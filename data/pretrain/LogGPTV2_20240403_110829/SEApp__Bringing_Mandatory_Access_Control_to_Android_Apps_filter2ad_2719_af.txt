separation on stock Android. In CCS, 2017.
[56] J. Vander Stoep. ioctl command whitelisting in SELinux. http:
//kernsec.org/files/lss2015/vanderstoep.pdf, 2015.
[57] K. MacMillan, C. Case, J. Brindle, and C. Sellers. SELinux
Common Intermediate Language motivation and design.
https://github.com/SELinuxProject/cil/wiki, 2020.
[58] R. Mayrhofer, J. Vander Stoep, C. Brubaker, and N. Kralevich.
The Android platform security model. arXiv, 2019.
[59] D. Muthukumaran, T. Jaeger, and V. Ganapathy. Leveraging
“choice” to automate authorization hook placement. In CCS,
2012.
[60] M. Ongtang, S. McLaughlin, W. Enck, and P. McDaniel. Se-
In
mantically rich application-centric security in Android.
ACSAC, 2009.
[61] P. Pearce, A.P. Felt, G. Nunez, and D. Wagner. AdDroid:
Privilege separation for applications and advertisers in Android.
In ASIACCS, 2012.
[62] Android Open
Source
Project.
PackageParser.
https://android.googlesource.com/platform/
frameworks/base/+/master/core/java/android/
content/pm/PackageParser.java, 2021.
[63] R. Sandhu and P. Samarati. Authentication, access control, and
audit. CSUR, 1996.
[64] U. Shankar, T. Jaeger, and R. Sailer. Toward automated
information-ﬂow integrity veriﬁcation for security-critical ap-
plications. In NDSS, 2006.
[65] S. Smalley and R. Craig. Security Enhanced (SE) Android:
Bringing ﬂexible MAC to Android. In NDSS, 2013.
[66] Statista.
Most popular
development
ware
apps worldwide
//www.statista.com/statistics/1035623/leading-
mobile-app-ad-network-sdks-android/, 2020.
as of September 2020.
installed ad network soft-
(SDKs)
across Android
https:
kits
[67] The SELinux Project.
Type Enforcement.
https://
selinuxproject.org/page/NB_TE, 2015.
[68] The SELinux Project.
libselinux. https://github.com/
SELinuxProject/selinux/tree/master/libselinux,
2021.
[69] Unity. Unity Ads. https://unity.com/solutions/unity-
ads, 2021.
[70] C. Wright, C. Cowan, J. Morris, James, S. Smalley, and
G. Kroah-Hartman. Linux Security Module framework. In
Ottawa Linux Symposium, 2002.
[71] Z. Xiao, A. Amit, and D. Wenliang. AFrame: Isolating adver-
tisements from mobile applications in Android. In ACSAC,
2013.
[72] Zerodium. Zerodium - The leading exploit acquisition platform.
https://zerodium.com, 2021.
A Application of SEApp
In this Section we give a technical demonstration of the
security measures introduced by SEApp. The description is
based on the showcase app presented in Section 3. We show
that: (1) the showcase app can operate without a policy mod-
ule; in this mode, its vulnerabilities can be exploited; (2) the
showcase app can also operate with the policy module listed in
Appendix A.4 and use the services offered by SEApp; in this
mode, the internal vulnerabilities are no longer exploitable.
The showcase app has a minimal structure. Its entry point is
the MainActivity, which is associated with the core_logic pro-
cess. From the MainActivity it is possible to send a startActiv-
ity intent to one among UseCase1Activity, UseCase2Activity
and UseCase3Activity; the entry points of use cases 1, 2 and 3,
respectively. For each entry point Zygote starts a dedicated
process and, according to the content of the seapp_contexts
(in Listing 4), assigns its speciﬁc domain (user_logic_d to
UC#1, ads_d to UC#2, media_d to UC#3). A dedicated de-
scription of each use case follows.
A.1 Use case 1
In this use case we demonstrate how an app could beneﬁt
from the ﬁne-granularity access to ﬁles. In particular, we
3628    30th USENIX Security Symposium
USENIX Association
show how the UseCase1Activity, suffering of a path traversal
vulnerability, cannot be exploited when the app is associated
with a properly conﬁgured policy module. According to the
Google Play Protect report on common application vulnera-
bilities [51], unsanitized path names that lead to path traversal
are a primary source of problems in applications.
UseCase1Activity is quite simple: it displays the content of
a ﬁle given its relative path through an intent. While this
may be ﬁne when the intent comes from trusted compo-
nents, the activity supports also implicit intents coming from
untrusted sources. This makes the vulnerability easily ex-
ploitable by an attacker targeting the conﬁdential ﬁles written
by the core_logic components.
In our setup phase, we leverage MainActivity to create an
internal directory structure by using the android.os.File
abstraction, which sets ﬁle and directory context upon its cre-
ation (see Section 6.2.2). Two directories are created: user/
and confidential/; inside both folders a ﬁle data is saved.
To test this use case, we ﬁrst start UseCase1Activity, then
we send an intent to “confuse” UseCase1Activity into showing
us the content of confidential/data. This can be done via
ADB with the command:
adb shell am start
-n com . example . showcaseapp /. UseCase1Activity
-a " com . example . showcaseapp . intent . action . SHOW "
--es " com . example . showcaseapp . intent . extra . PATH "
"../ confidential / data "
When the policy module is missing, all internal ﬁles are
ﬂagged with app_data_file and every app component exe-
cutes within the untrusted_app domain, which holds read
access to app_data_file. As a consequence the vulnerabil-
ity is successfully exploited and UseCase1Activity shows the
content of the confidential/data ﬁle.
Instead, when the policy module is enforced by SEApp, the
ﬁle confidential/data is ﬂagged with confidential_t,
as indicated in line 2 in file_contexts (see Listing 5).
Since no permission is granted on confidential_t in the
sepolicy.cil to user_logic_d, any access to the ﬁle
confidential/data by UseCase1Activity is blocked by
SELinux. The following denial is written to the system log: de-
nied search to user_logic_d domain on confidential_t
type. The confidential directory cannot then be accessed
despite the exploitation of the path traversal vulnerability.
A.2 Use case 2
In this use case we show how to conﬁne an Ad library into an
ad-hoc process, with guarantees that it cannot abuse the access
privileges granted to the whole application sandbox by the
user. To do that, we deliberately inject, in the same process the
library is executed, a malicious component (which is directly
invoked by the library) that tries to capture the location when
the permission ACCESS_FINE_LOCATION is granted to the
app. The Ad library used is Unity Ads [69], which according
to [66] in 2020 was used by 11% of apps that show ads.
In this case the library is invoked by UseCase2Activity,
and according to line 3 of the seapp_contexts, both the
activity and the components created by the library are ex-
ecuted by Zygote in a process labeled with ads_d. To in-
teract with the Ad library, UseCase2Activity instances a
UnityAdsListener. After the Ad initialization (including
the registration of the listener) and displaying the Ad to the
user, the Ad framework invokes the listener callback method
onUnityAdsFinish, which executes the malicious routine
captureLocation. The routine probes the app permissions;
if ACCESS_FINE_LOCATION was granted to the app, the
malicious component retrieves through the servicemanager a
handle to the LocationManager, and registers to it an asyn-
chronous listener that captures GPS location.
We show that when the policy module is enforced by
SEApp, the malicious component cannot access the GPS co-
ordinates. This is because the component is executed in the
same process of the library, which is labeled with ads_d. If we
look at the sepolicy.cil (lines 43-50), ads_d is not granted
access to the SELinux type location_service, so the ma-
licious routine cannot retrieve and therefore connect to the
location_service. The following denial is written to the sys-
tem log: denied find on location_service to the ads_d
domain. As a result, the malicious component is terminated
by the ActivityTaskManager.
The Ad library was included in the app as an .aar archive.
To conﬁne it, no modiﬁcation was necessary, only the use of
AndroidManifest.xml and sepolicy.cil was required.
A.3 Use case 3
In this use case we show how to conﬁne a set of components,
which rely on a high performance native library written in
C to perform some task. Our goal is to demonstrate that the
context running the native library code is prevented to ac-
cess the network, even when the permissions INTERNET and
ACCESS_NETWORK_STATE are granted to the app sandbox.
The native library is invoked by UseCase3Activity, which,
according to line 4 in the seapp_contexts, is executed
in a process labeled with media_d by Zygote. The call to
the library is performed via JNI. Its job is to connect to
the camera_service and take a picture. Since the app is
granted the CAMERA permission, the native library code
(legitimately, line 53 in the sepolicy.cil) connects to the
CameraManager.
Since the native library performs image processing, we do
not want it to access the network. However, the permissions
INTERNET and ACCESS_NETWORK_STATE are granted to
the app, as they are required by the Ads framework. Thus,
when the policy module is missing, the native library can con-
nect to the ConnectivityManager and successfully bind the
current process to the network. Instead, when the policy mod-
ule is enforced by SEApp, since media_d was granted only
the basic app permissions (line 11 in sepolicy.cil), the
USENIX Association
30th USENIX Security Symposium    3629
connection to the network is forbidden. This happens because
binding a process to the network is associated with opening a
network socket, an operation not permitted by SELinux with-
out the required permissions. The following denial is written
to the system log: denied create on udp_socket to media_d
domain.
This use case, besides showing how SEApp conﬁnes a
native library, also demonstrates the power and simplic-
ity of the macro, as adding the line (call md_netdomain
(media_d)) to the policy module grants to media_d the
needed permissions to access the network. The application de-
veloper is thus not required to know or understand the internal
SELinux policy in order to leverage this functionality.
The isolation properties introduced by SEApp applies also
to other common security problems presented in [51]. Just
to mention one, SEApp can mitigate the impact of incorrect
sandboxing of a scripting language.
A.4 Showcase app policy module
Here we report the showcase app policy module ﬁles.
1 user = _app seinfo = showcase_app domain =
com_example_showcaseapp . core_logic_d name = com .
example . showcaseapp : core_logic levelFrom = all
2 user = _app seinfo = showcase_app domain =
com_example_showcaseapp . user_logic_d name = com .
example . showcaseapp : user_logic levelFrom = all
3 user = _app seinfo = showcase_app domain =
com_example_showcaseapp . ads_d name = com . example .
showcaseapp levelFrom = all
4 user = _app seinfo = showcase_app domain =
com_example_showcaseapp . media_d name = com .
example . showcaseapp : media levelFrom = all
Listing 4: showcase app seapp_contexts
1 .*
2 files / confidential
u: object_r : app_data_file : s0
u: object_r :
com_example_showcaseapp . confidential_t : s0
3 files / ads_cache
u: object_r :
com_example_showcaseapp . ads_t : s0
Listing 5: showcase app ﬁle_contexts
1 
2 
3 
4  
5  
Listing 6: showcase app mac_permissions.xml
1 ( block com_example_showcaseapp
2 ; creation of domain types
3 ( type core_logic_d )
4 ( call md_untrusteddomain ( core_logic_d ))
5 ( type user_logic_d )
6 ( call md_appdomain ( user_logic_d ))
7 ( type ads_d )
8 ( call md_appdomain ( ads_d ))
9 ( call md_netdomain ( ads_d ))
10 ( type media_d )
11 ( call md_appdomain ( media_d ))
12 ( typeattribute domains )
13 ( typeattributeset domains ( core_logic_d
user_logic_d ads_d media_d ))
14 ; creation of file types
15 ( type confidential_t )
16 ( call mt_appdatafile ( confidential_t ))
17 ( type ads_t )
18 ( call mt_appdatafile ( ads_t ))
19 ; bounding the domains and types
20 ( typebounds untrusted_app core_logic_d )
21 ( typebounds untrusted_app user_logic_d )
22 ( typebounds untrusted_app ads_d )
23 ( typebounds untrusted_app media_d )
24 ( typebounds app_data_file confidential_t )
25 ( typebounds app_data_file ads_t )
26 ; grant core_logic_d access to confidential files
27 ( allow core_logic_d confidential_t ( dir ( search
write add_name )))
28 ( allow core_logic_d confidential_t ( file ( create
getattr open read write )))
29 ; grant ads_d access to ads_cache files
30 ( allow ads_d ads_t ( dir ( search write add_name )))
31 ( allow ads_d ads_t ( file ( create getattr open read
write )))
32 ; minimum app_api_service subset
33 ( allow domains activity_service ( service_manager
( find )))
34 ( allow domains activity_task_service (
service_manager ( find )))
35 ( allow domains ashmem_device_service (
service_manager ( find )))
36 ( allow domains audio_service ( service_manager (
find )))
37 ( allow domains surfaceflinger_service (
service_manager ( find )))
38 ( allow domains gpu_service ( service_manager ( find
)))
39 ; grant core_logic_d the needed permissions
40 ( allow core_logic_d restorecon_service (
service_manager ( find )))
41 ( allow core_logic_d location_service (
service_manage r( find )))
42 ; grant ads_d access to unity3ads needed services
43 ( allow ads_d radio_service ( service_manager ( find
)))
44 ( allow ads_d webviewupdate_service (
service_manager ( find )))
45 ( allow ads_d autofill_service ( service_manager (
find )))
46 ( allow ads_d clipboard_service ( service_manager (
find )))
47 ( allow ads_d batterystats_service ( service_manager
( find )))
48 ( allow ads_d batteryproperties_service (
service_manager ( find )))
49 ( allow ads_d audioserver_service ( service_manager
( find )))
50 ( allow ads_d mediaserver_service ( service_manager
( find )))
51 ; grant media_d the needed permissions
52 ( allow media_d autofill_service ( service_manager
( find )))
53 ( allow media_d cameraserver_service (
service_manager ( find ))))
Listing 7: showcase app sepolicy.cil
3630    30th USENIX Security Symposium
USENIX Association