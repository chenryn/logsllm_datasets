/ / Requirement: k f u l f i l l s a l l SIs
requires P OpsProperties ( k , op )
/ / Requirement: For operation ,
/ / p r e c o n d i t i o n s always imply i t s p o s t c o n d i t i o n s
i t s
requires P O p s F u l f i l l P r e C o n d i t i o n s ( k , op )
/ / Requirement:
/ /
then i t must
the c u r r e n t s t a t e k
/ /
I f operation  takes place ,
f u l f i l l a l l
i t s p r e c o n d i t i o n s on
ensures I s V a l i d S t a t e ( r e s u l t . 0 ) ∧
IsSecureState ( r e s u l t . 0 )
/ / Property : The r e s u l t s t a t e f u l f i l l s a l l SIs
/ /
r e s u l t .0 i s the r e s u l t s t a t e
ensures IsSecureOps ( k ,
r e s u l t . 0 )
/ / Property : The operation  f u l f i l l s a l l TCs
/ / defined i n IsSecureOps
i f ( op . DrvReadOp?)
then
else i f
else i f
var k ’ , d : | DrvRead PostConditions ( k , op . drv sid ,
op . read objs , op . tds dst src , op . fds dst src ,
op . dos dst src , k ’ , d ) ;
( op . DevReadOp?)
var k ’ , d : | DevRead PostConditions ( k , op . dev sid ,
op . read objs , op . tds dst src , op . fds dst src ,
op . dos dst src , k ’ , d ) ;
( op . DevWriteOp ?)
var k ’ , d : | DevWrite PostConditions ( k ,
( k ’ , d )
( k ’ , d )
then
then
then
then
then
op . dev sid , op . td id val map , op . fd id val map ,
op . do id val map , k ’ , d ) ;
( op . EmptyPartitionCreateOp ?)
( k ’ , d )
then
( op . DevActivateOp ?)
( op . DrvActivateOp ?)
( op . DrvDeactivateOp ?)
( op . EmptyPartitionDestroyOp ?)
var k ’ , d : | Common PostConditions ( k , k ’ , d ) ;
( k ’ , d )
var k ’ , d : | Common PostConditions ( k , k ’ , d ) ;
( k ’ , d )
var k ’ , d : | Common PostConditions ( k , k ’ , d ) ;
( k ’ , d )
var k ’ , d : | Common PostConditions ( k , k ’ , d ) ;
( k ’ , d )
var k ’ , d : | Common PostConditions ( k , k ’ , d ) ;
( k ’ , d )
var k ’ , d : | Common PostConditions ( k , k ’ , d ) ;
( k ’ , d )
var k ’ , d : | Common PostConditions ( k , k ’ , d ) ;
( k ’ , d )
var k ’ , d : | Common PostConditions ( k , k ’ , d ) ;
( k ’ , d )
var k ’ , d : | DrvWrite PostConditions ( k , op . drv sid ,
( op . ExternalObjsDeactivateOp ?)
( op . ExternalObjsActivateOp ?)
( op . DevDeactivateOp ?)
then
then
then
then
else i f
else i f
else i f
else i f
else i f
else i f
else i f
else i f
else
op . td id val map , op . fd id val map ,
op . do id val map , k ’ , d ) ;
( k ’ , d )
Fig. 10. K CALCNEWSTATE: example of a state transition
{
}
C. Axioms, State Invariants and Transition Constraints for I/O
Separation Model
Axioms. To prove that the I/O separation model is secure we
use the following ﬁve intuitive axioms (formally deﬁned in
Dafny speciﬁcations).
Ax1 All TDs have ﬁnite range of values.
Ax2 Only active subjects can issue transfers to objects.
Ax3 Hardcoded TDs cannot be accessed by drivers.
Ax4 A device performs a transfer to an object only if the
device can issue a transfer (Section IV-B1).
Ax5 The set of all subjects and objects are known a priori;
i.e., in either active or inactive state.
Axiom Ax1 is required by the termination of the transitive-
Authorized licensed use limited to: Tsinghua University. Downloaded on February 25,2022 at 12:32:26 UTC from IEEE Xplore.  Restrictions apply. 
587
closure computation. Axiom Ax2 states a basic tenet of all
state-transition models, while Ax3 reﬂects a common access
restriction on drivers; Axiom Ax4 deﬁnes the basic device
ability to issue transfers. Axiom Ax5 ﬁxes the domain of
the model operations, and is standard in all state-transition
models. Note that this axiom does not prevent the modeling
of device and driver install and uninstall operations, which are
now represented by activation and deactivation operations.
State Invariants. The I/O separation model deﬁnes the fol-
lowing state invariants for a secure system state:
1. Drivers and devices must have different subject IDs.
2. The set of subjects must not be empty.
3. TDs, FDs and DOs must have different object IDs.
4. The set of objects must not be empty.
5. Each device’s TDs must include its hardcoded TD.
6. No two subjects associate (own) the same object.
7. Objects associated with any subjects must exist
in the
system states’ objects.
8. No hardcoded TDs deﬁne direct transfers to a TD with both
read and write access modes.
9. Hardcoded TDs do not reference any hardcoded TDs.
10. Objects referenced in a device’s hardcoded TD must be
associated with the device.
11. Arbitrary set of TDs in the system state have ﬁnite ranges.
12. Only hardcoded TDs and active objects have values.
13. The partition IDs of the system state do not include NULL.
14. (SI1) For any TD state of a transitive closure in a system
state, if a TD can be read by an active device, then objects
referenced in that TD (i) must be in the same partition as
its referenced objects, and (ii) must not be hardcoded TDs.
15. All objects associated with a subject must be in the same
partition with the subject.
16. Active subjects and objects must belong to existing parti-
tions.
Transition Constraints. The I/O separation model deﬁnes the
following transition constraints:
1. IDs of objects and hardcoded TDs associated with subjects
must be immutable in transitions.
2. (TC1) Only hardcoded TDs can be reused in a new partition
with non-NULL partition IDs.
3. Hardcoded TDs’ values must be immutable in transitions.
D. Computing Transitive closure
Let a TD state contains the values of all active TDs in the
current state. The transitive closure of a TD state is the set of
all reachable TD states from that state via TD writes. The
implementation uses two mutually recursive functions. The
ﬁrst function discovers all direct TD writes that can be issued
by a device in one TD state, via a breadth-ﬁrst-search (BFS)
algorithm, which starts from the device’s hardcoded TD, and
constructs and traverses the graph of TDs that can be read by
the device. After discovering all TDs that can be read by the
device, this function iterates over all their entries and outputs
all TD writes enabled by these entries. The second function
uses the output of the ﬁrst function, constructs and traverses
Operation mapping: concrete to I/O separation model
TABLE I
Operations in I/O
separataion model
DrvWrite
DevWrite
DrvRead
DevRead
EmptyPartitionCreate
EmptyPartitionDestroy
DrvDeactivate
DevDeactivate
DrvActivate
DevActivate
ExternalObjsActivate
ExternalObjsDeactivate
Operations in concrete model
DM RedDrvWrite
DM GreenDrvWrite
DM RedDevWrite
DM GreenDevWrite
DM RedDrvRead
DM GreenDrvRead
DM DevRead
DM EmptyPartitionCreate
DM EmptyPartitionDestroy
DM GreenDrvDeactivate
DM DevDeactivate
DM DrvActivateToGreenPartition
DM DrvActivateToRedPartition
DM DevActivate
DM ExternalObjsActivateToGreenPartition
DM ExternalObjsActivateToRedPartition
DM GreenExternalObjsDeactivate
DM RedExternalObjsDeactivate
WK operations as concatenations of concrete operations.
TABLE II
Operations in
concrete model
DM RedDrvRead
DM GreenDrvRead
DM DevRead
DM RedDrvWrite
DM GreenDrvWrite
DM RedDevWrite
DM GreenDevWrite
DM EmptyPartitionCreate
DM EmptyPartitionDestroy
DM DevActivate
DM DevDeactivate
DM GreenDrvDeactivate
DM ExternalObjsActivate
ToGreenPartition
DM ExternalObjsActivate
ToRedPartition
Operations in
(correct) WK design
WSD OSDrvRead
WSD WimpDrvRead
WSD DevRead
WSD OSDrvWrite
WSD WimpDrvWrite
WSD OSDevWrite
WSD WimpDevWrite
WKD EmptyPartitionCreate
WKD EmptyPartitionDestroy
WSD DevActivate
WSD DevDeactivate
WKD GreenDrvDeactivate
WKD ExternalObjsActivate
ToGreenPartition
WKD ExternalObjsActivate
ToRedPartition
DM DrvActivateToGreenPartition
WKD DrvActivateToGreenPartition
DM GreenExternalObjsDeactivate
DM RedExternalObjsDeactivate
DM DevActivate || DM DevActivate ...
WKD GreenExternalObjsDeactivate
WKD RedExternalObjsDeactivate
WKD MultiDevs ReturnOS
a graph of TD states with the BFS algorithm, and outputs all
potential states that enable I/O transfers.
The transitive-closure computation always terminates since
the set of TDs is ﬁnite, and each TD has a ﬁnite set of values. It
terminates even when TD graphs are cyclic. Thus, the number
of all possible TD states is ﬁnite.
APPENDIX B
Operation Reﬁnements. Table I shows the operation mapping
from the concrete model to the I/O separation model, while
Table II illustrates the operations of the correct Wimpy kernel
as concatenations of concrete model operations. Table III
shows the operation mapping from the sound Wimpy kernel
design to its implementation speciﬁcations.
APPENDIX C
FFIs for WK Implementation A breakdown of the FFIs
that WK implemented is as follows. 9 of these FFIs invoke
APIs provided by the underlying micro-hypervisor (mHV )
Authorized licensed use limited to: Tsinghua University. Downloaded on February 25,2022 at 12:32:26 UTC from IEEE Xplore.  Restrictions apply. 
588
Operation mapping: WK design to implementation. (“/” denotes operations with the same preﬁx or sufﬁx. And WSD DevWrite wraps both
WSD OSDevWrite and WSD WimpDevWrite, and is for all active devices.)
TABLE III
Operations in (correct) WK design
WKD EmptyPartition
Create/Destroy
WKD DrvActivateToGreenPartition
WKD GreenDrvDeactivate
WSD DevActivate/Deactivate
WKD ExternalObjsActivateToGreenPartition
WKD GreenExternalObjsDeactivate
WSD WimpDrvWrite
WKD MultiDevs ReturnOS
WKD ExternalObjsActivateToRedPartition
WKD RedExternalObjsDeactivate
WSD WimpDrvWrite
WSD WimpDrvRead
WK APIs
WK EmptyPartition
Create/Destroy
WimpDrv Activate
WimpDrv Deactivate
USBPDev Activate/Deactivate
EEHCI Activate/Deactivate
USBTD slot allocate 1slot
USBTD slot deallocate 1slot
USBTD slot submit and verify qtd32/qh32
OS Activate AllReleasedPEHCIsAndUSBPDevs
OS Activate MainMem ByPAddr
OS Deactivate MainMem ByPAddr
WimpDrv Write eEHCI Conﬁg/Status/USBTDReg
WimpDrv Read eEHCI Conﬁg/Status/USBTDReg
Operations in (correct) WK design
Direct I/O Accesses
WSM OSDrvRead ByPAddr/PIO/ObjIDs
WSM OSDevRead ByPAddr/PIO
WSM OSNonUSBPDevRead ByObjIDs
WSM OSDrvWrite ByPAddr/PIO/ObjIDs
WSM OSDevWrite ByPAddr/PIO
WSM OSNonUSBPDevWrite ByObjIDs
WSM WimpDrvRead/Write ByPAddr
WSM USBPDevRead/Write ByObjID
WSM EEHCIReadOwnObjs ByOffset
WSM EEHCIReadUSBTD BySlotID
WSM EEHCIReadUSBPDevObj ByObjID
WSM EEHCIReadObjs ByPAddr
WSM EEHCIWriteOwnDO ByOffset
WSM EEHCIWriteUSBPDevObj ByObjID
WSM EEHCIWriteObjs ByPAddr
accesses and WK APIs are atomic, and is typical of state-
transition models. (The WK implementation uses additional 15
Dafny assume statements for trivial utility lemmas for similar
proof simpliﬁcation purpose.)
WSD OSDrvRead
WSD DevRead
WSD OSDrvWrite
WSD OSDevWrite
WSD WimpDrvRead/Write
WSD DevRead/Write*
WSD DevRead
WSD WimpDevWrite
and by internal code used by the WK APIs. That is, 4 APIs
are provided by mHV to move main memory areas between
OS/Apps and isolated drivers on-demand, and 3 APIs are pro-
vided by internal WK code that creates, destroys, and separates
ephemeral USB HCs on demand. Another API implements the
clearing of all mutable objects of USB peripheral devices. The
last API enables isolated drivers to clear data objects (DOs)
in their memory. Furthermore, WK code includes FFIs for
internal functions that support different versions of USB buses;
e.g., USB IDS memory moves, data structure parsing.
Axioms for WK Implementation A further breakdown of the
105 axioms is as follows. 37 axioms refer to the correctness
of arithmetic and bit-oriented operations. 50 axioms assert
that the mappings implemented object values and operations
to those of the WK design are valid; e.g., the mapping of
I/O access parameters to abstract object identiﬁers and values
of design speciﬁcations is formatted properly. These axioms
are valid because the mappings from WK implementation
speciﬁcations to those of WK design have easily checkable
formats. 9 axioms refer to trivial hardware properties of OS
devices, USB host controllers, peripheral devices and IDSes,
and to the memory properties of device drivers; e.g., they
constrain valid I/O objects values, and IDSes deﬁning transfers
to a USB device always deﬁne transfers to all its FDs and
DOs. 7 axioms state that the memory layout of WK code,
stack, and globals are valid. One axiom asserts the validity
of ID mappings of USB TDs. Another axiom asserts that I/O
Authorized licensed use limited to: Tsinghua University. Downloaded on February 25,2022 at 12:32:26 UTC from IEEE Xplore.  Restrictions apply. 
589