with addresses of functions used later during execution.
These functions include kernel32.WaitForSingleObject,
kernel32.CreateProcessA,
kernel32.ExitThread,
ws2_32.WSAStartup, ws2_32.WSASocketA, ws2_32.bind,
ws2_32.listen, ws2_32.accept and ws2_32.closesocket.
is identiﬁed.
ws2_32.WSAStartup is called to initialise the WinSock API
and then a socket is created using ws2_32.WSASocketA.
listen and accept is called to bind the socket to
Bind,
port 9999,
listen for incoming connections and accept
connections from the attacker at a later stage.
The DLL hooking method implemented using Detours
[7] logs resource usage by identifying calls to DLL func-
tions. Table 4 contains some of the library calls the attack
executes during runtime. The library trace starts with the
ws2_32.WSASocketA call to create the socket and ends with
the ws2_32.accept call when the process is in the state wait-
ing for the attacker to connect to the host.
The log positively identiﬁes the attack and provides suf-
ﬁcient information to identify the operations of the attack.
DLL ﬁles loaded during execution are identiﬁed as well as a
socket creation and subsequent calls to bind, listen and ac-
cept. The execution trace ends with the call to accept which
indicates that the process is in a state waiting for incoming
connections. This is sufﬁcient to determine that the exploit
attempts to start a server. Table 5 contains a list of the ex-
ploits we have tested together with the vulnerability they
exploit and information whether the attack was detected or
not. For attacks that could not be detected, detection failed
because we could not identify the ﬁrst executable instruc-
tion accurately.
In these cases the ﬁrst instruction of the
exploit code was inserted directly into the analyser to gen-
erate the function call log. By analysing the logs generated,
the ﬁrst exploit adds an administrator user to the vulner-
able host, exploits 2, 3 and 4 spawn a listening shell on
ports 5555, 9999 and 101 respectively, and exploit 5 and
6 attempt to connect to an outside host to download more
executable code.
The shellcode sandboxing approach has proven to have
excellent accuracy and completeness properties when im-
plemented correctly. During testing for the Linux operat-
ing environment all attacks tested were detected as well as
all code injection attacks contained in the DARPA intrusion
detection evaluation dataset without any false positives [2].
False positives are unlikely events when this approach is ap-
plied due to the difference in appearance of shellcode and
normal binary executables. Shellcode has higher density of
calls and due to its size long jumps never occur except for
calls directly to DLL functions. We have however tested the
detector on 3GB of Windows binary ﬁle transmission using
the NOP executable instruction detection approach without
recording any false positives.
8. Conclusion and Future Work
We have presented a framework for detecting code in-
jection attacks in a heterogeneous environment. The frame-
work is able to detect new or previously unseen attacks
regardless of obfuscation techniques applied. The ap-
Proceedings of the 21st Annual Computer Security Applications Conference (ACSAC 2005) 
1063-9527/05 $20.00 © 2005 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 12:07:54 UTC from IEEE Xplore.  Restrictions apply. 
Table 2. fp30reg.dll exploit
\xEB\x03\x5D\xEB\x05\xE8\xF8\xFF\xFF\xFF\x8B\xC5\x83\xC0\x11\x33
\xC9\x66\xB9\xC9\x01\x80\x30\x88\x40\xE2\xFA
\xDD\x03\x64\x03\x7C\x09\x64\x08\x88\x88\x88\x60\xC4\x89\x88\x88
.......
Table 3. Decoding routine
Memory Address Machine Instruction Assembly
00421A41
00421A45
00421A48
00421A49
66 B9 C9 01
80 30 88
40
E2 FA
MOV CX, 1C9
XOR BYTE PTR DS: [EAX], 88 Key is 88H
INC EAX
LOOPD SHORT 00421A45
Comment
Length of payload
proach consists of an IDS that identiﬁes potentially exe-
cutable instructions and sends the payload of the packet to a
monitored execution environment to determine whether the
packet indeed contains executable code. The appropriate
execution environment is selected based on the IP address
of the incoming packet.
The execution environment for Windows code is also
presented in this paper. We have compared two tracing ap-
proaches and determined that the DLL hooking approach
currently performs better than that of the Native API moni-
toring approach. However, since attacks using only the na-
tive API may be missed, future work includes further ex-
amination of methods to perform system call monitoring in
the Windows environment. The prototype implementation
of the system is capable of detecting Windows code injec-
tion attacks as long as the IDS is able to identify executable
instructions in a packet. Although the accuracy of the sys-
tem is very good, the completeness property will never be
better than the ability of the IDS to identify executable in-
structions. The NOP detection approach, although having
moderate success during testing, does not identify all code
injection attacks targeting Windows hosts. Future work in-
cludes identifying a more efﬁcient algorithm to detect po-
tentially executable instructions in a network stream so that
the completeness property of the system can be further in-
creased.
References
[1] S. Andersson, A. Clark, and G. Mohay. Network based
buffer overﬂow detection by exploit code analysis.
In
G. Mohay, A. Clark, and K. Kerr, editors, Proceedings
of AusCERT Asia Paciﬁc Information Technology Security
Conference (AusCERT2004): R&D Stream, Gold Coast,
Australia, 2004. University of Queensland. ISBN: 1-86499-
774-5.
[2] S. Andersson, A. Clark, and G. Mohay. Detecting network-
based obfuscated code injection attacks using sandboxing.
In A. Clark, K. Kerr, and G. Mohay, editors, AusCERT
Asia Paciﬁc Information Technology Security Conference
(AusCERT2005): Refereed R&D Stream, Gold Coast, Aus-
tralia, 2005. University of Queensland. ISBN: 1-86499-799-
0.
[3] P.
Windows
syscall
Bania.
http://www.securityfocus.com/infocus/1844, 2005.
cessed: 16/09-05.
shellcode.
Ac-
[4] R. Battistoni, E. Gabrielli, and L. V. Mancini. A host intru-
sion prevention system for windows operating systems. In
ESORICS, volume 3193 of LNCS, pages 352–369. Springer-
Verlag, 2004.
[5] J. Beale, J. C. Foster, J. Posluns, and B. Caswell. Snort 2.0
Intrusion Detection. Syngress Publishing, Rockland, 2003.
[6] H. Debar, M. Dacier, and A. Wespi. Towards a taxonomy of
intrusion-detection systems. Computer Networks, 31, 1999.
[7] G. Hunt and D. Brubacher. Detours: Binary interception of
Win32 functions. In Proceedings of the 3rd USENIX Win-
dows NT Symposium, Seattle, WA, 1999.
[8] Y. Kaplan. API spying techniques for Windows 9x, NT and
2000. http://www.internals.com/articles/apispy/apispy.htm,
2000. Accessed: 16/09-05.
[9] D. Mutz, C. Kruegel, W. Robertson, G. Vigna, and R. Kem-
merer. Reverse engineering of network signatures.
In
A. Clark, K. Kerr, and G. Mohay, editors, AusCERT
Asia Paciﬁc Information Technology Security Conference
(AusCERT2005): Refereed R&D Stream, Gold Coast, Aus-
tralia, 2005. University of Queensland. ISBN: 1-86499-799-
0.
[10] M.
the Native API.
Russinovich.
Inside
http://www.sysinternals.com/Information/NativeApi.html,
2004. Accessed: 16/09-05.
[11] S. B. Schreiber. Undocumented Windows 2000 Secrets. Ad-
dison Wesley, Upper Saddle River, 2001.
[12] T. Toth and C. Kruegel. Accurate buffer overﬂow detec-
tion via abstract payload execution. In Recent Advances in
Intrusion Detection, volume 2516 of Lecture Notes in Com-
puter Science, pages 274–291, Zurich, Switzerland, 2002.
Springer.
Proceedings of the 21st Annual Computer Security Applications Conference (ACSAC 2005) 
1063-9527/05 $20.00 © 2005 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 12:07:54 UTC from IEEE Xplore.  Restrictions apply. 
WSASocketA(2,1,0,0,0,0)
WSASocketW(2,1,0,0,0,0)
.
Table 4. Detours exploit trace
LoadLibraryA(C:\WINNT\system32\msafd.dll)
LoadLibraryExA(C:\WINNT\system32\msafd.dll,0,0)
LoadLibraryExW(C:\WINNT\system32\msafd.dll,0,0)
.
LoadLibraryExW(„) -> 74fd0000
LoadLibraryExA(„) -> 74fd0000
LoadLibraryA() -> 74fd0000
GetProcAddress(74fd0000,WSPStartup)
GetProcAddress(,) -> 74fd1f1c
GetModuleFileNameA(74fd0000,12f3fc,104)
GetModuleFileNameW(74fd0000,131fc0,104)
GetModuleFileNameW(,C:\WINNT\system32\msafd.dll,) -> 1b
GetModuleFileNameA(,C:\WINNT\system32\msafd.dll,) -> 1b
LoadLibraryA(C:\WINNT\system32\msafd.dll)
LoadLibraryExA(C:\WINNT\system32\msafd.dll,0,0)
LoadLibraryExW(C:\WINNT\system32\msafd.dll,0,0)
GetEnvironmentStringsW()
GetEnvironmentStringsW() -> =::=::\
LoadLibraryExW(„) -> 74fd0000
LoadLibraryExA(„) -> 74fd0000
LoadLibraryA() -> 74fd0000
ExpandEnvironmentStringsW(%SystemRoot%\System32\wshtcpip.dll,13a9d0,104)
ExpandEnvironmentStringsW(,C:\WINNT\System32\wshtcpip.dll,) -> 1f
LoadLibraryW(C:\WINNT\System32\wshtcpip.dll)
LoadLibraryExW(C:\WINNT\System32\wshtcpip.dll,0,0)
GetEnvironmentStringsW()
GetEnvironmentStringsW() -> =::=::\
DisableThreadLibraryCalls(75010000)
DisableThreadLibraryCalls() -> 1
LoadLibraryExW(„) -> 75010000
LoadLibraryW() -> 75010000
GetProcAddress(75010000,WSHOpenSocket)
.
GetProcAddress(75010000,WSHIoctl)
GetProcAddress(,) -> 75012d73
..
WSASocketW(„„,) -> 74
WSASocketA(„„,) -> 74
bind(74,12fcc4,16)
ntohs(f27)
htons(f27)
htons() -> 270f
ntohs() -> 270f
bind(„) -> 0
listen(74,0)
listen(,) -> 0
accept(74,12ffb0,0)
WSAAccept(74,12ffb0,0,0,0)
Table 5. Exploit table
Source
Detected
Vulnerability Exploit
MS03-039
MS03-049
MS03-051
MS04-011
MS04-011
MS04-045
/ExploitTree/system/microsoft/remote/MS03-039-exp.c www.securityforest.com Yes
www.securityforest.com No
/ExploitTree/system/microsoft/remote/MS03-049ex.c
www.securityforest.com Yes
/ExploitTree/application/webserver/iis/fp30reg.c
/ExploitTree/system/microsoft/remote/ms04011lsass.c
www.securityforest.com No
Sasser.B
NA
Yes
Yes
www.hat-squad.com
WINS Remote Heap Overﬂow Exploit
Proceedings of the 21st Annual Computer Security Applications Conference (ACSAC 2005) 
1063-9527/05 $20.00 © 2005 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 12:07:54 UTC from IEEE Xplore.  Restrictions apply.