18.10
息，并且不同的消息需要使用不同顺序的这些参数时，～的e变体可能是有用的。
以零开始的参数索引，默认为0。在你想要使用不同的控制字符串来为同一组参数生成不同的消
202
①这类问题可能在试图本地化一个应用程序并将人类可读消息翻译成不同语言时出现。FORMAT可以对这些问题中
在下一章里，你将接触Common Lisp的状况系统，类似于其他语言的异常和错误处理系统。
还有更多的内容。我还没有提到~?指令，它可以从格式化参数中获取控制字符串；还有~/
的一些提供帮助，但绝不意味着它是一个全功能的本地化系统。
还有更多·……
第18章一些FORMAT秘诀
www.TopSage.com
---
## Page 220
medium，medium调用了1ow，那么当控制流在low中时，它也仍然在medium和high中，也就是
上的，诸如此类。功能的层次关系在运行期以调用栈的形式显示其自身：如果high调用了
内部工作的黑箱。程序随后由分层的函数构建而成：高层次的函数是构建在相对低层次的函数之
处理错误就总是可能作一个bug。
么你最好以某种方式处理这些错误，否则就会引入bug。因此，错误并不是由bug导致的，但忽视
或是令磁盘不再是满的。尽管如此，
情的代码停止工作。但这里没有bug，代码中没有可以修复的地方，以使那些不存在的文件存在
的服务器会崩溃，或者网络会断开。如果发生了任何这些情况，它可能使一些正在做你所想的事
出错，那么它终将出错：一个程序需要读取的文件会丢失，一个需要写入的磁盘会满，正在连接
来选择所使用的恢复策略。
码提供几种可能的方式从这样一个错误中恢复，以及允许该应用程序的最上层代码制定一种方针
看到如何使用状况系统，允许底层函数在解析日志文件时检测问题并产生一个错误，允许中层代
(restarting）。在本章里，我将描述你在假想的分析日志文件应用程序中如何使用状况系统。你将
代码，而是将责任分拆成三个部分：产生（signaling）状况，处理（handling）它以及再启动
告信息。不过，一开始我还是集中讨论错误处理。
出警告而不会中断产生警告的那些代码的执行，并允许调用栈中更高层的代码来控制是否打印警
调用栈中不同层次的代码都可能对这些事件感兴趣。例如，在19.6节里你将看到，状况可用来输
外一
那么，处理错误究竟意味着什么呢？在一个编写良好的程序中，每个函数都是一个隐藏了其
一开始，我将介绍一些术语。错误（error），我采用墨菲法则定义该术语。如果某件事可能
状况系统相比异常系统的更灵活之处在于，它没有明确划分产生错误?的代码和处理错误?的
②在Java/Python的术语中称为捕捉（catch）该异常。
①在Java/Python的术语中称为抛出（throw）或提升（raise）一个异常。
一“状况”相比“异常”更具一般性，因为状况可以代表程序执行过程中的任何事件，程序
一的异常处理系统有着相同的目标但更加灵活。事实上，它的灵活性扩展到了错误处理之
isp的状况系统（condition system）是它最伟大的特性之一。它与Java、Python和C++中
第19章
再启动
超越异常处理：
，如果程序的其余部分正在依赖于这些正打算进行的操作，那
www.TopSage.com
状况和
大家网
6
---
## Page 221
里出了问题，在Java或Python中会抛出一个异常。而在Common Lisp中会产生一个状况。
测到有问题的输入。当它检测到不对的输人后应当做什么呢？在C中会返回一个特殊值来指示这
可以返回代表该项的一个log-entry对象。该函数将从函数parse-log-file中调用，后者读取
取一个Web服务器的日志。在应用程序的某处，你将有一个函数用来解析单独的日志项。我们假
种特定的恢复策略，将决策留给高层函数中的代码。
码和决定如何恢复的代码分开。这样，你可以将恢复代码放在底层函数中而无须决定实际使用何
19.1Lisp 的处理方式
都是一个黑箱的理念相违背。
low中的错误，这需要同时对medium和low的内部工作原理有所了解，这并不恰当，与每个函数
重试）比较棘手，这要求high必须改变当前环境的状况，使得下一个对medium的调用不会导致
的工作的额外实现。并且当栈进一步展开时，还有更多工作需要重做。后一个选项（修补环境并
前一个选项在理论上是清晰的，但可能导致大量的额外代码，那将需要一个完整的对于medium
完成其工作，要么以某种方式改变一些，使对medium的调用能够发挥作用，然后再次调用它。
权将在high手中。在high处理错误时，它必须要么在无须得到任何来自medium的帮助的情况下
发生时底层代码所在的上下文中进行操作。
缺点：在搜索一个可恢复的函数时，栈被展开了，这意味着可以恢复错误的代码无法在错误实际
出一个异常来返回控制。使用异常比使用正常函数返回是巨大的进步，但两种模式有一个共同的
该错误要么让其自身失败。某些语言使用了正常的函数返回机制，而带有异常的语言可以通过抛
无论如何都要完成期待的工作。
在它之上的程序就没有必要知道曾经出现的问题一
都是一个黑箱，如果调用栈中的任何函数可能以某种方式完成其工作而无需关注底层错误，那么
者high也有问题了，诸如此类，一直沿着调用栈到达程序的最顶端。另一方面，由于每个函数
作low能够完成，如果low不能完成该工作，那么medium就有问题了。这意味着medium的调用
一个使它不能正常工作的错误将给它的所有调用者带来风险;medium调用1ow是因为它需要的工
都有一个需要完成的任务。其直接调用者（这里是medium）的工作是统计它的调用次数。不过，
说它们仍然在调用栈中。
一个完整的日志文件并返回代表该文件中所有日志项的对象列表。
为了保持简单性，parse-log-entry函数不需要解析不正确的格式化项。不过，它可以检
想想函数high、medium和low的假想调用链。如果low失败而medium无法恢复，那么决定
在多数语言里，错误的处理方式都是从一个失败的函数返回并给调用者一个机会，要么修复
由于每个函数都是一个黑箱，函数边界刚好是处理错误的最佳场所。每个函数（比如说1ow)
204
为了了解其工作原理，我们假设你正在编写一个读取某种文本日志文件的应用程序，例如读
CommonLisp的错误处理系统提供了一种跳出这一难题的方式，它将实际从错误中恢复的代
第19章 
超越异常处理：状况和再启动
www.TopSage.com
一那些函数所关心的只是它们所调用的函数
---
## Page 222
来构造新状况的初始化参数，然后它将实例化该状况。前者对于重新产生一个已有的状况对象偶
方式来调用ERROR：传给它一个已经实例化的状况对象，或者传给它该状况类的名字以及需要用
error。函数ERROR用来报错，它将调用底层函数SIGNAL并在状况未处理时进入调试器。有两种
19.3
保存传递给parse-log-entry的参数：
个子类。这样，你可以像下面这样定义malformed-log-entry-error，其中带有一个槽用来
非MAKE-INSTANCE来创建。MAKE-CONDITION基于其被传递的：initargs来初始化新状况的槽
值的槽分别指定:reader选项或:acces sor选项。同样，新的状况对象使用MAKE-CONDITION而
在状况对象上。特别地，一个状况的槽不能使用SLOT-VALUE来访问，必须为任何你打算使用其
是STANDARD-OBJECT的实例,因此一些你和DEFCLASS所定义类一起使用的函数不要求可以工作
状况类malformed-log-entry-error，函数parse-log-entry将在给定数据无法解析时产生
带有导致该状况产生的特定情形细节的信息。在这个假想的日志分析程序里，你可以定义一个
解析日志项的细节：
定，状况类可以单一和多重地继承自其他源自CONDITION的类。但出于历史原因，状况类不要求
CONDITION所定义的类的默认基类是CONDITION而非STANDARD-OBJECT。槽以相同的方式来指
该状况。
19.2
②在一些Common Lisp实现中，状况被定义为STANDARD-OBJECT的子类。在这种情况下，SLOT-VALUE、
① 在这个意义上，除了并非所有状况都代表一个错误或异常的（exceptional）情形，一个状况和Java或Python中的异
当把状况系统用于错误处理时，你应当将状况定义成ERROR的子类，后者是CONDITION的一
状况类使用DEFINE-CONDITION宏来定义，它本质上就是DEFCLASS，除了使用DEFINE-
在parse-log-entry中，当无法解析日志项时将产生一个mal.formed-log-entry-
常很像。
(define-conaition malformed-log-entry-error (error)
一个状况（condition）是一个对象，它所属的类代表了该状况的一般性质，它的实例数据则
MAKE-INSTANCE和INITIALIZE-INSTANCE将可以工作，但依赖于它们将是不可移植的。
(defun parse-log-entry (text)
(if (well-formed-log-entry-p text)
((text :initarg :text :reader text)))
(make-instance 'log-entry ...)
状况处理器
状况
error
'malformed-log-entry-error :text text)))
www.TopSage.com
19.3状况处理器
205
---
## Page 223
而不会被收集。
parse-log-entry产生了一个malformed-log-entry-error，那么错误子句将返回NIL，从
况下是entry的值。）
(Loop子句collectit中的it是另一个LooP关键字，它指向最新求值条件测试的值，在这种情
么返回由parse-log-entry返回的值,要么在产生malformea-log-entry-error时返回NIL。
log-entry-error的方式，将是跳过有间题的项。在下面的函数中，HANDLER-cASE表达式要
保存状况对象的变量名。如果代码不需要访问状况对象，则可以省略这个变量名。
代码，且其值将由HANDLER-CASE返回。如果形参var被包含，在执行处理器代码时，它将成为
一个状况，并且其实例属于任何错误子句中指定的状况类型之一，那么将执行相应错误子句中的
须是单一表达式，你可以使用PROGN将几个表达式组合成单一形式。不过，如果该表达式产生了
其中每一个error-clause均为下列形式:
HANDLER-CASE可以建立这种类型的状况处理器。
将控制传递到SIGNAL之外。在下一节里，你将看到一个处理器是怎样选择传递控制的位置的。
说明符的最新建立的处理器。为了处理该状况，该函数必须通过一个非本地退出(nonlocal exit)
况。在这种情况下，控制将返回到SIGNAL函数，SIGNAL函数随后继续搜索下一个带有兼容类型
相兼容的处理器并调用它的函数，同时传递状况对象给该函数。
栈的不同层次上。当一个状况产生时，信号机制会查找最新建立的类型说明符与当前所产生状况
处理所产生的状况的处理器。每个状况处理器由一个代表它所能处理的状况类型的类型说明符和
handler)。当产生状况时，信号机制会查看活跃状况处理器的列表，并基于状况的类来寻找可以
进入调试器，必须在导致调用parse-log-entry的某个函数中建立一个状况处理器（condition
206
例如，一种在parse-log-entry的调用者parse-log-file中处理前者所产生的malformed-
当parse-log-entry正常返回时，它的值将赋值给变量entry中并被Loop收集。但如果
如果eXpreSSiOn正常返回，那么其值将被HANDLER-CASE返回。HANDLER-CASE的主体必
处理器函数随后可以选择是否处理该状况。该函数可以通过简单的正常返回来放弃处理该状
 当产生错误时，实际发生的事情取决于调用栈中parse-log-entry之上的代码。为了避免
(defun parse-log-file (file)
(condition-type ((var]) code)
(handler-case expression
error-clause*)
(with-open-file (in file :direction :input)
(loop for text = (read-line in nil nil) while text
第19章超越异常处理：状况和再启动
when entry collect it)))
www.TopSage.com
。一个HANDLER-CASE的基本形式如下所示：
宏
---
## Page 224
应用程序的更上层。
动（restart）中，状况处理器随后会通过调用一个适当的再启动来处理状况。可以将再启动代码
19.4
被用到。
同日志文件的解析本身一并丢弃了。你所需要的是一种方式，能提供当前的恢复策略而不是总要
有办法实现当前跳过个别项的策略了～—当错误发生时，栈将被一路展开到更高层的函数上，连
处理。
或者一个应用对于跳过它们是没问题的，但只有当发现特定数量的受损日志项后才需要特别
parse-log-file，或是想要从有问题的项中通过修复并重新解析它们来恢复，又该怎样做呢？
就不是它的职责所在。假如你想在一个想要告诉用户日志文件被破坏了的应用中使用
的任务是解析文件并产生log-entry对象的列表。如果它做不到这一点，决定采用何种替代方案
而在CommonLisp中需要写成这样：
或在Python中写成这样：
这样：
状况系统可以让你将错误处理代码拆分成两部分。将那些实际从错误中恢复的代码放在再启
你可以通过将HANDLER-CASE移动到一-个更高层的函数中来修复该问题。不过，这样你就没
这个版本的parse-log-file有一个严重的缺陷：它做得太多了。顾名思义,parse-log-file
(handler-case
try...
EANDLR-CaB是CommnLsp中最接近Jav或Pyhn风格的丹常处理，在J中‘能写成
except. SomeException,. se:
) catch (SomeException se) (
再启动
(some-exception (se) (recover se))) it- 
 doMoreStuff()
dostuff()
recover(se);
doMoreStuff();
dostuff();
:tprogn 
(do-more-stuff))
(do-stuff)
FE
www.TopSage.com
.80.
...
19.4再启动
11
207
---
## Page 225
存储在其他地方。
根据推测，其中函数analyze-entry将会实际取出那些你想要从每个日志项中得到的信息，并
一些事情。它的一个极其简化的版本可能像这样：