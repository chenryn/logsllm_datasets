## 追问 3：处于 prepare 阶段的 redo log 加上完整 binlog，重启就能恢复，MySQL 为什么要这么设计?回答：其实，这个问题还是跟我们在反证法中说到的数据与备份的一致性有关。在时刻B，也就是 binlog 写完以后 MySQL 发生崩溃，这时候 binlog已经写入了，之后就会被从库（或者用这个 binlog 恢复出来的库）使用。所以，在主库上也要提交这个事务。采用这个策略，主库和备库的数据就保证了一致性。
## 追问 4：如果这样的话，为什么还要两阶段提交呢？干脆先 redo log 写完，再写 binlog。崩溃恢复的时候，必须得两个日志都完整才可以。是不是一样的逻辑？回答：其实，两阶段提交是经典的分布式系统问题，并不是 MySQL 独有的。如果必须要举一个场景，来说明这么做的必要性的话，那就是事务的持久性问题。对于 InnoDB 引擎来说，如果 redo log提交完成了，事务就不能回滚（如果这还允许回滚，就可能覆盖掉别的事务的更新）。而如果redo log 直接提交，然后 binlog 写入的时候失败，InnoDB 又回滚不了，数据和binlog 日志又不一致了。两阶段提交就是为了给所有人一个机会，当每个人都说"我ok"的时候，再一起提交。
## 追问 5：不引入两个日志，也就没有两阶段提交的必要了。只用 binlog 来支持崩溃恢复，又能支持归档，不就可以了？回答：这位同学的意思是，只保留 binlog，然后可以把提交流程改成这样：...-\> "数据更新到内存" -\> "写 binlog" -\>"提交事务"，是不是也可以提供崩溃恢复的能力？答案是不可以。如果说**历史原因**的话，那就是 InnoDB 并不是 MySQL 的原生存储引擎。MySQL的原生引擎是 MyISAM，设计之初就有没有支持崩溃恢复。InnoDB 在作为 MySQL 的插件加入 MySQL引擎家族之前，就已经是一个提供了崩溃恢复和事务支持的引擎了。InnoDB 接入了 MySQL 后，发现既然 binlog 没有崩溃恢复的能力，那就用InnoDB 原有的 redo log 好了。而如果说**实现上的原因**的话，就有很多了。就按照问题中说的，只用 binlog来实现崩溃恢复的流程，我画了一张示意图，这里就没有 redo log 了。![](Images/83257bd857ea3f725fb2a9281b84ac90.png){savepage-src="https://static001.geekbang.org/resource/image/eb/63/eb838b87e9c20fa00aca50ef154f2a63.jpg"}```{=html}```图 2 只用 binlog 支持崩溃恢复]{.reference}```{=html}```这样的流程下，binlog还是不能支持崩溃恢复的。我说一个不支持的点吧：binlog没有能力恢复"数据页"。如果在图中标的位置，也就是 binlog2 写完了，但是整个事务还没有 commit的时候，MySQL 发生了 crash。重启后，引擎内部事务 2 会回滚，然后应用 binlog2 可以补回来；但是对于事务1 来说，系统已经认为提交完成了，不会再应用一次 binlog1。但是，InnoDB 引擎使用的是 WAL技术，执行事务的时候，写完内存和日志，事务就算完成了。如果之后崩溃，要依赖于日志来恢复数据页。也就是说在图中这个位置发生崩溃的话，事务 1也是可能丢失了的，而且是数据页级的丢失。此时，binlog里面并没有记录数据页的更新细节，是补不回来的。你如果要说，那我优化一下 binlog的内容，让它来记录数据页的更改可以吗？但，这其实就是又做了一个 redo log出来。所以，至少现在的 binlog 能力，还不能支持崩溃恢复。
## 追问 6：那能不能反过来，只用 redo log，不要 binlog？回答：如果只从崩溃恢复的角度来讲是可以的。你可以把 binlog关掉，这样就没有两阶段提交了，但系统依然是 crash-safe 的。但是，如果你了解一下业界各个公司的使用场景的话，就会发现在正式的生产库上，binlog都是开着的。因为 binlog 有着 redo log 无法替代的功能。一个是归档。redo log是循环写，写到末尾是要回到开头继续写的。这样历史日志没法保留，redo log也就起不到归档的作用。一个就是 MySQL 系统依赖于 binlog。binlog 作为 MySQL一开始就有的功能，被用在了很多地方。其中，MySQL 系统高可用的基础，就是binlog 复制。还有很多公司有异构系统（比如一些数据分析系统），这些系统就靠消费 MySQL的 binlog 来更新自己的数据。关掉 binlog 的话，这些下游系统就没法输入了。总之，由于现在包括 MySQL 高可用在内的很多系统机制都依赖于binlog，所以"鸠占鹊巢"redo log 还做不到。你看，发展生态是多么重要。
## 追问 7：redo log 一般设置多大？回答：redo log 太小的话，会导致很快就被写满，然后不得不强行刷 redolog，这样 WAL 机制的能力就发挥不出来了。所以，如果是现在常见的几个 TB 的磁盘的话，就不要太小气了，直接将 redolog 设置为 4 个文件、每个文件 1GB 吧。
## 追问 8：正常运行中的实例，数据写入后的最终落盘，是从 redo log 更新过来的还是从 buffer pool 更新过来的呢？回答：这个问题其实问得非常好。这里涉及到了，"redo log里面到底是什么"的问题。实际上，redo log并没有记录数据页的完整数据，所以它并没有能力自己去更新磁盘数据页，也就不存在"数据最终落盘，是由redo log 更新过去"的情况。1.  如果是正常运行的实例的话，数据页被修改以后，跟磁盘的数据页不一致，称为脏页。最终数据落盘，就是把内存中的数据页写盘。这个过程，甚至与    redo log 毫无关系。2.  在崩溃恢复场景中，InnoDB    如果判断到一个数据页可能在崩溃恢复的时候丢失了更新，就会将它读到内存，然后让    redo log    更新内存内容。更新完成后，内存页变成脏页，就回到了第一种情况的状态。