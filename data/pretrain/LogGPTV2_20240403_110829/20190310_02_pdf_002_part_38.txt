some examples using the CREATE TYPE and CREATE TYPE BODY commands.
The first example creates the addr_object_type object type that contains only
attributes and no methods:
CREATE OR REPLACE TYPE addr_object_type AS OBJECT
(
street VARCHAR2(30),
city VARCHAR2(20),
state CHAR(2),
zip NUMBER(5)
);
Since there are no methods in this object type, an object type body is not required. This
example creates a composite type, which allows you to treat related objects as a single
attribute.
6.3.1 Member Methods
A member method is a function or procedure that is defined within an object type and can
only be invoked through an instance of that type. Member methods have access to, and
can change the attributes of, the object instance on which they are operating.
The following object type specification creates the emp_obj_typ object type:
CREATE OR REPLACE TYPE emp_obj_typ AS OBJECT
(
empno NUMBER(4),
ename VARCHAR2(20),
addr ADDR_OBJ_TYP,
MEMBER PROCEDURE display_emp(SELF IN OUT emp_obj_typ)
);
Object type emp_obj_typ contains a member method named display_emp.
display_emp uses a SELF parameter, which passes the object instance on which the
method is invoked.
A SELF parameter is a parameter whose data type is that of the object type being defined.
SELF always refers to the instance that is invoking the method. A SELF parameter is the
first parameter in a member procedure or function regardless of whether it is explicitly
declared in the parameter list.
Copyright © 2007 - 2018 EnterpriseDB Corporation. All rights reserved. 328
Database Compatibility for Oracle® Developers Guide
The following code snippet defines an object type body for emp_obj_typ:
CREATE OR REPLACE TYPE BODY emp_obj_typ AS
MEMBER PROCEDURE display_emp (SELF IN OUT emp_obj_typ)
IS
BEGIN
DBMS_OUTPUT.PUT_LINE('Employee No : ' || empno);
DBMS_OUTPUT.PUT_LINE('Name : ' || ename);
DBMS_OUTPUT.PUT_LINE('Street : ' || addr.street);
DBMS_OUTPUT.PUT_LINE('City/State/Zip: ' || addr.city || ', ' ||
addr.state || ' ' || LPAD(addr.zip,5,'0'));
END;
END;
You can also use the SELF parameter in an object type body. To illustrate how the SELF
parameter would be used in the CREATE TYPE BODY command, the preceding object type
body could be written as follows:
CREATE OR REPLACE TYPE BODY emp_obj_typ AS
MEMBER PROCEDURE display_emp (SELF IN OUT emp_obj_typ)
IS
BEGIN
DBMS_OUTPUT.PUT_LINE('Employee No : ' || SELF.empno);
DBMS_OUTPUT.PUT_LINE('Name : ' || SELF.ename);
DBMS_OUTPUT.PUT_LINE('Street : ' || SELF.addr.street);
DBMS_OUTPUT.PUT_LINE('City/State/Zip: ' || SELF.addr.city || ', ' ||
SELF.addr.state || ' ' || LPAD(SELF.addr.zip,5,'0'));
END;
END;
Both versions of the emp_obj_typ body are completely equivalent.
6.3.2 Static Methods
Like a member method, a static method belongs to a type. A static method, however, is
invoked not by an instance of the type, but by using the name of the type. For example,
to invoke a static function named get_count, defined within the emp_obj_type type,
you would write:
emp_obj_type.get_count();
A static method does not have access to, and cannot change the attributes of an object
instance, and does not typically work with an instance of the type.
The following object type specification includes a static function get_dname and a
member procedure display_dept:
CREATE OR REPLACE TYPE dept_obj_typ AS OBJECT (
deptno NUMBER(2),
STATIC FUNCTION get_dname(p_deptno IN NUMBER) RETURN VARCHAR2,
MEMBER PROCEDURE display_dept
);
Copyright © 2007 - 2018 EnterpriseDB Corporation. All rights reserved. 329
Database Compatibility for Oracle® Developers Guide
The object type body for dept_obj_typ defines a static function named get_dname
and a member procedure named display_dept:
CREATE OR REPLACE TYPE BODY dept_obj_typ AS
STATIC FUNCTION get_dname(p_deptno IN NUMBER) RETURN VARCHAR2
IS
v_dname VARCHAR2(14);
BEGIN
CASE p_deptno
WHEN 10 THEN v_dname := 'ACCOUNTING';
WHEN 20 THEN v_dname := 'RESEARCH';
WHEN 30 THEN v_dname := 'SALES';
WHEN 40 THEN v_dname := 'OPERATIONS';
ELSE v_dname := 'UNKNOWN';
END CASE;
RETURN v_dname;
END;
MEMBER PROCEDURE display_dept
IS
BEGIN
DBMS_OUTPUT.PUT_LINE('Dept No : ' || SELF.deptno);
DBMS_OUTPUT.PUT_LINE('Dept Name : ' ||
dept_obj_typ.get_dname(SELF.deptno));
END;
END;
Within the static function get_dname, there can be no references to SELF. Since a static
function is invoked independently of any object instance, it has no implicit access to any
object attribute.
Member procedure display_dept can access the deptno attribute of the object
instance passed in the SELF parameter. It is not necessary to explicitly declare the SELF
parameter in the display_dept parameter list.
The last DBMS_OUTPUT.PUT_LINE statement in the display_dept procedure includes
a call to the static function get_dname (qualified by its object type name
dept_obj_typ).
6.3.3 Constructor Methods
A constructor method is a function that creates an instance of an object type, typically by
assigning values to the members of the object. An object type may define several
constructors to accomplish different tasks. A constructor method is a member function
(invoked with a SELF parameter) whose name matches the name of the type.
For example, if you define a type named address, each constructor is named address.
You may overload a constructor by creating one or more different constructor functions
with the same name, but with different argument types.
Copyright © 2007 - 2018 EnterpriseDB Corporation. All rights reserved. 330
Database Compatibility for Oracle® Developers Guide
The SPL compiler will provide a default constructor for each object type. The default
constructor is a member function whose name matches the name of the type and whose
argument list matches the type members (in order). For example, given an object type
such as:
CREATE TYPE address AS OBJECT
(
street_address VARCHAR2(40),
postal_code VARCHAR2(10),
city VARCHAR2(40),
state VARCHAR2(2)
)
The SPL compiler will provide a default constructor with the following signature:
CONSTRUCTOR FUNCTION address
(
street_address VARCHAR2(40),
postal_code VARCHAR2(10),
city VARCHAR2(40),
state VARCHAR2(2)
)
The body of the default constructor simply sets each member to NULL.
To create a custom constructor, declare the constructor function (using the keyword
constructor) in the CREATE TYPE command and define the construction function in the
CREATE TYPE BODY command. For example, you may wish to create a custom
constructor for the address type which computes the city and state given a
street_address and postal_code:
CREATE TYPE address AS OBJECT
(
street_address VARCHAR2(40),
postal_code VARCHAR2(10),
city VARCHAR2(40),
state VARCHAR2(2),
CONSTRUCTOR FUNCTION address
(
street_address VARCHAR2,
postal_code VARCHAR2
) RETURN self AS RESULT
)
CREATE TYPE BODY address AS
CONSTRUCTOR FUNCTION address
(
street_address VARCHAR2,
postal_code VARCHAR2
) RETURN self AS RESULT
IS
BEGIN
self.street_address := street_address;
self.postal_code := postal_code;
self.city := postal_code_to_city(postal_code);
Copyright © 2007 - 2018 EnterpriseDB Corporation. All rights reserved. 331
Database Compatibility for Oracle® Developers Guide
self.state := postal_code_to_state(postal_code);
RETURN;
END;
END;
To create an instance of an object type, you invoke one of the constructor methods for
that type. For example:
DECLARE
cust_addr address := address('100 Main Street', 02203');
BEGIN
DBMS_OUTPUT.PUT_LINE(cust_addr.city); -- displays Boston
DBMS_OUTPUT.PUT_LINE(cust_addr.state); -- displays MA
END;
Custom constructor functions are typically used to compute member values when given
incomplete information. The preceding example computes the values for city and
state when given a postal code.
Custom constructor functions are also used to enforce business rules that restrict the state
of an object. For example, if you define an object type to represent a payment, you can
use a custom constructor to ensure that no object of type payment can be created with an
amount that is NULL, negative, or zero. The default constructor would set
payment.amount to NULL so you must create a custom constructor (whose signature
matches the default constructor) to prohibit NULL amounts.
Copyright © 2007 - 2018 EnterpriseDB Corporation. All rights reserved. 332
Database Compatibility for Oracle® Developers Guide
6.4 Creating Object Instances
To create an instance of an object type, you must first declare a variable of the object
type, and then initialize the declared object variable. The syntax for declaring an object
variable is:
object obj_type
object is an identifier assigned to the object variable.
obj_type is the identifier of a previously defined object type.
After declaring the object variable, you must invoke a constructor method to initialize the
object with values. Use the following syntax to invoke the constructor method:
[NEW] obj_type ({expr1 | NULL} [, {expr2 | NULL} ] [, ...])
obj_type is the identifier of the object type’s constructor method; the constructor
method has the same name as the previously declared object type.
expr1, expr2, … are expressions that are type-compatible with the first attribute of the
object type, the second attribute of the object type, etc. If an attribute is of an object type,
then the corresponding expression can be NULL, an object initialization expression, or any
expression that returns that object type.
The following anonymous block declares and initializes a variable:
DECLARE
v_emp EMP_OBJ_TYP;
BEGIN
v_emp := emp_obj_typ (9001,'JONES',
addr_obj_typ('123 MAIN STREET','EDISON','NJ',08817));
END;
The variable (v_emp) is declared with a previously defined object type named
EMP_OBJ_TYPE. The body of the block initializes the variable using the emp_obj_typ
and addr_obj_type constructors.
You can include the NEW keyword when creating a new instance of an object in the body
of a block. The NEW keyword invokes the object constructor whose signature matches the
arguments provided.
The following example declares two variables, named mgr and emp. The variables are
both of EMP_OBJ_TYPE. The mgr object is initialized in the declaration, while the emp
object is initialized to NULL in the declaration, and assigned a value in the body.
DECLARE
mgr EMP_OBJ_TYPE := (9002,'SMITH');
Copyright © 2007 - 2018 EnterpriseDB Corporation. All rights reserved. 333
Database Compatibility for Oracle® Developers Guide
emp EMP_OBJ_TYPE;
BEGIN
emp := NEW EMP_OBJ_TYPE (9003,'RAY');
END;
Note: In Advanced Server, the following alternate syntax can be used in place of the
constructor method.
[ ROW ] ({ expr1 | NULL } [, { expr2 | NULL } ] [, ...])
ROW is an optional keyword if two or more terms are specified within the parenthesis-
enclosed, comma-delimited list. If only one term is specified, then specification of the
ROW keyword is mandatory.
6.5 Referencing an Object
Once an object variable is created and initialized, individual attributes can be referenced
using dot notation of the form:
object.attribute
object is the identifier assigned to the object variable. attribute is the identifier of an
object type attribute.
If attribute, itself, is of an object type, then the reference must take the form:
object.attribute.attribute_inner
attribute_inner is an identifier belonging to the object type to which attribute
references in its definition of object.
The following example expands upon the previous anonymous block to display the
values assigned to the emp_obj_typ object.
DECLARE
v_emp EMP_OBJ_TYP;
BEGIN
v_emp := emp_obj_typ(9001,'JONES',
addr_obj_typ('123 MAIN STREET','EDISON','NJ',08817));
DBMS_OUTPUT.PUT_LINE('Employee No : ' || v_emp.empno);
DBMS_OUTPUT.PUT_LINE('Name : ' || v_emp.ename);
DBMS_OUTPUT.PUT_LINE('Street : ' || v_emp.addr.street);
DBMS_OUTPUT.PUT_LINE('City/State/Zip: ' || v_emp.addr.city || ', ' ||
v_emp.addr.state || ' ' || LPAD(v_emp.addr.zip,5,'0'));
END;
Copyright © 2007 - 2018 EnterpriseDB Corporation. All rights reserved. 334
Database Compatibility for Oracle® Developers Guide
The following is the output from this anonymous block.
Employee No : 9001
Name : JONES
Street : 123 MAIN STREET
City/State/Zip: EDISON, NJ 08817
Methods are called in a similar manner as attributes.
Once an object variable is created and initialized, member procedures or functions are
called using dot notation of the form:
object.prog_name
object is the identifier assigned to the object variable. prog_name is the identifier of
the procedure or function.
Static procedures or functions are not called utilizing an object variable. Instead the
procedure or function is called utilizing the object type name:
object_type.prog_name
object_type is the identifier assigned to the object type. prog_name is the identifier
of the procedure or function.
The results of the previous anonymous block can be duplicated by calling the member
procedure display_emp:
DECLARE
v_emp EMP_OBJ_TYP;
BEGIN
v_emp := emp_obj_typ(9001,'JONES',
addr_obj_typ('123 MAIN STREET','EDISON','NJ',08817));
v_emp.display_emp;
END;
The following is the output from this anonymous block.
Employee No : 9001
Name : JONES
Street : 123 MAIN STREET
City/State/Zip: EDISON, NJ 08817
The following anonymous block creates an instance of dept_obj_typ and calls the
member procedure display_dept:
DECLARE
v_dept DEPT_OBJ_TYP := dept_obj_typ (20);
BEGIN
v_dept.display_dept;
END;
Copyright © 2007 - 2018 EnterpriseDB Corporation. All rights reserved. 335
Database Compatibility for Oracle® Developers Guide
The following is the output from this anonymous block.
Dept No : 20
Dept Name : RESEARCH
The static function defined in dept_obj_typ can be called directly by qualifying it by
the object type name as follows:
BEGIN
DBMS_OUTPUT.PUT_LINE(dept_obj_typ.get_dname(20));
END;
RESEARCH
6.6 Dropping an Object Type
The syntax for deleting an object type is as follows.
DROP TYPE objtype;
objtype is the identifier of the object type to be dropped. If the definition of objtype
contains attributes that are themselves object types or collection types, these nested object
types or collection types must be dropped last.
If an object type body is defined for the object type, the DROP TYPE command deletes
the object type body as well as the object type specification. In order to recreate the
complete object type, both the CREATE TYPE and CREATE TYPE BODY commands must
be reissued.
The following example drops the emp_obj_typ and the addr_obj_typ object types
created earlier in this chapter. emp_obj_typ must be dropped first since it contains
addr_obj_typ within its definition as an attribute.
DROP TYPE emp_obj_typ;
DROP TYPE addr_obj_typ;
The syntax for deleting an object type body, but not the object type specification is as
follows.
DROP TYPE BODY objtype;
The object type body can be recreated by issuing the CREATE TYPE BODY command.
The following example drops only the object type body of the dept_obj_typ.
DROP TYPE BODY dept_obj_typ;
Copyright © 2007 - 2018 EnterpriseDB Corporation. All rights reserved. 336
Database Compatibility for Oracle® Developers Guide
7 Open Client Library
The Open Client Library provides application interoperability with the Oracle Call
Interface – an application that was formerly “locked in” can now work with either an
EDB Postgres Advanced Server or an Oracle database with minimal to no changes to the
application code. The EnterpriseDB implementation of the Open Client Library is
written in C.
The following diagram compares the Open Client Library and Oracle Call Interface
application stacks.
For detailed usage information about the Open Client Library and the supported
functions, please see the EDB Postgres Advanced Server OCI Connector Guide, available
at: