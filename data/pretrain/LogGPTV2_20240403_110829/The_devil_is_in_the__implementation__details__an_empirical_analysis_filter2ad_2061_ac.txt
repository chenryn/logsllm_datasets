7
20
38
32
43
21
64
16
18
34
55
36
91
Table 2: The percentage of RPs that is vulnerable to each
exploit. Legends: T: SSL is used in the traditional login
form; S: Sign-in endpoint is SSL-protected; A1: Access token
eavesdropping; A2: Access token theft via XSS; A3: Imper-
sonation; A4: Session swapping; A5: Force-login.
and the RP server without SSL protection. We also im-
plemented an access token network sniﬀer to conﬁrm the
results. According to the OAuth speciﬁcation, an access to-
ken is never exposed in the network between the browser
and the RP server. However, our results show that access
tokens can be eavesdropped on 32% of RPs.
Initially, we found that Facebook and Microsoft SDKs
store the access token into an HTTP cookie on the RP do-
main by default, and all client-ﬂow RPs use this cookie as an
SSO credential to identify the user on the server side. How-
ever, as the cookie is created without secured and HTTP-
only attributes, it could be eavesdropped on the network,
or hijacked by malicious scripts injected on any page under
the RP domain. To address this issue, Facebook revised its
SDK to use a signed authorization code in place of an access
token for the cookie [6]. We re-executed the evaluation and
found that, many RPs save the token into a cookie them-
selves, or pass the access token as a query parameter to a
sign-in endpoint on the RP server side. Surprisingly, even
server-ﬂow RPs (7%) exhibit this insecure practice.
SSL provides end-to-end protection, and is commonly sug-
gested for mitigating attacks that manipulate network traf-
ﬁc. However, SSL imposes management and performance
overhead, makes web contents non-cacheable, and introduces
undesired side-eﬀects such as browser warnings about mixed
secure (HTTPS) and insecure (HTTP) content [42]. Due to
these unwanted complications, many websites use SSL only
for login pages. We found 49% of RPs employ SSL to pro-
tect their traditional login forms, but only 21% use SSL
for the sign-in endpoints. The reason behind this insecure
practice is unclear to us, but it might be due to the miscon-
ception that the communication channel is SSL-protected by
the IdP.
4.2 Access token theft via XSS (A2)
The IdP’s “automatic authorization granting” feature re-
turns an access token automatically (i.e., without the user’s
intervention) for an authorization request, if the requested
permissions denoted in the request have been granted by the
user previously, and the user has already logged into the IdP
in the same browser session. The rationales behind this de-
sign feature are detailed in Section 5.2. This automatic au-
thorization mechanism allows an attacker to steal an access
token by injecting a malicious script into any page of an RP
website to initiate a client-side login ﬂow and subsequently
obtain the responded token. To evaluate this vulnerability,
two exploits in JavaScript were designed (listed in Appendix
A and B). Both exploits send a forged authorization request
to the Facebook authorization server via a hidden iframe el-
ement when executed. The ﬁrst exploit uses the current page
as the redirect URI, and extracts the access token from the
Table 3: The percentages of RPs that are vulnerable to
impersonation (A3) or session swapping (A4) attacks.
fragment identiﬁer. The second exploit dynamically loads
the SDK and uses a special SDK function (getLoginStatus)
to obtain the access token. In order to conduct a realistic
evaluation without introducing actual harm to the testing
RPs and real users, we used GreasyMonkey [24], a Firefox
add-on, to execute these two exploits.
To evaluate, the evaluator logs into the IdP and visits the
RP in question (without signing in) using a GreasyMonkey
augmented browser. Both exploit scripts create a hidden
iframe element to transport a forged authorization request
to the IdP, and then obtain an access token in return. Once
the access token is obtained, the exploit script sends it back
to attacker.com using a dynamically created img element.
With this stolen access token, attacker.com then calls the
IdP’s web APIs to verify whether the exploit has been car-
ried out successfully.
Our evaluation results show that 88% of RPs are vulnera-
ble to the ﬁrst exploit regardless of their supporting ﬂow or
whether the user has logged into the RP website. RPs that
are resistant to this exploit either framebusted their home
pages (i.e., cannot be framed), or used a diﬀerent domain for
the redirect URI (i.e., login.rp.com for www.rp.com). The
second exploit succeeded on all evaluated RPs except those
that use a diﬀerent HTTP domain for receiving authoriza-
tion responses.
Additionally, we examined the feasibility of a scenario in
which the browser is the one that makes token theft possi-
ble, instead of relying on the RP website having an XSS
vulnerability. We tested two such scenarios, but believe
that other current and future exploits are possible. In both
test cases, the vulnerable browsers are still used by about
10% of web users [45]. First, we embedded each exploit in
a JPG image ﬁle and uploaded them onto the RP under
test. The evaluator then used IE 7 to view the uploaded
image, which caused the XSS payload being executed due
to the browser’s content-sniﬃng algorithm [1]. Second, we
designed an exploit script (see Appendix C) that leverages
certain browsers’ onerror event handling behavior. In those
browsers [30], the URL that triggers the script error is dis-
closed to the onerror handler. We tested the exploit using
Firefox 3.6.3, and it succeeded on all evaluated RPs. The ex-
ploit script sends a forged authorization request through the
src attribute of a dynamically created script element, and
then extracts the access token via onerror event handler.
4.3 Impersonation (A3)
An impersonation attack works by sending a stolen or
guessed SSO credential to the RP’s sign-in endpoint through
an attacker-controlled user-agent. We found that an imper-
sonation attack could be successfully carried out if (1) the
attacker can obtain or guess a copy of the victim’s SSO cre-
383dential, (2) the SSO credential is not limited to one-time
use, and (3) the RP in question does not check whether the
response is sent by the same browser from which the autho-
rization request was issued (i.e., lack of “contextual binding”
validation).
We designed an “impersonator” tool in C# to evaluate
this vulnerability. The tool reuses GeckoFX web browser
control [37] for sending HTTP requests and rendering the
received HTML content. We modiﬁed GeckoFX to make it
capable of observing and altering HTTP requests, including
headers. Based on the RP domain entered by the evalua-
tor, the tool constructs an exploit request based on the SSO
credential and sign-in endpoint retrieved from attacker.com,
and then sends it to the RP through the GeckoFX browser
control. In addition, for RPs that use the user’s IdP account
proﬁle as an SSO credential, the evaluator replaced the pro-
ﬁle information with one from another testing account to
test whether the SSO credential is guessable. Table 3 shows
our evaluation results. Interestingly, several RPs (9%) use
the user’s IdP proﬁle as an SSO credential. This allows an
attacker to log into the RP as the victim by simply using
the victim’s Facebook account identifer, which is publicly
accessible.
We also found that 13% of RPs use a proxy service from
Gigya [13], and half of them are vulnerable to an imperson-
ation attack, because the signatures signed by Gigya are not
veriﬁed by those RPs. The Gigya platform provides a uni-
ﬁed protocol interface for RPs to integrate a diverse range
of web SSO protocols. The proxy service performs OAuth
server-ﬂow on behalf of the website, requests and stores the
user’s proﬁle attributes, and then passes the user’s proﬁle via
a redirect URI registered with the proxy service or through
cross-domain communication channels. While useful, we be-
lieve that a malicious or compromised proxy service could
result in serious security breaches, because RPs need to pro-
vide the proxy service with their application secret for each
supported IdP, and all access tokens are passed through the
proxy server.
4.4 Session swapping (A4)
Session swapping is another way to exploit the lack of con-
textual binding vulnerability; that is, the RP doesn’t pro-
vide a state parameter in an authorization request (Step 2
in Figure 1 and 2) to maintain the state between the request
and response. The state parameter is typically a value that
is bound to the browser session (e.g., a hash of the session),
which will be appended to the corresponding response by
the IdP when redirecting the user back to the RP (Step 7
in Figure 1, and Step 6 in Figure 2). To launch a session
swapping attack, the attacker (1) signs into an RP using the
attacker’s identity from the IdP, (2) intercepts the SSO cre-
dential on his user-agent (Step 7 in Figure 1, and Step 8 in
Figure 2), and then (3) embeds the intercepted SSO creden-
tial in an HTML construct (e.g., img, iframe) that causes
the browser to automatically send the intercepted SSO cre-
dential to the RP’s sign-in endpoint when the exploit page is
viewed by a victim user. As the intercepted SSO credential
is bound to the attacker’s account on the RP, a successful
session swapping exploit allows the attacker to stealthily log
the victim into her RP as the attacker to spoof the victim’s
personal data [2], or mount a XSS attack as we discussed in
Section 5.5.
To evaluate this vulnerability, we designed an exploit page
hosted on attacker.com. The exploit page takes an RP do-
main as input parameter, retrieves the SSO credential and
sign-in endpoint as an exploit request for the RP in question
from the log, and then sets the exploit request as the src
of a dynamically created iframe element. Malicious con-
tent embedded in the iframe can cause the browser to issue
an HTTP request to the RP website using both GET and
POST methods, but the exploit request cannot have custom
HTTP headers, such as cookies. When the POST method
is used by the RP, the iframe’s src attribute is set to an-
other page that contains (1) a web form with the action
attribute set to the URL of the exploit request, and each
HTTP query parameter (key-value pair) in the exploit re-
quest is added to the form as a hidden input ﬁeld, and (2)
a JavaScript that submits the web form automatically when
the page is loaded.
4.5 Force-login CSRF (A5)
Cross-Site Request Forgery (CSRF) is a widely exploited
web application vulnerability [31], which tricks a user into
loading a page that contains a malicious request that could
disrupt the integrity of the victim’s session data with a web-
site. The attack URL is usually embedded in an HTML con-
struct (e.g., ) that causes
the browser to automatically issue the malicious request
when the HTML construct is viewed. As the malicious re-
quest originates from the victim’s browser and the session
cookies previously set by the victim site are sent along it
automatically, there is no detectable diﬀerence between the
attack request and the one from a legitimate user request.
To launch a CSRF attack, the malicious HTML construct
could be embedded in an email, hosted on a malicious web-
site, or planted on benign websites through XSS or SQL
injection attacks.
A typical CSRF attacks requires the victim has already
an authenticated session with the website, and a force-login
CSRF attack can be leveraged by an attacker to achieve this
prerequisite. By taking advantage of the “automatic autho-
rization granting” design feature, a force-login CSRF attack
logs the victim user into the RP automatically by luring a
victim user to view an exploit page that sends a forged login
request (Step 1 in Figure 1) or authorization request (Step
2 in both Figure 1 and 2) via the victim’s browser. A suc-
cessful exploit enables a web attacker to actively carry out
subsequent CSRF attacks without passively waiting for the
victim user to log into her website.
The evaluation procedures for this attack are same as A4,
except this attack requires the victim has already an authen-
ticated session with the IdP, and it uses a login or autho-
rization request as the exploit request. We have also noticed
that some client-ﬂow RPs (18%) sign users in automatically
if the user has already logged into Facebook, but this “auto-
login” feature enables an attacker to launch CSRF attacks
actively. After a successful force-login attack, we examined
whether the user account data on the RP can be altered
automatically by a CSRF attack. Our results show that,
on 21% of the tested RPs, their users’ proﬁle information is
indeed vulnerable to CSRF exploits.
5. DISCUSSION
Surprisingly, we found the aforementioned vulnerabilities
are largely caused by design decisions that trade security for
simplicity. Unlike logic ﬂows, those design features are valu-
384to the sign-in endpoint. Nevertheless, this enables an imper-
sonation attack by sending the victim’s Facebook identiﬁer
using a normal browser.
5.2 Automatic authorization granting
IdPs oﬀer an “automatic authorization granting” feature
to enhance both performance and the user experience, but
this feature also enables an attacker to steal access tokens
through an XSS exploit. We observed that when a page
containing an SDK library is loaded, an access token is re-
turned to the library automatically without an explicit user
consent. This happens when the requested permissions have
been granted before, and the user has already logged into the
IdP in the same browser session. Further investigation on
this undocumented feature revealed that obtaining access
tokens in the background is enabled by several design de-
cisions, including (1) for simplicity, OAuth 2.0 removes the
signature requirement for an authorization request [17], (2)
for usability, a repeated authorization request is granted au-
tomatically without prompting the user for consent, and (3)
for ﬂexibility, redirect URI restriction is based on an HTTP
domain rather than a whitelist so that access tokens could
be obtained on any page within the RP domain.
Automatic authorization granting might be indeed useful,
but it can be harmful as well. This function could be used by
RPs to eliminate the popup login window that simply blinks
and then closes, and reduce delays when the user is ready
for login. In addition, we believe that many RPs use this
design feature to (1) refresh an access token when it expires,
(2) log the user into the RP website automatically, and (3)
integrate the user’s social context on the client side directly
to reduce the overhead of round-trip communication with
the RP server. While useful, this function, however, enables
an attacker to obtain access tokens via a malicious script ex-
ecuted on any page of an RP website, even when the redirect
URI is SSL-protected and the user has not logged into the
RP yet. Surprisingly, we found that even server-ﬂow RPs
that obtain access tokens through a direct communication
with the IdP are vulnerable as well.
5.3 Cross-domain communication in SDK
IdP SDK libraries employ cross-domain communication
(CDC) mechanisms for passing access tokens between cross-
origin windows. As demonstrated by several researchers [3,
20, 46], passing sensitive information through CDC chan-
nels could impose severe security threats. Facebook SDK
uses postMessage HTML5 API and Adobe Flash for cross
frame interactions. For postMessage, Hanna et al. [20] found
that, due to several insuﬃcient checks on the sender’s and
receiver’s origin in the code, both tokens and user data could
be stolen by an attacker. For Flash, Wang et al. [46] uncov-
ered a vulnerability that allows an attacker to obtain the
session credential of a victim user by naming the malicious
Flash object with an underscore preﬁx. Both vulnerabilities
were reported and ﬁxed by Facebook, but they might appear
again in the future IdP’s SDK implementations.
We examined Microsoft’s SDK and found that the SDK
does not use any CDC mechanism for passing access to-
kens. Instead, a cookie shared between same-origin frames
is used. Microsoft SDK requires RPs to include its SDK
library on the page of the redirect URI, which is under the
RP’s domain. The library on the redirect URI page extracts
the access token from the URI fragment and saves it to a
Figure 3: The causality diagram.
able to RP developers, and cannot be ﬁxed with a simple
patch. The causality diagram in Figure 3 illustrates how
simplicity features from the protocol and IdP implementa-
tions lead to uncovered weaknesses. OAuth 2.0 oﬀers sup-
port for public clients that cannot keep their client secret
secure, and drops signatures in favor of SSL for RP-to-IdP
communication. These two design decisions enable the pro-
tocol to be “played” completely within the browser, and thus
client-ﬂow. To enhance user experience and reduce client-
ﬂow implementation eﬀorts, IdPs oﬀer an “automatic autho-
rization granting” feature and SDK library. These features
make the protocol simple to implement, but at the cost of
increasing the attack surface and opening the protocol to
new exploits.
5.1 Authentication State Gap
The OAuth client-ﬂow is inherently less secure than server-
ﬂow, because of an authentication state gap between the
client-side script and the program logic on the RP server.
According to the OAuth speciﬁcation, a client-ﬂow is in-
tended for browser-based applications that are executed com-
pletely within a user-agent. Nevertheless, a web application
typically issues authentication sessions from its server-side.
Hence, when applying client-ﬂow for SSO, there is an au-
thentication state gap between the client-side script and the
RP server after the authorization ﬂow is completed (i.e., the
access token has been delivered to the client-side script).
This gap requires a client-side script to transmit an SSO
credential to the sign-in endpoint on the RP server in order
to identify the current SSO user and issue an authentica-
tion cookie. However, if the sign-in endpoint is not SSL-