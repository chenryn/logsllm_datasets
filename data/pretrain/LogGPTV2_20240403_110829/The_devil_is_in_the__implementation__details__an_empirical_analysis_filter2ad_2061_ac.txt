### Table 2: The Percentage of RPs Vulnerable to Each Exploit

| Legend | Description |
| --- | --- |
| T | SSL is used in the traditional login form. |
| S | Sign-in endpoint is SSL-protected. |
| A1 | Access token eavesdropping. |
| A2 | Access token theft via XSS. |
| A3 | Impersonation. |
| A4 | Session swapping. |
| A5 | Force-login. |

### Access Token Eavesdropping (A1)

We evaluated the security of access tokens by implementing a network sniffer to confirm our findings. According to the OAuth specification, access tokens should never be exposed in the network between the browser and the RP server. However, our results show that access tokens can be eavesdropped on 32% of RPs.

Initially, we found that Facebook and Microsoft SDKs store the access token into an HTTP cookie on the RP domain by default, and all client-flow RPs use this cookie as an SSO credential to identify the user on the server side. However, since the cookie is created without secure and HTTP-only attributes, it can be eavesdropped on the network or hijacked by malicious scripts injected on any page under the RP domain. To address this issue, Facebook revised its SDK to use a signed authorization code instead of an access token for the cookie [6]. Re-evaluating the RPs, we found that many still save the token into a cookie or pass the access token as a query parameter to a sign-in endpoint on the RP server. Surprisingly, even 7% of server-flow RPs exhibit this insecure practice.

SSL provides end-to-end protection and is commonly suggested for mitigating attacks that manipulate network traffic. However, SSL imposes management and performance overhead, makes web content non-cacheable, and introduces undesired side effects such as browser warnings about mixed secure (HTTPS) and insecure (HTTP) content [42]. Due to these complications, many websites use SSL only for login pages. We found that 49% of RPs employ SSL to protect their traditional login forms, but only 21% use SSL for the sign-in endpoints. The reason behind this insecure practice is unclear, but it might be due to the misconception that the communication channel is SSL-protected by the IdP.

### Access Token Theft via XSS (A2)

The IdP’s “automatic authorization granting” feature returns an access token automatically (i.e., without the user’s intervention) for an authorization request if the requested permissions have been granted previously and the user has already logged into the IdP in the same browser session. This design feature allows an attacker to steal an access token by injecting a malicious script into any page of an RP website to initiate a client-side login flow and subsequently obtain the responded token.

To evaluate this vulnerability, we designed two exploits in JavaScript (listed in Appendix A and B). Both exploits send a forged authorization request to the Facebook authorization server via a hidden iframe element when executed. The first exploit uses the current page as the redirect URI and extracts the access token from the fragment identifier. The second exploit dynamically loads the SDK and uses a special SDK function (getLoginStatus) to obtain the access token. To conduct a realistic evaluation without introducing actual harm, we used GreasyMonkey [24], a Firefox add-on, to execute these exploits.

The evaluation process involves the evaluator logging into the IdP and visiting the RP in question using a GreasyMonkey-augmented browser. Both exploit scripts create a hidden iframe element to transport a forged authorization request to the IdP and then obtain an access token in return. Once the access token is obtained, the exploit script sends it back to attacker.com using a dynamically created img element. With the stolen access token, attacker.com calls the IdP’s web APIs to verify whether the exploit has been carried out successfully.

Our evaluation results show that 88% of RPs are vulnerable to the first exploit, regardless of their supporting flow or whether the user has logged into the RP website. RPs that are resistant to this exploit either frame-bust their home pages or use a different domain for the redirect URI. The second exploit succeeded on all evaluated RPs except those that use a different HTTP domain for receiving authorization responses.

Additionally, we examined the feasibility of a scenario where the browser itself makes token theft possible, rather than relying on the RP website having an XSS vulnerability. We tested two such scenarios, but other current and future exploits are possible. In both test cases, the vulnerable browsers are still used by about 10% of web users [45]. First, we embedded each exploit in a JPG image file and uploaded them onto the RP under test. The evaluator then used IE 7 to view the uploaded image, which caused the XSS payload to be executed due to the browser’s content-sniffing algorithm [1]. Second, we designed an exploit script (see Appendix C) that leverages certain browsers’ onerror event handling behavior. In those browsers [30], the URL that triggers the script error is disclosed to the onerror handler. We tested the exploit using Firefox 3.6.3, and it succeeded on all evaluated RPs. The exploit script sends a forged authorization request through the src attribute of a dynamically created script element and then extracts the access token via the onerror event handler.

### Impersonation (A3)

An impersonation attack works by sending a stolen or guessed SSO credential to the RP’s sign-in endpoint through an attacker-controlled user-agent. We found that an impersonation attack could be successfully carried out if (1) the attacker can obtain or guess a copy of the victim’s SSO credential, (2) the SSO credential is not limited to one-time use, and (3) the RP does not check whether the response is sent by the same browser from which the authorization request was issued (i.e., lacks "contextual binding" validation).

We designed an "impersonator" tool in C# to evaluate this vulnerability. The tool reuses the GeckoFX web browser control [37] for sending HTTP requests and rendering received HTML content. We modified GeckoFX to observe and alter HTTP requests, including headers. Based on the RP domain entered by the evaluator, the tool constructs an exploit request based on the SSO credential and sign-in endpoint retrieved from attacker.com and sends it to the RP through the GeckoFX browser control. For RPs that use the user’s IdP account profile as an SSO credential, the evaluator replaced the profile information with one from another testing account to test whether the SSO credential is guessable. Table 3 shows our evaluation results. Interestingly, several RPs (9%) use the user’s IdP profile as an SSO credential, allowing an attacker to log into the RP as the victim by simply using the victim’s Facebook account identifier, which is publicly accessible.

We also found that 13% of RPs use a proxy service from Gigya [13], and half of them are vulnerable to an impersonation attack because the signatures signed by Gigya are not verified by those RPs. The Gigya platform provides a unified protocol interface for RPs to integrate a diverse range of web SSO protocols. The proxy service performs OAuth server-flow on behalf of the website, requests and stores the user’s profile attributes, and then passes the user’s profile via a redirect URI registered with the proxy service or through cross-domain communication channels. While useful, a malicious or compromised proxy service could result in serious security breaches, as RPs need to provide the proxy service with their application secret for each supported IdP, and all access tokens are passed through the proxy server.

### Session Swapping (A4)

Session swapping is another way to exploit the lack of contextual binding vulnerability; that is, the RP does not provide a state parameter in an authorization request (Step 2 in Figure 1 and 2) to maintain the state between the request and response. The state parameter is typically a value bound to the browser session (e.g., a hash of the session), which will be appended to the corresponding response by the IdP when redirecting the user back to the RP (Step 7 in Figure 1, and Step 6 in Figure 2). To launch a session swapping attack, the attacker (1) signs into an RP using the attacker’s identity from the IdP, (2) intercepts the SSO credential on their user-agent (Step 7 in Figure 1, and Step 8 in Figure 2), and then (3) embeds the intercepted SSO credential in an HTML construct (e.g., img, iframe) that causes the browser to automatically send the intercepted SSO credential to the RP’s sign-in endpoint when the exploit page is viewed by a victim user. As the intercepted SSO credential is bound to the attacker’s account on the RP, a successful session swapping exploit allows the attacker to stealthily log the victim into the RP as the attacker to spoof the victim’s personal data [2], or mount an XSS attack as discussed in Section 5.5.

To evaluate this vulnerability, we designed an exploit page hosted on attacker.com. The exploit page takes an RP domain as an input parameter, retrieves the SSO credential and sign-in endpoint as an exploit request for the RP in question from the log, and sets the exploit request as the src of a dynamically created iframe element. Malicious content embedded in the iframe can cause the browser to issue an HTTP request to the RP website using both GET and POST methods, but the exploit request cannot have custom HTTP headers, such as cookies. When the POST method is used by the RP, the iframe’s src attribute is set to another page that contains (1) a web form with the action attribute set to the URL of the exploit request, and each HTTP query parameter (key-value pair) in the exploit request is added to the form as a hidden input field, and (2) a JavaScript that submits the web form automatically when the page is loaded.

### Force-Login CSRF (A5)

Cross-Site Request Forgery (CSRF) is a widely exploited web application vulnerability [31], which tricks a user into loading a page that contains a malicious request that could disrupt the integrity of the victim’s session data with a website. The attack URL is usually embedded in an HTML construct (e.g., `<img src="malicious_url">`) that causes the browser to automatically issue the malicious request when the HTML construct is viewed. As the malicious request originates from the victim’s browser and the session cookies previously set by the victim site are sent along with it automatically, there is no detectable difference between the attack request and the one from a legitimate user request.

To launch a CSRF attack, the malicious HTML construct could be embedded in an email, hosted on a malicious website, or planted on benign websites through XSS or SQL injection attacks. A typical CSRF attack requires the victim to have an authenticated session with the website, and a force-login CSRF attack can be leveraged by an attacker to achieve this prerequisite. By taking advantage of the "automatic authorization granting" design feature, a force-login CSRF attack logs the victim user into the RP automatically by luring the victim to view an exploit page that sends a forged login request (Step 1 in Figure 1) or authorization request (Step 2 in both Figure 1 and 2) via the victim’s browser. A successful exploit enables a web attacker to actively carry out subsequent CSRF attacks without passively waiting for the victim to log into their website.

The evaluation procedures for this attack are the same as for A4, except this attack requires the victim to have an authenticated session with the IdP, and it uses a login or authorization request as the exploit request. We have also noticed that some client-flow RPs (18%) sign users in automatically if the user has already logged into Facebook, but this "auto-login" feature enables an attacker to launch CSRF attacks actively. After a successful force-login attack, we examined whether the user account data on the RP can be altered automatically by a CSRF attack. Our results show that, on 21% of the tested RPs, their users’ profile information is indeed vulnerable to CSRF exploits.

### Discussion

Surprisingly, we found that the aforementioned vulnerabilities are largely caused by design decisions that trade security for simplicity. Unlike logic flows, these design features are valuable to RP developers and cannot be fixed with a simple patch. The causality diagram in Figure 3 illustrates how simplicity features from the protocol and IdP implementations lead to uncovered weaknesses. OAuth 2.0 offers support for public clients that cannot keep their client secret secure and drops signatures in favor of SSL for RP-to-IdP communication. These design decisions enable the protocol to be "played" completely within the browser, leading to client-flow. To enhance user experience and reduce client-flow implementation efforts, IdPs offer an "automatic authorization granting" feature and SDK library. These features make the protocol simple to implement but at the cost of increasing the attack surface and opening the protocol to new exploits.

#### Authentication State Gap

The OAuth client-flow is inherently less secure than server-flow due to an authentication state gap between the client-side script and the program logic on the RP server. According to the OAuth specification, a client-flow is intended for browser-based applications that are executed completely within a user-agent. Nevertheless, a web application typically issues authentication sessions from its server-side. Hence, when applying client-flow for SSO, there is an authentication state gap between the client-side script and the RP server after the authorization flow is completed (i.e., the access token has been delivered to the client-side script). This gap requires a client-side script to transmit an SSO credential to the sign-in endpoint on the RP server to identify the current SSO user and issue an authentication cookie. However, if the sign-in endpoint is not SSL-protected, the SSO credential can be eavesdropped.

#### Automatic Authorization Granting

IdPs offer an "automatic authorization granting" feature to enhance both performance and user experience, but this feature also enables an attacker to steal access tokens through an XSS exploit. We observed that when a page containing an SDK library is loaded, an access token is returned to the library automatically without explicit user consent. This happens when the requested permissions have been granted before, and the user has already logged into the IdP in the same browser session. Further investigation revealed that obtaining access tokens in the background is enabled by several design decisions, including (1) for simplicity, OAuth 2.0 removes the signature requirement for an authorization request [17], (2) for usability, a repeated authorization request is granted automatically without prompting the user for consent, and (3) for flexibility, redirect URI restriction is based on an HTTP domain rather than a whitelist, so access tokens could be obtained on any page within the RP domain.

Automatic authorization granting might be useful, but it can also be harmful. This function could be used by RPs to eliminate the popup login window that simply blinks and then closes, and reduce delays when the user is ready for login. Additionally, many RPs use this design feature to (1) refresh an access token when it expires, (2) log the user into the RP website automatically, and (3) integrate the user’s social context on the client side directly to reduce the overhead of round-trip communication with the RP server. While useful, this function enables an attacker to obtain access tokens via a malicious script executed on any page of an RP website, even when the redirect URI is SSL-protected and the user has not logged into the RP yet. Surprisingly, we found that even server-flow RPs that obtain access tokens through direct communication with the IdP are vulnerable as well.

#### Cross-Domain Communication in SDK

IdP SDK libraries employ cross-domain communication (CDC) mechanisms for passing access tokens between cross-origin windows. As demonstrated by several researchers [3, 20, 46], passing sensitive information through CDC channels can impose severe security threats. Facebook SDK uses the postMessage HTML5 API and Adobe Flash for cross-frame interactions. For postMessage, Hanna et al. [20] found that, due to insufficient checks on the sender’s and receiver’s origin in the code, both tokens and user data could be stolen by an attacker. For Flash, Wang et al. [46] uncovered a vulnerability that allows an attacker to obtain the session credential of a victim user by naming the malicious Flash object with an underscore prefix. Both vulnerabilities were reported and fixed by Facebook, but they might appear again in future IdP SDK implementations.

We examined Microsoft’s SDK and found that it does not use any CDC mechanism for passing access tokens. Instead, a cookie shared between same-origin frames is used. Microsoft SDK requires RPs to include its SDK library on the page of the redirect URI, which is under the RP’s domain. The library on the redirect URI page extracts the access token from the URI fragment and saves it to a cookie.