corruption just implies that the cluster is overwritten since, by definition, the cluster cannot be Hcorrupted".
Lesson 1 Type checking is usefulfor detecting pointer cor(cid:173)
ruption. However, systems that use type checking should not
overload the data types.
NTFS does not detect corruption when one index buffer
pointer (RootlndxBuf, SDH, SII, or DirlndxBuf)
points to a wrong index buffer.
the type
"INDX" is overloaded; it is used to represent different data
structures used for different purposes. Not detecting cor(cid:173)
ruption in these cases leads to further corruption by NTFS.
Thus, when a data type is used for different purposes in dif(cid:173)
ferent places, it must be assigned a different type identifier
to prevent corruption across uses.
In this case,
that NTFS detects
Pitfalll Inadequate / inconsistent use ofsanity checks.
corruption to any
We observe
pointer with an out-of-bounds value without
reading
Targetcorrupt. Similarly, the corruption is detected im(cid:173)
mediately when Boot-MFTM is assigned the value MFTO
(Row 2, column 6 in Figure la). These immediate detec(cid:173)
tions indicate the use of sanity checks. However, while
NTFS detects the above corruption scenario where point(cid:173)
ers Boot -MFTM and Boot -MFTO are equal,
it allows
MFTO - MFTM and MFTO - MFT to be equal (Row 5, column 6
in Figure la), although the Targetoriginal for each pointer
is the same as before. This difference in behavior points to
the lack of a consistent approach. There are more examples
ofinconsistencies - pointers for which some corruptions are
recovered from, while others are not even detected.
Lesson 2 Type checks do not workfor all pointers. There(cid:173)
fore, detailed sanity checks should be performed.
In the e ca e , anity checkin a
y e checkin i not u efu for ointer
ke F i 1 eDat a
since a type identifier cannot be stored in a user data clus(cid:173)
ter.
i(cid:173)
nificance. However, NTFS does not perform many simple
anity check that can determine whether a ointer i cor(cid:173)
ru t. For exam e,N FS doe not check whether a ointer
reater
une
ointin to the boot ec10r (Boot).
We note that not a N FS behavior can be ex
ailed
ba ed on anity or ty e checkin . N F S detect corru tion
of UpCase after readin Targetcorrupt for orne ex eri(cid:173)
ment but doe not detect for other . It i not c mr what
kind of check i u ed for thi
5.3.2. Reactions
N F S react
either recover
It
from corru tion, or re ort an error to the
in variou way on detectin corru tion.
ointer.
1-4244-2398-9/08/$20.00 ©2008 IEEE
507
DSN 2008: Bairavasundaram et al.
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 13:08:01 UTC from IEEE Xplore.  Restrictions apply. 
International Conference on Dependable Systems & Networks: Anchorage, Alaska, June 24-27 2008
Pointer
Boot-MFTO
Boot-MFTM
MFTO-MFT
MFTBitmap
MFTO-MFTM
LogFile
RootSecDesc
Root IndxBuf
SDS
SDH
SII
UpCase
DirlndxBuf
FileData
reports error for LastCluster; does not detect all other cases and corrupts
Interestingly, this corruption of Targetcorrupt is reversed for LogRes and LogResDup due to the or-
NTFS Behavior Details
Reports error and retries mount for values MFTMirror, LastCluster and Out-of-bounds; recovers using replica for others.
Reports error and retries mount for values MFTO, LastCluster and Out-of-bounds; recovers using replica for others.
Recovers using MFT mirror for values RootSecDesc, LastCluster and Out-of-bounds; reports error and retries mount for
others - however, both Targetcorrupt and the replica (MFT Mirror) are corrupted ifthe value is not an MFT entry or Boot.
Recovers only for an out-of-bounds value; reports error for the value Boot (however, NTFS corrupts Boot); does not detect
all other cases corrupting Targetcorrupt and possibly an MFT entry.
Recovers for an out-of-bounds value;
Targetcorrupt.
der of disk operations.
Recovers for an out-of-bounds value or LastCluster; attempts repair but corrupts clusters for LogResDup; reports error and
retries for others but corrupts the replica of the pointer in MFT mirror.
Reports error and retries mount for values LastCluster and Out-of-bounds; other cases are undetected.
Reports error and retries mount for all values except for other index buffers (SDH, SII or DirIndxBuf) which go undetected
thus corrupting Targetcorrupt.
Reports error and retries for Boot, LastCluster Last-Size+1 and out-of-bounds (For Last-Size+1, report and retry occur after
corrupting it); attempts to repair data structure for other cases, resulting in corruption of Targetcorrupt.
Reports and retries during mount for an out-of-bounds value; reports error during CreateFile for other values except
for index buffers (SII, RootIndxBuf and DirIndxBuf) which go undetected thus corrupting Targetcorrupt.
Reports and retries mount for all values.
Reports error and retries mount for the 10 detected cases (refer Figure 1); undetected cases do not cause further corruption.
Reports an error for all values except for other index buffers (these go undetected, thus corrupting Targetcorrupt).
Reports an error for values Last Cluster and out-of-bounds; others are not detected leading to corruption ofTargetcorrupt.
The corruption is reversed for LogRes, LogResDup, MFTO, and MFTMirror due to the order of disk operations.
Table 5. NTFS Behavior Details. The table presents the details ofNTFS behavior when its pointers are corrupted.
application, or retries the mount operation, or attempts to
repair a seemingly corrupt data structure.
Observation 2 NTFS typically uses replication to recover
from corruption.
We observe that NTFS uses replication of MFT VCN 0 to
recover from corruption to the pointer Boot -MFTO. In this
case, it uses the MFT mirror to obtain the required informa(cid:173)
tion. Similarly, NTFS uses redundant information in MFT
VCN 0 to recover from corruption to Boot-MFTM. Inter(cid:173)
estingly, for both pointers, this recovery is temporary; that
is, NTFS does not overwrite the corrupt pointer with the
correct value. Thus, the same recovery has to be performed
for each mount. This approach could lead to unrecoverable
data loss in the event of a second failure (loss or corrup(cid:173)
tion). When an out-of-bounds value is used for the pointers
MFTO-MFT, MFTBitmap, MFTO-MFTM, and LogFile,
NTFS performs permanent recovery; that is, the pointer
value is overwritten with the correct value, thus completely
healing the file system image.
Observation 3 NTFS uses error reporting and retries in re(cid:173)
sponse to corruption when it is unable to recover.
As described in Table 5, typically, NTFS reports an error to
the application when corruption is detected. For a subset of
cases, NTFS also retries the mount operation, perhaps hop(cid:173)
ing that the corruption is transient and mount will succeed
the second time. These retries do not succeed since the cor(cid:173)
ruption is persistent. Examples of pointers for which this
behavior is observed include MFTO -MFT and LogFile.
Observation 4 NTFS attempts to repair certain data struc(cid:173)
tures that it believes to be corrupt.
When the pointer SDS is corrupted, NTFS assumes that
the security descriptors pointed to by SDS are corrupt and
attempts to reinitialize the data structure, thus corrupting
Targetcorrupt. Similar behavior occurs when LogFile
points to LogResDup instead of LogRes (the log restart
In this case, the first cluster of the data region of
area).
the log is corrupted.
Pitfall 2 Detecting that a pointer target is corrupt instead
ofdetecting that the pointer is corrupt.
The instances under Observation 4 above show that NTFS
trusts the pointer to be correct, while not trusting the cluster
pointed to. Thus, attempting to repair a seemingly corrupt
target causes more harm than good if the corruption is actu(cid:173)
ally to the pointer.
In general, we observe that there are multiple instances
where NTFS does not detect the corruption or detects the
corruption but does not recover from it despite possessing
type information to detect corruption and redundancy to re(cid:173)
cover from corruption. Table 6 shows that despite possess(cid:173)
ing redundant information, NTFS detects an error but does
not recover from it in 87 cases, and in fact, causes further
corruption in 88 cases. From these failures, we derive more
potential pitfalls when handling pointer corruption.
Pitfa1l3 Ineffective replica management:
(a) not using
replicas when available, (b) destroying secondary replicas
without verifying the primary, and (c) not maintaining inde(cid:173)
pendent access paths for replicas.
(a) When pointers in MFT VCN 0 are corrupted, NTFS does
not use the copy ofpointers available in the MFT mirror for
most scenarios. For some pointers, NTFS could but does
1-4244-2398-9/08/$20.00 ©2008 IEEE
508
DSN 2008: Bairavasundaram et al.
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 13:08:01 UTC from IEEE Xplore.  Restrictions apply. 
International Conference on Dependable Systems &Networks: Anchorage, Alaska, June 24-27 2008
Pointer
Boot-MFTO
Boot-MFTM
MFTO-MFT
MFTBitmap
MFTO-MFTM
LogFile
RootSecDesc
Root IndxBuf
SDS
SDH
SII
UpCase
DirlndxBuf
FileData
Total
Total recoverable
22
22
2
51
51
3
3
7
23
2
22
3
22
25
10
22
2
145
87
16
24
42
42
23
23
25
3
3
17
4
24
122
49
16
24
20
1
3
24
3
4
20
115
88
16
24
24
64
64
Table 6. NTFS Behavior Summary.
The table
summarizes observed NTFS behavior on corruption for
the different pointers. The first column indicates l1'hether
some form of redundancy exists for either the pointer or
Targetoriginal. Columns 2 to 5 summarize the number of
cases for which NTFS behaves in a certain manner (from
Figure 1). The last two columns indicate the total number
ofcases for which further corruption occurs and for which
the replica ofthe pointer is destroyed. The penultimate row
is the sum of all rows and the last row is the sum of rows
that have a J for the uRedundancy?" column.
not use the replica for comparing and detecting that the
pointer is possibly corrupt. An example is MFTBi tmap.
For other pointers, NTFS detects corruption through dif(cid:173)
ferent means (type or sanity checking). However, NTFS
does not use the replica for recovering from the corruption.
(b) There are 64 instances where the replica of the pointer
is overwritten by NTFS with the corrupt value (the last col(cid:173)
umn of Table 6). In particular, in the cases where the pri(cid:173)
mary MFT (MFT VCN 0) is corrupt, but the MFT mirror is
correct, NTFS erroneously synchronizes the two copies by
overwriting the MFT mirror with data in the corrupt MFT.
(c) For some of the data structures in NTFS, the replica is
placed at a fixed virtual offset from the regular copy, thus
often using a single pointer value to access both. The secu(cid:173)
rity descriptors are an example. Corruption to the pointer
SDS will thus make both the regular copy and the replica
inaccessible (Figure 1a shows that NTFS does not recover
when SDS is corrupted).
Pitfall 4 Not realizing that most indexes are simply perfor(cid:173)
mance improvements and that their unavailability should
not cause complete failure.
NTFS uses two indexes SDH and SII for its security de(cid:173)
scriptors in $Secure. The security descriptors contain all
information necessary to rebuild both the indexes. How-
ever, when either SDH or S I I is corrupted, NTFS does not
recover despite detecting the corruption.
5.4. User-Visible NTFS Results
The previous subsection detailed NTFS behavior in re(cid:173)
sponse to pointer corruption. However, understanding these
actions does not imply an understanding of how they mani(cid:173)
fest to users or applications. The primary concern for users
is data and system reliability. Hence, in this subsection, we
discuss user-visible results of NTFS behavior. Figure 1b
presents the user-visible results.
Observation 5 The system works correctly when NTFS re(cid:173)
covers from corruption.
The system works without problems in 61 scenarios (17%),
primarily because NTFS detects and recovers from corrup(cid:173)
tion. For example, corruption ofanyone pointer field (MFT,
MFTMirror) in the boot sector does not affect normal opera(cid:173)
tion. In 10 other cases, even though NTFS does not recover,
pointer corruption does not cause problems due to the order
of disk operations or due to non-use of Targetcorrupt.
Observation 6 The most frequent user-visible result is an
unmountablefile system.
The file system becomes unmountable when NTFS detects
corruption to a pointer used during mount, but is unable
to recover. This situation applies to many pointers across
the range of values used. An example of such a pointer is
LogF i 1 e. The file system could also become unmountable
when undetected pointer corruption (e.g., for Fi 1 eDat a)
causes key data structures to be corrupted. The file system
is rendered unmountable in 133 scenarios (37%).
Observation 7 Other user-visible results include: (a) loss
ofdata or user-visible metadata, (b) failure ofmanyfile op(cid:173)
erations, and (c) corruption ofuserfile data.
(a) Data or metadata loss occurs
in 102 scenarios
(28%). Data is rendered inaccessible when the pointers
DirlndxBuf, RootSecDesc, SDS, and UpCase are
corrupted.
(b) For some corruption scenarios, file opera(cid:173)
tions fail since NTFS does not recover from the pointer
corruption. An example is corruption to SDH; attempts to
create files fail while files already created can be accessed.
Note that operations also fail when data or metadata is lost.
In total, file operations fail in 127 scenarios (35%). (c) User
data corruption occurs in 8 scenarios (2%), when user file
data is overwritten with other data or metadata, e.g., when a
file data pointer points to another file's data clusters.
Lesson 3 Undetected pointer corruption can pose a signif(cid:173)
icant security risk.
One would expect that pointer corruption might affect data
on a particular disk. However, it could be worse; most
experiments involving the pointer MFTBi tmap result in a
system crash (22 cases), thus affecting the entire system.
By systematically setting bits contained in Targetcorrupt
1-4244-2398-9/08/$20.00 ©2008 IEEE
509
DSN 2008: Bairavasundaram et al.
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 13:08:01 UTC from IEEE Xplore.  Restrictions apply. 
International Conference on Dependable Systems &Networks: Anchorage, Alaska, June 24-27 2008
.cQJ
.c
QJ QJ
=
;1
~
QJ
't:l
=
C"-.
~
U
=~ = =
~~ ~i U