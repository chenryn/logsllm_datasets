collective signing as described above in Section III including
the signing exception protocol for handling witness failures.
We evaluated the cothority implementation with Schnorr
signatures implemented on the Ed25519 curve [14], although
the implementation also works and has been tested with other
curves such as the NIST P-256 curve [5].
A. Witness Cosigned Time and Timestamp Service
As one application of witness cosigning, we built a digital
timestamping service [2], [63], [121], which also doubles as
a coarse-grained secure time service. The primary timestamp
server, serving as the CoSi leader, initiates a new signing round
periodically – currently once every 10 seconds – to timestamp
a batch of documents or nonces submitted by clients. While
the timestamp server could initiate a fresh witness cosigning
round to service each client timestamping request, this mode of
operation would be unlikely to scale to serve large timestamp
request transaction rates, due to the global communication
CoSi imposes on each signing round (see Section III-I).
1) Timestamp Request Processing: A client wishing to
timestamp a document opens a connection to the timestamp
server and submits a hash of the document to stamp. Many
clients can have outstanding timestamp requests at once, and
a single client can concurrently submit timestamp requests for
multiple documents at once; the timestamp server enqueues
these requests but does not answer them until the next signing
round has completed. At the beginning of each signing round,
the timestamp server collects all of the hashes submitted since
the previous round into a Merkle tree [91], and prepares a
timestamp record to sign consisting of the current time and
the root of this round’s timestamp tree. The timestamp server
does not actually log these timestamp records, but the records
are hash-chained together in case witnesses wish to do so. The
timestamp server uses CoSi to distribute the new timestamp
record to all available witnesses and produce a collective
signature on the timestamp record.
Finally,
the timestamp server replies to the outstanding
client requests, giving each client a copy of the timestamp
record and a standalone inclusion proof relating the client’s
submitted hash to the Merkle tree root contained in the time-
stamp record. To verify that a document was indeed included,
the veriﬁer of a document timestamp uses the document’s hash,
the timestamp server’s certiﬁcate (including the public keys of
all witnesses), the timestamp record, and the Merkle inclusion
proof, to verify that the document was indeed timestamped in
that round and that a threshold number of witnesses validated
the timestamp record.
The timestamp server never records or transmits the full
Merkle tree itself, and forgets the Merkle tree after the round
concludes. The server transmits only individual
inclusion
proofs to satisfy client requests. Thus, the timestamp server
leaves to clients the responsibility of remembering timestamp
records and cryptographic evidence that a particular document
was timestamped. The primary security property is bound into
the timestamp record’s collective signature, which attests that
the witnesses veriﬁed that the record was formed and signed
at approximately the time indicated in the timestamp record.
2) Coarse-grained Time Checking: Since the timeserver
does not care whether a value submitted for timestamping is
actually a hash of documents or merely a random number,
clients can submit a random nonce to timestamp a “challenge”
and obtain a witness cosigned attestation of the current time.
Timestamping a challenge in this way ensures that attackers
cannot replay valid but old signed timestamp records to trick
clients into thinking the time is in the past: the client can verify
directly that the timestamp record is fresh, and can trust the
536536
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:12:54 UTC from IEEE Xplore.  Restrictions apply. 
timestamp it contains on the assumption that a threshold of
the timestamp server’s witnesses are honest.
Such a coarse-grained time-check may be useful as a sanity-
check for the client’s NTP sources [95], [96], enabling the
client to protect itself against both compromised NTP servers
and other time-related vulnerabilities [86]. Due to the coordi-
nation required for collective signing, CoSi’s coarse-grained
time checking will not substitute for ﬁne-grained NTP-based
clock synchronization. CoSi’s coarse-grained sanity checking
is instead complementary to NTP,
increasing security and
ensuring that clients cannot be tricked into believing that the
time is far removed from reality in either direction.
3) Scalable Timestamping: To illustrate how applications
can further leverage CoSi’s architecture in application-speciﬁc
ways, we enhanced the timestamp server prototype to enable
the witnesses, in addition to the leader, to serve timestamp
requests submitted by clients. Thus, all witnesses effectively
become timestamp servers and can distribute the task of
handling heavy client timestamp loads. In this use of CoSi, the
leader defers formation of the timestamp record to be signed
until the beginning of the Challenge phase (Section III-E).
During the Commitment phase, each witness collects all
timestamp requests clients submitted since the last round into
a local Merkle timestamp tree, including the timestamp tree
roots generated by child witnesses, then passes the aggregated
Merkle timestamp tree up to the witness’s parent. The leader
thus forms a global timestamp tree that transitively includes
all witnesses’ local timestamp trees.
During the Challenge phase, the leader passes down to each
witness an inclusion proof relating the root timestamp record
to the root of the witness’s local timestamp tree. Once the CoSi
signing round concludes, forming the collective signature, each
witness can compose its inclusion proof with the inclusion
proof for each client request within its local timestamp tree,
to give each client a complete inclusion proof relating that
client’s submitted hash with the signed timestamp record.
B. Witness Cosigned Certiﬁcate Logging Service
As a second application and test-case building on an exist-
ing service, we incorporated CoSi as a backward-compatible
extension to Google’s existing Certiﬁcate Transparency log
server [76], [78]. CT’s log server periodically constructs a
Merkle tree of records for recently timestamped and logged
certiﬁcates, and creates a Signed Tree Head (STH) represent-
ing the root of each epoch’s tree of timestamp records. With
our extension, the log server attaches a collective witness
signature to each STH alongside the log server’s existing
individual signature. Since the collective signature is carried
in an extension ﬁeld, legacy CT clients can simply ignore it,
while new CT clients that are aware the log server supports
witness cosigning can verify the witness signature extension.
CT normally relies on a gossip protocol [104] to enable
other auditor servers to check retroactively that a log server
is behaving correctly, and not revising or forking its history
for example. Our extension effectively makes this auditing
function proactive, enabling the log server’s witnesses to check
the log server’s behavior before each record is signed and
withhold their cosignature on the STH if not.
The protection this extension offers CT clients in practice
depends of course on client behavior. Current CT clients
typically check only individually-signed log server timestamp
records attached to logged certiﬁcates, and thus would not di-
rectly beneﬁt from collective signatures on STHs. A log server
could in principle witness cosign each timestamp record, but
the communication cost could become prohibitive for log
servers that timestamp a high volume of certiﬁcates.
However, independent of our witness cosigning extension,
CT is currently being enhanced so that clients can obtain from
web servers not only the appropriate timestamp record but
the STH representing the epoch in which it was logged, and
an inclusion proof demonstrating that the timestamp record
was included in the STH for the relevant epoch. Thus, CT
clients supporting both this STH inclusion proof extension and
our STH cosigning extension can obtain proactive protection
from secret attacks by powerful adversaries who might have
compromised both a CA’s key and a few log servers’ keys, and
who might be able to block the client’s active communication
with uncompromised log servers.
VI. EVALUATION
The primary questions we wish to evaluate are whether
CoSi’s witness cothority architecture is practical and scalable
to large numbers, e.g., thousands of witnesses, in realistic sce-
narios. Important secondary questions are what the important
costs are, such as signing latencies and computation costs.
While this paper’s primary focus is on the basic CoSi proto-
col and not on particular applications or types of cothorities,
we also evaluated the CoSi prototype in the context of the
timestamping and log server applications discussed above.
A. Experimental Setup
We evaluated the prototype on DeterLab [44], using up
to 32 physical machines conﬁgured in a star-shaped virtual
topology. To simulate larger numbers of CoSi participants than
available testbed machines, we run up to 1,058 CoSi witness
processes on each machine to perform experiments with up
to 33,825 witnesses total, corresponding to a fully populated
tree of depth 3 and a branching factor of 32. A corresponding
set of CoSi client processes on each machine generate load by
issuing regular timestamp requests to the server processes.
To mimic a conservatively slow, realistic wide-area envi-
ronment in which the witness cothority’s servers might be
distributed around the world, the virtual network topology
imposes a round-trip latency of 200 milliseconds between any
two witnesses. The witnesses aggregate timestamp statements
from their clients and request every second the batch of state-
ments to be signed collectively as part of a single aggregate
Merkle tree per round. These testbed-imposed delays are likely
pessimistic; global deployments could probably achieve lower
latencies using approximate shortest-path spanning trees.
537537
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:12:54 UTC from IEEE Xplore.  Restrictions apply. 
s
d
n
o
c
e
s
n
i
y
c
n
e
t
a
l
d
n
u
o
r
i
g
n
n
g
S
i
8.00
4.00
2.00
1.00
0.50
2
JVSS
Naive
NTree
CoSi
User
System
32.00
16.00
8.00
4.00
2.00
1.00
0.50
0.25
0.12
0.06
d
n
u
o
r
r
e
p
s
d
n
o
c
e
s
U
P
C
e
g
a
r
e
v
A
oversubscription
JVSS
Naive
NTree
CoSi
8
32
128
512
2048
8192
32768
Number of witnesses
2
8
32
128
512
2048
8192
32768
Number of witnesses
Fig. 3. Collective signing latency versus number of participating witnesses.
Fig. 4. Per-node, per-round computation cost versus number of participating
witnesses.
B. Scalability to Large Witness Cothorities
Our ﬁrst experiment evaluates the scalability of the CoSi
protocol while performing simple collective signing rounds
across up to 33,825 witnesses. We compare CoSi’s perfor-
mance against three different baselines. The ﬁrst baseline is
“Naive” scheme in which the leader simply collects N stan-
dard individual signatures via direct communication with N
witnesses. Second, an “NTree” scheme still uses N individual
signatures, but the N witnesses are arranged in a communica-
tion tree and each node veriﬁes all signatures produced within
its subtree. Finally, a “JVSS” scheme implements Schnorr
signing using joint veriﬁable secret sharing [55], [125].
Figure 3 shows the results of this scalability experiment.
The lines represent averages measured over ten experimental
runs, while the shaded areas behind the lines represent the
minimum and maximum observed latencies over all ten runs.
CoSi’s signing latency increases with the number of hosts
as we would expect, scaling gracefully with total number of
witnesses up to around 8,192 witnesses, where the perfor-
mance impacts of testbed oversubscription begin to dominate
as explored later in Section VI-F. Per-round collective signing
latencies average slightly over 2 seconds with 8,192 cosigning
witnesses. The maximum latency we observed in that situation
was under 3 seconds over many runs. Given that many
authority protocols are or can be made fairly latency-tolerant,
often operating periodically at timescales of minutes or hours,
these results suggest that witness cosigning should be practical
to enhance the security of many such authorities.
The Naive scheme is naturally simpler and as a result
faster for small witness groups, but becomes impractical
beyond around 256 witnesses due to the costs of computing,
transmitting, and verifying N individual signatures.
The even poorer performance of the NTree scheme can be
traced back to the increasing computational load each node
must handle the further up it resides in the communication
tree. As with the Naive scheme, NTree becomes impractical