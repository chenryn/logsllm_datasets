4161293100530874836836422603625206824589693933040432789074054165274
087272587
题目中只给出了（n，e.c）三者的信息，为了能够计算出d从而解出c
我们必须要将n分解。继续使用yafu进行分解，如图21-7所示。
我们使用yafu成功分解了n，接下来使用分解出的p和g来计算d
从而解得明文m，代码如下：
or(41376
8196303384218941117367850019509202049026037168194982219784159)
ac:factoring 41376961156168948196303384218941117367850019509202049026037168194982219784159
einfo:
/gnfs crossover of 95 digits
g 1000 iterations on C77
1000
ves on C77,B1=11K,B2=
gmp-ecm
：149/149
tarting SIQS on c77: 41376961156168948196303384218941117367850019509202049026037168194982219784159
sieving in progress (1 thread):35008 relations needed *
ADQ 8
SIQS elapsed time = 104.4771 se
DtalIactoring tiBe
sfactors foundios
317183651045971246384245233153006206783
图21-7yafu使用方法示意图2
fromCrypto.Util.number import long_to_bytes,bytes_to_long.getPrime,isPrime
---
## Page 713
CTF特训营：技术详解、解题方法与
21.2.2直接模数分解
713/1144
importprimefac
def modinv(a,n):
returnprimefac.modinv(a,n)%n
#fromproblem
n=
4137696115616894819630338421894111736785001950920204902603716819498
2219784159
e=65537
C=
4161293100530874836836422603625206824589693933040432789074054165274
087272587
#fromyafu
p=130451115685568383270871808144053983073
q=317183651045971246384245233153006206783
#calc
d=modinv(e,（p-1)*(q-1))
m=pow(c,d,n)
print long_to_bytes(m)
输出结果如下：
flag(rsa_256bit_brute)
在将m转换为字符串的时候，我们使用了PyCrypto提供的
long_to_bytes函数。
---
## Page 714
CTF特训营：技术详解、解题方法与
21.2.3费马分解和Pollard_rho分解714/1144
21.2.3费马分解和Pollard_rho分解
前文中可以直接将n分解成功的原因是Bob选择的两个大素数太
小了，导致可以被爆破。即使选择p和q计算出的n很大，也会因为p
和q差距过远或者过于接近而产生问题。
我们都知道n=p*q，其中，p和q都是大素数，也就是奇数，这样
必定存在a和b，使得a=(p+q)/2，b=(p-q）/2，n=a²-b²。这时我们通过
枚举大于n的完全平方数，就可以分解n。这种方法适用于p和q的差
分解完毕。以上就是费马分解的原理
Pollardrho分解则与之相反，Pollardrho算法的原理就是通过桌
种方法得到两个整数a和b，计算p=gcd（a-b，n），直到p不为1，或者
a、b出现循环为止。然后再判断p是否为n，如果p=n成立，那么返回
n是一个质数，否则返回p是n的一个因子，接着，我们又可以递归地
计算Pollard（p）和Pollard（n/p)，这样，我们就可以求出n的所有质因子
值，实践中，通常取c为1，即b=a²+1，在下一次计算中，将b的值赋
---
## Page 715
CTF特训营：技术详解、解题方法与
21.2.3费马分解和Pollard_rho分解
715/1144
给a，再次使用上式来计算新的b的值，当a、b出现循环时，即可退
出并进行判断。在实际计算中，a和b的值最终肯定会出现一个循
环，而如果用光滑的曲线将这些值连接起来，则可以近似地看成是一
个p型的。对于Pollard_rho，它可以在O（sqrt（p））的时间复杂度内找到n
的一个小因子p，所以当n的两个素因子差距过大，即有一方过小的
话都可以通过Pollard_rho进行分解。
在题目中是看不出是否可以使用以上两种分解方法的，因为你只
能看到n的大小。不过幸运的是，yafu已经集成了上述两种分解方法，
我们可以在做题的时候进行尝试。示例数据如下：
n=
4000396308493166483792868970280586952700866555255033909996603978365
5241478271793221934708351067146540431087045575578735452562033981331
4774288666763468926094086933706407506660945860303066117072904855395
8489762050043121378109622992873815524493007661052252601134478852987
2573418170482451512833863359887844080223
e=65537
C=
2596003374356717350048173906641095443084901059265023089667051166955
3503559256272713866266533161921604492120388382053827180109196444750
4549710165940597953216235244043231059097231625318446199638824950598
194974747402699552746346829359679622002
使用yafu进行分解，如图21-8所示。
---
## Page 716
CTF特训营：技术详解、解题方法与
21.2.3费马分解和Pollard_rho分解
716/1144
图21-8yafu使用方法示意图3
由图21-8可知，使用yafu很快即可分解完毕，我们可以看到即使
n的长度是1024bit的，也会由于其中一个素因子太小而导致成功分解。
分解成功后，我们利用分解出的p和q计算出d，进而求得如下明文：
from Crypto.Util.number import long_to_bytes,bytes_to_long.getPrime,isPrime
import primefac
defmodinv(a,n):
return primefac.modinv(a,n)%n
n=
4000396308493166483792868970280586952700866555255033909996603978365
5241478271793221934708351067146540431087045575578735452562033981331
4774288666763468926094086933706407506660945860303066117072904855395
8489762050043121378109622992873815524493007661052252601134478852987
2573418170482451512833863359887844080223
e=65537
C=
4546795133990879205450002148351829823639584652544166879344560474495
2596003374356717350048173906641095443084901059265023089667051166955
3503559256272713866266533161921604492120388382053827180109196444750
4549710165940597953216235244043231059097231625318446199638824950598
194974747402699552746346829359679622002
p=2216926567
---
## Page 717
CTF特训营：技术详解、解题方法与
21.2.3费马分解和Pollard_rho分解
717/1144
q=
1804478491999219423758598933457856366020474757229536105783247613706
6041790220376398211438074695212284147383328992141008273893825361573
8628246889858967947536029926473612198207260628810474315125524342816
8313236714458626169781302906310389993397109964379010755539598733577
3839106223531693331380363831369
d=modinv(e,(p-1)*(q-1)
m=pow(c,d,n)
print long_to_bytes(m)
结果输出如下：
flag(yafu_is_great)
我们再来看一道例题，题目提供的信息如下：
n=
3161262255255421133292506694323988711204792818702640666084331634444
1487124289159506399545409744699314266187020446723181349086787306419
8141403703405832035915824681398715467917815939183223299019373845411
6371045928434239936027006539348488316754611586659587677659791620481
2007325640683671485412424265338236265865749152752095083001205748191
6703127977870534715039005822312878739611630155714313119545610939253
3558087426468918154427586602785149764315219337632726156532610446070
4187621299888373272466241019703841972177329060110906596567412959962
6151139566369
e=65537
c=
6315839115926606522154126830886887854389383864033233231312475345619
5853128857061213413928809053361954887615644749862793862641961796891
8299212863936839701943643735437264304062828205809984533592547599060
8294516682405693841301300809282920828885265679026957072156600202013
9264038851837906324448720488143959181339849528502570428578107298702
4698133147354238702861803146548057736756003294248791827782280722670
4571573852057872599798048929665295369029598136755370288794078023654
---
## Page 718
CTF特训营：技术详解、解题方法与
21.2.3费马分解和Pollard_rho分解
718/1144
3902471194209112305830546085667691045826809779853290104005050690614
1547909766093323197363034959926900440420805768716029052885452560625
308314284406
这里n是2048bit，同样也适用于利用yafu进行分解，如图21-9所
示。
由图21-9可以看出，即使p和g都很大，都是1024bit，也会由于
两者之间差距的太小，从而在很快的时间内被分解出来。后续工作不
必多说，与前面的相同，代码如下：
from Crypto.Util.number import long_to_bytes,bytes_to_long,getPrime,isPrime
import primefac
def modinv(a,n):
returnprimefac.modinv(a,n)%n
=
3161262255255421133292506694323988711204792818702640666084331634444
1487124289159506399545409744699314266187020446723181349086787306419
6371045928434239936027006539348488316754611586659587677659791620481
2007325640683671485412424265338236265865749152752095083001205748191
1385189593291220878391565276456831977148230933843436409468157913508
6703127977870534715039005822312878739611630155714313119545610939253
3558087426468918154427586602785149764315219337632726156532610446070
4187621299888373272466241019703841972177329060110906596567412959962
6151139566369
---
## Page 719
CTF特训营：技术详解、解题方法与
21.2.3费马分解和Pollard_rho分解
719/1144
714313119545
ser of 96 digits
154587641560637103663061410793471960999514235968345127013716
图21-9yafu使用方法示意图4
e=65537
c=
6315839115926606522154126830886887854389383864033233231312475345619
5853128857061213413928809053361954887615644749862793862641961796891
8299212863936839701943643735437264304062828205809984533592547599060
8294516682405693841301300809282920828885265679026957072156600202013
9264038851837906324448720488143959181339849528502570428578107298702
4698133147354238702861803146548057736756003294248791827782280722670
4571573852057872599798048929665295369029598136755370288794078023654
3902471194209112305830546085667691045826809779853290104005050690614
308314284406
p=
5622510342592017974501982842338225503008622660078323739858272024425
0840205090747144995470046432814267877822949968612053620215667790366
3384139792563577139754987644980457107663756141079347198093984514223
5988345125703333716856093782471927588570982419376052330632721791010
6187213556299122895037021898556005848447
q=
5622510342592017974501982842338225503008622660078323739858272024425
0840205090747144995470046432814267877822949968612053620215667790366
3384139792563577139754987644980457107663756141079347198093984514223
5988345125703333716856093782471927588570982419376052330632721791010
6187213556299122895037021898556005848927
d=modinv(e,(p-1)*(q-1))%((p-1)²(q-1))
m=pow(c,d,n)
---
## Page 720
CTF特训营：技术详解、解题方法与
21.2.3费马分解和Pollard_rho分解
720/1144
print long_to_bytes(m)
结果输出如下：
flag(yafu_is_great_2)
---
## Page 721
CTF特训营：技术详解、解题方法与
21.2.4公约数模数分解
721/1144
21.2.4公约数模数分解
如果Alice和Bob之间进行了两次消息传递的过程，且Bob不小心
在两次通信中生成的大素数有一个是相同的，那么Cat就可以通过对
两次通信的n进行求公约数的计算进而分解出两次通信的n。示例数
据如下：
n1=
2073868481933354864319160615403911272143904067556330654462561090915
2027142345256262044893684039033760000345977227424255285988276861540
8747952724598851671077867117030720610371533466558604707161098132709
7085048435924659633399548237052738635124047839132332452800362893678
1466053608725537623942740662936457390959060237568952795905984480747
2521319534314869199154547676661732117663249716982167290568237194039
3594824633702516913632842369076018175420141312999861284029031228887
0691831451331041035467130371628700808661866849510093563933041998781
8576050894302540206465891008406682791753073642686147229795023494597
33201313546503
e1=65537
c1=
4147487255697901583915872785212226386740804827031504209013873678271
1954901843479769097261138499925678227321579013857593972853542785811
0078110379350109579035057921183720286907514854591794631868488230746
6012864770911316092169851618822067233715426324048255853708450136404
8192663242053870445181150072953187849255464219274545695310831299403
9610039750037010020953694095297010211754157921861334470506369708155
3171695308476917272505352835269504338531141476596188545187942246478
9601281601642155227122173343282564823442388418039674313621754555112
77916355166899
n2=
8786943631445618907285673578128969065736407845231978676063517743990
1499716761085908380184781415392678301352973889463381331182125017539
---
## Page 722
CTF特训营：技术详解、解题方法与..
21.2.4公约数模数分解
722/1144
9588172832350502802204668189285239027528757845589294842002240172592
4370391459133256442791171090767044083995998801191405341251943486452
9677540592266259324118264160788239330014913189609069849152404831693
2705009559990813224701252763576238909934950609696492497965839739030
3632051436652851864517075326335258047336448737074832375662685357471
9019426137074931948836881412856529444940507252018234253636995370272
7897335358473
e2=65537
c2=
2376551337745495498143783836277905001359434157198875983392352023653
6079566611195909403531345378099484061992649508077938144679081351890
8835569778599590997952101265062119955537337009202023005665064419169
5731622240605564238060013790626918092343022945758900319577845906202
1310593348317550868080002647389745118852918093422370684255314762743
3419417974129891780223669046995420628808654917468181393159896092139
0785087102754534749899379867108150767902748565046767786034338660373
8557102458445549054413054789435377742118058621420441605645098200054
7280801569612056927906751952250584177103864064194663069251203452999
2860041798564
这种攻击情况通常适用于多组加密过程，并且e为65537，同时n
都很大的情况。下面对n和n2进行gcd计算，代码如下：
importprimefac
n1=
2073868481933354864319160615403911272143904067556330654462561090915
2027142345256262044893684039033760000345977227424255285988276861540
8747952724598851671077867117030720610371533466558604707161098132709
7085048435924659633399548237052738635124047839132332452800362893678
1466053608725537623942740662936457390959060237568952795905984480747
2521319534314869199154547676661732117663249716982167290568237194039
3594824633702516913632842369076018175420141312999861284029031228887
0691831451331041035467130371628700808661866849510093563933041998781
8576050894302540206465891008406682791753073642686147229795023494597
33201313546503
n2=
8786943631445618907285673578128969065736407845231978676063517743990
---
## Page 723
CTF特训营：技术详解、解题方法与
21.2.4公约数模数分解
723/1144
1499716761085908380184781415392678301352973889463381331182125017539
9588172832350502802204668189285239027528757845589294842002240172592
4370391459133256442791171090767044083995998801191405341251943486452
2705009559990813224701252763576238909934950609696492497965839739030
3632051436652851864517075326335258047336448737074832375662685357471
9019426137074931948836881412856529444940507252018234253636995370272
6532830052579978881891592694167046933479761478884334265896721145936
7897335358473
printprimefac.gcd(n1,n2)
结果输出如下：
1382084273625193214157969577198934091151588456206914653064298477561
8216079345779281327452431895497776598335234559935185184752265105376
3764408505742877046122880607112556561553947348312144520937951670858
2550042542491251245198479234506979941823367965908770824790650963234
14024512145988695828388117148558948090639
通过最大公约数的计算得到了n1和n2都有一个共同的素因子p，
那么接下来的工作就简单了。通过n、n2分别去除素因子p，可以成
功分解n和n2，后续步骤与之前一样。下面解密两段密文，代码如下：
from Crypto.Util.number import long_to_bytes,bytes_to_long,getPrime,isPrime
importprimefac
def modinv(a,n):
return primefac.modinv(a,n) % n
n1=
2073868481933354864319160615403911272143904067556330654462561090915
2027142345256262044893684039033760000345977227424255285988276861540
8747952724598851671077867117030720610371533466558604707161098132709
7085048435924659633399548237052738635124047839132332452800362893678
1466053608725537623942740662936457390959060237568952795905984480747
---
## Page 724
CTF特训营：技术详解、解题方法与
21.2.4公约数模数分解
724/1144
2521319534314869199154547676661732117663249716982167290568237194039
3594824633702516913632842369076018175420141312999861284029031228887
0691831451331041035467130371628700808661866849510093563933041998781
8576050894302540206465891008406682791753073642686147229795023494597
33201313546503
n2=
8786943631445618907285673578128969065736407845231978676063517743990
9588172832350502802204668189285239027528757845589294842002240172592
4370391459133256442791171090767044083995998801191405341251943486452
9677540592266259324118264160788239330014913189609069849152404831693
3632051436652851864517075326335258047336448737074832375662685357471