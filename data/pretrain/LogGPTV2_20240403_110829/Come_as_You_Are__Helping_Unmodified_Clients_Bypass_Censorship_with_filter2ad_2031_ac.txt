–
–
0% 100%
–
100%
Kazakhstan
0%
100%
100%
100%
100%
–
–
–
–
–
–
–
–
100% 100%
–
–
–
–
– No evasion
100% 100%
8 TCP Window Reduction
–
–
9 Triple Load
10 Double GET
–
11 Null Flags
–
Table 2: Summary of server-side-only strategies and their
success rates. All of these strategies manipulate only TCP, and yet,
against China’s GFW, their success rates are application-dependent.
Kazakhstan’s HTTPS and Iran’s DNS-over-TCP censorship infras-
tructure are currently inactive.
5.1 Server-side Evasion in China
We applied Geneva from the server side against the GFW across
DNS, FTP, SMTP, HTTP, and HTTPS. Geneva identified 8 distinct
server-side only strategies that are successful at least 50% of the
time for at least one protocol in China: 4 for DNS, 5 for FTP, 1 for
SMTP, 4 for HTTP, and 2 for HTTPS. We provide packet waterfall
diagrams in Figure 1 which show the resulting server- and client-
behaviors when the strategies are run. Although the strategies
require no client-side modifications whatsoever, they induce client-
side behavior that assists in circumventing censorship. In the rest
of this subsection, we explore each of these strategies, explain why
they work, and describe what they teach us about China’s GFW.
Strategy 1: Simultaneous Open, Injected RST (China)
DNS (89%), FTP (52%), HTTP (54%), HTTPS (14%), SMTP (70%)
[TCP:flags:SA]-
duplicate(
tamper{TCP:flags:replace:R},
tamper{TCP:flags:replace:S})-| \/
Simultaneous Open Strategy 1 triggers on outbound SYN+ACK
packets. Instead of sending the SYN+ACK, it replaces it with two
packets—a RST and a SYN—and sends them instead. How does an
unmodified client respond to this strange sequence of packets?
First, the RST packet is actually ignored by the client, because it
does not have the ACK flag set and the TCP connection is not yet
590
SIGCOMM ’20, August 10–14, 2020, Virtual Event, USA
Bock et al.
Figure 1: Server-side evasion strategies in China. All of the strategies work without modifications to the client, and yet they induce
client-side behavior that helps circumvent censorship. (Standard packets at the beginning and the end are grayed out to emphasize the
critical differences from normal behavior.)
in a synchronized state. Despite RFC 793 [1] suggesting that the
connection be torn down, we find that in practice, TCP implementa-
tions across all modern operating systems ignore this RST. Second,
the injected SYN packet serves to initiate TCP simultaneous open.
RFC 793 [1] requires TCP implementations to support simultane-
ous open. Originally, simultaneous open was meant to occur when
two hosts attempt to open a connection by sending SYN packets to
each other at the same time. However, a server can simulate simul-
taneous open by responding to a SYN packet from the client with a
SYN packet of its own. To the client, this resembles simultaneous
open, since the client receives a SYN packet, and therefore must re-
spond with a SYN+ACK packet. This strategy employs simultaneous
open by first sending an inert RST packet, then by setting up the
connection with a SYN packet.
When used for HTTP, Strategy 1 has a success rate of 54%. We
see similar success rates for FTP and for each single DNS-over-TCP
query (recall that DNS will try up to 3 times).
It is tempting to assume that this strategy works because the
injected RST tears down the connection, and the SYN packet looks
like an entirely new connection in the reverse direction (thereby
making the censored request sent by the client ignored). However,
this is not the case—as demonstrated above, injected RST packets
either inside or outside the 3-way handshake from the server are
unable to tear down a connection. Another potential theory is
that the GFW simply cannot properly handle TCP simultaneous
open; this too, however, is incorrect: if the RST is removed from the
strategy, the strategy fails. Instead, we hypothesize that this strategy
is far more nuanced, and is actually performing a desynchronization
attack by exploiting a bug in the GFW’s resynchronization state.
Prior work has hypothesized that the presence of a RST packet
during the three-way handshake can put the GFW in a resynchro-
nization state with about 50% probability [9, 36]. Therefore, we
expect the injected RST packet not to tear down the connection,
but instead to put the GFW into the resynchronization state. Wang
et al. hypothesized that the only packets sent by the server that the
GFW resynchronizes on are SYN+ACK packets, so the next packet
for the GFW to resynchronize on is the SYN+ACK packet sent by the
client. At this point, the GFW should just properly resynchronize
onto our connection—but it does not. Why?
When TCP simultaneous open is performed, the sequence num-
ber does not advance during the handshake in the same fashion
as it does in a regular TCP three-way handshake. During TCP si-
multaneous open, the SYN+ACK packet sent by the client retains
the same sequence number as the original SYN packet, and 1 is
not added to the sequence number until the ACK packet is sent.
Therefore, if the GFW’s resynchronization state is not aware that
simultaneous open is being performed, it will synchronize onto this
SYN+ACK packet and assume that the sequence number has already
been incremented by 1, as it would be if this were an ACK packet
finishing the regular 3-way handshake. As such, the GFW will fail
to advance its sequence number by 1 when the request is sent by
the client, making the GFW desynchronized by 1 byte from the real
connection.
To test this theory, we instrumented a client-side request to
decrement the sequence number of the forbidden request by 1
while the strategy is run on the server side. If the theory holds, we
expect to experience censorship approximately 50% of the time (as
this is how frequently China’s censors enter the resynchronization
state [36]). Indeed, when we perform this experiment, that is exactly
the result we see. Note that if we perform this sequence number
adjustment experiment without running the server-side strategy,
we never experience censorship as expected, because the real query
is now desynchronized from the connection.
This experiment suggests that Strategy 1 actually performs a
desynchronization attack against the GFW, and that a bug exists in
the GFW’s resynchronization state handling of simultaneous open.
As we will see, this bug is quite powerful, and Geneva identifies it
repeatedly in our experiments.
Strangely, Strategy 1 does not work well against HTTPS. We
hypothesize this is because the RST does not cause the GFW to
enter the resynchronization state for HTTPS, but does for the other
protocols. The rest of this section explores a number of cases in
which TCP/IP-level attacks work well for one application-level
protocol but not another; §6 offers an explanation why this occurs.
591
ClientServerSYNRSTSYNSYN/ACKACKPSH/ACKACKPSH/ACK(response)(query)Strategy 1Simultaneous open,injected RSTClientServerSYNSYNSYN/ACKPSH/ACKACKPSH/ACK(response)(query)(corrupted)SYNACKACKStrategy 2Simultaneous open,injected loadStrategy 6Corrupted load,induced RSTRSTSYN/ACKSYNClientServerFIN(w/ load)(bad ackno)SYN/ACKACKPSH/ACKACKPSH/ACK(response)(query)SYNClientServerRST(bad ackno)SYN/ACKRSTSYN/ACKACKPSH/ACKACKPSH/ACK(response)(query)Strategy 7Injected RST,induced RSTClientServer(bad ackno)SYN/ACKSYNRSTSYN/ACK(w/ load)ACKPSH/ACKACKPSH/ACK(response)(query)Strategy 5Corrupted ACK,injected loadNormal behaviorSYNSYN/ACKPSH/ACKACKPSH/ACK(response)(query)ACKClientServerStrategy 3Corrupted ACK,simultaneous openClientServerSYNSYNRSTPSH/ACKACKPSH/ACK(response)(query)SYN/ACK(bad ackno)SYN/ACKACKStrategy 4Corrupted ACK,aloneClientServerSYNSYN/ACKRSTPSH/ACKACKPSH/ACK(response)(query)ACK(bad ackno)SYN/ACKStrategy 8TCP windowreductionSYNPSH/ACKACKPSH/ACK(response)(query segment)ACKClientServer(small window)SYN/ACKPSH/ACK(query segment)PSH/ACK(query segment)Come as You Are: Helping Unmodified Clients
Bypass Censorship with Server-side Evasion
SIGCOMM ’20, August 10–14, 2020, Virtual Event, USA
Strategy 2: Simultaneous Open, Injected Load (China)
DNS (83%), FTP (36%), HTTP (54%), HTTPS (55%), SMTP (59%)
variants of this species in which the order of the two packets is
reversed.
[TCP:flags:SA]-
tamper{TCP:flags:replace:S}(
duplicate(,
tamper{TCP:load:corrupt}),)-| \/
Strategy 2 also relies on simultaneous open, but with a slightly
different mechanism. Rather than injecting a RST, it changes the
outgoing SYN+ACK packet into two SYN packets: the first SYN is well-
formed and the second has a random payload. It has comparable
success to Strategy 1, though slightly worse for FTP (36% vs. 52%)
and SMTP (59% vs. 70%), and better for HTTPS (55% vs. 14%).
Like with the first strategy, when the first SYN packet reaches
the client, it triggers simultaneous open, prompting the client to
respond with a SYN+ACK. Since both SYN packets are sent simulta-
neously, both likely cross the GFW before the client responds. The
second SYN packet with a payload will induce the GFW to enter the
resynchronization state, and like last time, the next packet available
for it to resynchronize on is the SYN+ACK packet from the client,
again desynchronizing the GFW by 1 from the connection. We
confirmed this by repeating the prior experiment on this strategy.
Strategy 2 does not damage the TCP connection despite the
client being unmodified. Although it is uncommon for SYN packets
to carry a payload, this is permitted by the RFC (this behavior is
required by TCP Fast Open), and the payload is ignored by the
client (though the client does respond with an ACK to acknowledge
the current sequence number).
Strategy 3: Corrupted ACK, Simultaneous Open (China)
DNS (26%), FTP (65%), HTTP (4%), HTTPS (4%), SMTP (23%)
[TCP:flags:SA]-
duplicate(
tamper{TCP:ack:corrupt},
tamper{TCP:flags:replace:S})-| \/
Geneva identified one final strategy relying on simultaneous
open. Strategy 3 copies the SYN+ACK packet: it corrupts the ack
number of the first, and converts the second to a SYN. The SYN+ACK
with the corrupted ack number induces the client to send a RST
packet, before responding with a SYN+ACK to initiate the TCP si-
multaneous open. However, unlike Strategies 1 and 2, this strategy
is the most successful for FTP.
Wang et al. [36], while studying HTTP censorship, hypothesized
that a SYN+ACK from the server with an incorrect ack number is
sufficient to trigger the GFW’s resynchronization state. We observe
that this is no longer true for; however, it does work for FTP censor-
ship. Therefore, when the SYN+ACK with the corrupted ack number
is sent, the FTP portion of the GFW enters the resynchronization
state and resynchronizes on the next packet from the client—the
RST induced by the incorrect ack number. Because the RST packet
has the incorrect sequence number, the GFW will become desyn-
chronized from the connection. Geneva also identified successful
Strategy 4: Corrupt ACK Alone (China)
DNS (7%), FTP (33%), HTTP (5%), HTTPS (5%), SMTP (22%)
[TCP:flags:SA]-
duplicate(
tamper{TCP:ack:corrupt},)-| \/
Strategy 4 is identical to Strategy 3, but without simultaneous
open. This shows that, although simultaneous open is not required
to evade FTP censorship, it improves the success rate (33% vs. 65%).
Strategy 5: Corrupt ACK, Injected Load (China)
DNS (15%), FTP (97%), HTTP (4%), HTTPS (3%), SMTP (25%)
[TCP:flags:SA]-
duplicate(
tamper{TCP:ack:corrupt},
tamper{TCP:load:corrupt})-| \/
Strategy 5 offers an even greater improvement in success rate.
This strategy sends a SYN+ACK with a corrupted ack number, fol-
lowed by another SYN+ACK with a random payload. As with the
previous strategies, the corrupted ack number induces the client
to send a RST packet, which the GFW resynchronizes on. This RST
is critical to the strategy’s success: if we instrument the client to
drop this induced RST, the strategy stops being effective.
Strategy 5 is highly successful (97%), but again, largely only
applicable to FTP. We do not yet understand the reason for the
improvement in success rate with the inclusion of simultaneous
open or an inert payload.
We draw special attention here to the specific order that the
injected packets are sent (first, corrupted ack, followed by injected
payload). When we reverse the order of the packets, the strategy is
ineffective. However, Geneva discovered a successful species almost
identical to this experimental ineffective strategy, requiring only
one modification:
Strategy 6: Injected Load, Induced RST (China)
DNS (82%), FTP (55%), HTTP (52%), HTTPS (54%), SMTP (55%)
[TCP:flags:SA]-
duplicate(
duplicate(
tamper{TCP:flags:replace:F}(
tamper{TCP:load:corrupt},),
tamper{TCP:ack:corrupt}),)-| \/
Resynchronization State, Revisited Strategy 6 replaces the
outbound SYN+ACK with three packets: (1) A FIN with a random
payload, (2) A SYN+ACK with a corrupted ack number, and (3) The
original SYN+ACK. Note the apparent similarity with Strategy 5: an
inert payload and SYN+ACK with corrupted ack are both sent to the
client, but Geneva found that adding the FIN makes the strategy
592
SIGCOMM ’20, August 10–14, 2020, Virtual Event, USA
Bock et al.
more effective for all but FTP. We also found that this strategy
works equally well if an ACK flag is sent instead of FIN.
When the FIN (or ACK) packet with the payload arrives at the
client, it is ignored, and like with previous strategies, when the cor-
rupted SYN+ACK packet arrives, it induces a RST. However, unlike
the previous strategies, this RST packet is not a critical component
of the strategy, but rather a vestigial side-effect of it—if we instru-
ment the client to drop the RST, the strategy is still equally effective.
This is because the GFW is resynchronizing not on the RST, but
instead on the SYN+ACK packet with an incorrect ack number.
This presents a stark difference from Strategy 5—once the cor-
rupted ack number caused the GFW to enter the resynchronization
state over FTP, the GFW did not resynchronize on the next packet
in the connection (which would be a SYN+ACK with the correct
sequence and ack numbers), but rather on the next packet from
the client (the RST with an incorrect sequence number). This has a
surprising implication: depending on the reason the GFW enters
the resynchronization state, it behaves differently.
In summary, our hypothesis for the new behavior of the resyn-
chronization state is as follows:
(1) A payload from the server on a non-SYN+ACK packet causes
the GFW to resynchronize on the next SYN+ACK packet from
the server or the next packet from the client with the ACK
flag set for every protocol.
(2) A RST from the server causes the GFW to resynchronize
on the next packet it sees from the client for each protocol
except HTTPS.
(3) A SYN+ACK with a corrupted ack number only causes a
resync for FTP, and it resynchronizes on the next packet
from the client.
We test this theory with Strategy 7, which begins by copying the
SYN+ACK packet twice. To the first duplicate, the flags are changed
to RST, to the second duplicate, the ack number is corrupted, and
the third is left unchanged. All three packets are then sent. The first
RST packet is ignored by the client, the corrupted ACK induces the
client to send a RST, and finally the client responds to the server’s
SYN+ACK with an ACK to properly finish the handshake.
Strategy 7: Injected RST, Induced RST (China)
DNS (83%), FTP (85%), HTTP (54%), HTTPS (4%), SMTP (66%)
[TCP:flags:SA]-
duplicate(
duplicate(