title:Robust Protection against Fault-Injection Attacks on Smart Cards Implementing
the Advanced Encryption Standard
author:Mark G. Karpovsky and
Konrad J. Kulikowski and
Alexander Taubin
Robust Protection against Fault-Injection Attacks on Smart Cards Implementing 
the Advanced Encryption Standard*
Mark Karpovsky, Fellow, IEEE, Konrad J. Kulikowski, Alexander Taubin, Senior Member, IEEE 
Reliable Computing Laboratory 
Department of Electrical and Computer Engineering 
Boston University 
8 Saint Mary’s Street, Boston, MA 02215 
{markkar, konkul, taubin}@bu.edu 
Abstract
We  present  a  method  of  protecting  a  hardware 
implementation  of  the  Advanced  Encryption  Standard 
(AES) against a side-channel attack known as Differential 
Fault  Analysis  attack.    The  method  uses  systematic 
nonlinear  (cubic)  robust  error  detecting  codes.    Error-
detecting  capabilities  of  these  codes  depend  not  just  on 
error patterns (as in the case of linear codes) but also on 
data at the output of the device which is protected by the 
code  and  this  data  is  unknown  to  the  attacker  since  it 
depends  on  the  secret  key.  In  addition  to  this,  the 
proposed  nonlinear  (n,k)-codes  reduce  the  fraction  of 
undetectable  errors  from  2 r(cid:16) to 
  as  compared  to  the 
corresponding  (n,k) linear code (where n-k=r and k>=r).  
We also present results on a FPGA implementation of the 
proposed protection scheme for AES as well as simulation 
results on efficiency of the robust codes.   
22 r(cid:16)
1. Introduction 
Today’s  information  security  engineer  is  faced  with 
the  problem  of  building  a  trustworthy  system  from 
untrustworthy components. Security experts claim that the 
only  workable  solutions  to  date  demand  some  minimal 
number  of  trustworthy  components.  These  trustworthy 
components  are  relied  on  for  ensuring  overall  system 
security  by  providing  services  such  as  authentication, 
encryption/decryption, cryptographic tokens and so on [1].   
Security  is  typically  provided  at  the  level  of  software 
(cryptographic  algorithms).  Traditional  cryptographic 
protocol  designs  assume  that  input  and  output  messages(cid:3)
are available to attackers, but other information about the 
keys  is  not  available.    However,  during  the  last  seven 
*
This work was partially supported by the Community  
Technology Fund of Boston University 
years a new class of attacks against cryptographic devices  
has  become  public  [2].  These  attacks  exploit  easily 
accessible  information  like  power  consumption,  running 
time,  input-output  behavior  under  malfunctions,  and  can 
be  mounted  by  anyone  using  low-cost  equipment.  These 
side-channel  attacks  amplify  and  evaluate 
leaked 
information  with  the  help  of  statistical  methods  and  are 
often  much  more  powerful  than  classical  cryptanalysis. 
Examples show that a very small amount of side-channel 
information is enough to completely break a cryptosystem 
[3].  While  many  previously-known  cryptanalytic  attacks 
can  be  analyzed  by  studying  algorithms,  side-channel 
attacks  vulnerabilities  result  from  electrical  behavior  of 
transistors  and  circuits  of  an  implementation.    This 
ultimately  compromises  cryptography  and  shifts  the  top 
priority in cryptography from the further improvement of 
algorithms  to  the  prevention  of  such  attacks  by  reducing 
variations  in  timing,  power  and  radiation  from  the 
hardware  [4],  reduction  of  observability  of  system 
behavior after fault injection [5], and theoretical extension 
of the current mathematical models of cryptography to the 
physical  setting  which  takes  into  consideration  side-
channel attacks [6].  
In  this  paper  we  focus  on  the  side-channel  attacks 
known  as  Differential  Fault  Analysis  (DFA)  [2]  attacks.  
DFA  was  first  proposed  in  1997  by  E.  Biham  and  A. 
Shamir [7] as an attack on DES.   The attacks have since 
been  applied  to  AES  by  others  [8,9,10,11].    DFA  attacks 
are based on deriving information about the secret key by 
examining the differences between a cipher resulting from 
correct operation and a cipher of the same initial message 
resulting from faulty operation.  
Several  research  groups  suggest  concurrent  error 
detection  procedures  as  a  hardware  countermeasure 
against fault injection based cryptanalysis. Karri et al. [12] 
Proceedings of the 2004 International Conference on Dependable Systems and Networks (DSN’04) 
0-7695-2052-9/04 $ 20.00 © 2004 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 12:30:51 UTC from IEEE Xplore.  Restrictions apply. 
propose to add circuitry to perform decryption, in parallel 
with  the  encryption  (with  various  possible  levels  of 
granularity)  and  compare  them  with  the  input  value  to 
ensure  that  no  error  has  occurred.  These  solutions  have 
different detection time latencies and hardware costs and, 
in general, exhibit a large cost close to that of duplication 
either  in  space  or  in  time.  It  is  clear  that  not  all-possible 
attacks  have  been  taken  into  account.  The  conclusion  of 
[12]  states  that  it  is  assumed  that  both  encryption  and 
decryption modules are not simultaneously under attack or 
faulty, that is not very realistic for example for smart card 
applications. 
The fault-detecting scheme for AES from [13] is based 
codes.  They  propose 
on  one-dimensional  parity 
associating one redundant parity bit with each byte of the 
state  matrix.  It  provides  for  detection  of  errors  involving 
an  odd  number  of  bits  in  a  byte.  Unfortunately,  the 
attacker  can  still  be  successful  if  only  even  number  of 
errors  in  a byte  element  of  state  matrix  is  injected by  the 
attacker . 
In our design, after a DFA attack is detected the device 
implementing  AES  disables  itself.      We  assume  that  the 
number of natural faults which can occur in a life span of 
a device is much less than the number of faulty ciphertexts 
needed for a realistic DFA attack.  The disabling circuitry 
can  be  composed  of  a  simple  counter  which  counts  the 
number  of  errors  detected.    When  a  predetermined 
threshold  is  reached  the  device  will  clear  the  secret  key 
from its memory thus preventing any further attacks.  This 
count  threshold  can  be  adjusted  depending  on  the 
operating  environment  and  expected  life  span  of  the 
device.    This  method  is  only  as  effective  as  the  error 
detecting  codes  used.    One  of  the  most  important  criteria 
for this method is that the error coverage of the code is as 
large as possible while maintaining a reasonable hardware 
overhead. 
  We  thus  present  a  new  class  of  systematic  nonlinear 
robust codes in Section 3 and propose a robust protection 
scheme  against  such  attacks.  We  will  use  systematic 
nonlinear robust codes for detection of DFA attacks.  The 
proposed nonlinear robust codes can be used to extend the 
error  coverage  of  linear  codes  without  increasing  their 
redundancy.    The  hardware  overhead  of  this  method  is 
less than the overhead that would be necessary if the error 
coverage  of  the  linear  code  was  increased  by  increasing 
the code’s redundancy.  We will use stuck-at fault and bit 
flip error models to justify the use of the nonlinear robust 
codes. 
We note that optimal nonsystematic robust codes have 
been  proposed  in  [14,  15]  but  these  codes  require  rather 
complicate  encoding  and  decoding  procedures,  which 
prohibits application of these codes for detection of DFA 
attacks.
For the proposed robust codes the probability of error 
detection depends not  only  on  the  error pattern  (as  in  the 
case of linear codes) but also on the data itself.  If all the 
data  vectors  and  error  patterns  are  equiprobable,  then  the 
probability of injecting an undetectable error if the device 
r(cid:16)2  if the 
is protected by our robust codes is 
device is protected by any linear code with the same r (r is 
a  number  of  redundant  bits  which  are  added  for  data 
protection).
 versus 
r22(cid:16)
For  brevity,  we  omit  the  discussion  of  AES.  The 
reader  may  consult  [16]  for  detailed  specification.  In 
Section 2 we give a detailed description of the fault model 
used,  in  Section  3  we  present  the  systematic nonlinear 
robust  codes  with  simple  encoding  and  decoding 
procedures.    Section  4  has  a  description  of  a  general 
architecture,  which  can  be  used  to  protect  AES  with  the 
presented  robust  codes. 
  Section  5  has  a  detailed 
description  of  a  FPGA  implementation  of  a  robust 
protected AES core.  In Section 6 we summarize the size 
and  overhead  statistics  of  our  FPGA  implementation.  
Section  7  shows  the  results  of  our  simulations  on 
probabilities of detecting a DFA attack, which support our 
initial  calculations.    Finally,  in  Section  8  we  present 
advantages of using the systematic nonlinear robust codes 
presented  for 
the  protection  of  AES  versus  other 
countermeasures. 
2. Fault model 
We refer to a fault as a physical malfunction of a part 
of a circuit, for example a wire being stuck-at zero, or an 
output  of  a  gate  being  stuck-at  one.    A  fault  is  what  is 
directly  created  by  an  attacker.    Faults  can  generally  be 
induced  into  a  device  by  subjecting  it  to  abnormal 
conditions.    Voltage  spikes,  clock  glitches,  extreme 
temperatures,  radiation,  eddy  currents,  and  light  can  all 
cause  faults.    However,  with  all  of  these,  with  the 
exception  of  light  [17,  18],  there  is  no  control  as  to  the 
location, and type of a fault which will be induced, these 
are  sometimes  called  probabilistic  attacks.  An  error  is  a 
manifestation of fault at the output of the device.  An error 
is  the  difference  (componentwise  XOR)  between    the 
correct and distorted outputs of the device.   
In  this  paper,  we  consider  protection  against  a 
probabilistic attack.  In this type of an attack, the attacker 
has  little  or  no  control  as  to  the  location  or  type  of  fault 
that  is  injected.    This  attack  does  not  necessitate  chip 
depackaging or specialized equipment, and as a result it is 
one of the most accessible attacks.   Regardless of where a 
fault occurs, the fault is only meaningful to an attacker if 
it manifests itself as an error at the output of the device. 
  Thus detecting a fault attack is equivalent to detecting 
the corresponding  error in the output of the device, or in 
the case of AES between each round.  In addition, because 
a  probabilistic  attack  has  little  control  over  the  location 
and timing of the faults, and hence the errors which occur, 
we further assume that the errors resulting from an attack 
are  uniformly  distributed  and  remain  constant  for  several 
different text inputs.   
Proceedings of the 2004 International Conference on Dependable Systems and Networks (DSN’04) 
0-7695-2052-9/04 $ 20.00 © 2004 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 12:30:51 UTC from IEEE Xplore.  Restrictions apply. 
3. Systematic nonlinear robust codes
N
2
(cid:32)
n
1
(cid:16) (cid:16)
2
2
(cid:16)
1
k
(6)
satisfy (4), we have from (3) and (5) for a number, N, of 
x
errors 
NN
which 
(cid:32)
N
2
are 
(cid:14)
k
2
any 
for 
(cid:16)
1
(cid:16)
1
1
2
n
(cid:14)
(cid:32)
Finally,  the  remaining 
(cid:16)
2
are detected with probability 
.
(cid:16)
rk
detected 
2
(cid:16) (cid:16) k
(cid:16)
n
1
1
2
(cid:14)(cid:16)(cid:16)
121
r
  errors  satisfying (4) 
  (cid:401)
.  
Table 1. Comparison of the proposed robust 
codes and corresponding linear codes 
ROBUST
NONLINEAR 
Number of undetectable 
errors. 
Number of  errors detected 
with probability of 1 
(cid:16)
1
n
2
(cid:14)
rk(cid:16)2
(cid:16)
1
k
2
(cid:16)
rk
(cid:16)
2
LINEAR 
NOT
ROBUST
k2
k(cid:16)
2n
2
Number of errors detected 
with probability 
(cid:14)(cid:16)(cid:16)
121
r
n
1
(cid:16) (cid:16) k
2
2
(cid:16)
1
0
non-linear  code 
The transition from linear code V to the corresponding 
VC   requires  only  addition  of  two  cubic 
networks.    Each  cubic  network  increases  the  complexity 
.  Thus  replacing 
of  encoding  and  decoding  by 
( 2rO
)
k (cid:116)
2/n
linear (n,k)  code  (
)   by  a  cubic  robust  code  with 
the  same    parameters  results in  a  reduction of  the  size of 
.
the  space  of  undetected  errors  from 
The properties of the proposed robust codes versus linear 
are summarized in Table 1.   
k2   to 
(cid:16)(cid:32)
(cid:16)
k r
2
2
n
2
r
In the above theorem and proof we had chosen a cubic 
network as the nonlinear function.  We note that a square 
in  the  respective  field  would  not  work.    Other  functions 
are also possible.  One alternative is to use a multiplicative 
  or  taking  a  higher  power.    The 
inverse  in 
)2( r
GF
alternative nonlinear functions result in a larger hardware 
overhead  or  reduced  error  coverage.    Thus,  the  cubic 
function  was  preferred  since  it  is  in  general  of  a  lower 
complexity and a results in higher error coverage.  
  Let  V be  a  binary  linear  (n,k)-code  with  2k(cid:116)n  and 
where I is an   (rxr) identity matrix 
check matrix
P I=
[
]
H
and P  is  an  ((n-k)  x  k)    matrix  of  rank n-k=r  over  GF(2)  
[19].   Then  for  any  message,  error  e  is  not  detected  iff 
e(cid:143)V.    As  it  will  be  shown  below  this  linear  (n,k)-code  V
can  be  modified  into  a  nonlinear  robust  systematic  (n,k)-
VC  is a 
code 
k2
VC  such that set E of undetected errors for 
(k-r)-dimensional subspace of V (
 instead of 
(cid:16)
rk
E
(cid:32) 2
for V).
Theorem I  
Let
VC =
{( ,
x w x GF
)
(cid:143)
w Px
(cid:32)
(cid:62)
(cid:64)3
Then the set 
E
=
e y
{
e C for all y C
V
V
k
(2 ),
(cid:128) (cid:137)
(cid:143)
GF
(cid:137)
r
(2 )}
.
}
of non-
detected errors for 
VC  is a (k-r)-dimensional subspace of 
n
2
rk
(cid:16)(cid:16) 2
 errors 
k
n
(cid:16)
1
(cid:16)
1
2
(cid:14)
V, and from the remaining 
(cid:16)
2
2
message and 
2
(cid:14)(cid:16)(cid:16)
121
r
(cid:16)
rk
 are detected with probability 1 for any 
(cid:16) (cid:16) k
1
2
 are detected with probability 
(cid:16)
1
n
. (All the messages assumed to be equiprobable).
Proof:
Error
(
x ee
,
message 
(cid:62)
P x
(
x
,(
(cid:134)
w
(ex(cid:143)GF(2k), ew(cid:143)GF(2r)) is not detected for 
)
(cid:64) )
(cid:62)
3Px
 from  
(cid:62)
(cid:64)
(cid:32)
e
)x
VC  iff: 
(cid:134)  
(1)
Px
e
w
(cid:64)
3
3
     (All computations in (1) are in 
GF
(2 )r
)
or
(cid:62)
Px
2
(cid:64) (cid:62)
Pe
x
(cid:64)
(cid:134)
(cid:62)
(cid:64)(cid:62)
Px Pe
x
2
(cid:64)
(cid:134)
(cid:62)
Pe
x
3
(cid:64)
(cid:134) (cid:32)
e
w
0
(2)
It follows from (2) that 
 is not detected for 
any x iff 
Pe
x
(cid:32) w
e
0(cid:32)
, and 
a (k-r)-dimensional subspace in 
,{(
wwx
)
)
Pe
x
(cid:32)
(cid:32)
e
w
(cid:32)
}0
 is 
Px
}
.
e (cid:32)
(
(cid:32)
E
w
x
w
,
,
)
x ee
ee
{(
(cid:32)
x ee
(
,
V
If
0(cid:32)xPe
  and 
0(cid:122)we
VC  for any x. There are 
,  then 