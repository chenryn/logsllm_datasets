In this section, we report on experiments conducted on
four drivers secured using our architecture. We ported the
device drivers for the RealTek RTL-8139 (8139too) and
8139C+ (8139cp) network cards, the driver for the Ensoniq
sound card (ens1371), and the driver for the Universal host
controller (USB) interface (uhci-hcd) to our security archi-
tecture. We used QEMU 0.9.1 (for the network and USB
drivers) and VMWare workstation 6 (for the sound driver)
running an unmodiﬁed Linux-2.6.18.1 kernel as the testbeds
for our experiments. Though the Linux kernel has several
thousand drivers, we restricted ourselves to four drivers for
two reasons. First, we only considered drivers available on
our test platforms. Second, DriverSlicer is not yet com-
pletely automatic (neither are other RPC libraries, such as
MSIDL [29]); porting drivers requires domain-speciﬁc un-
derstanding and is time-consuming. Nevertheless, the four
drivers above represent three major driver families, with dif-
ferent kernel/driver interfaces.
5.1. Privilege separation
We used DriverSlicer to partition the drivers that we con-
sidered into a k-driver and a u-driver. The k-driver of each
driver contains performance-critical code and code that re-
quires kernel privilege to execute. Figure 4 compares the
size of the k-driver and the u-driver. As this ﬁgure shows,
our architecture reduces the amount of hand-written driver
code running with kernel privilege and was able to remove
several non-critical functions to user space. As discussed in
Section 4.1, to split a driver into a microdriver, DriverSlicer
requires that the driver be annotated to clarify semantics of
pointers that cross the user/kernel boundary. Figure 4 also
presents the number of annotations needed, classiﬁed as an-
notations on kernel headers, which have to be provided just
once per version of the kernel, and driver-speciﬁc annota-
tions. As this Figure shows, device drivers can be ported into
our architecture with only a small number of annotations.
In addition to the k-driver, the kernel runtime and the RPC
monitor also execute with kernel privilege and contain RPC
code for control and data transfer. Though DriverSlicer cur-
rently emits several thousand lines of RPC code, we note that
this code is highly stylized and is automatically generated by
DriverSlicer. The correctness of this code can be ensured by
verifying DriverSlicer.
5.2. Ability to prevent attacks
We evaluated the ability of our architecture to prevent at-
tacks by simulating common attacks on driver code. As in-
dicated by recent vulnerability reports device drivers, buﬀer
over ows, especially in packet processing code and ioctl
handlers are the most exploited class of vulnerabilities. Be-
cause u-drivers contain the bulk of non-performance-critical
functionality, including parsing of control packets and ioctl
handling, we tested the ability of our security architecture at
preventing simulated buﬀer over ow attacks on u-drivers.
To do so, we ﬁrst obtained a set of invariants for each
driver using a benign workload in a controlled training phase.
This workload exercised functions implemented in the u-
307
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 13:08:20 UTC from IEEE Xplore.  Restrictions apply. 
Driver
8139too
8139cp
ens1371
uhci-hcd
Size of K-driver
SLOC
545 (33.7%)
735 (44.7%)
890 (59.7%)
2060 (81.8%)
# Functions
11 (21.6%)
21 (36.8%)
28 (43.7%)
60 (87.0%)
Size of U-driver
SLOC
1070 (66.2%)
908 (55.3%)
599 (40.3%)
457 (18.2%)
# Functions
40 (78.4%)
36 (63.1%)
36 (56.3%)
9 (13.0%)
Number of Annotations
Kernel header
Driver speci c
34
18
7
27
8
16
7
146
Figure 4. Sizes of the k-driver and the u-driver, and the number of annotations needed by DriverSlicer.
Driver
8139too
8139cp
ens1371
uhci-hcd
# Funcs. in u-driver
40
36
36
9
# Funcs. covered
35
33
14
7
Figure 5. Function coverage (in the u-
driver) obtained by the training workload.
driver of each driver, such as initializing and closing the
device and conﬁguring device parameters. Speciﬁcally, for
the network drivers, we conﬁgured several device parame-
ters using the ethtool utility, for the sound driver, we played
music ﬁles in several formats and adjusted parameters us-
ing the alsamixer utility, while for the USB driver, we in-
serted and removed several USB devices.
In addition, we
also initialized and closed the devices repeatedly. We conﬁg-
ured the training workload to maximize the number of func-
tions invoked in the u-driver. Figure 5 presents the coverage
obtained by our training workload. Although we could not
achieve 100% coverage using our workload, we expect that
such coverage can be achieved by vendors during driver de-
velopment using regression test suites. Figure 6 shows the
total number of invariants inferred for each driver.
In the testing phase, we used the RPC monitor to enforce
these invariants on u-driver to k-driver communication. Dur-
ing this phase, we simulated a compromised u-driver by con-
sidering three classes of attacks, as discussed below. Figure 6
presents the memory consumption of the RPC monitor.
• Control hijacking via injected downcalls. We simulated
code injection attacks on the u-driver by injecting ioctl sys-
tem calls that would result in a downcall to the k-driver.
For example, we injected a downcall to the kernel func-
tion netif wake queue in one of the u-driver functions. The
purpose of this function is to allow upper layers to call the
driver’s function to transmit packets and for
ow control
when transmit resources are available. This code injection
attack may result in data loss or block the wait queue.
Because the RPC monitor veriﬁes the set of downcalls that
each upcall is allowed to issue, using a control transfer pol-
icy, it was successfully able to detect such injection attacks.
• Control hijacking via modiﬁed function pointers. An
attacker with control over a u-driver can ﬁnd function point-
ers that are communicated from the u-driver to the k-driver,
and set them to point to arbitrary code (either injected code
or to existing kernel functions), thus resulting in arbitrary
code execution within the kernel. We simulated such an
attack within a u-driver function (rtl8139 get link in the
8139too driver) by modifying the dev->hard start xmit
function pointer to point to attacker-injected code. The
dev->hard start xmit function pointer typically refers to
transmits packets. When the upcall
the function that
to rtl8139 get link returns,
the kernel’s copy of the
hard start xmit function pointer will be updated, thereby
resulting in attacker-deﬁned code executing with kernel priv-
ilege each time the driver attempts to send a packet. The RPC
monitor was able to prevent this attack by enforcing the in-
Driver
8139too
8139cp
ens1371
uhci-hcd
# Invariants
2607
212
750
163
Inv. tab.
247,661
17,217
70,218
12,888
Vault tab.
65,180
14,817
3,918
7,455
Figure 6. Memory consumption (in bytes)
of the invariant and vault tables.
variant that dev->hard start xmit is not modiﬁed by a call
to the rtl8139 get link function (see Figure 3).
Although we only executed the above attack in our ex-
periments, we veriﬁed that Daikon had inferred an invariant
for each function pointer that crossed the u-driver/k-driver
boundary in all four drivers (most of them of the form fptr
= Orig(fptr)). These invariants will detect unauthorized
function pointer modiﬁcations within the u-driver and pre-
vent control hijacking attacks.
• Non-control data attacks. Sensitive scalar values, such
as I/O memory addresses, interrupt masks and conﬁgura-
tion parameters, that are marshaled between the u-driver and
the k-driver can be maliciously modiﬁed by a compromised
u-driver. For example, scalars that represent I/O memory
address ranges, e.g., dev->base addr, which represents the
base address of the driver’s I/O memory region, are set by
the kernel when the driver is loaded. These values must
not normally be modiﬁed by the driver because it will allow
the driver write access to memory regions that it does not
own, e.g., to the I/O memory regions of other devices. Yet,
a compromised u-driver can maliciously modify such sensi-
tive scalar values; when these values are marshaled into the
k-driver, they will maliciously update kernel data as well.
We simulated such an attack by modifying several non-
control data values. For instance, we modiﬁed the value of
rtl8139 intr mask within the u-driver. This variable repre-
sents a 16-bit mask; copying this value unchecked into the
k-driver will allow the driver to write to an undesired I/O
port. We were able to successfully detect this attack using
invariants that expressed relationships between the value of
the scalar before an upcall and the value after the upcall,
e.g., rtl8139 intr mask = Orig(rtl8139 intr mask).
• False positives and negatives. It is well-known that Daikon
can possibly infer serendipitous invariants, i.e., those that
are overly speciﬁc to the training workload. To determine
whether such invariants result in false positives during en-
forcement, we ran the drivers with several benign test work-
loads that called functions in the u-driver (the training work-
load used to infer invariants was the same as the one in Sec-
tion 5.2). We did not observe any false positives during this
experiment. While it is unclear whether the same result will
hold for other drivers as well, we note that in a real de-
ployment, false positives could be eliminated by manually
inspecting and reﬁning the invariants.
To evaluate false negatives, i.e., cases where invariants
fail to detect a compromised u-driver, we conducted fault-
injection experiments using the 8139too and 8139cp drivers.
(We could not conduct these experiments on the ens1371 and
308
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 13:08:20 UTC from IEEE Xplore.  Restrictions apply. 
Driver
8139too
8139too
8139cp
8139cp
uhci-hcd
Workload
TCP-send
TCP-receive
TCP-send
TCP-receive
Copy
Throughput
63.39Mbps
91.96Mbps
64.02Mbps
90.88Mbps
585.84Kbps
CPU (%)
99.76%
34.84%
99.88%
31.82%
4.92%
Original driver
Driver in our architecture
Throughput
61.20Mbps (-3.45%)
90.35Mbps (-1.8%)
64.51Mbps (+0.7%)
91.66Mbps (+0.8%)
578.95Kbps (-1.1%)
CPU (%)
99.86% (0%)
34.96% (0%)
99.94% (0%)
29.94% (-5.9%)
7.01% (+42%)
Figure 7. Performance of unmodiﬁed network and USB drivers and drivers in our security architecture.
Driver
8139too