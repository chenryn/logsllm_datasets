





B

E






EE

AEBDF
B

A	BD
EA
Figure 7: Format of joint frame seen by the receiver.
cus on two concurrent senders. The extension to multiple concurrent
senders is straightforward.
The lead sender triggers the joint transmission by transmitting a
synchronization header. The header contains a standard preamble
for packet detection and channel estimation, followed by the lead
sender identiÔ¨Åer, a Ô¨Çag indicating that this is a joint frame, and a
packet identiÔ¨Åer (16-bit hash of the IP source address, IP destination
address, and the IP identiÔ¨Åer). After transmitting the synchronization
header, the lead sender goes silent for a duration of SIFS to allow the
co-sender to switch from reception to transmission. The lead sender
stays silent for an additional duration of two symbols to allow the
co-sender to transmit its channel estimation symbols, and then begins
transmitting data. The co-sender, on its part, starts by listening on the
medium. Once it receives the synchronization header, it continues
listening till it has received the packet identiÔ¨Åer and then switches
from reception to transmission mode. The co-sender then waits
for its wait time, w1, computed as above, and transmits its channel
estimation symbols, followed immediately by data. Figs. 6(a) and (b)
show the transmission timeline of the joint frame from the perspective
of the lead sender and co-sender respectively. As a result of this
procedure, the receiver sees a single joint frame as shown in Fig. 7.
Two points are worth noting.
‚Ä¢ SourceSync extends directly to more than two senders. In this case,
after sending the synchronization header, the lead sender stays
silent for the duration of a SIFS to allow all co-senders to switch,
followed by two channel estimation symbols for each co-sender.
‚Ä¢ The overhead of synchronization is low. In particular, it consists of
a SIFS for switching and wait time, and 2 symbols per co-sender
channel estimation. For example, in the case of 802.11 using 1460
byte packets, and 12 Mbps transmission rate, the overhead is 1.7%
for two concurrent senders, and 2.8% for Ô¨Åve concurrent senders.
4.5 Delay Tracking and Mobility
The algorithm described so far ensures that senders can transmit
synchronized with each other. But what happens when nodes move?
It might seem that the changes in propagation delays resulting from
node mobility will necessitate constant probe-response exchanges
to recompute these delays, and maintain synchronization. However,
SourceSync can deal with mobility without additional probes. Instead,
ABC
DEC
DEC
F
F
	

Figure 8: Synchronization at two receivers. One-way delays are
shown. No choice of wait time allows perfect alignment at both
receivers.
it simply uses data transmissions to continuously adjust wait times at
co-senders and keep transmitters synchronized.
SpeciÔ¨Åcally, for each received joint frame, a SourceSync receiver
detects the start of the synchronization header, and computes the chan-
nels of the lead sender and the co-sender. It then measures the slopes
of both these channels, and translates the measured slopes to symbol
offsets using the technique described in ¬ß4.2. If the lead sender and
co-sender are perfectly synchronized, their symbol boundaries will
be aligned, and therefore their computed symbol offsets will also be
equal. Otherwise, the difference of the offsets corresponds exactly to
the misalignment between the senders. The receiver includes the mea-
sured misalignment in its ACK, and the co-sender uses this update to
appropriately change its wait time for the following transmission.
4.6 Synchronization at Multiple Receivers
So far, we have focused only on synchronization at a single receiver.
However, applications such as opportunistic routing would beneÔ¨Åt
from synchronization at multiple receivers.
In contrast to synchronization at a single receiver, where an appro-
priate choice of wait times at co-senders can achieve perfect align-
ment at the receiver, propagation delays may prevent us from achiev-
ing perfect synchronization simultaneously at multiple receivers. Con-
sider the senders in Fig. 8 with one-way delays as shown. To synchro-
nize at Rx1, the co-sender has to start data transmission before the
lead sender. But to synchronize at Rx2, the co-sender has to start data
transmission after the lead sender. Thus, it is not always feasible to
synchronize senders simultaneously at multiple receivers. However,
one can still leverage sender diversity gains from joint transmissions
by increasing the CP to account for the residual misalignment. The
objective of SourceSync in this case is to pick wait times at co-senders
so as to minimize the maximum misalignment at all receivers.
SourceSync formulates this problem as a linear program that es-
timates the optimal wait time, wi , for co-sender i . DeÔ¨Åne tij as the
one-way delay from co-sender i to receiver j , and Tj as the one-way
delay from the lead sender to receiver j . These values are estimated as
in the single-receiver case described in ¬ß4.2. The pair-wise misalign-
ment at receiver k of co-sender i with the lead sender can be written
as |(wi + tik ) ‚àí Tk |, and similarly the pair-wise misalignment with
another co-sender j can be written as |(wi + tik ) ‚àí (wj + tjk )|. The
linear program then chooses the wi ‚Äôs so as to minimize the maximum
pair-wise misalignment across the lead sender and all co-senders.
This optimization is a linear program, and can be solved efÔ¨Åciently,
especially since the number of co-senders and receivers is usually
small, say, < 5. Note that to determine the potential receivers to
synchronize at, we use the ETX metric as described in ¬ß7.2.
The lead sender performs this optimization and computes the neces-
sary increase in CP as the maximum misalignment across all senders.
In order to ensure that all senders in a joint transmission are synchro-
nized throughout the joint frame, it communicates the new CP to
co-senders as a Ô¨Åeld in the synchronization header. Co-senders use
this increased CP for the concurrently transmitted data symbols.
1765 Joint Channel Estimation
6 Smart Combiner
Now that senders are synchronized, the next step is to decode the joint
frame at each receiver.We focus on a single OFDM subcarrier since
OFDM subcarriers can be decoded independently. For simplicity of
exposition, we consider two concurrent senders for the rest of this
section. Our technique generalizes to multiple concurrent senders.
Say the two senders are already synchronized, and they both trans-
mit the same symbol xi in subcarrier i . After the FFT, the receiver
receives a symbol yi in subcarrier i , which is related to the transmit-
ted symbol xi as yi = Hi xi + n, where Hi is the composite channel
experienced by xi and n is noise. If the receiver knows the composite
channel Hi , it can extract xi from its received signal as xi = yi
Hi
The composite channel, however, is affected by two factors. The
Ô¨Årst is the individual channels traversed by symbol xi from each of
the senders. The second factor is that each sender has a different
oscillator crystal. It is unlikely that different crystals have exactly
the same carrier frequency [24], and therefore, each sender has a
different frequency offset with respect to the receiver. Hence, the
composite channel can be written as:
.
Hi (t) = Hi ,1e j 2œÄ ‚àÜf1t + Hi ,2e j 2œÄ ‚àÜf2t
where Hi (t) is the composite channel in subcarrier i at time t , Hi ,j
are the individual channels in subcarrier i from sender j , (j = 1, 2),
and ‚àÜfj is the frequency offset of sender j relative to the receiver.5
Since different senders have different frequency offsets, the two
components of the composite channel will keep rotating relative
to each other. SourceSync addresses this issue by leveraging the
observation that the frequency offset is relatively stable over long
periods of time. Therefore it can be computed at the same time as the
initial pair-wise propagation delay estimation and communicated to
each sender, which can then correct for the offset before transmitting
by multiplying its transmitted symbol at time t by e‚àíj 2œÄ ‚àÜfi t .
Once the transmitter corrects the offset, the receiver can estimate
each sender‚Äôs channel by using the corresponding channel estimation
symbols in the joint frame. It can then add the individual channels to
estimate the combined channel.
However, this is not sufÔ¨Åcient. One can never correct completely
for the frequency offset because, even if the estimate is relatively accu-
rate, a small residual error in frequency accumulates over time leading
to large phase errors and unrecoverable decoding errors throughout
the packet. This is why, even for a single sender-receiver pair, OFDM
decoders have to perform phase tracking to correct for residual errors
in frequency offset throughout the packet. SourceSync performs
phase tracking for the same reason. The difference, however, is that
it has to perform independent phase tracking for each of the senders.
To do so, we augment the traditional OFDM algorithm for phase
tracking. SpeciÔ¨Åcally, OFDM allocates some subcarriers known as pi-
lots in every data symbol for phase tracking. The exact algorithm for
phase tracking is in [15], but the important point here is that the algo-
rithm is designed to correct the residual frequency offset from a single
sender. Hence, this algorithm cannot work as such for concurrent
senders, since each sender has a different residual frequency offset.
We address this issue by sharing the pilots between the concurrent
senders across symbols. This is feasible since senders are synchro-
nized and have a common understanding of symbol boundaries. For
example, the lead sender can use pilot subcarriers in odd symbols,
and the co-sender can use pilot subcarriers in even symbols. The
receiver now maintains two residual frequency offset estimates which
it applies to the individual channels of the corresponding senders
before summing them to compute the composite channel.
5The frequency offset is normalized in units of the subcarrier width.
As stated earlier, even when the senders correct for the frequency
offset, there is always a residual frequency error that, over time,
causes the channel from each sender to rotate relative to the other.
Further, the initial phase of the channel for the two senders at the
beginning of a joint frame is random. The consequence of these
two behaviors is that the signals from the concurrent senders can
combine constructively or destructively depending on the random
initial phase and the rotation of the two channels, and the senders
cannot know how the signals are going to combine a priori. Thus, if
the two senders naively send the same signal, some unlucky symbols
will observe a deeply faded channel due to destructive combining and
the receiver will be unable to decode those symbols.
Let us consider a scenario where the channels from the two senders
happen to cancel each other, i.e., Hi ,1 = ‚àíHi ,2. In this case, if the
transmitters sent the same data symbol, xi , the receiver receives
Hi ,1xi + Hi ,2xi , which equals 0. Of course, one way to address the
problem would be for one transmitter to transmit xi and the other to
transmit ‚àíxi . This transformation would transform the destructive
composite channel to a channel where the two signals reinforce each
other at the receiver. But such a strategy does not always work; if the
channels were originally aligned with each other, sending xi and ‚àíxi
would result in a 0 signal at the receiver, transforming the constructive
channel into a destructive one! Since the transmitters cannot track
the individual channels and their phases ahead of transmission, they
need a coding strategy that will provide high throughput irrespective
of the relative orientations and magnitudes of the channels.
SourceSync addresses this issue by leveraging space time block
codes [39] that cleverly code data across symbols to eliminate deep
fades due to destructive combination of signals. SpeciÔ¨Åcally, in the
case of two senders, SourceSync uses the Alamouti code [2], which
is known to provide the optimal throughput in such a scenario, and
has low encoding and decoding complexity. In the case of more than
two senders, SourceSync uses a quasi-orthogonal space-time block
code [16] that is a simple extension of the Alamouti coding scheme,
and retains its simplicity of encoding and decoding. Given a sequence
of data symbols, a SourceSync lead sender uses codeword 1 from
the replicated Alamouti codebook speciÔ¨Åed by [16], and co-sender
i uses the (i + 1)th codeword from this codebook. This sequence
of codewords also has the property that the receiver can decode the
received frame even if only a subset of intended senders participate
in the concurrent transmission. Note that a receiver can determine
whether an intended co-sender participates in a transmission based on
the presence of energy in the time slots corresponding to the channel
estimation symbols of that co-sender.
7 Using SourceSync to harness sender diversity
Now that we have described the components of SourceSync, we
explain how SourceSync can be used to harness sender diversity for
opportunistic routing and wireless LANs. As we do so, we also
explain how SourceSync integrates with the MAC for both scenarios.
7.1 Combining SourceSync with Last Hop Diversity
Consider a client that is in the neighborhood of multiple APs, but has
poor connectivity to them. Uplink receiver diversity schemes like
MRD, SOFT, and Link-Alike [25, 17, 44] exploit the fact that, while
a transmitted packet has low probability of being received correctly
by a speciÔ¨Åc AP, it is likely to be received by at least one AP, and
all such APs can combine received packets or bits over the wired
177


 

C
F
BCE

	ABCD

D

DE

CD

	AB

CD

DCD

EF
E

E

FE
FF
B
C





A

A
Figure 9: SourceSync for the last hop. SourceSync can harness
sender diversity using concurrent transmissions from many APs.
network. SourceSync complements these schemes by enabling sender
diversity on the downlink, i.e., instead of a client receiving packets
from only one AP at a time, multiple neighboring APs can transmit
simultaneously to the client and increase downlink reliability.
SourceSync exploits last-hop diversity using the architecture
shown in Fig. 9. We leverage the high bandwidth of the wired net-
work connecting the access points. A SourceSync controller resides
on the wired network, and uses it to forward packets arriving from the
wired uplink to all the APs in a neighborhood. This enables multiple
APs to transmit the same data to a wireless client. Further, the APs
have a static ordering that decides which codeword of the space-time
block they will utilize for their transmission.
MAC and Association: When a client Ô¨Årst joins the wireless net-
work, it associates with multiple, say K , APs in its neighborhood,
where K is a tunable parameter. One of these APs, say the one with
the best link to the client, is chosen as the lead AP for this client and
this information is disseminated to all other APs. All the APs esti-
mate the propagation delays to their associated client. Additionally,
the APs can ofÔ¨Çine estimate their hardware turnaround delays and
propagation delays to each other. Each AP then uses this information
to calculate its delay compensation, as described in ¬ß4.4.
The APs use a contention-based MAC similar to 802.11. The only
difference is that when there is a downlink packet destined to a client,
only the lead AP contends for the medium. Once the lead AP acquires
the medium, it transmits its synchronization header followed by the
data. Upon hearing the synchronization header, all other APs join the
transmission as described in ¬ß4.4.
Similarly to 802.11, a client acknowledges successful receptions.
Note that since the ACK is on the uplink, APs can use standard re-
ceiver diversity techniques like SOFT [44] or MRD [25] to increase
the reliability of ACK reception. Received ACKs are communicated
to the lead AP over the wired network. The lead AP initiates retrans-
missions when it does not receive an ACK, and these retransmissions
are joined by the other APs, similarly to the original transmission.
Rate Adaptation: The APs coordinate rate adaptation since all si-
multaneously transmitted packets must have the same set of data
symbols. Rate adaptation in SourceSync is controlled by the lead AP.
SpeciÔ¨Åcally, the lead AP runs a standard rate adaptation algorithm
such as SampleRate, RRAA or SoftRate [3, 43, 41] which makes rate
decisions based on the feedback from the receiver (acknowledgment,
soft rate hint etc.). The lead AP then includes the chosen rate for the
packet in the synchronization header when it initiates transmission.
Other APs use this information to pick the right transmission rate.
Note that, since SourceSync can leverage power and diversity gains
across APs, the combined transmission across APs might be able to
use a rate that cannot be used by any individual transmissions.
Figure 10: SourceSync with Opportunistic Routing. SourceSync
exploits the fact that many relays hear a packet to improve throughput.
7.2 Combining SourceSync with Opportunistic Routing
In this section, we show how to extend opportunistic routing, partic-
ularly ExOR [4], to exploit sender diversity. Opportunistic routing
has been proposed to deal with lossy links in wireless mesh networks.
Consider the example in Fig. 10. Since all links have a loss rate of
0.5, a traditional single-path routing protocol will require an average
of two transmissions to deliver a packet from the source to its nexthop
router. However, when a source broadcasts its packet, the probability
that at least one of these routers will receive it is 1 ‚àí (0.5)3, and