title:Predicting vulnerable software components
author:Stephan Neuhaus and
Thomas Zimmermann and
Christian Holler and
Andreas Zeller
Predicting Vulnerable Software Components
Stephan Neuhaus*
Thomas Zimmermann+ Christian Holler* Andreas Zeller*
* Department of Computer Science
Saarland University, Saarbrücken, Germany
{neuhaus,holler,zeller}@st.cs.uni-sb.de
+ Department of Computer Science
University of Calgary, Calgary, Alberta, Canada
PI:EMAIL
ABSTRACT
Where do most vulnerabilities occur in software? Our Vul-
ture tool automatically mines existing vulnerability databa-
ses and version archives to map past vulnerabilities to com-
ponents. The resulting ranking of the most vulnerable com-
ponents is a perfect base for further investigations on what
makes components vulnerable.
In an investigation of the Mozilla vulnerability history, we
surprisingly found that components that had a single vulner-
ability in the past were generally not likely to have further
vulnerabilities. However, components that had similar im-
ports or function calls were likely to be vulnerable.
Based on this observation, we were able to extend Vul-
ture by a simple predictor that correctly predicts about half
of all vulnerable components, and about two thirds of all
predictions are correct. This allows developers and project
managers to focus their their eﬀorts where it is needed most:
“We should look at nsXPInstallManager because it is likely
to contain yet unknown vulnerabilities.”
Categories and Subject Descriptors: D.2.4 [Software
Engineering]: Software/Program Veriﬁcation—Statistical
methods; D.2.5 [Software Engineering]: Testing and De-
bugging—Testing tools; D.4.6 [Operating Systems]: Se-
curity and Protection—Invasive software.
General Terms: Security, Experimentation, Measurement
Keywords: Software Security, Prediction
1.
INTRODUCTION
Many software security problems are instances of general
patterns, such as buﬀer overﬂow or format string vulnerabil-
ities. Some problems, though, are speciﬁc to a single project
or problem domain: JavaScript programs escaping their jails
are a problem only in web browsers. To improve the secu-
rity of software, we must therefore not only look for general
problem patterns, but also learn speciﬁc patterns that apply
only to the software at hand.
Modern software development usually does a good job in
tracking past vulnerabilities. The Mozilla project, for in-
stance, maintains a vulnerability database which records
all incidents. However, these databases do not tell how
these vulnerabilities are distributed across the Mozilla code-
base. Our Vulture tool automatically mines a vulnerability
database and associates the reports with the change history
to map vulnerabilities to individual components (Figure 1).
Vulture’s result is a distribution of vulnerabilities across
the entire codebase. Figure 2 shows this distribution for
Mozilla: the darker a component, the more vulnerabilities
were ﬁxed in the past.The distribution is very uneven: Only
4% of the 10,452 components were involved in security ﬁxes.
This raises the question: Are there speciﬁc code patterns that
occur only in vulnerable components?
In our investigation, we were not able to determine code
features such as, code complexity or buﬀer usage that would
correlate with the number of vulnerabilities. What we found,
though, was that vulnerable components shared similar sets
of imports and function calls.
In the case of Mozilla, for
instance, we found that of the 14 components importing
nsNodeUtils.h, 13 components (93%) had to be patched be-
cause of security leaks. The situation is even worse for those
15 components that import nsIContent.h, nsIInterface-
RequestorUtils.h and nsContentUtils.h together—they
all had vulnerabilities. This observation can be used for
automatically predicting whether a new component will be
Vulnerability
database
Version
archive
Code
Code
Code
New
component
Vulture
produces
Predictor
maps vulnerabilities to components
predicts vulnerability
Component
Component
Component
Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proﬁt or commercial advantage and that copies
bear this notice and the full citation on the ﬁrst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciﬁc
permission and/or a fee.
CCS’07, October 29–November 2, 2007, Alexandria, Virginia, USA.
Copyright 2007 ACM 978-1-59593-703-2/07/0010...$5.00.
Figure 1: How Vulture works. Vulture mines a vul-
nerability database (e.g. a Bugzilla subset), a version
archive (e.g. CVS), and a code base, and maps past
vulnerabilities to components. The resulting predic-
tor predicts the future vulnerabilities of new compo-
nents, based on their imports or function calls.
529Figure 2: Distribution of vulnerabilities within Mozilla’s codebase. A component’s area is proportional to its
size; its shade of gray is proportional to its number of vulnerabilities. A white box means no vulnerabilities,
as is the case for 96% of the components.
vulnerable or not: “Tell me what you import or what you
call, and I’ll tell you how vulnerable you are.”
After discussing the scope of this work (Section 2), the
remainder of this paper details our original contributions,
which can be summarized as follows.
• We present a fully automatic way of mapping vulner-
abilities to components (Section 3).
• We provide empirical evidence that vulnerabilities cor-
relate with component imports (Section 4).
• We show how to build fully automatic predictors that
predict vulnerabilities of new components based on
their imports and function calls (Section 5).
• Our evaluation on the Mozilla project shows that these
predictors are accurate (Section 6).
After discussing related work (Section 7), we close with con-
clusions and future work (Section 8).
2. SCOPE OF THIS WORK
Our work is empirical and statistical: we look at correla-
tions between two phenomena—vulnerabilities on one hand
and imports or function calls on the other—, but we do not
claim that these are cause-eﬀect relationships. It is clearly
not the case that importing some import or calling some
function causes a vulnerability. Programmers writing that
import statement or function call generally have no choice in
the matter: they need the service provided by some import
or function and therefore have to import or call it, whether
they want to or not.
Our hypothesis is that the cause of the vulnerability is
the import’s or function’s domain, that is, the range of ser-
vices that it uses or implements. It appears that some do-
mains are more risky than others, and being associated with
a particular domain increases the risk of having a vulnera-
bility. Diﬀerent projects might have diﬀerent risky domains,
which would lead Vulture to mine project-speciﬁc vulnera-
bility patterns.
We have also identiﬁed the following circumstances that
could aﬀect the validity of our study:
Study size. The correlations we are seeing with Mozilla
could be artifacts that are speciﬁc to Mozilla. They
might not be as strong in other projects, or the cor-
relations might disappear altogether. From our own
work analyzing Java projects, we think this is highly
unlikely [29]; see also Section 7 on related work.
Bugs in the database or the code. The code to analyze
the CVS or import the Security Advisories into the
database could be buggy; the inputs to the machine-
learning methods or the code that assesses the eﬀec-
tiveness of these methods could be wrong. All these
risks were mitigated either by sampling small subsets
and checking them manually for correctness, or by im-
plementing the functionality a second time starting
from scratch and comparing the results. For example,
some machine-learning inputs were manually checked,
and the assessment code was rewritten from scratch.
Bugs in the R library. We rely on a third-party R library
for the actual computation of the SVM and the predic-
tions [9], but this library was written by experts in the
ﬁeld and has undergone cross-validation, also in work
done in our group [29].
Wrong or noisy input data. It is possible that the Mo-
zilla source ﬁles contain many “noisy” import relations
in the sense that some ﬁles are imported but actually
never used; or the Security Advisories that we use to
map vulnerabilities to components could accidentally
or deliberately contain wrong information. Our mod-
els do not incorporate noise. From manually checking
some of the data, we believe the inﬂuence of noise to
be negligible, especially since results recur with great
consistency, but it remains a (remote) possibility.
Yet unknown vulnerabilities. Right now, our predictions
are evaluated against known vulnerabilities in the past.
Finding future vulnerabilities in ﬂagged components
would improve precision and recall; ﬁnding them in
unﬂagged components would decrease recall.
3. COMPONENTS AND VULNERABILITIES
3.1 Components
For our purposes, a component is an entity in a software
project that can have vulnerabilities. For Java, components
would be .java ﬁles because they contain both the deﬁnition
and the implementation of classes. In C++, and to a lesser
extent in C, however, the implementation of a component
is usually separated from its interface: a class is declared
in a header ﬁle, and its implementation is contained in a
source ﬁle. A vulnerability that is reported only for one ﬁle
of a two-ﬁle component is nevertheless a vulnerability of the
entire component. For this reason, we will combine equally-
named pairs of header and source ﬁles into one component.
In C, it is often the case that libraries are built around
abstractions that are diﬀerent from classes. The usual case
is that there is one header ﬁle that declares a number of
structures and functions that operate on them, and several
ﬁles that contain those functions’ implementations. With-
out a working build environment, it is impossible to tell
which source ﬁles implement the concepts of which header
ﬁle. Since we want to apply Vulture to projects where we
do not have a working build environment—for example be-
cause we want to analyze old versions that we cannot build
anymore due to missing third-party software—, we simply
treat ﬁles which have no equally-named counterpart as com-
ponents containing just that ﬁle. We will subsequently refer
to components without any ﬁlename extensions.
Of course, some components may naturally be self-contai-
ned. For example, a component may consist only of a header
ﬁle that includes all the necessary implementation as inline
functions there. Templates must be deﬁned in header ﬁles.
A component may also not have a header ﬁle. For example,
the ﬁle containing a program’s main function will usually
not have an associated header ﬁle. These components then
consist of only one ﬁle.
3.2 Mapping Vulnerabilities to Components
A vulnerability is a defect in one or more components that
manifests itself as some violation of a security policy. Vul-
nerabilities are announced in security advisories that pro-
vide users workarounds or pointers to ﬁxed versions and help
them avoid security problems. In the case of Mozilla, advi-
sories also refer to a bug report in the Bugzilla database. We
use this information, to map vulnerabilities to components
through the ﬁxes that remove the defect.
First we retrieve all advisories from the Web to collect the
defects, in case of Mozilla from the “Known Vulnerabilities
in Mozilla Products” page.1 We then search for references
to the Bugzilla database that typically take the form of links
to its web interface:
https://bugzilla.mozilla.org/show_bug.cgi?id=362213
The number at the end of this URL is the bug identiﬁer of
the defect that caused the vulnerability. We collect all bug
identiﬁers and use them to identify the corresponding ﬁxes
in the version archive. In version archives every change is
annotated with a message that describes the reason for that
change. In order to identify the ﬁxes for a particular defect,
say 362213, we search these messages for bug identiﬁers such
as “362213”, “Bug #362213”, and “ﬁx 362213” (see also Fig-
ure 3). This approach is described in detail by ´Sliwerski et
al. [30] and extends the approaches introduced by Fischer et
al. [10] and by ˇCubrani´c et al. [7].
Once we have identiﬁed the ﬁxes of vulnerabilities, we can
easily map the names of the corrected ﬁles to components.
Note that a security advisory can contain several references
to defects, and a defect can be ﬁxed in several ﬁles.
It is important to note that we do not analyze binary
patches to programs, but source code repository commits.
Binary patches usually address a number of bugs at once,
which are not necessarily vulnerabilities, or contain function-
ality enhancements. In contrast, commits are very speciﬁc,
ﬁxing only one vulnerability at a time. This is why we can
determine the aﬀected components with conﬁdence.
3.3 Vulnerable Components in Mozilla
Mozilla as of 4 January 2007 contains 1,799 directories and
13,111 C/C++ ﬁles which are combined into 10,452 compo-
nents. There were 134 vulnerability advisories, pointing to
302 bug reports. Of all 10,452 components, only 424 or
4.05% were vulnerable.
Security vulnerabilities in Mozilla are announced through
Mozilla Foundation Security Advisories (MFSAs) since Jan-
uary 2005 and are available through the Mozilla Founda-
tion’s web site [33]. These advisories describe the vulner-
ability and give assorted information, such as Bugzilla bug
identiﬁcation numbers. Of all 302 vulnerability-related bug
reports, 280 or 92.7% could be assigned to components using
the techniques described above.2
1http://www.mozilla.org/projects/security/known-
vulnerabilities.html
2Some bug reports in Bugzilla [32] are not accessible without
Security Advisory
Changes
Components
Rank
Component
SAs BRs
# 1
# 2
# 3.5
# 3.5
# 5
# 6
# 7
# 8
# 9
# 10
dom/src/base/nsGlobalWindow
js/src/jsobj
js/src/jsfun
caps/src/nsScriptSecurityManager
js/src/jsscript
dom/src/base/nsDOMClassInfo
docshell/base/nsDocShell
js/src/jsinterp
content/base/src/nsGenericElement
layout/base/nsCSSFrameConstructor
14
13
11
11
10
9
9
8
7
6
14
24
15
15
14
10
9
14
10
17
Figure 3: Mapping Mozilla vulnerabilities
to
changes. We extract bug identiﬁers from security
advisories, search for the ﬁx in the version archive,
and from the corrected ﬁles, we infer the compo-
nent(s) aﬀected by the vulnerability.
Table 1: The top ten most vulnerable components
in Mozilla, sorted by associated Mozilla Foundation
Security Advisories (SAs) and bug reports (BRs).
Components with equal numbers of SAs get an av-
eraged rank.
Distribution of MFSAs
s
t
n
e
n
o
p
m
o
C
f
o
r
e
b
m
u
N
0
0
3
0
5
0
1
5
2
1
1 2 3 4 5 6 7 8 9
11
13
Number of MFSAs
Figure 4: Distribution of Mozilla Foundation Secu-
rity Advisories (MFSAs). The y axis is logarithmic.
If a component has a vulnerability-related bug report asso-
ciated with it, we call it vulnerable. In contrast to a vulnera-
ble component, a neutral component has had no vulnerability-
related bug reports associated with it so far.
The distribution of the number of MFSAs can be seen in
Figure 4. The most important result from this histogram is
that it directly contradicts an item of security folklore that
says that components that had vulnerabilities in the past
will likely have vulnerabilities in the future.
If that were
truly the case, the histogram should show ascending num-
bers of components with ascending numbers of reports. In
fact, however, the opposite is true: there were twice as many
components with one MFSA (292) than all components with
two or more MFSAs combined (132).
One consequence of this empirical observation is that the
number of past vulnerability reports is not a good predic-
tor for future reports, because it would miss all the com-
an authenticated account. We suppose that these reports
concern vulnerabilities that have high impact but that are
not yet ﬁxed, either in Mozilla itself or in other software that
uses the Mozilla codebase. In many cases, we were still able
to assign bug reports to ﬁles automatically because the CVS
log message contained the bug report number. By looking
at the diﬀs, it would therefore have been possible to derive
what the vulnerability was. Denying access to these bug
reports is thus largely ineﬀectual and might even serve to
alert blackhats to potential high-value targets.
ponents that have only one report. Indeed, when we take
the CVS from July 24, 2007—encompassing changes due to
MFSAs 2007-01 through 2007-25—we ﬁnd that 149 compo-
nents were changed in response to MFSAs. Of these newly
ﬁxed components, 81 were repeat oﬀenders, having at least
one vulnerability-related ﬁx before January 4. The remain-
ing 68 components had never had a security-related ﬁx.
As for using other metrics such as lines of code and so on
to predict vulnerabilities, studies by Nagappan et al. have
shown that there is no single metric that correlates with
failures across all considered projects [21].
The top ten most vulnerable components in Mozilla are
listed in Table 1. The four most vulnerable components all
deal with scripting in its various forms:
1. nsGlobalWindow, with ﬁxes for 14 MFSAs and 14 bug
reports, has, among others, a method to set the status
bar, which can be called from JavaScript and which
will forward the call to the browser chrome.
2. jsobj (13 MFSAs; 24 bug reports) contains support
for JavaScript objects.
3. jsfun (11 MFSAs; 15 bug reports) implements support
for JavaScript functions.
4. nsScriptSecurityManager (11 MFSAs; 15 bug reports)
implements access controls for JavaScript programs.
In the past, JavaScript programs have shown an uncanny
ability to break out of their jails, which manifests as a high
number of security-related changes to these components.