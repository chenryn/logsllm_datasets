# PWN：那些年坑过我们的数据类型

## 译文声明
本文为翻译文章，具体内容和含义以原文为准。

## 引言
大家好，我来填坑了！还记得我在安全客上发布的那篇关于内核PWN的文章吗？其中提到了无符号整型使用不当的漏洞利用。为什么最后传入的长度值是 `0xffffffffffff0000 | 0x100` 呢？别急，我们从基础开始讲解。本文将涵盖以下要点：
- 陌生的数据类型：文档与汇编
- 整数溢出漏洞
- 无符号整型使用不当漏洞

数据类型虽然基础但细节繁多，稍不注意就容易出现问题。这类问题不像堆栈溢出那样容易发现，但在PWN中却常常导致利用点被忽略或使Exploit崩溃。如果在入门时没有打好数据类型的基础，后续掌握更高级的攻击技术时很容易被这些问题困扰。因此，我写了这篇面向基础、从计算层面出发的数据类型相关漏洞的讲解，希望能帮助新手打好基础。

## 一、陌生的数据类型：文档与汇编
在进行PWN时，最直观判断数据类型的方法是查看IDA反编译出的C伪代码。然而，由于IDA的判定逻辑有时并不完美，某些变量可能会被识别为我们平时较少使用的数据类型。这种判断本身没有错误，但却给逆向工程人员带来了不便。

例如：`unsigned __int64` 和 `unsigned __int8` 这些不常见的数据类型如果不加注意，我们就无法有效地进行漏洞挖掘和利用。当我们在伪代码界面看到不熟悉的数据类型时，应对方法是查阅文档并结合汇编代码进行分析。

笔者在网上找到了一份微软的文档，详细列出了Visual C++ 32位和64位编译器支持的数据类型及其范围：

| 类型名称         | 字节 | 其他名称                 | 值的范围                                      |
|------------------|------|--------------------------|-----------------------------------------------|
| int              | 4    | signed                   | –2,147,483,648 到 2,147,483,647               |
| unsigned int     | 4    | unsigned                 | 0 到 4,294,967,295                            |
| __int8           | 1    | char                     | –128 到 127                                   |
| unsigned __int8  | 1    | unsigned char            | 0 到 255                                      |
| __int16          | 2    | short, short int, signed short int | –32,768 到 32,767 |
| unsigned __int16 | 2    | unsigned short, unsigned short int | 0 到 65,535 |
| __int32          | 4    | signed, signed int, int  | –2,147,483,648 到 2,147,483,647               |
| unsigned __int32 | 4    | unsigned, unsigned int   | 0 到 4,294,967,295                            |
| __int64          | 8    | long long, signed long long | –9,223,372,036,854,775,808 到 9,223,372,036,854,775,807 |
| unsigned __int64 | 8    | unsigned long long       | 0 到 18,446,744,073,709,551,615               |

### 数据类型的注意事项
- 如果类型名称以两个下划线 (__) 开始，则该数据类型是非标准的。
- `signed` 和 `unsigned` 是可以用于任何整型（除了 `bool`）的修饰符。
- `char`, `signed char` 和 `unsigned char` 在重载和模板等机制中被视为三种不同的类型。
- `int` 和 `unsigned int` 类型具有四个字节的大小，但不应依赖于 `int` 的大小，因为语言标准允许实现特定的可移植性。

### 通过汇编判断数据类型
下面我们通过一个例子来说明如何通过汇编代码来判断数据类型。以之前文章中的内核PWN案例为例：

```c
signed __int64 __fastcall core_copy_func(signed __int64 a1)
{
    signed __int64 result; // rax
    __int64 v2; // [rsp+0h] [rbp-50h]
    unsigned __int64 v3; // [rsp+40h] [rbp-10h]

    v3 = __readgsqword(0x28u);
    printk(&unk_215);

    if (a1 > 63) {
        // ...
    }
}
```

在这个例子中，`v3` 被定义为 `unsigned __int64` 类型。通过查看汇编代码，我们可以进一步确认其类型和用途。

总之，充分利用搜索引擎和文档，并结合汇编代码进行分析，可以帮助我们更好地理解和处理这些陌生的数据类型。