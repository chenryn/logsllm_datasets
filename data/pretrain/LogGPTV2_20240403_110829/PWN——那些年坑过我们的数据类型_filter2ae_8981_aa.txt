# PWN——那些年坑过我们的数据类型
|
##### 译文声明
本文是翻译文章
译文仅供参考，具体内容表达以及含义原文为准。
## 引言
老铁们我来填坑啦！
本人安全客上一篇内核pwn的坑还记得吧？就是关于无符号整型使用不当的漏洞利用，最后传进去的长度值为啥是0xffffffffffff0000|0x100，不着急，我们从基础开始介绍，这篇文章的要点包括：
  * 陌生的数据类型：文档+汇编
  * 整数溢出漏洞
  * 无符号整型使用不当漏洞
数据类型是个很基础又很细节的东西，越是这种细节的东西反而越容易坑人，它不像堆栈溢出那样的漏洞容易发现，pwn中数据类型的问题往往稍不注意就会错过利用点或者使exp莫名跑崩，不知道有多少人被它坑过；如果入门pwn的时候没有打好数据类型的基础，往后掌握了更高级的攻击面后很容易被坑，因此笔者写了这篇从计算层面出发、面向基础的数据类型相关漏洞的讲解，难度并不大，希望能帮入门者打好基础！
## 一、陌生的数据类型：文档+汇编
我们在做pwn的时候，最直观判断数据类型的途径就是看IDA反编译出的C伪代码，然而，由于IDA的判定逻辑有时候并不能彻底如人意，有时候某些变量就会被判断成我们在编程层面很少用到的数据类型，这种判断并没有错误，然而却给逆向工程人员带来了不便。
比如：unsigned __int64、unsigned
__int8，这些不常见的数据类型如果不加注意，我们就根本无法进行有效的漏洞挖掘和利用，当我们在伪代码界面看到不熟悉的数据类型，应对的方法就是查文档加看汇编
笔者在网上找到一份微软的文档：
> Visual C++ 32 位和 64 位编译器可识别本文后面的表中的类型。
>
>   * int (unsigned int)
>   * __int8 (unsigned __int8)
>   * __int16 (unsigned __int16)
>   * __int32 (unsigned __int32)
>   * __int64 (unsigned __int64)
>   * short (unsigned short)
>   * long (unsigned long)
>   * long long (unsigned long long)
>
>
> 如果其名称以两个下划线 (__) 开始，则数据类型是非标准的。
>
> 下表中指定的范围均包含起始值和结束值。
>
> 类型名称 | 字节 | 其他名称 | 值的范围  
> ---|---|---|---  
> int | 4 | signed | –2,147,483,648 到 2,147,483,647  
> unsigned int | 4 | unsigned | 0 到 4,294,967,295  
> __int8 | 1 | char | –128 到 127  
> unsigned __int8 | 1 | unsigned char | 0 到 255  
> __int16 | 2 | short、short int、signed short int | –32,768 到 32,767  
> unsigned __int16 | 2 | unsigned short、unsigned short int | 0 到 65,535  
> __int32 | 4 | signed、signed int、int | –2,147,483,648 到 2,147,483,647  
> unsigned __int32 | 4 | unsigned、unsigned int | 0 到 4,294,967,295  
> __int64 | 8 | long long、signed long long | –9,223,372,036,854,775,808 到
> 9,223,372,036,854,775,807  
> unsigned __int64 | 8 | unsigned long long | 0 到 18,446,744,073,709,551,615  
> bool | 1 | 无 | false 或 true  
> char | 1 | 无 | -128 到 127（默认）
>
> 0 到 255（当使用 [/J](https://docs.microsoft.com/zh-cn/previous-> versions/0d294k5z%28v%3dvs.120%29) 编译时）  
>  
> signed char | 1 | 无 | –128 到 127  
> unsigned char | 1 | 无 | 0 到 255  
> short | 2 | short int、signed short int | –32,768 到 32,767  
> unsigned short | 2 | unsigned short int | 0 到 65,535  
> long | 4 | long int、signed long int | –2,147,483,648 到 2,147,483,647  
> unsigned long | 4 | unsigned long int | 0 到 4,294,967,295  
> long long | 8 | 无（与 __int64 等效） | –9,223,372,036,854,775,808 到
> 9,223,372,036,854,775,807  
> unsigned long long | 8 | 无（与无符号的 __int64 等效） | 0 到
> 18,446,744,073,709,551,615  
> enum | varies | 无 | 请参阅本文后面的备注。  
> float | 4 | 无 | 3.4E +/- 38（7 位数）  
> double | 8 | 无 | 1.7E +/- 308（15 位数）  
> long double | 与 double 相同 | 无 | 与 double 相同  
> wchar_t | 2 | __wchar_t | 0 到 65,535  
>  
> 根据使用方式，__wchar_t 的变量指定宽字符类型或多字节字符类型。 在字符或字符串常量前使用 L 前缀以指定宽字符类型常量。
>
> signed 和 unsigned 是可用于任何整型（bool 除外）的修饰符。 请注意，对于重载和模板等机制而言，char、signed char 和
> unsigned char 是三种不同的类型。
>
> int 和 unsigned int 类型具有四个字节的大小。 但是，由于语言标准允许可移植代码特定于实现，因此该代码不应依赖于 int 的大小。
>
> Visual Studio 中的 C/C++ 还支持按大小分类的整型。
> 有关更多信息，请参见[__int8、__int16、__int32、__int64](https://docs.microsoft.com/zh-> cn/previous-> versions/29dh1w7z%28v%3dvs.120%29)和[整数限制](https://docs.microsoft.com/zh-> cn/previous-versions/296az74e%28v%3dvs.120%29)。
>
> 有关每个类型的大小限制的详细信息，请参阅[基本类型 (C++)](https://docs.microsoft.com/zh-cn/previous-> versions/cc953fe1%28v%3dvs.120%29)。
>
> 枚举类型的范围因语言上下文和指定的编译器标志而异。 有关更多信息，请参见[C 枚举声明](https://docs.microsoft.com/zh-> cn/previous-versions/whbyts4t%28v%3dvs.120%29)和[C++
> 枚举声明](https://docs.microsoft.com/zh-cn/previous-> versions/2dzy4k6e%28v%3dvs.120%29)。
>
> ## 请参见
>
> #### 参考
>
> [C++ 关键字](https://docs.microsoft.com/zh-cn/previous-> versions/2e6a4at9%28v%3dvs.120%29)
>
> [基本类型 (C++)](https://docs.microsoft.com/zh-cn/previous-> versions/cc953fe1%28v%3dvs.120%29)
反正就是充分利用搜索引擎，下面我们举例讲一下怎么通过汇编来判断：
先拿上一篇文章中内核pwn的core那个无符号整型漏洞为例
    signed __int64 __fastcall core_copy_func(signed __int64 a1)
    {
    signed __int64 result; // rax
    __int64 v2; // [rsp+0h] [rbp-50h]
    unsigned __int64 v3; // [rsp+40h] [rbp-10h]
    v3 = __readgsqword(0x28u);
    printk(&unk_215);
    if ( a1 > 63 )
    {