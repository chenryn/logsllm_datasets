问题。例如，可以这样重新定义List类型：
typedef struct list
{
Node * head; /* 指向链表的开头 */
Node * end;  /* 指向链表的末尾 */
} List;
当然，还要根据新的定义重写处理链表的函数，但是不用修改程序清单
17.4中的内容。对大型编程项目而言，这种把实现和最终接口隔离的做法相
当有用。这称为数据隐藏，因为对终端用户隐藏了数据表示的细节。
注意，这种特殊的ADT甚至不要求以链表的方式实现简单链表。下面是
另一种方法：
#define MAXSIZE 100
typedef struct list
{
Item entries[MAXSIZE]; /* 项数组 */
int items;         /* 其中的项数 */
} List;
这样做也需要重写list.c文件，但是使用list的程序不用修改。
最后，考虑这种方法给程序开发过程带来了哪些好处。如果程序运行出
现问题，可以把问题定位到具体的函数上。如果想用更好的方法来完成某个
任务（如，添加项），只需重写相应的函数即可。如果需要新功能，可以添
1348
加一个新的函数。如果觉得数组或双向链表更好，可以重写实现的代码，不
用修改使用实现的程序。
1349
17.4 队列ADT
在C语言中使用抽象数据类型方法编程包含以下3个步骤。
1.以抽象、通用的方式描述一个类型，包括该类型的操作。
2.设计一个函数接口表示这个新类型。
3.编写具体代码实现这个接口。
前面已经把这种方法应用到简单链表中。现在，把这种方法应用于更复
杂的数据类型：队列。
17.4.1 定义队列抽象数据类型
队列（queue）是具有两个特殊属性的链表。第一，新项只能添加到链
表的末尾。从这方面看，队列与简单链表类似。第二，只能从链表的开头移
除项。可以把队列想象成排队买票的人。你从队尾加入队列，买完票后从队
首离开。队列是一种“先进先出”（first in,first out，缩写为FIFO）的数据形
式，就像排队买票的队伍一样（前提是没有人插队）。接下来，我们建立一
个非正式的抽象定义：
类型名：    队列
类型属性：    可以储存一系列项
类型操作：    初始化队列为空
确定队列为空
确定队列已满
确定队列中的项数
在队列末尾添加项
1350
在队列开头删除或恢复项
清空队列
17.4.2 定义一个接口
接口定义放在queue.h文件中。我们使用C的typedef工具创建两个类型
名：Item和Queue。相应结构的具体实现应该是queue.h文件的一部分，但是
从概念上来看，应该在实现阶段才设计结构。现在，只是假定已经定义了这
些类型，着重考虑函数的原型。
首先，考虑初始化。这涉及改变Queue类型，所以该函数应该以Queue的
地址作为参数：
void InitializeQueue (Queue * pq);
接下来，确定队列是否为空或已满的函数应返回真或假值。这里，假设
C99的stdbool.h头文件可用。如果该文件不可用，可以使用int类型或自己定
义bool类型。由于该函数不更改队列，所以接受Queue类型的参数。但是，
传递Queue的地址更快，更节省内存，这取决于Queue类型的对象大小。这次
我们尝试这种方法。这样做的好处是，所有的函数都以地址作为参数，而不
像 List 示例那样。为了表明这些函数不更改队列，可以且应该使用const限
定符：
bool QueueIsFull(const Queue * pq);
bool QueueIsEmpty (const Queue * pq);
指针pq指向Queue数据对象，不能通过pq这个代理更改数据。可以定义
一个类似该函数的原型，返回队列的项数：
int QueueItemCount(const Queue * pq);
在队列末尾添加项涉及标识项和队列。这次要更改队列，所以有必要
1351
（而不是可选）使用指针。该函数的返回类型可以是void，或者通过返回值
来表示是否成功添加项。我们采用后者：
bool EnQueue(Item item, Queue * pq);
最后，删除项有多种方法。如果把项定义为结构或一种基本类型，可以
通过函数返回待删除的项。函数的参数可以是Queue类型或指向Queue的指
针。因此，可能是下面这样的原型：
Item DeQueue(Queue q);
然而，下面的原型会更合适一些：
bool DeQueue(Item * pitem, Queue * pq);
从队列中待删除的项储存在pitem指针指向的位置，函数的返回值表明
是否删除成功。
清空队列的函数所需的唯一参数是队列的地址，可以使用下面的函数原
型：
void EmptyTheQueue(Queue * pq);
17.4.3 实现接口数据表示
第一步是确定在队列中使用何种C数据形式。有可能是数组。数组的优
点是方便使用，而且向数组的末尾添加项很简单。问题是如何从队列的开头
删除项。类比于排队买票的队列，从队列的开头删除一个项包括拷贝数组首
元素的值和把数组剩余各项依次向前移动一个位置。编程实现这个过程很简
单，但是会浪费大量的计算机时间（见图17.6）。
1352
图17.6 用数组实现队列
第二种解决数组队列删除问题的方法是改变队列首端的位置，其余元素
不动（见图17.7）。
1353
图17.7 重新定义首元素
解决这种问题的一个好方法是，使队列成为环形。这意味着把数组的首
尾相连，即数组的首元素紧跟在最后一个元素后面。这样，当到达数组末尾
时，如果首元素空出，就可以把新添加的项储存到这些空出的元素中（见图
17.8）。可以想象在一张条形的纸上画出数组，然后把数组的首尾粘起来形
成一个环。当然，要做一些标记，以免尾端超过首端。
1354
图17.8 环形队列
1355
另一种方法是使用链表。使用链表的好处是删除首项时不必移动其余元
素，只需重置头指针指向新的首元素即可。由于我们已经讨论过链表，所以
采用这个方案。我们用一个整数队列开始测试：
typedef int Item;
链表由节点组成，所以，下一步是定义节点：
typedef struct node
{
Item item;
struct node * next;
} Node;
对队列而言，要保存首尾项，这可以使用指针来完成。另外，可以用一
个计数器来记录队列中的项数。因此，该结构应由两个指针成员和一个int类
型的成员构成：
typedef struct queue
{
Node * front; /* 指向队列首项的指针 */
Node * rear; /*指向队列尾项的指针*/
int items;    /* 队列中的项数*/
} Queue;
注意，Queue是一个内含3个成员的结构，所以用指向队列的指针作为参
数比直接用队列作为参数节约了时间和空间。
1356
接下来，考虑队列的大小。对链表而言，其大小受限于可用的内存量，
因此链表不要太大。例如，可能使用一个队列模拟飞机等待在机场着陆。如
果等待的飞机数量太多，新到的飞机就应该改到其他机场降落。我们把队列
的最大长度设置为10。程序清单17.6包含了队列接口的原型和定义。Item类
型留给用户定义。使用该接口时，可以根据特定的程序插入合适的定义。
程序清单17.6 queue.h接口头文件
/* queue.h -- Queue的接口 */
#ifndef _QUEUE_H_
#define _QUEUE_H_
#include 
// 在这里插入Item类型的定义，例如
typedef int Item;   // 用于use_q.c
// 或者 typedef struct item {int gumption; int charisma;} Item;
#define MAXQUEUE 10
typedef struct node
{
Item item;
struct node * next;
} Node;
typedef struct queue
1357
{
Node * front; /* 指向队列首项的指针  */
Node * rear; /* 指向队列尾项的指针  */
int items;  /* 队列中的项数     */
} Queue;
/* 操作：   初始化队列                  */
/* 前提条件：  pq 指向一个队列                */
/* 后置条件：  队列被初始化为空               */
void InitializeQueue(Queue * pq);
/* 操作：   检查队列是否已满               */
/* 前提条件：  pq 指向之前被初始化的队列           
*/
/* 后置条件：  如果队列已满则返回true，否则返回false     */
bool QueueIsFull(const Queue * pq);
/* 操作：   检查队列是否为空               */
/* 前提条件：  pq 指向之前被初始化的队列           
*/
/* 后置条件：  如果队列为空则返回true，否则返回false     */
bool QueueIsEmpty(const Queue *pq);
/* 操作：   确定队列中的项数               */
1358
/* 前提条件：  pq 指向之前被初始化的队列           
*/
/* 后置条件：  返回队列中的项数               */
int QueueItemCount(const Queue * pq);
/* 操作：   在队列末尾添加项               */
/* 前提条件：  pq 指向之前被初始化的队列           
*/
/*      item是要被添加在队列末尾的项          */
/* 
后置条件：  
如果队列不为空，item将被添加在队列的末
尾，    */
/*      该函数返回true；否则，队列不改变，该函数返回false*/
bool EnQueue(Item item, Queue * pq);
/* 操作：   从队列的开头删除项              */
/* 前提条件：  pq 指向之前被初始化的队列           
*/
/* 后置条件：  如果队列不为空，队列首端的item将被拷贝到*pitem中
*/
/*      并被删除，且函数返回true；           */
/*      如果该操作使得队列为空，则重置队列为
空      */
/*      如果队列在操作前为空，该函数返回false      
*/
1359
bool DeQueue(Item *pitem, Queue * pq);
/* 操作：   清空队列                   */
/* 前提条件：  pq 指向之前被初始化的队列           
*/
/* 后置条件：  队列被清空                  */
void EmptyTheQueue(Queue * pq);
#endif
1.实现接口函数
接下来，我们编写接口代码。首先，初始化队列为空，这里“空”的意思
是把指向队列首项和尾项的指针设置为NULL，并把项数（items成员）设置
为0：
void InitializeQueue(Queue * pq)
{
pq->front = pq->rear = NULL;
pq->items = 0;
}
这样，通过检查items的值可以很方便地了解到队列是否已满、是否为
空和确定队列的项数：
bool QueueIsFull(const Queue * pq)
{
1360
return pq->items == MAXQUEUE;
}
bool QueueIsEmpty(const Queue * pq)
{
return pq->items == 0;
}
int QueueItemCount(const Queue * pq)
{
return pq->items;
}
把项添加到队列中，包括以下几个步骤：
（1）创建一个新节点；
（2）把项拷贝到节点中；
（3）设置节点的next指针为NULL，表明该节点是最后一个节点；
（4）设置当前尾节点的next指针指向新节点，把新节点链接到队列
中；
（5）把rear指针指向新节点，以便找到最后的节点；
（6）项数加1。
函数还要处理两种特殊情况。第一种情况，如果队列为空，应该把front
指针设置为指向新节点。因为如果队列中只有一个节点，那么这个节点既是
1361
首节点也是尾节点。第二种情况是，如果函数不能为节点分配所需内存，则
必须执行一些动作。因为大多数情况下我们都使用小型队列，这种情况很少
发生，所以，如果程序运行的内存不足，我们只是通过函数终止程序。
EnQueue()的代码如下：
bool EnQueue(Item item, Queue * pq)
{
Node * pnew;
if (QueueIsFull(pq))
return false;
pnew = (Node *)malloc( sizeof(Node));
if (pnew == NULL)
{
fprintf(stderr,"Unable to allocate memory!\n");
exit(1);
}
CopyToNode(item, pnew);
pnew->next = NULL;
if (QueueIsEmpty(pq))
pq->front = pnew;   /* 项位于队列首端    */