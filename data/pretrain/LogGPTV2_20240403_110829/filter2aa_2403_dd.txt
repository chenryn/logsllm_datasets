节序的函数。 
常用的字节序转换函数是 htonl()和 htons()。 
在 TCP/IP 的术语里，大端字节序又称为“网络字节顺序（Network Byte Order）”，网络主机采用的字
节序叫作“主机字节顺序”。x86 和其他一些平台的主机字节序是小端字节序，但是 IBM POWER 等著名服
务器系列均采用大端字节序。因此，在主机字节顺序为大端字节序的平台上使用 htonl()或 htons()函数转换
字节序，其实不会进行真正意义上的字节重排。 
异步社区会员 dearfuture(15918834820) 专享 尊重版权
第
第 3322 章
章    内
内  存
存  布
布  局
局  
C/C++把内存划分为许多区域，主要的内存区域有： 
 全局内存空间，又称为“（全局）静态存储区 static memory allocation”。编程人员不需要为全局变
量和静态变量明确划分存储空间凡是由源程序声明的全局变量、全局数组，编译器都能够在数据
段或常量段为其分配适当的存储空间。由于整个程序都可以访问这个区域的数据，所以人们认为
使用这种存储空间数据会破坏程序的结构化体系。此外，在全局内存区存储数据之前，必须事先
声明其确切的容量。因而这个空间不适用于存储缓存或动态数组。在全局内存空间出现的缓冲区
溢出问题，往往将覆盖在内存中相邻位置的变量或缓存（请参阅本书 7.2 节的案例）。 
 栈空间，即分配给栈的存储区域。它是由编译器自动分配、释放的存储区域，常用于存放函数的
参数和局部变量。在特定情况下，局部变量可被其他函数访问（局部变量的指针作为参数传递给
被调用方函数）。在指令层面，“分配和释放栈空间的实质就是调整SP寄存器的值，因而分配和释
放栈空间的操作速度非常快。编译器只能为那些在编译阶段确定存储空间的局部变量分配栈空间。
因此，无法事先预判存储空间的缓冲型数据类型，即缓冲区和动态数组
①
① 除非像 5.2.4 节那样使用 alloca()函数。 
不会被分配到栈空间里。
在栈空间发生的缓冲区溢出问题，通常会篡改栈里的重要数据（请参阅本书 18.2 节的案例）案例）。 
 堆空间，即“动态内存分配区。C 语言的 malloc()/free()函数或 C++的 new/delete 语句即可分配、
释放堆空间）。“不必事先声明堆空间的大小”即“可在程序启动以后再确定数据块的容量”这一
特征构成了其独特的便利性。另外，程序员还可以动态调整（realloc()函数）内存块的大小，只是
调整堆空间的操作速度不很理想。在内存分配操作中，申请、释放堆空间的操作是速度最慢的操
作：在分配、释放堆空间时，进行这种操作的程序必须支持并且更新所有控制结构。在这个区域
发生的缓冲区溢出经常会覆盖堆空间的数据结构体。堆空间管理不当还会发生内存泄露问题：所
有被分配的堆空间都应当被明确地释放，否则就会出现内存泄露问题。但是程序员可能会出现“忘
记释放堆空间”的问题，还有发生释放不彻底的问题。另外，“在调用 free()函数释放空间之后再
次直接使用这块内存区域”的指令同样会带来非常严重的安全问题（请参阅本书 21.2 节的案例）。 
异步社区会员 dearfuture(15918834820) 专享 尊重版权
第
第 3333 章
章    CCPPUU  
33.1  分支预测 
现在的主流编译器基本都不怎么分配条件转移指令了。本书的 12.1.2 节、12.3 节和 19.5.2 节的编译结
果都体现了这一特性。 
虽然目前的分支预测功能并不完美，但是编译器还是在向这一方向发展。 
ARM 平台出现的条件执行指令（例如 ADRcc）及 x86 平台出现的 CMOVcc 指令，都是这一趋势的
明证。 
33.2  数据相关性 
当代的 CPU 多数都能并行执行指令（OOE/乱序执行技术）。但是，要充分利用 CPV 的乱序执行功能、
尽可能频繁地同期执行多条指令，首先就要降低各指令之间的数据相关性。所以，编译器尽可能地分配那
些不怎么影响 CPU 标识的指令。 
因为 LEA 指令并不像其他数学运算指令那样影响标识位，所以编译器越来越多地使用这种指令。 
异步社区会员 dearfuture(15918834820) 专享 尊重版权
第
第 3344 章
章    哈
哈  希
希  函
函  数
数  
哈希（hash）函数能够生成可靠程度较高的校验和（Checksum），可充分满足数据检验的需要。CRC32
算法就是一种不太复杂的哈希算法。哈希值是一种固定长度的信息摘要，不可能根据哈希值逆向“推测”
出信息原文。所以，无论 CRC32 算法计算的信息原文有多长，它只能生成 32 位的校验和。但是从加密学
的角度看，我们可以轻易地伪造出满足同一 CRC32 哈希值的多个信息原文。当然，防止伪造就是加密哈希
函数（Cryptographic hash function）的任务了。 
此外，人们普遍使用 MD5、SHA1 等哈希算法生成用户密码的摘要（哈希值），然后再把密码摘要存
储在数据库里。实际上网上论坛等涉及用户密码的数据库，存储的密码信息差不多都是用户密码的哈希值；
否则一旦发生数据库泄露等问题，入侵人员将能够轻易地获取密码原文。不仅如此，当用户登录网站的时
候，网络论坛等应用程序检验的也不是密码原文，它们检验的还是密码哈希值：如果用户名和密码哈希值
与数据库里的记录匹配，它将授予登录用户相应的访问权限。另外，常见的密码破解工具通常都是通过穷
举密码的方法，查找符合密码哈希值的密码原文而已。其他类型的密码破解工具就要复杂得多。 
单向函数与不可逆算法 
单向函数（one-way function）)是一种具有下述特点的单射函数：对于每一个输入，函数值都容易计算
（多项式时间）；但是根据函数值对原始输入进行逆向推算却比较困难（无法在多项式时间内使用确定性图
灵机计算）。本节着重讲解它的不可逆性。 
假设函数的输入值是由 10 个介于 0～9 之间的数值构成的一组矢量，且矢量中的标量仅出现一次。
例如： 
4  6  0  1  3  5  7  8  9  2 
下列算法即可实现最简单的单项函数： 
 取第 0 位的值作为参数 1（本例而言是 4）。 
 取第 1 位的值作为参数 2（本例而言是 6）。 
 交换位于参数 1、2 位置处（第 4、6 位）的值。 
本例中的第 4 位和第 6 位数字分别是： 
4  6  0  1  3  5  7  8  9  2 
             ^      ^ 
进行最终变换可得： 
4  6  0  1  7  5  3  8  9  2 
即使我们知道具体的算法和最终的函数值，我们也无法确定最初的输入值是什么。因为最初的位置参
数值可能是 0 也可能是 1，这两个参数可能会被交换位置。 
以上只是对单向函数的一种简单说明。实际应用中的单向函数远比本例复杂。 
异步社区会员 dearfuture(15918834820) 专享 尊重版权
第
第三
三部
部分
分  
一
一些
些高
高级
级的
的例
例子
子  
异步社区会员 dearfuture(15918834820) 专享 尊重版权
422 
逆向工程权威指南 
异步社区会员 dearfuture(15918834820) 专享 尊重版权
第
第 3355 章
章    温
温  度
度  转
转  换
换  
入门级的编程书籍一般都介绍“华氏温度转换为摄氏温度”的例子。 
从华氏度转换成摄氏度的计算公式为 
5 (
32)
9
F
C
⋅
−
=
笔者对程序添加了简单的出错处理： 
① 输入的温度数必须正确。 
② 核查最终结果，确保不会出现绝对零度（−273℃）以下的摄氏温度值。这是中学物理学课本介绍
过的一个常识。 
说明：调用函数 exit()会立即退出本程序，而且不会向调用方函数返回任何值。 
35.1  整数值 
#include  
#include  
int main() 
{ 
          int celsius, fahr; 
          printf ("Enter temperature in Fahrenheit:\n"); 
          if (scanf ("%d", &fahr)!=1) 
          { 
                    printf ("Error while parsing your input\n"); 
                    exit(0); 
          }; 
          celsius = 5 * (fahr-32) / 9; 
          if (celsius 
#include  
int main() 
{ 
   double celsius, fahr; 
   printf ("Enter temperature in Fahrenheit:\n"); 
   if (scanf ("%lf", &fahr)!=1) 
   { 
             printf ("Error while parsing your input\n"); 
             exit(0); 
   }; 
   celsius = 5 * (fahr-32) / 9; 
   if (celsius<-273) 
   { 
             printf ("Error: incorrect temperature!\n"); 
             exit(0); 
   }; 
   printf ("Celsius: %lf\n", celsius); 
}; 