import (
"database/sql"
_ "github.com/lib/pq" // enable support for Postgres
_ "github.com/go-sql-driver/mysql" // enable support for MySQL
)
db, err = sql.Open("postgres", dbname) // OK
db, err = sql.Open("mysql", dbname) // OK
db, err = sql.Open("sqlite3", dbname) // returns error: unknown driver "sqlite3"
练习 10.1： 扩展jpeg程序，以支持任意图像格式之间的相互转换，使用image.Decode检测支
持的格式类型，然后通过flag命令行标志参数选择输出的格式。
练习 10.2： 设计一个通用的压缩文件读取框架，用来读取ZIP（archive/zip）和POSIX
tar（archive/tar）格式压缩的文档。使用类似上面的注册技术来扩展支持不同的压缩格式，然
后根据需要通过匿名导入选择导入要支持的压缩格式的驱动包。
包的匿名导入 379
gopl
10.6. 包和命名
在本节中，我们将提供一些关于Go语言独特的包和成员命名的约定。
当创建一个包，一般要用短小的包名，但也不能太短导致难以理解。标准库中最常用的包有
bufio、bytes、flag、fmt、http、io、json、os、sort、sync和time等包。
它们的名字都简洁明了。例如，不要将一个类似imageutil或ioutilis的通用包命名为util，虽然
它看起来很短小。要尽量避免包名使用可能被经常用于局部变量的名字，这样可能导致用户
重命名导入包，例如前面看到的path包。
包名一般采用单数的形式。标准库的bytes、errors和strings使用了复数形式，这是为了避免
和预定义的类型冲突，同样还有go/types是为了避免和type关键字冲突。
要避免包名有其它的含义。例如，2.5节中我们的温度转换包最初使用了temp包名，虽然并没
有持续多久。但这是一个糟糕的尝试，因为temp几乎是临时变量的同义词。然后我们有一段
时间使用了temperature作为包名，虽然名字并没有表达包的真实用途。最后我们改成了和
strconv标准包类似的tempconv包名，这个名字比之前的就好多了。
现在让我们看看如何命名包的成员。由于是通过包的导入名字引入包里面的成员，例如
fmt.Println，同时包含了包名和成员名信息。因此，我们一般并不需要关注Println的具体内
容，因为fmt包名已经包含了这个信息。当设计一个包的时候，需要考虑包名和成员名两个部
分如何很好地配合。下面有一些例子：
bytes.Equal flag.Int http.Get json.Marshal
我们可以看到一些常用的命名模式。strings包提供了和字符串相关的诸多操作：
package strings
func Index(needle, haystack string) int
type Replacer struct{ /* ... */ }
func NewReplacer(oldnew ...string) *Replacer
type Reader struct{ /* ... */ }
func NewReader(s string) *Reader
包名strings并没有出现在任何成员名字中。因为用户会这样引用这些成员strings.Index、
strings.Replacer等。
其它一些包，可能只描述了单一的数据类型，例如html/template和math/rand等，只暴露一个
主要的数据结构和与它相关的方法，还有一个以New命名的函数用于创建实例。
包和命名 380
gopl
package rand // "math/rand"
type Rand struct{ /* ... */ }
func New(source Source) *Rand
这可能导致一些名字重复，例如template.Template或rand.Rand，这就是为什么这些种类的包
名往往特别短的原因之一。
在另一个极端，还有像net/http包那样含有非常多的名字和种类不多的数据类型，因为它们都
是要执行一个复杂的复合任务。尽管有将近二十种类型和更多的函数，但是包中最重要的成
员名字却是简单明了的：Get、Post、Handle、Error、Client、Server等。
包和命名 381
gopl
10.7. 工具
本章剩下的部分将讨论Go语言工具箱的具体功能，包括如何下载、格式化、构建、测试和安
装Go语言编写的程序。
Go语言的工具箱集合了一系列的功能的命令集。它可以看作是一个包管理器（类似于Linux中
的apt和rpm工具），用于包的查询、计算包的依赖关系、从远程版本控制系统下载它们等任
务。它也是一个构建系统，计算文件的依赖关系，然后调用编译器、汇编器和链接器构建程
序，虽然它故意被设计成没有标准的make命令那么复杂。它也是一个单元测试和基准测试的
驱动程序，我们将在第11章讨论测试话题。
Go语言工具箱的命令有着类似“瑞士军刀”的风格，带着一打子的子命令，有一些我们经常用
到，例如get、run、build和fmt等。你可以运行go或go help命令查看内置的帮助文档，为了查
询方便，我们列出了最常用的命令：
$ go
...
build compile packages and dependencies
clean remove object files
doc show documentation for package or symbol
env print Go environment information
fmt run gofmt on package sources
get download and install packages and dependencies
install compile and install packages and dependencies
list list packages
run compile and run Go program
test test packages
version print Go version
vet run go tool vet on packages
Use "go help [command]" for more information about a command.
...
为了达到零配置的设计目标，Go语言的工具箱很多地方都依赖各种约定。例如，根据给定的
源文件的名称，Go语言的工具可以找到源文件对应的包，因为每个目录只包含了单一的包，
并且包的导入路径和工作区的目录结构是对应的。给定一个包的导入路径，Go语言的工具可
以找到与之对应的存储着实体文件的目录。它还可以根据导入路径找到存储代码仓库的远程
服务器的URL。
10.7.1. 工作区结构
工具 382
gopl
对于大多数的Go语言用户，只需要配置一个名叫GOPATH的环境变量，用来指定当前工作目
录即可。当需要切换到不同工作区的时候，只要更新GOPATH就可以了。例如，我们在编写
本书时将GOPATH设置为 ：
$HOME/gobook
$ export GOPATH=$HOME/gobook
$ go get gopl.io/...
当你用前面介绍的命令下载本书全部的例子源码之后，你的当前工作区的目录结构应该是这
样的：
GOPATH/
src/
gopl.io/
.git/
ch1/
helloworld/
main.go
dup/
main.go
...
golang.org/x/net/
.git/
html/
parse.go
node.go
...
bin/
helloworld
dup
pkg/
darwin_amd64/
...
GOPATH对应的工作区目录有三个子目录。其中src子目录用于存储源代码。每个包被保存在
与$GOPATH/src的相对路径为包导入路径的子目录中，例如gopl.io/ch1/helloworld相对应的路
径目录。我们看到，一个GOPATH工作区的src目录中可能有多个独立的版本控制系统，例如
gopl.io和golang.org分别对应不同的Git仓库。其中pkg子目录用于保存编译后的包的目标文
件，bin子目录用于保存编译后的可执行程序，例如helloworld可执行程序。
第二个环境变量GOROOT用来指定Go的安装目录，还有它自带的标准库包的位置。
GOROOT的目录结构和GOPATH类似，因此存放fmt包的源代码对应目录应该为
$GOROOT/src/fmt。用户一般不需要设置GOROOT，默认情况下Go语言安装工具会将其设
置为安装的目录路径。
工具 383
gopl
其中 命令用于查看Go语言工具涉及的所有环境变量的值，包括未设置环境变量的默认
go env
值。GOOS环境变量用于指定目标操作系统（例如android、linux、darwin或windows），
GOARCH环境变量用于指定处理器的类型，例如amd64、386或arm等。虽然GOPATH环境变
量是唯一必须要设置的，但是其它环境变量也会偶尔用到。
$ go env
GOPATH="/home/gopher/gobook"
GOROOT="/usr/local/go"
GOARCH="amd64"
GOOS="darwin"
...
10.7.2. 下载包
使用Go语言工具箱的go命令，不仅可以根据包导入路径找到本地工作区的包，甚至可以从互
联网上找到和更新包。
使用命令 可以下载一个单一的包或者用 下载整个子目录里面的每个包。Go语言
go get ...
工具箱的go命令同时计算并下载所依赖的每个包，这也是前一个例子中golang.org/x/net/html
自动出现在本地工作区目录的原因。
一旦 命令下载了包，然后就是安装包或包对应的可执行的程序。我们将在下一节再关
go get
注它的细节，现在只是展示整个下载过程是如何的简单。第一个命令是获取golint工具，它用
于检测Go源代码的编程风格是否有问题。第二个命令是用golint命令对2.6.2节的
gopl.io/ch2/popcount包代码进行编码风格检查。它友好地报告了忘记了包的文档：
$ go get github.com/golang/lint/golint
$ $GOPATH/bin/golint gopl.io/ch2/popcount
src/gopl.io/ch2/popcount/main.go:1:1:
package comment should be of the form "Package popcount ..."
命令支持当前流行的托管网站GitHub、Bitbucket和Launchpad，可以直接向它们的版
go get
本控制系统请求代码。对于其它的网站，你可能需要指定版本控制系统的具体路径和协议，
例如 Git或Mercurial。运行 获取相关的信息。
go help importpath
命令获取的代码是真实的本地存储仓库，而不仅仅只是复制源文件，因此你依然可以
go get
使用版本管理工具比较本地代码的变更或者切换到其它的版本。例如golang.org/x/net包目录
对应一个Git仓库：
$ cd $GOPATH/src/golang.org/x/net
$ git remote -v
origin https://go.googlesource.com/net (fetch)
origin https://go.googlesource.com/net (push)
工具 384
gopl
需要注意的是导入路径含有的网站域名和本地Git仓库对应远程服务地址并不相同，真实的Git
地址是go.googlesource.com。这其实是Go语言工具的一个特性，可以让包用一个自定义的导
入路径，但是真实的代码却是由更通用的服务提供，例如googlesource.com或github.com。
因为页面 https://golang.org/x/net/html 包含了如下的元数据，它告诉Go语言的工具当前包真
实的Git仓库托管地址：
$ go build gopl.io/ch1/fetch
$ ./fetch https://golang.org/x/net/html | grep go-import
如果指定 命令行标志参数， 命令将确保所有的包和依赖的包的版本都是最新的，
-u go get
然后重新编译和安装它们。如果不包含该标志参数的话，而且如果包已经在本地存在，那么
代码将不会被自动更新。
命令只是简单地保证每个包是最新版本，如果是第一次下载包则是比较方便的；
go get -u
但是对于发布程序则可能是不合适的，因为本地程序可能需要对依赖的包做精确的版本依赖
管理。通常的解决方案是使用vendor的目录用于存储依赖包的固定版本的源代码，对本地依
赖的包的版本更新也是谨慎和持续可控的。在Go1.5之前，一般需要修改包的导入路径，所以
复制后golang.org/x/net/html导入路径可能会变为gopl.io/vendor/golang.org/x/net/html。最新
的Go语言命令已经支持vendor特性，但限于篇幅这里并不讨论vendor的具体细节。不过可以
通过 命令查看Vendor的帮助文档。
go help gopath
(译注：墙内用户在上面这些命令的基础上，还需要学习用翻墙来go get。)
练习 10.3: 从 http://gopl.io/ch1/helloworld?go-get=1 获取内容，查看本书的代码的真实托管
的网址（ 请求HTML页面时包含了 参数，以区别普通的浏览器请求）。
go get go-get
10.7.3. 构建包
命令编译命令行参数指定的每个包。如果包是一个库，则忽略输出结果；这可以用
go build
于检测包是可以正确编译的。如果包的名字是main， 将调用链接器在当前目录创建
go build
一个可执行程序；以导入路径的最后一段作为可执行程序的名字。
由于每个目录只包含一个包，因此每个对应可执行程序或者叫Unix术语中的命令的包，会要
求放到一个独立的目录中。这些目录有时候会放在名叫cmd目录的子目录下面，例如用于提供
Go文档服务的golang.org/x/tools/cmd/godoc命令就是放在cmd子目录（§10.7.4）。
每个包可以由它们的导入路径指定，就像前面看到的那样，或者用一个相对目录的路径名指
定，相对路径必须以 或 开头。如果没有指定参数，那么默认指定为当前目录对应的
. ..
包。 下面的命令用于构建同一个包, 虽然它们的写法各不相同:
工具 385
gopl
$ cd $GOPATH/src/gopl.io/ch1/helloworld
$ go build
或者：
$ cd anywhere
$ go build gopl.io/ch1/helloworld
或者：
$ cd $GOPATH
$ go build ./src/gopl.io/ch1/helloworld
但不能这样：
$ cd $GOPATH
$ go build src/gopl.io/ch1/helloworld
Error: cannot find package "src/gopl.io/ch1/helloworld".
也可以指定包的源文件列表，这一般只用于构建一些小程序或做一些临时性的实验。如果是
main包，将会以第一个Go源文件的基础文件名作为最终的可执行程序的名字。
$ cat quoteargs.go
package main
import (
"fmt"
"os"
)
func main() {
fmt.Printf("%q\n", os.Args[1:])