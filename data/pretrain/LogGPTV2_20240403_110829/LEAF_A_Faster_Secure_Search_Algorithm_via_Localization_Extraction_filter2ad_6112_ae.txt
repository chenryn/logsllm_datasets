ğ‘‹
?
Ã—
0
0
?
Ã—
0
0
Add Together:
ğ‘‹
Figure 8: Our Retrieval Process, we donâ€™t apply Akaviaâ€™s
method since it will add 1 additional depth.
Lemma 4.1. (1 âˆ’ ğœ€
holds if and only if ğ‘› = 1.
ğ‘›)ğ‘› â‰¥ 1 âˆ’ ğœ€, âˆ€ğ‘› âˆˆ N+, ğœ€  4, we have 2âˆš
ğ‘ƒğ‘ŸLEAF =(cid:0)1 âˆ’ ğœ€
ğ‘›  1 âˆ’ ğœ€
ğ‘› > (1 âˆ’ ğœ€
ğ‘›
ğ‘›
â–¡
Here, ğœ€ is the parameter that can be selected by the client, nor-
mally we will choose ğœ€ = 2âˆ’80, the above equation illustrates that
when ğ‘› > 4, our algorithmâ€™s output is correct with overwhelming
probability.
4.4 Retrieving Matches
Here we show how to retrieve the matched item given the en-
crypted pluse array without further interaction with clients. For the
convenience of description, we describe the process of retrieving
1-bit content. For arbitrary long content, we can retrieve each bit
in the same way.
Once we get the encrypted index of the target item, PIR would
be a feasible solution to retrieve the desired item without further
interactions at the cost of an extra degree of ğ‘‚(log ğ‘›). Akavia et
al. [2] proposed a depth-preserving method to retrieve matched
item using ğ‘‚(ğ‘›) multiplications and increasing the depth by 1.
In this paper, by rearranging the multiplication order, we can
complete the retrieval of matching items without increasing the
calculation depth, and ensure that the required number of multipli-
cation is the same as Akaviaâ€™s algorithm required, both of which
are ğ‘‚(ğ‘›), as shown in Figure 8.
It is worth pointing out that the Step 1 in the figure is very
similar to the Step 3 we mentioned in our Extraction step, which
is to extract non-zero intervals in an array by adding them, to be
specific, define ğ‘¡ğ‘’ğ‘šğ‘2 âˆˆ {0, 1}ğ‘˜, âˆ€ğ‘— âˆˆ [ğ‘˜]:
ğ‘¡ğ‘’ğ‘šğ‘2[ ğ‘—] â† ğ‘¡ğ‘’ğ‘šğ‘1[ ğ‘—] + ğ‘¡ğ‘’ğ‘šğ‘1[ğ‘˜ + ğ‘—] + Â· Â· Â· + ğ‘¡ğ‘’ğ‘šğ‘1[(ğ‘¡ âˆ’ 1) Â· ğ‘˜ + ğ‘—]
Instead of manipulating the final output in the searching part, we
utilize location information obtained from the intermediate process,
which enables us to retrieve the target item without adding depth.
5 EFFICIENCY ANALYSIS
5.1 Efficiency Estimate
Since multiplication takes much more time than addition, so in our
analysis, we only consider multiplication. Assuming each multipli-
cation operation costs ğ‘‡MUL1.
First, we use RS-OR ğ‘¡ times to calculate the OR results. In Sec-
tion 3.3, we know that each RS-OR is actually equivalent to doing
normal OR operations on log( ğ‘›
ğœ€ ) elements, so each operation costs
log ğ‘›
ğœ€ times multiplication, thus this step costs:
ğ‘¡ Â· log( ğ‘›
ğœ€
) Ã— ğ‘‡MUL1
Then we calculate the inner product of ğ‘£ and ğ‘ â„ğ‘–ğ‘’ğ‘™ğ‘‘, because
ğ‘£ and ğ‘ â„ğ‘–ğ‘’ğ‘™ğ‘‘ have ğ‘› elements, this step involves multiplying each
pair of elements in the two arrays, so it contains ğ‘› multiplication
operations, this step costs:
ğ‘› Ã— ğ‘‡MUL1
Then we apply AGHL_Step algorithm to calculate the stepped
ğœ€ ) times multiplication (AGHL_Step
ğœ€ ) times of multi-
array ğ‘“ ğ‘–ğ‘›, it contains ğ‘˜ Â· log( ğ‘›
needs ğ‘˜ times of RS-OR which requires ğ‘˜ Â· log( ğ‘›
plication), so this step costs:
After obtaining two position information, we use Reconstruction
method to reconstruct the output, it contains ğ‘› times of multiplica-
tion, so this step costs:
ğ‘˜ Â· log( ğ‘›
ğœ€
) Ã— ğ‘‡MUL1
ğ‘› Ã— ğ‘‡MUL1
And we have to add the time match procedure costs, assume it
contains MOPN times of multiplication, so it costs:
MOPN Ã— ğ‘‡MUL1
so, the overall time costs is:
ğ‘‡LEAF =(cid:0)ğ‘¡ Â· log( ğ‘›
) + 2ğ‘› + ğ‘˜ Â· log( ğ‘›
ğœ€
ğœ€
) + MOPN(cid:1) Ã— ğ‘‡MUL1
5.2 Concrete Parameters
To find the optimal parameters, we take the partial differential of
the total time expression ğ‘‡LEAF with respect to ğ‘¡, since MOPN, ğ‘‡
and ğ‘› is not a function of ğ‘¡, ğ‘˜ = ğ‘›
ğ‘¡ , so the target expression is equal
to:
ğ‘¡ Â· log( ğ‘›
ğœ€ ) + ğ‘›
ğœ•ğ‘¡
ğœ•(cid:0)ğ‘¡ Â· log( ğ‘›
ğœ€ )(cid:1)
= 0
we have:
âˆš
ğ‘›
ğ‘¡ =
So we get that the number of multiplications required by the
algorithm, it should be noted that since the matching algorithm
needs to check every element in the database, the MOPN term is
linearly dependent with the amount of data (ğ‘›), that is, MOPN =
ğœ‡ğ‘› = ğ‘‚(ğ‘›), as stated in Section 3.6.1. Define OPN as total number
of multiplications required by the protocol:
) + 2ğ‘› + ğ‘˜ Â· log( ğ‘›
ğœ€
) + 2ğ‘› + âˆš
ğ‘› Â· log(
) + MOPN
âˆš
ğ‘›
ğœ€
OPN = ğ‘¡ Â· log( ğ‘›
ğœ€
âˆš
ğ‘› Â· log( ğ‘›
=
ğœ€
= ğ‘‚(ğ‘›)
) + MOPN
The above formula indicates that the number of multiplications
required by our algorithm has reached the optimal theoretical
bound in the asymptotic sense, because even if we retrieve in plain-
text case, at least ğ‘‚(ğ‘›) operations are still needed.
The depth of this algorithm is:
ğ‘‘LEAF = log ğ‘‘ + log log( ğ‘›
= ğ‘‚(log log ğ‘›)
) + 1 + log log( ğ‘›
ğœ€
) + 1
ğœ€
The first term in the above formula is required by matching step,
the second one is attributed to Localization step, and the third is
due to Extraction step. The last two terms are the depths required
to operate on the extracted interval. To be specific, the fifth term
is corresponding to Reconstruction, while the fourth term is equiv-
alent to replacing the ğ‘› in the first term with ğ‘¡ and removing the
log ğ‘‘, because the depth required by the matching algorithm is not
required when operating on the target interval.
We recall the depth of AGHL algorithm for comparison:
ğ‘‘AGHL = log ğ‘‘ + log log( ğ‘›
) = ğ‘‚(log log ğ‘›)
ğœ€
Itâ€™s shown that the algorithm does not increase the computa-
tional depth in the asymptotic sense, therefore, when ğ‘› is large, the
time required for the single multiplication of the two algorithms
(ğ‘‡MUL2 for AGHL and ğ‘‡MUL1 for LEAF) becomes a constant ratio,
according to the estimation formula in Gentry et al.â€™s work[17]:
ğœ€ ) + 2)ğœ”
= ( ğ‘‘AGHL
ğ‘‘LEAF
)ğœ” = (
log(cid:0)ğ‘‘ log( ğ‘›
ğœ€ )(cid:1)
ğœ€ )(cid:1) + log log( ğ‘›
ğœ€ )(cid:1)
log(cid:0)ğ‘‘ log( ğ‘›
ğœ€ )(cid:1) + log log( ğ‘›
log(cid:0)ğ‘‘ log( ğ‘›
log(cid:0)ğ‘‘ log( ğ‘›
ğ‘‡MUL2
ğ‘‡MUL1
observe that:
ğ‘‡MUL2
ğ‘‡MUL1
lim
ğ‘›â†’+âˆ
ğœ€ ) + 2)ğœ”
ğ‘›â†’+âˆ(
= lim
= ( 1
2)ğœ” = ğ‘‚(1)
where ğœ” < 2.3727 is the matrix multiplication exponent, there-
fore, by combining the multiplication number required by AGHL
algorithm: ğ‘› Â· log( ğ‘›
ğœ€ ), we can get the time required by AGHL algo-
rithm:
ğ‘‡AGHL = ğ‘› Â· log( ğ‘›
) Ã— ğ‘‡MUL2 = ğ‘‚(ğ‘› log ğ‘›) Ã— ğ‘‡MUL2
ğœ€
=
ğ‘‚(ğ‘›)
ğ‘‚(ğ‘› log ğ‘›)
Ã— ğ‘‡MUL2
ğ‘‡MUL1
thus we have:
ğ‘‡AGHL
ğ‘‡LEAF
It turns out that our algorithm LEAF reduced the AGHL algo-
rithm by a log order of magnitude, mainly because we reduced the
number of multiplications from ğ‘‚(ğ‘› log ğ‘›) to ğ‘‚(ğ‘›) while keeping
the required computational depth asymptotically constant.
= ğ‘‚(log ğ‘›) Ã— ğ‘‚(1) = ğ‘‚(log ğ‘›)
6 PROTOCOL WITH BOOTSTRAPPING
LAZILY(LEAF+)
Compared with our algorithm LEAF, LEAF+ applies bootstrapping
only to the elements in the extracted interval, so as to control the
growth of the depth of computation, which leads to different effects:
â€¢ Pros: The bootstrapping step can control the computational
depth required by the algorithm, and the optimization effect
of the algorithm will be better when ğ‘› is large;
â€¢ Cons: The introduction of bootstrapping step will bring
about a large number of extra multiplication operations and
computation depth, which will even make the efficiency of
the algorithm lower than before when ğ‘› is small.
After bootstrapping was introduced, although the computation
depth of the algorithm did not change, the hidden constant in
ğ‘‚(log log ğ‘›) became smaller, so when ğ‘› is very large, the single
multiplication time costs in this algorithm will be the same as in
AGHL, which was different from LEAF algorithm.
At the same time, since we only need to do the bootstrapping
step once for the extracted interval elements rather than for all the
elements, this significantly reduces the extra time cost brought by
the bootstrapping step.
With proper parameter analysis and selection, we could use the
bootstrapping technology to bring benefits and lower down the
consequent disadvantages.
6.1 Efficiency Estimate
Similar to the analysis in the previous section and consider the
extra time bootstrapping takes, we could get the time that LEAF+ al-
gorithm takes:
) + MOPN(cid:1) Â· ğ‘‡MUL3 + ğ‘¡ Â· ğ‘‡BOO
ğ‘‡LEAF+ =(cid:0)ğ‘¡ Â· log( ğ‘›
) + 2ğ‘› + ğ‘˜ Â· log( ğ‘›
ğœ€
ğœ€
where ğ‘‡MUL3 represents the time taken for each homomorphic
multiplication, ğ‘‡BOO is the time required for single bootstrapping,
define:
which means the number of multiplication operations boostrap-
ping procedure needs, we have:
ğ‘¡ , ğ‘‡MUL3 is not a function of ğ‘¡, according to Jung
Hee Cheon et.al.â€™s work [8]: ğ›¼ = ğ‘‚(log2 ğœ†), where ğœ† is security
parameter, independent of ğ‘›, we take the partial with respect to ğ‘¡
to get the optimal solution:
) + MOPN) + ğ›¼ğ‘¡(cid:1) Ã— ğ‘‡MUL3
ğœ€ ) + MOPN) + ğ›¼ğ‘¡(cid:1)
ğœ€ ) + ğ›¼ğ‘¡(cid:1)
= 0
= 0
ğ›¼ =
ğ‘‡BOO
ğ‘‡MUL3
) + 2ğ‘› + ğ‘˜ Â· log( ğ‘›
ğœ€
ğœ€
ğ‘‡LEAF+ =(cid:0)(ğ‘¡ Â· log( ğ‘›
ğœ•(cid:0)(ğ‘¡ Â· log( ğ‘›
where ğ‘˜ = ğ‘›
Since MOPN and ğ‘› are not functions of ğ‘¡, we have:
ğœ€ ) + 2ğ‘› + ğ‘˜ Â· log( ğ‘›
ğœ•ğ‘¡
ğœ•(cid:0)ğ‘¡ Â· log( ğ‘›
ğœ€ ) + ğ‘›
ğ‘¡ Â· log( ğ‘›
ğœ•ğ‘¡
(cid:114) ğ‘›
then we get the solution:
thus we have:
ğ‘‡LEAF+ =(cid:0)(2
âˆš
+ ğ›¼
ğ‘¡ =
1 + ğ›¼
(cid:114) ğ‘›
ğ‘›(cid:1) Ã— ğ‘‡MUL3 = ğ‘‚(ğ‘›) Ã— ğ‘‡MUL3
Â· log( ğ‘›
ğœ€
1 + ğ›¼
) + 2ğ‘› + MOPN)
According to Chen et al.â€™s [6], bootstrapping requires depth
ğ‘‘BOO = log(ğ‘§)+log(â„) for BGV [4] and ğ‘‘BOO = log log(ğ‘§)+log(â„)
for FV [15], where â„ = ||ğ‘ ||1 is the 1-norm of the secret key, and
ğ‘§ = ğ‘ğ‘Ÿ is the plaintext modulus. Thus, the depth of our protocol is :
ğ‘‘LEAF+ = log ğ‘‘ + log log( ğ‘›
ğœ€
) + 1 + ğ‘‘BOO = ğ‘‚(log log ğ‘›) ,
where the 1 term accounts for the depth of retrieval. Similarly,
ğœ€ )(cid:1) + 1
log(cid:0)ğ‘‘ log( ğ‘›
ğ‘‘ğµğ‘‚ğ‘‚ + log(cid:0)ğ‘‘ log( ğ‘›
ğœ€ )(cid:1) + 1)ğœ” ,
ğœ€ )(cid:1) + 1
log(cid:0)ğ‘‘ log( ğ‘›
ğœ€ )(cid:1) + 1)ğœ” = 1
ğ‘‘BOO + log(cid:0)ğ‘‘ log( ğ‘›
ğ‘‡MUL2
ğ‘‡MUL3
= ( ğ‘‘AGHL
ğ‘‘LEAF+
)ğœ” = (
lim
ğ‘›â†’+âˆ
ğ‘‡MUL2
ğ‘‡MUL3
ğ‘›â†’+âˆ(
= lim
where ğœ” < 2.3727 is the matrix multiplication exponent. After
initializing the parameters, ğ‘‘BOO does not change with ğ‘›, therefore:
that is, when ğ‘› gets larger, the time multiplication needed of two