title:Cloaking Malware with the Trusted Platform Module
author:Alan M. Dunn and
Owen S. Hofmann and
Brent Waters and
Emmett Witchel
Cloaking Malware with the Trusted Platform Module
Alan M. Dunn Owen S. Hofmann Brent Waters Emmett Witchel
The University of Texas at Austin
{adunn,osh,bwaters,witchel}@cs.utexas.edu
Abstract
The Trusted Platform Module (TPM)
is commonly
thought of as hardware that can increase platform secu-
rity. However, it can also be used for malicious pur-
poses. The TPM, along with other hardware, can imple-
ment a cloaked computation, whose memory state cannot
be observed by any other software, including the operat-
ing system and hypervisor. We show that malware can
use cloaked computations to hide essential secrets (like
the target of an attack) from a malware analyst.
We describe and implement a protocol that establishes
an encryption key under control of the TPM that can only
be used by a speciﬁc infection program. An infected host
then proves the legitimacy of this key to a remote mal-
ware distribution platform, and receives and executes an
encrypted payload in a way that prevents software visibil-
ity of the decrypted payload. We detail how malware can
beneﬁt from cloaked computations and discuss defenses
against our protocol. Hardening legitimate uses of the
TPM against attack improves the resilience of our mal-
ware, creating a Catch-22 for secure computing technol-
ogy.
1 Introduction
The Trusted Platform Module (TPM) has become a com-
mon hardware feature, with 350 million deployed com-
puters that have TPM hardware [14]. The purpose of TPM
hardware, and the software that supports it, is to increase
the security of computer systems. However, this paper ex-
amines the question of how a malware author can use the
TPM to build better malware, speciﬁcally malware that
cannot be analyzed by white hat researchers.
Trusted computing technology [42] adds computer
hardware to provide security primitives independent from
other system functionality. The hardware provides cer-
tain low-level security guarantees directly. For example,
it guarantees that only it can read and write certain data.
Trusted software uses these low-level, hardware-enforced
properties to build powerful guarantees for programmers.
The TPM, as developed by the Trusted Computing
Group (TCG), is one of the more popular implementations
of trusted computing technology. The TPM has seen sig-
niﬁcant use in industry and government; the TPM is used
in Microsoft’s popular BitLocker drive encryption soft-
ware [7] and the United States Department of Defense has
required the TPM as a solution for securing data on lap-
tops [4]. TPMs are regularly included on desktop, laptop,
and server-class computers from a number of manufac-
turers. The wide dissemination of TPM functionality is
potentially a boon for computer security, but this paper
examines the potential of the TPM for malware authors (a
ﬁrst to our knowledge).
A malware writer can use the TPM for implementing
cloaked computations which, combined with a protocol
described in this paper, impede malware analysis. The
TPM is used with “late launch” processor mechanisms
(Intel’s Trusted Execution Technology [12, 8], abbrevi-
ated TXT, and AMD’s Secure Startup mechanism [10])
that ensure uninterrupted execution of secure binaries.
Late launch is a hardware-enforced secure environment
where code runs without any other concurrently executing
software, including the operating system. We demonstrate
a protocol where a malware author uses cloaked com-
putations to completely prevent certain malware func-
tions from being analyzed and understood by any cur-
rently available methods. TPM functionality ensures that
a cloaked program will remain encrypted until it is run-
ning directly on hardware. Assuming certiﬁcates for hard-
ware TPMs identify these TPMs as hardware and cannot
be forged, our malware will refuse to execute in a virtual-
ized environment.
Timely and accurate analysis is critical to the ability
to stop widespread effects of malware. Honeypots are
constantly collecting malware and researchers use cre-
ative combinations of static analysis, dynamic emulation
and virtualization to reverse engineer malware behavior
[47, 30, 19, 24, 35, 36]. This reverse engineering is often
crucial to defeating the malware. For example, once the
domain name generation algorithm used for propagating
the Conﬁcker worm was determined, the Conﬁcker ca-
bal blocked the registration of those DNS names [45, 43],
thereby defeating the worm.
While the idea of using the TPM to cloak malware com-
putation is conceptually straightforward, existing TPM
protocols do not sufﬁce and must be adapted to the task
1
of malware distribution. We clarify the capabilities of
and countermeasures for this threat. Cloaking does not
make malware all-powerful, and engineering malware to
take advantage of a cloaked environment is a design chal-
lenge. A cloaked computation runs without OS support,
so it cannot make a system call or easily use devices like
a NIC for network communication. This paper also dis-
cusses best practices for TPM-enabled systems that can
prevent the class of attacks we present.
This paper makes the following contributions.
• It speciﬁes a protocol that runs on current TPM im-
plementations that allows a malware developer to ex-
ecute code in an environment that is guaranteed to be
not externally observable, e.g., by a malware analyst.
Our protocol adapts TPM-based remote attestation
for use by the malware distribution platform.
• It presents the model of cloaked execution and mea-
sures the implementation of a malware distribution
protocol that uses the TPM to cloak its computation.
• It provides several real-world use cases for TPM-
based malware cloaking, and describes how to adapt
malware to use TPM cloaking for those cases. These
include: worm command and control, selective data
exﬁltration, and a DDoS timebomb.
• It discusses various defenses against our attacks and
their tradeoffs with TPM security and usability.
Organization In Section 2 we describe our threat model
and different attack scenarios for TPM cloaked malware.
Then in Section 3 we give TPM background information.
We then describe and analyze a general TPM cloaked mal-
ware attack in Section 4 and follow with a description of
a prototype implementation in Section 5.
We then turn to discussing future defenses against such
attacks in Section 6; describe related work in Section 7
and ﬁnally conclude in Section 8.
2 Threat Model and Attack Scenarios
We begin by describing our threat model for an attacker
that wishes to use the TPM for cloaked computations.
Then we describe multiple attack scenarios that can lever-
age TPM cloaked computations.
2.1 Threat model and goals
We consider an attacker who wishes to infect machines
with malware. His goal is to make a portion of this mal-
ware unobservable to any analyst (e.g., white-hat security
researcher, or IT professional) except for its input and out-
put behavior.
We assume an attacker will have the following capabil-
ities on the compromised machine.
• Kernel-level compromise. We assume our attack
has full access to the OS address space. Late launch
computation is privileged and can only be started by
code that runs at the OS privilege level. Exploits
that result in kernel-level privileges for commodity
OSes are common enough to be a signiﬁcant con-
cern. For example, in September and October 2010,
there were 13 remote code execution vulnerabilities
and 2 privilege escalation vulnerabilities that could
provide a kernel-level exploit for Microsoft’s Win-
dows 7 [13]. Kernel-level exploits for Linux are re-
ported more rarely, but do exist, e.g., the recent Xorg
memory management vulnerability [54]. There are
many examples of malware using kernel vulnerabil-
ities [34, 3].
• Authorization for TPM capabilities. We further as-
sume our attack can authorize the TPM commands
in our protocol. TPM commands are authorized us-
ing AuthData, which are 160-bit secrets that will
be described further in Section 3. The difﬁculty
of obtaining AuthData depends on how TPMs are
used in practice. To our knowledge, the TCG does
not provide concrete practices for protecting Auth-
Data. Most TPM commands do not require Auth-
Data to be sent on wire, even in encrypted form.
However, knowing AuthData is necessary for certain
common TPM operations like using TPM-controlled
encryption keys. We discuss acquiring the AuthData
needed by the attack in Sections 3.6 and 4.
An analyst will see all non-blackbox behavior of the
attacker’s cloaked computation. In our model, the analyst
is allowed full access to systems that run our malware.
We assume that all network trafﬁc is visible, and that the
analyst will attempt to exploit any attack protocol weak-
nesses. In particular, an analyst might run a honeypot that
is intended to be infected so that he can observe and ana-
lyze the malware. A honeypot may use a virtual machine
(including those that use hardware support for virtualiza-
tion like VMWare Workstation and KVM [33]), and may
include any combination of emulated and real hardware,
including software-based TPM emulators [50] and VM
interfaces to hardware TPMs like that of vTPMs [17].
We assume the analyst is neither able to mount phys-
ical attacks on the TPM nor is able to compromise the
TPM public key infrastructure.
(We revisit these as-
sumptions when discussing possible defenses in Sec-
tion 6.) While there are known attacks against Intel’s
late launch environment [55] and physical attacks against
the TPM [51, 32], manufacturers are working to eliminate
such attacks. Manufacturers have signiﬁcant incentive to
defeat these attacks because they compromise the TPM’s
guarantee that is currently its most commercially impor-
tant: preventing data leakage from laptop theft.
Our attack may be detectable because it increases TPM
use. Nonetheless, frequent TPM use might be the norm
for some systems, or users and monitoring tools may sim-
ply be unaware that increased TPM use is a concern.
A cloaked computation is limited to a computational
kernel. It cannot access OS services or make a system
2
call. Any functional malware must have extensive sup-
port code beyond the cloaked computation. The support
code performs tasks like communication over the network
or access to ﬁles. The attacker must design malware to
split functionality into cloaked and observable pieces. Ar-
guments can be passed to the computational kernel via
memory, and may be encrypted or signed off-platform for
privacy or integrity.
2.2 Attack Scenarios
We now describe various attack scenarios that leverage
TPM cloaking.
2.2.1 Worm command and control
We consider a modiﬁcation of the Conﬁcker B worm. The
worm has an infection stage, where a host is exploited and
downloads command and control code. Then the infection
code runs a rendezvous protocol to download and execute
signed binary updates. Engineers halted the propagation
of Conﬁcker B by reverse engineering the rendezvous pro-
tocol and preventing the registration of domain names that
Conﬁcker was going to generate.
Defeating Conﬁcker requires learning in advance the
rendezvous domain names it will generate. The sequence
of domain names can be determined in two ways; ﬁrst
by directly analyzing the domain name generation imple-
mentation or second by running the algorithm with inputs
that will generate future domain names. Cloaked compu-
tation prevents the static analysis and dynamic emulation
required to reverse engineer binary code, eliminating the
ﬁrst option of analyzing the implementation.
Conﬁcker uses as input to its domain name generation
algorithm the current day (in UTC). It establishes the cur-
rent day by fetching data from a variety of web sites.
White hat researchers ran Conﬁcker with fake replies to
these http requests, tricking the virus into believing it was
executing in the future.
However, malware can obtain timestamps securely at
day-level granularity. Package repositories for common
Linux distributions provide descriptions of repository
contents that are signed, include the date, and are updated
(See http://us.archive.ubuntu.com/
daily.
for
ubuntu/dists/lucid-updates/Release
Ubuntu Linux, which has an accompanying “.gpg”
signature ﬁle.) This data is mirrored at many locations
worldwide and is critical for the integrity of package
distribution1, so taking it ofﬂine or forging timestamps
would be both difﬁcult and a security risk.
Conﬁcker is not alone in its use of domain name gener-
ation for rendezvous points. The Mebroot rootkit [31] and
Kraken botnet [5] both use similar techniques to contact
their command and control servers.
1Although individual packages are signed, without signed release
metadata a user may not know whether there is a pending update for
a package.
3
Using cloaked computations for malware command
and control does not ipso facto make malware more dan-
gerous. Cloaked computations must be used as part of a
careful protocol in order to be effective.
2.2.2 Selective data exﬁltration
An infection program can exﬁltrate private ﬁnancial data
or corporate secrets. To minimize the probability of detec-
tion, the program rate limits its exﬁltrated data. The pro-
gram searches and prioritizes data inside a cloaked com-
putation, perhaps using a set of regular expressions.
Cloaked computation can obscure valuable clues about
the origin and motivation of the infection authors. The
regular expressions might target information about a par-
ticular competitor or project. If white hats can sample the
exﬁltrated data, this would also provide clues; however, it
would give less direct evidence than a set of search terms,
and output could be encrypted.
Stuxnet and Aurora are recent high proﬁle attacks that
exﬁltrate data [38]. Stuxnet seeks out speciﬁc industrial
systems and sends information about the infected OS and