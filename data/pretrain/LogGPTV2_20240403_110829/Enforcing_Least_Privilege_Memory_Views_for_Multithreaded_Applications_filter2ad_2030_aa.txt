title:Enforcing Least Privilege Memory Views for Multithreaded Applications
author:Terry Ching-Hsiang Hsu and
Kevin J. Hoffman and
Patrick Eugster and
Mathias Payer
Enforcing Least Privilege Memory Views for
Multithreaded Applications
Terry Ching-Hsiang Hsu
Purdue University
PI:EMAIL
Kevin Hoffman
eFolder Inc.
PI:EMAIL
Patrick Eugster
Purdue University and TU
Darmstadt
PI:EMAIL
Mathias Payer
Purdue University
PI:EMAIL
Abstract
Failing to properly isolate components in the same address
space has resulted in a substantial amount of vulnerabilities.
Enforcing the least privilege principle for memory accesses
can selectively isolate software components to restrict at-
tack surface and prevent unintended cross-component mem-
ory corruption. However, the boundaries and interactions
between software components are hard to reason about and
existing approaches have failed to stop attackers from ex-
ploiting vulnerabilities caused by poor isolation.
We present the secure memory views (SMV) model: a
practical and eﬃcient model for secure and selective mem-
ory isolation in monolithic multithreaded applications. SMV
is a third generation privilege separation technique that of-
fers explicit access control of memory and allows concurrent
threads within the same process to partially share or fully
isolate their memory space in a controlled and parallel man-
ner following application requirements. An evaluation of our
prototype in the Linux kernel (TCB 100 ∆ LOC)
Library assisted(<20 ∆ LOC)
FUSE (8K LOC) etc.
Firefox (13M LOC) etc.
Salus [40]
Single thread
Not handled
Not handled
Dynamic
Library, OS
Tool assisted
PolarSSL
Table 1: Issues and solutions for intra-process privilege separation techniques.
- Ease of use (EU): Programmers prefer to realize their de-
sired security policy in a model with a high-level API
rather than through low-level error-prone memory man-
agement tools without intra-process capabilities (e.g., mmap,
shmem.). In particular, porting legacy software to a new
model has to be easy despite the complexity of component
interweaving and the underlying assumption of shared
memory (e.g., Firefox, which contains 13M LOC), and
should be possible with minimal code refactoring eﬀorts.
- No hardware modiﬁcations (NH): Over-privileged multi-
threaded applications are pervasive. A model that is
ready to run on today’s commodity hardware (even re-
gardless of the CPU brands/models) is necessary for wide
deployment.
- Low runtime overhead (LO): Monitoring application mem-
ory accesses at high frequency is unrealistic for practical
systems. A practical model must be implemented in a way
that incurs only negligible runtime overheads. In particu-
lar, enhanced security should not sacriﬁce the parallelism
in multithreaded applications. A model has to support se-
lective memory isolation for multiple computing entities
(i.e., multiple threads can exercise the same privilege to
parallelize a given workload and perform highly parallel
memory operations).
To address the above challenges, we propose a third gen-
eration privilege separation solution for monolithic applica-
tions: secure memory views (SMVs) – a model and archi-
tecture that eﬃciently enforces diﬀerential security and fault
isolation policies in monolithic multithreaded applications at
negligible overheads. SMV protects applications from neg-
ligent or malicious memory accesses between software com-
ponents. In short, the intrinsically shared process address
space is divided into a dynamic set of memory protection
domains. A thread container SMV maintains a collection
of memory protection domains that deﬁne the memory view
for its associated threads. Access privileges to the memory
protection domains are explicitly deﬁned in the SMVs and
the associated SMVthreads must strictly follow the deﬁned
security policies. The SMV model provides a well-deﬁned
interface for programmers to exercise the least privilege prin-
ciple for arbitrary software objects “inside” a multithreaded
process. For example, a server’s worker thread can be con-
ﬁgured to allow access to its thread stack and part of the
global server conﬁguration but not to the private key that
resides within the same process address space.
With the SMV model, the programmer can enforce dif-
ferent access permissions for diﬀerent components in a sin-
gle address space (GF). New software can leverage the full
API and can be designed to only share data along a well-
deﬁned API, and existing software can be retroﬁtted (with
minimal code changes) by instrumenting calls across com-
ponent boundaries to change the underlying memory view
(EU). Moreover, the privilege enforcement relies on OS ker-
nel level page table manipulation and standard hardware
virtual memory protection mechanisms (NH). Therefore, the
SMV model does not suﬀer from the performance overheads
(LO) imposed by IPC (vs in-memory communication), user
level memory management (vs kernel level), or per-instruction
reference monitors (vs hardware trap). The SMV model’s
programmability and eﬃcient privilege enforcement mecha-
nism allow it to protect both client- and server-side multi-
threaded applications with low overhead.
We implemented a prototype of the SMV model in the
Linux kernel. Our evaluation demonstrates (a) its negligi-
ble runtime overhead in the presence of high concurrency
using multithreaded benchmarks that employ the general
producer-consumer pattern, and (b) the immediate beneﬁt
of eﬃcient software component isolation by compartmen-
talizing client connections for the popular Cherokee and
Apache httpd web servers and the compartments in the Fire-
fox web browser. SMVs incur only around 2% runtime
overhead overall with 2 LOC changes for the multithreaded
benchmark PARSEC, 0.69% throughput overhead with 2
LOC changes for Cherokee, 0.93% throughput overhead with
2 LOC changes for Apache httpd, and 1.89% runtime over-
head with only 12 LOC changes for the Firefox web browser.
Note that SMV focuses on restricting memory views for in-
dividual threads, access permissions for kernel APIs is an
orthogonal problem that is well covered by, e.g., AppAr-
mor [4], SELinux [39], or the seccomp framework [38].
In summary, this paper makes the following contribu-
tions:
Design of the SMV model which provides threads with ﬁne-
grained control over privileges for a shared address space.
Speciﬁcation of an SMV API for programmers that facili-
tates porting existing pthread applications.
Implementation of the SMV model that consists of a trusted
Linux kernel component (implementing enforcement) and
the corresponding untrusted user-space library that im-
plement the SMV API, which is publicly available along
with our benchmarks and test suite1.
Evaluation of our prototype implementation showing that
SMVs achieve all four desired requirements as a practical
and eﬃcient model for enforcing least privilege memory
views for multithreaded applications in practice.
1https://github.com/terry-hsu/smv
2. THREAT MODEL AND OBJECTIVES
Threat model. We assume that the attacker, an unpriv-
ileged user without root permissions, can control a thread
in a vulnerable multithreaded program, allocate memory,
and fork more threads up to resource limits on a trusted
kernel with sound hardware. The adversary will try to es-
calate privileges through the attacker-controlled threads or
gain control of another thread, e.g., by reading or writing
data of another module or executing code of another mod-
ule.
In this model, the adversary may read or write any
data that the controlled thread has access to. The adver-
sary may also attempt to bypass protection domains by ex-
ploiting race conditions between threads or by leveraging
confused deputy attacks, e.g., through the API exported by
other threads. We assume that the OS kernel is not com-
promised (OS kernel security is an orthogonal topic [24])
and user-space libraries installed by root users are trusted.
We assume that the access permissions both of the memory
views (enforced through SMV) and for the kernel (enforced
through AppArmor, SELinux, or seccomp) are set correctly.
Objectives. The key objective of the SMV model is to
eﬃciently protect memory references of threads to prevent
unintentional or malicious accesses to privileged memory ar-
eas during the lifetime of a program. Threads may commu-
nicate with other threads through mutually shared memory
areas set up by the programmer through SMVs. The SMV
model restricts the memory boundaries and memory access
permissions for each thread. Without SMVs, an untrusted
thread (e.g., a compromised worker thread) may access ar-
bitrary software objects (e.g., the private key) within its