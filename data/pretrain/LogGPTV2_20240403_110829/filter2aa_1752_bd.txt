时间
mktime()  tzset() 将时设 tm 的。时 -1（
 time t。
ctime() 将 time t  ASCII 示
#include 
char * ctime (const time_t *timep);
char * ctime_r (const time_t *timep, char *buf);
时 NULL。
time_t t = time (NULL);
printf (”the time a mere line ago: %s”, ctime
(&t));
的新出。能方 ctime() 
空。
 asctime()  ctime() 的。程
的程的程程 ctime r()  buf 
的上工作。 26 。
gmtime() 将给出的 time t  tm  UTC 时式示
#include 
struct tm * gmtime (const time_t *timep);
struct tm * gmtime_r (const time_t *timep, struct
tm *0result);
时 NULL。
的的
程的。程的程程 gmtime r() result 的
上操作。
localtime()  localtime r()  gmtime()  gmtime r()们
将给出的 time t 示时:
– 342 –
 10 
时间
#include 
struct tm * localtime (const time_t *timep);
struct tm * localtime_r (const time_t *timep,
struct tm *result);
 mktime()  localtime() 的调调 tzset()时。 lo-
caltime r() 步的。
difftime()  time t 的示相
的。
include 
double difftime (time_t time1, time_t time0);
 POSIX 上 time t  difftime() 以
进出的
(double) (time1 - time0)
 Linux 上 time t 将。然
性 difftime()。
10.7 调校系统时钟
墙上时间的然对操作绝对时间的
。 make(make  Makefile 的内件的程) 的
子。程处理对件
文件的小能小时进新。 make 对
文件（ wolf.c文件（wolf.o的时间。文件或
的何文件 wolf.h文件新 make 将文件
更新的文件。然文件文件新处理。
的时时间
小时 date 更新时间。更
新存 wolf.c我们能。时间调
wolf.c 能 wolf.o  (即), 进。
– 343 –
 10 
时间
的 Unix 提 adjtime() 以以的
的调时间。时间进程（NTP
的程以的调时间的 adjtime() 小们对的
#define _BSD_SOURCE
#include 
int adjtime (const struct timeval *delta,
struct timeval *olddelta);
调 djtime()示内 delta 调时间然
0。 delta 的时间内将时。
delta 时间内将时。内进的
时单调然的。即 delta 调然
时调时时间的时间。
 delta  NULL内处理的。对
的内将。 olddelta  NULL的
将写 timeval 。 delta 设 NULL将 olddelta 设
将以进的。
adjtime() 进的理的子提的 NTP, 
。 Linux 以的小。
时 adjtime()  -1设 errno 
EFAULT delta 或 olddelta 。
EINVAL delta 的调或小。
EPERM
调的 CAP SYS TIME 。
RFC 1305  adjtime() 的进调方更更
的时调。 Linux  adjtimex() 调实。
#include 
int adjtimex (struct timex *adj);
– 344 –
 10 
时间
调 adjtimex() 以将内时间相的读 adj 的 timex 
。调以性的的 modes 段设
。
文件   timex 
struct timex {
int modes; /* mode selector */
long offset; /* time offset (usec) */
long freq; /* frequency offset (scaled ppm) */
long maxerror; /* maximum error (usec) */
long esterror; /* estimated error (usec) */
int status; /* clock status */
constant; /* PLL time constant */
long precision; /* clock precision (usec) */
long tolerance; /* clock frequency tolerance
(ppm) */
struct timeval time; /* current time */
long tick; /* usecs between clock ticks */
};
modes 段零或以或的
ADJ OFFSET
 offset 设时间。
ADJ FREQUENCY
 freq 设率。
ADJ MAXERROR
 maxerror 设。
ADJ ESTERROR
 esterror 设。
ADJ STATUS
 status 设时。
ADJ TIMECONST
 constant 设相（PLL时间。
ADJ TICK
 tick 设时时。
ADJ OFFSET SINGLESHOT 单 ( adjtime)  offset 设时
间。
 modes  0设。 CAP SYS TIME 的能
给 modes 零何将设 mode  0
能设何。
– 345 –
 10 
时间
时 adjtimex() 时
TIME OK
时同步。
TIME INS
将。
TIME DEL 将。
TIME OOP 的进。
TIME OOP 出。
item [TIME BAD] 时同步。
时 adjtimex()  -1设 errno 
EFAULT adj 。
EINVAL 或更的 modes offset 或 tick 。
EPERM
modes 零调 CAP SYS TIME 。
adjtimex() 调 Linux 的。性的
adjtime()。
RFC 1305 的对 adjtimex() 的超出的
。更 RFC。
10.8 睡眠和等待
的能进程（的段时间。
的 sleep()进程 seconds 的。
#include 
unsigned int sleep (unsigned int seconds);
调的。的调 0能
 0  seconds 间的（。
设 errno。 sleep() 的进程实上
。
sleep (7); /* sleep seven seconds */
– 346 –
 10 
时间
真的进程时间的以调
sleep() 0。
unsigned int s = 5;
/* sleep five seconds: no ifs, ands, or buts
about it */
while ((s = sleep (s)))
;
10.8.1 微秒级精度睡眠
以的进实。操作上
以程的。 usleep()
/* BSD version */
#include 
void usleep (unsigned long usec);
/* SUSv2 version */
#define _XOPEN_SOURCE 500
#include 
int usleep (useconds_t usec);
10.8.2 Linux 的实时支持
调 usleep() 以进程 usec 。的 BSD  Single
UNIX Specification（单 UNIX 原上同。 BSD
。然 SUS  usleep() 
 useconds t 。 XOPEN SOURCE  500 或
更的 Linux  SUS 。 XOPEN SOURCE 或设小
– 347 –
 10 
时间
 500 Linux  BSD 。
SUS 时 0出时 -1。的 errno : 
时 EINTR usecs 的 EINVAL（ Linux 上
的的出。
 useconds t 能满 1,000,000 的。
同原间的以及 Unix 能
的 useconds t 的。能满性
设 usleep() 的
void usleep (unsigned int usec);
unsigned int usecs = 200;
usleep (usecs);
以满的同式以
errno = 0;
usleep (1000);
if (errno)
perror (”usleep”);
对程们 usleep() 的。
10.8.3 纳秒级精度睡眠
Linux  usleep() 提更能以提
的 nanosleep()
#define _POSIX_C_SOURCE 199309
#include 
int nanosleep (const struct timespec *req,
struct timespec *rem);
– 348 –
 10 
时间
调 nanosleep(), 进程 req 的时间 0。时调
 -1设 errno 相。调
时间。 nanosleep()  -1设 errno 
EINTR。 rem  NULL时间（req 的
rem 。程新调将 rem 作给 req（示。
能的 errno 
EFAULT req 或 rem 。
EINVAL req 段。
单
struct timespec req = { .tv_sec = 0,
.tv_nsec = 200 };
/* sleep for 200 ns */
ret = nanosleep (&req, NULL);
if (ret)
perror (”nanosleep”);
时的子
struct timespec req = { .tv_sec = 0,
.tv_nsec = 1369 };
struct timespec rem;
int ret;
/* sleep for 1369 ns */
retry:
ret = nanosleep (&req, &rem);
if (ret) {
if (errno == EINTR) {
/* retry, with the provided time
remaining */
req.tv_sec = rem.tv_sec;
– 349 –
 10 
时间
req.tv_nsec = rem.tv_nsec;
goto retry;
}
perror (”nanosleep”);
}
方（能更效读性以
同效
struct timespec req = { .tv_sec = 1,
.tv_nsec = 0 };
struct timespec rem, *a = &req, *b = &rem;
/* sleep for 1s */
while (nanosleep (a, b) && errno == EINTR) {
struct timespec *tmp = a;
a = b;
b = tmp;
}
nanosleep() 相对 sleep()  usleep() 
• 提能提或。
• POSIX.1b 。
• 实（方的将。
    对    程   然      usleep()   
nanosleep()的程 sleep()。 nanosleep()  POSIX
新程（或将的
 sleep() 或 usleep()。
10.8.4 实现睡眠的高级方法
我们的时间。 POSIX 提
的
#include 
– 350 –
 10 
时间
int clock_nanosleep (clockid_t clock_id,
int flags,
const struct timespec *req,
struct timespec *rem);
clock nanosleep() 的 nanosleep()。实上调
ret = nanosleep (&req, &rem);
调
ret = clock_nanosleep (CLOCK_REALTIME, 0, &req,
&rem);
的 clock id  flags 。的时间。然
能调进程的 CPU 时（ CLOCK PROCESS CPUTIME ID
时间的何调将进程
进程时间将。
时间的程进的的。绝
对时间 CLOCK REALTIME 的。备相对
的时间 CLOCK MONITONIC 绝对理的时间。
flags  TIMER ABSTIME 或 0。 TIMER ABSTIME req 
的绝对的时间。处理的件。
的以设进程处时间 T0时间 T1。 T0 时进
程调 clock gettime() 时间（T0。然 T1  T0
Y给 clock nanosleep()。时间进程进间
时间的。然的间进程调处理或
页对我们何处理时间时间
以及实间存件的。
TIMER ABSTIME 进程 T1, 。时间
 T1 内进程。时间的时间超
T1调即。
我相对绝对。的子进程 1.5 
– 351 –
 10 
时间
struct timespec ts = { .tv_sec = 1, .tv_nsec =
500000000 };
int ret;
ret = clock_nanosleep (CLOCK_MONOTONIC, 0, &ts,
NULL);
if (ret)
perror (”clock_nanosleep”);
相的的子绝对时间 clock gettime() 调
 CLOCK MONOTONIC 时间的。
struct timespec ts;
int ret;
/* we want to sleep until one second from NOW */
ret = clock_gettime (CLOCK_MONOTONIC, &ts);
if (ret) {
perror (”clock_gettime”);
return;
}
ts.tv_sec += 1;
printf (”We want to sleep until sec=%ld
nsec=%ld\n”,
ts.tv_sec, ts.tv_nsec);
ret = clock_nanosleep (CLOCK_MONOTONIC,
TIMER_ABSTIME,
&ts, NULL);
if (ret)
perror (”clock_nanosleep”);
程相对的们的。然
实时进程对时间相绝对的
– 352 –
 10 
时间
性的件。
10.8.5 sleep 的一种可移植实现
我们提 select()
#include 
int select (int n,
fd_set *readfds,
fd_set *writefds,
fd_set *exceptfds,
struct timeval *timeout);
时提的 select() 提实、的
方。段时间内的 Unix 程 sleep() 满的
的 usleep() 上实的 nanosleep()
写。给 select() 的 n  0给 fd set 
NULL以及的时间给 timeout效的方
进程
struct timeval tv = { .tv_sec = 0,
.tv_usec = 757 };
/* sleep for 757 us */
select (0, NULL, NULL, NULL, &tv);
对的 Unix 的性 select() 能
的。
10.8.6 超限
的进程的时间（或
示。进程的时间绝。存
能时间超时间。
以单的调的时间能内
– 353 –
 10 
时间
能及时进程调能。
然以更的原时超 (timer overruns)。时
的的时间间时。设时
 10 时进程 1 的。能 10 
的时间相的件（进程。进程
时时离时 1 将
1 内的时间（1 将内将进程。然
时进程时时的 10 将时
。进程将 9  1 的超。
 X 单的时 X/2 的率超。
 POSIX 时提的时间或的 HZ 以
时超。
10.8.7 替代睡眠
能的。
的的时间的时。
件的的设。文件上内处理
进程的的。内能进程
时进程件的。
10.9 定时器
时提时间进程的。时超时的时间
（delay或超时（expiration。内进程时
的方式时。 Linux 内提时我们将。
时新 60 或
的程 500 。
10.9.1 简单的闹钟
alarm() 单的时
#include 
– 354 –
 10 
时间
unsigned int alarm (unsigned int seconds);
对的调真实时间 (real time)seconds 将 SIGALRM 
给调进程。的处理调新的
的。 seconds  0的设
新的。
调 SIGALRM 处理程。（
处理程的内。的段
SIGALRM 处理程 alarm handler()设的
void alarm_handler (int signum)
{
printf (”Five seconds passed!\n”);
}
void func (void)
{