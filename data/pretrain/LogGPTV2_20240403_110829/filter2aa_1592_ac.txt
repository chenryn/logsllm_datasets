 sn.exe -k AlexandreBorges.snk
 sn.exe -p AlexandreBorges.snk AlexandreBorges.PublicKey sha256
 sn.exe -tp AlexandreBorges.PublicKey
 csc.exe /out:malware.dll /t:exe /keyfile:AlexandreBorges.PublicKey /delaysign 
Program.cs
 sn.exe -Vr malware.dll (CLR trust in the assembly without using the hash).
 It is not so hard to perform a supply-chain attack because, when a files is specified 
as reference in the csc.exe compiler using /reference switch, it looks at: 
 the working directory
 csc.exe directory
 directory specified by the /lib switch
 directory specified by the LIB environment variable. 
ALEXANDRE BORGES – MALWARE AND SECURITY RESEARCHER
DEF CON USA 2019
44
 Several malware samples have been modified or written directly in ILAsm to 
bypass common tools. 
 While ILAsm is not complicated, maybe it is still recommended to remember few 
directives and instructions. 
 .assembly DefCon { }: identifies the current assembly as being DefCon. 
 .assembly extern : determines the external managed assembly 
used by the program.  For example, .assembly extern  
 .module malware.dll: identifies the current module. 
 .namespace Conference: identities the namespace, but it does not represent a 
metadata. 
 .class public auto ansi Hacker entends [mscorlib]System.Object. Its keywords; 
 .class: identifies the current class (Hacker)
 public: specifies the visibility. For example, it could be “private”.
 auto: determines the class layout style. It could be “explicit” and 
“sequencial”. 
 ansi: string encode while communicating to unmaged code. Other values are 
autochar and unicode. 
 extends: determines its base class
ALEXANDRE BORGES – MALWARE AND SECURITY RESEARCHER
DEF CON USA 2019
45
 Other flags for .class directive are:
 private: used with private classes, which are not visible outside the current 
assembly. 
 sealed: the current class can’t be derived from this class. 
 abstract: the current class can’t be instantiated (it holds abstract methods). 
 explicit: the loader preserve the order of fields in the memory. 
 sequential: the loader preserves the order of the instance fields as specified 
in the class. 
 nested family: the class is visible from the descendants of the current class 
only. 
 nested assembly: the class is visible only from the current assembly.
 nested famandassem: the class is visible from the descendants of the current 
class, but residing in the same assembly only.
 windowsruntime: the class is a Windows runtime type. 
 .class public enum Exam: declares a class enumeration named “Exam”.
 .ctor( ): instance constructor, which is related to instance fields. 
 .cctor( ): class constructor (known as type initializer), which is related to static 
fields. 
ALEXANDRE BORGES – MALWARE AND SECURITY RESEARCHER
DEF CON USA 2019
46
 During malware analysis, take care: there can be a global .cctor directive, which it 
is related to global fields. 
 call: call a method. Its possible keywords: 
 return type: void, int32, and so on.
 vararg: variable number of arguments
 calli: directive used to call methods indirectly by taking arguments + function 
pointer. 
 ldc.i4.0
 ldc.i4.1
 ldc.i4.2
 ldftn void DefCon::Test(int32, int32, int32)
 calli void(int32, int32, int32)
 (method reference): 
 call instance void DefCon::Exam(int32, int32, int32)
 call instance [.module malware.dll]::Hooking(int32, int32, native int)
ALEXANDRE BORGES – MALWARE AND SECURITY RESEARCHER
DEF CON USA 2019
47
 .field: specifies a variable of any type declared directly in the class (or struct). Its 
main keywords can be: 
 public / assembly / family (accessed by any decending class) / private
 static (shared by all instances of the referred class). 
 .method: specifies the method declaration. Its main keywords (flags) can be: 
 public / static: similar meaning as especified in “field” explanation above. 
 cil managed: it means this method is represented in managed code.
 newslot: creates a new slot in the virtual table of the class to prevent that a 
existing method (same name and signature) to be overriden in a derived class. 
 native unmanaged: it means this method is represented in a native code.
 abstract: of course, no implementation is provided. 
 final: as known, the method can’t be overridden. 
 virtual: method can be “redefined” in derived classes.
 strict: this method can only be overridden whether it is accessible from the 
class that is overriding it. Of course, the method must be virtual. 
 noinline: it is not allowed to replace calls to this method by an inline version.
 pinvokeimpl: declares an unmanaged method from a managed code (it’s is 
also known as P/Invoke mechanism).
ALEXANDRE BORGES – MALWARE AND SECURITY RESEARCHER
DEF CON USA 2019
48
 .method public hidebysig static pinvokeimpl("user32.dll" winapi) int32 
FindWindow(string,string) cil managed preservesig
 preservesig: return of method must be preserved. 
 FindWindows(string,string): function invoked from the “user32.dll” and that 
returns a int32 value. 
 .class public DefCon implements InterfaceA,InterfaceB {
.method void virtual int32 IfB_Speaker(string) {
.override InterfaceB::Speaker
... 
}
 .class public DefConChina extends DefCon {
.method public specialname void .ctor( ) {
ldarg.0
call instance void DefCon::.ctor( )
ret }
callvirt instance void DefCon::IfB_Speaker( )
ALEXANDRE BORGES – MALWARE AND SECURITY RESEARCHER
DEF CON USA 2019
49
 .entrypoint: identifies the method as the entry point of the assembly. 
 .maxstack: defines the maximum stack depth used by the function code
 .locals int: defines the local variable of the current method and the “init” keyword 
is initializing the variable with “zero” (for example, a integer variable).
 .data : defines a data segment named “var_1”. 
 stloc : retrieves the value returned by the call and stores into the “var” 
variable. 
 ldarg.0: Load argument 0 onto the stack.
 ldloc : copies the value of “var” onto the stack. Variants, after optmization 
and run, such as ldloc.0, ldloc.1, ldloc2 and ldloc3 (representing the first local 
variables) are possible. 
 ldstr: loads the reference to a string onto stack. 
 ldsflda: loads the reference of a static field onto the stack.
 ldsfld: loads the value of a static field onto the stack. 
 ldc.i4 8: loads the constant value 8 onto the stack. 
ALEXANDRE BORGES – MALWARE AND SECURITY RESEARCHER
DEF CON USA 2019
50
 br Borges: its unconditional jump similar to “jmp” in native assembly. In this case, 
jumping to “Borges” label.
 brtrue DefCon: takes an item from stack and, if it is zero, so jump to “Alex” branch.
 brfalse Alex:  takes an item from stack and, if it is one, so jump to “Alex” branch. 
 .this: it is a reference to the current class (not instance of the class like C++).
 .base: it is a reference to the parent of the current class. 
 .typedef: creates a alias to a type. 
 .try / catch: the same meaning of traditional C language. 
ALEXANDRE BORGES – MALWARE AND SECURITY RESEARCHER
DEF CON USA 2019
51
auto: loader defines the 
“best lay out” in the 
memory”
nested and sealed class!
specialname flag helps 
the loader to 
understand this is a 
special function 
(constructor)
Remember that a field is a variable of any type that is 
declared directly in a class or struct.
ALEXANDRE BORGES – MALWARE AND SECURITY RESEARCHER
DEF CON USA 2019
52
instance 
constructor
load argument 0 onto the stack.
reserving 8 slots for arguments.
push 0 onto stack as int32.
loads a string reference onto stack.
replaces the value of a field with a value from stack.
Using a custom attribute statement to set 
the value of CompilerGeneratedAttribute .
ALEXANDRE BORGES – MALWARE AND SECURITY RESEARCHER
DEF CON USA 2019
53
Invoking an unmanaged methods. 
Declares a private class.
Defines an initially runtime zeroed 
local variable (type class) of the 
current method. 
ALEXANDRE BORGES – MALWARE AND SECURITY RESEARCHER
DEF CON USA 2019
54
It calls a virtual method, which can 
be overriden the the derived 
class). 
It loads -1 onto the stack.
Calls a static method GetCurrentProcess( ) method from 
Process class (within namespace System.Diagnostics) 
and returning an instance of Process class. 
Duplicate the value of 
the top of the stack.
legal instructions to way 
out of a “try block.”
ALEXANDRE BORGES – MALWARE AND SECURITY RESEARCHER
DEF CON USA 2019
55
It seems that someone 
is interested in our 
typed information. 
ALEXANDRE BORGES – MALWARE AND SECURITY RESEARCHER
DEF CON USA 2019
56
family: can be accessed by any class 
descending from the current one. 
ldfld: loads the instance field onto the stack.
ldsfld: loads the static field onto the stack.
Event declaration. We should 
remember that all events must 
have a subscribing  method 
(.addon ) and a unsubscribing 
method (.removeon), at least. 
Cleaning up
ALEXANDRE BORGES – MALWARE AND SECURITY RESEARCHER
DEF CON USA 2019
57
Declaring three local class variables in 
three different slots: 0, 1 and 2. We should 
remember that, eventually, slots of same 
type can be reused. However, it is another 
talk... 
ALEXANDRE BORGES – MALWARE AND SECURITY RESEARCHER
DEF CON USA 2019
58
Finally, when the publisher calls the Invoke method of the 
aggregate delegate, so the event is raised. 
Delegates are references representing “type-safe” 
function pointers. Thus, Combine( ) adds callback 
function pointers to an aggregate, which is used to 
implement the event.
Generic Delegate! Compares the second and third arguments and, if 
it’s equal, replace the first argument (!!0&). 
ALEXANDRE BORGES – MALWARE AND SECURITY RESEARCHER
DEF CON USA 2019
59
turn off compile optimization and 
not allow put this function as inline. 
calling several instance contructors
calling the virtual method
ALEXANDRE BORGES – MALWARE AND SECURITY RESEARCHER
DEF CON USA 2019
60
pushes a null references onto the stack
converts to int64 and pushes it onto the stack
converts to int32 and throws an exception when overflow
declares and initializes the local variable
Function used to decrypt strings
loads the local variable onto stack.
ALEXANDRE BORGES – MALWARE AND SECURITY RESEARCHER
DEF CON USA 2019
61
 As mentioned previously, a managed assembly can be compiled into a native image 
and installed by using Ngen.exe, but the managed assembly is still necessary. 
 DLL loaded from the Global Assembly Cache can and need to be monitored to 
detect strange behavior. Tools to log the DLL loading such as Fuslogvw.exe 
(Assembly Bind Log Viewer) and common applications such as Process Monitor can 
help us.
 Of course, .NET malware threats can try to compromise the .NET runtime class 
libraries and JIT, which would cause a deep infection in the system and  demand a 
detailed investigation because: 
 changing a runtime library (at IL code) can be lethal to many applications.
 it is feasible to change (hooking)/replace a runtime library. 
 changing a runtime library allows the threat to “break” some strict rules.
 Changing JIT cause same problems, but it is harder.
 Remember about basics: 
 copy DLL from GAC  dnSpy/Reflector + Reflexil  ildasm  change  ilasm
 Ngen  copy back to GAC (malware dropper can accomplish this task) 
ALEXANDRE BORGES – MALWARE AND SECURITY RESEARCHER
DEF CON USA 2019
62
 Of course, nothing is so simple:
 If the malware’s target is a DLL from .NET runtime, so it is digitally signed and 
it would be necessary to have the private key to sign it. Unfortunately, we 
don’t have.  
 Another option would be to generate a new pair of keys and re-sign all the 
DLL Framework. Unfortunately, it is so much work. 
 Copying a modified runtime DLL over the existing one can be difficult or 
almost impossible because other programs can be using it. Thus, we should 
stop programs and services to accomplish this task. 
 Eventually, it is necessary to reboot the machine (urgh!) to perform this copy 
from a script. 
 Using the new and modified DLL can be tricky: uninstall the existing native 
library (ngen uninstall ) and remove it from its respective directory 
under NativeImages_ directory. 
 There are other many tricks such as dropping an assembly into C:\Windows\System32 
or Syswow64)\Tasks\Tasks.dll (hint from Casey Smith)
ALEXANDRE BORGES – MALWARE AND SECURITY RESEARCHER
DEF CON USA 2019
63
 An alternative would be change the Registry. In this case, the GAC continue 
being associated to the original (and untouched) assembly, while its 
associated native image is changed to the modified version. 
 In this case: 
 HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Fusion\NativeImagesInd
ex\v2.0.50727_64\IL key holds information (name + signature key) 
about the original assembly.
 HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Fusion\NativeImagesInd
ex\v2.0.50727_64\NI key would hold information (name + MVID) about 
the modified native image.
 Using the MVID from NI key makes simple to locate the native image.
 Thus, we can either override the native image with a modified version or 
change the MVID entry to point to another native image. 
 GAC (old .NET assemblies) / GAC_32 (IL and x86) / GAC_64 (IL and x64) / 
GAC_MSIL (IL code) directories are under C:\Windows\Assembly directory. 
ALEXANDRE BORGES – MALWARE AND SECURITY RESEARCHER
DEF CON USA 2019
64
 Most of the time, .NET malwares attacking the .NET libraries try either to remove 
some check or introduce hooking points at entry or exit of a method. In this 
case, System.Reflection is commonly used. 
 Additionally, there are cases of .NET malware threats attacking  applications and 
the service management offered by System.ServiceProcess.ServiceBase class and 
their associated method such as OnStart( ), OnStop( ), Run( ), ServiceMain( ) and 
so on. 
 Modifying a target code for changing the execution flow demands inserting 
references (.assembly extern directive) to signed libraries (version + public key) 
to be able to access member and call methods. 
 Of course, we should remember to increase the stack (.maxstack).
 At end, we have multiple types of attacks from a malicious managed code by 
establishing a C2, intercepting communication with trusted websites, opening 
shells, gathering system information, launching native second stage droppers, 
intercepting filesystem communication, stealing information and so on. 
ALEXANDRE BORGES – MALWARE AND SECURITY RESEARCHER