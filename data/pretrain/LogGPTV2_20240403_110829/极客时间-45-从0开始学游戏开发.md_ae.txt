# 第4讲 \| 底层绘图接口的妙用上一节，我给你介绍了游戏引擎的概念及其在游戏开发中所起的作用。同时，我也提到了游戏引擎背后的工作方式。在代码层面，游戏引擎是一套对底层绘图、音频、操作系统接口的封装实现。在此基础上，我还举了一个在游戏屏幕上画线条的例子。在这个例子中，**画线的接口函数在背后分解、组合、计算，并将绘制工作交给底层绘图接口。]{.orange}**这个绘图接口，就是今天要讲的内容。
## 几种常见的绘图接口 {#05.html#-}前面我已经说过，我会针对 2D游戏来讲解游戏开发的流程和细节，所以，这里我先介绍几种2D**绘图接口**（即**API，**全称**Application ProgrammingInterface**）。我选择了 5 种 Windows 下最流行的绘图接口，分别讲解。
### 1.OpenGL {#05.html#1-opengl}OpenGL 是老牌的图形图像接口。GL 是 Graphics Library的缩写。所以，顾名思义，OpenGL 就是开放图形接口的意思。和接下来要讲的DirectX 一样，OpenGL 也可以创建和渲染 2D、3D 图形。但是，和 DirectX不同的是，它可以在多种平台下运行，比如 Windows、Linux、macOS 和部分UNIX，而 DirectX 只能在 Windows 生态下运行。OpenGL本身只提供图形渲染接口，如果你需要别的功能，比如音频、鼠标、键盘的操作，甚至是创建一个窗体，都需要别的扩展库支持。
### 2.DirectX {#05.html#2-directx}说起 DirectX，这个名字已经如雷贯耳。DirectX的开发初衷，是为了让游戏开发者能像在 DOS 平台编写游戏一样，在当时新的Windows 95 平台上，也能一样高效、快速地操纵各种硬件设备。其实，在 DirectX 发布之前，微软已经将 OpenGL 包含在 Windows系统里面。随着时间的推移，OpenGL 逐渐成为了行业标准，而 DirectX自然免不了与其展开竞争。这里，我主要介绍一下 DirectX 中的两个核心组件。这两个核心组件的功能与 2D游戏编程息息相关，你一定得了解一下。``{=html}第一个是**DirectDraw**。它是早期 DirectX 中掌管 2D部分的组件。DirectDraw 类似我之后要说的GDI，支持显存位图，而不是只能将位图存放在内存里，所以 DirectDraw更贴近硬件。但是在 DirectX 7 版本之后，DirectDraw 被合并到 DirectGraphics 组件中。虽然目前仍有很多人在使用 DirectDraw的老版本开发包，然而 DirectDraw 已经被微软逐渐淘汰。第二个是**Direct2D**。它是微软推出的最新 2D 组件，它的出现是为了取代Windows 下的 GDI、GDI+ 和 DirectDraw。Direct2D 能通过硬件加速来绘制 2D图形，也支持高质量 2D 图形渲染，比如支持 ClearType呈现的方式、除锯齿、几何位图的绘制和填充等等。
### 3.SDL {#05.html#3-sdl}SDL 全称**Simple DirectMediaLayer**，直译就是**简单的直接媒体层**。从严格意义上来讲，SDL并不算是"独立的"图形渲染接口，因为它将各类操作系统的图形图像渲染接口进行了封装，包装成统一的函数，以此来方便调用。比如，在Windows 下，它封装了 DirectX 和 GDI+；在 Linux 下，它封装了 Xlib等等。同时，它也提供了 OpenGL 的调用函数。SDL 不仅仅可以对现有图形图像接口进行封装，它也提供 SDL官方自己发布的编程接口。比如，SDL_image、图像接口、SDL_net、网络接口等等。后续我将介绍到的Pygame，其背后就是调用 SDL 编写的。Pygame 是使用 Python 封装的游戏库，你可以很方便地利用 Pygame 进行 2D游戏的编写，它的背后，调用的就是 SDL 的接口。所以我们将利用 Pygame 来对2D 游戏开发流程做一个完整的梳理。虽然网上关于 Pygame的代码和教材很多，但是我们要讲的，**不仅仅是 Pygame代码是如何编写的，而是要从 Pygame 的代码中，分析 2D游戏的编写逻辑和编程思想]{.orange}**。在这个过程中，Pygame只是一个载体。
### 4.GDI {#05.html#4-gdi}GDI，全称**Graphics Device Interface**，也是 Windows下的图形设备接口。它所做的就是处理 Windows 程序的图形输出，负责在Windows 系统和绘图程序之间进行信息的交换。使用 GDI的人已经越来越少，从编程的方便性和硬件加速等功能来看，GDI 被 GDI+取代是显而易见的。
### 5.GDI+ {#05.html#5-gdi-}在 Windows 下，大部分接触过图形编程的程序员都会用过 GDI+。而 GDI+其实就是 GDI 的进阶版本。GDI+ 是有**硬件加速功能**的，而 GDI 没有；GDI 是以 C语言接口的形式提供的，而 GDI+ 则是 C++和托管类的形式提供；从接口代码的层次上说，GDI+对程序员更友好，使用起来也更顺手。GDI+ 还提供了**图像处理**的接口，比如提供了 Image、Bitmap等类，可以用于读取、保存、显示，操作各种类型的图像，比如 BMP、JPG、GIF等。GDI 和 GDI+ 的**绘图操作**也存在差别。GDI中存在一个称为"当前坐标"（MoveTo）的位置。"当前坐标"的存在是为了提高绘画的效率。我还拿画线的过程来举例。有一条新的线连着一条老的线画，如果有了"当前坐标"的设置，逻辑上可以避免每次画线都要给出两个点的坐标（开始和结束）；如果每次都以该"当前坐标"做为起始点，线条绘制结束后，线的结束位置就成为"当前坐标"。事实上，这种方式的存在是有历史原因的。有一种说法来自很早的 Logo语言。这种语言针对儿童进行寓教于乐的编程教育。它的绘画逻辑是，如果有"当前坐标"这个概念，只需要一个递归就可以不停地画线，最终组成一个图形。所以后期很多的绘画接口都沿用这种方式去做。但实际到了2000 年左右，人们发现这种方式并不方便，因此 GDI+ 取消了这个"当前坐标"。一个原因是不方便；另一个原因是，如果无法确定"当前坐标"，绘图就会出现差错。而用GDI+ 绘制线条，则可以直接在 DrawLine函数中指定起始点和结束点的坐标位置。