     0005: 0x06 0x00 0x00 0x7fff0000  return ALLOW
     0006: 0x06 0x00 0x00 0x00000000  return KILL
这种可以通过 open read write 来读取flag
可以看 高校战役的 lgd
第二种是禁用了 open，write，read
     0000: 0x20 0x00 0x00 0x00000004  A = arch
     0001: 0x15 0x00 0x09 0xc000003e  if (A != ARCH_X86_64) goto 0011
     0002: 0x20 0x00 0x00 0x00000000  A = sys_number
     0003: 0x35 0x00 0x01 0x40000000  if (A > 32 # read(fd, buf, count)
     0008: 0x25 0x03 0x00 0x00000000  if (A > 0x0) goto 0012
     0009: 0x15 0x00 0x03 0x00000000  if (A != 0x0) goto 0013
     0010: 0x20 0x00 0x00 0x00000010  A = fd # read(fd, buf, count)
     0011: 0x35 0x00 0x01 0x00000004  if (A > 32 # read(fd, buf, count)
     0011: 0x15 0x00 0x08 0x00000000  if (A != 0x0) goto 0020
     0012: 0x20 0x00 0x00 0x00000010  A = fd # read(fd, buf, count)
     0013: 0x15 0x05 0x06 0x00000000  if (A == 0x0) goto 0019 else goto 0020
     0014: 0x15 0x00 0x05 0x00000001  if (A != write) goto 0020
     0015: 0x20 0x00 0x00 0x00000014  A = fd >> 32 # write(fd, buf, count)
     0016: 0x15 0x00 0x03 0x00000000  if (A != 0x0) goto 0020
     0017: 0x20 0x00 0x00 0x00000010  A = fd # write(fd, buf, count)
     0018: 0x15 0x00 0x01 0x00000001  if (A != 0x1) goto 0020
     0019: 0x06 0x00 0x00 0x7fff0000  return ALLOW
     0020: 0x06 0x00 0x00 0x00000000  return KILL
这种限制 参数的 可以冲参数上有什么问题，去考虑，比如第二道
限制只能冲 0 读，那可以把 0 close 再open 就可以
然后第一道，也是fd 限制为0，但是
     0007: 0x20 0x00 0x00 0x00000014  A = fd >> 32 # read(fd, buf, count)
     0008: 0x25 0x03 0x00 0x00000000  if (A > 0x0) goto 0012
fd为4个字节就能绕过
第四种是限制了sys_number,看起来完全无法利用一样，但是可以用32位的绕过或者用0x400000+sys_number，这样好像是调用了32位的ABI
     0000: 0x20 0x00 0x00 0x00000004  A = arch
     0001: 0x15 0x00 0x07 0xc000003e  if (A != ARCH_X86_64) goto 0009
     0002: 0x20 0x00 0x00 0x00000000  A = sys_number
     0003: 0x15 0x05 0x00 0x00000002  if (A == open) goto 0009
     0004: 0x15 0x04 0x00 0x00000009  if (A == mmap) goto 0009
     0005: 0x15 0x03 0x00 0x00000065  if (A == ptrace) goto 0009
     0006: 0x15 0x02 0x00 0x00000101  if (A == openat) goto 0009
     0007: 0x15 0x01 0x00 0x00000130  if (A == open_by_handle_at) goto 0009
     0008: 0x06 0x00 0x00 0x7fff0000  return ALLOW
     0009: 0x06 0x00 0x00 0x00000000  return KILL
这种就是 没判断
    if (A < 0x40000000)
导致了可以 0x40000000+sys_number绕过，sys_number |= 0x40000000
     0000: 0x20 0x00 0x00 0x00000000  A = sys_number
     0001: 0x15 0x04 0x00 0x00000001  if (A == write) goto 0006
     0002: 0x15 0x03 0x00 0x00000000  if (A == read) goto 0006
     0003: 0x15 0x02 0x00 0x00000009  if (A == mmap) goto 0006
     0004: 0x15 0x01 0x00 0x00000005  if (A == fstat) goto 0006
     0005: 0x06 0x00 0x00 0x00050005  return ERRNO(5)
     0006: 0x06 0x00 0x00 0x7fff0000  return ALLOW
     0007: 0x06 0x00 0x00 0x00000000  return KILL
如果没有 if (A != ARCH_X86_64) 这个可以同32位的shellcode绕过过，具体的可以参考下
SCTF2020里面的`CoolCode` ,利用 `retfq` 切换到32模式，来执行指令
可以 看 [1](http://p4nda.top/2018/07/27/CISCN-Final/)
参考链接
[一道 CTF 题目学习 prctl 函数的沙箱过滤规则](https://www.anquanke.com/post/id/186447#h2-7)
[seccomp学习笔记](//veritas501.space/2018/05/05/seccomp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/))
[seccomp_sys](https://docs.rs/seccomp-sys/0.1.0/seccomp_sys/fn.seccomp_rule_add.html)