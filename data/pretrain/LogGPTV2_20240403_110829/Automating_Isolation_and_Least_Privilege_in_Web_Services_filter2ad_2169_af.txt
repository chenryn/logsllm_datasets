(cid:11)
(cid:10)
(cid:13)
(cid:19)
(cid:23)
(cid:1)(cid:8)(cid:2)(cid:2)(cid:2)
(cid:1)(cid:7)(cid:2)(cid:2)(cid:2)
(cid:1)(cid:6)(cid:2)(cid:2)(cid:2)
(cid:1)(cid:5)(cid:2)(cid:2)(cid:2)
(cid:1)(cid:4)(cid:2)(cid:2)(cid:2)
(cid:1)(cid:3)(cid:2)(cid:2)(cid:2)
(cid:1)(cid:2)
consumption. Based on these measurements, modern servers
with a fairly modest 16 GB of RAM would be able to run
applications with hundreds of views. In comparison, the
most complicated application we tested had only 47 views.
While on dedicated servers, memory consumption may not
be prohibitive, in memory-constrained environments (e.g.,
hosted virtual machines), this cost may be excessive. In these
cases, a more aggressively optimized version of Passe could
make better use of copy-on-write memory and other memory
saving techniques to reduce this overhead. Such performance
improvements remain as future work.
(cid:9)(cid:10)(cid:11)(cid:12)(cid:13)
(cid:14)(cid:13)(cid:15)
(cid:15)(cid:16)(cid:13)(cid:17)(cid:18)(cid:19) (cid:15)(cid:10)(cid:14)(cid:16)(cid:20)(cid:18)(cid:21)(cid:19)(cid:22)(cid:15)
Figure 11: Memory usage of Passe in comparison to normal Django.
IX. RELATED WORK
(cid:1)
(cid:14)
(cid:13)
(cid:20)
(cid:19)
(cid:18)
(cid:17)
(cid:16)
(cid:15)
(cid:14)
(cid:13)
(cid:12)
(cid:1)
(cid:11)
(cid:9)
(cid:10)
(cid:8)
(cid:24)
(cid:23)
(cid:22)
(cid:21)
(cid:1)
(cid:1)(cid:6)(cid:2)(cid:2)(cid:2)
(cid:1)(cid:5)(cid:2)(cid:2)(cid:2)
(cid:1)(cid:4)(cid:2)(cid:2)(cid:2)
(cid:1)(cid:3)(cid:2)(cid:2)(cid:2)
(cid:1)(cid:2)
(cid:1)(cid:2) (cid:1)(cid:7) (cid:1)(cid:3)(cid:2) (cid:1)(cid:3)(cid:7) (cid:1)(cid:4)(cid:2) (cid:1)(cid:4)(cid:7) (cid:1)(cid:5)(cid:2) (cid:1)(cid:5)(cid:7) (cid:1)(cid:6)(cid:2) (cid:1)(cid:6)(cid:7) (cid:1)(cid:7)(cid:2)
(cid:25)(cid:16)(cid:17)(cid:26)(cid:11)(cid:27)(cid:1)(cid:13)(cid:28)(cid:1)(cid:15)(cid:20)(cid:17)(cid:18)(cid:10)(cid:11)(cid:1)(cid:29)(cid:20)(cid:11)(cid:30)(cid:15)
Figure 12: Idle memory consumption of Passe while varying the number of
views spawned by the simple application benchmark.
To characterize the throughput overhead of Passe, we
used JMeter conﬁgured with 40 simultaneous users. We ran
Gunicorn with 8 worker processes (one worker per CPU
core). When running Django, each of these workers ran
a separate Python interpreter with a separate copy of the
Django application. When running Passe, each worker ran a
separate Python interpreter connected to separate instances
of Passe.
Throughput results (Figure 10) show that the cost of
Passe may vary greatly based on the application. For the
simple benchmark, which requires little I/O and no database
operations, Passe reduces throughput by 37%. However, for
actual applications that often require more I/O and query the
database, such as the forum or CMS applications, we ﬁnd
Passe reduces throughput by about 25%.
B. Memory Overhead
In addition to latency overhead, Passe adds memory
overhead, as each view requires a separate OS process. To
characterize this overhead, we measured the total memory
consumption of Passe while running 8 workers for our
benchmark applications (Figure 11). While this memory
overhead is large, it does not increase signiﬁcantly under
load. Rather,
the memory overhead corresponds to the
number of views in the application, each of which causes
8 separate processes to be spawned. In order to understand
the behavior of this relationship, we varied the number of
views in our simple application. Figure 12 shows the linear
correspondence between the number of views and the memory
Intrusion Detection Systems: Our approach is most
related to previous work in intrusion detection. Like intrusion
detection systems, Passe uses dynamic analysis of execution
to “learn” the normal or intended behavior of the application.
Some work, such as DFAD [7] or SwitchBlade [20], has
similarly used taint tracking to check whether a detected de-
viation in program behavior was the result of a code injection
attack. This does not address attacks where code injection
was not the root cause. Other intrusion detection work, such
as Swaddler [21], SENTINEL [22] and DoubleGuard [8], has
analyzed internal program state to infer potential invariants
using Extended Finite State Machine modeling.
Passe differs from this work in two major ways. First,
Passe actively splits applications into sandboxed components,
allowing Passe to more easily infer constraints and to support
more restrictive constraints than could otherwise be achieved.
Second, Passe’s enforcement mechanisms operate without
instrumenting application code or requiring a stateful database
proxy. This prevents arbitrary code exploits from defeating
the system and allows the proxy to be implemented in a
scale-out architecture.
AutoISES [23] attempts to infer relationships between
security checks and data accesses. In general, Passe cannot
know which queries are “permission checks,” and so must
make inferences about the relationships between queries.
Automated Vulnerability Detection: Some work in
vulnerability detection has used a similar inference model to
ﬁnd potential errors in application code [24]. Several systems
for detecting web vulnerabilities use program analysis to
ﬁnd bugs which can be readily identiﬁed once they are
found (e.g., application crashes, malformed HTML, or
forced browsing) [25, 26, 27]. For ﬁnding general data-ﬂow
violations which are harder to characterize, Passe cannot use
the same kind of analysis.
Other work attempting to detect data-ﬂow vulnerabilities
has used a similar approach to Passe. For example, in [28],
“normal” usage of the application is analyzed dynamically.
In [29], taint tracking is used to identify cases in which
user input has not been properly sanitized. Such work is
focused on ﬁnding bugs rather than developing policies for
146
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 11:57:26 UTC from IEEE Xplore.  Restrictions apply. 
a secure runtime, as in Passe. Thus, many of these projects’
mechanisms cannot be applied to Passe’s setting.
Decentralized Information Flow Control: Passe differs
signiﬁcantly from traditional DIFC systems [30, 31, 32, 33,
34, 35], as Passe learns application policy during an analysis
phase, while DIFC systems require developers or users to ex-
plicitly annotate data or code. Because DIFC systems require
reasoning about information labels, application code may
still be vulnerable to aberrant behavior. This is true even for
automatic instrumentation systems such as SWIM [36], which
still requires developer-supplied policies. Hails [18] applies
the DIFC model to web applications while using a shared
data store. Hails requires applications to be written in a safe
subset of Haskell. Hails’ policies provide stronger guarantees
than Passe, but require explicit policy speciﬁcation.
XSS Protection: There has been signiﬁcant work in
preventing XSS attacks. Much of this work has focused on
ﬁltering and sanitizing user inputs. Passe addresses a stronger
class of threats, in which the attack has compromised part
of the application code. Other work allows applications to
specify exactly which scripts should be executed and in
what form [37, 38], or focuses on using the proposed CSP
standard [11] to separate trusted script sources from the data
of the HTTP response [39]. Other client side solutions use
taint tracking or ﬁne-grained policies to limit the threat of
XSS attacks [40, 41] XSS-Guard learns the set of scripts a
web application typically constructs, and blocks unrecognized
scripts [42]. While these approaches may work in Passe’s
setting, the approach we chose reuses the view-level isolation
model from the rest of our system’s protections. This allows
us to unify isolation at the server with isolation at the client.
Other Approaches to Web Security: Resin [43], a system
which uses explicit policies to specify allowable data ﬂows,
can provide many of the same properties as Passe. However,
because Resin relies on data-ﬂow tracking in the application
during runtime, it is susceptible to remote code exploits.
Systems such as Diesel [44] and OKWS [45] provide web
frameworks strongly rooted in the principle of least privilege.
Passe provides much richer constraints and does not require
explicit separation from the developer. SELinks [46] supports
enforcing explicit security policies near the database. Unlike
Passe, policies are compiled into user-deﬁned functions at
the database.
X. CONCLUSION
This paper introduces Passe, a system that provides security
guarantees for applications using a shared data store. Passe
decomposes applications into isolated views which execute in
sandboxed environments. Passe enforces the integrity of data
queries by using cryptographic tokens to preserve learned
data and control-ﬂow dependencies. In doing so, Passe infers
and enforces security policies without requiring developers
to specify them explicitly (and sometimes erroneously).
Our Passe prototype is capable of executing unmodiﬁed
Django applications. We test Passe on eleven off-the-shelf
applications, detail some of its inferred constraints, demon-
strate several examples of security vulnerabilities it prevents,
and show that it adds little performance overhead.
ACKNOWLEDGMENTS
We thank the anonymous PC and our shepherd Andrei
Sabelfed for the constructive feedback. We are grateful to
Nickolai Zeldovich for insightful discussion about our project.
We are also thankful to Edward Felten, Arvind Narayanan,
Ariel Rabkin, David Shue, Wyatt Lloyd, Matvey Arye, Ariel
Feldman, Marcela Melara, Xiaozhou Li, and Amy Tai, for all
of their helpful comments during the course of this project.
This research is supported by NSF Award CSR-0953197
(CAREER) and a Sloan Research Fellowship.
REFERENCES
[1] M. Schwartz, “Hackers hit Symantec, ImageShack, but
not PayPal,” http://www.informationweek.com/security/attacks/
hackers-hit-symantec-imageshack-but-not/240049863, 2012.
[2] T. Smith, “Hacker swipes 3.6m Social Security numbers, other
data,” http://usat.ly/TkBM0H, 2012.
[3] T. Preston-Warner, “Public key security vulnerability and
mitigation,” https://github.com/blog/1068-public-key-security-
vulnerability-and-mitigation, 2012.
[4] J. H. Saltzer and M. D. Schroeder, “The protection of
information in computer systems,” Proc. IEEE, vol. 63, no. 9,
1975.
[5] D. Brumley and D. Song, “Privtrans: Automatically parti-
tioning programs for privilege separation,” in Proc. USENIX
Security, 2004.
[6] S. Chong, J. Liu, A. C. Myers, X. Qi, K. Vikram, L. Zheng, and
X. Zheng, “Secure web applications via automatic partitioning,”
in Proc. SOSP, 2007.
[7] S. Bhatkar, A. Chaturvedi, and R. Sekar, “Dataﬂow anomaly
detection,” in Proc. IEEE S & P, 2006.
[8] M. Le, A. Stavrou, and B. Kang, “Doubleguard: Detecting
intrusions in multitier web applications,” IEEE TDSC, vol. 9,
no. 4, pp. 512–525, 2012.
[9] https://www.djangoproject.com/weblog/2011/nov/, 2011.
[10] http://wiki.apparmor.net/, 2012.
[11] “Content Security Policy 1.1,” www.w3.org/TR/CSP11/, Jun
2013.
[12] D. Akhawe, P. Saxena, and D. Song, “Privilege separation in
HTML5 applications,” in Proc. USENIX Security, 2012.
[13] E. J. Schwartz, T. Avgerinos, and D. Brumley, “All you ever
wanted to know about dynamic taint analysis and forward
symbolic execution (but might have been afraid to ask),” in
Proc. IEEE S & P, 2010.
[14] J. Clause, W. Li, and A. Orso, “Dytan: a generic dynamic
taint analysis framework,” in Proc. ISSTA, 2007.
[15] V. Haldar, D. Chandra, and M. Franz, “Dynamic taint
propagation for java,” in Proc. ACSAC, 2005.
147
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 11:57:26 UTC from IEEE Xplore.  Restrictions apply. 
[34] W. Cheng, D. R. K. Ports, D. Schultz, V. Popic, A. Blankstein,
J. Cowling, D. Curtis, L. Shrira, and B. Liskov, “Abstractions
for usable information ﬂow control in Aeolus,” in Proc.
USENIX ATC, 2012.
[35] Y. Mundada, A. Ramachandran, and N. Feamster, “Silverline:
Data and network isolation for cloud services,” in Proc.
HotCloud, 2011.
[36] W. R. Harris, S. Jha, and T. Reps, “DIFC programs by
automatic instrumentation,” in Proc. CCS, 2010.
[37] M. Ter Louw and V. Venkatakrishnan, “Blueprint: Robust
prevention of cross-site scripting attacks for existing browsers,”
in Proc. IEEE S & P, 2009.
[38] Y. Nadji, P. Saxena, and D. Song, “Document Structure
Integrity: A robust basis for cross-site scripting defense.” in
Proc. NDSS, 2009.
[39] A. Doupé, W. Cui, M. H. Jakubowski, M. Peinado, C. Kruegel,
and G. Vigna, “deDacota: Toward preventing server-side XSS
via automatic code and data separation,” in Proc. CCS, 2013.
[40] L. A. Meyerovich and B. Livshits, “Conscript: Specifying and
enforcing ﬁne-grained security policies for Javascript in the
browser,” in Proc. IEEE S & P, 2010.
[41] P. Vogt, F. Nentwich, N. Jovanovic, E. Kirda, C. Kruegel, and
G. Vigna, “Cross site scripting prevention with dynamic data
tainting and static analysis.” in Proc. NDSS, 2007.
[42] P. Bisht and V. Venkatakrishnan, XSS-GUARD: precise dy-
namic prevention of cross-site scripting attacks. Springer,
2008, pp. 23–43.
[43] A. Yip, X. Wang, N. Zeldovich, and M. F. Kaashoek,
“Improving application security with data ﬂow assertions,” in
Proc. SOSP, 2009.
[44] A. P. Felt, M. Finifter, J. Weinberger, and D. Wagner, “Diesel:
Applying privilege separation to database access,” in Proc.
ASIACCS, 2011.
[45] M. Krohn, “Building secure high-performance web services
with OKWS,” in Proc. USENIX ATC, 2004.
[46] N. Swamy, B. J. Corcoran, and M. Hicks, “Fable: A language
for enforcing user-deﬁned security policies,” in Proc. IEEE S
& P, 2008.
[16] N. Poole, “Code execution via YAML in JS-YAML Node.js
module,” https://nealpoole.com/blog/2013/06/code-execution-
via-yaml-in-js-yaml-nodejs-module/, Jun 2013.
[17] A. Patterson, “Serialized attributes YAML vulnerability with
Rails 2.3 and 3.0 [cve-2013-0277],” https://groups.google.com/
d/msg/rubyonrails-security/KtmwSbEpzrU/NzjxkM7HLjAJ,
Feb 2013.
[18] D. B. Gifﬁn, A. Levy, D. Stefan, D. Terei, D. Mazières,
J. Mitchell, and A. Russo, “Hails: Protecting data privacy
in untrusted web applications,” in Proc. OSDI, 2012.
[19] G. DeCandia, D. Hastorun, M. Jampani, G. Kakulapati,
A. Lakshman, A. Pilchin, S. Sivasubramanian, P. Vosshall, and
W. Vogels, “Dynamo: Amazon’s highly available key-value
store,” in Proc. SOSP, 2007.
[20] C. Fetzer and M. Süßkraut, “Switchblade: enforcing dynamic
personalized system call models,” in Proc. EuroSys, 2008.
[21] M. Cova, D. Balzarotti, V. Felmetsger, and G. Vigna, “Swad-
dler: An approach for the anomaly-based detection of state
violations in web applications,” in RAID, 2007, pp. 63–86.
[22] X. Li, W. Yan, and Y. Xue, “Sentinel: securing database from
logic ﬂaws in web applications,” in Proc. ACM CODASPY,
2012.
[23] L. Tan, X. Zhang, X. Ma, W. Xiong, and Y. Zhou, “AutoISES:
Automatically inferring security speciﬁcations and detecting
violations,” in Proc. USENIX Security, 2008.
[24] D. Engler, D. Y. Chen, S. Halem, A. Chou, and B. Chelf,
“Bugs as deviant behavior: a general approach to inferring
errors in systems code,” in Proc. SOSP, 2001.
[25] P. Bisht, T. Hinrichs, N. Skrupsky, and V. Venkatakrishnan,
“Waptec: whitebox analysis of web applications for parameter
tampering exploit construction,” in Proc. CCS, 2011.
[26] S. Artzi, A. Kiezun, J. Dolby, F. Tip, D. Dig, A. Paradkar,
and M. D. Ernst, “Finding bugs in dynamic web applications,”
in Proc. ISSTA, 2008.
[27] F. Sun, L. Xu, and Z. Su, “Static detection of access control
vulnerabilities in web applications,” in Proc. USENIX Security,
2011.
[28] V. V. Felmetsger, L. Cavedon, C. Kruegel, and G. Vigna,
“Toward automated detection of logic vulnerabilities in web
applications,” in Proc. USENIX Security, 2010.
[29] A. Nguyen-tuong, S. Guarnieri, D. Greene, and D. Evans,
“Automatically hardening web applications using precise
tainting,” in Proc. 20th IFIP International Information Security
Conference, 2005.
[30] A. Myers and B. Liskov, “Protecting privacy using the
decentralized label model,” TOSEM, vol. 9, no. 4, pp. 410–442,
2000.
[31] P. Efstathopoulos, M. Krohn, S. VanDeBogart, C. Frey,
D. Ziegler, E. Kohler, D. Mazières, F. Kaashoek, and R. Morris,
“Labels and event processes in the Asbestos Operating System,”
in Proc. SOSP, 2005.
[32] N. Zeldovich, S. Boyd-Wickizer, E. Kohler, and D. Mazières,
“Making information ﬂow explicit in HiStar,” in Proc. OSDI,
2006.
[33] M. Krohn, A. Yip, M. Brodsky, N. Cliffer, M. Kaashoek,
E. Kohler, and R. Morris, “Information ﬂow control for
standard OS abstractions,” in Proc. SOSP, 2007.
148
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 11:57:26 UTC from IEEE Xplore.  Restrictions apply.