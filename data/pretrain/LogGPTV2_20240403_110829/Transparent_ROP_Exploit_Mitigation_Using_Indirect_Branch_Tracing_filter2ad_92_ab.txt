o
i
t
c
a
r
f
.
l
u
m
u
C
1
0.8
0.6
0.4
0.2
0
0
1
10 16
100
1000
   4
10  
Number of indirect branches (ret, jmp, call)
Figure 2: LBR overwriting due to indirect branches that
take place within Windows API functions, prior to the
execution of a system call.
second-stage shellcode can be avoided altogether by im-
plementing all the necessary functionality solely using
ROP code, as is the case with a recent exploit against
Adobe Reader XI, in which the ROP code calls directly
the
func-
tions to drop and execute a malicious DLL [19].
, and
,
,
The implementation of many of the functions exported
by the Windows API is quite complex, and often involves
several internal functions that are executed before the in-
vocation of the intended system call. Due to the lim-
ited size of the LBR stack, this means that by the time
execution reaches the actual system call, the LBR stack
might be ﬁlled with indirect branches that took place af-
ter the Windows API function was called. To assess the
extent of this effect, we measured the average number
of indirect branch instructions (
) that
are executed between the ﬁrst instruction of a Windows
API function and the system call it invokes, for a set of
52 “sensitive” functions that are commonly used in Win-
dows shellcode and ROP code implementations (a com-
plete list of the tested functions is provided in the ap-
pendix). As shown in Fig. 2, about 34% of the API func-
tions execute less that 16 indirect branches, while the rest
of them completely overwrite the LBR stack.
, and
,
As these branches are made as part of legitimate ex-
ecution paths, calling a function that completely over-
writes the LBR stack would allow ROP code to evade
detection. However, this scheme can be improved to pro-
vide robust detection of ROP code that calls any sensitive
API function, irrespectively of the extent of overwriting
in the LBR stack due to code in the function body.
2.2.2 LBR Stack Inspection on API Function Entry
Given that i) exploit code usually calls Windows API
functions instead of directly invoking system calls, and
ii) most API functions overwrite the LBR stack with le-
gitimate indirect branches before invoking a system call,
450  22nd USENIX Security Symposium 
USENIX Association
API call verification
LBR check
kernel
system
DLL
user
space
time
API call
system call
Figure 3: Overview of the detection scheme of kBouncer.
Before the invocation of protected Windows API func-
tions,
the system inspects the LBR stack to identify
whether the execution path that led to the call was part
of ROP code, and writes a checkpoint. To account for
ROP code that would bypass the check by jumping over
kBouncer’s function hook, the system then veriﬁes the
entry point of the API function at the time of the corre-
sponding system call invocation.
kBouncer inspects the LBR stack at the time an API
function is called, instead upon system call invocation.
This allows the detection of ROP code that uses any sen-
sitive API function, irrespectively of the number of legit-
imate indirect branches executed within its body. In case
an API function is called by ROP code, all entries in the
LBR stack at the time of function entry will correspond
to the indirect branches of the gadgets that lead to the
function call, as depicted in Fig. 3.
Still, without any additional precautions, this scheme
would allow an attacker to bypass the LBR check at the
entry point of a function. An implementation of the LBR
check in the system call handler—within the kernel—
safeguards it from user-level code and any bypass at-
tempt.
In contrast, implementing the LBR check as a
hook to a user-level function’s entry point does not pro-
vide the same level of protection. An attacker could
avoid the check by jumping over the hook at the func-
tion’s prologue, instead of jumping at its main entry
point, and then normally executing the function body.
Alternatively, by trading off some of its reliability, the
ROP code could avoid calling the API function alto-
gether by invoking directly the relevant Native API call.
Fortunately, as the Native API is not exposed to user-
level programs, i.e., applications never invoke Native
API calls directly; we can solve this issue by ensur-
ing that system calls are always invoked solely through
their respective Windows API functions. After a clear
LBR check at an API function’s entry point, kBouncer
writes a checkpoint that denotes a legitimate invocation
of that particular function. When the respective system
call is later invoked, the system call handler veriﬁes that
a proper checkpoint was previously set by the expected
API function, and clears it.
If the checkpoint was not
set, then this means that the ﬂow of control did not pass
through the proper API function preamble, and kBouncer
reports a violation.
We should note that user-level ROP code cannot by-
pass kBouncer’s checks by faking a checkpoint. The
code for setting a checkpoint can only run with kernel
privileges, and the checkpoint itself is stored in kernel
space so that i) the system call handler can later access
it, and ii) any user-level code (and consequently the ROP
code itself) cannot tamper with it. The checkpoint code
is tied with and comes right after the code that inspects
the LBR stack, and both run in an atomic way at kernel
level, i.e., the checkpoint cannot be set without previ-
ously analyzing the LBR for the presence of ROP code.
This prevents any ROP code from faking a checkpoint
without being detected—the part of the ROP code with
the task of setting the checkpoint would be detected by
the LBR check before the checkpoint is actually set.
3 Identifying the Execution Behavior of
ROP Code
Before allowing a Windows API function call to proceed,
kBouncer analyzes the most recent indirect branches that
were recorded in the LBR cache prior to the function call.
LBR is conﬁgured to record only
, and
indirect
instructions. The execution of ROP code is
identiﬁed by looking for two prominent attributes of its
runtime behavior: i) illegal
instructions that target
locations not preceded by call sites, and ii) sequences
of relatively short code fragments “chained” through any
kind of indirect branches.
, indirect
Returns that do not transfer control right after call
sites is an illegitimate behavior exhibited by all pub-
licly available ROP exploits against Windows software,
which rely mainly on gadgets ending with
instruc-
tions (
conveniently manipulates both the program
counter and the stack pointer). The second, more generic
attribute captures an inherent property of not only purely
return-oriented code, but also of advanced (and admit-
tedly harder to construct) jump-oriented code (or even
“hybrid” ROP/JOP code that might use any combination
of gadgets ending with
instructions).
, and
,
3.1 Illegal Returns
When focusing on the control ﬂow behavior of ROP code
at the instruction level, we expect to observe the succes-
sive execution of several
instructions, which corre-
spond to the transfer of control from each gadget to the
next one. Although this control ﬂow pattern is quite dis-
tinctive, the same pattern can also be observed in legiti-
mate code, e.g., when a series of functions consecutively
USENIX Association  
22nd USENIX Security Symposium  451
normal
execution
ROP code
execution
call f1
mov eax, esi
...
xchg eax, edi
ret
call f2
test al, al
...
pop ecx
ret
call f3
add esp, 0Ch
...
add eax, edx
ret
pop eax
ret
Figure 4: In normal code,
instructions target valid
call sites (left), while in ROP code, they target gadgets
found in arbitrary locations (right).
return to their callers. However, when considering the
targets of
instructions, there is a crucial difference.
instructions are paired with
In a typical program,
instructions, and thus the target of a legitimate
corresponds to the location right after the call site of the
respective caller function, i.e., an instruction that follows
a
instruction, as illustrated in the left part of Fig. 4.
In contrast, a
instruction at the end of a gadget trans-
fers control to the ﬁrst instruction of the following gad-
get, which is unlikely to be preceded by a
instruc-
tion. This is because gadgets are found in arbitrary lo-
cations across the code image of a process, and often
may correspond to non-intended instruction sequences
that happen to exist due to overlapping instructions [62].
instructions of ROP code can be
easily distinguished from the legitimate return instruc-
tions of a benign program by checking their targets. A
instruction that transfers control to an instruction not
is considered illegal, and the obser-
is ﬂagged by kBouncer as an in-
preceded by a
vation of an illegal
dication of ROP code execution.
At runtime, the
Ensuring
-
pairing by verifying caller-callee
semantics, e.g., using a shadow stack [29], constrains
the control ﬂow of a process in a much stricter way
than the proposed scheme. In practice, though, enforc-
ing such a strict policy is problematic, due to the use of
“getPC” code
commonly found in position-independent executables,
tail call optimizations, and lightweight user-level threads
such as Windows ﬁbers, in which the context switch
function called by the current thread returns to the thread
that is scheduled next.
constructs,
Instead of enforcing a strict control ﬂow, kBouncer
simply makes sure that
instructions always target
any among all valid call sites (even those that correspond
to non-intended
instructions). This is a more re-
laxed constraint that is not expected to be violated (and
which did not, for the set of applications tested as part
of our experimental evaluation) even in programs that
use constructs like the above. Its implementation is also
much simpler, as there is no need to track the execution
of
instructions—checking that the target of each
falls right after a
is enough.
Call-preceded Gadgets Although the above scheme
prohibits the execution of illegal returns, which are
prominently exhibited by typical ROP exploits, an at-
tacker might still be able to construct functional ROP
code using gadgets that begin right after
instruc-
tions, to which we refer as
-preceded gadgets. Note
that
-preceded gadgets may begin after either in-
tended or unintended
instructions. As kBouncer
cannot know which
instructions were actually
emitted by the compiler, if any of the possible valid in-
structions immediately preceding the instruction at a tar-
get address is a
instruction, then that address may
correspond to the beginning of a
-preceded gadget.
that targets an instruction
located right after a
is considered by kBouncer
as normal, and thus ROP code comprising only
-
preceded gadgets would not be identiﬁed based on the
ﬁrst ROP code attribute kBouncer looks for during
branch analysis. Although such code would still be iden-
tiﬁed due to its “chained gadgets” behavior, which we
will discuss below, we ﬁrst brieﬂy explore the feasibility
of such an attempt.
The observation of a
For our analysis we use a set of typical Windows ap-
plications, detailed in Table 2. The data is collected us-
ing a purpose-built execution analysis framework, de-
scribed in Sec. 4.2. We consider as a gadget any (in-
tended or unintended) instruction sequence that ends
with an indirect branch, and which does not contain
any privileged or invalid instruction. In contrast to the
gadget constraints typically considered in relevant stud-
ies [62, 23, 60, 24, 73, 53, 36, 70] and the actual gadgets
used in real exploits [27, 19, 1, 6, 7, 2], i.e., contiguous
instruction sequences no longer than ﬁve instructions, we
follow a more conservative approach and consider gad-
gets that i) may be split into several fragments due to
internal conditional or unconditional relative jumps, and
ii) have a maximum length of 20 instructions.
Figure 5 shows the fraction of
-preceded gadgets
among all gadgets that end with a
instruction, for
different Windows applications. In the worst case, only
6.4% of the gadgets begin right after call sites, a per-
centage much smaller compared to all available
gad-
452  22nd USENIX Security Symposium 
USENIX Association
Table 2: Details about the dataset used for gadget analysis.
Media Player
Internet Explorer
Flash Player
MS Word
MS Excel
MS Powerpoint
Adobe Reader
0
1
2
3
4
5
6
7
Fraction of allowed RET gadgets (%)
Figure 5: Among all gadgets that end with a
instruc-
tion, only a small fraction (6.4% in the worst case for
Adobe Reader) begin right after call sites.
gets. Given that many of them are longer than the typical
gadget size, and are thus harder to use in ROP code due
to the many different operations and register or memory
state changes they incur, an attacker would be left with
a severely limited set of gadgets to work with. For com-
parison, the ROP payloads of the exploits we used in our
evaluation, listed in Table 4, collectively use 44 unique
gadgets with an average length of just 2.25 instructions,
and only three of them happen to be