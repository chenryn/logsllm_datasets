 0
 0
 100
 200
 300
 400
 500
 600
 700
 800
 900  1000
File Blocks
Figure 13: Comparing block retrieval on Mozy and a local
drive
located bytes in the ﬁle.9 The client measured the time required for
Mozy to return the requested blocks. The time seen by the client
also includes roughly 100 ms. of round-trip network latency (mea-
sured by pinging the Mozy servers). For comparison, we ran the
same tests locally on the HP drive and report the results in Fig-
ure 13. Once the number of requested blocks is greater than 150,
Mozy is able to retrieve the blocks and transmit them over the net-
work faster than our local drive can pull them from disk. For ex-
ample, 500 requested blocks were returned from Mozy in 2.449
seconds. By comparison, the same task took 3.451 seconds on the
HP drive. Mozy consistently retrieved the blocks 15% faster (and
occasionally up to 30% faster) than would be consistent with the
use of a single, high-performance drive. Even with no modiﬁca-
tion to Mozy, we are already able to demonstrate with a RAFT-like
protocol that Mozy distributes ﬁles across at least two drives.
Of course, with an integrated RAFT system in Mozy, we would
expect to achieve a stronger (i.e., higher) lower bound on the num-
ber of drives in the system, along with a proof of resilience to drive
crashes. RAFT’s suitability for Mozy promises broader deploy-
ment opportunities in cloud infrastructure.
7. RATIONAL SERVERS
The cheap-and-lazy server model reﬂects the behavior of an or-
dinary substandard storage provider. As already noted, an efﬁcient
RAFT is not feasible for a fully malicious provider. As we now
explain, though, RAFTs can support an adversarial server model
that is stronger than cheap-and-lazy, but not fully Byzantine. We
call such a server rational. We show some RAFT constructions for
rational servers that are efﬁcient, though not as practical as those
for cheap-and-lazy servers.
S
(m, ℓ, t) in Figure 1. Let ρ(d, {Dj}d
A rational server S aims to constrain within some bound the
drive and storage resources it devotes to ﬁle F . Refer again to Ex-
periment ExpRAFT (t)
j=1) be
a cost function on a ﬁle placement (d, {Dj}d
j=1) generated by S in
this experiment. This cost function ρ may take into account d, the
total number of allocated drives, and |Dj|, the amount of storage
on drive j. Let R denote an upper bound on ρ. We say that S is
(ρ, R)-constrained if it satisﬁes ρ(d, {Dj}d
j=1) ≤ R for all block
placements it generates. Roughly speaking, within constraint R, a
rational server S seeks to maximize Pr[AccS ]. Subject to maxi-
mized Pr[AccS ], S then seeks to maximize the fault-tolerance of
F . Formally, we give the following deﬁnition:
DEFINITION 1. Let p be the maximum probability Pr[AccS ]
that a (ρ, R)-constrained server S can possibly achieve. A (ρ, R)-
constrained server S is rational if it minimizes Pr[NotFTS ] among
all (ρ, R)-constrained servers S ′ with Pr[AccS ′ ] = p.
A rational adversary can perform arbitrary computations over ﬁle
blocks. It is more powerful than a cheap-and-lazy adversary. In
fact, a rational adversary can successfully cheat against our RAFT
scheme above. The following, simple example illustrates how a
rational S can exploit erasure-code compression, achieving t = 0,
i.e., no fault-tolerance, but successfully answering all challenges.
EXAMPLE 1. Suppose that S aims to reduce its storage costs,
i.e., minimize ρ(d, {Dj}d
j=1) = Pj |Dj|. Consider a RAFT (t)
with (systematic) encoding G, i.e., with {g1, . . . , gm} = {f1, . . . ,
fm} = F and parity blocks gm+1, . . . , gn. S can store {fj}m
individually across m disks {Dj}m
j=1
j=1 and discard all parity blocks.
In this experiment, we had a remote client upload a large (64GB)
ﬁle into Mozy. The client then issued several requests for randomly
9We use bytes to ensure the requested block is on a single drive
since we don’t know the granularity with which Mozy stripes ﬁles.
512To reply to a RAFT challenge, S retrieves every block of F (one per
disk) and recomputes parity blocks on the ﬂy as needed.
7.1 Incompressible erasure codes
This example illustrates why, to achieve security against ratio-
nal adversaries, we introduce the concept of incompressible erasure
codes. Intuitively, an incompressible ﬁle encoding / codeword G is
such that it is infeasible for a server to compute a compact represen-
tation G′. I.e., S cannot feasibly compute G′ such that |G′| < |G|
and S can compute any block gi ∈ G from G′. Viewed another
way, an incompressible erasure code is one that lacks structure,
e.g., linearity, that S can exploit to save space.10
Suppose that S is trying to create a compressed representation
G′ of G. Let u = |G′| < n = |G| denote the length of G′. Given
a bounded number of drives, a server S that has stored G′ can, in
any given timestep, access only a bounded number of ﬁle blocks /
symbols of G′. We capture this resource bound by deﬁning r < n
as the maximum number of symbols in G′ that S can access to
recompute any symbol / block gi of G.
Formally, let IEC = (ECEnc : SK × Bm → Bn, ECDec :
P K×Bn → Bm) be an (n, m)-erasure code over B. Let (sk, pk) ∈
(SK, P K) ← Keygen(1ℓ) be an associated key-generation algo-
rithm with security parameter ℓ. Let A = (A1, A(r)
2 ) be a memory-
less adversary with running time polynomially bounded in ℓ. Here
r denotes the maximum number of symbols / blocks that A2 can
access over G′.
Experiment ExpIEC
A (m, n, ℓ; u, r):
i=1
i=1 ← ECEnc(sk, F );
R← Bm ;
(sk, pk) ← Keygen(1ℓ);
F = {fi}m
G = {gi}n
G′ ∈ Bu ← A1(pk, G);
i R← Zn;
g ← A(r)
if g = gi
2 (pk, G′);
then output 1,
else output 0
Figure 14: IEC Security Experiment
Referring to Figure 14, we have the following deﬁnition:
DEFINITION 2. Let AdvIEC
A (m, n, ℓ, u, r) =
Pr[ExpIEC
A (m, n, ℓ; u, r) = 1] − u/n. We say that IEC is a (u, r)-
incompressible code (for u < n, r < n) if there exists no A such
that AdvIEC
A (m, n, ℓ; u, r) is non-negligible.
In the full version of the paper [5], we prove the following the-
orem (as a corollary of a result on arbitrary (u, d)-incompressible
IECs). It shows that given an IEC and a slightly modiﬁed query
structure, a variant of our basic scheme, RAFT ′(t), is secure
against rational adversaries:
THEOREM 2. For a RAFT (t) using a (n−1, d)-incompressible
IEC, a (ρ, R)-constrained rational adversary S with d drives has
advantage at most AdvRAFT (t)
(m, ℓ, t) ≤ 1 − B(c, t, α), where
B(c, t, α) is deﬁned as in Theorem 1.
S
Keyed RAFTs Adopting the approach of [16, 21], it is possible
to encrypt the parity blocks of G (for a systematic IEC) or all
of G to conceal the IEC’s structure from A.
(In a RAFT, the
client would compute Encode, encrypting blocks individually un-
der a symmetric key κ—in practice using, e.g., a tweakable cipher
mode [18].) Under standard indistinguishability assumptions be-
tween encrypted and random blocks, this transformation implies
(u, r)-incompressibility for any valid u, r < n. While efﬁcient,
this approach has a drawback: Fault recovery requires use of κ,
i.e., client involvement.
Digital signature with message recoverability A digital signa-
ture σ = Σsk[m] with message recoverability on a message m has
the property that if σ veriﬁes correctly, then m can be extracted
from σ. (See, e.g., [3] for PSS-R, a popular choice based on RSA.)
We conjecture that an IEC such that g′
i = Σsk[gi] for a message-
recoverable digital signature scheme implies (u, r)-incompressibility
for any valid u, r < n. (Formal proof of reduction to signature un-
forgeability is an open problem.)
This RAFT construction requires use of private key sk to com-
pute encoding G or to reconstruct G after a data loss. Importantly,
though, it doesn’t require use of sk to construct F itself after a data
loss. In other words, encoding is keyed, but decoding is keyless.
The construction is somewhat subtle. A scheme that appends
signatures that lack message recovery does not yield an incom-
pressible code: A can throw away parity blocks and recompute
them as needed provided that it retains all signatures. Similarly, ap-
plying signatures only to parity blocks doesn’t work: A can throw
away message blocks and recompute them on the ﬂy.11
8. CONCLUSION
We have shown how to bring a degree of transparency to the
abstraction layer of cloud systems in order to reliably detect drive-
failure vulnerabilities in stored ﬁles. Through theory and experi-
mentation, we provided strong evidence that our Remote Assess-
ment of Fault Tolerance (RAFT) works in realistic settings. With
careful parametrization, a RAFT can handle the real-world chal-
lenges of network and drive operation latency for large ﬁles (at least
100MB) stored on traditional storage architectures.
We believe that RAFT has a clear deployment path in systems
such as Mozy, where a cloud server can request data in parallel
from multiple drives and aggregate it before communicating with
the client. Such infrastructure is likely common for providers of-
fering fault-tolerant cloud storage. As we have shown, some level
of data dispersion can already be evidenced in Mozy even with-
out server-side modiﬁcation. It remains an open problem to build
a full end-to-end RAFT protocol integrated into an existing cloud
infrastructure and demonstrate its feasibility in practice.
With their unusual combination of coding theory, cryptography,
and hardware proﬁling, we feel that RAFTs offer an intriguing new
slant on system assurance. RAFT design also prompts interest-
ing new research questions, such as the modeling of adversaries in
cloud storage systems, the construction of provable and efﬁcient
incompressible erasure codes, and so forth.
We propose two constructions for incompressible erasure codes,
with various tradeoffs among security, computational efﬁciency,
and key-management requirements:
10Incompressibility is loosely the inverse of local decodability [22].
11Message-recoverable signatures are longer than their associated
messages. An open problem is whether, for random F , there is
some good message-recoverable signature scheme over blocks of G
that has no message expansion. Signatures would be existentially
forgeable, but checkable against the client copy of F .
513Acknowledgments
We wish to extend our thanks to Burt Kaliski for his comments on
an early draft of this paper, and to Erik Riedel for clearing up ques-
tions about hard drive operation. We also thank Tom Ristenpart
for shepherding the paper and to the anonymous reviewers for their
helpful comments.
9. REFERENCES
[1] D. G. Andersen, J. Franklin, M. Kaminsky, A. Phanishayee,
L. Tan, and V. Vasudevan. FAWN: A fast array of wimpy
nodes. In Proc. ACM SOSP, 2009.
[2] G. Ateniese, R. Burns, R. Curtmola, J. Herring, L. Kissner,
Z. Peterson, and D. Song. Provable data possession at
untrusted stores. In Proc. ACM CCS, pages 598–609, 2007.
[3] M. Bellare and P. Rogaway. The exact security of digital
signatures: How to sign with RSA and Rabin. In U. Maurer,
editor, Proc. EUROCRYPT ’96, volume 1070 of LNCS,
pages 399–416. Springer-Verlag, 1989.
[4] K. Bowers, A. Juels, and A. Oprea. HAIL: A
high-availability and integrity layer for cloud storage. In
Proc. ACM CCS ’09, pages 187–198, 2009.
[5] K. D. Bowers, M. van Dijk, A. Juels, A Oprea, and R. Rivest.
How to tell if your cloud ﬁles are vulnerable to drive crashes,
2010. IACR ePrint manuscript 2010/214.
[6] S. Brands and D. Chaum. Distance-bounding protocols
(extended abstract). In Proc. EUROCRYPT ‘93, pages
344–359. Springer, 1993. LNCS vol. 765.
[7] A. Clements, I. Ahmad, M. Vilayannur, and J. Li.
Decentralized deduplication in san cluster ﬁle systems. In
Proc. USENIX Annula Technical Conference, 2009.
[8] J. Cox. T-Mobile, Microsoft tell Sidekick users we ’continue
to do all we can’ to restore data. Network World, October 13,
2009.
[9] R. Curtmola, O. Khan, R. Burns, and G. Ateniese. MR.PDP:
Multiple-replica provable data possession. In Proc. 28th
IEEE ICDCS, 2008.
[10] Y. Dodis, S. Vadhan, and D. Wichs. Proofs of retrievability
via hardness ampliﬁcation. In Proc. TCC, 2009.
[11] C. Dwork and M. Naor. Pricing via processing or combatting
junk mail. In E.F. Brickell, editor, Proc. CRYPTO ‘92, pages
139–147. Springer, 1992. LNCS vol. 740.
[12] A. Fiat and A. Shamir. How to prove yourself: Practical
solutions to identiﬁcation and signature problems. In Proc.
CRYPTO’86, volume 263 of LNCS, pages 186–194.
Springer, 1986.
[13] T. Garﬁnkel, B. Pfaff, J. Chow, M. Rosenblum, and
D. Boneh. Terra: a virtual machine-based platform for trusted
computing. In Proc. ACM SOSP, pages 193–206, 2003.
[14] S. Ghemawat, H. Gobioff, and S.T. Leung. The Google ﬁle
system. In Proc. ACM SOSP, pages 29–43, 2003.
[15] P. Golle, S. Jarecki, and I. Mironov. Cryptographic primitives
enforcing communication and storage complexity. In Proc.
Financial Cryptography, pages 120–135. Springer, 2002.
LNCS vol. 2357.
[16] P. Gopalan, R. J. Lipton, and Y. Z. Ding. Error correction
against computationally bounded adversaries, October 2004.
Manuscript.
[17] The Hadoop distributed ﬁle system.
http://hadoop.apache.org/hdfs.
[18] S. Halevi and P. Rogaway. A tweakable enciphering mode. In
D. Boneh, editor, Proc. CRYPTO’03, volume 2729 of LNCS,
pages 482–499. Springer, 2003.
[19] Mozy CTO J. Herlocker. Personal Communication, 2011.
[20] A. Juels and J. Brainard. Client puzzles: A cryptographic
countermeasure against connection depletion attacks. In
Proc. ISOC NDSS, pages 151–165, 1999.
[21] A. Juels and B. Kaliski. PORs–proofs of retrievability for
large ﬁles. In Proc. ACM CCS 2007, pages 584–597, 2007.
[22] J. Katz and L. Trevisan. On the efﬁciency of local decoding
procedures for error-correcting codes. In Proc. STOC, pages
80–86, 2000.
[23] R. Kotla, L. Alvisi, and M. Dahlin. Safestore: a durable and
practical storage system. In Proc. USENIX’07, pages
10:1–10:14, Berkeley, CA, USA, 2007. USENIX
Association.
[24] C. Lumezanu, R. Baden, N. Spring, and B. Bhattacharjee.
Triangle inequality variations in the internet. In Proc. ACM
IMC, 2009.
[25] R. Merkle. A certiﬁed digital signature. In Proc. Crypto
1989, volume 435 of LNCS, pages 218–238.
Springer-Verlag, 1989.
[26] J.F. Muth and G.L. Thompson. Industrial scheduling.
Prentice-Hall, 1963.
[27] M. Naor and G. N. Rothblum. The complexity of online
memory checking. In Proc. 46th IEEE FOCS, pages
573–584, 2005.
[28] J. Ousterhout, P. Agrawal, D. Erickson, C. Kozyrakis,
J. Leverich, D. Mazières, S. Mitra, A. Narayanan,
G. Parulkar, M. Rosenblum, S. M. Rumble, E. Stratmann,
and R. Stutsman. The case for RAMClouds: Scalable
high-performance storage entirely in dram. SIGOPS
Operating Systems Review, 43(4):92–105, 2009.
[29] E. Riedel, C. Van Ingen, and J. Gray. A performance study of
sequential I/O on Windows NT 4.0. Technical Report
MSR-TR-97-34, Microsoft Research, September 1997.
[30] C. Ruemmler and J. Wilkes. An introduction to disk drive
modeling. IEEE Computer, 27(3):17–29, 1994.
[31] H. Shacham and B. Waters. Compact proofs of retrievability.
In Proc. Asiacrypt 2008, volume 5350 of LNCS, pages
90–107. Springer-Verlag, 2008.
[32] B. L. Worthington, G. R. Ganger, and Y. N. Patt. Scheduling
algorithms for modern disk drives. In Proc. ACM Sigmetrics,
pages 241–251, 1994.
514