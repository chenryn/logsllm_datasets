**作者：“Tencent Blade Team”leonwxqian  
公众号：[腾讯安全应急响应中心](https://mp.weixin.qq.com/s/SBQhFLh6nAAFMvUnVxnjEQ
"腾讯安全应急响应中心")**
### ** 背景**
Tencent Blade
Team在代码审计过程中发现了curl中存在两个可以通过NTLM远程触发的漏洞。这两个漏洞存在于curl在处理Type-2和Type-3消息的逻辑中。
这两个漏洞分别为：
（1）远程内存读取
（CVE-2018-16890， ）
利用此漏洞，攻击者可以在服务器上远程获取客户端内存至多64KB的原始内存信息。而且因为连接可以多次进行，服务器理论上可以多次重复地获取客户端内存。
（2）远程栈缓冲区溢出
（CVE-2019-3822，）
利用此漏洞，攻击者可以通过服务器的认证消息对客户端进行远程栈缓冲区溢出。通过组合上一个漏洞，理论上攻击者可以对客户端进行远程代码执行（RCE）。
curl的作者Daniel在博客中提到“我觉得这可能是很长时间以来curl中发现的最严重的安全问题”（I think this might be the
worst security issue found in curl in a long
time.，）。
如果编译curl时，选择了使用openssl同时禁用md4，则有漏洞的代码不会被编译进去。在这些情况下的curl不受此漏洞的影响。
我们先从一些常见的场景和认证模式来介绍一下背景，这样可以更方便理解curl这些漏洞是如何工作的。
#### **1.1 关于curl**
curl虽然比较少作为独立的软件出现在大众面前，但是它可谓是一个不折不扣的幕后大佬。它是许多互联网程序的必不可少的组件。
curl用于命令行或脚本中传输数据。它还用于汽车、电视机、路由器、打印机、音频设备、移动电话、平板电脑、机顶盒、媒体播放器，是成千上万每天影响数十亿人的软件应用的互联网传输中枢（语）。同时，它也可以作为组件（libcurl）在PHP、Python或者WordPress、Git等等软件中使用。
要触发这次提到的两个漏洞，客户端除了要使用有问题的版本以外，还必须支持使用libcurl或者curl来进行代理访问（通过NTLM认证）或者支持通过NTLM验证获取请求。
一般来说，curl的binary默认都是支持NTLM的。使用curl --version 查看，如果包含ntlm，即可以通过curl –ntlm -u
“用户名:密码” 服务器连接远程服务器。
而libcurl则稍稍复杂一点，它需要开发者打开CURLAUTH_NTLM或CURLAUTH_ANY，以表示支持NTLM认证。
图：Git在修改中加入了CURLAUTH_ANY开关，表明支持NTLM认证。
打开开关后要触发NTLM认证， **必须** 通过命令行或cul_setopt指定用户名密码，或者直接在请求的url中指定。例如curl --ntlm
http://用户名:密码@Server/。
NTLM常用于Windows上的身份认证，所以对有Windows机器的内网而言或者代理服务器而言，NTLM出现的频次并不很低。虽然说是身份认证，不过需要注意的是，要触发这次的两个漏洞，来自客户端的身份认证信息并不重要，因为服务器端是被黑客控制的，黑客并不在意客户端发来的是什么，只要按照既定规则发送攻击载荷即可。因此客户端哪怕发来的是错误的验证信息都可以继续触发漏洞。
**黑客唯一需要做的就是，控制一台服务器。因为这是一组由服务器攻击客户端的漏洞。**
**客户端一旦使用有漏洞的curl+NTLM连接到黑客的服务器，黑客就可以攻击客户端程序。**
举一些例子，为了称呼方便，我们在这里统称攻击者为H（Hacker），而被攻击的为V（Victim）。在这些场景下，你可能会和黑客“交手”：
  1. 你从网上随便找了一个公开的代理服务器H，但不幸的是这是一台黑客控制的服务器。然后把你的博客如WordPress配置了使用curl+NTLM代理的方式访问服务器H，则你的博客所在的Apache/PHP进程可能都会受到攻击* 
  2. 你使用了git客户端，配置使用了黑客的代理服务器H，认证过程中就会发生攻击* 
  3. 公司内网中，有一台服务器H被黑，其他服务器V通过curl+NTLM，向这台被黑的服务器发起网络请求时，H可以对这些服务器V进行攻击* 
  4. 你的爬虫程序V使用了libcurl来连接一个远程服务器H，并且V打开了支持所有认证模式的开关，这样H就可以攻击V了* 
诸如此类等等。
前提只有：
  1. 受害者V的客户端使用了有漏洞版本的curl（7.36.0~7.63.0）且支持NTLM； 
  2. 受害者V访问了黑客H控制的服务器，并使用任意账号密码（不正确也无所谓，但是需要提供）发生了NTLM认证流程。 
#### **1.2 关于NTLM认证流程**
再介绍一下NTLM。在Windows网络中，名词NT LAN
Manager(NTLM)表示一种微软的安全协议，该协议可为用户提供身份验证。NTLM是Microsoft LAN
Manager（LANMAN）中的身份验证协议的后继者，这是一种较旧的验证协议。（）。
NTLM的核心认证消息分为三类，三类的消息各不相同，但是名字很直观。它们分别称为Type-1、Type-2、Type-3
Message。其中Type-1类似握手的步骤，Type-2和Type-3则用于服务器和客户端之间的登陆沟通。
使用NTLM认证进行网络请求的过程如下：
    1: C →S GET ... 
    2: C←S HTTP 401 Unauthorized  
    WWW-Authenticate: NTLM  
    3: C →S GET ...  
    Authorization: NTLM   
    4: C←S HTTP 401 Unauthorized  
    WWW-Authenticate: NTLM   
    5: C→S GET ...  
    Authorization: NTLM   
    6: C←S HTTP 200 OK 
即：3~5为实际的认证过程。客户端（C）会发送Type-1消息和Type-3消息给服务器（S），而服务器会发送Type-2消息给客户端。
Type1、2、3三类消息的结果都是由之前消息的内容所计算而来的。
具体可以参考微软的文档：
curl官方已经发布了详细的漏洞通告。因为这两个漏洞的发现和利用仍然有许多有趣而且值得开发人员警醒的地方，所以我决定写一篇writeup来介绍一下漏洞的发现过程和思考。
### ** curl的客户端版“心脏滴血”CVE-2018-16890**
这个漏洞和“心脏滴血”有那么几分相似。虽然“心脏滴血”是泄露服务器上的内存，而curl是泄露客户端上的内存，但是成因、效果上都能看到“心脏滴血”的影子。
这个漏洞位于lib/vauth/ntlm.c: ntlm_decode_type2_target，问题在于处理传入的NTLM
Type-2消息的函数没有正确验证传入数据，最终导致了整数溢出。使用该溢出，恶意的NTLM服务器可以欺骗libcurl接受错误的长度+偏移组合，这将导致缓冲区读取和写入越界。
细节如下：
当用户尝试连接到启用了NTLM的服务器时，服务器将设置`target_info_len (0~0xffff)和target_info_offset
(0~0xffffffff)`来回复Type-2消息。请注意，在Type-2消息中，长度和offset都是可以被设置的。
而这两个值恰巧又都是unsigned long，因此此处的验证并不正确：
如果`target_info_len + target_info_offset = (unsigned long)0x1
00000000`，则结果为零(高位1溢出)，0在这里一定会小于“size”（消息长度）。
要触发整数溢出，target_info_offset的值必须介于0xffff0001~0xffffffff之间，因为它是长整形，这也代表它也一定会大于48。所以这里的两处安全保护全部会被绕过。
从而触发这里的越界读写
#### **2.1 读取越界→绕过ASLR**
我们先说越界读的问题。可以看到这里target_info_offset虽然定义成了无符号数，但是在方括号的数组索引中，它实际上还是有可能会扮演一个有符号数的角色。
  * 当软件是32位的时候，方括号中的数字等价于signed long类型。 
  * 当软件是64位的时候，方括号中的数字等价于signed long long类型。 
先以32位为例，假如offset是0xffffffff，这里memcpy读取到的实际上是buffer[0xffffffff]即buffer[-1]的数据，相当于向前读取了。
而如果是64位程序，则相当于从buffer[0xffffffff]处读取了数据。
数据存放在target_info中，在下一个NTLM Type-3消息返回给服务器时，curl将把这次读取到的内容发送回远程服务器。
根据len +
offset的约束，读取的数据至多可以有64KB大小（0xffff字节），但是可以多次重复触发泄露。每次泄露的位置根据内存分配算法的不同，从而有所不同。因为消息会被base64编码，所以后面的堆数据会原样传递给远程服务器。
通过多次泄露，远程服务器基本可以知道客户端的内存布局。而且，一般情况下可以根据获取到的curl版本以及泄露的堆内容来找到一些可以计算出基址的数据，从而绕过ASLR，为代码执行埋下铺垫。
### ** “可能是长期以来curl里最严重的安全问题”CVE-2019-3822**
Curl的作者在博客中写道，这可能是长期以来curl里最严重的安全问题。这个NTLM
Type-3消息中的栈缓冲区溢出非常有趣。它就是一个非常纯粹、“old-school”（传统）的栈溢出。就是memcpy直接拷贝了超过栈变量长度的数据导致了这个溢出。9102年了，为什么会发生这个问题？其中有几个值得深思的地方。
先介绍一下问题。问题出在`lib/vauth/ntlm.c:Curl_auth_create_ntlm_type3_message()`。创建传出NTLM
Type-3标头的函数基于先前接收的数据生成请求HTTP标头内容。如果从恶意的HTTP服务器提供的先前NTLMv2报头中提取非常大的“nt
response”数据，则输出数据可能比缓冲区大。
“过大的值”需要大约1000字节以上。 复制到目标缓冲区的实际有效负载数据来自NTLMv2 Type 2响应头。
而且，用于防止本地缓冲区溢出的检查的实现是错误的（使用无符号数学运算），因此它不会阻止溢出发生。
细节如下：