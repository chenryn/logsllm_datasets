key SKr.
• Decrypt query with input c: The challenger returns
Decrypt(c, SKr).
1. (P Kr, SKr) $← rKeyGen(λ)
2. (w0, w1, state) $← A(P Kr; sKeyGen1, sKeyGen2,
sKeyGenh, TrapGen1, TrapGen2, Decrypt)
3. b ∈R {0, 1}, cwb = Encrypt(wb, P Kr)
4. b′ $← A(P Kr, state, cwb ; sKeyGen1, sKeyGen2,
sKeyGenh, TrapGen1, TrapGen2, Decrypt)
Figure 1: IND-CCA Security
allowed to query any server’s private key through sKeyReq1,
sKeyReq2, or sKeyReqh. In practice, an outside attacker can
eavesdrop on the transmission of (encrypted) trapdoors, so
that we oﬀer it access to both trapdoor generation oracles
with its own inputs.
Remark 1. To deﬁne the IND-CPA security against an
outside attacker, we only need to disable the Decrypt oracle
in the game shown in Figure 1. In fact, if an ASE†† scheme
is secure under Deﬁnition 3 and Deﬁnition 7 (given below),
then it is automatically IND-CPA secure. Due to the limit
of space, we put the proof of this result in the full version of
this paper.
Against a curious Type-I server S1, in Deﬁnition 3, we de-
ﬁne a ciphertext indistinguishability (CI) security property
similar to the security deﬁnition of PEKS [4].
Informally,
this property says that, given some ciphertexts for which S1
has not obtained the corresponding message-dependent trap-
doors, then it cannot learn anything about the plaintexts.
Definition 3. An ASE†† scheme achieves CI security
against a curious Type-I server S1, if the attacker’s advan-
tage (i.e. | Pr[b′ = b] − 1
2 |) is negligible in the game shown
in Figure 2.
1. (P Kr, SKr) $← rKeyGen(λ)
2. (w0, w1, state) $← A(P Kr; sKeyGen1, sKeyGen2,
sKeyGenh, TrapGen1, TrapGen2, sKeyReq1)
3. b ∈R {0, 1}, cwb = Encrypt(wb, P Kr)
In the following, we present security deﬁnitions with re-
spect to the aforementioned two types of privacy concerns.
4. b′ $← A(P Kr, state, cwb ; sKeyGen1, sKeyGen2,
sKeyGenh, TrapGen1, TrapGen2, sKeyReq1)
3.1 Ciphertext Security Properties
Against an outside attacker, in Deﬁnition 2, we deﬁne
an IND-CCA property similar to the IND-CCA security for
PKE. Informally, the property says that, given some cipher-
texts and various oracle accesses (including decryption ora-
cle), an attacker cannot learn anything about the plaintexts.
Definition 2. An ASE†† scheme is IND-CCA secure against
an outside attacker if the attacker’s advantage (i.e. |P r[b′ =
b] − 1
2 |) is negligible in the game shown in Figure 1.
In the attack game, w0, w1 ∈ W and state is some state
information generated by the attacker. In Phase 4, the at-
tacker is not allowed to query the Decrypt oracle with cwb .
In this game, an outside attacker is modeled since it is not
Figure 2: CI Security against a Type-I Server
In this game, a Type-I server is modeled
In the attack game, w0, w1 ∈ W and state is some state
information generated by the attacker. In step 2 and 4, the
TrapGen1 oracle should have not been queried with (w0, P Ks1 )
or (w1, P Ks1 ).
since the attacker is allowed to obtain SKs1 through a sKeyReq1
query, but has no access to SKs2 or SKsh . The oracle access
to message-dependent trapdoors for any messages except for
w0 and w1 is indeed a big privilege for the attacker. Most ex-
isting IND-CPA secure PKE schemes, such as ElGamal [6],
normally allow some sort of homomorphism, so that they
will not be secure if directly used in constructing an ASE††
scheme. As an example, it is easy to verify that the PKEDS
scheme in [9] is not secure under this deﬁnition.
Against a curious hybrid server Sh, we deﬁne a special CI
security property. Compared with Deﬁnition 2 and Deﬁni-
tion 3, the speciality lies in that the challenger randomly
chooses the challenge messages w0, w1 instead of letting the
attacker do. The rationale is that, for a curious hybrid server
Sh, if it can choose the messages then it can easily tell which
message is encrypted by running the Test2 algorithm.
Definition 4. An ASE†† scheme achieves CI security
against a curious hybrid server Sh, if the attacker’s advan-
tage (i.e. | Pr[b′ = b] − 1
2 |) is negligible in the game shown
in Figure 3.
1. (P Kr, SKr) $← rKeyGen(λ)
2. state $← A(P Kr; sKeyGen1, sKeyGen2, sKeyGenh,
TrapGen1, TrapGen2, sKeyReqh)
3. b ∈R {0, 1}, w0, w1 ∈R W,
cb = (Encrypt(w0, P Kr), Encrypt(wb, P Kr))
4. b′ $← A(P Kr, state, cb; sKeyGen1, sKeyGen2,
sKeyGenh, TrapGen1, TrapGen2, sKeyReqh)
Figure 3: CI Security against a Hybrid Server
In the attack game, state is some state information gener-
ated by the attacker. In this game, a hybrid server is mod-
eled since the attacker is allowed to obtain SKsh through a
sKeyReqh query, but has no access to SKs1 or SKs2 . This
property guarantees that, given some ciphertexts, the at-
tacker can neither recover the plaintexts nor ﬁnd the equality
relationship of the plaintexts. Therefore, it provides much
stronger security guarantee than the standard one-wayness
property used in [9] and the enhanced one-wayness property
by Bellare, Boldyreva and O’Neill [2].
Similarly, we can deﬁne a special CI security property
against a curious Type-II server, as shown in Deﬁnition 5.
It is clear that if an ASE†† scheme is secure under Deﬁnition
4 then it is also secure under Deﬁnition 5.
Definition 5. An ASE†† scheme achieves CI security
against a curious Type-II server S2, if the attacker’s advan-
tage (i.e. | Pr[b′ = b] − 1
2 |) is negligible in the game shown
in Figure 3, where the sKeyReqh oracle is replaced with the
sKeyReq2 oracle.
Remark 2. It is worth noting that the security properties
deﬁned in Deﬁnition 4 and 5 only make sense when the mes-
sage space of the encryption scheme is not polynomial size.
when the message space is polynomial size, the attacker can
perform brute-force attacks. This fact is also true for Deﬁ-
nition 6.
Definition 6. An ASE†† scheme achieves universal trap-
door one-wayness if the attacker’s advantage (i.e. Pr[w =
w′]) is negligible in the game shown in Figure 4. Note that
the output value t in Phase 2 can be either 1, or 2, or h.
1. (P Kr, SKr) $← rKeyGen(λ)
2. (t, state) $← A(P Kr; sKeyGen1, sKeyGen2, sKeyGenh,
TrapGen1, TrapGen2, sKeyReq1, sKeyReq2, sKeyReqh)
3. w ∈R W, tw,st = TrapGen1(w, P Kst , SKr)
4. w′ $← A(P Kr, state, tw,st ; sKeyGen1, sKeyGen2,
sKeyGenh, TrapGen1, TrapGen2, sKeyReq1, sKeyReq2,
sKeyReqh, rKeyReqr)
Figure 4: Universal Trapdoor One-wayness
To further strengthen the universal trapdoor one-wayness
property, in Deﬁnition 7, we deﬁne the message-dependent
trapdoor indistinguishability property. Informally, the prop-
erty guarantees that, for the Type-I server S1 or the hy-
brid server Sh, no other entity can learn anything about
the messages encoded in message-dependent trapdoors gen-
erated under its public key.
Definition 7. An ASE†† scheme achieves trapdoor in-
| Pr[b′ =
distinguishability if the attacker’s advantage (i.e.
b] − 1
2 |) is negligible in the game shown in Figure 5.
1. (P Kr, SKr) $← rKeyGen(λ)
2. (w0, w1, t, state) $← A(P Kr; sKeyGen1, sKeyGen2,
sKeyGenh, TrapGen1, TrapGen2, sKeyReqt′ , sKeyReq2)
3. b ∈R {0, 1}, twb = TrapGen1(wb, P Kst , SKr)
4. b′ $← A(P Kr, state, twb ; sKeyGen1, sKeyGen2, sKeyGenh,
TrapGen1, TrapGen2, sKeyReqt′ , sKeyReq2, rKeyReqr)
Figure 5: Trapdoor Indistinguishability
In the attack game, w0, w1 ∈ W, the values t, t′ are chosen
(by the attacker) from {1, h} and t 6= t′, and state is some
state information generated by the attacker. This guaran-
tees that sKeyReqt is not queried in the game. We allow the
attacker to request the receiver’s private key in Phase 2 and
all servers’ private keys except for SKst .
It captures our
intention that, even if the receiver’s private key is leaked or
compromised, then the attacker still cannot ﬁgure out what
the receiver has searched for. This is similar to the forward
secrecy property in key establishment protocols.
3.2 Trapdoor Security Properties
4.
IND-CCA SECURE ASE††
In Deﬁnition 6, we deﬁne the universal trapdoor one-
wayness property. The property guarantees that no entity
can recover the message encoded in a message-dependent
trapdoor. Note that this will require the message space W
not to be polynomial size. In the attack game, an outside at-
tacker and various servers are modeled because the attacker
can obtain the private keys (SKs1 , SKs2 , SKsh ) through the
key request oracles (sKeyReq1, sKeyReq2, sKeyReqh).
In this section, we ﬁrst brieﬂy mention some attempts, and
then describe a novel ASE†† scheme and analyse its security
properties in our security model.
4.1 Some Attempts
To construct an ASE†† scheme, a very natural direction
is to follow the hybrid method used in [16]. Generically, the
data owner can have two key pairs (pk1, sk1) and (pk2, sk2),
and the ciphertext of a message m is in the form of c =
(c1, c2) = (Encrypt1(m, pk1), Encrypt2(m, pk2)), where c1 can
be used for decryption and c2 can be used for search. With
this methodology, the diﬃculty lies in that we need to pro-
vide a knowledge proof that c1 and c2 contain the same mes-
sage in order to achieve the soundness property. Moreover,
how to generate master trapdoors and message-dependent
trapdoors is not a straightforward task either. It remains as
an open problem to have a generic construction for ASE††.
Instead of a generic construction, we may follow the semi-
hybrid method in [14]: use a standard PKE scheme as a
main component and employ a key-private IBE scheme to
facilitate trapdoor constructions.
In order to achieve the
soundness property, we still need to provide a knowledge
proof to guarantee that the decryption and the test func-
tions are consistent with each other (note that the scheme
in [14] does not satisfy the third requirement in Deﬁnition
1). Moreover, it is also an interesting future work to improve
this scheme to achieve IND-CCA security.
4.2 Proposed Scheme and its Soundness
In the proposed scheme, the intuition behind the Encrypt
algorithm is that a message is protected by two layers of en-
cryption (see the element c2). The ﬁrst layer of encryption
makes use of a hash value of the message and can only be
removed by the receiver, while the second layer makes use of
a hash value of the message and a bilinear pairing technique
and it can only be removed with an appropriate message-
dependent trapdoor or a master trapdoor. The search al-
gorithms (Test1 and Test2) are made possible by employing
the bilinear property of pairings.
• sKeyGen(λ): It generates a key pair (P Ks, SKs) for
a standard PKE scheme (KeyGen′, Encrypt′, Decrypt′),
which has the message space M.
• rKeyGen(λ): It generates (P Kr, SKr) as follows.
1. Generate the pairing parameters: group G of prime
order p, a bilinear map ˆe: G × G → GT , randomly
chosen generators g1 and g2 of G.
2. Select a symmetric key encryption scheme (Enc, Dec)
whose key space is M, and select three hash func-
tions: H1 : GT → G, H2 : G → G, and H3 :
{0, 1}∗ → {0, 1}λ.
3. Select x1, x2 ∈R Zp and generate the receiver’s
1 , gx2
2 )
key pair (P Kr, SKr) where P Kr = (gx1
and SKr = (x1, x2).
Besides P Kr, the pairing parameters (G, GT , ˆe, p, g1, g2),
symmetric key encryption scheme (Enc, Dec), and hash
functions H1, H2, and H3 should be made public. The
receiver’s message space W is G.
• Encrypt(w, P Kr): It selects r1, r2 ∈R Zp and generates
a ciphertext cw = (c1, c2, c3, c4, c5) as follows.
c1 = gr1
1 , c2 = H1(ˆe(gx1
1 , H2(w)r1 )) · H2(w)r1 · w,
c3 = gr2
2 , c4 = gx2r2
2
· H2(w)r1 ,
c5 = H3(c1||c2||c3||c4||H2(w)||ˆe(gx1
1 , H2(w)r1 )).
• Decrypt(cw, SKr): It parses cw as (c1, c2, c3, c4, c5) and
, and outputs w if the
computes w =
c2
c4
x2
c
3
following equalities hold.
H1(ˆe(g
x1
1 ,
))·
c4
x2
c
3
ˆe(c1, H2(w)) = ˆe(g1,
c4
cx2
3
))
c5 = H3(c1||c2||c3||c4||H2(w)||ˆe(gx1
1 ,
c4
cx2
3
))
If either equality does not hold, the algorithm outputs
an error symbol ⊥.
• TrapGen1(w, P Ks, SKr): It selects y ∈R Zp and com-
putes the message-dependent trapdoor tw,s = (v7, v8)
as follows.
v0 = H2(w)x1y, v1 = H2(w)x1 , v2 = ˆe(gx1y
1
, w−1),
v3 = gx1y
1
, v4 = gx1x2y
1
, v5 = H2(w),
k1 ∈R M, v7 = Enc(v0||v1||v2||v3||v4||v5, k1),
v8 = Encrypt′(k1, P Ks).
• Test1(c, tw,s, SKs): It performs as follows.
1. Parse c as (c′
1, c′
2, c′
3, c′
4, c′
5) and tw,s as (v7, v8).
2. Decrypt v8 to obtain k1 and decrypt v7 to recover
v0, v1, v2, v3, v4, v5.
3. Output 1 if the following equalities hold, and out-
put 0 otherwise.
ˆe(v3, c′
ˆe(v4, c′
4)
3)
= v2 · ˆe(v3,
c′
2
H1(ˆe(c′
1, v1))
) = ˆe(c′
1, v0) (1)
c′
5 = H3(c′
1||c′
2||c′
3||c′
4||v5||ˆe(c′
1, v1))
(2)
• TrapGen2(P Ks, SKr): It generates a master trapdoor
t∗,s = (u1, u2), where z ∈R Zp, k2 ∈R M,
u1 = Enc(x1||gz
1 ||gx2·z
1
, k2), u2 = Encrypt′(k2, P Ks).
• Test2(c, w, t∗,s, SKs): It performs as follows.
1. Parse c as (c′
1, c′
2, c′
3, c′
4, c′
5) and t∗,s as (u1, u2).
2. Decrypt u2 to obtain k2 and decrypt u1 to recover
(x1, gz
1 , gx2·z
1
).
3. Output 1 if the following equalities hold, and out-
put 0 otherwise.
ˆe(gz
1 ,
c′
4
c′
2
H1(ˆe(c′
1 ,H2(w)x1 ))·w
) = ˆe(gx2·z
1
, c′
3)
(3)
ˆe(g1,
c′
2
H1(ˆe(c′
1, H2(w)x1 )) · w
) = ˆe(c′
1, H2(w))
(4)
c′
5 = H3(α||H2(w)||ˆe(c′
1, H2(w)x1 )),
(5)
where α = c′
1||c′
2||c′
3||c′
4.
Remark 3. The element c5 in the ciphertext is solely for
the purpose of achieving IND-CCA security against an out-
side attacker. To achieve IND-CPA security against an out-
side attacker and preserve all other security properties, we
can eliminate c5 in Encrypt, the veriﬁcation of c5 in Decrypt,
the veriﬁcations of c′
5 in Test1 and Test2 in the above scheme.
Moreover, the element v5 in TrapGen1 can also be eliminated.
Due to the limit of space, we put the proof of this simpliﬁed
scheme in the full version of this paper.
Theorem 1. The proposed ASE†† scheme is sound ac-
cording to Deﬁnition 1.