title:PartiSan: Fast and Flexible Sanitization via Run-Time Partitioning
author:Julian Lettner and
Dokyung Song and
Taemin Park and
Per Larsen and
Stijn Volckaert and
Michael Franz
PartiSan: Fast and Flexible Sanitization
via Run-Time Partitioning
Julian Lettner(B)
, Dokyung Song, Taemin Park, Per Larsen, Stijn Volckaert,
and Michael Franz
{jlettner,dokyungs,tmpark,perl,stijnv,franz}@uci.edu
University of California, Irvine, USA
Abstract. Sanitizers can detect security vulnerabilities in C/C++ code
that elude static analysis. Current practice is to continuously fuzz and
sanitize internal pre-release builds. Sanitization-enabled builds are rarely
released publicly. This is in large part due to the high memory and pro-
cessing requirements of sanitizers.
We present PartiSan, a run-time partitioning technique that speeds
up sanitizers and allows them to be used in a more ﬂexible manner. Our
core idea is to partition the execution into sanitized slices that incur a
run-time overhead, and “unsanitized” slices running at full speed. With
PartiSan, sanitization is no longer an all-or-nothing proposition. A single
build can be distributed to every user regardless of their willingness to
enable sanitization and the capabilities of their host system. PartiSan
enables application developers to deﬁne their own sanitization policies.
Such policies can automatically adjust the amount of sanitization to ﬁt
within a performance budget or disable sanitization if the host lacks
suﬃcient resources. The ﬂexibility aﬀorded by run-time partitioning also
means that we can alternate between diﬀerent types of sanitizers dynam-
ically; today, developers have to pick a single type of sanitizer ahead of
time. Finally, we show that run-time partitioning can speed up fuzzing by
running the sanitized partition only when the fuzzer discovers an input
that causes a crash or uncovers new execution paths.
Keywords: Security · Privacy · Software security
Application security
1 Introduction
Although modern, safe languages could gradually replace C/C++, the sheer
amount of legacy systems code forces security researchers to search for and ﬁx
memory corruption vulnerabilities in existing code in the near term. While some
bugs can be found through static program analysis, many cannot. Sanitizers
are dynamic analysis tools that can detect memory corruption and many other
problems as well as pinpoint their occurrence during program execution [13,16,
19]. To increase coverage, sanitizer runs can be driven by a fuzzer. A fuzzer simply
c(cid:2) Springer Nature Switzerland AG 2018
M. Bailey et al. (Eds.): RAID 2018, LNCS 11050, pp. 403–422, 2018.
https://doi.org/10.1007/978-3-030-00470-5_19
404
J. Lettner et al.
feeds the program random inputs and records inputs that generate crashes or
cause previously unexecuted code to run.
Sanitizers instrument programs—usually during compilation—to detect
issues such as memory corruption and undeﬁned behavior. This instrumenta-
tion incurs signiﬁcant overheads, so sanitizers are turned oﬀ in release builds
and traditionally only enabled on internal quality assurance builds that run on
high-end hardware. This is less than ideal as the number of paths executed by
test suites and fuzzers is outnumbered by the number of paths executed by end
users.
In a recent experiment, the Tor Project released sanitizer-enabled (labeled
“hardened”) builds directly to its users [8]. The hardened build series was discon-
tinued in part due to the high performance overhead and in part due to confusion
among end users over which version to download. With access to PartiSan, the
Tor Project developers could have released builds that automatically adapt the
level of sanitization to the capabilities of the host system. Overhead can be lim-
ited by using a conservatively low, adaptive threshold by default (and possibly
disabling sanitization completely on underpowered systems) while simultane-
ously allowing expert users to modify the default settings (thereby also elimi-
nating the need for multiple build versions).
PartiSan clones frequently executed functions at compile time and eﬃciently
switches among them at run time. Each function variant can be optimized and
sanitized independently, and thus has diﬀerent security and performance proper-
ties. In the simplest case, one variant is instrumented to sanitize memory accesses
while the other one is not. PartiSan supports conﬁgurable run-time partition-
ing policies that determine which variant is invoked when a function is called.
For example, PartiSan can execute slow variants (e.g., variants with expensive
checks) with low probability on frequently executed code paths, and with high
probability on rarely executed paths. This policy helps us keep the sanitization
overhead below a given threshold.
This is superﬁcially similar to the ASAP framework by Wagner et al. [22]
insofar that both approaches explore the idea of reducing the amount of san-
itization on the hot path. However, ASAP statically partitions the code into
parts with or without sanitization based on previous proﬁling runs at compile
time. PartiSan prepares programs for partitioning at compile time but does the
partitioning dynamically at run time. This allows us to produce a single binary
that adapts to each individual host system, sanitizing as many paths as possible
under a given performance budget. Moreover, we can create N diﬀerent func-
tion variants to support N − 1 types of sanitization in a single binary. Table 1
contrasts PartiSan and ASAP. Both our work and ASAP build on the assump-
tion that security vulnerabilities in frequently executed code get discovered and
patched relatively quickly, whereas vulnerabilities in rarely executed code might
go unpatched for a long time.
PartiSan: Fast and Flexible Sanitization via Run-Time Partitioning
405
Table 1. Conceptual comparison of ASAP and PartiSan
Statement
Goal . . .
ASAP
PartiSan
Deploy sanitizers as mitigations Find bugs eﬃciently
Partitioning is . . .
Static (compile time)
Dynamic (run time)
Overhead reduction . . .
Removal of expensive checks
Probabilistic checking
Code is . . .
Assertions are . . .
Deleted
Removed
Detect bugs in cold code . . . Always
Detect bugs in hot code . . . Never
Cloned
Retained
Always
Probabilistically
This paper makes the following contributions:
– We describe PartiSan1, a framework to partition program execution into san-
itized/unsanitized fragments at run time. Unlike previous approaches, the
partitioning is not static but happens dynamically according to a policy-
driven, run-time partitioning mechanism which selects the function variant
to execute with low overhead. This lets developers release sanitizer-enabled
builds to end users and thereby cover more execution paths.
– We present a fully-ﬂedged prototype implementation of our ideas and explore
three concrete run-time partitioning policies. We combined PartiSan with two
sanitizers and measured the performance overhead on the SPEC CPU 2006
benchmark suite with our expected-cost partitioning policy.
– We present a thorough evaluation showing that our approach still detects the
majority of vulnerabilities at greatly reduced performance overheads. For the
popular ASan and UBSan sanitizers, PartiSan reduces overheads by 68% and
76% respectively.
– We demonstrate an important use case of PartiSan: improving fuzzing eﬃ-
ciency. We combined PartiSan with a popular fuzzer and measured consis-
tently increased fuzzing throughput.
2 Background
LLVM [10], the premier open-source compiler, includes ﬁve diﬀerent sanitizers.
We demonstrate PartiSan by applying two of these sanitizers to a variety of
programs. ASan, short for AddressSanitizer [16], instruments memory accesses
and allocation operations to detect a range of memory errors, including spatial
memory errors such as out-of-bounds accesses and temporal violations such as
use-after-free bugs. UBSan, short for UndeﬁnedBehaviorSanitizer [13], currently
detects 22 types of operations whose semantics are undeﬁned [12] by the C
1 PartiSan is available upon request. Please contact the authors for a copy of the
research artifacts.
406
J. Lettner et al.
Compiler
Analyze module
Create variants
Create variant pointer array
Create trampolines
Transform call sites
Emit metadata
1
2
3
4
5
6
 Binary
Function Variant Set 0
Function Variant Set 1
Common
Functions
Function Variant Set n
PartiSan
Metadata
PartiSan
Runtime
 Process
Main Program
Function bar
Function foo
CALL  &baz
CALL   bar
Variant baz0
Variant baz1
PartiSan
Data
Variant
Pointer
Array
Metadata
PartiSan
Partitioning
Thread
#include 
Source 
Code
int main()
{
  std::cout << 
"Hello World!";
}
Data
{
}
Fig. 1. System overview. The compiler (left) creates PartiSan-enabled applications
(center) that have multiple variants of each function. A run-time indirection through
the variant pointer array (right) ensures that the control ﬂow calls the currently active
variant. PartiSan’s runtime periodically activates function variants according to the
conﬁgured partitioning policy.
standard [6]. UBSan includes checks for integer overﬂows, uses of uninitialized
or unaligned pointers, and undeﬁned integer shifts.
We used these sanitizers with PartiSan for two reasons. First, the combina-
tion of ASan and UBSan detects many of the vulnerabilities that are security
critical. Second, both sanitizers can be applied selectively.2 Removing any of the
sanitization checks from a program does not aﬀect the correct functioning of the
remaining checks. This makes these sanitizers a good ﬁt for our framework, in
which we selectively skip sanitization through run-time partitioning.
3 Design
Our goal is to reduce the run-time overhead of the sanitizers. We do this by creat-
ing multiple variants of each function, applying sanitizers to some variants, and
embedding a runtime component that partitions the execution of the program
into sanitized/unsanitized slices based on a policy.
Figure 1 shows an overview of the PartiSan system. To apply PartiSan to an
application, the developer must compile the source code of the program with our
modiﬁed compiler (left side of Fig. 1). Some partitioning policies require that the
developer supply proﬁle data.
The compiler generates an application with multiple variants for each func-
tion. To simplify the following discussion, we will focus on use cases where we
generate two variants. One of the variants, which we refer to as the unsanitized
variant, does not include any sanitizer checks. The other variant, which we call
the sanitized variant, incorporates all sanitizer instrumentation.
2 Note that ASan requires metadata to execute checks. The maintenance of this meta-
data constitutes residual overhead which cannot be removed.
PartiSan: Fast and Flexible Sanitization via Run-Time Partitioning
407
The compiler modiﬁes the program’s control ﬂow as follows. Rather than
calling functions directly, the functions call each other through an additional
level of indirection. Speciﬁcally, the compiler embeds a “variant pointer array”
containing one slot for each function in the program source code. At run time,
each slot holds the pointer to the currently active variant of the corresponding
function. The PartiSan runtime, which is linked into the application by our
compiler, selects and activates one variant of each function according to the
conﬁgured partitioning policy.
The runtime currently supports three partitioning policies: random parti-
tioning, proﬁle-guided partitioning, and expected-cost partitioning. With the
random partitioning policy, the runtime randomly selects the active variants,
whereas the proﬁle-guided and expected-cost partitioning policies select active