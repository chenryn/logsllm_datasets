cently proposed the use of simulated honey routers to study
protocol attacks against BGP [10].
In general, honeypots can be native, emulated or simu-
lated, and can involve a single machine or a vast network of
simulated nodes. Many oﬀ-the-shelf honeypot systems exist
for general purpose computers. However, such systems are
not without ﬂaws. For example, simulated honeypots dis-
guises themselves as vulnerable systems but does not expose
any actual vulnerabilities to the attacker. Therefore, min-
imizing false-positives in such systems is a challenge. Fur-
thermore, simulated honeypots may catch indiscriminate ex-
ploitation attempts, but will rarely fool sophisticated attack-
ers in highly targeted attacks. Thus, native and emulated
honeypots which exposes real vulnerabilities to the attacker
are much better suited for detecting sophisticated, targeted
attacks.
Guards, originally proposed by Chang and Atallah [6], is
another technology which uses mechanisms of action similar
to Symbiotes. A Guard is a simple piece of security code
which is injected into the protected software using binary
rewriting techniques similar to our Symbiote system. Once
injected, a guard will perform tamper-resistance function-
ality like self-checksumming and software repair. However,
Guards have no mechanism to pause and resume its com-
putation, the entire Guard routine must complete execution
each time it is invoked. This limits the sophistication of
what each Guard can realistically perform, especially when
Guards are used in time sensitive software and real-time em-
bedded devices.
Devices like Cisco routers are black-box systems utiliz-
ing large numbers of undocumented proprietary hardware
components. The injection of new code into proprietary
ﬁrmware and the emulation of specialized and undocumented
hardware makes the creation native and emulated honeypots
for embedded devices challenging. As Section 5 describes,
the unique capabilities of the Symbiote construct allows us
to overcome the above challenges in order to transform stan-
dard Cisco IOS ﬁrmware and hardware into highly believable
native router honeypots.
5. MEET SYMBIOTE
For a full discussion of Symbiotic Embedded Machines,
please see [9]. The Symbiote is a software construct that is
injected in situ into a host program to provide the following
four fundamental security properties.
1. The Symbiote has full visibility into the code and ex-
ecution state of its host program, and can either pas-
sively monitor or actively react to the observed events
at runtime.
2. The Symbiote executes along side the host software.
In order for the host to function as before, it’s injected
Symbiote must execute, and vice versa.
3. The Symbiote is an autonomous entity which is hard-
ened to defend against unauthorized modiﬁcation or
removal once it is injected into the host program.
4. No two instantiations of the same Symbiote are the
same. Each time a Symbiote is created, its code is
randomized and mutated, rendering signature based
detection methods and attacks requiring predictable
memory and code structures within the Symbiote in-
eﬀective.
Figure 2: Symbiote Injection Process.
Figure 1 shows the three logical components of Symbiotes:
Control-Flow Interceptors, Symbiotic Embedded Machine
Manager (SEMM) and the Symbiote Payload. Together,
all three components are injected in situ into the target em-
bedded device ﬁrmware. Since the Symbiote is injected in
situ, the size of the resulting ﬁrmware image is unchanged.
For example, the current implementation of the Symbiote
Manager, along with the rootkit detection payload requires
only approximately 1600 bytes to be injected into IOS.
Figure 2 illustrates the three step Symbiote injection pro-
cess. First, analysis is performed on the original host pro-
gram in order to determine areas of live code, or code that
will be run with high probability at runtime. Second, in-
tercept points are chosen randomly from the host program.
Lastly, the Symbiote Manager, Symbiote payload and a large
number of control-ﬂow intercepts are injected into the host
program binary, yielding a Symbiote protected host pro-
gram.
The Symbiote randomly intercepts a large number of func-
tions as a means to divert periodically and consistently a
small portion of the device’s CPU cycles to execute its pay-
load. This approach allows the Symbiote to remain agnos-
tic to operating system speciﬁcs while executing its payload
alongside the original OS. The Symbiote payload has full ac-
cess to the internals of the original OS but is not constrained
by it. This allows the payload to carry out functionality
which might not be possible under the original OS. In the
case of Cisco IOS for example, a process watchdog timer will
forcibly terminate any process which executes for more than
several seconds. However, since the Symbiote payload exe-
cutes in time-slices randomly distributed throughout many
unrelated processes, the Symbiote payload can execute in-
deﬁnitely, circumventing the watchdog timer entirely.
Stealth is a byproduct of the SEM structure. In the case
of IOS, no diagnostic tool available within the OS (short of
a full memory dump) can detect the presence of the SEM
payload because it manipulates no OS speciﬁc structure and
is eﬀectively invisible to the OS. The impact of the SEM
payload is further hidden by the fact that CPU utilization of
the payload is not reported within any single process under
IOS and is distributed randomly across a large number of
unrelated processes.
Once the Symbiote Manager gains control of the CPU, it
allocates a certain number of cycles for the execution of its
Symbiote payload (in this case, a checksuming mechanism).
After the payload completes its execution burst, control of
the CPU is returned to the Symbiote Manager, which in
turn resumes the execution of the original host program.
The Symbiote Manager acts as a job scheduler, treating
the entire host program as one process, and its Symbiote
payload as the other. Traditional scheduling strategies can
be used to determine the proper CPU resource distribution
between the Symbiote and its host program. In general, this
involves the optimization of both the frequency of context
switches as well as the duration of the Symbiote payload’s
execution bursts.
The proposed Symbiote payload detects unauthorized code
modiﬁcation through the computation of checksums over
static regions of memory. Therefore, a delay exists between
the time of the code modiﬁcation and its detection. In gen-
eral we refer to the time between the occurrence of an unau-
thorized event and its detection as the detection latency.
Intuitively, the amount of CPU resources diverted to the
Symbiote payload should be inversely proportional to the
detection latency, and thus directly proportional to the per-
formance of our detector.
In the case of Cisco IOS, and
Host Program= Live Code= Intercept PointHost ProgramHost Program= Symbiote BinaryOriginal Unmodiﬁed Host Program BinaryLive Code Found Through Static Analysis or ProﬁlingSymbiote Binary Injected into Host Program. Live Code is Randomly Intercepted123many other embedded systems, an over allocation of CPU
resources to the Symbiote can adversely aﬀect the perfor-
mance of the protected host device.
In practice, we have
found that it is beneﬁcial to frequently interleave the host
program’s execution with short Symbiote payload execution
bursts. This allows the Symbiote payload to compute at ac-
ceptable rates while minimizing the impact on the real-time
nature of Cisco routers.
The Symbiote scheduling problem is arguably simple as
it involves only two ”tasks”. However, performing such a
task safely in an OS agnostic manner on embedded systems
presents several interesting complexities. A full discussion of
potential Symbiote scheduling algorithms is out of the scope
of this paper. However, in the case of our IOS exploitation
detection Symbiote, the performance and overhead charac-
teristics of several scheduling strategies are discussed in Sec-
tion 9.
6. SELF-MONITORING SYMBIOTES
We must consider ways to protect the Symbiote itself
against attack and removal. The polymorphic nature of
the Symbiote and its payload makes signature-based attacks
against it ineﬀective. To further raise the bar, multiple Sym-
biotes within a protected host program can be conﬁgured
in a self-monitoring monitor arrangement. As proposed by
Stolfo, Greenbaum and Sethumadhavan [21], a network of
monitors can be constructed, such that an alarm will be
raised if any subset of monitors are compromised or deacti-
vated, or if any critical condition monitored by the system
is violated. Consider Figure 3, which shows three indepen-
dent Symbiotes arranged in a full-mesh monitoring network.
In this arrangement, each Symbiote monitors a speciﬁc crit-
ical condition, i.e., the output of their Symbiote Payload,
while simultaneously monitoring the operational status of
the other two Symbiotes within the network. If one or more
of the Symbiotes are corrupted or disabled, the remaining
Symbiotes within the network will raise an alarm. Similarly,
if all three Symbiotes are simultaneously deactivated, an ex-
ternal sensor can also detect this event and raise an alarm.
Note that the three Symbiotes shown in Figure 3 need not be
located within the same host router. Large networks of em-
bedded device sensors can be collectively protected in this
mutually defensive arrangement. Using Symbiotes in this
fashion is a topic of ongoing research.
7. EXPLOITATION DETECTOR
IOS rootkit and malware code is generally not publicly
available. However, a survey of published persistent rootkit
techniques reveals a commonality in their modus operandi.
Speciﬁcally, rootkits such as [16, 13, 7] all modify some re-
gion of static IOS memory in order to inject their rootkit
payload into the victim router. Thus, we implemented a
white-list strategy to detect IOS malcode and rootkits de-
scribed previously.
Known rootkits operate by hooking into and altering key
functions within IOS. To do this, speciﬁc binary patches
must be made to executable code. Therefore, a continuous
integrity check on all static areas of Cisco IOS will detect
all function hooking and patching attempts made by rootk-
its and malware. The rootkit detection payload described
below is not speciﬁc to IOS, and can be used on other em-
bedded operating systems as well. As Section 9 shows, our
Symbiote payload accurately detects unauthorized modiﬁca-
tion of any monitored region of memory within milliseconds,
and will accurately detect [16, 13, 7] immediately after suc-
cessful exploitation of the victim device.
In the case of Cisco IOS, several large contiguous segments
of the router’s memory address space can be monitored using
the checksumming mechanism described above. Figure 4 il-
lustrates the memory layout of a typical IOS ﬁrmware image
on a Cisco router. The darkened regions represent areas of
the router’s ﬁrmware which can be safely monitored by our
checksumming mechanism. For example, regions containing
executable code (text and ﬁrmware), and static data (ro-
data, ctors, sdata sections) should clearly not be modiﬁed at
runtime. In practice, the typical IOS ﬁrmware contains large
contiguous sections of memory which should semantically re-
main static during the normal operation of the router.
8. DESIGN AND OPERATION
Our sensor system has three components; a Symbiote-
protected router, a monitoring station, and a capture and
analysis system which automatically collects and analyzes
forensics data once an alarm is triggered. The Symbiote
within the IOS ﬁrmware simultaneously performs checksums
on all protected regions of the router’s memory while period-
ically communicating with an external monitor via a covert
channel. In the event of an unauthorized memory modiﬁca-
tion within the router, the Symbiote will raise an alarm to
the monitor, which then triggers the capture and analysis
component of our system.
The proposed exploitation detection sensor can be de-
ployed in one of at least three ways; natively, emulated
within a general purpose computer, or as a shadow replica
for a production device. The implementation of the moni-
toring station and capture and analysis engine changes de-
pending on how the Symbiote-injected router ﬁrmware is
executed; natively on embedded hardware or emulated on a
general purpose computer.
When deployed natively, the monitor and capture compo-
nents are integrated into the Symbiote payload and injected
directly into Cisco hardware, producing a standalone sen-
sor. When the detection payload raises an alarm, the Sym-
biote immediately triggers the core dump functionality from
within IOS. This causes the bulk of the router’s execution
state to be captured and transferred via FTP or TFTP.
When deployed as an emulated sensor, using Dynamips
for example, the monitoring and capture components of the
sensor are implemented within the emulator. This reduces
the footprint of the Symbiote and allows us to perform more
sophisticated capture and analysis on the server running the
emulation. For example, Dynamips was modiﬁed to contin-
uously monitor a region of the router’s memory for an en-
coded marker, which is set by the Symbiote payload only
when an alarm is raised.
For testing purposes, we chose to modify a portion of the
text that is printed when the ”show version” command is
invoked.
In practice, many better covert channels can be
used to communicate between the Symbiote and the router
emulator.
In order to transform large populations of embedded de-
vices into massive embedded exploitation sensor-grids, the
native deployment is the most eﬃcient and practical. For the
purposes of testing and validation of our approach, the emu-
lated deployment scenario is most appropriate. The shadow
Figure 3: Full Mesh Self-Monitoring Symbiote
Network
Figure 4: Memory layout of a typical Cisco IOS
router
deployment is best for capturing and analyzing IOS exploits
in mission critical production environments.
8.1 Native Sensor Deployment
In the native deployment scenarios, the Symbiote-injected
ﬁrmware is loaded directly onto the target embedded device,
i.e. a Cisco router. The Symbiote payload executes natively
on the embedded hardware, alongside the original ﬁrmware.
Native deployment allows the Symbiote to operate in em-
bedded systems for which emulation is not feasible. For ex-
ample, a large portion of Cisco devices can not be emulated
by existing software due to the use of undocumented, propri-
etary hardware. In practice, most modern high-performance
networking equipment falls within this category. Therefore,
native deployment is most practical for injecting Symbiotic
defenses into the diverse range of embedded devices found
on the Internet substrate.
8.2 Emulated Sensor Deployment
Figure 5: Emulated Deployment of Symbiote-based
Cisco IOS Detector
Figure 5 illustrates a typical emulated deployment of our
sensor. Instead of running the Symbiote-injected ﬁrmware
natively on embedded hardware, the ﬁrmware is emulated
on a general purpose computer. In the case of Cisco IOS,
Dynamips is used to emulate speciﬁc devices such as 7200 se-
ries routers used in our testing and evaluation environment.
This diﬀers from simulated honeypots in a signiﬁcant way:
the use of actual IOS ﬁrmware. The emulation of real Cisco
IOS allows us to create highly interactive honeypots which
exposes real IOS vulnerabilities to potential attackers.
The emulated deployment has several advantages which
make it the ideal approach for developing and testing ex-
perimental prototype Symbiotes. First, debugging proof of
concept Symbiotes in an emulated environment is slightly
more convenient than doing so on native embedded hard-
ware. Second, the general purpose computer which hosts
the emulation usually has far greater computational capacity
than the embedded hardware which it is emulating. There-
fore, computation can be oﬄoaded from the Symbiote pay-
load onto the general purpose host computer. This can
potentially allow the Symbiote payload to perform com-
plex computations not feasible on actual embedded hard-
ware. The Symbiote payload presented in this paper is sim-
ple and requires relatively little CPU power. However, this
can be replaced with payloads more akin to behavior based
anomaly detectors which can require signiﬁcantly more re-
sources. The development of Symbiote-based anomaly de-
tection mechanisms is an area of active research (See Section
10).
Lastly, the emulated sensor deployment can usually sim-
plify the capture and analysis component of the sensor. In
the case of the sensor presented in this paper, we modi-
ﬁed the Dynamips emulator to atomically capture the entire
memory state of the IOS router once the Symbiote payload
emits an alarm. The Dynamips emulator conveniently al-
lows us to halt the router’s CPU brieﬂy while the memory
capture takes place on the host computer. Once this opera-
tion completes, the memory snapshot, along with all network
.text.rodatafirmware.eh_frame.data.ctors.sdata.sbss.bss= Static Regions0x800080000x84669060Symbiote ProtectedRouter (Emulated)Internal MonitoringProcessNetworkCapture and AnalysisEngineGeneral Purpose Servertraﬃc received by the router is automatically processed and
archived for analysis. Once the Symbiote payload emits an
alarm, our modiﬁed Dynamips emulator continuously dumps
the memory state of the router at a conﬁgurable frequency.
8.3 Shadow Sensor Deployment
Figure 6: Shadow Deployment of Symbiote-based
Cisco IOS Detector
In order to detect exploitation against high-performance
embedded devices within production environments, we must
be able to deploy Symbiote-based sensors in a way which will
not cause unintentional service outages on the monitored de-
vices. In such cases, the use of a second, identical embedded
device as a shadow sensor is most appropriate. Figure 6