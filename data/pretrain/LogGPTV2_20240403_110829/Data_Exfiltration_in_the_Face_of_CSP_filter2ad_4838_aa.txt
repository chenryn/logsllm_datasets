title:Data Exfiltration in the Face of CSP
author:Steven Van Acker and
Daniel Hausknecht and
Andrei Sabelfeld
Data Exﬁltration in the Face of CSP
Steven Van Acker
Daniel Hausknecht
Chalmers University of Technology
Andrei Sabelfeld
ABSTRACT
Cross-site scripting (XSS) attacks keep plaguing the Web.
Supported by most modern browsers, Content Security Pol-
icy (CSP) prescribes the browser to restrict the features and
communication capabilities of code on a web page, mitigat-
ing the eﬀects of XSS. This paper puts a spotlight on the
problem of data exﬁltration in the face of CSP. We bring at-
tention to the unsettling discord in the security community
about the very goals of CSP when it comes to preventing
data leaks. As consequences of this discord, we report on
insecurities in the known protection mechanisms that are
based on assumptions about CSP that turn out not to hold
in practice. To illustrate the practical impact of the discord,
we perform a systematic case study of data exﬁltration via
DNS prefetching and resource prefetching in the face of CSP.
Our study of the popular browsers demonstrates that it is
often possible to exﬁltrate data by both resource prefetching
and DNS prefetching in the face of CSP. Further, we per-
form a crawl of the top 10,000 Alexa domains to report on
the cohabitance of CSP and prefetching in practice. Finally,
we discuss directions to control data exﬁltration and, for the
case study, propose measures ranging from immediate ﬁxes
for the clients to prefetching-aware extensions of CSP.
CCS Concepts
•Security and privacy → Browser security; Web pro-
tocol security; Web application security;
Keywords
content-security-policy; data exﬁltration; DNS prefetching;
resource prefetching; large-scale study; web browser
1.
INTRODUCTION
Cross-Site Scripting (XSS) attacks keep plaguing the Web.
According to the OWASP Top 10 of 2013 [36], content in-
jection ﬂaws and XSS ﬂaws are two of the most common
security risks found in web applications. While XSS can
be used to compromise both conﬁdentiality and integrity of
web applications, the focus of this paper is on conﬁdentiality.
The goal is protecting such sensitive information as personal
data, cookies, session tokens, and capability-bearing URLs,
from being exﬁltrated to the attacker by injected code.
XSS in a nutshell XSS to break conﬁdentiality consists
of two basic ingredients: injection and exﬁltration. The fol-
lowing snippet illustrates the result of a typical XSS attack:
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full cita-
tion on the ﬁrst page. Copyrights for components of this work owned by others than
ACM must be honored. Abstracting with credit is permitted. To copy otherwise, or re-
publish, to post on servers or to redistribute to lists, requires prior speciﬁc permission
and/or a fee. Request permissions from permissions@acm.org.
ASIA CCS ’16, May 30-June 03, 2016, Xi’an, China
c(cid:13) 2016 ACM. ISBN 978-1-4503-4233-9/16/05. . . $15.00
DOI: http://dx.doi.org/10.1145/2897845.2897899
h t t p : / / v . com/?name=(new Image ( ) ) . s r c =”
h t t p : / / e v i l . com/”+document . c o o k i e 
Listing 1: A typical XSS attack
Here, an attacker manages to inject some HTML through
the “name” URL parameter into a web page. When the
JavaScript in the injected  element is executed,
the user’s browser creates an  element with the source
URL on evil.com that contains the web page’s cookie in its
source path. Setting this URL as the source for the 
element triggers the browser to leak the cookie from v.com
to the attacker-controlled evil.com, as a part of making the
request to fetch the image.
This example illustrates the injection (via the “name” URL
parameter) and exﬁltration (via the image URL) ingredients
of XSS. Common mitigation techniques against injection are
data sanitization and encoding performed by the server, as
to prevent JavaScript from being injected in HTML.
The focus of this paper is on data exﬁltration. Prevent-
ing data exﬁltration is important for several scenarios.
It
is desired as the “last line of defense” when other mecha-
nisms have failed to prevent injection in trusted code.
It
is also desired when “sandboxing” [32, 45, 30, 46] untrusted
JavaScript, i.e., incorporating a functionality while not trust-
ing the code to leak sensitive information.
CSP Content Security Policy (CSP) is a popular client-side
countermeasure against content injection and XSS [43, 16].
CSP is set up by the server and enforced by the user agent
(browser) to restrict the functionality and communication
features of the code on the web page, mitigating the eﬀects
of a possible cross-site scripting attack.
CSP is standardized by the World Wide Web Consor-
tium (W3C) [49] and is supported by today’s mainstream
web browsers. With eﬀorts by the community to accommo-
date widespread adoption of CSP [50], we are likely to see
more websites implementing CSP. Large companies, such as
Google, Facebook, and Twitter lead the way introducing
CSP on their websites.
CSP mitigates content injection by, among others, disal-
lowing inline scripting by default. The injected JavaScript
code in the example above would be prevented from execut-
ing under CSP, simply because it appears as inline JavaScript
code in the viewed web page.
In addition, CSP allows a web developer to restrict in-
tended resources of a web application. Web browsers im-
plementing the CSP enforce this policy by only allowing re-
sources to be loaded from the speciﬁed locations. This has
two advantages. First, an attacker cannot sidestep the “no
inlining” rule by simply loading a piece of JavaScript from an
attacker-controlled server through . Sec-
ond, even if the attacker succeeds in executing code, e.g. by
including compromised third-party JavaScript, and some-
how steals data, it is no longer straightforward to exﬁltrate
this data back to the attacker. Exactly this is the case in
the example above when setting the URL to the new image
853object. CSP restricts the browser from making requests to
locations that are not explicitly whitelisted.
CSP discord about data exﬁltration CSP may appear
as a promising mitigation against content injection and XSS,
because it seemingly attempts to tackle both injection and
data exﬁltration. Yet, there is an unsettling discord in the
community about CSP’s intention to prevent data exﬁltra-
tion. This discord is unfortunate because it concerns the
very goals of CSP.
The CSP speciﬁcation only hints at data exﬁltration and
information leakage for several speciﬁc cases. The original
paper introducing CSP on the other hand, is very explicit
about its promise to prevent data exﬁltration [43].
Sadly, this vagueness appears to have led to misunder-
standings by the academic and practitioner community about
whether or not CSP can be used to prevent data exﬁltration.
On the one side are researchers who assume CSP is de-
signed to prevent data exﬁltration,
[25, 27, 41, 44, 47, 13].
Further, some previous research builds on the assumption
that CSP is intended to prevent data exﬁltration.
For example, the Conﬁnement System for the Web (COWL)
by Stefan et al. [44] is designed to conﬁne untrusted code
once it reads sensitive data. It implements a labeled-based
mandatory access control for browsing contexts. The system
trusts CSP to conﬁne external communication.
Another example is the SandPass framework by Van Acker
et al. [47], providing a modular way for integrating untrusted
client-side JavaScript. The security of the framework re-
lies on CSP to restrict external data communication of the
iframes where the untrusted code is loaded.
On the other side, there are researchers who claim CSP
does not intend to prevent against data exﬁltration. A com-
mon argument is that there are so many ways to break CSP
and exploit side channel attacks that it is simply impossible
for CSP to do anything about it [5, 10, 3].
Given the implications of the discord for the state of the
art in web security, it is crucial to bring the attention of the
community to it. This paper presents a detailed account
of the two respective views (in Section 2.2) and provides
directions for controlling data exﬁltration (in Section 7).
Further, the paper investigates at depth a particular chan-
nel for data exﬁltration in the face of CSP: via resource and
DNS prefetching. This channel is in particular need for sys-
tematization, given the unsatisfactory state of the art un-
covered in our experimental studies.
Case study: Prefetching in the face of CSP We bring
in the spotlight the fact that DNS prefetching is not covered
by the CSP and can be used by an attacker to exﬁltrate
data, even with the strongest CSP policy in place.
The following example allows an attacker to exﬁltrate
the cookie using automatic DNS prefetching, under a strict
CSP being default-src ’none’; script-src ’self’:
document . w r i t e ( "   " ) ;
Furthermore, we demonstrate that several types of re-
source prefetching, used to preemptively retrieve and cache
resources from web servers, can also be used for exﬁltrat-
ing data, in spite of CSP, allowing an attacker to set up a
two-way communication channel with the JavaScript envi-
ronment of a supposedly isolated web page.
We show that by combining diﬀerent techniques, an at-
tacker can exﬁltrate data from within a harshest possible
CSP sandbox on all twelve tested popular web browsers,
although one browser would only allow it conditionally.
Although we are not the ﬁrst to observe data leaks through
prefetching in the presence of a CSP policy (e.g. [34, 40, 11]),
we are to the best of our knowledge the ﬁrst to systematically
study the entire class of the prefetching attacks, analyze a
variety of browser implementations for desktop and mobile
devices, and propose countermeasures based on the lessons
learned.
Contributions The main contributions of our work are:
• Bringing to light a key design-level discord on whether
CSP is ﬁt for data exﬁltration prevention, illustrated
by assumptions and reasoning of opponents and pro-
ponents.
• The systematization of DNS and resource prefetch-
ing as data exﬁltration techniques in the face of the
strongest CSP policy.
• A study of the most popular desktop and mobile web
browsers to determine how they are aﬀected, demon-
strating that all of them are vulnerable in most cases.
• A measurement of the prevalence of DNS and resource
prefetching in combination with CSP on the top 10,000
Alexa domains.
• Directions for controlling data exﬁltration and their
• The proposal of countermeasures for the case study,
ranging from speciﬁc ﬁxes to a prefetching-aware ex-
tension to CSP.
interplay with CSP.
2. DATA EXFILTRATION AND CSP
2.1 Content Security Policy (CSP)
CSP whitelists sources from which a web application can
request content. The policy language allows to distinguish
between diﬀerent resource types (e.g. images or scripts) via
so called directives (e.g. img-src or script-src). The fol-
lowing example shows a policy which by default only allows
resources from the requested domain and images only from
http://example.com:
d e f a u l t −s r c
img−s r c h t t p : / / example . com
’ s e l f ’ ;
CSP disables the JavaScript eval() function and inline
scripting by default. CSP 1.1 [15] introduces a mechanism to
selectively allow inline scripts based on either nonces or the
code’s hash value. Newer versions of the standard [16, 17]
reﬁne the policy deﬁnition language through new directives.
None of the CSP standards cover DNS resolution, which
makes our case study independent of the used CSP version.
A CSP policy is deployed through the Content-Security-
Policy HTTP header in either the HTTP response or via
an HTML meta element with http-equiv attribute. Main-
stream web browsers already implement the CSP 2.0 [16]
standard. W3C currently works on an updated standard,
CSP 3.0 [17].
2.2 Discord about data exﬁltration and CSP
The CSP speciﬁcation [16] makes a single mention of data
exﬁltration. In the non-normative usage description of the
connect-src directive, the speciﬁcation acknowledges that
JavaScript oﬀers mechanisms that enable data exﬁltration,
854but does not discuss how CSP addresses this issue. Unfortu-
nately, this vagueness opens up for an unsettling discord by
the academic and practitioner community about whether or
not CSP can be used to prevent data exﬁltration. We now
overview and illustrate the discord, using both academic pa-
pers and online resources to back our ﬁndings.
The original paper [43] in which Mozilla researchers out-
line CSP is explicit about the intention to prevent data ex-
ﬁltration in what they call “data leak attacks”: “our scheme
will help protect visitors of a web site S such that the infor-
mation they provide the site will only be transmitted to S
or other hosts authorized by S, preventing aforementioned
data leak attacks” [43].
To this day, web security experts do not agree on whether
CSP should protect against data-exﬁltration attacks or not.
Several examples on the W3C WebAppSec mailinglist [48]
illustrate both opinions.
Some experts state that “Stopping exﬁltration of data has
not been a goal of CSP” [10] and “We’re never going to plug
all the exﬁltration vectors, it’s not even worth trying.” [3]
Others, such as one of the CSP speciﬁcation editors, “pre-
fer not to give up on the idea [of data exﬁltration pro-
tection] entirely” [31], stating that “it seems reasonable to
make at least some forms of exﬁltration prevention a goal of
CSP” [10], that “speedbumps are not useless” [20] and that
“the general consensus has been to try to at least address
leaks through overt channels.” [21]
The academic literature provides further evidence of the
discord. For example, Akhawe et al. [5] warn that CSP
should not be used to defend against data exﬁltration and
write “Browser-supported primitives, such as CSP, block
some network channels but not all. Current mechanisms
in web browsers aim for integrity, not conﬁnement. For ex-
ample, even the most restrictive CSP policy cannot block
data leaks through anchor tags and window.open.”
Other academic work represents the opposite view, either
stating explicitly or implying indirectly that CSP is intended
to mitigate exﬁltration, as discussed below.
For instance, Heiderich et al. [25], while discussing CSP
as a possible mitigation technique against scriptless attacks,
write “In summary, we conclude that CSP is a small and
helpful step in the right direction. It speciﬁcally assists elim-
ination of the available side channels along with some of the
attack vectors.” Using CSP to eliminate side channels im-
plies that CSP can prevent data-exﬁltration attacks.
Weissbacher et al. [50] analyze the usage of CSP on the
Web, indicating that CSP, if used correctly, can prevent data
exﬁltration, e.g. “While CSP in theory can eﬀectively miti-
gate XSS and data exﬁltration, in practice CSP is not de-
ployed in a way that provides these beneﬁts.”
Chen et al. [13] point out that CSP is vulnerable to self-
exﬁltration attacks, in which an attacker can exﬁltrate sen-
sitive data through a whitelisted site in order to retrieve it
later. In their work, CSP is listed as one of the existing data
exﬁltration defenses.
Johns [27] discusses several weaknesses in CSP which can
be resolved by combining it with PreparedJS, writing “Among
other changes, that primarily focus on the data exﬁltration
aspect of CSP, the next version of the [CSP] standard in-
troduces a new directive called script-nonce.” This seems to
imply that CSP has a data-exﬁltration aspect.
Stefan et al. [44] use CSP as a basis to build COWL,
an information-ﬂow control mechanism noting “While CSP
alone is insuﬃcient for providing ﬂexible conﬁnement, it suf-
ﬁciently addresses our external communication concern by
precisely controlling from where a page loads content, per-
forms XHR requests to, etc.”
Further, Van Acker et al. [47] use CSP to create an isola-
tion mechanism for SandPass, a password meter framework,
stating “the framework deﬁnes a CSP rule for included code
which completely forbids any network traﬃc.” Because these
defensive mechanisms are built on top of CSP, their security
relies on the assumption that CSP prevents data exﬁltration.
This state of the art illustrates the troubling consequences
of the vagueness of the CSP speciﬁcation, opening up the
wide disagreement of the community about the very goals of
the CSP. One might argue that the vagueness is natural and
perhaps even intended to accommodate the diﬀerent points
of view in the community, as a way of compromise. How-
ever, this argument would put the security community at
risk: defensive frameworks that build on partly unfounded
assumptions would be too high price to pay for giving room
for misinterpretation. We strongly believe that the way for-
ward is to be explicit about the goals of CSP in its speciﬁca-
tion, whether the community decides that data exﬁltration
is a part of them or not.
To illustrate data exﬁltration in the face of CSP, we inves-
tigate at depth a particular data exﬁltration channel: DNS
and resource prefetching.
3. BACKGROUND
This section provides background on DNS and resource
prefetching, which are at the heart of our case study.
3.1 Domain Name Service (DNS)
Figure 1: Recursive and iterative DNS resolution of
www.example.com.
Domain names like example.com are much more read- and
memorable for human users than a server’s numeric IP ad-
dress. To solve this issue, the early Internet saw the intro-
duction of a “phone book” service, the Domain Name Service
(DNS), that resolves a host’s more memorable name to its
associated IP addresses. Nowadays, DNS is a crucial part
of the Web and the Internet’s core infrastructure. DNS is
standardized in RFC 1034 [38] and RFC 1035 [39] with nu-
merous updates in successive RFCs.
The basic architecture of DNS is a distributed database
with a hierarchical tree structure. To resolve a domain
name, a client has to repeatedly query DNS servers until
the full name is resolved.