title:CopperDroid: Automatic Reconstruction of Android Malware Behaviors
author:Kimberly Tam and
Salahuddin J. Khan and
Aristide Fattori and
Lorenzo Cavallaro
CopperDroid: Automatic Reconstruction
of Android Malware Behaviors
Kimberly Tam∗, Salahuddin J. Khan∗, Aristide Fattori†, and Lorenzo Cavallaro∗
∗Systems Security Research Lab and Information Security Group
Royal Holloway University of London
†Dipartimento di Informatica
Universit`a degli Studi di Milano
Abstract—Mobile devices and their application marketplaces
drive the entire economy of the today’s mobile landscape. Android
platforms alone have produced staggering revenues, exceeding ﬁve
billion USD, which has attracted cybercriminals and increased
malware in Android markets at an alarming rate. To better
understand this slew of threats, we present CopperDroid, an
automatic VMI-based dynamic analysis system to reconstruct the
behaviors of Android malware. The novelty of CopperDroid lies
in its agnostic approach to identify interesting OS- and high-level
Android-speciﬁc behaviors. It reconstructs these behaviors by
observing and dissecting system calls and, therefore, is resistant
to the multitude of alterations the Android runtime is subjected
to over its life-cycle. CopperDroid automatically and accurately
reconstructs events of interest that describe, not only well-known
process-OS interactions (e.g., ﬁle and process creation), but also
complex intra- and inter-process communications (e.g., SMS
reception), whose semantics are typically contextualized through
complex Android objects. Because CopperDroid’s reconstruction
mechanisms are agnostic to the underlying action invocation
methods, it is able to capture actions initiated both from Java and
native code execution. CopperDroid’s analysis generates detailed
behavioral proﬁles that abstract a large stream of low-level—often
uninteresting—events into concise, high-level semantics, which
are well-suited to provide insightful behavioral traits and open
the possibility to further research directions. We carried out an
extensive evaluation to assess the capabilities and performance of
CopperDroid on more than 2,900 Android malware samples. Our
experiments show that CopperDroid faithfully reconstructs OS-
and Android-speciﬁc behaviors. Additionally, we demonstrate
how CopperDroid can be leveraged to disclose additional behaviors
through the use of a simple, yet effective, app stimulation
technique. Using this technique, we successfully triggered and
disclosed additional behaviors on more than 60% of the analyzed
malware samples. This qualitatively demonstrates the versatility
of CopperDroid’s ability to improve dynamic-based code coverage.
I.
INTRODUCTION
With more than a billion Android-activated devices [25]
and over a billion of monthly-active Android users [19],
mobile platforms have clearly become ubiquitous with trends
showing such a pace is unlikely to slow down. Application
Permission to freely reproduce all or part of this paper for noncommercial
purposes is granted provided that copies bear this notice and the full citation
on the ﬁrst page. Reproduction for commercial purposes is strictly prohibited
without the prior written consent of the Internet Society, the ﬁrst-named author
(for reproduction of an entire paper only), and the author’s employer if the
paper was prepared within the scope of employment.
NDSS ’15, 8-11 February 2015, San Diego, CA, USA
Copyright 2015 Internet Society, ISBN 1-891562-38-X
http://dx.doi.org/10.14722/ndss.2015.23145
marketplaces, such as Google Play, drive this entire economy
of mobile applications (apps). For instance, with more than
50 billion downloaded apps [39], Google Play has gener-
ated revenues exceeding 5 billion USD [23] in 2013. Such
a wealthy and unique ecosystem, with high turnovers and
access to sensitive data, has unfortunately spurred an alarming
growth in Android malware. Privacy breaches (e.g., access to
address book and GPS coordinates) [47], monetization through
premium SMS and calls [47], and colluding malware to bypass
2-factor authentication schemes [12] have become real threats.
Recent studies also report how easily mobile marketplaces
have been abused to host malware or seemingly legitimate
applications embedding malicious components [46].
The nature of Android apps makes it difﬁcult to rely on
standard, traditional, dynamic system call malware analysis
systems as is. While Android apps are generally written in the
Java programming language and executed on top of the Dalvik
virtual machine (VM) [7], native code execution is possible,
for instance, via the Java Native Interface (JNI). This mixed
execution model seems to suggest the need to reconstruct,
and keep in sync, different semantics through virtual machine
introspection (VMI) [20] for both the OS and Dalvik views,
as recently shown in [43]. More recently, Zhang et al. stressed
this concept further in [43] and pointed out that traditional
system call analysis is ill-suited to characterize the behaviors
of Android apps as it misses high-level Android-speciﬁc se-
mantics and fails to reconstruct inter-process communications
(IPC)1 and remote procedure call (RPC) interactions, which
are essential to understanding Android application behaviors.
In a signiﬁcantly different line of reasoning from [17],
we observed that system call invocations remains central to
both low-level OS-speciﬁc and high-level Android-speciﬁc
behaviors. However, a naive analysis of system calls would
miss the rich semantic of Android-speciﬁc behaviors. This is
where the novelty of our approach lies; our techniques enable
seamless and automatic dissection of complex inter-process
communications resulting in the automatic deserialization of
complex Android objects. This enables us to reconstruct behav-
iors of Android applications at multiple levels of abstraction
from a single point of observation (i.e., system calls). More im-
portantly, our simpliﬁed approach makes the analysis agnostic
to the runtime system, freeing the analysis engine from playing
catch-up with each change to the system (our techniques work
transparently on systems using the Dalvik VM and ART).
1Android IPC is also known as inter-component communication (ICC) [17].
We will use IPC and ICC interchangeably throughout the text.
Our framework, titled CopperDroid2, is an approach built
on top of QEMU [6] to automatically perform out-of-the-box
(VMI-based) dynamic analysis and reconstruct the behaviors
of Android malware. Through CopperDroid, we demonstrate
that all behaviors manifest themselves through the invocation
of system calls [17], and that we can faithfully reconstruct
Android malware behaviors regardless of whether it is initiated
from Java or native code. However,
to automatically and
reliably reconstruct system call semantics, including IPC, RPC,
and (complex) Android objects, is a challenging task. In fact,
high-level Android object information is not directly available
at the system call level. Moreover, to guarantee transparency
against
inner changes (or whole replacement) of the An-
droid runtime (e.g., Dalvik VM, ART), its direct introspection
must be avoided. To address this challenge, we introduce
the concept of the unmarshalling Oracle, which seamlessly
recreates complex Android objects to enrich the semantics of
the reconstructed OS- and Android-speciﬁc behaviors. This is
where the real value of CopperDroid lies. A preliminary de-
scription of CopperDroid, focused on introducing basic analysis
capabilities (e.g., system call tracking), has already appeared in
our workshop paper [36]. In this paper, we present our mature
research efforts, including the following contributions:
1) Automatic IPC Unmarshalling: We introduce Copper-
Droid and present the design and implementation of a novel,
practical, oracle-based technique to automatically and seam-
lessly reconstruct Android-speciﬁc objects involved in system
call-related IPC/ICC and RPC interactions. Our approach
avoids manual development efforts and transparently addresses
the challenge of dealing with the ever increasing number
of complex Android objects introduced in different Android
releases. The Oracle allows CopperDroid to perform large-
scale, automatic, and faithful reconstruction of Android apps
behaviors (Sections IV), suitable to enable further research,
including Android malware detection.
2) Value-based Data Flow Analysis: To abstract sequences
of related low-level system calls to higher-level semantics
(e.g., network communications, ﬁle creation) and enrich our
reconstructed behavioral proﬁles, we automatically build data
dependency graphs over sets of observed system calls (includ-
ing those referring to IPC/ICC and RPC mechanisms) and
perform value-based forward slicing to cluster data-dependent
system calls. This gives us the ability to automatically recreate
the resources associated with a stream of sliced system calls.
Moreover,
this further simpliﬁes the understanding of the
behavioral proﬁles by summarizing its semantic, and provides
access to the reconstructed resources, which can be fed back
to CopperDroid, downloaded for additional inspection, or an-
alyzed by complementary systems (Section V-B).
3) Behavioral Reconstruction: We provide a thorough eval-
uation of CopperDroid’s behavioral reconstruction capability
on more than 2,900 Android malware samples provided by
different sources [11], [30], [49]. Furthermore, our experiments
show how a simple yet effective malware stimulation strat-
egy (Section V-A) allows us to disclose an average of 25%
of additional behaviors on more than 60% of the analyzed
samples, qualitatively improving dynamic analysis behavioral
reconstruction capabilities with a very limited effort and neg-
ligible overhead (Section VI).
2Based on an informal British term for police ofﬁcers as well as the metal.
It is our belief that CopperDroid’s uniﬁed reconstruction
signiﬁcantly contributes to the state-of-the-art reconstruction
of Android malware behavior. Although our system could have
been built on top of DroidScope [43], a general-purpose VM-
based out-of-the-box framework to build dynamic analysis for
Android, its source code was not available when we began our
development. Furthermore, DroidScope offers basic hooking
mechanisms and relies on keeping a synchronized 2-level VMI
(for OS and Dalvik VM semantics), which makes it complex
and harder to port onto different versions of Android OSes (for
instance, VMI-related offsets tend to vary more frequently in
the Dalvik VM rather than in the kernel). Our approach, on
the other hand, is unaffected by such changes. VetDroid [44]
presents a framework to construct permission-use behavior
graphs, which highlight how applications use permissions to
access system resources, and how such resources are utilized
by the application. Although an interesting approach, VetDroid
requires a quite intrusive modiﬁcation of the Android system
(both Dalvik VM, Binder, and Linux kernel), which hampers
the ability to easily port
the system to different Android
versions. In addition, VetDroid builds on top of TaintDroid
and, therefore, inherits its drawbacks [10], [37].
Conversely, CopperDroid’s uniﬁed analysis does not require
complex introspection, but only needs to collect the system
calls invoked by the processes running on the monitored
system. Hence, all analyses are performed outside the VM.
This ﬂexibility allows our system to be largely decoupled
from any speciﬁc Android environment, enabling seamless
integration across different Android versions. For instance, we
have successfully run CopperDroid on Froyo, Gingerbread,
Jelly Bean, KitKat, and the newest Lollipop (i.e., Android
5.0) version with no modiﬁcation to the Android system and
minimal, automatically-generated, alterations to CopperDroid.
This is particularly remarkable as Lollipop has substituted the
existing Dalvik’s just-in-time compiler (in all previous Android
OS versions) with the new, faster, ahead-of-time compiler ART
[34]. While all Dalvik-level based analysis engines will be
affected by this change, CopperDroid was unfazed.
The enhancements presented in this paper are central
to CopperDroid’s VMI-based system call-centric analysis—
whose automatic IPC and RPC dissection and Android-speciﬁc
objects (and thus behaviors) reconstruction are a key aspect.
Furthermore, we evaluated CopperDroid on a large and diverse
datasets to demonstrate the range of behaviors (e.g., shell
execution, IPC) it can abstract.
II. BACKGROUND: THE ANDROID SYSTEM
Android applications are typically written in the Java pro-
gramming language and then deployed as Android Packages
archive (APKs). Each application runs in a separate userspace
process [2] as an instance of the Dalvik virtual machine
(DVM) [7] and usually with a distinct user and group ID. Al-
though isolated within their own sandboxed environment, these
applications can interact with other applications and the system
through well-deﬁned APIs. Every APK is also considered to be
a self-contained app that can be logically decomposed into one
or more components (e.g., activities, services, and broadcast
receivers). Each component is generally designed to fulﬁl a
speciﬁc task (e.g., GUI-related actions, notiﬁcation receiver)
and is invoked either by the user or the OS.
2
high-level Android-speciﬁc behaviors. Although recently ex-
plored to enforce user-authorized security policies [42], to the
best of our knowledge, CopperDroid is the ﬁrst approach to
carry out a detailed analysis of such communication channels
to comprehensively characterize OS- and Android-speciﬁc
behaviors of malicious applications.
As systematically evaluating the Oracle’s reconstruction
capabilities on every possible object (over 300+ AIDL objects
alone) is a very challenging task, we introduce a representative
example which triggers the main aspects of the Oracle’s
unmarshalling capabilities. Let us consider an app that sends an
SMS as our running example. The Java code that corresponds
to the SMS behavior (e.g., creation and execution of an SMS
intent) can be seen in Figure 4 (a). Such code typically includes
a call to the sendTextMessage method of SmsManager,
with the destination number (e.g., “123456789”) and the SMS
text (e.g., “Hello”) as parameters. It is also optional to include
a PendingIntent, which is broadcasted when the message
is successfully sent to its destination.
PendingIntent objects are usually passed by reference,
rather than being directly marshalled. To keep track of such
data, CopperDroid is also aware of any creation of shared
memory (for example,
to store a PendingIntent) due
to several ioctl calls sent from the client application to
the IActivityManager (speciﬁcally the getIntentSender
method). Indeed, all Binder transactions, including SMS, are
ﬁred by invoking the two ioctl system calls, as shown in
Figure 4 (b). For example, when an SMS is sent, we would see
one ioctl to locate the SMS service and the other to invoke
the sendTextMessage method. It is the latter that is sent
to the Oracle for unmarshalling. Furthermore, if the second
ioctl includes a pass-by-reference parameter (e.g., a handle
to a PendingIntent) CopperDroid locates a third ioctl
with the actual referenced object (e.g., PendingIntent
saying “SENT”) being sent to the IAccountManager.
From a high-level perspective (e.g., Java methods), sending
an SMS by executing sendTextMessage (last
line of
Figure 4 (a)), roughly corresponds to obtaining a reference
to an instance of the class SmsManager, the phone SMS
manager, and sending the SMS out by invoking the method
sendTextMessage as seen in the ﬁgure. This includes
the necessary method parameters
including the destination
phone number and the text message as the method arguments.
On a lower level,
this corresponds to locating the Binder
service isms and remotely invoking its sendText method
with proper arguments. From this low-level perspective, the
same actions correspond to the sender application invoking
two ioctl system calls on /dev/binder: one to locate
the service and the other to invoke its method. CopperDroid
thoroughly introspects the arguments of each binder-related
ioctl system call to reconstruct the remote invocation. This
allows us to identify the invoked method and its parameters,
and to infer the high-level semantic of the operation. In
particular, we focus our analysis on Binder transactions, i.e.,
IPC operations that actually transfer data (also responsible
for RPC). To identify them, CopperDroid parses the memory
structures passed as a parameter to the ioctl system call
and identiﬁes Binder transactions (BC_TRANSACTION) and
replies (BC_REPLY). (see [36] and Figure 3).
However, just intercepting transactions is of limited use
PendingIntent sentIntent = PendingIntent.getBroadcast(
SMS.this, 0, new Intent("SENT"), 0);
SmsManager sms = SmsManager.getDefault();
sms.sendTextMessage(
"123456789", null, "Hello", sentIntent, null);
(a) SMS send with PendingIntent behavior at Java level.
ioctl(0x14, BINDER_WRITE_READ, 0xbedc93e8) = 0
ioctl(0x14, BINDER_WRITE_READ, 0xbeb69508) = 0
ioctl(0x14, BINDER_WRITE_READ, 0xbeb693e8) = 0
(b) SMS send ioctls with PendingIntent behavior. The
third parameter points to a binder_write_read data structure,
which eventually leads to a binder_transaction_data data
structure, as shown in Figure 3.
BINDER_TRAN (from binder_transaction_data)::
sentIntent =
[android.app.PendingIntent = Intent("SENT")])
BINDER_REPLY (from binder_transaction_data)::
sentIntent =
[android.app.PendingIntent{Binder:
type = BINDER_TYPE_HANDLE,
flags = 0x7F|FLAT_BINDER_FLAG_ACCEPTS_FDS,
handle = 0xa,
cookie = 0xb8a58ae0}]
BINDER_TRAN (from binder_transaction_data)::
com.android.internal.telephony.ISms.sendText(
destAddr = "123456789", srcAddr = None,
text = "Hello",
sentIntent =
[android.app.PendingIntent{Binder:
type = BINDER_TYPE_HANDLE,
flags = 0x7F|FLAT_BINDER_FLAG_ACCEPTS_FDS,
handle = 0xa, cookie = 0x0}],
deliveryIntent = null
Oracle::
com.android.internal.telephony.ISms.sendText(
destAddr = "123456789", srcAddr = None,
text = "Hello",
sentIntent =
[android.app.PendingIntent("SENT")],
deliveryIntent = null
(c) Simpliﬁed SMS send (including PendingIntent) recon-
struction produced by CopperDroid and the Oracle, using the
binder_transaction_data retrieved from the ioctl.
Figure 4: Excerpt of CopperDroid reconstructed SMS send with
PendingIntent (for send conﬁrmation) using captured
ioctls, AIDL generated ﬁles, and correlated binder handles
generated by IActivityManager.
when it comes to understanding Android-speciﬁc behaviors.
In fact,
the raw ioctl-provided Binder data that ﬂows
throughout transactions are ﬂattened and marshalled into a
single buffer. Moreover, every interface a client and service
agree upon has its own set of predeﬁned methods’ signature,
and, as the Android framework counts more than 300 of these
AIDL interfaces, manual unmarshalling is unfeasible.
To understand the invoked method and the unmarshalling
procedure for its parameters, we extended CopperDroid with
the following. First, we let it identify the InterfaceToken spec-
iﬁed in the payload (see Figure 2, Interface Token Identiﬁer
block). This is then used to ﬁnd the AIDL description, if
5
available, of the interface CopperDroid needs to associate the
numeric code to the invoked method and, therein, understand
the types of its parameters. This step is necessary because,
even if Parcel methods can create easily unmarshallable
streams of bytes (including metadata to associate bytes to
types), payloads are often marshalled directly and only the
receiver knows exactly how to unmarshall them. Our solution,
therefore, parses the AIDL ﬁles (using a modiﬁed AIDL
parser) to automatically generate signatures of each method for
each interface. These signatures are speciﬁc to a given version
of Android and are used to assist in the unmarshalling process.
Such signatures are then sent to an unmarshalling Oracle
running separate from, but with the same Android OS version,
the CopperDroid emulator (see Figure 2). Along with the
AIDL signatures, marshalled data extracted from the ioctl
transaction is also sent to the Oracle to determine the values
of the method parameters through automatic unmarshalling of
binder data, as outlined next.
A. AIDL Parser
An AIDL ﬁle deﬁnes a given interface detailing its meth-
ods, parameters and return values types. The Android platform
includes an AIDL parser which, given an AIDL ﬁle, will
produce Proxy and Stub classes. The Proxy is used on the
client side and matches the method calls that a client would
call (in terms of method name, parameters and return value).
The Stub, used on the server side, utilizes the transaction
code in order to perform the appropriate actions for the given
method call. The reason for this is that all Binder calls go
through the Binder device driver as I/O controls and while the
functions on the client side (Proxy) match those in the client,
the server (Stub) needs to efﬁciently map a given call to its
method. The actual parcel data is held in the buffer ﬁeld of
the binder_transaction_data structure (see Figure 3).
While the AIDL process works ﬁne for marshalling data
between clients and servers during normal runtime, it is nec-
essary for CopperDroid to combine components of the Proxy
and Stub in order to unmarshall the objects post-analysis.
Furthermore, it is also necessary to implement a parcel reader
that understands how to unmarshall parameters from the mar-
shalled data. Therefore, CopperDroid includes a modiﬁed AIDL
parser that obtains the method names, parameters and return
values types (i.e., usually utilized in the Proxy at runtime) to
build a mapping between transaction codes and methods. It
then combines this information with the parcel reader class
mentioned earlier to automatically produce handling code for
a given method. CopperDroid utilizes this code to extract
the necessary information from any Binder call during later
analysis. All this automatically-generated AIDL information
is stored in multiple Python ﬁles, preserving the mapping
of all interface names to parcel data extraction routines. For
example, “com.android.internal.telephone.ISms” is mapped to
the db_parcel_ISms function call. As this process is only
needed once per Android OS version, it can be done before
analysis and does not induce overhead during analyses.
B. Oracle Input
else
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21 end
end
end
locate CREATOR ﬁeld for reﬂection;
use java reﬂection to get class object;
for every class ﬁeld do
if ﬁeld → primitive then
append string repr. to results;
explore ﬁeld recursively;
append string repr. to results;
else
end
end
if CREATOR → not found and buffer → binder
reference type then
Unmarshall Binder reference
Data: Marshalled binder transaction and data types
(determined through the AIDL)
Result: Unmarshalled binder transactions
1 while data → marshalled do
determine type of marshalled item;
2
if type → primitive then
3
4
automatically apply correct parcelable read/create
functions;
append string repr. to results;
Algorithm 1: The Unmarshalling Oracle.
can be seen in Figure 3. This is essentially the buffer minus
the InterfaceToken, placed at the front of the buffer, which is
a length-preﬁxed UTF-16 string. Serialized parameter values
following the token are stored and sent to the Oracle for post-
processing (Figure 2 leftmost RSP line and leftmost TCP line).
The second extracted piece of information is the numeric code
that, when united with the InterfaceToken, uniquely
identiﬁes the method that is called by a binder transaction.
The InterfaceToken, along with the numeric code,
is used by CopperDroid to invoke the correct automatically-
generated AIDL data extraction routine (as explained above).
This routine returns the AIDL description of the interface and
enables the Oracle to understand the types of the parameters
contained in the buffer and unmarshall them. For example,
in Figure 4, the PendingIntent leads us to an actual Java
Intent type, which stores the message “SENT” and can hold
other data such as an action to perform after the SMS had been
sent (e.g., notify the user or add the sent SMS into a log).
is
the
after
example,
Revisiting
SMS
the
ISms.sendText() method
invoked, CopperDroid
intercepts the corresponding binder
transaction and uses
the InterfaceToken and the code to invoke the
correct handling function that retrieves information on the
called method. For the SMS example,
these include the
method name (“sendText”), its parameters (destAddr, scAddr,
text,
types
(String, String, String, PendingIntent, PendingIntent). This
information is sent to the Oracle along with the marshalled
buffer—containing, among other
the
message. The Oracle uses this data to extract the value of
parameters passed to ISms.sendText().
sentIntent, deliveryIntent), and its parameter
the body of
things,
We extract two different pieces of data per ioctl call
containing the BINDER_WRITE_READ ﬂag. First, a blob of
marshalled parameters is taken from the buffer ﬁeld, as
C. Oracle Inner Workings and Output
The Oracle relies on Java reﬂection to unmarshall
the
6
complex serialized Java objects it receives and returns their
string representations to CopperDroid to enrich its behavioral
proﬁle with Android-speciﬁc actions. Therefore, the Oracle
must be run with the same Android OS version as the
CopperDroid emulator. However, it is worth noting that the
unmarshalling Oracle does not require the access to the app, or
malware, being analyzed in the separate CopperDroid emulator.
All information necessary to unmarshall the Binder data is
retrieved from the CopperDroid emulator and sent over to the
vanilla Android emulator running the Oracle via CopperDroid’s
behavioral reconstruction analysis, as depicted in Figure 2.
Algorithm 1 outlines the working details of the unmar-
shalling Oracle. It currently unmarshalls Binder communica-
tion objects in one of three unique ways depending on whether
the type of data is a primitive or basic type (e.g., String,
Integer), an Android class object (e.g., Intent), or a Binder
reference object (e.g., PendingIntent, Interface). As mentioned
previously, the data types are determined by CopperDroid’s
AIDL parser and the list of parameter types is sent to the
Oracle along with the marshalled parameter values. For ex-
ample, primitive or basic types are easily unmarshalled by
invoking the appropriate unmarshalling function provided by
the Parcel class (e.g., readString, readInt).
In the following, we provide additional details on the
automatic unmarshalling process.
Primitives: While iterating through the list of types and
class names (e.g., in our SMS example the Oracle would iterate
through three String types and two PendingIntent
types), if the type is identiﬁed as primitive (e.g., String) the
corresponding read function provided by the Parcel class
is used (e.g., readString()). The while loop at line 1
in Algorithm 1 would iterate through those ﬁve parameters,
while lines 3-5 are responsible for primitive types. In our
SMS example, the parameters destAddr, scAddr, and text have
primitive String types and would therefore be unmarshalled
using the correct readString() Parcel function in order
to regain the parameter values, such as the SMS text body
“Hello”.
Class objects: To unmarshall a class instance, the Oracle
application requires Java reﬂection (see lines 6-7 in Algorithm
1). This method allows the Oracle to dynamically retrieve a
reference to the CREATOR ﬁeld, implementing the Android
Parcelable interface. Any of such object must implement
this interface, and therefore must have the CREATOR ﬁeld,
in order to be written to and read from a Parcel. Once
this has been achieved,
the Oracle can begin reading the
remaining class data: in our example in Figure 4, the class
data of an Android Intent (sent as a PendingIntent)
entails the phrase “SENT” [13]. Once we have obtained the
CREATOR ﬁeld, the Oracle can obtain a reference to it, and
invoke its createFromParcel() method in order to unmarshall
the new object and read in its data. Once either a primitive or
class type has been unmarshalled, the Oracle creates a string
representation of the object by invoking its toString()
method, if any, or alternatively recursively inspecting each
ﬁeld through Java reﬂection (see Section IV-D). The string
representation is then appended to an output string list, and
the marshalled data offset is updated to point to the next item
to be unmarshalled next. Additionally, the Oracle iterates to
the next parameter primitive or class type on the given list.
IBinder objects: As mentioned previously, certain types
of Binder objects are not marshalled and then sent via
IPC directly, but
instead a reference to the object, stored
either in the caller memory address space or in a shared
memory space (i.e., ashmem), is sent instead. In this case,
if the object is neither a primitive nor directly marshalled
(see Algorithm 1, line 17), the Oracle veriﬁes whether the
data contains a binder reference object. This requires pars-
ing the ﬁrst four bytes of the marshalled object
looking
for IBinder reference types. These reference types deter-
mine whether the referenced object is a Binder service (i.e.,
BINDER_TYPE_(WEAK_)BINDER—a transaction sending a
handle and service name to the IServiceManager), a
Binder proxy (i.e., BINDER_TYPE_(WEAK_)HANDLE—to
send objects from clients including IInterface classes rep-
resented as a binder object), or a ﬁle descriptor of an ashmem
region (BINDER_TYPE_FD, although the other types may
also send fds with the appropriate ﬂags). Normally the Binder
reference keeps the object from being freed; however, if the
type is weak, the existence of the reference does not keep the
object from being removed, unlike a strong reference.
For instance, referring to our running example in Figure 4,
a PendingIntent can be used to broadcast whether the
SMS was successfully sent or not. By reconstructing this
Intent the Oracle can understand whether the SMS was
successfully sent. However, this Intent is not actually sent
over the IPC channel directly, but is rather sent as a handle
reference. Therefore the Oracle unmarshalls the ioctl call,
just as the receiving process would have in real-time, obtaining
a reference. Such a reference may contain an address or, as
is the case here, a handle to the PendingIntent that can
be seen with value “0xa” in our Oracle reconstructed SMS
in Figure 4 (c). When sending the IPC communication to the
server, Binder passes along the information necessary for the
receiving process to seamlessly retrieve the data.
With the referenced-based parceling used by Binder, the
Oracle needs to retrieve live ancillary data from the system
in order to be able to map the references to the data. To
this end, CopperDroid keeps track of these references in real-
time, whether they are sent via handle or via a ﬁle descriptor.
In the latter case, data from ashmem regions—created via
speciﬁc ioctl and mmap system calls—are retrieved by
CopperDroid and unmarshalled by the Oracle. Furthermore,
CopperDroid tracks certain calls which register a given allo-
cation (either in the caller space or shared via ashmem) and
obtains the handle that is assigned for the given allocation. For
example, in Figure 4 there is a transaction (BINDER_TRAN)
for registering the sentIntent and corresponding response
(BINDER_REPLY) with the handle. However, to extract such
information, CopperDroid needs to identify the ﬁle descrip-
tor or binder handle (e.g., the marshalled binder reference)
passed as a reference in the binder transaction. To avoid
using ad-hoc extraction procedures and to rely on automatic
mechanisms, CopperDroid relies on the support provided by
the unmarshalling code generated by the AIDL parser to
extract the primitive types and handles/references in the binder
transaction.
Thus, whenever CopperDroid intercepts a binder trans-
action that uses handle-referenced memory (caller allocated
or ashmem),
the reference at run
it can quickly extract
7
time. For instance, as mentioned earlier in Figure 4 (a),
when an app creates a PendingIntent, it does so by calling
the IActivityManager::getIntentSender method,
which returns a handle speciﬁc to that data (the handle is re-
turned in the standard flat_binder_object structure for
references). In order to extract the references, CopperDroid uti-
lizes two additional ﬁelds (i.e., offsets_size ﬁeld and the
offsets pointer), in the binder_transaction_data4.
The offsets_size ﬁeld is the size (in bytes) of the
offsets array, comprised of pointer sized values each cor-
responding to a given reference.
If, when unmarshaling a given binder transaction,
the
type (based on the code generated by the AIDL parser)
is a binder type, then the offsets array is used to lo-
cate the offset within the transaction data of the speciﬁc
flat_binder_object. The offsets are in the same order
as the types in the parcelable object. Referring to the SMS
example as shown in Figure 4, the sentIntent is the ﬁrst
reference and should thus be the ﬁrst entry (position 0) in the
offsets array and, if the deliveryIntent were not null,
it would be the second entry in the offsets array (position
1) and the offsets_size ﬁeld would be 8 (bytes) on a 32-
bit ARM system. With this information, CopperDroid identiﬁes
and captures the corresponding caller allocated memory region,
ashmem region, or any other memory region which contains
the actual marshalled object. The marshalled data is then sent
back to the Oracle for the ﬁnal unmarshalling procedure5.
D. Recursive Printing
The purpose of printing recursively is to thoroughly inspect
each ﬁeld in every object to produce as much information as
possible. Normally this means every sub class (or bundle)
is explored until a primitive can be found and printed or
stored for further analysis by CopperDroid. To do this, the
string representation of each primitive is appended to the
output string list, and the marshalled data offset is updated to
point of the next unmarshalled item. Additionally, the Oracle
iterates to the next type, or class name, on the given list. Once
the Oracle has completed unmarshalling all the parameters,
the ﬁnal output can be returned to CopperDroid. Figure 4(c)
presents an excerpt of a simpliﬁed Oracle output corresponding
to a reconstructed send SMS behavior. For simplicity, we only
include essential details, ﬁltering out less relevant ﬂags and
empty ﬁelds.
V. OBSERVED BEHAVIORS
We manually examined the results of CopperDroid’s anal-
yses (i.e., system call invocations tracking, Binder analysis,
and complex Android objects reconstruction) on a number
of randomly selected Android malware extracted from the
samples sets at our disposal [11], [30], [49]. Figure 5 shows
the insights of our examination, which allowed us to identify
six macro classes of behaviors. Each class contains one or
more behavioral models, which is deﬁned by a set of actions.
Actions are traced through CopperDroid and can belong to any
4These are not shown in the simpliﬁed payload Figure 3.
5A limitation of our current implementation is that we can only automat-
ically inspect and unmarshall parameters of methods contained in interfaces
of which we have the AIDL ﬁles. Bound services that do not use AIDL, e.g.,
ActivityManager, are manually unmarshalled.
Figure 5: Hierarchical map of behaviors.
level of behavior abstraction (e.g., OS- and Android-speciﬁc
behaviors). Interestingly, some behaviors are well-known and
shared with the world of non-mobile malware. Others, such as
those under the “Accessing Personal Info” class, are instead
inherently speciﬁc to the mobile ecosystem.
Every terminating class in the map corresponds to a behav-
ioral model that can be expressed by an arbitrary number of
actions, depending on its speciﬁc complexity. The complexity
of these elements vary greatly. Some are deﬁned as a single
system call, such as execve. Others, such as “SMS Send”
or those under “Access Personal Info”, are deﬁned as a set
of transactions of the Binder protocol. Yet others are deﬁned
as multiple consecutive system calls. For instance, outgoing
HTTP trafﬁc is modeled as a graph with a connect system
call, followed by an arbitrary number of send-like system
calls, whose payload is parsed to detect HTTP messages,
possibly interleaved by unrelated non-socket system calls.
Terminating classes do not forcibly correspond to just one
of the aforementioned models, but may also contain a set of
them. To clarify, consider the examples shown in Figure 6
which illustrate how CopperDroid recognizes actions triggered
by both these snippets of code as belonging to the class “Install
APK”, despite the differences in the manner in which these
actions are achieved (an execve system call rather then a
Binder transaction).
A. App Stimulation
Traditional executables have a single entry point, while
Android applications may have multiple. Most apps have a
main activity, but ancillary activities may be triggered by the
system or by other apps and the execution may reach them
without ﬂowing through the main. In such a scenario, a simple
install-then-execute dynamic analysis may miss a number of
interesting behaviors. This problem has long been affecting
traditional dynamic analysis approaches as non-exercised paths
are simply unanalyzed. If such paths host additional behaviors,
8
execve(’pm’,[’pm’, ’install’, ’-r’, ’New.apk’], ... );
(a) App installation via direct system call (OS-speciﬁc behavior).
Intent intent = \
new Intent(Intent.ACTION_VIEW);
intent.setDataAndType(
Uri.fromFile(
new File("/mnt/sdcard/New.apk")),
"application/vnd.android.pack...");
startActivity(intent);
(b) App installation via Binder transaction (e.g., Intent speciﬁc).
Figure 6: App installation via direct system call and Binder
(Android-level) transaction.
the application would only react
then any dynamic analysis would fail unless proper, but
generally expensive and complex exploration techniques are
adopted [8], [31]. In addition, this problem is exacerbated by
the fact that mobile applications are inherently user driven and
interaction with applications is generally necessary to increase
coverage. For instance, let us consider an application that
operates as a broadcast receiver for SMS RECEIVED events.
After installation,
to the
reception of SMS showing no additional interesting behaviors.
To qualitatively address dynamic code coverage issues,
CopperDroid implements a technique to artiﬁcially stimulate
the analyzed malware with a number of valid and interesting
events based on the malware’s Manifest. For example, injecting
events such as phone calls and reception of SMS texts would
lead to the execution of any application registered broadcast
receiver. Another example that comes from our experience with
Android malware is the BOOT_RECEIVED intent, that many
samples use to start execution as soon as the victim system
is booted (much like \CurrentVersion\Run registry keys
on Windows systems).
The Android emulator offers the possibility to inject a
considerable number of artiﬁcial events to stimulate a running
application. These range from very low-level hardware-related
events (e.g., loss of the 3G signal) to higher-level ones (e.g.,
incoming calls, SMS). CopperDroid could adopt a fuzzing-
like stimulation strategy and trigger all the events that could
be of interest for the analyses. That would unfortunately be
of limited effect because of the underlying Android security
model and permission system. Instead, CopperDroid leverages
static information extracted from the app to carry out a ﬁne-
grained targeted stimulation strategy. To this end, CopperDroid
examines each APK Manifest to extract events and permission-
related information to drive the malware stimulation. Further-
more, an application has the ability to dynamically register a
broadcast receiver for custom events at run-time. CopperDroid
is able to intercept such operations and add a proper stimula-
tion for the newly registered receiver.
To perform its custom stimulation, CopperDroid leverages
the Android emulator’s capabilities to inject a number of
artiﬁcial events into the emulated system. In particular,
it
leverages MonkeyRunner, a tool that provides an out-of-the-
box API to control an Android device or emulator, through the
Python programming language [3]. A summary of the main
#
1
2
3
4
5
6
Stimulation
Parameters
Received SMS
Incoming call