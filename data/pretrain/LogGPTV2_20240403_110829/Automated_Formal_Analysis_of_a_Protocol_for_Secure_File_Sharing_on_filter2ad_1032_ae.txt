3. An honest reader for g reads m using keys for
version 0.
ProVerif does not exhibit the former attack mentioned
in [32] because it stops with this simpler attack.
4.3.2. With server-veriﬁed writes, why should a new
write token be created for each version?
Suppose that a writer w, allowed at version 0, is revoked
without changing the write token. Then the server accepts
writes from w even after its revocation (at version 1), since
the token obtained by w at version 0 remains valid. In par-
ticular, w may destroy ﬁles by overwriting them with un-
readable junk after its revocation. This attack violates the
correctness of server-veriﬁed writes. Furthermore, w may
write valid contents after its revocation (at version 1) using
keys that it obtained at version 0, and readers can read such
data using keys for version 0, trusting that they were written
at version 0. This attack violates strong integrity.
Accordingly, neither the correctness of server-veriﬁed
writes nor strong integrity can be proved by ProVerif for
a model where write tokens are not changed. We manually
reconstruct the corresponding attacks from the derivations
output by ProVerif. The more basic integrity property con-
tinues to hold in this case, however.
4.4. Additional remarks
Below we list some more observations on the paper that
describes Plutus [32]:
• The following sentence appears in [32, Section 3.1]:
With ﬁlegroups, all ﬁles with identical shar-
ing attributes are grouped in the same ﬁle-
group . . .
Under this interpretation, each group is tied to a par-
ticular set of sharing attributes (writers and readers).
So, if two ﬁles happen to have the same sharing at-
tributes after some changes of sharing attributes, then
these two ﬁles should join the same ﬁlegroup even if
they initially belonged to different ﬁlegroups. Such a
join actually does not happen in Plutus.
• The following sentence appears in [32, Section 3.4]:
A revoked reader . . . will never be able to
read data updated since . . . [its] revoca-
tion.
We clarify that if a reader that is revoked at version v
colludes with a corrupt reader or writer at any v0 > v,
or is itself a reader or writer at such v0, it is able to read
data updated in the interval v + 1, . . . , v0.
• The following sentence appears in [32, Section 3.5.2]:
If the writers have no read access, then they
never get the . . . [lockbox key], and so it
is hard for them to determine the ﬁle-verify
key from the ﬁle-sign key.
The claim here is wrong. Writers always get the lock-
box key (to encrypt data), so they can always construct
the verify key (just as well as readers can).
• The following sentence appears in [32, Section 3.2]:
In order to ensure the integrity of the con-
tents of the ﬁles, a cryptographic hash of
the ﬁle contents is signed . . .
We clarify that contents should be signed after be-
ing encrypted (as in our model), for security in the
computational model of cryptography.
Indeed, sign-
ing encrypted contents allows one to use a weaker en-
cryption scheme: the encryption scheme needs to be
only IND-CPA (indistinguishable under chosen plain-
text attacks), with the signature providing integrity
of the ciphertext. Signing contents in the clear in-
stead requires a stronger security assumption for the
encryption scheme, that allows the adversary to call
the decryption oracle. This point is similar to the fact
that when the encryption is IND-CPA and the MAC
is UF-CMA (unforgeable under chosen message at-
tacks), encrypt-then-MAC (in which the MAC is ap-
plied to the ciphertext) guarantees the secrecy of the
plaintext, while encrypt-and-MAC (in which the MAC
is applied to the plaintext) does not [9]. Here, the sig-
nature plays the role of the MAC.
• As noted in [26, Section 3], the key rotation scheme
in [32] is not provable in the computational model
of cryptography under reasonable assumptions (one-
wayness of RSA and IND-CPA symmetric encryp-
tion), because a key obtained by unwinding is not in-
distinguishable from a random key when one has ac-
cess to other winded versions of this key. This prob-
lem is out of scope of our veriﬁcation since we work in
the Dolev-Yao model of cryptography. Recently sev-
eral other rotation schemes have been proposed, and
their cryptographic security properties have been for-
mally studied [6, 7, 26]. One can note that the attacks
discussed in this section do not depend on the speciﬁc
scheme for generating, winding, and unwinding lock-
box keys. Our results continue to hold if we change the
rotation scheme to a hash-chaining scheme [26, Sec-
tion 5.1], for instance. They also continue to hold if
lockbox keys are hashed before they are used for en-
cryption, as proposed in [26, Section 5.3] and [7, Sec-
tion 4.2] to correct the key rotation scheme in [32].
The scripts used in this paper are available at http://
www.soe.ucsc.edu/∼avik/projects/plutus/.
5. Conclusion
We have formally studied an interesting, state-of-the-
art protocol for secure ﬁle sharing on untrusted storage (in
the ﬁle system Plutus), and analyzed its security properties
in detail using the automatic veriﬁer ProVerif. Our study
demonstrates that protocols for secure storage are worth an-
alyzing.
Indeed, the analysis vastly improves our under-
standing of the above protocol; we formally specify and
verify its security properties, ﬁnd (and ﬁx) some unknown
attacks, and clarify some design details that may be rele-
vant for other storage protocols. Working in the Dolev-Yao
model allows a deep analysis of the security consequences
of some promising new features of the protocol. At the
same time, some consequences remain beyond the scope of
a Dolev-Yao analysis. It should be interesting to study those
consequences in the computational model, perhaps using an
automated veriﬁer like CryptoVerif [10, 13]. Unfortunately,
our initial attempts at modeling the protocol in CryptoVerif
indicate that the tool is presently not mature enough to prove
the relevant properties. We therefore postpone that study to
a point at which tools for proofs in the computational model
are more developed.
Over the years, storage has assumed a pervasive role in
modern computing, and understanding secure storage has
become as important as understanding secure communica-
tion. The study of secure communication has taught us the
importance of rigor in the design and analysis of protocols.
This observation certainly applies to secure storage as well.
As far as we know, we are the ﬁrst to present an automated
formal analysis of a secure storage protocol. Our approach
should be fruitful for other secure storage protocols, and we
expect to see further work in this new area.
Acknowledgments
We would like to thank Mart´ın Abadi for helpful discus-
sions on this work and comments on a draft of this paper.
Bruno Blanchet’s work was partly supported by the ANR
project ARA SSIA FormaCrypt. Avik Chaudhuri’s work
was partly supported by the National Science Foundation
under Grants CCR-0208800 and CCF-0524078.
References
[1] M. Abadi. Secrecy by typing in security protocols. Journal
of the ACM, 46(5):749–786, 1999.
[2] M. Abadi and B. Blanchet. Analyzing security protocols
with secrecy types and logic programs. Journal of the ACM,
52(1):102–146, 2005.
[3] M. Abadi and C. Fournet. Mobile values, new names,
In Proc. ACM SIGPLAN-
and secure communication.
SIGACT Symposium on Principles of Programming Lan-
guages (POPL’01), pages 104–115. ACM, 2001.
[4] M. Abadi and A. D. Gordon. A calculus for cryptographic
protocols: The spi calculus. Information and Computation,
148(1):1–70, 1999.
[5] X. Allamigeon and B. Blanchet. Reconstruction of attacks
In Proc. IEEE Computer
against cryptographic protocols.
Security Foundations Workshop (CSFW’05), pages 140–
154. IEEE, 2005.
[6] M. Backes, C. Cachin, and A. Oprea. Lazy revocation in
cryptographic ﬁle systems. In Proc. IEEE Security in Stor-
age Workshop (SISW’05), pages 1–11. IEEE, 2005.
[7] M. Backes, C. Cachin, and A. Oprea. Secure key-updating
for lazy revocation. In Proc. European Symposium on Re-
search in Computer Security (ESORICS’06), volume 4189
of LNCS, pages 327–346. Springer, 2006.
[8] M. Backes, A. Cortesi, and M. Maffei. Causality-based
In Proc.
abstraction of multiplicity in security protocols.
IEEE Computer Security Foundations Symposium (CSF’07),
pages 355–369. IEEE, 2007.
[9] M. Bellare and C. Namprempre. Authenticated encryption:
Relations among notions and analysis of the generic compo-
sition paradigm. In Proc. International Conference on the
Theory and Application of Cryptology & Information Secu-
rity (ASIACRYPT’00), volume 1976 of LNCS, pages 531–
545. Springer, 2000.
[10] B. Blanchet. A computationally sound mechanized prover
IEEE Transactions on Dependable
for security protocols.
and Secure Computing. To appear. Technical report version
available as ePrint Report 2005/401, http://eprint.
iacr.org/2005/401.
[11] B. Blanchet. An efﬁcient cryptographic protocol veriﬁer
In Proc. IEEE Computer Secu-
based on Prolog rules.
rity Foundations Workshop (CSFW’01), pages 82–96. IEEE,
2001.
[12] B. Blanchet. From secrecy to authenticity in security pro-
In Proc. International Static Analysis Symposium
tocols.
(SAS’02), volume 2477 of LNCS, pages 342–359. Springer,
2002.
[13] B. Blanchet. Computationally sound mechanized proofs
In Proc. IEEE Computer
of correspondence assertions.
Security Foundations Symposium (CSF’07), pages 97–111.
IEEE, 2007. Extended version available as ePrint Report
2007/128, http://eprint.iacr.org/2007/128.
[14] B. Blanchet. Automatic veriﬁcation of correspondences for
security protocols. Report arXiv:0802.3444v1, 2008. Avail-
able at http://arxiv.org/abs/0802.3444v1.
[15] M. Blaze. A cryptographic ﬁle system for unix.
In Proc.
ACM Conference on Computer and Communications Secu-
rity (CCS’93), pages 9–16. ACM, 1993.
[16] C. Bodei, M. Buchholtz, P. Degano, F. Nielson, and H. R.
Nielson. Static validation of security protocols. Journal of
Computer Security, 13(3):347–390, 2005.
[17] D. Boneh. Twenty years of attacks on the RSA cryp-
tosystem. Notices of the American Mathematical Society,
46(2):203–213, 1999.
[18] A. Chaudhuri. Dynamic access control in a concurrent ob-
In Proc. International Conference on Con-
ject calculus.
currency Theory (CONCUR’06), pages 263–278. Springer,
2006.
[19] A. Chaudhuri. On secure distributed implementations of dy-
namic access control. Technical Report UCSC-CRL-08-01,
University of California at Santa Cruz, 2008.
[20] A. Chaudhuri and M. Abadi. Formal security analysis of
basic network-attached storage. In Proc. ACM Workshop on
Formal Methods in Security Engineering (FMSE’05), pages
43–52. ACM, 2005.
[21] A. Chaudhuri and M. Abadi. Formal analysis of dynamic,
distributed ﬁle-system access controls. In Proc. IFIP WG6.1
Conference on Formal Techniques for Networked and Dis-
tributed Systems (FORTE’06), volume 4229 of LNCS, pages
99–114. Springer, 2006.
[22] A. Chaudhuri and M. Abadi. Secrecy by typing and ﬁle-
access control. In Proc. IEEE Computer Security Founda-
tions Workshop (CSFW’06), pages 112–123. IEEE, 2006.
[23] D. E. Denning and G. M. Sacco. Timestamps in key distri-
bution protocols. Communications of the ACM, 24(8):533–
536, 1981.
[24] D. Dolev and A. C. Yao. On the security of public
key protocols. IEEE Transactions on Information Theory,
29(12):198–208, 1983.
[25] K. Fu. Group sharing and random access in cryptographic
storage ﬁle systems. Master’s thesis, Massachusetts Institute
of Technology, 1999.
[26] K. Fu, S. Kamara, and Y. Kohno. Key regression: Enabling
efﬁcient key distribution for secure distributed storage. In
Proc. Network and Distributed System Security Symposium
(NDSS’06). Internet Society (ISOC), 2006.
[27] H. Gobioff, G. Gibson, and J. Tygar. Security for network
attached storage devices. Technical Report CMU-CS-97-
185, Carnegie Mellon University, 1997.
[28] E.-J. Goh, H. Shacham, N. Modadugu, and D. Boneh. SiR-
iUS: Securing remote untrusted storage. In Proc. Network
and Distributed System Security sympositum (NDSS’03),
pages 131–45. Internet Society (ISOC), 2003.
[29] A. Gordon and A. Jeffrey. Authenticity by typing for se-
curity protocols. Journal of Computer Security, 11(4):451–
521, 2003.
[30] S. Halevi, P. A. Karger, and D. Naor. Enforcing conﬁnement
in distributed storage and a cryptographic model for access
control. Cryptology ePrint Archive, Report 2005/169, 2005.
Available at http://eprint.iacr.org/2005/169.
[31] M. Kallahalla, E. Riedel, and R. Swaminathan. System
for enabling lazy-revocation through recursive key gener-
ation. United States Patent 7203317. Details available
online at http://www.freepatentsonline.com/
7203317.html, 2007.
[32] M. Kallahalla, E. Riedel, R. Swaminathan, Q. Wang, and
K. Fu. Plutus: Scalable secure ﬁle sharing on untrusted stor-
age. In Proc. USENIX Conference on File and Storage Tech-
nologies (FAST’03), pages 29–42. USENIX, 2003.
[33] G. Lowe. Breaking and ﬁxing the Needham-Schroeder
In Proc. Tools and
public-key protocol using FDR.
Algorithms for the Construction and Analysis of Sys-
tems (TACAS’96), volume 1055 of LNCS, pages 147–166.
Springer, 1996.
[34] D. Mazi`eres and D. Shasha. Building secure ﬁle systems out
of byzantine storage. In Proc. ACM Symposium on Princi-
ples of Distributed Computing (PODC’02), pages 108–117.
ACM, 2002.
[35] E. L. Miller, W. E. Freeman, D. D. E. Long, and B. C.
In
Reed. Strong security for network-attached storage.
Proc. USENIX Conference on File and Storage Technologies
(FAST’02), pages 1–14. USENIX, 2002.
[36] D. Naor, A. Shenhav, and A. Wool. Toward securing un-
In Proc.
trusted storage without public-key operations.
ACM Workshop on Storage Security and Survivability (Stor-
ageSS’05), pages 51–56. ACM, 2005.
[37] L. C. Paulson. The inductive approach to verifying cryp-
tographic protocols. Journal of Computer Security, 6(1–
2):85–128, 1998.
[38] M. Pistoia, A. Banerjee, and D. A. Naumann. Beyond stack
inspection: A uniﬁed access-control and information-ﬂow
security model. In Proc. IEEE Symposium on Security and
Privacy (S&P’07), pages 149–163. IEEE, 2007.
[39] R. Rivest, A. Shamir, and L. Adleman. A method for obtain-
ing digital signatures and public key cryptosystems. Com-
munications of the ACM, 21(2):120–126, 1978.
[40] D. Wagner and B. Schneier. Analysis of the SSL 3.0 proto-
col. In Proc. USENIX Workshop on Electronic Commerce,
pages 29–40. USENIX, 1996.
[41] T. Y. C. Woo and S. S. Lam. A semantic model for authenti-
cation protocols. In Proc. IEEE Symposium on Security and
Privacy (S&P’93), pages 178–194. IEEE, 1993.
[42] L. Zheng and A. Myers. Dynamic security labels and
In Proc. IFIP WG1.7 Workshop on For-
noninterference.
mal Aspects in Security and Trust (FAST’04), pages 27–40.
Springer, 2004.