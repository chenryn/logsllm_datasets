5.4 Developer-Deﬁned Policies
XiOS allows the creation and integration of developer-
deﬁned policies. While the ﬁrst one is highly dependent on
the application that the policies are made for, for the sec-
ond one we have implemented an easy way to add policies.
Speciﬁcally, the developer provides XiOS with two prede-
ﬁned functions, i.e., pre external call and post external call,
that are executed before and after each external function
call. These functions need to be implemented in C and self-
contained, i.e., cannot use other external functions such as
memcpy as this would end up intercepted by XiOS and cre-
ate a loop. In order to facilitate the job of the developer we
can provide her with a set of pre-deﬁned functions, e.g., she
can use xios memcpy instead of memcpy.
Within the pre external call and post external call func-
tions, the developer has access to the function name, argu-
ments and return value. Note that the return of a func-
tion can be a value or a pointer referring to internal buﬀers.
XiOS can handle both cases. However, each external func-
tion takes a diﬀerent number of arguments and returns a
diﬀerent type; thus, the developer must be aware of the sig-
nature for the functions she aims to handle. Moreover, with
XiOS, the return values and the arguments can be changed.
The following code snippet shows an example where an ex-
ternal call to the NSLog function will not be allowed:
i n t p r e e x t e r n a l c a l l ( const char ∗ f u n c t i o n n a m e ,
const unsigned long r e g s [ ] ) {
char n s l o g [ 6 ] = ”NSLog ” ;
i f
( x i o s s t r c m p ( f u n c t i o n n a m e , n s l o g ) == 0 )
return FAIL ;
}
Note that the reference monitor does not diﬀerentiate be-
tween invocations of C functions or Objective-C methods, as
the Objective-C mechanism dispatches all objects’ methods
through a generic C function called objc msgSend. With
XiOS both can be analyzed in the same manner within the
two pre-deﬁned functions.
Developing self-contained policies in C maybe cumber-
some. Hence, we are currently working on a service where
the developer submits the app, and uses a simple interface
to deﬁne rules and triggers XiOS ’s hardening mechanism.
This will enable convenient deﬁnition of custom policies.
6. EVALUATION
In this section we present a detailed evaluation of XiOS
with respect to its eﬀectiveness and eﬃciency. First, we
analyze the eﬀectiveness of our hardening process against
previous and our own new attacks (see Section 2.2 and 3).
Then, we evaluate the performance impact of our changes on
the application, and measure the overhead they impose on a
randomly selected set of both C and Objective-C functions.
Moreover, we evaluate our hardening mechanism on several
real-world applications.
6.1 Effectiveness
In order to test the eﬀectiveness of XiOS we use our ma-
licious sample application that we introduced in Section 3.
In particular, we modiﬁed our sample application so that it
includes both attack types: (1) exploiting a runtime address
of a public API ([19, 35] and Section 2.2), and (2) exploit-
ing the runtime address of the dynamic loader function to
resolve lazy symbols (Section 3). To this end, we ﬁrst ap-
ply XiOS to our sample malicious application. Afterwards,
we deploy the hardened application on our test iOS device
(iPhone 4 running iOS 7.0).
Previous Attacks: To test XiOS against previous attacks,
we let our malicious application de-reference the runtime
address of a public API. Speciﬁcally, we invoke the CGIm-
ageSourceCreateWithURL public API residing in the public
ImageIO framework as ImageIO contains references to load-
library and load-address. Since the runtime address of the
public API is lazily resolved on-demand, its runtime address
will be stored in the lazy symbol section after we have called
the public API during normal program execution. However,
since XiOS completely overwrites the original lazy and non-
lazy symbol section with zeroes, the de-referenced value will
be always zero rather than the runtime address of CGImage-
SourceCreateWithURL. In XiOS, the runtime address of the
public API is on the shadow table which is only accessible
from the XiOS reference monitor. This eﬀectively prevents
the ﬁrst attack step of previous attacks [19, 35].
Our New Attack: Recall that our improved attack does
not require the knowledge of a public API runtime address.
printf
mmap
strerror NSString alloc NSUserName NSTemporaryDirectory
1 Policy Check
10 Policy Checks
100 Policy Checks
0.029459
0.037107
0.140015
-0.018641
-0.002330
0.088113
0.016662
0.023010
0.091601
0.041377
0.063399
0.260605
-0.013764
0.105262
0.334400
0.096091
0.058099
0.228264
Table 1: Overhead for 10,000 calls (in seconds)
Instead, our attack attempts to access the runtime address
of the dynamic loader function dyld_stub_binder which is
present in every iOS application in the non-lazy symbol sec-
tion. XiOS successfully prevents this attack similar to the
previous attack as it hides runtime addresses of external
functions contained in the non-lazy symbol section by over-
writing this section with zero and maintaining the runtime
addresses in the protected shadow table.
To summarize, in both attack instances (previous and our
new one), XiOS prevents the malicious application from
determining critical runtime addresses of function pointers
that could be exploited to invoke a private API.
Since the pointers in the lazy and non-lazy symbol sec-
tion are no longer available to the adversary, he may try to
leak function addresses by inspecting return buﬀers, return
values and return register values in public APIs that can be
called. We prevent this by the use of policies that inspect
the return information of a public API and zeroise or replace
any sensitive pointer data.
On the other hand, the adversary could perform a com-
plete memory scan to identify private APIs and dynamic
loader functions based on signature or instruction matching.
However, this requires the adversary to know exactly the lo-
cation of all mapped memory pages. Otherwise, the appli-
cation will crash upon read access on non-mapped memory.
Moreover, many consecutive read operations from main ap-
plication code to shared library code resembles a program
anomaly which one can certainly monitor at runtime.
A current limitation of XiOS are attacks through an ad-
dress of a global external variable stored in the non-lazy
symbol section. This allows an adversary to use oﬀset-based
computation to retrieve the address of dynamic loader func-
tions. We successfully tested this attack and it is indeed
currently feasible in iOS, since the shared library code and
its data section are always located at the same oﬀset, ir-
respective of ASLR. Such attacks are only possible as the
ASLR scheme implemented in iOS does not randomize the
oﬀset between the data and code section. Since our focus in
XiOS resides on attacks based on function pointers and more
ﬁne-grained ASLR solves the issue, we did not implement
a mechanism to hide data pointers which is an orthogonal
problem and we leave as future work.
6.2 Efﬁciency
Our hardening mechanism is deployed by the reference
monitor for each function call. The overhead is constant ir-
respective of the type of function called and depends on the
number of policies. As described in Section 4.3, we intercept
only calls to external functions. Thus, the main application
code and instructions from shared libraries execute with na-
tive performance.
In order to determine the overhead of our approach per
external call, we have selected a variety of functions and
evaluated their execution time. Speciﬁcally, we have imple-
mented an application that calls only the tested function and
implanted a set of 1, 10, 100 policies using XiOS. We mea-
sure the execution time when running the application with
and without policy enforcement. Each of the selected func-
tions runs for 10,000 times. Note that the selected policies
only perform a sanity check (i.e., verify the function’s name
and print its arguments) and do not prohibit execution of
functions as this would end the testing procedure.
We present the results in Table 1. The overhead for run-
ning Objective-C functions 10,000 times is, at most, only
of 0.33s, while the overhead for native-C functions is only
0.14s in the case of 100 policies. The negative numbers dis-
played for mmap and NSUserName show that the hardened
application was actually faster than the vanilla version. This
is due to the fact that we do not control how the operating
system scheduler (i.e., closed-source OS) aﬀects our tests.
During our tests, we analyzed the average number of func-
tion calls per second inside an app. For normal use (clicks,
accessing resources) there are no more than 1,000 function
calls per second. This means, that if an app were to use only
the functions listed in Table 1 the overhead would at most
be 0.033s; less than 5%.
We applied our enforcements on a popular iOS bench-
mark tool called Gensystek [1]. Figure 5 shows results for
eight diﬀerent benchmarks with diﬀerent number of threads
(1, 2 and 4) and with diﬀerent number of policy checks
(1, 10 and 100). The computation of an MD5 hash dis-
plays the most noticeable slowdown of 3.9x. However, simi-
lar heavy-CPU computation such as Floating point calcula-
tion/Arithmetic logical unit (FPU/ALU) show an overhead
of only 1.5% when tested against 100 policy checks. The
overhead for taking and saving a screenshot to disk is 4.3%.
Moreover, XiOS induces less overhead than previous work,
e.g., MoCFI adds up to 500% overhead for the PI calcula-
tion [15]. Note that every external function called is applied
the 100 policy checks, irrespective of what the function does,
as these checks were part of the reference monitor implemen-
tation. Within a more realistic scenario, there would only
be a handful of functions that do these many policy checks,
reducing the overall incurred overhead.
In terms of required memory, our experiments with XiOS
on real applications show that no additional space is required
for storing the reference monitor inside the executable. This
is due to the fact that the reference monitor requires only
1KB and can be stored in unused space of the binary, such
as the __TEXT segment. The shadow table requires 4K and
is allocated dynamically when the application is executed.
In our evaluation, less than 1KB was required for one policy.
However, if complex policies (hence, more space required for
storing the policies) are to be inserted, new code sections and
memory pages can be added at the end of the application.
Figure 5: Gensystek Benchmark
No. of policies
SysMonitor
Frotz MusicNotes
1
10
100
-8.78% -9.05%
3.68% 2.25%
21.39% 10.35%
1.74%
-9.69%
-2.49%
Table 2: Loss in number of external functions calls
6.3 Study of Real World Apps
To demonstrate the eﬀectiveness of our approach, we tested
XiOS on several real-world applications such as Facebook,
Twitter, Gmail, Youtube. In our experiences with the hard-
ened applications we encountered no overhead. Moreover,
we used our hardening service to apply policies to several ap-
plications such as System Monitor, Frotz, WhatsApp, Mu-
sicNotes and Gensystek. For testing the application behav-
ior we sequentially used a number of 1, 10, and 100 policies
and measured the number of external function calls with and
without XiOS in a time frame of 30s. As before, policies are
conﬁgured to allow all external calls.
In order to access
the application’s binary (as iOS stores them encrypted), we
made use of a well established tool, namely Clutch [14].
We compared ”vanilla” application runs against hardened
application runs. The results are shown in Table 2 as the
percentage of loss in the number of external calls. Remark-
ably, XiOS does not reduce the number of external calls
that are made within a given time frame. A noticeable
overhead of 21% is noticed only when XiOS is conﬁgured
with 100 policies for each external function call which is far
from realistic but represents worst-case scenarios. The Mu-
sicNotes application allows users to play diﬀerent sounds at
a touch of a screen-keyboard. We did not encounter any
noticeable delay when performing diﬀerent tests.
6.4 Access Control on Public Applications
XiOS allows enterprises to create and apply their own
policies on any application available on the App Store. In
order to demonstrate how such policies can be created we
have chosen one of the most used application today, namely
the instant messenger WhatsApp [3]. One particular feature
of WhatsApp is that it uses the phone number for identifying
diﬀerent users in the network. Moreover, the full address
book is copied to the developer servers when the application
is installed. XiOS allows ﬁltering of the contacts to avoid
that WhatsApp retrieves all the user’s contacts.
Before creating the ﬁltering policies we need to identify
which functions are relevant and need to be instrumented.
To do so, XiOS provides a script that can be used to iden-
tify all external functions invoked by the application along
with the framework that they belong to. Speciﬁcally, What-
sApp uses ABAddressBookGetPersonWithRecordID within
the AddressBook framework to extract the contacts from
the address book.
Next, the developer can check the function’s signature and