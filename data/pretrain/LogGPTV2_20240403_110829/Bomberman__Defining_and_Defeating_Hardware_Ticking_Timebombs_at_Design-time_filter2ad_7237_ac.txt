SSCs that could be part of a TTT. The Bomberman dynamic
analysis framework is broken into two phases:
1) SSC IdentiÔ¨Åcation, and
2) SSC ClassiÔ¨Åcation.
During the SSC IdentiÔ¨Åcation phase, Bomberman identiÔ¨Åes
all coalesced and distributed SSCs within the design. During
the SSC ClassiÔ¨Åcation phase, Bomberman analyzes the value
progressions of all SSCs to identify suspicious SSCs that may
comprise a TTT. Fig. 5 illustrates the Bomberman architecture.
A. SSC IdentiÔ¨Åcation
The Ô¨Årst step in locating TTTs, is identifying all SSCs
in the design. Identifying coalesced SSCs is straightforward:
any component in the HDL that may be synthesized into
a coalesced collection of Ô¨Çip-Ô¨Çops (or latches ¬ßVII-2) is
considered a coalesced SSC. Enumerating distributed SSCs
is more challenging. Since distributed SSCs are comprised
of various combinations of coalesced SSCs that are inter-
connected the host circuit, a naive approach would be to
enumerate the power set of all coalesced SSCs in the design.
However, this creates an obvious state-explosion problem, and
is unnecessary. Instead, we take advantage of the fact that
not every component in a circuit is connected to every other
component. Moreover, the structure of the circuit itself tells us
what connections between coalesced SSCs are possible, and
thus the distributed SSCs Bomberman must track.
Therefore, we break the SSC IdentiÔ¨Åcation phase into two
sub-stages: 1) Data-Flow Graph (DFG) Generation, and 2)
SSC Enumeration (Fig. 5A). First, we generate a DFG from
a circuit‚Äôs HDL, where each node in the graph represents a
signal, and each edge represents connections between signals
facilitated by intermediate combinational or sequential logic.
Then, we systematically traverse the graph to enumerate: 1)
the set of all coalesced SSCs, and 2) the set of all connected
coalesced SSCs, or distributed SSCs.
1) DFG Generation: We implement the DFG Generation
stage of the SSC IdentiÔ¨Åcation phase using the open-source
Icarus Verilog (IVL) [46] compiler front-end with a custom
back-end written in C++. Our custom IVL back-end traverses
the intermediate HDL code representation generated by the
IVL front-end, to piece together a bit-level signal dependency,
or data-Ô¨Çow, graph. In doing so,
it distinguishes between
Authorized licensed use limited to: Tsinghua University. Downloaded on February 25,2022 at 12:30:57 UTC from IEEE Xplore.  Restrictions apply. 
974
state-saving signals (i.e., signals gated by Ô¨Çip-Ô¨Çops) and inter-
mediate signals output from combinational logic. Continuous
assignment expressions are the most straightforward to capture
as the IVL front-end already creates an intermediate graph-
like representation of such expressions. However, procedural
assignments are more challenging. SpeciÔ¨Åcally, at the RTL
level, it is up to the compiler to infer what HDL signals
will synthesize into SSCs. To address this challenge, we use
a similar template-matching technique used by modern HDL
compilers [47], [48]. The data-Ô¨Çow graph is expressed using
the Graphviz .dot format. Fig. 11 in Appendix C shows an
example data-Ô¨Çow graph generated by Bomberman.
2) SSC Enumeration: We implement the SSC Enumeration
stage of the SSC IdentiÔ¨Åcation phase using a script written
in Python. First, our SSC Enumeration script iterates over
every node in the circuit DFG, and identiÔ¨Åes nodes (signals)
that are outputs of registers (Ô¨Çip-Ô¨Çops). The script marks
these nodes as coalesced SSCs. Next, the script performs a
Depth-First Search (DFS), starting from each non-coalesced
SSC signal node, to piece together distributed SSCs. The
DFS backtracks when an input or coalesced SSC signal is
reached. When piecing together distributed SSCs, Bomberman
does not take into account word-level orderings between root
coalesced SSCs. The order of the words, and thus the bits,
of the distributed SSC does not affect whether it satisÔ¨Åes
or violates the properties of our deÔ¨Ånition of a TTT trigger
(¬ßIV-A). Our deÔ¨Ånition does not care about the progression of
values expressed by the SSC(s), but only cares if all values are
not expressed and individual values are not repeated. Note, a
clever attacker may try to avoid detection by selecting a slice
of a single coalesced SSC to construct a ticking timebomb
trigger. However, our implementation of Bomberman classiÔ¨Åes
a single sliced coalesced SSC as a distributed SSC with a
single root coalesced SSC.
Algorithm 1: SSC ClassiÔ¨Åcation Algorithm
Input: Set, P , of all possible SSCs
Output: Set, S, of all suspicious SSCs
1 S ‚Üê P ;
2 foreach p ‚àà P do
*/
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17 end
n ‚Üê SizeOf (p);
Vp ‚Üê ‚àÖ; /* previous values of p
foreach t ‚àà T do
value ‚Üê V alueAtT ime(p, t);
if value ‚àà Vp then
Remove p from S;
Break;
Add value to Vp;
else
end
end
if (cid:7)Vp(cid:7) == 2n then
Remove p from S;
end
B. SSC ClassiÔ¨Åcation
After all SSCs have been enumerated, Bomberman analyzes
the values expressed by every SSC during veriÔ¨Åcation sim-
ulations to classify whether each SSC is either suspicious‚Äî
meaning it could construct a TTT‚Äîor benign. Bomberman be-
gins by assuming all SSCs within the design are suspicious. At
every update time within the simulation, Bomberman checks
to see if any SSC expresses a value that causes it to violate
either property of our deÔ¨Ånition (¬ßIV-A). If a property is
violated, the SSC no longer meets the speciÔ¨Åcations to be part
of a TTT, and Bomberman classiÔ¨Åes it benign. Bomberman
does not care how, when, what, or the amount an SSC‚Äôs
value is incremented; rather, Bomberman only monitors if
an SSC repeats a value, or enumerates all possible values.
Lastly, Bomberman reports any remaining suspicious SSCs for
manual analysis by veriÔ¨Åcation engineers.
the
We
implement
SSC ClassiÔ¨Åcation
algorithm‚Äî
Algorithm 1‚Äîusing Python. Our classiÔ¨Åcation program
(Fig. 5B) takes as input a Value Change Dump (VCD)
Ô¨Åle, encoding the veriÔ¨Åcation simulation results, and cross-
references the simulation results with the set of suspicious
SSCs,
initially generated by the SSC IdentiÔ¨Åcation stage
(Fig. 5A). For coalesced SSCs, this is trivial: our analysis
program iterates over the values expressed by each coalesced
SSC during simulation, and tests if either property from our
deÔ¨Ånition (¬ßIV-A) is violated. SSCs that break our deÔ¨Ånition
of a TTT are marked benign. However, distributed SSCs are
more challenging. To optimize Ô¨Åle sizes, the VCD format
only records signal values when they change, not every clock
cycle. This detail
is important when analyzing distributed
SSCs, whose root coalesced SSCs may update at different
times. We address this detail by time-aligning the root
coalesced SSC values with respect to each other to ensure
the recording of all possible distributed SSC values expressed
during simulation. Finally, any remaining suspicious SSCs
are compiled into a JSON Ô¨Åle, and output for veriÔ¨Åcation
engineers to inspect and make a Ô¨Ånal determination on
whether or not the design contains TTTs.
VI. EVALUATION
By construction Bomberman cannot produce false negatives
since it initially assumes all SSCs are suspicious, and only
marks SSCs as benign if they express values during simulation
that violate the deÔ¨Ånition of TTT SSC behavior. However,
false positives are possible. To quantify Bomberman‚Äôs false
positives rate, we evaluate Bomberman against four real-world
hardware designs with TTTs implanted in them. To model a
production simulation-based veriÔ¨Åcation Ô¨Çow, we use a mix of
existing test vectors (from each core‚Äôs repository), random test
vectors (commonly used to improve coverage), and custom test
vectors (to Ô¨Åll coverage gaps). To contextualize Bomberman‚Äôs
effectiveness compared to state-of-the-art TTT defenses, we
build an end-to-end (E2E) TTT‚Äîthat uses a pseudorandom
sequence to trigger a privilege escalation within a processor‚Äî
that evades all defenses except Bomberman. Lastly, we provide
an asymptotic complexity analysis of the Bomberman frame-
work, and characterize Bomberman‚Äôs performance in practice.
A. Experimental Setup
1) Hardware Designs: We evaluate Bomberman against
four open-source hardware designs: 1) an AES accelera-
975
Authorized licensed use limited to: Tsinghua University. Downloaded on February 25,2022 at 12:30:57 UTC from IEEE Xplore.  Restrictions apply. 


	

	

	

	


	

	'

$&$

"'

 "
$


"'

 "
"'
&%$  $ "
!"$&$


# %#


)

*+
(&
 "'
	


	

"'

 "



"'
&%$  $ "
(&
-.,,

*+
 "'
*+
*+
)/
$%#
# %#
Fig. 6. Hardware Testbenches. Testbench architectures for each DUT (outlined in red). For the AES and UART designs, LFSRs generate random inputs
for testing. For the RISC-V and OR1200 CPUs, we compile ISA-speciÔ¨Åc assembly programs [18], [49] into executables to exercise each design.
the testbench controller resets and initializes the Wishbone bus
arbiter, LFSR, and DUT, and begins testing.
RISC-V CPU. The RISC-V CPU contains 32 general-
purpose registers, a built-in interrupt handler, and interfaces
with other on-chip peripherals through a 32-bit AXI-4 Lite or
Wishbone bus interface. We instantiate an AXI-4 Lite bus ar-
biter to connect the DUT with a simulated main memory block
to support standard memory-mapped I/O functions (Fig. 6C).
The testbench controller has two main jobs after it initializes
and resets all components within. First, it initializes main
memory with an executable to be run on the bare metal CPU.
These programs are in the form of .hex Ô¨Åles that are compiled
and linked from RISC-V assembly or C programs using the
RISC-V cross-compiler toolchain [50]. Second, it monitors the
progress of each program execution and receives any output
from an executing program from speciÔ¨Åc memory addresses.
We conÔ¨Ågure the testbench controller to run multiple programs
sequentially, without resetting the device.
OR1200 CPU. The OR1200 CPU implements the OR1K
RISC ISA. It contains a 5-stage pipeline, instruction and data
caches, and interfaces with other peripherals through a 32-bit
Wishbone bus interface. We instantiate a Wishbone bus arbiter
to connect the DUT with a simulated main memory block and
a UART module to support standard I/O functions (Fig. 6D).
The testbench controller has two jobs after it initializes and
resets all components within. First, it initializes main memory
with an executable to be run on the bare metal CPU. These
programs are in the form of .vmem Ô¨Åles that are compiled
and linked from OR1K assembly or C programs using the
OR1K cross-compiler toolchain [51]. Second, it monitors the
progress of each program execution and receives any program
output from the UART decoder. Like the RISC-V, we conÔ¨Ågure
the OR1200 testbench controller to run multiple programs
sequentially, without resets in between.
2) System Setup: As described in ¬ßV, Bomberman inter-
faces with Icarus Verilog (IVL). IVL is also used to perform all
veriÔ¨Åcation simulations of our four hardware designs. In both
cases, we use version 10.1 of IVL. Both IVL and Bomberman
were compiled with the Clang compiler (version 10.0.1) on
a MacBook Pro with a 3.1 GHz Intel Core i7 processor and
16 GB DDR3 RAM. All RTL simulations and Bomberman
analyses were also run on the same machine.
B. False Positives
We empirically quantify Bomberman‚Äôs false positive rate by
analyzing four real world hardware designs (¬ßVI-A1). Addi-
Fig. 7. Hardware Design Complexities. Histograms of the (coalesced)
registers in each hardware design.
tor [20], 2) a UART module [19], 3) a RISC-V CPU [18],
and 4) an OR1200 CPU [19]. Fig. 6 provides details on the
testing architectures we deployed to simulate each IP core.
We also summarize the size and complexity of each hardware
design in terms of the number of registers (i.e., potential
SSCs) in Fig. 7. The AES, RISC-V, and OR1200 designs
are shown to be the most computationally-intensive designs
for Bomberman to analyze, since they have large registers
(‚â•32-bits), i.e., potentially suspicious SSCs that can increment
almost indeÔ¨Ånitely.
AES Accelerator. The AES core operates solely in 128-bit
counter (CTR) mode. It takes a 128-bit key and 128-bits of
plaintext (i.e., a counter initialized to a random seed) as input,
and 22 clock cycles later produces the ciphertext. Note, the
design is pipelined, so only the Ô¨Årst encryption takes 22 clock
cycles, and subsequent encryptions are ready every following
clock cycle. We interface two Linear Feedback Shift Registers
(LFSRs) to the DUT to generate random keys and plaintexts
to exercise the core (Fig. 6A). Upon testing initialization,
the testbench controller resets and initializes both LFSRs (to
different random starting values) and the DUT. It then initiates
the encryption process, and veriÔ¨Åes the functionality of the
DUT is correct, i.e., each encryption is valid.
UART Module. The UART module interfaces with a
Wishbone bus and contains both a transmit (TX) and receive
(RX) FIFO connected to two separate 8-bit TX and RX shift
registers. Each FIFO holds a maximum of sixteen 8-bit words.
The core also has several CSRs, one of which conÔ¨Ågures
the baud rate, which we set to 3.125 MHz. We instantiate a
Wishbone bus arbiter to communicate with the DUT, and an
LFSR to generate random data bytes to TX/RX (Fig. 6B). We
also instantiate a UART encoder/decoder to receive, and echo
back, any bytes transmitted from the DUT. Upon initialization,
Authorized licensed use limited to: Tsinghua University. Downloaded on February 25,2022 at 12:30:57 UTC from IEEE Xplore.  Restrictions apply. 
976
.,&! 
!.,&! 
 
"
-  


!





!
&

-
+




!
&

-
+


	



!
&

-
+


!






!
&

-
+


!
