title:SOMA: mutual approval for included content in web pages
author:Terri Oda and
Glenn Wurster and
Paul C. van Oorschot and
Anil Somayaji
SOMA: Mutual Approval for Included Content in Web Pages
Terri Oda Glenn Wurster P. C. van Oorschot Anil Somayaji
Carleton Computer Security Lab
School of Computer Science
Carleton University, Canada
{toda, gwurster, paulv, soma}@scs.carleton.ca
ABSTRACT
Unrestricted information ﬂows are a key security weakness of cur-
rent web design. Cross-site scripting, cross-site request forgery,
and other attacks typically require that information be sent or re-
trieved from arbitrary, often malicious, web servers. In this paper
we propose Same Origin Mutual Approval (SOMA), a new pol-
icy for controlling information ﬂows that prevents common web
vulnerabilities. By requiring site operators to specify approved ex-
ternal domains for sending or receiving information, and by requir-
ing those external domains to also approve interactions, we prevent
page content from being retrieved from malicious servers and sensi-
tive information from being communicated to an attacker. SOMA
is compatible with current web applications and is incrementally
deployable, providing immediate beneﬁts for clients and servers
that implement it. SOMA has an overhead of one additional HTTP
request per domain accessed and can be implemented with minimal
effort by application and web browser developers. To evaluate our
proposal, we have developed a Firefox SOMA add-on.
Categories and Subject Descriptors
C.2 [General]: Security and protection; H.3 [Online Information
Services]: Web-based services
General Terms
Security, Experimentation
Keywords
web security, JavaScript, same origin policy, cross-site scripting
(XSS), cross-site request forgery (XSRF)
1.
INTRODUCTION
Current web pages are more than collections of static informa-
tion: they are a synthesis of code and data often provided by multi-
ple sources that are assembled and run in the browser. Users gener-
ally trust the web sites they visit; however, external content may be
Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proﬁt or commercial advantage and that copies
bear this notice and the full citation on the ﬁrst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciﬁc
permission and/or a fee.
CCS’08, October 27–31, 2008, Alexandria, Virginia, USA.
Copyright 2008 ACM 978-1-59593-810-7/08/10 ...$5.00.
untrusted, untrustworthy, or even malicious. Such malicious inclu-
sions can initiate drive-by downloads [26], misuse a user’s creden-
tials [13], or even cause distributed denial-of-service attacks [21].
One common thread in these scenarios is that the browser must
communicate with web servers that normally wouldn’t be contacted.
Those servers may be controlled by an attacker, may be victims,
or may be unwitting participants; whatever the case, information
should not be ﬂowing between the user’s browser and these sites.
In this paper, we propose a policy for constraining communica-
tions and inclusions in web pages. This policy, which we call Same
Origin Mutual Approval (SOMA), requires the browser to check
that both the site operator of the page and the third party content
provider approve of the inclusion before any communication is al-
lowed (including adding anything to a page). This “tightening”
of same origin policy prevents attackers from loading malicious
content from arbitrary web sites and restricts their ability to com-
municate sensitive information. While attacks such as cross-site
scripting are still possible, with SOMA they must be mounted from
domains trusted by the originating domain. Because attackers have
much less control over this small subset than they do over other ar-
bitrary hosts on the Internet, SOMA can prevent the exploitation of
a wide range of vulnerabilities in web applications.
In addition to being effective, SOMA is also a practical proposal.
To participate in SOMA, browsers have to make minimal code
changes and web sites must create small, simple policy ﬁles. Sites
and browsers participating in SOMA can see beneﬁts immediately,
while non-participating sites and browsers continue to function as
normal. These characteristics facilitate incremental deployment,
something that is essential for any change to Internet infrastructure.
We have implemented SOMA as an add-on for Mozilla Firefox
2 and 3, which can be run in any regular installation of the Firefox
browser. In testing with this browser and simulated SOMA policy
ﬁles for over 500 main pages on different sites, we have found no
compatibility issues with current web sites. The policy ﬁles for
these sites have been, with only a few exceptions, extremely easy
to create and cause no compatibility issues. Simulated attacks are
also appropriately blocked. To retrieve policy ﬁles, SOMA requires
an extra web request per new domain visited. As we explain in
Section 5, such overhead is minimal in practise. For these reasons,
we argue that SOMA is a practical, easy to adopt, and effective
proposal for improving the security of the modern web.
The remainder of this paper proceeds as follows. Section 2 gives
background on current web security rules and attacks on modern
web pages. Section 3 details the proposed Same Origin Mutual Ap-
proval design, which we then evaluate in Section 4. Our prototype
and the results of testing in the browser are described in Section 5.
We discuss some alternative browser security proposals and other
related work in Section 6. Section 7 concludes.
Permissions
Content
Fetch Read Modify
Type
YES
Images
HTML
YES
YES
JavaScript
Styles
YES
Audio/Video YES
SO
SO
SO
SO
Plugin Dependant
SO
SO
YES
YES
Execute
NO
NO
YES
NO
NO
Table 1: Current JavaScript access to other content (permis-
sions denoted SO are dictated by the Same Origin Policy)
2. BACKGROUND AND MOTIVATION
Web browsers are programs that regularly engage in extensive
cross-domain communication.
In the course of a user viewing a
web page, they will retrieve images from one server, advertisements
from another, and post a user’s responses to a third. In this way the
browser serves as a dynamic, cross-domain communications nexus.
While such promiscuity may be permissible when combining static
data, to maintain security, restrictions must be placed upon exe-
cutable content.
JavaScript has two main security features that limit the potential
damage of malicious scripts: the sandbox and the same origin pol-
icy. Assuming there are no bugs in the implementation, the sand-
box prevents JavaScript code from affecting the underlying system
or other web browser instances (including other tabs). Each page
is contained within its own sandbox instance. The same origin pol-
icy [31] helps to deﬁne what can be manipulated within this sand-
box and how sandboxed code can communicate with the outside
world. The same origin policy is designed to prevent documents or
scripts loaded from one “origin” from getting, or setting properties
of, content loaded from a different origin (with a special case in-
volving subdomains). The origin is deﬁned as the protocol, port,
and host from which the content originated. While scripts from
different origins are not allowed to access each other’s source, the
functions in one script can be called from another script in the same
page even if the two scripts are from different domains. JavaScript
code has different access restrictions depending on the type of con-
tent being loaded. For example, it can fetch (make a request for)
HTML, but it can only read and modify the information it gets as a
result if the HTML falls within the same origin. These restrictions
are summarized in Table 1.
Any script included onto a page inherits the origin of that page.
This means that if a page from http://example.com includes
a script from advertiser.com, this script is considered to have
the origin http://example.com. This allows the script to
modify the web page from example.com. It is important to note
that many scripts, including scripts dealing with embedding adver-
tisements, require this ability. The script cannot subsequently read
or modify content originating from advertiser.com directly;
it can only read and modify content from example.com, or con-
tent which has inherited that origin.
While the sandbox and same origin policy protect the host and
prevent many types of network communication, opportunities for
recursive script inclusion, unrestricted outbound communication,
cross-site request forgery, and cross-site scripting allow consider-
able scope for security vulnerabilities. We explore each of these
issues below.
2.1 Recursive script inclusion
The same origin policy states that scripts can read or modify
any part of a page with a matching origin. This includes allow-
ing scripts to add additional script tags to the document. These new
scripts are then loaded into the page, and also gain read and modify
access to any content coming from the origin.
A page creator could choose to include content only from sources
they deem trustworthy, but this does not mean that all content in-
cluded will be directly from those sources. Any script loaded from
a “trustworthy” domain can subsequently load content from any
domain. Unfortunately, trust is not transitive, even if JavaScript
treats it that way. Besides the risk of an intentionally malicious
script loading additional, dangerous code, there is also the risk of
a “trustworthy” domain inadvertently loading malicious content.
Even well-known, legitimate advertising services have been tricked
into distributing malicious code [32, 28].
2.2 Unrestricted outbound communication
While the same origin policy restricts how content from another
domain can be used, it does not stop any content from other do-
mains from being requested and loaded into the origin page. These
requests for content can be abused to send information out to any
arbitrary domain.
One common JavaScript attack involves cookie-stealing.1 A script
reads cookie information from the user’s browser and uses it as part
of the URL of a request. An innocuous request, such as an extra
image, may actually be used to send data to attacker.com:
var image = new Image();
image.src= ’http://attacker.com/log.php?cookie=’
+ encodeURIComponent(document.cookie);
Such cookie information could then be used by the remote server
to gain access to the user’s session, or to get other information about
the user. Any information that can be read from the document could
be sent out in a similar manner, including credit card information,
personal emails, or username and password pairs. Even if a user
does not hit “submit” on a form, any information they enter can be
read by JavaScript and potentially retransmitted.
2.3 Cross-site request forgery (XSRF/CSRF)
The information theft techniques described in the previous sec-
tion can be used to launch a cross-site request forgery (XSRF or
CSRF) attack [3]. Some URLs, when requested, cause an action to
be performed on the web server: a message is posted, a friend is
added, a vote is cast. Providing easy links for these actions is very
useful for the web developer who may want to include them in a
menu or elsewhere on the page. What happens, however, if one of
these links is used as the URL for an image? Even though nothing
has been clicked, that action will still be performed on behalf of
the logged-in user because the URL is requested when the browser
attempts to get the supposed image. Cross-site request forgery oc-
curs when the user visits a web page which accesses a URL that
performs an action (using that user’s privileges) on another web
page (even if the user never sees the URL being loaded).
2.4 Cross-site scripting (XSS)
While no precise deﬁnition of cross-site scripting seems to be
universally accepted, the core concept behind cross-site scripting
(XSS) is that of a security exploit in which an attacker inserts code
onto a page returned by an unsuspecting web server [5, 6]. This
code may be stored or reﬂected, it may contain JavaScript or just
HTML, and it may use third party sites as sources or rely only
upon the resources of the targeted server. With such ambiguity,
it is possible to have a cross-site scripting attack which neither
uses scripting nor is cross-site. Typically, however, XSS attacks
1While this attack can now be mitigated by httpOnly [23], other
information (including form data) can still be stolen this way.
Content
Type
Images
HTML
JavaScript
Styles
Audio/Video
Permissions
Fetch
SOMA
SOMA
SOMA
SOMA
SOMA Plugin Dependant
Read Modify
SO
SO
SO
SO
SO
SO
YES
YES
Execute
NO
NO
YES
NO
NO
Table 2: JavaScript access to other content with SOMA (per-
missions denoted SO are dictated by the long-standing same
origin policy)
involve JavaScript code engaging in cross-domain communication
with malicious web servers.
Code injection for cross-site scripting usually occurs because
user-supplied data is not sufﬁciently sanitized before being stored
and/or displayed to other users. Although the existence of such vul-
nerabilities is not a ﬂaw in the same origin policy, per se, the same
origin policy does allow the injected code access to content of the
originating site. Speciﬁcally, it can then steal information associ-
ated with that domain or perform actions on behalf of the user.
Some existing proposals to address cross-site scripting and other
JavaScript security issues are described in greater detail in Sec-
tions 6. Here we note that no current proposal targets the cross-
domain communication involved in most JavaScript exploits.
3. SOMA DESIGN
The Same Origin Mutual Approval (SOMA) policy tightens the
same origin policy so that it can better handle exploits as discussed
in Section 2, including cross-site scripting and cross-site request
forgery. SOMA requires that both the origin web site and the site
providing included content approve of the request before the browser
allows any external content to be fetched for a page. Adding these
extra checks gives site operators much more control over what gets
included into or from their sites. These changes are shown in Table
2. While the differences (relative to Table 1) are all in the Fetch
column, a “fetch” can also be used to leak (send out) information
such as cookies, as discussed earlier.
A key idea behind SOMA is that security policy should be de-
cided by site operators, who have a vested interest in doing it cor-
rectly and the knowledge necessary to create secure policies, rather
than end users. Having said that, we cannot expect site operators
to create complex policies—their time and resources are limited.
Thus SOMA works at a level of granularity that is both easy to
understand and specify, that of DNS domains and URLs.