6c16d0ec9f8ef1a1f6ef47ce92b77692dd8c5d12e669b045366bbaf71d7182b1 7
$ sudo docker images
REPOSITORY TAG IMAGE ID CREATED VIRTUAL SIZE
imported container 6c16d0ec9f8e 35 seconds ago 192.5 MB 9
ubuntu latest 9bd07e480c5b 3 weeks ago 192.7 MB
docker import会把打包的容器导入为一个镜像。
8
import表示从标准输入读取容器内容，我们把name.tar的内容传给了标准输入，res和tag分别
代表生成的镜像和标记。 10
除了导入本地文件系统的tar包成为一个镜像外，我们还可以使用一个url来导入网络上的
10
容器：
docker import url res:tag
11
接着就可以通过docker run命令使用导入的镜像创建我们需要的容器了。
13
14
15
16
17
18
28 第3章 镜像
第 3 章
镜 像
和容器一样，镜像是Docker的核心组件之一。镜像是容器的运行基础，容器是镜像运行后的
形态，二者紧密相连又有不同。在第2章中讨论容器时，涉及镜像的地方并没有展开来讲，本章
详细介绍一下镜像。在本章中，我们将详细探讨如下内容：
 镜像的概念，其中包括镜像与容器的区别、镜像独特的组成架构等；
 本地镜像的管理，其中将涉及获取、创建和删除等命令的使用；
 如何通过互联网来分发我们定制的镜像。
3.1 镜像的概念
镜像是一个包含程序运行必要依赖环境和代码的只读文件，它采用分层的文件系统，将每一
次改变以读写层的形式增加到原来的只读文件上。
3.1.1 镜像与容器
镜像是容器运行的基石。正如在第2章中所看到的，使用docker run命令创建一个容器并在
其中运行进程时，必须指定一个镜像名称或者镜像ID。下面的命令展示了使用根镜像ubuntu创建
容器并在其中运行的例子：
# docker run ubuntu echo "hello docker"
hello docker
如果将容器理解为一套程序运行的虚拟环境，那么镜像就是用来构建这个环境的模板。通过
同一个镜像，我们可以构造出很多相互独立但运行环境一样的容器。
不同镜像也许有着不同的服务目标，比如ubuntu镜像用来构建一个精简的Ubuntu操作系统容
器环境，wordpress镜像用来构建博客程序容器环境。此外，用户还可以在已有的任意镜像上面
扩展定制出满足特殊业务需求的镜像。
3.1 镜像的概念 29
3.1.2 镜像的系统结构
1
图3-1展示了Docker镜像的系统结构。镜像的最底层必须是一个称为启动文件系统（bootfs）
2
的镜像，用户不会与这一层直接打交道。bootfs的上层镜像叫作根镜像（rootfs），它在通常情况
下是一个操作系统，如Ubuntu、Debian 和CentOS等。用户的镜像必须构建于根镜像之上。图中
3
所示的镜像1是通过在根镜像ubuntu上安装MySQL来创建的。在镜像1的基础上再安装一个Nginx，
就又创建了镜像2。利用镜像2启动的容器里面运行的是一个已经安装好了MySQL和Nginx的
4
Ubuntu系统。
5
6
7
9
8
10
图3-1 Docker镜像的系统结构
10
镜像的本质是磁盘上一系列文件的集合。不难理解，创建新的镜像其实也就是对已有镜像文
件进行增、删、改操作。镜像之间并不是孤立的，而是存在单向的文件依赖关系。如图3-2所示， 11
镜像的原理与Git相似，熟悉Git工作原理的读者对此应该不会陌生。镜像1的FileA’是镜像2的FileA
的修改版本，NewFile是新创建的文件，其他文件则全部引自镜像2。正因为Docker的这种文件层 13
叠共享机制，才造就镜像占用磁盘空间小、扩展容易、传播灵活等优点。
14
15
16
17
18
图3-2 镜像的文件依赖关系
30 第3章 镜像
3.1.3 镜像的写时复制机制
通过docker run命令指定镜像创建一个容器时，实际上是在该镜像之上创建一个空的可读写
文件系统层级。可以将这个文件系统当成一个新的临时镜像，而命令里所指定的镜像称为父镜像。
父镜像的内容都是以只读方式挂载进来的，容器会读取共享父镜像的内容。不过一旦需要修改父
镜像文件，便会触发Docker从父镜像中复制这个文件到临时镜像中来，所有的修改均发生你的文
件系统中，而不会对父镜像造成任何影响，这就是Docker镜像的写时复制机制。图3-2展示了这
种写时复制导致的文件依赖关系。用户可以通过commit命令保存该临时镜像所做的修改，从而形
成一个真正的镜像，这在3.3节中会详细讲到，在此暂且略过。
3.2 本地镜像的管理
在本节中，我们主要介绍本地镜像的基础管理：查看、下载和删除。
3.2.1 查看
通过images命令，可以列出本机上的所有镜像：
# docker images
REPOSITORY TAG IMAGE ID CREATED VIRTUAL SIZE
bbbb/ccccc aaaa 1009d6e33803 45 hours ago 199.3 MB
centos latest ae0c2d0bdc10 4 weeks ago 224 MB
ubuntu latest 5506de2b643b 5 weeks ago 199.3 MB
...
下面简要介绍一下上述代码中各个字段的含义。
 REPOSITORY：仓库名称。仓库一般用来存放同一类型的镜像，其名称由它的创建者指定（具
体如何指定将在3.3节中讲到），如果创建时没有指定则为。仓库的名称有下面几种
形式。
 [namespace\ubuntu]：由命名空间和实际的仓库名称组成，中间通过\隔开。当你在Docker
Hub上注册一个账户时，账户名便自动成为了你的命名空间，该命名空间是用来区分
Docker Hub上注册的不同用户或者组织。如果你想创建一个分发到Docker Hub上去的镜
像，必须指定命名空间。如果不指定或者指定了但命名空间不符合，将会得到如下错误：
2014/12/10 20:43:10 Error: Status 403 trying to push repository abcd/abcd: "Access Denied:
Not allowed to create Repo at given location"
 [ubuntu]：只有仓库名。对于这种没有命名空间的仓库名，我们可以认为它属于顶级命
名空间。该空间的仓库只用于官方的镜像，由Docker官方进行管理，但一般会授权给第
三方进行开发维护。用户在本地创建的镜像也可以这样命名，但是无法分发到Docker
Hub上进行共享。
3.2 本地镜像的管理 31
 [dl.dockerpool.com:5000\ubuntu:12.04]：指定URL路径的方式。如果该镜像不是放置 1
在Docker Hub上，而是放置在你自己搭建的Hub或者第三方Hub上，则使用这种方式命
名。dl.dockerpool.com:8080是第三方Hub的主机名及端口，ubuntu是镜像名称。
2
 TAG：用于区分同一仓库中的不同镜像。如果未指定，默认为latest。
 IMAGE ID：每个镜像都有一个字符串类型、长为64位的HashID，用来全网标识一个镜像。 3
该字段只展示前面一部分，因为这一部分已经足以在本机唯一标识一个镜像了。
 CREATED：镜像的创建时间。 4
 VIRTUAL SIZE：镜像所占用的虚拟大小，该大小包含了所有共享文件的大小。
5
我们还可以通过在images命令后面添加通配符，找出符合条件的一系列镜像：
# docker images ub*
6
REPOSITORY TAG IMAGE ID CREATED VIRTUAL SIZE
ubuntu latest 5506de2b643b 5 weeks ago 199.3 MB
7
使用images命令，一般只会列出镜像的基础信息。要想得到一个镜像更详细的信息，可以通
过inspect命令：
9
# docker inspect ubuntu
[{
"Architecture": "amd64", 8
"Author": "",
"Comment": "",
"Config": { 10
"AttachStderr": false,
"AttachStdin": false,
"AttachStdout": false, 10
"Cmd": [
"/bin/bash"
], 11
...
13
3.2.2 下载
使用docker run命令运行一个镜像时，Docker首先会在本机寻找该镜像，如果本机不存在， 14
会继续去Docker Hub上面搜索符合条件的镜像并将其下载下来运行，相关代码如下：
15
# docker run ubuntu echo "hello docker"
Unable to find image 'ubuntu' locally
ubuntu:latest: The image you are pulling has been verified 16
01bf15a18638: Pull complete
30541f8f3062: Pull complete
e1cdf371fbde: Pull complete
17
9bd07e480c5b: Pull complete
511136ea3c5a: Already exists
Status: Downloaded newer image for ubuntu:latest
18
hello docker
32 第3章 镜像
这里需要说明的是，Docker Hub上存在许多由各用户和组织创建的镜像，对于有些已经存在
的镜像，可以直接下载下来使用，没有必要再去重复发明轮子。
通过search命令，可以在Docker Hub上搜索符合要求的镜像：
# docker search wordpress
NAME DESCRIPTION STARS OFFICIAL AUTOMATED
wordpress The WordPress... 138 [OK]
tutum/wordpress Wordpress Docker image - 29 [OK]
...
下面简要介绍一下上述代码中各个字段的含义。
 NAME：镜像的名称。由命名空间和仓库名构成，如果没有命名空间，说明该镜像属于Docker
Hub的官方镜像。
 DESCRIPTION：镜像的简要描述，创建者可以登录Docker Hub修改该项。
 STARS：用户对镜像的评分。评分越高，说明质量越高。
 OFFICIAL：是否为官方镜像。一般情况下，官方镜像更可靠、更稳定。
 AUTOMATED：是否使用了自动构建，这将在3.4.3节中介绍。
为了在运行镜像时不用再费时等待下载镜像，可以通过pull命令预先将镜像拉回到本地。镜
像名必须完整地包含命名空间和仓库名。如果一个仓库中存在多个镜像，还必须指定TAG，否则
使用默认的TAG——latest。
例如，下面直接运行容器ubuntu，我们发现本地没有，于是Docker向Docker Hub中拉取：
# docker run ubuntu echo "hello docker"
Unable to find image 'ubuntu' locally
ubuntu:latest: The image you are pulling has been verified
01bf15a18638: Pull complete
30541f8f3062: Pull complete
e1cdf371fbde: Pull complete
9bd07e480c5b: Pull complete
511136ea3c5a: Already exists
Status: Downloaded newer image for ubuntu:latest
hello docker
这时我们就可以预先通过pull命令来完成拉去的工作，而不用等到要运行的时候，这样可以
节省运行时的等待时间：
# docker pull ubuntu
Unable to find image 'ubuntu' locally
ubuntu:latest: The image you are pulling has been verified
01bf15a18638: Pull complete
30541f8f3062: Pull complete
e1cdf371fbde: Pull complete
9bd07e480c5b: Pull complete
511136ea3c5a: Already exists
Status: Downloaded newer image for ubuntu:latest
3.3 创建本地镜像 33
3.2.3 删除
1
对于那些不再需要的镜像，可以使用rmi命令删除。与移除容器的命令rm相比，删除镜像的
2
命令多了一个i，i即image的意思，这非常容易记住。示例代码如下：
# docker rmi c20fd090cbb6 3
Deleted: c20fd090cbb692b556e5910e7c1092ce292fc5efc7493deaecfec5d746c3cf42
Deleted: 6d3f47df05998b84fbd5ec433785851f64d2d0fc4c28cd6b0f4a050c7e360f8a
# docker rmi jamtur01/static_web 4
Deleted: c20fd090cbb692b556e5910e7c1092ce292fc5efc7493deaecfec5d746c3cf42
Deleted: 6d3f47df05998b84fbd5ec433785851f64d2d0fc4c28cd6b0f4a050c7e360f8a
5
在rmi后面，可以指定一个或多个镜像名称或者镜像ID，其中多个镜像之间使用空格隔开。
如果不指定，则会删除TAG为latest的镜像。
6
有时候，会遇到镜像删不掉的情况，一般出现这个问题的原因是这个镜像被容器所依赖。即
便容器已经停止运行了，也仍然需要依赖镜像。用户可以使用-f参数进行强制删除，或者选择另
7
一种相对温柔的办法，那就是先将依赖它的镜像和容器移除。
下面的例子演示了存在容器而导致镜像删除失败的情况： 9
# docker rmi ubuntu
Error response from daemon: Conflict, cannot delete 9bd07e480c5b because the container 1ea331e3ce1e 8
is using it, use -f to force
2014/12/10 20:11:09 Error: failed to remove one or more images
10
如果本地有很多已经停止运行的容器，一个个删除很麻烦，此时可以通过下面的命令将这些
容器一次性删除掉，这样就能减少无用容器对镜像的依赖：
10
# docker rm $(docker ps -a -q)
e13788bcce4c
11
08530fb59349
9a0ab77d4449
其中docker ps -a -q命令用来列出所有容器的ID。 13
3.3 创建本地镜像 14
在2.3节中，我们知道可以将一个本地的tar包导入为镜像，其前提是该tar包是由镜像导出的。 15
不管怎样，将tar包导入也算是创建本地镜像的一种方法。接下来，我们介绍另外两种创建本地镜
像的方法。 16
3.3.1 使用commit命令创建本地镜像
17
正如3.1节所讲，使用镜像创建并运行一个容器，实际上是在父镜像的基础上创建一个可读
18
写的文件层级。我们在容器里所做的修改（包括安装新的应用程序、更改系统配置），都发生在
34 第3章 镜像
这个层级上面。下面的一系列命令展示了在ubuntu镜像上创建和运行一个容器，并在该容器上安
装SQLite3以及在根目录下创建一个名为hellodocker的文件，并且在这个文件中写入test docker
commit：
# docker run -t -i ubuntu
root@0ddf83b837fe:/# apt-get update
.....(apt-get update命令的输出，为节省篇幅，在此省略)