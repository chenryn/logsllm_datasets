```
$ docker service inspect sample-stack_whoami
```
这提供了关于服务的所有相关设置的丰富信息。这包括我们在`stack.yaml`文件中明确定义的那些，但也包括那些我们没有指定的，因此被赋予默认值的。我们不打算在这里列出整个输出，因为它太长了，但我鼓励读者在自己的机器上检查它。我们将在*群路由网格*部分更详细地讨论部分信息。
# 服务日志
在前面的章节中，我们处理了由容器产生的日志。在这里，我们专注于一项服务。请记住，最终，一个具有许多副本的服务会有许多容器在运行。因此，我们期望，如果我们向服务请求日志，Docker 会返回属于该服务的那些容器的所有日志的集合。事实上，这就是我们使用`docker service logs`命令得到的结果:
![](img/1a1a4108-2011-4d37-a121-0e233b62b1db.png)
Logs of the whoami service
目前日志中没有太多信息，但足以讨论我们得到了什么。日志中每一行的第一部分总是包含容器的名称以及日志条目来源的节点名称。然后，用竖线(`|`)隔开，我们得到实际的日志条目。因此，如果我们直接询问列表中第一个容器的日志，我们只会得到一个条目，在这种情况下，我们看到的值将是`Listening on :8000`。
我们通过`docker service logs`命令获得的聚合日志没有以任何特定的方式进行排序。因此，如果事件的关联发生在不同的容器中，您应该将信息添加到日志输出中，以使这种关联成为可能。通常，这是每个日志条目的时间戳。但这必须在源头上进行；例如，生成日志条目的应用也需要确保添加了时间戳。
我们还可以通过提供任务标识而不是服务标识或名称来查询服务的单个任务的日志。因此，查询任务 2 中的日志会得到下面的截图:
![](img/461abdb0-ea1e-47b6-85c0-e1702fe36775.png)
Logs of an individual task of the whoami service
# 调和期望的状态
我们已经了解到，群服务是我们希望应用或应用服务在其中运行的期望状态的描述或清单。现在，让我们看看 Docker Swarm 如何协调这个期望的状态，如果我们做了一些事情，导致服务的实际状态不同于期望的状态。最简单的方法是强制杀死服务的一个任务或容器。
让我们用已经安排在`node-1`的容器来做这件事:
```
$ docker container rm -f sample-stack_whoami.2.n21e7ktyvo4b2sufalk0aibzy
```
如果我们这样做，然后立即执行`docker service ps`，我们将看到以下输出:
![](img/642552f4-b4ee-431e-acf2-48d2ff69b48d.png)
Docker Swarm reconciling the desired state after one task failed
我们看到任务 2 以退出代码`137`失败，并且群通过在具有空闲资源的节点上重新调度失败的任务来立即协调期望的状态。在这种情况下，调度程序选择了与失败任务相同的节点，但情况并非总是如此。因此，在没有我们干预的情况下，swarm 完全解决了这个问题，并且由于服务在多个副本中运行，因此服务从未中断。
让我们尝试另一个失败场景。这一次，我们将关闭整个节点，并观察蜂群的反应。让我们以`node-2`为例，因为它上面运行着两个任务(任务 3 和任务 4)。为此我们需要打开一个新的终端窗口，使用 Docker 机器停止`node-2`:
```
$ docker-machine stop node-2
```
回到`node-1`，我们现在可以再次运行`docker service ps`来看看发生了什么:
![](img/51a7f7be-e6da-4183-b401-0292860d1f5b.png)
Swarm reschedules all tasks of a failed node
在前面的截图中，我们可以看到任务 3 立即被重新安排在`node-1`上，而任务 4 被重新安排在`node-3`上。即使是这种更彻底的失败也由 Docker Swarm 优雅地处理。
但是需要注意的是，如果`node-2`在集群中重新上线，先前运行在其上的任务将不会自动转移回集群。但是节点现在已经为新的工作负载做好了准备。
# 删除服务或栈
如果我们想从群中移除一个特定的服务，我们可以使用`docker service rm`命令。另一方面，如果我们想从群体中移除一个栈，我们类似地使用`docker stack rm`命令。此命令删除栈定义中的所有服务。就`whoami`服务而言，它是通过使用栈文件创建的，因此我们将使用后一个命令:
![](img/46256692-9b0e-4be7-8f0f-9c5b88b79685.png)
Removing a stack
前面的命令将确保栈的每个服务的所有任务都被终止，并且通过首先发送`SIGTERM`来停止相应的容器，然后，如果不成功，则在 10 秒的超时后发送`SIGKILL`。
需要注意的是，停止的容器不会从 Docker 主机中移除。因此，建议不时清除工作节点上的容器，以回收未使用的资源。为此使用`docker container purge -f`。
# 部署多服务栈
在[第 8 章](08.html)、 *Docker Compose、*中，我们使用了一个由两个服务组成的应用，这两个服务在 Docker Compose 文件中进行了声明性描述。我们可以使用这个合成文件作为模板来创建一个栈文件，允许我们将同一个应用部署到一个群中。我们的栈文件`pet-stack.yaml`的内容是这样的:
```
version: "3.5"
services:
  web:
    image: fundamentalsofdocker/ch08-web:1.0
    networks:
      - pets-net
    ports:
      - 3000:3000
    deploy:
      replicas: 3
  db:
    image: fundamentalsofdocker/ch08-db:1.0
    networks:
      - pets-net
    volumes:
      - pets-data:/var/lib/postgresql/data
volumes:
  pets-data:
networks:
  pets-net:
    driver: overlay
```
我们要求服务`web`有三个副本，并且两个服务都连接到覆盖网络`pets-net`。我们可以使用`docker stack deploy`命令部署该应用:
![](img/69a99a61-4732-4778-8665-8c5ef0ac074c.png)
Deploy the pets stack
Docker 创建了`pets_pets-net`覆盖网络，然后创建了两个服务`pets_web`和`pets_db`。然后我们可以列出`pets`栈中的所有任务:
![](img/8b529116-2cb8-4616-b95f-d853b00fd0af.png)
List of all the tasks in the pets stack
最后，让我们使用`curl`测试应用。实际上，该应用的工作情况与预期一致:
![](img/f54253d1-8774-496b-927f-1ca3b91d3bca.png)
Testing the pets application using curl
容器标识在输出中，表示`Delivered to you by container c9aa9dacd9b2`。如果多次运行`curl`命令，ID 应该在三个不同的值之间循环。这些是我们请求服务的三个容器(或复制品)的 ID`web`。
完成后，我们可以用`docker stack rm pets`移除栈。
# 群体路由网格
如果你一直在注意，那么你可能在最后一节注意到了一些有趣的东西。我们部署了 pets 应用，结果是服务实例 **web** 安装在三个节点`node-3`、`node-4`和`node-5`上。然而，我们可以通过`localhost`访问`node-1`上的**网络**服务，并从那里到达每个容器。*这怎么可能？*嗯，这是由于所谓的群体路由网格。路由网格确保当我们发布一个服务的端口时，该端口会发布在群的所有节点上。因此，命中群的任何节点并请求使用特定端口的网络流量将通过路由网格被转发到服务容器之一。让我们看看下图，看看它是如何工作的:
![](img/5a7df2a0-c0e1-4595-90c3-336ccdeef83c.png)
Docker Swarm routing mesh
在这种情况下，我们有三个节点，称为**主机 A** 到**主机 C** ，IP 地址为`172.10.0.15`、`172.10.0.17`和`172.10.0.33`。在图的左下角，我们看到了创建带有两个副本的服务 **web** 的命令。相应的任务已经安排在**主机 B** 和**主机 C** 上。任务 1 降落在主机 B 上，而任务 2 降落在主机 c 上。
当一项服务在 Docker Swarm 上创建时，它会自动获得一个分配的**虚拟 IP** ( **贵宾**)地址。该 IP 地址在服务的整个生命周期中是稳定和保留的。让我们假设在我们的情况下，贵宾是`10.2.0.1`。
如果现在来自外部**负载平衡器** ( **LB** )的端口`8080`请求是针对我们群集的一个节点，那么这个请求由该节点上的 Linux **IP 虚拟服务器** ( **IPVS** )服务处理。该服务在 IP 表中查找给定端口`8080`，会发现这对应于服务 **web** 的 VIP。现在，由于 VIP 不是真正的目标，IPVS 服务将对与该服务相关联的任务的 IP 地址进行负载平衡。在我们的例子中，它选择了任务 2，其 IP 地址为`10.2.0.3`。最后，**入口**覆盖网络用于将请求转发到主机 c 上的目标容器。
需要注意的是，外部 LB 将外部请求转发到哪个群节点并不重要。路由网格将始终正确处理请求，并将其转发给目标服务的任务之一。
# 摘要
在这一章中，我们已经介绍了 Docker Swarm，它是仅次于 Kubernetes 的第二大最受欢迎的容器编排器。我们研究了群的体系结构，讨论了群中运行的所有类型的资源，如服务、任务等，并且在群中创建了服务，部署了由多个相关服务组成的应用。
在下一章中，我们将探讨如何将服务或应用部署到具有零宕机和自动回滚功能的 Docker Swarm 上。我们还将引入机密作为保护敏感信息的手段。
# 问题
要评估您的学习进度，请回答以下问题:
1.  如何初始化一个新的 Docker Swarm？
    1.  Docker 初始化群
    2.  DockerSwarm 初始化-广告-地址
    3.  Docker swarm 联接令牌
2.  您希望从 Docker Swarm 中删除一个工作节点。需要哪些步骤？
3.  如何创建一个名为`front-tier`的覆盖网络？使网络可连接。
4.  如何从带有五个副本的`nginx:alpine`映像创建名为`web`的服务，该服务暴露入口网络上的端口 3000 并连接到`front-tier`网络？
5.  您将如何将 web 服务缩减到三个实例？
# 进一步阅读
有关所选主题的更多详细信息，请参考以下链接:
*   *亚马逊 AWS EC2 示例*在[http://dockr.ly/2FFelyT](http://dockr.ly/2FFelyT)