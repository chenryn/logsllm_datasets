import
[pye_generator.py]
关于Pyhon的import机制，在后面的章节中将专门予以剖析，这里我们只简单地利
第7章Python的编译结果
要了解pyc文件的格式，首先我们必须要清楚pyCodeObject中每一个域都表示什么
可以看到，pyc是一个二进制文件，那么Python如何解释这一堆看上去毫无意义的字
图7-2所示的是demo.py所对应的demo.pyc文件：
finally:
try:
EP
name
imp.load_module(name,fo, pathname,description)
pathname,description = imp.find_module（name)
sys
深度探索动态语言核心技术
：
00000040h:
00000020h:
00000010h:
00000000h:
tp.close()
demo.pyc
请参见第11章对函数机制的剖析）
CodeBlock的位置参数的个数，比如说一个函数的位置参数个数（位置参数
Content
main
S80010S9.00Z0YS
表7-1
00
B3
F2
图7-2demo.pyc的内容
PyCodeObject中各个域的意义
00
ODCL
2
Code对象与pyc文件
Y
64
01
40
00
000001
00
45
7
00
73
6403
30
00
00
53
83
N
---
## Page 149
的增量值，所以，对应的co_lnotab就应该是：0，1，6，1，44，5。
式的一个1ist。比如对于下面的例子（见表7-2）：
形式存在的，数组的形式可以看作（字节码指令在co_code中位置，sourcecode行号）形
编译时完成。所以，相应地，Pyhon会在编译时直接将这个信息记录到co_Inotab中。
字节码在cocode中的偏移
于调试和显示异常信息都有用。但是，在Python2.3之后，Python在编译时不会再产生这
SET_LINENO，这条字节码会记录py文件中sourcecode的位置（行号）信息，这个信息对
条
在以后的剖析中也不会涉及。
9
字节码，因为毕竟字节码代表的是运行时的行为，而记录源代码行号的动作完全可以在
co_Inotab
co_firstlineno
co_name
co_filename
co_cellvars
co_freevars
co_varnames
co_names
co_consts
co_code
co_flags
co_stacksize
co_nlocals
Field
这里有一个小小的技巧，Python不会直接记录这些信息，但是，它会记录这些信息间
co_1notab中的字节码和相应 source code行号的对应信息是以unsigned bytes的数组
这里需要说明一下的是co_1notab域。在Python2.3以前，有一条字节码指令，叫做
标注为N/A的域是说明该域对于理解Python虚拟机的行为没有太多用处，所以我们
CodeBlock在对应的.py文件中的起始行
CodeBlock所对应的.py文件的完整路径
CodeBlock的名字，通常是函数名或类名
CodeBlock中内部嵌套函数所引用的局部变量名集合
Pyhon实现闭包需要用到的东西，后面的章节中会涉及
CodeBlock中的局部变量名集合
PyTupleObject对象，保存Code Block中的所有符号
PyTupleObject对象，保存CodeBlock中的所有常量
CodeBlock编译所得的字节码指令序列。以PyStringObject的形式存在
执行该段CodeBlock需要的栈空间
N/A
CodeBlock中局部变量的个数，包括其位置参数的个数
Content
存在
7.2
Python编译器的编译结果
表7-2
Python源码剖析
py文件中源代码的行号
PyCodeObject 对象
一深度探索动态语言核心技术
119
续表
---
## Page 150
7.2.4
Python源码剖析
7.3.1
7.3
120
文件中时到底进行了怎样的动作就可以了。代码清单7-1的函数就是我们的切入点。
的格式到底是什么样的，我们只需考察Python在将编译得到的pyCodeobject写入到pyc
的pyc文件或dll文件，就会在py文件的基础上自动创建pyc文件。那么，要想了解pyc
对象，并访问其中的属性。关于内建函数compile的更多信息，请参阅Python文档。
PyCodeObject对象中的各个域。图7-3展示了如何通过compile内建函数获得一个code
象是对C一级的PyCodeobject对象的一个简单包装，通过code对象，我们可以访问
代码清单7-1
[import.c]
Pyc文件的生成
mtime)
创建pyc文件的具体过程
在Python中访问PyCodeObject对象
第7章Python的编译结果一
前面我们提到，Python在通过import对module进行动态加载时，如果没有找到相应
在Python中，有与C一级的Pycodeobject对象对应的对象一
FLLE*EP)
PyMarshal_WrlteLongToPile(mtime.fp.Py_MARSHAL_VERSION)
//[2]：写入时间信息
PyMarshal
//[1写入Python的magienumber
fp=open_exclusive(cpatnname);
//排他性地打开文件
深度探索动态语言核心技术
WriteLongToFile(pyc_magic,fp,
demo.py
ctype
图7-3在Python中访问PyCodeObject对象中的信息
('AT
dir(co)
CO
orint co.co_filename
Iconlocals
init
"Funr,
str
co.co_name
co.co_names
CmP
Code对象与pyc文件
Tco_stacksize',
demo-py:ezec）
covarnames]
PyMARSHAL_VERSION)
co1n
code对象，这个对
---
## Page 151
成了pyc文件的创建工作。
的代码，有兴趣的读者可以参阅Pyhon的源代码。
写入时间的真实动作并不是如代码清单7-1的[2]所示，为了描述的简便，我们修改了这里
的时间，于是就会自动重新编译demo.py，生成新的demo.pyc。需要指出的是，python中
会首先尝试加载demo.pyc，在加载的过程中，Python会发现pye文件的时间早于py文件
自动将pyc文件与最新的py文件进行同步。
[2]处完成了向pyc文件写入时间信息的动作。在pyc文件中包含时间信息可以使Python
magicnumber，我们可以看一看Python2.5所定义的magicnumber：
的不兼容问题。
的SET_LINENo：而另一些新的语法特性会导致加入新的字节码指令。这些都会导致Pyhon
化，由于Python一直在不断地改进，有一些字节码指令退出了历史舞台，比如上面提到
录的magicnumber不同，则会拒绝加载不兼容的pye文件。
检查这个magicnumber：如果发现Pyhon自身的magicnumber与待加载的pyc文件中记
Python 1.5的magicnumber设为不同的值就可以了，因为Python在加载pyc文件时会首先
修改了demo.py，当Python执行修改后的demo.py时，因为存在demo.pyc文件，所以Python
止Python 2.5的运行环境加载由Python 1.5产生的pyc文件，那么只需要将Python2.5和
实现都会定义不同的magicnumber，这个值就是用来保证Python兼容性的。比如说要防
开头。实际上，pyc_magic是Python所定义的一个整数值。一般来说，不同版本的Python
[import.c]
息：Python的magicnumber、pyc文件创建的时间信息，以及PyCodeobject对象。
statie
#define
在代码清单7-1的[3]处，Python将内存中的PyCodeobject对象写入了pyc文件，完
假如在早上9点我们将demo.py文件编译成了demo.pyc文件，在下午3点时，我们
在pyc文件中，紧接着magicnumber的是pyc文件创建的时间信息，代码清单7-1的
在import.c中，可以在源代码的注释里找到从Python1.5到Python2.5所有版本的
这里出现了一个问题，pyc文件为什么会不兼容了？最主要的原因是字节码指令的变
首先在代码清单7-1的[1]处，我们看到Python会将pyc_magic这个值写入到文件的
从write_compiled_module中可以发现，一个pyc文件中实际上包含了三部分独立的信
fclose(tp):
fflush(fp);
PyMarshal_WriteObjectToFLle((PyObject*)co,fp.Py_MARSHAL_VERSION）;
//[3]:写入PyCodeObject对象
long pyc_magie=
MAGIC:
Python源码剖析
7.3Pyc文件的生成
一深度探索动态语言核心技术
121
---
## Page 152
Python源码剖析
122
基于这些数值或字符串重新构造出1ist对象。
件中。换句话说，Python在向pyc文件中写入一个11st对象时，其实只是将1sE中所包
其最终目的都是通过最基本的w_long或w_string将整个pycodeobject写入到pyc文
就是对应不同的对象，比如string、int、list、dict等，会有不同的写的动作，然而
数正是Pyhon编译出来的PyCodeobject对象。
文件中的操作。要特别注意的是PyMarshal_WriteObjectToFile的第一个参数，这个参
时，Python会借助于另一个辅助的函数w_object来完成将PyCodeobject对象写入到pyc
对代码进行了删减，删减部分，请参考Pyhon源代码。
static void wstring（char *g, int n,WFILE *p)
个函数中。在这里，我们假设代码只处理写入到文件，即p->tp是有效的情况。因此我们
statie void w_object(Pyobject *v,WpILE *p)
[marshal.c]
域依次写入：
入的数据一个字节一个字节地写入到文件中。而在调用pyMarshal_WriteObjeatToFile
static void w_long(long x,WpTLE *p）
#definew_byte(e,p) pute((c),(p)->fp)
typedef
[marshal.c]
w_object的代码非常长，这里就不全部列出。实际上，w_object的逻辑非常简单，
WFILE;
对于pyCodeobject，很显然，wobject会遍历pyCodeobject中的所有域，将这些
第7章Python的编译结果
在write_compiled_module中，向pyc文件写入数据的动作最后会集中到下面所示的几
fwrite(s,I,p,p->fp)
W_byte（（char）（(x>24）&0xff),
w_byte((char)((x>>16)
w_byte((chaI)((x>>
w_byte((char)（
FILE
int
depth;
struct
深度探索动态语言核心技术
X
OXfE)
OxfEy,
Code对象与pyc文件
P）:
三
---
## Page 153
的结构和蕴含的信息了，所以Pyhon必须将对象的类型信息也写入到pyc文件中，这些标
如果没有类型信息，Pyhon再次加载pye文件时，就再也没有办法知道这些字节流中隐藏
PyCodeObject对象写入到pyc文件之后，所有的数据都变成了字节流，类型信息丢失了。
加载具有至关重要的作用。
TYPE_LIST、TYPE_CODE，或者是TYPE_INT这样的标识。这些标志对于PyC文件的再次
[w_object() in marshal.c]
[w_object() in marshal.c]
一个元素依次写入到pyc文件中：
在前面我们就已经提到过，Python最终仅仅会将数值和字符串写入到pyc文件中。当
细心的你一定注意到了，wobject毫无例外地都会在写入对象之前，先写入一个
而如果w_object 面对的是pyIntObject，嗯，那太简单了，儿乎没有什么可说的：
我们来想象一下，当w_object面对一个PyListobject对象时，会有什么动作？没
Wbyte(TYPE_INTD);
w_long（x:p)）
/注意这里的D的类型为WEIL日*
w_object(co->co_names,p)
wobieot(eo
W_object(eo->co_code,p):
wlong（co->co_argcountD):
Pycodeobiect co= (Eycodeobject )v;
+H+1
W_object(Pylist_GEm_ITEM(v
>CO_
consts,
P）:
Python源码剖析
1
7.3
Pyc文件的生成
深度探索动态语言核心技术
123
---
## Page 154
Python源码剖析
7.3.2
124
面
对象。
向pyc文件中写入字符串或从其中读出字符串的关键所在，当向pyc中写入时，strings会
对FILE*的简单包装，但是在WFILE里，出现了一个奇特的strings域。这个域是Python
入过程中关键的结构体WFILE（有删节）：
文件中即可。而在写入字符串时，Pyhon则设计了一套比较复杂的机制。
实已经看到了对数值的写入过程，对数值的写入非常简单，仅仅需要按字节依次写入到pyc
最后都会归结为简单的两种形式，
void PyMarshal_WriteObjeotToFile(EyObject *x,FILE ·fp,int version)
[marshal.c]
实际上在write的动作中，不论面临PyCodeobject还是pyListobject这些复杂对象，
typedef
[marshal.c]
#define TYPE_CODE