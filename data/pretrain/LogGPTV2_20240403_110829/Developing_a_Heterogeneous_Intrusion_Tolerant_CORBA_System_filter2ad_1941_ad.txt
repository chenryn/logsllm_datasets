this,  receivers  avoid  retaining  information  without 
limit,  avoiding  a  potential  attack.    However,  the 
receiving process  cannot  distinguish  between  late  and 
Byzantine  processes,  and  so  cannot  generate  proof  to 
the Group Manager that the sending process is, in fact, 
Byzantine.   
Voting  is  also  used  to  detect  faulty  processes.  
However,  this  mechanism  is  not  completely  reliable 
since the voter calculates a result after receiving 2f+1 
messages and it is possible that the faulty response is 
not  among those  received.    In  that  case,  its  fault  will 
not be detected  with that particular vote. The receiver 
of  the  2f+1  messages  is  still  guaranteed  the  correct 
value, provided there are not more than f faulty values. 
is  responsible  for  expelling 
If  a  faulty  value  is  detected  the  voter  must  initiate 
action  to  expel  the  Byzantine  process.    The  Group 
Manager 
the  faulty 
process(es)  from  the  affected  replication  domain  by 
keying them out of all communication groups of which 
they  are  part.    Thus,  a  replication  domain  element 
notifies the Group Manager that action is required by 
sending a change_request.  A faulty replication domain 
element may  be  expelled  by  request  from  a  singleton 
replication  domain  element,  or  by  request  from  the 
multiple members of a replication domain.  In the first 
case,  a  single  client  process  invokes  on  a  server  and 
detects  a  faulty  reply  from  some  (up  to  f)  replication 
domain  elements  in  that  server  replication  domain.  
The single client process then sends a change_request 
including  proof  to  the  Group  Manager  to  expel  the 
faulty process(es).  A potential vulnerability is that the 
client  is  malicious  and  is  attempting  to  expel  correct 
processes  from  the  target  replication  domain.    To 
prevent  against  this  sort  of  attack,  ITDOS  requires 
proof from the single client of the faulty value(s).  The 
proof is the set of signed messages through which the 
faulty value was detected. Since each message contains 
a sequence number to protect against replay, and each 
message  is  signed, the  Group  Manager  can  determine 
the  validity  of  the  proof.    The  Group  Manager  must 
perform a vote on the values just as the client did – on 
unmarshalled data.  However, the Group Manager does 
not  run  in  an  ORB.    To  solve  this  difficulty,  ITDOS 
adds  the  full  interface  name  to  the  GIOP  message 
(which GIOP doesn’t normally provide).  Furthermore, 
ITDOS  provides  a  marshalling  engine  that  the  Group 
Manager  uses  to  perform  its  vote.    Once  Group 
Manager  determines  that  the  request  is  valid,  it 
generates  new  communication  keys  and  distributes 
them  to  all  the  correct  processes  in  the  affected 
replication  domain and associated  clients  and  servers, 
effectively removing the faulty process. 
send 
an 
in 
domain  will 
In the case of a replication domain detecting a faulty 
the 
value,  each  replication  domain  element 
replication 
individual 
change_request message.  Proof here is not necessary 
since the request originated from a trustworthy source, 
a  replication  domain.    However,  the  Group  Manager 
must  receive  the  necessary  number  of  messages  to 
perform  a  vote  on  the  request  message  prior  to 
expelling the faulty process(es).  
Related Work 
3.7 
There has  been a  limited amount  of  prior  work  on 
distributed  object  middleware  systems  that  tolerate 
Byzantine  failures.    One  such  system,  Immune  [25] 
does  not  support  heterogeneous  environments  due  to 
its  use  of  byte-by-byte  voting.    This  is  also  true  of 
Proceedings of the International Conference on Dependable Systems and Networks (DSN’02) 
0-7695-1597-5/02 $17.00 © 2002 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 04:16:17 UTC from IEEE Xplore.  Restrictions apply. 
fault-tolerant  CORBA  projects  that  have  tolerated 
crash failures, including Electra [16], AQuA [11], and 
Eternal  [22].    Other  efforts  in  BFTM  systems,  like 
Rampart [35, 36] and Castro-Liskov [6, 7, 8, 9], have 
limited the implementation model so that applications 
cannot  be  built  using  a  standard  distributed  object 
paradigm.  ITDOS allows a standard CORBA model of 
development  in  a  heterogeneous  environment.    These 
BFTM systems also use value comparison mechanisms 
equivalent to byte-by-byte voting, so they do not work 
correctly  in  the  face  of  heterogeneity,  or  inexact 
values, like floating point numbers. The ITUA project 
is  similar 
their 
integration  point  is    a  local  proxy  which  uses  a 
modified  AQuA  protocol  to  handle  replication.  They 
are extending the protocol to handle Byzantine failures 
[41]. 
the  ITDOS  effort;  however, 
to 
4. Future Work 
There are several areas that require further work to 
make  this  architecture  viable  for  a  wide  variety  of 
distributed  systems.    The  single-threaded  approach  to 
handling  determinism  may  be  a  limiting  factor  in 
deployment  and  scalability  of  any  one  particular 
server.    Castro  describes  a  generalized  technique  for 
handling  multi-threaded  applications  in  BFT  systems 
[40].    Our  current  implementation lacks  the ability  to 
create  new  replicas  on-the-fly 
to  replace  faulty 
replicas. 
Transferring large objects poses another obstacle to 
efficient  performance.  While  signing  and  voting  on 
individual messages when they are of “small” size can 
be  a  reasonable  performance  sacrifice  for  security, 
doing  so  on  large,  multi-gigabyte  image  objects  (for 
instance),  could  pose  a  significant  problem  (most 
CORBA systems probably wouldn’t transfer such large 
objects).  However,  to  improve  flexibility  within  the 
architecture, we must find an efficient way of moving 
larger  messages 
system  with 
confidentiality, authentication, and integrity. 
through 
the 
Once  we  fully  implement  ITDOS,  we  will  analyze 
the performance tradeoffs required for given levels  of 
intrusion tolerance.  Similarly, we are considering the 
possibility of adaptive voting such as outlined in [32]. 
5. Conclusions 
ITDOS  provides  an  architecture 
for  highly 
available,  high-integrity  distributed  object  systems. 
The 
for 
heterogeneous  server  implementations  on  different 
platforms to increase the survivability of the protected 
service.    ITDOS  improves  scalability  independent  of 
uniquely 
provides 
support 
system 
confidentiality 
symmetric  encryption 
the  number  of  objects  by  using  a  message  queue  to 
synchronize  replica  state,  as  opposed  to  state  transfer 
techniques.  Communication 
is 
preserved  via 
techniques 
between  clients  and  servers,  and  key  distribution  is 
performed  using  threshold  cryptography  techniques.  
The 
this 
blocks 
of 
implementation  should  be  extensible 
for  other 
distributed object middleware, like Java RMI, enabling 
greater flexibility in system development.  
fundamental 
building 
References 
[1] Bakken, David.  “Middleware.”  Chapter in Encyclopedia 
of Distributed Computing, J. Urban and P. Dasgupta, eds., 
Kluwer Academic Publishers, 2001, to appear.  
[2] K. Birman, "Virtual synchrony model", in Reliable 
Distributed Computing with the Isis toolkit, IEEE CS Press, 
1994.  
[3] Bakken, Zhan, Jones, Kann, “Middleware Support for 
Voting and Data Fusion” in Proceedings of the International 
Conference on Dependable Systems and Networks, 
IEEE/IFIP, Göteborg, Sweden, July 1-4, 2001, 453-462. 
[4] G. Bracha and S. Toueg. Asynchronous Consensus and 
Broadcast Protocols. Journal of the ACM, 32(4), 1995. 
[5] C. Cachin, K. Kursawe, and V. Shoup.  Random oracles 
in Constantinople:  Practical asynchronous Byzantine 
agreement using cryptography.  In Proceedings, 19th ACM 
Symposium on Principles of Distributed Computing (PODC 
2000), pages 123-132, July 2000.  
[6] M. Castro and B. Liskov.  Proactive Recovery in a 
Byzantine-Fault-Tolerant System. In Proceedings of the 4th 
USENIX Symposium on Operating Systems Design and 
Implementation, October 2000. 
[7] M. Castro and B. Liskov.  Practical Byzantine fault 
tolerance. In Proceedings of the 3rd USENIX Symposium on 
Operating Systems Design and Implementation, February 
1999. 
[8] M. Castro and B. Liskov.  Authenticated Byzantine Fault 
Tolerance Without Public-Key Cryptography. Technical 
Memo MIT/LCS/TM-589, MIT Laboratory for Computer 
Science, 1999. 
[9] M. Castro and B. Liskov.  A Correctness Proof for a 
Practical Byzantine-Fault-Tolerant Replication Algorithm. 
Technical Memo MIT/LCS/TM-590, MIT Laboratory for 
Computer Science, 1999. 
[10] M. Chereque, D. Powell, P. Reynier, J. Richier, and J. 
Voiron.  “Active Replication in Delta-4”, in Proceedings of 
the Twenty Second International Symposium on Fault-
Tolerant Computing , IEEE, Boston, Mass., July 1992, 28-
37. 
[11] M. Cukier, J. Ren, C. Sabnis, W. H. Sanders, D. E. 
Bakken, M. E. Berman, D. A. Karr and R. E. Schantz, 
‘‘AQuA:  An adaptive architecture that provides dependable 
distributed objects,’’ Proceedings of the IEEE 17th 
Symposium on Reliable Distributed Systems, West Lafayette, 
IN (October 1998), pp. 245-253. 
[12] “Data encryption standard”, Federal Information 
Processing Standards Publication 46-3, U.S. Department of 
Proceedings of the International Conference on Dependable Systems and Networks (DSN’02) 
0-7695-1597-5/02 $17.00 © 2002 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 04:16:17 UTC from IEEE Xplore.  Restrictions apply. 
Commerce/National Bureau of Standards, National Technical 
Information Service, Springfield, Virginia, October, 1999.  
[13] W. Fenner.  RFC 2236: Internet Group Management 
Protocol, version 2.  IETF, November 1997. 
[14] http://www.pgp.com/research/nailabs/distributed-
systems/intrusion-tolerant.asp. 
[15] K. Kihlstrom, L. Moser and P. Melliar-Smith, ``The 
SecureRing Protocols for Securing Group Communication,” 
Proceedings of the IEEE 31st Hawaii International 
Conference on System Sciences, Kona, Hawaii (January 
1998), vol. 3, pp. 317-326. 
[16] S. Landis and S. Maffeis, ‘‘Building reliable distributed 
systems with CORBA,’’ Theory and Practice of Object 
Systems, vol. 3, no. 1 (April 1997), pp. 31-43. 
[17] Lamport, Shostak, and Pease, “The Byzantine Generals 
Problem”, ACM Transactions on Programming Languages 
and Systems, Vol. 4, No. 3, July 1982, Pages 382-401. 
[18] L. Moser, Y. Amir, P. Melliar-Smith, and D. Agarwal, 
“Extended virtual synchrony,” In Proceedings of the 14th 
IEEE International Conference on Distributed Computing 
Systems (Poznan, Poland) June 1994, pp. 56–65. 
[19] L. E. Moser, P. M. Melliar-Smith, R. R. Koch and K. 
Berket, ‘‘A group communication protocol for CORBA,’’ 
Proceedings of the 1999 ICPP International Workshop on 
Group Communication, Aizu, Japan (September 1999), pp. 
30-36. 
[20] L. Moser, P. Melliar-Smith, P. Narasimhan, L. 
Tewksbury, and V. Kalogeraki, Eternal: Fault Tolerance and 
Live Upgrades for Distributed Object Systems, DARPA 
Information Survivability Conference & Exposition Volume 
II, 25 - 27 January, 2000, Hilton Head, South Carolina. 
[21] L. Moser, P. Melliar-Smith and N. Narasimhan, "The 
SecureGroup Communication System", Proceedings of the 
IEEE Information Survivability Conference, Hilton Head, SC 
(January 2000). 
[22] L.E. Moser, P.M. Melliar-Smith, P. Narasimhan, V. 
Kalogeraki, and L. Tewksbury, "The Eternal System", 
Workshop on Compositional Software Architectures, 
Monterey, California, January 6-8, 1998. 
[23] D. Malkhi, M. Merritt, O. Rodeh, Secure reliable 
multicast protocols in a WAN.  Proceedings of the IEEE 17th 
International Conference on Distributed Computing Systems, 
1997, pp. 94-97. 
[24] D. Malkhi and M. Reiter, "A high-throughput secure 
reliable multicast protocol, " Journal of Computer Security, 
IOS Press, 1997.  Earlier version of this paper appeared in 
Proceedings of the 9th Computer Security Foundations 
Workshop, Kenmore, Ireland (June 1996), pp. 9-17. 
[24] D. Malkhi and M. Reiter.  A high-throughput secure 
reliable multicast protocol.  The Journal of Computer 
Security, 5, 1997, pp 113-127. 
[25] P. Narasimhan, K. P. Kihlstrom, L. E. Moser, and P. M. 
Melliar-Smith, "Providing support for survivable CORBA 
applications with the Immune system," in Proceedings of the 
19th IEEE International Conference on Distributed 
Computing Systems, (Austin, TX), pp.507--516, May 1999. 
[26] M. Naor, B. Pinkas and O. Reingold, “Distributed 
Pseudo-random Functions and KDCs”, Advances in 
Cryptology–EUROCRYPT ’99 (LNCS 1592), 327–346, 
1999. 
[27] C. O'Ryan, F. Kuhns, D. Schmidt, O. Othman, and J. 
Parsons, The Design and Performance of a Pluggable 
Protocols Framework for Real-time Distributed Object 
Computing Middleware, in Proceedings of theIFIP/ACM 
Middleware 2000 Conference, Pallisades, New York, April 
3-7, 2000. 
[28] OMG.  General Inter-ORB Protocol. OMG specification 
CORBA V2.3, 15:1-62, June 1999. 
[29] OMG. The Common Object Request Broker: 
Architecture and specification. Revision 2.5, 2001. 
[30] OMG. The CORBA Security Service. Draft Adopted 
Revision 1.8, 2001. 
[31] B. Parhami, "Optimal Algorithms for Exact, Inexact, and 
Approval Voting," Digest of the 22nd International 
Symposium on Fault-Tolerant Computing, pp. 404-411.  
[32] Parameswaran, R., Blough, D., and Bakken, D.  “A 
Preliminary Investigation of Precision vs. Fault Tolerance 
Trade-offs in Voting Algorithms”, in Digest of FastAbstracts 
presented at the International Conference on Dependable 
Systems and Networks (DSN-2001), Göteborg, Sweden, July, 
2001.  
[33] Rivest, Shamir, Adleman. A Method for Obtaining 
Digital Signatures and Public-Key Cryptosystems. 
Communications of the ACM, 21(2), 1978. 
[34] Rivest. The MD5 Message-Digest Algorithm. Internet 
RFC-1321, 1992. 
[35] M. K. Reiter. Secure agreement protocols: Reliable and 
atomic group multicast in Rampart. In Proceedings of the 
2nd ACM Conference on Computer and Communication 
Security, pages 68-80, November 1994. 
[36] M. Reiter. The Rampart toolkit for building high-
integrity services. In Theory and Practice in Distributed 
Systems (Lecture Notes in Computer Science 938), pages 99-
110, Springer-Verlag, 1995. 
[37] F. Schneider, Implementing fault-tolerant services using 
the state machine approach: a tutorial, ACM Computer 
Surveys, 22,4 (Dec. 1990), Pages 299 – 319. 
[38] D. Schmidt, A. Gokhale, T. Harrison, and G. Parulkar.  
“A High-performance Endsystem Architecture for Real-
timeCORBA”, IEEE Communications Magazine, February, 
1997. 
[39] V. Shoup, “Practical threshold signatures”, Advances in 
Cryptology–EUROCRYPT ’2000, 2000. 
[40] Rodrigo Rodrigues, Miguel Castro, and Barbara Liskov, 
“BASE: Using Abstraction to Improve Fault Tolerance”,  
Proceedings of the 18th Symposium on Operating Systems 
Principles (SOSP '01), Banff, Canada, October 2001.  
[41] Pal P, Webber F, Schantz RE, and Loyall JP. Intrusion 
Tolerant Systems. Proceedings of the IEEE Information 
Survivability Workshop (ISW-2000), 24-26 October 2000, 
Boston, Massachusetts. 
Proceedings of the International Conference on Dependable Systems and Networks (DSN’02) 
0-7695-1597-5/02 $17.00 © 2002 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 04:16:17 UTC from IEEE Xplore.  Restrictions apply.