如果没有索引，搜寻查询将不得不扫描所有文件（如 grep），如果有著大量文件，这样做的开销巨大。没有索引意味著写入路径上的工作量较少（没有要更新的索引），但是在读取路径上需要更多工作。
另一方面，可以想象为所有可能的查询预先计算搜寻结果。在这种情况下，读路径上的工作量会减少：不需要布林逻辑，只需查询查询结果并返回即可。但写路径会更加昂贵：可能的搜寻查询集合是无限大的，因此预先计算所有可能的搜寻结果将需要无限的时间和储存空间。那肯定没戏 [^iii]。
[^iii]: 假设一个有限的语料库，那么返回非空搜寻结果的搜寻查询集合是有限的。然而，它是与语料库中的术语数量呈指数关系，这仍是一个坏讯息。
另一种选择是预先计算一组固定的最常见查询的搜寻结果，以便可以快速提供它们而无需转到索引。不常见的查询仍然可以透过索引来提供服务。这通常被称为常见查询的 **快取（cache）**，尽管我们也可以称之为 **物化检视（materialized view）**，因为当新文件出现，且需要被包含在这些常见查询的搜寻结果之中时，这些索引就需要更新。
从这个例子中我们可以看到，索引不是写路径和读路径之间唯一可能的边界；快取常见搜寻结果也是可行的；而在少量文件上使用没有索引的类 grep 扫描也是可行的。由此来看，快取，索引和物化检视的作用很简单：它们改变了读路径与写路径之间的边界。透过预先计算结果，从而允许我们在写路径上做更多的工作，以节省读路径上的工作量。
在写路径上完成的工作和读路径之间的界限，实际上是本书开始处在 “[描述负载](ch1.md#描述负载)” 中推特例子里谈到的主题。在该例中，我们还看到了与普通使用者相比，名人的写路径和读路径可能有所不同。在 500 页之后，我们已经绕回了起点！
#### 有状态、可离线的客户端
我发现写路径和读路径之间的边界很有趣，因为我们可以试著改变这个边界，并探讨这种改变的实际意义。我们来看看不同上下文中的这一想法。
过去二十年来，Web 应用的火热让我们对应用开发作出了一些很容易视作理所当然的假设。具体来说就是，客户端 / 伺服器模型 —— 客户端大多是无状态的，而伺服器拥有资料的权威 —— 已经普遍到我们几乎忘掉了还有其他任何模型的存在。但是技术在不断地发展，我认为不时地质疑现状非常重要。
传统上，网路浏览器是无状态的客户端，只有当连线到网际网路时才能做一些有用的事情（能离线执行的唯一事情基本上就是上下滚动之前线上时载入好的页面）。然而，最近的 “单页面” JavaScript Web 应用已经获得了很多有状态的功能，包括客户端使用者介面互动，以及 Web 浏览器中的持久化本地储存。移动应用可以类似地在装置上储存大量状态，而且大多数使用者互动都不需要与伺服器往返互动。
这些不断变化的功能重新引发了对 **离线优先（offline-first）** 应用的兴趣，这些应用尽可能地在同一装置上使用本地资料库，无需连线网际网路，并在后台网路连线可用时与远端伺服器同步【42】。由于移动装置通常具有缓慢且不可靠的蜂窝网路连线，因此，如果使用者的使用者介面不必等待同步网路请求，且应用主要是离线工作的，则这是一个巨大优势（请参阅 “[需要离线操作的客户端](ch5.md#需要离线操作的客户端)”）。
当我们摆脱无状态客户端与中央资料库互动的假设，并转向在终端使用者装置上维护状态时，这就开启了新世界的大门。特别是，我们可以将装置上的状态视为 **伺服器状态的快取**。萤幕上的画素是客户端应用中模型物件的物化检视；模型物件是远端资料中心的本地状态副本【27】。
#### 将状态变更推送给客户端
在典型的网页中，如果你在 Web 浏览器中载入页面，并且随后伺服器上的资料发生变更，则浏览器在重新载入页面之前对此一无所知。浏览器只能在一个时间点读取资料，假设它是静态的 —— 它不会订阅来自伺服器的更新。因此装置上的状态是陈旧的快取，除非你显式轮询变更否则不会更新。（像 RSS 这样基于 HTTP 的 Feed 订阅协议实际上只是一种基本的轮询形式）
最近的协议已经超越了 HTTP 的基本请求 / 响应模式：服务端传送的事件（EventSource API）和 WebSockets 提供了通讯通道，透过这些通道，Web 浏览器可以与伺服器保持开启的 TCP 连线，只要浏览器仍然连线著，伺服器就能主动向浏览器推送资讯。这为伺服器提供了主动通知终端使用者客户端的机会，伺服器能告知客户端其本地储存状态的任何变化，从而减少客户端状态的陈旧程度。
用我们的写路径与读路径模型来讲，主动将状态变更推至到客户端装置，意味著将写路径一直延伸到终端使用者。当客户端首次初始化时，它仍然需要使用读路径来获取其初始状态，但此后它就能够依赖伺服器传送的状态变更流了。我们在流处理和讯息传递部分讨论的想法并不局限于资料中心中：我们可以进一步采纳这些想法，并将它们一直延伸到终端使用者装置【43】。
这些装置有时会离线，并在此期间无法收到伺服器状态变更的任何通知。但是我们已经解决了这个问题：在 “[消费者偏移量](ch11.md#消费者偏移量)” 中，我们讨论了基于日志的讯息代理的消费者能在失败或断开连线后重连，并确保它不会错过掉线期间任何到达的讯息。同样的技术适用于单个使用者，每个装置都是一个小事件流的小小订阅者。
#### 端到端的事件流
最近用于开发有状态的客户端与使用者介面的工具，例如如 Elm 语言【30】和 Facebook 的 React、Flux 和 Redux 工具链，已经透过订阅表示使用者输入或伺服器响应的事件流来管理客户端的内部状态，其结构与事件溯源相似（请参阅 “[事件溯源](ch11.md#事件溯源)”）。
将这种程式设计模型扩充套件为：允许伺服器将状态变更事件推送到客户端的事件管道中，是非常自然的。因此，状态变化可以透过 **端到端（end-to-end）** 的写路径流动：从一个装置上的互动触发状态变更开始，经由事件日志，并穿过几个衍生资料系统与流处理器，一直到另一台装置上的使用者介面，而有人正在观察使用者介面上的状态变化。这些状态变化能以相当低的延迟传播 —— 比如说，在一秒内从一端到另一端。
一些应用（如即时讯息传递与线上游戏）已经具有这种 “实时” 架构（在低延迟互动的意义上，不是在 “[响应时间保证](ch8.md#响应时间保证)” 中的意义上）。但我们为什么不用这种方式构建所有的应用？
挑战在于，关于无状态客户端和请求 / 响应互动的假设已经根深蒂固地植入在我们的资料库、库、框架以及协议之中。许多资料储存支援读取与写入操作，为请求返回一个响应，但只有极少数提供订阅变更的能力 —— 请求返回一个随时间推移的响应流（请参阅 “[变更流的 API 支援](ch11.md#变更流的API支援)” ）。
为了将写路径延伸至终端使用者，我们需要从根本上重新思考我们构建这些系统的方式：从请求 / 响应互动转向释出 / 订阅资料流【27】。更具响应性的使用者介面与更好的离线支援，我认为这些优势值得我们付出努力。如果你正在设计资料系统，我希望你对订阅变更的选项留有印象，而不只是查询当前状态。
#### 读也是事件
我们讨论过，当流处理器将衍生资料写入储存（资料库，快取或索引）时，以及当用户请求查询该储存时，储存将充当写路径和读路径之间的边界。该储存应当允许对资料进行随机访问的读取查询，否则这些查询将需要扫描整个事件日志。
在很多情况下，资料储存与流处理系统是分开的。但回想一下，流处理器还是需要维护状态以执行聚合和连线的（请参阅 “[流连线](ch11.md#流连线)”）。这种状态通常隐藏在流处理器内部，但一些框架也允许这些状态被外部客户端查询【45】，将流处理器本身变成一种简单的资料库。
我愿意进一步思考这个想法。正如到目前为止所讨论的那样，对储存的写入是透过事件日志进行的，而读取是临时的网路请求，直接流向储存著待查资料的节点。这是一个合理的设计，但不是唯一可行的设计。也可以将读取请求表示为事件流，并同时将读事件与写事件送往流处理器；流处理器透过将读取结果传送到输出流来响应读取事件【46】。
当写入和读取都被表示为事件，并且被路由到同一个流运算元以便处理时，我们实际上是在读取查询流和资料库之间执行流表连线。读取事件需要被送往储存资料的资料库分割槽（请参阅 “[请求路由](ch6.md#请求路由)”），就像批处理和流处理器在连线时需要在同一个键上对输入分割槽一样（请参阅 “[Reduce 侧连线与分组](ch10.md#Reduce侧连线与分组)”）。