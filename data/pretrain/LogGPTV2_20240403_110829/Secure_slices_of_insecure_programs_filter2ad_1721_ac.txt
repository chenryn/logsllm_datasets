The computation of secure slices is based on the transfor-
mation function τ . This function is parameterized with the
set of invalid ﬂows in the program and is independent of the
approach used to identify these ﬂows; therefore, if we are
able to detect invalid ﬂows in presence of declassiﬁcation, a
secure slice can be computed using τ .
For example, in [11], Hammer et al. provide a dataﬂow
analysis framework for intransitive non-interference analysis
[26]. The framework is deﬁned over a dependence graph and
is specially designed to support information declassiﬁcation.
The information produced by this framework —a set of in-
valid ﬂows— can be used to appropriately modify a program
and produce secure slices from it. The prototype tool de-
scribed in the next section is based on this framework and,
as we show, it can be used to compute secure slices.
4. SECURE SLICING REAL LANGUAGES
An important and distinguishing feature of the transfor-
mation process presentend in this paper is its scalability to
real and non trivial programming languages such as Java.
There are well know algorithms for dependence analysis of
programs coded in modern programming languages —e.g.,
[24, 31, 5, 21]—, therefore it is possible to build information
ﬂow analyzers on top of them. Although this is true, there
are only a couple of such tools —e.g., the tool described in
[11]— and most of IFC systems are based on type systems —
e.g., Jif (originally named JFlow) [19] and Flow Caml [30]—.
We have developed a prototype tool capable of perform
IFC of software systems coded in Java and/or Java byte-
code and supporting security annotations at both levels:
source and bytecode. The tool also permits to enforce non-
interference in programs needing to intentionally declassify
information.
The tool, coded in Java, is based on the slicing and anal-
ysis libraries of Indus [25], a framework for the analysis
of full Java programs.5 The slicing library provides meth-
ods to compute highly customizable interprocedural context-
sensitive slices in back and forward direction. The analy-
sis library provides modules to calculate inter/intra method
data dependencies, control dependencies, interference de-
pendence6, ready dependence, and other related analysis.
Both libraries work on top of Jimple [23], a three address
representation for Java bytecode. Jimple is part of the Soot
framework [22] that provides libraries for Jimple manipula-
5With the exception of dynamic class loading, reﬂection,
and native methods.
6Here, the term interference is related with the concurrent
write/read access to shared memory between diﬀerent pro-
gram threads.
117
1 output ( wshp ) ;
2 output ( papDate ) ;
3 output ( papN um ) ;
4 output ( papT tl ) ;
5 output ( authors ) ;
6 output ( ref eree ) ;
7 pc := f a l s e ;
8 i f
9 output ( ‘ r e v i e w i n g ’ )
( state = 0 ) then
i f
i f
e l s e
( state = 1 ) then
output ( ‘ a c c e p t e d ’ ) ;
pc := t r u e
( state = −1 ) then
output ( ‘ r e j e c t e d ’ )
pc := t r u e
10 e l s e
11
12
13
14
15
16
17
18
19 e n d i f
20 e n d i f ;
21 i f
22 output ( ref Comments ) ;
23 e l s e s k i p e n d i f
( pc = t r u e ) then
e l s e s k i p e n d i f
1 output ( wshp ) ;
2 output ( papDate ) ;
3 output ( papN um ) ;
4 output ( papT tl ) ;
5 output ( authors ) ;
6 s k i p ;
7 pc := f a l s e ;
8 i f
9 output ( ‘ r e v i e w i n g ’ )
( state = 0 ) then
i f
i f
( state = 1 ) then
output ( ‘ a c c e p t e d ’ ) ;
pc := t r u e
( state = −1 ) then
output ( ‘ r e j e c t e d ’ )
pc := t r u e
10 e l s e
11
12
13
14 e l s e
15
16
17
18
19 e n d i f
20 e n d i f ;
21 i f
22 output ( ref Comments ) ;
23 e l s e s k i p e n d i f
( pc = t r u e ) then
e l s e s k i p e n d i f
1 output ( wshp ) ;
2 output ( papDate ) ;
3 output ( papN um ) ;
4 output ( papT tl ) ;
5 s k i p ;
6 output ( ref eree ) ;
7 pc := f a l s e ;
8 i f
9 output ( ‘ r e v i e w i n g ’ )
( state = 0 ) then
i f
i f
( state = 1 ) then
output ( ‘ a c c e p t e d ’ ) ;
pc := t r u e
( state = −1 ) then
output ( ‘ r e j e c t e d ’ )
pc := t r u e
10 e l s e
11
12
13
14 e l s e
15
16
17
18
19 e n d i f
20 e n d i f ;
21 i f
22 output ( ref Comments ) ;
23 e l s e s k i p e n d i f
( pc = t r u e ) then
e l s e s k i p e n d i f
1 output ( wshp ) ;
2 output ( papDate ) ;
3 output ( papN um ) ;
4 output ( papT tl ) ;
5 s k i p ;
6 s k i p ;
7 pc := f a l s e ;
8 i f
9 s k i p
( state = 0 ) then
( state = −1 ) then
( state = 1 ) then
i f
i f
s k i p ;
pc := t r u e
10 e l s e
11
12
13
14 e l s e
15
16
17
18
19 e n d i f
20 e n d i f ;
21 i f
22 s k i p ;
23 e l s e s k i p e n d i f
s k i p
pc := t r u e
e l s e s k i p e n d i f
( pc = t r u e ) then
(a) Original program
(b) Slice for authors
(c) Slice for referees
(d) Slice for general public
Figure 4: Example program and three of its secure versions
void s e t ( ){ x =2;}
i n t x ;
void s e t ( ){ x =0;}
void s e t ( i n t i ){ x=i ;}
i n t g e t ( ) { return x ;}
1 public c l a s s A {
2
3
4
5
6 }
7 public c l a s s B extends A {
8
9 }
10 public c l a s s I n f F l o w {
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26 }
}
public s t a t i c void main ( S t r i n g [ ] a ) {
i n t s e c = 0 ; // P : High
i n t pub = 1 ;
A o = new A ( ) ;
o . s e t ( s e c ) ;
o = new A ( ) ;
o . s e t ( pub ) ;
System . o ut . p r i n t ( o . g e t ( ) ) ; // A: Low
i f
( s e c==0 && a [ 0 ] . e q u a l s ( ”007 ” ) )
o = new B ( ) ;
o . s e t ( ) ;
System . o ut . p r i n t ( o . g e t ( ) ) ; // A: Low
o . s e t ( 4 2 ) ;
System . o ut . p r i n t ( o i n s t a n c e o f B ) ; // A: Low
Figure 5: A Java program with invalid ﬂows
tion —e.g., addition, deletion, and transformation of byte
code—.
Indus and Soot libraries sets allow us to identify
invalid ﬂows in Java programs and to modify them appro-
priately to produce secure slices from them.
Consider the Java program of Figure 5, this example pro-
gram7 will let us show how the tool deals with complex fea-
tures of Java such as object sensitivity and dynamic dis-
patch. Security annotations, using a two level security lat-
tice Low → High, are given as program comments for the
sake of clarity.8 Provides tags (P) are used to mark state-
ments generating secure data; Allows tags (A) are used to
indicate the allowed upper security level of the information
ﬂowing to an output channel.
To identify invalid ﬂows, the tool computes the backward
7Borrowed from [11].
8Security annotations are actually written in separated text
ﬁles.
118
slice for each one of the allows-tagged statements of the pro-
gram —statements 18, 22, and 24 in our example—. Then
each slice is analyzed looking for statements providing in-
formation at a security level not lower nor equal than the
allowed level of the criterion statement; if that is the case,
an invalid ﬂow has been identiﬁed. The analysis of the three
slices from our example is:
• The backward slice9 for statement 18 is {13, 16, 17}
and does not include any provides-tagged statement,
therefore ﬂows to 18 are valid. Notice that the tool is
able to detect that the object referenced at line 18, is
in fact the object created at line 16 and not the ﬁrst
created object (line 14) which was set with a High
value (variable sec).
• The backward slice for statement 22 is {11, 12, 16, 17,
19, 20, 21}. Because statement 12 provides a High
ﬂow, the tool will indicate the existence of an invalid
ﬂow 12 ; 22.
• The backward slice for statement 24, as the slice for
22 does, includes statement 12 because statements 19
and 20 are also included; the tool will report the invalid
ﬂow 12 ; 24.
From the analysis we can conclude that statements 22 and
24 are the sink of two invalid ﬂows, therefore they need to be
modiﬁed in order to get a secure slice. Both sentences can be
eliminated or changed to output a default value by applying
τ transformation function. Figure 6 shows a secure slice of
the example program; statements 22 and 24 now print out
a default message.
4.1 Example: A Java Program with Declassi-
ﬁcation
A typical example of a program that needs to intentionally
declassify information is a password checking program like
the one listed at Figure 7. The program is annotated with
security levels from the lattice P ublic → Conf idential →
Secret. Password list is Secret, user names list and the
query introduced by the user are Conf idential.
9For the sake of clarity, we do not include statements outside
InfFlow.main method.
public s t a t i c void main ( S t r i n g [ ] a ) {
i n t s e c = 0 ; // P : High
i n t pub = 1 ;
A o = new A ( ) ;
o . s e t ( s e c ) ;
o = new A ( ) ;
o . s e t ( pub ) ;
System . o ut . p r i n t ( o . g e t ( ) ) ; // A: Low
i f
( s e c==0 && a [ 0 ] . e q u a l s ( ”007 ” ) )
o = new B ( ) ;
1 public c l a s s I n f F l o w {
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17 }
o . s e t ( ) ;
System . o ut . p r i n t ( ”Ce nsored ” ) ; // A: Low
o . s e t ( 4 2 ) ;
System . o ut . p r i n t ( ”Ce nsored ” ) ; // A: Low
}
Figure 6: Secure slice of the Java program at Listing
5
private S t r i n g [ ] names ; // P : C o n f i d e n t i a l
private S t r i n g [ ] p a s s w o r d s ; // P : S e c r e t
public boolean c h e c k (
S t r i n g username ,
S t r i n g q u e r y // P : C o n f i d e n t i a l
){
boolean match = f a l s e ;
boolean nameOkFlag = f a l s e ;
f o r ( i n t i =0; i  P u b l i c
nameOkFlag = true ;
i f