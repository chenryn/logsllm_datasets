>>> True == 1
True
>>> False == 0
True
>>> True + 1
2
!41
学习笔记 . 第三版
布尔转换时，数字零、空值（None）、空序列和空字典被视作 False，反之为 True。
>>> data = (0, 0.0, None, "", list(), tuple(), dict(), set(), frozenset())
>>> any(map(bool, data))
False
对于⾃定义类型，可通过重写 __bool__ 或 __len__ ⽅法影响 bool 转换结果。
枚举
Python 语⾔规范⾥并没有枚举（enum）定义，⽽是采⽤标准库实现。
在多数语⾔⾥，枚举是⾯向编译器，类似数字常量的存在。但到了 Python 这⾥，事情变
得有些复杂。⾸先，需要定义枚举类型，随后由内部代码⽣成对应的枚举值。
>>> import enum
>>> Color = enum.Enum("Color", "BLACK YELLOW BLUE RED")
>>> isinstance(Color.BLACK, Color)
True
>>> list(Color)
[, , , ]
并没有规定枚举值就必须是整数。通过继承 Enum，可将其指定为任何类型。
>>> class X(enum.Enum):
A = "a"
B = 100
C = [1, 2, 3]
>>> X.C
!42
学习笔记 . 第三版
枚举类型内部以字典⽅式实现，每个枚举值都有 name 和 value 属性。可通过名字或值查
找对应的枚举实例。
>>> X.B.name
'B'
>>> X.B.value
100
>>> X["B"] # by-name
>>> X([1, 2, 3]) # by-value
>>> X([1, 2])
ValueError: [1, 2] is not a valid X
按照字典规则，值（value）可以相同，但名字（name）不许重复。
>>> class X(enum.Enum):
A = 1
B = 1
>>> class X(enum.Enum):
A = 1
A = 2
TypeError: Attempted to reuse key: 'A'
只是当值相同时，⽆论基于名字还是值查找，都返回第⼀个定义项。
>>> class X(enum.Enum):
A = 100
B = "b"
C = 100
>>> X.A
!43
学习笔记 . 第三版
>>> X.C
>>> X["C"]
>>> X(100)
如要避免值相同的枚举定义，可⽤ enum.unique 装饰器。
相⽐传统枚举常量，标准库 enum 提供了丰富的扩展功能，包括⾃增数字（auto）、标志
位（Flag），以及整型枚举等。只是这些需额外的内存和性能开销，算是各有利弊。
内存
对于常⽤⼩数字，系统初始化时会预先缓存。稍后使⽤，直接将名字关联到这些预缓存对
象即可。如此，可避免对象创建过程，提⾼性能，且节约内存开销。
以 Python 3.6 为例，其预缓存范围是 [-5, 256]。
具体过程请阅读 Objects/longobject.c : _PyLong_Init 源码。
>>> a = -5
>>> b = -5
>>> a is b
True
>>> a = 256
>>> b = 256
>>> a is b
True
如果超出范围，那么每次都要新建对象，这其中⾃然包括内存分配等操作。
>>> a = -6
>>> b = -6
>>> a is b
False
!44
学习笔记 . 第三版
>>> a = 257
>>> b = 257
>>> a is b
False
如果⽤ Python 开发⼤数据等应⽤，免不了要创建并持有海量数字对象（⽐如超⼤ ID 列
表）。Python 2.7 对回收后的整数复⽤缓存区不作收缩处理，这会导致⼤量闲置内存驻留。
⽽ Python 3 则改进了此设计，极⼤减少了内存占⽤，这也算是迁移到新版的⼀个理由。
公平起见，下⾯测试代码在 Ubuntu 16.04 下分别以 Python 2.7 和 Python 3.6 运⾏，输出不同阶段
RSS 内存⼤⼩。⽰例中使⽤了第三⽅库 psutil。
from __future__ import print_function
import psutil
def mem_usage(): # 输出进程 RSS 内存⼤大⼩小。
m = psutil.Process().memory_info()
print(m.rss >> 20, "MB")
mem_usage() # 起始内存占⽤用。
x = list(range(10000000)) # 使⽤用列列表持有海海量量数字对象。
mem_usage() # 输出海海量量数字造成的内存开销。
del x # 删除列列表，回收数字对象。
mem_usage() # 输出回收后内存占⽤用。
输出：
$ python2.7 ./main.py
11 MB
323 MB
246 MB
$ python3.6 ./main.py
11 MB
397 MB
11 MB
!45
学习笔记 . 第三版
2.2 浮点数
默认 float 类型存储双精度（double）浮点数，可表达 16 到 17 个⼩数位。
>>> 1/3
0.3333333333333333
>>> 0.1234567890123456789
0.12345678901234568
从实现⽅式看，浮点数以⼆进制存储⼗进制数的近似值。这可能会导致执⾏结果与编码预
期不符，造成算法结果不⼀致性缺陷。对精度有要求的场合，应选择固定精度类型。
可通过 float.hex ⽅法输出实际存储值的⼗六进制格式字符串，以检查执⾏结果为何不同。
另外，还可⽤该⽅式实现浮点值的精确传递，避免精度丢失。
>>> 0.1 * 3 == 0.3
False
>>> (0.1 * 3).hex() # 显然两个存储内容并不不相同。
0x1.3333333333334p-2
>>> (0.3).hex()
0x1.3333333333333p-2
>>> s = (1/3).hex()
>>> float.fromhex(s) # 反向转换回浮点数。
0.3333333333333333
对于简单⽐较操作，可尝试将浮点数限制在有效固定精度内。但考虑到 round 算法实现的
⼀些问题，更精确做法是⽤ decimal.Decimal 类型。
>>> round(0.1 * 3, 2) == round(0.3, 2) # 避免不不确定性，左右都使⽤用固定精度。
True
>>> round(0.1, 2) * 3 == round(0.3, 2) # 将 round 返回值作为操作数，导致精度再次丢失。
False
!46
学习笔记 . 第三版
不同类型的数字之间，可直接进⾏加减法和⽐较等运算。
>>> 1.1 + 2
3.1
>>> 1.1 >> 1.1 == 1
False
转换
将整数或字符串转换为浮点数很简单，且能⾃动处理字符串内正负符号和空⽩符。只是超
出有效精度时，结果与字符串内容存在差异。
>>> float(100)
100.0
>>> float("-100.123") # 符号
-100.123
>>> float("\t 100.123\n") # 空⽩白符
100.123
>>> float("1.234E2") # 科学记数法
123.4
>>> float("0.1234567890123456789")
0.12345678901234568
反过来，将浮点数转换为整数时，有多种不同⽅案可供选择。可截掉（int, trunc）⼩数部
分，或分别往⼤（ceil）、⼩（floor）⽅向取临近整数。
>>> int(2.6), int(-2.6)
(2, -2)
>>> from math import trunc, floor, ceil
!47
学习笔记 . 第三版
>>> trunc(2.6), trunc(-2.6) # 截断⼩小数部分。
(2, -2)
>>> floor(2.6), floor(-2.6) # 往⼩小数字⽅方向取最近整数。
(2, -3)
>>> ceil(2.6), ceil(-2.6) # 往⼤大数字⽅方向取最近整数。
(3, -2)
floor floor
ceil ceil
-2.6 2.6
-3 -2 -1 0 1 2 3
十进制浮点数
相⽐ float 基于硬件的⼆进制浮点类型，decimal.Decimal 是⼗进制实现，最⾼可提供 28 位
有效精度。能准确表达⼗进制数和运算，不存在⼆进制近似值问题。
>>> 1.1 + 2.2 # 结果与 3.3 近似。
3.3000000000000003
>>> (0.1 + 0.1 + 0.1 - 0.3) == 0 # 同样⼆二进制近似值计算结果与⼗十进制预期不不符。
False
>>> from decimal import Decimal
>>> Decimal("1.1") + Decimal("2.2")
Decimal('3.3')
>>> (Decimal("0.1") + Decimal("0.1") + Decimal("0.1") - Decimal("0.3")) == 0
True
在创建 Decimal 实例时，应该传⼊⼀个准确的数值，⽐如整数或字符串等。如果是 float
类型，那么要知道在构建之前，其精度就已丢失。
>>> Decimal(0.1)
!48
学习笔记 . 第三版
Decimal('0.1000000000000000055511151231257827021181583404541015625')
>>> Decimal("0.1")
Decimal('0.1')
在需要时，可通过上下⽂（context）修改 Decimal 默认的 28 位精度。
>>> from decimal import Decimal, getcontext
>>> getcontext()
Context(prec=28, ...)
>>> getcontext().prec = 2
>>> Decimal(1) / Decimal(3)
Decimal('0.33')
或者⽤ localcontext 限制某个区域的精度。
>>> from decimal import localcontext
>>> getcontext().prec = 28
>>> with localcontext() as ctx: # 在该范围内将精度修改为 2。
ctx.prec = 2
print(getcontext().prec)
print(Decimal(1) / Decimal(3))
2
0.33
>>> getcontext().prec # 不不会影响外部精度。
28
除⾮有明确需求，否则不要⽤ Decimal 替代 float，要知道前者运算速度要慢许多。
四舍五入
同样因为近似值和精度问题，造成对 float 进⾏ “四舍五⼊”（round）操作存在不确定性，
其结果会导致⼀些不易察觉的陷阱。
!49
学习笔记 . 第三版
>>> round(0.5) # 5 舍
0
>>> round(1.5) # 5 ⼊入
2
⾸先，按照 round 算法规则，按临近数字（舍⼊后）的距离远近来考虑是否进位。如此，
四舍六⼊就是确定的，相关问题都集中在两边距离相等的 5 是否进位。
以 0.4 为例，其舍⼊后的相邻数字是 0 和 1，从距离上看⾃然是 0 更近⼀些。
对于 5，还要考虑后⾯是否还有⼩数位。如果有，那么左右距离就不可能是相等的，这⾃
然是要进位的。
>>> round(0.5) # 与 0、1 距离相等，不不确定。
0
>>> round(0.500001) # 哪怕 5 后⾯面的⼩小数部分再⼩小，那也表示它更更接近 1。
1
>>> round(1.25, 1)
1.2
>>> round(1.25001, 1)
1.3
剩下的，要看是返回整数还是浮点数。如果是整数，取临近的偶数。
>>> round(0.5) # 0 ---> 0.5 ---> 1
0
>>> round(1.5) # 1 ---> 1.5 ---> 2
2
>>> round(2.5) # 2 ---> 2.5 ---> 3
2
在不同版本下，规则存在差异。⽐如 Python 2.7，round 2.5 返回 3.0。
从这点来看，我们应谨慎对待此类⾏为差异，并严格测试其造成的影响。
!50
学习笔记 . 第三版
如果依旧返回浮点数，事情就变的有点莫名其妙。有些⽂章宣称 “奇舍偶⼊” 或 “五成双”
等，也就是看数字 5 前⼀位⼩数奇偶来决定是否进位，但事实未必如此。
>>> round(1.25, 1) # 偶舍
1.2
>>> round(1.245, 2) # 偶进