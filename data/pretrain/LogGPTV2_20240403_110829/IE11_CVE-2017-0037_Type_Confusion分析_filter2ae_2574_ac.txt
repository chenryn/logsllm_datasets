      *((_DWORD *)v4 + 14) = 0;
      *((_DWORD *)v4 + 8) = 0;
      *((_DWORD *)v4 + 15) = 0;
      *((_DWORD *)v4 + 16) = 0;
      v6 = Array::Create((int *)&v8, *(_DWORD *)(a2 + 80) + 1);
      SArray::operator=(v5, v6);
      if ( *v5 )
        Layout::STableBoxSizeCalculator::STableColumnDistributor::CalculateColumnsUsedWidth(v4);
      else
        *a4 = 0;
      return v4;
    }
其值被`Layout::STableBoxSizeCalculator::STableColumnDistributor::CalculateColumnsUsedWidth`更改
    void __thiscall Layout::STableBoxSizeCalculator::STableColumnDistributor::CalculateColumnsUsedWidth(Layout::STableBoxSizeCalculator::STableColumnDistributor *this)
    {
      Layout::STableBoxSizeCalculator::STableColumnDistributor *v1; // esi
      Layout::STableBoxSizeCalculator::STableColumnDistributor *v2; // ecx
      Layout::STableBoxSizeCalculator::STableColumnDistributor *v3; // ecx
      int v4; // [esp+4h] [ebp-4h]
      v1 = this;
      Layout::STableBoxSizeCalculator::STableColumnDistributor::CalculateColumnsTotalMinMaxWidths(this);
      Layout::STableBoxSizeCalculator::STableColumnDistributor::CalculatePercentColumnsTotalUsedWidth(v1);
      Layout::STableBoxSizeCalculator::STableColumnDistributor::CalculatePercentColumnsUsedWidth(v1, &v4);
      Layout::STableBoxSizeCalculator::STableColumnDistributor::CalculateNonPercentColumnsUsedWidth(v1, v4);
      Layout::STableBoxSizeCalculator::STableColumnDistributor::CalculatePixelAndAutoColumnsTotalWidth(v1);
      Layout::STableBoxSizeCalculator::STableColumnDistributor::DeterminePixelAndAutoColumnsDistributionMethod(v2);
      Layout::STableBoxSizeCalculator::STableColumnDistributor::CalculateAutoColumnsUsedWidth(v3);
      Layout::STableBoxSizeCalculator::STableColumnDistributor::CalculatePixelColumnsUsedWidth(v1); // 改变值函数
      Layout::STableBoxSizeCalculator::STableColumnDistributor::DistributeRoundingErrors(v1);
    }
根据反复调试，最后更改数据的函数在这里
    void __thiscall Layout::STableBoxSizeCalculator::STableColumnDistributor::CalculatePixelColumnsUsedWidth(Layout::STableBoxSizeCalculator::STableColumnDistributor *this)
    {
      Layout::STableBoxSizeCalculator::STableColumnDistributor *v1; // edi
      int v2; // ebx
      int v3; // eax
      int v4; // ecx
      int v5; // eax
      int v6; // eax
      int v7; // eax
      int v8; // eax
      int v9; // esi
      int v10; // esi
      _DWORD **v11; // eax
      int v12; // edi
      _DWORD *v13; // eax
      _DWORD *v14; // eax
      int v15; // [esp+Ch] [ebp-24h]
      int v16; // [esp+10h] [ebp-20h]
      int v17; // [esp+18h] [ebp-18h]
      char v18; // [esp+1Ch] [ebp-14h]
      char v19; // [esp+20h] [ebp-10h]
      char v20; // [esp+24h] [ebp-Ch]
      Layout::STableBoxSizeCalculator::STableColumnDistributor *v21; // [esp+28h] [ebp-8h]
      int v22; // [esp+2Ch] [ebp-4h]
      v1 = this;
      v2 = 0;
      v21 = this;
      if ( *((_DWORD *)this + 3) > 0 )
      {
        v3 = *((_DWORD *)this + 16);
        v4 = *(_DWORD *)(*(_DWORD *)this + 80) + 1;
        v22 = *(_DWORD *)(*(_DWORD *)v1 + 80) + 1;
        v5 = v3 - 1;
        if ( v5 )
        {
          v6 = v5 - 1;
          if ( v6 )
          {
            v7 = v6 - 1;
            if ( v7 )
            {
              if ( v7 == 1 )
              {
                v8 = 0;
                v9 = *((_DWORD *)v1 + 11) - *((_DWORD *)v1 + 7);
                v21 = 0;
                if ( v4 > 0 )
                {
                  do
                  {
                    Tree::TableGridBlock::ColumnMeasure(*(_DWORD **)v1, &v15, v8);
                    if ( v17 && v17 == 1 )
                    {
                      if ( *((_DWORD *)v1 + 7)  0 )
              {
                do
                {
                  Tree::TableGridBlock::ColumnMeasure(*v11, &v15, v2);
                  if ( v17 && v17 == 1 )
                  {
                    v13 = Math::SLayoutMeasure::MulDivQuickRound(&v18, v12, v16 - v15, v10);
                    *(_DWORD *)(*((_DWORD *)v21 + 2) + 4 * v2) = v15 + *v13;
                  }
                  v11 = (_DWORD **)v21;
                  ++v2;
                }
                while ( v2  0 )
          {
            do
            {
              Tree::TableGridBlock::ColumnMeasure(*(_DWORD **)v1, &v15, v2);// 更改v16
              if ( v17 && v17 == 1 )
                *(_DWORD *)(*((_DWORD *)v1 + 2) + 4 * v2) = v16;// 改变值的循环
              ++v2;
            }
            while ( v2  0 )
        {
          do
          {
            Tree::TableGridBlock::ColumnMeasure(*(_DWORD **)v1, &v15, v2);
            if ( v17 && v17 == 1 )
              *(_DWORD *)(*((_DWORD *)v1 + 2) + 4 * v2) = v15;
            ++v2;
          }
          while ( v2  output
因为目前已知结果只和`width`有关，所以假设结果和输入是一元一次的线性关系，并设置`colspan`为0
    a*input_1 + b = output_1
    a*input_2 + b = output_2
结果为`a=100,b=200`，测试一个数据`input_1=50`，计算结果为`0x1450`
至此，整个关系捋清楚了，我们可以通过堆喷，从而控制`EIP`，但是在利用的过程中发现，只用`CVE-2017-0037`没有办法直接绕过`win7`下的`ASLR+DEP`，还需要一个内存泄露的洞来形成利用链才行。所以打算下篇分析[CVE-2017-0059](https://www.exploit-db.com/exploits/41661)，这个洞由于`UAF`导致的内存泄露，正好结合这个洞，形成一个完整的利用链。到时再给出完整的exploit。但是还有很多`fuzzing`结果需要分析，可能会稍微慢点：）。
## 总结
第一次分析浏览器相关的漏洞，可能是难度比较大，导致这个洞的分析资料比较少，中文的也就`k0shl`大牛的分析还算详细，但是很多跳跃太大了，要想连贯起来，作为新手还要花费很多时间去不断调试。分析过程很痛苦，但是收获也很大。
最后欢迎批评指正。
## 参考
[P0 ifratric](https://bugs.chromium.org/p/project-zero/issues/detail?id=1011)
[k0shl分析](https://whereisk0shl.top/cve_2017_0037_ie11&edge_type_confusion.html)
[CVE to PoC – CVE-2017-0037](https://redr2e.com/cve-to-poc-cve-2017-0037/)