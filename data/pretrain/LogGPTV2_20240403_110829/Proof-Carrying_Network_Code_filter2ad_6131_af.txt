CCS ’19, November 11–15, 2019, London, United Kingdom
Skalka et al.
[4] Carolyn Jane Anderson, Nate Foster, Arjun Guha, Jean-Baptiste Jeannin, Dexter
Kozen, Cole Schlesinger, and David Walker. 2014. NetKAT: Semantic Founda-
tions for Networks. In ACM Symposium on Principles of Programming Languages
(POPL).
[5] Andrew W. Appel and Edward W. Felten. 1999. Proof-carrying Authentication.
In ACM Conference on Computer and Communications Security (CCS). 52–62.
https://doi.org/10.1145/319709.319718
[6] Ljudevit Bauer. 2003. Access Control for the Web via Proof Carrying Authorization.
[7] Qiang Cao, Vamsi Thummala, Jeffrey S. Chase, Yuanjun Yao, and Bing Xie. 2017.
Certificate Linking and Caching for Logical Trust. CoRR abs/1701.06562 (2017).
http://arxiv.org/abs/1701.06562
[8] Peter Chapin, Christian Skalka, and X. Sean Wang. 2008. Authorization in Trust
Ph.D. Dissertation. Princeton University.
Management: Features and Foundations. Comput. Surveys 40, 3 (2008), 1–48.
[9] CloudFlare. 2019. Cloudflare. https://www.cloudflare.com/.
[10] Heather Crawford, Karen Renaud, and Tim Storer. 2013. A framework for con-
tinuous, transparent mobile device authentication. Elsevier Computers & Security
39 (2013), 127–136.
[11] fitbit. 2019. Fitbit Charge 3. https://www.fitbit.com/home.
[12] Nate Foster, Rob Harrison, Michael J. Freedman, Christopher Monsanto, Jennifer
Rexford, Alec Story, and David Walker. 2011. Frenetic: A Network Programming
Language. In ACM International Conference on Functional Programming (ICFP).
279–291.
[13] Nate Foster, Dexter Kozen, Matthew Milano, Alexandra Silva, and Laure Thomp-
son. 2015. A Coalgebraic Decision Procedure for NetKAT. In ACM Symposium on
Principles of Programming Languages (POPL). 343–355. https://doi.org/10.1145/
2676726.2677011
3 Model B+.
[14] Raspberry Pi
Raspberry Pi
2019.
Foundation.
https://www.raspberrypi.org/.
[15] Deepak Garg. 2007. An Introduction to Proof-Carrying Authorization. https:
//people.mpi-sws.org/~dg/papers/intro-pca.pdf Course notes for CMU 18-739:
Foundations of Security and Privacy.
[16] Deepak Garg and Martín Abadi. 2008. A Modal Deconstruction of Access
Control Logics. In Proceedings of the Theory and Practice of Software, 11th In-
ternational Conference on Foundations of Software Science and Computational
Structures (FOSSACS’08/ETAPS’08). Springer-Verlag, Berlin, Heidelberg, 216–230.
http://dl.acm.org/citation.cfm?id=1792803.1792819
[17] Deepak Garg and Frank Pfenning. 2012. Stateful Authorization Logic—Proof
Theory and a Case Study. Journal of Computer Security 20, 4 (July 2012), 353–391.
http://dl.acm.org/citation.cfm?id=2590602.2590605
[18] Arpit Gupta, Nick Feamster, and Laurent Vanbever. 2016. Authorizing Network
Control at Software Defined Internet Exchange Points. In Proceedings of the
Symposium on SDN Research (SOSR ’16). ACM, New York, NY, USA, Article 16,
6 pages. https://doi.org/10.1145/2890955.2890956
[19] Andrew K. Hirsch and Michael R. Clarkson. 2013. Belief Semantics of Authoriza-
tion Logic. In ACM Conference on Computer and Communications Security (CCS).
561–572. https://doi.org/10.1145/2508859.2516667
[20] iHealth. 2019. iHealth. https://ihealthlabs.com/.
[21] INRIA. 2019. OCaml. https://ocaml.org/.
[22] Peyman Kazemian, George Varghese, and Nick McKeown. 2012. Header Space
Analysis: Static Checking for Networks. In USENIX Symposium on Network Sys-
tems Design and Implementation (NSDI).
[23] Ahmed Khurshid, Xuan Zou, Wenxuan Zhou, Matthew Caesar, and P. Brighten
Godfrey. 2013. VeriFlow: Verifying Network-Wide Invariants in Real Time. In
USENIX Symposium on Network Systems Design and Implementation (NSDI).
[24] Dexter Kozen. 1997. Kleene algebra with tests. Transactions on Programming
Languages and Systems 19, 3 (May 1997), 427–443.
[25] Diego Kreutz, Fernando M.V. Ramos, and Paulo Verissimo. 2013. Towards Secure
and Dependable Software-defined Networks. In ACM SIGCOMM Workshop on
Hot Topics in Software Defined Networking (HotSDN). 55–60. https://doi.org/10.
1145/2491185.2491199
[26] Dan Mihai, James Martucci, and Kenneth Kohler. 2004. System and method for
medical device authentication. US Patent App. 10/748,762.
[27] Takayuki Miura, Tsuyoshi Ono, Naoshi Suzuki, and Kouji Miyata. 2010. Device
authentication system. US Patent 7,681,033.
[28] Christopher Monsanto, Joshua Reich, Nate Foster, Jennifer Rexford, and David
Walker. 2013. Composing Software Defined Networks. In USENIX Symposium on
Networked Systems Design and Implementation (NSDI), Lombard, IL.
[29] George C. Necula. 1997. Proof-carrying Code. In ACM SIGPLAN-SIGACT
Symposium on Principles of Programming Languages (POPL). 106–119. https:
//doi.org/10.1145/263699.263712
[30] B. Pfaff, J. Pettit, T. Koponen, E. J. Jackson, A. Zhou, J. Rajahalme, J. Gross, A.
Wang, J. Stringer, P. Shelar, K. Amidon, and M. Casado. 2015. The Design and
Implementation of Open vSwitch. In USENIX Symposium on Networked Systems
Design and Implementation (NSDI). 117–130.
[31] Frank Pfenning and Rowan Davies. 2001. A Judgmental Reconstruction of Modal
Logic. Mathematical. Structures in Comp. Sci. 11, 4 (Aug. 2001), 511–540. https:
//doi.org/10.1017/S0960129501003322
[32] Philip Porras, Seungwon Shin, Vinod Yegneswaran, Martin Fong, Mabry Tyson,
and Guofei Gu. 2012. A Security Enforcement Kernel for OpenFlow Networks. In
ACM SIGCOMM Workshop on Hot Topics in Software Defined Networks (HotSDN).
121–126. https://doi.org/10.1145/2342441.2342466
[33] Yue Qiu and Maode Ma. 2016. A mutual authentication and key establishment
IEEE transactions on
[34] Freddy K Santoso and Nicholas CH Vun. 2015. Securing IoT for smart home
scheme for m2m communication in 6lowpan networks.
industrial informatics 12, 6 (2016), 2074–2085.
system. In IEEE International Symposium on Consumer Electronics (ISCE). 1–2.
[35] Fred B. Schneider, Kevin Walsh, and Emin Gün Sirer. 2011. Nexus Authorization
Logic (NAL): Design Rationale and Applications. ACM Trans. Inf. Syst. Secur. 14,
1, Article 8 (June 2011), 28 pages. https://doi.org/10.1145/1952982.1952990
https://github.com/
ring cryptography API for Rust.
[36] Brian Smith. 2019.
briansmith/ring
[37] Steffen Smolka, Spiridon Eliopoulos, Nate Foster, and Arjun Guha. 2015. A Fast
Compiler for NetKAT. In ACM International Conference on Functional Program-
ming (ICFP). 328–341. https://doi.org/10.1145/2858949.2784761
[38] Richard Statman. 1979. Intuitionistic propositional logic is polynomial-space
complete. Theoretical Computer Science 9, 1 (1979), 67 – 72. https://doi.org/10.
1016/0304-3975(79)90006-9
[39] Mininet Team. 2019. Mininet. http://mininet.org/.
[40] withings. 2019. Withings BPM Core. https://www.withings.com/.
A System FSays DEFINITION
Section 3 presented a summary of System FSays. This appendix
provides a more complete definition.
The syntax of System FSays is given in Figure 10. The language
is an extension of System F with a Says monad to represent the
Says modality in NALlight, and other features to represent NALlight
connectives. Types τ of System FSays have a tight correspondence
with NALlight formulas F. The System F fragment of System FSays
is adequate to represent implication and higher order quantification
as in NALlight, and the addition of sum (+) and product (×) types are
adequate to represent disjunction and conjunction. The Says monad
is realized using the return and bind style. Existential quantification
is realized using standard pack and unpack terms. The predicate
reconfig(p) asserts the intent to install configuration program p,
while p ≼ q asserts semantic containment of p in q. The language
could be endowed with a type preserving reduction semantics [31],
but we leave this as future work.
The System FSays type derivation rules are given in Figure 11.
There are two main judgment forms, well-formedness, S ⊢ τ where
S is a set of variables assumed to be in scope and τ is required to
have no free variables outside of S, and typing judgments S, Γ ⊢ e : τ
where Γ is a free variable typing environment. These rules are fairly
standard and include System F-style polymorphism, existential
quantification for pack and unpack, and monadic typing rules for
return and bind. Most notable is the Equiv rule, which is predicated
on the NetKAT equivalence p ≡ q.
Proof-Carrying Network Code
CCS ’19, November 11–15, 2019, London, United Kingdom
p
X
A
τ
x
e
v
Γ
S
∈
∈
∈
∈
∈
∈
∈
∈
∈
Unit
S ⊢ unit
. . .
prog (cid:66)
(cid:66)
tvar
pals (cid:66)
type (cid:70) unit | τ + τ | τ × τ | τ → τ | X | ∀X .τ | ∃X .τ |
. . .
. . .
τ Says τ | install(τ) | τ ≼ τ | p | A
var
. . .
exp (cid:70) tt |
(cid:66)
inl(e) as · + τ | inr(e) as τ + · | case(e){x .e }{x .e } |
⟨e, e⟩ | projl(e) | projr(e) |
x | let x (cid:66) e in e | λ(x : τ).e | e(e) |
ΛX .e | e[τ] | ⟨∗τ , e⟩ as ∃X .τ | let ⟨∗X, x⟩ (cid:66) e in e |
retA(e) | x ← e ; e | e ≼ e | p
val (cid:70) tt |
inl(v) as · + τ | inr(v) as τ + · |
⟨v, v⟩ |
λ(x : τ).e |
ΛX .e | ⟨∗τ , v⟩ as ∃X .τ |
retA(v) | p ≼ p
NetKAT Programs
type variables
principles
term variables
unit
sums
products
variables, let and functions
existential quantification
unit
sums
products
existential quantification
program equivalence
type environment
type scope
tenv
scope (cid:66)
(cid:66) var ⇀ type
℘(tvar)
Sum
S ⊢ τ1
S ⊢ τ2
S ⊢ τ1 + τ2
Prod
S ⊢ τ1
S ⊢ τ2
S ⊢ τ1 × τ2
Figure 10: System FSays Syntax
Fun
S ⊢ τ1
S ⊢ τ2
S ⊢ τ1 → τ2
Equiv
S ⊢ p ≼ p′
TVar
X ∈ S
S ⊢ X
Forall
S ∪ {X } ⊢ τ
S ⊢ ∀X .τ
S ⊢ τ
Scope Well-formedness
Says
Exists
S ∪ {X } ⊢ τ
S ⊢ ∃X .τ
S ⊢ τ
S ⊢ A Says τ
Type Well-formedness
S, Γ ⊢ e : τ
TT
S, Γ ⊢ tt : unit
Inl
S ⊢ τ2
S, Γ ⊢ e : τ1
S, Γ ⊢ inl(e) as · + τ2 : τ1 + τ2
Case
S, Γ ⊢ e1 : τ1 + τ2
S, Γ[x (cid:55)→ τ1] ⊢ e2 : τ
S, Γ[y (cid:55)→ τ2] ⊢ e3 : τ
S, Γ ⊢ case(e1){x .e2}{y .e3} : τ
Inr
S ⊢ τ1
S, Γ ⊢ e : τ2
S, Γ ⊢ inr(e) as τ1 + · : τ1 + τ2
Projl
S, Γ ⊢ e : τ1 × τ2
S, Γ ⊢ projl(e) : τ1
S, Γ ⊢ e2 : τ2
S, Γ ⊢ ⟨e1, e2⟩ : τ1 × τ2
Pair
S, Γ ⊢ e1 : τ1
Projr
S, Γ ⊢ e : τ1 × τ2
S, Γ ⊢ projr(e) : τ2
Var
Γ(x) = τ
S, Γ ⊢ x : τ
Let
S, Γ ⊢ e1 : τ1
S, Γ[x (cid:55)→ τ1] ⊢ e2 : τ2
S, Γ ⊢ let x (cid:66) e1 in e2 : τ2
Apply
S, Γ ⊢ e1 : τ1 → τ2
S, Γ ⊢ e2 : τ1
S, Γ ⊢ e1(e2) : τ2
TypeLambda
S ∪ {X }, Γ ⊢ e : τ
S, Γ ⊢ ΛX .e : ∀X .τ
TypeApply
S ⊢ τ ′
S, Γ ⊢ e : ∀X .τ
S, Γ ⊢ e[τ ′] : [τ ′/X]τ
Lambda
S ⊢ τ1
S, Γ[x (cid:55)→ τ1] ⊢ e : τ2
S, Γ ⊢ λ(x : τ1).e : τ1 → τ2
Pack
S, Γ ⊢ e : [τ ′/X]τ
S, Γ ⊢ ⟨∗τ ′
, e⟩ as ∃X .τ : ∃X .τ
Unpack
S \ {X } ⊢ τ2
S, Γ ⊢ e1 : ∃X .τ1
S, Γ ⊢ let ⟨∗X, x⟩ (cid:66) e1 in e2 : τ2
S ∪ {X }, Γ[x (cid:55)→ τ1] ⊢ e2 : τ2
Bind
S, Γ ⊢ e1 : A Says τ1
S, Γ[x (cid:55)→ τ1] ⊢ e2 : A Says τ2
S, Γ ⊢ x ← e1 ; e2 : A Says τ2
Ret
S, Γ ⊢ e : τ
S, Γ ⊢ retA(e) : A Says τ
Contains
q ≡ p + q
S, Γ ⊢ p ≼ q : p ≼ q
Figure 11: System FSays Type Derivation Rules.