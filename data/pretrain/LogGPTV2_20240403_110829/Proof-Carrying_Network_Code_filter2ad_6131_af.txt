### CCS '19, November 11–15, 2019, London, United Kingdom

#### References
1. **Anderson, C.J., Foster, N., Guha, A., Jeannin, J.-B., Kozen, D., Schlesinger, C., and Walker, D. (2014).** *NetKAT: Semantic Foundations for Networks.* In *ACM Symposium on Principles of Programming Languages (POPL)*.
2. **Appel, A.W. and Felten, E.W. (1999).** *Proof-carrying Authentication.* In *ACM Conference on Computer and Communications Security (CCS)*. 52–62. [DOI: 10.1145/319709.319718](https://doi.org/10.1145/319709.319718)
3. **Bauer, L. (2003).** *Access Control for the Web via Proof Carrying Authorization.*
4. **Cao, Q., Thummala, V., Chase, J.S., Yao, Y., and Xie, B. (2017).** *Certificate Linking and Caching for Logical Trust.* CoRR abs/1701.06562 (2017). [arXiv: 1701.06562](http://arxiv.org/abs/1701.06562)
5. **Chapin, P., Skalka, C., and Wang, X.S. (2008).** *Authorization in Trust Management: Features and Foundations.* Comput. Surveys 40, 3 (2008), 1–48.
6. **CloudFlare (2019).** *Cloudflare.* [URL: https://www.cloudflare.com/](https://www.cloudflare.com/)
7. **Crawford, H., Renaud, K., and Storer, T. (2013).** *A Framework for Continuous, Transparent Mobile Device Authentication.* Elsevier Computers & Security 39 (2013), 127–136.
8. **Fitbit (2019).** *Fitbit Charge 3.* [URL: https://www.fitbit.com/home](https://www.fitbit.com/home)
9. **Foster, N., Harrison, R., Freedman, M.J., Monsanto, C., Rexford, J., Story, A., and Walker, D. (2011).** *Frenetic: A Network Programming Language.* In *ACM International Conference on Functional Programming (ICFP).* 279–291.
10. **Foster, N., Kozen, D., Milano, M., Silva, A., and Thompson, L. (2015).** *A Coalgebraic Decision Procedure for NetKAT.* In *ACM Symposium on Principles of Programming Languages (POPL).* 343–355. [DOI: 10.1145/2676726.2677011](https://doi.org/10.1145/2676726.2677011)
11. **Raspberry Pi (2019).** *Raspberry Pi 3 Model B+.* [URL: https://www.raspberrypi.org/](https://www.raspberrypi.org/)
12. **Garg, D. (2007).** *An Introduction to Proof-Carrying Authorization.* Course notes for CMU 18-739: Foundations of Security and Privacy. [URL: https://people.mpi-sws.org/~dg/papers/intro-pca.pdf](https://people.mpi-sws.org/~dg/papers/intro-pca.pdf)
13. **Garg, D. and Abadi, M. (2008).** *A Modal Deconstruction of Access Control Logics.* In *Proceedings of the Theory and Practice of Software, 11th International Conference on Foundations of Software Science and Computational Structures (FOSSACS’08/ETAPS’08).* Springer-Verlag, Berlin, Heidelberg, 216–230. [DOI: 10.1007/978-3-540-78499-9_17](http://dl.acm.org/citation.cfm?id=1792803.1792819)
14. **Garg, D. and Pfenning, F. (2012).** *Stateful Authorization Logic—Proof Theory and a Case Study.* Journal of Computer Security 20, 4 (July 2012), 353–391. [DOI: 10.3233/JCS-2012-0447](http://dl.acm.org/citation.cfm?id=2590602.2590605)
15. **Gupta, A., Feamster, N., and Vanbever, L. (2016).** *Authorizing Network Control at Software Defined Internet Exchange Points.* In *Proceedings of the Symposium on SDN Research (SOSR ’16).* ACM, New York, NY, USA, Article 16, 6 pages. [DOI: 10.1145/2890955.2890956](https://doi.org/10.1145/2890955.2890956)
16. **Hirsch, A.K. and Clarkson, M.R. (2013).** *Belief Semantics of Authorization Logic.* In *ACM Conference on Computer and Communications Security (CCS).* 561–572. [DOI: 10.1145/2508859.2516667](https://doi.org/10.1145/2508859.2516667)
17. **iHealth (2019).** *iHealth.* [URL: https://ihealthlabs.com/](https://ihealthlabs.com/)
18. **INRIA (2019).** *OCaml.* [URL: https://ocaml.org/](https://ocaml.org/)
19. **Kazemian, P., Varghese, G., and McKeown, N. (2012).** *Header Space Analysis: Static Checking for Networks.* In *USENIX Symposium on Network Systems Design and Implementation (NSDI).*
20. **Khurshid, A., Zou, X., Zhou, W., Caesar, M., and Godfrey, P.B. (2013).** *VeriFlow: Verifying Network-Wide Invariants in Real Time.* In *USENIX Symposium on Network Systems Design and Implementation (NSDI).*
21. **Kozen, D. (1997).** *Kleene Algebra with Tests.* Transactions on Programming Languages and Systems 19, 3 (May 1997), 427–443.
22. **Kreutz, D., Ramos, F.M.V., and Verissimo, P. (2013).** *Towards Secure and Dependable Software-defined Networks.* In *ACM SIGCOMM Workshop on Hot Topics in Software Defined Networking (HotSDN).* 55–60. [DOI: 10.1145/2491185.2491199](https://doi.org/10.1145/2491185.2491199)
23. **Mihai, D., Martucci, J., and Kohler, K. (2004).** *System and Method for Medical Device Authentication.* US Patent App. 10/748,762.
24. **Miura, T., Ono, T., Suzuki, N., and Miyata, K. (2010).** *Device Authentication System.* US Patent 7,681,033.
25. **Monsanto, C., Reich, J., Foster, N., Rexford, J., and Walker, D. (2013).** *Composing Software Defined Networks.* In *USENIX Symposium on Networked Systems Design and Implementation (NSDI), Lombard, IL.*
26. **Necula, G.C. (1997).** *Proof-carrying Code.* In *ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages (POPL).* 106–119. [DOI: 10.1145/263699.263712](https://doi.org/10.1145/263699.263712)
27. **Pfaff, B., Pettit, J., Koponen, T., Jackson, E.J., Zhou, A., Rajahalme, J., Gross, J., Wang, A., Stringer, J., Shelar, P., Amidon, K., and Casado, M. (2015).** *The Design and Implementation of Open vSwitch.* In *USENIX Symposium on Networked Systems Design and Implementation (NSDI).* 117–130.
28. **Pfenning, F. and Davies, R. (2001).** *A Judgmental Reconstruction of Modal Logic.* Mathematical. Structures in Comp. Sci. 11, 4 (Aug. 2001), 511–540. [DOI: 10.1017/S0960129501003322](https://doi.org/10.1017/S0960129501003322)
29. **Porras, P., Shin, S., Yegneswaran, V., Fong, M., Tyson, M., and Gu, G. (2012).** *A Security Enforcement Kernel for OpenFlow Networks.* In *ACM SIGCOMM Workshop on Hot Topics in Software Defined Networks (HotSDN).* 121–126. [DOI: 10.1145/2342441.2342466](https://doi.org/10.1145/2342441.2342466)
30. **Qiu, Y. and Ma, M. (2016).** *A Mutual Authentication and Key Establishment Scheme for M2M Communication in 6LoWPAN Networks.* IEEE Transactions on Industrial Informatics 12, 6 (2016), 2074–2085.
31. **Santoso, F.K. and Vun, N.C.H. (2015).** *Securing IoT for Smart Home System.* In *IEEE International Symposium on Consumer Electronics (ISCE).* 1–2.
32. **Schneider, F.B., Walsh, K., and Sirer, E.G. (2011).** *Nexus Authorization Logic (NAL): Design Rationale and Applications.* ACM Trans. Inf. Syst. Secur. 14, 1, Article 8 (June 2011), 28 pages. [DOI: 10.1145/1952982.1952990](https://doi.org/10.1145/1952982.1952990)
33. **Smith, B. (2019).** *Ring Cryptography API for Rust.* [GitHub: briansmith/ring](https://github.com/briansmith/ring)
34. **Smolka, S., Eliopoulos, S., Foster, N., and Guha, A. (2015).** *A Fast Compiler for NetKAT.* In *ACM International Conference on Functional Programming (ICFP).* 328–341. [DOI: 10.1145/2858949.2784761](https://doi.org/10.1145/2858949.2784761)
35. **Statman, R. (1979).** *Intuitionistic Propositional Logic is Polynomial-Space Complete.* Theoretical Computer Science 9, 1 (1979), 67–72. [DOI: 10.1016/0304-3975(79)90006-9](https://doi.org/10.1016/0304-3975(79)90006-9)
36. **Mininet Team (2019).** *Mininet.* [URL: http://mininet.org/](http://mininet.org/)
37. **Withings (2019).** *Withings BPM Core.* [URL: https://www.withings.com/](https://www.withings.com/)

### Appendix: Definition of System FSays

**Section 3** provided a summary of System FSays. This appendix offers a more comprehensive definition.

#### Syntax of System FSays

The syntax of System FSays is detailed in Figure 10. The language extends System F with a `Says` monad to represent the `Says` modality in NALlight, along with other features to represent NALlight connectives. Types \( \tau \) in System FSays closely correspond to NALlight formulas \( F \). The System F fragment of System FSays is sufficient to represent implication and higher-order quantification as in NALlight. The addition of sum (+) and product (×) types enables the representation of disjunction and conjunction. The `Says` monad is implemented using the `return` and `bind` style. Existential quantification is realized using standard `pack` and `unpack` terms. The predicate `reconfig(p)` asserts the intent to install configuration program \( p \), while \( p \preceq q \) asserts semantic containment of \( p \) in \( q \). The language could be endowed with a type-preserving reduction semantics, but this is left as future work.

#### Type Derivation Rules for System FSays

The type derivation rules for System FSays are presented in Figure 11. There are two main judgment forms:
- **Well-formedness**: \( S \vdash \tau \), where \( S \) is a set of variables assumed to be in scope, and \( \tau \) must have no free variables outside of \( S \).
- **Typing judgments**: \( S, \Gamma \vdash e : \tau \), where \( \Gamma \) is a free variable typing environment.

These rules are fairly standard and include System F-style polymorphism, existential quantification for `pack` and `unpack`, and monadic typing rules for `return` and `bind`. Notably, the `Equiv` rule is predicated on the NetKAT equivalence \( p \equiv q \).

#### Figures

**Figure 10: System FSays Syntax**

| Category | Syntax |
|----------|--------|
| Unit     | \( S \vdash \text{unit} \) |
| ...      | ...    |
| Prog     | \( \text{prog} \) |
| ...      | ...    |
| Type     | \( \text{type} \mid \text{unit} \mid \tau + \tau \mid \tau \times \tau \mid \tau \to \tau \mid X \mid \forall X . \tau \mid \exists X . \tau \mid \tau \, \text{Says} \, \tau \mid \text{install}(\tau) \mid \tau \preceq \tau \mid p \mid A \) |
| Var      | \( \text{var} \) |
| ...      | ...    |
| Exp      | \( \text{exp} \mid \text{tt} \mid \text{inl}(e) \, \text{as} \, \cdot + \tau \mid \text{inr}(e) \, \text{as} \, \tau + \cdot \mid \text{case}(e)\{\text{x}.e\}\{\text{y}.e\} \mid \langle e, e \rangle \mid \text{projl}(e) \mid \text{projr}(e) \mid x \mid \text{let} \, x = e \, \text{in} \, e \mid \lambda(x : \tau).e \mid e(e) \mid \Lambda X . e \mid e[\tau] \mid \langle \ast \tau, e \rangle \, \text{as} \, \exists X . \tau \mid \text{let} \, \langle \ast X, x \rangle = e \, \text{in} \, e \mid \text{ret}_A(e) \mid x \leftarrow e ; e \mid e \preceq e \mid p \) |
| Val      | \( \text{val} \mid \text{tt} \mid \text{inl}(v) \, \text{as} \, \cdot + \tau \mid \text{inr}(v) \, \text{as} \, \tau + \cdot \mid \langle v, v \rangle \mid \lambda(x : \tau).e \mid \Lambda X . e \mid \langle \ast \tau, v \rangle \, \text{as} \, \exists X . \tau \mid \text{ret}_A(v) \mid p \preceq p \) |
| ...      | ...    |

**Figure 11: System FSays Type Derivation Rules**

| Rule Name | Conditions | Conclusion |
|-----------|------------|------------|
| TT        | \( S, \Gamma \vdash \text{tt} : \text{unit} \) |
| Inl       | \( S \vdash \tau_2 \) <br> \( S, \Gamma \vdash e : \tau_1 \) | \( S, \Gamma \vdash \text{inl}(e) \, \text{as} \, \cdot + \tau_2 : \tau_1 + \tau_2 \) |
| Case      | \( S, \Gamma \vdash e_1 : \tau_1 + \tau_2 \) <br> \( S, \Gamma[x \mapsto \tau_1] \vdash e_2 : \tau \) <br> \( S, \Gamma[y \mapsto \tau_2] \vdash e_3 : \tau \) | \( S, \Gamma \vdash \text{case}(e_1)\{\text{x}.e_2\}\{\text{y}.e_3\} : \tau \) |
| Inr       | \( S \vdash \tau_1 \) <br> \( S, \Gamma \vdash e : \tau_2 \) | \( S, \Gamma \vdash \text{inr}(e) \, \text{as} \, \tau_1 + \cdot : \tau_1 + \tau_2 \) |
| Projl     | \( S, \Gamma \vdash e : \tau_1 \times \tau_2 \) | \( S, \Gamma \vdash \text{projl}(e) : \tau_1 \) |
| Pair      | \( S, \Gamma \vdash e_1 : \tau_1 \) <br> \( S, \Gamma \vdash e_2 : \tau_2 \) | \( S, \Gamma \vdash \langle e_1, e_2 \rangle : \tau_1 \times \tau_2 \) |
| Projr     | \( S, \Gamma \vdash e : \tau_1 \times \tau_2 \) | \( S, \Gamma \vdash \text{projr}(e) : \tau_2 \) |
| Var       | \( \Gamma(x) = \tau \) | \( S, \Gamma \vdash x : \tau \) |
| Let       | \( S, \Gamma \vdash e_1 : \tau_1 \) <br> \( S, \Gamma[x \mapsto \tau_1] \vdash e_2 : \tau_2 \) | \( S, \Gamma \vdash \text{let} \, x = e_1 \, \text{in} \, e_2 : \tau_2 \) |
| Apply     | \( S, \Gamma \vdash e_1 : \tau_1 \to \tau_2 \) <br> \( S, \Gamma \vdash e_2 : \tau_1 \) | \( S, \Gamma \vdash e_1(e_2) : \tau_2 \) |
| TypeLambda| \( S \cup \{X\}, \Gamma \vdash e : \tau \) | \( S, \Gamma \vdash \Lambda X . e : \forall X . \tau \) |
| TypeApply | \( S \vdash \tau' \) <br> \( S, \Gamma \vdash e : \forall X . \tau \) | \( S, \Gamma \vdash e[\tau'] : [\tau'/X]\tau \) |
| Lambda    | \( S \vdash \tau_1 \) <br> \( S, \Gamma[x \mapsto \tau_1] \vdash e : \tau_2 \) | \( S, \Gamma \vdash \lambda(x : \tau_1).e : \tau_1 \to \tau_2 \) |
| Pack      | \( S, \Gamma \vdash e : [\tau'/X]\tau \) | \( S, \Gamma \vdash \langle \ast \tau', e \rangle \, \text{as} \, \exists X . \tau : \exists X . \tau \) |
| Unpack    | \( S \setminus \{X\} \vdash \tau_2 \) <br> \( S, \Gamma \vdash e_1 : \exists X . \tau_1 \) <br> \( S \cup \{X\}, \Gamma[x \mapsto \tau_1] \vdash e_2 : \tau_2 \) | \( S, \Gamma \vdash \text{let} \, \langle \ast X, x \rangle = e_1 \, \text{in} \, e_2 : \tau_2 \) |
| Bind      | \( S, \Gamma \vdash e_1 : A \, \text{Says} \, \tau_1 \) <br> \( S, \Gamma[x \mapsto \tau_1] \vdash e_2 : A \, \text{Says} \, \tau_2 \) | \( S, \Gamma \vdash x \leftarrow e_1 ; e_2 : A \, \text{Says} \, \tau_2 \) |
| Ret       | \( S, \Gamma \vdash e : \tau \) | \( S, \Gamma \vdash \text{ret}_A(e) : A \, \text{Says} \, \tau \) |
| Contains  | \( q \equiv p + q \) | \( S, \Gamma \vdash p \preceq q : p \preceq q \) |

This structured format ensures clarity and coherence, making the references and the system definition more accessible and professional.