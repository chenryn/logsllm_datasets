ule is verified separately, the verification time per module is
less than 1.5 minutes on average.
An example of an ambiguity in the ACME RFC is that the stan-
dard does not clearly state that the ACME flow must be performed
using the same account, i.e., the server must check whether all
requests sent by the client are signed with the same key within one
flow. While it is obvious that the server must perform this check,
the standard only suggests this quite implicitly. Developers who
just ‚Äúcode down‚Äù the standard might easily miss this check.
As also demonstrated by other real-world protocols, flaws can
be quite subtle and be rooted in both logical protocol flaws as well
as low-level mechanisms and ambiguities, such as state manage-
ment [54], control flow decisions [9], insufficient checks [29], and
incomplete or ambiguous data structures [30, 51, 52].
For critical protocols, such as ACME, which affect the security
of the whole Internet infrastructure, it is therefore important to
carry out a very detailed analysis by rigorously following the spec-
ification and along the way also clarify potential ambiguities. This
results in strong and meaningful security guarantees of the stan-
dard, and our modeling/implementation artifact can serve as a
reference implementation alongside the standard itself to guide
programmers.
6 DY‚òÖ IMPLEMENTATION OF ACME
We modeled ACME clients and servers as F‚òÖ programs built on top
of DY‚òÖ‚Äôs labeled security API. Our model supports an unbounded
number of principals, where each principal can own any number
of domains, and can play the role of a client or server (or both).
Our model covers most of the ACME standard, including all steps
specified by ACME to order, verify, issue, and retrieve a certificate,
as well as a detailed specification of all relevant data structures.
Moreover, our model also covers semantics of underlying protocols
such as HTTP requests and responses, including HTTP headers
and ACME‚Äôs special construction of POST-as-GET requests. This
results in a comprehensive model comprising about 5,500 lines of
functional F‚òÖ code alone, excluding the DY‚òÖ framework, comments,
white space, and lemmas and proofs for the security properties
(see Table 1). To further demonstrate our coverage, we refer to
Appendix C where we map sections of the ACME specification [5]
to F‚òÖ modules in our model.
Modeling Decisions. To ease analysis, our model leaves out cer-
tain security mechanisms required by ACME, and by this, safely
over-approximates them. That is, we omit the usage of TLS, i.e.,
Session 10B: Crypto and Protocol Security CCS ‚Äô21, November 15‚Äì19, 2021, Virtual Event, Republic of Korea2608ACME messages are exchanged unprotected (e.g., no confidentiality
or integrity) on the network. The only exception is that the verifi-
cation response (Step 16 of Figure 2) is sent over an authenticated
channel, matching the key assumption of the ACME standard, as ex-
plained in Section 4.1. Further, our modeled server does not enforce
ACME‚Äôs replay protection mechanism (DoS protection), which, as
shown by our analysis, is not necessary for ACME‚Äôs central secu-
rity properties. Moreover, in the case of verification mismatches,
our implementation does not output a terminating error message
but instead aborts only the local execution of the respective pro-
tocol step without updating the state machine, allowing the same
protocol flow to be continued, and hence, leaving the adversary fur-
ther options. Following the same reasoning, we also do not model
expiration of ACME orders, authorizations, and challenges.
6.1 Application-specific Data Structures
In our model, we closely follow the specification, including real-
world message formats. This is security-critical. For example, we
capture that the ACME server points the client to URLs for subse-
quent steps, which can potentially lead the client to interact with an
unintended ACME server in the same protocol flow. Modeling these
detailed message flows directly in terms of DY‚òÖ bytes would be
too cumbersome. Instead, we define ACME-specific high-level data
structures as F‚òÖ record types and implement functions to convert
these high-level data structures to bytes and back. Using F‚òÖ‚Äôs theo-
rem prover, we prove that these conversion functions are inverses
of each other (see Appendix A for a full example). This approach
provides multiple benefits over a bytes-only modeling. First, by rely-
ing on the F‚òÖ type checker to verify initialization of all record fields
with values of the correct type, we avoid all modeling errors related
to inconsistent message serialization and parsing. Second, as data
structures can be modeled very close to their specification, writing
and (manually) comparing the model against the standard becomes
much easier. We believe this modeling approach is generally useful,
beyond ACME, for protocols with complex messages.
As an example, we show our high-level data structure for an
ACME order and compare it with its specification in the standard:
type acme_order = {
status: option // optional because new order messages (7.4 of [5]) do not have a status
(s:acme_status{s=Pending || s=Ready || s=Processing || s=Valid || s=Invalid});
identifiers: doms:(Seq.seq domain){Seq.length doms > 0};
authorizations: option (Seq.seq url);
finalize: option url; // Optional for the same reason as status
certificate: option url}
This defines an F‚òÖ record type acme_order with five fields. E.g.,
the field identifiers holds a value of type Seq.seq domain, i.e., an
unbounded sequence of domains, with an additional refinement stat-
ing that this sequence cannot be empty. (Identifiers are shortened
for presentation, see module ACME.Data in [10] for full details.)
Comparing this type definition with the following excerpt from
Section 7.1.3 of the ACME specification [5], it is easy to see that
our model closely resembles the specification:
status (required, string): [...] Possible values are "pending",
"ready", "processing", "valid", and "invalid". [...]
identifiers (required, array of object): An array of identifier
objects that the order pertains to. [...]
authorizations (required, array of string): [...] Each entry is
a URL from which an authorization can be fetched [...].
finalize (required, string): A URL that a CSR must be POSTed to
once all of the order's authorizations are satisfied [...]
certificate (optional, string): A URL for the certificate that
has been issued in response to this order.
6.2 ACME Client & Server APIs
The core of our ACME model is a set of APIs implementing the
ACME protocol steps on both client and server side. These functions
use the DYL effect provided by DY‚òÖ, which allows us to make use
of DY‚òÖ‚Äôs labeled application API, e.g., to send and receive messages
(recall that DYL implicitly carries the global execution trace and
requires users to retain the valid_trace invariant). We here present
one such function to illustrate our modeling, namely, the ACME
server endpoint to place a new order. It has the following type:
val acme_server_new_order_nw:
acme_server_principal:principal ‚Üí // identity of the server
msg_idx:nat ‚Üí // trace index of send(http request)
DYL nat // trace index of send(http response)
(requires (ùúÜ t0 ‚Üí‚ä§)) // No precondition (except for valid_trace)
(ensures (ùúÜ t0 result t1 ‚Üí‚ä§)) // No post condition (except for valid_trace)
This function takes the name of a server principal and an index
(msg_idx) in the global trace at which it expects to find a message
carrying an HTTP request containing an ACME new order message
(as specified in Section 7.4 of [5]), i.e., an instance of the acme_order
type presented above. The function either returns an error (e.g. if
the input message is malformed) or it adds an HTTP response to
the trace and returns an index to this message in the trace.
The function acme_server_new_order_nw is implemented as
shown in Figure 3. Note that this code is roughly what one would
expect from a ‚Äúregular‚Äù ACME implementation in a functional pro-
gramming language, e.g., the received message undergoes several
parsing steps. The code precisely models authorization objects as
specified in [5]: an acme_order does not contain the authorization
objects themselves, but URLs from which the ACME client has
to retrieve the actual authorization objects, a distinction that is
security-critical for ACME.
6.3 Functional Tests and Attacks
To test the functional correctness of our ACME model, we use
DY‚òÖ‚Äôs symbolic debugging capabilities (see Section 2). Of course, as
outlined above, our ACME model itself comprises a set of functions
representing protocol steps. Thus, to actually run the protocol,
we need to implement an entry point which calls these protocol
step functions. We implement several such scheduling functions,
modeling different runs of ACME, allowing us to: 1) Empirically
verify that our models for ACME clients and servers are functionally
correct in the sense that they can finish the protocol with each
other. 2) Print and inspect the resulting symbolic traces produced
by these protocol runs. For example, we have encoded a (benign)
run similar to Figure 2 and checked whether the client indeed stores
the correct certificate in the end. 3) Check whether protocol steps
fail as expected with a faulty/malicious scheduler, i.e., an attacker.
For example, we implement a run where a malicious ACME client
orders a certificate for a set of domains, one of which it does not
own, and we check that the protocol cannot continue (as expected)
when the client is asked to prove control over that domain.
Of course, these tests do not prove security (see Section 7), but
they serve to increase confidence in the functional correctness of
Session 10B: Crypto and Protocol Security CCS ‚Äô21, November 15‚Äì19, 2021, Virtual Event, Republic of Korea2609// Note: All parse functions throw an error if parsing fails
let acme_server_new_order_nw server msg_idx =
// receive_i ‚àà DY‚òÖ, ‚Äúsender of message‚Äù is untrusted information
let (sender_of_message, message) = receive_i msg_idx server in
let http_req = parse_http_request message in
if (http_request_header_contains_domain_of_server http_req server) then
let http_resp = acme_server_new_order_http server http_req in // See below
let http_resp_bytes = serialize_http_response http_resp in
send server sender_of_message http_resp_bytes
error "Request‚ê£was‚ê£sent‚ê£to‚ê£wrong‚ê£server"
else
else
let acme_server_new_order_http server http_request =
let jws_request = parse_jws_acme_request http_request.req_body in
if not(dfst (verify_jws_acme_request http_request server jws_request)) then
error "Invalid‚ê£signature‚ê£or‚ê£invalid‚ê£request‚ê£JWS"
let order_object = parse_acme_order jws_request.payload in
let ((UserAccount _acc_pub_key acc_url), account_session_id) =
retrieve_account_session_for_kid server jws_request.key_id in
let server_domain = get_dom_from_host_header http_request.req_headers in
let (updated_order, authzs) =
acme_server_new_order_helper order_object server_domain in // See below
let new_order_session_idx = store_order_object_in_server_state
server updated_order account_session_id acc_url acc_pub_key in
store_authzs_to_server_state server authzs 0 new_order_session_idx;
// Return an HTTP response containing the updated order. req_id allows relating this
// response to the corresponding request (modeling the TCP connection beneath HTTP).
new_order_create_response http_request.req_id updated_order
let acme_server_new_order_helper (order_obj:acme_order) (server_domain:domain)
: DYL ( // Returns a tuple (order, authorizations)
order:acme_order{(order.acme_order_status = Some Pending)} √ó
Seq.seq acme_authorization
) =
// guid_gen ‚àà DY‚òÖ generates a unique, but not necessarily secret value
let finalize_path_nonce = guid_gen () in
let finalize_url = create_finalize_url server_domain finalize_path_nonce in
// create a sequence of authorization objects (Sec. 7.1.4 & 7.4 in ACME specification)
let authzs = create_authorization_objects server_domain order_obj.identifiers 0 in
let authz_urls = extract_urls_from_authzs authzs 0 in
let updated_acme_order = {
status = Some Pending;
identifiers = order_obj.identifiers;
authorizations = Some authz_urls;
finalize = Some finalize_url;
certificate = None
} in
(updated_acme_order, authzs)
Figure 3: Implementation of our ACME server‚Äôs new order
API. For brevity, we omit most annotations for F‚òÖ‚Äôs theorem
prover as well as some helper functions and technicalities.
See module ACME.Server.NewOrder in [10] for full details.
our model. We, for example, found and fixed an error in our server
model which prevented the server from accepting (valid) requests.
We note that finding such errors is much harder in non-executable
symbolic models, especially if the model is as detailed as ours.
In addition, we can also use our test framework to try out at-
tacks based on known implementation flaws. For example, we ex-
tended the server API with a faulty function, resembling the Boulder
flaw [35] (see Section 5), and demonstrated, by writing a new sched-
uler function, that an adversary can indeed exploit this bug to obtain
a certificate for a domain it does not own.
6.4 Modeling Limitations
While our ACME model is quite comprehensive and detailed, there
are some limitations: 1) We focused on the ACME protocol and
thus omitted certification authority aspects, in particular certificate
revocation and account creation ‚Äì we over-approximate the latter
by assuming that an arbitrary number of honest and dishonest
accounts has been initialized. 2) The ACME specification itself only
specifies DNS identifiers, i.e., domains, but allows extensions to
define other identifier types, e.g., email addresses. Our model does
not include that extension point. 3) The ACME specification defines
an optional feature called pre-authorization (see Section 7.4.1 of [5]),
allowing clients to finish an ACME authorization independent of
a concrete order. Since this is an optional feature and even Let‚Äôs
Encrypt does not support it [39], we chose not to model it. 4) As
we do not model TLS (see above), we modeled DNS as a trusted
function mapping domains to principals. Note that this does not
impede the attacker‚Äôs capabilities at all: Due to the lack of TLS,
the attacker can redirect network messages without the receiver
noticing. Finally, of the two (structurally similar) challenge types
defined in the ACME specification, dns-01 and http-01, our client
and server only implement the latter. Note that this does not impede
compliance with the specification as support for either challenge
type is optional.
7 SECURITY PROPERTIES AND PROOF
Our analysis considers several security properties: The central,
most obvious property for certificate issuance is the secure binding
property, which guarantees that an honest ACME server only issues
certificates to the rightful owner of the domains stated in the respec-
tive certificate. This property not only captures the security goals
of ACME (see Section 4.2) but is even stronger, as it holistically
captures the overall issuance process. Moreover, we also state and
prove integrity properties for the entire ACME flow, by which we
go beyond the security goals stated in the specification as well.
We emphasize that our analysis does not consider just the ideal
protocol flow as depicted in Figure 2 but considers an unbounded
number of ACME servers and clients that can perform an un-
bounded number of (interleaved) protocol sessions in parallel. Fur-
thermore, we consider an active network attacker that can (non-
deterministically) intercept, block, and spoof messages, freely sched-
ule the execution of the protocol, and corrupt any principal at any
time (as discussed in Section 2).
7.1 Secure Binding Property
The secure binding property states that if an honest ACME server
issues a certificate for a set of domains where at least one domain
in that set is owned by an honest client, then the private key corre-
sponding to the public key bound in the certificate is unknown to
the adversary. This way, we capture that (as an outcome of every
possible run of ACME) the attacker can never obtain a certificate
that enables it to impersonate someone honests‚Äôs domain. More
formally, we define this property as follows:
Definition 1. Let ùë° be a global trace of the DY‚òÖ model of ACME,
ùë† be an honest principal (an ACME server) in ùë°, ùê∑ be a set of domains,
ùëò be some private key, and ùëêùëíùëüùë° some certificate issued by ùë† in ùë° for
the set ùê∑ and the public key corresponding to ùëò. We say that ùë° fulfills
ACME‚Äôs secure binding property for ùë†, ùê∑, ùëò, and ùëêùëíùëüùë° if (in ùë°) ùëò is
not derivable by the adversary or all domains ùëë ‚àà ùê∑ are owned by
dishonest principals (the adversary).
Session 10B: Crypto and Protocol Security CCS ‚Äô21, November 15‚Äì19, 2021, Virtual Event, Republic of Korea2610Based on this definition, we state the following theorem:
Theorem 1. For all possible global traces ùë° of the DY‚òÖ model of