1
5.2 Security Analysis
2
τ
appears tj times in ˆX andn′′
Theorem 5.3. The aggregate Γ-signature scheme presented in
Table 2 is secure (in accordance with Definition 3.1) under the NMDL
assumption in the random oracle model.
Proof. According to the security definition of aggregate signature
presented in Section 3, supposing there exists a PPT forger A who
breaks the security of the aggregate Γ-signature with non-negligible
probability, we present another PPT algorithm B who can solve
the NMDL problem also with non-negligible probability. Denote
by (X = xP, x) the public and secret key pair of the target honest
user, where x ← Z∗
q. The algorithm B takes (G, X) as input (where
G is the underlying cyclic group defined in the elliptic curve), runs
A as a subroutine, and works as follows.
Whenever A asks the target user to sign a message m, B an-
swers the signing query by running the Γ-signature simulator S
as described in Corollary 2.1, where the simulation is statistically
indistinguishable from what A gets in reality. Finally, suppose
that A outputs a valid aggregate Γ-signature denoted ( ˆT , ˆA, z),
where ˆT = {(X1, m1),· · · ,(Xn′, mn′)}, ˆA = {A1,· · · , An′}. Assume
that there are n′′ distinct elements ¯X = {Xi1 ,· · · , Xin′′} in ˆX =
j=1 tj = n′.
{X1,· · · , Xn′}, where Xij
For each j, 1 ≤ j ≤ n′′, denote by Ij = {j1,· · · , jtj } the set of
appears in ˆX where 1 ≤ jα ≤ n′ for 1 ≤ α ≤ tj;
indices that Xij
. B outputs { ¯T , ¯A, z}, which are
= Xj1 = · · · = Xjtj
specifically, Xij
specified below:
• ¯T = {(b1, Xi1 , m1),· · · ,(bn′′, Xin′′ , mn′′)}, where for each j,
1 ≤ j ≤ n′′, bj = −1 and mj = mj1|| · · · ||mjkj
• ¯A = {(b′
1, A1, λ)· · · ,(b′
n′, An′, λ)}, where for each i, 1 ≤ i ≤
n′, b′
= 1, and λ represents the empty string.
i
According to the security analysis of Γ-signature in [70], what
seen by A under the run of B is statistically indistinguishable
from what seen in reality. Thus, with also non-negligible proba-
bility, A will output a valid aggregate Γ-signature ( ˆT , ˆA, z) under
the simulation of B. Consequently, B outputs ( ¯T , ¯A, z) with the
same probability. Define H′ : G × ({0, 1}∗)β → Zq as follows:
H′(X , m1,· · · , mβ) = H(X , m1) + · · · + H(X , mβ) mod q for any
β, 1 ≤ β ≤ n′. Assuming H : {0, 1}∗ → Zq is a random oracle, so
is H′. Finally, we show that the output { ¯T , ¯A, z} by B is a correct
solution to the NMDL problem, by the following observations:
• All the tuples in ¯T ¯A are distinct. This is from the facts that:
.
(1) the tuples in ¯T are distinct and mj (cid:44) λ, 1 ≤ j ≤ n′′; (2)
the tuples in ¯A are also distinct with the same empty string
as the third element in each tuple.
• As we assume the aggregate signature ( ˆT , ˆA, z) output by
A is valid, we have that X ∈ ¯X = {Xi1 ,· · · , Xin′′}, and
H′(Xij , mj).
i =1 di Ai −n′′
, where di = H(Ai) and e′
zP =n′
j=1 e′
jXij
=
j
6 APPLICATIONS TO BITCOIN
In this section, we describe a Merkle-Patricia tree (MPT) aided
implementation of our aggregate signature scheme, and specify
its applications to Bitcoin. The goal is to maximize performance
and compatibility with the existing Bitcoin system, with the least
modifications that are inherent in deploying aggregate signatures.
Our modifications involve: txid, unlocking script, locking script,
Merkle tree, block construction, block mining and block verification.
For presentation simplicity, we describe our implementation for a
hard-fork of Bitcoin, in a self-contained manner for ease of reading.
6.1 Inheritances: Keys, Addresses and Network
Bitcoin uses a specific elliptic curve, as defined in a standard called
secp256k1, established by NIST. Our aggregate Γ-signature scheme
also works on the secp256k1 curve. As for new key pair generation,
algorithm KeyGen(1l) is the same as in the existing Bitcoin system.
As for Bitcoin addresses, we inherit the existing design in Bit-
coin. Specifically, this is the process of generating address from
public key through the use of one-way hash algorithms SHA256
and RIPEMD160,
A=RIPEMD160(SHA256(X)),
where X is the public key and A is the Bitcoin address. The above
address is called P2PKH address. There is another type of address
called P2SH address, which is generated by the following equation:
A=RIPEMD160(SHA256(script)).
We also use the Base58 [3] and Base58Check [2, 7] formats for unam-
biguously and compactly encoding Bitcoin data such as addresses,
etc.
We adopt the existing Bitcoin network which is structured as
a peer-to-peer (P2P) network on top of the internet. And the Bit-
coin network refers to the collection of nodes running the Bitcoin
protocol. When a peer receives data, it will broadcast the data to
its neighbouring peers after some necessary verification. With the
usage of P2P network, in a very short period of time, the data such
as transactions and blocks can be efficiently spread all over the
network.
6.2 Transactions
Transactions are the most important part of the Bitcoin system.
Everything else in Bitcoin is designed to ensure that transactions
can be created, propagated on P2P network, validated, and finally
added to the global ledger of transactions (i.e., the blockchain).
The Bitcoin transaction consists of fields such as version, in-
counter, inputs list, out-counter, outputs list and locktime, which is
shown in Table 3.
transaction output (UTXO).
Within the inputs list field of transaction, it consists of
• txid: a pointer to the transaction containing the unspent
• vout: the index number of the UTXO to be spent.
• unlocking script: a script that fulfills the conditions of the
• sequence: the block number where the UTXO is recorded
UTXO locking script.
in the blockchain.
In the Bitcoin system, txid is the double SHA256 hash of the
transaction, including the witness (i.e., the associated signature).
Session 6B: Applied CryptographyAsiaCCS ’19, July 9–12, 2019, Auckland, New Zealand535Description
Transaction version number
Field
version
in-counter Counter of inputs
inputs-list List of transaction inputs
out-counterCounter of outputs
outputs-list List of transaction outputs
locktime
Size
4 bytes
1-9 bytes
variable
1-9 bytes
variable
Earliest time that a transaction is valid 4 bytes
Table 3: Structure of Bitcoin transaction
header. The size of block header is 80-bytes, and its structure is
shown in Table 5.
Description
Block version number
Size
Field
4 bytes
version
hashPrevBlock Hash of the previous block header
32 bytes
hashMerkleRoot Hash of Merkle tree root in the block 32 bytes
4 bytes
timestamp
4 bytes
bits
nonce
4 bytes
Current timestamp as seconds
Current target in compact format
32-bit number
Table 5: Structure of Bitcoin blockheader
Every block in blockchain contains a summary of all the trans-
actions using a Merkle tree. A Merkle tree, also known as a binary
hash tree, is a data structure used for efficiently summarizing and
verifying the integrity of large sets of data. In our modifications,
we build Merkle tree with our modified txid which is the double
SHA256 hash of the transaction without witness.
In the existing Bitcoin system, after validating transactions a
miner will add them to the memory pool or transaction pool where
transactions await until they can be included (mined) into a block.
We adopt Merkle-Patricia tree (MPT) [54] to play the role of memory
pool and to perform duplication check, as the elements in ˆT and
ˆA in our aggregate Γ-signature are required to be distinct. MPT
can provide a cryptographically authenticated data structure that
can be used to store (key, value) pairs, and enjoys a faster speed
both in element searching and in outputting ordered elements. The
algorithm Aдд in our aggregate Γ-signature can be implemented
with MPT as follows.
, where
and MPT ˆT
(resp., MPT ˆT
) is for the set of ˆA (resp., ˆT ).
• Initialize two empty MPT instances MPT ˆA
MPT ˆA
• Traverse the received transactions and do the following. For
every transaction input, extract the public key Xi and the
signature σi = (di , zi) in the unlocking script, and mi that is
the specific part of a transaction defined by SIGHASH flag;
Then, calculate Ai from σi, and search in MPTA, MPTT to
check whether there already exists Ai or (Xi , mi); Finally,
verify (Xi , mi , σi) with our V eri f y algorithm.
• If there already exists Ai or (Xi , mi), or V eri f y algorithm
outputs RE J ECT , drop the current transaction, and loop to
the next transaction.
• Insert Ai and (Xi , mi) to MPTA and MPTT respectively, and
set z := z + zi mod q.
• When all the transactions are traversed, output the ordered
list of Ai’s as ˆA, the ordered list of(Xi , mi) as ˆT , and a number
z ∈ Zq.
Now, we pay attention to P2SH unlocking script multi-signature,
where N public keys are recorded in the script and at least M
of them must provide signatures to unlock the funds. In order
to aggregate the multi-signature, a Bitcoin node should extract
each tuple (Xj , m, σj) from the M provided signatures on the same
message m, and deals with it like a normal transaction input.
After collecting enough transactions, the miner constructs a can-
didate block, with the only witness of aggregate signature ( ˆA, z)
It is inherently impossible to retrieve the txid whenever aggregate
signature is used, where multiple individual signatures are replaced
with the aggregate signature in the block. So, for AS-based im-
plementations, we modify the txid to be the double SHA256 hash
of the transaction without witness. Note that tampering with the
witness data is the source for launching transaction malleability
attacks [20]. Removing it from the hash input in generating txid
also removes the opportunity for transaction malleability attacks.
This can also greatly improve the implementations for many other
protocols, such as payment channels, chained transactions, and
lightning networks.
Unlocking script of P2PKH is in the format of ,
where PubK is a public key and sig is a signature signed by the
private key corresponding to PubK; The unlocking script of P2SH
has a basic format of , mainly for multi-signature.
In our modifications, the sig is generated by the Siдn(X , x, m) of
Γ-signature (where m is part of a transaction defined by SIGHASH
flag), which replaces the existing EC-DSA signature.
Within the outputs list field of transaction, it consists of (1)
value which is an amount of Bitcoin; and (2) locking script which
is a cryptographic puzzle that determines the conditions required to
spend the output. As for operations OP_CHECKSIG and OP_CHECKMULTISIG
among locking script of P2PKH and P2SH, the EC-DSA verifica-
tion procedure is replaced by running V eri f y(X , m, σ = (d, z)) of
Γ-signature.
6.3 Block
A block is a container data structure that collects transactions for
inclusion in the public ledger, the blockchain. The block consists of a
header, containing metadata, followed by a long list of transactions,
which is shown in Table 4.
Description
Field
magic-no
blocksize
blockheader Consists of 6 items
tx-counter Counter of transactions