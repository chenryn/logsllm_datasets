it requires that for every distance d in the desired ND range
R, there should be at least some setting, in which the pro-
tocol is able to conclude that a node is a neighbor (in some,
not all executions); this setting should contain exactly two
nodes at distance d, being neighbors, and both correct. The
“two-nodes setting” requirement clariﬁes why we call this
two-party ND. The ND2 property is the least that can be
required from a usable two-party ND protocol:
indeed, a
protocol not satisfying this property would be unable to con-
clude, for some distance(s) in the ND range, that nodes are
neighbors. This makes the impossibility result in Section 3
more meaningful: impossibility with respect to a weak prop-
erty implies impossibility for any stronger property.
IMPOSSIBILITY FOR T-PROTOCOLS
3.
We show in this section that no time-based protocol can
solve the two-party neighbor discovery problem as speciﬁed
by Deﬁnition 15. We base the proof on the fact, captured in
Lemma 1, that it is impossible for a correct node to distin-
guish between diﬀerent settings based on an T-local view.
The impossibility result in Theorem 1 stems from showing
two settings which are indistinguishable by a correct node,
one in which two nodes are neighbors and one where they
are not. We elaborate on the assumptions and implications
of this result in Section 6.
We emphasize that the non-restricted form of the message
space M encompasses all possible messages including, for
example, time-stamps and any type of cryptography, thus
contributing to the generality of the impossibility result.
Lemma 1. Let P be a T-protocol model, S and S(cid:48) be set-
cor, and θ ∈ ΘS,P and θ(cid:48) ∈ ΘS(cid:48)
tings such that Vcor = V (cid:48)
be traces such that local traces θ|A = θ(cid:48)|A for all A ∈ Vcor.
Then θ(cid:48) is feasible with respect to T-protocol model P.
6
(a) S a
(b) S b
(c) S c
=
S c
and
Figure 2: Settings used in the impossibility result
Settings S a = (cid:104){A, B}, loca, type a, link a(cid:105),
proof.
(cid:104){A, B, C}, locb, type b, link b(cid:105)
S b
=
(cid:104){A, B, C, D}, locc, type c, link c(cid:105).
In all settings, nodes
A and B are correct, nodes C and D are ad-
versarial. The location functions are such that
dist b(A, C) + dist b(B, C) + v∆relay (cid:54) dist a(A, B) (cid:54) R and
dist c(C, D) + v∆relay (cid:54)
dist c(A, C) + dist c(D, B) + v
vadv
dist a(A, B). The state of links does not change over
time and is shown in the ﬁgure. The dashed arrow
in ﬁgure (c) denotes the adversarial channel.
Theorem 1. If ∆relay  end (Receive(A; t1; C, authB(t))))
v ) ∧
Condition 1 ensures that a correct node only broadcasts bea-
con messages that are authenticated by itself and that have
the beacon-time set to the start of the beacon sending time.
Recall that correct nodes have synchronized clocks, other-
wise they cannot be considered correct. Condition 2 ensures
that a correct A accepts B as a neighbor only after it receives
and deems fresh a beacon generated by B.
Adversary Model. Towards proving that P T solves the ND
problem, we need to develop a stronger than A∆relay adver-
sary model. This is necessary, as proving that a protocol
is secure against a weak adversary would be of little value.
The new adversary model, AT
∆relay , allows for not only mes-
sage relay but also for generation and transmission of any
message, as long as the employed cryptosystem is not bro-
ken (this approach is compliant with the classical Dolev-Yao
model [6]).
Definition 17. A trace θ ∈ ΘS,PT is feasible with respect
to an adversary model AT
∆relay if:
1. ∀Bcast(A; t; m) ∈ θ, A /∈ Vadv
2. ∀A ∈ Vadv, ∀Dcast(A; t1; α, β, authB(t)) ∈ θ,
(B ∈ Vadv) ∨ (∃C ∈ Vadv, ∃δ (cid:62) ∆relay + dist(C,A)
∃D ∈ V, Receive(C; t1 − δ; D, authB(t)) ∈ θ)
vadv
,
Condition 1 simpliﬁes the presentation mandating that ad-
versarial nodes do not use the Bcast primitive. Nonetheless,
3For clarity and brevity, we deﬁne this “from scratch,”
rather than specifying an T-protocol model according to
Deﬁnition 9 and relying on Deﬁnition 10 for feasibility.
7
this is not a limitation because Bcast(m) is equivalent to
Dcast(0, 2π, m), by which we mean that it triggers exactly
the same Receive(m) events. Condition 2 ensures that an
adversarial node is allowed to send any message as long as
it is authenticated by an adversarial node (itself or other).
This implies that adversarial nodes can share cryptographic
keys or any material used for authentication. Furthermore,
Condition 2 reﬂects that the adversary cannot forge authen-
ticated messages: it ensures that a message sent by an ad-
versarial node, and authenticated by a correct node must
be a relayed one. In other words, some (possibly the same)
adversarial node must have received this message earlier,
at least ∆relay plus the propagation time between the two
nodes (over the adversarial channel).
Theorem 3. If ∆relay (cid:62) R
v then P T satisﬁes neighbor
∆relay .
discovery for the adversary model AT
5. TL-PROTOCOL SOLVING ND
Time- and location-based protocols, compared to the T-
protocol class, augment nodes with location awareness. Be-
cause nodes are more powerful, we can show that if v = vadv,
an TL-protocol we denote as P GT solves ND regardless of