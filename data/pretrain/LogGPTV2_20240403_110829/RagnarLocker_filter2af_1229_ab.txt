    dbsnmp
    synctime
    agntsvc
    isqlpussvc
    xfssvccon
    mydesktopqos
    ocomm
    dbeng50
    sqbcoreservice
    excel
    infopath
    msaccess
    mspub
    onenote
    outlook
    powerpnt
    steam
    thebat
    thunderbird
    visio
    wordpad
    winword
    EduLink2SIMS
    bengine
    benetns
    beserver
    pvlsvr
    beremote
    VxLockdownServer
    postgres
    fdhost
    WSSADMIN
    wsstracing
    OWSTIMER
    dfssvc.exe
    swc_service.exe
    sophos
    SAVAdminService
    SavService.exe
请注意，进程列表可能会取决于样本的不同而有所不同。
在制作快照后，它将会使用`Process32FirstW`和`Process32NextW`函数枚举所有进程，并为找到的每个进程调用`WideCharToMultyByte`函数，以获取将Unicode返回的进程名称转换为ASCII所需的大小。随后，将会为不同名称的进程保留内存，并调用相同的函数进行字符串转换。
获取所有系统进程：
如果恶意软件在使用`StrStrIA`函数进行比较之后，检测到了某些黑名单中的进程，则会使用`OpenProcess`函数打开该进程，并使用`TerminateProcess`函数终止该进程，返回代码为0x29A。
打开并终止黑名单中的进程：
该恶意软件将使用字符串中的一部分来检查黑名单中的所有进程，并非是使用确切的名称。由于不使用扩展名，将会带来更大的迷惑性，但也同时可能导致某些使用该字符串的进程被意外关闭的风险。
此后，恶意软件将检查操作系统是否为64位，使用的是`GetNativeSystemInfo`函数，如果值为9，则表示使用了64位系统。
如果操作系统是64位，则将使用`LoadLibraryW`和`GetProcAddress`获得函数`Woe64EnableWow64FsRedirection`，以删除默认情况下在64位操作系统中出现的重定向。该调用以动态方式完成，但恶意软件不会检查是否已经成功检索到该函数。通常情况下是没问题的，但是并不能100%确定，并且可能会发生调用空指针的崩溃情况。
检查操作系统，并在需要时禁用重定向：
此后，恶意软件将使用嵌入到代码中的字符串`wmic.exe shadowcopy
delete`，并使用函数`CreateProcessW`调用它。在调用之后，将会使用函数`WaitForSingleObject`等待一个没有上限的时间，以便`wmic.exe`进程在各种卷大小、卷数量、主机可用资源的场景中都可以执行完成。
当然，恶意软件还将使用经典的`vssadmin`程序通过命令`vssadmin delete shadows /all
/quiet`和`CreateProcessW`函数来删除卷影。之后，它将再次使用`WaitForSingleObject`等待新进程的结束。
在完成之后，恶意软件将再次检查操作系统是否为64位，如果是，则将使用`LoadLibraryW`和`GetProcAddress`获取函数`Wo64EnableWow64FsRedirection`，像以前一样使用重定向来离开系统。同样，恶意软件不会检查函数是否成功解析，而是直接以动态方式进行调用。
销毁卷影并重新启用重定向：
尽管再次破坏卷影似乎是一个错误，但实际并非如此，因为RagnarLocker勒索软件也同样支持Windows
XP，而XP操作系统中不存在WMIC类，所以就需要使用存在于Windows中的旧版本程序`vssadmin`来同时兼容新旧操作系统。
该恶意软件继续解密以Base64编码的一个PEM块，并在内存中存储了赎金提示信息。
解密后的PEM块和赎金提示信息：
下面展示了赎金提示信息，其中已经删除了敏感信息。
赎金提示信息示例：
在完成上述两项任务之后，恶意软件会将Base64编码后的PEM块解码为一个对象，获得一个密钥，该密钥将用于使用RSA算法加密进程中使用的密钥。随着恶意软件的发展，这一过程可能会在以后的样本中发生变化。
使用Base64解码并解码对象，以便稍后使用：
使用这个密钥，将会加密先前生成的两个随机密钥，以在内存中对其进行保护。随后，加密功能将释放内存。
此后，将会再次获取被感染主机的名称，得到名称的大小，并使用与之前相同的算法来计算自定义哈希值。
对之前生成的值进行加密，并获取计算机名称：
使用这个哈希值，将会准备具有以下结构的字符串：
1、`RGNR_`
2、受害主机名称的哈希值
3、扩展名.txt
4、以反斜杠字符开头的字符串
这一过程通过函数`lstrcatW`来实现。
创建赎金提示信息名称：
使用这个字符串，勒索软件将利用`SHGetSpecialFolderPathW`函数获取所有用户“我的文档”的文件夹路径。这个包含文件夹路径的字符串将与赎金提示信息名称字符串结合在一起，共同组合创建文件的最终路径。
获取我的文档文件夹所在路径，以在稍后写入赎金提示信息：
此后，将使用`CryptBinaryToStringA`函数对关键信息进行Base64编码以解密文件。恶意软件第一次使用该函数来获取所需的大小并保留相应内存，然后再次使用该函数对数据进行编码。在对数据进行编码后，它会在文档路径中创建一个勒索提示文件，该字符串先前已经通过`CreateFileW`函数与路径进行连接，并且将会写入已经在内存中准备好的赎金提示信息内容。随后，将使用一些硬编码的特定字符串“—RAGNAR
SECRET—”对内容进行格式化，并以其作为块的开头和结尾，在二者之间，将写入Base64编码后的字符串和赎金提示信息。
创建赎金提示信息并在其末尾加入Ragnar Secret：
随后，恶意软件将使用以下两个字符串组合生成一个新的字符串：
1、`.ragnar_`
2、受害者主机名称的哈希值
该字符串稍后将用作加密文件的新扩展名。此后，恶意软件将再次使用`函数`遍历系统内的逻辑单元，并且再次检查这些单元是否正确，使用`GetLogicalDrivesW`函数检查该单元的类型，以规避CD-ROM（只读）。对于每个逻辑单元，恶意软件将遍历所有的文件和文件夹，并开始加密过程。
获取所有逻辑单元并逐一检查：
在开始加密过程之前，恶意软件先尝试将赎金记录写入每个单元的根目录中，以便易于被用户发现。
该恶意软件将忽略包含以下名称的文件夹：
    Windows
    Windows.old
    Internet Explorer
    Google
    Opera
    Opera Software
    Mozilla
    Mozilla Firefox
    $Recycle.Bin
    ProgramData
    All Users
赎金提示信息将会写入到所有受影响的文件夹中，这一点与其他的勒索软件相同。在这里，将使用`FindFirstFileW`和`FindNextFileW`函数遍历每个文件夹中的所有内容。
检查文件夹名称是否在黑名单中：
RagnarLocker还会避免加密某些特定的文件，包括：
    autorun.inf
    boot.ini
    bootfont.bin
    bootsect.bak
    bootmgr
    botmgr.efi
    bootmgfw.efi
    desktop.ini
    iconcache.db
    ntldr
    ntuser.dat
    ntuser.dat.log