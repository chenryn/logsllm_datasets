6. DISCUSSION
Running Seminal on our app collection, we discovered tens of
thousands of vulnerable apps. The presences of security risks within
these apps have been validated through a manual analysis on ran-
domly selected samples. This, however, does not mean that all
these apps can be exploited. A successful attack on a known vulner-
ability often depends on other issues such as availability of message
formats (for message injection). Sometimes, we may even need to
leverage multiple ﬂaws to make an end-to-end attack work. Given
the large number of problematic apps we discovered, it is impos-
sible for us to exploit even a small portion of them within a short
period of time. Therefore, except a few high-proﬁle apps we indeed
broke, the other ﬁndings are security risks in a strict sense. Never-
theless, all such problems are indeed security critical, rendering the
apps much more exposed to security threats than those that do not
have them.
The techniques we developed and the study we performed are
nothing more than a ﬁrst step towards effective protection of push-
messaging services. After all, we only looked at the service inte-
gration between app and SDK. It is still less clear whether other
security problems exist on the cloud front. This can be addressed
by formal veriﬁcation of the whole service. To this end, new tech-
niques need to be developed for probing the cloud-side program
logics to build a more accurate model. Also, the rapid evolution on
the messaging-service infrastructure requires continuous studies to
identify its new security-related features.
7. CONCLUSION
In this paper, we report the ﬁrst large-scale, systematic security
analysis on the integration of push-messaging services within An-
droid apps. This study was performed using Seminal, a new tool for
automatically verifying key security properties in such integrations.
Seminal is designed to leverage unique features of push-messaging
services, focusing on only a small portion of the app code related to
the integration. Running it on 30 leading cloud-messaging services
and over 35,173 popular apps, we are amazed by the scope and the
magnitude of the security problem in those services: more than half
of the service SDKs, over 20% of Google-Play apps and more than
50% apps from mainstream Chinese markets involve critical secu-
1270rity risks (see Section 6), allowing the adversary to impersonate
trusted parties to post content to the victim’s apps and intercept her
private messages. More importantly, most of the ﬂaws are never
known before. Our ﬁndings indicate the seriousness of the prob-
lem, which requires intensive effort to address, and our new tech-
nique makes the ﬁrst step toward improving the security qualities
of this important mobile cloud service.
8. ACKNOWLEDGMENTS
The project is supported in part by National Science Foundation
CNS-1117106, 1223477 and 1223495. Authors from Peking Uni-
versity are supported in part by National Development and Reform
Commission (NDRC) under project "Guidelines for Protecting Per-
sonal Information". Kai Chen was supported in part by NSFC
61100226.
9. REFERENCES
[1] Android Platform Distribution. https://developer.
android.com/about/dashboards/index.html.
[2] Baidu Cloud Push.
http://developer.baidu.com/cloud/push.
[3] CVE-2012-6636. https://web.nvd.nist.gov/
view/vuln/detail?vulnId=CVE-2012-6636.
[4] CVE-2014-6041.
http://nvd.nist.gov/nvd.cfm?cvename=CVE-
2014-6041.
[5] GCM Template Code. http://developer.android.
com/google/gcm/c2dm.html.
[6] Getui. http://www.igetui.com/.
[7] JPush. https://www.jpush.cn/.
[8] Push Woosh. https://www.pushwoosh.com/.
[9] PushIO.
http://www.responsys.com/marketing-
cloud/products/push-IO.
[10] Soot. http://www.sable.mcgill.ca/soot/.
[11] Supplement materials. https:
//sites.google.com/site/perplexedmsg/.
[12] UrbanAirship. http://urbanairship.com/.
[13] D. Arp, M. Spreitzenbarth, M. Hübner, H. Gascon, K. Rieck,
and C. Siemens. Drebin: Effective and explainable detection
of android malware in your pocket. In Proceedings of the
Annual Symposium on Network and Distributed System
Security (NDSS), 2014.
[14] S. Arzt, S. Rasthofer, C. Fritz, E. Bodden, A. Bartel, J. Klein,
Y. Le Traon, D. Octeau, and P. McDaniel. Flowdroid: Precise
context, ﬂow, ﬁeld, object-sensitive and lifecycle-aware taint
analysis for android apps. In Proceedings of the 35th ACM
SIGPLAN Conference on Programming Language Design
and Implementation, page 29. ACM, 2014.
[15] E. Chin, A. P. Felt, K. Greenwood, and D. Wagner.
Analyzing inter-application communication in android. In
Proceedings of the 9th international conference on Mobile
systems, applications, and services, pages 239–252. ACM,
2011.
[16] M. Egele, D. Brumley, Y. Fratantonio, and C. Kruegel. An
empirical study of cryptographic misuse in android
applications. In Proceedings of the 2013 ACM SIGSAC
conference on Computer & communications security, pages
73–84. ACM, 2013.
[17] W. Enck, D. Octeau, P. McDaniel, and S. Chaudhuri. A study
of android application security. In USENIX Security
Symposium, 2011.
[18] W. Enck, M. Ongtang, P. D. McDaniel, et al. Understanding
android security. IEEE Security & Privacy, 7(1):50–57,
2009.
[19] S. Fahl, M. Harbach, T. Muders, L. Baumgärtner,
B. Freisleben, and M. Smith. Why eve and mallory love
android: An analysis of android ssl (in) security. In
Proceedings of the 2012 ACM conference on Computer and
communications security, pages 50–61. ACM, 2012.
[20] A. P. Felt, H. J. Wang, A. Moshchuk, S. Hanna, and E. Chin.
Permission re-delegation: Attacks and defenses. In USENIX
Security Symposium, 2011.
[21] C. Gibler, J. Crussell, J. Erickson, and H. Chen.
AndroidLeaks: automatically detecting potential privacy
leaks in android applications on a large scale. Springer,
2012.
[22] M. I. Gordon, D. Kim, J. Perkins, L. Gilham, N. Nguyen, and
M. Rinard. Information-ﬂow analysis of android applications
in droidsafe. In Proc. of the Network and Distributed System
Security Symposium (NDSS). The Internet Society, 2015.
[23] M. Grace, Y. Zhou, Z. Wang, and X. Jiang. Systematic
detection of capability leaks in stock android smartphones. In
Proceedings of the 19th Annual Symposium on Network and
Distributed System Security, 2012.
[24] M. Grace, Y. Zhou, Q. Zhang, S. Zou, and X. Jiang.
Riskranker: scalable and accurate zero-day android malware
detection. In Proceedings of the 10th international
conference on Mobile systems, applications, and services,
pages 281–294. ACM, 2012.
[25] X. Jin, X. Hu, K. Ying, W. Du, H. Yin, and G. N. Peri. Code
injection attacks on html5-based mobile apps:
Characterization, detection and mitigation. In Proceedings of
the 2014 ACM SIGSAC Conference on Computer and
Communications Security, pages 66–77. ACM, 2014.
[26] W. Klieber, L. Flynn, A. Bhosale, L. Jia, and L. Bauer.
Android taint ﬂow analysis for app sets. In Proceedings of
the 3rd ACM SIGPLAN International Workshop on the State
of the Art in Java Program Analysis, pages 1–6. ACM, 2014.
[27] L. Li, A. Bartel, T. F. D. A. Bissyande, J. Klein, Y. Le Traon,
S. Arzt, S. Rasthofer, E. Bodden, D. Octeau, and
P. McDaniel. Iccta: detecting inter-component privacy leaks
in android apps. In 2015 IEEE/ACM 37th IEEE International
Conference on Software Engineering (ICSE 2015), 2015.
[28] T. Li, X. Zhou, L. Xing, Y. Lee, M. Naveed, X. Wang, and
X. Han. Mayhem in the push clouds: Understanding and
mitigating security hazards in mobile push-messaging
services. In Proceedings of the 2014 ACM SIGSAC
Conference on Computer and Communications Security,
pages 978–989. ACM, 2014.
[29] L. Lu, Z. Li, Z. Wu, W. Lee, and G. Jiang. Chex: statically
vetting android apps for component hijacking vulnerabilities.
In Proceedings of the 2012 ACM conference on Computer
and communications security, pages 229–240. ACM, 2012.
[30] D. Octeau, P. McDaniel, S. Jha, A. Bartel, E. Bodden,
J. Klein, and Y. Le Traon. Effective inter-component
communication mapping in android with epicc: An essential
step towards holistic security analysis. In USENIX Security
2013, 2013.
[31] S. Poeplau, Y. Fratantonio, A. Bianchi, C. Kruegel, and
G. Vigna. Execute this! analyzing unsafe and malicious
1271dynamic code loading in android applications. In
Proceedings of the 20th Annual Network & Distributed
System Security Symposium (NDSS), 2014.
[32] D. Sounthiraraj, J. Sahs, G. Greenwood, Z. Lin, and L. Khan.
Smv-hunter: Large scale, automated detection of ssl/tls
man-in-the-middle vulnerabilities in android apps. In
Proceedings of the 19th Network and Distributed System
Security Symposium, 2014.
[33] R. Wang, L. Xing, X. Wang, and S. Chen. Unauthorized
origin crossing on mobile platforms: Threats and mitigation.
In Proceedings of the 2013 ACM SIGSAC conference on
Computer & communications security, pages 635–646.
ACM, 2013.
[34] F. Wei, S. Roy, X. Ou, and Robby. Amandroid: A precise and
general inter-component data ﬂow analysis framework for
security vetting of android apps. In Proceedings of the 2014
ACM SIGSAC Conference on Computer and
Communications Security, CCS ’14, pages 1329–1341, New
York, NY, USA, 2014. ACM.
[35] M. Xia, L. Gong, Y. Lyu, Z. Qi, and X. Liu. Effective
real-time android application auditing. In IEEE S&P, 2015.
[36] Z. Yang and M. Yang. Leakminer: Detect information
leakage on android with static taint analysis. In Software
Engineering (WCSE), 2012 Third World Congress on, pages
101–104. IEEE, 2012.
messaging service. Speciﬁcally, such a service can be modeled
as (cid:104)S, A, I(cid:105). Here S is a set of states where a message or a ser-
vice request is being processed by a service entity, such as the state
of app server (appsrv), connection server (connsrv), syndication
server (synsrv), device-side service app (client), SDK (sdk) or
app (app). A is a set of security-related actions that happen on
a state. For example, A(connsrv) = (sreceive(i, appsrv →
connsrv), check(i), ssend(convert(i), connsrv → client)) m-
odels the operations performed by a connection server (at the conn
srv state) given an input i from an app server: sreceive receives
i from the network and authenticates its sender; check veriﬁes i
against a security policy that only an authorized sender (the one
bound to the registration ID in i) is allowed to push a message to
the ID; convert transforms i to i(cid:48) by replacing the registration ID
with the target device and app, and then ssend sends the input to
the service app (across the network) through an authenticated se-
cure channel and also causes the system to move to the next state
client.
Finally I is the collection of inputs to those states, in
which i is a concatenation of identiﬁer (dev), authentication tokens
(e.g., appid) and message (m).
[37] Z. Yang, M. Yang, Y. Zhang, G. Gu, P. Ning, and X. S.
Wang. Appintent: Analyzing sensitive data transmission in
android for privacy leakage detection. In Proceedings of the
2013 ACM SIGSAC conference on Computer &
communications security, pages 1043–1054. ACM, 2013.
[38] Y. Zhou and X. Jiang. Detecting passive content leaks and
pollution in android applications. In Proceedings of the 20th
Annual Symposium on Network and Distributed System
Security, 2013.
[39] Y. Zhou, Z. Wang, W. Zhou, and X. Jiang. Hey, you, get off
of my market: Detecting malicious apps in ofﬁcial and
alternative android markets. In NDSS, 2012.
APPENDIX
Models and Security Properties
To analyze the security qualities of different push-messaging ser-
vices, we ﬁrst need to ﬁnd out the security properties they are ex-
pected to have. In this section, we describe how we model these
services and identify their necessary properties, with a focus on
their integrations within apps. Understanding the integrations is a
critical ﬁrst step towards evaluating a push-messaging service’s se-
curity quality, as the prior research [28] clearly indicates that the
weakest link of security protection is on the mobile device. Also,
due to our limited observation of what happens within the cloud
(e.g., the program logic of the connection server), a study on com-
plete services is hard. Following we describe the model and prop-
erties. All the information used here comes from the speciﬁcations
of existing messaging services.
Models. The security goals of a push-messaging service can be
described as follows: (1) a message mu for a user u from an app
server appsrv should only be pushed to u and no one else; (2) u
only gets her own message mu (not others) from the authorized
server appsrv (not from an unauthorized party). The security poli-
cies for achieving these goals need to be enforced by the refer-
ence monitors distributed across different entities within a push-
Figure 8: Manufacturer Push Service Security Model
Using this simple model, Figure 8 illustrates the security checks
expected when a message is pushed to the user through the manu-
facturer service. Speciﬁcally, for the manufacturer service, after the
input i(cid:48) = (dev, appid, m) is sent to client, the service app contin-
ues to perform (sreceive(i(cid:48), connsrv → client), sdsend(i(cid:48), cli
ent → app)), where sdsend passes a message on device to an-
other Android component through an authenticated secure chan-
nel. Intuitively, these actions include authenticating the connection
server and sending i(cid:48) to the target app. Then, app further goes
through (sdreceive(i(cid:48), client → app), ucheck(i(cid:48), u)), where sdr
eceive veriﬁes the sender on the same device and ucheck inspects
the user ID within i(cid:48) against that of the current login user u to make
sure that she is the right recipient. Note that such a veriﬁcation can
only happen within the app, because no other entities in the ser-
vice can differentiate two users sharing the same app on the same
device, which if not handled properly can lead to serious security
breaches (Section 4.1).
For a third-party service, the reference monitor on the connec-
tion server connsrv performs exactly the same operations as de-
scribed above, except that ssend at connsrv sends i(cid:48) directly to
sdk through a socket connection. Here ssend uses the CID gener-
ated by the SDK during the registration process to establish such a
secure channel. In the state sdk, actions (sreceive(i(cid:48), connsrv →
sdk), sdsend(i(cid:48), sdk → app)) are taken to pass i(cid:48) securely to the
app, which further checks the user information within the input
(ucheck). When it comes to the syndication service, an additional
state synsrv needs to go through during message pushing, where a
function sconvert replaces the CID within i (from the app server)
with the registration ID of a manufacturer cloud. Also on the device
side, the client state moves to sdk before arriving at app. Along
the transitions, authentication needs to be performed at every state.
appsrvconnsrvclientappi = (m, regID)sreceive(i, appsrv->connsrv)Check(i)ssend(convert(i), connsrv->client) i  = (dev, appid, m)sdreceive(i , client->app)ucheck(i , u) sreceive(i , connsrv->client)sdsend(i , client->app) i  = (dev, appid, m)CloudMobile DeviceActions:ssend/sreceive:Secure Communication over Networksdsend/sdreceive:Secure Communication on Devicecheck:Security Policy Verificationucheck:User ID Inspection1272