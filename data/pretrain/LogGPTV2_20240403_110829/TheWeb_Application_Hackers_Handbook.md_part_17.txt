controllable data via an out-of-band channel:
n A web mail application that processes and renders e-mail messages received
via SMTP
n A publishing application that contains a function to retrieve content via
HTTP from another server
n An intrusion detection application that gathers data using a network
sniffer and presents this using a web application interface
n Any kind of application that provides an API interface for use by non-
browser user agents, such as cell phone apps, if the data processed via
this interface is shared with the primary web application
Identifying Server-Side Technologies
Normally it is possible to fi ngerprint the technologies employed on the server
via various clues and indicators.
Banner Grabbing
Many web servers disclose fi ne-grained version information, both about the
web server software itself and about other components that have been installed.
For example, the HTTP Server header discloses a huge amount of detail about
some installations:
Server: Apache/1.3.31 (Unix) mod_gzip/1.3.26.1a mod_auth_passthrough/
1.8 mod_log_bytes/1.2 mod_bwlimited/1.4 PHP/4.3.9 FrontPage/
5.0.2.2634a mod_ssl/2.8.20 OpenSSL/0.9.7a
In addition to the Server header, the type and version of software may be dis-
closed in other locations:
n Templates used to build HTML pages
n Custom HTTP headers
n URL query string parameters
cc0044..iinndddd 110011 88//1199//22001111 1122::0044::4455 PPMM
Stuttard c04.indd V3 - 07/22/2011 Page 102
102 Chapter 4 n Mapping the Application
HTTP Fingerprinting
In principle, any item of information returned by the server may be customized
or even deliberately falsifi ed, and banners like the Server header are no excep-
tion. Most application server software allows the administrator to confi gure the
banner returned in the Server HTTP header. Despite measures such as this, it is
usually possible for a determined attacker to use other aspects of the web server’s
behavior to determine the software in use, or at least narrow down the range of
possibilities. The HTTP specifi cation contains a lot of detail that is optional or left
to an implementer’s discretion. Also, many web servers deviate from or extend
the specifi cation in various ways. As a result, a web server can be fi ngerprinted
in numerous subtle ways, other than via its Server banner. Httprecon is a handy
tool that performs a number of tests in an attempt to fi ngerprint a web server’s
software. Figure 4-11 shows Httprecon running against the EIS application and
reporting various possible web servers with different degrees of confi dence.
Figure 4-11: Httprecon fingerprinting the EIS application
File Extensions
File extensions used within URLs often disclose the platform or programming
language used to implement the relevant functionality. For example:
n asp — Microsoft Active Server Pages
n aspx — Microsoft ASP.NET
cc0044..iinndddd 110022 88//1199//22001111 1122::0044::4455 PPMM
Stuttard c04.indd V3 - 07/22/2011 Page 103
Chapter 4 n Mapping the Application 103
n jsp — Java Server Pages
n cfm — Cold Fusion
n php — The PHP language
n d2w — WebSphere
n pl — The Perl language
n py — The Python language
n dll — Usually compiled native code (C or C++)
n nsf or ntf — Lotus Domino
Even if an application does not employ a particular fi le extension in its published
content, it is usually possible to verify whether the technology supporting that
extension is implemented on the server. For example, if ASP.NET is installed,
requesting a nonexistent .aspx fi le returns a customized error page generated
by the ASP.NET framework, as shown in Figure 4-12. Requesting a nonexistent
fi le with a different extension returns a generic error message generated by the
web server, as shown in Figure 4-13.
Figure 4-12: A customized error page indicating that the ASP.NET platform is present on
the server
Using the automated content discovery techniques already described, it
is possible to request a large number of common fi le extensions and quickly
confi rm whether any of the associated technologies are implemented on the
server.
The divergent behavior described arises because many web servers map
specifi c fi le extensions to particular server-side components. Each different
component may handle errors (including requests for nonexistent content) dif-
ferently. Figure 4-14 shows the various extensions that are mapped to different
handler DLLs in a default installation of IIS 5.0.
cc0044..iinndddd 110033 88//1199//22001111 1122::0044::4455 PPMM
Stuttard c04.indd V3 - 07/22/2011 Page 104
104 Chapter 4 n Mapping the Application
Figure 4-13: A generic error message created when an unrecognized file extension is
requested
Figure 4-14: File extension mappings in IIS 5.0
It is possible to detect the presence of each fi le extension mapping via the
different error messages generated when that fi le extension is requested. In
some cases, discovering a particular mapping may indicate the presence of a
web server vulnerability. For example, the .printer and .ida/.idq handlers
in IIS have in the past been found vulnerable to buffer overfl ow vulnerabilities.
Another common fi ngerprint to be aware of are URLs that look like this:
https://wahh-app/news/0,,2-421206,00.html
cc0044..iinndddd 110044 88//1199//22001111 1122::0044::4455 PPMM
Stuttard c04.indd V3 - 07/22/2011 Page 105
Chapter 4 n Mapping the Application 105
The comma-separated numbers toward the end of the URL are usually gener-
ated by the Vignette content management platform.
Directory Names
It is common to encounter subdirectory names that indicate the presence of an
associated technology. For example:
n servlet — Java servlets
n pls — Oracle Application Server PL/SQL gateway
n cfdocs or cfide — Cold Fusion
n SilverStream — The SilverStream web server
n WebObjects or {function}.woa — Apple WebObjects
n rails — Ruby on Rails
Session Tokens
Many web servers and web application platforms generate session tokens by default
with names that provide information about the technology in use. For example:
n JSESSIONID — The Java Platform
n ASPSESSIONID — Microsoft IIS server
n ASP.NET_SessionId — Microsoft ASP.NET
n CFID/CFTOKEN — Cold Fusion
n PHPSESSID — PHP
Third-Party Code Components
Many web applications incorporate third-party code components to implement
common functionality such as shopping carts, login mechanisms, and message
boards. These may be open source or may have been purchased from an external
software developer. When this is the case, the same components often appear
within numerous other web applications on the Internet, which you can inspect to
understand how the component functions. Often, other applications use different
features of the same component, enabling you to identify additional behavior and
functionality beyond what is directly visible in the target application. Also, the
software may contain known vulnerabilities that have been discussed elsewhere,
or you may be able to download and install the component yourself and perform
a source code review or probe it for defects in a controlled way.
cc0044..iinndddd 110055 88//1199//22001111 1122::0044::4455 PPMM
Stuttard c04.indd V3 - 07/22/2011 Page 106
106 Chapter 4 n Mapping the Application
HACK STEPS
1. Identify all entry points for user input, including URLs, query string param-
eters,POST data, cookies, and other HTTP headers processed by the
application.
2. Examine the query string format used by the application. If it does not
employ the standard format described in Chapter 3, try to understand
how parameters are being transmitted via the URL. Virtually all custom
schemes still employ some variation on the name/value model, so try to
understand how name/value pairs are being encapsulated into the non-
standard URLs you have identified.
3. Identify any out-of-bound channels via which user-controllable or other
third-party data is being introduced into the application’s processing.
4. View the HTTP Server banner returned by the application. Note that in
some cases, different areas of the application are handled by different
back-end components, so different Server headers may be received.
6. Check for any other software identifiers contained within any custom
HTTP headers or HTML source code comments.
7. Run the httprint tool to fingerprint the web server.
8. If fine-grained information is obtained about the web server and other
components, research the software versions in use to identify any vulner-
abilities that may be exploited to advance an attack (see Chapter 18).
9. Review your map of application URLs to identify any interesting-looking
file extensions, directories, or other sub-sequences that may provide clues
about the technologies in use on the server.
10. Review the names of all session tokens issued by the application to iden-
tify the technologies being used.
11. Use lists of common technologies, or Google, to establish which technolo-
gies may be in use on the server, or discover other websites and applica-
tions that appear to employ the same technologies.
12. Perform searches on Google for the names of any unusual cookies,
scripts, HTTP headers, and the like that may belong to third-party software
components. If you locate other applications in which the same compo-
nents are being used, review these to identify any additional functionality
and parameters that the components support, and verify whether these
are also present in your target application. Note that third-party compo-
nents may look and feel quite different in each implementation, due to
branding customizations, but the core functionality, including script and
parameter names, is often the same. If possible, download and install the
component and analyze it to fully understand its capabilities and, if pos-
sible, discover any vulnerabilities. Consult repositories of known vulner-
abilities to identify any known defects with the component in question.
cc0044..iinndddd 110066 88//1199//22001111 1122::0044::4466 PPMM
Stuttard c04.indd V3 - 07/22/2011 Page 107
Chapter 4 n Mapping the Application 107
Identifying Server-Side Functionality
It is often possible to infer a great deal about server-side functionality and struc-
ture, or at least make an educated guess, by observing clues that the application
discloses to the client.
Dissecting Requests
Consider the following URL, which is used to access a search function:
https://wahh-app.com/calendar.jsp?name=new%20applicants&isExpired=
0&startDate=22%2F09%2F2010&endDate=22%2F03%2F2011&OrderBy=name
As you have seen, the .jsp fi le extension indicates that Java Server Pages are
in use. You may guess that a search function will retrieve its information from
either an indexing system or a database. The presence of the OrderBy parameter
suggests that a back-end database is being used and that the value you submit
may be used as the ORDER BY clause of a SQL query. This parameter may well
be vulnerable to SQL injection, as may any of the other parameters if they are
used in database queries (see Chapter 9).
Also of interest among the other parameters is the isExpired fi eld. This
appears to be a Boolean fl ag specifying whether the search query should include
expired content. If the application designers did not expect ordinary users to
be able retrieve any expired content, changing this parameter from 0 to 1 could
identify an access control vulnerability (see Chapter 8).
The following URL, which allows users to access a content management
system, contains a different set of clues:
https://wahh-app.com/workbench.aspx?template=NewBranch.tpl&loc=
/default&ver=2.31&edit=false
Here, the .aspx fi le extension indicates that this is an ASP.NET application. It also
appears highly likely that the template parameter is used to specify a fi lename,
and the loc parameter is used to specify a directory. The possible fi le extension
.tpl appears to confi rm this, as does the location /default, which could very
well be a directory name. It is possible that the application retrieves the template
fi le specifi ed and includes the contents in its response. These parameters may
well be vulnerable to path traversal attacks, allowing arbitrary fi les to be read
from the server (see Chapter 10).
Also of interest is the edit parameter, which is set to false. It may be that
changing this value to true will modify the registration functionality, poten-
tially enabling an attacker to edit items that the application developer did not
intend to be editable. The ver parameter does not have any readily guessable
purpose, but it may be that modifying this will cause the application to perform
a different set of functions that an attacker could exploit.
cc0044..iinndddd 110077 88//1199//22001111 1122::0044::4466 PPMM
Stuttard c04.indd V3 - 07/22/2011 Page 108
108 Chapter 4 n Mapping the Application
Finally, consider the following request, which is used to submit a question
to application administrators:
POST /feedback.php HTTP/1.1
Host: wahh-app.com
Content-Length: 389
from=PI:EMAIL&to=PI:EMAIL&subject=
Problem+logging+in&message=Please+help...
As with the other examples, the .php fi le extension indicates that the function
is implemented using the PHP language. Also, it is extremely likely that the
application is interfacing with an external e-mail system, and it appears that
user-controllable input is being passed to that system in all relevant fi elds of
the e-mail. The function may be exploitable to send arbitrary messages to any
recipient, and any of the fi elds may also be vulnerable to e-mail header injec-
tion (see Chapter 10).
TIP It is often necessary to consider the whole URL and application context
to guess the function of different parts of a request. Recall the following URL
from the Extreme Internet Shopping application:
http://eis/pub/media/117/view
The handling of this URL is probably functionally equivalent to the
following:
http://eis/manager?schema=pub&type=media&id=117&action=view
While it isn’t certain, it seems likely that resource 117 is contained in the
collection of resources media and that the application is performing an action
on this resource that is equivalent to view. Inspecting other URLs would help
confi rm this.
The fi rst consideration would be to change the action from view to a possi-
ble alternative, such as edit or add. However, if you change it to add and this
guess is right, it would likely correspond to an attempt to add a resource with
an id of 117. This will probably fail, since there is already a resource with an
id of 117. The best approach would be to look for an add operation with an
id value higher than the highest observed value or to select an arbitrary high
value. For example, you could request the following:
http://eis/pub/media/7337/add
It may also be worthwhile to look for other data collections by altering
media while keeping a similar URL structure:
http://eis/pub/pages/1/view
http://eis/pub/users/1/view
cc0044..iinndddd 110088 88//1199//22001111 1122::0044::4466 PPMM
Stuttard c04.indd V3 - 07/22/2011 Page 109
Chapter 4 n Mapping the Application 109
HACK STEPS
1. Review the names and values of all parameters being submitted to the
application in the context of the functionality they support.
2. Try to think like a programmer, and imagine what server-side mechanisms
and technologies are likely to have been used to implement the behavior
you can observe.
Extrapolating Application Behavior
Often, an application behaves consistently across the range of its functionality.
This may be because different functions were written by the same developer
or to the same design specifi cation, or share some common code components.
In this situation, it may be possible to draw conclusions about server-side func-
tionality in one area and extrapolate these to another area.
For example, the application may enforce some global input validation checks,
such as sanitizing various kinds of potentially malicious input before it is pro-
cessed. Having identifi ed a blind SQL injection vulnerability, you may encounter
problems exploiting it, because your crafted requests are being modifi ed in
unseen ways by the input validation logic. However, other functions within the
application might provide good feedback about the kind of sanitization being
performed — for example, a function that echoes some user-supplied data to
the browser. You may be able to use this function to test different encodings and
variations of your SQL injection payload to determine what raw input must be
submitted to achieve the desired attack string after the input validation logic
has been applied. If you are lucky, the validation works in the same way across
the application, enabling you to exploit the injection fl aw.
Some applications use custom obfuscation schemes when storing sensitive
data on the client to prevent casual inspection and modifi cation of this data
by users (see Chapter 5). Some such schemes may be extremely diffi cult to
decipher given access to only a sample of obfuscated data. However, there may
be functions within the application where a user can supply an obfuscated
string and retrieve the original. For example, an error message may include the
deobfuscated data that led to the error. If the same obfuscation scheme is used
throughout the application, it may be possible to take an obfuscated string from
one location (such as a cookie) and feed it into the other function to decipher its
meaning. It may also be possible to reverse-engineer the obfuscation scheme by
submitting systematically varying values to the function and monitoring their
deobfuscated equivalents.
Finally, errors are often handled inconsistently within the application. Some
areas trap and handle errors gracefully, and other areas simply crash and return
cc0044..iinndddd 110099 88//1199//22001111 1122::0044::4466 PPMM
Stuttard c04.indd V3 - 07/22/2011 Page 110
110 Chapter 4 n Mapping the Application
verbose debugging information to the user (see Chapter 15). In this situation,
it may be possible to gather information from the error messages returned in