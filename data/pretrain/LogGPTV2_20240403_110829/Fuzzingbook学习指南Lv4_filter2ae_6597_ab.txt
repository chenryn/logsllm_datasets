            for (nextx, nexty) in neighbours(x, y):
                new_loss = get_loss(nextx, nexty)
                if new_loss =这种比较复杂的我们该怎么办呢？其实也很简单，我们下面就逐个说一下：
  * ==和!=，实质上一样，True我们使用abs(a – b)即可，False我们使用1
  * 大于、小于实质上一样，对于True使用大 – 小 + 1，对与False使用小 – 大即可
  * 大于等于、小于等于本质上一样，True就是大 – 小，False就是小 – 大 + 1
为了以后方面使用，我们可以原子化的思想，借鉴Lv3中抽象语法树对于词的拆分，将要评价的目标拆为：左项、比较符、右项，
    def evaluate_condition(num, op, lhs, rhs):
        distance_true = 0
        distance_false = 0
        # 这是展示的==操作
        if op == "Eq":
            if lhs == rhs:
                distance_false = 1
            else:
                distance_true = abs(lhs - rhs)
        # 写其他的操作
        if distance_true == 0:
            return True
        else:
            return False
那如果出现了像是`if a==b and b==c`这种多条件的情况怎么办呢？其实也很简单：
  * and，说明两种情况都得成立才行，那我们就选择两种情况中最大的作为距离即可
  * or，说明两种情况成立一种即可，有两种思路 
    * 短路，因为两种都可以，我们就只关心第一种
    * 选择两种中的最小的作为距离
  * in，判断a是否在b里，实质就是对b中的每一个元素都进行了or操作，所以我们相应的求出b中每一个元素的距离，选择最小的即可。
我们按照上面思路书写代码，即可完成对cgi_decode的测试。
看上去很美好是吧，但是很抱歉，还是有问题，你所看到的美好都是我们假设出来的，这山是我们玩的“假山”，我们假设输入的字符不是ascii，而是utf-8的呢？我们运用改进的Hillclimbing时，是每走一步都要去看周围所有的搜索空间中谁最低，相当于对每一个模式都去开辟了一个搜索空间，一旦搜索空间的单个面积大了，这玩意加起来的消耗我们可接受不起。那我们还有办法吗？说实话，没有完全的办法，我们只能是使用一些讨巧的方式减少消耗：
  * 限制迭代，简单说就是限制你下山走的次数，你走10步下不来就下不来吧，咱直接说再见。
  * 找路时只看一部分，不全看，比如本来走一步要开辟100×100的空间，那我不开了，我就开10个，我就选10个里面最小的走。这其实就是把我们改进后的Hillclimbing又改回去了，算是一种折中方案
  * 掷骰子，我随机选一条路，看能不能走，能走就走，不能走就不走接着随机。这是一种非常讨巧的方法，完全规避了搜索空间庞大的问题，甚至不用求搜索空间，只用求随机出来的模式的距离即可。代码就更好写了，用我们现成的变异函数即可，每次选路时进行一次变异，变异的距离小，就走这个。
上面都是对Hillclimbing算法的改进，但无论怎么改，我们还是没法从本质上改善算法的缺陷，最好的方法就是换方法，我们选个别的算法来进行优化。
fuzzingbook上给我们介绍了一种遗传算法来解决问题，其关键函数长这样：
    def crossover(parent1, parent2):
        pos = random.randint(1, len(parent1))
        offspring1 = parent1[:pos] + parent2[pos:]
        offspring2 = parent2[:pos] + parent1[pos:]
        return (offspring1, offspring2)
函数很简单，把俩字符串拆开，各挑一部分再拼起来。实际上这是在模拟遗传的过程，我们的字符就相当于基因，字符串就是染色体，在繁殖后代时，父母会各自给后代一部分的染色体。
那么父母是怎么来的呢？很简单，物竞天择，适者生存。我们先随机生成一部分字符串，选择其中loss（别忘了loss就是上面求的距离）最小的一部分，让他们进行“繁殖”，模拟优秀基因的传递过程，这样，通过把优秀基因不断的传递下来，我们的字符串的loss就会越来越低。
当然，生物学告诉我们，新的性状不会凭空产生，都是基因变异的结果，这个过程中我们同样需要考虑基因变异的问题，因为纯粹的遗传，基因没有发生改变，就无法产生新的字符，我们可以使用我们的变异函数，按照一定的概率对基因进行变异，创造出新的基因。
说了这么多，其实本质就是通过降低loss函数，不断优化我们模式的问题。大家可以自由发挥，甚至可以把机器学习、数学统计那部分模型拿过来用，只要是能降低loss，那就是好方法。
## 总结
这一章开始，体现了大量的知识“联动”，我们一种知识可以放在不同的地方发挥作用，一个概念也可以“两开花”，我们学到的不仅仅是fuzzing，也是对计算机问题的处理思路。
下一篇开始我们将开始新征程，跳出现在的思维，让我们的fuzzing史莱姆更加强大。