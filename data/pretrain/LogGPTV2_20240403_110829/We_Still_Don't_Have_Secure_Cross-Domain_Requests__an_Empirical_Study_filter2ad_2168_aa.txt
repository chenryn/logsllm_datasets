title:We Still Don't Have Secure Cross-Domain Requests: an Empirical Study
of CORS
author:Jianjun Chen and
Jian Jiang and
Hai-Xin Duan and
Tao Wan and
Shuo Chen and
Vern Paxson and
Min Yang
We Still Don’t Have Secure Cross-Domain Requests: 
an Empirical Study of CORS
Jianjun Chen, Tsinghua University; Jian Jiang, Shape Security; Haixin Duan,  
Tsinghua University; Tao Wan, Huawei Canada; Shuo Chen, Microsoft Research; 
Vern Paxson, UC Berkeley, ICSI; Min Yang, Fudan University
https://www.usenix.org/conference/usenixsecurity18/presentation/chen-jianjun
This paper is included in the Proceedings of the 
27th USENIX Security Symposium.
August 15–17, 2018 • Baltimore, MD, USA
ISBN 978-1-939133-04-5
Open access to the Proceedings of the 27th USENIX Security Symposium is sponsored by USENIX.We Still Don’t Have Secure Cross-Domain Requests:
an Empirical Study of CORS
Jianjun Chen
Tsinghua University
Jian Jiang
Shape Security
Haixin Duan ∗
Tsinghua University
Tao Wan
Huawei Canada
Shuo Chen
Microsoft Research
Vern Paxson
UC Berkeley, ICSI
Min Yang
Fudan University
Abstract
The default Same Origin Policy essentially restricts ac-
cess of cross-origin network resources to be “write-
only”. However, many web applications require “read”
access to contents from a different origin. Developers
have come up with workarounds, such as JSON-P, to by-
pass the default Same Origin Policy restriction. Such ad-
hoc workarounds leave a number of inherent security is-
sues. CORS (cross-origin resource sharing) is a more
disciplined mechanism supported by all web browsers to
handle cross-origin network access. This paper presents
our empirical study about the real-world uses of CORS.
We ﬁnd that the design, implementation, and deployment
of CORS are subject to a number of new security issues:
1) CORS relaxes the cross-origin “write” privilege in a
number of subtle ways that are problematic in practice;
2) CORS brings new forms of risky trust dependencies
into web interactions; 3) CORS is generally not well un-
derstood by developers, possibly due to its inexpressive
policy and its complex and subtle interactions with other
web mechanisms, leading to various misconﬁgurations.
Finally, we propose protocol simpliﬁcations and clariﬁ-
cations to mitigate the security problems uncovered in
our study. Some of our proposals have been adopted by
both CORS speciﬁcation and major browsers.
1
Introduction
Same origin policy (SOP) is the foundation for client-
side web security. It guards web resources from being
accessed by scripts from another origin. The default SOP
does not provide an explicit access control authorization
mechanism to share cross-origin network resources. Un-
der the SOP, client-side scripts are free to send GET or
POST requests to third-party servers by referencing other
websites’ resources or submitting cross origin forms, but
they have no simple and safe mechanism to read those
∗Corresponding author
responses, even from an origin willing to share. Because
many web applications have the need to read cross-origin
network resources and browsers did not have any good
support for it, developers proposed some ad-hoc mecha-
nism to serve the need. For example, JSON-P [19] uses
the exception that an imported cross-origin JavaScript
is accessible to workaround the restriction. But such a
workaround approach introduces a number of inherent
security issues.
Cross origin resource sharing (CORS) is proposed to
solve the problems of JSON-P, and to provide a proto-
col support of authorized access cross-origin network
resources. This protocol has been adopted by major
browsers (e.g., Chrome, Firefox, IE) since 2009, and has
been widely used in mainstream websites. Our work
aims to provide a comprehensive security analysis of
CORS in its protocol design, implementation, and de-
ployment process, and to identify new types of secu-
rity issues about the deployments of CORS in real-world
websites.
The issues we found in this study can be classiﬁed
into three categories: a) Overly permissive cross ori-
gin sending permissions. The CORS protocol enables
new default sending permissions inadvertently, giving at-
tackers more capabilities that lead to new security is-
sues. We found that by leveraging this relaxed send-
ing permission, an attacker could exploit previously un-
exloitable CSRF vulnerabilities, remotely infer victim’s
accurate cookie size of any website, or use a victim’s
browser as a stepping-stone to attack binary protocol ser-
vices inside victim’s internal network. b) Inherent se-
curity risks of CORS. The functionality of CORS needs
resource servers to trust third-party domains and share
resources. Such a trust dependency on third-party web-
sites increases attack surfaces and introduces new se-
curity risks. We found that an attacker can leverage
this inherent risk to launch MITM attack against HTTPS
sites or steal secrets on strongly secured target sites by
exploiting vulnerabilities on weak websites. c) Com-
USENIX Association
27th USENIX Security Symposium    1079
plex CORS details and various misconﬁgurations. While
CORS’s general process is simple, there are certain error-
prone details leading to a number of misconﬁgurations
and security issues in the real world. By conducting
a large-scale measurement on Alexa top 50,000 web-
sites including their 97,199,966 distinct sub-domains,
we found insecure CORS misconﬁgurations in 132,476
sub-domains, accounting for 27.5% of all the CORS con-
ﬁgured sub-domains across 13.2% of all CORS conﬁg-
ured “base domains” (the ﬁrst lower-level domains of
public domain sufﬁxes 1, sometimes referred to as “pub-
lic sufﬁx plus one”). Some of these domains serve pop-
ular websites, such as sohu.com, mail.ru, sogou.com,
fedex.com, washingtonpost.com. These misconﬁgura-
tions could cause privacy leakage, information theft and
even account hijacking.
We further delve into these security issues and ana-
lyze the underlying causes behind them. We found that,
although some are developer’s mistakes, many security
issues are caused by various error-prone details in the
CORS protocol design and implementation. We propose
some improvements and mitigation measures to address
these problems.
To sum up, this paper makes the following contribu-
tions:
• We conducted a comprehensive security analysis on
CORS protocol in its design, implementation, and
deployment process.
• We discovered a number of new CORS related se-
curity issues and demonstrated their consequences
with practical attacks. For example, remotely ex-
ploiting victim’s internal binary-protocol services,
remotely obtaining victim’s accurate cookie size on
any website.
• We conducted a large-scale measurement of CORS
conﬁgurations in popular websites, and found
27.5% of all the CORS conﬁgured sub-domains
across 13.2% of base domains have insecure mis-
conﬁgurations. We also provided an open-source
tool2 to help web developers and security practition-
ers identify CORS misconﬁguration vulnerabilities.
• We analyzed the underlying design reasons be-
hind those security issues, and proposed protocol
simpliﬁcations and clariﬁcations to mitigate them.
Some of our proposals have been standardized in
the CORS speciﬁcation. Major browsers (including
Chrome, Firefox) are implementing the speciﬁca-
tion changes to address these issues.
1https://publicsufﬁx.org/
2https://github.com/chenjj/CORScanner
We organize the rest of this paper as follows. Section 2
describes the development of cross origin network access
and CORS. In Section 3 we present an overview of this
study, including methodology and summary of discov-
ered CORS issues. In the next three sections (Section 4
to 6), we detail three categories of CORS security is-
sues separately and also demonstrate their security im-
plications with case studies. We discuss root causes and
possible protocol simpliﬁcations in Section 7. Then we
present responses from industry in Section 8. Finally we
review related research regarding CORS and SOP in Sec-
tion 9 and conclude in Section 10.
2 Background
Cross-origin resource access can be classiﬁed into two
categories: cross-origin local resources access (e.g., for
DOM, cookie) and cross-origin network resources access
(e.g., for XMLHttpRequest). The former has been stud-
ied in previous research [31, 45], and the latter is the fo-
cus of this paper. More speciﬁcally, we study the ac-
cess control mechanisms for both sending cross-origin
requests and reading cross-origin responses.
2.1 Cross-Origin Network Access
Cross-origin reference is a core feature of the web at its
birth, and there is no explicit cross-origin access con-
trol mechanisms built into the HTTP protocol. In other
words, any website can refer to resources of any other
website using HTML tags, implying that any website can
manipulate a visitor’s browser into issuing GET requests
to any resource servers. This does not directly cause
security concerns when HTML does not support active
content. Contents retrieved by HTTP requests are ren-
dered by the browser. Websites referring the resources
do not have direct access to the contents.
JavaScript changes the threat model of the Web, and
introduces signiﬁcant risks to the cross-origin access. In
order to ensure that different web applications cannot in-
terfere with each other, Netscape introduced the Same
Origin Policy (SOP), the fundamental isolation strategy
for client-side web application security. This policy de-
ﬁnes the security boundary of a resource by its origin,
the URI scheme/host/port tuple. Although SOP prevents
JavaScript from reading the response of a cross-origin re-
quest (except a few cases such as imported script), it does
not prevent client-side JavaScript from sending cross-
origin POST requests (e.g., using automatic form sub-
mission without user awareness). While this permissive
sending capability provides rich features for Web inter-
actions, it also introduces security problems.
1080    27th USENIX Security Symposium
USENIX Association
2.2 The Risks of Cross-Origin Sending
Automatic submission of POST requests provides more
permissions to a malicious website, enabling two types
of attacks.
The ﬁrst category of attacks is Cross Site Request
Forgery (CSRF) [42]. CSRF is a serious threat to the
Web, and has been an OWASP top-10 security issue since
2007 [27]. Besides the possibility of automatic POST
submission, two other mechanisms in web lead to the
severity of CSRF. First, POST is the standard method for
non-idempotent request that changes server state. Sec-
ond, cookies are commonly used in web applications as
authentication tokens, attached by default with HTTP re-
quests. Combining the three factors, a malicious website
can control a victim’s browser to issue POST requests
with the victim’s identity to other websites. Without suf-
ﬁcient application-level defenses, this could cause disas-
trous consequences, such as automatic money transfer-
ring from the victim to the attacker account.
The second category is HTML Form Protocol At-
tack (HFPA) [35]. HFPA allows an adversary to use a
victims’ browser as a stepping-stone to attack text-based
protocol services (such as SMTP) otherwise unreach-
able, e.g., located within an internal network. By care-
fully crafting HTML forms, an attacker can encapsulate
other textual protocol data into the body of cross-origin
POST requests. Since textual protocol implementations
are often permissive in accepting input, they simply ig-
nore the unknown lines in POST requests and execute the
known commands crafted by an attacker. Below is an ex-
ample showing how SMTP commands are encapsulated
into a POST request:
HTTP/1.1
POST /
Host: 192.168.1.1
Content-type: multipart/form-data; boundary=--123
--123
Content-Disposition: form-data; name="foo"
HELO example.com
MAIL FROM:
RCPT TO:
--123--
There are currently no effective protocol-level solution
for these two types of attacks. Proposed solutions for
CSRF attacks, such as Origin header [9] and same-site
cookies [23], are not widely deployed due to incomplete
browser support. The mainstream CSRF defense still re-
lies on CSRF tokens, implemented by individual web ap-
plications. To mitigate HFPA attacks, browsers restrict
port numbers in cross-origin requests, e.g., by disallow-
ing cross-origin requests to port 25 to protect SMTP ser-
vices. However, such blacklisting approaches are incom-
plete, since services may be conﬁgured to use different
port numbers, and new services are constantly emerging.
Thus, browsers often block only a small subset of port
numbers, leaving the majority of them exposed. For ex-
ample, Chrome disables 63 port numbers in total, while
Edge and IE browser only forbid 8 of them. None of the
browsers protect port 6379 (redis) or 11211 (memcache),
for example, leaving those services vulnerable to HFPA
attacks [17].
2.3 The Need for Cross-Origin Reading
Many web applications need JavaScript
to have the
capability to read responses of cross-origin resources.
Initially developers
invented JSON-P (JSON with
Padding) [19] to bypass SOP, by leveraging the excep-
tion that an imported cross-origin JavaScript using the
 tag is accessible to the hosting page. A re-
sources server can encapsulate shared data in JSON for-
mat into JavaScript by padding, and a third-party domain
can include the JavaScript through  tag to ob-
tain the embedded data. Although JSON-P solves some
cross-origin resource sharing problems, it still has limi-
tations. For example, it only supports resource sharing
through cross-origin GET requests and doesn’t support
other methods such as POST. Further, it introduces two
inherent security problems [16, 28]. First, importing a
third-party JSON-P resource requires complete trust of
the third-party. Because JSON-P resource is executed
immediately as JavaScript; the importing origin cannot
perform any input validation on the content. Second, a
JSON-P resource needs to have application-level access
control to prevent unauthorized read, which complicate
web application implementations.
In order to provide a safer and more powerful solu-
tion for authorized cross-origin resource sharing, W3C
designed Cross-Origin Resource Sharing (CORS) [38]
protocol to replace JSON-P. Since the ﬁrst proposal in
2005, CORS has had several iterations in terms of proto-
col design. In August 2011, CORS was included in Fetch
standard [37] by Web Hypertext Application Technology
Working Group (WHATWG) [40], another web stan-
dard organization founded by browser vendors including
Mozilla, Opera and Apple. Since then, CORS was inde-
pendently updated in the Fetch standard, and has minor
differences from the W3C standard. Browser vendors
such as Mozilla gave priority to the WHATWG’s stan-
dard [6], resulting in the obsolescence of W3C CORS
standard in August 2017 [7]. Today, CORS is im-
plemented in all major browsers and is still evolving.
Figure 1 summarizes the development history of cross-
origin access and CORS.
USENIX Association
27th USENIX Security Symposium    1081
Figure 1: Timeline of cross-origin network access and CORS development.
2.4 The Complexity of CORS
In general, CORS consists of three steps:
1. A domain issues a cross-origin request to a resource
server. For each CORS request, an Origin header is
automatically added by the browser to indicate the
origin of the requesting domain.
2. The resource server generates an access control
policy in HTTP response headers (Access-Control-
Allow-Origin) indicating the origins allowed to read
its resources.
3. The browser enforces the received access control
policy by checking if the requesting origin matches
the allowed origins as speciﬁed by Access-Control-
Allow-Origin header. Only if yes is the requesting
domain allowed to read the response content.
CORS may seem straightforward, but its details are