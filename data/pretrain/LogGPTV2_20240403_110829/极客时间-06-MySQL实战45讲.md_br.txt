# 37 \| 什么时候会使用内部临时表？今天是大年初二，在开始我们今天的学习之前，我要先和你道一声春节快乐！]{.orange}在[第 16](https://time.geekbang.org/column/article/73479)和[第34](https://time.geekbang.org/column/article/79700)篇文章中，我分别和你介绍了sort buffer、内存临时表和 joinbuffer。这三个数据结构都是用来存放语句执行过程中的中间数据，以辅助 SQL语句的执行的。其中，我们在排序的时候用到了 sort buffer，在使用 join语句的时候用到了 join buffer。然后，你可能会有这样的疑问，MySQL 什么时候会使用内部临时表呢？今天这篇文章，我就先给你举两个需要用到内部临时表的例子，来看看内部临时表是怎么工作的。然后，我们再来分析，什么情况下会使用内部临时表。
# union 执行流程为了便于量化分析，我用下面的表 t1 来举例。    create table t1(id int primary key, a int, b int, index(a));delimiter ;;create procedure idata()begin  declare i int;   set i=1;  while(i```图 1 union 语句 explain 结果]{.reference}```{=html}```可以看到：-   第二行的 key=PRIMARY，说明第二个子句用到了索引 id。-   第三行的 Extra 字段，表示在对子查询的结果集做 union    的时候，使用了临时表 (Using temporary)。``{=html}这个语句的执行流程是这样的：1.  创建一个内存临时表，这个临时表只有一个整型字段 f，并且 f    是主键字段。2.  执行第一个子查询，得到 1000 这个值，并存入临时表中。3.  执行第二个子查询：    -   拿到第一行 id=1000，试图插入临时表中。但由于 1000        这个值已经存在于临时表了，违反了唯一性约束，所以插入失败，然后继续执行；    -   取到第二行 id=999，插入临时表成功。4.  从临时表中按行取出数据，返回结果，并删除临时表，结果中包含两行数据分别是    1000 和 999。这个过程的流程图如下所示：![](Images/a0cd3ae557a517ac3ba094a789d5a329.png){savepage-src="https://static001.geekbang.org/resource/image/5d/0e/5d038c1366d375cc997005a5d65c600e.jpg"}```{=html}```图 2 union 执行流程]{.reference}```{=html}```可以看到，这里的内存临时表起到了暂存数据的作用，而且计算过程还用上了临时表主键id 的唯一性约束，实现了 union 的语义。顺便提一下，如果把上面这个语句中的 union 改成 union all的话，就没有了"去重"的语义。这样执行的时候，就依次执行子查询，得到的结果直接作为结果集的一部分，发给客户端。因此也就不需要临时表了。![](Images/685974a4f6db56cb5c839cb2f72f5c89.png){savepage-src="https://static001.geekbang.org/resource/image/c1/6d/c1e90d1d7417b484d566b95720fe3f6d.png"}```{=html}```图 3 union all 的 explain 结果]{.reference}```{=html}```可以看到，第二行的 Extra 字段显示的是 Usingindex，表示只使用了覆盖索引，没有用临时表了。
# group by 执行流程另外一个常见的使用临时表的例子是 group by，我们来看一下这个语句：    select id%10 as m, count(*) as c from t1 group by m;这个语句的逻辑是把表 t1 里的数据，按照 id%10 进行分组统计，并按照 m的结果排序后输出。它的 explain 结果如下：![](Images/9fb550c78d3e315aba267074e1b1569b.png){savepage-src="https://static001.geekbang.org/resource/image/3d/98/3d1cb94589b6b3c4bb57b0bdfa385d98.png"}```{=html}```图 4 group by 的 explain 结果]{.reference}```{=html}```在 Extra 字段里面，我们可以看到三个信息：-   Using index，表示这个语句使用了覆盖索引，选择了索引 a，不需要回表；-   Using temporary，表示使用了临时表；-   Using filesort，表示需要排序。这个语句的执行流程是这样的：1.  创建内存临时表，表里有两个字段 m 和 c，主键是 m；2.  扫描表 t1 的索引 a，依次取出叶子节点上的 id 值，计算 id%10    的结果，记为 x；    -   如果临时表中没有主键为 x 的行，就插入一个记录 (x,1);    -   如果表中有主键为 x 的行，就将 x 这一行的 c 值加 1；3.  遍历完成后，再根据字段 m 做排序，得到结果集返回给客户端。这个流程的执行图如下：![](Images/ef11efa0c4bdcc94c543d0aea6262513.png){savepage-src="https://static001.geekbang.org/resource/image/03/54/0399382169faf50fc1b354099af71954.jpg"}```{=html}```图 5 group by 执行流程]{.reference}```{=html}```图中最后一步，对内存临时表的排序，在[第 17篇文章](https://time.geekbang.org/column/article/73795)中已经有过介绍，我把图贴过来，方便你回顾。![](Images/f9411f66d015d6371e6a6eabe92b8265.png){savepage-src="https://static001.geekbang.org/resource/image/b5/68/b5168d201f5a89de3b424ede2ebf3d68.jpg"}```{=html}```图 6 内存临时表排序流程]{.reference}```{=html}```其中，临时表的排序过程就是图 6 中虚线框内的过程。接下来，我们再看一下这条语句的执行结果：![](Images/6df29bad0c5b1339db190eb505fdc409.png){savepage-src="https://static001.geekbang.org/resource/image/ae/55/ae6a28d890efc35ee4d07f694068f455.png"}```{=html}```图 7 group by 执行结果]{.reference}```{=html}```如果你的需求并不需要对结果进行排序，那你可以在 SQL 语句末尾增加 order bynull，也就是改成：    select id%10 as m, count(*) as c from t1 group by m order by null;这样就跳过了最后排序的阶段，直接从临时表中取数据返回。返回的结果如图 8所示。![](Images/e470abf93d4e95e02570862260d88311.png){savepage-src="https://static001.geekbang.org/resource/image/03/eb/036634e53276eaf8535c3442805dfaeb.png"}```{=html}```图 8 group + order by null 的结果（内存临时表）]{.reference}```{=html}```由于表 t1 中的 id 值是从 1 开始的，因此返回的结果集中第一行是id=1；扫描到 id=10 的时候才插入 m=0 这一行，因此结果集里最后一行才是m=0。这个例子里由于临时表只有 10行，内存可以放得下，因此全程只使用了内存临时表。但是，内存临时表的大小是有限制的，参数tmp_table_size 就是控制这个内存大小的，默认是 16M。如果我执行下面这个语句序列：    set tmp_table_size=1024;select id%100 as m, count(*) as c from t1 group by m order by null limit 10;把内存临时表的大小限制为最大 1024 字节，并把语句改成 id %100，这样返回结果里有 100 行数据。但是，这时的内存临时表大小不够存下这100 行数据，也就是说，执行过程中会发现内存临时表大小到达了上限（1024字节）。那么，这时候就会把内存临时表转成磁盘临时表，磁盘临时表默认使用的引擎是InnoDB。 这时，返回的结果如图 9 所示。![](Images/0c0534245cc862c1a931ddfb28c8e810.png){savepage-src="https://static001.geekbang.org/resource/image/a7/6e/a76381d0f3c947292cc28198901f9e6e.png"}```{=html}```图 9 group + order by null 的结果（磁盘临时表）]{.reference}```{=html}```如果这个表 t1的数据量很大，很可能这个查询需要的磁盘临时表就会占用大量的磁盘空间。
# group by 优化方法 \-- 索引可以看到，不论是使用内存临时表还是磁盘临时表，group by逻辑都需要构造一个带唯一索引的表，执行代价都是比较高的。如果表的数据量比较大，上面这个group by 语句执行起来就会很慢，我们有什么优化的方法呢？要解决 group by 语句的优化问题，你可以先想一下这个问题：执行 group by语句为什么需要临时表？group by 的语义逻辑，是统计不同的值出现的个数。但是，由于每一行的 id%100的结果是无序的，所以我们就需要有一个临时表，来记录并统计结果。那么，如果扫描过程中可以保证出现的数据是有序的，是不是就简单了呢？假设，现在有一个类似图 10 的这么一个数据结构，我们来看看 group by可以怎么做。![](Images/ab281739c7032614927a2541cf8fab50.png){savepage-src="https://static001.geekbang.org/resource/image/5c/19/5c4a581c324c1f6702f9a2c70acddd19.jpg"}```{=html}```图 10 group by 算法优化 - 有序输入]{.reference}```{=html}```可以看到，如果可以确保输入的数据是有序的，那么计算 group by的时候，就只需要从左到右，顺序扫描，依次累加。也就是下面这个过程：-   当碰到第一个 1 的时候，已经知道累积了 X 个 0，结果集里的第一行就是    (0,X);-   当碰到第一个 2 的时候，已经知道累积了 Y 个 1，结果集里的第二行就是    (1,Y);按照这个逻辑执行的话，扫描到整个输入的数据结束，就可以拿到 group by的结果，不需要临时表，也不需要再额外排序。你一定想到了，InnoDB 的索引，就可以满足这个输入有序的条件。在 MySQL 5.7 版本支持了 generated column机制，用来实现列数据的关联更新。你可以用下面的方法创建一个列 z，然后在 z列上创建一个索引（如果是 MySQL 5.6及之前的版本，你也可以创建普通列和索引，来解决这个问题）。    alter table t1 add column z int generated always as(id % 100), add index(z);这样，索引 z 上的数据就是类似图 10 这样有序的了。上面的 group by语句就可以改成：    select z, count(*) as c from t1 group by z;优化后的 group by 语句的 explain 结果，如下图所示：![](Images/dbdd74ae9e619ab0551d11bf9bd561d8.png){savepage-src="https://static001.geekbang.org/resource/image/c9/b9/c9f88fa42d92cf7dde78fca26c4798b9.png"}```{=html}```图 11 group by 优化的 explain 结果]{.reference}```{=html}```从 Extra 字段可以看到，这个语句的执行不再需要临时表，也不需要排序了。
# group by 优化方法 \-- 直接排序所以，如果可以通过加索引来完成 group by逻辑就再好不过了。但是，如果碰上不适合创建索引的场景，我们还是要老老实实做排序的。那么，这时候的group by 要怎么优化呢？如果我们明明知道，一个 group by语句中需要放到临时表上的数据量特别大，却还是要按照"先放到内存临时表，插入一部分数据后，发现内存临时表不够用了再转成磁盘临时表"，看上去就有点儿傻。那么，我们就会想了，MySQL 有没有让我们直接走磁盘临时表的方法呢？答案是，有的。在 group by 语句中加入 SQL_BIG_RESULT这个提示（hint），就可以告诉优化器：这个语句涉及的数据量很大，请直接用磁盘临时表。MySQL 的优化器一看，磁盘临时表是 B+树存储，存储效率不如数组来得高。所以，既然你告诉我数据量很大，那从磁盘空间考虑，还是直接用数组来存吧。因此，下面这个语句    select SQL_BIG_RESULT id%100 as m, count(*) as c from t1 group by m;的执行流程就是这样的：1.  初始化 sort_buffer，确定放入一个整型字段，记为 m；2.  扫描表 t1 的索引 a，依次取出里面的 id 值, 将 id%100 的值存入    sort_buffer 中；3.  扫描完成后，对 sort_buffer 的字段 m 做排序（如果 sort_buffer    内存不够用，就会利用磁盘临时文件辅助排序）；4.  排序完成后，就得到了一个有序数组。根据有序数组，得到数组里面的不同值，以及每个值的出现次数。这一步的逻辑，你已经从前面的图10 中了解过了。下面两张图分别是执行流程图和执行 explain 命令得到的结果。![](Images/af6704c9959bb6af81c0dc2d7206ca1e.png){savepage-src="https://static001.geekbang.org/resource/image/82/6a/8269dc6206a7ef20cb515c23df0b846a.jpg"}```{=html}```图 12 使用 SQL_BIG_RESULT 的执行流程图]{.reference}```{=html}```![](Images/29b37e0486ceadb683c4feecfe9142b3.png){savepage-src="https://static001.geekbang.org/resource/image/83/ec/83b6cd6b3e37dfbf9699cf0ccc0f1bec.png"}```{=html}```图 13 使用 SQL_BIG_RESULT 的 explain 结果]{.reference}```{=html}```从 Extra字段可以看到，这个语句的执行没有再使用临时表，而是直接用了排序算法。基于上面的 union、union all 和 group by语句的执行过程的分析，我们来回答文章开头的问题：MySQL什么时候会使用内部临时表？1.  如果语句执行过程可以一边读数据，一边直接得到结果，是不需要额外内存的，否则就需要额外的内存，来保存中间结果；2.  join_buffer 是无序数组，sort_buffer 是有序数组，临时表是二维表结构；3.  如果执行逻辑需要用到二维表特性，就会优先考虑使用临时表。比如我们的例子中，union    需要用到唯一索引约束， group by 还需要用到另外一个字段来存累积计数。
# 小结通过今天这篇文章，我重点和你讲了 group by的几种实现算法，从中可以总结一些使用的指导原则：1.  如果对 group by 语句的结果没有排序要求，要在语句后面加 order by    null；2.  尽量让 group by 过程用上表的索引，确认方法是 explain 结果里没有    Using temporary 和 Using filesort；3.  如果 group by    需要统计的数据量不大，尽量只使用内存临时表；也可以通过适当调大    tmp_table_size 参数，来避免用到磁盘临时表；4.  如果数据量实在太大，使用 SQL_BIG_RESULT    这个提示，来告诉优化器直接使用排序算法得到 group by 的结果。最后，我给你留下一个思考题吧。文章中图 8 和图 9 都是 order by null，为什么图 8 的返回结果里面，0是在结果集的最后一行，而图 9 的结果里面，0 是在结果集的第一行？你可以把你的分析写在留言区里，我会在下一篇文章和你讨论这个问题。感谢你的收听，也欢迎你把这篇文章分享给更多的朋友一起阅读。