It analyzes the outbound
trafﬁc through the monitored network and is capable
of detecting several malicious activities that the internal
hosts may perform. For example, the A-plane monitor
is able to detect scanning activities (which may be used
for malware propagation or DoS attacks), spamming,
binary downloading (possibly used for malware update),
and exploit attempts (used for malware propagation or
targeted attacks). These are the most common and “use-
ful” activities a botmaster may command his bots to
perform [9, 33, 44].
Our A-plane monitor is built based on Snort [36], an
open-source intrusion detection tool, for the purpose of
convenience. We adapted existing intrusion detection
techniques and implemented them as Snort pre-processor
plug-ins or signatures. For scan detection we adapted
SCADE (Statistical sCan Anomaly Detection Engine),
which is a part of BotHunter [19] and available at [11].
Speciﬁcally, we mainly use two anomaly detection mod-
ules: the abnormally-high scan rate and weighted failed
5This tool will be released in open source soon.
connection rate. We use an OR combination rule, so
that an event detected by either of the two modules
will trigger an alert.
In order to detect spam-related
activities, we developed a new Snort plug-in. We focused
on detecting anomalous amounts of DNS queries for
MX records from the same source IP and the amount
of SMTP connections initiated by the same source to
mail servers outside the monitored network. Normal
clients are unlikely to act as SMTP servers and therefore
should rely on the internal SMTP server for sending
emails. Use of many distinct external SMTP servers for
many times by the same internal host is an indication
of possible malicious activities. For the detection of
PE (Portable Executable) binary downloading we used
an approach similar to PEHunter [42] and BotHunter’s
egg download detection method [19]. One can also use
speciﬁc exploit rules in BotHunter to detect internal hosts
that attempt to exploit external machines. Other state-of-
the-art detection techniques can be easily added to our
A-plane monitoring to expand its ability to detect typical
botnet-related malicious activities.
It is important to note that A-plane monitoring alone
is not sufﬁcient for botnet detection purpose. First of
all, these A-plane activities are not exclusively used in
botnets. Second, because of our relatively loose design
of A-plane monitor (for example, we will generate a
log whenever there is a PE binary downloading in the
network regardless of whether the binary is malicious or
not), relying on only the logs from these activities will
generate a lot of false positives. This is why we need to
further perform A-plane clustering analysis as discussed
shortly in Section 2.6.
2.5 C-plane Clustering
C-plane clustering is responsible for reading the logs
generated by the C-plane monitor and ﬁnding clusters
of machines that share similar communication patterns.
Figure 3 shows the architecture of the C-plane clustering.
First of all, we ﬁlter out irrelevant (or uninterest-
ing) trafﬁc ﬂows. This is done in two steps: basic-
ﬁltering and white-listing. It is worth noting that these
two steps are not critical for the proper functioning of the
C-plane clustering module. Nonetheless, they are useful
for reducing the trafﬁc workload and making the actual
clustering process more efﬁcient. In the basic-ﬁltering
step, we ﬁlter out all the ﬂows that are not directed from
internal hosts to external hosts. Therefore, we ignore the
ﬂows related to communications between internal hosts6
and ﬂows initiated from external hosts towards internal
hosts (ﬁlter rule 1, denoted as F1). We also ﬁlter out
ﬂows that are not completely established (ﬁlter rule 2,
6If the C-plane monitor is deployed at the edge router, these trafﬁc
will not be seen. However, if the monitor is deployed/tested in a LAN,
then this ﬁltering can be used.
USENIX Association  
17th USENIX Security Symposium 
143
Flow
Record
Basic
Filtering
(F1,F2)
White
Listing
(F3)
Aggregation
(C-Flow)
Feature
Extraction
Feature
Reduction
Coarse-grain
Clustering
Refined
Clustering
Cluster
Reports
Figure 3: C-plane clustering.
denoted as F2), i.e., those ﬂows that only contain one-
way trafﬁc. These ﬂows are mainly caused by scanning
activity (e.g., when a host sends SYN packets without
completing the TCP hand-shake). In white-list ﬁltering,
we ﬁlter out those ﬂows whose destinations are well
known as legitimate servers (e.g., Google, Yahoo!)
that will unlikely host botnet C&C servers. This ﬁlter
rule is denoted as F3. In our current evaluation, the white
list is based on the US top 100 and global top 100 most
popular websites from Alexa.com.
After basic-ﬁltering and white-listing, we further re-
duce the trafﬁc workload by aggregating related ﬂows
into communication ﬂows (C-ﬂows) as follows. Given
an epoch E (typically one day), all m TCP/UDP ﬂows
that share the same protocol (TCP or UDP), source IP,
destination IP and port, are aggregated into the same
C-ﬂow ci = {fj}j=1..m, where each fj is a single
TCP/UDP ﬂow. Basically, the set {ci}i=1..n of all the
n C-ﬂows observed during E tells us “who was talking
to whom”, during that epoch.
2.5.1 Vector Representation of C-ﬂows
The objective of C-plane clustering is to group hosts
that share similar communication ﬂows. This can be
accomplished by clustering the C-ﬂows.
In order to
apply clustering algorithms to C-ﬂows we ﬁrst need to
translate them in a suitable vector representation. We
extract a number of statistical features from each C-ﬂow
ci, and translate them into d-dimensional pattern vectors
pi ∈ Rd. We can describe this task as a projection
function F : C-plane → Rd. The projection function F
is deﬁned as follows. Given a C-ﬂow ci, we compute the
discrete sample distribution of (currently) four random
variables:
1. the number of ﬂows per hour (fph). fph is computed
by counting the number of TCP/IP ﬂows in ci that
are present for each hour of the epoch E.
2. the number of packets per ﬂow (ppf). ppf is com-
puted by summing the total number of packets sent
within each TCP/UDP ﬂow in ci.
number of bytes transfered within fj by the number
of packets sent within fj.
4. the average number of bytes per second (bps). bps
is computed as the total number of bytes transfered
within each fj ∈ ci divided by the duration of fj.
these four
An example of the results of this process is shown in
Figure 4, where we select a random client from a real
network ﬂow log (we consider a one-day epoch) and il-
lustrate the features extracted from its visits to Google.
Given the discrete sample distribution of each
random variables, we compute an
of
approximate version of
it by means of a binning
technique. For example, in order to approximate the
distribution of fph we divide the x-axis in 13 intervals
as [0, k1], (k1, k2], ..., (k12, ∞). The values k1, .., k12
are computed as follows. First, we compute the overall
discrete sample distribution of f ph considering all the
C-ﬂows in the trafﬁc for an epoch E. Then, we compute
the quantiles7 q5%, q10%, q15%, q20%, q25%, q30%, q40%,
q50%, q60%, q70%, q80%, q90%,
obtained
distribution, and we set k1 = q5%, k2 = q10%,
k3 = q15%, etc. Now, for each C-ﬂow we can describe
its fph (approximate) distribution as a vector of 13
elements, where each element i represents the number
of times fph assumed a value within the corresponding
interval (ki−1, ki]. We also apply the same algorithm for
ppf, bpp, and bps, and therefore we map each C-ﬂow
ci into a pattern vector pi of d = 52 elements. Figure
5 shows the scaled visiting pattern extracted form the
same C-ﬂow shown in Figure 4.
of
the
2.5.2 Two-step Clustering
Since bots belonging to the same botnet share simi-
lar behavior (from both the communication and activity
points of view) as we discussed before, our objective is
to look for groups of C-ﬂows that are similar to each
other. Intuitively, pattern vectors that are close to each
other in Rd represent C-ﬂows with similar communi-
cation patterns in the C-plane. For example, suppose
two bots of the same botnet connect to two different
3. the average number of bytes per packets (bpp). For
each TCP/UDP ﬂow fj ∈ ci we divide the overall
7The quantile ql% of a random variable X is the value q for which
P (X < q) = l%.
144 
17th USENIX Security Symposium 
USENIX Association
20
15
s
w
o
l
f
#
10
5
0
0
25
20
s
w
o
l
f
#
15
10
5
0
s
w
o
l
f
#
18
16
14
12
10
8
6
4
2
0
0
50
100
150
200
250
(b) ppf
s
w
o
l
f
#
4
3.5
3
2.5
2
1.5
1
0.5
0
0
1
2
3
4
5
(a) fph
2
1.5
s
w
o
l
f
#
1
0.5
200
400
600
800
1000
0
0
2000
4000
6000
8000 10000 12000 14000
(c) bpp
(d) bps
Figure 4: Visit pattern (shown in distribution) to Google from a randomly chosen normal client.
s
w
o
l
f
#
18
16
14
12
10
8
6
4
2
0
1
2
3
4
5
6
7
8
9 10 11 12 13
(b) Scaled ppf
s
w
o
l
f
#
12
10
8
6
4
2
0
1
2
3
4
5
6
7
8
9 10 11 12 13
(c) Scaled bpp
s
w
o
l
f
#
18
16
14
12
10
8
6
4
2
0
1
2
3
4
5
6
7
8
9 10 11 12 13
(d) Scaled bps
1
2
3
4
5
6
7
8
9 10 11 12 13
(a) Scaled fph
Figure 5: Scaled visit pattern (shown in distribution) to Google for the same client in Figure 4.
C&C servers (because some botnets use multiple C&C
servers). Although the connections from both bots to
the C&C servers will be in different C-ﬂows because
of different source/destination pairs, their C&C trafﬁc
characteristics should be similar. That is, in Rd, these
C-ﬂows should be found as being very similar. In order
to ﬁnd groups of hosts that share similar communication
patterns, we apply clustering techniques on the dataset
D = {pi = F (ci)}i=1..n of the pattern vector rep-
resentations of C-ﬂows. Clustering techniques perform
unsupervised learning. Typically, they aim at ﬁnding
meaningful groups of data points in a given feature space
F. The deﬁnition of “meaningful clusters” is application-
dependent. Generally speaking, the goal is to group the
data into clusters that are both compact and well sepa-
rated from each other, according to a suitable similarity
metric deﬁned in the feature space F [25].
Clustering C-ﬂows is a challenging task because |D|,
the cardinality of D, is often large even for moderately
large networks, and the dimensionality d of the feature
space is also large. Furthermore, because the percentage
of machines in a network that are infected by bots is
generally small, we need to separate the few botnet-
related C-ﬂows from a large number of benign C-ﬂows.
All these make clustering of C-ﬂows very expensive.
In order to cope with the complexity of clustering of
D, we solve the problem in several steps (currently in two
steps), as shown in a simple form in Figure 6. At the ﬁrst
step, we perform coarse-grained clustering on a reduced
feature space Rd, with d < d, using a simple (i.e., non-
expensive) clustering algorithm (we will explain below
how we perform dimensionality reduction). The results
Figure 6: Two-step clustering of C-ﬂows.
of this ﬁrst-step clustering is a set {C
i}i=1..γ1 of γ1
relatively large clusters. By doing so we subdivide the
dataset D into smaller datasets (the clusters C
i) that
contain “clouds” of points that are not too far from each
other.
Afterwards, we reﬁne this result by performing a
second-step clustering on each different dataset C
i
using a simple clustering algorithm on the complete
description of the C-ﬂows in Rd (i.e., we do not perform
dimensionality reduction in the second-step clustering).
This second step generates a set of γ2 smaller and more
precise clusters {C
i }i=1..γ2.
We implement the ﬁrst- and second-step clustering
using the X-means clustering algorithm [31]. X-means
is an efﬁcient algorithm based on K-means [25], a very
popular clustering algorithm. Different from K-means,
USENIX Association  
17th USENIX Security Symposium 
145
the X-means algorithm does not require the user to
choose the number K of ﬁnal clusters in advance.
X-means runs multiple rounds of K-means internally