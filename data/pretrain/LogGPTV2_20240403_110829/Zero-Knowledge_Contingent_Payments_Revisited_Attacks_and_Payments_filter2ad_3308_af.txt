INV gates
Bristol Circuit Our Circuit
236112
90825
42029
103258
116245
22272
91780
2194
Table 4: Number of gates in SHA256 circuit implementations.
Bandwidth
Key Generation pk: 41959 KB
Time (ms)
14041
3287
37
Proof
Verification
sk: 13 KB
374 bytes
—
Table 3: Stats for Fair Auditing of Publicly Verifiable PoR
with SNARKs.
specifically the BLS scheme from [15]. More specifically the PoR is
succesfull if the server proves to the client that it knows s = (m, σ )
such that V er (PK, m, σ ) = 1 where V er is the verification algorithm
of the BLS signature scheme, and PK is the public key of the client.
In this case we used Protocol 1 described in Section 4.2 where
f (s) = 1 if and only if s = (m, σ ) and V er (PK, m, σ ) = 1. We imple-
mented ZK-SNARK to enable the server to prove that she knows
(s, r ) such that y = Ff ,H (s, r ). This proof was implemented in C++
using libsnark [11]. The function F was described in libsnark
as set of constraints called Rank-One Constraint System (R1CS).
Implementing the above F we obtained a R1CS system with 39409
constraints. In this setting we used λ = 80 bits of computational
security. See Table 3 for evaluation of running time and bandwidth.
For
Generation of the CRS The timing results in the tables above
refer to a Key Generation performed by a trusted party.
5.3 A More Efficient SHA256 Circuit
Implementation
SCAPI and other cryptographic libraries require the user to supply
the circuit for the function that want to compute. Building a circuit
file in this format is complex, and there is a library of such circuit
files made available by researchers at Bristol University [45].
As part of the implementation in the proof of concept above, we
constructed a new optimized reusable boolean circuit for SHA256.
Our circuit may be of independent use for circuit-based MPC and
FHE protocols that require SHA256 computations.
To the best of our knowledge, the only other re-usable circuit im-
plementation openly available for SHA256 was developed the Bristol
circuit. See Table 4 for a comparison of the circuit parameters be-
tween the Bristol circuit and ours. Our circuit compares favorably
both with respect to the total number of gates and to the number
of AND gates. The latter parameter is particularly important if one
intends to use SHA256 in Secure Multi-Party Computation. In fact,
in modern MPC protocols the number of AND gates dominates the
total evaluation cost thanks to a technique called Free-XOR [33]
which evaluates XOR gates “for free”. In the process of building
our SHA256 circuit we developed a library for semi-automated gen-
eration of optimized boolean circuits which we believe may be of
independent interest. We stress that our contribution here is not the
optimizations themselves as they were mostly straightforward from
the SHA2 specification, but or contributions is the the optimized
implementation of SHA2 in a boolean circuit format that can be
reused by other cryptographic libraries and protocols.
6 ACKNOWLEDGMENTS
We thank Dario Fiore, Hugo Krawczyk, Arvind Narayanan, Pino
Persiano, and Eran Tromer and the anonymous reviewers for useful
discussions and advice.
Matteo Campanelli is supported by NSF Grant 1545759. Rosario
Gennaro is supported by NSF Grant 1565403. Steven Goldfeder is
supported by the NSF Graduate Research Fellowship under grant
number DGE-1148900 and NSF award CNS-1651938.
REFERENCES
[1] B. Abdolmaleki, K. Baghery, H. Lipmaa, and M. Zajac. A subversion-resistant
snark. Cryptology ePrint Archive, Report 2017/599, 2017. http://eprint.iacr.org/
2017/599.
[2] G. Andresen. Github: Proposal: open up IsStandard for P2SH transactions. https:
//gist.github.com/gavinandresen/88be40c141bc67acb247, 2017.
[3] M. Andrychowicz, S. Dziembowski, D. Malinowski, and L. Mazurek. Fair two-
party computations via bitcoin deposits. In R. Böhme, M. Brenner, T. Moore,
and M. Smith, editors, FC 2014 Workshops, volume 8438 of LNCS, pages 105–121.
Springer, Mar. 2014.
[4] M. Andrychowicz, S. Dziembowski, D. Malinowski, and L. Mazurek. On the
In International Conference on Financial
malleability of bitcoin transactions.
Cryptography and Data Security, pages 1–18. Springer, 2015.
[5] N. Asokan, V. Shoup, and M. Waidner. Optimistic fair exchange of digital signa-
tures (extended abstract). In K. Nyberg, editor, EUROCRYPT’98, volume 1403 of
LNCS, pages 591–606. Springer, May / June 1998.
[6] W. Banasik, S. Dziembowski, and D. Malinowski. Efficient zero-knowledge
contingent payments in cryptocurrencies without scripts. In European Symposium
on Research in Computer Security, pages 261–280. Springer, 2016.
[7] M. Bellare, G. Fuchsbauer, and A. Scafuro. Nizks with an untrusted crs: security
in the face of parameter subversion. In Advances in Cryptology - ASIACRYPT
2016 - 22nd International Conference on the Theory and Application of Cryptology
and Information Security, Part II, pages 777–804. Springer, 2016.
[8] E. Ben-Sasson, A. Chiesa, D. Genkin, S. Kfir, E. Tromer, M. S. L. Virza, and oth-
ers external contributors. Libsnark, 2017. https://github.com/scipr-lab/libsnark.
[9] E. Ben-Sasson, A. Chiesa, M. Green, E. Tromer, and M. Virza. Secure sampling
of public parameters for succinct zero knowledge proofs. In IEEE Security and
Privacy Conference, pages 287–304, 2015.
[10] E. Ben-Sasson, A. Chiesa, E. Tromer, and M. Virza. Scalable zero knowledge via
cycles of elliptic curves. In J. A. Garay and R. Gennaro, editors, CRYPTO 2014,
Part II, volume 8617 of LNCS, pages 276–294. Springer, Aug. 2014.
[11] E. Ben-Sasson, A. Chiesa, E. Tromer, and M. Virza. Succinct non-interactive zero
knowledge for a von neumann architecture. In Proceedings of the 23rd USENIX
Conference on Security Symposium, SEC’14, pages 781–796, Berkeley, CA, USA,
2014. USENIX Association.
[12] BitcoinWiki. Bitcoin transaction, 2016. https://en.bitcoin.it/wiki/Transaction.
[13] BitcoinWiki. Zero knowledge contingent payment, 2016. https://en.bitcoin.it/
wiki/Zero_Knowledge_Contingent_Payment.
[14] BitcoinWiki. Scripts, 2017. https://en.bitcoin.it/wiki/Script.
[15] D. Boneh, B. Lynn, and H. Shacham. Short signatures from the weil pairing.
In International Conference on the Theory and Application of Cryptology and
Information Security, pages 514–532. Springer, 2001.
[16] D. Boneh, B. Lynn, and H. Shacham. Short signatures from the weil pairing.
In International Conference on the Theory and Application of Cryptology and
Session A5:  CryptocurrencyCCS’17, October 30-November 3, 2017, Dallas, TX, USA241[17] J. Bonneau, A. Miller, J. Clark, A. Narayanan, J. A. Kroll, and E. W. Felten. Sok:
Information Security, pages 514–532. Springer, 2001.
Research perspectives and challenges for bitcoin and cryptocurrencies, 2015.
[18] S. Bowe. pay-to-sudoku, 2016. https://github.com/zcash/pay-to-sudoku.
[19] S. Bowe, A. Gabizon, and M. Green. A multi-party protocol for constructing the
public parameters of the pinocchio zk-snark. 2016. https://github.com/zcash/
mpc/blob/master/whitepaper.pdf.
[20] V. Buterin et al. A next-generation smart contract and decentralized application
platform, 2014.
[21] M. Campanelli, R. Gennaro, S. Goldfeder, and L. Nizzardo. An attack to pay-to-
sudoku. https://github.com/matteocam/pay-to-sudoku-attack, 2017.
[22] M. Campanelli, R. Gennaro, S. Goldfeder, and L. Nizzardo. Zkcsp over bitcoin.
https://github.com/matteocam/zkcsp-over-bitcoin, 2017.
[23] R. Cleve. Limits on the security of coin flips when half the processors are faulty
(extended abstract). In J. Hartmanis, editor, Proceedings of the 18th Annual ACM
Symposium on Theory of Computing, May 28-30, 1986, Berkeley, California, USA,
pages 364–369. ACM, 1986.
[24] G. G. Dagher, B. Bünz, J. Bonneau, J. Clark, and D. Boneh. Provisions: Privacy-
preserving proofs of solvency for bitcoin exchanges. In Proceedings of the 22nd
ACM SIGSAC Conference on Computer and Communications Security, pages 720–
731. ACM, 2015.
[25] G. Danezis, C. Fournet, J. Groth, and M. Kohlweiss. Square span programs with
applications to succinct NIZK arguments.
In P. Sarkar and T. Iwata, editors,
ASIACRYPT 2014, Part I, volume 8873 of LNCS, pages 532–550. Springer, Dec.
2014.
[26] Y. Ejgenberg, M. Farbstein, M. Levy, and Y. Lindell. Scapi: The secure computation
application programming interface. IACR Cryptology EPrint Archive, 2012:629,
2012.
[27] U. Feige and A. Shamir. Witness indistinguishable and witness hiding protocols.
In Proceedings of the 22nd Annual ACM Symposium on Theory of Computing, May
13-17, 1990, Baltimore, Maryland, USA, pages 416–426, 1990.
[28] G. Fuchsbauer. Subversion-zero-knowledge snarks. Cryptology ePrint Archive,
Report 2017/587, 2017. http://eprint.iacr.org/2017/587.
[31] O. Goldreich and Y. Oren. Definitions and properties of zero-knowledge proof
[30] O. Goldreich and H. Krawczyk. On the composition of zero-knowledge proof
[29] R. Gennaro, C. Gentry, B. Parno, and M. Raykova. Quadratic span programs
and succinct NIZKs without PCPs. In T. Johansson and P. Q. Nguyen, editors,
EUROCRYPT 2013, volume 7881 of LNCS, pages 626–645. Springer, May 2013.
systems. SIAM J. Comput., 25(1):169–192, 1996.
systems. J. Cryptology, 7(1):1–32, 1994.
In
Proceedings of the 14th ACM conference on Computer and communications security,
pages 584–597. Acm, 2007.
[33] V. Kolesnikov and T. Schneider. Improved garbled circuit: Free xor gates and
[32] A. Juels and B. S. Kaliski Jr. Pors: Proofs of retrievability for large files.
applications. Automata, Languages and Programming, pages 486–498, 2008.
[34] H. Krawczyk. Lfsr-based hashing and authentication. In Advances in Cryptology
- CRYPTO ’94, 14th Annual International Cryptology Conference, Santa Barbara,
California, USA, August 21-25, 1994, Proceedings, volume 839, pages 129–139.
Springer, 1994.
[35] A. Küpçü and A. Lysyanskaya. Usable optimistic fair exchange. In J. Pieprzyk,
editor, CT-RSA 2010, volume 5985 of LNCS, pages 252–267. Springer, Mar. 2010.
[36] Y. Lindell and B. Pinkas. An efficient protocol for secure two-party computation
in the presence of malicious adversaries. In Annual International Conference on
the Theory and Applications of Cryptographic Techniques, pages 52–78. Springer,
2007.
[37] G. Maxwell. Zero knowledge contingent payment, 2015. https://en.bitcoin.it/
wiki/Zero_Knowledge_Contingent_Payment.
[38] S. Nakamoto. Bitcoin: A peer-to-peer electronic cash system. 2008.
[39] A. Narayanan, J. Bonneau, E. Felten, A. Miller, and S. Goldfeder. Bitcoin and
Cryptocurrency Technologies: A Comprehensive Introduction. Princeton University
Press, 2016.
[40] B. Parno, J. Howell, C. Gentry, and M. Raykova. Pinocchio: Nearly practical
verifiable computation. In 2013 IEEE Symposium on Security and Privacy, pages
238–252. IEEE Computer Society Press, May 2013.
[41] A. D. Santis and G. Persiano. Zero-knowledge proofs of knowledge without
interaction (extended abstract). In 33rd Annual Symposium on Foundations of
Computer Science, Pittsburgh, Pennsylvania, USA, 24-27 October 1992, pages 427–
436, 1992.
[42] E. B. Sasson, A. Chiesa, C. Garman, M. Green, I. Miers, E. Tromer, and M. Virza.
Zerocash: Decentralized anonymous payments from bitcoin. In Security and
Privacy (SP), 2014 IEEE Symposium on, pages 459–474. IEEE, 2014.
[43] H. Shacham and B. Waters. Compact proofs of retrievability. In J. Pieprzyk, editor,
ASIACRYPT 2008, volume 5350 of LNCS, pages 90–107. Springer, Dec. 2008.
[44] H. Shacham and B. Waters. Compact proofs of retrievability. In International
Conference on the Theory and Application of Cryptology and Information Security,
pages 90–107. Springer, 2008.
[45] S. Tillich and N. Smart. Circuits of basic functions suitable for mpc and fhe, 2016.
[46] F. Tramer, F. Zhang, H. Lin, J.-P. Hubaux, A. Juels, and E. Shi. Sealed-glass proofs:
Using transparent enclaves to prove and sell knowledge. Euro Security and
Privacy’17, 2017. To appear.
[47] J. van Lint. Introduction to coding theory, 1992.
[48] X. Wang, A. J. Malozemoff, and J. Katz. Faster secure two-party computation in
the single-execution setting. In Annual International Conference on the Theory
and Applications of Cryptographic Techniques, pages 399–424. Springer, 2017.
[49] M. N. Wegman and J. L. Carter. New hash functions and their use in authentication
and set equality. Journal of computer and system sciences, 22(3):265–279, 1981.
[50] G. Wood. Ethereum: A secure decentralised generalised transaction ledger, 2014.
[51] A. C. Yao. Protocols for secure computations. In Foundations of Computer Science,
1982. SFCS’08. 23rd Annual Symposium on, pages 160–164. IEEE, 1982.
A APPENDIX: THE SHACHAM/WATERS POR
SCHEME
A Proof of Retrievability (PoR) scheme involves a client C, who
outsources some data, and a server S who is supposed to store
them, in a way that he can prove to a verifier that he is actually
storing the client’s data. In [43], Shacham and Waters presented
two compact proof of retrievability schemes, one with private and
another with public verifiability. The first one is based on PRFs and
secure in the standard model, the second one based on BLS signa-
tures [16], secure in the Random Oracle Model. The framework is
the same for both: an erasured coded file is divided into n blocks
m1, . . . , mn ∈ Zp, where p is a large prime. Intuitively, the fact that
the file is erasured coded ensures that it is possible to decode even
in presence of adversarial (or random) erasure (see [47] for further
details about erasure codes).
Privately Verifiable POR Scheme: In order to authenticate each
block mi, the client C chooses a secret key which is composed by a
$← Zp and a PRF key k for a function f . Then, for each
random α
i ∈ [n] she computes σi := fk (i) + αmi ∈ Zp.
The pairs {(mi , σi )}i∈[n] are then stored into the server and the
proof of retrievability between the server and the verifier works as
follows:
(1) The verifier chooses a challenge set I ⊂ [n], | I |= ℓ and
some coefficients ν1, . . . νℓ ∈ Zp. The set Q := {(i, νi )}i∈[ℓ]
is then sent to the server.
(2) The server sends back a pair (σ , µ), where
σ ← (cid:88)
(i,νi )∈Q
σ = α · µ +
νi · mi.
νi · σi and µ ← (cid:88)
(cid:88)
νi · fk (i)
(i,νi )∈Q
(i,νi )∈Q
(3) The verifies checks whether the following holds
.
Note the here the secret key is necessary in order to run the verifi-
cation.
(cid:102)
Public Verifiable POR Scheme: Let e : G × G → G be a bilinear
map and let Zp be the support of G . The client sets a secret key
to be x ← Zp and the public key to be (v := дx , u), where д, u
are two generators of G. Then, for each i ∈ [n] she computes
σi
stored into the server and the proof of retrievability between the
server and the verifier works as follows:
(cid:103)x . As before, the pairs {(mi , σi )}i∈[n] are then
H (i)umi
:=
Session A5:  CryptocurrencyCCS’17, October 30-November 3, 2017, Dallas, TX, USA242σ ← (cid:89)
(2) The server sends back a pair (σ , µ), where
νi · mi.
(3) The verifies checks whether the following holds:
(i,νi )∈Q
(i,νi )∈Q
σ
νi
i
and µ ← (cid:88)
(cid:89)
H (i)νi · uµ , v)
(1) The verifier chooses a challenge set I ⊂ [n], | I |= ℓ and
some coefficients ν1, . . . νℓ ∈ Zp. The set Q := {(i, νi )}i∈[ℓ]
is then sent to the server.
e (σ , д) = e (
.
(i,νi )∈Q
Note that the secret key x is necessary in order to create the
authenticators {σi}. On the other hand the public element v is
sufficient to perform the verification.
Session A5:  CryptocurrencyCCS’17, October 30-November 3, 2017, Dallas, TX, USA243