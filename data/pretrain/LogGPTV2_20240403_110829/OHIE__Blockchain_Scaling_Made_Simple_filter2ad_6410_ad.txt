pn ticks of the execution,
1−f T honest blocks are newly
in every 2T
added to S.
pn ticks, at least 1−2f
C. Proof for Theorem 1
Overview of proof for Theorem 1. Our ﬁrst step is to obtain
a reduction from (p, λ, T )-Nakamoto to (k, p, λ, T )-OHIE.
Consider any given adversary A for (k, p, λ, T )-OHIE, and any
given chain i (0 ≤ i ≤ k − 1) in the execution of (k, p, λ, T )-
OHIE against A. Our reduction step will show that there exists
13Different prior works [17], [40] deﬁne consistency slightly differently.
Our deﬁnition here is either equivalent or stronger than those in the prior
works.
97
some adversary A(cid:48) for (p, λ, T )-Nakamoto with the following
property: Except some exponentially small probability and
after proper mapping from blocks in (k, p, λ, T )-OHIE to
blocks in (p, λ, T )-Nakamoto, the behavior of chain i in the
execution of (k, p, λ, T )-OHIE against A follows exactly the
same distribution as the behavior of the (single) chain in the
execution of (p, λ, T )-Nakamoto against A(cid:48). Such a reduction
implies that existing properties on (p, λ, T )-Nakamoto directly
carry over to each individual chain in (k, p, λ, T )-OHIE.
Our second step is to show that conditioned upon all the
existing properties (in Theorem 2) on (p, λ, T )-Nakamoto
holding for each individual chain in (k, p, λ, T )-OHIE, the
SCB generated in OHIE must satisfy the properties in The-
orem 1, except with some exponentially small probability.
The reasoning in this step will center around the rank and
next rank values of the blocks.
Formal concepts needed for reduction. Consider any (black-
box and potentially randomized) adversary A for OHIE. Deﬁne
EXEC(OHIE, k, p, λ, T,A) to be the random variable denoting
the joint states of all the honest nodes and the adversary
throughout (i.e., at every tick) the entire execution resulted
from running (k, p, λ, T )-OHIE against A. Deﬁne random vari-
able Chainviewi(EXEC(OHIE, k, p, λ, T,A)) to be the joint
state of chain i on every honest node throughout this execution.
Recall that in OHIE, a node maintains k sets of blocks, V0
through Vk−1, and chain i corresponds to the longest path in
Vi. One could imagine that for each (u, t) pair, Chainviewi()
contains a component describing chain i on the honest node
u at tick t.
We similarly deﬁne EXEC(Nakamoto, p, λ, T,A(cid:48)) for the
execution resulted from running (p, λ, T )-Nakamoto against
adversary A(cid:48). Also, we similarly deﬁne random variable
Chainview(EXEC(Nakamoto, p, λ, T,A(cid:48))) to be the joint state
of the (single) chain on every honest node throughout this
execution.
For two random variables X and Y over some ﬁnite
domain Z, deﬁne their variation distance to be ||X − Y || =
z∈Z | Pr[X = z] − Pr[Y = z]|. If X and Y are both
parameterized by λ, we say that X(λ) is strongly statistically
close to Y (λ) iff ||X − Y || = exp(−Ω(λ)).
Our reduction lemma. The following is our reduction lemma:
Lemma 3. Consider any given i where 0 ≤ i ≤ k−1, and any
given adversary A for (k, p, λ, T )-OHIE. There exists some
adversary A(cid:48)
i for (p, λ, T )-Nakamoto such that the following
two random variables are strongly statistically close:
0.5(cid:80)
Here τ is the randomness in EXEC(Nakamoto, p, λ, T,A(cid:48)
i).
i (Chainview()) is the same as
The random variable στ
that we replace each block B(cid:48)
Chainview(), except
in
i (B(cid:48)). The mapping στ
Chainview() with another block στ
i ()
is some one-to-one mapping from each block B(cid:48) among all the
blocks on all the nodes in (p, λ, T )-Nakamoto to some block
i (B(cid:48)) on all the nodes in (k, p, λ, T )-OHIE. The mapping
στ
i () guarantees that i) B(cid:48) is an honest block iff στ
i (B(cid:48)) is an
στ
• Chainviewi(EXEC(OHIE, k, p, λ, T,A))
• στ
i (Chainview(EXEC(Nakamoto, p, λ, T,A(cid:48)
i))
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 09:19:07 UTC from IEEE Xplore.  Restrictions apply. 
honest block, and ii) B(cid:48) extends from A(cid:48) iff στ
from στ
i (A(cid:48)).
i (B(cid:48)) extends
The crux of proving this lemma is to construct the adversary
A(cid:48)
i. In our proof, A(cid:48)
i simulates a certain execution of OHIE
against A. More precisely, A(cid:48)
i simulates all the OHIE nodes, as
well as the adversary A in a black-box fashion. The adversary
A(cid:48)
i simultaneously interacts with the (real) nodes running
(p, λ, T )-Nakamoto, while ensuring that the simulated OHIE
execution and the real Nakamoto execution are properly “cou-
pled”. Due to space limitations, we defer the complete proof of
this lemma to our extended technical report [46]. To be fully
rigorous, the complete proof needs additional formalism and
also needs to fully specify the (p, λ, T )-Nakamoto protocol by
pseudo-code.
From individual chains to SCB. The following lemma (proof
in Appendix A) establishes the connection from the individual
chains in OHIE to the SCB in OHIE:
Lemma 4. If the three properties in Theorem 2 hold for each
of the k chains in (k, p, λ, T )-OHIE, then with probability
at
the SCB in OHIE satisﬁes the
consistency and quality-growth properties in Theorem 1.
least 1 − exp(−Ω(λ)),
Final proof. Using all the lemmas, we can now prove Theo-
rem 1:
Proof. (for Theorem 1) We set the constant c in Theorem 1 to
be the same as the c in Theorem 2. For any given i where 0 ≤
i ≤ k − 1, Lemma 3 and Theorem 2 tell us that for chain i in
(k, p, λ, T )-OHIE, with probability at least 1− exp(−Ω(λ))−
exp(−Ω(T ))−exp(−Ω(λ)), the three properties in Theorem 2
hold for that chain. Hence with probability at least 1 − k ·
exp(−Ω(λ)) − k · exp(−Ω(T )), the properties in Theorem 2
hold for all k chains in (k, p, λ, T )-OHIE. The growth and
quality properties in Theorem 1 then directly follow. Applying
Lemma 4 further leads to the consistency and quality-growth
properties in Theorem 1.
D. Discussion and Comparison
Plug-in alternative results. Our analysis invokes the results in
[40]. The analysis in [40] is just one of the many works [17],
[18], [24], [26], [40] that analyze Nakamoto-style protocols.
A highlight of our proof on OHIE is that it invokes the ex-
isting guarantees on (p, λ, T )-Nakamoto as black-box. Hence
alternative results on (p, λ, T )-Nakamoto directly translates to
alternative results on OHIE.
Speciﬁcally, Theorem 2 (adopted from [40]) has the follow-
ing three quantitative measures:
1
c∆n is the upper limit on p.
• The value of c, where
• The value of x = 2T
pn ticks (i.e., the growth rate), which
is the time needed for the chain length to grow by T
blocks.
• The value of y = 1−2f
1−f T (i.e., the quality rate), which is
the number of honest blocks among every T consecutive
blocks on the chain.
Other analyses [17], [18], [24], [26] have obtained alternative
results on x and y values for (p, λ, T )-Nakamoto. They have
also derived various sufﬁcient conditions14 for consistency in
(p, λ, T )-Nakamoto, which all ultimately translate to require-
ment on the value of c.
We can directly plug in alternative c, x, and y values
from alternative analyses on (p, λ, T )-Nakamoto to obtain
alternative results on OHIE. If we do so, then the value of
c in Theorem 1 will be exactly the same as the given c. The
consistency property in Theorem 1 will remain unchanged.
The remaining properties in Theorem 1 will become:
• (growth) The length of each of the k chains on each
honest node will increase by at least T blocks every x
ticks.
• (quality) On any honest node and at any time, every T
consecutive blocks on any of the k chains must contain
at least y honest blocks.
• (quality-growth) For all integer γ ≥ 1, after the very
ﬁrst x ticks of the execution, on any honest node in every
(γ + 2) · x + 2∆ ticks, at least γ · k · y honest blocks are
newly added to SCB.
Comparing with prior results. With the above discussion,
we can now easily compare Theorem 1 with any of the prior
results [17], [18], [24], [26], [40]. Consider the result from
any such prior analyses, with certain resulting c, x, and y
values. (This also implies that in that particular result, the rate
of quality-growth is y new honest blocks every x ticks.) Now
let us plug in such c, x, and y values into Theorem 1. Then
OHIE will provide exactly the same quantitative guarantees as
that prior result, in terms of the value of c, the growth rate,
and the quality rate. The only difference will be regarding
the quality-growth of SCB. Under the given x and y, for all
integer γ ≥ 1, in OHIE γ · k· y honest blocks are newly added
to the SCB every (γ +2)·x+2∆ ticks. Since 2∆ is dominated
by (γ +2)·x, the average rate of honest blocks being added to
the SCB is about k· y honest blocks every x ticks, in the long
term. Such a rate is k times of the rate of quality-growth in
the corresponding prior result. This also intuitively explains
why OHIE increases throughput by k times.15
Conﬁrmation latency. Finally, Theorem 1 also indirectly
gives OHIE’s guarantee on transaction conﬁrmation latency
(also called wait-time in [17], [40]): Assume that we want
the properties in Theorem 1 to hold with 1 −  probability,
c∆n ). By quality-
and let us invoke the theorem with p = Θ( 1
growth, at least one honest block is newly added to SCB
within Θ(T ∆) = Θ((log 1
 + log k)∆) ticks. Now if a
transaction is injected into all honest nodes continuously for
 + log k)∆) ticks, this transaction must be included
Θ((log 1
in the SCB after those ticks. Hence, the conﬁrmation latency
is simply Θ((log 1
 + log k)∆) ticks. As explained earlier,
14For
example,
the
α(1 − 2(∆ + 1)α) ≥ (1 + η)β for some positive constant η.
sufﬁcient
condition derived in [40]
15Of course, k cannot be unbounded. In practice, increasing k beyond a
certain point will cause a non-trivial increase in ∆, when the system starts to
saturate the network bandwidth. Our experiments later will quantify this.
is
that
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 09:19:07 UTC from IEEE Xplore.  Restrictions apply. 
98
 ) in practical settings. Such
this usually becomes Θ(∆ log 1
a conﬁrmation latency is the same as in [17], [40], and is
fundamental in all Nakamoto-style protocols: Each new block
takes Θ(∆) ticks, and Θ(log 1
 ) new blocks are needed for the
“conﬁdence” to reach 1 − .
VI. EXPERIMENTAL EVALUATION
Methodology. We have implemented a prototype of OHIE in
C++, with total around 4,700 lines of code. We use Amazon’s
EC2 virtual machines (or EC2 instances) for evaluation. We
rent m4.2xlarge instances in 14 cities around the globe16,
with each instance having 8 cores and 1Gbps bandwidth.
The one-way latency between two random EC2 instances
is about 90-140ms, which is consistent with AlgoRand’s
experiments [20] and with measurements in Bitcoin and
Ethereum [19]. To avoid excessive monetary expenses on EC2,
we run two sets of experiments. Our macro experiments run
12, 000 to 50, 000 OHIE nodes on up to 1, 000 EC2 instances
to evaluate the end performance of OHIE, while our micro
experiments run 1, 000 OHIE nodes on 20 EC2 instances to
determine OHIE internal parameters.
In all experiments, the OHIE nodes form a P2P overlay by
each node connecting to 8 randomly selected peers, and per-
node bandwidth is up to 20Mbps, since we run 50 nodes per
EC2 instance. This setup is the same as in the experiments
of AlgoRand [20] and Conﬂux [32]. All results reported are
averaged over 5 runs, each lasting until measurements stabilize
in that run.
A. Choosing Block Size and Block Interval in OHIE
We ﬁrst use micro experiments to measure the block prop-
agation delay (BPD) for a single block (with no parallel
propagations) to reach 99% of the nodes. We consider differ-
ent bandwidth conﬁgurations where the per-node bandwidth
ranges from 8Mbps to 20Mbps. We observe that the BPD
for 20 KB blocks is about 1.7-1.9 seconds, across all our
bandwidth conﬁgurations. Similar BPD values are observed
for block sizes ranging from 10 KB to 64 KB.
We further observe that such BPD does not signiﬁcantly
increase as the network size increases: Even in our macro
experiments with 50, 000 nodes, the BPD values are still only
about 3.2 seconds for 10-20 KB blocks. This is consistent
with theoretical expectations about random graphs,17 and the
fact that BPD is proportional to the average number of hops
between two nodes.
Smaller blocks enable better decentralization, but also incur
more protocol overheads. Taking all factors into account, we
choose a block size of 20 KB for OHIE. We then set p to
correspond to a block interval of about 10 seconds on each
chain. Based on Section V and results in [40], a block interval
of 5× BPD is sufﬁcient to tolerate f = 0.43.
16This is the maximal number of cities with such instances.
17In random Erdos-Renyi graphs, roughly speaking, the average number of
hops between two nodes increases only logarithmically with the number of
nodes.
8
6
4
2
)
s
d
n
o
c
e
s
(
D
P
B