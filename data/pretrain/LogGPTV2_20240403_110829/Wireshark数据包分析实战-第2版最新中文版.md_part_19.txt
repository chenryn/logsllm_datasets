包的来源。
Wireshark数据包分析实战（第2版）
sre:
服务器。
32bytes
备的查询。
祸首。
SYN数据包没有得到响应，这告诉我们总部和分公司DNS服务器之间区域
[validationdisabTed]
2009653443
078
3.学到的知识
图8-36这个SYN数据包使用了53端口，但不是UDP
208
(172
2510
53
然后找到了DNS
---
## Page 194
8.3.6
生气的开发者
但通常它们最终能帮你找出来。
服务器，最终找到路由器，也就是问题的来源。
value，简称CSV）文件的形式传回，插入中心数据库中。
报告回中心数据库。为了节约正常工作时间的带宽，他没有设计成实时应用程
的代码。
糕的网络设置和设备。系统管理员则倾向于把网络错误和网络缓慢归答于槽糕
怨这是网络的问题。程序员一口咬定文件在从商店传到中心数据库时被损坏了。
还存在错误，而且文件某些部分还丢失了。系统管理员很烦恼，因为程序员抱
回的文件，但插入数据库的数据是错误的。一些地区的数据丢失了，有的数据
办公室那边
故障影响到了所有商店，因此如果这确实是网络导致的问题，那肯定是在中心
我们就要证明他是错的。
pcap文件中。
然而，这个新开发的应用程序工作不太正常。服务器接收到了各个商店传
在分析时，请尝试从数据包中找出线索。线索不一定能告诉你谁是“罪犯”，
在这个场景中，程序员开发了一个应用程序，用于跟踪多个商店的销售并
网络交换机支持端口镜像，所以我们用端口镜像功能噢探服务器的流量。我们
在IT界，
为了收集所需数据，
1.侦听线路
除了网络上的基本信息流量之外，我们完全不了解程序员开发的应用程序。
2.分析
在流量图的基础上，我们看见一个172.16.16.128与172.16.16.1210之间的
，开发者和系统管理员经常争吵。开发者总是将程序故障归答于槽
一它是所有商店通信的汇聚点。
我们可以在其中一个商店或中心办公室捕获数据包。
第8章基础的现实世界场景：179
---
## Page 195
Time
0.003
EOOO
1721616128
协议。
et:pcap-GrphArulyis
on504.Com
5515NAO
Rauest USERal
BZF
Reone130Cannr
RZIS X
Reguestootsuts
2555>211AK5
pons=227 Entet
WetPASSp
250CWD
RestST.
REPASY
BEAHEtIYPEA
Reentust.
172.16.16121
226Trans
图8-37流量图提供了FTP通信的快速视图
FTPRep
TCP
FTPRansUTFmoderaed
FTp:Raon230 Loggon
FTPRE
FTP.Requ
TCP255211Cx5052001ck5932W425
FTP Rep2Te Or
FTP.
寻
FTP
FTP
FTD
FTP
FTP:tesp
ETP:
FTP.ReqtL5T
Comnent
RqUeC.TYPEA
Reip
Hequet CwD/acup
PSS
UetUSER
etPWD
na331Pawcndquedore
BURECTYPEA
E片LEST
nse.2s7.cumnt dctory
10Ccd
0011
201ypt10
adi
---
## Page 196
17
26169039
Tere
store4829-03222010.csv文件0.如图8-39所示。
Clear按钮清除过滤器。
在过滤器对话框中。接着，如图8-38所示，编辑过滤器，将单词USER替换
和USER section右击Request Command：USER域，并选择Prepare a Filter
包5，这是最接近列表顶部的一个。然后展开Packet Details面板的FTP section
为此，我们首先需要选择一个出现有FTP请求命令的数据包。我们将选择数据
器中的数百个协议和选项，只要在Packet List面板中直接生成过滤器就行了。
上传数据到FTP服务器的FTPSTOR命令。最简单的方法是生成一个过滤器。
数据的位置。FTP连接和数据传输是由客户端发起的，因此我们应该寻找用于
1824
个STOR命令
成STORO
最后，选择Selected
查看从数据包64开始的捕获文件，我们看见这个数据包指定了传输
既然我们已经知道数据从哪里开始传输了，就单击PacketList面板上方的
172.10.16126
这将生成一个筛选含有FTPUSER请求命令的数据包的过滤器，并出现
这个捕获文件里到处都是FTP请求命令，因此我们不需要面对表达式生成
我们知道这里会有一些数据传输，因此我们用FTP的知识，定位开始传输
现在按回车键应用这个过滤器，你会看见捕获文件的数据包649里只有一
图8-38这个过滤器有助于识别数据从哪里开如传输
图8-39使用FTP传输CSV文件
17210.16.124
Destinution
Peotoceltnto
第8章基础的现实世界场景181
---
## Page 197
Stresm Content-
FollowTCP Stream
182Wireshark数据包分析实战（第2版）
ndeBsEtEnrece
26
66
260
Heip
215
10
51E
没有被损坏。
在TCP流中，如图8-40所示
64中显示的文件名，如图8-41所示。然后单击Save。
eation(19832byte)
图8-40TCP流显示了传输的数据
Fle Out This Stream
Close
---
## Page 198
致。MD5哈希值应该是一样的，如图8-42所示。
出错了。
文件从商店传输到收集服务器时是完整的，所以肯定是应用程序处理文件时
3.学到的知识
比较完文件后，我们可以证明网络并不是应用程序数据库出错的原因。
图8-42原始文件和提取文件的MD5哈希值相等
Browseforotherfoldes
Savtinfolden
Name
Wiresharkc Save Follow Stream As
MDS
ECDAAD703ACED7B0CSEBCE44200D5799
Ytons
HashCompaon
SHA-I
D5
Hame
图8-41将数据流保存为原始文件名
HohT/
Local Dik(C)
FD38F576
Hash Vale
store829-03222010.c
Corpaealle
第8章基础的现实世界场景183
SAME
---
## Page 199
小结
可能不会遇到跟这里完全相同的场景，但本章讨论的分析技术应该能给你一些
障。通过分析常见协议，我们可以及时查出并解决网络问题。你在现实网络中
有益的启发。
在本章，我们讲述了几个基本场景，数据包分析使我们更好地理解通信故
---
## Page 200
注意
会有非常大的进步
心
真的很慢。你将在本章中学到这些技巧。
网络的问题。
慢的计算机和服务。但是人们抱怨网络缓慢，并不意味着就是
在开始处理网络缓慢的问题之前，你首先要确定网络是否
作为一名网络管理员，你将花费很多时间用于修复运行缓
让网络不再卡
第
---
## Page 201
9.1.1
TCP的错误恢复特性
TCP重传
额外的流量（比如ICMP）
端点所花时间很少时，就说通信是低时延的。相反，当数据包在来源和目的地
来源到达目的地并返回来源）。当设备间通信很快，并且数据包从一端点到另一
（以及工作）的网络管理员们的头号敌人。
间传输要花费大量时间时，就说通信是高时延的。高时延是所有珍视自己声誉
抵达（或根本没有接收到）时，TCP是如何响应的。
丢失。
延迟可以被测量为单程延迟（从单个来源到一个目的地）或往返延迟（从
在第6章中，我们讨论了TCP如何使用序号和确认号保证可靠地传递数据
成真正的RTO。
这个计时器负责
以形
---
## Page 202
据包是否丢失。图9-1阐述了TCP重传过程。
面板中列出的重传例子。
个数据包。
系统中都是可配置的。
最多重传5次。大部分Linux主机则默认最多重传15次。这个选项在两个操作
持续到收到一个ACK数据包，或者发送方达到配置的最大重传次数为止。
还是没有收到ACK，RTO值将翻倍。每次重传，RTO值都将翻倍，这个过程会
限值之前一直没有接收到ACK数据包，那将发生另一次重传。如果下一次重传
假设原来的数据包丢失了，并重传它。重传之后，RTO值翻倍：如果在到达极
发送主机
这是一个TCPPSH/ACK数据包O，包含648字节的数据，从10.3.30.1
最大重传次数取决于传输操作系统上的配置。默认情况下，Windows主机
一旦RTO值确定下来，重传定时器就被用于每个传输的数据包，以确定数
在正常情况下，你会期待发送第一个数据包之后，很快就能看到响应的TCP
要看TCP重传的例子，请打开tep_retransmissions.pcap文件，它包含了6
当数据包被发送出去，但接收方没有发送TCPACK数据包时，传输主机就
第一个数据包如图9-2所示。
图9-1TCP重传过程的概念视图
重传5（RTOX16）
重传4（RTOX8）
重传3（RTOX4）
重传2（RTOX2）
没有响应=连接终止
敢传1（RTO）
数据
第9章让网络不再卡187
接收主机
---
## Page 203
100011C5451W
188
DaTA
20206000
9
Flags:
TT
Number
Wireshark数据包分析实战（第2版）
STr
1
FCE
ONIS
111037171CPTCP
否是重传数据包。
ana
06byte50nre（54
af
nce
r154061453
1048
5405497
1nf1ight:648]
00:20
1018104
808202
(dation disabled]
10.
Hghti648j
5406143
bitss.
图9-3PacketList面板中的重传
9-2
288227
10451043P5HAC5540547Ad71111Wn8760L464
20:
706 bytescaptu
含数据的简单TCP数据包
8
9-4
一个重传数据包
10.1
M.Z
6
641
---
## Page 204
9.1.2
注意
TCP重复确认和快速重传
部使用序号和确认号字段，以确保数据被可靠接收并以发送顺序重组。
们将查看TCP的重复确认特性，它被接收方用于检测数据包丢失并从中恢复。
所示，查看Packet List 面板的Time列。在这里，你将看到每一次重传后RTO
Checksum域，以及RTO值。为了显示每个数据包之间的时间间隔，如图9-5
数据包里。SEQ/ACKanalysis告诉我们这确实是一个重传，RTO值0.206s
初的数据包
完全一致。为了验证这个结论，在PacketBytes面板中比较这个重传数据包和最
握手过程中交换的最重要信息之一
它们称为“数据包”
值翻倍，时间呈指数增长。
是基于与数据包16的时间差值算出来的。
一些额外的信息。这个有用的信息是由Wireshark提供的，实际上并不包含在
当接收方收到乱序数据包时，就发送重复的TCPACK数据包。TCP在其头
在Packet Details面板中，注意到重传数据包的 SEQ/ACKAnalysis标题下有
举个例子，
传输设备使用TCP的重传特性来检测数据包丢失并从中恢复。下一步，我
查看剩下的数据包应该是类似的结果，唯一的不同在于IPidentification和
注意除了IPidentification和Checksum域之外，这个数据包与最初的数据包
“TCP数据包”的准确术语其实应该是“TCP分段”，但大多数人倾向于把
图9-5Time列显示了RTO值的增长
64.805000
30.600000
2.40000