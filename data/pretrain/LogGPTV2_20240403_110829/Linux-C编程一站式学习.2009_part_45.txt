包含.text段、.rodata段、
总之，
，栈空间是可能用尽的，并且比堆空间更容易用尽，在第3节“递归"讲过，
0x8048000
break
，x86平台的虚拟地址空间是0x0000 0000~0xffff，
00000000X0
 其中高地址的部分保存着进程的环境变量和命令行参数,
：我们讲过这个共享库是由内核虚拟出来的。0xbfac 5000-
，但是有几十层深的函数调用并且每层调用都有很多局部变
，但显然没有堆空间那么大的可供增长的余地，
后者是前者的符号链接。
这段空间称为堆（Heap）
，从堆空间的结束地址
，大致上前3GB（0x0000
表示Text 
低地址的部分保
：标有[vdso]的地
因为实际的
以后会讲
353
---
## Page 354
的PA。如下图所示。
Segment中的数据应该是不同的，
时运行着,
编译链接时写进/bin/bash这个可执行文件的，
4000,
该进程也占用了Ox0000 0000-0xbffff的地址空间，
的bash进程地址空间的布局差不多：
继续前面的实验，
面
不
另
第
码的破坏能力受
被保护起来，
机制实现的。
以读写，
另外一个进程的数据，
各进程的地址范围是否冲突。
会意外改写其它
进程中的
 每个进程都认为自
，Data Segment也是0x080f 4000-0x080f 9000，
，虚拟内存管理最主要的作用是让每个进程有独立的地址空间。
图 20.5.进程地址空间是独立的
b8006000-b80000
bff0e000-bff23000
b8022000-b8023000
b8021000-b8022000
b8020000-b8021000
5
5
8
080f9000-080fe000
0８0f4000-0８0f900０
30749
30697
S
而操作系统要求不同的页面具有不同的访问权限，
L
lib/tls/i686/cmov/libc.
1ib/tls/i686/cmov/1ibnss_files-2.8.90.so
7cfbo00
2
的同一
fb8000-
C
cf1000-b7cfb000 
2d7000-084f9000
ID
受到了限制，顶多使当前进程因段错误终止，
>
防止在用户模式下执行错误的指令意外改写内核数据。这样,
山山
一个VA被MMU映射到不同的PA，
例如，
pts/1
它进程的数据，
-b7fb9000
-b7cfd000
再打开-
，Text Segment被只读保护起来,
，这样使得任何一个进程由于执行错误指令或恶意代码导致的非法内存访问都
已
独占整个虚拟地址空间
00:00:00
00:00:00
个终端窗口，
rw-p
rw-p
r-xp
r-xp
r-xp
rw-p
rw-p
r-xp
TIME
“不会影响其它进程的运行，
相同的VA怎么会有不同的数据呢？因为它们被映射到不同
bffeb000
00000000
c-2.8.90.so
：0015a000 08:15
）00000000
b8020000
-2.8.90.s0
 00000000 08:15 581656
082d7000
080f9000
00000000
 00158000 08:15
-2.8.90.so
CMD
0001b000
0001a000
 ps
bash
看
两个进程都加载它。这两个进程在同一个系统中同
-下这个新的bash进程的地址空间，可以发现和先前
00:00
08:15
08:15
08:15
 08:15
00:00
00:00
08:15
，并且在某一
但是两个进程各自干各自的事情，
 这样链接器和加载器的实现会
，Text Segment也是0x0804 8000-0x080f
，防止被错误的指令意外改写，
581656
581656
581665
581665
 688142
和先前的进程一模一样，
0
565466
0
565466
0
o
从而保证整个系统的稳定性。1
一个进程中访问任何地址都不可能访问至
而不会影响整个系统的稳定性。
这是利用CPU模式和MMU的内存保护
5
/bin/bash 
[stack]
vdso]
/lib/ld-2.8.90.so
[heap]
 所谓独立的地址空间是指,
，执行错误指令或恶意代
会上
，因为这些地址是在
比较客
，显然Data
内核地址空间t
容易，
另一方
不必考
适
也
---
## Page 355
围。如下图所示。
却没有足够大的连续空闲内存，这时就可以分配多个不连续的物理页面而映射到连续的虚拟地址范
地址连续的一块内存。比如要用malloc分配一块很大的内存空间，虽然有足够多的空闲物理内存，
第三，
求libc的代码不管加载到什么地址都能正确执行。
在的物理页面，
现在我们也可以理解为什么共享库必须是位置无关代码了。比如1ibc，
个名称的由来了。
间
使用共享库可以大大节省内存。
写
另外，
相应的PA，因此不可能访问到其它进程的地址，也就没有可能意外改写其它进程的数据。
程都有自己的一套VA到PA的映射表，
的，
从图中还可以看到，
在/bin/bash这个可执行文件中。但即使如此,
，而libe的只读部分在物理内存中只需要存在一份，就可以被所有进程共享，这就是“共享库"这
当然，
，不会被改写，
 VA到PA的映射会给分配和释放内存带来方便，物理地址不连续的几块内存可以映射成虚拟
注意到两个进程的共享库加载地址并不相同，
图 20.6.不连续的PA可以映射为连续的VA
080f4000
08048000
080f4000
08048000
只有只读的部分是共享的，可读可写的部分不共享。
，但这些物理页面被映射到各进程的虚拟地址空间时却位于不同的地址，所以要
，因此操作系统会安排两个进程的Text Segment共享相同的物理页面。由于每个进
bash pid=30697
bash pid=29977
，两个进程都是bash进程，
系统中几乎所有的进程都映射1ibc到自己的进程地址空
PA
.Text Segment是一样的，
，也不影响两个进程共享相同物理页面中的共享
，共享库的加载地址是在运行时决定的，
RAM
不同的进程虽然共享libc所
并且Text Segment是只读
而不是
---
## Page 356
映射。
面。第二张图是换入，从空闲的物理页面中分配一个，
如下图所示。第一张图是换出，
系统中可分配的内存总量=物理内存的大小+交换设备的大小
out）
备，然后这个物理页面就认为是空闲的了
盘上临时保存虚拟内存页面的可能是-
的页面，
第四，
，虚拟内存管理使得这种情况下各进程仍然能够正常运行。
。如果进程要用到被换出的页面，
图20.7.换页
09402000
09401000
09400000
，这些页面的数据可以映射到物理页面，
一个系统如果同时运行着很多进程，
，将物理页面中的数据保存到磁盘，
，就从交换设备再加载回物理内存，这称为换入（Page 
一个磁盘分区
 可以重新分配给进程使用，
将一些不常用的物理页面中的数据临时保存到交换设
 为各进程分配的内存之和可能会大于实际可用的物理内
也可能是-
，将磁盘暂存的页面加载回内存，并建立地址
一个磁盘文件.
 并解除地址映射，
RAM
，这个过程称为换出（Page
称为交换设备
，释放物理页
备
---
## Page 357
4.共享库
一页
全国嵌入式人才培训基地
起始页
上一级
RAM
RA
第21章预处理
---
## Page 358
4.其它预处理特性
5.虚拟内存管理
3.条件预处理指示
2.宏定义
目录
第 21 章 预处理 请点评
1.预处理的步骤
2.4.宏展开的步骤
2.2.内联函数
2.1.函数式宏定义
贝
#运算符和可变参数
全国嵌入式人才培训基地
全国嵌入式人才培训基地
部分ⅡI. C语言本质
第21章预处理
起始页
1.预处理的步骤
358
下一页
---
## Page 359
7、把相邻的字符串连接起来。继续上面的例子，如果代码中有：
6、找出字符常量或字符串中的转义序列，用相应的字节来替换它，比如把\n替换成字节0x0a。
中允许使用的空白字符只有空格和Tab。
我们早在第2节“数组应用实例：统计随机数"就认识了预处理指示这个概念，
的源文件包含进来，并对源文件做以上1-4步预处理。如果遇到宏定义则做宏展开。
5、在Token中识别出预处理指示，
符常量、字符串、运算符和其它符号。继续上面的例子，两个源代码行被接成一个逻辑代码行，
成Token和空白字符，这时的Token称为预处理Token，
3、把注释（不管是单行注释还是多行注释）都替换成一个空格。
这种续行的写法要求\后面紧跟换行，中间不能有其它空白字符。
经过这个预处理步骤之后接成一行:
2、把用>字符续行的多行代码接成一行。例如：
后这个逻辑代码行被划分成Token和空白字符：#，define，空格，STR，空格，"hello，
1、把第2节“常量"提到过的三连符替换成相应的单字符。
现在我们全面了解一下C编译器做语法解析之前的预处理步骤：
1.预处理的步骤 请点评
中
4、
，Tab,Tab,"world"。
、经过以上两步之后去掉了-
上一页
也随着注释一起去掉了
printf(
#define STR "
 STR);
"hello,
一个逻辑代码行组成，
 剩下的代码行称为逻辑代码行。然后预处理器把逻辑代码行划分
一些换行,
，做相应的预处理动作，如果遇到#include预处理指示，则把相应
，有的换行在续行过程中去掉了，
全国嵌入式人才培训基地
第21章预处理
1.预处理的步骤
以#开头，后面跟若干个预处理Token，
'world"
包括标识符、整数常量、浮点数常量、
有的换行在多行注释之
，现在给出它的严格定
，在预处理指示
359
字
---
## Page 360
world",
符。继续上面的例子,
8、经过以上处理之后,
第 21章预处理
换行。
后把相邻的字符串连接起来，
空白字符，
页
而称为C Token了。
，在做语法解析时所有空白字符都已经丢掉了。
把-
把空白字符丢掉，
而把C代码写成多行则不需要用>续行，因为换行在C代码中只不过是-
个预处理指示写成多行要用\续行，
。这里丢掉的空白字符包括空格、换行、水平Tab、垂直Tab、分页
全国嵌入式人才培训基地
 把Token交给C编译器做语法解析，
起始页
一级
因为根据定义,
"hello,
，这时就不再是预处
一条预处理指示只
2.宏定义
一页
---
## Page 361
3、定义这种宏要格外小心，如果上面的定义写成#define MAx(a，b）（a>b?a:b）,
传参时要格外小心。
就像函数调用一样，
法，但没关系，我们只做预处理而不编译，不会检查程序是否符合C语法。
我们想看第二行的表达式展开成什么样，可以用gcc的-E选项或cpp命令，
以前我们用过的#define N 20或#define STR"hello，world"这种宏定义可以称为变量式宏定义
2.1.函数式宏定义请点评
2.宏定义请点评
义的外层括号也是不能省的，想一想为什么。
和cal1指令。所以，使用函数式宏定义编译生成的目标文件会比较大。
是代码中出现的每次调用编译生成的指令都相当于-
成传参指令和cal1指令。
数
2、
1、函数式宏定义的参数没有类型，
正的函数调用有什么不同：
常用。
用的语法规则本书并不涉及，但有关宏展开的语法规则本节却力图做全面讲解，因为它很重要也很
宏定义。看起来宏展开就是做个替换而已，
较大的项目都会用大量的宏定义来组织代码，
一样在代码中使用，称为函数式宏定义（Function-like Macro）。例如编辑一
、调用真正函数的代码和调用函数式宏定义的代码编译生成的指令不同。如果MAx是个真正的函
上一页
#
#
#
k
 cpp main.c
（(0x0):(0x0)(0x0)"
main.c
，把两个实参分别替换到宏定义中形参a和b的位置。注意这种函数式宏定义和真
而如果MAx是个函数式宏定义，
 宏定义名可以像变量一样在代码中使用。另外一种宏定义可以像函数调用
，预处理器只负责做形式上的替换，而不做参数类型检查，所以
全国嵌入式人才培训基地
第21章预处理
 其实里面有比较复杂的规则，
2.宏定义
。你可以看看/usr/include下面的头文件中用了多少个
一个函数体，而不是简单的几条传参指令
 这个宏定义本身倒不必编译生成指令，但
，代码中出现的每次调用也要编译生
 尽管这个C程序不合语
，C语言有很多复杂但不常
一个文件main.c：
 省去内层括号
下一
贝
---
## Page 362
这样宏展开之后，函数体的第二条语句不在i条件中。那么简单地用.．．}括起来组成一个语句
为什么要用do{..．}while(o)括起来呢？不括起来会有什么问题呢？
函数式宏定义经常写成这样的形式（取自内核代码include/linux/pm.h）：
数组，
这段代码从一个数组中找出最大的数，如果MAx是个真正的函数，
极端的例子，也是个很有意思的例子。
5、即使实参没有Side Effect，
4、调用函数时先求实参表达式的值再传给形参，如果实参表达式有Side Effect，那么这些Side 
数实现，
率
尽管函数式宏定义和真正的函数相比有很多缺点,
是多少？