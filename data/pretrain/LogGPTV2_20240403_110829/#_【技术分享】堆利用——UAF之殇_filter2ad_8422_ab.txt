### 内存布局和Use-After-Free (UAF) 漏洞分析

#### 内存布局
以下是内存中特定地址的数据布局：
```plaintext
0x604220: 0x4444444444444444 0x4444444444444444
0x604230: 0x4444444444444444 0x4444444444444444
0x604240: 0x4444444444444444 0x4444444444444444
0x604250: 0x4444444444444444 0x4444444444444444
0x604260: 0x4444444444444444 0x4444444444444444
0x604270: 0x4444444444444444 0x4444444444444444
0x604280: 0x0000000000000000 0x0000000000020d81
0x603190: 0x0000000000604130 0x00000000006041e0
```

我们已经成功创建了一支球队，接下来我们将通过利用Use-After-Free (UAF)漏洞来攻击它。

#### UAF漏洞分析
堆内存管理涉及内存的分配和释放。如果被释放的内存没有得到妥善管理，可能会导致信息泄露甚至任意代码执行。让我们来看看删除球员时发生了什么：

```assembly
/* index */
00401b9c  mov     eax, dword [rbp-0x1c]
/* player struct pointer */
00401b9f  mov     rax, qword [rax*8+0x603180] 
00401ba7  mov     qword [rbp-0x18], rax
00401bab  mov     eax, dword [rbp-0x1c]
/* Mitigate double-free, good shit */
00401bae  mov     qword [rax*8+0x603180], 0x0 
00401bba  mov     rax, qword [rbp-0x18]
/* player's name pointer */
00401bbe  mov     rax, qword [rax+0x10]      
00401bc2  mov     rdi, rax
00401bc5  call    free
/* player's chunk */
00401bca  mov     rax, qword [rbp-0x18]   
00401bce  mov     rdi, rax
00401bd1  call    free
```

首先释放的是球员的名字，然后是球员本身的chunk。需要注意的是，在显示球员信息之前，必须先选择该球员。然而，上述汇编代码并没有将全局变量`selected`清零。这是一个重要的逻辑错误，意味着即使球员已经被释放，我们仍然可以打印出球员的信息。

`show`函数的工作如下：
```assembly
/* Global variable holding a player pointer */
004020f2  mov     rax, qword [rel selected] 
004020f9  mov     rdi, rax
004020fc  call    show_player_func
```

`show`函数接收全局变量`selected`的内容作为参数，而该参数是一个球员结构体的指针。

#### 堆崩溃简介
在现代操作系统中，ASLR通常是启用的。为了获得shell，我们需要用`sh`作为参数调用`system()`。由于事先不知道`system()`的地址，我们需要先泄露某个libc函数的地址，从而计算出libc的基址，并根据偏移量找到`system()`的地址。这一切都要归功于Use-After-Free漏洞。

在深入讨论之前，我们先回顾一下malloc和free处理chunk的知识。

##### Malloc Chunk 结构
```c
struct malloc_chunk {
  INTERNAL_SIZE_T      mchunk_prev_size;  /* Size of previous chunk (if free).  */
  INTERNAL_SIZE_T      mchunk_size;       /* Size in bytes, including overhead. */
  struct malloc_chunk* fd;                /* double links -- used only if free. */
  struct malloc_chunk* bk;
  /* Only used for large blocks: pointer to next larger size.  */
  struct malloc_chunk* fd_nextsize; /* double links -- used only if free. */
  struct malloc_chunk* bk_nextsize;
};
```

##### Chunk 类型
- **Fast chunks**：表示小尺寸的chunk。
- **Small chunks**：表示中等尺寸的chunk。
- **Large chunks**：表示大尺寸的chunk。

当一个chunk被释放时，它会被保存到一个列表中。这些列表包括fast bin、small bin、unsorted bin和large bin。

- **Fast bins**：总共有10个fast bin，每个bin维护一个单链表，添加和删除操作发生在头部（LIFO）。两个相邻的空闲fast chunk不会被合并。
- **Small bins**：总共有62个small bin，每个bin维护一个双链表，插入操作发生在头部，删除操作发生在尾部（FIFO）。small chunk可能在unsorted bin结尾时被合并。
- **Large bins**：总共有63个large bin，每个bin维护一个双链表，插入和删除操作可以发生在链表的任何位置。large chunk可能在unsorted bin结尾时被合并。
- **Unsorted bin**：只有一个unsorted bin，用于充当缓冲层，以加快内存分配和释放请求的速度。
- **Top chunk**：作为arena的上边界chunk，是处理malloc请求时的最后操作。

#### 利用UAF漏洞
现在我们已经分配了4名球员，下面我们将泄露libc函数的地址。

```plaintext
(gdb) x/80gx 0x604000
0x604000: 0x0000000000000000 0x0000000000000021 <-- player 0 [in use]
0x604010: 0x0000000200000001 0x0000000400000003
0x604020: 0x0000000000604030 0x0000000000000071
0x604030: 0x4141414141414141 0x4141414141414141
0x604040: 0x4141414141414141 0x4141414141414141
0x604050: 0x4141414141414141 0x4141414141414141
0x604060: 0x4141414141414141 0x4141414141414141
0x604070: 0x4141414141414141 0x4141414141414141
0x604080: 0x4141414141414141 0x4141414141414141
0x604090: 0x0000000000000000 0x0000000000000021 <-- player 1 [in use]
0x6040a0: 0x0000000200000001 0x0000000400000003
0x6040b0: 0x00000000006040c0 0x0000000000000071
0x6040c0: 0x4242424242424242 0x4242424242424242
0x6040d0: 0x4242424242424242 0x4242424242424242
0x6040e0: 0x4242424242424242 0x4242424242424242
0x6040f0: 0x4242424242424242 0x4242424242424242
0x604100: 0x4242424242424242 0x4242424242424242
0x604110: 0x4242424242424242 0x4242424242424242
0x604120: 0x0000000000000000 0x0000000000000021 <-- player 2 [free]
0x604130: 0x0000000000000000 0x0000000400000003
0x604140: 0x0000000000604150 0x0000000000000091
0x604150: 0x00007ffff7dd37b8 0x00007ffff7dd37b8 
0x604160: 0x4343434343434343 0x4343434343434343
0x604170: 0x4343434343434343 0x4343434343434343
0x604180: 0x4343434343434343 0x4343434343434343
0x604190: 0x4343434343434343 0x4343434343434343
0x6041a0: 0x4343434343434343 0x4343434343434343
0x6041b0: 0x4343434343434343 0x4343434343434343
0x6041c0: 0x4343434343434343 0x4343434343434343
0x6041d0: 0x0000000000000090 0x0000000000000020 <-- player 3 [in use]
```

球员2已被释放，但其名字指针仍然指向相同的区域。我们可以提取球员2的信息：

```plaintext
0x604120: 0x0000000000000000 0x0000000000000021 <-- player 2 [free]
0x604130: 0x0000000000000000 0x0000000400000003
0x604140: 0x0000000000604150 0x0000000000000091
0x604150: 0x00007ffff7dd37b8 0x00007ffff7dd37b8
0x604160: 0x4343434343434343 0x4343434343434343
0x604170: 0x4343434343434343 0x4343434343434343
0x604180: 0x4343434343434343 0x4343434343434343
0x604190: 0x4343434343434343 0x4343434343434343
0x6041a0: 0x4343434343434343 0x4343434343434343
0x6041b0: 0x4343434343434343 0x4343434343434343
0x6041c0: 0x4343434343434343 0x4343434343434343
0x6041d0: 0x0000000000000090 0x0000000000000020 <-- player 3 [in use]
```

通过这种方式，我们可以利用UAF漏洞进一步进行攻击。