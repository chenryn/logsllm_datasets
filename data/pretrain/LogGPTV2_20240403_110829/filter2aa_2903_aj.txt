Bootvis、TCP/IP View）都使用了该机制。我们将在第15章详细介绍事
件追踪机制及其应用。
1.5.6 转储文件
某些情况下，我们希望将发生问题时的系统状态像拍照片一样永久
保存下来，发送或带走后再进一步分析和调试，这就是转储文件
（dump file）的基本用途。理想情况下，转储文件是转储时目标程序运
行系统的一个快照，包含了当时内存中的所有信息，包括代码和各种数
据。但在实际情况下，考虑到转储文件过大时不但要占用大量的磁盘空
间，而且不便于发送和传递，因此转储文件通常分为小、中、大几种规
格，最小的通常称为mini dump。
Windows操作系统提供了为应用程序和整个系统产生转储文件的机
制，可以在不停止程序或系统运行的情况下产生转储文件。Linux系统
下的转储文件有个更好听的名字，叫作core文件或者core转储文件，这
个名字应该来源于20世纪50～70年代时流行的磁核内存技术。当时，大
块头的磁核存储器是计算机系统中不可或缺的主流内存设备，直到被
SRAM和DRAM这样的半导体存储产品所取代。
1.5.7 栈回溯
目前的主流CPU架构都是用栈来进行函数调用的，栈上记录了函数
的返回地址，因此通过递归式寻找放在栈上的函数返回地址，便可以追
溯出当前线程的函数调用序列，这便是栈回溯（stack backtrace）的基本
原理。通过栈回溯产生的函数调用信息称为call stack（函数调用栈）。
栈回溯是记录和探索程序执行踪迹的极佳方法，使用这种方法，可
以快速了解程序的运行轨迹，看其“从哪里来，向哪里去”。
因为从栈上得到的只是函数返回地址（数值），不是函数名称，所
以为了便于理解，可以利用调试符号（debug symbol）文件将返回地址
翻译成函数名。大多数编译器都支持在编译时生成调试符号。微软的调
试符号服务器包含了多个Windows版本的系统文件的调试符号。我们将
在本书后续分卷深入讨论调试符号。
大多数调试器都提供了栈回溯的功能，比如WinDBG的k命令和
GDB的bt命令，它们都是用来观察栈回溯信息的，某些非调试器工具也
可以记录和呈现栈回溯信息。
1.5.8 反汇编
所谓反汇编（disassemble），就是将目标代码（指令）翻译为汇编
代码。因为汇编代码与机器码有着简单的对应关系，所以反汇编是了解
程序目标代码的一种非常直接而且有效的方式。有时我们对高级语言的
某一条语句的执行结果百思不得其解，就可以看一下它所对应的汇编代
码，这时往往可以更快地发现问题的症结。以1.6.1节将介绍的bad_div
函数为例，看一下汇编指令，我们就可知道编译器是将C++中的除法操
作编译为无符号整除指令（DIV），而不是有符号整除指令（IDIV）。
这正是错误所在。
另外，反汇编的依赖性非常小，根据二进制的可执行文件就可以得
到汇编语言表示的程序。这也是反汇编的一大优点。
调试符号对于反汇编有着积极的意义，反汇编工具可以根据调试符
号得到函数名和变量名等信息，这样产生的汇编代码具有更好的可读
性。
大多数调试器提供了反汇编和跟踪汇编代码的能力。一些工具也提
供了反汇编功能，IDA（Interactive Disassembler）是其中非常著名的一
个。
1.5.9 观察和修改内存数据
观察被调试程序的数据是了解程序内部状态的一种直接方法。很多
调试器提供了观察和修改数据的功能，包括变量和程序的栈及堆等重要
数据结构。在调试符号的支持下，我们可以按照数据类型来显示结构化
的数据。
寄存器值代表了程序运行的瞬时状态。观察和修改寄存器的值也是
一种常见的调试技术。
1.5.10 控制被调试进程和线程
像WinDBG这样的调试器支持同时调试多个进程，每个进程又可以
包含多个线程。调试器提供了单独挂起和恢复某一个或多个线程的功
能，这对于调试多线程和分布式软件是很有帮助的。我们将在本书后续
分卷详细介绍控制进程和线程的方法。
1.6 错误与缺欠
软件缺欠是软件调试和测试过程的主要工作对象。现实中，人们经
常交替使用几个名词来称呼软件问题，比如error、bug、fault、failure和
defect。本节将介绍对这几个名词的一种常见区分方法，说明本书的用
法，并讨论有关的几个问题。
1.6.1 内因与表象
区分以上几个术语的一种方法是从内因和表面现象的角度来分析。
一般认为，failure（失败）是用来描述软件问题的可见部分，即外在的
表现和症状（symptom）。而error是导致这种表象的内因（root
cause）。fault是指由内因导致表象出现的那个错误状态。而bug和defect
是对软件错误和失败的通用说法，二者之间没有显著的差异，或许bug
一词更通俗和口语化，而defect（缺欠）一词正式一些。
以第一个登记到文档中的bug为例，那只飞蛾是error，计算机停止
工作是failure，70#继电器断路是fault。当不区分内因和表象时，便可以
模糊地说是Mark II中的一个缺欠或者bug。
进一步来说，一方面，一个错误（error）可能导致很多个失败
（failure），也就是所谓的多个问题是同样根源（same root cause）。另
一方面，如果没有满足特定的条件，那么“错误”是不会导致“失败”的，
或者说错误是在一定条件下才表现出来的，表现的形式可能有多种。
以下面的函数为例：
int bad_div(int n,unsigned int m)
{
   return n/m;
}
当这样调用它时：
printf("%d/%d=%d!\n",6,3,bad_div(6,3));
打印出的结果是正确的：
6/3=2!
但是当这样调用它时：
printf("%d/%d=%d!\n",-6,3,bad_div(-6,3));
打印出的结果却是错误的：
-6/3=1431655763!
当然，如果参数n为−10，m为2，那么结果也是错误的。其中的原
因为参数m是无符号整数，所以编译器在编译n/m时采用了无符号除法
指令（DIV），这相当于把参数n也假设为无符号整数。因此，当n为负
数时，实际上被当作了一个较大的正数来做除法，除后的商被返回。
对于这个例子，函数bad_div的代码存在错误，不应该将有符号整
数和无符号整数直接做除法。这个错误当两个参数都为正数6和3时不会
体现出来，但是当参数n为负数、m不等于1时可以体现出来，会导
致“失败”症状，特别的−6除以+3会得到结果1431655763。
在本书中，除非特别指出，我们通常用bug或软件缺欠（defect）来
描述软件调试所面对的软件问题。
1.6.2 谁的bug
在软件工程中，一个值得注意的问题是不要把bug轻易归咎于某一
个程序员。讨论bug时，不要使用“你的 bug”这样的说法，因为这样可能
是不公平的，容易伤害程序员的自尊心，不利于调动他们的积极性。
简单来说，测试过程中发现的与软件需求规约不一致的任何现象都
可以当作bug/defect报告出来。其中有些可能是因为代码中确实存在过
失而导致的，而有些可能是与需求定义和前期设计有关的。因此，把和
某个模块有关的bug都归咎于负责这个模块的程序员可能是不恰当的。
一种较好的方式是称呼“××模块的bug”，而不要说成是“××人的
bug”。这样，与这个模块有关的人员可以相互协作，共同努力，迅速将
其解决，这对于个人和整个团队都是有好处的。
 老雷评点  
在《周易》中，有一句关于语言之重要性的话，即“言行，
君子之枢机，枢机之发，荣辱之主也”。有时，一字之差就会让
人暴跳如雷，换一种说法则让人心悦诚服。在技术书中有此一
段，作者煞费苦心也。
1.6.3 bug的生命周期
图1-8描述了一个典型的软件bug从被发现到被消除所经历的主要过
程。其中不带格线的矩形框代表的是测试人员的活动，而带格线的矩形
框代表的是开发和调试人员的活动。
图1-8 bug的生命周期
当登记一个bug时，通常要为其指定如下属性。
严重程度。一般分为低、中、高、critical（关键）、
showstopper（观止）等。
状态。一般的做法是：新登记一般记录为new，指定了负责人后修
改为assigned，开发人员实现了解决方案等待测试验证时可以设置
为resolved，测试人员验证问题已经解决后改为closed，由于某种原
因此问题又重新出现后，那么可以设置为reopened。
环境。包括硬件平台（x86、x64、安腾等）、操作系统，等等。
bug被登录到系统（如Bugzilla）中后，它会被指派一个负责人，这
个负责人会先在自己的系统中重现问题，然后调试和定位问题的根源，
找到根源后，修正代码，并进行初步的测试，没有问题后将修正载入即
将发布给测试人员的下一个版本中，并将系统中的bug状态修改为
resolved。而后由测试人员进行测试和验证。如果经过一段时间的测试
证明问题确实解决了，那么就可以关闭这个问题。对于严重程度很高的
问题，可能需要通过团队会议讨论后才能关闭。
1.6.4 软件错误的开支曲线
我们把与一个软件错误直接相关的人力投入和物力投入称为此软件
错误的开支（cost）。
如果一个错误在设计或编码阶段就被发现和解决了，那么它所导致
的开支主要是设计者或开发者所用的时间。
如果一个错误是在发布给测试团队后由测试人员所发现的，那么其
开支便要包括测试过程的各种投入、测试团队和开发团队相互沟通所需
的人力和时间开销、重现问题和定位问题根源所需的投入、设计和实现
解决方案及重新验证解决方案的投入。
如果一个错误是在软件正式发布后才发现的，那么其导致的危害通
常会更大，可能的开支项目有处理客户投诉、远程支持、开发及发布补
丁程序、客户退货、产品召回、赔偿导致的其他损失等。
不难看出，软件错误被发现和纠正得越早，其开支就越小。如果在
开发阶段发现和得到纠正，那么就不需要测试阶段的开支了。如果等产
品都已经发布给最终用户才发现问题，那么其导致的开支会是以前的数
十倍乃至更多。Barry W. Boehm在《Software Engineering Economics》
一书中给出了在软件生命周期的不同阶段修正软件错误的相对成本（见
表1-1）。
表1-1 软件错误的相对开支
错误被检测和纠正的阶段
相对开支的中值
需求
2
设计
5
编码
10
开发测试（development test）
20
接受测试（acceptance test）
50
运行
150
图1-9是根据表1-1中的数据画出的曲线，其中横轴代表软件生命周
期的各个阶段（时间），纵轴代表发现和纠正软件错误的相对成本（中
值）。
图1-9 软件错误开支相对于软件生命周期各阶段的曲线
根据图1-9中的曲线，软件错误的开支是随着发现的时间呈指数形
式上升的，所以应该尽可能早地发现和纠正问题。要做到这一点，需要
软件团队中所有成员的共同努力，从一开始就注重程序的可测试性和可
调试性。我们将在本书后续分卷详细讨论可调试性和更多有关的问题。
1.7 重要性
从软件工程的角度来讲，软件调试是软件工程的一个重要部分，软
件调试出现在软件工程的各个阶段。从最初的可行性分析、原型验证到
开发和测试阶段，再到发布后的维护与支持，都需要软件调试技术。
定位和修正bug是几乎所有软件项目的重要问题，越临近发布，这
个问题的重要性越高！很多软件项目的延期是由于无法在原来的期限内
修正bug所造成的。为了解决这个问题，整个软件团队都应该重视软件
的可调试性，重视对软件调试风险的评估和预测，并预留时间。本节先
介绍软件调试与软件工程中其他活动的关系，然后介绍学习调试技术的
意义。
1.7.1 调试与编码的关系
调试与编码（coding）是软件开发中不同但联系密切的两个过程。
在软件的开发阶段，对于一个模块（一段代码）来说，它的编写者通常
也是它的调试者。或者说，一个程序员要负责调试他所编写的代码。这
样做有两个非常大的好处。
调试过程可以让程序员了解程序的实际执行过程，检验执行效果与
自己设计时的预想是否一致，如果不一致，那么很可能预示着代码
存在问题，应该引起重视。
调试过程可以让程序员更好地认识到提高代码可调试性和代码质量
的重要性，进而让他们自觉改进编码方式，合理添加可用来支持调