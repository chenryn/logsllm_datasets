to construct
causal models for Zipsplit and PINE. A related model
for Zipsplit is presented in Fig. 18, corresponding to the
“read n ﬁles and compress to an output ﬁle” behavior. Note
that it is context-free as there are two groups of nodes (from
the 4th to the 6th and from the 12th to the 16th) that have the
same number of repetition. The ﬁrst group is for reading the
meta information of the n input ﬁles and the second group is
for reading the contents of the ﬁles and write to an output ﬁle.
MCI matches the models over the audit log collected from
the attacker’s machine, and it accurately reveals the causal-
ity between the secret document and the outgoing message.
Fig. 19-(b) presents a causal graph generated by MCI. It shows
that the c1.zip and c2.zip are derived from secret.pdf, and they
are sent out via PINE. In contrast, Fig. 19-(a) shows a causal
graph generated by BEEP but it contains many false-positives
as BEEP was not able to identify such removed attachments
nor causal relations between inputs and outputs of Zipsplit.
We manually inspect the program to identify the root cause of
false-positives. It turns out that Zipsplit ﬁrst compresses
input ﬁles into a temporary ﬁle, then splits it into multiple
output ﬁles. Hence, BEEP considers the temporary ﬁle is
dependent on all input ﬁles, and the output ﬁles are dependent
on the temporary ﬁle. In other words, BEEP considers all
output ﬁles are dependent on all input ﬁles. Instead, MCI infers
precise causality between each input and output ﬁle via implicit
dependencies annotated in the model.
3) Long running real world applications: In the last exper-
iment, we evaluate MCI on large scale real world workloads. In
particular, we use 2 months of NASA HTTP server access logs
obtained from [41] as well as 3 months of our institution’s
HTTP server access logs (from Nov. 2015 to Jan. 2016).
To obtain audit
logs from the HTTP access logs, we
ﬁrst emulate the web server environment by crawling all the
contents of the original servers. Then, we create a script
which connects and accesses the web server according to the
access log so that the audit logging system on our server can
regenerate logs for our analysis.
TABLE V.
EVALUATION ON LONG RUNNING EXECUTIONS.
Access Log
NASA-HTTP [41]
Our institution
# of req. (unique)
3.4M (36K)
5.6M (4.2M)
Elapsed Time
19 hrs 41mins
40 hrs 13mins
FP / FN
3.9% / 0.2%
1.1% / 0.1%
Table V shows the result. First, our parser takes 19 hours
and 40 hours to parse the logs from [41] and our institution,
respectively. Considering the size of the logs, we argue that
our parser is reasonably scalable. For the accuracy test, we
have 3.9% and 1.2% false-positives for the two respective logs.
We analyze such cases and ﬁnd that the NASA-HTTP log
includes much more CGI requests than our institution’s log.
We ﬁnd that most of the false-positive cases are from those
CGI requests (e.g., PHP) that introduce noises. That is, some
of the CGI behaviors are similar to the server behaviors and
hence confuse our parser. We also have 0.2% and 0.1% false-
negative rates. We manually analyze such cases and ﬁnd out
that they are mainly caused by CGI requests and suspicious
requests embedding binary payloads, which crash the web-
server during the experiment. Overall, the result shows that
MCI is scalable to identify causality over large scale logs.
VI. RELATED WORK
Causality Tracking. There exists a line of work in tracking
causal dependences for system-level attack analysis [25], [16],
[24], [26], [29], [23]. BackTracker [25] and Taser [16] propose
backward and forward analysis techniques to identify the entry
point of an attack and to understand the damage happened
to the target system. Recently, a series of works [32], [37],
[36] have proposed to provide accurate and ﬁne-grained at-
tack analysis. Dynamic taint analysis techniques [42], [21],
[20] track information ﬂow between taint sources and taint
sinks. SME [12] detects information ﬂows between different
security levels by running a program multiple times. LDX [31]
proposes a dual execution based causality inference technique.
When a user executes a process, LDX automatically starts a
slave execution by mutating input sources. It identiﬁes causal
dependences between input source and outputs by comparing
the outputs from the original and slave executions.
13
Fig. 17. Causal graphs generated from BEEP and MCI for the camouﬂaged FTP server case.
VII. DISCUSSION
Kernel-level Attack. We trust audit logs collected at the victim
system. Most audit logging systems including Linux Audit and
Windows ETW collect and store audit logs at the kernel level,
and a kernel-level attack could disable the logging system or
tamper with the log. One possible solution is to integrate with
LPM-Hiﬁ [6] that provides stronger security guarantees.
Limitations by LDX [31]. In our off-line analysis, we leverage
LDX to construct causal models, hence,
the limitations in
LDX are also inherited by MCI. LDX doubles the resource
consumption such as memory, processor and disk storage in
order to run a slave execution along with original execution.
However, we argue that the limitations only apply to the off-
line analysis and do not apply the end-user.
Model Coverage. MCI relies on causal models generated by
training with typical workloads. If an audit log includes behav-
iors that cannot be composed by the models in the provided
workloads, MCI may not be able to infer causality precisely
and could cause false-positives/negatives. Also, the FPs and
FNs caused by missing models may cascade throughout the
remaining MCI’s parsing process. However,
the cascading
effect is mostly limited within a unit (e.g., each request in a
server program) because MCI nonetheless starts a new model
instance when it encounters an input syscall that matches with
the model. Moreover, we can detect matching failures due to
the incomplete models while MCI is parsing the audit log. For
instance, missing models often lead to causal graphs lacking
important I/O related system-objects (e.g., ﬁles/sockets), hence
they are a strong indicator. Then we can enhance the model
to resolve the situation by training with more workloads.
Furthermore, we can fall back to a conservative strategy to
assume unmatched events have inter-dependencies.
Although we mitigate the ambiguity problem (Sec. III-C2),
as some models may not have enough dependencies to segment
traces, ambiguity is still a challenge. We plan to investigate
using irrelevant events as delimiters to further partition the
trace and suppress ambiguity.
Signal and Exception Handler. Signals and exceptions can
be delivered to a predeﬁned handler at anytime, interrupting
a normal execution ﬂow. Unfortunately, it is possible that
system calls in the handler may affect our parser. However,
we observe that in practice our models are robust enough to
handle the additional system calls caused by such handlers.
This is because system calls invoked in a signal or exception
handler are generally distinctive from the system calls in our
causal models, hence our parser is able to ﬁlter them out.
Moreover, in many programs such as Lighttpd, handlers
functions often do not invoke any system call. In the future, we
Fig. 18.
(Context-free) Model from Zipsplit
Fig. 19. Causal graphs for the Zipsplit case.
These approaches have limitations, for instance, syscall-
based techniques suffer from imprecisions that cause false-
positives and false-negatives, unit-based techniques require
training or instrumentation on the end-user site, and dynamic
taint analysis techniques cause too much runtime overhead.
We discussed details of strengths and limitations of those
techniques in Section II and compare them with MCI.
Program Behavior Modeling. Constructing program models
that represent program’s internal structures (e.g., control ﬂow)
or behaviors (e.g., system call invocations) have been exten-
sively studied, especially in anomaly detection techniques [46],
[28], [14], [48], [50], [47]. Speciﬁcally,
they train benign
program executions to get models which are abstraction of
the program behavior. Then, they use various ways such as
DFA [28], FSA [46], [14], push-down automaton (PDA) [48],
hidden Markov models [50], and machine learning [47], [34].
However, their models are mostly control ﬂow models that
do not have dependency information. Having dependences
(acquired from LDX) in our models on one hand allows us
to use models in attack provenance investigation, on the other
hand poses a number of new technical challenges. Due to
the difﬁculty of static binary dependency analysis, generating
precise models using static analysis is highly challenging.
14
sendmailsendmailsendmailprocmailx.x.x.x:53935x.x.x.x:113n.n.n.n:53/var/mail/…/94368.5221pinebashfirefoxunix socket/tmp/.X11-unixy.y.y.y:80/…/places.sqlite../file1/home/…/proftpdproftpdz.z.z.z:31337/home/…/doc../file2...74.125.224.72:80...pinebashfirefoxy.y.y.y:80/home/…/proftpdproftpdz.z.z.z:31337/home/…/docsendmailsendmailsendmailprocmailx.x.x.x:53935x.x.x.x:113/var/mail/…/94368.5221(a) Graph generated from BEEP(b) Graph generated by MCIsβt∅sγrεsεt∅sβt∅sθwθsεwθrεwθnγnnsσ: stat(σ), tσ: time(σ), wσ: write(σ), rσ: read(σ), nσ: rename(σ), α: stdin, β: current dir, γ: output (compressed) files,  ε: input files, θ: temp fileLegendExplicitImplicitsαpinebashc1.zipc2.zipc3.zip/home/.../sent-mailsmtpdpostdrop/.../maildrop/17623.5743/dev/logZipsplit1.pdf2.pdfsecret.pdfpinebashc2.zip/home/.../sent-mailsmtpdpostdrop/.../maildrop/17623.5743Zipsplitsecret.pdf(a) Graph generated from BEEP(b) Graph generated by MCIc4.zipc1.zip[19] K. Jee, V. P. Kemerlis, A. D. Keromytis, and G. Portokalidis. Shad-
owreplica: Efﬁcient parallelization of dynamic data ﬂow tracking.
CCS’13.
[20] K. Jee, G. Portokalidis, V. P. Kemerlis, S. Ghosh, D. I. August, and A. D.
Keromytis. A general approach for effciently accelerating software-
based dynamicdata ﬂow tracking on commodity hardware. NSDI’12.
[21] V. P. Kemerlis, G. Portokalidis, K. Jee, and A. D. Keromytis.
libdft:
practical dynamic data ﬂow tracking for commodity systems. VEE’12.
[22] W. M. Khoo. Taintgrind. https://github. com/wmkhoo/taintgrind, 2017.
[23] D. Kim, Y. Kwon, W. N. Sumner, X. Zhang, and D. Xu. Dual execution
for on the ﬂy ﬁne grained execution comparison. ASPLOS’15.
[24] T. Kim, X. Wang, N. Zeldovich, and M. F. Kaashoek. Intrusion recovery
using selective re-execution. OSDI’10.
[25] S. T. King and P. M. Chen. Backtracking intrusions. SOSP’03.
[26] S. T. King, Z. M. Mao, D. G. Lucchetti, and P. M. Chen. Enriching
intrusion alerts through multi-host causality. NDSS’05.
[27] W. Koch. The gnu privacy guard. https://gnupg.org/, 2017.
[28] A. P. Kosoresow and S. A. Hofmeyr.
call traces. IEEE Softw., 14(5), Sept.
Intrusion detection via system
[29] S. Krishnan, K. Z. Snow, and F. Monrose. Trail of bytes: efﬁcient
support for forensic analysis. CCS’10.
[30] S. Kumar, S. Dharmapurikar, F. Yu, P. Crowley, and J. Turner. Al-
gorithms to accelerate multiple regular expressions matching for deep
packet inspection. SIGCOMM’06.
[31] Y. Kwon, D. Kim, W. N. Sumner, K. Kim, B. Saltaformaggio, X. Zhang,
and D. Xu. Ldx: Causality inference by lightweight dual execution.
ASPLOS’16.
[32] K. H. Lee, X. Zhang, and D. Xu. High accuracy attack provenance via
binary-based execution partition. NDSS’13.
[33] K. H. Lee, X. Zhang, and D. Xu. Loggc: garbage collecting audit log.
CCS’13.
[34] Z. Li and A. Oprea. Operational security log analytics for enterprise
breach detection. In SecDev’16.
[35] S. Ma, K. H. Lee, C. H. Kim, J. Rhee, X. Zhang, and D. Xu. Accurate,
low cost and instrumentation-free security audit logging for windows.
ACSAC’15.
[36] S. Ma, J. Zhai, F. Wang, K. H. Lee, X. Zhang, and D. Xu. MPI: Mul-
tiple Perspective Attack Investigation with Semantic Aware Execution
Partitioning. SEC’17.
[37] S. Ma, X. Zhang, and D. Xu. Protracer: Towards practical provenance
tracing by alternating between logging and tainting. NDSS’16.
[38] Microsoft. Event tracing for windows. https://msdn.microsoft.com/en-
[39]
us/library/windows/desktop/bb968803(v=vs.85).aspx, 2017.
J. Ming, D. Wu, G. Xiao, J. Wang, and P. Liu. Taintpipe: Pipelined
symbolic taint analysis. SEC’15.
[40] M. Muuss. Ping c program. http://ws.edu.isoc.org/materials/src/ping.c.
[41] NASA. Nasa-http - two months of http logs from the ksc-nasa www
server. http://ita.ee.lbl.gov/html/contrib/NASA-HTTP.html, 1995.
J. Newsome and D. X. Song. Dynamic taint analysis for automatic
detection, analysis, and signaturegeneration of exploits on commodity
software. NDSS’05.
[43] D. Ongaro and J. Ousterhout. In search of an understandable consensus
algorithm. ATC’14.
[44] V. Paxson. Bro: A system for detecting network intruders in real-time.
Comput. Netw., 31(23-24), Dec.
[45] M. Roesch. Snort. https://www.snort.org/, 2016.
[46] R. Sekar, M. Bendre, D. Dhurjati, and P. Bollineni. A fast automaton-
based method for detecting anomalous program behaviors. SP’01.
[47] X. Shu, D. Yao, and N. Ramakrishnan. Unearthing stealthy program
attacks buried in extremely long execution paths. CCS’15.
[48] D. Wagner and D. Dean. Intrusion detection via static analysis. SP’01.
[49] Willem. C implementation of the raft. https://github.com/willemt/raft.
[50] K. Xu, K. Tian, D. Yao, and B. G. Ryder. A sharper sense of self:
Probabilistic reasoning of program behaviors for anomaly detection with
context sensitivity. DSN’16.
[8] A. Cahalan. procps. http://procps.sourceforge.net/, 2009.
[9] N. Chomsky. Three models for the description of language.
Transactions on Information Theory, 2:113–124, September 1956.
IRE
[42]
[10] N. Chomsky. On certain formal properties of grammars. Information
and Control, 2:137–167, June 1959.
Transparent computing.
[11] DARPA.
transparent-computing, 2017.
https://www.darpa.mil/program/
plan to extend MCI to construct proper models for signal and
exception handlers. As such, we can identify handler models
from the audit log and extract them before we apply MCI’s
model parsing process.
VIII. CONCLUSION
We present MCI, a novel causality inference algorithm
that directly works on audit logs provided from commod-
ity systems. MCI does not require any special efforts (e.g.,
training, instrumentation, code annotation) or framework (e.g.,
enhanced logging, taint tracking) on the end-user. Our off-line
analysis precisely infers causality from a given system call
log by constructing causal models and identifying the models
in a given audit log. We implemented a prototype of MCI
and our evaluation results show that MCI is scalable to cope
with large scale log from long-running applications. We also
demonstrate that MCI can precisely identify causal relations
in realistic attack scenarios.
ACKNOWLEDGMENT
We thank the anonymous reviewers for their construc-
tive comments. This research was supported,
in part, by
DARPA under contract FA8650-15-C-7562, NSF under awards
1748764, 1409668, and 1320444, ONR under contracts
N000141410468 and N000141712947, and Sandia National
Lab under award 1701331, and Cisco Systems under an
unrestricted gift. Any opinions, ﬁndings, and conclusions in
this paper are those of the authors only and do not necessarily
reﬂect the views of our sponsors.
REFERENCES
[1]
Insider threat spotlight report, 2016. http://crowdresearchpartners.com/
wp-content/uploads/2016/09/Insider-Threat-Report-2016.pdf.
[2] Quarterly threat report. https://www.solutionary.com/threat-intelligence/
threat-reports/quarterly-threat-reports/sert-threat-report-q4-2016/.
proftpd-1.3.3c-backdoor. https://www.aldeid.com/wiki/Exploits/proftpd-
1.3.3c-backdoor, 2011.
[3]
[4] Trends from the years’s breaches and cyber attacks. https://www.ﬁreeye.
com/current-threats/annual-threat-report/mtrends.html, 2017.
[5] G. Altekar and I. Stoica. Odr: Output-deterministic replay for multicore
debugging. SOSP’09.
[6] A. Bates, D. Tian, K. R. B. Butler, and T. Moyer. Trustworthy whole-
system provenance for the linux kernel. In SEC’15.
[7] M. Braun. Gnupg vim plugin.
https://github.com/jamessan/vim-
gnupg/blob/master/plugin/gnupg.vim, 2017.
[12] D. Devriese and F. Piessens. Noninterference through secure multi-
execution. SP’10.
dtrace.org. Dtrace. http://dtrace.org/blogs/, 2017.
[13]
[14] H. H. Feng, O. M. Kolesnikov, P. Fogla, W. Lee, and W. Gong. Anomaly
detection using call stack information. In SP’03.
[15] M. R. Garey and D. S. Johnson. Computers and Intractability; A Guide
to the Theory of NP-Completeness. W. H. Freeman & Co.
[16] A. Goel, K. Po, K. Farhadi, Z. Li, and E. de Lara. The taser intrusion
recovery system. SOSP’05.
[17] S. Grubb. Redhat linux audit. https://people.redhat.com/sgrubb/audit/.
[18] P. Institute. 2016 cost of data breach study. https://app.clickdimensions.
com/blob/softchoicecom-anjf0/ﬁles/ponemon.pdf.
15