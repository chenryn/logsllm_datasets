loadable kernel module to extend the existing kernel allows
systems to be modiﬁed without rebuilding from source.
Minimizing Data Loss: Data loss occurs when hidden data
(unrevealed data at a high deniability level) is overwritten
because the ﬁle system is mounted at a lower level—an
unfortunate, but unavoidable characteristic of any deniable ﬁle
system. One strategy to prevent overwriting is to maintain a
global list of memory blocks that are free for writing (not in
use by any higher or lower levels); a strategy similar to this is
employed by Pang et al. [33]. Alone, this strategy undermines
plausible deniability: a single-view adversary learns which
blocks are in-use across the system, revealing if hidden levels
exist. The remedy in Pang is to create abandoned blocks,
or blocks that are falsely marked as in-use. This creates
plausible deniability, at the expense of permanently sacriﬁcing
capacity. Anderson et al. [9] prevent data loss in their system
through block replication, similarly suffering a signiﬁcant
overhead to prevent data loss. While the capacity of NAND
drives is increasing and prices decreasing, the cost-per-byte
for ﬂash memory is still almost double that of hard disk
devices, limiting the appeal of solutions with high storage
overheads. What’s more, storage devices that employ wear
leveling preclude ﬁle systems from modifying data in place
or at completely random locations. This entirely excludes data
recovery strategies based on random placement of replicas,
or recovering overwritten blocks from n-out-of-m threshold-
based error correction codes.
Wear Leveling: NAND ﬂash has a limit to the number of
times data can be written to a block before it fails. Many
devices, then, implement wear leveling, in which all writes
are systematically written to new locations, preventing some
blocks from failing far earlier than others. This has impli-
cations for both encrypting and deniable ﬁle systems: wear
leveling mechanisms may persist old versions of encrypted
data, providing an adversary with a timeline of changes made
to disk, and thus, an ability to differentiate between claimed
and actual disk activity. Wear leveling undermines any ﬁle
system whose security is predicated on the ability to overwrite
data. Any secure ﬁle system designed for ﬂash-based storage
should be secure and compatible with drives that either do or
do not manage their own wear leveling.
Easily Deployable: To have the broadest impact, a deniable
VI. DESIGN OVERVIEW
DEFY is designed as an extension to the YAFFS ﬁle
system, with security features inspired by WhisperYAFFS. We
chose YAFFS because it is designed to operate on raw NAND
ﬂash, handles wear leveling, is widely-deployed, and is open-
source. To YAFFS we add authenticated encryption, crypto-
graphic secure deletion, and support for multiple deniability
levels that are resistant to strong adversaries. A comparison of
DEFY’s features with existing work appears in Table I. The
following provides a high-level description of DEFY’s main
design features.
Deniability Levels: DEFY supports one or more deniability
levels, each associated with a level directory, and permits the
dynamic creation of levels. Each level directory exists under
the root directory of the ﬁle system. All ﬁles for a deniability
level are located below its level directory. Each deniability
level is associated with a unique name and cryptographic key,
derived from a user-provided password. The system maintains
no record of what levels exist in the system; it can only know
which levels are currently open. When a user reveals a level,
all lower levels are also revealed. This is a convenience, helps
to minimize the chance of overwriting (since only unrevealed
levels risk overwriting), and follows the conventions of previ-
ous work.
Assigning deniability to directories at the root level is
strategic and provides a number of advantages. Level direc-
tories allow for easy inheritance of deniability levels. Objects
created within a directory will, by default, inherit the level
of that directory, i.e. be correctly encrypted at the appro-
priate level. We believe this behavior to be quite natural,
following the tradition of other security semantics (e.g. ﬁle
system permissions), and frees users of the burden of assigning
deniability levels to individual ﬁles. Separating deniability
level namespaces through level directories, also forces users
to be more thoughtful, and perhaps, careful about how they
categorize the sensitivity of their data.
Authenticated Encryption: The two key challenges associ-
ated in implementing authenticated encryption in DEFY are:
(1) designing a ﬁle system that can accommodate the data
5
Input: Data Page (cid:104)d1, . . . , dm(cid:105) with page ID id, OOB
data doob, counter x, and per-level keys K(cid:96), M(cid:96)
1: ctr1 ← PAD-128(id||x||1)
2: c1, . . . , cm, coob ← AES-CTRctr1
3: σ ← HMAC-SHA256M(cid:96) (c1, ..., cm, coob)
4: ctr2 ← PAD-128(id||x||0)
5: x1, . . . , xm, xoob ← AES-CTRctr2
6: t ← σ ⊕ x1... ⊕ xm ⊕ xoob
Output: Tag t, Page (cid:104)x1, . . . , xm(cid:105) and OOB xoob
(d1, . . . , dm, doob)
(c1, ..., cm, coob)
K(cid:96)
σ
Input: Encrypted Page (cid:104)x1, . . . , xm(cid:105) with page ID id,
OOB data xoob, counter x, tag t, per-level keys K(cid:96), M(cid:96)
1: ctr2 ← PAD-128(id||x||0)
2: σ ← t ⊕ x1 ⊕ . . . ⊕ xm ⊕ xoob
3: c1, . . . , cm, coob ← AES-CTRctr2
4: σ(cid:48) ← HMAC-SHA256M(cid:96) (c1, . . . , cm, coob)
5: if σ(cid:48) (cid:54)= σ return ⊥
6: ctr1 ← PAD-128(id||x||1)
7: d1, . . . , dm, doob ← AES-CTRctr1
Output: Page (cid:104)d1, . . . , dm(cid:105), OOB doob
(x1, . . . , xm, xoob)
(c1, . . . , cm, coob)
K(cid:96)
σ
(a) AON Encryption.
(b) AON Decryption.
Fig. 1: Authenticated encryption/decryption for a page using the all-or-nothing transform in DEFY.
expansion that results from authentication and, (2) designing an
encryption scheme that is supportive of efﬁcient and granular
secure deletion. Here, we focus our discussion on the former,
leaving a discussion of the latter for the next section.
DEFY’s encryption scheme is presented in Figure 1. The
algorithm takes as input a data page, broken into m, 128-
bit messages (d1, . . . , dm), the OOB data (doob), a unique
page identiﬁer (id), a unique global counter (x), a per-level
encryption key (K(cid:96)) and a per-level MAC key (M(cid:96)). The
algorithm implements an encrypt-then-MAC scheme: ﬁrst en-
crypting the page and OOB data using AES in counter mode
(AES-CTR), then MACing the resulting ciphertext using a
SHA-based message authentication code (HMAC-SHA256).
An additional encryption using AES-CTR using the authen-
ticator as the key is performed to complete an all-or-nothing
transform (described later). A tag (t) is created by XOR-ing
the ciphertext blocks (x1, . . . , xm, xoob) with the authenticator
(σ). This small tag is not secret; rather, it is an expansion of
the encrypted data and is subject to the all-or-nothing property.
The encrypted page (x1, . . . , xm) is written to disk as data, the
encrypted OOB data (xoob) is written to the OOB area, and
the tag (t) is stored as metadata in the parent object.
The same counter and key pair should never be used for
encryption more than once. For the block cipher in counter
mode, we extract a unique counter value, padding this to
128-bits in length using some appropriate padding scheme
(PAD-128). This value is derived from the page’s physical
disk address (id) and a global sequence counter (x); both
are associated with a DEFY object and, by policy, are non-
repeatable in a ﬁle system. The encryption key and MAC key
are also distinct between levels.
We remark that other constructions for achieving all-or-
nothing encryption, leveraging other cryptographic modes and
algorithms, may provide better performance or a more elegant
design. For example, Steps 1–3 of Figure 1a may be combined
into a single call of OCB mode [39], which requires only
one pass over the data to be made and is fully parallelizable.
Our construction acts as proof-of-concept and an exemplar for
achieving our design goals.
Encryption-Based Deletion: The same AON transform that
provides authenticated encryption, also provides a means for
efﬁcient secure deletion. The original AON transform, due to
Rivest [38], is a cryptographic function that, given only a par-
tial output, reveals nothing about its input. No single message
of a ciphertext can be decrypted in isolation without decrypting
the entire ciphertext. The original intention of the transform
was to provide additional complexity to exhaustive search
attacks, by requiring an attacker to decrypt an entire message
for each key guess. AON has been proposed to make secure
an RSA padding scheme [11], to make efﬁcient smart-card
transactions [12], [13], [24], message authentication [19], and
threshold-type cryptosystems using symmetric primitives [8].
Our design implements an encryption-based secure deletion
scheme based on Peterson et al.’s AON technique for secure
deletion of versioned data [34]. The all-or-nothing transform
allows any subset of a ciphertext block to be deleted (e.g.
through overwriting) in order to delete the entire ciphertext;
without all ciphertext blocks, the page can never be decrypted.
When combined with authenticated encryption, the AON trans-
form creates a message expansion that is bound to the same
all-or-nothing property. This small expansion becomes the
tag and can be efﬁciently overwritten to securely delete the
corresponding page. Indeed, message expansion is fundamental
to our deletion model and the AON transform is a natural
construct for providing efﬁcient secure deletion for DEFY, as
it minimizes the amount of data needed to be overwritten,
does not complicate key management, and conforms to our
hierarchical deletion model.
Metadata for DEFY: Metadata in YAFFS have been re-
purposed to support authenticated encryption and secure dele-
tion. Every DEFY metadata object supports the storage of tags
for its child objects: data pages in the case of a ﬁle object,
or ﬁle objects in the case of a directory object. When a child
object is modiﬁed, the parent object is updated with a new tag,
overwriting the previous tag, securely deleting the old object.
As a result of storing a new tag, the parent object is modiﬁed.
Thus, creating, deleting or modifying an object in DEFY will
trigger a tag cascade for all directory objects in that object’s
path, up to the ﬁle system root. See Figure 2 for a simpliﬁed
overview of DEFY’s hierarchical metadata design.
Tags for the level directory are collocated in a tag storage
area (TSA), which is managed separately from the rest of
the ﬁle system. When the level tags are updated, they are
written to a new block, and the previous version is erased and
re-written with pseudo-random data. The approach of using
a specially-managed area of ﬂash storage to achieve secure
deletion is akin to the strategies proposed by Reardon et al.
6
read and write operations, both unbuffered and buffered. We
believe these characterize the most common and I/O-bound
operations for a ﬁle system.
With each test, IOZone performs an I/O operation on a
number of uniformly-sized ﬁles, up to some maximum size.
For example, when measuring the write performance of a
64KB sized ﬁle, IOZone attempts to write sixteen 4KB ﬁles,
eight 8KB ﬁles, and so on, up to one 64KB ﬁle. For each
benchmark, we average the throughputs across four runs.
Results, with standard deviations, are presented in Figure 6.
We ﬁnd that DEFY performs comparably with Whis-
perYAFFS, while both DEFY and WhisperYAFFS underper-
form when compared with YAFFS, ext3, and ext4. This is not
unexpected, due in large part to the additional computation
requirements necessary to support their cryptographic opera-
tions. It is notable that these results suggest our AON transform
comes at an expense similar to AES in XTS mode [20],
used by WhisperYAFFS. Further, we believe the additional
computational and I/O requirements for tag cascading have
little to no impact on normal ﬁle system operations.
We also ﬁnd that the number of deniability levels has little
effect on ﬁle system performance. We conﬁgured a DEFY
partition with three deniability levels and performed the same
IOZone benchmarks mounted under all three levels (i.e. one
level, two level, and all levels revealed). Figure 7 presents the
results. These ﬁndings demonstrate that performance in DEFY
is an artifact of IO irrespective of the number of revealed (or
unrevealed) levels. DEFY’s log-structured nature writes new
data to the head of the log, regardless from which level is per-
forming the write. Writing data from many levels concurrently
may cause a single level’s blocks to be fragmented across the
device, which could lead to poor sequential read performance
for rotating media. Indeed, poor sequential read performance
is a contributing factor to why log-structured ﬁles systems
has not been more widely adopted. However, the uniform
random access performance of solid state drives render data
non-contiguity largely irrelevant, allowing system engineer’s
to once again enjoy the manifold beneﬁts of a log structure
(e.g. implicit versioning, inherent consistency, and simpliﬁed
data structures).
X. DENIABLE FILESYSTEMS IN PRACTICE
We remark that the use of deniable ﬁle systems from social,
legal, and usability perspectives has not been well-explored
in the literature. In particular, all deniable ﬁle systems to
date employ user passwords for securing ﬁles at a certain
deniability level. This allows an adversary to undermine plau-
sible deniability at the cost of a password-guessing attack. In
our adversarial setting, some password protection mechanisms
can be successfully utilized (e.g., using password-based key
derivation functions to increase the cost of brute force attacks)
while others cannot. For example, although not needed, pass-
word salts for each level’s password, would need to be stored