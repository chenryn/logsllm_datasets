### Loadable Kernel Modules for Extending the Kernel

Loadable kernel modules (LKMs) enable the extension of an existing kernel, allowing systems to be modified without the need for a complete rebuild from source. This approach provides flexibility and modularity, making it easier to add, remove, or update functionalities.

### Minimizing Data Loss in Deniable File Systems

Data loss in deniable file systems occurs when hidden data (unrevealed data at a high deniability level) is overwritten because the file system is mounted at a lower level. This is an unfortunate but unavoidable characteristic of any deniable file system. One strategy to prevent overwriting is to maintain a global list of free memory blocks that are available for writing (not in use by any higher or lower levels). A similar approach is employed by Pang et al. [33]. However, this strategy alone undermines plausible deniability, as a single-view adversary can learn which blocks are in use across the system, revealing the existence of hidden levels. To address this, Pang et al. introduce abandoned blocks, or blocks that are falsely marked as in-use, creating plausible deniability at the expense of permanently sacrificing storage capacity.

Anderson et al. [9] prevent data loss through block replication, but this also incurs significant overhead. Despite the increasing capacity and decreasing prices of NAND drives, the cost-per-byte for flash memory remains almost double that of hard disk devices, limiting the appeal of solutions with high storage overheads. Additionally, storage devices that employ wear leveling preclude file systems from modifying data in place or at completely random locations, excluding data recovery strategies based on random placement of replicas or threshold-based error correction codes.

### Wear Leveling and Its Implications

NAND flash has a limited number of write cycles before a block fails. Many devices implement wear leveling, where writes are systematically distributed to new locations to prevent some blocks from failing earlier than others. This has implications for both encrypting and deniable file systems: wear leveling mechanisms may persist old versions of encrypted data, providing an adversary with a timeline of changes made to the disk. This can differentiate between claimed and actual disk activity, undermining the security of file systems that rely on overwriting data. Any secure file system designed for flash-based storage should be compatible with drives that either do or do not manage their own wear leveling.

### Easily Deployable Deniable File Systems

To have the broadest impact, a deniable file system must be easily deployable. DEFY is designed as an extension to the YAFFS file system, incorporating security features inspired by WhisperYAFFS. YAFFS was chosen because it operates on raw NAND flash, handles wear leveling, is widely deployed, and is open-source. DEFY adds authenticated encryption, cryptographic secure deletion, and support for multiple deniability levels resistant to strong adversaries. A comparison of DEFY’s features with existing work is provided in Table I. The following sections provide a high-level description of DEFY’s main design features.

### Deniability Levels in DEFY

DEFY supports one or more deniability levels, each associated with a level directory, and allows for the dynamic creation of levels. Each level directory exists under the root directory of the file system, and all files for a deniability level are located below its level directory. Each deniability level is associated with a unique name and cryptographic key, derived from a user-provided password. The system maintains no record of what levels exist; it only knows which levels are currently open. When a user reveals a level, all lower levels are also revealed, minimizing the chance of overwriting and following the conventions of previous work.

Assigning deniability to directories at the root level is strategic and provides several advantages. Level directories allow for easy inheritance of deniability levels. Objects created within a directory will, by default, inherit the level of that directory, ensuring they are correctly encrypted at the appropriate level. This behavior is natural, following the tradition of other security semantics (e.g., file system permissions), and frees users from the burden of assigning deniability levels to individual files. Separating deniability level namespaces through level directories also encourages users to be more thoughtful and careful about categorizing the sensitivity of their data.

### Authenticated Encryption in DEFY

The two key challenges in implementing authenticated encryption in DEFY are:
1. Designing a file system that can accommodate the data expansion resulting from authentication.
2. Designing an encryption scheme that supports efficient and granular secure deletion.

DEFY’s encryption scheme is presented in Figure 1. The algorithm takes as input a data page, broken into m, 128-bit messages (d1, ..., dm), out-of-band (OOB) data (doob), a unique page identifier (id), a unique global counter (x), a per-level encryption key (K(cid:96)), and a per-level MAC key (M(cid:96)). The algorithm implements an encrypt-then-MAC scheme: first encrypting the page and OOB data using AES in counter mode (AES-CTR), then MACing the resulting ciphertext using a SHA-based message authentication code (HMAC-SHA256). An additional encryption using AES-CTR with the authenticator as the key completes an all-or-nothing transform (AON). A tag (t) is created by XOR-ing the ciphertext blocks (x1, ..., xm, xoob) with the authenticator (σ). This small tag is not secret; it is an expansion of the encrypted data and is subject to the AON property.

The encrypted page (x1, ..., xm) is written to disk as data, the encrypted OOB data (xoob) is written to the OOB area, and the tag (t) is stored as metadata in the parent object. The same counter and key pair should never be used for encryption more than once. For the block cipher in counter mode, a unique counter value is extracted, padded to 128 bits using an appropriate padding scheme (PAD-128). This value is derived from the page’s physical disk address (id) and a global sequence counter (x), both non-repeatable in the file system. The encryption key and MAC key are distinct between levels.

Other constructions for achieving AON, leveraging different cryptographic modes and algorithms, may provide better performance or a more elegant design. For example, Steps 1–3 of Figure 1a could be combined into a single call of OCB mode [39], which requires only one pass over the data and is fully parallelizable. Our construction serves as a proof-of-concept and exemplar for achieving our design goals.

### Encryption-Based Deletion

The AON transform that provides authenticated encryption also enables efficient secure deletion. The original AON transform, due to Rivest [38], ensures that given only a partial output, nothing about the input is revealed. No single message of a ciphertext can be decrypted in isolation without decrypting the entire ciphertext. The AON transform allows any subset of a ciphertext block to be deleted (e.g., through overwriting) to delete the entire ciphertext. When combined with authenticated encryption, the AON transform creates a message expansion bound to the same AON property. This small expansion becomes the tag and can be efficiently overwritten to securely delete the corresponding page. Message expansion is fundamental to our deletion model, and the AON transform is a natural construct for providing efficient secure deletion in DEFY, minimizing the amount of data needed to be overwritten, simplifying key management, and conforming to our hierarchical deletion model.

### Metadata for DEFY

Metadata in YAFFS have been repurposed to support authenticated encryption and secure deletion. Every DEFY metadata object supports the storage of tags for its child objects: data pages in the case of a file object, or file objects in the case of a directory object. When a child object is modified, the parent object is updated with a new tag, overwriting the previous tag and securely deleting the old object. As a result, the parent object is modified, triggering a tag cascade for all directory objects in that object’s path up to the file system root. Tags for the level directory are collocated in a tag storage area (TSA), managed separately from the rest of the file system. When the level tags are updated, they are written to a new block, and the previous version is erased and rewritten with pseudo-random data. This approach is akin to the strategies proposed by Reardon et al.

### Performance Evaluation

Performance evaluation of DEFY was conducted using IOZone, a benchmark tool that measures read and write operations, both unbuffered and buffered. These tests characterize the most common and I/O-bound operations for a file system. For each test, IOZone performs an I/O operation on a number of uniformly-sized files, up to a maximum size. For example, when measuring the write performance of a 64KB file, IOZone attempts to write sixteen 4KB files, eight 8KB files, and so on, up to one 64KB file. For each benchmark, we average the throughputs across four runs. Results, with standard deviations, are presented in Figure 6.

We find that DEFY performs comparably with WhisperYAFFS, while both DEFY and WhisperYAFFS underperform compared to YAFFS, ext3, and ext4. This is expected due to the additional computational requirements for supporting cryptographic operations. The results suggest that our AON transform comes at a similar cost to AES in XTS mode [20], used by WhisperYAFFS. Further, the additional computational and I/O requirements for tag cascading have little to no impact on normal file system operations.

We also find that the number of deniability levels has little effect on file system performance. We configured a DEFY partition with three deniability levels and performed the same IOZone benchmarks mounted under all three levels (i.e., one level, two levels, and all levels revealed). The results, presented in Figure 7, demonstrate that performance in DEFY is an artifact of I/O irrespective of the number of revealed (or unrevealed) levels. DEFY’s log-structured nature writes new data to the head of the log, regardless of the level performing the write. Writing data from many levels concurrently may cause a single level’s blocks to be fragmented across the device, leading to poor sequential read performance for rotating media. However, the uniform random access performance of solid-state drives renders data non-contiguity largely irrelevant, allowing system engineers to enjoy the benefits of a log structure (e.g., implicit versioning, inherent consistency, and simplified data structures).

### Deniable File Systems in Practice

The use of deniable file systems from social, legal, and usability perspectives has not been well-explored in the literature. All deniable file systems to date employ user passwords for securing files at a certain deniability level, allowing an adversary to undermine plausible deniability through a password-guessing attack. In our adversarial setting, some password protection mechanisms can be successfully utilized (e.g., using password-based key derivation functions to increase the cost of brute force attacks), while others cannot. For example, although not needed, password salts for each level’s password would need to be stored, adding complexity to the system.