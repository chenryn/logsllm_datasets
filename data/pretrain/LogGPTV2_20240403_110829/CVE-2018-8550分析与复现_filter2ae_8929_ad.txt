        else
          HeadCtxFound = 0;
        // 继续找下一个
        HeadCtx = HeadCtxFound->pctxNext;
      }
      if ( HeadCtx )
        HeadCtxFoundRet = HeadCtx + *NtCurrentTeb()->ReservedForOle;
      return HeadCtxFoundRet;
    }
    int __thiscall CPerContext::IsHandleValid(CPerContext *this)
    {
      CPerContext *that; // esi
      int result; // eax
      wchar_t Dest; // [esp+8h] [ebp-48h]
      that = this;
      StringCchPrintfW(
        &Dest,
        0x20u,
        L"OleDfRoot%X%08lX",
        this->CGlobalContextPtr->_luidMutexName.HighPart,
        this->CGlobalContextPtr->_luidMutexName.LowPart);
      // 在poc中使用NtCreateEvent使它验证成功
      result = CDfMutex::IsHandleValid(&that->_dmtx, &Dest);
      if ( !result )
        // 失败就返回0
        that->baseclass_CContext.ctxid = 0;
      return result;
    }
之后进入
CFileStream::Unmarshal,同样通过CContextList::_Find和方式通过设置和bits服务相同的pid从SDfMarshalPacket->CBasedGlobalFileStreamBaseObj找第一个CFileStream也就是poc中往共享内存0x7279
–
0x10写入的CFileStream,它的CFileStream->_hFile被赋值为0导致GetFileType返回-1导致验证失败(不影响程序运行),这个时候它的ctxid已经可以检测到为0,这时会进入poc中新建线程的第一个if语句断点.由于验证失败进入else,其中fstmOut->_CGlobalFileStreamPtr被赋值成SDfMarshalPacket->CBasedGlobalFileStreamBaseObj,fstmGlobal赋值成SDfMarshalPacket->CGlobalFileStreamPtr,之后它的fstmGlobal->_CGlobalFileStreamPtr->_pctxHead=0x7279被
CContextList::Add设置成fstmGlobal的相对地址,可以去判断读取SDfMarshalPacket->CBasedGlobalFileStreamBaseObj->_pctxHead已经不是0x7279,其实是fstmGlobal的相对地址.笔者发现一个小tips,fstmGlobal->_CGlobalFileStreamPtr也是可以在SDfMarshalPacket中读取到的,这样实际上求fstmGlobal->_CGlobalFileStreamPtr-SDfMarshalPacket->CBasedGlobalFileStreamBaseObj值就可以计算出bits进程的映射共享内存的映射基址也就是(NtCurrentTeb()->ReservedForOle->pvThreadBase-8)的值,从而实现读写bits进程的任意指定真实地址(非通过偏移内存计算)内存数据在共享内存区域,有兴趣的读者可以自行尝试后续研究.
    int __userpurge CFileStream::Unmarshal@(unsigned int *ppvRet@, CGlobalFileStream *fstmFromGlobal@, struct CGlobalFileStream *a3, void **a4, unsigned int a5)
    {
      CGlobalFileStream *fstmGlobal; // ebx
      unsigned int nowPid; // eax
      struct CContext *pCPerContextFound; // eax
      CFileStream *fstm; // esi
      CFileStream *fstmOut; // edi
      int hr; // eax
      int v11; // ebx
      CFileStream *CFileStreamAlloced; // eax
      unsigned int v14; // [esp+0h] [ebp-14h]
      struct IMalloc *v15; // [esp+4h] [ebp-10h]
      unsigned int *v16; // [esp+Ch] [ebp-8h]
      v16 = ppvRet;
      fstmGlobal = fstmFromGlobal;
      nowPid = GetCurrentProcessId();
      pCPerContextFound = CContextList::_Find(&fstmGlobal->_pctxHead, nowPid);
      if ( pCPerContextFound )
        // 就是poc的 CFileStream fstm=(CFileStream*)(0x7279 - 0x10 + (ULONG)directoryMappedAddressLocal + 8);
        fstm = &pCPerContextFound[-2];
      else
        fstm = 0;
      // 验证句柄,这里在poc中新建线程中检测到that->baseclass_CContext.ctxid=0
      if ( fstm && (fstmOut = (CFileStream::IsHandleValid(fstm) != 0 ? fstm : 0)) != 0 )
      {
        // 这部在原作者的hajctvtable中实现
        (fstmOut->_ILockBytesField.lpVtbl->AddRef)(fstmOut->_ILockBytesField.lpVtbl->AddRef, fstmOut);
        if ( !fstmGlobal->_awcPath[0] )
        {
    LABEL_9:
          *v16 = fstmOut;
          return 0;
        }
        hr = CFileStream::InitWorker(fstmOut, 0, 1u, 0);
      }
      else
      {
        // 创建新的CFileStream
        CFileStreamAlloced = CMallocBased::operator new(v14, v15);
        if ( CFileStreamAlloced )
          fstmOut = CFileStream::CFileStream(CFileStreamAlloced, fstmGlobal->_pMalloc);
        else
          fstmOut = 0;
        if ( !fstmOut )
          return -2147287032;
        //其中fstmGlobal->_CGlobalFileStreamPt->_pctxHead=0x7279被poc设置,fstmGlobal=CGlobalFileStreamPtr,实际上就可以度bits进程的任意内存数据,因为可以根据CGlobalFileStreamPtr计算出映射共享内存的基址CGlobalFileStreamPtr-olebae-8
        fstmOut->_CGlobalFileStreamPtr = fstmGlobal;
        ++fstmGlobal->_cReferences;
        // (CContextList)(fstmGlobal->_pctxHead(0x0))->_pctxHead(0x0)= &fstmOut->baseContext(0x10)-OleBase;
        // fstmOut=new_fs_offset = fsBase->baseclass_CContextList._pctxHead - 0x10;
        // 创建新的CFileStream链接到(CContextList)(fstmGlobal->_pctxHead(0x0))->_pctxHead(0x0)也就是原来的0x7279
        CContextList::Add(&fstmOut->_CGlobalFileStreamPtr->_pctxHead, &fstmOut->baseContext);
        // 这里之前就要设置_awcPath[0]不为NULL
        if ( !fstmGlobal->_awcPath[0] )
          goto LABEL_9;
        // 进入关键步骤
        hr = CFileStream::InitWorker(fstmOut, 0, 1u, 0);
      }
      v11 = hr;
      if ( hr >= 0 )
        goto LABEL_9;
      (fstmOut->_ILockBytesField.lpVtbl->Release)(fstmOut->_ILockBytesField.lpVtbl->Release, fstmOut);
      return v11;
    }
    int __thiscall CFileStream::IsHandleValid(CFileStream *this)
    {
      CFileStream *that; // edi
      signed int hr; // esi
      that = this;
      hr = 1;
      // 这里是hFile要预先设为0让他返回-1
      if ( this->_hFile != -1 && GetFileType(this->_hFile) != 1 )
      {
        hr = 0;
        // 这里在poc中新建线程中检测到that->baseclass_CContext.ctxid=0
        that->baseContext.ctxid = 0;
      }
      return hr;
    }
之后进入CFileStream::InitWorker,that->_CGlobalFileStreamPtr->_pctxHead=0x7279,(CFileStream*)(0x7279
– 0x10)是第一个找到的fstmFoundNew,由于的我在poc中预先设置了  
fstmFoundNew->baseContext.pctxNext = 0x7279这样pctxNext又链接到了它自己,这样可以构建 while (
fstmFoundNew )无限循环,产生一个时间差,让poc中的新建线程有时间读取最终复制的句柄.
    int __thiscall CFileStream::InitWorker(CFileStream *this, const unsigned __int16 *a2, unsigned int a3, void *a4)
    {
      CFileStream *that; // esi
      CGlobalFileStream *fstmGlobal; // eax
      unsigned int v6; // ebx
      int hrTemp; // eax
      signed int v8; // edi
      unsigned int v9; // ecx
      CGlobalFileStream *v10; // eax
      const unsigned __int16 *v12; // ecx
      CGlobalFileStream *v13; // eax
      unsigned int v14; // [esp+0h] [ebp-43Ch]
      const unsigned __int16 *v15; // [esp+4h] [ebp-438h]
      LPWSTR FilePart; // [esp+10h] [ebp-42Ch]
      WCHAR Buffer; // [esp+14h] [ebp-428h]
      WCHAR FileName; // [esp+224h] [ebp-218h]
      // this=new 0x7279
      that = this;
      FilePart = a4;
      fstmGlobal = this->_CGlobalFileStreamPtr;
      v6 = fstmGlobal->_df;
      // 这里之前就要设置hfile=-1,之后会被赋值
      if ( this->_hFile != -1 )
        return 0;
      // 这里之前就要设置_awcPath[0]不为NULL
      if ( fstmGlobal->_awcPath[0] )
      {
        // 进入复制句柄方法
        hrTemp = CFileStream::Init_DupFileHandle(this, 0);
      }
     ....
    }
    int __thiscall CFileStream::Init_DupFileHandle(CFileStream *this, unsigned int a2)
    {
      CFileStream *that; // eax
      HANDLE fakePid; // edi
      void *hPreDupedRef; // ecx
      int fstmFoundNewOffset; // ecx
      CFileStream *fstm; // esi
      CFileStream *fstmFoundNew; // esi
      void *hfileRef; // ebx
      HANDLE bitsPid; // eax
      CFileStream *_this; // [esp+8h] [ebp-4h]
      that = this;
      fakePid = 0;
      _this = this;
      hPreDupedRef = this->_hPreDuped;
      // hPreDuped之前也必需要是-1
      if ( hPreDupedRef != -1 )
      {
        that->_hPreDuped = -1;
        that->_hFile = hPreDupedRef;
        return 0;
      }
      // fstmFoundNewOffset是原CGlobalFileStreamPtr->_pctxHead=0x7279的CFileStream,不是是被替换后新创建的CFileStream,便于被查找next进入循环
      fstmFoundNewOffset = that->_CGlobalFileStreamPtr->_pctxHead;
      if ( fstmFoundNewOffset )
        fstm = (fstmFoundNewOffset + *NtCurrentTeb()->ReservedForOle);
      else
        fstm = 0;
      if ( fstm )
        // fstmOut=new_fs_offset  that->_CGlobalFileStreamPtr._pctxHead - 0x10;
        // 找到后再- 0x10
        fstmFoundNew = (fstm - 0x10);
      else
        fstmFoundNew = 0;
      if ( !fstmFoundNew )
        return -2147287034;
      do
      {
        hfileRef = fstmFoundNew->_hFile;
        if ( hfileRef == -1 )
        {
          // 如果hFile还是-1就继续找下一个
          if ( fstmFoundNew->_hPreDuped == -1 )
            goto LABEL_17;
          hfileRef = fstmFoundNew->_hPreDuped;
        }
        // 根据ctxid打开poc进程
        fakePid = OpenProcess(0x40u, 0, fstmFoundNew->baseContext.ctxid);
        if ( fakePid )
        {
          bitsPid = GetCurrentProcess();
          // 赋值poc进程的句柄至bits进程句柄写入CFileStream->_hFile
          if ( DuplicateHandle(fakePid, hfileRef, bitsPid, &_this->_hFile, 0, 0, 2u) )
            break;
          GetLastError();
          _this->_hFile = -1;
          CloseHandle(fakePid);
          fakePid = 0;
        }
        else
        {
          GetLastError();
        }
    LABEL_17:
        // 找Next的方式就是new_fs_offset = CFileStream->baseContext.pctxNext - 0x10,这里Next预先链接为自己,这样可以构建时间差,但poc现成有时间读取最终复制的句柄
        fstmFoundNew = CFileStream::GetNext(fstmFoundNew);
      }
      while ( fstmFoundNew );
      if ( !fstmFoundNew )
        return -2147287034;
      if ( fakePid )
        CloseHandle(fakePid);
      return 0;
    }
最终bits服务调用DuplicateHandle函数复制了poc中pWorkFileStream->_hFile设置的句柄,使用这个句柄后作为创建新进程的父句柄,最后成功弹出了一个System权限NotePad,如图:
> 引用
>
> [我的poc地址](https://gitee.com/cbwang505/CVE2018-8550Poc "poc")
>
> [原poc](https://www.exploit-db.com/exploits/45893 "poc")
>
> [P0地址](https://bugs.chromium.org/p/project-> zero/issues/detail?id=1648&can=1&q=dcom "poc")