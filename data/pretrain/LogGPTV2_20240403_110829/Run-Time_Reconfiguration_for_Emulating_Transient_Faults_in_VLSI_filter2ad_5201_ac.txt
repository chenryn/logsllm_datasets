read, modify and write again the configuration memory 
of  the  FPGA.  This  module  implements  the  different 
approaches  proposed  in  Section  4  to  emulate  the 
occurrence of transient faults. 
Proceedings of the 2006 International Conference on Dependable Systems and Networks (DSN’06) 
0-7695-2607-1/06 $20.00 © 2006 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 12:11:40 UTC from IEEE Xplore.  Restrictions apply. 
– Results analysis module: Observations taken from 
each experiment are compared to a Golden Run (fault 
free)  trace  to  classify  fault  effects  into:  Failure  (the 
traces present different outputs), Latent (the traces how 
the same outputs, but the system is in a different final 
state)  and  Silent  (the  traces  and  the  final  state  of  the 
system are identical). 
FADES  has  been  entirely  developed  in  Java  to 
assure  its  portability  across  platforms.  Furthermore,  it 
can make use of any board as long as it holds a Virtex 
FPGA  and  supports  the  Xilinx  HardWare  InterFace 
(XHWIF). 
This  tool  allows  the  user  to  emulate  any  of  the 
previously presented transient faults. It implements all 
the proposed approaches to perform the fault emulation 
and stores a trace of the execution for later analysis. 
Next section shows different experiments that have 
been carried out to validate that tool and some results 
that can be extracted from them. 
6. Experiments and results 
With  the  purpose  of  studying  the  feasibility  of  our 
approach and validating our tool, FADES has run side-
by-side with VFIT, a VHDL-based Fault Injection Tool 
[19],  to  carry  out  several  experiments.  VFIT  was 
successfully  used  in  the Fault  Injection  into  the  Time 
Triggered 
to 
experimentally  evaluate  the  concepts  of  TTA.  The 
following points present the experiments setup (target, 
workload, faultload) and the obtained results. 
Architecture 
European 
project 
6.1. Experimental setup 
(required  by  VFIT)  and 
First of all, the model of the system under analysis 
must  meet  two  requirements:  it  must  be  written  in 
VHDL 
it  must  be 
synthesisable,  i.e.  FPGA  implementable  (required  by 
FADES). We decided to use a not very complex model 
and workload, which will allow us to easily follow the 
execution  and  fault  injection  traces  to  locate  any 
possible  error  in  the  implementation  of  our  tool.  The 
selected  model  was  an  IP  (Intellectual  Property)  core 
that models the Intel 8051 microcontroller [20], and the 
Bubblesort  algorithm,  which  is  commonly  used  in 
HDL-based fault injection experiments, was selected as 
workload.  This  algorithm  took  1303  clock  cycles  to 
complete when running on the modelled system. 
Several different experiments were carried out, each 
one consisting in 3000 single transient fault injections. 
The  injection  instant  was  uniformly  distributed  along 
the workload duration, and the faults were confined to 
different locations in each experiment (registers, RAM 
memory, the arithmetic logic unit, the memory control 
and  the  finite  state  machine  module).  The  duration  of 
the injected faults was divided into three ranges: faults 
taking less than 1 clock cycle, faults lasting from 1 to 
10  clock  cycles,  and  those  taking  between  11  and  20 
clock cycles. 
The  analysis  of  the  results  obtained  from  these 
experiments  will allow  us to (i) estimate the speed-up 
our  tool  achieves  in  terms  of  execution  time  and  (ii) 
validate the implementation of the transient faults. 
6.2. Emulation time 
it 
is 
The  use  of  FPGAs  to  implement  the  model  of  the 
system allows for a very quick workload execution. On 
the other hand, FPGAs must be reconfigured to emulate 
the occurrence of a fault in the system, which involves 
transferring  a  certain  amount  of  information  to  and 
from  the  FPGA.  Since  we  are  talking  about  transient 
faults, 
another 
necessary 
reconfiguration  after  some 
the 
previously injected fault. Therefore, the fault injection 
process  introduces  some  temporal  overhead  in  the 
workload execution. 
to 
time 
perform 
remove 
times 
This overhead depends on the number of resources 
involved  and  how  many 
they  must  be 
reconfigured  to  emulate  the  fault.  Therefore,  the 
execution  time  for  each  experiment  differs  depending 
on  the  injected  fault.  Figure  10  shows  the  average 
emulation  time  obtained  for  the  different  experiments 
performed via FADES. 
to 
Figure 10. Mean emulation time of experiments 
performed via FADES 
The  emulation  of  bit-flips  took  an  average  of  916 
seconds  when  targeting  FFs  and  only  536  seconds 
when  targeting  memory  blocks.  The  emulation  of 
pulses  presents  a  particular  case when the duration  of 
the  fault is less than one clock cycle. In this case, the 
experiments  took  a  mean  of  755  seconds  while  they 
took  around  1520  seconds  in  every  other  case  (it  is 
necessary to perform two injections for this fault model 
implementation).  All  these  differences  are  due  to  the 
particular implementation of these faults when using a 
Virtex  FPGA  which  involves  transferring  a  different 
amount of information in each case to reconfigure the 
involved FPGA resources. 
Proceedings of the 2006 International Conference on Dependable Systems and Networks (DSN’06) 
0-7695-2607-1/06 $20.00 © 2006 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 12:11:40 UTC from IEEE Xplore.  Restrictions apply. 
the 
than 
logic 
transfer  of  very 
The  worst  case  execution  time  is  obtained  for  the 
emulation  of  the  delay  fault  model.  Although  the 
approach  for  injecting  the  delay  is  quite  simple,  and 
involves 
few  bits,  some 
experimental problems with the JBits package and the 
prototyping  board  driver,  lead  us  to  download  a  full 
configuration file and thus these huge execution times 
(2487  and  2778  seconds  for  delays  in  lines  related to 
sequential  and  combinational  logic  respectively).  The 
injection 
in 
combinational  logic  since  the  selected  model  presents 
fewer sequential injection points. 
in  sequential 
is  shorter 
In the case of indeterminations, it can be seen that as 
happened  with  the  bit-flip  and pulse  fault models, the 
injection  into  sequential  elements  takes  more  time 
(1065  seconds)  than  the  injection  into  combinational 
elements  (805  seconds).  These  particular  results  are 
obtained when keeping fixed the resulting logical value 
caused by the indetermination fault. Assuming that this 
logical  level  can  oscillate  during  the  fault  duration,  it 
must be randomly generate every clock cycle. It causes 
multiple  reconfigurations  along  the  duration  of  the 
fault,  which  greatly  increases  the  execution  time.  For 
instance, 
in 
sequential  logic  with  duration  ranging  from  10  to  20 
clock cycles lasts around 4605 seconds. 
the  emulation  of 
indeterminations 
With respect to VFIT, it makes use of the simulator 
commands  technique  [19],  resulting  in  very  similar 
execution times for any type and length of the studied 
fault  models.  The  average  execution  time  for  the 
experiments was 21600 seconds. 
Table 2 summarises all this information and shows 
the speed-up obtained by our tool. The time devoted to 
execute  the  experiments  with FADES is decreased, in 
nearly  every  case,  by  at  least  an  order  of  magnitude. 
The best results are obtained when emulating bit-flips 
into memory blocks and the worst speed-up is achieved 
when emulating delays in sequential logic. 
Table 2. Speed-up obtained when performing the 
experiments via FADES 
Fault model 
Target 
Speed-up
This  shows  that FADES can be used to  effectively 
accelerate the experiments to perform the validation of 
Mean emulation 
time of 3000 
faults (seconds) 
FADES  VFIT 
21600 
21600 
916 
536 
2487 
2778 
1065 
805 
1379 
21600 
21600 
21600 
21600 
21600 
23.60 
40.30 
8.68 
7.77 
20.28 
26.83 
15.66 
755/1520  21600 28.60/14.21
Bit-flip 
Pulse 
Delay 
FFs 
Memory blocks 
Combinational 
Sequential 
Combinational 
Sequential 
Combinational 
Indetermination 
Estimated mean time for emulating 
3000 faults (combining all models) 
a VLSI system. However, not only the results must be 
quickly  obtained  but  they  must  be  correct.  The  next 
point deals with this topic. 
6.3. Results validation 
A  first  experiment  was  performed  to  locate  those 
registers that were susceptible of causing a failure when 
executing  the  selected  workload:  3000  bit-flips  were 
randomly 
the  registers.  This 
experiment reported that only 14 registers (81 FFs out 
of  637)  were  eligible  for  being  targeted  by  transient 
faults. The same approach was applied to the injection 
of bit-flips into the RAM memory of the system. 
injected  among  all 
As shown in Figure 11, the occurrence of a bit-flip 
in the selected memory positions will very likely cause 
a failure in the system, while one out of two bit-flips in 
any of the targeted registers will have the same effect. 
Figure 11. Results from the bit-flip emulation 
Figure 12. Results from the delay and indetermination 
emulation into sequential logic 
Figure  12  presents  the  results  related  to  injecting 
delays  and  indeterminations  into  sequential  logic.  In 
both  cases,  the  percentage  of  failures  in  the  system 
increases with the duration of the faults. In the case of 
indeterminations,  short  fault  durations  have  similar, 
although  less  dangerous,  effects  than  bit-flips,  but  the 
percentage of failures greatly increases with the length 
of  the  faults.  Delays  are  less likely to  cause a failure, 
and there is a lesser increase of failures with the length 
of faults. This is due to the correct logic value stored in 
the  memory  cell  although  it  is  being  propagated  with 
some  delay  (which  may  or  may  not  affect  the  circuit 
driven by this cell). 
With  reference  to  combinational  logic  the  system 
under  study  was  implemented  using  5310  LUTs  that 
can  be  targeted  by  pulse,  delay  or  indetermination 
faults. That great number of  injection points led us to 
divide  the  experiments  according  to  the  targeted 
Proceedings of the 2006 International Conference on Dependable Systems and Networks (DSN’06) 
0-7695-2607-1/06 $20.00 © 2006 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 12:11:40 UTC from IEEE Xplore.  Restrictions apply. 
the  Arithmetic  Logic  Unit  (ALU), 
location: 
the 
Memory  Control  unit  (MEM)  and  the  Finite  State 
Machine unit (FSM). 
An  example  of  the  results  extracted  from  these 
experiments can be seen in Figures 13, 14 and 15. The 
percentage  of 
failures  when  emulating  pulses, 
indeterminations and delays in the combinational logic 
slowly  increases  with  the  duration  of  the  fault,  being 
the  FSM  the  most  sensitive  unit  in  terms  of  Failure 
rates.  However,  the  number  of  Latent  faults  greatly 
increases  when  injecting  pulses  into  the  MEM  unit, 
obtaining the lowest rates of Silent faults. 
faults: 
i)  signals 
indetermination 
in  charge  of 
controlling the finite state machines are treated in VFIT 
in  a  different  way  than  signals  just  implementing 
sequential  logic.  This  leads  FADES  to  obtain  higher 
failure  rates  when  injecting  indeterminations  into 
sequential  logic;  ii)  while  there  exist  131  signals 
eligible  for  this  injection  when  using  VFIT,  FADES 
can  choose  among  5283  LUTs 
injecting 
indeterminations  into  combinational  logic.  This  leads 
to a higher chance of logic masking resulting in lower 
failure rates. 
for 
Table 3. Comparison of the results obtained via 
FADES and VFIT 
Fault model 
Fault
location
Percentage of failures 
(Fault duration =  
< 1 / 1-10 / 11-20 clock cycles) 
FADES 
43.86 
80.95 
VFIT 
43.70 
81.76 
0.06 / 3.13 / 8.86  1.36 / 3.53 / 7.43 
5.7 / 18.6 / 31.67 
0 / 0.57 / 2.1 
- 
- 
29.53 / 45.9 / 61.4 18.87 /35.90 / 52.47
0.37 / 1.37 / 3.57  1.30 / 3.03 / 8.23 
Figure 13. Results from pulse emulation 