party Pi receives also a MAC key αi.
b) DISTRIBUTED SIGNING:
• Round 1 (Presigning):
Prep, to receive back PK. In addition, each
1) If no ECDSA tuples are currently stored, the parties send the command Tuple to F R
2) Each party Pi retrieves the shares of the next tuple (xi, (Mi,j, Kj,i)j(cid:54)=i, yi, di, zi).
3) Each party Pi sends xi · G and Mi,j · G to each Pj.
4) Upon receiving xj · G and Mj,i · G for each j (cid:54)= i, each party Pi checks that Mj,i · G = Kj,i · G + αi · (xj · G).
j=0 xj · G and sets r ← π(R). Otherwise, it
• Round 2 (Signing): Upon receiving a message m: each party Pi computes m(cid:48) ← H(m) and τi ← yi · m(cid:48) + r · di
If the equation holds for each j (cid:54)= i, then Pi computes R ←(cid:80)n−1
sends abort to the other parties and halts.
Prep obtaining N fresh tuples.
and broadcasts zi and τi.
1) Upon receiving τj and zj for all j (cid:54)= i, each party Pi computes τ ←(cid:80)n−1
s ← τ /z.
j=0 zj, and sets
2) Each party Pi run VerifyPK(m, (r, s)). If the result is 1, then Pi outputs (r, s). Otherwise, it outputs ⊥ and
j=0 τj and z ←(cid:80)n−1
• Output:
halts.
Fig. 4. The distributed ECDSA protocol
it
a) From the Ring R to the Vectorial Representation and
its Compression: In Section II, we observed how DPFs permit
to compress 2-party secret-sharings of large unit vectors.
Consider now the Module-LPN assumption. Each element of
the ring R can be represented as a polynomial of degree
at most N − 1. Therefore, we can convert
into a N-
dimensional vector over Fq. When we are actually dealing with
a monomial, the representation becomes a unit vector. Now,
the distribution HW t samples random t-sparse polynomials in
R, so we can represent its outputs with sums of t unit vectors.
b) Compressing the Terms xi and yi: When we look at
a ring ECDSA tuple, we observe that the shares xi and yi of
the i-th party are random elements in R. In order to compress
them, we rely on the Module-LPN assumption: for every r ∈
[c], each party Pi generates two t-sparse polynomials in R
i [l]·X ηr
ur
γr
i (X) :=
i [l]·X ωr
βr
vr
i (X) :=
(cid:88)
(cid:88)
i [l],
i [l]
l∈[t]
i [l])l∈[t] and the degree of
i [l])l∈[t] and (ηr
and
by sampling the non-zero coefﬁcients
the associated monomials
(γr
i [l])l∈[t]. During the evaluation, using a
(ωr
random oracle, the parties will obtain c − 1 random elements
a0, a1, . . . , ac−2 in R. The values of xi and yi will be
computed as
i [l])l∈[t]
l∈[t]
(βr
c−2(cid:88)
c−2(cid:88)
j=0
xi = (cid:104)a, ui(cid:105) =
yi = (cid:104)a, vi(cid:105) =
aj · uj
i + uc−1
i
,
aj · vj
i + vc−1
i
.
By the Rc-LPNt assumption, xi and yi are indistinguishable
from random.
j=0
Mi,j − Ki,j = αj · xi.
We recall that αj ∈ Fq, so we have that
(1)
c) Compressing the BeDOZa Style MACs: It remains to
explain how to derive the remaining parts of the ring ECDSA
tuple. We start by observing that, for every i (cid:54)= j, Mi,j and
Ki,j are random elements satisfying
αj · xi = αj · (cid:104)a, ui(cid:105) = (cid:104)a, αj · ui(cid:105).
i = (cid:102)M r
i,j +(cid:101)K r
Now, if we secret-share αj · ur
i,j between Pi and
Pj, we leak no additional information to the parties, while
obtaining
αj · xi = (cid:104)a, (cid:102)Mi,j +(cid:102)Ki,j(cid:105) = (cid:104)a, (cid:102)Mi,j(cid:105) + (cid:104)a,(cid:102)Ki,j(cid:105).
In other words, the values Mi,j := (cid:104)a, (cid:102)Mi,j(cid:105) and Ki,j =
−(cid:104)a,(cid:102)Ki,j(cid:105) satisfy (1). Finally, observe that, for every r ∈ [c],
αj · ur
i is a t-sparse polynomial, so we can compress a 2-party
secret-sharing between Pi and Pj using t DPF keys. In total,
this procedure requires c · t · n(n − 1) of them.
d) Compressing the Term di: Once we understood how
to obtain compressed BeDOZa style MACs,
is easy to
generalise the ideas for the terms (di)i∈[n]. As a matter of
fact, the following relation holds
it
(cid:88)
(cid:88)
skj · (cid:88)
di =
yi =
(ski · yi) +
(skj · yi).
(cid:88)
(cid:88)
i(cid:54)=j
i∈[n]
i∈[n]
j∈[n]
i∈[n]
Since skj belongs to Fq, we can apply the techniques described
in the previous paragraph to compress a secret-sharing of
skj · yi = d0
i,j between Pi and Pj, while leaking no
additional information to the parties. Speciﬁcally, we observe
that skj · yi = (cid:104)a, skj · vi(cid:105). Moreover, skj · vr
i (X) is a t-
sparse polynomial for every r ∈ [c], allowing us to compress
i,j + d1
Authorized licensed use limited to: Tsinghua University. Downloaded on August 07,2022 at 12:21:08 UTC from IEEE Xplore.  Restrictions apply. 
92562
Let R := Fq[X]/(cid:0)F (X)(cid:1), t and c be the parameters of the Module-LPN assumption. Denote the degree of F (X) by N.
The Pseudorandom Correlation Generator PCGECDSA
Gen. On input 1λ, do the following:
1) Sample a BeDOZa style MAC key αi
2) For every i ∈ [n], r ∈ [c], sample ωr
3) For every i, j ∈ [n] with i (cid:54)= j, r ∈ [c], compute
i , ηr
i
$← [N ]t and βr
i , γr
i
$← Ft
q.
$← Fq and ECDSA key shares ski
$← Fq, for every i ∈ [n].
(cid:17)
,
(cid:17) $← DSPFt
(cid:16)
(cid:17)
.
1λ, ηr
i , skj · γr
i
i,j , V r,1
V r,0
i,j
(cid:16)
i , αj · βr
4) For every i, j ∈ [n] with i (cid:54)= j, r, s ∈ [c], compute
i,j , U r,1
U r,0
1λ, ωr
i,j
i
C r,s,h
5) For every i ∈ [n], output the seed
i,j
(cid:18)
αi, ski,(cid:0)ωr
κi ←
(cid:16)
(cid:1)
r∈[c],
(cid:16)
N .Gen
(cid:17) $← DSPFt
(cid:17)
(cid:16)
r∈[c],(cid:0)ηr
(cid:1)
(cid:88)
i , βr
i
h∈[2]
i , γr
i
Eval. On input the seed κi, do the following:
1) For every r ∈ [c], deﬁne the two polynomials
i [l] · X ωr
βr
ur
i (X) :=
i [l],
(cid:16)
(cid:16)
(cid:17)
N .Gen
(cid:17)
$← DSPFt2
2N .Gen
1λ, ωr
i
(cid:1) ηs
j , βr
(cid:16)
j
i ⊗ γs
(cid:17)
,
j(cid:54)=i
r∈[c]
.
(cid:16)
(cid:19)
(cid:17)
j(cid:54)=i
r,s∈[c]
C r,s,0
i,j
, C r,s,1
j,i
i,j , U r,1
U r,0
j,i
i,j , V r,1
V r,0
j,i
,
j(cid:54)=i
r∈[c]
(cid:88)
l∈[t]
vr
i (X) :=
i [l] · X ηr
γr
i [l]
2) For every r ∈ [c], compute(cid:102)M r
i,j ← DSPFt
(cid:101)vr
i ← ski · vr
i +
N .FullEval(U r,0
i,j )
N .FullEval(V r,0
DSPFt
(cid:101)K r
j,i ← DSPFt
i,j ) + DSPFt
N .FullEval(U r,1
j,i )
N .FullEval(V r,1
j,i )
(cid:17)
(viewing outputs of FullEval as degree N − 1 polynomials over Fq)
3) For every r, s ∈ [c], compute
i ← ur
wr,s
i · vs
i +
DSPFt2
2N .FullEval(C r,s,0
i,j
) + DSPFt2
l∈[t]
(cid:16)
(cid:88)
j(cid:54)=i
(cid:16)
(cid:88)
j(cid:54)=i
4) Deﬁne the vectors of polynomials ui := (u0
, . . . , wc−1,1
5) For a random a ∈ Rc with ac−1 = 1 provided by the random oracle O, compute the ﬁnal shares
, . . . , wc−1,c−1
Let wi := (w0,0
, . . . , wc−1,0
), vi := (v0
, w0,1
).
i
i
i
i
i
i
i , . . . , uc−1
Mi,j ←(cid:68)
xi ← (cid:104)a, ui(cid:105) ,
a,(cid:102)Kj,i
in Fq[X]/(cid:0)F (X)(cid:1). Output (αi, ski, xi, (Mi,j, Kj,i)j(cid:54)=i, yi, zi, di).
a, (cid:102)Mi,j
yi ← (cid:104)a, vi(cid:105) ,
,
Kj,i ← −(cid:68)
(cid:69)
(cid:17)
2N .FullEval(C r,s,1
)
j,i
), similarly for (cid:102)Mi,j,(cid:102)Kj,i,(cid:101)vi.
zi ← (cid:104)a ⊗ a, wi(cid:105) ,
di ← (cid:104)a,(cid:101)vi(cid:105)
i
i , . . . , vc−1
(cid:69)
,
Fig. 5. The PCG for ring ECDSA tuples.
a two party secret-sharing between Pi and Pj using t DPF
keys. Once d0
i,j are available for every pair (i, j)
with i (cid:54)= j, each party Pi can set
i,j and d1
di ← ski · yi +
(d0
i,j + d1
j,i).
(cid:88)
j(cid:54)=i
In total, this procedure requires c · t · n(n − 1) DPF keys.
e) Compressing the Term zi: This is probably the most
complex part of the construction but the main ideas are the
same as before. We observe that the terms (zi)i∈[n] are random
values satisfying
(cid:88)
i∈[n]
zi =
(cid:88)
i∈[n]
xi · (cid:88)
j∈[n]
(cid:88)
i∈[n]
yj =
(xi · yi) +
(xi · yj).
(cid:88)
i(cid:54)=j
Again, our plan is to compress a secret-sharing of xi · yj
between Pi and Pj without leaking any additional information
to the parties. This time, however, the major issue is that both
xi and yj belong to the ring R. By extending our analysis, we
Authorized licensed use limited to: Tsinghua University. Downloaded on August 07,2022 at 12:21:08 UTC from IEEE Xplore.  Restrictions apply. 
102563
notice that
xi·yj =
(cid:16)(cid:88)
r∈[c]
(cid:17)·(cid:16)(cid:88)
(cid:17)
=
as·vs