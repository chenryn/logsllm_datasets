temperature attribute of a temperature sensor in the bedroom will
be updated to the same value. This is achieved with parallel state
transitions which change both the environment object and the de-
vice object. If no location coniguration is provided for a device,
we consider it as deployed in the common zone. Note that, our
main purpose for environment modeling is to model the implicit
chaining of a device’s command to another device’s event (e.g., tem-
perature is higher than 30). Thus, we model each environmental
variable with discrete values. A full modeling of environmental
variables, such as dealing with real-time continuous environments
with dynamic laws and time delays, and modeling correlations of
environmental variables are out of our scope.
Time Modeling. We support temporal behavior modeling by mod-
eling time as a monotonically increasing variable. Time advances
when there is no other transition available. Time-based triggers (e.g.,
Session 7A: Internet of ThingsCCS ’19, November 11–15, 2019, London, United Kingdom1443a timer at 8 am) are modeled as time events when the time variable
advances to the speciic values. For device actuation that can afect
environmental variables, we make state transitions of the environ-
ment objects to update their values as time advances. The updates
are made based on the efects caused by the actuation. Currently, we
support increase (i.e., increasing by a rate), decrease (i.e., decreasing
by a rate) and change to efects (i.e., directly changing to a value).
For example, if a heater increases the temperature with a rate r .
For each time unit that the switch attribute of the heater is łonž,
we make a state transition from  to
. If no rate r is provided, we use
1 as default. One optimization we use to reduce system states is to
update the values of time and environmental variables only with
the values used in the ruleset. For example, if there are two timers,
one at 8 am and the other at 9 am , in the rules, we will advance
time from 0 to 8 am then to 9 am instead of advancing the time by
one time unit in the transitions.
The device metadata contains the nec-
Device/Service Metadata.
essary information for device modeling and environment modeling.
For example, it deines the attributes and commands of a device
type, the efects on environmental variables (e.g., increasing tem-
perature) of a command, and state transitions of a device command
(i.e., what events will be generated by the execution of a com-
mand). Device/Service metadata can be constructed by analyzing
the documentation of an IoT platform or provided by the platform
developers or experts [28, 51]. For the IFTTT platform, we construct
the service metadata by crawling the web page of each service to
get what triggers and actions the service supports. We describe how
we extract state transitions of service actions using NLP techniques
in Section 6. We show examples of a device metadata and a service
metadata in Appendix C.1. The service metadata is generated with
the help of the NLP techniques in Section 6.
y ) if ϕ (−→
−→
x ,
x ) → t ′(−→
x ,
The model builder could generate
Intermediate Representation.
intermediate representation for diferent model checkers. Due to
its maturity and expressiveness, we use Maude [13], which is a lan-
guage and tool that supports the formal speciication and analysis of
concurrent systems in rewriting logic [62], as our checking engine.
With rewriting logic, an IoT system, which is a concurrent system,
can be naturally speciied as a rewrite theory R = (Σ, E, R) with
(Σ, E) an equational theory describing system states, and R rewrite
rules describing the system’s concurrent transitions. Rewrite rules
of the form crl [l] : t (−→
−→
y ) describe an l-
labeled transition in an open system from an instance of t to the
corresponding instance of t ′; the extra variables −→
y on the right-
hand side of the rule are fresh new variables that can represent
external nondeterminism (e.g., sensor probing); ϕ is a constraint
solvable by an SMT solver. In the generated intermediate repre-
sentation, devices, environmental variables and time are modeled
as objects; events and commands are modeled as messages; state
transitions and trigger-action rules are modeled as rewrite rules
(rl for rules and crl for conditional rules). Consider an example
of an IoT deployment consisting of a temperature sensor sensor
sensing the temperature from the environment and an air condi-
tioner ac, which collaborate to maintain the in-house temperature
at a desired setpoint. In this case, the state of the system can be
modeled as , ,
 and , where the
attributes time, temp, and setpoint are integers representing the
wall-clock, the temperature in the house, and the desired temper-
ature setpoint, respectively, and the attribute switch is a Boolean
referring to whether the air conditioner is turned on or of. Note that
time and temp are under control of the environment, while setpoint
and switch are under control of the system. The state transitions
can then be modeled by the following three rewrite rules:
crl [ turn - on ] :
( 
 ; ϕ )
→ ( 
 ; ϕ ∧ T > S ) if sat (ϕ ∧ T > S ) .
crl [ turn - off ] :
( 
 ; ϕ )
→ ( 
 ; ϕ ∧ T ≤ S ) if sat (ϕ ∧ T ≤ S ) .
rl [ time - a d v a n c e ] :
→    .
Rules [turn-on] and [turn-of] model the situations in which the
temperature sensed by the sensor exceeds the setpoint or not, and
thus the air conditioner is turned on or of. Rule [time-advance]
models the advance of wall-clock time (advancing the timer by one
time unit in this case) and the state transition of temperature and
the sensor. Note that the extra variable T ′ indicates the external
nondeterminism resulting from temperature changes in the house.
Also note that we embed in the system state the constraints (e.g.,
ϕ ∧ T > S) along the way during the system transitions, which will
be solved by the SMT solver in the symbolic reachability analysis.
5.3 Formal Analysis by Checking Engine
The checking engine takes the IR as input and uses rewriting modulo
SMT [75] to discover inter-rule vulnerabilities. Rewriting modulo
SMT is a symbolic technique combining the power of rewriting
modulo theories, SMT solving, and model checking. For each com-
bination of device states, we use it as an initial state to check the
vulnerable properties as deined in Section 5.2. Since our goal is to
ind existence of violations, we use the search command to search
a reachable state that reveals the vulnerabilities. As an example,
the following search command looks up to 1 solution and a search
depth 15 for a reachable state in which the air conditioner is turned
on, while the temperature sensed by the sensor from the house
does not exceed the current setpoint:
s e a r c h [1 ,15] (   ; true )
= >* (   ; B ': B o o l e a n )
such that sat (T ': I n t e g e r  []  on ( C2 : C o n f i g ) ) .
Note that above and on are two user-deined predicates on the
system states. The temporal operator → represents the notion of
łimplicationž, and □ ♢ the LTL notion of łalways eventuallyž.
6 IOT INFORMATION FLOW MODELING
As discussed in the prior section, iRuler requires an understanding
of how triggers and actions interact to detect inter-rule vulnera-
bilities. In this section, we describe our approach to the automatic
extraction of such lows from proprietary trigger-action platforms.
At irst glance, identifying such lows seems trivial. However, in
practice, identifying these links proves surprisingly diicult.
Following the methodology of [86] and
Preliminary Experiment:
[63], we scraped the descriptions of 674 services and 315,393 applets
from the IFTTT website. Recall that each trigger and action in an
applet represent an API deined by a third-party service (channel).
For example, the SmartThings service provides an action łLock a
SmartThings devicež and a trigger łIf a SmartThings device is turned
onž. The simplest way to model action-to-trigger lows within a
service is to conservatively assume that all outbound triggers de-
pend on all inbound actions. However, applying this naïve strategy
generates 6637 intra-service lows, many of which are spurious and
represent false dependencies. For example, in Figure 7, the łLockž
action of the SmartThings would not afect the łHumidity rises
abovež trigger; these are two independent attributes that can be ma-
nipulated through this service. Thus, while information low within
a rule (trigger-to-action) is deinitionally apparent, understanding
inter-rule dependencies (action-to-trigger) requires decomposition of
services into their underlying components so that true lows can be
identiied.
6.1 NLP-based Information Flow Analysis
Given the proprietary nature of trigger-action IoT platforms, our
options for analyzing the internal state of services are extremely
limited. As observed in prior work [81, 84, 86], analyzing text de-
scriptions of IoT components that appear on the platform websites
Semantic 
Analyzer
1. Semantic similarity 
score (word-vector 
embedding)
2. Semantic Relation 
Mining (Babelnet)
Training Set
Test Set
Unseen 
Dataset
 Pairwise Numeric 
Feature Extraction
Accuracy Analysis
Real world information 
flow graph
Trained Model
Figure 8: An overview of our NLP-based information low analysis
of trigger-action IoT platforms.
Dependency
Relation
Part of Speech
nsubj
det
dobj
punct
det
aux
compound:prt
compound
                This   Act ion   wil l    t urn   of f    t he   air   condit ioner   .
                      DET       NOUN    MODAL  VERB    PRT    DET   NOUN         NOUN        PUNCT
ROOT
Figure 9: An example dependency tree that encodes the grammati-
cal structure of an action description.
provides one means of overcoming this obstacle. We now present
an approach that leverages Natural Language Processing (NLP) in
the design of an information low analysis framework, an overview
of which is given in Figure 8. To eliminate the spurious lows and
to detect the true information lows, we pose this problem as a
supervised classiication problem. Our framework learns a function
to map an Action (A) and Trigger (T ) pair from a Service (S) to a
binary output specifying whether an information low exists from
A to T . As a irst step toward our goal, we need to encode each
⟨A,T ⟩ pair as a set of numeric features.
Syntactic Element Extraction. To simplify the analysis of un-
6.1.1
structured text, we irst perform Part-of-Speech (POS) tagging and
Dependency Parsing using the Stanford CoreNLP [12] library to pro-
duce a dependency tree for the description of each rule component.
An example dependency tree for an action description is shown
in Figure 9. The parser performs Dependency Parsing to identify
the root verb representing the main task of the rule component.
All other syntactic units are either directly or indirectly connected
to the root by dependency edges, which encode a grammatical re-
lation between a source node (governor) and a destination node
(dependent). While there are many dependency relationships, those
we use in our analysis are:
• Direct Object: The dependent of this relation with respect to the
root is the object that the main task is acted upon.
• Compounds: These relations are part of the root verb or direct
object of the task (e.g., łair conditionerž, łturn ofž).
• Modiiers: These relations encode words that modify the meaning
of a noun by specifying some additional quality, association, or
attribute (e.g., łnew subscriberž - adjective modiier to subscriber).
Session 7A: Internet of ThingsCCS ’19, November 11–15, 2019, London, United Kingdom1445Table 2: A summary of our feature vector, calculated as a compari-
son between the text descriptions of an action and trigger.
Feature
Verb Similarity
Object Similarity
Verb Synonym
Verb Hypernym
Verb Causation
Verb Entailment
Object Synonym
Object Hypernym
Object Meronym
Object Holonym
Object-Property
Match
Verb-Particle
Match
Type
Continuous
Continuous