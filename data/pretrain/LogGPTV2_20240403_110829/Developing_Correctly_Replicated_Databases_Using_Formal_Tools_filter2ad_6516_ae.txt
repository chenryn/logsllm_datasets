of each table, sending the rows in batches, and inserting
10
16B –+–
1KB –×–
6K
4K
2K
.
c
e
s
r
e
p
.
s
n
a
r
T
0
10
3
1
2
30
20
Seconds elapsed
40
(a)
)
s
(
e
m
T
i
1000
100
10
1
0.1
0.01
50
60
0.5s
0.4s
5 ∗ 102
2.4s
1.4s
9.1s
3.8s
69.6s
22.6s
5 ∗ 103
5 ∗ 104
5 ∗ 105
Database size (number of rows)
(b)
Figure 10. An execution with a crash of the primary (a) (1: crash detection in 10 sec, 2: group reconﬁguration and state transfer in 3.8
sec, 3: clients resume their execution) and the overhead of state transfer (b).
them in the corresponding table at the destination replica. We
consider rows of 16 bytes and 1 kilobyte with respectively
3 and 4 columns, and a number of rows varying from
500 to 500,000. For both row sizes, the batch size was
chosen such that
it would be close to 50 kilobytes in
serialized form. Our state transfer technique allows to do
state transfer with any JDBC-enabled database but is at
best one order of magnitude slower than what the network
can accomplish. In all experiments, row insertion speed
constitutes the bottleneck of state transfer.
With a TPC-C database conﬁgured with 1 warehouse, or
the equivalent of about 100MB of data, state transfer takes
54.5 seconds. In the case of TPC-C, serializing table rows
has a higher overhead compared to our micro-benchmark
because tables have many more columns (serialization over-
head is proportional to the number of table columns). As a
consequence, serializing the equivalent of 100MB of data
takes 77% of the time it takes to transfer a database of
500MB with rows of 4 columns (the state transfer time for
500,000 rows of 1KB in Fig. 10(b)).
V. Related Work
Our methodology resembles the one of seL4,
the ﬁrst
machine-veriﬁed operating system kernel [1]. Both our work
and seL4 start with an informal speciﬁcation. From the infor-
mal speciﬁcation, formal correctness properties are derived,
as well as a speciﬁcation of the system. In the case of
seL4, the formal correctness properties are speciﬁed in Is-
abelle/HOL [2], and the system speciﬁcation in Haskell [28].
For our work, we used Nuprl and EventML respectively.
In both cases, the system speciﬁcation is translated into
a speciﬁcation in the respective formal environment, and
a manual correctness proof is performed to show that the
speciﬁcation satisﬁes the desired correctness properties.
Our methodologies depart from there. For seL4,
the
executable code was handwritten in a subset of C and
has to be related to the speciﬁcation using a reﬁnement
mapping in Isabelle/HOL. Because EventML operates at a
different abstraction level than Haskell, we were able to
generate executable Nuprl code directly from the EventML
speciﬁcation and automatically prove the correspondence to
the LoE speciﬁcation. Also, exploiting Nuprl’s Inductive
Logical Form translator, we were able to prove correctness
of distributed system properties by induction on causal order.
Another similar approach is taken by the Formally Veri-
ﬁable Networking (FVN) project [29]. They use Network
Datalog (NDlog), a variant of Datalog [30],
to specify
routing protocols in a declarative fashion. In our system we
use EventML. An NDlog speciﬁcation can be translated into
axioms of PVS [31], and correctness proofs can be carried
out interactively. This corresponds to carrying out proofs at
the level of LoE. In FVN, it is also possible to translate PVS
axioms into NDlog. Within the P2 framework [32], the ND-
log speciﬁcation is compiled into a dataﬂow program, with
dataﬂow elements written in C++. In our work, we generate
GPM programs from EventML speciﬁcations. P2 has been
extended with cardinality abstractions [33]. This technique
allows formal reasoning on the effects of applications of
declarative rules directly.
EventML has strong similarities to Orc [34], [35], a pro-
gramming language for structured concurrent programming.
Like EventML, Orc has a small set of combinators that
perform basic services, and Orc expressions are similar
to our event classes. Although there are formal semantics
of Orc, to the best of our knowledge none of them are
formalized in a theorem prover.
There are a variety of other languages to specify dis-
tributed systems concisely. Mace [36] speciﬁcations can
be model-checked and translated into C++ code. MOM-
MIE [37] speciﬁcations can be translated to runnable code
as well as to a TLA+ speciﬁcation, to be veriﬁed. Nomadic
Pict [38] is a language designed for programming mobile
agents, with a precise semantics that allows reasoning about
correctness. In none of these cases is there a veriﬁable link
between the correctness of the speciﬁcation and that of the
generated code that is executed.
VI. Conclusion
We presented our methodology to build highly-available
databases using new formal tools that allow the generation
11
council
benchmark
c
processing
performance
[18] B. Charron-Bost and A. Schiper, “The Heard-Of model: computing in
distributed systems with benign failures,” Distributed Computing, vol. 22,
no. 1, pp. 49–71, 2009.
[19] M. Gordon, R. Milner, and C. Wadsworth, Edinburgh LCF: a mech-
anised logic of computation, ser. LNCS. Springer-Verlag, 1979, vol. 78.
[20] R. V. Renesse, “Paxos made moderately complex,” Cornell University,
Tech. Rep., 2011.
[21] X. D´efago, A. Schiper, and P. Urb´an, “Total order broadcast and
multicast algorithms: Taxonomy and survey,” ACM Comput. Surv., vol. 36,
no. 4, pp. 372–421, 2004.
[22] P. A. Bernstein, V. Hadzilacos, and N. Goodman, Concurrency
Control and Recovery in Database Systems. Addison-Wesley, 1987.
[23] R. Van Renesse and F. B. Schneider, “Chain replication for
supporting high throughput and availability,” in OSDI’04. USENIX
Association, 2004, pp. 7–7. [Online]. Available: http://dl.acm.org/citation.
cfm?id=1251254.1251261
[24] C. Papadimitrou, “The serializability of concurrent updates in
databases,” J. ACM, vol. 26, no. 4, pp. 631–653, Oct. 1979.
[25] C. Dwork, N. Lynch, and L. Stockmeyer, “Consensus in the presence
of partial synchrony,” J. ACM, vol. 35, no. 2, pp. 288–323, 1988.
[26] L. Chen and A. Avizienis, “N-version programming: A fault-tolerance
approach to reliability of software operation,” in FTCS’77. Los Alamitos,
CA: IEEE Computer Society Press, 1977.
[27] “Transaction
http://www.tpc.org/tpcc/.”
[28] S. Jones, Haskell 98 language and libraries: the Revised Report.
Cambridge University Press, 2003.
[29] A. Wang, L. Jia, C. Liu, B. T. Loo, O. Sokolsky, and P. Basu,
“Formally veriﬁable networking,” in HotNets. ACM SIGCOMM, 2009.
[30] S. Abiteboul, R. Hull, and V. Vianu, Foundations of Databases.
Addison Wesley, 1995.
[31] S. Owre, N. Shankar, and J. Rushby, “PVS: A prototype veriﬁcation
system,” in CADE 11, Saratoga Springs, NY, Jun. 1992.
[32] B. T. Loo, T. Condie, J. M. Hellerstein, P. Maniatis, T. Roscoe, and
I. Stoica, “Implementing declarative overlays,” SIGOPS Oper. Syst. Rev.,
vol. 39, no. 5, pp. 75–90, Oct. 2005.
[33] J. A. P´erez, A. Rybalchenko, and A. Singh, “Cardinality abstraction
for declarative networking applications,” in CAV’09.
Springer-Verlag,
2009, pp. 584–598.
[34] D. Kitchin, W. R. Cook, and J. Misra, “A language for task orchestra-
tion and its semantic properties,” in CONCUR 2006 - Concurrency Theory,
17th Int’l Conf., ser. LNCS, vol. 4137. Springer, 2006, pp. 477–491.
[35] D. Kitchin, A. Quark, W. R. Cook, and J. Misra, “The Orc program-
ming language,” in Formal Techniques for Distributed Systems, ser. LNCS,
vol. 5522. Springer, 2009, pp. 1–25.
[36] C. E. Killian, J. W. Anderson, R. Braud, R. Jhala, and A. M. Vahdat,
“Mace: language support for building distributed systems,” in PLDI’07.
ACM, 2007, pp. 179–188.
[37] P. Maniatis, M. Dietz, and C. Papamanthou, “Mommie knows best:
systematic optimizations for veriﬁable distributed algorithms,” in HotOS’11.
USENIX Association, 2011, pp. 30–30.
[38] P. Sewell, P. Wojciechowski, and A. Unyapoth, “Nomadic Pict: Pro-
gramming languages, communication infrastructure overlays, and semantics
for mobile computation,” Trans. on Programming Languages and Systems,
vol. 32, no. 4, 2010.
of correct distributed protocols. Based on a total order broad-
cast service whose code comes with correctness properties,
we built two replicated databases: one is based on primary-
backup replication and the other is based on state machine
replication.
“The Coq Proof Assistant,” http://coq.inria.fr/.
Primary-backup replication offers performance similar or
superior to the popular MySQL database. Although not as
fast as primary-backup replication on all benchmarks, we
showed that the state machine replication protocol provides
similar peak throughput on the TPC-C benchmark. With
state machine replication, normal case operation relies on
the broadcast service, and a larger proportion of the code
comes with correctness guarantees. This shows that building
replicated databases with formal guarantees is not only
feasible but it can also provide good performance.
References
[1] G. Klein, K. Elphinstone, G. Heiser, J. Andronick, D. Cock, P. Derrin,
D. Elkaduwe, K. Engelhardt, R. Kolanski, M. Norrish, T. Sewell, H. Tuch,
and S. Winwood, “seL4: formal veriﬁcation of an OS kernel,” in SOSP’09.
ACM, 2009, pp. 207–220.
[2] T. Nipkow, L. C. Paulson, and M. Wenzel, Isabelle/HOL — A Proof
Assistant for Higher-Order Logic, ser. LNCS. Springer, 2002, vol. 2283.
[3] X. Leroy, “Formal certiﬁcation of a compiler back-end or: program-
ming a compiler with a proof assistant,” in POPL’06. ACM, 2006, pp.
42–54.
[4]
[5] N. Schiper, V. Rahli, R. V. Renesse, M. Bickford, and R. L.
Constable, “ShadowDB: A replicated database on a synthesized consensus
core,” in HotDep’12, 2012. [Online]. Available: http://nuprl.org/KB/show.
php?ID=696
[6] N. Budhiraja, K. Marzullo, F. Schneider, and S. Toueg, “The primary-
backup approach,” in Distributed systems (2nd Ed.), S. Mullender, Ed. New
York, NY: ACM Press/Addison-Wesley Publishing Co., 1993.
[7] L. Lamport, “Time, clocks, and the ordering of events in a distributed
system,” CACM, vol. 21, no. 7, pp. 558–565, Jul. 1978.
[8] V. Rahli, “Interfacing with proof assistants for domain speciﬁc pro-
gramming using EventML,” presented at UITP 2012.
[9] M. J. C. Gordon, R. Milner, and C. P. Wadsworth, Edinburgh LCF:
A Mechanised Logic of Computation., ser. LNCS. Springer-Verlag, 1979,
vol. 78.
[10] R. L. Constable, S. F. Allen, H. M. Bromley, W. R. Cleaveland,
J. F. Cremer, R. W. Harper, D. J. Howe, T. B. Knoblock, N. P. Mendler,
P. Panangaden, J. T. Sasaki, and S. F. Smith, Implementing mathematics
with the Nuprl proof development system. Upper Saddle River, NJ, USA:
Prentice-Hall, Inc., 1986.
[11] C. Kreitz, The Nuprl Proof Development System, Version 5, Reference
Manual and User’s Guide, Cornell University, Ithaca, NY, 2002, www.
nuprl.org/html/02cucs-NuprlManual.pdf.
[12] S. F. Allen, M. Bickford, R. L. Constable, R. Eaton, C. Kreitz,
L. Lorigo, and E. Moran, “Innovations in computational type theory using
Nuprl,” J. Applied Logic, vol. 4, no. 4, pp. 428–469, 2006.
[13] M. Bickford, “Component speciﬁcation using event classes,” in
Component-Based Software Engineering, 12th Int’l Symp., ser. LNCS, vol.
5582. Springer, 2009, pp. 140–155.
[14] M. Bickford and R. L. Constable, “Formal foundations of computer
security,” in NATO Science for Peace and Security Series, D: Information
and Communication Security, 2008, vol. 14, pp. 29–52.
[15] M. Bickford, R. L. Constable, and V. Rahli, “Logic of Events, a
framework to reason about distributed systems,” in Languages for Dis-
tributed Algorithms Workshop, Philadelphia, PA, 2012. [Online]. Available:
http://www.nuprl.org/documents/Bickford/LOE-LADA2012.html
[16] M. Bickford, R. L. Constable, and D. Guaspari, “Generating event
logics with higher-order processes as realizers,” Cornell University, Tech.
Rep., 2010.
[17] T. D. Chandra, R. Griesemer, and J. Redstone, “Paxos made live: an
engineering perspective,” in PODC’07.
Portland, OR: ACM, 2007, pp.
398–407.
12