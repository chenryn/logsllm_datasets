we targeted,
the overﬂow occurred because a length was
speciﬁed in the packet but a larger value was sent. It certainly
is possible to write a fuzz tester that has knowledge about
a protocol and attempts to overﬂow by supplying incorrect
lengths [17]. Interestingly, pretty much the same chunked
encoding vulnerability that appeared in nginx has already
appeared in Apache in the past [18]. It may be possible to
write fuzz testers for particular protocol conditions that are
known to be hard to implement correctly, or that have been
known to be exploited in the past.
XIII. BROP PREVENTION
The following is a discussion of defense mechanisms that
will prevent the BROP attack, including two precautions we
suggest server developers use. There is a lot of prior research in
ROP attack defense mechanisms, and many of those techniques
are applicable to defending against BROP. Thus, this list is by
no means comprehensive.
A. Rerandomization
The most basic protection against the BROP attack is to
rerandomize canaries and ASLR as often as possible. These
protection mechanisms are effective, but server developers
undermine them by not rerandomizing when worker processes
crash. The simplest method is to fork and exec the process
on a crash or spawn, which rerandomizes both the canary
and ASLR. It is important that any child processes forked
are randomized independently so that any information learned
from one child cannot be used against another one.
There has been research on rerandomizing binaries at
runtime. One such technique is work by Giuffrida et al. that
uses a modiﬁed compiler to migrate the running state between
two instances (with a different ASLR randomization) [19].
We also prototyped a re-randomization technique that moves a
binary’s text segment to a new location using mmap/munmap,
and uses a page fault handler to determine whether pointers
should be rewritten as they are faulted on.
An even simpler improvement we developed is to reran-
domize the canary on a per-user or per-request basis. We
suggest servers write a new canary before entering a per-
request function. On the return through that function the old
canary should be restored so that execution can continue
normally. While this protects against the bugs in nginx and
our proprietary server, the particular attack against yaSSL can
avoid the canary entirely.
B. Sleep on crash
Systems
like NetBSD’s
segvguard [20] and grsec’s
deter_bruteforce for Linux [21] propose delaying a
fork after a segmentation fault. This technique can slow down
attacks such that an administrator can notice something is
wrong and address the problem. The downside of this approach
is that bugs now can become easy denial of service attacks.
It is also unclear what a good value for the delay is. grsec
proposes a 30 second delay. While this is sufﬁcient for most
setups, overnight attacks on a small site might go unnoticed:
our optimized BROP attack for nginx can complete in 1,000
requests, making the attack time roughly 8 hours.
240
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 11:56:59 UTC from IEEE Xplore.  Restrictions apply. 
While denial of service attacks are serious, leaking private
data can be even worse. In some situations, servers should
not respawn, but in practice users and developers ﬁnd this an
unacceptable solution. Modern Linux desktops use systemd to
monitor services and automatically restart services on failures.
Developers should be cautious about which remote services
they really need or want to restart automatically to reduce the
attack surface.
C. ROP protections
Another class of defense mechanisms is protections that
defend against ROP attacks. Firstly, Control Flow Integrity
(CFI) [22] prevents return oriented programming in general
by enforcing the control ﬂow graph. There are many other
similar techniques.
Another approach developed by Pappas et al. is to enforce
control ﬂow inside the system call handler by comparing the
stack against last branch record (LBR) facility available in
Intel processors [23]. This can be used to verify that the stack
has not been tampered with. The main limitation is the depth
of the stack that can be checked is as small as four entries
depending on the processor model.
There are solutions that propose adding randomness to
binaries [24]. While these are effective against ROP they are
not in a BROP setting. Additional techniques exist to try to
randomize gadget locations on a per instance run, but these
offer no defense against BROP unless the binary is fully
restarted (fork and exec) [25], [26]. There are also techniques
to remove or reduce the number of available gadgets [27] that
could protect effectively against ROP attacks in general.
D. Compiler Techniques
Many modern compilers support inserting runtime bounds
checks on buffers. This prevents a class of bugs, unlike canaries
that detect corruption after the fact or not at all if a suc-
cessfully hacker brute-forces the secret value. LLVM contains
AddressSanitizer, a tool for bounds checks, and use after free
bugs [28]. The SafeCode framework is built on LLVM and
also enforces bounds checks among other things [29]. Intel
compilers also provide support for runtime bounds checking.
The main problem with all these solutions is that they
may suffer as much as a 2x performance slowdown, and as
such they are used mostly for testing. One bright spot to make
these solutions practical is that Intel has announced a set of
instruction extensions to reduce the cost of bounds checking
variables [30].
XIV. RELATED WORK
Prior work exists on scanning for a single ROP gadget.
Goodspeed’s half-blind attack against microcontrollers [31] re-
lies on knowledge of (common) bootloader code, and scanning
for a single gadget in an unknown portion of memory to con-
struct an attack used for ﬁrmware extraction. The BROP attack
is more generic as it is fully blind and presents techniques to
ﬁnd and chain multiple, different, gadgets.
There has been work on attacking instruction set random-
ization [32] that uses similar techniques to the BROP attack.
In that work, signaling for correct/incorrect guesses was based
on whether an application crashes or not. The goal, however,
was to leak an encryption key, and the method assumes that
a code injection exploit can be carried out in the ﬁrst place:
i.e., no ASLR and no NX were in place.
Stack reading to determine canaries is a well known
technique [33]. Researchers as well as attackers have shown
how to brute-force 32-bit ASLR [9], but this approach was not
feasible on 64-bit machines as it brute-forced the entire word
at once. We generalize the stack reading technique to reading
off the saved return address and frame pointer to break 64-bit
ASLR.
Many have noted that exploits today are multistage and
require leaking information. Kingcope’s 32-bit nginx exploit
for example brute-forces the location of write in the PLT
to leak the binary to ﬁnd gadgets and construct a binary-
agnostic exploit [14], [34]. This technique falls short on 64-bit
because multiple items need to be brute-forced at once: the
location of write and all the gadgets needed to populate
the arguments to write (the latter was not needed on 32-
bit). This makes a BROP-like attack a necessity on 64-bit;
even Kingcope admits difﬁculty in generalizing his approach
to these platforms. The author also admits that the exploit
does not work on WANs due to nginx’s non-blocking read.
The missing link was IP fragmentation. The nginx exploit is a
great case study showing the problems involved when writing
modern server-side exploits end-to-end.
Client-side exploit writers have had more luck with 64-
bit and ASLR, at least publicly, possibly due to contests that
highly reward participants and force them to publish their
work [35]. This year’s pwn2own exploit uses a JavaScript
vulnerability to leak a pointer, and then uses the same vulner-
ability to leak the entire contents of the chrome.dll library
to build a ROP chain. Again, this shows how exploits are
moving toward being binary-independent for robustness. This
made a difference even in closed-source systems where there
are relatively fewer versions of the binary, because Chrome
released a new version of the DLL shortly prior to the contest
demo, which would have stopped any exploit based on a
speciﬁc binary.
XV. CONCLUSION
We show that, under the right conditions, it is possible to
write exploits without any knowledge of the target binary or
source code. This works for stack vulnerabilities where the
server process restarts after a crash. Our attack is able to
defeat ASLR, NX and stack canaries on modern 64-bit Linux
servers. We present two new techniques: generalized stack
reading, which defeats full ASLR on 64-bit systems, and the
BROP attack, which is able to remotely ﬁnd ROP gadgets. Our
fully automated tool, Braille, can take under 4,000 requests to
spawn a shell, under 20 minutes, tested against real versions
of yaSSL+MySQL and nginx with known vulnerabilities, and
a toy proprietary service running an unknown binary.
We show that design patterns like forking servers with
multiple worker processes can be at odds with ASLR, and
that ASLR is only effective when it is applied to all code
segments in the binary (including PIE). Moreover, security
through obscurity, where the binary is unknown or randomized,
can only slow but not prevent buffer overﬂow attacks. In order
241
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 11:56:59 UTC from IEEE Xplore.  Restrictions apply. 
to defend against our attack, we suggest that systems should
rerandomize ASLR and canaries after any crash, and that no
library or executable should be exempt from ASLR.
Braille is available at: http://www.scs.stanford.edu/brop/.
[16] Ubuntu security features. [Online]. Available: https://wiki.ubuntu.com/
Security/Features
[17] Peach fuzzer. [Online]. Available: http://peachfuzzer.com/
[18] mitre. Cve-2002-0392. [Online]. Available: http://cve.mitre.org/cgi-bin/
cvename.cgi?name=CVE-2002-0392
ACKNOWLEDGMENTS
We thank our anonymous reviewers and Elad Efrat for their
feedback. We also thank Mark Handley and Brad Karp who
helped shape early versions of this work. Eric Smith suggested
using out-of-order TCP segments instead of IP fragmentation.
This work was funded by DARPA CRASH and a gift from
Google.
REFERENCES
[1] R. Roemer, E. Buchanan, H. Shacham, and S. Savage, “Return-oriented
programming: Systems, languages, and applications,” ACM Trans. Inf.
Syst. Secur., vol. 15, no. 1, pp. 2:1–2:34, Mar. 2012.
[Online].
Available: http://doi.acm.org/10.1145/2133375.2133377
[2] mitre. Cve-2013-2028. [Online]. Available: http://cve.mitre.org/cgi-bin/
cvename.cgi?name=CVE-2013-2028
[3] ——. Cve-2008-0226. [Online]. Available: http://cve.mitre.org/cgi-bin/
cvename.cgi?name=CVE-2008-0226
[4] A. One, “Smashing The Stack For Fun And Proﬁt,” Phrack, vol. 7,
no. 49, Nov. 1996. [Online]. Available: http://phrack.com/issues.html?
issue=49&id=14#article
[5] M. Kaempf. Vudo malloc tricks by maxx.
[Online]. Available:
http://www.phrack.org/issues.html?issue=57&id=8&mode=txt
[6] S. Designer. Getting around non-executable stack (and ﬁx). [Online].
Available: http://seclists.org/bugtraq/1997/Aug/63
[7] P. Team. Pax address space layout randomization (aslr). [Online].
Available: http://pax.grsecurity.net/docs/aslr.txt
[8] S. Bhatkar, D. C. DuVarney, and R. Sekar, “Address obfuscation:
an efﬁcient approach to combat a board range of memory error
exploits,” in Proceedings of
the 12th conference on USENIX
Security Symposium - Volume 12, ser. SSYM’03. Berkeley, CA,
USA: USENIX Association, 2003, pp. 8–8.
[Online]. Available:
http://dl.acm.org/citation.cfm?id=1251353.1251361
[9] H. Shacham, M. Page, B. Pfaff, E.-J. Goh, N. Modadugu, and D. Boneh,
“On the effectiveness of address-space randomization,” in Proceedings
of the 11th ACM conference on Computer and communications security,
ser. CCS ’04. New York, NY, USA: ACM, 2004, pp. 298–307.
[Online]. Available: http://doi.acm.org/10.1145/1030083.1030124
[10] gera and riq. Advances in format string exploitation.
[Online].
http://www.phrack.org/archives/59/p59 0x07 Advances%
Available:
20in%20format%20string%20exploitation by riq%20&%20gera.txt
[11] C. Cowan, C. Pu, D. Maier, H. Hintony, J. Walpole, P. Bakke, S. Beattie,
A. Grier, P. Wagle, and Q. Zhang, “Stackguard: automatic adaptive
detection and prevention of buffer-overﬂow attacks,” in Proceedings of
the 7th conference on USENIX Security Symposium - Volume 7, ser.
SSYM’98. Berkeley, CA, USA: USENIX Association, 1998, pp. 5–5.
[Online]. Available: http://dl.acm.org/citation.cfm?id=1267549.1267554
[12] H. Etoh, “GCC extension for protecting applications from stack-
smashing attacks (ProPolice),” 2003, http://www.trl.ibm.com/projects/
security/ssp/.
[Online]. Available: http://www.trl.ibm.com/projects/
security/ssp/
[13] Bulba and Kil3r, “Bypassing stackguard and stackshield,” Phrack
[Online]. Available: http://phrack.org/issues.
Magazine, May 2000.
html?issue=56&id=5#article
[14] Kingcope. About a generic way to exploit
linux targets. [Online].
Available: http://www.exploit-db.com/wp-content/themes/exploit/docs/
27074.pdf
[15] G. F. Roglia, L. Martignoni, R. Paleari, and D. Bruschi, “Surgically
returning to randomized lib(c),”
the 2009
Annual Computer Security Applications Conference, ser. ACSAC ’09.
Washington, DC, USA: IEEE Computer Society, 2009, pp. 60–69.
[Online]. Available: http://dx.doi.org/10.1109/ACSAC.2009.16
in Proceedings of
[19] C. Giuffrida, A. Kuijsten, and A. S. Tanenbaum, “Enhanced operating
system security through efﬁcient and ﬁne-grained address space
randomization,” in Proceedings of
the 21st USENIX conference
on Security symposium,
Berkeley, CA, USA:
USENIX Association, 2012, pp. 40–40. [Online]. Available: http:
//dl.acm.org/citation.cfm?id=2362793.2362833
[20] E. Efrat. Segvguard. [Online]. Available: http://www.netbsd.org/∼elad/
ser. Security’12.
recent/man/security.8.html
grsecurity.
able:
and PaX Conﬁguration Options#Deter exploit bruteforcing
Avail-
http://en.wikibooks.org/wiki/Grsecurity/Appendix/Grsecurity
bruteforcing.
[Online].
exploit
Deter
[21]
[22] M. Abadi, M. Budiu, U. Erlingsson, and J. Ligatti, “Control-
the 12th ACM Conference on
ser. CCS ’05. New
[Online]. Available:
ﬂow integrity,” in Proceedings of
Computer and Communications Security,
York, NY, USA: ACM, 2005, pp. 340–353.
http://doi.acm.org/10.1145/1102120.1102165
[23] V. Pappas, M. Polychronakis, and A. D. Keromytis, “Transparent ROP
exploit mitigation using indirect branch tracing,” in Proceedings of the
22nd USENIX conference on Security, ser. SEC’13. Berkeley, CA,
USA: USENIX Association, 2013, pp. 447–462. [Online]. Available:
http://dl.acm.org/citation.cfm?id=2534766.2534805
[24] R. Wartell, V. Mohan, K. W. Hamlen, and Z. Lin, “Binary stirring:
Self-randomizing instruction addresses of legacy x86 binary code,”
in Proceedings of
the 2012 ACM Conference on Computer and
Communications Security, ser. CCS ’12. New York, NY, USA: ACM,
2012, pp. 157–168. [Online]. Available: http://doi.acm.org/10.1145/
2382196.2382216
J. Hiser, A. Nguyen-Tuong, M. Co, M. Hall, and J. W. Davidson,
“Ilr: Where’d my gadgets go?” in Proceedings of
the 2012 IEEE
Symposium on Security and Privacy, ser. SP ’12. Washington, DC,
USA: IEEE Computer Society, 2012, pp. 571–585. [Online]. Available:
http://dx.doi.org/10.1109/SP.2012.39
[25]
[26] V. Pappas, M. Polychronakis, and A. D. Keromytis, “Smashing
the gadgets: Hindering return-oriented programming using in-place
code randomization,” in Proceedings of the 2012 IEEE Symposium
on Security and Privacy, ser. SP ’12. Washington, DC, USA:
IEEE Computer Society, 2012, pp. 601–615.
[Online]. Available:
http://dx.doi.org/10.1109/SP.2012.41
[27] K. Onarlioglu, L. Bilge, A. Lanzi, D. Balzarotti, and E. Kirda, “G-free:
defeating return-oriented programming through gadget-less binaries,”
in Proceedings of the 26th Annual Computer Security Applications
Conference. ACM, 2010, pp. 49–58.
[28] T. C. Team. Addresssanitizer - clang 3.4 documentation. [Online].
Available: http://clang.llvm.org/docs/AddressSanitizer.html
[29] D. Dhurjati, S. Kowshik, and V. Adve, “SAFECode: Enforcing alias
analysis for weakly typed languages,” in Proceedings of
the 2006
ACM SIGPLAN Conference on Programming Language Design and
Implementation, ser. PLDI ’06. New York, NY, USA: ACM, 2006,
pp. 144–157. [Online]. Available: http://doi.acm.org/10.1145/1133981.
1133999
Intel.
sions.
introduction-to-intel-memory-protection-extensions
exten-
http://software.intel.com/en-us/articles/
Introduction
[Online]. Available:
protection
memory
intel
[30]
to
[31] T. Goodspeed and A. Francillon, “Half-Blind Attacks: Mask ROM
Bootloaders are Dangerous,” in WOOT, 2009.
[32] A. N. Sovarel, D. Evans, and N. Paul, “Where’s the feeb?: The
effectiveness of instruction set randomization,” in Usenix Security, 2005.
[33] A. Zabrocki. Scraps of notes on remote stack overﬂow exploitation.
[Online]. Available: http://www.phrack.org/issues.html?issue=67&id=
13#article
[34] Kingcope. nginx 1.3.9/1.4.0 x86 brute force remote exploit. [Online].
Available: http://www.exploit-db.com/exploits/26737/
[35] M. Labes. Mwr
labs pwn2own 2013 write-up - webkit exploit.
[Online]. Available: https://labs.mwrinfosecurity.com/blog/2013/04/19/
mwr-labs-pwn2own-2013-write-up---webkit-exploit/
242
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 11:56:59 UTC from IEEE Xplore.  Restrictions apply.