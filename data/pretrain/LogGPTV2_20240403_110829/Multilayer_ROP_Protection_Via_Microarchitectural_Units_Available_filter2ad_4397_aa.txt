# Title: Multilayer ROP Protection via Microarchitectural Units Available in Commodity Hardware

## Authors:
- Mateus Tymburib'a
- Hugo Sousa
- Fernando Magno Quintão Pereira

### Conference:
2019 49th Annual IEEE/IFIP International Conference on Dependable Systems and Networks (DSN)

## Abstract
This paper introduces a multilayer protection approach to safeguard programs against Return-Oriented Programming (ROP) attacks. The upper layers validate the majority of a program’s control flow with minimal computational cost, ensuring that runtime performance is not compromised. The lower layers provide robust enforcement guarantees for more suspicious flows, thereby enhancing security. Our multilayer system integrates existing techniques from the literature with new verifications introduced in this paper. We argue that modern x86 processors already possess the necessary microarchitectural units to implement our technique. We demonstrate the effectiveness of our multilayer protection using an extensive suite of benchmarks, including SPEC CPU2006, the three most popular web browsers, 209 benchmarks distributed with LLVM, and four well-known systems vulnerable to ROP exploits. Our experiments show that our approach can protect programs with almost no overhead, combining the efficiency of lightweight security techniques with the high dependability of heavyweight approaches.

**Index Terms:** ROP, Architecture, Layers, RAS, LBR, CFI

## I. Introduction
Return-Oriented Programming (ROP) is a form of software exploitation that involves chaining sequences of binary instructions to force actions not originally intended by the program's developers [1]. Notable malware such as Conficker [2], [3] and Duqu [4] have used ROP. Additionally, the Common Vulnerabilities and Exposures (CVE) database contains numerous examples of recent ROP-based vulnerabilities [5]–[7]. Despite the media coverage of these exploits, the research community generally believes that current protection techniques can prevent most ROP attacks [8], [9]. However, recent demonstrations of successful attacks, though tailored to specific applications or protection measures, highlight the ongoing threat [10]–[12]. The primary challenge is performance: effective protection techniques often slow down programs to unacceptable levels, making them impractical for real-world use.

Most anti-ROP protection techniques in practice are based on Control Flow Integrity (CFI). Compilers like Clang and GCC implement various forms of CFI, all aiming to prevent unwanted program flows. The first implementation of CFI incurred a 21% overhead [13], which has since been reduced but remains noticeable. Effective CFI requires validating every type of indirect branch, including return instructions, which is computationally expensive. Recent CFI implementations, such as SafeDispatch [14], T-VIP [15], VTV/IFCC [16], vfGuard [17], and VTint [18], have overheads ranging from 2% to 18%. More general techniques that verify return instruction targets, such as the original CFI [13], MoCFI [19], Lockdown [20], PathArmor [9], and PittyPat [21], have overheads between 7% and 21%.

The observation that "effective CFI is computationally too expensive to be practical" has been key in demonstrating recent ROP-based exploits [22]–[24]. Two additional factors make it challenging to design a definitive CFI mechanism. First, more constrained CFI implementations raise more false positives, often rendering the execution of authentic programs impractical. Second, even the more restrictive versions of CFI can be bypassed by determined attackers. Carlini et al. [23] showed how to circumvent fully-precise CFI, and Veen et al. [24] demonstrated how to bypass context-sensitive CFI. Therefore, designing and implementing a system that prevents ROP attacks efficiently and effectively remains an open problem.

### Our Thesis
Efficiency and effectiveness do not need to coexist in a single protection technique. Instead, we can achieve both by combining existing approaches in layers. This perspective shifts the focus from malicious execution streams to certifying authentic ones. Upper layers cheaply certify most program flows, reducing the number of tests executed in lower layers, which check eccentric codes via more expensive verifications. This novel multilayer system can be implemented using components available in current x86 architectures.

### Our Contribution
As a proof of concept, we propose a three-layered defense system to prevent code reuse attacks that divert return instructions. The first layer (Layer 1) uses hardware branch predictors to filter authentic execution flows. If the target of a return instruction is correctly predicted, it is considered valid. This approach has been explored in previous work, which we revisit in Section V. Layer 1 filters out most valid program flows due to the high accuracy of branch predictors, even for indirect branches, as shown in Section IV-C. Few branches slip through to the second layer, where more expensive checks occur.

Layer 2 implements an original detection strategy that reduces the number of gadgets available to attackers. It extends Kiriansky et al.’s concept of call-preceded return address verification [25] by also verifying if the preceding call is valid. This step was necessary because Carlini et al. [23] demonstrated that Kiriansky’s method is easily circumvented.

Layer 3 avoids false positives related to return address verification, reducing the number of false alarms raised by genuine control flows.

### Our Results
We evaluate our ideas in Section IV. Our model imposes a small execution time overhead of 0.57% on a set of benchmarks, including all 29 programs from SPEC CPU2006 [26] and 209 benchmarks from the LLVM Test Suite [27]. The high hit rate of branch prediction based on the Return Address Stack (RAS) at 99% is the main reason for this low overhead. The new check in Layer 2, which validates call instructions preceding return addresses, is also effective, reducing the number of available gadgets by almost 35 times compared to a previous protection mechanism [25].

We analyzed the number of false positives that slip through the first two layers of protection. In this experiment, we enriched our benchmark suite with the three most popular desktop browsers and four vulnerable applications with known ROP exploits. Only 3.14% of all return addresses were considered invalid. We demonstrate that the cost of handling these false positives has no impact on the execution time of programs.

### A Design Based on Microarchitectural Units
We demonstrate the viability of our ideas using a software prototype implemented via Pin [28]. An important part of this work is to show that all these layers could be built at the hardware level using existing microarchitectural units in modern x86 processors, such as branch prediction machinery, branch recording structures, and executable space protection mechanisms. Each protection layer is discussed in terms of its potential hardware implementation.

The change in perspective fosters a modular design. The second layer of our model can be replaced with other techniques that validate branches, as long as the necessary architectural units are in place. One candidate is Intel’s Control-Flow Enforcement Technology (CET) [29], which also thwarts Jump-Oriented (JOP) and Call-Oriented (COP) Programming attacks. The high accuracy of the branch predictor leaves fewer jmps and calls to be verified by CET. Similar to the RAS, the call and jmp predictors cannot be tampered with, as they are based on the previous execution of the instruction. When a call or jmp is executed for the first time, the branch predictor always misses, forcing validation in Layer 2. Section IV empirically demonstrates the benefits of implementing Layer 2 using CET.

## II. Return-Oriented Programming (ROP)
ROP exploits involve chaining sequences of instructions, called gadgets, which end with an indirect branch, typically a return instruction. ROP is used after exploiting vulnerabilities such as buffer overflows, integer overflows, and use-after-free. Once attackers exploit these vulnerabilities, they can control the execution flow of the vulnerable application by overwriting its function stack with addresses of several gadgets, which execute in sequence. After one gadget finishes, its final indirect branch sends the program flow to the next gadget, whose address has been stacked by the attacker.

These gadgets can be chained to bypass typical OS-level protections, such as Write⊕Execute. Once disabled, attackers can execute code from memory pages marked as data. For example, Windows, depending on its configuration, allows a process to disable Data Execution Prevention (DEP) via the `SetProcessDEPPolicy` routine. Attackers can use sequences of gadgets to prepare the arguments for this function. Tutorials and examples of ROP-based attacks are widely available online. For instance, Blake et al. [34] demonstrated how to hijack control of My MP3 Player v3.0 by disabling DEP in Windows XP SP3, using 10 gadgets. Figure 1 shows a snapshot of the stack during the actual exploitation of My MP3 Player.

Finding gadgets free of side effects is the greatest challenge for attackers performing ROP-based exploits. However, tools like Q [35], Mayhem [36], and Mona [37] allow attackers to automatically discover gadgets in a binary file.

## III. Layers of Protection
This paper shows that different anti-ROP mechanisms can be combined in layers, so that costly but effective lower-level layers are only used when higher-level layers have already filtered most authentic indirect branch flows. Figure 2 provides an abstract view of the multilayer protection mechanism. Our key idea is to certify the validity of indirect branches, the cornerstone of modern ROP exploits, in layers. The vast majority of these branches will be certified in the first layer, described in Section III-A. The few targets that cannot be validated at this level will undergo further verification in the second layer, explained in Section III-B. A third layer will filter this stream of branches even further, using the methodology described in Section III-C.

If a branch target cannot be verified in these three layers, multiple actions are possible. The most immediate action would be to interrupt the program. However, a better compromise is to move the program into a safe mode, achieved via sandboxing at the operating system level. Section III-D discusses this possibility, although the implementation of sandboxing, a well-researched topic, is not within the scope of this paper. Our goal is to filter out most indirect branch targets at a low computational cost. For the few that remain, we can afford the heavy price of stronger enforcement. As shown in Section IV-B, the proportion of targets that escape from one layer to the next is very small.

### A. First Level: Branch Predictors
The first layer of protection relies on branch predictors to validate targets of indirect branches. Modern computer architectures predict the target of indirect branch instructions to avoid pipeline stalls. For example, current x86 implementations use the Return Address Stack (RAS) to predict the address targeted by returns. When a function is invoked via a call instruction, the address immediately following the invocation point is pushed onto the RAS. When a return operation executes, the predictor guesses its target as the address on top of the RAS. Correct predictions indicate legitimate program flows and do not require further verification. This method is simple, effective, and costless.

Our use of the RAS is similar to the Shadow Stack technique [38], which matches the target of returns against the addresses following call instructions in a stack-like fashion. However, shadow stacks were conceived before the RAS became part of x86 processors and could not benefit from this hardware. We claim that a shadow stack can be implemented at zero-overhead at the hardware level by leveraging the RAS infrastructure. Although we do not treat ROP attacks based on other types of indirect branches (indirect calls and jmps) in this work, we show that their predictors have similar efficiency and effectiveness, making them suitable for the first layer of protection. Section IV-B1 presents the hit rates of these predictors, including the RAS.

**Implementation:** This protection layer requires only one extra comparison at the branch predictor level. This check can be fully implemented in hardware without impacting the execution time of programs, as it does not directly affect the instruction pipeline.

**Prototype:** In Section IV, we use hardware performance counters available in current x86 architectures to evaluate the hit rate of branch predictors. The defense mechanisms proposed in this paper do not depend on the availability of hardware counters; they are used only for evaluation.

### B. Second Level: Valid Call Verification
Not every mispredicted return address indicates a ROP attack. Mispredictions can occur due to overflows in the RAS buffer, caused by long sequences of function invocations or context switches between processes. If the target of a return is mispredicted, we resort to further validation.