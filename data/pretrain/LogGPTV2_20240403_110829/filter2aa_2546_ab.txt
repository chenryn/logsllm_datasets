Page 6 of 26
for this is simple. Files are the building blocks of the information we use as well as the 
way we use it. 
Files and specifically file formats used as documents provide some unique things for a 
client side attack, intel, opportunity, and exploits. 
Intel
The contents of documents contain data. Data which can be in a myriad of forms; words, 
pictures, videos, or even more data. This data can contain valuable information like 
passwords, names, and other specifics which can be leveraged in a client side attack. 
Opportunity
Client side attacks rely on specific opportunities which enable an attacker to compromise 
a target. Documents provide the delivery mechanism, and the bait.   
Exploits
There are a variety of things that can be exploited in documents. This includes social 
engineering such as exploiting the information in the document itself as it is presented to 
the viewer as well as more traditional exploits in documents and document viewers 
themselves. File format viewers such as acroread, xpdf, foxit have vulnerabilities which 
are being discovered and exploited at a rapid rate, usually in the file format parsing 
routines. There is also the concept of file format infection vs. exploitation. Infection 
refers to the process of embedding malicious functionality in the document itself rather 
than exploiting a programming error in the PDF viewer.
Office and productivity files can provide a valuable resource for targeting. If an attacker 
can take a file which the victim is likely to open, such as a corporate news letter, then the 
chances of successful penetration are greatly improved.
An attacker can search the web, specifying search parameters that focus on the target 
looking for available document files. Newsletters, conference announcements or slides, 
weather notifications, advertisements and other such files can be taken advantage of and 
modified to be malicious, then resent to the victims. 
If the target partners or has a relationship with another organization then files from the 2nd 
party can be used and sent to the first, or vice versa. The goal is to get a victim to open 
the document and exploit the reader. The acquisition of targets can be easily scripted for 
automation.
People believe that documents such as PDF’s are safe formats for them to open and 
people also trust documents coming from their own organizations. With thorough recon, 
Page 7 of 26
an attack can easily pick topics that are likely to interest the target or that are widely 
circulated to a large audience. 
4.3 Why PDF’s?
First one may ask the question, what do clients have a lot of? The answer would be data 
in the form of documents, which have diverse file formats. What do we gain from this? 
That file formats provide a large attack surface as well as target intelligence, and a 
potential delivery mechanism. 
PDF’s are an advantageous document file format to select because they contain a 
significant amount of potential functionality. PDF’s can contain JavaScript, enable code 
execution, contain other nested PDF’s, dynamic content is possible and exploits in the 
readers abound. There are 283,000,000 PDF’s available on the internet according to 
Google.
PDF’s can be easily infected by doing what is called an incremental update. This can be a 
very tedious process to do by hand because of the large amount of data needed to be 
parsed in the PDF file format. The authors have reverse engineered the PDF file format 
and created tools which can do the parsing and infection in an automated way.
The tool is called adobe_basic_social_engineering.rb *Appendix A and is a metasploit 
module written in ruby. The basic usage is to select a PDF to infect, pass the file to the 
module which will then parse the PDF and perform an incremental update with whatever 
malicious payload is available. The difference between this tool and other PDF exploit 
generation tools is that this allows the attacker to infect existing targeted PDF’s while 
most other tools simply generate a blank, and not very standard malicious PDF which can 
raise suspicion from the victim.
Chapter 5
Web Spear Phishing
5.1 Work Flow
The infrastructure of a web based spear phishing has several requirements. First needed is 
the ability to direct targets to the malicious site. Often this can be accomplished by 
implementing IFRAMES to hide the site inside another trusted site, by cross site scripting 
or other means. Next the ability to enumerate information about the target using a web 
application is useful. A mechanism for socially engineering the target into believing that 
everything they are seeing is expected and acceptable should be considered. Next a 
method for executing code on the target via social engineering, malicious java applet, 
Page 8 of 26
exploits or other means is implemented. The attacker needs the ability to handle incoming 
shells from the target, even in large numbers and automate the post exploitation activities.
The authors have broken down this problem into several modular compontents:
•
Target Sieve – A framework for enumerating the target and passing them off to 
the appropriate exploit
•
Includes:
o
Operating system detection
o
IP detection
o
Browser detection (firefox, IE, opera, safari, etc)
o
A decision making capability based on the results of enumeration
o
De­cloaking for gathering internal or natted network information
o
Cryptographically signed Java applications using “fake” certificates to 
trick the user
o
Obfuscation for IDS/HIDS evasion
This paper will provide code examples of how one could begin to implement these 
components into a framework. Several functions have been developed to perform each of 
these actions (full code available in the appendix):
genHeader() ­ Generate header, noscript to test JS
ipCheck() ­ Get target IP and compare to scope
javaCheck() ­ Verify java is enabled
osDetect() ­ Determine the operating system type
browserDetect() ­ Determine the browser in use
jsDecloakIP() ­ Get natted / internal IP using javascript
japdip() ­ Get natted / internal IP using javapplet
Logger() ­ Log captured info to a file
Page 9 of 26
5.2 SE and Malicious Java Applets
The authors have developed a simple proof of concept java applet for downloading and 
executing meterpreter. The client views a page which attempts to load the java applet in 
the victim’s browser. The victim is presented with a window asking if they would like to 
run the applet. If the client hits run then the applet is loaded and causes the client to 
download a stand alone meterpreter executable from a specified website and execute it. 
The meterpreter then sends a reverse shell over the specified port to the attackers waiting 
server. The code to the applet is available in the appendix.
To make the java applet concept much more deadly one can cryptographically sign the 
applet. You can sign it with whatever information you want (self signing). Many large 
environments are full of expired or self signed certificates so users are used to looking at 
the message and seeing its from someone they trust and then accepting it. 
An astute attacker can set file names of applets and web code to reflect things common to 
the targets infrastructure, or even penetrate the targets web server and places these tools 
on the real trusted server itself.
Here are the steps for cryptographically signing a malicious java applet:
•
Compile the applet: 
–
javac MetaPhish.java
Page 10 of 26
Example Page
Normally you wouldn’t 
display output
Shows all the target 
acquired data
•
Generate a class file: 
–
jar ­cf MetaPhish.jar MetaPhish.class
•
Build a ketystore and set the passwords / organization name: 
–
keytool ­genkey ­alias signFiles ­keystore msfkeystore ­storepass 
msfstorepass ­dname "cn=The Targets Org" ­keypass msfkeypass
•
Sign the files and create a “secured” jar: 
–
jarsigner ­keystore msfkeystore ­storepass msfstorepass ­keypass 
msfkeypass ­signedjar sMetaPhish.jar MetaPhish.jar signFiles
•
Create the certificate: 
–
keytool ­export ­keystore msfkeystore ­storepass msfstorepass ­alias 
signFiles ­file MetaPhishLLC.cer
•
Import the certificate: 
–
keytool ­import ­alias company ­file MetaPhishLLC.cer ­keystore 
msfkeystore ­storepass msfstorepass
•
Once completing the above steps you will have a collection of files:
–
MetaPhish.class 
* Compiled Java 
–
MetaPhish.jar 
* Compressed class
–
MetaPhish.java
* Source code
–
MetaPhishLLC.cer
* Certificate
–
msfkeystore
* Key store
–
sMetaPhish.jar
* Signed Jar
–
windex.html
* malicious web page
Once the code is signed it can be placed on a web page like this:
<APPLET code="MetaPhish.class" archive="sMetaPhish.jar" width="1" 