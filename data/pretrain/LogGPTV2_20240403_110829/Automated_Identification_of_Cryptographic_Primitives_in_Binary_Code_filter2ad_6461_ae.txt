2.3s. However the number of vertices is not the only param-
eter to inﬂuence the execution time. Sometimes larger sig-
natures imply stronger structural constrains between their
vertices and the subgraph isomorphism algorithm will be
able converge more rapidly towards the solution.
Regarding the normalization step, every rewrite rule is
linear with the number of vertices, except for the common
subexpression rule which is quadratic (at least for its naive
implementation). However as previously stated, the rewrite
rules are iteratively applied until a ﬁxed-point is reached.
Thus, the execution time also depends on the distance be-
tween the original DFG and its normalized version. In prac-
tice the execution time of the normalization does not exceed
the execution time of the signature matching.
To conclude, despite the theoretical complexity of the un-
derlying algorithm, the execution times we observed on syn-
thetic samples seem acceptable.
9. CONCLUSION
In this paper we presented a new method for symmetric
cryptographic algorithms identiﬁcation in binary programs.
To this end we introduced a DFG representation. This rep-
resentation was ﬁrst used in a normalization step designed to
increase the detection capability, by erasing the peculiarities
of each instance of an algorithm. Then, the normalized DFG
was compared to the signatures of database using a subgraph
isomorphism algorithm. Signatures cover the full length of
the algorithm and not only an isolated group of distinctive
instructions. Thus our approach does not produce any false
positive and the input and output parameters of the cryp-
tographic primitive are automatically identiﬁed as part of
the signature boundary. We built a prototype and tested
it against several synthetic samples covering three crypto-
graphic algorithms: XTEA, MD5 and AES. We showed de-
tailed results proving that our approach was resistant to a
large range of compilation conditions. We also provided re-
sults on well known cryptographic libraries.
As future work, we plan to cover block cipher modes of
operation by leveraging the concept of macro-signature we
have presented in this paper and we envisage to extend our
approach to automatically identify public key cryptographic
algorithms. In order to make our contribution more practi-
cal for security auditors to support more algorithms, we aim
at automatically generating signatures from reference imple-
mentation. Finally we left for future researches the delicate
problem of dealing with obfuscated code.
10. ACKNOWLEDGMENTS
The authors are grateful to Pierre Karpman for his help
and his useful feedbacks.
11. REFERENCES
[1] Botan. http://botan.randombit.net/.
[2] Crypto++. http://www.cryptopp.com/.
[3] Openssl. https://www.openssl.org/.
[4] A. V. Aho, R. Sethi, and J. D. Ullman. Compilers:
Princiles, Techniques, and Tools. Addison-Wesley,
1986.
[5] G. Balakrishnan and T. W. Reps. WYSINWYX: what
you see is not what you execute. ACM Trans.
Program. Lang. Syst., 32(6), 2010.
[6] A. Biryukov. The design of a stream cipher lex. In
E. Biham and A. M. Youssef, editors, Selected Areas
in Cryptography, volume 4356 of Lecture Notes in
Computer Science, pages 67–75. Springer, 2006.
[7] J. Calvet, J. M. Fernandez, and J.-Y. Marion. Aligot:
cryptographic function identiﬁcation in obfuscated
binary programs. In T. Yu, G. Danezis, and V. D.
Gligor, editors, ACM Conference on Computer and
Communications Security, pages 169–182. ACM, 2012.
[8] C. Clavier and K. Gaj, editors. Cryptographic
Hardware and Embedded Systems - CHES 2009, 11th
International Workshop, Lausanne, Switzerland,
September 6-9, 2009, Proceedings, volume 5747 of
Lecture Notes in Computer Science. Springer, 2009.
[9] J. Daemen and V. Rijmen. The Design of Rijndael:
AES - The Advanced Encryption Standard.
Information Security and Cryptography. Springer,
2002.
212[10] T. S. Denis. Libtomcrypt. http://libtom.org/.
[11] S. Even and Y. Mansour. A construction of a cipher
from a single pseudorandom permutation. J.
Cryptology, 10(3):151–162, 1997.
Cryptographic Techniques, Interlaken, Switzerland,
May 2-6, 2004, Proceedings, volume 3027 of Lecture
Notes in Computer Science, pages 555–570. Springer,
2004.
[12] D. Genkin, A. Shamir, and E. Tromer. RSA key
[24] R. Rivest. The MD5 Message-Digest Algorithm. RFC
extraction via low-bandwidth acoustic cryptanalysis.
In J. A. Garay and R. Gennaro, editors, Advances in
Cryptology - CRYPTO 2014 - 34th Annual Cryptology
Conference, Santa Barbara, CA, USA, August 17-21,
2014, Proceedings, Part I, volume 8616 of Lecture
Notes in Computer Science, pages 444–461. Springer,
2014.
[13] F. Gr¨obert, C. Willems, and T. Holz. Automated
identiﬁcation of cryptographic primitives in binary
programs. In R. Sommer, D. Balzarotti, and G. Maier,
editors, RAID, volume 6961 of Lecture Notes in
Computer Science, pages 41–60. Springer, 2011.
[14] I. Guilfanov. Findcrypt2.
http://www.hexblog.com/?p=28, February 2006.
[15] S. Halevi, W. E. Hall, and C. S. Jutla. The hash
function ”fugue”. IACR Cryptology ePrint Archive,
2014:423, 2014.
[16] M. Hamburg. Accelerating aes with vector permute
instructions. In Clavier and Gaj [8], pages 18–32.
[17] E. K¨asper and P. Schwabe. Faster and timing-attack
resistant aes-gcm. In Clavier and Gaj [8], pages 1–17.
[18] J. Kelsey, B. Schneier, and D. Wagner. Related-key
cryptanalysis of 3-way, biham-des, cast, des-x, newdes,
rc2, and TEA. In Y. Han, T. Okamoto, and S. Qing,
editors, Information and Communication Security,
First International Conference, ICICS’97, Beijing,
China, November 11-14, 1997, Proceedings, volume
1334 of Lecture Notes in Computer Science, pages
233–246. Springer, 1997.
[19] W. M. Khoo, A. Mycroft, and R. Anderson.
Rendezvous: a search engine for binary code. In
T. Zimmermann, M. D. Penta, and S. Kim, editors,
Proceedings of the 10th Working Conference on
Mining Software Repositories, MSR ’13, San
Francisco, CA, USA, May 18-19, 2013, pages
329–338. IEEE / ACM, 2013.
[20] N. Lutz. Towards revealing attacker’s intent by
automatically decrypting network traﬃc. Master’s
thesis, ETH Zurich, July 2008.
[21] J. Manger. A chosen ciphertext attack on RSA
optimal asymmetric encryption padding (OAEP) as
standardized in PKCS #1 v2.0. In J. Kilian, editor,
Advances in Cryptology - CRYPTO 2001, 21st Annual
International Cryptology Conference, Santa Barbara,
California, USA, August 19-23, 2001, Proceedings,
volume 2139 of Lecture Notes in Computer Science,
pages 230–238. Springer, 2001.
[22] M. Matsui and J. Nakajima. On the power of bitslice
implementation on intel core2 processor. In P. Paillier
and I. Verbauwhede, editors, CHES, volume 4727 of
Lecture Notes in Computer Science, pages 121–134.
Springer, 2007.
[23] P. Q. Nguyen. Can we trust cryptographic software?
cryptographic ﬂaws in GNU privacy guard v1.2.3. In
C. Cachin and J. Camenisch, editors, Advances in
Cryptology - EUROCRYPT 2004, International
Conference on the Theory and Applications of
1321, April 1992.
[25] A. Sæbjørnsen, J. Willcock, T. Panas, D. J. Quinlan,
and Z. Su. Detecting code clones in binary
executables. In G. Rothermel and L. K. Dillon,
editors, Proceedings of the Eighteenth International
Symposium on Software Testing and Analysis, ISSTA
2009, Chicago, IL, USA, July 19-23, 2009, pages
117–128. ACM, 2009.
[26] E. Tromer, D. A. Osvik, and A. Shamir. Eﬃcient
cache attacks on aes, and countermeasures. J.
Cryptology, 23(1):37–71, 2010.
[27] J. R. Ullmann. An algorithm for subgraph
isomorphism. J. ACM, 23(1):31–42, 1976.
[28] S. Vaudenay. Security ﬂaws induced by CBC padding
- applications to ssl, ipsec, WTLS ... In L. R.
Knudsen, editor, Advances in Cryptology -
EUROCRYPT 2002, International Conference on the
Theory and Applications of Cryptographic Techniques,
Amsterdam, The Netherlands, April 28 - May 2, 2002,
Proceedings, volume 2332 of Lecture Notes in
Computer Science, pages 534–546. Springer, 2002.
[29] R. Wang, Y. Shoshitaishvili, C. Kruegel, and
G. Vigna. Steal this movie: Automatically bypassing
DRM protection in streaming media services. In S. T.
King, editor, USENIX Security, pages 687–702.
USENIX Association, 2013.
[30] X. Wang, N. Zeldovich, M. F. Kaashoek, and
A. Solar-Lezama. Towards optimization-safe systems:
analyzing the impact of undeﬁned behavior. In
M. Kaminsky and M. Dahlin, editors, ACM SIGOPS
24th Symposium on Operating Systems Principles,
SOSP ’13, Farmington, PA, USA, November 3-6,
2013, pages 260–275. ACM, 2013.
[31] Z. Wang, X. Jiang, W. Cui, X. Wang, and M. Grace.
Reformat: Automatic reverse engineering of encrypted
messages. In M. Backes and P. Ning, editors,
ESORICS, volume 5789 of Lecture Notes in Computer
Science, pages 200–215. Springer, 2009.
[32] D. J. Wheeler and R. M. Needham. Tea, a tiny
encryption algorithm. In B. Preneel, editor, Fast
Software Encryption: Second International Workshop.
Leuven, Belgium, 14-16 December 1994, Proceedings,
volume 1008 of Lecture Notes in Computer Science,
pages 363–366. Springer, 1994.
[33] T. Xie, F. Liu, and D. Feng. Fast collision attack on
MD5. IACR Cryptology ePrint Archive, 2013:170,
2013.
[34] R. Zhao, D. Gu, J. Li, and R. Yu. Detection and
analysis of cryptographic data inside software. In
X. Lai, J. Zhou, and H. Li, editors, Information
Security, 14th International Conference, ISC 2011,
Xi’an, China, October 26-29, 2011. Proceedings,
volume 7001 of Lecture Notes in Computer Science,
pages 182–196. Springer, 2011.
213B. MD5 IMPLEMENTATION REMINDER
MD5 [24] is a cryptographic hash function that given a
message of any size produces a 128-bit hash. The message
is divided into 512-bit chunks with a padding being applied
to the last chunk. The MD5 algorithm is based on a four-
branch Feistel network that operates on a 128-bit state. It
is composed of 64 rounds. We use the following notations:
fi is the round function of round i, {ki, 1 ≤ i ≤ 64} is a
set of speciﬁc constants, M is an input message chunk and
(A1,i, A2,i, A3,i, A4,i) is the 128-bit state at the beginning of
round i, divided into four words of 32 bits. At each round
(1 ≤ i ≤ 64) the state is updated according to the following
equations:
A1,i+1 = A4,i
A2,i+1 = fi(A1,i, A2,i, A3,i, A4,i, M, ki)
A3,i+1 = A2,i
A4,i+1 = A3,i
The round function fi contains a boolean function that
changes every 16 rounds (4 distinct boolean functions are
used for the 64 rounds). Apart from this boolean function,
the round function remains the same for every round. Usu-
ally the 64 rounds are directly unrolled in the source code.
This is for instance the case of the C source code given in
the appendix of the RFC).
For the ﬁrst two series of rounds (round 1 to 16 and round
17 to 32) two diﬀerent formulas might be used to compute
the boolean functions. A diﬀerent formula that the one pro-
vided in the RFC might be used for improved eﬃciency (it
can be implemented using fewer bitwise instructions).
C. TEA & XTEA IMPLEMENTATION RE-
MINDER
Tiny Encryption Algorithm (TEA) [32] is a 64-bit block
cipher with a 128-bit key. It is based on a two-branch Feistel
network that operates on a 64-bit state. Rounds are usually
regrouped in pairs forming cycles. The recommended num-
ber of cycles is 32. However TEA suﬀers from related-key
attacks [18]. To solve this weakness Needham and Wheeler
proposed an extended version of TEA named XTEA. XTEA
has a diﬀerent key scheduling and a diﬀerent round function.
Both TEA and XTEA have been designed as small C pro-
grams performing simple operations on 32-bit words. The
only implementation variation we are aware of concerns the
key scheduling. Since the key scheduling is extremely sim-
ple some implementations do not compute the round keys
separately but they do it directly in each round.
APPENDIX
A. AES IMPLEMENTATION REMINDER
The Advanced Encryption Standard (AES) [9] is a Sub-
stitution Permutation Network (SPN) that can be instanti-
ated using three diﬀerent key bit-lengths: 128, 192, and 256.
The 128-bit plaintext initializes the internal state viewed
as a 4 × 4 matrix of bytes seen as elements of the ﬁnite
ﬁeld GF (28), which is deﬁned via the irreducible polyno-
mial x8 + x4 + x3 + x + 1 over GF (2). Depending on the
version of the AES, Nr rounds are applied to that state:
Nr = 10 for AES-128, Nr = 12 for AES-192 and Nr = 14
for AES-256. Each of the Nr AES round applies four op-
erations to the state matrix (except the last one where the
MixColumns is omitted):
• AddRoundKey: adds a 128-bit subkey to the state.
• SubBytes: applies the same 8-bit to 8-bit invertible S-
Box S 16 times in parallel on each byte of the state.
• ShiftRows: shifts the i-th row left by i positions.
• MixColumns: replaces each of the four column C of the
state by M × C where M is a constant 4× 4 maximum
distance separable matrix over GF (28).
After the Nr-th round has been applied, a ﬁnal subkey is
added to the internal state to produce the ciphertext. A key
expansion algorithm is used to produce the Nr + 1 sub keys
required for all AES variants.
From an implementation perspective, the ShiftRows and
the MixColumns can be combined with the SubBytes result-
ing in 4 lookup tables of 1 kilobyte each. We introduce the
following notations: Ai is the state at round i, divided in
four 32-bits word and Ti (0 ≤ i ≤ 3) is a function that
given a 32-bit word, extracts the ith most signiﬁcant byte
and returns the associated 32-bit word in the ith lookup ta-
ble. For each full round (1 ≤ i ≤ Nr − 1), the combination
of the ShiftRows, MixColumns and SubBytes can be imple-
mented using the following pseudo code (we have omitted
the AddRoundKey for brevity):
Ai+1[0] = T0(Ai[0]) ⊕ T1(Ai[1]) ⊕ T2(Ai[2]) ⊕ T3(Ai[3])
Ai+1[1] = T0(Ai[1]) ⊕ T1(Ai[2]) ⊕ T2(Ai[3]) ⊕ T3(Ai[0])
Ai+1[2] = T0(Ai[2]) ⊕ T1(Ai[3]) ⊕ T2(Ai[0]) ⊕ T3(Ai[1])
Ai+1[3] = T0(Ai[3]) ⊕ T1(Ai[0]) ⊕ T2(Ai[1]) ⊕ T3(Ai[2])
[22] and K¨asper et al.
This implementation is the most widespread and it is usu-
ally referred to as the tables implementation. However, it is
not the only way to eﬃciently implement the AES. Matsui
et al.
[17] proposed two bitsliced
implementations. In bitsliced modes, several blocks are pro-
cessed in parallel taking advantage of the SMID architecture.
Nevertheless bitsliced can only be used in parallel modes of
operation (such as the counter mode for instance). Hamburg
[16] demonstrated that it is feasible to implement a single
block AES encryption with vector permute instructions. Fi-
nally recent CPUs have dedicated AES instructions to reach
the best performances and the highest security levels. These
alternative implementations have been mentioned here for
completeness. This work only covers the tables implemen-
tation.
214