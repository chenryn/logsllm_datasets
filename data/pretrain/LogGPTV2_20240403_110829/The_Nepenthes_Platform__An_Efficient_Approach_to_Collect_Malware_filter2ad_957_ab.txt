with only moderate requirements in hardware and maintenance. This platform
enables us to eﬃciently deploy thousands of honeypots in parallel and collect
information about malicious network traﬃc.
2.1 Architecture of the Nepenthes Platform
nepenthes is based upon a very ﬂexible and modularized design. The core – the
actual daemon – handles the network interface and coordinates the actions of
the other modules. The actual work is carried out by several modules, which
register themselves in the nepenthes core. Currently, there are several diﬀerent
types of modules:
– Vulnerability modules emulate the vulnerable parts of network services.
– Shellcode parsing modules analyze the payload received by one of the vulner-
ability modules. These modules analyze the received shellcode, an assembly
language program, and extract information about the propagating malware
from it.
– Fetch modules use the information extracted by the shellcode parsing mod-
ules to download the malware from a remote location.
170
P. Baecher et al.
Fig. 1. Concept behind nepenthes platform
– Submission modules take care of the downloaded malware, e.g., by saving
the binary to a hard disc, storing it in a database, or sending it to anti-virus
vendors.
– Logging modules log information about the emulation process and help in
getting an overview of patterns in the collected data.
In addition, several further components are important for the functionality
and eﬃciency of the nepenthes platform: shell emulation, a virtual ﬁlesystem for
each emulated shell, geolocation modules, sniﬃng modules to learn more about
new activity on speciﬁed ports, and asynchronous DNS resolution.
The schematic interaction between the diﬀerent components is depicted in
Figure 1 and we introduce the diﬀerent building blocks in the next paragraphs.
Vulnerability modules are the main factor of the nepenthes platform. They en-
able an eﬀective mechanism to collect malware. The main idea behind these mod-
ules is the following observation: in order to get infected by autonomous spreading
malware, it is suﬃcient to only emulate the necessary parts of a vulnerable ser-
vice. So instead of emulating the whole service, we only need to emulate the relevant
parts and thus are able to eﬃciently implement this emulation. Moreover, this con-
cepts leads to a scalable architecture and the possibility of large-scale deployment
due to only moderate requirements on processing resources and memory. Often the
emulation can be very simple: we just need to provide some minimal information at
certain oﬀsets in the network ﬂow during the exploitation process. This is enough
to fool the autonomous spreading malware and make it believe that it can actu-
ally exploit our honeypot. This is an example of the deception techniques used in
honeypot-based research. With the help of vulnerability modules we trigger an in-
coming exploitation attempt and eventually we receive the actual payload, which
is then passed to the next type of modules.
Shellcode parsing modules analyze the received payload and extract automat-
ically relevant information about the exploitation attempt. Currently, only one
The Nepenthes Platform: An Eﬃcient Approach to Collect Malware
171
shellcode parsing module is capable of analyzing all shellcodes we have found
in the wild. The module works in the following way: ﬁrst, it tries to decode
the shellcode. Most of the shellcodes are encrypted with an XOR encoder. An
XOR decoder is a common way to encrypt the actual shellcode in order to evade
intrusion detection systems and avoid string processing functions. Afterwards
the module decodes the code itself according to the computed key and then
applies some pattern detection, e.g., CreateProcess() or generic URL detec-
tion patterns. The results are further analyzed (e.g., to extract credentials) and
if enough information can be reconstructed to download the malware from the
remote location, this information is passed to the next kind of modules. A shell-
code module that parses shellcodes in an even more generic way by emulating a
Windows operating system environment is currently in development.
Fetch modules have the task of downloading ﬁles from the remote location.
Currently, there are seven diﬀerent fetch modules. The protocols TFTP, HTTP,
FTP and csend/creceive (an IRC-based submission method) are supported. Since
some kinds of autonomous spreading malware use custom protocols for propa-
gation, there are also fetch modules to handle these custom protocols. Fetching
ﬁles from a remote location implies that the system running nepenthes contacts
other machines in the Internet. From an ethical point of view, this could be a
problem since systems not under our control are contacted. A normal computer
system that is infected by autonomous spreading malware would react in the
same way, therefore we have no concerns fetching the malware from the remote
location. However, it is possible to turn oﬀ the fetch modules. Then the system
collects information about exploitation attempts and can still be useful as some
kind of warning system.
Finally, submission modules handle successfully downloaded ﬁles. Currently
there are four diﬀerent types of submission modules:
– A module that stores the ﬁle in a conﬁgurable location on the ﬁlesystem and
is also capable of changing the ownership.
– A module that submits the ﬁle to a central database to enable distributed
sensors with central logging interface.
– A module that submits the ﬁle to another nepenthes instance to enable a
hierarchical structure of nepenthes sensors.
– A module that submits the ﬁle to an antivirus vendor for further analysis.
Certain malware does not spread by downloading shellcodes, but by providing
a shell to the attacker. Therefore it is sometimes required to spawn and emulate
a Windows shell. nepenthes oﬀers shell emulation by emulating a rudimentary
Windows shell to enable a shell interaction for the attacker. Several commands
can be interpreted and batch ﬁle execution is supported. Such a limited sim-
ulation has proven to be suﬃcient to trick automated attacks. Based on the
collected information from the shell session, it is then possible to also download
the corresponding malware.
A common technique to infect a host via a shell is to write commands for
downloading and executing malware into a temporary batch ﬁle and then execute
172
P. Baecher et al.
Fig. 2. Setup of distributed nepenthes platform
it. Therefore, a virtual ﬁlesystem is implemented to enable this type of attacks.
This helps in scalability since ﬁles are only created on demand, similar to copy-
on-write: when the incoming attack tries to create a ﬁle, this ﬁle is created
on demand and subsequently, the attacking process can modify and access it.
All this is done virtually, to enable a higher eﬃciency. Every shell session has
its own virtual ﬁlesystem, so that concurrent infection sessions using similar
exploits do not infere with each other. The temporary ﬁle is analyzed after the
attacking process has ﬁnished and based on this information, the malware is
downloaded from the Internet automatically. This mechanism is similar to cages
in Symantec’s ManTrap honeypot solution [18].
Nepenthes has several advantages compared to other solutions to automati-
cally collect malware. On the one hand, nepenthes is a very stable architecture.
A wrong oﬀset or a broken exploit will not lead to crashes, as opposed to other
attempts in this area. On the other hand, nepenthes scales well to even a large
number of IP addresses in parallel. By hierarchical deployment, it is very easy
to cover even larger parts of the network space with only limited resources.
2.2 Flexible Deployment
Nepenthes oﬀers a very ﬂexible design that allows a wide array of possible setups.
The most simple setup is a local nepenthes sensor, deployed in a LAN. It collects
information about malicious, local traﬃc and stores the information on the local
hard disc. More advanced uses of nepenthes are possible with a distributed ap-
proach. Figure 2 illustrates a possible setup of a distributed nepenthes platform:
a local nepenthes sensor in a LAN collects information about suspicious traﬃc
The Nepenthes Platform: An Eﬃcient Approach to Collect Malware
173
there. This sensor stores the collected information in a local database and also
forwards all information to another nepenthes sensor.
A second setup is a hierarchical one (depicted in the middle of Figure 2): a
distributed structure with several levels is build and each level sends the col-
lected information to the sensor at the higher level. In such a way, load can be
distributed across several sensor or information about diﬀerent network ranges
can be collected in a central and eﬃcient way.
Thirdly, traﬃc can be re-routed from a LAN to a remote nepenthes sensor
with the help of a VPN tunnel (depicted on the right). This approach is similar
to the network setup of the Collapsar project [9]. It enables a ﬂexible setup for
network attack detention. Furthermore, it simpliﬁes deployment and requires
less maintenance.
2.3 Capturing New Exploits
An important factor of a honeypot-based system is also the ability to detect
and respond to zero-day (0day) attacks, e.g., attack that exploit an unknown
vulnerability or at least a vulnerability for which no patch is available. The
nepenthes platform also has the capability to respond to this kind of threat. The
two basic blocks for this ability are the portwatch and bridging modules. These
modules can track network traﬃc at network ports and help in the analysis of
new exploits. By capturing the traﬃc with the help of the portwatch module,
we can at least learn more about any new threat since we have already a full
network capture of the ﬁrst few packets. In addition, nepenthes can be extended
to really handle 0day attacks. If a new exploit targets the nepenthes platform,
it will trigger the ﬁrst steps of a vulnerability module. At some point, the new
exploit will diverge from the emulation. This divergence can be detected and
then we perform a switch (hot swap) to either a real honeypot or some kind of
specialized system for dynamic taint analysis, e.g. Argos [13]. This second system
is an instance of the system nepenthes is emulating vulnerabilities for and shares
the internal state with it. This approach is similar to shadow honeypots [1].
With the help of the nepenthes platform, we can eﬃciently handle all known
exploits. Once something new is propagating in the wild, we switch from our
emulation to a real honeypot to capture all aspects of the new attack. From
the captured information, we are also able to respond to this new threat and
automatically extract response patterns. The mechanism behind this is rather
simple, but eﬀective. We record the network ﬂow and extract from this ﬂow the
necessary information to build a full vulnerability module. The whole mechanism
could presumably also be extended to build a fully automated system to respond
to new threats. Since the honeypot has by deﬁnition no false positives, we can
assume that all traﬃc is malicious. For known malicious traﬃc, we can respond
with the correct replies. For unknown malicious code, we need to learn the correct
replies with the help of a shadow honeypot. Based on the correct replies, a
learning algorithm could be used to extract all dynamic data inside the replies
(e.g., timestamps) and a correct vulnerability module could be built on-the-ﬂy.
These ideas are currently in development.
174
P. Baecher et al.
2.4 Limitations
We also identiﬁed several limitations of the nepenthes platform which we present
in this section. First, nepenthes is only capable of collecting malware that is au-
tonomously spreading, i.e., that propagates further by scanning for vulnerable
systems and then exploits them. This is a limitation that nepenthes has in com-
mon with most honeypot-based approaches: a web site that contains a browser
exploit which is only triggered when the web site is accessed will not be de-
tected with ordinary honeypots due to their passive nature. The way out of
this dilemma is to use client-side honeypots like HoneyMonkeys [22] or Kathy
Wang’s honeyclient [21] to detect this kind of attacks. The modular architecture
of nepenthes would enable this kind of vulnerability modules, but this is not the
aim of the nepenthes platform. The results in Section 3.2 show that nepenthes
is rather able to collect many diﬀerent types of bots [7].
Secondly, malware that propagates by using a hitlist to ﬁnd vulnerable systems
[17] is hard to detect with nepenthes. This is a limitation that nepenthes has in
common with all current honeypot-based systems and also other approaches in
the area of vulnerability assessment. Here, the solution of the problem would be
to become part of the hitlist. If for example the malware generates its hitlist by
querying a search engine for vulnerable systems, the trick would be to smuggle
a honeypot system in the index of the search engine. Currently it is unclear how
such an advertisement could be implemented within the nepenthes platform.
Thirdly, it is possible to remotely detect the presence of nepenthes: since a ne-
penthes instance normally emulates a large number of vulnerabilities and thus
opens many TCP ports, an attacker could become suspicious during the recon-
naissance phase. Current automated malware does not check the plausibility of
the target, but future malware could do so. To mitigate this problem, the stealth-
iness can be improved by using only the vulnerability modules which belong to a
certain conﬁguration of a real system, e.g., only vulnerability modules which emu-
late vulnerabilities for Windows 2000 Service Pack 1. The tradeoﬀ lies in reduced
expressiveness and leads to fewer samples collected. A similar problem with the
stealthiness appears if the results obtained by running nepenthes are published
unmodiﬁed. To mitigate such a risk, we refer to the solution outlined in [16].
Moreover, nepenthes is not exhaustive in terms of analyzing which exploits a
particular piece of malware is targeting. This limitation is due to the fact that
we respond to an incoming exploitation attempt and can just react on these
network pakets. Once we have downloaded a binary executable of the malware,
static or dynamic analysis of this binary can overcome this limitation. This is,
however, out of the scope of the current nepenthes implementation.
3 Results
Vulnerability modules are one of the most important components of the whole
nepenthes architecture since they take care of the emulation process. At the
time of this writing, there are 21 vulnerability modules in total. Table 1 gives
an overview of selected available modules, including a reference to the related
security advisory or a brief summary of its function.
The Nepenthes Platform: An Eﬃcient Approach to Collect Malware
175
Table 1. Overview of selected emulated vulnerable services