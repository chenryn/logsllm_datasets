nano / vim / emacs 字符终端的文本编辑器
exit 退出 shell
23
1.3 Linux 基础
管道命令符 "|" 将一个命令的标准输出作为另一个命令的标准输入
使用变量：
var=value 给变量var赋值value
$var, ${var} 取变量的值
`cmd`, $(cmd) 代换标准输出
'string' 非替换字符串
"string" 可替换字符串
$ var="test";
$ echo $var
test
$ echo 'This is a $var';
This is a $var
$ echo "This is a $var";
This is a test
$ echo `date`;
2017年 11月 06日 星期一 14:40:07 CST
$ $(bash)
$ echo $0
/bin/bash
$ $($0)
Bash 快捷键
24
1.3 Linux 基础
Up(Down) 上（下）一条指令
Ctrl + c 终止当前进程
Ctrl + z 挂起当前进程，使用“fg”可唤醒
Ctrl + d 删除光标处的字符
Ctrl + l 清屏
Ctrl + a 移动到命令行首
Ctrl + e 移动到命令行尾
Ctrl + b 按单词后移（向左）
Ctrl + f 按单词前移（向右）
Ctrl + Shift + c 复制
Ctrl + Shift + v 粘贴
更多细节请查看：Bash Keyboard Shortcuts
根目录结构
25
1.3 Linux 基础
$ uname -a
Linux manjaro 4.11.5-1-ARCH #1 SMP PREEMPT Wed Jun 14 16:19:27 C
EST 2017 x86_64 GNU/Linux
$ ls -al /
drwxr-xr-x 17 root root 4096 Jun 28 20:17 .
drwxr-xr-x 17 root root 4096 Jun 28 20:17 ..
lrwxrwxrwx 1 root root 7 Jun 21 22:44 bin -> usr/bin
drwxr-xr-x 4 root root 4096 Aug 10 22:50 boot
drwxr-xr-x 20 root root 3140 Aug 11 11:43 dev
drwxr-xr-x 101 root root 4096 Aug 14 13:54 etc
drwxr-xr-x 3 root root 4096 Apr 8 19:59 home
lrwxrwxrwx 1 root root 7 Jun 21 22:44 lib -> usr/lib
lrwxrwxrwx 1 root root 7 Jun 21 22:44 lib64 -> usr/lib
drwx------ 2 root root 16384 Apr 8 19:55 lost+found
drwxr-xr-x 2 root root 4096 Oct 1 2015 mnt
drwxr-xr-x 15 root root 4096 Jul 15 20:10 opt
dr-xr-xr-x 267 root root 0 Aug 3 09:41 proc
drwxr-x--- 9 root root 4096 Jul 22 22:59 root
drwxr-xr-x 26 root root 660 Aug 14 21:08 run
lrwxrwxrwx 1 root root 7 Jun 21 22:44 sbin -> usr/bin
drwxr-xr-x 4 root root 4096 May 28 22:07 srv
dr-xr-xr-x 13 root root 0 Aug 3 09:41 sys
drwxrwxrwt 36 root root 1060 Aug 14 21:27 tmp
drwxr-xr-x 11 root root 4096 Aug 14 13:54 usr
drwxr-xr-x 12 root root 4096 Jun 28 20:17 var
由于不同的发行版会有略微的不同，我们这里使用的是基于 Arch 的发行版
Manjaro，以上就是根目录下的内容，我们介绍几个重要的目录：
/bin 、 /sbin ：链接到 /usr/bin ，存放 Linux 一些核心的二进制文
件，其包含的命令可在 shell 上运行。
/boot ：操作系统启动时要用到的程序。
/dev ：包含了所有 Linux 系统中使用的外部设备。需要注意的是这里并不是
存放外部设备的驱动程序，而是一个访问这些设备的端口。
/etc ：存放系统管理时要用到的各种配置文件和子目录。
/etc/rc.d ：存放 Linux 启动和关闭时要用到的脚本。
/home ：普通用户的主目录。
/lib 、 /lib64 ：链接到 /usr/lib ，存放系统及软件需要的动态链接共
26
1.3 Linux 基础
享库。
/mnt ：这个目录让用户可以临时挂载其他的文件系统。
/proc ：虚拟的目录，是系统内存的映射。可直接访问这个目录来获取系统
信息。
/root ：系统管理员的主目录。
/srv ：存放一些服务启动之后需要提取的数据。
/sys ：该目录下安装了一个文件系统 sysfs。该文件系统是内核设备树的一
个直观反映。当一个内核对象被创建时，对应的文件和目录也在内核对象子系
统中被创建。
/tmp ：公用的临时文件存放目录。
/usr ：应用程序和文件几乎都在这个目录下。
/usr/src ：内核源代码的存放目录。
/var ：存放了很多服务的日志信息。
进程管理
top
可以实时动态地查看系统的整体运行情况。
ps
用于报告当前系统的进程状态。可以搭配 kill 指令随时中断、删除不必要
的程序。
查看某进程的状态： $ ps -aux | grep [file] ，其中返回内容最左边
的数字为进程号（PID）。
kill
用来删除执行中的程序或工作。
删除进程某 PID 指定的进程： $ kill [PID]
UID 和 GID
Linux 是一个支持多用户的操作系统，每个用户都有 User ID(UID) 和 Group
ID(GID)，UID 是对一个用户的单一身份标识，而 GID 则对应多个 UID。知道某个
用户的 UID 和 GID 是非常有用的，一些程序可能就需要 UID/GID 来运行。可以使
用 id 命令来查看：
27
1.3 Linux 基础
$ id root
uid=0(root) gid=0(root) groups=0(root),1(bin),2(daemon),3(sys),4
(adm),6(disk),10(wheel),19(log)
$ id firmy
uid=1000(firmy) gid=1000(firmy) groups=1000(firmy),3(sys),7(lp),
10(wheel),90(network),91(video),93(optical),95(storage),96(scann
er),98(power),56(bumblebee)
UID 为 0 的 root 用户类似于系统管理员，它具有系统的完全访问权。我自己新建的
用户 firmy，其 UID 为 1000，是一个普通用户。GID 的关系存储在 /etc/group
文件中：
$ cat /etc/group
root:x:0:root
bin:x:1:root,bin,daemon
daemon:x:2:root,bin,daemon
sys:x:3:root,bin,firmy
......
所有用户的信息（除了密码）都保存在 /etc/passwd 文件中，而为了安全起
见，加密过的用户密码保存在 /etc/shadow 文件中，此文件只有 root 权限可以
访问。
$ sudo cat /etc/shadow
root:$6$root$wvK.pRXFEH80GYkpiu1tEWYMOueo4tZtq7mYnldiyJBZDMe.mKw
t.WIJnehb4bhZchL/93Oe1ok9UwxYf79yR1:17264::::::
firmy:$6$firmy$dhGT.WP91lnpG5/10GfGdj5L1fFVSoYlxwYHQn.llc5eKOvr7
J8nqqGdVFKykMUSDNxix5Vh8zbXIapt0oPd8.:17264:0:99999:7:::
由于普通用户的权限比较低，这里使用 sudo 命令可以让普通用户以 root 用户的
身份运行某一命令。使用 su 命令则可以切换到一个不同的用户：
28
1.3 Linux 基础
$ whoami
firmy
$ su root
# whoami
root
whoami 用于打印当前有效的用户名称，shell 中普通用户以 $ 开头，root 用户
以 # 开头。在输入密码后，我们已经从 firmy 用户转换到 root 用户了。
权限设置
在 Linux 中，文件或目录权限的控制分别以读取、写入、执行 3 种一般权限来区
分，另有 3 种特殊权限可供运用。
使用 ls -l [file] 来查看某文件或目录的信息：
$ ls -l /
lrwxrwxrwx 1 root root 7 Jun 21 22:44 bin -> usr/bin
drwxr-xr-x 4 root root 4096 Jul 28 08:48 boot
-rw-r--r-- 1 root root 18561 Apr 2 22:48 desktopfs-pkgs.txt
第一栏从第二个字母开始就是权限字符串，权限表示三个为一组，依次是所有者权
限、组权限、其他人权限。每组的顺序均为 rwx ，如果有相应权限，则表示成相
应字母，如果不具有相应权限，则用 - 表示。
r ：读取权限，数字代号为 “4”
w ：写入权限，数字代号为 “2”
x ：执行或切换权限，数字代号为 “1”
通过第一栏的第一个字母可知，第一行是一个链接文件 （ l ），第二行是个目录
（ d ），第三行是个普通文件（ - ）。
用户可以使用 chmod 指令去变更文件与目录的权限。权限范围被指定为所有者
（ u ）、所属组（ g ）、其他人（ o ）和所有人（ a ）。
-R：递归处理，将指令目录下的所有文件及子目录一并处理；
+：开启权限范围的文件或目录的该选项权限设置
$ chmod a+r [file] ：赋予所有用户读取权限
29
1.3 Linux 基础
-：关闭权限范围的文件或目录的该选项权限设置
$ chmod u-w [file] ：取消所有者写入权限
=：指定权限范围的文件或目录的该选项权限设置；
$ chmod g=x [file] ：指定组权限为可执行
$ chmod o=rwx [file] ：制定其他人权限为可读、可写和可执行
字节序
目前计算机中采用两种字节存储机制：大端（Big-endian）和小端（Little-
endian）。
MSB (Most Significan Bit/Byte)：最重要的位或最重要的字节。
LSB (Least Significan Bit/Byte)：最不重要的位或最不重要的字节。
Big-endian 规定 MSB 在存储时放在低地址，在传输时放在流的开始；LSB 存储时
放在高地址，在传输时放在流的末尾。Little-endian 则相反。常见的 Intel 处理器使
用 Little-endian，而 PowerPC 系列处理器则使用 Big-endian，另外 TCP/IP 协议和
Java 虚拟机的字节序也是 Big-endian。
例如十六进制整数 0x12345678 存入以 1000H 开始的内存中：
30
1.3 Linux 基础
我们在内存中实际地看一下，在地址 0xffffd584 处有字符 1234 ，在地址
0xffffd588 处有字符 5678 。
31
1.3 Linux 基础
gdb-peda$ x/w 0xffffd584
0xffffd584: 0x34333231
gdb-peda$ x/4wb 0xffffd584
0xffffd584: 0x31 0x32 0x33 0x34
gdb-peda$ python print('\x31\x32\x33\x34')
1234
gdb-peda$ x/w 0xffffd588
0xffffd588: 0x38373635
gdb-peda$ x/4wb 0xffffd588
0xffffd588: 0x35 0x36 0x37 0x38
gdb-peda$ python print('\x35\x36\x37\x38')
5678
gdb-peda$ x/2w 0xffffd584
0xffffd584: 0x34333231 0x38373635
gdb-peda$ x/8wb 0xffffd584
0xffffd584: 0x31 0x32 0x33 0x34 0x35 0x36
0x37 0x38
gdb-peda$ python print('\x31\x32\x33\x34\x35\x35\x36\x37\x38')
123455678
db-peda$ x/s 0xffffd584
0xffffd584: "12345678"
输入输出
使用命令的输出作为可执行文件的输入参数
$ ./vulnerable 'your_command_here'
$ ./vulnerable $(your_command_here)
使用命令作为输入
$ your_command_here | ./vulnerable
将命令行输出写入文件
$ your_command_here > filename
使用文件作为输入
$ ./vulnerable    
* soft core unlimited
修改转储文件保存路径
通过修改 /proc/sys/kernel/core_uses_pid ，可以使生成的核心转储文件
名变为 core.[pid] 的模式。
# echo 1 > /proc/sys/kernel/core_uses_pid
还可以修改 /proc/sys/kernel/core_pattern 来控制生成核心转储文件的
保存位置和文件名格式。
# echo /tmp/core-%e-%p-%t > /proc/sys/kernel/core_pattern
此时生成的文件保存在 /tmp/ 目录下，文件名格式为 core-[filename]-
[pid]-[time] 。
使用 gdb 调试核心转储文件
gdb [filename] [core file]
例子
34
1.3 Linux 基础
$ cat core.c
#include 
void main(int argc, char **argv) {
char buf[5];
scanf("%s", buf);
}
$ gcc -m32 -fno-stack-protector core.c
$ ./a.out
AAAAAAAAAAAAAAAAAAAA
Segmentation fault (core dumped)
$ file /tmp/core-a.out-12444-1503198911
/tmp/core-a.out-12444-1503198911: ELF 32-bit LSB core file Intel
80386, version 1 (SYSV), SVR4-style, from './a.out', real uid:
1000, effective uid: 1000, real gid: 1000, effective gid: 1000,
execfn: './a.out', platform: 'i686'
$ gdb a.out /tmp/core-a.out-12444-1503198911 -q
Reading symbols from a.out...(no debugging symbols found)...done
.
[New LWP 12444]
Core was generated by `./a.out'.