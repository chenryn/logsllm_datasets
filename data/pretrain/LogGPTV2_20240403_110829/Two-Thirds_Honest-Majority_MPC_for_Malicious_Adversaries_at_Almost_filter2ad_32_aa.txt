title:Two-Thirds Honest-Majority MPC for Malicious Adversaries at Almost
the Cost of Semi-Honest
author:Jun Furukawa and
Yehuda Lindell
Two-Thirds Honest-Majority MPC for Malicious
Adversaries at Almost the Cost of Semi-Honest󰂏
Jun Furukawa1 and Yehuda Lindell2
1 NEC Israel Research Center
PI:EMAIL
2 Bar-Ilan University and Unbound Tech Ltd., Israel󰂏󰂏
PI:EMAIL
Abstract. Secure multiparty computation (MPC) enables a set of par-
ties to securely carry out a joint computation of their private inputs
without revealing anything but the output. Protocols for semi-honest
adversaries guarantee security as long as the corrupted parties run the
speciﬁed protocol and ensure that nothing is leaked in the transcript.
In contrast, protocols for malicious adversaries guarantee security in the
presence of arbitrary adversaries who can run any attack strategy. Secu-
rity for malicious adversaries is typically what is needed in practice (and
is always preferred), but comes at a signiﬁcant cost.
In this paper, we present the ﬁrst protocol for a two-thirds honest major-
ity that achieves security in the presence of malicious adversaries at es-
sentially the exact same cost as the best known protocols for semi-honest
adversaries. Our construction is not a general transformation and thus
it is possible that better semi-honest protocols will be constructed which
do not support our transformation. Nevertheless, for the current state-of-
the-art for many parties (based on Shamir sharing), our protocol invokes
the best semi-honest multiplication protocol exactly once per multipli-
cation gate (plus some additional local computation that is negligible to
the overall cost). Concretely, the best version of our protocol requires
each party to send on average of just 2 2
3 elements per multiplication
gate (when the number of multiplication gates is at least the number
of parties). This is four times faster than the previous-best protocol of
Barak et al. (ACM CCS 2018) for small ﬁelds, and twice as fast as the
previous-best protocol of Chida et al. (CRYPTO 2018) for large ﬁelds.
1
Introduction
1.1 Background
Protocols for secure computation enable a set of parties with private inputs to
compute a joint function of their inputs while revealing nothing but the output.
󰂏 This paper appeared at ACM CCS 2019.
󰂏󰂏 Supported by the European Research Council under the ERC consolidators grant
agreement n. 615172 (HIPS), by the BIU Center for Research in Applied Cryptog-
raphy and Cyber Security in conjunction with the Israel National Cyber Bureau in
the Prime Minister’s Oﬃce, and by the Alter Family Foundation.
1
The security properties typically required from secure computation protocols
include privacy (meaning that nothing but the output is revealed), correctness
(meaning that the output is correctly computed), independence of inputs (mean-
ing that a party cannot choose its input as a function of the other parties’ inputs),
fairness (meaning that if one party gets output then so do all), and guaranteed
output delivery (meaning that all parties always receive output). Formally, the
security of a protocol is proven by showing that it behaves like an ideal exe-
cution with an incorruptible trusted party who computes the function for the
parties [5,16]. In some cases, fairness and guaranteed output delivery are not re-
quired. This is standard in the case of no honest majority (since not all functions
can be computed fairly without an honest majority), but can also be the case
otherwise in order to aid the construction of highly eﬃcient protocols (e.g., as
in [1,19]).
Protocols for secure computation must remain secure in the face of adversarial
behavior. There are many parameters determining the adversary. Three that are
of relevance to this paper are:
– Adversarial behavior: If the adversary is semi-honest, then it follows the
protocol speciﬁcation but may try to learn more than is allowed by inspecting
the protocol transcript. If the adversary is malicious, then it may follow an
arbitrary attack strategy in its attempt to break the protocol.
– Adversarial power: If the protocol is guaranteed to remain secure even if
the adversary is computationally unlimited, then the protocol is said to be
information-theoretically secure. If the adversary is bounded to probabilistic
polynomial-time, then the protocol is computationally secure.
– Number of corruptions: Denote by t the number of corrupted parties and
by n the overall number of parties. There are typically three main thresholds
that are considered in the literature: t  n. Let α1, . . . , αn ∈ F. We
have the following procedures:
– share(v): In this procedure, a dealer with a value v ∈ F, chooses random
a1, . . . , at ∈ F and deﬁnes p(x) = v +󰁓t
i=1 ai · xi. The dealer then sends
p(αj) to party Pj, for j = 1, . . . , n. We denote by [v] the case whereby all
parties hold a sharing of v. We will sometimes consider sharings via degree-t
polynomials, and sometimes via degree-2t polynomials. When this distinction
is needed, we will denote such sharings by [v]t and [v]2t, respectively.
We stress that if the dealer is corrupted, then the shares received by the
parties may not be correct in that the dealer may deﬁne a polynomial of
degree greater than t. In such a case, we call the sharing invalid; else we call
it valid. We remark that we will abuse notation and say that the parties hold
shares [v] even if these are invalid.
– complete(vi1 , . . . , vit+1 ): Given t + 1 shares vi1 , . . . , vit+1 , this procedure in-
terpolates to ﬁnd the unique polynomial p passing through all these points,
and v = p(0). Then, complete outputs the remaining n− t− 1 shares deﬁned
by p.
5
– reconstruct([v]t, i): Given a sharing [v]t and an index i held by the parties,
all parties send their shares of [v]t to Pi. Party Pi veriﬁes that all points