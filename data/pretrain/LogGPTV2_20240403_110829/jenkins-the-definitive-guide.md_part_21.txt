(see Section 7.5, “Authorization—Who Can Do What”), you can write a second script, which determines
the groups for a given user. This groups uses the U environment variable to determine which user is
trying to log on, and prints a comma-separated list of groups for this user to the standard output. If you
don’t like commas, you can override the separating character in the configuration. A simple Groovy
script to do this job is shown here:
def env = System.getenv()
def username = env['U']
println findGroupsFor(username)
System.exit 0
def findGroupsFor(def username) {
return "admin,game-of-life-developer"
}
Both these scripts must return 0 when called for a user to be authenticated.
7.5. Authorization—Who Can Do What
Once you have defined how to identify your users, you need to decide what they are allowed to do.
Jenkins supports a variety of strategies in this area, ranging from a simple approach where a logged-in
user can do anything to more involved roles and project-based authentication strategies.
7.5.1. Matrix-based Security
Letting signed-in users do anything is certainly flexible, and may be all you need for a small team. For
larger or multiple teams, or cases where Jenkins is being used outside the development environment, a
more sophisticated approach is generally required.
Matrix-based security is a more sophisticated approach, where different users are assigned different
rights, using a role-based approach.
7.5.1.1. Setting up matrix-based security
The first step in setting up matrix-based security in Jenkins is to create an administrator. This is an
essential step, and must be done before all others. Now your administrator can be an existing user, or
one created specially for the purpose. If you want to create a dedicated administrator user, simply create
one by signing up in the usual way (see Figure 7.2, “The Jenkins Sign up page”). It doesn’t have to be
associated with an SCM user.
Once you have your admin user ready, you can activate matrix-based security by selecting “Matrix-
based security” in the Authorization section of the main configuration page. Jenkins will display a table
containing authorized users, and checkboxes corresponding to the various permissions that you can
assign to these users (see Figure 7.16, “Matrix-based security configuration”).
183
Figure 7.16. Matrix-based security configuration
The special “anonymous” user is always present in the table. This user represents unauthenticated users.
Typically, you only grant very limited rights to unauthenticated users, such as read-only access, or no
access at all (as shown in Figure 7.16, “Matrix-based security configuration”).
The first thing you need to do now is to grant administration rights to your administrator. Add your
administration user in the “User/group to add” field and click on Add. Your administrator will now
appear in the permissions matrix. Now make sure you grant this user every permission (see Figure 7.17,
“Setting up an administrator”), and save your configuration. You should now be able to log in with
your administrator account (if you aren’t already logged in with this account) and continue to set up
your other users.
Figure 7.17. Setting up an administrator
7.5.1.2. Fine-tuning user permissions
Once you have set up your administrator account, you can add any other users that need to access your
Jenkins instance. Simply add the user names and tick the permissions you want to grant them (see
Figure 7.18, “Setting up other users”). If you are using an LDAP server or Unix users and groups as
the underlying authentication schema (see Section 7.4.2, “Using an LDAP Repository”), you can also
configure permissions for groups of users.
Figure 7.18. Setting up other users
184
You can grant a range of permissions, which are organized into several groups: Overall, Slave, Job, Run,
View and SCM. Most of the permissions are fairly obvious, but some need a little more explanation.
The individual permissions are as follows:
Overall
This group covers basic system-wide permissions:
Administer
Lets a user make system-wide configuration changes and other sensitive operations, for
example in the main Jenkins configuration pages. This should be reserved for the Jenkins
administrator.
Read
This permission provides read-only access to virtually all of the pages in Jenkins. If you
want anonymous users to be able to view build jobs freely, but not to be able to modify or
start them, grant the Read role to the special “anonymous” user. If not, simply revoke this
permission for the Anonymous user. And if you want all authenticated users to be able to
see build jobs, then add a special user called “authenticated”, and grant this user Overall/
Read permission.
Slave
This group covers permissions about remote build nodes, or slaves:
Configure
Create and configure new build nodes.
Delete
Delete build nodes.
Job
This group covers job-related permissions:
Create
Create a new build job.
Delete
Delete an existing build job.
Configure
Update the configuration of an existing build jobs.
Read
View build jobs.
Build
Start a build job.
185
Workspace
View and download the workspace contents for a build job. Remember, the workspace
contains source code and artifacts, so if you want to protect these from general access, you
should revoke this permission.
Release
Start a Maven release for a project configured with the M2Release plugin.
Run
This group covers rights related to particular builds in the build history:
Delete
Delete a build from the build history.
Update
Update the description and other properties of a build in the build history. This can be useful
if a user wants to leave a note about the cause of a build failure, for example.
View
This group covers managing views:
Create
Create a new view.
Delete
Delete an existing view.
Configure
Configure an existing view.
SCM
Permissions related to your version control system:
Tag
Create a new tag in the source code repository for a given build.
Others
There can also be other permissions available, depending on the plugins installed. One useful
one is:
Promote
If the Promoted Builds plugin is installed, this permission allows users to manually promote
a build.
7.5.1.3. Help! I’ve locked myself out!
Now it may happen that, during this process, you may end up locking yourself out of Jenkins. This
can happen if, for example, you save the matrix configuration without having correctly set up your
186
administrator. If this happens, do not panic—there is an easy fix, as long as you have access to Jenkins’s
home directory. Simply open up the config.xml file at the root of the Jenkins home directory. This
will contain something like this:
1.391
2
NORMAL
true
...
The thing to look for is the  element. To restore your access to Jenkins, change this
value to false, and restart your server. You will now be able to access Jenkins again, and set up your
security configuration correctly.
7.5.2. Project-based Security
Project-based security lets you build on the matrix-based security model we just discussed, and apply it
to individual projects. Not only can you assign system-wide roles for your users, you can also configure
more specific rights for certain individual projects.
To activate project-level security, select “Project-based Matrix Authorization Strategy” in the
Authorization section of the main configuration screen (see Figure 7.19, “Project-based security”).
Here, you set up the default rights for users and groups, as we saw with Matrix-based security (see
Section 7.5.1, “Matrix-based Security”).
Figure 7.19. Project-based security
These are the default permissions that apply to all projects that have not been specially configured.
However, when you use project-based security, you can also set up special project-specific permissions.
You do this by selecting “Enable project-based security” in the project configuration screen (see
Figure 7.20, “Configuring project-based security”). Jenkins will display a table of project-specific
permissions. You can configure these permissions for different users and groups just like on the system-
wide configuration page. These permissions will be added to the system-wide permissions to produce
a project-specific set of permissions applicable for this project.
187
Figure 7.20. Configuring project-based security
The way this works is easiest to understand with a few practical examples. In Figure 7.19, “Project-based
security”, for instance, no permissions have been granted to the anonymous user, so by default all build
jobs will remain invisible until a user signs on. However, we are using project-based security, so we
can override this on a project-by-project basis. In Figure 7.20, “Configuring project-based security”, for
example, we have set up the game-of-life project to have read-only access for the special “anonymous”
user.
When you save this configuration, unauthenticated users will be able to see the game-of-life project
in read-only mode (see Figure 7.21, “Viewing a project”). This same principle applies with all of the
project-specific permissions.
Figure 7.21. Viewing a project
Note that Jenkins permissions are cumulative—at the time of writing, there is no way to revoke a system-
wide permission for a particular project. For example, if the anonymous user has read-access to build
jobs at the system level, you can’t revoke read-only access for an individual project. So when using
188
project-based security, use the system level matrix to define minimum default permissions applicable
across all of your projects, and set up projects with additional project-specific authorizations.
There are many approaches to managing project permissions, and they depend as much on organizational
culture as on technical considerations. One common strategy approach is to allow team members to have
full access to their own projects, and read-only access to other projects. The Extended Read Permission
plugin is a useful extension to have for this scenario. This plugin lets you let users from other teams see
a read-only view of your project configuration, without being able to modify anything (see Figure 7.22,
“Setting up Extended Read Permissions”). This is a great way to share build configuration practices and
tips with other teams without letting them tamper with your builds.
Figure 7.22. Setting up Extended Read Permissions
It is worth noting that, whenever large and/or multiple teams are involved, the internal Jenkins database
reaches its limits quite quickly, and it is worth considering integrating with a more specialized directory
service such as an LDAP server, Active Directory or Atlassian Crowd, or possibly a more sophisticated
permission system such as role-based security, discussed in the following section.
7.5.3. Role-based Security
Sometimes managing user permissions individually can be cumbersome, and you may not want to
integrate with an LDAP server to set up groups that way. A more recent alternative option is to use
the Role Strategy plugin, which allows you to define global and project-level roles, and assign these
roles to users.
You install the plugin in the usual way, via the Plugin Manager. Once installed, you can activate
this authorization strategy in the main configuration page (see Figure 7.23, “Setting up Role-based
security”).
Figure 7.23. Setting up Role-based security
189
Once you have set this up, you can define roles that regroup sets of related permissions. You set up and
configure your roles, and assign these roles to your users, in the Manage Roles screen, which you can
access in the Manage Jenkins screen (see Figure 7.24, “The Manage Roles configuration menu”).
Figure 7.24. The Manage Roles configuration menu
In the Manage Roles screen, you can set up global and project-level permissions. Global permissions
apply across all projects, and are typically system-wide administration or general access permissions
(see Figure 7.25, “Managing global roles”). Setting these roles up is intuitive and similar to setting up
user permissions in the other security models we have seen.
Figure 7.25. Managing global roles
Project roles are slightly more complicated. A project role regroups a set of permissions that are
applicable to one or more (presumably related) projects. You define the relevant projects using a
regular expression, so it helps to have a clear and consistent set of naming conventions in place for
your project names (see Figure 7.26, “Managing project roles”). For example, you may wish to create
roles distinguishing developers with full configuration rights on their own project from users who can
simply trigger a build and view the build results, or create roles where developers can configure certain
automated deployment build jobs, but only production teams are allowed to execute these jobs.
190
Figure 7.26. Managing project roles
Once you have defined these roles, you can go to the Assign Roles screen to set up individual users or
groups with these roles (see Figure 7.27, “Assigning roles to users”).
Figure 7.27. Assigning roles to users
Role-based strategy is relatively new in Jenkins, but it is an excellent way to simplify the task of
managing permissions in large, multiteam and multiproject organizations.
7.6. Auditing—Keeping Track of User Actions
In addition to configuring user accounts and access rights, it can also be useful to keep track of the
individual user actions: in other words, who did what to your server configuration. This sort of audit
trail facility is even required in many organizations.
191
There are two Jenkins plugins that can help you do this. The Audit Trail plugin keeps a record of user
changes in a special log file. And the JobConfigHistory plugin lets you keep a copy of previous versions
of the various system and job configuration files that Jenkins uses.
The Audit Trail Plugin keeps track of the main user actions in a set of rolling log files. To set this up,
go to the Plugin Manager page and select the Audit Trail plugin in the list of available plugins. Then,
as usual, click on Install and restart Jenkins once the plugin has been downloaded.
You can set up the audit trail configuration in the Audit Trail section of the main Jenkins configuration
page (see Figure 7.28, “Configuring the Audit Trail plugin”). The most important field is the Log
Location, which is where you indicate the directory in which the log files are to be written. The audit trail
is designed to produce system-style log files, which are often placed in a special system directory such
as /var/log. You can also configure the number of log files to be maintained, and the (approximate)
maximum size of each file. The simplest option is to provide an absolute path (such as /var/log/
hudson.log), in which case Jenkins will write to log files with names like /var/log/hudson.log.1,
/var/log/hudson.log.2, and so forth. Of course, you need to ensure that the user running your
Jenkins instance is allowed to write to this directory.
Figure 7.28. Configuring the Audit Trail plugin
You can also use the format defined in the Java logging FileHandler1 class for more control over the
generated log files. In this format, you can insert variables such as %h, for the current user’s home
directory, and %t, for the system temporary directory, to build a more dynamic file path.
By default, the details recorded in the audit logs are fairly sparse—they effectively record key actions
performed, such as creating, modifying or deleting job configurations or views, and the user who
performed the actions. The log also shows how individual build jobs started. An extract of the default
log is shown here:
Dec 27, 2010 9:16:08 AM /job/game-of-life/configSubmit by johnsmart
Dec 27, 2010 9:16:42 AM /view/All/createItem by johnsmart
Dec 27, 2010 9:16:57 AM /job/game-of-life-prod-deployment/doDelete by johnsmart
Dec 27, 2010 9:24:38 AM job/game-of-life/ #177 Started by user johnsmart
Dec 27, 2010 9:25:57 AM job/game-of-life-acceptance-tests/ #107 Started by upstream
project "game-of-life" build number 177
Dec 27, 2010 9:25:58 AM job/game-of-life-functional-tests/ #7 Started by upstream
1 http://download.oracle.com/javase/1.5.0/docs/api/java/util/logging/FileHandler.html
192
project "game-of-life" build number 177
Dec 27, 2010 9:28:15 AM /configSubmit by johnsmart
This audit trail is certainly useful, especially from a system administration perspective. However, it
doesn’t provide any information about the exact changes that were made to the Jenkins configuration.
Nevertheless, one of the most important reasons to keep track of user actions in Jenkins is to keep tabs
on exactly what changes were made to build job configurations. When something goes wrong, it can
be useful to know what changes were done and so be able to undo them. The JobConfigHistory plugin
lets you do just this.
The JobConfigHistory plugin is a powerful tool that lets you keep a full history of changes made to
both job and system configuration files. You install it from the Plugin Manager in the usual way. Once
installed, you can fine-tune the job history configuration in the Manage Jenkins screen (see Figure 7.29,
“Setting up Job Configuration History”).
Figure 7.29. Setting up Job Configuration History
Here, you can configure a number of useful nonstandard options. In particular, you should specify