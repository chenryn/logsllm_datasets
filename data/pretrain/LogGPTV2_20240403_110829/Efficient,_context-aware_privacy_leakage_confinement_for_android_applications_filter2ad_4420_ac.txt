### 优化后的文本

#### Java 代码示例
```java
private static String deviceId;
public static boolean deviceId_s0_t;

public String getIMEI(BoolWrapper ret_s0_wrapper) {
    String imei = manager.getDeviceId();
    if (imei == null) {
        imei = "";
        imei_s0_t = false;
    } else {
        imei_s0_t = true;
    }
    ret_s0_wrapper.status = imei_s0_t;
    return imei;
}

public void post(String addr, byte[] bytes, BoolWrapper bytes_s0_wrapper) {
    boolean bytes_s0_t = bytes_s0_wrapper.status;
    OutputStream output = conn.getOutputStream();
    boolean isAllow = false;
    if (bytes_s0_t) {
        isAllow = queryPolicyService(0, 0, addr);
    }
    if (isAllow) {
        output.write(bytes, 0, bytes.length);
    } else {
        // 处理不允许的情况
    }
}

public void onStart() {
    BoolWrapper ret_s0_wrapper = new BoolWrapper();
    ret_s0_wrapper.status = false;
    Leakage.deviceId = getIMEI(ret_s0_wrapper);
    Leakage.deviceId_s0_t = ret_s0_wrapper.status;
}

public void onDestroy() {
    String imei = Leakage.deviceId;
    byte[] bytes = imei.getBytes();
    boolean bytes_s0_t = Leakage.deviceId_s0_t;
    for (int i = 0; i < bytes.length; i++) {
        bytes[i] = crypt(bytes[i]);
        bytes_s0_t = bytes_s0_t || false;
    }
    BoolWrapper bytes_s0_wrapper = new BoolWrapper();
    bytes_s0_wrapper.status = bytes_s0_t;
    post(addr, bytes, bytes_s0_wrapper);
}
```

### 用户决策和数据流建模
为了使用户在相同的场景下不再反复面对烦人的对话框，我们需要适当地建模与用户决策相关的程序上下文。然而，从数据流的角度提取语义是具有挑战性的。以下是几种可能的方案及其优缺点。

#### 4.1 污点传播追踪
为了实现高精度，我们首先考虑使用精确的执行跟踪作为特定信息流的模式。执行跟踪可以在指令或方法级别获取。它包含从源到汇的所有传播敏感数据的指令或方法，因此可以唯一地描述一个数据流路径。当用户对某个信息流做出决策时，其执行跟踪将被计算并保存为模式，并附带用户偏好。下次检测到新的泄漏实例时，将计算新的流的跟踪并与已保存的进行比较。如果存在匹配，则应用已保存的操作。

然而，这种方法有两个主要缺点：
1. 动态跟踪非常耗时，比较两个跟踪也非常昂贵，这可能会影响交互式移动应用的响应性。
2. 每个数据流实例都被建模得过于精确。任何执行分歧都会导致不同的跟踪模式，即使两个泄漏流在相同语义下发生，也难以匹配它们的跟踪。这会导致对于语义等价的隐私相关数据流重复显示警告消息。

#### 4.2 源和汇调用点
基于跟踪的方法过于昂贵，因为控制粒度非常细。因此，我们尝试放宽严格性，在准确性和效率之间取得平衡。我们提出了一种调用点方法，结合源和汇调用点来建模隐私流。也就是说，具有相同源和汇调用点的信息流被归为一类。一旦在一个泄漏流上采取了操作，未来的同类敏感信息流也将采取相同的操作。为此，我们引入了源和汇调用点的标签。从这些调用点开始或到达这些调用点的信息流将与相应的标签关联，以便根据这些标签进行区分。

这种方法在效率上有显著提高，但对程序上下文的敏感度不如基于跟踪的方法——不同的执行路径可以从相同的源开始并在相同的汇结束。然而，我们在实践中很少观察到这种不准确性，因为具有相同源和汇调用点的应用执行通常代表恒定的语义。

#### 4.3 参数化的源和汇对
除了源/汇调用点外，传递给这些调用点API的参数对语义上下文也至关重要。例如，用户可能允许应用程序向某些可信的URL发送数据，但不愿意允许访问其他URL。因此，比较关键参数以确定新观察到的流是否与历史记录中的流匹配非常重要。

注意，检查参数可以最小化模仿攻击的影响。先前的研究表明，易受攻击的Android应用程序容易受到各种攻击[9, 16, 18, 24, 37]。例如，暴露的易受攻击的应用组件可能会被利用，将私有信息泄露给攻击者指定的URL。如果不考虑URL参数，很难（如果不是不可能的话）区分关键调用点的内部使用和针对恶意URL劫持同一调用点的行为。一旦通过某些调用点的数据流被允许并且用户偏好被保存，使用相同调用点的模仿攻击也会得到批准。相反，参数感知方法可以根据目标URL区分传出的数据流，从而防止对以前允许的调用点的利用。

| API 描述 | 源或汇 | 关键参数 |
| --- | --- | --- |
| 向互联网发送数据 | 汇 | 目标URL |
| 发送短信 | 汇 | 目标电话号码 |
| 查询联系人数据库 | 源 | 源URI |

除了Internet API的URL外，我们还考虑了一些其他关键的API及其参数组合。表1总结了我们的列表。汇API的目标对安全性很敏感。类似于Internet API，目标电话号码对sendTextMessage() API也很重要，因此需要监控。另一方面，一些源调用点也需要根据参数进行区分。例如，查询联系人列表的API可能根据输入的URI（如ContactsContract.CommonDataKinds.Phone用于电话号码，ContactsContract.CommonDataKinds.Email用于电子邮件）获取不同的数据。

#### 4.4 实现
我们将策略服务实现为一个单独的应用程序。这种隔离保证了服务应用及其保存的策略的安全性。换句话说，即使客户端被利用，服务也不会受到影响或被破坏，并且仍然可以正确执行隐私策略。

服务应用仅通过Android IPC与重写的客户端应用通信。一旦客户端应用想要查询服务，它会将源和汇调用点的标签以及特定的关键参数封装到Intent中作为额外数据负载。客户端应用然后被阻塞并等待响应。由于此事务通常很快，阻塞不会影响应用程序的响应性。在服务端，它解码数据并在其数据库中搜索匹配项。如果存在匹配项，它会立即返回保存的操作给客户端。否则，服务应用将在创建的Activity中显示一个对话框。如果用户愿意，用户的决定会被保存；否则不会保存。无论如何，用户的选项都会发送回客户端。收到服务的响应后，重写的应用程序将继续执行或跳过汇调用点，具体取决于回复。

值得注意的是，我们必须防御欺骗攻击并防止伪造的消息被发送到客户端应用。为此，我们对客户端应用进行了插桩，使其通过动态注册的BroadcastReceiver监听服务的回复。当接收到广播消息时，接收器会立即取消注册。因此，由于按需接收器注册，攻击窗口减小。此外，为了限制谁可以发送广播，我们使用自定义权限保护接收器。没有此权限的广播发送者无法向客户端应用发送消息。为了防止重放攻击，我们还在初始查询消息中嵌入了一个会话令牌，从而使客户端应用能够验证响应消息的发送者身份。

类似地，我们也需要保护策略服务免受欺骗。服务应用必须通过getCallingUid()检查绑定通信的调用者身份，以防止恶意应用程序假装成另一个应用程序并欺骗服务为其配置策略。

#### 4.5 运行示例中的策略执行
我们根据调用点及其关键输入来区分信息流。因此，在这个示例中，queryPolicyService()接受三个参数。第一个“0”和第二个“0”分别表示源和汇调用点的标签。第三个参数是一个特定于调用点API的对象，接受关键输入。根据策略服务的回复（即isAllow），应用程序中的强制逻辑将被执行。如果用户决定阻止数据流，我们需要适当地跳过output.write()并禁用泄漏。

### 实验评估
为了评估Capper的有效性、正确性和效率，我们在真实世界的Android应用程序上进行了实验。在策略设置中，我们考虑IMEI、机主电话号码、位置、联系人作为敏感信息源，网络输出API（如OutputStream.write()、HttpClient.execute()、WebView.loadUrl()、URLConnection.openConnection()和SmsManager.sendTextMessage()）作为汇。汇上的操作可以是“阻止”或“允许”。用户还可以选择“总是”选项，以便将相同的规则应用于未来相同语义上下文的情况。请注意，此策略主要用于演示Capper的可用性。还需要更多工作来定义更完整的隐私泄漏限制策略。

我们首先介绍实验设置（第5.1节）。然后讨论汇总分析结果（第5.2节），并详细描述分析（第5.3节）。最后，我们在第5.4节中测量运行时性能。

#### 5.1 实验设置
我们从Google Play收集了11,939个真实世界的Android应用程序，并对这些应用程序进行了包级别的初步调查。

- **本地组件的使用**：在11,939个应用程序中，有2631个至少包含一个本地库。这表明只有一小部分Android应用程序（22%）需要辅助本地代码才能运行。此外，我们发现大量这些本地库在这些应用程序中是通用的。这些本地库通常用于视频/音频处理、编码/解码等。例如，libandroidgl20.so（Android系统的OpenGL图形库）被265个应用程序使用。
  
- **框架兼容性**：碎片化是Android平台众所周知的问题。应用程序使用不同版本的框架SDK开发，包括Google Maps、Google Analytics、Admob等支持库，因此需要不同集合的Google API进行分析和插桩。在我们的实验中，我们准备了一组特定的库，包括API级别16（Android 4.1，Jelly Bean）的Android SDK、API级别16的Google Maps、Google Analytics SDK v2和Google Admob SDK版本6.2.1。然后，我们检查Manifest文件并排除那些不符合我们设置的应用程序。最终，我们获得了4915个应用程序，并将其用作我们的实验样本集。当然，要在现场使用Capper，需要多套API来满足应用程序中多样化的SDK需求。

然后，我们对这些应用程序进行字节码重写，以启用运行时隐私保护。我们在测试机器上进行实验，该机器配备Intel(R) Xeon(R) CPU E5-2690（20M缓存，2.90GHz）和200GB物理内存。操作系统是CentOS 6.3（64位）。

为了验证重写应用程序的有效性和评估运行时性能，我们进一步在真实设备上运行它们。实验在Google Nexus S上进行，Android OS版本为4.0.4。

#### 5.2 汇总分析结果
图4展示了4915个真实世界应用程序的分布情况。其中，Capper在30分钟内未能完成对314个应用程序的分析。这些应用程序相当大（许多超过10 MB）。应用程序范围的数据流分析对于这些大型程序来说是昂贵的。我们将分析超时时间延长至3小时，又有122个应用程序成功进行了分析和重写。给定足够的分析时间，我们认为成功率可以从目前的96%进一步提高到接近100%。

在由Capper完全处理的4723个应用程序中，根据静态分析，有1414个应用程序可能会泄露私人信息，Capper成功对其进行了字节码重写。我们观察到大多数应用程序泄露IMEI和位置信息。由于分析或广告原因，这些类型的信息经常被应用程序发送出去。应用程序有时也会泄露机主电话号码或联系人中的电话号码。对于其余的应用程序（67%），静态分析未能找到从敏感信息源到网络输出汇的可行路径。这意味着这些应用程序不会泄露私人信息，因此不需要对其进行重写。

对于这1414个重写的应用程序，我们进一步调查了它们对本地代码和反射的使用。研究表明，在118个（2%）应用程序中，未知的本地代码在污点切片中被调用。作为字节码级解决方案，我们的系统无法跟踪本地代码中的信息流处理。因此，这些未知的本地调用可能导致信息流中断。另外3%的应用程序包含反射调用。如果类名和方法名不能静态解析，我们不知道信息是如何通过这些函数传播的。因此，总共5%的应用程序可能是不安全的，并且可能无法完全执行指定的策略。对最终用户的最佳建议是不要使用这些不安全的重写应用程序，因为可能存在策略执行的不完整性。关于这个问题的更多讨论将在后续章节中呈现。