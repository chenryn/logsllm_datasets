35
I
I
36
I
37
43
44
45
I
46
47
I
48
I
I
49
50
51 }
...
private static String deviceId;
public static boolean deviceId_s0_t;
...
public String getIMEI(BoolWrapper ret_s0_wrapper){
...
String imei = manager.getDeviceId();
if(imei==null){
imei = "";
imei_s0_t = false;
}else{
imei = manager.getDeviceId();
imei_s0_t = true;
}
ret_s0_wrapper.status = imei_s0_t;
return imei;
}
...
public void post(String addr, byte[] bytes,
BoolWrapper bytes_s0_wrapper){
boolean bytes_s0_t = bytes_s0_wrapper.status;
OutputStream output = conn.getOutputStream();
boolean isAllow = false;
if(bytes_s0_t == true)
isAllow = queryPolicyService(0, 0, addr);
if(isAllow){
output.write(bytes, 0, bytes.length);}
else{ ... }
...
}
...
public void onStart(){
BoolWrapper ret_s0_wrapper = new BoolWrapper();
ret_s0_wrapper.status = false;
Leakage.deviceId = getIMEI(ret_s0_wrapper);
Leakage.deviceId_s0_t = ret_s0_wrapper.status;
}
...
public void onDestroy(){
String imei = Leakage.deviceId;
byte[] bytes = imei.getBytes();
boolean bytes_s0_t = Leakage.devicdId_s0_t;
for(int i=0; i<bytes.length; i++){
bytes[i] = crypt(bytes[i]);
bytes_s0_t = bytes_s0_t || false;
}
BoolWrapper bytes_s0_wrapper = new BoolWrapper();
bytes_s0_wrapper.status = bytes_s0_t;
post(addr, bytes, bytes_s0_wrapper);
}
Figure 3: Java Code for the Rewritten Program
be remembered and used for the same scenario next time. Thus,
the user doesn’t need to face the annoying dialog message over and
over again for the exactly identical situation.
However, it is non-trivial to appropriately model the program
context speciﬁc to a user decision and the challenge lies in the way
semantics is extracted from a dataﬂow point of view. We hereby
discuss some possible options and our solution.
4.1 Taint Propagation Trace
To achieve high accuracy, we ﬁrst consider using the exact ex-
ecution trace as pattern to represent a speciﬁc information ﬂow.
An execution trace can be obtained at either instruction or method
level. It consists of all the instructions or methods propagating sen-
sitive data from a source to a sink, and therefore can uniquely de-
scribe a dataﬂow path. When a user decision is made for a certain
information ﬂow, its execution trace is computed and saved as a
pattern along with user preference. Next time when a new leakage
instance is detected, the trace computation will be done on the new
ﬂow and compared with saved ones. If there exists a match, action
taken on the saved one will be applied correspondingly.
263Nevertheless, there exist two major drawbacks with this approach.
Firstly, dynamic tracing is considerably heavy-weight. Comparison
of two traces is also fairly expensive. This may affect the respon-
siveness of interactive mobile apps. Secondly, each dataﬂow in-
stance is modeled overly precisely. Since any execution divergence
will lead to a different trace pattern, even if two leakage ﬂows occur
within the same semantics, it is still difﬁcult to match their traces.
This results in repeated warning messages for semantically equiva-
lent privacy-related dataﬂows.
4.2 Source and Sink Call-sites
Trace-based approach is too expensive because the control gran-
ularity is extremely ﬁne. We therefore attempt to relax the strict-
ness and achieve balance in the accuracy-efﬁciency trade-off. We
propose a call-site approach which combines source-sink call-sites
to model privacy ﬂow. That is to say, information ﬂows of same
source and sink call-sites are put into one category. Once an ac-
tion is taken on one leakage ﬂow, the same action will be taken
on future sensitive information ﬂow in the same category. To this
end, we introduce labels for source and sink call-sites. Informa-
tion ﬂows starting from or arriving at these call-sites are associated
with corresponding labels, so that they can be differentiated based
on these labels.
With a signiﬁcant improvement of efﬁciency, this approach is
not as sensitive to program contexts as the traced-based one - dif-
ferent execution paths can start from the same origin and end at the
same sink. However, we rarely observed this inaccuracy in prac-
tice because the app execution with same source and sink call-sites
usually represents constant semantics.
4.3 Parameterized Source and Sink Pairs
In addition to source/sink call-sites, parameters fed into these
call-sites APIs are also crucial to the semantic contexts. For exam-
ple, the user may allow an app to send data to certain trustworthy
URLs but may not be willing to allow access to the others. There-
fore, it is important to compare critical parameters to determine if
a new observed ﬂow matches the ones in history.
Notice that checking parameters can minimize the impact of mimicry
attack. Prior research shows that vulnerable Android apps are sub-
ject to various attacks [9, 16, 18, 24, 37]. For instance, an exposed
vulnerable app component can be exploited to leak private infor-
mation to an attacker-speciﬁed URL. Without considering the URL
parameter, it is difﬁcult, if not possible, to distinguish internal use
of critical call-sites from hijacking the same call-sites to target a
malicious URL. Once a ﬂow through some call-sites is allowed
and user preference is saved, mimicking attack using same call-
sites will also get approved. On the contrary, a parameter-aware
approach can differentiate outgoing dataﬂows according to the des-
tination URL, and thus, exploitation of a previously allowed call-
sites will still raise a warning.
API Description
Send data to Internet
Send SMS message
Query contacts database
Source or Sink
Sink
Sink
Source
Critical Parameter
destination URL
target phone number
source URI
Table 1: APIs and Critical Parameters
Besides the URL of a Internet API, we also consider some other
critical combinations of an API and its parameter. Table 1 sum-
marizes our list. The target of a sink API is sensitive to secu-
rity. Similar to Internet APIs, target phone numbers are crucial
to sendTextMessage() APIs and thus need watching. On the
other hand, some source call-sites also need to be distinguished ac-
cording to the parameters. For instance, the API that queries con-
tacts list may obtain different data depending on the input URI (e.g.,
ContactsContract.CommonDataKinds.Phone for phone num-
ber, ContactsContract.CommonDataKinds.Email for email).
4.4 Implementation
We implement the policy service as a separate app. This isolation
guarantees the security of the service app and its saved policies.
In other words, even if the client is exploited, the service is not
affected or compromised, and can still correctly enforce privacy
policies.
The service app communicates with a rewritten client app solely
through Android IPC. Once a client app wants to query the service,
it encapsulates the labels of source and sink call-sites as well as
the speciﬁc critical parameter into an Intent as extra data pay-
load. The client app is then blocked and waiting for a response.
Since this transaction is usually fast, the blocking won’t affect the
responsiveness of the app mostly. On the service side, it decodes
the data and searches for a match in its database. If there exists a
match, it returns immediately with the saved action to the client.
Otherwise, the service app will display a dialog message within a
created Activity. The user decision is saved if the user prefers,
or not saved otherwise. Either way, user’s option is sent back to
the client. On receiving the response from service, the rewritten
app will either continue its execution or skip the sink call-site with
respect to the reply.
It is noteworthy that we have to defend against spooﬁng attack
and prevent forged messages from being sent to a client app. To ad-
dress that, we instrument the client app to listen for the service re-
ply with a dynamically registered BroadcastReceiver. When
a broadcast message is received, the receiver is immediately unreg-
istered. Thus, attack window is reduced due to this on-demand re-
ceiver registration. Further, to restrict who can send the broadcast,
we protect the receiver with a custom permission. Broadcaster
without this permission is therefore unable to send messages to
the client app. To defeat replay attack, we also embed a session
token in the initial query message, and the client app can therefore
authenticate the sender of a response message.
Similarly, we need to protect a policy service from spooﬁng, too.
The service app has to check the caller identity from a bound com-
munication via getCallingUid(), so that a malicious appli-
cation cannot pretend to be another app and trick the service to
conﬁgure the policies for the latter.
4.5 Policy Enforcement in Running Example
We distinguish an information ﬂow based on call-sites and their
critical input. Therefore, here in this example, queryPolicyService()
takes three parameters. The ﬁrst “0” and second “0” represent the
labels of source and sink call-sites, respectively. The third one is
an object taking the critical input and is speciﬁc to a call-site API.
With the reply from policy service (i.e., isAllow), the enforce-
ment logic devised in the app will be exercised. If the user decision
is to block the dataﬂow, we need to properly skip the output.write()
and disable the leakage.
5. EXPERIMENTAL EVALUATION
To evaluate the efﬁcacy, correctness and efﬁciency of Capper,
we conducted experiments on real-world Android applications. In
the policy setting, we consider IMEI, owner’s phone number, lo-
cation, contacts to be the sensitive information sources, and net-
work output APIs (e.g., OutputStream.write(), HttpClient.
execute(), WebView.loadUrl(), URLConnection.
openConnection() and SmsManager.sendTextMessage()) as
the sinks. The action on the sink can be “block” or “allow”. User
264can also check an “always” option to have the same rule applied to
future cases of the same semantic context. Note that this policy is
mainly for demonstrating the usability of Capper. More work is
needed to deﬁne a more complete policy for privacy leakage con-
ﬁnement.
We ﬁrst present our experiment setup and in Section 5.1. We then
discuss summarized analysis results in Section 5.2, and describe a
detailed analysis in Section 5.3. Finally we measure the runtime
performance in Section 5.4.
5.1 Experiment Setup
We collect 11,939 real-world Android applications from Google
Play, and perform a preparatory package-level investigation into
these apps.
Use of Native Components.
Out of the 11,939 apps, 2631 of them enclose at least one native
library in the package. This shows that a small portion of Android
apps (22%) need auxiliary native code to function.
In addition,
we discover that a large amount of these native libraries are com-
monly used across these apps. These native libraries are often used
for video/audio processing, encoding/decoding, etc. For example,
libandroidgl20.so, an OpenGL graphical library for Android sys-
tem, is used by 265 apps.
Framework Compatibility.
Fragmentation is a well-known issue for Android platform. Apps
are developed with different versions of framework SDK, as well
as supporting libraries including Google Maps, Google Analytics,
Admob, and therefore require different sets of Google APIs for
analysis and instrumentation. In our experiment, we prepare a set
of speciﬁc libraries which consist of Android SDK of API level 16
(Android 4.1, Jelly Bean), Google Maps of API level 16, Google
Analytics SDK v2 and Google Admob SDK, version 6.2.1. We
then inspect the Manifest ﬁles and exclude those apps that don’t ﬁt
into our setting. In the end, we obtain 4915 applications and use
them as our experiment sample set. Of course, to use Capper in
the ﬁeld, multiple sets of APIs are needed to accommodate diverse
SDK requirements in the apps.
We then perform bytecode rewriting on these apps to enable run-
time privacy protection. We conduct the experiment on our test
machine, which is equipped with Intel(R) Xeon(R) CPU E5-2690
(20M Cache, 2.90GHz) and 200GB of physical memory. The op-
erating system is CentOS 6.3 (64bit).
To verify the effectiveness and evaluate runtime performance of
the rewritten apps, we further run them on a real device. Experi-
ments are carried out on Google Nexus S, with Android OS version
4.0.4.
5.2 Summarized Analysis Results
Figure 4 illustrates the partition of 4915 realworld apps. Amongst
these apps, Capper did not ﬁnish analyzing 314 of them within 30
minutes. These apps are fairly large (many over 10 MB). Application-
wide dataﬂow analysis is known to be expensive for these large
programs. We further extended the analysis timeout to 3 hours, and
122 more apps were successfully analyzed and rewritten. Given
sufﬁcient analysis time, we believe that the success rate can further
increase from currently 96% to nearly 100%.
Out of the 4723 apps that were completely processed by Capper,
1414 apps may leak private information, according to our static
analysis, and Capper successfully performed bytecode rewriting
on them. We observed that most of them leak IMEI and loca-
tion information. These types of information are frequently sent
Figure 4: Bytecode Rewriting Results on 4915 Realworld Android
Apps
out by apps due to analytic or advertisement reasons. Apps may
also sometimes leak owner’s phone number or phone numbers from
contacts. For the rest of them (67%), static analysis couldn’t ﬁnd
a viable path from the sensitive information sources to the network
output sinks. It means that these apps do not leak private informa-
tion, so no rewriting is needed for these apps.
For these 1414 apps that were rewritten, we further investigate
their use of native code and reﬂection. Our study shows that un-
known native code is invoked within the taint slices for 118 (2%)
apps. As a bytecode-level solution, our system cannot keep track
of information ﬂow processing in the native code. So the informa-
tion ﬂow may be broken on these unknown native calls. The rest
3% contain reﬂective calls within the slices. If the class name and
method name cannot be resolved statically, we do not know how
information is propagated through this function. Therefore, totally
5% apps may be unsafe and may not be fully enforced with the
speciﬁed policies. The best suggestion for the end user is not to use
these unsafe rewritten apps due to the potential incompleteness in
policy enforcement. More discussion on this issue is presented in