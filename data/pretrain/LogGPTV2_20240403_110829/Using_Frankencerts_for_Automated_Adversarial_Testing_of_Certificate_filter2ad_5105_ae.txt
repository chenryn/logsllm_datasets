8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
123
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:02:03 UTC from IEEE Xplore.  Restrictions apply. 
TABLE V: Semantic discrepancies in certiﬁcate validation (incorrect answers in bold)
Problem
Untrusted version 1 intermediate CA
certiﬁcate
Untrusted version 2 intermediate CA
certiﬁcate
Version 1 certiﬁcate with valid basic
constraints
Intermediate CA not authorized to is-
sue further intermediate CA certiﬁ-
cates, but followed in the chain by an
intermediate CA certiﬁcate
. . . followed by a leaf CA certiﬁcate
Intermediate CA not authorized to is-
sue certiﬁcates for server’s hostname
Certiﬁcate not yet valid
Certiﬁcate expired in its timezone
CA certiﬁcate not authorized for sign-
ing other certiﬁcates
Server certiﬁcate not authorized for
use in SSL/TLS handshake
Server certiﬁcate not authorized for
server authentication
Certiﬁcate with unknown critical ex-
tension
Certiﬁcate with malformed extension
value
Certiﬁcate with the same issuer and
subject and a valid chain of trust
Issuer name does not match AKI
Issuer serial number does not match
AKI
Certiﬁcates
triggering
the problem
occur
in
the original
corpus
No
No
No
No
No
No
Yes
Yes
No
Yes
Yes
No
No
No
No
No
OpenSSL
PolarSSL
GnuTLS
CyaSSL MatrixSSL
NSS
OpenJDK,
Bouncy
Castle
Browsers
reject
reject
accept
reject
reject
reject
reject
reject
reject
reject
reject
reject
accept
reject
reject
reject
reject
reject
reject
reject
reject
reject
accept
accept
reject
accept
accept
reject
reject
reject
accept
accept
accept
reject
reject
reject
accept
accept
reject
reject
accept
accept
reject
reject
accept
accept
accept
accept
accept
accept
accept
reject
reject
accept
reject
reject
accept
accept
accept
accept
accept
reject
accept
accept
accept
accept
accept
accept
accept
accept
reject
accept
accept
accept
accept
accept
accept
accept
accept
accept
reject
reject
reject
reject
reject
reject
reject
reject
reject
reject
reject
reject
reject
reject
reject
reject
reject
reject
reject
reject
reject
reject
reject
reject
reject
reject
reject
reject
reject
reject
reject
reject
reject
reject
Firefox: reject
Opera, Chrome: accept
reject
reject
reject
reject
reject
reject
reject
reject
reject
reject
reject
reject
reject
32
33
34
35
36
}
}
}
/*perform other checks*/
...
There is an interesting dependency between the two
ﬂags. To prevent intermediate v1 certiﬁcates from being ac-
cepted, GNUTLS_VERIFY_ALLOW_X509_V1_CA_CRT must be false and
GNUTLS_VERIFY_DO_NOT_ALLOW_X509_V1_CA_CRT must be true. The
calling function sets the former, but not the latter. Therefore,
although by default GnuTLS is only intended to accept root
v1 certiﬁcates, in reality it accepts any v1 certiﬁcate.
The consequences of this bug are not subtle. If an ap-
plication based on GnuTLS trusts a v1 root CA certiﬁcate,
then any server certiﬁed by the same root can act as a
rogue CA, issuing fake certiﬁcates for any Internet domain
and launching man-in-the-middle attacks against this GnuTLS-
based application. Unfortunately, trusting v1 root certiﬁcates is
very common. For example, Gentoo Linux by default has 13 v1
root CA certiﬁcates, Mozilla has 9, and we observed thousands
of CA-issued v1 leaf certiﬁcates “in the wild” (Section VI).
Untrusted version 2 intermediate certiﬁcate. We never
observed X.509 version 2 certiﬁcates “in the wild,” but, for
the purposes of testing, did generate version 2 frankencerts.
As explained above, MatrixSSL silently accepts all CA
certiﬁcates whose version ﬁeld is less than 2 (i.e., version
number less than 3). In GnuTLS, gnutls_x509_crt_get_version
returns the actual version, not
following check blocks version 2 certiﬁcates:
the version ﬁeld, and the
issuer_version = gnutls_x509_crt_get_version (issuer);
// ...
if (!(flags & GNUTLS_VERIFY_DISABLE_CA_SIGN) &&
((flags &
GNUTLS_VERIFY_DO_NOT_ALLOW_X509_V1_CA_CRT)
|| issuer_version != 1))
{
}
// ...
Version 1 certiﬁcate with valid basic constraints. Basic
constraints were added only in X.509 version 3, but several
SSL/TLS implementations always verify basic constraints if
present in the certiﬁcate regardless of its version ﬁeld.
Some of our frankencert chains include version 1 interme-
diate certiﬁcates with correct basic constraints (obviously, such
certiﬁcates do not exist “in the wild”). OpenSSL, GnuTLS,
MatrixSSL, CyaSSL, Opera, and Chrome accept them, Open-
JDK and Bouncy Castle reject them, NSS and Firefox fail with
a generic Security library failure error. Neither choice appears
to lead to a security vulnerability.
Intermediate CA not authorized to issue further intermediate
CA certiﬁcates. When a higher-level CA certiﬁes a lower-
level CA, it can impose various restrictions on the latter. For
example, it can limit the number of intermediate certiﬁcates
that may follow the lower-level CA’s certiﬁcate in a certiﬁcate
124
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:02:03 UTC from IEEE Xplore.  Restrictions apply. 
chain. This is done by setting the pathLenConstraint ﬁeld in the
basic constraints extension of the lower-level CA’s certiﬁcate.
For example, if path length is set to zero, then the lower-
level CA is authorized to issue only leaf certiﬁcates, but not
intermediate CA certiﬁcates. This is good security practice: a
CA delegates its authority to a lower-level CA, but prevents
the latter from delegating it any further. We observed 17 CA
certiﬁcates with path length constraints in our corpus.
MatrixSSL ignores path length constraints. This can be
exploited by a malicious or compromised CA to evade restric-
tions imposed by a higher-level CA. For example, suppose
that a trusted root CA authorized a lower-level CA—call it
EnterpriseCA—but prohibited it from creating other CAs (via
path length constraints) and from issuing certiﬁcates for any
domain other than enterprise.com (via name constraints—see
Section IX-B). This provides a degree of protection if Enter-
priseCA is compromised. If the attacker uses EnterpriseCA to
issue a certiﬁcate for, say, google.com, this certiﬁcate should
be rejected by any SSL/TLS implementation because it violates
the constraints expressed in EnterpriseCA’s own certiﬁcate.
This attack will succeed, however, against any application
based on MatrixSSL. The impact of this vulnerability may be
ampliﬁed by the fact that MatrixSSL targets embedded devices,
whose manufacturers are the kind of organizations that are
likely to obtain CA certiﬁcates with restricted authority.
There is an interesting discrepancy in how the implemen-
tations react when an intermediate CA whose path length is
zero is followed by a leaf certiﬁcate that also happens to be a
CA certiﬁcate. In our testing, only MatrixSSL and GnuTLS ac-
cepted this chain. All other SSL/TLS implementations rejected
it because they do not allow any CA certiﬁcate to follow an
intermediate CA whose path length is zero. This interpretation
is incorrect. The X.509 standard explicitly permits a leaf CA
certiﬁcate to follow an intermediate CA whose path length is
zero [69, Section 4.2.1.9], but only GnuTLS implements this
part of the standard correctly.
B. Incorrect checking of name constraints
The higher-level CA may restrict the ability of a lower-
level CA to issue certiﬁcates for arbitrary domains by including
a name constraint in the lower-level’s CA’s certiﬁcate. For
example, if the issuing CA wants to allow the lower-level CA
to certify only the subdomains of foo.com, it can add a name
constraint *.foo.com to the lower-level CA’s certiﬁcate.
GnuTLS, MatrixSSL, and CyaSSL ignore name constraints
and accept the server’s certiﬁcate even if it has been issued by
a CA that is not authorized to issue certiﬁcates for that server.
C. Incorrect checking of time
Every X.509 certiﬁcate has the notBefore and notAfter
timestamp ﬁelds. The SSL/TLS client must verify that the
current date and time in GMT (or the time zone speciﬁed in
these ﬁelds) is within the range of these timestamps.
PolarSSL ignores the notBefore timestamp and thus accepts
certiﬁcates that are not yet valid. When verifying the notAfter
ﬁeld, it uses local time instead of GMT or the time zone
speciﬁed in the ﬁeld.
MatrixSSL does not perform any time checks of its own
and delegates this responsibility to the applications. The sam-
ple application code included with MatrixSSL checks the day,
but not the hours and minutes of the notAfter ﬁeld, and uses
local time, not GMT or the time zone speciﬁed in the ﬁeld.
D. Incorrect checking of key usage
SSL/TLS clients must check the key usage and, if present,
extended key usage extensions to verify that the certiﬁcates
are authorized for their purpose. Leaf certiﬁcates must be
authorized for key encipherment or key agreement, while CA
certiﬁcates must be authorized to sign other certiﬁcates.
CA certiﬁcate not authorized for signing other certiﬁcates.
All CA certiﬁcates in the chain must include keyCertSign
in their key usage. GnuTLS, CyaSSL, and MatrixSSL do
not check the key usage extension in CA certiﬁcates. An
attacker who compromises any CA key, even a key that is
not intended or used for certiﬁcate issuance, can use it to
forge certiﬁcates and launch man-in-the-middle attacks against
applications based on these libraries.
Server certiﬁcate not authorized for use in SSL/TLS hand-
shake. PolarSSL, GnuTLS, CyaSSL, and MatrixSSL do not
check the key usage extension in leaf certiﬁcates. This is
a serious security vulnerability. For example, if an attacker
compromises some company’s code signing certiﬁcate, which
is only intended for authenticating code, he will be able
to impersonate that company’s network and Web servers to
any application based on the above SSL/TLS libraries, vastly
increasing the impact of the attack.