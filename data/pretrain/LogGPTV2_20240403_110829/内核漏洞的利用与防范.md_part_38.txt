Linelof1
data:e000EE6C
）-0121a（endeu)
data:BneDEE6D
db
12h
data:8000EE6E
db
aoh
data:eonBEE6F
db
data:B00DEE70
db
98h
:UF13zsfDF1text,c98
Data:000BEE71
db
och
data:000BEE72
db
data:B00BEE73
db
图5.8
关联一个类型到一个内存地址
现在我们知道了IOCTL在二进制文件里面的位置，接下来可以开始有趣的部分了：审查
它，查找bug。在开始之前，我们必须看看内核源代码里面是如何定义这个函数的：
ioctl（int fildes,unsigned long request,...);
---
## Page 188
第5章MacOSX179
data:0000EE5F
db
data:0a00EE60neventry
dd 1CEAh
：dopen
data:0000EE60
DATA XREF:Sub87
data:000nEE60
sub_10845410
data:800EE60
dd1c88h
0close
data:B0DBE60
ddBD12F0h
dread
data:00B8EE60
dd0012F0h
data:000nE60
dd0C98h
dioctl
data:0800E60
dd0D12F0h
data:B000E60
ddBD12F
dreset
data:0000160
;dttys
data:D00EE60
dd 6BFh
:d_select
data:0000EE60
dd0D12F8h
:d_nnap
data:0000E60
dd0012F4h
:dstrategy
data:0o0BfE6D
dd 0D12F0h
:d_getc
data:000BEF60
dd0D12F0h
;d_pute
dd0
：dtype
data:0008Er98dword_EE98
dd OFFFFFFFFh
DATA XREF:SUb87
data:aontE98
:SuD_1BCC+831r
图5.9展开结构体定义来查找d_ioctl的地址
典型地，IOCTL函数有3个参数。第一个是IOCTL执行的文件描述符。它通常是一个打
开的devfs文件。第二个参数是一个无符号长整型，用来指示IOCTL将执行的功能。IOCTL
的典型行为就是执行一个switchcase，以决定执行哪一个行为。最后一个参数通常是一个空类
型的指针，可以用来传递需要从用户态传递到特定IOCTL的任何数据。
好消息是，IDAPro可以用N键在适当的时候给函数参数命名。这将使逆向分析的过程更加
清晰。一旦我们这样操作，就必须开始IOCTL审查流程以查找bug。正如我们在本节的前面所说
的，IOCTL一般以switch开始，然后查看预先定义的request参数的值来确定需要哪个功能。
就其本身而言，代码是以检测文件描述符来确定它的有效性开始的。然后直接比较request参
数和一系列预定义的值，然后跳到可能的响应代码的地方。定位这个查找和跳转过程（摘要如
图5.10所示）很简单，然后仔细地手动审查每一步（或者逃脱和查找mu-b的利用°），我们可
以找到request的一个值，它看起来像一个漏洞。
text:08nEDD
cmp
edx,ac0015627h
jnb
10c_1hDA
text:00B00EE9
edx,
80105624h
text:DBee0EEF
loc_1468
text:0B000EF5
edx,882E56hR:UulnerabletocTL Here
1oc_1546
text:0e0F0
cnp
edx,80105619h
text:00800F07
jnz
locDa
jnp
图5.10反汇编IOCTL调用：查找和跳转的过程
图5.11显示了反汇编与0x802E564A相关的代码的情形（高亮显示1oc_1546是跳转的目标）。
第一件引l人注目的事情是检测全局变量byte_EF60是否是0，如果是0，那么就跳到
1oc_1584（_text：0000155A）。然后代码使用data参数（_text：00001584）并且开始复制
从此处开始的4个字节（偏移量是0x4、0x8、0xC、0x10等）到若干不知道的全局变量（dword_
www.digit-labs.org/files/exploits/vmware-fission.c
---
## Page 189
180第二部分UNIX家族、MacOSX和Windows
D040、dword_D044等）。为进一步了解，我们需要准确地知道代码结束后那些变量会发生什么。
为了实现这一目标，我们再一次使用IDAPro的交叉引用功能查看每个地址发生了什么变化。
text:0000154610c_15:
;CODE xREF:my_ioct1·2631j
+.
text:00081546
eax.ds:duord F4hB
text:88001548
ROU
[esp+38h*uar_38],eax
text:0000154E
call
ds:byte EF60,0
near ptr
text:0a881553
cap
text:0800155A
jz
[esp+3Bh*var 30].
short1oc_1584
text:0008155C
reou
2日
text:00001564
nou
eax,[ebp+data]
text:08001567
noU
[esp+38h*uar_3a],eax
text:88801568
ROU
[esp+38h*var_38].offsetduord_D60h0
text:00001572
call
near ptr
text:00081577
test
eax,eax
text:08001579
jnz
1oc_1618
text:080a157F
jnp
1oc_160C
text:08881584
text:00001584
text:009015841oc_1584:
:CODE xREF:ny_ioct1·8C21j
text:08081584
nou
edx,[ebp+data]
text:08001587
nou
xea*otgponp:sp
eax,[edx]
text:00001589
Aou
text:800a158E
eax,[edx+a]
text:68001591
nou
ds:duord Da4a,eax
text:00001596
nou
eax.[edx+8]
text:08001599
nou
ds:duord_Da8,eax
text:0000159E
noU
eax,[edx+och]
text:880015A1
nou
ds:duord_DaD4C.
eax
text:000015A6
eax.[edx+10h]
text:0a0a15A9
rou
ds:duord_D0D50,
eax
Aou
eax,[edx+1ah]
text:0B8815B1
ROU
ds:duord_d0054,
eax
text:08001586
nou
eax,[edx+18h]
text:08081589
nou
ds:duord_D8D58.
eax
text:000015BE
nou
eax,[edx-1ch]
text:080015c1
nou
ds:duord_DaD5c.
eax
_text:088815c6
nou
eax,[edx+7]
图5.11
反汇编IOCTL路径的漏洞
通过遍历地址列表和查找每个交叉引用，我们可以看到它们是如何被使用的。有意思的是
第一个地址dword_D0D60，如图5.12所示。
Expxefstdwor00060
text:0
text:8