# etcdctl get /apisix/services --prefix    /apisix/services/    init_dir    /apisix/services/1    {"update_time":1614293352,"create_time":1614293352,"upstream":{"type":"roundrobin","nodes":{"172.18.5.12:80":1},"hash_on":"vars","scheme":"http","pass_host":"pass"},"id":"1"}    /apisix/services/2    {"update_time":1614293361,"create_time":1614293361,"upstream":    {"type":"roundrobin","nodes":{"172.18.5.13:80":1},"hash_on":"vars","scheme":"http","pass_host":"pass"},"id":"2"}从中我们可以总结出如下信息：1.  Apache APSIX 2.x 系列版本使用的是    etcd3。    2.  服务、路由、ssl、插件等配置存储格式前缀是 /apisix + \"/\" +    功能特性类型（routes/services/ssl 等），我们通过 Admin API    添加的路由、服务等配置就保存在相应的前缀下。        3.  路由和服务配置的 value 是个 Json 对象，其中服务对象包含了    id、负载均衡算法、后端节点、协议等信息。        了解完 Apache APISIX 在 etcd中的数据存储格式后，那么它是如何动态、近乎实时地感知到服务配置变化的呢？Watch 机制的应用与 Kubernetes 一样，它们都是通过 etcd 的 **Watch机制**来实现的。Apache APISIX 在启动的时候，首先会通过 Range操作获取网关的配置、路由等信息，随后就通过 Watch机制，获取增量变化事件。使用 Watch机制最容易犯错的地方是什么呢？答案是不处理 Watch 返回的相关错误信息，比如已压缩 ErrCompacted错误。Apache APISIX 项目在从 etcd v2 中切换到 etcd v3早期的时候，同样也犯了这个错误。去年某日收到小伙伴求助，说使用 Apache APISIX后，获取不到新的服务配置了，是不是 etcd 出什么 Bug了？ 经过一番交流和查看日志，发现原来是 Apache APISIX 未处理 ErrCompacted错误导致的。根据我们07Watch 原理的介绍，当你请求 Watch的版本号已被 etcd 压缩后，etcd 就会取消这个 watcher，这时你需要重建watcher，才能继续监听到最新数据变化事件。查清楚问题后，小伙伴向社区提交了 issue 反馈，随后 Apache APISIX相关同学通过PR 2687修复了此问题，更多信息你可参考Apache APISIX 访问 etcd相关实现代码文件slate-object="inline"。鉴权机制的应用除了 Watch 机制，Apache APISIX项目还使用了鉴权，毕竟配置网关是个高危操作，那它是如何使用 etcd鉴权机制的呢？ **etcd 鉴权机制**中最容易踩的坑是什么呢？答案是不复用 client 和鉴权 token，频繁发起 Authenticate 操作，导致etcd 高负载。正如我在17和你介绍的，一个 8 核 32G的高配节点在 100 个连接时，Authenticate QPS 仅为8。可想而知，你如果不复用token，那么出问题就很自然不过了。Apache APISIX是否也踩了这个坑呢？Apache APISIX 是基于 Lua构建的，使用的是lua-resty-etcd这个项目访问etcd，从相关issueslate-object="inline"反馈看，的确也踩了这个坑。社区用户反馈后，随后通过复用client、更完善的 token 复用机制解决了 Authenticate的性能瓶颈，详细信息你可参考PR 2932slate-object="inline"、PR 100slate-object="inline"。除了以上介绍的 Watch 机制、鉴权机制，Apache APISIX 还使用了 etcd 的Lease 特性和事务接口。Lease 特性的应用为什么 Apache APISIX 项目需要 Lease特性呢？ 服务发现的核心工作原理是服务启动的时候将地址信息登录到注册中心，服务异常时自动从注册中心删除。这是不是跟我们前面05节介绍的 \应用场景很匹配呢？没错，Apache APISIX 通过 etcd v2 的 TTL 特性、etcd v3 的 Lease特性来实现类似的效果，它提供的增加服务路由 API，支持设置 TTL属性，如下面所示：    
# Create a route expires after 60 seconds, then it's deleted automatically    $ curl http://127.0.0.1:9080/apisix/admin/routes/2?ttl=60 -H 'X-API-KEY: edd1c9f034335f136f87ad84b625c8f1' -X PUT -i -d '    {        "uri": "/aa/index.html",        "upstream": {            "type": "roundrobin",            "nodes": {                "39.97.63.215:80": 1            }        }    }'当一个路由设置非 0 TTL 后，Apache APISIX 就会为它创建 Lease，关联key，相关代码如下：    -- lease substitute ttl in v3    local res, err    if ttl then        local data, grant_err = etcd_cli:grant(tonumber(ttl))        if not data then            return nil, grant_err        end        res, err = etcd_cli:set(prefix .. key, value, {prev_kv = true, lease = data.body.ID})    else        res, err = etcd_cli:set(prefix .. key, value, {prev_kv = true})    end事务特性的应用介绍完 Lease 特性在 Apache APISIX 项目中的应用后，我们再来思考两个问题。为什么它还依赖 etcd 的事务特性呢？简单的执行 put 接口有什么问题？答案是它跟 Kubernetes是一样的使用目的。使用事务是为了防止并发场景下的数据写冲突，比如你可能同时发起两个Patch Admin API 去修改配置等。如果简单地使用 put接口，就会导致第一个写请求的结果被覆盖。Apache APISIX是如何使用事务接口提供的乐观锁机制去解决并发冲突的问题呢？核心依然是我们前面课程中一直强调的 mod_revision，它会比较事务提交时的mod_revision 与预期是否一致，一致才能执行 put 操作，Apache APISIX相关使用代码如下：    local compare = {        {            key = key,            target = "MOD",            result = "EQUAL",            mod_revision = mod_revision,        }    }    local success = {        {            requestPut = {                key = key,                value = value,                lease = lease_id,            }        }    }    local res, err = etcd_cli:txn(compare, success)    if not res then        return nil, err    end关于 Apache APISIX事务特性的引入、背景以及更详细的实现，你也可以参考PR 2216slate-object="inline"。小结最后我们来小结下今天的内容。今天我给你介绍了服务部署架构的演进，我们从单体架构的缺陷开始、到分布式及微服务架构的诞生，和你分享了分布式及微服务架构中面临的一系列痛点（如服务发现，鉴权，安全，限速等等）。而开源项目 Apache APISIX 正是一个基于 etcd的项目，它为后端存储提供了一系列的解决方案，我通过它的架构图为你介绍了其控制面和数据面的工作原理。随后我从数据存储格式、Watch 机制、鉴权机制、Lease特性以及事务特性维度，和你分析了它们在 Apache APISIX项目中的应用。数据存储格式上，APISIX 采用典型的 prefix + 功能特性组织格式。key是相关配置 id，value 是个 json对象，包含一系列业务所需要的核心数据。你需要注意的是 Apache APISIX 1.x版本使用的 etcd v2 API，2.x 版本使用的是 etcd v3 API，要求至少是 etcdv3.4 版本以上。Watch 机制上，APISIX依赖它进行配置的动态、实时更新，避免了传统的修改配置，需要服务重启等缺陷。鉴权机制上，APISIX使用密码认证，进行多租户认证、授权，防止用户出现越权访问，保护网关服务的安全。Lease 及事务特性上，APISIX 通过 Lease来设置自动过期的路由规则，解决服务发现中的节点异常自动剔除等问题，通过事务特性的乐观锁机制来实现并发场景下覆盖更新等问题。希望通过本节课的学习，让你从 etcd 角度更深入了解 APISIX项目的原理，了解 etcd各个特性在其中的应用，学习它的最佳实践经验和经历的各种坑，避免重复踩坑。在以后的工作中，在你使用APISIX 等开源项目遇到 etcd 相关错误时，能独立分析、排查，甚至给社区提交PR 解决。 思考题好了，这节课到这里也就结束了，最后我给你留了一个开放的配置系统设计思考题。假设老板让你去设计一个大型配置系统，满足公司各个业务场景的诉求，期望的设计目标如下：1.  高可靠。配置系统的作为核心基础设施，期望可用性能达到    99.99%。        2.  高性能。公司业务多，规模大，配置系统应具备高性能、并能水平扩容。        3.  支持多业务、多版本管理、多种发布策略。        你认为 etcd适合此业务场景吗？如果适合，分享下你的核心想法、整体架构，如果不适合，你心目中的理想存储和架构又是怎样的呢？欢迎大家留言一起讨论，后面我也将在答疑篇中分享我的一些想法和曾经大规模TO C 业务中的实践经验。感谢你阅读，也欢迎你把这篇文章分享给更多的朋友一起阅读。