by adversarial input from H, secret input from H must be low-
integrity (that is, its label must be H→). But if it is low-integrity,
this input (or the variable y) must be endorsed to allow the de-
classification it influences. As in the previous two examples, the
endorsement of high-confidentiality information enables exploits.
3 BACKGROUND
We explore nonmalleable information flow in the context of a sim-
plified version of FLAM [4], so we first present some background.
FLAM provides a unified model for reasoning about both informa-
tion flow and authorization. Unlike in previous models, principals
and information flow labels in FLAM are drawn from the same
set L. The interpretation of a label as a principal is the least pow-
erful principal trusted to enforce that label. The interpretation of
a principal as a label is the strongest information security policy
that principal is trusted to enforce. We refer to elements of L as
principals or labels depending on whether we are talking about
authorization or information flow.
Labels (and principals) have both confidentiality and integrity
aspects. A label (or principal) ℓ can be projected to capture just its
confidentiality (ℓ→) and integrity (ℓ←) aspects.
The information flow ordering ⊑ on labels (and principals) de-
scribes information flows that are secure, in the direction of increas-
ing confidentiality and decreasing integrity. The orthogonal trust
ordering ≽ on principals (and labels) corresponds to increasing
trustedness and privilege: toward increasing confidentiality and
increasing integrity. We read ℓ ⊑ ℓ′ as “ℓ flows to ℓ′”, meaning ℓ′
specifies a policy at least as restrictive as ℓ does. We read p ≽ q as
“p acts for q”, meaning that q delegates to p.
The information flow and the trust orderings each define a lattice
over L, and these lattices lie intuitively at right angles to one
another. The least trusted and least powerful principal is ⊥, (that
is, p ≽ ⊥ for all principals p), and the most trusted and powerful
principal is ⊤ (where ⊤ ≽ p for all p). We also assume there is a
set of atomic principals like alice and bob that define their own
delegations.
Since the trust ordering defines a lattice, it has meet and join
operations. Principal p ∧ q is the least powerful principal that can
act for both p and q; conversely, p ∨ q can act for all principals
that both p and q can act for. The least element in the information
flow ordering is ⊤←, representing maximal integrity and minimal
confidentiality, whereas the greatest element is ⊤→, representing
minimal integrity and maximal confidentiality. The join and meet
operators in the information flow lattice are the usual ⊔ and ⊓,
respectively.
Any principal (label) can be expressed in a normal form p→ ∧
q← where p and q are CNF formulas over atomic principals [4].
This normal form allows us to decompose decisions about lattice
ordering (in either lattice) into separate questions regarding the
integrity component (p) and the confidentiality component (q).
Lattice operations can be similarly decomposed.
FLAM also introduces the concept of the voice of a label (princi-
pal) ℓ, written ∇(ℓ). Formally, for a normal-form label ℓ = p→ ∧q←,
we define voice as follows: ∇(p→ ∧ q←) ≜ p←.1 A label’s voice
represents the minimum integrity needed to securely declassify
data constrained by that label, a restriction designed to enforce
robust declassification.
The Flow-Limited Authorization Calculus (FLAC) [5] previously
embedded a simplified version of the FLAM proof system into a core
language for enforcing secure authorization and information flow.
FLAC is an extension of the Dependency Core Calculus (DCC) [1, 3]
whose types contain FLAM labels. A computation is additionally
associated with a program-counter label pc which tracks the influ-
ences on the control flow and values that are not explicitly labeled.
In this paper we take a similar approach: NMIFC enforces secu-
rity policies by performing computation in a monadic context. As
in FLAC, NMIFC includes a pc label. For an ordinary value v, the
monadic term (ηℓ v) signifies that value with the information flow
label ℓ. If value v has type τ, the term (ηℓ v) has type ℓ says τ,
capturing the confidentiality and integrity of the information.
Unlike FLAC, NMIFC has no special support for dynamic delega-
tion of authority. Atomic principals define L by statically delegating
their authority to arbitrary conjunctions and disjunctions of other
principals, and we include traditional declassification and endorse-
ment operations, decl and endorse. We leave to future work the
integration of nonmalleable information flow with secure dynamic
delegation.
4 ENFORCING NONMALLEABILITY
Multiple prior security-typed languages—both functional [5] and
imperative [6, 11, 27]—aim to allow some form of secure down-
grading. These languages place no restriction whatsoever on the
confidentiality of endorsed data or the context in which an endorse-
ment occurs. Because of this permissiveness, all three insecure
examples from Section 2 type-check in these languages.
4.1 Robust declassification
Robust declassification prevents adversaries from using declassifi-
cations in the program to release information that was not intended
to be released. The adversary is assumed to be able to observe some
1FLAM defines ∇(p→ ∧ q←) = p← ∧ q←, but our simplified definition is sufficient
for NMIFC. For clarity, the operator ∇ is always applied to a projected principal.
state of the system, whose confidentiality label is sufficiently low,
and to modify some state of the system, whose integrity label is
sufficiently low. Semantically, robust declassification says that if the
attacker is unable to learn a secret with one attack, no other attack
will cause it to be revealed [27, 46]. The attacker has no control over
information release because all attacks are equally good. When ap-
plied to a decentralized system, robust declassification means that
for any principal p, other principals that p does not trust cannot
influence declassification of p’s secrets [11].
To enforce robust declassification, prior security-typed languages
place integrity constraints on declassification. The original work
on FLAM enforces robust declassification using the voice operator
∇. However, when declassification is expressed as a programming-
language operation, as is more typical, it is convenient to define a
new operator on labels, one that maps in the other direction, from
integrity to confidentiality. We define the view of a principal as the
upper bound on the confidentiality a label or context can enforce
to securely endorse that label:
Definition 4.1 (Principal view). Let ℓ = p→∧q← be a FLAM label
(principal) expressed in normal form. The view of ℓ, written ∆(ℓ),
is defined as ∆(p→ ∧ q←) ≜ q→.
When the confidentiality of a label ℓ lies above the view of its own
integrity, a declassification of that label may give adversaries the
opportunity to subvert the declassification to release information.
Without enough integrity, an adversary might, for example, replace
the information that is intended to be released via declassification
with some other secret.
Figure 3 illustrates this idea graphically. It depicts the lattice of
FLAM labels, which is a product lattice with two axes, confidential-
ity and integrity. A given label ℓ is a point in this diagram, whereas
the set of labels sharing the same confidentiality ℓ→ or integrity
ℓ← correspond to lines on the diagram. Given the integrity ℓ← of
the label ℓ, the view of that integrity, ∆(ℓ←), defines a region of
information (shaded) that is too confidential to be declassified.
The view operator directly corresponds to the writers-to-readers
operator that Chong and Myers [11] use to enforce robust declassi-
fication in the DLM. We generalize the same idea here to the more
expressive labels of FLAM.
4.2 Transparent endorsement
The key insight of this work is that endorsement should be re-
stricted in a manner dual to robust declassification; declassification
(reducing confidentiality) requires a minimum integrity, so endorse-
ment (raising integrity) should require a maximum confidentiality.
Intuitively, if a principal could have written data it cannot read,
which we call an “opaque write,” it is unsafe to endorse that data.
An endorsement is transparent if it endorses only information its
authors could read.
The voice operator suffices to express this new restriction conve-
niently, as depicted in Figure 4. In the figure, we consider endorsing
information with confidentiality ℓ→. This confidentiality is mapped
to a corresponding integrity level ∇(ℓ→), defining a minimal in-
tegrity level that ℓ must have in order to be endorsed. If ℓ lies below
this boundary, its endorsement is considered transparent; if it lies
above the boundary, endorsement is opaque and hence insecure.
The duality with robust declassification is clear.
Figure 3: Robust declassification says information at level ℓ can be
declassified only if it has enough integrity. The gray shaded region
represents information that ∆(ℓ←) cannot read, so it is unsafe to
declassify with ℓ’s integrity.
τ
v
e
e −→ e′
[E-App]
[E-BindM]
[E-Step]
[E-UnitM]
[E-Decl]
[E-Endorse]
[E-Eval]
(cid:12)(cid:12)(cid:12) p ⊓ p
n ∈ N
x ∈ V
π ∈ {→, ←}
p, ℓ, pc
::= n
(atomic principals)
(variable names)
(security aspects)
pc−−→ τ
(cid:12)(cid:12)(cid:12) p ⊔ p
(cid:12)(cid:12)(cid:12) p ∨ p
(cid:12)(cid:12)(cid:12) ⊤ (cid:12)(cid:12)(cid:12) ⊥ (cid:12)(cid:12)(cid:12) p π (cid:12)(cid:12)(cid:12) p ∧ p
(cid:12)(cid:12)(cid:12) ℓ says τ
(cid:12)(cid:12)(cid:12) τ
(cid:12)(cid:12)(cid:12) (η ℓ v )
(cid:12)(cid:12)(cid:12) λ(x :τ )[pc]. e
(cid:12)(cid:12)(cid:12) bind x = e in e
(cid:12)(cid:12)(cid:12) (ηℓ e )
(cid:12)(cid:12)(cid:12) e e
(cid:12)(cid:12)(cid:12) v
(cid:12)(cid:12)(cid:12) endorse e to ℓ
decl e to ℓ
Figure 5: Core NMIFC syntax.
()
::= unit
::=
(cid:12)(cid:12)(cid:12)
::= x
(event)
(trace)
⟨e, t⟩ −→→ (cid:10)e′
, t′(cid:11)
t ::= ε
e −→ e′
ℓ′, η ℓ v )
(λ(x :τ )[pc]. e ) v −→ e[x (cid:55)→ v]
bind x = (η ℓ v ) in e −→ e[x (cid:55)→ v]
, t;•(cid:11)
(cid:12)(cid:12)(cid:12) (↓π
c ::= • (cid:12)(cid:12)(cid:12) (η ℓ v )
(cid:12)(cid:12)(cid:12) c
(cid:12)(cid:12)(cid:12) t; t
⟨e, t⟩ −→→ (cid:10)e′
(cid:10)(ηℓ v ), t(cid:11) −→→ (cid:68)
(cid:69) −→→ (cid:68)
(cid:69) −→→ (cid:68)
⟨e, t⟩ −→→ (cid:10)e′
, t′(cid:11)
⟨E[e], t⟩ −→→ (cid:10)E[e′], t′(cid:11)
(cid:12)(cid:12)(cid:12) v E
(cid:12)(cid:12)(cid:12) (ηℓ E )
(cid:12)(cid:12)(cid:12) bind x = E in e
(cid:12)(cid:12)(cid:12) endorse E to ℓ
(η ℓ v ), t; (η ℓ v )
(η ℓ v ), t; (↓→
(η ℓ v ), t; (↓←
ℓ′, η ℓ v )
(cid:69)
(cid:12)(cid:12)(cid:12) E e
(cid:69)
(cid:69)
ℓ′, η ℓ v )
decl (η ℓ′ v ) to ℓ, t
endorse (η ℓ′ v ) to ℓ, t
(cid:68)
(cid:68)
(cid:12)(cid:12)(cid:12)
Evaluation context
::= [·]
E
decl E to ℓ
Figure 4: Transparent endorsement in NMIFC. The gray shaded
region represents information that ∇(ℓ→) does not trust and may
have been created by an opaque write. It is thus unsafe to endorse
with ℓ’s confidentiality.
5 A CORE LANGUAGE: NMIFC
We now describe the NonMalleable Information Flow Calculus
(NMIFC), a new core language, modeled on DCC and FLAC, that
allows downgrading, but in a more constrained manner than FLAC
so as to provide stronger semantic guarantees. NMIFC incorpo-
rates the program-counter label pc of FLAC, but eschews the more
powerful assume mechanism of FLAC in favor of more traditional
declassify and endorse operations.
The full NMIFC is a small extension of Polymorphic DCC [1]. In
Figure 5 we present the core syntax, leaving other features such as
sums, pairs, and polymorphism to Appendix A. Unlike DCC, NMIFC
supports downgrading and models it as an effect. It is necessary
Figure 6: Core NMIFC operational semantics.
to track what information influences control flow so that these
downgrading effects may be appropriately constrained. Therefore,
like FLAC, NMIFC adds pc labels to lambda terms and types.
Similarly to DCC, protected values have type ℓ says τ where ℓ
is the confidentiality and integrity of a value of type τ. All compu-
tation on these values occurs in the says monad; protected values
must be bound using the bind term before performing operations
on them (e.g., applying them as functions). Results of such compu-
tations are protected with the monadic unit operator (ηℓ e), which
protects the result of e with label ℓ.
5.1 NMIFC operational semantics
The core semantics of NMIFC are mostly standard, but to obtain our
theoretical results we need additional information about evaluation.
This information is necessary because we want to identify, for
instance, whether information is ever available to an attacker during
ℓ←CI⊥⊤⊤→⊤←Δ(ℓ←)nonrobustrobustCI⊥⊤⊤→⊤←l→transparentopaque∇(ℓ→)ℓ→⊢ ℓ ⊑ τ
[P-Unit]
⊢ ℓ ⊑ unit
[P-Lbl]
⊢ ℓ
Figure 7: Type protection levels.
′ ⊑ ℓ
ℓ
′ ⊑ ℓ says τ
evaluation, even if it is discarded and does not influence the final
result. This approach gives an attacker more power; an attacker can
see information at its level even if it is not output by the program.
The NMIFC semantics, presented in Figure 6, maintain a trace t of
events. An event is emitted into the trace whenever a new protected
value is created and whenever a declassification or endorsement
occurs. These events track the observations or influence an attacker
may have during a run of an NMIFC program. Formally, a trace can
be an empty trace ε, a single event c, or the concatenation of two
traces with the associative operator “;” with identity ε.
When a source-level unit term (ηℓ v) is evaluated (rule E-UnitM),
an event (ηℓ v) is added to the trace indicating that the value v
became protected at ℓ. When a protected value is declassified, a
declassification event (↓→
ℓ′ , ηℓ v) is emitted, indicating that v was
declassified from ℓ′ to ℓ. Likewise, an endorsement event (↓←
ℓ′ , ηℓ v)
is emitted for an endorsement. Other evaluation steps (rule E-Step)
emit •, for “no event.” Rule E-Eval steps under the evaluation
contexts [45] defined at the bottom of Figure 6.
Rather than being literal side effects of the program, these events
track how observable information is as it is accessed, processed,
and protected by the program. Because our semantics emits an
event whenever information is protected (by evaluating an η term)
or downgraded (by a decl or endorse term), our traces capture
all information processed by a program, indexed by the policy
protecting that information.
By analogy, these events are similar to the typed and labeled mu-
table reference cells of languages like FlowCaml [31] and DynSec [49].
An event (ηℓ v) is analogous to allocating a reference cell protected
at ℓ, and (↓π
ℓ′, ηℓ v) is analogous to copying the contents of a cell
at ℓ′ to a new cell at ℓ.
It is important for the semantics to keep track of these events
so that our security conditions hold for programs containing data
structures and higher-order functions. Previous language-based
definitions of robust declassification have only applied to simple
while-languages [6, 11, 27] or to primitive types [5].
5.2 NMIFC type system
The NMIFC protection relation, presented in Figure 7, defines how
types relate to information flow policies. A type τ protects the
confidentiality and integrity of ℓ if ⊢ ℓ ⊑ τ. Unlike in DCC and