### 优化后的文本

#### 3.3.5 僵尸网络控制与XSS攻击示例
当攻击者连接到僵尸网络后，您便可以完全掌控其浏览器。根据设备、浏览器类型及已启用的功能，您可以执行多种类型的攻击。例如，采用社会工程策略并通过Flash更新提示推送恶意软件，是展示跨站脚本（XSS）攻击的一个有效方法，如图3.7所示。

![图3.7](#)

在完成攻击后，被攻击者的计算机上将显示一个弹出窗口，诱使其安装包含额外恶意软件的更新程序，如图3.8所示。

![图3.8](#)

建议读者深入研究BeEF框架的所有后期利用模块，并了解JavaScript的强大功能。既然已经获得了对目标浏览器的控制权，接下来需要考虑如何在红队活动中运用这种能力。一旦发现并利用了XSS漏洞，下一步该怎么做？我们将在下一节中探讨这个问题。

#### 3.3.6 盲XSS
盲XSS由于其实现过程需要极大耐心而较少被讨论。它指的是，在执行存储型XSS负载时，攻击者或用户无法直接看到任何反馈信息；只有管理员或后端工作人员才能观察到效果。尽管此类攻击对于后台操作人员可能非常危险，但它往往容易被忽视。

设想这样一个场景：某个应用提供了一个“联系我们”的页面，允许用户提交联系方式以供后续联系使用。若此数据仅由管理员手动查看，则普通请求发送者将无从得知自己的输入是否触发了潜在的XSS漏洞。此时，我们可以借助XSS Hunter工具来验证是否存在盲XSS问题。

XSS Hunter的工作机制如下：当JavaScript代码被执行时，它会捕获受害者当前浏览页面的屏幕截图，并将其发送回XSS Hunter服务器。收到截图后，XSSHunter会向攻击者发送通知，同时附带所有相关细节。基于这些信息，攻击者能够构建新的恶意负载，从而继续实施攻击。

以下是使用XSS Hunter进行测试的具体步骤：
1. 禁用所有代理软件（如Burp Suite）。
2. 在XSS Hunter网站注册账号。
3. 登录XSS Hunter平台。
4. 转至负载页面选择合适的载荷。
5. 根据需求调整载荷内容，支持多语言环境下的自定义设置，参见图3.9。
6. 检查XSS Hunter接收情况，确认载荷是否成功执行，详见图3.10。

![图3.9](#)
![图3.10](#)

#### 3.3.7 基于DOM的跨站脚本攻击
理解反射型和存储型XSS攻击相对简单。然而，基于文档对象模型（DOM）的XSS攻击则有所不同，常常导致误解。因此有必要花时间专门学习基于DOM的XSS。

当攻击者篡改网页应用程序客户端脚本时，就可能发生基于DOM的XSS攻击。如果攻击者能够将恶意代码注入DOM结构，并促使用户的浏览器读取这段代码，则该恶意代码将在解析过程中得以执行。

那么，究竟什么是DOM呢？简而言之，文档对象模型是一种表示HTML属性的方式。浏览器本身不能直接解析HTML属性，而是通过解释器将其转换为DOM形式。

为了更好地说明这一点，请访问一个具有漏洞的聊天支持网站。创建账户并登录后，转至聊天页面尝试输入一些精心构造的XSS载荷。在这个例子中，我们配置了Node.js环境以及socket.io库，用于建立用户与服务器间的WebSocket连接。客户端则运行着JavaScript代码`msg.msgText`。如图3.11所示，您不会像在标准反射/存储型XSS攻击中那样立即看到“警告”对话框弹出。这里唯一可见的变化可能是来自`msg.name`引用的载荷被调用了。有时候很难判断载荷具体在哪里执行，或者是否需要脱离HTML标签才能生效。

![图3.11](#)

#### 3.3.8 Node.js中的高级XSS攻击
XSS漏洞之所以频繁出现，一个重要原因是单纯过滤特定标签或字符难以彻底防范此类攻击。尤其是当载荷针对特定编程语言或框架定制时，防护变得更加困难。每种语言都有其独特的安全特性，Node.js也不例外。

接下来我们将展示几种特定于Node.js环境下的XSS实现方式。考虑到Express框架和Pug模板引擎是较为常见的Web开发堆栈组合，默认情况下，除非通过模板引擎渲染，否则Express本身并不具备内置XSS防御机制。使用Pug这样的模板引擎时，通常有两种途径可以找到XSS漏洞：字符串插值和未编码的缓冲区代码。

**字符串插值**

模板引擎引入了字符串插值的概念，这是一种特殊的变量占位符表达形式。例如，在Pug模板中可以这样定义变量：

```pug
- var title = "This is the HTML Title"
- var THP = "Hack the Planet"
h1 #{title}
p The Hacker Playbook will teach you how to #{THP}
```

其中`#{THP}`即为之前分配给THP变量值的占位符。这类模板常用于邮件分发系统中，比如自动发送电子邮件时可能会出现“Dear ${first_name}...”这样的格式。

上述Pug代码生成的HTML将是：

```html
<h1>This is the HTML Title</h1>
<p>The Hacker Playbook will teach you how to Hack the Planet</p>
```

幸运的是，这里使用的“#{...}”语法是经过转义处理的Pug插值方式。这意味着即使存在用户输入也不会轻易引发XSS问题。

**非转义字符串插值**

Pug还支持非转义版本的字符串插值，即`!{...}`语法。在这种模式下，传递给模板的数据不会被自动转义，从而可能导致XSS风险。此外，Pug中还有一种特殊形式的未编码缓冲区代码，以“!＝”开头，后面紧跟的内容会被视为纯JavaScript代码执行。

只要允许插入原始HTML内容，就可能存在XSS隐患。现实世界中许多案例表明，开发者往往忽略了上下文环境以及输入传递的位置，从而无意间留下了安全漏洞。下面是一些实际存在于聊天支持系统中的XSS示例。请访问虚拟机上的URL地址：http://chat:3000/xss。我们将逐一演示每个练习来深入了解Node.js/Pug环境下XSS攻击的特点。

**练习1（http://chat:3000/xss）**

在此示例中，我们将使用段落标记内的转义字符串插值。由于采用了正确的转义符号，因此这个场景是不可利用的。

- 访问 http://chat:3000/xss 并点击“Exercise #1”。
- 查看Pug模板源码：
  ```pug
  p No results found for #{name1}
  ```
- 尝试输入并提交以下载荷：
  ```javascript
  <script>alert(1)</script>
  ```
- 提交后检查页面源码，可以看到特殊字符已被转换成HTML实体，如图3.12所示。

![图3.12](#)

- 此时，虽然可以在浏览器中看到<script>标签，但并不会作为JavaScript代码执行。这证明了正确使用转义字符串插值的重要性。

**练习2**

这次我们在段落标记中使用了非转义字符串插值`!{...}`。这种方式极易遭受XSS攻击。

- 跳转到“Exercise #2”。
- 查看Pug模板源码：
  ```pug
  p No results found for !{name2}
  ```
- 输入并提交以下载荷：
  ```javascript
  <script>alert(1)</script>
  ```
- 提交后应能看到弹出警告框。验证方法同上，参见图3.13。

![图3.13](#)

- 结论：使用非转义字符串插值处理用户输入是非常危险的做法，任何JavaScript代码都将在受害者的浏览器中执行。

**练习3**

本例展示了即使在动态内联JavaScript中使用了转义字符串插值，也可能存在安全隐患。原因在于代码所处的具体上下文环境。

- 进入“Example #3”。
- 查看Pug模板源码：
  ```pug
  - var user3 = #{name3};
  p No results found for #{name3}
  ```
- 此模板将被解析成如下HTML：
  ```html
  <script>var user3 = [escaped user input];</script>
  <p>No results found for [escaped user input]</p>
  ```
- 尝试输入并提交以下载荷：
  ```javascript
  1;alert(1);
  ```
- 提交后同样会出现警告框。这是因为尽管进行了转义处理，但由于位于<script>标签内部，JavaScript代码仍能正常工作。

- 修正方案是在插值周围添加引号：
  ```pug
  script.
    var user3 = "#{name3}";
  ```

**练习4**

最后一个例子展示了Pug中非转义代码块`! =`的使用。由于没有进行任何转义处理，此处很容易受到XSS攻击影响。

- 查看Pug模板源码：
  ```pug
  p != 'No results found for '+name4
  ```
- 输入并提交以下载荷：
  ```javascript
  <script>alert(1)</script>
  ```
- 提交后将看到警告框弹出，验证方法同前。

通过以上几个练习，希望能够帮助读者更全面地理解Node.js环境下XSS攻击的各种可能性及其防范措施。