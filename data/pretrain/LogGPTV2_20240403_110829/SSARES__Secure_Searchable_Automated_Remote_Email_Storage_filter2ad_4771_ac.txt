### Situation and Script Overview

The use of filters is essential, as their absence would render the system ineffective. The second script, `SSARES_email_search.py`, assists users in querying the email archive. This script utilizes the PEKS (Public Key Encryption with Keyword Search) private key to generate trapdoors. Users provide a list of keywords for each field. The script then calls the Bloom Filter application to create the query filter and invokes the PEKS script to generate the required trapdoors. Each trapdoor is organized into a list based on the queried field, ensuring they are tested against the appropriate `peks-list` on the server. Similar to the previous process, the first letter of the unencrypted keyword in each trapdoor is exposed to facilitate Alpha-Sorting. Since there is only one error-prone filter per message, the query filters are not separated. Finally, the script sends the resulting SSARES Query to the server to perform the search.

### Searching Process

The searching process is facilitated by the `SSARES_mailbox_test.py` script. This script accepts an SSARES Email created using `SSARES_email_parse.py` and an SSARES Query generated by `SSARES_email_search.py`. It tests for matches using the algorithm described in Section 3. The output is a list of unique IDs for matching SSARES Emails, which can be requested individually by the user for decryption and local reading.

### Evaluation

We evaluated SSARES in three main areas: email production, query production, and searching. Our sample set consisted of 100 messages from the Enron Data Set [7]. All tests were conducted on a Red Hat Enterprise Linux machine with a Pentium 4 CPU at 3.00 GHz.

#### 5.1 SSARES Email Production

We used the `SSARES_email_parse.py` script to process our sample dataset and generate a SSARES Mailbox. Figure 2 illustrates the results. Figures 2(a) and 2(b) show the relationship between the original email size in bytes and the number of keywords, respectively, and the size of the resulting SSARES Email in bytes, with a best-fit line. Both graphs exhibit a strong linear relationship, but the number of keywords has a more significant impact on the final size of the SSARES Email than the original email size. This is due to the fixed size of the PEKS-encrypted keywords. A larger number of keywords results in more PEKS-encryption, leading to a larger SSARES Email.

- **Average Original Email Size**: 2523 bytes
- **Average SSARES Email Size**: 94,863 bytes
- **Average Increase Factor**: 37 (as shown by the slope in Figure 2(a))

Given current and future storage costs, this tradeoff is reasonable for some environments but not entirely satisfactory. We are exploring techniques to minimize this overhead. The slope in Figure 2(b), at 387.27, represents the average space one keyword takes up in the final encrypted email. Even a small, wordy message can take up more space than a larger, less wordy message.

Figures 2(c) and 2(d) display time dependencies in SSARES Email Production. Figure 2(c) shows a direct relationship between the number of keywords and the time of email production. The slope, at 0.07, indicates the average time in seconds per keyword for encryption. Figure 2(d) also shows a linear relationship between the original email size and the time of encryption, likely because larger emails have more keywords.

- **Average Time of Encryption**: 17.17 seconds
- **Standard Deviation**: 24.17 seconds
- **Worst Case**: 179.31 seconds (for an email with over 1,000 keywords)

Encryption speed is not a critical factor since email typically operates on the order of minutes. An additional minute for encryption does not significantly impact usability.

#### 5.2 SSARES Query Production

To test query production, we collected keywords while parsing the body and subject of the emails. We produced three types of SSARES Queries with varying numbers of keywords (1 to 20) for both the subject and body fields, with and without Alpha-Sorting:

1. **First-Match Queries**: The first keyword provided matches at least one message.
2. **Last-Match Queries**: The last keyword provided matches an email.
3. **No Match Queries**: None of the keywords match any emails.

Non-matching keywords were created by appending numerals to the search keywords. These queries were designed to provide varying results on different search styles.

Figure 3 shows the results from the SSARES query production test. Figure 3(a) illustrates the relationship between the number of keywords and the time to produce a query. Query production is fast, even with many keywords. Using twenty keywords, it took less than 2 seconds to produce a query. This is crucial for overall search performance. Figure 3(b) displays the size of the resulting queries in bytes relative to the size of the keywords being searched. There is a linear relationship, likely due to the fixed amount of information (filter and trapdoor) and their fixed sizes. The maximum query size is 9 KB, which should not pose significant performance issues.

#### 5.3 SSARES Search

The SSARES Queries from the query production testing were used to run search tests on the SSARES Mailbox. Figures 4(a) and 4(b) show how the search time in seconds relates to the number of keywords, also dependent on the number of keywords per message. As the number of keywords increases, search speed generally decreases. Outlying points represent searches on emails with over a thousand keywords. Without Alpha-Sorting, it takes about 7 seconds to search the largest message and 2.7 seconds on average. However, these times add up, making the overall search slow. A small search of 1 to 6 keywords over 100 emails can take half a minute. Searches on the subject, which has a shorter `peks-list` than the body, can still take over a minute for 8 keywords, indicating the need for filters and Alpha-Sorting to improve speed.

Figure 5(a) shows the drastic effect of the Bloom Filter on search speed. When a query fails the filter, it can be eliminated in under a second. If the filter is passed, the time per message ranges from 1 to 7 seconds. Figure 5(b) shows that, on average, 76% of messages can be eliminated using the filter, matching our minimum error rate of 25%. Adjusting the filter's minimum error rate can affect overall search speed, at the cost of reduced privacy.

Search testing with Alpha-Sorting showed significant improvements. Figure 6 illustrates that with just filters, the average search speed for the subject was 28.88 seconds and 0.27 seconds per email. Alpha-Sorting improved this to 7.00 seconds per search and 0.05 seconds per email. However, searching the body, which has a longer `peks-list`, still requires improvement. With Alpha-Sorting, the average search time of 46.47 seconds and 0.45 seconds per email is still too slow for practicality.

### Conclusion

We have presented SSARES, a novel system that addresses the challenge of securing email at rest while allowing for searchable access. The combination of Bloom Filters with intentional errors, PEKS encryption, and Alpha Sorting provides an automated and transparent process, maintaining normal email practices. SSARES enhances the security of server-side email storage and, if properly implemented, can significantly impact the privacy of user emails and other information stored with third-party providers.

### References

[1] S. Artzi, A. Kiezum, C. Newport, and D. Schultz. Encrypted Keyword Search in Distributed Storage System. MIT CSAIL Tech Report, MIT-CSAIL-TR-2006-010, February 2006.

[2] L. Ballard, M. Green, B. de Medeiros, and F. Monrose. Correlation-Resistant Storage via Keyword Searchable Encryption. Cryptology ePrint Archive, Report 2005/417, 2005.

[3] S. M. Bellovin and W. R. Cheswick. Privacy-Enhanced Searches Using Encrypted Bloom Filters. DRAFT, 2006.

[4] B. Bloom. Space/time trade-offs in hash coding with allowable errors. Communications of the ACM, 13(7):422–426, July 1970.

[5] D. Boneh, G. Crescenzo, R. Ostrovsky, and G. Persiano. Public key encryption with keyword search. In C. Cachin and J. Camenisch, editors, Proceedings of Eurocrypt, pages 506–522, 2004.

[6] D. Boneh and M. Franklin. Identity-Based Encryption from Weil Pairing. SIAM Journal of Computing, 32(3):586–615, 2003.

[7] CALO Project. Enron Data Set. 2004.

[8] Y.-C. Chang and M. Mitzenmacher. Privacy Preserving Keyword Searches. In Proceedings of ACNS, pages 442–455, June 2005.

[9] R. Curtmola, J. Garay, S. Kamara, and R. Ostrovsky. Searchable Symmetric Encryption: Improved Definition and Efficient Constructions. In Proceedings of ACM CCS, November 2006.

[10] E.-J. Goh. Secure Indexes. Cryptology ePrint Archive, Report 2003/216, 2003.

[11] C. Gu, Y. Zhu, and Y. Zhang. Efficient Public Key Encryption with Keyword Search Scheme from Pairings. Cryptology ePrint Archive, Report 2006/108, 2006.

[12] B. Lynn. The Pairing Based Cryptography Library.

[13] D. Park, J. Cha, and P. Lee. Searchable Keyword-Based Encryption. Cryptography ePrint Archive, Report 2005/367, 2005. Available at http://eprint.iacr.org.

[14] D. Parl, K. Kim, and P. Lee. Public Key Encryption with Conjunctive Field Keyword Search. In C. Lim and M. Yung, editors, Proceedings of WISA, pages 73–86, 2004.

[15] D. Song, D. Wagner, and A. Perrig. Practical Techniques for Searches on Encrypted Data. In IEEE Symposium on Security and Privacy, pages 44–55, May 2000.

[16] B. Waters, D. Balfanz, G. Durfee, and D. Smetters. Building an Encrypted and Searchable Audit Log. Proceedings of ISOC NDSS, February 2004.