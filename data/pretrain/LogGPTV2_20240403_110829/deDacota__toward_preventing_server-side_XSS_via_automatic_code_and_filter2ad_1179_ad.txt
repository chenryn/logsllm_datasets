### 1. Introduction to the Test Applications

Table 1: ASP.NET Web Form applications used to test deDacota's applicability to real-world web applications.

| Application | Lines of Code |
|-------------|---------------|
| BugTracker.NET | 29,000 |
| BlogEngine.NET | 30,000 |
| BlogSA.NET | 67,000 |
| ScrewTurn Wiki | 15,000 |
| WebGoat.NET | 0 |
| ChronoZoom | 11,000 |
| Other Apps | 26,000 |
| Total | 100,000 |

The primary application, ChronoZoom, is a JavaScript-heavy HTML page, chosen for its extensive test suite that exercises the JavaScript portion. To evaluate the correctness of our rewriting, we converted the main HTML page of ChronoZoom, which contained inline JavaScript, into an ASP.NET Web Form page, along with nine other HTML pages used by the test suite. These six real-world web applications encompass a broad spectrum of web application functionality, written by different developers with varying coding styles. Some applications had inline JavaScript in the ASP.NET page, some created inline JavaScript directly in C#, and others used string concatenation in C# to create inline JavaScript. Additionally, we analyzed the entire .NET framework (including ASP.NET), which comprises 256 MB of binary code. Given our analysis handles ASP.NET, we are confident that our approach can be applied to most ASP.NET applications.

### 2. Security Analysis

We ran deDacota on each of our test applications. Table 2 shows the total number of inline JavaScript scripts per application, broken down into static inline JS scripts, safe dynamic inline JS scripts, and unsafe dynamic inline JS scripts. Four dynamic inline JS scripts were created by the ASP.NET framework, represented in parentheses in Table 2. We excluded these from the total dynamic inline JS scripts because they are not under the developer’s control and should be addressed by changes to the ASP.NET library. Our tool automatically identified these dynamic inline JS scripts within the ASP.NET framework.

| Application | Total JS | Static | Safe Dynamic | Unsafe Dynamic |
|-------------|----------|--------|--------------|-----------------|
| BugTracker.NET | 46 | 18 | 3 | 2 (4) |
| BlogEngine.NET | 18 | 12 | 10 | 4 (4) |
| BlogSA.NET | 35 | 6 | 1 | 1 (4) |
| ScrewTurn Wiki | 6 | 5 | 4 | 4 (4) |
| WebGoat.NET | 41 | 4 | 0 | 0 (4) |
| ChronoZoom | 5 | 10 | 0 | 0 (4) |

From our results, it is clear that modern web applications frequently use inline JavaScript. The applications used between five and 46 total inline JS scripts, with 22% to 100% of these being static. deDacota was able to safely transform 50% to 70% of the dynamic inline JS scripts, resulting in zero to four actual unsafe dynamic inline JS scripts per application.

To ensure no false negatives, we manually browsed every ASP.NET Web Form in the application and searched for inline JavaScript in the original source code. No false negatives were found.

For applications with known vulnerabilities, we manually crafted inputs to exploit these bugs. After verifying that the exploits worked on the original version, we launched them against the rewritten versions (with the Content Security Policy header activated and a browser supporting CSP). As expected, the Content Security Policy in the browser, combined with our rewritten applications, successfully blocked all exploits.

### 3. Functional Correctness

To evaluate the correctness of our approach, we used two methods. First, we manually browsed web pages generated by each rewritten application, interacting with the site as a normal user. We looked for JavaScript errors, unexpected behaviors, or CSP violations and found no issues. Second, we leveraged the developer-written testing suite in ChronoZoom. Before applying our rewriting, the original application passed 160 tests. After rewriting, all 160 tests executed without errors.

### 4. Performance Analysis

To assess the impact of deDacota on application performance, we ran browser-based tests on original and transformed versions of two applications, using Internet Explorer 9.0. The web server was a 3 GB Hyper-V virtual machine running Microsoft IIS 7.0 under Windows Server 2008 R2, while the client was a similar VM running Windows 7. The physical server was an 8 GB, 3.16 GHz dual-core machine running Windows Server 2008 R2.

Table 3 summarizes the performance data:

| Application | Page Size (bytes) | Loading Time (seconds) |
|-------------|-------------------|------------------------|
| ChronoZoom (original) | 50,827 | 0.65 |
| ChronoZoom (transformed) | 20,784 | 0.63 |
| BlogEngine.NET (original) | 18,518 | 0.15 |
| BlogEngine.NET (transformed) | 19,269 | 0.16 |

As shown, deDacota’s transformations did not significantly affect page-loading times. The transformed ChronoZoom page is less than half the size of the original due to the significant amount of script code. Conversely, the BlogEngine.NET page is slightly larger due to the replacement of small amounts of script code with longer links to script files. The page-loading times reflect the page sizes, indicating no discernible performance impact.

### 5. Discussion

Our rewriting results highlight the nature of inline JavaScript in web applications. Of the four applications with dynamic JavaScript, 12.2% to 77.8% of the total inline JavaScript is dynamic. This is important because one of BEEP’s XSS prevention policies involves a whitelist containing the SHA1 hash of allowed JavaScript. However, modern web applications often include dynamic elements, necessitating new approaches to handle dynamic JavaScript.

BEEP and Blueprint require developers to manually annotate sinks to neutralize untrusted data. For example, in BlogSA.NET, there are 407 TextWriter.Write call sites in 29 Web Forms. Manually analyzing and annotating these sinks is labor-intensive.

Unlike BEEP and Blueprint, deDacota is fully automatic and does not require developer annotations. While deDacota cannot prevent all XSS vulnerabilities in dynamic inline JavaScript, it significantly reduces the number of sinks that need to be examined. In BlogSA.NET, there are three sinks within the single unsafe dynamic JavaScript. Taint analysis can further reduce the number of sinks by checking if untrusted input can reach a sink in the dynamic JavaScript.

### 6. Limitations

deDacota aims to automatically separate JavaScript code from HTML data in web pages using static analysis. While effective with real-world web applications, it has limitations. .NET's dynamic language features, such as dynamic assembly loading and reflection, may compromise the soundness of static analysis. However, these features are rarely used in ASP.NET web applications. We handle loops conservatively, assuming their output does not contain script tags, which holds for the tested applications but may not for others.

We do not offer a formal proof of deDacota's correctness, leaving this to future work. deDacota currently supports string concatenations but not more complex operations like regular expressions. When deploying deDacota, we recommend performing all tests on the rewritten binary and using CSP’s “Report Only” mode during testing and initial deployment to detect missed inline JavaScript.

Finally, our prototype does not handle JavaScript code in HTML attributes. While this is not fundamentally more difficult, it requires generating unique identifiers for HTML elements associated with JavaScript attributes.

### 7. Related Work

Various approaches have been proposed to address different types of XSS, including input sanitization and restrictions on script generation and execution. Server-side techniques aim to generate pages free of XSS vulnerabilities, involving validation, injection of sanitizers, and automatic generation of XSS-free scripts. Examples include Saner, which uses static and dynamic analysis to track and test unsafe inputs, and ScriptGard, which analyzes scripts for XSS vulnerabilities.