29
30
67
15
0
11
26
4
0
0
Table 1: ASP.NET Web Form applications that we ran deDacota on to test its applicability to real-world
web applications.
ASP.NET Web Forms, but the main application is a Java-
Script-heavy HTML page. We use ChronoZoom because,
unlike the other applications, it has an extensive test suite
that exercises the JavaScript portion of the application. To
evaluate the correctness of our rewriting, we converted the
main HTML page of ChronoZoom, which contained inline
JavaScript, into an ASP.NET Web Form page, along with
nine other HTML pages that were used by the test suite.
These six real-world web applications encompass the spec-
trum of web application functionality that we expect to en-
counter. These applications constitute a total of 100,000
lines of code, written by diﬀerent developers, each with a
diﬀerent coding style. Some had inline JavaScript in the
ASP.NET page, some created inline JavaScript in C# di-
rectly, while others created inline JavaScript in C# using
string concatenation. Furthermore, while analyzing each ap-
plication we also analyzed the entire .NET framework (which
includes ASP.NET); all 256 MB of binary code. As our anal-
ysis handles ASP.NET, we are conﬁdent that our approach
can be applied to the majority of ASP.NET applications.
6.2 Security
We ran deDacota on each of our test applications. Ta-
ble 2 shows the total number of inline JS scripts per ap-
plication and a breakdown of the number of static inline JS
scripts, the number of safe dynamic inline JS scripts, and the
number of unsafe dynamic inline JS scripts. There were four
dynamic inline JS scripts created by the ASP.NET frame-
work, and these are represented in Table 2 in parentheses.
We chose to exclude these four from the total dynamic in-
line JS scripts because they are not under the developer’s
control, and, furthermore, they can and should be addressed
by changes to the ASP.NET library. Furthermore, it is im-
portant to note that our tool found these dynamic inline JS
scripts within the ASP.NET framework automatically.
From our results it is clear that modern web applications
frequently use inline JS scripts. The applications used a
range of ﬁve to 46 total inline JS scripts. Of these total
inline JS scripts 22% to 100% of the inline JS scripts were
static.
deDacota was able to safely transform, using the tech-
nique outlined in Section 4.5, 50% to 70% of the dynamic
inline JS scripts. This result means that our mitigation tech-
nique worked in the majority of the cases, with only zero to
four actual unsafe dynamic inline JS scripts per application.
We looked for false negatives (inline JavaScript that we
might have missed) in two ways. We manually browsed to
every ASP.NET Web Form in the application and looked for
inline JavaScript. We also searched for inline JavaScript in
the original source code of the application to reveal possible
scripts the previous browsing might have missed. We did
not ﬁnd any false negatives in the applications.
To evaluate the security improvements for those applica-
tions that had known vulnerabilities, we manually crafted
inputs to exploit these know bugs. After verifying that the
exploits worked on the original version of the application, we
launched them against the rewritten versions (with the Con-
tent Security Policy header activated, and with a browser
supporting CSP). As expected, the Content Security Pol-
icy in the browser, along with our rewritten applications,
successfully blocked all exploits.
6.3 Functional Correctness
To evaluate the correctness of our approach, and to verify
that we maintained the semantics of the original applica-
tion, we used two approaches. First, we manually browsed
web pages generated by each rewritten application and in-
teracted with the web site similar to a normal user. During
this process, we looked for JavaScript errors, unexpected be-
haviors, or CSP violations. We did not ﬁnd any problems or
deviations. Second, and more systematically, we leveraged
1212Application
Total JS
Static
BugTracker.NET 46
BlogEngine.NET 18
12
BlogSA.NET
35
ScrewTurn Wiki
6
WebGoat.NET
ChronoZoom
5
41
4
10
27
6
5
Safe
Dynamic
3
10
1
4
0
0
Unsafe
Dynamic
2 (4)
4 (4)
1 (4)
4 (4)
0 (4)
0 (4)
Table 2: Results of running deDacota against the
ASP.NET Web Form applications. Safe Dynamic
is the number of dynamic inline JS scripts that we
could safely transform, and Unsafe Dynamic is the
number of dynamic inline JS scripts that we could
not safely transform.
Application
ChronoZoom (original)
ChronoZoom (transformed)
BlogEngine.NET (original)
BlogEngine.NET (transformed)
Page Size
50,827
20,784
18,518
19,269
Loading Time
0.65
0.63
0.15
0.16
Table 3: Performance measurements for two of the
tested applications, ChronoZoom. Page Size is the
size (in bytes) of the main HTML page rendered
by the browser, and Loading Time is the time (in
seconds) that the browser took to load and display
the page.
the developer-written testing suite in ChronoZoom. Before
we applied our rewriting, the original application passed 160
tests. After rewriting, all 160 tests executed without errors.
6.4 Performance
To assess the impact of deDacota on application perfor-
mance, we ran browser-based tests on original and trans-
formed versions of two of the tested applications. Our per-
formance metric was page-loading time in Internet Explorer
9.0, mainly to determine the impact of moving inline Java-
Script into separate ﬁles. The web server was a 3 GB Hyper-
V virtual machine running Microsoft IIS 7.0 under Windows
Server 2008 R2, while the client was a similar VM running
Windows 7. The physical server was an 8 GB, 3.16 GHz
dual-core machine running Windows Server 2008 R2.
Table 3 shows test results for two web applications, sum-
marizing performance data from page-loading tests on the
client. The table columns list the average sizes of the main
HTML pages retrieved by the browser by accessing the main
application URLs, along with the average time used by the
browser to retrieve and render the pages in their entirety.
All the numbers were averaged over 20 requests.
As Table 3 indicates, deDacota’s transformations in-
curred no appreciable diﬀerence in page-loading times. Be-
cause the original ChronoZoom page contained a signiﬁcant
amount of script code, the transformed page is less than half
of the original size. On the other hand, the BlogEngine.NET
page is slightly larger because of its small amount of script
code, which was replaced by longer links to script ﬁles. The
page-loading times mirror the page sizes, also indicating that
server-side processing incurred no discernible performance
impact.
6.5 Discussion
The results of our rewriting shed light on the nature of
inline JavaScript in web applications. Of the four applica-
tions that have dynamic JavaScript, 12.2% to 77.8% of the
total inline JavaScript in the application is dynamic. This is
important, because one of BEEP’s XSS prevention policies
is a whitelist containing the SHA1 hash of allowed Java-
Script [20]. Unfortunately, in the modern web JavaScript is
not static and frequently includes dynamic elements, necessi-
tating new approaches that can handle dynamic JavaScript.
The other security policy presented in BEEP is DOM
sandboxing. This approach requires the developer to man-
ually annotate the sinks so that they can be neutralized.
Blueprint [28] works similarly, requiring the developer to
annotate the outputs of untrusted data. Both approaches
require the developer to manually annotate the sinks in the
application in order to specify the trusted JavaScript. To
understand the developer eﬀort required to manually anno-
tate the sinks in the application, we counted the sinks (i.e.,
TextWriter.Write call sites) inside the 29 Web Forms of
BlogSA.NET and there were 407.
In order to implement
either BEEP or Blueprint a developer must manually an-
alyze all sinks in the application and annotate any that could
create untrusted output.
Unlike BEEP and Blueprint, deDacota is completely
automatic and does not require any developer annotations.
deDacota cannot prevent XSS vulnerabilities in dynamic
inline JavaScript completely. If a developer wishes to pre-
vent all XSS vulnerabilities after applying deDacota, they
would only need to examine the sinks that occur within the
unsafe dynamic inline JavaScript.
In BlogSA.NET, there
are three sinks within the single unsafe dynamic JavaScript.
One could further reduce the number of sinks by using taint
analysis to check if untrusted input can reach a sink in the
dynamic JavaScript.
7. LIMITATIONS
The goal of deDacota is to automatically separate the
JavaScript code from the HTML data in the web pages of a
web application using static analysis. We have shown that
deDacota is eﬀective with real-world web applications. In
this section, we discuss its limitations in general.
The programming language of .NET has the following dy-
namic language features: dynamic assembly loading, dy-
namic compilation, dynamic run-time method calling (via
reﬂection), and threading. The use of these features may
compromise the soundness of any static analysis including
ours in deDacota. However, these language features are
rarely used in ASP.NET web applications in practice. For
instance, those applications we tested did not use any of
these features. Furthermore, deDacota is aﬀected only if
the use of these features determines the HTML output of an
application.
On one hand, we handle loops conservatively by approx-
imating that a loop can produce anything. On the other
hand, we treat the output of a loop as a * in the approxi-
mation graph and assume it does not aﬀect the structure of
the approximation graph in a way that impacts our analysis.
For instance, we assume the output of a loop does not con-
tain the opening or closing script tag. Our analysis will be
incorrect if this assumption is violated. While we found that
this assumption holds for all the web applications we tested,
it is possible that this assumption will not hold for other
programs, thus requiring a diﬀerent approach to handling
loops.
We do not oﬀer any formal proof of the correctness of
deDacota. While we believe that our approach is correct in
1213absence of the dynamic language features, we leave a formal
proof of this to future work.
deDacota currently supports the analysis of string con-
catenations. The support for more complex string opera-
tions such as regular expressions is left for future work. A
potential approach is to leverage an automata-based string
analysis engine [50].
Our approach to sanitizing dynamic JavaScript code may
not preserve an application’s semantics when the dynamic
content being sanitized as a string is meant to be used in
multiple JavaScript contexts.
When deploying deDacota in practice, we recommend
two practices to mitigate its limitations. First, all tests
for the original web application should be performed on
the rewritten binary to detect any disruptions to the ap-
plication’s semantics. Second, CSP’s “Report Only” mode
should be used during the testing and initial deployment.
Under this mode, the browser will report violations back to
the web server when unspeciﬁed JavaScript code is loaded.
This helps detect inline JavaScript code that is missed by
deDacota.
Finally, our prototype does not handle JavaScript code
in HTML attributes. We do not believe that there is any
fundamental limitation that makes discovering JavaScript
attributes more diﬃcult than inline JavaScript. The only
minor diﬃculty here is in the rewriting. In order to sepa-
rate a JavaScript attribute into an external JavaScript, one
must be able to uniquely identify the DOM element that
the JavaScript attribute aﬀects. To do this, it would re-
quire generating a unique identiﬁer for the HTML element
associated with the JavaScript attribute.
8. RELATED WORK
A broad variety of approaches have been proposed to ad-
dress diﬀerent types of XSS, though no standard taxonomy
exists to classify these attacks and defenses. In general, XSS
defenses employ schemes for input sanitization or restric-
tions on script generation and execution. Diﬀerences among
various techniques involve client- or server-side implementa-
tion and static or dynamic operation. We group and review
XSS defenses in this context.
8.1 Server-Side Methods
While CSP itself is enforced by browsers [42], our ap-
proach for leveraging CSP is a static, server-side XSS de-
fense. There has been much previous research in server-side
XSS defenses [3, 4, 13, 14, 22, 28, 34, 35, 38, 40, 43]. Server-
based techniques aim for dynamically generated pages free
of XSS vulnerabilities. This may involve validation or in-
jection of appropriate sanitizers for user input, analysis of
scripts to ﬁnd XSS vulnerabilities, or automatic generation
of XSS-free scripts.
Server-side sanitizer defenses either check existing saniti-
zation for correctness or generate input encodings automat-
ically to match usage context. For example, Saner [3] uses
static analysis to track unsafe inputs from entry to usage,
followed by dynamic analysis to test input cases for proper
sanitization along these paths. ScriptGard [40] is a com-