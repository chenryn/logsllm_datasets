•
Scanning VS. List traversal
•
Scanning 
– Can be very slow
– Tends to be high assurance
•
Link/Pointer Traversal
– Easily confused
– Super Fast !
IOActive, Inc. Copyright ©2014.  All Rights Reserved.
What’s  a  Process?
•
A Process is an address space configuration
– A container for threads which are executed on a CPU.
– Threads share address space.
– Hard to know if you have them all.
– Can’t I inject a library/thread to an existing process?
• Code overwrite or injection is an integrity issue 
– Hash Check
IOActive, Inc. Copyright ©2014.  All Rights Reserved.
Process Detection
•
Volatility to the rescue! 
https://code.google.com/p/volatility/wiki/CommandRefer
ence#psxview
– It compares the following logical identifiers:
• PsActiveProcessHead linked list
• EPROCESS pool scanning
• ETHREAD pool scanning (then it references the owning 
EPROCESS)
• PspCidTable
• Csrss.exe handle table
• Csrss.exe internal linked list (unavailable Vista+)
IOActive, Inc. Copyright ©2014.  All Rights Reserved.
Takahiro Haruyama -- April 2014, discuss his BH 
Europe 2012 talk with respect to Abort Factors.
IOActive, Inc. Copyright ©2014.  All Rights Reserved.
64bit Process Detection
•
Earlier presentation for kernel code 
– E.g. CSW14 Diff CPU Page table & Logical kernel objects 
(to  detect  hidden  kernel  modules,  “rootkit  revealer”)
•
Also uses page tables “Locating  x86  paging  structures  in  
memory  images”  
https://www.cs.umd.edu/~ksaur/saurgrizzard.pdf
– Karla Saur, Julian B. Grizzard
•
New process detection technique is faster - single pass
– Similar  to  “pmodump”,  enhanced  with  64bit  &  additional  
checks (64bit scan has much more verifiability)
IOActive, Inc. Copyright ©2014.  All Rights Reserved.
64bit Process Detection Integrity
•
Not easily attacked
– Many modifications result in BSOD
– Able to extract candidate memory for integrity checking of 
memory pages to fully qualify
• Can make “non-abortable”  if willing to do slower check
• Current check is really good
– Always room to grow with respect to countermeasures 
and performance
IOActive, Inc. Copyright ©2014.  All Rights Reserved.
A quick indirection
•
Slides 37-39 from Dave Probert (Windows Kernel 
Architect, Microsoft)
– Windows Kernel Architecture Internals
•
Next  slide  show’s  a  big  hint,  can  you  guess?  It’s  an  
example of process page table layout/configuration.
– You have  to  love  all  of  those  arrow’s  
IOActive, Inc. Copyright ©2014.  All Rights Reserved.
IOActive, Inc. Copyright ©2014.  All Rights Reserved.
Self Map trick in Linux
•
Virtual Memory in the IA-64 Linux Kernel
– Stephane Eranian and David Mosberger
• 4.3.2 Virtually-mapped linear page tables
“linear  page tables are not very practical when implemented 
in physical memory”
“The  trick that makes this possible is to place a self-mapping 
entry in the global directory.”
IOActive, Inc. Copyright ©2014.  All Rights Reserved.
Self Map process detection Windows 
AMD64
•
Self Map exists for each process (not only kernel:) 
•
Examining a page table - !process 0 0  dirbase/cr3 
(e.g. 7820e000)
!dq 7820e000  
#7820e000 00800000`60917867
!dq 7820e000+0xf68
#7820ef68 80000000`7820e863
^-- current PFN found --^         (PFN FTW) 
IOActive, Inc. Copyright ©2014.  All Rights Reserved.
PFN FTW Trick! (or Defensive exploit!!)
#7820ef68 80000000`7820e863
^----------^
64Bit is a more powerful check
Valid PFN will be bounded by system 
physical memory constraints
IOActive, Inc. Copyright ©2014.  All Rights Reserved.
Self Map Detection Attacks
•
Attacks against performance
– If we de-tune performance we can validate spoof entries 
and various malformed cases
– Windows  zero’s  memory  quickly  (no  exiting  processes,  so  
far:)
•
!ed [physical] can be done to assess evasive 
techniques
– Simply destroying self map results in BSOD!! 
– Looking for feedback testing to identify better more 
comprehensive PTE flag checks (edge cases, missed 
tables or extra checks)
IOActive, Inc. Copyright ©2014.  All Rights Reserved.
Implementation (basically in 1 line)
IOActive, Inc. Copyright ©2014.  All Rights Reserved.
Example execution (.vmem starts @0 offset), .DMP (0x2000+) 
or other autodetect header offset 
IOActive, Inc. Copyright ©2014.  All Rights Reserved.
Detect processes of guests from host 
dump
•
A host memory dump will include page tables for every 
guest VM process as well as host process entries
– Lots of room to grow here, deep integration with 
HyperVisor page mapping data may be straight forward
• E.g. parsing of MMInternal.h / MMPAGESUBPOOL in 
VirtualBox
•
Issues
– Hypervisor may not wipe when moving an instance or 
after  it’s  been  suspended  (ghost  processes)
• I’d  rather  detect  ghosts  than  fail  
•
Nested paging not a problem
IOActive, Inc. Copyright ©2014.  All Rights Reserved.
Skew is evident for guest instances.  An typical kernel PFN is observed  
(scream 187 to a mo…) as the first (large jump 0x2..->0x4…)  in  a  range  
of skewed diff values (another layer of decoding to adjust, similar to what 
happens when snapshot is requested and disk memory is serialized)
Initial values reflective of host system, consistent Diff values 
Final host processes identifiable by Diff realignment 
IOActive, Inc. Copyright ©2014.  All Rights Reserved.
Detected Memory Runs
•
Round value by offset to find gap size, adjust to 
automate memory run detection
– Takahiro Haruyama blog post on related issue (large 
memory) and also memory run detection issues from 
logical sources
•
*previous slide, detecting gap, when offset changes;
– ROUND_UP(0xb4b56000, 0x40000000) = first run end 
0xc0000..
–
ROUND_DOWN(0x1181f1000, 0x40000000)
IOActive, Inc. Copyright ©2014.  All Rights Reserved.
Future Weird Machine overload  ? 
•
Microsoft Research
– Tracking Rootkit Footprints with a Practical Memory 
Analysis System -- Weidong Cui, Marcus Peinado, Zhilei
Xu, Ellick Chan
– “The  goal  of  MAS  is  to  identify  all  memory  changes  a  
rootkit  makes….  MAS  does  so  in  three  steps:  static 
analysis, memory traversal and integrity checking”
•
Seems really hard problem (source code used in MAS), 
how can we verify this level of state?
IOActive, Inc. Copyright ©2014.  All Rights Reserved.
Public symbols to the rescue’ish 
•
Public symbols, RTTI or other type inference technique 
to find/root(tree/linked) all pointers
– Thread stack return into verifiable code
• Anti RoP Attack
– Advanced methods kernel pool (does not require source) 
verification
• Integrity Checking of Function Pointers in Kernel Pools via 
Virtual Machine Introspection
–
At least kernel alerts, logs and various tracing can be trusted if 
we have code integrity, process/thread detection.
– Future is not too bad for Defense!
IOActive, Inc. Copyright ©2014.  All Rights Reserved.
Summary
•
Attacks: WeIrD MaChInE
– Worst case scenario most weird machine activity can 
hopefully be detected through simple tracing, logging and 
monitoring tools
• What about the next GPU/UEFI backdoor?   use a 
hypervisor guest to establish device/low layer trust capability
•
Defenses: Detecting hidden 64bit processes 
•
Deep future holds deep verifiability for more devices  (get free 
The Memory Cruncher™  TMC  &  BlockWatch ™  )  
•
FINALLY DEFENSIVE FUN & PROFIT! With the D!
IOActive, Inc. Copyright ©2014.  All Rights Reserved.
Summary
•
Always use a VM
– At least simplify memory dumping
•
Use ProcDetect
– Have fun detecting!
– Process hiding rootkit is dead
– 64bits helps peace of mind
•
We can detect a process anywhere (host, guest, 
nested, on the network (probably)!
IOActive, Inc. Copyright ©2014.  All Rights Reserved.
Issues, Considerations Caveats
•
Use a hypervisor – secure the guest/host (very hardened 
host)
– Hypervisor  escape  ==  you’re  a  high  value  to  risk  nice  exploit
• Probably NOT YOU!
• BluePill type attacks, hopeful still to consider (but perf hit of 
nesting should be obvious)
•
SefMap Detection relies on page table.
– Maybe  “no paging process”– (same as x86 paging paper)
– TSS considerations, monitor other tables with stacks?
– Remote DMA?
• Please no! 
IOActive, Inc. Copyright ©2014.  All Rights Reserved.
Thank you & Questions
•
I hope I referenced earlier works sufficiently, this topic is 
broad and expansive, thanks to the many security 
professionals who analyze memory, reverse-engineered, 
dove deep and discussed their understanding.
•
References, follow embedded links and their links