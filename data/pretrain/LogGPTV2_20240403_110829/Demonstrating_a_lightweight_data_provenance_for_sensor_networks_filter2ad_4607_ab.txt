provenance ibf.
(1)
2.2 Provenance Decoding
Figure 2 shows the provenance mechanism decoding steps.
When the base station receives a data packet, it checks for all
possible safe paths of packets from the same source node of this
packet. These paths have been previously saved by the base
station. It then computes the provenance of these paths by using
Figure 2: Provenance decoding at the Base Station (BS).
the information in the packet, and compares it to the provenance
encoded by Bloom ﬁlter enclosed with the data packet. If there is a
match, the data is considered for further processing and analysis.
If there is a mismatch, then the arrived data packet has either
taken a new route that could be safe but had not been previously
saved at the base station node, or a previous packet(s) of the same
source node has (have) been dropped while on its way to the base
station. In the former case, the base station traces back the path
and computes the provenance at each node until it reaches the
If the provenance matches, then the base station
source node.
adds this new route to its set of safe paths.
If there is still
a mismatch, then the data packet has been tampered either by
inserting a malicious node in to the network or by compromising
an existing node. In this case, we check for compromised nodes
and change the route dynamically to avoid such nodes.
In the
latter case where a mismatch is caused by a dropped packet,
this dropping may be due to non-malicious network errors, or
to malicious attacks.
In the latter case, the base station traces
back the node responsible for dropping packets and analyzes the
frequency of dropped packets by this node to determine whether it
is a normal behavior or an attack. This procedure is executed by
tracing back every intermediate node starting from the base station
and comparing the components used for encoding the provenance,
and ﬁnally comparing the node’s last sequence number of the data
packet (pSeq) with the current sequence number of the passing data
packet (Seq) from the corresponding source node.
2.3 Detecting Packet Dropping Attacks
Every intermediate node stores the last sequence number of the
data packet (pSeq) that passed through it for every source node.
When the same source node sends another packet through the same
intermediate node, it uses the (pSeq) together with the current
sequence number of the passing data packet (Seq) to encode the
provenance. This approach helps the base station locate the node
that dropped certain data packets when there is a mismatch in the
provenance by checking the last processed packet coming from the
same source. The base station will be checking the variables at
every intermediate node to ﬁnd which node dropped the packet that
could have caused the mismatch in the computed provenance. By
comparing its own (pSeq) and (Seq) for the corresponding source
canbegeneratedinvariouswaystoservethepurpose.Tokeepthesolutionsimpler,wetransmitpacketsequencenumbertoacknowl-edgeapacket.Foranyj-thpacket,anodecreatesavertexandthevertexIDasfollows=(,,)(5)=(∣∣)whereisthesequencenumberattachedtothecurrentpacketandisthestoredinformationataboutthesequencenum-berofthe(−1)-thpacket.Toupdatetheprovenancegraphofthepacket,theninsertsintotheassociatediBF.TobenotedFigure4:Extendedprovenanceframeworktodetectpacketdroppingattackandidentifythemaliciouslink.Provenanceencodingatasensornode.Itisasimpleextensiontothebasicencodingscheme.that,anodemustmaintainaper-ﬂowrecordtostorethepreviouspacketsequenceforeachdataﬂowpassedthroughit.Wheneveranodeprocesses/forwardsapacket,itupdatesthepreviouspacketrecordoftheappropriatedataﬂowwiththerecentlyprocesspacketsequence.Ifanodereceivespacketfromadataﬂowforwhichithasnopacketsequenceinformation,thenitmayuseapre-speciﬁedspecialpurposeidentiﬁer,suchas0.Itaddressesthecaseofrout-ingpathchangewhereanewnodeinthepathcanusethisspecialidentiﬁerforencodingprovenance.Moreover,ifanodedoesnotreceivepacketsfromadataﬂowforalongtime,itcanerasethepreviouspacketinformationforthatﬂowtoreducespaceoverhead.Anyway,thenodecangetupdatedandmaintainthisrecordwhenitreceivespacketsfromthatﬂowmorefrequently.2.ProvenanceDecodingattheBS:TheBSalsostoresthese-quencenumberofthemostrecentpacketprocessedforeachdataﬂow.Uponreceivingapacket,theBSretrievesthesequenceofthelastpackettransmittedbythesourcenodefromthepacketheader,fetchesthepreviouspacketsequencefortheﬂowfromitslocalstorageandthencomparesthesetwosequencenumbers.Ifthereisnopacketdroppingattack,eachnodeinthepathaswellastheBSreceivesallpacketsintheﬂowandthuspossessesthesameprevi-ouspacketsequence.Otherwise,iftheBSobservesadifferencebetweenthesetwosequencenumbers,itinfersaboutapossiblepacketlossandthentakesnecessaryactionstoconﬁrmtheeventandtolocalizethefaultylink.However,theprovenanceveriﬁca-tionand/orcollectionareperformedaccordingtothealgorithms1and2,respectively.Theonlydifferenceisthat,theBSnowcreatesthevertexIDcorrespondingtoanodeaccordingtotheEq.5.3.FaultyLinkIdentiﬁcationusingProvenance:Assume,adatapacket[]hasbeendroppedatanintermediatenode.Thus,thenodes,1,...,received[]andupdatedtheirlastlyseenpacketsequencesto[].Onthecontrary,nodes+1,...,aswellastheBSdidnotobserve[],TheyhavenowaytoupdateFigure5:Packetlossdetectionandfaultylinkidentiﬁcationusingprovenance.theprecedingpacketsequencebuttoretainthesameoldidentiﬁer[−1].Uponreceivingthenextpacketintheﬂow,,1,...,−1certainlyinclude[]intheprovenancemetadatawhereas+1,...,use[−1]forthispurpose.However,themaliciousnodemayeither(i)use[],whichleadstheBStodetectasfaulty(ii)use[−1],inwhichcasethelink(−1)isidenti-ﬁedasfaulty.Inanycase,anadjacentlinktothemaliciousnodeisidentiﬁedandheldresponsiblefor.Withoutthelossofgenerality,weassumethatthemaliciousnodeencodes[−1].Figure5showsthealgorithmtoidentifyanearlierpacketloss,tolocalizethefaultylink,andalsotoensurethatnootherattackhasbeenencounteredonthecurrentpacket.ItusesthereceivediBFtoidentifythecontributingnodesandtocollecttheirencodedprovenancerecords.Forthispurpose,itchecksthemembershipofallnodesinthenetworkwithintheiBFusingatwosteppro-cess.Theﬁrstqueryisperformedwiththepreviouspacketiden-tiﬁer()containedinthepacketheaderandthenextonewiththesequencenumber()recordedattheBS.Let,thesetofnodesfoundintheﬁrstandsecondsteparerespectively1=and2=.TheBFconstructedwith1and2are1and2,respectively.TheﬁnalBloomﬁlterisconstructedasabitwise-ORof1and2.IfandthereceivediBFcompletelymatches,theeventofapacketlossisconﬁrmed.Inthiscase,thepathconstructedonthesetofnodesS=12isequivalenttothepathaswellas1=and2=.Thus,wecanconcludethatthelink(−1)isfaultyandcausesthepacketloss.4.CertiﬁcationofAttack:Toconﬁrmthatthefaultylink(−1)isactuallymalicious(i.e.causespacketdroppingattack),theBSob-servesmorepackets.WhenevertheBSidentiﬁesapacketlossandtheresponsiblelink(−1),itupdatestheempiricallossrate(−1)forthelink.Assume,thedropratethresholdforalinkis,whereisgreaterthanthenaturallossrateofanylink.Ifafteranumberofpackettransmissions,(−1)>,thentheBSconvicts(−1)asamaliciouslink.1023node with every intermediate node in the path, the base station
can determine the responsible node for packet dropping, and it
measures the frequency of dropped packets at that particular node
to determine whether a packet dropped attack exists or not.
3. SCENARIOS
For demonstration purposes, we have simulated the entire sensor
network on a single computer. Each node in the network is running
its own Java program on a separate port acting as a sensor node,
where the network map identiﬁes the nodes by their corresponding
port number. Our goal is to show different scenarios that reﬂect
the main contribution of our work allowing the audience to interact
with our system and test its efﬁciency.
Scenario 1: Multiple source nodes will send packets towards the
base station. We will show how the provenance is encoded at every
intermediate node and how it is decoded once it arrives the base
station. The goal is to see the provenance decoding code running at
the base station and to see a matching provenance.
We believe the above scenarios will demonstrate the importance
of our approach by showing its effectiveness and efﬁciency on
sensor data for secure data transmission. Figure 3 shows how our
audience will visualize the path that every data packet takes and the
Bloom ﬁlter provenance encoding at every node as in ﬁgure 4.
Scenario 2: While source nodes are sending packets to the base
station, some malicious nodes are introduced into the network. The
purpose of this scenario is to show how the base station raises the
ﬂag at untrusted data received by the network.
Scenario 3: We will show how the base station detects packet
dropping attacks and locates the responsible node.
Figure 3: Complete path of a data packet from source node 12
to base station node 10.
4. CONCLUSION
In this demonstration, we develop a light weight scheme for
securely transmitting provenance for sensor networks. Our scheme
uses Bloom ﬁlters to encode and decode the provenance, and
is capable of detecting packet dropping attacks and localizing
malicious sensor nodes as well as to dynamically change the route
of data packets to avoid using such nodes.
5. ACKNOWLEDGMENTS
The work reported in this paper has been partially supported by
the Northrop Grumman Cybersecurity Research Consortium, and
NSF under grants NSF-CNS 0964294 and NSF CNS-1111512.
Figure 4: Final Bloom ﬁlter based provenance at the base
station node 10.
6. REFERENCES
[1] I. Akyildiz, W. Su, Y. Sankarasubramaniam, and E. Cayirci.
A survey on sensor networks. Communications Magazine,
IEEE, 40(8):102 – 114, Aug 2002.
[2] S. Chong, C. Skalka, and J. A. Vaughan. Self-identifying
sensor data. In Proceedings of the 9th ACM/IEEE
International Conference on Information Processing in
Sensor Networks, IPSN ’10, pages 82–93, New York, NY,
USA, 2010. ACM.
[3] I. Foster, J. VÃ˝uckler, M. Wilde, and Y. Zhao. Chimera: A
virtual data system for representing, querying, and
automating data derivation. In 14th Conference on Scientiﬁc
and Statistical Database Management, pages 37–46, 2002.
[4] A. Ghani and P. Nikander. Secure in-packet bloom ﬁlter
forwarding on the netfpga. In Proceedings of the European
NetFPGA Developers Workshop, 2010.
[5] R. Hasan, R. Sion, and M. Winslett. The case of the fake
picasso: Preventing history forgery with secure provenance.
[6] H.-S. Lim, Y.-S. Moon, and E. Bertino. Provenance-based
trustworthiness assessment in sensor networks. In
Proceedings of the Seventh International Workshop on Data
Management for Sensor Networks, DMSN ’10, pages 2–7,
New York, NY, USA, 2010. ACM.
[7] T. M. . F. N. Ramachandran A., Bhandankar K. Packets with
provenance. Technical report, Georgia Institute of
Technology, 2008.
[8] Y. L. Simmhan, B. Plale, and D. Gannon. A survey of data
provenance in e-science. SIGMOD RECORD, 34:31–36,
2005.
[9] A. Syalim, T. Nishide, and K. Sakurai. Preserving integrity
and conﬁdentiality of a directed acyclic graph model of
provenance. In Proceedings of the 24th annual IFIP WG
11.3 working conference on Data and applications security
and privacy, DBSec’10, pages 311–318, Berlin, Heidelberg,
2010. Springer-Verlag.
[10] N. N. Vijayakumar and B. Plale. Towards low overhead
provenance tracking in near real-time stream ﬁltering. In
Proceedings of the 2006 international conference on
Provenance and Annotation of Data, Berlin, 2006.
[11] M. N. Wybourne. National cyber security, research and
development challenges related to economics, physical
infrastructure and human behavior. Technical report, Institute
for Information Infrastructure Protection (I3P), Dartmouth
College, 2009.
1024