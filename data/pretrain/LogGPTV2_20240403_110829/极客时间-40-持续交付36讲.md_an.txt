## 使用本地缓存虽然搭建私有仓库可以解决代码或者依赖下载的问题，但是私有仓库不能滥用，还是要结合构建机器本地的磁盘缓存才能达到利益最大化。如果每次依赖拉取都走一次网络下载，一方面网络下载的速度通常会比本地磁盘慢很多，另一方面在构建量很大时，并发请求会导致私有仓库出现网卡打爆或者出现莫名其妙的异常，从而导致所有的构建过程变得不稳定，甚至影响其他工具的使用。所以，妥善地用好本地缓存十分重要。这里说的"妥善"，主要包括以下两个方面：1.  对于变化的内容，增量下载；2.  对于不变的内容，不重复下载。目前，很多工具都已经支持这两点了。对于第一点，项目的源码是经常变化的内容，下载源码时，如果你使用 Git进行增量下载，那么就不需要在每次构建时都重复拉取所有的代码。Jenkins 的Git 插件，也默认使用这种方式。对于第二点，Maven每次下载依赖后都会在本地磁盘创建一份依赖的拷贝，在构建下载之前会先检查本地是否已经有依赖的拷贝，从而达到复用效果。并且，这个依赖的拷贝是公共的，也就是说每个项目都可以使用这个缓存，极大地提升了构建效率。如果你使用 Docker，那么你可以在宿主机上 mount 同一个依赖拷贝目录到多个Slave容器上，这样多个容器就可以共享同一个依赖拷贝目录。你可以最大程度地利用这一优势，但要注意不要让宿主机的磁盘I/O 达到瓶颈。
## 规范构建流程程序员的祖训说：Less is More，Simple isBetter，这与大道至简的含义不谋而合。程序的追求是简约而不简单，但随着业务越来越复杂，构建过程中各种各样的需求也随之出现，虽然工具已经封装了很多实用的功能，但是很多情况下，你都需要加入一些自定义的个性化功能，才能满足业务需求。在携程，Java 构建过程中就有大量的额外逻辑，比如 Enforcer检查、框架依赖检查、Sonar检查、单元测试、集成测试等等，可以说是无所不用其极地去保证构建产物的质量。因此，当前复杂的构建过程再也回不到仅仅一条 mvn 或者 gcc命令就能搞定的年代。而这一套复杂的流程下来必定会花费不少时间，让程序员们有更多喝茶和去厕所的时间。追求高效的同时，又不舍弃这些功能，是一个现实而又矛盾的命题，我们能否做到二者兼顾呢？答案，当然肯定的。以 Java 构建为例，Enforcer 检查、框架依赖检查、Sonar检查、单元测试、集成测试这些步骤，并没有放在同一个构建过程中同步执行，而是通过异步的方式穿插在CI/CD 当中，甚至可以在构建过程之外执行。比如， Sonar 扫描在代码集成阶段执行，用户在 GitLab上发起一个合并请求（Merge Request），这时只对变更的代码进行对比 Sonar扫描，只要变更代码检查没有问题，那么就可以保证合并之后主干分支的代码也是没问题的。所以，用户发布时就无需再重复检查了，只要发布后更新远端 Sonar Qube的数据即可，同时，这个过程完全不会影响用户的构建体验。通过以上一些规范构建流程的做法，可以进一步提高构建速度。
## 善用构建工具正如我前面所说的，目前很多构建工具已经具备了非常多的功能来帮助我们更好地进行构建，因此，充分理解并用好这些功能就成了我们必须要掌握的武林绝学。以 Maven 为例，我来带你看看有哪些提速方式，当然其他的构建工具，如 Gradle等也都可以采用类似的方法：1.  **设置合适的堆内存参数。** 过小的堆内存参数，会使 Maven 增加 GC    次数，影响构建性能；过大的堆内存参数，不但浪费资源，而且同样会影响性能。因此，构建时，你需要反复试验，得到最优的参数。2.  **使用 -Dmaven.test.skip = true 跳过单元测试。** Maven    默认的编译命令是 mvn    package，这个命令会自动执行单元测试，但是通常我们的构建机器无法为用户提供一套完整的单元测试环境，特别是在分布式架构下。因此如果单元测试需要服务依赖，则可以去掉它。3.  **在发布阶段，不使用 Snapshot 版本的依赖。** 这就可以在 Maven    构建时不填写 -U    参数来强制更新依赖的检查，省下因为每次检查版本是否更新而浪费的时间。4.  **使用 -T 2C 命令进行并行构建。** 在该模式下 ，Maven    能够智能分析项目模块之间的依赖关系，然后并行地构建那些相互间没有依赖关系的模块，从而充分利用计算机的多核    CPU 资源。5.  **局部构建。**    如果你的项目里面有多个没有依赖关系的模块，那么你可以使用 -pl    命令指定某一个或几个模块去编译，而无需构建整个项目，加快构建速度。6.  **正确使用 clean 参数。** 通常情况下，我们建议用户在构建时使用 clean    参数保证构建的正确性。clean    可以删除旧的构建产物，但其实我们大多数时间可能不需要这个参数，只有在某些情况下（比如，更改了类名，或者删除了一些类）才必须使用这个参数，所以，如果某次变更只是修改了一些方法，或者增加了一些类，那么就不需要强制执行    clean 了。总之，如果你能熟练运用各种构建工具，那么你的效率一定会比其他人高，你的构建速度一定比其他人快。
## 总结我介绍了五种常见的构建提速的方式，分别是：1.  升级硬件资源，最直接和粗暴的提速方式；2.  搭建私有仓库，避免从外网下载依赖；3.  使用本地缓存，减少每次构建时依赖下载的消耗；4.  规范构建流程，通过异步方式解决旁支流程的执行；5.  善用构建工具，根据实际情况合理发挥的工具特性。然而，每个公司持续交付的构建流程不太一样，面临的问题与挑战也都不太一样，所以在优化前，一定要先了解问题原因，再对症下药。
## 思考题你所在公司的构建流程是什么样的？是否也面临性能的问题？你又是是如何解决这些问题的？欢迎你给我留言。![](Images/69e5b7a8ed8eecd006aa3ce5f76f78af.png){savepage-src="https://static001.geekbang.org/resource/image/55/0a/55b7b7cb930ca733523be64e3a720d0a.jpg"}
# 15 \| 构建检测，无规矩不成方圆在这个专栏的第 5 篇文章《手把手教你依赖管理》中，我介绍了构建 Java项目的一些最佳实践，同时也给你抛出了一个问题：如果用户偷懒不遵循这些规范该怎么办？所谓没有规矩不成方圆，构建是持续交付过程中非常重要的一步，而好的构建检测则可以直接提升交付产物的质量，使持续交付的流水线又快又稳。所以，也就有了Maven 构建中的大杀器：Maven Enforcer 插件。
## 什么是 Maven Enforcer 插件？Maven Enforcer 插件提供了非常多的通用检查规则，比如检查 JDK 版本、检查Maven 版本、检查依赖版本，等等。下图所示就是一个简单的使用示例。![](Images/f2d0bcd12f0c6aadb601384e40610aca.png){savepage-src="https://static001.geekbang.org/resource/image/cc/86/cc332605af04d20bda53d44f8d16cc86.png"}上述的配置会在构建时（准确的说是在 validate 时）完成三项检查：-   requireMavenVersion 检查 Maven 版本必须大于 3.3.9；-   requireJavaVersion 检查 JDK 版本必须大于等于 1.9；-   requireOS 检查 OS 必须是 Windows 系统。如果你使用 Java 1.8， Maven 3.3.3， 在 Linux 上构建，便会出现如下的错误：-   Rule 0: org.apache.maven.plugins.enforcer.RequireMavenVersion failed    with message: Detected Maven Version: 3.3.3 is not in the allowed    range 3.3.9.-   Rule 1: org.apache.maven.plugins.enforcer.RequireJavaVersion failed    with message: Detected JDK Version: 1.8.0-77 is not in the allowed    range 1.9.-   Rule 2: org.apache.maven.plugins.enforcer.RequireOS failed with    message: OS Arch: amd64 Family: unix Name: linux Version:    3.16.0-43-generic is not allowed by Family=windows``{=html}从而导致构建失败。那么，是否有办法在所有应用的构建前都执行 Enforcer 的检查呢。我在专栏的第 5篇文章《手把手教你依赖管理》中，也已经介绍了在携程内部，一般 Java应用的继承树关系，每个项目都必须继承来自技术委员会或公司层面提供的super-pom。携程在 super-pom 之上又定义了一层 super-rule 的 pom，这个 pom中定义了一系列的 Enforcer 规则。 这样，只要是集成了 super-pom的项目，就会在构建时自动运行我们所定义的检查。也许你会问了， 如果用户不继承 super-pom是不是就可以跳过这些规则检查了？是的， 继承 super-pom 是规则检查的前提。但是，我们不会给用户这样的机会， 因为上线走的都是统一的构建系统。构建系统在构建之前会先检查项目的继承树，继承树中必须包含 super-pom，否则构建失败。并且，构建系统虽然允许用户自定义 Maven的构建命令，但是会将 Enforcer 相关的参数过滤掉，用户填写的任何关于Enforcer 的参数都被视为无效。Enforcer会被强制按照统一标准执行，这样就保证了所有应用编译时都要经过检查。因为携程的构建系统只提供几个版本的 Java 和 Maven，并且操作系统是统一的Linux CentOS版本，所以就不需要使用之前例子中提到的三个检查，一定程度的缩小标准化范围，也是有效的质量保证手段。了解了 Maven Enforcer 插件，我再从 Maven Enforcer 内置的规则、自定义的Enforcer检查规则，以及构建依赖检查服务这三个方面，带你一起看看构建监测的"豪华套餐"，增强你对交付产物的信心。
## 丰富的内置的 Enforcer 规则Maven Enforcer 提供了非常丰富的内置检查规则，在这里，我给你重点介绍一下bannedDependencies 规则、dependencyConvergence 规则，和banDuplicateClasses 规则。**第一，bannedDependencies 规则****该规则表示禁止使用某些依赖，或者某些依赖的版本**，使用示例：![](Images/05b1f1b595cc8f4b8c6a8e6971bf5a4c.png){savepage-src="https://static001.geekbang.org/resource/image/27/ba/27f936902309c3ee2e71a8dd007018ba.png"}该代码检查的逻辑是，只允许使用版本大于等于 1.8.0 的 org.slf4j:slf4j-api依赖，否则将会出现如下错误：![](Images/95c94d7ae1b3fcc133a7003c1468d22f.png){savepage-src="https://static001.geekbang.org/resource/image/8f/8b/8feb3a6d98ed61748525dd53dcadf48b.png"}bannedDependencies 规则的常见应用场景包括：1.  当我们知道某个 jar    包的某个版本有严重漏洞时，可以用这种方法禁止用户使用，从而避免被攻击；2.  某个公共组件的依赖必须要大于某个版本时，你也可以使用这个方法禁止用户直接引用不兼容的依赖版本，避免公共组件运行错误。**第二，dependencyConvergence 规则**在《手把手教你依赖管理》一文中，我介绍了 Maven的依赖仲裁的两个原则：最短路径优先原则和第一声明优先原则。但是，Maven基于这两个原则处理依赖的方式过于简单粗暴。毕竟在一个成熟的系统中，依赖的关系错综复杂，用户很难一个一个地排查所有依赖的关系和冲突，稍不留神便会掉进依赖的陷阱里，这时dependencyConvergence 就可以粉墨登场了。**dependencyConvergence 规则的作用是： 当项目中的 A 和 B分别引用了不同版本的 C 时， Enforce 检查失败。**下面这个实例，可以帮你理解这个规则的作用。![](Images/f9028a8fb0eb5b58363336c11cee9a5a.png){savepage-src="https://static001.geekbang.org/resource/image/ef/d0/ef9194165537330d5d8e0bbc6ce1ded0.png"}org.slf4j:slf4j-jdk14:1.6.1 依赖了 org.slf4j:slf4j-api:1.6.1， 而org.slf4j:slf4j-nop:1.6.0 依赖了org.slf4j:slf4j-api:1.6.0，当我们在构建项目时， 便会有如下错误：![](Images/2fdd36adb905431f67013bceb4ba3156.png){savepage-src="https://static001.geekbang.org/resource/image/e5/8d/e551db93e22b7e1b077025136d9b8f8d.png"}这时就需要开发人员介入了，使用 dependecy 的 exclusions元素排除掉一个不合适的版本。 虽然这会给编程带来一些麻烦，但是非常必要。因为，我始终认为你应该清楚地知道系统依赖了哪些组件，尤其是在某些组价发生冲突时，这就更加重要了。**第三，banDuplicateClasses 规则****该规则是 Extra Enforcer Rules 提供的，主要目的是检查多个 jar包中是否存在同样命名的 class，如果存在编译便会报错。** 同名 class若内容不一致，可能会导致java.lang.NoSuchFieldError，java.lang.NoSuchMethodException等异常，而且排查起来非常困难，因为人的直觉思维很难定位到重复类这个非显性错误上，例如下面这种情况：org.jboss.netty 包与 io.netty 包中都包含一个名为 NettyBundleActivator的类，另外还有 2 个重复类：spring/NettyLoggerConfigurator 和microcontainer/NettyLoggerConfigurator。![](Images/7db8eeb4fe69c431be4cfaba471edc38.png){savepage-src="https://static001.geekbang.org/resource/image/f2/55/f2a50ca7bc448a6673fb6bef5a925055.png"}当激活了 banDuplicateClasses 规则之后，Enforcer 检查，便会有如下的报错：![](Images/39a65b6b0ac415a775fbb401eceab4df.png){savepage-src="https://static001.geekbang.org/resource/image/41/90/417ae44052d9cdf0a1e083910cab1990.png"}通常情况下，用户需要排除一个多余的 jar包来解决这个问题，但有些情况下两个 jar包都不能被排除，如果只是个别类名冲突了，那么可以通过 ignoreClasses去忽略冲突的类，类名可以使用通配符（\*），如:org.jboss.netty.container.\*。但是，用户不能随意更改这个配置，因为它必须得到一定的授权，否则随意忽略会产生其他不确定的问题。因此我们将这个插件做了一些改动，通过API 来获取 ignoreClasses 的内容。当用户有类似的需求时，可以提交ignoreClasses ，但必须申请，经过 Java 专家审批之后才可忽略掉。