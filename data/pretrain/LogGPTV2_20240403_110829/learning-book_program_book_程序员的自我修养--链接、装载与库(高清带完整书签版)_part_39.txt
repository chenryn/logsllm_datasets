个计算过程我们可以从图7-6中看到。
text
fe-1
inte
data
jenytA esooold
图7-6模块内部数据访问示意
程序员的自我修养—链接、装载与库
---
## Page 217
194
第7章动态链接
类型三模块间数据访问
模块间的数据访问比模块内部稍微麻烦一点，因为模块间的数据访问目标地址要等到装
载时才决定，比如上面例子中的变量b，它被定义在其他模块中，并且该地址在装载时才能
确定。我们前面提到要使得代码地址无关，基本的思想就是把跟地址相关的部分放到数据段
里面，很明显，这些其他模块的全局变量的地址是跟模块装载地址有关的。ELF的做法是在
数据段里面建立一个指向这些变量的指针数组，也被称为全局偏移表（GlobalOfsetTable，
GOT），当代码需要引用该全局变量时，可以通过GOT中相对应的项间接引用，它的基本
机制如图7-7所示。
.data
Qa20002300
.text
0x20002000
.data
text
Ox10000000
Process Virtual
Space
图7-7模块间数据访问
当指令中需要访问变量b时，程序会先找到GOT，然后根据GOT中变量所对应的项找
到变量的目标地址。每个变量都对应一个4个字节的地址，链接器在装载模块的时候会查找
每个变量所在的地址，然后填充GOT中的各个项，以确保每个指针所指向的地址正确。由
于GOT本身是放在数据段的，所以它可以在模块装载时被修改，并且每个进程都可以有独
立的副本，相互不受影响，
我们来看看GOT如何做到指令的地址无关性。从第二中类型的数据访问我们了解到，
模块在编译时可以确定模块内部变量相对与当前指令的偏移，那么我们也可以在编译时确定
程序员的自我修养一链接、装载与库
---
## Page 218
7.3地址无关代码
195
GOT相对于当前指令的偏移。确定GOT的位置跟上面的访问变量a的方法基本一样，通过
得到PC值然后加上一个偏移量，就可以得到GOT的位置。然后我们根据变量地址在GOT
中的偏移就可以得到变量的地址，当然GOT中每个地址对应于哪个变量是由编译器决定的，
比如第一个地址对应变量b，第二个对应变量c等。
让我们再回顾刚才函数bar（）的反汇编代码。为访问变量b，我们的程序首先计算出变量
b 的地址在 GOT 中的位置，即 0x10000000+0x454 + 0x118c+(-8) = 0x100015d8（0xfff8
为-8的补码表示），然后使用寄存器间接寻址方式给变量b赋值2。
我们也可以使用objdump来查看GOT的位置：
$ objdump -h pic.80
17 -got
00000010000015d0000015d0000005d02**2
CONTENTS, ALLOC, LOAD, DATA
可以看到GOT在文件中的偏移是0x15d0，我们再来看看pic.so的需要在动态链接时重
定位项：
$ objdump -R pic.80
DYNAMIC RELOCATION RECORDS
OPFSET
34A
VALUE
000015d8 R_386_GL0B_DAT  b
可以看到变量b的地址需要重定位，它位于0x15d8，也就是GOT中偏移8，相当于是
GOT中的第三项（每四个字节一项）。从上面重定位项中看到，变量b的地址的偏移为0x15d8，
正好对应了我们前面通过指令计算出米的偏移值，即0x100015d8-0x10000000=0x15d8。
类型四模块间调用、跳转
对于模块间调用和跳转，我们也可以来用上面类型四的方法来辨决。与上面的类型有所
不同的是，GOT中相应的项保存的是目标函数的地址，当模块需要调用目标函数时，可以
通过GOT中的项进行间接跳转，基本的原理如图7-8所示。
调用extO函数的方法与上面访问变量b的方法基本类似，先得到当前指令地址PC，然
后加上一个偏移得到函数地址在GOT中的偏移，然后一个间接调用：
ca11
494 
mov 0xEEEffffc($ecx), eax
add
$0x118c, $ecx
cal1
*(%eax)
程序员的自我修养一链接、装载与库
---
## Page 219
196
第7章动态链接
000200020
int b #
.data
.text
Pa20091930
sat( :
0x20002000
0x20001000
e8t(I
.data
GOT
.text
Process Virtual
图7-8模块间调用、跳转
这种方法很简单，但是存在一些性能问题，实际上ELF采用了一种更加复杂和精巧的
方法，我们将在后面关于动态链接优化的章节中进行更为具体的介绍。
地址无关代码小结
历经磨难，终于功德圆满。4种地址引用方式在理论上都实现了地址无关性，我们将它
们总结一下，如表7-1所示。
表7-1
各种地址引用方式
指今跳转、调用
数据访问
模块内部
（1）相对跳转和调用
（2）相对地址访问
模块外部
（3）间接现转和调用（GOT)
（4）间接访问（GOT)
-fpic 和-fPIC
使用GCC产生地址无关代码很简单，我们只需要使用“-IPIC”参数即可。实际上GCC
来讲完全一样，都是指示GCC产生地址无关代码。唯一的区别是，“-PIC"产生的代码要
程序员的自我修养一链接、装载与库
---
## Page 220
7.3地址无关代码
大，而“-fpic”产生的代码相对较小，面且较快。那么我们为什么不使用“-fpic”而要使用
“-PIC”呢？原因是，由于地址无关代码都是跟硬件平台相关的，不同的平台有着不同的
实现，“-fpic”在某些平台上会有一些限制，比如全局符号的数量或者代码的长度等，而
“-IPIC”则没有这样的限制。所以为了方便起见，绝大部分情况下我们都使用“-PIC”参
数来产生地址无关代码。
如何区分一个DSO是否为PIC
readelf -d foo.so 1 grep TEXTREL
如果上面的命令有任何输出，那么foo.so就不是PIC的，否则就是PIC的。PIC的DSO
是不会包含任何代码段重定位表的，TEXTREL表示代码段重定位表地址。
PIC 与 PIE
地址无关代码技术除了可以用在共享对象上面，它也可以用于可执行文件，一个以地址
无关方式编译的可执行文件被称作地址无关可执行文件（PlE，Posion-lndependent
7.3.4共享模块的全局变量问题
地址无关性问题就这么解决了吗？看起来好像是的。如果你还没看出来一个小问题的
话，最好回头再仔细看看前面的4种地址引用方式的分类。发现了吗？我们上面的情况中没
有包含定义在模块内部的全局变量的情况。可能你的第一反应就是，这不是很简单吗？跟模
块内部的静态变量一样处理不就可以了吗？的确，粗略一看模块内部的全局变量和静态变量
的地址都可以通过上面所列出的类型两种方法米解决。但是有一种情况很特殊，我们来看看
会产生什么同题。
有一种很特殊的情况是，当一个模块引用了一个定义在共享对象的全局变量的时候，比
如一个共享对象定义了一个全局变量global，面模块module.c中是这么引用的：
extern int globa1;
int foo()
g1oba1 = 1;
当编译器编译module.c时，它无法根据这个上下文判断global是定义在同-个模块的
的其他目标文件还是定义在另外一个共享对象之中，即无法判断是否为跨模块间的调用。
假设module.c是程序可执行文件的一部分，那么在这种情况下，由于程序主模块的代
码并不是地址无关代码，也就是说代码不会使用这种类似于PIC的机制，它引用这个全局变
程序员的自我修养一—链接、装载与库
---
## Page 221
198
第7章动态链蜜
量的方式跟普通数据访问方式一样，编译器会产生这样的代码：
mov1$0x1, xxxxxXXX
XXXXXXXX就是global的地址。由于可执行文件在运行时并不进行代码重定位，所以
变量的地址必须在链接过程中确定下来。为了能够使得链接过程正常进行，链接器会在创建
可执行文件时，在它的“.bss”段创建一个global变量的副本。那么问题就很明显了，现在
global变量定义在原先的共享对象中，而在可执行文件的“.bss”段还有一个副本。如果同
一个变量同时存在于多个位置中，这在程序实际运行过程中肯定是不可行的。
于是解决的办法只有一个，那就是所有的使用这个变量的指令都指向位于可执行文件中
的那个副本。ELF共享库在编译时，默认都把定义在模块内部的全局变量当作定义在其他模
块的全局变量，也就是说当作前面的类型四，通过GOT来实现变量的访问。当共享模块被
装载时，如果某个全局变量在可执行文件中拥有副本，那么动态链接器就会把GOT中的相
应地址指向该副本，这样该变量在运行时实际上最终就只有一个实例。如果变量在共享模块
中被初始化，那么动态链接器还需要将该初始化值复制到程序主模块中的变量副本：如果该
全局变量在程序主模块中没有副本，那么GOT中的相应地址就指向模块内部的该变量副本。
假设module.c是一个共享对象的一部分，那么GCC编译器在-fPIC的情况下，就会把
对global 的调用按照跨模块模式产生代码。原因也很简单：编译器无法确定对global的引用
是跨模块的还是模块内部的。即使是模块内部的，即模块内部的全局变量的引用，按照上面
的结论，还是会产生跨模块代码，因为globul可能被可执行文件引用，从面使得共享模块中
对global的引用要执行可执行文件中的global 副本。
Q&A
Q:如果一个共享对象lib.so中定义了一个全局变量G，而进程A和进程B都使用了lib.so，
都么当进程A改变这个全局变量G的值时，进程B中的G会受到彩响吗？
A:不会。因为当lib.so被两个进程加载时，它的数据段部分在每个进程中都有独立的副本，
从这个角度看，共享对象中的全局变量实际上和定义在程序内部的全局变量没什么区
到。任何一个进程访问的只是自己的那个副本，而不会影响其他进程。那么，如果我
们把这个问题的条件改成同一个进程申的线程A和线程B，它们是否看得到对方对
lib.so中的全局变量G的修改呢？对于同一个进程的两个线程来说，它们访问的是同一
个进程地址空间，也就是同一个ib.so的副本，所以它们对G的修改，对方都是考得
到的。
那么我们可不可以做到跟前面答案相反的情况呢？比如要求两个进程共享一个共享对
象的副本或要求两个线程访问全局变量的不同副本，这两种需求都是存在的，比如多
个进程可以其享同一个全局变量就可以用来实现进程间通信：而多个线程访问全局变
程序员的自我修养一键接、装载与库
---
## Page 222
7.3地址无关代码
199
量的不同别本可以防止不同线程之间对全局交量的干抚，比如C语言选行库的erTon
全局变量。实际上这两种需求都是有相应的解决方法的，多进程共享全局变量又被叫
做“共享数据投”，在介绍WindowsDLL的时候会碰到它、而多个线程访问不网的全
局变量副本又被叫做“线程私有存储”（Thread Local Storage），我们在后面还会详细介
络。
7.3.5数据段地址无关性
通过上面的方法，我们能够保证共享对象中的代码部分地址无关，但是数据部分是不是
也有绝对地址引用的间题呢？让我们来看看这样一段代码：
static int a:
static int* p = &a;
如果某个共享对象里面有这样一段代码的话，那么指针p的地址就是一个绝对地址，它
指向变量a，面变量a的地址会随着共享对象的装载地址改变面改变。那么有什么办法解决
这个问题呢？
对于数据段来说，它在每个进程都有一份独立的副本，所以并不担心被进程改变。从这
点来看，我们可以选择装载时重定位的方法来解决数据段中绝对地址引用问题，对于共享对
象来说，如果数据段中有绝对地址引用，那么编译器和链接器就会产生一个重定位表，这个
重定位表里面包含了“R_386_RELATIVE”类型的重定位入口，用于解决上述问题，当动态
链接器装载共享对象时，如果发现该共享对象有这样的重定位入口，那么动态链接器就会对
该共享对象进行重定位。
实际上，我们甚至可以让代码段也使用这种装载时重定位的方法，面不使用地址无关代
码。从前面的例子中我们看到，我们在编泽共享对象时使用了“-PIC”参数，这个参数表
示产生地址无关的代码段。如果我们不使用这个参数来产生共享对象又会怎么样呢？
Sgcc -shared pic.c -o pic.80
上面这个命令就会产生一个不使用地址无关代码面使用装载时重定位的共享对象，但正
如我们前面分析过的一样，如果代码不是地址无关的，它就不能被多个进程之间共享，于是
也就失去了节省内存的优点。但是装裁时重定位的共享对象的运行速度要比使用地址无关代
码的共享对象快，因为它省去了地址无关代码中每次访间全局数据和函数时需要做一次计算
当前地址以及间接地址寻址的过程。
对于可执行文件来说，默认情况下，如果可执行文件是动态链接的，那么GCC会使用
PIC的方法来产生可执行文件的代码段部分，以便于不间的进程能够共享代码段，节省内存。
程序员的自我修养一—链接、装载与库
---
## Page 223
200
第7章动态链接
7.4延迟绑定（PLT）
动态链接的确有很多优势，比静态链接要灵活得多，但它是以牺牲一部分性能为代价的。
据统计ELF程序在静态链接下要比动态库稍微快点，大约为1%~5%，当然这取决于程序
本身的特性及运行环境等。我们知道动态链接比静态链接慢的主要原因是动态链接下对于全
局和静态的数据访问都要进行复杂的GOT定位，然后间接寻址：对于模块间的调用也要先
定位GOT，然后再进行间接跳转，如此一来，程序的运行速度必定会减慢。另外一个减慢
运行速度的原因是动态链接的链接工作在运行时完成，即程序开始执行时，动态链接器都要
进行一次链接工作，正如我们上面提到的，动态链接器会寻找并装载所需要的共享对象，然
后进行符号查找地址重定位等工作，这些工作势必减慢程序的启动速度。这是影响动态链接
性能的两个主要问题，我们将在这一节介绍优化动态链接性能的一些方法。
延迟绑定实现
在动态链接下，程序模块之间包含了大量的函数引用（全局变量往往比较少，因为大量
的全局变量会导致模块之间耦合度变大），所以在程序开始执行前，动态链接会耗费不少时