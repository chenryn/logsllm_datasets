# **一、幽灵（Spectre）漏洞介绍**
幽灵是一个存在于分支预测（Branch Prediction）实现中的硬件缺陷及安全漏洞，含有预测执行（Speculative
Execution）功能的现代微处理器均受其影响，该漏洞使得攻击者可以在用户态突破CPU的进程隔离，导致跨进程敏感信息泄露。截至2018年，几乎所有的计算机系统都受到Spectre的影响，包括台式机、笔记本电脑和移动设备。  
幽灵是一类潜在漏洞的总和，Spectre Variant 2漏洞编号CVE-2017-5715（Branch Target
Injection分支目标注入），它可以让攻击者训练受害者（victim）进程所在的CPU的分支目标预测器（Branch Target
Predictor）指向特定的代码片段（gadget），使得受害者进程在特定间接跳转处预测失误（mispridict）进入到gadget，在随后的处理器推测执行中执行gadget并将需要探测的信息映射到CPU的某一片缓存区域，最后攻击者通过逐一测量缓存区域内缓存块（Cache
Line）命中时间得到命中位置，进而还原出所探测的信息。  
简而言之这个漏洞的问题在于CPU被攻击者误导转不过弯导致正常运行的进程内部的信息暴露给了攻击者。
[视频：利用spectre
v2跨进程泄露敏感信息](https://m.youku.com/video/id_XNDMzNzYyOTM1Mg==.html?x=&sharefrom=android&sharekey=f32ecc8b57aea320b529bfb236b66d034&from=message
"视频：利用spectre v2跨进程泄露敏感信息")  
[源代码下载](https://github.com/qiutianshu/spectre.git "源代码下载")
# **二、目标**
  * 在受害者进程中找到可以在攻击者和受害者之间建立信息传递的隐蔽通道[3][p9]；
  * 在受害者进程中找到可以将敏感信息传递到隐蔽通道的指令片段；
  * 攻击者进程训练分支目标预测器，使受害者进程在特定位置的预测执行中执行我们选定的指令片段；
  * 攻击者进程不断刷新CPU特定位置的L1、L2、L3 Cache，触发受害者进程在特定位置的预测执行；
  * 击者进程利用缓存侧信道攻击手段将隐蔽通道内的状态信息转化为ASCII字节。
# **三、现代CPU提速增效之技术**
为了提高性能，现代处理器使用了一些优化机制提高了指令处理的并发度 ，进而宏观上提升了运行速度。下面简要提一下这些机制有助于理解本文：
## **3.1 乱序执行（Out-of-order Execution）**
为了提高CPU指令执行的并发度，人们发明了多级流水线。但是如果前后两条指令存在依赖，比如数据依赖、控制依赖，那么流水线中的后一条指令就必须等待前一条指令执行完才能执行。为了提升流水线的效率，CPU对不存在依赖的指令进行乱序和调度，减少流水线的停留，提高指令运行的吞吐率。虽然CPU内部是在乱序执行指令，但是对外则是根据指令原来的顺序提交乱序执行结果，所以我们从外部看到的是顺序执行的结果。
## **3.2 预测执行（Speculative Execution）**
处理器在乱序执行的过程中如果遇到条件分支
    条件分支：
    if(condition){
        ......
    }
或者间接跳转
    间接跳转：
    call rax、jmp [rax]、ret
下一条执行指令的位置取决于condition的计算结果或者内存访问结果，而由于某些原因例如缓存刷新导致计算延迟或者访存延迟，为了使乱序执行不至于在此处卡住，CPU会根据先前的执行情况做出路径预测并按照预测的路径继续执行下去。当condition被计算出来或者访存结果到达，如果预测执行的路径正确，则结果被提交，如果预测失败（mispridict）则执行回滚，重新按照正确的路径执行。  
现代CPU的Speculative Execution可以提前执行数百条指令，这取决于CPU指令缓存的大小。
## **3.3 分支预测（Branch Prediction）**
Speculative
Execution依赖于CPU的分支预测机制，CPU内部会有专门的缓存来记录先前的分支执行情况并为分支预测提供依据。CPU内部会有多种预测器，在遇到分支指令时，每种预测器都会给出预测结果，所有预测结果都会被汇总到一个选择器最终选择出最有可能的路径。换句话说在某个分支处的预测结果是受到该分支以及其他临近分支的历史情况影响的，所以我们后面可以通过训练分支预测器使之预测执行到我们想要的任何代码片段。
## **3.4 计算机存储结构**
CPU访问内存的时间大约为200~300个时钟周期，这种延迟相对于每条指令执行时只需耗费数个时钟周期而言是巨大的。为了加速访存引入了多级缓存技术，在intel处理器里面就是L1
Cache、L2 Cache、L3
Cache。假设CPU首次访问某个数据，那么他会首先花费200多个时钟周期从内存里面取得该数据并将数据依次填满L1、L2、L3，而后再把数据取出来计算；如果CPU第二次访问该数据，那么就只需要花费十几个时钟周期从片上缓存中取得。访问数据时间上的差异就是后面我们缓存侧信道攻击的依据。需要注意的是，预测执行会影响缓存的状态，即使由于预测失败而导致结果回滚，缓存的状态并不会随之回滚而是会保留。  
# **四、CPU分支预测器**
## **4.1 分支预测器的两大类**
分支预测器是CPU内部的一个重要组件，它的作用是在指令周期的取指阶段（IF）预测出分支的走向，进而为预测执行提供依据。分支预测器根据作用的指令类型分为两大类：分支预测器（Branch
Predictor）和分支目标预测器（Branch Target
Predictor）。前者作用于条件分支例如if...else...，他的作用是判断是否需要进入到条件分支当中，所以他的输出也就是简单的“进入”（Taken）和“不进入”（Not
Taken）。  
分支目标预测器作用于间接跳转一类的指令例如 call rax、jmp [rax]，他的作用是预测出跳转的目标地址，所以他的输出就是虚拟地址。
## **4.2 作用的时机**
取指阶段遇到分支指令时，由于分支条件需要计算或者间接地址的内容不在缓存中（miscache）需要花费数百个时钟周期来计算分支条件或者从内存中取出间接地址的内容，这时CPU就会利用这个时间窗口来预测并执行，最后根据实际计算出的结果来决定到底是提交还是回滚预测执行的结果，并对分支预测器内部的一些参数进行调整。
## **4.3 工作流程**
这里我研究的是Haswell平台的分支目标预测器。Haswell提供了3种预测机制：
  * **通用分支预测器（Generic Branch Predictor）**  
它使用了分支目标缓存（Branch Target
Buffer）来建立分支指令地址和目标地址之间的映射关系。分支指令地址的低31位用来索引BTB中的项[1][p16]。  
以上可以看到，只使用地址的低31位会造成BTB条目的重叠，解决的办法是进行分组，分为N路组相联，这点类似于CPU缓存的组织方式，这里不深入细究。
  * **间接分支预测器（Indirect Branch Predictor）**  
间接分支预测器是一个两级分支预测器。第一级是一个分支历史缓存（Branch History
Buffer），它是一个58位的移位寄存器，他的作用是记录前29个分支的“源地址——目标地址”信息，这个相当于找到程序控制流的一种模式，按照这种模式可以做到精确匹配。  
它的第二级是间接分支目标缓存（Indirect Branch Target Buffer），它类似于前面介绍的BTB，里面是“标记——目标地址”之间的映射。  
他的预测过程是：BHB与PC的值做异或运算，而后进入到哈希函数计算出哈希值，根据哈希值进入到IBTB查找目标地址，并根据IBPB中得到的预测位来判断是否应该采取这个预测出来的结果。  
分支历史缓存BHB是在动态更新的，当执行一条间接分支指令，例如callq *0xb0(%r8)，它可以被看作：
    push rip
    jmp *0xb0(%r8)
**BHB的更新过程：**  
经过译码、执行，解析出目标地址Target，将BHB左移2位与PC的0~19位和Target的0~5位作“类XOR”运算，而后把运算结果重新填回BHB，这就完成了BHB的一次更新，call这条指令的分支记录也就被加入到了BHB中。  
“类XOR”运算说明此算法并不是严格的xor运算，国外通过逆向工程得到了BHB更新算法的代码：
    /* ‘bhb_state‘ points to the branch history
    * buffer to be updated
    * ‘src‘ is the virtual address of the last
    * byte of the source instruction
    * ‘dst‘ is the virtual destination address
    */
    void bhb_update(uint58_t *bhb_state, unsigned long src, unsigned long dst) {
            *bhb_state > 6;
            *bhb_state ˆ= (src & 0xc00) >> (10 - 2);
            *bhb_state ˆ= (src & 0xc000) >> (14 - 4);
            *bhb_state ˆ= (src & 0x30) > (12 - 10);
            *bhb_state ˆ= (src & 0x30000) >> (16 - 12);
            *bhb_state ˆ= (src & 0xc0000) >> (18 - 14);