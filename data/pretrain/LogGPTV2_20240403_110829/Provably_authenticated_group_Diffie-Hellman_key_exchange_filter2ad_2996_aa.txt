title:Provably authenticated group Diffie-Hellman key exchange
author:Emmanuel Bresson and
Olivier Chevassut and
David Pointcheval and
Jean-Jacques Quisquater
Provably Authenticated Group Diffie-Hellman Key
Exchange
Emmanuel Bresson
Olivier Chevassut∗
David Pointcheval
Jean-Jacques Quisquater
´Ecole Normale Sup´erieure
Laboratoire d’informatique
45 rue d’Ulm, 75230 Paris
Univ. Catholique de Louvain
Lawrence Berkeley National Lab
1 Cyclotron Rd, MS 50B-2239
´Ecole Normale Sup´erieure
Laboratoire d’informatique
45 rue d’Ulm, 75230 Paris
Univ. Catholique de Louvain
Microelectronic laboratory
1348 Louvain-la-Neuve
France
Berkeley, CA 94720, USA
France
Belgium
Emmanuel.Bresson@ens.f r
PI:EMAIL
David.P PI:EMAIL
PI:EMAIL
ABSTRACT
Group Diﬃe-Hellman protocols for Authenticated Key Ex-
change (AKE) are designed to provide a pool of players with
a shared secret key which may later be used, for example, to
achieve multicast message integrity. Over the years, several
schemes have been oﬀered. However, no formal treatment
for this cryptographic problem has ever been suggested. In
this paper, we present a security model for this problem and
use it to precisely deﬁne AKE (with “implicit” authentica-
tion) as the fundamental goal, and the entity-authentication
goal as well. We then deﬁne in this model the execution of
an authenticated group Diﬃe-Hellman scheme and prove its
security.
1.
INTRODUCTION
Group Diﬃe-Hellman schemes for Authenticated Key Ex-
change are designed to provide a pool of players communi-
cating over an open network with a shared secret key which
may later be used to achieve some cryptographic goals like
multicast message conﬁdentiality or multicast data integrity.
Secure virtual conferencing involving up to a hundred par-
ticipants is an example of such a multicast scenario [14]. In
this scenario the group membership is static and known in
advance: at startup the participants would like to engage in
a conversation at the end of which they have established a
session key. For this scenario group Diﬃe-Hellman schemes
are attractive alternatives to methods that establish a ses-
sion key between every pair of players in the multicast group
or rely on a centralized key distribution center.
∗
The second author was supported by the Director, Oﬃce
of Science, Oﬃce of Advanced Scientiﬁc Computing Re-
search, Mathematical Information and Computing Sciences
Division, of the U.S. Department of Energy under Contract
No. DE-AC03-76SF00098. This document is report LBNL-
47585.
Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for profit or commercial advantage and that copies
bear this notice and the full citation on the first page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior specific
permission and/or a fee.
CCS’01, November 5-8, 2001, Philadelphia, Pennsylvania, USA.
Copyright 2001 ACM 1-58113-385-5/01/0011 ...$5.00.
Over the years, several papers [2, 3, 13, 18, 20, 21, 27, 31,
32] have attempted to extend the well-known Diﬃe-Hellman
key exchange [17] to the multi-party setting. The protocols
meet a variety of performance attributes but only exhibit
an informal analysis showing that they achieve the desired
security goals. Some papers exhibit an ad-hoc analysis for
the security of their schemes and some of these schemes have
later been found to be ﬂawed [21, 26]. Other papers only
provide heuristic evidence of security without quantifying it.
The remaining schemes assume authenticated links and thus
do not consider the authentication as part of the protocol
design.
In the paradigm of provable security [19] one identiﬁes
a concrete cryptographic problem to solve (like the group
Diﬃe-Hellman key exchange) and deﬁnes a formal model
for this problem. The model captures the capabilities of the
adversary and the capabilities of the players. Within this
model one deﬁnes security goals to capture what it means
for a group Diﬃe-Hellman scheme to be secure. And, for a
particular scheme one exhibits a proof of its security. The se-
curity proof aims to show that the scheme actually achieves
the claimed security goals under computational security as-
sumptions.
The fundamental security goal for a group Diﬃe-Hellman
scheme to achieve is Authenticated Key Exchange (with
“implicit” authentication) identiﬁed as AKE. In AKE, each
player is assured that no other player aside from the arbi-
trary pool of players can learn any information about the ses-
sion key. Another stronger highly desirable goal for a group
Diﬃe-Hellman scheme to provide is Mutual Authentication
(MA). In MA, each player is assured that its partners (or
pool thereof) actually have possession of the distributed ses-
sion key. Pragmatically, MA takes more rounds; one round
of simultaneous broadcasts.
With these security goals in hand, one can analyze the
security of a particular group Diﬃe-Hellman scheme and see
how it meets the deﬁnitions. A security analysis (or proof
of security) for the scheme works via reduction from the
security of the scheme to the underlying “hard” problem. A
reduction is a successful algorithm for the “hard” problem
that uses an adversary of the scheme as a subroutine.
In this paper we assume honest players. Honest players do
not deviate from the protocol and their instances erase any
internal data when terminating. Existing two-party proto-
cols (e.g., SSL and IPsec) make this assumption. We see
the additional security goal of dealing with dishonest play-
255ers (like veriﬁable contributory [2]) as important in some
environments but less important in others [1].
This paper provides major contributions to the solution
of the group Diﬃe-Hellman key exchange problem. We ﬁrst
present a formal model to help manage the complexity of
deﬁnitions and proofs for the authenticated group Diﬃe-
Hellman key exchange. A model where a process controlled
by a player running on some machine is modeled as an in-
stance of the player, the various types of attacks are modeled
by queries to these instances and the security of the ses-
sion key is modeled through semantic security. Moreover, in
order to be correctly formalized, the intuition behind mu-
tual authentication requires cumbersome deﬁnitions of ses-
sion IDS and partner IDS which may be skipped at the ﬁrst
reading.
Second, we deﬁne in this model the execution of a modi-
ﬁed known protocol [31], we refer to it as AKE1, and show
that AKE1 can be proven secure under reasonable and well-
deﬁned intractability assumptions. Third, we present a generic
transformation for turning an AKE protocol into a protocol
that provides MA and justify its security under reasonable
and well-deﬁned intractability assumptions.
The remainder of this paper is organized as follows. The
paper starts with some related work in Section 2 and cryp-
tographic notions in Section 3. The paper continues with a
description of our model of a distributed environment in Sec-
tion 4 and gives the precise security deﬁnitions that should
be satisﬁed by a group Diﬃe-Hellman scheme in Section 5.
Section 6 presents the protocol AKE1 and justiﬁes its secu-
rity in the random oracle model. Section 7 turns AKE1 into
a protocol that provides MA and justiﬁes its security in the
random oracle model.
2. RELATED WORK
Two formal models for secure key exchange have received
the most consideration. The ﬁrst model initiated by Bellare
and Rogaway [6, 8] modeled the two-party and three-party
key distribution. This model was further extended by Blake-
Wilson et al. [10, 11] to model the authenticated Diﬃe-
Hellman key exchange. In this model, player instances are
modeled as oracles available to the adversary and attacks are
modeled by oracle queries. Recently, Bellare, Pointcheval
and Rogaway [5] reﬁned this model to use session IDs as
an approach to deﬁne the partnering. They also extended
the model to include forward-secrecy, allow password au-
thentication and deal with dictionary attacks. Our model is
derived from [5].
The second formal model is based on the multi-party sim-
ulatability technique and was initiated by Bellare, Canet-
ti and Krawczyk [4].
con-
sidered Diﬃe-Hellman and encryption-based key exchange.
Recently Shoup [30] reﬁned this model and showed that the
two models are equivalent for two parties under speciﬁc con-
ditions. However no such treatment has been provided for
the group setting yet.
In this model Bellare et al.
The work of Ateniese et al. [2] is of particular interest
since it identiﬁes the fundamental and additional desirable
security goals of authenticated group Diﬃe-Hellman key ex-
change. The authors oﬀer provably secure authenticated
protocols and sketch informal proofs that their protocols
achieve these goals. Unfortunately these protocols have later
been found to be ﬂawed [26].
Other related papers are [23, 24]. Although they do not
tackle the exact same problem and do not achieve the same
goal, they still seem relevant enough to mention.
3. BACKGROUND
We use the following cryptographic notions throughout
the paper.
3.1 Concrete Security
In this paper we develop proofs in the framework of con-
crete provable security. We provide an exact analysis of the
security of the schemes rather than asymptotic ones. That
is, we explicitly quantify the reduction from the security of a
scheme to the security of the underlying “hard” problem(s)
on which it is based. This allows us to know exactly how
much security is maintained by the reduction and thus to
determine the strength of the reduction.
In order to quantify the reductions, we deﬁne the advan-
tage Advake(A) that a computationally bounded adversary
A will defeat the AKE security goal of a protcol. The ad-
vantage is twice the probability that A will defeat the AKE
security goal of the protcol minus one1.
In order to quantify the reduction, we also consider the
probability Succma(A) that a computationally bounded ad-
versary A will defeat the MA security goal of a protocol2.
3.2 The Ideal Hash Model
In the ideal hash model, also called the “random oracle
model” [7], the cryptographic hash functions (like SHA or
MD5) are viewed as random functions with the appropri-
ate range. Security proofs in this model identify the hash
functions as oracles which produce a truly random value for
each new query and identical answers if the same query is
asked twice. Later, in practice, the random functions are
instantiated using speciﬁc functions derived from standard
cryptographic hash functions like SHA or MD5.
Analysis in this idealized model has been quite successful
in ensuring security guarantees of numerous cryptographic
schemes provided that the hash function has no weakness.
Security proofs in this model are superior to those provided
by ad hoc protocol designs although they do not, of course,
provide the same security guarantees as those in the stan-
dard model.
3.3  The Group Diffie-Hellman Problems
The Group Diﬃe-Hellman schemes have traditionally been
designed based on diﬀerent intractability assumptions. The
schemes of [13, 18] are based on heuristic assumptions that
are not known to be reducible to a well-known “hard” prob-
lem. The schemes of [20, 22, 27] are based on assumptions
that are reducible to a well-known “hard” problem.
In a cyclic prime-order group (cid:2)g(cid:3), the “standard” assump-
tions that have been used so far are:
1. The Decisional Diﬃe-Hellman(DDH) assumption. Un-
der this assumption, distinguishing gab from a random
value when given ga and gb is computationally hard.
1To defeat AKE security means for A distinguishing the
session key from a random value. Hence, A can trivially
defeat AKE with probability 1/2, multiplying by two and
substracting one rescales the probability.
2To defeat the MA security for A means impersonating a
player.
2562. The Group Decisional Diﬃe-Hellman (G-DDH) assum-
xi for some sub-
ption. One considers the elements g
sets of indices i (either all these subsets, except {1, . . . ,
n}, or only a part of them) and tries to distinguish
gx1...xn from a random value.
(cid:1)
In the ideal hash function model, one usually uses the CDH
and G-CDH assumptions:
1. The Computational Diﬃe-Hellman(CDH) assumption.
This assumption claims that given two elements ga, gb
, it is computationally hard to compute gab.
(cid:1)
2. The Group Computational Diﬃe-Hellman (G-CDH)
assumption. In the G-CDH problem, one considers the
xi for some subsets of indices i (either all
elements g
these subsets, except {1, .., n}, or only a part of them)
and tries to compute gx1...xn . G-CDH is believed to
be a “hard” problem.
The G-DDH problem appears to have ﬁrst surfaced in the
cryptographic literature in the paper of Steiner et al. [31]
which also proves that the DDH assumption implies the G-
DDH assumption. Since then, the G-DDH has been used in
several other cryptographic settings [12, 25].
The G-CDH assumption is a potentially weaker intractabi-
lity assumption than G-DDH. It is also believed that the
CDH assumption implies the G-CDH assumption but it has
not yet been proved. The G-CDH has however, when con-
sidered modulo a composite number, been related to factor-
ing [9].
4. MODEL
In our model, the adversary A, which is not a player in
our formalization, is given enormous capabilities. It controls
all communications between player instances and can at any
time ask an instance to release a session key or a long-lived
key. In the rest of this section we formalize the protocol and
the adversary’s capabilities.
4.1 Protocol Participants
We ﬁx a nonempty set ID of n players that want (and are
supposed) to participate in a group Diﬃe-Hellman protocol
P . The number n of players is polynomial in the security
parameter k.
A player Ui ∈ ID can have many instances called oracles,
involved in distinct concurrent executions of P . We denote
i with s ∈ N. Also, when we
instance s of player Ui as Πs
mean a not ﬁxed member of ID we use U without any index
and so denote an instance of U as Πs
4.2 Long-Lived Keys
Each player U ∈ ID holds a long-lived key LLU which is
either a pair of matching public/private keys or a symmetric
key. LLU is speciﬁc to U not to one of its instances. As-
sociated to protocol P is a LL-key generator GLL which at
initialization generates LLU and assigns it to U .
4.3 Session IDS
U with s ∈ N.
We deﬁne the session IDS (SIDS) for oracle Πs
cution of protocol P as SIDS(Πs
SIDij is the concatenation of all ﬂows that oracle P is
changes with oracle Πt
in an execution of P . We emphasize that SIDS is public –
i in an exe-
i ) = {SIDij : j ∈ ID} where
i ex-
j (possibly by the intermediate of A)
it does not depend on the session key – and, thus, is avail-
able to the adversary A; A can just listen on the wire and
construct it. We will use SIDs to properly deﬁne partnering
through the notion of partners IDs (PIDs).
4.4 Accepting and Terminating
An oracle Πs
U has not yet terminated. Πs
U accepts when it has enough information to
compute a session key SK. At any time an oracle Πs
U can
accept and it accepts at most once. As soon as oracle Πs
U ac-
cepts, SK and SIDS are deﬁned. Now once having accepted
Πs
U may want to get conﬁrma-
tion that its partners have actually computed SK or that
its partners are really the ones it wants to share a session
key with. As soon as Πs
U gets this conﬁrmation message, it
terminates – it will not send out any more messages.
4.5 Oracle Queries
The adversary A has an endless supply of oracles Πs
U and
makes various queries to them. Each query models a capa-
bility of the adversary. The four queries and their responses
are listed below:
• Send(Πs
U , m): This query models adversary A send-
ing messages to instances of players. The adversary
A gets back from his query the response which oracle
Πs
U would have generated in processing message m. If
oracle Πs
U has not yet terminated and the execution
of protocol P leads to accepting, variables SIDS are
updated. A query of the form Send(Πs
U , “start”) ini-
tiates an execution of P .
• Reveal(Πs
U ): This query models the attacks resulting
in the session key being revealed. The Reveal query
is only available to adversary A if oracle Πs
U has ac-
cepted. The Reveal-query unconditionally forces Πs
U to
release SK which otherwise is hidden to the adversary.
• Corrupt(U ): This query models the attacks resulting
in the player U ’s LL-key been revealed. Adversary A
gets back LLU but does not get the internal data of
any instances of U executing P .
• Test(Πs
U ): This query models the semantic security of
the session key SK, namely the following game, de-
noted by Gameake(A, P ), between adversary A and