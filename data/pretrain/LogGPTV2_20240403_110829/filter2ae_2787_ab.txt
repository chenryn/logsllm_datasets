    Paged pools （bit 0 set）
    PagedSession pool （bit 5 and 1 set）
第五个段堆也被分配，但是作者没有找到它的用途。前三个与NonPaged、NonPagedNx、Paged相关的段堆被存储在HEAP_POOL_NODES中。与PagedPoolSession相关联的段堆被存储在当前线程中。图3总结了5个段堆
图3. 段后端内部结构
尽管用户层段堆仅使用一个段分配器上下文进行128KB到508KB之间的分配，但在内核层段堆使用两个段分配器上下文，第二个用于508KB到7GB之间的分配。
#### 段后端（Segment Backend）
段后端被用于分配大小在128KB到7GB之间的内存块。它也在后台使用，为VS和LFH后端分配内存。
段后端上下文存储在称作_HEAP_SEG_CONTEXT的结构体中。
    1: kd > dt nt! _HEAP_SEG_CONTEXT
    +0 x000 SegmentMask : Uint8B
    +0 x008 UnitShift : UChar
    +0 x009 PagesPerUnitShift : UChar
    +0 x00a FirstDescriptorIndex : UChar
    +0 x00b CachedCommitSoftShift : UChar
    +0 x00c CachedCommitHighShift : UChar
    +0 x00d Flags : 
    +0 x010 MaxAllocationSize : Uint4B
    +0 x014 OlpStatsOffset : Int2B
    +0 x016 MemStatsOffset : Int2B
    +0 x018 LfhContext : Ptr64 Void
    +0 x020 VsContext : Ptr64 Void
    +0 x028 EnvHandle : RTL_HP_ENV_HANDLE
    +0 x038 Heap : Ptr64 Void
    +0 x040 SegmentLock : Uint8B
    +0 x048 SegmentListHead : _LIST_ENTRY
    +0 x058 SegmentCount : Uint8B
    +0 x060 FreePageRanges : _RTL_RB_TREE
    +0 x070 FreeSegmentListLock : Uint8B
    +0 x078 FreeSegmentList : [2] _SINGLE_LIST_ENTRY
图4. 段后端内部结构图
段后端通过称为段的可变大小块分配内存。每个段由多个可分配的页组成。
段存储在SegmentListHead的链表中。段以一个_HEAP_PAGE_SEGMENT开头，后面跟着256个_HEAP_PAGE_RANGE_DESCRIPTOR结构。
    1: kd > dt nt! _HEAP_PAGE_SEGMENT
    +0 x000 ListEntry : _LIST_ENTRY
    +0 x010 Signature : Uint8B
    +0 x018 SegmentCommitState : Ptr64 _HEAP_SEGMENT_MGR_COMMIT_STATE
    +0 x020 UnusedWatermark : UChar
    +0 x000 DescArray : [256] _HEAP_PAGE_RANGE_DESCRIPTOR
    1: kd > dt nt! _HEAP_PAGE_RANGE_DESCRIPTOR
    +0 x000 TreeNode : _RTL_BALANCED_NODE
    +0 x000 TreeSignature : Uint4B
    +0 x004 UnusedBytes : Uint4B
    +0 x008 ExtraPresent : Pos 0, 1 Bit
    +0 x008 Spare0 : Pos 1, 15 Bits
    +0 x018 RangeFlags : UChar
    +0 x019 CommittedPageCount : UChar
    +0 x01a Spare : Uint2B
    +0 x01c Key : _HEAP_DESCRIPTOR_KEY
    +0 x01c Align : [3] UChar
    +0 x01f UnitOffset : UChar
    +0 x01f UnitSize : UChar
为了提供对空闲页面范围的快速查找，还在_HEAP_SEG_CONTEXT中维护了一个红黑树。
每个_HEAP_PAGE_SEGMENT 都有一个签名，计算方法如下
    Signature = Segment ^ SegContext ^ RtlpHpHeapGlobals ^ 0xA2E64EADA2E64EAD ;
此签名用于从任何已分配的内存块中检索拥有的_HEAP_SEG_CONTEXT和相应的_SEGMENT_HEAP。
图4总结了段后端中使用的内部结构。
通过使用存储在_HEAP_SEG_CONTEXT中的SegmentMask掩码，可以快速从任意地址计算出原始段。SegmentMask的值为0xfffffffffff00000。
    Segment = Addr & SegContext ->SegmentMask;
通过使用_HEAP_SEG_CONTEXT中的UnitShift，可以轻松从任意地址计算出相应的PageRange。UnitShift设置为12。
    PageRange = Segment + sizeof( _HEAP_PAGE_RANGE_DESCRIPTOR ) * (Addr- Segment) >> SegContext ->UnitShift;
当Segment
Backend被另一个后端使用时，_HEAP_PAGE_RANGE_DESCRIPTOR的RangeFlags字段被用于存储请求分配的后端。
#### 可变大小后端（Variable Size Backend）
可变大小后端分配512B到128KB大小的块。它旨在提供对空闲块的轻松重用。
可变大小后端上下文存储在被称为_HEAP_VS_CONTEXT的结构体中。
    0: kd > dt nt! _HEAP_VS_CONTEXT
    +0 x000 Lock : Uint8B
    +0 x008 LockType : _RTLP_HP_LOCK_TYPE
    +0 x010 FreeChunkTree : _RTL_RB_TREE
    +0 x020 SubsegmentList : _LIST_ENTRY
    +0 x030 TotalCommittedUnits : Uint8B
    +0 x038 FreeCommittedUnits : Uint8B
    +0 x040 DelayFreeContext : _HEAP_VS_DELAY_FREE_CONTEXT
    +0 x080 BackendCtx : Ptr64 Void
    +0 x088 Callbacks : _HEAP_SUBALLOCATOR_CALLBACKS
    +0 x0b0 Config : _RTL_HP_VS_CONFIG
    +0 x0b4 Flags : Uint4B
可变大小后端的内部结构
图5. 可变大小后端内部结构
空闲块存储在称为FreeChunkTree的红黑树中。当请求分配时，红黑树用于查找任何大小相同的空闲块或大于请求大小的第一个空闲块。
空闲块以一个称作_HEAP_VS_CHUNK_FREE_HEADER的专用结构体为头部。
    0: kd > dt nt! _HEAP_VS_CHUNK_FREE_HEADER
    +0 x000 Header : _HEAP_VS_CHUNK_HEADER
    +0 x000 OverlapsHeader : Uint8B
    +0 x008 Node : _RTL_BALANCED_NODE
一旦找到一个空闲块，就会调用RtlpHpVsChunkSplit将其分割为大小合适的块。
已经被分配的块都会以一个名为_HEAP_VS_CHUNK_HEADER的结构体开头。
    0: kd > dt nt! _HEAP_VS_CHUNK_HEADER
    +0 x000 Sizes : _HEAP_VS_CHUNK_HEADER_SIZE
    +0 x008 EncodedSegmentPageOffset : Pos 0, 8 Bits
    +0 x008 UnusedBytes : Pos 8, 1 Bit
    +0 x008 SkipDuringWalk : Pos 9, 1 Bit
    +0 x008 Spare : Pos 10, 22 Bits
    +0 x008 AllocatedChunkBits : Uint4B
    0: kd > dt nt! _HEAP_VS_CHUNK_HEADER_SIZE
    +0 x000 MemoryCost : Pos 0, 16 Bits
    +0 x000 UnsafeSize : Pos 16, 16 Bits
    +0 x004 UnsafePrevSize : Pos 0, 16 Bits
    +0 x004 Allocated : Pos 16, 8 Bits
    +0 x000 KeyUShort : Uint2B
    +0 x000 KeyULong : Uint4B
    +0 x000 HeaderBits : Uint8B
header结构体中的所有字段都与RtlHpHeapGlobals和块的地址进行异或。
    Chunk ->Sizes = Chunk ->Sizes ^ Chunk ^ RtlpHpHeapGlobals ;
在内部，VS分配器使用段分配器。它通过_HEAP_VS_CONTXT中的_HEAP_SUBALLOCATOR_CALLBACKS字段在RtlpHpVsSubsegmentCreate中使用。子分配器回调函数都与VS上下文和RtlpHpHeapGlobals地址进行异或。
    callbacks.Allocate = RtlpHpSegVsAllocate ;
    callbacks.Free = RtlpHpSegLfhVsFree ;
    callbacks.Commit = RtlpHpSegLfhVsCommit ;
    callbacks.Decommit = RtlpHpSegLfhVsDecommit ;
    callbacks.ExtendContext = NULL;
如果FreeChunkTree中没有足够大的块，则会在子段列表中分配并插入一个新的子段，其大小范围为64KiB到256KiB。它以_HEAP_VS_SUBSEGMENT结构体为首。所有剩余的块都用作空闲块被插入到FreeChunkTree中。
    0: kd > dt nt! _HEAP_VS_SUBSEGMENT
    +0 x000 ListEntry : _LIST_ENTRY
    +0 x010 CommitBitmap : Uint8B
    +0 x018 CommitLock : Uint8B
    +0 x020 Size : Uint2B
    +0 x022 Signature : Pos 0, 15 Bits
    +0 x022 FullCommit : Pos 15, 1 Bit
图5总结了VS后端的内存架构。
当VS块被释放时，如果它小于1KB并且VS后端是正确配置的（Config.Flags的第四位配置为1），它将被临时存储在DelayFreeContext列表中。一旦DelayFreeContext填充了32个块，这些块将一次性全部被释放。DelayFreeContext从不用于直接分配。
当一个VS块真的被释放，如果它与其他两个空闲块相邻，那么这三个空闲块将利用函数RtlpHpVsChunkCoalesce合并在一起。然后合并后的大块将被插入到FreeChunkTree中。
#### 低碎片化堆后端（Low Fragmentation Heap Backend）
低碎片化的堆是一个专门用来分配1B到512B的小块的后端。
LFH后端上下文存储在称作_HEAP_LFH_CONTEXT的结构体中。
    0: kd > dt nt! _HEAP_LFH_CONTEXT
    +0 x000 BackendCtx : Ptr64 Void
    +0 x008 Callbacks : _HEAP_SUBALLOCATOR_CALLBACKS
    +0 x030 AffinityModArray : Ptr64 UChar
    +0 x038 MaxAffinity : UChar
    +0 x039 LockType : UChar
    +0 x03a MemStatsOffset : Int2B
    +0 x03c Config : _RTL_HP_LFH_CONFIG
    +0 x040 BucketStats : _HEAP_LFH_SUBSEGMENT_STATS
    +0 x048 SubsegmentCreationLock : Uint8B
    +0 x080 Buckets : [129] Ptr64 _HEAP_LFH_BUCKET
LFH后端的主要特点是使用不同大小的bucket来避免碎片化
图6
每个bucket由段分配器分配的子段组成。段分配器通过使用_HEAP_LFH_CONTEXT结构体的_HEAP_SUBALLOCATOR_CALLBACKS字段来使用。子分配器回调函数与LFH上下文和RtlpHpHeapGlobals的地址进行异或。
    callbacks.Allocate = RtlpHpSegLfhAllocate ;
    callbacks.Free = RtlpHpSegLfhVsFree ;
    callbacks.Commit = RtlpHpSegLfhVsCommit ;
    callbacks.Decommit = RtlpHpSegLfhVsDecommit ;
    callbacks.ExtendContext = RtlpHpSegLfhExtendContext ;
LFH子段以_HEAP_LFH_SUBSEGMENT结构体为首
    0: kd > dt nt! _HEAP_LFH_SUBSEGMENT
    +0 x000 ListEntry : _LIST_ENTRY
    +0 x010 Owner : Ptr64 _HEAP_LFH_SUBSEGMENT_OWNER
    +0 x010 DelayFree : _HEAP_LFH_SUBSEGMENT_DELAY_FREE
    +0 x018 CommitLock : Uint8B
    +0 x020 FreeCount : Uint2B
    +0 x022 BlockCount : Uint2B
    +0 x020 InterlockedShort : Int2B