cation of the test harness to change the point at which
the keys are computed will even provide a successful ex-
ploitation of the bug.
An interesting observation regarding the evolution of
the OpenSSL code is that for the four different versions
that we analysed (1.0.1g, 1.0.1j, 1.0.1l and 1.0.2) the
number of states reduces with every version. For ver-
sion 1.0.2 there is still one state more than required, but
this is an error state from which all messages result in a
closed connection.
4.9 nqsb-TLS
A recent TLS implementation, nqsb-TLS, is intended to
be both a speciﬁcation and usable implementation writ-
ten in OCaml [25]. For nsqb-TLS we analysed ver-
sion 0.4.0. Our analysis revealed a bug in this imple-
mentation: alert messages are not encrypted even af-
ter a ChangeCipherSpec is received. This bug was re-
ported to the nqsb-TLS developers and is ﬁxed in a newer
version. What is more interesting is a design decision
with regard to the state machine: after the client sends
a ChangeCipherSpec, the server immediately responds
with a ChangeCipherSpec. This is different compared to
all other implementations, that ﬁrst wait for the client to
also send a Finished message before sending a response.
This is a clear example where the TLS speciﬁcations are
not completely unambiguous and adding a state machine
would remove room for interpretation.
5 Conclusion
We presented a thorough analysis of commonly used
TLS implementations using the systematic approach we
call protocol state fuzzing: we use state machine learn-
ing, which relies only on black box testing, to infer a
state machine and then we perform a manual analysis of
the state machines obtained. We demonstrated that this
is a powerful and fast technique to reveal security ﬂaws:
in 3 out of 9 tested implementations we discovered new
ﬂaws. We applied the method on both server- and client-
side implementations. By using our modiﬁed version of
the W-method we are able to drastically reduce the num-
ber of equivalence queries used, which in turn results in
a much lower running time of the analysis.
Our approach is able to ﬁnd mistakes in the logic in
the state machine of implementations. Deliberate back-
doors, that are for example triggered by sending a par-
ticular message 100 times, would not be detected. Also
mistakes in, for example, the parsing of messages or cer-
tiﬁcates would not be detected.
An overview of different approaches to prevent secu-
rity bugs and more generally improve the security of soft-
ware is given in [38] (using the Heartbleed bug as a ba-
sis). The method presented in this paper would not have
detected the Heartbleed bug, but we believe it makes a
useful addition to the approaches discussed in [38]. It
is related to some of the approaches listed there; in par-
ticular, state machine learning involves a form of neg-
ative testing: the tests carried out during the state ma-
chine learning include many negative tests, namely those
where messages are sent in unexpected orders, which one
would expect to result in the closing of the connection
(and which probably should result in closing of the con-
nection, to be on the safe side). By sending messages in
an unexpected order we get a high coverage of the code,
which is different from for example full branch code cov-
erage, as we trigger many different paths through the
code.
In parallel with our research Beurdouche et al. [6] in-
dependently performed closely related research. They
also analyse protocol state machines of TLS implemen-
tations and successfully ﬁnd numerous security ﬂaws.
Both approaches have independently come up with the
same fundamental idea, namely that protocol state ma-
chines are a great formalism to systematically analyse
implementations of security protocols. Both approaches
require the construction of a framework to send arbi-
trary TLS messages, and both approaches reveal that
OpenSSL and JSSE have the most (over)complicated
state machines.
204  24th USENIX Security Symposium 
USENIX Association
12
The approach of Beurdouche et al. is different though:
whereas we infer the state machines from the code with-
out prior knowledge, they start with a manually con-
structed reference protocol state machine, and subse-
quently use this as a basis to test TLS implementations.
Moreover, the testing they do here is not truly random, as
the ‘blind’ learning by LearnLib is, but uses a set of test
traces that is automatically generated using some heuris-
tics.
The difference in the issues identiﬁed by Beurdouche
et al. and us can partly be explained by the difference
in functionality that is supported by the test frameworks
used. For example, our framework supports the Heart-
beat extension, whereas theirs supports Difﬁe-Hellman
certiﬁcates and export cipher suites. Another reason is
the fact that our approach has a higher coverage due to
its ‘blind’ nature.
One advantage of our approach is that we don’t have to
construct a correct reference model by hand beforehand.
But in the end, we do have to decide which behaviour
is unwanted. Having a visual model helps here, as it is
easy to see if there are states or transitions that seem re-
dundant and don’t occur in other models. Note that both
approaches ultimately rely on a manual analysis to as-
sess the security impact of any protocol behaviour that is
deemed to be deviant or superﬂuous.
When it comes to implementing TLS, the speciﬁca-
tions leave the developer quite some freedom as how
to implement the protocol, especially in handling errors
or exceptions. Indeed, many of the differences between
models we infer are variations in error messages. These
are not ﬁxed in the speciﬁcations and can be freely cho-
sen when implementing the protocol. Though this might
be useful for debugging, the different error messages are
probably not useful in production (especially since they
differ per implementation).
This means that there is not a single ‘correct’ state ma-
chine for the TLS protocol and indeed every implemen-
tation we analysed resulted in a different model. How-
ever, there are some clearly wrong state machines. One
would expect to see a state machine where there is clearly
one correct path (or possibly more depending on the con-
ﬁguration) and all other paths going to one error state –
preferably all with the same error code. We have seen
one model that conforms to this, namely the one for RSA
BSAFE for Java, shown in Fig. 6.
Of course, it would be interesting to apply the same
technique we have used on TLS implementations here on
implementations of other security protocols. The main
effort in protocol state fuzzing is developing a test har-
ness. But as only one test harness is needed to test all
implementations for a given protocol, we believe that this
is a worthwhile investment. In fact, one can argue that
for any security protocol such a test harness should be
provided to allow analysis of implementations.
The ﬁrst manual analysis of the state machines we ob-
tain is fairly straightforward: any superﬂuous strange be-
haviour is easy to spot visually. This step could even be
automated as well by providing a correct reference state
machine. A state machine that we consider to be correct
would be the one that we learned for RSA BSAFE for
Java.
Deciding whether any superﬂuous behaviour is ex-
ploitable is the hardest part of the manual analysis, but
for security protocols it makes sense to simply require
that there should not be any superﬂuous behaviour what-
soever.
The difference behaviour between the various imple-
mentations might be traced back to Postel’s Law:
‘Be conservative in what you send,
be liberal in what you accept.’
As has been noted many times before, e.g. in [35], this
is an unwanted and risky approach in security protocols:
if there is any suspicion about inputs they should be dis-
carded, connections should be closed, and no response
should be given that could possibly aid an attacker. To
quote [21]: ‘It’s time to deprecate Jon Postel’s dictum
and to be conservative in what you accept’.
Of course, ideally state machines would be included in
the ofﬁcial speciﬁcations of protocols to begin with. This
would provide a more fundamental solution to remove –
or at least reduce – some of the implementation freedom.
It would avoid each implementer having to come up with
his or her own interpretation of English prose speciﬁca-
tions, avoiding not only lots of work, but also the large
variety of state machines in implementations that we ob-
served, and the bugs that some of these introduce.
References
[1] AARTS, F., DE RUITER, J., AND POLL, E. Formal models of
bank cards for free. In Software Testing Veriﬁcation and Valida-
tion Workshop, IEEE International Conference on (2013), IEEE,
pp. 461–468.
[2] AARTS, F., SCHMALTZ, J., AND VAANDRAGER, F. Inference
and abstraction of the biometric passport. In Leveraging Appli-
cations of Formal Methods, Veriﬁcation, and Validation, T. Mar-
garia and B. Steffen, Eds., vol. 6415 of Lecture Notes in Com-
puter Science. Springer, 2010, pp. 673–686.
[3] AL FARDAN, N., AND PATERSON, K. Lucky Thirteen: Breaking
In Security and Privacy
the TLS and DTLS record protocols.
(SP), 2013 IEEE Symposium on (2013), IEEE, pp. 526–540.
[4] ALFARDAN, N., BERNSTEIN, D. J., PATERSON, K. G., POET-
TERING, B., AND SCHULDT, J. C. N. On the security of RC4 in
TLS. In Presented as part of the 22nd USENIX Security Sympo-
sium (USENIX Security 13) (2013), USENIX, pp. 305–320.
[5] ANGLUIN, D. Learning regular sets from queries and counterex-
amples. Information and Computation 75, 2 (1987), 87–106.
USENIX Association  
24th USENIX Security Symposium  205
13
[6] BENJAMIN BEURDOUCHE, KARTHIKEYAN BHARGAVAN, A.
D.-L., FOURNET, C., KOHLWEISS, M., PIRONTI, A., STRUB,
P.-Y., , AND ZINZINDOHOUE, J. K. A messy state of the union:
Taming the composite state machines of TLS.
In Security and
Privacy (SP), 2015 IEEE Symposium on (2015), IEEE, pp. 535–
552.
[7] BHARGAVAN, K., FOURNET, C., CORIN, R., AND ZALINESCU,
E. Cryptographically veriﬁed implementations for TLS. In Pro-
ceedings of the 15th ACM Conference on Computer and Commu-
nications Security (2008), CCS ’08, ACM, pp. 459–468.
[8] BHARGAVAN, K., FOURNET, C., KOHLWEISS, M., PIRONTI,
A., AND STRUB, P.
Implementing TLS with veriﬁed crypto-
graphic security. 2013 IEEE Symposium on Security and Privacy
(2013), 445–459.
[9] BLEICHENBACHER, D. Chosen ciphertext attacks against pro-
In
tocols based on the RSA encryption standard PKCS #1.
Advances in Cryptology – CRYPTO ’98, H. Krawczyk, Ed.,
vol. 1462 of Lecture Notes in Computer Science. Springer, 1998,
pp. 1–12.
[10] BRUBAKER, C., JANA, S., RAY, B., KHURSHID, S., AND
SHMATIKOV, V. Using Frankencerts for automated adversar-
ial testing of certiﬁcate validation in SSL/TLS implementations.
In Security and Privacy (SP), 2014 IEEE Symposium on (2014),
pp. 114–129.
[11] CHALUPAR, G., PEHERSTORFER, S., POLL, E., AND
DE RUITER, J. Automated reverse engineering using Lego. In
8th USENIX Workshop on Offensive Technologies (WOOT 14)
(2014), USENIX.
[12] CHOW, T. Testing software design modeled by ﬁnite-state ma-
chines. IEEE Transactions on Software Engineering 4, 3 (1978),
178–187.
[13] CODENOMICON. Heartbleed bug. http://heartbleed.com/.
Accessed on June 8th 2015.
[14] COMPARETTI, P., WONDRACEK, G., KRUEGEL, C., AND
KIRDA, E. Prospex: Protocol speciﬁcation extraction. In Secu-
rity and Privacy, 2009 30th IEEE Symposium on (2009), IEEE,
pp. 110–125.
[15] DE RUITER, J. Lessons learned in the analysis of the EMV
and TLS security protocols. PhD thesis, Radboud University Ni-
jmegen, 2015.
[16] DÍAZ, G., CUARTERO, F., VALERO, V., AND PELAYO, F. Auto-
matic veriﬁcation of the TLS handshake protocol. In Proceedings
of the 2004 ACM Symposium on Applied Computing (2004), SAC
’04, ACM, pp. 789–794.
[17] DIERKS, T., AND ALLEN, C. The TLS protocol version 1.0.
RFC 2246, Internet Engineering Task Force, 1999.
[18] DIERKS, T., AND RESCORLA, E. The Transport Layer Security
(TLS) protocol version 1.1. RFC 4346, Internet Engineering Task
Force, 2006.
[19] DIERKS, T., AND RESCORLA, E. The Transport Layer Security
(TLS) protocol version 1.2. RFC 5246, Internet Engineering Task
Force, 2008.
[20] GAJEK, S., MANULIS, M., PEREIRA, O., SADEGHI, A.-R.,
AND SCHWENK, J. Universally composable security analysis of
TLS. In Provable Security, J. Baek, F. Bao, K. Chen, and X. Lai,
Eds., vol. 5324 of Lecture Notes in Computer Science. Springer,
2008, pp. 313–327.
[21] GEER, D. Vulnerable compliance. login: The USENIX Magazine
35, 6 (2010), 10–12.
[22] HE, C., SUNDARARAJAN, M., DATTA, A., DEREK, A., AND
MITCHELL, J. C. A modular correctness proof of IEEE 802.11i
and TLS. In Proceedings of the 12th ACM Conference on Com-
puter and Communications Security (2005), CCS ’05, ACM,
pp. 2–15.
[23] HSU, Y., SHU, G., AND LEE, D. A model-based approach to
security ﬂaw detection of network protocol implementations. In
Network Protocols, 2008. ICNP 2008. IEEE International Con-
ference on (2008), IEEE, pp. 114–123.
[24] JAGER, T., KOHLAR, F., SCHÄGE, S., AND SCHWENK, J. On
In Advances
the security of TLS-DHE in the standard model.
in Cryptology – CRYPTO 2012, R. Safavi-Naini and R. Canetti,
Eds., vol. 7417 of Lecture Notes in Computer Science. Springer,
2012, pp. 273–293.
[25] KALOPER-MERŠINJAK, D., MEHNERT, H., MADHAVAPEDDY,
A., AND SEWELL, P. Not-quite-so-broken TLS: Lessons in
re-engineering a security protocol speciﬁcation and implemen-
tation. In 24th USENIX Security Symposium (USENIX Security
15) (2015), USENIX Association.
[26] KAMIL, A., AND LOWE, G. Analysing TLS in the strand spaces
model. Journal of Computer Security 19, 5 (2011), 975–1025.
[27] KIKUCHI, M. OpenSSL #ccsinjection vulnerability. http://
ccsinjection.lepidum.co.jp/. Access on June 8th 2015.
[28] KRAWCZYK, H., PATERSON, K., AND WEE, H. On the security
of the TLS protocol: A systematic analysis. In Advances in Cryp-
tology – CRYPTO 2013, vol. 8042 of Lecture Notes in Computer
Science. Springer, 2013, pp. 429–448.
[29] MEYER, C., AND SCHWENK, J. SoK: Lessons learned from
SSL/TLS attacks. In Information Security Applications, Y. Kim,
H. Lee, and A. Perrig, Eds., Lecture Notes in Computer Science.
Springer, 2014, pp. 189–209.
[30] MEYER, C., SOMOROVSKY, J., WEISS, E., SCHWENK, J.,
SCHINZEL, S., AND TEWS, E. Revisiting SSL/TLS imple-
mentations: New bleichenbacher side channels and attacks.
In
23rd USENIX Security Symposium (USENIX Security 14) (2014),
USENIX Association, pp. 733–748.
[31] MORRISSEY, P., SMART, N., AND WARINSCHI, B. A modular
security analysis of the TLS handshake protocol. In Advances in
Cryptology – ASIACRYPT 2008, J. Pieprzyk, Ed., vol. 5350 of
Lecture Notes in Computer Science. Springer, 2008, pp. 55–73.
[32] OGATA, K., AND FUTATSUGI, K. Equational approach to for-
mal analysis of TLS. In Distributed Computing Systems, 2005.
ICDCS 2005. Proceedings. 25th IEEE International Conference
on (2005), IEEE, pp. 795–804.
[33] PAULSON, L. C. Inductive analysis of the internet protocol TLS.
ACM Trans. Inf. Syst. Secur. 2, 3 (1999), 332–351.
[34] RAFFELT, H., STEFFEN, B., AND BERG, T. LearnLib: a library
for automata learning and experimentation.
In Formal methods
for industrial critical systems (FMICS’05) (2005), ACM, pp. 62–
71.
[35] SASSAMAN, L., PATTERSON, M. L., AND BRATUS, S. A patch
for Postel’s robustness principle. Security & Privacy, IEEE 10, 2
(2012), 87–91.
[36] SEGGELMANN, R., TUEXEN, M., AND WILLIAMS, M. Trans-
port Layer Security (TLS) and Datagram Transport Layer Secu-
rity (DTLS) Heartbeat Extension. RFC 6520, Internet Engineer-
ing Task Force, 2012.
[37] TURNER, S., AND POLK, T. Prohibiting Secure Sockets Layer
(SSL) version 2.0. RFC 6176, Internet Engineering Task Force,
2011.
[38] WHEELER, D. Preventing Heartbleed. Computer 47, 8 (2014),
80–83.
206  24th USENIX Security Symposium 
USENIX Association
14