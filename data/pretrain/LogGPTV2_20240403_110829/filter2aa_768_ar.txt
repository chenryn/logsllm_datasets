类、类加载器，以及用于同步的监视对象等。 
28.9.4  JDWP 
简单来说，Java Debug Wire Protocol（JDWP）是一个通信协议，它定义了被调试进程
（Debuggee）与调试器进程通信的格式和方法。JDWP 允许调试器进程和被调试程序工作
在不同的机器上，以支持远程调试。 
JDWP 中的所有数据通信是基于数据包的，它定义了两种基本的包类型：命令包和回
复包。每个包都由固定长度的头结构（Header）和可变长度的数据组成。命令包的头格式
为。 
长度（4 bytes）：整个包的长度，包括这个字段。 
《软件调试》补编 
- 61 – 
Copyright © 2009 ADVDBG.ORG All Rights Reserved 
ID（4 bytes）：包的唯一 ID。 
标志（1 byte）：标志位，0x80 位如果为 1，则代表是回复包。 
命令集合（1 byte）：命令所属的命令集合。 
命令（1 byte）：命令。 
回复包的头格式为： 
长度（4 bytes）：整个包的长度，包括这个字段。 
ID（4 bytes）：包的唯一 ID。 
标志（1 byte）：标志位。 
错误代码（2 bytes）：0 代表成功，非零代表发生错误。 
调试器进程通过命令包向被调试进程中的调试器后端发送命令，调试器后端收到命令
后通过回复包发送处理结果。命令包中的命令集合字段和命令字段指定了要执行的命令，
目前 JDWP 定义了 18 个命令集合，共 100 多条命令。JDWP 的文档详细定义了每个命令
包的格式和用法，因为篇幅关系，在此从略。 
JDK 中包含了使用 JPDA 的 3 个例子程序，分别是用来显示踪迹信息的 Trace 程序，
一个简单的命令行调试器 JDB 和一个简单的 GUI 调试器 Javadt。感兴趣的读者可以下载
JDK 并阅读它们的源代码。 
《软件调试》补编 
- 62 – 
Copyright © 2009 ADVDBG.ORG All Rights Reserved 
补编内容
补编内容
补编内容
补编内容 7 WinDBG 内幕
内幕
内幕
内幕 
补编说明： 
这一节本来属于《软件调试》第 29 章的后半部分，讲的是 WinDBG 调试器实
现不同类型的调试会话的方式，分内核调试和远程用户态调试两个部分。 
考虑到第 30 章还会介绍有关的主题，在最后一轮压缩篇幅时，这一节被
删除了。 
29.8  内核调试 
前面两节我们以活动的用户态调试目标为例，介绍了调试会话和 WinDBG 接收处理
命令的过程。本节我们将把这些内容推广到内核调试的情况，严格来说，是通过通信电缆
进行双机内核调试的情况。 
29.8.1  建立内核调试会话 
对于用户态调试目标，无论是启动新进程开始调试还是附加到一个已经存在的进程，
一旦选定了程序文件或者进程 ID，那么调试器就立刻与调试目标建立起了调试会话。内
核调试与此略有不同，当我们选择内核调试（WinDBG 的 File>Kernel Debug…）并指定通
信方式（COM、1394 或 USB）后，虽然调试器会开始启动调试会话并等待与调试目标建
立连接，但是直到与调试目标建立起通信连接并检测到目标的基本信息后，内核调试会话
才真正建立。为了便于理解，我们将内核调试会话的建立过程分为两个阶段：启动阶段和
连接阶段。 
举例来说，我们可以在一台没有连接串行数据线的计算机上，选择开始内核调试
（File>Kernel Debug，选择 COM），点击确定后，WinDBG 就会创建调试会话线程，然后
调用 StartSession 开始调试会话，其执行过程如清单 29-8 所示。 
清单 29-8  开始内核调试会话 
0:001> kn 
 # ChildEBP RetAddr   
00 00dffce8 020c5dec dbgeng!ConnLiveKernelTargetInfo::ConnLiveKernelTargetInfo 
01 00dffd38 020bf86d dbgeng!LiveKernelInitialize+0x6c 
02 00dffd5c 0102a532 dbgeng!DebugClient::AttachKernelWide+0x7d 
03 00dfffa4 0102a9bb WinDBG!StartSession+0x5f2 
04 00dfffb4 7c80b6a3 WinDBG!EngineLoop+0x1b 
05 00dfffec 00000000 kernel32!BaseThreadStart+0x37 
《软件调试》补编 
- 63 – 
Copyright © 2009 ADVDBG.ORG All Rights Reserved 
其中，2 号栈帧是调用 DebugClient 类的 AttachKernel 方法，其原型如下： 
HRESULT  IDebugClient5::AttachKernelWide( 
    IN ULONG  Flags,    IN OPTIONAL PCWSTR  ConnectOptions); 
其 中 Flags 可 以 为 DEBUG_ATTACH_KERNEL_CONNECTION （ 0 ）、 DEBUG_ 
ATTACH_LOCAL_KERNEL（1）和 DEBUG_ATTACH_EXDI_DRIVER（2）三个值之一。
因为我们选择的是通过串口进行双机调试，所以 Flags 参数为 0，ConnectOptions 参数的值
如下： 
0:001> du 010662e4 // 可以从栈帧#02 的参数中得到这个地址 
010662e4  "com:port=com1,baud=115200" 
AttachKernel 函数根据指定的参数调用 LiveKernelInitialize 来初始化调试活动内核目
标所需的调试器引擎对象，0 号栈帧显示在执行 ConnLiveKernelTargetInfo 类的构造函数，
也就是构建 ConnLiveKernelTargetInfo 类的实例，这个构造好的实例会保存在 g_Target 全
局变量中。AttachKernel 返回后，StartSession 做了些公共的初始化工作后，便也返回了。
至此，内核调试会话的启动阶段结束，调试会话线程开始等待与调试目标建立连接。 
我们知道内核调试引擎（Kernel Debug Engine，简称 KD）是 Windows 操作系统内核
的一部分，它的功能就是调试器一起工作实现内核调试。因此，从通信的角度来看，在进
行双机内核调试时，通信的一方是主机上的调试器，另一方是目标系统上的内核调试引擎，
即 KD。 
当 WinDBG 收到 KD 的第一个数据包后，ConnLiveKernelTargetInfo 类的 WaitForEvent
方法会调用 ProcessStateChange 方法，后者会调用 NotifyDebuggee- Activation 方法，这与
用户调试态调试时在处理进程创建事件前调用 NotifyDebuggee- Activation 的情况类似。清
单 29-9 显示了其执行过程。 
清单 29-9  建立连接的过程 
0:001> kn 
//调试会话线程 
 # ChildEBP RetAddr   
00 00d0fa20 7c90e9c0 ntdll!KiFastSystemCallRet 
//调用内核服务 
01 00d0fa24 7c8025cb ntdll!ZwWaitForSingleObject+0xc 
//残根函数 
02 00d0fa88 020c275a kernel32!WaitForSingleObjectEx+0xa8 
//等待同步对象 
03 00d0faa8 01055bdc dbgeng!DebugClient::DispatchCallbacks+0x4a  
04 00d0fab8 0102a7e1 WinDBG!EngSwitchWorkspace+0x9c 
//切换工作空间 
05 00d0fad0 01027378 WinDBG!SessionActive+0x171 
//激活会话 
06 00d0fadc 020b71ea WinDBG!EventCallbacks::SessionStatus+0x28  
07 00d0faf0 020b38ec dbgeng!SessionStatusApcData::Dispatch+0x2a  
08 00d0fb28 020b3b4f dbgeng!ApcDispatch+0x4c 
09 00d0fb78 020b7181 dbgeng!SendEvent+0xcf 
0a 00d0fb98 02130ef5 dbgeng!NotifySessionStatus+0x21 
0b 00d0fbc4 0213466b dbgeng!NotifyDebuggeeActivation+0x55 
0c 00d0fef4 02133eb1 dbgeng!ConnLiveKernelTargetInfo::ProcessStateChange+0x1bb 
0d 00d0ff10 020ceacf dbgeng!ConnLiveKernelTargetInfo::WaitForEvent+0xe1 
0e 00d0ff34 020cee9e dbgeng!WaitForAnyTarget+0x5f 
//等待目标 
0f 00d0ff80 020cf110 dbgeng!RawWaitForEvent+0x2ae 
10 00d0ff98 0102aadf dbgeng!DebugClient::WaitForEvent+0xb0 
//等待事件 
11 00d0ffb4 7c80b6a3 WinDBG!EngineLoop+0x13f 
//调试循环 
12 00d0ffec 00000000 kernel32!BaseThreadStart+0x37 
其中，栈帧#0b~#05 是向调试器中注册的回调对象通知会话状态（Session Status）改
变。 栈帧#04 是当调试器检测到了调试目标的基本信息后，要切换到与其相匹配的工作
空间。在切换到新的工作空间前，WinDBG 通常会显示图 29-19 所示的对话框，询问用户
是否要保存当前使用的默认工作空间（’Kernel default’）。 
《软件调试》补编 
- 64 – 
Copyright © 2009 ADVDBG.ORG All Rights Reserved 
图 29-19  WinDBG 在收到内核调试目标激活消息后显示的工作空间对话框 
值得注意的是，3 号栈帧调用了 DispatchCallbacks 方法，这会使当前线程（调试会话
线程）进入等待状态。因此，当 WinDBG 显示图 29-8 所示的对话框时，调试器的调试会
话线程是处于等待状态的，而且此时目标系统也是处于冻结状态的。只有这个对话框被关
闭后，UI 线程才会调用 FinishCommand 命令，然后 UpdateEngine，再调用 ExitDispatch
方法，增加信号量的计数，使调试会话进程被唤醒，清单 29-18 显示了这一过程。 
清单 29-10  应用内核调试工作空间 
0:000> kn 
 # ChildEBP RetAddr   
00 0006cd00 0102af20 dbgeng!DebugClient::ExitDispatch 
//通知调试会话线程 
01 0006cd10 010279d5 WinDBG!UpdateEngine+0x30 
//更新调试器引擎 
02 0006cd18 01027acf WinDBG!FinishCommand+0x15 
03 0006cd3c 01027b89 WinDBG!AddStringCommand+0xef 
04 0006cd5c 01054d11 WinDBG!AddStringMultiCommand+0xa9 //执行命令恢复目标执行 
05 0006d218 01055901 WinDBG!Workspace::Apply+0x5c1 
//应用新的工作空间 
06 0006d240 01055b03 WinDBG!UiSwitchWorkspace+0xd1 
//切换工作空间 
07 0006d260 0103d539 WinDBG!UiDelayedSwitchWorkspace+0x33//迟后的工作空间切换 
08 0006ddf4 7e418724 WinDBG!FrameWndProc+0x1e09 
//窗口过程 
… 
//省略其他栈帧 
调试会话线程等待到信号量后，EngineLoop 再次调用 DebugClient 类的 WaitForEvent
方法等待下一个调试事件。至此内核调试会话的连接阶段结束，调试会话完全建立。 
29.8.2  等待调试事件 
清单 29-11 显示了使用串行电缆进行双机内核调试时，WinDBG 的调试会话线程等待
调试事件的过程。 
清单 29-11  等待内核调试事件 
0:001> kn 
 # ChildEBP RetAddr   
00 00e0fb68 022919be kernel32!ReadFile 
//从 COM 口读取数据 
01 00e0fcd4 022a83cc dbgeng!ComPortRead+0x22e 
//调试器引擎的 COM 函数 
02 00e0fd00 022a7782 dbgeng!KdComConnection::Read+0x6c //串行通信连接层 
03 00e0fd20 022a91be dbgeng!KdConnection::ReadAll+0x22  
04 00e0fd90 020dd497 dbgeng!KdComConnection::Synchronize+0x16e 
05 00e0fdbc 020dd624 dbgeng!DbgKdTransport::Synchronize+0xc7 
06 00e0fddc 020ddff3 dbgeng!DbgKdTransport::ReadPacketContents+0x84 
07 00e0fe50 02133f5b dbgeng!DbgKdTransport::WaitForPacket+0x133 
08 00e0feec 02133e38 dbgeng!ConnLiveKernelTargetInfo::WaitStateChange+0x8b 
09 00e0ff10 020ceacf dbgeng!ConnLiveKernelTargetInfo::WaitForEvent+0x68 
0a 00e0ff34 020cee9e dbgeng!WaitForAnyTarget+0x5f 
//轮番等待所有调试目标 
0b 00e0ff80 020cf110 dbgeng!RawWaitForEvent+0x2ae 
0c 00e0ff98 0102aadf dbgeng!DebugClient::WaitForEvent+0xb0  
0d 00e0ffb4 7c80b6a3 WinDBG!EngineLoop+0x13f 
//调试会话循环 
0e 00e0ffec 00000000 kernel32!BaseThreadStart+0x37 
//会话线程的启动函数 
可以看出，从栈帧#0e 到栈帧#0a 与用户态的情况（清单 29-2）完全相同，这得益于
重构后的 WinDBG 使用了 C++的多态性，顶层可以用统一的代码来处理不同类型的调试
目标。栈帧#07 是调用 DbgKdTransport 类的 WaitForPacket 方法等待来自目标系统的数据
包，而后传输层调用连接层，即 KdComConnection 类的方法。KdComConnection 会按照
《软件调试》补编 
- 65 – 
Copyright © 2009 ADVDBG.ORG All Rights Reserved 
一定的时间间隔反复读取 COM 口，监视是否有数据来临。 
29.8.3  执行命令 
在进行内核调试时，大多数命令都需要位于目标系统的内核调试引擎（KD）的帮助，
只有少数命令可以完全在本地执行。对于需要调试引擎协助的命令，调试器需要通过第
18 章介绍的内核调试协议与 KD 进行通信。清单 29-12 显示了 WinDBG 的调试会话线程
在执行寄存器命令（r）时向 KD 发送数据包的过程。 
清单 29-12  调试会话线程执行 r 命令时向 KD 发送请求的过程 
0:001> kn 50 
 # ChildEBP RetAddr   
00 00d0e334 022a77d6 dbgeng!KdComConnection::Write 
//写数据 
01 00d0e358 022a8ee0 dbgeng!KdConnection::WriteAll+0x26 
//连接层的基类方法 
02 00d0e384 020dd8aa dbgeng!KdComConnection::WritePacketContents+0x80 
03 00d0e3c8 020de6b5 dbgeng!DbgKdTransport::WritePacketContents+0x7a 
04 00d0e448 020b250a dbgeng!DbgKdTransport::WriteDataPacket+0x1c5 
05 00d0e46c 020deb14 dbgeng!DbgKdTransport::WritePacket+0x2a 
06 00d0e4a8 020debf2 dbgeng!DbgKdTransport::SendReceivePacket+0x44 
07 00d0e4d4 020d72df dbgeng!DbgKdTransport::SendReceiveManip+0x42//发送访问类 API 
08 00d0e548 020f058e dbgeng!ConnLiveKernelTargetInfo::ReadControl+0x7f 
09 00d0e574 0214e3d7 dbgeng!TargetInfo::GetTargetSpecialRegisters+0x3e 
0a 00d0e590 021723e1 dbgeng!X86MachineInfo::KdGetContextState+0xd7 
0b 00d0e5a8 02150f68 dbgeng!MachineInfo::GetContextState+0x121 
0c 00d0e6e0 02236afd dbgeng!X86MachineInfo::OutputAll+0x28 
0d 00d0e824 02199468 dbgeng!OutCurInfo+0x25d 
0e 00d0e8bc 02186362 dbgeng!ParseRegCmd+0x1b8 
//解析 r 命令 
0f 00d0e8fc 02188348 dbgeng!WrapParseRegCmd+0x92 
//r 命令的入口 
10 00d0e9d8 021889a9 dbgeng!ProcessCommands+0x1278 
//分发命令 
11 00d0ea1c 020cbec9 dbgeng!ProcessCommandsAndCatch+0x49 
12 00d0eeb4 020cc12a dbgeng!Execute+0x2b9 
13 00d0eee4 01028553 dbgeng!DebugClient::ExecuteWide+0x6a //执行命令的接口函数 
14 00d0ef8c 01028a43 WinDBG!ProcessCommand+0x143 
15 00d0ffa0 0102ad06 WinDBG!ProcessEngineCommands+0xa3 
16 00d0ffb4 7c80b6a3 WinDBG!EngineLoop+0x366 
//调试会话循环 
17 00d0ffec 00000000 kernel32!BaseThreadStart+0x37 
其中栈帧#0b 到#17 与调试 x86 架构的用户目标时是完全一样的。栈帧#08 是
ConnLiveKernelTargetInfo 类的 ReadControl 方法通过传输层向目标系统的 KD 发送请求。
请求发送后，SendReceivePacket 方法调用 WaitForPacket 读取 KD 的回复包（清单 29-13）。 
清单 29-13  WinDBG 的调试会话线程读取 KD 回复的过程（部分） 
0:001> kn 