title:TriggerScope: Towards Detecting Logic Bombs in Android Applications
author:Yanick Fratantonio and
Antonio Bianchi and
William K. Robertson and
Engin Kirda and
Christopher Kruegel and
Giovanni Vigna
2016 IEEE Symposium on Security and Privacy
2016 IEEE Symposium on Security and Privacy
TriggerScope: Towards Detecting Logic Bombs
in Android Applications
Yanick Fratantonio∗, Antonio Bianchi∗, William Robertson†, Engin Kirda†, Christopher Kruegel∗, Giovanni Vigna∗
∗UC Santa Barbara
{yanick,antoniob,chris,vigna}@cs.ucsb.edu
†Northeastern University
{wkr,ek}@ccs.neu.edu
Abstract—Android is the most popular mobile platform today,
and it is also the mobile operating system that is most heavily
targeted by malware. Existing static analyses are effective in
detecting the presence of most malicious code and unwanted
information ﬂows. However, certain types of malice are very dif-
ﬁcult to capture explicitly by modeling permission sets, suspicious
API calls, or unwanted information ﬂows.
One important type of such malice is malicious application
logic, where a program (often subtly) modiﬁes its outputs or per-
forms actions that violate the expectations of the user. Malicious
application logic is very hard to identify without a speciﬁcation of
the “normal,” expected functionality of the application. We refer
to malicious application logic that is executed, or triggered, only
under certain (often narrow) circumstances as a logic bomb. This
is a powerful mechanism that is commonly employed by targeted
malware, often used as part of APTs and state-sponsored attacks:
in fact, in this scenario, the malware is designed to target speciﬁc
victims and to only activate under certain circumstances.
In this paper, we make a ﬁrst step towards detecting logic
bombs. In particular, we propose trigger analysis, a new static
analysis technique that seeks to automatically identify triggers
in Android applications. Our analysis combines symbolic execu-
tion, path predicate reconstruction and minimization, and inter-
procedural control-dependency analysis to enable the precise
detection and characterization of triggers, and it overcomes
several limitations of existing approaches.
We implemented a prototype of our analysis, called TRIG-
GERSCOPE, and we evaluated it over a large corpus of 9,582
benign apps from the Google Play Store and a set of trigger-
based malware, including the recently-discovered HackingTeam’s
RCSAndroid advanced malware. Our system is capable of
automatically identify several interesting time-, location-, and
SMS-related triggers,
is affected by a low false positive rate
(0.38%), and it achieves 100% detection rate on the malware
set. We also show how existing approaches, speciﬁcally when
tasked to detect logic bombs, are affected by either a very high
false positive rate or false negative rate. Finally, we discuss the
logic bombs identiﬁed by our analysis, including two previously-
unknown backdoors in benign apps.
I. INTRODUCTION
Android is currently the most popular mobile platform. 78%
of all smartphones sold in Q1 2015 [39] were shipped with
Android installed, and the Google Play Store now hosts more
than two million applications [17]. Unfortunately, Android
has also become the most widely-attacked mobile platform;
according to a recent report, it is the target of 79% of known
mobile malware instances [59].
2375-1207/16 $31.00 © 2016 IEEE
© 2016, Yanick Fratantonio. Under license to IEEE.
DOI 10.1109/SP.2016.30
DOI 10.1109/SP.2016.30
377
377
App store providers invest signiﬁcant resources to protect
their users and keep their platforms clean from malicious
apps. To prevent malicious apps from entering the market
(and to detect malice in already-accepted applications), these
providers typically use a combination of automated program
analysis (e.g., Google Bouncer [41]) and manual app reviews.
These automated approaches leverage static and/or dynamic
code analysis techniques, and they aim to detect potentially-
malicious behaviors – e.g., exﬁltrating personal private infor-
mation, stealing second-factor authentication codes, sending
text messages to premium numbers, or creating mobile bot-
nets. These techniques are similar in nature to the numer-
ous approaches to detecting Android malware proposed in
academia [29], [31], [40], [36], [64], [14], [18], [19], [32].
These approaches proved to be effective when detecting tra-
ditional malware [63], and recent reports show that the ofﬁcial
Google Play app store is reasonably free from malicious
applications [15].
Nonetheless, there are certain types of malice that are still
very difﬁcult to capture explicitly by modeling permission
sets, suspicious API calls, or unwanted information ﬂows
(i.e., all those features used by existing analysis approaches).
One important type of such malice is malicious application
logic. We consider a program to contain malicious application
logic when it (often subtly) modiﬁes its outputs, providing
results that violate the expectations that a user can reasonably
have when interacting with this app. In particular, we refer to
malicious application logic that is executed, or triggered, only
under certain (often narrow) circumstances as a logic bomb.
As an example of a logic bomb, consider a navigation
application (similarly to Google Maps) that is meant to assist a
soldier in the battleﬁeld when determining the shortest route to
a given location. As a legitimate part of its intended behavior,
this application would collect GPS-related information, send
the information over the network to the application’s back-
end for processing, retrieve the results, and display to the
user some helpful information (such as the route to follow).
Assume further that
this app contains a functionality that
checks whether the current day is past a speciﬁc, hard-coded
date: If the current day is indeed past this date, the app subtly
queries the network back-end for a long route, and not for
the shortest one as the user would expect. Thus, after the
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:13:49 UTC from IEEE Xplore.  Restrictions apply. 
Date now = new Date();
Date target = new Date(12,22,2016);
// 1) retrieve GPS coordinates;
...
if (now.after(target)) {
// 2) query network back-end
//
g();
} else {
for a *long* route
1 public void f() {
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18 }
// 2) query network back-end
//
//
h();
for the *shortest* route
(as expected)
}
// 3) show computed route to user
...
Figure 1: A possible implementation of a logic bomb.
hard-coded date, this application would provide misleading
information, and the results could seriously affect the well-
being of the user. Figure 1 shows a possible implementation
of this behavior.
While traditional malware rarely implements this kind of
stealthy behavior, these techniques are often used by targeted
malware employed by APT actors when executing targeted,
state-sponsored attacks. In fact,
in this scenario, malware
is designed to target speciﬁc victims and to only activate
under certain circumstances. Unfortunately, targeted malware
are becoming more prevalent. As a clear example, in July
2015 the HackingTeam security company was victim of a
sophisticated attack [56], and all its internal resources and
personal communications got publicly leaked: This attack led
to the identiﬁcation of RCSAndroid [60], one of the most
sophisticated malware sample for Android ever discovered.
This malware has the ability to leak the victim’s private con-
versations, GPS location, and device tracking information, but
it is also able to capture screenshots, collect information about
online accounts, and capture real-time voice calls. However,
these malicious behaviors are not manifested when the appli-
cation starts. Instead, to increase its stealthiness, RCSAndroid
waits for incoming SMS messages and checks whether these
messages are sent from speciﬁc senders and contain speciﬁc
commands. While this application was ofﬁcially sold to law
enforcements agencies and governments, the HackingTeam
company has been accused by anti-surveillance campaigners
of collaborating with governments with poor human rights
records [57], and also in conducting targeted attacks against
activists [58]. In particular, RCSAndroid’s usage in the wild
is documented by several (now public) internal communica-
tions [7], [5], [6].
Another scenario where trigger-based malware poses a real
threat is related to the Android app store curated by the U.S.
Department of Defense [26], which collects applications to
assist ofﬁcers and soldiers in the battleﬁeld. The DoD market-
place features applications that are internally-developed but
also many applications developed by government contractors
and third parties, such as commercial entities. The current
solution to ﬁnding malicious application logic is manual audit,
often in combination with dynamic analysis. That is, to vet an
application, a human analyst executes the program in an in-
strumented environment and studies its behavior under various
inputs. In this model, the analyst’s own judgment and the app’s
description serve as the guidelines to help determine whether
the program functions as expected. Unfortunately, even this
costly (both in terms of time and labor) manual process does
not guarantee the identiﬁcation of logic bombs, especially for
those cases where the source code is not available (e.g., Google
Maps).
Logic bombs are particularly insidious, since they can elude
static analysis efforts and are hard to detect for human analysts,
even when equipped with powerful dynamic analysis tools. In
fact, consider the example in Figure 1. When examining this
application, a static analysis system will not ﬁnd any unusual
permission or unwanted API calls, or any clearly-malicious
action (in fact, invoking network-related APIs is perfectly
legitimate for a navigation app), thereby bypassing traditional
approaches such as [31], [18], [36], [64]. Also, all information
ﬂows (e.g., location-related source ﬂows to a network sink)
are expected, as they correspond to the description of the app
in the store, rendering ineffective the detection capabilities
provided by [19], [35]. Approaches based on dynamic analy-
sis [41], [29], [40], [53], [49], [55] are ineffective as well: since
the hardcoded date is set in the future, the time-related check
will not be satisﬁed when testing the app, and the malicious
functionality will thus not be executed. As another example,
an app could run its malicious behavior only when the user
is in a particular location. Unfortunately, these techniques are
actively being used to bypass automatic and manual vetting
systems [10], [1].
it
The key challenge is related to the fact that automatically
detecting malicious application logic is very hard without
taking into account the speciﬁc purpose and “normal” func-
tionality of an application, and, hence,
is out of reach
for most existing analysis tools. In fact, even those dynamic
analysis tools designed to increase the code coverage (e.g.,
approaches based on multipath execution and/or dynamic sym-
bolic execution [43], [22], [34], [8], [42], [61], [48]) would not
have access to enough information to discern whether the just-
executed functionality was malicious or not. At the very least,
these tools would require a very ﬁne-grained speciﬁcation of
the intended app behavior, something that is typically not
available.
In this paper, we make a ﬁrst step towards the automatic
detection of logic bombs. Our work is based on the follow-
ing key observation: an aspect that, at least in principle, is
necessary for the implementation of a logic bomb is that
the malicious behavior is triggered only under very speciﬁc
circumstances. Thus, in this work we propose to detect logic
bombs by precisely analyzing and characterizing the checks
that guard a given behavior, and to give less importance to the
behavior itself. To this end, we developed a new static analysis
378378
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:13:49 UTC from IEEE Xplore.  Restrictions apply. 
technique, called trigger analysis, which combines traditional
program analysis techniques with novel elements used for
automatically and precisely identifying triggers. We (infor-
mally) deﬁne triggers as suspicious predicates (or checks)
over program inputs that guard the execution of potentially-
sensitive behavior, where a predicate is (intuitively) considered
as suspicious if it is satisﬁed only under very speciﬁc condi-
tions. In particular, we use static code analysis and symbolic
execution to ﬁrst identify checks that operate on sensitive
input, and to then extract their precise semantics (i.e., which
inputs are used, what operations were performed on these
inputs, and what values are they compared against). We then
use path predicate reconstruction, path predicate minimization,
and predicate classiﬁcation to identify interesting checks, and,
as a last step, the analysis performs inter-procedural control-
dependency analysis to determine whether a speciﬁc check
guards sensitive operations.
We propose to use trigger analysis for the identiﬁcation of
logic bombs. However, of course, not every trigger (according
to our deﬁnition) is part of a logic bomb. As a result, the
fact that an app contains a trigger is typically not enough to
outright convict an application as being malicious. However,
we show in our experiments that a detection system that ﬂags
all applications that contain an interesting trigger as malicious,
delivers excellent detection results for targeted malware, while
raising a very small number of false positives on benign apps
(outperforming existing malware detection systems that focus
on opportunistic malware). Our system also returns a series
of detailed information for each of the detected trigger, thus
going beyond the mere identiﬁcation of each of them. This
greatly simpliﬁes the work of a human analyst who has to
make the decision whether a trigger is acceptable or malicious.
Moreover, the output of our analysis can be also used as a
starting point to craft inputs for a dynamic analysis system to
exercise and vet the relevant behavior.
We have implemented our trigger analysis in a system called
TRIGGERSCOPE. Our analysis operates directly on Dalvik
bytecode, and it does not rely on access to source code. Our
current prototype handles a number of different program inputs
that have been traditionally used to activate malicious behav-
ior: time, location, and the content (and sender) of text mes-
sages (SMS). We have extensively evaluated TRIGGERSCOPE
over a large corpus of benign and malicious applications. Our
benign dataset is constituted by 9,582 Android applications
downloaded from the Google Play Store, while our malicious
dataset is constituted by several malicious apps that were either
developed by an independent DARPA Red Team organization
(developed with the aim of resembling state-sponsored mal-
ware) or real-world malware samples containing logic bombs,
including the HackingTeam’s RCSAndroid application.
Our experiments demonstrate the ability of our system to
precisely and efﬁciently detect triggered behavior in these
applications. In particular, TRIGGERSCOPE was able to au-
tomatically identify several interesting triggers, including two
previously-unknown backdoors in supposedly-benign apps,
and a variety of logic bombs in the malicious samples. TRIG-
GERSCOPE’s output also proved to be useful for constructing
proof-of-concepts that exercise the relevant behaviors. To
assess the precision of our tool, we performed manual analysis
(on more than 100 applications) and we compared our results
against the ground truth. TRIGGERSCOPE has a low false
positive rate of 0.38%, and we did not encounter any false
negative. Although we acknowledge that this evaluation does
not deﬁnitely exclude the possibility of false negatives in the
benign apps (see Section VI for a discussion about the limita-
tions of this work), we believe our results are an encouraging
step towards the detection of trigger-based behavior in Android
applications.
As the second part of our evaluation, we considered sev-
eral state-of-the-art Android malware detection tools, each
of which relies on a different approach. In particular, we
considered Kirin [31], which relies on permission-based signa-
tures, DroidAPIMiner [14], which relies on machine learning,
and FlowDroid [19], which relies on taint analysis. Our
experiments show that all these existing tools are not suitable
for the detection of logic bombs, as they either have a very
high false negative rate (78.57%) or a very high false positive
rate (69.23%). We show that TRIGGERSCOPE signiﬁcantly
outperforms them.
To summarize, this paper makes the following contributions:
• We make a ﬁrst step towards the automatic detection
of logic bombs in Android applications. To this end,
we introduce trigger analysis, a static program analysis
technique that discovers hidden triggers. Our analysis
combines both existing and novel analysis techniques:
symbolic execution (§III-A), block predicate extraction
(§III-B), path predicate reconstruction and minimiza-
tion (§III-C), predicate classiﬁcation (§III-D), and inter-
procedural control-dependency analysis (§III-E).
• We developed a prototype, called TRIGGERSCOPE, and
we evaluated it over a large corpus of benign and
malicious Android applications. Our experiments show
that TRIGGERSCOPE is able to efﬁciently and effec-