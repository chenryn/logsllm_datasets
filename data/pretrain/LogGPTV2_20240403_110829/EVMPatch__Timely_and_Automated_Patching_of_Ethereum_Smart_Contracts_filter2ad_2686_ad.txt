in Line 11 allowing the attacker to transfer a large amount of
tokens to an attacker-controlled account. Recently, similar vul-
nerabilities have been discovered in over 42,000 contracts [13].
We developed patch templates for detecting integer over-
ﬂows and underﬂows for the standard EVM integer width, i.e.,
unsigned 256 bit integers. For integer addition, subtraction,
and multiplication, these templates add checks inspired by
secure coding rules in the C programming language [34]
and the SafeMath [33] Solidity library. When a violation is
detected, EVMPATCH issues an exception to abort and roll
back the current call to the contract.
5.2.1 Evaluation Results
To verify the correctness of the patches generated by our
bytecode rewriter, we utilized the state-of-the-art integer
detection tool Osiris [13] for vulnerability detection. After
analyzing 50,535 unique contracts in the ﬁrst 5,000,000
blocks of the Ethereum blockchain, Osiris detects at least
one integer overﬂow vulnerability in 14,107 contracts. Using
EVMPATCH, we were able to successfully patch almost all of
these contracts automatically. More speciﬁcally, we could not
patch 33 contracts amongst the 14107 investigated contracts
because the basic block, where the detected vulnerability was
located is too small for the trampoline code.
From those 14107 contracts, around 8000 involve transac-
tions on the Ethereum network. To generate a large and repre-
sentative evaluation data set, we extracted all transactions sent
to these contracts up to block 7,755,100 (May 13 2019) from
the Ethereum blockchain resulting in 26,385,532 transactions.
Replaying those transactions with our patch tester shows
that for 95.5 % of all vulnerable contracts, EVMPATCH’s
generated patch was compliant to all of the prior transactions
associated with those contracts. For the remaining 4.5 % of
the investigated contracts, our patch rejected transactions for
one of the following reasons: (1) we successfully stopped a
malicious transaction, (2) the reported vulnerability was a
false positive and should not have been patched, or (3) we
unintentionally changed the contract’s functionality.
For close scrutiny, we selected ERC-20 token contracts
from those contracts that could be successfully patched by
EVMPATCH with conﬁrmed integer overﬂow/underﬂow
vulnerabilities that have been successfully attacked (see
Table 3). For comparison purposes, we also manually patch
these contracts on the Solidity source code level by replacing
the vulnerable arithmetic operations with functions adapted
from the SafeMath library [33]. The manually patched source
code is then compiled with the exact same Solidity compiler
version and optimization options used in the original contract
(as reported on etherscan.io).
We applied the EVMPATCH patch tester to the generated
patched contract versions and validated the reported outcome.
This allows us to verify whether both patching approaches
abort the same attack transactions. In addition, we can
compare the overhead in gas consumption and the increase
in code size. Note that in the manual patching method, we
do not patch all potential vulnerabilities detected by Osiris as
we skip adding checks on those arithmetic operations which
cannot be exploited by an attacker, i.e., vulnerable arithmetic
operations contained in functions that can only be called by the
controller or owner of the contract. We veriﬁed the correctness
of our patches using a total number of 506,607 real-world
transactions associated with the ERC-20 token contracts listed
in Table 3.
Table 3 shows the transaction execution results of the patch
tester. We veriﬁed the aborted transactions and conﬁrm that
all of them correspond to genuine attacks except for one
transaction7, which resembles a special case of token burning
that we discuss in detail below. Apart from the valid attack
transactions, the execution traces of the re-executed transac-
tions match those of the original transactions, conﬁrming that
our patch does not break the contract’s functionality.
Out of the transactions identiﬁed as attacks, we found one
particular transaction to the HXG token [17]. The transaction
does indeed trigger an integer overﬂow but the HXG token
rather burns some tokens by transferring them to a blackhole
address 0x0. The burned tokens cannot be recovered and
the balance of the blackhole address does not inﬂuence the
behavior of the contract. When analyzing the contract, Osiris is
not aware of the semantics of this blackhole address and reports
a possible integer overﬂow. EVMPATCH then conservatively
patches the integer overﬂow bugs reported by Osiris, which
leads to one legitimate transaction failing. We argue that this
pattern can be seen as bad coding practice as it wastes gas in
unnecessarily storing the balance of the blackhole address.
Gas Overhead. The additional code introduced by the patch-
ing may potentially cause transactions to fail with an out-of-gas
70x776da02ce8ce3cc882eb7f8104c31414f9fc756405745690bcf8df21e779e8a4
USENIX Association
30th USENIX Security Symposium    1299
Contract
CVE
# Patches
# Transactions
Total
Overhead (gas)
Code Size Increase (B)
SM
RW
BEC [2]
2018-10299
SMT [36] 2018-10376
UET [43]
2018-10468
SCA [37] 2018-10706
HXG [17] 2018-11239
1
1
55
1
9
424,229
56,555
24,034
292
1497
Attacks RW
83
47
225
47
120
1
1
12
10
5
SM
164
108
21
0
541
per Upgrade
Additional Cost RW (US$)
per TX
133 (1.1%) <0.01
97 (0.4%) <0.01
541 (7.6%) <0.01
361 (1.6%) <0.01
519 (14.6%) <0.01
0.01
0.01
0.071
0.189
0.057
117 (1.0%)
191 (0.8%)
1,299 (18.2%)
3,811 (17.3%)
997 (28.1%)
Table 3: ERC-20 Token contracts investigated in depth with their respective CVE number, the number of patches introduced by EVMPATCH,
and the number of transactions replayed by EVMPATCH’s patch tester and the number of attack transactions identiﬁed while testing the patches.
We also give the average amount of overhead in gas consumption over all replayed transactions and overhead of contract size of the manual
patched contracts (SM) and rewriter-generated patches (RW) and the overhead of the rewriter converted to US$ (with a gas price of 1 Gwei
and 235 US$/eth; For readability we only show the exact US$ ﬁgures only if they are more than one cent).
error. While the patches generally do not signiﬁcantly increase
gas consumption, such a behavior can nevertheless occur when
the sender of the transactions provides a very tight gas budget.
When the re-execution of a transaction with patched code fails
early due to an out-of-gas exception, we could not accurately
compare the behavior of the patched contract with the original
contract. To remedy this, we disabled the gas-accounting in
the EVM. We report the amount of additional gas consumption
during transaction execution in Table 3. We excluded those
transactions that do not execute functions which contain the
vulnerable code, because they are not affected by the patches
and therefore not relevant to our measurements.
Our results show that for contracts BEC, SMT, and HXG,
those patched with EVMPATCH incur less gas overhead
at runtime (83 gas, 47 gas and 120 gas) when compared to
those patched on the source code level (164 gas, 108 gas and
541 gas). This is due to the fact that the Solidity compiler gen-
erates non-optimal code when only very few checks are added.
In particular, Solidity utilizes internal function calls to invoke
the SafeMath integer overﬂow checks. While this reduces code
size (in case the check is needed at multiple places), it always
requires executing additional instructions—thereby increasing
gas overhead—to invoke and return from the internal function.
In contrast, EVMPATCH inlines the safe numeric operations
thereby introducing less gas overhead. One would need to
instruct the Solidity compiler to selectively enable function
inlining to yield similar gas costs as EVMPATCH.
Note that the average gas overhead is 0 gas for the manually
patched SCA token. This is because only one transaction
triggers the SafeMath integer overﬂow check. However, this
is an attack transaction and it is aborted early, making gas
overhead calculation not possible.
For UET and SCA, we identify higher gas overhead than for
the manually patched version. In fact, UET requires on average
255 units of additional gas for every transaction in the patched
version. In contrast, only 21 gas is added for manually patched
version. This is due to the fact that our bytecode rewriter
conservatively patches every potential vulnerability reported
by Osiris in these two contracts (12 and 10 respectively).
However, not all of them are actually exploitable and as such
we did not instrument them during manual patching.
Code Size Increase. Deploying contracts in the Ethereum
blockchain also incurs costs proportionally to the size
of the deployed contract. More speciﬁcally, Ethereum
charges 200 gas per byte to store the contract code on the
blockchain [44]. From Table 3, we recognize that the amount
of extra code added by our rewriter is comparable to that of
the SafeMath approach when a single vulnerability is patched.
Since our approach duplicates the original basic blocks, the
code size overhead depends on the speciﬁc location of the
vulnerability. In the case of the BEC token contract, our
rewriter increases the code size less than the source-level
patches. The Solidity compiler generates more code for
including the SafeMath library than is strictly necessary for the
patch. Even considering the overhead of bytecode rewriting,
we observe that EVMPATCH generates a smaller patch than
the manual patching method for this contract.
However, in case many vulnerabilities are patched,
EVMPATCH adds a slightly higher overhead. Naturally, the
size of the upgraded contracts increases with the number of
vulnerabilities to ﬁx due to inlining. For instance, our bytecode
rewriter generates 12 patches for UET contract and 10 patches
for SCA contract resulting in 1299 B (18.2%) and 3811 B
(17.3%) increase in code size. In the worst-case scenario in our
dataset, this increase in code size induces negligible additional
cost of US$0.18 per deployment.
Our patch templates are currently optimized for patching
a single vulnerable arithmetic. It is straightforward to adopt
an approach akin to Solidity’s internal function calls when
developing patch templates for our bytecode rewriter, which
would reduce the code size overhead when patching many
integer overﬂows.
EVMPATCH applies 3.9 patches on average to a contract in
our data set of 14,107 contracts. The average code size of the
original contracts is 8142.7 B (σ 5327.8 B). The average size
increase after applying patches with EVMPATCH is 455.9 B
(σ 333.5 B). This amounts to an average code size overhead of
5.6% after applying the patches. Given that Ethereum charges
1300    30th USENIX Security Symposium
USENIX Association
200 gas per byte to the contract creation transaction, it incurs
an average overhead of 91,180 gas or US$0.02 at the time of
writing. In the worst case that we observed, EVMPATCH incurs
an overhead of 199,800 gas at deployment, which at the time of
writing only amounts to about US$0.04 additional deployment
cost. This shows that the overhead of applying patches with
bytecode rewriting is negligible for contract deployment, espe-
cially when compared to the number of Ether possibly at stake.
Costs of Deployment. The deployment cost of a newly
patched contract dominates the costs of operating a smart
contract with EVMPATCH. However, additionally there is a
transaction needed to switch the address of the logic contract.
Since the proxy pattern requires no state migration, this trans-
action requires a constant amount of gas. The proxy contract
we utilize in EVMPATCH consumes 43.167 gas during a
switchover transaction, i.e., about US$0.01. Currently, state mi-
gration is the most viable contract upgrade strategy besides the
proxy pattern. Prior work estimated that even with only 5000
ERC-20 holders, i.e., smart contract users, state migration will
likely cost more than US$100.00 in the best case [41]. Hence,
compared to the cost of migrating all data to a new contract,
the EVMPATCH’s additional cost of US$0.01 is negligible.
Detecting Attacks. The patch tester of EVMPATCH allows
us to also identify any prior attack transactions. In Figure 6, we
additionally observe that while the vulnerabilities of the other
token contracts have been reported within a fairly reasonable
time after the ﬁrst attack, UET has been exploited (5 months)
long before the bug disclosure. More surprisingly, all contracts
are still fairly active though they encountered a decrease of
transaction volume after public disclosure of the vulnerabil-
ities. Despite the fact that all of these vulnerabilities have
been discovered around one year before the time of writing,
there are still 23,630 transactions (4.66 % of the evaluated
transactions) issued to these vulnerable contracts after the
public disclosure of the vulnerabilities, including successful
attacks. This means that the owners of those contracts did
not properly migrate to patched versions and users were not
properly notiﬁed of the vulnerable state of these contracts.
5.2.2 Analysis of False Positives/Negatives
During our analysis of the vulnerable contracts, we identiﬁed
false positives and false negatives caused by vulnerability
reporting of Osiris [13]. This demonstrates that our patch
testing is an important step in the process as many analysis
tools are imprecise. We found that in the default conﬁguration,
Osiris often achieves limited code coverage. To this end, we
utilized different timeout settings for both the whole analysis
and for queries to the SMT solver and combined the results
of multiple runs to achieve better code coverage. Furthermore,
we found that—contrary to the claims in the original Osiris
paper [13]—not all vulnerabilities are accurately detected by
Osiris in two particular cases.
Hexagon (HXG) Token. This contract is vulnerable to an
Figure 6: Activity timeline of each contract. The grey shadow
indicates the time window in which the vulnerabilities of these
contracts are disclosed by Peckshield [30], and the big hollow points
signify the occurrences of the attacks.
integer overﬂow, which allows an attacker to transfer very
large amounts of ERC-20 tokens [26]. Osiris reports two false
positives, which are caused by EVM code that is generated by
the Solidity compiler. Even though all types are unsigned types
in the Solidity source code, the compiler generates a signed
addition. Here, Osiris reports a possible integer overﬂow,
when −2 is added to the balanceOf mapping variable. When
performing signed integer additions with negative values, the
addition naturally overﬂows when the result moves from the
negative value range into the positive value range and vice
versa. As such, EVMPATCH patches a checked addition for
an unsigned arithmetic operation which will always overﬂow.
With our patch tester we observe all the failing transactions and
perform manual analysis of the patched contract’s bytecode
to determine that the root cause is an issue in the Solidity
compiler, i.e., the generated code requires an additional
instruction, when compared to a simple unsigned subtraction.
Social Chain (SCA). Our results also show a problem with
Osiris when analyzing the SCA token. While Osiris does
detect a possible overﬂow during multiplication in the
problematic Solidity source code line, it does not detect the
possible integer overﬂow for an addition in the same source
code line. However, in the actual attack transaction, the integer
overﬂow happens during the not-ﬂagged addition operation.
As such, this constitutes a false negative problem of Osiris.
Since the vulnerable addition is not reported by Osiris, it is
also not automatically patched by EVMPATCH. In contrast,
for the manually patched version we took both arithmetic
operations into account. The related attack transaction was
previously reported as an attack transaction [27].
Summary of Evaluation. To summarize, our evaluation on
integer overﬂow detection shows that EVMPATCH can cor-
rectly apply patches to smart contracts preventing any integer
overﬂow attack. Furthermore, EVMPATCH incurs only a
negligible gas overhead during deployment and runtime; espe-
cially compared to the Ether at stake. Our analysis shows that
USENIX Association
30th USENIX Security Symposium    1301
 1 10 100 1000 10000 10000007/1709/1711/1701/1803/1805/1807/1809/1811/1801/1903/1905/19#TransactionsDateBECSMTUETSCAHXGBEC attackSMT attackUET attackSCA attackHXG attackthe analyzed vulnerable smart contracts are still in active use,
even after being attacked and the vulnerabilities being publicly
disclosed. This motivates the need for a timely patching frame-
work such as EVMPATCH. Lastly, based on an extensive and
detailed analysis of 26,385,532 transactions, we demonstrate
that EVMPATCH always preserves the contract’s original
functionality except for a few cases, where the vulnerability re-
port (generated by the third-party tool Osiris) was not accurate
or bad coding practices were used (blackhole address).
5.3 Developer Study
Developer Background. To quantify the manual effort needed
to patch smart contracts and evaluate the usefulness of EVM-
PATCH we conducted a thorough study with 6 professional
developers with varying prior experience in using blockchain
technologies and developing smart contracts. Our developers
consider themselves familiar with blockchain technologies
but not very familiar with developing Solidity code. None of
the developers have developed an upgradable contract before.
As such, we can quantify the effort needed for a smart contract
developer to learn and apply an upgradable contract pattern.
Methodology. Throughout our study, we asked the developers
to perform multiple tasks manually that are performed
automatically by EVMPATCH: (1) manually patch three
contracts vulnerable due to integer overﬂow bugs given the
output of a static analyzer (OSIRIS [13]), (2) convert a contract
to an upgradable contract manually and with EVMPATCH, and
(3) patch an access control bug using EVMPATCH by writing a
custom patch-template. The three tasks cover different scenar-
ios, where EVMPATCH can be useful to a developer. The ﬁrst
two tasks cover the use of EVMPATCH to patch known bug
classes with minimal human intervention. For these two tasks