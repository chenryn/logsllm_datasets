size increases and run-time cost are dominated by com-
pression workload, which is unaffected by Capsicum.
We ﬁnd that the overhead of launching a sandboxed gzip
is 2.37 ± 0.01 ms, independent of the type of compres-
sion stream. For many workloads, this one-off perfor-
mance cost is negligible, or can be amortised by passing
multiple ﬁles to the same gzip invocation.
7 Future work
Capsicum provides an effective platform for capability
work on UNIX platforms. However, further research and
development are required to bring this project to fruition.
We believe further reﬁnement of the Capsicum prim-
itives would be useful. Performance could be improved
for sandbox creation, perhaps employing an Capsicum-
centric version of the S-thread primitive proposed by Bit-
tau. Further, a “logical application” OS construct might
Figure 15: Run time per gzip invocation against random
data, with varying ﬁle sizes; performance of the two ver-
sions come within 5% of one another at around a 512K.
 0.001 0.01 0.1 11B2B4B8B16B32B64B128B256B512B1K2K4K8k16K32K64K128K256K512K1M2M4M8M16MTime/gzip invocation (sec)File sizeCapabilities gzipStandard gzipimprove termination properties.
Another area for research is in integrating user in-
terfaces and OS security; Shapiro has proposed that
capability-centered window systems are a natural ex-
tension to capability operating systems. Improving the
mapping of application security constructs into OS sand-
boxes would also signiﬁcantly improve the security of
Chromium, which currently does not consistently assign
web security domains to sandboxes.
It is in the con-
text of windowing systems that we have found capability
delegation most valuable: by driving delegation with UI
behaviors, such as Powerboxes (ﬁle dialogues running
with ambient authority) and drag-and-drop, Capsicum
can support gesture-based access control research.
Finally,
it is clear that the single largest problem
with Capsicum and other privilege separation approaches
is programmability: converting local development into
de facto distributed development adds signiﬁcant com-
plexity to code authoring, debugging, and maintenance.
Likewise, aligning security separation with application
separation is a key challenge: how does the programmer
identify and implement compartmentalisations that offer
real security beneﬁts, and determine that they’ve done
so correctly? Further research in these areas is critical
if systems such as Capsicum are to be used to mitigate
security vulnerabilities through process-based compart-
mentalisation on a large scale.
8 Related work
In 1975, Saltzer and Schroeder documented a vocabulary
for operating system security based on on-going work
on MULTICS [19]. They described the concepts of ca-
pabilities and access control lists, and observed that in
practice, systems combine the two approaches in order
to offer a blend of control and performance. Thirty-ﬁve
years of research have explored these and other security
concepts, but the themes remain topical.
8.1 Discretionary and Mandatory Access
Control
The principle of discretionary access control (DAC) is
that users control protections on objects they own. While
DAC remains relevant in multi-user server environments,
the advent of personal computers and mobile phones has
revealed its weakness: on a single-user computer, all
eggs are in one basket. Section 5.1 demonstrates the dif-
ﬁculty of using DAC for malicious code containment.
Mandatory access control systemically enforce poli-
cies representing the interests of system implementers
and administrators.
Information ﬂow policies tag sub-
jects and objects in the system with conﬁdentiality
and integrity labels—ﬁxed rules prevent reads or writes
that allowing information leakage. Multi-Level Secu-
rity (MLS), formalised as Bell-LaPadula (BLP), protects
conﬁdential information from unauthorised release [3].
MLS’s logical dual, the Biba integrity policy, imple-
ments a similar scheme protecting integrity, and can be
used to protect Trusted Computing Bases (TCBs) [4].
MAC policies are robust against the problem of con-
fused deputies, authorised individuals or processes who
can be tricked into revealing conﬁdential information. In
practice, however, these policies are highly inﬂexible, re-
quiring administrative intervention to change, which pre-
cludes browsers creating isolated and ephemeral sand-
boxes “on demand” for each web site that is visited.
Type Enforcement (TE) in LOCK [20] and,
later,
SELinux [12] and SEBSD [25], offers greater ﬂexibil-
ity by allowing arbitrary labels to be assigned to sub-
jects (domains) and objects (types), and a set of rules
to control their interactions. As demonstrated in Sec-
tion 5.4, requiring administrative intervention and the
lack of a facility for ephemeral sandboxes limits appli-
cability for applications such as Chromium: policy, by
design, cannot be modiﬁed by users or software authors.
Extreme granularity of control is under-exploited, or per-
haps even discourages, highly granular protection—for
example, the Chromium SELinux policy conﬂates dif-
ferent sandboxes allowing undesirable interference.
8.2 Capability systems, micro-kernels, and
compartmentalisation
The development of capability systems has been tied to
mandatory access control since conception, as capabil-
ities were considered the primitive of choice for media-
tion in trusted systems. Neumann et al’s Provably Secure
Operating System (PSOS) [16], and successor LOCK,
propose a tight integration of the two models, with the
later reﬁnement that MAC allows revocation of capabili-
ties in order to enforce the *-property [20].
Despite experimental hardware such as Wilkes’ CAP
computer [28],
the eventual dominance of general-
purpose virtual memory as the nearest approximation
of hardware capabilities lead to exploration of object-
capability systems and micro-kernel design. Systems
such as Mach [2], and later L4 [11], epitomise this ap-
proach, exploring successively greater extraction of his-
toric kernel components into separate tasks. Trusted
operating system research built on this trend through
projects blending mandatory access control with micro-
kernels, such as Trusted Mach [6], DTMach [22] and
FLASK [24]. Micro-kernels have, however, been largely
rejected by commodity OS vendors in favour of higher-
performance monolithic kernels.
MAC has spread, without the beneﬁts of micro-kernel-
enforced reference monitors, to commodity UNIX sys-
tems in the form of SELinux [12]. Operating system ca-
pabilities, another key security element to micro-kernel
systems, have not seen wide deployment; however, re-
search has continued in the form of EROS [23] (now
CapROS), inspired by KEYKOS [9].
OpenSSH privilege separation [17] and Privman [10]
rekindled interest in micro-kernel-like compartmentali-
sation projects, such as the Chromium web browser [18]
and Capsicum’s logical applications. In fact, large ap-
plication suites compare formidably with the size and
complexity of monolithic kernels: the FreeBSD kernel is
composed of 3.8 million lines of C, whereas Chromium
and WebKit come to a total of 4.1 million lines of
C++. How best to decompose monolithic applications re-
mains an open research question; Bittau’s Wedge offers a
promising avenue of research in automated identiﬁcation
of software boundaries through dynamic analysis [5].
Seaborn and Hand have explored application com-
partmentalisation on UNIX through capability-centric
Plash [21], and Xen [15], respectively. Plash offers an
intriguing blend of UNIX semantics with capability se-
curity by providing POSIX APIs over capabilities, but
is forced to rely on the same weak UNIX primitives
analysed in Section 5. Supporting Plash on stronger
Capsicum foundations would offer greater application
compatibility to Capsicum users. Hand’s approach suf-
fers from similar issues to seccomp, in that the run-
time environment for sandboxes is functionality-poor.
Garﬁnkel’s Ostia [7] also considers a delegation-centric
approach, but focuses on providing sandboxing as an ex-
tension, rather than a core OS facility.
A ﬁnal branch of capability-centric research is capa-
bility programming languages. Java and the JVM have
offered a vision of capability-oriented programming: a
language run-time in which references and byte code ver-
iﬁcation don’t just provide implementation hiding, but
also allow application structure to be mapped directly to
protection policies [8]. More speciﬁc capability-oriented
efforts are E [13], the foundation for Capdesk and the
DARPA Browser [26], and Caja, a capability subset of
the JavaScript language [14].
9 Conclusion
We have described Capsicum, a practical capabilities ex-
tension to the POSIX API, and a prototype based on
FreeBSD, planned for inclusion in FreeBSD 9.0. Our
goal has been to address the needs of application au-
thors who are already experimenting with sandboxing,
but ﬁnd themselves building on sand when it comes to
effective containment techniques. We have discussed
our design choices, contrasting approaches from research
capability systems, as well as commodity access con-
trol and sandboxing technologies, but ultimately leading
to a new approach. Capsicum lends itself to adoption
by blending immediate security improvements to cur-
rent applications with the long-term prospects of a more
capability-oriented future. We illustrate this through
adaptations of widely-used applications, from the sim-
ple gzip to Google’s highly-complex Chromium web
browser, showing how ﬁrm OS foundations make the job
of application writers easier. Finally, security and perfor-
mance analyses show that improved security is not with-
out cost, but that the point we have selected on a spec-
trum of possible designs improves on the state of the art.
10 Acknowledgments
The authors wish to gratefully acknowledge our spon-
sors, including Google, Inc, the Rothermere Founda-
tion, and the Natural Sciences and Engineering Research
Council of Canada. We would further like to thank Mark
Seaborn, Andrew Moore, Joseph Bonneau, Saar Drimer,
Bjoern Zeeb, Andrew Lewis, Heradon Douglas, Steve
Bellovin, and our anonymous reviewers for helpful feed-
back on our APIs, prototype, and paper, and Sprewell for
his contributions to the Chromium FreeBSD port.
11 Availability
Capsicum, as well as our extensions to the Chromium
web browser are available under a BSD license; more
information may be found at:
http://www.cl.cam.ac.uk/research/security/capsicum/
A technical report with additional details is forthcoming.
References
[1] The Chromium Project:
Sandboxing Design.
developers/design-documents/sandbox/
osx-sandboxing-design.
Design Documents:
OS X
http://dev.chromium.org/
[2] ACETTA, M. J., BARON, R., BOLOWSKY, W., GOLUB, D.,
RASHID, R., TEVANIAN, A., AND YOUNG, M. Mach: a new
kernel foundation for unix development. In Proceedings of the
USENIX 1986 Summer Conference (July 1986), pp. 93–112.
[3] BELL, D. E., AND LAPADULA, L. J. Secure computer systems:
Mathematical foundations. Tech. Rep. 2547, MITRE Corp.,
March 1973.
[4] BIBA, K. J.
Integrity considerations for secure computer sys-
tems. Tech. rep., MITRE Corp., April 1977.
[5] BITTAU, A., MARCHENKO, P., HANDLEY, M., AND KARP, B.
Wedge: Splitting Applications into Reduced-Privilege Compart-
In Proceedings of the 5th USENIX Symposium on Net-
ments.
worked Systems Design and Implementation (2008), pp. 309–
322.
[6] BRANSTAD, M., AND LANDAUER, J. Assurance for the Trusted
Mach operating system. Computer Assurance, 1989. COMPASS
’89, ’Systems Integrity, Software Safety and Process Security’,
Proceedings of the Fourth Annual Conference on (1989), 103–
108.
[26] WAGNER, D., AND TRIBBLE, D.
A security analysis
architecture, March 2002.
the
combex darpabrowser
of
http://www.combex.com/papers/darpa-review/
security-review.pdf.
[27] WATSON, R., FELDMAN, B., MIGUS, A., AND VANCE, C. De-
sign and Implementation of the TrustedBSD MAC Framework.
In Proc. Third DARPA Information Survivability Conference and
Exhibition (DISCEX), IEEE (April 2003).
[28] WILKES, M. V., AND NEEDHAM, R. M. The Cambridge CAP
computer and its operating system (Operating and programming
systems series). Elsevier North-Holland, Inc., Amsterdam, The
Netherlands, 1979.
[7] GARFINKEL, T., PFA, B., AND ROSENBLUM, M. Ostia: A del-
egating architecture for secure system call interposition. In Proc.
Internet Society 2003 (2003).
[8] GONG, L., MUELLER, M., PRAFULLCHANDRA, H., AND
SCHEMERS, R. Going Beyond the Sandbox: An Overview of
the New Security Architecture in the Java Development Kit 1.2.
In Proceedings of the USENIX Symposium on Internet Technolo-
gies and Systems.
[9] HARDY, N. KeyKOS architecture. SIGOPS Operating Systems
Review 19, 4 (Oct 1985).
[10] KILPATRICK, D. Privman: A Library for Partitioning Applica-
tions. In Proceedings of USENIX Annual Technical Conference
(2003), pp. 273–284.
[11] LIEDTKE, J. On microkernel construction. In Proceedings of the
15th ACM Symposium on Operating System Principles (SOSP-
15) (Copper Mountain Resort, CO, Dec. 1995).
[12] LOSCOCCO, P., AND SMALLEY, S. Integrating ﬂexible support
for security policies into the Linux operating system. Proceedings
of the FREENIX Track: 2001 USENIX Annual Technical Confer-
ence table of contents (2001), 29–42.
[13] MILLER, M. S. The e language. http://www.erights.
org/.
[14] MILLER, M. S., SAMUEL, M., LAURIE, B., AWAD, I., AND
STAY, M. Caja: Safe active content in sanitized javascript,
May 2008. http://google-caja.googlecode.com/
files/caja-spec-2008-06-07.pdf.
[15] MURRAY, D. G., AND HAND, S. Privilege Separation Made
Easy. In Proceedings of the ACM SIGOPS European Workshop
on System Security (EUROSEC) (2008), pp. 40–46.
[16] NEUMANN, P. G., BOYER, R. S., GEIERTAG, R. J., LEVITT,
K. N., AND ROBINSON, L. A provably secure operating system:
The system, its applications, and proofs, second edition. Tech.
Rep. Report CSL-116, Computer Science Laboratory, SRI Inter-
national, May 1980.
[17] PROVOS, N., FRIEDL, M., AND HONEYMAN, P. Preventing
Privilege Escalation. In Proceedings of the 12th USENIX Security
Symposium (2003).
[18] REIS, C., AND GRIBBLE, S. D. Isolating web programs in mod-
In EuroSys ’09: Proceedings of the
ern browser architectures.
4th ACM European conference on Computer systems (New York,
NY, USA, 2009), ACM, pp. 219–232.
[19] SALTZER, J. H., AND SCHROEDER, M. D. The protection of in-
formation in computer systems. In Communications of the ACM
(July 1974), vol. 17.
[20] SAMI SAYDJARI, O. Lock: an historical perspective.
In Pro-
ceeedings of the 18th Annual Computer Security Applications
Conference (2002), IEEE Computer Society.
[21] SEABORN, M. Plash: tools for practical least privilege, 2010.
http://plash.beasts.org/.
[22] SEBES, E. J. Overview of the architecture of Distributed Trusted
Mach. Proceedings of the USENIX Mach Symposium: November
(1991), 20–22.
[23] SHAPIRO, J., SMITH, J., AND FARBER, D. EROS: a fast capa-
bility system. SOSP ’99: Proceedings of the seventeenth ACM
symposium on Operating systems principles (Dec 1999).
[24] SPENCER, R., SMALLEY, S., LOSCOCCO, P., HIBLER, M.,
ANDERSON, D., AND LEPREAU, J. The Flask Security Archi-
tecture: System Support for Diverse Security Policies. In Proc.
8th USENIX Security Symposium (August 1999).
[25] VANCE, C., AND WATSON, R. Security Enhanced BSD. Net-
work Associates Laboratories (2003).