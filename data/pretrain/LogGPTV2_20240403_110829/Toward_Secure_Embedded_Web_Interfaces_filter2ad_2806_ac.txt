(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
Table 3: Threats and corresponding security mechanisms
Server-side input ﬁltering. Even though ﬁltering or
whitelisting of user input can fail if implemented incor-
rectly [3, 2, 1], it is still very important to sanitize user
data before web pages are rendered with it. Input ﬁltering
can prevent scripting exploits as well as SQL injections.
When applied to data coming from other embedded ser-
vices, input ﬁltering can also prevent many XCS attacks.
CSP (Content Security Policy). Pages rendered by the
typical embedded web application have little need to con-
tact external web sites. Correspondingly our server is con-
ﬁgured to offer restrictive CSP [14] directives to browsers,
limiting the impact of any injected code in the page.
S-CSP (Server-side Content Security Policy). For
browsers that do not support CSP, we introduce Server-
side CSP. While rendering a particular site, the server
looks at the CSP directives present in the header (or the
policy-uri) and modiﬁes the HTML code accordingly. In-
stead of standard input ﬁltering, the changes are based on
the custom policies deﬁned by the administrator: such as
valid hosts for the different HTML elements, use of inline-
scripts, eval functionality usage and so on. Its novelty lies
in the fact that the resulting HTML page as received by
the browser automatically becomes CSP compliant. In
addition to ﬁltering, S-CSP can also support reporting of
CSP violations via ’report-uri’ directive which ordinarily
is not possible for incompatible browsers.
X-Frame-Options. Clickjacking is a serious emerging
threat which is best handled by preventing web site fram-
ing. Since embedded web applications are usually not
designed with mash-up scenarios in mind, setting the
option to DENY is a good default conﬁguration.
JavaScript frame-busting. Not all browsers support the
X-Frame-Options header, and therefore our framework
automatically includes frame-busting code in JavaScript.
The particular piece of code we use is as simple as possi-
ble and has been vetted for vulnerabilities typically found
in such implementations [44].
Random anti-CSRF token. Cross-site request forgery
is another web application attack which is easy to prevent,
but often not addressed in embedded settings. Our frame-
work automatically injects random challenge tokens in
links and forms pointing back at the web application, and
checks the tokens on page access [39].
Origin header veriﬁcation. Along with checking CSRF
tokens, we make sure that for requests that supply any
parameters (either POST or GET) and include the Ori-
gin [5] or Referer header, the origin/referer values are
as expected. We do this as a basic measure to prevent
cross-site attacks. When the Referer header is available,
we also check for cross-application attacks, making sure
that each application is only accessed through its entry
pages.
SSL. Securing network communications often ends up
being a low-priority item for application developers, and
this is why our web server uses HTTPS exclusively by
default, with a persistent self-signed certiﬁcate created
during device initialization.
8
HSTS (HTTP Strict Transport Security) and Secure
cookies. In addition to supporting SSL out of the box,
our server implements the HSTS standard [22] and re-
quests that all incoming connections be over SSL, which
prevents several passive and active network attacks [23].
Moreover, browser cookies are created with the Secure
attribute, preventing the browser from leaking them to the
network in plaintext.
Parametrized rendering and queries. Android already
supports parametrized SQLlite queries [52] and we en-
courage developers to make use of this facility. We have
also added the ability to parametrize dynamic HTML ren-
dering, in which case escaping of the output is performed
automatically.
URL scanning.
Incoming HTTP requests are sani-
tized by applying ﬁltering similar to that offered by the
URLScan tool in Microsoft IIS [34]. Our ﬁlter is conﬁg-
ured to restrict both the URL and query parts of a request,
while changes by the web application developer are al-
lowed if necessary. URLScan is most useful in preventing
web application vulnerabilities due to incorrect or incom-
plete parsing of request data.
Application-wide authentication, password policy,
and password anti-bruteforcing. Recognizing that user
authentication is often a weak spot for web applications,
we have implemented user authentication as part of the
web server, freeing the developers from the need to im-
plement secure user session tracking. In addition, the
password strength policy can be changed according to
requirements, and a mechanism to prevent (or severely
slow down) brute-force attacks is always enabled.
Network restrictions. Most embedded web servers have
a relatively constrained network access proﬁle: either the
device should serve requests only when connected to a
speciﬁc network or WiFi SSID, or the hosts requesting
service might match a proﬁle, such as a speciﬁc IP or
MAC address. This feature, while easily accessible, can
not be conﬁgured by default due to the differences in
individual application environments.
Location restrictions. Similar to network restrictions,
the server can be conﬁgured to operate only when the
device is at speciﬁc physical locations, minimizing the
opportunities for an attacker to access and potentially
compromise the system.
DDoS. While distributed denial-of-service (DDoS) pro-
tection is difﬁcult, we believe that much can be done to
mitigate such threats. For most applications, maintaining
local service is of top priority, and so we throttle HTTP
requests such that those coming from the local network
always have a guaranteed level of service. Of course, this
can not prevent lower-level network DDoS attacks: these
have to be taken care of separately, outside of the web
server.
7 User interface
This section brieﬂy describes the user interface required
for basic administration of the web server and security
policy management. In the following description, we refer
to the owner of the smart phone or embedded device as
the Admin user.
7.1 Conﬁguration management
Figure 4: Main web server conﬁguration interface.
This interface is used to control the server settings
across all the applications. As shown in Figure 4, it pro-
vides the ability to disable each web application. It also
displays the web server overall statistics such as the num-
ber of active application and the number of active connec-
tions session.
Web server logs. Accessible from the menu options,
the logged events such as failures, new connections and
conﬁguration changes can be visualized.
Settings. From this interface, the Admin overrides some
security features in order to enforce certain mechanisms
for all applications, irrespective of their individual conﬁg-
uration.
9
com.android.websms
1
1
1
1
Figure 6: Web server conﬁguration sample
ﬁeld is empty, the web server will enforce the restrictive
’allow self’ policy and block all other sources.
IP whitelist. The Admin user can explicitly allow access
for a speciﬁc set of trusted hosts by adding a comma-
separated list of IP addresses. For a new connection re-
quest, if the source IP is in this list then access is permitted
regardless of the restrictions described above.
7.3 Conﬁguration without the UI
For embedded devices without a display to access the
conﬁguration interface, the web server can be conﬁgured
through an XML ﬁle present in the application package
as a raw resource. With this ﬁle, the web server adminis-
trator can enforce security mechanisms for speciﬁc web
applications or disable all web application that do not
respect some requirements. The web server conﬁgura-
tion can also be done after installation by modifying the
SQLite database on the device.
8
Implementation
In this section we describe how our system is imple-
mented and how Android applications interact with
it. Our system consists of two main components: the
Dispatcher (a web server that processes and routes
requests to applications) and our framework API that
Android applications can access.
The Dispatcher works as an Android background
service. As a starting block we used the Tornado
open-source web server that we hardened and mod-
iﬁed to work with our framework. The web server
follows the least privilege principle, and runs with
the minimal permissions set needed to handle HTTP
android.permission.INTERNET.
communications:
To be allowed to expose a web interface, an appli-
cation requests a new permission that we created
com.android.webserver.WEB APPLICATION.
called
This novel permission is more restrictive than an-
droid.permission.INTERNET and only allows
the
Figure 5: Web application conﬁguration interface, al-
lowing per-application customizations (secure settings
highlighted in green).
7.2 Conﬁguration per web application
This interface enables the Admin user to control some
web application parameters such as the port number, the
application name, and its password or tune the security
policy for every application. As shown in Figure 5, it dis-
plays the name, path, security level and status information
along with the currently enabled security mechanisms.
Since all the mechanisms are turned on by default, policy
administration is not strictly necessary. However, this
allows ﬂexibility in the framework that can be useful in
special circumstances. For instance, the Admin user may
wish to disable the heavy S-CSP mechanism in the case
of a restricted set of trusted users. The different function-
alities provided by the interface are described below.
Alarm system conﬁguration. Each new client connec-
tion request can be monitored by setting the alarm noti-
ﬁcation level to one of the three possibilities: Disabled,
Passive, or Approval. Both Passive and Approval notiﬁ-
cations alert the administrator about the new connection.
Approval mode has the additional feature of requiring the
Admin user to grant access before proceeding.
Network and location restriction. The web server can
restrict clients connecting based on the network properties
(serving WiFi or 3G only for example) or based on the
current location such as home or ofﬁce.
Domain whitelist. The Admin can deﬁne a list of do-
mains that are allowed in the CSP policy by writing a
comma separated list of domains/IP addresses. If this
10
mountWebContent("websms",
Home.class);
mountWebContent("websms/send",
mountWebContent("websms/view",
SendSMS.class);
SMSHistory.class);
mountWebContent("websms/theme.css",
RawRessource.class,
RawRessource.CSS,
R.raw.hello);
Figure 7: WebSMS code used to declare the exposed web
interface.
application to serve web requests via the dispatcher.
At launch time the Dispatcher browses the list of in-
stalled applications for new ones requesting the web ap-
plication permission. By retrieving the ContentProvider
associated to the framework, it queries the security con-
ﬁguration. Following the consent as permission principle
we prompt the user every time a new web application
wants to register. When an application set the same URL
path than another one, the registration is discarded and a
possible malicious application warning is displayed to the
user.
The framework API is a Java library that handles com-
munications between the web server and the web appli-
cation (which run as separate processes). It also provides
a set of classes that help generating web content. Simi-
larly to many modern web framework (i.e. Rails), every
web page need to registered it web path through a func-
tion call, in our case this function is mountWebContent.
This function bind a path to a java class entry point. For
example our WebSMS web application register 4 web
pages: 3 HTML pages and 1 CSS stylesheet (Figure
7). Note the use of the RawRessource.class which al-
lows developer to expose directly raw data to the web
such as CCS ﬁles. Our framework provides a set of
classes to help building HTML pages, or handling other
resources request such as pictures, CSS stylesheets or
JavaScript libraries. The java classes Home, SendSMS
and SMSHistory extends the framework class HTML-
Page which provides various methods to add dynamic
content to the pages. In particular the HTMLPage class
has the method appendHTMLContent(content,
String[] vars) that allows to programmatically ap-
pend content to the page. Text variables are represented
by $ which are substituted by the corresponding var string
after it is ﬁltered to prevent XSS. While the authors can
bypass the ﬁltering process if they want by default it is
in place. Similarly, the HTMLPage class ensures that
the data passed to the application is properly sanitized
and that parametrized SQL queries are used in order to
prevent SQL injection.
When an HTTP request is received, it goes through all
pre-processing security mechanisms and is dispatched to
the corresponding web application. The framework API
embeds an Android ContentProvider used by the web
server to query pages. HTTP headers, body and security
tokens are added to the query and then transmitted to the
web application. Using the framework API, the web page
is build and send back as answer to the query. This one is
ﬁnally checked by all post-process security mechanisms
and send back to the web client.
9 Case Studies
In this section we present two case studies that demon-
strate how our framework effectively mitigates web
vulnerabilities. We describe the applications we built,
their attack surface, how the framework protects them,
and ﬁnally show that when using off-the-shelf security
scanners the framework is indeed able to mitigate the
vulnerabilities found in the apps.
To study the effectiveness of our the system we built
two sample applications that take advantages of the
phone’s capabilities to provide useful services: the ﬁrst
one, WebSMS, is used for reading and sending SMS from
the browser; the second one, WebMedia, provides a con-
venient web interface to browse and display the photos
and videos stored on the smartphone. We argue that these
two applications—while limited—are good case studies
of what developers might want to built in order to leverage
a device’s capabilities in the form of web applications.
9.1 Applications
WebSMS. When loaded in a client browser, the user can
choose to view the current SMS inbox or send a new one.
For the second choice, the application displays a list of
contacts fetched from the phone’s directory along with a
search box. Clicking on a particular contact allows to send
a SMS directly from the browser. The SMS content is
sent by the browser to the application via a POST request
that contains the contact ID.
WebMedia. This application displays a gallery of photos
and videos stored on the Android device (Figure 8). When
a thumbnail is clicked, a full size view of the media ﬁle
is displayed. The application provides a convenient way
to display photos and videos to friends and family on a
big screen. In addition, this application enables seamless
sharing of content with trusted users (friends or family).
11
Figure 9: Average number of request per second with and
without security features enabled.
This limited experiment shows that our framework can
help effectively and transparently mitigate vulnerabilities
that may exist in embedded web interfaces even though
it can not completely replace good coding practices and
careful code review.
9.4 Performance evaluation
While as stated earlier performance should not be the
focus of a mobile web framework, we still ran a basic
performance evaluation using the Apache benchmark
tool to evaluate the impact of enabling security features
on WebDroid performance. To reﬂect as accurately as
possible real world usage, we ran these benchmarks over
WiFi with WebDroid on a standard HTC Desire phone
with Android 2.3. We were not able to test over 3G as IP
are not routable.
WebDroid performance in term of requests per second
for the WebSMS application when the number of simul-
taneous connections increase is reported in ﬁgure 9. The
ﬁgure 10 depicts how fast WebDroid is able to process
each request as the number of simultaneous connections
increase. As visible in the diagrams, WebDroid take be-
tween a 10% to 30% performance hits when the security
features are turned one depending on the number of simul-
taneous connections. On average WebDroid performance
take a 20% hit when the security features are enabled.
While this performance hit might not be acceptable for a