Furthermore, 57 out of the 90 candidates were part of
Linux drivers and among them, 22 were size checking re-
lated, 9 were type selection related and 19 were shallow
copy related.
Table 1: Basic Double Fetch Analysis Results
Category
Size Checking
Type Selection
Shallow Copy
Other
Total
True Bugs
Occurrences
30
11
31
18
90
5
In Drivers
73%
82%
61%
39%
63%
80%
33% 22
12%
9
34% 19
20%
7
100% 57
4
6%
Kernel
Reported
Table 2: Reﬁned Double-Fetch Bug Detection Results
Type
Sel.
6
6
3
Linux 4.5
Android 6.0.1
FreeBSD
Total
Files
39,906
35,313
32,830
True
Bugs
5
3
0
Files
53
48
16
Size
Check.
23
18
8
Most importantly, we found ﬁve previously unknown
double-fetch bugs which include four size checking sce-
narios and one shallow copy scenario which also be-
longs to the size checking scenario. Three of them are
exploitable vulnerabilities. The ﬁve bugs have been re-
ported and they all have been conﬁrmed by the develop-
ers and have meanwhile been ﬁxed. From the statistical
result, we can observe the following:
1. 57 out of 90 (63%) of the candidates were driver
related and 22 out of 30 (73%) of the size checking
cases, 9 out of 11 (82%) of the type selection cases
and 19 out of 31 (61%) of the shallow copy cases
occur in drivers.
2. 4 out of 5 (80%) of the double-fetch bugs we found
inside drivers and belong to the size checking cate-
gory.
Overall, this leads to the conclusion that most double
fetches do not cause double-fetch bugs and that double
fetches are more likely to occur in drivers. However, as
soon as a double fetch is due to size checking, developers
have to be careful: Four out of 22 size checking scenarios
in drivers turned out to be double-fetch bugs.
4.2 Analysis of Three Open Source Kernels
Based on the double fetch basic pattern matching and
manual analysis, we reﬁned our double fetch pattern
and developed a new double-fetch bug detection analysis
based on the Coccinelle engine. In order to fully evalu-
ate our approach, we analyzed three popular open source
kernels, namely Linux, Android, and FreeBSD. Results
are shown in Table 2.
10    26th USENIX Security Symposium
USENIX Association
For the Linux kernel, the experiment was conducted
on version 4.5, which was the newest version when the
experiment was conducted. The analysis took about 10
minutes and reported 53 candidate ﬁles. An investigation
of the 53 candidates revealed ﬁve true double-fetch bugs,
which were also found by the previous manual analysis.
Among the reported ﬁles, 23 were size checking related,
and 6 were type selection related.
For Android, even though it uses Linux as its ker-
nel as well, we analyzed version 6.0.1 which is based
on Linux 3.18. There are still diﬀerences between the
Android kernel and original Linux kernel: A kernel for
Android is a mainstream Linux kernel, with additional
drivers for the speciﬁc Android device, and other ad-
ditional functionality, such as enhanced power manage-
ment or faster graphics support. Our analysis took about
9 minutes and reported 48 candidate ﬁles,
including
seven ﬁles that were not included in the original Linux
kernel reports. Among the reported candidates, three
were true double-fetch bugs, including two that were
shared with the Linux 4.5 report above, and one that was
only reported for Android. Among the results, 18 candi-
dates were size checking related, and six candidates were
type selection related.
For FreeBSD, we needed to change the transfer func-
tions copy_from_user() and __copy_from_user()
to the corresponding ones in FreeBSD, copyin() and
copyin_nofault(). We obtained the source code from
the master branch3. This analysis took about 2 minutes
and only 16 ﬁles were reported, but none of them turned
out to be a vulnerable double-fetch bug. Among the re-
ported candidates, eight were size checking related, and
three were type selection related. It is interesting to note
that 5 out of these 16 ﬁles were benign double fetches,
which would have been double-fetch bugs but were pre-
vented by additional checking schemes. The develop-
ers of FreeBSD seem to be more aware of double-fetch
bugs and try to actively prevent them.
In comparison,
for Linux, only 5 out of the 53 reports were protected by
additional checking schemes.
In this experiment, we only counted the size check-
ing and type selection cases because the reﬁned pattern
matching approach discards shallow copy cases that are
not able to cause a double-fetch bug. Our approach
matches the double fetch pattern that fetches data from
the same memory region, which ignores the ﬁrst buﬀer
fetches in the case of a shallow copy and only considers
multiple fetches to the same second buﬀer. Such shallow
copy cases usually combine with other scenarios such as
size checking and type selection.
In Table 2, the size
checking cases of the Linux kernel also includes one case
that occurred in a shallow copy scenario.
3From GitHub as of July 2016 (https://github.com/freebsd/freebsd)
5 Discussion
In this section, we discuss the discovered double-fetch
bugs and vulnerabilities in Linux 4.5 and how double-
fetch bugs can be prevented in the presence of double-
fetch situations. We also interpret our ﬁndings and the
limitations of our approach.
5.1 Detected Bugs and Vulnerabilities
Based on our approach, we found six double-fetch bugs
in total. Five of them are previously unknown bugs that
have not been reported before (CVE-2016-5728, -6130, -
6136, -6156, -6480), and the sixth one (CVE-2015-1420)
is a double-fetch bug present in the newest Android (ver-
sion 6.0.1) which is based on an older Linux kernel (ver-
sion 3.18) containing the bug, which has been ﬁxed in
the mainline Linux kernel since Linux 4.1. Three of the
ﬁve new bugs are exploitable double-fetch vulnerabili-
ties (CVE-2016-5728, -6136, -6480). Four of the ﬁve
are in drivers (CVE-2016-5728, -6130, -6156, -6480).
All bugs have been reported to the Linux kernel main-
tainers who have conﬁrmed them. All of these reported
bugs are ﬁxed as of Linux 4.8. We did not ﬁnd any new
double-fetch bugs in FreeBSD. Details on the detected
bugs are shown in Table 3.
The presented approach identiﬁes a large number of
double-fetch situations for which only a small number
are double-fetch bugs (or even vulnerabilities). How-
ever, even though the cases we call benign double-fetch
situations are not currently faulty, they could easily turn
into a double-fetch bug or vulnerability when the code is
updated without paying special attention to the double-
fetch situation. We observed an occurrence of such
a situation when investigating the patch history of the
double-fetch bug CVE-2016-5728. A reuse of the sec-
ond fetched value was introduced when the developer
moved functionality from the MIC host driver into the
Virtio Over PCIe (VOP) driver, therefore introducing a
double-fetch bug. A major part of our future work will
be preventing such benign double fetch situations from
turning into harmful ones.
We did not ﬁnd any false negatives while manually
checking random samples of Linux kernel source code
ﬁles.
5.2 Comparison
Only a few systematic studies have been conducted on
double fetches. Bochspwn [14, 13] is the only approach
similar enough to warrant a comparison with. An anal-
ysis of Linux 3.5.0 with Bochspwn did not ﬁnd any
double-fetch bug, while producing up to 200KB of dou-
ble fetch logs. In the same kernel, our approach identi-
USENIX Association
26th USENIX Security Symposium    11
Table 3: Description of Identiﬁed Double Fetch Bugs and Vulnerabilities (*)
IDs
CVE-
2016-
5728*
CVE-
2016-
6130
CVE-
2016-
6136*
CVE-
2016-
6156
CVE-
2016-
6480*
CVE-
2015-
1420*
File
mic_virtio.c
MIC architecture VOP
(Virtual I/O Over PCIe)
driver
Linux 4.5
sclp_ctl.c
IBM S/390 SCLP console
driver
Linux 4.5
auditsc.c
Linux auditing subsystem
Linux 4.5
cros_ec_dev.c
Chrome OS Embedded
Controller driver
Linux 4.5
commctrl.c
Adaptec RAID controller
driver
Linux 4.5
fhandle.c
File System
Android 6.0.1, (Linux 3.18)
Description
Race condition in the vop_ioctl function allows local users to obtain sensitive
information from kernel memory or cause a denial of service (memory cor-
ruption and system crash) by changing a certain header, aka a “double fetch”
vulnerability.
Belongs to the size checking scenario.
Race condition in the sclp_ctl_ioctl_sccb function allows local users to
obtain sensitive information from kernel memory by changing a certain length
value, aka a “double fetch” vulnerability.
Belongs to the size checking scenario.
Race condition in the audit_log_single_ execve_arg function allows local
users to bypass intended character-set restrictions or disrupt system-call audit-
ing by changing a certain string, aka a “double fetch” vulnerability.
Race condition in the ec_device_ioctl_xcmd function allows local users to
cause a denial of service (out-of-bounds array access) by changing a certain size
value, aka a “double fetch” vulnerability.
Belongs to the size checking scenario.
Race condition in the ioctl_send_fib function allows local users to cause a
denial of service (out-of-bounds access or system crash) by changing a certain
size value, aka a “double fetch” vulnerability.
Belongs to the size checking scenario.
Race condition in the handle_to_path function allows local users to cause a
denial of service (out-of-bounds array access) by changing a certain size value,
aka a “double fetch” vulnerability.
Belongs to the size checking scenario.
ﬁed 3 out of the above discussed 6 double-fetch bugs (the
other 3 bugs we found are in ﬁles that were not present
in Linux 3.5.0).
It is likely that Bochspwn could not ﬁnd these bugs
because they were present in drivers. Indeed, dynamic
approaches cannot support drivers without correspond-
ing hardware or simulations of hardware. Bochspwn re-
ported an instruction coverage of only 28% for the ker-
nel, while our approach statically analyses the complete
source code.
As for eﬃciency, our approach takes only a few min-
utes to conduct a path-sensitive exploration of the source
code of the whole Linux kernel. In contrast, Bochspwn
introduces a severe runtime overhead. For instance, their
simulator needs 15 hours to boot the Windows kernel.
While it only took a few days to investigate the 90
double-fetch situations, Jurczyk and Coldwind did not
report the time they needed to investigate the 200KB of
double fetch logs generated by their simulator.
5.3 Double-Fetch Bug Prevention
Even though we provide an analysis to detect double-
fetch bugs, developers must still be aware of how they
occur and preemptively prevent double-fetch bugs. Hu-
man mistakes are to be expected in driver development
when dealing with variable messages leading to new
double-fetch situations.
(1) Don’t Copy the Header Twice. Double-fetch situa-
tions can be completely avoided if the second fetch only
copies the message body and not the complete message
which copies the header a second time. For example, the
double-fetch vulnerability in Android 6.0.1 (Linux 3.18)
is resolved in Linux 4.1 by only copying the body in the
second fetch.
(2) Use the Same Value. A double-fetch situation turns
into a bug when there is a use of the “same” data from
both fetch operations because a (malicious) user can
change the data between the two fetches.
If develop-
ers only use the data from one of the fetches, problems
are avoided. According to our investigation, most of the
double-fetch situations are benign because they only use
the ﬁrst fetched value.
12    26th USENIX Security Symposium
USENIX Association
(3) Overwrite Data. There are also situations in which
the data has to be fetched and used twice, for exam-
ple, the complete message is passed to a diﬀerent func-
tion for processing. One way to resolve the situation
and eliminate the double-fetch bug is to overwrite the
header from the second fetch with the header that has
been fetched ﬁrst. Even if a malicious user changed
the header between the two fetches, the change would
have no impact. This approach is widely adopted in
FreeBSD code, such as in sys/dev/aac/aac.c and
sys/dev/aacraid/aacraid.c.
(4) Compare Data. Another way to resolve a double-
fetch bug is to compare the data from the ﬁrst fetch to
the data of the second fetch before using it. If the data is
not the same, the operation must be aborted.
(5) Synchronize Fetches. The last way to prevent a
double-fetch bug is to use synchronization approaches
to guarantee the atomicity of two inseparable operations,
such as locks or critical sections. As long as we guaran-
tee that the fetched value cannot be changed between the
two fetches, then nothing wrong will come out of fetch-
ing multiple times. However, this approach will incur
performance penalties for the kernel, as synchronization
is introduced on a critical section.
Since the Compare Data approach does not need to
modify very much of the source code, most of the identi-
ﬁed double-fetch bugs we found have been patched in
this way by the Linux developers (CVE-2016-5728, -
6130, -6156, -6480). If the overlapped data sections from
the two fetches are not the same, the kernel will now re-
turn an error. One can argue that it would have been
better to avoid the double fetch of the headers with any
of the other ﬁrst three recommendations. However, com-
paring the data has two advantages: it not only allow de-
tecting attacks by malicious users but also protects from
situation in which the data is changed without malicious
intent (e.g., by some bug in user space code).
We have implemented the Compare Data approach
in Coccinelle as an automatic patch that injects code to
compare the data from the ﬁrst fetch with the data from
the second fetch at places where a double-fetch bug has
been found.
It is able to automatically patch all size
checking double-fetch bugs, which accounts for most of