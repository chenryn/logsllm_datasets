Pr
≈λ 0.
(R, auxR) ← RGen(1λ),
(crs, tc, ζ) ← KGencrs(R, auxR), ωZ ←$ RND(Z),
(crsup, ζup, auxZ) ← Z(crs,{ζi}i=n
i=1 , ωZ),
if Vcrs(crsup, ζup) = 0 then return 0,
ωA ←$ RND(A),
(x, π) ← AO(·)(R, auxR, crsup, auxZ; ωA),
w ← ExtA(R, auxR, crsup, auxZ; ωA) :
(x, π) (cid:54)∈ Q ∧ (x, w) (cid:54)∈ R ∧
V(R, auxR, crsup, x, π) = 1
Here RND(Z) = RND(A) and {ζi}i=n
i=1 for n ∈ N is a number proofs for
the correctness of the updating procedure. The oracle O(.) represents two
oracles O1(.) and O2(.) which return π := Sim(R, auxR, crs, tc, x) and π :=
Sim(R, auxR, crsup, tcup, x) respectively. O(.) keeps track of all queried (x, π)
via Q. Note that Z can also ﬁrst generate crs and then an honest updater
updates it and outputs crsup. In the latter case, O(.) = O2(.). The elements
{ζi}i=n
i=1 of the input of Z may be empty when all updating (but one which is
honestly computed) are done by Z.
X-Zero-knowledge. For X = trusted, Π is statistically unbounded ZK for
RGen [Gro06], if for all (R, auxR) ∈ im(RGen(1λ)), and all computationally
unbounded A, εunb
εunb
Here, oracle O0(x, w) returns ⊥ (reject) if (x, w) (cid:54)∈ R, and otherwise it returns
P(R, auxR, crs, x, w). Similarly, O1(x, w) returns ⊥ (reject) if (x, w) (cid:54)∈ R, and
otherwise it returns Sim(R, auxR, crs, tc, x). Π is perfectly unbounded ZK
for RGen if we require εunb
For X ∈ {subverted, updatable}, Π is statistically unbounded X-ZK for
RGen [ABLZ17, Fuc18, GKM+18], if for any PPT Z there exists a PPT
ExtZ, such that for all (R, auxR) ∈ im(RGen(1λ)), and computationally un-
bounded A, εunb
b = Pr(cid:2)(crs, tc, ζ) ← KGencrs(R, auxR) : AOb(·,·)(R, auxR, crs) = 1
0 ≈λ εunb
0 = εunb
, where
(cid:3).
.
1
, where
0 ≈λ εunb
ωZ ←$ RND(Z), (crs, ζ, auxZ) ← Z(R, auxR; ωZ),
εunb
b = Pr
tc ← ExtZ(R, auxR; ωZ) :
Vcrs(R, auxR, crs, ζ) = 1 ∧ AOb(·,·)(R, auxR, crs, tc, auxZ) = 1
Here RND(Z) = RND(A), the oracle O0(x, w) returns ⊥ (reject) if (x, w) (cid:54)∈ R,
and otherwise it returns P(R, auxR, crs, x, w). Similarly, O1(x, w) returns ⊥
(reject) if (x, w) (cid:54)∈ R, and otherwise it returns Sim(R, auxR, crs, tc, x). Π is
perfectly unbounded X-ZK for RGen if one requires that εunb
.
.
0 = εunb
1
1
1
9
In all of the above properties, auxR can be seen as a common auxiliary input to
algorithm A that is generated by using a benign [BCPR14] relation generator; we
recall that we just think of auxR as being the description of a bilinear group.
We note that strong simulation-sound extractability in this work (for consis-
tentency with [KZM+15]) is often called simulation-sound extractability (e.g.,
in [DS19] which will be the basis for the Lamassu framework). For complete-
ness, quadratic arithmetic programs and rank 1 constraint systems are discussed
in Appendix A.3
2.2 Key-Homomorphic Signatures
We recall relevant parts of the deﬁnitional framework of key-homomorphic sig-
natures as introduced in [DS19]. Therefore, let Σ = (KGen, Sign, Verify) be a
signature scheme (cf. Appendix A.5) and the secret and public key elements live
in groups (H, +) and (E,·), respectively. For these two groups it is required that
group operations, inversions, membership testing as well as sampling from the
uniform distribution are eﬃcient.
(cid:48)
(cid:48)
Deﬁnition 3 (Secret Key to Public Key Homomorphism). A signature
scheme Σ provides a secret key to public key homomorphism, if there exists an
eﬃciently computable map µ : H → E such that for all sk, sk
(cid:48) ∈ H it holds that
), and for all (sk, pk) ← KGen, it holds that pk = µ(sk).
µ(sk + sk
In the discrete logarithm setting, it is usually the case sk ← Zp and pk = gsk
with g being the generator of some group G of prime order p, e.g., for ECDSA
or Schnorr signatures (cf. [DS19]).
) = µ(sk)· µ(sk
Deﬁnition 4 (Key-Homomorphic Signatures). A signature scheme is called
key-homomorphic, if it provides a secret key to public key homomorphism and
an additional PPT algorithm Adapt, deﬁned as:
Adapt(pk, m, σ, ∆) : Given a public key pk, a message m, a signature σ, and a
shift amount ∆ outputs a public key pk
(cid:48) and a signature σ(cid:48),
such that for all ∆ ∈ H and all (pk, sk) ← KGen(1λ), all messages m ∈ M and
all σ ← Sign(sk, m) and (pk
(cid:48)
(cid:48)
Pr[Verify(pk
, σ(cid:48)) ← Adapt(pk, m, σ, ∆) it holds that
, m, σ(cid:48)) = 1] = 1 ∧ pk
(cid:48)
= µ(∆) · pk.
The following notion covers whether adapted signatures look like freshly gen-
erated signatures, where we do not need the strongest notion in [DS19], which
requires this to hold even if the initial signature used in Adapt is known.
Deﬁnition 5 (Adaptability of Signatures). A key-homomorphic signature
scheme provides adaptability of signatures, if for every λ ∈ N and every message
m ∈ M, it holds that
[(sk, pk), Adapt(pk, m, Sign(sk, m), ∆)],
10
where (sk, pk) ← KGen(1λ), ∆ ← H, and
[(sk, µ(sk)), (µ(sk) · µ(∆), Sign(sk + ∆, m)))],
where sk ← H, ∆ ← H, are identically distributed.
For illustration purposes we will use the Schnorr signature scheme [Sch90], which
is very popular in the blockchain and distributed ledger domain, and whose
adaption notion we discuss in Appendix A.6.
2.3 The C∅C∅ Framework
Kosba et al. [KZM+15] proposed lifting transformations for SNARKs in three
diﬀerent versions basic, improved lifting, and the strengthened lifting. We only
consider the strongest version which lifts a SNARK to a strongly simulation
extractable (SE) SNARK. In particular, their construction, which we recall in
Fig. 1, transforms any NIZK Π to one that satisﬁes SE. Given a language L with
NP relation RL, let L(cid:48) be s.t. {(x, c, µ, pkOT, pke, ρ), (w, r1, r0, s0)} ∈ RL(cid:48) iﬀ:
c = Ω.Enc(pke, w; r1)∧ ((x, w) ∈ RL ∨
(µ = fs0(pkOT) ∧ ρ = Commit(s0; r0))) ,
(1)
where pke is the public key of a public key encryption scheme Ω (cf. Ap-
pendix A.4) and pkOT is the veriﬁcation key of a strong OTS scheme ΣOT (cf. Ap-
pendix A.5). Note that extraction is deﬁned here with respect to a black-box ex-
tractor (i.e., decrypting c to obtain the witness w), which Kosba et al. [KZM+15]
do to support UC-security. If this is not required, as in our case, then one can
use the non black-box extractor of the underlying SNARK and simplify the lan-
guage L(cid:48) by removing the part in the gray box , which we will do subsequently
(cf. [Bag19] for a formal treatment). In this case, C∅C∅ retains subversion resis-
tance of the underlying SNARK.
3 Lifting Transformations for SE (Subversion/Updatable)
SNARKs
In this section, we ﬁrst revisit the C∅C∅ framework and then present a diﬀerent
novel transformation which we call Lamassu.
3.1 Revisiting the C∅C∅ Framework
We will now revisit the most eﬃcient version of the C∅C∅ framework based
on a commitment and PRF evaluation (Equation (1) without the gray box ).
Kosba et al. [KZM+15] proposed to instantiate the commitment and the PRF
using hash functions, and in particular SHA-256. Similarly, the commitment is
instantiated as a hash commitment using the same hash function. With the de-
velopment of SNARK/STARK-friendly primitives soon after the introduction of
11
KGencrs(R, auxR)
- Π.crs ← Π.KGen(R, auxR); (pke, ske) ← Ω.KGen(1λ);
- tc := (s0, r0) ←${0, 1}λ; ρ ← Commit(s0; r0);
- return (crs := (Π.crs, pke, ρ), tcext := ske)
P(crs, x, w)
- (pkOT, skOT) ← ΣOT.KGen(1λ); r1, z0, z1, z2 ←${0, 1}λ;
- c = Ω.Enc(pke, w; r1); µ ← z0;
- πΠ ← Π.P(Π.crs, (x, c, pke, pkOT, µ, ρ), (w, r1, z1, z2));
- σOT ← ΣOT.Sign(skOT, (x, c, µ, πΠ));
- return π := (c, µ, πΠ, pkOT, σOT);
V(crs, x, π)
- if ΣOT.Verify(pkOT, (x, c, µ, πΠ, σOT)) = 0
- ∨ Π.V(Π.crs, x, c, µ, pke, pkOT, ρ, πΠ) = 0
- then return 0 else return 1;
Sim(crs, x, tc)
- (pkOT, skOT) ← ΣOT.KGen(1λ); µ = fs0 (pkOT);
- r1, z3 ←${0, 1}λ; c ← Ω.Enc(pke, z3; r1); w ← z3;
- πΠ ← Π.P(Π.crs, (x, c, pke, pkOT, µ, ρ), (w, r1, r0, s0));
- σOT ← ΣOT.Sign(skOT, (x, c, µ, πΠ));
- return π = (c, µ, πΠ, pkOT, σOT);
Ext(crs, x, π, tcext)
- return w ← Ω.Dec(tcext, c);
Fig. 1. The strong version of the C∅C∅ transformation.
the C∅C∅ framework, we observe that this choice is non-optimal from an eﬃ-
ciency point of view. Moreover, the choice of the commitment is also problematic
in a diﬀerent sense, because the speciﬁc commitment used in C∅C∅ is secure in
the random oracle model (ROM). Since this implies that statements need to
be proven with respect to the preimage of a random oracle, instantiating the
framework in a provable secure way is not possible. Consequently, we discuss an
alternative approach to commit to the PRF key. Our approach can be instan-
tiated in a provably secure way and, on top of that, is also more eﬃcient while
still relying on symmetric-key primitives only.
The problem in the symmetric setting is to ﬁnd eﬃcient binding commit-
ments. The signature scheme construction in [DOR+16] based on the Bellare-
Goldwasser paradigm [BG90] also needs to “commit” to a PRF key. There, sig-
natures consist of a simulation extractable NIZK proof of a PRF key, where
the PRF is built from symmetric-key primitives. The standard notion of PRF
security, however, does not immediately imply any binding property on the key.
Therefore, the construction relies on a computational ﬁxed-valued-key-binding
PRF [CMR98, Fis99], i.e., a PRF f with the additional property that there ex-
12
ists a β such that for a PRF key s and given y = fs(β) it is hard to provide a
second PRF key s(cid:48), s (cid:54)= s(cid:48), satisfying y = fs(cid:48)(β):
Deﬁnition 6 (Computational Fixed-Value-Key-Binding PRF). A PRF
family f : S × D → R is computationally key-binding if there exists a special
value β ∈ D so that it holds for all adversaries A that:
(cid:104)
s ←$S, s(cid:48) ← Afs(·)(fs(β), β) : fs(cid:48)(β) = fs(β)
Pr
(cid:105) ≈λ 0.
Extending the public key with the PRF evaluation at β and proving its well-
formedness is then suﬃcient to “commit” to the PRF key.10
For C∅C∅, we can apply the same idea: we replace the commitment to the
PRF key with the evaluation of the PRF at β and adapt the language accord-
ingly. That is, for the construction depicted in Fig. 111, let the language L(cid:48) be
such that {(x, µ, pkOT, ρ, β), (w, s0)} ∈ RL(cid:48) if and only if:
(cid:8)(x, w) ∈ RL ∨ (µ = fs0(pkOT) ∧ ρ = fs0(β))(cid:9) .
We denote the C∅C∅ framework using the language L(cid:48) as Optimized C∅C∅, or
OC∅C∅ for short. For the security proofs (Theorem 2 and Theorem 3 in [Bag19]),
we note for each game change based on computational hiding of the commitment,
we now use the PRF property and replace them with the evaluation of a random
function (Lemma 4). For the step relying on the commitment scheme’s binding
property (Lemma 2), one can now argue the uniqueness of the PRF key using the
ﬁxed-value-key-binding property of the PRF. Therefore, we obtain the following
corollary:
Corollary 1. If the underlying SNARK satisﬁes perfect completeness, knowl-
edge soundness, subversion zero-knowledge, the PRF is secure and computation-
ally ﬁxed-value-key-binding, and the one-time signature is sEUF-CMA secure,
then OC∅C∅ yields a SNARK satisfying perfect completeness, subversion zero-
knowledge, and strong simulation extractability.
Instantiating the OC∅C∅ Framework When instantiating the original C∅C∅
framework or OC∅C∅ based on our modiﬁcations, SHA-256 as well as any other
variant of the SHA2 family or the SHA3 family are non-optimal choices from an
eﬃciency point of view. Indeed, representing the SHA-256 compression function
as R1CS requires 22,272 constraints [CGGN17]. The permutation used in SHA3
is even more expensive with 38,400 constraints [AGR+16]. Recent lines of work
speciﬁcally designed block ciphers and hash functions that work especially well
in the context of SNARKs. These include MiMC [AGR+16], GMiMC [AGP+19],
Poseidon [GKK+19], Friday [AD18], Vision and Rescue [AABS+19], which all
were speciﬁcally designed with SNARK/STARK-based applications in mind. We
10 Similarly, [DRS18] employs the same idea to commit to a PRF key.
11 Now, one will use the non black-box extractor of the underlying SNARK instead of
the black-box extractor Ext from Fig. 1.
13
however want to note that these designs are all relatively young and were not
available at the time C∅C∅ was proposed.
Since those designs are all very recent, their cryptanalysis is still ongoing.
Friday suﬀers from a Gröbner-basis attack [ACG+19], the key schedule of some
variants of MiMC can be attacked using an interpolation attack [LP19] and they
also suﬀer from a collision attack [Bon19], which can also be applied to some
variants of GMiMC. Notably, the designs also received some interest as part of
a hash collision challenge for STARK-friendly designs,12 where collisions have
been found for low-security instances already. Therefore, we will only include
instances in our evaluation that – to the best of our knowledge – have not been
broken so far.
Even though these symmetric primitives are designed for SNARKs, they
often run into practical problems. For instance, one of the popular choices for
instantiating SNARKs is the pairing-friendly BLS12-38113 curve. However, its
group order q does not match MiMC’s and GMiMC’s requirement coming from
the choice of x (cid:55)→ x3 as Sbox that gcd(q−1, 3) = 1. Additionally, MiMC operates
in large prime ﬁelds, requiring one to emulate the required ﬁelds on top of Fq.
The latter issue is solved by GMiMC working over smaller ﬁelds, but the order
requirement is still an issue. Poseidon, which allows one to choose x (cid:55)→ x5 as Sbox
meaning that gcd(q− 1, 5) = 1 needs to be satisﬁed, ﬁxes both problems and can
be directly implemented in Fq arithmetic. Similarly, Rescue faces similar issues
as the Sboxes used there are x (cid:55)→ xα and x (cid:55)→ x1/α. Hence, for the speciﬁc choice
of BLS12-381 this would imply α = 5. Vision, on the other hand, is speciﬁed over
a binary ﬁeld and can thus also not be directly implemented in Fq arithmetic.
Additionally, the signature scheme Picnic [CDG+17] demonstrated that
LowMC [ARS+15], initially designed for MPC and FHE, performs well enough
in the context of NIZKs. We consider LowMC in our evaluation as the con-
servative choice of SNARK-friendly primitives, since it has seen some rounds
of cryptanalysis [DEM16, DLMW15] and corresponding updates to the round
formula [RST18], and additionally gained some attention in terms of eﬃcient
implementations [DKP+19].
Evaluation In Table 1 we evaluate a variety of SNARK-friendly primitives
together with the SHA2 and SHA3 families of hash functions. Our evaluation
focuses on the provable secure version using ﬁxed-value-key-binding PRFs as
discussed above with a PRF having 256 bit keys, inputs, and outputs. The
number of constraints is computed according to the formulas given in the re-
spective works. We consider MiMC-(N, R), GMiMC-(N, t, R) with the expand-
ing round function (ERF) construction, Poseidon-(N, t, Rf , Rp) with x (cid:55)→ x5
as SBox, Rescue-(N, t, R) with x (cid:55)→ x5 and x (cid:55)→ x1/5, Vision-(N, t, R), and
LowMC-(N, k, m, R), where N denotes the block size, t the number of branches,
R the number of rounds, Rf and Rp the number of full and partial rounds, k
the key size and m the number of Sboxes. Where possible, we selected instances
12 https://starkware.co/hash-challenge/
13 https://electriccoin.co/blog/new-snark-curve/
14
2
9
2
1
8
9
9
1
4
0
8
0
0
8
2
0
8
6
1
8
4
1
2
8
8
2
4
0
2
7
2
2
2
0
0
8
0
6
4
6
4
6
9
9
9
2
0
4
0
4
8
0
0
4
1
4
7
0
1
4
4
1
2
0
6
3
1
1
1
0
0
4
0
3
2
2
9
9
4
4
2
4
4
5
4
4
+
0