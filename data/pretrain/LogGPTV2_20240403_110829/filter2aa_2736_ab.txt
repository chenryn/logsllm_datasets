bool result = pRecycler->m_HeapBlockMap32.SetHeapBlock(
pageaddress,pagenum,pLargeHeapBlock );
if(result)
{
//link the new LargeHeapBlock to the pLargeHeapBucket-
>pLargeHeapBlockList list
pLargeHeapblock->pNextLargeBlock = pLargeHeapBucket-
>pLargeHeapBlockList;
pLargeHeapBucket->pLargeHeapBlockList = pLargeHeapblock;
return pLargeHeapblock;
}
}
LargeHeapBucket::AddLargeHeapBlock Part II
SmallNormalHeapBlock
Size = 0x68 + ((0x1000/blocksize) +3 )&0x0FFFFFFFC
blockSize
blockSize
blockSize
……
……
……
blockSize
blockSize
blockSize
SmallNormalHeapBlock
0x04: StartAddress
0x20:pNextSmallHeapblock
0x24: pFreeHeapObject
0x2c: pValidPointersBuffer
0x34: blockSize
0x36: objectCapacity
0x44: pMarkBitMapTable
0x48: freeBitVector
0 1 2 3 4 5 6 7 8 9 a b c d e f
1
0
1
1
1
2
1
3
1
4
1
5
1
6
1
7
1
8
1
9
1
a
1
b
1
c
1
d
1
e
1
f
Attribute Array
0 1 2 3 4 5 6 7 8 9 a b c d e f
1
0
1
1
1
2
1
3
1
4
1
5
1
6
1
7
1
8
1
9
1
a
1
b
1
c
1
d
1
e
1
f
0
1
2
……
fe
ff
100
101
102
……
1fe
1ff
HeapInfo::ValidPointersMap::validPointersBuffer
L2MapChunk
SmallNormalHeapBlock
Markbitmap,freeBitvector
• SmallHeapBlock managers one page( 4k)Memory.
– 2^12/2^4=256
• markbitmap 32 bytes, 256 bit.
– bit 1: mark
– bit 0: unmark
• freeBitVector 32 bytes, 256 bit.
– bit 1: free
– bit 0: unfree
validPointersBuffer
• Each SmallHeapBlock mangers one page(4k) 
memory
– 2^12/2^4=256
• ValidPointer: the beginaddres of the object is 
Valid pointer, the interior address is invalid 
pointer.
• Each validPointersBuffer element contains two 
part, each part is an array,array length is 256.
– First part: Chakra GC
– Second part: MemGc
HeapInfo::ValidPointersMap::validPointersBuffer
SmallNormalHeapBlock
blocksize 0x20
pageaddress 0x15100000
validPointersBuffer example
• 15100000,15100020,15100040……
• 15100010
– Chakra GC: 
• index = validPointerBuffer_chakra[(address –
pageaddress)/0x10] = 0xffff
– MemGC
• Index = validPointerBuffer_memgc[(address –
pageaddress)/0x10] = 0x00
• Realaddress = pageaddress + index*blocksize = 
0x15100000
LargeHeapBlock
• pagenums = ((blocksize*4 + 10 ) + 0xfff)/2^12
• arrayLength = ( (pagenums*2^12) – blocksize -0x10)/2^10 +1
• largeheapblockSize = 0x64 + 4*arrayLength
LargeHeapBlock
LargeHeapBlock
0x04 pageAddress
0x28 allocblockcount
0x2c blockCapacity
0x30 allocAddress
0x34 endAddress
0x38 pNextLargeHeapBlock
0x44 pPrevFreeList
0x48 pNextFreeList
0x4c pFreeHeapObject
0x64 allocBlockAddressArray[]
0
1
2
…
blockCapa
city-1
blockSize
+0x10
blockSize
+0x10
blockSize
+0x10
……
……
……
blockSize
+0x10
blockSize
+0x10
blockSize
+0x10
LargeObjectHeader
LargeObjectHeader( inuse )
0x00    index
0x04    blocksize
0x08    initialzero
0x0c    encode
LargeObjectHeader( free)
0x00    index
0x04    blocksize
0x08    pLargeHeapBlock
0x0c    pNextFreeHeapObject
pageaddress to HeapBlock
• pageaddres
– High 12 bit: first_index
– Middle 8 bit: second_index
– Low 12 bit: not used
3
1
3
0
2
9
2
8
2
7
2
6
2
5
2
4
2
3
2
2
2
1
2
0
1
9
1
8
1
7
1
6
1
5
1
4
1
3
1
2
1
1
1
0
9 8 7 6 5 4 3 2 1 0
HeapBlock32Map
count: the number of L2MapChunk in m_pL2MapChunkArray
m_pL2MapChunkArray: an L2MapChunk  array.
HeapBlock32Map
0x00    count
0x04
m_pL2MapChunkArray[4096] 
L2MapChunk
0x0000    markbitmaptable[256]
0x2000    m_address2heapblocktable[256]
markbitmaptable:   markbitmap array. each element 32 bytes
m_address2heapblocktable : an array, each element is an pointer 
to HeapBlock
pageaddress to HeapBlock
MemGC Free
• edgehtml! MemoryProtection::HeapFree
 Edgehtml!MemoryProtection::CMemoryGC::ProtectedFree
chakra!MemProtectHeapUnrootAndZero
MemProtectHeapUnrootAndZero
MemProtectHeapUnrootAndZero(MemProtectHeap* pMemProtectHeap, void* freeBlockAddress)
{
MemProtectThreadContext* pMemProtectThreadContext = TlsGetValue( pMemProtectHeap-
>m_tlsIndex);
RecyclerHeapObjectInfo tempRecyclerHeapObjectInf;
if( pMemProtectThreadContext )
{
*(_BYTE*)(pMemProtectThreadContext+8) = 1;
MemProtectHeap* pMemProtectHeapFromContext = pMemProtectThreadContext-
>pMemProtectHeap;
Recycler* pRecycler = &(pMemProtectHeapFromContext->m_Recycler);
if(pRecycler->FindHeapObject( freeblockAddress,2, &tempRecyclerHeapObjectInf ))
{
if( !tempRecyclerHeapObjectInf.IsLeaf( ))
{
int objectsize = tempRecyclerHeapObjectInf.pHeapBlock->GetObjectSize( );
//set the freeblockaddress content zero
memset( freeBlockAddress, 0, objectsize);
}
if(tempRecyclerHeapObjectInf.ClearImplictRootbit( ))
{
pMemProtectThreadContext->NotifyUnroot( &RecyclerHeapObjectInfo);
}
}
}
}
1、memset zero
2、unroot
Mark
 stackpointer: the stack current element address.
 basepointer: the stack begin address
 endAddress: the stack endaddress
 arrayStartAddress : the begin address which maintance the
stack information.
chakra!markcontext
0x08    stackpointer
0x0c    basepointer
0x10    endAddress
0x14    arrayStartAddress
Mark
find roots
• MemProtectHeap::FindRoots
– MemProtectThreadContext::ScanStack
– Recycler::ScanImplicitRoots
• push the root object into makecontext.
processmarkcontext
Address mark
• Address > 0x10000
• Address -> HeapBlock
• realaddress = GetRealAddressFromInterior
– LargeHeapBlock:: GetRealAddressFromInterior
– SmallHeapBlock::GetRealAddressFromInterior
address mark
• Addres
– High 12 bit: first_index
– Middle 8 bit: second_index
– Low 8 bit: bit_index
– Last low 4 bit: 0x10 bytes alignment
3
1
3
0
2
9
2
8
2
7
2
6
2
5
2
4
2
3
2
2
2
1
2
0
1
9
1
8
1
7
1
6
1
5
1
4
1
3
1
2
1
1
1
0
9 8 7 6 5 4 3 2 1 0
address mark
push (address,size) to stack
• The address is the first time mark
• Address -> HeapBlock
• SmallNormalHeapBlock::ProcessMarkedObject
• LargeHeapBlock::Mark
chakra!SmallNormalHeapBlock::ProcessMarkedObject(SmallHeapBlock* pSmallHeapBlock, int
address, MarkContext* pMarkContext)
{
int blockSize = this->blockSize;
BYTE bit_index = (address>>4) &0xff int invalidBitsIndex = blockSize/0x10;
//32 bytes 
invalidBits = HeapInfo::ValidPointersMap:: invalidBitsData[ invalidBitsIndex ];
//1,invalid,0 valid
if(!bittest( invalidBits, bit_index ))
{
if( pMarkContext->stackpointer != pMarkContext->arrayEndAddress)
{
//push one element into the stack.
stackpointer = pMarkContext->stackpointer;
*stackpointer = address;
*(currentAddress+4) = blockSize;
pMarkContext->stackpointer +=8;
}
}
}
SmallNormalHeapBlock::ProcessMarkedObject
invalidBitsData
• each smallheapblock manager one page 
memory(4k)
– 2^12/2^4 = 256
• Each invalidBitsData element is 32 bytes, 256 
bit , each bit indicates whether the address is 
a valid pointer
– bit 1: invalid  pointer
– bit 0: valid pointer
HeapInfo::ValidPointersMap::invalidBit
sData
• blocksize 0x20
chakra!LargeHeapBlock::Mark( int address, MarkContext* pMarkContext)
{
//get the largeobjectheader
LargeObjectHeader* pLargeObjectHeader = (LargeObjectHeader*)(address-0x10)
//check the object is a valid object 
//one: address-0x10 > LargeHeapblock::pageaddress
//two: LargeObjectHeader::index index]