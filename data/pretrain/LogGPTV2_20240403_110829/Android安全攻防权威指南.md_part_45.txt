target remote 127.0.0.1:31337
dev:gn-browser-dbg $
D
---
## Page 203
7.6调试原生代码
187
如注释所描述的，第一个命令用于告诉GDB客户端在当前目录下查找有符号文件。GDB服
务器指明加载哪些模块，GDB客户端相应地加载这些指定的模块。第二个命令大家应该很熟悉，
它告知GDB客户端去哪里连接GDB服务器。
最后，可以运行所有程序来查看该过程的运行情况。下面的片段展示了在最精简配置下的调
试情况。
dev:gn-browser-dbg S arm-eabi-gdb -q -x script .gdb app_process
Reading symbols from /android/source/gn-browser-dbg/app_process.. done.,
varning: Could not 1oad shared library symbols for 86 1ibrarie8, e-g. 1ibm.
Use the *info sharedlibrary* command to see the complete listing.
80.
warning1 Breakpoint address adjusted from 0x40079b79 to 0x40079b78.
epo11_wait () at bionic/1ibc/arch-arm/sysca11s/epo11_wait.S:10
OT
(gdb)back
Aow
r7, ip
epo11_wait () at bionic/1ibe/arch-arm/syscal1s/epo11_wait.S:10
+1
0x400d1fcc in android::Looper::po11Inner (this=0x415874c8,
timeoutMi11i8=coptimized
out>)
at franeworks/native/1ibs/uti1s/Looper,epp:218
#2
0x400d21f0 in android::Looper::po110nce (this=0x415874c8,
timeoutMi11ia=-1,
outFd=0x0,outEvents=0x0, outData=0x0)
0x40209c68 in po110nce (timeoutxi11is=,
at frameworks/native/1ibs/uti1s/Looper,cpp:189
this=) at frameworks/native/inelude/utils/Looper.h:176
3
$4
android::NativeMessageQueue:1po110nce (this=0x417fdb10, env=0x416d1d90,
timeoutHi11is=coptimized out>)
at frameworks/base/core/jni/android_os_MessageQueue,epp:97
#6 0x409cbed2 in dvmCa11JNIMethod (args=0x579f9e18, pResu1t=0x417841d0,
5
0x4099bc50 in dvmP1atfoznInvoke () at dalvik/vm/arch/arm/Ca11EABI.S:258
method=0x57b57860, se1f=0x417841c01
at da1vik/vm/Jni.cpp:1185
da1vik/vm/sterp/out/InterpAsm-armv7-aneon.S:16240
#7
0x409a5064 in dalvik_nterp () at
80x409a95f0 in dvmInterpret (self=0x417841c0, method=0x57b679b8,
#90x409dele2 in dvmInvokeMethod (obj=, method=0x57b679b8,
argList=coptimized out>, params=,
returnType=0x418292a8, noAccessCheck=false) at
dalvik/vm/interp/Stack,cpp:737
#10 0x409e5de2 in Dalvix_java_lang_reflect_Method_invokeNative
(args=,pResult=0x417841d0)
at da1vik/vm/native/Java_lang_reflect_Method.cpp:101
11 0x409a5064 in dalvik_nterp () at
dalvik/vm/mterp/out/InterpAem-armv7-aneon.S:16240
12 0x409a95fo in dvmInterpret (self=0x417841e0, method=0x57b5cc30,
pResult=0xbec94960)
at da1vik/vm/interp/Interp-cpp:1956
13 0x409ddf24 in dvmCa118ethodV (self=0x417841c0, method=0x57b5cc30,
---
## Page 204
188
第7章调试与分析安全漏洞
obj=, fromJni=,
pResu1t=0xbec94960, args=...) at dalvik/vm/interp/Stack.cpp:526
14 0x409e7b6a in Ca11StaticVoidMethodV (env=,
out>, methodTD=0x57b5cc30, arge=coptinized out>)
jclazz=,
at da1vik/vm/Jni .cpp:2122
clazz=, methodID=0x57b5cc30)
at 1ibnativehelper/inelude/nativebelper/{ni .h:780
16 0x401ee32a In android :AndroidRuntime1:start (thiss,
88:dd
options=) at frameworks/base/core/jni/AndroidRuntime,
frameworks/base/cmds/app_process/app_nain. cpp :231
#17 0x4000d05e in main (argc=4, argv=0xbec94b38) at
(gdb)
从libwebcore.so中加载符号需要相当长的时间，因为它太大了。使用SSD或RAM磁盘会大
大加快加载速度。可以看出，前面的片段中使用了完全符号，显示出了函数名、源代码文件、行
号甚至函数参数。
3.源代码级调试
交互式调试的终极目标是能够在源代码级别进行工作。幸运的是，使用AOSP中checkout
出的代码配合AOSP支持的Nexus设备就可以做到这一点。如果一直按照前面小节中的步骤来操
作，通过使用自已编译出的带符号的二进制文件就已经可以实现源代码级的调试了。只需简单地
在GDB客户端中执行一些命令就能看到这个过程，如以下片段所示：
after attaching. as before
epo11_wait () at bionic/1ibc/arch-arm/syscal1s/epo11_wait.S:10
1.0
(gdb) 1ist
mov
r7, ip
ENTRY(epo11_wait)
mov
ip. r7
8
1dr
r7,
=_NR_epol1_wait
9
sv1
#0
11
1.0
BoV
{ + ONX） 0x
r7,
1p
12
cnn
13
bx1s
neg
r0, r0
1r
1. 4
b
_set_errno
#10x400d1fcc in android::Looper::po11Inner (this=0x41591308,
(gdb)up
timeoutMi11is=)
81dxaoo/a//eu/ouexe
218
int eventCount = epol1_wait (mEpol1Fd, eventItens, EPOLL_MAX_
EVENTS,
tineouttillis):
213
(gdb) 1ist
int result = AL0OPBR_POLL_WAKE;
214
mResponses.clear() :
215
nRe8ponseIndex = 0:
---
## Page 205
7.6调试原生代码
189
216
217
218
int eventCount = epo11_wait (mEpo1lFd, eventItens, EPOLL_MAX_
struct epo11_event eventItems [EPOLL_MAX_EVENrS]:
tineoutMi11.s) :
EVENTS,
219
221
220
// Acquire lock.
222
mLock.1ock(1:
(gdb)
附加到目标进程后，能够同时看到函数调用栈中的汇编和C++源代码。GDB的1ist命令
会显示当前代码位置附近的10行代码。up命令在调用栈中向上移动（调用帧方向），dowm命令
向下移动。
如果符号是在其他机器上生成的，或者符号生成后源代码被移动，那么源代码就无法显示，
并会出现错误信息，如以下片段所示：
(gdb)up
10x400d1fce In android::Looper:ipo11Inner (this=0x415874c8,
timeoutxillis=coptinized out>)
at frameworke/natLve/1ibs/ut:i1s/Looper ,cpp :218
218
frameworks/native/libs/utils/Looper-cpp: No such fi1e or directory-
In frameworks/nat:ive/1ibs/ut:11s/Looper cpp
(gdb)
为了解决这种问题，需要创建符号链接，使其指向文件系统中源代码所在的位置。以下片段
展示了所需的命令：
dev:gn-browser-dbg $ 1n -g ~/android/source/dalvik
dev:gn-browser-dbg $ 1n -8 ~/android/source/externa1
完成以上操作后，就可以恢复激代码缓的调试了。此时可以在GDB中查者源代码，基于源
代码位置设置断点，以漂亮的格式显示结构，等等。
- ()papeangranoet114sa(qorapuagi1exooqon. yeesq (@p5)
Breakpoint 1 at 0x5d3a3e44: file
externa1/webkit/Source/WebCore/rendering/Render0bject .h, 1ine 524.
Continuing.
(gdb) cont
只要浏览器打开一个页面，就会触发该断点。在其上下文环境中，可以查看RenderObject
的状态，并分析发生了什么。第8章会详细讨论这些对象。
7.6.6调试非AOSP设备
有时候需要调试运行在非AOSP设备上的代码。或许有bug的代码并没有在AOSP支持的设
备上出现，或者相应代码与AOSP中的不同。后者经常出现在原始设备制造商（OEM）直接出
售的设备上，因为在OEM开发线中所作的修改可能会引人AOSP中不存在的问题。不幸的是，
在这些设备上的调试更加麻烦。
---
## Page 206
190第7章调试与分析安全漏润
在这些设备上调试会面临一些挑战，大部分集中在两个主要问题上。第一，难以准确地知道
该设备系统是使用哪种工具链生成的。OEM可能选择商业工具链、老版本的公开工具，甚至
是自定义修改后的工具链。即使成功地确定了所使用的工具链，也可能无法获取到该工具链。使
用正确的工具链很重要，因为一些工具链之间可能不兼容。例如，GDB所支持协议的不同可能