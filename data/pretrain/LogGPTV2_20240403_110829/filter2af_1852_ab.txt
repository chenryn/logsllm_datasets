后台地址是/xssblind/admin_login.php。pikachu有三个初始用户，我这里的是用户名admin，密码123456，登录即可触发XSS
[
还有一点，如果碰上了XSS中目标不让信息显示出来，如果能发送请求，那么就可以尝试咱这个办法——用DNSlog来获取回显。简单来说，在xss上的利用是在于我们将xss的攻击代码拼接到dnslog网址的高级域名上，就可以在用户访问的时候，将他的信息带回来。具体可以看我的另外一篇笔记，是关于DNSlog来使本来不会显示的信息回显的，比如SQL盲注就可以利用此方法
#### 3.1.3.3.XSS之过滤
具体可看这个：XSS过滤绕过速查表(按ctrl键点我跳转)
输入`'` ，看输出结果和前端源码，被过滤得只剩下`'>`了，输入与输出结果不一致。
[
这里看一波源码，发现这里会使用正则对`
成功
[
因为这里只是过滤了`script`，所以其实还有许多payload可以尝试，比如：``点击图片触发弹窗、``鼠标移动到图片的位置触发弹窗、``图像加载过程中发生错误时触发弹窗。还有下面这种：
    //iframe元素会创建包含另外一个文档的内联框架（即行内框架）。我将用base64编码然后放在iframe元素里，这里也可以绕过
## 3.2.存储型XSS（持续型XSS）
### 介绍
是一种持续型的攻击。将跨站代码植入到网站的数据库中。一旦攻击者第一次成功攻击之后，那么在后续的其他访问者均会受到跨站攻击。这种攻击可能是写到网站的留言板，那么当对方访问留言板就会被触发。它与反射型、DOM型XSS相比，具有更高的隐蔽性，危害性也更大。它们之间最大区别在于反射型与DOM型XSS执行都必须依靠用户手动触发，而存储型XSS却不需要。
### 出现地方
交互的数据会被存在数据库里面，永久性存储，一般出现在留言板、注册等页面
### 3.2.1.过程
#### 3.2.1.1.判断
存储型xss和反射型不同的地方在于他会把输入的数据保存在服务端，反射型输入的数据游走在客户端
存储型xss主要存在于留言板评论区，因为最近没有挖到存储型xss，所以这里就用dvwa的留言板用来演示：
点击留言 **(这里最好不要使用`
`来测试是否存在XSS漏洞，容易被管理员发现，所以你可以使用``来测试，如果成功了，不会被管理员发现)**
OK，我先在留言里输入`s`提交留言，F12打开审查元素，来看我们输入的标签是否被过滤了
[
发现没有过滤 (如果`s`中的``是彩色的说明没有过滤，如果是灰色就说明过滤了)
[
这里换成`impossible`级别就是灰色的，说明被过滤了
[
这里留言板中只留下s，并且s是这样显示的，也说明这里没有过滤
[
这里换成`impossible`级别就留下`s`，说明被过滤了
[
#### 3.1.2.2.使用工具
和反射型XSS的利用方法大同小异
反射型XSS(按ctrl键点我跳转)
#### 3.1.2.3.优势
我在留言板中写下如下留言：
[
[
只要管理员点击那个留言板中已经成功写入获取cookie代码的网页，我们就可以获取到管理员的cookie和后台地址
比如这里我一在dvwa的留言板中刷新，XSS Platform中就会有我的cookie和这个dvwa的地址
[
## 3.3.DOM型XSS
### 介绍
[DOM-XSS攻击原理与防御](https://www.cnblogs.com/mysticbinary/p/12542695.html)
[DOM型xss深度剖析与利用](https://blog.csdn.net/Bul1et/article/details/85091020)
​ DOM的全称为Document Object
Model，即文档对象模型，DOM通常用于代表在HTML、XHTML和XML中的对象。使用DOM可以允许程序和脚本动态地访问和更新文档的内容、结构和样式。
​
通过js可以重构整个HTML页面，而要重构页面或者页面中的某个对象，js就需要知道HTML文档中所有元素的“位置”。而DOM为文档提供了结构化表示，并定义了如何通过脚本来访问文档结构。根据DOM规定，HTML文档中的每个成分都是一个节点。
​ DOM的规定如下：
  * 整个文档是一个文档节点；
  * 每个HTML标签是一个元素节点；
  * 包含在HTML元素中的文本是文本节点；
  * 每一个HTML属性是一个属性节点；
  * 节点与节点之间都有等级关系。
HTML的标签都是一个个的节点，而这些节点组成了DOM的整体结构：节点树。如图所示：
[
简单来说，DOM为一个一个访问html的标准编程接口。
可以发现DOM本身就代表文档的意思，而基于DOM型的XSS是不需要与服务器端交互的，它只发生在客户端处理数据阶段，是基于javascript的。而上面两种XSS都需要服务端的反馈来构造xss。
DOM型XSS示例：
上述代码的意思是获取URL中content参数的值，并且输出，如果输入
`网址?content=`,就会产生XSS漏洞
这里再举一例：
这个文件名为123.html
**在这里我先解释下上面的意思**
Document.write是把里面的内容写到页面里。
document.URL是获取URL地址。
substring 从某处到某处，把之间的内容获取。
document.URL.indexOf("a=")+2是在当前URL里从开头检索a=字符，然后加2(因为a=是两个字符，我们需要把他略去)，同时他也是substring的开始值
document.URL.length是获取当前URL的长度，同时也是substring的结束值。
合起来的意思就是：在URL获取a=后面的值，然后把a=后面的值给显示出来。
[
怎么会出现这个问题呢？
因为当前url并没有`a=`的字符，而`indexOf`的特性是，当获取的值里，如果没有找到自己要检索的值的话，返回-1。找到了则返回0。那么`document.URL.indexOf("a=")`则为-1，再加上2，得1。然后一直到URL最后。这样一来，就把file的f字符给略去了，所以才会出现`ttp://127.0.0.1/123.html`
大致的原理都会了，我们继续下面的
我们可以在123.html后面加上?a=123或者#a=123，只要不影响前面的路径，而且保证a=出现在URL就可以了。
[
我们清楚的看到我们输入的字符被显示出来了。
那我们输入``会怎么样呢？
答案肯定是弹窗(这个用的是360安全浏览器)
[
但是这下面没却没有弹窗，这是为什么呢？这是因为浏览器不同，maxthon、firefox、chrome则不行，他们会在你提交数据之前，对url进行编码。这不是说DOM型XSS不行了，这只是个很简单的例子，所以不用在意。
[
我再次强调下，DOM型XSS 是基于javascript基础上，而且不与服务端进行交互，他的code对你是可见的，而基于服务端的反射型、存储型则是不可见的。
### 3.3.1.利用原理
客户端JS可以访问浏览器的DOM文本对象模型是利用的前提，当确认客户端代码中有DOM型XSS漏洞时，并且能诱使(钓鱼)一名用户访问自己构造的URL，就说明可以在受害者的客户端注入恶意脚本。利用步骤和反射型很类似，但是唯一的区别就是，构造的URL参数不用发送到服务器端，可以达到绕过WAF、躲避服务端的检测效果。
### 3.3.2.过程
输入测试代码`'"<>`，显示的内容和我们所输入的有所不同
[
那就来看看源码吧
[
HTML的DOM中，`getElementById()`方法可返回对拥有指定 ID
的第一个对象的引用。语法为：`document.getElementById(id)`。在这里就是获取标签id为`text`的值传递给`str`，`str`通过字符串拼接到a标签中。所以我们要闭合前面的标签
输入payload：`'>`
成功闭合，鼠标移动到图片的位置触发弹窗
[
# 4.注意事项
1.能不能执行js代码主要看浏览器的安全策略怎么样，要考虑到各个浏览器的版本的安全策略，浏览器版本比较高的时候，有些js代码会被禁用。像IE高版本会过滤js本地的一些脚本的加载，所以存在这个攻击也会攻击失效
2.需要受害者去配合。一般需要特定的人去访问去触发才行。是被动攻击
# 5.XSS工具
## 5.1.xss平台
上面已经介绍过，这里就不赘述了