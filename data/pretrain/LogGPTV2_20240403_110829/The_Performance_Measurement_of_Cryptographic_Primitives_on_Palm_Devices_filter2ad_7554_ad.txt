p
s
e
t
y
B
n
i
d
e
e
p
S
d
n
o
c
e
s
r
e
p
s
e
t
y
B
n
i
d
e
e
p
S
15000
10000
5000
0
128 
192
256
ECB
CBC
FB 64
FB 32
FB 16
MD2
MD4
MD5
Hash Functions
SHA-1
Figure 3. Performance of MD2, MD4, MD5 and
SHA-1
Rijndael 
DES
DESX
Triple DES
Ciphers
Figure 2. Performance of Rijndael, DES, DESX
and Triple-DES on a Palm IIIc (2KB case)
6. Hash Functions
In this section, we give the performance measurement
results of MD2, MD4, MD5 and SHA-1. All of these al-
gorithms were ported from open source coded in C and im-
plemented in the system library format. The test results are
shown in Table 8.
If the hash functions are bundled on the application code
resource directly, we found a slight improvement on the
hashing speed for all these hash functions due to the reasons
explained in Section 2.1. The improvement ranges from 1%
to 4%. The relative speeds of these hash functions running
on Palm devices are shown in Figure 3. The speed of SHA-1
is about 47% of that of MD5.
7. Multiple Precision Integer Arithmetic Oper-
ations
Many public-key cryptosystems require computations in
(cid:1), the integers modulo  where  is a large positive inte-
ger of hundreds of digits long. Besides (cid:1) , other algebraic
structures such as polynomial rings, ﬁnite ﬁelds and ﬁnite
cyclic groups are also extensively used. It is generally no-
ticed that efﬁcient implementations of these operations are
becoming of utmost importance in modern applied cryptog-
raphy.
In this section, we describe a multiple-precision in-
teger arithmetic system library we developed for Palm
OS and evaluated its performance. The library is called
Multiple-precision Integer Arithmetic Library for Palm OS
(MPLib)15.
It contains functions to perform multiple-
precision integer arithmetic operations and other related al-
gorithms. In general, there is no limit applied to the preci-
sion of the integers except the available dynamic memory
implied by the memory manager of the Palm OS. MPLib
has a rich set of functions, and the functions have a regular
interface. A complete list of the functions currently sup-
ported by MPLib can be found in the User’s Manual 16.
15http://www.ccs.neu.edu/home/swong/MPLib
16http://www.ccs.neu.edu/home/swong/MPLib/MPLibmanual.txt
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 07:05:01 UTC from IEEE Xplore.  Restrictions apply. 
To test the speeds of the MPLib algorithms, we used a
similar approach to that of testing the speeds of ciphers and
hash functions. Below is the pseudo-code of testing the
speed of 512-bit modular multiplication ( (cid:2) (cid:1)(cid:7) (cid:20) (cid:16)
where (cid:7)(cid:1)(cid:7) (cid:2) (cid:7)(cid:7)(cid:7) (cid:2) (cid:7)(cid:16)(cid:7)).
(t = 0; t < samples; t++);
a = randGen(512);
b = randGen(512);
d = randGen(512);
(Start Timer)
(c = 0; c < calls; c++);
MPLib_mod_mul(m, a, b, d);
(Stop Timer)
For each sample, the testing program randomly gener-
ates three 512-bit integers (cid:1), (cid:7) and (cid:16). Then the modular
multiplication function of the MPLib is called for calls
times and the time taken for doing these computations is
recorded.
Table 9 shows the average speed of computing a 512-bit
modular reduction for calls(cid:2) (cid:3)(cid:5)(cid:7)(cid:1).
Speed (msec) Average Tick Count
Palm V
Palm IIIc
3.13
1.88
320
192
Table 9. Speed of 512-bit Modular Reduction
doable if a cryptosystem [10, 9] requires only one or two
such operations. Table 12 shows the performance of com-
puting a 512-bit modular inverse.
Speed (msec) Average Tick Count
Palm V
Palm IIIc
1,381
998
4420
3194
Table 12. Speed of 512-bit Modular Inverse
This is an implementation of the extended Euclidean algo-
rithm. It has a much higher cost than any of the three op-
erations mentioned above. On Palm V, the average time
of performing one 512-bit modular inverse is over one sec-
ond. When designing a cryptosystem for PalmPilot, we sug-
gest to minimize or even eliminate any calls to the modu-
lar inverse operation for large integers. Table 13 shows the
performance of computing 512-bit modular exponentiation
with different magnitude of exponents.
512-bit Exponent
Speed
Tick Count
Small Exponent ((cid:2) 8 bits)
Speed
Tick Count
Palm V
Palm IIIc
Palm V
Palm IIIc
310112
224761
96.91 sec
70.24 sec
Special Case 1 (exp = 3)
710 msec
514 msec
2273
1645
5858
3758
1,831 msec
1,174 msec
Special Case 2 (exp = 65537)
2,627 msec
1,899 msec
8407
6077
This is a simple multiple-precision division. Table 10 shows
the speed of computing a 512-bit modular addition.
Table 13. Speed of 512-bit Modular Exponen-
tiation
Speed (msec) Average Tick Count
Palm V
Palm IIIc
3.28
2.21
336
226
Table 10. Speed of 512-bit Modular Addition
We ﬁrst note that the modular reduction and modular addi-
tion are relatively fast due to the simplicity of these opera-
tions. The cost of doing these operations can be ignored for
most of the applications. Table 11 shows the performance of
computing a 512-bit and a 1024-bit modular multiplication.
From now on, the value of calls has been set to (cid:6)(cid:7).
512-bit Mod Mult
1024-bit Mod Mult
Speed (msec)
Tick Count
Speed (msec)
Tick Count
Palm V
Palm IIIc
107
79
341
253
410
299
1311
956
Table 11. Speed of Modular Multiplication
This operation has a higher cost than the modular reduc-
tion or the modular addition. About 100 msec is taken to
perform one 512-bit modular multiplication which is still
The modular exponentiation is very expensive if the value
of the exponent is large. To compute a 512-bit modular ex-
ponentiation for 512-bit exponent, over one minute of pure
computation time is required of the CPU. On the other hand,
if the exponent is small (e.g. exponent = 3), the time taken
for pure computation is signiﬁcantly shorter. The results
suggest that the Palm devices are only suitable for limited
computation of modular exponentiation for most of the ap-
plications. For example, it may be acceptable to conduct
one RSA encryption or signature veriﬁcation but not the
RSA decryption or signature generation. The modular ex-
ponentiation was conducted using the Montgomery expo-
nentiation algorithm [2]. Figure 4 summarizes the perfor-
mance of modular multiplication, modular inversion and
modular exponentiation.
The implementation also revealed that there is a com-
mon set of instructions such as rotational shifts, exclusive-
or, and data moves, which are widely used among ciphers,
hash functions and multiple-precision arithmetic operations
we developed. Improvements should be made at an instruc-
tional or hardware level in order to further improve their
efﬁciency. Furthermore, due to the limited number of regis-
ters in the microprocessor and there is no cache, most of the
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 07:05:01 UTC from IEEE Xplore.  Restrictions apply. 
References
[1] J. Daemen and V. Rijmen. AES Proposal: Rijndael. AES
Algorithm Submission, Sep 1999. http://www.nist.gov/aes.
[2] Stephen R. Duss´e and Burton S. Kaliski Jr. A cryptographic
library for the Motorola DSP56000. In I.B. Damg˚ard, editor,
Advances in Cryptology — Eurocrypt ’90, pages 230–244,
New York, 1990. Springer-Verlag.
[3] B.S. Kaliski, Jr. RFC 1319: The MD2 Message-Digest Al-
gorithm. IETF RFC 1319, Apr 1992.
[4] NIST FIPS PUB 180-1. Secure Hash Standard, Apr 1995.
[5] Ronald Rivest. RFC 1320: The MD4 Message-Digest Algo-
rithm. IETF RFC 1320, Apr 1992.
[6] Ronald Rivest. RFC 1321: The MD5 Message-Digest Algo-
rithm. IETF RFC 1321, Apr 1992.
[7] Phillip Rogaway and Don Coppersmith. A software-opti-
mized encryption algorithm. Journal of Cryptology, 11(4),
First Quarter 1998.
[8] Bruce Schneier. Applied Cryptography : protocols, algo-
rithms, and source code in C. John Wiley & Sons, Inc., sec-
ond edition, 1996.
[9] Duncan S. Wong and Agnes H. Chan. Efﬁcient and mutu-
ally authenticated key exchange for low power computing
devices. to appear in Proc. of ASIACRYPT 01, Dec 2001.
[10] Duncan S. Wong and Agnes H. Chan. Mutual authentication
and key exchange for low power wireless communications.
to appear in IEEE MILCOM 2001 Conference Proceedings,
Oct 2001.
[11] Muxiang Zhang, Christopher Carroll, and Agnes H. Chan.
The software-oriented stream cipher SSC2. Fast Software
Encryption Workshop 2000, 2000.
s
d
n
o
c
e
s
i
l
i
m
n
i
e
m
T
i
100000
10000
1000
100
10
1
Palm V
Palm IIIc
512 bit Exponent
S mall Exponent
Special Case 1
1024 bit M od M ult.
512 bit M od M ult.
M odular Inverse
Special Case 2
Arithmetic Operations
Figure 4. Performance of Modular Multiplica-
tion, Modular Inverse and Modular Exponen-
tiation
data requests induce direct memory access requests, each
of which takes several clock cycles to complete. We believe
that by reducing the number of memory access or by pro-
viding faster memory accesses, one can have a signiﬁcant
effect on the overall efﬁciency of the algorithms.
8. Suggestions and Conclusions
SSC2 gives the most efﬁcient keystream generation and
encryption speed in most of the cases. It outperforms ARC4
by 10% in most of the cases. In addition, it requires less
memory space for storing the internal states than the ARC4
does. On the other hand, SEAL 3.0 is very efﬁcient in en-
crypting very large data. It can be very useful to encrypt
real-time data-stream if precomputation of the key setup ta-
bles is allowed or the overhead of key setup is not an issue
for a target application. The drawback is that large memory
chunk is needed (over 3KB) for storing T, S and R tables.
This may cause problems on some other low-power devices
with very limited memory space.
Block ciphers are much slower than stream ciphers. Al-
though they are still relatively fast for small data blocks
when compared with public-key encryption, our results
show that stream ciphers such as SSC2 and ARC4 should
be used whenever possible.
Finally, for applications which desire eminently efﬁcient
algorithms, the code of the algorithms should be put inside
the applications in order to eliminate any system trap in-
structions. Also hand-coded optimization is always possi-
ble through a closer inspection of the assembly code derived
from a compiled program.
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 07:05:01 UTC from IEEE Xplore.  Restrictions apply.