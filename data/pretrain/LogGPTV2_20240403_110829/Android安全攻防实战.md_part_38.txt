显然，0x000084f8上的BLX指令就是调用printf的指令，所以如果要跳过它，
我们就必须得到紧接着它的下一条指令的地址，即0x000084fc。更具体地说，
就是我们要把下面这个东西输入到程序中：
[16 padding chars]  \xfc\x84
由于目标处理器是台小端机，指定返回地址的字节必须要以逆序给出的。
8.用GDB server重新运行应用程序，这次给它以下输入
260
---
## Page 279
第8章原生代码中漏洞的利用与分析
如果一切进行顺利，你会看到应用程序不再打出”youlose"的信息，而直接退
出了。
你可以做的远远不止跳过一个简单的输出信息的指令（函数）。在某些情况下，
你甚至可以完全控制一个因执行有漏洞的程序面产生的进程。有关如何操作的更多
信息，可以参考拓展阅读部分的《面向返回的程序不返回》（Retum-Oricnted
Programming withoutReturns）一文的链接。对于更一般的内存溢出攻击的资源，可
以参阅拓展阅读中《内存溢出攻击，（基本）完整的历史指南》（TheMemoryCorruption
AntacksThe（atlmost) CompleteHistory），以及《搞定栈，为了有趣和有利》（Smashing
the Stack forfun and Profit）等文的链接。
拓展阅读
·ARM开发的简短指南位于http:/www.exploit-db.com/wpcontent/themes/
exploit/docs/24493.pdf.
。AlephOne撰写的《搞定栈，为了有趣和有利》位于http://www.phrack.org
issues.html?issue=49&id14#article.
·ThinkstSecurity出版社于2010 年出版的Haroon Meer撰写的《内存溢出攻击，
（基本）完整的历 史指南》在http:/thinkst.com/stuf/bh10/BlackHat-USA-
2010-Meer-History-of-Memory-Corruption-Attacks-wp.pdf.
* Stephen Checkoway,Lucas Davi, Alexandra Dmitrienko, Ahmad-Reza Sadeghi,
http://cseweb.ucsd.edu/~hovav/dist/noret-ccs.pdf。
* Lucas Davi,Alexandra Dmitrienko, Ahmad-Reza Sadeghi, 和l Marcel Winandy
《ARM上面i 向返回的程序不返[回》在http://www.informatik.tu-darmstadt.de/
fileadmin/user_upload/Group_TRUST/PubsPDF/ROP-without-Retums-on-ARM.p
df。
8.6自动fuzzing测试Android原生代码
Fuzz 测试技术是一个发现系统应用程序中可资利用的漏洞或缺陷的很好的方
法。它能使审计人员能评估：文件处理程序及其他应用程序处理异常和可能的恶意
输入的有效性，并有助于确定系统中是否有容易被利用的切入点。它也是一个自动
化安全测试的好办法。
Android 和许多其他系统一样，也有成堆的，有意思的fuzzing目标。Android设
261
---
## Page 280
Android安全攻防实战
备的攻击面并不止于Java应用程序层。事实上，在许多情况下，黑客能获取到root
权限，都是因为原生可执行文件或系统中的实用程序未能正确地处理某些特殊的输
入或以安全的方式对某些情况进行响应。Fuzzing就是一个在Android设备上发现这
些情况—即，可能被利用来进行root的极好的方法。
我们在这里讨论的是如何把一个名为 Radamsa 的fuzzing 测试工具，用到Android
平台上，以及安装一些实用程序，以帮助你编写一些专为Radamsa 开发的，健壮的
fuzzing 测试脚本。
准备工作
在开始前，你需要先下载一个Radamsafuzzer，操作步骤如下。
1.先确认你的Linux 机器已安装了CURL或Wget。只有Wget 其实也够了，但
根据Radamsa 网站建议，你最好能执行下面这条命令，在Ubuntu 机器上先
装上 CURL:
sudo apt-get instal1 gcc cur1
运行这个命令，会产生一个类似如图8.28这张截图的输出。
[0]k317enakan@B14ckwidow:~/Radamsa-AndroidPort
ssudo apt-get install gcccur]
Reading package lists...Done
Building dependency tree
Reading state information...Done
邯 8.28
2.安装好curl之后，你就可以下载Radamsa 的源代码了。
cur1 http: //ouspg googlecode com/files/radamsa-0 .3.tar gz >
radamsa-0.3.tar . gz
执行这个命令，会产生一个类似如图8.29这张截图的输出。
Tnne
Left
 8.29
3.然后执行下面这条命令解压Radamsa。
tar -zxvf radamsa-0.3.tar.gz
如果这条命令执行正确，就会得到类似如图8.30这张截图的输出。
262
---
## Page 281
第8章原生代码中漏润的利用与分析
nsa-0.3/
adansa-0.3/tests/lt.sh
adamsa-0.3/tests/run
msa-0.3/tests/sr.sh
radansa-0.3/tests/tr2.sh
radamsa-0.3/tests/ls.sh
radamsa-0.3/tests/ts1.sh
tests/t
[E 8.30
完成后，你的目录看上去应该会是如图8.31所示这个样子的。
[0]k317enakangB14ckwtd0w:-/Radansa-AndrotdPort
ls -al
WXFOXF-X
drwxr-xr-x
5k3170makan k3170nakan
4096Mar282012
Sep 27 20:53
[e]k3170nakan@B14ckwtdow:~/Radansa-AndrotdPort/radansa-8.3
cdradamsa-0.3/
1s-1
otal616
2012Makefle
-rw-
2012 rao
arsa.c
drwxr-xr-x2k3178nakan k3178makan4096Mar 282012 tests
547Mar 28
图8.31
万事俱备，接下来我们可以开始设置jni 目录架构，并编译 for Android版的
Radamsa 了。
如何做
交叉编译forAndroid版的 Radamsa，需要执行以下几步。
1.在解压了radamsa 源代码之后，在该目录下，已经有了一个名为radamsa-0.3
的文件夹。你还要在这个文件夹里，再创建一个名为jmi的目录，就像在“交
叉编译原生可执行程序”那个实验中所做的一样。
2.把“栈溢出漏润的利用”这个实验中使用的Android.mk文件复制到到jni 目
263
---
## Page 282
Android安全攻防实战
录中。你的目录看上去应该像图8.32这张截图这样。
[]k317emakan@B14ckWid0w:~/Radamsa-AndroidPort/radansa-0.3
[0]k3178makan(B14ckWLdew:~/Radarsa-AndrotdPort/radansa-0.3
nkdLr_jnt
$ls-al
drwxr-xr-x6k3170makan k3170nakan
total628
4096 Sep 27 21:03
drwxrwxr-x
-rw----.
1k317makank3178makan
1689 Mar 28 2012 Makefile
drwxr-xr-x
4096
28
2012rad
rw
28
2012readne.txt
2812 radansa.c
547 Mar
drwxr-xr-x2k3170nakank3170nakan
4096Mar 28 2012 tests
图 8.32
3.radamsa.c文件中含有Radamsa 源代码，把它文件复制到jni目录里去，如图
8.33所示。
[θ]k3176makan@814ckWidew:~/Radamsa-AndrotdPort/radansa-0.3
Scpradamsa.c jnt/.
[e]k3178makan@B14ckwidew:~/Radansa-AndroidPort/radansa-0.3
[0]k3170makan@B14ckwidew:~/Radansa-AndrotdPort/radansa-0.3/jnt
5cdjnt/
sls-al
total684
drwxrwxr-x 2k3170nakan k317nakan
drwxr-xr-x 6k3170nakan k3170nakan
4096Sep 27 21:03
4096 Sep 27 21:03
rw-.*.1 k3170nakan k3170nakan 607139Sep 27 21:03radamsa.C
图 8.33
4.把Android.mk文件复制到jni文件夹中。
可以以图8.34这张截图中所示的方法，复制Android.mk文件。
①原文如此，实际上在第4步中作者又会重复一下这个步骤，对应的截图也是第4步下面的那张
一译者注。
264
---
## Page 283
第8章原生代码中漏润的利用与分析
[0]k3170nakan@Bl4ckWtd8w:~/Radansa-AndroidPort/radamsa-8.3/jni
[0]k3170nakan@814ckwtd0w:~/Radamsa-AndroLdPort/radansa-8.3/ jnt
total608
1e-s1
drwxrwxr-x2k3178nakan k3178nakan
4096 S52210
-rw-rw-r..
-rw**.1 k3170nakan k3170nakan 607139 Sep 27 21:03radansa.C
图 8.34
5.编辑上一步中复制过来的Android.mk文件，把它修改成图8.35这个样子。
1oCAL_PATH:=S（callmy-dir)
3
odule
4 LOCAL_MODULE
:=radansa-0.3
6LOCAL_SRC_FILES：
5
LLst
of
cet
S(BUILD_EXECUTABLE)
图8.35
6，改完Android.mk文件后，你就可以执行ndk-build命令了。你会看到如图8.36
所示的输出。
[0]k3170rkm
9-3/
hetethlsfction
ortedoslyonce foreachfunctiont
ArtPortrad03/traa3:8: ne: ech lared dtfer 1s 
图 8.36
这些信息表明：编译生成二进制可执行文件失败。GCC同时还会告诉你是源
码中的哪几行代码导致的错误。实际上这是一个定义（即有一个typedef，它
把in_addr_t定义为unsignedlong的别名）无法传递到之后的代码中的问题。
在下一步中，我们将修复这个问题，使Radamsa 能够正常完成编译。
7.用你喜欢的代码编辑器一最好是能够显示行号的—打开radamsa.c文件。
向下滚动到第3222行。如图8.37所示是使用的Vim文本编辑器所看到的代
码。
265
---
## Page 284
Android安全攻防实战
3221
addr.stn port =htons(port);
8223
1222
）.1（ip[]1tbs/arreabi/radansa-0.3
图 8.41
11.在成功生成二进制可执行文件之后，你可以把它复制到Android模拟器中
假设你已经安装了Android模拟器，并已经把挂在/system上的分区重新
mount成可写的了，如图8.42所示。
266
---