# ps auxUSER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMANDroot         1  0.0  0.0 115568  2136 pts/0    S    22:55   0:00 /bin/bashroot        13  0.0  0.0 155360  1872 pts/0    R+   22:55   0:00 ps aux果真，我们看不到宿主机上的 IP地址和网卡了，也看不到宿主机上的所有进程了。另外，我们还可以通过函数操作 namespace。第一个函数是**clone**，也就是创建一个新的进程，并把它放到新的 namespace中。    int clone(int (*fn)(void *), void *child_stack, int flags, void *arg);clone 函数我们原来介绍过。这里面有一个参数flags，原来我们没有注意它。其实它可以设置为CLONE_NEWUTS、CLONE_NEWUSER、CLONE_NEWNS、CLONE_NEWPID。CLONE_NEWNET会将 clone 出来的新进程放到新的 namespace 中。第二个函数是**setns**，用于将当前进程加入到已有的 namespace 中。    int setns(int fd, int nstype);其中，fd 指向 /proc/\[pid\]/ns/ 目录里相应 namespace对应的文件，表示要加入哪个 namespace。nstype 用来指定 namespace的类型，可以设置为CLONE_NEWUTS、CLONE_NEWUSER、CLONE_NEWNS、CLONE_NEWPID 和 CLONE_NEWNET。第三个函数是**unshare**，它可以使当前进程退出当前的namespace，并加入到新创建的 namespace。    int unshare(int flags);其中，flags 用于指定一个或者多个上面的CLONE_NEWUTS、CLONE_NEWUSER、CLONE_NEWNS、CLONE_NEWPID 和 CLONE_NEWNET。clone 和 unshare 的区别是，unshare 是使当前进程加入新的 namespace；clone是创建一个新的子进程，然后让子进程加入新的namespace，而当前进程保持不变。这里我们尝试一下，通过 clone 函数来进入一个 namespace。    #define _GNU_SOURCE#include #include #include #include #include #include #include #define STACK_SIZE (1024 * 1024) static int childFunc(void *arg){    printf("In child process.\n");    execlp("bash", "bash", (char *) NULL);    return 0;} int main(int argc, char *argv[]){    char *stack;    char *stackTop;    pid_t pid;     stack = malloc(STACK_SIZE);    if (stack == NULL)    {        perror("malloc");         exit(1);    }    stackTop = stack + STACK_SIZE;     pid = clone(childFunc, stackTop, CLONE_NEWNS|CLONE_NEWPID|CLONE_NEWNET|SIGCHLD, NULL);    if (pid == -1)    {        perror("clone");         exit(1);    }    printf("clone() returned %ld\n", (long) pid);     sleep(1);     if (waitpid(pid, NULL, 0) == -1)    {        perror("waitpid");         exit(1);    }    printf("child has terminated\n");    exit(0);}在上面的代码中，我们调用 clone 的时候，给的参数是CLONE_NEWNS\|CLONE_NEWPID\|CLONE_NEWNET，也就是说，我们会进入一个新的pid、network，以及 mount 的 namespace。如果我们编译运行它，可以得到下面的结果。    
# echo $$64267 
# ps aux | grep bash | grep -v greproot     64267  0.0  0.0 115572  2176 pts/0    Ss   16:53   0:00 -bash 
# ./a.out           clone() returned 64360In child process. 
# echo $$1 
# ip addr1: lo:  mtu 65536 qdisc noop state DOWN group default qlen 1000    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 