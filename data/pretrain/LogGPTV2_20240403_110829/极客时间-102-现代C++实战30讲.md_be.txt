# 27 \| C++ REST SDK：使用现代C++开发网络应用你好，我是吴咏炜。在实战篇，我们最后要讲解的一个库是 C++ REST SDK（也写作cpprestsdk）\[1\，一个支持 HTTP 协议\[2\、主要用于 RESTful\[3\ 接口开发的 C++库。 初识 C++ REST SDK向你提一个问题，你认为用多少行代码可以写出一个类似于 curl\[4\ 的 HTTP 客户端？使用 C++ REST SDK的话，答案是，只需要五十多行有效代码（即使是适配到我们目前的窄小的手机屏幕上）。请看：    #include     #ifdef _WIN32    #include     #include     #endif    #include     using namespace utility;    using namespace web::http;    using namespace web::http::client;    using std::cerr;    using std::endl;    #ifdef _WIN32    #define tcout std::wcout    #else    #define tcout std::cout    #endif    auto get_headers(http_response resp)    {      auto headers = resp.to_string();      auto end =        headers.find(U("\r\n\r\n"));      if (end != string_t::npos) {        headers.resize(end + 4);      };      return headers;    }    auto get_request(string_t uri)    {      http_client client{uri};      // 用 GET 方式发起一个客户端请求      auto request =        client.request(methods::GET)          .then([](http_response resp) {            if (resp.status_code() !=                status_codes::OK) {              // 不 OK，显示当前响应信息              auto headers =                get_headers(resp);              tcout `。        `then` 是         `pplx::task`    类模板的成员函数，参数是能接受其类型参数对象的函数对象。除了最后一个        `then`    块，其他每个         `then` 里都应该返回一个           `pplx::task`，而        `task`    的内部类型就是下一个         `then`    块里函数对象接受的参数的类型。        4.  第 37 行开始，是第一段异步处理代码。参数类型是           `http_response`------因为        `http_client::request` 的返回值是           `pplx::task`。代码中判断如果响应的 HTTP    状态码不是 200    OK，就会显示响应头来帮助调试。然后，进一步取出所有的响应内容（可能需要进一步的异步处理，等待后续的    HTTP 响应到达）。        5.  第 49 行开始，是第二段异步处理代码。参数类型是           `string_t`------因为上一段        `then`    块的返回值是         `pplx::task`。代码中就是简单地把需要输出的内容输出到终端。        6.  第 56--60    行，我们根据平台来定义合适的程序入口，确保命令行参数的正确处理。        7.  第 62--65 行，在 Windows    上我们把标准输出设置成宽字符模式，来确保宽字符（串）能正确输出（参考        [\[第 11    讲\]             ）。注意         `string_t` 在 Windows 上是           `wstring`，在其他平台上是           `string`。        8.  第 72--83 行，如注释所言，产生 HTTP 请求、等待 HTTP    请求完成，并处理相关的异常。        整体而言，这个代码还是很简单的，虽然这种代码风格，对于之前没有接触过这种函数式编程风格的人来讲会有点奇怪------这被称作持续传递风格（continuation-passingstyle），显式地把上一段处理的结果传递到下一个函数中。这个代码已经处理了Windows 环境和 Unix环境的差异，底下是相当复杂的。另外提醒一下，在 Windows 上如果你把源代码存成 UTF-8的话，需要确保文件以 BOM 字符打头。Windows 的编辑器通常缺省就会做到；在Vim 里，可以通过 `set bomb`命令做到这一点。安装和编译上面的代码本身虽然简单，但要把它编译成可执行文件比我们之前讲的代码都要复杂------C++REST SDK 有外部依赖，在 Windows 上和 Unix上还不太一样。它的编译和安装也略复杂，如果你没有这方面的经验的话，建议尽量使用平台推荐的二进制包的安装方式。由于其依赖较多，使用它的编译命令行也较为复杂。正式项目中绝对是需要使用项目管理软件的（如cmake）。此处，我给出手工编译的典型命令行，仅供你尝试编译上面的例子作参考。Windows MSVC：>  > `cl /EHsc /std:c++17 test.cpp cpprest.lib zlib.lib libeay32.lib ssleay32.lib winhttp.lib httpapi.lib bcrypt.lib crypt32.lib advapi32.lib gdi32.lib user32.lib`>Linux GCC：>  > `g++ -std=c++17 -pthread test.cpp -lcpprest -lcrypto -lssl -lboost_thread -lboost_chrono -lboost_system`>macOS Clang：>  > `clang++ -std=c++17 test.cpp -lcpprest -lcrypto -lssl -lboost_thread-mt -lboost_chrono-mt`>概述有了初步印象之后，现在我们可以回过头看看 C++ REST SDK到底是什么了。它是一套用来开发 HTTP 客户端和服务器的现代异步 C++代码库，支持以下特性（随平台不同会有所区别）：1.  HTTP 客户端        2.  HTTP 服务器        3.  任务    4.  JSON    5.  URI    6.  异步流        7.  WebSocket 客户端        8.  OAuth 客户端        上面的例子里用到了 HTTP 客户端、任务和 URI（实际上是由 `string_t`隐式构造了 `uri`），我们下面再介绍一下异步流、JSON 和 HTTP服务器。 异步流C++ REST SDK里实现了一套异步流，能够实现对文件的异步读写。下面的例子展示了我们如何把网络请求的响应异步地存储到文件results.html 中：    #include     #include     #ifdef _WIN32    #include     #include     #endif    #include     #include     #include     using namespace utility;    using namespace web::http;    using namespace web::http::client;    using namespace concurrency::streams;    using std::cerr;    using std::endl;    #ifdef _WIN32    #define tcout std::wcout    #else    #define tcout std::cout    #endif    auto get_headers(http_response resp)    {      auto headers = resp.to_string();      auto end =        headers.find(U("\r\n\r\n"));      if (end != string_t::npos) {        headers.resize(end + 4);      };      return headers;    }    auto get_request(string_t uri)    {      http_client client{uri};      // 用 GET 方式发起一个客户端请求      auto request =        client.request(methods::GET)          .then([](http_response resp) {            if (resp.status_code() ==                status_codes::OK) {              // 正常的话              tcout     #include     #include     #include     #ifdef _WIN32    #include     #include     #endif    #include     using namespace std;    using namespace utility;    using namespace web;    #ifdef _WIN32    #define tcout std::wcout    #else    #define tcout std::cout    #endif    int main()    {    #ifdef _WIN32      _setmode(_fileno(stdout),               _O_WTEXT);    #endif      // 测试的 JSON 字符串      string_t json_str = U(R"(        {          "s": "你好，世界",          "t": true,          "f": false,          "n": null,          "i": 123,          "d": 3.1416,          "a": [1, 2, 3        })");      tcout   > `/sayHi?name=…`>"..."部分代表一个名字，而服务器应当返回一个 JSON的回复，形如：    {"msg": "Hi, …!"}这个服务器的有效代码行同样只有六十多行，如下所示：    #include     #include     #include     #include     #ifdef _WIN32    #include     #include     #endif    #include     #include     using namespace std;    using namespace utility;    using namespace web;    using namespace web::http;    using namespace web::http::      experimental::listener;    #ifdef _WIN32    #define tcout std::wcout    #else    #define tcout std::cout    #endif    void handle_get(http_request req)    {      auto& uri = req.request_uri();      if (uri.path() != U("/sayHi")) {        req.reply(          status_codes::NotFound);        return;      }      tcout second) +        U("!"));      req.reply(status_codes::OK,                answer);    }    int main()    {    #ifdef _WIN32      _setmode(_fileno(stdout),               _O_WTEXT);    #endif      http_listener listener(        U("http://127.0.0.1:8008/"));      listener.support(methods::GET,                       handle_get);      try {        listener.open().wait();        tcout `；当这个任务完成时（        `wait` 调用返回），表示 HTTP    监听器上的对应操作（打开或关闭）真正完成了。        运行程序，然后在另外一个终端里使用我们的第一个例子生成的可执行文件（或curl）： >  > `curl "http://127.0.0.1:8008/sayHi?name=Peter"`>我们就应该会得到正确的结果：>  > `{"msg":"Hi, Peter!"}`>你也可以尝试把路径和参数写错，查看一下程序对出错的处理。关于线程的细节C++ REST SDK使用异步的编程模式，使得写不阻塞的代码变得相当容易。不过，底层它是使用一个线程池来实现的------在C++20的协程能被使用之前，并没有什么更理想的跨平台方式可用。C++ REST SDK 缺省会开启 40个线程。在目前的实现里，如果这些线程全部被用完了，会导致系统整体阻塞。反过来，如果你只是用C++ REST SDK 的 HTTP客户端，你就不需要这么多线程。这个线程数量目前在代码里是可以控制的。比如，下面的代码会把线程池的大小设为10：     #include     …    crossplat::threadpool::      initialize_with_threads(10);如果你使用 C++ REST SDK开发一个服务器，则不仅应当增加线程池的大小，还应当对并发数量进行统计，在并发数接近线程数时主动拒绝新的连接------一般可返回`status_codes::ServiceUnavailable`------以免造成整个系统的阻塞。内容小结今天我们对 C++ REST SDK的主要功能作了一下概要的讲解和演示，让你了解了它的主要功能和这种异步的编程方式。还有很多功能没有讲，但你应该可以通过查文档了解如何使用了。这只能算是我们旅程中的一站------因为随着 C++20的到来，我相信一定会有更多好用的网络开发库出现的。课后思考作为实战篇的最后一讲，内容还是略有点复杂的。如果你一下子消化不了，可以复习前面的相关内容。如果对这讲的内容本身没有问题，则可以考虑一下，你觉得 C++ REST SDK的接口好用吗？如果好用，原因是什么？如果不好用，你有什么样的改进意见？参考资料\[1\] Microsoft, cpprestsdk. slate-object="mark"}https://github.com/microsoft/cpprestsdkslate-object="mark"} \[2\] Wikipedia, "Hypertext Transfer Protocol".https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocolslate-object="mark"} \[2a\] 维基百科, "超文本传输协议".https://zh.m.wikipedia.org/zh-hans/超文本传输协议slate-object="mark"} \[3\] RESTful. slate-object="mark"}https://restfulapi.net/slate-object="mark"} \[4\] curl. slate-object="mark"}https://curl.haxx.se/slate-object="mark"} \[5\] JSON. slate-object="mark"}https://www.json.org/slate-object="mark"} \[6\] Niels Lohmann, json. slate-object="mark"}https://github.com/nlohmann/jsonslate-object="mark"} \[7\] Tencent, rapidjson. slate-object="mark"}https://github.com/Tencent/rapidjsonslate-object="mark"} \[8\] Milo Yip, nativejson-benchmark.https://github.com/miloyip/nativejson-benchmarkslate-object="mark"} \[9\] Christopher Kohlhoff, Boost.Asio.https://www.boost.org/doc/libs/release/doc/html/boost_asio.htmlslate-object="mark"} 