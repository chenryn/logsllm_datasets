 200
 300
 400
 500
 600
 700
Time (1 minute)
(b) TCP Bytes sampled every minute
Fig. 3. Comparison of traﬃc volume between the Input trace and TCPopera (1%-loss)
 1
 0.8
 0.6
 0.4
 0.2
Original
TCPopera (0.0)
TCPopera (0.01)
)
F
D
C
(
n
o
i
t
u
b
i
r
t
s
i
D
 1
 0.8
 0.6
 0.4
 0.2
Original
TCPopera (0.0)
TCPopera (0.01)
)
F
D
C
(
n
o
i
t
u
b
i
r
t
s
i
D
 0
 1e−04 0.001  0.01  0.1
 1
 10
 100  1000
 0
 1e−04 0.001  0.01  0.1
 1
 10
 100  1000
Inter−connection Time (seconds)
(a) Inter-connection time
Session Duration (seconds)
(b) Session duration
Fig. 4. Comparison of two distributional properties: Inter-connection time & Session
duration (log-scale)
On Interactive Internet Traﬃc Replay
257
playing hour) when we apply packet losses at our BSD ﬁrewall. To verify this
diﬀerence, we carefully investigated input trace records and learned that the
large amount of short-lived HTTP connections has been replayed and dropped
during the second replaying hour. 4 It is reasonable that packet losses changes
short-lived TCP connections into long-lived ones because a packet loss causes
the retransmisstion of packets. However, we believe that the main reason of the
diﬀerence was from SYN packet losses causing the failure of replaying TCP con-
nections. a SYN packet loss forces TCPopera to wait until the expiration of the
connection-establishment timer (75 seconds). This TCPopera behavior changes
traﬃc patterns after packet losses and the amount of changes grows when a
packet loss happens where the density of short-lived TCP connections is high.
The eﬀect of packet losses to TCPopera is more clear when we compare two
distributional properties, inter-connection time and session duration, as shown
in Figure 4. Both inter-connection time and session duration showed similar
distributional characteristics in that the number of samples less than 0.1 second
increases in both distributional graphs. When TCPopera experiences the delay
in the current replaying TCP connections, it reduces inter-packet time to meet
the original transmission speed of input trace records. Because of this TCPopera
behavior, the number of short-lived TCP connections increases, and the inter-
connection time is shrinking.
Eﬀectiveness test. To test the eﬀectiveness of TCPopera traﬃc, we evaluated
Snort 2.3 including the stream4 analysis. We ﬁrst ran Snort over input trace
records, and then we employed Snort into our test environment to feed TCPopera
traﬃc. For the test, we used two datasets, one is from IDEVAL99 dataset and
the other is from ITRI. Due to the space limitation, we only provide the analysis
results of the ITRI dataset in Table 2. The ITRI dataset was collected for 20
minutes from ahe host in the 140.96.114.0/24 segment. This dataset contains
various TCP applications including HTTP, FTP, and P2P(eDonkey). Because
of the space limitation, We added the test results of the IDEVAL99 dataset to
the appendix.
The ﬁrst interesting result we observed is that Snort only showed the diﬀerence
in both stream4 inspections. The Possible rxmt detection rule is originally de-
signed to capture potential packet replaying attacks. 5 As shown in Table 2, Snort
issued 5-6 times more alerts from TCPopera traﬃc than that from input trace
records. From the careful inspection on alerts, we found out that this diﬀerence
was from TCPopera’s delayed ACKs. These delayed ACKs caused the confusion
to Snort because the diﬀerence in packet processing time between Snort and
TCPopera. Figure 5 shows an example of how TCPopera traﬃc confused Snort
with delayed ACKs. While TCPopera replaying the trace in Figure 5(a), it gen-
erated two delayed ACKs as shown in Figure 5(b). Before the TCPopera node,
representing 140.96.114.96, processes the ﬁrst delayed ACK packet, it sends out
4 About 30% of connections from input trace records has been replayed during the
second replaying hour.
5 Snort generates an Possible rxmt detection alert when it observes a retransmission
of packet that has been already acknowledged.
258
S.-S. Hong and S. Felix Wu
Table 2. Test results on the ITRI dataset over various test conditions. All Snort rules
and stream 4 analysis are enabled during the test.
Signature
Number of alerts
TCPopera
Input
trace no loss 1% loss 3% loss
5
3
ICMP Destination/Port Unreachable
P2P eDonkey Transfer
ICMP Destination Unreachable
Fragmentation needed but DF bit is set
2
ICMP Destination/Host Unreachable
(stream4) Possible rxmt detection
38
(stream4) WINDOW violation detection 488
537
Total
1
5
3
1
2
212
3
226
5
3
1
2
200
1
212
5
3
1
2
181
4
196
01:20:49.403876 IP 24.7.116.14.4662 > 140.96.114.97.1134: P 376:431(55) ack 324 win 65212
01:20:49.405044 IP 140.96.114.97.1134 > 24.7.116.14.4662: P 324:326(2) ack 431 win 65105
01:20:50.723002 IP 140.96.114.97.1134 > 24.7.116.14.4662: P 324:364(40) ack 431 win 65105
(a) Input trace: The second data segment from 140.96.114.97 re-
transmits the ﬁrst data segment after repacketization
17:24:28.866305 IP 24.7.116.14.4662 > 140.96.114.97.1134: P 376:431(55) ack 324 win 65212
17:24:29.389348 IP 140.96.114.97.1134 > 24.7.116.14.4662: P 324:326(2) ack 431 win 65105
17:24:29.789172 IP 24.7.116.14.4662 > 140.96.114.97.1134: . ack 326 win 65212
17:24:30.711409 IP 140.96.114.97.1134 > 24.7.116.14.4662: P 324:364(40) ack 431 win 65105
17:24:30.733341 IP 24.7.116.14.4662 > 140.96.114.97.1134: . ack 364 win 65212
(b) TCPopera (no-loss): TCPopera sends two delayed ACKs for
both data segments from 140.96.114.97
Fig. 5. TCPdump output shows the diﬀerence caused by TCPopera’s delayed ACKs
the second data segment. However, Snort already processed the ﬁrst delayed
ACK for this connection, it interprets the second data segment as suspicious re-
transmission of the ﬁrst data segment. That is, the time diﬀerence in processing
delayed ACK packets between Snort and a TCPopera node caused false posi-
tives in the Possible rxmt detection analysis. In addition, the number of alerts is
decreasing while we increase the packet loss rate. It is because why more TCP
connections has been dropped by the failure of connection establishment.
The WINDOW violation detection rule is originally created to detect a suspi-
cious behavior to write data into the outside of the receiver’s window. In fact,
this behavior was often witnessed in the TCP implementation of Microsoft Win-
dows Operating Systems. The stream4 reassembler of Snort issues an alert if the
following condition is true.
(seq no − last ack) + data length > receiver’s window size
As shown in Table 2, we observed big diﬀerence in this rule between input
trace records and TCPopera traﬃc. After the deep-inspection on the alerts from
On Interactive Internet Traﬃc Replay
259
01:12:13.811379 IP 140.96.114.97.3269 > 220.141.33.182.4662: S 4166059610:4166059610(0) win 65535 
01:12:13.879016 IP 140.96.114.97.3269 > 220.141.33.182.4662: P 1:102(101) ack 3686742391 win 65535
01:12:14.018670 IP 140.96.114.97.3269 > 220.141.33.182.4662: P 102:142(40) ack 3686742471 win 65455
01:12:14.093459 IP 220.141.33.182.4662 > 140.96.114.97.3269: P 3686742471:3686742513(42) ack 142 win 64659
01:12:14.104423 IP 140.96.114.97.3269 > 220.141.33.182.4662: P 142:164(22) ack 3686742513 win 65413
(a) Input trace: The client (140.96.114.97) keeps sending packets without receiving any
packet from the server (220.141.33.182)
17:15:53.534364 IP 140.96.114.97.3269 > 220.141.33.182.4662: S 4166059610:4166059610(0) win 65535 
17:16:00.250345 IP 140.96.114.97.3269 > 220.141.33.182.4662: S 4166059610:4166059610(0) win 65535 
17:16:27.310699 IP 140.96.114.97.3269 > 220.141.33.182.4662: S 4166059610:4166059610(0) win 65535 
17:17:08.257095 IP 140.96.114.97.3269 > 220.141.33.182.4662: R 4166059611:4166059611(0) win 65535
(b) TCPopera (no-loss): TCPopera retransmits the ﬁrst SYN packet three times, then the
connection is reset when the connection-establishment timer expires
Fig. 6. TCPdump output where Snort generated false positives for the window viola-
tion analysis because of mishandling incomplete TCP connections
input trace records, we found out that there are only 18 legitimate alerts and
others are false positives caused by the incorrect initialization on incomplete
TCP connections.6 Figure 6 shows the TCPdump output that caused false pos-
itives in input trace records.
The problem of Snort in processing the connection in Figure 6(a) is that the
variable, last ack, used for checking the window violation condition is not prop-
erly initialized. When Snort reads the last packet in Figure 6(a),it executes the
following program segment in spp stream4.c, which mistakenly changes the lis-
tener (220.141.33.182)’s state to ESTABLISHED and thinks 3-way handshaking
is ﬁnally completed at this point. But, since last ack has never been initialized,
Snort thinks the last packet violates the condition ((4166059752 − 0) + 22 >
64659). In input trace records, there were many instances of this example and
they caused 470 false positives. In contrast, Snort did not generates this type of
false positives for TCPopera traﬃc because TCPopera could not complete the
3-way handshaking as shown in Figure 6(b).TCPopera retransmitted the ﬁrst
SYN packet until the connection-establishment timer expires and then sent the
RST packet.
switch(listener->state) {
. . . . . .
case SYN_RCVD:
if(p->tcph->th_flags & TH_ACK) {
listener->state = ESTABLISHED;
DEBUG_WRAP(DebugMessage(DEBUG_STREAM_STATE,
6 There are two reasons why snort generated relatively small number of alerts, compar-
ing to input trace records. First, delayed ACKs by TCPopera opened new window.
Second, some of TCP connections containing WINDOW violations are failed to re-
played because of SYN packet losses.
260
S.-S. Hong and S. Felix Wu
"
%s Transition: ESTABLISHED\n", l););
retcode |= ACTION_COMPLETE_TWH;
}
break;
. . . . . .
}
Yet another issue in the (stream4) WINDOW violation detection analysis is re-
lated to the RST handling. Basically, the stream4 reassembler of Snort updates the
window size even for a RST segment by executing the following program segment in
spp stream4.c. After processing the RST segment in Figure 7, the window size of the
client (ssn->client.win_size) is set to 1 because the window value of this RST seg-
ment is 1.7 Later, Snort issues an alert on the last TCP segment because the window
violation condition is true ((4226095699 − 4226095699) + 101 > 1).
17:18:18.947066 IP 140.96.114.97.3756 > 200.82.109.224.http: S 4226095698:4226095698(0) win 65535 
17:18:19.142875 IP 200.82.109.224.http > 140.96.114.97.3756: S 597332127:597332127(0) ack 4226095699 win 8000 
17:18:19.143128 IP 200.82.109.224.http > 140.96.114.97.3756: R 597332128:597332128(0) win 1
17:18:19.143891 IP 140.96.114.97.3756 > 200.82.109.224.http: . ack 1 win 65535
17:18:19.144149 IP 140.96.114.97.3756 > 200.82.109.224.http: P 1:102(101) ack 1 win 65535
Fig. 7. TCPdump output from one of examples of false positives in TCPopera traﬃc
if((direction = GetDirection(ssn, p)) == SERVER_PACKET){
p->packet_flags |= PKT_FROM_SERVER;
ssn->client.win_size = ntohs(p->tcph->th_win);
DEBUG_WRAP(DebugMessage(DEBUG_STREAM,
"server packet: %s\n", flagbuf););
}
else{
p->packet_flags |= PKT_FROM_CLIENT;
ssn->server.win_size = ntohs(p->tcph->th_win);
DEBUG_WRAP(DebugMessage(DEBUG_STREAM,