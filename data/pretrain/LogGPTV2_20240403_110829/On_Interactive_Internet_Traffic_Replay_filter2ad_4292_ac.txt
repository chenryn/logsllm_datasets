### 优化后的文本

#### 图3. 输入流量与TCPopera（1%丢包）之间的流量体积比较
- **时间 (分钟)**
  - 200
  - 300
  - 400
  - 500
  - 600
  - 700

- **(b) 每分钟采样的TCP字节数**

**图3**展示了输入流量与TCPopera（1%丢包率）之间的流量体积对比。 

---

#### 图4. 两个分布特性：连接间隔时间和会话持续时间（对数尺度）
- **(a) 连接间隔时间**
- **(b) 会话持续时间**

**图4**展示了两种分布特性：连接间隔时间和会话持续时间的比较，使用了对数尺度。

---

### 在交互式互联网流量重放中的观察

在应用BSD防火墙上的数据包丢失时，我们在第二次重放期间观察到了显著差异。为了验证这一差异，我们仔细检查了输入流量记录，并发现大量短生命周期的HTTP连接在第二次重放期间被重新播放并丢弃。大约30%的连接在第二次重放期间被重新播放。数据包丢失将短生命周期的TCP连接变为长生命周期的原因在于数据包丢失会导致重传。然而，我们认为主要原因是SYN数据包丢失导致TCP连接无法成功建立。SYN数据包丢失迫使TCPopera等待连接建立定时器（75秒）到期。这种行为改变了数据包丢失后的流量模式，并且当短生命周期TCP连接密度较高时，变化幅度更大。

从**图4**中可以看出，连接间隔时间和会话持续时间都显示出类似的分布特征，即小于0.1秒的样本数量增加。当TCPopera遇到当前重放TCP连接的延迟时，它会减少包间时间以匹配输入流量记录的原始传输速度。因此，短生命周期TCP连接的数量增加，连接间隔时间缩短。

### 有效性测试

为了测试TCPopera流量的有效性，我们评估了包括stream4分析的Snort 2.3。首先，我们在输入流量记录上运行了Snort，然后在我们的测试环境中使用TCPopera流量进行测试。我们使用了两个数据集，一个是IDEVAL99数据集，另一个是ITRI数据集。由于篇幅限制，我们仅提供了ITRI数据集的分析结果（见**表2**）。ITRI数据集是从140.96.114.0/24网段的一个主机收集的20分钟数据，包含各种TCP应用，如HTTP、FTP和P2P（eDonkey）。IDEVAL99数据集的结果已添加到附录中。

第一个有趣的观察结果是，Snort在两次stream4检查中显示了差异。"Possible rxmt detection"规则最初设计用于捕获潜在的数据包重放攻击。如**表2**所示，Snort从TCPopera流量中发出的警报比从输入流量记录中发出的警报多5-6倍。通过仔细检查这些警报，我们发现这种差异是由TCPopera的延迟ACK引起的。这些延迟ACK导致了Snort的混淆，因为Snort和TCPopera之间的数据包处理时间存在差异。**图5**展示了一个例子，说明了TCPopera流量如何通过延迟ACK使Snort产生混淆。

此外，我们还观察到"WINDOW violation detection"规则在输入流量记录和TCPopera流量之间存在显著差异。经过深入检查，我们发现输入流量记录中的大部分警报是由于不完整的TCP连接初始化错误导致的假阳性。**图6**展示了其中一个例子。Snort在处理**图6(a)**中的连接时，变量`last ack`未正确初始化，导致了窗口违规条件的误判。相比之下，TCPopera未能完成三次握手，从而避免了这种类型的假阳性（见**图6(b)**）。

另一个问题与RST处理有关。Snort的stream4重组器即使对于RST段也会更新窗口大小。**图7**展示了这种情况下的一个例子。处理完RST段后，客户端的窗口大小被设置为1，随后Snort在最后一个TCP段上发出了警报，因为窗口违规条件成立。

```c
if((direction = GetDirection(ssn, p)) == SERVER_PACKET){
    p->packet_flags |= PKT_FROM_SERVER;
    ssn->client.win_size = ntohs(p->tcph->th_win);
    DEBUG_WRAP(DebugMessage(DEBUG_STREAM,
    "server packet: %s\n", flagbuf););
} else {
    p->packet_flags |= PKT_FROM_CLIENT;
    ssn->server.win_size = ntohs(p->tcph->th_win);
    DEBUG_WRAP(DebugMessage(DEBUG_STREAM,
    "client packet: %s\n", flagbuf););
}
```

总之，通过这些测试，我们发现了TCPopera在处理延迟ACK和窗口违规检测方面的一些问题，并提出了相应的解释和解决方案。