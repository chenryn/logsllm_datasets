# 【缺陷周话】第20期：无符号整数回绕
##### 译文声明
本文是翻译文章
译文仅供参考，具体内容表达以及含义原文为准。
## 1、无符号整数回绕
在[第17期缺陷周话](http://mp.weixin.qq.com/s?__biz=MzI2NTg4OTc5Nw==&mid=2247488902&idx=1&sn=41b5ea3d26d9ad42b057f32b2a736c9a&chksm=ea9724ecdde0adfaa2a696182a95bce0563675467a5881bf94500344d910cc16a3e10807f377&scene=21#wechat_redirect)中，曾经对有符号整数溢出问题进行了分析，本期来聊一聊
C/C++ 整数类型中的无符号整数使用不当所导致的问题。首先我们来看一下无符号整数的取值范围，下表中列出ANSI标准定义的无符号整数类型及范围。
类型 | 位数 | 最小取值范围  
---|---|---  
unsigned int | 16/32 | 0~65535  
unsigned short int | 16 | 0~65535  
unsigned long int | 32 | 0~4294967295  
unsigned long long int | 64 | 264-1  
C99第6.2.5节的第9条规定：涉及无符号整数的计算不会产生溢出，而是当数值超过无符号整数的取值范围时会发生回绕。如：无符号整数的最大值加1会返回0，而无符号整数最小值减1则会返回该类型的最大值。造成无符号整数运算回绕的操作符有“+”、“-”、“*”、“++”、“–”、“+=”、“-=”、“*=”、“ （1）当函数的参数类型为无符号整数时，需要对传入的参数的值进行有效判断，避免直接或者经过运算后产生回绕；
>
> （2）不可信源的数据仍旧需要格外注意，应对来自不可信源的数据进行过滤和限制；
>
> （3）使用源代码静态分析工具进行自动化的检测，可以有效的发现源代码中的无符号整数回绕问题。