调用缓存。
下面这个例子之前也出现过，只是现在添加了/o：
my $today = (qw) [(localtime)[6]];
while (){
if(m/^stoday:/io){
这个表达式要快得多，因为从第二次开始的每轮循环中，正则表达式都忽略了$today。不
需要插值，也不需要预处理和重新编译正则表达式，能够节省大量的时间，而这是Perl无
法自动完成的，因为使用了变量插值，Stoday可能会变化，所以为了安全，Perl必须每次
都检查。使用/o就告诉Perl，在第一次预处理和编译完成之后“锁定”这个表达式。因为
我们知道，插值变量是不变的，即使变化了，也不希望使用新值，所以这样做完全没问题。
/o的潜在“陷阱”
在使用/o时，有个重要的“陷阱”必须要注意。例如下面这个函数：
sub CheckLogfileForToday()
my $today = (qw)[(localtime) [6]];
while ()(
if（m/^Stoday：/io）（#危险-这里要小心
记住，/o表示正则运算元只需要编译一次。第一次调用CheckLogfileForToday（）时，代
表当天日期的正则运算元就锁定在其中。如果过了一段时间再次调用这个函数，即使stoday
变化了，也不会重新检查：在程序执行过程中，每次使用的都是最开始锁定在其中的正则
表达式。
---
## Page 379
效率
353
这个问题很严重，不过下一节中，regex对象提供了两全其美的解决办法。
用regex对象提高效率
迄今为止，我们看到的所有关于预处理的讨论都适用于正则文字。其自的在于花尽可能少
的工夫获得编译好的正则表达式。达到此目的的另一个办法是使用regex对象，把编译好的
正则表达式封装在变量内部供程序使用。可以使用qr/…/创建regex对象（303）。
下面是使用regex对象的例子：
sub CheckLogfileForToday()
my$RegexObj=qr/^Stoday:/i；#每次调用编译一次
while (){
if （$_=~$RegexObj）(
，
每调用一次函数，就会创建一个新的regex对象，但是之后它只是直接用于log文件的每一
行。如果regex对象用做运算元，它不会进行前面介绍的任何预处理。预处理是在regex对
象创建而不是使用时进行的。可以把regex对象想象为“自动设定的正则缓存”，这个编译
好的表达式可以在任何地方使用。
这个办法兼具了两方面的优点：它效率高，因为只有在每次函数调用（而不是log文件的每
一行）时才会编译，但是，与之前错误使用/o的例子不同，即使多次调用checkLogfile
ForToday（），也没有问题。
需要弄清楚的是，这个例子中出现了两个正则运算元。正则运算元qr/…/并不是一个regex
对象，但能从接收的正则文字创建regex对象。然后这个对象用作循环中match运算符=-
的运算元。
regex对象配合m/.../
这段程序：
if（S_=~$RegexObj）{
也可以这样写：
if（m/$RegexObj/){
---
## Page 380
354
第7章：Perl
此时已经不是普通的正则文字了，尽管看上去没有区别。“正则文字”的内容就是regex对
象，它与直接使用regex对象一样。这种做法的好处在于：m/…/更为常见，更容易使用。
也不用明确指定目标字符串S_，方便与其他使用同样默认变量的运算符结合。最后一个原
因是，这样我们能够对regex对象使用/g。
/o配合qr/../
/o修饰符可以配合qr//，但在这里你肯定不希望如此。就像用/o配合其他任何正则运算
符一样，qr/…/o在第一次使用正则表达式时就会进行锁定，所以如果这样写，无论stoday
如何变化，每次调用这个函数sRegexObj使用的都是同样的regex对象。这与第352页的
m/../o的问题一样。
依靠默认表达式提高效率
正则运算符的默认表达式（308）可以提高效率，尽管使用regex对象可能更划算。不过
我还是会简要介绍一番。例如：
sub CheckLogfileForToday()
{
#直到匹配为止，设置默认表达式
"Sun:"=~m/^$today:/i or
"Mon:"=~m/^$today:/i or
"Tue:”=~m/^$today:/i or
*Wed:"=~m/^Stoday:/ior
"Thu:*=m/~$today:/i or
"Fri:"=~m/^$today:/i or
"Sat:*=m/~$today:/i;
while (){
if（m//）（#使用默认的表达式
使用默认正则表达式的关键在于，只有匹配成功才会设置默认值，所以Stoday设置之后还
有长长的代码。你已经看到，这相当不美观，所以我不推荐这么做。
---
## Page 381
效率
355
理解“原文”副本
UInderstanting the“Pre-Match”Copy
在匹配和替换时，Per1有时必须动用额外的空间和时间来保存目标字符串在匹配之前的副
本。我们会看到，有时这个副本会用于支持重要特性，有时则不会。应该尽量避免不会用
到的副本，提高效率，尤其是在目标字符串很长，或者速度非常重要的情况下更是如此。
下一节我们会讲解何时以及为什么Perl可能会保存目标字符事的原文副本，什么时候用到
副本，以及在效率极端重要时，如何取消这个副本来提高效率。
通过原文副本支持S1、S&、S’、$+
对于match或者substitution操作的目标字符事，Perl会生成一个原文副本，以支持s1、$&
之类匹配后的变量（299）。每次匹配完成之后，Perl不会实际生成这些变量，因为许多变
量（还有可能是所有）根本不会被程序用到。相反、Perl只是保存原始字符串的副本，记住
各种匹配发生在原来文本中的位置，在使用$1之类变量时通过位置来引用。这种办法不错，
工作量小，因为多数情况下都不会用到某些甚至全部的匹配后的变量。这种“延迟求值（lazy
evaluation）”能避免许多不必要的工作。
尽管延迟创建S1之类的变量能够节省工作量，但保存目标字符串的副本仍然需要成本。而
这是必要的吗？为什么不能直接使用原来的文本？请参考：
$Subject=~s/^(?:Re:\s*)+//;
这样，$&正确地引l用了$Subject中删除的文本，但因为它已经从sSubject中删除，在后
面用到s&时，Perl不能从sSubject中引I用这段文本。下面的代码情况相同：
if ($Subject =~m/^SPAM:（.+)/i）（
$Subject="--spam subject removed --";
$SpamCount{$1}++;
引l用s1时，原来的sSubject已经删除了。所以，Perl必须保存原文副本。
原文副本井非时时必须
在实践中，原文副本的主要“用户”是S1、$2、$3之类的变量。但是如果正则表达式不包
---
## Page 382
356
第7章：Perl
含捕获型括号呢？那样就不必担心$1之类了，所以完全不必考虑如何支持它们。所以至少，
不包含捕获型括号的正则表达式可以不必保存拷贝？答案是未必。
不宜使用的变量：S、$&和s
$、$&、S这三个变量与捕获型括号无关。它们分别对应到匹配文本之前的部分，匹配文本
和匹配之后的部分，其实可以应用于每一次match和substitution。Peri不能预先知道某个匹
配中是否会用到这些变量，所以每次都必须保存原文副本。
听起来，似乎没有办法省略副本，但是Perl足够聪明，它能够认识到，如果这些变量不会
出现在程序中，就根本没必要（甚至在任何可能用到的library之中）保存副本来提供支持。
所以，如果没有用到捕获型括号，再避免出现s"、$&和S'就能省略原文副本一一这是很的
优化！只要在程序中的任何一处用到了S、$&和S三者之一，整个优化即告失效。这可不够
意思！所以，我认为这些变量是“不宜使用（naughty）”的。
原文副本的代价有多高
我进行了简单的性能测试，对Perl源代码的130000行C程序中的每-行检查m/c/。这个
性能测试仅仅检测哪一行出现了字符c’。测试的目的是衡量原文副本的影响。我用两种
方法进行测试：一种肯定没有用到原文副本，一种肯定用到了。因此，唯一的区别就在于
保存副本的开销。
保存原文副本的程序所用的时间要长40%。这代表了“平均最差情况”，这样说是因为性能
测试并没有进行什么实质性的操作，否则二者之间的时间相对比例会减小（甚至显得微不
足道）。
另一方面，在真正的最坏情况下，额外副本可能真的占据非常重要的比重。我对同样的数
据运行同样的程序，但是这次将所有超过3.5MB的数据都放在一行中，而不是长度合适的
130000行。这样就能比较单次匹配的相对表现。不使用原文副本的匹配几乎是立刻就得到
了结果，因为第一个‘e’字符离开头不远，匹配之后程序就运行结束。而使用原文副本的
程序运行原理差不多，只是它会首先拷贝整个字符串。它所用的时间大约是前者的7000倍。
因此我们知道，避免使用某些结构能够提高效率。
---
## Page 383
效率
357
避免使用原文副本
如果Perl能够领会程序员的意图，只在需要的情况下保存副本，当然很好。但请记住，这
些副本并不是“败笔”—Perl在幕后处理这些繁琐事务是我们选择Perl，而不是C或者汇
编语言的原因。事实上，Perl最初只是为了把用户从繁杂的机制中解放出来，这样他们只需
要关注问题的解决方案就好了。
永远不要使用不宜使用的变量。同样，尽可能避免额外的工作也是不错的。首先想到的就
是，永远不要在代码中使用s`、$&和S。通常，S&很容易消除一把正则表达式包围在一个
捕获型括号内，然后使用S1即可。举例来说，把HTMLtag转换为小写时，不使用
8//\LS&\B/g，而使用8/()/\L$1\E/g。
如果保存了原始目标字符串，就可以很容易地模拟s和s。匹配某个target字符串之后，可
以按下面的规则来模拟：
变量
模拟方式
substr(target,0,$-[o])
$&
substr(target,$-[o],$+[0]-$-[0])
（[]+s）xsqns
因为-和@+（302）保存的是原始目标字符串中的位置，而不是确切的文本，使用它们不需
要担心效率问题。
我还给出了$&的模拟。相对使用捕获型括号和$1的办法，这可能是一个更好的办法，这样
完全不必使用任何捕获型括号。请记住，避免使用$&之类变量的目的就在于，如果表达式
中没有出现捕获型括号，要避免保存原始副本。如果修改程序，去掉$&，再对每个匹配都
增加捕获型括号，就不会节省任何时间。
不要使用不宜使用的模块。当然，避免S、$&、S'也意味着避免使用调用它们的模块。Perl
的核心模块中，除English之外都没有使用它们。如果你希望使用English模块，可以这
样：
use English '-no_match_vars';
这样就没有问题了。如果你从CPAN或者其他地方下载了模块，你可能需要检查一番，看
看它们是否使用了这些变量。请参考下一页的补充内容，里面有些诀窍，告诉你如何判断
程序是否用到了这些变量。
---
## Page 384
358
第7章：Perl
如何检查代码是否包含S&
判断程序是否使用了不宜使用的变量S、S&和S'，并不是件容易的事情，尤其使用库函
数时更是如此，但还是有几个办法来判断。最简单的是，如果你的二进制程序在编译
时指定了-DDEBUGGING参数，就可以使用-c和-Mre=debug参数（361）、观察输出
的结尾，找到包含‘EnablingS`、$&和S’eupport’或者‘Omitting$`，$&和$'、Bupport
的那一行。如果见到前面的文宇，就表示使用了这些变量。
另一种可能（但不太现实）的情况是，程序在eVal语句中使用了这些变量，如果没
有实际运行，Perl不知道的是否使用了这些变量。解决办法之一就是安装CPAN
(http://www.cpan.org）的 Devel:SawAmpersand Package:
END
require Devel::SawAmpersand;
if (Devel::SawAmpersand::sawampersand) {
与Devel：：SawAmpersand一起的还有Devel：：FindAmpersand，这个package 能够告
诉用户有问题的代码的位置。不幸的是，对最新版本的Perl，它不能保证完全正确。
这两个package的安装都不简单，所以要做的事没准很多（请参考http://regex.info/查
找可能的更新）。
用查找性能损失的办法找出问题代码的办法也值得一看：
use Time::HiRes;
sub CheckNaughtiness ()
myStext=‘x’x10_000；#创建一定量的数据
#计算纯循环的开销
my Sstart = Time::HiRes::time() ;
for（my$i=0:$i$overhead*5)？"naughty":"clean",$overhead,Sdelta;
---
## Page 385
效率
359
Study函数
TheStudyFunction
与优化正则表达式本身不同，study（）优化了对特定字符串的某些检索。一个字符串在
study之后，应用到它的（一个或多个）正则表达式可以从缓存的分析数据中受益。一般
是这样使用的：
while (<>)
study（SR）：#匹配之前Study联认的目标宇符串S_
if (m/regex 1/)("}
if (m/regex 2/)(…}
if (m/regex 3/)( }
if (m/regex 4/)()
，
study的作用很简单，但是理解它什么情况下有价值却不简单。它不会影响到程序的任何
值和任何结果，唯一的影响就是，Perl会使用更多的内存，总的执行时间可能会增加，保持
不变，或者减少（这是我们预期的）。
study一个字符串时，Perl会分配时间和内存来记录字符串中的一系列位置（在大多数系统
中，需要的内存是字符串大小的4倍）。在字符串修改之前，针对此字符串的每次匹配都可
以从中受益。对字符事的任何修改都会导致study数据的失效，相当于study另-一个字符
串。
Study能给目标字符串提供的帮助，很大程度上取决于用来匹配的正则表达式，以及Perl
能够使用的优化。例如用m/foo/检索文本，如果使用了study，速度会提升很多（如果字
符串更长，甚至可能提高10000倍）。但是，如果使用了/i，就不会有这种效果，因为/i