title:Server-aided signatures verification secure against collusion attack
author:Sherman S. M. Chow and
Man Ho Au and
Willy Susilo
Server-Aided Signatures Veriﬁcation
Secure against Collusion Attack
Sherman S. M. Chow
University of Waterloo
Ontario, Canada
PI:EMAIL
Man Ho Au
University of Wollongong
Australia
PI:EMAIL
Willy Susilo
University of Wollongong
PI:EMAIL
Australia
ABSTRACT
Wireless handheld devices which support e-mail and web
browsing are increasingly popular. The authenticity of the
information received is important, especially for business us-
es.
In server-aided veri(cid:12)cation (SAV), a substantial part
of the veri(cid:12)cation computation can be o(cid:15)oaded to a pow-
erful but possibly untrusted server. This allows resource-
constrained devices to enjoy the security guarantees provid-
ed by cryptographic schemes, such as pairing-based signa-
tures, which may be too heavyweight to verify otherwise.
To gain unfair advantage, an adversary may bribe the
server to launch various kinds of attacks { to convince that
an invalid signature held by a client is a valid one (say for
providing false information or repudiable commitment) or to
claim that a valid signature is invalid (say for spoiling the
o(cid:11)er provided by an opponent). However, these concerns
are not properly captured by existing security models.
In this paper, we provide a generic pairing-based SAV pro-
tocol. Compared with the protocol of Girault and Lefranc
in Asiacrypt ’05, ours provides a higher level of security
yet applicable to a much wider class of pairing-based cryp-
tosystems. In particular, it suggests SAV protocols for short
signatures in the standard model and aggregate signatures
which have not been studied before.
Categories and Subject Descriptors
C.2.4 [Computer-Communication Networks]: Distribut-
ed Systems; K.6.5 [Management of Computing and In-
formation Systems]: Security and Protection
General Terms
Security
Keywords
server-aided computation, collusion attack, authenticity, sig-
natures, pairings, delegation, weak computational device
Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proﬁt or commercial advantage and that copies
bear this notice and the full citation on the ﬁrst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciﬁc
permission and/or a fee.
ASIACCS ’11, March 22–24, 2011, Hong Kong, China.
Copyright 2011 ACM 978-1-4503-0564-8/11/03 ...$10.00.
Keywords
server-aided computation; pairings; signatures; delegation;
1.
INTRODUCTION
Server-aided computation protocols are protocols in which
a device, also called the client, o(cid:15)oads the computation to a
server. Nowadays, there are many computation devices with
relatively limited power, e.g., smart card, RFID tag, but
need to perform cryptographic operations which are both
time and power consuming. Server-aided computation pro-
tocols are particularly useful since these devices often have
access to a more powerful device which can act as the server.
1.1 Server-Aided Computation of Pairing
Bilinear pairing is an enabling technology for construct-
it al-
ing next-generation cryptosystems. On one hand,
lows the construction of novel cryptographic application-
s that are otherwise di(cid:14)cult or impossible to build based
on other primitives. On the other hand, it also facilitates
the construction of some highly e(cid:14)cient cryptographic solu-
tions which are particularly appealing for computationally-
limited devices. Pairing is currently instantiated on ellip-
tic curves. The use of elliptic curves leads to a shorter-
representation of the cryptographic group elements, so many
pairing-based schemes can be made space-e(cid:14)cient. An ever
increasing number of protocols have been appearing in the
literature since its introduction in constructing cryptograph-
ic schemes. Some of which have a very simple design (e.g.,
[3] and [2]) when compared with non-pairing constructions.
While these schemes may o(cid:11)er high e(cid:14)ciency in terms of
bandwidth or storage requirement, they often require rela-
tively heavyweight cryptographic operations. To enjoy the
features made possible by cryptography, one may resorting
to a symmetric-key solution instead of a public-key one (e.g.,
[7]), or employ tricks such as precomputation (e.g., [5]). In
this paper, we study the approach of server-aided computa-
tion, with focus in signature veri(cid:12)cation.
1.2 Collusion Attack
Server-aided computation should not introduce new vul-
nerability to the application. This is true if the server is
fully-trusted and there exists a secure channel between it
and the client.
In this case the client can simply o(cid:15)oad
the computation to the server. Unfortunately, this trust
assumption is not realistic.
In reality, the client could be
facing a malicious server, or the client cannot establish an
authenticated connection with a trusted server easily. (Au-
thenticated connection can be established by cryptographic
401
means, which leads to a chicken-and-egg situation). More-
over, concerns with con(cid:12)dentiality arise when the operation
involves some private information from the client (e.g., de-
cryption or signing which uses the client’s private key) or
when the operation result gives the basis for the client to
make a decision whether the integrity of some information
(e.g., via digital signature) has been tampered or not.
Wireless handheld devices which support push e-mail, tex-
t messaging, and web browsing are increasingly popular for
business uses. For examples, roaming employees can re-
sponse quickly to their colleagues, and traders can always
get update information of the exchange market.
In these
scenarios, it is important to verify the authenticity of the
messages received. It is also undesirable if a malicious serv-
er can falsely claim that a valid signature is an invalid one,
which e(cid:11)ectively denies the client from receiving legitimate
message. This attack may be motivated by a unfair prof-
it gain, say a bid from a competitor of an attacker can be
\made" invalid and now this attacker can supply another
bid.
1.3 Existing Work
In the work of Girault and Lefranc [9], some security re-
quirements of server-aided veri(cid:12)cation are formalized. T-
wo existing protocols are then analyzed in their model and
a new one for a limited class of pairing-based signature
schemes has been introduced (speci(cid:12)cally, schemes where
the veri(cid:12)cation requires only comparisons against a (cid:12)xed
element ^e(g; g)). In their model, a malicious server is not
allowed to collude with the signer. In particular, the secu-
rity of the protocol relies that the malicious server is not
given any valid signature on that message. Subsequently,
Wu et al. [13] proposed a SAV protocol for Boneh-Lynn-
Shacham signature [3] since it is not covered in the previous
semi-generic construction. Wu et al. also observed that the
security model of Girault and Lefranc [9] does not allow an
adversary to interact with the client via the aided veri(cid:12)ca-
tion protocol, and consequently devised an attack of their
protocol by exploiting this weakness. However, this attack
actually assumes the server to be deviated from the speci-
(cid:12)cation of the aided veri(cid:12)cation protocol, which is di(cid:11)erent
from the models considered in [9, 13]. On the other hand,
Wu et al. [13] proposed a security model aimed to capture
the collusion of the signer with the server. Recently, [12]
criticized the model of [13] and proposed a new one. We
found that these two models may not model the collusion
attack well. In particular, they do not address the situation
when the attacker is in fact in possession of the private key
of the signer. For example, a malicious signer, after created
an invalid signature, may collude with the server and try
to convince the client to accept this maliciously generated
signature.
2. PRELIMINARIES
For a (cid:12)nite set S, x ∈R S means choosing an element x
uniformly at random from S. For algorithms A1 and A2, we
use out $← A1(in) to denote that out is the result of running
A1 on input in, and out1 ← A1(in1) ↔ A2(in2) to denote
that out1 is the (cid:12)nal output of algorithm A1 with local input
in1 after interacting with algorithm A2 with local input in2.
2.1 Framework for Server-Aided Veriﬁcation
Definition 1. A signature scheme (Setup; KeyGen; Sign;
Verify) with server-aided veri(cid:12)cation is one equipped with a
VStetup algorithm and an AidedVerify protocol.
• VStetup is a probabilistic algorithm executed by a ver-
i(cid:12)er which takes a security parameter 1(cid:21) and outputs
some veri(cid:12)cation parameter VString.
• AidedVerify is an interactive protocol between a veri-
(cid:12)er and a server. The input of the veri(cid:12)er includes
VString generated by VStetup, a message/signature
pair (m; (cid:27)) obtained from a signer and the public key
pk of the signer. As a result of the protocol, the veri(cid:12)er
outputs ⊤ i(cid:11) (cid:27) is a valid signature on m under pk, ⊥
otherwise. The server has no local output.
In this paper we give a more (cid:12)ne-grained de(cid:12)nition.
Definition 2. Our de(cid:12)nition of algorithms for server-
aided veri(cid:12)cation are re(cid:12)ned as below.
1. VString can be partitioned into private/public veri(cid:12)-
cation parameters ((cid:28); (cid:0)), i.e., ((cid:28); (cid:0)) $← VStetup(1(cid:21)).
2. AidedVerify is split into a pair of interacting multi-
stage algorithms AidedVerifyc and AidedVerifys, which
denotes the respective part of the AidedVerify protocol
executed by a client and a server.
Definition 3. Correctness of a signature scheme with
server-aided veri(cid:12)cation requires that for all (cid:21) ∈ N, all Param
given by Setup(1(cid:21)), all (sk; pk) given by KeyGen(), and al-
l VString given by VStetup(1(cid:21)), we have Verify(pk; (cid:27); m) =
; pk; VString) ↔ AidedVerifys((cid:0)) holds for
AidedVerifyc(m
all m in the message space and (cid:27) in the signature space.
2.2 Existential Unforgeability
; (cid:27)
∗
∗
The work of Wu et al. [13] gives two security de(cid:12)nition.
The (cid:12)rst one is an extension of the existential unforgeability
against adaptive chosen message attack of a standard sig-
nature scheme. Below gives our de(cid:12)nition of unforgeability
that will be used throughout this paper. This is based on the
de(cid:12)nition of Wu et al. with adjustments to be elaborated.
Definition 4. A server-aided veri(cid:12)cation of signatures
protocol is (t; qs; qv)-existentially unforgeable under adaptive
chosen message and veri(cid:12)cation attacks (EUF-CMVA) if
for all probabilistic polynomial time adversary A which runs
within time t wins the following game with negligible proba-
bility in a security parameter (cid:21).
Setup. The challenger C runs the algorithms Setup, KeyGen
and VStetup to obtain the system parameter Param, a
key pair (sk; pk) and the veri(cid:12)cation private/public pa-
rameter VString = ((cid:28); (cid:0)) respectively. The adversary
A is given Param, pk and (cid:0), while (cid:28) and sk are with-
held from A.
Query. A can adaptively make at most qs OSign queries
and at most qv OAidedVer queries.
• In an OSign query, A supplies a message m. C
puts m into a set M and responses with Sign(sk; m).
• In an OAidedVer query, A starts by supplying a