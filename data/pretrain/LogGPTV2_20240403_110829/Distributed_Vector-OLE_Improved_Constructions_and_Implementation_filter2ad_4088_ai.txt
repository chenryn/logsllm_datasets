(1ğœ†, ğ‘›, ğ‘–), ğ‘Ÿ(cid:1). Note that
in Definition A.1.
ğ‘ = 2. Sample ğ‘Ÿ
this distribution is the same as the right side of Eq. (3). There-
fore, any distinguisher of the two sides of Eq. (1) could be
used to distinguish the distributions in Eq. (3) by choosing a
ğ›½ â† G and replacing ğ‘£1
ğ‘– in Eq. (3) by ğ›½ âˆ’ ğ‘£1
ğ‘– .
Theorem A.6. Steps (1)â€“(6) in Protocol 3 together implement
SPFSS.Gen(1ğœ†, ğ‘“ğ‘–,ğ›½) from Functionality 8 with security against semi-
honest adversaries, where ğ‘– is input by P2 and ğ›½ is secret-shared
between the two parties.
Proof. We first prove that Protocol 3 is secure in the (ğ‘› âˆ’
1)-out-of-ğ‘›-ROT-hybrid model when all calls to ROT.Gen are per-
formed by the ideal Functionality 7. We construct simulators Simğ‘
for ğ‘ âˆˆ {1, 2} for the views of both parties in the ideal model.
ğ‘ = 1. The only messages received by P1 come from the execution
ğ‘ = 2. Here, in addition to the output of ROT.Gen, P2 receives ğ‘…ğ›½.
In the (ğ‘› âˆ’ 1)-out-of-ğ‘›-ROT-hybrid model, this simulated
view is distributed identically to the real view.
Simulate this with ğ›½2 âˆ’ Ëœğ‘Ÿ +ğ‘— âˆˆ[ğ‘›]\{ğ‘–} SPFSS.Eval(2, ğ¾2, ğ‘—).
of ROT.Gen, and thus Sim1 is the identity function.
To prove security in the plain model, we again use the modular com-
position theorem for semi-honest security together with a secure
protocol for ROT.Gen, as proven in Theorem A.3
â–¡
A.3 Known-Indices MPFSS
We will now prove security of our batched FSS implementation.
However, as discussed in Section 5, there is a small probability that
the batching fails (note that this is also the case for the heuristic
batch code construction suggested by Boyle et al. [9]). Here we
have two options if batching fails: We could abort the key genera-
tion, sacrificing security as this leaks some information about the
non-zero indices that failed to be batched; or we could sacrifice
correctness by returning keys that will result in shares of zeros for
some indices that should be non-zero. Both are valid approaches
depending on the concrete application, as also discussed in [1, 15].
For our VOLE construction, we will opt for the second choice, since
this will allow us to achieve the same security guarantee as Boyle
et al. [9], i.e., our scheme is either secure under standard LPN (if
batching succeeds), or under a slightly stronger variant of LPN (if
batching fails). See also the discussion in Section 6. We will not
mention this explicitly in the following definitions and proofs, but
whenever cuckoo hashing is performed, we assume that failures are
handled by dropping indices that would result in a hashing failure.
Definition A.7 (Known-Indices MPFSS). For any ğ‘¡, ğ‘› âˆˆ N, let F =
(cid:8)ğ‘“i,ğœ· : [ğ‘›] â†’ G(cid:9) be a class of multi-point functions, where i âˆˆ [ğ‘›]ğ‘¡,
ğœ· âˆˆ Gğ‘¡, and
(cid:26) ğ›½ ğ‘—
0
ğ‘“i,ğœ· (ğ‘¥) =
if ğ‘¥ = ğ‘– ğ‘— for some ğ‘— âˆˆ [ğ‘¡],
otherwise.
Let further ğœ‚, ğœ† âˆˆ N denote statistical and computational security pa-
rameters, respectively. A Known-Indices Multi-Point Function Secret
Sharing (Known-Indices MPFSS) scheme consists of the following
two algorithms:
â€¢ (ğ¾1, ğ¾2) â† MPFSS.Gen(1ğœ†, ğœ‚, ğ‘“ ) â€“ given a description of
â€¢ ğ‘“ğ‘(ğ‘¥) â† MPFSS.Eval(ğ‘, ğ¾ğ‘, ğ‘¥) â€“ given a key for party ğ‘ âˆˆ
ğ‘“ âˆˆ F , outputs two keys.
{1, 2} and an input ğ‘¥ âˆˆ [ğ‘›], return a share of ğ‘“ (ğ‘¥).
â–¡
Where the following properties have to be satisfied:
17
Functionality 9: Known-Indices MPFSS
Key Generation (MPFSS.Gen(1ğœ†, ğœ‚, ğ‘“i,ğœ·)):
Let [ğ‘›] denote the domain of ğ‘“i,ğœ·, and ğ‘¡ the number of
non-zero points.
(1) Choose parameters (ğœ…, ğ‘š) â† ParamGen(ğ‘›, ğ‘¡, ğœ‚) for a
ğ‘— âˆˆ[ğ‘¡], where ğ‘™ ğ‘— is the location of ğ‘– ğ‘— in ğ‘‡ .
cuckoo hashing scheme such that hashing any ğ‘¡ indices
from [ğ‘›] fails with probability at most 2âˆ’ğœ‚.
(2) Perform Steps (1) and (2) from Protocol 4, i.e., choose ğœ…
random hash functions and use them to insert (ğ‘–1, . . . , ğ‘–ğ‘¡)
into a cuckoo hash table ğ‘‡ , and simple-hash the
domain [ğ‘›]. Let posğ‘™ be defined as in Protocol 4.
Compute v âˆˆ Gğ‘š, where
(3) Let u =(cid:0)(ğ›½ ğ‘— , ğ‘™ ğ‘—)(cid:1)
(cid:26) ğ‘
2(cid:1)(cid:17)
obtain ğ‘š sets of keys(cid:16)(cid:0)ğ¾ğ‘™
(cid:17) for ğ‘ âˆˆ {1, 2}.
(cid:16)(cid:0)â„ğ‘(cid:1)
(cid:1)
ğ‘âˆˆ[ğœ…],(cid:0)ğ¾ğ‘™
(cid:17) and output
Parse ğ¾ğ‘ as(cid:16)(cid:0)â„ğ‘(cid:1)
ğ‘âˆˆ[ğœ…],(cid:0)ğ¾ğ‘™
(cid:1)
ğ‘=1 SPFSS.Eval(cid:0)ğ‘, ğ¾
, posâ„ğ‘ (ğ‘¥)(ğ‘¥)(cid:1).
ğœ…
(5) Output ğ¾ğ‘ =
Expansion (MPFSS.Eval(ğ‘, ğ¾ğ‘, ğ‘¥)):
ğ‘™âˆˆ[ğ‘š]
(4) Call SPFSS.Gen ğ‘š times as in Step (4) from Protocol 4 to
if (ğ‘, ğ‘—) âˆˆ u,
otherwise.
ğ‘
â„ğ‘ (ğ‘¥)
ğ‘
ğ‘™âˆˆ[ğ‘š]
ğ‘™âˆˆ[ğ‘š]
1, ğ¾ğ‘™
ğ‘£ ğ‘— =
0
ğ‘
Correctness. For any ğ‘“ âˆˆ F , and any ğ‘¥ âˆˆ ğ¼, when (ğ¾1, ğ¾2) â†
MPFSS.Gen(1ğœ†, ğœ‚, ğ‘“ ), we have
(cid:35)
MPFSS.Eval(ğ‘, ğ¾ğ‘, ğ‘¥) = ğ‘“ (ğ‘¥)
â‰¥ 1 âˆ’ 2âˆ’ğœ‚ .
(cid:34) 
ğ‘âˆˆ{1,2}
Pr
(cid:110)ğ¾ğ‘
Security. For any ğ‘ âˆˆ {1, 2}, there exists a ppt simulator Simğ‘ such
that for any polynomial-size function sequence ğ‘“ğœ† âˆˆ F ,
(cid:12)(cid:12)(cid:12) (ğ¾1, ğ¾2) â† MPFSS.Gen(1ğœ†, ğœ‚, ğ‘“ğœ†)(cid:111) ğ‘â‰ˆ
(cid:110)ğ¾ğ‘ â† Simğ‘(1ğœ†, ğœ‚, Leakğ‘(ğ‘“ğœ†))(cid:111) ,
(4)
where Leak1(ğ‘“i,ğœ·) = ([ğ‘›], G) and Leak2(ğ‘“i,ğœ·) = ([ğ‘›, G], i).
Note that the security guarantee of Definition A.7 is the same as
in Definition 2.2. The main difference is in the correctness guarantee,
where we allow the output to be incorrect with a small probability
depending on the statistical security parameter ğœ‚.
Functionality 9 describes our MPFSS procedure. We will now
prove its correctness and security guarantees according to Defini-
tion A.7.
Theorem A.8. Functionality 9 is a Known-Index MPFSS scheme.
Proof. Correctness. First, observe that the parameters for cuckoo
hashing are chosen in Step (1) such that insertion fails with prob-
ability of at most 2âˆ’ğœ‚. Thus, it remains to show in the case that
18
ğœ…
MPFSS.Eval(ğ‘, ğ¾ğ‘, ğ‘¥)
SPFSS.Eval(cid:0)ğ‘, ğ¾
â„ğ‘ (ğ‘¥)
ğ‘
, posâ„ğ‘ (ğ‘¥)(ğ‘¥)(cid:1)
ğ‘”â„ğ‘ (ğ‘¥)(posâ„ğ‘ (ğ‘¥)(ğ‘¥))
cuckoo hashing succeeds,
ğ‘âˆˆ{1,2}


ğœ…
ğ‘=1
ğ‘âˆˆ{1,2}
ğ‘=1
ğ‘“i,ğœ· (ğ‘¥) =
=
=
where ğ‘”ğ‘™ (ğ‘¥) is defined as in Step (4) of Protocol 4. There are two
cases.
(1) ğ‘¥ = ğ‘– ğ‘— for some ğ‘— âˆˆ [ğ‘¡]. Then, since cuckoo hashing was
ğ‘™âˆ— = â„ğ‘âˆ— be the location of ğ‘¥ in ğ‘‡ . Then ğ‘”ğ‘™âˆ—(posğ‘™âˆ—(ğ‘¥)) = ğ›½ ğ‘—,
successful, for exactly one ğ‘âˆ— âˆˆ [ğœ…], ğ‘‡(cid:2)â„ğ‘âˆ—(ğ‘¥)(cid:3) = ğ‘¥. Let
while ğ‘”ğ‘™ (posğ‘™ (ğ‘¥)) = 0 for all ğ‘™ âˆˆ(cid:8)â„ğ‘(ğ‘¥)(cid:12)(cid:12) ğ‘ âˆˆ [ğœ…] \ {ğ‘âˆ—}(cid:9).
(2) ğ‘¥ âˆ‰ i. Then for all possible locations ğ‘™ âˆˆ(cid:8)â„ğ‘(ğ‘¥)(cid:12)(cid:12) ğ‘ âˆˆ [ğœ…](cid:9),
ğ‘‡ [ğ‘™] â‰  ğ‘¥ and thus ğ‘”ğ‘™ (posğ‘™ (ğ‘¥)) = 0.
ğ‘
1
Security. We construct simulators Simğ‘ for ğ‘ âˆˆ {1, 2} by calling
for the SPFSS key generation algorithm
simulators SimSPFSS.Gen
used in Step (4) of Functionality 9.
Both simulators start by computing (ğœ…, ğ‘š) â† ParamGen(ğ‘›, ğ‘¡, ğœ‚)
and sampling ğœ… random hash functions (â„ğ‘)ğ‘âˆˆ[ğœ…]. They then simple-
hash the domain [ğ‘›], resulting in ğ‘š buckets of sizes (ğ¼ğ‘™)ğ‘™âˆˆ[ğ‘š].
ğ‘ = 1. For each bucket ğ‘™ âˆˆ [ğ‘š], call SimSPFSS.Gen
ğ‘™âˆˆ[ğ‘š]
1(cid:1). Output(cid:16)(cid:0)â„ğ‘(cid:1)
(cid:17). Indistinguisha-
tain keys(cid:0)ğ¾ğ‘™
ğ‘âˆˆ[ğœ…],(cid:0)ğ¾ğ‘™
1(cid:1)
(1ğœ†, ğ¼ğ‘™ , G) to ob-
bility of the distributions in Eq. (4) follows from the fact
that the â„ğ‘ (and therefore the bucket sizes ğ¼ğ‘™) are identically
distributed, and for each bucket the simulated keys are in-
distinguishable from the real ones due to the security of the
SPFSS.Gen procedure (Eq. (1)).
ğ‘ = 2. Construct a cuckoo hash table ğ‘‡ of size ğ‘š using the hash
functions (â„ğ‘)ğ‘âˆˆ[ğœ…] and ğ‘–1, . . . , ğ‘–ğ‘¡ as in Step (2) of Func-
tionality 9. Now for each bucket ğ‘™ âˆˆ [ğ‘š], compute ğ¾ğ‘™
2 â†
SimSPFSS.Gen
ğ‘âˆˆ[ğœ…],
(cid:0)1ğœ†, ğ¼ğ‘™ , G, posğ‘™ (ğ‘‡ [ğ‘™])(cid:1) and output (cid:16)(cid:0)â„ğ‘(cid:1)
(cid:17). Again, indistinguishability follows from the fact
(cid:0)ğ¾ğ‘™
2(cid:1)
1
ğ‘™âˆˆ[ğ‘š]
that both views are identically distributed up to and includ-
ing the creation of ğ‘‡ , and then from the fact that the simu-
lated and real keys for each bucket are indistinguishable by
Eq. (1).
â–¡
Theorem A.9. Protocol 4 implements MPFSS.Gen(1ğœ†, ğœ‚, ğ‘“i,ğœ·) from
Functionality 9 with security against semi-honest adversaries, where i
is input by P2 and ğœ· is secret-shared element-wise between the parties.
Proof. We will first prove security assuming an ideal func-
tionalities SPFSS.Gen (Functionality 8) for SPFSS key generation,
and F 2PC for generic two-party computation. Then we again rely
on modular composition to obtain a protocol in the plain model.
We construct simulators Simğ‘ for the the views of both parties
ğ‘ âˆˆ {1, 2}. Both simulators perform simple hashing to obtain bucket
sizes consistent with the keys from the ideal output. Then, the sim-
ulation depends on ğ‘:
ğ‘ = 1. The only messages Sim1 needs to simulate are the outputs
of F 2PC, which by construction are equal to the inputs to
the calls to SPFSS.Gen, since all other messages received by
P1 are part of the output. Since by definition, v1 in Step (3)
of Protocol 4 is a random share, this can be simulated by
sampling v1 ğ‘…â† G. The resulting view is identical to the one
in the (SPFSS.Gen, F 2PC)-hybrid model.
ğ‘ = 2. Sim2 needs to first perform cuckoo hashing to generate a
hash table ğ‘‡ consistent with the input indices i and hash
functions from the ideal output. It can then call F 2PC with
a uniform vector v1 ğ‘…â† G as above. The inputs to each
SPFSS.Gen call are computed from ğ‘‡ as in Step (4) of Proto-
col 4. The resulting view is again identical to the one in the
(SPFSS.Gen, F 2PC)-hybrid model.
â–¡
19