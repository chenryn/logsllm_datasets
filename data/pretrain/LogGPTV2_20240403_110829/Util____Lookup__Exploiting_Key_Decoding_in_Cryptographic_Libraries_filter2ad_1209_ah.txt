shows that 0  𝑒 would be a contradiction to 𝑒·sk★[𝑑] = 𝑘(𝑁−sk★[𝑝]−
sk★[𝑞] + 1) + 1. As 𝑒 = 65537 is by far the most common choice,
we can thus enumerate all such values. For each such 𝑘, we can
combine the three equations and easily compute the two solutions
of the modular equation
𝑥2 − [𝑘(𝑁 − 1) + 1] · 𝑥 − 𝑘 = 0
(mod 𝑒).
This equation has two solutions 𝑥1 and 𝑥2 and it is easy to see
that {𝑥1, 𝑥2} = {𝑘𝑝, 𝑘𝑞} (see e. g. [35]). Hence, we can perform our
algorithm on (𝑥1, 𝑥2) as well as on (𝑥2, 𝑥1) to determine the values
𝑘, 𝑘𝑝, and 𝑘𝑞 correctly.
With the above approach, we need to run the algorithm 2 ·
65537 times, which might take a long time. To rule out infeasible
possibilities for 𝑘 earlier without running the complete algorithm,
value of 𝑘 corresponding to our secret key sk★, we have 0 ≤ 𝛿(𝑘) ≤
sk★[𝑝]+sk★[𝑞]. Hence, 𝛿(𝑘) and sk★[𝑑] agree on the ⌊𝑛/2⌋−2 most
Boneh, Durfee, and Frankel [13] defined the value 𝛿((cid:101)𝑘) = ⌊((cid:101)𝑘(𝑁 +
1) + 1)/𝑒⌋ for 0 <(cid:101)𝑘 < 𝑒. They then showed that for the correct
significant bits. We can thus compare, for each possibility 0 <(cid:101)𝑘 < 𝑒,
the most significant bits of 𝛿((cid:101)𝑘) with the most significant bits given
we discard our guess(cid:101)𝑘. Note that this reduces the running time
by our observations obs(part)[𝑑] on sk★[𝑑]. If these do not agree,
significantly to only 2 iterations of the algorithm, as almost always
there is only one possible value left after this check.
In the following, we thus assume that we found the correct values
for 𝑘, 𝑘𝑝, and 𝑘𝑞.
(2) In order to iteratively add more bits to our candidates, we
first need to find an initial candidate. As shown by Heninger and
Shacham [35], we know that 𝑒 · sk★[𝑑] ≡ 1 (mod 22+𝜏(𝑘)), 𝑒 ·
sk★[𝑑𝑝] ≡ 1 (mod 21+𝜏(𝑘𝑝)), and 𝑒 · sk★[𝑑𝑞] ≡ 1 (mod 21+𝜏(𝑘𝑞)),
where 𝜏(𝑥) is the exponent of the largest power of 2 that divides 𝑥,
i. e. 𝜏(𝑥) = max𝑖{2𝑖|𝑥}. Furthermore, both sk★[𝑝] and sk★[𝑞] are
significant bit of sk★[𝑝], the least significant bit of sk★[𝑞], the least
significant 2 + 𝜏(𝑘) bits of sk★[𝑑], the least significantly 1 + 𝜏(𝑘𝑝)
bits of sk★[𝑑𝑝], and the least significantly 1 + 𝜏(𝑘𝑞) bits of sk★[𝑑𝑞].
odd primes. Hence, for our first candidate(cid:101)sk, we know the least
(3) We say that a candidate(cid:101)sk has depth 𝑖, if the least significant
candidate(cid:101)sk with depth 𝑖, we perform an expand operation, that
𝑖 bits of 𝑝 are set (and thus the least significant 𝑖 bits of 𝑞, the
least significant 𝑖 + 𝜏(𝑘) bits of 𝑑, the least significant 𝑖 + 𝜏(𝑘𝑝) bits
of 𝑑𝑝, and the least significant 𝑖 + 𝜏(𝑘𝑞) bits of 𝑑𝑞). Now, given a
produces two candidates of depth 𝑖 + 1. In order to do this, we
need to determine the bits 𝑝[𝑖], 𝑞[𝑖], 𝑑[𝑖 + 𝜏(𝑘)], 𝑑𝑝[𝑖 + 𝜏(𝑘𝑝)],
and 𝑑𝑞[𝑖 + 𝜏(𝑘𝑞)]. Note that a trivial approach would continue the
algorithm with all possible 25 = 32 assignments, but the partial
knowledge given by our candidate allows us to drastically shrink
the number of possibilities down to 2.
Therefore, we set up the following system of congruencies de-
rived from the relations between the variables. This is a system
with 5 variables and 4 constraints and thus has exactly 2 solutions.
𝑝[𝑖] + 𝑞[𝑖] ≡ rhs1[𝑖]
(mod 2)
𝑑[𝑖 + 𝜏(𝑘)] + 𝑝[𝑖] + 𝑞[𝑖] ≡ rhs2[𝑖 + 𝜏(𝑘)]
𝑑𝑝[𝑖 + 𝜏(𝑘𝑝)] + 𝑝[𝑖] ≡ rhs3[𝑖 + 𝜏(𝑘𝑝)]
𝑑𝑞[𝑖 + 𝜏(𝑘𝑞)] + 𝑞[𝑖] ≡ rhs4[𝑖 + 𝜏(𝑘𝑞)]
(mod 2)
(mod 2)
(mod 2)
Here, the right-hand sides are given as
to the solutions of the system. For example, if 𝑝[𝑖] is part of the
we can check, whether the 𝑗-th block block𝑗 (𝑣) of each variable
𝑣 is feasible under our observation obs. We therefore check for
𝑗′ = obs(part)[sk★[𝑣]]𝑗. If this assignment is not possible, we
prune the solution. We denote this check against our observation
rhs1 = (𝑁 −(cid:101)sk[𝑝] ·(cid:101)sk[𝑞])
rhs2 = (𝑘(𝑁 + 1) + 1 − 𝑘((cid:101)sk[𝑝] +(cid:101)sk[𝑞]) − 𝑒 ·(cid:101)sk[𝑑])
rhs3 = (𝑘𝑝((cid:101)sk[𝑝] + 1) + 1 − 𝑒 ·(cid:101)sk[𝑑𝑝])
rhs4 = (𝑘𝑞((cid:101)sk[𝑞] + 1) + 1 − 𝑒 ·(cid:101)sk[𝑑𝑞]).
Let(cid:101)sk1 and(cid:101)sk2 be the solutions of depth 𝑖 + 1 obtained by set-
ting the position 𝑖 (resp. 𝑖 + 𝜏(𝑘), 𝑖 + 𝜏(𝑘𝑝), and𝑖 + 𝜏(𝑘𝑞)) of(cid:101)sk
first solution, the candidate(cid:101)sk1[𝑝] for 𝑝 in(cid:101)sk1 would be given by
(cid:101)sk1[𝑝] =(cid:101)sk[𝑝] + 2𝑖 · 𝑝[𝑖].
(4) Now, whenever a candidate(cid:101)sk of depth 𝑗 · 𝑏 + 𝑏 − 1 is reached,
each 𝑣 ∈ Vars, whether we have block𝑗 ((cid:101)sk[𝑣]) ∈ part𝑗′ with
obs as check(obs,(cid:101)sk).
We say that a candidate(cid:101)sk of depth 𝑖 is compatible with a secret
bits of sk★[𝑣] are identical to(cid:101)sk[𝑣] for all 𝑣 ∈ Vars. The correctness
Lemma 3. Let sk★ be the correct secret key and(cid:101)sk be a candidate
• If 𝑖 = 𝑗 · 𝑏 and obs is correct, check(obs,(cid:101)sk) will never prune(cid:101)sk.
• Let(cid:101)sk1 and(cid:101)sk2 be the output of expand((cid:101)sk). Then, either(cid:101)sk1 or
(cid:101)sk2 are compatible with sk★.
(5) Finally, whenever we find a candidate with our target depth 𝐷,
we output this candidate.
key sk★ if the 𝑖 (resp. 𝑖+𝜏(𝑘), 𝑖+𝜏(𝑘𝑝), and 𝑖+𝜏(𝑘𝑞)) least significant
of the algorithm is easily seen by the following lemma.
• The initial candidate of depth 1 produced by the algorithm is com-
patible with sk★.
of depth 𝑖 that is compatible with sk★.
Proof of Theorem 1
Proof. Expanding all of the candidates in 𝐶 with 𝑏 bits gives
us exactly 2𝑏 · |𝐶| incorrect candidates. If we expand any incorrect
candidate by 𝑏 bits, our assumption says that the blocks 𝑗 + 1 of
these candidates behave like random 𝑏-bit strings. Fix one of these
𝑗′ = obs(part)[sk★[𝑣]]𝑗 for all 𝑣 ∈ Vars. By our assumption, for
=
2−𝐻2(pr), where pr[𝑖] = | part𝑖 |/2𝑏. As these are independent, the
candidates(cid:101)sk. Now,(cid:101)sk is not pruned, if block𝑗 ((cid:101)sk[𝑣]) ∈ part𝑗′ with
(cid:16)| part𝑖 |2/22𝑏(cid:17)
each block, this happens with probability𝑘
probability that such an incorrect(cid:101)sk is not pruned, is 2−5𝐻2(pr).
Hence, the expected number of non-pruned candidates where each
block behaves like a random 𝑏-bit-string is exactly |𝐶| · 2𝑏−5·𝐻2(pr).
Furthermore, the expansion of the correct candidate gives us an
additional 2𝑏 − 1 incorrect candidates.
□
𝑖=1
Session 10A: Crypto, Symbols and Obfuscation CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea2471Proof of Theorem 2
.
𝑝
Proof. As noted above, we have 2𝑏−1 ≤ 2𝑏 candidates of depth
𝑗
𝑏. A simple induction combined with Theorem 1 shows that the
number of incorrect candidates with depth 𝑗 · 𝑏 is at most 2𝑏 ·
𝑖=0(2𝑏−5·𝐻2(pr))𝑖 = 2𝑏 · (2𝑏−5·𝐻2(pr)) 𝑗+1−1
□
2𝑏−5·𝐻2(pr)−1
THE LAST PARAMETER 𝑞−1
The attentive reader might have noticed that we obtain information
about six parts of the secret key 𝑝, 𝑞, 𝑑, 𝑑𝑝, 𝑑𝑞, and 𝑞−1
𝑝 , but do not use
the information about 𝑞−1
𝑝 in our key reconstruction algorithm. In
the following, we will shorty illustrate the problems of integrating
𝑞−1
𝑝 into the key-reconstruction algorithm. First, note that, similar
to the other variables of the secret key, one can easily conclude
that there is some value 𝑘′ such that 𝑞 · 𝑞−1
𝑝 = 𝑘′ · 𝑝 + 1. But the
following adaption of an argument of Nguyen (described in [35])
shows that knowing 𝑘′ already reveals the factorization of 𝑁 . As
𝑞 · 𝑞−1
𝑝 = 𝑘′ · 𝑝 + 1, multiplying both sides of the equation by 𝑝
gives the equation 𝑁 · 𝑞−1
𝑝 = 𝑘′ · 𝑝2 + 𝑝. Defining the polynomial
𝑓 (𝑥) = 𝑘′ · 𝑥2 + 𝑥 shows that 𝑓 (𝑝) mod 𝑁 = 0. Hence, 𝑝 is a small
root of a known polynomial (if 𝑘′ is known) and can thus be found
by the method of Coppersmith [23, 37, 52].
B AN EXAMPLE KEY IN DER ENCODING
30 82 02 77 # SEQUENCE : Length 0 x277
02 01 00 # INTEGER : Version 00
30 0d
# SEQUENCE : Length 0 xd
06 09 2a 86 ... 01 01 # Algorithm ID
05 00
04 82 02 61 # OCTET STRING : RSA Priv . Key
30 82 02 5d # SEQUENCE : Length 0 x25d
# Private Key Parameters
# Version 00
02 01 00
02 81 81 00 ... a9 33 # n
02 03 01 00 01
# e
02 81 80 76 ... 79 a1 # d
02 41 00 f3 ... e8 1f # p
02 41 00 cf ... ac 6d # q
02 40 2b 96 ... ef 8d # d mod (p -1)
02 41 00 c0 ... 85 95 # d mod (q -1)
02 41 00 89 ... 8c 19 # q ^ -1 mod p
Figure 9: 1024-bit RSA private key, DER encoded according
to PKCS #8, in hexadecimal format.
C LEAKAGE ESTIMATION WITH
MICROWALK
Table 5: The leakage estimation from Microwalk for
OpenSSL, generated from 4,096 test cases. For each instruc-
tion, Microwalk computes the Mutual Information (MI) be-
tween the memory access traces and the test case IDs, which
measures the ability of an attacker to infer the input from
an observed trace. Note that the leakage is upper bounded
by the logarithm of the number of test cases (12).
Instruction
EVP_DecodeUpdate+105
EVP_DecodeBlock+E
EVP_DecodeBlock+59
EVP_DecodeBlock+C0
EVP_DecodeBlock+D4
EVP_DecodeBlock+E5
EVP_DecodeBlock+FA
BN_bin2bn+AC
BN_bin2bn+24
ASN1_get_object+171
ASN1_get_object+16
ASN1_get_object+CC
PEM_read_bio+24E
EVP_DecodeUpdate+E2
EVP_DecodeUpdate+F8
EVP_DecodeBlock+49
EVP_DecodeBlock+14D
EVP_DecodeBlock+C8
EVP_DecodeBlock+D9
EVP_DecodeBlock+EE
EVP_DecodeBlock+138
EVP_DecodeBlock+142
EVP_DecodeBlock+148
PEM_read_bio+1D0
PEM_read_bio+1ED
PEM_read_bio+1F2
Avg. leakage (bits)
12
12
12
12
12
12
12
4.035
4.016
2.965
2.941
2.941
1.012
1.012
1.012
1.012
1.012
1.012
1.012
1.012
1.012
1.012
1.012
1.009
1.009
1.009
Session 10A: Crypto, Symbols and Obfuscation CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea2472D BORINGSSL’S BASE64 DECODING
static uint8_t base64_ascii_to_bin ( uint8_t a) {
// Since PEM is sometimes used to carry private keys , we decode base64 data
// itself in constant - time .
const uint8_t is_upper = constant_time_in_range_8 (a , 'A ', 'Z ');
const uint8_t is_lower = constant_time_in_range_8 (a , 'a ', 'z ');
const uint8_t is_digit = constant_time_in_range_8 (a , '0 ', '9 ');
const uint8_t is_plus = constant_time_eq_8 (a , '+ ');
const uint8_t is_slash = constant_time_eq_8 (a , '/ ');
const uint8_t is_equals = constant_time_eq_8 (a , '= ');
uint8_t ret = 0 xff ;
ret = constant_time_select_8 ( is_upper , a - 'A ', ret );
ret = constant_time_select_8 ( is_lower , a - 'a ' + 26 , ret );
ret = constant_time_select_8 ( is_digit , a - '0 ' + 52 , ret );
ret = constant_time_select_8 ( is_plus , 62 , ret );
ret = constant_time_select_8 ( is_slash , 63 , ret );
// Padding maps to zero , to be further handled by the caller .
ret = constant_time_select_8 ( is_equals , 0, ret );
return ret ;
// [0 ,26)
// [26 ,52)
// [52 ,62)
// 0 xff signals invalid .
}
Figure 10: Base64 decoding constant-time implementation in Google’s BoringSSL [14] (crypto/base64/base64.c)
Session 10A: Crypto, Symbols and Obfuscation CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea2473