shows that 0  ğ‘’ would be a contradiction to ğ‘’Â·skâ˜…[ğ‘‘] = ğ‘˜(ğ‘âˆ’skâ˜…[ğ‘]âˆ’
skâ˜…[ğ‘] + 1) + 1. As ğ‘’ = 65537 is by far the most common choice,
we can thus enumerate all such values. For each such ğ‘˜, we can
combine the three equations and easily compute the two solutions
of the modular equation
ğ‘¥2 âˆ’ [ğ‘˜(ğ‘ âˆ’ 1) + 1] Â· ğ‘¥ âˆ’ ğ‘˜ = 0
(mod ğ‘’).
This equation has two solutions ğ‘¥1 and ğ‘¥2 and it is easy to see
that {ğ‘¥1, ğ‘¥2} = {ğ‘˜ğ‘, ğ‘˜ğ‘} (see e. g. [35]). Hence, we can perform our
algorithm on (ğ‘¥1, ğ‘¥2) as well as on (ğ‘¥2, ğ‘¥1) to determine the values
ğ‘˜, ğ‘˜ğ‘, and ğ‘˜ğ‘ correctly.
With the above approach, we need to run the algorithm 2 Â·
65537 times, which might take a long time. To rule out infeasible
possibilities for ğ‘˜ earlier without running the complete algorithm,
value of ğ‘˜ corresponding to our secret key skâ˜…, we have 0 â‰¤ ğ›¿(ğ‘˜) â‰¤
skâ˜…[ğ‘]+skâ˜…[ğ‘]. Hence, ğ›¿(ğ‘˜) and skâ˜…[ğ‘‘] agree on the âŒŠğ‘›/2âŒ‹âˆ’2 most
Boneh, Durfee, and Frankel [13] defined the value ğ›¿((cid:101)ğ‘˜) = âŒŠ((cid:101)ğ‘˜(ğ‘ +
1) + 1)/ğ‘’âŒ‹ for 0 <(cid:101)ğ‘˜ < ğ‘’. They then showed that for the correct
significant bits. We can thus compare, for each possibility 0 <(cid:101)ğ‘˜ < ğ‘’,
the most significant bits of ğ›¿((cid:101)ğ‘˜) with the most significant bits given
we discard our guess(cid:101)ğ‘˜. Note that this reduces the running time
by our observations obs(part)[ğ‘‘] on skâ˜…[ğ‘‘]. If these do not agree,
significantly to only 2 iterations of the algorithm, as almost always
there is only one possible value left after this check.
In the following, we thus assume that we found the correct values
for ğ‘˜, ğ‘˜ğ‘, and ğ‘˜ğ‘.
(2) In order to iteratively add more bits to our candidates, we
first need to find an initial candidate. As shown by Heninger and
Shacham [35], we know that ğ‘’ Â· skâ˜…[ğ‘‘] â‰¡ 1 (mod 22+ğœ(ğ‘˜)), ğ‘’ Â·
skâ˜…[ğ‘‘ğ‘] â‰¡ 1 (mod 21+ğœ(ğ‘˜ğ‘)), and ğ‘’ Â· skâ˜…[ğ‘‘ğ‘] â‰¡ 1 (mod 21+ğœ(ğ‘˜ğ‘)),
where ğœ(ğ‘¥) is the exponent of the largest power of 2 that divides ğ‘¥,
i. e. ğœ(ğ‘¥) = maxğ‘–{2ğ‘–|ğ‘¥}. Furthermore, both skâ˜…[ğ‘] and skâ˜…[ğ‘] are
significant bit of skâ˜…[ğ‘], the least significant bit of skâ˜…[ğ‘], the least
significant 2 + ğœ(ğ‘˜) bits of skâ˜…[ğ‘‘], the least significantly 1 + ğœ(ğ‘˜ğ‘)
bits of skâ˜…[ğ‘‘ğ‘], and the least significantly 1 + ğœ(ğ‘˜ğ‘) bits of skâ˜…[ğ‘‘ğ‘].
odd primes. Hence, for our first candidate(cid:101)sk, we know the least
(3) We say that a candidate(cid:101)sk has depth ğ‘–, if the least significant
candidate(cid:101)sk with depth ğ‘–, we perform an expand operation, that
ğ‘– bits of ğ‘ are set (and thus the least significant ğ‘– bits of ğ‘, the
least significant ğ‘– + ğœ(ğ‘˜) bits of ğ‘‘, the least significant ğ‘– + ğœ(ğ‘˜ğ‘) bits
of ğ‘‘ğ‘, and the least significant ğ‘– + ğœ(ğ‘˜ğ‘) bits of ğ‘‘ğ‘). Now, given a
produces two candidates of depth ğ‘– + 1. In order to do this, we
need to determine the bits ğ‘[ğ‘–], ğ‘[ğ‘–], ğ‘‘[ğ‘– + ğœ(ğ‘˜)], ğ‘‘ğ‘[ğ‘– + ğœ(ğ‘˜ğ‘)],
and ğ‘‘ğ‘[ğ‘– + ğœ(ğ‘˜ğ‘)]. Note that a trivial approach would continue the
algorithm with all possible 25 = 32 assignments, but the partial
knowledge given by our candidate allows us to drastically shrink
the number of possibilities down to 2.
Therefore, we set up the following system of congruencies de-
rived from the relations between the variables. This is a system
with 5 variables and 4 constraints and thus has exactly 2 solutions.
ğ‘[ğ‘–] + ğ‘[ğ‘–] â‰¡ rhs1[ğ‘–]
(mod 2)
ğ‘‘[ğ‘– + ğœ(ğ‘˜)] + ğ‘[ğ‘–] + ğ‘[ğ‘–] â‰¡ rhs2[ğ‘– + ğœ(ğ‘˜)]
ğ‘‘ğ‘[ğ‘– + ğœ(ğ‘˜ğ‘)] + ğ‘[ğ‘–] â‰¡ rhs3[ğ‘– + ğœ(ğ‘˜ğ‘)]
ğ‘‘ğ‘[ğ‘– + ğœ(ğ‘˜ğ‘)] + ğ‘[ğ‘–] â‰¡ rhs4[ğ‘– + ğœ(ğ‘˜ğ‘)]
(mod 2)
(mod 2)
(mod 2)
Here, the right-hand sides are given as
to the solutions of the system. For example, if ğ‘[ğ‘–] is part of the
we can check, whether the ğ‘—-th block blockğ‘— (ğ‘£) of each variable
ğ‘£ is feasible under our observation obs. We therefore check for
ğ‘—â€² = obs(part)[skâ˜…[ğ‘£]]ğ‘—. If this assignment is not possible, we
prune the solution. We denote this check against our observation
rhs1 = (ğ‘ âˆ’(cid:101)sk[ğ‘] Â·(cid:101)sk[ğ‘])
rhs2 = (ğ‘˜(ğ‘ + 1) + 1 âˆ’ ğ‘˜((cid:101)sk[ğ‘] +(cid:101)sk[ğ‘]) âˆ’ ğ‘’ Â·(cid:101)sk[ğ‘‘])
rhs3 = (ğ‘˜ğ‘((cid:101)sk[ğ‘] + 1) + 1 âˆ’ ğ‘’ Â·(cid:101)sk[ğ‘‘ğ‘])
rhs4 = (ğ‘˜ğ‘((cid:101)sk[ğ‘] + 1) + 1 âˆ’ ğ‘’ Â·(cid:101)sk[ğ‘‘ğ‘]).
Let(cid:101)sk1 and(cid:101)sk2 be the solutions of depth ğ‘– + 1 obtained by set-
ting the position ğ‘– (resp. ğ‘– + ğœ(ğ‘˜), ğ‘– + ğœ(ğ‘˜ğ‘), andğ‘– + ğœ(ğ‘˜ğ‘)) of(cid:101)sk
first solution, the candidate(cid:101)sk1[ğ‘] for ğ‘ in(cid:101)sk1 would be given by
(cid:101)sk1[ğ‘] =(cid:101)sk[ğ‘] + 2ğ‘– Â· ğ‘[ğ‘–].
(4) Now, whenever a candidate(cid:101)sk of depth ğ‘— Â· ğ‘ + ğ‘ âˆ’ 1 is reached,
each ğ‘£ âˆˆ Vars, whether we have blockğ‘— ((cid:101)sk[ğ‘£]) âˆˆ partğ‘—â€² with
obs as check(obs,(cid:101)sk).
We say that a candidate(cid:101)sk of depth ğ‘– is compatible with a secret
bits of skâ˜…[ğ‘£] are identical to(cid:101)sk[ğ‘£] for all ğ‘£ âˆˆ Vars. The correctness
Lemma 3. Let skâ˜… be the correct secret key and(cid:101)sk be a candidate
â€¢ If ğ‘– = ğ‘— Â· ğ‘ and obs is correct, check(obs,(cid:101)sk) will never prune(cid:101)sk.
â€¢ Let(cid:101)sk1 and(cid:101)sk2 be the output of expand((cid:101)sk). Then, either(cid:101)sk1 or
(cid:101)sk2 are compatible with skâ˜….
(5) Finally, whenever we find a candidate with our target depth ğ·,
we output this candidate.
key skâ˜… if the ğ‘– (resp. ğ‘–+ğœ(ğ‘˜), ğ‘–+ğœ(ğ‘˜ğ‘), and ğ‘–+ğœ(ğ‘˜ğ‘)) least significant
of the algorithm is easily seen by the following lemma.
â€¢ The initial candidate of depth 1 produced by the algorithm is com-
patible with skâ˜….
of depth ğ‘– that is compatible with skâ˜….
Proof of Theorem 1
Proof. Expanding all of the candidates in ğ¶ with ğ‘ bits gives
us exactly 2ğ‘ Â· |ğ¶| incorrect candidates. If we expand any incorrect
candidate by ğ‘ bits, our assumption says that the blocks ğ‘— + 1 of
these candidates behave like random ğ‘-bit strings. Fix one of these
ğ‘—â€² = obs(part)[skâ˜…[ğ‘£]]ğ‘— for all ğ‘£ âˆˆ Vars. By our assumption, for
=
2âˆ’ğ»2(pr), where pr[ğ‘–] = | partğ‘– |/2ğ‘. As these are independent, the
candidates(cid:101)sk. Now,(cid:101)sk is not pruned, if blockğ‘— ((cid:101)sk[ğ‘£]) âˆˆ partğ‘—â€² with
(cid:16)| partğ‘– |2/22ğ‘(cid:17)
each block, this happens with probabilityğ‘˜
probability that such an incorrect(cid:101)sk is not pruned, is 2âˆ’5ğ»2(pr).
Hence, the expected number of non-pruned candidates where each
block behaves like a random ğ‘-bit-string is exactly |ğ¶| Â· 2ğ‘âˆ’5Â·ğ»2(pr).
Furthermore, the expansion of the correct candidate gives us an
additional 2ğ‘ âˆ’ 1 incorrect candidates.
â–¡
ğ‘–=1
Session 10A: Crypto, Symbols and Obfuscation CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea2471Proof of Theorem 2
.
ğ‘
Proof. As noted above, we have 2ğ‘âˆ’1 â‰¤ 2ğ‘ candidates of depth
ğ‘—
ğ‘. A simple induction combined with Theorem 1 shows that the
number of incorrect candidates with depth ğ‘— Â· ğ‘ is at most 2ğ‘ Â·
ğ‘–=0(2ğ‘âˆ’5Â·ğ»2(pr))ğ‘– = 2ğ‘ Â· (2ğ‘âˆ’5Â·ğ»2(pr)) ğ‘—+1âˆ’1
â–¡
2ğ‘âˆ’5Â·ğ»2(pr)âˆ’1
THE LAST PARAMETER ğ‘âˆ’1
The attentive reader might have noticed that we obtain information
about six parts of the secret key ğ‘, ğ‘, ğ‘‘, ğ‘‘ğ‘, ğ‘‘ğ‘, and ğ‘âˆ’1
ğ‘ , but do not use
the information about ğ‘âˆ’1
ğ‘ in our key reconstruction algorithm. In
the following, we will shorty illustrate the problems of integrating
ğ‘âˆ’1
ğ‘ into the key-reconstruction algorithm. First, note that, similar
to the other variables of the secret key, one can easily conclude
that there is some value ğ‘˜â€² such that ğ‘ Â· ğ‘âˆ’1
ğ‘ = ğ‘˜â€² Â· ğ‘ + 1. But the
following adaption of an argument of Nguyen (described in [35])
shows that knowing ğ‘˜â€² already reveals the factorization of ğ‘ . As
ğ‘ Â· ğ‘âˆ’1
ğ‘ = ğ‘˜â€² Â· ğ‘ + 1, multiplying both sides of the equation by ğ‘
gives the equation ğ‘ Â· ğ‘âˆ’1
ğ‘ = ğ‘˜â€² Â· ğ‘2 + ğ‘. Defining the polynomial
ğ‘“ (ğ‘¥) = ğ‘˜â€² Â· ğ‘¥2 + ğ‘¥ shows that ğ‘“ (ğ‘) mod ğ‘ = 0. Hence, ğ‘ is a small
root of a known polynomial (if ğ‘˜â€² is known) and can thus be found
by the method of Coppersmith [23, 37, 52].
B AN EXAMPLE KEY IN DER ENCODING
30 82 02 77 # SEQUENCE : Length 0 x277
02 01 00 # INTEGER : Version 00
30 0d
# SEQUENCE : Length 0 xd
06 09 2a 86 ... 01 01 # Algorithm ID
05 00
04 82 02 61 # OCTET STRING : RSA Priv . Key
30 82 02 5d # SEQUENCE : Length 0 x25d
# Private Key Parameters
# Version 00
02 01 00
02 81 81 00 ... a9 33 # n
02 03 01 00 01
# e
02 81 80 76 ... 79 a1 # d
02 41 00 f3 ... e8 1f # p
02 41 00 cf ... ac 6d # q
02 40 2b 96 ... ef 8d # d mod (p -1)
02 41 00 c0 ... 85 95 # d mod (q -1)
02 41 00 89 ... 8c 19 # q ^ -1 mod p
Figure 9: 1024-bit RSA private key, DER encoded according
to PKCS #8, in hexadecimal format.
C LEAKAGE ESTIMATION WITH
MICROWALK
Table 5: The leakage estimation from Microwalk for
OpenSSL, generated from 4,096 test cases. For each instruc-
tion, Microwalk computes the Mutual Information (MI) be-
tween the memory access traces and the test case IDs, which
measures the ability of an attacker to infer the input from
an observed trace. Note that the leakage is upper bounded
by the logarithm of the number of test cases (12).
Instruction
EVP_DecodeUpdate+105
EVP_DecodeBlock+E
EVP_DecodeBlock+59
EVP_DecodeBlock+C0
EVP_DecodeBlock+D4
EVP_DecodeBlock+E5
EVP_DecodeBlock+FA
BN_bin2bn+AC
BN_bin2bn+24
ASN1_get_object+171
ASN1_get_object+16
ASN1_get_object+CC
PEM_read_bio+24E
EVP_DecodeUpdate+E2
EVP_DecodeUpdate+F8
EVP_DecodeBlock+49
EVP_DecodeBlock+14D
EVP_DecodeBlock+C8
EVP_DecodeBlock+D9
EVP_DecodeBlock+EE
EVP_DecodeBlock+138
EVP_DecodeBlock+142
EVP_DecodeBlock+148
PEM_read_bio+1D0
PEM_read_bio+1ED
PEM_read_bio+1F2
Avg. leakage (bits)
12
12
12
12
12
12
12
4.035
4.016
2.965
2.941
2.941
1.012
1.012
1.012
1.012
1.012
1.012
1.012
1.012
1.012
1.012
1.012
1.009
1.009
1.009
Session 10A: Crypto, Symbols and Obfuscation CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea2472D BORINGSSLâ€™S BASE64 DECODING
static uint8_t base64_ascii_to_bin ( uint8_t a) {
// Since PEM is sometimes used to carry private keys , we decode base64 data
// itself in constant - time .
const uint8_t is_upper = constant_time_in_range_8 (a , 'A ', 'Z ');
const uint8_t is_lower = constant_time_in_range_8 (a , 'a ', 'z ');
const uint8_t is_digit = constant_time_in_range_8 (a , '0 ', '9 ');
const uint8_t is_plus = constant_time_eq_8 (a , '+ ');
const uint8_t is_slash = constant_time_eq_8 (a , '/ ');
const uint8_t is_equals = constant_time_eq_8 (a , '= ');
uint8_t ret = 0 xff ;
ret = constant_time_select_8 ( is_upper , a - 'A ', ret );
ret = constant_time_select_8 ( is_lower , a - 'a ' + 26 , ret );
ret = constant_time_select_8 ( is_digit , a - '0 ' + 52 , ret );
ret = constant_time_select_8 ( is_plus , 62 , ret );
ret = constant_time_select_8 ( is_slash , 63 , ret );
// Padding maps to zero , to be further handled by the caller .
ret = constant_time_select_8 ( is_equals , 0, ret );
return ret ;
// [0 ,26)
// [26 ,52)
// [52 ,62)
// 0 xff signals invalid .
}
Figure 10: Base64 decoding constant-time implementation in Googleâ€™s BoringSSL [14] (crypto/base64/base64.c)
Session 10A: Crypto, Symbols and Obfuscation CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea2473