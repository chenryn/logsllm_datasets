[23] Anthony Desnos. 2010. Dynamic, Metamorphic (and opensource) Virtual Ma-
chines. Hack.lu.
[24] Robert B. K. Dewar. 1975. Indirect Threaded Code. Commun. ACM 18, 6 (1975).
[25] M. Anton Ertl and David Gregg. 2001. The Behavior of Efficient Virtual Ma-
chine Interpreters on Modern Architectures. In Proceedings of the 2001 European
Conference on Parallel Processing.
[26] Nicolas Falliere, Patrick Fitzgerald, and Eric Chien. 2009.
Inside the Jaws of
Trojan.Clampi. Symantec Technical Report.
[27] Vijay Ganesh and David L. Dill. 2007. A Decision Procedure for Bit-vectors and
Arrays. In Proceedings of the 2007 International Conference in Computer Aided
Verification (CAV’07).
[28] Patrice Godefroid, Michael Y. Levin, and David Molnar. 2008. Automated White-
box Fuzz Testing. In Proceedings of the 15th Annual Network and Distributed
System Security Symposium (NDSS’08).
[29] Yoann Guillot and Alexandre Gazet. 2010. Automatic binary deobfuscation.
Journal in Computer Virology 6, 3 (2010).
[30] Anatoli Kalysch, Johannes Götzfried, and Tilo Müller. 2017. VMAttack: De-
obfuscating Virtualization-Based Packed Binaries. In Proceedings of the 12th
International Conference on Availability, Reliability and Security (ARES’17).
[31] Yuhei Kawakoya, Makoto Iwamura, Eitaro Shioji, and Takeo Hariu. 2013. API
Chaser: Anti-analysis Resistant Malware Analyzer. In Proceedings of the 16th In-
ternational Symposium on Research in Attacks, Intrusions, and Defenses (RAID’13).
[32] Johannes Kinder. 2012. Towards Static Analysis of Virtualization-Obfuscated
Binaries. In Proceedings of the 19th Working Conference on Reverse Engineering
(WCRE’12).
[33] Samuel T. King, George W. Dunlap, and Peter M. Chen. 2003. Operating System
Support for Virtual Machines. In Proceedings of the 2003 USENIX Annual Technical
Conference (ATC’03).
[34] Dhilung Kirat, Giovanni Vigna, and Christopher Kruegel. 2014. BareCloud:
Bare-metal Analysis-based Evasive Malware Detection. In Proceedings of the 23rd
USENIX Conference on Security Symposium (USENIX Security’14).
[35] Kaiyuan Kuang, Zhanyong Tang, Xiaoqing Gong, Dingyi Fang, Xiaojiang Chen,
Tianzhang Xing, Guixin Ye, Jie Zhang, and Zheng Wang. 2016. Exploiting Dy-
namic Scheduling for VM-Based Code Obfuscation. In Proceedings of the 15th
IEEE International Conference on Trust, Security and Privacy in Computing and
Communications (TrustCom’16).
[36] Boris Lau. 2008. Dealing with Virtualization Obfuscators. CARO Workshop.
[37] Mingyue Liang, Zhoujun Li, Qiang Zeng, and Zhejun Fang. 2017. Deobfuscation
of Virtualization-obfuscated Code through Symbolic Execution and Compilation
Optimization. In Proceedings of the 19th International Conference on Information
and Communications Security (ICICS’17).
[38] Chi-Keung Luk, Robert Cohn, Robert Muth, Harish Patil, Artur Klauser, Geoff
Lowney, Steven Wallace, Vijay Janapa Reddi, and Kim Hazelwood. 2005. Pin:
building customized program analysis tools with dynamic instrumentation. In
Proceedings of the 2005 ACM SIGPLAN conference on Programming language design
and implementation (PLDI’05).
[39] Ramya Manikyam, J. Todd McDonald, William R. Mahoney, Todd R. Andel, and
Samuel H. Russ. 2016. Comparing the Effectiveness of Commercial Obfuscators
Against MATE Attacks. In Proceedings of the 6th Workshop on Software Security,
Protection, and Reverse Engineering (SSPREW’16).
[40] Jiang Ming, Dongpeng Xu, Yufei Jiang, and Dinghao Wu. 2017. BinSim: Trace-
based Semantic Binary Diffing via System Call Sliced Segment Equivalence
Checking. In Proceedings of the 26th USENIX Conference on Security Symposium
(USENIX Security’17).
[41] Jiang Ming, Dongpeng Xu, Li Wang, and Dinghao Wu. 2015. LOOP: Logic-
Oriented Opaque Predicate Detection in Obfuscated Binary Code. In Proceedings
of the 22nd ACM SIGSAC Conference on Computer and Communications Security
(CCS’15).
[42] Andreas Moser, Christopher Kruegel, and Engin Kirda. 2007. Exploring multiple
execution paths for malware analysis. In Proceedings of the 28th IEEE Symposium
on Security and Privacy (S&P’07).
[43] Philip OKane, Sakir Sezer, and Kieran McLaughlin. 2011. Obfuscation: The Hidden
Malware. IEEE Security and Privacy 9, 5 (2011).
[44] Oreans Technologies. 2015. Protecting Better with Code Virtualizer. http://
oreans.com/codevirtualizer.php.
[61] Yan Shoshitaishvili, Ruoyu Wang, Christopher Salls, Nick Stephens, Mario Polino,
Andrew Dutcher, John Grosen, Siji Feng, Christophe Hauser, Christopher Kruegel,
and Giovanni Vigna. 2016. SoK: (State of) The Art of War: Offensive Techniques
in Binary Analysis. In Proceedings of the 37th IEEE Symposium on Security and
Privacy (S&P’16).
[62] Craig Smith. 2008. Creating Code Obfuscation Virtual Machines. RECON.
[63] Jim Smith and Ravi Nair. 2005. Virtual Machines: Versatile Platforms for Systems
and Processes (The Morgan Kaufmann Series in Computer Architecture and Design).
Morgan Kaufmann Publishers Inc., San Francisco, CA, USA.
[64] Dawn Song, David Brumley, Heng Yin, Juan Caballero, Ivan Jager, Min Gyung
Kang, Zhenkai Liang, James Newsome, Pongsin Poosankam, and Prateek Saxena.
2008. BitBlaze: A New Approach to Computer Security via Binary Analysis. In
Proceedings of the 4th International Conference on Information Systems Security
(ICISS’08). Keynote invited paper.
[65] Aditya K Sood, Richard J Enbody, and Rohit Bansal. 2011. SpyEye malware
infection framework. Virus Bulletin.
[66] StrongBit Technology. last reviewed, 10/01/2017. EXECryptor: Bulletproof soft-
ware protection. http://www.strongbit.com/execryptor.asp.
[67] Zhanyong Tang, Lei Wang, Kaiyuan Kuang, Chao Xue, Xiaoqing Gong, Xiao-
jiang Chen, Dingyi Fang, and Zheng Wang. 2017. SEEAD: A Semantic-based
Approach for Automatic Binary Code De-obfuscation. In Proceedings of 16th
IEEE International Conference on Trust, Security and Privacy in Computing and
Communications (TrustCom’17).
[68] Clark Taylor and Christian Collberg. 2016. A Tool for Teaching Reverse Engi-
neering. In Proceedings of the 2016 USENIX Workshop on Advances in Security
Education.
[69] The Enigma Protector. last reviewed, 10/01/2017. Enigma Protector: A profes-
sional system for executable files licensing and protection. http://enigmaprotector.
com/.
[70] Tora. 2012. Devirtualizing FinSpy. POC 2012.
[71] Xabier Ugarte-Pedrero, Davide Balzarotti, Igor Santos, and Pablo G Bringas. 2015.
SoK: Deep packer inspection: A longitudinal study of the complexity of run-
time packers. In Proceedings of the 36th IEEE Symposium on Security & Privacy
(S&P’15).
[72] Julien Vanegue, Sean Heelan, and Rolf Rolles. 2012. SMT Solvers for Software
Security. In Proceedings of the 6th USENIX Workshop on Offensive Technologies
(WOOT’12).
[45] Oreans Technologies. last reviewed, 10/01/2017. Code Virtualizer: Total obfusca-
[73] VMProtect Software. last reviewed, 10/01/2017. VMProtect software protection.
tion against reverse engineering. http://oreans.com/codevirtualizer.php.
http://vmpsoft.com.
[46] Oreans Technologies. last reviewed, 10/01/2017. Themida: Advanced Windows
Software Protection System. https://www.oreans.com/themida.php.
[47] Joshua Phillips, Vitaly Zaytsev, and Abhishek Karnik. 2009. Parasitics: The Next
Generation. Kaspersky Lab Technical Report.
[48] Ian Piumarta and Fabio Riccardi. 1998. Optimizing Direct Threaded Code by Selec-
tive Inlining. In Proceedings of the 1998 ACM SIGPLAN Conference on Programming
Language Design and Implementation (PLDI’98).
[49] Mario Polino, Andrea Continella, Sebastiano Mariani, Stefano D’Alessio, Lorenzo
Fontata, Fabio Gritti, and Stefano Zanero. 2017. Measuring and Defeating Anti-
Instrumentation-Equipped Malware. In Proceedings of the 14th Conference on
Detection of Intrusions and Malware and Vulnerability Assessment (DIMVA’17).
[50] Michalis Polychronakis. 2011. Reverse Engineering of Malware Emulators. Springer
US, Chapter Encyclopedia of Cryptography and Security.
[51] Jason Raber. 2013. Virtual Deobfuscator: Removing virtualization obfuscations
from malware. Black Hat USA.
[52] Ben Read and Jonathan Leathery. 2017. CVE-2017-0199 Used as Zero Day to
Distribute FINSPY Espionage Malware and LATENTBOT Cyber Crime Malware.
FireEye Threat Research Blog.
[53] ReWolf. last reviewed, 10/01/2017. x86 Virtualizer. http://www.openrce.org/blog/
view/847/x86_Virtualizer_-_source_code.
[54] Thomas Roccia. 2017. Malware Packers Use Tricks to Avoid Analysis, Detection.
McAfee Blogs.
[55] Rolf Rolles. 2009. Unpacking virtualization obfuscators. In Proceedings of the 3rd
USENIX Workshop on Offensive Technologies (WOOT’09).
[56] Kevin A. Roundy and Barton P. Miller. 2013. Binary-code Obfuscations in Preva-
lent Packer Tools. Comput. Surveys 46, 1 (2013).
[57] Jonathan Salwan and Sébastien Bardin and Marie-Laure Potet. 2017. Deobfusca-
tion of VM based software protection. In Symposium sur la sécurité des technologies
de l’information et des communications (SSTIC’17).
[58] Florent Saudel and Jonathan Salwan. 2015. Triton: A Dynamic Symbolic Execution
Framework. In Symposium sur la sécurité des technologies de l’information et des
communications (SSTIC’15).
[59] Monirul Sharif, Andrea Lanzi, Jonathon Giffin, and Wenke Lee. 2009. Auto-
matic reverse engineering of malware emulators. In Proceedings of the 30th IEEE
Symposium on Security and Privacy (S&P’09).
[60] Yunhe Shi, David Gregg, Andrew Beatty, and M. Anton Ertl. 2005. Virtual Ma-
chine Showdown: Stack Versus Registers. In Proceedings of the 1st ACM/USENIX
International Conference on Virtual Execution Environments (VEE’05).
[74] C. Wang, J. Davidson, J. Hill, and J. Knight. 2001. Protection of software-based sur-
vivability mechanisms. In Proceedings of International Conference on Dependable
Systems and Networks (DSN’01).
[75] Huaijun Wang, Dingyi Fang, Guanghui Li, Na An, Xiaojiang Chen, and Yuanxi-
ang Gu. 2014. TDVMP: Improved Virtual Machine-Based Software Protection
with Time Diversity. In Proceedings of the 3rd Program Protection and Reverse
Engineering Workshop.
[76] Huaijun Wang, Dingyi Fang, Guanghui Li, Xiaoyan Yin, Bo Zhang, and Yuanxiang
Gu. 2013. NISLVMP: Improved Virtual Machine-Based Software Protection. In
Proceedings of the 9th International Conference on Computational Intelligence and
Security.
[77] Pei Wang, Shuai Wang, Jiang Ming, Yufei Jiang, and Dinghao Wu. 2016. Translin-
gual Obfuscation. In Proceedings of the 1st IEEE European Symposium on Security
and Privacy (Euro S&P’16).
[78] Zhenxiang Jim Wang. 2010. Virtual Machine Protection Technology and AV
industry. CARO Workshop.
[79] Josh Watson. 2017. An extra bit of analysis for cLEMENCy. Trail of Bits Blog.
[80] Haijiang Xie, Yuanyuan Zhang, Juanru Li, and Dawu Gu. 2017. Nightingale:
Translating Embedded VM Code in x86 Binary Executables. In Proceedings of the
20th Information Security Conference(ISC’17).
[81] Dongpeng Xu, Jiang Ming, and Dinghao Wu. 2017. Cryptographic Function
Detection in Obfuscated Binaries via Bit-precise Symbolic Loop Mapping. In
Proceedings of the 38th IEEE Symposium on Security and Privacy (S&P’17).
[82] Babak Yadegari and Saumya Debray. 2015. Symbolic Execution of Obfuscated
Code. In Proceedings of the 22nd ACM SIGSAC Conference on Computer and Com-
munications Security (CCS’15).
[83] Babak Yadegari, Brian Johannesmeyer, Ben Whitely, and Saumya Debray. 2015. A
generic approach to automatic deobfuscation of executable code. In Proceedings
of the 36th IEEE Symposium on Security and Privacy (S&P’15).
[84] Lok-Kwong Yan, Manjukumar Jayachandra, Mu Zhang, and Heng Yin. 2012. V2E:
Combining Hardware Virtualization and Software Emulation for Transparent
and Extensible Malware Analysis. In Proceedings of the 8th ACM SIGPLAN/SIGOPS
Conference on Virtual Execution Environments (VEE’12).
[85] Qinghua Zhang and Douglas S. Reeves. 2007. MetaAware: Identifying Metamor-
phic Malware. In Proceedings of the 23rd Annual Computer Security Applications
Conference (ACSAC’07).
[86] Yongxin Zhou, Alec Main, Yuan X. Gu, and Harold Johnson. 2007. Information
Hiding in Software with Mixed Boolean-Arithmetic Transforms. In Proceedings
of the 8th International Workshop on Information Security Applications (WISA’07).
Appendix A
A common virtualization procedure is shown as follows.
a) In the source code of the program that will be virtualized, insert
marks around the sensitive area. In C/C++ code, typically the mark
is implemented as macros. Figure 8 shows such an example.
b) Compile the source code using a normal compiler like GCC or MS
VC++. The code is linked to a library provided by the virtualization
tool. The result is an executable file. In this step, the sensitive area
in the executable file is not obfuscated. It is only marked.
c) Run the virtualization tool to process the executable file. The
virtualization tool will translate the marked area to the virtualized
code and append the virtual machine in the binary code.
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
...
#include "VirtualizerSDK.h"
int f(int a)
{
int b = 1;
VIRTUALIZER_START
a++;
VIRTUALIZER_END
return a + b;
}
// The macro marks the
// starting point of the
// virtualized area
// The macro marks the ending
// point of the virtualized
// the area
Figure 8: An example showing the virtualization marks in
the source code to be virtualized. The macros mark the start-
ing and ending point of the sensitive area which will be vir-
tualized.
Sensitive Area. According to the manual book of the vir-
A.0.1
tualization tools, users should prevent the following cases when
applying virtualization to a program.
• Users should avoid virtualizing a loop that repeats many
times to avoid too much performance loss.
• Switch/Case statements and exception handling inside a
sensitive area might not work properly after virtualization.
Therefore, those program structures are not recommended
to be virtualized.
In practice, due to the performance overhead and the compatibil-
ity problems, virtualization can only be applied to limited program
structures and areas. The recommended way of applying virtual-
ization is only protect the sensitive area in your program.
One typical situation of the sensitive area is the checking pro-
cedure in a trial/registration scheme of an application. The same
application can run in two modes, the trial mode or the registered
mode. The registered mode provides full features whereas the trial
mode only provide limited features. Figure 9 shows an example
of the registration checking function and the recommended way
of protecting them by virtualization. The function f runs differ-
ent branches based on the value of the global variable reg_mode.
Therefore, all snippets that reads or write reg_mode should be
considered as sensitive areas and should be virtualized.
Basically, the trial/registration scheme needs a checking mecha-
nism to decide in which mode the application should run. For ex-
ample, the checking mechanism can be implemented as a function
to verify whether a serial number is eligible. Figure 9 shows an ex-
ample of the registration checking function and the recommended
way of protecting them by virtualization. The global boolean vari-
able at the first line stores the mode of the application. true
means the program is running under the registered mode and
false means the trial mode. At line 8 in the main function, the
application check whether it is registered by calling the function
checkRegistration(). The function will return true if the se-
rial number is eligible or false if not. The function f includes two
branches for the registered mode and trial mode, respectively. It
checks the global variable reg_mode and then select one branch to
execute. In this example, the global variable reg_mode is sensitive
because the trial/registration scheme can be work around if we
can modify its value. Therefore, any snippet that reads or write it
should be considered as sensitive area and should be virtualized.
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
bool reg_mode;
int main ()
{
...
VIRTUALIZER_START
reg_mode = checkRegistration(); // sensitive area 1
VIRTUALIZER_END
...
}
void f()
{
VIRTUALIZER_START
if (reg_mode) {
// sensitive area 2
// code for registered verion
} else {
// code for trial version
}
VIRTUALIZER_END
}
Figure 9: An example showing a registration checking func-
tion and the sensitive area being virtualized.