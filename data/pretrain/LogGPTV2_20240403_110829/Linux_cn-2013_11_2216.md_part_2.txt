注意：cgroup是一组进程。
下面我们要求回答"Device controller for cgroups (CGROUP\_DEVICE)"(Cgroup的设备控制器)。cgroup(控制组)是一种用来控制资源使用的特性。回答"yes"可以允许设备cgroup的白名单可以使用open和mknod系统调用(用来创建文件系统节点的系统调用)。
下一个问题(Cpuset support (CPUSETS))（CPU分组支持）询问的是内核是否可以创建和管理CPU分组。这允许管理员可以在一个系统上动态分配各组内存节点，并分配任务在这些内存上运行。这通常用于SMP和NUMA系统中。我这个问题回答的是"no"。
注意：请记住，如果我没有指定我选的是什么，那么我选的就是默认选项。
启用cgroup统计子系统(Simple CPU accounting cgroup subsystem (CGROUP\_CPUACCT))（Cgroup子系统的简单CPU统计）会生成一个资源控制器来监控在一个cgroup组内的独立任务的CPU使用情况。我选择了"no"。
资源计数器(Resource counters (RESOURCE\_COUNTERS))使控制器的独立资源统计功能能够统计cgroup。我选择了"no"。
下一个问题(Enable perf\_event per-cpu per-container group (cgroup) monitoring (CGROUP\_PERF))（启用每个CPU、每个容器组的pref\_event监控）允许开发者扩展每个CPU的模式，使它可以只监控运行在特定CPU上的一个特别的cgroup组的线程。
下一章节是"Group CPU Scheduler"（CPU分组调度器）。前两个已经回答的问题包括：
Group CPU scheduler (CGROUP*SCHED)（CPU分组调度器） Group scheduling for SCHED*OTHER (FAIR*GROUP\*SCHED)（SCHED\_OTHER分组调度）
第一个已回答的问题(CPU bandwidth provisioning for FAIR\_GROUP\_SCHED (CFS\_BANDWIDTH))（CPU带宽分配）询问的是内核是否允许用户设置在公平组调度器内执行的任务的CPU带宽限制。没有限制的组会被认为不受约束，并会没有限制地运行。
注意：并不是所有内核选项都在这里。我这里提到的组只是为了便于阅读，并挑出那些新的和大的部分。并不需要了解所有的分组。分组有助于使用图形工具配置内核，这样开发者可以在搜索特定的设置时，直接通过分组菜单找到。
开发者可以通过回答"Group scheduling for SCHED\_RR/FIFO (RT\_GROUP\_SCHED)"（SCHED\_RR/FIFO分组调度）这个问题为"yes"来让用户可以分配CPU带宽到任务组中。
下一个问题是"Block IO controller (BLK\_CGROUP)"（阻塞IO控制器）。任务组可以被识别，并且它们的磁盘带宽是由使用块IO控制器实现的CFQ IO调度器分配的。BIO在块级的限制逻辑使用块IO控制器来提供设备上的IO速率上限。
这里有一个调试问题(Enable Block IO controller debugging (DEBUG*BLK*CGROUP) [N/y/?])（启用阻塞IO控制器的调试）询问是否启用块IO控制器的调试。为了制作一个精简的内核，最好禁用这个特性。
为了启用内核中的检查点和还原特性。这个问题“Checkpoint/restore support (CHECKPOINT\_RESTORE)”（检查点及还原支持）可以选择“yes”，不过为了更低的负载这里我选择了“n”。启用这个特性会增加辅助的进程控制代码来设置进程的代码段、数据段和堆的大小，并增加了一些额外的程序入口。
下面我们就要配置命名空间的支持了。命名空间是一组标识符的容器。比如，/usr/lib/python3/dist-packages/re.py就是一个标识符，/usr/lib/python3/dist-packages/就是一个命名空间。而re.py是这个命名空间下的本地名称。
第一个命名空间问题(Namespaces support (NAMESPACES))询问的是是否启用命名空间。这允许可以使用相同的PID但在不同的命名空间内(译注：原文为" This will allow the same PIDs (Process ID) to be used but indifferent namespaces",这里indiffernt根据上下文应该是少了空格)，否则PID永远不会重复。
下一个问题(UTS namespace (UTS\_NS))询问是否可以让UTS命名空间内的任务可以在uname()系统调用中看到不同的信息。uname()系统调用提供查看机器和操作系统的信息。
启用IPC命名空间(IPC namespace (IPC\_NS))将允许在这个命名空间内的任务与其他命名空间内相对应IPC ID的对象协同工作。
PID命名空间(PID Namespaces (PID\_NS))就是进程ID命名空间。这可以使不同的进程在不同的PID命名空间使用相同的PID。这是一个容器的构建块。
接下来，启用网络命名空间(Network namespace (NET\_NS))可以使用户创建一个拥有多个实例的网络栈。
当启用后,自动进程分组调度(SCHED\_AUTOGROUP)会填充并创建任务组来优化桌面程序的调度。它将把占用大量资源的应用程序放在它们自己的任务组，这有助于性能提升。
这里是一个调试特性，除非你有特别的需求否则应该禁用它。这个问题(Enable deprecated sysfs features to support old userspace tools (SYSFS\_DEPRECATED))（启用不推荐的sysfs功能来支持旧式的用户空间工具）询问是否启用sysfs，这是调试内核时用的虚拟文件系统。
接下来，因为当前的配置需要它，所以"Kernel->user space relay support (formerly relayfs) (RELAY)"（内核->用户空间的中继支持，即relayfs）已经被设成"yes"了。最好启用initrd支持(Initial RAM filesystem and RAM disk (initramfs/initrd) support (BLK\_DEV\_INITRD))（初始化内存文件系统和内存盘(initramfs/initrd)）。
用户会被问及哪里放置initramfs源文件。如果没有需要，请留空。
接下来,开发人员会被询问关于初始虚拟磁盘(Linux的内核映像文件)所支持的压缩格式。你可以启用所有支持的压缩格式。
* Support initial ramdisks compressed using gzip (RD\_GZIP)
* Support initial ramdisks compressed using bzip2 (RD\_BZIP2)
* Support initial ramdisks compressed using LZMA (RD\_LZMA)
* Support initial ramdisks compressed using XZ (RD\_XZ)
* Support initial ramdisks compressed using LZO (RD\_LZO)
这里设置了内核的编译内核编译选项(Optimize for size (CC\_OPTIMIZE\_FOR\_SIZE))（优化大小）。开发者可以让编译器在编译时优化代码。我选择了"yes"。
用户想要配置更多的内核特性，那么下个问题就回答"yes"(Configure standard kernel features (expert users) (EXPERT))（配置标准内核特性（专家级用户））。
要启用过时的16位UID系统调用封装器，这个问题设成"yes"(Enable 16-bit UID system calls (UID16))。系统调用就会使用16位UID。
推荐启用"sysctl syscall"(Sysctl syscall support (SYSCTL\_SYSCALL))支持。这使/proc/sys成为二进制路径的接口。
接下来的两个问题已经被预先回答了"yes",它们是"Load all symbols for debugging/ksymoops (KALLSYMS)"（载入所以的调试符号）和"“Include all symbols in kallsyms (KALLSYMS\_ALL)"（包括所有的kallsyms符号）。这些都是启用调试标志。
下一步，开发者应该启用printk支持( (Enable support for printk (PRINTK)))，这会输出内核消息到内核日志中。这在内核出错时是很重要的。编译一个"哑巴"内核并不是一个好主意。然而，如果我们启用了这个支持，就会被一些开发者看到这些出错，要么就不要启用。
除非有必要，开发者可以禁用bug支持(BUG() support (BUG))。禁用这项将会不支持WARN信息和BUG信息。这会减小内核的体积。
---
via: 
译者：[geekpi](https://github.com/geekpi) 校对：[wxy](https://github.com/wxy)
本文由 [LCTT](https://github.com/LCTT/TranslateProject) 原创翻译，[Linux中国](http://linux.cn/) 荣誉推出