不会利用study的结果（和其他优化）。
不应该使用study的情况
Y
·如果只使用/i，或是所有正则文字都受（？i）或（？i：）作用，就不应该对字符串使
用study，因为它们不能从study中受益。
·
如果目标字符串很短，也不应该使用study。因为此时，正常的固定字符串识别优化
（247）已经足够了。那么“短”究竟如何界定呢？字符串的长度没有确切的标准，
所以具体来说，只有进行性能测试才能判断study是否有益。不过权衡利弊，我通常
不使用study，除非字符串的长度为若干KB。
---
## Page 386
360
第7章：Perl
如果你只希望在修改之前，或是study不同的字符串之前，对目标字符串进行少数几次匹
配，请不要使用study。如果要获得真正的性能提升，必须是多次匹配节省下来的时间长
于study的时间。如果匹配次数较少，花在study身上的时间抵不上节省的时间，得不偿
失。
只对期望使用包含“独立出来的”文字（255）的正则表达式搜索的字符串使用study。
如果不知道匹配中必须出现的字符，study就派不上用场（看了这几条，也许你会认为，
study对index函数有益，但事实并非如此）。
什么时候使用study
最适合使用study的情况就是，目标字符串很长，在修改之前会进行许多次匹配。一个简
单的例子就是我在写作本书时所用的过滤器。我用自己的标记法写稿，然后用过滤器转换
为SGML（再转换为trof，再转换为PostScript)。经过过滤器内部，一整章变为一个大字符
串（例如，本章的大小为475KB）。在退出之前进行多项检查来保证不会漏过错误的标记。
这些检查不会修改字符串，它们通常查找固定长度的字符串，所以它们很适合于study。
性能测试
Benclumarking
如果你真的关心效率，最好的办法就是进行性能测试。Perl自带的Benchmark模块提供了
详细的文档（"perldocBenchmark"）。可能是习惯使然，我更喜欢从自己动手写性能测试：
use Time::HiRes 'time';
我把希望测试的内容简单包装成：
my $start = time;
my $delta = time -$start;
printf "took $.1f seconds\n*，$delta;
性能测试的重要问题包括，确保性能测试进行了足够多的工作，显示的时间真正有意义，
尽可能多地测试希望的部分，尽可能少地测试不希望的部分。在第6章有详细的讲解
(232）。找到正确的测试方法可能得花些时间，但是结果可能非常有价值，也很值得。
---
## Page 387
效率
361
正则表达式调试信息
RegexDebuggingInformation
Perl提供了数量众多的优化措施，期望能够尽可能快地找到匹配：第6章的“常见优化措
施”（204）介绍了基础的措施，但还有许多其他的措施。大多数优化只能应用于专门的
情况，所以特定正则表达式只能从其中的某一些（甚至是没有）获益。
Perl的调试模式（debuggingmode）能提供优化的信息。在正则表达式第一次编译时，Perl
会选择这个正则表达式所使用的优化措施，而调试模式会显示其中的一部分。调试模式同
样可以告诉我们引擎是如何应用表达式的。仔细分析这些调试信息不属于本书的范围，但
我会在这里给出简要介绍。
在程序中可以通过usere‘debug'；来显示调试信息，用nore'debug';来关闭（上文
曾出现过编译指示usere，根据不同的参数，启用或禁用插值变量中的内嵌代码口337）。
如果希望在整个脚本中启用此功能，可以使用命令行参数-Mre=debug。这很适合检查单个
的正则表达式的编译方法。下面是一个例子（只保留了相关的行）：
①%perl-cw-Mre=debug-e'm/^Subject:（.*)/'
Compiling REx·^Subject:（.*)
rarest charjat3
1:BOL (2)
?
2:EXACT (6)
?
=
12: END (0)
Omitting $'$& $'support.
在0处从shell提示符启动perl，使用命令行参数-c（意思是检查脚本，而不是确切执行它），
w（如果Perl对代码存有疑问，就会发出警报），以及-Mre=debug启用调试。-e表示下面
的参数‘m/^Subject：·（.*）/’是一段Perl代码，需要运行或者检查。
行报告表达式固定长度的字符串中“出现频率最低”的字符（由Perl猜测）。Perl根据这
一点进行某些优化（例如预查所需字符/子串245）。
---
## Page 388
362
第7章：Perl
第O到行表示Perl编译好的正则表达式。因为篇幅的原因，我们在这里不会花太多的工夫。
不过，即使是随便看看，第行也不难理解。
第行对应大多数行为。可能显示的信息包括：
它表示匹配必须包含某个字符串，此字符串在匹配中的偏移值为ofset。如果s紧跟在
·String之后，那么string是匹配结尾的元素。
floating'string'atfrom..to
它表示匹配必须包含某个字符串，此字符串在匹配中处于从from（开始）到to（结束）
中的任意位置。如果s紧跟在·String'之后，string是匹配结尾元素。
stclass 'list'
它表示匹配可能的并始字符。
anchored(MBOL)，anchored(BOL)，anchored(SBOL)
说明表达式以开头。MBOL说明使用了/m修饰符，BOL和SBOL表示没有使用（BOL
和SBOL的区别在现代Perl中没有意义。SBOL与S*变量有关，而此变量已被废弃了）。
anchored(GPOS)
说明正则表达式以G开头。
implicit
说明anchored（MBOL）是由Perl隐式添加的，因为正则表达式以.*开头。
minlenlength
代表匹配成功的最小长度。
with eval
说明表达式包含（？（}）或是（？？（}）
第行与正则表达式无关，只有当二进制代码中的编译启用了-DDEBUGGING时才会出现。
如果启用，在载人整个程序之后，Perl会报告是否启用了对S&等变量的支持（356）。
运行时调试信息
我们知道如何利用内嵌代码获得匹配的运行信息（331），但是Perl的正则表达式调试可
以提供更多的信息。如果去掉表示“仅编译”的-c选项，Perl会提供更多关于匹配运行细
节的信息。
---
## Page 389
结语
363
则表达式永远无法在目标字符串中匹配，所以会忽略任何尝试，下面是一个例子：
%perl -w-Mre=debug -e '"this is a test"=~m/^Subject:/:
Did not find anchored substr'Subject:'?
Match rejected by optimizer
提供的正则表达式。例如：
...大量调试信息...
它没有进行任何操作，只是装载了warning模块，但是因为这个模块包含正则表达式，我
们仍然会见到许多调试信息。
显示调试信息的其他办法
我已经提到，可以使用“usere‘debug'；”或-Mre=debug来启用正则表达式的调试。不
过，如果把所有的debug替换为debugcolor，而终端又支持ANSI转义控制字符（ANSI
terminalcontrolescapesequences），输出的信息就会以高亮标记，更容易阅读。
另一个办法是，如果Perl二进制代码在编译时启用了调试支持，可以使用命令行参数-Dr
来表示-Mre=debug。
结语
Final Comments
我确信自己已经陶醉于Perl的正则表达式中，本章的开头我曾提到，这是有充分理由的。
Perl之父LarryWall，完全是按照常识和发明的动力（MotherofInvention）来做的。是的，
Perl的正则表达式实现也有自己的问题，但是我仍然愿意醉心于Perl正则语言丰富的功能，
及其与Perl其他部分的融合。
当然，我热情而不盲目一Perl并没有提供某些我希望的特性。本书第1版渴望的某些特性
现在已经添加了，我会继续提出要求，希望Perl会继续添加。相对于其他实现，Perl最急
需提供的功能是命名捕获（?138)。本章给出了模拟的办法，但还存在若干限制。提供内
建支持是最好的解决办法。如果能提供字符组集合运算（125）也很好，虽然目前可以费
点周折用顺序环视来模拟（?126）。
---
## Page 390
364
第7章：Perl
然后是占有优先量词（142）。Perl的固化分组提供了更多的完整功能，但是在某些情况下
占有优先量词的解法更清楚更美观。所以，两种办法我都喜欢。事实上，还有两个我喜欢
两个相关结构，目前还没有任何流派提供。其中之一是“cut”操作，或者叫"\v，它会立
刻清除当前存在的所有保存状态（这样，x+\v就等于'x++或者（?>X+）)。另一个结构用
来禁止传动装置的任何进一步的操作。它的意思是“要么在当前路径找到一个匹配，要么
就不容许任何匹配，没有其他可能。”可能用V来表示比较好。
还有个与v有关的想法，我认为在传动装置中添加通用的钩子功能（generalhooks）是有
用的，这样第335页的程序就可以大大化简。
最后要说的是，我在第337页曾经提到，在内嵌代码插值到正则表达式时，提供更多的控
制是非常有用的。
Perl当然不是理想的正则表达式语言，但它很接近这个目标，而且一直在进步。
---
## Page 391
8
第
章
Java
java
自2002年早期发布的Java1.4.0以后，Java就内建了正则表达式包，java.util.regex，
它的API毫不复杂（可以称得上简单），提供了强大而有创意的功能。对Unicode的支持很
棒，文档很清晰，运行速度也很快。它能够用来匹配CharSequence对象，所以使用起来
非常方便。
sjava.util.regex一经发布就给人留下了深刻印象。它的功能、速度和正确性都达到了非
常高的水平，尤其是对初次发布的软件来说，更是如此。Java1.4的最终版本是1.4.2。写作
本书时，Java1.5.0（也叫Java5.0）已经发布，而Java1.6.0（也叫Java6.0）已经发布了第
二个beta版本。本书针对的是Java1.5.0，不过我会在合适的时候提到它与Java1.4.2或Java
1.6.0之间的重要差异（这些差异的总结在本章末尾401）（注1）。
与之前各章的联系
在阅读本章之前，我必须说明，这一章不会重复第1章到第6章介绍的所有知识。有些只
关心Java的读者可能会直接从这章开始阅读，我希望他们不要错过前言和开头几章的内容：
第1、2、3章介绍了正则表达式的基本概念、特性和技巧，第4、5、6章包含了理解正则
表达式的关键知识，它们可以直接应用到javautiregex中。开头几章讲解的重要概念
包括NFA引擎的工作原理、匹配优先性、回溯和效率。
注1：本书可以适用于Java15.0Update7。Java1.5的最初版本在进行不区分大小写的匹配时存
在若干bug。Update2修整了这些问题，所以如果你的Java版本低于它，我推荐你升级。
Java1.6beta的信息针对当前发布的beta2,build59g版。
---
## Page 392
366
第8章：Java
表8-1：方法名索引1（按字母、页码排序）
380
appendReplacement
373
matcher
379
replaceFirst
381
appendTail
376
matcher(Matcher)
390
reguireEnd
372
compile
395
matcher (Pattern)
392
reset
377
end
393
pattern(Matcher)
395
split
375
find
394
pattern(Pattern)
377
start
394
flags
395
quote
394
text
377
group
379
QuoteReplacement
377
toMatcheResult
377
groupcount
386
region
393
toString(Matcher)
388
hasAnchoringBounds
386
regionEnd
394
toString(Pattern)
387
hasTransparentBounds
386