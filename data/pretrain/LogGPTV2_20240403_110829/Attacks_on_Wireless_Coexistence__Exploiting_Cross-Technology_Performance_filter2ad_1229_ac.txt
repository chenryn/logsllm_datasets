a
B
I
X
A
1
0
3
-
C
N
I
WL HOST WAKE
WL DEV WAKE
JTAG
Other GPIOs
SDIO D
PCIe
AXI2APB
SDIO 3.0
PCIe 1.1
D11 Core (MAC)
1×1 802.11ac PHY
RF Switch Controls
2.4 GHz/5 GHz 802.11ac
Dual-Band Radio
XTAL
FEM or SP3T
2.4 GHz
FEM or SPDT
5 GHz
Diplexer
Fig. 3: Coexistence interfaces as documented for the Google Nexus 5 chip [18], discovered vulnerabilities marked in red.
Authorized licensed use limited to: Tsinghua University. Downloaded on August 07,2022 at 12:34:02 UTC from IEEE Xplore.  Restrictions apply. 
51233
TABLE II: Wi-Fi code execution and data leak through Wi-Fi/Bluetooth shared RAM (CVE-2020-10368, CVE-2020-10367).
Device
Nexus 5
iPhone 6
Raspberry Pi 3
Raspberry Pi 3B+/4
Samsung Galaxy S6, Google Nexus 6P
Chip
BCM4335C0
BCM4345B0
BCM43430A1
BCM4345C0
BCM4358A3
BCM20703A2 MacBook Pro 2016
BCM4355C0
BCM4347B0
BCM4347B1
BCM4375B1
BCM4375B1
BCM4375B1
BCM4377B3
BCM4364B3
BCM4378B1
iPhone 7
Samsung Galaxy S8/S8+/Note 8
iPhone 8/X/XR
Samsung Galaxy S10/S10e/S10+
Samsung Galaxy S10/S10e/S10+/S20/Note 20 5G
Samsung Galaxy S20/Note 20 5G
MacBook Pro+Air, 2019–2020 (PCIe)
MacBook Pro+Air, 2019–2020 (UART)
iPhone 11/SE2
Tested OS with FW Updates
Android 6.0.1
iOS 12.4–12.5.1
Raspbian Buster
Raspbian Buster
Lineage OS 14.1
–
iOS 13.3–14.3
Android 8.0.0
iOS 13.3–14.7
Android 9
Android 10
Android 11
macOS 10.15.1–10.15.7
macOS 10.15.4–10.15.6
iOS 13.3–13.5
FW Build Date
Dec 11 2012
Jul 15 2013
Jun 2 2014
Aug 19 2014
Oct 23 2014
Oct 22 2015
Sep 14 2015
Jun 3 2016
Oct 11 2016
Apr 13 2018
Apr 13 2018
Apr 13 2018
Feb 28 2018
May 9 2018
Oct 25 2018
FW Accesses wl_buff
×
×
×
(cid:88)(cid:88)(cid:88)
×
(cid:88)(cid:88)(cid:88)
×
(cid:88)(cid:88)(cid:88)
(cid:88)(cid:88)(cid:88)
×
×
×
×
×
×
Code Execution
?
(cid:88)(cid:88)(cid:88)
?
(cid:88)(cid:88)(cid:88)
(cid:88)(cid:88)(cid:88)
•
(cid:88)(cid:88)(cid:88)
(cid:88)(cid:88)(cid:88)
(cid:88)(cid:88)(cid:88) ( <14.3)
(cid:88)(cid:88)(cid:88)
(cid:88)(cid:88)(cid:88)
(cid:88)(cid:88)(cid:88)
(cid:88)(cid:88)(cid:88) ( <10.5.7)
(cid:88)(cid:88)(cid:88)
(cid:88)(cid:88)(cid:88)
? Mentioned in datasheet but probably different mapping, did not work in our test.
• Likely vulnerable but no physical device available for testing.
(cid:88)(cid:88)(cid:88) Code execution within Wi-Fi successfully tested.
Kernel panic observed on the OS (Android/iOS/macOS).
Issues persist on all tested up-to-date devices, but not all OS updates were tested due to limited device and jailbreak availability.
The Wi-Fi ﬁrmware is always loaded to the same addresses.
Thus, once code execution was conﬁrmed on a single chip
and ﬁrmware patch level, the identiﬁed region is valid on all
devices of the same model and patch level.
We conﬁrm code execution by analyzing crash logs. How-
ever, after initial conﬁrmation and exploit development, log-
ging is no longer required. Android, macOS and iOS generate
Wi-Fi crash logs, including a full chip RAM dump. We use
RAM dumps to conﬁrm that we can write to the shared
RAM and got code execution. On Android, Wi-Fi crash
logs and memory dumps are written to /data/vendor/
log/wifi/. On some models, memory dumps are disabled,
but the Wi-Fi chip still logs to the kernel, observable via
/dev/kmsg. macOS and iOS use a different debug format.
On iOS, creating these logs requires an additional Wi-Fi debug
proﬁle [4]. macOS and iOS both write to the common log
directory. The folder name already contains the crash cause
and the ﬁle SoC_RAM.bin contains the RAM dump.
Finding exploitable regions can be automated by sending
randomized branch instructions as bytecode. For example, if
the Bluetooth chip writes the instruction b 0xcafebabe to a
shared RAM address and Wi-Fi executes it, it will crash since
there is no valid code at the branch target. The Wi-Fi ﬁrmware
fault handler forwards the exception to the Wi-Fi driver prior to
resetting. Thus, the address 0xcafebabe appears in the OS
Wi-Fi crash logs. The last address byte differs due to ARM-
speciﬁc branch handling. We ﬁnd shared RAM regions that
immediately trigger Wi-Fi chip code execution.
While using this method to identify executable code regions,
the Bluetoth chip frequently continues sending bytes to the
shared RAM region even after the Wi-Fi chip crashes. The
Bluetooth chip can already control the shared RAM during
early Wi-Fi chip initialization. In this state, the Wi-Fi chip
is not connected to any network. After each chip crash, the
code execution ﬁnder should wait at least 10 s, ensuring that
executable regions are reached during a regular chip state.
The Wi-Fi crash logs contain further insights into the chip’s
current state and information. For example, when the chip
crashes while being connected to a network, the RAM dump
contains the network name and password. Thus, an attacker is
able to access this information.
This attack only affects combo chips. Separate chips lack the
bus used for memory sharing, and thus, coexistence coordina-
tion via pure serial interfaces is not affected. Almost all chips
manufactured by Broadcom are combo chips. Some Cypress-
branded chips, such as in the Raspberry Pi, are similarly
affected by shared RAM attacks [16].
3) Over-the-Air Code Execution: Bluetooth→Wi-Fi code
execution can be triggered over the air. We show the potential
of coexistence exploitation by building an over-the-air Proof
of Concept (PoC) on a Samsung Galaxy S8. The authors of
Frankenstein published CVE-2019-11516 [48], an over-the-
air Bluetooth code execution vulnerability. This issue was
reported in April 2019, and patches were rolled out in fall
2019. We downgrade the S8 Bluetooth ﬁrmware to a January
2019 patchlevel to ensure it is still vulnerable. We keep the
remaining system on an up-to-date Samsung stock ROM,
including the Wi-Fi ﬁrmware. The following equipment is
required to perform the attack:
• CYW20735 evaluation board with a ﬁrmware modiﬁ-
cation to set shellcode device names and change the
Bluetooth MAC address, taken from the Frankenstein
repository [46].
• Raspberry Pi or other Linux device with the BlueZ stack.
• A battery pack (optional).
The total costs of this portable setup are below USD
100. Such a mobile attacker is hard to locate. While the
original PoC was meant to write arbitrary memory on the
Authorized licensed use limited to: Tsinghua University. Downloaded on August 07,2022 at 12:34:02 UTC from IEEE Xplore.  Restrictions apply. 
61234
Bluetooth chip, combining this with the shared Wi-Fi RAM
allows us to control arbitrary Wi-Fi memory, resulting in Wi-Fi
code execution. On the speciﬁc Wi-Fi version running on
the Samsung Galaxy S8, the Bluetooth address 0x6841d2
is mapped to the Wi-Fi address 0x1841d2, and the code at
this address is executed regularly. When writing the shellcode
b 0xcafebabe to this address via Bluetooth, the Wi-Fi
console output read from /dev/kmsg shows that the code
is executed:
CONSOLE: 000000.454 wl1: Broadcom BCM4361 802.11 Wireless
Controller 13.38.63 (B0 Network/rsdb)
CONSOLE: 000000.456 ThreadX v5.6 initialized
CONSOLE: TRAP 3(2bfea0): pc
cafebabc, lr 1843ef, sp 2bfef8, ...
Note that CVE-2019-11516 was only ﬁxed on devices that
still received ofﬁcial security updates in fall 2019. Devices like
the Google Nexus 5 or Samsung Galaxy S6 remain unpatched.
Unofﬁcial Android images, e.g., LineageOS, only contain OS
updates—updated ﬁrmware patches require a collaboration
between Broadcom and, respectively, Samsung and Google.
All
4) Wi-Fi Kernel Driver Issues: Finding Wi-Fi kernel vul-
nerabilities is not a focus of this paper and has concep-
tually been covered by previous work [8], [9], [60]. Yet,
our Bluetooth→Wi-Fi coexistence test setup triggers kernel
panics across multiple OSes. After our reports, the vendors
ﬁxed kernel panics caused by missing PCIe and Wi-Fi state
management. Kernel panics and ﬁxes are listed in Table II.
these crashes were produced while probing the
Bluetooth→Wi-Fi shared RAM interface. This indirectly
fuzzes the Wi-Fi→host interface, most of the time by crashing
the Wi-Fi chip when the OS driver does not expect it. Thus,
the majority of these kernel panics are caused by PCIe bus
timeouts and failed attempts to bring up the Wi-Fi chip again
on Android, macOS, and iOS. Interestingly, some of these
crashes indicate more substantial issues—e.g., a malformed
PCIe Input–Output Memory Management Unit (IOMMU)
request on iOS. This means that the fuzzer also manipulates
data sent to the host via PCIe.
Overall, the stability issues found in the kernels indicate
that Wi-Fi drivers were not tested sufﬁciently. We assume that
especially unexpected states that over-the-air setups cannot
trigger but via coexistence were not considered, such as invalid
replies during driver initialization or network connection setup.
While we were working on coexistence issues inside the chips,
other researchers found various issues within Apple’s Wi-Fi
stack in parallel [8], [60].
D. Serial Enhanced Coexistence (Broadcom & Cypress)
The proprietary Serial Enhanced Coexistence Interface
(SECI) by Broadcom and Cypress is used internally in combo
chips. In addition, it is exposed on chips that only support
Bluetooth or Wi-Fi, and it can be manually connected. SECI
is largely undocumented, except for the information covered
in Section V-D1. Its functionality can be observed with a
logic analyzer as described in Section V-D2, resulting in
understanding the SECI physical layer in Section V-D3. After
understanding the protocol, we can mount DoS and informa-
tion disclosure attacks from the ﬁrmware—without a logic
analyzer or other hardware modiﬁcations. A Bluetooth DoS
on the grant reject scheme is demonstrated in Section V-D4.
A more severe attack, where Wi-Fi observes packet types
and timings of Bluetooth keyboards to determine keystroke
timings, is shown in Section V-D5.
1) Documentation: The BCM4339 datasheet in Figure 3
shows multiple coexistence interfaces [18]. GCI supports
various coexistence mechanisms, such as standardized MWS
and proprietary SECI. SECI uses UART to transmit 64 bit
coexistence data [19], [58]. Wi-Fi sends its current trans-
mit channels to Bluetooth, which blocklists them. Moreover,
SECI contains timeout parameters, such as Asynchronous
Connection-Less (ACL) and Synchronous Connection Ori-
ented (SCO) timeout limits, powersave and idle timers, as
well as medium request and grant timers. Priorities of Wi-Fi
and Bluetooth are hardcoded. Audio, video, BLE, and Human
Interface Devices (HIDs) have the highest priority, while ﬁle
transfer has the lowest priority. During Wi-Fi powersave, all
Bluetooth requests are granted. Otherwise, coexistence polls
between Wi-Fi and Bluetooth.
These features extend PTA. As the Cypress coexistence
application note states, the chips already implement PTA [19].
SECI augments PTA with additional information to enable
more advanced coexistence methods.
2) Reverse-engineering: SECI uses a Bluetooth→Wi-Fi
wire and a Wi-Fi→Bluetooth wire. Both wires operate at
3 MBaud and indicate all packets, including metadata, such as
the packet type. For comparison, the Bluetooth↔Host UART
interface that carries all Bluetooth data also transmits with
3 MBaud. Both the Wi-Fi ﬁrmware and D11 core as well as
the Bluetooth ﬁrmware access SECI. The Wi-Fi D11 core is
Wi-Fi
CYW43907
Bluetooth CYW20719
Fig. 4: Debugging setup for the Cypress SECI between a
separate Wi-Fi and Bluetooth chip.
Authorized licensed use limited to: Tsinghua University. Downloaded on August 07,2022 at 12:34:02 UTC from IEEE Xplore.  Restrictions apply. 
71235
BT
Wi-Fi
Start scan
Last result
End scan
3.2
3.4
3.6
3.8
4
4.2
4.4
4.6
4.8
5
5.2
Time (s)
5.4
5.6
5.8
6
6.2
6.4
6.6
6.8
7
a) SECI while streaming music via Bluetooth and scanning for Wi-Fi access points.
BT
Wi-Fi
db 03 db 22
3.83632445
fe
db e1 db 3c
Time (s)
3.83641841
b) SECI while streaming music via Bluetooth and scanning for Wi-Fi access points, zoomed in to ﬁrst Wi-Fi peak.
Fig. 5: Initial SECI observations.
a reprogrammable low-level processor that implements a state
machine for the ﬁrst packet processing stage [51].
Combo chips have an integrated SECI connection, but even
separate Wi-Fi and Bluetooth modules can be connected with
SECI. Each chip generation implements a slightly different
version, and only speciﬁc chips can be connected [19]. Major
differences are 48 bit or 64 bit data size and 3 MBaud or
4 MBaud data rate. Irrespective of physical layer details, SECI
is abstracted as hardware-mapped registers. Once a fresh value
is written to an output register on one wireless core, it is
received as input on the other wireless core.
For the initial analysis, we reproduce a coexistence setup
with a separate Wi-Fi and Bluetooth chip [59]. Then, we
intercept the exposed SECI with a logic analyzer, as shown in
Figure 4. Wi-Fi TP17 and TP18 are connected to Bluetooth
D8 and A0, respectively. The black board is required for Wi-
Fi programming and debugging but has no further wireless
functionality. In this setup, all information exchanged between
Wi-Fi and Bluetooth only originates from SECI. Antenna locks
and other signal-related effects can be excluded.
With this setup, SECI messages can be observed, and their
meanings can be reverse-engineered. SECI is not implemented
inside the ﬁrmware but an external hardware component. The
Bluetooth and Wi-Fi ﬁrmware only use hardware register map-
pings to write values over the serial protocol (mapping details
for reproducing our experiments are provided in Appendix
A-B). According to our threat model, the attacker only has
code execution on one of the wireless core, but cannot attach
cables. Thus, the attacker can only observe values in these