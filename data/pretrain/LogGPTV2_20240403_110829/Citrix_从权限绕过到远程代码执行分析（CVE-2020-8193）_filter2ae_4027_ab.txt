    }
    ...
    if($args != "")
    {
        $query_params .= "&args=" . $args;
    }
随后跟进`command_execution`函数第264行，发现这里对`$query_params`参数进行了过滤，需要`$query_params`参数中带有
`loginchallengeresponse` 字符串才能走到 `if`
逻辑里，随后检查`$query_params`参数重是否含有`requestbody`，才能进一步执行，覆盖参数`$query_params`，得到我们想要的结果。
因此，我们需要在请求参数中携带`loginchallengeresponse`和`requestbody`，而此时请求参数`$query_params`仅包含了`view`和`sessionid`，根据上文分析，我们只能对sid参数进行控制：`sid=loginchallengeresponseIIIrequestbody`。command_execution函数过滤方法代码片段如下：
`command_execution()`
    if (strpos($query_params, 'loginchallengeresponse') !== false)
        {
            $query_array = explode("&", $query_params);
            $request_body = "";
            for ($i = 0; $i v1($arg_list[0], $arg_list[1] . $query_params);
    ...
    // Process result
    if(ns_empty($nitro_return_value) || $nitro_return_value === false)
    {
        $this->set_error_code();
        $this->set_error_message($command);
    }
`ns_empty` 的实现附录如下,当该函数传入变量不为空且不等于 `"0"` 的时候返回 `true`，然而恰巧 `$nitro->v1` 的返回值是
`0`，从而使得 `ns_empty` 返回结果为 `False` 最终实现绕过。
`ns_empty()`
    function ns_empty(&$var)
    {
        return empty($var) && ($var != "0");
    }
至此，我们通过一系列分析使得`ns_empty`函数返回 False，从而绕过权限验证，创建了一个未授权的session
###  修复 Session
此时，我们已经创建了一个未授权的
`session`，由于在绕过`command_execution()`函数过滤时，我们将sid设置成了`loginchallengeresponseIIIrequestbody`，因此此时不能够直接使用创建的伪造session，我们需要对$_SESSION[‘NSAPI’]也就是sid进行修复。
借助`admin_uiphpapplicationcontrollerscommonmenu.php` 文件中的 `setup_session` 函数，传入
`username`、`sid` 以及 `force_setup` 参数，将这些参数重新赋给SESSION。这里，如果传入参数中包含
`force_setup` 的值，就可以修复SESSION，从而达到权限绕过的目的。
`setup_session()`
    else if(isset($data["force_setup"]))
    {
        $this->load->helper('cookie');
        utils::setup_webstart_user_session(urldecode($data["sid"]), $data["username"], null, true);
    }
    ...
    require_once(APPPATH. "controllers/common/login.php");
    $login = new login();
    $login->setupUserSession($username, input_validator::get_default_value("timeout"), input_validator::get_default_value("unit"), $timezone_offset, input_validator::get_default_value("jvm_memory"));
实际上此时伪造的SESSION只包含了一个我们自己构造的username和password，由于Citrix采用了集成认证体系，仅可以使用读取、删除文件等部分功能，并不能真正的达到完全接管用户的效果。  
经过调试分析，我们发现了一个可以造成远程代码执行的风险点，接下来对远程代码执行风险进行验证分析。
###  从任意文件读取到Getshell
当我们获得了伪造的SESSION后，想要POST数据，首先需要通过GET /menu/neo 或 GET /menu/stc
获取一个名为`rand_key` 的token，加入构造包中使得数据包成为正常请求，如下图所示。
拿到 `rand_key` 我们即可执行读取文件的命令，如下图所示。
随后，尝试写入文件时发现存在一些问题，如下图，提示未授权用户。
跟进`uploadtext`函数发现文件上传的功能使用了SFTP的方式实现，此时我们并没有真正的用户密码，此处无法绕过执行，如下图所示。
经过一番思索，虽然不能直接写
shell，但是已经拥有未授权读取文件的情况下，可以尝试读到高权限用户SESSION的方法，从而进行利用。通过列目录这个点，找到的 nsroot
session 存放的位置：
读取高权限 `session`：
Bingo!
现在拿到的真正的管理员权限，尝试写文件：
如下图所示，可以发现已经写入`test123456789.txt`，此经可以通过写入`authorized_key`等文件，达到远程代码执行的目的。
同时，也可以通过增加用户/修改密码的方式实施控制。
最后，由于SESSION存在过期时间的限制，因此该漏洞存在一定利用条件。
## 0x03 影响版本
Citrix ADC and Citrix Gateway: ]
Adventures in Citrix security research | dmaasland.github.io  
[]