apps and Native Client sandboxes native code in the Chrome web
browser [64]. In contrast, Milkomeda protects a vetting layer from
an untrusted app within its own process.
10 LIMITATIONS AND FUTURE WORK
Other GPU frameworks. While OpenGL ES is the main frame-
work using the GPU in mobile devices, it is not the only one. Notably,
OpenCL and CUDA leverage the GPU for computation. Milkomeda
disallows any code outside the shield space to interact with the GPU
device driver. Therefore, our current prototype blocks the usage
of such frameworks. We plan to address this problem in two steps.
First, we will load these frameworks in the shield space and allow
the app to use them by making proper shield-calls. Note that this
step immediately improves the state of the art, which needs to give
unrestricted access to the app for communication with the GPU
device driver. In our solution, the app’s access will be regulated and
limited to a higher-level API (i.e., the GPU framework API). Second,
we will evaluate the security of the interface of these frameworks
and, if needed, investigate adding proper vetting for them as well.
Use the shield space to improve WebGL performance. As
mentioned, web browsers deploy a multi-process architecture to
protect the integrity of the security checks (see Figure 1b). We plan
to use the shield space to employ the WebGL backend (including
the security checks) in the web app process and improve the WebGL
performance.
Supporting ANGLE. As mentioned in §2.4, WebGL uses AN-
GLE’s shader validator. ANGLE, in addition to the shader verifier,
is being orthogonally equipped with a set of security checks. While
it does not yet provide a comprehensive set of checks as current
WebGL checks (e.g., no support for OpenGL ES version 3.0), it is
under active development and will likely add the missing checks,
as evident from a discussion by Google on the potential integration
of all security checks [14]. We plan to update our CheckGen tool to
also automatically reuse ANGLE’s security checks for the mobile
graphics interface.
Supporting ARMv7 processors. Our shield implementation
in Milkomeda targets ARMv8 processors, used in modern mobile
devices. We plan to support older ARMv7 processors as well. For
that, we will use a smaller part of the process address space for
the shield space since the address space is limited for these 32-bit
processors. We will also consider implementing the shield space
memory using ARM memory domains available in ARMv7 proces-
sors [27], which will not require changes to the kernel. Note that,
unfortunately, ARM memory domains are not available on ARMv8
processors. We believe that if such hardware support existed on
these processors, the shield’s overhead could be reduced.
11 CONCLUSIONS
We presented Milkomeda, a system solution to protect the mobile
graphics interface against exploits. We showed, through a study,
that the mobile graphics interface exposes a large amount of vulner-
able kernel code to potentially malicious mobile apps. Yet, mobile
apps’ access to the OpenGL ES interface is not vetted.
Browser vendors have invested significant effort to develop a
comprehensive set of security checks to vet calls for the WebGL
API, a framework for GPU-based graphics acceleration for web
apps. Milkomeda repurposes the existing WebGL security checks
to harden the security of the mobile graphics interface. Moreover,
it does so with almost no engineering effort by using a tool, Check-
Gen, which automates the porting of these checks to be used for
mobile graphics. We also introduced a novel shield space design
that allows us to securely deploy these checks in the app’s process
address space for better performance. Our evaluation shows that
Milkomeda achieves high graphics performance for various mobile
apps, although at the cost of moderately increased CPU utilization.
ACKNOWLEDGMENTS
This work was supported by NSF awards #1617513, #1513783, and
ONR award N00014-17-1-2513. Any opinions, findings, conclusions,
or recommendations expressed in this material are those of the
authors and do not necessarily reflect the views of our sponsors. We
thank the paper shepherd, Adwait Nadkarni, and the anonymous
CCS reviewers for their insightful comments. The pseudocode used
in Figure 6 was adopted and modified from a similar one suggested
by one of the reviewers.
REFERENCES
[1] 2011. Chromium Issue 70718: Crashes when opening a page with webgl. https:
//bugs.chromium.org/p/chromium/issues/detail?id=70718.
[2] 2011. Microsoft considers WebGL harmful. http://blogs.technet.com/b/srd/
archive/2011/06/16/webgl-considered-harmful.aspx.
[3] 2014. GPU Accelerated Compositing in Chrome. https://www.chromium.org/
developers/design-documents/gpu-accelerated-compositing-in-chrome.
[4] 2015. WebGL* in Chromium*: Behind the scenes. https://software.intel.com/
en-us/articles/webgl-in-chromium-behind-the-scenes.
[5] 2017. A new multi-process model for Firefox. https://hacks.mozilla.org/2017/06/
firefox-54-e10s-webextension-apis-css-clip-path/.
[6] 2017.
Best Practices for Working with Vertex Data.
https://developer.
apple.com/library/content/documentation/3DDrawing/Conceptual/
OpenGLES_ProgrammingGuide/TechniquesforWorkingwithVertexData/
TechniquesforWorkingwithVertexData.html.
[7] 2017. Certain types of loops in WebGL shaders cause GLSL compiler crashes on
Adreno. https://bugs.chromium.org/p/chromium/issues/detail?id=784817.
[8] 2017. National Vulnerability Database. https://www.nist.gov/programs-projects/
national-vulnerability-database-nvd.
[9] 2017. OpenGL ES Benchmark 1. https://github.com/googlesamples/android-ndk/
tree/master/hello-gl2.
org/cvss/v2/.
[10] 2017. SELinux. https://wiki.centos.org/HowTos/SELinux.
[11] 2017. The Common Vulnerability Scoring System version 2. https://www.first.
[12] 2017. WebGL Security. http://www.khronos.org/webgl/security/.
[13] 2018. Android NDK. https://developer.android.com/ndk/index.html.
[14] 2018.
back
1CucIsdGVDmdTWRUbg68IxLE5jXwCb2y1E9YVhQo0thg/pub?slide=id.
g26efd2cf6_0178.
and
https://docs.google.com/presentation/d/
Direct3D
OpenGL
ANGLE:
again.
From
to
[15] 2018. AppArmor. https://wiki.ubuntu.com/AppArmor.
[16] 2018. Client-Side Vertex Arrays.
https://www.khronos.org/opengl/wiki/
Client-Side_Vertex_Arrays.
[17] 2018.
Drive-by
Rowhammer
attack
using
on Android.
https://arstechnica.com/information-technology/2018/05/
drive-by-rowhammer-attack-uses-gpu-to-compromise-an-android-phone/.
[18] 2018. glTexImage2D specification – OpenGL ES 3.0. https://www.khronos.org/
registry/OpenGL-Refpages/es3.0/html/glTexImage2D.xhtml.
[19] 2018.
Google Play Instant.
https://developer.android.com/topic/
google-play-instant/.
[20] 2018. GPU Command Buffer - The Chromium Projects. https://www.chromium.
org/developers/design-documents/gpu-command-buffer.
[21] 2018. OpenGL ES Benchmark 2. https://github.com/googlesamples/android-ndk/
[53] Seccomp 2018. SECure COMPuting with filters. https://www.kernel.org/doc/
[39] V. Ganapathy, M. J. Renzelmann, A. Balakrishnan, M. M. Swift, and S. Jha. 2008.
The Design and Implementation of Microdrivers. In Proc. ACM ASPLOS.
[40] T. Ho, D. Dean, X. Gu, and W. Enck. 2014. PREC: Practical Root Exploit Contain-
ment for Android Devices. In Proc. ACM CODASPY.
[41] T. C. Hsu, K. Hoffman, P. Eugster, and M. Payer. 2016. Enforcing Least Privilege
Memory Views for Multithreaded Applications. In Proc. ACM CCS.
[42] W. Li, S. Luo, Z. Sun, Y. Xia, L. Lu, H. Chen, B. Zang, and H. Guan. 2018. VButton:
Practical Attestation of User-driven Operations in Mobile Apps. In Proc. ACM
MobiSys.
[43] J. Litton, A. Vahldiek-Oberwagner, E. Elnikety, D. Garg, B. Bhattacharjee, and
P. Druschel. 2016. Light-Weight Contexts: An OS Abstraction for Safety and
Performance. In Proc. USENIX OSDI.
[44] J. M. McCune, Y. Li, N. Qu, Z. Zhou, A. Datta, V. Gligor, and A. Perrig. 2010.
TrustVisor: Efficient TCB Reduction and Attestation. In Proc. IEEE Symposium on
Security and Privacy (S&P).
[45] J. M. McCune, B. J. Parno, A. Perrig, M. K. Reiter, and H. Isozaki. 2008. Flicker:
An Execution Infrastructure for TCB Minimization. In Proc. ACM EuroSys.
[46] N. Palix, G. Thomas, S. Saha, C. Calvès, J. Lawall, and G. Muller. 2011. Faults in
Linux: Ten Years Later. In Proc. ACM ASPLOS.
[47] M. Payer, E. Kravina, and T. R. Gross. 2013. Lightweight Memory Tracing. In
Proc. USENIX ATC.
[48] P. Pearce, A. P. Felt, G. Nunez, and D. Wagner. 2012. AdDroid: Privilege Separa-
tion for Applications and Advertisers in Android. In Proc. ACM Symposium on
Information, Computer and Communications Security (AsiaCCS).
[49] N. Provos. 2003. Improving Host Security with System Call Policies. In Proc.
[50] N. Provos, M. Friedl, and P. Honeyman. 2003. Preventing Privilege Escalation. In
USENIX Security Symposium.
Proc. USENIX Security Symposium.
[51] A. Razeen, A. R. Lebeck, D. H. Liu, A. Meijer, V. Pistol, and L. P. Cox. 2018.
SandTrap: Tracking Information Flows On Demand with Parallel Permissions. In
Proc. ACM MobiSys.
[52] F. Roesner and T. Kohno. 2013. Securing Embedded User Interfaces: Android and
Beyond. In Proc. USENIX Security Symposium.
Documentation/prctl/seccomp_filter.txt.
[54] S. Shekhar, M. Dietz, and D. S. Wallach. 2012. AdSplit: Separating Smartphone
Advertising from Applications. In Proc. USENIX Security Symposium.
[55] R. Strackx, P. Agten, N. Avonds, and F. Piessens. 2015. Salus: Kernel Support for
Secure Process Compartments. EAI Endorsed Transactions on Security and Safety
(2015).
[56] M. M. Swift, B. N. Bershad, and H. M. Levy. 2003. Improving the Reliability of
Commodity Operating Systems. In Proc. ACM SOSP.
[57] V. van der Veen, D. Andriesse, E. Göktaş, B. Gras, L. Sambuc, A. Slowinska, H.
Bos, and C. Giuffrida. 2015. Practical Context-Sensitive CFI. In Proc. ACM CCS.
[58] L. Vilanova, M. Ben-Yehuda, N. Navarro, Y. Etsion, and M. Valero. 2014. CODOMs:
Protecting Software with Code-centric Memory Domains. In Proc. ACM/IEEE
ISCA.
[59] R. Wahbe, S. Lucco, T. E. Anderson, and S. L. Graham. 1993. Efficient Software-
Based Fault Isolation. In Proc. ACM SOSP.
[60] J. Wang, X. Xiong, and P. Liu. 2015. Between Mutual Trust and Mutual Distrust:
Practical Fine-grained Privilege Separation in Multithreaded Applications. In
Proc. USENIX ATC.
[61] R. N. M. Watson, J. Anderson, B. Laurie, and K. Kennaway. 2010. Capsicum:
Practical Capabilities for UNIX. In Proc. USENIX Security Symposium.
[62] J. Woodruff, R. N. M. Watson, D. Chisnall, S. W. Moore, J. Anderson, B. Davis,
B. Laurie, P. G. Neumann, R. Norton, and M. Roe. 2014. The CHERI Capability
Model: Revisiting RISC in an Age of Risk. In Proc. ACM/IEEE ISCA.
[63] Z. Yao, Z. Ma, Y. Liu, A. Amiri Sani, and A. Chandramowlishwaran. 2018. Sugar:
Secure GPU Acceleration in Web Browsers. In Proc. ACM ASPLOS.
[64] B. Yee, D. Sehr, G. Dardyk, J. B. Chen, R. Muth, T. Ormandy, S. Okasaka, N. Narula,
and N. Fullagar. 2009. Native Client: A Sandbox for Portable, Untrusted x86 Native
Code. In Proc. IEEE Symposium on Security and Privacy (S&P).
[65] K. Ying, A. Ahlawat, B. Alsharifi, Y. Jiang, P. Thavai, and W. Du. 2018. TruZ-Droid:
Integrating TrustZone with Mobile Operating System. In Proc. ACM MobiSys.
[66] N. Zeldovich, H. Kannan, M. Dalton, and C. Kozyrakis. 2008. Hardware Enforce-
ment of Application Security Policies Using Tagged Memory. In Proc. USENIX
OSDI.
[67] H. Zhang, D. She, and Z. Qian. 2015. Android Root and its Providers: A Double-
Edged Sword. In Proc. ACM CCS.
[68] F. Zhou, J. Condit, Z. Anderson, I. Bagrak, R. Ennals, M. Harren, G. Necula, and E.
Brewer. 2006. SafeDrive: Safe and Recoverable Extensions Using Language-Based
Techniques. In Proc. USENIX OSDI.
[69] S. Zhu, L. Lu, and K. Singh. 2016. Case: Comprehensive Application Security
Enforcement on COTS Mobile Devices. In Proc. ACM MobiSys.
tree/master/gles3jni.
[22] 2018.
[23] 2018.
OpenGL ES Benchmark 3.
Learn-OpenGLES-Tutorials (Lesson 5).
OpenGL ES Benchmark 4.
Learn-OpenGLES-Tutorials (Lesson 7).
https://github.com/learnopengles/
https://github.com/learnopengles/
[24] M. Abadi, M. Budiu, Ú. Erlingsson, and J. Ligatti. 2005. Control-Flow Integrity.
In Proc. ACM CCS.
[25] A. Amiri Sani. 2017. SchrodinText: Strong Protection of Sensitive Textual Content
of Mobile Applications. In Proc. ACM MobiSys.
[26] A. Amiri Sani, L. Zhong, and D. S. Wallach. 2014. Glider: A GPU Library Driver
for Improved System Security. Technical Report 2014-11-14, Rice University (2014).
[27] ARM. 2007. Architecture Reference Manual, ARMv7-A and ARMv7-R edition.
ARM DDI 0406A (2007).
[28] ARM. 2013. Architecture Reference Manual, ARMv8, for ARMv8-A architecture
profile. ARM DDI 0487A.a (ID090413) (2013).
[29] M. Backes, S. Bugiel, C. Hammer, O. Schranz, and P. von Styp-Rekowsky. 2015.
Boxify: Full-fledged App Sandboxing for Stock Android. In Proc. USENIX Security
Symposium.
[30] A. Belay, A. Bittau, A. Mashtizadeh, D. Terei, D. Mazieres, and C. Kozyrakis. 2012.
Dune: Safe User-level Access to Privileged CPU Features. In Proc. USENIX OSDI.
[31] A. Bittau, P. Marchenko, M. Handley, and B. Karp. 2008. Wedge: Splitting Appli-
cations into Reduced-Privilege Compartments. In Proc. USENIX NSDI.
[32] D. Brumley and D. Song. 2004. Privtrans: Automatically Partitioning Programs
for Privilege Separation. In Proc. USENIX Security Symposium.
[33] N. Burow, S. A. Carr, J. Nash, P. Larsen, M. Franz, S. Brunthaler, and M. Payer. 2017.
Control-Flow Integrity: Precision, Security, and Performance. ACM Computing
Surveys (CSUR) (2017).
[34] A. Chou, J. Yang, B. Chelf, S. Hallem, and D. Engler. 2001. An Empirical Study of
Operating Systems Errors. In Proc. ACM SOSP.
[35] Ding, R. and Qian, C. and Song, C. and Harris, B. and Kim, T. and Lee, W. 2017.
Efficient Protection of Path-Sensitive Control Security. In Proc. USENIX Security
Symposium.
[36] K. Elphinstone and G. Heiser. 2013. From L3 to seL4 What Have We Learnt in 20
Years of L4 Microkernels?. In Proc. ACM SOSP.
[37] T. Frassetto, P. Jauernig, C. Liebchen, and A. Sadeghi. 2018. IMIX: In-Process
Memory Isolation EXtension. In Proc. USENIX Security Symposium.
[38] P. Frigo, C. Giuffrida, H. Bos, and K. Razavi. 2018. Grand Pwning Unit: Accelerat-
ing Microarchitectural Attacks with the GPU. In Proc. IEEE Security and Privacy
(S&P). bibtex: frigo2018.