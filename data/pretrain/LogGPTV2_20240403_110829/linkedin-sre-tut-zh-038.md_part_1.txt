# 查询性能
> 原文：
### 查询性能调优
查询性能是关系数据库的一个非常重要的方面。如果没有正确调优，select 查询对于应用和 MySQL 服务器来说会变得缓慢而痛苦。重要的任务是识别速度慢的查询，并通过重写它们或在相关表上创建适当的索引来提高它们的性能。
#### 慢速查询日志
慢速查询日志包含执行时间比配置参数 long_query_time 中设置的时间长的 SQL 语句。这些查询是优化的候选对象。有一些很好的工具可以总结慢速查询日志，如 mysqldumpslow(由 MySQL 自己提供)、pt-query-digest(由 Percona 提供)等。以下是用于启用和有效捕获慢速查询的配置参数
| 可变的 | 说明 | 示例值 |
| --- | --- | --- |
| 慢速查询日志 | 启用或禁用慢速查询日志 | 在…上 |
| 慢速查询日志文件 | 慢速查询日志的位置 | /var/lib/mysql/mysql-slow.log |
| 长查询时间 | 阈值时间。耗时超过此时间的查询会记录在慢速查询日志中 | five |
| 日志查询未使用索引 | 当启用慢速查询日志时，不使用任何索引的查询也会记录在慢速查询日志中，即使它们花费的时间比 long_query_time 少。 | 在…上 |
因此，对于这一部分，我们将启用 **slow_query_log** ， **long_query_time** 将保持为 **0.3 (300 ms)** ，并且 **log_queries_not_using** 索引也将启用。
下面是我们将在 employees 数据库上执行的查询。
1.  select * from employees where last _ name = ' Koblick '；
2.  select * from salaries，其中薪金> = 100000；
3.  select * from titles where title = ' Manager '；
4.  select * from employees where year(hire _ date)= 1995；
5.  select year(e.hire_date)，max(s . salary from employees e join salary s on e . EMP _ no = s . EMP _ no group by year(e . hire _ date)；
现在，查询 **1** 、 **3** 和 **4** 在 300 毫秒内执行，但是如果我们检查缓慢的查询日志，我们会发现这些查询被记录下来，因为它们没有使用任何索引。查询 **2** 和 **5** 耗时超过 300 毫秒，并且不使用任何索引。
使用以下命令获取慢速查询日志的摘要
`mysqldumpslow /var/lib/mysql/mysql-slow.log`
![slow query log analysis](img/132a906cf359ee5def0ba65d51739b76.png "slow query log analysis")
除了提到的查询之外，快照中还有其他一些查询。Mysqldumpslow 替换 N(对于数字)和 S(对于字符串)使用的实际值。这可以被`-a`选项覆盖，但是如果在类似的查询中使用不同的值，这将增加输出行。
#### 解释计划
**EXPLAIN** 命令用于我们想要分析的任何查询。它描述了查询执行计划，MySQL 如何查看和执行查询。EXPLAIN 使用 Select、Insert、Update 和 Delete 语句。它讲述了查询的不同方面，例如，如何连接表，是否使用索引等。这里重要的是理解查询的基本解释计划输出，以确定其性能。
让我们以下面的查询为例，
```sh
mysql> explain select * from salaries where salary = 100000;
+----+-------------+----------+------------+------+---------------+------+---------+------+---------+----------+-------------+
| id | select_type | table    | partitions | type | possible_keys | key  | key_len | ref  | rows    | filtered | Extra       |
+----+-------------+----------+------------+------+---------------+------+---------+------+---------+----------+-------------+
|  1 | SIMPLE      | salaries | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 2838426 |    10.00 | Using where |
+----+-------------+----------+------------+------+---------------+------+---------+------+---------+----------+-------------+
1 row in set, 1 warning (0.00 sec) 
```
以上输出中需要理解的关键方面是:-
*   **分区** -执行查询时考虑的分区数量。只有当表被分区时，它才有效。
*   **Possible_keys** -创建执行计划时考虑的索引列表。
*   **Key** -执行查询时将使用的索引。
*   **Rows** -执行过程中检查的行数。
*   **Filtered** -被检查的行中被过滤掉的行的百分比。最大和最优化的结果在该字段中将有 100。
*   **Extra**——这告诉我们一些关于 MySQL 如何评估的额外信息，查询是否只使用 where 子句来匹配目标行、任何索引或临时表等。
因此，对于上面的查询，我们可以确定没有分区，没有要使用的候选索引，因此根本没有使用索引，检查了超过 2M 的行，只有 10%的行包含在结果中，最后，只有 where 子句用于匹配目标行。
#### 创建索引
索引用于加快为给定的列值选择相关行的速度。如果没有索引，MySQL 从第一行开始，遍历整个表来查找匹配的行。如果表中有太多的行，操作会变得很昂贵。有了索引，MySQL 就可以在不读取整个表的情况下确定开始查找数据的位置。
主键也是最快的索引，与表数据一起存储。辅助索引存储在表数据之外，用于进一步提高 SQL 语句的性能。索引大多存储为 B 树，但也有一些例外，比如空间索引使用 R 树，内存表使用散列索引。
创建索引有两种方法:-
*   当创建一个表时——如果我们预先知道在 select 查询中驱动 where 子句最多的列，那么我们可以在创建一个表时在它们上面放一个索引。
*   修改表——为了提高一个麻烦的查询的性能，我们使用 ALTER 或 CREATE INDEX 命令在一个已经有数据的表上创建一个索引。此操作不会阻塞表，但可能需要一些时间来完成，具体取决于表的大小。
让我们看一下我们在上一节中讨论的查询。很明显，扫描 2M 记录并不是一个好主意，因为只有 10%的记录在结果集中。
因此，我们在 sales 表的 salary 列上创建了一个索引。
`create index idx_salary on salaries(salary)`
运筹学
`alter table salaries add index idx_salary(salary)`
同样的解释计划现在看起来像这样
```sh
mysql> explain select * from salaries where salary = 100000;
+----+-------------+----------+------------+------+---------------+------------+---------+-------+------+----------+-------+
| id | select_type | table    | partitions | type | possible_keys | key        | key_len | ref   | rows | filtered | Extra |
+----+-------------+----------+------------+------+---------------+------------+---------+-------+------+----------+-------+
|  1 | SIMPLE      | salaries | NULL       | ref  | idx_salary    | idx_salary | 4       | const |   13 |   100.00 | NULL  |
+----+-------------+----------+------------+------+---------------+------------+---------+-------+------+----------+-------+
1 row in set, 1 warning (0.00 sec) 
```
现在使用的索引是 idx_salary，我们最近创建的那个。该索引实际上只帮助检查了 13 条记录，并且它们都在结果集中。此外，查询执行时间也从 700 毫秒以上减少到几乎可以忽略不计。
让我们看另一个例子。我们在这里搜索名和姓的特定组合。但是，我们也可以只根据姓氏进行搜索。