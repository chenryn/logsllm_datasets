~c = (M, M ) +
sj~xj +
mXj=1
ti~bi,
2Xi=1
where ‘+’ is a binary operation meaning an addition
in Z × Z.
Dec(sk, ~c): Parse ~c as (c1, c2) ∈ Z × Z. Output M =
(c1 ¯p1 + c2 ¯p2 mod N ) mod Q.
Note that in SetupAlg1 algorithm, the secret information
p1 and p2 are taken by Alg1 as inputs and the remaining
process of SetupAlg1 algorithm uses Alg1 only a black-box
manner; that is, p1 and p2 are not utilized elsewhere except
for generating a secret key.
Theorem 2. The proposed scheme satisﬁes the correct-
ness requirement under the condition 2η > ρ + log Q(C +
1) + log A + µ + 3 holds where C is the number of allowed
scalar multiplications and µ > log m.
Proof. Let ejQ = Φ−1(~xj) and eiQ = Φ−1(~bi) for ei, ej ∈
(−2ρ, 2ρ), 1 ≤ i ≤ 2, and 1 ≤ j ≤ m. Then, a fresh cipher-
text ~c is Φ(M +Pm
i=1 tieiQ) for some message
M ∈ (−Q/2, Q/2], sj ∈ {0, 1}, and ti ∈ [0, 2µ). For correct
decryption, |M +Pm
i=1 tieiQ| should be less
j=1 sjej Q +P2
j=1 sjej Q +P2
Add(~c1,··· , ~cℓ): OutputPℓ
integer additions.
i=1 ~ci through component-wise
than N/2 and it is satisﬁed when 2η > ρ + µ + log Q + 3
under assuming µ > log m.
Moreover, let ~c′ be a ciphertext which is the result of A
additions and C scalar multiplications of fresh ciphertexts.
Then, the pre-image of ~c′ under Φ is less than (1 + m2ρ +
2µ+ρ)AQC+1. If 2η > ρ + log Q(C + 1) + log A + µ + 3 and
µ > log m, then (1 + m2ρ + 2µ+ρ)AQC+1  log m for the security. See Lemma 3
for the details.
3.2 Security Proof
We present the security theorem for our public key en-
cryption.
Theorem 3. The proposed public key scheme using Alg1
is semantically secure against any PPT adversaries under
the decisional co-ACD assumption.
The proof of Theorem 3 directly comes from the following
sequence of lemmas. In short, Lemma 2 says that the scheme
using Alg1 and the scheme using Alg2 are computationally
indistinguishable and Lemma 4 implies the semantic security
of the scheme using Alg2, though such scheme does not hold
the correctness requirement indeed.
Lemma 1. Let p1 and p2 be η-bit random primes and
Q be the size of the message space. We can consider ~xj
(~yj , resp.) as a random variable generated by the probabilis-
tic algorithm Alg1(p1, p2, Q) (Alg2(p1, p2, Q), resp.). Then,
X = (~x1, . . . , ~xm) and Y = (~y1, . . . , ~ym) are computationally
indistinguishable under the decisional co-ACD assumption,
where m is polynomial in the security parameter.
Proof. We prove the lemma via the standard hybrid ar-
gument. First, we begin with deﬁning a sequence of inter-
mediate variables Xj for j = 1, . . . , m as follows:
Xj (for j = 1, . . . , m) : (~y1, . . . , ~yj , ~xj+1, . . . , ~xm)
ǫ = (cid:12)(cid:12) Pr[A(Xj ) → 1] − Pr[A(Xj+1) → 1](cid:12)(cid:12) is non-negligible
Set X0 = X. We assume that for some adjacent vari-
ables Xj and Xj+1 there is a distinguisher A such that
in the security parameter. Then, we can construct an al-
gorithm breaking the decisional co-ACD assumption. Since
we can access polynomially many outputs of Alg1 and Alg2,
we can generate (~y1, . . . , ~yj, ~x∗, ~xj+2, . . . , ~xm), where each ~xj
is generated by Alg1, each ~yj is output of Alg2, and ~x∗ is
the challenge. Give (~y1, . . . , ~yj , ~x∗, ~xj+2, . . . , ~xm) to A and
transfer A’s output to the decisional co-ACD problem chal-
lenger. Then, it is quite straightforward that we have ǫ
advantage, which is non-negligible, to break the decisional
co-ACD assumption. Therefore, any adjacent variables are
computationally indistinguishable. Since there are polyno-
mially many variables only, by the standard hybrid argu-
ment we complete the proof of the lemma.
Lemma 2. Under the decisional co-ACD assumption, the
public key outputted by SetupAlg1 is indistinguishable from
that of SetupAlg2.
Proof. We can easily check that SetupAlg algorithm uses
Alg1 only a black-box manner so that the process of SetupAlg1
to generate public key (except for Q) can be considered
as a publicly computable function with taking polynomi-
ally many outputs of Alg1. By Lemma 1, the outputs of
291Alg1 is computationally indistinguishable from those of Alg2.
Therefore, we conclude that the result of Setup algorithm
should be indistinguishable between using two algorithms
Alg1 and Alg2, hence we complete the proof of the lemma.
The proof of Lemma 2 also implies that the performance
(e.g., the expected running time) of SetupAlg1 is almost the
same as that of SetupAlg2 under the co-ACD assumption.
To prove the semantic security of the scheme with Alg2,
we need the following lemma due to Coron, Lepoint, and
Tibouchi [13].
Lemma 3
(Leftover Hash Lemma over Lattices [13]).
Let L ⊂ Zn be a lattice of rank n of basis B = (~b1, . . . ,~bn).
Let ~xi for 1 ≤ i ≤ m be generated independently according
to the distribution DB, where DB is obtained by generating
a random element in the half-open parallelepiped generated
by the basis B. Let ~y = Pm
i=1 ti~bi and ~y′ ←
D2µB, where sj ← {0, 1} and ti ← [0, 2µ) ∩ Z and 2µB =
(2µ~b1, . . . , 2µ~bm). Then (~x1, . . . , ~xm, ~y) and (~x1, . . . , ~xm, ~y′)
2 ·q | det L|
are ǫ-statistically close, with ǫ = mn
j=1 sj~xj +Pn
2µ + 1
2m .
Lemma 4. The encryption algorithm of the scheme with
Alg2 statistically hides message M .
j=1 sj~xj +P2
Proof. We argue that for arbitrary message M , ~c =
(M, M ) +Pm
i=1 ti~bi, which is the ciphertext
generated by the scheme using Alg2, is statistically indis-
tinguishable from ~y ← D2µB. To this end, we consider an
intermediate random variable of the form ~z = (M, M ) + ~y′,
where ~y′ ← D2µB. Lemma 3 and our parameter selection
directly implies the statistical indistinguishability between ~c
and ~z.
Next, we show that ~z is ε-statistical close to ~y, where ε is
negligible in our parameters. To this end, it is suﬃcient to
show that the probability that ~z is not contained in the half-
open parallelepiped generated by 2µB is upper-bounded by
ε = 2µ+η ·Q
| det L| , where L is the lattice of basis 2µB. Since all
messages are chosen from (− Q
2 ], such the probability is
less than or equal to (|2µ~b1|+|2µ~b2|)·Q
| det L| . Further-
256 )2µ+2η and Q
more, InstGen guarantees that | det L| > ( 15
is chosen to be exponentially smaller than each modulus pi,
that is, 2η. Therefore, we obtain the desired result.
≤ 2µ+η ·Q
2 , Q
| det L|
4. HARDNESS OF THE CO-ACD PROBLEM
As shown in Section 2 and Section 3, the security of our
constructions relies on the hardness of the co-ACD prob-
lem.
In this section, we examine the hardness of the co-
ACD problem using well-known techniques for solving the
ACD problem. We analyze the general (ρ, η, k; Q)-co-ACD
problem, without the restriction that k = 2.
4.1 Using One Component of Instances
In this subsection, we ﬁrst consider the statistical distance
between the distribution ˆDρ,Q of the co-ACD problem and
the uniform distribution on Z ∩(cid:0)− pi
2(cid:3). We also provide
some attacks to ﬁnd a prime pi on the co-ACD problem
using the i-th component of the instances.
2 , pi
4.1.1 Statistical Distance
If we consider only one component of the multiple co-
ACD instances, it looks uniform when the condition ρ ≥
1
2ρ+1
2ρ+1
2 , pi
on Z∩(cid:0)− pi
|Pr[Di,ρ,Q = s] − Pr[Di = s]| ≤
η + λ holds. Fix i and let Di be the uniform distribution
Then, the statistical distance between Di and Di,ρ,Q is as
follows:
2(cid:3) and Di,ρ,Q := {eQ mod pi | e ← (−2ρ, 2ρ)}.
2Xs
∆[Di,ρ,Q;Di] =
since Pr[Di,ρ,Q = s] = ⌊2ρ+1/pi⌋
and hence
pi | ≤ 1
|Pr[Di,ρ,Q = s] − Pr[Di = s]| = | Pr[Di,ρ,Q = s]− 1
2ρ+1 .
This is less than 1
2λ if we take ρ ≥ η + λ. However, we
note that this does not guarantee that the sampling distri-
bution ˆDρ,Q in the co-ACD problem is statistically close to
the uniform distribution on Zp1 × ··· × Zpk .
4.1.2 Chen-Nguyen’s Attack and Its Variant
or ⌈2ρ+1/pi⌉
pi
2ρ+1 ,
Recently, Chen and Nguyen [8] proposed an improved at-
tack that can solve the partial ACD problem with complex-
ity eO(2ρ/2) and the general ACD (GACD) problem with
complexity eO(23ρ/2), where ρ is the bit length of the error.
Coron et al. [15] extended this attack to solve the GACD
problem on multiple instances. Now, we apply the method
of Coron et al. to solve the co-ACD problem.
Given multiple elements sampled from the distribution
ˆDρ,Q, we can apply Coron et al.’s method as follows: Let
~cj = (cj1, cj2, . . . , cjk) = Φ(ejQ) be elements sampled from
the distribution ˆDρ,Q in the co-ACD problem for 1 ≤ j ≤
t. Let us focus that our parameters satisfy ρ > η + 1.
Here, e′
j := ej mod pi is divided by pi since ci − ejQ =
ci − (e′
j + qpi)Q ≡ ci − e′
jQ mod pi for some q. Let yji =
Qx∈(−2η ,2η )(cji − xQ) for 1 ≤ j ≤ t.
multiplications to compute each yji, and pi divides yji for
1 ≤ j ≤ t and 1 ≤ i ≤ k. Hence, pi also divides Mi =
gcd(y1i, . . . , yti). To compute Mi eﬃciently, we perform the
following gcd computations sequentially:
It requires eO(2η)
Mi = gcd(··· gcd(gcd(y1i, y2i), y3i),· ·· , yti)).
(1)
and η > log Q. We have a multiple of pi, and can ﬁnd
This has a complexity of eO(t2η(η + log Q)), since log yji ≈
2η(η + log Q), and this becomes eO(2ηη2) when t = O(η)
the exact pi in eO(max{2η+1, log Mi}) by the trivial divi-
eO(max{2ηη2, 2η+1, log Mi}). Since 2η is suﬃciently large, it
sion algorithm. Hence, the total complexity of this attack is
is hard to solve the co-ACD problem with our parameters.
We also investigate how to apply the Lagarias algorithm to
the co-ACD problem using one component of each instance,
and show that this does not work for our parameters. Refer
to the full version for details.
4.2 Using Multiple Components of Instances
Now, we consider two attacks using multiple components
of instances. One is based on orthogonal lattice attacks,
and the other is based on the Coppersmith algorithm and
its variants.
4.2.1 Orthogonal Lattice Attacks
Suppose we have t vectors ~x1, . . . , ~xt sampled from ˆDρ,Q(p1,
. . . , pk). Then there exist ei’s in Z ∩ (−2ρ, 2ρ) such that
eij := eiQ mod pj where ~xi := (ei1, . . . , eik) for 1 ≤ i ≤ t
and 1 ≤ j ≤ k. Let Ej be a column vector (e1j , . . . , etj)T and
L the lattice generated by column vectors Ej’s, 1 ≤ j ≤ k−1.
Consider a vector ~a := (a1, . . . , at) orthogonal to the lat-
292tice L. Then we have
ai · (eiQ mod pj) = 0
tXi=1
tXi=1
for j = 1, . . . , k − 1, and so
ai · ei = 0
(mod
pj).
k−1Yj=1
(2)
over the integers. Then Pt
If ~a has only entries small enough, Equation (2) holds
i=1 ai(ei mod pk) is divisible by
pk. By factorizing this integer or computing its gcd with
another integer obtained from another orthogonal vector to
L, one can easily ﬁnd pk.
To prevent this attack, the short vector should not be too
short, i.e.
log(λ1(L⊥)) + ρ > (k − 1)η.
Note that dim L⊥ = t − k + 1 and det(L⊥) = det(L) ≤
j=1 kEjk ≤ (2η√t)k−1 when L is perfect. Then, the
Qk−1
norm of the shortest vector in L⊥ is expected to be about
2η(k−1)/(t−k+1). (Refer to [37] for details of orthogonal lat-
tices.) In this case, the inequality becomes
1
+ ρ > (k − 1)η
or ρ >(cid:18)1 −
t(cid:19) (k − 1)η.
(k − 1)η
t − k + 1
Let us consider the above attack when k = 2. For k = 2,
we can estimate the determinant of a lattice span(L) ∩ Zt
more precisely. L is a lattice generated by E1 = (e11,··· , et1)T
and det(L⊥) = det(span(L)∩ Zt) = 1
gt kE1k ≈
2η
if in-
gt
stances of the co-ACD problem were “random”, it is expected
that the norm of the shortest vector ~a1 is approximately
gt 2η)1/t. Since it is expected that gt elements are required
( 1
to obtain t elements whose gcd is g, we assume that g is
less than 2λ. Then, to make it hard to ﬁnd a short vector
satisfying Equation (2), the parameters should satisfy
gt · det(L) = 1
for g = gcd(e11,··· , et1) in this case. Hence,
η
t − λ + ρ > η
and hence ρ >(cid:18)1 −
1
t(cid:19) η + λ.
Therefore, if we take ρ ≥ η + 2λ when k = 2, the above
attack will take at least 2λ although the most signiﬁcant
λ-bit of the ei’s must be guessed to reduce the size of ρ.
4.2.2 Coppersmith Algorithm and Its Variants