# CVE-2021-43267 TIPC协议MSG_CRYPTO消息溢出利用
##### 译文声明
本文是翻译文章
译文仅供参考，具体内容表达以及含义原文为准。
**影响版本** ：Linux v5.10-rc1 ~ v5.14.15。v5.14.16已修补。高危，可导致远程提权，评分9.8。
默认不加载，需用户配置。
**测试版本** ：Linux-5.14.15 [exploit及测试环境下载地址](https://github.com/bsauce/kernel-exploit-factory)—
**编译选项** ： 配置所有`**TIPC**`选项， **CONFIG_TIPC=y** ；`**NETLINK**`选项。
在编译时将`.config`中的`CONFIG_E1000`和`CONFIG_E1000E`，变更为=y。[参考](https://blog.csdn.net/qq_16097611/article/details/104965045)
exp原作者关闭了 `CONFIG_SLAB_FREELIST_RANDOM` 和
`CONFIG_SLAB_FREELIST_HARDENED`，难怪我的测试总是不能成功。如何在有`CONFIG_SLAB_FREELIST_HARDENED`保护的情况下提高利用成功率呢？
    # 安装 pahole, 否则 CONFIG_DEBUG_INFO_BTF 不成功。 但是安装完后还是报错，所以修改.config 中 CONFIG_DEBUG_INFO_BTF=n 来关闭BTF。
    $ git clone https://git.kernel.org/pub/scm/devel/pahole/pahole.git/
    $ cd pahole
    $ mkcd build
    $ sudo apt-get install cmake libdw-dev zlib1g zlib1g-dev libelf-dev dwarves
    $ cmake -D__LIB=lib ..
    $ sudo make install
    $ sudo apt-get install git fakeroot build-essential ncurses-dev xz-utils libssl-dev bc qemu qemu-system bison flex libncurses5-dev libelf-dev
    $ wget https://mirrors.tuna.tsinghua.edu.cn/kernel/v4.x/linux-5.14.15.tar.xz
    $ tar -xvf linux-5.14.15.tar.xz
    # KASAN: 设置 make menuconfig 设置"Kernel hacking" ->"Memory Debugging" -> "KASan: runtime memory debugger"。
    $ make -j32
    $ make all
    $ make modules
    # 编译出的bzImage目录：/arch/x86/boot/bzImage。
    # 问题：make[1]: *** No rule to make target 'debian/canonical-certs.pem'
    # 解决：修改 .config, 将 CONFIG_SYSTEM_TRUSTED_KEYS 和 CONFIG_SYSTEM_REVOCATION_KEYS 置空即可
    #      CONFIG_DEBUG_INFO_BTF=n
**漏洞描述** ：漏洞位于 `net/tipc/crypto.c` 文件，TIPC（Transparent Inter-Process
Communication）集群内通信协议中对 `MSG_CRYPTO`
类型的消息长度验证出错，导致堆溢出。[tipc_crypto_key_rcv()](https://elixir.bootlin.com/linux/v5.14.15/source/net/tipc/crypto.c#L2281)
函数中，TIPC消息（[tipc_msg](https://elixir.bootlin.com/linux/v5.14.15/source/net/tipc/msg.h#L148)结构）的数据部分指向`MSG_CRYPTO`消息（[tipc_aead_key](https://elixir.bootlin.com/linux/v5.14.15/source/include/uapi/linux/tipc.h#L241)结构），在分配`tipc_aead_key`
空间并拷贝 `tipc_aead_key->key` 时，未校验`tipc_aead_key->keylen`的有效性，导致拷贝越界。只对TIPC消息的
`header size` 和 `msg size` 进行检查，却没有对
`MSG_CRYPTO`消息的`tipc_aead_key->keylen`进行检查。
**补丁**
：[patch](https://github.com/torvalds/linux/commit/fa40d9734a57bcbfa79a280189799f76c88f7bb0)
在拷贝 `MSG_CRYPTO` 消息之前检查 keylen 和 size。
    net/tipc/crypto.c | 32 +++++++++++++++++++++-----------     1 file changed, 21 insertions(+), 11 deletions(-)
     diff --git a/net/tipc/crypto.c b/net/tipc/crypto.c
     index c9391d38d..dc60c32bb 100644
     --- a/net/tipc/crypto.c
     +++ b/net/tipc/crypto.c
     @@ -2285,43 +2285,53 @@ static bool tipc_crypto_key_rcv(struct tipc_crypto *rx, struct tipc_msg *hdr)
       u16 key_gen = msg_key_gen(hdr);
       u16 size = msg_data_sz(hdr);
       u8 *data = msg_data(hdr);
     +   unsigned int keylen;
     +
     +   /* Verify whether the size can exist in the packet */
     +   if (unlikely(size name);
     +       goto exit;
     +   }
     +
     +   keylen = ntohl(*((__be32 *)(data + TIPC_AEAD_ALG_NAME)));
     +
     +   /* Verify the supplied size values */
     +   if (unlikely(size != keylen + sizeof(struct tipc_aead_key) ||
     +            keylen > TIPC_AEAD_KEY_SIZE_MAX)) {
     +       pr_debug("%s: invalid MSG_CRYPTO key size\n", rx->name);
     +       goto exit;
     +   }
         spin_lock(&rx->lock);
         if (unlikely(rx->skey || (key_gen == rx->key_gen && rx->key.keys))) {
         pr_err("%s: key existed , gen %d vs %d\n", rx->name,
            rx->skey, key_gen, rx->key_gen);
     -        goto exit;
     +        goto exit_unlock;
         }
         /* Allocate memory for the key */
         skey = kmalloc(size, GFP_ATOMIC);
         if (unlikely(!skey)) {
         pr_err("%s: unable to allocate memory for skey\n", rx->name);
     -        goto exit;
     +        goto exit_unlock;
         }
         /* Copy key from msg data */
     -   skey->keylen = ntohl(*((__be32 *)(data + TIPC_AEAD_ALG_NAME)));
     +   skey->keylen = keylen;
        memcpy(skey->alg_name, data, TIPC_AEAD_ALG_NAME);
        memcpy(skey->key, data + TIPC_AEAD_ALG_NAME + sizeof(__be32),
                skey->keylen);
     -   /* Sanity check */
     -   if (unlikely(size != tipc_aead_key_size(skey))) {
     -       kfree(skey);
     -       skey = NULL;
     -       goto exit;
     -   }
     -        rx->key_gen = key_gen;
        rx->skey_mode = msg_key_mode(hdr);
        rx->skey = skey;
        rx->nokey = 0;
        mb(); /* for nokey flag */
     - exit:
     + exit_unlock:
        spin_unlock(&rx->lock);
     + exit:
        /* Schedule the key attaching on this crypto */
        if (likely(skey && queue_delayed_work(tx->wq, &rx->work, 0)))
        return true;
**保护机制** ：SMEP / SMAP / KASLR / KPTI
**利用总结** ：
  * （1）使用netlink来使能 `UDP bearer media` ；
  * （2）创建有效的node link: 发送 `LINK_CONFIG` / `LINK_PROTOCOL` / `LINK_PROTOCOL` 包；
  * （3）创建 `/tmp/benign` 错误elf文件, 触发modprobe; 创建 `/tmp/hax` 提权文件, `modprobe_path` 将指向 `"/tmp/hax"`；
  * （4）堆喷布置2048个 `msg_msg` 消息, 释放偶数下标的 `msg_msg`；
  * （5）触发tipc漏洞，泄露内核基址； 
    * （5-1）触发 tipc 漏洞, 篡改 `msg_msg->m_ts`；
    * （5-2）喷射 0x40 个 `tty_struct` 结构，便于越界读泄露；
    * （5-3）`msg_msg` 越界读泄露 `tty_struct->ops` 和 `tty_struct->ldisc_sem->read_wait->next`（若读取到`tty_struct->magic` 也即0x5401，则表示泄露成功）；
  * （6）篡改 `tty_struct->ops.ioctl` 指针, 并篡改 `modprobe_path` 为 `"/tmp/hax"`； 
    * （6-1）`msg_msg` 消息偏移0x60处放置gadget `mov qword ptr [rdx], rsi` 地址（伪造`tty_operations->ioctl`指针），喷射2048个这样的`msg_msg`；
    * （6-2）篡改 `tty_struct->ops` 指针，指向某个 `msg_msg` 的消息开头；
    * （6-3）调用 `ioctl` 触发任意写gadget，篡改 `modprobe_path` 为 `"/tmp/hax"`；
  * （7）执行 `/tmp/hax` 触发modprobe并提权。
* * *
## 1\. 漏洞分析
####  1-1. TIPC协议介绍
**简介** ：TIPC（Transparent Inter Process
Communication）是一种专为集群内通信而设计的协议。消息传递是顺序保证、无丢失和流控制的。延迟时间比任何其他已知协议都短，而最大吞吐量可与 TCP
相媲美。
**配置** ：默认不加载，需用户来加载。加载时，TPIC可以用作socket并可以用Netlink接口来配置，它可以配置为通过 UDP
或直接通过Ethernet以太网传输消息。但是低权限的用户无法创建Ethernet帧，所以使用UDP更容易实现本地漏洞利用。
**协议头**
：虽然TIPC是在这些协议之上运行的，但有独立的地址方案，节点可以选择自己的地址。所有的消息构造和分析都是在kernel中进行的。每个TIPC消息都有相同的通用header格式和消息特定的header，
**TIPC消息（`tipc_msg`结构）存储地址位于`sk_buff->data`指向的线性数据区**。对该漏洞来说，通用header最重要的部分是
**`Header Size` 和 `message size`**。
TIPC消息的header如下所示：
[tipc_msg_validate()](https://elixir.bootlin.com/linux/v5.14.15/source/net/tipc/msg.c#L252)
函数负责验证这两个size的大小。 调用路径 ——
[tipc_rcv()](https://elixir.bootlin.com/linux/v5.14.15/source/net/tipc/node.c#L2103)
->
[tipc_msg_validate()](https://elixir.bootlin.com/linux/v5.14.15/source/net/tipc/msg.c#L252)
    bool tipc_msg_validate(struct sk_buff **_skb)
    {
        struct sk_buff *skb = *_skb;
        struct tipc_msg *hdr;
        int msz, hsz;
        /* Ensure that flow control ratio condition is satisfied */
        if (unlikely(skb->truesize / buf_roundup_len(skb) >= 4)) {
            skb = skb_copy_expand(skb, BUF_HEADROOM, 0, GFP_ATOMIC);
            if (!skb)
                return false;
            kfree_skb(*_skb);