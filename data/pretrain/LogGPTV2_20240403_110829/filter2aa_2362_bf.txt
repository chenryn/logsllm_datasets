to fuzz servers, clients, and even applications that process files. It is executed and
controlled through a graphical Java application.
Codenomicon can be configured to send a valid input between fuzzed inputs
and compare the response to those in the past. In this way it can detect some criti-
cal faults. It can also run custom external monitoring scripts. However, it other-
wise doesn’t have any built-in monitoring or analysis features.
8.3.6
beSTORM
beSTORM from Beyond Security is another commercial fuzzer that can handle net-
work or file fuzzing. It contains support for almost 50 protocols. However, unlike
the other commercial offerings, it can be used for fuzzing of proprietary and unsup-
ported protocols. This is done through a GUI interface similar, but more sophisti-
cated than, that found in Taof. A network packet capture, or in the case of file
fuzzing, a file, is loaded into beSTORM. This valid file can then be manually dis-
sected. Alternatively, beSTORM has the ability to automatically analyze the valid
file and determine significant occurrences such as length fields, ASCII text, and
delimiters. Once the unknown protocol is understood by beSTORM, it then fuzzes
it using a large library of heuristics. beSTORM also supports the ability to describe
a protocol specification completely in XML.
228
Fuzzer Comparison
The beSTORM fuzzer also possesses sophisticated monitoring capabilities. It can
remotely talk to a monitoring tool that, at the very least, monitors the target for
crashes or exceptions. Using this knowledge, this information can be passed back to
the fuzzer to help determine exactly what input caused an error in the application.
8.3.7
Application-Specific Fuzzers
When possible, we included protocol-specific fuzzers in the evaluation. This
includes FTPfuzz, a GUI-based FTP fuzzer, and the PROTOS test suite. PROTOS
was the original SNMP fuzzer developed at the University of Oulu many years ago.
PROTOS was the tool used to discover the ASN.1 bugs mentioned in the sidebar.
8.3.8
What’s Missing
This study excluded some well-known open-source fuzzers including SPIKE, Sulley,
and Peach. This is because these are fuzzing frameworks and not really fuzzers. They
allow a user to generate fuzzed inputs based on a specification file. If you attempted
to test one of these fuzzers using the strategies outlined in the chapter, you’d really
be testing that particular format specification, and not the actual framework. For
this reason, and the fact it can take weeks to produce a through specification file,
these fuzzers were excluded. It should be noted that Sulley does contain sophisti-
cated monitoring and analysis tools and SPIKE now has layer 2 support.
8.4
The Targets
Three protocols were chosen for testing: FTP, SNMP, and DNS. They are extremely
common, for the most part they are relatively simple, and between them, they rep-
resent both ASCII-based and binary protocols. Additionally, while FTP and SNMP
servers were tested, a DNS client was examined. In each case, in an effort to avoid
finding real bugs, a well-established and hopefully robust open source implementa-
tion was selected.
The FTP server selected was ProFTPD. This well-established server was config-
ured mostly by its default settings. Some options were modified to ensure that the
fuzzer could run very quickly against the server without the server denying connec-
tions. Other changes included ensuring an anonymous login was available, includ-
ing the ability to download and upload documents.
For SNMP, we tested the Net-SNMP server. The server was configured to
accept version 2 SNMP when presented with a suitable community string and ver-
sion 3 SNMP when presented with a valid username (requiring no authentication).
This user was given read and write access. It is important to note that these config-
uration options may have significant effect on the outcome because some fuzzers
may only be able to handle certain SNMP versions in addition to the way the code
coverage will obviously be affected. Of course, in the interest of fairness, the vari-
ous configurations were set before any fuzzer was examined.
Finally, for a DNS client we chose the dig utility from the BIND open-source
DNS library.
8.4
The Targets
229
8.5
The Bugs
For each program implementation, 17 bugs were added to the applications. Of
these vulnerabilities, approximately half were buffer overflows and a fourth were
format string vulnerabilities. The remaining bugs were from other categories, such
as command injection, double free, and wild pointer writes. Some of these bugs
were made easy to find and others were hidden deeper within the application. All
bugs were tested to ensure they were remotely accessible. None were detectable
using the standard server or client (they weren’t THAT obvious). Each vulnerabil-
ity was prefaced with code that would log when they had been detected. Note that
this means credit is given to a fuzzer for finding a bug even if it is likely that the
fuzzer would not have found this bug in real life. An example of this is if a fuzzer
overflowed a buffer by one byte only, the logging function would indicate the vul-
nerability had been “found” when in reality this would be very difficult to detect
(without the monitoring described in Chapter 6, at least). On the positive side, hav-
ing this logging code eliminates any dependency on the type of monitoring used
(custom or that which comes with the fuzzer) and is completely accurate.
Below are several of the bugs for illustration.
8.5.1
FTP Bug 0
MODRET xfer_type(cmd_rec *cmd) {
...
if (strstr(get_full_cmd(cmd), "%")!=NULL){
BUGREPORT(0);
}
char tempbuf[32];
snprintf(tempbuf, 32, "%s not understood", get_full_cmd(cmd));
pr_response_add_err(R_500, tempbuf);
Here, we see the logging code trying to detect the use of the format identifier
‘%’. This bug occurs because the function pr_response_add_err is a function that
expects a format string for its second argument. In this case, the processing of the
XFER command contains a straightforward format string vulnerability.
8.5.2
FTP Bugs 2, 16
MODRET xfer_stru(cmd_rec *cmd) {
...
cmd->argv[1][0] = toupper(cmd->argv[1][0]);
switch ((int) cmd->argv[1][0]) {
...
case 'R':
case 'P':
{
char tempbuf[64];
if(strlen(get_full_cmd(cmd)) > 34){
BUGREPORT(16);
230
Fuzzer Comparison
}
if(strstr(get_full_cmd(cmd), "%")!=NULL){
BUGREPORT(2);
}
sprintf(tempbuf, "'%s' unsupported structure type.", 
get_full_cmd(cmd));
pr_response_add_err(R_504, tempbuf);
return ERROR(cmd);
}
Here, a buffer overflow and a format string issue exist in the processing of the
STRU FTP command. However, it is only possible to find this if the first character
of the string is ‘R’ or ‘P.’ These two bugs proved difficult for the fuzzers to find—
more on this later in Section 8.7.1.
These code snippets illustrate some example bugs that were added to the appli-
cations. As will be seen in the next section, some of these bugs were easier to find
than others for the fuzzers. After each comparison, some of the bugs that proved
decisive will be examined closer.
8.6
Results
After all this setup about the bugs and the fuzzers, it remains to be seen how the
fuzzers did in this testing. Below we list which bugs each fuzzer found and how much
code coverage they obtained. The following abbreviations will be used in the results:
• Random. This is purely random data fed into the interface. For fuzzing
servers, this data was obtained with the “-R” option of GPF. For fuzzing
clients, a custom server that sent random data was used. This is mostly
included for code coverage comparison.
• GPF Partial. This is GPF used with only a partial packet capture. For FTP
fuzzing, we used two initial inputs to GPF and Taof. The first was a packet
capture consisting of most common FTP operations, including login, pass-
word, directory changing, and uploading and downloading files. GPF Partial
refers to this packet capture for the initial input.
• GPF Full. This is GPF as described above except the packet capture used con-
tained every FTP command that ProFTPD accepted, according to its help
message. This is a more full and complete initial input. In both cases, GPF
was used with the ASCII tokAid.
• SuperGPF. This refers to SuperGPF using the full packet capture described
above along with a text file containing all valid FTP commands.
• Taof Partial. Taof with the partial packet capture described above.
• Taof Full. Taof with the full packet capture described above.
• ProxyFuzz Partial. ProxyFuzz with the partial packet capture available for
modification
• ProxyFuzz Full. ProxyFuzz with the full packet capture available.
8.6
Results
231
Figure 8.1
Percentage of bugs found and code coverage obtained by fuzzers on FTP server.
Table 8.1
Results of Fuzzing the FTP Server
Bug
0
1
3
4
5
9
11
12
13
14
15
16
GPF Random
GPF Partial
X
X
X
GPF Full
X
X
X
X
X
Super GPF
X
X
X
X
X
X
Taof Partial
Taof Full
X
X
X
ProxyFuzz Partial
ProxyFuzz Full
X
X
X
Mu-4000
X
X
X
X
X
FTPfuzz
X
X
X
X
Codenomicon
X
X
X
X
X
X
• GPF Generic. GPF used with a generic binary tokAid.
• GPF SNMP. GPF used with a custom written SNMP tokAid.
Throughout all the testing, generation-based fuzzers were allowed to run
through all their test cases. Mutation-based fuzzers were allowed to run for 25,000
test cases or seven hours, whichever came first. While this time period is somewhat
arbitrary, it was consistent with the amount of time required by most generation-
based fuzzers.
8.6.1
FTP
Table 8.1 summarizes the bugs found while fuzzing the FTP server.
Figure 8.1 shows the percentage of bugs found as well as the total percentage
of code coverage obtained by each of the fuzzers. For this particular application, the
code coverage represents the percentage of source code lines executed after authen-
232
Fuzzer Comparison
tication. This explains why the random fuzzer received 0% code coverage, since it
never successfully authenticated. For the other applications, the code coverage sta-
tistics include the authentication code.
Detailed analysis of these numbers will follow the presentation of the results
for the three applications.
8.6.2
SNMP
Table 8.2 displays the results of the fuzzing against the SNMP server. Note that
SuperGPF could not be used since it only works on ASCII protocols.
These results, as well as the amount of code coverage obtained, are summarized
in the Figure 8.2:
8.6.3
DNS
Table 8.3 again lists which bugs were found by which fuzzers.
Note that the Mu-4000 fuzzer does not fuzz client-side applications and so is
excluded from this testing. Figure 8.3 summarizes the results and lists the code cov-
erage obtained by each fuzzer.
8.6
Results
233
Figure 8.2
Percentage of bugs found and code coverage obtained by fuzzers against the SNMP
server.
Table 8.2
Results of Fuzzing the SNMP Server
Bug
0
1
2
3
4
5
6
9
10
11
12
13
14
15
16
GPFRandom
GPF Generic
X
X
X
X
X
X
X
GPF SNMP
X
X
X
X
X
X
X
X
X
ProxyFuzz
X
X
X
X
X
X
Mu-4000
X
X
X
X
X
X
X
X
X
X
X
X
PROTOS
X
X
X
X
X
X
X
Codenomicon
X
X
X
X
X
X
X
X