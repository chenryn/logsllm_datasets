title:A security-preserving compiler for distributed programs: from information-flow
policies to cryptographic mechanisms
author:C&apos;edric Fournet and
Gurvan Le Guernic and
Tamara Rezk
A Security-Preserving Compiler for Distributed Programs
From Information-Flow Policies to Cryptographic Mechanisms
C√©dric Fournet
Microsoft Research
Cambridge
United Kingdom
PI:EMAIL
Gurvan Le Guernic
MSR‚ÄìINRIA Joint Centre
Orsay
France
PI:EMAIL
PI:EMAIL
Tamara Rezk
INRIA Sophia Antipolis
M√©diterran√©e
France
ABSTRACT
We enforce information Ô¨Çow policies in programs that run at mul-
tiple locations, with diverse levels of security.
We build a compiler from a small imperative language with lo-
cality and security annotations down to distributed code linked to
concrete cryptographic libraries. Our compiler splits source pro-
grams into local threads; inserts checks on auxiliary variables to
enforce the source control Ô¨Çow; implements shared distributed vari-
ables using instead a series of local replicas with explicit updates;
and Ô¨Ånally selects cryptographic mechanisms for securing the com-
munication of updates between locations.
We establish computational soundness for our compiler: under
standard assumptions on cryptographic primitives, all conÔ¨Ådential-
ity and integrity properties of the source program also hold with
its distributed code, despite the presence of active adversaries that
control all communications and some of the program locations. We
also present performance results for the code obtained by compil-
ing sample programs.
Categories and Subject Descriptors
D.2.0 [Software Engineering]: Protection Mechanisms
General Terms
Security, Design, Languages
1.
INTRODUCTION
The security of distributed systems usually entails the implemen-
tation of protection mechanisms based on cryptography to ensure
the conÔ¨Ådentiality and integrity of information. This involves ex-
pert knowledge, as well as attention to many implementation de-
tails. Our goal is to let developers focus on high-level security poli-
cies and properties of their programs, and use a compiler to gen-
erate lower-level protection mechanisms that ensure that the dis-
tributed implementation is at least as secure as the source program.
We take information Ô¨Çow security as our speciÔ¨Åcation of security
(for an abstract memory model) and also as our model for cryptog-
raphy in the implementation. In information Ô¨Çow security, policies
Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proÔ¨Åt or commercial advantage and that copies
bear this notice and the full citation on the Ô¨Årst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciÔ¨Åc
permission and/or a fee.
CCS‚Äô09, November 9‚Äì13, 2009, Chicago, Illinois, USA.
Copyright 2009 ACM 978-1-60558-352-5/09/11 ...$10.00.
are expressed by annotating variables with labels from a lattice [see
e.g. Myers and Liskov, 2000]. Correct information Ô¨Çow in a pro-
gram means that an adversary with restricted access to program
variables can neither affect the program behavior nor gain knowl-
edge above its security level by interacting with the system. Since
this notion of security depends on the semantics of programs, an
essential difÔ¨Åculty is to preserve security properties as programs
get compiled to concrete implementations. In a distributed imple-
mentation, for instance, a network adversary may observe messages
sent between hosts, and it may control their scheduling. Inasmuch
as these side channels are not apparent in source programs, they
must be carefully addressed in the compilation process.
We enforce information Ô¨Çow policies in programs that run at
multiple locations, with diverse levels of security. This involves
cryptographic protection whenever relatively secure locations (e.g.
a client and a server) interact via less secure locations (e.g. an open
network).
‡¢´ In source programs, security depends on a global program se-
mantics, with abstract policies for reading and writing shared
memory. These policies enable a simple review of conÔ¨Åden-
tiality and integrity properties.
‡¢´ In their distributed implementations, shared memory is un-
protected, the adversary controls the scheduling, and security
depends instead on cryptographic protection.
Our compiler is structured into four stages: slicing, control Ô¨Çow,
replication, and cryptography. The Ô¨Årst stage slices sequential code
with locality annotations into a series of local programs, each meant
to run at a single location. After slicing, the second stage pro-
tects the control Ô¨Çow of the source program against a malicious
scheduler, by generating code that maintains auxiliary variables to
keep track of the program state, based on its integrity policy. The
replication stage transforms a distributed program (still relying on a
global, shared, protected memory) into a program where variables
are implemented as local replicas at each location, with explicit
updates between replicas. Finally, the cryptography stage inserts
cryptographic operations to protect these variable updates, and it
generates an initial protocol for distributing their keys.
Our target notions of security are expressed in a computational
model of cryptography. In this model, adversaries are probabilistic
programs that operate on bitstrings and have limited computational
power. This leads us to reason with polynomial-time hypotheses
and probabilistic semantics. We could have used instead a symbolic
model of cryptography, where adversaries may perform arbitrary
computations on abstract algebraic terms (not bitstrings). How-
ever, this simpler model would have hidden many cryptographic
side channels that are relevant in distributed implementations and
problematic for information security. The relation between sym-
432bolic and computational models is the subject of active research
[see e.g. Abadi and Rogaway, 2002, Backes et al., 2003, Comon-
Lundh and Cortier, 2008, Laud, 2008] but it is unlikely that they
can be reconciled at the level of details handled by our compiler.
Thus, we seek computational soundness directly for information-
Ô¨Çow security, rather than for symbolic cryptography.
In prior work, Fournet and Rezk [2008] design a computation-
ally sound type system for cryptography and give a typed trans-
lation from non-interferent source programs to their cryptographic
implementations. Our theory extends theirs in several directions:
Active Adversaries: Our compiled code is secure against ad-
versaries that control the scheduling between hosts. This reÔ¨Çects
a realistic attacker model for distributed programs, where the op-
ponent controls parts of the program (representing for instance the
corrupted parties of a protocol) and also controls all interactions
between the remaining ‚Äúhonest‚Äù parts of the program (representing
for instance an open network). In their work, they restrict the con-
trol Ô¨Çow of programs and assume that the compiled code follows
the source control Ô¨Çow.
Information release: Our safety conditions on source programs
are less restrictive and do not require noninterference. Hence, our
compiler accepts programs that selectively leak information, and
our theorems state that, for all safe source programs, if an adversary
can successfully attack our compiled code, then there is also an
adversary that can successfully attack the source program.
EfÔ¨Åcient use of cryptography: They formalize only asymmetric
cryptography. In contrast, we use asymmetric cryptography only
for initial key distribution, then rely on symmetric cryptography,
which is much more efÔ¨Åcient. We also allocate fewer keys and
perform simple cryptographic optimizations.
Main Contributions
‡¢´ We design and implement a compiler from sequential pro-
grams with shared memory to distributed programs at least
as secure as the source. Our tool combines both symmetric
and asymmetric cryptography and yields efÔ¨Åcient code.
‡¢´ We account for a realistic class of active adversaries, which
control some components of the system (including the net-
work) and schedule the others.
‡¢´ We obtain computational soundness theorems for all infor-
mation Ô¨Çows, both for secrecy and for integrity.
(We also
show functional correctness, but only for an adversary that
implements a reliable network.)
‡¢´ We report experimental performance results obtained for a
series of sample distributed programs.
Related Work Due to lack of space, we discuss only closely re-
lated work. We refer to Sabelfeld and Myers [2003] for a survey
of information Ô¨Çow security, and to Fournet and Rezk [2008] for a
more complete account of cryptographic information Ô¨Çows.
Computational noninterference: Laud [2001] pioneers work on
information Ô¨Çow relying on concrete cryptographic assumptions.
He introduces computational correctness for encryption in a model
with passive adversaries. Our notions of noninterference generalize
this property to the active case, and also cover integrity properties.
Secure program partitioning: Jif/Split [Zdancewic et al., 2002,
Zheng et al., 2003] is a compiler from information Ô¨Çow typed se-
quential Java programs to distributed systems with mutual distrust
between hosts. Their distributed implementation relies on secure
communications, modelled as private channels. We lift this as-
sumption, implement communications using cryptographic mech-
anisms, and prove them correct under standard cryptographic hy-
potheses. Hence, our compiler can be seen as a cryptographic
back-end for Jif/Split. Unlike Jif/Split, we do not consider code
replication but only data replication.
Robustness: A system is robust when an adversary cannot affect
the security of information Ô¨Çow [Zdancewic and Myers, 2001, My-
ers et al., 2006]. Decentralized robustness generalizes this notion
to conÔ¨Ågurations with mutual distrust between principals [Chong
and Myers, 2006]. In this work, we rely on similar robustness con-
ditions on source programs.
Contents Section 2 deÔ¨Ånes our source and target languages. Sec-
tion 3 deÔ¨Ånes information Ô¨Çow policies and security properties.
Sections 4, 5, 6, and 7 describe the slicing, control-Ô¨Çow, replication,
and cryptographic stages of the compiler. Section 8 reports experi-
mental results. Section 9 concludes. Additional deÔ¨Ånitions, exam-
ples, and proofs appear online at http://www.msr-inria.
inria.fr/projects/sec/cflow.
2. LANGUAGES
In this section, we present a core probabilistic imperative lan-
guage and its extension to express distribution. We also deÔ¨Åne con-
crete distributed programs with explicit scheduling.
Core Language We use a while-language based on transparent
shared memory, with the following grammar:

     :=  ‡¢Ø  :=        ‡¢Ø skip ‡¢Ø ; 
  ‡¢Ø   
‡¢Ø
‡¢Ø
if  then  else  ‡¢Ø while  do 
 := declassify ‡°Å
where  and  range over deterministic and probabilistic -ary
functions, respectively, with  ‡£ô . Expressions  consist of vari-
ables and operations, including standard boolean and arithmetic
constants and operators. Programs and commands  consist of
variable assignments, using deterministic expressions and proba-
bilistic functions, composed into sequences, tests, and loops. (The
assignment  := declassify ‡°Å behaves as  := ; it is explained
in Section 3.) We use curly brackets  for parenthesizing com-
mands. We let ML be the set of variables written by , let HL
be the set of variables read by , and let L be ML √û HL.
Although our language does not feature procedure calls, we can
use command contexts to range over programs with access to Ô¨Åxed,
privileged procedures (sometimes called ‚Äúoracles‚Äù in cryptogra-
phy) using shared variables for passing their input and output pa-
rameters. An -ary command context, written  _     _‡¢§,
is a term obtained from the grammar of commands extended with
placeholders for commands _ (and, more generally, for command
contexts _     ). For instance,  _ ﬂ∞ represents a com-
mand, parameterized by a command context _, that Ô¨Årst runs 
then runs , which may in turn call  ﬂ∞ any number of times.
Probabilistic Semantics The semantics of each probabilistic func-
tion is given by a discrete parametric probability distribution. We
write   for the fair ‚Äúcoin-tossing‚Äù function that returns either
  . We use probabilistic functions mainly to
 or  with probability 
model cryptographic algorithms as commands.
Program conÔ¨Ågurations are of the form   where  is a pro-
gram and  is a memory, that is, a function from variables to values.
The special program
represents termination. The operational se-
mantics of commands is given as Markov chains between program
conÔ¨Ågurations, with probabilistic steps  √õ ﬂ∞ induced by the
√ù
433conÔ¨Ågurations ﬂ∞, ﬂ∞ﬂ∞ ‡¢£
condition : 2H    E‡¢ê√ù‡¢£
probabilistic functions (see the full paper). We lift these reduction
steps to conÔ¨Åguration distributions, and write  √õ ﬂ∞ when, for all
√õﬂ∞   . We write √õ‡¢© for the
transitive closure of √õ. We deÔ¨Åne the semantics of a program 
with initial memory  as follows:  is the conÔ¨Åguration distribu-
tion such that    ;  √õ  for  ‡£ô ; and 2H  
is the probability that  completes with a Ô¨Ånal memory that meets
‡¢Ø . (The limit
exists because the sum increases with  and is bounded by .)
Source Language, with Locations Let      ‡¢† √í be a Ô¨Ånite
set of hosts, intended to represent units of trust (principals) and of
locality (runtime environments). We extend the grammar of the
core language () with locality annotations:
√ù
       ‡¢Ø   
The locality command    states that command  should run
at host . This programming abstraction hides the implementation
details for transferring control between the current host and  be-
fore and after running command . Locality commands can be
nested, as in          . We assume that every source
program has a locality command at top level, setting an initial host.
Since memory is transparently shared between hosts, locality an-
notations do not affect our command semantics.
Target Language, with Explicit Scheduling A distributed pro-
gram is just a series of commands in the core language, each com-
mand intuitively running at a single host. We refer to these com-
mands as threads. (Pragmatically, our compiler groups threads run-
ning at the same host into a single host command that locally sched-
ules its threads.)
To model the intended behavior of a distributed program with 
threads, in particular to state its correctness in the absence of an ad-
versary, we deÔ¨Åne an -ary command context  that implements
a round-robin scheduler. This command context uses a global pro-
gram counter variable ANJ that indicates which thread should run
next, with a special value  to indicate the end of the execution.
DEFINITION 1
_     _
(-ARY SCHEDULER).

 while ANJ ‡¢ß  do _;    ; _
This context may represent a public network, for instance, with
communications between hosts using messages in shared memory.
Finally, we model a compiler  as a function from source pro-
grams   to series of commands          where
 is a distinguished initialization command and  are com-
mands representing threads, meant to be executed as
ANJ := ; ;      
To study the security properties of this compiled program, we will
replace  with some unknown command context  representing
an active adversary that controls the scheduler.