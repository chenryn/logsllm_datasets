5
4
6
internal error
internal error
internal error
internal error
internal error
internal error
internal error
internal error
internal error
internal error
internal error
internal error
4
3
1
3
3
55
4
3
0
3
3
50






































: 1
: 12
: 0
:25
Results: Table IV shows the evaluation results on the
ZEUS dataset. For each contract, the table shows the number
of alarms (#Alarm),
the number of false positives (#FP)
produced by VERISMART and SMTCHECKER. The column
Veriﬁed indicates whether each tool detected all bugs without
false positives (: success, : failure).
The results show that VERISMART successfully addresses
limitations of ZEUS and SMTCHECKER. The 25 contracts
contain 172 arithmetic operations, where VERISMART pointed
out 40 operations as potential bugs. We have manually checked
that 34 out of total alarms are true positives. In benchmark #24,
VERISMART produced 6 false positives due to unsupported
invariants (quantiﬁed invariants and compound invariants, Sec-
tion III-C), and imprecise function call analysis. We manually
checked that the remaining 132 (=172-40) queries proven to be
safe by VERISMART are actually true negatives. By contrast,
according to the publicly available data [28], ZEUS produces
at least one false positives for each contract in Table IV
(i.e., ≥ 25 false alarms in total). SMTCHECKER could
only analyze 13 contracts as it raised internal errors for the
other 12 contracts, which is due to its immature support of
Solidity syntax [29]. Among 61 operations from 13 contracts,
SMTCHECKER succeeded to detect all 5 bugs in them thanks
to its exhaustive veriﬁcation approach. However, it reported
55 alarms in total, of which 50 are false positives. In terms of
efﬁciency, SMTCHECKER took about 1 second per contract
and VERISMART took about 20 seconds per contract.
Importance of Transaction Invariants: The key enabler
for high precision was the ability of VERISMART to lever-
age transaction invariants. We also ran VERISMART without
inferring transaction invariants (i.e., using true as transaction
invariants); without transaction invariants, VERISMART fails
to verify 17 out of 25 contracts.
C. Case Study: Application to Other Types of Vulnerabilities
VERISMART can be used for analyzing other safety prop-
erties as well. To show this, we applied VERISMART to
ﬁnding bugs related to access control, where security-sensitive
variables can be manipulated by anyone for malicious use.
For example, consider the code snippet adapted from the
EtherCartel contract for crypto idle game (CVE 2018-11329):
function DrugDealer() public { ceoAddr = msg.sender; }
function buyDrugs () public payable {
ceoAddr.transfer(msg.value); // send Ether to ceoAddr
drugs[msg.sender] += ...; // buy drugs by paying Ether
}
Observe that the address-typed variable ceoAddr, the beneﬁ-
ciary of Ether, can be taken by anyone who calls the function
DrugDealer. If an attacker becomes the beneﬁciary by
calling DrugDealer, the attacker might illegally take some
digital assets whenever benign users buy some digital assets
(i.e., drugs) by calling buyDrugs where transfer in it is
a built-in function that sends Ether to ceoAddr. This vulner-
ability was exploited in about 1 hour after deployment [30].
To detect this bug, we used VERISMART as follows. First,
we speciﬁed safety properties by automatically generating
the assertion assert(msg.sender==addr) right before
each assignment of the form addr=...;, where addr is a
global address-typed variable which is often security-sensitive
(excluding assignments in constructors, which typically set the
contract owners). Next, we ran VERISMART without any mod-
iﬁcation of its veriﬁcation algorithm. With this simple exten-
sion, VERISMART worked effectively; it not only detected all
known CVE vulnerabilities (2018-10666, 2018-10705, 2018-
11329) but also proved the absence of this bug scenario for
55 contracts out of 60 from Table II. VERISMART could not
prove safety of the remaining 5 contracts due to the imprecise
speciﬁcation described above.
D. Threats to Validity
We summarize limitations of our evaluation and consequent
threats to validity. Firstly, the benchmark contracts that we
used (60 CVE dataset + 25 ZEUS dataset) might not be repre-
sentative although we made effort to avoid bias in the datasets
(e.g., removal of duplicates). Secondly, the performance of
VERISMART may vary depending on the performance of the
off-the-shelf SMT solver (i.e., Z3) used internally or timeout
options used in the experiments. Thirdly, we did not study
the exploitability of bugs in this paper and did not compare
VERISMART and other tools in this regard. Thus, the results
may be different if those tools are evaluated with exploitability
in mind. Lastly, although we did our best, we realized that
manually classifying static analysis alarms into true or false
positives is extremely challenging and the classiﬁcation can
be even subjective in a few cases.
VI. RELATED WORK
In this section, we place our work in the literature and clar-
ify our contributions regarding existing works. Section VI-A
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 09:39:38 UTC from IEEE Xplore.  Restrictions apply. 
1689
compares our work with existing smart contract analyses. Sec-
tion VI-B discusses veriﬁcation techniques for other domains.
A. Analyzing Smart Contracts
Compared to existing techniques for analyzing smart con-
tracts [9], [26], [8], [18], [7], [31], [32], [33], [34], [12], [11],
[19], [20], [35], [36], [37], [38], [39], [40], VERISMART is
unique in that it achieves full automation, high precision, and
high recall at the same time. Below, we classify existing ap-
proaches into fully automated and semi-automated approaches.
Fully Automated Approaches: VERISMART belongs to
the class of fully automated tools based on static or dynamic
program analysis techniques that require no manual effort and
can be used by end-users who lack expertise in formal veri-
ﬁcation. Instead, these approaches focus on relatively simple
safety properties (e.g., overﬂows).
One popular approach is bug-ﬁnders based on symbolic
execution or fuzz testing. For example, OYENTE [9], [26],
MYTHRIL [8], OSIRIS [7], MANTICORE [10] and MA-
IAN [18] discover bugs by symbolically executing EVM byte-
code. OYENTE is the ﬁrst such tool for Ethereum smart con-
tracts, which detects various bug patterns including arithmetic
bugs. MYTHRIL is also a well-known open-sourced tool for
detecting a variety of bugs by performing symbolic execution.
OSIRIS [7] is a tool that is specially designed for detecting
arithmetic bugs. MAIAN [18] focuses on ﬁnding violations
of trace properties. GASPER [31] uses symbolic execution
to identify gas-costly programming patterns. REGUARD [34]
and ContractFuzzer [41] use fuzz testing to detect common
security vulnerabilities. Although symbolic execution and fuzz
testing are effective for ﬁnding bugs, they inevitably miss
critical vulnerabilities, which is particularly undesirable for
safety-critical software like smart contracts.
Other approaches are veriﬁers that perform exhaustive anal-
yses based on static analysis or automatic program veriﬁcation
techniques. ZEUS [11] is a sound static analyzer that can
detect arithmetic bugs or prove their absence. ZEUS leverages
abstract
interpretation and software model checking [42].
SMTCHECKER [12] is the “ofﬁcial” veriﬁer for Solidity
developed by the Ehtereum Foundation. Its primarily goal is to
verify the absence of arithmetic bugs such as integer over/un-
derﬂows and division-by-zeros [12] by performing SMT-
based bounded veriﬁcation. Unlike VERISMART, ZEUS and
SMTCHECKER lack inter-transactional reasoning and this is
currently considered a key limitation of these tools [11], [12].
SECURIFY [19], MadMax [20], and Vandal [21] use declar-
ative static analysis techniques based on Datalog [43]. Besides
their inability to infer transaction invariants, one common
drawback of Datalog-based analyzers is that
they cannot
describe general classes of (in particular, numerical) static
analyses and is inappropriate for ﬁnding arithmetic bugs.
Semi-Automated Approaches: Semi-automated tools for
formally specifying and verifying smart contracts have dif-
ferent goals. These approaches can prove a wide range of
functional properties at the expense of full automation; they
require users to manually provide speciﬁcations or invariants.
Hirai
[36]
formalizes
the Ethereum Virtual Machine
(EVM) and provides a way to prove safety properties of
smart contracts in interactive theorem provers such as Is-
abelle/HOL [44]. Bharagavan et al. [37] provide a framework
for formally specifying and verifying functional correctness of
smart contracts using the F* proof assistant [45]. Grishchenko
et al. [38] also use F* to formalize small-step semantics of
EVM bytecode and express a number of security properties
of smart contracts. Hildenbrandt et al. [46] deﬁne formal
semantics of EVM using the K framework [47]. Amani
et al. [39] formalize EVM in Isabelle/HOL and provide a
program logic for reasoning about smart contracts. Lahiri et
al. [40] describe an approach for formal speciﬁcation and
veriﬁcation of smart contracts, where the primary goal is to
take a high-level speciﬁcation expressed by a state machine
and to verify that the implementation meets the speciﬁcation.
Manual Safety Checking: Some techniques (e.g., Safe-
Math [48]) depend on manual annotation of programs to
prevent bugs, which has two drawbacks. First, manual an-
notation is error-prone, hardly exhaustive, and sometimes
not recommended (e.g., decreasing readability, unnecessary
waste of gas fees). As a result, many smart contracts do
not perform manual safety checking exhaustively [7], [11].
Second, veriﬁcation prevents bugs at compile time so that they
can be ﬁxed before deployment, but manual checking detects
bugs only at runtime.
B. Analyzing Arithmetic Safety of Traditional Programs
Ensuring arithmetic safety has been studied extensively in
the program analysis and veriﬁcation communities [49], [50],
[51], [52], [53], [54], [55], [56], [56], [57], [58]. Our work
differs from them in two ways. First, we focus on smart
contracts and provide a domain-speciﬁc algorithm. Second,
to our knowledge, our CEGIS-style algorithm for verifying
arithmetic safety is also new in this general context.
Astr´ee [49], [50] is a domain-speciﬁc static analyzer tailored
to ﬂight-control software. Sparrow [51] and Frama-C [52],
[53] are domain-unaware static analyzers for C programs.
Astr´ee, Sparrow, and Frama-C are based on abstract inter-
pretation [59], [60]. Instead, we use a CEGIS-style algorithm
because existing abstract domains such as intervals [59] and
octagons [61] cannot capture domain-speciﬁc invariants (e.g.,
sum) of smart contracts. Furthermore, abstract interpretation
cannot infer invariants that are useful in practice but not in-
ductive with respect to their abstract semantics. While our ap-
proach is similar to the existing CEGIS approaches (e.g., [13],
[14], [15]), to the best of our knowledge, its application to
arithmetic safety veriﬁcation has not been studied. Bounded
veriﬁcation approaches (e.g., [62], [63]) are different from
our work as we perform unbounded veriﬁcation. Our work is
different from symbolic execution-based techniques [54], [55],
[56], [56], [57], [58] or unsound static analysis [64], [65], as
we aim to detect all bugs. A few techniques aim to ﬁx integer
overﬂow bugs [66], [67], [68], which may introduce unwanted
changes in programs though useful.
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 09:39:38 UTC from IEEE Xplore.  Restrictions apply. 
1690
VII. CONCLUSION
in particular transaction,
As smart contracts are safety-critical, formally verifying their
correctness is of the greatest importance. In this paper, we
presented a new and powerful veriﬁcation algorithm for smart
contracts. Its central feature is the ability to automatically
infer hidden,
invariants of smart
contracts and leverage them during the veriﬁcation process.
We implemented the algorithm in a tool, VERISMART, for
verifying arithmetic safety of Ethereum smart contracts and
demonstrate its effectiveness on real-world smart contracts in
comparison with existing safety analyzers. Our work shows a
common yet signiﬁcant shortcoming of existing approaches
(i.e.,
inability to infer and use transaction invariants) and
sheds light on the future development of automated tools for
analyzing smart contracts.
ACKNOWLEDGMENT
We thank Junhee Lee and Minseok Jeon for their valuable
comments on Proposition 1 and Appendix A. This work
was supported by Institute of Information & communications
Technology Planning & Evaluation(IITP) grant funded by
the Korea government(MSIT) (No.2019-0-01697, Develop-
ment of Automated Vulnerability Discovery Technologies for
Blockchain Platform Security and No.2019-0-00099, Formal
Speciﬁcation of Smart Contract).
REFERENCES
[1] 2018,
[Online; accessed 31-May-2019].
[Online]. Available: http:
//virtual-strategy.com/2018/12/05/hashcash-enters-malta-with-smart-
contract-based-insurance-automation/
[2] Y. Hanada, L. Hsiao, and P. Levis, “Smart contracts for machine-
to-machine communication: Possibilities and limitations,” CoRR, vol.
abs/1806.00555, 2018. [Online]. Available: http://arxiv.org/abs/1806.
00555
[3] N. Atzei, M. Bartoletti, and T. Cimoli, “A survey of attacks on
ethereum smart contracts sok,” in Proceedings of the 6th International
Conference on Principles of Security and Trust - Volume 10204. New
York, NY, USA: Springer-Verlag New York, Inc., 2017, pp. 164–186.
[Online]. Available: https://doi.org/10.1007/978-3-662-54455-6 8
[4] 2016,
[Online; accessed 31-May-2019].
[Online]. Available: https:
[5] 2018,
//www.wired.com/2016/06/50-million-hack-just-showed-dao-human/
[Online;
[Online]. Available:
https://blockexplorer.com/news/260-million-parity-proposes-eip-999-
to-recover-frozen-multi-sig-funds/
31-May-2019].
accessed
[6] 2018,
[Online; accessed 31-May-2019].
[Online]. Available: https:
//blog.peckshield.com/2018/04/25/proxyOverﬂow/
[7] C. F. Torres, J. Sch¨utte, and R. State, “Osiris: Hunting for integer
bugs in ethereum smart contracts,” in Proceedings of the 34th Annual
Computer Security Applications Conference, ser. ACSAC ’18. New
York, NY, USA: ACM, 2018, pp. 664–676.
[Online]. Available:
http://doi.acm.org/10.1145/3274694.3274737
[8] “Mythril classic: an open-source security analysis tool for ethereum
smart contracts.” 2018, [Online; accessed 31-May-2019]. [Online].
Available: https://github.com/ConsenSys/mythril-classic
[9] L. Luu, D.-H. Chu, H. Olickel, P. Saxena, and A. Hobor, “Making
smart contracts smarter,” in Proceedings of the 2016 ACM SIGSAC
Conference on Computer and Communications Security, ser. CCS ’16.
New York, NY, USA: ACM, 2016, pp. 254–269. [Online]. Available:
http://doi.acm.org/10.1145/2976749.2978309
[10] “Manticore: a symbolic execution tool for analysis of smart contracts
[Online].
[Online; accessed 31-May-2019].
and binaries,” 2017,
Available: https://github.com/trailofbits/manticore
[11] S. Kalra, S. Goel, M. Dhawan, and S. Sharma, “ZEUS: analyzing
safety of smart contracts,” in 25th Annual Network and Distributed
System Security Symposium, NDSS 2018, San Diego, California, USA,
February 18-21, 2018. The Internet Society, 2018. [Online]. Available:
http://wp.internetsociety.org/ndss/wp-content/uploads/sites/25/2018/02/
ndss2018 09-1 Kalra paper.pdf
[12] L. Alt and C. Reitwiessner, “Smt-based veriﬁcation of solidity smart
contracts,” in Leveraging Applications of Formal Methods, Veriﬁcation
and Validation. Industrial Practice, T. Margaria and B. Steffen, Eds.
Cham: Springer International Publishing, 2018, pp. 376–388.
[13] A. Solar-Lezama, L. Tancau, R. Bodik, S. Seshia, and V. Saraswat,
“Combinatorial sketching for ﬁnite programs,” SIGOPS Oper. Syst.
Rev., vol. 40, no. 5, pp. 404–415, Oct. 2006. [Online]. Available:
http://doi.acm.org/10.1145/1168917.1168907
[14] A. Udupa, A. Raghavan, J. V. Deshmukh, S. Mador-Haim, M. M.
Martin, and R. Alur, “Transit: Specifying protocols with concolic
snippets,” in Proceedings of the 34th ACM SIGPLAN Conference on
Programming Language Design and Implementation, ser. PLDI ’13.
New York, NY, USA: ACM, 2013, pp. 287–296. [Online]. Available:
http://doi.acm.org/10.1145/2491956.2462174
[15] A. Solar-Lezama, “Program synthesis by sketching,” Ph.D. dissertation,
Berkeley, CA, USA, 2008, aAI3353225.
[16] 2018,
[Online; accessed 31-May-2019].
[Online]. Available: https:
//github.com/VenusADLab/EtherTokens/blob/master/SHARKTECH/
SHARKTECH.md
[17] “Solidity 0.5.3,” 2019,
[Online; accessed 31-May-2019].
Available: https://solidity.readthedocs.io/en/v0.5.3/index.html
[Online].
[18] I. Nikoli´c, A. Kolluri, I. Sergey, P. Saxena, and A. Hobor, “Finding the
greedy, prodigal, and suicidal contracts at scale,” in Proceedings of the
34th Annual Computer Security Applications Conference, ser. ACSAC
’18. New York, NY, USA: ACM, 2018, pp. 653–663. [Online].
Available: http://doi.acm.org/10.1145/3274694.3274743
[19] P. Tsankov, A. Dan, D. Drachsler-Cohen, A. Gervais, F. B¨unzli,
smart
and M. Vechev, “Securify: Practical
contracts,” in Proceedings of
the 2018 ACM SIGSAC Conference
on Computer and Communications Security, ser. CCS ’18. New
York, NY, USA: ACM, 2018, pp. 67–82.
[Online]. Available:
http://doi.acm.org/10.1145/3243734.3243780
security analysis of
[20] N. Grech, M. Kong, A.
Jurisevic, L. Brent, B. Scholz, and
Y. Smaragdakis,
in
ethereum smart contracts,” Proc. ACM Program. Lang., vol. 2,
no. OOPSLA, pp. 116:1–116:27, Oct. 2018.
[Online]. Available:
http://doi.acm.org/10.1145/3276486
“Madmax: Surviving out-of-gas
conditions
[21] L. Brent, A. Jurisevic, M. Kong, E. Liu, F. Gauthier, V. Gramoli, R. Holz,
and B. Scholz, “Vandal: A scalable security analysis framework for smart
contracts,” CoRR, vol. abs/1809.03981, 2018.
[22] A. R. Bradley and Z. Manna, The Calculus of Computation: Decision
Berlin, Heidelberg:
Procedures with Applications to Veriﬁcation.
Springer-Verlag, 2007.
[23] L. de Moura and N. Bjørner, “Z3: An efﬁcient smt solver,” in Tools
and Algorithms for the Construction and Analysis of Systems, C. R.
Ramakrishnan and J. Rehof, Eds. Berlin, Heidelberg: Springer Berlin
Heidelberg, 2008, pp. 337–340.
[24] C. Barrett, C. L. Conway, M. Deters, L. Hadarean, D. Jovanovi’c,
T. King, A. Reynolds, and C. Tinelli, “CVC4,” in Proceedings of the
23rd International Conference on Computer Aided Veriﬁcation (CAV
’11), ser. Lecture Notes in Computer Science, G. Gopalakrishnan