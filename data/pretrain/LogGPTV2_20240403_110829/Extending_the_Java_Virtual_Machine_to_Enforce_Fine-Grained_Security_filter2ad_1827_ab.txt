such simpliﬁcation represents a clear trade-oﬀ against a number of other aspects of the respective
security model. Our work targets the adverse eﬀects that this simpliﬁcation has on ﬂexibility and
granularity of policy speciﬁcation and enforcement.
While code in J2SE runs within JVM, applications executed in J2ME (on top of CLDC and MIDP,
as depicted in Figure 1(a)) on a constrained mobile device run within KVM - a scaled-down version
of JVM. The sandbox model deﬁned by KVM is considerably diﬀerent to that of JVM: it restricts the
exposed API to that predeﬁned by CLDC; application management occurs at native code level; user
is forbidden from touching the classloader or downloading any native libraries.
MIDP retains the general concept of the domain-based security model of J2SE. Permissions in
MIDP protection domains are classiﬁed in two groups:
• Permission classiﬁed as ALLOWed are granted automatically, without recourse to user conﬁr-
mation.
• The USER permissions are granted only upon explicit user approval.
Furthermore, the validity period associated with the latter category of permissions may vary between
single permission request (oneshot), application session wide (session) or until explicit revocation
(blanket).
CLDC and MIDP (Figure 1(a)), as stated previously, represent the execution environment for
MIDlets - J2ME applications designed for mobile devices. While MIDP 1.0 introduced the concept of
sandbox for MIDlets, MIDP 2.0 deﬁned the MIDlet trust model, as detailed below.
Trust model of J2ME is based on the ability to verify the origin and integrity of a MIDlet. The
veriﬁcation is based on certiﬁcate associated with the MIDlet suite. Should the certiﬁcate be known
and veriﬁable against a trusted authority, the MIDlet is considered as trusted. Otherwise, should the
user decide to proceed with MIDlet installation, it will be designated as untrusted. This eﬀectively
means the user shall be asked to explicitly conﬁrm every sensitive operation [14]. Figure 2(a) shows
the process of signing and assigning a MIDlet to a protection domain based on the trusted certiﬁcate.
Typically, MIDP default (unmodiﬁable) policy consists of trusted and untrusted protection domains -
associated with trusted and untrusted MIDlets respectively. Figure 2(b) shows the mapping from spe-
ciﬁc application to the assigned protection domain and associated security permission. For example,
the untrusted MIDlets Stock App and Automotive are allowed to execute, while the trusted MIDlet
Game is allowed HTTP access, sending SMSs and accessing the contact list.
Limitations of the J2ME (with respect to J2SE) that serve as the main motivation for our work
can be summarized as:
• User can not modify the security policy (including the ﬁle), implying:
– Predetermined permission set
– Predetermined domain set
• No ability to specify per-application policy
• SecurityManager is ﬁxed and cannot be replaced by user
Although there are diﬀerent implementations of J2ME, from diﬀerent vendors (Sun, IBM) and
for diﬀerent operating systems (Symbian, Palm, Windows, WinCE, Linux, Solaris), they all follow
the security architecture speciﬁcations deﬁned in JSR118 [15]. JSR 248, Mobile Service Architecture
Speciﬁcation [16], deﬁnes the set of permissions supported and enforced in Java. Permission types
belong to diﬀerent function groups (e.g.: Phone Call, Call Control, Net Access, Messaging, Local
Connectivity etc).
6
(a)
(b)
Figure 2: (a) Trusting a MIDlet suite and binding it to a protection domain (b) Mapping MIDlets to
protection domains and to Java permissions
4.4 J2ME Security Model - Operational Aspects
With reference to the original J2ME security architecture, the modules involved in the process of
making resource access decisions and their interactions are shown in Figure 3(a).
Access requests are triggered when applications invoke respective, resource-related (e.g. commu-
nications channel, system settings, etc.) library calls. The security architecture of the JVM/KVM
assures that the application may not bypass the JVM/KVM libraries and directly access native calls
and protected operations. In other words, all sensitive calls must pass through libraries. On receiving
a resource access request, the respective Java 2 library invokes the SecurityToken class to make the
access decision.
As Figure 3(a) depicts, to make an access decision, the SecurityToken module checks whether the
particular domain to which the requesting MIDlet is assigned (as speciﬁed in policy.txt ﬁle) includes
the corresponding access granting permission. If the permission is ALLOWed, access is granted. If
the permission is of type USER, the user is prompted for a decision. Otherwise, if nothing is speciﬁed
in the policy ﬁle, access is denied and a SecurityException is thrown. The decisions thus derived
can be referred to as atomic in the sense that no access history or other contextual attributes are
considered. The policy itself, i.e. the protection domain speciﬁcation, is loaded by the Permissions
module. At execution time, the module answers queries on the permissions of the running MIDlets.
The policy deﬁnition ﬁle itself comes pre-loaded on the virtual execution environment and can
not be accessed for any type of modiﬁcation. This eﬀectively implies complete lack of ﬂexibility with
respect to protection domains structure and permissions speciﬁcation.
5 Extended J2ME Architecture
Having introduced the fundamental aspects of the J2ME architecture, in this section we present the
extensions to the architecture and modiﬁcation of its operational aspects that enable the support
for ﬁne-grained, history-aware, user-deﬁnable, per-application policy speciﬁcation and enforcement.
The contribution made in this section represents the basis for addressing the constraints of the J2ME
security model speciﬁed in Section 4. We preserve the fundamental aspects of the J2ME security
model, such as its domain-based nature.
Figure 3(b) depicts the complete J2ME architecture incorporating our modiﬁcations. The modiﬁ-
cations include both addition of specialized modules and modiﬁcation of functionality of the existing
ones, as detailed in the following sections.
As previously stated, the aim of the presented work is to provide the support for ﬁne-grained,
history-based, application-speciﬁc policy speciﬁcation and enforcement within the J2ME framework.
7
(a)
(b)
Figure 3: (a) Permission-based initial J2ME security architecture. (b)Extending the J2ME security
architecture with the Run-time Monitor.
A simple example of a security policy that is supported by our extended J2ME architecture (xJ2ME)
is “browser may not download more than 300 KB of data per day”.
Figure 3(b) depicts the new Java security architecture. The Run-time Monitor is in charge of
making resource access decisions. In order to grant or deny resource access, the Run-time Monitor
relies on the Policy Manager to identify the relevant application-speciﬁc policy. Once the policy is
identiﬁed, the Run-time Monitor evaluates its conditions in conjunction with resource usage history
information of the system and MIDlet, as obtained from the History Keeper. If the policy conditions
are fulﬁlled, access is granted, otherwise a SecurityException is thrown.
In order to enable per-application policies, we associate each MIDlet with a speciﬁc policy which
becomes an integral part of the corresponding MIDlet suite. This is in addition to the system-wide
security policy. The Policy Manager is in charge of managing (reading, loading and interpreting)
both MIDlet-speciﬁc and system-wide policies. We envisage the user to be able to set the desired
policies on his mobile phone through a graphical interface.
To support policies based on historic resource access and usage, the Run-time Monitor must
maintain a history of relevant system and application behavior. This is the role of the History
Keeper module. Application-speciﬁc behavior information is retrieved at the MIDlet loading time,
accumulated over its execution and stored in a persistent manner upon its termination. The system-
related behavior information is accumulated throughout the system operation. The behavior history
information is always stored in a secure manner - not accessible to MIDlets.
The introduced policy model does not in any manner aﬀect the original J2ME security model.
Instead, our contribution builds upon the J2ME model, retaining its domain-based nature and per-
mission structure. The extended policy model actually allows extra constraints to be placed on
per-application basis, further strengthening the overall J2ME security model.
6 Policy Speciﬁcation
The existing J2ME policy speciﬁcation language, based around the concept of protection domains, is
too constrained to allow for the expressiveness required by our policy model. To express the policies in
our model, we leverage Security Policy Language (SPL) [17]. SPL is an event-driven, constraint-based,
declarative policy language that supports access-control, history-based and obligation-based policies.
It also has inherent support for policy prioritization which enables us to specify per-application policies
8
in the context of a wider platform policy which guides the overall behavior of the system, as described
below.
6.1 Basic SPL Rules
SPL policies are composed of individual rules, each representing a three-valued logic expression that
evaluates to: allow, deny or not apply. The role of the rules is do provide the decision making basis for
the access control engine that implements the language. The rules are conditioned on the occurence
of an event - an access request for a monitored resource. The following is the basic form of SPL rule
that we use in our work:
[label:] domain-expression :: decide-expression
The rule has two parts: i) an optional label used to refer to the speciﬁc rule; and ii) two logical
expressions separated by “::”. The logical expression on the left of the “::” separator establishes the
domain of applicability of the rule, while the expression on the right determines the acceptability
of the event. Both of the expressions are simple binary expressions with the standard set of logic
operators and two special values: “true” and “false”.
As previously stated, SPL is an event-driven language. In other words, rules are evaluated upon
occurence of a policy-relevant event. Examples of SPL rules speciﬁc for our work are the following:
sms_number_limit:
sms_black_list:
sms_cost_limit:
ce.target.permission = "SMS" :: global_state.total_sms_sent < sms_number_limit;
ce.target.permission = "SMS" :: ce.target.number = "+396427334";
ce.target.permission = "SMS" :: global_state.total_sms_cost < sms_cost_limit + sms_cost;
To express entities, SPL uses object-oriented like syntax.
In the above example, ce represents
the event that triggered the policy evaluation - the current event; permission attribute of the event
determines the family of security relevant operations the request applies to; while the global state
object keeps the variables describing the state of the resources to which the policy applies.
6.2 SPL Policies and Rule Restriction
An SPL policy is deﬁned as a group of rules that govern a particular domain of events. In our work,
domains of events group events related to individual MIDlets. In other words, we specify a policy per
MIDlet on the mobile platform. An example of a policy deﬁnition would be the following:
policy GameApp {
gprs_limit: ce.target.permission = "GPRS" ::
local_state.gprs_consumed < (local_grps_limit + ce.target.amount);
sms_number_limit: ce.target.permission = "SMS" ::
local_state.total_sms_sent < local_sms_number_limit;
?GameApp: gprs_limit AND sms_number_limit;
}
The above example shows the use of local, application speciﬁc limits on resource consumption. The
last statement in the policy deﬁnition, ?GameApp:
gprs limit AND sms number limit;, represents
the policy query rule. A query rule is the rule that implements the policy, i.e. the one that is invoked
to obtain a decision with respect to the speciﬁc policy. The query rule is in itself a logic expression
that combines, using the standard logic operators, individual rules comprising the policy.
In general, logic expressions are normally deﬁned for two-valued (true/false) logics. However,
since SPL uses a tree-valued (true/false/not-applicable) logic, it deﬁnes a suitable tree-value algebra
in which the not-applicable value acts as a neutral element with respect to the standard two-value
algebra for AND, OR and NOT logic operators.
As previously stated, we deﬁne local MIDlet policies in the context of a platform-wide, global
system policy. The global policy is deﬁned using the same syntax as for the local policies. However,
9
a global policy by its nature cannot refer to local state of any MIDlet. Therefore, it is deﬁned in
terms of global (cross-MIDlet), cumulative state of platform resources and the corresponding resource
consumption limits.
The overall “system” policy will, owing to the above, consist of a number of local, per-MIDlet
policies and a single platform-wide policy, setting the global limits. In the context of SPL, individual
policies are active only if instantiated and inserted in another policy - eﬀectively forming a tree of
active policies. The only exception to this rule is the master policy which represents the root of the
tries. In our case, the master policy is represented by the platform-wide policy. Instantiation of a
policy uses a syntax similar to creation of a new object in Java, as shown in the following example of
a global policy:
policy PlatformPolicy {
gprs_limit: ce.target.permission = "GPRS" ::
global_state.gprs_consumed < (global_grps_limit + ce.target.amount);
sms_number_limit: ce.target.permission = "SMS" ::
global_state.total_sms_sent < global_sms_number_limit;
GameApp_Policy: new GameApp;
FORALL r in GameApp_Policy {
r @ {ce.MIDlet = "GameApp"};
};
BrowserApp_Policy: new BrowserApp;
FORALL r in BrowserApp_Policy {
r @ {ce.MIDlet = "BrowserApp"};
};
?PlatformPolicy: gprs_limit AND sms_number_limit AND GameApp_Policy AND BrowserApp_Policy;
}
In the above example we can see (starting from the top) two rules applying to the global state,
followed by instantiation of two MIDlet speciﬁc policies (note the new keyword). FORALL block follow-
ing each of the policy instantiations denotes the SPL universal quantiﬁer, leveraged here to specify
policy restriction. The expression following it speciﬁes that all rules r are applicable (@ operator) only
when the access request comes from the respective MIDlet. Deﬁnition of such a constraint ensures
that there is no conﬂicts among policies deﬁned for diﬀerent MIDlets.
6.3 Local and Global State Update
Finally, we leverage the concept of obligation in SPL to ensure in a veriﬁable manner that relevant
state updates take place. The following is an example based on the previously deﬁned global policy.
policy PlatformPolicy {
gprs_limit: ce.target.permission = "GPRS" ::
global_state.gprs_consumed < (global_grps_limit + ce.target.amount);
gprs_state_update:
EXISTS fe in FutureEvents {
fe.action.target = "GPRS_STATE_UPDATE" &
fe.action.value = ce.target.quantity :: true
};
gprs: gprs_limit AND gprs_state_update;
sms_number_limit: ce.target.permission = "SMS" ::
global_state.total_sms_sent < global_sms_number_limit;
sms_state_update:
EXISTS fe in FutureEvents {
fe.action.target = "SMS_STATE_UPDATE" &
fe.action.value = ce.target.quantity :: true
};
sms: sms_limit AND sms_state_update;
10
...
?PlatformPolicy: gprs AND sms AND GameApp_Policy AND BrowserApp_Policy;
}
In SPL, the obligation policies use the existential operator (EXISTS) to condition an operation on
a future event (represented by the set FutureEvents). Although Schneider [7] argues that policies
conditioning present events on future ones are not enforceable, that does not apply for the cases
in which both of the events are within the same atomic transaction. In our work, we assume that
both policy evaluation and state update happen within the same atomic transaction (with ACID
properties).
In the above example, we require the future event to update the state by the value