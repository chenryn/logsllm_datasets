endADT
对于不同的应用，线性表的基本操作是不同的，上述操作是最基本的，对于实际
问题中涉及的关于线性表的更复杂操作，完全可以用这些基本操作的组合来实现。
比如，要实现两个线性表集合A和B的并集操作。即要使得集合A=AUB。说白
了，就是把存在集合B中但并不存在A中的数据元素插人到A中即可。
仔细分析一下这个操作，发现我们只要循环集合B中的每个元素，判断当前元素
是否存在A中，若不存在，则插入到A中即可。思路应该是很容易想到的。
我们假设La表示集合A，Lb表示集合B，则实现的代码如下：
/*将所有的在线性表Lb中但不在La中的数据元素插入到La中·/
（qT STTT.TT）UTUn PTOA
int La_len,Lb_len,i;
ElemType e;
声明与La和Lb相网的数据元素e*/
La_len-ListLength（La）;/求线性表的长度*/
Lb_len=ListLength（Lb）;
for（i-1:iL.length)
return ERROR;
*e=L.data[1-1];
return OK;
注意这里返回值类型Satus是一个整型，返回OK代表1，ERROR代表0。之后
代码中出现就不再详述。
3.5.2插入操作
刚才我们也谈到，这里的时间复杂度为0（1）。我们现在来考虑，如果我们要实现
Listlnsert（*Lie），即在线性表L中的第i个位置插入新元素e，应该如何操作？
举个例子，本来我们在春运时去买火车票，大家都排队排的好好的。这时来了一
个美女，对着队伍中排在第三位的你说，“大哥，求求你帮帮忙，我家母亲有病，我得
急着回去看她，这队伍这么长，你可否让我排在你的前面？”你心一软，就同意了。
这时，你必须得退后一步，否则她是没法进到队伍来的。这可不得了，后面的人像蟠
虫一样，全部都得退一步。骂起四声。但后面的人也不清楚这加塞是怎么回事，没什
么办法。
这个例子其实已经说明了线性表的顺序存储结构，在插入数据时的实现过程（如
图3-5-1所示）。
大哥，求求你？
插队前
空闲空间
加京的出去
空闲空间
图 3-5-1
51
---
## Page 76
大调数据结构
插入算法的思路：
■如果插入位置不合理，抛出异常；
■如果线性表长度大于等于数组长度，则抛出异常或动态增加容量；
■从最后一个元素开始向前遍历到第i个位置，分别将它们都向后移动一个位
置；
■将要插入元素填入位置i处；
■表长加1。
实现代码如下：
/*初始条件：顺序线性表L已存在，1≤i≤ListLength（L），/
/*操作结果：在L中第个位置之前插入新的数据元素e，L的长度加1*/
Status ListInsert（SqList *L,int i,ElemType e)
int k;
if（L->length==MAXSIZE）/*顺序线性表已经满*/
return ERROR;
if（iL->length+1）/*当i不在范图内时*/
return ERROR;
it（ilength）/*若插入数据位置不在表尾·/
for（k=L->length-1;k>=i-11k--/*将要输入位置后数据元素向后移动一位*/
[x]data[i-1]=e;
/*将新元素抽入
L->length++;
return OK;
应该说这代码不难理解。如果是以前学习其他语言的同学，可以考虑把它转换成
你熟悉的语言再实现一遍，只要思路相同就可以了。
3.5.3删除操作
接着刚才的例子。此时后面排队的人群意见都很大，都说怎么可以这样，不管什
么原因，插队就是不行，有本事，找火车站开后门去。就在这时，远处跑来一胖子，
52
---
## Page 77
第3章线性表
对着这美女喊，可找到你了，你这骗子，还我钱。只见这女子二话不说，突然就冲出
了队伍，胖子追在其后，消失在人群中。哦，原来她是倒卖火车票的黄牛，刚才还装
可怜。于是排队的人群，又像蟠虫一样，均向前移动了一步，骂声渐息，队伍又恢复
了平静。
这就是线性表的顺序存储结构删除元素的过程（如图3-5-2所示）。
骗子，还我钱
这离前
空闲空间
逃离后
空闲空间
图3-5-2
删除算法的思路：
如果删除位置不合理，抛出异常；
取出删除元素；
从删除元素位置开始遍历到最后一个元素位置，分别将它们都向前移动一
个位置；
表长减1。
实现代码如下：
/*初始条件：顺序线性表L巴存在，1i匹ListLength（L）·/
/*操作结果：删除L的第个数据元素，并用e返回其值，L的长度减1/
Status ListDelete（SqList*L,int i,ElemType *e)
int k:
if(L->length-=o)
/线性表为空*/
returnERROR;
---
## Page 78
大语数据结构
if（iL->length）/*则除位量不正确*/
return ERROR:
+e-L->data[1-1];
if（ilength)