VM control (C)
Privacy-sensitive (P)
Read-only (R)
Build-only (B)
Virtual I/O (I)
Platform conﬁg. (L)
Sdom0
X
X
X
X
domB
X
Udom0
X
X
X
X
SD/MTSD
X
X
X
X
Table 1. Actors and operations in the privilege model. Each X
in the table denotes that the actor can perform the correspond-
ing operation.
Hardware
Sdom0
domB
Udom0
SD
MTSD
UdomU
Sdom0
domB
Udom0
SD
MTSD
L
C,R,I
C,R,I
C,R,I
C,R,I
C,R,I
B
B
B
B
I
C,P,R,I
R,I
C,P,R,I
C,P,R,I
R,I
C,P,R,I
C,P,R,I
R,I
C,P,R,I
Table 2. Actors, objects, and operations in the privilege model.
Each column denotes an actor that performs an operation,
while each row denotes the object upon which the operation
is performed. Operations are abbreviated as shown in Table 1.
(3) Read-only operations expose non-private information of a VM
to a requester, including the number of vCPUs and RAM allocation
of a VM, and the physical parameters of the host.
(4) Build-only operations include privacy-sensitive operations
and certain operations that are only used during VM initialization.
(5) Virtual I/O operations set up event channels and grant tables
to share memory and notiﬁcations in a controlled way for I/O.
(6) Platform conﬁgurations manage the physical host. Examples
of these operations include programming the interrupt controller or
clock sources.
In addition to these operations, VMMs also perform hardware de-
vice administration that assigns PCI devices and interrupts to dif-
ferent VMs. We expect that hardware device administration may
rarely be used in a dynamic cloud environment, where VM check-
pointing and migration are commonplace, and leave for future work
the inclusion of such operations in the SSC privilege model.
In SSC, Sdom0 has the privileges to perform VM control, read-
only, virtual I/O and platform operations. VM control operations al-
low VMs to be provisioned for execution on physical hardware, and
it is unreasonable to prevent Sdom0 from performing these tasks.
A malicious system administrator can misuse VM control opera-
tions to launch denial-of-service attacks, but we exclude such at-
tacks from our threat model. Sdom0 retains the privileges to access
read-only data of client VMs for elementary management opera-
tions, e.g., listing the set of VMs executing in a client meta-domain.
Sdom0 executes backend drivers for virtual devices and must there-
fore retain the privileges to perform virtual I/O operations for all
domains on the system. As discussed earlier, SSC also admits the
notion of driver domains, where device drivers execute within sep-
arate VMs [28]. In such cases, only the driver domains need to re-
tain privileges to perform virtual I/O. Finally, Sdom0 must be able
to control and conﬁgure physical hardware, and therefore retains
privileges to perform platform operations.
The domain builder (domB) performs build-only operations.
Building domains necessarily involves some operations that are cat-
egorized as privacy-sensitive, and therefore includes them. How-
ever, when domB issues a hypercall on a target domain, the hyper-
visor ﬁrst checks that the domain has not yet accrued a single cycle
(i.e., it is still being built), and allows the hypercall to succeed only
257if that is the case. This prevents domB from performing privacy-
sensitive operations on client VMs after they have been built.
Udom0 can perform privacy-sensitive and read-only operations
on VMs in its meta-domain. It can also perform limited VM control
and virtual I/O operations. Udom0 can pause/unpause and destroy
VMs in its meta-domain, but cannot control scheduling (this privi-
lege rests with Sdom0). Udom0 can perform virtual I/O operations
for UdomUs in its meta-domain. Udom0 can delegate speciﬁc priv-
ileges to SDs and MTSDs as per their requirements. A key aspect of
our privilege model is that it groups VMs by meta-domain. Opera-
tions performed by Udom0, SDs and MTSDs are restricted to their
meta-domain. While Udom0 has privileges to perform the above
operations on VMs in its meta-domain, it cannot perform VM con-
trol, privacy-sensitive, and virtual I/O operations on MTSDs exe-
cuting in its meta-domain. This is because such operations will al-
low Udom0 to breach its contract with the cloud provider (e.g., by
pausing, modifying or terminating an MTSD that the Udom0 has
agreed to execute). Table 1 and Table 2 summarize the privilege
model of SSC.
We implemented this privilege model in our prototype using the
Xen Security Modules (XSM) framework [38]. XSM places a set
of hooks in the Xen hypervisor, and is a generic framework that
can be used to implement a wide variety of security policies. Secu-
rity policies can be speciﬁed as modules that are invoked when a
hook is encountered at runtime. For example, XSM served as basis
for IBM’s sHype project, which extended Xen to enforce manda-
tory access control policies [38]. We implemented the privilege de-
scribed in this section as an XSM policy module.
Although the privilege model described above suﬃces to im-
plement a variety of services, it can possibly be reﬁned to make it
more ﬁne-grained. For example, our privilege model can currently
be used to allow or disallow an SD from inspecting UdomU mem-
ory. Once given the privilege to do so, the SD can inspect arbitrary
memory pages. However, it may also be useful to restrict the SD to
view/modify speciﬁc memory pages, e.g., on a per-process granu-
larity, or view kernel memory pages alone. We plan to explore such
extensions to the privilege model in future work.
3.5 Virtual I/O
In our SSC prototype, device drivers execute within Sdom0,
thereby requiring clients to depend on Sdom0 to perform I/O on
their behalf. Na¨ıvely entrusting Sdom0 with I/O compromises
client privacy. Our prototype protects clients via modiﬁcations to
XenStore.
In Xen, domUs discover virtual devices during bootstrap using
a service called XenStore, which runs as a daemon in dom0. Each
domU on the system has a subtree in XenStore containing its virtual
device conﬁgurations. Dom0 owns XenStore and has full access to
it, while domUs only have access to their own subtrees.
In SSC, we modiﬁed XenStore allowing domB to create sub-
trees for newly-created VMs, and give each Udom0 access to the
subtrees of all VMs in its meta-domain. Udom0 uses this privilege
to customize the virtual devices for its UdomUs. For instance, it
can conﬁgure a UdomU to use Sdom0 as the backend for virtual
I/O. Alternatively, it can conﬁgure the UdomU to use an SD as a
backend; the SD could modify the I/O stream (e.g., a storage SD;
see Figure 4). An SD can have Sdom0 as the backend, thereby ulti-
mately directing I/O to physical hardware, or can itself have an SD
as a backend, thereby allowing multiple SDs to be chained on the
path from a UdomU to the I/O device. We also modiﬁed XenStore
to allow Sdom0 and Udom0 to insert block devices into domB.
This is used to transfer kernel and ramdisk images during domain
building.
Xen traditionally uses a mechanism called grant tables for ﬁne-
grained control on virtual I/O. Grant tables are used when domUs
communicate with the backend drivers in dom0. DomU uses grant
tables to share a single page of its memory with dom0, which
redeems the grant to access the page. The hypervisor enforces any
access restrictions speciﬁed by domU, and does not even disclose
the actual page number to dom0. SSC beneﬁts from the grant tables
mechanism in allowing meta-domains to ultimately connect to and
communicate I/O payloads to their backend drivers in Sdom0. As
long as these payloads are encrypted (e.g., using an SD within the
meta-domain), client privacy is protected.
Ultimately, Sdom0 is responsible for I/O operations by com-
municating with physical hardware. Malicious Sdom0s can mis-
use this privilege to enable a number of attacks. For example,
a client’s Udom0 attaches a virtual device via a handshake with
Sdom0. Sdom0 can launch attacks by corrupting this handshake
or ﬁring spurious virtual interrupts. As long as client payloads are
encrypted, none of these attacks will breach client privacy; they
merely result in denial-of-service attacks.
A ﬁnal possibility for attack is XenStore itself. In our prototype,
XenStore resides within Sdom0, which can possibly leverage this
fact implement a variety of denial of service attacks. (Note that
even if XenStore is abused to connect client VMs to the wrong
backend, grant tables prevent client payloads from being leaked to
Sdom0). Techniques for XenStore protection have recently been
developed in the Xoar project [9], and work by factoring XenStore
into a separate domain (akin to domB). SSC can employ similar
techniques, although we have not done so in our prototype.
3.6 Regulatory Compliance using MTSDs
As previously discussed, an MTSD executes within a client meta-
domain. The MTSD can request speciﬁc privileges over client VMs
in this meta domain (via a manifest) to perform regulatory com-
pliance checks. These privileges include access to a VM’s mem-
ory pages, vCPU registers and I/O stream. For example, an MTSD
to ensure that a client VM is not executing malicious code may
request read access to the VM’s memory and registers (see Sec-
tion 4.2). The client can inspect the manifest to decide whether the
requested privileges are acceptable to it, and then start the MTSD.
The privileges requested in the manifest are directly translated into
parameters for the C MTSD hypercall. Both the client and the
provider can verify that the MTSD was started with the privileges
speciﬁed in the manifest.
Clients may wish to ensure that the MTSD’s functionality does
not compromise their privacy. For example, the client may want to
check that an MTSD that reads its VM memory pages does not in-
advertantly leak the contents of these pages. One way to achieve
this goal is to inspect the code of the MTSD to ensure the absence
of such undesirable functionality. However, we cannot reasonably
expect most cloud clients to have the economic resources to con-
duct thorough and high-quality security evaluations of MTSDs.
We therefore limit the amount of information that an MTSD
can transmit outside the meta-domain. MTSDs are not given any
persitent storage, and can only communicate with the provider
(i.e., Sdom0) via the SSC hypervisor. Further, this communica-
tion channel is restricted to be a stream of bits whose semantics
is well-understood. That is, each 0 bit in the stream denotes a vio-
lation of regulatory compliance, while a 1 bit denotes otherwise.1
The client can set up a user daemon (e.g., within Udom0) that is
awakened by the SSC hypervisor upon every new bit transmitted
by the MTSD over this channel. An honest client that does not vio-
late the provider’s regulatory compliance policies should therefore
only expect to see a stream of 1s transmitted to Sdom0. Any 0s
1 Note that a client cannot modify this stream without tampering with the code of the
MTSD. The provider ensures that the MTSD was booted correctly (Figure 3(c)), and
SSC’s privilege model prevents the client from modifying a running MTSD.
258Time (seconds)
Platform
2.131±0.011
Traditional Xen
2.144±0.012 (0%)
SSC
Table 3. Cost of building domains.
in the stream either denote an MTSD attempting to steal informa-
tion, or an inadvertant compliance violation (e.g., due to malware
infection). In either case, the client can terminate its meta-domain.
4. EVALUATION
In evaluating our SSC prototype, our main goals were:
(1) To demonstrate the ﬂexibility of the SSC model in enabling
various virtualization-based services as SDs; and
(2) To compare the performance of these SD-based services
against their traditional, dom0-based counterparts.
Our experiments were performed on a Dell Poweredge R610
system equipped with 24GB RAM, eight 2.3GHz Xeon cores with
dual threads (16 concurrent executions), Fusion-MPT SAS drives,
and a Broadcom NetXtreme II gigabit NIC. All virtual machines
started in our experiments (dom0, domU, Sdom0, Udom0, UdomU,
SDs and domB) were conﬁgured to have 2GB RAM and 2 virtual
CPUs. The experimental numbers reported in this section are aver-
aged over ﬁve executions; we also report standard deviations.
In SSC, all VM creation requests are communicated to domB.
DomB neither has any persistent state nor does it require a ﬁle
system. During startup, domB prepares XenStore devices that are
necessary for block interface communication between domB and
other control VMs; it does not require any other I/O devices. Kernel
images and the initial ramdisk along with the conﬁguration of the
VM to be created are presented to domB as a virtual disk via