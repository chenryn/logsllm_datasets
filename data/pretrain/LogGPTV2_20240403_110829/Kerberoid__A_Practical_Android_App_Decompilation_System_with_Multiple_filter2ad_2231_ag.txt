to assume that one has access to a set of inputs with known
outputs for the reversed program. They may be used as a test
suite. The challenge with this approach is the granularity of
the oracle provided by test cases. For meta decompilation to
work, the granularity of the oracle needs to be ﬁner or equal
to the one of transplantation. In this work, we use ecj errors
as we are able to map them to code fragments. This allows
us to label a fragment as correct and incorrect.
Another oracle can be based on the bytecode distance
between the decompiled-then-recompiled fragment and its
original bytecode counterpart. This could be considered as a
heuristic to minimize the likelihood of semantic diﬀerences
between both fragments. In this work we measure bytecode
distance with JarDiff, but SootDiff [5] could also be
used, as its authors announce that it tolerates some control
ﬂow graph equivalent transformation.
Furthermore, depending on the metric that a decompi-
ler user favours, the order of the decompilers used through
meta decompilation may change. In this work we rank de-
compilers according to the number of classes for which they
produce semantically equivalent modulo inputs sources. If
a user favours the rate of deceptive decompilation to be as
low as possible, CFR could be put ﬁrst. Inverting the order
of Procyon and CFR for Arlecchino, on the 157 classes pre-
sented in Section 4.5, yields only 38 decompiled classes that
are semantically equivalent modulo inputs. But it produces
only 4 deceptive decompilations.
Highlights about meta-decompilation: To summarize,
we have devised and implemented a novel approach to
merge results from diﬀerent decompilers, called meta-
decompilation. This tool handles 59 of the 157 cases
(37.6%) previously not handled by any decompiler.
Meta-decompilationis,toourknowledge,aradicallynew
idea that has never been explored before. Our experi-
mentsdemonstrate thefeasibility andeﬀectiveness ofthe
idea.
6. Threats to Validity
liability threats against the validity of our results.
In this section, we report about internal, external and re-
Internal validity. The internal threats are related to the
metrics employed, especially those used to compare the syn-
tacticdistortionandsemanticequivalencemoduloinputsbe-
tween the original and decompiled source code. Moreover,
thecoverageandqualityofthetestsuiteoftheprojectsunder
study inﬂuences our observations about the semantic equiv-
alence of the decompiled bytecode. To mitigate this threat,
we select a set of mature open-source projects with good test
suites as study subjects, and rely on state-of-the-art AST and
bytecode diﬀerencing tools.
External validity. The external threats refer to what extent
the results obtained with the studied decompilers can be
generalized to other Java projects. To mitigate this threat,
we reuse an existing dataset of Java programs which we
believe is representative of the Java world. Moreover, we
added a handmade project which is a collection of classes
used in previous decompilers evaluations as a baseline for
further comparisons.
Reliability validity. Our results are reproducible,
the
experimental pipeline presented in this study is publicly
available online. We provide all necessary code to repli-
cate our analysis, including AST metric calculations and
statistical analysis via R notebooks.14
7. Related work
This paper is related to previous works on bytecode
analysis, decompilation and program transformations.
In
this section, we present the related work on Java bytecode
decompilers along these lines.
Kerbedroid[18]istheclosestrelatedwork. Theworkfo-
cuses on decompilers for Android and starts from the same
observation as ours: decompilers perform diﬀerently with
varying applications due to the various strategies to han-
dle information lost in compilation. Kerbedroid is a meta-
decompiler that stitches together results from multiple de-
compilers. Our current work shares the same observation,
while contributing two key novel points. We perform an in-
depth assessment of the diﬀerent strategies implemented in
8 decompilers, with respect to three quality attributes, in-
cluding equivalence modulo-input to compare the behavior
of decompiled bytecode. Arlecchino leverages the partial re-
sults from 8 decompilers instead of 3 for Kerbedroid, which
increases the coverage of various corner cases in the byte-
code.
Theevaluationofdecompilersiscloselyrelatedtotheas-
sessment of compilers. In particular, Le et al. [25] introduce
the concept of semantic equivalence modulo inputs to vali-
date compilers by analyzing the interplay between dynamic
execution on a subset of inputs and statically compiling a
program to work on all kind of inputs. Blackburn et al. [3]
propose a set of benchmarking selection and evaluation
methodologies, and introduces the DaCapo benchmarks, a
14
https://github.com/castor-software/decompilercmp/
tree/master/notebooks
Harrand et al.: Preprint submitted to Elsevier
Page 17 of 19
Java Decompiler Diversity and its Application to Meta-decompilation
set of open source, client-side Java benchmarks. Naeem et
al. [30] propose a set of software quality metrics aimed at
measuring the eﬀectiveness of decompilers and obfuscators.
In2009, Hamiltonetal.[15]showthatdecompilationispos-
sible for Java, though not perfect. In 2017, Kostelansky et
al. [23] perform a similar study on updated decompilers. In
2018, Gusarovs [14] performed a study on ﬁve Java decom-
pilers by analyzing their performance according to diﬀerent
handcrafted test cases. All those works demonstrate that
Java bytecode decompilation is far from perfect.
Decompilers are disassemblers are closely related, and
each pair of binary format, target language poses speciﬁc
challenges (see Vinciguerra et al. [44] for C++, Khadra et
al. [22] for ThumbISA, Grech et al. [13] for Ethereum byte-
code). With dissassembling, types must be reconstructing
[41], as well as assignment chains [43]. As we do in this pa-
per, some researchers focus on reassembling disassembled
binary code [45, 8, 10].
Arecenttrendindecompilationistouseneuralnetworks
[21,26,12]. Forexample,Katzetal.[21]presentatechnique
for decompiling binary code snippets using a model based
on Recurrent Neural Networks, which produces source code
that is more similar to human-written code and therefore
more easy for humans to understand. This a remarkable at-
tempt at driving decompilation towards a speciﬁc goal. La-
comis et al. [24] propose a probabilistic technique for vari-
able name recovery. Schulte et al. [36] use evolutionary
searchtoimproveandrecombinealargepopulationofcandi-
date decompilations by applying source-to-source transfor-
mations gathered from a database of human-written sources.
Miller and colleagues [29] model the uncertainty due to the
information loss during compilation using probabilities and
propose a novel disassembly technique, which computes a
probability for each address in the code space, indicating its
likelihood of being a true positive instruction.
8. Conclusion
In this work, we presented a fully automated pipeline to
assess Java bytecode decompilers with respect to their ca-
pacity to produce compilable, equivalent modulo-input, and
readable code. We assessed eight decompilers with a set of
2041 classes from 14 open-source projects compiled with
two diﬀerent compilers. The results of our analysis show
that bytecode decompilation is a non-trivial task that still re-
quires human work. Indeed, even the highest ranking de-
compiler in this study produces syntactically correct output
for 84% of classes of our dataset and semantically equiva-
lent modulo inputs output for 78%. We extract 157 classes
for which no decompiler produces semantically equivalent
sources. These classes illustrate how generics and, in partic-
ular, genericwithwildcardsandtypeboundsarechallenging
for all decompilers. Yet the Java language with its diver-
sity of compilers and versions makes room for many corner
cases that require extensive testing and development eﬀort
from decompilers authors. Meanwhile, the diversity of im-
plementation of these decompilers allows to merge their dif-
ferentresultstobypasstheshortcomingsofsingledecompil-
ers. We called this approach ‘meta decompilation‘ and im-
plemented it in a tool called Arlecchino. Our experimental
results show that Arlecchino can produce semantic equiva-
lence modulo inputs sources for 37.6% of classes for which,
previously, no single decompiler could.
Acknowledgments
This work has been partially supported by the Wallen-
berg Autonomous Systems and Software Program (WASP)
funded by Knut and Alice Wallenberg Foundation and by
the TrustFull project funded by the Swedish Foundation for
Strategic Research.
References
[1] Amin, N., Tate, R., 2016. Java and scala’s type systems are unsound:
The existential crisis of null pointers, in: Proceedings of the 2016
ACM SIGPLAN International Conference on Object-Oriented Pro-
gramming, Systems, Languages, and Applications, Association for
Computing Machinery, New York, NY, USA. p. 838–848. URL:
https://doi.org/10.1145/2983990.2984004, doi:10.1145/
2983990.2984004.
[2] Benﬁeld, L., 2019. CFR. https://www.benf.org/other/cfr/.
[Online; accessed 19-July-2019].
[3] Blackburn, S.M., Garner, R., Hoﬀmann, C., Khang, A.M., McKin-
ley, K.S., Bentzur, R., Diwan, A., Feinberg, D., Frampton, D., Guyer,
S.Z., Hirzel, M., Hosking, A., Jump, M., Lee, H., Moss, J.E.B.,
Phansalkar, A., Stefanovik, D., VanDrunen, T., von Dincklage, D.,
Wiedermann, B., 2006. The dacapo benchmarks: Java benchmarking
development and analysis, in: Proceedings of the 21st Annual ACM
SIGPLAN Conference on Object-Oriented Programming Systems,
Languages, and Applications, Association for Computing Machinery,
New York, NY, USA. p. 169–190. URL: https://doi.org/10.
1145/1167473.1167488, doi:10.1145/1167473.1167488.
[4] Chen, Y., Jiang, Y., Ma, F., Liang, J., Wang, M., Zhou, C.,
Su, Z.,
EnFuzz: Ensemble Fuzzing with
arXiv e-prints ,
Seed Synchronization among Diverse Fuzzers.
arXiv:1807.00182arXiv:1807.00182.
[5] Dann, A., Hermann, B., Bodden, E., 2019. Sootdiﬀ: Bytecode
comparison across diﬀerent java compilers, in: Proceedings of the
8th ACM SIGPLAN International Workshop on State Of the Art
in Program Analysis, Association for Computing Machinery, New
York, NY, USA. p. 14–19. URL: https://doi.org/10.1145/
3315568.3329966, doi:10.1145/3315568.3329966.
https://http://
[Online; accessed 19-July-
java-decompiler.github.io/.
2019].
[7] 
urﬁna, L., Koustek, J., Zemek, P., 2013. PsybOt Malware: A Step-
By-Step Decompilation Case Study, in: 20th Working Conference on
Reverse Engineering (WCRE), pp. 449–456. doi:10.1109/WCRE.
2013.6671321.
[8] Emamdoost, N., Sharma, V., Byun, T., McCamant, S., 2019. Binary
mutation analysis of tests using reassembleable disassembly. doi:10.
14722/bar.2019.23058.
[9] Falleri, J.R., Morandat, F., Blanc, X., Martinez, M., Monperrus, M.,
2014. Fine-grained and Accurate Source Code Diﬀerencing, in: 29th
InternationalConferenceonAutomatedSoftwareEngineering(ASE),
ACM, New York, NY, USA. pp. 313–324. URL: http://doi.
acm.org/10.1145/2642937.2642982, doi:10.1145/2642937.
2642982.
[10] Flores-Montoya, A., Schulte, E.M., 2019. Datalog disassembly.
CoRR abs/1906.03969. URL: http://arxiv.org/abs/1906.
03969, arXiv:1906.03969.
[6] Dupuy, E., 2019.
Jiao, X., 2018.
Java Decompiler.
Harrand et al.: Preprint submitted to Elsevier
Page 18 of 19
Java Decompiler Diversity and its Application to Meta-decompilation
[11] Foster, B., Somayaji, A., 2010. Object-level recombination of com-
modity applications, in: Proceedings of the 12th annual conference
on Genetic and evolutionary computation, pp. 957–964.
[12] Fu, C., Chen, H., Liu, H., Chen, X., Tian, Y., Koushanfar, F., Zhao, J.,
2019. Coda: Anend-to-endneuralprogramdecompiler,in: Advances
in Neural Information Processing Systems, pp. 3703–3714.
[13] Grech, N., Brent, L., Scholz, B., Smaragdakis, Y., 2019. Gigahorse:
thorough, declarative decompilation of smart contracts, in: Interna-
tional Conference on Software Engineering, IEEE. pp. 1176–1186.
[14] Gusarovs, K., 2018. An Analysis on Java Programming Language
Decompiler Capabilities. Applied Computer Systems 23, 109–117.
[15] Hamilton, J., Danicic, S., 2009. An Evaluation of Current Java Byte-
code Decompilers, in: 9th IEEE International Working Conference
on Source Code Analysis and Manipulation (SCAM), pp. 129–136.
doi:10.1109/SCAM.2009.24.
[16] Hoenicke, J., 2019. JODE. http://jode.sourceforge.net/.
[Online; accessed 19-July-2019].
[17] Jaﬀe, A., Lacomis, J., Schwartz, E.J., Goues, C.L., Vasilescu,
B., 2018. Meaningful Variable Names for Decompiled Code:
A Machine Translation Approach,
in: 26th Conference on Pro-
gram Comprehension (ICPC), ACM, New York, NY, USA. pp. 20–
30. URL: http://doi.acm.org/10.1145/3196321.3196330,
doi:10.1145/3196321.3196330.
[18] Jang, H., Jin, B., Hyun, S., Kim, H., 2019. Kerberoid: A practi-
cal android app decompilation system with multiple decompilers, in:
Proceedingsof the2019 ACMSIGSACConference onComputer and
Communications Security, pp. 2557–2559.
[19] Jerome Miecznikowski, Nomair A. Naeem, L.J.H., 2019. Dava.
http://www.sable.mcgill.ca/dava/.
[Online; accessed 19-
July-2019].
[20] JetBrains,
Fernﬂower.
2019.
https://github.com/
JetBrains/intellij-community/tree/master/plugins/
java-decompiler/engine. [Online; accessed 19-July-2019].
[21] Katz, D.S., Ruchti, J., Schulte, E., 2018. Using Recurrent Neural
Networks for Decompilation, in: 25th International Conference on
Software Analysis, Evolution and Reengineering (SANER), pp. 346–
356. doi:10.1109/SANER.2018.8330222.
[22] Khadra, M.A.B., Stoﬀel, D., Kunz, W., 2016. Speculative disassem-
bly of binary code, in: International Conference on Compliers, Ar-
chitectures, and Sythesis of Embedded Systems (CASES), pp. 1–10.
doi:10.1145/2968455.2968505.
[23] Kostelanský, J., Dedera, L., 2017. AnEvaluationofOutputfromCur-
rent Java Bytecode Decompilers: Is it Android Which is Responsible
for Such Quality Boost?, in: Communication and Information Tech-
nologies (KIT), pp. 1–6. doi:10.23919/KIT.2017.8109451.
[24] Lacomis,J.,Yin,P.,Schwartz,E.J.,Allamanis,M.,Goues,C.L.,Neu-
big, G., Vasilescu, B., 2019. Dire: A neural approach to decompiled
identiﬁer naming. arXiv:1909.09029.
[25] Le, V., Afshari, M., Su, Z., 2014. Compiler Validation via Equiva-
lenceModuloInputs, in: 35thConferenceonProgrammingLanguage
Design and Implementation (PLDI), ACM, New York, NY, USA.
pp. 216–226. URL: http://doi.acm.org/10.1145/2594291.
2594334, doi:10.1145/2594291.2594334.
[26] Li, Z., Wu, Q., Qian, K., 2019. Adabot: Fault-TolerantJavaDecompi-
ler. Technical Report 1908.06748. arXiv.
[27] Lindholm, T., Yellin, F., Bracha, G., Buckley, A., 2014. The Java
Virtual Machine Speciﬁcation. Pearson Education.
[28] Miecznikowski, J., Hendren, L., 2002. Decompiling Java Bytecode:
Problems,TrapsandPitfalls,in: Horspool,R.N.(Ed.),CompilerCon-
struction, Springer Berlin Heidelberg, Berlin, Heidelberg. pp. 111–
127.
[29] Miller, K., Kwon, Y., Sun, Y., Zhang, Z., Zhang, X., Lin, Z., 2019.
Probabilistic disassembly, in: 2019 IEEE/ACM 41st International
Conference on Software Engineering (ICSE), IEEE. pp. 1187–1198.
[30] Naeem, N.A., Batchelder, M., Hendren, L., 2007. Metrics for Mea-
suring the Eﬀectiveness of Decompilers and Obfuscators, in: 15th
IEEE International Conference on Program Comprehension (ICPC),
pp. 253–258. doi:10.1109/ICPC.2007.27.
[31] Nolan, G., 2004. DecompilerDesign.Apress, Berkeley, CA. pp.121–
157. URL: https://doi.org/10.1007/978-1-4302-0739-9_
5, doi:10.1007/978-1-4302-0739-9_5.
[32] Pawlak, R., Monperrus, M., Petitprez, N., Noguera, C., Seinturier,
L., 2015. Spoon: A Library for Implementing Analyses and Trans-
formations of Java Source Code. Software: Practice and Experience
46, 1155–1179. URL: https://hal.archives-ouvertes.fr/
hal-01078532/document, doi:10.1002/spe.2346.
[33] Persaud, B., Obada-Obieh, B., Mansourzadeh, N., Moni, A., So-
mayaji, A., 2016. Frankenssl: Recombining cryptographic libraries
forsoftwarediversity,in: Proceedingsofthe11thAnnualSymposium
On Information Assurance., pp. 19–25.
[34] Ragkhitwetsagul, C., Krinke, J., 2017. Using Compilation/Decompi-
lation to Enhance Clone Detection, in: 11th International Workshop
on Software Clones (IWSC), pp. 1–7. doi:10.1109/IWSC.2017.
7880502.
[35] Robles,G.,Gonzalez-Barahona,J.M.,Herraiz,I.,2005. AnEmpirical
ApproachtoSoftwareArchaeology,in: 21stInternationalConference
on Software Maintenance (ICSM), pp. 47–50.
[36] Schulte, E., Ruchti, J., Noonan, M., Ciarletta, D., Loginov, A., 2018.
Evolving exact decompilation, in: Shoshitaishvili, Y., Wang, R.F.
(Eds.),WorkshoponBinaryAnalysisResearch,SanDiego,CA,USA.
URL: http://www.cs.unm.edu/~eschulte/data/bed.pdf.
[37] Selberg, E., Etzioni, O., 1997. The metacrawler architecture for re-
source aggregation on the web.
IEEE Expert 12, 11–14. doi:10.
1109/64.577468.
[38] skylot, 2019. JADX. https://github.com/skylot/jadx. [On-
line; accessed 19-July-2019].
[39] Storyyeller,
2019.
Storyyeller/Krakatau. [Online; accessed 19-July-2019].
[40] Strobel, M., 2019.
https://bitbucket.org/
mstrobel/procyon. [Online; accessed 19-July-2019].
[41] Troshina, K., Derevenets, Y., Chernov, A., 2010. Reconstruction of
Composite Types for Decompilation, in: 10th IEEE Working Confer-
ence on Source Code Analysis and Manipulation (SCAM), pp. 179–
188. doi:10.1109/SCAM.2010.24.
[42] Vallée-Rai, R., Co, P., Gagnon, E., Hendren, L., Lam, P., Sundaresan,
V., 1999. Soot - a java bytecode optimization framework, in: Pro-
ceedings of the 1999 Conference of the Centre for Advanced Studies
on Collaborative Research, IBM Press. p. 13.
[43] Van Emmerik, M.J., 2007. Static Single Assignment for Decompila-
tion. University of Queensland.
[44] Vinciguerra, L., Wills, L., Kejriwal, N., Martino, P., Vinciguerra,
R., 2003. An Experimentation Framework for Evaluating Disassem-
bly and Decompilation Tools for C++ and Java, in: 10th Working
Conference on Reverse Engineering (WCRE), IEEE Computer Soci-
ety, Washington, DC, USA. pp. 14–. URL: http://dl.acm.org/
citation.cfm?id=950792.951361.
[45] Wang,S.,Wang,P.,Wu,D.,2015. Reassembleabledisassembling,in:
24thUSENIXSecuritySymposium(USENIXSecurity15), USENIX
Association, Washington, D.C.. pp. 627–642.
URL: https:
//www.usenix.org/conference/usenixsecurity15/
technical-sessions/presentation/wang-shuai.
[46] Yakdan, K., Dechand, S., Gerhards-Padilla, E., Smith, M., 2016.
Helping Johnny to Analyze Malware: A Usability-Optimized De-
compiler and Malware Analysis User Study, in: IEEE Symposium on
SecurityandPrivacy(SP),pp.158–177. doi:10.1109/SP.2016.18.
[47] Yang, Y., Zhou, Y., Sun, H., Su, Z., Zuo, Z., Xu, L., Xu, B., 2019.
Hunting for Bugs in Code Coverage Tools via Randomized Diﬀeren-
tial Testing, in: 41st International Conference on Software Engineer-
ing (ICSE), ACM.
Krakatau.
Procyon.
https://github.com/
Harrand et al.: Preprint submitted to Elsevier
Page 19 of 19