142KB
141KB
145KB
42.7% 167KB
57.6%
61.0%
41.1%
79.8%
60.8%
60.1%
40.5%
77.7%
49.5%
60.4%
65.2%
48.1%
top
eog
gzip
213KB
174KB
166KB
200KB
206KB
121KB
169KB
212KB
158KB
216KB
57.1% 245KB
61.7%
286KB
257KB
247KB
215KB
222KB
143KB
168KB
230KB
215KB
233KB
177KB
59.7% 297KB
Name
Injectso
Cymothoa v1
Cymothoa v2
Cymothoa v3
Cymothoa v4
Hotpatch
Xlibtrace
Hijacker
Infelf v1
Infelf v2
Arches
Elf-infector
ERESI
KBeast
Sebek
Adore-ng
Infection Method
Online infection: Shared object injection
Online infection: Fork process
Online infection: Clone thread
Online infection: Settimer parasite
Online infection: Signal/Alarm parasite
Online infection: Library injection
Online infection: $LD PRELOAD linker
Online infection: Global offset table poisoning
Ofﬂine binary infection
Ofﬂine binary infection
Ofﬂine binary infection
Ofﬂine binary infection
Ofﬂine binary infection
Kernel rootkit
Kernel rootkit
Kernel rootkit
Payload
UDP server
Bind /bin/sh to TCP port and fork shell
Bind /bin/sh to TCP port and fork shell
Remote ﬁle sniffer
Single process backdoor
File writing of injecting timestamp
Tracking function invocation
Redirection of library function
Remote shell server
Register dumping
Register dumping
Register dumping
UDP server
File/Process hiding, keystroke sniffer
Conﬁdential data collection
File/Process hiding
Note
Case study I
Recover sys fork and TCP server
Recover sys clone and TCP server
Recover sys settimer and signal handler
Case study II
Recover injection and ﬁle writing procedure
Recover tty procedures on terminal
Recover the procedure of hijacking
Recover remote shell socket operations
Case study III
Recover register dumping operations on terminal
Same as above
Recover creation of udp server
Case study IV
Recover kernel code in sebek module
Recover kernel code in adore-ng module
Table II: Results of Security Evaluation Against a Spectrum of User/Kernel Malware
code sections (e.g., bind executes a kernel code path from
sys bind to release sock 4 in chronological order).
We test the system again and apply the “union” kernel
view, which includes both top and some network applica-
tions (such as Firefox and Apache) – to represent a system-
wide minimization technique. These network applications
require the same kernel networking code as the UDP server
payload, and thus this case results in no UDP related kernel
functions being recovered. Due to the enlarged attack surface
of the system-wide minimized kernel,
this attack would
achieve its goal with the available kernel code and thus go
undetected.
Case Study II – Cymothoa: Cymothoa [11] is a shell-
code injection framework that uses different infection meth-
ods and payload types. The parasite executable coexists with
the host process stealthily while the host process continues to
work properly. We test all four working parasites introduced
in the article “Single Process Parasite” [12] in Phrack issue
68 and successfully reveal all four attack behaviors. The
parasite uses the sys fork and sys clone system calls to
create a child process/thread to execute its payload. Later
variants are more stealthy, utilizing settimer and signal to
schedule the shellcode inside the host process. Here, we give
a detailed description of the most stealthy (variant 4) para-
site’s control ﬂow. This variant creates a backdoor parasite
4Symbols of kernel functions are not necessary for backtracking. We use
them here for clear demonstration.
living within another process (bash is the target program
in this case). First the shellcode registers a signal handler
for the SIGALRM signal. Then it opens a nonblocking I/O
socket, binds it to a speciﬁc port, and sets the SIGALRM
timer. When the SIGALRM signal is handled, the parasite
accepts any connection on the socket and launches a remote
shell. The parent then sets the timer again and resumes
execution of the host process.
Again, the kernel code executed by the shellcode’s ac-
tions, e.g., setting the signal handler, creating the TCP
server, and setting the alarm clock are recorded in the kernel
recovery log. This reveals both the infection method and
payload behaviors of the stealthy parasite. Also, like before,
existing kernel minimization techniques may fail to detect
this attack entirely because other applications will likely add
these kernel regions into the union-based minimized kernel.
Case Study III – Infelf: In addition to runtime infection
malware, we also apply our techniques to detect compro-
mised applications. Infelf [13] is an ofﬂine binary infection
tool that is able to implant trojan code into an existing
binary program. It splits trojan code into multiple instruction
blocks,
inserts them into free alignment areas between
functions, and concatenates their execution path with jump
instructions. We use this tool to implant a hardware register
printing function into the gvim binary and redirect gvim’s
entry function to this shellcode. During gvim’s startup,
FACE-CHANGE recovers numerous TTY kernel functions
498
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 08:20:50 UTC from IEEE Xplore.  Restrictions apply. 
0xc03566d0 
0xc03566d0 
|-- 0xc0355ce6 
|-- 0xc0355ce6 
|-- 0xc0355f7a 
|-- 0xc0355f7a 
|-- 0xf8078bbe 
|-- 0xf8078bbe 
|-- 0xc01033ec 
|-- 0xc01033ec 
0xc02173d0 
0xc02173d0 
|-- 0xf8078edc 
|-- 0xf8078edc 
|-- 0xc01033ec 
|-- 0xc01033ec 
1
2
3
0xc02cdfa0 
0xc02cdfa0 
|-- 0xc02a5f8c 
|-- 0xc02a5f8c 
|-- 0xc028d3f0 
|-- 0xc028d3f0 
|-- 0xc0228db1 
|-- 0xc0228db1 
|-- 0xc021e575 
|-- 0xc021e575 
|-- 0xc01cd908 
|-- 0xc01cd908 
|-- 0xc01cdcb7 
|-- 0xc01cdcb7 
|-- 0xc0287401 
|-- 0xc0287401 
|-- 0xc020a014 
|-- 0xc020a014 
|-- 0xf80787a5 
|-- 0xf80787a5 
|-- 0xf8078edc 
|-- 0xf8078edc 
|-- 0xc01033ec 
|-- 0xc01033ec 
Figure 5: Attack Pattern of KBeast Rootkit
which are not included in gvim’s kernel view. Again, in this
case, a whole-system kernel minimization technique would
be unable to detect this attack on a system containing both
gvim and terminal applications that require the kernel’s TTY
functions (such as tcpdump or bash).
Case Study IV – KBeast Rootkit: In addition to user-
level attacks, our system is also able to detect rootkit attacks
at the kernel level. Because rootkit attacks originate from
shellcode in kernel space, the interpretation of kernel re-
covery logs is different from user-level attacks. Kernel-level
attacks aim to hide their malicious behavior by detouring
the kernel’s control ﬂow during execution of certain kernel
routines (e.g., listing kernel modules, network connections,
etc.). Again, we assume that no rootkit is present during
the initial proﬁling phase, and so no rootkit code can be
included in the kernel view conﬁguration ﬁles. When FACE-
CHANGE allocates a new kernel view,
if a rootkit has
already been installed in the runtime system’s kernel, the
rootkit’s code will not be loaded into the new view and
will be ﬁlled with UD2 by default. If the application later
triggers FACE-CHANGE’S code recovery, the log will allow
us to clearly see where the hijack took place. A more
complicated scenario that FACE-CHANGE can detect is a
rootkit which is installed while FACE-CHANGE is enforcing
an application’s kernel view. In this scenario, the rootkit will
be detected in the same way as user-level malware: by the
kernel functionality that it requests to perform its malicious
functionalities. Again, this code will be recovered and we
can backtrace recovered kernel code to reveal the anomalous
execution.
We use the KBeast [14] rootkit as an example to show
this process in detail. KBeast is a new rootkit that inherits
many features from traditional Linux kernel rootkits (e.g.,
ﬁle/process/socket/module hiding, keystroke sniffer) and it
supports recent kernel versions. We use the kernel view for
the bash program to detect the existence of KBeast. All
the keystrokes typed in bash are processed by the keyboard
event handler. KBeast
is able to intercept and read the
keystrokes and store this data into a hidden ﬁle, and it
will hide its existence by removing itself from the kernel
module list. In Figure 5, by backtracking the recovered
kernel functions, we ﬁnd code addresses with an UNKNOWN
tag. This indicates that these memory addresses are not in
any identiﬁed memory regions. We also ﬁnd that KBeast’s
Figure 6: Normalized System Performance Results from
UnixBench
code hijacks the entries of some system calls and invokes
strnlen to check the length of the keystroke buffer, ﬁlp open
to open the hidden ﬁle, and do sync write to write the
keystroke data into this ﬁle.
B. Performance Evaluation
1) System Performance: We use the UnixBench bench-
mark suite to measure and evaluate system performance.
Speciﬁcally, we take three different measurements:
(i) We run UnixBench without enabling FACE-CHANGE
to get a baseline result.
(ii) We enable FACE-CHANGE,
load one kernel view
(Apache), and run the benchmark. This tests whole-
system performance overhead after enabling our sys-
tem.
(iii) Next, we launch the applications5 from Table I and
load their kernel views one at a time. After each
kernel view is loaded, we rerun the benchmark. This
measures any performance inﬂuence on the whole
system after loading multiple kernel views.
In Figure 6, we normalize the performance scores of the
UnixBench (higher performance score indicates better per-
formance) based on the baseline score from step 1. The
X axis represents the number of kernel views we enabled
simultaneously. We ﬁnd that, compared to the baseline
result, enabling our system incurs 5%∼7% performance
overhead on the whole system. Adding multiple kernel views
incurs trivial impact on the system performance. We ﬁnd
that the only performance degradation occurs during the
subtest Pipe-based Context Switching of UnixBench. This
is not surprising because FACE-CHANGE triggers additional
traps for each context switch. We could largely minimize
the performance overhead with optimization of the context
switch handler’s code.
5We exclude gzip here because it is not a long running application
(i.e. it is difﬁcult to ensure it executes during the entire benchmarking
measurement).
499
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 08:20:50 UTC from IEEE Xplore.  Restrictions apply. 
For example, suppose a web server is compromised and
a parasite command-and-control(C&C) server is installed.
If this C&C server uses only kernel functionalities that
are within the kernel view of the host web server, FACE-
CHANGE does not need to recover any missing kernel code
and it would be impossible for us to detect its existence in
this case. This problem may require a deeper understanding
and ﬁner-grained proﬁling of the semantic behaviors of
each application. In addition to recording an application’s
kernel usage in the proﬁling phase, we also need to proﬁle
the application’s behavior, speciﬁcally its interactions with
the kernel. Thereby we can classify the malicious behavior
during the runtime phase if it violates the application’s
known behaviors.