                    );
            }
    }
可以看到这里对于我们传入的$address做了一个正则匹配，如果正则不匹配的话，就会throw出错误信息，导致运行的程序运行的中止。那么结合我们上面所说的，这个步骤是在上传文件完成之后，删除文件之前执行的，如果这个步骤出了错，那么就不会对上传文件进行删除。那么我们上传的文件就存活了下来。
那么怎样让这个正则匹配失效呢？
可以看到这个正则匹配是验证你是否是有效的邮箱地址，如果不是有效的邮箱地址就会报错，那么我们传入一个错误的邮箱地址的话，就会报错了。但是这里我们不这么“简单”的做，我们搞一点有意思的事情。
我们首先看一下我们参数传入的地方：
在/framework/modules/ecommerce/controllers/eventregistrationController.php中第1149行：
    $email_addy = array_flip(array_flip($this->params['email_addresses']));
    $email_addy = array_map('trim', $email_addy);
    $email_addy = array_filter($email_addy);
这里的$email_addy是我们可控的。用户正常的输入的话，这个地方$this->params['email_addresses']应该是一个数组，然后后面的一切都能正规的运行下去，不会出错，但是！！！如果这个地方我们不传入数组会怎么样？正如大家知道的，array_flip()是对数组进行操作的，但是如果我们给它传入一个字符串的话，那么结果会返回一个null，意思就是说现在$email_addy=NULL。然后我们看到将$email_addy带入到了quickBatchSend函数中去:
    $mail->quickBatchSend(array(
                 'headers'=>$headers,
                    'html_message'=> $this->params['email_message'],
                    'text_message'=> strip_tags(str_replace("", "", $this->params['email_message'])),
                    'to'          => $email_addy,
                    'from'        => $from,
                    'subject'     => $this->params['email_subject']
            ));
在quickBatchSend中又对$email_addy做了处理：
          if (is_array($params['to'])) {
               $params['to'] = array_filter($params['to']);
           } else {
               $params['to'] = array(trim($params['to']));
           }
           if (empty($params['to'])) {
               $params['to'] = array(trim(SMTP_FROMADDRESS)); // default address is ours
           }
            $this->addTo($params['to']);  // we only do this to save addresses in our object
首先会判断是否是数组，如果不是的话，就变成一个数组。我们知道开始$Params[‘to’]为NULL，经过强行转换之后现在的$param[‘to’]就是array(0=>””)，接下来的判断很有意思，:
    if (empty($params['to']))
你觉得是true还是false呢？很多人认为会是ture，但是实际上是false。因为这个数组不是空数组，它有一个元素啊！！，虽然只是一个空字符串，但是它还是有元素啊，所以数组不为空，这个条件不成立。也就不会有赋值默认邮箱的操作：
    $params['to'] = array(trim(SMTP_FROMADDRESS)); // default address is ours
然后将$params[‘to’]传递给了addTo函数，我们看一下addTo函数是怎样处理$params[‘to’]的：
    public function addTo($email = null) {
            // attempt to fix a bad to address
            if (is_array($email)) {
                foreach ($email as $address=>$name) {
                    if (is_integer($address)) {
                        if (strstr($name,'.') === false) {
                            $email[$address] .= $name.'.net';
                        }
                    }
                }
            } else {
                if (strstr($email,'.') === false) {
                    $email .= '.net';
                }
            }
            $this->to = $email;
            if (!empty($email)) {
                $this->message->setTo($email);
里经过处理后，$email的值为array(1) { [0]=> string(4) ".net" }。然后传递给了setTo做操作：
    public function setTo($addresses, $name = null)
        {   
            if (!is_array($addresses) && isset($name)) {
                $addresses = array($addresses => $name);
            }
            if (!$this->_setHeaderFieldModel('To', (array) $addresses)) {
                $this->getHeaders()->addMailboxHeader('To', (array) $addresses);
            }
            return $this;
    }
将参数传递给了addMailboxHeader，我们看一下该函数的操作：
    public function addMailboxHeader($name, $addresses = null)
        {
            $this->_storeHeader($name,
            $this->_factory->createMailboxHeader($name, $addresses));
    }
又将$address给了createMailboxHeader函数，我们继续看操作：
       public function createMailboxHeader($name, $addresses = null)
        {
            $header = new Swift_Mime_Headers_MailboxHeader($name, $this->_encoder, $this->_grammar);
            if (isset($addresses)) {
                $header->setFieldBodyModel($addresses);
            }
            $this->_setHeaderCharset($header);
            return $header;
        }
又给了setFieldbodyModel函数，我们继续看：
    public function setFieldBodyModel($model)
        {
            $this->setNameAddresses($model);
    }
又给了setNameAddresses函数，我们继续追踪该函数：
    public function setNameAddresses($mailboxes)
        {
            $this->_mailboxes = $this->normalizeMailboxes((array) $mailboxes);
            $this->setCachedValue(null); //Clear any cached value
    }
又给了normalizeMailboxes函数：
    protected function normalizeMailboxes(array $mailboxes)
        {
            $actualMailboxes = array();
            foreach ($mailboxes as $key => $value) {
                if (is_string($key)) {
                    //key is email addr
                    $address = $key;
                    $name = $value;
                } else {
                    $address = $value;
                    $name = null;
                }
                $this->_assertValidAddress($address);
                $actualMailboxes[$address] = $name;
            }
            return $actualMailboxes;
    }
经过这个函数处理之后，$address变成了字符串’.net’。然后将这个字符串给了_assertValidAddress做一个正则匹配是不是有效邮箱:
    private function _assertValidAddress($address)
        {
            if (!preg_match('/^'.$this->getGrammar()->getDefinition('addr-spec').'$/D',
                $address)) {
                throw new Swift_RfcComplianceException(
                    'Address in mailbox given ['.$address.
                    '] does not comply with RFC 2822, 3.6.2.'
                    );
            }
    }
很显然，’.net’并不能与之相匹配，所以就抛出了一个错误。
导致程序的终止运行，也导致了程序的文件删除操作无法执行。
但是我们开始说了文件名的命名规则是time()+’_’+文件名。
那么我们如何知道time()呢？
在/framework/modules/ecommerce/controllers/eventregistrationController.php中第129行：
      function eventsCalendar() {
            global $user;
            expHistory::set('viewable', $this->params);
            $time = isset($this->params['time']) ? $this->params['time'] : time();
            assign_to_template(array(
                'time' => $time
            ));
这里直接将time()打印到了网站源码里，我们可以从这个地方得到一个大概的time值，然后便可以进行一个爆破文件名的操作，这样我们就能够getshell。
漏洞利用：
以程序官网为例
构造一个上传表单:
    Filename:
然后选择我们的php文件，文件名为index.php：
然后点击上传之后，可以看到报错了:
这个时候我们紧接着快速的访问
[www.exponentcms.org/index.php?module=eventregistration&action=eventsCalendar](http://www.exponentcms.org/index.php?module=eventregistration&action=eventsCalendar)
然后右键查看网页源代码找到rel:
记下这个数字，这就是大概的时间戳，我们爆破文件名需要用到的。
然后我们开始爆破文件名：
/tmp/时间戳_index.php
因为我们得到的时间戳比上传的时间戳要晚一些时间(所以说越快访问越好)，但是爆破的位数基本可以控制在3位数以内。
然后我们就可以用burpsuite进行一个爆破文件名的操作：
Status为200表示我们成功爆破到了文件名，我们访问一下，可以看到php文件确实成功上传：