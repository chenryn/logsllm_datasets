# Linux 内核 DirtyPipe 任意只读文件覆写漏洞（CVE-2022-0847）分析
##### 译文声明
本文是翻译文章
译文仅供参考，具体内容表达以及含义原文为准。
作者：Nitro[@360GearTeam](https://github.com/GearTeam "@GearTeam")
## 简介
2022 年 3 月 7 日，据一位国外开发者披露[^1](https://dirtypipe.cm4all.com/)，Linux
内核存在一个文件任意覆写漏洞，低权限用户可以利用此漏洞覆写本没有写权限的文件。由于这个漏洞是基于 Linux 的管道（pipe）形成的，因此被命名为
Dirty Pipe。漏洞的发现过程挺有意思的，可以参考发现者写的文章（见文末“参考资料”部分）。
漏洞形成原因：
使用 `splice(2)` [^5](https://man7.org/linux/man-pages/man2/splice.2.html)系统调用从一个只读文件向一个管道[^6](https://man7.org/linux/man-pages/man2/pipe.2.html)中传输数据时，会使管道用于保存数据的缓冲区共享文件的 page cache。由于
`PIPE_BUF_FLAG_CAN_MERGE` 标志位的存在，调用 `splice(2)` 之后再向管道中写入数据时，写入的数据会直接写到文件的
page cache 中。
漏洞危害：低权限用户可利用此漏洞向本没有写权限的文件中写入数据，进而实现提权。
CVE 编号： **CVE-2022-0847** 。
漏洞评分：7.8。
影响版本：
  * 根据作者的描述， **5.8** 以上的内核均受影响。在 **5.16.11** 、 **5.15.25** 、 **5.10.102** 版本中被修复。
  * 根据 Red Hat 官方通告[^2](https://access.redhat.com/security/cve/cve-2022-0847) ,[^3](https://access.redhat.com/security/vulnerabilities/RHSB-2022-002)，目前还没有发布已修复的内核软件包。受影响的 Red Hat 版本有： 
    * 使用 `redhat-virtualization-host` 内核的 `Red Hat Virtualization 4`。
    * 使用 `kernel-rt` 或 `kernel` 内核软件包的 `Red Hat Enterprise Linux 8`。
  * 根据 Debian 的官方通告[^4](https://security-tracker.debian.org/tracker/CVE-2022-0847)，已修复的内核版本号为： 
    * `stretch` ：`4.9.228-1`。
    * `stretch (security)`：`4.9.303-1`。
    * `buster`：`4.19.208-1`。
    * `buster (security)`：`4.19.232-1`。
    * `bullseye`：`5.10.84-1`。注：这是受影响的版本。官方通告中没有说明修复的版本号。
    * `bullseye (security)`：`5.10.103-1`。
    * `bookworm`：`5.16.11-1`。
    * `sid`：`5.16.12-1`。
修复方法：根据使用的发行版，关注官方的漏洞通告并升级内核到已修复的版本。
## 漏洞分析过程
漏洞的利用过程与 Linux 管道和 `splice(2)` 系统调用的实现机制有关，因此当了解了二者的实现机制后，就很容易理解漏洞的形成原因。
因此漏洞分析过程分两部分：第一部分结合内核源码介绍管道和 `splice(2)` 的实现原理，第二部分通过运行 PoC
并动态调试内核，来实际体验并验证漏洞的触发过程。如果已经了解先导知识中所讲的内容，可直接跳到“漏洞复现”部分。
文中的源码分析基于 `5.10` 版本。“调试验证”部分基于 `5.11` 版本。
###  先导知识[^9](https://book.douban.com/subject/4843567//)
####  pipe 实现机制
首先给出一张描述 pipe
相关内核数据结构之间关系的图[^7](https://lwn.net/Articles/118750/)、[^8](https://www.slideshare.net/divyekapoor/linux-kernel-implementation-of-pipes-and-fifos)：
####  创建 pipe
创建 pipe 的系统调用有两个：`pipe(2)` 和 `pipe2(2)`，原型为：
    #include 
    int pipe(int pipefd[2]);
    int pipe2(int pipefd[2], int flags);
系统调用的定义在 `/fs/pipe.c`
（[https://elixir.bootlin.com/linux/v5.10/source/fs/pipe.c#L1008）](https://elixir.bootlin.com/linux/v5.10/source/fs/pipe.c#L1008%EF%BC%89)  
文件中：
    SYSCALL_DEFINE2(pipe2, int __user *, fildes, int, flags)
    {
        return do_pipe2(fildes, flags);
    }
    SYSCALL_DEFINE1(pipe, int __user *, fildes)
    {
        return do_pipe2(fildes, 0);
    }
两个系统调用的入口都是 `do_pipe2()`
（[https://elixir.bootlin.com/linux/v5.10/source/fs/pipe.c#L986）](https://elixir.bootlin.com/linux/v5.10/source/fs/pipe.c#L986%EF%BC%89)  
函数。这个函数的功能是：
  * 调用 `__do_pipe_flags()` 函数创建两个 `struct file` 结构体实例和两个对应的文件描述符。
  * 调用 `copy_to_user()` 函数将两个文件描述符拷贝给系统调用参数 `pipefd`。
  * 调用 `fd_install()` 函数将文件描述符和 `struct file` 结构体实例关联起来。
#####  __do_pipe_flags()
再看 `__do_pipe_flags()`
（[https://elixir.bootlin.com/linux/v5.10/source/fs/pipe.c#L936）](https://elixir.bootlin.com/linux/v5.10/source/fs/pipe.c#L936%EF%BC%89)  
函数。函数原型为：
    static int __do_pipe_flags(int *fd, struct file **files, int flags);
第一个参数 `fd` 用于保存创建的两个文件描述符，第二个参数用于保存创建的两个 `struct file` 结构体实例，第三个参数是系统调用参数
`flags` 的值。
`__do_pipe_flags()` 函数的工作为：
  * 检查非法的标志位组合。
  * 调用 `create_pipe_files()` 函数创建两个 `struct file` 结构体实例。
  * 调用两次 `get_unused_fd_flags()` 函数创建两个文件描述符。
  * 调用 `audit_fd_pair()` 函数处理审计相关的工作。
#####  create_pipe_files()
再看 `create_pipe_files()`
函数（[https://elixir.bootlin.com/linux/v5.10/source/fs/pipe.c#L893）。](https://elixir.bootlin.com/linux/v5.10/source/fs/pipe.c#L893%EF%BC%89%E3%80%82)  
函数的用途是根据传入的标志位创建两个 `struct file` 结构体实例。流程为：
  * 调用 `get_pipe_inode()` 函数创建一个 inode 实例。
  * 如果标志位设置了 `O_NOTIFICATION_PIPE` 位，则初始化一个 watch 队列。
  * 调用 `alloc_file_pseudo()` 函数创建一个 `strcut file` 实例，并将 `private_data` 字段的值设置为 `inode->i_pipe` 的值。
  * 调用 `alloc_file_clone()` 函数拷贝一个 `struct file` 实例，同样将其 `private_data` 字段的值设置为 `inode->i_pipe` 的值。
  * 调用 `stream_open()` 函数打开两个文件。
#####  get_pipe_inode()
接下来看看 `get_pipe_inode()` 函数是如何创建 inode 实例的。
  * 调用 `new_inode_pseudo()` 函数创建一个 inode 实例。
  * 调用 `alloc_pipe_info()` 函数创建一个 `pipe_inode_info` 实例。
  * 设置 inode 实例的以下字段： 
    * `inode->i_pipe` 设置为 `pipe` 实例指针。
    * `inode->i_fop` 设置为 `pipefifo_fops` 变量的指针。
    * `inode->i_state` 设置为 `I_DIRTY`。
    * `inode->i_mode` 设置为 `S_IFIFO | S_IRUSR | S_IWUSR`。
    * `inode->i_uid` 设置为 `fsuid`，`inode->i_gid` 设置为 `fsgid`。
    * `inode->i_atime`、`inode->i_mtime`、`inode->i_ctime` 均设置为当前时间。
#####  关键的内核数据结构
这里涉及到第一个关键的结构体 `struct
pipe_inode_info`（[https://elixir.bootlin.com/linux/v5.10/source/include/linux/pipe_fs_i.h#L57），](https://elixir.bootlin.com/linux/v5.10/source/include/linux/pipe_fs_i.h#L57%EF%BC%89%EF%BC%8C)  
内核使用这个结构体来描述一个 pipe：
    /**
     *    struct pipe_inode_info - a linux kernel pipe
     *    @mutex: mutex protecting the whole thing
     *    @rd_wait: reader wait point in case of empty pipe
     *    @wr_wait: writer wait point in case of full pipe
     *    @head: The point of buffer production
     *    @tail: The point of buffer consumption
     *    @note_loss: The next read() should insert a data-lost message
     *    @max_usage: The maximum number of slots that may be used in the ring
     *    @ring_size: total number of buffers (should be a power of 2)
     *    @nr_accounted: The amount this pipe accounts for in user->pipe_bufs
     *    @tmp_page: cached released page
     *    @readers: number of current readers of this pipe
     *    @writers: number of current writers of this pipe
     *    @files: number of struct file referring this pipe (protected by ->i_lock)
     *    @r_counter: reader counter
     *    @w_counter: writer counter
     *    @fasync_readers: reader side fasync
     *    @fasync_writers: writer side fasync
     *    @bufs: the circular array of pipe buffers
     *    @user: the user who created this pipe
     *    @watch_queue: If this pipe is a watch_queue, this is the stuff for that
     **/
    struct pipe_inode_info {
        struct mutex mutex;
        wait_queue_head_t rd_wait, wr_wait;
        unsigned int head;
        unsigned int tail;
        unsigned int max_usage;
        unsigned int ring_size;
    #ifdef CONFIG_WATCH_QUEUE
        bool note_loss;
    #endif
        unsigned int nr_accounted;
        unsigned int readers;
        unsigned int writers;
        unsigned int files;
        unsigned int r_counter;
        unsigned int w_counter;
        struct page *tmp_page;
        struct fasync_struct *fasync_readers;
        struct fasync_struct *fasync_writers;
        struct pipe_buffer *bufs;
        struct user_struct *user;
    #ifdef CONFIG_WATCH_QUEUE
        struct watch_queue *watch_queue;
    #endif
    };
pipe 中的数据保存在结构体 `pipe_buffer`
（[https://elixir.bootlin.com/linux/v5.10/source/include/linux/pipe_fs_i.h#L26）中的](https://elixir.bootlin.com/linux/v5.10/source/include/linux/pipe_fs_i.h#L26%EF%BC%89%E4%B8%AD%E7%9A%84)
`page` 字段：
    /**
     *    struct pipe_buffer - a linux kernel pipe buffer
     *    @page: the page containing the data for the pipe buffer
     *    @offset: offset of data inside the @page
     *    @len: length of data inside the @page
     *    @ops: operations associated with this buffer. See @pipe_buf_operations.
     *    @flags: pipe buffer flags. See above.
     *    @private: private data owned by the ops.
     **/
    struct pipe_buffer {
        struct page *page;
        unsigned int offset, len;
        const struct pipe_buf_operations *ops;
        unsigned int flags;
        unsigned long private;
    };
顺便看看 `alloc_pipe_info()` 函数是怎样初始化 `pipe_inode_info` 结构体的。
  * 使用 `kzalloc` 函数创建一个 `pipe_inode_info` 实例。`kzalloc` 函数与 `kmalloc` 类似，只不过会初始化分配的内存。
  * 根据用户是否有 `CAP_SYS_RESOURCE` 权限决定 pipe 缓冲区的大小，并保存在 `pipe_bufs` 变量里。缓冲区的大小以页为单位。非 root 用户可以将缓冲区大小扩展为最大 `1048576` 个字节，保存在 `pipe_max_size` 变量中。可以通过 `/proc/sys/fs/pipe-max-size` 调整这个值。默认大小为 `PIPE_DEF_BUFFERS` （16）个内存页。
  * 检查当前用户是否创建了过多的 pipe。
  * 调用 `kcalloc` 函数为 `pipe_inode_info` 结构体的 `bufs` 字段分配内存。`kcalloc` 与 `kzalloc` 类似，只不过是分配连续若干个指定大小的内存块。
  * 初始化 `pipe_buffer` 中的其它成员： 
    * 初始化读写队列。
    * 将读者和写者的数量初始化为 1。
    * pipe 的最大可使用量、缓冲区大小、记账个数都初始化为 `pipe_bufs` 变量的值。
    * 设置用户为当前用户。
    * 初始化互斥锁。
####  读写 pipe
上文中提到的 `pipefifo_fops` 是一个 `struct file_operations` 类型的常量，表示 pipe
文件支持的文件操作有哪些，以及保存了对应操作的函数指针：
    const struct file_operations pipefifo_fops = {
        .open        = fifo_open,
        .llseek        = no_llseek,
        .read_iter    = pipe_read,
        .write_iter    = pipe_write,
        .poll        = pipe_poll,
        .unlocked_ioctl    = pipe_ioctl,
        .release    = pipe_release,
        .fasync        = pipe_fasync,
    };
在上面 `create_pipe_files()` 函数中，会将 `file` 结构体实例的 `f_op` 字段设置成 `pipefifo_fops`
结构体的指针。用户态执行上面支持的系统调用时，VFS 会调用结构体中相应的函数。
    ssize_t vfs_write(struct file *file, const char __user *buf, size_t count, loff_t *pos)
    {
      ...
        if (file->f_op->write)
            ret = file->f_op->write(file, buf, count, pos);
        else if (file->f_op->write_iter)
            ret = new_sync_write(file, buf, count, pos);
      ...
    }
以 `write(2)` 系统调用为例，进入系统调用入口之后，实际会调用 `vfs_write()` 函数。而 pipe 支持 `write_iter`
而不是 `write`，因此会接着执行 `new_sync_write()`:
    static ssize_t new_sync_write(struct file *filp, const char __user *buf, size_t len, loff_t *ppos)
    {
        struct iovec iov = { .iov_base = (void __user *)buf, .iov_len = len };
        struct kiocb kiocb;
        struct iov_iter iter;
        ssize_t ret;
        init_sync_kiocb(&kiocb, filp);
        kiocb.ki_pos = (ppos ? *ppos : 0);
        iov_iter_init(&iter, WRITE, &iov, 1, len);
        ret = call_write_iter(filp, &kiocb, &iter);
        BUG_ON(ret == -EIOCBQUEUED);