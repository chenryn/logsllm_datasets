aborts,
the aborting party will be ﬁnancially penalized
while the remaining parties receive compensation. As is
well-known in the cryptography literature, such fairness
guarantees are not attainable in general by off-chain only
protocols such as secure multi-party computation [7], [17].
As explained later, Hawk offers built-in mechanisms for
enforcing refunds of private bids after certain timeouts.
Hawk also allows the programmer to deﬁne additional rules,
841841
as part of the Hawk contract, that govern ﬁnancial fairness.
• Security against a dishonest manager. We ensure authen-
ticity against a dishonest manager: besides aborting, a dis-
honest manager cannot affect the outcome of the auction
and the redistribution of money, even when it colludes with
a subset of the users. We stress that to ensure the above,
input independent privacy against a faulty manager is a
prerequisite. Moreover, if the manager aborts, it can be
ﬁnancially penalized, and the participants obtain correspond-
ing remuneration.
An auction with the above security and privacy requirements
cannot be trivially implemented atop existing cryptocurrency
systems such as Ethereum [57] or Zerocash [11]. The former
allows for programmability but does not guarantee transac-
tional privacy, while the latter guarantees transactional privacy
but at the price of even reduced programmability than Bitcoin.
Aborting and timeouts. Aborting is dealt with using timeouts.
A Hawk program such as Figure 2 declares timeout parame-
ters using the HawkDeclareTimeouts special syntax. Three
timeouts are declared where T1 < T2 < T3:
T1 : The Hawk contract stops collecting bids after T1.
T2 : All users should have opened their bids to the manager
within T2; if a user submitted a bid but fails to open by T2,
its input bid is treated as 0 (and any other potential input
data treated as ⊥), such that the manager can continue.
T3 : If the manager aborts, users can reclaim their private bids
after time T3.
The public Hawk contract φpub can additionally implement
incentive structures. Our sealed auction program redistributes
the manager’s public deposit if it aborts. Speciﬁcally, in our
sealed auction program, φpub deﬁnes two functions, namely
check and managerTimeOut. The check function will be in-
voked when the Hawk contract completes execution within T3,
i.e., manager did not abort. Otherwise, if the Hawk contract
does not complete execution within T3, the managerTimeOut
function will be invoked. We remark that although not explic-
itly written in the code, all Hawk contracts have an implicit
default entry point for accepting parties’ deposits – these
deposits are withheld by the contract till they are redistributed
by the contract. Bidders should check that the manager has
made a public deposit before submitting their bids.
Additional applications. Besides the sealed auction example,
Hawk supports various other applications. We give more
sample programs in Section VI-B.
C. Contributions
To the best of our knowledge, Hawk is the ﬁrst to simulta-
neously offer transactional privacy and programmability in a
decentralized cryptocurrency system.
Formal models for decentralized smart contracts. We are
among the ﬁrst ones to initiate a formal, academic treatment
of the blockchain model of cryptography. We present a formal,
Universal Composability (UC) model for the blockchain model
of cryptography – this formal model is of independent interest,
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:16:41 UTC from IEEE Xplore.  Restrictions apply. 
and can be useful in general for deﬁning and modeling the
security of protocols in the blockchain model. Our formal
model has also been adopted by the Gyges work [35] in
designing criminal smart contracts.
In deﬁning for formal blockchain model, we rely on a notion
called wrappers to modularize our protocol design and to sim-
plify presentation. Wrappers handle a set of common details
such as timers, pseudonyms, global ledgers in a centralized
place such that they need not be repeated in every protocol.
New cryptography suite. We implement a new cryptography
suite that binds private transactions with programmable logic.
Our protocol suite contains three essential primitives freeze,
compute, and finalize. The freeze primitive allows parties
to commit to not only normal data, but also coins. Committed
coins are frozen in the contract, and the payout distribution will
later be determined by the program φpriv. During compute,
parties open their committed data and currency to the manager,
such that the manager can compute the function φpriv. Based on
the outcome of φpriv, the manager now constructs new private
coins to be paid to each recipient. The manager then submits
to the blockchain both the new private coins as well as zero-
knowledge proofs of their well-formedness. At this moment,
the previously frozen coins are now redistributed among the
users. Our protocol suite strictly generalizes Zerocash since
Zerocash implements only private money transfers between
users without programmability.
We deﬁne the security of our primitives using ideal func-
tionalities, and formally prove security of our constructions
under a simulation-based paradigm.
Implementation and evaluation. We built a Hawk prototype
and evaluated its performance by implementing several ex-
ample applications, including a sealed-bid auction, a “rock,
paper, scissors” game, a crowdfunding application, and a
swap ﬁnancial instrument. We propose interesting protocol
optimizations that gained us a factor of 10× in performance
relative to a straightforward implementation. We show that
for at about 100 parties (e.g., auction and crowdfunding), the
manager’s cryptographic computation (the most expensive part
of the protocol) is under 2.85min using 4 cores, translating
to under $0.14 of EC2 time. Further, all on-chain computation
(performed by all miners) is very cheap, and under 20ms for
all cases. We will open source our Hawk framework in the
near future.
D. Background and Related Work
1) Background: The original Bitcoin offers limited pro-
grammability through a scripting language that
is neither
Turing-complete nor user friendly. Numerous previous endeav-
ors at creating smart contract-like applications atop Bitcoin
(e.g., lottery [7], [17], micropayments [4],veriﬁable computa-
tion [40]) have demonstrated the difﬁculty of in retroﬁtting
Bitcoin’s scripting language – this serves well to motivate a
Turing-complete, user-friendly smart contract language.
Ethereum is the ﬁrst Turing-complete decentralized smart
contract system. With Ethereum’s imminent launch, companies
and hobbyists are already building numerous smart contract
applications either atop Ethereum or by forking off Ethereum,
such as prediction markets [3], supply chain provenance [6],
crowd-based fundraising [1], and security and derivatives
trading [28].
Security of the blockchain. Like earlier works that design
smart contract applications for cryptocurrencies, we rely on the
underlying decentralized blockchain to be secure. Therefore,
we assume the blockchain’s consensus protocol attains security
when an adversary does not wield a large fraction of the com-
putational power. Existing cryptocurrencies are designed with
heuristic security. On one hand, researchers have identiﬁed
attacks on various aspects of the system [29], [34]; on the
other, efforts to formally understand the security of blockchain
consensus have begun [32], [45].
Minimizing on-chain costs. Since every miner will execute
the smart contract programs while verifying each transaction,
cryptocurrencies including Bitcoin and Ethereum collect trans-
action fees that roughly correlate with the cost of execution.
While we do not explicitly model such fees, we design our
protocols to minimize on-chain costs by performing most of
the heavy-weight computation off-chain.
2) Additional Related Works: Leveraging blockchain for
ﬁnancial fairness. A few prior works have explored how to
leverage the blockchain technology to achieve fairness in pro-
tocol design. For example, Bentov et al. [17], Andrychowicz
et al. [7], Kumaresan et al. [40], Kiayias et al. [36], as well
as Zyskind et al. [59], show how Bitcoin can be used to
ensure fairness in secure multi-party computation protocols.
These protocols also perform off-chain secure computation
of various types, but do not guarantee transactional privacy
(i.e., hiding the currency ﬂows and amounts transacted). For
example, it is not clear how to implement our sealed auction
example using these earlier techniques. Second, these earlier
works either do not offer system implementations or provide
implementations only for speciﬁc applications (e.g., lottery). In
comparison, Hawk provides a generic platform such that non-
specialist programmers can easily develop privacy-preserving
smart contracts.
Smart contracts. The conceptual idea of programmable elec-
tronic “smart contracts” dates back nearly twenty years [53].
Besides recent decentralized cryptocurrencies, which guaran-
tee authenticity but not privacy, other smart contract imple-
mentations rely on trusted servers for security [46]. Our work
therefore comes closest to realizing the original vision of
parties interacting with a trustworthy “virtual computer” that
executes programs involving money and data.
Programming frameworks for cryptography. Several works
have developed programming frameworks that take in high-
level programs as speciﬁcations and generate cryptographic
implementations, including compilers for secure multi-party
computation [19], [39], [41], [51], authenticated data struc-
tures [44], and (zero-knowledge) proofs [12], [30], [31], [49].
Zheng et al. show how to generate secure distributed protocols
such as sealed auctions, battleship games, and banking applica-
tions [58]. These works support various notions of security, but
842842
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:16:41 UTC from IEEE Xplore.  Restrictions apply. 
none of them interact directly with money or leverage public
blockchains for ensuring ﬁnancial fairness. Thus our work
is among the ﬁrst to combine the “correct-by-construction”
cryptography approach with smart contracts.
Concurrent work. Our framework is the ﬁrst to provide a
full-ﬂedged formal model for decentralized blockchains as
embodied by Bitcoin, Ethereum, and many other popular
decentralized cryptocurrencies. In concurrent and independent
work, Kiayias et al. [36] also propose a blockchain model
in the (Generalized) Universal Composability framework [23]
and use it
to derive results that are similar to what we
describe in the online version [37], i.e., fair MPC with public
deposits. However, the “programmability” of their formalism
is limited to their speciﬁc application (i.e., fair MPC with
public deposits). In comparison, our formalism is designed
with much broader goals, i.e., to facilitate protocol designers
to design a rich class of protocols in the blockchain model. In
particular, both our real-world wrapper (Figure 11) and ideal-
world wrapper (Figure 10) model the presence of arbitrary user
deﬁned contract programs, which interact with both parties and
the ledger. Our formalism has also been adopted by the Gyges
work [35] demonstrating its broad usefulness.
II. THE BLOCKCHAIN MODEL OF CRYPTOGRAPHY
A. The Blockchain Model
We begin by informally describing the trust model and
assumptions. We then propose a formal framework for the
“blockchain model of cryptography” for specifying and rea-
soning about the security of protocols.
In this paper, the blockchain refers to a decentralized set
of miners who run a secure consensus protocol to agree upon
the global state. We therefore will regard the blockchain as a
conceptual trusted party who is trusted for correctness and
availability, but not trusted for privacy. The blockchain
not only maintains a global ledger that stores the balance for
every pseudonym, but also executes user-deﬁned programs.
More speciﬁcally, we make the following assumptions:
• Time. The blockchain is aware of a discrete clock that
increments in rounds. We use the terms rounds and epochs
interchangeably.
• Public state. All parties can observe the state of the block-
chain. This means that all parties can observe the public
ledger on the blockchain, as well as the state of any user-
deﬁned blockchain program (part of a contract protocol).
• Message delivery. Messages sent to the blockchain will
arrive at
the beginning of the next round. A network
adversary may arbitrarily reorder messages that are sent
to the blockchain within the same round. This means that
the adversary may attempt a front-running attack (also
referred to as the rushing adversary by cryptographers), e.g.,
upon observing that an honest user is trading a stock, the
adversary preempts by sending a race transaction trading the
same stock. Our protocols should be proven secure despite
such adversarial message delivery schedules.
We assume that all parties have a reliable channel to the
blockchain, and the adversary cannot drop messages a party
sends to the blockchain. In reality, this means that the
overlay network must have sufﬁcient redundancy. However,
an adversary can drop messages delivered between parties
off the blockchain.
• Pseudonyms. Users can make up an unbounded polynomial
number of pseudonyms when communicating with the
blockchain.
• Correctness and availability. We assume that the blockchain
will perform any prescribed computation correctly. We also
assume that the blockchain is always available.
Advantages of a generic blockchain model. We adopt
a generic blockchain model where the blockchain can run
arbitrary Turing-complete programs. In comparison, previous
and concurrent works [7], [17], [40], [50] retroﬁt the artifacts
of Bitcoin’s limited and hard-to-use scripting language. In
Section VII and the online version [37], we present additional
theoretical results demonstrating that our generic blockchain
model yields asymptotically more efﬁcient cryptographic pro-
tocols.
B. Formally Modeling the Blockchain
Our paper adopts a carefully designed notational system
such that readers may understand our constructions without
understanding the precise details of our formal modeling.
We stress, however, that we give formal, precise speciﬁ-
cations of both functionality and security, and our protocols
are formally proven secure under the Universal Composability
(UC) framework. In doing so, we make a separate contribution
of independent interest: we are the ﬁrst to propose a formal,
UC-based framework for describing and proving the security
of distributed protocols that interact with a blockchain —
we refer to our formal model as “the blockchain model of
cryptography”.
Programs, wrappers, and functionalities. In the remainder
of the paper, we will describe ideal speciﬁcations, as well
as pieces of the protocol executed by the blockchain, the
users, and the manager respectively as programs written in
pseudocode. We refer to them as the ideal program (denoted
Ideal), the blockchain program (denoted B or Blockchain), and
the user/manager program (denoted UserP) respectively.
All of our pseudo-code style programs have precise mean-
ings in the UC framework. To “compile” a program to a
UC-style functionality or protocol, we apply a wrapper to
a program. Speciﬁcally, we deﬁne the following types of
wrappers:
• The ideal wrapper F(·) transforms an ideal program IdealP
into a UC ideal functionality F(IdealP).
• The blockchain wrapper G(·) transforms a blockchain pro-
gram B to a blockchain functionality G(B). The blockchain
functionality G(B) models the program executing on the
blockchain.
• The protocol wrapper Π(·) transforms a user/manager
program UserP into a user-side or manager-side protocol
Π(UserP).
One important reason for having wrappers is that wrappers im-
plement a set of common features needed by every smart con-
843843
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:16:41 UTC from IEEE Xplore.  Restrictions apply. 
tract application, including time, public ledger, pseudonyms,
and adversarial reordering of messages — in this way, we
need not repeat this notation for every blockchain application.
We defer our formal UC modeling to Appendix B. This will
not hinder the reader in understanding our protocols as long
as the reader intuitively understands our blockchain model and
assumptions described in Section II-A. Before we describe our
protocols, we deﬁne some notational conventions for writing
“programs”. Readers who are interested in the details of our
formal model and proofs can refer to Appendix B.
C. Conventions for Writing Programs
take place immediately, but
Our wrapper-based system modularizes notation, and allows
us to use a set of simple conventions for writing user-deﬁned
ideal programs, blockchain programs, and user protocols. We
describe these conventions below.
Timer activation points. The ideal functionality wrapper
F(·) and the blockchain wrapper G(·) implement a clock that
advances in rounds. Every time the clock is advanced, the
wrappers will invoke the Timer activation point. Therefore,
by convention, we allow the ideal program or the blockchain
program can deﬁne a Timer activation point. Timeout oper-
ations (e.g., refunding money after a certain timeout) can be
implemented under the Timer activation point.