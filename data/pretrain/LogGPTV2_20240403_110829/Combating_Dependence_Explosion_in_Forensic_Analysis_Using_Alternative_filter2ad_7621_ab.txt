we present effective detection techniques using provenance tags,
and in particular, a prioritized approach for tag propagation. Our
technique is not only accurate on ccleaner, but also other stealthy
attacks, including those that use in-memory payloads, browser
extensions, and in one instance, kernel-resident malware.
The challenges faced in scenario reconstruction are even more
formidable. Because of intermixing of benign and attack activities,
a forward analysis starting at the ccleaner process yields a
graph with tens of thousands of nodes, illustrating the effect of
dependence explosion. Existing forensic analysis techniques that
rely on coarse-grained provenance are ill-equipped to deal with
this explosion. Specifically, SLEUTH’s [30] approach of cost-based
pruning of forward paths is helpful, but the resulting graph still
contains over 3000 nodes. This is at least an order of magnitude
larger than what can be visualized and understood by an analyst.
HOLMES [57] copes with dependence explosion by looking
for and linking together the steps in a typical APT life-cycle,
including initial compromise, privilege escalation, internal recon,
lateral movement, exfiltration and clean-up. Although HOLMES can
cope with a few missing phases, ccleaner poses a stiff challenge,
as it exercises just a single APT stage (initial compromise).
NODOZE [29] prioritizes anomalous information flows to reduce
the size of the graph generated by forward analysis. Unfortunately,
the flows manifested by malicious ccleaner program are similar to
those of benign ccleaner. This can make it difficult to ensure that
malware activities are faithfully captured in the output. Moreover,
flows created by the backup process share similarities with the
malware, making it difficult to prune out this benign background
activity. PRIOTRACKER’s [51] isn’t directly aimed at constructing
a compact scenario graph, but instead, it aims to include as much of
attack activity as possible within a given amount of analysis time.
Their use of event rareness can prioritize edges from ccleaner
malware, but because many of the files read by the backup process
are also new, those benign reads have to be prioritized as well.
1141
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 10:02:08 UTC from IEEE Xplore.  Restrictions apply. 
40 ﬁlesbashloadAttack Activities... ... load~bob/ccleaner~bob/.ssh/known_hosts/usr/local/bin/ssh/usr/bin/scpPipe~bob/aa.txt~bob/zz.txt~bob/aa.tkn~bob/zz.tknx.x.x.xscp -t./ccleaner./ccleanerfork+execsshd sshd dbus-launch dbus-daemon fork+exec sshd sshd sshdscp -r ~bob/*bob@bkupsrv:work/ fork+execssh bob@bkupsrv scp -r -d -t ./work/load128.55.12.117 /usr/local/etc/ssh_conﬁgfork+execfork+execBenign Activities......Event
create(s, x)
read(s, x)
write(s, x)
periodically:
Tag to
update
x.dtag
s.dtag
x.dtag
s.dtag
New tag value for different subject types
benign
min(s.dtag + ab, x.dtag)
max(s.dtag, db∗s.dtag+(1 − db)∗Tqb)
suspect
s.dtag
min(s.dtag, x.dtag)
min(s.dtag, x.dtag)
no change
suspect environment
min(s.dtag + ae, x.dtag)
max(s.dtag, de∗s.dtag+(1 − de)∗Tqe)
Table I: Propagation rules for operations on data. Here, dtag refers to the data tag. Tqb and Tqe stand for quiescent tag values for benign and suspect environment processes,
set respectively to (cid:104)0.75, 0.75(cid:105) and (cid:104)0.45, 0.45(cid:105) in our implementation. Attenuation (ab and ae) and decay rate (db and de) settings are discussed in Section VIII.
Since NODOZE and PRIOTRACKER rely on anomalous (“rare”)
events and/or anomalous information flows, sophisticated attackers
can evade them by designing their malware to match the behaviors
of benign applications. Moreover, these techniques require an exter-
nal attack detector to initiate the analysis. In contrast, we present a
tag prioritization method that automates both attack detection and
scenario graph construction, and moreover, operates in real-time.
III. Tags and Propagation
Provenance graphs faithfully capture all possible dependencies, and
hence do nothing to address dependence explosion. The core of
our approach is to develop a system of tags and propagation rules
that prioritize a subset of dependencies for attack investigation.
Our prioritization takes advantage of behaviors common to benign
applications in order to prune away dependency chains unlikely
to play a role in attacks. At the same time, it is conservative (i.e.,
assumes the worst-case behavior) in its reasoning about malicious
subjects, thus making it evasion-resistant. Key to this approach is
our method for tagging subjects as benign or malicious, a topic
covered in Table II, Sections V.B and VII. Here, we begin by
defining the subject tags used to differentiate these groups:
• suspicious code: This value indicates that the subject’s code is
• suspicious environment: This value, abbreviated as susp env,
indicates that the subject’s code is benign, but its execution was
started by a suspicious subject, which controlled the command-
line parameters and environment variables.
• benign: This tag value indicates that both the code and running
environment of a subject are benign. Benign subjects may
contain exploitable vulnerabilities, so they may be compromised
by malicious inputs.
• trusted: This tag indicates that the subject is capable of
suspect, i.e., it could be malware.
protecting itself from malicious inputs.
Unlike subject tags that are associated only with subjects, data
tags are associated with objects as well as subjects, as both contain
stored data. A data tag is a tuple (cid:104)c, i(cid:105), where:
• c is the confidentiality tag that captures data sensitivity, and
• i the integrity tag that captures data trustworthiness.
Highly confidential data needs protection from unauthorized
disclosure. Logically, we distinguish between high and low values
for confidentiality. However, since it is easier to express tag prop-
agation rules as real-valued functions, we use real values for data
tags. Note that by convention, lower numerical values correspond
to higher levels of confidentiality. Thus, secret data such as private
keys and password files should be assigned a confidentiality tag
of zero, while public information should be assigned a tag of 1.0.
Values in the range [0.0, 0.5) are considered high confidentiality,
while the range [0.5, 1.0] corresponds to low confidentiality.
1142
High integrity data is safe to consume, i.e., it won’t compromise
the subject, or otherwise enable an attacker to control its behavior.
In contrast, low integrity data may compromise a subject that
executes it. For this reason, we refer to high integrity data
(specifically, the range [0.5, 1.0]) as benign and low integrity
data (specifically, the range [0.0, 0.5)) as suspicious. Note the
convention that higher numerical values correspond to higher
levels of integrity. Thus, highly trusted data is given an integrity tag
of 1.0, while highly suspicious data will have an integrity tag close
to zero. In some contexts, it is helpful to define suspiciousness tag,
which is obtained by subtracting the integrity tag value from 1.0.
The flow of data tags within the dependence graph is modulated
by subject tags in our framework. To express these modulation rules
concisely, we extend standard arithmetic operations to data tags
as follows, where op is one of +,−,∗ or / operators. Operations
such as min and average can be extended similarly.
(cid:104)c1, i1(cid:105) op k = (cid:104)c1 op k, i1 op k(cid:105)
(cid:104)c1, i1(cid:105) op (cid:104)c2, i2(cid:105) = (cid:104)c1 op c2, i1 op i2(cid:105)
Tag Propagation Rules
Events cause data tags to propagate in the direction of information
flow. Unchecked propagation leads to a dependence explosion, so
our core idea is to use subject tags to modulate data tags flowing
through a subject. The guiding principles behind our design are:
• tag propagation should be conservative for suspect subjects,
• tag propagation should prioritize data flows that an attacker
• only benign subjects can have benign data integrity; for other
can control, while de-emphasizing other data flows.
but can be lenient for benign subjects.
subjects, data integrity is forced to be low, say, 0.45.1
Tables I and II consider the main operations that propagate tags.
Note that fork implicitly copies the parent’s tags to the child. Other
system calls such as chmod, unlink, and mprotect are security-
relevant but do not change provenance. As a result, we are left with
just the operations listed in the first column of Tables I and II. These
operations typically take two arguments s and x that represent the
subject performing the operation and the object being operated on.
The second column in the table identifies the tag that will need
to be updated as a result of the operation in the first column. The
next three columns specify, respectively, the new tag values of this
tag for benign, suspicious and suspect environment processes.
Propagation Rules for Operations on Data
The first row in Table I corresponds to object creation. The object
simply inherits the subject’s data tag in all cases. Note, however
1Suspect subjects may be malicious and hence can generate low-integrity output
even if they only consume benign input. Suspect environment subjects are spawned
by suspect subjects, so they may already hold low integrity data in their memory
(as command-line arguments, environment variables, etc.) and can output this data
even before consuming input from low-integrity objects.
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 10:02:08 UTC from IEEE Xplore.  Restrictions apply. 
Event
load(s, x)
exec(s, x)
inject(s, s(cid:48))
Tag to
update
s.stag
s.dtag
s.stag
s.dtag
s(cid:48).stag
s(cid:48).dtag
benign
x.itag
(cid:104)1.0, 1.0(cid:105)
New tag value for different subject types
suspect environment
suspect
min(s.stag, x.itag)
min(s.dtag, x.dtag)
min(x.itag, susp env)
x.itag
min(s.dtag, x.dtag)
min(s.dtag, x.dtag)
min(s(cid:48).stag, s.itag)
min(s.dtag, s(cid:48).dtag)
Table II: Propagation rules for code operations. Here, stag and dtag denote subject and data tags. The integrity component of dtag is referenced using itag.
that an empty file contains no confidential or malicious content.
Hence, for benign subjects, we delay this propagation of subject’s
tag until the first write operation. We avoid this lenient treatment
for suspicious and suspect environment subjects, so that objects
created by them will have low integrity from the very beginning.
The second row concerns a read operation. Note that if a process
reads highly confidential (or low integrity) data, this immediately
leads to the process memory holding highly confidential (or low
integrity) data. For this reason, we update the subject’s data tag to
be the minimum of its current value and the tag of the data just read.
The next row concerns the write operation, which propagates the
subject’s tag to the object being written. For suspicious processes,
this propagation is immediate, i.e., we assume that (a) the most
confidential data within process memory may be output at this
point, and (b) lowest integrity data within the process memory may
be written. This conservative treatment ensures that all outputs of
a malicious process will be treated with suspicion.
Tag attenuation for benign subjects. Note that even if a benign
subject previously read highly confidential (or low integrity) data,
an attacker cannot control whether a write operation will output such
data. To factor this, we attenuate the confidentiality and integrity
tags of a benign subject before propagating them to the object.
Recall that smaller confidentiality (or suspiciousness) corresponds
to larger tag value, so we can achieve attenuation by multiplying
by a factor f > 1. However, a multiplicative factor will have no
effect if the original tag value is zero. So, we prefer an additive
factor. We use different additive factors ab and ae for benign and
suspect environment subjects. Since an attacker is likely to have
more control over suspect environment subjects, ae < ab.
For updating the data tags of objects being written, we take
the min operation, so that the object’s tag indicates the most
confidential (and the lowest integrity) data contained within.
Tag decay for benign subjects. If a benign process is compromised
by suspicious input, then this compromise will happen soon after
input consumption. Otherwise, it is likely that the input, even though
it was deemed suspicious at first, is really benign. So capture this
intuition, we gradually lift the integrity tag to its quiescent value
by applying a decay operator. Decay is not applied to higher tag
values, thus leaving them untouched.
Tag decay is meaningful for confidentiality as well. Long-
running benign applications that use highly sensitive data, e.g.,
passwords or keys, are designed to use them quickly, and then erase
them from memory, or at least prevent them from being emitted
in their output. For simplicity, we have used the same decay rate
and quiescent value for both confidentiality and integrity tags.
As is common in modeling decays, we have used an exponential
decay function. If the decay operation is applied once for each
period t, then a tag with an initial value v0 < Tqb will change to vn
after n periods, as given by the following equation. Since db < 1.0,
vn converges to Tqb for large n.
vn = v0 ∗ dn
b + (1 − dn
b ) ∗ Tqb
This rationale for decay does not apply to suspicious processes,
so no decay operator is applied to them. For benign processes
running within a suspect environment, a decay operator can be
applied, but the rate parameter de should be larger than db, reflecting
a greater level of skepticism about their behavior in comparison
with benign processes. For the same reason, Tqe should be smaller
than Tqb. In our implementation, we have used Tqe = (cid:104)0.45, 0.45(cid:105).
Propagation Rules for Operations on Code
Table II specifies propagation rules for code-related operations.
In general, loading causes the integrity tag of loaded object to
propagate to the subject. (This is the primary means of determining
subject tags, a topic further discussed in Section VII.) For this
propagation, we treat data integrity in the range of [0.5.1.0] as
benign, while the range [0.0, 0.5) is treated as suspicious. In
addition, recall that the maximum data integrity of a subject is
bounded by its subject tag. For this reason, all operations that load
code into a subject s propagate the data integrity of the code object
to the data integrity of s. In particular, we take the min of the data
integrity of s and the code object.
Consider the load operation that is typically used to load a
library into a subject’s memory. When a benign process loads an
object, its subject tag is downgraded to suspicious if the object
has a low integrity tag; otherwise, the subject tag is left unchanged.
This behavior is captured by the min operation used to update the
subject tag of benign subjects on a load operation. The same logic
applies to suspicious as well as suspect environment subjects.
Although exec is similar to load in terms of loading new code
for execution, there are several important differences as well. In
particular, exec causes the code memory to be cleared, so we
simply overwrite the subject tag for benign code with the integrity
of the new code. Moreover, since exec causes data memory to
be cleared, we set the data tag to (cid:104)1.0, 1.0(cid:105) to indicate the absence
of confidential data, and to reset its data integrity tag to be high.
(Recall the condition that data integrity tags can never exceed the
subject tag, so, the value of the integrity tag will automatically be
reduced to that of the object just loaded.)
The above logic for updating subject tag on exec operations
applies to subjects with a suspect environment as well. In addition,
we no longer consider the process to be running in a suspect
environment since the process performing the exec isn’t suspicious.
But we do not reset the subject’s data tags, as our level of trust on
these processes are strictly less than that of benign subjects.
For exec’s by suspicious processes, the above argument for re-
placing their subject tag with that of the executable continues to hold.
However, note that since the process is starting out to be suspicious,
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 10:02:08 UTC from IEEE Xplore.  Restrictions apply. 
1143
Name
Description
Operation(s)
Data integrity
condition
MemExec
F ileExec
Inject
ChP erm
Corrupt