foreach (int number in new int[12]{10, 9, 8, 7, 7, 6, 5, 10, 4, 3, 2,
1})
{
    numbers.Add(number);
}
// Insert an element in the penultimate position in the list, and
move the last item up
// The first parameter is the position; the second parameter is the
Download from finelybook PI:EMAIL
611
value being inserted
numbers.Insert(numbers.Count-1, 99);
// Remove the first element whose value is 7 (the 4th element, index
3)
numbers.Remove(7);
// Remove the element that's now the 7th element,
numbers.RemoveAt(6);
// Iterate the remaining 11 elements using a for statement
Console.WriteLine("Iterating using a for statement:");
for (int i = 0; i 
collection is different from querying the number of items in an array.
When using a List collection, you examine the Count property;
when using an array, you examine the Length property.
The LinkedList collection class
The LinkedList collection class implements a doubly linked list. Each
item in the list holds the value for that item together with a reference to the
next item in the list (the Next property) and the previous item (the Previous
property). The item at the start of the list has the Previous property set to null,
and the item at the end of the list has the Next property set to null.
Unlike the List class, LinkedList does not support array notation
for inserting or examining elements. Instead, you can use the AddFirst
method to insert an element at the start of the list, moving the previous first
item up and setting its Previous property to refer to the new item. Similarly,
you can use the AddLast method to insert an element at the end of the list,
setting the Next property of the previously last item to refer to the new item.
You can also use the AddBefore and AddAfter methods to insert an element
before or after a specified item in the list (you have to retrieve the item first).
You can find the first item in a LinkedList collection by querying the
First property, whereas the Last property returns a reference to the final item
in the list. To iterate through a linked list, you can start at one end and step
through the Next or Previous references until you find an item with a null
value for this property. Alternatively, you can use a foreach statement, which
iterates forward through a LinkedList object and stops automatically at
the end.
You delete an item from a LinkedList collection by using the Remove,
RemoveFirst, and RemoveLast methods.
Download from finelybook PI:EMAIL
613
The following example shows a LinkedList collection in action.
Notice how the code that iterates through the list by using a for statement
steps through the Next (or Previous) references, stopping only when it
reaches a null reference, which is the end of the list:
Click here to view code image
using System;
using System.Collections.Generic;
...
LinkedList numbers = new LinkedList();
// Fill the List by using the AddFirst method
foreach (int number in new int[] { 10, 8, 6, 4, 2 })
{
    numbers.AddFirst(number);
}
// Iterate using a for statement
Console.WriteLine("Iterating using a for statement:");
for (LinkedListNode node = numbers.First; node != null; node =
node.Next)
{
    int number = node.Value;
    Console.WriteLine(number);
}
// Iterate using a foreach statement
Console.WriteLine("\nIterating using a foreach statement:");
foreach (int number in numbers)
{
    Console.WriteLine(number);
}
// Iterate backwards
Console.WriteLine("\nIterating list in reverse order:");
for (LinkedListNode node = numbers.Last; node != null; node =
node.Previous)
{
    int number = node.Value;
    Console.WriteLine(number);
}
Here is the output generated by this code:
Click here to view code image
Iterating using a for statement:
2
4
Download from finelybook PI:EMAIL
614
6
8
10
Iterating using a foreach statement:
2
4
6
8
10
Iterating list in reverse order:
10
8
6
4
2
The Queue collection class
The Queue class implements a first-in, first-out mechanism. An element
is inserted into the queue at the back (the Enqueue operation) and is removed
from the queue at the front (the Dequeue operation).
The following code is an example showing a Queue collection and
its common operations:
Click here to view code image
using System;
using System.Collections.Generic;
...
Queue numbers = new Queue();
// fill the queue
Console.WriteLine("Populating the queue:");
foreach (int number in new int[4]{9, 3, 7, 2})
{
    numbers.Enqueue(number);
    Console.WriteLine($" has joined the queue");
}
// iterate through the queue
Console.WriteLine("\nThe queue contains the following items:");
foreach (int number in numbers)
{
    Console.WriteLine(number);
}
// empty the queue
Download from finelybook PI:EMAIL
615
Console.WriteLine("\nDraining the queue:");
while (numbers.Count > 0)
{
    int number = numbers.Dequeue();
    Console.WriteLine($" has left the queue");
}
Here is the output from this code:
Click here to view code image
Populating the queue:
9 has joined the queue
3 has joined the queue
7 has joined the queue
2 has joined the queue
The queue contains the following items:
9
3
7
2
Draining the queue:
9 has left the queue
3 has left the queue
7 has left the queue
2 has left the queue
The Stack collection class
The Stack class implements a last-in, first-out mechanism. An element
joins the stack at the top (the push operation) and leaves the stack at the top
(the pop operation). To visualize this, think of a stack of dishes: new dishes
are added to the top and dishes are removed from the top, making the last
dish to be placed on the stack the first one to be removed. (The dish at the
bottom is rarely used and will inevitably require washing before you can put
any food on it—because it will be covered in grime!) Here’s an example—
notice the order in which the items are listed by the foreach loop:
Click here to view code image
using System;
using System.Collections.Generic;
...
Stack numbers = new Stack();
// fill the stack
Console.WriteLine("Pushing items onto the stack:");
Download from finelybook PI:EMAIL
616
foreach (int number in new int[4]{9, 3, 7, 2})
{
    numbers.Push(number);
    Console.WriteLine($" has been pushed on the stack");
}
// iterate through the stack
Console.WriteLine("\nThe stack now contains:");
foreach (int number in numbers)
{
    Console.WriteLine(number);
}
// empty the stack
Console.WriteLine("\nPopping items from the stack:");
while (numbers.Count > 0)
{
    int number = numbers.Pop();
    Console.WriteLine($" has been popped off the stack");
}
Here is the output from this program:
Click here to view code image
Pushing items onto the stack:
9 has been pushed on the stack
3 has been pushed on the stack
7 has been pushed on the stack
2 has been pushed on the stack
The stack now contains:
2
7
3
9
Popping items from the stack:
2 has been popped off the stack
7 has been popped off the stack
3 has been popped off the stack
9 has been popped off the stack
The Dictionary collection class
The array and List types provide a way to map an integer index to an
element. You specify an integer index within square brackets (for example,
[4]), and you get back the element at index 4 (which is actually the fifth
element). However, sometimes you might want to implement a mapping in
which the type from which you map is not an int but some other type, such as
Download from finelybook PI:EMAIL
617
string, double, or Time. In other languages, this is often called an associative
array. The Dictionary class implements this functionality by
internally maintaining two arrays, one for the keys from which you’re
mapping and one for the values to which you’re mapping. When you insert a
key/value pair into a Dictionary collection, it automatically
tracks which key belongs to which value and makes it possible for you to
retrieve the value that is associated with a specified key quickly and easily.
The design of the Dictionary class has some important
consequences:
A Dictionary collection cannot contain duplicate keys.
If you call the Add method to add a key that is already present in the
keys array, you’ll get an exception. You can, however, use the square
brackets notation to add a key/value pair (as shown in the following
example) without danger of an exception, even if the key has already
been added; any existing value with the same key will be overwritten
by the new value. You can test whether a Dictionary
collection already contains a particular key by using the ContainsKey
method.
Internally, a Dictionary collection is a sparse data
structure that operates most efficiently when it has plenty of memory
with which to work. The size of a Dictionary
collection in memory can grow quite quickly as you insert more
elements.
When you use a foreach statement to iterate through a
Dictionary collection, you get back a
KeyValuePair item. This is a structure that contains a
copy of the key and value elements of an item in the Dictionary collection, and you can access each element through the Key
property and the Value property. These elements are read-only; you
cannot use them to modify the data in the Dictionary
collection.
Here is an example that associates the ages of members of my family with
their names and then prints the information:
Click here to view code image
using System;
Download from finelybook PI:EMAIL
618
using System.Collections.Generic;
...
Dictionary ages = new Dictionary();
// fill the Dictionary
ages.Add("John", 53); // using the Add method
ages.Add("Diana", 53);
ages["James"] = 26; // using array notation
ages["Francesca"] = 23;
// iterate using a foreach statement
// the iterator generates a KeyValuePair item
Console.WriteLine("The Dictionary contains:");
foreach (KeyValuePair element in ages)
{
   string name = element.Key;
   int age = element.Value;
   Console.WriteLine($"Name: , Age: ");
}
Here is the output from this program:
Click here to view code image
The Dictionary contains:
Name: John, Age: 53
Name: Diana, Age: 53
Name: James, Age: 26
Name: Francesca, Age: 23
Note The System.Collections.Generic namespace also includes the
SortedDictionary collection type. This class maintains
the collection in order, sorted by the keys.
The SortedList collection class
The SortedList class is very similar to the Dictionary class in that you can use it to associate keys with values. The
primary difference is that the keys array is always sorted. (It is called a
SortedList, after all.) It takes longer to insert data into a SortedList object than a SortedDictionary object in most
Download from finelybook PI:EMAIL
619
cases, but data retrieval is often quicker (or at least as quick), and the
SortedList class uses less memory.
When you insert a key/value pair into a SortedList
collection, the key is inserted into the keys array at the correct index to keep
the keys array sorted. The value is then inserted into the values array at the
same index. The SortedList class automatically ensures that
keys and values remain synchronized, even when you add and remove
elements. This means that you can insert key/value pairs into a
SortedList in any sequence; they are always sorted based on
the value of the keys.
Like the Dictionary class, a SortedList
collection cannot contain duplicate keys. When you use a foreach statement
to iterate through a SortedList, you receive back a
KeyValuePair item. However, the KeyValuePair items will be returned sorted by the Key property.
Here is the same example that associates the ages of members of my
family with their names and then prints the information, but this version has
been adjusted to use a SortedList object rather than a
Dictionary collection:
Click here to view code image
using System;
using System.Collections.Generic;
...
SortedList ages = new SortedList();
// fill the SortedList
ages.Add("John", 53);    // using the Add method
ages.Add("Diana", 53);
ages["James"] = 26;      // using array notation
ages["Francesca"] = 23;
// iterate using a foreach statement
// the iterator generates a KeyValuePair item
Console.WriteLine("The SortedList contains:");
foreach (KeyValuePair element in ages)
{
    string name = element.Key;
    int age = element.Value;
    Console.WriteLine($"Name: , Age: ");
}
Download from finelybook PI:EMAIL
620
The output from this program is sorted alphabetically by the names of my
family members:
Click here to view code image
The SortedList contains:
Name: Diana, Age: 53
Name: Francesca, Age: 23
Name: James, Age: 26
Name: John, Age: 53
The HashSet collection class
The HashSet class is optimized for performing set operations, such as
determining set membership and generating the union and intersection of
sets.
You insert items into a HashSet collection by using the Add method,
and you delete items by using the Remove method. However, the real power
of the HashSet class is provided by the IntersectWith, UnionWith, and
ExceptWith methods. These methods modify a HashSet collection to
generate a new set that either intersects with, has a union with, or does not
contain the items in a specified HashSet collection. These operations are
destructive in as much as they overwrite the contents of the original
HashSet object with the new set of data. You can also determine whether
the data in one HashSet collection is a superset or subset of another by
using the IsSubsetOf, IsSupersetOf, IsProperSubsetOf, and
IsProperSupersetOf methods. These methods return a Boolean value and are
nondestructive.
Internally, a HashSet collection is held as a hash table, enabling the
fast lookup of items. However, a large HashSet collection can require a
significant amount of memory to operate quickly.
The following example shows how to populate a HashSet collection
and illustrates the use of the IntersectWith method to find data that overlaps
two sets:
Click here to view code image
using System;
using System.Collections.Generic;
...
Download from finelybook PI:EMAIL
621
HashSet employees = new HashSet(new string[]
{"Fred","Bert","Harry","John"});
HashSet customers = new HashSet(new string[]
{"John","Sid","Harry","Diana"});
employees.Add("James");
customers.Add("Francesca");
Console.WriteLine("Employees:");
foreach (string name in employees)
{
    Console.WriteLine(name);
}
Console.WriteLine("");
Console.WriteLine("Customers:");
foreach (string name in customers)
{
    Console.WriteLine(name);
}
Console.WriteLine("\nCustomers who are also employees:");
customers.IntersectWith(employees);
foreach (string name in customers)
{
    Console.WriteLine(name);
}