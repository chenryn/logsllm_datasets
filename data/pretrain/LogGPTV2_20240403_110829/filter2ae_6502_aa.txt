# 网恋选我，我撒网贼6
##### 译文声明
本文是翻译文章
译文仅供参考，具体内容表达以及含义原文为准。
## 声明
  1. 本文纯属虚构，若有雷同，纯属巧合。
  2. 本文及本人并未对任何社区进行攻击、扰乱等行为。
  3. 本文中出现的技术仅做讨论、研究之用，不以任何形式开放、出售与 APP 相关的源代码。
  4. 本文中出现的数据、代码、截图均已做脱敏处理。
## 前传
这个事情要从很久很久以前说起…
我有一个朋友，母胎单身，去年不知道从哪拱到了一棵大白菜，感觉人生到达了巅峰。
有一次，我与他相遇夜宵，凑了一局。 两杯啤酒顿顿顿下肚，只见他脸色红润，情绪激昂，只差一匹汗血宝马就可以出征长沙，血战沙场。
于是大放厥词，口出狂言道： 忆往夕，吾已鳏独二十有五载，看今朝，新春必携伴归乡探亲。
……
很可惜的是，可能是因为没有经验或者性 格不合，两人还没到过年就吹了，老死不相往来。
那几天，他悲痛欲绝，哀哀戚戚，无心工作，借酒消愁，感觉人生已经到达了低谷。
然后我去安利他看爱情公寓。 喜剧，也许能缓解一下心情。
后来突然有一天跟我说要他练级，练到 99 级！
咱也不知道咋练、练啥，咱也不敢问。。。
……
这货上网搜了一下陌生人社交软件，下载了一个比较热门的 APP。
练级第一天，点击匹配，匹配成功，开始聊天，于是：
然后就没然后了，他说这是他人生中遇到的第一次滑铁卢，感觉人生已经到达了低谷中的低谷。
练级第二天，看到社区里有漂亮的小姐姐发自拍，能收到好多赞和评论，真是一群有趣的灵魂啊，于是也决定自己发一张。
练级第三天：
不禁令人感慨，人生呐，就是如此的起起落落落落落落。
然后呢，就又来找我了，让我帮帮他。
这位胸 dei，谈恋爱俺不会，聊天俺也不会，那我只能手动帮你点个赞了。
这位仁兄一听，灵机一动，道:
“那你帮我搞个软件，能自动帮别人点赞也行。高手靠实力，新手靠运气，只要我给一万个人点赞，总有那么几个人能看到我的自拍，然后被我那无处安放的魅力所吸引的。”
嗯, 他说的好像有道理。
于是有了正文。
## 正文
因年代久远，当时的分析与现在 APP 的协议已经很多对不上，我只能尽量复盘。
大伙们，编故事真的不容易。
……
需求很明确：
  1. 从社区里获取小姐姐们的动态
  2. 点赞
###  抓包
这个 `soeasy` ，主要是抓获取动态和点赞的两个请求。
首先打开 `Charles`，然后给把代理端口反向转发到手机里。
`adb reverse tcp:8888 tcp:8888`
再给手机设置代理
`adb shell settings put global http_proxy 127.0.0.1:8888`
结果发现一挂上代理就无法正常发送请求。
这种情况一般有几种可能：
  1. SSL Pinning 证书绑定
  2. 代理检测
  3. SSL 双向校验
根据我多年的经验，第一判断就是 `sslpinning`，于是我用 3 秒钟时间打开 `objection`， 执行 `android sslpinning
disable`。 关于 `Frida` 和 `objection`
的安装和使用，我的另一位母胎不单身的好友已经写过[多遍](https://www.anquanke.com/post/id/197670)，可以参阅。
然后再次抓包，然鹅不管用。
那么先观察一下抓包的情况，发现 `Charles` 并没有出现 SSL 错误的提示，可以完整的看到请求的报文。
然鹅，`response` 却返回 400。由此可得，这是一个 SSL
双向校验，因为代理可以正常拦截到发送包，说明不是代理检测，如果有代理检测，那么这个数据包并不会通过代理发送出去。而且可以正常解密，更是说明也没有做证书绑定。
因为做双向验证，就需要在客户端里放一个证书，那么直接在 APK 里的 `assets` 中就可以找到一个 `.p12` 和一个 `.cer`
的文件，那么这两个就是客户端的证书了。
但是想要使用这个证书来与服务端通信，还需要一个密码。
一般来说，我们可以静态分析代码，搜索 `KeyStore` 或者 `client.p12` 来逆向分析找到密码，然鹅，这个 APP 做过加固，看不到代码。
那么可以采用更加高效的方式： `Hook`。
Hook 的原理不再多说，可参阅 [《Android
动态分析攻防小结》](https://mp.weixin.qq.com/s/YwwcAxRslDCXu4IEOwl8Aw)。  
直接上 `Frida` 脚本:
    Java.perform(function () {
        console.log("Hooking...");
        var PKCS12KeyStoreSpi = Java.use("com.android.org.bouncycastle.jcajce.provider.keystore.pkcs12.PKCS12KeyStoreSpi");
        var String = Java.use("java.lang.String");
        PKCS12KeyStoreSpi.cryptData.implementation = function(a, b, c, d, e){
            console.log(String.$new(c));
            return this.cryptData(a, b ,c ,d ,e);
        }
    });
拿到密码之后，就可以打开 `Charles` 的 `SSL Proxy Settings` 里导入 `p12` 证书了，随后在抓包的时候，`Charles`
会提示你输入密码。 而想要在 `Python` 脚本里使用，还需要使用 `openssl` 转换成 `pem` 证书，然后就可以像这样正常发起
`Https` 请求了:
    response = requests.post(url="https://{}{}".format(ip, path), headers=headers, data=data, verify=False, cert="./client.pem")
于是，终于跨过抓包这个坎了。