(SM) (see Figure 7). Our 5G model considers four communicating
state machines for three participants— MNASUE and MRRCUE for the
UE, MRRCBS
for the base station, and MNASAMF for the AMF.
to MRRCBS
and another from MRRCBS
We model each communication channel between two FSMs, for
instance, MRRCUE and MRRCBS with two uni-directional channels; one
from MRRCUE
to MRRCUE . Such
design choice of using two unidirectional channels instead of a
single bidirectional channel provides better flexibility (e.g., one
direction of the public channels to be adversary controlled whereas
the other to be reliable) in reasoning specific scenarios and filtering
spurious counterexamples.
We consider the communication channel between MNASUE and
MRRCUE , and MRRCBS
and MNASAMF to be private. This is because our
threat model assumes that neither the cellular device’s firmware
nor the secure communication channel (with SCTP connection)
between the base station and AMF is controlled by an adversary.
We model the public communication channel between MRRCUE and
MRRCBS , through which all NAS and RRC layers’ messages are trans-
mitted over the air, to be Dolev-Yao adversary-controlled.
4.3 Capturing Data and Packet Payload
One of the most challenging aspects of precisely capturing the
5G protocol behavior is to model the protocol packet payload. If
one were to directly represent all the packet payloads, due to the
large domain of the payloads, the resulting model is unlikely to be
amenable to automated reasoning. Our initial attempt of directly
capturing packet payload resulted in a model that was not amenable
to analysis by any of the state-of-the-art model checkers. To address
the issue with state-explosion, we employed the notion of behaivor-
aware predicate abstraction. Intuitively, rather than capturing the
data directly we model a predicate over the data and such predicates
are directly inspired by the protocol behavior. The following are
only a few of the representative predicates our 5G model employs.
Validity predicate. As most of the 5G protocol behavior relies
only on the validity of particular message authentication codes
(MAC) instead of the precise MAC value, we use a predicate for each
such MAC value called valid_MAC(·) whose truth value signifies
the validity of the MAC.
Presence predicate. In the paging procedure of 5G, the behav-
ior of the device relies on the type of identity (TMSI or C-RNTI) used
in the received paging message. Instead of capturing the exact iden-
tity, we use two mutually exclusive predicates isPresentTMSI(·)
and isPresentCRNTI(·). The first (resp., second) predicate is true
only if the identity used is TMSI (resp., C-RNTI).
Grouping predicate. When the core network denies the device
connection, it sends the device a reject message which contains
a payload signifying the reason for such rejection. There are 70
possible rejection reasons and the device reacts differently based on
the rejection reasons. Our inspection of the standard revealed that
the device behavior can be used to divide these 70 reasons into three
mutually exclusive groups. We thus capture the group membership
of the rejection reason with the following three mutually exclusive
predicates: ReasonGroup1(·); ReasonGroup2(·); ReasonGroup3(·)
where predicate ReasonGroupi (·) is true only if the rejection reason
belongs to group i ∈ {1, 2, 3}.
In addition to the payload, we also faithfully model counters
with a finite domain. Some of these counters (e.g., link counters)
are also used as payloads. Some of these counters are modeled as
they are without employing any sort of predicate abstraction.
Session 3D: Formal Analysis ICCS ’19, November 11–15, 2019, London, United Kingdom6754.4 Modeling Timers
In our 5G model, some transitions are dependent on various timers.
The protocol behaves differently based on the various state of the
timer. We do not model timers counting down, that is, given a timer
for 5 time units we do not model every clock tick as this would
severely impede the analysis scalability.
For each timer in our model, we maintain two Boolean variables
timer_started and timer_expired. The state variable timer_started
signifies the start of the timer whereas the environmental variable
timer_expired signifies the expiration of the timer. Other timer
behavior such as timer is ongoing can be captured in the following
way: timer_started ∧ ¬timer_expired.
4.5 Capturing Multi-Layer Adversary Behavior
As we model multiple layers of the protocol stack, we have to handle
packets generated by protocols of both layers. Conceptually, NAS
layer protocol packets are sent as payloads of the RRC layer packets.
Moreover, there are RRC layer packets which may not carry any
NAS layer packet. If we were to let the adversary change arbitrary
data of the packet, it may generate packets that are not compliant
to any protocol packet and will result in parsing errors.
To ensure that all packets after adversarial modification result in
compliant protocol packets, we include additional well-formedness
properties. For instance, whenever a NAS layer packet is sent from
the UE to the AMF, it is embedded as a payload of an RRC packet of
type ul_info_transfer. When such a packet is encountered, the ad-
versary would only modify the NAS layer packet, not the RRC layer
packet. We add similar rules for other relevant protocol packets.
5 IMPLEMENTATION
We now discuss our realization of 5GReasoner.
5.1 Formal Property Gathering
Conformance Requirement Documents. After carefully re-
viewing the conformance requirement document [7], we extract 74
conformance tests for the NAS layer that are within the scope of
the paper. We formalize and write them as properties which our
model adheres to1. Out of these 74, 9 are liveness properties and 65
are safety properties. We also extract 63 conformance tests for the
RRC layer and then formalize and write them as properties. Out
of these 63, 6 are liveness properties and 57 are safety properties.
The excluded conformance tests fall under one of the following
categories: (1) Performance related tests; (2) Refers to procedures
not modeled (e.g., Mobile Initiated Connection Only, Wifi-calling).
Technical Requirement and Specifications. We extracted, for-
malized, and verified a total of 50 implicit properties from the
technical specification and requirement documents [4–6] for both
NAS and RRC layers that are within the scope of the paper. Out of
these 50, 33 are liveness properties and 17 are safety properties.
5.2 Protocol Abstraction
We have developed a model generator that takes as input the state
machine of the protocol written in a graphviz-like language and
outputs a Lustre [27] or SMV [38] description of the model. The
1The model’s compliance with the concretized test suites is crucial to establish our
model’s correctness concerning the specification.
UE state machine at the NAS layer has 7 states and 76 transitions
whereas the AMF state machine has 5 states and 66 transitions. Our
RRC layer UE state machine consists of 6 states and 54 transitions
and the base station state machine is comprised of 9 states and 42
transitions. The current models and the respective properties are
available at https://github.com/relentless-warrior/5GReasoner.git.
5.3 MCheck Component Instantiation
To model check our state machine representation, we use two differ-
ent tools, NuXmv [18], and Kind 2 [19]. We decide to use both these
tools to complement each other and overcome their weaknesses.
NuXmv. NuXmv allows one to check for liveness properties which
are essential for reasoning about some of the requirements, however,
it is not capable of handling data from infinite domains. Our NuXmv
model consists of 847 lines of code for NAS in isolation, 629 for
RRC in isolation, and 1476 for the cross-layer.
Kind 2. Kind 2 is able to handle data from an infinite domain;
however, it is unable to check for liveness properties. Our Kind 2
model consists of 2098 lines of code for NAS in isolation, 1494 for
RRC in isolation and 3771 for the cross-layer.
5.4 CPVerif Implementation
We use ProVerif [15] as the cryptographic protocol verifier. We veri-
fied 23 secrecy (for confidentiality), 52 injective-correspondence (for
strong authentication), 52 correspondence (for weak-authentication),
and 16 observational equivalence (for linkability) properties.
5.5 Formal Protocol Analysis in Isolation
To reduce a wide array of spurious counterexamples generated due
to a large number of environment variables spanning across two
control-plane protocol layers, we first reason about each layer in
isolation with 5GReasoner.
NAS Layer. We first instantiate our analysis withMNASUE andMNASAMF
and the corresponding NAS layer properties ϕNAS relevant to the
NAS layer procedures. While analyzing the NAS layer test suites
and procedures (e.g., registration, configuration update, service
request, handover) in isolation, we consider the following aspects
for protocol model abstraction. (A) The UE and the base station
reliably perform the relevant RRC layer procedures, such as, RRC
connection setup, resume, reestablish, reconfiguration, and nego-
tiation of security algorithms that are prerequisites to initiating
respective NAS layer procedures. For instance, to reason about the
NAS layer registration procedure, 5GReasoner assumes that the UE
and the base station set up the required RRC layer connection with
the given security context by following the corresponding RRC
layer procedures. (B) An incoming event from RRC to NAS layer is
represented by a boolean environment variable. As an illustration,
when the UE’s RRC layer releases the connection with the base
station, the RRC layer notifies the NAS layer to move the UE to the
idle state. We abstract such inter-layer communications as boolean
environment variables while analyzing in isolation.
RRC Layer. For analyzing the RRC layer procedures in isolation,
we similarly instantiate 5GReasoner with MRRCUE , MRRCBS
and ϕRRC.
In our instantiation, we abstract the incoming and outgoing events
for the RRC layer in the following ways. (A) We abstract the invo-
cation of RRC layer procedures from the NAS layer using boolean
Session 3D: Formal Analysis ICCS ’19, November 11–15, 2019, London, United Kingdom676Figure 8: Counters maintained by UE and AMF
environment variables. (B) We model the RRC layer to consume the
outgoing events generated for the NAS layer. (C) Though RRC layer
uses the PDCP (packet data convergence protocol) layer for ensur-
ing encryption and integrity protection of the RRC layer’s control-
plane messages, we incorporate the functionalities for encryption
of integrity protections into RRC layer for ease of reasoning and
minimizing state explosion problems.
5.6 Formal Cross-layer Protocol Analysis
As all unexpected interactions cannot be realized by reasoning
about procedures in isolation, we also model and reason about the
control-plane procedures considering two layers. For cross-layer
analysis, we model a channel to carry at most one message at each
step between two participants to avoid any non-determinism. This,
however, poses additional challenges because a participant may
occasionally require to send both NAS and RRC layer messages
at the same time when a particular condition of the participant’s
next state transition becomes true. For instance, if AMF receives a
ue_dereg_request message from a UE, it sends dereg_accept message to
UE-NAS and sends a context release request to BS-RRC for releasing
the RRC layer connection. To address this challenge, 5GReasoner
first lets the AMF-NAS send dereg_accept message to the UE and
then sets a boolean state variable "context_release_required" to true
which triggers the AMF-NAS to send the context_release_request
message to the base station at the next state.
6 FINDINGS
This section highlights the vulnerabilities and attacks uncovered
by 5GReasoner. We also discuss how the uncovered vulnerabilities
can be further exploited along with some domain knowledge to
perform detrimental attacks. We summarize our findings in Table 1.
6.1 Attacks in NAS Layer
We first present our findings on the 5G NAS layer.
6.1.1 NAS Counter Reset. With this attack, the adversary ex-
ploits a potential vulnerability lurking in the handling of NAS
counter values typically used in generating/verifying the message
authentication codes (MAC) for replay protection of NAS layer mes-
sages. This may allow an adversary to replay particular messages
which can reset and desynchronize the counter values between the
device and network, and may further enable the adversary to cause
over-billing to a user.
Adversary Assumptions. The adversary knows the C-RNTI [45]
(i.e., the layer-2 identity of the victim device) and uses it to fol-
low and eavesdrop on victim’s downlink messages from the AMF.
The adversary is also capable of setting up a fake base station or
a Man-in-the-Middle relay [28, 45] that can additionally replay
sec_mode_command and sec_mode_complete messages.
dl
ul
) to estimate cntS
dl
dl
.
dl
or seqamf
ul
and cntue
dl
Vulnerability. The UE and AMF independently maintain a set
of NAS counters— cntue
and cntamf
dl
ul
at AMF (as shown in Figure 8)— to prevent replay of both up-
link (UE→AMF) and downlink (UE←AMF) transmissions. A NAS
counter (cnt) is a 24-bit unsigned integer comprised of a 16-bit
overflow counter (oc) concatenated with a 8-bit sequence number
(seq).
at UE, and cntamf
ul
assuming that (seqS
with the estimated cntS
The sender (S) uses its locally stored NAS counters (e.g., cntue
for
for AMF) as input to the integrity protection algorithm
UE or cntamf
dl
for generating message authentication code whereas the receiver
(R) uses the sequence number included in the received message
and estimates the overflow counter to compute the corresponding
counter used as input to the integrity verification algorithm. If
verification passes, in case of downlink transmissions, the receiver
updates its cntR
If the estimated sequence number wraps around, the overflow
counter is incremented by one. According to TS 33.501, clause:
6.4.3.1, for detecting wrap around, the AMF checks whether its
is close to 28 [6]. Primarily, the vulnerability stems
seqamf
dl
from the lack of specification [4, 6] when a currently received mes-
sage has a sequence number (e.g., seqS
) smaller than that of the
dl
). Due to such underspecified policy of
last accepted message (seqR
dl
“wrap-around”, the receiver may handle the overflow counter (ocR
)
dl
in one of the two possible ways: (i) do not increment the overflow
counter (ocR
when neither the received sequence
number nor the locally stored number is close to 28; (ii) increment
ocR
+ 28 -seqR
) number of messages between
dl
the received sequence number (seqS
) and the receiver’s stored se-
quence number (seqR
) have been lost. Both of these interpretations
entail two different potential vulnerabilities. The case (i) enables
the adversary to replay the integrity-protected sec_mode_command and
sec_mode_complete messages used for changing the current cipher
suite or for resynchronizing the uplink NAS counters between UE
and AMF. The case (ii), on the other hand, allows the adversary to
stealthily drop packets without getting noticed. On top of that, if
the network operator and device manufacturer interpret this “wrap
around” policy differently, there will be inter-operability issues
which may disrupt the regular services. In what follows, we dis-
cuss a potential attack for case (i) in detail and briefly outline the
potential adversarial impact for case (ii).
Detection. We modeled MNASUE and MNASAMF considering the case
(i). We check the MNASadv against the following property implicitly
mentioned in TS 24.501: “Replay protection assures that the same
NAS message is not accepted twice by the receiver. Specifically, for
a given 5G NAS security context, a given NAS COUNT value shall
be accepted at most one time and only if message integrity veri-
fies correctly”. This is violated by a counterexample in which the
adversary sends a sec_mode_command and receives sec_mode_complete
message. Since sec_mode_command message has integrity protection,
we resort to ProVerif to reason the following correspondence prop-
erty: If a UE sent sec_mode_complete message, then the AMF previously
sent a sec_mode_command message. ProVerif provided an attack strategy
which allows the adversary to replay the sec_mode_command message.
ProVerif also provided a similar attack strategy for replaying the
sec_mode_complete message to the core network.
dl
dl