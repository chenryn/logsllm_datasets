1
0
25
CVE
0
2
1
0
1
1
5
0
1
0
0
0
11
Table 4: Vulnerabilities discovered by PTrix
PTrix triggered 19,000 unique exceptions — unique crashes
and hangs based on the measurement of AFL. We have manually
analyzed a subset of them and confirmed 35 new vulnerabilities.
Among those vulnerabilities, 25 are memory corruptions vulner-
abilities and 10 are Denial-of-Service (DoS) flaws that could lead
to endless computation or resource exhaustion. 11 CVE numbers
81624324048566472Fuzzing Hours5400550056005700580059006000Covered Edgesptrix (363394 seeds)qemu (22829 seeds)81624324048566472Fuzzing Hours17501800185019001950Covered Edgesptrix (10342 seeds)qemu (1038 seeds)81624324048566472Fuzzing Hours20000220002400026000280003000032000Covered Edgesptrix (93471 seeds)qemu (8783 seeds)81624324048566472Fuzzing Hours17502000225025002750300032503500Covered Edgesptrix (109824 seeds)qemu (5829 seeds)81624324048566472Fuzzing Hours1650170017501800185019001950Covered Edgesptrix (5876 seeds)qemu (1668 seeds)81624324048566472Fuzzing Hours4500460047004800Covered Edgesptrix (125661 seeds)qemu (8520 seeds)81624324048566472Fuzzing Hours27502800285029002950300030503100Covered Edgesptrix (25629 seeds)qemu (3866 seeds)81624324048566472Fuzzing Hours15001750200022502500275030003250Covered Edgesptrix (159784 seeds)qemu (2905 seeds)81624324048566472Fuzzing Hours40004200440046004800500052005400Covered Edgesptrix (104076 seeds)qemu (7307 seeds)PTrix: Efficient Hardware-Assisted Fuzzing for COTS Binary
ASIACCS ’19, July 07–12, 2019, Auckland, NZ
have been created for those vulnerabilities. We have been commu-
nicating with the developers for patches. When those patches are
available, we will disclose the details of those vulnerabilities.
Taking a closer look at the results, we observe that the discovery
of certain vulnerabilities was indeed benefited from our new feed-
back. Among the 10 DoS vulnerabilities, 9 are due to recursive calls
or deep loops, which follow the same pattern as the example shown
in Figure 6. As we have explained in Section 3, QEMU-AFL unlikely
would catch them. For the memory corruption vulnerabilities, al-
though most of them locate in execution space that QEMU-AFL will
also cover with high likelihood, we have identified a case that can
only be discovered using our new feedback. In the following, we
the above memory corruption case and a DoS vulnerability (all the
other DoS vulnerabilities share the same pattern).
Stack Overflow/Exhaustion in c++filt. c++filt shipped in
binutils-2.29 can run into stack exhaustion with a long sequence
of “F”. More specifically, each “F” leads to a recursive call chain in-
cluding demangle_nested_args, demangle_args, do_arg and
do_type. Stack frames of those recursive functions gradually oc-
cupy the whole stack.
Integer Overflow in objdump. In objdump from binutils-2.29,
an integer could overflow, which further causes memory corruption.
To be specific, objdump utilizes qsort for sorting an array and uses
the return value of bfd_canonicalize_dynamic_reloc to specify
the array size. When exception happens, bfd_canonicalize_dyn-
amic_reloc may return -1. However, this is ignored by objdump
and consequently, qsort wrongly casts -1 to the largest unsigned
value (which is taken as the array size) and ultimately makes out-of-
bound memory accesses. The bfd_canonicalize_dynamic_reloc
function implements a logic close to Figure 5a. Because of a similar
reason as we explained in Section 3, QEMU-AFL is unable to make
bfd_canonicalize_dynamic_reloc return -1.
6 DISCUSSION
In this section, we discuss the limitations of our current design,
insights we learned and possible future directions.
Path explosion: PTrix implements a gray-box fuzzing scheme
with path-sensitive feedback. This feedback metric, however, may
lead to the problem of path explosion. That is, the fuzzer may
explore a huge number of paths and correspondingly produce an
extremely large corpus. This could further result in the exhaustion
of available bitmap entries used by the fuzzer to record coverage. As
we detailed in Section 3, PTrix mitigates the path explosion problem
by incorporating the technique of descending path sensitivity. This
technique favors the prefix of an execution path and suppresses
long paths, which prevents PTrix from generating a large corpus
and trapping into localized code regions.
Generality: PTrix leverages PT to trace the target program. How-
ever, PT is only equipped on x86 platforms. We believe this will
not impede the generality of the design philosophy behind PTrix.
Probably due to the motivation to assist debugging, hardware trac-
ing has become a common feature in major architectures. Besides
x86, ARM also incorporates a hardware feature called Embedded
Trace Macrocell (ETM) to support runtime tracing. ETM, similar to
PT, can trace the instructions with negligible performance impacts.
In addition, ETM also provides a rich set of configuration options
which can serve the requirement of PTrix. We, therefore, believe
PTrix can be ported to other platforms without any modifications
to the design.
7 RELATED WORKS
This work focuses on leveraging PT to escalate efficiency of grey-
box fuzzing on COST binaries. With regard to this problem, the
closely related research includes binary compatible coverage-based
fuzzing, improvement of coverage-based fuzzing, and combination
of fuzzing and other techniques.
7.1 Binary Compatible Coverage-based Fuzzing
Coverage-based fuzzing requires feedback from the target program,
which can be obtained via lightweight program instrumentation
when source code is available. This is, however, very challenging
when only a binary is present. In the literature, various options
have been explored.
Fuzzing with Dynamic Instrumentation. Dynamic instrumen-
7.1.1
tation based solutions [3, 6, 7, 24] dynamically translate the binary
code, the fuzzer can then intercept and collect coverage informa-
tion. This approach, however, significantly slows down the fuzzing
process. The fastest tool produced by this research line (QEMU-AFL)
reportedly introduces 2 to 5 times of overhead.
7.1.2 Hardware-assisted Fuzzing. Motivated by the inefficiency of
dynamic instrumentation based fuzzing systems, hardware-assisted
fuzzing techniques were proposed recently [38]. Similar to PTrix,
by leveraging the newly available hardware tracing component–
Intel PT [1], Honggfuzz [5] and kAFL [29] efficiently collect the
execution trace from the target program. In contrast to PTrix, the
two systems do not fully exploit the potential of PT. Honggfuzz
only collects coarse-grained coverage information trading for ex-
ecution throughput, which in fact degrades the code exploring
capability. kAFL and PTFuzz, however, spend too much bandwidth
on reconstructing the execution flow from PT trace.
Improving Seed Generation. Many programs take as inputs
7.2 Improvement of Coverage-based Fuzzing
7.2.1
highly structured files and process these inputs over different stages [10,
14, 25, 28, 33]. As a result, most randomly generated inputs will be
rejected at the early stages and cannot reach the core logic of the tar-
get program. Therefore, based on a priori knowledge about inputs
taken by the fuzzed programs, more targeted seeds can be gen-
erated. Skyfire [35] establishes a probabilistic context-sensitive
grammar model by learning through a large corpus of valid inputs.
It then uses the grammar to generate inputs that are accepted by
target programs. Similarly, Godefroid et al. aid white-box fuzzing
with a grammar-based input generator [17, 26].
Improving Fuzzing Scheduling. When there are plenty of
7.2.2
seeds in the input queue, the strategy to select seeds for the fol-
lowing runs is very critical for the efficiency of fuzzing test [36].
AFL [22] develops a scheduling algorithm in a round-robin flavor
which prefers seeds that bring new edge coverage and take less time
ASIACCS ’19, July 07–12, 2019, Auckland, NZ
Chen, et al.
to run. Böhme et al. [11] propose to change that algorithm to prior-
itize inputs that follow less frequently visited paths. This strategy
significantly accelerates the code coverage and bug discovery.
Improving Coverage Guidance. Providing a more informative
7.2.3
coverage guidance is a new trend on tuning the effectiveness of
fuzz-testing techniques. CollAFL [15] reduced path collision intro-
duced by AFL’s over-approximated counted edge coverage feedback,
and thus make the fuzzer more sensitive to new program paths.
Along the same route, recent works [13, 31] introduced context-
aware branch coverage to decide on whether to follow inputs cover
branches with new context. Both techniques showed that a path-
based feedback is a promising direction to help boost fuzzer’s ef-
fectiveness. PTrix aims to provide a higher level of path guidance,
which helps PTrix achieve high fuzzing throughput.
8 CONCLUSION
We present PTrix, a binary compatible fuzz-testing tool featuring
efficient code exploration capability. PTrix is carefully designed and
engineered to take full advantage of Intel Processor Trace as its un-
derpinning tracing component. Using PTrix, we demonstrate newly
available hardware feature can significantly accelerate binary-only
fuzzing through two elaborate designs, including a parallel scheme
of trace parsing and a newly designed PT-friendly feedback. Also
because of the new feedback provides more guidance than code
coverage, PTrix is able to identify 35 new software bugs in well-
tested programs that have not yet been uncovered, among them 11
CVEs have been assigned thus far.
9 ACKNOWLEDGMENTS
The authors would like to thank the anonymous reviewers for
their constructive comments. This project was supported by the
National Science Foundation (Grant#: CNS-1718459, Grant#: CNS-
1748334, Grant#: CNS-1718459) and the Army Research Office
(Grant#: W911NF-17-1-0039). Any opinions, findings, and conclu-
sions or recommendations expressed in this paper are those of the
authors and do not necessarily reflect the views of the funding
agencies.
REFERENCES
[1] 2013. Intel Processor Trace. https://software.intel.com/en-us/blogs/2013/09/18/
processor-tracing.
[2] 2013. Sample images for testing Exif metadata retrieval. https://github.com/
ianare/exif-samples.
[3] 2014. AFL technical details. http://lcamtuf.coredump.cx/afl/technical_details.txt.
[4] 2014. Fuzzing random programs without execve(). https://lcamtuf.blogspot.com/
2014/10/fuzzing-binaries-without-execve.html.
[5] 2015. Honggfuzz. http://honggfuzz.com.
[6] 2016. AFL-dyninst. https://github.com/vrtadmin/moow/tree/master/afl-dyninst.
[7] 2016.
https://www.
Project Triforce: Run AFL on Everything!
nccgroup.trust/us/about-us/newsroom-and-events/blog/2016/june/
project-triforce-run-afl-on-everything/.
[8] 2017. Harnessing Intel Processor Trace on Windows for fuzzing and dynamic
analysis. https://recon.cx/2017/brussels/talks/intel_processor_trace.html.
[9] Fabrice Bellard. 2005. QEMU, a Fast and Portable Dynamic Translator. In Proceed-
ings of the Annual Conference on USENIX Annual Technical Conference (USENIX
ATC). USENIX Association.
[10] Marcel Böhme, Van-Thuan Pham, Manh-Dung Nguyen, and Abhik Roychoudhury.
2017. Directed greybox fuzzing. In Proceedings of the 2017 ACM SIGSAC Conference
on Computer and Communications Security (CCS). ACM.
[11] Marcel Böhme, Van-Thuan Pham, and Abhik Roychoudhury. 2016. Coverage-
based greybox fuzzing as markov chain. In Proceedings of the 2016 ACM SIGSAC
Conference on Computer and Communications Security (CCS). ACM.
[12] Hanno BÃűck. 2014. The Fuzzing Project - apps. https://fuzzing-project.org/
software.html.
[13] Peng Chen and Hao Chen. 2018. Angora: Efficient Fuzzing by Principled Search.
arXiv preprint arXiv:1803.01307 (2018).
[14] Yaohui Chen, Peng Li, Jun Xu, Shengjian Guo, Rundong Zhou, Yulong Zhang,
Tao Wei, and Long Lu. 2020. SAVIOR: Towards Bug-Driven Hybrid Testing. In
To appear in the 2020 IEEE Symposium on Security and Privacy (SP). IEEE.
[15] S. Gan, C. Zhang, X. Qin, X. Tu, K. Li, Z. Pei, and Z. Chen. 2018. CollAFL: Path
Sensitive Fuzzing. In 2018 IEEE Symposium on Security and Privacy (SP). IEEE.
[16] Xinyang Ge, Weidong Cui, and Trent Jaeger. 2017. Griffin: Guarding control
flows using intel processor trace. In Proceedings of the Twenty-Second International
Conference on Architectural Support for Programming Languages and Operating
Systems (ASPLOS). ACM.
[17] Patrice Godefroid, Adam Kiezun, and Michael Y. Levin. 2008. Grammar-based
Whitebox Fuzzing. In Proceedings of the 29th ACM SIGPLAN Conference on Pro-
gramming Language Design and Implementation (PLDI). ACM.
[18] Patrice Godefroid, Michael Y. Levin, and David Molnar. 2012. SAGE: Whitebox
Fuzzing for Security Testing. Queue 10, 1, Article 20 (Jan. 2012), 8 pages.
[19] Christian Henke, Carsten Schmoll, and Tanja Zseby. 2008. Empirical Evaluation
of Hash Functions for Multipoint Measurements. SIGCOMM Comput. Commun.
Rev. 38, 3 (July 2008), 39–50.
[20] George Klees, Andrew Ruef, Benji Cooper, Shiyi Wei, and Michael Hicks. 2018.
Evaluating Fuzz Testing. In Proceedings of the 2018 ACM SIGSAC Conference on
Computer and Communications Security (CCS). ACM.
[21] Geeknik Labs. 2016. Fuzzing Perl: A Tale of Two American Fuzzy Lops. http:
//www.geeknik.net/71nvhf1fp.
[22] lcamtuf. 2005. american fuzzy lop. http://lcamtuf.coredump.cx/afl/.
[23] Caroline Lemieux and Koushik Sen. 2017. FairFuzz: Targeting Rare Branches to
Rapidly Increase Greybox Fuzz Testing Coverage. CoRR abs/1709.07101 (2017).
[24] Yuekang Li, Bihuan Chen, Mahinthan Chandramohan, Shang-Wei Lin, Yang Liu,
and Alwen Tiu. 2017. Steelix: program-state based binary fuzzing. In Proceedings
of the 2017 11th Joint Meeting on Foundations of Software Engineering (FSE). ACM.
[25] Hui Peng, Yan Shoshitaishvili, and Mathias Payer. 2018. T-Fuzz: fuzzing by
program transformation. In 2018 IEEE Symposium on Security and Privacy (SP).
IEEE.
[26] Van-Thuan Pham, Marcel Böhme, and Abhik Roychoudhury. 2016. Model-based
Whitebox Fuzzing for Program Binaries. In Proceedings of the 31st IEEE/ACM
International Conference on Automated Software Engineering (ASE). ACM.
[27] Sanjay Rawat, Vivek Jain, Ashish Kumar, Lucian Cojocar, Cristiano Giuffrida,
and Herbert Bos. 2017. Vuzzer: Application-aware evolutionary fuzzing. In
Proceedings of the Network and Distributed System Security Symposium (NDSS).
[28] Alexandre Rebert, Sang Kil Cha, Thanassis Avgerinos, Jonathan Foote, David
Warren, Gustavo Grieco, and David Brumley. 2014. Optimizing Seed Selection
for Fuzzing. In Proceedings of the 23rd USENIX Conference on Security Symposium
(USENIX Security). USENIX Association.
[29] Sergej Schumilo, Cornelius Aschermann, Robert Gawlik, Sebastian Schinzel, and
Thorsten Holz. 2017. kAFL: Hardware-Assisted Feedback Fuzzing for OS Kernels.
In Proceedings of the 26rd USENIX Conference on Security Symposium (USENIX
Security). USENIX Association.
[30] Margo I Seltzer and Ozan Yigit. 1991. A New Hashing Package for UNIX.. In
USENIX Winter. USENIX.
[31] Hyunmin Seo and Sunghun Kim. 2014. How we get there: A context-guided
search strategy in concolic testing. In Proceedings of the 22nd ACM SIGSOFT
International Symposium on Foundations of Software Engineering (FSE). ACM.
[32] Yan Shoshitaishvili, Ruoyu Wang, Christopher Salls, Nick Stephens, Mario Polino,
Audrey Dutcher, John Grosen, Siji Feng, Christophe Hauser, Christopher Kruegel,
and Giovanni Vigna. 2016. SoK: (State of) The Art of War: Offensive Techniques
in Binary Analysis. In Proceedings of the 2016 IEEE Symposium on Security and
Privacy (SP). IEEE.
[33] Nick Stephens, John Grosen, Christopher Salls, Andrew Dutcher, Ruoyu Wang,
Jacopo Corbetta, Yan Shoshitaishvili, Christopher Kruegel, and Giovanni Vigna.
2016. Driller: Augmenting Fuzzing Through Selective Symbolic Execution.. In
Proceedings of the Network and Distributed System Security Symposium (NDSS).
[34] László Szekeres. 2017. Memory corruption mitigation via hardening and testing.
Ph.D. Dissertation. Stony Brook University.
[35] Junjie Wang, Bihuan Chen, Lei Wei, and Yang Liu. 2017. Skyfire: Data-driven seed
generation for fuzzing. In Proceedings of the 2017 IEEE Symposium on Security
and Privacy (SP). IEEE.
[36] Maverick Woo, Sang Kil Cha, Samantha Gottlieb, and David Brumley. 2013.
Scheduling black-box mutational fuzzing. In Proceedings of the 2013 ACM SIGSAC
conference on Computer and Communications Security (CCS). ACM.
[37] Wen Xu, Sanidhya Kashyap, Changwoo Min, and Taesoo Kim. 2017. Designing
New Operating Primitives to Improve Fuzzing Performance. In Proceedings of the
2017 ACM SIGSAC Conference on Computer and Communications Security (CCS).
ACM.
[38] Gen Zhang, Xu Zhou, Yingqi Luo, Xugang Wu, and Erxue Min. 2018. PTfuzz:
Guided Fuzzing with Processor Trace Feedback. IEEE Access (2018).
PTrix: Efficient Hardware-Assisted Fuzzing for COTS Binary
ASIACCS ’19, July 07–12, 2019, Auckland, NZ
A SUPPLEMENTARY FIGURES AND
EVALUATION DATA
Figure 9: CDF of Call chains triggered by different fuzzing
techniques. PTrix (Solidline), QEMU-AFL (Dashline)
010013579111315lengthcxxfilt0501003579111315lengthpng050100234567891011lengthjpeg010026101418222630lengthexif050100010203040506070lengthxml-lint050100135791113151719lengthperl05010024lengthnm0501002468101214161820lengthobjdump05010037111519232731353943lengthmupdf