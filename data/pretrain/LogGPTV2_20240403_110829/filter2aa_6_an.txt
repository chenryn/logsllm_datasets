253− (254−1)
%1.f51...f0 × 22532
55位
254− (255−1)
%1.f51...f000 × 254
...
对于54位数，最后一位数字总是0，对于55位数，最后两位数字总是0，以此类推。这意味着对于54位数来讲，每两个数只有一个能用这种方式表示，对于55位数，每四个数只有一个能表示，以此类推。举个例子：
最佳实践
如果和不超过53位的整型打交道，那是没问题的。然而，在程序中经常会遇到64位无符号整型数字（Twitter的ID、数据库等）。它们必须以字符串形式存储在JavaScript中。如果想对这些整型执行某种算法，需要特殊的库。JavaScript有计划要引入更大的整型，不过还需要一些时间。
11.6.3 安全的整型
JavaScript只能安全地表示在−253＜i＜253范围内的整型。这一节解释了它的意义，和它的影响。它是基于Mark S. Miller发给es讨论邮件组的一封邮件（http://mzl.la/1oOaCOO）。
安全的整型的想法关注如何将数学中的整数用JavaScript表示出来。在（−253，253）（不包括上下边界）这个区间里，JavaScript整型是安全的：此时在数学整数和对应的JavaScript表示之间有一对一的映射关系。
在这个区间以外，JavaScript整型是不安全的：两个或更多个的数学整数会表示成同一个JavaScript整型。举个例子，从253开始，每两个数学整数在JavaScript中只能表示一个（在前面的章节解释了原因）。因此，一个安全的JavaScript整型指的是能够明确地表示一个单独的数学整数。
ECMAScript 6中的定义
ECMAScript 6将提供以下这些常量：
同时还提供了一个用来检测一个整型是否安全的函数：
对于一个给定的值n，这个函数首先检查n是不是一个数字和整型。如果这两个检查都通过，当n大于等于MIN_SAFE_INTEGER并且小于等于MAX_SAFE_INTEGER时，n是安全的。
算术运算的安全结果
我们如何确定算术运算的结果是正确的呢？比如，下面的结果很明显是错误的：
有两个安全的运算数，但是得到了一个不安全的结果：
下面的结果也是错误的：
这一次，结果是安全的，但是其中一个运算数不是：
因此，只有当所有的运算数和结果都是安全的时候，才能保证应用整型运算符op的结果是正确的。更正规的写法如下：
表示a op b是正确的结果。
11.7 转换成整数
在JavaScript中，所有的数字都是浮点数。整数是没有小数部分的浮点数。将一个数字n转换成整数意味着找到与n最接近的整数（其中“最接近”的意思取决于你的转换方式）。你可以选择以下几种转换方式。
（1）Math函数：Math.floor()，Math.ceil()以及Math.round()（参见11.7.1“通过Math.floor()，Math.ceil()和Math.round()得到整数”）
（2）定制的ToInteger()函数（参见11.7.2“通过定制函数ToInteger()得到整数”）
（3）二进制位运算操作符（参见11.7.3“通过位运算操作符得到32位整数”）
（4）全局函数parseInt()（参见11.7.4“通过parseInt()得到整数”）
先剧透一下结果：方式（1）通常是最佳选项，方式（2）和方式（3）适用于特定的场景，方式（4）可以用于解析字符串，但是不适合用于将数字转换成整数。
11.7.1 通过Math.floor()，Math.ceil()和Math.round()得到整数
下面是将数字转换成整数最常用的三个函数。
Math.floor()将其参数转换成小于且最接近于它的整数：
Math.ceil()将其参数转换成大于且最接近于它的整数：
Math.round()将其参数转换成最接近于它的整数：
估算-3.5的结果可能让人吃惊：
因此，Math.round(x)等同于：
11.7.2 通过定制函数ToInteger()得到整数
另一种将任意值转换成整数的好方法是ECMAScript内置的ToInteger()方法，该方法会移除浮点数的小数部分。如果JavaScript支持的话，则其使用方式如下：
ECMAScript规范中对ToInteger(number)的结果是如下定义的：
为了得到以上结果，该公式会比较复杂，因为floor会向下取整；如果要去掉负整数的小数部分，必须向上取整。该操作在JavaScript中的实现如下。通过使用ceil避免了在number为负数时使用sign操作。
11.7.3 通过位运算符得到32位整数
二进制位运算操作符（参见11.9.3“二进制位运算符”）将（至少）一个操作数转换成一个32位的整数，然后经过运算生成一个同样为32位整数的结果。因此，如果适当地选择其他操作数，可以快速将任意数字转换成32位整数（有符号或无符号）。
二进制或Or（|）
如果掩码，即第二个操作数为0，那么不会改变任何位，结果为第一个操作数，被强制转换成了一个有符号的32位整数。这是执行且用于这种强制转换的典型方式，例如asm.js就使用了这种方法（参见2.5“JavaScript是否足够快”）：
ToInt32()移除了小数部分并且对2的32次方取模：
移位操作符
在Or运算中使用的技巧同样适用于移位操作符：如果移动0位，移位操作的结果为第一个操作数，它被强制转换成了32位整数。下面是一些通过移位操作符实现ECMAScript规范操作的示例：
下面是ToUnit32()实战：
是否应该使用位运算操作符强制转换整数？
需要评估牺牲代码可读性换取的性能提升是否值当。还要注意位操作符只限于32位，这通常不是必需的而且也没什么用。使用除Math.abs()之外的其他Math函数可能是更好的选择，也更容易理解。
11.7.4 通过parseInt()得到整数
parseInt() 函数：
将字符串str（非字符串类型的值会被强制转换）解析成整数。该函数会忽略开头的空白字符并尽可能多地查找连续的合法数字。
基数
基数的范围是“大于等于2，且小于等于36”，它决定了数字被解析时的基数。如果基数大于10，会使用字母来表示0到9之外的数字（不区分大小写）。
如果没有设定基数，则基数默认是10，除非要被解析的字符串以0x或者0X开头，此时基数被设为16（十六进制）：
如果基数已经是16，则下列十六进制前缀是可选的：
至此已经描述了ECMAScript规范中parsetInt()的行为。此外，如果str以0开头的话，某些引擎会将它们的基数设为8：
因此，最好显式地声明基数，并且总是使用两个参数来调用parsetInt()。
示例如下：
不要使用parseInt()来转换数字成整数。虽然最后一个例子让我们觉得可以使用parseInt()来将数字转换成整数，但是这里有一个转换不正确的示例：
解释
参数首先会被转换成字符串：
parseInt认为e不是整数，因此在1后面就停止解析了。例如：
总结
不应该使用parseInt()将数字转换成整数：强制转换成字符串会走不必要的弯路，而且结果也不一定正确。
parseInt()对于解析字符串非常有用，但是必须注意该函数在遇到第一个非法字符时会停止解析。通过Number()解析字符串（参见11.10“Number函数”）更宽松，但是可能产生非整数。
11.8 算术运算符
下面的操作符可用于数字：
number1 + number2
在操作数不存在字符串的情况下进行数值相加。否则两个操作数都会被转换成字符串并且拼接到一块（参见9.5“加号运算符（+）”）：
number1 - number2
减法。
number1 * number2
乘法。
number1 / number2
除法。
number1 % number2
求余：
警告：
该操作不是取模运算。它会返回与第一个操作数符号相同的值（更多细节稍后介绍）。
-number
对参数取反。
+number
保持参数不变；非数字会被转换成数字。
++variable, --variable
返回变量自增（或者自减）1后的值：
variable++, variable—−
将变量值自增（或者自减）1，并返回运算前的值：
提示：
 记忆法：自增（++）和自减（--）操作符
操作数的位置可以帮助记忆是返回自增（或自减）操作之前还是之后的值。如果操作数出现在自增操作符之前，则返回自增之前的值。如果操作数出现在操作符之后，则返回自增之后的值（自减操作符的使用也类似）。
陷阱：求余操作符（%）不是取模
求余操作符的结果通常和第一个操作数的符号相同（而取模和第二个操作数的符号相同）：
这意味着下面的函数无效：
正确的版本为：
11.9 位运算符
JavaScript有几个32位整数位运算操作符。它们会将操作数转换成32位整数并产生32位整数的结果。这些操作符在二进制协议和特殊算法处理中使用。
11.9.1 背景知识
本节介绍了几个可以帮助理解位运算操作符的概念。
二进制补码
计算一个二进制数字的二进制补码的两种常见方法如下。
（1）一的补码
通过将一个数字的32位上的所有二进制取反来计算一个数字x的补码值~x。让我们通过4位数字来表示一的补码。1100的一补码是0011。为其一补码添加一个数字会生成一个所有数字为1的数：
（2）二的补码
数字x的二的补码-x是将其一的补码加1。为其二补码添加一个数结果会是0（忽略最高位以上的溢出）。下面是一个使用4位数字的示例：
有符号32位整数
32位整数没有明显的符号，但是仍然可以编码成负数。例如，−1可以被编码成1的二的补码：为结果加1生成0（32位内）。正数和负数是连续的；4294967295（2的32次方减1）和−1在这是相同的整数。但是在将这样的整数和JavaScript数字相互转换时需要确定一个符号，JavaScript的符号是显式而不是隐式的。因此，有符号的32位整数被分成了两组。
最高位为0：数字为0或正数。
最高位为1：数字为负数。
最高位通常被称为符号位。相应的，4294967295，解释成一个32位的整数，在被转换成JavaScript数字时是−1：
ToInt32()在11.7.3“通过位运算操作符得到32位整数”中进行了解释。
注解：
 只有无符号的右移操作符（>>>）可以在无符号32位整数上使用；其他所有位运算操作符可以在有符号32位整数上使用。
二进制数字的输入和输出
在下面的例子中，我们通过下面两个运算符来操作二进制数字。
parseInt(str, 2)（参见11.7.4“通过parseInt()得到整数”）解析了一个使用二进制标注的（以2为底）字符串str。例如：
num.toString(2)（参见11.12.3“Number.prototype.toString(radix?)”）将数字num转换为一个二进制标记的（以2为底）字符串。例如：
11.9.2 位运算非操作符
~number计算了number的一的补码：
11.9.3 二进制位运算符
JavaScript有三种二进制位运算操作符。
number1 & number2（位运算与）：
number1 | number2（位运算或）：
number1 ^ number2（位运算异或）：
有两种方式来直观地理解二进制位运算操作符。
（1）逐位进行布尔操作
在下面的公式中，ni表示数字n的i位作为布尔值（0为false，1为true）。例如，20为false，21为true。
与：resulti = number1i && number2i
或：resulti = number1i || number2i
异或：resulti = number1i ^^ number2i
操作符^^并不存在。如果存在的话，它的作用会像这样（如果只有一个操作数为true的话结果为true）：
（2）通过number2来修改number1的每一位
与：number1仅保留number2上已设置的位。该操作也被称为掩码，number2就是掩码（mask）。
或：设置number1上所有在number2上已经设置的位，并保留其他所有位不变。
异或：将number1上所有number2已设置的位取反，并保留其他所有位不变。
11.9.4 位运算移位操作符
JavaScript有三个位运算移位操作符。
number > digitCount（有符号右移）：
这个32位的二进制数字被解释成了有符号（查看上一节）。在右移时，符号会被保留：
我们已经左移了−2。其结果为−1，正好和所有位都为1的32位整数相等。换句话说，有符号右移一个数位会将正负整数都除二进制2。
number >>> digitCount（无符号右移）：
正如所见，该操作符会从左边的零开始移位。
11.10 Number函数
Number函数可以用以下两种方式调用。
Number(value)
作为一个常规函数，它将value转换成一个原始数字（参见11.2“转换成数字”）：
new Number(num)
作为构造函数，创建了一个Number的实例（参见8.4“原始值的包装对象”(#)），即一个包装了num的对象（在转换成一个数字后）。例如：
前面的调用更常见。
11.11 Number构造器属性
Number对象有如下属性。
Number.MAX_VALUE