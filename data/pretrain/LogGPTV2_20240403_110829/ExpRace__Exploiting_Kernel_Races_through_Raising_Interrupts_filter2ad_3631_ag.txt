15 M 4.4e-04
37 B
0
29 M 3.47e-04
0
12 M
13 M
0
36 B
0
13 M 6.12e-04
37 B
✗
36 B
0
Syscallx Syscally interrupt
14 K
250 K
1.1 M
1.3 M
1 M
1 M
56 K
417 K
2 M
44 K
30 K
4 K
43 M 1.3 M
140 K 140 K
6 M 113 K
5 K
5 K
5 K
5 K
9 M 17 M
13 K
2 M
9 K
9 K
1 K
1 K
TLB shootdown
Syscallx Syscally interrupt PEXPRACE
✗ 3.92e-04
5 M 1.09e-03
26 M 7.79e-04
26 M 7.63e-04
46 K 5.30e-04
53 K 1.02e-03
10 M 6.63e-04
5 M 2.61e-03
✗ 1.33e-05
4.88-e4
✗
✗
30 K
20 M
50 K
50 K
5 M 100 K
2 K
2 K
3 K
3 K
7 M 15 M
8 K
✗
1 K
72 B
190 B
59 M
1 M
12 M 12 M
50 K
6 M
1.9 M 1.9 M
2.8 M 2.8 M
32 B
43 B
10 K
3 M
3.3 M 3.3 M
35 M 35 M
81 B
198 B
150 B
5 B
19 M 19 M
6 B 130 M
2.7 M 2.7 M
4.1 M 4.1 M
33 B
66 B
51 M
7 B
5 M
5 M
50 M 50 M
✗
✗
30 M
39 K
14 M 14 M
60 K
5 M
2.2 M 2.2 M
3.5 M 3.5 M
32 B
43 B
7 K
1.1 M
✗
✗
43 M 43 M
810 K
✗
1 K
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
HW interrupt
✗
80 B
71 B
multi
✗
multi
MEMBARRIER_CMD_REGISTER_PRIVATE_EXPEDITED, 0);
// There is a data race in this thread
MEMBARRIER_CMD_PRIVATE_EXPEDITED, 0);
membarrier(
membarrier(
1 void sendIPI(void) {
2
3
4 }
5
6 void registerIPI(void) {
7
8
9 }
10
11 void target_thread(void *arg) {
12
13
14
15 }
16
17 int main() {
18
19
20
21
22 }
while(1){
}
pthread_t thread;
registerIPI();
pthread_create(&thread, NULL, target_thread, NULL);
sendIPI();
Figure A.3: The simplified code of EXPRACE’s membarrier IPI
exploitation method
for(int i = 0; i < LOOPNUM_A; i++);
// Race exploitation is successful.
return 0x1337;
if(!P2)
if(!P1)
// Failed to exploit.
return 0;
// Failed to exploit.
return 0;
1 int P1, P2;
2
3 // __attribute__((optimize("O0")))
4 long Syscallx(ulong LOOPNUM_A) {
5
6
7
8
9
10
11
12
13
14
15
16
17 }
18
19 // __attribute__((optimize("O0")))
20 long Syscally(ulong LOOPNUM_B) {
21
22
23
24
25
26
27
28
29
30
31
32 }
P2 = 0;
// rdtsc(); // to measure Ty
P1 = 0;
P2 = 1;
// rdtsc(); // to measure Ty
P1 = 1;
return 0;
for(int i = 0; i < LOOPNUM_B; i++);
pthread_t thread;
pthread_create(&thread, NULL, (void *)target_thread,
Figure A.5: The simplified code of EXPRACE’s HW interrupt ex-
ploitation method
Figure A.4: Synthetic race vulnerability code
2380    30th USENIX Security Symposium
USENIX Association
// if pid is NULL then calling thread is used
if(sched_setaffinity(pid, sizeof(cpu_set_t), &cset))
// Create socket
sk = socket(AF_INET, SOCK_STREAM, 0);
addr.sin_family = AF_INET;
addr.sin_addr.s_addr = inet_addr(IP);
addr.sin_port = htons(PORT);
err(1, "affinity");
int sk;
struct sockaddr_in addr;
cpu_set_t cset;
CPU_ZERO(&cset);
CPU_SET(cpu, &cset);
1 int map_size = 0x1000;
2
3 void pin_task_to(int pid, int cpu) {
4
5
6
7
8
9
10
11 }
12
13 void sendIRQ() {
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28 }
29
30 void target_thread(void *arg) {
31
32
33
34
35
36 }
37
38 int main(void) {
39
40
41
42
43 }
// pin process to IRQ’s affinity
pin_task_to(0, 11);
while(1){
sendIPI();
NULL);
}
sizeof(struct sockaddr_in));
// There is a data race in this thread
// Connect to server
// HW interrupt will occurs when reply packet arrive
connect(sock, (struct sockaddr *)&server_addr, \