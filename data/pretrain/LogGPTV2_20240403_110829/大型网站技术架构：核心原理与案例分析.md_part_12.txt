?
消息队列服务器
—2保存数据—
4保存数据—
数据库服务器
数据库服务
---
## Page 74
压力过大而响应缓慢，使用户请求具有更好的响应延迟特性，如图4.15所示。
组成的服务器集群，将并发访问请求分发到多台服务器上处理，避免单一服务器因负载
4.3.3
电子邮件或SMS消息通知用户订单成功，以免交易纠纷。
成功，需要在消息队列的订单消费者进程真正处理完该订单，甚至商品出库后，再通过
务流程进行配合，如订单提交后，订单数据写入消息队列，不能立即返回用户订单提交
写数据库等操作可能失败，因此在使用消息队列进行业务异步处理后，需要适当修改业
在网站高并发访问的场景下，使用负载均衡技术为一个应用构建一个由多台服务器
需要注意的是，由于数据写入消息队列后立即返回给用户，数据在后续的业务校验
使用集群
任何可以晚点做的事情都应该晚点再做。
负载压力
用户发起访问请求
图4.14使用消息队列消除并发访问高峰
图4.15利用负载均衡技术改善性能
直接调用
新服务器
4瞬时响应：网站的高性能架构·
请求转发
请求转发
消态队列异步处理
L
53
---
## Page 75
理优化业务代码，可以很好地改善网站性能。不同编程语言的代码优化手段有很多，这
理的 http请求只有总并发请求数的三分之一，根据性能测试曲线，使服务器的并发请求
线程IO阻塞与执行交替进行，可最大限度地利用CPU资源。使用多线程的另一个原因
盘IO还是网络IO）通常都需要较长的时间，这时CPU可以调度其他的线程进行处理。
去处理。由于线程比进程更轻量，更少占有系统资源，切换代价更小，所以目前主要的
器的并发用户也会达到数百。CGI编程时代，每个用户请求都会创建一个独立的系统进程
里我们概要地关注比较重要的几个方面。
4.3.4
数目控制在最佳运行区间，获得最佳的访问请求延迟。
54
动的线程数有个简化的估算公式可供参考：
务器上启动多少线程合适呢？假设服务器上执行的都是相同类型任务，针对该类任务启
务器容器管理，但不管是Web容器管理的线程，还是应用程序自己创建的线程，一台服
般数据中心的服务器至少16核CPU，要想最大限度地使用这些CPU，必须启动多线程。
是服务器有多个CPU，在这个连手机都有四核CPU的时代，除了最低配置的虚拟机，一
前面我们提到，
进行IO处理的时候，会被阻塞释放CPU以等待IO操作完成，由于IO操作（不管是磁
编程。
Web应用服务器都采用多线程的方式响应并发用户请求，因此网站开发天然就是多线程
大型网站技术架构核心原理与案例分析
网站的业务逻辑实现代码主要部署在应用服务器上，需要处理复杂的并发事务。
三台Web服务器共同处理来自用户浏览器的访问请求，这样每台Web服务器需要处
网站的应用程序一般都被Web服务器容器管理，用户请求的多线程也通常被Web服
从资源利用的角度看，使用多线程的原因主要有两个：IO阻塞与多CPU。当前线程
多用户并发访问是网站的基本需求，大型网站的并发用户数会达到数万，单台服务
最佳启动线程数和CPU内核数量成正比，和IO阻塞时间成反比。如果任务都是CPU
启动线程数=［任务执行时间/（任务执行时间-IO等待时间）]xCPU内核数
1.多线程
代码优化
，理想的系统Load是既没有进程（线程）等待也没有CPU空闲，利用多
合
---
## Page 76
（Singleton）和对象池（ObjectPool）。
除非程序有意识地将这些对象传递给其他线程，否则不会出现对象被多线程并发访问的
改，导致数据混乱。这也是缺乏经验的网站工程师最容易犯错的地方，而线程安全Bug
度；相反如果是任务需要等待磁盘操作，网络响应，那么多启动线程有助于提高任务并
计算型任务，那么线程数最多不超过CPU内核数，因为启动再多线程，CPU也来不及调
网络通信连接、线程、复杂对象等。从编程角度，资源复用主要有两种模式：单例
步顺序执行，可能会对系统性能产生严重影响。
过从面向对象设计的角度看，无状态对象是一种不良设计。
线程并发调用处理用户请求。而Web开发中常用的贫血模型对象都是些无状态对象。不
不一致，JavaWeb开发中常用的Servlet对象就设计为无状态对象，可以被应用服务器多
成员变量，或者成员变量也是无状态对象），这样多线程并发访问的时候就不会出现状态
数据库，乃至另一个线程都可能被多线程并发访问。
程执行，因为用户请求是并发提交的，也就是说，所有的资源一
题有关。对网站而言，不管有没有进行多线程编程，工程师写的每一行代码都会被多线
发度，提高系统吞吐能力，改善系统性能。
各种轻量级锁，使得运行期线程获取锁和释放锁的代价都变得更小，但是锁导致线程同
作转化为顺序操作，从而避免资源被并发修改。随着操作系统和编程语言的进步，出现
情形。
并发访问资源时使用锁：即多线程访问资源的时候，通过锁的方式使多线程并发操
多线程编程一个需要注意的问题是线程安全问题，即多线程并发对某个资源进行修
使用局部对象：即在方法内部创建对象，这些对象会被每个进入该方法的线程创建
将对象设计为无状态对象：所谓无状态对象是指对象本身不存储状态信息（对象无
系统运行时，要尽量减少那些开销很大的系统资源的创建和销毁，比如数据库连接、
编程上，解决线程安全的主要手段有如下几点。
2.
：资源复用
瞬时响应：网站的高性能架构T
一对象、内存、文件、
55
---
## Page 77
56
写和计算特性可极大优化程序的性能。
不言而喻。在不同场景中合理使用恰当的数据结构，灵活组合各种数据结构改善数据读
连接池、线程池，本质上都是对象池，即连接、线程都是对象，池管理方式也基本相同。
立的线程去处理，这方面，应用服务器也采用线程池（Thread Pool）的方式。这些所谓的
要创建新的连接。
连接，对数据库服务器而言是灾难性的，同时频繁创建关闭连接也需要花费较长的时间。
每次创建连接，数据库服务端都需要创建专门的资源以应对，因此频繁创建关闭数据库
要注意的是 Spring的单例是 Spring 容器管理的单例，而不是用单例模式构造的单例)。
就自然而然了。事实上，Java开发常用的对象容器 Spring 默认构造的对象都是单例（需
要使用贫血模式，从Service到Dao都是些无状态对象，无需重复创建，使用单例模式也
指纹求HashCode，由于字符串微小的变化就可以引起信息指纹的巨大不同，因此可以获
用场景是不能接受的，这种情况下，一个可行的方案是对字符串取信息指纹，再对信息
如字符串“AA”的HashCode是2210，字符串“AB”的HashCode是2211。这在某些应
求得Hash值，算法原型为：
高，目前比较好的字符串Hash散列算法有Time33算法，即对字符串逐字符迭代乘以33，
HashCode的随机性，即HashCode越随机散列，Hash表的冲突就越少，读写性能也就越
从对象池中获取一个空闲的连接使用，使用完毕再将该对象归还到对象池中即可，不需
据库连接对象创建好以后，将连接对象放入对象池容器中，应用程序要连接的时候，
因此在实践中，应用程序的数据库连接基本都使用连接池（ConnectionPool）的方式。
大型网站技术架构核心原理与案例分析
对象池模式通过复用对象实例，减少对象创建和资源消耗。对于数据库连接对象，
Time33虽然可以较好地解决冲突，但是有可能相似字符串的HashCode也比较接近，
前面缓存部分已经描述过Hash表的基本原理，Hash表的读写性能在很大程度上依赖
前面说过，对于每个Web请求（HTTPRequest），Web应用服务器都需要创建一个独
3.数据结构
单例虽然是GoF经典设计模式中较多被垢病的一个模式，但由于目前Web开发中主
早期关于程序的一个定义是，程序就是数据结构+算法，数据结构对于编程的重要性
hash（i)=hash（i-1)*33+str[i]
就
数
---
## Page 78
统的性能特性产生巨大影响。理解垃圾回收机制有助于程序优化和参数调优，以及编写
得较好的随机散列，如图4.16所示。
将 Eden 区和 From区还在被使用的对象复制到 To区，下一次 Young GC 则是将 Eden 区
区和To区，新建对象总是在Eden区中被创建，当Eden区空间已满，就触发一次 Young
Generation）和年老代（Old Generation），又将年轻代分为Eden区（Eden Space）、From
回收，其基本原理如图4.17所示。
其短暂，这部分对象产生的垃圾应该被更快地收集，以释放内存，这就是JIVM分代垃圾
垃圾回收就在这里进行。通过对对象生命周期的观察，发现大部分对象的生命周期都极
内存安全的代码。
收，全量回收会对系统性能产生较大影响，因此应根据系统业务特点和对象生命周期，
Generation。如果OldGeneration空间也已用完，那么就会触发FullGC，即所谓的全量回
区和To区多次复制，如果超过某个阈值对象还未被释放，则将该对象复制到Old
和To区还被使用的对象复制到From区。因此，经过多次Young GC，某些对象会在From
区都是未被使用的空间，可供继续创建对象，当Eden区再次用完，再触发一次 Young GC.
GC（GarbageCollection，垃圾回收），将还被使用的对象复制到From区，这样整个Eden
下文信息，如方法参数、局部变量等。堆则是存储对象的内存空间，对象的创建和释放
以 JVM为例，其内存主要可划分为堆（heap）和堆栈（stack）。堆栈用于存储线程上
如果Web应用运行在JVM等具有垃圾回收功能的环境中，那么垃圾回收可能会对系
在JVM分代垃圾回收机制中，将应用程序可用的堆空间分为年轻代（Young
4.垃圾回收
原始字符串
Old Generation
Young Generation
MD5
Eden Space
图4.16通过MD5计算HashCode
图4.17JVM分代垃圾回收机制
信息指纹
From
Hash计算—
4瞬时响应：网站的高性能架构-
To
HashCode
5
---
## Page 79
决一部分数据读压力，但是很多时候，磁盘仍然是系统最严重的瓶颈。而且磁盘中存储
4.4存储性能优化
磁盘震动与噪声。SSD 硬盘如图4.19所示。
位置访问数据，由于每次访问数据都需要移动磁头臂，因此机械硬盘在数据连续访问（要
应用在整个运行期间可以做到从不进行Full GC。
空间）时，由于移动磁头臂的次数相差巨大，性能表现差别也非常大。机械硬盘结构如
4.4.1
的数据是网站最重要的资产，磁盘的可用性和容错性也至关重要。
合理设置Young Generation 和Old Generation大小，尽量减少Full GC。事实上，某些Web
忆的硅晶体上，因此可以像内存一样快速随机访问。而且SSD 具有更小的功耗和更少的
图4.18所示。
访问的数据存储在连续的磁盘空间上）和随机访问（要访问的数据存储在不连续的磁盘
大型网站技术架构核心原理与案例分析
58
固态硬盘又称作 SSD 或 Flash 硬盘，这种硬盘没有机械装置，数据存储在可持久记
机械硬盘是目前最常用的一种硬盘，通过马达驱动磁头臂，带动磁头到指定的磁盘
在网站应用中，海量的数据读写对磁盘访问造成巨大压力，虽然可以通过Cache解
机械硬盘VS.固态硬盘
空气过滤片
音圈马达
其下方
永磁铁
图4.18机械硬盘结构图（图片来自互联网）
磁头臂
磁头
磁盘