### 优化后的文本

尽管您的内核已具备在多个用户级环境间切换的能力，但由于初始化设置的限制，其运行环境仍受一定约束。接下来，您需要实现必要的 JOS 系统调用，以便用户环境能够创建并启动新的用户环境。

#### Unix 的 `fork()` 系统调用
Unix 提供了 `fork()` 系统调用来创建新进程。`fork()` 通过复制父进程的整个地址空间来创建一个子进程。从用户空间的角度看，父子进程之间的唯一区别在于它们的进程 ID 和父进程 ID（分别由 `getpid` 和 `getppid` 返回）。在父进程中，`fork()` 返回子进程的 PID；而在子进程中，`fork()` 返回 0。默认情况下，每个进程拥有独立的私有地址空间，因此一个进程对内存的修改对另一个进程是不可见的。

#### JOS 系统调用的实现
为了在用户模式下创建新的环境，您需要提供一组更为原始的 JOS 系统调用。利用这些系统调用，除了可以创建其他类型的环境外，还可以在用户空间中实现一个完整的类 Unix `fork()`。以下是您需要为 JOS 编写的系统调用：

- **`sys_exofork`**:
  创建一个新的空白环境：该环境的地址空间用户部分没有任何映射，并且它不能运行。新环境与调用 `sys_exofork` 时父环境的寄存器状态完全相同。在父进程中，`sys_exofork` 返回新创建环境的 `envid_t`（如果环境分配失败，则返回负错误代码）。在子进程中，它返回 0（因为子进程一开始被标记为不可运行，在子进程中 `sys_exofork` 并不真正返回，直到其父进程显式地将其标记为可运行）。

- **`sys_env_set_status`**:
  设置指定环境的状态为 `ENV_RUNNABLE` 或 `ENV_NOT_RUNNABLE`。通常用于标记一个已经完成地址空间和寄存器状态初始化的新环境，使其准备好运行。

- **`sys_page_alloc`**:
  分配一个物理内存页，并将其映射到给定环境地址空间中的指定虚拟地址上。

- **`sys_page_map`**:
  从一个环境的地址空间复制一个页映射（而不是页内容！）到另一个环境的地址空间中，保持内存共享，使新旧映射指向同一个物理内存页。

- **`sys_page_unmap`**:
  在给定环境中取消映射指定的已映射虚拟地址。

所有上述系统调用都接受环境 ID 作为参数。JOS 内核约定使用值 "0" 表示“当前环境”，这一约定在 `kern/env.c` 中的 `envid2env()` 函数中实现。

#### 测试程序
在 `user/dumbfork.c` 中提供了一个非常基础的类 Unix `fork()` 实现。该测试程序使用上述系统调用创建并运行一个复制自身地址空间的子环境。两个环境通过 `sys_yield` 来回切换，父进程在迭代 10 次后退出，而子进程在迭代 20 次后退出。

> **练习 7**: 在 `kern/syscall.c` 中实现上述描述的系统调用，并确保 `syscall()` 能够调用它们。您将需要使用 `kern/pmap.c` 和 `kern/env.c` 中的多个函数，特别是 `envid2env()`。每次调用 `envid2env()` 时，在 `checkperm` 中传递参数 1。务必检查任何无效的系统调用参数，并在这种情况下返回 `-E_INVAL`。使用 `user/dumbfork` 测试您的 JOS 内核，并确保其正常运行后再继续。

> **小挑战！** 添加额外的系统调用，使其能够读取现有环境的重要状态并进行设置。然后实现一个能够在用户模式下 fork 子环境的程序，让其运行一段时间（即，几次 `sys_yield()`），并在几个点上截取屏幕截图或保存检查点。接着，让子环境继续运行一段时间，再将其恢复到之前的检查点状态，并从此处继续。这样，您可以有效地从中间状态“回放”子环境的运行。确保子环境与用户进行了交互（例如，通过 `sys_cgetc()` 或 `readline()`），以便用户可以查看和修改其内部状态，并通过选择性遗忘某些事件来验证检查点/重启动的有效性。

至此，您已完成实验 Part A 部分。在运行 `make grade` 之前，请确保通过了所有 Part A 的测试，并像往常一样使用 `make handin` 提交。如果您想找出特定测试失败的原因，可以运行 `run ./grade-lab4 -v`，这将显示内核构建输出和 QEMU 运行情况。当测试失败时，脚本会停止运行，您可以检查 `jos.out` 的内容以查看内核的实际输出。

### Part B: 写时复制 Fork
如前所述，Unix 使用 `fork()` 作为主要的进程创建原语。`fork()` 通过复制父进程的地址空间来创建一个新进程。xv6 Unix 的 `fork()` 复制父进程的所有数据页并分配到子进程的新页上。本质上，这种方法与 `dumbfork()` 类似，但复制父进程的地址空间是 `fork()` 操作中最昂贵的部分。

然而，在 `fork()` 后，子进程经常立即调用 `exec()` 以替换内存中的新程序。在这种情况下，复制父进程地址空间的时间是非常浪费的，因为子进程在调用 `exec()` 之前使用的内存很少。因此，现代 Unix 版本利用虚拟内存硬件的优势，允许父进程和子进程共享映射到各自地址空间上的内存，直到其中一个进程实际修改内存为止。这种技术称为“写时复制”。

在 `fork()` 时，内核复制父进程到子进程的地址空间映射，而不是所映射页的内容，并将共享页设置为只读。当任一进程尝试写入共享页时，会产生页故障。此时，内核意识到该页是“虚拟”或“写时复制”的副本，并生成一个新的、可写的私有页副本。这种方式使得 `fork()` 后跟随 `exec()` 的开销非常低，因为子进程可能只需复制一个页（当前栈页）。

在本实验的下一阶段，您将实现带有“写时复制”的“真正的”类 Unix `fork()`，作为一个常规的用户空间库。在用户空间中实现 `fork()` 和写时复制的好处是，可以使内核保持简单，从而减少出错的可能性。这也允许个别用户模式程序定义自己的 `fork()` 语义，例如代价高昂的总是复制的 `dumbfork()` 版本，或真实共享内存的版本。

#### 用户级页故障处理
用户级写时复制 `fork()` 需要知道关于写保护页上的页故障的信息，因此这是您首先需要实现的功能。对于用户级页故障处理来说，写时复制只是众多用途之一。

通常，配置地址空间使得在需要时，页故障将指示执行某些操作。例如，主流 Unix 内核在新进程的栈区域最初仅映射单个页，并按需分配和映射额外的栈页，从而使进程的栈消耗逐渐增加，并导致未映射的栈地址上发生页故障。每个进程空间区域的页故障都需要内核跟踪。例如，在栈区域中的页故障通常会分配和映射新的物理内存页。在 BSS 区域中的页故障通常会分配一个新页，填充 0 并映射它。在按需分页系统的可执行文件的文本区域中的页故障将从磁盘读取相应的二进制页并映射它。

内核跟踪大量信息，与传统 Unix 方法不同，您将决定在每个用户空间中如何处理每个页故障。用户空间中的 bug 影响较小。这种设计还带来了灵活性，允许程序员灵活定义内存区域，并在基于磁盘文件系统的文件映射和访问时使用用户级页故障处理。

##### 设置页故障服务程序
为了处理自己的页故障，用户环境需要在 JOS 内核上注册一个页故障服务程序入口。用户环境通过新的 `sys_env_set_pgfault_upcall` 系统调用来注册页故障入口。我们为 `Env` 结构增加了 `env_pgfault_upcall` 成员来记录此信息。

> **练习 8**: 实现 `sys_env_set_pgfault_upcall` 系统调用。查找目标环境的环境 ID 时，一定要启用权限检查，因为这是一个“危险的”系统调用。

##### 用户环境中的正常和异常栈
在正常运行期间，JOS 中的一个用户环境运行在正常的用户栈上：其 `ESP` 寄存器开始指向 `USTACKTOP`，推送的栈数据驻留在 `USTACKTOP-PGSIZE` 和 `USTACKTOP-1` 之间的页上。但在用户模式中发生页故障时，内核将在不同的栈上重新启动用户环境，运行用户级页故障指定的服务程序，即用户异常栈。我们将让 JOS 内核为用户环境实现自动的“栈切换”，类似于 x86 处理器在从用户模式转换到内核模式时的栈切换方式。

JOS 用户异常栈也是一页大小，其顶部定义在虚拟地址 `UXSTACKTOP` 处，因此有效字节数是从 `UXSTACKTOP-PGSIZE` 到 `UXSTACKTOP-1`。尽管运行在异常栈上，用户页故障服务程序仍可以使用 JOS 的普通系统调用来映射新页或调整映射，以修复导致页故障的各种问题。然后，用户级页故障服务程序通过汇编语言 stub 返回到原始栈上的故障代码。

每个支持用户级页故障处理的用户环境都需要使用 `sys_page_alloc()` 系统调用为其异常栈分配内存。

##### 调用用户页故障服务程序
现在，您需要修改 `kern/trap.c` 中的页故障处理代码，以处理接下来在用户模式中发生的页故障。我们将故障发生时用户环境的状态称为捕获时状态。

如果没有注册页故障服务程序，JOS 内核将像以前一样使用消息销毁用户环境。否则，内核将在异常栈上设置一个陷阱帧，看起来像是来自 `inc/trap.h` 文件中的 `struct UTrapframe`：
```
                      tf_esp` 下，而不是在 `UXSTACKTOP` 下启动一个新的栈帧。
去测试 `tf->tf_esp` 是否已经在用户异常栈上准备好，可以去检查它是否在 `UXSTACKTOP-PGSIZE` 和 `UXSTACKTOP-1`（含）的范围内。
> 
> **练习 9**、实现在 `kern/trap.c` 中的 `page_fault_handler` 的代码，要求派发页故障到用户模式故障服务程序上。在写入到异常栈时，一定要采取适当的预防措施。（如果用户环境运行时溢出了异常栈，会发生什么事情？）
> 
> 
> 
##### 用户模式页故障入口点
接下来，您需要实现汇编程序，它将调用 C 页故障服务程序，并在原始的故障指令处恢复程序运行。这个汇编程序是一个故障服务程序，它由内核使用 `sys_env_set_pgfault_upcall()` 来注册。
> 
> **练习 10**、实现在 `lib/pfentry.S` 中的 `_pgfault_upcall` 程序。最有趣的部分是返回到用户代码中产生页故障的原始位置。您将要直接返回到那里，不能通过内核返回。最难的部分是同时切换栈和重新加载 EIP。
> 
> 
> 
最后，您需要实现用户级页故障处理机制的 C 用户库。
> 
> **练习 11**、完成 `lib/pgfault.c` 中的 `set_pgfault_handler()`。