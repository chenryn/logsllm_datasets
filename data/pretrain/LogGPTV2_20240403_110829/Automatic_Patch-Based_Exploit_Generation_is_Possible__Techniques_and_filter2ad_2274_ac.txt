We create a model of the trace by raising each instruc-
tion in the trace to Vine. We ﬁrst lift each recorded in-
struction to Vine in a syntax-directed manner, e.g., if the
x86 instruction add eax, ebx is in the trace, we pro-
duce the model statement eax = eax + ebx. Next,
any operand which is not dependent upon input is re-
placed with its concrete value. Last, we assert that each
branch condition in the trace will evaluate the same way
as in the executed path.
Generating a Constraint Formula from the Modeled
Path. The resulting execution trace from P ′(i) deﬁnes a
single program path, which is also a valid model in Vine.
The constraint formula is calculated over the straight-
line model by calculating the weakest precondition [11].
We calculate the weakest precondition using the efﬁ-
cient algorithm and implementation given in Brumley
et al. [6].
Table 1 shows the rules for calculating the weakest
precondition. Each rule is read as an implication:
if
a program fragment matches the pattern shown below
the horizontal bar to the left of the turnstile (⊢), we per-
form the calculation shown on the top. The resulting
formula is to the right of the turnstile. The rules induc-
tively form an algorithm. The algorithm is initialized
with wp(P ′(i), Q), where Q is a predicate that states
3.2.3 Background: Generating a Constraint For-
mula from a CFG
In the static approach, we raise all of P ′ to Vine as the
ﬁrst step. Since we are only concerned with paths that
execute the new check, we remove Vine statements in
the model for other paths. We achieve this by comput-
ing the chop [5, 6], and then constructing the constraint
formula on the chop. Chopping is a technique which cre-
ates a smaller model that includes only those statements
relevant to executing a sync node from a given start node
in the CFG. In the static case, the start node is the input
instruction, and the sync node is the new check. The
exact algorithm we use for chopping is detailed in [5, 6].
The formula we ultimately generate is over the CFG.
Thus, a smaller, more compact CFG will generally lead
to a smaller, easier-to-solve formula.
In our experi-
ments, the time to solve formulas usually dominates
total exploit generation time, thus making formulas as
easy as possible for the decision procedure to solve is
important. Our experience has shown three common
reasons formulas may take longer to solve: 1) “dead”
code in the model where a value is computed but never
used, 2) algebraic simpliﬁcations that can be performed,
and 3) common sub-expressions that are recomputed.
We have implemented common compiler optimizations
on our modeling language to optimize the model: we re-
move dead code, perform as much algebraic simpliﬁca-
tion as possible, and remove redundant sub-expressions.
In our evaluation, we show these optimizations can dou-
ble the speed at which formulas are solved. (Note that
these optimizations can also be applied in the dynamic
case.)
The weakest precondition calculation used for the dy-
namic case applies equally well to any acyclic CFG [6].
We create an acyclic CFG by unrolling loops and recur-
sive procedures a ﬁxed number of times. Determining
how many times to unroll a loop is known to be unde-
cidable. In our evaluation, we unrolled loops only once.
The size of the generated formula is O(n2) in the
number n of vine statements in the acyclic CFG [6].
Note that enumerating each path and applying a dynamic
approach would result in a total formula O(2b) for b
branches. Therefore, even though the static approach
generates large formulas, it is more efﬁcient than simply
iterating the dynamic approach.
3.2.4 Formula Generation by Combined Static and
Dynamic Analysis
Recall that the formula must cover all instructions for
an exploitable path in order for the solver to generate
a candidate exploit. The dynamic approach considers
149
Figure 3. A graphical depiction of building
a model of combined dynamic and static
information.
only a single program path to the new check, but gen-
erates compact formulas and requires we know an input
that executes the new check. The static approach covers
more paths, but may produce larger formulas. At a high
level, the only difference between the two is that the dy-
namic approach uses a trace to generate a straight-line
program, over which we generate a formula, while the
static approach uses the program to generate a branch-
ing acyclic program, over which we generate a formula.
Thus, it should be of no surprise that the two can be com-
bined where we alternatively combine the dynamic and
static approach to select paths for formula generation.
Although both the static and dynamic approach alone
have been used previously to generate formulas, we are
the ﬁrst to propose the combined dynamic and static ap-
proach and demonstrate its feasibility in practice.
The high level intuition of a combined approach can
graphically be represented as lolly-pop shaped, as shown
in Figure 2. The combined approach offers a balance be-
tween the efﬁciency offered by single-path models pro-
duced by dynamic execution and the code coverage of-
fered by multiple-path static techniques.
Suppose we have a trace containing executed instruc-
tions 0..n. Let instruction 0 ≤ i ≤ n be a dynamic ex-
ecution, and let there be a path from i to the new check,
as shown in Figure 2. We build a combined model by
ﬁrst truncating the execution trace at instruction i to cre-
ate the “stick” end. We create the lolly end by chopping
off the program using the successor of i as the chop start
and the new check as the chop sink. The two pieces
are put together by adding the edge from i in the dy-
namic model to its successor in the static model. The
resulting model considers only the straight-line program
path up to i, then any subsequent path from i to the new
check. We then compute the weakest precondition over
the combined model.
The intuition why this works is that if we lifted the
entire chop from instruction 0 to the new check, then the
particular path taken by dynamic analysis is a path in
the chop. Therefore, the path up to some step i in the
dynamic trace to the chop is also a path. In the worst
case, all paths from i to the new check are infeasible,
i.e., there is no input that takes the path 0..i and then the
successor i + 1 to the new check. Since the combined
approach takes in two models and sequentially combines
them, the result is a model.
For example, in our evaluation of the IGMP vulner-
ability, we combine an execution path that cannot be
turned into an exploit with a chop of the procedure that
contains the new check to create a combined model.
Generating a formula and solving this model produces
a working exploit for this example, but both the pure dy-
namic and static approaches do not.
Automatic Combined Execution. Automatic com-
bined execution requires automatically deciding the mix
point. In Figure 3, the question is which point should
we choose as i. Of course one pre-requisite is we should
choose an i such that there is a path in the static model
from i to the new check. However, there still may be
many such instructions in the trace.
One straight-forward approach is to take the i closest
(in terms of CFG distance) to the new check and gen-
erate the combined model. If the formula generated on
the combined model has no exploit, we pick instruction
i − 1, and iterate.
In our experiments, we found a good heuristic that
is quicker than the iterative approach is to choose i at
procedure boundaries. Procedures are intended to per-
form a speciﬁc task independent of the remaining code.
Therefore, by mixing at procedure points, the combined
model includes overall tasks, instead of speciﬁc code
paths. One implementation advantage of choosing pro-
cedure boundaries is that it is relatively straight-forward
to implement automatic mixing: we simply set up a call
to the static model of the procedure at the desired mix
point in the trace.
3.3 Generating a Candidate Exploit from the
Constraint Formula
We use STP [16], a decision procedure that supports bit-
level operations, as a solver to generate candidate ex-
ploits from the constraint formula. When STP returns a
satisfying solution for a given constraint formula, the so-
lution provides a candidate exploit. By construction, the
satisfying assignment will ensure that inputs taking on
such satisfying assignment will make the program exe-
cution reach the point of the new check and fail the new
check.
The need for bit-level support in the solver is neces-
sary since assembly code typically makes use of bit-level
operations such as ⊕ and logical shifts. For example,
zeroing out a register r is usually not handled by a mov
r, 0, but by the equivalent xor r, r.
If the solver returns that there does not exist a satis-
fying solution for a given constraint formula, this means
150
that it is not possible to have an input going down the
paths covered in the constraint formula and failing the
check. Thus, we need to build other constraint formulas
covering other paths.
In some cases the solver may take too long to re-
turn an answer.
In this case, we set a timeout and
then move on to build other constraint formulas covering
other paths. For example, the mix point can be changed
so that fewer paths are included. In Section 4.4 we eval-
uate how the changing the mix point effects how long it
takes the solver to generate a candidate exploit.
3.4 Generating Polymorphic Exploits.
Our approach allows us to enumerate (candidate) poly-
morphic exploit variants of the paths covered by F . Sup-
pose x satisﬁes F . Let F ′(X) = F (X) ∧ (X <> x).
F ′ is satisﬁed by all inputs except x that fail the check
and execute a path in F . Therefore a satisfying answer
x′ such that F ′(x′) = true is a polymorphic (candidate)
exploit variant. This process can be repeated as desired.
3.5 Verifying a Candidate Exploit
We verify the candidate exploit x by checking if the
safety policy φ is violated when executing P (x). In our
implementation, we use an off-the-shelf dynamic-taint-
analysis-style exploit detector as a black box for φ for
memory safety vulnerabilities. Using other types of ex-
ploit detectors is also possible. The candidate exploit is
veriﬁed when the detector returns unsafe. If the veri-
ﬁer returns safe, and all paths to the new check have not
been analyzed, then we iterate the above procedure on
different code paths until an exploit is generated or all
paths are exhausted.
3.6
Implementation
Our implementation of our three approaches for creating
the constraint formulas is written in a mixture of C++
and OCaml. About 16,500 lines of C++ code is respon-
sible for raising x86 to Vine. There are about 21,000
lines of OCaml. Most of the analysis, including chop-
ping, code optimizations, and interfacing with the deci-
sion procedure is written in OCaml.
4 Evaluation
In this section, we evaluate our approach on 5 differ-
ent vulnerable Microsoft programs which have patches
available. Our experiments highlight that each approach
for constraint formula generation — dynamic, com-
bined, and static — is valuable in different settings. We
show that we can generate exploits when no public ex-
ploit is available (to the best of our knowledge) for the
ASPNet Filter, IGMP, and PNG vulnerabilities. We also
show that we can generate polymorphic exploit variants.
We focus on reporting our results on generating ex-
ploits for the new check which is exploitable, as dis-
cussed in Section 3.1. We also report the order in which
the exploitable check would be found using the least-
changed heuristic from Section 3.1.
4.1 Vulnerability and Exploit Description
DSA SetItem Integer Overﬂow Vulnerability. The
DSA SetItem routine in comctl32.dll performs memory
management similar to realloc [35]. The procedure
takes in (essentially) a pointer p, a size for each object
s, and a total number of objects n. The procedure calls
realloc(p, s ∗ n). An overﬂow can occur in the
multiplication s ∗ n, resulting in a smaller-than-expected
returned pointer size. Subsequent use of the pointer
at best causes the application to crash, and at worst,
can be exploited to hijack control of the application.
DSA SetItem can be called directly, or indirectly by a
malicious webpage via the setSlice JScript method.
In practice, this vulnerability is widely exploited on the
web either by overtly malicious sites and legitimate but
hacked web sites [29].
The patched version adds logic to protect against in-
teger overﬂow. In particular, it adds a check that over-
ﬂow never happens and the result is < 231 (i.e., always
positive).
EBDS took 371.9 seconds to perform the diff. 21
functions were found changed, and 5 new functions
were added. Given the least-changed heuristic, the ex-
ploitable check would be the 3rd check tried.
Exploit Generated: The exploits we generated caused
a denial of service attack, e.g., Internet Explorer crashed.
Any φ that can detect pointer misuse is suitable: we used
TEMU [2]. We also could specify speciﬁc memory lo-
cations to overwrite. Determining the speciﬁc address
for a successful control hijack requires predicting the
processes memory layout, which changes each time the
process is invoked. Attackers currently do this by essen-
tially repeatedly launching an attack until the memory
layout matches what the exploit expects. We similarly
repeatedly launch the attack until we achieve a success-
ful control hijack.
ASPNet Filter Information Disclosure Vulnerability
(MS06-033; Bugtraq ID#18920; CVE-2006-1300).
The ASPNet Filter DLL is responsible for ﬁltering ASP
requests for the Microsoft .NET IIS Server, and is vul-
nerable to an information disclosure attack. The module
ﬁlters sensitive folder names from a URI request during
processing so that information contained in these folders
is not disclosed upon response. These folders are auto-
matically built using ASP.NET’s default template. For
example, App Data, App Code, and Bin are used to
151
store data ﬁles, dynamically compiled code, and com-
piled assemblies, respectively. An exploit for this vul-
nerability would allow the attacker to view ﬁles under
these folders. This is a serious vulnerability because
scripts in these directories often contain sensitive infor-
mation, such as passwords, database schemas, etc. To
the best of our knowledge, there are no public exploits
for this vulnerability.
The unpatched version performs proper ﬁltering for
URI requests that use forward slashes (’/’), but not back-
slashes (’\’). The patched version ﬁxes this vulnerabil-
ity by checking for ’\’ and ﬂipping them to ’/’.
EBDS took 16.6 seconds to perform the diff. One
new function was added, along with 4 changes to exist-
ing procedures to call the new function. The exploitable
check using the least-changed heuristic would be the
ﬁrst one tried.
Exploit Generated: The exploit we generated was
able to read ﬁles in the protected directories. Currently
we do not have implemented a φ that detects such at-
tacks, so we veriﬁed the generated candidate exploit
manually.
IGMP Denial of Service Vulnerability (MS06-007;
Bugtraq ID#16645; CVE-2006-0021). The IGMP (In-
ternet Group Management Protocol) protocol is used for
managing the membership of multi-cast groups. An ex-
ploit for this vulnerability is an IGMP query packet with
invalid IP options. The invalid options can cause the
IGMP processing logic to enter an inﬁnite loop. Since
IGMP is a system-level network service, an exploit will
freeze the entire vulnerable system. The patch adds
checks in the IGMP processing routine for invalid IP op-
tions. To the best of our knowledge, there is no public
exploit for this vulnerability. 1
EBDS took 157.08 seconds to diff the patched and
unpatched tcpip.sys. The diff identiﬁed that one func-
tion was changed. Using the least-changed heuristic, the
exploitable check would be ﬁrst.
The exploit we generated successfully caused the
denial-of-service. Currently we do not have imple-
mented a φ that detects deadlock due to an inﬁnite loop,
thus we veriﬁed our candidate exploit manually.
GDI Integer Overﬂow Vulnerability (MS07-046;
Bugtraq ID#25302; CVE-2007-3034). The Windows
Graphic Device Interface (GDI) is the core engine for
displaying graphics on screen. The GDI routine respon-
sible for showing metaﬁle graphics is vulnerable to an
integer overﬂow. The integer overﬂow can subsequently
lead to a heap overﬂow, which at best causes a system
1An EBDS [13] tutorial discusses this vulnerability. However, they
do not create an exploit.
152