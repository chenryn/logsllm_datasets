End-to-end time 
w/  
shred(ms) 
154 
curl 
minizip 
23770 
openssh  158.1 
openssl  2502 
lighttpd 
501 
Avg. 
w/o 
shred(ms) 
163 
25650 
163.3 
2546 
525 
time 
increase 
5.80% 
7.90% 
3.20% 
1.75% 
4.70% 
4.67% 
Memory footprint(Max RSS) 
w/  
shred(KB) 
4520 
3004 
3908 
3892 
3364 
w/o 
shred(KB) 
5104 
3064 
4644 
3908 
3440 
size 
increase 
12.90% 
1.90% 
18.80% 
0.40% 
2.30% 
7.26% 
ments. They are neither suitable nor practical for preventing
memory abuses, which can target data or code that cannot
be jailed in these isolated environments. In addition, these
systems do not need to consider the case where the protected
execution can be exploited, whereas our design does and
enforces security checks on in-shred executions.
Memory encryption and protection: Several memory pro-
tection mechanisms were proposed before. Overshadow [27]
uses virtualization to render encrypted views of application
memory to untrusted OS, and in turn, protects application
data. Mondrian [28] is a hardware-level memory protection
scheme that enables permission control at word-granularity
and allows memory sharing among multiple protection do-
mains. Another scheme [29] provides memory encryption and
integrity veriﬁcation for secure processors. While offering
strong protection, these schemes all require hardware modiﬁ-
cations have not been adopted in real-world. In fact, this work
was partly motivated by the lack of a practical and software-
based memory protection mechanism. Recently, protecting
cryptographic keys in memory became a popular research
topic. Proposed solutions range from minimizing key exposure
in memory [30]–[32], to avoiding key presence in the RAM
by conﬁning key operations to CPUs [33], [34], GPUs [35],
and hardware transactional memory [36]. Although effective
at preventing key thefts, a major common type of memory
abuse, these works can hardly protect other types of sensitive
data or code in memory.
Dynamic information ﬂow tracking: Many previous works
have used dynamic ﬂow tracking for detecting and defending
a range of attacks, including privacy leaks [37] and control
ﬂow manipulations [38]. HiStar [39] and Flume [40] enabled
system-wide tracking. While information ﬂow tracking can be
an ideal solution to memory abuse in theory, it is arguably
difﬁcult to use in reality, especially for average programmers.
In contrast, our work takes a more practical approach to
address a less broad security issue. We aim to provide easy-
to-use primitives that help developers efﬁciently protect their
sensitive data and code.
Granular sandbox and compartmentalization: Some recent
works proposed ﬁne-grained and ﬂexible application sand-
box [15], [41] and compartmentalization [42] frameworks.
These works mainly aim at mitigating memory-related ex-
ploitations by reducing the capabilities and privileges for
untrusted or vulnerable code. In contrast, our work adopts
a reversed model of trust: code in an application is by
default untrusted and only the explicitly created and statically
veriﬁed shreds are given the extra privilege during runtime to
access the associated s-pools. However, despite the difference
between their goals and ours, shreds are related to this line of
woks for two reasons: (1) we faced a same technical challenge
of efﬁciently isolating in-process memory, and overcame it
via a new and effective approach suitable to our goal, and
(2) shreds can employ compartmentalization to achieve more
systematic mediation of untrusted code, as discussed in § III-D.
VII. CONCLUSION
We propose shreds, a set of OS-backed programming prim-
itives that addresses developers’ currently unmet needs for
ﬁne-grained, convenient, and efﬁcient protection of sensitive
memory content against in-process adversaries. A shred can be
view as a ﬂexibly deﬁned segment of a thread execution (hence
the name). Each shred is associated with a protected memory
pool, which is accessible only to code running in the shred.
Unlike previous works, shreds offer in-process private memory
without relying on separate page tables, nested paging, or even
modiﬁed hardware. Plus, shreds provide the essential data ﬂow
and control ﬂow guarantees for running sensitive code. We
have built the compiler toolchain and the OS module that
together enable threads on Linux. We demonstrated the usage
of shreds and evaluated their performance using 5 non-trivial
open source software, including OpenSSH and Lighttpd. The
results show that shreds are fairly easy to use and incur low
runtime overhead.
VIII. ACKNOWLEDGMENT
We thank the anonymous reviewers for their insightful
comments. We thank our shepherds, Robert Watson and Brent
Kang, for their guidance on the ﬁnal paper revisions. We
thank our colleagues at the National Security Institute at Stony
Brook, in particular, Mingwei Zhang, for their feedback to
the work. This project was supported by the National Science
Foundation (Grant#: CNS-1421824 and CNS-1514142) and
the Ofﬁce of Naval Research (Grant#: N00014-15-1-2378).
6969
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:17:20 UTC from IEEE Xplore.  Restrictions apply. 
Any opinions, ﬁndings, and conclusions or recommendations
expressed in this paper are those of the authors and do
not necessarily reﬂect
the views of the National Science
Foundation or the Ofﬁce of Naval Research.
REFERENCES
[1] Z. Durumeric, J. Kasten, D. Adrian, J. A. Halderman, M. Bailey,
F. Li, N. Weaver, J. Amann, J. Beekman, M. Payer et al., “The matter
of heartbleed,” in Proceedings of
the 2014 Conference on Internet
Measurement Conference. ACM, 2014, pp. 475–488.
[2] Z. Deng, B. Saltaformaggio, X. Zhang, and D. Xu, “iris: Vetting
private api abuse in ios applications,” in Proceedings of the 22Nd ACM
SIGSAC Conference on Computer and Communications Security, ser.
CCS ’15. New York, NY, USA: ACM, 2015, pp. 44–56. [Online].
Available: http://doi.acm.org/10.1145/2810103.2813675
[3] A. Bittau, P. Marchenko, M. Handley, and B. Karp, “Wedge: Splitting
applications into reduced-privilege compartments.” in NSDI, vol. 8,
2008, pp. 309–322.
[4] “Memory
domains,”
http://infocenter.arm.com/help/index.jsp?topic=
/com.arm.doc.ddi0211k/Babjdffh.html.
[5] J. Corbet, “Memory protection keys,” https://lwn.net/Articles/643797/,
May 2015.
[6] D. Hansen, “[rfc] x86: Memory protection keys,” https://lwn.net/
Articles/643617/, May 2015.
[7] C. Lattner and V. Adve, “Llvm: A compilation framework for lifelong
program analysis & transformation,” in Code Generation and Optimiza-
tion, 2004. CGO 2004. International Symposium on.
IEEE, 2004, pp.
75–86.
[8] D. Kilpatrick, “Privman: A library for partitioning applications.” in
USENIX Annual Technical Conference, FREENIX Track, 2003, pp. 273–
284.
[9] N. Provos, M. Friedl, and P. Honeyman, “Preventing privilege escala-
tion.” in USENIX Security, vol. 3, 2003.
[10] D. Brumley and D. Song, “Privtrans: Automatically partitioning pro-
grams for privilege separation,” in USENIX Security Symposium, 2004,
pp. 57–72.
[11] Y. Liu, T. Zhou, K. Chen, H. Chen, and Y. Xia, “Thwarting memory
disclosure with efﬁcient hypervisor-enforced intra-domain isolation,” in
Proceedings of the 22Nd ACM SIGSAC Conference on Computer and
Communications Security, ser. CCS ’15, 2015.
[12] F. McKeen, I. Alexandrovich, A. Berenzon, C. V. Rozas, H. Shaﬁ,
V. Shanbhogue, and U. R. Savagaonkar, “Innovative instructions and
software model for isolated execution,” in Proceedings of
the 2nd
International Workshop on Hardware and Architectural Support for
Security and Privacy. ACM, 2013, pp. 1–1.
[13] R. Wahbe, S. Lucco, T. E. Anderson, and S. L. Graham, “Efﬁcient
software-based fault isolation,” in ACM SIGOPS Operating Systems
Review, vol. 27, no. 5. ACM, 1994, pp. 203–216.
[14] “Domain access control register,” http://infocenter.arm.com/help/index.
jsp?topic=/com.arm.doc.ddi0434b/CIHBCBFE.html.
[15] R. N. Watson, J. Anderson, B. Laurie, and K. Kennaway, “Capsicum:
Practical capabilities for unix.” in USENIX Security Symposium, 2010,
pp. 29–46.
[16] “clang: a c language family frontend for llvm,” http://clang.llvm.org/.
[17] M. Castro, M. Costa, J.-P. Martin, M. Peinado, P. Akritidis, A. Donnelly,
P. Barham, and R. Black, “Fast byte-granularity software fault isolation,”
in Proceedings of the ACM SIGOPS 22nd symposium on Operating
systems principles. ACM, 2009, pp. 45–58.
[18] U. Erlingsson, M. Abadi, M. Vrable, M. Budiu, and G. C. Necula, “Xﬁ:
Software guards for system address spaces,” in Proceedings of the 7th
symposium on Operating systems design and implementation. USENIX
Association, 2006, pp. 75–88.
[19] B. Ford and R. Cox, “Vx32: Lightweight user-level sandboxing on the
x86.” in USENIX Annual Technical Conference. Boston, MA, 2008,
pp. 293–306.
[20] B. Yee, D. Sehr, G. Dardyk, J. B. Chen, R. Muth, T. Ormandy,
S. Okasaka, N. Narula, and N. Fullagar, “Native client: A sandbox for
portable, untrusted x86 native code,” in Security and Privacy, 2009 30th
IEEE Symposium on.
IEEE, 2009, pp. 79–93.
[21] “Arm 32-bit
sandbox,”
https://developer.chrome.com/native-client/
Avail-
https://developer.chrome.com/native-client/reference/sandbox
reference/sandbox internals/arm-32-bit-sandbox.
able:
internals/arm-32-bit-sandbox
[Online].
[22] Y. Zhou, X. Wang, Y. Chen, and Z. Wang, “Armlock: Hardware-based
fault isolation for arm,” in Proceedings of the 2014 ACM SIGSAC
Conference on Computer and Communications Security. ACM, 2014,
pp. 558–569.
[23] R. Strackx and F. Piessens, “Fides: Selectively hardening software
application components against kernel-level or process-level malware,”
in Proceedings of the 2012 ACM conference on Computer and commu-
nications security. ACM, 2012, pp. 2–13.
[24] J. M. McCune, B. J. Parno, A. Perrig, M. K. Reiter, and H. Isozaki,
“Flicker: An execution infrastructure for tcb minimization,” in ACM
SIGOPS Operating Systems Review, vol. 42, no. 4. ACM, 2008, pp.
315–328.
[25] J. M. McCune, Y. Li, N. Qu, Z. Zhou, A. Datta, V. Gligor, and A. Perrig,
“Trustvisor: Efﬁcient tcb reduction and attestation,” in Security and
Privacy (SP), 2010 IEEE Symposium on.
IEEE, 2010, pp. 143–158.
[26] A. M. Azab, P. Ning, and X. Zhang, “Sice: a hardware-level strongly
isolated computing environment for x86 multi-core platforms,” in Pro-
ceedings of the 18th ACM conference on Computer and communications
security. ACM, 2011, pp. 375–388.
[27] X. Chen, T. Garﬁnkel, E. C. Lewis, P. Subrahmanyam, C. A. Wald-
spurger, D. Boneh, J. Dwoskin, and D. R. Ports, “Overshadow: a
virtualization-based approach to retroﬁtting protection in commodity
operating systems,” in ACM SIGOPS Operating Systems Review, vol. 42,
no. 2. ACM, 2008, pp. 2–13.
[28] E. Witchel, J. Cates, and K. Asanovi´c, “Mondrian memory protection,”
in Proceedings of the 10th International Conference on Architectural
for Programming Languages and Operating Systems, ser.
Support
ASPLOS X. New York, NY, USA: ACM, 2002, pp. 304–316.
[Online]. Available: http://doi.acm.org/10.1145/605397.605429
[29] G. E. Suh, D. Clarke, B. Gassend, M. v. Dijk, and S. Devadas, “Efﬁcient
memory integrity veriﬁcation and encryption for secure processors,” in
Proceedings of the 36th annual IEEE/ACM International Symposium on
Microarchitecture.
IEEE Computer Society, 2003, p. 339.
[30] K. Harrison and S. Xu, “Protecting cryptographic keys from memory dis-
closure attacks,” in Dependable Systems and Networks, 2007. DSN’07.
37th Annual IEEE/IFIP International Conference on.
IEEE, 2007, pp.
137–143.
[31] Akamai Technologies, “Secure storage of private (rsa) keys,” https://lwn.
net/Articles/594923/.
[32] MSDN, “Securestring class,” https://msdn.microsoft.com/en-us/library/
system.security.securestring.aspx.
[33] T. M¨uller, F. C. Freiling, and A. Dewald, “Tresor runs encryption
securely outside ram.” in USENIX Security Symposium, 2011, pp. 17–17.
[34] L. Guan, J. Lin, B. Luo, and J. Jing, “Copker: Computing with private
keys without ram,” in 21st ISOC Network and Distributed System
Security Symposium (NDSS), 2014.
[35] G. Vasiliadis, E. Athanasopoulos, M. Polychronakis, and S. Ioannidis,
“Pixelvault: Using gpus for securing cryptographic operations,” in
Proceedings of the 2014 ACM SIGSAC Conference on Computer and
Communications Security. ACM, 2014, pp. 1131–1142.
[36] L. Guan, J. Lin, B. Luo, J. Jing, and J. Wang, “Protecting private
keys against memory disclosure attacks using hardware transactional
memory,” in Security and Privacy (SP), 2015 IEEE Symposium on, May
2015, pp. 3–19.
[37] D. Y. Zhu, J. Jung, D. Song, T. Kohno, and D. Wetherall, “Tainteraser:
protecting sensitive data leaks using application-level taint tracking,”
ACM SIGOPS Operating Systems Review, vol. 45, no. 1, pp. 142–154,
2011.
[38] G. E. Suh, J. W. Lee, D. Zhang, and S. Devadas, “Secure program
execution via dynamic information ﬂow tracking,” in Acm Sigplan
Notices, vol. 39, no. 11. ACM, 2004, pp. 85–96.
[39] N. Zeldovich, S. Boyd-Wickizer, E. Kohler, and D. Mazi`eres, “Making
information ﬂow explicit in histar,” in Proceedings of the 7th symposium
on Operating systems design and implementation. USENIX Associa-
tion, 2006, pp. 263–278.
[40] M. Krohn, A. Yip, M. Brodsky, N. Cliffer, M. F. Kaashoek, E. Kohler,
and R. Morris, “Information ﬂow control for standard os abstractions,”
in ACM SIGOPS Operating Systems Review, vol. 41, no. 6. ACM,
2007, pp. 321–334.
[41] A. Belay, A. Bittau, A. Mashtizadeh, D. Terei, D. Mazi`eres, and
C. Kozyrakis, “Dune: Safe user-level access to privileged cpu features,”
in Presented as part of the 10th USENIX Symposium on Operating
Systems Design and Implementation (OSDI 12), 2012, pp. 335–348.
7070
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:17:20 UTC from IEEE Xplore.  Restrictions apply. 
[42] R. N. Watson, J. Woodruff, P. G. Neumann, S. W. Moore, J. Anderson,
D. Chisnall, N. Dave, B. Davis, K. Gudka, B. Laurie et al., “Cheri:
A hybrid capability-system architecture for scalable software compart-
mentalization,” in Security and Privacy (SP), 2015 IEEE Symposium on.
IEEE, 2015, pp. 20–37.
7171
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:17:20 UTC from IEEE Xplore.  Restrictions apply.