We thoroughly evaluated the defense implemented in each
SSL/TLS library. Table VII presents the results of our evalu-
ation. The second column describes whether the SSL/TLS li-
brary allows embedded NULL bytes, the third column presents
the corresponding API function which is used to retrieve the
CN/SAN identiﬁer, and the fourth column describes whether
the API call also returns the length of the corresponding
CN/SAN identiﬁer. Note that this is a very important feature
since, otherwise, the application using the SSL/TLS library
cannot know where the identiﬁer string is terminating. We no-
tice that this important feature is implemented by all libraries
except JSSE. Notice though that, even though JSSE is not
returning the length of the corresponding identiﬁer, since JSSE
is written in Java, it is not vulnerable to the embedded NULL
byte attacks because Java strings are not NULL terminated.
SSL
Libraries
OpenSSL
GnuTLS
MbedTLS
MatrixSSL
JSSE
ID
CN
CN
CN
CN
SAN
CN
SAN
CN
SAN
CN
SAN
CN
SAN
Allows
Embedded
NULL?
Function / Structure Name
Returns
Length













X509 NAME get text by NID()
X509 NAME get text by OBJ()
X509 NAME get index by NID()1
X509 NAME get index by OBJ()1
X509 get ext d2i()2
gnutls x509 crt get dn by oid()
gnutls x509 crt get subject alt name()
mbedtls x509 name
mbedtls x509 sequence
x509DNattributes t
x509GeneralName t
getSubjectX500Principal()
getSubjectAlternativeNames()













CPython SSL
1followed by X509 NAME get entry()
2followed by sk GENERAL NAME value()
— Functionality not exposed to apps —
Despite the fact that SSL/TLS implementations take pre-
cautions against embedded NULL byte attacks, this doesn’t
imply that the applications using the libraries are also secure.
Indeed, applications implementing the hostname veriﬁcation
functionality must ensure that
they do not use vulnerable
functions such standard string comparison function from libc
(e.g., strcmp, strcasecmp, fnmatch), as they match
strings in NULL-termination style.
In order to evaluate the security of applications using
SSL/TLS libraries against embedded NULL byte attacks, we
conducted a manual audit against several applications. Un-
fortunately, we found several popular applications being vul-
nerable to man-in-the-middle attacks using embedded NULL
byte certiﬁcates. Some examples include FreeRadius server [8]
which is one of the most widely deployed RADIUS (Remote
authentication dial-in user service) servers, OpenSIPS [12]
which is a popular open-source SIP server, Proxytunnel [13]
which is a stealth tunneling proxy, and Telex Anticensorship
system [15] which is an open-source censorship-circumventing
software.
An important takeaway from this section is that embedded
NULL byte attacks, even though addressed at the SSL/TLS
library level, still present a very realistic and overlooked threat
for applications using these libraries.
VII. RELATED WORK
A. Securing SSL/TLS Implementations
The security analysis of different components of SSL/TLS
implementations has been examined in a large number of
projects. We provide a summary of the most related projects
below. The key difference between these projects and ours
is that none of these projects focused on automatically an-
alyzing the correctness of the hostname veriﬁcation part of
SSL/TLS certiﬁcate validation implementations. Prior works
didn’t cover analyzing hostname veriﬁcation in detail primarily
534
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:20:25 UTC from IEEE Xplore.  Restrictions apply. 
due to the hardness of accurately modeling the implementa-
tions. In this paper, we solve this problem by using automata
learning techniques and demonstrating that they can accurately
and efﬁciently infer DFA models of hostname veriﬁcation
implementations in a black-box manner.
of
SSL/TLS
in their case,
Automated Analysis
implementations.
Brubaker et al. [36] and subsequently Chen et al. [39] used
mutation-based differential testing to ﬁnd certiﬁcate validation
issues. However,
the hostname veriﬁcation
functionality of the libraries under test is disabled in order
to discover other certiﬁcate validation issues and thus, they
cannot uncover bugs discovered by our work. He et al. [52]
used static analysis to detect incorrect usage of SSL/TLS
libraries APIs. Somorovsky [61] created TLS-Attacker a tool
to fuzz the TLS implementations systematically. However,
TLS-Attacker focused on ﬁnding bugs in the protocol level
and did not analyze the hostname veriﬁcation functionalities
of SSL/TLS implementations. Finally, de Ruiter and Poll [41]
used automata learning algorithms to infer models of the
TLS protocol and manually inspected the machines to ﬁnd
bugs. Contrary to our approach, where we focus on analyzing
hostname veriﬁcation implementations,
their work focused
on the TLS state machine induced by the different messages
exchanged during the TLS handshake.
Certiﬁcate validation. Georgiev et al. [50] studied different
ways that SSL/TLS API was abused in non-browser software.
They manually identiﬁed pervasive incorrect certiﬁcate valida-
tion in different SSL/TLS implementations on which critical
software rely. Fahl et al. [45] investigated the incorrect usage
of SSL/TLS API in Android apps. However, unlike HVLearn,
none of these projects looked into the implementations of the
API functions.
Parsing X.509 certiﬁcates with embedded NULL character.
Kaminsky et al. [53] demonstrated that several hostname ver-
iﬁcation implementations mishandled embedded NULL char-
acters in X.509 certiﬁcates and can be used to trick a CA into
issuing a valid leaf certiﬁcate with the wrong subject name.
However, they found this issue manually and did not have
any automated techniques for analyzing hostname veriﬁcation
implementations. Moreover, these issues were supposed to be
ﬁxed by the SSL/TLS implementations but we ﬁnd that several
applications using incorrect APIs for extracting the identiﬁer
strings from a certiﬁcate still suffer from these vulnerabilities
as described in Section VI.
Cryptographic attacks and implementation bugs. There is
a large body of work on various cryptographic attacks on
the SSL/TLS protocol implementations. The interested reader
may consult [40] for a survey. These attacks include various
protocol based attacks [35], [43], [44], [46] as well as timing
attacks [37] and ﬂaws in pseudo-random number genera-
tors [57]. Besides cryptographic attacks, implementation bugs
may cause severe security vulnerabilities as demonstrated by
recently discovered attacks [26], [56].
535
B. Automata inference and applications
Angluin [31] invented the L
∗ algorithm for learning deter-
ministic ﬁnite automata (DFA) from membership and equiv-
alence queries. In the following years, many variations and
optimizations were developed, including the Kearns-Vazirani
algorithm used in HVLearn [54]. The interested reader can
read the paper by Balcazzar et al. [34] for a uniﬁed presen-
tation of popular algorithms. Automata learning algorithms
have been applied to infer models for various protocols such
as EMV bank cards [29], electronic passports [30], TLS
protocols [41] and TCP/IP implementations [47], [48].
Argyros et al. [33] utilized symbolic ﬁnite automata learning
algorithms to create a differential testing framework and lever-
aged it to discover bugs in Web application ﬁrewalls. While
our approach is similar in nature, we counter the problem
of large alphabets by using only the necessary symbols for
our analysis. Moreover, instead of using differential testing to
simulate equivalence queries, our approach uses an optimized
version of the Wp-method, which offers stronger correctness
guarantees.
VIII. CONCLUSION
We designed,
implemented and extensively evaluated
HVLearn, an automated black-box automata learning frame-
work for analyzing different hostname veriﬁcation imple-
mentations. HVLearn supports automated extraction of DFA
models from multiple different implementations as well as
efﬁcient differential testing of the inferred DFA models. Our
extensive evaluation on a broad spectrum of hostname veriﬁ-
cation implementations found 8 RFC violations with serious
security implications. Several of these RFC violations could
enable active man-in-the-middle attacks. We also discovered
121 unique differences on average between each pair of
inferred DFA models. In addition, given that the RFC speciﬁ-
cations are often ambiguous about corner cases, we expect
that the models inferred by HVLearn will be very useful
to the developers for checking their hostname veriﬁcation
implementations against the RFC speciﬁcations and therefore
can help in reducing the chances of undetected security ﬂaws.
We have made HVLearn open-source so that the community
can continue to build on it. The framework can be accessed
at https://github.com/HVLearn.
IX. ACKNOWLEDGMENTS
We would like to thank the anonymous reviewers for
their feedback. This work was supported by the NSF under
grants CNS-13-18415 and CNS-16-17670. Author Suphannee
Sivakorn is also partially supported by the Ministry of Science
and Technology of the Royal Thai Government. Any opinions,
ﬁndings, conclusions, or recommendations expressed herein
are those of the authors, and do not necessarily reﬂect those
of the US Government or the NSF.
REFERENCES
[1] https://gitlab.com/gnutls/gnutls/merge requests/314.
[2] https://gitlab.com/gnutls/gnutls/issues/185.
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:20:25 UTC from IEEE Xplore.  Restrictions apply. 
technotes/guides/jni/.
docs/LibFuzzer.html.
[11] libFuzzer - A Library for Coverage-guided Fuzz Testing. http://llvm.org/
[12] OpenSIPS. https://github.com/OpenSIPS/opensips.
[13] proxytunnel. http://proxytunnel.sf.net.
[14] SLOCCount. https://www.dwheeler.com/sloccount/.
[15] Telex Anticensorship. https://github.com/ewust/telex.
[16] RFC 1035 - DOMAIN NAMES - IMPLEMENTATION AND SPECI-
FICATION. https://tools.ietf.org/html/rfc1035, November 1987.
[17] RFC 1123 - Requirements for Internet Hosts – Application and Support.
https://tools.ietf.org/html/rfc1123, October 1989.
[18] RFC 2818 - HTTP Over TLS. https://tools.ietf.org/search/rfc2818, May
[3] https://gitlab.com/gnutls/gnutls/issues/187.
[4] http://www.matrixssl.org/blog/releases/matrixssl 3 9 0.
[5] https://issues.apache.org/jira/browse/HTTPCLIENT-1802.
[6] American Fuzzy Lop (AFL) Fuzzer. http://lcamtuf.coredump.cx/aﬂ/.
[7] cURL - Compare SSL Libraries.
https://curl.haxx.se/docs/ssl-
compared.html.
[8] FreeRADIUS. http://freeradius.org/.
[9] GnuTLS 3.5.10: X509 certiﬁcate API. https://goo.gl/ZSbNGb.
[10] Java Native Interface (JNI).
https://docs.oracle.com/javase/8/docs/
2000.
[19] RFC 3492 - Punycode: A Bootstring encoding of Unicode for Interna-
tionalized Domain Names in Applications (IDNA). https://tools.ietf.org/
html/rfc3492, March 2003.
[20] RFC 4985 - Internet X.509 Public Key Infrastructure Subject Alternative
https://tools.ietf.org/html/
Name for Expression of Service Name.
rfc4985, August 2007.
[21] RFC 5280 - Internet X.509 Public Key Infrastructure Certiﬁcate and
https://tools.ietf.org/html/
Certiﬁcate Revocation List (CRL) Proﬁle.
rfc5280, May 2008.
[22] RFC 5321 - Simple Mail Transfer Protocol. https://tools.ietf.org/html/
rfc5321, October 2008.
[23] RFC 5890 - Internationalized Domain Names for Applications (IDNA):
https://tools.ietf.org/html/
Deﬁnitions and Document Framework.
rfc5890, August 2010.
[24] RFC 6125 - Representation and Veriﬁcation of Domain-Based Appli-
cation Service Identity within Internet Public Key Infrastructure Using
X.509 (PKIX) Certiﬁcates in the Context of Transport Layer Security
(TLS). https://tools.ietf.org/html/rfc6125, March 2011.
[25] RFC 6818 - Updates to the Internet X.509 Public Key Infrastruc-
ture Certiﬁcate and Certiﬁcate Revocation List (CRL) Proﬁle. https:
//tools.ietf.org/html/rfc6818, January 2013.
[26] CVE-2014-0092, March 2014.
[27] CVE-2014-1492, March 2014.
[28] CVE-2015-1855, March 2015.
[29] F. Aarts, J. D. Ruiter, and E. Poll. Formal Models of Bank Cards
for Free. In Proceedings of the International Conference on Software
Testing, Veriﬁcation and Validation Workshops, pages 461–468, 2013.
Inference and Abstraction
of the Biometric Passport. In Proceedings of the International Confer-
ence on Leveraging Applications of Formal Methods, Veriﬁcation, and
Validation, pages 673–686, 2010.
[30] F. Aarts, J. Schmaltz, and F. Vaandrager.
[31] D. Angluin. Learning Regular Sets from Queries and Counterexamples.
Inf. Comput., 75(2):87–106, 1987.
[32] Apache Software Foundation. Apache HttpComponents - HttpCom-
https://hc.apache.org/httpcomponents-
ponents HttpClient Overview.
client-ga/.
[33] G. Argyros, I. Stais, S. Jana, A. D. Keromytis, and A. Kiayias. SFAD-
iff: Automated Evasion Attacks and Fingerprinting Using Black-box
Differential Automata Learning.
In Proceedings of the ACM SIGSAC
Conference on Computer and Communications Security, pages 1690–
1701, 2016.
[34] J. L. Balc´azar, J. D´ıaz, R. Gavalda, and O. Watanabe. Algorithms for
Learning Finite Automata from Queries: A Uniﬁed View, pages 53–72.
Springer, 1997.
[35] D. Bleichenbacher. Chosen ciphertext attacks against protocols based on
the RSA encryption standard PKCS# 1. In Proceedings of the Annual
International Cryptology Conference on Advances in Cryptology, pages
1–12, 1998.
[36] C. Brubaker, S. Jana, B. Ray, S. Khurshid, and V. Shmatikov. Using
Frankencerts for Automated Adversarial Testing of Certiﬁcate Validation
in SSL/TLS Implementations. In Proceedings of the IEEE Symposium
on Security and Privacy, pages 114–129, 2014.
[37] D. Brumley and D. Boneh. Remote Timing Attacks Are Practical. In
Proceedings of the USENIX Conference on Security Symposium, pages
1–1, 2003.
[38] Y. Chen and Z. Su. Guided Differential Testing of Certiﬁcate Validation
in SSL/TLS Implementations. In Proceedings of the Joint Meeting on
Foundations of Software Engineering, pages 793–804, 2015.
[39] Y. Chen and Z. Su. Guided Differential Testing of Certiﬁcate Validation
in SSL/TLS Implementations. In Proceedings of the Joint Meeting on
Foundations of Software Engineering, pages 793–804, 2015.
[40] J. Clark and P. C. van Oorschot. SoK: SSL and HTTPS: Revisiting
Past Challenges and Evaluating Certiﬁcate Trust Model Enhancements.
In Proceedings of the IEEE Symposium on Security and Privacy, pages
511–525, 2013.
[41] J. De Ruiter and E. Poll. Protocol State Fuzzing of TLS Implementa-
tions. In Proceedings of the USENIX Conference on Security Symposium,
pages 193–206, 2015.
HostnameChecker.
http://www.docjar.com/docs/api/sun/
security/util/HostnameChecker.html.
[42] Docjar.
[43] T. Duong and J. Rizzo. Here Come The ⊕ Ninjas. 2011.
[44] T. Duong and J. Rizzo. The CRIME Attack. 2012.
[45] S. Fahl, M. Harbach, T. Muders, L. Baumg¨artner, B. Freisleben, and
M. Smith. Why Eve and Mallory Love Android: An Analysis of Android
SSL (in)Security. In Proceedings of the ACM SIGSAC Conference on
Computer and Communications Security, pages 50–61, 2012.
[46] N. J. A. Fardan and K. G. Paterson. Lucky thirteen: Breaking the tls
and dtls record protocols. In Proceedings of the IEEE Symposium on
Security and Privacy, pages 526–540, 2013.
[47] P. Fiter˘au-Bros¸tean, R. Janssen, and F. Vaandrager. Learning Fragments
of the TCP Network Protocol.
In Proceedings of the International
Conference on Formal Methods for Industrial Critical Systems, pages
78–93, 2014.
[48] P. Fiter˘au-Bros¸tean, R. Janssen, and F. Vaandrager. Combining Model
Learning and Model Checking to Analyze TCP Implementations.
In
Proceedings of the International Conference on Computer Aided Veriﬁ-
cation, pages 454–471, 2016.
[49] S. Fujiwara, G. v. Bochmann, F. Khendek, M. Amalou, and
IEEE
A. Ghedamsi. Test Selection Based on Finite State Models.
Transactions on software engineering, 17(6):591–603, 1991.
[50] M. Georgiev, S.
Iyengar, S. Jana, R. Anubhai, D. Boneh, and
V. Shmatikov. The Most Dangerous Code in the World: Validating
SSL Certiﬁcates in Non-browser Software. In Proceedings of the ACM
SIGSAC Conference on Computer and Communications Security, pages
38–49, 2012.
[51] GNU Compilers. Gcov - Using the GNU Compiler Collection (GCC).
https://gcc.gnu.org/onlinedocs/gcc-4.8.1/gcc/Gcov.html.
[52] B. He, V. Rastogi, Y. Cao, Y. Chen, V. Venkatakrishnan, R. Yang, and
Z. Zhang. Vetting SSL usage in applications with SSLint. In Proceedings
of the IEEE Symposium on Security and Privacy, pages 519–534, 2015.
[53] D. Kaminsky, M. L. Patterson, and L. Sassaman. PKI Layer Cake:
New Collision Attacks Against the Global x.509 Infrastructure.
In
Proceedings of the International Conference on Financial Cryptography
and Data Security, pages 289–303, 2010.
[54] M. J. Kearns and U. V. Vazirani. An Introduction to Computational
Learning Theory. MIT Press, 1994.
[55] D. Kozen. Lower Bounds for Natural Proof Systems. In Proceedings
of the Annual Symposium on Foundations of Computer Science, pages
254–266, 1977.
[56] A. Langley. Apple’s SSL/TLS Bug. https://goo.gl/DzRLNq, 2014.
[57] A. Lenstra, J. P. Hughes, M. Augier, J. W. Bos, T. Kleinjung, and
C. Wachter. Ron was wrong, Whit is right. International Association
for Cryptologic Research, 2012.
Java Cryptography Architecture Oracle Providers Documen-
https://docs.oracle.com/javase/7/docs/technotes/guides/security/
[58] Oracle.
tation.
SunProviders.html.
[59] H. Raffelt, B. Steffen, and T. Berg. LearnLib: A Library for Automata
Learning and Experimentation.
In Proceedings of the International
Workshop on Formal Methods for Industrial Critical Systems, pages
62–71, 2005.
[60] M. Sipser. Introduction to the Theory of Computation. Thomson Course
Technology Boston, 2006.
[61] J. Somorovsky. Systematic Fuzzing and Testing of TLS Libraries.
In Proceedings of the ACM SIGSAC Conference on Computer and
Communications Security, pages 1492–1504, 2016.
536
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:20:25 UTC from IEEE Xplore.  Restrictions apply. 
A. Details of test hostname veriﬁcation implementations
X. APPENDIX
OpenSSL. has separate checking functions for each type
identiﬁers as shown in Table I. In our testing, we use the
default setup that supports matching wildcards. OpenSSL
also provides support for applications to turn some of these
hostname veriﬁcation functions on or off by calling different
setup functions (e.g., X509_VERIFY_PARAM_set1_host
and X509_VERIFY_PARAM_set1_email).
GnuTLS. The GnuTLS check hostname function is de-
signed for certiﬁcate veriﬁcation for HTTPS supporting do-
main names, IPv4, and IPv6. Like OpenSSL, GnuTLS also
provides the application to select whether to verify hostname
with wildcard or not. By default, GnuTLS wildcard matching
is enabled. We use the default setting for our experiments.
MbedTLS. The
hostname
MbedTLS only supports
veriﬁcation.
veriﬁcation
in
checking for domain name
functions
MatrixSSL. A single function matrixValidateCerts
is responsible for checking all different types of identiﬁers