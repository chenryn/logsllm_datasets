ğ‘¤ â† EA(crs, ğ‘¥, ğœ‹)
Pr
: Verify(crs, ğ‘¥, ğœ‹) = 1
âˆ§ ğ‘…(ğ‘¥, ğ‘¤) = 0
 â‰¤ ğœ–ks(ğœ…)
Session 2E: Smart Contracts and Cryptocurrencies CCS '20, November 9â€“13, 2020, Virtual Event, USA644
 (ğ‘¦, ğœ)â†A(1ğœ…)
A Î£-protocol is a simple 3-move interactive protocol used for
building very efficient ZK proof systems. We refer to [34] for a
formal definition of Î£-protocols.
2.2 Trapdoor permutations
Definition 2.2. A collection of efficiently computable functions
H (cid:66) {Hğœ… : Kğœ… Ã— {0, 1}ğœ… â†’ {0, 1}ğœ…} is said to be a family of
trapdoor permutations if for every ğœ… âˆˆ N and every ğ‘˜ âˆˆ Kğœ…, we
have that Hğœ…(ğ‘˜, Â·) is a permutation over {0, 1}ğœ…. Furthermore, there
exists a pair of ppt algorithms (H .Gen,H .Inv) where (for certain
polynomial ğ‘):
â€¢ H .Gen(1ğœ…) â†’ (ğ‘˜, ğœğ‘˜) takes as input the security parameter ğœ…
and outputs a key ğ‘˜ âˆˆ Kğœ… and a trapdoor ğœğ‘˜ âˆˆ{0, 1}ğ‘(ğœ…).
â€¢ H .Inv(ğœğ‘˜, ğ‘¦) â†’ ğ‘¥ takes as input a trapdoor and a value and
outputs another value ğ‘¥.
And such that, for every ğœ… âˆˆ N, every ğ‘¦ âˆˆ {0, 1}ğœ… and every
(ğ‘˜, ğœğ‘˜) â† H .Gen(1ğœ…), it holds Hğœ…(ğ‘˜,H .Inv(ğœğ‘˜, ğ‘¦)) = ğ‘¦. Further-
more, for every ppt adversary A, the following advantage is negli-
gible in ğœ…,
.
: Hğœ…(ğ‘˜, ğ‘¥) = ğ‘¦
AdvTPH,A(ğœ…) (cid:66) Pr
(ğ‘˜, ğœğ‘˜)â†H .Gen(1ğœ…)
ğ‘¥ â†A(ğ‘˜, ğœ)
For a fixed ğœ… âˆˆ N, we often write Hâˆ’1
2.3 Claw-freeness and collision-resistance
The notion of claw-freeness (between two functions ğ»1 and ğ»2)
captures the hardness of finding two (not necessarily different)
values ğ‘¥1 and ğ‘¥2 such that ğ»1(ğ‘¥1) = ğ»2(ğ‘¥2).
ğœ… instead of H .Inv.
Definition 2.3. A function generator FGen is a ppt algorithm
which, on input the security parameter, outputs the description of
two efficiently computable functions ğ»1 and ğ»2 with range {0, 1}ğœ….
A function generator FGen is said to be claw-free if for every ppt
adversary A, the following advantage is negligible in ğœ…,
(cid:20) (ğ»1, ğ»2) â†FGen(1ğœ…)
(cid:21)
AdvCF
(ğ‘¥1, ğ‘¥2) â†A(ğ»1, ğ»2) : ğ»1(ğ‘¥1) = ğ»2(ğ‘¥2)
FGen,A(ğœ…) (cid:66) Pr
On the other hand, collision-resistance refers to the hardness of
.
finding two different inputs with the same image.
Definition 2.4. A family of efficiently computable functions F =
{ğ¹ğœ… : {0, 1}âˆ— â†’ {0, 1}ğœ…}ğœ…âˆˆN is said to be collision-resistant if for
every ppt A the following probability is negligible in ğœ…:
AdvCRF,A(ğœ…) (cid:66) Pr(cid:2)(ğ‘¥1, ğ‘¥2)â†A(1ğœ…) : ğ¹ğœ…(ğ‘¥1) = ğ¹ğœ…(ğ‘¥2)(cid:3)
.
2.4 Encryption
Definition 2.5. A private-key encryption scheme E is a triple of
ppt algorithms E = (Gen, Enc, Dec) over a key space K, a message
space M and a ciphertext space C, where:
â€¢ Gen(1ğœ…) â†’ ğ‘˜ is a ppt algorithm that on input the security
parameter outputs a key ğ‘˜ âˆˆ K.
â€¢ Enc(ğ‘˜, ğ‘š)â†’ğ‘ is a ppt algorithm that on input a key ğ‘˜ âˆˆ K and
a message ğ‘š âˆˆ M, outputs a ciphertext ğ‘ âˆˆ C.
â€¢ Dec(ğ‘˜, ğ‘)â†’ ğ‘š is a deterministic algorithm that on input a key
ğ‘˜ âˆˆ K and a ciphertext ğ‘ âˆˆ C, outputs a message ğ‘š âˆˆ M or âŠ¥.
(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)Pr
2
(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)
 âˆ’ 1
(cid:21)
We often write Encğ‘˜(ğ‘š) and Decğ‘˜(ğ‘) instead of Enc(ğ‘˜, ğ‘š) and
Dec(ğ‘˜, ğ‘) respectively. We require an encryption scheme be correct,
that is, for every ğ‘š âˆˆ M, all ğœ… âˆˆ N and all ğ‘˜ â† Gen(1ğœ…), it holds
Decğ‘˜(Encğ‘˜(ğ‘š)) = ğ‘š.
We say an encryption scheme E has indistinguishable encryptions
in the presence of an eavesdropper if for every ppt adversary A, the
following advantage is negligible in ğœ…,
AdveavE,A(ğœ…) (cid:66)
(ğ‘š0, ğ‘š1, ğœ)â†A(1ğœ…)
ğ‘˜ â†E.Gen(1ğœ…)
ğ‘ â†$ {0, 1}; ğ‘ â† E.Encğ‘˜(ğ‘šğ‘)
ğ‘â€²â†A(ğ‘, ğœ)
: ğ‘â€² = ğ‘
,
(cid:20) ğ‘šâ†A(1ğœ…);
where the adversary is required to follow the constraint |ğ‘š0| = |ğ‘š1|.
We say an encryption scheme E is secure against one-time key
recovery if for every ppt adversary A, the following advantage is
negligible in ğœ…,
Advkey-rec
E,A (ğœ…) (cid:66) Pr
Observe that these notions of security are quite weak and both
are implied by the standard IND-CPA security (which is similar to
eav security where the adversary also interacts with an encrypting
oracle). However, both notions are sufficient for our security proofs.
ğ‘˜ â†E.Gen(1ğœ…); ğ‘˜â€²â†A(ğ‘)
ğ‘ â†E.Encğ‘˜(ğ‘š)
: ğ‘˜â€² = ğ‘˜
.
2.5 Garbled Circuits
As in [35], we follow the definitions of garbled circuits from [8],
simplifying the terminology to capture our necessities. We also
focus on projective garbling schemes and consider a verification
algorithm.
0 , ğ¿(ğ‘–)
0 , ğ‘ (ğ‘–)
1 }ğ‘–âˆˆ[ğ‘š], {ğ‘ (ğ‘–)
Definition 2.6 (Garbled circuit). A garbled circuit scheme is a triple
GC of ppt algorithms GC = (Garble, Eval, Verify) where:
1 }ğ‘–âˆˆ[ğ‘›]) on in-
â€¢ Garble(1ğœ…, ğ‘“ ) â†’ (GC, {ğ¿(ğ‘–)
put ğœ… and the description of a function ğ‘“ : {0, 1}ğ‘š â†’ {0, 1}ğ‘›,
outputs a garbled circuit, a set of ğ‘š input label pairs and a set
of ğ‘› output label pairs.
â€¢ Eval(GC, {ğ¿(ğ‘–)}ğ‘–âˆˆ[ğ‘š]) â†’{ğ‘ (ğ‘–)}ğ‘–âˆˆ[ğ‘›] on input a garbled circuit
and a set of input labels, outptus a set of output labels.
1 }ğ‘–âˆˆ[ğ‘›]) â†’ {0, 1} on in-
â€¢ Verify(GC, ğ‘“ , {ğ¿(ğ‘–)
put a garbled circuit, a function and a set of input label pairs
and a set of output label pairs, outputs a bit (1 for acceptance
and 0 for rejection).
We say a garbled circuit scheme is correct if for all polynomial-
size (in ğœ…) functions ğ‘“ : {0, 1}ğ‘š â†’ {0, 1}ğ‘› and all ğ‘¥ âˆˆ {0, 1}ğ‘š, for
ğ‘¦ = ğ‘“ (ğ‘¥), the following probability is overwhelming in ğœ…,
1 }ğ‘–âˆˆ[ğ‘š], {ğ‘ (ğ‘–)
0 , ğ‘ (ğ‘–)
0 , ğ¿(ğ‘–)
Pr
0 , ğ¿(ğ‘–)
1 }ğ‘–âˆˆ[ğ‘š], {ğ‘ (ğ‘–)
0 , ğ‘ (ğ‘–)
{ Ë†ğ‘ (ğ‘–)}ğ‘–âˆˆ[ğ‘›] â† Eval(GC, {ğ¿(ğ‘–)
1 }ğ‘–âˆˆ[ğ‘›]) â† Garble(1ğœ…, ğ‘“ )
ğ‘¥ğ‘– }ğ‘–âˆˆ[ğ‘š]) :
Ë†ğ‘ (ğ‘–) = ğ‘ (ğ‘–)
ğ‘¦ğ‘– âˆ€ğ‘– âˆˆ [ğ‘›]
(cid:34) (GC, {ğ¿(ğ‘–)
(cid:35)
.
We say a garbled circuit scheme has authenticity if for all polyno-
mial-size (in ğœ…) functions ğ‘“ : {0, 1}ğ‘š â†’ {0, 1}ğ‘› and all ğ‘¥ âˆˆ {0, 1}ğ‘š,
for ğ‘¦ = ğ‘“ (ğ‘¥), and for all ppt adversaries A, the following probability,
denoted by AdvauthGC,A(ğœ…), is negligible in ğœ…,
Pr
(cid:34) (GC, {ğ¿(ğ‘–)
1 }ğ‘–âˆˆ[ğ‘›]) â† Garble(1ğœ…, ğ‘“ )
0 , ğ‘ (ğ‘–)
ğ‘¥ğ‘– }ğ‘–âˆˆ[ğ‘š]) : ğ‘âˆ— = ğ‘ (ğ‘–âˆ—)Â¬ğ‘¦ğ‘–âˆ—
1 }ğ‘–âˆˆ[ğ‘š], {ğ‘ (ğ‘–)
(ğ‘âˆ—, ğ‘–âˆ—) â† A(ğ‘“ , ğ‘¥, GC, {ğ¿(ğ‘–)
0 , ğ¿(ğ‘–)
(cid:35)
.
Session 2E: Smart Contracts and Cryptocurrencies CCS '20, November 9â€“13, 2020, Virtual Event, USA645tS-WIÎ ,RG
A
(ğœ…) :
Trapdoor subversion witness indistinguishability. Our new notion of
WI4 requires that the system remain WI even when the adversary
generates the crs and is given a trapdoor associated with the relation
to be proven.
(crs, ğœ) â† A(ğ‘…, ğœ)
A
(ğœ…)
(ğœ…) S-WIÎ ,RG
(crs, ğœ) â† A(ğ‘…)
Game WIÎ ,RG
A
ğ‘ â†$ {0, 1}
(ğ‘…, ğœ) â† RG(1ğœ…)
crsâ† Î .CrsGen(ğ‘…)
ğ‘â€² â† AO(ğ‘…,crs,ğ‘,Â·,Â·,Â·)(crs, ğœ)
return (ğ‘â€² = ğ‘)
O(ğ‘…, crs, ğ‘, ğ‘¥, ğ‘¤0, ğ‘¤1):
ğœ‹ â† Î .Prove(ğ‘…, crs, ğ‘¥, ğ‘¤ğ‘)
if ğ‘…(ğ‘¥, ğ‘¤0) = 0 or ğ‘…(ğ‘¥, ğ‘¤1) = 0, return âŠ¥
otherwise, return ğœ‹
Definition 2.7 (tS-WI). A NI proof system Î  = (CrsGen, Prove,
Verify) with respect to a relation generator RG is trapdoor sub-
version witness indistinguishable if for all ppt A, the following
advantage is negligible in ğœ…,
Î ,A (ğœ…) (cid:66)
tS-WI
(cid:12)(cid:12)(cid:12)(cid:12)Pr(cid:104)tS-WIÎ ,RG
(ğœ…)(cid:105) âˆ’ 1
Adv
(cid:12)(cid:12)(cid:12)(cid:12)
A
.
2
3 CONTINGENT PAYMENT FROM CSP
In the work by Campanelli et al. [18], the authors explored the
idea of using the relation designed for contingent service payment
for information contingent payment. The main motivation is that
the witness indistinguishability of the underlying NI system could
be enough to completely hide the information about the secret
(thanks to the disjunctive structure on the property). Unfortunately,
Fuchsbauer showed that WI is not enough for this application [27].
More concretely, he proposed NI schemes for the CP-from-CSP
relation that are WI and can lead to completely insecure contingent
payment systems, where the buyer can learn all the information
before making the payment. In this section we show that our notion
of tS-WI is indeed enough to achieve a secure CP based on the
following relation (used in [18]):
Definition 3.1 (CP-from-CSP relation generator). Let E (cid:66) (Gen,
Enc, Dec) be an encryption scheme and let ğ‘“ : {0, 1}âˆ—â†’{0, 1} be a
predicate. Let H (cid:66) {Hğœ… : Kğœ… Ã— {0, 1}ğœ… â†’ {0, 1}ğœ…} be a trapdoor
permutation, and let F (cid:66) {Fğœ… : {0, 1}âˆ— â†’ {0, 1}ğœ…} be a hash
function family. We define the CP relation generator RGCP as:
RGCP(1ğœ…) :
(ğ‘˜, ğœğ‘˜) â† H .Gen(1ğœ…);
ğ‘…((ğ‘, ğ‘¦), ğ‘Ÿ) (cid:66) {ğ‘“ (Decğ‘Ÿ (ğ‘)) âˆ§ ğ‘¦ = Fğœ…(ğ‘Ÿ)} âˆ¨ ğ‘¦ = Hğœ…(ğ‘˜, ğ‘Ÿ);
return (ğ‘…, ğœğ‘˜)
The only difference with the relation in [18] is that we require H
be a trapdoor permutation, a technical requirement in our security
proof.