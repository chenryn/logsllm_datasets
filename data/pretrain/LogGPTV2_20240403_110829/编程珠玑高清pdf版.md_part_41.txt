的《MorcProgrammingPearls》的第13章再次出现。这些参考包含了对其正确性的简单
证明。
10.我们总是选择第一行，并使用二分之一的概率选择第二行，使用三分之一的概
bbs.theithome.com
---
## Page 226
212
部分问题的答案
率选择第三行，以此类推。在该过程结束的时候，每一行具有相同的选中概率（1n，其
中n是文件中的总行数）：
i =0
while more input 1ines
with probability 1.0/++i
choice = this {nput line
print choice
11.在“应用算法设计”一课的家庭作业中我提出了这个问题。如果学生想出的方
法能够在几分钟的CPU时间内计算出答案，他们就得零分。如果同答是“我要同我的概
率统计老师讨论”就能够得到一半的分数，而最佳答案是：
4..16之间的数值对游戏没有任何影响，所以能够忽略它们。如果在3之前选择
了1和2就能赢得游戏。这也就是3是最后选中的情况，这种情况的概率为二
分之一。因此随机顺序赢的概率为1/3。
不要被问题的陈述所迷惑。不能因为能够使用CPU时间所以你就使用CPU时
间。
12.第5.9节介绍了Kermighan和Pike的《PracticeofProgramming》.他们书中的第
同程序）。
第13章的答案
1.按此风格使用IntSet类能够实现答案12.9中的Floy算法：
void genfloyd(int m,int maxval)
int *v = new int[m];
IntSetSTL S(n,maxva1);
for （int =maxval-m；j>[]A >> no>
当m和maxval相等时，按递增顺序插入元素，这是二分查找树的最差情况。
4.链表的这个迭代插入算法比相应的递归算法要长，因为它复制了在head之后和
列表之后插入结点的案例分析：
bbs.theithome.com
---
## Page 227
部分问题的答案
213
void insert(t)
if head->va1 == t
return
if head->val> t
head = new node(t, head)
n++
return
for (p = head; p->next->val next)
if p->next->val  t
：
return
p->next =new node(t,p->next)
n++
这段代码更为简单，通过使用指向指针的指针删除了重复项：
void insert(t)
for （p=&head;（+p）->valnext）)
if (*p)->val e t
return
*p= new node(t，*p)
++U
它跟前一版本一样快。只需要对该段代码做出很小的修改就能应用在桶。答案7
将该方法应用于二分查找树中。
5.需要一个指向下一可用结点的指针，才能用单个分配替换多个分配：
node +freenode;
我们在构建类的时候分配所有需要的结点：
freenode = new node[maxelms]
在插入函数中根据需要进行删除：
if (p e 0)
p × freenode++
p->va1 = t
p->1eft = p->right = 0
else if ...
n++
在桶中使用同一技巧。答案7在二分查找树中使用了这一技巧。
6.按照递增顺序插入结点能够衡量数组和列表的查找成本，并且仅会引入很少的插
入开销，该序列将引发箱和二分查找的最差性能。
7.前一版本中为null的指针现在都将指向标记结点。在构造函数中将它初始化：
root = sentinel= new node
插入结点首先将目标值t放入标记结点，然后使用一个指针的指针（如答案4中所
介绍的）遍历树直到找到t。那时，它使用答案5中的技巧插入一个新结点。
bbs.theithome.com
---
## Page 228
214
部分问题的答案
void insert(t)
sentinel->va1= t
p=&root
while (±p)->val != t
iftval
p=&（（p）->1eft)
else
p=&（（+p)->right)
if p  sentinel
+p= freenode++
（+p）->va1=t
(+p)->1eft =(+p)->right= sentine1
n++
声明并初始化变量node：
node **p = &root;
9.使用位移替换除法，使用如下所示的伪码初始化变量：
goa1 = n/n
binshift =1
for (i = 2; ↑> binshift)
这个插入函数从该结点开始：
p = &(bin[t >> binshift])
10.可以通过混合并比较大量数据结构来表示随机集合。由于我们很清楚每个桶中
将包含多少项，例如：我们可以使用第13.2节中的结果，使用小的数组来表示多数桶中
的元素（然后当桶满时将多余的元素放入链表中）。在《CommunicationsoftheACM》1986
年5月的“ProgrammingPearls”专栏中，DonKnuth在介绍他用于文档化Pascal程序的
5章中再次提到了这篇文章。
第14章的答案
1.如果将swap中对临时变量的赋值和从中取值的语句移到循环外部，那么就能够
加快siftdown函数的执行远度。将代码移出循环，并在x[0]位置放置一个哨兵元素来替
代if=-1的测试能够进一步加快siftup函数的执行远度。
2.对书中的siftdown函数版本稍作修改就得到新的siftdown函数，使用i=l替换了
赋值i=1，并将跟n的比较替换成跟u的比较。结果，函数的运行时间为O（logu-logl)。
该段代码在O（n）时间内建立了一个堆：
bbs.theithome.com
---
## Page 229
邮分问题的答案
215
for (i = n-1; i >= 1; i--)
不变式：maxheap（i+1，n）/
siftdown(i，n)
/maxheap(i，n）*/
由于对于所有的整数I>n/2来说，maxheap（l，n）为真，因此能够将for循环中的边界
n-1更改为n/2。
3.使用答案1和2中的函数，堆排序如下所示：
for (i = n/2; i >= 1; 1--)
siftdownl(i，n)
for (i = n; 1 > 2; i--)
swap(1，1)
siftdown1(1,i-1)
它的运行时间仍然是O(nlogn)，但是比原来的堆排序的系数要小。网站（www.
Programmingpearls.com）提供了堆排序的几个实现版本。
4.在所有问题中，堆使用O(logn)过程替换O（n）过程。
a）构建哈夫曼代码的选代过程中，选择集合中的两个最小的元素，然后将它们合并
到一个新的结点中，这是通过两个extractmins加上一个insert来实现的。如果输入频率
是有序的，那么就能够在线性时间内计算哈夫曼代码，具体的实现细节留作练习。
b）使用简单算法将浮点大数和浮点小数相加可能会造成精度误差。更高级的算法总
是将集合中的两个最小的数值相加，这类似于前面提到的哈夫曼代码的算法。
c）具有百万个元素的堆（顶部是最小值）代表了目前看到的100万个最大的数值。
d）可以使用堆来表示每个文件中的下一个元素，从而合并有序文件。选代步骤从堆
中选择最小的元素并将它的后续元素插入到堆中。能够在O（logn）时间内从n个文件中
选择出要输出的下一个元素。
5.在桶数列上有一个类似于堆的结构。堆中的每个结点说明了它的子孙中最不满的
桶的剩余空间。判断在哪里放置新权时，查找会尽可能向左进行（也就是说，左边最不
满的箱中有足够的空间容纳它），只有在必要的情况下才向右执行，该操作所需要的时间
和堆的深度的O(logn）成正比。插入了权之后，重新遍历该路径将权放置在堆中。
6.磁盘上通常是通过让块i指向块i+1来实现顺序文件的。McCreight观察到如果
结点i也指向结点2i，那么最多通过O(logn)次访问就能够找到任意结点n.下面的递归
函数输出了访问的路径。
void path(n)
pren >= 0
post path to n is printed
if n mm 0
print “start at 0”
else if even(n)
bbs.theithome.com
---
## Page 230
216
部分问题的答案
path(n/2)
print “double to ",n
else
path(n-1)
注意，这和问题4.9中的程序在O（logn）步骤内计算x”是相同的。
7.修改后的二分查找从i=1开始，每次选代都将i设置为2i或2i+1，元素x[1]包含
中间元素，x[2]包含第一个四分位点，x[3]是第三个四分位点，以此类推。S.R.Mahaney
和J.1.Munro发现在O(n)时间和O(1)额外空间内将具有n元素的有序数组放入“堆查找”
中的算法。作为该方法的先驱，还考虑了将大小为2-1的有序数组复制到一个“堆查找”
数组b中：a中奇数位的元素按序进入b中后半部分的位置，逢2的位置模4得到b的
第二个四分之一位，等等。
11.C++标准模板库支持堆的make_heap、push_heap、pop_heap和sort_heap这类操
作。您可以组合这些操作以尽量简化堆排序：
nake_heap(a,a+n);
sort_heap(a,a+n);
STL同样也提供了priority_queue适配器。
第15章的答案
1.很多文档系统提供了检索出所有格式命令并查看输入的原始文本表示的方法。在
需要36秒来处理KingJamcsBible中的4460056个字符，并且最长的重复字符串中有269
个字符。如果删除每行的行号从而标准化输入文本后，长字符串就能够跨越行界，这时
最长的字符串能够达到563个字符，该程序找出这个字符串需要的运行时间和前面基本
相同。
3.由于该程序每次执行插入操作时都需要执行很多相关的查找操作，因此只有很少
一部分时间是用于内存分配的。使用专用内存分配器能够将处理时间大致减少0.06秒，
这能将这个阶段提速10%，但是只能将整个程序提速2%。
5.在C++程序中添加另一个map，从而将一系列的单词和它们的计数结合起来。在
C程序中，我们可以通过计数排序数组，然后选代它（由于一些单词的统计很大，因此
这个数组要比输入的文本小得多）。对于一般文本，我们可以使用关键字索引，保存一个
范围在1..1000的链表数组以作计数用。
7.算法书上警告过“aaaaaaaa”这类输入，即重复几千次。我发现很容易就能够计
算出处理文件中新行的程序所需的运行时间。程序需要2.09秒来处理5000个新行，8.90
bbs.theithome.com
---
## Page 231
部分问题的答案
217
秒处理10000个新行，37.90秒处理20060个新行。这个增长速度要比平方快一些，可
能和nlogzn成正比，每个都和n成比例。添加大型输入文件的两个副本可能会出现更差
的情况。
8.子数组a[i.i+M]代表了M+1个字符串。由于数组是有序的，通过在第一个和最
后一个字符串上调用comlen，我们能够很快判断出M+1个字符串中有几个相同的字符：
conlen(a[1]，a[f+M])
网站（www.Programmingpearls.com）提供了该算法的实现代码。
9.将第-个字符串读入数组c，注意其终止的位置，使用null字符结束它，然后读
入第二个字符串并结束它。跟前面一样进行排序。在扫描数组时，使用“异或”确保其
中一个字符串是在过渡点之前开始的。
14.该函数散列了k个单词，以null字符结束：
unsigned int hash(char )
unsigned int h = 0
int n
for (n±k;n> 0; p++)
h = MULT +h + +p
if (±p = 0)
return h % NHASH
网站（www.programmingpearls.com）提供的程序使用该散列函数替换Markov文本
生成算法中的二分查找，这样就将时间从O(nlogn)缩减到O(n)。程序使用散列表中的
元素列表表示方法来添加正好nwords个额外的32位整数，其中nwords是输入的单词数。
bbs.theithome.com
---