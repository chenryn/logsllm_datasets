title:Improving dependability of network configuration through policy classification
author:Sihyung Lee and
Tina Wong and
Hyong S. Kim
International Conference on Dependable Systems &Networks: Anchorage, Alaska, June 24-27 2008
Improving Dependability of Network Configuration through Policy
Classification
Sihyung Lee Tina Wong
Hyong S. Kim
Carnegie Mellon University
{sihyunglee, tinawong, hskim}@cmu.edu
Abstract
which
groups
As a network evolves over time, multiple operators
modify its configuration, without fully considering
what has previously been done. Similar policies are
defined more than once, and policies that become
obsolete after a transition are left in the configuration.
As a result,
the network configuration becomes
complicated and disorganized, escalating maintenance
costs and operator faults. We present a method called
NetPiler,
by
discovering a set ofshared features and which uses the
groupings for the configuration instead of using each
individual
removes
redundancies and simplifies the configuration while
preserving the intended behavior of the configuration.
We apply NetPiler to the routing policy configurations
from four different networks, and reduce more than
50% of BGP communities and the related commands.
In addition, we show that
the reduced community
definitions are sufficient
to satisfy changes as the
network evolves over nearly two years.
approach
common
policies
policy.
Such
an
1. Introduction
Network configuration is
a low-level, device(cid:173)
specific task. To configure a network, one needs to
configure each device in the network separately. There
can be hundreds of devices,
thus hundreds of
configuration files, each with thousands of commands.
Often, multiple files need to be modified to make a
relatively minor change in the network. This requires
the careful attention of operators since a change in one
file can potentially affect other devices or even the
whole network. These dependencies are spread across
files of multiple devices, even in a small-sized network.
its configurations become
difficult
to understand and to debug. Patches are
sometimes put into configuration files to temporarily
As a network evolves,
deal with a problem, and they are forgotten and left in
place after the problem is handled. Old configurations
often remain to ensure the network operation will work
until
the transition is complete. Configurations are
edited by multiple operators with different backgrounds
and working styles. In addition, networks are often
merged into a single network,
complicating the
combined configurations. Also, because of the low(cid:173)
level nature of configuration commands, the same high(cid:173)
level goal can be achieved in various ways
in
configurations. In other words, both technical and non(cid:173)
technical issues can degrade the quality of a network's
configuration over time.
As a result, companies spend more resources on the
daily management and operations of their networks
than on new IT services. In fact, one study has found
that 80% of IT budgets in enterprise networks are used
just to maintain the current operating environments [1].
Scheduled maintenance and upgrades can account for
more than 30% of network outages in Tier-lISPs [2].
Operator errors are common and can account for more
than 50% of failures in computer systems and networks
[3][4].
the
extracts
In this process of
underlying
Our system, called NetPiler, transforms the network
configuration into a more manageable configuration.
We define a configuration as manageable if
the
configuration is short, and if it can be extended over
time according to the changes of the network, with few
modifications.
transformation,
NetPiler
functions
and
dependencies from the network configuration and puts
them into a concise and system-independent format by
reducing any redundancy (Section 3.2). From this
format, NetPiler generates a new configuration that
takes into account complex inter-device and intra(cid:173)
device dependencies. We apply this technique to inter(cid:173)
domain routing policy configurations
to
demonstrate NetPiler
(Section 4). We evaluate the
algorithm on four production networks - two national
providers and two regional providers (Section 5). We
in order
1-4244-2398-9/08/$20.00 ©2008 IEEE
297
DSN 2008: Lee et al.
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 13:18:36 UTC from IEEE Xplore.  Restrictions apply. 
International Conference on Dependable Systems &Networks: Anchorage, Alaska, June 24-27 2008
2
are able to reduce up to 70% of the respective
commands. We also go over a few reduction types and
show that
improve the
the configuration (Section 5.3).
manageability of
Finally, we present a few ways
to improve the
algorithm (Section 6).
such simplification does
2. Related Work
3. NetPiler
We first present an overview of NetPiler and show
how we simplify a configuration for
inter-domain
routing policies and BGP communities in Section 3.1.
We describe the details of NetPiler in Section 3.2 and
its applications in Section 3.3.
3.1. Overview
as
to
can
simplify
the
so
increase
configuration
There has been a significant amount of work done to
help simplify network management. To the best of our
knowledge, this paper is the first to consider reducing a
network
its
manageability. [5][6] propose high-level configuration
languages for specific parts of a network configuration.
NetPiler finds unique clusters of elements that share
certain properties (or implement common functions) in
a network configuration. Description by element
groups
network configuration,
independent of the description language. Others have
proposed new management architectures. The 4D
architecture [7] has a central decision plane, and
CONMan [8] exposes a simple and consistent interface
to the management plane. Even with these architectures,
transforming a
we believe
configuration into a simpler form would make the
configuration easier to maintain. [9] [10] [11] identify
potential errors in configurations by comparing them to
a list of predefined rules. Although these tools are
effective for the detection of particular types of errors,
their use is tedious because the operators must list the
possible errors and customize the tools to the changes
of the network. Our tool
is more proactive and is
compatible with these approaches. We remove the
complexity and redundancies in the configuration that
can increase maintenance costs and thus operator
mistakes.
that our method of
The goal of NetPiler differs from those of other
optimization techniques found in VLSI CAD [12] and
firewalls [13]. NetPiler transforms a configuration in
order to increase the manageability and readability of
the configuration for human operators. In contrast, the
other optimization techniques are intended to speed up
a program or to reduce the complexity of the compiled
code, according to quantitative metrics. A manageable
configuration for one aspect in the configuration may
not be manageable for
and the
generation of a manageable configuration requires
domain knowledge about that aspect. Therefore, we do
not attempt to generalize the method in NetPiler for all
aspects. We show a way to enhance the general model
for the inter-domain routing policy aspect (Section 4).
another aspect,
We perform the following steps to transform a
network configuration into another
form. We first
select the element in the configuration that is subject to
the transformation. The element can be the ones that
can be grouped,
ranging from routes that can be
grouped by routing policies to packets that can be
grouped by firewall or QoS policies. We then parse the
configuration with regard to the element and construct
a graph model. The model is a bipartite graph with two
partite sets, the set of instances I and the set of their
properties P. An instance i El is joined by an edge with
a property p EP iff i has p. For example, when we
consider firewall policies, i refers to a certain collection
of packets (e.g., packets from subnet 1.1.1.0/24), and
its property p refers to the actions associated with the
packets as well as the locations where the actions take
place (e.g., sample and count the packets at router R).
We use a graph model instead of simple sets since each
instance can have multiple properties such that some of
the properties are properties of other instances as well.
A graph is easier and more natural to represent the
overlapping nature of the relationships. From the model,
we identify distinct groups of instances that share
common properties. Group A is comprised of a set of
properties PA that characterize the group, and a set of
instances lA, each of which has all the properties in PA.
For example, we may identify a group of packets i J,
i2J
i3 that are disallowed into AS]. We may identify
another group i4, is, i6 that are allowed into AS1. This
latter group of packets is tagged with IP precedence
value 5 when forwarded to an external network AS1. If
i3 },
we denote the two groups A and B,
is, i6 }, and PB={permit,
PA={discard at AS1}, lB={i4,
lP precedence 5 at AS1}. The two instance(cid:173)
set
property sets show two distinct policies associated with
packets. Finally, we generate a new configuration that
uses the groups in the specification.
lA={iJ,
i2,
Before we go into more detail, we start with a
fictional scenario to illustrate what the scheme can do.
The scenario includes routing policy configurations
using the BGP community. We first present
the
background of inter-domain routing policies as well as
the BGP community, and then the scenario.
1-4244-2398-9/08/$20.00 ©2008 IEEE
298
DSN 2008: Lee et al.
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 13:18:36 UTC from IEEE Xplore.  Restrictions apply. 
International Conference on Dependable Systems &Networks: Anchorage, Alaska, June 24-27 2008
3
3.1.1. Inter-domain Routing and BGP Communities.
The BGP is a de facto standard inter-domain routing
protocol. BGP route advertisement is selective in that
only a subset of routes received from an AS is
distributed to other ASes. This is done mainly to
implement a business relationship or to engineer traffic
between ASes [14]. The selection of routes works by
applying a route filter to the BGP session to/from the
AS. A route filter has a structure similar to the "if-then(cid:173)
else" chain in programming languages. It has a set of
conditions followed by actions. The conditions and
actions can be comprised of many different attributes in
a BGP route such as AS-path and destination prefix.
Among the attributes, the BGP community is one of the
most widely used.
for
(All
the actions). For example,
A BGP community refers to a group of routes that
share certain properties, and thus the same action is
applied to the community. A community is encoded as
a 32-bit field. A community influences the selection of
routes by having its 32-bit string tagged to the set of
route advertisements that belong to the community. If
the 32-bit string matches the condition of a route filter,
the required action is performed. A community
implements a routing policy, which is in general
described by a 3-tuple, (description of a set of routes,
actions to be taken on the routes, a set of local/remote
locations
the
prefixes received from AS 1, re-advertise, outbound
session to AS5) means that we want all
the routes
received from the inbound BGP session with AS 1 to be
re-announced to AS5. To implement the policy using a
community, a community A is added to the routes by a
route filter that is applied to the inbound direction of
BGP sessions with AS 1. The route filter has the
condition "if any prefixes", and the action "add A".
Another router filter in the outbound direction with
AS5 will announce the routes to AS5 by the condition
there exists community A", and the action
"if
"then permit". Fig. 1(a)
illustrates an example
implementation of the same policy. The shaded routers
are in our administrative domain, and the other routers
are in external networks. A line between two routers
denotes that there exists a BGP session between the
routers. A rounded rectangle represents a route filter.
The arrow within the filter
indicates the direction
where the filter is applied. The actual content of the
filter (Le. an if-then-else chain) is connected with a
dashed line. For example, router filter Zl is applied to
the routes advertised from AS 1 towards R1. The filter
adds community A to all the routes from AS 1. These
routes match the condition of Z5 and are re-announced
to AS5. Every if-then-else chain has an implicit deny
action at
the other routes are
the end. Thus, all
Zx: a route filter on Ri, applied inbound to Ri
Zy: a route filter on Ri, applied outbound from Ri
(a) The implementation of communities A and B in (b). ASes 3 and
6 are not shown for simplicity.
Comm.
1: set of routes
A
B
any from {1,2,3 }
prefixes P1 from {2}
prefixes P2 from {3}
P: common actions &
locations
Advertise to {4,5,6}
Do not advertise to {4}
(b)
Initial configuration
Comm.
1: set of routes
A
B
c
D
E
F
any from {1,2,3,13}
prefixes P1 from {2}
prefixes P2 from {3}
any from {7,8,9,13}
any from {1,2,3,7,8,9}