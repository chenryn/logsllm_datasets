`Curl_auth_create_ntlm_type3_message`会调用`Curl_ntlm_core_mk_ntlmv2_resp`来获取Type-2中得到的消息长度，在`Curl_ntlm_core_mk_ntlmv2_resp`中有如下定义：
其中，NTLMv2_BLOB_LEN定义如下：
`\#define NTLMv2_BLOB_LEN (44 -16 + ntlm->target_info_len + 4)`
可以看到这其实是一个有`target_info_len`参与的可变的值，而问题更大的是`target_info_len`是一个攻击者可控的值。当这个函数计算完len并把len写入`ntresp_len`后，外层`Curl_auth_create_ntlm_type3_message`中的拷贝逻辑则会使用这个值向ntlmbuf中复制一个很大的内存。
而不巧ntlmbuf是一个固定长度的栈上变量。因此这里会发生栈缓冲区溢出。
#### **3.1 有符号/无符号数的错误比较→防护失效**
但是上面明明有写size  两个本可避免的漏洞**
漏洞均出于人。人是代码的创造者，也是灾难的创造者。让我们简单分析一下这些漏洞是如何产生的，而它们为什么本可以避免在代码中呆那么久的时间。
图：这两个漏洞从36版本引入，一直存活到63版本（我报告时的版本）。
#### **4.1被忽视的编译器警告**
不要忽略编译器的警告。编译器之所以给出警告，正是代表着代码已经存在了歧义，虽然开发者可能有A型抽象的理解，但是运行的时候难免会变成机器遵循规则执行机器码的B型具体的解释。
其实这个问题单独抽出来就很容易想明白，有符号数与无符号数相加相减，到底代表什么？为什么描述同一个状态的缓冲区变量，一个“大小”可以是负数，而另一个“大小”却只能是正数？与其解释给自己或者小黄鸭，不如直接在代码上就规范好所有同类的东西的类型。
#### **4.2过于隐蔽的宏定义**
因为是人工审计，我习惯只在*.cc里面搜索，以至于这次差点漏过了这个缓冲区溢出（这个宏定义于.h文件中）。
它的问题出在这个宏给人的感觉就是，它就是一个常量，一个类似于#define PI 3.14的常量。但实际上它不仅值会变，而且还参与了很重要的逻辑的运算。
如果语义上要定义一个动态可变的参数，出于安全考虑，我更建议定义成函数样式，如：
    \#define LENGTH(X) (1 + 2 + (X) - 3) 
或者，只把不变的部分定义成宏，如：
    \#define HEADERLEN (1 + 2) 
    \#define SUFFIXLEN (3) 
    Len = HEADERLEN + x – SUFFIXLEN; 
这样，当代码中出现这个宏的时候，基本一眼就能看得出来至少这东西的值可能是会变化的。以免在自己动态调试的时候都可能看花眼略过去。
#### **4.3过长的函数**
最后，开发同学们可能都知道，一直会有人强调不要写一个好几百行、功能复杂的大函数，而是要把函数分离开。但是深层次原因除了这样很难阅读或维护，还有其他的嘛？这里从安全上补充一个建议：为了安全起见，建议不要写如此庞大的函数。
从安全角度来说有什么影响？就像本文的例子一样，因为函数的栈帧中有太多的局部变量，一旦某个变量发生缓冲区溢出，或者其他什么变量发生了Out of
bounds存取，极有可能会影响到其他局部变量的值。
而如果把函数分成很多小函数，即使发生了栈缓冲区溢出，因为有Stack
cookie的保护，攻击者也不太可能会直接影响到其他函数中的栈帧（因为在调用到那里前就会因为cookie不符合程序直接崩溃）。
当然，关于大函数，这一点可能是利也可能是弊。我们的例子这种，如果攻击者在函数很靠前的位置就控制了你的函数，那后面这部分代码很有可能会帮助攻击者完成更复杂的功能。当然，弊端就是根据实际情况，后面的代码也有可能会给攻击者设置障碍。
### ** 结语**
对于一些第三方组件，我们在使用的时候也许都会假定他们很安全，可能觉得它没有那么危险，但如果当它们与PHP或者其他你熟悉的软件结合起来，那后果可能都是十分严重的。
任何的远程代码执行、内存泄露，都可能造成另一个特定的攻击客户端版本的“心脏滴血”。
感谢Tencent Blade
Team和团队的技术氛围，研究和讨论中我逐渐发现，这些问题的根源很多是来源于开发者的开发习惯上。我也曾经有几年在做开发，看别人代码不那么容易，但看自己代码更难。我也写过不少有安全问题的代码，开发不易，测试不易，坚持不易。不过即使不易，我觉得仍要坚守开发的规范，这个既避免自己之后还技术债，也是对产品形象的负责，和对用户的负责。
最后，也附上CURL官方的修复方案。
（1）受影响的CURL： 低于7.63.0且开启NTLM认证的CURL  
（2）按照优先顺序立即采取以下操作之一：
A-将curl升级到版本7.64.0。  
B-将修补程序应用到您的软件上并重新编译。
PATCH
[https://github.com/curl/curl/commit/50c9484278c63b958655a717844f0721263939cc
](https://github.com/curl/curl/commit/50c9484278c63b958655a717844f0721263939cc)
PATCH
[https://github.com/curl/curl/commit/b780b30d1377adb10bbe774835f49e9b237fb9bb
](https://github.com/curl/curl/commit/b780b30d1377adb10bbe774835f49e9b237fb9bb)
C-关闭NTLM身份验证
Daniel的修补代码都十分巧妙，非常简单有效，因此除了升级，PATCH也是一个比较好的备选方案。当然，如果你不需要NTLM，关闭它是最直接的避免此漏洞的方案。
具体仍请参考curl官网公告：  
[https://curl.haxx.se/docs/CVE-2018-16890.html
](https://curl.haxx.se/docs/CVE-2018-16890.html)
[https://curl.haxx.se/docs/CVE-2019-3822.html
](https://curl.haxx.se/docs/CVE-2018-16890.html)
* * *