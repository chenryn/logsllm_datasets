Return (Ci,b : (i, b) ∈ I).
◦ Dec((Ci,b : (i, b) ∈ I), (cid:126)SK, P P ):
For (i, b) ∈ Jx, E.DecSKi,x[i] (Ci,b) → [f(cid:48)]i,b,
Return D([f(cid:48)]i,b : (i, b) ∈ Jx) = f (x).
We now begin with the proofs of security. Notice that
Malicious Authority Secure implies Message Secure since the
security requirement is the same, with the only modiﬁcation
being that the CA may be malicious in the former. There-
fore, we do not prove Message Security separately. It will
be useful to deﬁne an ordering on the elements of I (ﬁrst
by column, then by row), we can then refer to the ‘ﬁrst j’
ordered pairs without ambiguity.
Theorem 3.2. If E is a IND-CPA public-key encryption
scheme and (E, D) is a secure decomposable randomized en-
coding, W is a CPA secure Worry-Free Encryption Scheme.
Proof of Function Hiding: We deﬁne a sequence of
hybrids Hj. In the FunctionHiding experiment, recall that
the (i, b) ∈ I index of W.Enc(f, ( (cid:126)P K, σ), P P ) is:
Ci,b = E.EncP Ki,b ([f
(cid:48)
]i,b).
For Hj, instead of generating the ﬁrst j elements of I \ Jx
as above in the challenge ciphertext, generate them as:
Ci,b = E.EncP Ki,b (0m).
Since for all replaced (i, b) (which are not in Jx), the public
keys were generated by the experiment, by a standard hybrid
argument we can conclude that if (A1, A2, A3) has a non-
negligible advantage in the FunctionHiding game (H0), it
also has a non-negligible advantage in Hn.
However, notice that in the experiment Hn, the challenge
z]i,b : (i, b) ∈ Jx}
ciphertext depends only on the values {[f(cid:48)
where fz is the challenge function. By the indistinguisha-
1(x ◦ 0) =
bility requirement of the encoding, and that f(cid:48)
0|, the probability (A1, A2, A3) outputs
0(x◦0) and |f(cid:48)
f(cid:48)
z is no greater than 1/2 plus a negligible function. There-
fore, (A1, A2, A3) can not have a non-negligible advantage in
the experiment Hn if the randomized encoding satisﬁes in-
distinguishability, contradicting the previous assertion.
1| = |f(cid:48)
Proof of Hidden Credentials: Notice the scheme sat-
isﬁes the deﬁnition of hidden credentials information theo-
retically since if both user and CA are honest (as assumed
in the experiment), all elements of the public key are drawn
from the same distribution, independently of x.
Proof of Malicious Authority Security: As in the
proof of Function Hiding by going through a series of hybrids
(recall for the experiment to not abort the indices in (cid:126)P K
corresponding to elements of Jx were generated by the ex-
periment), if (A1, A2, A3, A4) has a non-negligible advantage
in the original experiment, it has a non-negligible advantage
in the modiﬁed experiment where for all (i, b) ∈ Jx the (i, b)
component of the challenge ciphertext is instead generated
as (removing dependence on the challenge function):
Ci,b = E.EncP Ki,b (0m).
Therefore, after the output of f0, f1 by A3, the challenge ci-
z]i,x[i] : i ∈ [1, n]).
phertext is publicly computable from: ([f(cid:48)
But notice this is the ﬁrst n components of the encoding:
z]i,x[i] : i ∈ [1, n]) ∪ ([f
(cid:48)
(cid:48)
z]n+1,1).
([f
1(x ◦
where fz is the challenge function. Since f(cid:48)
1) = 0k the above distribution is computationally indistin-
guishable for z = 0 or z = 1, contradicting the assumption
that A4 outputs z with non-negligible probability.
0(x ◦ 1) = f(cid:48)
4. CHOSEN-CIPHERTEXT SECURITY
In this section, we address the natural problem of pro-
viding a CCA2 Secure Worry-Free Encryption scheme. The
ﬁrst step is to precisely deﬁne what it means for a Worry-
Free Encryption scheme to be CCA2 secure.
Notice that under a chosen ciphertext attack, the obvi-
ous notion of Hidden Credentials becomes unattainable since
the adversary may simply ask for the user’s decryption of
467an encryption of the identity function (f (x) = x for all x),
which gives the adversary access to the user’s credentials.
For Function Hiding, the attacker (a malicious user) already
has the secret key and a decryption oracle doesn’t add any
functionality. The most natural setting in which to consider
chosen-ciphertext attacks is therefore Malicious Authority
Security (which implies Message Security). Recall that in
the Malicious Authority security game we assume a mali-
cious CA, the guarantee of indistinguishability should hold
as long as the authority assigns a public key that is consis-
tent with the user’s pre-processing information.
Formally, to prove CCA2 security, (A1, A2, A3, A4) are
given access to the oracle O below in the MaliciousAuthor-
ity experiment:
O(C(cid:48)) :
If queried by A4 and C = C(cid:48) return ⊥,
Else return W.Dec(C(cid:48), SK, P P ).
4.1 CCA2 Security with Random Oracles
We now provide an eﬃcient construction of CCA2 secure
Worry-Free Encryption in the random oracle model.
Intuitively, the scheme will work similarly to our previous
construction, however, due to the discrete components of the
ciphertexts, we must safeguard against the adversary reusing
parts of the challenge ciphertext in decryption queries. It is
with this motivation that we use an additional invocation of
the public-key encryption scheme (the keys of which we will
label P K∗, SK∗) which will allow us to ensure that an ad-
versary that makes a valid decryption query does not reuse
parts of the challenge ciphertext. This can be viewed as a
consistency check through all components of the ciphertext.
The random oracle proof model incorporates a function
H : {0, 1}∗ → {0, 1}l that is modeled as a random function.
The function is treated as an oracle, so any adversary must
query H directly in order to have any information about the
output H(x) for any x ∈ {0, 1}∗.
In our construction we will assume a IND-CPA secure
encryption scheme with what we call, unpredictable cipher-
texts, meaning that for any public key and any message, the
probability that the ciphertext takes a ﬁxed value should
be negligible. We point out that this is satisﬁed by most
schemes in the literature already and can be trivially ob-
tained by concatenating randomness to the ciphertext not
used during decryption. Let L(λ) be a polynomial bound
on the size of the credentials and the circuit components
(the output of Tλ, which is polynomial in the circuit size).
We use Enc(M ; R) to indicate that we run the encryp-
tion using R as randomness. For this scheme, we will let
H : {0, 1}∗ → {0, 1}l where l is an upper bound on the bits
of randomness E.Enc requires for the encryption of L(λ)+m(cid:48)
and 2m(cid:48) bit messages where m(cid:48) = Θ(λ) (one can take m(cid:48) = λ
for simplicity but this can be optimized, we will assume the
encryption scheme can take as input more randomness than
needed).
In this section, we will also assume [f ]i,b, an encoding
component will begin with the index (i, b) in plaintext and
we use (i, b) ∈ [f ]i,b to denote that [f ]i,b has this label. While
this requires the simulator in the privacy guarantee to have x
as input, it does not aﬀect our usage or indistinguishability.
We now deﬁne R:
◦ Setup(1λ):
S.KeyGen(1λ) → (V K, SignK) = (P P, M SK),
Return (P P, M SK).
◦ Pre(x, P P ):
For (i, b) ∈ Jx,E.KeyGen(1λ) → (P Ki,b, SKi,b),
E.KeyGen(1λ) → (P K∗, SK∗),
Set Σ = ((P Ki,b : (i, b) ∈ Jx), P K∗),
Set (cid:126)SK = ((SKi,b : (i, b) ∈ Jx), SK∗),
Return (Σ, (cid:126)SK).
◦ Auth(Σ = ((P Ki,b : (i, b) ∈ Jx), P K∗), x, P P )):
For (i, b) ∈ I \ Jx,
E.KeyGen(1λ) → (P Ki,b, SKi,b),
Set4 (cid:126)P K = ((P Ki,b : (i, b) ∈ I), P K∗),
S.Sign( (cid:126)P K, SignK) → σ,
Return ( (cid:126)P K, σ).
◦ CheckAuth(( (cid:126)P K, σ), Σ, x, P P ):
Check S.V erV K (σ, (cid:126)P K) = True,
For (i, b) ∈ Jx check (i, b) entry of (cid:126)P K is P Ki,b ∈ Σ.
◦ Enc(f, ( (cid:126)P K, σ), P P ):
Check S.V erV K (σ, (cid:126)P K) = True,
Tλ(f ) → ([f(cid:48)]i,b : i ∈ [1, n + 1], b ∈ {0, 1}),
For all (i, b) ∈ I: ri,b
Generate r, r∗ $←− {0, 1}m(cid:48)
For all (i, b) ∈ I:
$←− {0, 1}m(cid:48)
,
,
Ci,b = EncP Ki,b ([f(cid:48)]i,b ◦ ri,b; H([f(cid:48)]i,b ◦ ri,b ◦ r)),(†)
Set C∗ = EncP K∗ (r ◦ r∗; H({Ci,b}(i,b)∈I ◦ r ◦ r∗)),
Return ((Ci,b : (i, b) ∈ I), C∗).
◦ Dec((Ci,b : (i, b) ∈ I), C∗, (cid:126)SK):
For (i, b) ∈ Jx, E.DecSKi,b (Ci,b) → ([f(cid:48)]i,b ◦ ri,b),
Run E.DecSK∗ (C∗) → (r ◦ r∗),
For (i, b) ∈ Jx, check:
Ci,b = EncP Ki,b ([f(cid:48)]i,b ◦ ri,b; H([f(cid:48)]i,b ◦ ri,b ◦ r)),
Check C∗ = EncP K∗ (r ◦ r∗; H({Ci,b}(i,b)∈I ◦ r ◦ r∗)),
For (i, b) ∈ Jx, check (i, b) ∈ [f(cid:48)]i,b,
Return D([f(cid:48)]i,b : (i, b) ∈ Jx) = f (x).
Theorem 4.1. If E is a IND-CPA public-key encryption
scheme with unpredictable ciphertexts and (E, D) is a secure
decomposable randomized encoding, then R is an IND-CCA2
secure Worry-Free Encryption Scheme in the RO model.
Proof of Function Hiding. We begin by showing that
the above scheme is a usual Worry-Free Encryption scheme
before addressing CCA2 security. Let (A1, A2, A3) be an
adversary with non-negligible advantage in the Function-
Hiding security game for R where H is modeled as a ran-
4Format (cid:126)P K as a matrix in Mn+1×2 with (n + 1, 1) index
null followed by P K∗.
468dom oracle. We deﬁne two intermediary security games, the
modiﬁed line in the scheme is marked with (†).
◦ Let Fh1 denote the event FunctionHiding outputs 1
while interacting with (A1, A2, A3).
◦ For all (i, b) ∈ I \ Jx let the (i, b) component of the
challenge ciphertext be generated instead as:
]i,b ◦ ri,b; Ri,b)
EncP Ki,b ([f
(cid:48)
$←− {0, 1}l. Call the event this modiﬁed experiment
with Ri,b
outputs 1 with (A1, A2, A3), Fh2.
◦ For all (i, b) ∈ I \ Jx let the (i, b) component of the
challenge ciphertext be generated instead as:
EncP Ki,b (0m ◦ ri,b; Ri,b)
$←− {0, 1}l. Call the event this modiﬁed experiment
with Ri,b
outputs 1 with (A1, A2, A3), Fh3.
Lemma 4.2. Pr(Fh3) ≤ 1/2 + ν(λ) for some ν negligible.
Proof. This follows directly from the computational indis-
tinguishability requirement of decomposable encodings since
the challenge ciphertext only depends on the (i, b) ∈ Jx
components of the encoding of the challenge function and
f0(x) = f1(x), |f0| = |f1| for both challenge functions sub-
mitted by the adversary in FunctionHiding.
Lemma 4.3. | Pr(Fh3) − Pr(Fh2)| is negligible.
Proof. The above follows directly by the IND-CPA secu-
rity of Enc recall that for all indices where the ciphertext
component is modiﬁed, the public key was chosen by the
experiment, not the adversary.
Lemma 4.4. | Pr(Fh2) − Pr(Fh1)| is negligible.
z]i,b ◦ rz
Proof. Notice that unless (A1, A2, A3) queries H on in-
i,b ◦ rz where fz is the challenge function and
put [f(cid:48)
rz
i,b, rz are the corresponding randomness generated dur-
ing the challenge ciphertext query for some (i, b) ∈ I \ Jx,
the view of the adversary is identically distributed in both
games. Therefore, we can upper bound this diﬀerence by
i,b ◦ rz)
the probability that (A1, A2, A3) queries H([f(cid:48)
in the modiﬁed game of Fh2 (since up to the point of the
query, the view is identical, the probability such a query
happens is the same in both experiments).
Assume that (A1, A2, A3) queries H([f(cid:48)
i,b ◦ rz) for
some (i, b) ∈ I with non-negligible probability in the relevant
experiment for Fh2. Consider the experiment where instead
of rz
i,b being generated after the challenge index z is chosen,