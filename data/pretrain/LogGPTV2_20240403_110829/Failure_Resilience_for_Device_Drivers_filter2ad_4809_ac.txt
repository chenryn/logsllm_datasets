recovery
Virtual File System
Network Server
resend
packet
VFS
INET
Error
Network Drivers
Realtek
IntelPro
3COM
I/O 
Figure 4: Network driver recovery is done by the network
server or application, transparent to the user.
between the driver crash and the consequent restart, the
request fails and is postponed until the driver is back.
Upon notiﬁcation by the data store, the network server
checks its tables to ﬁnd out if the driver update concerns
a new driver or a recovered one, and in the latter case,
starts its internal recovery procedure. This procedure
closely mimics the steps that are taken when the driver
is ﬁrst started. The Ethernet driver is reinitialized to put
it in promiscuous mode and told to resume I/O. The Eth-
ernet driver is stateless and does not need to retrieve lost
state from the data store—although it could do so, were
that necessary.
6.2 Recovering Block Drivers
We now zoom in on block device driver crashes and
describe the recovery procedure as implemented by the
native MINIX 3 ﬁle server, MFS. If a disk driver (such
as the hard disk, RAM disk, CD-ROM, or ﬂoppy driver)
crashes, transparent recovery without loss of data is pos-
sible, since disk block I/O is idempotent. If I/O was in
progress at the time of the failure, the IPC rendezvous
will be aborted by the kernel, and the ﬁle server marks
the request as pending. Then, the ﬁle server blocks and
waits until the disk driver has been restarted and pending
I/O requests can be retried, as illustrated in Fig. 5.
In contrast to other drivers, disk driver recovery is
currently not policy driven, since that would require
reading the recovery script from disk. Instead, the rein-
carnation server directly restarts failed disk drivers from
a copy in RAM.1 Like the other drivers in our system,
disk drivers are stateless and do not need to retrieve lost
state from the data store, although they could were that
necessary. Once the driver has been restarted, the rein-
carnation server publishes the new IPC endpoint in the
data store and the ﬁle server is notiﬁed. At this point,
the ﬁle server updates its device–driver mappings, and
1If policy-driven recovery is needed for disk drivers, the system can
be conﬁgured with a dedicated RAM disk to provide trusted storage for
crucial data, such as the driver binaries, the shell, and policy scripts.
We have written a small 450-line RAM disk driver for this purpose.
37th Annual IEEE/IFIP International Conference on Dependable Systems and Networks (DSN'07)0-7695-2855-4/07 $20.00  © 2007End User
Applications
vim
ls
find
Virtual File System
VFS
File Servers
redo
I/O
MFS
FAT
redo
I/O
Error
Block Drivers
S−ATA
RAM
Floppy
I/O 
Figure 5: Block device driver recovery is done by the ﬁle
server, transparent to applications and users.
reinitializes the disk driver by reopening minor devices,
if needed. Finally, the ﬁle server checks whether there
are any pending I/O requests, and if so, it reissues the
failed disk operations. At this point the ﬁle server re-
sumes normal operation and continues to handle pend-
ing I/O requests from other user applications.
As an aside, our design is meant to provide recov-
ery in the event of driver crashes, but is not designed
to detect silent data corruption, as discussed in Sec. 3.
While the TCP protocol automatically eliminates this
problem for network driver crashes, disk driver crashes
can potentially corrupt the data on disk. However, our
design may be combined with end-to-end checksums,
as in IRON ﬁle systems [33], to prevent data corruption.
6.3 Recovering Character Drivers
Character device drivers cannot be transparently re-
covered, since it is impossible to tell whether data was
lost. Deciding which part of the data stream was suc-
cessfully processed and which data is missing is an un-
decidable problem. If an input stream is interrupted due
to a device driver crash, input might be lost because it
can only be read from the controller once. Likewise, if
an output stream is interrupted, there is no way to tell
how much data has been output to the controller, and
full recovery is also not possible. Therefore, such fail-
ures are reported to the application layer where further
recovery might be possible, as illustrated in Fig. 6.
End User
Applications
hiccups
cd burn
failed
retry
mp3
cdr
lpd
redo
job
Virtual File System
VFS
Error
Character Drivers
Audio
SCSI
Printer
I/O 
Figure 6: Recovery for character device drivers. Errors are
always pushed up, but need to be reported the user only if the
application cannot recover.
For historical reasons, most applications assume that
a driver failure is fatal and immediately give up, but our
prototype in fact supports continuous operation when
applications are made recovery-aware. For example, it
may be possible to modify the printer daemon such that
it automatically reissues failed print requests (without
bothering the user). While transparent recovery is not
possible—duplicate printouts may result in this case—
the user beneﬁts from this approach. As another exam-
ple, an MP3 player could continue playing a song after a
driver recovery at the risk of small hiccups. Only when
the application layer cannot handle the failure, the user
needs to be informed. For example, continuing the CD
or DVD burn process if the SCSI driver fails will most
certainly produce a corrupted disc, so the error must be
reported to the user.
7 EXPERIMENTAL EVALUATION
We have evaluated our recovery mechanisms in various
ways. First, we discuss the performance overhead intro-
duced by our recovery mechanisms. Then, we report on
the results of software fault-injection. Finally, we quan-
tify the reengineering effort needed to prototype our re-
covery mechanisms in MINIX 3.
7.1 Performance Overhead
To determine the performance overhead introduced
by our
recovery mechanisms we simulated driver
crashes while I/O was in progress and compared the
performance to the performance of an uninterrupted I/O
transfer. We performed this test for both block device
and network drivers. The crash simulation was done us-
ing a tiny shell script that ﬁrst initiates the I/O transfer,
and then repeatedly looks up the driver’s process ID and
kills the driver using a SIGKILL signal. The test was run
with varying intervals between the simulated crashes.
The recovery policy that was used for these tests directly
restarts the driver without introducing delays. After the
transfer we veriﬁed that no data corruption took place.
In all cases, full recovery transparent to the application
and without user intervention was possible.
We ﬁrst measured the overhead for the recovery of
network drivers using the RealTek 8139 Ethernet driver.
In this case, we initiated a TCP transfer using the wget
utility to retrieve a 512-MB ﬁle from the Internet. We
ran multiple tests with the period between the simulated
crashes ranging from 1 to 15 seconds. In all cases, wget
successfully completed, with the only noticeable differ-
ence being a small performance degradation as shown
in Fig. 7. To verify that the data integrity was preserved,
we compared the MD5 checksums of the received data
37th Annual IEEE/IFIP International Conference on Dependable Systems and Networks (DSN'07)0-7695-2855-4/07 $20.00  © 2007the original ﬁle. The mean recovery time for the Real-
Tek 8139 driver failures is 0.48 sec, which is, in part,
due to the TCP retransmission timeout. The uninter-
rupted transfer time is 47.41 sec with a throughput of
10.8 MB/s. The interrupted transfer times range from
47.85 sec to 62.98 sec with a throughput of 10.7 MB/s
and 8.1 MB/s, respectively. The loss in throughput due
to Ethernet driver failures ranges from 25% to just 1%
in the best case.
)
s
/
B
M
(
e
t
a
R
r
e
f
s
n
a
r
T
 12
 10
 8
 6
 4
 2
 0
 0
 2
 Uninterrupted Transfer
 With Driver Recovery
 6
 4
 12
Network Driver Kill Interval (s)
 10
 8
 14
 16
Figure 7: Networking throughput when using wget retrieve
a 512-MB ﬁle from the Internet while repeatedly killing an
Ethernet driver with various time intervals.
We also measured the overhead of disk driver recov-
ery by repeatedly sending a SIGKILL signal to the SATA
hard disk driver while reading a 1-GB ﬁle ﬁlled with
random data using dd. The input was immediately redi-
rected to sha1sum to calculate the SHA-1 checksum.
Again, we killed the driver with varying intervals be-
tween the simulated crashes. The data transfer success-
fully completed in all cases with the same SHA-1 check-
sum. The transfer rates are shown in Fig. 8. The un-
interrupted disk transfer completed in 31.33 sec with
a throughput of 32.7 MB/sec. The interrupted trans-
fer shows a transmission time ranging from 83.06 sec
to 34.73 sec, with a throughput of 12.3 MB/s and 30.5
MB/s, for simulated crashes every 1 and 15 sec, respec-
tively. The performance overhead of disk driver recov-
ery ranges from 62% to about 7% in this test. The higher
recovery overhead compared to the previous experiment
is due to the much higher I/O transfer rates.
)
s
/
B
M
(
t
e
a
R
r
e
f
s
n
a
r
T
 40
 35
 30
 25
 20
 15
 10
 5
 0
Uninterrupted Transfer
With Driver Recovery
 0
 2
 4
 6
 8
 10
 12
 14
 16
Disk Driver Kill Interval (s)
Figure 8: Throughput of uninterrupted disk transfers and
throughput in case of repeated disk driver failures while read-
ing a 1-GB ﬁle using dd.
7.2 Fault-Injection Testing
To test the capability of our system to withstand and
recover from driver failures, we also simulated failures
in our drivers by means of software fault-injection. We
based our experiments on two existing fault injectors
that mutate binary code [32, 39, 40]. This kind of fault
injection was shown to be most representative for real
failures [29]. We used the following seven fault types:
(1) change source register, (2) change destination reg-
ister, (3) garble pointer, (4) use current register value
instead of paramater passed, (5) invert termination con-
dition of a loop, (6) ﬂip a bit in an instruction, or (7)
elide an instruction. These faults emulate programming
errors common to operating system code [11, 37].
The fault-injection experiments demonstrated that
our design can successfully recover from common, tran-
sient failures and provide continuous operation. One ex-
periment run inside the Bochs PC emulator 2.2.6 tar-
geted the DP8390 Ethernet driver and repeatedly in-
jected 1 randomly selected fault into the running driver