# Google Chromium CVE-2019-5826 UAF分析
##### 译文声明
本文是翻译文章
译文仅供参考，具体内容表达以及含义原文为准。
## 简介
CVE-2019-5826是Google Chrome里IndexedDB中的Use-after-free漏洞，在版本73.0.3683.86之前该漏洞允许攻击者通过 **搭配render的RCE漏洞** 来造成UAF并 **沙箱逃逸** 。
## 一、环境搭建
笔者所使用的chrome版本为`73.0.3683.75`（[源码](https://source.chromium.org/chromium/chromium/src/+/refs/tags/73.0.3683.75:content/browser/indexed_db/indexed_db_database.cc)）。下载源码
**并打上patch** ，之后编译运行即可patch如下。至于为什么要打上patch，笔者将在下面详细介绍。
    // third_party/blink/renderer/modules/indexeddb/web_idb_factory_impl.cc
    void WebIDBFactoryImpl::Open(
           std::make_unique(
               base::WrapUnique(database_callbacks));
       DCHECK(!name.IsNull());
       factory_->Open(GetCallbacksProxy(std::move(callbacks_impl)),
                      GetDatabaseCallbacksProxy(std::move(database_callbacks_impl)),
                      name, version, transaction_id);
    +  if (version == 3) {
    +    mojom::blink::IDBCallbacksAssociatedPtrInfo ptr_info;
    +    auto request = mojo::MakeRequest(&ptr_info);
    +    factory_->DeleteDatabase(std::move(ptr_info), origin, name, true);
    +    factory_->AbortTransactionsForDatabase(origin, base::OnceCallback());
    +  }
     }
从[chrome源码](https://source.chromium.org/chromium/chromium/src/+/refs/tags/73.0.3683.75:content/browser/indexed_db/indexed_db_database.cc)中依次复制
  * `indexed_db_database.cc`
  * `indexed_db_factory_impl.cc`
  * `web_idb_factory_impl.cc`
  * `indexed_db_connection.cc`
等文件中的源码，并将其保存至当前目录中的`chromeSrc`文件夹。这样做的目的是 **为了在调试时可以使用源代码** 。
> 没有源码的调试chrome实在是太痛苦了QwQ
老样子，使用gdb脚本来辅助调试
    # gdbinit
    # 读取符号
    file ./chrome
    # 设置启动参数
    set args http://localhost:8000/test.html
    # 设置源码路径
    directory chromeSrc/
    # 设置执行fork后继续调试父进程
    set follow-fork-mode parent
> 这里没有设置`--headless`，是因为chrome **单次刷新页面的速度比gdb重启chrome的速度快上很多**
> ，这样每次修改完`exploit/poc`后只需点击刷新即可。
输入以下命令即可开启调试
    gdb -x gdbinit
如果执行时提示`No usable sandbox!`，执行以下命令
    sudo sysctl -w kernel.unprivileged_userns_clone=1
**机器重启后该命令将会失效** ，届时需要重新执行。
## 二、IndexedDB简介
Chrome中IndexedDB的大部分是在浏览器进程中实现。 浏览器和渲染中都存在几个不同的mojo
IPC接口，用于进程之间的通信，并且使得沙盒渲染能够执行IndexedDB的操作。
IndexedDBFactory
[mojo接口](https://source.chromium.org/chromium/chromium/src/+/master:third_party/blink/public/mojom/indexeddb/indexeddb.mojom)是渲染的主要入口点。
**大多数操作（打开、关闭数据库等）都是通过IndexedDBFactory实例来进一步操作IndexedDatabase实例** （注意这句话）。
IndexedDB有关于数据库和连接的概念。 对于Chrome-IndexedDB，分别由`IndexedDBDatabase`和`IndexedDBConnection`类表示。 在某一时间段内可以
**存在对同一数据库的多个连接** ，但是每个数据库 **只有一个IndexedDBDatabase对象** 。
另一个要理解的重要概念是 **请求。 打开和删除数据库操作不可能同时发生** ，但会规划执行相应操作的请求。
通过`IndexedDBDatabase::OpenRequest`
和`IndexedDBDatabase::DeleteRequest`类可以实现这些功能。
>
> `OpenRequest`类和`DeleteRequest`类是声明在`IndexedDBDatabase`类中的，换句话说这两个类都是`IndexedDBDatabase`类的子类。
IndexedDBDatabase对象是一种 **引用计数（Reference counted）的对象** 。
针对该对象的计数引用被保存在IndexedDBConnection对象、IndexedDBTransaction对象或其他正在进行或待处理的请求对象中。
一旦引用计数降至0，会立即释放对象。
释放数据库对象后， **会从数据库映射中删除指向IndexedDBDatabase的相应原始指针** ，这点非常重要。
我们顺便简单了解一下IndexDB的`JS API`
    dbName = "mycurrent";
    // 打开一个数据库，其中数据库名称为dbName，2为数据库版本
    // 返回一个requests，这个request在这里应该是OpenRequest
    var request = indexedDB.open(dbName, 2);
    // onsuccess是该request处理完成后所执行的回调函数
    request.onsuccess = function (event) {
      // 当该request执行成功后，request中的result成员为所打开的数据库对象
      db = request.result;
    }
    // 关闭一个数据库
    var deleteRequest = indexedDB.deleteDatabase(dbName);
> 具体IndexedDB 的细节我们将在下节详细讲解。
## 三、漏洞分析
###  1\. connections_成员变量
在讲解漏洞代码之前，我们先了解一下`IndexedDBDatabase::connections_`成员变量。`connections_`集合存储着
**当前连接至`IndexedDatabase`的所有连接**。当有新connection连接至数据库，或某个connection被中断时，该`connections_`变量都会被修改（执行insert或remove函数）。而该关键变量是一个`list_set`类型的成员。
    class CONTENT_EXPORT IndexedDBDatabase {
        // ...
        private:
          list_set connections_;
        // ...
`list_set`类型是`list`与`set`的结合体，这里我们只需关注该结构体的`end`函数。
    iterator end() { return iterator(list_.end()); }
可以看到，`list_set::end`函数返回的是 **list的迭代器** 。
### 2\. database _map_ 成员变量
该成员变量保存了所有指向打开的`IndexedDatabase`的 **原始指针**
> 注意，直接使用C++的原始指针通常是一个比较危险的事情。
    class CONTENT_EXPORT IndexedDBFactoryImpl : public IndexedDBFactory {
     // ...
     private:
      // ...
      std::map database_map_;
    }
当打开一个新的数据库时，指向该数据库的原始指针将会被添加进`database_map_`中；同样当关闭一个数据库时，指向该数据库的原始指针将会从`database_map_`中被移除。
###  3\. 漏洞流程
####  a. “悬垂”指针
我们先来简单了解一下删除数据库的流程。
当JS中执行`indexedDB.deleteDatabase`函数时，通过render与chrome之间的IPC通信，chrome进程会执行[IndexedDBFactoryImpl::DeleteDatabase](https://source.chromium.org/chromium/chromium/src/+/refs/tags/73.0.3683.75:content/browser/indexed_db/indexed_db_factory_impl.cc;l=492;bpv=0;bpt=1)函数，在该函数中，程序会进一步调用对应`IndexedDBDatabase`的`DeleteDatabase`函数来处理对应的数据库。
    void IndexedDBFactoryImpl::DeleteDatabase(
            const base::string16& name,
            scoped_refptr callbacks,
            const Origin& origin,
            const base::FilePath& data_directory,
            bool force_close) {
      IDB_TRACE("IndexedDBFactoryImpl::DeleteDatabase");
      // 每个IndexedDatabase在IndexedDBFactoryImpl类中都有对应唯一的idntifier
      // 该函数通过数据库名称来获取identifier并进一步在database_map中查找对应的IndexedDatabase指针
      IndexedDBDatabase::Identifier unique_identifier(origin, name);
      const auto& it = database_map_.find(unique_identifier);
      if (it != database_map_.end()) {
        // 如果找到了对应的数据库，则执行该数据库的DeleteDatabase函数
        it->second->DeleteDatabase(callbacks, force_close);
        return;
      }
      // ...
在[IndexedDBDatabase::DeleteDatabase](https://source.chromium.org/chromium/chromium/src/+/refs/tags/73.0.3683.75:content/browser/indexed_db/indexed_db_database.cc;l=1862)中，程序会添加一个`DeleteRequest`到当前`IndexedDatabase`中的待处理请求列表中，当数据库处理到`DeleteRequest`时，数据库就会马上关闭。这样做的目的是为了
**在剩余的请求（`DeleteRequest`前的所有请求）全部处理完之后，再关闭当前数据库**。
    void IndexedDBDatabase::DeleteDatabase(
        scoped_refptr callbacks,
        bool force_close) {
      AppendRequest(std::make_unique(this, callbacks));
      // Close the connections only after the request is queued to make sure
      // the store is still open.
      if (force_close)
        ForceClose();
    }
但是倘若
**设置了`force_close`标志**后，则程序将会进一步执行`ForceClose`函数来强制关闭所有的`request`和`connection`。但是，第二段
**用于遍历关闭连接的代码** 在修改`connections_`时 **并不安全** 。 **（漏洞点!）**
    void IndexedDBDatabase::ForceClose() {
      // IndexedDBConnection::ForceClose() may delete this database, so hold ref.
      scoped_refptr protect(this);
      // 循环将所有尚未处理的请求强制关闭
      while (!pending_requests_.empty()) {
        std::unique_ptr request =
            std::move(pending_requests_.front());
        pending_requests_.pop();
        request->AbortForForceClose();
      }
      // 循环将所有连接到当前数据库的connections强制断开
      // 注意！这段代码在修改connection_时不够安全
      auto it = connections_.begin();
      while (it != connections_.end()) {
        IndexedDBConnection* connection = *it++;
        // 注意这一步，执行`connection->ForceClose()`时，程序会关闭当前连接。
        // 但倘若当前遍历的连接是connection_中的最后一条连接，则会执行函数StartUpgrade以建立新连接
        connection->ForceClose();
      }
      // 常规检查
      DCHECK(connections_.empty());
      DCHECK(!active_request_);
    }
在第二个用于关闭connection的循环中，程序会执行`connection->ForceClose()`，即[IndexedDBConnection::ForceClose函数](https://source.chromium.org/chromium/chromium/src/+/refs/tags/73.0.3683.75:content/browser/indexed_db/indexed_db_connection.cc;l=48;bpv=0;bpt=0)，以强制关闭该connection。而为了在`IndexedDBDatabase`中释放当前连接在数据库中所占用的资源，在这个函数中，程序会进一步调用`IndexedDBDatabase::Close`函数。
    void IndexedDBConnection::ForceClose() {
      if (!callbacks_.get())
        return;
      // IndexedDBDatabase::Close() can delete this instance.
      base::WeakPtr this_obj = weak_factory_.GetWeakPtr();
      scoped_refptr callbacks(callbacks_);
      // 注意这条代码
      database_->Close(this, true /* forced */);
      if (this_obj) {
        database_ = nullptr;
        callbacks_ = nullptr;
        active_observers_.clear();
      }
      callbacks->OnForcedClose();
    }
[IndexDBDatabase::Close函数](https://source.chromium.org/chromium/chromium/src/+/refs/tags/73.0.3683.75:content/browser/indexed_db/indexed_db_database.cc;l=1897)会依次执行一系列操作，但这里我们只关注两个操作。该函数中，程序会先
**在`connection_`集合中删除当前连接**，之后 **执行`active_request_->OnConnectionClosed`函数**。
    void IndexedDBDatabase::Close(IndexedDBConnection* connection, bool forced) {
      DCHECK(connections_.count(connection));
      DCHECK(connection->IsConnected());
      DCHECK(connection->database() == this);
      IDB_TRACE("IndexedDBDatabase::Close");
      // 终止当前连接中所有的未完成事务
      connection->FinishAllTransactions(IndexedDBDatabaseError(
          blink::kWebIDBDatabaseExceptionUnknownError, "Connection is closing."));
      // 从数据库中的connections_集合中删除当前request
      connections_.erase(connection);
      // 通知当前正在处理的请求，因为当前请求可能需要进行清理或者继续进行操作
      if (active_request_)
        active_request_->OnConnectionClosed(connection);
      // 如果当前数据库中的所有连接和所有请求均已经全部释放完成，则从IndexDBFactory类实例中删除指向当前IndexedDBData的指针
      if (connections_.empty() && !active_request_ && pending_requests_.empty()) {
        backing_store_ = nullptr;
        factory_->ReleaseDatabase(identifier_, forced);
      }
    }
`OnConnectionClosed`函数中会先判断当前待处理connection **是否被过早关闭** 。
    void OnConnectionClosed(IndexedDBConnection* connection) override {