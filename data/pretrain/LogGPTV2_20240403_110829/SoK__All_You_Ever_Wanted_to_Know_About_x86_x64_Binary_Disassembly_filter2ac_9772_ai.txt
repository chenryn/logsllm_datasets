ities in x86 executables,” in 2006 22nd Annual Computer Security Applications
Conference (ACSAC’06).
IEEE, 2006, pp. 269–278.
[26] C. CyLab, “Bap github repo,” https://github.com/BinaryAnalysisPlatform/bap/tree/
cfeacbfc, 2020.
[27] C. CyLab, “Bap-toolkit github repo,” https://github.com/BinaryAnalysisPlatform/
bap-toolkit/tree/7b7744dc3/with-no-return, 2020.
[28] L. Davi, C. Liebchen, A.-R. Sadeghi, K. Z. Snow, and F. Monrose, “Isomeron:
Code randomization resilient to (just-in-time) return-oriented programming.” in
NDSS, 2015.
[29] Y. David, N. Partush, and E. Yahav, “Firmup: Precise static detection of common
vulnerabilities in ﬁrmware,” in ACM SIGPLAN Notices, vol. 53, no. 2. ACM,
2018, pp. 392–404.
[30] Y. David and E. Yahav, “Tracelet-based code search in executables,” in Acm
Sigplan Notices, vol. 49, no. 6. ACM, 2014, pp. 349–360.
[31] L. De La Rosa, S. Kilgallon, T. Vanderbruggen, and J. Cavazos, “Efﬁcient
characterization and classiﬁcation of malware using deep learning,” in 2018
Resilience Week (RWS).
IEEE, 2018, pp. 77–83.
[32] R. Decompiler, “A retargetable machine-code decompiler based on llvm,” https:
//retdec.com/.
[33] A. Dinaburg and A. Ruef, “Mcsema: Static translation of x86 instructions to llvm,”
in ReCon 2014 Conference, Montreal, Canada, 2014.
[34] S. Dinesh, N. Burow, D. Xu, and M. Payer, “Retrowrite: Statically instrumenting
cots binaries for fuzzing and sanitization,” in 2020 IEEE Symposium on Security
and Privacy (SP).
IEEE Computer Society, 2020, pp. 9–9.
[35] DynInst, “Dataﬂowapi programmers guide,” https://dyninst.org/sites/default/ﬁles/
manuals/dyninst/dataﬂowAPI.pdf, 2019.
[38]
[36] C. Eagle, The IDA pro book. No Starch Press, 2011.
[37] M. Elsabagh, D. Fleck, and A. Stavrou, “Strict virtual call integrity checking for
c++ binaries,” in 2017 ACM on Asia Conference on Computer and Communica-
tions Security. ACM, 2017, pp. 140–154.
´U. Erlingsson, M. Abadi, M. Vrable, M. Budiu, and G. C. Necula, “Xﬁ: Software
guards for system address spaces,” in 7th USENIX Security Symposium, 2006, pp.
75–88.
[39] U. Erlingsson and F. B. Schneider, “Sasi enforcement of security policies: A
retrospective,” in Proceedings DARPA Information Survivability Conference and
Exposition. DISCEX’00, vol. 2.
IEEE, 2000, pp. 287–295.
[40] S. Eschweiler, K. Yakdan, and E. Gerhards-Padilla, “discovre: Efﬁcient cross-
architecture identiﬁcation of bugs in binary code.” in NDSS, 2016.
[41] Q. Feng, M. Wang, M. Zhang, R. Zhou, A. Henderson, and H. Yin, “Extracting
conditional formulas for cross-platform bug search,” in 2017 ACM on Asia
Conference on Computer and Communications Security. ACM, 2017, pp. 346–
359.
[42] Q. Feng, R. Zhou, C. Xu, Y. Cheng, B. Testa, and H. Yin, “Scalable graph-
based bug search for ﬁrmware images,” in the 2016 ACM SIGSAC Conference on
Computer and Communications Security. ACM, 2016, pp. 480–491.
[43] H. Flake, “Structural comparison of executable objects,” in DIMVA, vol. 46.
Citeseer, 2004, pp. 161–173.
[44] P. Garba and M. Favaro, “Saturn-software deobfuscation framework based on
llvm,” in 3rd ACM Workshop on Software Protection. ACM, 2019, pp. 27–38.
[45] A. Gazet, “ret-sync is a set of plugins that helps to synchronize a debugging
session,” https://github.com/bootleg/ret-sync, 2016.
[46] M. Ghaffarinia and K. W. Hamlen, “Binary control-ﬂow trimming,” in cnum26th
ACM Conference on Computer and Communications Security nymCCS. forthcom-
ing, 2019.
[47] GNU, “Index of /gnu/binutils,” https://ftp.gnu.org/gnu/binutils/, 2019.
[48] GNU, “Mirror of sourceware glibc repository,” https://github.com/bminor/glibc/
blob/master/sysdeps/x86 64/multiarch/memcpy-ssse3.S#L441, 2019.
I. Guilfanov, “Jump tables,” https://www.hex-rays.com/blog/jump-tables/.
[49]
[50] N. Hasabnis and R. Sekar, “Lifting assembly to intermediate representation: A
novel approach leveraging compilers,” in ACM SIGARCH Computer Architecture
News, vol. 44, no. 2. ACM, 2016, pp. 311–324.
[51] W. He, S. Das, W. Zhang, and Y. Liu, “No-jump-into-basic-block: Enforce basic
block cﬁ on the ﬂy for real-world binaries,” in 54th Annual Design Automation
Conference 2017. ACM, 2017, p. 23.
[52] G. Hernandez, F. Fowze, D. J. Tian, T. Yavuz, and K. R. Butler, “Firmusb: Vetting
usb device ﬁrmware using domain informed symbolic execution,” in 2017 ACM
SIGSAC Conference on Computer and Communications Security. ACM, 2017,
pp. 2245–2262.
[53] J. Hiser, A. Nguyen-Tuong, M. Co, M. Hall, and J. W. Davidson, “Ilr: Where’d
IEEE,
my gadgets go?” in 2012 IEEE Symposium on Security and Privacy (SP).
2012, pp. 571–585.
[54] X. Hu and K. G. Shin, “DUET: Integration of dynamic and static analyses for
malware clustering with cluster ensembles,” in 29th Annual Computer Security
Applications Conference (ACSAC’13), 2013, pp. 79–88.
[55] Y. Hu, Y. Zhang, J. Li, and D. Gu, “Binary code clone detection across
architectures and compiling conﬁgurations,” in 25th International Conference on
Program Comprehension.
IEEE Press, 2017, pp. 88–98.
[56] M. Jiang, Y. Zhou, X. Luo, R. Wang, Y. Liu, and K. Ren, “An empirical study on
arm disassembly tools,” in ACM SIGSOFT International Symposium on Software
Testing and Analysis (ISSTA’20), 2020.
[57] W. M. Khoo, A. Mycroft, and R. Anderson, “Rendezvous: A search engine for
binary code,” in the 10th Working Conference on Mining Software Repositories.
IEEE Press, 2013, pp. 329–338.
[58] S. Kilgallon, L. De La Rosa, and J. Cavazos, “Improving the effectiveness and
efﬁciency of dynamic malware analysis with machine learning,” in 2017 Resilience
Week (RWS).
IEEE, 2017, pp. 30–36.
[59] J. Kinder, “The jakstab static analysis platform for binaries,” http://www.jakstab.
org/.
[60] H. Koo, Y. Chen, L. Lu, V. P. Kemerlis, and M. Polychronakis, “Compiler-assisted
code randomization,” in 2018 IEEE Symposium on Security and Privacy (SP).
IEEE, 2018, pp. 461–477.
[61] H. Koo and M. Polychronakis, “Juggling the gadgets: Binary-level code ran-
domization using instruction displacement,” in 11th ACM on Asia Conference
on Computer and Communications Security. ACM, 2016, pp. 23–34.
[62] C. Kruegel, E. Kirda, D. Mutz, W. Robertson, and G. Vigna, “Polymorphic worm
Authorized licensed use limited to: Tsinghua University. Downloaded on February 25,2022 at 12:27:37 UTC from IEEE Xplore.  Restrictions apply. 
847
detection using structural information of executables,” in International Workshop
on Recent Advances in Intrusion Detection. Springer, 2005, pp. 207–226.
[63] S. S. Lab, “Psi: A platform for secure static binary instrumentation,” http://www.
986353c0, 2019.
pp. 1–6, 2006.
[94] M. Santosa, “Understanding elf using readelf and objdump,” Linux Forms article,
[95] Y. Shoshitaishvili, R. Wang, C. Salls, N. Stephens, M. Polino, A. Dutcher,
J. Grosen, S. Feng, C. Hauser, C. Kruegel et al., “Sok:(state of) the art of war:
Offensive techniques in binary analysis,” in 2016 IEEE Symposium on Security
and Privacy (SP).
IEEE, 2016, pp. 138–157.
[96] S. Sidiroglou, O. Laadan, C. Perez, N. Viennot, J. Nieh, and A. D. Keromytis,
“Assure: automatic software self-healing using rescue points,” ACM SIGARCH
Computer Architecture News, vol. 37, no. 1, pp. 37–48, 2009.
[97] D. Song, D. Brumley, H. Yin, J. Caballero, I. Jager, M. G. Kang, Z. Liang,
J. Newsome, P. Poosankam, and P. Saxena, “Bitblaze: A new approach to computer
security via binary analysis,” in International Conference on Information Systems
Security. Springer, 2008, pp. 1–25.
[98] N. Stephens, J. Grosen, C. Salls, A. Dutcher, R. Wang, J. Corbetta, Y. Shoshi-
taishvili, C. Kruegel, and G. Vigna, “Driller: Augmenting fuzzing through
selective symbolic execution.” in NDSS, vol. 16, no. 2016, 2016, pp. 1–16.
[99] V. Van Der Veen, E. G¨oktas, M. Contag, A. Pawoloski, X. Chen, S. Rawat, H. Bos,
T. Holz, E. Athanasopoulos, and C. Giuffrida, “A tough call: Mitigating advanced
code-reuse attacks at the binary level,” in 2016 IEEE Symposium on Security and
Privacy (SP).
IEEE, 2016, pp. 934–953.
[100] M. Wang, H. Yin, A. V. Bhaskar, P. Su, and D. Feng, “Binary code continent:
Finer-grained control ﬂow integrity for stripped binaries,” in 31st Annual Com-
puter Security Applications Conference (ACSAC’15). ACM, 2015, pp. 331–340.
[101] R. Wang, Y. Shoshitaishvili, A. Bianchi, A. Machiry, J. Grosen, P. Grosen,
C. Kruegel, and G. Vigna, “Ramblr: Making reassembly great again.” in NDSS,
2017.
[102] S. Wang, P. Wang, and D. Wu, “Reassembleable disassembling,” in 24th USENIX
Security Symposium, 2015, pp. 627–642.
[103] S. Wang, P. Wang, and D. Wu, “Uroboros: Instrumenting stripped binaries with
static reassembling,” in 2016 IEEE 23rd International Conference on Software
Analysis, Evolution, and Reengineering (SANER).
IEEE, 2016.
[104] R. Wartell, V. Mohan, K. W. Hamlen, and Z. Lin, “Binary stirring: Self-
randomizing instruction addresses of legacy x86 binary code,” in 2012 ACM
conference on Computer and communications security. ACM, 2012, pp. 157–168.
[105] M. Wenzl, G. Merzdovnik, J. Ullrich, and E. Weippl, “From hack to elaborate
techniquea survey on binary rewriting,” ACM Computing Surveys (CSUR), vol. 52,
no. 3, p. 49, 2019.
[106] D. Williams-King, G. Gobieski, K. Williams-King, J. P. Blake, X. Yuan, P. Colp,
M. Zheng, V. P. Kemerlis, J. Yang, and W. Aiello, “Shufﬂer: Fast and deployable
continuous code re-randomization,” in 12th USENIX Symposium on Operating
Systems Design and Implementation (OSDI 16), 2016, pp. 367–382.
[107] B. Yee, D. Sehr, G. Dardyk, J. B. Chen, R. Muth, T. Ormandy, S. Okasaka,
N. Narula, and N. Fullagar, “Native client: A sandbox for portable, untrusted x86
native code,” in 2009 30th IEEE Symposium on Security and Privacy (SP).
IEEE,
2009, pp. 79–93.
[108] C. Zhang, T. Wei, Z. Chen, L. Duan, S. McCamant, and L. Szekeres, “Protecting
function pointers in binary,” in 8th ACM SIGSAC symposium on Information,
computer and communications security. ACM, 2013, pp. 487–492.
[109] C. Zhang, T. Wei, Z. Chen, L. Duan, L. Szekeres, S. McCamant, D. Song,
and W. Zou, “Practical control ﬂow integrity and randomization for binary
executables,” in 2013 IEEE Symposium on Security and Privacy (SP).
IEEE,
2013, pp. 559–573.
[110] M. Zhang, M. Polychronakis, and R. Sekar, “Protecting cots binaries from
disclosure-guided code reuse attacks,” in 33rd Annual Computer Security Ap-
plications Conference (ACSAC’17). ACM, 2017, pp. 128–140.
[111] M. Zhang and R. Sekar, “Control ﬂow integrity for cots binaries,” in 22nd USENIX
Security Symposium, 2013, pp. 337–352.
[112] L. Zhao, Y. Duan, H. Yin, and J. Xuan, “Send hardest problems my way:
Probabilistic path prioritization for hybrid fuzzing,” in NDSS, 2019.
APPENDIX
TABLE XVII: Statistics of complex constructs in our bench-
mark binaries.
Complex Constructs
Types
Data in code
Indirect Jumps
Special functions
Padding bytes
Hard-coded bytes
Jump tables
Jump tables
Indirect tail-calls
Handle-written ones
Overlapping functions
Multi-entry functions
Non-return functions
(Direct) Tail-calls
N/A
Cases / Prog / Bin
6,445,649 / 236 / 3,788
295 / 3 / 18
21,586 / 57 / 426
118,616 / 225 / 3,594
35,087 / 26 / 465
336 / 1 / 4
2,050 / 6 / 49
103 / 3 / 11
29,668 / 228 / 3,712
503,527 / 236 / 3,781
seclab.cs.sunysb.edu/seclab/psi/, 2019.
[64] T. C. S. D. Laboratory, “Program analysis tools developed at draper on the cbat
project,” https://github.com/draperlaboratory/cbat tools/, 2018.
[65] L. Li, J. E. Just, and R. Sekar, “Address-space randomization for windows
systems,” in 2006 22nd Annual Computer Security Applications Conference
(ACSAC’06).
IEEE, 2006, pp. 329–338.
[66] Z. Li, D. Zou, S. Xu, X. Ou, H. Jin, S. Wang, Z. Deng, and Y. Zhong,
“Vuldeepecker: A deep learning-based system for vulnerability detection,” arXiv
preprint arXiv:1801.01681, 2018.
[67] S. McCamant and G. Morrisett, “Evaluating sﬁ for a cisc architecture.” in 7th
USENIX Security Symposium, 2006.
[68] X. Meng and B. P. Miller, “Binary code is not easy,” in 25th International
Symposium on Software Testing and Analysis. ACM, 2016, pp. 24–35.
[69] B. P. Miller, M. Christodorescu, R. Iverson, T. Kosar, A. Mirgorodskii, and
F. Popovici, “Playing inside the black box: Using dynamic instrumentation to
create security holes,” Parallel Processing Letters, vol. 11, no. 02n03, pp. 267–
280, 2001.
[70] J. Ming, M. Pan, and D. Gao, “ibinhunt: Binary hunting with inter-procedural con-
trol ﬂow,” in International Conference on Information Security and Cryptology.
Springer, 2012, pp. 92–109.
[71] M. Muench, D. Nisi, A. Francillon, and D. Balzarotti, “Avatar 2: A multi-target
orchestration platform,” in Workshop on Binary Analysis Research (colocated with
NDSS Symposium)(February 2018), BAR, vol. 18, 2018.
[72] P. Muntean, M. Fischer, G. Tan, Z. Lin, J. Grossklags, and C. Eckert, “τcﬁ: Type-
assisted control ﬂow integrity for x86-64 binaries,” in International Symposium
on Research in Attacks, Intrusions, and Defenses. Springer, 2018, pp. 423–444.
[73] J. Mußler, D. Lorenz, and F. Wolf, “Reducing the overhead of direct application
instrumentation using prior static analysis,” in European Conference on Parallel
Processing. Springer, 2011, pp. 65–76.
[74] B. Ninja, “binary.ninja : a reverse engineering platform,” https://binary.ninja/,
2019.
2019.
[75] NSA, “Ghidra github repo,” https://github.com/NationalSecurityAgency/ghidra/
tree/Ghidra 9.0.4 build, 2019.
[76] T. of Bits, “Vulnerability modeling with binary ninja,” https://blog.trailofbits.com/
2018/04/04/vulnerability-modeling-with-binary-ninja/, 2018.
[77] R. Paleari, L. Martignoni, G. Fresi Roglia, and D. Bruschi, “N-version disassem-
bly: differential testing of x86 disassemblers,” in 19th international symposium
on Software testing and analysis. ACM, 2010, pp. 265–274.
[78] V. Pappas, M. Polychronakis, and A. D. Keromytis, “Smashing the gadgets:
Hindering return-oriented programming using in-place code randomization,” in
2012 IEEE Symposium on Security and Privacy (SP).
IEEE, 2012, pp. 601–615.
[79] Paradyn, “Dyninst github repo,” https://github.com/dyninst/dyninst/tree/5d2ddacb,
[80] M. Payer, A. Barresi, and T. R. Gross, “Fine-grained control-ﬂow integrity through
binary hardening,” in International Conference on Detection of Intrusions and
Malware, and Vulnerability Assessment. Springer, 2015, pp. 144–164.
[81] H. Peng, Y. Shoshitaishvili, and M. Payer, “T-fuzz: fuzzing by program transfor-
IEEE, 2018,
mation,” in 2018 IEEE Symposium on Security and Privacy (SP).
pp. 697–710.
[82] J. Pewny, B. Garmany, R. Gawlik, C. Rossow, and T. Holz, “Cross-architecture
bug search in binary executables,” in 2015 IEEE Symposium on Security and
Privacy (SP).
IEEE, 2015, pp. 709–724.
[83] J. Pewny, F. Schuster, L. Bernhard, T. Holz, and C. Rossow, “Leveraging semantic
signatures for bug search in binary programs,” in the 30th Annual Computer
Security Applications Conference (ACSAC’14). ACM, 2014, pp. 406–415.
[84] B. Potchik, “Binary ninja deep thoughts,” https://binary.ninja/2017/11/06/
architecture-agnostic-function-detection-in-binaries.html, 2017.
[85] A. Prakash, X. Hu, and H. Yin, “vfguard: Strict protection for virtual function
calls in cots c++ binaries.” in NDSS, 2015.
[86] C. Qian, H. Hu, M. Alharthi, P. H. Chung, T. Kim, and W. Lee, “Razor: A
framework for post-deployment software debloating,” in 28th USENIX Security
Symposium, 2019, pp. 1733–1750.
[87] W. Qiang, Y. Huang, D. Zou, H. Jin, S. Wang, and G. Sun, “Fully context-sensitive
cﬁ for cots binaries,” in Australasian Conference on Information Security and
Privacy. Springer, 2017, pp. 435–442.
[88] R. Qiao, M. Zhang, and R. Sekar, “A principled approach for rop defense,” in
31st Annual Computer Security Applications Conference (ACSAC’15). ACM,
2015, pp. 101–110.
radreorg,
“Radare2
5a1df188, 2020.
https://github.com/radareorg/radare2/tree/
github
repo,”
[90] G. Ravipati, A. R. Bernat, N. Rosenblum, B. P. Miller, and J. K. Hollingsworth,
“Toward the deconstruction of dyninst,” Univ. of Wisconsin, technical report, p. 32,
2007.
[91] S. Rawat, V. Jain, A. Kumar, L. Cojocar, C. Giuffrida, and H. Bos, “Vuzzer:
[89]
Application-aware evolutionary fuzzing,” in NDSS, 2017.
[92] N. Redini, R. Wang, A. Machiry, Y. Shoshitaishvili, G. Vigna, and C. Kruegel,
“B in t rimmer: Towards static binary debloating through abstract interpretation,”
in International Conference on Detection of Intrusions and Malware, and Vulner-
ability Assessment. Springer, 2019, pp. 482–501.
[93] s3team,
“Uroboros
github
repo,”
https://github.com/s3team/uroboros/tree/
Authorized licensed use limited to: Tsinghua University. Downloaded on February 25,2022 at 12:27:37 UTC from IEEE Xplore.  Restrictions apply. 
848
A. Complex Constructs
Table XVII presents the statistics of complex constructs
from our benchmark binaries.
B. Building Ground Truth for Windows Binaries
First, we follow a similar approach as described in [5] to
gather instructions. We use the line table in debug information
to ﬁnd the ﬁrst instruction of each source-code/assembly state-
ment, followed by recursive disassembly (skipping indirect
control transfers) to ﬁnd instructions not covered by the line
table. We also found that Visual Studio considers hard-coded
bytes as code in the line table. We manually exclude such
cases. Second, we rely on symbols to identify functions. The
symbol of a function also carries a ﬂag indicating whether it
returns, aiding us to gather non-returning functions. Third, we
enable the DEBUGTYPE:FIXUP option in Visual Studio such
that all xrefs are preserved in the linking process. Finally, we
identify jump tables based on xrefs (which contain the base
address and entries of a jump table). For each xref, if its target
location contains a list of other xrefs pointing to basic blocks
in the same function, we consider the xref refers to a jump
table and deem the list of xrefs at its target location as entries.
For correctness, we further verify if the jump table entries
correspond to switch-cases in the source code. Otherwise,
we manually verify the correctness (since some jump tables
are hand-crafted or compiled from if-else statements).
Our initial ground truth of non-returning functions (for both
Linux and Windows binaries) can miss propagated cases. To
this end, we expand our ground truth by running algorithms
14 and 15 with recursive updates.
C. Conﬁgurations of Disassembly Tools
OBJDUMP, PSI, UROBOROS: We use the recommended
options to run them. We parse their outputs for results.
DYNINST: We use its ParseAPI interface to perform recursive
disassembly and we further enable IdiomMatching to include
the decision-tree based function matching (which is excluded
when we do testing without heuristics). We parse the returned
structure of ParseAPI to get the disassembly results.
ANGR: We use its CFGFast
interface for disassembly.
When using this interface, we enable the normalize and
detect tail calls arguments so that a basic block is split by
a control transfer to the middle and tail calls are detected.
When testing disassembly without heuristics, we disable the
force complete scan and function prologues arguments to
CFGFast, preventing linear scan and function matching. To
obtain the results, we interpret the CFG returned by CFGFast
for results. We also excluded functions marked as “alignment”.
We use the Reassembler interface for symbolization.
GHIDRA: Besides default settings, we enable Assume Con-
tiguous Functions Only and Allow Conditional Jumps to per-
form tail call detection. We disable the X86 Constant Reference
Analyzer in symbolization as it
introduces many dummy
xrefs. Finally, to test GHIDRA without heuristics, we disable
Function Start Search and xrefs related options, to prevent the
signature-based matching and xref based disassembly.
TABLE XVIII: Results of disassembly without heuristics.
Instructions
Min
Avg
L
Instructions
Min
Avg
W
t
s
n
i
n
y
D
O0
O2
O3
Os
Of
E O0
N
O2
-
a
O3
r
d
Os
i
h
Of
G
O0
O2
O3
Os
Of
S O0
O2
N
-
O3
r
g
Os
n
A
Of
O0
O2
O3
Os
Of
2
e
r
a
d
a
R