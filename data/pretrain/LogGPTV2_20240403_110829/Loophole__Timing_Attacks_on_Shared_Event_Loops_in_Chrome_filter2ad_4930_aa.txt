title:Loophole: Timing Attacks on Shared Event Loops in Chrome
author:Pepe Vila and
Boris K&quot;opf
Loophole: Timing Attacks on  
Shared Event Loops in Chrome
Pepe Vila, IMDEA Software Institute & Technical University of Madrid (UPM);  
Boris Köpf, IMDEA Software Institute
https://www.usenix.org/conference/usenixsecurity17/technical-sessions/presentation/vila
This paper is included in the Proceedings of the 26th USENIX Security SymposiumAugust 16–18, 2017 • Vancouver, BC, CanadaISBN 978-1-931971-40-9Open access to the Proceedings of the 26th USENIX Security Symposium is sponsored by USENIXLoophole: Timing Attacks on Shared Event Loops in Chrome
Pepe Vila*,† and Boris K¨opf*
*IMDEA Software Institute
†Technical University of Madrid (UPM)
{pepe.vila, boris.koepf}@imdea.org
Abstract
is the prevalent
Event-driven programming (EDP)
paradigm for graphical user interfaces, web clients, and
it is rapidly gaining importance for server-side and net-
work programming. Central components of EDP are
event loops, which act as FIFO queues that are used by
processes to store and dispatch messages received from
other processes.
In this paper we demonstrate that shared event loops
are vulnerable to side-channel attacks, where a spy pro-
cess monitors the loop usage pattern of other processes
by enqueueing events and measuring the time it takes for
them to be dispatched. Speciﬁcally, we exhibit attacks
against the two central event loops in Google’s Chrome
web browser: that of the I/O thread of the host process,
which multiplexes all network events and user actions,
and that of the main thread of the renderer processes,
which handles rendering and Javascript tasks.
For each of these loops, we show how the usage pat-
tern can be monitored with high resolution and low over-
head, and how this can be abused for malicious purposes,
such as web page identiﬁcation, user behavior detection,
and covert communication.
1
Introduction
Event-driven programming (EDP) consists of deﬁning
responses to events such as user actions, I/O signals,
or messages from other programs. EDP is the preva-
lent programming paradigm for graphical user interfaces,
web clients, and it is rapidly gaining importance for
server-side and network programming. For instance, the
HTML5 standard [2] mandates that user agents be imple-
mented using EDP, similarly, Node.js, memcached, and
Nginx, also rely on EDP.
In EDP, each program has an event loop which con-
sists of a FIFO queue and a control process (or thread)
that listens to events. Events that arrive are pushed into
the queue and are sequentially dispatched by the con-
trol process according to a FIFO policy. A key fea-
ture of EDP is that high-latency (or blocking) opera-
tions, such as database or network requests, can be han-
dled asynchronously: They appear in the queue only as
events signaling start and completion, whereas the block-
ing operation itself is handled elsewhere.
In this way
EDP achieves the responsiveness and ﬁne-grained con-
currency required for modern user interfaces and net-
work servers, without burdening programmers with ex-
plicit concurrency control.
Figure 1: Shared event loop. A enqueues multiple short
tasks and records the time at which each of them is pro-
cessed. The time difference between two consecutive
tasks reveals whether V has posted tasks in-between, and
how long they took to execute.
In this paper we show that EDP-based systems are sus-
ceptible to side-channel attacks. The key observation is
that event loops form a resource that can be shared be-
tween mutually distrusting programs. Hence, contention
of this resource by one program can be observed by the
others through variations in the time the control process
takes for dispatching their events. Figure 1 illustrates
such a scenario for a loop that is shared between an at-
tacker A and a victim V.
Attacks based on observable contention of shared re-
sources have a long history [25] and an active present [8,
27, 37]; however, attacks against shared event loops have
so far only been considered from a theoretical point of
view [22]. Here, we perform the ﬁrst attacks against real
EDP-based systems. Speciﬁcally, we target shared event
loops in the two central processes of Google’s Chrome
USENIX Association
26th USENIX Security Symposium    849
web browser: The host process, whose event loop is
shared between all requests for common resources, such
as network and user interface; and the renderer pro-
cesses, whose loops can be shared between Javascript
tasks of different tabs or iframes.
We build infrastructure that enables us to spy on both
loops from a malicious HTML page. This is facilitated
by the asynchronous programming model used in both
Chrome and Javascript. Asynchronous function calls
trigger new tasks that are appended to the same queue, in
contrast to synchronous calls which are simply pushed
onto the current task’s call stack and executed without
preemption, blocking the loop.
• For the event loop of the renderer we rely on the
postMessage API, which is a Javascript feature
for cross-window communication based on asyn-
chronous callbacks. By posting messages to our-
selves we can monitor the event loop with a resolu-
tion of 25 µs, with only one task in the loop at each
point in time.
• For the event loop of the host process we rely on
two different mechanisms: network requests to non-
routable IP addresses, which enter the loop and
abort very quickly, providing a resolution of 500 µs;
and SharedWorkers, whose messages pass through
the event loop of the host process, providing a reso-
lution of 100 µs.
We use the information obtained using these techniques
in three different attacks:
1. We show how event delays during the loading
phase, corresponding to resource requests, parsing,
rendering and Javascript execution, can be used to
uniquely identify a web page. Figure 2 visualizes this
effect using three representative web pages. While this
attack shares the goal with the Memento attack [21],
the channels are quite different: First, in contrast to
Memento, we ﬁnd that the relative ordering of events is
necessary for successful classiﬁcation, which motivates
the use of dynamic time warping as a distance measure.
Second, we show that page identiﬁcation through the
event loop requires only minimal training: we achieve
recognition rates of up to 75% and 23% for the event
loops of the renderer and host processes, respectively,
for 500 main pages from Alexa’s Top sites. These rates
are obtained using only one sample of each page for the
training phase.
2. We illustrate how user actions in cross-origin pages
can be detected based on the delays they introduce in the
event loop.
In particular, we mount an attack against
Google OAuth login forms, in which we measure the
time between keystrokes while the user is typing a pass-
word. The timing measurements we obtain from the
event loop are signiﬁcantly less noisy or require less priv-
ileges than from other channels [20, 38, 18].
Figure 2: Delays observed while loading different web
pages, by an attacker tab sharing the renderer process.
Horizontal axis depicts elapsed real time, vertical axis
depicts time taken by the event loop for processing the
tasks inserted by the attacker. All pages are clearly dis-
tinguishable, both by the human eye and by classiﬁcation
techniques.
3. We demonstrate that shared event
loops can
be used to transmit information between cross-origin
pages.Speciﬁcally, we implement a covert channel with
a bandwidth of 200 bit/s through the renderer’s main
thread event
loop, and another one working cross-
processes of 5 bit/s.
Our attacks show that event loops can be successfully
spied on even with simple means. They work under the
assumption that event loops behave as FIFO queues; in
reality, however, Chrome’s event loop has a more so-
phisticated structure, relying on multiple queues and a
policy-based scheduler. We believe that this structure can
be leveraged for much more powerful attacks in the fu-
ture.
2
Isolation Policies and Sharing of Event
Loops in Chrome
In this section we revisit the same origin policy and its
variants. We then discuss the relationship of these poli-
cies with the Chrome architecture, where we put a special
focus on the way in which event loops are shared.
2.1 Same Origin Policy
The Same-Origin Policy (SOP) is a central concept in
the web security model: The policy restricts scripts on a
850    26th USENIX Security Symposium
USENIX Association
web page to access data from another page if their origins
differ. Two pages have the same origin if protocol, port
and host are equal.
The demand for ﬂexible cross-origin communication
has triggered the introduction of features such as domain
relaxation, the postMessage API, Cross-origin Resource
Sharing (CORS), Channel Messaging, Suborigins, or the
Fetch API. This feature creep comes with an increase in
browser complexity and attack surface, which has mo-
tivated browser vendors to move towards more robust
multi-process architectures.
2.2 Overview of the Chrome Architecture
The Chrome architecture is segmented into different op-
erating system processes. The rationale for this seg-
mentation is twofold:
to isolate web content from the
host [6], and to support the enforcement of origin poli-
cies by means of the OS [30]. For achieving this seg-
mentation, Chrome relies on two processes:
Figure 3: Overview of Chrome’s architecture.
The host process runs the top-level browser window.
It has access to system resources such as network, ﬁle
system, UI events, etc., which it manages on behalf of
the unprivileged renderer processes. The host process
runs several threads; the most relevant ones are:
• the CrBrowserMain thread, which handles, e.g.,
user interaction events, and
• the IOThread, which handles, e.g., IPC, network
stack, and ﬁle system.
The renderer processes are sandboxed processes re-
sponsible for parsing, rendering and Javascript execu-
tion. Communication with the host process is done via
an inter-process communication (IPC) system based on
message passing. Each renderer runs several threads; the
most relevant ones are:
• the MainThread where resource parsing, style cal-
culation, layout, painting and non-worker Javascript
runs,
• the IOChildThread, which handles IPC communi-
cation with the host process, and
• the CompositorThread, which improves respon-
siveness during the rendering phase by allowing the
user to scroll and see animations while the main
thread is busy, thanks to a snapshot of the page’s
state.
Each of the threads in the host and renderer processes
maintains at least one event loop that is largely a FIFO
queue. Inter-thread and inter-process communication are
carried out via message passing through these queues.
We next discuss scenarios where pages of different origin
can share the event loops of host and renderer processes.
In Section 3 we show how this sharing can be exploited
for eavesdropping.
2.3 Sharing in the Renderer Processes
Chrome supports different policies that govern how web
applications are mapped to renderer processes, and that
inﬂuence whether or not event loops are shared.
a
policy
is
called
The
default
It
is deﬁned as
for each instance of a site.
Here,
registered domain plus
process-per-site-
instance.
requires using a dedicated renderer
a
process
site
a
scheme.
For example, https://docs.google.com and
https://mail.google.com:8080 are from the same site –
but not from the same origin, as they differ in subdomain
and port. A site instance is a collection of pages from
the same site that can obtain references to each other
(e.g., one page opened the other in a new window using
Javascript).
The other supported policies are more permissive. For
example, the process-per-site policy groups all instances
of a site in the same renderer process, trading robust-
ness for a lower memory overhead. The process-per-tab
policy dedicates one renderer process to each group of
script-connected tabs. Finally, the single-process policy
lets both the host and renderer run within a single OS
process (only used for debugging purposes).
Even in the restrictive default process-per-site-
instance policy,
there are some situations that force
Chrome to host documents from different sites in the
same renderer process, causing them to share the event
loop:
• Iframes are currently hosted in the same process as
their parent.
• Renderer-initiated navigations such as link clicks,
form submissions, and scripted redirections will
reuse the same renderer as the origin page.
• When the number of renderer processes exceeds a
certain threshold, Chrome starts to reuse existing
renderers instead of creating new ones.
On (64-bit) OSX and Linux, the threshold for reusing
renderers is calculated by splitting half of the physical
USENIX Association
26th USENIX Security Symposium    851
HOST PROCESSMain ThreadI/O ThreadRENDERER AMainThreadIOChildThreadCompositorThreadRENDERER BMainThreadIOChildThreadCompositorThreadRAM among the renderers, under the assumption that
each consumes 60MB.1 In our experiments, on a ma-
chine with 4 GB of RAM we could spawn 31 new tabs
before any renderer was shared, whereas on a machine
with 8 GB of RAM we observed a threshold of approx-
imately 70 renderers. There is no apparent grouping
policy for the pages that can share a process when this
threshold is exceeded, except for tabs in Incognito mode
not being mixed up with “normal” tabs.
In particular,
we do not observe any preference for similar origins,
same sites, or secure versus insecure pages. In fact, even
ﬁlesystem pages (loaded with file://) can co-reside
with an arbitrary HTTP site.
3 Eavesdropping on Event Loops
Chrome
in
In this section we describe how to violate the SOP by