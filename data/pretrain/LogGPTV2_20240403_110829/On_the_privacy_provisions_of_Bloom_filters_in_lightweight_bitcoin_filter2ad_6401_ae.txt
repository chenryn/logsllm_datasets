0.1
0.5
0.05
0.1
0.5
0
0
0
0
0.13
11.27
4.21
18.06
523.20
7.37
30.01
753.41
Table 5: Measuring |B1 ∩ B2| in Experiments 1,2, and 3, using
ﬁlters pertaining to different SPV clients with respect to Pt. Each
data point is averaged over 10 independent runs.
Observation 1: The number of elements inserted within a Bloom
ﬁlter signiﬁcantly affects the resulting false positive rate of
the ﬁlter. This is especially true when the ﬁlter’s size is mod-
est (e.g., < 500). Indeed, the number of elements inserted in
the ﬁlter should match at all times the ﬁlter’s size in order to
achieve the target false positive rate (i.e., Pf (m) = Pt).
Observation 2: The acquisition of multiple Bloom ﬁlters consid-
erably reduces the privacy of SPV clients. The construction
of multiple Bloom ﬁlters per SPV client should be avoided.
Otherwise, different Bloom ﬁlters should be constructed with
different initial seeds, and should contain different elements.
In this way, an adversary does not gain considerable advan-
tage when acquiring two or more Bloom ﬁlters.
Observation 3: SPV clients should keep state about their outsourced
Bloom ﬁlters (i.e., on persistent storage) to avoid the need to
re-compute a ﬁlter which contains the same elements using
different parameters.
Observation 4: As mentioned earlier, inserting both the public key
and the public key hash (the address) in the Bloom ﬁlter pro-
vides a sufﬁcient distinguisher for the adversary in guessing
whether an address is a true positive or not. Note that for
the most common transaction type Pubkey Hash (P2PKH),
inserting the hash of the public key is sufﬁcient. However,
there might be other transaction types where it is beneﬁcial to
also store the public key in the Bloom ﬁlter. In this case, the
client can insert either a Bitcoin address or its corresponding
public key (but not both) in the same Bloom ﬁlter. Indeed,
sample experimental results that we conducted show that for
almost 99% of all addresses in the network, it sufﬁces to in-
sert either the public key or the public key hash within the
same Bloom ﬁlter in order to receive all the relevant transac-
tions destined to the address.
Our Solution.
In what follows, we describe a solution which leverages Obser-
vations 1, 2, 3, and 4. Our proposed solution unfolds as follows.
During the ﬁrst setup of the client, each SPV client generates N
Bitcoin addresses, and embeds them in a Bloom ﬁlter which can ﬁt
M = m = N. Here, the Bloom ﬁlter is constructed with a real-
istic target false positive rate Pt, which combined with N and M,
results in a target privacy level (cf. Equation 3). Note that since
M = m, then we ensure that the Bloom ﬁlter’s false positive rate
matches Pt (cf. Section 4). Here, we assume that only the address
is inserted within each ﬁlter.
Clearly, since the user might not directly use all N addresses,
some of his Bitcoin addresses will not be revealed and will remain
in his wallets. Whenever users run out of their N addresses and
need to get additional addresses, they repeat the aforementioned
setup process. That is, users create an additional set of N addresses
and embed them in a new Bloom ﬁlter—constructed with a new
initial seed— with M = m = N, and using the previously chosen
Pt. Here, the advantage of an adversary which captures one or
more Bloom ﬁlters pertaining to the same SPV client is negligible,
since these ﬁlters do not have any element in common.
Additionally, our solution requires the SPV clients to keep state,
e.g., about each Bloom ﬁlter, to avoid the need of re-computation of
the same ﬁlter if the client restarts at any point in time. We point out
that the required storage overhead to maintain information about
the state of each Bloom ﬁlter is negligible. Indeed, to keep all the
necessary state to reconstruct a Bloom ﬁlter, an SPV client needs
to locally store: (i) the number of addresses embedded in the ﬁler
(4 bytes), (ii) the used target false positive rate Pt (8 bytes), (iii)
the used seed value (8 bytes), (iv) the BloomUpdate ﬂag (2 bytes),
and (v) the addresses inserted in the ﬁlter. The SPV client can add a
pointer in the ECKey class of Bitcoinj in order to link each Bitcoin
address to the Bloom ﬁlter that embeds it; the size of the pointer
is roughly 2 bytes per address. This amounts to a total storage of
2N + 20 bytes per Bloom ﬁlter. For example, when N = 100, the
SPV client needs to store an additional 220 bytes per Bloom ﬁlter
in order to reconstruct the ﬁlter upon restart; clearly, this overhead
can be easily tolerated in existing SPV client implementations.
Clearly, our proposed solution can be directly integrated within
existing SPV clients, and only incurs in small modiﬁcations to ex-
isting client implementations. Moreover, our solution does not in-
cur additional overhead on the SPV clients—apart from the pre-
generation of N Bitcoin addresses (which is only done at setup
time), and the storage space required for each generated Bloom ﬁl-
ter. Note that our solution requires SPV clients to outsource all their
Moreover, we point out that our analysis and solution do not ad-
dress the case where the adversary can link addresses by using side-
channel information from the Bitcoin block chain, namely:
Filtering false positives by date: SPV client implementations only
appeared in the second half of 2011, which is 1.5 years af-
ter Bitcoin started. Therefore, if a Bitcoin address which
was created before 2011 matches the Bloom ﬁlter of an SPV
client, the adversary can label it, with high conﬁdence, to be
a false positive, and not a Bitcoin address of the node. Our
proposed solution however relies on the assumption that the
number of addresses created from 2011 exceeds by far that
corresponding to the period from 2009-2011, during which
Bitcoin was still not widely used at the time.
Clustering Bitcoin addresses: The adversary can make use of tech-
niques such as [11, 18, 22] to link/cluster certain Bitcoin ad-
dresses based on user behavior, transaction amounts/time,
etc., and assess whether an address matching a Bloom ﬁl-
ter is a false positive or a true positive. For instance, if two
addresses which match Bi are used as inputs to the same
transaction, then the adversary can be certain that these ad-
dresses are linked to the same entity [11], and as such are
unlikely to be false positives. Here, we point out that our
proposed solution can be used in conjunction with existing
solutions such as [10, 23] to prevent the linking/clustering of
addresses using such techniques.
7. RELATED WORK
In this section, we overview related work in the area.
User Privacy in Bitcoin: Bitcoin has received considerable atten-
tion from the research community [5, 12, 16–19, 21].
In [11], Androulaki et al. evaluate user privacy in Bitcoin and
show that Bitcoin leaks considerable information about the proﬁles
of user.
In [6], Elias investigates the legal aspects of privacy in
Bitcoin. In [26], Reid and Harrigan explore user anonymity lim-
its in Bitcoin. In [27], Ron and Shamir investigate how users move
BTCs between their various accounts in order to better protect their
privacy. In [22], the authors investigated the possibility of linking
addresses of the same user together by utilizing the Bitcoin peers
network address information (IPs). Miers et al. introduced in [23]
ZeroCoin, a cryptographic extension to Bitcoin that augments the
protocol to prevent the tracing of coin expenditure. In [10], An-
droulaki and Karame proposed an extension of ZeroCoin to hide
the transaction values and address balances in the system.
Privacy in Bloom Filters: As far as we are aware, Mullin et al. [24]
were the ﬁrst to propose an estimate the false positive rate of Bloom
ﬁlters. In [15], Christensen et al. propose a novel technique for
computing the false positive rate, which results in tighter estimates
when compared to [24].
In [13], Bianchi et. al quantify the privacy properties of Bloom
ﬁlters; their analysis, however, does not address the privacy pro-
visions when the adversary has access to multiple Bloom ﬁlters
originating from the same entity. In [25], Nojima et. al, propose a
cryptographically secure privacy-preserving Bloom-ﬁltering proto-
col based on blind signatures; this proposal, however, incurs addi-
tional computational load on SPV nodes.
8. CONCLUSION
Figure 6: Evaluation of our countermeasure. Here, we measure
Ph(1) and Ph(N ) given Pt = 0.05 and assuming the current SPV
client implementation.
In computing Ph(1), we assume that the
SPV client did not restart since initialization.
ﬁlters to full Bitcoin nodes since different ﬁlters embed different
sets of their addresses. Therefore, N should be carefully chosen.
If a user needs many addresses, choosing a larger N would avoid
the generation of a larger number of Bloom ﬁlters. We leave the
task of ﬁnding the best parameters when constructing a Bloom ﬁl-
ter as an interesting direction for future work. Since users typically
have few hundred Bitcoin addresses, we argue that this overhead
can be largely tolerated given the current usage patterns in Bitcoin.
Notice that the larger is N, the smaller are the number of Bloom
ﬁlters created by the SPV client. Note that, in our solution, an SPV
client should not outsource more than one Bloom ﬁlter to each reg-
ular node that it connects to. Indeed, if the client outsources several
ﬁlters to the same node, then the regular node can correlate these
ﬁlters (even if they do not embed the same elements).
In Figure 6, we analytically compute Ph given our countermea-
sure. Clearly, our countermeasure considerably decreases Ph, es-
pecially for clients that have a small number of addresses.
Additional Insights.
We point out that an adversary which has access to the Bitcoin
block chain can observe that Bitcoin addresses which recently were
used by an SPV client do match the Bloom ﬁlter of that client. This
knowledge clearly reduces the privacy of newly used addresses.
Here, we stress that every newly used address of an SPV client
is likely to match the Bloom ﬁlters of a fraction Pt of all other
SPV clients.
In our solution, Pt therefore deﬁnes the minimum
anonymity set size of each address.
One alternative would be to embed existing Bitcoin addresses
that do not belong to the node, when constructing each Bloom ﬁl-
ter. Subsequently, whenever an SPV client needs to generate a new
Bitcoin address, it will choose a Bitcoin address which matches its
existing Bloom ﬁlter7. However, this alternative also results in an
anonymity set deﬁned by Pt; it also comes at the expense of com-
putational overhead incurred on the SPV clients. In an experiment
that we conducted using a Bloom ﬁlter Bt of size 1608 bits with
Pt = 0.05% and m = 102, we were able to generate three new
Bitcoin addresses which match Bt; these addresses were found af-
ter 240,351, 415,877, and 5,767,346 tries, respectively.
7That can be achieved, e.g., by constantly generating a new Bitcoin
address until it matches its existing Bloom ﬁlter.
In this paper, we explored the privacy provisions due to the in-
tegration of Bloom ﬁlters in SPV clients. Our results show that
010020030040050000.20.40.60.81PhNumber of addresses of SPV client  Ph(1) (Analytical)Ph(1) (Countermeasure)Ph(N) (Analytical)Ph(N) (Countermeasure)[15] Ken Christensen, Allen Roginsky, and Miguel Jimeno. A
new analysis of the false positive rate of a bloom ﬁlter.
Information Processing Letters, 110(21):944–949, 2010.
[16] J. Clark and A. Essex. (Short Paper) CommitCoin: Carbon
Dating Commitments with Bitcoin. In Proceedings of
Financial Cryptography and Data Security, 2012.
[17] C. Decker and R. Wattenhofer. Information Propagation in
the Bitcoin Network. In 13-th IEEE International
Conference on Peer-to-Peer Computing, 2013.
[18] Meiklejohn et al. A ﬁstful of bitcoins: Characterizing
payments among men with no names. In Proceedings of the
2013 Conference on Internet Measurement Conference, IMC
’13, pages 127–140, New York, NY, USA, 2013. ACM.
[19] Arthur Gervais, Ghassan Karame, Srdjan Capkun, and
Vedran Capkun. Is bitcoin a decentralized currency? IEEE
Security and Privacy Magazine, 2014.
[20] Mike Hearn. Connection bloom ﬁltering, 2012. Available
from: https://github.com/bitcoin/bips/
blob/master/bip-0037.mediawiki.
[21] Ghassan O. Karame, Elli Androulaki, and Srdjan Capkun.
Double-spending fast payments in bitcoin. In Proceedings of
the 2012 ACM conference on Computer and communications
security, CCS ’12, pages 906–917, New York, NY, USA,
2012. ACM.
[22] Philip Koshy, Diana Koshy, and Patrick McDaniel. An
analysis of anonymity in bitcoin using p2p network trafﬁc.
2014. http://fc14.ifca.ai/papers/fc14_
submission_71.pdf.
[23] Ian Miers, Christina Garman, Matthew Green, and Aviel D.
Rubin. Zerocoin: Anonymous Distributed E-Cash from
Bitcoin. 2013.
[24] James K Mullin. A second look at bloom ﬁlters.
Communications of the ACM, 26(8):570–571, 1983.
[25] Ryo Nojima and Youki Kadobayashi. Cryptographically
secure bloom-ﬁlters. Transactions on Data Privacy,
2(2):131–139, 2009.
[26] F. Reid and M. Harrigan. An Analysis of Anonymity in the
Bitcoin System. CoRR, 2011.
[27] Dorit Ron and Adi Shamir. Quantitative analysis of the full
bitcoin transaction graph. 2013.
http://eprint.iacr.org/2012/584.pdf.
[28] S. Nakamoto. Bitcoin: A Peer-to-Peer Electronic Cash
System, 2009.
[29] S Joshua Swamidass and Pierre Baldi. Mathematical
correction for ﬁngerprint similarity measures to improve
chemical retrieval. Journal of chemical information and
modeling, 47(3):952–964, 2007.
Bloom ﬁlters incur serious privacy leakage in existing SPV client
implementations. More speciﬁcally, we show that a considerable
number of the addresses of users of SPV clients which possess a
modest number of Bitcoin addresses (e.g., < 20) are leaked by a
single Bloom ﬁlter. Moreover, we show that a considerable number
of the addresses of users is leaked if the adversary can collect two
different Bloom ﬁlters issued by the same node, irrespective of the
target false positive rate of the ﬁlter, and of the number of addresses
owned by the user.
Given that such an information leakage might severely harm the
privacy of users, we argue that the integration of appropriate coun-
termeasures in the current SPV client implementation of Bitcoin
emerges as a necessity. To this end, we propose a lightweight so-
lution that enhances the privacy offered by Bloom ﬁlters; our pro-
posal can be integrated within existing SPV client implementations
with minimum modiﬁcations.
9. REFERENCES
[1] Core Development Status Report # 1 - Bitcoin, Available
from https://bitcoinfoundation.org/2012/
11/01/core-development-status-report-1/.
[2] BitcoinJ, Available from
http://bitcoinj.github.io/.
[3] BitcoinJ limitations, Available from
http://bitcoinj.github.io/limitations.
[4] TOR project. Available from:
https://www.torproject.org/.
[5] Bitcoin Gateway, A Peer-to-peer Bitcoin Vault and Payment
Network, 2011. Available from
http://arimaa.com/bitcoin/.
[6] Bitcoin: Tempering the Digital Ring of Gyges or Implausible
Pecuniary Privacy, 2011. Available from
http://ssrn.com/abstract=1937769ordoi:
10.2139/ssrn.1937769.
[7] Bitcoin Blockchain parser, 2013. Available from:
https://github.com/znort987/blockparser.
[8] Bitcoin Wallet, Android, 2014. Available from:
https://play.google.com/store/apps/
details?id=de.schildbach.wallet.
[9] BitcoinJ, privacy assumptions, 2014. Available from:
https:
//github.com/bitcoinj/bitcoinj/blob/
ee2a91010e5cf66299684160d6a48a108ff2299b/
core/src/main/java/com/google/bitcoin/
core/PeerGroup.java#L250.
[10] Elli Androulaki and Ghassan Karame. Hiding transaction
amounts and balances in bitcoin. In Proceedings of
International Conference on Trust & Trustworthy Computing
(TRUST), 2014.
[11] Elli Androulaki, Ghassan Karame, and Srdjan Capkun.
Evaluating user privacy in bitcoin. 2013.
http://eprint.iacr.org/2012/596.pdf.
[12] S. Barber, X. Boyen, E. Shi, and E. Uzun. Bitter to Better -
How to Make Bitcoin a Better Currency. In Proceedings of
Financial Cryptography and Data Security, 2012.
[13] Giuseppe Bianchi, Lorenzo Bracciale, and Pierpaolo Loreti.
Better than nothing privacy with bloom ﬁlters: To what
extent? In Privacy in Statistical Databases, pages 348–363.
Springer, 2012.
[14] Burton H Bloom. Space/time trade-offs in hash coding with
allowable errors. Communications of the ACM,
13(7):422–426, 1970.