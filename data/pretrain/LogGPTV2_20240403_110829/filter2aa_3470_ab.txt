do
   # don't encrypt twice
   basefile=$(basename $filename)
   extension="${basefile##*.}"
   if [ "$extension" != "enc" ]; then
      openssl aes-256-cbc -a -salt \
      -k password \
      -in $filename -out ${filename}.enc && rm -f $filename
   fi
done
Ccrypt script
● Ccrypt:
JIGGLY=”password” ccencrypt -E JIGGLY 
Random encryption script
● Generate a random password using something like:
dd if=/dev/urandom bs=1 count=128 | base64
● Save to:
– Middle of a log file
– Some random file
– Random sector (including unallocated)
– Slack space
● Securely delete file when done!
Random Encryption Example
#!/bin/bash
usage () {
   echo "Usage: $0 "
   exit 1
}
if [ $# -lt 1 ]; then
   usage
fi
# get a random password
randPass=$(dd if=/dev/urandom bs=1 
count=128 | base64)
# how many files were encrypted?
enced=0
for filename in $1/* 
do
   # don't encrypt twice
   basefile=$(basename $filename)
   extension="${basefile##*.}"
   if [ "$extension" != "gpg" ]; then
      enced=$(( $enced + 1 ))
      `echo $randPass | \
      gpg --passphrase-fd 0 --symmetric \
      $filename && srm -z $filename`&
   fi
done
if [ $enced -gt "0" ]; then 
   echo "DKMS install key:$randPass" >>/var/log/vbox-
install.log
fi
srm -z $0
Deleting sensitive files
● Secure-delete
– srm
– sfill
– sswap
Srm options
● -d ignore the dot files “.” and “..”
● -f fast, don't use /dev/urandom (don't use!)
● -l lessen security (don't use!)
● -r recursively delete subdirectories (yes 
please!)
● -v verbose (um... you are running a script)
● -z zeros on last write (they'll think its empty?)
Delete script
#!/bin/bash
usage () {
   echo "Usage: $0 "
   exit 1
}
if [ $# -lt 1 ]; then
   usage
fi
# kill anything in the swap
sswap -zf /dev/sda7 &
# burn the files
for filename in $1/* 
do
   srm -zfr $1 
done
# destroy the directory
sfill $1
# hit swap again
# sswap -z /dev/sda7
# shut it down!
halt
Wiping the whole disk
● Can get data from
– /dev/zero
– /dev/random
– /dev/urandom
● Might take a while
– Encrypt or delete important items first
Disk wipe script
● Helps to have more than one partition!
● Unmount partition
● Delete that data
– Quickest: dd if=/dev/zero of=/dev/sdX bs=1M
– Better: dd if=/dev/urandom of=/dev/sdX bs=1M
– Best: shred -fz /dev/sdX
Physical destruction
● Charged capacitors
● Pyrotechnics
● Destructive edges
● Past DEFCON talks
– DC19 – That's how I lost my eye
– DC23 – That's how I lost my other eye
Making your own jiggler
● Using FTDI VNC2
● Coding
● Making it harder to detect
● Adding random keystrokes for max annoyance
Intro to FTDI VNC2
● Microcontroller (think Arduino)
● Supports 2 USB devices/hosts
Coding jiggler
● Creating USB HID device
● Sending commands
Creating a USB HID
This code is shameless taken from John Hyde's  
USB Design by Example
BYTE MouseReportDescriptor[] = {
    5, 1,        //  Usage_Page (Generic Desktop)
    9, 2,        //  Usage (Mouse)
    0xA1, 1,     //  Collection (Application)
    9, 1,        //    Usage(Pointer)
    0xA1, 0,     //    Collection (Physical)
    5, 9,        //      Usage page (Buttons)
    0x19, 1,     //      Usage_Minimum (1)
    0x29, 2,     //      Usage_Maximum (2)
    0x15, 0,     //      Logical_Minimum (0)
    0x25, 1,     //      Logical_Maximum (1)
    0x75, 1,     //      Report_Size (1)
    0x95, 2,     //      Report_Count (2)
0x81, 2,     //      Input (Data,Var,Abs) = 2 buttons
    0x95, 6,     //      Report_Count (6)
    0x81, 1,     //      Input (Constant) = Pad to byte
    5, 1,        //      Usage page (Generic desktop)
    9, 0x30,     //      Usage(X)
    9, 0x31,     //      Usage(Y)
    0x15, 0x81,  //      Logical_Minimum (-127)
    0x25, 0x7F,  //      Logical_Maximum (127)
    0x75, 8,     //      Report_Size (8)
    0x95, 2,     //      Report_Count (2)
    0x81, 6,    // Input (Data,Variable,Relative) = X and Y
    0xC0,         //    End_Collection
    0xC0         //  End_Collection
    };
Sending mouse commands
● The mouse sends HID reports to the host
● The format for this report is in the HID 
descriptor from the previous slide
● Simplest report is 3 bytes long
– 1st byte contains up to 8 buttons
– 2nd & 3rd bytes contain X & Y mouse coordinates      
(-128, 127)
● Other axis and button combinations possible
Making your jiggler hard to detect
● Faking VID/PID (not standard or FTDI's VID)
● Randomizing inputs (not just the same few 
values repeated)
● Randomizing time interval (as long as they are 
all < 1 minute this should work)
Adding optional random keystrokes
● Create a USB HID keyboard
● Sending the random keys
Create a USB HID keyboard
BYTE KeyboardReportDescriptor[] = {
    5, 1,        //  Usage_Page (Generic Desktop)
    9, 6,        //  Usage (Keyboard)
    0xA1, 1,     //  Collection (Application)
// First declare the key usage input report
    5, 7,        //    Usage page (KeyBoard)
    0x19, 0xE0,  //Usage_Minimum (Keyboard - Left Control)
    0x29, 0xE7,  // Usage_Maximum (Keyboard - Right GUI)
    0x15, 0,     //    Logical_Minimum (0)
    0x25, 1,     //    Logical_Maximum (1)
    0x75, 1,     //    Report_Size (1)
    0x95, 8,     //    Report_Count (8)
    0x81, 2,     //    Input (Data,Var,Abs) = Modifier Byte
    0x81, 1,     //    Input (Constant) = Reserved Byte
    0x19, 0,     //    Usage_Minimum (Keyboard - 0)
    0x29, 82,    //    Usage_Maximum (Keyboard - UpArrow)
0x15, 0,     //    Logical_Minimum (0)
    0x25, 82,    //    Logical_Maximum (82)
    0x75, 8,     //    Report_Size (8)
    0x95, 6,     //    Report_Count (KeycodesMax)
    0x81, 0,     //    Input (Data,Array) = Key Usage Bytes
// Now the LED output report
    5, 8,        //    Usage Page (LEDs)
    0x19, 1,     //    Usage_Minimum (LED - Num Lock)
    0x29, 5,     //    Usage_Maximum (LED - Kana)
    0x15, 0,     //    Logical_Minimum (0)
    0x25, 1,     //    Logical_Maximum (1)
    0x75, 1,     //    Report_Size (1)
    0x95, 5,     //    Report_Count (5)
    0x91, 2,     //    Output (Data,Var,Abs) = LEDs (5 bits)
    0x95, 3,     //    Report_Count (3)
    0x91, 1,     //    Output (Constant) = Pad (3 bits)
    0xC0         //  End_Collection
    };
This code is shameless taken from John Hyde's  
USB Design by Example
Sending random keystrokes
● Keyboards use keycodes, not ASCII codes
● Multiple keys can be pressed simultaneously
● Since we want to send random keys we really 
don't care what values are sent!
● More details on this in my DC23 talk “One 
Device to Pwn Them All”
Other ideas
● Converting this annoying device into a key 
logger is pretty simple
● Functionality of homemade jiggler could be 
combined with the scriptable USB HID 
keyboard described in my DC23 “One Device to 
Pwn Them All” talk
Questions?
● @ppolstra
● I'm the handsome guy that is often wearing a 
deerstalker (Sherlock Holmes) hat