bycheckingtoseewhetheryoureceiveanyadditionalpackets
fromthetargetafteryou’veestablishedaconnection.Youcan
accomplishthisbysniffingthepacketstoseeifanyofthem
weretransmittedwithaTCPflagvalueindicativeof
additional,legitimateservicecommunications.
TCPflagsindicateinformationaboutthestateofapacket
transfer.IfyoulookattheTCPspecification,you’llfindthat
theflagsarestoredinasinglebyteatposition14inthe
packet’sheader.Eachbitofthisbyterepresentsasingleflag
value.Theflagis“on”ifthebitatthatpositionissetto1,and
“off”ifthebitissetto0.Table8-1showsthepositionsofthe
flagsinthebyte,aspertheTCPspecification.
Table8-1:TCPFlagsandTheirBytePositions
Bit
7
6
5
4
3
2
1
0
Flag
CWR
ECE
URG
ACK
PSH
RST
SYN
FIN
Onceyouknowthepositionsoftheflagsyoucareabout,
youcancreateafilterthatchecksthem.Forexample,youcan
lookforpacketscontainingthefollowingflags,whichmight
indicatealisteningservice:
ACKandFIN
ACK
ACKandPSH
Becauseyouhavetheabilitytocaptureandfiltercertain
packetsbyusingthegopacketlibrary,youcanbuildautilitythat
attemptstoconnecttoaremoteservice,sniffsthepackets,and
displaysonlytheservicesthatcommunicatepacketswiththese
TCPheaders.Assumeallotherservicesarefalsely“open”
becauseofSYNcookies.
BuildingtheBPFFilter
YourBPFfilterneedstocheckforthespecificflagvaluesthat
indicatepackettransfer.Theflagbytehasthefollowingvalues
iftheflagswementionedearlierareturnedon:
ACKandFIN:00010001(0x11)
ACK:00010000(0x10)
ACKandPSH:00011000(0x18)
Weincludedthehexequivalentofthebinaryvaluefor
clarity,asyou’llusethehexvalueinyourfilter.
Tosummarize,youneedtocheckthe14thbyte(offset13
fora0-basedindex)oftheTCPheader,filteringonlyfor
packetswhoseflagsare0x11,0x10,or0x18.Here’swhatthe
BPFfilterlookslike:
tcp[13]==0x11ortcp[13]==0x10ortcp[13]==0x18
Excellent.Youhaveyourfilter.
WritingthePortScanner
Nowyou’llusethefiltertobuildautilitythatestablishesafull
TCPconnectionandinspectspacketsbeyondthethree-way
handshaketoseewhetherotherpacketsaretransmitted,
indicatingthatanactualserviceislistening.Theprogramis
showninListing8-6.Forthesakeofsimplicity,we’veopted
tonotoptimizethecodeforefficiency.However,youcan
greatlyimprovethiscodebymakingoptimizationssimilarto
thosewemadeinChapter2.
var(❶
snaplen=int32(320)
promisc=true
timeout=pcap.BlockForever
filter="tcp[13]==0x11ortcp[13]==0x10ortcp[13]==0x18"
devFound=false
results=make(map[string]int)
)
funccapture(iface,targetstring){❷
handle,err:=pcap.OpenLive(iface,snaplen,promisc,timeout)
iferr!=nil{
log.Panicln(err)
}
deferhandle.Close()
iferr:=handle.SetBPFFilter(filter);err!=nil{
log.Panicln(err)
}
source:=gopacket.NewPacketSource(handle,handle.LinkType())
fmt.Println("Capturingpackets")
forpacket:=rangesource.Packets(){
networkLayer:=packet.NetworkLayer()❸
ifnetworkLayer==nil{
continue
}
transportLayer:=packet.TransportLayer()
iftransportLayer==nil{
continue
}
srcHost:=networkLayer.NetworkFlow().Src().String()❹
srcPort:=transportLayer.TransportFlow().Src().String()
ifsrcHost!=target{❺
continue
}
results[srcPort]+=1❻
}
}
funcmain(){
iflen(os.Args)!=4{
log.Fatalln("Usage:main.go
")
}
devices,err:=pcap.FindAllDevs()
iferr!=nil{
log.Panicln(err)
}
iface:=os.Args[1]
for_,device:=rangedevices{
ifdevice.Name==iface{
devFound=true
}
}
if!devFound{
log.Panicf("Devicenamed'%s'doesnotexist\n",iface)
}
ip:=os.Args[2]
gocapture(iface,ip)❼
time.Sleep(1*time.Second)
ports,err:=explode(os.Args[3])
iferr!=nil{
log.Panicln(err)
}
for_,port:=rangeports{❽
target:=fmt.Sprintf("%s:%s",ip,port)
fmt.Println("Trying",target)
c,err:=net.DialTimeout("tcp",target,1000*time.Millisecond)❾
iferr!=nil{
continue
}
c.Close()
}
time.Sleep(2*time.Second)
forport,confidence:=rangeresults{❿
ifconfidence>=1{
fmt.Printf("Port%sopen(confidence:%d)\n",port,confidence)
}
}
}
/*Extraneouscodeomittedforbrevity*/
Listing8-6:ScanningandprocessingpacketswithSYN-floodprotections(/ch-
8/syn-flood/main.go)
Broadlyspeaking,yourcodewillmaintainacountof
packets,groupedbyport,torepresenthowconfidentyouare
thattheportisindeedopen.You’lluseyourfiltertoselect
onlypacketswiththeproperflagsset.Thegreaterthecountof
matchingpackets,thehigheryourconfidencethattheservice
islisteningontheport.
Yourcodestartsbydefiningseveralvariablesforuse
throughout❶.Thesevariablesincludeyourfilterandamap
namedresultsthatyou’llusetotrackyourlevelofconfidence
thattheportisopen.You’llusetargetportsaskeysand
maintainacountofmatchingpacketsasthemapvalue.
Nextyoudefineafunction,capture(),thatacceptsthe
interfacenameandtargetIPforwhichyou’retesting❷.The
functionitselfbootstrapsthepacketcapturemuchinthesame
wayaspreviousexamples.However,youmustusedifferent
codetoprocesseachpacket.Youleveragethegopacket
functionalitytoextractthepacket’snetworkandtransport
layers❸.Ifeitheroftheselayersisabsent,youignorethe
packet;that’sbecausethenextstepistoinspectthesourceIP
andportofthepacket❹,andifthere’snotransportor
networklayer,youwon’thavethatinformation.Youthen
confirmthatthepacketsourcematchestheIPaddressthat
you’retargeting❺.IfthepacketsourceandIPaddressdon’t
match,youskipfurtherprocessing.Ifthepacket’ssourceIP
andportmatchyourtarget,youincrementyourconfidence
levelfortheport❻.Repeatthisprocessforeachsubsequent
packet.Eachtimeyougetamatch,yourconfidencelevel
increases.
Inyourmain()function,useagoroutinetocallyourcapture()
function❼.Usingagoroutineensuresthatyourpacket
captureandprocessinglogicrunsconcurrentlywithout
blocking.Meanwhile,yourmain()functionproceedstoparse
yourtargetports,loopingthroughthemonebyone❽and
callingnet.DialTimeouttoattemptaTCPconnectionagainsteach
❾.Yourgoroutineisrunning,activelywatchingthese
connectionattempts,lookingforpacketsthatindicateaservice
islistening.
Afteryou’veattemptedtoconnecttoeachport,processall
ofyourresultsbydisplayingonlythoseportsthathavea
confidencelevelof1ormore(meaningatleastonepacket
matchesyourfilterforthatport)❿.Thecodeincludesseveral
callstotime.Sleep()toensureyou’releavingadequatetimetoset
upthesnifferandprocesspackets.
Let’slookatasamplerunoftheprogram,showninListing
8-7.
$gobuild-osyn-flood&&sudo./syn-floodenp0s510.1.100.100
80,443,8123,65530
Capturingpackets
Trying10.1.100.100:80
Trying10.1.100.100:443
Trying10.1.100.100:8123
Trying10.1.100.100:65530
Port80open(confidence:1)
Port443open(confidence:1)
Listing8-7:Port-scanningresultswithconfidenceratings
Thetestsuccessfullydeterminesthatbothport80and443
areopen.Italsoconfirmsthatnoserviceislisteningonports
8123and65530.(Notethatwe’vechangedtheIPaddressin
theexampletoprotecttheinnocent.)
Youcouldimprovethecodeinseveralways.Aslearning
exercises,wechallengeyoutoaddthefollowing
enhancements:
1. Removethenetworkandtransportlayerlogicandsourcechecksfromthe
capture()function.Instead,addadditionalparameterstotheBPFfiltertoensure
thatyoucaptureonlypacketsfromyourtargetIPandports.
2. Replacethesequentiallogicofportscanningwithaconcurrentalternative,
similartowhatwedemonstratedinpreviouschapters.Thiswillimprove
efficiency.
3. RatherthanlimitingthecodetoasingletargetIP,allowtheusertosupplyalist
ofIPsornetworkblocks.
SUMMARY
We’vecompletedourdiscussionofpacketcaptures,focusing
primarilyonpassivesniffingactivities.Inthenextchapter,
we’llfocusonexploitdevelopment.
9
WRITINGANDPORTINGEXPLOIT
CODE
Inthemajorityofthepreviouschapters,youusedGotocreate
network-basedattacks.You’veexploredrawTCP,HTTP,
DNS,SMB,databaseinteraction,andpassivepacket
capturing.
Thischapterfocusesinsteadonidentifyingandexploiting
vulnerabilities.First,you’lllearnhowtocreateavulnerability
fuzzertodiscoveranapplication’ssecurityweaknesses.Then
you’lllearnhowtoportexistingexploitstoGo.Finally,we’ll
showyouhowtousepopulartoolstocreateGo-friendly
shellcode.Bytheendofthechapter,youshouldhaveabasic
understandingofhowtouseGotodiscoverflawswhilealso
usingittowriteanddelivervariouspayloads.
CREATINGAFUZZER
Fuzzingisatechniquethatsendsextensiveamountsofdatato
anapplicationinanattempttoforcetheapplicationtoproduce
abnormalbehavior.Thisbehaviorcanrevealcodingerrorsor
securitydeficiencies,whichyoucanlaterexploit.
Fuzzinganapplicationcanalsoproduceundesirableside
effects,suchasresourceexhaustion,memorycorruption,and
serviceinterruption.Someofthesesideeffectsarenecessary
forbughuntersandexploitdeveloperstodotheirjobsbutbad
forthestabilityoftheapplication.Therefore,it’scrucialthat
youalwaysperformfuzzinginacontrolledlabenvironment.
Aswithmostofthetechniqueswediscussinthisbook,don’t
fuzzapplicationsorsystemswithoutexplicitauthorization
fromtheowner.
Inthissection,you’llbuildtwofuzzers.Thefirstwill
checkthecapacityofaninputinanattempttocrashaservice
andidentifyabufferoverflow.Thesecondfuzzerwillreplay
anHTTPrequest,cyclingthroughpotentialinputvaluesto
detectSQLinjection.
BufferOverflowFuzzing
Bufferoverflowsoccurwhenausersubmitsmoredatainan
inputthantheapplicationhasallocatedmemoryspacefor.For
example,ausercouldsubmit5,000characterswhenthe
applicationexpectstoreceiveonly5.Ifaprogramusesthe
wrongtechniques,thiscouldallowtheusertowritethat
surplusdatatopartsofmemorythataren’tintendedforthat
purpose.This“overflow”corruptsthedatastoredwithin
adjacentmemorylocations,allowingamalicioususerto
potentiallycrashtheprogramoralteritslogicalflow.
Bufferoverflowsareparticularlyimpactfulfornetwork-
basedprogramsthatreceivedatafromclients.Usingbuffer
overflows,aclientcandisruptserveravailabilityorpossibly
achieveremotecodeexecution.It’sworthrestating:don’tfuzz
systemsorapplicationsunlessyouarepermittedtodoso.In
addition,makesureyoufullyunderstandtheconsequencesof
crashingthesystemorservice.
HowBufferOverflowFuzzingWorks
Fuzzingtocreateabufferoverflowgenerallyinvolves
submittingincreasinglylongerinputs,suchthateach
subsequentrequestincludesaninputvaluewhoselengthisone
characterlongerthanthepreviousattempt.Acontrived
exampleusingtheAcharacterasinputwouldexecute
accordingtothepatternshowninTable9-1.
Bysendingnumerousinputstoavulnerablefunction,
you’lleventuallyreachapointwherethelengthofyourinput
exceedsthefunction’sdefinedbuffersize,whichwillcorrupt
theprogram’scontrolelements,suchasitsreturnand
instructionpointers.Atthispoint,theapplicationorsystem
willcrash.
Bysendingincrementallylargerrequestsforeachattempt,
youcanpreciselydeterminetheexpectedinputsize,whichis
importantforexploitingtheapplicationlater.Youcanthen
inspectthecrashorresultingcoredumptobetterunderstand
thevulnerabilityandattempttodevelopaworkingexploit.We
won’tgointodebuggerusageandexploitdevelopmenthere;
instead,let’sfocusonwritingthefuzzer.
Table9-1:InputValuesinaBufferOverflowTest
Attempt
Inputvalue
1
A
2
AA
3
AAA
4
AAAA
N
ArepeatedNtimes
Ifyou’vedoneanymanualfuzzingusingmodern,
interpretedlanguages,you’veprobablyusedaconstructto
createstringsofspecificlengths.Forexample,thefollowing
Pythoncode,runwithintheinterpreterconsole,showshow
simpleitistocreateastringof25Acharacters:
>>>x="A"*25
>>>x
'AAAAAAAAAAAAAAAAAAAAAAAAA'
Unfortunately,Gohasnosuchconstructtoconveniently
buildstringsofarbitrarylength.You’llhavetodothattheold-
fashionedway—usingaloop—whichwouldlooksomething
likethis:
var(
nint
sstring
)
forn=0;n<25;n++{
s+="A"
}
Sure,it’salittlemoreverbosethanthePythonalternative,
butnotoverwhelming.
Theotherconsiderationyou’llneedtomakeisthedelivery
mechanismforyourpayload.Thiswilldependonthetarget
applicationorsystem.Insomeinstances,thiscouldinvolve
writingafiletoadisk.Inothercases,youmightcommunicate
overTCP/UDPwithanHTTP,SMTP,SNMP,FTP,Telnet,or
othernetworkedservice.
Inthefollowingexample,you’llperformfuzzingagainsta
remoteFTPserver.Youcantweakalotofthelogicwe
presentfairlyquicklytooperateagainstotherprotocols,soit
shouldactasagoodbasisforyoutodevelopcustomfuzzers
againstotherservices.
AlthoughGo’sstandardpackagesincludesupportforsome
commonprotocols,suchasHTTPandSMTP,theydon’t
includesupportforclient-serverFTPinteractions.Instead,you
coulduseathird-partypackagethatalreadyperformsFTP
communications,soyoudon’thavetoreinventthewheeland
writesomethingfromthegroundup.However,formaximum
control(andtoappreciatetheprotocol),you’llinsteadbuild
thebasicFTPfunctionalityusingrawTCPcommunications.If
youneedarefresheronhowthisworks,refertoChapter2.
BuildingTheBufferOverflowFuzzer
Listing9-1showsthefuzzercode.(Allthecodelistingsatthe
rootlocationof/existundertheprovidedgithubrepo
https://github.com/blackhat-go/bhg/.)We’vehardcodedsome
values,suchasthetargetIPandport,aswellasthemaximum
lengthofyourinput.ThecodeitselffuzzestheUSERproperty.
Sincethispropertyoccursbeforeauserisauthenticated,it
representsacommonlytestablepointontheattacksurface.
Youcouldcertainlyextendthiscodetotestotherpre-
authenticationcommands,suchasPASS,butkeepinmindthat
ifyousupplyalegitimateusernameandthenkeepsubmitting
inputsforPASS,youmightgetlockedouteventually.
funcmain(){
❶fori:=0;i<2500;i++{
❷conn,err:=net.Dial("tcp","10.0.1.20:21")
iferr!=nil{
❸log.Fatalf("[!]Erroratoffset%d:%s\n",i,err)
}
❹bufio.NewReader(conn).ReadString('\n')
user:=""
❺forn:=0;n<=i;n++{
user+="A"
}
raw:="USER%s\n"
❻fmt.Fprintf(conn,raw,user)
bufio.NewReader(conn).ReadString('\n')
raw="PASSpassword\n"