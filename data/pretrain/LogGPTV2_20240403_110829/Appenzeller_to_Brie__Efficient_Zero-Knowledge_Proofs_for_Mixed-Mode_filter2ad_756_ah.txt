MultiplicationCheck Upon
putting
(idğ‘¥,ğ‘–, ğ‘¥ğ‘–), (idğ‘¦,ğ‘–, ğ‘¦ğ‘–), (idğ‘§,ğ‘–, ğ‘§ğ‘–) âˆˆ st for ğ‘– = 1, . . . , ğ‘›:
(1) Send (success) to V if ğ‘¥ğ‘–
in-
where
Â· ğ‘¦ğ‘– = ğ‘§ğ‘– holds for all
ğ‘– = 1, . . . , ğ‘›, otherwise send (abort) to all parties and
terminate.
ğ‘–=1).
&
(CheckMult, (idğ‘¥,ğ‘–, idğ‘¦,ğ‘–, idğ‘§,ğ‘–)ğ‘›
ğ‘–=1)
P
We use the shorthand CheckMult(([ğ‘¥ğ‘–], [ğ‘¦ğ‘–], [ğ‘§ğ‘–])ğ‘›
Figure 15: Functionality modeling homomorphic commit-
ments of values in the ring ğ‘….
communicates with two parties P,V. It contains
F 2,ğ‘€
ComZK
two separate instances of the commitment functionality
F ğ‘…
, one for ğ‘… = Z2 and the other for ğ‘… = Zğ‘€. Com-
mitments are denoted as [Â·]2 and [Â·]ğ‘€, respectively.
ComZK
The parties can use the functions of F ğ‘…
with respect
to both domains Z2 and Zğ‘€, so all functions are parameter-
ized by a domain unless apparent from context. Then, any
use of [Â·]2 or [Â·]ğ‘€ interfaces are dealt with in the same
way as F ğ‘…
ComZK
.
ComZK
Figure 16: Ideal functionality modeling communication us-
ing commitments over multiple domains.
B PROOF OF CORRECT TRUNCATION
FVerifyTrunc (Figure 7) in the FCheckLength-hybrid model.
Theorem B.1. The protocol Î VerifyTrunc (Figure 10) UC-realizes
Before writing the proof, we make the following observations.
First, if correct information is provided by P, then the protocol
completes. Intuitively, if the prover provides a correct [ğ‘â€²]ğ‘€ = [ğ‘
mod 2ğ‘š]ğ‘€ and [ğ‘ğ‘¡ğ‘Ÿ]ğ‘€, then when both of these are subtracted
from [ğ‘]ğ‘€, then it will be equal to 0 as required by CheckZero.
CheckLength on ([ğ‘â€²]ğ‘€, ğ‘š): This ensures that [ğ‘â€²]ğ‘€ can be rep-
resented by ğ‘š bits.
CheckLength on ([ğ‘ğ‘¡ğ‘Ÿ]ğ‘€, ğ‘™ âˆ’ ğ‘š): This ensures that [ğ‘ğ‘¡ğ‘Ÿ]ğ‘€ can be
represented by ğ‘™ âˆ’ ğ‘š bits.
CheckZero([ğ‘]ğ‘€ âˆ’ (2ğ‘š Â· [ğ‘ğ‘¡ğ‘Ÿ]ğ‘€ + [ğ‘â€²]ğ‘€)): This check ensures cor-
rectness of the two values [ğ‘â€²]ğ‘€ and [ğ‘ğ‘¡ğ‘Ÿ]ğ‘€. As we know
that they are both of correct length (ğ‘š and ğ‘™ âˆ’ ğ‘š respec-
tively), 2ğ‘š Â· ğ‘ğ‘¡ğ‘Ÿ + ğ‘â€² exactly represents all values in [0, 2ğ‘™ âˆ’1].
Therefore, the truncation must be correct.
We now proceed with the proof.
Proof. We consider a malicious prover and a malicious verifier
separately. In both cases we will construct a simulator S given
access to FVerifyTrunc that will emulate FCheckLength. We implicitly
assume that S passes all communication between the adversary
(either Pâˆ— or Vâˆ— dependent on the case) and the environment Z.
Malicious Prover. S sends (corrupted, P) to the ideal functional-
ity FVerifyTrunc. It also creates copies of the prover Pâˆ— and verifier
V, and runs the verifier according to the protocol Î VerifyTrunc, while
letting the prover behave as instructed by the environment Z.
(1) S forwards Input on [ğ‘â€²]ğ‘€.
(2) S forwards any calls to FCheckLength. If any calls to FCheckLength
(3) For the remainder of the protocol, S acts like an honest verifier.
(4) Lastly, S forwards the call (VerifyTrunc, Â·, Â·).
The only avenue for Pâˆ— to distinguish the ideal from the real world
is the case of passing the verification check with an incorrect trun-
cation. As argued above, this can never happen. This completes the
returns âŠ¥, then S outputs âŠ¥ to FVerifyTrunc and abort.
Session 1C: Zero Knowledge I CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea206proof for the case of a malicious prover.
Malicious Verifier. S sends (corrupted,V) to the ideal function-
ality FVerifyTrunc. It also creates copies of the prover P and verifier
Vâˆ—, and runs the prover according to the protocol Î VerifyTrunc,
while letting the verifier behave as instructed by the environment
Z. If S receives âŠ¥ from FConv, then it simply abort. Otherwise S
interacts with the verifier as follows:
(1) S forwards the call (VerifyTrunc, ğ‘ , {ğ‘š ğ‘— , [ğ‘ ğ‘—]ğ‘€, [ğ‘ ğ‘—
ğ‘¡ğ‘Ÿ]ğ‘€} ğ‘— âˆˆ[ğ‘ ]).
If FVerifyTrunc returns âŠ¥, output âŠ¥ to Vâˆ— and abort.
(2) For each ğ‘— âˆˆ [ğ‘] S commits to a random value [ğ‘â€²]ğ‘€ using
Input of FCheckLength. We assume that simulated commitments
to ğ‘ ğ‘— , ğ‘
(3) For each iteration ğ‘— âˆˆ [ğ‘], let ğ‘™ be the size of ğ‘ ğ‘— and ğ‘š be the
â€²,ğ‘— already exist in FCheckLength.
â€²,ğ‘—. S runs (CheckLength, idğ‘
â€²,ğ‘— , ğ‘š) and
(4) S then computes ğ‘¦ ğ‘— â† ğ‘ ğ‘— âˆ’ (2ğ‘š Â· ğ‘ ğ‘—
and then runs (CheckZero, idğ‘¦ ğ‘—), which it makes output (success).
ğ‘¡ğ‘Ÿ , ğ‘™ âˆ’ğ‘š) in FCheckLength towards the verifier.
â€²,ğ‘—) using FCheckLength
The view of Vâˆ— simulated by S is distributed identically to its view
in the real protocol. Any value being communicated to Vâˆ— is hidden
in the commitment functionality.
â–¡
ğ‘¡ğ‘Ÿ + ğ‘
size of ğ‘
(CheckLength, idğ‘ ğ‘—
C A NAÃVE TRUNCATION PROTOCOL
For comparison, we now describe a â€œnaÃ¯veâ€ way of truncating some
value [ğ‘]ğ‘€ where ğ‘ âˆˆ [0, 2ğ‘™) âŠ‚ Zğ‘€, without doing any conversions
to Z2. Informally, the prover provides [ğ‘]ğ‘€ as well as its supposed
bit decomposition ([ğ‘0]ğ‘€, . . . , [ğ‘ğ‘™âˆ’1]ğ‘€) authenticated in Zğ‘€. The
prover then has to convince the verifier that each authenticated
[ğ‘ğ‘–]ğ‘€ is a bit and that they all sum up to [ğ‘]ğ‘€, thus proving the
correctness of the bit decomposition. Lastly, the prover and verifier
can individually sum up most-significant ğ‘™ âˆ’ ğ‘š bits, resulting in the
truncated value [ğ‘ğ‘¡ğ‘Ÿ]ğ‘€.
Protocol Î NaiveTrunc
Input [ğ‘]ğ‘€ and itâ€™s
([ğ‘0]ğ‘€, . . . , [ğ‘ğ‘™âˆ’1]ğ‘€).
Protocol
(1) For ğ‘– = 0, . . . , ğ‘™âˆ’1 compute [ğ‘¦ğ‘–]ğ‘€ = [ğ‘ğ‘–]ğ‘€ Â·(1âˆ’[ğ‘ğ‘–]ğ‘€).
supposed bit decomposition
ğ‘–=0[ğ‘ğ‘–]ğ‘€2ğ‘–.
(2) Let [ğ‘¦]ğ‘€ â†ğ‘™âˆ’1
(4) Let [ğ‘ğ‘¡ğ‘Ÿ]ğ‘€ â†ğ‘™âˆ’ğ‘š
Output [ğ‘ğ‘¡ğ‘Ÿ]ğ‘€.
(3) Run CheckZero([ğ‘¦]ğ‘€, [ğ‘¦0]ğ‘€, . . . , [ğ‘¦ğ‘™âˆ’1]ğ‘€), output
abort if the check fails and terminate.
ğ‘–=0 [ğ‘ğ‘™âˆ’ğ‘š+ğ‘–]ğ‘€2ğ‘–.
Figure 17: Protocol that naÃ¯vely truncates ğ‘ by ğ‘š bits
[ğ‘ğ‘–]ğ‘€ for ğ‘– âˆˆ [ğ‘™] requires a multiplication, leading to further interac-
tion. To give an example, we analyze the cost of this protocol when
using Wolverine [31] to check the multiplications (alternative pro-
tocols such as [4] could also be used, but this does not significantly
change the costs). For ğ‘™ multiplications in Zğ‘€, Wolverine runs a
total of (ğµ âˆ’ 1) Â· ğ‘™ iterations, each requiring 1 multiplication triples,
for a total of (3(ğµ âˆ’ 1)) Â· ğ‘™ random authentications and (ğµ âˆ’ 1)ğ‘™
fix (where fix corresponds to inputting a specific value into the
commitment functionality) in Zğ‘€. Secondly, each iteration opens
2 values and performs a single CheckZero. All calls to CheckZero
may be batched together and performed at the end, but the other
2 must be done in each iteration, for a total of ğ‘™ Â· ((ğµ âˆ’ 1) Â· 2) + 1
openings in Zğ‘€. Lastly, in step 3, all the checks for ğ‘ğ‘–(1âˆ’ğ‘ğ‘–) ?
= 0 are
batched together for a total of 1 opening. Throughout this analysis,
we assume weâ€™re working in a small field such that log(ğ‘€) â‰¤ ğ‘  for
some security parameter. If instead it holds that log(ğ‘€) > ğ‘ , then
we can save a factor (ğµ âˆ’ 1) in these costs.
A breakdown of the costs of Î NaiveTrunc compared to those of
our optimized protocol Î VerifyTrunc (Figure 10) is given in Table 5,
where we list both if log(ğ‘€) â‰¥ ğ‘  but also log(ğ‘€) > ğ‘  . In both cases,
for typical parameters (e.g. ğ‘™ = 32 â‰ˆ log ğ‘€ and ğµ = 3â€“5) the naive
protocol has much higher communication cost than ours, since
the number of Zğ‘€ openings scales with the bit-length ğ‘™. To give a
concrete number, e.g. for the Zğ‘ variant with ğ‘™ = 32 â‰ˆ log ğ‘€, when
verifying a batch of around a million multiplications and 40-bit
statistical security, we can use a bucket size ğµ = 3. This leads to
the communication of 8256 bits when using the naÃ¯ve compared to
only 960 when using ours, when we disregard the construction of
the random authentications in Z2 and Zğ‘ for both protocols.
D SUB-PROTOCOLS
We look at the two sub-protocols convertBit2A and bitADDcarry
that is used in our protocol verifying converion tuples.
D.1 Complexity of bitADDcarry
We assume that the input is distributed prior to running the protocol.
The bitADDcarry circuit is implemented as a ripple-carry adder
which computes the carry bit at every position with the following
equation
ğ‘ğ‘–+1 = ğ‘ğ‘– âŠ• ((ğ‘¥ğ‘– âŠ• ğ‘ğ‘–) âˆ§ (ğ‘¦ğ‘– âŠ• ğ‘ğ‘–)),âˆ€ğ‘– âˆˆ {0, . . . , ğ‘š âˆ’ 1}
(2)
where ğ‘0 = 0 and ğ‘¥ğ‘–, ğ‘¦ğ‘– are the iâ€™th bits of the two binary inputs.
The output is then
ğ‘§ğ‘– = ğ‘¥ğ‘– âŠ• ğ‘¦ğ‘– âŠ• ğ‘ğ‘–,âˆ€ğ‘– âˆˆ {0, . . . , ğ‘š âˆ’ 1}
(3)
and the last carry bit ğ‘ğ‘š. This requires ğ‘š AND gates and as such ğ‘š
rounds of communication. As all the âŠ• can be computed by ğ‘ƒ1 and
ğ‘ƒ2 locally (and as such requires no communication), 1 field element
must be communicated per round. As this circuit is evaluated ğµ âˆ’ 1
times per bucket, it results in a total for (ğµ âˆ’ 1)ğ‘š field elements
which must be communicated.
This protocol is much more expensive than our edaBit-based
approach, due to working in Zğ‘€ for all operations. Each bit must
be committed to by a commitment over Zğ‘€, which itself requires
log2(ğ‘€) bits of communication. Furthermore, the checking of each
D.2 Complexity of convertBit2A
We consider the procedure convertBit2A as defined in Figure 4.
We assume that the input (not the daBit) is distributed prior to
running the protocol. This sub-protocol requires a single daBit to
Session 1C: Zero Knowledge I CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea207Table 5: Comparison of the costs of Î NaiveTrunc (Figure 17) and Î VerifyTrunc (Figure 10).
NaÃ¯ve log(ğ‘€) â‰¤ ğ‘ 
NaÃ¯ve log(ğ‘€) > ğ‘ 
Ours
NaÃ¯ve log(ğ‘€) â‰¤ ğ‘ 
NaÃ¯ve log(ğ‘€) > ğ‘ 
Ours
#Openings F2
0
0
ğµğ‘™ + 2ğµ
#Openings Zğ‘€
ğ‘™((ğµ âˆ’ 1) Â· 2) + 2
ğ‘™ Â· 2 + 2
2ğµ + 1
#(e)dabit COTs
#(e)dabit VOLEs
0
0
ğµğ‘™ + 2ğµ
0
0
4ğµ
#Faulty triples F2
0
0
ğµğ‘™
#Faulty triples Zğ‘€
(ğµ âˆ’ 1)ğ‘™
ğ‘™
0
#Bits from fix
2(ğµ âˆ’ 1)ğ‘™ log2(ğ‘€)
2ğ‘™ Â· log2(ğ‘€)
(ğµ + 1)ğ‘™ + (4ğµ + 2) log2(ğ‘€)
convert the bit authenticated in F2 to Fğ‘€. Having a single daBit
([ğ‘Ÿ]2, [ğ‘Ÿ]ğ‘€), we can convert a value [ğ‘¥ğ‘š]2 by following the follow-
ing protocol.
(1) Compute [ğ‘]2 = [ğ‘¥ğ‘š]2 + [ğ‘Ÿ]2
(2) ğ‘ â† Open([ğ‘]2)
(3) [ğ‘¥]ğ‘€ = ğ‘ + [ğ‘Ÿ]ğ‘€ âˆ’ 2 Â· ğ‘ Â· [ğ‘Ÿ]ğ‘€.
We note that the only things requiring communication, is the dis-
tribution of the daBit used during the protocol and the opening of
the value [ğ‘]2. As such, we conclude that this requires the sending
of four field elements (the opening of [ğ‘]2 and the sending of the
two bits of the daBit) and the cost of generating 1 daBit.
E PROOFS OF THE Z2ğ‘˜ PROTOCOLS
Here we present the full proofs of security that were omitted in
Section 5.3.
E.1 Proof of Theorem 5.1
Proof of Theorem 5.1. To show security in the UC-model, we
construct a simulatorS with access to the ideal functionality F Z2ğ‘˜
ComZK
The environment can choose to corrupt one of the parties, where-
upon S simulates the interaction for the corrupted party. We cover
the two cases separately, and first consider a corrupted prover, then
a corrupted verifier.
Throughout the proof, we assume that the parties behave some-
what sensible, e.g. they use correct value identifiers, both parties
access the functionality in a matching way, and that the simulator
can always detect which method is to be executed.
.
ComZK
Z2ğ‘˜
ComZK-a
Malicious Prover. S sends (corrupted, P) to the ideal function-
. It also creates copies of the prover Pâˆ— and verifier
ality F Z2ğ‘˜
V, and runs the verifier according to the protocol Î 
, while
letting the prover behave as instructed by the environment. For
this, S simulates the functionality of F ğ‘ ,ğ‘˜+ğ‘ 
with corrupted P. If
the simulated P aborts the protocol, S sends (abort) to F Z2ğ‘˜
.