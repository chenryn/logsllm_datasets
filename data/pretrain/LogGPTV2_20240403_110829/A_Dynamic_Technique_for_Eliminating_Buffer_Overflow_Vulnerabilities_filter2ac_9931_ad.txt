tion in the face of memory errors, memory-safe program-
ming language implementations, traditional error recovery,
and data structure repair.
5.1 Memory Errors and Continued Execution
Boundless memory blocks enable the program to continue
to execute through memory errors. We have also developed
a technique, called failure-oblivious computing, which simply
discards out of bounds writes and manufactures values to re-
turn as the result of out of bounds reads [36]. Even though
this technique has the potential to take the program down an
unanticipated execution path, in practice it enables servers
to execute through memory errors (such as buﬀer overﬂows)
and continue on to correctly serve subsequent requests. An-
other approach responds to memory errors by terminating
the enclosing function and continuing on to execute the code
immediately following the corresponding function call [40].
The results indicate that, in many cases, the program can
continue on to execute acceptably after the premature func-
Proceedings of the 20th Annual Computer Security Applications Conference (ACSAC’04) 
1063-9527/04 $ 20.00 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 11:38:47 UTC from IEEE Xplore.  Restrictions apply. 
tion termination. These techniques diﬀer from boundless
memory blocks in that they are designed to convert incor-
rect and dangerous execution paths into unanticipated but
acceptable execution paths. Boundless memory blocks, of
course, can convert incorrect execution paths into correct
and anticipated execution paths.
speciﬁc information (in the case of data structure repair, a
data structure consistency speciﬁcation). But because there
is no explicit recovery procedure and because the consistency
speciﬁcation is not tied to speciﬁc blocks of code, data struc-
ture repair may enable systems to more eﬀectively recover
from unanticipated data structure corruption errors.
5.2 Safe-C Compilers
Our work builds on previous research into implementing
memory-safe versions of C [15, 43, 34, 27, 38, 28]. As de-
scribed in Section 3, our implementation uses techniques
originally developed by Jones and Kelly [28], then signif-
icantly reﬁned by Ruwase and Lam [38]. Memory-safe C
compilers can use a variety of techniques for detecting out
of bounds memory accesses via pointers; all of these tech-
niques modify the representation of pointers in some way as
compared to standard C compilers. To implement boundless
memory blocks it is essential that the pointer representation
preserve the memory block and oﬀset information for out of
bounds pointers.
It is also feasible to implement boundless memory blocks
for safe languages such as Java or ML by simply replacing
the generated code that throws an exception in response
to an out of bounds access. The new generated code, of
course, would store out of bounds writes in the hash table
and appropriately retrieve the stored value for out of bounds
reads.
5.3 Traditional Error Recovery
The traditional error recovery mechanism is to reboot the
system, with repair applied during the reboot if necessary to
bring the system back up successfully [23]. Mechanisms such
as fast reboots [39], checkpointing [30, 31], and partial sys-
tem restarts [17] can improve the performance of the reboot
process. Hardware redundancy is the standard solution for
increased availability.
Boundless memory blocks diﬀer in that they are designed
to convert erroneous executions into correct executions. The
advantages include better availability because of the elimi-
nation of down time and the elimination of vulnerabilities
to persistent errors — restarting Pine as described in Sec-
tion 4.3, for example, does not enable the user to read mail
if the mail ﬁle still contains a problematic mail message.
5.4 Manual Error Detection and Recovery
Motivated in part by the need to avoid rebooting, re-
searchers have developed more ﬁne-grain error recovery mech-
anisms. The Lucent 5ESS switch and the IBM MVS operat-
ing system, for example, both contain software components
that detect and attempt to repair inconsistent data struc-
tures [26, 33, 24]. Other techniques include failure recovery
blocks and exception handlers, both of which may contain
hand-coded recovery algorithms [32].
The successful application of these techniques requires the
programmer to anticipate some aspects of the error and,
based on this understanding, develop an appropriate recov-
ery strategy. Boundless memory blocks, on the other hand,
can be applied without programmer intervention to any sys-
tem to completely eliminate memory block size calculation
errors.
Data structure repair [20] occupies a middle ground. Like
more traditional error detection and recovery techniques,
it requires the programmer to provide some application-
5.5 Static Analysis and Program Annotations
It is also possible to attack the memory error problem
directly at its source: a combination of static analysis and
program annotations should, in principle, enable program-
mers to deliver programs that are completely free of memory
errors [22, 21, 42, 37]. All of these techniques share the same
advantage (a static guarantee that the program will not ex-
hibit a speciﬁc kind of memory error) and drawbacks (the
need for programmer annotations or the possibility of con-
servatively rejecting safe programs). Even if the analysis is
not able to verify that the entire program is free of memory
errors, it may be able to statically recognize some accesses
that will never cause a memory error, remove the dynamic
checks for those accesses, and thereby reduce the dynamic
checking overhead.
Researchers have also developed unsound, incomplete anal-
yses that heuristically identify potential errors [41, 16]. The
advantage is that such approaches typically require no an-
notations and scale better to larger programs; the disadvan-
tage is that (because they are unsound) they may miss some
genuine memory errors.
5.6 Buffer Overﬂow Detection Tools
Researchers have developed techniques that are designed
to detect buﬀer overﬂow attacks after they have occurred,
then halt the execution of the program before the attack can
take eﬀect. StackGuard [19] and StackShield [14] modify the
compiler to generate code to detect attacks that overwrite
the return address on the stack; StackShield also performs
range checks to detect overwritten function pointers.
It is also possible to apply buﬀer overﬂow detection di-
rectly to binaries. Purify instruments the binary to detect
a range of memory errors, including out of bounds memory
accesses [25]. Program shepherding uses an eﬃcient binary
interpreter to prevent an attacker from executing injected
code [29].
A key diﬀerence between these techniques and boundless
memory blocks is that boundless memory blocks prevent
the attack from performing out of bounds writes that cor-
rupt the address space. These writes instead are redirected
into the hash table that holds the out of bounds writes. Of
course, our implementation of boundless memory blocks also
generates a log ﬁle that identiﬁes all out of bounds accesses,
enabling the programmer to go back and update the code
to eliminate such accesses if desired.
5.7 Extensible Arrays
Many languages provide extensible array data structures,
which dynamically grow to accommodate elements stored
at arbitrary oﬀsets. Boundless memory blocks are, in eﬀect,
an implementation of extensible arrays. They diﬀer from
standard extensible arrays in their tight integration with
the C programming language (especially the preservation
of the address space from the original legacy implementa-
tion). This integration forces the compiler to make large
scale changes to the generated code to perform the required
Proceedings of the 20th Annual Computer Security Applications Conference (ACSAC’04) 
1063-9527/04 $ 20.00 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 11:38:47 UTC from IEEE Xplore.  Restrictions apply. 
checks and integrate eﬀectively with the low-level packages
that maintain information about out of bounds pointers and
accesses.
6. CONCLUSION
Memory errors are an important source of program fail-
ures and security vulnerabilities. This paper shows how to
automatically convert legacy C programs to use (concep-
tually) boundless memory blocks. This conversion elimi-
nates memory errors associated with out of bounds reads
and writes and, as our results indicate, make the program
invulnerable to buﬀer overﬂow attacks that exploit these er-
rors. The measured overhead of applying our technique is
acceptable for the widely used open source server programs
that we tested.
Acknowledgements
This research was supported in part by the Singapore-MIT
Alliance and NSF grant CCR00-86154, NSF grant CCR00-
63513, NSF grant CCR00-73513, NSF grant CCR-0209075,
NSF grant CCR-0341620, and NSF grant CCR-0325283.
7. REFERENCES
[1] Apache HTTP Server exploit.
http://securityfocus.com/bid/8911/discussion/.
[2] ELM. http://www.instinct.org/elm/.
[3] Midnight Commander exploit.
http://www.securityfocus.com/bid/8658/discussion/.
[4] Midnight Commander website. http://www.ibiblio.org/mc/.
[5] Mutt exploit.
http://www.securiteam.com/unixfocus/5FP0T0U9FU.html.
[6] Mutt website. http://www.mutt.org.
[7] Netcraft website.
http://news.netcraft.com/archives/web server survey.html.
[8] Pine exploit.
http://www.securityfocus.com/bid/6120/discussion.
[9] Pine website. http://www.washington.edu/pine/.
[10] SecuriTeam website. http://www.securiteam.com.
[11] Security Focus website. http://www.securityfocus.com.
[12] Sendmail exploit.
http://www.securityfocus.com/bid/7230/discussion/.
[13] Sendmail website. www.sendmail.org.
[14] Stackshield. http://www.angelfire.com/sk/stackshield.
[15] T. Austin, S. Breach, and G. Sohi. Eﬃcient detection of all
pointer and array access errors. In Proceedings of the ACM
SIGPLAN ’94 Conference on Programming Language Design
and Implementation, June 2004.
[16] W. Bush, J. Pincus, and D. Sielaﬀ. A static analyzer for ﬁnding
dynamic, programming errors. Software - Practice and
Experience, 2000.
[17] G. Candea and A. Fox. Recursive restartability: Turning the
reboot sledgehammer into a scalpel. In Proceedings of the 8th
Workshop on Hot Topics in Operating Systems
(HotOS-VIII), pages 110–115, Schloss Elmau, Germany, May
2001.
[18] S. Card, T. Moran, and A. Newell. The Psychology of
Human-Computer Interaction. Lawrence Erlbaum Associates,
1983.
[19] C. Cowan, C. Pu, D. Maier, J. Walpole, P. Bakke, S. Beattie,
A. Grier, P. Wagle, Q. Zhang, and H. Hinton. StackGuard:
Automatic Adaptive Detection and Prevention of
Buﬀer-Overﬂow Attacks. In Proceedings of the 7th USENIX
Security Conference, January 1998.
[20] B. Demsky and M. Rinard. Automatic Detection and Repair of
Errors in Data Structures. In Proceedings of the 18th Annual
ACM SIGPLAN Conference on Object-Oriented
Programming, Systems, Languages, and Applications,
October 2003.
[21] D. Dhurjati, S. Kowshik, V. Adve, and C. Lattner. Memory
safety without runtime checks or garbage collection. In
Proceedings of the 2003 Workshop on Languages, Compilers,
and Tools for Embedded Systems (LCTES’03), June 2003.
[22] N. Dor, M. Rodeh, and M. Sagiv. CSSV: Towards a realistic
tool for statically detecting all buﬀer overﬂows in C. In
Proceedings of the ACM SIGPLAN 2003 Conference on
Programming Language Design and Implementation, 2003.
[23] J. Gray and A. Reuter. Transaction Processing: Concepts and
Techniques. Morgan Kaufmann, 1993.
[24] N. Gupta, L. Jagadeesan, E. Koutsoﬁos, and D. Weiss.
Auditdraw: Generating audits the FAST way. In Proceedings of
the 3rd IEEE International Symposium on Requirements
Engineering, 1997.
[25] R. Hastings and B. Joyce. Purify: Fast detection of memory
leaks and access errors. In Proceedings of the Winter USENIX
Conference, 1992.
[26] G. Haugk, F. Lax, R. Royer, and J. Williams. The 5ESS(TM)
switching system: Maintenance capabilities. AT&T Technical
Journal, 64(6 part 2):1385–1416, July-August 1985.
[27] T. Jim, G. Morrisett, D. Grossman, M. Hicks, J. Cheney, and
Y. Wang. Cyclone: A safe dialect of C. In USENIX Annual
Technical Conference, June 2002.
[28] R. Jones and P. Kelly. Backwards-compatible bounds checking
for arrays and pointers in C programs. In Proceedings of Third
International Workshop On Automatic Debugging, May 1997.
[29] V. Kiriansky, D. Bruening, and S. Amarasinghe. Secure
Execution Via Program Shepherding. In Proceedings of 11th
USENIX Security Symposium, August 2002.
[30] M. Litzkow, M. Livny, and M. Mutka. Condor - A Hunter of
Idle Workstations. In Proceedings of the 8th International
Conference of Distributed Computing Systems, 1988.
[31] M. Litzkow and M. Solomon. The Evolution of Condor
Checkpointing.
[32] M. R. Lyu. Software Fault Tolerance. John Wiley & Sons,
1995.
[33] S. Mourad and D. Andrews. On the reliability of the IBM
MVS/XA operating system. IEEE Transactions on Software
Engineering, September 1987.
[34] G. C. Necula, S. McPeak, and W. Weimer. CCured: type-safe
retroﬁtting of legacy code. In Symposium on Principles of
Programming Languages, 2002.
[35] V. S. Pai, P. Druschel, and W. Zwanenepoel. Flash: An
eﬃcient and portable Web server. In USENIX Annual
Technical Conference, General Track, 1999.
[36] M. Rinard, C. Cadar, D. Roy, D. Dumitran, T. Leu, and W. S.
Beebee. Enhancing server availability and security through
failure-oblivious computing. In 6th Symposium on Operating
Systems Design and Implementation, Dec. 2004.
[37] R. Rugina and M. Rinard. Symbolic bounds analysis of
pointers, array indices, and accessed memory regions. In
Proceedings of the ACM SIGPLAN ’00 Conference on
Programming Language Design and Implementation , June
2000.
[38] O. Ruwase and M. S. Lam. A Practical Dynamic Buﬀer
Overﬂow Detector. In Proceedings of the 11th Annual Network
and Distributed System Security Symposium, February 2004.
[39] M. I. Seltzer and C. Small. Self-monitoring and self-adapting
operating systems. In Proceedings of the Sixth workshop on
Hot Topics in Operating Systems, 1997.
[40] S. Sidiroglou, G. Giovanidis, and A. Keromytis. Using
execution transactions to recover from buﬀer overﬂow attacks.
Technical Report CUCS-031-04, Columbia University
Computer Science Department, September 2004.
[41] D. Wagner, J. S. Foster, E. A. Brewer, and A. Aiken. A First
Step towards Automated Detection of Buﬀer Overrun
Vulnerabilities. In Proceedings of the Year 2000 Network and
Distributed System Security Symposium, 2000.
[42] H. Xi and F. Pfenning. Eliminating Array Bound Checking
Through Dependent Types. In Proceedings of ACM SIGPLAN
Conference on Programming Language Design and
Implementation, June 1998.
[43] S. H. Yong and S. Horwitz. Protecting C Programs from
Attacks via Invalid Pointer Dereferences. In Proceedings of the
9th European software engineering conference held jointly
with 10th ACM SIGSOFT international symposium on
Foundations of software engineering, 2003.
Proceedings of the 20th Annual Computer Security Applications Conference (ACSAC’04) 
1063-9527/04 $ 20.00 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 11:38:47 UTC from IEEE Xplore.  Restrictions apply.