addrbook WHERE id = 2; 'ADDR B1'
Copyright © 2010 - 2018 EnterpriseDB Corporation. All rights reserved. 284
EDB Postgres Replication Server User’s Guide
Timestamp Action Master Node A Master Node B
The row with id = 2 is
Synchronization pushes Node A already deleted on target
t3
changes to Node B Node B, hence update from
Node A fails.
6.6.3 Conflict Detection
This section discusses the synchronization process and conflict detection.
When synchronization replication occurs, either on demand or on a scheduled basis, each
of the master node changes is pushed to the other master nodes. See Section 2.2.11 for
information on this process.
Using a 3-node example the following describes the conflict detection process.
 The replication server loads the first set of pending transactions from master node
A. Transactions are processed on a transaction set basis. (The same process is
used for single-master replication.) All pending transactions are grouped in one or
more transaction sets to avoid loading a very large chunk of rows in memory that
may result in an out of heap space issue.
 For an update transaction, the replication server queries the first target master
node B to load the related row. If the old column value on the source master node
A is different than the current column value on target master node B, the
transaction is marked as an update/update conflict. If a related row is not found on
the target master node, it is marked as an update/delete conflict.
 For a delete transaction, the replication server queries the target master node to
load the related row. If a related row is not found on the target master node, the
transaction is marked as a delete/delete conflict.
 When a conflict is detected, the conflict information such as the transaction ID,
conflict type, and conflict detection timestamp are logged in the conflict table on
the target master node.
 For a conflicting transaction, the replication server checks if any conflict
resolution strategy has been selected for the specific table. If a strategy is found, it
is applied accordingly and the conflict status is marked as resolved. If a strategy
cannot be applied, the conflict status is marked as unresolved (also called
pending).
 If no conflict is detected, the transactional change is replicated to the target master
node and the transaction status for that target node is marked as completed in the
source master node control schema. A transaction status mapping for each target
master node is maintained on all master nodes. For example node A contains two
mappings of status – one for node B and another for node C.
 All of these prior steps are repeated to process and replicate all pending
transaction sets available on master node A to master node B.
Copyright © 2010 - 2018 EnterpriseDB Corporation. All rights reserved. 285
EDB Postgres Replication Server User’s Guide
 Next, the publication server proceeds to replicate master node A pending
transactional changes to the next target master node, C.
 Once the master node A changes are replicated to nodes B and C, the publication
server replicates the pending changes available on master node B to nodes A and
C.
 Finally, the master node C changes are replicated to nodes A and B.
6.6.4 Conflict Resolution Strategies
A number of built-in conflict resolution options are available to support automatic
conflict resolution. The conflict resolution options are applicable to update/update and
delete/delete conflicts.
Uniqueness (insert/insert), update/delete, and delete/update conflicts are marked
unresolved and must be manually reconciled.
The following are the built-in, automatic conflict resolution options.
 Earliest Timestamp. When the earliest timestamp option is selected, the relevant
rows involved in an update conflict from the source and target master nodes are
compared based on the timestamp of when the update occurred on that particular
node. The row change that occurred earliest is applied. The row changes with the
later timestamps are discarded.
 Latest Timestamp. Same approach as earliest timestamp except the row change
with the latest timestamp is accepted. The row changes with earlier timestamps
are discarded.
 Node Priority. The row change of the master node with the highest node priority
level is applied while the lower priority level master node changes are discarded.
The node priority level is an integer in the range of 1 to 10, inclusive where 1 is
the highest priority level and 10 is the lowest priority level.
 Custom. Custom conflict handling applies to update/update conflicts only. You
must supply a PL/pgSQL program to resolve any conflicts that occur resulting
from an update/update conflict. See Section 6.6.8 for information on using custom
conflict handling.
The delete/delete conflict is always resolved implicitly regardless of the conflict
resolution option in effect. The net impact of a delete/delete conflict is the removal of a
given row, and the row in question has already been removed the from the source and
target nodes.
For the earliest timestamp and latest timestamp conflict resolution strategies, the
transaction timestamp is tracked in a column with data type TIMESTAMP in the shadow
table.
Once selected, the conflict resolution strategy for a given table can later be changed to a
different strategy (see Section 6.8).
Copyright © 2010 - 2018 EnterpriseDB Corporation. All rights reserved. 286
EDB Postgres Replication Server User’s Guide
6.6.5 Conflict Prevention – Uniqueness Case
Since there is no automatic built-in resolution strategy for the uniqueness conflict, this
section discusses strategies to avoid this problem that would be implemented by the
DBA. This discussion is based on a realm of numeric values generated by a sequence
such as for a unique primary key.
The following are possible strategies:
 Node specific sequence range. A sequence range is reserved for each master
node. For example, master node A would have MINVALUE = 1 and MAXVALUE =
1000, master node B would have MINVALUE = 1001 and MAXVALUE = 2000,
and so on for other nodes. This ensures that a unique ID is always generated
across all master nodes.
 Start value variation. Each node is assigned a different start value. For example,
master node A would have a START value of 1, node B would have 2, and node C
would have 3. An increment greater than or equal to the number of nodes
guarantees unique IDs as shown in Table 6-4.
 Common sequence. All nodes share a common sequence object, however this
has the major disadvantage of slowing down transaction processing due to
network round-trips associated with each ID generation.
 MMR-ready sequence. This is a technique that enhances the use of sequences
and provides a more flexible, reliable approach for a distributed, multiple
database architecture as is inherent in a multi-master replication system. This
approach is recommended over the previously listed sequence techniques. See
Section 6.6.6 for information on an MMR-ready sequence.
Table 6-4 - Sequence With Start Value Variation
Sequence Clause Master Node A Master Node B Master Node C
START WITH 1 2 3
INCREMENT BY 5 5 5
Generated IDs 1, 6, 11, 16, … 2, 7, 12, 17, … 3, 8, 13, 18, …
6.6.6 Conflict Prevention with an MMR-Ready Sequence
To prevent uniqueness conflicts in a multi-master replication system, an MMR-ready
sequence can be used to generate unique identifiers for each row of publication tables that
do not have an inherent, unique identifier.
Copyright © 2010 - 2018 EnterpriseDB Corporation. All rights reserved. 287
EDB Postgres Replication Server User’s Guide
An MMR-ready sequence incorporates a function and a sequence to return BIGINT data
type, integer values. These values combine a user-assigned, unique database identifier for
each master node with a sequence generated within that master node.
A publication table requiring an MMR-ready sequence can be altered to include a
BIGINT NOT NULL column with a default value returned by the function.
An MMR-ready sequence satisfies the following characteristics:
 Uniqueness. The combination of the unique, database identifier with the sequence
ensures that each row in a given table will have a unique value across all master
nodes.
 Clustered index support. An MMR-ready sequence does not impair the usage of
a clustered index to provide retrieval efficiency. MMR-ready sequence values are
returned in a typical, ordered sequence – not as random values such as if the
universally unique identifier (UUID) were used.
 Effective migration support. Tables already utilizing a sequence can be
modified to use an MMR-ready sequence with minimal impact on existing
primary keys and foreign keys.
 Reliability and maintainability. In summary, an MMR-ready sequence provides
a reliable and maintainable method to avoid uniqueness conflicts.
The following sections provide the steps for creating an MMR-ready sequence followed
by an example. The conversion process for existing sequences is described in Section
6.6.6.3.
6.6.6.1 Creating an MMR-Ready Sequence
The following are the steps to create an MMR-ready sequence in a database to participate
as a master node in a multi-master replication system.
Begin these steps with the database to be used as the master definition node.
Step 1: Assign a unique, database identifier as an integer from 1 to 1024, inclusive. Thus,
a maximum of 1024 databases can be uniquely identified in a multi-master replication
system with an MMR-ready sequence.
Issue the following commands to create and set the database identifier:
ALTER DATABASE dbname SET cluster.unique_db_id TO db_id;
SET cluster.unique_db_id TO db_id;
Use a different db_id value for each database.
Step 2: Create a sequence to uniquely identify each table row within the database.
Copyright © 2010 - 2018 EnterpriseDB Corporation. All rights reserved. 288
EDB Postgres Replication Server User’s Guide
CREATE SEQUENCE seq_name START WITH 1 INCREMENT BY 1 NO
CYCLE;
Multiple sequences can be created if it is desired to use separate sequences for multiple
tables within the publication. Be sure that the same sequence name is used across all
databases for the same given table.
A publication table column that uses an MMR-ready sequence will include a DEFAULT
clause referencing the sequence name in a function call. The publication table definition
must be consistent across all master nodes by referencing the same sequence name in the
function call.
Step 3: Create the following function that returns the next MMR-ready sequence value
when a row is inserted into the table. This function is referenced by the DEFAULT clause
of the publication table column.
CREATE OR REPLACE FUNCTION mmr_sequence_nextval (
seq_id VARCHAR
)
RETURNS bigint
LANGUAGE sql
AS
$function$
SELECT (
(SELECT current_setting('cluster.unique_db_id'))::bigint
<< 52)::bigint +
nextval($1::regclass);
$function$;
The sequence name created in Step 2 is specified as the seq_id input argument when the
function is added to the DEFAULT clause of the publication table column.
This function performs a bitwise shift left operation (<< 52) on the database identifier
(cluster.unique_db_id), thus significantly increasing its numeric value. The next
sequence value is then added to this number. Thus, all rows inserted in the table on a
given database fall within a numeric range determined by the shifted, database identifier
value.
Step 4 (Optional): Create the following function to obtain the current MMR-ready
sequence value.
CREATE OR REPLACE FUNCTION mmr_sequence_currval (
seq_id VARCHAR
)
RETURNS bigint
LANGUAGE sql
AS
$function$
Copyright © 2010 - 2018 EnterpriseDB Corporation. All rights reserved. 289
EDB Postgres Replication Server User’s Guide
SELECT (
(SELECT current_setting('cluster.unique_db_id'))::bigint
<< 52)::bigint +
currval($1::regclass);
$function$;
The mmr_sequence_nextval function must be invoked in the current session before
calling the mmr_sequence_currval function.
Step 5: Add or modify the publication table column that is to use the MMR-ready
sequence. The column data type must be BIGINT. The mmr_sequence_nextval
function is specified in the DEFAULT clause as shown in the following example for
column id.
CREATE TABLE table_name (
id BIGINT NOT NULL PRIMARY KEY
DEFAULT mmr_sequence_nextval('seq_name'),
field VARCHAR2(20)
);
The column will also typically be the primary key.
Step 6: Repeat steps 1 through 4 for the other databases to be added as master nodes.
Note that Step 5 is omitted for the additional master nodes as the publication table
definitions are replicated from the master definition node to the additional master nodes
when they are created as described in Section 6.3.
Step 7: Create the complete, multi-master replication system as described in Chapter 6.
6.6.6.2 MMR-Ready Sequence Example
The following is an example of a 3-master node system using an MMR-ready sequence.
The databases to be used as the master nodes are mmrnode_a, mmrnode_b, and
mmrnode_c. A publication table named mmr_seq_tbl uses the MMR-ready sequence.
The following commands are invoked in database mmrnode_a, which will be the master
definition node:
ALTER DATABASE mmrnode_a SET cluster.unique_db_id TO 1;
SET cluster.unique_db_id TO 1;
CREATE SEQUENCE mmr_seq START WITH 1 INCREMENT BY 1 NO CYCLE;
CREATE OR REPLACE FUNCTION mmr_sequence_nextval (
seq_id VARCHAR
)
RETURNS bigint
LANGUAGE sql
AS
Copyright © 2010 - 2018 EnterpriseDB Corporation. All rights reserved. 290
EDB Postgres Replication Server User’s Guide
$function$
SELECT (
(SELECT current_setting('cluster.unique_db_id'))::bigint
<< 52)::bigint +
nextval($1::regclass);
$function$;
CREATE OR REPLACE FUNCTION mmr_sequence_currval (
seq_id VARCHAR
)
RETURNS bigint
LANGUAGE sql
AS
$function$
SELECT (
(SELECT current_setting('cluster.unique_db_id'))::bigint
<< 52)::bigint +
currval($1::regclass);
$function$;
CREATE TABLE mmr_seq_tbl (
id BIGINT NOT NULL PRIMARY KEY
DEFAULT mmr_sequence_nextval('mmr_seq'),
field VARCHAR2(20)
);
On mmrnode_b and mmrnode_c, the commands to create different settings for the
configuration parameter cluster.unique_db_id are run as well as the commands to
create the sequence and the functions.
On mmrnode_b the following commands are invoked. Note that
cluster.unique_db_id is set to 2.
ALTER DATABASE mmrnode_b SET cluster.unique_db_id TO 2;
SET cluster.unique_db_id TO 2;
CREATE SEQUENCE mmr_seq START WITH 1 INCREMENT BY 1 NO CYCLE;
CREATE OR REPLACE FUNCTION mmr_sequence_nextval (
seq_id VARCHAR
)
RETURNS bigint
LANGUAGE sql
AS
$function$
SELECT (
(SELECT current_setting('cluster.unique_db_id'))::bigint
<< 52)::bigint +
nextval($1::regclass);
$function$;
CREATE OR REPLACE FUNCTION mmr_sequence_currval (
seq_id VARCHAR
)
RETURNS bigint
LANGUAGE sql
AS
$function$
SELECT (
(SELECT current_setting('cluster.unique_db_id'))::bigint
Copyright © 2010 - 2018 EnterpriseDB Corporation. All rights reserved. 291
EDB Postgres Replication Server User’s Guide
<< 52)::bigint +
currval($1::regclass);
$function$;
On mmrnode_c the following commands are invoked. Note that
cluster.unique_db_id is set to 3.
ALTER DATABASE mmrnode_c SET cluster.unique_db_id TO 3;
SET cluster.unique_db_id TO 3;
CREATE SEQUENCE mmr_seq START WITH 1 INCREMENT BY 1 NO CYCLE;
CREATE OR REPLACE FUNCTION mmr_sequence_nextval (
seq_id VARCHAR
)
RETURNS bigint
LANGUAGE sql
AS
$function$
SELECT (
(SELECT current_setting('cluster.unique_db_id'))::bigint
<< 52)::bigint +
nextval($1::regclass);
$function$;
CREATE OR REPLACE FUNCTION mmr_sequence_currval (
seq_id VARCHAR
)
RETURNS bigint
LANGUAGE sql
AS
$function$
SELECT (
(SELECT current_setting('cluster.unique_db_id'))::bigint
<< 52)::bigint +