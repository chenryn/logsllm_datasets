non-obvious starting location of the exploit code. The meth-
ods proposed by Toth and Kruegel [22] and Akritidis et al. [9]
focused on NO-OP sleds which may be missing in advanced
exploit code [12, 18]. The method used by Chinchani et
al. [10] to extract the control ﬂow of the exploits is not re-
sistant to data injection attack. Wang et al. [23] proposed a
code abstraction method to distill useful instructions from
an instruction sequence to detect exploits. However the code
abstraction is based on a data-ﬂow anomaly rule that an in-
struction referencing an undeﬁned variable is redeemed use-
less. This is easily evaded by some obfuscation techniques.
For instance, two instructions referencing the same unde-
ﬁned variable can still be useful, if they can be used to clear
the registers for initialization.
If an attacker exploits this
property, most of their useful instructions would probably
not be detected by a chaining eﬀect. In addition, none of
these approaches oﬀer a mechanism to clearly identify the
starting location of the polymorphic exploit code in network
traﬃc.
Polychronakis et al. [19] proposed a method that uses in-
struction emulation to more eﬀectively identify self-modifying
polymorphic exploit code than is possible with static anal-
ysis. Their approach does not, however, provide a compre-
hensive mechanism to identify the starting location of poly-
morphic exploit code in network traﬃc. The method will
be very slow if all potential starting locations are tried, but
simple heuristics for narrowing down the possible starts of
exploit code may miss some attacks.
In this paper we present a new method to detect self-
decrypting exploit code. The proposed method harnesses
static analysis and emulated instruction execution to ﬁnd
the starting location and identify the instructions of the
polymorphic exploit code. Previous approaches [19, 10, 23,
22, 9] do not oﬀer such capabilities. In addition, the pro-
posed method can detect polymorphic exploit code that is
self-modifying, which static analysis has previously been un-
able to detect.
The proposed method works by scanning the network traf-
ﬁc for the presence of a decryption routine, which is char-
acteristic of such exploits. First, it identiﬁes the possible
starting locations of a decryption routine by looking for a
form of GetPC code. This is a generally inevitable com-
ponent of the decryption routine, which is used to ﬁnd the
absolute address of the encrypted exploit code. Second, it
ﬁnds the actual decryption instructions by a novel two-way
traversal of the code, as well as by using standard back-
ward data ﬂow analysis. Third, it identiﬁes self-modifying
decryption routines through emulated execution of already
found decryption instructions. Last, it veriﬁes the detected
code is a decryption routine by checking whether it satisﬁes
two properties that are typical of such code.
The proposed method has been implemented and evalu-
ated against real polymorphic exploits produced by Metas-
ploit [4], and also those produced by polymorphic engines [5,
6].
It achieves a 100% detection rate on the polymorphic
exploits which use statically coded decryption routines. It
likewise has a 100% detection rate for decryption routines
that are self-modifying . The method was also tested on
typical network traﬃc not containing polymorphic exploits,
and on Windows executable ﬁles. The false positive rate
is approximately .0002% and .01% for these two categories,
respectively. We also measure the running time of our non-
optimized implementation. The running time is roughly lin-
ear in the size of the traﬃc being analyzed, and is between
1 and 2 MB/s.
The rest of this paper is organized as follows. Section
2 describes related work. Section 3 presents our method.
Section 4 demonstrates our evaluation. Section 5 gives the
attack analysis. Section 6 concludes the paper.
2. RELATED WORK
The two major approaches to detection of polymorphic
exploit code are static-analysis [10, 9, 22, 23] and emulation
[19]. These have been brieﬂy described above. Two other
approaches for detection of polymorphic exploits in network
traﬃc are signature-based methods, and data mining meth-
ods. These are now brieﬂy described.
Polygraph [16] and Hamsa [14] are examples of the signature-
based approach. These methods generate polymorphic worm
signatures by ﬁnding common invariant content substrings
among multiple polymorphic worm samples. This approach
requires a network traﬃc classiﬁer to preselect suspicious
traﬃc for training. The detection and false positive rates
depend on the eﬀectiveness of the classiﬁer.
If the back-
ground “noise” (network traﬃc not containing exploits, but
selected by the classiﬁer) is signiﬁcant, the accuracy can
be signiﬁcantly reduced. Newsome et al. [17] presented an
attack that causes the signature learning approach to fail.
Nemean [25] is a method that uses protocol semantics to
group similar worm traﬃc, and that uses machine-learning
techniques to generate connection and session level signa-
tures. This approach requires detailed protocol speciﬁcation
for every application protocol. It is also sensitive to back-
ground noise.
In general, this category of methods has a
high maintenance cost, in the sense that signature reposi-
tories need to be constantly updated, as new polymorphic
variants are encountered.
The second category uses data-mining [18]. This approach
combines neural networks with a simple NO-OP sled detec-
tor (as used in [22]) to detect exploit code. The neural
(cid:1)(cid:2)(cid:3)(cid:2)(cid:4)(cid:5)(cid:6)(cid:7)(cid:8)(cid:9)(cid:10)(cid:8)(cid:11)(cid:12)(cid:13)(cid:14)(cid:15)(cid:16)(cid:17)(cid:18)(cid:5)(cid:12)(cid:17)(cid:19)(cid:15)(cid:16)(cid:18)(cid:8)(cid:20)(cid:18)(cid:11)(cid:12)(cid:13)(cid:14)(cid:15)(cid:8)(cid:9)(cid:5)(cid:14)(cid:21)(cid:13)(cid:7)(cid:17)(cid:21)(cid:9)network has to be carefully trained with negative and pos-
itive data sets, which highly aﬀects its detection rates. In
practice, high quality training sets may be diﬃcult to obtain
and keep updated.
There is considerable work on malware detection or pre-
vention at the host level. These methods provide insight
into the form of malware, and the run time environment. A
recent method named PolyUnpack [20] automatically iden-
tiﬁes and extracts the hidden-code bodies of unpacking-
executing malware, with knowledge of the instance’s static
code model. Christodorescu et al [11] proposed to detect
malware through the use of semantic behavior models, called
templates. One of the presented templates models is the
decryption loop of polymorphic malware. However, this
method does not provide a way to model self-modifying de-
cryption loops. How to deﬁne a general semantic behav-
ior model remains an open problem. Sidiroglou et al.
[21]
proposed an end-point architecture to automatically repair