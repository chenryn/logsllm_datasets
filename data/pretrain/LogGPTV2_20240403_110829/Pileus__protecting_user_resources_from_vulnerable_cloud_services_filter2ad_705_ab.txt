VMs. Such isolation would be end-to-end, restricting cloud service
interactions as well (e.g., Alice’s services cannot forge messages
for Bob’s services or modify Bob’s cloud resources). Figure 2(b)
shows that when Alice wants to release a used volume to public, the
volume must ﬁrst be sanitized by a declassiﬁer whose trust is con-
ferred by running with Alice’s ownership. Similarly, Figure 2(c)
shows when Alice wants to use a public image provided by Bob,
the image must ﬁrst be veriﬁed by an endorser whose trust is con-
ferred by running with Alice’s ownership.
4. PILEUS DESIGN
4.1 Pileus Overview
Based on the problems highlighted in Section 2.2, we identify
the following security goals for the Pileus design.
• Minimize Permissions: Restrict event handler permissions
to only those necessary for executing the handler for the spe-
ciﬁc operation, typically the permissions of the user request-
ing the operation.
• Minimize Security Decisions: Restrict security decisions to
only those cloud services that are trusted by the users to man-
age their data security.
• Eliminate Dependence on Untrusted Nodes: A users’ data
security should never depend on cloud nodes that the user
does not trust. Further, when performing an operation, a user
should delegate his trust to the node that has the least likeli-
hood of compromise.
To achieve these goals, we leverage the following insights. First,
we can spawn cloud services on demand as event handlers that run
with only the permissions necessary for that command. The event
handler abstraction was proposed for the Asbestos system [15],
Alice-API
S = {a}
Alice-Compute
S = {a}
Alice-VM
S = {a}
Alice-Volume
S = {a}
Alice-Declassi(cid:29)er
S = {a}, O= {a}
Alice-Compute
I = {a}
Alice-VM
I = {a}
Bob-API
S = {b}
Bob-Compute
S = {b}
Bob-VM
S = {b}
Volumes Store
S = { }
Bob’s Image
I = {b}
(a) Alice’s cloud services and data 
are isolated from Bob’s
(b) Cloud services cannot release Alice’s 
data to public unless properly declassi(cid:23)ed
(c) Cloud services cannot read public 
data unless properly endorsed
Figure 2: Decentralized information ﬂow control examples in Pileus.
Alice-Endorser
I = {a}, O= {a}
op
Alice
Plieus
Initiator
spawn
Ownership
Registry
OR mediates spawn
spawn
spawn
API
Event Handler
DIFC
Plieus
Daemon
Kernel
cloud node
Compute
Event Handler
Plieus
DIFC
Kernel
Daemon
cloud node
Image
Event Handler
Plieus
DIFC
Kernel
Daemon
cloud node
Figure 3: Overview: a user operation performed on Pileus.
where stateless services are launched with minimal permissions.
The Pileus design leverages this insight because we ﬁnd that cloud
services are already architectured as stateless services, although
we need a platform to spawn such event handlers dynamically in
a manner that complies with the user’s security policy. Second,
researchers have proposed the decentralized security principle [4],
which states that the security of a principal must not depend on any
part of the system that it does not trust. The Pileus design targets
this goal by choosing nodes most capable of enforcing the user’s
security policy to run event handlers, and prevent nodes not trusted
by a user from tampering with the user’s data security. We leverage
prior work in secure capability systems to prevent depending on
nodes that would violate security constraints [16] (i.e., could be an
adversary). Third, the decentralized information ﬂow control [24]
(DIFC) enables access control that expresses a subject’s (e.g., event
handler) authority over security decisions explicitly as ownerships
(see Section 3). The Pileus design leverages this insight to restrict
the security decisions to only event handlers that are trusted by the
user to manage their data security.
Pileus utilizes these insights to implement user operations as fol-
lows, shown in Figure 3. First, when a user submits an operation to
the cloud, the Pileus initiator validates the user’s identity and com-
putes the access control requirements for executing the operation,
as described in Section 4.3. Second, each user operation is exe-
cuted as a set of event handlers launched on-demand, correspond-
ing to the cloud services needed to complete the operation on the
old cloud platform. Starting with the Pileus initiator, requests to se-
lect nodes on which to spawn new event handlers are submitted to
the Pileus ownership registry, which selects a node that satisﬁes the
cloud security policy and minimizes the risk of attack from other
users, as described in Section 4.4. Third, each node is empowered
with the ability to enforce DIFC policies securely to govern the ex-
ecution of all event handlers. When a node receives a request to
spawn an event handler, it validates that it has been approved to run
the speciﬁc event handler by obtaining an authority token granting
such as capability from the OR. When a node completes the execu-
tion of its event handler, it no longer needs the authority to access
user data, as described in Section 4.5.
The remainder of this section details the key design tasks for
building a Pileus system. The foundation of Pileus security is the
spawn protocol, described in Section 4.2, which determines how to
distribute the authority to enforce DIFC policies over every event
handler while preventing unauthorized access to user data. The
other design tasks involve best effort methods to restrict the event
handlers that may make security decisions (Section 4.3), to select
nodes that satisfy a cloud security policy while minimizing risk
(Section 4.4), and to enable individual cloud nodes to revoke au-
thority from their delegatees (Section 4.5).
Security Model. In Pileus, we assume the trustworthiness of two
global services: a Pileus initiator that authenticates users and com-
putes access control requirements for their operations, and a Pileus
ownership registry that manages the authority distribution. Since
these services are relatively static and simple, we expect them to be
fully trusted by any user in cloud. We trust the cloud vendor at the
organizational level.
The local enforcement mechanism on each cloud node consists
of a Pileus daemon and a DIFC kernel. A user trusts those services
on any cloud nodes that run her cloud services. However, we do not
assume the mutual trust between enforcement mechanisms on dif-
ferent cloud nodes; that is, we assume individual cloud nodes may
be under the complete control of an adversary. Thus, the TCB of
a cloud user will include the globally trusted services and the local
enforcement mechanisms to which the user has delegated her au-
thority. The attacks we aim to block are exempliﬁed in Section 2.1.
We assume an adversary may launch confused deputy attacks or
gain complete control over cloud services by exploiting vulnerabil-
ities in them. He may further escalate his privilege on a cloud node
(e.g., by exploiting a kernel vulnerabilities). Pileus’s approach for
mitigating adversarial cloud services and nodes is to enforce the
decentralized security principle [4]: a user’s data security does not
depend on any components of the cloud platform that are not part
of her TCB.
4.2 Pileus Spawn Protocol
The execution of a user operation in a Pileus cloud is imple-
mented by spawning a sequence of event handlers for each program
necessary to complete the operation. Thus, the security of operation
execution is governed by the protocol to spawn event handlers to
execute user operations, the spawn protocol shown in Figure 4(a).
In the spawn protocol, a cloud node wishing to spawn an event han-
dler on another cloud node, the parent node, presents evidence of
its authority over a user operation (called an authority token below)
and the program to be spawned to the Pileus ownership registry
(OR). The OR completes the spawn protocol by choosing a target
node to execute the speciﬁed event handler and producing evidence
that the target node can also act on behalf of the user operation (i.e.,
access user data on that node and make further spawn requests on
behalf of the user).
The aim of the spawn protocol is to prevent: (1) nodes that lack
a user’s authority from spawning event handlers that may access
that user’s data and (2) nodes that fail to satisfy a cloud security
policy (regarding the user’s trust in the node to enforce her access
control) from being selected (by the OR) as target nodes or given
55
Event 
Handler p
1
Pileus 
Daemon Dp
Event 
Handler q
7
Pileus 
Daemon Dq
4
Event 
Handler p
5
Pileus 
Daemon Dp
2
Event 
Handler q
1
Pileus 
Daemon Dq
2
3
5
Ownership
Registry
6
4
3
Ownership
Registry
(a) Spawning an event handler
(b) Ownership revocation 
Figure 4: Protocols of ownership delegation and revocation.
the authority to execute the user’s handler2.
In Pileus, authority over a user’s operation is distributed to cloud
nodes as authority tokens, t = {own, n, auth, sig}, where: (1)
own are the DIFC ownerships describing the authority of the to-
ken, usually the user’s DIFC label; (2) n is the node for which
the token applies; (3) auth describes the conditions under which
an event handler may obtain ownerships for this operation, which
we call ownership authorizations (see Section 4.3), to control how
ownerships may be used in execution of the operation; and (4) sig
is an OR signature over the ﬁrst three elements that certiﬁes the
token. In effect, when an OR grants an authority token to a target
node, this implies that the user trusts the node to protect her data
security requirements (i.e., enforce her DIFC policy) for the execu-
tion of this operation. Each cloud node runs a Pileus daemon which
obtains, propagates, and revokes (see Section 4.5) authority tokens
for each node.
In Pileus, the OR produces authority tokens for a target node only
when the distribution of a user’s trust to that node complies with a
cloud security policy. Such cloud security policies could prevent
mutually distrustful users from running handlers on the same node
(i.e., conﬂict-of-interest policies), could prevent handlers from be-
ing deployed on nodes that ran privileged handlers on behalf of
other users (i.e., information ﬂow policies), and could prevent the
use of nodes that have run too many handlers or handlers on be-
half of too many users (i.e., cardinality policies). Traditionally,
capability systems (like DIFC) allow the holders of authority to
choose how they propagate authority, but this may present prob-
lems in the cloud because a compromised or ignorant cloud node
may violate the cloud security policy that protects the user’s oper-
ation. This problem is analogous to the classic capability system
problem caused because the authority to exercise a capability also
permits the authority to delegate capabilities, leading to violations
of the ⋆-property [49]. Thus, we leverage the solutions proposed
to solve the classical capability system problem [19, 38, 16], in
particular identity-based capabilities in the ICAP system [16] that
associate authority with individual nodes and validate the propaga-
tion of such authority.
Figure 4(a) shows how an event handler dynamically spawns an-
other event handler. When a handler p needs to spawn another
event handler, its request (i.e., event) will be proxied by its Pileus
daemon Dp (Step 1). Dp will send the spawn request to the OR
(Step 2). In its spawn request, Dp must specify the authority token
t that it would like to delegate. This reﬂects the fact that spawn-
ing event handlers on a new node requires a user’s trust in that new
node. After receiving the spawn request, the OR checks in its own-
ership graph, a data structure that tracks the states of cloud nodes,
to see if Dp actually holds the user’s ownership. If so, the OR will
select a target node by running the spawn scheduling algorithm as
discussed in Section 4.4 and update its ownership graph to mark the
2The OR may also prevent a node from being selected as a target node for
functional reasons.
56
ownership delegation. It will also produce a new authority token for
the target node that incorporates its identity. The OR then returns
a reference to the new authority token as well as the target node
identity to Dp (Step 3). Assume the Pileus daemon running on the
target is called Dq. Dp will then send p’s event, q’s security label
(inherited from p) and the authority token reference to Dq (Step 4).
Dq will query the OR to retrieve the authority token created for it
(Step 5 and 6). It then validates if the authority token is sufﬁcient to
create q’s label. If so, Dq launches q with speciﬁed label and may
or may not delegate ownerships to q depending on whether or not q
meets the ownership authorizations speciﬁed in the authority token
(Step 7), as discussed in Section 4.3. As q is run, the Pileus kernel
and other Pileus enforcement mechanisms on q’s node ensure that
all q’s data accesses comply with the DIFC policy.
It is easy to prove that this spawn protocol satisﬁes the expected
security properties. First, it prevents a parent node that lacks a
user’s authority (per the OR) from spawning event handlers that
may access that user’s data. If a parent node provides an author-
ity token that does not correspond to the authority tokens stored
by the OR, then the delegation request will be rejected. Further,
since nodes can only access user data on their node or by spawn-
ing an event handler on another node, the parent node will not be
able to trick the target node into access user data on its behalf. This
ensures the decentralized security principle. Second, no node that
fails to satisfy a cloud security policy will obtain an authority token
for that user’s operation. The OR checks the cloud security policy
when selecting a target node and the OR validates the cloud secu-
rity policy when producing an authority token. This ensures that
cloud security policy will always be met. In addition, the OR uses
a best effort protocol to select targets to lower the risk of choosing
a compromised node, as described in Section 4.4.
As an optimization, the parent node needs not request the identity
of a target node from the OR each time. A parent node may cache a
set of approved nodes or reuse nodes from previous spawn requests
for that operation. In this case, the parent node may submit an event
and its authority token (in lieu of a reference to a new token) in a
spawn request to a target node optimistically to reduce messaging.
The target node will still only be allowed with the user’s authority
should an OR provide a authority token for that user to the target
node. In this case, the spawn request from the parent node must be
signed to enable the OR to verify the source and include a nonce
for replay protection.
4.3 Restricting Security Decisions
In Pileus, security decisions, such as declassiﬁcation and en-
dorsement of cloud objects, are localized to certain event handlers
that a cloud user trusts to manage their data security. For exam-
ple, Figure 2(b) shows that a volume declassiﬁer is trusted by Al-
ice (e.g., Alice-Declassiﬁer) to remove secrets before releasing the
volume to public, and to declassify the volume this declassiﬁer
runs with Alice’s ownership. Since event handlers are dynamically
spawned, one way for a trusted event handler to obtain ownership
is by inheriting the ownership from its parent (e.g., Alice-Volume).
However, this defeats the purpose of DIFC, as we want to localize
the authority to make security decisions to only the event handlers
the user trusts. Other event handler are conﬁned so that they cannot
violate the user’s data security either inadvertently or intentionally.
As a result, we need a mechanism in Pileus that authorizes the in-
vocation of event handlers with user ownerships.
This problem is analogous to the setuid problem of UNIX sys-