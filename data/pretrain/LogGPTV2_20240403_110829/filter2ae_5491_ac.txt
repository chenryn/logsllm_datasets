首先解压,查看这个本身的 class.dex 一无所获。
然后发现 assets 中有个 abc,META-INF 中有个 y,同时 CERT.RSA 严重过大。
观察可知 abc 是个 dex 头,那就是要找出对应的 body 了,然后 CERT.RSA 中随便看看会发现有
KEY=Misc@inf0#fjhx11^@DEX=,于是把后面内容拉出来。
内容最后有个 aes-128-cbc,于是尝试解密,用 python 解密未遂(尝试前 16 位和后 16 位是 IV 都不行),
队友用 openssl 解密能出看起来正常的内容,但最后一行报错,于是照抄队友 openssl 命令成功(后发现队友 vim 编辑自动加了个换行 -_-#
的锅):
    openssl aes-128-cbc -d -nosalt -in DEX -out DEX.dec -k Misc@inf0#fjhx11
把解出来的内容拼到 abc 后面,发现还是 010 模版跑还是没有内容。
然后发现头中各种 count 全是 0,于是计算一下修复下,然而修复后校验还是不对,dex2jar 失败,baksmali 成功,发现是
MainActivity 中 onCreate 不对。
然后想起之前没用到的 y,感觉是用来替换修复 onCreate 的,然而,第一次用 010 + 刚玩 android,找了半天没找到 onCreate
对应代码,还以为是代码和其余部分一样是一句话一句话打散的,以为走错路……
最后被队友告知 IDA 可以看 dex,于是轻松找到 onCreate 区域发现全是 0,果断替换之,校验正确,解开得 flag。
**Caesar deformation (MISC 100)  
**
从图片的 Exif 信息中拿到一个奇怪的字符串,其中有许多重复字符,  
把不重复的部分提取出来看作 01 串,然后不知道该怎么办,后来的提示里说不一定是 8 位,某队友试了下 7 位一个字符发现在某 2 种情况下得到的字符都是
printable 的。
同样根据题目提示,我们试着将其在 string.printable 上移位一下,得到一个奇怪的字符串 XCZFnCaesar tr3nsformation
s0 easy fun1x0b,然后我们发现第 1 与 3 个字符在 string.printable 上左移 6 位就是 R 和 T,n 与 x0b 左移
6 位则是 { 和 },空格左移则为 _,所以把它们移动一下得到RCTF{Caesar_tr3nsformation_s0_easy_fun1}
交上去竟然就过了。
最后附上操作的 python 代码如下
枚举部分:
    s='DJECQDJEARTJECRTBAARDJECRTBACQDJACRTBECRTJEARTBACQTBAARTBECRDJECQTJAARDJECQTBEAQTBACQTJECQDBECRDJACQTBACQDJACRDBACRTBECQTBACQDBEARTBEARTJACQDJACQTJEARTBACQTJECQDBEAQTJEARDJEARDJACRDBEAQTBACQTJEARTJAARTJECQDJAARDJAAQTJEARTBACQTJEARTJACRDJECQDJAARDJAARDBACRTJACQTBECQDJACQDBACQDJEAR'
    from pwn import *
    def xor(s1,s2,z):
        rt = ''
        for i in range(len(s1)):
            if s1[i]==s2[i]:
                rt+=str(z[i])
            else:
                rt+=str(1-z[i])
        return rt
    cmp = 'DJECQ'
    a={}
    cnt=0;
    def dfs(s,dep):
        if dep == 5:
            ans = ''
            for i in range(len(s)/5):
                ans+=xor(cmp,s[i*5:(i+1)*5],a)
            flag=''
            for i in range(len(ans)/7):
                flag += pack(int(ans[i*7:(i+1)*7],2),8,endianness='big')
            print flag
            #print pack(int(ans,2),35*8,endianness='big')
            #print len(pack(int(ans,2),35*8,endianness='big'))
            #print hex(int(ans,2))[2:].decode('hex')
            global cnt
            cnt+=1
            print cnt
            return
        a[dep]=1
        dfs(s,dep+1)
        a[dep]=0
        dfs(s,dep+1)
    print len(s)
    dfs(s,0)
python shell部分:
    >>> import string
    >>> s='395f627c4b5f59233b593a493c3a522c3b242d3a2b593c272d2c493b4f4923593b5b49243d2c504d'.decode('hex')
    >>> s
    "9_b|K_Y#;Y:I>> t=string.printable
    >>> t
    '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!"#$%&'()*+,-./:;?@[\]^_`{|}~ tnrx0bx0c'
    >>> a=[]
    >>> for ch in s:
    ...     a.append(t.find(ch))
    ...
    >>> a
    [9, 88, 11, 91, 46, 88, 60, 64, 78, 60, 77, 44, 79, 77, 53, 73, 78, 65, 74, 77, 72, 60, 79, 68, 74, 73, 44, 78, 50, 44, 64, 60, 78, 84, 44, 65, 80, 73, 51, 48]
    >>> len(t)
    100
    >>> t[1:]+t[:1]
    '123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!"#$%&'()*+,-./:;?@[\]^_`{|}~ tnrx0bx0c0'
    >>> for i in range(99):
    ...     t=t[1:]+t[:1]
    ...     print t.encode('hex')
    ...     print '--------------------------------'
    ...     q=''
    ...     for aa in a:
    ...             q+=t[aa]
    ...     print q
    ...
    >>> t='4f505152535455565758595a2122232425262728292a2b2c2d2e2f3a3b3c3d3e3f405b5c5d5e5f607b7c7d7e20090a0d0b0c303132333435363738396162636465666768696a6b6c6d6e6f707172737475767778797a4142434445464748494a4b4c4d4e'.decode('hex')
    >>> t
    'OPQRSTUVWXYZ!"#$%&'()*+,-./:;?@[\]^_`{|}~ tnrx0bx0c0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMN'
    >>> q=''
    >>> for aa in a:
    ...     q+=t[aa]
    ...
    >>> q
    'XCZFnCaesar tr3nsformation s0 easy fun1x0b'
****
**I can't hear that (MISC 150)**
提供了一个 wav 文件, strings 到最后可以看到一个字符串形式的数组, 显然为有用信息.
将其提取出后发现为 0-8349 的一个排列, 查看 wav 文件元信息得到其 frame 数为 835000, 因此考虑根据数字指示将 wav
的帧重排列.
第 K 帧应放到其数组中对应值 (A[k]) 处, 重排列后播放 wav 得到 flag.
**login (WEB 300)  
**
[Github](https://github.com/garzon/CTF-Writeups/tree/master/RCTF2015#login-web-300)
**Old Driver (REVERSE 400)  
**
初步观察可知,题目应当是要 OldDriverAPP.exe 和 OldDriverWin7.sys 通信的过程寻找 Flag。
OldDriverAPP.exe
这程序被加了一层Themida壳,真无聊,还是先看驱动吧。
OldDriverWin7.sys
分析可知,驱动加载时主要干了这么几件事:
1、通过修改 SSDT 的方法 Hook NtDeviceIoControlFile(并且做的时候关了中断忘记开了)。
2、没了。
在 Hook NtDeviceIoControlFile 的处理函数中,驱动首先判断当前进程文件名是否是 OldDriverAPP.exe,如果是的话:
1、第一次调用时,强行将 IoControlCode 的最低位字节修改为 0x2F.
2、接下来的 512 次调用,根据驱动数据段的一个数组的值来强行修改 IoControlCode。这个数组是由 IoControlCode 为
0x22E02F 时触发的函数初始化的,内容为
    "sasawawasawawawawawasasasasasasasawasawasawawasawawasawawasasawasawasawasasasawasasawasasawasasasawasawawasasasasasa"
    "sawawasawawawawawawawawawasawasawawawasasawasasawawawawawawasawawasawasasawawawasasasasasawawawasawasawasasawawawasa"
    "sasasawawawasawasasasawasawawawasawawawasasasasasasasasasasasawasawawawawawasawawasawasawasawasawasasasawawasawawawa"
    "wasawasawawasawasasawawawawasasawasawasasasawasasawasawasasawasasawawasawawawasasawasasasasasasawasawawawawawawawasa"
    "sawasasawawawawawasawasawasasawawasawawawasawawaf"
对于对应位置上是 w, s, a, d, f 的情况,分别将 IoControlCode 修改为0x22E037, 0x22E03B, 0x22E03F,
0x22E043, 0x22E047。
分析对应 IoControlCode 的 handler 可以大概了解到验证部分的逻辑。
OldDriverAPP.exe
脱这个壳太麻烦了,可以选择用 OllyDbg 带 StrongOD 插件在 Windows XP/7 上带壳调试。  
StrongOD 开启大部分隐藏选项之后即可躲过 Themida 的检测。
在 OllyDbg 中运行起来程序之后查看 401000 处的内存,可以找到关键逻辑:
1、接受输入的一个用户名和密码。
2、对于用户名里的前 512 个字符(不够长的话多出来的部分就是0),发送一个请求给驱动,如果是 w/s/a/d/f,发送对应的control
code,否则发送一个奇怪的值。如果是a的话,额外读入两个整数一并传递给驱动。但是这个并不重要,因为……驱动里用hook的方式强行修改了这512个control