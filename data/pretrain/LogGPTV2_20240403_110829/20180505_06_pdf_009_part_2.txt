SELECT * FROM st
ID 1 2 3 4 5
NAME John Paul Anna Peter Steve
MANAGER_ID 1 1 2 4
RESULT: (‘John’, ‘Paul’, ‘Anna’)
Recursive CTE EXAMPLE: STEP 4
WITH RECURSIVE st (id, name, manager_id) AS (SELECT id, name, manager_id FROM staff
where name = ‘John’
UNION ALL
SELECT id, name, manager_id FROM staff cur, st prev WHERE cur.manager_id = prev.id)
SELECT * FROM st
ID 1 2 3 4 5
NAME John Paul Anna Peter Steve
MANAGER_ID 1 1 2 4
RESULT: (‘John’, ‘Paul’, ‘Anna’, ‘Peter’)
Recursive CTE EXAMPLE: STEP 5
WITH RECURSIVE st (id, name, manager_id) AS (SELECT id, name, manager_id FROM staff
where name = ‘John’
UNION ALL
SELECT id, name, manager_id FROM staff cur, st prev WHERE cur.manager_id = prev.id)
SELECT * FROM st
ID 1 2 3 4 5
NAME John Paul Anna Peter Steve
MANAGER_ID 1 1 2 4
RESULT: (‘John’, ‘Paul’, ‘Anna’, ‘Peter’, ‘Steve’)
Recursive CTE example: FINISH
WITH RECURSIVE st (id, name, manager_id) AS (SELECT id, name, manager_id FROM staff
where name = ‘John’
UNION ALL
SELECT id, name, manager_id FROM staff cur, st prev WHERE cur.manager_id = prev.id)
SELECT * FROM st
ID 1 2 3 4 5
NAME John Paul Anna Peter Steve
MANAGER_ID 1 1 2 4
RESULT: (‘John’, ‘Paul’, ‘Anna’, ‘Peter, ‘Steve’)
CONNECT BY vs CTEs
Oracle PostgreSQL
WITH RECURSIVE st (id, name,
manager_id) AS (SELECT id, name,
manager_id FROM staff where name =
‘John’
SELECT name FROM staff
UNION ALL
START WITH name = ‘John’
CONNECT BY manager_id = PRIOR id
SELECT id, name, manager_id FROM staff
cur, st prev WHERE cur.manager_id =
prev.id)
SELECT * FROM st
CONNECT BY vs CTEs
Search order difference
Oracle (depth-first) PostgreSQL (breadth-first)
1 John 1 John
2 Paul 5 Anna 2 Paul 3 Anna
3 Peter 4 Peter
Steve Steve
5
4
(John, Paul, Peter, Steve, Anna) (John, Paul, Anna, Peter, Steve)
LEVEL and PATH in Oracle
SELECT ID, NAME, LEVEL, SYS_CONNECT_BY_PATH(name, ‘/’) “PATH” FROM staff
START WITH NAME=‘John’ CONNECT BY PRIOR ID = MANAGER_ID
ID NAME LEVEL PATH
1 John 1 /John
2 Paul 2 /John/Paul
4 Peter 3 /John/Paul/Peter
/John/Paul/Peter/
5 Steve 4
Steve
3 Anna 2 /John/Anna
LEVEL and PATH in PostgreSQL
WITH RECURSIVE org AS (SELECT id, name, 1 as level, ARRAY[name] AS path FROM staff
UNION ALL SELECT next.id, next.name, prev.level + 1 as level, prev.path || next.name as
path FROM org prev, staff next WHERE org.id = staff.manager_id)
SELECT id, name, level, ‘/’||array_to_string(path, ‘/’) as path from org
ID NAME LEVEL PATH
1 John 1 /John
2 Paul 2 /John/Paul
3 Anna 2 /John/Anna
4 Peter 3 /John/Paul/Peter
/John/Paul/Peter/
5 Steve 4
Steve
Matching Oracle’s search order
WITH RECURSIVE org AS (SELECT id, name, 1 as level, ARRAY[name] AS path FROM staff
UNION ALL SELECT next.id, next.name, prev.level + 1 as level, prev.path || next.name as
path FROM org prev, staff next WHERE org.id = staff.manager_id)
SELECT id, name, level, ‘/’||array_to_string(path, ‘/’) as path from org ORDER BY path
ID NAME LEVEL PATH
1 John 1 /John
2 Paul 2 /John/Paul
4 Peter 3 /John/Paul/Peter
/John/Paul/Peter/
5 Steve 4
Steve
3 Anna 2 /John/Anna
Detecting cycles with Oracle
SELECT ID, NAME, LEVEL, SYS_CONNECT_BY_PATH(name, ‘/’) “PATH” FROM staff
START WITH NAME=‘John’ CONNECT BY NOCYCLE PRIOR ID = MANAGER_ID
1 John
2 Paul 5 Anna
3 Peter
Steve
4
Detecting cycles with PostgreSQL
WITH RECURSIVE org AS (SELECT id, name, 1 as level, ARRAY[name] AS path, cycle as
FALSE FROM staff UNION ALL SELECT next.id, next.name, prev.level + 1 as level, prev.path
|| next.name as path, next.name = ANY(prev.path) as cycle FROM org prev, staff next
WHERE org.id = staff.manager_id) WHERE cycle = FALSE
SELECT id, name, level, ‘/’||array_to_string(path, ‘/’) as path FROM org WHERE cycle=FALSE
1 John
2 Paul 5 Anna
3 Peter
Steve
4
More Oracle CONNECT BY
features (not covered)
•
CONNECT_BY_ISCYCLE
•
CONNECT_BY_ISLEAF
•
CONNECT_BY_ROOT
•
ORDER SIBLINGS
Translating Oracle functions
•
Orafce: orafce.projects.pgfoundry.org
•
PL/SQL to PL/pgSQL:
http://www.postgresql.org/docs/current/
static/plpgsql-porting.html
Translating instr
•
Orafce
•
PostgreSQL documentation
•
Corner case:
Oracle PostgreSQL
SELECT instr(‘foo’, ‘f’, 0) FROM dual SELECT instr(‘foo’, ‘f’, 0) FROM dual
RESULT: 0 RESULT: 2
sysdate vs now()
•
sysdate - server's timezone
•
now() - session's timezone
•
implement sysdate as now() at hard-coded
timezone in PostgreSQL
Making sure it works
•
Hundreds of files, 1 - 10 queries each
•
Lack of frameworks for cross-database
query testing
•
Python to the rescue
Python database drivers
•
psycopg2
•
cx_Oracle 4.4.1 (with a custom patch)
•
32-bit version to talk to Oracle 8i
Test application workflow
•
Establish the database connections
•
Read queries from test files
•
Run queries against both databases
•
Compare results
•
Cleanup and exit
Connecting to databases
import cx_Oracle
import psycopg2
...
conn_string_pg="dbname=pgdb host=pghost user=slon password=secret"
conn_string_ora=slon/secret@oracledb"
...
def establish_db_connections(self, conn_string_ora, conn_string_pg):
try:
self._connora = cx_Oracle.connect(conn_string_ora)
self._connpg = psycopg2.connect(conn_string_pg)
except Exception, e:
if isinstance(e, cx_Oracle.Error):
raise Exception("Oracle: %s" % (e,))
elif isinstance(e, psycopg2.Error):
raise Exception("Postgres: %s" % (e,))
else:
raise
Reading queries
•
Query files parsing
•
Variables replacements
•
Python is flexible (handles queries
embedded in XML easily)
Running queries
def get_query_result(self, conn, query, limit=0):
result = []
rows = 0
try:
cur = conn.cursor()
cur.execute(str(query))
for row in cur:
result.append(row)
rows += 1
if rows - limit == 0:
break
except Exception, e:
if isinstance(e, cx_Oracle.Error):
raise Exception(("Oracle: %s" % (e,)).rstrip('\n\r'))
elif isinstance(e, psycopg2.Error):
raise Exception(("Postgres: %s" % (e,)).rstrip('\n\r'))
else:
raise
finally:
conn.rollback()
return result
Running queries faster
•
One thread per database connection
•
Asynchronous I/O
Getting result rows from
PostgreSQL
•
SELECTs are easy
•
INSERTs/UPDATEs/DELETEs +
RETURNING:
INSERT INTO pgconf(year, city) values(2012, 'Prague') RETURNING *;
Getting result rows from
Oracle
•
SELECTs are easy
•
INSERTs/UPDATEs/DELETEs - dynamically
wrap into anonymous PL/SQL blocks
•
INSERT...SELECT is a special case
Anonymous PL/SQL blocks for DML
queries example
cur = con.cursor()
result=[]
result.append(cur.arrayvar(ora.NUMBER, 1000))
result.append(cur.arrayvar(ora.STRING, 1000))
cur.execute("""
begin
insert into pgconf(year,city) values(2012, 'Prague') returning year, city bulk
collect into :1, :2;
end;""", result)
rows = zip(*(x.getvalue() for x in result))
cur.close()
Getting table information from
Oracle
SELECT
TABLE_NAME, COLUMN_NAME,
DATA_TYPE, DATA_PRECISION,
DATA_SCALE,
CHAR_COL_DECL_LENGTH
FROM ALL_TAB_COLUMNS
WHERE TABLE_NAME='pgconf'
ORDER BY COLUMN_ID ASC
Unsupported features by
PL/SQL in 8i
•
Scalar subselects
•
LONG RAW columns
•
CASE...WHEN blocks
Questions?
Twitter: @alexeyklyukin
Email: PI:EMAIL
References
•
http://ora2pg.darold.net/index.html - Ora2pg home page
•
http://keithf4.com/oracle_fdw - using Oracle FDW to migrate from 8i
•
http://www.postgresql.org/docs/8.3/interactive/plpgsql-porting.html -
PostgreSQL documentation chapter on porting PL/SQL code
•
http://orafce.projects.postgresql.org/ - Orafce home page
•
http://cx-oracle.sourceforge.net/html/index.html - cx_Oracle documentation
•
http://www.initd.org/psycopg/docs/ - psycopg2 documentation
•
http://code.google.com/p/python-sqlparse/ - Python SQL parser library
•
http://docs.python.org/library/markup.html - python libraries to work with
structured data markup
Thank you!
Feedback: 2012.pgconf.eu/feedback/