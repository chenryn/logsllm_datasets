### 优化后的文本

#### 表2：基于FFT的分类器混淆矩阵（Safari私密浏览）
尽管Tor网络引入了更长的网络往返时间，以及不可避免的背景活动在每次测量的50秒内发生，这些因素并没有降低分类器的性能。该分类器在区分Facebook和Wikipedia的记忆图时表现最差。我们认为这是由于这两个网站加载了一个带有闪烁光标的最小化网页，从而生成了如图6所示的独特2 Hz脉冲。通过使用更高级的分类启发式方法（例如，记录URL输入时的按键时间、表征并过滤掉含有切换噪声的频率），可以提高检测器的准确性。

我们的评估仅限于一个封闭世界的互联网模型，其中只考虑了一小部分网站，并且模板创建是基于受害者的机器上的追踪数据进行的。对于特定攻击者来说，这种模型是可以接受的，因为攻击者可以通过JavaScript指令让受害者的机器加载已知页面并记录记忆图来进行特征分析。然而，将评估扩展到开放世界模型仍然是有意义的，即考虑成千上万个网站，并且模板在与受害者当前浏览会话不同的时间和地点创建[11]。

#### 表3：基于FFT的分类器混淆矩阵（Tor浏览器）

| 分类器输出 → | 亚马逊 (1) | 百度 (2) | Facebook (3) | 谷歌 (4) | 推特 (5) | 维基百科 (6) | 雅虎 (7) | YouTube (8) |
| --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 真实标签 ↓ |  |  |  |  |  |  |  |  |
| (1) | 1 | - | - | - | - | - | - | - |
| (2) | .2 | - | - | - | - | - | - | .8 |
| (3) | - | - | .33 | - | - | - | - | .17 |
| (4) | - | - | - | 1 | - | - | - | - |
| (5) | - | - | - | - | .17 | - | - | .83 |
| (6) | - | - | .4 | - | - | - | - | .5 |
| (7) | - | - | - | - | - | - | 1 | - |
| (8) | - | - | - | - | - | - | - | 1 |

#### 表4：受影响的桌面浏览器：最低版本及全球流行率 [26]

| 浏览器 | 最低支持版本 | 全球流行率 |
| --- | --- | --- |
| Internet Explorer | v10 | 11.77% |
| Safari | v8 | 1.86% |
| Chrome | v20 | 50.53% |
| Firefox | v15 | 17.67% |
| Opera | v15 | 1.2% |
| 总计 | - | 83.03% |

### 6. 讨论

#### 6.1 受影响系统的普及率
我们的攻击需要一台由Intel Sandy Bridge、Ivy Bridge、Haswell或Broadwell微架构的CPU驱动的个人电脑。根据IDC的数据，自2011年以来销售的所有PC中有超过80%满足这一要求。我们还假设用户正在使用的浏览器支持HTML5高分辨率时间API和类型化数组规范。表4列出了每个常见浏览器支持这些API的最早版本，以及根据StatCounter测量结果（2015年1月）显示的来自这些浏览器版本的全球互联网流量比例。如表所示，当今使用的桌面浏览器中有超过83%受到我们描述的攻击的影响。

攻击的有效性取决于能够使用JavaScript高分辨率时间API进行精确测量。虽然W3C对该API的建议[16]规定高分辨率时间戳应“准确到毫秒的千分之一”，但并未指定该值的最大分辨率，实际分辨率因浏览器版本和操作系统而异。在测试中，我们发现Mac OS X上的Safari的时间戳分辨率为纳秒级，而Windows上的IE分辨率为0.8µs。另一方面，Chrome在所有测试的操作系统中都提供了统一的1µs分辨率。

由于单次缓存命中和缓存未命中的时间差异约为50ns（见图3），因此在粗粒度时间分辨率的系统上，需要对剖析和测量算法进行略微修改。在剖析阶段，我们不是测量单次缓存未命中，而是多次重复内存访问周期以放大时间差异。我们利用这一观察成功地在时间分辨率有限的Chrome浏览器版本上进行了缓存剖析。在测量阶段，我们不能放大单次缓存未命中，但我们利用代码访问通常会使同一页面帧中的多个连续缓存集失效的事实。只要单个页面帧中的至少20个缓存集注册了缓存未命中，即使在微秒级时间分辨率下，我们的攻击也能成功。

我们提出的攻击也可以应用于移动设备，如智能手机和平板电脑。需要注意的是，Android浏览器从版本4.4开始支持高分辨率时间和类型化数组，但截至撰写本文时，最新的iOS Safari（8.1版）尚不支持高分辨率时间API。

#### 6.2 微架构洞察
尽管我们的攻击是在一种受限的高级语言中实现的，但它揭示了受害者机器的极低级元素。因此，它受到Intel CPU架构师所做的细微设计选择的影响。正如Aciiçmez[1]所述，两个概念会影响缓存的功能行为：映射策略和替换策略。前者确定哪些内存位置映射到缓存中的每个集合，而后者确定在缓存未命中后如何修改缓存集合。

我们在调查的系统中注意到了不同的映射策略行为，特别是在内存地址的切片索引选择方面。在我们测试的处理器中，LLC的集合被划分为切片，每个缓存切片位于硬件中，靠近CPU的一个核心。所有切片通过环形缓冲区互连，使所有核心都能访问所有切片中的缓存条目。因此，缓存集合首先使用切片索引进行索引，然后使用相应切片内的集合索引进行索引。

Hund等人[10]的研究表明，在Sandy Bridge CPU上，切片索引仅是物理地址高位比特的函数，而Liu等人[14]则认为较新的微架构也考虑了低位比特。我们通过在四核Haswell处理器上测量我们能够剖析的每个缓存集合的缓存命中情况来确认这一点。在这种系统中，L3缓存命中可能有三种可能的时间。位于与当前核心关联的切片中的L3缓存条目访问速度最快。位于距离当前核心一个核心距离的两个切片中的缓存条目的访问速度稍慢，因为条目必须穿过环形缓冲区的一跳。最后，位于距离当前核心两个核心距离的切片中的缓存条目访问速度最慢，因为条目必须穿过环形缓冲区的两跳。如果较低位地址比特用于选择缓存切片，我们预计会在同一个物理内存页中的地址之间看到缓存命中时间的变化。图7显示了在Haswell代CPU上确实观察到了这种行为，证实了Liu等人的建议。

最坏情况下的缓存命中（需要穿过环形缓冲区的两跳）和缓存未命中之间的时间差异仍然足以使算法1无需修改即可运行。然而，攻击者可以利用有关LLC切片的这种洞察来操作优势。例如，运行在同一系统上的两个进程可以通过比较相同缓存集合的缓存命中时间来发现它们是否运行在同一个核心上。这可以使攻击者可选地从LLC缓存攻击过渡到L1缓存攻击，后者被认为更为敏感且更容易执行。更重要的是，一旦在新系统上反向工程出物理地址到缓存集合的映射，这种行为将允许低权限进程推断其自身变量的物理地址信息，从而减少多种攻击类型的熵，如ASLR去随机化[10]。

在研究缓存替换策略时，我们注意到所调查的CPU在两种不同的替换策略之间转换。现代Intel CPU通常采用最近最少使用（LRU）替换策略[23]，即将新条目添加到缓存中标记为最近使用的，因此在未来缓存未命中时最后被替换。然而，在某些情况下，这些CPU可能会切换到双模式插入策略（BIP），其中新条目添加到缓存中时大多被标记为最久未使用的，因此在未来缓存未命中时首先被替换。