addSpecialEvent)
addTickets()
客户指示此生成器依照这些步碑，建立一
getVacationPlanner()
个规则，然后调用setVacationPlanner（）方法
以段得究整的对象。
生成器的优点
生成器的用途和缺点
将一个复杂对象的创建过程封装起来。
经常被用来创建组合结构。
允许对象通过多个步骤来创建，并且可以改
变过程（这和只有一个步骤的工厂模式不
■与工厂模式相比，采用生成器模式创建对象
同）。
的客户，需要具备更多的领域知识。
向客户隐藏产品内部的表现。
产品的实现可以被替换，因为客户只看到一
个抽象的接口。
你现在的位置
615
---
## Page 652
责任链模式
责任链
当你想要让一个以上的对象有机会能够处理某个请求的时候，就使用责
任链模式（ChainofResponsibilityPattern）。
场景
自从推出Java版本的糖果机之后，万能糖果公司
收到的电子邮件数量已超出他们所能处理的范
围。据他们自已分析，所收到的电子邮件有四
类：其一，Fans寄来的信，他们喜欢新推出的
1in10游戏；其二，父母寄来的信，抱怨他们
的孩子沉漏于这个游戏：其三，店家寄来的信，
他们希望能够在某些地方也摆设糖果机：其四，
垃圾邮件。
所有Fans的邮件都需要直接送到CEO手上，所
你一定要帮我们
有的抱怨邮件则是送给法律部门，而所有的新
处理这洪水能的电子
机器请求邮件则交给业务部门，至于垃圾邮件
邮件。自从Java糖累机推
当然是删除了事。
出后，我们的邮件数量
大增。
你的任务
D
万能糖果公司已经写了一些人工智能过滤程序，
这些程序很厉害，它们会分辨邮件是属于上述
哪一类，但是他们需要你构造一个设计一使
用这个过滤程序处理收到的邮件。
河
PDG
616
附录A
---
## Page 653
剩下的模式
如何使用责任链模式
通过责任链模式，你可以为某个请求创建一个对象链。每个对象依
序检查此请求，并对其进行处理，或者将它传给链中的下一个对象。
Handler
Josseoons
能中的每个对象扮演处理
handleRequest()
器，并且有一个后能对象。
如果它可以处理请求，就
进行处理：否则把请求转
发给后继老。
SpamHandler
FanHandler
ComplaintHandler
NewLocHandler
handleRequest()
handleRequest()
handleRequest()
handleRequest()
当收到电子邮件的时候，它会被送进第一个处理器，也就
如果电子邮件摔落到随属
是SpamHandler。如果SpamHandler无法处理，就将它传给
端之后，就表示它没有经
FanHandler。依次类推.....
过任何处理—不过你可
以实现一个终极处理器应
付这种状况。
每个电子邮件都
Spam
Fan
mplaln
wLoc
Handler
Handle
会被送进第一个
Hnndler
Handler
处理器。
责任链的优点
责任链的用途和缺点
将请求的发送者和接受者解耦。
经常被使用在窗口系统中，处理鼠标和键盘
可以简化你的对象，因为它不需要知道链的
之类的事件。
结构。
·并不保证请求一定会被执行：如果没有任何
通过改变链内的成员或调动它们的次序，允
象处理它的话，它可能会落到链尾端之外
许你动态地新增或者删除责任。
（这可以是优点也可以是缺点）。
可能不容易观察运行时的特征，有碍于除
错。
你现在的位置
617
---
## Page 654
蝇量模式
蝇量
如想让某个类的一个实例能用来提供许多“虚拟实例”，就使用蝇量模
式（FlyweightPattern）。
场景
在热门的全新景观设计应用中，你想要加上一些树作为点缀；树有一个XY坐标位
置，而且可以根据树的年龄动态地将自己绘制出来。问题是，用户可能要在他们
的家庭景观设计中有非常非常多的树，看起来就像这样：
树
树
树
每个树的实例都维护
自己的状态。
树
房子
Tree
树
xCoord
yCoord
age
display()
7/使用XY坐标
//以及复杂的
你的大客户陷入两难
//树龄计算
你刚刚取得了重大突破。你已经向关键客户努力推销了好
几个月，而他们打算购买1.000套你的软件，并将其用于
大型规划社区的景观设计。在使用一个星期之后，客户开
始抱怨：他们创建了许多树之后，这个程序开始变得呆
PDG
618
附录A
---
## Page 655
剩下的模式
为何使用蝇量模式？
如果不用上页的做法，你可以重新设计系统，只用一个
树实例和一个客户对象来维护“所有”树的状态。这就
是蝇量模式！
所有的状态，代表所奇
的虐拟树对象，健存在
一个单独的没有状
这个二维数组内。
态的树对象。
TreeManager
treeArray
Tree
displayTrees()(
display(x,Y
//取得所有树的
age)(
//使用XY坐标
//数组位置
//以及复杂的
display(x,Y,age);
//树龄计算
蝇量的优点
蝇量的用途和缺点
减少运行时对象实例的个数，节省内存。
当一个类有许多的实例，而这些实例能被同
将许多“虚拟”对象的状态集中管理
一方法控制的时候，我们就可以使用蝇量模
式。
蝇量模式的缺点在于，一旦你实现了它，那
么单个的逻辑实例将无法拥有独立而不同的
行为。
你现在的位置
619
---
## Page 656
解释器模式
解释器
使用解释器模式（InterpreterPattern）为语言创建解
放轻枪
释器。
解释器模式需要一些形式语法的
场景
知识，如果你还没有学过形式语
还记得DuckPond的模拟器吗？你可能会想到这适合拿来当做
法，那么请继续读下去，你还是可
儿童学习编程的教育工具。使用这个模拟器，每个孩子都可以
以抓住一些重点的。
用一种简单的语言来控制一只鸭子。下面是此语言的一个简单
例子：
让略子右转。
right;
整天都在飞.
while (daylight) fy;
quack;
….然后唤叫。
现在，回想很久以前，你在编程入门课程上所学到的语法知识，
把语法写成下面这样：
程序是一个表达式，内含一串命今和
重复（“while”语句）。
所调的“一事”、指
的是一群表达式，彼
expression::=||
此之间用分号隔开，
sequence::=
;'
command ::= right|quack|fly
repetition::=while(')'
我们有三个命今：向右.呱
variable ::= [A-Z,a-z]+
叫.以及飞行
while语句由一个条件变量
和一个表达式组成。
现在怎么办？
你已经有了一个语法；现在所需要做的事情，就是表现并解释
语法中的句子，好让学生看到用这个语言控制鸭子的效果。
620
附录A
---
## Page 657
剩下的模式
如何实现解释器
当你需要实现一个简单的语言时，就使用解释器模式定义
语法的类，并用一个解释器解释句子。每个语法规则都
用一个类代表。这是一个将鸭子语言转化成类的例子，请
特别留意，类直接映射到语法。
Expression
interpret(context)
Repetition
Sequence
variable
expression1
expression
expression2
interpret(context)
interpret(context)
Variable
QuackCommand
RightCommand
FlyCommand
interpret(context)
interpret(context)
interpret(context)
interprot(context)
要想解释这种语言，就调用每个表达式类型的interpret()方法。此方
法需要传入一个上下文（Context）—也就是我们正在解析的语言
字符串输入流一然后进行比对并采取适当的动作。
解释器模式的优点
解释器的用途和缺点
将每一个语法规则表示成一个类，方便于实
$
当你需要实现一个简单的语言时，使用解
现语言。
释器。
·因为语法由许多类表示，所以你可以轻易地
当你有一个简单的语法，而且简单比效率
改变或扩展此语言。
更重要时，使用解释器。
通过在类结构中加人新的方法，可以在解释
可以处理脚本语言和编程语言。
的同时增加新的行为，例如打印格式的美化
当语法规则的数日太大时，这个模式可能
或者进行复杂的程序验证。
会变得非常繁杂。在这种情况下，使用解
析器/编译器的产生器可能更合适。
你现在的位置
621
---
## Page 658
中介者模式
中介者
使用中介者模式（MediatorPattern）来集中相关对象之间复杂
的沟通和控制方式。
场景
感谢未来屋公司的这群好家伙，Bob拥有一个Java版本的自动屋，这可以让他的
生活变得更便利。当Bob点击了打盹按钮，他的闹钟就会告诉咖啡壶开始煮咖啡。
尽管生活对他来说是如此惬意，但他（以及其他的客户）总是不断地提出许多新
的要求：周末不要供应咖啡在洗澡前将喷头关闭15分钟在丢垃圾的日子
里将闹钟时刻提前.
Alarm
CoffeePot
闹钟
onEvent()(
onEvent()(
checkCalendar()
checkCalen-
咖啡壶
checkAlarm ()
dar ()
//做更多事
checkSprin-
kler()
startCoffee()
//做更多事
Calendar
日历
喷头
Sprinkler
onEvent()(
checkDayOfWeek()
onEvent()(
doSprinkler()
checkCalendar()
doCoffee ()
checkShower()
doAlarm()
checkTemp()
//做更多事
checkWeather()
1/
做更多事
未来屋公司的两难
想要持续地追踪每个对象的每个规则，以及众多对象之间彼此错综复杂的关
系，实在不容易。
622
附录A
---
## Page 659
剩下的模式
中介者在行动···
真让人枪了
口气，不用再理会
在这个系统中加人一个中介者，一切都变
闹钟那些挑剔的现则
得简单了。
D
31
■每个对象都会在自己的状态改变时，告
闹钟
咖啡壶
诉中介者。
■每个对象都会对中介者所发出的请求作
出回应。
Mediator
if (alarmEvent) (
在没有中介者的情况下，所有的对象都需
checkCalendar()
中介者
checkShower()
要认识其他对象也就是说，对象之间
checkTemp()
是紧耦合的。有了中介者之后，对象之间
if（weekend)(
彻底解耦。
checkWeather()
//做更多事
中介者内包含了整个系统的控制逻辑。当
if(trashDay)(
resetAlarm()
某装置需要一个新的规则时，或者是一个
喷头