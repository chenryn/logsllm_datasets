A perfect malware analysis solution is unattainable. The cyber
arms race between malware and defenders has transformed
into an intensive tug-of-war. Cybercriminals are motivated
to circumvent API-Xray once it is public. We do not assume
that evading API-Xray is strictly impossible, but it can pro-
hibitively increase malware developers’ cost. This section
discusses possible attacks to API-Xray, our countermeasures,
API-Xray’s limitations, and the application to Linux malware.
6.1 Possible Attacks and Countermeasures
Attacks to BTS. The BTS mechanism can only be manipula-
ted in the kernel. Starting with Windows 10 (version 1607),
Windows OS does not load any new kernel drivers unless they
are signed by Windows Hardware Dev Center program [13].
This mandatory driver signing enforcement leaves malware
with little wiggle room to hack into the OS kernel.
Attacks to NX bit. Unlike BTS mechanism, the NX bit
can be detected and manipulated at the user level. API-Xray’s
kernel module can intercept the detection and manipulation
from user-mode malware samples and deceive them by re-
Countermeasure
Attack Type
Detect NX
VirtualQuery
Disable NX
VirtualProtect ZwProtectVirtualMemory
VirtualAlloc
(cid:88)
ZwAllocateVirtualMemory (cid:88)
ZwQueryVirtualMemory
Result
(cid:88)
turning expected answers. For example, malware can use
API “VirtualQuery” to detect whether API-Xray has enabled
the NX bit for DLLs’ virtual memory pages. However, we
also hook its corresponding native API “ZwQueryVirtualMe-
mory”, in which we modify the return value to hide the NX bit.
Similarly, malware can call the API “VirtualProtect” or “Vir-
tualAlloc” to disable the NX bit [58]. This attack is prevalent
in ROP attacks [12, 59, 61, 66]. However, the VirtualProtect
and VirtualAlloc will call the related Windows native API
eventually: “ZwProtectVirtualMemory” and “ZwAllocateVir-
tualMemory”. To prevent this attack, we have hooked both
“ZwProtectVirtualMemory” and “ZwProtectVirtualMemory”
in our current design. Since disabling NX from the user level
can only be accomplished via “VirtualProtect” and “Virtua-
lAlloc” [80], our kernel-level hooking will protect API-Xray
from this attack. We have evaluated the detection and mani-
pulation attempts to the NX bit in the userspace. As shown in
Table 9, the API-Xray’s kernel module can defeat the attacks
to NX bit successfully.
Statically-Linked Library. If system libraries are stati-
cally linked into malware binary code, API-Xray cannot re-
solve API names because malware will never call APIs from
our monitoring system’s DLLs. However, we argue that static
linking is not an attractive option to spread malware. First,
it causes incompatibility problems under different Windows
versions. Second, static linking also compromises malware’s
portability, because it bloats program size drastically.
Stolen Function. Kawakoya et al. [41] describe an evol-
ved version of stolen code: instead of copying a few bytes
from the head of an API, it copies the whole body of an API.
We call it as “stolen function.” API-Xray will miss this case
because the control ﬂow does not jump to the target API
at all. However, it is not a trivial task to copy all instructi-
ons of an API to another memory space and then execute
them smoothly. The stolen function has to relocate all related
position-dependent code in advance; otherwise, it will lead
to an execution crash. To counter the stolen function, we can
leverage the “Execute-no-Read” idea [5] to protect the DLL
memory pages as “no-Read.” When the target API function
is copied to a new location, it will be monitored by our page
fault handler. And then, we use the target API information
(name & address) to reconstruct import tables.
Argument-Sensitive Trampoline. The basic premise of
our API Micro Execution is that the trampoline code does
not depend on the particular API arguments. A determined
packer author can customize the trampoline code for each
3464    30th USENIX Security Symposium
USENIX Association
Table 10: Running time (seconds) of fake-API-call DoS at-
tacks. They have relatively small impact on API-Xray.
Sample
Yoda’s Protector
Yoda’s Protector + (Fake API Call)×103
Yoda’s Protector + (Fake API Call)×106
Yoda’s Protector + (Fake API Call)×109
0.7
0.8
121.0
121,472
API-Xray (s)
Disable
Enable
17.2
17.3
153.1
123,648
Relative Slowdown
23.6X
20.6X
26.5%
1.8%
API callsite. For example, only when the trampoline code
checks the validity of API arguments (e.g., a speciﬁc string
or HANDLE value), it transfers the control ﬂow to the target
API. In this case, we have to resort to expensive symbolic
execution to explore a feasible path to the target API.
Fake API Calls. An intuitive attack to any API-monitoring
based security measures is the so-called “Fake API Calls” [15].
The packer can invoke many iterations of fake or null API calls
before calling the target API. This will increase API-Xray’s
overhead because we have to check the destination address
for every fake API call. However, API invocations are much
expensive as well. BinUnpack [15] has quantitatively measu-
red the adverse impact of fake API calls and concluded that
too many fake API calls impose dramatically large overhead
to the packed malware itself. Inspired by BinUnpack [15], we
also simulated a fake-API-call Denial-of-Service (DoS) attack
by modifying the open-source Yoda’s Protector packer [23].
As shown in Table 10, the API-Xray’s overall running time
does not increase signiﬁcantly when the fake API call iterati-
ons are less than 106. When the iteration number reaches 109
times, the custom Yoda’s Protector packer’s execution will
be occupied by the large number of API invocations, and the
runtime overhead will increase by ﬁve orders of magnitude;
while API-Xray only incur 1.8% relative slowdown to the
custom Yoda’s Protector packer. Clearly, the accumulative
overhead from a plethora of fake API calls far outstrips the
deterioration of API-Xray’s performance.
6.2 Limitations
API-Xray fails to produce an executable PE ﬁle from the
unpacked code for the following two cases.
Custom DLLs. We ﬁnd that 1.6% of malware samples
call APIs exported from custom DLLs instead of standard
Windows DLLs. Unfortunately, API-Xray cannot restore im-
port tables exported from custom DLLs, which are absent in
our testing environment.
OEP Obfuscation. 9.5% of unpacked PE ﬁles with com-
plete import tables crashed at run time. The reason is OEP
obfuscation schemes cause existing generic unpacking tools
to miss the real OEP locations. For example, many unpacking
tools use the “stack balance” detects OEP by checking whet-
her the stack is similar to that when a program is just loaded
into memory. However, some custom packers do not satisfy
this rule. Dealing with OEP obfuscation is an orthogonal
question to API-Xray, and we leave it as our future work.
6.3 Application to Linux Malware
API-Xray is designed to work on Intel CPUs, and both Win-
dows and Linux OS provide the interface to manipulate BTS
and NX bit. Besides, Linux’s executable ﬁle format also has
a similar import table structure. According to Cozzi et al.’s
study [21], Linux malware is not as complex as Windows
malware. Most packed Linux malware samples are protected
by UPX packer or UPX-like variants, which do not apply any
API obfuscation scheme. If new Linux packed malware be-
comes as complex as its Windows counterpart, API-Xray’s
technique is generalized to Linux malware as well.
7 Conclusion
API-Xray is the ﬁrst hardware-assisted solution towards brid-
ging the gap of generic binary unpacking—automated import
table reconstruction. API-Xray complements the state-of-art
binary unpacking tools by producing a standard PE ﬁle that
can be executed and analyzed independently. Security analysts
utilizing API-Xray will enjoy a simpler and more streamlined
malware analysis than ever before.
Acknowledgments
We sincerely thank Usenix Security 2021 anonymous revie-
wers for their insightful and helpful comments. Jiang Ming
was supported by the National Science Foundation (NSF)
under grant CNS-1850434. We thank the University of Texas
at Arlington and the Department of Education for supporting
us with a Graduate Assistance in Areas of National Need
(GAANN) fellowship. This work was also supported in part
by the National Natural Science Foundation of China grants
(61972297, U1636107, and 61976085). This project has re-
ceived funding from the European Union’s Horizon 2020
research and innovation programme under grant agreement
No 830927.
References
[1] Hojjat Aghakhani, Fabio Gritti, Francesco Mecca, Martina Lin-
dorfer, Stefano Ortolani, Davide Balzarotti, Giovanni Vigna,
and Christopher Kruegel. When Malware is Packin’ Heat; Li-
mits of Machine Learning Classiﬁers Based on Static Analysis
Features. In Proceedings of the 27th Network and Distributed
System Security Symposium (NDSS’20), 2020.
[2] Aguila. Scylla - x64/x86 Imports Reconstruction. https:
//github.com/NtQuery/Scylla, 2016.
[3] Mansour Ahmadi, Dmitry Ulyanov, Stanislav Semenov, Mik-
hail Troﬁmov, and Giorgio Giacinto. Novel Feature Extraction,
Selection and Fusion for Effective Malware Family Classiﬁca-
tion. In Proceedings of the 6th ACM Conference on Data and
Application Security and Privacy (CODASPY’16), 2016.
USENIX Association
30th USENIX Security Symposium    3465
[4] Pieter Arntz. Analyzing Malware by API Calls. http://tiny.
cc/qm6rsz, Malwarebytes Labs Blog, October 2017.
[5] Michael Backes, Thorsten Holz, Benjamin Kollenda, Philipp
Koppe, Stefan Nürnberger, and Jannik Pewny. You Can Run but
You Can’t Read: Preventing Disclosure Exploits in Executable
Code. In Proceedings of the 2014 ACM SIGSAC Conference
on Computer and Communications Security (CCS’14), 2014.
[6] M. Bazús, R.J. Rodríguez, and J. Merseguer. Qualitative and
Quantitative Evaluation of Software Packers. NoConName
2015, 2015.
[7] Leyla Bilge, Andrea Lanzi, and Davide Balzarotti. Thwarting
Real-time Dynamic Unpacking. In Proceedings of the Fourth
European Workshop on System Security (EUROSEC’11), 2011.
[8] Guillaume Bonfante, Jose Fernandez, Jean-Yves Marion, Ben-
jamin Rouxel, Fabrice Sabatier, and Aurélien Thierry. CoDi-
sasm: Medium Scale Concatic Disassembly of Self-Modifying
Binaries with Overlapping Instructions. In Proceedings of the
22nd ACM SIGSAC Conference on Computer and Communi-
cations Security (CCS’15), 2015.
[9] Marcus Botacin, Paulo Lício De Geus, and André Grégio. En-
hancing Branch Monitoring for Security Purposes: From Cont-
rol Flow Integrity to Malware Analysis and Debugging. ACM
Transactions on Privacy and Security (TOPS), 21(1):4, 2018.
[10] Derek Bruening, Qin Zhao, and Saman Amarasinghe. Transpa-
rent Dynamic Instrumentation. In Proceedings of the 8th ACM
SIGPLAN/SIGOPS Conference on Virtual Execution Environ-
ments (VEE’12), 2012.
[11] Joan Calvet, Fanny Lalonde Lévesque, Jose M. Fernandez,
Erwann Traourouder, Francois Menet, and Jean-Yves Marion.
WaveAtlas: Surﬁng Through the Landscape of Current Mal-
ware Packers. Virus Bulletin Conference, 2015.
[12] Nicholas Carlini and David Wagner. ROP is Still Dangerous:
Breaking Modern Defenses. In 23rd USENIX Security Sympo-
sium (USENIX Security’14), pages 385–399, 2014.
[13] Microsoft Hardware Dev Center. Driver Signing Policy. http:
//tiny.cc/dm6rsz, April 2017.
[14] Stephen Checkoway, Lucas Davi, Alexandra Dmitrienko,
Ahmad-Reza Sadeghi, Hovav Shacham, and Marcel Winandy.
Return-Oriented Programming without Returns. In Procee-
dings of the 17th ACM Conference on Computer and Commu-
nications Security (CCS’10), 2010.
[15] Binlin Cheng, Jiang Ming, Jianmin Fu, Guojun Peng, Ting
Chen, Xiaosong Zhang, and Jean-Yves Marion. Towards Pa-
ving the Way for Large-Scale Windows Malware Analysis:
Generic Binary Unpacking with Orders-of-Magnitude Perfor-
mance Boost. In Proceedings of the 25th ACM Conference on
Computer and Communications Security (CCS’18), 2018.
[16] Yueqiang Cheng, Zongwei Zhou, Yu Miao, Xuhua Ding, and
Robert H Deng. ROPecker: A Generic and Practical Appro-
ach for Defending Against ROP Attacks. In In Proceedings
of the 21st Annual Network and Distributed System Security
Symposium (NDSS’14), 2014.
[17] Seokwoo Choi. API Deobfuscator: Identifying Runtime-
obfuscated API Calls via Memory Access Analysis. Black
Hat Asia, 2015.
[18] Context Information Security. CAPE: Malware Conﬁguration
And Payload Extraction. https://cape.contextis.com/,
2016.
[19] Kevin Coogan, Gen Lu, and Saumya Debray. Deobfuscation
of Virtualization-Obfuscated Software: A Semantics-Based
Approach. In Proceedings of the 18th ACM Conference on
Computer and Communications Security (CCS’11), 2011.
[20] Intel Corparation. Intel ((R)) 64 and IA-32 Architectures Soft-
ware Developer’s Manual. Combined Volumes, Dec, 2016.
[21] Emanuele Cozzi, Mariano Graziano, Yanick Fratantonio, and
Davide Balzarotti. Understanding Linux Malware. In Procee-
dings of the 39th IEEE Symposium on Security and Privacy
(S&P’18), 2018.
[22] crowdstrike.
Hybrid Analysis.
https://www.
hybrid-analysis.com/, [online].
[23] Ashkbiz Danehkar. Yoda’s Protector. https://sourceforge.
net/projects/yodap/, 2013.
[24] Lucas Davi, Ahmad-Reza Sadeghi, Daniel Lehmann, and Fa-
bian Monrose. Stitching the Gadgets: On the Ineffectiveness
of Coarse-Grained Control-Flow Integrity Protection. In 23rd