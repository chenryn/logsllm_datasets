• Oyente is neither sound nor complete, and reports a high
false alarm rate for three of its four bug classes. Further, it
times out or gives no result for 711 contracts (or 46.7%) in
our dataset. These numbers are consistent with their published
dataset, where almost half the tests gave no result [33].
DISCUSSION. ZEUS determines a contract as either safe or
unsafe, i.e., if a contract is vulnerable in principle or not. An
unsafe result does not guarantee a trivial exploit. For example,
several contracts are vulnerable to integer overﬂow because
they do not check for the bounds. Thus, ZEUS marks them
as unsafe. Even though possible in principle, these contracts
may not be susceptible to an immediate exploit, say when
the payouts use uint256 for calculation. Similarly, contracts
using timestamp for control ﬂow, may not be affected
immediately, but a path may exist with a certain value of the
timestamp that affects the Ether ﬂow in a send invocation.
FAIRNESS. We select representative contracts from the four
classes (per § VI-A) and apply contract speciﬁc properties
along with a common fairness policy across all contracts.
(1) DAO: CrowdFundDao [9] implements a DAO scheme
allowing investors to choose when to pay and withdraw their
funds. We implemented two policies: (a) blacklisted developers
cannot participate in the scheme, and (b) the investment must
be more than a threshold limit. ZEUS determined that none of
these checks were encoded in the contract.
(2) Game: DiceRoll [10] is a dice game where players join
a game by placing a bet. We implemented a policy that the
number of dice rolls for a player must be limited. We observed
instruments. While most of
that the game did not cap the number of dice rolls per user.
(3) Token: Tokens, such as StandardToken [42], are used
to implement ﬁnancial
them
consider integer underﬂow possibilities on the sender side, it
is important for them to consider whether token transfer could
result in overﬂows on the receiver. We implemented this policy
on several contracts and observed that some of them, such as
Campaign [5], do not consider overﬂows at the recipient.
(4) Wallet: Wallet [49] implements several functionalities for
users, including a daily withdrawal limit. We check for two
policies: (a) a user cannot send money to themselves, and (b)
there is a limit on the amount being transferred per transaction.
We observed that both these policies report a violation.
(5) Common policy: Solidity provides selfdestruct to kill
a contract and return its balance to an address. We check if
the construct is invoked only by the owner. We observed that
284 out of 1524 contracts had this construct, with around 5.6%
reporting a violation of the policy with no false alarms.
C. Performance
(I) INSTRUCTION OVERHEAD. ZEUS’s Solidity to LLVM
bitcode translator introduces checks for several bugs described
in § III-A and § III-C. Fig. 16a plots a CDF of this instruction
overhead due to additional LLVM bitcode LOC introduced
per contract. We observe that ZEUS introduces less than 50
LOC for 97% of contracts across ﬁve of the seven bug classes.
For integer overﬂow/underﬂow, ZEUS’s checks account for less
than 200 LOC in 95% of the contracts. However, detection of
transaction order dependence incurs maximum overhead, with
20% contracts requiring over 500 LOC for the required checks.
(II) ANALYSIS COMPLEXITY. We measure the veriﬁcation
complexity by determining the number of rules generated
and their depth per contract across the seven bug classes.
Fig. 16b and Fig. 16c plot the results. We observe that 75%
of contracts across all categories generate less than 50 rules
with depth of around 700. Overall, integer overﬂow generates
maximum constraint rules and depth across all categories,
with a maximum of 1035 rules and depth of 277, 345. This
behavior is consistent with our observation that contracts have
signiﬁcant amount of arithmetic operations (recall Fig. 15d).
(III) ANALYSIS TIME. We determine ZEUS’s veriﬁcation time
for each unique contract in our data set and compare against
Oyente. Fig. 16d plots the CDF of the results. We observe
that ZEUS takes a minute or less for verifying 97% contracts
(as indicated by the vertical line). Only 44 contracts out of
1524 timeout or give no result for one or more bug classes. In
contrast, Oyente returns results for only 40% contracts within
one minute. Furthermore, it provides no result or timeouts
(even after 30 minutes) for around 43% contracts.
13
(a) LLVM bitcode instruction overhead.
(b) Veriﬁcation rules generated.
(c) Veriﬁcation constraints generated.
(d) Veriﬁcation time in minutes.
Fig. 16: ZEUS’s performance.
D. Case Studies
We now demonstrate ZEUS’s versatility with other
blockchain platforms and veriﬁcation engines. First, we port
a popular Solidity contract to Fabric [24]. Second, we use
SMACK [72] to verify fairness policies for the said contract.
We describe our experiences below.
Simple Dice [39] is a popular multi-player gambling
contract, where players put in a minimum deposit (along with
a fee) to play. The players have a 25% chance of winning the
entire balance. Also, every 40th player wins the jackpot, which
is considerably more than the balance. The fee and deposit rate
can only be changed by the owner, and is publicly visible.
To validate the contract, we check the following ﬁve
policies: (a) a minimum deposit is required to play the game,
(b) every 40th player does win the jackpot, (c) only the owner
can change the deposit and fee rate, (d) the owner cannot
participate in the game, and (e) every player must have an
equal chance of winning the jackpot, i.e., a player must not
have multiple entries when playing for the jackpot.
(I) FABRIC. Smart contracts in Fabric can be written in
high-level languages, such as GO and JAVA. Solidity’s global
variables that persist state across transactions are mapped on
to the blockchain. In contrast, high-level languages do not
have this support; the globals share state across functions calls.
Fabric gets around this problem by deﬁning a shim layer for
each high-level language that exports APIs to allow smart
contracts to explicitly manage state atop the blockchain.
We ported the Simple Dice contract to GO and linked it
against Fabric’s mock-stub [25]. However, we noticed that
the mock-stub takes strings as input and converts them to
the required data types using standard GO libraries. Since
Seahorn does not have support for strings, we ﬁxed the mock-
stub to take integers as input. While policy speciﬁcation is
automated for Solidity, we manually edited the GO code
and placed the correct assertions along the required program
paths, corresponding to the above mentioned policies. We then
leveraged llgo [27] to generate LLVM bitcode for Simple
Dice and veriﬁed the policies with Seahorn.
(II) SMACK. To leverage SMACK as the veriﬁer of choice,
we had to make three key modiﬁcations. First, since SMACK
supports integer operations up to 64 bytes [30], we had to
port our Solidity to LLVM bitcode translator to work with 64
bytes. Note that Solidity supports integers of length 256 bytes.
Second, SMACK, unlike Seahorn, requires developers to use
different APIs to request for the entire integer domain [40].
For example, one has to use
VERIFIER nondet ushort
for modeling integer domains for unsigned short, and
VERIFIER nondet uint for unsigned int. Third, the
APIs for invocation to the veriﬁer are different between
SMACK and Seahorn. Overall, we required around 50 lines of
modiﬁcations to ZEUS to make it compatible with SMACK.
With our SMACK-compatible ZEUS, we veriﬁed the ﬁve
fairness policies for Simple Dice as described earlier.
Our experiences with both Fabric and SMACK suggest that
it is easy to extend ZEUS to other blockchain platforms and
veriﬁers with only minor changes.
VII. RELATED WORK
SMART CONTRACT BUG DETECTION. We now compare
and contrast ZEUS with related work in the area of smart
contract bug detection, apart from Oyente [68], Bhargavan et
al. [54] and Why3 [22], [50], which we have discussed earlier.
Delmolino et al. [58] document several classes of mistakes
when developing contracts, suggest ways to mitigate these
errors, and advocate best practices for programming smart
contracts. In contrast, ZEUS presents a formal veriﬁcation
framework for smart contracts that enables users to build and
verify correctness and fairness policies over them.
POLICY SPECIFICATION. Naccio [60], PoET/Pslang [59]
and Polymer [53] enable policy speciﬁcation for security
properties. Like prior work, ZEUS ensures that the veriﬁcation
policy is deﬁned separately from the main application. This
separation of logic makes it easier to understand, verify, and
modify the security policy. XACML [51] deﬁnes a declarative
ﬁne-grained, attribute-based access control policy language
that inspires ZEUS’s syntax for policy declaration.
VIII. CONCLUSION
We present the design and implementation of ZEUS—a
framework for analyzing safety properties of smart contracts.
ZEUS leverages abstract interpretation and symbolic model
checking, along with the power of CHCs to quickly ascertain
the veriﬁcation conditions. We build the ﬁrst Solidity to LLVM
bitcode translator to automatically insert veriﬁcation conditions
given a policy speciﬁcation. Our evaluation with over 22.4K
Solidity smart contracts indicates that about 94.6% of them
(with a net worth of more than $0.5 billion) are vulnerable.
ZEUS is sound (with zero false negatives) and signiﬁcantly
outperforms Oyente for contracts in our data set, with low
false positive rate and an order of magnitude improvement in
time for veriﬁcation.
14
 0 0.2 0.4 0.6 0.8 1 0 300 600 900 1200CDFOverhead (LOC)ReentrancyUnchecked sendFailed sendInteger overflowTx. state depBlk. state dep.Tx. order dep. 0.75 0.8 0.85 0.9 0.95 1 50 100 150 200 250 300CDF# constraintsReentrancyUnchecked sendFailed sendInteger overflowTx. state dep.Blk. state dep.Tx. order dep 0.75 0.8 0.85 0.9 0.95 1 500 900 1300 1700 2100CDFConstraint depthReentrancyUnchecked sendFailed sendInteger overflowTx. state dep.Blk. state dep.Tx. order dep 0 0.2 0.4 0.6 0.8 1 0 5 10 15 20 25 30CDFTime (min)ZeusOyenteACKNOWLEDGEMENT
We thank the anonymous reviewers for their valuable
comments. We are also grateful to Prasad Naldurg for his
feedback on an earlier draft of the paper.
REFERENCES
“Analysis of the DAO exploit,” http://hackingdistributed.com/2016/06/
18/analysis−of−the−dao−exploit/.
“Auction house,” https://git.io/vFAl6.
“Blockchain investment in 2016,” https://www.cryptocoinsnews.com/
pwc−expert−1−4−billion−invested−blockchain−2016/.
“Buggy contract,” https://live.ether.camp/account/
dfa42284475636ecc1e04f519b075ec7f1e04f48/contract.
“CampaignToken,” https://etherscan.io/address/
0xa0388ffb2a3c198dee723135e0caa423840b375a.
“Computation in Fallback Function,”
https://ethereum.stackexchange.com/questions/5992/how−much−
computation−can−be−done−in−a−fallback−function.
“Contest contract,” https://etherscan.io/address/
0x98086130278fe48f2f0330e330df6ed6c91ce4f7#code.
“Cross-function Race Condition,” https://git.io/vFA4y.
“CrowdFundDAO,” https://live.ether.camp/account/
9b37508b5f859682382d8cb6467a5c7fc5d02e9c/contract.
“DiceRoll,” https://ropsten.etherscan.io/address/
0xb95bbe8ee98a21b5ef7778ec1bb5910ea843f8f7#code.
“EtherCamp,” https://live.ether.camp/.
“Etherchain,” https://www.etherchain.org/contracts.
“Ethereum,” https://www.ethereum.org/.
“Ethereum Block Protocol,” https://git.io/vFA8I.
“Ethereum Blog,”
https://blog.ethereum.org/2016/06/10/smart−contract−security/.
“Ethereum Contract Security,” https://git.io/vFA8a.
“Ethereum Doubler,” https://etherscan.io/address/
0x83651a62b632c261442f396ad7202fe2a4995e3a#code.
“Etherscan,” https://etherscan.io/accounts/c.
“Etherscan - Ropsten,” https://ropsten.etherscan.io/accounts/c.
“Exception on overﬂow #796,” https://git.io/vFA8e.
“Formal Veriﬁcation and Ethereum,”
https://ethereum.stackexchange.com/questions/11092/what−is−formal−
veriﬁcation−and−why−is−it−important−for−smart−contracts.
“Formal Veriﬁcation for Solidity Contracts,” https://forum.ethereum.
org/discussion/3779/formal−veriﬁcation−for−solidity−contracts.
“HackerGold Bug,” https://git.io/vFAl2.
“Hyperledger Fabric,” https://hyperledger.org/projects/fabric.
“Hyperledger Fabric Mockstub,” https://git.io/vFA8Y.
“Inian Parameshwaran,” Personal Communication.
“LLVM-based compiler for Go ,” https://git.io/FPuO.
“Logical bug,” https://live.ether.camp/account/
ef71862273817c9e082ca2c92486c8dcdcd9356f/contract.
“Loi Luu,” Personal Communication.
“Model arbitrary integer size,” https://git.io/vFAlu.
“Multiply your ether,” https://etherscan.io/address/
0xc357a046c5c13bb4e6d918a208b8b4a0ab2f2efd#code.
“Oyente: An Analysis Tool for Smart Contracts,” https://git.io/vFAlX.
“Oyente Results,” https://raw.githubusercontent.com/oyente/
benchmarks/master/benchmark/results.json.
“Parity MultiSig bug,”
http://hackingdistributed.com/2017/07/22/deep−dive−parity−bug.
“Remove tx.origin #683,” https://git.io/vFA8n.
“Scoping and Declarations,”
https://solidity.rtfd.io/en/develop/control−structures.html.
“SeaHorn,” https://seahorn.github.io/.
[1]
[2]
[3]
[4]
[5]
[6]
[7]
[8]
[9]
[10]
[11]
[12]
[13]
[14]
[15]
[16]
[17]
[18]
[19]
[20]
[21]
[22]
[23]
[24]
[25]
[26]
[27]
[28]
[29]
[30]
[31]
[32]
[33]
[34]
[35]
[36]
[37]
[38]
[39]
[40]
[41]
[42]
[43]
[44]
[45]
[46]
[47]
[48]
[49]
[50]
[51]
[52]
“Send w/Throw Is Dangerous,” http://vessenes.com/ethereum−
grieﬁng−wallets−send−w−throw−considered−harmful/.
“Simple Dice,” https://etherscan.io/address/
0x237f29bbFd52C768A02980eA8D4D983a1D234eDC.
“Smack,” https://git.io/vFAlB.
“Solidity Programming Language.” https://git.io/vFA47.
“StandardToken,” https://git.io/vFAlg.
“The DAO,” https://en.wikipedia.org/wiki/The DAO (organization).
“The DAO is kind of a mess,” https://www.wired.com/2016/06/
biggest−crowdfunding−project−ever−dao−mess/.
“Tx.Origin And Ethereum Oh My!”
http://vessenes.com/tx−origin−and−ethereum−oh−my/.
“Unchecked-Send Bug,” http://hackingdistributed.com/2016/06/16/
scanning−live−ethereum−contracts−for−bugs/.
“Underhanded Solidity coding,” https://redd.it/4e5y30.
“Units and Globally Available Variables,”
https://solidity.rtfd.io/en/develop/units−and−global−variables.html.
“Wallet,” https://etherscan.io/address/
0xab7c74abc0c4d48d1bdad5dcb26153fc8780f83e.
“Why3,” http://why3.lri.fr/.
“XACML,” https://tools.ietf.org/html/rfc7061.
J. Barnat et al., “DiVinE 3.0 – An Explicit-State Model Checker for
Multithreaded C & C++ Programs,” in CAV ’13.
[53] L. Bauer et al., “Composing Security Policies with Polymer,” in PLDI
’05.
[54] K. Bhargavan et al., “Formal Veriﬁcation of Smart Contracts: Short
Paper,” in PLAS ’16.
[55] N. Bjørner et al., “Program Veriﬁcation as Satisﬁability Modulo
Theories,” in SMT ’12.
[56] A. R. Bradely, “SAT-based Model Checking without unrolling,” in
VMCAI 2011.
[57] M. Castro et al., “Practical Byzantine Fault Tolerance,” in OSDI ’99.
[58] K. Delmolino et al., “Step by Step Towards Creating a Safe Smart
Contract: Lessons and Insights from a Cryptocurrency Lab.” in FC
’16.
[59] U. Erlingsson et al., “IRM Enforcement of Java Stack Inspection,” in
S&P ’00.
[60] D. Evans et al., “Flexible Policy-Directed Code Safety,” in S&P ’99.
[61] A. Gurﬁnkel et al., “The SeaHorn Veriﬁcation Framework,” in CAV
’15.
[62] A. Juels et al., “The Ring of Gyges: Investigating the Future of
Criminal Smart Contracts,” in CCS ’16.
[63] A. Komuravelli et al., “SMT-based Model Checking for Recursive
Programs,” in CAV’14.
[64] A. E. Kosba et al., “Hawk: The Blockchain Model of Cryptography
and Privacy-Preserving Smart Contracts,” in S&P ’16.
[65] L. Lamport, “The Part-time Parliament,” ACM Trans. Comput. Syst.
[66] C. Lattner et al., “LLVM: A Compilation Framework for Lifelong
Program Analysis & Transformation,” in CGO ’04.
[67] L. Luu et al., “Demystifying Incentives in the Consensus Computer,”
in CCS ’15.
[68] ——, “Making Smart Contracts Smarter,” in CCS ’16.
[69] K. L. McMillan, “Interpolants and Symbolic Model Checking,” in
VMCAI 2007.
[70] S. Nakamoto, “Bitcoin: A Peer-to-Peer Electronic Cash System.”
[Online]. Available: https://bitcoin.org/bitcoin.pdf
[71] D. Ongaro et al., “In Search of an Understandable Consensus
Algorithm,” in USENIX ATC’14.
[72] Z. Rakamari´c et al., “SMACK: Decoupling Source Language Details
from Veriﬁer Implementations,” in CAV ’14.
[73] F. Zhang et al., “Town Crier: An Authenticated Data Feed for Smart
Contracts,” in CCS ’16.
J. Zhao et al., “Formalizing the LLVM Intermediate Representation
for Veriﬁed Program Transformations,” in POPL ’12.
[74]
15