  scrape_interval: 5s
scrape_configs:
  - job_name: 'Api'
    static_configs:
      - targets: ['api:50505']
  - job_name: 'NerdDinnerWeb'
    static_configs:
      - targets: ['nerd-dinner:50505']
```
每个要监视的应用都被指定为一个作业，每个端点都被列为一个目标。普罗米修斯将在同一个 Docker 网络上的一个容器中运行，所以我可以通过容器名称来引用目标。
This setup is for a single Docker Engine, but you can use the same approach with Prometheus to monitor services running across multiple replicas, just using different configuration settings. I cover that in detail for Windows and Linux containers in my Pluralsight course, *Monitoring Containerized Application Health with Docker.*
现在，我可以在一个容器中启动普罗米修斯服务器:
```
docker container run -d -P --name prometheus dockeronwindows/ch11-prometheus:2e
```
普罗米修斯轮询所有配置的指标端点并存储数据。您可以使用普罗米修斯作为丰富的用户界面组件(如 Grafana)的后端，将所有运行时关键绩效指标构建到一个仪表板中。对于基本监控，普罗米修斯服务器有一个简单的网络用户界面在端口`9090`上监听。
我可以去普罗米修斯容器的发布端口，对它从我的应用容器中抓取的数据运行一些查询。普罗米修斯用户界面可以显示原始数据，或随时间变化的聚合图形。下面是 REST API 应用发送的 HTTP 响应:
![](img/51c842d2-ccef-4050-804c-944af2e34719.png)
您可以看到，每个不同的标签值都有单独的行，因此我可以看到来自不同 URL 的不同响应代码。这些计数器随着容器寿命的增加而增加，因此图表总是向上。普罗米修斯有一套丰富的功能，因此您也可以绘制一段时间内的变化率，汇总指标，并选择数据的预测。
普罗米修斯`NuGet`包中的其他计数器是快照，例如性能计数器统计。我可以看到 IIS 每秒从 NerdDinner 容器处理的请求数:
![](img/9cc9e9fb-a94b-4fb5-a7ea-a988d49eb640.png)
公制名称在普罗米修斯中很重要。如果我想比较. NET Console 和 ASP.NET 应用的内存使用情况，那么我可以查询两组值是否具有相同的度量名称，类似于`process_working_set`。每个指标的标签标识哪个服务提供数据，因此您可以跨所有服务进行聚合或筛选到特定的服务。您还应该包含每个容器的标识符作为度量标签。导出应用添加服务器主机名作为标签。这实际上是容器标识，所以当您大规模运行时，您可以聚合整个服务或查看单个容器。
在[第 8 章](08.html)*管理和监控 Docker 化解决方案*中，我演示了 Docker 企业中的**通用控制平面**(**UCP**)**容器即服务** ( **CaaS** )平台。启动和管理 Docker 容器的标准 API 让这个工具提供了一个统一的管理和行政体验。Docker 平台的开放性让开源工具可以采用相同的方法来进行丰富、整合的监控。
普罗米修斯就是一个很好的例子。它作为轻量级服务器运行，非常适合在容器中运行。您可以通过在应用中添加度量端点，或者在现有应用旁边运行度量导出器，在应用中添加对普罗米修斯的支持。Docker 引擎本身可以配置为导出 Prometheus 指标，因此您可以收集关于容器和节点运行状况的低级指标。
您只需要这些指标就可以启动一个丰富的仪表板，让您一目了然地了解应用的运行状况。
# 在格拉夫纳构建应用仪表板
Grafana 是一个可视化数据的网络用户界面。它可以读取许多数据源，包括时间序列数据库(如普罗米修斯)和关系数据库(如 SQL Server)。您可以在 Grafana 中构建仪表板，显示整个应用资产的运行状况，包括业务关键绩效指标、应用和运行时指标以及基础架构运行状况。
您通常在一个容器化的应用中添加 Grafana 来呈现来自普罗米修斯的数据。您也可以在一个容器中运行 Grafana，并且可以打包您的 Docker 映像，以便内置仪表板、用户帐户和数据库连接。在本章的最后部分，我已经在`dockeronwindows/ch11-grafana:2e`映像中这样做了。Grafana 团队不在 Docker Hub 上发布 Windows 映像，因此我的 Dockerfile 从一个示例映像开始，并添加了我的设置的所有配置:
```
# escape=`
FROM dockersamples/aspnet-monitoring-grafana:5.2.1-windowsservercore-ltsc2019
SHELL ["powershell", "-Command", "$ErrorActionPreference = 'Stop';"]
COPY datasource-prometheus.yaml \grafana\conf\provisioning\datasources\
COPY dashboard-provider.yaml \grafana\conf\provisioning\dashboards\
COPY dashboard.json \var\lib\grafana\dashboards\
COPY init.ps1 .
RUN .\init.ps1 
```
Grafana 有两种自动化部署的方法。第一个只是使用已知位置的文件，我用它来设置普罗米修斯数据源、仪表板和仪表板提供程序，仪表板提供程序只是将 Grafana 指向仪表板的目录。第二个使用 REST API 进行认证和授权，我的`init.ps1`脚本使用该 API 创建一个可以访问仪表板的只读用户。
用 Grafana 创建自己的仪表板很简单。您可以为特定类型的可视化创建面板，数字、图形、热图、交通灯和表格都受支持。然后，将面板连接到数据源并指定查询。通常，您会使用普罗米修斯用户界面来微调查询，然后将其添加到格拉夫纳。为了节省时间，我的映像附带了一个现成的仪表板。
我将从`ch11`文件夹中的 Docker Compose 文件开始监控解决方案，然后浏览到 API 和网站生成一些流量。现在，我可以浏览到 Grafana 并使用用户名`viewer`和密码`readonly`登录，我将看到仪表板:
![](img/a8ac5193-aa9c-433f-811e-5e25f9899cfa.png)
这只是一个示例仪表板，但它让您知道您可以呈现多少信息。我有一行是 REST API，显示了 HTTP 请求和响应的细分，以及 CPU 使用的整体视图。我还有一行用于 NerdDinner，显示来自 IIS 的性能指标和缓存使用情况的标题统计。
您可以不费吹灰之力将工具添加到所有应用中，并构建一个详细的仪表板，让您了解解决方案中正在发生的事情。此外，您可以在每个环境中拥有完全相同的监控设施，因此在开发和测试中，您可以看到与生产中使用的相同的指标。这对于跟踪性能问题非常有用。开发人员可以为性能问题添加新的度量和可视化，修复问题，并且当更改生效时，它将包括可以在生产中跟踪的新度量。
本章我要讲的最后一件事是如何修复 Docker 中的 bug，以及容器化如何让它变得更容易。
# Docker 中的错误修复工作流
修复生产缺陷的最大困难之一是在您的开发环境中复制它们。这是确认您有 bug 的第一步，也是深入查找问题的起点。这也可能是问题中最耗时的部分。
大的.NET 项目往往不经常发布，因为发布过程很复杂，需要大量的手动测试来验证新特性并检查任何回归。一年只有三四个版本，开发人员发现自己不得不在发布过程的不同部分支持应用的多个版本，这并不罕见。
在这种情况下，你可能会有 1.0 版本的产品，1.1 版本的**用户验收测试** ( **UAT** )和 1.2 版本的系统测试。这些版本中的任何一个都可能会出现 bug，开发团队需要在他们目前致力于版本 1.3，甚至是版本 2.0 的重大升级时追踪并修复这些 bug。
# 在 Docker 之前修复错误
我已经在这个位置上很多次了，不得不从我正在处理的重构的 2.0 代码库切换回即将发布的 1.1 代码库。上下文切换是昂贵的，但是设置我的开发环境来重新创建 1.1 UAT 环境的过程更昂贵。
发布过程可能会创建一个版本化的 MSI，但是通常你不能在你的开发环境中运行它。安装程序可以与特定环境的配置一起打包。它可能是在发布模式下编译的，打包时没有 PDB 文件，因此没有附加调试器的选项，并且它可能有我在开发中没有的先决条件，例如证书或加密密钥或其他软件组件。
相反，我需要从源代码重新编译 1.1 版本。希望发布过程有足够的信息让我找到用于构建发布的确切源代码，取一个分支，并在本地克隆它(可能 Git 提交 ID 或 TFS 更改集记录在构建的程序集中)。然后，当我试图在我的本地开发盒上重新创建另一个环境时，真正的问题就开始了。
工作流程看起来有点像这样，我的设置和 1.1 环境有很多不同之处:
*   在本地编译源代码。我将在 Visual Studio 中构建该应用，但发布的版本使用了 MSBuild 脚本，这些脚本会做很多额外的事情。
*   在本地运行应用。我将在 Windows 10 上使用 IIS Express，但是该版本使用了一个在 Windows Server 2012 上部署到 IIS 8 的 MSI。
*   我的本地 SQL Server 数据库是为我正在使用的 2.0 模式设置的。这个版本有从 1.0 到 1.1 的升级脚本，但是没有从 2.0 到 1.1 的降级脚本，所以我需要手动修复本地模式。
*   我有任何不能在本地运行的依赖项的存根，比如第三方 API。该版本使用真实的应用组件。
即使我能获得 1.1 版的确切源代码，我的开发环境与 UAT 环境也有很大的不同。这是我能做的最好的了，可能需要几个小时的努力。为了减少这一时间，我可以走捷径，例如利用我对应用的了解，针对 2.0 数据库模式运行 1.1 版，但走捷径意味着我的本地环境更不像目标环境。
此时，我可以在调试模式下运行该应用，并尝试复制该问题。如果 bug 是由 UAT 的数据问题或环境问题引起的，那么我将无法复制它，并且可能需要一整天的努力才能发现。如果我怀疑问题与 UAT 的设置有关，我无法在我的环境中验证这一点；我需要和行动小组一起研究 UAT 的配置。
但是希望我能按照错误报告中的步骤重现这个问题。当我完成手动步骤后，我可以编写一个失败的测试来复制这个问题，并且当我更改代码并且测试绿色运行时，我确信我已经修复了这个问题。我的环境和 UAT 之间存在差异，所以可能是我的分析不正确，修复程序无法修复 UAT，但我要到下一个版本才会发现这一点。
如何将修复程序发布到 UAT 环境中是另一个问题。理想情况下，已经为 1.1 分支建立了完整的配置项和打包过程，所以我只需推送我的更改，新的 MSI 就会出现，并准备好进行部署。在最坏的情况下，配置项仅从主分支运行，因此我需要在修复分支上设置一个新作业，并尝试将该作业配置为与上一个 1.1 版本相同。
如果工具链的任何部分在 1.1 和 2.0 之间移动，那么它会使过程的每一步都更加困难，从配置本地环境、运行应用、分析问题和推动修复。
# 用 Docker 修复错误
使用 Docker 的过程要简单得多。要在本地复制 UAT 环境，我只需要从在 UAT 运行的相同映像中运行容器。将会有一个 Docker Compose 或栈文件描述整个版本化的解决方案，因此通过部署 1.1 版本，我可以获得与 UAT 完全相同的环境，而不必从源代码构建。
在这一点上，我应该能够复制这个问题，并确认它是编码问题还是与数据或环境有关的问题。如果这是一个配置问题，那么我应该会看到和 UAT 一样的问题，我可以用一个更新的 Compose 文件来测试这个修复。如果是编码问题，那么我需要深入研究代码。
在这一点上，我可以从 1.1 版本标签中克隆源代码，并在调试模式下构建 Docker 映像，但在我非常确定这是应用中的问题之前，我不会花时间这样做。如果我使用的是多阶段构建，所有版本都固定在 Dockerfile 中，本地构建将生成一个与在 UAT 运行的版本相同的映像，但是有额外的调试工件。
现在，我可以找到问题，编写测试，并修复 bug。当新的集成测试通过时，它将针对我将在 UAT 部署的同一个 Dockerized 解决方案执行，因此我可以非常自信地认为这个错误已经被修复。
如果没有为 1.1 分支配置配置项，那么设置它应该很简单，因为构建任务只需要运行`docker image build`或`docker-compose build`命令。如果我想要快速反馈，我甚至可以将本地构建的映像推送到注册表，并部署一个新的 UAT 环境来验证配置项设置时的修复。这个新环境只是测试集群上的一个不同的栈，所以我不需要为部署委托更多的基础设施。
Docker 的工作流程更干净、更快，但更重要的是，风险要小得多。当您在本地复制问题时，您使用的应用组件与 UAT 环境运行在完全相同的平台上。当您测试您的修复时，您知道它将在 UAT 工作，因为您将部署相同的新工件。
您在应用 Dockerizing 上投入的时间将通过支持多个版本的应用节省的时间得到多次回报。
# 摘要
本章介绍了容器中运行的应用的故障排除，以及调试和检测。Docker 是一个新的应用平台，但是容器中的应用在主机上作为进程运行，因此它们仍然是远程调试和集中监控的合适目标。
Visual Studio 的所有当前版本都支持 Docker。Visual Studio 2017 支持最全，涵盖 Linux 和 Windows 容器。Visual Studio 2015 和 Visual Studio Code 目前具有为 Linux 容器提供调试的扩展。您可以轻松添加自己对 Windows 容器的支持，但完整的调试体验仍在不断发展。
在本章中，我还介绍了 Prometheus，这是一个轻量级的检测和监控组件，您可以在 Windows Docker 容器中运行。Prometheus 存储它从运行在其他容器上的应用中提取的指标。容器的标准化特性使得像这样的监控解决方案非常容易配置。我使用普罗米修斯数据在格拉夫纳驱动了一个仪表板，在一个容器中运行，这是一种简单而强大的方式来呈现应用运行状况的综合视图。
下一章是这本书的最后一章。最后，我将分享一些在您自己的领域中开始使用 Docker 的方法，包括我在现有项目中使用 Docker 的案例研究。