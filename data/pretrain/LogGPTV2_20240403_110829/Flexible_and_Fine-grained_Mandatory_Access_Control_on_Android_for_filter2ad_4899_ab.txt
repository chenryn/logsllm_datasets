security context of an app at install-time. Based on
criteria, such as the requested permissions, apps are
assigned a security type. This mapping from appli-
cation meta-information to security types is deﬁned
in the SE Android policy.
Additionally, SE Android provides limited support
for MAC policy enforcement at the Android middle-
ware layer (MMAC) and we explain these particular
features in Section 7.2 and provide a comparison to
our FlaskDroid architecture.
3 Requirements Analysis for Android
Security Architectures
3.1 Adversary Model
We consider a strong adversary with the goal to get
access to sensitive data as well as to compromise
system or third-party apps. Thus, we consider an
adversary that is able to launch software attacks on
diﬀerent layers of the Android software stack.
3.1.1 Middleware Layer
Recently, diﬀerent attacks operating at Android’s
middleware layer have been reported:
Overprivileged 3rd party apps and libraries
threatening user privacy by adopting questionable
privacy practices (e.g. WhatsApp [6] or Path [23]).
Moreover, advertisement libraries,
frequently in-
cluded in 3rd party apps have been shown to exploit
the permissions of their host app to collect informa-
tion about the user [25].
Malicious 3rd party apps [22] leverage dangerous
permissions to cause ﬁnancial harm to the user (e.g.,
sending premium SMS) and exﬁltrate user-private
information [57, 40].
Confused deputy attacks concern malicious apps,
which leverage unprotected interfaces of benign sys-
tem [20, 41] and 3rd party [16, 56] apps (denoted
deputies) to escalate their privileges.
Collusion attacks concern malicious apps that col-
lude using covert or overt channels [8, 34] in order to
gain a permission set which has not been approved
by the user (e.g. the Soundcomber attack [46]).
Sensory malware leverages the information from
onboard sensors, like accelerometer data, to derive
privacy sensitive information, like user input [53, 12].
3.1.2 Root Exploits
Besides attacks at Android’s middleware layer, vari-
ous privilege escalation attacks on lower layers of the
Android software stack have been reported [55, 40]
which grant the attacker root (i.e., administrative)
privileges and can be used to bypass the Android per-
mission framework. For instance, he can bypass the
ContactsProvider permission checks by accessing the
contacts database ﬁle directly. Moreover, processes
on Android executing with root privileges inherit all
available permissions at middleware layer.
It should be noted that attacks targeting vulner-
abilities of the Linux kernel are out of scope of this
paper, since SE Android is a building block in our
architecture (see Section 4) and as part of the kernel
it is susceptible to kernel exploits.
3.2 Requirements
Based on our adversary model we derive the neces-
sary requirements for an eﬃcient and ﬂexible access
control architecture for mobile devices, focusing on
the Android OS.
Access Control on Multiple Layers. Manda-
tory access control solutions at kernel level, such
as SE Android [48] or Tomoyo [27], help to defend
against or to constrain privilege escalation attacks on
134  22nd USENIX Security Symposium 
USENIX Association
USENIX Association  
22nd USENIX Security Symposium  135
thelower-levelsoftheOS[48].However,kernellevelMACprovidesinsuﬃcientprotectionagainstsecurityﬂawsinthemiddlewareandapplicationlayers,andlacksthenecessaryhigh-levelsemanticstoenableaﬁne-grainedﬁlteringatthoselayers[48,47].Accesscontrolsolutionsatmiddlewarelevel[28,15,39,9,8]areabletoaddresstheseshortcomingsofkernellevelMAC,butare,ontheotherhand,susceptibletolow-levelprivilegeescalationattacks.Thus,aﬁrstrequirementistoprovidesimultaneousMACdefensesatthetwolayers.Ideally,thesetwolayerscanbedynamicallysynchronizedatrun-timeovermutualinterfaces.Atleast,thekernelMACisabletopreservesecurityinvariants,i.e.,itenforcesthatanyaccesstosensitiveresources/functionalityisalwaysﬁrstmediatedbythemiddlewareMAC.Multiplestakeholderspolicies.Mobilesystemsinvolvemultiplestakeholders,suchastheend-user,thedevicemanufacturer,appdevelopers,orother3rdparties(e.g.,theend-user’semployer).Thesestakeholdersalsostoresensitivedataonthedevice.Relatedwork[39,9]hasproposedspecialpurposesolutionstoaddressthesecurityrequirementsandspeciﬁcproblemsoftheseparties.Naturally,theassetsofdiﬀerentstakeholdersaresubjecttodiﬀerentsecurityrequirements,whicharenotalwaysalignedandmightconﬂict.Thus,oneobjectiveforagenericMACframeworkthatrequireshandlingpoliciesofmultiplestakeholdersistosupport(basic)policyreconciliationmechanisms[43,35].Context-awareness.Thesecurityrequirementsofdiﬀerentstakeholdersmaydependonthecurrentcontextofthedevice.Thus,ourarchitectureshallprovidesupportforcontext-awaresecuritypolicies.SupportfordiﬀerentUse-Cases.Ourarchitec-tureshallserveasabasisfordiﬀerentsecurityso-lutionsapplicableinavarietyofusecases.Forin-stance,bymodifyingtheunderlyingpolicyoursolu-tionshouldbeabletosupportdiﬀerentusecases(asshowninSection5),suchastheselectiveandﬁne-grainedprotectionofappinterfaces[39]orprivacy-enhancedsystemServicesandContentProviders.4FlaskDroidArchitectureInthissection,weprovideanoverviewofourFlaskDroidarchitecture,elaborateinmoredetailonparticulardesigndecisions,andpresentthepolicylanguageemployedinoursystem.Duetospacecon-straints,wefocusonthemostimportantaspectsandrefertoourtechnicalreport[11]formoredetailedinformation.Services (Location, Telephony) ContentProviders (Contacts, SMS,…) API API Hook Hook API access SE Android Resource (Filesystem,…) API Hook Low-Level MAC queries User-space Kernel space SysCall Context Providers FlaskDroid component Modified component SE Android module Policy Database User System Apps User-Space Security Server App Policy App Rules update MAC queries Package Manager User Policy App Standard Android Update boolean flags Geolocation Network state … Set active context Feedback Figure1:FlaskDroidArchitecture4.1OverviewThehigh-levelideaofFlaskDroidisinspiredbytheFlasksecurityarchitecture[50],wherevariousObjectManagersatmiddlewareandkernel-levelarerespon-sibleforassigningsecuritycontextstotheirobjects.Objectscanbe,forinstance,kernelresourcessuchasFilesorIPCandmiddlewareresourcessuchasServiceinterfaces,Intents,orContentProviderdata.Onaccesstotheseobjectsbysubjects(i.e.,apps)toperformaparticularoperation,themanagersenforceanaccesscontroldecisionthattheyrequestfromasecurityserverattheirrespectivelayer.Thus,ourapproachimplementsauserspacesecurityserver.Accesscon-trolinFlaskDroidisimplemented,asinSEAndroid(cf.Section2),astypeenforcement.However,incon-trasttoSEAndroidweextendourpolicylanguagewithnewfeaturesthataretailoredtotheAndroidmiddlewaresemantics(cf.Section4.3).Moreover,toenablemoredynamicpolicies,thepolicychecksinFlaskDroiddependalsoontheSystemState,whichdeterminestheactualsecuritycontextoftheobjectsandsubjectsatruntime.Eachsecurityserverisalsoresponsibleforthepol-icymanagementformultiplestakeholderssuchasappdevelopers,end-user,or3rdparties.Aparticularfeatureisthatthepoliciesonthetwolayersaresyn-chronizedatruntime,e.g.,achangeinenforcementinthemiddleware,mustbesupported/reﬂectedatkernel-level.Thus,bydecouplingthepolicyman-agementanddecisionmakingfromtheenforcementpointsandconsolidatingthebothlayers,thegoalofFlaskDroid’sdesignistoprovideﬁne-grainedandhighlyﬂexibleaccesscontroloveroperationsonbothmiddlewareandkernel-level.4.2 Architecture Components
Figure 1 provides an overview of our architecture. In
the following, we will explain the individual compo-
nents that comprise the FlaskDroid architecture.
Server (USSS) is implemented as part of the Android
system server (com.android.server) and comprises
3741 lines of Java code. It exposes an interface to
the USOMs for requesting access control decisions
over ICC (cf. Figure 1).
4.2.1 SE Android Module
At the kernel-level, we employ stock SE Android [48]
as a building block primarily for the following pur-
poses: First, it is essential for hardening the Linux
kernel [48] thereby preventing malicious apps from
(easily) escalating their privileges by exploiting vul-
nerabilities in privileged (system) services. Even
when an attack, usually with the intent of gaining
root user privileges, is successful, SE Android can con-
strain the ﬁle-system privileges of the app by restrict-
ing the privileges of the root account itself. Second,
it complements the policy enforcement at the mid-
dleware level by preventing apps from bypassing the
middleware enforcement points (in Flask terminology
deﬁned as Userspace Object Managers (USOMs)), for
example, accessing the contacts database ﬁle directly
instead of going through the ContactsProvider app.
Dynamic policies. Using the dynamic policy sup-
port of SELinux (cf. Section 2.3) it is possible to
reconﬁgure the access control rules at runtime de-
pending on the current system state. Our Userspace
Security Server (cf. Section 4.2.2) is hereby the trusted
user space agent that controls the SELinux dynamic
policies and can map system states and contexts to
SELinux boolean variables (cf. Section 4.3). To this
end, SE Android provides user space support (in
particular android.os.SELinux).
4.2.2 Userspace Security Server
In our architecture, the Userspace Security Server is
the central policy decision point for all userspace
access control decisions, while the SE Android ker-
nelspace security server is responsible for all ker-
nelspace policy decisions. This approach provides
a clear separation of security issues between the
userspace and the kernelspace components. Further-
more, it enables at middleware level the use of a more
dynamic policy schema (diﬀerent from the more static
SELinux policy language) which takes advantage of
the rich semantics (e.g., contextual information) at
that layer. Access control is implemented as type
enforcement based on (1) the subject type (usually
the type associated with the calling app), (2) the
object type (e.g., contacts_email or the type associ-
ated with the callee app UID), (3) the object class
(e.g., contacts_data or Intent), and (4) the operation
on the object (e.g. query). The Userspace Security
4.2.3 Userspace Object Managers
In FlaskDroid, middleware services and apps act
as Userspace Object Managers (USOMs) for their re-
spective objects. These services and apps can be
distinguished into system components and 3rd party
components. The former, i.e., pre-installed services
and apps, inevitably have to be USOMs to achieve
the desired system security and privacy, while the
latter can use interfaces provided by the Userspace
Security Server to optionally act as USOMs.
Table 4 in Appendix B provides an overview of
exemplary system USOMs in FlaskDroid and shows
some typical operations each object manager controls.
Currently, the USOMs implemented in FlaskDroid
comprise 136 policy enforcement points. In the fol-
lowing, we explain how we instrumented selected
components as Userspace Object Managers.
PackageManagerService
for
(un)installation of application packages. Further-
more,
it is responsible for ﬁnding a preferred
component for doing a task at runtime. For instance,
if an app sends an Intent to display a PDF, the
PackageManagerService looks for a preferred Activity
able to perform the task.
responsible
is
As a Userspace Object Manager, we extend the Pack-
ageManagerService to assign consolidated middleware-
and kernel-level app types to all apps during instal-
lation using criteria deﬁned in the policy (cf. Sec-
tion 4.3). This is motivated by the fact that at the
time a policy is written, one cannot predict which
3rd party apps will be installed in the future. Pre-
installed apps are labeled during the phone’s boot
cycle based on the same criteria. More explicitly,
we assign app types to the (shared) UIDs of apps,
since (shared) UIDs are the smallest identiﬁable unit
for application sandboxes. In addition, pre-deﬁned
UIDs in the system are reserved for particular system
components3 and we map these UIDs to pre-deﬁned
types (e.g., aid_root_t or aid_audio_t). Further-
more, we extend the logic for ﬁnding a preferred
component to only consider apps which are allowed
by the policy to perform the requested task.
ActivityManagerService is responsible for man-
aging the stack of Activities of diﬀerent apps, Activity
life-cycle management, as well as providing the Intent
3These pre-deﬁned UIDs on Android 4.0.4 are found in
system/core/include/private/android_ﬁlesystem_conﬁg.h
136  22nd USENIX Security Symposium 
USENIX Association
broadcast system. As a USOM, the ActivityManager-
Service is responsible for labeling Activity and Intent
objects and enforcing access control on them. Acti-
vities are labeled according to the apps they belong
to, i.e., the UID of the application process that cre-
ated the Activity. Subsequently, access control on
the Activity objects is enforced in the ActivityStack
subsystem of the ActivityManagerService. During op-
erations that manipulate Activities, such as moving
Activities to the foreground/background or destroying
them, the ActivityStack queries the USSS in order to
verify that the particular operations are permitted
to proceed depending on the subject type (i.e., the
calling app) and object type (i.e., the app owning
the Activity being modiﬁed).
Similar to apps, Intents are labeled based on avail-
able meta-information, such as the action and cate-
gory string or the sender app (cf. Section 4.3.1). To
apply access control to Broadcast Intents, we followed
a design pattern as proposed in [39, 9]. We modi-
ﬁed the ActivityManagerService to ﬁlter out receivers
which are not allowed to receive Intents of the pre-
viously assigned type (e.g., to prevent apps of lower
security clearance from receiving Broadcasts by an
app of a higher security clearance).
Content Providers are the primary means for apps
to share data. This data can be accessed over a
well-deﬁned, SQL-like interface. As Userspace Object
Managers, ContentProviders are responsible for assign-
ing labels to the data entries they manage during
insertion/creation of data and for performing access
control on update, query, or deletion of entries. Two
approaches for access control are supported: 1) at
the API level by controlling access to the provider as
a whole or 2) integrating it into the storage back-end
(e.g., SQLite database) for more ﬁne-grained per-data
access control.
For approach 2), we implemented a design pattern
for SQLite-based ContentProviders. Upon insertion
or update of entries, we verify that the subject type
of the calling app is permitted to perform this opera-
tion on the particular object type. To ﬁlter queries
to the database we create one SQL View for each
subject type and redirect the query of each calling
app to the respective View for its type. Each View
implements a ﬁltering of data based on an access con-
trol table managed by the USSS which represents the
access control matrix for subject/object types. This
approach is well-suited for any SQLite-based Con-
tentProvider and scales well to multiple stakeholders
by using nested Views.
Service components of an app provide a particular
functionality to other (possibly remote) components,
which access the Service interface via ICC. To instan-
tiate a Service as a Userspace Object Manager, we add
access control checks when a (remote) component
connects to the Service and on each call to Service
functions exposed by the Service API. The developer
of the Service can set the types of the service and its
functions by adding type-tags to their deﬁnitions.
Service interfaces are exposed as Binder IPC ob-
jects that are generated based on an interface spec-
iﬁcation described in the Android Interface Deﬁni-
tion Language (AIDL). We extended the lexer and
parser of Android’s AIDL tool to recognize (developer-
deﬁned) type tags on Service interfaces and function
declarations. The AIDL code generator was extended
to automatically insert policy checks for these types
in the auto-generated Service code. Since the AIDL
tool is used during build of the system as well as
part of the SDK for app development, this solution
applies to both system Services and 3rd party app
Services in the same way.
4.2.4 Context Providers
A context is an abstract term that represents the
current security requirements of the device. It can
be derived from diﬀerent criteria, such as physical
criteria (e.g., the location of the device) or the state
of apps and the system (e.g., the app being currently
shown on the screen). To allow for ﬂexible control
of contexts and their deﬁnitions, our design employs
Context Providers. These providers come in form of
plugins to our Userspace Security Server (see Figure 1)
and can be arbitrarily complex (e.g., use machine
learning) and leverage available information such as
the network state or geolocation of the device to
determine which contexts apply. Context Providers
register Listener threads in the system to detect con-
text changes similar to the approach taken in [15].
Each Context Provider is responsible for a distinct
set of contexts, which it activates/deactivates in the
USSS. Decoupling the context monitoring and deﬁni-
tion from our policy provides that context deﬁnitions
do not aﬀect our policy language except for very sim-
ple declarations (as we will show in Section 4.3.1).
Moreover, the USSS provides feedback to Context
Providers about the performed access control deci-
sions. This is particularly useful when instantiating
security models like [8, 15] in which access control
decisions depend on previous decisions.
4.3 Policy
4.3.1 Policy Language and Extensions
We extend SELinux’s policy semantics for type en-
forcement (cf. Section 2.3) with new default classes
USENIX Association  
22nd USENIX Security Symposium  137
Listing 1: Assigning types to apps and Intents
Listing 2: Linking booleans with contexts
1 defaultAppType untrustedApp_t;
2 defaultIntentType untrustedIntent_t;
3
4 appType app_telephony_t {
Package:package_name=com.android.phone; };
5
6 intentType intentLaunchHome_t {
7
8
Action:action_string=android.intent.action.MAIN;
Categories:category=android.intent.category.HOME;};
1 bool phoneBooth_b = false;
2 kbool allowIPTablesExec_b = true;
3
4 switchBoolean {
5
6
7
context=phoneBooth_con;
auto_reverse=true;
phoneBooth_b=true;};
SELinux boolean.
and constructs for expressing policies on both mid-
dleware and kernel-level. A recapitulation of the
SELinux policy language is out of scope of this paper
and we focus here on our extensions.
New default classes. Similar to classes at the
kernel-level, like ﬁle or socket, we introduce new
default classes and their corresponding operations
to represent common objects at middleware level,
such as Activity, Service, ContentProvider, and Intent.
Operations for these classes are, for example, query
a ContentProvider or receive an Intent.
Application and Intent Types. A further exten-
sion is the possibility to deﬁne criteria by which ap-
plications and Intents are labeled with a security type
(cf. Listing 1). The criteria for apps can be, for in-
stance, the application package name, the requested
permissions or the developer signature. Criteria for
assigning a type to Intent objects can be the Intent
action string, category or receiving component. If no