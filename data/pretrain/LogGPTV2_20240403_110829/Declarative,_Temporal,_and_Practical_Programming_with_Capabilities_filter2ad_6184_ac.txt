os ∈ Opens, rs ⊆Rights
Figure 4. Syntax of the set of Capsicum woven instructions capinstr.
or branches. The language of unwoven programs UNWOVEN
is the language of imperative programs with no woven
instructions: UNWOVEN = IMP(cid:2)∅(cid:3).
2) Language Semantics:
Syntax of Woven Programs: The language of woven
programs is the language of IMP programs that may execute
Capsicum woven instructions (Fig. 4), deﬁned over a set of
weaving variables WVars. A Capsicum woven instruction
may assign the result of a language operation to a variable in
WVars, or may execute a guarded invocation of a Capsicum
primitive. A Capsicum primitive is either cap enter, fork,
join, or limitfd(os, rs), for os ∈ Opens and rs ⊆ Rights.
A woven program is an IMP program instrumented to
execute Capsicum instructions: WOVEN = IMP(cid:2)capinstr(cid:3).
In this section, we deﬁne a
semantics of WOVEN programs by mapping each WOVEN
program to the executions that it may perform. In particular,
we deﬁne a semantic function τ that maps every WOVEN
program P and initial program state p to the trace of
capabilities that P holds throughout its execution from p.
τ is deﬁned using an operational-semantic function σs that
describes how each program statement updates the state of
the program. σs is deﬁned using the operational-semantic
function σw, which deﬁne how each weaving instruction
updates the program state. σw is deﬁned using the Capsicum
interpretation of Capsicum primitives, which deﬁnes how
each primitive updates the state maintained by Capsicum
(§III-A3).
The semantics of WOVEN, given in Fig. 5, is deﬁned
by a function τ (Fig. 5, Eqns. (1) and (2)) that maps
each program in WOVEN and initial program state p to
the sequence of capabilities that the program holds during
an execution that starts from p. Let a program state be an
assignment from each program variable to an integer value:
progstates = Vars → Z, where Z denotes the set of integers.
A capability state is the state maintained by the Capsicum
operating system. The set of capability states capstates
is deﬁned by the Capsicum architect (see §III-A3). Let a
capability trace be a sequence of program labels paired with
the capabilities that the program has as it executes the block
with the given label: captraces = (Labels × capstates)∗.
τ maps each program P ∈ WOVEN and program state
p ∈ progstates to the capability trace that P generates in
an execution that starts from p (Fig. 5, Eqn. (1)). The trace
generated by P from a program state p is the trace that the
initial block of P generates in an execution that starts from
p, along with a ﬁxed initial woven state and capability state
(Fig. 5, Eqn. (2)).
The semantic function τb, given in Fig. 5, Eqns. (3)
and (4), deﬁnes the capability trace that a block generates
in an execution from a given state. Let a woven state be
a map from each weaving variable to an integer value:
wvstates = WVars → Z. Let a full state be a program-
state, woven-state, and capability-state triple: fullstates =
progstates × wvstates × capstates. Then τb deﬁnes the
capability trace generated by executing a given block from
a given full-state (Fig. 5, Eqn. (3)). The trace generated by
executing a block LABEL : s; t from a full state f is LABEL
paired with the capability state in f, followed by the trace
generated by executing the terminator instruction t starting
in the full-state obtained by updating f with the statement
s (Fig. 5, Eqn. (4)).
The terminator semantic function τt, given in Fig. 5,
Eqns. (5)–(7), deﬁnes the trace generated by executing a
block terminator from a given full-state f ∈ fullstates. The
terminator halt generates the empty trace (Fig. 5, Eqn. (6)).
The terminator br v ? LABELt : LABELf generates the trace
obtained by executing either the block labeled LABELt or
the block labeled LABELf from full-state f, depending on
whether v’s value is non-zero or zero, respectively (Fig. 5,
Eqn. (7)).
The statement semantic function σs, given in Fig. 5,
Eqns. (8)–(11), deﬁnes how a statement s ∈ stmt updates
a full-state f ∈ fullstates. If s is an assignment, then it
updates the program state in f according to the seman-
tics of the right-hand-side operation (Fig. 5, Eqn. (9)). In
Eqn. (9), the language semantics is denoted by the function
ιo : stmt → progstates → progstates, and omitted for
brevity. If s is a descriptor instruction, then it updates the
program and capability state in f according to the Capsicum
interpretation of descriptor instructions ιd (Fig. 5, Eqn. (10);
for a discussion of ιd, see §III-A3). If s is a weaving
instruction, then it updates the weaving and capability state
in f as deﬁned by the weaving-instruction semantic function
σw (Fig. 5, Eqn. (11)).
23
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 11:51:01 UTC from IEEE Xplore.  Restrictions apply. 
τ (cid:2)(block0,{block1, . . . , blockn})(cid:3)(p) = τb(cid:2)P, block0(cid:3)(p,∅, ci)
τ : WOVEN → progstates → captraces
τb : (WOVEN × block) → fullstates → captraces
τb(cid:2)P, LABEL : stmt; termin)(cid:3)(p, i, c) = (LABEL, c) :: τt(cid:2)P, termin(cid:3)(σs(cid:2)stmt(cid:3)(p, i, c))
τt : (WOVEN × termin) → fullstates → captraces
τt(cid:2)P, br v ? LABELt
τt(cid:2)P, halt(cid:3)(p, i, c) = 
: LABELf (cid:3)(p, i, c) = let dest = if p(v) (cid:6)= 0 then LABELt else LABELf in
τb(cid:2)labelblkP (dest)(cid:3)(p, i, c)
σs : stmt → fullstates → fullstates
σs(cid:2)v0 := op(v1, . . . , vn)(cid:3)(p, i, c) = (ιo(cid:2)v0 := op(v1, . . . , vn)(cid:3)(p), i, c)
σs(cid:2)dscinst(cid:3)(p, i, c) = let (p(cid:2), c(cid:2)) = ιd(cid:2)dscinst(cid:3)(p, c) in (p(cid:2), i, c(cid:2))
σs(cid:2)capinstr(cid:3)(p, i, c) = σw(cid:2)capinstr(cid:3)(i, c)
σw : capinstr → (wvstates × capstates) → (wvstates × capstates)
σw(cid:2)v0 := op(v1, . . . , vn)(cid:3)(i, c) = (ιo(cid:2)v0 := op(v1, . . . , vn)(cid:3)(i), c)
σw(cid:2)v ? capprim(cid:3)(i, c) = (i, if i(v) (cid:6)= 0 then ιp(cid:2)capprim(cid:3)(c) else c)
(1)
(2)
(3)
(4)
(5)
(6)
(7)
(8)
(9)
(10)
(11)
(12)
(13)
(14)
Semantics of WOVEN. τ, τb, and τt deﬁne the capability trace that a WOVEN program generates by executing a given program, block, or
Figure 5.
terminator instruction, respectively, from a given state. In the deﬁnition of τt, labelblkP maps each label to the instruction block that it labels. σs and
σw deﬁne how a program statement and woven instruction, respectively, update the state of a program. ιo and ιp denote the interpretation of program
operations and Capsicum primitives (Fig. 6), respectively). progstates, wvstates, capstates, and fullstates denote the spaces of program states, woven
states, capability states, and “full” program states, respectively (see §III-A2).
The woven-instruction semantic function σw, given in
Fig. 5, Eqns. (12)–(14), deﬁnes how a woven instruction
v ∈ wvinstrs updates a woven state w ∈ wvstates and a
capability state c ∈ capstates. If v stores the value of a
language operation in a woven-state variable, then the woven
state is updated according to the language semantics (Fig. 5,
Eqn. (13)). If the woven instruction is a guarded Capsicum
primitive v ? p, then if v is zero in w, v ? p does not update
the woven state, and otherwise, v ? p updates c according to
the Capsicum interpretation of primitive p (Fig. 5, Eqn. (14);
for a discussion of the interpretation of primitives ιp, see
§III-A3).
3) Capsicum Interpretation Functions: The semantics of
WOVEN (§III-A2) is deﬁned from (1) the space of capability
states maintained by Capsicum, (2) the initial capability
state with which a program executes, and (3) the Capsicum
interpretations, which deﬁne how program instructions and
Capsicum primitives update capability states. If the se-
mantics of Capsicum were to be extended or revised in
some way, these are the only pieces of information that
a Capsicum architect would have to modify to obtain an
updated version of capweave.
A capability state deﬁnes what capabilities are held by
a program (Fig. 6, Eqns. (15) and (16)). Let a process
capability state be a Boolean, denoting whether a process
has ambient authority,
together with a map from each
descriptor to a set of rights (Fig. 6, Eqn. (15)). A capability
state is a stack of process capability states (Fig. 6, Eqn. (16)).
The initial capability state ci is a singleton stack contain-
ing a process state denoting that the process has ambient
capability, and that the rights of no descriptors are deﬁned:
ci = [(True,∅)].
The Capsicum interpretation functions are given in Fig. 6.
The ﬁrst interpretation function ιd deﬁnes how each descrip-
tor instruction i ≡ d: x := open(y) (Fig. 6, Eqns. (17)
and (18)) updates a program state p ∈ progstates and
capability state c ∈ capstates (Fig. 6, Eqn. (17)). If the
program holds ambient authority in c, then i updates p so
that x holds a fresh descriptor, and updates c so that the fresh
descriptor has all access rights. Otherwise, i updates p so that
x holds the value −1, and the latest descriptor opened at d
is not mapped to any set of access rights (Fig. 6, Eqn. (18)).
The second interpretation function ιp (Fig. 6, Eqns. (19)
and (20)) speciﬁes how a Capsicum primitive p ∈ Capprims
updates a capability state c ∈ capstates (Fig. 6, Eqn. (19)).
If a program executes cap enter, then the program relin-
quishes ambient authority (Fig. 6, Eqn. (20)). If a program
invokes limitfd(d, R), then the program’s rights for the
last descriptor opened at d are updated to the intersection
of the program’s rights in c and the set of rights R (Fig. 6,
Eqn. (21)). If a program invokes fork, then the program
pushes a copy of the current process-capability state onto
the stack of process capability states (Fig. 6, Eqn. (22)).
If a program invokes join, then the program pops its top
process capability state pc, and updates the new top process
state in its capability state to have the descriptor rights in
pc (Fig. 6, Eqn. (23)).
Policy Semantics of WOVEN: A policy is a set of exe-
cutions of a program annotated with the capabilities that the
program must have as it executes. Although the capability
24
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 11:51:01 UTC from IEEE Xplore.  Restrictions apply. 
proccap = B × (Opens → P(Rights))
capstates = proccap
∗
ιd(cid:2)d : x := open(y)(cid:3)(p, r :: rs) = let (f d, R(cid:2)) = if ambcap(r) then (fresh(r), Rights) else (−1,⊥) in
ιd : dscinst → (progstates × capstates) → (progstates × capstates)
(p[x (cid:8)→ f d], (ambcap(r), rights(r)[d (cid:8)→ R(cid:2)]) :: rs)
ιp : capprim → capstates → capstates
ιp(cid:2)cap enter(cid:3)(r :: rs) = (False, rights(r)) :: rs
ιp(cid:2)limitfd(d, R)(cid:3)(r :: rs) = (ambcap(r), descrights(r)[d (cid:8)→ rs(r)(d) ∩ R]) :: rs
ιp(cid:2)fork(cid:3)(r :: rs) = r :: r :: rs
ιp(cid:2)join(cid:3)(r :: r(cid:2) :: rs) = (ambcap(r(cid:2)), descrights(r)) :: rs
(15)
(16)
(17)
(18)
(19)
(20)
(21)
(22)
(23)
Figure 6. Deﬁnition of the space of capability states and interpretation functions. proccap denotes the space of process states. In Eqn. (16), P(Rights)
denotes the power set of Capsicum access rights. capstates denotes the space of capability states. ιd and ιp denote the interpretations of descriptor
instructions and Capsicum primitives, respectively. In Eqns. (18), (21), and (23), ambcap(r) and descrights(r) denote the ambient-authority ﬂag and map
from descriptors to access rights, respectively, in process state r. In Eqn. (18), fresh(r) denotes a new descriptor value that is not bound in process state r.
state of a program completely deﬁnes the capabilities held
by a program as it executes, writing policies deﬁned by the
complete capability-state may be complicated or infeasible.
In particular, the Capsicum interpretation functions in Fig. 6
are deﬁned over capability states that are stacks of process
capability states, but practical policies are typically deﬁned
over only the currently executing process (i.e.,
the top
process on the stack of process capability states).
To bridge the gap between the capability state maintained
by Capsicum and the state used to deﬁne policies,
the
Capsicum architect deﬁnes a space of policy states polstates
and a policy-state abstraction α : capstates → polstates that
maps each capability state to the policy state that represents
it. Our implementation of capweave allows policies to
be deﬁned using the capabilities of the currently executing
process: polstates = proccap, and α(cur :: procs) = cur.
A policy-state abstraction α deﬁnes a policy-semantics
function that maps each woven program and initial program
state to the trace of program labels paired with policy states
that the program generates in an execution from the initial
program state. For poltraces = (Labels × polstates)∗, the
policy semantics function τα : WOVEN → (progstates →
poltraces) is
τα(cid:2)prog(cid:3)(p) = mα(τ (cid:2)prog(cid:3)(p))
where
mα() = 
mα((LABEL, c) :: t) = (LABEL, α(c)) :: mα(t)
4) Problem Deﬁnition: The policy-weaving problem is
to take an unwoven program and a policy, and weave
the program to satisfy the policy. We formally deﬁne the
weaving problem using the policy semantics of a program
and the deﬁnition of a weaving. To simplify the deﬁnition
of the policy-weaving problem, we ﬁx the deﬁnition of the
Capsicum interpretation functions, initial state, and policy-
state abstraction to be as deﬁned in Fig. 6 and §III-A2. The
25
deﬁnition of the program and policy semantics of WOVEN
programs is thus ﬁxed as well.
For an unwoven program P ∈ UNWOVEN and a woven
program P (cid:3) ∈ WOVEN, P (cid:3) is a weaving of P if P (cid:3) is
constructed by only adding woven instructions to P .
Defn. 1. For IMP statements s and s(cid:3), s(cid:3) is a weaving of s
if one of the following holds:
0; s(cid:3)
1 is a weaving of s.
0 is a weaving of s and s(cid:3)
s(cid:3) = s(cid:3)
1 and either s(cid:3)
sequence of woven instructions, or s(cid:3)
woven instructions and s(cid:3)
of statements s(cid:3)
s(cid:3)
1 is a weaving of s1.
• s is not a sequence of statements, and (1) s(cid:3) = s or (2)
1 is a
0 is a sequence of
• s is a sequence of statements s0; s1 and s(cid:3) is a sequence
1 where s(cid:3)
0; s(cid:3)
0 is a weaving of s0 and
n}) is a weav-
0,{block
(cid:3)
(cid:3)
(cid:3)
A program P (cid:3) = (block
1, . . . , block
ing of a program P = (block0,{block1, . . . , blockn}) if
for each 0 ≤ i ≤ n, blocki = LABELi
: si; ti and
block
(cid:3)
i = LABELi : s(cid:3)
i is a weaving of si.
i; ti, where s(cid:3)
The policy-weaving problem is to take an unwoven pro-
gram and a policy deﬁning the allowed executions of the
program, and instrument the program so that it satisﬁes the
policy.
Defn. 2. Let P ∈ UNWOVEN be an unwoven program, and
let Q ⊆ captraces be a regular language of capability traces.
For a woven program P (cid:3), let the traces of P (cid:3), denoted as
T (P (cid:3)) ⊆ captraces, be the set of capability traces generated
by some input to the program: T (P (cid:3)) = {τα(cid:2)P (cid:3)(cid:3)(i) | i ∈
(Vars → Z)}. A solution to the policy-weaving problem