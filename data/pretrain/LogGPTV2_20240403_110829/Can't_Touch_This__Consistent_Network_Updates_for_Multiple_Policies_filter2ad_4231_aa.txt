title:Can't Touch This: Consistent Network Updates for Multiple Policies
author:Szymon Dudycz and
Arne Ludwig and
Stefan Schmid
2016 46th Annual IEEE/IFIP International Conference on Dependable Systems and Networks
Can’t Touch This:
Consistent Network Updates for Multiple Policies
Szymon Dudycz1 Arne Ludwig2
Stefan Schmid2,3
1 University of Wroclaw, Poland
2 Technical University Berlin, Germany
3 Aalborg University, Denmark
Abstract—Computer networks such as the Internet or data-
center networks have become a a crucial infrastructure for many
criticial services. Accordingly, it is important that such networks
preserve correctness criteria, even during transitions from one
correct conﬁguration to a new correct conﬁguration. This paper
initiates the study of how to simultaneously update multiple
routes in a Software-Deﬁned Network (SDN) in a transiently
consistent and efﬁcient manner. In particular, we study the
problem of minimizing the number of switch interactions, in
this paper also called “touches”. Our main result is a negative
one: we rigorously prove that jointly optimizing multiple route
updates in a consistent and efﬁcient manner is N P-hard, already
for two routing policies. However, we also present an efﬁcient,
polynomial-time algorithm that, given correct update schedules
for individual policies, computes an optimal global schedule with
minimal touches.
I.
INTRODUCTION
The availability and protection of computer networks such
as the Internet or datacenter (cloud) networks, is becoming
a national and world-wide concern of high priority. Already
today, many individuals and organizations need to place great
reliance on the services of computer networks. At the same
time, the Internet core suffers from ossiﬁcation, and has hardly
evolved over the last decades. Despite the huge success of the
Internet in the past, the increased dependability requirements
raise concerns whether today’s network protocols will be
sufﬁcient in the future [3].
Software-deﬁned networking is
an interesting new
paradigm which promises to overcome the Internet ossiﬁ-
cation. A Software-Deﬁned Network (SDN) outsources and
consolidates the control over multiple data-plane elements
to a centralized software program, enabling fast innovations
while supporting formal veriﬁability through a simple match-
action paradigm. Especially the trafﬁc engineering ﬂexibilities
introduced by SDN [1], [14] as well as the potentially more
scalable network virtualization [6], [16] have received much
attention over the last years.
However, while a programmatic, logically centralized net-
work control
is appealing, exploiting the introduced ﬂexi-
bilities and operating an SDN in a consistent and efﬁcient
manner is non-trivial. In particular, an SDN still needs to be
regarded as a distributed system, posing many challenges [5],
[8], [17], [23], [25], [31], [37], [38]. Several of these challenges
are due to the asynchronous communication channel between
switches and controller, which exhibits non-negligible and
varying delays [37], [43].
A fundamental problem which has recently received much
attention regards the consistent update of network routes [8],
[22], [25], [37], [42]. A particularly interesting approach to
solve the update problem is to proceed in rounds [22], [25]: in
each round, a “safe subset” of switches is updated, such that,
independently of the times and order in which the updates of
this round take effect, the network is always consistent. The
scheme can be implemented as follows: After the switches of
round t have conﬁrmed the successful update (e.g., using ac-
knowledgments [17]), the next subset of switches for round t+1
is scheduled. The appeal of this round-based approach is that it
does not require packet tagging (which comes with overheads
in terms of header space and also introduces challenges in
the presence of middleboxes [44] or multiple controllers [5])
or additional TCAM entries [5], [37] (which is problematic
given the fast table growth both in the Internet as well as in the
highly virtualized datacenter [4]). Moreover, this approach also
allows (parts of the) paths to become available sooner [25].
However, so far research focused on devising network
update schemes for a single policy: for scenarios where a single
route [22], [37], or all (destination-based) routes to a single
destination [25] need to be updated. However, especially in
large and dynamic networks, it is likely that multiple routes
have to be updated simultaneously [35]. For example, consider
a wireless network where users arrive in groups (e.g., at a
train station), or a Content Distribution Network where trafﬁc
is reassigned to servers in batches [10]. It is well-known that
updating a switch and its datastructures comes at a certain
cost [43], [27], and it is useful to batch updates [18].
loop-freedom [22], [25]:
Our Contributions: This paper initiates the study of how
to jointly optimize the update of multiple routing policies
(i.e., multiple complete source-destination paths) in a tran-
siently consistent (namely loop-free) yet efﬁcient manner.
In particular, we consider a most fundamental consistency
requirement,
loops are known to
harm the dependability of a network, due to packet drops,
TCP packet reorderings, etc. Accordingly, there exist several
RFCs and standards [39] on loop-free layer-2 spanning tree
constructions [36], on avoiding microloops in MPLS [32], on
loop-free IGP migration [7], etc. We in this paper aim to devise
loop-free update algorithms for multiple policies in SDNs,
such that the number of switch interactions, called touches,
is minimized.
We show that the network update problem features inter-
esting connections to Directed Feedback Vertex Set, Short-
est Common Supersequence (SCS), Supersequence Run prob-
lems [28]. Our main result
is a negative one: we prove
that
the problem is computationally hard, already for two
policies which by themselves can be updated in two rounds,
by a rigorous reduction from Max-2SAT [19]. We complement
this negative result by presenting an optimal polynomial-time
algorithm to combine consistent update schedules computed
978-1-4673-8891-7/16 $31.00 © 2016 IEEE
DOI 10.1109/DSN.2016.21
133
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 09:17:41 UTC from IEEE Xplore.  Restrictions apply. 
for individual policies (e.g., using any existing algorithm,
e.g., [22], [25]), into a global schedule guaranteeing a minimal
number of touches.
Organization: The remainder of this paper is organized as
follows. Section II introduces preliminaries and presents our
formal model. In Section III, we present proofs for the com-
putational hardness. Section IV describes optimal polynomial-
time algorithms under the assumption that only one switch is
updated per round. After reviewing related work in Section V,
we conclude in Section VI.
II. MODEL
We are given a network which is controlled by a (logically)
centralized software (the so-called controller) which communi-
cates forwarding rule updates to the switches (the nodes), over
an asynchronous but reliable channel. Due to this asynchrony,
we require the controller to send out simultaneous updates only
to a “safe” subset of nodes: the correctness of the network
conﬁguration is always preserved independently of the order
in which these updates take effect at the switches. Only after
these updates have been conﬁrmed (acked), the next subset is
updated.
1
2
1
is the old
1 , π(i)
and π(i)
2 ), where π(i)
The controller needs to simultaneously update k routing
policies, deﬁned over a set U of n=∣U∣ to-be-updated nodes.
Each policy update is a pair (π(i)
is the new route of the i-th policy, i ∈ [1, k].
route and π(i)
Both π(i)
are simple directed paths, for any i. In
other words, packets of policy i are initially forwarded, using
the old rules, henceforth also called old edges (often indicated
with solid edges in the ﬁgures), along π(i)
1 , and eventually
they should be forwarded according to the new rules of π(i)
(dashed edges). W.l.o.g. [22], we will assume that both the
old as well as the new path of the i-th update have the same
source si and the same destination di.
2
2
We will assume that the k routing policies are deﬁned
over independent parts of the header space [33], i.e., packets
of different ﬂows are forwarded according to different (and
non-aggregated) rules. However, multiple routes may include
the same nodes. Accordingly, as we will see, when reasoning
about consistency, we can focus on the correct update of
different policies individually; however, for efﬁciency, we will
coordinate the updates to shared nodes, to minimize the node
interactions.
Packets should never be delayed or dropped at a node:
whenever a packet arrives at a node, a matching forwarding
1 (v)
rule should be present. Let, for each node v ∈ V , out(i)
1 (v)) denote the outgoing (resp. incoming) edge
(resp. in(i)
2 (v)) denote
2 (v) (resp. in(i)
according to policy π(i)
the outgoing (resp. incoming) edge according to policy π(i)
2 .
j (v), for j ∈ {1, 2}, and
Moreover,
let us extend these deﬁnitions for entire node
sets S, i.e., out(i)
analogously, for in(i)
1 , and out(i)
j (S) = ⋃v∈S out(i)
.
j
Let U (i) be the set of to-be-updated nodes for the i-th pol-
icy. We want to assign each update in U (i) to a round, such that
the resulting schedule fulﬁlls certain consistency properties.
That is, we want to ﬁnd an update schedule U (i)
2 , . . .,
1 , U (i)
134
1 , π(1)
2 ) in black, at the bottom update (π(2)
update (π(1)
2 )
Fig. 1: Example with two concurrent policy updates: at the top
1 , π(2)
in orange. The old policies (π(1)
1 ) are drawn using
solid lines, the new policies (π(1)
2 ) using dashed lines.
At least one node cannot install both updates simultaneously
without creating a loop, and hence, needs two rounds of
interactions (touches).
and π(2)
and π(2)
1
2
t
t′
2 ⊍ . . .⊍ U (i)
t ⊆ U (i) where the subsets form
a partition of U (i) (i.e., U (i) = U (i)
1 ⊍ U (i)
i.e., a sequence of subsets U (i)
ri ), with
the property that for any round t, given that the updates U (i)
for t′ t etc. be deﬁned analogously. Since updates
nodes X ⊆ U (i)
during round t occur asynchronously, an arbitrary subset of
t ∖ X still use the old rules, resulting in a
nodes X = U (i)
t may already have been updated while the
temporary forwarding graph Gt(U (i), X, Et) over nodes U (i)
for this policy, where Et = out(i)
t ∪X)∪out(i)
1 , U (i)
2 (U (i)
2 , . . . , U (i)
ri
fulﬁlls
t
2