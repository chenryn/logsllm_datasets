title:Hybrid Analysis and Control of Malware
author:Kevin A. Roundy and
Barton P. Miller
Hybrid Analysis and Control of Malware
Kevin A. Roundy and Barton P. Miller
Computer Sciences Department
{roundy,bart}@cs.wisc.edu
University of Wisconsin
Abstract. Malware attacks necessitate extensive forensic analysis ef-
forts that are manual-labor intensive because of the analysis-resistance
techniques that malware authors employ. The most prevalent of these
techniques are code unpacking, code overwriting, and control transfer
obfuscations. We simplify the analyst’s task by analyzing the code prior
to its execution and by providing the ability to selectively monitor its
execution. We achieve pre-execution analysis by combining static and
dynamic techniques to construct control- and data-ﬂow analyses. These
analyses form the interface by which the analyst instruments the code.
This interface simpliﬁes the instrumentation task, allowing us to reduce
the number of instrumented program locations by a hundred-fold relative
to existing instrumentation-based methods of identifying unpacked code.
We implement our techniques in SD-Dyninst and apply them to a large
corpus of malware, performing analysis tasks such as code coverage tests
and call-stack traversals that are greatly simpliﬁed by hybrid analysis.
Keywords: malware analysis, forensics, hybrid, de-obfuscation, packed
code, self-modifying code, obfuscated code.
1 Introduction
Malicious software infects computer systems at an alarming rate, causing eco-
nomic damages that are estimated at more than ten billion dollars per year [1].
Immediately upon discovering a new threat, analysts begin studying its code to
determine damage done and information extracted, and ways to curtail its im-
pact; analysts also study the malware so they can recover infected systems and
construct defenses. Thus, a primary goal of malware authors is to make these
tasks as diﬃcult and resource intensive as possible. This explains why 90% of
malware binaries employ analysis-resistance techniques [9], the most prevalent of
which are the run-time unpacking of compressed and encrypted code, run-time
modiﬁcations to existing code, and obfuscations of control transfers in the code.
Security companies detect thousands of new malware samples each day [45], yet
despite the importance and scale of this problem, analysts continue to resort to
manual-labor intensive methods.
Analysts accomplish their tasks by studying the malware’s overall structure
to identify the relevant code and then analyzing it thoroughly. Unfortunately,
analysis-resistance techniques force the analyst out of the usual mode of binary
S. Jha, R. Sommer, and C. Kreibich (Eds.): RAID 2010, LNCS 6307, pp. 317–338, 2010.
c(cid:2) Springer-Verlag Berlin Heidelberg 2010
318
K.A. Roundy and B.P. Miller
analysis, which involves statically analyzing the binary prior to instrumenting
regions of interest and performing a controlled execution of the program. Instead,
the analyst must execute the malicious code to analyze it, as static analysis
can fail to analyze dynamically generated, modiﬁed, and obfuscated code. The
analyst must therefore construct a virtual environment that allows the malware
to interact with other hosts and that is suﬃciently convincing that the malware
will display its normal behavior while executing in isolation from the outside
world. Many analysts prefer the analyze-then-execute model and therefore resort
to expending considerable manual eﬀort to strip analysis-resistance features from
malicious binaries [12,40].
The goal of our research is to simplify malware analysis by enabling a return to
the traditional analyze-then-execute model, which has the beneﬁt of bringing the
malicious code under the analyst’s control before it executes. We address these
goals by combining static and dynamic techniques to construct and maintain
the control- and data-ﬂow analyses that form the interface through which the
analyst understands and instruments the code. A key feature of our approach
is its ability to update these analyses to include dynamically unpacked and
modiﬁed code before it executes. Our work makes the following contributions:
– Pre-execution analysis and instrumentation makes it possible for the analyst
to control the execution of malicious code. For example, our work allows
interactions with other infected hosts to be simulated through instrumenta-
tion’s ability to patch the program, removing the need for complex virtual
environments involving multiple hosts. Additionally, our work can comple-
ment a virtualization strategy by identifying and disabling the malware’s
attempts to detect its virtual-machine environment [36].
– We give the analyst the ability to instrument malware intuitively and eﬃ-
ciently by providing data-ﬂow analysis capabilities and a control ﬂow graph
(CFG) as an interface to the code. For example, the CFG allows us to ﬁnd
transitions to dynamically unpacked code by instrumenting the program’s
statically unresolved control transfers (see Section 5). By contrast, prior
instrumentation-based unpacking tools did not maintain a CFG and there-
fore had to monitor all of the program’s control transfers and memory writes
to detect the execution of code that is written at run-time [23,41]. We achieve
a hundred-fold reduction in the number of monitored program locations.
– Our structural analysis allows analysts to be selective in the components
they monitor, the operations in those components that they select, and in
the granularity of data they collect. Current tools that can monitor analysis-
resistant malware do not provide ﬂexible instrumentation mechanisms; they
trace the program’s execution at a uniform granularity, either providing ﬁne-
grained traces at the instruction or basic-block level [17,36], or coarse grained
traces (e.g., at interactions with the OS) [52]. These tools either bog the
analyst down with irrelevant information (a signiﬁcant problem for inexpe-
rienced analysts [42]), or can only give a sketch of the program’s behavior.
– By combining static and dynamic techniques we allow the analyst to ﬁnd and
analyze code that is beyond the reach of either static or dynamic analysis
Hybrid Analysis and Control of Malware
319
alone, thereby providing a fuller understanding of the malware’s possible
behavior. Prior combinations of static and dynamic analysis only operate on
non-defensive code, and only ﬁnd and disassemble the code [34] or produce
their analysis results only after the program has fully executed [28].
Analysts have controlled and monitored malicious code either by executing the
malware in a process that they control through the debugger interface [44], or by
executing the malware in a virtual machine [36]. There are advantages to both
approaches. The debugger approach makes it easy to collect process information
and intercept events, and allows for the creation of lightweight tools that do
not have to worry about anti-emulation techniques [36]. Among the beneﬁts of
virtual machines are that they isolate the underlying system from the malware’s
eﬀects, they provide the ability to revert the machine to a clean state or to
a decision point, and allow for stealthy monitoring of the program’s execution
[17,36]. While in this paper we demonstrate an instrumentation and analysis tool
that executes malicious processes through the debugger interface, our techniques
are orthogonal to this choice and beneﬁt both scenarios. For example, in the
former case, pre-execution analysis and control allows the analyst to limit the
damage done to the system, while the latter case beneﬁts from the ability to
detect and disable anti-emulation techniques.
Our analysis and instrumentation tool is not the ﬁrst to analyze code prior to
its execution (e.g., Dyninst [22], Vulcan [48]), but existing tools rely exclusively
on static analysis, which can produce incomplete information even for binaries
that are generated by standard compilers. Despite recent advances in identi-
fying functions in stripped compiler-generated binaries, on the average, 10% of
the functions generated by some compilers cannot be recognized by current tech-
niques [43], and even costly dataﬂow analyses such as pointer aliasing may be
insuﬃcient to predict the targets of pointer-based control transfers [5,21].
Most malware binaries make analysis and control harder by employing the
analysis-resistance techniques of code packing, code overwriting, and control
transfer obfuscations. Code packing techniques, wherein all or part of the bi-
nary’s malicious code is compressed (or encrypted) and packaged with code that
decompresses the malicious payload into the program’s address space at run-
time, are present in 75% of all malware binaries [8,50]. Dealing with dynamic
code unpacking is complicated by programs that unpack code in stages, by the
application of multiple code-packing tools to a single malicious binary, and by
a recent trend away from well-known packing tools, so that most new packed
binaries use custom packing techniques [9,10].
To further complicate matters, many packing tools and malicious programs
overwrite code at run-time. While code unpacking impacts static analysis by
making it incomplete, code overwriting makes the analysis invalid and incom-
plete. A static analysis may yield little information on a self-modifying program,
as potentially little of the code is exposed to analysis at any point in time [2].
Malware often uses control-transfer obfuscations to cause static analysis algo-
rithms to miss and incorrectly analyze large swaths of binary code. In addition to
the heavy use of indirect control transfers, obfuscated binaries commonly include
320
K.A. Roundy and B.P. Miller
non-conventional control transfer sequences (such as the use of the return instruc-
tion as an indirect jump), and signal- and exception-based control transfers [18].
Additionally, malicious binaries and packers often contain hand-written assem-
bly code that by its nature contains more variability than compiler-generated
code, causing problems for most existing code-identiﬁcation strategies, as they
depend on the presence of compiler-generated instruction patterns [24,43].
We analyze binaries by ﬁrst building a CFG of the binary through static pars-
ing techniques. As the binary executes, we rely on dynamic instrumentation and
analysis techniques to discover code that is dynamically generated, hidden by ob-
fuscations, and dynamically modiﬁed. We then re-invoke our parsing techniques
to update our CFG of the program, identifying the new code and presenting
the updated CFG to the analyst. The structural information provided by our
analysis allows us to discover new code by instrumenting the program lightly,
only at control transfer instructions whose targets cannot be resolved through
static analysis, making our tool’s execution time comparable to that of existing
unpacking tools despite the additional cost that we incur to provide an updated
CFG. (see Section 8).
Other analysis resistance techniques that can be employed by malicious
program binaries include anti-debugging checks, anti-emulation checks, timing
checks, and anti-tampering (e.g., self-checksumming) techniques. Since our cur-
rent implementation uses the debugger interface, we have neutralized the com-
mon anti-debugging checks [18]. In practice, anti-debugging and timing checks
leave footprints that are evident in our pre-execution analysis of the code and
that the analyst can disable with the instrumentation capabilities that we pro-
vide. Our research is investigating multiple alternatives for neutralizing the eﬀect
of anti-tampering techniques, but this work is beyond the scope of this paper.
We proceed by discussing related work in Section 2 and we give an overview
of our techniques and algorithm in Section 3. Our code-discovery techniques
are described in Sections 4-7. In Section 8 we show the utility of our approach
by applying our tool to analysis-resistant malware, and to synthetic samples
produced by the most prevalent binary packing tools. We conclude in section 9.
2 Related Work
Our work is rooted in the research areas of program binary analysis, instrumen-
tation, and unpacking.
Analysis. Static parsing techniques can accurately identify 90% or more of the
functions in compiler-generated binaries despite the lack of symbol information
[43], but are much worse at analyzing arbitrarily obfuscated code [24,51], and
cannot analyze the packed code that exists in most malicious binaries [9]. Thus,
most malware analysis is dynamic and begins by obtaining a trace of the pro-
gram’s executed instructions through single-step execution [17], dynamic instru-
mentation [41], or the instrumentation capabilities of a whole-system emulator
[32]. The resulting trace is used to construct an analysis artifact such as a vi-
sualization of the program’s unpacking behavior [42], a report of its operating
Hybrid Analysis and Control of Malware
321
system interactions [6], or a representation that captures the evolving CFG of
a self-modifying program [4]. As these analysis artifacts are all produced after
monitoring the program’s execution, they are potential clients of our analysis-
guided instrumentation techniques rather than competitors to them.
Madou et al. [28] and Cifuentes and Emmerik [13] combine static and dynamic
techniques to identify more code than is possible through either technique alone.
Madou et al. start from an execution trace and use control-ﬂow traversal parsing
techniques to ﬁnd additional code, whereas Cifuentes and Emmerik start with
speculative static parsing and use an instruction trace to reject incorrect parse
information. Their hybrid approaches to CFG-building are similar to ours in
spirit, but they analyze only code that is statically present in the binary as they
lack the ability to capture dynamically unpacked and overwritten code.
Instrumentation. Existing tools that provide analysis-guided binary instru-
mentation [22,49,48] cannot instrument code that is obfuscated, packed, or self-
modifying, as their code identiﬁcation relies exclusively on static analysis. Our
tool uses Dyninst’s [22] dynamic instrumentation and analysis capabilities, up-
dating its analysis of the code through both static and dynamic code-capture
techniques, prior to the code’s execution.
The BIRD dynamic instrumenter [34] identiﬁes binary code by augmenting
its static parse with a run-time analysis that ﬁnds code by instrumenting control
transfers that could lead to unknown code areas. BIRD works well on compiler-
generated programs, but does not handle self-modifying programs and performs
poorly on programs that are packed or obfuscated, as it is not optimized for ex-
tensive dynamic code discovery (it uses trap instructions to instrument all return
instructions and other forms of short indirect control transfers that it discovers
at runtime). BIRD also lacks a general-purpose interface for instrumentation
and does not produce analysis tools for the code it identiﬁes.
Other dynamic instrumentation tools forgo static analysis altogether, instead
discovering code as the program executes and providing an instruction-level in-
terface to the code (e.g., PIN [27], Valgrind [7]). These tools can instrument
dynamically unpacked and self-modifying code, but do not defend against
analysis-resistance techniques [18]. As with BIRD, the lack of a structural anal-
ysis means that it is diﬃcult to selectively instrument the code and that it may
not be possible to perform simple-sounding tasks like hooking a function’s return
values because compiler optimizations (and obfuscations) introduce complexities
like shared code, frameless functions, and tail calls in place of return statements.
Unpacking. The prevalence of code packing techniques in malware has driven
the creation of both static and dynamic approaches for detecting packed mali-
cious code. Some anti-virus tools (e.g., BitDefender [8]) create static unpackers
for individual packer tools at signiﬁcant expense, but this approach will not scale
with the explosive growth rate of new packing approaches [9,35]. Anti-virus tools
also employ “X-Ray” techniques that can statically extract the packed contents
of binaries that employ known compression schemes or weak encryption [37].
Coogan et al. [15] use static analysis to extract the unpacking routine from a
322
K.A. Roundy and B.P. Miller
packed binary and then use the extracted routine to unpack it. These static ap-
proaches are unsuccessful when confronted with malware that employs multiple
packing layers (e.g., Rustock [12]), and Coogan et al.’s static techniques are also
unable to deal with heavily obfuscated code [33,46].
Most dynamic unpacking tools take the approach of detecting memory loca-
tions that are written to at run-time and later executed as code. OmniUnpack
[30], Saﬀron [41], and Justin [20] approach the problem at a memory-page gran-
ularity by modifying the operating system to manipulate page write and execute
permissions so that both a write to a page and a subsequent execution from that
page result in an exception that the tool can intercept. This approach is eﬃcient
enough that it can be used in an anti-virus tool [30], but it does not identify
unpacked code with much precision because of its memory-page granularity.
Other unpackers identify written-then-executed code at a byte level by tracing
the program’s execution at a ﬁne granularity and monitoring all memory writes.
EtherUnpack [17] and PolyUnpack [44] employ single-step execution of the bi-
nary, whereas Renovo [23] and “Saﬀron for Intel-PIN” [41] use the respective
instruction-level instrumentation capabilities of the Qemu whole-system emula-
tor [7] and the PIN instrumenter [27]. By contrast, our analysis-guided instru-
mentation allows us to unpack and analyze program binaries with a hundred-fold
reduction in instrumented program locations and comparable execution times.
3 Technical Overview
Our hybrid algorithm combines the strengths of static and dynamic analysis. We
use static parsing techniques to analyze code before it executes, and dynamic
techniques to capture packed, obfuscated, and self-modifying code. Hybrid anal-
ysis allows us to provide analysis-guided dynamic instrumentation on analysis-
resistant program binaries for the ﬁrst time, based on the following techniques:
Parsing. Parsing allows us to ﬁnd and analyze binary code by traversing stati-
cally analyzable control ﬂow starting from known entry points into the code. No
existing algorithm for binary code analysis achieves high accuracy on arbitrarily
obfuscated binaries, so we create a modiﬁed control-ﬂow traversal algorithm [47]
with a low false-positive rate. Our initial analysis of the code may be incomplete,
but we can fall back on our dynamic capture techniques to ﬁnd new entry points
into the code and use them to re-seed our parsing algorithm.
Dynamic Capture. Dynamic capture techniques allow us to ﬁnd and analyze
code that is missed by static analysis either because it is not generated until
run-time or because it is not reachable through statically analyzable control ﬂow.
Our static analysis of the program’s control ﬂow identiﬁes control transfer in-
structions that may lead to un-analyzed code; we monitor these control transfers
using dynamic instrumentation, thereby detecting any transition to un-analyzed
Hybrid Analysis and Control of Malware
323
1. Load the program into memory, paused at its entry point
2. Remove debugging artifacts
3. Parse from known entry points
4. Instrument newly discovered code
5. Resume execution of the program
6. Handle code discovery event, adding new entry points
7. Goto 3
Fig. 1. Algorithm for binary code discovery, analysis, and instrumentation