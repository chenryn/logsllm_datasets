the API summary of getResources and getString (lines
37-38). Next, we compute the value of v0 (line 17-21), v1,
this.val$conStr, and ﬁnally the value of v0 at line 31.
C. Vulnerability Identiﬁcation
After obtaining the keys identiﬁed by LeakScope, next
we would like to detect data leakage vulnerabilities in the
cloud services. The detection is cloud speciﬁc, and we have
designed the following algorithms to detect key misuses and
permission misconﬁgurations for services that use Azure,
AWS, and Firebase.
(I) Detecting Key Misuses in Azure (Storage and Notiﬁca-
tion Hub). As discussed in §III-A, if there are root keys or
full access keys in mobile apps, then an attacker can easily use
these keys to leak data. Therefore, we do not need to probe the
back-end to conﬁrm the vulnerabilities. As long as we identify
root keys or full access keys in a mobile app, we know the
cloud service is vulnerable.
(II) Detecting Key Misuses in AWS. An AWS root key
has full access to the corresponding AWS account, which
means all resources under that account can be accessed
by an adversary if we identify a root key in an app. We
found that a root key has the permission to get some
AWS instance information with the following rest API:
https://ec2.amazonaws.com/?Action=Describe
Instances&InstanceId.1=X, where X is the ID of
the target instance. In contrast, an app key does not have
this permission. Therefore, to detect key misuses in AWS,
we set X to be a nonexistent ID. When we send a request
alone with the key identiﬁed, we will receive the error
message “InvalidInstanceID” if the key is a root key
or “UnauthorizedOperation” if the key is an app key.
(III) Detecting Permission Misconﬁguration in Firebase.
There are two typical permission misconﬁguration rules as
shown in Figure 5: (a) no authentication check (the database
is entirely open to anyone), and (b) no permission check
(only checks whether the user is authenticated). We use the
following algorithms to detect them:
• Detecting “Open” Database. When a developer mistak-
enly speciﬁes a read policy as “.read”: “true”, then
anyone can read the database. Firebase provides a REST
API to access data from the database in a given “path”.
By setting the “path”, a user can read speciﬁc data. If we
set “path” to “root”, then we can read the entire database.
However, we do not have to read the entire database, as
Firebase supports queries with the indexon ﬁeld. If we
set this ﬁeld to a nonexistent value when attempting to
read the “root” path, no data will leak, but we can still
conﬁrm the data leaks as the returned error message is
different when the user has root read permissions.
in order
• Detecting No Permission Check. When a data record
read policy is “.read”: “auth != null”, we must
use an authenticated user
to perform the
indexon-based leakage testing. It would be a huge
engineering challenge to register a legitimate user in each
corresponding cloud service. Fortunately, we noticed that
Firebase also provides a number of cloud APIs for user
registration, e.g., by using email/password, phone number,
Google/Facebook SSO, etc., in addition to developer cus-
tomized registration methods. We therefore can directly
invoke these Firebase APIs to register legitimate users
in the corresponding service if the tested app has used
them. After that, we authenticate the registered user and
then perform the indexon-based test.
(IV) Detecting Permission Misconﬁguration in AWS. AWS
keys are used to access the speciﬁed resources under particular
access control policies. In AWS, there are several types of
resources. Among these resources, we only focus on the
detection of permission misconﬁguration of S3 Storage. Note
that several recent high proﬁle data leaks (e.g., [33]) were from
S3. To perform our test, we have to collect not only AWS keys,
but also the S3 Storage names. Therefore, we have to apply
our string value analysis for both of them. With the identiﬁed
AWS keys and storage names, we directly invoke an AWS API
HEAD Bucket [9] to verify whether a key has permission
to access the storage or not. If so, a data leak is detected.
D. Implementation
We have implemented LeakScope1 atop dexlib2 [6]
and soot [16]. In particular, to implement our Cloud API
Identiﬁcation, we leverage dexlib2, a lightweight APK static
analysis framework that allows easily parsing of dex ﬁles to
build function signatures. We build our String Value Analysis
atop Soot, a powerful framework for analyzing Java bytecode
with particularly useful features such as data ﬂow analysis.
The Vulnerability Identiﬁcation is quite straightforward; we just
wrote a python script
to send the requests and parse the
1The source code of LeakScope is made available at https://github.com/
OSUSecLab/LeakScope.
1303
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:40:50 UTC from IEEE Xplore.  Restrictions apply. 
w/ Cloud API
w/ AWS only
w/ Azure only
w/ Firebase only
w/ AWS & Azure
w/ AWS & Firebase
w/ Azure & Firebase
w/ Three Services
Total
#Apps
107,081
4,799
899
99,186
3
1,973
210
11
Non-Obfuscated
Obfuscated
% #Apps
% #Apps
-
85,357
4.48
0.84
92.63
0.00
1.84
0.20
0.01
4,548
720
78,475
2
1,427
174
11
79.71
5.33
0.84
91.94
0.00
1.67
0.20
0.01
21,724
251
179
20,711
1
546
36
0
%
20.29
1.16
0.82
95.34
0.00
2.51
0.17
0.00
Table IV: Result of Our Cloud API Detection.
response. In total, LeakScope consists of around 6, 000 lines
of our own Python and Java code.
VI. EVALUATION
In this section, we present our evaluation result. We ﬁrst
describe our experiment setup including how we collect the
mobile apps in §VI-A, describe our detailed result in §VI-B,
and ﬁnally provide an analysis of the identiﬁed vulnerabilities
and the false positives of our approach in §VI-C.
A. Experiment Setup
Collecting the Mobile Apps. We focus on the Android apps
published in Google Play. To obtain an app from Google
Play, we have to provide the app package name. As such,
we ﬁrst developed a python script atop the scrapy [14]
framework to crawl for each app package name. After two
weeks of crawling, we retrieved about 1.9 million app names
in May 2017. Then we crawled the entire package contents of
1, 609, 983 free Android apps within two months. Note that
we could not download all 1.9 million apps due to restrictions
such as paid apps or certain apps only being available in certain
countries. In total, these 1.6 million mobile apps consumed
15.42 TB of space on our hard drive.
Environment Setup. Our experiments were conducted on
seven workstations, each equipped with Intel Xeon E5-2640
CPU with 24 cores and 96 GB memory and running Ubuntu
16.04. We do not need any real mobile devices since
LeakScope is mostly a static analysis tool, and only the
Vulnerability Identiﬁcation component needs to communicate
with the cloud servers using dynamic analysis. All of our
experimental data including the target apps and intermediate
results are stored in a Network Attached Storage with
34.90TB hard drive space.
B. Experiment Result
In
total
6, 894.89
spent
LeakScope
single CPU
computation hours analyzing these 1, 609, 983 apps, which
consumes 2.56 TB of storage for storing the intermediate
results. Among the tested apps, eventually LeakScope detected
15, 098 unique mobile apps (with 17, 299 vulnerabilities in
total), whose cloud servers are subject to data leakage attacks.
In the following, we present detailed results based on how
each component of LeakScope performs.
1) Cloud API Identiﬁcation: We ﬁrst evaluated our
Identiﬁcation with the tested 1, 609, 983 apps.
Cloud API
Since our approach is obfuscation-resilient, it clearly works
for non-obfuscated apps as well. In total, our Cloud API
Identiﬁcation generated 39, 617, 809, 277 function signatures
and identiﬁed 107, 081 mobile apps that used some of the
32 cloud APIs of our interest. Among these apps, 21, 724
of them (20.29%) are obfuscated. Therefore, as reported
in Table IV, we separated our experimental results into two
sets: apps without obfuscation (85, 357 apps), and apps with
obfuscation, in order to understand whether obfuscated apps
provide better protection against data leakage attacks.
We also reported the detailed distributions of the cloud
services used by the mobile apps. In particular, among these
107, 081 apps, 4, 799 (4.48%) exclusively use Amazon AWS,
899 (0.84%) exclusively use Microsoft Azure, and 99, 186
(92.63%) exclusively use Google Firebase. There are also 3
apps that use both AWS and Azure, 1, 973 with AWS and
Firebase, and 210 with Azure and Firebase. Interestingly,
there are also 11 apps that use all three cloud services. The
detailed breakdown for non-obfuscated and obfuscated apps
are reported from the 4th to 7th column, respectively.
It is quite surprising that the vast majority (over 90%) of the
mobile apps actually used Google Firebase for their back-end
services, at least according to the results reported in Table IV.
We consulted with the Google Firebase team when we made
our responsible disclosure. They informed us that part of the
reason for this is that there may be a signiﬁcant portion of
mobile apps that have used Amazon’s or Microsoft’s clouds,
but not their mBaaS clouds (e.g., they may use their IaaS
clouds instead). Our mBaaS cloud API Identiﬁcation cannot
identify these clouds.
2) String Value Analysis: Among the 107, 081 apps, our
String Value Analysis statically computed 631, 551 strings of
the parameters of our interest, and our detailed performance
results are reported in Table V. In particular, we report the
string parameters of our interest in the 2nd column, followed
by the corresponding APIs to which each string parameter
belongs in the 3rd column (the original deﬁnition of these
APIs is presented in Table III and Table IX in the Appendix).
Then for both non-obfuscated and obfuscated apps, we report
how many of the corresponding APIs were called in the 4th
and 8th columns, how many apps have called these APIs in
the 5th and 9th columns, how many of the parameter strings
had their values eventually resolved in the 6th and 10th, and
the corresponding percentages in the 7th and 11th columns.
We can observe from Table V that we are interested in a
parameter called bucketName from 2 different sets of APIs
in AWS. This is because we need bucketName to locate
the corresponding S3 storage for authorization vulnerability
veriﬁcation. We are also interested in identityPoolId,
which is used to detect
the permission misconﬁguration
vulnerability in AWS, and accessKey and secretKey are
also clearly of direct interest. For Azure, we are interested in
parameters appURL, connectionString, and appKey.
For Firebase, we are interested in google_app_id,
google_api_key, firebase_database_url,
and
google_storage_bucket. The app may call each of
these APIs one or more times at different places.
Based on how the strings are used by the app code, String
Value Analysis has resolved the vast majority of the string
values, as shown in the 7th and 11th column in Table V for
both non-obfuscated and obfuscated apps. It would also be
interesting to understand why not all the parameter strings
could be resolved by our String Value Analysis. Our further
investigation revealed that
there are two reasons for this.
The ﬁrst one is that many of the unresolved values of these
parameters were actually retrieved from the Internet. This
case is particularly common for Firebase, as Google actually
1304
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:40:50 UTC from IEEE Xplore.  Restrictions apply. 
String Parameter Name
APIs
#API-Call
#APP
#Resolved Str.
%
#API-Call
#APP
#Resolved Str.
Non-Obfuscated
Obfuscated
AWS
Azure
Firebase
bucketName
bucketName
identityPoolId
accessKey
secretKey
appURL
appURL
appKey
connectionString
connectionString
google_app_id
google_api_key
firebase_database_url
google_storage_bucket
google_app_id
google_api_key
firebase_database_url
google_storage_bucket
1*
2*
3
4
4
5
6
6
7
8
9
9
9
9
10
10
10
10
2,460
2,069
3,458
3,280
3,280
185
824
824
700
345
2,378
2,378
2,378
2,378
154,664
154,664
154,664
154,664
1,229
1,703
3,458
1,769
1,769
39
316
316
513
97
1,228
1,228
1,228
1,228
78,859
78,859
78,859
78,859
2,190
2,045
3,315
2,650
2,646
185
817
809
643