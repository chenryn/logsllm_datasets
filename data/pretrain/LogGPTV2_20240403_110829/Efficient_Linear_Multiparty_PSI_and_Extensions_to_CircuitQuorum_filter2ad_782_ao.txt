and
ConvertSharesğ‘›,ğ‘¡, it follows that ğ‘ ğ‘— â‰¥ ğ‘˜ and ğ‘ ğ‘— =ğ‘–âˆˆ{2,Â·Â·Â· ,ğ‘›} ğ‘“ğ‘– ğ‘—.
ğ‘’ âˆˆ ğ‘Œ implies ğ‘ ğ‘— = 1. Further, by correctness of F ğ‘,ğ‘˜,ğ‘›,ğ‘¡
w-CMP
and F Fğ‘
B2A
Now, for every ğ‘– âˆˆ {2, Â· Â· Â· , ğ‘›}, by correctness of F Fğ‘
by correctness of F ğœ
B2A
EQ
ğ‘“ğ‘– ğ‘— = ğ‘’ğ‘ğ‘– ğ‘— and
, ğ‘’ğ‘ğ‘– ğ‘— equals 1 if ğ‘¦ğ‘– ğ‘— = ğ‘¤ğ‘– ğ‘— and 0 otherwise.
, F ğœ
EQ
ğ‘–âˆˆ{2,Â·Â·Â· ,ğ‘›} ğ‘“ğ‘– ğ‘— = ğ‘ ğ‘— â‰¥ ğ‘˜ and for all ğ‘– âˆˆ {2, Â· Â· Â· , ğ‘›}, ğ‘’ğ‘ğ‘– ğ‘— âˆˆ {0, 1} we
Let E = {ğ‘– âˆˆ {2, Â· Â· Â· , ğ‘›} : ğ‘’ âˆˆ ğ‘‹ğ‘–}, the set of indices of parties
(other than ğ‘ƒ1) who possess ğ‘’ in their private sets. Let Eâ€² = {ğ‘– âˆˆ
{2, Â· Â· Â· , ğ‘›} : ğ‘’ğ‘ğ‘– ğ‘— = 1}, the set of indices of parties (other than ğ‘ƒ1)
whom the protocol interprets to have possession of ğ‘’. We now show
that false positive (ğ‘Œ âŠˆ ğ‘Œâˆ—) implies that Eâ€²\E is non-empty and
finally prove that the later event occurs with low probability. Since
have |Eâ€²| â‰¥ ğ‘˜. Consider the following disjoint cases.
â€¢ Case 1: ğ‘’ âˆ‰ ğ‘‹1. By the construction of Table1, this implies that
ğ‘’ is a dummy element inserted by ğ‘ƒ1. Then, |E| = 0 since real
elements are distinct from ğ‘’. Therefore, Eâ€²\E is non-empty.
Further, since any dummy elements inserted by parties other
than ğ‘ƒ1 are distinct from ğ‘’, for every ğ‘– âˆˆ Eâ€²\E it holds that
ğ‘’ âˆ‰ Tableğ‘–[ ğ‘—].
â€¢ Case 2: ğ‘’ âˆˆ ğ‘‹1. Since ğ‘’ âˆ‰ ğ‘Œâˆ—, we have |E|  1 âˆ’ 2âˆ’ğœ… (for
ğœ… = 40) the protocolâ€™s output will be correct.
Session 4C: Private Set Intersection CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea1203and F Fğ‘
B2A
Remark. To ensure the correctness of Quorum-I (instantiated using
w-CMP1) with probability at least 1 âˆ’ 2âˆ’ğœ…, we set the parameter ğœ
of w-CMP1 to be ğœ… + âŒˆlog ğ‘šâŒ‰ + 3.
Security. Let ğ¶ âŠ‚ [ğ‘›] be the set of corrupted parties (|ğ¶| = ğ‘¡ < ğ‘›/2).
We show how to simulate the view of ğ¶ in the ideal world, given the
input sets ğ‘‹ğ¶ = {ğ‘‹ ğ‘— : ğ‘— âˆˆ ğ¶} and the output, ğ‘Œâˆ— = {ğ‘¥ âˆˆ ğ‘‹1 : ğ‘ğ‘¥ â‰¥
ğ‘˜}, where, for each ğ‘¥ âˆˆ ğ‘‹1, ğ‘ğ‘¥ = |{ğ‘– : ğ‘¥ âˆˆ ğ‘‹ğ‘– for ğ‘– âˆˆ {2, Â· Â· Â· , ğ‘›}}|,
when ğ‘ƒ1 is corrupt, and no output, otherwise. We consider two
cases based on party ğ‘ƒ1 being corrupt or not.
â€¢ Case 1 (ğ‘ƒ1 is honest): The hashing step is local, and can be
executed by the simulator using the inputs of the corrupted
parties. In Step 2, ğ‘ƒ1 and ğ‘ƒğ‘– (for each ğ‘– âˆˆ {2, Â· Â· Â· , ğ‘›}) invoke
the F ğ›½,ğœ,ğ‘
functionality and the corrupted parties only see the
senderâ€™s views (since ğ‘ƒ1 is honest), {ğ‘¤ğ‘– ğ‘—}ğ‘–âˆˆğ¶,ğ‘— âˆˆ[ğ›½], which can
wPSM
all be picked at random by the simulator (by the definition of
). In Steps 3 and 4, for each ğ‘– âˆˆ {2, Â· Â· Â· , ğ‘›}, parties ğ‘ƒ1
F ğ›½,ğœ,ğ‘
wPSM
and ğ‘ƒğ‘– invoke the F ğœ
functionalities and the cor-
EQ
rupted parties see only one of the two boolean and additive
shares, {âŸ¨ğ‘’ğ‘ğ‘– ğ‘—âŸ©ğµ
ğ‘– }ğ‘–âˆˆğ¶,ğ‘— âˆˆ[ğ›½] and {âŸ¨ğ‘“ğ‘– ğ‘—âŸ©ğ‘–}ğ‘–âˆˆğ¶,ğ‘— âˆˆ[ğ›½], respectively,
which can be generated as corresponding shares of some ran-
dom bit (by the security of secret sharing). In Step 5, besides
the local computations, the parties invoke the functionalities
ConvertSharesğ‘›,ğ‘¡ and F ğ‘,ğ‘˜,ğ‘›,ğ‘¡
. The view of the corrupted par-
w-CMP
ties in this step includes: at most ğ‘¡ shares of the ğ‘ ğ‘—, for each
ğ‘— âˆˆ [ğ›½]. Here, the simulator can pick shares of some random
values as the ğ‘¡ shares of the ğ‘ ğ‘—â€™s (by the security of secret shar-
ing). Note that, the corrupted parties get no output from the
Fw-CMP
functionality (since ğ‘ƒ1 is honest), and also no output
from the protocol.
â€¢ Case 2 (ğ‘ƒ1 is corrupt): The simulation of the hashing step is
exactly the same as in Case 1. In Step 2, ğ‘ƒ1 and ğ‘ƒğ‘– (for each ğ‘– âˆˆ
{2, Â· Â· Â· , ğ‘›}) invoke the F ğ›½,ğœ,ğ‘
functionality and the corrupted
parties see both the receiverâ€™s view {ğ‘¦ğ‘– ğ‘—
: ğ‘– âˆˆ {2, Â· Â· Â· , ğ‘›}, ğ‘— âˆˆ
wPSM
[ğ›½]}, and the senderâ€™s views {ğ‘¤ğ‘– ğ‘—}ğ‘–âˆˆğ¶\{1},ğ‘— âˆˆ[ğ›½]. For each ğ‘– âˆˆ
ğ¶ \ {1}, the simulator picks a random ğ‘¦ğ‘– ğ‘— = ğ‘¤ğ‘– ğ‘—, if Table1[ ğ‘—] âˆˆ
Tableğ‘–[ ğ‘—], else picks a random ğ‘¦ğ‘– ğ‘— and ğ‘¤ğ‘– ğ‘— independently, for
each ğ‘— âˆˆ [ğ›½] (the faithfulness of this step of simulation fol-
lows from the definition of F ğ›½,ğœ,ğ‘
and since the simulator
has both Table1 and Tableğ‘–). In Steps 3 and 4, for each ğ‘– âˆˆ
wPSM
{2, Â· Â· Â· , ğ‘›}, parties ğ‘ƒ1 and ğ‘ƒğ‘– invoke the F ğœ
func-
EQ
tionalities and the corrupted parties see both the boolean and
1 , âŸ¨ğ‘’ğ‘ğ‘– ğ‘—âŸ©ğµ
additive shares for ğ‘– âˆˆ ğ¶, {âŸ¨ğ‘’ğ‘ğ‘– ğ‘—âŸ©ğµ
ğ‘– }ğ‘–âˆˆğ¶\{1},ğ‘—âˆˆ[ğ›½] and
{âŸ¨ğ‘“ğ‘– ğ‘—âŸ©1, âŸ¨ğ‘“ğ‘– ğ‘—âŸ©ğ‘–}ğ‘–âˆˆğ¶\{1},ğ‘— âˆˆ[ğ›½], and only one of the two shares for
ğ‘– âˆˆ [ğ‘›] \ ğ¶, {âŸ¨ğ‘’ğ‘ğ‘– ğ‘—âŸ©ğµ
1 }ğ‘–âˆˆ[ğ‘›]\ğ¶,ğ‘— âˆˆ[ğ›½] and {âŸ¨ğ‘“ğ‘– ğ‘—âŸ©1}ğ‘–âˆˆ[ğ‘›]\ğ¶,ğ‘— âˆˆ[ğ›½].
For each ğ‘– âˆˆ ğ¶ \ {1}, the simulator sets ğ‘’ğ‘ğ‘– ğ‘— = ğ‘“ğ‘– ğ‘— = 1, if
Table1[ ğ‘—] âˆˆ Tableğ‘–[ ğ‘—] and sets ğ‘’ğ‘ğ‘– ğ‘— = ğ‘“ğ‘– ğ‘— = 0, otherwise, for
each ğ‘— âˆˆ [ğ›½]. It then generates the boolean and arithmetic
shares of the ğ‘’ğ‘ğ‘– ğ‘—â€™s and ğ‘“ğ‘– ğ‘—â€™s, respectively. For each ğ‘– âˆˆ [ğ‘›] \ ğ¶,
the simulator generates both the boolean and additive shares
as shares of some random bit (by the security of secret sharing).
To simulate Steps 5 and 6, the simulator does the following: for
all ğ‘— âˆˆ [ğ›½], give ğ‘¡ shares of the random values as shares of the
ğ‘ ğ‘—â€™s (by the security of secret sharing). Finally, for each ğ‘— âˆˆ [ğ›½],
set ğ‘ ğ‘— = 1 if Table1[ ğ‘—] âˆˆ ğ‘Œâˆ— and set ğ‘ ğ‘— = 0, otherwise, and set
the final output as ğ‘Œâˆ—.
and F Fğ‘
B2A
, F Fğ‘
B2A
, F ğœ
EQ
when F ğ‘,ğ‘˜,ğ‘›,ğ‘¡
w-CMP
F.2 Quorum PSI Complexity
We instantiate the F ğœ
, ConvertSharesğ‘›,ğ‘¡ functionalities as
EQ
specified in sections 2.3.1, 2.3.2 and 2.5. We instantiate the F ğ›½,ğœ,ğ‘
wPSM
functionality using the polynomial-based batch OPPRF. Let Quorum-
I and Quorum-II denote instantiations of F ğ‘›,ğ‘š,ğ‘˜
is
QPSI
instantiated with w-CMP1 (with ğœ = ğœ… + âŒˆlog ğ‘šâŒ‰ + 3) and w-CMP2
respectively. We first discuss the complexity trade-off between
w-CMP1 and w-CMP2 and then discuss the complexities of Quorum-
I and Quorum-II
F.2.1 Trade-offs between w-CMP1 and w-CMP2. We first discuss
the communication complexity and rounds of both protocols. Mul-
tiparty functionalities in both the protocols are instantiated as re-
ferred in Sec. 2.5. Since these instantiations provide good amortized
complexities, we give amortized costs of both the protocols.
The amortized communication cost of w-CMP1 is at most 14ğ‘˜â€²(ğ‘›âˆ’
1)(âŒˆlog ğ‘›âŒ‰ + 1) + 17ğœ(ğ‘› âˆ’ 1) and the round complexity is 6 + 2ğ‘˜â€²,
when we set âŒˆlog ğ‘âŒ‰ = âŒˆlog ğ‘›âŒ‰ + 1 and ğ‘˜â€² = min{ğ‘˜ âˆ’ 1, ğ‘› âˆ’ ğ‘˜}.
While for w-CMP2, the (expected11) communication complexity is
20(ğ‘›âˆ’1)âŒˆlog 2ğ‘›âŒ‰(ğœ…+âŒˆlog 2ğ‘›âŒ‰)2, when we set âŒˆlog ğ‘âŒ‰ = ğœ…+âŒˆlog ğ‘›âŒ‰+2.
The expected round complexity is 9 + 2âŒˆlog ğ‘›âŒ‰.
We now discuss trade-offs between the two comparison pro-
tocols. Complexity of w-CMP2 protocol is independent of ğ‘˜, in
contrast to w-CMP1 protocolâ€™s dependence on ğ‘˜. Hence, theoret-
ically, for large values of ğ‘˜â€², the communication complexity and
round complexity of w-CMP2 is better than w-CMP1. However, for
practical setting of ğ‘˜â€² < ğ‘› < 512, the concrete communication of
w-CMP1 is better than that of w-CMP2 for ğœ… = 40 and ğœ = ğœ… + 23.
For any âŒˆlog ğ‘›âŒ‰ + 2 < ğ‘˜â€², the round complexity of w-CMP2 is better
than that of w-CMP1.
F.2.2 Complexities of Quorum-I and Quorum-II. Our protocol, in
total, calls the F ğ›½,ğœ,ğ‘
, ConvertSharesğ‘›,ğ‘¡ and F ğ‘,ğ‘˜,ğ‘›,ğ‘¡
w-CMP
wPSM
functionalities (ğ‘›âˆ’1), ğ›½(ğ‘›âˆ’1), ğ›½(ğ‘›âˆ’1), ğ›½ and ğ›½ times respectively,
where ğ›½ = 1.28ğ‘š. Let ğ‘˜â€² = min{ğ‘˜ âˆ’ 1, ğ‘› âˆ’ ğ‘˜}. Recall that ğœ =
ğœ… + âŒˆlog ğ‘šâŒ‰ + âŒˆlog ğ‘›âŒ‰ +2. We first give the costs of the steps common
to Quorum-I and Quorum-II.
â€¢ Steps 1-4 cost less than ğ‘š(ğ‘› âˆ’ 1)(ğœ†ğœ + 5.8ğœ† + 14ğœ + 1.28âŒˆlog ğ‘âŒ‰).
â€¢ Excluding the cost of F ğ‘,ğ‘˜,ğ‘›,ğ‘¡
, Step 5 contributes at most 8ğ‘š(ğ‘› âˆ’
w-CMP
1)âŒˆlog ğ‘âŒ‰.
The total cost of w-CMP1 executions by Quorum-1 is at most ğ‘š(ğ‘›âˆ’
1)(18ğ‘˜â€²(âŒˆlog ğ‘›âŒ‰ + 1) + 22ğœ), where ğœ = ğœ… + âŒˆlog ğ‘šâŒ‰ + 3 . Therefore,
the concrete communication of Quorum-I is at most ğ‘š(ğ‘› âˆ’ 1)(ğœ†ğœ +
5.8ğœ† + 14ğœ + 18ğ‘˜â€²(âŒˆlog ğ‘›âŒ‰ + 1) + 22ğœ + 10âŒˆlog ğ‘›âŒ‰), when we set
âŒˆlog ğ‘âŒ‰ = âŒˆlog ğ‘›âŒ‰ + 1. The round complexity of Quorum-I is at most
10 + âŒˆlog ğœâŒ‰ + 2ğ‘˜â€².
The (expected) total cost of w-CMP2 executions by Quorum-
II is at most 26ğ‘š(ğ‘› âˆ’ 1)(âŒˆlog ğ‘›âŒ‰ + 1)(ğœ… + âŒˆlog ğ‘›âŒ‰ + 1)2. Therefore,
(expected) concrete communication of Quorum-II is at most ğ‘š(ğ‘› âˆ’
1)(ğœ†ğœ + 5.8ğœ† + 14ğœ + 27(âŒˆlog ğ‘›âŒ‰ + 1)(ğœ… + âŒˆlog ğ‘›âŒ‰ + 1)2), when we set
ğ‘ = ğœ… + âŒˆlog ğ‘›âŒ‰ + 2. The (expected) round complexity of Quorum-II
is at most 8 + âŒˆlog ğœâŒ‰ + 2âŒˆlog ğ‘›âŒ‰.
, F Fğ‘
B2A
11One of the underlying sub-protocol uses rejection sampling for randomness that
incurs repeated executions with small probability, namely, 1/ğ‘.
Session 4C: Private Set Intersection CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea1204