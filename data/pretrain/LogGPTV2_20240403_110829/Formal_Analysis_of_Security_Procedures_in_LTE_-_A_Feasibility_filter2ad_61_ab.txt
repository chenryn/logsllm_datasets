{[NSR]}
[RSM: RRCalgs]
ISC: UEalgs,KeNB
{[RSC]}
CSC
ATT: Attach Request
ADQ: Authentication Data Request
ADR: Authentication Data Response
ACH: Authentication Challenge
ARE: Authentication Response
NSM: NAS Security Mode Command
NSC: NAS Security Mode Complete
NSR: NAS Service Request
ICS: Initial Context Setup
RSM: RRC Security Mode Command
RSC: RRC Security Mode Complete
CSC: Context Setup Complete
[ ] Integrity protected
{} Encrypted
Fig. 2. AKA, NAS security control and service request procedures
Formal Analysis of Security Procedures in LTE - A Feasibility Study
347
3 ProVerif Overview
Before we present our work with the security procedures, we ﬁrst describe
ProVerif, the tool we use. We will be using AKA as a supporting example to
show how protocols can be modeled and analyzed with it.
3.1 ProVerif
The tool takes formal models of the protocols together with a set of security
properties as input. The input language is a typed variant of the applied pi
calculus [4]. In this language, messages are modeled as terms. Relationships
between cryptographic primitives are captured by rewrite rules or an equational
theory. The complete speciﬁcation can be found in the user manual [10].
ProVerif can prove reachability properties and correspondence assertions [7].
Reachability properties allow checking which information is in the possession of
the attacker, i.e. secrecy. Correspondence properties are of the form “if some
event is executed, then another event has previously been executed”, and can
be used for checking various types of authentication [20].
3.2 Input Language
Figure 3 shows an AKA model in the ProVerif language. In general, a protocol
model can be divided in three parts: the declarations (lines 1-9), the process
macros (10-31) and the main process (32). The declarations include the user
types, the functions that describe the cryptographic primitives, and the secu-
rity properties. The process macros consist of sub-process deﬁnitions. Each sub-
process is a sequence of events. Finally, the main process is deﬁned using those
macros. In this particular example, it is deﬁned as the parallel composition (de-
noted by |) of the unbounded replication (denoted by !) of three process macros
representing a UE (line 10), an MME (18) and an HSS (24) node.
Declarations. Besides the built-in types: channel, bitstring and bool; addi-
tional user types can be declared as in line 2. Free names are introduced as in
line 1 where two channels with names pubch and secch are declared. Free names
are by default accessible to the attacker unless qualiﬁed by [secret]. In the ex-
ample, the private channel is used for secure communication such as within a
trusted domain or over an IPsec tunnel.
Constructors are functions used to build terms. They are declared by spec-
ifying their names, the types of the arguments and the return value (see lines
4-7). By default, functions are one-way; that is, the attacker cannot derive the
arguments from the return value, unless qualiﬁed by [data] . Destructors (line
8) are special functions that are used to manipulate terms. Combined together,
constructors and destructors are used to capture the relationship between cryp-
tographic primitives. In the model of Fig. 3, the ﬁrst three declared functions are
used to derive the authentication parameters in the HSS process (lines 28-30).
The last two are used to model a shared key encryption and decryption scheme.
348
N.B. Henda and K. Norrman
[ p r i v a t e ] .
t y p e i d .
t y p e m s g h e a d e r .
f r e e s e c c h : c h a n n e l
f r e e pubch : c h a n n e l .
t y p e k e y .
c o n s t ATT, ADR, ADQ, ACH, ARE : m s g h e a d e r .
f u n k d f ( b i t s t r i n g , k e y ) : k e y .
f u n a u t n ( b i t s t r i n g , k e y ) : b i t s t r i n g .
f u n r e s ( b i t s t r i n g , k e y ) : b i t s t r i n g .
f u n s e n c ( b i t s t r i n g , k e y ) : b i t s t r i n g .
r e d u c f o r a l l x : b i t s t r i n g , y : k e y ;
t a b l e db ( i d , k e y ) .
l e t UE ( ) =
i d ; new k : k e y ; (∗ k e y p r o v i s i o n n i n g ∗)
new i m s i :
i n s e r t db ( i m s i , k ) ; (∗ k e y a c t i v a t i o n ∗)
out ( pubch ,
(ATT,
i n ( pubch , (=ACH,
i f a = a u t n ( r , k )
i m s i ) ) ; (∗ a t t a c h r e q u e s t ∗)
r : b i t s t r i n g , a : b i t s t r i n g ) ) ;
then
s d e c ( s e n c ( x , y ) , y ) = x .
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
l e t kasme : k e y = k d f ( r , k )
out ( pubch ,
(ARE ,
i n
r e s ( r , k ) ) ) . (∗ a u t h e n t i c a t i o n r e s p o n s e ∗)
l e t MME( ) =
i n ( pubch , (=ATT,
out ( s e c c h ,
(ADQ,
i n ( s e c c h , (=ADR, kasme : key , a : b i t s t r i n g , x r : b i t s t r i n g , n : b i t s t r i n g ) ) ;
out ( pubch ,
i n ( pubch , (=ARE , =x r ) ) .
i m s i :
i m s i ) ) ; (∗ a u t h e n t i c a t i o n d a t a r e q u e s t ∗)
(ACH, n , a ) ) ; (∗ a u t h e n t i c a t i o n r e q u e s t ∗)
i d ) ) ;
i d ) ) ; (∗ a u t h e n t i c a t i o n d a t a r e q u e s t ∗)
l e t HSS ( ) =
i m s i :
i n ( s e c c h , (=ADQ,
new n : b i t s t r i n g ;
g e t db(= i m s i , k : k e y )
l e t kasme : k e y = k d f ( n , k )
i n
l e t a : b i t s t r i n g = a u t n ( n , k )
l e t
out ( s e c c h ,
r : b i t s t r i n g = r e s ( n , k )
(ADR, kasme , a ,
i n
i n
i n
p r o c e s s
( ( ! UE ( ) )
|
( !MME( ) )
|
r , n ) ) . (∗ a u t h e n t i c a t i o n d a t a r e s p o n s e ∗)
( ! HSS ( ) ) )
Fig. 3. AKA model
Constants (line 3) are 0-arity functions that together with types can be used
to improve the clarity of the model and can help reducing the number of valid
traces during the analysis. This is also common behavior of implementations,
i.e., a protocol implementation typically reject messages of unexpected types. In
addition, we use the constants to identify the diﬀerent exchanged messages so
that they can be easily mapped in the corresponding chart (Fig. 2).
The language provides support for tables for persistent storage. In line 9, a
table modeling the subscriber database is declared. Lines 11-12 model the process
of registering a new subscriber; and line 27 models the process of retrieving the
pre-shared secret key of a subscriber (variable k) given its identity (imsi).
Process Macros. Messages are represented by terms. A term can be a name,
a variable, a tuple of terms, a constructor or destructor application. In addition,
the language has support for some common Boolean functions (=, &&,||, <>)
that use the inﬁx notation. Pattern matching is used for term evaluation of
message inputs. The pattern x : t matches any term of type t and binds it to
x. For a term M , the pattern = M matches any term N such that M = N . A
pattern tuple (T1, T2, . . . , Tn) matches any term tuple (M1, M2, . . . , Mn) where
pattern matching is applyed recursively to each term Mi against pattern Ti. For
example, the pattern (= ATT, imsi : id) in line 19 matches any term pair where
the ﬁrst one is the constant ATT and the second one is of type id.
Formal Analysis of Security Procedures in LTE - A Feasibility Study
349
Processes are deﬁned as sequences of events. The name restriction event (line
26) creates a fresh name of a speciﬁc type and binds it inside the following events.
The communication event out(M, N ); P (13), sends the term N on channel
M and continue as the process P . The communication event in(M, T ); P (25),
awaits a message matching pattern T on channel M and continues as P . The
conditional if M else P then Q (15) continues as the process P if the term M
evaluates to true, continues as the process Q if M evaluates to another value,
or stops if M evaluation fails. The statement let T = M in P else Q (28) tries
to match the term M with pattern T , continues as the process P if there is a
match, or continues as the process Q otherwise.
3.3 Security Properties
Security properties are declared with the keyword query. In our example of
AKA, one of the goals is to establish the shared session key KASME between the
MME and the UE. In order to check this, we consider the following properties.
1
2
3
4
5
6
7
8
9
e v e n t u e R e a c h a b l e ( ) . e v e n t mmeReachable ( ) . e v e n t h s s R e a c h a b l e ( ) .
q u e r y e v e n t ( mmeReachable ( ) ) ; e v e n t ( h s s R e a c h a b l e ( ) ) ; e v e n t ( u e R e a c h a b l e ( ) ) .
f r e e s e c r e t : b i t s t r i n g [ p r i v a t e ] .
q u e r y a t t a c k e r ( s e c r e t ) .
e v e n t u eR u n n i n g ( key ) . e v e n t ueCommit ( key ) . e v e n t mmeRunning ( key ) . e v e n t
mmeCommit ( key ) .
q u e r y k : key ; e v e n t ( ueCommit ( k ) ) ==> e v e n t ( mmeRunning ( k ) ) .
q u e r y k : key ; e v e n t ( mmeCommit ( k ) ) ==> e v e n t ( u eR u n n i n g ( k ) ) .
q u e r y k : key ;
q u e r y k : key ;
i n j −e v e n t ( ueCommit ( k ) ) ==> i n j −e v e n t ( mmeRunning ( k ) ) .
i n j −e v e n t ( mmeCommit ( k ) ) ==> i n j −e v e n t ( u eR u n n i n g ( k ) ) .
The ﬁrst two declarations are used for sanity checks. The “reachability” events
of line 1 are intended to be executed each at the end of the corresponding process
macro. Events are special extension to the process grammar that do neither aﬀect
the attacker knowledge, nor the execution of the processes. When analyzing the
query of line 2, ProVerif attempts to falsify its claims by generating traces that
reach those events. This is useful to check that the processes can be fully executed
and that there are no blocking events for example due to a constantly failing
pattern matching. The declarations in lines 3-4 are used to check secrecy of the
established key. The attacker (line 4) is a built-in predicate that can be used
to check which terms are compromised.
The last declarations are correspondence assertions used for checking mutual
agreement between the UE and the MME on the key. The syntax to query a
basic correspondence assertion uses the event keyword (lines 5-7). Correspon-
dence assertions where a one-to-one mapping is required between events, use the
inj-event keyword instead. In our case, we recall Lowe’s deﬁnitions of weak and
injective agreement [20] and use the special “running” and “commit” events de-
clared in line 5 together with the correspondence assertions of lines 6-7 to check
for agreement on the established key between the MME and UE processes. In
general, a commit event is added in the end of each “responder” process, to which
another “initiator” process is trying to authenticate. Then for each commit, a
running event is added in the “initiator” process before the last send operation.
350
N.B. Henda and K. Norrman
3.4 Analysis and Discussion
ProVerif is able to solve all the properties except one of the reachability queries
of line 2 and the injective correspondence assertion query of line 9. The remaining
queries are solved as expected. More precisely, the correspondence and secrecy
ones are proved to hold and the reachability queries are falsiﬁed.
The unresolved reachability query can be solved by restricting the attacker
model. This is can be done by a special feature of ProVerif for setting internal
conﬁguration parameters. One of those parameters representing the attacker
capability can be set to either passive or active directly in the model. Setting
the attacker to passive has the eﬀect of reducing the number of traces (improving
the chances for termination) but the analysis is no longer sound. This is not a
problem for reachability because a trace that reaches the target event in the
restricted model is also valid in the non restricted one. ProVerif is then able
to solve the unanswered reachability claim. Another way for achieving the same
eﬀect consists in declaring all communication channels as private. Intuitively, the
goal is to check whether the protocol can be run at all in a secure environment
by honest agents.
For the unresolved correspondence assertion, while further experimenting with
the model we observed the following. When strengthening the claim by including
an additional id parameter (see below), executing the corresponding commit and
running events with the additional argument set to the imsi, and setting the
attacker model to passive, then ProVerif is able to ﬁnd an attack trace even for
the corresponding non-injective assertion.
q u e r y i :
i d , k : key ; e v e n t ( mmeCommit ( i , k ) ) ==> e v e n t ( u eR u n n i n g ( i , k ) ) .
The attack trace is due to the ProVerif approximation [8]. In the following