void L_Rotate（BiTree *P)
BiTree R;
R=（·p）->rchild;
R指向P的右子树根结点*/
（*P)->rchild-R->1child;
R的左子树挂接为P的右子树/
R->lchild-（*P）;
*P=R;
P指向新的根结点*/
这段代码与右旋代码是对称的，在此不做解释了。上面例子中的新增结点5、6、
7（如图8-7-5的图4、5，图8-7-6的图6、7、8、9），都是左旋操作。
现在我们来看左平衡旋转处理的函数代码。
defineLH+1/左高/
defineEHO/等高/
defineRH-1/*右高·/
/对以指针所指结点为根的二叉树作左平街旋转处理·/
/本算法结来时，指针T指向新的根结点*/
1void LeftBalance（BiTree *T）
2
9
3
BiTree L,Lr
4
L-（·T）->1chi1d；/L指向的左子树根结点/
switch（L->bf)
6
（/检壹T的左子树的平街度，并作相应平衡处理*/
caseLH：/·新结点插入在T的左孩子的左子树上，要作单右旋处理*/
8
H=qrchild;/Lr指向T的左孩子的右子树根*/
13
switch（Lr->bt）/·修改T及其左孩子的平街因子/
14
15
case LH:（*T)->bf=RH;
16
L->bf-EH;
336
---
## Page 361
第8章查找
17
break:
18
3-qbf=EH;
21
L->bf-LH;
22
break;
23
F
24
3-q1child）：/对T的左子树作左旋平衡处理·/
26
R_Rotate（T);
·对作右旋平衡处理*/
27
28
首先，我们定义了三个常数变量，分别代表1、0、一1。
1.函数被调用，传入一个需调整平衡性的子树T。由于LeftBalance函数被调用
时，其实是已经确认当前子树是不平衡状态，且左子树的高度大于右子树的高
度。换句话说，此时T的根结点应该是平衡因子BF的值大于1的数。
2.第4行，我们将T的左孩子赋值给L。
3.第5~27行是分支判断。
4.当L的平衡因子为LH，即为1时，表明它与根结点的BF值符号相同，因
此，第8行，将它们的BF值都改为0，并且第9行，进行右旋操作。操作的
方式如图8-7-9所示。
5.当L的平衡因子为RH，即为一1时，表明它与根结点的BF值符号相反，此
时需要做双旋处理。第13~22行，针对L的右孩子Lr的BF作判断，修改根
结点T和L的BF值。第24行将当前L的BF改为0。
6.第25行，对根结点的左子树进行左旋，如图8-7-10第二图所示。
7.第26行，对根结点进行右旋，如图8-7-10的第三图所示，完成平衡操作。
337
---
## Page 362
大话
数据结
(N
插入N前是平衡二叉树
插入N后是平衡性打破
左旋以保证根结点和它的
左孩子BF符号相同
调整后恢复平衡性
图8-7-10
同样的，右平衡旋转处理的函数代码非常类似，直接看代码，不做讲解了。
我们前面例子中的新增结点9和8就是典型的右平衡旋转，并且双旋完成平衡的
例子（如图8-7-7的图11、12，图8-7-8的图14、15、16所示）。
有了这些准备，我们的主函数才算是正式登场了。
1若在平衡的二叉排序树T中不存在和e有相同关键字的结点，则插入一个/
/*数据元素为e的新结点并田1，否则返回0.若因插入而使二叉排序树*/
/失去平衡，则作平衡旋转处理，布尔变量taller反映T长高与否。·/
Status InsertAVL(BiTree*T,int e,Status*taller)
2
3
sf(!*T)
4
（/插入新结点，树“长高”，里taller为TRUE·/
5
T=（BiTree）malloc（sizeof(BiTNode));
6
fa=eepbf-EH;
9
"taller-TRUE;
10
11
else
12
13
（pdata）
19
（/]
应继续在T的左子树中进行搜索*/
20
if（1InsertAVL（6(*T）->lchild,e,taller））/未插入*/
21
return FALSE;
22
if(taller)/*
已插入到T的左子树中且左子树“长高”*/
23
24
switch（（*T）->bf）/·检壹T的平街度·/
25
26
caseLH：/*原本左子树比右子树高，需要作左平衡处理*/
27
LeftBalance(T):
28
*taller-FALSE;
29
break;
30
caseEH：/原本左右子树等高，现固左子树增高而树增高*/
31
fHT=zqrchild,e,taller)）/未入/
44
returnFALSE;
339
---
## Page 364
大话数据结构
45
46
47
switch（（*T）->bf）/检查T的平衡度*/
48
49
caseLH：/原本左子树比右子树高，现左、右子树等高·/
50
(*T)->bf-EH;
51
*taller-FALSE;
52
break;
53
CaseEH：/原本左右子树等高，现固右子树增高而树增高*
54
-q<-（
SS
"taller=TRUE;
56
break;
57
caseRH：/原本右子树比左子树高，需要作右平衡处理*/
89
RightBalance(T);
69
"taller=FALSE;
60
break;
61
62
63
64
65
return TRUE;
661
1.程序开始执行时，第3~10行是指当前T为空时，则申请内存新增一个结点。
2.第13~17行表示当存在相同结点，则不需要插入。
3.第18~40行，当新结点e小于T的根结点值时，则在T的左子树查找。
4.第20~21行，递归调用本函数，直到找到则返回fase，否则说明插入结点成
功，执行下面语句。
5.第22~39行，当taller为TRUE时，说明插入了结点，此时需要判断T的平
衡因子，如果是1，说明左子树高于右子树，需要调用LeftBalance函数进行
左平衡旋转处理。如果为0或一1，则说明新插入结点没有让整棵二叉排序树
失去平衡性，只需要修改相关的BF值即可。
6.第41~63行，说明新结点e大于T的根结点的值，在T的右子树查找。代码
上述类似，不再详述。
340
---
## Page 365
第8章查找
对于这段代码来说，我们只需要在需要构建平衡二叉树的时候执行如下列代码即
可在内存中生成一棵与图8-7-4的图2相同的平衡的二叉树。
inti;
fnta[10]-(3,2,1,4,5,6,7,10,9,8};
for（i=0:i<10;i++）
InsertAVL（6T,a[i],6taller）;
不容易，终于讲完了，本算法代码很长，是有些复杂，编程中容易在很多细节上
出错，要想真正掌握它，需要同学们自已多练习。不过其息想还是不难理解的，总之
就是把不平衡消灭在最早时刻。
如果我们需要查找的集合本身没有顺序，在频繁查找的同时也需要经常的插入和
删除操作，显然我们需要构建一棵二叉排序树，但是不平衡的二叉排序树，查找效率
是非常低的，因此我们需要在构建时，就让这棵二叉排序树是平衡二叉树，此时我们
的查找时间复杂度就为0（ogn），而插入和副除也为O（ogn）。这显然是比较理想的一
种动态查找表算法1