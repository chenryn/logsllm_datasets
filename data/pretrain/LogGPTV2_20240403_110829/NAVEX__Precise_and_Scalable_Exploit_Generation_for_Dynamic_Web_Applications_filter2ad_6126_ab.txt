itizations are available in many ﬂavors, including built-
in sanitizations (e.g., htmlspecialchars()), implicit
sanitizations (e.g., cast operators as shown in the run-
ning example), custom sanitizations (e.g., custom use of
str replace()), and sanitizations induced by database
constraints (e.g., NOT NULL constraints). The practical
challenge here is to precisely identify when such sani-
tizations are sufﬁciently robust to eliminate all possible
risks.
Dynamic features. An automatic exploit generation ap-
proach that is entirely based on static aspects of a web
application is prone to miss certain real exploits. As
mentioned before, modern web applications often con-
tain features that are revealed only when the application
is executed. These features often include dynamically
generated forms and links that may drive the navigation
of the application to vulnerable sinks. Unless the ap-
plication is deployed and executed, it is challenging for
a static analysis approach to infer such artifacts, which
may contain useful constraints for exploit paths. For in-
stance, line 23 of Listing 1, where the action of the
form is set by the result of running the embedded PHP
code. To precisely infer the value of that action, a static
analyzer has to be able to handle the PHP semantics of
that code portion. Other situations (not shown in the ex-
ample) include dynamically generated content including
JavaScript generated content. It is, therefore, necessary
USENIX Association
27th USENIX Security Symposium    379
to incorporate dynamic analysis as part of the exploit
generation framework to make these runtime artifacts ex-
plicit. An additional challenge with dynamic execution
is maximizing the coverage of an application.
Scalability. Generating executable exploits that span
multiple modules and traverse execution paths inside
each module for large and complex modern web applica-
tions is challenging. Constructing exploits requires an-
alyzing the application as a whole, including its client-
side, server-side and database backend. To deal with this
challenge, the exploit generation approach must be de-
signed with careful considerations for pruning unfeasi-
ble exploit paths. To demonstrate the need for a scal-
able approach, let’s consider our running example. For
this simple application, to construct an exploit for the
vulnerable sink in Listing 3, we have to process a to-
tal of 44 execution paths in the 3 modules (i.e., 32
paths in selectBooks.php, 4 in hold.php, and 8 in
checkout.php) to ﬁnd candidate exploitable paths to
the sink.
Another scalability challenge we need to tackle is
related to the goal of generating exploits for multiple
classes of vulnerabilities. To address this challenge,
we need to support abstraction and analysis of multi-
ple classes of vulnerabilities efﬁciently, as to generate as
many different types of exploits as possible.
2.3 Approach Overview
Our goal is to build a precise, scalable, and efﬁcient
exploit generation framework that takes into account the
dynamic features of web applications and the naviga-
tional complexities that stem from dependencies among
the client-side, server-side and database backend.
Our approach is implemented in a system called
NAVEX, as shown in Figure 1. To address the scala-
bility challenges, our approach is divided into two steps:
(I) vulnerable sink identiﬁcation and (II) concrete exploit
generation.
Given the application source code, the ﬁrst step iden-
tiﬁes vulnerable sinks in the application and the corre-
sponding modules. This phase analyzes each module
separately and is crucial for prioritizing only those mod-
ules that have vulnerabilities; thus signiﬁcantly reduc-
ing the search space and contributing to scalability. To
address the sink reachability challenge, NAVEX builds a
precise representation of the semantics of built-in saniti-
zation routines. In addition, for custom sanitizations, it
builds a model using symbolic constraints. These con-
straints are used by a constraint solver, which determines
if the sanitizations are sufﬁciently robust.
The second step is responsible for generating concrete
exploits. The main problem in automatically generating
concrete exploits is that of identifying application-wide
navigation paths that, starting from public-facing pages,
drive the execution to the vulnerable sinks identiﬁed in
Figure 1: The architecture of NAVEX.
the ﬁrst step through a series of HTTP requests. The
output of the dynamic execution is a Navigation Graph
that represents the navigation structure of the web appli-
cation. Finally, for every module containing a vulnera-
ble sink, as identiﬁed in the ﬁrst step, NAVEX uses this
navigation graph to ﬁnd the paths from public modules
to that module along which the exploit can be executed.
The dynamic features challenge is addressed in NAVEX
by combining dynamic analysis and symbolic execution
of applications. To maximize the coverage of an applica-
tion, NAVEX repeats the dynamic execution many times,
each time with different inputs generated by a constraint
solver in a way that maximizes path coverage in the ap-
plication. At each execution, NAVEX collects the infor-
mation necessary to derive the application’s navigation
structure.
3 Architecture and Algorithms
3.1 Vulnerable Sink Identiﬁcation
To identify the vulnerable sinks, NAVEX analyses each
module separately. An implicit goal of this step is to
exclude from the following step those modules that do
not contain vulnerable sinks. In particular, as depicted
in Figure 2, NAVEX ﬁrst builds a graph model of each
module’s code, then it discovers the paths that contain
data ﬂows between sources and sinks. Finally, it uses
symbolic execution to generate a model of the execution
as a formula and constraint solving to determine which
of those paths are potentially exploitable. Each of these
components is described next.
3.1.1 Attack Dictionary
To address the challenge of discovering multiple classes
of vulnerabilities, NAVEX was designed to be easily ex-
tensible to a wide range of vulnerabilities, such as SQLI,
XSS as well as logic vulnerabilities such as EAR [18]
and command injection. A key observation is that sev-
eral types of vulnerabilities are essentially similar. For
instance, SQLI and XSS both depend on the ﬂow of ma-
licious data from sources to sinks and injection of ma-
licious data in those sinks. The main difference is the
nature of the sink and the attack payload. This similar-
ity, in turn, can be leveraged to build analysis templates
that can be instantiated with minimal changes to discover
different classes of vulnerabilities. To this end, NAVEX
builds an Attack Dictionary, which is used to instantiate
analysis templates targeting each class of vulnerability.
In particular, it contains attack speciﬁcations, as follows:
380    27th USENIX Security Symposium
USENIX Association
APPROACHAbeer    |   April 4, 2018Vulnerability Spec.Vulnerable Sinks IdentificationVulnerable SinksConcrete Exploits GenerationApp  source codeAttack DictionaryExploitsExploit StringsApp  source codeAttack DictionaryPhase I : Vulnerable Sink IdentificationSQLIXSSFile Inclusion...Graph ConstructionGraph TraversalFormula Generation SolverSanitizationsSinksTraversal TypeAttack StringsAttack InstanceFigure 2: Vulnerable Sinks Identiﬁcation (Step I) Components.
Sinks. These are instructions that execute the malicious
content of an attack. For instance, echo and print PHP
functions are sinks for XSS attacks.
Sanitizations. These include an extensive list of PHP
sanitizations,
including built-in sanitization functions
and operators, which may implicitly sanitize an input
(e.g., cast operators). While extensive, this list is not
exhaustive, and therefore it may miss functions. How-
ever, the semantics of known custom sanitization func-
tions (e.g., str replace) are captured by NAVEX using
constraint solving.
Traversal Type.
It speciﬁes the type of traversal that
is needed on the graph (the graph representation will be
described shortly). We currently support forward and
backward traversals between sources and sinks. Speciﬁ-
cally, injection vulnerabilities typically need a backward
traversal, while vulnerabilities such as EAR need a for-
ward one.
Attack Strings. The attack strings are speciﬁcations of
the possible (malicious) values that can appear at a sink.
While not exhaustive, the list of attack strings used by
NAVEX is very extensive. It contains 45 attack patterns
collected from cheat sheets (e.g., [6]), and security re-
ports.
Currently, the attack dictionary contains entries for
SQLI, XSS, ﬁle inclusion, command injection, code ex-
ecution, and EAR.
3.1.2 Graph Construction
This step builds a graph model to represent the possi-
ble execution paths, which are later symbolically exe-
cuted, in a PHP module. Speciﬁcally, our graph model
is based on Code Property Graphs (CPGs) [9, 33], which
combine abstract syntax trees (AST), control ﬂow graphs
(CFG), call graph, and data dependence graphs (DDG)
under a unique representation to discover vulnerabilities,
which are modeled as graph queries. In particular, given
a source and a sink instruction, CPGs can be used to ﬁnd
data dependency paths between their variables.
However, our ﬁnal goal is not merely that of ﬁnding
vulnerable paths but also that of generating concrete ex-
ploits. To this end, we extend CPGs with sanitization and
database constraint tags. These tags are attributes added
to the CPGs and are used to prune out a large number of
potentially unexploitable paths and indirectly addressing
the challenge of path explosion.
Sanitization Tags. A sanitization tag stores information
about the sanitization status of each variable in a node, if
any. The possible values of the tag are unsan-X, san-X
where X represents the speciﬁc vulnerability. For in-
stance, san-sql and unsan-sql represent presence (or
non-presence) of SQLI sanitization, respectively.
The values of the sanitization tags are inferred and
added to the graph during its construction. In particular,
as a node is added to the CPG, the corresponding node’s
AST is analyzed to detect eventual sanitizations. This
analysis is guided by the sanitizations patterns contained
in the attack dictionary for each type of vulnerability.
When a match among the sanitization patterns is found
for a variable in a node, the corresponding san-X value
is set for that variable. Note, we add sanitization tags
that resolve the sanitization status of different types of
PHP statements such as assignment, cast, binary, unary
statements, built-in functions, etc.
To demonstrate how NAVEX assigns sanitization tags,
let us consider the statement at line 9 in Listing 1.
NAVEX starts by inspecting the AST of $edition =
(int)$ POST[’edition’] to assign an appropriate tag
to $ POST[’edition’] ﬁrst. Then, it propagates the san-
itization status to $edition. In this case, the assigned
tag to $ POST[’edition’] is san-all because the cast to
integer operator sanitizes it for all vulnerabilities in our
attack dictionary. Consequently, the variable $edition
will have the same value in its sanitization tag.
Database Constraint Tags. Databases may often en-
force additional constraints on the data that ﬂow to the
database tables. For instance, the columns of a database
table may implicitly sanitize certain inputs, based on the
column’s data type (e.g., enum or integer). We enhance
code property graphs to capture database constraints. In
particular, for each web application, NAVEX parses its
schema to collect table names, their columns names, data
types, and value constraints (e.g., NOT NULL).
During the CPG construction, NAVEX adds a tag
called DB to the root node of each application. This tag
contains the collected information from the schema, and
it is utilized later during the graph traversal and exploit
generation (Sections 3.1.3 and 3.1.4).
USENIX Association
27th USENIX Security Symposium    381
Graph ConstructionGraph TraversalFormula Generation SolverSanitizationsSinksTraversal TypeAttack StringsAttack InstanceSQLIXSSFile Inclusion...Attack DictionaryApp  source code[Vulnerable Sinks, Exploit Strings]3.1.3 Graph Traversal
The goal of this step is to discover vulnerable paths from
sources to sensitive sinks by inspecting the enhanced
CPG.
Backward Traversal. An example of a backward traver-
sal for discovering vulnerable paths for injection vulner-
abilities is shown in Algorithm 1.
The algorithm starts by searching the graph for calls
to sensitive sinks speciﬁed in the attack dictionary (line
4). For each node representing a sink, it follows back-
ward the data dependency edges for all variables used
in that sink using the function AnalyzeNode (line 8).
This function calls FollowBackwardDDEdge (line 18)
to ﬁnd all data dependency paths from a sink node to
either a source or a function argument (if the sink is
inside a function).
If a path ends at a function argu-
ment, AnalyzeNode is called recursively over the nodes
representing the call sites of that function (line 15).
The function FollowBackwardDDEdge identiﬁes intra-
procedural paths between sources and sinks and uses the
sanitization and DB tags to eliminate sanitized paths. Fi-
nally, getPathsTo (line 24) ﬁnds all traversed and un-
sanitized paths in the graph leading to source nodes.
As an example, consider the vulnerable sink echo to
XSS (line 15) in Listing 3. Starting from this sink, the
algorithm follows all data dependency edges backwards
while checking the sanitization tags of $name and $msg.
Since they are both unsanitized, NAVEX stores the intra-
procedural paths of the variables and follows the data de-
pendency edges in the caller function until it reaches the
source of $msg (line 10). Note, $name is not a user input
(holds values from the database) and therefore the algo-
rithm only returns the inter-paths of $msg as vulnerable
paths to XSS.
The FilterSanNodes function uses the sanitization
and DB tags to prune out unpromising paths for exploit
generation.
In particular, DB tags are utilized during
the search for SQLI vulnerability. For each write query,
NAVEX parses the query using a SQL parser to ﬁnd nec-
essary information such as table and columns names.
Then, it matches the extracted information with the DB
tag to derive constraints from the columns data types and
value constraints (Fdb). These constraints are used in
conjunction with the path constraints (Fpath) in the next
step (Section 3.1.4).
Forward Traversal. As another example, to detect EAR
vulnerabilities, NAVEX performs a forward graph traver-
sal from sources to sinks where the sources are redirec-
tion instructions (e.g., header) and the sinks are termi-
nation instructions (e.g., die). In particular, we distin-
guish between two types of EAR vulnerabilities, namely
benign where the code between sources and sinks does
not contain sensitive operations (e.g., SQL queries) and
malicious EAR where that code contains them [18].
VulnerablePaths = ANALYZENODE(sn)
Algorithm 1 Injection Vulnerability Path Discovery
1: Input: sources,sinks
2: output: VulnerablePaths
3:
4: sinkNodes = FINDSINKNODE(sinks)
5: for all sn ∈ sinkNodes do
6:
7: return VulnerablePaths
8: function ANALYZENODE(node)
VulnerablePaths ← []
9:
paths = FOLLOWBACKWARDDDEDGE(sn)
10:
for all path ∈ paths do
11:
12:
13:
14:
15:
16:
17:
18: function FOLLOWBACKWARDDDEDGE(node)
19:
20:
return VulnerablePaths
Intra Paths ← []
while node is not a source ∧ node is not a func. argu-
callPaths = ANALYZENODE(callNode)
VulnerablePaths ← path + callPaths
if path has a source then
VulnerablePaths ← path
else
ment do
21:
22:
23:
24:
25:
IncNodes = GETINCOMINGDDNODE(node)
UnsanNodes = FILTERSANNODES(IncNodes)
node ← unsanNodes
Intra Paths = GETPATHSTO(node)
return Intra Paths
The output of this step is a set of paths that are poten-
tially vulnerable. This set of paths is sent in input to the
next step.
3.1.4 Exploit String Generation
The last step of the static analysis is the generation of
exploit strings over the vulnerable paths discovered dur-
ing graph traversal.
In this step, each vulnerable path
is modeled as a logical formula Fpath. In addition, the
constraints derived from the DB tags Fdb are added to
the formula. It is next augmented with additional con-
straints over the variables at the sinks Fattack, which rep-
resent values that can lead to an attack. These values are
retrieved from the Attack Dictionary based on the type of
vulnerability under consideration.
The augmented formula (i.e., Fpath ∧ Fdb ∧ Fattack) is
next sent to a solver, which provides a solution (if it ex-
ists) over the values of the input variables, that is an ex-
ploit string. This solution contains the values of the in-
put variables, which, after the path and sanitizations ex-
ecutions, cause the attack string to appear at the sink.
However, even if a solution exists, the related exploit
is not necessarily feasible. To determine its feasibility,
NAVEX needs to uncover the sequence of HTTP requests
that must be sent to the application to execute the attack
described by the exploit strings. This step is exposed in