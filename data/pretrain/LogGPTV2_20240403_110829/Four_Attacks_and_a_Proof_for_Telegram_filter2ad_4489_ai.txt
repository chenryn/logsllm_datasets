SHACAL-1(Dshacal
OTPRF)
SHACAL-2, 𝜙KDF, 𝜙SHACAL-2
CH (DIND) ≤ 4 ·(cid:16)Advotprf
+ Advlrkprf
(cid:22) ℓ + 256
+ Advhrkprf
+
+ 𝑞Ch · (𝑞Ch − 1)
2128
CBC[AES-256](DOTIND$).
+ 2 · Advotind$
(DHRKPRF)
· Advotprf
+ pb + 1
4
(DLRKPRF)
OTPRF)(cid:17)
(Dcompr
SHACAL-2, 𝜙MAC
512
H
(cid:23)
Qualitatively, Corollary 1 shows that the conﬁdentiality of
the MTProto-based channel depends on whether SHACAL-1
and SHACAL-2 can be considered as pseudorandom functions
in a variety of modes: with keys used only once, related keys,
partially chosen-keys when evaluated on ﬁxed inputs and when
the key and input switch positions. Especially the related-key
assumptions (LRKPRF and HRKPRF given in Section V-B) are
highly unusual; both assumptions hold in the ideal cipher model,
but require further study in the standard model. Quantitatively,
a limiting term in the advantage, which implies security only
if 𝑞Ch  kMaxMessageLength ) {
LOG (( " TCP Error : bad messageLength %1 " ). arg (
messageLength ));
TCP_LOG (( " TCP Error : bad message %1 " ). arg (
Logs :: mb ( ints ,
intsCount * kIntSize ). str ()));
return restart ();
}
// ...
// MAC computation and check follow
3) Discussion: Note that all three of the Desktop, Android
and iOS clients were in violation of Telegram’s own security
guidelines [42] which state: “If an error is encountered before
this check could be performed, the client must perform the
msg_key check anyway before returning any result. Note that
the response to any error encountered before the msg_key
check must be the same as the response to a failed msg_key
check.” In contrast, TDLib [11], the cross-platform library for
building Telegram clients, does avoid timing leaks by running
the MAC check ﬁrst.
4) Practical experiments: We ran experiments to verify
whether the side channel present in the desktop client code
25Note that this beats random guessing as the correct value can be recognised.
is exploitable. We measured the time difference between
processing a message with a wrong msg_length and processing
a message with a correct msg_length but a wrong MAC. This
was done using the Linux desktop client, modiﬁed to process
messages generated on the client side without engaging the
network. We collected data for 108 trials for each case under
ideal conditions, i.e. with hyper-threading, Turbo Boost etc.
disabled. After removing outliers, the difference in means was
about 3 microseconds, see Fig. 27. This should be sufﬁciently
large for a remote attacker to detect, even with network and
other noise sources (cf. [43], where sub-microsecond timing
differences were successfully resolved over a LAN).
Figure
time
handleReceived in microseconds.
Processing
27:
of
SessionPrivate::
VII. Discussion
The central result of this work is that the use of sym-
metric encryption in Telegram’s MTProto 2.0 can provide
the basic security expected from a bidirectional channel if
small modiﬁcations are made. The Telegram developers have
indicated that they implemented most of these changes. Thus,
our work can give some assurance to those reliant on Telegram
providing conﬁdential and integrity-protected cloud chats – at
a comparable level to chat protocols that run over TLS’s record
protocol. However, our work comes with a host of caveats.
Attacks: Our work also presents attacks against the symmetric
encryption in Telegram. These highlight the gap between
the variant of MTProto 2.0 that we model and Telegram’s
implementations. While the reordering attack in Section IV-B1
and the attack on IND-CPA security in Section IV-B2 were
possible against implementations that we studied, they can
easily be avoided without making changes to the on-the-wire
format of MTProto, i.e. by only changing processing in clients
and servers. After disclosing our ﬁndings, Telegram informed
us that they have changed this processing accordingly.
Our attacks in Section VI are attacks on the implementation.
As such, they can be considered outside the model: our
model only shows that there can be secure instantiations of
MTProto but does not cover the actual implementations; in
particular, we do not model timing differences. That said,
protocol design has a signiﬁcant impact on the ease with which
secure implementations can be achieved. Here, the decision
Authorized licensed use limited to: Tsinghua University. Downloaded on August 07,2022 at 12:21:42 UTC from IEEE Xplore.  Restrictions apply. 
104
29303132333435020000004000000lengthMACin MTProto to adopt Encrypt & MAC results in the potential
for a leak that we can exploit in speciﬁc implementations.
This “brittleness” of MTProto is of particular relevance due
to the surfeit of implementations of the protocol, and the
fact that security advice may not be heeded by all authors.26
Here Telegram’s apparent ambition to provide TDLib as a one-
stop solution for clients across platforms will allow security
researchers to focus their efforts. We thus recommend that
Telegram replaces the low-level cryptographic processing in
all ofﬁcial clients with a carefully vetted library.
Tightness: On the other hand, our proofs are not necessarily
tight. That is, our theorem statements contain terms bounding
the advantage by ≈ 𝑞/264 where 𝑞 is the number of queries
sent by the adversary. Yet, we have no attacks matching these
bounds (our attacks with complexity 264 are outside the model).
Thus, it is possible that a reﬁned analysis would yield tighter
bounds.
Future work: Our attack in Appendix A is against the
implementation of Telegram’s key exchange and is thus outside
of our model for two reasons: as before, we do not consider
timing side channels in our model and, critically, we only
model the symmetric part of MTProto. This highlights a second
signiﬁcant caveat for our results that large parts of Telegram’s
design remain unstudied: multi-user security, the key exchange,
the higher-level message processing, secret chats, forward
secrecy, control messages, bot APIs, CDNs, cloud storage,
the Passport feature, to name but a few. These are pressing