title:Improving Host Security with System Call Policies
author:Niels Provos
USENIX Association
Proceedings of the
12th USENIX Security Symposium
Washington, D.C., USA
August 4–8, 2003
© 2003 by The USENIX Association
Phone: 1 510 528 8649
FAX: 1 510 548 5738
THE ADVANCED COMPUTING SYSTEMS ASSOCIATION
All Rights Reserved
Email: PI:EMAIL
For more information about the USENIX Association:
WWW: http://www.usenix.org
Rights to individual papers remain with the author or the author's employer.
 Permission is granted for noncommercial reproduction of the work for educational or research purposes.
This copyright notice must be included in the reproduced paper. USENIX acknowledges all trademarks herein.
Improving Host Security with System Call Policies
Niels Provos
Center for Information Technology Integration
University of Michigan
PI:EMAIL
Abstract
We introduce a system that eliminates the need to
run programs in privileged process contexts. Using our
system, programs run unprivileged but may execute cer-
tain operations with elevated privileges as determined
by a conﬁgurable policy eliminating the need for suid
or sgid binaries. We present the design and analysis
of the “Systrace” facility which supports ﬁne grained
process conﬁnement, intrusion detection, auditing and
privilege elevation.
It also facilitates the often diﬃ-
cult process of policy generation. With Systrace, it is
possible to generate policies automatically in a training
session or generate them interactively during program
execution. The policies describe the desired behavior of
services or user applications on a system call level and
are enforced to prevent operations that are not explic-
itly permitted. We show that Systrace is eﬃcient and
does not impose signiﬁcant performance penalties.
1 Introduction
Computer security is increasing in importance as
more business is conducted over the Internet. Despite
decades of research and experience, we are still unable
to make secure computer systems or even measure their
security.
We take for granted that applications will always
contain exploitable bugs that may lead to unauthorized
access [4]. There are several venues that an adversary
may choose to abuse vulnerabilities, both locally or
remotely. To improve the security of a computer sys-
tem, we try to layer diﬀerent security mechanisms on
top of each other in the hope that one of them will be
able to fend oﬀ a malicious attack. These layers may
include ﬁrewalls to restrict network access, operating
system primitives like non-executable stacks or appli-
cation level protections like privilege separation [30]. In
theory and practice, security increases with the num-
ber of layers that need to be circumvented for an attack
to be successful.
Firewalls can prevent remote login and restrict ac-
cess, for example to a web server only [12]. However,
an adversary who successfully exploits a bug in the
web server and gains its privileges may possibly use
them in subsequent attacks to gain even more privi-
leges. With local access to a system, an adversary may
obtain root privileges, e.g., by exploiting setuid pro-
grams [5, 11], using localhost network access or special
system calls [8].
To recover quickly from a security breach, it is im-
portant to detect intrusions and to keep audit trails for
post-mortem analysis. Although there are many intru-
sion detection systems that analyze network traﬃc [27]
or host system activity [21] to infer attacks, it is often
possible for a careful intruder to evade them [31, 36].
Instead of detecting intrusions, we may try to con-
ﬁne the adversary and limit the damage she can cause.
For ﬁlesystems, access control lists [15, 32] allow us
to limit who may read or write ﬁles. Even though
ACLs are more versatile than the traditional Unix ac-
cess model, they do not allow complete conﬁnement of
an adversary and are diﬃcult to conﬁgure.
We observe that the only way to make persistent
changes to the system is through system calls. They
are the gateway to privileged kernel operations. By
monitoring and restricting system calls, an application
may be prevented from causing harm. Solutions based
on system call interposition have been developed in the
past [20, 24]. System call interposition allows these
systems to detect intrusions as policy violations and
prevent them while they are happening. However, the
problem of specifying an accurate policy still remains.
This paper presents Systrace, a solution that eﬃ-
ciently conﬁnes multiple applications, supports mul-
tiple policies, interactive policy generation, intrusion
detection and prevention, and that can be used to
generate audit logs. Furthermore, we present a novel
approach called privilege elevation that eliminates the
need for setuid or setgid binaries. We discuss the de-
sign and implementation of Systrace and show that it is
an extensible and eﬃcient solution to the host security
USENIX Association
12th USENIX Security Symposium 
257
problem.
The remainder of the paper is organized as follows.
Section 2 discusses related work.
In Section 3, we
provide further motivation for our work. Section 4
presents the design of Systrace and Section 5 discusses
its implementation. We present an analysis of the sys-
tem in Section 6. In Section 7, we present a detailed
performance analysis of our system. We discuss future
work in Section 8 and conclude in Section 9.
2 Related Work
[26] and access
Although capabilities
control
lists [15, 32] extend the traditional Unix access model
to provide ﬁner-grained controls, they do not prevent
untrusted applications from causing damage. Instead,
we may use mechanisms based on system call inter-
ception or system call interposition to prevent damage
from successful intrusions.
Janus, by Goldberg et al. [20], is one of the ﬁrst
system call interception tools. It uses the ptrace and
/proc mechanisms. Wagner states that ptrace is not a
suitable interface for system call interception, e.g., race
conditions in the interface allow an adversary to com-
pletely escape the sandbox [37]. The original Janus im-
plementation has several drawbacks: Applications are
not allowed to change their working directory or call
chroot because Janus cannot keep track of the appli-
cation’s changed state. Janus has evolved signiﬁcantly
over time and its latest version uses a hybrid approach
similar to Systrace to get direct control of system call
processing in the operating system [18].
One particularly diﬃcult problem in application
conﬁnement is symlinks, which redirect ﬁlesystem ac-
cess almost arbitrarily. Garﬁnkel introduces safe call-
ing sequences that do not follow any symlinks [18].
The approach uses an extension to the open system
call that is speciﬁc to the Linux operating system but
breaks any application that accesses ﬁlenames contain-
ing symlinks. Systrace solves this problem using ﬁle-
name normalization and argument replacement. Cur-
rently, Janus does not address intrusion detection, au-
diting or policy generation.
Jain and Sekar [24] oﬀer another fairly complete
treatment of system call interposition. On some sys-
tems their implementation is based on ptrace and suf-
fers the problems mentioned above. Furthermore, they
do not address the problem of naming ambiguities that
may result in policy circumvention. Because C++
is used as their policy language, creating comprehen-
sive policies is diﬃcult. Systrace, on the other hand,
supports automatic and interactive policy generation
which allows us to create policies quickly even in very
complex environments.
Other systems that use mechanisms like system call
interception are BlueBox [10], Cerb [14], Consh [2],
MAPbox [1] and Subterfugue [13].
Peterson et al. present a general-purpose system call
API for conﬁnement of untrusted programs [28]. The
API is ﬂexible but has no provisions for recording audit
trails or intrusion detection. Furthermore, specifying
security policies is labor intensive as the sandbox needs
to be programmed into applications.
Domain Type Enforcement [3, 38] is a kernel-level
approach to restrict system access for all processes de-
pending on their individual domains. A complete DTE
implementation requires extensive changes to the op-
erating system and does not automatically extend to
new subsystems. Because policies are locked down on
system start, users may not create individual policies.
In contrast to Systrace, DTE domains do not diﬀeren-
tiate between users. We feel that system call interpo-
sition oﬀers higher ﬂexibility as it allows us to design
and create a simple system that also addresses policy
generation, audit trails, intrusion detection, etc.
The security architecture for the Flask microkernel
emphasizes policy ﬂexibility and rejects the system call
interception mechanism claiming inherent limitations
that restrict policy ﬂexibility [34]. Instead, the Flask
system assigns security identiﬁers to every object and
employs a security server for policy decisions and an
object server for policy enforcement. However, Sys-
trace uses a hybrid design that allows us to overcome
the traditional limitations of system call interception;
see Section 6.
SubOS [23] takes a similar approach based on object
labeling to restrict access to the system. Depending on
their origin, objects are assigned sub-user identiﬁers. A
process that accesses an object inherits its sub-user id
and corresponding restrictions. As a result, a process
subverted by a malicious object may cause only limited
damage. In practice, there are only a few applications
that can be subverted that way and enforcing security
policies for these applications is suﬃcient to prevent
malicious data from causing damage.
Forrest et al. analyze system call sequences to dis-
criminate between processes [16]. Their work is ex-
tended by Hofmeyer et al. to achieve intrusion detec-
tion by recording the system calls that an application
executes and comparing the recorded sequences against
a database of good sequences [21]. Abnormal sequences
indicate an ongoing intrusion. The training process
that collects good system call sequences is similar to
the automatic policy generation feature of Systrace.
Wespi et al.
further extend this approach by using
258
12th USENIX Security Symposium 
USENIX Association
variable-length patterns to match audit events [39]. Al-
though analyzing system call or audit sequences is an
eﬀective mechanism to detect intrusions, it does not
help to prevent them. Recent research also shows that
mimicry attacks can evade intrusion detection system
based on system call sequences [35, 36]. Systrace not
only detects such intrusions, it can also prevent them
or at least limit the damage they can cause. Further-
more, evasion attacks are not possible as we discuss in
Section 6.
3 Motivation and Threat Model
Most applications that run on computer systems are
too complex and complicated to trust: web browsers,
name servers, etc. Even with access to the source code,
it is diﬃcult to reason about the security of these appli-
cations. They might harbor malicious code or contain
bugs that are exploitable by carefully crafted input.
Because it is not possible to ﬁnd all vulnerabilities,
we assume the existence of programming errors known
to the adversary that she can use to gain unauthorized
access to the system.
We limit the impact an adversary can have on the
system by restricting the operations an application is
allowed to execute. The observation that changes rele-
vant to security are performed via system calls makes
the enforcement of restrictions at the system call level
a natural choice.
An application is conﬁned by a set of restrictions
which are expressed by a security policy. Deﬁning
a correct policy is diﬃcult and not possible without
knowing all possible code paths that an uncompro-
mised application may take. Therefore we require the
policy language to be intuitive while still expressive.
It should be possible to generate policies without com-
plete knowledge of an application.
We may use the security policy as a speciﬁcation
that describes the expected behavior of an applica-
tion. When monitoring the operations an application
attempts to execute, any deviation from the speciﬁed
policy indicates a security compromise [25]. To further
facilitate forensic analysis of an intrusion, we also wish
to generate an audit log of previous operations related
to the application.
Experience shows that adversaries escalate their
privileges by abusing setuid or setgid programs [5].
These programs are executed by the operating sys-
tem with diﬀerent privileges than the user starting
them. Although increasing privileges is often necessary
for correct operation, the setuid model is too coarse
grained. We aim to provide a ﬁne-grained model that
eliminates the need for setuid binaries and integrates a
method to elevate privilege into a policy language.
Systrace realizes these goals and is an eﬀective im-
provement of host security that limits the damage an
adversary can cause by exploiting application vulnera-
bilities. The next section discusses the design of Sys-
trace.
4 Design
There are several approaches for implementing sys-
tem call interposition. We may use existing intercep-
tion mechanisms to create an implementation com-
pletely in user space, implement the system entirely
at the kernel-level, or choose a hybrid of both. A user
space implementation is often more portable but may
suﬀer a larger performance impact. Furthermore, the
interception mechanism may not provide the required
security guarantees or may make it diﬃcult to keep
track of operating system state like processes exiting
and forking. A notable exception is SLIC [19], a mecha-
nism to create extensible operating systems via system
call interposition. Unfortunately, it is not portable and
adds signiﬁcant complexity to the operating system.
On the other hand, an implementation completely
at the kernel-level is likely to be fast but less portable
and also causes a signiﬁcant increase in the complexity
of the operating system.
We choose a hybrid approach to implement a small
part of the system at the kernel-level. The kernel-level
part supports a fast path for system calls that should
always be allowed or denied. That case should incur
almost no performance penality because it does not
require a context switch to ask a user space policy dae-
mon for a decision.
Some control in the kernel also allows us to make
the system fail-safe, i.e., no application can escape
its sandbox even if there are unforeseen errors that
might cause the monitor itself to terminate. When the
sandboxing process terminates, the kernel terminates
all processes that it was monitoring. Additionally, the
kernel keeps track of creation of new processes and of
processes that exit. Child processes inherit the policy
of their parent.
If the kernel cannot use the fast path for a system
call, it must ask the policy daemon in user space for
a policy decision. In that case, the process is blocked
until the daemon returns with an answer to permit the
system call or to deny it with a certain error code.
Information is exported from the kernel to user space
via a simple yet comprehensive interface.
The user space policy daemon uses the kernel inter-
USENIX Association
12th USENIX Security Symposium 
259
face to start monitoring processes and to get informa-
tion about pending policy decisions or state changes.
The state changes may be process creation, processes
exiting, processes changing uid or gid, and other state
changes.
The daemon may also request information about the
result of a system call. This allows us to know, for ex-
ample if the execve system call has succeeded in replac-
ing the current process image with a new application.
This event can install a new policy from the policy
database.
System call interception does not provide atomicity
between the time a policy decision is made and the
time a system call is executed, i.e. the time of check is
not the time of use (TOCTOU). As a result, an adver-
sary can change the system call before it is executed
but after the policy daemon has inspected it. For ex-
ample, two processes that share parts of their address
space may cooperate to present one set of system call
arguments to the policy daemon and another one to
the kernel. When the kernel suspends the ﬁrst process
to consult the policy daemon, the second process is still
running and may change the system call arguments of
the ﬁrst process after they have been inspected by the
daemon. For ﬁlesystem access, an adversary may also
redirect the access by changing a component in the ﬁle-
name to a symbolic link after the policy check. This
lack of atomicity may allow an adversary to escape the
sandbox.
We prevent these race conditions by replacing the
system call arguments with the arguments that were
resolved and evaluated by Systrace. The replaced ar-
guments reside in kernel address space and are avail-
able to the monitored process via a read-only look-aside
buﬀer. This ensures that the kernel executes only sys-
tem calls that passed the policy check.
Before making a policy decision, the system call and
its arguments are translated into a system independent
human-readable format. The policy language operates
on that translation and does not need to be aware of
system call speciﬁc semantics.
actions are ask, deny or permit plus optional ﬂags. If
the boolean expression evaluates to true, the speciﬁed
action is taken. The ask action requires the user to
deny or permit the system call explicitly.
A boolean expression consists of variables Xn and
the usual logical operators: and, or and not. The
variables Xn are tuples of the form (subject op data),
where subject is the translated name of a system call
argument, data is a string argument, and op a function
with boolean return value that takes subject and data
as arguments.
The set of all lists forms the security policy. For a
given system call, policy evaluation starts at the be-
ginning of the system call speciﬁc list and terminates
with the ﬁrst boolean expression that is true; see Fig-
ure 1. The action from that expression determines if
the system call is denied or allowed.
If no boolean expression becomes true, the policy
decision is forwarded to the user of the application or
automatically denied depending on the conﬁguration.
Section 4.2 explains in more detail how this mechanism
is used to generate policies interactively or automati-
cally. When denying a system call, it is possible to
specify which error code is passed to the monitored
application.
To create comprehensive policies that apply to dif-
ferent users, policy statements may carry predicates.
A policy statement is evaluated only if its predicate
matches and ignored otherwise. Using predicates, it is
possible to restrict the actions of certain users or be
more permissive with others, for example system ad-
ministrators. Predicates are appended to the policy
statement and are of the form if {user,group} op data,
where op is either equality or inequality and data a user
or group name.
The log modiﬁer may be added to a policy statement
to record matching system calls. Every time a system
call matches this policy statement, the operating sys-
tem records all information about the system call and
the resulting policy decision. This allows us to create
arbitrarily ﬁne-grained audit trails.
4.1 Policy
4.2 Policy Generation
Existing frameworks for making policy decisions
propose generic policy languages [6, 7] and provide pol-
icy evaluation methods but are more complex than nec-
essary in our case. For that reason, we create our own
policy language and evaluator. This approach has also
been taken by other sandboxing tools [1, 20].
We use an ordered list of policy statements per sys-
tem call. A policy statement is a boolean expression B
combined with an action clause: B then action. Valid
Creating policies is usually relegated to the user who
wishes to sandbox applications. Policy generation is
not an easy task as some policy languages resemble
complicated programming languages [24]. Although
those languages are very expressive, the diﬃculty of