Message1之后也可以在收到所有客户端的连接请求之后。最后group message 1
也包含了现有组密钥的收到重放计数器，这个字段是图1的RSC字段所有的组密钥握手消息都是使用EAPOL格式帧，使用Group1和Group2在图2中代表。注意组消息1存储了新的组密钥在数据字段中（使用KEK确认密钥加密）、所以只要PTK被安装之后，完整的EAPOL格式帧都被数据机密性协议保护。
最后，当客户端发送一个广播或者多播帧，她首先需要发送单播给AP，AP对这个数据帧使用组密钥加密，然后广播给所有的客户端。这保证了所有的在AP范围内的客户端都能收到消息。
**0x03 攻击四次握手**
**3.1 请求状态机**
802.11i的修订没有一个正式的描述Supplicant如何实现四次握手。相反，它只提供了如何实现的伪代码，并没有说明握手包将在何时被处理。幸运的是，802.11r略微扩展了四次握手，并详细描述了请求状态机该如何实现。图2包括了这个状态机的简单描述。
当第一次连接一个网络并且开始四次握手的时候，状态机会进入PTK_INIT状态。在这里，它将初始化PMK。当Supplicant接收到信息1的时候，会进入PTK-START阶段。这个经常在第一次连入一个网络的时候，或者是在前一个四次握手完成之后，会话密钥需要更新的时候。当进入PTK-START阶段，Supplicant会随机生成一个SNonce，计算一个临时PTK（TPTK），并且在信息2中将SNonce发送给Authenticator。Authenticator随后会回复Message
3，其将在MIC和重传计数器有效的时候被Supplicant所接受。如果成功，将进入PTK-NEGOTIATING状态，在这里若是TPTK和PTK相同时，Supplicant会发送Message
4给Authenticator。紧接着，就会进入PTK-DONE阶段，在这里PTK和GTK都会被装载，并且被用在数据保密协议以及密钥管理请求的完整性。最终，它会打开802.1x的端口，让Supplicant能够正常接收和发送数据包。注意，这个状态机会在Authenticator没接收到信息2和4的时候，分别重复发送信息1和3。
我们确认802.11r的状态机符合在802.11i的修订中通过文字描述的状态机。最重要的是，我们能够进行重装密钥攻击的两个要素。第一，802.11i的状态机中，AP会在没有接受到回复的时候重传消息1和3。因此，客户端必须接受这重传的信息1和3，来和802.11r的状态机相匹配。更多的，802.11i状态机要求客户端在接受并且回复Message
3之后要装载PTK。这点也和802.11r中提供的状态机相匹配。
**3.2 密钥重载攻击**
我们的密钥重载攻击现在很容易理解：因为Supplicant即使在PTK-Done阶段，依旧持续接受重传的Message3，我们就可以强制重载PTK。更确切地说，我们第一步在Supplicant和Authenticator中建立一个中间人（MitM）的身份。我们是用这个中间人的身份来进行Message
3的重放，并阻止Authenticator接受Message 4。这就导致了，当重放Message
3的时候，Supplicant就会重载一个已经被使用过的PTK。反过来说，这个会重置被用在数据保密协议中的Nonce。取决于不同协议的使用，这有可能造成数据包的重放、解密以及伪造。在6.1节中，我们会详细描述Nonce的重用会在不同协议中有什么实际的影响。
在攻击实践中，可能会遇到一些问题。首先，不是所有Wi-Fi设备都正确实现了状态机。特别是Windows和iOS，它们不接受Message
3的重传。这和802.11标准是相违背的。总的来说，这些错误的实现并不会被我们的针对四次握手的密钥重载攻击所影响。不幸的是，从防御者的角度来说，iOS和Windows设备依旧会被我们针对组密钥的攻击所影响。另外，因为他们都支持802.11r，因此他们依旧有可能被针对AP的密钥重载攻击所影响。
第二个主要障碍是我们需要在AP和Client中获得一个中间人（MitM）的身份。这可能不能通过使用一个不同MAC地址的恶意AP在真实AP和Client间转发数据包来实现。在2.3节中提到，会话密钥（session
key）是基于Client和AP的MAC地址来生成的，这意味着不同的MAC会生成不同的密钥。这会导致握手过程以及攻击过程的失败。为了解决这个问题，我们可以部署基于频段的中间人攻击，在不同频段部署和目标AP相同MAC的恶意AP来实现。这个保证了Client和AP能产生一样的会话密钥。
第三个障碍是某些实现在PTK已经被加载的时候，只接受被数据保密协议所保护的数据包。这对我们的攻击是一个问题，因为Authenticator会在不加密的情况下重传Message
3。这意味着这些重传信息会被Supplicant所忽略。即使这看起来会阻碍我们的攻击，但是我们发现了一个技术手段来绕过这个问题（3.4节）
在接下来的两节中，我们会描述如何使用我们的密钥重载攻击在不同情况下来攻击四次握手实现的细节。更确切地说，我们会先描述在Client（受害者）接受明文重传Message
3的情况。然后我们会演示对只接受加密重传Message
3的客户端的攻击。表1第6列里总结了哪些设备会在针对四次握手的不同的密钥重载攻击中受影响。不同设备的表现取决于操作系统以及被使用的无线网络设备。例如，即使Linux接受明文的重传Message
3，但是在某些Android设备里使用的网卡会拒绝它们。因此，使用不同无线芯片的Android设备事实上可能会接受明文的重传Message 3。
表1
**3.3 明文重传Message 3**
如果受害者在加载完会话密钥之后，依旧接受明文重传Message
3的话，我们的密钥重载攻击就很简单了。首先，攻击者会使用基于频段的中间人攻击，因此她可以控制握手包。然后她能够阻止Authenticator接受Message
4。这就是图4里的第一阶段。在发送Message
4之后很快，受害者就会装载PTK以及GTK密钥。在这种情况下，受害者依然会打开802.11x端口，并且开始传输正常数据。注意一点，在数据保密协议中的第一个数据包使用的Nonce是1。然后，在攻击的第三阶段，Authenticator会因为没有收到Message
4而重传Message 3。攻击者可以转发重传Message
3给受害者，导致它重新装载PTK和GTK。总的来说，这样会重置数据保密协议使用的Nonce和防重传计数器。注意一点，攻击者不能够重放旧的Message
3，因为EAPOL的重传计数器没有被刷新。我们现在暂时忽略攻击的阶段4。最后，当受害者传输它下一个数据帧时，数据保密协议就会使用旧的Nonce。这意味着攻击者可以在转发重传Message
3给受害者前等待任意的时间。因此，我们可以控制一定数量的会被重用的Nonce。更多的，攻击者可以一直对Client进行掉线攻击（deauthenticating），直至它重新连入网络并执行新的四次握手的过程。
图4
图4同样展示了我们的密钥重载攻击会在Message 4由于背景噪声而丢失的时候自发地出现。不同的是，接受明文重传Message
3的Client，可能会在没有攻击者的情况下重用Nonce。在这种情况下，一个攻击者可以选择性地阻塞Message 4，来区分攻击和随机背景噪声的干扰。
我们现在回到攻击的阶段4。这个阶段的目标是完成Authenticator部分的握手阶段。这不是很重要，因为受害者已经加载了PTK，这意味着它的下一个Message
4是被加密的。在Authenticator还未加载PTK时，它通常会拒绝已加密的Message
4。因此，802.11标准里揭示了Authenticator需要接受具有任意重传计数器的四次握手包，而不仅仅是最后一个。
接受Message 4的时候，Authenticator验证Key Replay Counter字段值在当前四次握手过程中使用的。
在实践中，我们发现一些AP确实接受具有旧的重传计数器的数据包。更确切的说，一些AP接受在被发送给Client数据包中使用，并且还未被Client发送回来的重传计数器。这些AP会接受旧的未加密的Message
4，就是图4里的重传计数器r+1。总的来说，这些AP会装载PTK，并且开始发送加密的单播数据帧给Client。
虽然图4只说明了Client发送的Nonce重用情况，我们的攻击同样允许我们重放数据帧。首先，在Client在阶段3中重载GTK之后，AP之后通过广播和多播的重传Message
3是可以被重放的。这是因为在重载密钥的时候，重传计数器也被重置了。第二，如果我们能够让AP装载PTK，我们同样能重放从AP单播给Client的数据帧。
我们确认，在图4中的攻击在MediaTek的Wi-Fi设备和特定版本的wpa_supplicant下是有效的。我们将在下一节解释我们攻击的另外一种实现。
**3.4 加密重传Message 3**
我们现在来解释我们是如何攻击那些一旦装载了PTK就只接受加密重传Message3的Client的。为了完成这个，我们利用一个使用了数据保密协议的实体在执行四次握手的时候的一个内在的竞争条件。
图5
就像先前说的，我们先来攻击Android上所实现的Supplicant。在这里，我们发现当明文重传Message 3被紧接着原始Message
3发送的时候，Android会接收这个重传信息。图5表明了为什么会发生这个情况，并且我们该如何利用它。注意一下就是，图5里并没有AP，因为AP的反应在上文中已经描述的很清楚了。在我们的攻击中，首先让Client和AP交换信息1,2。然后我们不将第一个Message
3转发给Client，而是等着AP重传第二个Message 3，在攻击的第二阶段，我们接连发送两个Message
3给Client。这时候，实现了数据保密协议的无线网卡还没有装载PTK，于是就将收到的两个包按顺序转发给CPU。这个实现了四次握手的CPU接受了第一个Message
3，并且让无线网卡装载PTK。在攻击的阶段4里，Client的CPU从接受序列里得到了第二个Message