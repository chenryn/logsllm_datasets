tectors.
In Proceedings of the ACM SIGSOFT Inter-
national Symposium on Software Testing and Analysis
2004 (ISSTA’04), pages 34–44, Boston, MA, USA, July
2004. ACM Press.
[9] M. Ciubotariu. Netsky: a conﬂict starter? Virus Bul-
letin, pages 4–8, May 2004.
[10] F. Cohen. Computer viruses: Theory and experiments.
Computers and Security, 6:22–35, 1987.
[11] J. Corbett, M. Dwyer, J. Hatcliff, C. Pasareanu, Robby,
S. Laubach, and H. Zheng. Bandera: Extracting ﬁnite-
state models from Java source code. In Proceedings of
the 22nd International Conference on Software Engi-
neering (ICSE’00), pages 439–448. ACM Press, 2000.
[12] D. W. Currie, A. J. Hu, and S. Rajan. Automatic formal
veriﬁcation of DSP software. In Proceedings of the 37th
Annual ACM IEEE Conference on Design Automation
(DAC’00), pages 130–135. ACM Press, 2000.
[13] DataRescue sa/nv. IDA Pro – interactive disassembler.
Published online at http://www.datarescue.
com/idabase/. Last accessed on 3 Feb. 2003.
[14] D. Detlefs, G. Nelson, and J. Saxe. The Simplify theo-
rem prover. Published online at http://research.
compaq.com/SRC/esc/Simplify.html. Last
accessed on 10 Nov. 2004.
[15] U. Erlingsson and F. B. Schneider.
IRM enforce-
ment of Java stack inspection.
In Proceedings of the
2000 IEEE Symposium on Security and Privacy (Oak-
land’00), pages 246–255, May 2000.
[16] X. Feng and A. J. Hu. Automatic formal veriﬁcation
for scheduled VLIW code. In Proceedings of the Joint
Conference on Languages, Compilers and Tools for Em-
bedded Systems & Software and Compilers for Embed-
ded Systems (LCTES/SCOPES’02), pages 85–92. ACM
Press, 2002.
[17] J. Gordon. Lessons from virus developers: The Beagle
worm history through April 24, 2004. In SecurityFocus
Guest Feature Forum. SecurityFocus, May 2004. Pub-
lished online at http://www.securityfocus.
com/guest/24228. Last accessed: 9 Sep. 2004.
[18] L. A. Gordon, M. P. Loeb, W. Lucyshyn, and
R. Richardson. 2004 CSI/FBI computer crime and se-
curity survey. Technical report, Computer Security In-
stitute, 2004.
[19] T. Jensen, D. M´etayer, and T. Thorn. Veriﬁcation of
control ﬂow based security properties. In Proceedings
of the 1999 IEEE Symposium on Security and Privacy
(Oakland’99), May 1999.
[20] C. Kruegel, W. Robertson, F. Valeur, and G. Vigna.
Static disassembly of obfuscated binaries. In Proceed-
ings of the 13th USENIX Security Symposium (Secu-
rity’04), San Diego, CA, Aug. 2004.
[21] C. Kruegel, W. Robertson, and G. Vigna. Detecting
kernel-level rootkits through binary analysis.
In Pro-
ceedings of the 20th Annual Computer Security Ap-
plications Conference (ACSAC’04), Tucson, AZ, Dec.
2004.
[22] S. K. Lahiri and S. A. Seshia. The UCLID decision pro-
cedure. In R. Alur and D. A. Peled, editors, Proceed-
ings of the 16th International Conference on Computer
Aided Veriﬁcation (CAV’04), volume 3114 of Lecture
Notes in Computer Science, pages 475–478, Boston,
MA, USA, July 2004. Springer-Verlag Heidelberg.
[23] C. Linn and S. Debray. Obfuscation of executable code
to improve resistance to static disassembly.
In Pro-
ceedings of the 10th ACM Conference on Computer and
Communications Security (CCS’03), Oct. 2003.
[24] R. Lo, K. Levitt, and R. Olsson. MCF: A malicious code
ﬁlter. Computers & Society, 14(6):541–566, 1995.
Proceedings of the 2005 IEEE Symposium on Security and Privacy (S&P’05) 
1081-6011/05 $ 20.00 IEEE
[25] LURHQ Threat Intelligence Group. Sobig.a and the
spam you received today. Technical report, LURHQ,
2003.
Published online at http://www.lurhq.
com/sobig.html. Last accessed on 16 Jan. 2004.
[26] LURHQ Threat Intelligence Group. Sobig.e - Evo-
Technical report, LURHQ,
lution of the worm.
2003.
Published online at http://www.lurhq.
com/sobig-e.html. Last accessed on 16 Jan. 2004.
[27] LURHQ Threat Intelligence Group. Sobig.f examined.
Technical report, LURHQ, 2003. Published online at
http://www.lurhq.com/sobig-f.html. Last
accessed on 16 Jan. 2004.
[28] A. Marinescu. Russian doll. Virus Bulletin, pages 7–9,
Aug. 2003.
[29] G. McGraw and G. Morrisett. Attacking malicious
code: report to the Infosec research council. IEEE Soft-
ware, 17(5):33 – 41, Sept./Oct. 2000.
[30] C. Nachenberg. Computer virus-antivirus coevolution.
Communications of the ACM, 40(1):46–51, Jan. 1997.
[31] G. C. Necula. Translation validation for an optimiz-
ing compiler.
In Proceedings of the ACM SIGPLAN
2000 Conference on Programming Language Design
and Implementation (PLDI’00), pages 83–94. ACM
Press, June 2000.
[32] A. Pnueli, M. Siegel, and E. Singerman. Translation
validation.
In Proceedings of the 4th International
Conference on Tools and Algorithms for Construction
and Analysis of Systems (TACAS’98), volume 1384 of
Lecture Notes in Computer Science, pages 151–166.
Springer-Verlag Heidelberg, Mar. 1998.
[33] P. Singh and A. Lakhotia. Analysis and detection of
computer viruses and worms: An annotated bibliogra-
phy. ACM SIGPLAN Notices, 37(2):29–35, Feb. 2002.
[34] D. Spinellis. Reliable identiﬁcation of bounded-length
IEEE Transactions on Infor-
viruses is NP-complete.
mation Theory, 49(1):280–284, Jan. 2003.
[35] P. Sz¨or and P. Ferrie. Hunting for metamorphic.
In
the 2001 Virus Bulletin Conference
Proceedings of
(VB2001), pages 123 – 144, Sept. 2001.
[36] z0mbie.
z0mbie’s homepage.
Published online at
http://z0mbie.host.sk. Last accessed: 16 Jan.
2004.
A. Proof of Theorem 2
Let P be a program and T a template such that
AM D(P, T ) returns yes. Let f be a function from the
set of nodes of P to nodes in T that satisfy the two
conditions given in section 3 (such a function exists be-
cause the AM D(P, T ) returned yes). We will prove that
P |= T .
There are two set of states - one for the program
(which we simply refer to as state) and other for the
template (which we refer to as template state). Re-
call that a state s of program is a 3-tuple comprising
of an assignment val(s) of values to registers, value
pc(s) for the program counter, and the memory con-
tents mem(s). Consider a node n in the template T and
a node m in P such that f(m) = n. Let s be a state
Proceedings of the 2005 IEEE Symposium on Security and Privacy (S&P’05) 
1081-6011/05 $ 20.00 IEEE
such that pc(s) = m (in this proof we equate the pro-
gram counter with the CFG node it corresponds to), and
B(·, n, m) be the binding. We deﬁne a template state
corresponding to s (denoted by T (s)) as follows:
• Let B(val(s)) be the assignment implied by the bind-
ing B, i.e., B(val(s))(X) is equal to the value of the
expression B(X, n, m) in the state s.
• Deﬁne pc(T (s)) to be the program counter corre-
sponding to node n.
• Deﬁne mem(T (s)) as mem(s).
0 ) and eT
1 = I(n0)(sT
Let n0 be the initial node of the template and m0
be a node in the program such that f(m0) = n0.
Let s0 be a state such that pc(s0) = m0, and deﬁne
0 as T (s0). Recall that I(n) denotes the instruction
sT
corresponding to node n. Given a state s, I(n)(s) de-
notes the state obtained by executing instruction I(n)
from state s, and e(I(n), s) denotes the event gener-
(cid:1)
ated by executing instruction I(n) from state s. Let s
1
be equal to I(m0)(s0) and e1 be equal to e(I(m0), s0).
0 ). Since n0
1 = e(I(n0), sT
Let sT
1 = e1. Let
and m0 are uniﬁable, it is easy to see that eT
n1 be the template node corresponding to pc(sT
1 ). As-
(cid:1)
sume that in program P , from state s
1 there is a feasible
(cid:1)
(cid:1)
path path(s
1, m1) from pc(s
1) to a node m1, such that
(cid:1)
f(m1) = n1, i.e., executing path(s
1, m1) from state
(cid:1)
1 yields a state s1, such that pc(s1) = m1. We de-
s
e1(cid:2) s1, i.e., there is an execution
note this fact by s0
sequence α that starts at s0 and ends at s1 and the ﬁrst
event generated by α is e1. Thus we obtain the follow-
ing execution sequences in P and T :
e1(cid:2) s1
1→ sT
σ = s0
σT = sT
0
eT
1
Recall that use(n1) is the set of variables used by in-
struction I(n1). For every variable X ∈ use(n1),
value of expression B(X, n1, m1) is unchanged by
(cid:1)
path(s
1, m1). Therefore, executing instruction I(n1)
in the template from the states T (s1) and sT
=
I(n0)(s0) results in same memory accesses, generate
the same event, and transitions to the same node n2 in
the template. We continue augmenting the execution
sequences σ and σT until we obtain a template state sT
k
such that pc(sT
k ) corresponds to the ﬁnal node of the
template. At the end, we have two execution sequences
1
σ = s0
σT = sT
0
e1(cid:2) s1
1→ sT
eT
1
e2(cid:2) s2 ··· ek(cid:2) sk
k→ sk
2 ··· eT
2→ sT
eT
where σ and σT are execution sequences in the program
and the template. Moreover, for 1 ≤ i ≤ k, ei = eT
i
i and T (si) satisfy the following
and template states sT
property:
• Executing instruction I(pc(si)) in the program P
from the state si and instruction I(pc(sT
i )) in the
template from the state T (si) results in same mem-
ory accesses and generate the same event.
• In the template T , executing instruction I(pc(sT
i ))
i and from the state T (si) results in
from the state sT
same memory accesses and generate the same event.
The proof of abovementioned property uses the condi-
tion that def-use paths are preserved by the program.
From the above two observations it is easy to see that
P |= T .
B. Intermediate representation language
The intermediate representation (IR) of a program is
structured as a collection of control ﬂow graphs (CFGs),
each node in the graph corresponding to one IR instruc-
tion. Edges in a CFG are unlabeled, with the exception
of the outgoing edges of a conditional control ﬂow in-
struction. In such a case, the IR instruction is labeled
jump, and the outgoing edges are labeled with the cor-
responding condition that holds true along that branch.
IR instructions are elements in a language with sim-
ple rules, illustrated in Table 6. Each IR instruction (or
IR term) is either an assignment that updates state vari-
ables or a call to other functions in the same program,
or to external functions (library or system routines). An
IR expression uses arithmetic, bit-vector, and relational
operators, as well as the special memory addressing op-
erator.
term ::
expr1 ASSIGN expr2
| CALL expr
expr
op
::
expr1 op expr2
|
ident ( expr, . . . )
| memory [ expr ]
|
ident | number | string
:: OR | AND | XOR | NOT | BITAND
|
|
| GREATERTHAN | LEQ | GEQ
|
|
BITOR | BITXOR | BITNOT
EQUAL | LESSTHAN
BITSHIFTLEFT | BITSHIFTRIGHT
PLUS | MINUS | STAR | DIV | MOD
Table 6. Term algebra for intermediate rep-
resentation (IR) expressions.
proven as semantic nops for the program in Figure 3
to satisfy the template in the same ﬁgure. In Table 7,
we list the 10 def-use chains in the template, the de-
rived value predicates that relate program expressions,
and the corresponding program fragments. The nota-
(cid:1) describes the variable corresponding to the
tion n
def-use path, such that def (n) ∩ use(n
(cid:1)) = {x}.
x→ n
Def-use chain and
value predicate
T1 A→ T3
val post(cid:2)I(cid:3)(ecx − 1)
= val pre(cid:2)I(cid:3)(eax )
T5 A→ T3
val post(cid:2)I(cid:3)(ecx − 1)
= val pre(cid:2)I(cid:3)(eax )
T1 A→ T4
val post(cid:2)I(cid:3)(eax )
= val pre(cid:2)I(cid:3)(eax )
T5 A→ T4
val post(cid:2)I(cid:3)(eax )
= val pre(cid:2)I(cid:3)(eax )
T2 B→ T4
val post(cid:2)I(cid:3)(ebx )
= val pre(cid:2)I(cid:3)(ebx )
T6 B→ T4
val post(cid:2)I(cid:3)(ebx )
= val pre(cid:2)I(cid:3)(ebx )
T1 A→ T5
val post(cid:2)I(cid:3)(eax )
= val pre(cid:2)I(cid:3)(eax )
T5 A→ T5
val post(cid:2)I(cid:3)(eax )
= val pre(cid:2)I(cid:3)(eax )
T2 B→ T6
val post(cid:2)I(cid:3)(ebx )
= val pre(cid:2)I(cid:3)(ebx )
T6 B→ T6
val post(cid:2)I(cid:3)(ebx )
= val pre(cid:2)I(cid:3)(ebx )
Program fragment
2: ebx = 0x400000
3: nop
4: ecx = eax + 1
9: ebx = ebx + 1
4: ecx = eax + 1
2: ebx = 0x400000
3: nop
4: ecx = eax + 1
6: eax = ecx - 1
9: ebx = ebx + 1
4: ecx = eax + 1
6: eax = ecx - 1
3: nop
4: ecx = eax + 1
6: eax = ecx - 1
4: ecx = eax + 1
6: eax = ecx - 1
2: ebx = 0x400000
3: nop
4: ecx = eax + 1
6: eax = ecx - 1
7: mem[ebx] = mem[eax] ˆ 5
9: ebx = ebx + 1
4: ecx = eax + 1
6: eax = ecx - 1
7: mem[ebx] = mem[eax] ˆ 5
3: nop
4: ecx = eax + 1
6: eax = ecx - 1
7: mem[ebx] = mem[eax] ˆ 5
8: eax = eax + 1
4: ecx = eax + 1
6: eax = ecx - 1
7: mem[ebx] = mem[eax] ˆ 5
8: eax = eax + 1
C. Def-use paths and value predicates
We list here the complete set of value predicates
and corresponding program fragments that have to be
Table 7. Def-use paths, value predicates,
and program paths for the example in Fig-
ure 3.
Proceedings of the 2005 IEEE Symposium on Security and Privacy (S&P’05) 
1081-6011/05 $ 20.00 IEEE