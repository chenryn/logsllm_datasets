Over the Air Remote Code 
Execution on the 
DEF CON 27 Badge via NFMI
World’s first NFMI exploitation, sorta
or
OTARCEDC27NFMIOMGWTFBBQ
Agenda
1.
Introduction
2.
Intro to the Badge
3.
Buffer Overflow and Proof of Concept
4.
NFMI Specs
5.
Convert Analog Signal into Symbols
6.
Convert Symbols to Bytes
7.
Reverse Engineer CRC, Craft Packets
8.
Remote Crash the Badge
9.
Hacking NFMI Firmware
10. OTA RCE Demos
Because Any Meeting without an Agenda is a Trap
Introduction
• Seth Kintigh
• Hardware Security Development Lifecycle Engineer a Dell
• Hobbyist programmer since 1987, learned cipher breaking 
from my grandma, mom was meteorologist and COBOL 
programmer, dad is an Electrical Engineer
• WPI graduate
• BS EE with minors in CS and Physics
• MS EE with concentration in crypto and infosec
• Started career as an EE, but shifted to network security in 
2004
• At home at low levels and layers
Near Field Magnetic Inductance (NFMI)
• Short range wireless physical layer that communicates by coupling a tight, low-
power, non-propagating magnetic field between devices. 
• The concept is for a transmitter coil in one device to modulate a magnetic field which is 
measured by means of a receiver coil in another device. [1]
• Not radio!
• Radio waves (electromagnetic waves) decay at 1/r2
• Magnetic fields decay at 1/r6
•
Very short range, 2m tops, 10s of cm badge to badge, a 1-2 cm in my experiments.
•
Short range makes it more secure
• Low absorption by body tissue, unlike radio, good for a “Body Area Network”
• More efficient than radio over short distances
• Used in some hearing aids and some proximity cards as part of the NFC protocol
1: https://en.wikipedia.org/wiki/Near-field_magnetic_induction_communication
2: https://www.nxp.com/products/wireless/miglo/nfmi-radio-for-wireless-audio-and-data-
streaming:NXH2261UK
Almost No Information Available
• Weird levels of secrecy for hearing aid tech (dreams of Apple earbuds?)
• No data sheet (very weird)
• No protocol info at all
• No development kits
• No samples
• NDA required with minimum orders in the 100,000s of units
Software Defined Radio (SDR)
• Functions that were once performed in specialized hardware can now 
be done in software, hence Software Defined Radio
• I used GNURadio to modulate and demodulate signals
• I use HackRF to tune and receive/transmit signals
• Instead of an antenna I use a coil, basically an electromagnet (or half 
of a transformer), to send and receive signals
• I used Python for everything else
• Pulling clean packets out of noise, unmasking/unobfuscating packets, 
convolution and deconvolution of symbols, converting symbols to/from data, 
computing their bizarre CRC format, writing packets into .wav files for 
transmit
Other Terms You Should Know
• Buffer overflow: write data to a stack variable then keep on writing 
until you overwrite the return address of a function. Rewrite the 
return address to some point at your code or somewhere interesting.
• SWD/J-TAG: low level debugging interface for hardware. Like GDB, for 
hardware – read or write registers, memory and flash, step the clock 
one cycle at a time, good stuff.
• Convolution code: In telecommunication, a convolutional code is a 
type of error-correcting code that generates parity symbols via the 
sliding application of a boolean polynomial function to a data 
stream.[1]
[1] https://en.wikipedia.org/wiki/Convolutional_code
The DEF CON 27 Badge Game
• The badges communicate with each other via 
NFMI, also LEDS and beep depending on activity
• They were part of a game:
• Must communicate with 1 each of “magic” versions of 
the badge types: Speaker, Village, Contest, Artist, Goon
• “Prize” is a piezoelectric rick-roll
• Cut from crystalline stone, see great presentation 
on how they were made[2]
[1] http://www.grandideastudio.com/defcon-27-badge/
[2] https://www.youtube.com/watch?v=gnZQcWIX02A
DEF CON 27 Badge Hardware
• Badge has an MCU, NFMI chip, LEDs, and piezoelectric speaker
• MCU communicates to the NFMI chip via UART
• When the MCU boots up, the MCU 
loads the badge firmware
• Within that firmware is an NFMI 
protocol firmware patch
• The MCU sends that firmware patch 
to the NFMI chip during bootup
www.grandideastudio.com/wp-content/uploads/dc27_bdg_slides.pdf
DEF CON 27 Badge Debug Interfaces
www.reddit.com/r/Defcon/comments/cpmpja/defcon_27_badge_hacking_for_beginners/
• There are pads for serial and SWD 
communication with the MCU
• Solder on leads or use pressure connectors
“Depopulating the connectors stops the
hackers!” 
• Serial port shows a terminal interface for 
the badge MCU
• JTAG/SWD allows rewriting of the MCU 
firmware, and full debugging control over 
the MCU, including stepping the clock, 
reading registers, etc.
Padding UART for Fun and Profit
• Badge MCU wants to transmit 8 bytes
• MCU pads that to 18 bytes
• Sends via UART to NFMI chip
• NFMI chip un-pads and transmits
NFMI Transmission
• Receiving NFMI re-pads data
• Sends via UART to MCU
• Badge MCU strips padding, puts data
on ring buffer until it’s ready to process it
Badge 1
UART
MCU
NFMI
“B” D0 D1 D2 D3 D4 D5 D6 D7 
D8 D9 DA DB DC DD DE DF*“E”
01 23 45 67 89 AB CD EF
01 23 45 67 89 AB CD EF
UART
NFMI
MCU
“B” D0 D1 D2 D3 D4 D5 D6 D7 
D8 D9 DA DB DC DD DE DF “E”
01 23 45 67 89 AB CD EF
01 23 45 67 89 AB CD EF
Badge 2
* I’m Ignoring byte reordering
Buffer Overflow
• To find game clues I spent the first few hours reverse engineering the firmware
• Then the source code was released… But I’ve never been given the correct answers before
• Found a buffer overflow so obvious I was sure it was a part of the game
• (Narrator: It wasn’t)
Buffer Overflow Proof of Concept
• I Verified it was exploitable by simulating a large packet
• I started by writing a buffer overflow exploit in ARM code
• I used JTAG to write it directly onto the MCU’s ring buffer for receiving NFMI data
• The badge read the data and executed my code injection, proving it was exploitable 
W1 0x1ffffcd6 0x04  // set nxhTxIndex
w1 20002f00 42  d0 d0 d0 d0
d0 d0 d0 d0
d0 d0 d0 d0
d0 d0 d0 d0 // “B”, 16 bytes of padded nibbles
w1 20002f11 00 00 00 00  11 11 11 11  44 44 44 44  55 55 55 55 // Overwrite other stack vars, R4, R5
w1 20002f21 33 4c 00 00 e5 f1 ff 1f  11 11 11 11  22 22 22 22 // LR→[POP R0-R2,R3,R4,PC], R0→str addr, R1, R2
w1 20002f31 33 33 33 33  44 44 44 44 2d 04 00 00 48 61 63 6b // R3, R4, LR->printf, then my string
w1 20002f41 20 74 68 65 20 70 6c 61 6e 65 74 0d 0a 00 45    // end of string, “E”
w1 0x1ffffcd4 0x51 // set nxhRxIndex
• Demo!
• Now I just needed to do that with a real NFMI transmission
NFMI Specs are Tough to Find
• Some NXP NXH2261UK info in marketing pamphlets, blogs, and FCC filings:
• Center frequency: 10.579 MHz[2][5], 10.6 MHz[1], 10.56 MHz antenna on badge[3]
• 12.288 MHz oscillator?[6]
• Bandwidth: 596 kbps[1][4] and/or 400 kHz[1] or 568.7 kHz[7]
• Supports streaming via I2C?
• D8PSK/8-DPSK modulation[1][7]
• Up to 2 audio Tx, 2 audio Rx[6]
• Firmware suggests it has 8 queues, each 16 bytes (group chat?)
1: https://www.futureelectronics.com/resources/get-connected/2017-06/future-electronics-near-field-magnetic-induction
2: https://www.nxp.com/products/wireless/miglo/nfmi-radio-for-wireless-audio-and-data-streaming:NXH2261UK
3: http://www.grandideastudio.com/wp-content/uploads/dc27_bdg_bom.pdf
4: https://www.nxp.com/docs/en/fact-sheet/MIGLOFS.pdf
5: https://fccid.io/TTUBEOPLAYE8R/RF-Exposure-Info/RFExp-3568435
6: https://www.52audio.com/wp-
content/uploads/2018/06/NXP%E6%81%A9%E6%99%BA%E6%B5%A6%E3%80%8A%E6%81%A9%E6%99%BA%E6%B5%A6%E7%9C%9F%E6%97%A0%E7%BA%BF%E8%80%B3%E6%9C%BA%E5%92
%8C%E4%BD%8E%E5%8A%9F%E8%80%97%E6%B8%B8%E6%88%8F%E8%80%B3%E6%9C%BA%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E3%80%8B.pdf
7: https://apps.fcc.gov/eas/GetApplicationAttachment.html?id=5049516
Start by Analyzing the Analog Signal
• Pattern of 8 bursts every 4.8 seconds (16 bursts shown):
• Each burst has 4 sections (1 burst shown):
1   23    4
Section 1
2
3
Section 4
Raw signal capture, no down-conversion
Sections:
Section 1
• Section 1 is 21 pulses of 3 frequencies then a pause/null
• Appears to be timing signal using/mimicking trinary FSK modulation (TFSK?)
• Center of frequency plot is 10.569MHz, other pulses shifted +/- 150MHz
• Probably to tell the receiver the signal strength and timing, possible frequency info
frequency
magnitude
 Time →
Graphs made with: Baudline, Audacity
Quick Note on Down-Conversion
• This is the raw signal, most energy at 10.569MHz +/- 200KHz:
• Below is the signal when the HackRF is tuned to 10.569MHz, and it 
down-converts the signal by 10.569MHz
• Most energy is now centered at 0Hz +/-200KHz 
• Signals that were at 10.569MHz are now at almost 0Hz (sections 1 and 3)
• Data is more visually obvious (sections 2 and 4)
• It’s the process of shifting a signal to an Intermediate Frequency
frequency
frequency
Section 2: Preambles
• Section 2 held one of a few patterns, often repeated twice, or 
inverted, or with magnitude and phase swapped
Demodulated by 10.56MHz so center appears at 0Hz
Section 3: More Timing?
• Seems to be more timing(/strength/freq) data, communicated with 4 
bursts of the center frequency followed by a pause/null
Mag and phase down-converted
Magnitude with no down-converting
Mag down-converted by 10.569MHz to almost 0Hz
Frequency drift happens
Section 4: Data!
• 271(?!) copies of the data packet
• Each starts with one of 8 variations of Section 2 preamble
• Followed by data
• Then a brief null/pause
• Sometimes exact copies, sometimes inverted, sometimes I and Q swap
D8PSK Modulation
• PSK modulations transmit data by 
modulating a carrier frequency using 
carefully timed cosine “I” and sine “Q’ inputs
• If you plot these signals by magnitude of the 
“in-phase” (I) and “quadrature” (Q) 
components the result is a constellation of 8 
points 
• Each phase is a “symbol” 0-7
• Differential means the information is 
transmitted as the difference between 2 
symbols, modulo 8
• Differential, 8-point constellation, Phase Shift Keying
Frequency and Sample Rate
• Center frequency seems to move
• Different badges have different freqs? Temperature? Sample rates? Anger?
• 1.5515MHz worked for a long time, then 1.4MHz, then 1.569MHz
• Sample rate of 2Msps and 1.192Msps (corresponding to 596kHz 
bandwidth) didn’t work as well as 1.19055Msps (595,275Hz 
bandwidth)
• Latter value gave me 4 samples per symbol, 440 samples per packet
Reverse Engineering the Analog Signal
• HackRF to receive the signal
• Used GNURadio to write a D8PSK demodulator to output symbols
• Nightmare of poor docs, broken examples, months of guessing and checking 
• I published working examples here: https://github.com/skintigh/GNURadio_examples
Dealing with Noise and Nulls
• The 271 copies of section 4 varied a lot, only some of that due to noise
• Structure seems* to be: 3 null symbols, 1 random symbol, then 106 symbols
• Nulls?!?
• Appeared to be noise at first
• Sort of a 9th symbol in D8PSK, the null forms a 
9th dot at the center of the constellation (D9PSK?)
• Related to NXP’s CoolFlux BSP audio chip?
• Uses nulls in a OFDM-DQPSK signal [1]
• Simple to find timing using a low pass filter[1]
* Or maybe random symbol R, 2 nulls, 7-R? Signals have 11 tiny samples that look like: .I…….I.
[1] DSP-Based Implementation of a Digital Radio Demodulator on the ultra-low power processor CoolFlux BSP 
110 Symbols Plotted by Phase and Delay
000000000000000000000000000025453535353535353535353535353573544444444444444444444444444170177177764
000000000000000000000000000027362626253535353535353535353552444453535353535353535353537000700000001
000000000000000000000000000036362535352626262626262535353563444444444444444444535353520700000000077
000000000000000000000000000016353535353535353535353535353513445353535354444444444444434000000000070
000000000000000000000000000105444444444444444444444444444424444444444444444444444444430100000000640