malware-thats-keylogger-ransomware-and-trojan/. Accessed: January 8, 2021.
[21] Duy Phuc Pham, Croese Niels, and Han Sahin Cengiz. Exobot - Android
banking Trojan on the rise. https://www.threatfabric.com/blogs/exobot an-
droid banking trojan on the rise.html. Accessed: January 8, 2021.
[22] Chuangang Ren, Peng Liu, and Sencun Zhu. WindowGuard: Systematic
Protection of GUI Security in Android. In Proceedings of the Network and
Distributed System Security Symposium (NDSS), 2017.
[23] Chuangang Ren, Yulong Zhang, Hui Xue, Tao Wei, and Peng Liu. Towards
Discovering and Understanding Task Hijacking in Android. In Proceedings
of the 24th USENIX Conference on Security Symposium, pages 945–959,
Berkeley, CA, USA, 2015. USENIX Association.
[24] Hossain Shahriar, Tulin Klintic, and Victor Clincy. Mobile Phishing Attacks
and Mitigation Techniques. In Journal of Information Security, volume 06,
pages 206–212, 06 2015.
[25] Yuru Shao, Qi Alfred Chen, Zhuoqing Morley Mao, Jason M Ott, and Zhiyun
Qian. Kratos: Discovering Inconsistent Security Policy Enforcement in the
Android Framework. In Proceedings of the Network and Distributed System
Security Symposium (NDSS), 2016.
[26] Raphael Spreitzer, Felix Kirchengast, Daniel Gruss, and Stefan Mangard.
Procharvester: Fully automated analysis of procfs side-channel leaks on
In Proceedings of the 2018 Asia Conference on Computer and
android.
Communications Security (ASIACCS), pages 749–763, New York, NY, USA,
2018. ACM.
[27] Raphael Spreitzer, Gerald Palfinger, and Stefan Mangard. SCAnDroid:
In Proceedings of
Automated Side-Channel Analysis of Android APIs.
the 11th ACM Conference on Security & Privacy in Wireless and Mobile
Networks (WiSec), pages 224–235, New York, NY, USA, 2018. ACM.
[28] ThreatFabric.
afterlife.
https://www.threatfabric.com/blogs/anubis 2 malware and afterlife.html.
Accessed: January 8, 2021.
- malware
Anubis
and
II
[29] ThreatFabric. BianLian - from rags to riches, the malware dropper that had
a dream. https://www.threatfabric.com/blogs/bianlian from rags to riches -
the malware dropper that had a dream.html. Accessed: January 8, 2021.
[30] Federico Tomassetti. JavaParser - Parser and Abstract Syntax Tree for Java.
https://github.com/javaparser/javaparser. Accessed: January 8, 2021.
[31] Ventura Vitor.
Gustuff
banking
botnet
targets Australia.
https://blog.talosintelligence.com/2019/04/gustuff-targets-australia.html.
Accessed: January 8, 2021.
[32] Gahr Wesley, Duy Phuc Pham, and Croese Niels. LokiBot - The first hybrid
Android malware. https://www.threatfabric.com/blogs/lokibot the first hy-
brid android malware.html. Accessed: January 8, 2021.
[33] L. Wu, X. Du, and J. Wu. MobiFish: A lightweight anti-phishing scheme
for mobile phones. In Proceedings of the 23rd International Conference on
Computer Communication and Networks (ICCCN), pages 1–8, Aug 2014.
[34] Zhi Xu and Sencun Zhu. Abusing Notification Services on Smartphones
for Phishing and Spamming. In Proceedings of the 6th USENIX Conference
on Offensive Technologies (WOOT), pages 1–1, Berkeley, CA, USA, 2012.
USENIX Association.
[35] Yuxuan Yan, Zhenhua Li, Qi Alfred Chen, Christo Wilson, Tianyin Xu,
Ennan Zhai, Yan-Ping Li, and Yunhao Liu. Understanding and Detecting
Overlay-based Android Malware at Market Scales. 2019.
[36] Guangliang Yang, Jeff Huang, and Guofei Gu.
Iframes/Popups Are
Dangerous in Mobile WebView: Studying and Mitigating Differential Context
Vulnerabilities. In Proceedings of the 28th USENIX Conference on Security
Symposium, 2019.
[37] Lei Zhang, Zhemin Yang, Yuyu He, Zhenyu Zhang, Zhiyun Qian, Geng Hong,
Yuan Zhang, and Min Yang. Invetter: Locating Insecure Input Validations
in Android Services. In Proceedings of the 2018 ACM SIGSAC Conference
on Computer and Communications Security (CCS), 2018.
[38] N. Zhang, K. Yuan, M. Naveed, X. Zhou, and X. Wang. Leave Me Alone:
App-Level Protection against Runtime Information Gathering on Android.
In Proceedings of the IEEE Symposium on Security and Privacy (S&P), pages
915–930, May 2015.
A. Case-Study
APPENDIX
try {
1 void attack(int uid) {
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16 }
}, 1000);
}
/* Hijack the original activity */
}
handler.postDelayed(this, 1000);
} catch (Exception e) {
/* Handle the exception */
(b) Pseudo-code to exploit getDataLayerSnapshotForUid API
(a) This code can be used to exploit isAppForeground API: the
attacker only needs to provide the target UID. This API does not
require permission to be invoked
final Handler handler = new Handler();
handler.postDelayed(new Runnable() {
/* Executed every second */
public void run() {
1 /* First measure of txPackets */
2 public long prevTxPackets;
3 void attack(int uid) {
4
5
6
7
8
9
/* Obtain a reference to IActivityManager */
if (iam.isAppForeground(uid)) {
final Handler handler = new Handler();
handler.postDelayed(new Runnable() {
/* Executed every second */
public void run() {
/* Obtain
try {
a reference to INetworkStatsManager */
NetworkStats
ns = inss.getDataLayerSnapshotForUid(uid);
/* 1 is for foreground data
Check if the application is sending
data and if is trasmitting in foreground
*/
if (ns.set
== 1 && ns.txPackets > prevTxPackets) {
/* Hijack the original activity */
}
prevTxPackets = ns.txPackets;
handler.postDelayed(this, 1000);
} catch (Exception e) {
/* Handle the exception */
}
}, 1000);
10
11
12
13
14
15
16
17
18
19
20
21
22
23 }
(c) Pseudo-code to exploit queryEvents API
1 public long prevTime = System.currentTimeMillis();
2 public String TARGET_APP_PACKAGE_NAME = "com.bank"
3 void attack() {
4
5
6
7
8
9
final Handler handler = new Handler();
handler.postDelayed(new Runnable() {
/* Executed every second */
public void run() {
UsageStatsManager usm
try {
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26 }
= (UsageStatsManager)getSystemService(Context.USAGE_STATS_SERVICE);
UsageEvents ue = usm.queryEvents(prevTime, System.currentTimeMillis());
prevTime = System.currentTimeMillis();
while (ue.hasNextEvent()) {
UsageEvents.Event e = new UsageEvents.Event();
ue.getNextEvent(e);
if (e.getPackageName().equalsIgnoreCase(TARGET_APP_PACKAGE_NAME)) {
if (e.getEventType() == 1) {
/* Hijack the original activity */
}
}
}
handler.postDelayed(this, 1000);
} catch (Exception e) {
/* Handle the exception */
}
}, 1000);
17
B. API Whitelisting
Category
Graphical User Interface (GUI)
Audio and Video
API
For this category, we whitelist APIs from the following classes:
android.ui.ISurfaceComposer
android.gui.DisplayEventConnection
android.gui.IGraphicBufferProducer
android.gui.SensorEventConnection
android.view.IWindowSession
android.hardware.display.IDisplayManager
•
•
•
•
•
•
•
•
•
•
•
•
•
•
For this category, we whitelist mostly APIs from the android.media package. This
package, provides classes that manage various media interfaces in audio and video. For
instance, we whitelist:
android.media.IMediaAnalyticsService
android.media.IMediaCodecService
android.media.IMediaExtractorService
android.media.IMediaMetadataRetriever
android.media.IMediaRouterService
android.media.IMediaPlayerService
android.media.IAudioService
android.media.IAudioPolicyService
Digital Rights Management (DRM)
For this category, the whitelist contains the classes of the drm package, which handles
all the DRM framework.
System Services Internals
This categories contains a variety of API that are used by the system, behind the scenes,
when dealing with different system components. For instance, the system automatically
handles from the “synchronization” operations for what concerns the access to shared
structures to the “reference counting” when dealing with Content Providers. We whitelist
APIs for the following services:
•
•
•
•
ContentProvider
PowerManager
PermissionManager
AlarmManager
Example
The GUI system handles all the operations that allows the system
to display and render the UI of a given app. The application is in
charge, for instance, of declaring all the supported screen sizes
and pixel densities, but it does not have to handle the interaction
with the actual frame buffer. The GUI framework will handle,
behind the scene all the rendering operations and the rescaling,
if needed.
The Audio and Video services on Android is a complex
ecosystem formed of different components. Every component
is in charge of a specific task. For instance, when an application
wants to play an audio, it normally relies on the “MediaPlayer”
component, and performs operations like “start, stop, and pause.”
However, behind the scenes, all the whitelisted components
performs the tasks of handling the Audio, using the correct
Decoder and Coded, forward the audio to the proper hardware
interface and handle the refresh of the audio buffer.
DRM is a complex framework: it relies on plugins and it is strictly
connected with the “Media” system. In fact, DRM content are
normally audio and video file, protected with digital rights, that
are played by the system player’s. For example, every time the
app starts the DRM, a series of operations are done behind the
scenes, like loading different DRM Plugins, setup the connec-
tions with MediaPlayer and the Media System, to finally decodes
and then forwards to the player each chunk of the file to play.
As mentioned before, when an application use a system services
shared accross multiple apps, it does not have to handle all the
operation to acquire and release the lock. In fact, we noticed
these operations are handled directly by the service on behalf of
the app. It is possible to see the same behavior when dealing with
reference counting, for example when interacting with Content-
Providers or other components that can be shared across multiple
apps. Some of the APIs that we identified are used by the system
services to achieve these tasks are acquireWakeLock,
releaseWakeLock, or refContentProvider
TABLE V: The table summarizes and shows the different categories of APIs we whitelist on our on-device defense system. For each
category, we describe the classes, services, APIs, or packages we whitelist and we provide a detailed description with concrete example. We
manually investigated each of the APIs in our whitelist and none of these APIs can abused by malicious apps to mount state inference attacks.
18