O
O
O
O
O
O
O
O
O
O
O
O
C4
C4C4
S
S
C3
C3C3
O
O
C2
C2C2
S
S
C1
C1C1
D5
D5D5
S
S
D4
D4D4
O
O
D3
D3D3
O
O
D2
D2D2
S
S
D1
D1D1
A3
A3A3
O
O
A2
A2A2
S
S
A1
A1A1
O
O
O
O
P1-0
P1-0P1-0
Process
Process
Component
Component
P1
P1
A
A
Component
Component
B
B
P2-0
P2-0P2-0
O
O
O
O
P3-0
P3-0P3-0
Process
Process
Component
Component
Process
Process
Component
Component
P2
P2
C
C
P3
P3
D
D
Figure 1: Dependable initialization example
  A  recovery  graph 
initialization. 
is  dynamically
constructed  based  on the types  of dependencies
appearing  in  the  interdependency  graph  as  well  as  the 
execution state of initialization tasks.
(2) 
All 
initialization 
tasks  associated  with  failed
entities form a part  of  the  recovery  graph. Already-
completed  tasks  must  also be  a  part  of  the  recovery
graph  (so  they  can  be  re-executed)  if  they satisfy  two 
conditions:  (1)  these  already-completed  tasks have
operational  dependencies  on  tasks  associated  with 
failed  entities,  and 
there  exist  operational
dependencies on  these  already-completed  tasks  by
initialization  tasks  that  are being  executed or  that  need
to  be  re-executed.    Partially  completed  tasks  must  be
added  to  the  recovery  graph  if  they  have  operational
dependencies on  tasks  that  need  to  be  re-executed.
Current  execution  of  these partially  completed  tasks
must  be  stopped  and  any  cleanup operations  must  be 
performed  so  that  these  tasks  can  later  be re-executed.
Next,  we  add  to  the  recovery  graph  all  initialization
tasks not yet executed plus those tasks in progress that
have no operational  dependencies  on  any  of  the  tasks
already  in  the  recovery  graph.        Dependencies  among
tasks that appear in the recovery graph are the same as 
those specified in the original interdependency graph.
task  A3,  component  B 
We illustrate the above behavior using the example
shown  in  Figure 1.    Suppose  that  component A has
completed  executing 
is 
executing  tasks  B7  and  B8  (in  parallel),  component  C
has  completed  executing  task  C4,  and  component  D  is 
executing  task  D4. Now suppose  that  process  P2
containing component C fails.  All tasks associated with
P2  and  all  tasks  associated  with  component  C  become
part  of  the  recovery  graph.    We  see  that  currently-
executing  task  B7  has  an  operational  dependency  on
B4,  and  B4 has  an  operational  dependency  on  C2  of
failed  component  C.    Hence,  B4 must  be  added  to  the
recovery  graph.
In turn,  B4 has  an  operational
dependency on  B2,  and B2  has  an operational
dependency on  C1 of  failed  component  C. Hence,  B2
must also be added to the recovery graph. Now, B7 has
an operational dependency on a task (B4) that is in the
recovery graph.    Thus,  B7 must  be  placed  in  the
recovery graph and needs to be re-executed.  A similar
procedure identifies in-progress task B8 as requiring re-
execution (hence it must appear in the recovery graph).
Note  that while  B8  has  an operational  dependency  on 
B5, B5 does not depend on tasks associated with failed 
entities.  B5, therefore, does not need to be re-executed
and hence  does  not  appear  in  the  recovery  graph.    A
similar  argument  holds  for  B3.    D4  does  not have
operational  dependencies  on  tasks  in  the  recovery
graph; 
to
completion.  Unexecuted tasks B9, B10, and D5, along
with  in-progress  task  D4  are  added  to  the  recovery
graph. Figure 2 shows the resulting graph.  The shaded
tasks represent those that must be re-executed.
its  execution 
to  continue 
is  allowed 
B10
B10B10
O
O
S
S
B8
B8B8
O
O
O
O
B2
B2B2
B9
B9B9
S
S
B7
B7B7
O
O
O
O
O
O
B4
B4B4
O
O
O
O
O
O
O
O
O
O
O
O
C4
C4C4
S
S
C3
C3C3
O
O
C2
C2C2
S
S
C1
C1C1
D5
D5D5
S
S
D4
D4D4
Process
Process
P1
P1
Component
Component
B
B
Process
Process
Component
Component
Process
Process
Component
Component
P2
P2
C
C
P3
P3
D
D
P2-0
P2-0P2-0
O
O
Figure 2: Recovery graph for example
2.4. Recovery Graph Computation Algorithm
The  algorithm  to  construct  the  recovery  graph
(ComputeRecoveryGraph)  is  shown  in  Figure 3,  and
contains four key steps.  Step 1 places all initialization
tasks  associated with failed entities  into  the  recovery
graph.    Step  2.1  recursively  places  already-executed
tasks  into  the recovery  graph  if  they  have  operational
dependencies on other  tasks  already  in  the  recovery
graph.    Step  2.2  adds  currently  executing  tasks  to  the
recovery graph  if  they  have  operational  dependencies
on any tasks inserted in the recovery graph in previous
steps. Step 3  adds  to  the  recovery  graph  those  tasks
either  in-progress  or not  yet  executed.  Finally,  Step  4 
incorporates  dependencies  into  the recovery  graph  by
'copying' them from the original interdependency graph.
ComputeRecoveryGraph(G,{FailedEntities})
// FailedEntities: set of failed entities 
// OD(Ti,Tj): true if the dependency 
//   from task Ti to task Tj in original 
Proceedings of the 2004 International Conference on Dependable Systems and Networks (DSN’04) 
0-7695-2052-9/04 $ 20.00 © 2004 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 11:51:18 UTC from IEEE Xplore.  Restrictions apply. 
//   interdependency graph is an operational 
//   dependency 
// R(v,e): recovery graph 
// R(v): set of tasks in recovery graph 
// R(e): dependency arcs in recovery graph 
0. 
1.
1.1.
1.1.1.
2.
R(v) := (cid:73);
(cid:5) entities e (cid:143) FailedEntities 
(cid:5) tasks Ti associated with e 
(cid:5) current execution tasks Ti associated 
with fault-free entities 
R(v) := R(v) (cid:137) Ti; 
2.1. 
2.2. 
2.2.1.
3.
4.
IdentifyCompletedTasksToReExec(R,Ti); 
if (cid:7) Tj (cid:143) R such that OD(Tj,Ti) 
R(v) := R(v) (cid:137) Ti; 
R(v) := R(v) (cid:137) unfinished tasks in G; 
R(e) := all edges from original 
interdependency graph corresponding to 
tasks in R(v); 
IdentifyCompletedTasksToReExec(R,Ti)
// Ti: current execution task associated with 
//     a fault-free entity 
1. 
if (cid:7) Tj (cid:144) R such that OD(Tj,Ti) && 
(cid:7) Tk (cid:143) R such that OD(Tk,Tj) 
1.1.
1.2. 
R := R (cid:137) Tj;
IdentifyCompletedTasksToReExec(R,Tj); 
Figure 3: Recovery graph algorithm 
2.5. Deciding When to Recover Failed Entities 
is 
initialization 
The goal of  dependable 
to 
successfully  bring  a  distributed  system,  as  quickly  as 
possible,  to  a  point  where  it  can  begin  to perform  its
normal  function,  even  in  the presence  of  failures. One
way to handle failures is to trigger recovery activities as 
soon as failures are detected.  We show, however, that
in  a  distributed  system  with  interdependencies  among
immediately may
tasks,  recovering  failed  entities 
actually 
than
deferring recovery until a later stage in the initialization
procedure. The example below illustrates how recovery
actions  can  impact  overall  system initialization  time
(see Figure 4).
initialization times 
longer
lead 
to 
As  shown  in  Figure 4,  components  A  and  B
execute within process P1, while component C executes
within process P2.  Initialization is considered complete
once A2, B2, and C2 have all completed.
Suppose that tasks P1-0 and P2-0 for processes P1
and P2 take negligible time, that tasks A1, B1, and C1
take  ten  seconds  each,  tasks  A2  and  B2 require  two
minutes to execute, while task C2 takes eight minutes to
execute.    Failure detection  time  is  five  seconds,  a 
component  is  recovered  by  restarting  the  process  in
which  the  component  is  contained (the restart  takes
negligible time, but all components must re-execute all
of  their  initialization  tasks),  and  all  components  are 
created  in  parallel  simultaneously.    At  t=9.05  minutes,
component A fails when C is using B’s services.
A2
A2
A2A2
S
S
S
A1
A1
A1A1
O
O
O
O
O
O
P1-0
P1-0
P1-0P1-0
B2
B2
B2B2
S
S
S
B1
B1
B1B1
C2
C2
C2C2
S
S
S
C1
C1
C1C1
O
O
O
O
O
O
P2-0
P2-0
P2-0P2-0
Process
Process
Process
Component
Component
Component
Component
Component
Component
Process
Process
Process
Component
Component
Component
P1
P1
P1
A
A
A
B
B
B
P2
P2
P2
C
C
C
(a) Interdependency graph
(a) Interdependency graph
(a) Interdependency graph
A2
A2
A2A2
S
S
S
A1
A1
A1A1
O
O
O
O
O
O
P1-0
P1-0
P1-0P1-0
B2
B2
B2B2
S
S
S
B1
B1
B1B1
C2
C2
C2C2
S
S
S
C1
C1
C1C1
O
O
O
O
O
O
P2-0
P2-0
P2-0P2-0
Process
Process
Process