GSPR’s RevCheck algorithm does not determine the revoca-
tion status of a private key with certainty, but instead with
a certain probability.
If an alias token has been revoked
and its corresponding alias code has been included in the
revocation code, then RevCheck’s result is guaranteed to be
correct. However, there is a possibility of a false alarm. Us-
ing an iterative algorithm, this probability can be decreased
iteratively, a la the well-known Miller-Rabin primality test
algorithm [19]. The details of the revocation check proce-
dure and iterative algorithm are given in Section 5.4.1.
For analyzing the revocation correctness, we deﬁne the
two hypotheses—H0 : xik has been revoked, and H1 : xik
has not been revoked. Here, the probability of false nega-
tive/dismissal, Pf d, can be deﬁned as the probability of er-
roneously determining that a given alias token has not been
revoked when it has been revoked by the group manager.
In RevCheck, Pf d is equal to the probability of z  0.
As a result of the random nature of the codes, there are
inevitable false dismissals, which means there is signiﬁcant
possibility that the veriﬁer would not be able to detect a
revoked private key. This is untenable in PPA as this could
be utilized by adversaries to bypass the revocation check.
As discussed above, orthogonal codes as well as random
codes have critical drawbacks that limit their utility as alias
codes. Hence, we propose a new type of codes that we call
piecewise-orthogonal codes. The use of piecewise-orthogonal
codes enables us to create alias codes that are compact and
have a very desirable property—viz., Pf d = 0 and Pf a > 0.
In other words, when we use piecewise-orthogonal codes, the
probability of false dismissals is guaranteed to be zero, al-
though the probability of false alarms is non-zero. Note that
ensuring Pf d = 0 is much more important than Pf a = 0 from
a security point of view. The former implies that a revoked
alias token can detected by RevCheck with 100% certainty.
In the next subsection, we provide details on how piecewise-
orthogonal codes are used in probabilistic revocation.
5.4.1 Revocation with Piecewise-Orthogonal Codes
In GSPR, we utilize piecewise-orthogonal codes as alias
codes for achieving probabilistic revocation. The piecewise-
orthogonal codes are generated by concatenating multiple
segments where each segment is an orthogonal code. To gen-
erate a piecewise-orthogonal code as an alias code, an alias
token is divided into multiple segments, and an orthogonal
code is generated corresponding to each segment. These or-
thogonal codes corresponding to the segments of the alias
token are concatenated to form the complete alias code. In
this way, the alias codes are piecewise-orthogonal.
Speciﬁcally, a set of 2bs orthogonal codes, denoted by Cs,
is generated using the technique discussed in [7], where each
orthogonal code is of length 2bs . Note that an orthogonal
code in Cs can be retrieved using a bs-bit index. Further,
each alias token xik ∈ Z∗
p of bp bits is divided into d segments
each of length bs bits, such that d · bs ≤ bp < (d + 1) · bs.
The segments of the alias token xik are represented by xik,j,
∀j ∈ [1, d]. Further, ∀j ∈ [1, d], xik,j is utilized to generate
bs-bit index so that an orthogonal code sik,j is chosen from
Cs. Finally, all the d orthogonal codes, sik,j, ∀j ∈ [1, d],
are concatenated to generate the alias code sik. The length
of the resulting revocation code is l = d · 2bs . The group
manager declares the two public parameters Cp and Fc, such
that the set of all possible alias codes Cp = Cd
s, and the
mapping function Fc : Z∗
p → Cp is deﬁned as segment-wise
indexing as discussed above.
When the revocation code is generated using the Revoke
algorithm, each segment of the revocation code is generated
by summation of the corresponding segments of the revoked
alias codes. Hence, the generated revocation code also has d
segments, represented by RCj, ∀j ∈ [1, d]. Note that due to
the property of orthogonal codes, the cross-correlation of a
revocation code’s segment and an orthogonal code results in
one of the two values—(1) 0 if the revocation code was not
generated by the orthogonal code, or (2) an integral multiple
of 1 if the revocation code was generated by the orthogonal
code. Hence, the threshold τ is set to 1.
Having received a signature with alias token xik, the ver-
iﬁer can run RevCheck for each of the d segments. However,
to minimize the computational overhead, the veriﬁer only
runs RevCheck for a segments. This means that RevCheck
can be re-organized as follows.
RevCheck(RC, σ)
1. Set j = 1.
2. Generate a bs-bit index from xik,j, and select an or-
thogonal code sik,j from Cs.
3. Compute z = 1
2bs sT
ik,j · RCj. If z ≥ 1, output invalid;
otherwise, output valid, and exit.
4. Set j = j + 1. If j ≤ a, go to Step 2; otherwise, exit.
5.4.2 Example
We illustrate the revocation check procedure in GSPR
through an example. The alias codes and the revocation
code used in the example are given in Table 1. We as-
sume that there are ﬁve 4-bit alias tokens represented by
x1 = {1111}, x2 = {1010}, x3 = {0101}, x4 = {1101} and
x5 = {1110}. Also, we assume that Cs contains 22 = 4
orthogonal codes. The group manager generates the alias
codes s1, s2, s3, s4, and s5—corresponding to x1, x2, x3,
x4, and x5, respectively—by concatenating two orthogonal
codes of length 4 samples. Suppose that the group man-
ager needs to revoke alias tokens x1 and x2. Hence, the
group manager computes the sample-by-sample addition of
the alias codes s1 and s2. The resulting vector is the revoca-
tion code, represented by RC. The group manager provides
the veriﬁer with RC. In this scenario, if the veriﬁer receives
a signature with the alias token x1, he runs two iterations
1341)
a
f
P
(
m
r
a
a
l
e
s
a
l
f
f
o
y
t
i
l
i
b
a
b
o
r
P
0
10
−2
10
−4
10
10
−6
1
)
a
f
P
(
m
r
a
a
l
e
s
a
l
f
f
o
y
t
i
l
i
b
a
b
o
r
P
6
7
8
Number of revoked private keys, n
=1024
r
Number of revoked private keys, n
=2048
r
5
2
3
4
Number of iterations (a)
0
10
−5
10
−10
10
−15
10
10
Number of revoked private keys, n
=1024
r
Number of revoked private keys, n
=2048
r
18
12
14
16
20
Number of bits in each segment of an alias token (b
s
22
24
)
Figure 1: Probability of false alarm vs. number of itera-
tions.
Figure 2: Probability of false alarm vs. number of bits in
each segment of an alias token.
4 sT
4 sT
1,1 · RC1 = 1, and 1
of RevCheck. In the ﬁrst iteration, the veriﬁer computes the
cross correlation between the ﬁrst segments, i.e., ﬁrst 4 sam-
ples of s1 and RC, represented by s1,1 and RC1, respectively.
In the second iteration, the veriﬁer computes the cross cor-
relation between the second segments, i.e., second 4 samples
of s1 and RC represented by s1,2 and RC2, respectively. The
cross correlation is computed by sample-by-sample multipli-
cation of the alias code and the revocation code followed by
the addition of all the products, and the resulting value is
given by 1
1,2 · RC2 = 1. Since the
cross correlation of both the segments resulted in the value
of 1, the veriﬁer concludes that x1 has been revoked. Using
the same procedure, the veriﬁer concludes that x2 has also
been revoked. On the other hand, if the veriﬁer receives a
signature with the alias token x3, he will conclude that the
alias token is valid because the cross correlation of s3,1 with
RC1 is 0. Here, the RevCheck algorithm exits after the ﬁrst
iteration. Now, let us take a look at x4. The cross correla-
tion of s4,1 and s4,2 with RC1 and RC2 results in the values
1 and 0, respectively. Here, if the veriﬁer makes a decision
after only computing the correlation of the ﬁrst segment, to
decrease its computational overhead, he erroneously deter-
mines that x4 has been revoked because this is an instance
of a false alarm. However, after computing the correlation of
the second segment, the veriﬁer can conclude with absolute
conﬁdence that x4 has not been revoked because Pf d = 0.
Lastly, the cross correlation of s5,1 and s5,2 with RC1 and
RC2 results in 1 and 1, respectively. Hence, if the veriﬁer
receives a signature with an alias token x5, he erroneously
concludes that x5 has been revoked.
5.4.3 Discussions on the False Alarm Probability
With the proposed piecewise-orthogonal codes, the prob-
ability of false dismissal is zero, i.e., Pf d = 0. However, after
checking a segments, the upper bound of the probability of
false alarm (Pf a) can be computed to be
Pf a =
(mnr)a 2bp−abs − mnr
=
2bp − mnr