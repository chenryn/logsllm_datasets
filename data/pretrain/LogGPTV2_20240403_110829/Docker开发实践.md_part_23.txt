# echo 1 > /proc/sys/net/ipv4/ip_forward
# cat /proc/sys/net/ipv4/ip_forward
15
1
如果我们将Docker服务的参数--ip-forward设成true，那么Docker服务每次启动时，都会将
16
/proc/sys/net/ipv4/ip_forward设成1。如果是false，则启动服务时不会对主机ip_forward做任
何修改。大多数情况下，我们可以打开这个开关，以确保与外部网络及其他容器间正常通信。
17
每一个从容器发往外部的源IP地址最终都会被修改为主机的IP地址。这得益于iptables的
MASQUERADE规则。当Docker服务启动时，就会在iptables中添加一条这样的规则。
18
144 第12章 容器网络
下面的MASQUERADE规则表明所有的源地址为172.17.0.0/16的数据包在路由前数据包中的源IP
地址字段都会被替换成主机的IP地址：
# iptables -t nat -L -n
...(略)
Chain POSTROUTING (policy ACCEPT)
target prot opt source destination
MASQUERADE all -- 172.17.0.0/16 0.0.0.0/0
... (略)
12.2.5 创建点对点连接
默认情况下，Docker会将所有的容器接入到虚拟网桥docker0所组织的虚拟子网中。我们已经
学过如何将容器连接到创建的网桥之上，但是有时候我们仅仅需要两个容器之间能够直接通信，
而不想让它们混入其他复杂的网络中。
解决方案很简单，当我们创建一对veth设备时，将veth的两端网络接口设备分别放入两个容
器中，并且就像配置普通网络接口那样配置它们。这样，两个容器就能直接进行通信了。图12-4
展示了这种解决方案。下面我们将演示具体的创建步骤。
图12-4 容器点对点连接
(1) 在终端1创建一个无网络的容器767318ce80c3，下面将以容器1指代：
# docker run --rm -i -t --net=none ubuntu
root@767318ce80c3:/#
(2) 在终端2创建一个无网络的容器bd1f6fe8f7c7，下面将以容器2指代：
# docker run --rm -i -t --net=none ubuntu
root@bd1f6fe8f7c7:/#
(3) 在终端3查看刚才创建的两个容器的进程ID：
# docker inspect -f '{{.State.Pid}}' 767318ce80c3
4207
# docker inspect -f '{{.State.Pid}}' bd1f6fe8f7c7
4241
(4) 在终端3分别为两个容器在它们独立的进程空间里创建虚拟网络空间：
12.2 配置及原理 145
# mkdir -p /var/run/netns
1
# ln -s /proc/4207/ns/net /var/run/netns/4207
# ln -s /proc/4241/ns/net /var/run/netns/4241
2
(5) 创建一对veth，两端命名分别为A、B：
# ip link add A type veth peer name B
3
(6) 将A放入容器1的网络空间：
4
# ip link set A netns 4207
(7) 在容器1的网络空间中设置设备A的IP地址为10.1.1.1/32：
5
# ip netns exec 4207 ip addr add 10.1.1.1/32 dev A
(8) 在容器1的网络空间中启动设备A： 6
# ip netns exec 4207 ip link set A up
7
(9) 在容器1的网络空间中设置设备A的路由地址为10.1.1.2/32：
9
# ip netns exec 4207 ip route add 10.1.1.2/32 dev A
(10) 将B放入容器1的网络空间：
8
# ip link set B netns 4241
(11) 在容器2的网络空间中设置设备B的IP地址为10.1.1.2/32： 10
# ip netns exec 4241 ip addr add 10.1.1.2/32 dev B
10
(12) 在容器2的网络空间中启动设备B：
# ip netns exec 4241 ip link set B up 12
(13) 在容器2的网络空间中设置设备B的路由地址为10.1.1.1/32：
13
# ip netns exec 4241 ip route add 10.1.1.1/32 dev B
现在这两个容器就能直接通信了。点对点通信不需要依赖子网，所以也不需要子网掩码。 14
我们需要做的仅仅是通过ip route命令为veth在本端的设备指定路由地址为对端的IP地址。点对
点连接可以与其他网络连接方式安全共存，这就意味我们没有必要以--net=none方式启动一个 15
容器了。
我们同样可以将这种点对点的连接方式应用到容器与主机之间，这样允许主机使用一个独立 16
IP地址与那个容器进行通信。这种不依赖网桥的通信方式可以用来关闭容器与其他容器之间的通
信，但是除非有特殊的网络需求，我们更加推荐使用12.2.2节介绍的--icc=false参数来达到关闭 17
容器间通信通道的目的。
18
146 第12章 容器网络
12.3 网桥
前面已经讲到网桥在容器网络中所发挥的巨大作用，本节中我们将学习网桥的配置以及如何
为容器创建我们自己的网桥。
12.3.1 配置网桥
在默认网络模式（--net=bridge）下启动容器时，容器会检查Docker服务的全局配置中是否
指定了-b参数，如果指定了，容器就连接到这个参数所指定的网桥，没有指定就连接到默认的网
桥docker0。
docker0网桥的IP地址、子网掩码、MTU值及连接设备IP地址分配范围是由Docker服务配置的，
我们可以通过全局配置/etc/default/docker文件中的DOCKER_OPTS选项来修改这些值。以下是具体的
修改参数说明。
 --bip=CIDR。为默认网桥指定一个子网掩码和IP地址。需要使用标准CIDR格式，如
192.168.1.5/24。
 --fixed-cidr=CIDR。设定docker0网桥下的子网IP分配范围。需要使用标准CIDR格式，如
172.167.1.0/28。
 --mtu=BYTES。指定网桥的最大传输单元长度。如果不指定，则使用默认值1500字节。
修改/etc/default/docker文件之后，需要重启Docker服务配置方可生效。
12.3.2 构建自己的网桥
通常情况下，Docker创建的默认网桥已经能够满足需求。但我们仍可以在不依赖Docker的基
础上，完完全全手工为容器创建一个网桥，并通过参数-b或者--bridge告诉Docker使用我们自定
义的网桥。下面我们将一步一步讲解如何构建网桥。
(1) 停止已经启动的服务：
# sudo service docker stop
(2) 停止默认网桥设备docker0：
# sudo ip link set dev docker0 down
(3) 删除默认网桥：
# sudo brctl delbr docker0
(4) 创建虚拟网桥bridge0：
# sudo brctl addbr bridge0
12.3 网桥 147
(5) 为新建的网桥设定IP地址和子网掩码：
1
# sudo ip addr add 192.168.5.1/24 dev bridge0
2
(6) 启动新建网桥：
# sudo ip link set dev bridge0 up 3
(7) 为了确认网桥是否如期启动，通过下面的命令进行检视：
4
# ip addr show bridge0
3: bridge0:  mtu 1500 qdisc noop state UP group default
link/ether 66:38:d0:0d:76:18 brd ff:ff:ff:ff:ff:ff 5
inet 192.168.5.1/24 scope global bridge0
valid_lft forever preferred_lft forever
6
(8) 修改全局配置，设定bridge0为默认网桥：
# echo 'DOCKER_OPTS="-b=bridge0"' >> /etc/default/docker
7
(9) 重启Docker服务：
9
$ sudo service docker restart
至此，我们自己的网桥就创建好了，之后运行的容器都将会连接到这个网桥上。
8
10
10
12
13
14
15
16
17
18
148 第13章 安全
第 13 章
安 全
我们知道Docker是基于操作系统级的虚拟技术，而虚拟机是基于硬件层面的虚拟技术。相对
而言，Docker的安全性一直受到怀疑，即便Docker看起来像沙箱一样安全。不过Docker公司后面
也承认，容器的安全是今后需要重点加强的部分。事实上，Docker也正在行动，它和Red Hat组
件安全小组一起在加强安全性能。Docker的安全机制主要依赖Linux已有的安全机制，恰如其分
地使用已有的技术往往比推倒一切重来来得简单和巧妙，这和Linux的工具链颇为相似。本章的
主要内容有：
 命名空间。
 cgroups。
 Linux能力机制。
13.1 命名空间
Linux的命名空间对虚拟化提供了轻量级的支持，通过它我们可以完全隔离不同的进程。以
往，在Linux及其他类UNIX系统中，很多资源都是全局的，包括进程号（Pid）、用户信息、系统
信息、网络接口和文件系统等。用户可以看到其他用户的进程、使用的一些资源等。多数情况下，
这都没问题。但在有些时候，这不能满足我们的需求。如果服务器供应商向客户提供Linux计算
机的全部访问权限的话，那么在传统的做法中，可能要为每个用户提供一台计算机，这样做代价
太高，而且计算机也不能完全发挥作用。使用虚拟机是一种解决方案，但是资源的利用率还是太
低。每个虚拟机都需要一个独立的系统，安装配套的应用层应用，这会占用大量的磁盘空间。有
多个内核都在同时运行，由于虚拟机内核对程序指令封装了一层，执行效率也会大打折扣。
命名空间提供了一种不同的解决方案，只占用很少的资源，只需要运行计算机本身的操作系
统。所有的进程都在同一个系统上运行，需要隔离的各种资源则通过命名空间达到隔离的目的。
这样就可以把一些进程放到一个容器中，另一些进程放到另一个容器中，两个容器之间互相隔离。
当然，也可以根据需要允许容器间有一定的共享。例如，容器使用独立的PID集合，但是和其他
容器共享文件系统。本质上，命名空间提供了对资源的不同视图，在不同的命名空间下我们会看
到不同的资源集合。之前的每一项全局资源都被封装到容器的数据结构中。只有资源和包含资源
13.1 命名空间 149
的命名空间构成的组合是全局唯一的。也许在容器内部资源是唯一的，但是从容器外部看就保证 1
不了了。
图13-1显示了命名空间如何隔离进程。所有的命名空间都在同一个内核上运行，命名空间1 2
中有进程1-1和进程1-2，命名空间2中有进程2-1和进程2-2，命名空间n中有进程n-1和进程n-2。在
进程1-1中可以看到进程1-2，但是看不到进程2-1，也看不到进程n-1。每个命名空间中的进程都 3
认为它们独占整个系统。
4
5
6
7
9
图13-1 命名空间将进程隔离
8
图13-2演示了系统上有3个命名空间的情况。一个命名空间是父命名空间，它衍生了两个子
命名空间。假定容器用于虚拟主机配置，其中每个容器看起来必须像是单独的一台Linux计算机。
10
因此，其中每一个都有自身的init进程，PID为1，其他进程的PID以递增次序分配。两个子命名空
间都有PID为1的init进程，以及PID分别为2和3的两个进程。由于相同的PID在系统中会出现多次，
10
所以PID号不是全局唯一的。虽然子容器不了解系统中的其他容器，但父容器知道子命名空间的
存在，而且可以看到其中执行的所有进程。图中子容器的进程映射到父容器中，PID为4到9。尽
11
管系统上有9个进程，但却需要15个PID来表示，因为一个进程可以关联到多个PID。至于哪个PID
是“正确”的，则依赖于具体的上下文。
13
14
15
16
图13-2 命名空间的层次关联 17
不同的资源构成了不同的命名空间，这里简要介绍一下进程命名空间、网络命名空间、IPC
18
命名空间、挂载命名空间、UTS命名空间和用户命名空间这6种。
150 第13章 安全
 进程命名空间（PID Namespace）。该命名空间主要用来管理进程id以及其他id（tgid、
pgid和sid）。这里我们以进程id为例来说明进程命名空间的作用。在创建进程时，Linux
会为它分配一个号码以在其命名空间中唯一标识它，该号码称作进程id号，常用pid表示。
同一进程在不同的进程命名空间下会有不同的进程id，每个进程命名空间可以按自己的方
法管理进程id。所有的进程命名空间组成一个树形结构，子空间中的进程对于各级父辈空
间是可见的，进程在各可见空间中都有一个进程id与之对应。
下面的代码用于先启动一个容器，只是让它长时间sleep，然后我们在宿主机上通过ps命
令查看到sleep进程的pid为11032，接下来进入容器内部用ps命令查看sleep进程的pid为1：
$ sudo docker run -d ubuntu /bin/bash -c "sleep 1000"
440db3a5bb98a6acf407bc28d6d573178bc081f60b3949a9fb43c43b14dc3ce2
$ ps aux | grep sleep | grep -v grep
root 11032 0.1 0.0 4344 360 ? Ss 19:12 0:00 sleep 1000
$ sudo docker exec -i -t 440db3a5bb98 /bin/bash
root@440db3a5bb98:/# ps aux
USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND
root 1 0.0 0.0 4344 360 ? Ss 11:12 0:00 sleep 1000
root 7 0.0 0.0 18140 1936 ? S 11:12 0:00 /bin/bash
root 22 0.0 0.0 15568 1124 ? R+ 11:13 0:00 ps aux
root@440db3a5bb98:/#
 网络命名空间（Network Namespace）。该命名空间为进程提供了一个完全独立的网络协
议栈的视图，包括网络设备接口、IPv4和IPv6协议栈、IP路由表、防火墙规则和sockets等。
网络命名空间提供了一份独立的网络环境，就跟一个独立的系统一样。物理设备只能存
在于网络命名空间中。通过给每个容器建立一个独立的网络命名空间，可以为容器提供
一个虚拟的独立的网络环境，就好像自己有一个私有的网络接口一样。
虚拟网络设备（virtual network device）还提供了一种类似管道的抽象，可以在不同的命
名空间之间建立隧道。利用虚拟化网络设备，可以建立到其他命名空间中的物理设备的
桥接。利用这种桥接，我们可以实现容器间的网络通信。当一个网络命名空间被销毁时，
该命名空间的物理设备会被自动移回init Network Namespace，即系统最开始的命名空间。
 IPC命名空间。为了实现进程间的通信，Linux会使用全局的IPC对象，而所有进程都可以
见到这些IPC对象。IPC命名空间就是为了隔离这些进程间的通信资源的。一个IPC命名空
间由一组System V IPC objects标识符构成，这些标识符由IPC相关的系统调用创建。在一
个IPC命名空间里面创建的IPC object对该命名空间内的所有进程可见，但是对其他命名空
间不可见，这样就使得不同命名空间之间的进程不能直接通信，就像是在不同的系统里
一样。当一个IPC命名空间被销毁时，该命名空间内的所有IPC object会被内核自动销毁。
PID命名空间和IPC命名空间可以组合起来一起使用，这样新创建的命名空间既是一个独
立的PID空间，又是一个独立的IPC空间。不同命名空间的进程彼此不可见，也不能互相
通信，这样就实现了进程组间的隔离。
13.2 cgroups 151
 挂载命名空间。挂载命名空间为进程提供了一个文件层次视图，每个进程都存在于一个 1
挂载命名空间里。默认情况下，子进程和父进程将共享同一个挂载命名空间，其后子进
程调用mount或umount将会影响到所有该命名空间内的进程。如果子进程在一个独立的挂
2
载命名空间里，就可以调用mount或umount命令建立一份新的文件层次视图。这样的话，
不同的容器就拥有独立的文件系统了。