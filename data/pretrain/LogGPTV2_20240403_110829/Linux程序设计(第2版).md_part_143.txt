put_unaligned (val.ptr)
如果你确实需要访问某个肯定是非对齐的数据，就请使用表21-24里的宏定义。它们的定义
在asm/unaligned.h头文件里。如果计算机的体系结构直接支持非对齐访间，这几个宏定义将展开
为普通的退化指针。
其他可移植性方面的问题已经在各有关章节里介绍过了，你应该不会再遇到我们没有在这
里或那里讲到的问题。可移植代码是优美的代码，大家要在程序设计工作中多考虑这方面的
问题！
21.10本章总结
我们希望大家能够体会到内核开发工作中的乐趣，内核源代码的长度实在是太大了，所以
它经常给人以一种不可企及的感觉，但我们希望这一章内容能够给大家提供足够的装备和各自
为战的信心。对这本书的学习无论如何也比不上你自已对源代码的研究。毫无疑义，源代码是
惟一能够完全跟上潮流变化的文档！这确实是开故源代码项目赋予程序员的强大武器，整个源
代码都毫无保留地量现在你的面前任你研究。Linux内核方面的文档能够称得上好的实在是不多，
所以阅读他人编写的驱动程序和内核改进就成为我们大家能够拥有的最佳资源。
够帮助大家开始起步去追求自已的目标。为了一个深藏不露的“小虫子”，我们可能会经历许多
个头悬梁锥刺骨的不眠之夜，但我们最终捉住了它；也许正是这些才激励着你去孜孜不倦地研
究源代码和不断地学习。有些内核开发人员极具天份，他们的工作绝对值得我们花费时间和精
力去学习。
要想成为内核程序员需要克服很多的困难，而最大的障碍也许就是不知道某个特定的代码段被
存放在内核源代码的什么地方。我们希望这一章能够给大家一个好的开始，对内核里的来龙去脉有
加入jaVva编程群：524621833
---
## Page 774
第21章设备驱动程序
757
一个大致的认识。如果你在某个具体问题上遇到了困难，grep命令会一如既往地帮你查到所有相关
示例。但正如我们在这一章开始时说的那样，内核水远在发展当中，一本印刷出来的书已经肯定不
是最新最全面的了。如果大家发现这里写的内容与内核里的实际情况不一致，请以内核为准，
21.11内核源代码解剖图
linux
（依赖于计算机体系结构的代码）
（驱动程序）
block
（块设备）
cdrum
（基本动程序和标准化接口层）
（字符设备）
macintosh
misc
（大部分内容与并行山有关）
180
（网络事动程序）
pt1
（PCI子系统）
sbus
（SBUS子系统，（SPARC））
sesi
（驱动程序和SCSI子系统）
sound
（驱动程序和声音子系统）
video
（大部分是帧缓冲驱动程序）
fs
（vis和其他文件系统）
inctude
（头文件）
asm
（到有关平台的链接，比如asm-alpha）
linux
init
（开机启动文件）
ipc
（进程间通信）
kemel
（内核）
lib
（实幕堡申缺本）
加血
（内存管理子系统）
modules（模块）
net
（网络子系统）
sdyos
（各种有用的工其程序）
图21-6
图21-6就是内核的基本结构，但我们省略了许多内容，希望大家能够把它补充上。
加入jaVa编程群：524621833
---
## Page 775
附录A可移植性
可移植性涉及到的问题主要有三个方面：
·不同操作系统之间的可移植性，它们可以是UNIX操作系统的其他实现形式，也可以是完
全不同的操作系统，比如OS-9、VMS或MS-DOS等。
·不同供应商的编译器之间的可移植性，包括使用不同的C语言编译器和微为C++代码进行
编译等方面。
·不同硬件之间的可移植性，比如字长度、字节存储顺序以及其他可能导致问题的差异等
我们在这本书里断断续续地提到过不同操作系统之间的可移植性问题，而这个附录的主要
论题是其他方面的可移植性。
UNIX世界里的可移植性永远是非常重要的，这是因为各种计算机平台上曾经有过许多版本
的UNIX操作系统。截至到不久前，Linux还只能用在80x86系列的机器上：可现在Linux已经能
够用在其他平台上了，其中最值得注意的是Motorola公司出品的68k系列和DEC公司出品的
Alpha处理器。
我们在这个附录里准备了一些与可移植性有关的技巧、跨门和一般性论述，目的是为了帮
助大家保证自已的软件能够在不同的UNIX平台和不同的编译器版本之间进行移植。
A.1程序语言方面的可移植性
首先，我们来看看你需要采取哪些措施才能保证自己的代码能够在不同版本的C语言编译器
和不同版本的UNIX操作系统上进行移植。
A.1.1预处理器符号
有几个预处理器符号是用来指示编译器类型和编译器与有关标准之间符合程度的。这些符
号的定义没有采用头文件这种普通的方法，它们是由预处理器或编译器系统提供的。这些符号
对可移植性的影响很大。
1.__STDC_
也许最重要的预处理器符号就是“_STDC__”了。只要编译环境能够满足ISO（国际标
准化组织）的C语言标准，就必须定义这个符号。从传统上讲，它经常被用来在只能编译
“Kernighan&Ritchie”原始格式的老式系统和紧随C语言标准发展动向的新式系统之间移植
代码。
现如今，尽管很多编译器还没有通过认证一一也就是说多多少少地与C语言标准还有细微的
差异，但明显不同于C语言标准的编译器可以说是少之又少了。使用这个符号将使你能够把需要
按ISO的（.语言标准而不是按老式的“K&R”惯例来对待处理的代码部分隔离出来。它们之间
加入java编程群：524621833
---
## Page 776
附录A可移植性
759
的大部分区别在于函数的定义格式方面，
使用这个符号需要在程序里加上如下所示的代码：
fdefSTDC
int By_function(const char *nystring. const int a_value) ;
telse
int my_function();
#endif
如果你使用的是GNU编译器gcc，请使用-ansi开关来激活标准的C编译处理。
有些编译器把“_STDC__"符号定义为“0"，这很明显地表明它们与ISO的C语言标准足
不相符合的！如果你真的遇见了这样的情况，就不得不使用“#if_STDC_”做为替代办法。
2._XOPEN_SOURCE
如果你的代码符合（或者估计符合）X/Open和POSIX标准，就请在包括任何头文件之前先
行定义“_XOPEN_SOURCE”符号。
这个定义会改变头文件的行为，使它们与X/Open标准保持一致。如果你已经定义了
“_XOPEN_SOURCE”符号，就不必再定义老式的“_POSIX_SOURCE”符号了。
它的使用方法如下所示：
define _xOPEN_SOURCE
include
A.1.2系统保留字
有一些名字是系统保留使用的。ISO的标准C语言里就有这样一个保留字清单，但要注意某
些非标准化的编译器还可能保留了一些其他的名字。遇到这类情况时就请以编译器的参考手册
为准。
auto
break
case
const
continue
default
op
double
else
wmua
exlen
float
for
goto
i#
int
kng
register
retum
short
signed
sizeof
4s
switch
japad6
union
unsigned
void
volatile
while
此外。如果你希望在今后把自己的程序由C语言转换到C++，那么最好也要避免使用任何C++
的关键字。在我们编写这本书的时候，ANSI（美国国家标准化协会）的C++标准仍在制定当中，
所以现在就给出一个完整的清单是不可能的。但不管怎样，你至少要免使用下面这些保留字：
asm
catch
delete
friend
inline
new
private
protected
public
tempiate
this
throw
try
virtual
加入jaVa编程群：524621833
---
## Page 777
760
Linux程序设计
还有一些其他的名字也需要保留。需要特别注意的有：以一个下划线字符“”打头所有名
字都是保留给编译器使用的：以“”结尾的名字又都是保留给POSIX头文件里使用的。也就是
说，永远不要用“_做名字的开始字符，也不要用“1”来结束它。
只要你开始在自已的程序文件里包括上头文件，就会使用到额外的名字，而这就可能有不
良的后果。我们来想象一下这样的情况：你已经有一个能够正确编译的文件了，你又在这个文
件里编写了一个新函数，这个新函数要求新包括上一个头文件：可这个新头文件使用的名字与
你现有的名字发生了冲突，你将不得不重新编写程序代码的某些部分。要想解决这个问题也并
不困难，只要注意避免使用各种头文件所使用的一切名字就相安无事了。
我们把各种头文件里使用的各种名字总结在表A-1里：
表A-1
头文件
使用的名字
ctype.h
所有名字都是以“s”或“o”开始的
dirent .h
所有名字都是以“d_”开始的
errno.h
所有名字都是以大写字母“E”开始，后面或者跟着一个数字，或者跟着其他的
大写字母
fnct1.h
所有名字都是以“L_”、“F_、“O_”或“S_”开始的
grp.h
所有名字都是以“g_”开始的
linits.h
所有名字都是以“_MAX"结尾的
locale.h
所有名字都是以“LC”开始的
pwd.h
所有名学都是以“pw_”开始的
signal.h
所有名字都是以“sa_”、“SIG”或“SA_”开始的
st.ring.h
ays/stat.h
所有名字都是以“s_”或“S_”开始的
sys/times.h
所有名字都是以“tms_开始的
termios.h
所有名字都是以“_"、“V"、"T"、“O”或“TC”开始的
A.1.3资源极限
头文件limits.h里定义了许多最大值。一定要坚持使用头文件里定义的值，这里千万要不得
你自已的发明创造。如果你确实需要定义一个自己的极限值，同时还希望代码能够被用在许多
不同的系统上，就应该加上些“一次性”代码去检查当前系统上的极限值与你程序要求的是否
一样或者更好。
当有人试图运行一个程序的时候，如果它不能运行，先说明哪些个极限值与程序要求的不
兼容然后再“体面地退出”是比较好的做法；强行运行却又行为失常是不足取的。
A.2硬件方面的可移植性
UNIX，以及如今的Linux，能够在范围很广的硬件上使用。你必须采取必要的步骤以保证
自已不会失手写出只能限制使用在某个或某几个平台上的代码来。
C语言被广泛地认为是一种可移植性很强的语言。它适合完成各种截然不同的任务一一从底
加入jaVa编程群：524621833
---
## Page 778
附录A可移植性761
层的硬件访问操作一直到数据库等高层的应用程序。它还是一种效率极高的语言，它可以直接
被编译器翻译为机器代码，以很小的运行开销高效率地完成预定的任务。
但事情并非总是如此。C语言有许多不能准确定义的成分—当我们在不同系统之间移植C
语合源代码的时候，它们就容易引起问题。整数的长度大概是其中最经典的例子了。有许多年，
UNIX程序员使用着能够容纳极大数值的32位整数一而同时代的MS-DOS程序员使用的还都是