.NET Framework Rootkits – Backdoors Inside Your Framework
1
.NET Framework Rootkits:  
Backdoors inside your 
Framework 
March, 2009 (Revised) 
Erez Metula 
PI:EMAIL 
PI:EMAIL 
 .NET Framework Rootkits – Backdoors Inside Your Framework
2
Table of content 
TABLE OF CONTENT .........................................................................................................................2 
ABSTRACT ............................................................................................................................................3 
INTRODUCTION..................................................................................................................................4 
HOW CAN THE FRAMEWORK BE CHANGED?..........................................................................................4 
MODIFYING THE FRAMEWORK CORE .......................................................................................6 
OVERVIEW - STEPS & TOOLS FOR CHANGING THE FRAMEWORK...........................................................6 
LOCATE THE DLL IN THE GAC ............................................................................................................6 
ANALYZE THE DLL..............................................................................................................................7 
DECOMPILE THE DLL USING ILDASM ...................................................................................................9 
MODIFYING THE MSIL CODE .............................................................................................................10 
RECOMPILE THE DLL USING ILASM....................................................................................................11 
BYPASSING THE GAC STRONG NAME MODEL....................................................................................11 
REVERTING BACK FROM NGEN NATIVE DLL....................................................................................14 
ROOTKIT DEVELOPMENT - FUNCTION INJECTION................................................................................16 
SENDTOURL(STRING URL, STRING DATA)...........................................................................................16 
REVERSESHELL(STRING HOSTNAME, INT PORT)..................................................................................18 
PRACTICAL EXAMPLES .................................................................................................................20 
FORMS AUTHENTICATION CREDENTIAL STEALING..............................................................................20 
BACKDOORING FORMS AUTHENTICATION...........................................................................................20 
INSTALLING A REVERSE SHELL INSIDE A FRAMEWORK DLL...............................................................21 
DNS RECORD FIXATION......................................................................................................................22 
STEALING THE CONNECTION STRING FOR EVERY CONNECTION OPENING............................................22 
INJECTING BROWSER EXPLOITATION FRAMEWORK INTO AUTO GENERATED HTML/JS FILES.............22 
ENCRYPTION KEY FIXATION / STEALING /DOWNGRADING / ETC..........................................................23 
SECURESTRING STEALING...................................................................................................................23 
DISABLING SECURITY CHECKS............................................................................................................24 
AUTOMATING THE PROCESS WITH .NET-SPLOIT.................................................................25 
OTHER PLATFORMS RELEVANCY – JAVA ROOTKITS.........................................................29 
CONCLUSIONS...................................................................................................................................30 
ABOUT..................................................................................................................................................30 
REFERENCES .....................................................................................................................................31 
 .NET Framework Rootkits – Backdoors Inside Your Framework
3
Abstract 
This paper introduces application level rootkit attacks on managed code 
environments, enabling an attacker to change the language runtime implementation, 
and to hide malicious code inside its core. The paper focuses on the .NET Framework, 
but the concepts described in this paper can also be applied to other platforms such as 
Java's JVM. 
The paper covers various ways to develop rootkits for the .NET framework, so that 
every EXE/DLL that runs on a modified Framework will behave differently than what 
it's supposed to do. Code reviews will not detect backdoors installed inside the 
Framework since the payload is not in the code itself, but rather it is inside the 
Framework implementation. Writing Framework rootkits will enable the attacker to 
install a reverse shell inside the framework, to steal valuable information, to fixate 
encryption keys, disable security checks and to perform other nasty things as 
described in this paper.  
This paper also introduces ".Net-Sploit" - a new tool for building MSIL rootkits that 
will enable the user to inject preloaded/custom payload to the Framework core DLL. 
 .NET Framework Rootkits – Backdoors Inside Your Framework
4
Introduction 
The .NET framework is a powerful development environment which became the de-
facto environment for software development. With .NET you can develop web 
applications, windows applications, web services and more. 
As a managed code environment, .NET enables the code to run inside its virtual 
machine - the CLR [1] – while abstracting the low level calls, allowing MSIL [2] code 
to benefit from the services it gives. 
Since the code written by the developer, whether it's in c#, vb.net, cobol.net, etc. must 
be compiled to MSIL, and afterwards to the CPU's instruction set on the fly ("JIT – 
Just In Time"), it is easy to reverse engineer it and extract the MSIL code from .NET 
compiled code. Readers are encouraged to learn more about .NET assembly reverse 
engineering [3] in order to better understand the techniques discussed in this paper. 
The process of assembly reverse engineering is much documented and there are many 
tools that enables you to observe the code of a given DLL and tamper with it. This 
paper discusses a new technique in which the traditional methods are applied to the 
Framework DLL in order to change the .NET language and install malicious code 
such as backdoors and rootkits inside it. 
Using Framework level rootkits, you can implement: 
• API Hooking (pre / post) 
• Method code modification 
• Object member manipulation 
• Method parameter manipulation 
• Polymorphism method overloading 
• Return value modification 
• Metadata streams tampering 
• RVA (Relative Virtual Address) item modification 
• Exe dynamic forking 
This paper will provide an example for some of the techniques listed above. 
How can the Framework be changed? 
Since a Framework DLL is just a regular .NET assembly after all, it is possible to 
apply the same concepts of reversing on this DLL in order to achieve code tampering.  
Tampering with the Framework DLL's means that we can modify the implementation 
of methods that the Framework exposes to the upper layer – the application. 
Since application level code relies on the Framework lower level methods to perform 
its job, changing the lower lever methods means that all the applications that rely on it 
will be influenced - and by that taking complete control over its behavior. 
The following abstract diagram shows this workflow – an example application code 
calls Console.WriteLine to print some string. WriteLine is implemented in a 
Framework DLL called mscorlib.dll, and in this example it was changed to always 
print the string "Hacked!".  
The end result here is that every application calling WriteLine will have this modified 
behavior, of displaying every string twice. 
 .NET Framework Rootkits – Backdoors Inside Your Framework
5
The methods described in this paper can be applied to any version of the .NET 
Framework (1.0, 1.1, 2.0, 3.0, and 3.5).  
In order to maintain consistency, this paper focuses on version 2.0 of the .NET 
Framework, but can easily be applied to other versions of the Framework. 
And, as a side note – the methods described in this paper are not restricted only for the 
.NET Framework,  but can also be applied to other VM based platforms, such as Java. 
It is important to mention that the technique described in this paper is 
considered as a post exploitation type attack! Such attacks are usually deployed 
after an attacker has managed to penetrate a system (using some other attack) and 
want to leave backdoors and rootkits behind, for further exploitation. 
In other words, changing the Framework requires administrator level privileges.  
Windows \ Web application
.Net Class Library
Windows APIs and services
public void class DoSomething() 
 {  
//some code  
……….. 
Console.WriteLine(“Some String”);  
} 
mscorlib.dll 
 public static void Write ( string value )
 {
 ……// My Evil  Code
 DoEvilThing(value) … 
} 
User interface 
Hacked! 
public static void WriteLine ( string s ) 
{ 
//code that prints "Hacked!" regardless of 
//the string s 
}  
 .NET Framework Rootkits – Backdoors Inside Your Framework
6
Modifying the Framework core 
Framework modification can be achieved by tampering with a Framework DLL and 
"pushing" it back into the Framework. 
This section describes in detail the necessary steps and the tools used to achieve this 
goal. 
The following steps will be demonstrated with a simple and intuitive example - we 
will modify the internal implementation of the "WriteLine(string s)" method so that 
every time it is called "s" will be printed twice. 
Overview - steps & tools for changing the Framework 
The process is composed of the following steps: 
 Locate the DLL in the GAC, and copy it outside 
 Analyze the DLL 
 Decompile the DLL using ildasm 
 Modify the MSIL code  
 Recompile to a new DLL using ilasm 
 Bypass the GAC strong name protection 
 Reverting back from NGEN Native DLL 
 Deploy the new DLL while overwriting the original 
Below are the tools needed to perform the methods described next: 
 Filemon – locating which DLL’s are used and their location in the GAC 
 Reflector – analyzing the DLL code 
 Ilasm – compiling (MSIL -> DLL) 
 Ildasm – decompiling (DLL -> MSIL) 
 Text editor – modifying the MSIL code 
 Ngen - native compiler 
Locate the DLL in the GAC 
Our example begins with a simple "Runme.exe" test application that calls 
Console.WriteLine in order to print some string - obviously, only 1 time. 
The compiled application code will help us to identify what are the Framework DLL's 
used and their exact location. 
class Hello 
{ 
    static void Main(string[] args) 
    { 
        Console.WriteLine("Hello (crazy) World!"); 
    } 
} 
 .NET Framework Rootkits – Backdoors Inside Your Framework
7
Using Filemon [4], a file access monitor tool, it is possible to observe the files that our 
Runme.exe application is making. Our mission is to identify which DLL is used and 
its location in the GAC (Global Assembly Cache). 
Looking at Filemon while executing "Runme.exe" gives us the following information: 
As can be seen, we can identify access to the file mscorlib.dll, located at  
c:\WINDOWS\assembly\GAC_32\mscorlib\2.0.0.0__b77a5c561934e089. 
This DLL file contains the WriteLine function (among other important functions), and 
it’s of the most important DLL’s. 
After we have located it - let’s copy it to some temp directory, outside of the GAC. 
Now, our task will be to locate the "WriteLine(string)" method inside the mscorlib.dll 
and modify its MSIL code, which will be discussed in the following sections. 
Analyze the DLL 
The next thing we would like to do is to peek at the code of this interesting DLL, 
which is responsible for many of the basic operations such as IO, Security, Reflection, 
etc. 
In order to better understand the MSIL code, it is preferred to observe it in a higher 
level .NET language, such as C#. 
Reflector [5], which is an amazing tool for various .NET assembly reversing, can help 
us analyze the code and decide where and what we want to do. 
 .NET Framework Rootkits – Backdoors Inside Your Framework
8
Looking at mscorlib, we can find the WriteLine method under the System namespace 
at the Console class. The information about the namespace and class can be retrieved 
from the runme executable MSIL code: 
call  void [mscorlib]System.Console::WriteLine(string) 
 .NET Framework Rootkits – Backdoors Inside Your Framework
9
We can see the WriteLine(string) function, and its MSIL code: 
.method public hidebysig static void  WriteLine(string 'value') cil managed 
  { 
    .permissionset linkcheck 
               = {class 'System.Security.Permissions.HostProtectionAttribute, mscorlib, 
Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089' = {property 
bool 'UI' = bool(true)}} 
    // Code size       12 (0xc) 
    .maxstack  8 
    IL_0000:  call       class System.IO.TextWriter System.Console::get_Out() 
    IL_0005:  ldarg.0 
    IL_0006:  callvirt   instance void System.IO.TextWriter::WriteLine(string) 
    IL_000b:  ret 
  } // end of method Console::WriteLine 
The method starts with a signature (containing some information that we'll refer to 
later), the stack size, and the code itself. 
The lines starting with IL_XXXX are the MSIL code for this function. Those lines are 
the ones we want to change. 
Now let's decompile this DLL using ildasm. 
Decompile the DLL using ildasm 
"ildasm" is The framework's MSIL disassembler that can produce MSIL code from a 
given assembly (EXE / DLL). 
Method 
signature 
Stack 
size 
Method 
MSIL 
code 
 .NET Framework Rootkits – Backdoors Inside Your Framework
10
So in order to generate the MSIL code for mscorlib.dll, and write the output to 
mscorlib.dll.il we'll execute the following command: 
Modifying the MSIL code 
Now we have the decompiled code at mscorlib.dll.il, which is actually a text file 
containing MSIL code that is easy to work with. Let's load it in a text editor. 
Searching for the method signature 
.method public hidebysig static void  WriteLine(string 'value') cil managed 
will brings us to the beginning of this function. 
Our task is, in order to make the WriteLine function print every string twice, is to 
double the MSIL code in this method that does this work. 
So we'll take the original lines of code (marked blue) 
IL_0000:  call       class System.IO.TextWriter System.Console::get_Out() 
IL_0005:  ldarg.0 
IL_0006:  callvirt   instance void System.IO.TextWriter::WriteLine(string) 
IL_000b:  ret 
And double them. We will now have 3 new lines of code (marked red), injected 
between the end of the original code and the last "ret" (return opration). 
IL_0000:  call       class System.IO.TextWriter System.Console::get_Out() 
IL_0005:  ldarg.0 
IL_0006:  callvirt   instance void System.IO.TextWriter::WriteLine(string) 
IL_000b:  call       class System.IO.TextWriter System.Console::get_Out() 
IL_0010:  ldarg.0 
IL_0011:  callvirt   instance void System.IO.TextWriter::WriteLine(string) 
IL_0016:  ret 
As can be seen, MSIL line recalculation needs to be performed for the new lines, 
according to MSIL code specification ("call" operation takes 5 bytes, "load" operation 
takes 1 byte, and so on). 
Another important thing we need to do is to fix the ".maxstack" directive which tells 
the CLR how much memory to allocate for this function on the stack. Although in 
some cases (such as this) it can be ignored, it is best to set this value to be 
New_maxstack = original_maxstack + appended_code_maxstack 
ILDASM /OUT=mscorlib.dll.il /NOBAR /LINENUM /SOURCE mscorlib.dll 
Original 
MSIL 
code 
Modified 
MSIL 
code 
 .NET Framework Rootkits – Backdoors Inside Your Framework
11
So finally, WriteLine's code will be: 
.method public hidebysig static void  WriteLine(string 'value') cil managed 
  { 
    .permissionset linkcheck 
               = {class 'System.Security.Permissions.HostProtectionAttribute, mscorlib, 
Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089' = {property 
bool 'UI' = bool(true)}} 
    // Code size       12 (0xc) 
    .maxstack  16 
    IL_0000:  call       class System.IO.TextWriter System.Console::get_Out() 
    IL_0005:  ldarg.0 
    IL_0006:  callvirt   instance void System.IO.TextWriter::WriteLine(string) 
    IL_000b:  call       class System.IO.TextWriter System.Console::get_Out() 
    IL_0010:  ldarg.0 
    IL_0011:  callvirt   instance void System.IO.TextWriter::WriteLine(string) 
    IL_0016:  ret 