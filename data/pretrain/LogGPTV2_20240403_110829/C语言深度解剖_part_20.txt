【规则6-12】如果函数中的参数较长，则要进行适当的划分。
例如：
【规则6-13】用正确的反义词组命名具有互斥意义的变量或相反动作的函数等。
例如：
int aiMinValue;
- 106 -
int aiMaxValue;
int niSet_Value(⋯);
int niGet_Value(⋯);
【规则6-14】如果代码行中的运算符比较多，用括号确定表达式的操作顺序，避免使
用默认的优先级。
{
int a;
int b;
int c;
};
if (condition){
//program code
}
else{
//program code
}
例如：
leap_year = ((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0)；
【规则6-15】不要编写太复杂的复合表达式。
例如：
i = a >= b&&c = 10))
应改为： if (num 0)
{
fun(i/2);
}
printf("%d\n",i);
}
- 109 -
intmain()
{
fun(10);
return 0;
}
问：输出结果是什么？
这是我上课时，一个学生问我的问题。他不明白为什么输出的结果会是这样：
0
1
2
5
10
他认为应该输出0。因为当i 小于或等于0 时递归调用结束，然后执行printf 函数打
印i 的值。这就是典型的没明白什么是递归。其实很简单，printf("%d\n",i);语句是fun
函数的一部分，肯定执行一次fun 函数，就要打印一行。怎么可能只打印一次呢？关键就
是不明白怎么展开递归函数。展开过程如下：
void fun(int i)
{
if (i>0)
{
//fun(i/2);
if(i/2>0)
{
if(i/4>0)
{
…
}
printf("%d\n",i/4);
}
printf("%d\n",i/2);
}
printf("%d\n",i);
}
这样一展开，是不是清晰多了？其实递归本身并没有什么难处，关键是其展开过程别弄
错了。
6.4.2 丌使用任何变量编写 strlen 函数
看到这里，也许有人会说，strlen 函数这么简单，有什么好讨论的。是的，我相信你
能熟练应用这个函数，也相信你能轻易的写出这个函数。但是如果我把要求提高一些呢：
不允许调用库函数，也不允许使用任何全局或局部变量编写intmy_strlen (char
*strDest);似乎问题就没有那么简单了吧？这个问题曾经在网络上讨论的比较热烈，我几
乎是全程“观战”，差点也忍不住手痒了。不过因为我的解决办法在我看到帖子时已经有人
提出了，所以作罢。解决这个问题的办法由好几种，比如嵌套有编语言。因为嵌套汇编一般
- 110 -
只在嵌入式底层开发中用到，所以本书就不打算讨论C 语言嵌套汇编的知识了。有兴趣的读
者，可以查找相关资料。
也许有的读者想到了用递归函数来解决这个问题。是的，你应该想得到，因为我把这个
问题放在讲解函数递归的时候讨论。既然已经有了思路，这个问题就很简单了。代码如下：
intmy_strlen( const char* strDest )
{
assert(NULL != strDest);
if ('\0' == *strDest)
{
return 0;
}
else
{
return (1 + my_strlen(++strDest));
}
}
第一步：用assert 宏做入口校验。
第二步：确定参数传递过来的地址上的内存存储的是否为'\0'。如果是，表明这是一
个空字符串，或者是字符串的结束标志。
第三步：如果参数传递过来的地址上的内存不为'\0'，则说明这个地址上的内存上存
储的是一个字符。既然这个地址上存储了一个字符，那就计数为1，然后将地址加1 个char