 免锁事务管理：MOT在保证严格一致性和数据完整性的前提下，采用乐观的策略实现
高并发和高吞吐。在事务过程中，MOT不会对正在更新的数据行的任何版本加锁，从
而大大降低了一些大内存系统中的争用。事务中的乐观并发控制（Optimistic
ConcurrencyControl，OCC）语句是在没有锁的情况下实现的，所有的数据修改都是在
内存中专门用于私有事务的部分（也称为私有事务内存）中进行的。这就意味着在事务
过程中，相关数据在私有事务内存中更新，从而实现了无锁读写；而且只有在提交阶段
才会短时间加锁。更多详细信息，请参见MOT并发控制机制。
 免锁索引：由于内存表的数据和索引完全存储在内存中，因此拥有一个高效的索引数据
南大通用数据技术股份有限公司
440
GBase 8s V8.8开发者手册
结构和算法非常重要。MOT索引机制基于最先进的Masstree，这是一种用于多核系统
的快速和可扩展的键值（KeyValue，KV）存储索引，以B+树的Trie实现。通过这种
方式，高并发工作负载在多核服务器上可以获得卓越的性能。同时MOT应用了各种先
进的技术以优化性能，如优化锁方法、高速缓存感知和内存预取。
 NUMA-aware的内存管理：MOT内存访问的设计支持非统一内存访问（NUMA）感知。
NUMA-aware算法增强了内存中数据布局的性能，使线程访问物理上连接到线程运行的
核心的内存。这是由内存控制器处理的，不需要通过使用互连（如英特尔QPI）进行额
外的跳转。MOT的智能内存控制模块，为各种内存对象预先分配了内存池，提高了性
能，减少了锁，保证了稳定性。事务的内存对象的分配始终是NUMA本地的。本地处
理的对象会返回到池中。同时在事务中尽量减少系统内存分配（OSmalloc）的使用，
避免不必要的锁。
 高效持久性：日志和检查点是实现磁盘持久化的关键能力，也是ACID的关键要求之一
（D代表持久性）。目前所有的磁盘（包括SSD和NVMe）都明显慢于内存，因此持
久化是基于内存数据库引擎的瓶颈。作为一个基于内存的存储引擎，MOT的持久化设
计必须实现各种各样的算法优化，以确保持久化的同时还能达到设计时的速度和吞吐量
目标。这些优化包括：
 并行日志，所有磁盘表都支持。
 每个事务的日志缓冲和无锁事务准备。
 增量更新记录，即只记录变化。
 除了同步和异步之外，创新的NUMA感知组提交日志记录。
 最先进的数据库检查点（CALC）使内存和计算开销降到最低。
 高SQL覆盖率和功能集：MOT通过扩展的PostgreSQL外部数据封装（FDW）以及索
引，几乎支持完整的SQL范围，包括存储过程、用户定义函数和系统函数调用。有关
不支持的功能的列表，请参阅MOTSQL覆盖和限制。
 使用PREPARE语句的查询原生编译：通过使用PREPARE客户端命令，可以以交互方
式执行查询和事务语句。这些命令已被预编译成原生执行格式，也称为Code-Gen或即
时（Just-in-Time，JIT）编译。这样可以实现平均30%的性能提升。在可能的情况下，
应用编译和轻量级执行；否则，使用标准执行路径处理适用的查询。CachePlan模块已
针对OLTP进行了优化，在整个会话中甚至使用不同的绑定设置以及在不同的会话中重
用编译结果。
南大通用数据技术股份有限公司
441
GBase 8s V8.8开发者手册
 MOT和数据库的无缝集成：MOT是一个高性能的面向内存优化的存储引擎，已集成在
GBase8s数据库包中。MOT的主内存引擎和基于磁盘的存储引擎并存，以支持多种应
用场景，同时在内部重用数据库辅助服务，如WAL重做日志、复制、检查点和恢复高
可用性等。用户可以从基于磁盘的表和MOT的统一部署、配置和访问中受益。根据特
定需求，灵活且低成本地选择使用哪种存储引擎。例如，把会导致瓶颈的高度性能敏感
数据放入内存中。
13.1.4 MOT 应用场景
MOT可以根据负载的特点，显著加快应用程序的整体性能。MOT通过提高数据访问和
事务执行的效率，并通过消除并发执行事务之间的锁和锁存争用，最大程度地减少重定向，
从而提高了事务处理的性能。
MOT的极速不仅因为它在内存中，还因为它围绕并发内存使用管理进行了优化。数据
存储、访问和处理算法从头开始设计，以利用内存和高并发计算的最新先进技术。
GBase8s允许应用程序随意组合MOT和基于标准磁盘的表。对于启用已证明是瓶颈的
最活跃、高争用和对性能敏感的应用程序表，以及需要可预测的低延迟访问和高吞吐量的表
来说，MOT特别有用。
MOT可用于各种应用，例如：
 高吞吐事务处理：这是使用MOT的主要场景，因为它支持海量事务，同时要求单个事
务的延迟较低。这类应用的例子有实时决策系统、支付系统、金融工具交易、体育博彩、
移动游戏、广告投放等。
 性能瓶颈加速：存在高争用现象的表可以通过使用MOT受益，即使该表是磁盘表。由
于延迟更低、竞争和锁更少以及服务器吞吐量能力增加，此类表（除了相关表和在查询
和事务中一起引用的表之外）的转换使得性能显著提升。
 消除中间层缓存：云计算和移动应用往往会有周期性或峰值的高工作负载。此外，许多
应用都有80%以上负载是读负载，并伴有频繁的重复查询。为了满足峰值负载单独要
求，以及降低响应延迟提供最佳的用户体验，应用程序通常会部署中间缓存层。这样的
附加层增加了开发的复杂性和时间，也增加了运营成本。MOT提供了一个很好的替代
方案，通过一致的高性能数据存储来简化应用架构，缩短开发周期，降低CAPEX 和
OPEX成本。
 大规模流数据提取：MOT 可以满足云端（针对移动、M2M 和物联网）、事务处理
（TransactionalProcessing，TP）、分析处理（AnalyticalProcessing，AP）和机器学习
南大通用数据技术股份有限公司
442
GBase 8s V8.8开发者手册
（MachineLearning，ML）的大规模流数据的提取要求。MOT尤其擅长持续快速地同
时提取来自许多不同来源的大量数据。这些数据可以在以后进行处理、转换，并在速度
较慢的基于磁盘的表中进行移动。另外，MOT还可以查询到一致的、最新的数据，从
而得出实时结果。在有许多实时数据流的物联网和云计算应用中，通常会有专门的数据
摄取和处理。例如，一个ApacheKafka集群可以用来提取10万个事件/秒的数据，延迟
为10ms。一个周期性的批处理任务会将收集到的数据收集起来，并将转换格式，放入
关系型数据库中进行进一步分析。MOT可以通过将数据流直接存储在MOT关系表中，
为分析和决策做好准备，从而支持这样的场景（同时消除单独的数据处理层）。这样可
以更快地收集和处理数据，MOT避免了代价高昂的分层和缓慢的批处理，提高了一致
性，增加了分析数据的实时性，同时降低了总拥有成本（TotalCostofOwnership，TCO）。
 降低TCO：提高资源利用率和消除中间层可以节省30%到90%的TCO。
13.2使用 MOT
本章介绍如何部署、使用和管理MOT。使用MOT的方法非常简单，相关命令语法与
GBase8s基于磁盘的表相同。只有MOT中的创建和删除表语句有所不同。本章主要介绍
MOT入门、如何将基于磁盘的表转换为MOT、如何使用MOT 的查询原生编译功能以及
MOT的局限性和覆盖面。还包括MOT管理选项，以及如何进行TPC-C基准测试。
13.2.1 MOT 使用概述
MOT作为GBase8s的一部分自动部署。有关如何计算和规划所需的内存和存储资源以
维持工作负载的说明，请参阅MOT准备。参考MOT部署了解MOT中所有的配置，以及
服务器优化的非必须选项。
使用MOT的方法非常简单。MOT命令的语法与基于磁盘的表的语法相同，并支持大
多数标准，如PostgreSQLSQL、DDL和DML命令和功能，如存储过程。只有MOT中的创
建和删除表语句有所不同。您可以参考MOT使用了解这两个简单命令的说明，如何将基于
磁盘的表转换为MOT，如何使用查询原生编译和PREPARE语句获得更高的性能，以及了
解外部工具支持和MOT引擎的限制。
MOT管理介绍了如何进行数据库维护，以及监控和分析日志和错误报告。最后，MOT
样例TPC-C基准介绍了如何执行标准TPC-C基准测试。
阅读以下流程了解如何使用MOT：
南大通用数据技术股份有限公司
443
GBase 8s V8.8开发者手册
13.2.2 MOT 准备
下文介绍了使用MOT的前提条件以及内存和存储规划。
前提条件
以下是使用GBase8sMOT的软硬件前提条件。
 硬件支持
MOT支持最新硬件和现有硬件平台，支持x86架构和华为鲲鹏Arm架构。
MOT能够支持GBase8s数据库支持的硬件。
 CPU
MOT在多核服务器（扩容）上提供卓越的性能。在这些环境中，MOT的性能明显优于
友商，并提供近线性扩展和极高的资源利用率。
用户也可以开始在低端、中端和高端服务器上实现MOT的性能优势，无论CPU槽位
是1或2个，还是4个，甚至是8个也没问题。在16路甚至32路的高端服务器上，性能和
资源利用率也非常高。
 内存
MOT支持标准RAM/DRAM用于其数据和事务管理。所有MOT数据和索引都驻留在
内存中，因此内存容量必须能够支撑数据容量，并且还有进一步增长的空间。内存需求和规
划，详见MOT内存和存储规划。
 存储IO
MOT是一个持久的数据库，使用永久性存储设备（磁盘/SSD/NVMe驱动器）进行事务
南大通用数据技术股份有限公司
444
GBase 8s V8.8开发者手册
日志操作和存储定期检查点。
推荐采用低延迟的存储设备，如配置RAID-1的SSD、NVMe或者任何企业级存储系统。
当使用适当的硬件时，数据库事务处理和竞争将成为瓶颈，而非IO。
详细的内存要求和规划，详见MOT内存和存储规划。
 操作系统支持
MOT支持裸机和虚拟化环境
 操作系统优化
MOT不需要任何特殊修改或安装新软件。但是，一些优化可以提高性能。有关实现最
大性能的优化说明，请参阅MOT服务器优化。
MOT内存和存储规划
本节描述了为满足特定应用程序需求，在评估、估计和规划内存和存储容量数量时，需
要注意的事项和准则，以及影响所需内存数量的各种数据，例如计划表的数据和索引大小、
维持事务管理的内存以及数据增长的速度。
 MOT内存规划
MOT是一种内存数据库存储引擎（IMDB），其中所有表和索引完全驻留在内存中。
内存存储是易失的，需要电力来维护所存储的信息。磁盘存储是持久的，写入磁盘是非
易失性存储。MOT使用两种存储，既把所有数据保存在内存中，也把事务性更改同步
（通过WAL日志记录）到磁盘上以保持严格一致性（使用同步日志记录模式）。
服务器上必须有足够的物理内存以维持内存表的状态，并满足工作负载和数据的增长。
所有这些都是在传统的基于磁盘的引擎、表和会话所需的内存之外的要求。因此，提前规划
好足够的内存来容纳这些内容是非常有必要的。
开始可以使用任何数量的内存并执行基本任务和评估测试。但当准备好生产时，应解决
以下问题：
 内存配置
GBase8s数据库和标准Postgres类似，其内存上限是由max_process_memory设置的，
该上限在postgresql.conf文件中定义。MOT及其所有组件和线程，都驻留在进程中。因此，
分配给MOT的内存也是在整个数据库进程的max_process_memory定义的上限内分配。
南大通用数据技术股份有限公司
445
GBase 8s V8.8开发者手册
MOT为自己保留的内存是max_process_memory的一部分。可以通过百分比或通过小于
max_process_memory的绝对值定义。这个部分在mot.conf配置文件中由_mot__memory配置
项定义。
max_process_memory中可以除了被MOT使用的部分之外，必须为Postgres（GBase8s）
封装留下至少2GB的可用空间。为了确保这一点，MOT在数据库启动过程中会进行如下校
验：
(max_mot_global_memory+max_mot_local_memory)+2GBMOTenginemaximummemorydefinitions(global:9830MB,
local:1843MB,sessionlargestore:0MB,total:11673MB)breachGaussDBmaximum
processmemoryrestriction(12288MB)and/ortotalsystemmemory(64243MB).MOTvalues
shallbeadjustedaccordinglytopreserverequiredgap(2048MB).
以下警告消息示例提示MOT正在自动调整内存限制：
[WARNING]AdjustingMOTmemorylimits:global=8623MB,local=1617
MB,sessionlargestore=0MB,total=10240MB
新内存限制仅在此处显示。
此外，当总内存使用量接近所选内存限制时，MOT不再允许插入额外数据。不再允许
额外数据插入的阈值即是MOT最大内存百分比（如上所述，这是一个计算值）。MOT最
大内存百分比默认值为90，即90%。尝试添加超过此阈值的额外数据时，会向用户返回错
误，并且也会注册到数据库日志文件中。
 最小值和最大值
为了确保内存安全，MOT根据最小的全局和本地设置预先分配内存。数据库管理员应
指定MOT和会话维持工作负载所需的最小内存量。这样可以确保即使另一个消耗内存的应
用程序与数据库在同一台服务器上运行，并且与数据库竞争内存资源，也能够将这个最小的
南大通用数据技术股份有限公司
446
GBase 8s V8.8开发者手册
内存分配给MOT。最大值用于限制内存增长。
 全局和本地
MOT使用的内存由两部分组成：
 全局内存：全局内存是一个长期内存池，包含MOT的数据和索引。它平均分布在
NUMA节点，由所有CPU核共享。
 本地内存：本地内存是用于短期对象的内存池。它的主要使用者是处理事务的会话。
这些会话将数据更改存储在专门用于相关特定事务的内存部分（称为事务专用内
存）。在提交阶段，数据更改将被移动到全局内存中。内存对象分配以NUMA-local
方式执行，以实现尽可能低的延迟。
 被释放的对象被放回相关的内存池中。在事务期间尽量少使用操作系统内存分配
（malloc）函数，避免不必要的锁和锁存。
 这 两 个 内 存 的 分 配 由 专 用 的 min/max_mot_global_memory 和
min/max_mot_local_memory设置控制。如果MOT全局内存使用量太接近最大值，
则MOT会保护自身，不接受新数据。超出此限制的内存分配尝试将被拒绝，并向
用户报告错误。
 最低内存要求
在开始执行对MOT性能的最小评估前，请确保：
除了磁盘表缓冲区和额外的内存，max_process_memory（在postgresql.conf中定义）还
有 足 够 的 容 量 用 于 MOT 和 会 话 （ 由 mix/max_mot_global_memory 和
mix/max_mot_local_memory配置）。对于简单的测试，可以使用mot.conf的默认设置。
 生产过程中实际内存需求
在典型的OLTP工作负载中，平均读写比例为80:20，每个表的MOT内存使用率比基
于磁盘的表高60%（包括数据和索引）。这是因为使用了更优化的数据结构和算法，使得
访问速度更快，并具有CPU缓存感知和内存预取功能。
特定应用程序的实际内存需求取决于数据量、预期工作负载，特别是数据增长。
 最大全局内存规划：数据和索引大小
要规划最大全局内存，需满足：
1 确定特定磁盘表（包括其数据和所有索引）的大小。如下统计查询可以确定customer
表的数据大小和customer_pkey索引大小：
南大通用数据技术股份有限公司
447
GBase 8s V8.8开发者手册
 数据大小：选择pg_relation_size（'customer'）；
 索引：选择pg_relation_size（'customer_pkey'）；
2 额外增加60%的内存，相对于基于磁盘的数据和索引的当前大小，这是MOT中的
常见要求。
3 额外增加数据预期增长百分比。例如：
5%月增长率 =80%年增长率（1.05^12）。因此，为了维持年增长，需分配比表当前使
用的还多80%的内存。
至此，max_mot_global_memory 值的估计和规划就完成了。实际设置可以用绝对值或
Postgresmax_process_memory的百分比来定义。具体的值通常在部署期间进行微调。
 最大本地内存规划：并发会话支持
本地内存需求主要是并发会话数量的函数。平均会话的典型OLTP工作负载最大占用
8MB。此值乘以会话的数量，再加一点额外的值。
可以通过这种方式进行内存计算，然后进行微调：
SESSION_COUNT*SESSION_SIZE(8MB)+SOME_EXTRA(100MBshouldbeenough)
默认指定Postgres最大进程内存（默认为12GB）的15%。相当于1.8GB可满足230个
会话，即max_mot_local内存需求。实际设置可以用绝对值或Postgresmax_process_memory
的百分比来定义。具体的值通常在部署期间进行微调。
 异常大事务
某些事务非常大，因为它们将更改应用于大量行。这可能导致单个会话的本地内存增加
到允许的最大限制，即1GB。例如：
deletefromSOME_VERY_LARGE_TABLE;
在配置max_mot_local_memory设置和应用程序开发时，请考虑此场景。
有关配置的更多信息，请参阅内存（MOT）部分。
 存储IO
MOT是一个内存优化的持久化数据库存储引擎。需要磁盘驱动器来存储WAL重做日
志和定期检查点。
推荐采用低延迟的存储设备，如配置RAID-1的SSD、NVMe或者任何企业级存储系统。
南大通用数据技术股份有限公司
448
GBase 8s V8.8开发者手册
当使用适当的硬件时，数据库事务处理和竞争将成为瓶颈，而非IO。
由于持久性存储比RAM内存慢得多，因此IO操作（日志和检查点）可能成为内存中
数据库和内存优化数据库的瓶颈。但是，MOT具有针对现代硬件（如SSD、NVMe）进行
优化的高效持久性设计和实现。此外，MOT最小化和优化了写入点（例如，使用并行日志
记录、每个事务的单日志记录和NUMA-aware事务组写入），并且最小化了写入磁盘的数
据（例如，只把更改记录的增量或更新列记录到日志，并且只记录提交阶段的事务）。
 容量需求
所需容量取决于检查点和记录的要求，如下所述：
 检查点
检查点将所有数据的快照保存到磁盘。
需要给检查点分配两倍数据大小的容量。不需要为检查点索引分配空间。
检查点 =2xMOT数据大小（仅表示行，索引非持久）。
检查点之所以需要两倍大小，是因为快照会保存数据的全部大小到磁盘上，此外还应该
为正在进行的检查点分配同样数量的空间。当检查点进程结束时，以前的检查点文件将被删
除。
MOT增量检查点特性，这将大大降低存储容量需求。