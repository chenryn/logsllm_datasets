# 【技术分享】使用PowerShell Payload暴力破解出口过滤规则
|
##### 译文声明
本文是翻译文章，文章来源：安全客
原文地址：
译文仅供参考，具体内容表达以及含义原文为准。
**翻译：**[ **WisFree**](http://bobao.360.cn/member/contribute?uid=2606963099)
**预估稿费：150RMB（不服你也来投稿啊！）**
**投稿方式：发送邮件至linwei#360.cn，或登陆**[
**网页版**](http://bobao.360.cn/contribute/index) **在线投稿**
**  
**
**前言**
想必各位同学都曾经历过这样的事情吧？你花费了大量的时间和精力去设计一封网络钓鱼邮件，然后还注册了一个看起来“毫无破绽”的域名，并且将所有的数据处理器和你MSF中的multi/handler和其他配置也都全部配置妥当了。然后你就开始像“姜太公钓鱼”一样开始等待着目标上钩，但是当你发现没人买你的账时，你就一脸懵逼了。这是为什么呢？因为出口数据包过滤规则（egress
packet filtering）让你所有的努力全部付诸东流了。
虽然现在也有很多专门针对这种过滤规则的payload和监听器可以使用，而且它们通常都不会出什么大问题。但是如果你与我一样喜欢给自己多一些选择的余地，那么我会推荐你尝试使用一下PowerShell。
**准备工作**
为了更好地给大家演示，我编写了一份只有几行代码的脚本。在这个脚本的帮助下，我就可以尝试使用每一个端口来向我的监听器发送数据包，直到我找出一个开放的端口为止。找到之后，我就可以在我的payload中使用这个端口了。
先设置好你的主机地址和监听器，然后在“$wait”变量中设置超时时间（2000毫秒）。当然了，你也可以适当增加这个超时时间，以保证你的客户端与服务器端有足够的时间进行连接。但是增加超时意味着你在遍历端口的时候将会花费更多的时间，所以你要根据实际情况来设置这个值，在这里我设置成了2000毫秒。
在服务器端我同样也有很多选择，所以我可以根据自己的需要去设置相应的参数。无论是Metasploit的mulit/handler，还是其他各种不同的监听工具（nc、ncat、PowerCat、gcat、以及dnscat等等），我需要设计出一种能够让任意端口都能到达我这个反向SHELL端口的解决方案，于是我选择使用IPtables，让1-65535端口进来的数据都重定向到我multi/handler监听的4444端口。
配置好了IPtable之后，启动metasploit的反向tcp监听器。别忘了，我们在iptables的命令中设置的是端口4444，这里可不能出错。
首先，用社会工程学工具集（SET）生成我们的PowerShell反向tcp
payload，然后编辑payload，将前面给出的那部分代码添加到payload代码的前面。在此，我只需要修改一小部分代码，让payload使用我在代码开头所设置的IP地址（$address
= $Computername）。然后注释掉下面那行设置端口的代码，因为我已经在前面的foreach循环中已经设置好端口号了（$port）。
我们可以在PowerShell的控制台中看到shell的运行状态，当脚本扫描到端口25时将会停止，因为端口25是该shell脚本检测到的第一个开放端口。
**灵活即新颖**
虽然我知道可以使用Metasploit中提供的payload（multi/shell/reverse_tcp_allports）来监听所有端口，但是正如我之前所说的，我们追求的是灵活性。因为Metasploit提供的反向tcp监听器并不适用于很多特殊的情况，所以我们就要避免受到这样的限制。也许你手头上有一台处于隔离区中的从未使用过的Web开发服务器，你有这台服务器的root访问权限，而你正打算在这台服务器上加载你的payload。但是你要知道，在安装这些工具的过程中你很可能会遇到各种各样的麻烦，并且还会受到很多环境限制。无论你因为什么原因而放弃使用Metasploit提供的multi/shell/reverse_tcp_allports
payload，下面这项技术肯定可以给你提供莫大的帮助。
**Powercat Payload**
我配置好了Powercat，然后用Powercat生成了一个payload。
虽然这个payload的代码量巨大，但是我们可以在代码的底部找到Main函数的执行代码。
如上图所示，主函数的运行还需要一些参数变量的支持。于是我便将我的循环代码放在了Main函数被调用之前，以此来保证我的代码可以最先得到执行。接下来，我修改了Main函数的调用参数，我用循环中相对应的参数替换掉了之前的IP地址和端口号。
我将这段脚本代码保存在了“payload.ps1”文件中，然后开启了我的netcat监听器，我通过“while
true”来保证监听器一直处于运行状态。当然了，在这里我仍然要使用端口4444。我们必须要保证payload能够正确扫描到对应端口，并且在扫描成功之后终止监听器的运行。
然后运行payload.ps1
当脚本扫描到端口25（第一个开放端口）之后，我们就成功了！
**  
**
**总结**
没错，就是这么简单！如果网络系统会屏蔽你的出口流量，那么你只需要写几行代码，配置一些IPtable，PowerShell就可以帮你的网络流量找到一条“出路”。请你记住，即便你可以使用Metasploit提供的各种监听器，但你也可以向你的PowerShell
Payload中添加一个简单的循环，这样将会极大地提升你的成功率。
友情提醒：如果你所处的环境中有企业级防火墙的保护，那么你所得到的实验结果很可能会不同。除此之外，使用PowerShell来扫描开放端口的方法也不止这一种，感兴趣的同学可以自行探索其他的方法。