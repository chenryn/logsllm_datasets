# 【技术分享】正则表达式使用不当引发的系统命令执行漏洞

### 译文声明
本文为翻译文章，原文来源：nvisium.com。具体内容及含义以原文为准。

**严正声明**：本文仅供技术讨论与学术学习研究之用，严禁用于非法用途（如未经授权的攻击等）。否则，后果自负，与作者和平台无关。如有不妥之处，请及时联系作者和平台。

- 翻译：[ForrestX386](http://bobao.360.cn/member/contribute?uid=2839753620)
- 预估稿费：100 RMB
- 投稿方式：发送邮件至 [linwei@360.cn](mailto:linwei@360.cn)，或登录[网页版](http://bobao.360.cn/contribute/index) 在线投稿

---

## 前言
在某些情况下，通过正则表达式对字符串进行白名单过滤可能并不理想。本文将通过一个实例展示，在使用正则表达式进行白名单过滤时，可能会导致操作系统命令注入 (OSCI, Operating System Command Injection) 漏洞。

---

## 正文
测试代码如下：

```php
if (preg_match('/^[a-zA-Z0-9_\/\s]*\.rpt$/', $filename)) {
    exec("file -i -b " . escapeshellarg($filename));
} else {
    echo 'regex failed';
}
```

乍一看，这段代码似乎没有什么问题。它匹配文件名由字母、数字、下划线、斜杠、空白字符组成的，并且后缀名为 `.rpt` 的文件。如果匹配成功，则执行系统命令 `file` 打印文件的类型和编码信息；如果匹配失败，则打印 `regex failed`。

起初，我尝试了多种攻击载荷，但都未能成功进行命令注入。后来发现，攻击点在于正则表达式中的 `\s`，它匹配任何空白字符，包括常见的制表符 (`\t`)、回车符 (`\r`)、换行符 (`\n`) 和换页符 (`\f`)。其中，换行符在 shell 环境中可能导致命令注入。例如，以下攻击载荷：

```plaintext
file%0Aid%0A.rpt
```

`%0A` 是 URL 编码后的换行符。显然，这段载荷匹配上述正则表达式。当这段载荷在 shell 环境中执行时，会发生什么？

因为在 shell 环境中，多个命令的分隔符除了分号 (`;`) 之外还有换行符。上述载荷传入 shell 后，会变成两条命令执行：

```shell
file -i -b file
id
.rpt
```

因此，`id` 命令的内容会被打印出来。

如何解决这个问题呢？可以将 `\s` 替换成空格 (`" "`):

```php
if (preg_match('/^[a-zA-Z0-9_\/ ]*\.rpt$/', $filename)) {
    exec("file -i -b " . escapeshellarg($filename));
} else {
    echo 'regex failed';
}
```

你以为这样修改就万事大吉了吗？实际上并非如此。请看以下攻击载荷：

```plaintext
file.rpt%0aid
```

执行后会发生什么呢？很意外地，命令注入成功了。原因是正则表达式结尾的 `/m` 标志。在 PHP 中，`/m` 表示开启多行匹配模式。在这种模式下，`^` 和 `$` 可以匹配每行的开头和结尾。因此，上述载荷中的换行符使得内容被当作两行处理，只要有一行匹配成功即可进入 `exec` 分支，从而导致命令执行。

---

## 总结
在使用正则表达式构建白名单时，一定要小心谨慎，尤其是在涉及命令执行的情况下。有时候，明确具体的白名单更好。例如，在类似场景中，我们可以定义一些完整的允许的文件名，而不是使用正则表达式。