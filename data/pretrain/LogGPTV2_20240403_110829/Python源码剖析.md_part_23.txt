lineno += 1ine_incr
到了现在，更进一步，我们还可以解析字节码指令序列。前面我们已经知道，Python
将图7-9、图7-10与表7-1中对PyCodeObject对象各个域的描述对照参考，就能更
下面是从一段Python源代码对应的ryCodeobject解析出字节码指令序列的结果，这
对照demo.py，你会发现这些对象都是其中定义的对象的名字。可以看到，其实co_names
STORE_NAME
LOAD_CONST
图7-9中显示的是pyc文件中的第三部分
图7-10demo.pyc中的符号表（co_names）和局部变量表（co_vamames）
addr_incn
A:
1ine_iner In c_lnotab:
/m
Python源码剖析
一PyCodeobject。可以看到，在pyCode
7.5解析pyc文件
深度探索动态语言核心技术
131
---
## Page 162
Python源码剖析
132
事啊。遥远的天空，一抹朝阳，缓缓升起了。
到达的地方出发，我们就可以做出一个Python的执行引擎了，，这是多么激动人心的
我们自己的解析结果。
当前的字节码指令，最后一列显示了当前字节码指令的参数。
的行数，左起第2列显示的是当前的字节码指令在co_code中的偏移位置，第3列显示了
些，
令信息。利用这个工具，可以很容易地得到我们在这里得到的结果，当然，还要更详细一
个名为dis的方法，这个方法接收一个code对象，然后会输出code对象里的字节码指
能够解析pyc文件，对于我们来说，实际上是一件非常重要的成就，想一想，从现在
在以后的分析中，我们大部分将采用dis工具的解析结果，在有些特殊情况下会使用
，图7-l1展示了利用dis工具对declare.py进行解析的结果：
在图7-11显示的结果中，最左面一列显示的是字节码指令对应的源码在declare.py中
="Python"
事实上，Python标准库中提供了对python的code对象进行解析的工具dis，dis提供
第7章
RETURN VALUE
STORE_NAME
BUILDLIST
STORENAME
BUTLD_MAP
STOREINAME
LOAD_CONST
一深度探索动态语言核心技术
Python的编译结果
图7-11利用dis工具对declare.py对应的code对象进行解析
dis.dis(co)
NW
none
compile(s,
dis
27
24
2
6LOAD_CONST
0LOAD CONST
BUILD_LIST
STORE NAME
BUILD_MAP
LOAD
STORE
Code对象与pyc文件
declare.py
CONST
NAME
exec")
2（d）
(None)
(1）
---
## Page 163
8.1
件是以一种什么方式运行的。在这里，我们主要关注运行时栈的栈帧，如图8-1所示：
因此，在进入Python的虚拟机之前，我们先来看一看在普通的x86的机器上，可执行文
的运行机理有一个大致的了解，那么对于理解Pyhon虚拟机的运行机理是相当有益的。
反复运行，所有由Pyhon源代码所规定的动作都会如期望一样，一
对象中依次读入每一条字节码指令，并在当前的上下文环境中执行这条字节码指令。如此
就将由Python的虚拟机接手整个工作。Python的虚拟机会从编译得到的Pycodeobject
Python虚拟机等名称。
行机理。在以后提及Py山on字节码虚拟机时，我们可能会根据不同情况使用虚拟机或
Python虚拟机中的执行环境
Pyton的虚拟机是Python的核心，在.py源代码被编译器编译为字节码指令序列之后
Pyhon的虚拟机实际上是在模拟操作系统运行可执行文件的过程，如果对可执行文件
从本章开始，我们将切入Python字节码虚拟机，深入剖析Pyhon字节码虚拟机的运
Python虚拟机框架
Python源码剖析
一深度探索动态语言核心技术
一一展开。
第
CHAPTER
---
## Page 164
Python源码剖析
134
然，在函数调用发生时，系统会保存上一个栈帧的栈指针esp和帧指针ebp。当函数王执
g中执行函数的调用时，系统就会在地址空间中，于g的栈帧之后，创建的栈顿。当
的栈帧中完成，而函数之间的调用则通过创建新的栈帧完成。
而“当前帧”则是函数主的栈帧。对于一个函数而言，其所有对局部变量的操作都在自己
intmain()
void g()
void E(int a,int b)
在图8-1所示的系统中，运行时栈是从地址空间的高地址向低地址延伸的。
当程序的流程进入函数时，对应于图8-1。其中“调用者的帧”是函数g的栈帧，
g0;
（，2）
printf("a=d,
图8-1所展示的运行时栈的情形可以看作是如下的C代码运行时的情形：
第8章
一深度探索动态语言核心技术
Python虚拟机框架
栈指针
帧指针
地址增大
b=wdn”a.b）
ebp
图8-1
可执行文件运行时的运行时栈
局部变量和临时变
被保存的寄存器，
被保存的ebp
返回地址
栈顶
参数1
参数n
栈底
......
当前帧
调用者的帧
较早的帧
当在函数
---
## Page 165
中某个变量的值，以影响后续的字节码指令。这样的过程会一直持续下去，直到发生了函
Pyhon可以从这个执行环境中获取变量的值，也可以根据字节码指令的指示修改执行环境
Pyhon已经建立起了一个执行环境A，所有的字节码指令都会在这个执行环境中执行。
environment.py的执行过程。当Python开始执行environment.py中的第一条表达式时，
包含了其他的一些信息。
字空间。实际上，名字空间仅仅是执行环境的一部分，除了名字空间，在执行环境中，还
东西。它们确实比较相似，但是，我们在之后将看到的执行环境的概念并不完全等同于名
些信息是不可能在PyCodeobject对象中被静态地存储的。
的不同时刻对应不同的值，甚至不同类型的情况，必须在运行时动态地被捕捉和维护。这
在执行2处的print时，执行环境中i的值为“Python”。像这种同样的符号在程序运行
在执行环境的影响下产生的。在执行“1”处的print时，执行环境中，的值为999；而
对应的字节码指令肯定是相同的，但是这两条语句的执行效果是不同的。这样的结果正是
关于程序运行的动态信息一
所有静态信息。然而有一点，是PyCodeobject对象没有包含，也不可能包含的。这就是
Object对象上进行所有的动作呢？
静态信息都存放在pyCodeobject对象中，那么Python的虚拟机是否就是在这个ryCode-
这并不妨碍你对后面内容的理解。
理，从而完成了Pyton字节码指令序列的执行。如果你对这个过程不是太清晰，不要紧，
机器上的大致运行原理。而Pyhon正是在其虚拟机中通过不同的实现方式模拟了这一原
回到了函数g中，而程序工作的空间则又回到了函数g的栈帧中。这就是可执行文件在x86
int#2
行完成之后，系统会把esp和ebp的值恢复为创建的栈帧之前的值，这样程序的流程又
def
[environment.py]
结合x86平台运行可执行文件的机理，我们可以用这样的机理来定性地解释
细心的读者一定发现了，这里的执行环境和我们之前所提到的名字空间似乎是同一个
在上面代码中的1和2两个地方，都进行了同样的动作，即printi。显然，它们所
#U
什么是执行环境呢，考虑下面的一个例子：
答案并不唯一。PyCodeobject对象中包含了最关键的字节码指令，以及关于程序的
上一章的剖析表明Pyuhon源代码经过编译之后，所有的字节码指令以及程序的其他
（
Python
666
一执行环境。
Python源码剖析
8.1Python虚拟机中的执行环境
一深度探索动态语言核心技术
135
---
## Page 166
8.1.1
136
Python源码剖析
object的定义：
的那个简简单单的栈帧，它实际上包含了其他更多的信息。请看Pyhon源码中对pyFrame-
x86平台上栈帧的模拟。你瞧，它的名字中还有个Frame呢。
对象，而是另一个对象一PyFrameObject。它就是我们所说的执行环境，也是Python对
的对象。这个新的执行环境B实际上可以对应图8-1中所示的一个新的栈帧。
之外重新创建一个新的执行环境B，在这个新的执行环境B中，有一个新的名字为“”
对象，而这些对象会被链接起来，形成一条执行环境链表。这正是对x86机器上栈顿间关
数的调用行为。
间的关系。前面我们说名字空间实际上是维护着变量名和变量值之间关系的PyDictObject
不是这样呢，
后能顺利回到旧的栈顿中，而Pyton正是利用_back来完成这个动作。那真实的情况是
系的模拟。在x86上，栈帧间通过esp指针和ebp指针建立了关系，使新的栈帧在结束之
[frameobject.h]
PyFrameobject;
第8章Python虚拟机框架
Python源码中的PyFrameObject
所以在Python真正执行的时候，它的虚拟机实际上面对的并不是一个PyCodeobject
从E_back我们可以看出一点，在Python实际的执行中，会产生很多PyFrameObject
当然，对于Python而言，PyFrameobject对象不仅仅是一个我们在x86机器上看到
当Python在执行环境A中执行调用函数主的字节码指令时，会在当前的执行环境A
在f_code中存放的是一个待执行的PyCodeobject对象，而接下来的E_builtins
PyObJeCt_VAR_HEAD
Pyobject
//动态内存，维护（局部变量+cel1对象集合fre对象集合运行时栈）所需要的空间
int
pyobject
Pyoblect
Pyobject
Pyobject
Byobiect
ByCodeObject
struct
lineno
lasti;
struct
深度探索动态语言核心技术
我们暂且按下不表。
frame *f_back；
**f_stacktop;
fbuiltins;
*_loealsplus[l];
**f_valuestack;
*fcode;
trame
1/当前字节码对应的源代码行
//上一条字节码指令在E_code中的偏移位置
//local名字空间
//global名字空间
/builen名字空间
//Pycodeobject对象
//执行环境链上的前一个rame
//运行时栈的找顶位置
//运行时栈的找底位置
---
## Page 167
个时刻的完整运行时环境。
内存空间。
x86平台上的“运行时栈”区分开来。我们这里所谓的“运行时栈”单指运算时所需要的
在今后的描述中，我们将其称为运行时栈。注意，一定要将这里的“运行时栈”的概念和
所以作为对x86栈帧的模拟，在PyFrameObject中，也提供了对这些内存空间的模拟。
只需要CPU中的寄存器即可，这里仅仅展示了在计算的过程中是需要消耗一定的内存的。
放在内存中，这些内存就是执行计算所必需的内存。当然，在x86上，完成一条加法操作
例子：在计算c=a+b时，我们需要将a和b的值分别读入内存，然后计算的结果也需要存
Block在执行时所需的栈空间的大小是不同的，所以决定了PyFrameobject的开头一定有
栈空间的大小存储在_stacksize中，而栈本身正是那段变动的内存。因为不同的Code
（注意，这个栈空间才是和x86机器上那个用于函数执行的栈空间相对应的概念）。这个
在编译一段CodeBlock时，会计算出这段CodeBlock执行过程中所需要的栈空间的大小
应的，更准确地说，是和我们在研究ryCodeobject时提到的那个CodeBlock对应的。而
object对象。这表明每一个PyFrameObject对象和Python源代码中的一段Code都是对
的内存是用来做什么的呢？实际上，每一个pyFrameObject对象都维护了一个PyCode
后，将其对应的值取出，并打印出来。
在执行printi时，首先会到f_ocals中去寻找pyStringobject对象，找到了之
细解析，因为它对于理解Python虚拟机的行为相当关键。想想前面的那段environment.py，
个栈帧中，包含了执行计算所必需的内存空间，为什么执行计算还需要内存空间呢？举个
以及1ocal的name与对应值之间的映射关系。在下一节，我们将给出关于名字空间的详
对象，所以，在这3个PyDictObject中，分别维护了bui1tin的namegloba1的name，
个PyObject_VAR_HEAD
个变长的对象，即每次创建的PyFrameobject对象的大小可能是不一样的。这些变动
与图8-1所示的x86平台上的运行时栈对应，图8-2展示了Pyhon虚拟机在运行时某
前面我们说PyFrameObject对象是对x86机器上单个栈帧的模拟。既然在x86的单
local
yFrameObject其他球
PyFrameObject
运行时栈
global
buitin
图8-2
f_back
Python执行的某个时刻的运行时环境
local
yFrameObject其他域
运行时栈
global
Python源码剖析
8.1
[buitin]
Python虚拟机中的执行环境
f_back
一深度探索动态语言核心技术
Idcal
yFrameObject其他域
运行时栈
giobal
buitin]
137
---
## Page 168
8.1.2
138
Python源码剖析
护了一段变动长度的内存，但是这段内存不只是给栈使用的，还有别的对象也会使用：
和图8-2，我们仍然能够看出它们之间的相似之处。
PyErameObject对象中动态内存部分的关系。
图8-3是一个刚被创建的PyFrameObject对象的示意图。从中可以清晰地看到运行时栈和