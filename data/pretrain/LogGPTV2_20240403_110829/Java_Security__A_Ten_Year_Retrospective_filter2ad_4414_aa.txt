title:Java Security: A Ten Year Retrospective
author:Li Gong
2009 Annual Computer Security Applications Conference
Java Security: A Ten Year Retrospective 
Li Gong 
Mozilla Online Ltd 
Beijing, China 
PI:EMAIL 
Abstract— The first edition of Java (both the language and the 
platform)  was  released  in  1995,  which  contained  the  all-or-
nothing  security  access  model.  A  mid-1997  paper  I  published 
in IEEE Micro laid out a vision for the future of Java security, 
which notably included a model for fine-grained access control, 
a  crypto  architecture,  and  a  number  of  other  security 
mechanisms.  The  first  implementation  of  these  features  was 
officially released in late 1998 as part of the JDK 1.2 platform. 
Ten  years  on,  the  original  vision  of  Java  security was  largely 
realized and the overall architecture had in fact been  carried 
over  to  both  the  enterprise  Java  and  mobile  Java  platforms. 
This  paper  reflects  on  lessons  --  technical  and  otherwise  -- 
learned in the process of designing and implementing the Java 
security architecture and in the aftermath of its release into the 
real world 
Keywords-Java; security; least privilege; access control; safe 
programming; mobile code. 
I. 
 AN UNEXPECTED JOURNEY 
In May of 1995, Sun Microsystems officially introduced 
Java, a language and a software platform that was to change 
the  programming  world  completely.  Initially  designed  for 
set-top boxes, it debuted in the form of the HotJava browser 
running  on  PCs  and  was  soon  integrated  into  the  Netscape 
browser, making it accessible to millions of web creators and 
users.  Java  was  described  as  objected-oriented,  cross-
platform,  and  secure.  In  fact  it  had  so  many  marketing 
attributes  attached  that  it  was  dubbed  the  most  buzzword-
complete technology.  
However, labeling any system secure is at best imprecise 
and often plainly wrong, and is an unfailing public invitation 
for computer security researchers to attack it. Sure enough, 
security bugs and loopholes started flowing in, discovered by 
a  wide  range  of  people  from  individual  “hackers”  to 
specialized security research institutions, but most visibly a 
group  of  researchers  at  Princeton  University  led  by  Ed 
Felten.  Given  that  Netscape  was  garnering  such  public 
attention  and  that  the  browser  was  the  common  conduit  in 
which  Java  was  deployed  and  utilized,  stories  of  security 
breach in Netscape or Java (where sometimes it was not easy 
to  differentiate  between  the  two  even  to  the  experts)  were 
headline news in the New York Times and the Wall Street 
Journal.  
Later, when Microsoft licensed Java and incorporated it 
into the Internet Explorer browser, competition to deliver the 
most  secure  browser  (factual  or  perceived)  became  an 
important  battleground  in  the  now  well-documented  David 
vs.  Goliath  browser  war,  with  (seemingly  weekly)  security 
hole  discoveries,  mad  scrambles  to  patch  the  problems, 
inevitable leaks to the press, and behind the scenes efforts to 
keep things quiet while solutions were being rolled out. Sun 
Microsystems  was  an  eager  participant  in  this  fight,  and  I 
found myself at numerous industry conferences sitting on the 
same  panel  with  Jim  Roskind  from  Netscape  and  Barbara 
Fox  from  Microsoft, 
lobbing  verbal  missiles  at  and 
deflecting  unflattering  comments  from  the  floor  to  each 
other.  I quietly chuckled much later when I quoted George 
Bernard Shaw in my Java security book, who famously said 
“Security  is  the  chief  pretence  of  civilization.”  But  I  am 
getting ahead of myself here. 
Soon after Java’s first release, a more scholarly debate on 
runtime security (a term that was mostly focused on Java but 
also  generalized  to  include  any  mobile  code)  raged  on  the 
ACM  Risks  Forum  [1],  the  most  popular  discussion  forum 
on such topics that was founded and moderated by Peter G. 
Neumann,  who  was  an  esteemed  colleague  of  mine  at  the 
Computer Science Laboratory at SRI international. Sitting a 
few offices apart, one day we decided that it should be useful 
if  we  got  all  the  major  players  into  the  same  room  to  talk 
things out, and SRI was an ideal neutral ground. Invitations 
were sent out, and a one-day runtime security meeting  was 
duly held at SRI on May 3, 1996.  
The only surviving notes I am aware of (kept by Peter) 
listed  participants  including  a  Sun  team  led  by  James 
Gosling,  a  Netscape  team  headed  by  Taher  ElGamal  (then 
Chief Scientist for Security at Netscape), the Princeton gang 
(Felten, Drew Dean, and Dan Wallach), and highly-respected 
researchers  Mike  Schroeder  (DEC  SRC),  Butler  Lampson 
(Microsoft),  and  David  Presotto  (Bell  Labs).  Actual 
discussions are a hazy memory now, but I clearly remember 
Schroeder concluding at the end that if we  were to put our 
heads together, we should be able to solve this problem.  
After the meeting, Gosling and I talked a bit more, and 
on August 12 that year, I joined the JavaSoft division of Sun 
as its Java security architect with the mission to build out the 
security team there and to figure out what Java security was 
(and should be) all about. This was a rare chance to put one’s 
research  learning  into  practice,  and  Java  seemed  a  pretty 
good  place  to  jump  in  given  it  was  the  first  commercial 
system in years that at least publicly and positively claimed 
security  as  a  design  goal.  I  took  the  plunge  head  first, 
although Java’s future was anything but assured at the time. 
II.  EVOLUTION OF JAVA SECURITY 
Java was released through the Java Development Kit (or 
JDK for short). JDK contains the Java Runtime Environment 
(JRE) that includes the Java Virtual Machine (JVM), as well 
as all the Java APIs and libraries. The initial release was JDK 
1063-9527/09 $26.00 © 2009 IEEE
DOI 10.1109/ACSAC.2009.44
395
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 13:13:50 UTC from IEEE Xplore.  Restrictions apply. 
1.0.  Each  subsequent  major  release,  such  as  JDK  1.1  and 
JDK 1.2, included major new features, while minor releases 
such  as  JDK  1.1.2  and  JDK  1.2.3  would  include  only  bug 
fixes and minor upgrades.  
As  for  security,  JDK  1.0  has  a  clear-cut,  binary  model. 
Applications, defined as anything loaded from the local disk 
(or its equivalent), run as trusted code and can do anything 
the JVM can, which is everything. Applets, defined as code 
loaded over the network, run as untrusted and can do little. 
Applets were described as being contained in a safe sandbox, 
and  thus  the  binary  security  model  was  often  called  the 
sandbox model. 
JDK 1.1’s main improvement over JDK 1.0 in terms of 
security  support  was  the  addition  of  a  feature  called  code 
signing.  An  applet’s  code  can  be  digitally  signed.  Upon 
loading, if the JRE recognizes the signatory and the signature 
checks out against the applet code, then the applet is treated 
as a trusted application and is given full access to the entire 
system. When I arrived on the scene in mid August of 1996, 
I was told that JDK 1.1 was going to be released at the end of 
that  month  and  my  immediate  concern  was  to  have 
everything  related  to  JDK  1.1  wrapped  up  as  quickly  as 
possible.  In  reality,  JDK  1.1  was  not  shipped  until  quite  a 
few months later.  
Design  work  for  JDK  1.2  started  in  late  1996  and 
intensified  once JDK 1.1 left the door.  It  was  planned as  a 
one-year project, more or less, but in practice it took a little 
more than two years of very hard work, finally shipping in 
December of 1998. At the engineering post mortem meeting 
on  JDK  1.2,  it  was  agreed  that  we  made  all  those  same 
mistakes  we  vowed  to  avoid  at  the  JDK  1.1  post  mortem 
meeting. JDK 1.2, which was renamed Java 2, saw the most 
significant changes to the Java platform in a single release, 
not  just  for  security.  JDK  1.2  introduced  the  fine-grained 
access control model, which continued essentially unchanged 
till  this  day.  In  order  to  implement  the  new  security 
architecture,  we  needed 
tweak  almost 
everything,  because  security  is  closely  intertwined  with  the 
JVM and impacts every part of the JRE/JDK. 
touch  and 
providing 
The  new  architecture  designed  for  JDK  1.2  also 
introduced  a  full  specification  for  cryptographic  services, 
called the Java Cryptography Architecture (JCA). This set of 
services  enables  a  crypto  service  provider  --  anyone 
interested 
cryptographic 
implementations  for  use  by  others  –  to  plug  in  its  custom 
implementations to a standard set of provider APIs. On the 
other  hand,  applications  can  call  a  standard  set  of  crypto 
APIs for crypto services, and choose a specific provider if so 
desired. JCA was released as an optional component for JDK 
1.2, called Java  Cryptographic  Extension (JCE),  due  to  US 
export  control  restrictions  at  the  time.  Eventually  JCA 
became part of the standard JDK release. 
Separately,  JSSE  (Java  Secure  Socket  Extension)  was 
implemented  to  support  SSL/TLS  on  the  Java  platform. 
Underlying all these was a full package for handling digital 
certificates. During that same period, a Java Authentication 
and Authorization Services (JAAS) framework was outlined. 
As  its  name  suggests,  JAAS  introduces  authentication  and 
authorization – fundamental concepts for system security -- 
own 
its 
to 
in 
and  enables  a  more  sophisticated  style  of  security  policy 
management. 
implementation  of 
The  first  public  musing  about  the  directions  of  Java 
security was a talk I gave at IEEE COMPCON in San Jose in 
February of 1997 [2], and the content was expanded and later 
published  in  IEEE  Micro  in  mid  1997  [3].  This  is  the 
designated  “classic  paper”  for  this  conference.    The  first 
published  paper  on 
the  JDK  1.2 
architecture  was  presented  at  a  USENIX  symposium  in 
Monterey at the end of that year [4]. The first edition of my 
book,  “Inside Java 2 Platform  Security” [5],  which  I  wrote 
almost  as  a 
to  remind  myself  of 
what/how/why  we  did  things  in  ways  that  often  appeared 
peculiar  to  outside  observers,  was  completed  in  time  for 
release at JavaOne in June of 1999. Gary Ellison and Mary 
Dageforde  later  added  new  chapters  and  generally  brought 
things up to date to produce the second edition in 2003 [6]. 
technical  record 
I left the JDK engineering group soon after the release of 
JDK 1.2, not unlike a good number of others after the super 
stressful  two  plus  years  on  the  project.  I  left  Sun  in  2005, 
right on the tenth anniversary of Java. 
III.  CRITERIA FOR A GOOD FOUNDATION 
One fundamental question facing us during JDK 1.2 was 
what sorts of security support are appropriate to build into a 
development  platform.  What  are  the  critical  rules  that  the 
system should require all programmers to abide by?  Which 
set of features are often used such that they should be made 
available,  even  though  their  utilization  is  strictly  optional? 
Which  decisions  should  the  system  make,  and  which  are 
best left to application developers? 
In the  “classic paper”, four considerations are raised to 
determine the right platform security. I quote verbatim here: 
Usability  –  To  be  ubiquitous  and  accepted  in  the 
marketplace,  the  platform  must  be  easy  to  use  for 
building small- and large-scale systems and applications. 
Simplicity – To inspire confidence in its correctness, the 
platform  cannot  be  too  complex  to  analyze  (by  code 
inspection or testing, for example) for critical properties. 
Adequacy  –  The  platform  must  contain  all  essential 
features and building blocks for supporting higher-level 
trustworthiness (security) requirements. 
Adaptability  –  The  platform  must  evolve  with  ease, 
following demand and market reality. 
These  four  attributes  highlight  what  were  my  primary 
concerns back then. On the one hand, fresh from academia, I 
was very much aware that many outstanding research results 
never see their light of day in practice because the work is 
too difficult to use or too hard to understand. On the other 
hand, given the visibility of Java and its security work, and 
knowing  that  it  would  take  at  least  a  year  or  more  to  add 
something  in  a  later  edition  of  the  Java  platform,  I  was 
constantly worried that we would miss a key ingredient that 
would  make 
(in 
applications) very difficult or impossible.  
implementing  a 
For example, I included SignedObject and SealedObject 
classes, to mimic authenticated and encrypted data packets, 
because 
in 
distributed  computing  systems.  The  GuardedObject  class 
these  constructs  are  useful  for  security 
security 
feature 
396
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 13:13:50 UTC from IEEE Xplore.  Restrictions apply. 
allows a programmer to encapsulate access conditions in a 
Guard  object,  and  this  is  a  more  elegant  way  to  express 
access  control  than  directly  calling  the  SecurityManager, 
which was/is the standard coding style inherited from JDK 
1.0. The GuardedObject construct has a lot of potential but 
is perhaps one of the most neglected features introduced in 
JDK 1.2. 
At  the  same  time,  I  equally  feared  over-prescription. 
Once the JDK includes an API, it would be hard to remove, 
due to backward compatibility requirements. So I often told 
my  team  to  think  about  forward  compatibility  and  only 
design things that we were sure that we absolutely needed. 
In  the  same  vein,  I  tried  to  leave  everything  as  extensible 
and adaptable, to the maximum extent possible. 
IT’S NOT ALL TECHNICAL 
IV. 
The most fundamental question during the design phase 
of  the  JDK  1.2  security  architecture  was  where  Java  was 
headed. Although Java had all the ingredients as a general 
programming  platform,  Java’s  early  success  was  most 
visible  through  the  integration  into  the  Netscape  browser. 
Should  we  design  Java  security  so  that  it  supports  general 
applications?  Or  should  we  view  Java  as  primarily  a 
component of the browser? 
It was not surprising that the Netscape team was pushing 
us  towards  features  that  they  felt  were  important  to  a 
browser. In fact, the Netscape team already modified JRE’s 
security  implementation  and  designed  their  own  security 
features  (as  Java  extensions),  blaming  JavaSoft  for  not 
moving  fast  enough.  This  was  partially  justified,  since  the 
browser was being updated much more frequently than Java 
was.  
Moreover,  the  Netscape  team  wanted  us  to  adopt  their 
extensions  wholesale  and  make  their  security  model  the 
default  for  everyone.    This  request  was  met  with  strong 
resistance,  since  the  browser  specific  features  as  proposed 
would  not  work  if  Java  was  going  to  be  a  general 
programming  platform  that  might  support  applications  for 
servers. For example, central to the Netscape model  was  a 
call-back  feature  where,  when  uncertainty  arises,  the  user 
(who is presumably looking at the browser window on the 
PC screen) would be prompted to click a button to allow or 
disallow an action. This design is similar to what Windows 
Vista  has  recently  implemented  to  alert  users  for  critical 
actions, but it clearly would not work in an unmanned server 