一以名字冒号开始的符号。
当读取器保留这样一个名字
---
## Page 56
某个值的变量来求值，然后（formatt"yes")将被当成一个函数调用来求值，在向标准输出打
求值，因此无法写出一个类似第3章里用到的IF操作符那样的函数。为了说明这点，可以假设有
4.6特殊操作符
函数来处理。Lisp的这种设计对于保持其语法正则化很有帮助。
最后，值3和-1被传递到*函数里，从而得到-3。
时需要先对它们的参数求值，然后再对它们应用相应的函数：
如下所示，其中每个参数本身也是一个Lisp形式：
有的列表元素它们自身必须是一个形态良好的Lisp形式。换句话说，函数调用形式的基本语法应
下面这种形式：
4.5
宏形式（macro form）和特殊形式（special form)。
名字。如果该符号尚未定义，比如说当你正在编译一段含有对尚未定义函数的引用的代码时，它
定的列表是哪种形式，求值器必须检测列表开始处的那个符号是一个函数、宏还是特殊操作符的
号开始，但是有三种类型的列表形式，它们会以三种相当不同的方式进行求值。为了确定一个给
①在Common Lisp中一个符号可以同时为操作符（函数、宏或特殊操作符）和变量命名。这是Common Lisp和Scheme
如果IF是一个函数，那么求值器将从左到右依次对其参数表达式求值。符号x将被作为产生
然而，并非所有的操作都可定义成函数。由于一个函数的所有参数在函数被调用之前都将被
正如这些例子所显示的这样，许多在其他语言中需用特殊语法来处理的事务在Lisp中都可用
(*（+12）（-34)）
（（uouo）(μS euIo） x )
像下面这样更复杂的表达式也采用相似的求值方法，不过在求值参数(+12)和(－34)
函数调用形式的求值规则很简单，对以Lisp形式存在的列表其余元素进行求值并将结果传递
这样下面这个表达式在求值时将首先求值1，再求值2，然后将得到的值传给+函数，再返回3:
(function-hame argument*)
当我们开始考虑列表的求值方式时，事情变得更加有趣了。所有合法的列表形式均以一个符
(+12）
而拥护者们总是在无休止地争论哪种更好。
名空间，一个用于操作符而另一个用于变量，但一个Lisp-1仅使用单一的命名空间。两种选择都有其各自的优点，
的主要区别之一。这一区别有时被描述成Common Lisp是一种Lisp-2而Scheme则是Lisp-1一
函数调用
www.TopSage.com
4.6特殊操作符
一个Lisp-2有两个命
39
---
## Page 57
值为10的变量名：
用来创建新的变量绑定。
符修改了其他形式的求值环境。其中之一是LET，也是我将在第6章详细讨论的特殊操作符，它
来是一样的：一个首元素为符号QUOTE并且次元素是列表(+12)的列表。
也可以这样写：
写之外：
不经求值。例如，下面的表达式求值得到列表(+1 2)，而不是值3：
其中test-form将总是被求值，然后要么是then-form要么是else-form。
说
的值。否则，返回第三个表达式的求值，或者如果第三个表达式被省略的话，返回NIL。换句话
符的规则进行求值。
函数无法做到的事情。它们总共有25个，但只有很少一部分直接用于日常编程。
FORMAT表达式中的哪一个会被求值了。
只有当所有三个表达式都被求值以后，它们的结果值才被传递给IF，而这时已经无法控制两个
印“yes”以后得到NIL。接下来（format七“no")将被求值，打印出“no”同时也得到NIL。
为了解决这个问题，Common Lisp定义了一些特殊操作符，IF就是其中之一，它们可以做到
40
① 其他操作符提供了有用但有时嗨涩难懂的特性。我将在它们所支持的特性里讨论它们。
一般来说，特殊操作符所实现的语言特性需要求值器作出某些特殊处理。例如，有些的操作
一个更简单的特殊操作符是QUOTE，它接受一个单一表达式作为其“参数”并简单地返回它，
IF的规则相当简单：求值第一个表达式。如果得到非NIL，那么求值下一个表达式并返回它
当列表的第一个元素是一个由特殊操作符所命名的符号时，表达式的其余部分将按照该操作
②确实有一点区别——像引用列表这样的字面对象，也包括双引号里的字符串、字面数组和向量（以后你将看到它
该语法是读取器所理解的S-表达式语法的小扩展。从求值器的观点来看，这两个表达式看起
(quote (+ 1 2))
QUOTE被用得相当普遍，以至于读取器中内置了一个它的特别语法形式。除了能像下面这样
(if test-form then-form [ else-form ])
一个IF表达式的基本形式是像下面这样：
(let ((x 10))x)
'(+1 2)
这个列表没有什么特别的，你可以像用LIST函数所创建的任何列表那样处理它。
(quote（+ 1 2)）
扩展时，他们指的是正规的宏，我将在稍后讨论它们。
定义你自己的读取宏也是有可能的，但这是该语言的一种很少被用到的机制。多数Lisp程序员提到该语言的语法
第 4章 
语法和语义
下面的形式求值得到10，因为在第二个x的求值环境中，它是由LET赋
www.TopSage.com
?
---
## Page 58
但却有着相当不同的用途，并提供了一种嵌入编译器的钩子。
义了一种语法，合法的backwards形式列表必须与合法的Lisp形式列表反序。
成展开式。换句话说，每个宏都定义了它们自己的局部语法。例如，第3章的backwards宏就定
Lisp形式。每个宏都为其宏形式中的符号表达式指定了一种含义，用以指明宏将如何使用它们生
函数被调用时再付出额外的代价。
开式，它们可以用相对大量的工作来生成其展开式，而无需在文件被加载时或是当文件中定义的
知道如何去加载它。但编译后的代码直到文件被加载时才会被执行。因为宏在编译期会生成其展
中只含有函数调用形式和特殊形式。这些无宏的代码随后被编译成一个FASL文件——LOAD函数
使用函数COMPILE-FILE来编译整个源代码文件时，文件中所有宏形式将被递归展开，直到代码
这两个阶段所发生时间却是完全不同的，因此关键在于对于何时发生什么要保持清醒。例如，当
忘记这一点，因为两个阶段相继发生并且后一阶段的值被立即返回了。但是当Lisp代码被编译时，
求值。
函数里；其次，由宏函数所返回的形式（称其为展开式（expansion））按照正常的求值规则进行
该值取代宏形式。宏形式的求值过程包括两个阶段：首先，宏形式的元素不经求值即被传递到宏
里看到的那样，宏是一个以S-表达式为其参数的函数，并返回一个Lisp形式，然后对其求值并用
符的数量在语言标准中是固定的。然而宏却能提供给语言用户一种语法扩展方式。如同在第3章
我会在本书中经常地提到宏。眼下最为重要的是认识到宏，虽然跟函数调用在句法上相似，
重点在于要清醒地认识到一个宏形式求值的两个阶段。当你在REPL中输入表达式时很容易
虽然特殊操作符以超越了函数调用所能表达的方式扩展了CommonLisp语法，但特殊操作
名字。
一个函数或宏的名字时本身才有意义。将这一现象和随后作为变量出现的x联系起来，就会很容易发现poLIST
就算一个DoLIST形式被写在了单行里，也有几条线索可以说明它是一个宏。其一，表达式（xfoo）只有在x是
义的宏也是如此。
后面两种形式使DOLIST显得像是一个函数。一个好的Lisp开发环境会自动正确地格式化宏调用，甚至对于用户定
(dolist (x foo)
也不会是这样：
(dolistt
而不是这样：
(dolist (x foo)
格式上与函数调用不同。例如，你会写成这样：
用跟正常函数调用一样时可能会紧张。但这在实践中却并不是一个问题，原因如下。一方面是因为宏形式通常在
(print x))
宏
(x foo) (print x))
www.TopSage.com
一通常作为宏的循环结构都带有一个以do开始的
4.7
宏
---
## Page 59
代码时，看到了一个EQ，就得停下来检查它是否被正确使用了（换句话说，它永远不该被用来比
方式，以及(b)因为EQ不需要检查它的参数是否为数字或字符，所以它将会稍微更有效率。
道不存在比较数字或字符时就应该使用EQ，他们认为(a)这是一种说明你不在比较数字或字符的
(eql11.0）则被确保是假，因为整数值1和浮点数1.0是不同类型的对象。
型的两个对象表示相同的数字或字符值时，它们是等价的。因此，（eql1 1)能被确保是真。而
那么EQ的行为也将很有可能发生改变。
味着只是简单地把实现升级到一个新版本一
可预测的方式工作，但如果切换了语言实现，则它将不保证以相同的方式工作。切换实现可能意
求值为真或假，这种情况更多会发生在x恰好为数字或字符时。
会被EQ认为是等价的也可能会是不等价的。语言实现者有足够的空间将表达式（eq×x)合法地
对象标识取决于这些数据类型在特定Lisp平台上实现的方式。带有相同值的两个数字或字符可能
和EQUALP。
Lisp对象，然后当它们等价时返回真，否则返回假。按照介绍的顺序，它们是EQ、EQL、EQUAI
的章节里将会看到，CommonLisp提供了许多特定于类型的等价谓词：=用来比较数字，CHAR:
直接求解出符号NIL。基于同样的理由，t和't的求值结果也完全相同：符号T。
看成是对值为符号NIL的常值变量的引用来进行求值，而在引用形式中，QUOTE特殊操作符将会
其值的常值变量名，所以表达式nil、（）、‘nil以及；()求值结果是相同的——未引用形式将被
读取它。它们是完全可以互换的。并且如同我前面提到的那样，因为NIL是一个以符号NIL作为
表。°这种NIL和空列表的等价性被内置在读取器之中：如果读取器看到了（），它将作为符号NIL
烦的一点是，它是唯一一个既是原子又是列表的对象：除了用来表示假以外，它还用来表示空列
号T是标准的真值，可用于需要返回一个非NIL值却又没有其他值可用的情况。关于NIL，唯一麻
的含义。真和假的含义在这里是直截了当的：符号NIL是唯一的假值，其他所有的都是真值。符
4.8
使用诸如“完全相同”这样的术语理所当然会引申出两个值“等价”的这个问题上。在后面
EQ用来测试“对象标识”，只有当两个对象相同时才是EQ等价的。不幸的是，数字和字符的
42
① 使用空列表作为假是Lisp作为列表处理语言所留下的遗产，就好比是C语言使用整数0作为假是其作为字节处理语
关于何时使用EQ以及何时使用EQL，这里有两种观点：“凡有可能就用EQ”阵营认为，当知
因此，Common Lisp定义了EQL来获得与EQ相似的行为，除此之外，它也可以保证当相同类
因此不该将EQ用于比较可能是数字或字符的值上。在个别实现的特定值上，它可能会以一种
最后两个需要了解的基本知识是Common Lisp对于真和假的表示法以及两个Lisp对象“等价"
两者也是不同的。
言所留下的遗产。但并非所有的Lisp都以相同的方式处理布尔值。Common Lisp和Scheme的许多细微差异中的另
真、假和等价
一个就是Scheme使用一个单独的假值#f，#f无论跟符号nil还是空列表都是不同的值，并且即便是nil和空列表
第 4章 
语法和语义
www.TopSage.com
一而如果Lisp实现者改变了表示数字或字符的方式，
---
## Page 60
号缩进两个空格。就像这样：
这样，一个需要跨越多行的函数调用可能会被写成这样：
嵌套层次都需要多缩进一点儿，并且如果折行是必需的，位于同一个嵌套层次的项应当按行对齐。
反映出代码结构，这样就不需要通过数括号来查看代码究竟写到哪儿了。一般而言，每一个新的
编写流利而又地道的代码而言非常重要。格式化Lisp代码的关键在于正确缩进它。这一缩进应当
4.9
对象是等价的，但EQL或EQUAL则不会。对于所有的其他数据类型，EQUALP回退到EQL的水平上。
也是BQUALP等价的。和EQUAL一样，还有一些我尚未涉及的其他数据类型，EQUALP可认为两个
真的。由EQUALP等价的元素所组成的列表也是EQUALP等价的。同样地，带有EQUALP元素的数组
只要数字表示相同数学意义上的值，它们在EQuALP下面就是等价的。因此，（equalp11.o）是
价性时忽略了大小写的区别。它还认为如果两个字符只在大小写上有区别，那么它们就是等价的。
性，我将在未来的章节里讨论这两个数据类型。对于所有其他类型，它回退到EQL的水平上。
也认为含有相同字符的字符串是等价的，它对于位向量和路径名也定义了比EQL更加宽松的等价
所需方式来比较不同类型对象。
含义的等价性没有什么特别的。如果这些谓词不能满足需要，也可以自己定义谓词函数，以自己
对象是等价的。除了它们曾经被过去的Lisp程序员认为是有用的之外，由这些函数所实现的特殊
又不像BQ或EQL那样基础。它们每个都定义了相比EQL稍微宽松一些的等价性，允许认为不同的
实际的性能瓶颈来说微不足道。
较数字或字符），这样就会丢失潜在获得的代码清晰性，以及(b)EQ和EQL之间的效率差异相比于
EQUALP甚至更加宽松之外，它和EQUAL是相似的。它在考察两个含有相同字符的字符串的等
EQUAL相比EQL的宽松之处在于，它将在递归上具有相同结构和内容的列表视为等价。BQUAL
①甚至是语言标准，在关于EQ或EQL哪一个应当被使用方面也有一点歧义，对象标识（objectidentity）是由EQ定义
严格说起来，代码格式化既不是句法层面也不是语法层面上的事情，好的格式化对于阅读和
本书中的代码是以“总是使用EQL”风格写成的。
尽管如此，但也不需要太担心这些规则，因为一个像SLIME这样的优秀Lisp环境将会帮你做
(defun print-list (list)
另外两个等价谓词BQUAL和EQUALP更为通用，因为它们可以操作在所有类型的对象上，但
的对象。不得不承认，这个问题有些无聊。
技术上100%正确的话，你可以说（-32）和（-43）求值到“相同”（same）的对象而不是“同样”（identical）
的，但是标准在谈论对象时定义了术语“相同”来表达EQL，除非明确提到了另外的谓词。因此，如果你想要在
格式化Lisp代码
(dolist （ilist)
（formatt"item:~a~%"i）))
another-arg-with-an-even-longer-name)
www.TopSage.com
4.9格式化Lisp代码
m
---
## Page 61
结尾处的）））可能看起来令人生畏，但是一旦代码缩进正确，那么括号的意义就不存在了，没有
而一定要写成这样：
也就是说，不要写成这样：
你立即就能看出有错误发生。
将得到如下的代码：
加一个额外的括号，从而得到下面的代码：
而你不小心忘记了test后面的闭括号。如果不数括号，那么很可能就会在DEFUN形式的结尾处添
器所给出的奇怪缩进而被发现。例如，假设要编写一个如下所示的函数：
观，还可以检测笔误：一旦熟悉了代码该如何缩进，那么一个错误放置的括号就将立即由于编辑
键入C-c M-q来重新缩进整个函数体。