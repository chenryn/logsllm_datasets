title:Oracle Simulation: A Technique for Protocol Composition with Long
Term Shared Secrets
author:Hubert Comon and
Charlie Jacomme and
Guillaume Scerri
Oracle simulation: a technique for protocol composition with
long term shared secrets
Hubert Comon1, Charlie Jacomme2, and Guillaume Scerri3
1,2LSV, CNRS & ENS Paris-Saclay & Inria & Université Paris-Saclay
3Université Versailles Saint-Quentin & Inria
August 10, 2020
Abstract
We provide a composition framework together with a variety of composition theorems
allowing to split the security proof of an unbounded number of sessions of a compound
protocol into simpler goals. While many proof techniques could be used to prove the
subgoals, our model is particularly well suited to the Computationally Complete Symbolic
Attacker (CCSA) model.
We address both sequential and parallel composition, with state passing and long term
shared secrets between the protocols. We also provide with tools to reduce multi-session
security to single session security, with respect to a stronger attacker. As a consequence,
our framework allows, for the ﬁrst time, to perform proofs in the CCSA model for an
unbounded number of sessions.
To this end, we introduce the notion of O-simulation: a simulation by a machine
that has access to an oracle O. Carefully managing the access to long term secrets, we
can reduce the security of a composed protocol, for instance P(cid:107)Q, to the security of P
(resp. Q), with respect to an attacker simulating Q (resp. P ) using an oracle O. As
demonstrated by our case studies the oracle is most of the time quite generic and simple.
These results yield simple formal proofs of composed protocols, such as multiple ses-
sions of key exchanges, together with multiple sessions of protocols using the exchanged
keys, even when all the parts share long terms secrets (e.g. signing keys). We also provide
with a concrete application to the SSH protocol with (a modiﬁed) forwarding agent, a
complex case of long term shared secrets, which we formally prove secure.
Contents
I The Framework
1 Introduction
1.1 Our contributions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
1.2 Related Works
3
3
4
5
1
2 Protocols and Indistinguishability
7
7
. . . . . . . . . . . . . . . . . . . . . . . . . . .
2.1 Syntax and semantics of terms
8
2.2 Syntax of the protocols . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.3 Semantics of the protocols . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
9
2.4 Stateless Oracle Machines . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10
2.5 Computational indistinguishability . . . . . . . . . . . . . . . . . . . . . . . . . 12
3 Simulatability
13
3.1 Protocol Simulation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14
3.2 Generic Oracles for Tagged Protocols . . . . . . . . . . . . . . . . . . . . . . . . 23
4 Main Composition Theorems
25
4.1 Composition without State Passing . . . . . . . . . . . . . . . . . . . . . . . . . 25
4.2 Composition with State Passing . . . . . . . . . . . . . . . . . . . . . . . . . . . 29
4.3 Unbounded Replication . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32
5 Unbounded Sequential Replication
II Applications to Key Exchange
33
34
6 Application to Key Exchanges
34
6.1 Our Model of Key Exchange . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 34
6.2 Proofs of Composed Key Exchange Security . . . . . . . . . . . . . . . . . . . . 35
7 Basic Diﬃe-Hellman Key Exchange
38
8 Extension to Key Conﬁrmations
40
8.1 Proofs with Key Conﬁrmations . . . . . . . . . . . . . . . . . . . . . . . . . . . 40
41
9 Application to SSH
9.1 The SSH Protocol
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 43
9.2 Security of SSH . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 44
9.3 SSH with Forwarding Agent . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 45
III Composition in the CCSA logic
10 Oracles in the CCSA Logic
48
10.1 Syntax and Semantics
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 48
10.2 Oracle Soundness . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 48
47
11 Computational Soundness of the logic
51
11.1 Protocols
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 51
11.2 Introduction of attacker’s functions . . . . . . . . . . . . . . . . . . . . . . . . . 52
12 Extension to the Model for Unbounded Replication
53
2
A Messages
59
A.1 Syntax of messages . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 59
A.2 Semantics of terms . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 59
B Protocols
60
B.1 Protocol Algebra . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 60
B.2 Formal deﬁnition of a protocol execution . . . . . . . . . . . . . . . . . . . . . . 60
B.3 Formal deﬁnition of protocol oracles
. . . . . . . . . . . . . . . . . . . . . . . . 61
C A case study : signed DDH
64
C.1 Key exchange security . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 65
C.2 Proof for φ3 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 67
C.2.1 Real or random of the key . . . . . . . . . . . . . . . . . . . . . . . . . . 67
C.2.2 Authentication . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 68
C.3 Conclusion for Signed DDH . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 69
D An application to SSH
69
D.1 Presentation of SSH . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 69
D.2 The security of the protocol without forwarding agent
. . . . . . . . . . . . . . 70
D.3 Proof of real of random . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 72
. . . . . . . . . . . . . . . . . . . . . . . . . . . 72
. . . . . . . . . . . . . . . . . . . . . . . . . . . . 73
D.4 Proof for the authentication . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 73
D.3.1 Proof of Ax |= φ2 ∼ ψ2
2 ∼ ψ1
D.3.2 Proof of Ax |= φ1
2
E SSH with forwarding agent
E.1 Scheme of the proof
74
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 74
E.1.1 First application of Corollary 3 . . . . . . . . . . . . . . . . . . . . . . . 75
E.1.2 Second application of Corollary 3 . . . . . . . . . . . . . . . . . . . . . . 76
F Proofs
77
F.1 Formal Corollary for Key Exchange . . . . . . . . . . . . . . . . . . . . . . . . . 77
F.2 Formal Corollary for Key Conﬁrmations . . . . . . . . . . . . . . . . . . . . . . 79
F.3 Oracle Simulation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 81
F.4 Autocomposition Results . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 84
F.5 Key Exchanges . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 88
F.6 Computational soundness
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 101
Part I
The Framework
Introduction
1
This paper is concerned with the security proofs of composed protocols. This topic has been
widely studied in the last two decades. For instance, Universal Composability (UC) and
simulation based reductions [1–6] and other game-based composition methods [7–10] address
this issue. While the former proceed in a more bottom-up manner (from secure components in
3
any environment, construct secure complex protocols), the latter proceed in a more top-down
way: from the desired security of a complex protocol, derive suﬃcient security properties of its
components. Such “top-down” proofs design allows more ﬂexibility: the security requirements
for a component can be weaker in a given environment than in an arbitrary environment.
The counterpart is the lack of “universality”: the security of a component is suitable for some
environments only.
We follow the “top-down” approach. While we aim at designing a general methodology,
our target is the management of formal security proofs in the Computationally Complete
Symbolic Attacker (CCSA) model [11]. As a side result of our work, we provide with a way
of proving the security of an arbitrary number of sessions (that may depend on the security
parameter) in the CCSA model.
When trying to (de-)compose security properties, the main diﬃculty comes from the fact
that diﬀerent protocols may share some secrets. This is typically the case for multiple sessions
of the same protocol, or for key exchange protocols, which result in establishing a shared
secret that will be later used in another protocol. Protocols may also share long term secrets,
for instance the same signing key may be used for various authentication purposes. Another
example is the SSH protocol with the agent forwarding feature [12], which we will consider
later. The forwarding feature allows to obtain, through previously established secure SSH
connections, signatures of fresh material required to establish new connections.
It raises a
diﬃculty, as signatures with a long term secret key are sent over a channel established using
the same long term secret key.
As far as we know, the existing composition results that follow the “top-down” approach
cannot be used in situations where there is both a “state passing”, as in key exchange protocols,
and shared long term secrets. For instance, in the nice framework of [10], the same public key
cannot be used by several protocols, a key point for reducing security of multiple sessions to
security of one session.
When decomposing the security of a composed protocol into the security of its components,
we would like to break a complex proof into simpler proofs, while staying in the same proof
framework. This is also a diﬃculty since the attacker on a protocol component might use the
other components: we need a proof with respect to a stronger attacker. In [10], such a strong
attacker can be simulated by a standard one, because there is no shared long term secret.
1.1 Our contributions
We provide with a composition framework that reduces the security of a compound protocols
to the security of its components. We allow both state passing and shared long term secrets.
We stay in the same proof framework of the CCSA model.
The starting idea is simple: if we wish to prove the security of a composed protocol P(cid:107)Q,
it is suﬃcient to prove the security of P against an attacker that may simulate Q, maybe
with the help of an oracle.
If n are the secrets shared by P and Q, this simulation has
to be independent of the distribution of n. This is actually an idea that is similar to the
key-independence of [8].
Therefore, we ﬁrst introduce the notion of O-simulation, in which an oracle O holds the
shared secrets: if Q is O-simulatable and P is secure against an attacker that has access to O,
then P(cid:107)Q is secure. Intuitively, O deﬁnes an interface through which the secrets can be used
(e.g. obtaining signatures of only well tagged messages). O simulatable protocols conform to
this interface.
4
We extend this basic block to arbitrary parallel and sequential compositions, as well as
replication of an unbounded number of copies of the same protocol. In the latter case, the
security of a single copy of P against an attacker that has access to an oracle allowing to
simulate the other copies, requires to distinguish the various copies of a same protocol. In the
universal composability framework, this kind of properties is ensured using explicit session
identiﬁers. We rather follow a line, similar to [13], in which the session identiﬁers are implicit.
Our main composition Theorems are generic: the classical game based setting can be used
to prove the subgoals. They are also specially well-suited for the CCSA model, which allows
to complete computational proofs of real life protocols [14–16], while only relying on ﬁrst order
logic and cryptographic axioms. Many such axioms can easily be generalized so as to be sound
with respect to an attacker that has access to oracles (we will see examples later).
A proof using such axioms is valid for an attacker who has access to an environment,
while abstracting all the details of the environment and its interactions with the attacker.
Moreover, as our reductions from one session to multiple sessions are uniform, we may now
complete proofs in the CCSA model for a number of session that is parameterized by the
security parameter. This was a limitation (and left as an open issue) in all previous CCSA
papers.
We illustrate our composition results showing how to split the security of any (multi-session
with shared long term secret) composed key exchange into smaller proofs. We then complete
the formal proof of security of a Diﬃe-Hellman key exchange (ISO 9798-3 [17]) for any number
of sessions in parallel.
We generalize the application to key exchanges performing key conﬁrmations, i.e. using
the derived key in the key exchange (as in TLS). The generalization is simple, which is a clue
of the usability of our framework.
To illustrate the usability of our framework, we use all our results to prove the security of
the SSH [12] protocol with a modiﬁed agent forwarding, a complex example of key exchange,
with both key conﬁrmation and long term shared secrets. The modiﬁcation, which consists in
the addition of a tag to specify if the signature was performed remotely, is necessary for the
protocol to satisfy some natural security properties related to the agent forwarding.
1.2 Related Works
We introduce the composition problem through a process algebra: protocols are either build-
ing blocks (deﬁned,e.g, with a transition system) or composed using parallel and sequential
composition, and replication. This prevents from committing to any particular programming
language, while keeping a clean operational semantics. This approach is also advocated in [10],
which follows a similar approach. Other works on composition (e.g., [5, 7]) rely on speciﬁc
execution models.
Our starting idea, to prove a component w.r.t. a stronger attacker that has access to the
context, is not new. This is the basis of many works, including [8–10,18]. The main diﬀerence,
that we wish to emphasize, is that these works do not support long term shared secrets, used
in diﬀerent components. Notably, the oracles of [10] are only used to decompose protocols
with state passing. Our notion of simulatability allows sharing long term secret by granting
the attacker access to oracles that depend on the secrets (for instance, signing oracles). It also
allows a symmetric treatment for proofs of a protocol and proofs of its context.
For several speciﬁc problems, typically key exchanges, there are composition results allow-
ing to prove independently the key exchange protocol and the protocol that uses the exchanged
5
key [8, 9, 13, 18, 19]. In such examples, the diﬃculty also comes from the shared secret, es-
pecially when there is a key conﬁrmation step. In that case, the derived key is used for an
integrity check, which is part of the key exchange. Then the property of the key exchange:
“the key is indistinguishable from a random” does not hold after the key conﬁrmation and
thus cannot be used in the security proof of the protocol that uses this exchanged key. In [8],
the authors deﬁne the notion of key independent reduction, where, if an attacker can break
a protocol for some key distribution, he can break the primitive for the same distribution of
the key. This is related to our notion of simulatability, as interactions with shared secrets
are captured by an oracle for ﬁxed values of the key, and thus attacks on the protocol for
a ﬁxed distribution are naturally translated into attacks against the primitive for the same
distribution. Key exchanges with key conﬁrmation are therefore a simple application of our
composition results. Along the same line, [19] extends [18] to multi staged key exchanges,
where multiple keys might be derived during the protocol. While we do not directly tackle
this in our paper, our framework could be used for this case.
The authors of [9] also provide results allowing for the study of key renewal protocols (which
we capture with the sequential replication Theorem), and has the advantage to be inside a
mechanized framework, while we only cast our results inside a mechanizable framework. It
does not however consider key conﬁrmations.
The UC framework initiated by [1] and continued in [3, 4, 6] is a popular way of tackling
composition. As explained above, this follows a “bottom-up” approach, in which protocols
must be secure in any context, which often yield very strong security properties, some of
which are not met in real life protocols. Moreover, to handle multiple sessions of a protocol
using a shared secret, joint-state theorems are required. This requires a tagging mechanism
with a distinct session identiﬁer (sid) for each session. Relaxing this condition, the use of
implicit session identiﬁers was established in [20] for the UC framework, ideas continued in [13]
for Diﬃe-Hellman key exchanges, where they notably provide a proof of the ISO 9798-3 [17]
protocol.
We do not consider a composition that is universal: it depends on the context. This allows
us to relax the security properties regarding the protocol, and thus prove the compositional
security of some protocols that cannot be proved secure in the UC sense. We also rely on
implicit sids to prove the security of multiple sessions. Some limitations of the UC framework
are discussed in [18, Appendix A].
In [5], the authors also address the ﬂexibility of UC (or reactive simulatability) showing how
to circumvent some of its limitations. The so-called “predicates” are used to restrict the order
and contents of messages from environment and deﬁne a conditional composability. Assuming
a joint-state conditional composability theorem, secret sharing between the environment and
the protocol might be handled by restricting the accepted messages to the expected use of the
shared secrets. However, the framework does not cover how to prove the required properties
of (an instance of) the environment.
Protocol Composition Logic is a formal framework [21] designed for proving, in a “Dolev-
Yao model”, the security of protocols in a compositional way. Its computational semantics is
very far from the usual game-based semantics, and thus the guarantees it provides [22] are
unclear. Some limitations of PCL are detailed in [23].
The compositional security of SSH, in the sense of [18], has been studied in [24]. They do
not consider however the agent forwarding feature. It introduces important diﬃculties since
the key exchange is composed with a second key exchange that uses both the ﬁrst derived key
and the same long term secrets. SSH has also been studied, without agent forwarding, in [25],
6
where the implementation is derived from a secure modelling in CryptoVerif [26].
Summing up, our work is strongly linked to previous composition results and captures
analogues of the following notions in our formalism:
implicit disjointness of local session
identiﬁers [20], single session games [18], key-independent reductions [8] and the classical
proof technique based on pushing part of a protocol inside an attacker, as recently formalized
in [10]. We build on all these works and additionally allow sharing long term secrets, thanks
to a new notion of O-simulatability. This ﬁts with the CCSA model: the formal proofs
of composed protocols are broken into formal proofs of components. All these features are
illustrated by a proof of SSH with (a modiﬁed) agent forwarding.
2 Protocols and Indistinguishability
We ﬁrst recall some features of the CCSA model. Although this model is not used until the
case studies, it may be useful for an easier understanding of the protocol semantics.
2.1 Syntax and semantics of terms
To enable composition with long term shared secrets, we must be able to specify precisely
the shared randomness between protocols. We use symbols from an alphabet of names, to
represent the random samplings. The same symbol used twice represents the same (shared)
randomness. Those names can be seen as pointers to a speciﬁc randomness, where all the