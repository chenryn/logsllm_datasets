generic and at identifying different kinds of intrusion such
as buffer overﬂows or denial of service attacks. In [10], the
authors focus on analysing system call traces produced by
the sendmail program and they propose ways of learning
rules for detecting normal and abnormal sequences. Other
works, which focus on university account theft [22], analyse
authentication logs and build on heuristics to introduce fea-
tures that are sensible to the situation such as temporal-spatial
violation or inconsistencies based on resource usage. More
speciﬁc works have focused on intrusion detection on Android
devices [21]. Their machine learning mechanisms rely on fea-
tures based on dataﬂow-related APIs which are particularly
suited for describing Android application behaviours.
Although these works aim at detecting different kinds of in-
trusion, our work aims at building precise methods for identi-
fying a speciﬁc and particularly common action that intruders
may perform which is credential theft from Windows memory.
All of those works resorted to heuristics based on security
knowledge and domain expertise in order to build features
that were suited to analyse their speciﬁc situation and that
made machine learning algorithms exploitable. Similarly, as
our work means to study the memory read behaviours of dif-
ferent programs, we introduce in Section 7 the features that
we used in our analyses and we justify our intuition as for
why they are meaningful in our scenario.
3 Methodology Driven By Customer Data
We now develop and justify our approach and its methodology,
which are motivated by two chief objectives:
• Develop an accurate model for read behaviour of LSASS
memory as a basis for classifying malicious reads.
• Protect customers of MDATP against current attacks that
steal credentials from LSASS memory through detectors
that use such accurate models.
simulations on test machines. This rationale justiﬁes and
shapes the manner in which we collect our data and perform
our subsequent analyses. These data are collected as part of
an opt-in, commercial relationship between Microsoft and
their enterprise customers. The data are collected from indi-
vidual operating systems as part of the MDATP deployment,
in nearly real time, and sent to Azure to provide detection and
remediation capabilities. Care is taken to obfuscate personal
information before presentation to researchers.
We analysed the processes that were reading from the
LSASS memory on all machines that are customers of
MDATP and looked for credential dumping tools such as
Lslsass, Windows Credential Editor and Mimikatz. The only
tool that we effectively observed running in a non-obfuscated
manner on customers’ machines was Mimikatz.
We thus decided to study the read behaviour of LSASS
memory for a set of prominent anti-virus and security soft-
ware tools, but also for Mimikatz as the most relevant tool an
attacker appears to choose. As explained further in Section
4, our intuition for building a model of such read behaviours
came from studying the way in which such credential dump-
ing tools work, with a particular emphasis on Mimikatz.
Our data collection and machine learning then proceeded
in the following stages:
• We analysed the behaviour of the most prevalent benign
software that scan the memory of the LSASS process by
examining a random sample of seventy-thousand differ-
ent machines that run MDATP.
• We then harvested the LSASS read behaviour of creden-
tial theft techniques performed by Mimikatz seen on real
customers’ machines by harvesting such attacks on 244
different machines that run MDATP.
• Based on these data, we trained and tested a detector for
credential theft.
• Finally, we analysed the inﬂuence of Windows update on
the read behaviour of credential theft techniques based
on recent data, by collecting and comparing malicious
read behaviours on machines running on different Win-
dows update versions.
In Section 11, we discuss potential countermeasures that
an attacker could devise in order to bypass our detector. Re-
gardless of bypass techniques, however, the practical beneﬁts
of our detector were deemed powerful enough to lead to their
integration into the deployed MDATP detection suite.
Our methodology also has the advantage of being rather
generic. Therefore, this novel way of characterising malicious
processes may be transferable to other kinds of malicious be-
haviour or may safeguard other parts of the Windows memory.
4 Modelling and Collecting Memory Reads
As we aim at protecting MDATP customers, we place great
value on the data that originates from machines of genuine
MDATP customers, rather than relying on data generated by
LSASS contains secrets that are stored in its process memory.
Keys and credentials held here are attractive to attackers as
they enable them to perform operations such as decrypting
184    23rd International Symposium on Research in Attacks, Intrusions and Defenses
USENIX Association
sensitive data, or impersonating users that have a higher level
of privilege on the domain.
Tools that read from LSASS memory in order to obtain
these secrets, such as Mimikatz, perform a number of cross
process reads of the address space of the LSASS process –
using Windows API calls such as ReadProcessMemory.
These APIs take an address of a target process and size of
the portion to be read as their arguments. Assuming the caller
has the required privileges to read from the target, the data
from this address is then copied to a supplied buffer located
in the caller process.
The address space layout of the LSASS process is dynamic
and varies depending upon a number of factors, such as Ad-
dress Space Layout Randomisation (ASLR), the timing of
memory allocations, the type and size of data that is stored,
and on how long the process has been running. It is therefore
extremely difﬁcult to predict the address at which secrets of
interest reside within the LSASS memory.
Since one cannot simply provide an address and perform
a single read to obtain the required information, tools such
as Mimikatz must instead ﬁrst perform multiple reads of the
LSASS process in order to search for addresses at which the
sensitive data resides.
Whilst the target process address space is generally un-
predictable, there are some ﬁxed frames of reference that
can be exploited in this activity. For example, the ad-
dress of the Process Environment Block (PEB) of the re-
mote process can be obtained by an API call such as
NtQueryInformationProcess. The target Process Environ-
ment Block can then be read to discover the location of certain
modules loaded by the process.
Once these module locations are known, pointers from
structures that are stored as global variables inside these mod-
ules can be read predictably, where this predictability varies
slightly with the operating system versions. When these point-
ers are followed, they lead to other structures that can act as
clues that ultimately help to unravel and reveal the address
where credentials or other secrets are stored.
For example, the Mimikatz sekurlsa::logonpasswords
operation enumerates and displays all credentials for logon
sessions stored within LSASS and follows this approach:
• It performs multiple remote reads against the LSASS
Process Environment Block to retrieve loaded module
information for loaded lsa package dll ﬁles.
• For the MSV1_0 authentication package, it remotely reads
all of msv1_0.dll into a local buffer. Starting at the
base address, it searches for a series of magic bytes that
are located in close proximity to a pointer to the logon
session list.
• It mines a series of magic bytes that are in close proxim-
ity to an AES key and Initialisation Vector (IV) located
in LSASS memory and remotely reads the key and vector
to a local buffer.
• It copies the size of the logon session list out of LSASS
memory.
• For each of the items in the session list, it remotely reads
various details from the session out of LSASS memory
in individual reads – username, domain, SID, etc., and a
pointer to where the credentials are stored.
• A number of reads from LSASS are then performed
to pull different structures out of LSASS, the last one
contains encrypted credentials as a unicode string.
• The encrypted credential material is then decrypted using
the previously retrieved key and IV.
These operations result, over short time periods, in a large
and varying number of reads of the LSASS process memory.
Since Windows 10 RS3, insights into memory reads of
target processes are possible – due to instrumentation of the
memory manager. Telemetry from this instrumentation is
available to security vendors via the Microsoft-Windows-
Threat-Intelligence Event Tracing for Windows provider.
This telemetry information provides details of the calling
process, the target process, and the size of the data that was
copied. It is not practical to collect all of these events. Even if
we were to restrict the collection of these events to the target
of LSASS, the volume of data generated from a single host
would be too large to be practical at network scale.
Instead, aggregates of this data are created by MDATP.
These aggregates summarise data into 5-minute time slices,
which we will refer to as sessions, that provide the calling
process, target process, the total of bytes read and the number
of reads that occurred within that time slice.
Given the total number of bytes read and the number of
reads within that time period, it seems natural to model the
behaviour of credential theft tooling such as Mimikatz by
these data aggregates understood as features for machine
learning. We conjecture that the manner in which malicious
tools extract secrets from LSASS memory is different enough
from the read behaviour of LSASS memory for benign tools,
when we understand behaviour in terms of those features.
The next sections will report on our experimental work for
testing and conﬁrming this conjecture.
5 Patterns in Benign Read Behaviours
Based on the model of behaviour and the features of such be-
haviour introduced in the previous section, we next investigate
the behaviour of LSASS memory reads for benign processes
that run anti-virus or other security software. This investiga-
tion means to identify whether benign read behaviour follows
any particular statistical patterns that could differentiate them
from processes that run tools which aim to steal credentials.
To that end, we performed the following experiment:
Experiment 1. We collected 100k read sessions randomly
sampled over 10 days on 70k different machines running
MDATP. We plot in Figure 1 the behaviour of 5 of the most
prevalent processes to read memory from LSASS: WmiPrvSE,
USENIX Association
23rd International Symposium on Research in Attacks, Intrusions and Defenses    185
meant to perform similar tasks might explain why the data
that we observe for them is localised into speciﬁc clusters.
Our conjecture suggests to study the read behaviour of
LSASS memory for malicious processes that are trying to
steal credentials, and to determine whether the patterns of
such malicious reads are sufﬁciently different from those of
benign read behaviours. This is the topic of the next section.
The classiﬁcation and the resulting detector that we develop
in this paper have uses beyond the mere classiﬁcation into
benign or malicious process. For example, a process whose
behaviour seems anomalous compared to all data clusters of
applications that are known to be benign may be deemed to be
suspicious even if no prior data about that process is available.
Similarly, when the actual read behaviour of an application
that is known to be benign deviates from what its data clus-
ter would suggest, this can indicate that the application has
become infected – triggering an appropriate response.
6 Harvest and Analysis of Malicious Reads
We have seen that the behavioural model of reads from
LSASS memory, introduced in Section 4, provides us a use-
ful and effective characterisation of how benign processes
access LSASS memory. In this section, we analyse the read
behaviour of LSASS memory deemed most important to cre-
dential theft techniques. This requires an experiment to collect
data from real Windows networks, and a subsequent analysis
of that data in order to assess whether our behavioural model
allows us to distinguish benign from malicious processes, as
claimed in our conjecture.
As already emphasised in Section 3, our research and busi-
ness objective is to protect Windows customers from threats
that are existing at present. Since many current credential
thefts from LSASS memory are based on use of the Mimikatz
tool, we focus our attention on studying the behaviour of that
tool when it is invoked on machines of customers.
To that end, we conducted the following experiment:
Experiment 2. We collected some data for all instances of
Mimikatz invocations that we observed on machines that use
MDATP, from January to July 2019. This exercise gathered
a total of 1600 Mimikatz instances that were collected on
244 different machines within that 7-month period. Out of
these 1600 instances, 256 were interactive sessions and were
launched without any command line arguments. We could ap-
ply an unsupervised classiﬁcation technique in order to label
these data points, but for simplicity purposes we discarded
those entries from our analysis. Thus, we obtained 1344 la-
belled data points from this experiment, instances of Mimikatz
invocations that have one of three possible labels L1, L2 or
L3 – denoting which of the three commands listed in items
L1-3 in Section 2 were used in these respective instances.
Out of those 1344 labelled instances, 39 instances were iso-
lated data points which we decided to discard for the purpose
Figure 1: Read behaviour of LSASS memory for the 5 most
prevalent security software and anti-virus applications, with
data collected over 10 days across 70k different machines.
Units are millions (x-axis) ten-thousands (y-axis).
Mcshield, MsMpEng, Wepsvc and CollectGuestLogs which
are security software tools which scan the LSASS memory
for potentially infected ﬁles. Recall that for each of those
5-minute sessions performed by those tools, we recorded the
number of bytes read and the total number of read attempts
performed during that session. Figure 1 shows the read ses-
sions whose number of bytes read was between 0 and 6 million.
We chose this range as it will be of particular interest when
comparing benign with malicious behaviours in Section 6.
The plots in Figure 1 suggest that data are very sparse, and
that the large majority of the data points appear to aggregate
on four different highly linear relationships passing through
the origin. For each of those four clusters, we could ﬁt a
linear model for classiﬁcation in terms of the selected fea-
tures. Some of these linear clusters contain a single process,
such as the one formed by WmiPrvSE. This suggests that it
is reasonable to devise a method for identifying whether a
process reading from LSASS memory is indeed WmiPrvSE or
not – based on the data point that it leaves on this graph.
The processes such as CollectGuestLogs and Wepsvc
seem to lie on the same line, and it would thus be more difﬁ-
cult to distinguish both processes by looking at their read be-
haviours of LSASS memory, especially for those data points
that could represent either of those processes.
However, it is perfectly reasonable that two security soft-
ware applications may perform similar routine sanity checks
on the same area of memory, and therefore may have similar
read behaviour of LSASS memory. Fortunately, we have no
need to distinguish between different benign processes. At
the abstract level of classiﬁcation of malicious read behaviour
of LSASS memory, it is safe to identify such benign processes
if their behaviour is sufﬁciently similar.
Also, the fact that the benign processes we are studying are
186    23rd International Symposium on Research in Attacks, Intrusions and Defenses
USENIX Association
0246·1060246·104BytesreadReadattemptsWmiPrvSEMcshieldMsMpEngWepsvcCollectGuestLogsLSASS memory takes place, but that can also classify which
credential theft technique is being used in that attack. Such
information is valuable as a guide for security response and
to improve security intelligence data.
7 Modelling Credential Theft
The experiments and analysis of the collected data on the read
behaviours of LSASS memory, described in Sections 5 and
6, suggest that it is feasible to build a detection mechanism
for credential theft based on such read behaviour of processes.
This section discusses how we built such a detector, based on
the data collected in Section 6.
We split the cleaned dataset, containing the 1305 labelled
memory reads performed by Mimikatz instances, into 3
datasets following a standard 60%-20%-20% distribution:
a training set of size 783, and a validation and a test set both
of size 261. In order to build this detector, we studied the
different memory read techniques L1-L3 individually and we
noticed that each of them was producing data that seemed to
aggregate on linear clusters.
The idea of our detector is thus to consider that a data point
witnesses a malicious memory read technique if it lies within
a certain interval around the corresponding line. To realise
this idea, we performed logistic regressions for the data points
on the training set, for each of the techniques L1-L3.
We then used the validation set to analyse the inﬂuence of
the width of the detection interval on the classiﬁcation rates.
Then, we use the test set to establish that we obtain low false
positive (FP) and false negative (FN) rates.
7.1 Training
We display in Figure 3 a zoomed-in view of the data points
that we collected for the memory read technique L1, which
steals logon passwords from LSASS memory. We can see
that those points seem to lie on a line, which conﬁrms the
effectiveness of our behavioural model. For these data, we