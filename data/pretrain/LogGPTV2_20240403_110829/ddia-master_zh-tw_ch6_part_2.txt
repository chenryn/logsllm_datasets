### 根据键的杂凑分割槽
由于偏斜和热点的风险，许多分散式资料储存使用杂凑函式来确定给定键的分割槽。
一个好的杂凑函式可以将偏斜的资料均匀分布。假设你有一个 32 位杂凑函式，无论何时给定一个新的字串输入，它将返回一个 0 到 $2^{32}$ -1 之间的 “随机” 数。即使输入的字串非常相似，它们的杂凑也会均匀分布在这个数字范围内。
出于分割槽的目的，杂凑函式不需要多么强壮的加密演算法：例如，Cassandra 和 MongoDB 使用 MD5，Voldemort 使用 Fowler-Noll-Vo 函式。许多程式语言都有内建的简单杂凑函式（它们用于散列表），但是它们可能不适合分割槽：例如，在 Java 的 `Object.hashCode()` 和 Ruby 的 `Object#hash`，同一个键可能在不同的程序中有不同的杂凑值【6】。
一旦你有一个合适的键杂凑函式，你可以为每个分割槽分配一个杂凑范围（而不是键的范围），每个透过杂凑杂凑落在分割槽范围内的键将被储存在该分割槽中。如 [图 6-3](../img/fig6-3.png) 所示。
![](../img/fig6-3.png)
**图 6-3 按杂凑键分割槽**
这种技术擅长在分割槽之间公平地分配键。分割槽边界可以是均匀间隔的，也可以是伪随机选择的（在这种情况下，该技术有时也被称为 **一致性杂凑**，即 consistent hashing）。
> #### 一致性杂凑
>
> 一致性杂凑由 Karger 等人定义。【7】 用于跨网际网路级别的快取系统，例如 CDN 中，是一种能均匀分配负载的方法。它使用随机选择的 **分割槽边界（partition boundaries）** 来避免中央控制或分散式共识的需要。请注意，这里的一致性与复制一致性（请参阅 [第五章](ch5.md)）或 ACID 一致性（请参阅 [第七章](ch7.md)）无关，而只是描述了一种再平衡（rebalancing）的特定方法。
>
> 正如我们将在 “[分割槽再平衡](#分割槽再平衡)” 中所看到的，这种特殊的方法对于资料库实际上并不是很好，所以在实际中很少使用（某些资料库的文件仍然会使用一致性杂凑的说法，但是它往往是不准确的）。因为有可能产生混淆，所以最好避免使用一致性杂凑这个术语，而只是把它称为 **杂凑分割槽（hash partitioning）**。
不幸的是，透过使用键杂凑进行分割槽，我们失去了键范围分割槽的一个很好的属性：高效执行范围查询的能力。曾经相邻的键现在分散在所有分割槽中，所以它们之间的顺序就丢失了。在 MongoDB 中，如果你使用了基于杂凑的分割槽模式，则任何范围查询都必须传送到所有分割槽【4】。Riak【9】、Couchbase 【10】或 Voldemort 不支援主键上的范围查询。
Cassandra 采取了折衷的策略【11, 12, 13】。Cassandra 中的表可以使用由多个列组成的复合主键来宣告。键中只有第一列会作为杂凑的依据，而其他列则被用作 Casssandra 的 SSTables 中排序资料的连线索引。尽管查询无法在复合主键的第一列中按范围扫表，但如果第一列已经指定了固定值，则可以对该键的其他列执行有效的范围扫描。
组合索引方法为一对多关系提供了一个优雅的资料模型。例如，在社交媒体网站上，一个使用者可能会发布很多更新。如果更新的主键被选择为 `(user_id, update_timestamp)`，那么你可以有效地检索特定使用者在某个时间间隔内按时间戳排序的所有更新。不同的使用者可以储存在不同的分割槽上，对于每个使用者，更新按时间戳顺序储存在单个分割槽上。
### 负载偏斜与热点消除
如前所述，杂凑分割槽可以帮助减少热点。但是，它不能完全避免它们：在极端情况下，所有的读写操作都是针对同一个键的，所有的请求都会被路由到同一个分割槽。
这种场景也许并不常见，但并非闻所未闻：例如，在社交媒体网站上，一个拥有数百万追随者的名人使用者在做某事时可能会引发一场风暴【14】。这个事件可能导致同一个键的大量写入（键可能是名人的使用者 ID，或者人们正在评论的动作的 ID）。杂凑策略不起作用，因为两个相同 ID 的杂凑值仍然是相同的。
如今，大多数资料系统无法自动补偿这种高度偏斜的负载，因此应用程式有责任减少偏斜。例如，如果一个主键被认为是非常火爆的，一个简单的方法是在主键的开始或结尾新增一个随机数。只要一个两位数的十进位制随机数就可以将主键分散为 100 种不同的主键，从而储存在不同的分割槽中。
然而，将主键进行分割之后，任何读取都必须要做额外的工作，因为他们必须从所有 100 个主键分布中读取资料并将其合并。此技术还需要额外的记录：只需要对少量热点附加随机数；对于写入吞吐量低的绝大多数主键来说是不必要的开销。因此，你还需要一些方法来跟踪哪些键需要被分割。
也许在将来，资料系统将能够自动检测和补偿偏斜的工作负载；但现在，你需要自己来权衡。
## 分割槽与次级索引
到目前为止，我们讨论的分割槽方案依赖于键值资料模型。如果只通过主键访问记录，我们可以从该键确定分割槽，并使用它来将读写请求路由到负责该键的分割槽。
如果涉及次级索引，情况会变得更加复杂（参考 “[其他索引结构](ch3.md#其他索引结构)”）。次级索引通常并不能唯一地标识记录，而是一种搜寻记录中出现特定值的方式：查询使用者 123 的所有操作、查询包含词语 `hogwash` 的所有文章、查询所有颜色为红色的车辆等等。
次级索引是关系型资料库的基础，并且在文件资料库中也很普遍。许多键值储存（如 HBase 和 Volde-mort）为了减少实现的复杂度而放弃了次级索引，但是一些（如 Riak）已经开始新增它们，因为它们对于资料模型实在是太有用了。并且次级索引也是 Solr 和 Elasticsearch 等搜寻伺服器的基石。
次级索引的问题是它们不能整齐地对映到分割槽。有两种用次级索引对资料库进行分割槽的方法：**基于文件的分割槽（document-based）** 和 **基于关键词（term-based）的分割槽**。
### 基于文件的次级索引进行分割槽
假设你正在经营一个销售二手车的网站（如 [图 6-4](../img/fig6-4.png) 所示）。每个列表都有一个唯一的 ID—— 称之为文件 ID—— 并且用文件 ID 对资料库进行分割槽（例如，分割槽 0 中的 ID 0 到 499，分割槽 1 中的 ID 500 到 999 等）。
你想让使用者搜寻汽车，允许他们透过颜色和厂商过滤，所以需要一个在颜色和厂商上的次级索引（文件资料库中这些是 **栏位（field）**，关系资料库中这些是 **列（column）** ）。如果你声明了索引，则资料库可以自动执行索引 [^ii]。例如，无论何时将红色汽车新增到资料库，资料库分割槽都会自动将其新增到索引条目 `color:red` 的文件 ID 列表中。
[^ii]: 如果资料库仅支援键值模型，则你可能会尝试在应用程式程式码中建立从值到文件 ID 的对映来实现次级索引。如果沿著这条路线走下去，请万分小心，确保你的索引与底层资料保持一致。竞争条件和间歇性写入失败（其中一些更改已储存，但其他更改未储存）很容易导致资料不同步 - 请参阅 “[多物件事务的需求](ch7.md#多物件事务的需求)”。
![](../img/fig6-4.png)
**图 6-4 基于文件的次级索引进行分割槽**
在这种索引方法中，每个分割槽是完全独立的：每个分割槽维护自己的次级索引，仅覆盖该分割槽中的文件。它不关心储存在其他分割槽的资料。无论何时你需要写入资料库（新增，删除或更新文件），只需处理包含你正在编写的文件 ID 的分割槽即可。出于这个原因，**文件分割槽索引** 也被称为 **本地索引**（而不是将在下一节中描述的 **全域性索引**）。
但是，从文件分割槽索引中读取需要注意：除非你对文件 ID 做了特别的处理，否则没有理由将所有具有特定颜色或特定品牌的汽车放在同一个分割槽中。在 [图 6-4](../img/fig6-4.png) 中，红色汽车出现在分割槽 0 和分割槽 1 中。因此，如果要搜寻红色汽车，则需要将查询传送到所有分割槽，并合并所有返回的结果。
这种查询分割槽资料库的方法有时被称为 **分散 / 聚集（scatter/gather）**，并且可能会使次级索引上的读取查询相当昂贵。即使并行查询分割槽，分散 / 聚集也容易导致尾部延迟放大（请参阅 “[实践中的百分位点](ch1.md#实践中的百分位点)”）。然而，它被广泛使用：MongoDB，Riak 【15】，Cassandra 【16】，Elasticsearch 【17】，SolrCloud 【18】和 VoltDB 【19】都使用文件分割槽次级索引。大多数资料库供应商建议你构建一个能从单个分割槽提供次级索引查询的分割槽方案，但这并不总是可行，尤其是当在单个查询中使用多个次级索引时（例如同时需要按颜色和制造商查询）。