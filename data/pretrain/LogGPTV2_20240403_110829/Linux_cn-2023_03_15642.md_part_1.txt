---
author: Two-bit History
category: 观点
comments_data: []
count:
  commentnum: 0
  favtimes: 0
  likes: 0
  sharetimes: 0
  viewnum: 3443
date: '2023-03-20 15:43:00'
editorchoice: true
excerpt: 符合描述性状态迁移（REST）的应用程序接口（API）无处不在。有趣的是又有多少人真正了解“符合描述性状态迁移”的应有之义呢？
fromurl: https://twobithistory.org/2020/06/28/rest.html
id: 15642
islctt: true
largepic: /data/attachment/album/202303/20/154318tpynlzzdi1yhug5h.jpg
permalink: /article-15642-1.html
pic: /data/attachment/album/202303/20/154318tpynlzzdi1yhug5h.jpg.thumb.jpg
related: []
reviewer: wxy
selector: lujun9972
summary: 符合描述性状态迁移（REST）的应用程序接口（API）无处不在。有趣的是又有多少人真正了解“符合描述性状态迁移”的应有之义呢？
tags:
- REST
thumb: false
title: 被误用的罗伊·菲尔丁的有关描述性状态迁移（REST）的博士论文
titlepic: true
translator: CanYellow
updated: '2023-03-20 15:43:00'
---
![](/data/attachment/album/202303/20/154318tpynlzzdi1yhug5h.jpg)
符合  描述性状态迁移   REpresentational State Transfer （LCTT 译注：REST，译自审定公布名词数据库）的应用程序接口（API）无处不在。有趣的是又有多少人真正了解“符合描述性状态迁移”的应有之义呢？
大概我们中的大多数人都会跟 [黑客新闻网站上的这篇公开问答](https://news.ycombinator.com/item?id=7201871) 产生共鸣：
> 
> 我阅读了几篇介绍描述性状态迁移（REST）的文章，甚至包括原始论文的部分章节。然而我仍然对REST 到底是什么只有一个相当模糊的想法。我开始认为没有人真的了解它，它仅仅是一个定义相当不充分的概念。
> 
> 
> 
我曾经计划写一篇有关 REST 的博客，在里面探讨 REST 是如何成为这样一个在网络通信领域占主导地位的范式的。我通过阅读 [2000 年发表的  罗伊·菲尔丁   Roy Fielding  的博士论文](https://www.ics.uci.edu/~fielding/pubs/dissertation/fielding_dissertation_2up.pdf) 开始我的研究，这篇博士论文向世人介绍了 REST 的概念。在读过菲尔丁的博士论文以后，我意识到，相比之下，更引人注意的是菲尔丁的理论缘何受到如此普遍的误解。
（相对公平地说，）很多人知道 REST 源自菲尔丁的博士论文，但并没有读过该论文。因此对于这篇博士论文的原始内容的误解才得以流行。
最大的误解是：这篇博士论文直接解决了构建 API（API）的问题，我此前一直认为 REST 从一开始就打算成为构建在超文本传输协议（HTTP）之上的  网络 API   Web API 的架构模型，我相信很多人也这样认为。我猜测此前可能存在一个混乱的试验时期，开发人员采用完全错误的方式在 HTTP 基础上开发 API，然后菲尔丁出现了，并提出了将 REST 做为网络应用程序开发的正确方式。但是这种想法的时间线对不上：我们今天所熟知的网络服务的 API 并非是在菲尔丁出版他的博士论文之后才出现的新生事物。
菲尔丁的博士论文《架构风格与基于网络的软件架构设计》不是讨论如何在 HTTP 的基础上构建 API，而恰恰是讨论 HTTP 本身。菲尔丁是 HTTP/1.0 版规范的贡献者，同时也是 HTTP/1.1 版的共同作者。有感于从 HTTP 的设计中获得的架构经验，他的博士论文将 REST 视为指导 HTTP/1.1 的标准化过程的架构原则的精华。举例而言，他拒绝了使用新的 `MGET` 和 `MHEAD` 方法进行批量请求的提议，因为他认为这违反了 REST 所定义的约束条件，尤其是在一个符合 REST 的系统中传递的消息应该是易于代理和缓存的约束条件。   [1]  因此，HTTP/1.1 转而围绕持久性连接设计，在此基础上可以发送多个 HTTP 请求。（菲尔丁同时认为网页保存在本地的浏览数据，即 cookie 是不符合 REST 的，因为它们在一个状态无关的系统中增加了状态描述，然而它们的应用已经根深蒂固了。   [2] ）菲尔丁认为，REST 并非构建基于 HTTP 的系统的操作指南，而是扩展 HTTP 的操作指南。
这并不意味着菲尔丁认为 REST 不能用于构建其他系统。只是他假定其他系统也是 “ 分布式超媒体系统   distributed hypermedia systems ”。人们对 REST 还有另一个误解：认为它是一个可以用在任何网络应用中的通用架构。但是从这篇博士论文中菲尔丁介绍 REST 的部分你基本上能够得出如下的结论，“请注意，我们只设计了 HTTP，但是如果你发现你自己也在设计一个\_分布式超媒体系统\_，你也应该采用我们提出的称为 REST 的优秀架构，以让开发变得更容易”。有鉴于互联网已经存在了，我们尚不清楚为什么菲尔丁认为有人可能试图重新创建这样一个（和 HTTP 一样的）系统。或许在 2000 年的时候世界上仍然存在不只一个分布式超文本系统的空间吧。无论如何，菲尔丁已经说得很清楚了，REST 意在提供一套解决方案，来解决在试图经由网络连接超文本内容时出现的可扩展性与一致性问题，*而不是* 作为分布式应用的通用架构模型。
我们现在只记得菲尔丁的博士论文提出了 REST 的概念，但事实上，他的博士论文是在讨论一刀切的软件架构有多么糟糕，以及如何更好地选择符合你需求的软件架构。这篇博士论文中仅用了一个章节来讨论 REST 本身，大量的文本内容都都花在了对你能够在网络应用中运用的不同的架构风格    [3]  的分类上。这些架构风格包括：受 Unix 的管道设计启发的  管道-过滤器   Pipe-and-Filter  （PF）风格， 客户-服务器   Client-Server  （CS）风格的多种改进，如  分层-客户-服务器   Layered-Client-Server （LCS）风格、 客户-缓存-无状态-服务器   Client-Cache-Stateless-Server （C$SS）风格和 分层-客户-缓存-无状态-服务器   Layered-Client-Cache-Stateless-Server （LC$SS）。这些缩略词未必实用，但是菲尔丁认为我们可以通过混合匹配现有风格提供的约束条件来派生出新的风格。REST 就是通过这种方式产生的，它本可以称之为  一致性-分层-按需代码-客户-缓存-无状态-服务器   Uniform-Layered-Code-on-Demand-Client-Cache-Stateless-Server （ULCODC$SS）风格，显然我们并没有这样做。菲尔丁建立上述分类是为了强调（每一种风格对应的）约束适用于不同的应用，而上述最后一种风格对应的约束是他所认为的最适用于 HTTP 的。
今天，REST 的无处不在是极具讽刺意味的。REST 在各种各样的网络应用中被盲目使用，但是菲尔丁最初只是将 REST 视作一种指引，通过它指导人们裁剪一种软件架构来适应独立应用的特殊需求。
我很难弄清楚这是如何发生的，毕竟菲尔丁已经明确地指出了不能让形式服从功能的陷阱。他在论文的一开始就作出了警告：由于没有正确地理解软件架构而“使用流行的架构设计是经常发生的”   [4] 。他在几页之后又重新强调了这一点：
> 
> 一些架构风格经常被描述为适用于一切软件形式的“银弹”解决方案。然而，一名好的设计者应该选择能够满足解决特定问题的需要的架构风格   [5] 。
> 