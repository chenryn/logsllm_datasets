1 typedef void (*fptr_t0)(char *);
2 struct A { fptr_t0 handler; };
3 void func_A(char *);
4 struct A a = { .handler = &func_A };
5 struct B b = { .handler = &func_B } ;
6 struct B * a2b = (struct B *) &a;
Figure 3: An example showing the FN of FLTA. The icall in line 6 takes
type ftpr_t1, which only func_B matches. However, the real target is func_A.
FLTA misses it as it does not consider the type casting between A and B.
(*a2b->handler)(0);
of type mlt (p) should be the union of all M[γ], where γ is in M and
compatible with mlt (p). All functions in the union are valid targets
of the icall.
Before we formally analyze MLTA and FLTA, we introduce the
term sensitive type defined in the paper of Code Pointer Integrity
recursively [27]: a sensitive type is a function-pointer type, a void
type, a pointer type of another sensitive type, or a pointer type of a
structure that has at least one member with a sensitive type.
Lemma 1. If the program does not have any type-cast of sensitive
types, (1) FLTA has no FN; (2) MLTA has no FN; (3) MLTA introduces
no extra FP than FLTA; (4) MLTA may have fewer FPs than FLTA.
Proof. Given any icall (∗p)(), suppose f is one target function
based on the ground-truth:
(1) FLTA has no FN. Suppose f has type F and its address is taken
with a=&f , a must have type F∗. The confinement rule of FLTA
will add f into M[t (a)], i.e., f ∈M[F∗]. Similarly, p must have type
F∗. The resolving rule of FLTA infers the target set of this icall is
M[t (p)]=>M[F∗], which contains f .
(2) MLTA has no FN. Suppose the address of f is taken through
a=&f , and the complete multi-layer type of a is A:· · · :Z, and the
complete multi-layer type of p is A1:· · · :Z1. As there is not cast al-
lowed between sensitive types, for each involved basic byte X,
X must be the same as X1. Suppose the mlt (a) in the confine-
ment rule is N :· · · :Z, where N is either A or _, then we have
f ∈M[N :· · · :Z]. Similarly, in the resolving rule, suppose the mlt (p)
is L:· · · :Z where L is either A or _, the resolving result will be
a super set of M[N :· · · :Z] as N :· · · :Z is always compatible with
L:· · · :Z. Therefore, the result must contain f .
(3) MLTA has no extra FPs than FLTA. Suppose f has type F, p must
have type F∗. Suppose the resolving rule of MLTA finds mlt (p) is
N :· · · :F∗, then the resolving result of MLTA must be a subset of
that by resolving _:F∗, as any type compatible with N :· · · :F∗ is
also compatible with _:F∗. Meanwhile, resolving _:F∗ with MLTA
is equivalent to resolving F∗ with FLTA. Thus, for one icall, the
target set returned by MLTA is a subset of that returned by FLTA.
(4) MLTA may have fewer FPs than FLTA. The code in Figure 1 shows
that MLTA introduces fewer FPs than FLTA. This is adequate to
prove this predicate. In fact, we can generally view the map M in
FLTA as a union of that in MLTA. As long as the propagation of
MLTA does not merge all targets to their compatible first-layer
type, like _:ptr, MLTA will have fewer FPs than MLTA.
□
Lemma 2. If the program has type-cast of sensitive types, (1) FLTA
may have FNs; (2) MLTA has no FN; (3) MLTA may have fewer FPs
than FLTA.
Proof. Given any indirect call instruction (∗p)(), suppose f is one
target function based on the ground-truth:
(1) FLTA may have FNs. Consider Figure 3: the function pointer
a2b->handler has type fptr_t1, and FLTA will report the target is
func_B as it is the only type-matched function. However, the real
target is func_A. FLTA misses the real target as it does not consider
the type casting in outer-layer types, i.e., from A* to B*. In fact,
FLTA will miss all implicit cast of function pointer types that are
indicated by casts between outer-layer types.
(2) MLTA has no FN. The only way to introduce FNs here is through
type casting. The propagation rule of MLTA handles type casting
conservatively. mlt (a) could be different from mlt (p) at each layer,
or even has a different number of basic types. The type casting may
take several steps, each happening at a different layer. However, the
propagation rule always conservatively propagates all functions
from all compatible types of the source type to all compatible types
of the destination type, including the longest type. Therefore, MLTA
will not drop any function targets during the type casting. Therefore,
it will not introduce any FN compared to the scenario where no cast
of sensitive types is allowed. In summary, even with type casting,
MLTA does not introduce any FN.
(3) MLTA may have fewer FPs than FLTA. With the multi-layer
confinement, for each source type, MLTA may have fewer FPs. For
programs with many type layers, MLTA can achieve significantly
fewer FPs than FLTA, as we will show in §7.2.
□
Theorem 1. (1) MLTA does not introduce any FN. (2) FLTA may
have FNs. (3) MLTA can have fewer FPs than FLTA.
Proof. Lemma 1 and Lemma 2 indicate the theorem.
7 Evaluation
We have provided our formal analysis of MLTA and implemented
TypeDive based the LLVM compiler infrastructure. In this section,
we evaluate TypeDive in the following aspects.
• Scalability. TypeDive excels in large programs where composite
types are prevalent. The evaluation should first confirm that
TypeDive can scale to extremely large programs (§7.1).
• Effectiveness. Reducing icall targets is the main goal of TypeDive.
The evaluation should show to which extent TypeDive can re-
duce the number of icall targets (§7.2).
• No false negatives. Avoiding potential false negatives is another
design goal of TypeDive. The evaluation should confirm that
TypeDive does not miss valid icall targets (§7.3).
• Important use cases. As a foundational approach, we apply
TypeDive to assist static bug-detection mechanisms to demon-
strate its usefulness (§7.4).
□
Experimental setup. We apply TypeDive to real-world system
programs, including the Linux kernel of version 5.1.0, the FreeBSD
kernel of version 12.0-RELEASE, and the Firefox browser (C++) with
the top commit number f2cd91cb305f. While the Linux kernel is
compiled with the allyesconfig option (including as many mod-
ules as possible), the FreeBSD kernel and the Firefox browser are
compiled with the default configuration. All programs are compiled
with flags -O0 -g -fno-inlining. These flags make sure that the
generated binary accurately contains all debug information, such
as line numbers and function names, which will simplify our ver-
ification on false negatives (§7.3) and analysis on detected bugs
(§7.4). However, TypeDive by design should work on any other
Session 8D: Language SecurityCCS ’19, November 11–15, 2019, London, United Kingdom1875System Modules
17,558
Linux
1,481
FreeBSD
Firefox
1,541
SLoC
10,330K
1,232K
982K
Loading Analysis
1m 40s
6s
1m 25s
2m 6s
6s
27s
Table 2: Scalability of TypeDive.
compilation configurations, including higher optimization levels
(e.g., -O2) and aggressive code inlining. Although the evaluation
numbers could be different from what we report here, we believe
the effectiveness of TypeDive should be similar for other compila-
tion options. We leave the evaluation with other options as future
work. The experimental machine is equipped with Ubuntu 18.04
LTS with LLVM version-8.0 installed. The machine has a 64GB
RAM and an Intel CPU (Xeon R CPU E5-1660 v4, 3.20 GHz) with 8
cores.
7.1 Scalability of TypeDive
The results are shown in Table 2. TypeDive can finish constructing
the global call-graph for 10 million lines of code in the Linux kernel
within four minutes. In fact, more than two minutes are spent in
loading bitcode files. The promising scalability benefits from that
TypeDive avoids data-flow analysis or pointer analysis, but uses
only type analysis. TypeDive’s split of multi-layer types into two-
layer types also helps reduce the storage and computation cost.
7.2 Reduction of Indirect-Call Targets
The main goal of TypeDive is to reduce false positives in finding
icall targets. We evaluate the effectiveness of TypeDive by mea-
suring to what extent TypeDive can reduce icall targets. In this
evaluation, we take the total number of address-taken functions as
the baseline and count how many false-positive targets can be re-
moved. We report the average number of icall targets identified by
TypeDive, for the three system programs, present the distribution
of numbers of targets, and breakdown the reduction by layers.
Average number of targets. Table 3 shows the average numbers
of icall targets reported by TypeDive. Column iCall for TypeDive
denotes how many icalls benefit from TypeDive. If an icall does
not load the function pointer from a composite-type object, or
TypeDive cannot ensure zero false negatives (e.g., the composite
type has escaped), the icall does not qualify TypeDive and thus
is excluded in this column. The results show that most icalls can
enjoy the reduction offered by TypeDive. In particular, 81% icalls in
the Linux kernel have their targets refined by TypeDive. Column
&Func. denotes the number of address-taken functions. All tested
system programs have a large number of address-taken functions.
Therefore, traditional coarse-grained CFI techniques [1] that con-
servatively take all these functions as valid icall targets will have
weak protection. The column Ave. target (signature) shows the
average number of targets after applying the signature-based (i.e.,
function type, first-layer) matching. The last column shows the
final average number of targets after applying TypeDive, which is
based on the icalls that qualify TypeDive.
The average numbers are calculated over icalls that can benefit
from MLTA, i.e., the types have at least two layers. When calculating
the average over all icalls (i.e., also including the ones cannot benefit
System Total
iCall
58K
6.3K
37K
Linux
FreeBSD
Firefox
iCall for &Func. Ave. target
(signature)
TypeDive
134
47K (81%)
25.5
4.0K (64%)
23K (63%)
115
180K
8.7K
58K
Ave. target
(TypeDive)
7.7 (94% ↓)
3.5 (86% ↓)
1.8 (98% ↓)
Table 3: Reduction of icall targets. &Func denotes the number of address-
taken functions. The reduction percentage is based on the targets reported
by the signature-based approach (i.e., the first-layer type analysis).
Figure 4: Distribution of the numbers of icall targets. MLTA identifies
more icalls with fewer targets (less than four targets) while FLTA infers
more icalls with more targets. Both of them have a long tail, where icalls
under MLTA have at most 1,914 targets while icalls under FLTA have at
most 7,983 targets.
from MLTA), the average numbers of indirect-call targets will be
amortized: they are 31.6, 11.5, and 44.6 for Linux, FreeBSD, and
Firefox, respectively.
The average number of targets reflects the complexity of static
analysis to traverse the whole CFG for any particular analysis. As
we treat TypeDive as a general tool for generating accurate CFG,
the average number of targets is a reasonable metric. However,
it may fail to measure the benefit of using TypeDive for defense
mechanisms such as improving CFI [15, 55]—as will be shown as
in the next evaluation of target distribution, some icalls still have a
large number of targets.
Distribution of the numbers of targets. We show the distribu-
tion of the numbers of icall targets in Figure 4. The CDF (cumu-
lative distribution function) of MLTA always has a larger value
than CDF-FLTA, showing that MLTA consistently identifies fewer
targets for icalls than FLTA. Based on the PDF (probability density
function) graphs, MLTA identifies more icalls with less than four
targets, while FLTA finds more icalls with at least four targets. All
graphs have long tails, indicating that under static analyses, some
icalls still permit a large number of targets. For example, under
the MLTA analysis, icalls have at most 1,914 targets, while under
FLTA, icalls could have up to 7,983 targets. For these icalls, we
may seek help from runtime information to reduce the number of
targets [22, 36, 48].
Reduction breakdowns. We further evaluated the extent to which
the type matching at each layer can refine the icall targets. In this
evaluation, we make TypeDive configurable to layers by specify-
ing the maximum layers. Once TypeDive reaches the maximum
2123252729211213numberoficalltargets0.00.20.40.60.81.0ratioofallicallsCDF-MLTACDF-FLTAPDF-MLTAPDF-FLTASession 8D: Language SecurityCCS ’19, November 11–15, 2019, London, United Kingdom1876number, it stops the analysis and reports the current target set. Ta-
ble 4 shows the results. We found that the first couple of layers can
dramatically reduce the icall targets. This is because types for each
layer are largely independent. However, the reduction becomes
steady after four layers. TypeDive can still slightly reduce the tar-
gets for the Linux kernel given the extremely complex code. Based
on the results, we believe that a layer number of five should be able
to remove most targets for general programs. Several recent works
propose similar ideas for confining icall targets [15, 29], and most
of them can be treated as special two-layer type analysis. We will
discuss the difference between TypeDive and those works in §9.
False positives. Static analysis of icall resolution has to consider
all possible invocations of one icall instruction, where each invoca-
tion may have different targets by design instead of a unique code
target [22]. However, our evaluation shows that MLTA has dramat-
ically reduced the average number even for extremely complicated
programs like the Linux kernel. Especially for Firefox, the average
number is less than 2. As shown in Table 3, MLTA significantly
improves over the state-of-the-art FLTA techniques [35, 46], where
the average number of icall targets is reduced by around 90%.
7.2.1 Comparisons with existing works. The work by Ge et al. [15]
uses taint analysis and type analysis to find icall targets. The authors
use the average number of icall targets to evaluate the analysis ac-
curacy and provides the measurement on several operating systems.
One common benchmark between our work and [15] is FreeBSD,
where the latter reports that each icall has 6.64 targets on average.
Although our result is better than that, we have to clarify two dif-
ferences between the two evaluations. First, our result is calculated
over icalls that MLTA can provide two-or-higher layer result, which
is 64% of all icalls. When we calculate the average number over all
icalls (i.e., also including the ones cannot benefit from MLTA), the
number is about 12, higher than 6.64 reported in [15]. Second, our
result does not count icalls in assembly code, which usually has
a single target. [15] takes them into consideration; therefore, the
average number should be higher if they exclude these single-target
icalls. Other than the accuracy, [15] requires manual fixing when
violations of assumptions are detected. In comparison, TypeDive
automatically falls back to an upper layer to avoid false negatives.
Further, since [15] uses static taint-analysis, it will take a longer
time to finish.
Pointer analysis is an alternative approach to finding icall targets.
Recent work [14] (section 5.4) compares the effectiveness of type-
based CFI (i.e., based on FLTA) and that of pointer analysis–based
CFI (i.e., using SVF [44]). The comparison indicates two results. First,
there is no strong evidence showing that pointer analysis can lead to
more accurate results in resolving icall targets. Among 14 evaluated
programs, FLTA achieves more accurate results than SVF on eight
programs but has worse results on the other four programs. Since
MLTA performs much better than FLTA on kernels and a browser,
we believe it will provide better results than pointer analysis–based
approaches in general. Second, for two out of 14 programs, specifi-
cally, Nginx (139 kLoC) and Httpd (267 kLoC), SVF cannot finish in
a reasonable time and crashes after five-hour running. This result
shows the limited scalability of pointer analysis–based approaches.
Our technique, MLTA, is able to finish the analysis for the Linux
kernel (millions of lines of code) within four minutes. Therefore,
System Baseline
5-Layer
180K
Linux
7.78
8.7K
FreeBSD
3.49
Firefox
58K
1.82
Table 4: Breakdowns of target reduction by layers. Here we measure
icalls that support multi-layer type analysis, which cover most icalls.
2-Layer