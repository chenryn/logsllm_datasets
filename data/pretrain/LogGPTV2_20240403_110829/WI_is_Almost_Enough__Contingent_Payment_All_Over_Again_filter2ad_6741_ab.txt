as a countermeasure against their own attack (the seller performs
those checks before producing the proof). They first propose a full
check of consistency that results in S-ZK, but requires an expensive
computation. The proverâ€™s runtime so far is estimated to exceed
one hour in [18]. Alternatively, the authors suggested to perform a
minimal check, which in fact does not guarantee that the zkSNARK
in use is S-ZK, but only S-WI. However, also in [27], another attack
against the pay-to-sudoku system was presented, successful even
when the minimal checks by [18] are performed. This result shows
that zkSNARK with these checks is not S-WI and it even exacerbates
the situation by implying that there is no other way around to avoid
the full expensive checks over the crsâ€™ elements. With more than
one hour of estimated running time, the zkCP system using S-ZK
zkSNARK still leaves a lot of room for improvement.
1.1 Our contributions
Formal security definitions for contingent payment. We provide for-
mal security definitions for the properties that a contingent pay-
ment system must satisfy (see Section 3). More concretely, we define
a security game that models the soundness of the protocol: no ef-
ficiently computable seller should be able to receive the payment
without providing the buyer with the desired information (Figure 3).
Furthermore, we design a security game (that resembles the ZK
game) to model the fact that the buyer cannot learn any information
until the payment takes place (Figure 2).
To the best of our knowledge, these properties have not been
formalized in the literature before. (Although we acknowledge
the work by Campanelli et al. [18] for having provided informal
definitions for zero-knowledge contingent service payment.) As
a consequence, previous works contained incorrect statements or
proposed invalid repairs to existing security problems. Our for-
mal treatment of these notions allows us to give precise proofs of
security that make the constructions robust and reliable.
New WI security notion. We define a new security notion for proof
systems that we coin â€œtrapdoor subversion witness indistinguish-
ablilityâ€ (tS-WI). Roughly, it states that the scheme is witness in-
distinguishable even if the verifier chooses the crs and samples the
relation (possibly getting a trapdoor associated to it). For example,
consider the following relation:
ğ‘…ğ‘“ ,H((ğ‘, ğ‘¦), ğ‘Ÿ) â‡” {ğ‘“ (Decğ‘Ÿ (ğ‘)) âˆ§ ğ‘¦ = SHA(ğ‘Ÿ)} âˆ¨ ğ‘¦ = Hğœ…(ğ‘˜, ğ‘Ÿ) .
Trapdoor subversion witness indistinguishability for the above
relation (formally, it should be relative to a relation generator) would
state that the system is subversion witness indistinguishable even if
the distinguisher is given a trapdoor that allows them to efficiently
find preimages for H.
Formal security proof from tS-WI. In order to soften and amend the
criticism to [18] about S-WI not being enough for contingent pay-
ment, we show that our new notion of tS-WI is enough to achieve
secure contingent payment according to our formal definition (The-
orem 3.5). In particular, observe that the transformations of Fuchs-
bauerâ€™s attacks (both the attack against CP and the one against CSP)
do not preserve our tS-WI property.3
Interactive approach for zkCP. We consider our previous contribu-
tion of theoretical interest. However, even if tS-WI suffices for the
contingent payment protocol of Campanelli et al. [18] to be secure,
to the best of our knowledge, no S-WI constructions are known
that are significantly more efficient than full S-ZK schemes. Im-
plementing zkCP in this direction with SNARKs is still risky and
hard to be made efficient. We take on this issue and approach it
with an interactive protocol. Particularly, we replace SNARKs with
an interactive ZK proof system using garbled circuits and oblivious
transfer, as proposed in [35]. In addition, we take into account not
only arithmetic statements but also those of hybrid nature. More
specifically, let ğº be a group with generator ğ‘ƒ and let ğ´ âˆˆ ğº. Given
: {0, 1}ğ‘š â†’ {0, 1}ğ‘› and given com âˆˆ ğº, in
a boolean circuit ğ‘“
section 4, we propose a zero-knowledge proof system for:
PoK {(ğ‘ , ğ‘¥, ğ‘¡) : com = ğ‘  ğ´ + ğ‘¡ğ‘ƒ âˆ§ ğ‘“ (ğ‘¥) = ğ‘ } .
(2)
We also prove that our construction is indeed a zero-knowledge
proof of knowledge.
Implementation. Finally, we implement our construction of interac-
tive proof systems for zkCP from Section 4 and present the results
in Section 5. The experiments concern selling ECDSA and RSA
signatures on a contract. To do so, we design a method for proving
the knowledge of an ECDSA signature or an RSA signature by just
proving knowledge of a discrete logarithm (see Sections 5.1, 5.2).
1.2 Other related works
In [35], Jawurek et al. proposed an efficient, interactive ZK proof
system for statements that are expressed as boolean circuits. Their
work was motivated by the idea of Yaoâ€™s garbled circuits and it
provides active security while having complexity proportional to
the size of the circuit representing the relation verification function.
Moreover, this protocol does not require the common cut-and-
choose technique to provide active security, because the verifier
does not have any secret information to hide. The verifier just needs
to transmit one single garbled circuit, which implies a significant
efficiency gain for communication time. Taking into account the
recent advances in garbling schemes, e.g. the half-gate technique
in [46], and in oblivious transfer, e.g. an elegant idea of a simple OT
in [20] or the OT extension technique [4, 5], the protocol of [35]
could result in an even more optimistic performance.
When there are algebraic operations included in the relation, e.g.
group exponentiations, the idea of having a proof system for state-
ments that involves both arithmetic and algebraic computation has
inspired other works in this line, in particular the work by Chase
et al. [19]. Their work originated from the question of verifying
signatures on committed messages, which usually concerns a hash
value of messages and an (EC)DSA or RSA signature on it. The
authors proposed a method that took advantage from the approach
3An adversary (against WI) with the ability to invert H can choose values ğ‘ 0 and ğ‘ 1 such
that ğ‘“ (ğ‘ 0) = 0 and ğ‘“ (ğ‘ 1) = 1, then sample ğ‘Ÿ1 â†$ {0, 1}256, compute ğ‘¦ (cid:66) SHA(ğ‘Ÿ1)
and ğ‘Ÿ0 (cid:66) Hâˆ’1(ğ‘¦), calling its oracle on instance ğ‘¦ and witnesses (ğ‘ 0, ğ‘Ÿ0), (ğ‘ 1, ğ‘Ÿ1). If
the received proof leaks ğ‘“ (ğ‘ ), the adversary will realize which witness was used.
Session 2E: Smart Contracts and Cryptocurrencies CCS '20, November 9â€“13, 2020, Virtual Event, USA643in [35] to prove the non-algebraic part, and link it with sigma pro-
tocols [22] for proving the algebraic one. Additionally, their results
showed the possibility to obtain an efficient proof of knowledge
of signatures on a committed message using DSA, ECDSA, and
RSA signature schemes. We observe that our protocols for proving
knowledge of ECDSA and RSA signatures are simpler, because we
are assuming that the message is public (a natural assumption in
the application of signing a contract), whereas their model can
provide privacy on the message. Furthermore, in the case of ECDSA
signature, we are assuming that the seller is the owner of the secret
key or, in other words, the signature (ğ‘Ÿ, ğ‘ ) is freshly generated (and
so the first half, ğ‘Ÿ, can be sent in the clear).
Prior to our work, there was already an attempt by Banasik et
al. [6] that replaces the generic non-interactive ZK building block
by an interactive ZK protocol in the construction of a ZKCP sys-
tem. Their protocol does not use hash-locked transactions but only
standard transactions, which are preferably shorter and less error-
prone. At the same time, it employs the cut-and-choose technique
together with timed commitment to avoid expensive generic ZK
schemes. However, it is vulnerable to the so-called mauling attacks:
an adversary can â€œmaulâ€ a valid transaction in the ledger and output
an equivalent but invalid transaction, e.g., one with the same input
and output and of the same amount, but whose hash identifier is
different from the original one. The authors of [6] were aware of
this attack and pointed out that in some scenarios this attack may
be an issue because many Bitcoin clients cannot handle transactions
whose hash identifiers are different from what was posted in the
ledger. In an attempt to resolve this issue, the authors propose a fix
which prevents the mauling attack that exploits the malleability of
ECDSA signatures. However, their improved construction is still
vulnerable to mauling by changing the script, as mentioned in [18].
Hence, for CP systems that are implemented using the method
in [6], a mauling attack can still be mounted to make the transac-
tions unredeemable and lead to problems when creating Bitcoin
contracts, see [1, 2].
Speaking of subversion resistance for SNARKs, Ben-Sasson et
al. [11] provided a generic multi-party protocol for constructing the
crs, where only if all parties collude will they be able to reproduce
the trapdoor, or in other words, â€œcheatâ€. Motivated by this work,
Bowe et al. [15] proposed an efficient and simpler way to achieve
the same goal. More interestingly, the protocol in [15] provides
statistical zero-knowledge even in the case where all players are
malicious. These interactive methods indeed cast a light on possi-
ble solutions for the challenge of subverted crs and the systems
susceptible to it.
2 PRELIMINARIES
For a finite set ğ‘†, we write ğ‘ â†$ ğ‘† to denote that ğ‘ is uniformly
sampled from ğ‘†. We denote the security parameter by ğœ… âˆˆ N. Given
two functions ğ‘“ , ğ‘” : N â†’ [0, 1], we write ğ‘“ â‰ˆ ğ‘” if the difference
|ğ‘“ (ğœ…) âˆ’ ğ‘”(ğœ…)| is asymptotically smaller than the inverse of any
polynomial in ğœ…. A function ğ‘“ is said to be negligible if ğ‘“ â‰ˆ 0,
whereas it is said to be overwhelming when ğ‘“ â‰ˆ 1. For integers
ğ‘š, ğ‘› âˆˆ N, we denote by [ğ‘š, ğ‘›] the range {ğ‘š, . . . , ğ‘›} and by [ğ‘›] the
range [1, ğ‘›]. We denote by Zğ‘› the set of integers modulo ğ‘› and
denote by =ğ‘› equality modulo ğ‘›. Given a string or an integer ğ‘ , we
denote by |ğ‘ | the length of its binary representation. For a bit-string
ğ‘  âˆˆ {0, 1}ğ‘›, when it is clear from the context, we abuse notation and
refer to ğ‘  as the integer that it represents in binary (in big-endian).
We use additive notation for groups. Given a cyclic group ğº of order
ğ‘ with generator ğ‘ƒ, and given ğ‘ âˆˆ Zğ‘, we use(cid:74)ğ‘(cid:75) to denote the
For a cryptographic scheme Î  with security notion sec and
Î ,A(ğœ…), we define:
implicit representation ğ‘ğ‘ƒ of ğ‘ in ğº, following [24].
advantage function (of an adversary A), Advsec
(cid:110)
Î ,A(ğœ…)(cid:111) .
Advsec
Î  (ğœ…) (cid:66) max
ppt A
Advsec
We explicitly write the state associated to stateful adversaries,
usually denoted by ğœ. Given two distributions ğ·1 and ğ·2, we write
ğ·1 â‰¡ ğ·2 if they are identical and ğ·1 â‰ˆ ğ·2 if they are computation-
ally indistinguishable.
2.1 Zero-knowledge proof systems
A zero-knowledge (ZK) proof system [31] is a two party protocol
executed between a prover and a verifier that allows the prover
to convince the verifier about the validity of certain statement,
without revealing any other information, e.g., why the statement
is true. More formally, given a binary relation ğ‘… : X Ã— W â†’
{0, 1}, defined over a set of statements X and a set of witnesses
W, let ğ¿ğ‘… be the language defined as ğ¿ğ‘… (cid:66) {ğ‘¥ âˆˆ X | âˆƒğ‘¤ âˆˆ W :
ğ‘…(ğ‘¥, ğ‘¤) = 1}. A zero-knowledge proof system allows a prover in
possession of (ğ‘¥, ğ‘¤) âˆˆ ğ‘… to convince a verifier of the fact that ğ‘¥ âˆˆ ğ¿ğ‘…
without revealing any information about ğ‘¤. Non-interactive ZK
proof systems [13] are a version of ZK proof systems where the
prover sends one single message to the verifier.
Definition 2.1 (Non-Interactive Argument System). A non-interac-
tive argument system (NIZK) for relation ğ‘… is a triple of polynomial-
time algorithms Î  = (CrsGen, Prove, Verify) where:
â€¢ CrsGen(1ğœ…) â†’ crs is a probabilistic algorithm that takes a
security parameter and generates a common reference string.
â€¢ Prove(crs, ğ‘¥, ğ‘¤) â†’ ğœ‹ is a probabilistic algorithm that on input
a crs, an instance ğ‘¥ and a witness ğ‘¤, outputs a proof ğœ‹.
â€¢ Verify(crs, ğ‘¥, ğœ‹) â†’ 0/1 is a deterministic algorithm that on input
a crs, an instance ğ‘¥ and a proof ğœ‹, outputs a bit representing
acceptance (1) or rejection (0).
A NIZK system is complete if for all (ğ‘¥, ğ‘¤) âˆˆ ğ‘… and all ğœ… âˆˆ N,
crs â† CrsGen(1ğœ…), it holds Verify(crs, ğ‘¥, Prove(crs, ğ‘¥, ğ‘¤)) = 1. A
NIZK argument system is said to have the zero-knowledge property
if there exists a simulator that, without any witness (but possibly
some useful piece of information like a trapdoor, or the ability of
rewinding), can produce proofs that look indistinguishable from
proofs produced by an honest prover in possession of a valid wit-
ness. A NIZK argument system is knowledge-sound if there exists a
negligible function ğœ–ks and there exists a polynomial-time extractor
E such that for any ppt adversary A,
Following the notation introduced by Camenisch and Stadler
in [17], we denote a ZK proof of knowledge of secret ğ‘¤ satisfying
ğ‘…(ğ‘¥, ğ‘¤) for some public ğ‘… and ğ‘¥ as PoK{(ğ‘¤) : ğ‘…(ğ‘¥, ğ‘¤) = 1}.
 crs â† CrsGen(1ğœ…)
(ğ‘¥, ğœ‹) â† A(crs)