scenarios where we expect sufﬁcient instances for this attack to
be practical, it is necessary to rate limit the number of ledger
posts included in a given block that the enclave will accept
results from.
Ethereum and Smart Contract Systems. A very natural
realization of our ledger system is a smart contract systems
such as Ethereum [47], [6]. Smart contract systems enable
distributed public computation on the blockchain. Typically, a
program is posted to some speciﬁc address on the blockchain.
When a user submits a transaction to the associated address,
the code is executed and appropriate state is updated. As noted
11
Computation Section
Bitcoin Operations
Proof Preparation
Proof Veriﬁcation
Protocol Operations
Ciphertext Decryption
Javascript Invocation
Ciphertext Encryption
SGX Overhead
Enclave Initialization
Ecall Entry and Exit
Running Time
Percentage
7764 µs
7094 µs
550 µs
2006 µs
4 µs
1920 µs
82 µs
1153348 µs
1153308 µs
40 µs
100%
92.8%
7.2%
100%
0.2%
95.7%
4.0%
100%
100.0%
0.0%
Fig. 3. Measured computation overhead for different elements of our ELI
experiment using a simple string concatenation program P . Because SGX does
not support internal time calls, these times were measured by the application
code. The table above shows averaged results over 100 runs on a local Bitcoin
regtest network
previously, our system allows for smart contracts with private
data, which is impossible on current implementations of smart
contract system.
Private Blockchains. Many recent systems such as Hyper-
ledger [31] implement private smart contracts by constructing
a shared blockchain among a set of dedicated nodes. In some
instantiations, the parties forgo the use of proof-of-work in fa-
vor of using digital signatures and trusted hardware to identify
the party who writes the next block [33]. Private blockchains
represent a compromise between centralized systems such
as CT and proof-of-work blockchains. They are able to use
digital signatures to produce ledger authentication tags so the
security is not economic in nature. Moreover, the ledger can be
constructed to provide efﬁcient rules for ledger state updates,
which enables an efﬁcient realization of our model of §II-B.
VI. PROTOTYPE IMPLEMENTATION
To validate our approach we implemented our ELI con-
struction using Intel SGX [5], [45], [34], [10], [15], [53],
[32]to implement the enclave and the Bitcoin blockchain to
implement the ledger. We embedded a lightweight Javascript
engine called Duktape [4] into our enclave, as similar projects
have done in the past [46]. Source code can be found at
https://github.com/JHU-ARC/state for the stateless/.
The host application communicates with a local Bitcoin
node via RPC to receive blockchain (ledger) fragments for de-
livery to the enclave, and to sends transaction when requested
by the enclave. The enclave requires an independent (partial)
Bitcoin implementation to verify proof-of-work tags used as
ledger authenticators. We based this on the C++ SGX-Bitcoin
implementation in the Obscuro project [60].
At startup, the host application loads the Javascript program
from a ﬁle, initializes the protocol values as in Algorithms 1,
2 and 3. and launches the SGX enclave. At ﬁrst initialization
the enclave generates a random, long term, master key K,
which can be sealed to the processor using SGX’s data
sealing interface, protecting the key from power ﬂuctuations.
In each iteration of the protocol, the untrusted application code
prompts the user for the next desired input. It then generates
a transaction T using bitcoin-tx RPC. The ﬁrst “input”
T.vin[0] is set to be an unspent transaction in the local wallet.
The ﬁrst “output” T.vout[0] spends the majority of the input
12
transaction to a new address belonging to the local wallet. The
second output T.vout[1] embeds SHA256(i(cid:107)Ii(cid:107)Si(cid:107)P(cid:107)CID(cid:107)ri)
in an OP_RETURN script. The third output T.vout[2] embeds
the public output Pub emitted by the previous step. This
transaction is signed by a secret key in the local wallet and
submitted for conﬁrmation.
The host application now monitors the blockchain until
T has been conﬁrmed by 6 blocks.15 The host then sets (1)
posti.Data ← T.vout, (2) posti.PrevHash ← T.vin[0].Hash,
(3) posti.CID ← chain of transactions from T back to the
transaction with hash post0.PrevHash, (4) posti.Hash ←
T.Hash, and (5) σi ← 6 blocks conﬁrming T .
The host then submits (posti, σi) to the enclave which then
performs the following checks: (1) veriﬁes that σi is valid and
has sufﬁciently high block difﬁculty (2) the blocks in σi are
consecutive (3) T.vout[0], T.vout[1] embed the correct data
and (4) the transactions in posti.CID are well formatted.
If i = 0 and there is no input state, the enclave generates
a zero initial state. Otherwise it generates the decryption key
as described in the protocol using C-MAC to implement the
PRF. The state along with the inputs and random coins are
passed to the Javascript interpreter. All hashes computed in
the enclave are computed using SHA256. One note is that
instead of hashing all of CID into the ciphertext, we include
only post0.PrevHash, which keeps CID constant throughout
the rounds.
Implementation Limitations. We chose to use Intel SGX to
implement our enclave because it is a widely accepted, secure
execution environment. However, SGX is signiﬁcantly more
powerful than the enclaves we model, including access to
trusted time and monotonic counters. Although we use SGX,
we do not leverage any of these additional features to make
sure our implementation matches our model. Our Bitcoin
implementation of the ledger is slow and would likely not
be suitable for production release. Finally, we implement our
applications in Javascript so the Javascript virtual machine will
insulate the enclave code from host tampering.
Measurements. To avoid spending signiﬁcant money on the
Bitcoin main network, we tested our implementation on a
private regression regtest. This also allows us to control the
rate at which blocks are mined. The most time-consuming
portion of an implementation using the mainnet or testnet
is waiting for blocks to be conﬁrmed; blocks on the main
bitcoin network take an average of 10 minutes to be mined, or
an average of 70 minutes to mine a block and its 6 conﬁrmation
blocks. If an application requires faster execution, alternative
blockchains can be used, such as Litecoin (2.5 minutes per
block) or Ethereum (approximately 10-19 seconds).
Our experiments used a simple string concatenation pro-
gram P . For our experiments we measured three speciﬁc
operations: (1) the execution time of the Bitcoin operations
(on the host, enclave and regtest network, (2) ELI protocol
execution time, (3) the time overhead imposed by Intel SGX
operations. Figure 3 shows the running times of these parts
of our implementation. It is worth noting that SGX does not
15In general, six blocks is considered sufﬁciently safe for normal Bitcoin
payment operations; however the number of conﬁrmations blocks can be
tweaked as an implementation parameter.
provide access to a time interface, and there is no way for
an SGX enclave to get trustworthy time from the operating
system. The times in Figure 3 were measured from the
application code.
Discussion. Note that initializing an SGX enclave is a one-
time cost that must be paid when the enclave is ﬁrst loaded into
memory. It is a comparatively expensive operation because the
SGX driver must verify the code integrity and perform other
bookkeeping operations. An additional computationally expen-
sive operation is obtaining the proof-of-publication to be deliv-
ered to the enclave. This process relies on bitcoin-cli to
retrieve the proper blocks, which can be slow depending on the
status of the bitcoind daemon. We note that these tests were
run using the regression blockchain regtest, and retrieving
blocks from testnet or mainnet may produce different results.
VII. CONCLUSION
In this work we considered the problem of constructing
secure stateful computation from limited computing devices.
This work leaves several open questions. First, while we
discussed the possibility of using cryptographic obfuscation
schemes to construct the enclave, we did not evaluate the
speciﬁc assumptions and capabilities of such a system. Addi-
tionally, there may be other capabilities that the enclave-ledger
combination can provide that are not realized by this work.
Finally, while we discussed a number of applications of the
ELI primitive, we believe that there may be many other uses
for these systems. ACKNOWLEDGMENTS
This work was supported in part by: the National Science
Foundation under awards CNS-1653110 and CNS-1801479.
REFERENCES
[1]
[2]
[3]
[4]
[5]
[6]
[7]
2016.
[Online].
transparency,”
https://namecoin.org/, November
“Namecoin,”
Available: https://namecoin.org/
“Bitcoin wiki: Script,” Available at https://en.bitcoin.it/wiki/Script,
2018.
“Certiﬁcate
certiﬁcate-transparency.org, 2018.
“Duktape.org,” Available at http://duktape.org, 2018.
“Intel Software Guard Extensions (Intel SGX),” https://software.intel.
com/en-us/sgx, 2018.
“The Ethereum Project,” https://www.ethereum.org/, 2018.
“TPM Reset Attack,” Available
∼pkilab/sparks/, 2018.
at http://www.cs.dartmouth.edu/
https://www.
Available
at
[8] Advanced Microchip Devices, Available at https://developer.amd.com/
sev/, 2018.
[9] Amazon, “AWS Step Functions,” Available at https://aws.amazon.com/
[10]
step-functions/, 2018.
I. Anati, S. Gueron, S. Johnson, and V. Scarlata, “Innovative technology
for CPU based Attestation and Sealing,” in Proceedings of the 2nd
International Workshop on Hardware and Architectural Support for
Security and Privacy, vol. 13, 2013.
[11] Android Project, “File-based encryption for android,” Available at https:
//source.android.com/security/encryption/ﬁle-based, 2017.
[12] Apple Computer, “iOS Security: iOS 9.3 or later,” Available at https:
//www.apple.com/business/docs/iOS Security Guide.pdf, May 2016.
[13] ——, “Answers to your questions about Apple and security,” Available
at http://www.apple.com/customer-letter/answers/, 2017.
[14] ARM Consortium, “ARM Trustzone,” Available at https://www.arm.
com/products/security-on-arm/trustzone, 2017.
[15] A. B, “Introduction to Intel SGX Sealing,” Available at https://software.
intel.com/en-us/blogs/2016/05/04/introduction-to-intel-sgx-sealing,
2016.
13
[16] B. Barak, O. Goldreich, R. Impagliazzo, S. Rudich, A. Sahai, S. Vad-
han, and K. Yang, “On the (im)possibility of obfuscating programs,”
Cryptology ePrint Archive, Report 2001/069, 2001, http://eprint.iacr.
org/2001/069.
reset
secure
against
attacks,”
[17] M. Bellare, M. Fischlin, S. Goldwasser, and S. Micali, “Identiﬁcation
in EUROCRYPT ’01,
protocols
B. Pﬁtzmann, Ed. Berlin, Heidelberg: Springer Berlin Heidelberg,
2001, pp. 495–511.
[Online]. Available: https://doi.org/10.1007/
3-540-44987-6 30
J. Bonneau, “The science of guessing: Analyzing an anonymized
corpus of 70 million passwords,” in IEEE S&P (Oakland) ’12, ser.
SP ’12. Washington, DC, USA: IEEE Computer Society, 2012, pp.
538–552. [Online]. Available: http://dx.doi.org/10.1109/SP.2012.49
[18]
[19] M. Bowman, A. Miele, M. Steiner, and B. Vavala, “Private Data
Objects: an Overview,” ArXiv e-prints, Jul. 2018.
[20] R. Canetti, O. Goldreich, S. Goldwasser, and S. Micali, “Resettable
zero-knowledge (extended abstract),” in Proceedings of
the Thirty-
second Annual ACM Symposium on Theory of Computing, ser. STOC
’00. New York, NY, USA: ACM, 2000, pp. 235–244. [Online].
Available: http://doi.acm.org/10.1145/335305.335334
[21] R. Cheng, F. Zhang, J. Kos, W. He, N. Hynes, N. M. Johnson,
A.
Juels, A. Miller, and D. Song, “Ekiden: A platform for
conﬁdentiality-preserving, trustworthy, and performant smart contract
execution,” CoRR, vol. abs/1804.05141, 2018. [Online]. Available:
http://arxiv.org/abs/1804.05141
[22] A. R. Choudhuri, M. Green, A. Jain, G. Kaptchuk, and I. Miers,
“Fairness in an unfair world: Fair multiparty computation from public
bulletin boards,” in CCS ’17, 2017, https://eprint.iacr.org/2017/1091.
[23] N. D¨ottling, T. Mie, J. M¨uller-Quade, and T. Nilges, “Basing obfus-
cation on simple tamper-proof hardware assumptions,” in TCC ’11.
Springer, 2011.
[24] Ethereum White Paper, “Ethereum white paper,” Available at https://
github.com/ethereum/wiki/wiki/White-Paper, 2017.
[25] A. Foundation, “Hadoop Key Management Server (KMS) - Doc-
umentation Sets,” Available at https://hadoop.apache.org/docs/stable/
hadoop-kms/index.html, 2018.
[26] S. Garg, C. Gentry, S. Halevi, M. Raykova, A. Sahai, and B. Waters,
“Candidate indistinguishability obfuscation and functional encryption
for all circuits,” Cryptology ePrint Archive, Report 2013/451, 2013,
http://eprint.iacr.org/2013/451.
[27] B. Giller, “Implementing Practical Electrical Glitching Attacks,” in
BlackHat ’15, 2015.
[28] Google Inc., “Google Cloud Functions,” Available at https://cloud.
google.com/functions/, 2018.
[29] R. Goyal and V. Goyal, “Overcoming cryptographic impossibility
results using blockchains,” Cryptology ePrint Archive, Report 2017/935,
2017, https://eprint.iacr.org/2017/935.
[30] Handshake, “Handshake protocol,” Available at https://handshake.org/,
2018.
[31] Hyperledger,
“Hyperledger Architecture, Volume
1,” Available
https://www.hyperledger.org/wp-content/uploads/2017/08/
at
Hyperledger Arch WG Paper 1 Consensus.pdf, 2017.
Intel Corporation, “Product Licensing FAQ,” Available at https://
software.intel.com/en-us/sgx/product-license-faq, 2016.
[32]
[33] ——, “Hyperledger Sawtooth,” Available at http://hyperledger.org/
projects/sawtooth, 2018.
[34] S. Johnson, V. Scarlata, C. Rozas, E. Brickell, and F. Mckeen, “Intel
Software Guard Extensions: EPID Provisioning and Attestation Ser-
vices,” 2016.
[35] A. Juels, A. Kosba, and E. Shi, “The Ring of Gyges: Investigating the
future of criminal smart contracts,” in Proceedings of the 2016 ACM
SIGSAC Conference on Computer and Communications Security, ser.
CCS ’16. New York, NY, USA: ACM, 2016, pp. 283–295. [Online].
Available: http://doi.acm.org/10.1145/2976749.2978362
[36] M. Kan,
you
“Paying
the WannaCry
nothing. Here’s why.”
probably
avail-
https://www.pcworld.com/article/3196880/security/