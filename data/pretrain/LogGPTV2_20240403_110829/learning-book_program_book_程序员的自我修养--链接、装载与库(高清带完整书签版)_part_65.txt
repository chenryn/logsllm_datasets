程序员的自我修养一链接、装载与库
---
## Page 374
11.3运行库与多线程
351
多线程运行库
现有版本的C/C++标准（特指C++03、C89、C99）对多线程可以说只字不提，因此相
应的C/C++运行库也无法针对线程提供什么帮助，也就是说在运行库里不能找到关于创建、
结束、同步线程的函数。对于C/C++标准库来说，线程相关的部分是不属于标准库的内容的，
它跟网络、图形图像等一样，属于标准阵之外的系统相关库。由于多线程在现代的程序设计
中占据非常重要的地位，主流的C运行库在设计时都会考虑到多线程相关的内容。这里我
们所说的“多线程相关”主要有两个方面，一方面是提供那些多线程操作的接口，比如创建
线程、退出线程、设置线程优先级等函数接口：另外一方面是C运行库本身要能够在多线
程的环境下正确运行。
对于第·方面，主流的 CRT都会有相应的功能。比如Windows下，MSVC CRT提供了
诸如_beginthreadO、_endthread(等函数用于线程的创建和退出：而 Linux下，glibc 也提供
了一个可选的线程库pthread（POSIX Thrcad），它提供了诸如 pthread_create(、pthread_exit()
等函数用于线程的创建和退出。很明显，这些函数都不属于标准的运行库，它们都是平台相
关的。
对于第二个方面，C语言运行库必须支持多线程的环境，这是什么意思呢？实际上，最
初CRT在设计的时候是没有考虑多线程环境的，因为当时根本没有多线程这样的概念。到
后来多线程在程序中越来越普及，C/C++运行库在多线程环境下吃了不少苦头。例如：
（1）ermo：在C标准库里，大多数错误代码是在函数返回之前赋值在名为ermmo的全
局变量里的。多线程并发的时候，有可能A线程的ermo的值在获取之前就被B线程给覆盖
掉，从而获得错误的出错信息。
（2）strtok(）等函数都会使用函数内部的局部静态变量来存储字符串的位置，不同的线
程调用这个函数将会把它内部的局部静态变量弄混乱。
（3）malloc/new与free/delete：堆分配/释放函数或关键字在不加锁的情况下是线程不
安全的。由于这些函数或关键字的调用十分频繁，因此在保证线程安全的时候显得十分繁琐。
（4）异常处理：在早期的C++运行库里，不同的线程抛出的异常会被此冲突，从而造
成信息丢失的情况。
（5）printf/lprintr及其他1O函数：流输出函数同样是线程不安全的，因为它们共享了
同一个控制台或文件输出。不同的输出并发时，信息会混杂在一起。
（6）其他线程不安全函数：包括与信号相关的些函数。
通常情况下，C标准库中在不进行线程安全保护的情况下白然地其有线程安全的属性的
函数有（不考虑ermo的因素）：
程序员的自我修养一链接、装载与库
---
## Page 375
352
第11章运行库
（1）字符处理（ctype.h），包括isdigit、toupper等，这些函数同时还是可重入的。
（2）字符串处理函数（string.h），包括 strlen、strcmp等，但其中涉及对参数中的数组
进行写入的函数（如 strcpy）仅在参数中的数组各不相同时可以并发。
（3）数学函数（math.h），包括sin、pow等，这些函数同时还是可重入的。
（4）字符串转整数/浮点数（stdlib.h），包括 atof、atoi、atol、strtod、strtol、strtoul。
（5）获取环境变量（stdlib.h），包括getenv，这个函数同时还是可重入的。
（6）变长数组辅助函数（stdarg.h）。
（7）非局部跳转函数（setjmp.h），包括 sejmp 和 longjmp，前提是longjmp 仅跳转到本
线程设置的 jmpbuf .上。
为了解决C标准库在多线程环境下的容追处境，许多编译器附带了多线程版本的运行
库。在MSVC中，可以用/MT或/MTd等参数指定使用多线程运行库。
11.3.2CRT改进
使用TLS
多线程运行库具有什么样的改进呢？首先，ermo必须成为各个线程的私有成员。在glibc
中，ermo被定义为一个宏，如下：
#define errno (*_errno_location (1)
函数_ermo_location在不同的库版本下有不同的定义，在单线程版本中，它仅直接返回了
全局变量ermo 的地址。面在多线程版本中，不同线程调用_ermo_location返回的地址则各
不相同。在MSVC中，ermo同样是一个宏，其实现方式和glibc类似。
加锁
在多线程版本的运行库中，线程不安全的函数内部都会自动地进行加锁，包括malloc、
printf 等，而异常处理的错误也早早就解决了。因此使用多线程版本的运行库时，即使在
malloc/new前后不进行加锁，也不会出现并发冲突。
改进函数调用方式
C语言的运行库为了支持多线程特性，必须做出一些改进。一种改进的办法就是修改所
有的线程不安全的函数的参数列表，改成某种线程安全的版本。比如MSVC的CRT就提供
了线程安全版本的 strtokO函数：strtok_s，它们的原型如下：
char *strtok_s( char *strToken, const char *strDelimit, char **context):
char *strtok(char *strToken, const char *strDelimit ):
程序贝的自我修养一链接、装载与库
---
## Page 376
11.3运行库与多线程
353
改进后的 strtok_s增加了一个参数，这个参数context是由调用者提供一个char*指针，
sttok_s将每次调用后的字符串位置保存在这个指针中。面之前版本的strntok函数会将这个
位置保存在一个函数内部的静态局部变量中，如果有多个线程同时调用这个函数，有可能出
现冲突。与MSVC CRT类似，Glibc也提供了一个线程安全版本的 strokO叫做 strok_r0。
但是很多时候改变标准库函数的做法是不可行的，标准库之所以称之为“标准”，就是
它具有一定的权威性和稳定性，不能随意更改。如果随意更改，那么所有遵循该标准的程序
都需要重新进行修改，这个“标准”是不是值得遵循就有待商了。所以更好的做法是不改
变任何标准库函数的原型，只是对标准库的实现进行一些改进，使得它能够在多线程的环境
下也能够顺利运行，做到向后兼容。
11.3.3线程局部存储实现
很多时候，开发者在编写多线程程序的时候都希望存储一些线程私有的数据。我们知道。
属于每个线程私有的数据包括线程的栈和当前的寄存器，但是这两种存储都是非常不可靠
的，栈会在每个函数退出和进入的时候被改变：面寄存器更是少得可怜，我们不可能拿寄存
器去存储所需要的数据。假设我们要在线程中使用一个全局变量，但希望这个全局变量是线
程私有的，面不是所有线程共享的，该怎么办呢？这时候就须要用到线程局部存储（TLS，
ThreadLocal Storage）这个机制了。TLS的用法很简单，如果要定义一个全局变量为TLS
类型的，只需要在它定义前加上相应的关键字即可。对于GCC来说，这个关键字就是
_thread，比如我们定义一个TLS 的全局整型变量；
_thread int number;
对于MSVC来说，相应的关键字为_declspec(thread)：
_declspec (thread) int number;
注
在WindowsVista和2008之前的操作系统，如果TLS的全局变量被定义在一个DLL中，
意
并且该DLL是使用LoadLibrary0显式装载的，那么该全局变量将无法使用，如果访问该
全局变量将会导致程序发生保护错误。导数这个情况的主要原因是在WindowsVista之
前的操作系统下，DLL在使用LoadLibraryo装载时无法正确初始化由_declspec(thread)
定义的变量，具体请参照MSDN。
一旦一个全局变量被定义成TLS类型的，那么每个线程都会拥有这个变量的一个副本，
任何线程对该变量的修改都不会影响其他线程中该变量的副本。
Windows TLS 的实现
对于Windows系统来说，正常情况下一个全局变量或静态变量会被放到”.data”或".bss”
段中，但当我们使用_declspec（thread）定义一个线程私有变量的时候，编译器会把这些变量
程序员的自我修养一链接、装载与库
---
## Page 377
354
第11章运行库
放到PE文件的“.ls”段中。当系统启动一个新的线程时，它会从进程的堆中分配一块足够
大小的空间，然后把“.ls”段中的内容复制到这块空间中，于是每个线程都有自己独立的
一个“ls”副本。所以对于用_declspec（thread）定义的网个变量，它们在不同线程中的地
址都是不一样的。
我们知道对于一个TLS变量来说，它有可能是一个C++的全局对象，那么每个线程在
启动时不仅仅是复制“Ils”的内容那么简单，还需要把这些TLS对象初始化，必须逐个地
调用它们的全局构造函数，而且当线程退出时，还要逐个地将它们析构，正如普通的全局对
象在进程启动和退出时都要构造、析构一样。
WindowsPE文件的结构中有个叫数据目录的结构，我们在第2部分已经介绍过了。它
总共有16个元素，其中有一元素下标为IMAGE_DIRECT_ENTRY_TLS，这个元素中保存
的地址和长度就是TLS表（IMAGE_TLS_DIRECTORY结构）的地址和长度。TLS表中保
存了所有TLS变量的构造函数和析构函数的地址，Windows系统就是根据TLS表中的内容，
在每次线程启动或退出时对TLS变量进行构造和析构。TLS表本身往往位于PE文件的
“rdata”段中。
另外一个问题是，既然同一个TLS变量对于每个线程来说它们的地址都不一样，那么
线程是如何访问这些变量的呢？其实对于每个Windows线程来说，系统都会建立一个关于
线程信息的结构，叫做线程环境块（TEB.ThreadEnvironmentBlock）。这个结构里面保
存的是线程的堆栈地址、线程ID等相关信息，其中有一个域是一个TLS数组，它在TEB
中的偏移是0x2C。对于每个线程米说，x86的FS段寄存器所指的段就是该线程的TEB，于
是要得到一个线程的TLS数组的地址就可以通过FS:[0x2C]访问到。
注
TEB这个结构不是公开的，它可能随着Windows版本的变化而变化，我们这里所说的
意
TEB结构都是指在xB6版的WindowsXP。
这个TLS数组对于每个线程来说大小是固定的，一般有64个元素。而TLS数组的第一
个元素就是指向该线程的“.ls”副本的地址。于是要得到一个TLS的变量地址的步骤为：
首先通过FS:[Ox2C]得到TLS数组的地址，然后根据TLS数组的地址得到“.Ils”副本的地
址，然后加上变量在“.ls”段中的偏移即该TLS变量在线程中的地址。下面看一个简单的
例子：
_declspec(thread) int t = 1;
int maln()
t = 2:
return 0:
程序员的自我修养一链接、装载与库
---
## Page 378
11.3运行库与多线程
355
经过编译以后，这段代码的汇编实现如下：
_main:
00000000: 55
push
ebp
00000003:A1 00 00 00 00
00000001: 8B EC
noV
mov
eax,dword ptr [t1s_index]
ebp, esp
00000008: 64 88 0D 00 00 00 mov
ecx,dword ptr fs: [_tls_array]
0000000F: 8B 14 81
00
mov
edx, dword ptr [ecx+eax*4]
00000012: C7 82 00 00 00 00 mov
02 00 00 00
dword ptr _t[edx], 2
000010000000
pop
xor
0000001E: 5D
ebp
eax, eax
0000001F: C3
代码中有两个符号_ls_index和_uls_aray，它们被定义在MSVC CRT中，对于MSVC
2008来说，它们的值分别是0和0x2C，分别表示TLS数组下的第一个元素和TLS数组在
TEB中的偏移。由于这两个数值有可能随着Windows系统的变化而变化，所以它们被保存
在CRT中，如果程序以DLL方式链接，那么在不同版本的Windows平台上运行就不会有
问题：如果是静态链接，那么当新版的Windows更改TEB结构时而导致TLS数组在TEB
中的偏移改变，程序运行就可能出错，当然出于Windows多年来的“良好表现”，这种随意
更改核心数据结构的事情发生的可能性还是比较小的。
显式TLS
前面提到的使用_thread或_declspec(thread)关键字定义全局变量为TLS变量的方法往
往被称为隐式TLS，即程序员无须关心TLS变最的申请、分配赋值和释放，编译器、运行
库还有操作系统已经将这一切销俏处理要当了。在程序员看来，TLS全局变量就是线程私有
的全局变量。相对于隐式TLS，还有一种叫做显式TLS的方法，这种方法是程序员须要手
工申请TLS变量，并且每次访问该变量时都要调用相应的函数得到变量的地址，并且在访
问完成之后需要释放该变量。在Windows平台上，系统提供了TlsAllocO、TlsGetValue(、
TlsSetValue()和TlsFree()这4个API函数用于显式TLS变量的申请、取值、赋值和释放；Linux
下相对应的库函数为pthread库中的pthread_key_create()、pthread_getspecific(、
pthread_setspecific()fl pthread_key_delete()。
显式的TLS实现其实非常简单，我们前面提到过TEB结构中有个TLS数组，实际上显
式的TLS就是使用这个数组保存TLS数据的。由于TLS数组的元素数量固定，一般是64
个，于是显式TLS在实现时如果发现该数组已经被使用完了，就会额外申请4096个字节作
为二级TLS 数组，使得在WindowsXP下最多能拥有1088（1024+64）个显式TLS变量（当
然隐式的TLS也会占用TLS数组）。相对于隐式的TLS变量，显式的TLS变量的使用十分
麻烦，而且有诸多限制，显式TLS的诸多缺点已经使得它越来越不受欢迎了，我们并不推
荐使用它。
程序员的自我修养一链接、装载与库
---
## Page 379
356
第11章运行库
Q&A: CreateThread()和_beginthread()有什么不同]
我们知道在Windows下创建一个线程的方法有两种，一种就是调用Windows API
CreateThreadO来创建线程；另外一种就是调用MSVCCRT的函数_beginthread()或
_beginthreadex()来创建线程。相应的退出线程也有两个函数Windows API 的ExirThread()
和CRT的_endthread(。这两豪函数都是用来创建和退出线程的，它们有什么区别呢？
很多开发者不清楚这两者之间的关系，他们随意选一个函数来用，发现也没有什么大
问题，于是就忙于解决更为紧追的任务去了，而没有对它们进行深究。等到有一天忽
然发现一个程序运行时间很长的时候会有细微的内存泄露，开发者绝对不会想到是因
为这两套函数用混的结果。
根据Windows API 和 MSVC CRT 的关系，可以看出来_beginthread(O是对 CreateThread()
的包装，它最终还是调用CreateThrcad(来创建线程。那么在_beginthread()调用
CreateThread0之前做了什么呢？载们可以看一下_beginthreadO的源代码，它位于CRT源
代码中的 thread.c。我们可以发现它在调用CreateThread()之前申请了一个叫_tiddata的结
构，然后将这个结构用_initptd(）函数初始化之后传递给_beginthread0自己的线程入口函
数_threadstart。_threadstarn 首先把由_beginthreadO传过来的_iddata 结构指针保存到线程
的显式TLS数组，然后它调用用户的线程入口真正开始线程。在用户线程结束之后，
_thrcadstart()函数调用_endthread()结来线程。并且_threadstarn 还用_try/_except 将用户
线程入口函数包起未，用于捕获所有未处理的信号，并且将这些信号交给CRT处理。
所以除了信号之外，很明显CRT包装WindowsAPI线程接口的最主要目的就是郡个
_tiddata。这个线程私有的结构里面保存的是什么呢？我们可以从mtdll.h中找到它的定
义，它里面保存的是诸如线程ID、线程句柄、erron、strtok(）的前一次调用位置、rand(）
函数的种子、并需处理等与CRT有关的而且是线程私有的信息。可见MSVCCRT并
没有使用我们前面所说的_declspec（thread）这种方式来定义线程私有变量，从而防止库
函数在多线程下失效，而是采用在堆上申请一个_tiddata结构，把线程私有变量救在结
构内部，由显式TLS 保存_tiddata 的指针。
了解了这些信总以后，我的应该会想到一个同越，部就是如来我们用CreateIhread()创
建一个线程然后调用CRT的 strtok()函数，按理说应该会出错，因为strtok(所需要的
_tiddata并不存在，可是我们好像从来没碰到过这祥的问题。查看strtoki函数就会发现，
当一开始调用_gelptd0去得到线程的_tiddata结构时，这个函数如果发现线程没有申请
Liddata结构，它就会申请这个结构并且负责初始化。于是无论我们调用哪个函数创建
线程，都可以安全调用所有需要_liddata的函数，因为一旦这个结构不存在，它就会被
创建出来。
都么_tiddata在什么时候会被释放呢？ExitThread()背定不会，因为它根本不如通有