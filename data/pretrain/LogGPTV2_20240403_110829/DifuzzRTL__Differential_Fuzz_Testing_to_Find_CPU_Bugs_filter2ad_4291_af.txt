Elapsed time (h)
riscv-torture
mux-cov
reg-cov
Issue #492
CVE-2020-29561
✗Not able to reproduce bug
118
✗
✗
✗
20.3
31.7
Fig. 21: Average time to find real-world bugs using each
approach.
instructions on DIFUZZRTL fuzzing framework with RFuzz’s
mux-coverage guiding. Since RFuzz compiler pass was not
able to instrument all the muxes in Boom core due to the
resource constraints, we modified the pass to randomly and
selectively instrument muxes.
Case Study on Issue #492. The Issue #492 bug (i.e.,
dynamic rm bug) can be found with the following three steps:
1) Starting from the initial state, the FS bit in mstatus register
should be set; 2) frm bits in fcsr register should be set with
a specific value; and 3) A floating point instruction with a
DYN-enabled rm field should be executed [54].
For each fuzzing iteration, we configured each approach
to generate (or mutate) a sequence of instructions and tested
designs. The first row of Figure 21 shows an average elapsed
time to find the bug using each approach. DIFUZZRTL with
register-coverage guidance was almost 6 times faster than riscv-
torture in finding the bug since it captures each step above
as a new coverage and guides input efficiently. However, the
fuzzer which used mux-coverage was not able to find the bug
due to the slow fuzzing speed and inefficient guidance.
Case Study on CVE-2020-29561. The CVE-2020-29561 bug
(i.e., misaligned lr bug) can be found with the following
three steps: 1) A special memory instruction which fetches
the accessed cache line (e.g., amoand) should be executed;
2) Load-reserve instruction (i.e., lr) should be executed on
the same cache line but with a misaligned address. Such an
instruction raises a misaligned load exception, and the program
counter jumps to the address of exception vector [54]; and
3) After exception, additional store-conditional instruction (i.e.,
sc) which accesses the same cache line should be performed,
but this time, with a correct address alignment.
Due to the complex nature of the bug, it took approximately
30 hours for DIFUZZRTL to find the bug as shown in Figure 21.
Meanwhile, none of other techniques were able to find the bug
even after running ten times of elapsed time for DIFUZZRTL
(i.e., 300 hours). When reasoning about the bug reproducing,
the first step (i.e., fetching a specific cache line) does not have
any architectural effect on the second step (i.e., loading and
reserving the same cache line). However, DIFUZZRTL captures
the new coherency state of the cache line explored by the two
steps, and successfully guides inputs to the next step.
VII. LIMITATIONS
Confirming the Semantic Bugs. Since DIFUZZRTL detects
semantic bugs by comparing the execution results of ISA
and RTL simulation, the system alone cannot confirm which
one is responsible for the found bug. Thus DIFUZZRTL
requires manual inspection of the specification to confirm
the bug. DIFUZZRTL may leverage the results of different
implementations of the same specification (e.g. Rocket and
Boom core) to at least confine the suspicious design as proposed
in [36]. While these are an interesting research direction, we
leave them as future work.
Applying Register Coverage on General RTL Designs. The
design of DIFUZZRTL has several design points that can only
be used for the RTL designs that have golden models. However,
DIFUZZRTL’s idea on register coverage is generic enough such
that it can be applied to various RTL designs in the future, such
as cache, ALU, rob, etc. It is also possible to run a targeted
fuzzing on a module such as D-cache while simulating entire
CPU because DIFUZZRTL leverages the module by module
approach.
Identifying Side-Channel CPU Bugs. Since DIFUZZRTL
relies on differential testing to discover bugs, DIFUZZRTL
alone cannot identify side-channel CPU issues such as Spectre,
Meltdown, Foreshadow, MDS. In order to discover these bugs,
DIFUZZRTL’s compilation framework can be extended to
monitor the microarchitectural states of modules to check the
state changes depending on a secret value.
Authorized licensed use limited to: Tsinghua University. Downloaded on February 25,2022 at 12:15:46 UTC from IEEE Xplore.  Restrictions apply. 
1299
VIII. RELATED WORK
Dynamic RTL Verification. Dynamic RTL verification is
an old verification methodology which is still widely used.
In [55], authors introduce pseudo random test generation for
verifying DECchip and challenges for defining coverage and
test generation. Shai et al. [56] designs a neural network
to generate input stimuli using coverage but they require
deep knowledge on the design. MicroGP [57] is similar to
DIFUZZRTL in that it verifies a processor using coverage for
input generation. However, the work requires external tools for
coverage evaluation thus increasing manual work.
Recently, various open-source tools for CPU verifica-
tion [37, 58] have been introduced with the rise of RISC-V,
which randomly generate instructions to test the processors.
While random instruction generation is efficient for testing a
wide range of processor functionalities, such tools do not have
a coverage-guiding feature to rigorously test the processors.
DIFUZZRTL, on the other hand, employs the coverage-guiding
with carefully designed coverage metrics to further verify the
processors in deeper aspects.
Other CPU fuzzing works [59, 60] aim at finding hardware
flaws as well as undocumented instructions through exhaus-
tively searching the instruction space of the x86 architecture.
Instead of testing a sequence of instructions, these works focus
on generating a single potentially harmful instruction opcode
because the x86 architecture has a huge instruction space with
a variable instruction length. While DIFUZZRTL is designed
for testing a sequence of instructions, DIFUZZRTL can also
help these approaches if the RTL source code is available—i.e.,
DIFUZZRTL can provide the coverage metric for the instruction
decode unit.
Coverage Definition. On the other hand, researchers have
continued to find good coverage definition. Coverage metrics
are classified into code coverage and functional coverage, where
code coverage relies on the analysis of the code while functional
coverage relies on design specific information [61]. Code
coverages including statement, or toggle coverage are easy
to obtain but insufficient to guide input. Functional coverage
requires designers manual setup.
Moudanos et al. [10] introduce state coverage and transition
coverage which are directly defined on the FSM. However,
the metrics is not scalable because of the state explosion
problem. HYBRO [62] tries to reach hard to reach states
while maximizing branch coverage. As mentioned, branch
coverage on RTL code has fundamental limitation. Recently,
RFUZZ [14], proposes mux coverage which can be synthesized
into FPGA accelerated simulation. Nevertheless, the most
widely used coverage is the functional coverage which is
manually defined by the designers [14].
Static RTL Verification. Along with dynamic verification,
methods to verify RTL using static analysis have been devel-
oped. Symbolic execution mathematically verifies all the design
space of the RTL code. STAR [13] employs hybrid approach,
using random input generation and symbolic execution but the
method has limitations on the sequential depth of a variable.
Zhang et al. [63] introduces backward symbolic execution to
reach assertion violation.
Coverage-guided Fuzzing. Many recent studies leverage
coverage-guided fuzzing approach and try to achieve higher
coverage and vulnerabilities in user programs and kernels
[18–32]. For example, taint-analysis [20, 24] and symbolic
execution [21, 23] techniques have been proposed to overcome
the limitations of coverage-guided fuzzing such as magic bytes
and nested branches.
Differential Fuzzing. Differential fuzzing is designed to
discover semantic bugs by observing inconsistent behaviors
across similar applications. For example,
[64, 65] leverages
differential fuzzing to find the inconsistent behaviors across
Java Virtual Machines (JVMs). Nezha [35] defined the notion of
δ-diversity, which represents the asymmetric behaviors between
testing programs, to guide the fuzzer to disclose semantic bugs
in softwares such as SSL/TLS libraries and PDF viewers.
IX. CONCLUSION
This paper proposed DIFUZZRTL, an RTL fuzzer to dis-
cover CPU bugs in RTL designs. The key design features
of DIFUZZRTL includes register-coverage guided fuzzing
techniques, which can be used as a drop-in-replacement
fuzzer to test various CPU RTLs. DIFUZZRTL is implemented
to perform the fuzz testing for three open-source CPUs,
OpenRISC Mor1kx Cappuccino, RISC-V Rocket Core, and
RISC-V Boom Core. During the evaluation, DIFUZZRTL
identified 16 new bugs from these CPUs, demonstrating its
strong practical prospects.
X. ACKNOWLEDGMENT
We would like to thank Matthew Hicks and anonymous
reviewers for their insightful comments, which significantly
improved the final version of this paper. We also thank
the developers of the open-source CPUs for their helpful
feedback and responses. This work was partially supported by
National Research Foundation (NRF) of Korea grant funded
by the Korean government (NRF-2021R1A2C3014131, NRF-
2019R1C1C1006095), Institute for Information & communica-
tions Technology Promotion (IITP) grant funded by the Korea
government (MSIP) (No.2020-0-01840, Analysis on technique
of accessing and acquiring user data in smartphone). The
Institute of Engineering Research (IOER) and Automation and
Systems Research Institute (ASRI) at Seoul National University
provided research facilities for this work. The Institute of
Engineering Research at Seoul National University provided
research facilities for this work.
REFERENCES
[1] Kypros Constantinides, Onur Mutlu, and Todd Austin. Online design
bug detection: Rtl analysis, flexible mechanisms, and evaluation.
In
Proceedings of the 41st Annual IEEE/ACM International Symposium on
Microarchitecture (MICRO), Washington, DC, November 2008.
[2] Pentium fdiv: The
processor
bug
that
shook
the world.
https://www.techradar.com/news/computing-components/processors/
pentium-fdiv-the-processor-bug-that-shook-the-world-1270773.
[3] Intel’s fdiv bug: Empty cells at empty tables. https://www.olenick.com/
blog/articles/infamous-software-bugs-fdiv-bug/.
Authorized licensed use limited to: Tsinghua University. Downloaded on February 25,2022 at 12:15:46 UTC from IEEE Xplore.  Restrictions apply. 
1300
[4] Paul Kocher, Jann Horn, Anders Fogh, Daniel Genkin, Daniel Gruss,
Werner Haas, Mike Hamburg, Moritz Lipp, Stefan Mangard, Thomas
Prescher, et al. Spectre attacks: Exploiting speculative execution. In
Proceedings of the 40th IEEE Symposium on Security and Privacy
(Oakland), San Francisco, CA, May 2019.
[5] Moritz Lipp, Michael Schwarz, Daniel Gruss, Thomas Prescher, Werner
Haas, Anders Fogh, Jann Horn, Stefan Mangard, Paul Kocher, Daniel
Genkin, Yuval Yarom, and Mike Hamburg. Meltdown: Reading kernel
memory from user space. In Proceedings of the 27th USENIX Security
Symposium (Security), Baltimore, MD, August 2018.
[6] Saad Islam, Ahmad Moghimi, Ida Bruhns, Moritz Krebbel, Berk
Gulmezoglu, Thomas Eisenbarth, and Berk Sunar. SPOILER: Speculative
load hazards boost rowhammer and cache attacks. In Proceedings of
the 28th USENIX Security Symposium (Security), SANTA CLARA, CA,
August 2019.
[7] Jo Van Bulck, Marina Minkin, Ofir Weisse, Daniel Genkin, Baris Kasikci,
Frank Piessens, Mark Silberstein, Thomas F. Wenisch, Yuval Yarom,
and Raoul Strackx. Foreshadow: Extracting the keys to the intel SGX
kingdom with transient out-of-order execution. In Proceedings of the
27th USENIX Security Symposium (Security), Baltimore, MD, August
2018.
[8] Intel finds
tsx
enterprise
bug
on
haswell,
broadwll
cpus.
https://www.pcworld.com/article/2464880/intel-finds-specialized-
tsx-enterprise-bug-on-haswell-broadwell-cpus.html.
[9] Intel november 2019 microcode update.
https://access.redhat.com/
solutions/2019-microcode-nov.
[10] Dinos Moundanos, Jacob A Abraham, and Yatin Vasant Hoskote. Ab-
straction techniques for validation coverage analysis and test generation.
IEEE Transactions on Computers, 47(1):2–14, 1998.
[11] Yanhong Zhou, Tiancheng Wang, Huawei Li, Tao Lv, and Xiaowei Li.
Functional test generation for hard-to-reach states using path constraint
solving. IEEE Transactions on Computer-Aided Design of Integrated
Circuits and Systems, 35(6):999–1011, 2015.
[12] Jian Wang, Huawei Li, Tao Lv, Tiancheng Wang, Xiaowei Li, and
Sandip Kundu. Abstraction-guided simulation using markov analysis for
functional verification. IEEE Transactions on Computer-Aided Design
of Integrated Circuits and Systems, 35(2):285–297, 2015.
[13] Lingyi Liu and Shabha Vasudevan. Star: Generating input vectors for
design validation by static analysis of rtl. In 2009 IEEE International
High Level Design Validation and Test Workshop, San Francisco, CA,
November 2009.
[14] Kevin Laeufer, Jack Koenig, Donggyu Kim, Jonathan Bachrach, and
Koushik Sen. Rfuzz: coverage-directed fuzz testing of rtl on fpgas.
In Proceedings of the 37th IEEE/ACM International Conference on
Computer-Aided Design (ICCAD), San Diego, CA, November 2018.
[15] Donald Thomas and Philip Moorby. The Verilog R⃝ Hardware Description
Language. Springer Science & Business Media, 2008.
[16] Peter J Ashenden. The designer’s guide to VHDL. Morgan Kaufmann,
2010.
[17] M. Zalewski. American fuzzy lop. http://lcamtuf.coredump.cx/afl/.
[18] Marcel B¨ohme, Van-Thuan Pham, and Abhik Roychoudhury. Coverage-
based greybox fuzzing as markov chain. In Proceedings of the 23rd
ACM Conference on Computer and Communications Security (CCS),
Vienna, Austria, October 2016.
[19] Dae R Jeong, Kyungtae Kim, Basavesh Shivakumar, Byoungyoung Lee,
and Insik Shin. Razzer: Finding kernel race bugs through fuzzing.
In Proceedings of the 40th IEEE Symposium on Security and Privacy
(Oakland), San Francisco, CA, May 2019.
[20] Peng Chen and Hao Chen. Angora: Efficient fuzzing by principled search.
In Proceedings of the 39th IEEE Symposium on Security and Privacy
(Oakland), San Francisco, CA, May 2018.
[21] Insu Yun, Sangho Lee, Meng Xu, Yeongjin Jang, and Taesoo Kim.
{QSYM}: A practical concolic execution engine tailored for hybrid
In Proceedings of the 27th USENIX Security Symposium
fuzzing.
(Security), Baltimore, MD, August 2018.
[22] Caroline Lemieux and Koushik Sen. Fairfuzz: A targeted mutation
strategy for increasing greybox fuzz testing coverage. In Proceedings of
the 33rd IEEE/ACM International Conference on Automated Software
Engineering (ASE), Montpellier, France, September 2018.
[23] Nick Stephens, John Grosen, Christopher Salls, Andrew Dutcher, Ruoyu
Wang, Jacopo Corbetta, Yan Shoshitaishvili, Christopher Kruegel, and
Giovanni Vigna. Driller: Augmenting fuzzing through selective symbolic
execution. In Proceedings of the 2016 Annual Network and Distributed
System Security Symposium (NDSS), San Diego, CA, February 2016.
[24] Sanjay Rawat, Vivek Jain, Ashish Kumar, Lucian Cojocar, Cristiano
Giuffrida, and Herbert Bos. Vuzzer: Application-aware evolutionary
fuzzing. In Proceedings of the 2017 Annual Network and Distributed
System Security Symposium (NDSS), San Diego, CA, February 2017.
[25] syzkaller. https://github.com/google/syzkaller.
[26] Shuitao Gan, Chao Zhang, Xiaojun Qin, Xuwen Tu, Kang Li, Zhongyu
Pei, and Zuoning Chen. Collafl: Path sensitive fuzzing. In Proceedings
of the 39th IEEE Symposium on Security and Privacy (Oakland), San
Francisco, CA, May 2018.
[27] Cornelius Aschermann, Tommaso Frassetto, Thorsten Holz, Patrick
Jauernig, Ahmad-Reza Sadeghi, and Daniel Teuchert. Nautilus: Fishing
In Proceedings of the 2019 Annual
for deep bugs with grammars.
Network and Distributed System Security Symposium (NDSS), San Diego,
CA, February 2019.
[28] Cornelius Aschermann, Sergej Schumilo, Tim Blazytko, Robert Gawlik,
and Thorsten Holz. Redqueen: Fuzzing with input-to-state correspon-
In Proceedings of the 2019 Annual Network and Distributed
dence.
System Security Symposium (NDSS), San Diego, CA, February 2019.
[29] Chenyang Lyu, Shouling Ji, Chao Zhang, Yuwei Li, Wei-Han Lee,
Yu Song, and Raheem Beyah. {MOPT}: Optimized mutation scheduling
for fuzzers. In Proceedings of the 28th USENIX Security Symposium
(Security), SANTA CLARA, CA, August 2019.
[30] Wei You, Xueqiang Wang, Shiqing Ma, Jianjun Huang, Xiangyu Zhang,
XiaoFeng Wang, and Bin Liang. Profuzzer: On-the-fly input type probing
for better zero-day vulnerability discovery. In Proceedings of the 40th
IEEE Symposium on Security and Privacy (Oakland), San Francisco,
CA, May 2019.
[31] HyungSeok Han and Sang Kil Cha.
Imf: Inferred model-based
In Proceedings of the 24th ACM Conference on Computer
fuzzer.
and Communications Security (CCS), Dallas, TX, October 2017.
[32] Shankara Pailoor, Andrew Aday, and Suman Jana. Moonshine: Optimiz-
ing {OS} fuzzer seed selection with trace distillation. In Proceedings of
the 27th USENIX Security Symposium (Security), Baltimore, MD, August
2018.
[33] Wen Xu, Hyungon Moon, Sanidhya Kashyap, Po-Ning Tseng, and Taesoo
Kim. Fuzzing file systems via two-dimensional input space exploration.
In Proceedings of the 40th IEEE Symposium on Security and Privacy
(Oakland), San Francisco, CA, May 2019.