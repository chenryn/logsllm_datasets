# 优化后的文本

## 图21：使用每种方法发现实际漏洞的平均时间（小时）

| 方法 | Issue #492 | CVE-2020-29561 |
|------|------------|----------------|
| riscv-torture | 无法重现漏洞 | 无法重现漏洞 |
| mux-cov | 无法重现漏洞 | 无法重现漏洞 |
| reg-cov | 118 | 30 |

### 案例研究：Issue #492
Issue #492 漏洞（即动态 rm 漏洞）可以通过以下三个步骤找到：
1. 从初始状态开始，设置 mstatus 寄存器中的 FS 位。
2. 设置 fcsr 寄存器中的 frm 位为特定值。
3. 执行带有 DYN 启用 rm 字段的浮点指令 [54]。

对于每次模糊测试迭代，我们配置每种方法生成（或变异）一系列指令并进行测试。图21的第一行显示了使用每种方法找到漏洞的平均耗时。DIFUZZRTL 使用寄存器覆盖引导比 riscv-torture 快近六倍，因为它能捕捉上述每个步骤作为新的覆盖率，并有效地引导输入。然而，使用多路选择器覆盖的方法由于模糊速度慢且引导效率低而未能找到该漏洞。

### 案例研究：CVE-2020-29561
CVE-2020-29561 漏洞（即错位 lr 漏洞）可以通过以下三个步骤找到：
1. 执行一个特殊的内存指令，例如 amoand，以获取访问的缓存行。
2. 在相同的缓存行上执行带错位地址的加载保留指令（即 lr）。这种指令会引发错位加载异常，程序计数器跳转到异常向量地址 [54]。
3. 异常发生后，执行附加的存储条件指令（即 sc），访问相同的缓存行，但这次使用正确的地址对齐。

由于此漏洞的复杂性，如图21所示，DIFUZZRTL 大约需要30小时才能找到该漏洞。与此同时，其他技术即使运行十倍于 DIFUZZRTL 的时间（即300小时）也未能找到该漏洞。在分析漏洞重现时，第一步（即获取特定缓存行）对第二步（即加载和保留相同缓存行）没有架构上的影响。然而，DIFUZZRTL 能够捕捉到由这两个步骤探索的新缓存行一致性状态，并成功地引导输入进入下一步。

## 限制
### 确认语义错误
由于 DIFUZZRTL 通过比较 ISA 和 RTL 仿真结果来检测语义错误，系统本身无法确认哪个是导致问题的原因。因此，DIFUZZRTL 需要手动检查规范以确认错误。DIFUZZRTL 可以利用同一规范的不同实现（例如 Rocket 和 Boom 核心）的结果来至少缩小可疑设计范围，如 [36] 中所提议。尽管这是一个有趣的研究方向，但我们将其留作未来的工作。

### 将寄存器覆盖率应用于通用 RTL 设计
DIFUZZRTL 的设计有几个仅适用于具有黄金模型的 RTL 设计的设计点。然而，DIFUZZRTL 关于寄存器覆盖率的思想足够通用，可以应用于各种 RTL 设计，如缓存、ALU、rob 等。此外，由于 DIFUZZRTL 采用了模块化方法，还可以在模拟整个 CPU 的同时对某个模块（如 D-cache）进行有针对性的模糊测试。

### 识别侧信道 CPU 错误
由于 DIFUZZRTL 依赖差异测试来发现错误，它本身无法识别像 Spectre、Meltdown、Foreshadow 和 MDS 这样的侧信道 CPU 问题。为了发现这些错误，可以扩展 DIFUZZRTL 的编译框架以监控模块的微架构状态，以检查根据秘密值的状态变化。

## 相关工作
### 动态 RTL 验证
动态 RTL 验证是一种古老的验证方法，至今仍被广泛使用。[55] 中介绍了用于验证 DECchip 的伪随机测试生成及其面临的挑战。Shai 等人 [56] 设计了一个神经网络，利用覆盖率生成输入刺激，但这需要对设计有深入了解。MicroGP [57] 类似于 DIFUZZRTL，它使用覆盖率进行输入生成以验证处理器。然而，这项工作需要外部工具进行覆盖率评估，从而增加了手动工作。

最近，随着 RISC-V 的兴起，各种开源 CPU 验证工具 [37, 58] 被引入，这些工具随机生成指令以测试处理器。虽然随机指令生成在测试处理器的广泛功能方面是有效的，但这些工具缺乏覆盖率引导功能以严格测试处理器。相比之下，DIFUZZRTL 采用精心设计的覆盖率指标进行覆盖率引导，进一步深入验证处理器。

其他 CPU 模糊测试工作 [59, 60] 旨在通过详尽搜索 x86 架构的指令空间来查找硬件缺陷以及未记录的指令。这些工作专注于生成单个可能有害的指令操作码，因为 x86 架构具有巨大的指令空间和可变长度的指令。虽然 DIFUZZRTL 旨在测试一系列指令，但如果 RTL 源代码可用，DIFUZZRTL 也可以帮助这些方法——即 DIFUZZRTL 可以为指令解码单元提供覆盖率指标。

### 覆盖率定义
另一方面，研究人员一直在寻找良好的覆盖率定义。覆盖率度量分为代码覆盖率和功能覆盖率，其中代码覆盖率依赖于代码分析，而功能覆盖率依赖于设计特定信息 [61]。诸如语句或切换覆盖率等代码覆盖率易于获得但不足以引导输入。功能覆盖率则需要设计师的手动设置。

Moudanos 等人 [10] 引入了直接定义在 FSM 上的状态覆盖率和转换覆盖率。然而，这些度量由于状态爆炸问题而不具备可扩展性。HYBRO [62] 尝试在最大化分支覆盖率的同时达到难以到达的状态。正如提到的，RTL 代码的分支覆盖率存在根本性的局限。最近，RFUZZ [14] 提出了可以合成到 FPGA 加速仿真的多路选择器覆盖率。尽管如此，最广泛使用的覆盖率仍然是由设计师手动定义的功能覆盖率 [14]。

### 静态 RTL 验证
除了动态验证外，还开发了使用静态分析来验证 RTL 的方法。符号执行数学上验证了 RTL 代码的所有设计空间。STAR [13] 采用混合方法，结合随机输入生成和符号执行，但该方法在变量的顺序深度上有局限性。Zhang 等人 [63] 引入了反向符号执行以达到断言违反。

### 覆盖率引导的模糊测试
许多近期研究利用覆盖率引导的模糊测试方法，试图在用户程序和内核中实现更高的覆盖率和漏洞发现 [18–32]。例如，提出了污点分析 [20, 24] 和符号执行 [21, 23] 技术来克服覆盖率引导模糊测试的局限性，如魔术字节和嵌套分支。

### 差异模糊测试
差异模糊测试旨在通过观察相似应用程序之间的不一致行为来发现语义错误。例如，[64, 65] 利用差异模糊测试来查找 Java 虚拟机 (JVM) 之间的不一致行为。Nezha [35] 定义了 δ 多样性的概念，表示测试程序之间的不对称行为，以引导模糊测试器披露 SSL/TLS 库和 PDF 查看器等软件中的语义错误。

## 结论
本文提出了 DIFUZZRTL，一种用于在 RTL 设计中发现 CPU 错误的模糊测试工具。DIFUZZRTL 的关键设计特点包括基于寄存器覆盖率的模糊测试技术，可以用作替代模糊测试器来测试各种 CPU RTL。DIFUZZRTL 实现了对三种开源 CPU（OpenRISC Mor1kx Cappuccino、RISC-V Rocket Core 和 RISC-V Boom Core）的模糊测试。在评估过程中，DIFUZZRTL 从这些 CPU 中发现了16个新错误，展示了其强大的实际应用前景。

## 致谢
我们要感谢 Matthew Hicks 和匿名审稿人提出的宝贵意见，这极大地改进了本文的最终版本。我们还要感谢开源 CPU 开发者的有益反馈和支持。本研究得到了韩国国家研究基金会（NRF）资助（NRF-2021R1A2C3014131, NRF-2019R1C1C1006095），信息技术促进研究所（IITP）资助（No.2020-0-01840, 分析智能手机中访问和获取用户数据的技术），以及首尔国立大学工程研究院（IOER）和自动化与系统研究所（ASRI）提供的研究设施的支持。