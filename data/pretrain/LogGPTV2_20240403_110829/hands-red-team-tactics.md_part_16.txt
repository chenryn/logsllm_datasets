topic.
Assuming that you have some basic understanding of Domains, Domain
Controllers, and **Active Directory Domain Services** (**AD/DS**),
let\'s continue with the Active Directory exploitation. You should
already have an active agent. In our case, the agent is active and has
the privileges of the PT user.
> ![](media/image498.jpeg)
>
> To get access to the Domain Controller, we first need to get access to
> a domain user\'s account so that we can perform reconnaissance on the
> domain. Remember that we can\'t gather information regarding a
> particular domain with a local account. We need to have access to a
> domain user account so that the domain user can communicate with the
> Domain Controller to get information.
>
> Let\'s first escalate the privileges using the bypassuac_eventvwr
> module on the local system so that we can have a higher security
> context to perform further attacks:
>
> ![](media/image499.jpeg)
>
> The asterisk (\*) in the username means that we have escalated the
> privileges for the PTuser:
>
> ![](media/image500.jpeg)
The next step would be to gather the credentials from the memory using
mimikatz. We will be able to find these if any domain user has logged on
to this server before. Using mimikatz, we can fetch the credentials of
the domain users as well.
> ![](media/image501.jpeg)
Two domain users are found on this server: harry and john. We also found
that the domain is l33t.local:
> ![](media/image502.jpeg)
>
> In our current scenario, we have system privileges on the local server
> and we have the credentials of two domain users: harry and john. What
> we need to do now is to elevate from a local user to a domain user. We
> can do this using another
>
> post module in Empire. In this situation, we can use the spawnas
> module in Empire to spawn a new agent using the domain user:
>
> ![](media/image503.jpeg)
>
> Next, we\'ll set the CredID, which can be found by executing the creds
> command, and the Listener:
>
> ![](media/image504.jpeg)
Once all the options are set, we can execute the module, which will
create a process using the domain user\'s credentials:
> ![](media/image505.jpeg)
A new agent is now online. This time, it\'s the John user:
> ![](media/image506.jpeg)
>
> Now that we have access to a domain user\'s account, we can move
> forward with Domain Controller Reconnaissance. The first thing that we
> need to know is the IP address of the Domain Controller. This can be
> found using the dnsserver module in Empire:
>
> ![](media/image507.jpeg)
>
> At the time of configuration, a DC will always try to set up a DNS
> server if this is not already done. This Empire module will look for
> the primary and secondary DNS servers:
>
> ![](media/image508.jpeg)
>
> As we can see, the IP 192.168.2.17 is the primary DNS server. There\'s
> a high chance this IP could belong to the DC. To confirm this, we can
> use the get_domain_controller module in Empire. This module will
> return information about the DC for the current domain:
>
> ![](media/image509.jpeg)
Let\'s set up the domain option here and execute the module so that it
can look for
> information regarding the specified domain:
>
> ![](media/image510.jpeg)
As we can see from the preceding result, 192.168.2.17 is indeed the DC.
The
> get_domain_controller module provides us with the following
> information:
+---------------+------------------------------------------------------+
| > Forest      | > l33t.local                                         |
+===============+======================================================+
| > OSVersion   | > Windows Server 2008 R2 Enterprise                  |
+---------------+------------------------------------------------------+
| > Roles       | > SchemaRole, NamingRole, PdcRole, RidRole           |
+---------------+------------------------------------------------------+
| > IPAddress   | > 192.168.2.17                                       |
+---------------+------------------------------------------------------+
| > Name        | > WIN-9PIACAHV7U3.l33t.local                         |
+---------------+------------------------------------------------------+
> Please refer to
> [https://technet.microsoft.com/pt-pt/library/cc759073(v=ws.10).aspx](https://technet.microsoft.com/pt-pt/library/cc759073(v%3Dws.10).aspx)
> to understand the basics of Domains and Forests.
To get information about the Forest, use the get_forest module:
> ![](media/image511.jpeg)
The Forest name will be used in the get_forest module to retrieve
information about the specified Forest. This includes the root domain
and its SID. Let\'s set the
> Forest name to l33t.local, which we retrieved from the
> get_domain_controller
>
> module:
>
> ![](media/image512.jpeg)
>
> As you can see in the preceding screenshot, we were able to retrieve
> the root domain and its SID using the get_forest module. This gives us
> the following information:
+------------------------+---------------------------------------------+
| > RootDomainSID        | > S-1-5-21-3140846176-3513996709-3658482848 |
+========================+=============================================+
| >                      | > DomainDNSZones for l33t, local            |
|  ApplicationPartitions | > ForestDNSZones for l33t, local            |
+------------------------+---------------------------------------------+
| > SchemaRoleOwner      | > WIN-9PIACAHV7U3.l33t.local                |
+------------------------+---------------------------------------------+
| > NamingRoleOwner      | > WIN-9PIACAHV7U3.l33t.local                |
+------------------------+---------------------------------------------+
> Now that we have retrieved all the information regarding the l33t
> domain in the Forest, let\'s look for other domains that are
> configured in the same Forest, if any are available. This can be
> achieved using the get_forest_domain module. Use this module to
> retrieve the information regarding **Primary DC** (**PDC**) as well as
> the Role Owner:
>
> ![](media/image513.jpeg)
>
> Set the Forest name to l33t.local to find all the domains in this
> forest:
>
> ![](media/image514.jpeg)
>
> We found that the l33t.local Forest has only one domain under it and
> that the PDC is the same as the Domain Controller that we want to
> access. Let\'s confirm all the information that we have gathered on
> the Domain Controller up until now:
+------------------------+---------------------------------------------+
| > Forest               | > l33t.local                                |
+========================+=============================================+
| > OSVersion            | > Windows Server 2008 R2 Enterprise         |
+------------------------+---------------------------------------------+
| > Roles                | > SchemaRole, NamingRole, PdcRole, RidRole  |
+------------------------+---------------------------------------------+
| > IPAddress            | > 192.168.2.17                              |
+------------------------+---------------------------------------------+
| > Name                 | > WIN-9PIACAHV7U3.l33t.local                |
+------------------------+---------------------------------------------+
| > RootDomainSID        | > S-1-5-21-3140846176-3513996709-3658482848 |
+------------------------+---------------------------------------------+
| >                      | > DomainDNSZones for l33t, local            |
|  ApplicationPartitions | > ForestDNSZones for l33t, local            |
+------------------------+---------------------------------------------+
| > SchemaRoleOwner      | > WIN-9PIACAHV7U3.l33t.local                |
+------------------------+---------------------------------------------+
| > NamingRoleOwner      | > WIN-9PIACAHV7U3.l33t.local                |
+------------------------+---------------------------------------------+
| > PdcRoleOwner         | > WIN-9PIACAHV7U3.l33t.local                |
+------------------------+---------------------------------------------+
| > Domain mode          | > Windows2008Domain                         |
+------------------------+---------------------------------------------+
> Now that we know our target, let\'s move on to the lateral movement.
> To connect to the Domain Controller using the domain user\'s
> credentials that we acquired earlier, we can use the invoke_wmi module
> in Empire:
>
> ![](media/image515.jpeg)
>
> This module will execute the Empire stager on the target host in the
> network using **Windows Management Instrumentation** (**WMI**). Let\'s
> set up the options to run this module. Use the computer name that we
> retrieved from the earlier Domain Controller reconnaissance:
>
> ![](media/image516.jpeg)
Upon execution of this module, we get an E_ACCESSDENIED error, which
means that the credentials we used in this module are invalid. Let\'s
try another set of credentials that we acquired:
> ![](media/image517.jpeg)
Execute the module with the new credentials:
> ![](media/image518.jpeg)
We are in luck! We were able to log in to the Domain Controller using
John\'s credentials with the cred ID 6.
Let\'s check our agent list to confirm the active agent on the Domain
Controller.
> ![](media/image519.jpeg)
This shows that we now have access to the Domain Controller. The
asterisk next to L33T\\John means that the John user is a domain admin.
> Let\'s retrieve the credentials for Domain Administrator\'s account
> using mimikatz. Remember that we can\'t run mimikatz on an
> unprivileged user; we need to have higher privileges. We did not
> perform privilege escalation here as the user already has a higher
> security context:
>
> ![](media/image520.jpeg)
>
> The module was executed successfully. We can now use the creds command
> to
>
> confirm the newly acquired credentials from the Domain Controller.
>
> ![](media/image521.jpeg)
>
> The whole process from reconnaissance to Domain Admin account access
> can take a lot of time and it is easy to get confused in the
> reconnaissance phase.
>
> Fortunately, we have an automation script to exploit the AD/DS to get
> access to the Domain Controller in a matter of minutes.
# Automating Active Directory exploitation using the DeathStar
> As explained by the creator:
>
> *\"DeathStar is a Python script that uses Empire\'s RESTful API to
> automate gaining Domain Admin rights in Active Directory environments
> using a variety of techniques.\"*
>
> *- (source: )*
>
> To run DeathStar, we need to start Empire with a RESTful API. This can
> be achieved with the following command:
>
> ![](media/image522.jpeg)**sudo ./empire \--rest \--username \ to access the API\> \--password \ ![](media/image523.jpeg)
>
> The message displayed in the previous screenshots indicates that the
> RESTful API is running on port 1337/tcp and an API token has been
> allotted. There\'s a huge security risk if we open port 1337/tcp for
> everyone. To avoid this, we will create a reverse SSH tunnel to
> connect to the port securely:
>
> ![](media/image524.jpeg)
Confirm the tunnel has been created as follows:
> ![](media/image525.jpeg)
>
> This shows that it has indeed been created successfully. Before
> starting DeathStar, let\'s make sure we have an active agent in
> Empire:
>
> ![](media/image526.jpeg)
To run DeathStar, we will execute the following command:
> **./DeathStar.py -u harry -p harry123**
>
> ![](media/image527.jpeg)
>
> Upon execution, DeathStar acquires the active agent. In a matter of
> seconds, DeathStar is able to find the following:
>
> The Domain SID
>
> The members in the Domain Admin group The Domain Controller
>
> ![](media/image528.jpeg)
>
> After this, DeathStar then found that three users logged in to the
> target server, one of which was a Domain Admin. DeathStar quickly ran
> lateral movement modules and the domain privilege escalation module to
> get access:
>
> ![](media/image529.jpeg)
DeathStar was able to get the credentials from memory for the
administrator. It then enumerated the admin processes and found the
Domain Admin Credentials:
> ![](media/image530.jpeg)
All of this happened in a matter of seconds. That\'s the power of
automation! For more information regarding the workings of this tool,
please refer to the flow
> chart at the following link:
> [https://byt3bl33d3r.github.io/automating-the-empire-with-the](https://byt3bl33d3r.github.io/automating-the-empire-with-the-death-star-getting-domain-admin-with-a-push-of-a-button.html)
>
> [-death-star-getting-domain-admin-with-a-push-of-a-button.html](https://byt3bl33d3r.github.io/automating-the-empire-with-the-death-star-getting-domain-admin-with-a-push-of-a-button.html)
>
> This example showed a simple way of getting access to the Domain
> Controller, but the same method doesn\'t always work. Sometimes, you
> have to look for different attack paths. You can then choose which
> path to use to access the Domain Admin\'s account
>
> The internal network exploitation techniques have grown so much
> because of new red team **tactics, techniques, and procedures**
> (**TTPs**) that are now used to find the attack paths using graph
> theories. The can be done using a tool called Bloodhound, which is not
> covered in this book. For more information regarding Bloodhound,
> please refer to the following website:
> [https://github.com/BloodHoundAD/B
> loodhound/.](https://github.com/BloodHoundAD/Bloodhound/)
Note that DeathStar is just a tool that uses Empire post exploitation
module scripts to get a Domain Admin account. In some cases, however, we
don\'t get the account, so we have to perform manual lateral movement
and try to exploit the internal network systems. We can then try
different ways to get access to the Domain Controller.
> In the next section, we will look at using Empire via a web interface.
# Empire GUI
> It can sometimes be quite difficult to use Empire in command line
> mode. To avoid this, we\'re going to look at how to use the Empire web
> interface, which can be managed much more easily. To begin with,
> let\'s clone the GitHub repository:
>
> ![](media/image531.jpeg)**git clone
> https://github.com/interference-security/empire-web**
>
> Now, move the empire-web directory to the /var/www/html of your web
> server:
>
> ![](media/image532.jpeg)
Then, start the web service and check for the login.php page in
empire-web. In this case, we have configured a custom web service port,
9797/tcp:
> ![](media/image533.jpeg)
>
> The biggest issue with accessing the Empire web in this case is that
> anyone can access it. Because it\'s a web application, anyone can try
> and look for vulnerabilities.
>
> If we try to check for the 9797/tcp on the web server, it shows that
> the port is accessible from any interface:
>
> ![](media/image534.jpeg)
A quick Nmap port scan can help us get a clear picture:
> ![](media/image535.jpeg)
As we can see in the preceding screenshot, port 9797 is accessible from
any IP. We need to find a way to access the Empire GUI web interface in
a secure fashion. We can do this by blocking the 9797/tcp for everyone
and accessing it via a reverse SSH tunnel.
> Block port 9797/tcp on the firewall using the ufw tool. ufw is
> pre-installed in some variants of Linux. If it isn\'t pre-installed,
> we can install it using the apt install ufw
>
> -y command:
>
> ![](media/image536.jpeg)
Once the rules are added to the firewall chain, try to use Nmap again:
> ![](media/image537.jpeg)
The port is now blocked from outside. If we try to access the web
interface now, we won\'t be able to connect:
> ![](media/image538.jpeg)
So, let\'s configure a reverse SSH tunnel using the following command:
> **ssh -Nf -L 9797:127.0.0.1:9797 \@\**
>
> ![](media/image539.jpeg)
>
> As we can see in the previous screenshot, port 9797/tcp on the web
> server is connected to our system through local port 9797/tcp. This
> means that we have configured a tunnel on port 9797/tcp. Let\'s try to
> access the web service using our local IP and port 9797/tcp:
>
> ![](media/image540.jpeg)
>
> We were successful! Let\'s add in the Empire IP Address, the Empire
> Port, the Empire Username, and the Empire Password:
>
> ![](media/image541.jpeg)
>
> These credentials are the same as the ones we set when we ran
> DeathStar. When we are logged in, we will see the Empire web
> interface, which shows us how many listeners and agents there are:
>
> ![](media/image542.jpeg)