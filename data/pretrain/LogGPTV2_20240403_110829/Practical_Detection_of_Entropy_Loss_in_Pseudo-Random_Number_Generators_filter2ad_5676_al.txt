of fresh entropy γ to the entropy counter c. The values of γ and the leakage z are also
returned to A. We denote by qr the number of times A calls D-refresh (and, hence, D),
and notice that by our convention (of including oracle calls into run-time calculations) the
total run-time of D is implicitly upper bounded by the run-time of A.
• next-ror. This procedure provides A with either the real-or-random challenge (provided
that c ≥ γ∗) or the true generator output. As a small subtlety, a “premature” call to
next-ror before c crosses the γ∗ resets the counter c to 0, since then A might learn something
non-trivial about the (low-entropy) state S in this case. We denote by qn the total number
of calls to next-ror and get-next.
• get-state/set-state. These procedures provide A with the ability to either learn the current
state S, or set it to any value S∗. In either case c is reset to 0.We denote by qs the total
number of calls to get-state and set-state.
We can now deﬁne the corresponding security notions for pseudo-random number generator with
input. In the sequel we denote the ’resources’ of A by T = (t, qr, qn, qs). We also use the integers
k and j as follows:
— 54 —
4.1. Model Description
• The integer k is used to identify the successive outputs (σk, Ik, γk, zk) of the distribution
sampler D and therefore the successive inputs Ik used to update the internal state of the
generator,
• The integer j is used to identify the successive states Sj of the generator, when updated
with the refresh algorithm.
Deﬁnition 29 (Security of pseudo-random number generator with input [DPR+13]). A pseudo-
random number generator with input G = (setup, refresh, next) is called (T = (t, qr, qn, qs), γ∗, ε)-
resilient, forward-secure, backward-secure), if for any adversary A running in
robust (resp.
time at most t, making at most qr calls to D-refresh, qn calls to next-ror/get-next and qs calls
to get-state/set-state, and any legitimate distribution sampler D inside the D-refresh procedure,
the advantage of A in game ROB(γ∗) (resp, RES(γ∗), FWD(γ∗), BWD(γ∗)) is at most ε, where:
• ROB(γ∗) is the unrestricted game where A is allowed to make the above calls.
• RES(γ∗) is the restricted game where A makes no calls to get-state/set-state (i.e., qs = 0).
• FWD(γ∗) is the restricted game where A makes no calls to set-state and a single call to
get-state (i.e., qs = 1) which is the very last oracle call A is allowed to make.
• BWD(γ∗) is the restricted game where A makes no calls to get-state and a single call to
set-state (i.e., qs = 1) which is the very ﬁrst oracle call A is allowed to make.
Hence, (a) resilience protects the security of the generator when not corrupted against arbitrary
distribution samplers D, (b) forward security protects past generator outputs in case the state
S gets compromised, (c) backward security security ensures that the generator can successfully
recover from state compromise, provided enough fresh entropy is injected into the system, (d)
robustness ensures arbitrary combination of the above. Hence, robustness is the strongest and
the resilience is the weakest of the above four notions. In particular, all our provable construc-
tions will satisfy the robustness notion, but we will use the weaker notions to better point some
of our attacks.
Examples of the entropy traces of the counter c for the procedures deﬁned for the security game
ROB are provided in Figure 4.3. Note that we illustrated two next-ror calls, the ﬁrst one where
c ≥ γ∗ and the second one where c < γ∗.
entropy estimate c
state lenght n
threshold γ∗
y
p
o
r
t
n
e
d
e
t
a
m
i
t
s
e
n
o
d
n
u
o
b
-
r
e
w
o
l
n
γ∗
0
D-refresh
D-refresh
D-refresh
D-refresh
next-ror
next-ror
D-refresh
D-refresh
set-state
Figure 4.3 – Entropy Estimates in ROB(γ∗)
Comparison with [BH05]. As described, this security models complements the previous work
of [BH05] in two ways:
— 55 —
Chapter 4. Robustness of Pseudo-random Number Generators with Inputs
1. It clearly captures the notion of entropy accumulation.
2. It clariﬁes the need of independence between the public parameter seed and the source of
randomness.
This security models also allows to deﬁne precisely the notion of backward security which is
close to the recovering security described in the next section. In [BH05], an immediate recovery
occurs any time one call is done to procedure good-refresh, which should be seen as an extreme
case of the new proposed security model.
In [BH05], Barak and Halevi also insisted that the state S is indistinguishable from random once
corrupt = false. While true in their speciﬁc construction, we think that demanding this property
is simultaneously too restrictive and also not very well motivated as the mandatory part of a
general security deﬁnition.
For example, if one considers a generator with an internal state S that includes a (never random)
Boolean ﬂag which keeps track if the last call to the generator was made to the next procedure.
In particular, looking at the analysis of [BH05], the (truncated) generator G0 inside the refresh
procedure is only needed to ensure the state pseudo-randomness of their construction. In other
words, if one drops (only the) state pseudo-randomness from the BH model, the “Simpliﬁed BH”
construction is already robust in their model. Motivated by this, we will present a strong attack
on the simpliﬁed BH construction, for any extractor Extract and any standard pseudo-random
number generator G.
We consider a ’simpliﬁed’ construction (that we denote after the ’Simpliﬁed BH’ construction,
as it is derived from the robust construction described in Section 3.6.2). This construction also
involves a randomness extraction function Extract : {0, 1}p −→ {0, 1}n and a standard pseudo-
random number generator G : {0, 1}n −→ {0, 1}n+‘. As for the initial construction of [BH05],
we do not deﬁne an explicit setup algorithm, and the refresh and next algorithms are given below:
• refresh(S, I) = S ⊕ Extract(I)
• next(S) = G(S)
Hence the only diﬀerence between the initial construction of [BH05] is that we dropped the
(truncated) generator G0 inside the refresh procedure that is only needed to ensure the state
pseudo-randomness of their construction. Consider now the simpliﬁed version of the robustness
security model described in Figure 4.4, that we name the ’Simpliﬁed ROB’ model. This security
model is the same as the robustness security model described in Section 3.6, except that the
set-state procedure is not used to challenge the adversary on its capability to distinguish the
state from random.
proc. set-state(S∗)
corrupt ← true
S ← S∗
proc. initialize
S0 ← 0n;
corrupt ← true;
$← {0, 1};
b
parse H as {Di}i∈I
seed $← {0, 1}n;
OUTPUT seed
proc. ﬁnalize(b∗)
IF b = b∗ RETURN 1
ELSE RETURN 0
proc. good-refresh(i)
$← Di;
x
S0 ← refresh(S0, x);
corrupt ← false;
proc. bad-refresh(x)
IF corrupt = true
S0 ← refresh(S0, x);
ELSE ⊥
proc. next-ror
(S, R0) ← next(S)
IF corrupt = true,
RETURN R0
ELSE
$← {0, 1}‘
R1
RETURN Rb
Figure 4.4 – Procedures in Security Game ’Simpliﬁed ROB(H)’
— 56 —
4.2. Recovering and Preserving Security
Following the proof of [BH05], one can prove that the ’Simpliﬁed BH’ construction is robust in
the ’Simpliﬁed ROB’ model. Motivated by this, we give a very strong attack on the ’Simpliﬁed
BH’ construction in our stronger model, for any extractor Extract and generator G. This already
illustrates the main diﬀerence between our models in terms of entropy accumulation.
Consider the following very simple distribution sampler D. At any time period, it simply sets
I = αp (meaning bit α concatenated p times) for a fresh and random bit α, and also sets entropy
estimate γ = 1 and leakage z = ∅. Clearly, D is legitimate, as the min-entropy of I is 1, even
conditioned on the past and the future. Hence, for any entropy threshold γ∗, the simpliﬁed
BH construction must regain security after γ∗ calls to the D-refresh procedure following a state
compromise. Now consider the following simple adversary A attacking the backward security
(and, thus, robustness) of the ’Simpliﬁed BH’ construction. It calls set-state(0n), and then makes
γ∗ calls to D-refresh followed by many calls to next-ror. Let us denote the value of the state S
after j calls to D-refresh by Sj, and let Y (0) = Extract(0p), Y (1) = Extract(1p). Then, recalling
that refresh(S, I) = S ⊕ Extract(I) and S0 = 0n, we see that Sj = Y (α1) ⊕ . . . ⊕ Y (αj), where
α1 . . . αj are random and independent bits. In particular, at any point of time there are only
if j is even, then Sj ∈ {0n, Y (0) ⊕ Y (1)}, and, if j is odd, then
two possible values for Sj:
Sj ∈ {Y (0), Y (1)}. In other words, despite receiving γ∗ random and independent bits from D,
the refresh procedure failed to accumulate more than 1 bit of entropy in the ﬁnal state S∗ = Sγ∗.
In particular, after γ∗ calls to D-refresh, A can simply try both possibilities for S∗ and easily
distinguish real from random outputs with advantage arbitrarily close to 1 (by making enough
calls to next-ror).
This shows that the ’Simpliﬁed BH’ construction is never backward secure in our model, despite
being secure in the ’Simpliﬁed ROB’ model.
4.2 Recovering and Preserving Security
We deﬁne two properties of a pseudo-random number generator with input which are intuitively
simpler to analyze than the full robustness security. We show that these two properties, taken
together, imply robustness.
Recovering Security. The notion of recovering security considers an adversary that compro-
mises the state to some arbitrary value S0, either by asking for the state (get-state), setting it
(set-state) or with the output (next-ror) when the internal state is unsafe. Afterwards, suﬃcient
calls to D-refresh are made to increase the entropy estimate c above the threshold γ∗. The recov-
ering process should make the bit b involved in the next-ror procedure indistinguishable: when
the internal state is considered as safe, the output randomness R should look indistinguishable
from random.
Formally, we consider the security game RECOV for a pseudo-random number generator with
input (setup, refresh, next), whose procedures are described in Figure 4.5.
The security game RECOV is described as follow, with an adversary A, a sampler D, and bounds
qr, γ∗:
1. The challenger generates a seed seed $← setup and a bit b
$← {0, 1} uniformly at random. It
sets σ0 = 0 and for k = 1, . . . , qr, it computes (σk, Ik, γk, zk) ← D(σk−1), initializes k = 0
and sets c = 0 It then gives back the seed and the values γ1, . . . , γqr and z1, . . . , zqr to the
adversary.
2. The adversary gets access to an oracle getinput which on each invocation increments k :=
k + 1 and outputs Ik.
— 57 —
Chapter 4. Robustness of Pseudo-random Number Generators with Inputs
proc. next-ror
(S(0), R(0)) ← next(S)
(S(1), R(1)) $← {0, 1}n+‘
RETURN (S(b), R(b)),
(Ik+1, . . . , Iqr)
proc. initialize(D)
seed $← setup;
σ0 ← 0;
$← {0, 1};
b
FOR k = 1 TO qr DO
(σk, Ik, γk, zk) ← D(σk−1)
END FOR
k ← 0;
OUTPUT seed, (γk, zk)k=1,...,qr
proc. ﬁnalize(b∗)
IF b = b∗ RETURN 1
ELSE RETURN 0
proc. getinput
k ← k + 1
OUTPUT Ik
proc. set-state(S∗)
S ← S∗
c ← 0
proc. D-refresh
k ← k + 1;
S = refresh(S, Ik);
IF c < γ∗,
c = min(c + γk, n)
Figure 4.5 – Procedures in Security Game RECOV(qr, γ∗)
3. At some point the adversary A calls procedure set-state: she sets a chosen internal state
S∗ ∈ {0, 1}n. She then chooses an integer d such that k+d ≤ qr and γk+1+···+γk+d ≥ γ∗,
then calls D-refresh d times: this procedure updates the state S := refresh(S, Ik+j) and
updates c ← c + γk sequentially.
4. Eventually, the challenger sets (S(0), R(0)) ← next(S) and generates (S(1), R(1)) $← {0, 1}n+‘.
It then gives (S(b), R(b)) to the adversary, together with the next inputs Ik+1, . . . , Iqr (if k
was the number of refresh-queries asked up to this point);
5. The adversary A outputs a bit b∗.
The output of the game is the output of the ﬁnalize oracle at the end, which is 1 if the adversary
correctly guesses the challenge bit, and 0 otherwise. Note that the challenge concerns the total
output of the next algorithm. We deﬁne the advantage of the adversary A and sampler D in the
above game as |2 Pr[b∗ = b] − 1|.
Deﬁnition 30 (Recovering Security). A pseudo-random number generator with input (setup,
refresh, next) is said (t, qr, γ∗, ε)-recovering if for any adversary A and sampler D, both running
in time t, the advantage of A in Game RECOV(qr, γ∗) is at most ε.
Preserving Security. This security notion considers a safe internal state. After several calls to
D-refresh with known (and even chosen) inputs, the internal state should remain safe. An initial
state S is generated with entropy n. Then it is refreshed with arbitrary many calls to D-refresh.
This is the preserving process, which should make the bit b involved in the next-ror procedure
indistinguishable: since the internal state is considered as safe, the output randomness R should
look indistinguishable from random.