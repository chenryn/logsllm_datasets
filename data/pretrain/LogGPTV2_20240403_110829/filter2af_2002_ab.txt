        Source : $_GET,
        Sink : echo,
        is_filterxss : False,
    }
也正是因为如此，CodeQL的出现，被许多人认为是跨时代的出现，静态分析从底层的代码分析，需要深入到编译过程中的方式，变成了在平台上巧妙构思的规则语句，或许从现在来说，CodeQL这种先铺好底层的方式并不能直接的看到效果，可幸运的是，作为技术本身而言，我们又有了新的前进方向。
下面的文章，我们就跟着我前段时间的一些短期研究成果，探索一下到底如何实现一个合理的CodeDB。
# 如何实现一个合理的CodeDB呢?
在最早只有Semmle
QL的时候我就翻看过一些paper，到后来的LGTM，再到后来的CodeQL我都有一些了解，后来CodeQL出来的时候，翻看过一些人写的规则都距离CodeQL想要达到的目标相去甚远，之后就一直想要自己试着写一个类似的玩具试试看。这次在更新KunLun-M的过程中我又多次受制于基于AST的数据流分析的种种困难，于是有了这次的计划诞生。
为了践行我的想法，这次我花了几个星期的事件设计了一个简易版本的CodeDB，并基于CodeDB写了一个简单的寻找php反序列化链的工具，工具源码详见:
  * 
在聊具体的实现方案之前，我们需要想明白CodeDB到底需要记录什么？
首先，每一行代码的执行顺序、所在文件是基本信息。其次当前代码所在的域环境、代码类型、代码相关的信息也是必要的条件。
在这个基础上，我尝试使用域定位、执行顺序、源节点、节点类型、节点信息这5个维度作为五元组储存数据。举一个简单的例子：
    test.php
    0){
        echo $b;
    }
上面的代码转化的结果为
    test_php 1 Variable-$a Assignment ArrayOffset-$_GET@a
    test_php 2 if If ['1', '>', '0']
    test_php.if 0 1 BinaryOp-> 0
    test_php.if 1 echo FunctionCall ('$a',)
由于这里我主要是一个尝试，所以我直接依赖SQL来做查询并将分析逻辑直接从代码实现，这里我们直接用sql语句做查询。
    select * from code_db where node_type='FunctionCall' and node_name='echo'
用上述语句查询出echo语句，然后分析节点信息得到参数为`$a`。
然后通过
    select * from code_db where node_locate = 'test_php.if' and node_sort=0 
来获取if的条件信息，并判断为真。
紧接着我们可以通过SQL语句为
    select * from code_db where node_name='$a' and node_type='Assignment' and node_locate like 'test_php%' and node_id >= 4 
得到赋值语句，经过判断就可以得到变量来源于`$_GET`。
当然，逻辑处理远比想像的要复杂，这里我们举了一个简单的例子做实例，通过sort为0记录参数信息和条件信息，如果出现同一个语句中的多条指令，可能会出现sort相同的多个节点，还需要sort和id共同处理...
这里我尝试性的构造了基于五元组的CodeDB生成方案，并通过一些SQL语句配合代码逻辑分析，我们得到了想要扫描结果。事实上，虽然这种基于五元组的CodeDB仍不成熟，但我们的确通过这种方式构造了一种全新的扫描思路，如果CodeDB构造成熟，然后封装一些基础的查询逻辑，我们就可以大幅度解决我在KunLun-M中遇到的许多困境。
# 写在最后
这篇文章用了大量的篇幅解释了什么是基于.QL的扫描方案，聊了聊许多现代代码审计遇到的问题、困境。在这个基础上，我也做了一些尝试，这里讲的这种基于五元组的CodeDB生成方案属于我最近探索的比较有趣的生成方案，在这个基础上，我也探索了一个简单的查询php反序列化的小插件，后续可能花费比较大的代价去做优化并定制一些基础的查询函数，希望这篇文章能给阅读的你带来一些收获。
如果对相应的代码感兴趣，可以持续关注KunLun-M的更新
  * 
# ref
  * 
  * 
  * 
  * 
  * 
  * 
  * 
  * 
  * 
  * 
* * *