t
a
l
o
s
I
e
t
i
S
s
r
e
m
T
i
r
e
l
i
p
m
o
C
-
-
(cid:35) (cid:71)(cid:35)
(cid:35) (cid:71)(cid:35)
(cid:35) (cid:71)(cid:35)
(cid:35) (cid:71)(cid:35)
(cid:35) (cid:71)(cid:35)
(cid:35) (cid:71)(cid:35)
(cid:35) (cid:71)(cid:35)
-
-
-
-
-
-
-
(cid:32)
(cid:32)
(cid:71)(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
-
-
-
r
e
l
i
p
m
o
C
(cid:32)
(cid:32)
(cid:71)(cid:35)
(cid:35)
-
-
-
-
(cid:35)
(cid:35)
(cid:35)
Meltdown-RW* (cid:32) (cid:71)(cid:35)
Meltdown-PK* (cid:32) (cid:71)(cid:35)
Meltdown-BR* (cid:32) (cid:71)(cid:35)
Table 1: Web browser mitigations for Spectre and Meltdown
attacks, for targets inside and outside the attacker’s process.
Symbols show if an attack is mitigated ((cid:32)), partially mitigated ((cid:71)(cid:35)),
not mitigated ((cid:35)), or not applicable (-). Site Isolation mitigates all
applicable same-process attacks, and it depends on other mitiga-
tions for cross-process attacks.
* Only affects browsers that use these hardware features.
mitigating same-process attacks, and it can mitigate attacks
like Spectre-STL that are difﬁcult or costly for compilers to
prevent [37]. For Meltdown attacks that target same-process
data (e.g., Meltdown-RW, which can transiently overwrite
read-only data), Site Isolation applies as well. It is less clear
whether Meltdown-PK and Meltdown-BR [8] are relevant
in the context of the browser, but Site Isolation would miti-
gate them if browsers used protection keys [38] or hardware-
based array bounds checks, respectively.
Site Isolation does not attempt to mitigate attacks target-
ing data in other processes or the kernel, such as the “Out-
side Process” variants in Table 1 and Microarchitectural Data
Sampling (MDS) attacks [40, 57, 66]. Site Isolation can
and must be combined with hardware and OS mitigations
for such attacks to prevent web attackers from leaking data
across process boundaries or from the kernel. For example,
PTI is a widely used mitigation for Meltdown-US, eliminat-
ing kernel memory from the address space of each user pro-
cess [15, 24]. Similarly, microcode updates and avoiding
sibling Hyper-Threads for untrustworthy code may be useful
for mitigating MDS attacks [40, 57, 66].
Ultimately, cross-process and user/kernel boundaries must
fundamentally be preserved by the OS and hardware and
cannot be left to applications to enforce. Within a process,
however, the OS and hardware have much less visibility into
where isolation is needed. Thus, applications that run code
from untrustworthy principals (e.g., browsers) must align
their architectures with OS-enforced abstractions to isolate
these principals. As a result, we have chosen Site Isolation
as the most effective mitigation strategy for Chrome. When
it is enabled, Chrome re-enables SharedArrayBuffer and
other precise timers and removes JavaScript compiler mitiga-
tions, to restore powerful functionality to the web and regain
lost performance.
5.3 Performance
Enabling Site Isolation can affect the browser’s performance,
so we evaluate its effect on memory overhead, latency, and
CPU usage in the wild and in microbenchmarks. We ﬁnd that
the new architecture has low enough overhead to be practical
to deploy.
5.3.1 Observed Workload
We ﬁrst focus on measuring performance in the ﬁeld, be-
cause this more accurately reﬂects real user workloads (e.g.,
many tabs, long-tail sites) than microbenchmarks do. The
data in this section was collected using pseudonymous met-
ric reporting over a two-week period starting October 1,
2018, from desktop and laptop users of Chrome (version 69)
on Windows who have this reporting enabled. We compare
results from equal-sized test and control groups within the
general user population. (These metrics are enabled by de-
fault, but users can opt out during installation or later in set-
tings. Our experimental design and data collection were re-
viewed under Google’s processes.)
Process Count. With Site Isolation, the browser process
must create more renderer processes to keep sites isolated
from each other: at least as many as unique sites open at a
time. Using periodic samples, we found that users had 6.0
unique sites open across the entire browser at the 50th per-
centile of the distribution, and 41.9 unique sites at the 99th
percentile. This only provides a lower bound for the num-
ber of renderer processes; each instance of a site might live
in a separate process. If this were the case, our metrics give
an upper bound estimate of 79.7 processes at the 99th per-
centile. However, thanks to the process sharing heuristics
described in Section 4.1.1, far fewer processes were used in
practice, as shown in Figure 2. At the 50th percentile, the
number of processes increased 43.5% from 4.4 without Site
Isolation to 6.2 with Site Isolation. At the 99th percentile, the
process count increased 50.6% from 35.0 to 52.7 processes.
This indicates that many more processes are needed for Site
Isolation, but also that the process consolidation heuristics
greatly reduce the count at the upper percentiles.
Memory Overhead. On its own, the 50% increase in ren-
derer process count is signiﬁcant, but this does not necessar-
ily translate to an equivalent increase in memory overhead or
performance slowdowns. Site Isolation is effectively divid-
ing an existing workload across more processes, so each ren-
derer process is correspondingly smaller and shorter lived.
In reported metrics, we found that private memory use per
renderer process decreased 51.5% (87.2 MB to 42.3 MB) at
1670    28th USENIX Security Symposium
USENIX Association
Latency. Site Isolation also impacts latency in multiple
ways, from the time it takes to load a page to the responsive-
ness of input events. On one hand, more navigations need
to create new processes, which can incur latency due to pro-
cess startup time. There may also be greater contention for
IPC messages and input event routing, leading to some de-
lays. On the other hand, there is a signiﬁcant amount of new
parallelism possible now that the workload for a given page
can be split across multiple independent threads of execu-
tion. We use observed metrics from the ﬁeld to study the
combined impact of these changes in practice.
Site Isolation signiﬁcantly increased the percentage of
navigations that cross a process boundary, from 5.73% to
56.0%. However, we mask some of the latency of process
creation in Chrome by starting the renderer process in par-
allel with making the network request. Combined with the
increased parallelism of loading cross-site iframes in differ-
ent processes, we see very little change to a key metric for
page load time:
the time from navigation start to the ﬁrst
paint of page content (e.g., text, images, etc) [22]. Across
all navigations, we observe this to increase at most 2.25%
at the 25th percentile (457 ms to 467 ms) and 1.58% (14.6
s to 14.8 s) at the 99th percentile. This metric also bene-
ﬁts from the spare process optimization described in Sec-
tion 4.1.3, which avoids the process startup latency on many
navigations. Without the spare process, this “First Contentful
Paint” time increases 5.1% at the 25th percentile and 2.4%
at the 99th percentile.
If we look closer at various types of navigations, the most
signiﬁcantly affected category is back/forward navigations,
which frequently load pages from the cache without waiting
for the network. This eliminates most of the beneﬁt of paral-
lelizing process startup with the network request. Here, we
see time to First Contentful Paint increase 28.3% (177 ms to
227 ms) at the 25th percentile and 6.8% (4637 ms to 4952
ms) at the 99th percentile. Again, this is better than with-
out using a spare process, in which case we see increases of
40.7% and 12.5% at these percentiles, respectively.
Figure 2: Renderer process count. This graph shows the number
of renderer processes before and after Site Isolation, as well as an
estimated lower and upper bound on process count, controlled by
the amount of process sharing for instances of the same site. Site
Isolation ﬁnds a middle ground between no process sharing and
having at most one process per site.
Figure 3: Total browser memory usage across all processes.
Overall, Site Isolation has a 9-13% overhead.
the 50th percentile and 28.6% (from 714.2 MB to 509.7 MB)
at the 99th percentile. Renderer process lifetime decreased
4.3% at the 50th percentile and 55.5% at the 99th percentile.
This leaves an open question about the overhead of each
process relative to the workload of the process, which de-
termines the total memory use. Figure 3 compares the total
private memory use across all processes (including browser
process, renderer processes, and other types of utility pro-
cesses) with and without Site Isolation. In practice, we see
that total memory use increased only 12.6% at the 25th per-
centile, and only 8.6% at the 99th percentile. This is signif-
icantly lower than the 50% increase in process count might
suggest, indicating that the large number of extra processes
has a relatively small impact on the total memory use of the
browser. We conﬁrmed that this is not due to a change in
workload size: there were no statistically signiﬁcant differ-
ences in page load count, and we saw at most a 1.5% de-
crease in the number of open tabs (at the 99th percentile).
Due to the severity of transient execution attacks and the
drawbacks of other mitigation strategies in Section 5.2, the
Chrome team was willing to accept 9-13% memory overhead
for the security beneﬁts of enabling Site Isolation.
We also looked at the latency impact on input events. The
current implementation uses slow path hit testing for mouse
and touch events over out-of-process iframes, which results
in small increases to input event latency. For key presses,
there are no statistically signiﬁcant differences at the 50th or
99th percentiles, and only a 1.0% latency increase at the 75th
percentile (43.6 ms to 44.0 ms). For mouse scroll update
events, latency increased 1.3% (21.8 ms to 22.1 ms) at the
50th percentile and 8.6% (228.8 ms to 248.6 ms) at the 99th
percentile. For touch scroll update events, latency increased
2.6% (18.4 ms to 18.9 ms) and 10.7% (134.0 ms to 148.3 ms)
at these percentiles. We expect to improve these by updating
hit testing to avoid the slow path in most cases.
CPU Usage. Finally, we study the impact of Site Isolation
on CPU usage. Average CPU usage in the browser pro-
cess increased 8.2% (32.0% to 34.6%) at the 99th percentile,
USENIX Association
28th USENIX Security Symposium    1671
25th50th75th95th99thPercentileRenderer process count020406080255075100No Site IsolationLower bound (# unique sites)Site IsolationUpper bound (no process sharing)353610111828575777398685124131316274PercentileTotal memory  (MB) 0200040006000800025th50th75th95th99thNo Site IsolationWith Site Isolationsports, games, shopping, and home, as well as google.com as
the top overall URL.4 This set provides pages with a range
of cross-site iframe counts, showing how the browser scales
with more processes per page.
Next, we started Chrome version 69.0.3497.100 with a
clean proﬁle, and we loaded each site in a single tab, both
with and without Site Isolation. We report the median of
ﬁve trials for each data point to reduce variability, and we re-
played recorded network data for all runs using WprGo [69].
Our experiments were performed on a Windows 10 desktop
with an Intel Core i7-8700K 3.7 GHz 6-core CPU and 16 GB
RAM. Our data collection script is available online [45].
Figure 4 (a) shows the total browser memory use for each
site, sorted by the number of renderer processes (shown in
parentheses) that each site utilizes when loaded with Site
Isolation. As expected, the relative memory overhead gen-
erally increases with the number of processes, peaking at
89% for wowprogress.com with 10 processes. Sites that use
more memory tend to have smaller relative overhead, as their
memory usage outweighs the cost of extra processes. For
example, a heavier amazon.com site has a 5% overhead com-
pared to seatguru.com’s 31%, even though both require ﬁve
processes. google.com does not have any cross-site iframes
and requires no extra processes, but it shows a 4% increase in
memory use due to the spare process that we maintain with
Site Isolation, as explained in Section 4.1.3.
The overhead seen in these results is signiﬁcantly higher
than the 9-13% overhead we reported from real-world user
workloads in the previous section. This underscores the limi-
tations of microbenchmarks: users tend to have multiple tabs
(four at 50th percentile) and a variety of open URLs. In prac-
tice, this helps reduce memory overhead via process consol-
idation, while iframe-heavy sites like wowprogress.com may
represent only a small part of users’ browsing sessions.
Figure 4 (b) shows time to First Contentful Paint [22] for
each site, to gauge impact on page load time. Most paint
times improve with Site Isolation because the spare process
helps mask process startup costs, which play a larger role
than network latency due to the benchmark’s use of recorded
network trafﬁc. The speedups are not correlated with process
counts; Site Isolation ofﬂoads some of the work from the
main frame into iframe renderers, which may make the main
frame more responsive regardless of process count.
5.4 Compatibility
Site Isolation strives to avoid web-visible changes. For ex-
ample, we found that CORB blocks less than 1% of re-
sponses, most of which are not observable; if it only relied
on content type and not conﬁrmation snifﬁng, it would block
20% of responses [17]. Also, since cross-origin frame in-
teractions had been mostly asynchronous prior to our work,
making these interactions cross-process is largely transpar-
4If a site’s main content required logging in, we picked the next highest-
ranked site.
Figure 4:
(a) Total browser memory usage and (b) Time to
First Contentful Paint for individual sites. Parentheses denote
the number of renderer processes required to load each site with
Site Isolation. Without Site Isolation, each site requires one ren-
derer process.
due to additional IPC messages and coordination across pro-
cesses. While there were more renderer processes, each ren-
derer’s average CPU usage dropped 33.5% (47.7% to 31.8%)
at the 99th percentile, since the workload was distributed
across more processes.
Overall, we found that enabling Site Isolation had a much
smaller performance impact than expected due to the prop-
erties of the workload. Given the importance of mitigating
the attacks in the threat model described in Section 2, the
Chrome team has chosen to keep Site Isolation enabled for
all users on desktop and laptop devices.
5.3.2 Microbenchmarks
We also report microbenchmark results showing the over-
head of Site Isolation on individual web pages when loaded
in a single tab, with nothing else running in the browser.
This setup does not beneﬁt from process consolidation across
multiple tabs as discussed in Section 4.1.1, and hence it is
not representative of the real-world workloads used in the
previous section. However, these measurements establish a
baseline and provide a reproducible reference point for fu-
ture research.
To study a mix of the most popular (likely highly opti-
mized) and slightly less popular sites, we selected the top site
as well as the 50th-ranked site in Alexa categories for news,