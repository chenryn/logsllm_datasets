# 2021 AntCTF x D^3CTF 中Crypto方向题解
##### 译文声明
本文是翻译文章
译文仅供参考，具体内容表达以及含义原文为准。
## 简介
2021 AntCTF x D^3CTF
中共有四道Crypto方向的题目，题目难度适中，本文对这四道题目及本人的解题思路进行介绍，如有错误还请各位师傅指教。
## babyLattice
###  题目分析
这道题的题目如下
    from collections import namedtuple
    PublicKey = namedtuple('PublicKey', ['n', 'b'])
    SecretKey = namedtuple('SecretKey', ['p', 'q', 'A'])
    def gen_key():
        p = random_prime(2^512, lbound=2^511)
        q = random_prime(2^512, lbound=2^511)
        n = p * q
        a11, a12, a21 = [random_prime(2^100) for _ in range(3)]
        a22 = random_prime(2^100)
        while a11 * a22 == a12 * a21:
            a22 = random_prime(2^100)
        A = Matrix(ZZ, [[a11, a12], [a21, a22]])
        a1 = crt([a11, a21], [p, q])
        a2 = crt([a12, a22], [p, q])
        b = a1 * inverse_mod(a2, n) % n
        PK = PublicKey(n, b)
        SK = SecretKey(p, q, A)
        return (PK, SK)
    def encrypt(m, pk):
        assert 0 < m < 2^400
        r = randint(0, 2^400-1)
        c = (pk.b*m + r) % pk.n
        return c
    def decrypt(c, sk):
        a2 = crt([sk.A[0,1], sk.A[1,1]], [sk.p, sk.q])
        s1 = a2 * c % sk.p
        s2 = a2 * c % sk.q
        m, r = sk.A.solve_right(vector([s1, s2]))
        return m
    def test(pk, sk, num=3):
        for _ in range(num):
            m = randint(0, 2^400-1)
            c = encrypt(m, pk)
            mm = decrypt(c, sk)
            assert m == mm
    if __name__ == '__main__':
        from hashlib import sha256
        from secret import m, FLAG
        assert FLAG == 'd3ctf{%s}' % sha256(int(m).to_bytes(50, 'big')).hexdigest()
        PK, SK = gen_key()
        test(PK, SK)
        c = encrypt(m, PK)
        print(f"PK = {PK}")
        print(f"c = {c}")
我们重点看看加密函数
也就是
这样就可以通过`LLL`算法还原出`m`了
###  EXP
    from hashlib import sha256
    n = 69804507328197961654128697510310109608046244030437362639637009184945533884294737870524186521509776189989451383438084507903660182212556466321058025788319193059894825570785105388123718921480698851551024108844782091117408753782599961943040695892323702361910107399806150571836786642746371968124465646209366215361
    b = 65473938578022920848984901484624361251869406821863616908777213906525858437236185832214198627510663632409869363143982594947164139220013904654196960829350642413348771918422220404777505345053202159200378935309593802916875681436442734667249049535670986673774487031873808527230023029662915806344014429627710399196
    c = 64666354938466194052720591810783769030566504653409465121173331362654665231573809234913985758725048071311571549777481776826624728742086174609897160897118750243192791021577348181130302572185911750797457793921069473730039225991755755340927506766395262125949939309337338656431876690470938261261164556850871338570
    A = Matrix(ZZ,[[1,0,b],[0,2^400,c],[0,0,n]])
    A = A.LLL()
    m = int(A[0][0])
    flag = 'd3ctf{%s}' % sha256(int(m).to_bytes(50, 'big')).hexdigest()
    print(flag)
## simpleGroup
###  题目分析
这道题的题目如下
    from random import randint
    from secret import FLAG
    # A gift for key recovery in challenge [babyLattice]
    n = 69804507328197961654128697510310109608046244030437362639637009184945533884294737870524186521509776189989451383438084507903660182212556466321058025788319193059894825570785105388123718921480698851551024108844782091117408753782599961943040695892323702361910107399806150571836786642746371968124465646209366215361
    y = 12064801545723347322936991186738560311049061235541031580807549422258814170771738262264930441670708308259694588963224372530498305648578520552038029773849342206125074212912788823834152785756697757209804475031974445963691941515756901268376267360542656449669715367587909233618109269372332127072063171947435639328
    e = 1928983487
    M = int.from_bytes(FLAG, 'big')
    C = []
    while M != 0:
        m = M % e
        M //= e
        r = randint(0, n-1)
        c = power_mod(y, m, n) * power_mod(r, e, n)
        C.append(c % n)
    print(f"C = {C}")
通过注释我们可以大概猜测`babyLattice`本来是需要分解`n`的，但是因为被非预期了所以又出了这道题目
那么我们回到`babyLattice`题目里面，我们知道的参数实际上只有`b,c,n`，分解`n`应该和`b`有关，通过阅读`b`的生成代码我们可以得到
我们展开后两个式子
也就是
两边相乘得到
展开并变形得到
也就是
由于
所以我们同样可以用`LLL`还原出目标向量，然后使用`factor`进行分解（`a11,a12,a21,a22`它们都是素数）
当分解完毕后，通过猜测它们对应的值来分解`n`，即
得到`p,q`后，我们回来看题目里面的加密，其会对`FLAG`进行取模并分段加密余数，其中`c`的生成公式如下
`r`是随机生成的数字，而`e`可以被分解为`e1`和`e2`两个素数，这两个素数又分别是`p-1`和`q-1`的因子
那么我们可以得到
通过遍历`j`并判断得到的`c'`是不是为模`p`的`e1次剩余`，我们就可以得到`m`模`e1`的值
同样我们也可以用`q`得到`m`模`e2`的值，然后使用`中国剩余定理`即可还原`m`并最终得到`flag`
###  EXP
    n = 69804507328197961654128697510310109608046244030437362639637009184945533884294737870524186521509776189989451383438084507903660182212556466321058025788319193059894825570785105388123718921480698851551024108844782091117408753782599961943040695892323702361910107399806150571836786642746371968124465646209366215361
    b = 65473938578022920848984901484624361251869406821863616908777213906525858437236185832214198627510663632409869363143982594947164139220013904654196960829350642413348771918422220404777505345053202159200378935309593802916875681436442734667249049535670986673774487031873808527230023029662915806344014429627710399196
    c = 64666354938466194052720591810783769030566504653409465121173331362654665231573809234913985758725048071311571549777481776826624728742086174609897160897118750243192791021577348181130302572185911750797457793921069473730039225991755755340927506766395262125949939309337338656431876690470938261261164556850871338570
    A = Matrix(ZZ,[[1,0,b^2],[0,1,b],[0,0,n]])
    A = A.LLL()
    x1 = -A[0][0]
    x3 = A[0][2]
    print(factor(x1))
    print(factor(x3))
    a12 = 1018979931854255696816714991181
    a22 = 1151291153120610849180830073509
    a11 = 1017199123798810531137951821909
    a21 = 207806651167586080788016046729
    print(gcd(b * a12 - a11,n))
    print(gcd(b * a22 - a21,n))
    p = 7669036313101194621345265255994200133006921565596653797956940811601516306410232120057637504305295677357422367597831138570269733177579895994340511712373309
    q = 9102122415165681824420871673621781250311822805618731863628192549895693024247220594372897360668046264863189831887100676431439200352775676467952192600956629
    assert(p * q == n)
    #!/usr/bin/env python
    from Crypto.Util.number import *
    import gmpy2
    p = 7669036313101194621345265255994200133006921565596653797956940811601516306410232120057637504305295677357422367597831138570269733177579895994340511712373309
    q = 9102122415165681824420871673621781250311822805618731863628192549895693024247220594372897360668046264863189831887100676431439200352775676467952192600956629
    n = 69804507328197961654128697510310109608046244030437362639637009184945533884294737870524186521509776189989451383438084507903660182212556466321058025788319193059894825570785105388123718921480698851551024108844782091117408753782599961943040695892323702361910107399806150571836786642746371968124465646209366215361
    y = 12064801545723347322936991186738560311049061235541031580807549422258814170771738262264930441670708308259694588963224372530498305648578520552038029773849342206125074212912788823834152785756697757209804475031974445963691941515756901268376267360542656449669715367587909233618109269372332127072063171947435639328
    e = 1928983487
    e1 = 36493
    e2 = 52859
    def GCRT(mi, ai):
        assert (isinstance(mi, list) and isinstance(ai, list))
        curm, cura = mi[0], ai[0]
        for (m, a) in zip(mi[1:], ai[1:]):
            d = gmpy2.gcd(curm, m)
            c = a - cura
            assert (c % d == 0)
            K = c // d * gmpy2.invert(curm // d, m // d)
            cura += curm * K
            curm = curm * m // d
            cura %= curm
        return (cura % curm, curm) 
    def check(d,p,n):
        if((p - 1) % n == 0):
            return pow(d,(p - 1) // n,p) == 1
        else:
            k = gmpy2.gcd(n, p - 1)
            return pow(d,(p - 1) // k,p) == 1
    def getM(c,e,p):
        for i in range(2,e):
            tmpc = (c * gmpy2.invert(pow(y,i,p),p)) % p
            if check(tmpc,p,e):
                return i
        exit(0)
    C = [63173987757788284988620600191109581820396865828379773315280703314093571300861961873159324234626635582246705378908610341772657840682572386153960342976445563045427986000105931341168525422286612417662391801508953619857648844420751306271090777865836201978470895906780036112804110135446130976275516908136806153488, 9763526786754236516067080717710975805995955013877681492195771779269768465872108434027813610978940562101906769209984501196515248675767910499405415921162131390513502065270491854965819776080041506584540996447044249409209699608342257964093713589580983775580171905489797513718769578177025063630080394722500351718, 37602000735227732258462226884765737048138920479521815995321941033382094711120810035265327876995207117707635304728511052367297062940325564085193593024741832905771507189762521426736369667607865137900432117426385504101413622851293642219573920971637080154905579082646915297543490131171875075081464735374022745371, 1072671768043618032698040622345664216689606325179075270470875647188092538287671951027561894188700732117175202207361845034630743422559130952899064461493359903596018309221581071025635286144053941851624510600383725195476917014535032481197737938329722082022363122585603600777143850326268988298415885565240343957, 27796821408982345007197248748277202310092789604135169328103109167649193262824176309353412519763498156841477483757818317945381469765077400076181689745139555466187324921460327576193198145058918081061285618767976454153221256648341316332169223400180283361166887912012807743326710962143011946929516083281306203120, 27578857139265869760149251280906035333246393024444009493717159606257881466594628022512140403127178174789296810502616834123420723261733024810610501421455454191654733275226507268803879479462533730695515454997186867769363797096196096976825300792616487723840475500246639213793315097434400920355043141319680299224, 29771574667682104634602808909981269404867338382394257360936831559517858873826664867201410081659799334286847985842898792091629138292008512383903137248343194156307703071975381090326280520578349920827357328925184297610245746674712939135025013001878893129144027068837197196517160934998930493581708256039240833145, 33576194603243117173665354646070700520263517823066685882273435337247665798346350495639466826097821472152582124503891668755684596123245873216775681469053052037610568862670212856073776960384038120245095140019195900547005026888186973915360493993404372991791346105083429461661784366706770467146420310246467262823, 5843375768465467361166168452576092245582688894123491517095586796557653258335684018047406320846455642101431751502161722135934408574660609773328141061123577914919960794180555848119813522996120885320995386856042271846703291295871836092712205058173403525430851695443361660808933971009396237274706384697230238104, 61258574367240969784057122450219123953816453759807167817741267194076389100252707986788076240792732730306129067314036402554937862139293741371969020708475839483175856346263848768229357814022084723576192520349994310793246498385086373753553311071932502861084141758640546428958475211765697766922596613007928849964, 13558124437758868592198924133563305430225927636261069774349770018130041045454468021737709434182703704611453555980636131119350668691330635012675418568518296882257236341035371057355328669188453984172750580977924222375208440790994249194313841200024395796760938258751149376135149958855550611392962977597279393428]
    m = 0
    for c in C[::-1]:
        cp = c % p
        cq = c % q
        m1 = getM(cp,e1,p)
        m2 = getM(cq,e2,q)
        mm,lcm = GCRT([e1,e2],[m1,m2])
        print("Get mm: " + hex(mm))
        m *= e
        m += mm
    flag = long_to_bytes(m)
    print(flag)
## EasyCurve
###  题目分析
这道题目的主要部分如下
    import socketserver
    from Crypto.PublicKey import RSA
    from Crypto.Util.number import getPrime , bytes_to_long
    from Curve import MyCurve
    from hashlib import sha256
    import os
    import string
    import random
    import signal
    from secret import flag
    BIT = 2048
    p = 9688074905643914060390149833064012354277254244638141162997888145741631958242340092013958501673928921327767591959476890238698855704376126231923819603296257
    class Task(socketserver.BaseRequestHandler):
        def proof_of_work(self):
            random.seed(os.urandom(8))
            proof = ''.join([random.choice(string.ascii_letters+string.digits) for _ in range(20)])
            _hexdigest = sha256(proof.encode()).hexdigest()
            self.send(f"sha256(XXXX+{proof[4:]}) == {_hexdigest}".encode())
            self.send(b'Give me XXXX: ')
            x = self.recv()
            if len(x) != 4 or sha256(x+proof[4:].encode()).hexdigest() != _hexdigest:
                self.send('wrong')
                return False
            return True
        def recv(self):
            data = self.request.recv(1024)
            return data.strip()
        def send(self, msg, newline=True):
            if isinstance(msg , bytes):
                msg += b'\n'
            else:
                msg += '\n'
                msg = msg.encode()
            self.request.sendall(msg)
        def key_gen(self , bit):
            key = RSA.generate(bit)
            return key
        def ot(self , point):
            x , y = point
            random.seed(os.urandom(8))
            key = self.key_gen(BIT)
            self.send('n = ' + str(key.n))
            self.send('e = ' + str(key.e))
            x0 = random.randint(1 , key.n)
            x1 = random.randint(1 , key.n)
            self.send("x0 = " + str(x0))
            self.send("x1 = " + str(x1))
            self.send("v = ")
            v = int(self.recv())
            m0_ = (x + pow(v - x0, key.d, key.n)) % key.n
            m1_ = (y + pow(v - x1, key.d, key.n)) % key.n
            self.send("m0_ = " + str(m0_))
            self.send("m1_ = " + str(m1_))
        def handle(self):
            signal.alarm(180)
            if not self.proof_of_work():
                return 0