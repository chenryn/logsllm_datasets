the corrupt parties. A bit 𝑏 is chosen randomly, and if 𝑏 = 0, the
value 𝑟0 is returned to the adversary that is generated by running
RComp on the adversary’s randomness commitments and the re-
sponses of the oracle queries. If 𝑏 = 1, then 𝑟1 is sampled uniformly
and returned to the adversary. The adversary outputs a bit 𝑏′ as its
guess. The distributed randomness generation protocol is said to be
T-Indistinguishable Randomness (IND-RAN) if the probability that
𝑏 = 𝑏′ is negligibly close to 1/2. The above intuition is captured in
the formal definition below.
Pr
𝑏 = 𝑏′∧
𝑉 ′ ≠ ∅
pp ← RSetup(1𝜆)
𝑏 ← {0, 1}
𝑉 ← ARGen(pp)(pp)
𝑟0 ← RComp(pp, 𝑉 ∪ 𝑉 ′)
𝑟1 ← {0, 1}𝜆
𝑏′ ← A(pp, 𝑟𝑏)
(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)
Definition 6.2 (T-Indistinguishable Randomness). A dis-
tributed randomness generation protocol ΠDRG satisfies Indistinguish-
able randomness (IND-RAN) with a gap 𝜖  ˜T and for all 𝜆, T ∈ N, and all PPT adversaries A with parallel
running time bounded by T𝜖, it holds that
≤ 1/2 + negl(𝜆)
where 𝑉 ′ denotes the set of answers to queries to the RGen oracle.
We discuss how IND-RAN notion captures standard properties
for randomness generation considered in prior works.
Unpredictability. Prior works consider adversarial machines that
cannot predict any non-trivial information about the final random
value with a non-negligible probability. Our IND-RAN notion mod-
els the stronger notion of computational indistinguishability with
respect to a uniformly sampled string. This trivially implies unpre-
dictability against any T-bounded (but possibly parallel) adversary.
Note that the T condition is necessary, since after time T the ran-
domness is revealed to all participants as the output of the protocol.
Bias-Resistance. A scheme for distributed randomness generation
satisfying our IND-RAN notion also satisfies bias-resistance [68]:
This is because if an adversary can bias the final outcome of the
protocol even by a single bit, it can also distinguish it from a truly
random string with the same probability.
Session 10C: Foundations CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea2672All-but-one corruption. The winning condition in our IND-RAN
notion requires the adversary to query the RGen(pp) at least once,
and its output is included in the computation of the random string.
This models the fact that at least one honest user must be in the
system, while the rest can be corrupt.
6.2 Our Protocol
We present a distributed randomness generation protocol ΠDRG
(Figure 4) where 𝑛 parties 𝑃1, . . . , 𝑃𝑛 jointly compute a random
integer in Z𝑞, for some prime 𝑞. The protocol’s maximum running
time is T and uses our homomorphic CCA timed commitment
(cf. Section 5).
RSetup(1𝜆, 1T): The setup algorithm samples and returns
pp := crs ← TSetup(1𝜆, 1T).
RGen(pp): The randomness generation algorithm does the
following:
• Sample 𝑠 ← Z𝑞.
• Generate a timed commitment (𝑐, 𝜋) ← TCom(crs, 𝑠).
• Output 𝑣 := (𝑐, 𝜋).
RComp(pp, {𝑣1, . . . , 𝑣𝑛}): The distributed randomness
computation algorithm does the following:
• For 𝑖 ∈ [𝑛]:
– Parse each value 𝑣𝑖 := (𝑐𝑖, 𝜋𝑖).
– Check if TVfy(crs, 𝑐𝑖, 𝜋𝑖) ?
• Compute 𝑐∗ ← TEval(crs,+, 𝑐1, . . . , 𝑐𝑛), where + denotes
addition over Z𝑞.
• Force open 𝑟∗ ← TForceOp(crs, 𝑐∗).
• Output 𝑟∗.
= 1, if not discard 𝑣𝑖.
Figure 4: Distributed Randomness Generation protocol
The setup algorithm simply runs the setup of the timed com-
mitment to generate the public parameters. Given that our timed
commitment scheme (cf. Section 5) has a non-interactive transpar-
ent (public-coin) setup, our setup algorithm for ΠDRG inherits the
same. The randomness generation algorithm is run individually by
each party 𝑃𝑖 and internally samples a random integer in Z𝑞 and
generates a timed commitment to such an integer, along with a
proof 𝜋. Finally, the output of the protocol is computed by combin-
ing all timed commitments (such that the corresponding proof 𝜋
verifies) and solving the resulting commitment via the force open
algorithm.
Optimistic Efficiency. In the optimistic case where all the parties
are honest, after everyone broadcasts their randomness commit-
ment, the parties can simply broadcast the openings: The random
integer 𝑠 that they committed to in the timed commitments, and the
random coins used in generating the timed commitment. Parties
can verify the openings in a canonical way, by recomputing the
timed commitments canonically and checking if this is what was
received earlier. The parties can simply add the random integers
from the openings in plain, to compute the final randomness. This
way no party needs to run the force opening algorithm of the timed
commitments, which is the computationally expensive step.
Public Verifiability. The protocol as described above requires all
parties to run the force opening algorithm (which internally runs
T sequential squarings) to output the final randomness. We can
modify our protocol to add efficient verifiability for this computa-
tion if the party computing the squaring operation also produces a
succinct and efficiently verifiable proof of correct computation. This
is exactly the same class of functions that is computed in verifiable
delay functions (VDFs) [11]. Wesolowski [74] gave a construction of
VDF for sequential squaring in the class group setting, where the
user performing the squaring operations can succinctly prove that
the computation was performed correctly. Verifying this proof only
takes logarithmic steps in the number of squarings performed.
Now, even in the pessimistic settings where some party does not
broadcast their opening, only a single party has to run the (expen-
sive) sequential computation and can convince all other participants
of the correctness of the computation.
Scalability. The homomorphism of the timed commitments is ex-
ploited in the distributed randomness computation algorithm: In-
stead of force-opening each of the 𝑛 timed commitments, the homo-
morphic evaluation results in a single timed commitment to force
open. Therefore as 𝑛 increases, the computational cost of comput-
ing the final randomness remains (approximately) the same. This
evaluation operation is very efficient and adds only negligible over-
head, as it only requires 2(𝑛 − 1) group operations for evaluating
over 𝑛 commitments.
Analysis. Our security guarantee is stated formally in the following
theorem. We defer the formal analysis to Appendix F.
Theorem 6.3. Let (TSetup, TCom, TForceOp) be a perfectly bind-
ing CCA timed commitment. Then the protocol ΠDRG has indistin-
guishable randomness.
7 RELATED WORK
Timed Commitments and Time-Lock Puzzles. Time-lock puz-
zles can be constructed in RSA groups assuming the sequentiality
of the squaring operation [66]. Boneh and Naor [13] built on the
above construction to introduce the notion of timed commitments.
The notion of homomorphic time-lock puzzles has been recently
introduced in [55] where it was shown how to build linearly and
multiplicatively homomorphic time-lock puzzles over RSA groups.
In a later work, Brakerski et al. [15] showed how to construct fully
homomorphic time-lock puzzles, additionally assuming multi-key
fully homomorphic encryption. Due to the reliance on RSA groups,
all of these schemes assume a trusted setup to sample the RSA mod-
ulus 𝑁 .2 The notion of non-malleable time-lock puzzles has been
recently explored in a sequence of works [3, 43, 47]. This notion
is intimately related to CCA timed commitments, although all of
the scheme proposed do not support homomorphic operations, nor
they have been implemented. Finally, we mention that time-lock
puzzles can also be constructed from supersingular isogenies [21]
and succinct randomized encodings [7], although the constructions
are significantly less efficient than the RSA-based ones.
2It has been shown [50] that in many cases one can substitute RSA groups with RSA-
UFO group (where the modulus is a large randomly chosen integer), which have the
advantage of having a public-coin setup. It is plausible that a similar approach would
give us homomorphic time-lock puzzles with public-coin setup, however the scheme
would be completely impractical.
Session 10C: Foundations CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea2673Randomness Generation. There has been a long line work study-
ing distributed randomness generation starting from Blum [8] and
Rabin [64] who introduced the notion. Threshold techniques like
threshold publicly-verifiable secret sharing [23, 48, 69, 71] and
threshold signature schemes [22, 45] have been used to generate
randomness in a distributed manner. These proposals require that at
least a majority of the parties are honest. Note that this is inherent,
since no protocol in the standard model (as opposed to approaches
that make timing-like assumptions, such as ours) can yield secure
coin tossing if all-but-one parties are corrupted [33].
Verifiable Random Functions (VRFs) have been used in Algo-
rand [29] and Ouroboros Praos [37] to generate randomness as a
byproduct of their consensus mechanism. However these protocols
fail to achieve strong bias-resistance guarantees as the adversary
could refuse to publish a block if the randomness outcome is unde-
sirable to him [69]. Bonneau et al. [14] and Bentov et al. [5] show
that we can extract almost uniformly distributed bits from a se-
quence of Bitcoin blocks, but the adversary can bias the result as
shown in [61].
Verifiable Delay Functions (VDFs) that have been recently stud-
ied [11, 38, 62, 74] to build bias-resistant and unpredictable random-
ness generation as one of the main applications. Randao [57, 65]
is one such proposal where users contribute randomness in plain
and the aggregation of these values is hashed and used as a starting
point to compute the VDF. Similar protocols where also consid-
ered that use VDFs [20, 51, 68]. However these proposals require
a trusted setup (to generate the RSA modulus 𝑁 ) and even when
all parties are honest (optimistic case), one party still has to com-
pute the delay function. In practice, this means that a specialized
hardware that performs squaring operations is running at all times.
UC secure time-lock puzzles [3] and non-malleable time-lock
puzzles [43] were used to construct coin flipping protocol that
satisfied optimistic efficiency, all-but-one corruption, and public
verifiability. However their protocols do not scale well with the
number of users as their time-lock puzzle constructions do not
support homomorphic evaluation. Moreover, we are not aware of
any implementation of their proposals.
8 EXPERIMENTAL EVALUATION
We implement our CCA Timed commitment construction, run ex-
periments and report the evaluation results here.
Experimental Setup. We have implemented our CCA Timed Com-
mitments using Sagemath with calls to PARI native C Library [60]
for the operations in class groups. All benchmarks were done us-
ing a single thread on a standard laptop (Intel Core i5-6267U @
2.90GHz). Our experiments have been run for security levels of
𝜆 = 112 and 128 bits. The fundamental discriminant Δ𝐾 has there-
fore respective sizes of 1338 bits and 1827 bits following estimates
from [6]. The prime 𝑞 that defines the plaintext space Z𝑞 is set to
have 256 bits, which is a classical target in practice for randomness
generation.
As the prime ˜𝑞 equals 𝐵·2𝜆, it has size 𝛼 = 786 bits (resp. 𝛼 = 1042
bits with 𝜆 = 128). The Elgamal encryptions needed for the NIZK
proof of well-formedness are done in a group ˜G of prime order ˜𝑞
instantiated as a subgroup of Z∗
𝑃 with 𝑃 − 1 = ℓ ˜𝑞 for a ℓ such that
the prime 𝑃 is of size 2048 to have a 112 bit security against DL
Table 1: Communication cost of CCA Timed Commitments.
(H) denotes our heuristic variant.