150
37
27
9
7
439
29
262
FP Keys
FN Keys
TS
126
124
15
12
14
8
1
–
1
18
CV TS
39
0
90
0
0
23
4
0
52
0
0
0
0
3
–
0
7
0
0
1
CV
29
11
7
4
1
0
0
107
3
5
are the only artifact left in the binary that can uniquely iden-
tify classes. Marx performs overwrite analysis which is based
on the heuristic that in a constructor, the vptr of a base class
gets overwritten by that of its derived class and vice versa in a
destructor. Therefore, two vptrs that overwrite each other are
said to be related. It also checks VTable function entries to
take advantage of the possibility that a derived class may not
redeﬁne every virtual function it inherits from its base class.
Therefore, if two VTables contain pointers to the same func-
tion(s) at the same offset, they are said to be related. In order
to improve coverage, Marx also preforms inter-procedural
data ﬂow analysis, which uses forward edge analysis to re-
solve indirect control ﬂow ( to improve coverage for over-
write analysis) and backward edge analysis to take return
values into account. Finally, it performs inter-modular data
ﬂow, which considers hierarchy from libraries to obtain a
more comprehensive result. Even though these heuristics give
strong indication about class relations, Marx only reconstructs
class hierarchy as a plain set, direction of inheritance is not in-
ferred. According to the authors, class relations recovery is a
hard problem in itself and information regarding the direction
of the relation is not available in binaries [20].
We analyzed xalancbmk with Marx, Figure 3 shows its
representation of a subset of the inheritance graph generated.
Marx was able to correctly identify related vptrs, but they
are only grouped into a set. In Figure 4, we show a mapping
between the ground truth and our analysis. The ﬁgure shows
that not only are we able to infer class relations, we are also
able to infer the direction of inheritance correctly. In the
ﬁgure, base classes are above the derived classes and the
broken lines show nodes in the ground truth corresponding to
nodes in our analysis while the solid lines show relationship
between classes.
26          22nd International Symposium on Research in Attacks, Intrusions and DefensesUSENIX AssociationTable 4: Evaluating the amount of class hierarchy information OVT reveals at callsites. Column with “# types with associated
callsites" contains the number of classes that has at least one corresponding callsite, “#overall types recovered + VTable scanning"
contains number of classes recovered from the binary using both callsite information and VTable scanning, “#leaf node" contains
number of classes with no base class, and “#non-leaf node" contains number of classes with at least one base class.
Program
Spidermonkey
Xalanc
Soplex
Povray
Omnetpp
Namd
CplusplusThread
# types with
associated callsites
From Analysis
#overall types recovered
+ VTable scanning
#leaf node
#non-leaf node
#leaf node
GT
#non-leaf node
91
427
23
14
45
0
4
768
847
30
30
104
3
11
19
275
12
6
27
0
0
72
152
11
8
18
0
4
636
668
17
20
85
3
6
171
307
12
12
27
1
5
evaluation reported for this work shows a high number of
false positive and false negative inferred inheritance relation-
ships. Marx [20] uses heuristics to reconstruct class hierarchy,
such as, overwrite analysis, similar VTable entries and return
values. For comprehensive class hierarchy, it also analyzes
libraries used by executables. Even though Marx can infer
relationship with high precision, it ignores the direction of
inheritance.
Fokin et al.
[9] depends on rules including analyzing
VTable sizes, checking for pure virtual functions, checking
for parameters of virtual functions and checking if the vptr of
a class is overwritten by that of another class. However they
are also not able to give precise class hierarchy.
OOAnalyzer [24] combines traditional binary analysis,
symbolic analysis and Prolog-based reasoning to group meth-
ods into classes(for both polymorphic and non-polymorphic
classes). Methods called on the same pointers are identiﬁed
and then reasoning rules are applied to decide if they belong
to the same classes. The authors mentioned that inheritance
can be assigned using class size and VTable sizes. However,
no evaluation was done regarding this , therefore, we cannot
conﬁrm if OOAnalyzer can indeed decide inheritance.
TVIP [10], ensures that a VTable pointer points to the read
only section before it is used, leveraging the fact that VTables
are always located in read only memory. Class hierarchy was
not used. Similarly, VTint [30] is developed on the basis that
all legitimate VTables are stored only in the read only memory.
They identiﬁed the possibility of an attacker reusing existing
VTables which are in read only memory. They suggested that
this can be handled by leveraging class hierarchy information.
TypeArmor [28] determines an approximate number of argu-
ments prepared at callsite and the number of arguments that
a function expects. This information is used to restrict the
functions that any given callsite can target.
Figure 3: Marx’s representation of a subset of the inheritance
graph generated from Xalanc
6 Related Work
6.1 C++ Attacks and Defenses
Due to the use of computed code pointers in dynamic dis-
patch, multiple attacks have targeted C++ programs including
the recent COOP [26] attack that reuses existing virtual func-
tions in order to accomplish malicious computation. With
insufﬁcient semantics in the binary, binary-level solutions –
VTint [30], TVIP [10], vfGuard [21], RECALL [5] introduce
imprecision in the defense. However, source-code based so-
lutions (i.e., [4, 11, 15, 17, 27, 29]) must embed inheritance
information into the binary in order to improve precision and
offer interoperability, and therefore reveal design information.
6.2 C++ Reverse Engineering
VCI [6] reconstructs the class hierarchy of a program using
constructor only analysis. Constructors give useful informa-
tion about inheritance as well as its direction [23], however,
due to constructor inlining, there are inadequate constructors
in the binary to carry out a comprehensive static analysis. The
USENIX Association        22nd International Symposium on Research in Attacks, Intrusions and Defenses 27Figure 4: A mapping between a subset(for the reason of space) of the recovered class hierarchy from the ground truth and our
analysis of Xalanc compiled with OVT.
7 Conclusion
In Summary, we have shown that most modern C++ defenses
1. embed metadata in the binary 2. and the metadata can
be easily recovered. This makes reverse engineering the bi-
nary easier. In order to address this problem, we suggest the
following:
1. Transform the metadata: This can be done either by
encrypting the metadata or randomizing their layout so
that recovering them does not reveal any meaningful
information.
2. Avoid embedding metadata: CFIXX [19] and µCFI [13]
achieve this by dynamically deciding the only valid tar-
get of a callsite. Instead of statically identifying possible
targets of a callsite, CFIXX dynamically tracks object
type using a policy called Object Type Integrity. This
makes it possible to identify the single allowable tar-
get, thereby providing better integrity. Similarly, µCFI
proposes another CFI called Unique Code Target which
relies on Intel Processor Trace to dynamically record
data. This data is used to augment points-to analysis
which is used to identify the only allowable target of a
callsite.
By incorporating design-revealing information in the bi-
nary, modern C++ defenses arguably pose a deterrent to us-
ability in commercial products. While their precision in se-
curity is certainly appealing to the open-source software, it
comes at the cost of privacy, which may not be acceptable in
commercial software.
8 ACKNOWLEDGEMENT
We would like to thank anonymous reviewers for their valu-
able feedback. This research was supported in part by Of-
ﬁce of Naval Research Grant #N00014-17-1-2929, National
Science Foundation Award #1566532, and DARPA award
#81192. Any opinions, ﬁndings and conclusions in this paper
are those of the authors and do not necessarily reﬂect the
views of the funding agencies.
References
[1] “The
IDA Pro Disassembler and Debugger,”
https://www.hex-rays.com/products/ida/.
[2] A Novel Software Toolkit for Graph Edit Distance Com-
putation, 2013.
[3] “Itanium
ABI,”
http://refspecs.linuxbase.org/cxxabi-1.83.html, Revi-
sion: 1.83.
C++
[4] D. Bounov, R. G. Kıcı, and S. Lerner, “Protecting C++
dynamic dispatch through vtable interleaving,” in Pro-
ceedings of the 23rd Annual Network and Distributed
System Security Symposium (NDSS’16), 2016.
[5] D. Dewey and J. T. Gifﬁn, “Static detection of C++
vtable escape vulnerabilities in binary code.” in Pro-
ceedings of 19th Annual Network and Distributed Sys-
tem Security Symposium (NDSS’12), 2012.
[6] M. Elsabagh, D. Fleck, and A. Stavrou, “Strict Virtual
Call Integrity Checking for C++ Binaries,” in Proceed-
ings of the ACM Asia Conference on Computer and
Communications Security (ASIACCS’17), 2017.
[7] S. Fan, L. Xiaokang, X. Yulei, and J. Xiangke, “Boosting
the Precision of Virtual Call Integrity Protection with
Partial Pointer Analysis for C++,” in Proceedings of
the 26th ACM SIGSOFT International Symposium on
Software Testing and Analysis (ISSTA’17), 2017.
28          22nd International Symposium on Research in Attacks, Intrusions and DefensesUSENIX Association[8] A. Fokin, E. Derevenetc, A. Chernov, and K. Troshina,
“SmartDec: Approaching C++ Decompilation,” in 18th
Working Conference on Reverse Engineering (WCRE),
2011.
[9] A. Fokin, K. Troshina, and A. Chernov, “Reconstruction
of class hierarchies for decompilation of C++ programs,”
in 14th European Conference on Software Maintenance
and Reengineering (CSMR), 2010.
[10] R. Gawlik and T. Holz, “Towards Automated Integrity
Protection of C++ Virtual Function Tables in Binary
Programs,” in Proceedings of 30th Annual Computer
Security Applications Conference (ACSAC’14), 2014.
[11] I. Haller, E. Gökta¸s, E. Athanasopoulos, G. Portokalidis,
and H. Bos, “ShrinkWrap: VTable Protection without
Loose Ends,” in Proceedings of the 31st Annual Com-
puter Security Applications Conference (ACSAC’15),
2015.
[12] I. Haller, Y. Jeon, P. Hui, M. Payer, C. Giuffrida, H. Bos,
and E. van der Kouwe, “TypeSan: Practical Type Con-
fusion Detection,” in Proceedings of the 2016 ACM
SIGSAC Conference on Computer and Communications
Security, 2016.
[13] H. Hu, C. Qian, C. Yagemann, S. P. H. Chung, W. R.
Harris, T. Kim, and W. Lee, “Enforcing Unique Code
Target Property for Control-Flow Integrity,” in Proceed-
ings of the 2018 ACM SIGSAC Conference on Computer
and Communications Security, 2018.
[14] R. Ibragimov, M. Malek, J. Guo, and J. Baumbach,
“GEDEVO: An Evolutionary Graph Edit Distance Algo-
rithm for Biological Network Alignment,” in German
Conference on Bioinformatics 2013, 2013.
[15] D. Jang, Z. Tatlock, and S. Lerner, “SafeDispatch: Se-
curing C++ Virtual Calls from Memory Corruption At-
tacks,” in Proceedings of 21st Annual Network and Dis-
tributed System Security Symposium (NDSS’14), 2014.
[16] Y. Jeon, P. Biswas, S. Carr, B. Lee, and M. Payer, “Hex-
Type: Efﬁcient Detection of Type Confusion Errors for
C++,” in Proceedings of the 2017 ACM SIGSAC Confer-
ence on Computer and Communications Security, 2017.
[17] B. Lee, C. Song, T. Kim, and W. Lee, “Type casting
veriﬁcation: Stopping an emerging attack vector,” in
24th USENIX Security Symposium (USENIX Security
15), 2015.
[18] C. Linn and S. Debray, “Obfuscation of executable code
to improve resistance to static disassembly,” in Proceed-
ings of the 10th ACM conference on Computer and com-
munications security (CCS’03), 2003.
[19] Nathan Burow and Derrick McKee and Scott A. Carr and
Mathias Payer, “CFIXX: Object Type Integrity for C++
Virtual Dispatch,” in Proceedings of the 25th Annual
Network and Distributed System Security Symposium
(NDSS’18), 2018.
[20] A. Pawlowski, M. Contag, V. van der Veen, C. Ouwe-
hand, T. Holz, H. Bos, E. Athanasopoulos, and C. Giuf-
frida, “MARX : Uncovering Class Hierarchies in C++
Programs,” in Proceedings of the 24th Annual Network
and Distributed System Security Symposium (NDSS’17),
2017.
[21] A. Prakash, X. Hu, and H. Yin, “vfGuard: Strict Protec-
tion for Virtual Function Calls in COTS C++ Binaries,”
in Proceedings of the 22nd Annual Network and Dis-
tributed System Security Symposium (NDSS’15), 2015.
[22] J.
Under
the
Ray,
“C++:
Hood,”
http://www.openrce.org/articles/ﬁles/jangrayhood.pdf,
1994.
[23] P. V. Sabanal and M. V. Yason, “Reversing C++,” Black-
hat Security Conference, 2007.
[24] E. J. Schwartz, C. F. Cohen, M. Duggan, J. Gennari, J. S.
Havrilla, and C. Hines, “ Using Logic Programming to
Recover C++ Classes and Methods from Compiled Exe-
cutables,” in Proceedings of the 25th ACM Conference
on Computer and Communications Security (CCS’18),
2018.
[25] H. Shacham, “The geometry of innocent ﬂesh on the
bone: Return-into-libc without function calls (on the
x86),” in Proceedings of the 14th ACM conference
on Computer and communications security (CCS’07),
2007.
[26] F. Shuster, T. Tendyck, C. Liebchen, L. Davi, A.-r.
Sadeghi, and T. Holz, “Counterfeit Object-oriented Pro-
gramming, On the Difﬁculty of Preventing Code Reuse
Attacks in C++ Applications,” in Proceedings of 36th
IEEE Symposium on Security and Privacy (Oakland’15),
2015.
[27] C. Tice, T. Roeder, P. Collingbourne, S. Checkoway,
Ú. Erlingsson, L. Lozano, and G. Pike, “Enforcing
Forward-Edge Control-Flow Integrity in GCC &
LLVM,” in Proceedings of 23rd USENIX Security Sym-
posium (USENIX Security’14), 2014.
[28] V. van der Veen, E. Göktas, M. Contag, A. Pawlowski,
X. Chen, S. Rawat, H. Bos, T. Holz, E. Athanasopoulos,
and C. Giuffrida, “A Tough call: Mitigating Advanced
Code-Reuse Attacks At The Binary Level,” in Proceed-
ings of IEEE Symposium on Security and Privacy (Oak-
land’16), 2016.
USENIX Association        22nd International Symposium on Research in Attacks, Intrusions and Defenses 29[29] C. Zhang, S. A. Carr, T. Li, Y. Ding, C. Song, M. Payer,
and D. Song, “VTrust: Regaining Trust on Virtual Calls,”
in Proceedings of the 23rd Annual Network and Dis-
tributed System Security Symposium (NDSS’16), 2016.
[30] C. Zhang, C. Song, Z. K. Chen, Z. Chen, and D. Song,
“VTint: Defending Virtual Function Tables’ Integrity,”
in Proceedings of the 22nd Annual Network and Dis-
tributed System Security Symposium (NDSS’15), 2015.
30          22nd International Symposium on Research in Attacks, Intrusions and DefensesUSENIX Association