Different
from aireplay-ng,
the failure for
0verkill results from an insufﬁcient PT log. As is
speciﬁed in Table 2, the vulnerability corresponding to
this case is an integer overﬂow. To trigger this security
loophole, the PoC used in our experiment aggressively
accumulates an integer variable which makes a PT log
full of arithmetic computation instructions but not the
instruction corresponding to the root cause. As such, we
observe POMP can taint only one instruction pertaining to
the crash. We believe this situation can be easily resolved
if a software developer (or security analyst) can enlarge
the capacity of the PT buffer.
7 Related Work
This research work mainly focuses on locating software
vulnerability from its crash dump. Regarding the tech-
28    26th USENIX Security Symposium
USENIX Association
niques we employed and the problems we addressed, the
lines of works most closely related to our own include
reverse execution and postmortem program analysis. In
this section, we summarize previous studies and discuss
their limitation in turn.
Reverse execution. Reverse execution is a conventional
debugging technique that allows developers to restore the
execution state of a program to a previous point. Pioneer-
ing research [7–9, 13] in this area relies upon restoring
a previous program state from a record, and thus their
focus is to minimize the amount of records that one has
to save and maintain in order to return a program to a
previous state in its execution history. For example, the
work described in [7–9] is mainly based on regenerating
a previous program state. When state regeneration is not
possible, however, it recovers a program state by state
saving.
In addition to state saving, program instrumentation is
broadly used to facilitate the reverse execution of a pro-
gram. For example, Hou et al. designed compiler frame-
work Backstroke [21] to instrument C++ program in
a way that it can store program states for reverse exe-
cution. Similarly, Sauciuc and Necula [30] proposed to
use an SMT solver to navigate an execution trace and
restore data values. Depending on how the solver per-
forms on constraint sets corresponding to multiple test
runs, the technique proposed automatically determines
where to instrument the code to save intermediate values
and facilitate reverse execution.
Given that state saving requires extra memory space
and program instrumentation results in a slower forward
execution, recent research proposes to employ a core
dump to facilitate reverse execution. In [16] and [37],
new reverse execution mechanisms are designed in which
the techniques proposed reversely analyzes code and then
utilizes the information in a core dump to reconstruct the
states of a program prior to its crash. Since the effective-
ness of these techniques highly relies upon the integrity
of a core dump, and exploiting vulnerabilities like buffer
overﬂow and dangling pointers corrupts memory informa-
tion, they may fail to perform reverse execution correctly
when memory corruption occurs.
Different from the prior research works discussed
above, the reverse execution technique introduced in this
paper follows a completely different design principle, and
thus it provides many advantages. First, it can reinstate a
previous program state without restoring that state from a
record. Second, it does not require any instrumentation
to a program, making it more generally applicable. Third,
it is effective in performing execution backward even
though the crashing memory snapshot carries corrupted
data.
Postmortem program analysis. Over the past decades,
there is a rich collection of literature on using program
analysis techniques along with crash reports to identify
faults in software (e.g., [15, 20, 24, 25, 28, 29, 32, 38]).
These existing techniques are designed to identify some
speciﬁc software defects. In adversarial settings, an at-
tacker exploits a variety of software defects and thus they
cannot be used to analyze a program crash caused by a
security defect such as buffer overﬂow or unsafe dangling
pointer. For example, Manevich et al. [24] proposed
to use static backward analysis to reconstruct execution
traces from a crash point and thus spot software defects,
particularly typestate errors [33]. Similarly, Strom and
Yellin [32] deﬁned a partially path-sensitive backward
dataﬂow analysis for checking typestate properties, specif-
ically uninitialized variables. While demonstrated to be
effective, these two studies only focus on speciﬁc types-
tate problems.
Liblit et al. proposed a backward analysis technique for
crash analysis [23]. To be more speciﬁc, they introduce
an efﬁcient algorithm that takes as input a crash point
as well as a static control ﬂow graph, and computes all
the possible execution paths that lead to the crash point.
In addition, they discussed how to narrow down the set
of possible execution paths using a wide variety of post-
crash artifacts, such as stack traces. As is mentioned
earlier, memory information might be corrupted when
attackers exploit a program. The technique described
in [23] highly relies upon the integrity of the informa-
tion resided in memory, and thus fails to analyze program
crash resulting from malicious memory corruption. In this
work, we do not infer program execution paths through
the stack traces recovered from memory potentially cor-
rupted. Rather, our approach identiﬁes the root cause
of software failures by reversely executing program and
reconstructing memory footprints prior to the crash.
Considering the low cost of capturing core dumps, prior
studies also proposed to use core dumps to analyze the
root cause of software failures. Of all the works along this
line, the most typical ones include CrashLocator [35],
!analyze [18] and RETracer [16] which locate soft-
ware defects by analyzing memory information resided
in a core dump. As such, these techniques are not
suitable to analyze crashes resulting from malicious
memory corruption. Different from these techniques,
Kasikci et al. introduced Gist [22], an automated de-
bugging technique that utilizes off-the-shelf hardware to
enhance core dump and then employs a cooperative debug-
ging technique to perform root cause diagnosis. While
Gist demonstrates its effectiveness on locating bugs
from a software crash, it requires the collection of crashes
from multiple parties running the same software and suf-
fering the same bugs. This could signiﬁcantly limit its
adoption. In our work, we introduce a different technical
approach which can perform analysis at the binary level
USENIX Association
26th USENIX Security Symposium    29
without the participation of other parties.
In recent research, Xu et al. [36] introduced CREDAL,
an automatic tool that employs the source code of a crash-
ing program to enhance core dump analysis and turns a
core dump to an informative aid in tracking down mem-
ory corruption vulnerabilities. While sharing a common
goal as POMP– pinpointing the code statements where a
software defect is likely to reside – CREDAL follows a
completely different technical approach. More speciﬁ-
cally, CREDAL discovers the mismatch in variable values
and deems the code fragments corresponding to the mis-
match as the possible vulnerabilities that lead to the crash.
While it has been shown that CREDAL is able to assist soft-
ware developers (or security analysts) in tracking down
a memory corruption vulnerability, in most cases, it still
requires signiﬁcant manual efforts for locating a memory
corruption vulnerability in a crash for the reasons that
the mismatch in variable values may be overwritten or
the code fragments corresponding to mismatch may not
include the root cause of the software crash. In this work,
POMP precisely pinpoints the vulnerability by utilizing
the memory footprints recovered from reverse execution.
8 Discussion
In this section, we discuss the limitations of our current
design, insights we learned and possible future directions.
Multiple threads. POMP focuses only on analyzing the
post-crash artifact produced by a crashing thread. There-
fore, we assume the root cause of the crash is enclosed
within the instructions executed by that thread and other
threads do not intervene the execution of that thread prior
to its crash. In practice, this assumption however may
not hold, and the information held in a post-crash artifact
may not be sufﬁcient and even misleading for root cause
diagnosis.
While this multi-thread issue indeed limits the capabil-
ity of a security analyst using POMP to pinpoint the root
cause of a program crash, this does not mean the failure of
POMP nor signiﬁcantly downgrades the utility of POMP
because of the following. First, a prior study [31] has
already indicated that a large fraction of software crashes
involves only the crashing thread. Thus, we believe POMP
is still beneﬁcial for software failure diagnosis. Second,
the failure of POMP roots in incomplete execution trac-
ing. Therefore, we believe, by simply augmenting our
process tracing with the capability of recording the timing
of execution, POMP can synthesize a complete execution
trace, making POMP working properly. As part of the
future work, we will integrate this extension into the next
version of POMP.
Just-in-Time native code. Intel PT records the addresses
of branching instructions executed. Using these addresses
as index, POMP retrieves instructions from executable and
library ﬁles. However, a program may utilize Just-in-
Time (JIT) compilation in which binary code is generated
on the ﬂy. For programs assembled with this JIT func-
tionality (e.g., JavaScript engine), POMP is less likely to
be effective, especially when a post-crash artifact fails to
capture the JIT native code mapped into memory.
To make POMP handle programs in this type, in the fu-
ture, we will augment POMP with the capability of tracing
and logging native code generated at the run time. For ex-
ample, we may monitor the executable memory and dump
JIT native code accordingly. Note that this extension does
not require any re-engineering of reverse execution and
backward taint analysis because the limitation to JIT na-
tive code also results from incomplete execution tracing
(i. e., failing to reconstruct all the instructions executed
prior to a program crash).
9 Conclusion
In this paper, we develop POMP on Linux system to an-
alyze post-crash artifacts. We show that POMP can sig-
niﬁcantly reduce the manual efforts on the diagnosis of
program failures, making software debugging more infor-
mative and efﬁcient. Since the design of POMP is entirely
on the basis of the information resided in a post-crash
artifact, the technique proposed can be generally applied
to diagnose the crashes of programs written in various
programming languages caused by various software de-
fects.
We demonstrated the effectiveness of POMP using the
real-world program crashes pertaining to 31 software vul-
nerabilities. We showed that POMP can reversely recon-
struct the memory footprints of a crashing program and
accurately identify the program statements (i. e., , instruc-
tions) that truly contribute to the crash. Following this
ﬁnding, we safely conclude POMP can signiﬁcantly down-
size the program statements that a software developer (or
security analyst) needs to manually examine.
10 Acknowledgments
We thank the anonymous reviewers for their helpful feed-
back and our shepherd, Andrea Lanzi, for his valuable
comments on revision of this paper. This work was sup-
ported by ARO W911NF-13-1-0421 (MURI), NSF CNS-
1422594, NSF CNS-1505664, ONR N00014-16-1-2265,
ARO W911NF-15-1-0576, and Chinese National Natural
Science Foundation 61272078.
30    26th USENIX Security Symposium
USENIX Association
References
[1] libdisasm: x86 disassembler library.
http://bastard.
sourceforge.net/libdisasm.html.
[2] Libelf - free software directory. https://directory.fsf.org/
wiki/Libelf.
[3] Linux programmer’s manual. http://man7.org/linux/man-
pages/man7/signal.7.html.
[4] Offensive security exploit database archive. https://www.
exploit-db.com/.
[5] The z3 theorem prover. https://github.com/Z3Prover/z3.
[6] Processor tracing. https://software.intel.com/en-us/blogs/
2013/09/18/processor-tracing, 2013.
[7] T. Akgul and V. J. Mooney, III. Instruction-level reverse
execution for debugging. In Proceedings of the 2002 ACM
SIGPLAN-SIGSOFT Workshop on Program Analysis for
Software Tools and Engineering, 2002.
[8] T. Akgul and V. J. Mooney III. Assembly instruction level
reverse execution for debugging. ACM Trans. Softw. Eng.
Methodol., 2004.
[9] T. Akgul, V. J. Mooney III, and S. Pande. A fast assem-
bly level reverse execution method via dynamic slicing.
In Proceedings of the 26th International Conference on
Software Engineering, 2004.
[10] S. Artzi, S. Kim, and M. D. Ernst. Recrash: Making soft-
ware failures reproducible by preserving object states. In
Proceedings of the 22Nd European Conference on Object-
Oriented Programming, 2008.
[11] G. Balakrishnan and T. Reps. Analyzing memory accesses
in x86 executables. In cc, pages 5–23, 2004.
[17] L. De Moura and N. Bjørner. Z3: An efﬁcient smt solver.
In International conference on Tools and Algorithms for
the Construction and Analysis of Systems, pages 337–340.
Springer, 2008.
[18] K. Glerum, K. Kinshumann, S. Greenberg, G. Aul, V. Or-
govan, G. Nichols, D. Grant, G. Loihle, and G. Hunt.
Debugging in the (very) large: Ten years of implementa-
tion and experience. In Proceedings of the ACM SIGOPS
22Nd Symposium on Operating Systems Principles, 2009.
[19] W. Gu, Z. Kalbarczyk, R. K. Iyer, Z.-Y. Yang, et al. Char-
acterization of linux kernel behavior under errors. In DSN,
volume 3, pages 22–25, 2003.
[20] S. Hangal and M. S. Lam. Tracking down software bugs
using automatic anomaly detection. In Proceedings of the
24th International Conference on Software Engineering,
2002.
[21] C. Hou, G. Vulov, D. Quinlan, D. Jefferson, R. Fujimoto,
and R. Vuduc. A new method for program inversion.
In Proceedings of the 21st International Conference on
Compiler Construction, 2012.
[22] B. Kasikci, B. Schubert, C. Pereira, G. Pokam, and G. Can-
dea. Failure sketching: A technique for automated root
cause diagnosis of in-production failures. In Proceedings
of the 25th Symposium on Operating Systems Principles,
2015.
[23] B. Liblit and A. Aiken. Building a better backtrace: Tech-
niques for postmortem program analysis. Technical report,
2002.
[24] R. Manevich, M. Sridharan, S. Adams, M. Das, and
Z. Yang. Pse: Explaining program failures via postmortem
static analysis. In Proceedings of the 12th ACM SIGSOFT
Twelfth International Symposium on Foundations of Soft-
ware Engineering, 2004.
[12] J. Bell, N. Sarda, and G. Kaiser. Chronicler: Lightweight
recording to reproduce ﬁeld failures. In Proceedings of the
2013 International Conference on Software Engineering,
2013.
[25] D. Molnar, X. C. Li, and D. A. Wagner. Dynamic test
generation to ﬁnd integer bugs in x86 binary linux pro-
grams. In Proceedings of the 18th Conference on USENIX
Security Symposium, 2009.
[13] B. Biswas and R. Mall. Reverse execution of programs.
SIGPLAN Not., 1999.
[14] Y. Cao, H. Zhang, and S. Ding. Symcrash: Selective
recording for reproducing crashes. In Proceedings of the
29th ACM/IEEE International Conference on Automated
Software Engineering, 2014.
[15] H. Cleve and A. Zeller. Locating causes of program fail-
ures. In Proceedings of the 27th International Conference
on Software Engineering, 2005.
[16] W. Cui, M. Peinado, S. K. Cha, Y. Fratantonio, and V. P.
Kemerlis. Retracer: Triaging crashes by reverse execution
from partial memory dumps. In Proceedings of the 38th
International Conference on Software Engineering, 2016.
[26] P. Ohmann. Making your crashes work for you (doctoral
symposium). In Proceedings of the 2015 International
Symposium on Software Testing and Analysis, 2015.
[27] F. Qin, J. Tucek, J. Sundaresan, and Y. Zhou. Rx: treat-
ing bugs as allergies—a safe method to survive software
In ACM SIGOPS Operating Systems Review,
failures.
volume 39, pages 235–248. ACM, 2005.
[28] M. Renieris and S. P. Reiss. Fault localization with nearest
neighbor queries. In Proceedings of IEEE/ACM Interna-
tional Conference on Automated Software Engineering,
2003.
[29] S. K. Sahoo, J. Criswell, C. Geigle, and V. Adve. Using
likely invariants for automated software fault localization.
USENIX Association
26th USENIX Security Symposium    31
In Proceedings of the Eighteenth International Conference
on Architectural Support for Programming Languages and
Operating Systems, 2013.
[30] R. Sauciuc and G. Necula. Reverse execution with con-
straint solving. Technical report, EECS Department, Uni-
versity of California, Berkeley, 2011.
[31] A. SchrÃ˝uter, N. Bettenburg, and R. Premraj. Do stack
traces help developers ﬁx bugs? In Proceedings of the 7th
IEEE Working Conference on Mining Software Reposito-
ries, 2010.
[32] R. E. Strom and D. M. Yellin. Extending typestate check-
ing using conditional liveness analysis. IEEE Transaction
Software Engineering, 1993.
[33] R. E. Strom and S. Yemini. Typestate: A programming
language concept for enhancing software reliability. IEEE
Transaction Software Engineering, 1986.
[34] M. Weiser. Program slicing. In Proceedings of the 5th
international conference on Software engineering, pages
439–449. IEEE Press, 1981.
[35] R. Wu, H. Zhang, S.-C. Cheung, and S. Kim. Crashlocator:
Locating crashing faults based on crash stacks. In Pro-
ceedings of the 2014 International Symposium on Software
Testing and Analysis, 2014.
[36] J. Xu, D. Mu, P. Chen, X. Xing, P. Wang, and P. Liu.
Credal: Towards locating a memory corruption vulnerabil-
ity with your core dump. In Proceedings of the 2016 ACM
SIGSAC Conference on Computer and Communications
Security, 2016.
[37] C. Zamﬁr, B. Kasikci, J. Kinder, E. Bugnion, and G. Can-
dea. Automated debugging for arbitrarily long executions.
In Proceedings of the 14th USENIX Conference on Hot
Topics in Operating Systems, 2013.
[38] A. Zeller. Isolating cause-effect chains from computer
programs. In Proceedings of the 10th ACM SIGSOFT Sym-
posium on Foundations of Software Engineering, 2002.
[39] W. Zhang, J. Lim, R. Olichandran, J. Scherpelz, G. Jin,
S. Lu, and T. Reps. Conseq: detecting concurrency bugs
In ACM SIGPLAN Notices,
through sequential errors.
volume 46, pages 251–264. ACM, 2011.
32    26th USENIX Security Symposium
USENIX Association