k
2d
A
2d
A
B
This hyper-geometric distribution is the one analyzed in [5,
Lemma 5.2] where they showed that
Pr[xi+1 − xi > Δ]  4n2
(1 − δ)2
`
which leads to a code of length
(cid:3) = dmin · (n + 1) = O
´
.
2
) · log(2n/)
(n3/(1 − δ)
· log(2n/)
We obtain a δ-robust ﬁngerprinting code for any δ ∈
[0, 1). This in turn leads to a fully collusion-resistant traitor-
tracing system with constant size ciphertext and private keys
of size (cid:3). The tracing algorithm works by constructing ¯w∗
using experiments RobustTRj and then running the robust
ﬁngerprint tracing algorithm on ¯w∗
.
Sirvent [32, Section 4.3] shows that the method in [5] can
be used to extend a δ-robust fully collusion resistant code
to a δ(cid:4)
-robust t-collusion resistant code (for some δ(cid:4)  t and all polynomial
time adversaries A we have that MH Adv[A, TT (n)](λ) and
TR Adv[A, TT (n, t)](λ) are negligible functions of λ.
In Game 2 we require the pirate decoder PD to be per-
fect and decrypt all well-formed ciphertexts. We discuss
imperfect pirate decoders in Section 4. Deﬁnition 3 easily
generalizes to handle non-perfect decoders as in [4]: simply
change (13) to
Pr[PD(Encrypt(bk , m)) = m] ≥ 1 − δ
for some pre-agreed δ ∈ [0, 1) given to both the challenger
and the adversary.
Also note that we are modeling a stateless (resettable)
pirate decoder — the decoder is just an oracle and maintains
no state between activations. Non stateless decoders were
studied in [18].
Minimal access decoders
The black-box tracing model described above is often called
the full access model — the tracer is given the decryptions
output by PD. When the decoder PD is a tamper resistant
box, such as a music player, the tracer does not get direct
access to decryptions; it only sees whether a given ciphertext
results in music being played or not. To address this issue
we deﬁne a more restricted black-box tracing model called
minimal access tracing. This model is similar to the game
above with the exception that the challenger presents the
tracing algorithm with a more restricted oracle P(·,·) which
takes a message-ciphertext pair as input and outputs:
j
P(m, c) =
1 if PD(c) = m
0 otherwise
P
We then modify Step 4 of Game 2 above so that challenger
(tk , ) to obtain a set S ⊆ {1, . . . , n}. Conse-
runs Trace
quently, in the minimal access game the tracing algorithm
is given far more restricted access to PD. One can argue [3]
that this model accurately captures the problem of tracing
a stateless tamper resistant decoder.
It is not diﬃcult to
see that our tracing algorithm works in the minimal access
model.