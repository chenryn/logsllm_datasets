In Search of an Understandable
[58] Diego Ongaro, Stephen M. Rumble, Ryan Stutsman, John Ousterhout, and Mendel
Rosenblum. 2011. Fast Crash Recovery in RAMCloud. In ACM SOSP (2011).
[59] John K. Ousterhout, Arjun Gopalan, Ashish Gupta, Ankita Kejriwal, Collin Lee,
Behnam Montazeri, Diego Ongaro, Seo Jin Park, Henry Qin, Mendel Rosenblum,
Stephen M. Rumble, Ryan Stutsman, and Stephen Yang. 2015. The RAMCloud
Storage System. ACM Trans. Comput. Syst. 33, 3 (2015).
[60] Parveen Patel, Deepak Bansal, Lihua Yuan, Ashwin Murthy, Albert Green-
berg, David A. Maltz, Randy Kern, Hemant Kumar, Marios Zikos, Hongyu Wu,
Changhoon Kim, and Naveen Karri. 2013. Ananta: Cloud Scale Load Balancing.
In ACM SIGCOMM (2013).
[61] Larry Peterson, Tom Anderson, Sachin Katti, Nick McKeown, Guru Parulkar,
Jennifer Rexford, Mahadev Satyanarayanan, Oguz Sunay, and Amin Vahdat. 2019.
Democratizing the network edge. ACM SIGCOMM Computer Communication
Review 49, 2 (2019).
[62] Zafar Ayyub Qazi, Melvin Walls, Aurojit Panda, Vyas Sekar, Sylvia Ratnasamy,
and Scott Shenker. 2017. A High Performance Packet Core for Next Generation
Cellular Networks. In ACM SIGCOMM (2017).
[63] Shriram Rajagopalan, Dan Williams, and Hani Jamjoom. 2013. Pico replication:
A high availability framework for middleboxes. In ACM SoCC (2013).
[64] Shriram Rajagopalan, Dan Williams, Hani Jamjoom, and Andrew Warfield. 2013.
Split/Merge: System Support for Elastic Execution in Virtual Middleboxes. In
USENIX NSDI (2013).
[65] Arjun Roy, Hongyi Zeng, Jasmeet Bagga, George Porter, and Alex C. Snoeren.
2015. Inside the Social Network‚Äôs (Datacenter) Network. In ACM SIGCOMM
(2015).
[66] Jerome H Saltzer, David P Reed, and David D Clark. 1984. End-to-end arguments
in system design. ACM Transactions on Computer Systems (TOCS) 2, 4 (1984).
[67] Amedeo Sapio, Marco Canini, Chen-Yu Ho, Jacob Nelson, Panos Kalnis,
Changhoon Kim, Arvind Krishnamurthy, Masoud Moshref, Dan Ports, and Pe-
ter Richtarik. 2021. Scaling Distributed Machine Learning with In-Network
Aggregation. (2021).
[68] Karla Saur, Joseph Collard, Nate Foster, Arjun Guha, Laurent Vanbever, and
Michael Hicks. 2016. Safe and flexible controller upgrades for SDNs. In ACM
SOSR (2016).
[69] Rinku Shah, Vikas Kumar, Mythili Vutukuru, and Purushottam Kulkarni. 2020.
TurboEPC: Leveraging Dataplane Programmability to Accelerate the Mobile
Packet Core. In ACM SOSR (2020).
[70] Justine Sherry, Peter Xiang Gao, Soumya Basu, Aurojit Panda, Arvind Krishna-
murthy, Christian Maciocco, Maziar Manesh, Jo√£o Martins, Sylvia Ratnasamy,
Luigi Rizzo, et al. 2015. Rollback-recovery for middleboxes. In ACM SIGCOMM
(2015).
[71] Arjun Singh, Joon Ong, Amit Agarwal, Glen Anderson, Ashby Armistead, Roy
Bannon, Seb Boving, Gaurav Desai, Bob Felderman, Paulie Germano, Anand
Kanagala, Jeff Provost, Jason Simmons, Eiichi Tanda, Jim Wanderer, Urs H√∂l-
zle, Stephen Stuart, and Amin Vahdat. 2015. Jupiter Rising: A Decade of Clos
Topologies and Centralized Control in Google‚Äôs Datacenter Network. In ACM
SIGCOMM (2015).
[72] L. Tang, Q. Huang, and P. P. C. Lee. 2020. SpreadSketch: Toward Invertible and
Network-Wide Detection of Superspreaders. In IEEE INFOCOM 2020 (2020).
[73] Muhammad Tirmazi, Ran Ben Basat, Jiaqi Gao, and Minlan Yu. 2020. Cheetah:
Accelerating Database Queries with Switch Pruning. In ACM SIGMOD.
[74] Robbert van Renesse and Fred B. Schneider. 2004. Chain Replication for Support-
ing High Throughput and Availability. In USENIX OSDI (2004).
[75] Shinae Woo, Justine Sherry, Sangjin Han, Sue Moon, Sylvia Ratnasamy, and Scott
Shenker. 2018. Elastic Scaling of Stateful Network Functions. In USENIX NSDI
(2018).
[76] Jiarong Xing, Wenqing Wu, and Ang Chen. 2021. Ripple: A Programmable,
Decentralized Link-Flooding Defense Against Adaptive Adversaries. In USENIX
Security (2021).
[77] Menghao Zhang, Guanyu Li, Shicheng Wang, Chang Liu, Ang Chen, Hongxin
Hu, Guofei Gu, Qianqian Li, Mingwei Xu, and Jianping Wu. 2020. Poseidon:
Mitigating volumetric ddos attacks with programmable switches. In ISOC NDSS
(2020).
[78] Hang Zhu, Zhihao Bai, Jialin Li, Ellis Michael, Dan RK Ports, Ion Stoica, and
Xin Jin. 2019. Harmonia: Near-linear scalability for replicated storage with
in-network conflict detection. Proceedings of the VLDB Endowment 13, 3 (2019).
236
RedPlane: Enabling Fault-Tolerant Stateful In-Switch Applications
SIGCOMM ‚Äô21, August 23‚Äì27, 2021, Virtual Event, USA
Note: Appendices are supporting material that has
not been peer-reviewed.
A Details of Lazy Snapshotting
Algorithm 1: Lazy snapshotting
/* 1-bit variable indicating the current active buffer
1 active_buffer ‚Üê 0;
*/
/* array of 1-bit variables indicating which buffer has has lastly been
updated for a certain slot
2 last_updated_buffer[0. . . REGISTER_SIZE] ‚Üê 0;
/* two copies of the replicated data structure (e.g., a sketch in this
example)
3 pair sketch [0. . . REGISTER_SIZE] ‚Üê 0;
4 Upon receiving a packet (ùëùùëòùë°):
/* is this the first pkt of a snapshot read burst?
5 if pkt.type = SNAPSHOT_READ and pkt.index = 0 then
/* if so, swap the active buffer
active_buffer ‚Üê swap_active_buffer();
6
7 else
/* if not, get the current active buffer
active_buffer ‚Üê get_active_buffer();
/* which buffer was lastly updated for this index?
8
*/
9 last_updated_buffer_for_index ‚Üê update_last_updated_buffer(pkt.index,active_buffer);
*/
/* for a regular packet
*/
*/
*/
*/
*/
10 if pkt.type = SKETCH_UPDATE then
B P4 Skeleton Code of RedPlane-enabled
Application
As mentioned in ¬ß6 of our paper, we expose RedPlane APIs as
modules in P4. Fig. 16 illustrates how the P4 implementation of
RedPlane-enabled NAT looks like. Developers need to include the
P4 file of RedPlane core APIs (line 1) and the P4 file of their original
application code (line 2). Lines highlighted in red shows initial-
ization and the use of the RedPlane ingress and egress control
block instances (line 5, 9, 20, and 24). And the lines highlighted
in bold blue indicates modules of the original NAT program (line
6 and 11). Since NAT does not update state in the data plane (i.e.,
read-centric), no modification is needed to their original P4 imple-
mentation. Other applications (firewall, load balancer, HH-detector,
etc.) introduced in the paper can be implemented in a similar way.
/* is this the first time this buffer has been touched since we took
*/
a snapshot?
if active_buffer ‚â† last_updated_buffer_for_index then
/* if so, copy data from the inactive buffer before updating */
if active_buffer = 0 then
pkt.result ‚Üê copy_update_and_read_buffer_0(pkt.index, pkt.update);
pkt.result ‚Üê copy_update_and_read_buffer_1(pkt.index, pkt.update);
/* if not, some other packet has touched this buffer since we took a
*/
snapshot, so just do update
else
else
if active_buffer = 0 then
pkt.result ‚Üê update_and_read_buffer_0(pkt.index,pkt.update);
pkt.result ‚Üê update_and_read_buffer_1(pkt.index, pkt.update);
else
11
12
13
14
15
16
17
18
19
20
23
24
25
26
27
28
29
30
31
32
/* for a snapshot read packet
*/
21 else if pkt.type = SNAPSHOT_READ then
22
pkt.update = 0; /* is this the first time this buffer has been touched
since we took a snapshot?
if active_buffer ‚â† last_updated_buffer_for_index then
*/
/* if so, copy data from the inactive buffer before updating */
if active_buffer = 0 then
pkt.result ‚Üê copy_update_and_read_buffer_0(pkt.index, pkt.update);
pkt.result ‚Üê copy_update_and_read_buffer_1(pkt.index, pkt.update);
/* if not, some other packet has touched this buffer since we took a
*/
snapshot, so just do read
else
else
if active_buffer = 0 then
pkt.result ‚Üê update_and_read_buffer_1(pkt.index, pkt.update);
pkt.result ‚Üê update_and_read_buffer_0(pkt.index, pkt.update);
else
Algorithm 1 shows the pseudocode for lazy snapshotting de-
scribed in ¬ß5.4. We implement this logic in P4 to provide a basic
sketch with 64√ó32-bit slots. As explained in ¬ß6, we implement
count-min sketches using three of this sketch.
Figure 16: The main part of P4 implementation of RedPlane-
enabled NAT.
C TLA+ Specification of RedPlane Protocol
We write a TLA+ specification of RedPlane protocol to model-check
its correctness.
237
1234567891011121314151617181920212223242526272829303132333435363738#include"redplane_core.p4" // RedPlane core API#include"nat.p4" // developer‚Äôs NAT programcontrolIngress(headershdr, metadata meta) {RedPlaneIngress() redplane_ingress;NAT_Ingress() nat_ingress;L3_Routing() l3_routing;apply {redplane_ingress.apply(hdr, meta);if(meta.is_normal_pkt== true) {nat_ingress.apply(hdr, meta);}if(meta.is_normal_pkt== true ||meta.is_piggybacked==true) {l3_routing_ingress.apply (hdr, meta);}}}controlEgress(headershdr, metadata meta) {RedPlaneEgress() redplane_egress;apply {if(meta.is_redplane_req== true ||meta.is_redplane_ack== true) {redplane_egress.apply(hdr, meta);}}}Pipeline(IngressParser(),Ingress(),IngressDeparser(),EgressParser(),Egress(),EgressDeparser()) pipe;Switch(pipe) main;238
moduleredplaneprotocolextendsIntegers,Sequences,TLC,FiniteSetsconstantsNULL,SWITCHES,LEASEPERIOD,TOTALPKTSvariablesquery,requestqueue,SwitchPacketQueue,RemainingLeasePeriod,owner,up,active,AliveNum,globalseqnum,pcExists(val)‚àÜ=val6=NULLRequestingSwitches‚àÜ={sw‚ààSWITCHES:Exists(query[sw])‚àßquery[sw].type=‚Äúrequest‚Äù}variablesswitch,q,seqnum,round,upSwitches,sentpktsvars‚àÜ=hquery,requestqueue,SwitchPacketQueue,RemainingLeasePeriod,owner,up,active,AliveNum,globalseqnum,pc,switch,q,seqnum,round,upSwitches,sentpktsiProcSet‚àÜ={‚ÄúStateStore‚Äù}‚à™(SWITCHES)‚à™{‚ÄúLeaseTimer‚Äù}‚à™{‚Äúpktgen‚Äù}Init‚àÜ=Globalvariables‚àßquery=[sw‚ààSWITCHES7‚ÜíNULL]‚àßrequestqueue=hi‚àßSwitchPacketQueue=[sw‚ààSWITCHES7‚Üí0]‚àßRemainingLeasePeriod=[sw‚ààSWITCHES7‚Üí0]‚àßowner=NULL‚àßup=[sw‚ààSWITCHES7‚Üítrue]‚àßactive=[sw‚ààSWITCHES7‚Üífalse]‚àßAliveNum=Cardinality(SWITCHES)‚àßglobalseqnum=0‚àßswitch=NULL‚àßq=NULL‚àßseqnum=[self‚ààSWITCHES7‚Üí0]‚àßround=[self‚ààSWITCHES7‚Üí0]‚àßupSwitches={}‚àßsentpkts=0‚àßpc=[self‚ààProcSet7‚Üícaseself=‚ÄúStateStore‚Äù‚Üí‚ÄúSTARTSTORE‚Äù2self‚ààSWITCHES‚Üí‚ÄúSTARTSWITCH‚Äù2self=‚ÄúLeaseTimer‚Äù‚Üí‚ÄúSTARTTIMER‚Äù2self=‚Äúpktgen‚Äù‚Üí‚ÄúSTARTPKTGEN‚Äù]STARTSTORE‚àÜ=‚àßpc[‚ÄúStateStore‚Äù]=‚ÄúSTARTSTORE‚Äù1239
‚àßpc0=[pcexcept![‚ÄúStateStore‚Äù]=‚ÄúSTOREPROCESSING‚Äù]‚àßunchangedhquery,requestqueue,SwitchPacketQueue,RemainingLeasePeriod,owner,up,active,AliveNum,globalseqnum,switch,q,seqnum,round,upSwitches,sentpktsiSTOREPROCESSING‚àÜ=‚àßpc[‚ÄúStateStore‚Äù]=‚ÄúSTOREPROCESSING‚Äù‚àßifrequestqueue6=hithen‚àßswitch0=Head(requestqueue)‚àßrequestqueue0=Tail(requestqueue)‚àßq0=query[switch0]‚àßifq0.leaserequest=‚Äúnew‚Äùthen‚àßifowner6=NULLthen‚àßpc0=[pcexcept![‚ÄúStateStore‚Äù]=‚ÄúBUFFERING‚Äù]else‚àßpc0=[pcexcept![‚ÄúStateStore‚Äù]=‚ÄúTRANSFERLEASE‚Äù]else‚àßifq0.leaserequest=‚Äúrenew‚Äùthen‚àßpc0=[pcexcept![‚ÄúStateStore‚Äù]=‚ÄúRENEWLEASE‚Äù]else‚àßpc0=[pcexcept![‚ÄúStateStore‚Äù]=‚ÄúSTARTSTORE‚Äù]else‚àßpc0=[pcexcept![‚ÄúStateStore‚Äù]=‚ÄúSTARTSTORE‚Äù]‚àßunchangedhrequestqueue,switch,qi‚àßunchangedhquery,SwitchPacketQueue,RemainingLeasePeriod,owner,up,active,AliveNum,globalseqnum,seqnum,round,upSwitches,sentpktsiTRANSFERLEASE‚àÜ=‚àßpc[‚ÄúStateStore‚Äù]=‚ÄúTRANSFERLEASE‚Äù‚àßquery0=[queryexcept![switch]=[type7‚Üí‚Äúresponse‚Äù]@@([lastseqnum7‚Üíglobalseqnum])]‚àßRemainingLeasePeriod0=[RemainingLeasePeriodexcept![switch]=LEASEPERIOD]‚àßowner0=switch‚àßpc0=[pcexcept![‚ÄúStateStore‚Äù]=‚ÄúSTARTSTORE‚Äù]‚àßunchangedhrequestqueue,SwitchPacketQueue,up,active,AliveNum,globalseqnum,switch,q,seqnum,round,upSwitches,sentpktsiBUFFERING‚àÜ=‚àßpc[‚ÄúStateStore‚Äù]=‚ÄúBUFFERING‚Äù‚àßrequestqueue0=Append(requestqueue,switch)‚àßpc0=[pcexcept![‚ÄúStateStore‚Äù]=‚ÄúSTOREPROCESSING‚Äù]‚àßunchangedhquery,SwitchPacketQueue,RemainingLeasePeriod,owner,up,active,AliveNum,globalseqnum,switch,q,seqnum,round,upSwitches,sentpktsiRENEWLEASE‚àÜ=‚àßpc[‚ÄúStateStore‚Äù]=‚ÄúRENEWLEASE‚Äù‚àßglobalseqnum0=q.writeseq‚àßquery0=[queryexcept![switch]=[type7‚Üí‚Äúresponse‚Äù]@@([lastseqnum7‚Üíglobalseqnum0])]‚àßRemainingLeasePeriod0=[RemainingLeasePeriodexcept![switch]=LEASEPERIOD]2240
‚àßowner0=switch‚àßpc0=[pcexcept![‚ÄúStateStore‚Äù]=‚ÄúSTARTSTORE‚Äù]‚àßunchangedhrequestqueue,SwitchPacketQueue,up,active,AliveNum,switch,q,seqnum,round,upSwitches,sentpktsistatestore‚àÜ=STARTSTORE‚à®STOREPROCESSING‚à®TRANSFERLEASE‚à®BUFFERING‚à®RENEWLEASESTARTSWITCH(self)‚àÜ=‚àßpc[self]=‚ÄúSTARTSWITCH‚Äù‚àß‚à®‚àß(up[self]‚àßSwitchPacketQueue[self]>0)‚àßactive0=[activeexcept![self]=true]‚àßifRemainingLeasePeriod[self]=0then‚àßpc0=[pcexcept![self]=‚ÄúNOLEASE‚Äù]else‚àßpc0=[pcexcept![self]=‚ÄúHASLEASE‚Äù]‚à®‚àßpc0=[pcexcept![self]=‚ÄúSWFAILURE‚Äù]‚àßunchangedactive‚àßunchangedhquery,requestqueue,SwitchPacketQueue,RemainingLeasePeriod,owner,up,AliveNum,globalseqnum,switch,q,seqnum,round,upSwitches,sentpktsiNOLEASE(self)‚àÜ=‚àßpc[self]=‚ÄúNOLEASE‚Äù‚àßquery0=[queryexcept![self]=[type7‚Üí‚Äúrequest‚Äù]@@([leaserequest7‚Üí‚Äúnew‚Äù])]‚àßrequestqueue0=Append(requestqueue,self)‚àßpc0=[pcexcept![self]=‚ÄúWAITLEASERESPONSE‚Äù]‚àßunchangedhSwitchPacketQueue,RemainingLeasePeriod,owner,up,active,AliveNum,globalseqnum,switch,q,seqnum,round,upSwitches,sentpktsiWAITLEASERESPONSE(self)‚àÜ=‚àßpc[self]=‚ÄúWAITLEASERESPONSE‚Äù‚àßquery[self].type=‚Äúresponse‚Äù‚àßseqnum0=[seqnumexcept![self]=query[self].lastseqnum]‚àßquery0=[queryexcept![self]=NULL]‚àßpc0=[pcexcept![self]=‚ÄúHASLEASE‚Äù]‚àßunchangedhrequestqueue,SwitchPacketQueue,RemainingLeasePeriod,owner,up,active,AliveNum,globalseqnum,switch,q,round,upSwitches,sentpktsiHASLEASE(self)‚àÜ=‚àßpc[self]=‚ÄúHASLEASE‚Äù‚àßseqnum0=[seqnumexcept![self]=seqnum[self]+1]‚àßquery0=[queryexcept![self]=[type7‚Üí‚Äúrequest‚Äù]@@([leaserequest7‚Üí‚Äúrenew‚Äù,writeseq7‚Üíseqnum0[self]])]3241
‚àßrequestqueue0=Append(requestqueue,self)‚àßpc0=[pcexcept![self]=‚ÄúWAITWRITERESPONSE‚Äù]‚àßunchangedhSwitchPacketQueue,RemainingLeasePeriod,owner,up,active,AliveNum,globalseqnum,switch,q,round,upSwitches,sentpktsiWAITWRITERESPONSE(self)‚àÜ=‚àßpc[self]=‚ÄúWAITWRITERESPONSE‚Äù‚àßquery[self].type=‚Äúresponse‚Äù‚àßAssert(seqnum[self]=query[self].lastseqnum,‚Äúassertionfailed.‚Äù)‚àßquery0=[queryexcept![self]=NULL]‚àßactive0=[activeexcept![self]=false]‚àßSwitchPacketQueue0=[SwitchPacketQueueexcept![self]=SwitchPacketQueue[self]‚àí1]‚àßpc0=[pcexcept![self]=‚ÄúSTARTSWITCH‚Äù]‚àßunchangedhrequestqueue,RemainingLeasePeriod,owner,up,AliveNum,globalseqnum,switch,q,seqnum,round,upSwitches,sentpktsiSWFAILURE(self)‚àÜ=‚àßpc[self]=‚ÄúSWFAILURE‚Äù‚àßifAliveNum>1‚àßup[self]=truethen‚àßup0=[upexcept![self]=false]‚àßAliveNum0=AliveNum‚àí1‚àßquery0=queryelse‚àßifup[self]=falsethen‚àßup0=[upexcept![self]=true]‚àßquery0=[queryexcept![self]=NULL]‚àßAliveNum0=AliveNum+1else‚àßtrue‚àßunchangedhquery,up,AliveNumi‚àßpc0=[pcexcept![self]=‚ÄúSTARTSWITCH‚Äù]‚àßunchangedhrequestqueue,SwitchPacketQueue,RemainingLeasePeriod,owner,active,globalseqnum,switch,q,seqnum,round,upSwitches,sentpktsiswitch(self)‚àÜ=STARTSWITCH(self)‚à®NOLEASE(self)‚à®WAITLEASERESPONSE(self)‚à®HASLEASE(self)‚à®WAITWRITERESPONSE(self)‚à®SWFAILURE(self)STARTTIMER‚àÜ=‚àßpc[‚ÄúLeaseTimer‚Äù]=‚ÄúSTARTTIMER‚Äù‚àßowner6=NULL‚àßifRemainingLeasePeriod[owner]>0‚àßactive[owner]=falsethen‚àßRemainingLeasePeriod0=[RemainingLeasePeriodexcept![owner]=RemainingLeasePeriod[owner]‚àí1]4242
‚àßowner0=ownerelse‚àßifRemainingLeasePeriod[owner]=0then‚àßowner0=NULLelse‚àßtrue‚àßowner0=owner‚àßunchangedRemainingLeasePeriod‚àßpc0=[pcexcept![‚ÄúLeaseTimer‚Äù]=‚ÄúSTARTTIMER‚Äù]‚àßunchangedhquery,requestqueue,SwitchPacketQueue,up,active,AliveNum,globalseqnum,switch,q,seqnum,round,upSwitches,sentpktsiexpirationTimer‚àÜ=STARTTIMERSTARTPKTGEN‚àÜ=‚àßpc[‚Äúpktgen‚Äù]=‚ÄúSTARTPKTGEN‚Äù‚àßifsentpkts<TOTALPKTSthen‚àßAliveNum‚â•1‚àßupSwitches0={sw‚ààSWITCHES:up[sw]}‚àß‚àÉsw‚ààupSwitches0:SwitchPacketQueue0=[SwitchPacketQueueexcept![sw]=SwitchPacketQueue[sw]+1]‚àßsentpkts0=sentpkts+1‚àßpc0=[pcexcept![‚Äúpktgen‚Äù]=‚ÄúSTARTPKTGEN‚Äù]else‚àßpc0=[pcexcept![‚Äúpktgen‚Äù]=‚ÄúDone‚Äù]‚àßunchangedhSwitchPacketQueue,upSwitches,sentpktsi‚àßunchangedhquery,requestqueue,RemainingLeasePeriod,owner,up,active,AliveNum,globalseqnum,switch,q,seqnum,roundipacketGen‚àÜ=STARTPKTGENNext‚àÜ=statestore‚à®expirationTimer‚à®packetGen‚à®(‚àÉself‚ààSWITCHES:switch(self))Spec‚àÜ=‚àßInit‚àß2[Next]vars‚àßWFvars(statestore)‚àß‚àÄself‚ààSWITCHES:WFvars(switch(self))‚àßWFvars(expirationTimer)‚àßWFvars(packetGen)AtLeastOneAliveSwitch‚àÜ=‚àßAliveNum‚â•1‚àß‚àÉsw‚ààSWITCHES:up[sw]=trueSingleOwnerInvariant‚àÜ=5243
‚àÄsw‚ààSWITCHES:sw6=owner‚áíRemainingLeasePeriod[sw]=0Liveness‚àÜ=‚à®‚àÄsw‚ààSWITCHES:(query[sw]6=NULL‚àßquery[sw].type=‚Äúrequest‚Äù);owner=sw6SIGCOMM ‚Äô21, August 23‚Äì27, 2021, Virtual Event, USA
Daehyeok Kim, Jacob Nelson, Dan R. K. Ports, Vyas Sekar, Srinivasan Seshan
D Testbed
We evaluate RedPlane on a testbed consisting of six commodity
switches (including two programmable ones) and servers, as shown
in Fig. 17.
E Detailed Switch ASIC Resource Utilization
Table 2 shows the additional switch ASIC resource consumption of
RedPlane for 100K concurrent flows (using the P4 compiler‚Äôs out-
put), expressed relative to each application‚Äôs baseline usage. Overall,
there are ample resources remaining to implement other functions
along with RedPlane. RedPlane uses TCAM to implement acknowl-
edgment processing and request timeout management, which need
range matches. In terms of scale vs. number of concurrent flows,
only the SRAM usage would increase proportional to the number
of flows as it stores per-flow information (lease expiration time,
current sequence number, and last acknowledged sequence num-
ber).
Figure 17: Three-layer network testbed for experiments.
Resource
Match Crossbar
Meter ALU
Gateway
SRAM
TCAM
VLIW Instruction
Hash Bits
Additional usage
5.3%
8.3%
9.9%
13.2%
11.8%
5.5%
3.7%
Table 2: Switch ASIC resources used by RedPlane.
244
Core layer(Arista 7060CX)ToRlayer(Arista7060CX)Aggregaon layer(Programmable Arista 7170)