正值或0
0110
VS
V=1
溢出
0111
VC
V=0
无溢出
1000
HI
C=1 且 Z=0
无符号大于
219
---
## Page 245
0
day
续表
安
编码
条件助记符
标志位
含义
全
1001
LS
C=0 且 Z=1
无符号小于或等于
：
1010
GE
N和V相同
有符号大于或等于
软
1011
LT
N和V不相同
有符号小于
件
1100
Z=0且N等于V
有符号大于
漏
洞
1101
LE
Z=1且N不等于V
有符号小于或等于
分
1110
AL
任意
无条件执行（不推荐使用）
析
1111
NV
任意
从不执行（不要使用）
技
术
7.2.4ARM指令寻址方式
第
所谓寻址方式就是处理器根据指令中给出的地址码来寻找物理地址的方式。根据地址码段
2
的不同ARM的寻址方式也有所不同，但对x86汇编有所了解的朋友们对这些寻址方式应该都
版
不陌生，接下来我们对这些寻址方式进行简单的介绍。
1.立即寻址
立即寻址也叫立即数寻址，这是一种特殊的寻址方式，立即寻址指令中的操作码字段后面
的地址码部分就是操作数本身，也就是说，数据就包含在指令当中，取出指令也就取出了可以
立即使用的操作数（立即数）。例如以下指令：
ADDR0.R0.#1:R0-R0+1
ADDR0,R0,#0x3f;R0-R0+0x3f
在以上两条指令中，第二个源操作数即为立即数，要求以“#”为前缀，对于以十六进制
表示的立即数，还要求在“#”后加上“0x”或“&”。
2.寄存器寻址
操作数的值在寄存器中，指令中的地址码字段指出的是寄存器编号，指令执行时直接取出
寄存器值操作。这种寻址方式是各类微处理器经常采用的一种方式，也是一种执行效率较高的
寻址方式。以下指令：
ADDR0，R1，R2R0-R1+R2
该指令的执行效果是将寄存器R1和R2的内容相加，其结果存放在寄存器R0中。
3.寄存器间接寻址
寄存器间接寻址指令中的地址码给出的是一个通用寄存器编号，所需要的操作数保存在寄
存器指定地址的存储单元中，即寄存器为操作数的地址指针。例如，以下指令：
LDR R1,[R2][R1]-R2
STRR0.[R1]:[R1]-R0
在第一条指令中，将R2中的数值作为地址，取出此地址中的数据保存在R1中。第二条
220
---
## Page 246
第
指令将R0的值传送到以R1的值为地址的存储器中。
7
4.基址变址寻址
章
基址寻址是将基址寄存器的内容与指令中给出的偏移量相加，形成操作数的有效地址，基
手
址寻址用于访问基址附近的存储单元，常用于查表，数组操作，功能部件寄存器访问等。采用
机
变址寻址方式的指令常见有以下几种形式，如下所示：
里
的
LDR R0,[R1,#4]:R0-[R1+4]
缓
LDRR0,[R1],#4：R0-[R1]、R1-R1+4
冲
区
第一条指令将寄存器R1的内容加上4形成操作数的有效地址，从而取得操作数存入寄存
溢
器RO中。
出
第二条指令以寄存器R1的内容作为操作数的有效地址，从而取得操作数存入寄存器RO
中，然后，R1的内容自增4个学节。
5.寄存器偏移寻址
寄存器偏移寻址是ARM指令集特有的寻址方式，当第2操作数是寄存器偏移方式时，第
2个寄存器操作数在与第1个操作数结合之前，选择进行移位操作。寄存器偏移寻址方式指令
举例如下：
ANDSR1，R1，R2，LSLR3;R2的值左移R3位，然后和R1相与操作，结果放入R1
6.多寄存器寻址
多寄存器寻址就是一次可以传送几个寄存器值，充许一条指令传送16个寄存器的任何子
集或所有寄存器。例如以下指令：
LDMIARO,(R1,R2,R3,R4}；R1-[R0]R2-[R0+4]R3-[R0+8]R4-[R0+12]
该指令可将连续存储单元的值传送到R1~R4。
7.相对寻址
相对寻址是基址寻址的一种变通，相对寻址以程序计数器PC的当前值为基地址，指令中
的地址标号作为偏移量，将两者相加之后得到操作数的有效地址。以下程序段完成子程序的调
用和返回，跳转指令BL采用了相对寻址方式：
BLNEXT：跳转到子程序NEXT处执行
.....
NEXT
...
MOVPC，LR：从子程序返回
8.堆栈寻址
堆栈是特定顺序进行存取的存储区，操作顺序分为“后进先出”和“先进后出”，堆栈寻
址是隐含的，它使用一个专门的寄存器（堆栈指针）指向一块存储区域（堆栈），指针所指向
221
---
## Page 247
day
的存储单元就是堆栈的栈顶。存储器堆栈可分为两种。
安
向上生长：向高地址方向生长，称为递增堆栈
全
向下生长：向低地址方向生长，称为递减堆栈
：
堆栈指针指向最后压入的堆栈的有效数据项，称为满堆栈（FullStack）：堆栈指针指向下
软
一个要放入的空位置，称为空堆栈（EmptyStack）。这样就有4种类型的堆栈表示递增和递减
件
漏
的满堆栈和空堆栈的各种组合。
洞
·满递增：堆栈通过增大存储器的地址向上增长，堆栈指针指向内含有效数据项的最高
分
地址。指令如LDMFA，STMFA等。
析
·空递增：堆栈通过增大存储器的地址向上增长，堆栈指针指向堆栈上的第一个空位置。
技
术
指令如LDMEA，STMEA等。
第
·满递减：堆栈通过减小存储器的地址向下增长，堆栈指针指向内含有效数据项的最低
地址。指令如LDMFD，STMFD等。
2
·空递减：堆栈通过减小存储器的地址向下增长，堆栈指针指向堆栈下的第一个空位置。
版
指令如LDMED，STMED等。
堆栈寻址指令举例如下：
STMFDSP!，（R1-R7，LR）：将R1~R7，LR入栈。满递减堆栈。
LDMFDSP!，（R1-R7，LR）；数据出栈，放入R1~R7，LR寄存器.满递减堆栈。
7.2.5ARM的函数调用与返回
ARM下面的函数调用与x86下面函数的调用有着相似之处，例如都要保护返回地址、进
入子函数执行、执行完成后根据返回地址返回等一系列操作，但是它们有着许多的不同。ARM
属于RISC指令集，不同于x86的CISC指令集，ARM在函数调用时倾向于寄存器传参数，这
一点与x86的堆栈传参是不同的。一般情况下当参数不超过4个时，系统会使用R0~R4寄存
器进行参数传递，而当参数超过4个时才会借助堆栈进行传递。例如，存在一个函数如下所示。
int test（int a,int b,int c,intd，int e)
intf=a+b+c+d+e;
return f;
当我们通过test（1,2,3，4,5)方式调用它时，前4个参数会分别通过R0~R4传递，第5个参数
会通过堆栈传递，这个调用过程的反汇编代码如下所示。
//test(1,2,3,4,5):
mov
r3,#5
str
[ds]'ex
AOu
r3,#4
mov
r2,#3
mov
r1，#2
222
---
## Page 248
第
mov
r0，#1
7
bl
1test(11364h)1
章
通过上面的反汇编代码我们还可以看到一点特殊之处，就是在调用子函数的时候它不是使
手
用的CALL指令，而是使用了BL指令，这也是ARM的一个特点。在执行BL指令后，R15
机
的值（即函数返回地址）会保存在R14中，进入函数后程序会将R14的值入栈保存。
里
当函数具有返回值时，返回值的传递与x86下也略有区别。我们知道x86下面是使用EAX
的
寄存器传递返回值的，但在ARM下面是没有这个寄存器的。不过不要担心，我们还有很多寄
缓
冲
存器可以使用的，在ARM中返回值是靠RO传递的。依然以前面的test函数为例，函数返回
区
前会将返回值放入RO寄存器中，反汇编代码如下所示。
溢
//intf=a+b+c+d+e;
出
ldr
r2,a,#0x10
ldr
r3，b,#0x14
add
r2,r2,r3
1dr
r3，c，#0x18
add
r2,r2,r3
ldr
r3，d,#0x1c
add
r2,r2,r3
ldr
r3,e，#0x20
Ppe
r3,r2,r3
str
r3,f
//returnf;
ldr
r3.f
str
r3,[sp,#4]
ldr
r0，[sp,#4]
add
8#'ds'ds
ldmia
sp.(sp，pc)
弄好返回值后，CPU就会从栈中取出先前保存的返回地址并赋给R15，进而完成函数的调用。
7.3WindowsMobile上的HelloWorld
作为WindowsCE的重要分支，WindowsMoblie与CE的开发过程和开发环境基本上一致，
我们可以使用eMbeddedVisualC++、VisualStudio.NET等开发环境来进行应用程序开发。接
下来我们先搭建WindowsMobile的开发环境。
首先安装编译环境，在这里我们以VisualStudio.NET2008安装为例，其实安装过程和我
们平时安装.NET没有区别，只是在安装时需要选择“SmartDeviceProgammability”选项，选
择上该选项后我们的VS.NET才具有Mobile程序的编译能力。在VS.NET2008中的C#、VC++、
VB可以用来编译Mobile程序，大家可以根据自己的需求进行选择，如图7.3.1所示。
接下来我们需要安装WindowsMobile的SDK和与手机通信的ActiveSync。这两个软件的安
装过程很简单，两个都是无污染绿色软件，不用担心什么流氓插件，一直点击“下一步”即可。
223
---
## Page 249
0
day
安全：
VisualStudio2008MaintenanceMode
Feature descrphon
软件漏洞分析技术
tVisual St
2008 P
SRO
geTeoh
5Q
种编程语言均可使
7
用，本书中我们将使
用VC++进行演示
al Co+ Tock
CPog
ksece
150G8
Dak.Sir
31GB
13G8
17G8
（第
2
版
Upda
图7.3.1安装VS.NET编译环境
安装好环境后，我们就可以来编写-一个手机上的HelloWorld了。这里我们要编写一个基
于MFC的程序，程序上面有一个按钮，单击按钮可以弹出“HelloWorld”的对话框。
首先我们通过“File一New→Project”菜单来建立一个基于VC++MFC的工程，在新建工
程对话框中点击VisualC++下面的SmartDevice选项，然后在右边选择MFCSmartDevice
Application，如图7.3.2所示。选择好后直接单击“OK”按钮。
Projecl
Projedt types:
Iemplates:
NETFr
ork.3.5
0G
 Vpual C#
G Other Langueges
Visuel Stu
tdter
Wsual C
PMFC Snart Dev
ATL
CLR
MFC Smat Device DuL
General
MFC
My Templotes
选择MFC程序
win32
es
Bame:
Helo_word
C:1Doc
Qwriso
olution:
Create grectory lar solution
Helo_world
[Carcs
图7.3.2建立基于VC++MFC的工程
224
---
## Page 250
第
在弹出的设置向导对话框中，单击“Next”按钮来到Platforms选项界面，在这个界面选
7
择SDK的版本，在这我们选择WindowsMobile6ProfessionalSDK，如图7.3.3所示，选择好
章
后单击“Next”按钮。
然后在ApplicationType选项页将对话框设置为DialogBased模式，编写过MFC程序的朋
手