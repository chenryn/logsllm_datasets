#### [工厂](/软件工程/设计模式/创建型模式.md#工厂模式)
> 当创建一个对象或创建整个聚合时，如果创建工作很复杂，或者暴露了过多的内部结构，则可以使用工厂进行封装。
创建方法要是原子的
工厂应该创建抽象类型 而不是具体类
#### Repository
> 客户需要一种有效的方式来获取对已存在的领域对象的引用
> Repository是一个简单的概念框架，它可用来封装对聚合在数据库的检索技术
- 查询：Specification
对类型进行抽象
充分利用与客户端解耦的优点
将事务的控制权交给客户
工厂与Repository的区别在于工厂聚焦于对象的创建，Repository的中间及结束生命周期，也就是查询已有对象
### 领域建模方法论
#### [CBM](/软件工程/架构/系统设计/架构设计.md#CBM基于模块的业务模型)
#### [SOA](/软件工程/服务计算.md)
#### [UML建模](/软件工程/理论/UML.md)
#### 事件风暴
> 围绕系统事件，定义事件，从而完成对系统的整体建模
参与者：项目干系人
材料：描述命令、实体、领域事件、补充信息的不同颜色贴纸
关注点：某些业务动作或行为（事件）是否会触发下一个业务动作，这个动作（事件）的输入和输出是什么？是谁（实体）发出的什么动作（命令），触发了这个动作（事件）
### 领域事件
一个领域事件将导致进一步的业务操作，在实现业务解耦的同时，还有助于形成完整的业务闭环
![领域事件全流程](/assets/屏幕截图%202021-11-16%20213841.png)
领域事件是实现 [CQRS](/软件工程/微服务/查询.md#CQRS模式)的一种方式
## 重构
为改进蹩脚的模型、实现更深层次模型而进行重构
所以DDD的重构不仅是为了干净的代码，也是为了一个更为一致的模型
重构的时机：
- 设计没有表达出对领域的最新理解
- 重要的概念被隐含分散在设计中了，但是已经有让它变成显式概念的方法了
- 发现一个能让设计更灵活的设计
### 突破
持续重构能不断精进，当达到一定量促成质变，对模型的理解会产生一个突破，从而使模型更加自洽
当然这种突破也意味着大改，对项目来说是一种风险
### 提炼概念
> 将隐式概念转为显式概念
- 有没有一些术语能够简洁地表达出复杂的概念
- 借助领域专家 书籍
- 不断尝试
#### 隐式概念
- 注意约束：使用对象来描述施加在某个对象上的约束
  - Specification 模式就可以用来约束对象状态
```java
QueryWrapper qw = new QueryWrapper()
wq.equals("name", "cxk")
wq.like("address", "%翻斗大街%")
```
Specification 可以用来在验证、查询、创建用来描述必须满足什么规则
- 将过程提炼为领域对象的行为
### 柔性设计
乐于使用 易于修改
使代码更加清晰可以表达领域模型，需要切分多个子域，从小开始，还要尽可能利用已有的形式来使现在与过去自洽
- 模式：Intention-Revealing Interfaces
  - 使用接口来解释代码的意图
- 模式：Side-Effect-Free Function
  - 将操作粗略分为有副作用的命令以及无副作用的查询
- 模式：[Assertion](/软件工程/软件设计/代码质量/防御式编程.md#断言)
  - 声明前置条件与后置条件
- 模式：Conceptual Contour
  - 概念轮廓 将设计元素组织成内聚的单元
- 模式：Standalong Class
  - 类尽可能保持与其他类的低耦合 以此降低依赖带来的复杂度
- 模式：Closure Of Operation 闭合操作
  - 入参类型与出参类型相同 减少了与其他概念的依赖
#### 声明式设计*
把代码写成一种可执行的规则
也就说必须遵守某种预先定义好的规则
基于规则的编程
DSL是一种可以通过声明的方式完成业务的设计
### 使用分析模式
所谓分析模式，就是业务建模中的常见结构，可以理解是业务的设计模式
在重构精进时如果发现合适的分析模式，可以尝试使用，但重要的一点就是对于分析模式中的术语，应该忠于其原来的意义，不要赋予其不同的含义，因为分析模式的术语也是一种通用语言
### 使用[设计模式](/软件工程/设计模式/设计模式.md)
## 战略设计
### 保持模型的完整性
看似相同的概念其实并不是同一个东西，混用了不一致的模型导致软件的不正确性
#### 模式：Bounded Context
限定模型的工作范围，通过封装通用语言和领域对象，提供上下文环境，保证在领域之内的一些术语、业务相关对象等（通用语言）有一个确切的含义
- 子域提出问题 在界限上下文内解决问题
#### 模式：Continuous Integration
- 使用CI快速发现模型的错误
#### 模式：Context Map
![使用该模式描述两个边界上下文之间的关系](/assets/批注%202020-07-26%20152329.png)
![不同模式对相关系统的控制能力](/assets/屏幕截图%202022-05-26%20214451.png)
##### 合并上下文模式
单个界限上下文，两团队如一家人，紧密到无法分开。一切模型要素都是共享的。
##### 模式：Shared Kernel
![两团队之间紧密合作，代码模型可以提取成通用组件共享](/assets/批注%202020-07-26%20152535.png)
##### 模式：Customer/SupplierDevelopment Team
强依赖，上下游系统开发合作顺利，上游团队做出变更要对下游团队负责，使用自动化测试来验证来实现对模型逻辑修改反应迅速，能快速判断是否遵守契约
##### 模式：Conformist
- 使用承诺维护上下游系统关系
一定要跟某上游系统绑定，但别人是主，本系统是从。
##### 模式：Anticorruption Layer
- 封装遗留/外部系统
集成遗留系统，又不能强制老系统更新。新系统要做个适配器层来转换模型.
![防腐层防止别人的模型影响到自身](/assets/批注%202020-07-26%20153136.png)
##### 模式：Separate Way
- 子系统分道扬镳 独立演化
- 集成总是代价高昂 而且又是获益却很小
##### 模式：Open Host Service
- 定义一套Service 暴露给其他系统
##### 模式：Published Language
- 使用一种可文档化的、通用的共享语言作为通信媒介
### 精炼
拆分组件，以便从某种形式提取出最重要的内容
#### 模式：Core Domain
针对核心领域模型进行优化、开发，让高手们都集中在复杂的核心业务，打造领域知识沉淀的闭环
#### 逐步精炼
##### 模式：Gneric Subdomain
降低非核心领域模型的优先级，降低优先级意味着这些模块可以购买，可以被外包，反正不比核心领域受重视，资源也不会向这些模块倾斜太多
##### 模式：Domain Vision Statement
简短描述领域模型及其它所带来的价值
##### 模式：Highlighted Core
标记核心领域模型相关元素
##### 模式：Cohesive Mechanism
当模型的某些行为变得复杂时 将这些行为抽离到一个独立的框架里
##### 模式：Segregated Core
增强Core的内聚性
##### 模式：Abstract Core
对核心领域进一步抽象 降低复杂度
### 大型结构
大型结构使得人们可以从宏观角度讨论及理解整个系统，使用这种结构可以使系统变得更清晰，通过重构来得到这些结构
#### 模式：Evolving Order
让结构随着代码一起演变
##### 模式：System Metaphor
一种促进系统一致性的隐喻，如防火墙之于网络领域，如建筑设计、城市规划之于架构领域
##### 模式：Responsibility Layer
注意系统中的依赖 根据依赖可能会形成自然的层次结构 进而进行抽象成完整的层次结构
##### 模式：Knowledge Level
利用约束来定制系统的行为，使得用户可以通过定义约束的形式来改变系统的行为
##### 模式：Pluggable Component Framework
设计一个可插拔的灵活框架
## 使用误区
- 所有业务都使用DDD
- 照搬全部战术设计方法 忽略战略设计