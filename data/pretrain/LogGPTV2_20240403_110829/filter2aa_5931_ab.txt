    散列的值中有指定对象时返回 `true`，否则则返回 `false`。
    ```ruby
    h = {"a"=>"b", "c"=>"d"}
    p h.value?("b")     #=> true
    p h.has_value?("z") #=> false
    ```
# 查看散列的大小
- `h.size`
- `h.length`
    我们可以用 `length` 方法或者 `size` 方法来查看散列的大小，也就是散列键的数量。
    ```ruby
    h = {"a"=>"b", "c"=>"d"}
    p h.length    #=> 2
    p h.size      #=> 2
    ```
- `h.empty?`
    我们可以用 `empty?` 方法来查看散列的大小是否为 0，也就是散列中是否不存在任何键。
    ```ruby
    h = {"a"=>"b", "c"=>"d"}
    p h.empty?    #=> false
    h2 = Hash.new
    p h2.empty?   #=> true
    ```
# 删除键值
像数组一样，我们也可以成对地删除散列中的键值。
- `h.delete(key)`
    通过键删除用 `delete` 方法。
    ```ruby
    h = {"R"=>"Ruby"}
    p h["R"]    #=> "Ruby"
    h.delete("R")
    p h["R"]    #=> nil
    ```
    `delete` 方法也能使用块。指定块后，如果不存在键，则返回块的执行结果。
    ```ruby
    h = {"R"=>"Ruby"}
    p h.delete("P"){|key| "no #{key}."}    #=> "no P."
    ```
- `h.delete_if{|key, val| … }`
- `h.reject!{|key, val| … }`
    希望只删除符合某种条件的键值的时候，我们可以使用 `delete_if` 方法。
    ```ruby
    h = {"R"=>"Ruby", "P"=>"Perl"}
    p h.delete_if{|key, value| key == "P"}    #=> {"R"=>"Ruby"}
    ```
    另外，虽然 `reject!` 方法的用法与 `delete_if` 方法相同，但当不符合删除条件时，两者的返回值却各异。
    `delete_if` 方法会返回的是原来的散列，而 `reject!` 方法则返回的是 `nil`。
    ```ruby
    h = {"R"=>"Ruby", "P"=>"Perl"}
    p h.delete_if{|key, value| key == "L"}
    #=> {"R"=>"Ruby", "P"=>"Perl"}
    p h.reject!{|key, value| key == "L"}  #=> nil
    ```
# 初始化散列
- `h.clear`
    用 `clear` 方法清空使用过的散列。
    ```ruby
    h = {"a"=>"b", "c"=>"d"}
    h.clear
    p h.size    #=> 0
    ```
    这有点类似于使用下面的方法创建新的散列：
    ```ruby
    h = Hash.new
    ```
    实际上，如果程序中只有一个地方引用 `h` 的话，两者的效果是一样的。不过如果还有其他地方引用 `h` 的话，那效果就不一样了。我们来对比一下下面两个例子.
    ```ruby
    h = {"k1"=>"v1"}
    g = h
    h.clear
    p g  #=> {}
    ```
    ```ruby
    h = {"k1"=>"v1"}
    g = h
    h = Hash.new
    p g  #=> {"k1"=>"v1"}
    ```
    在例 1 中，`h.clear` 清空了 `h` 引用的散列，因此 `g` 引用的散列也被清空，`g` 与 `h` 还是引用同一个散列对象。
    而在例 2 中，程序给 `h` 赋值了新的对象，但 `g` 还是引用原来的散列，也就是说，`g` 与 `h` 分别引用不同的散列对象。
    需要注意的是，这里方法操作的不是变量，而是变量引用的对象。
**处理有两个键的散列**
散列的值也可以是散列，也就是所谓的“散列的散列”，这与数组中的“数组的数组”的用法是一样的。
```ruby
table = {"A"=>{"a"=>"x", "b"=>"y"},
         "B"=>{"a"=>"v", "b"=>"w"} }
p table["A"]["a"]  #=> "x"
p table["B"]["a"]  #=> "v"
```
在本例中，名为 `table` 的散列的值也是散列。因此，这里使用了 `["A"]["a"]` 这种两个键并列的形式来获取值。
# 应用示例：计算单词数量
下面我们用散列写个简单的小程序。在代码中，程序会统计指定文件中的单词数量，并按出现次数由多到少的顺序将其显示出来。
```ruby
# 计算单词数量
count = Hash.new(0)
## 统计单词
File.open(ARGV[0]) do |f|
  f.each_line do |line|
    words = line.split
    words.each do |word|
      count[word] += 1
    end
  end
end
## 输出结果
count.sort{|a, b|
  a[1]  b[1]
}.each do |key, value|
  print "#{key}: #{value}\n"
end
```
首先，在程序第 2 行创建记录单词出现次数的散列 `count`。`count` 的键表示单词，值表示该单词出现的次数。如果键不存在，那么值应该为 0，因此将 `count` 的默认值设为 0。
在程序第 6 行到第 11 行的循环处理中，读取指定的文件，并以单词为单位分割文件，然后再统计各单词的数量。
在程序第 6 行，使用 `each_line` 方法读取每行数据，并赋值给变量 `line`。接下来，在程序第 7 行，使用 `split` 方法分割变量 `line`，将其转换为以单词为单位的数组，然后赋值给变量 `words`。
在程序第 8 行的循环处理中，对 `words` 使用 `each` 方法，逐个取出数组中的单词，然后将各单词作为键，从 `count` 中获取对应的出现次数，并做 +1 处理。
在程序第 15 行的循环处理中，输出统计完毕的出现次数。然后，在程序第 15 行到第 17 行，使用 `sort` 方法的块将单词按出现次数进行排序。
这里有两个关键点。一是使用了 `` 运算符进行排序，另外一点是比较对象使用了数组的第 2 个元素，如 `a[1]`、`b[1]`。
`` 运算符会比较左右两边的对象，检查判断它们的关系是 ``。`` 时结果为正数。另外，之所以使用 `a[1]` 这样的数组，是因为用 `sort` 方法获取 `count` 的对象时，各个值会被作为数组提取出来，如下所示： `[ 单词, 出现次数]`
这样一来，`a[0]` 就表示单词本身，`a[1]` 才表示出现次数。因此，通过比较 `a[1]` 与 `b[1]`，就能实现按出现次数排序。
在程序第 17 行，`each` 方法会将排序后的散列元素逐个取出，然后再在程序第 18 行输出该单词与出现次数。
以上就是整个程序的执行流程，下面就让我们来实际执行一下这个程序，统计 Ruby 的 `README` 文件中各单词出现的次数。
执行示例
```ruby
> ruby word_count.rb README
=: 1
What's: 1
end:: 1
rdoc: 1
 ┊
you: 10
of: 11
Ruby: 1
and: 13
to: 22
the: 23
*: 25
```
根据这个结果我们可以看出，除符号之外，出现最多的单词是“`the`”，总共出现了 23 次。
# 关于散列的键
下面我们来讨论一下用数值或者自己定义的类等对象作为散列的键时需要注意的地方。在下面的例子中，我们首先尝试创建一个以数值为键的散列。
```ruby
h = Hash.new
n1 = 1
n2 = 1.0
p n1==n2     #=> true
h[n1] = "exists."
p h[n1]     #=> "exists."
p h[n2]     #=> nil
```
用 `n1` 可以获取以 `n1` 为键保存的值，但是用与 `n1` 有相同的值的 `n2` 却无法获取。这是由于使用 `n2` 时，无法在散列中找到与之对应的值，因此就返回了默认值 `nil`。
在散列内部，程序会将散列获取值时指定的键，与将值保存到散列时指定的键做比较，判断两者是否一致。这时，判断键是否一致与键本身有着莫大的关系。具体来说，对于两个键 `key1`、`key2`，当 `key1.hash` 与 `key2.hash` 得到的整数值相同，且 `key1.eql?(key2)` 为 true 的时候，就会认为这两个键是一致的。
像本例那样，虽然使用 `==` 比较时得到的结果是一致的，但是，当两个键分别属于 `Fixnum` 类和 `Float` 类的对象时，由于不同类的对象不能判断为相同的键，因此就会产生与期待不同的结果。