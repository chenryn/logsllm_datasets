    ; 把1写入魔法硬件寄存器0x5ff6中。
    ; 将0x6xxx处的RAM映射为ROM中0x1000的位置。
    ; 从而可以实现对主机的堆进行越界操作。:-)
    ; 注意，0x6xxx是可写的，而0x8xxx是只读的，所以我们需要这么干。
    ; 假设0x6xxx地址空间中的偏移量0x160是堆指针，
    ; 那么利用这个堆指针就可以从6502地址0x6160对堆进行读写操作了。
    STA $5ff6
如果你对6502还不是很熟，但愿你能理解这些简洁的操作指令。下面是一些注意事项：
没有指定次数的位移操作。因此，4个LSR（逻辑右移）操作，等效于C语言中的 >> 4。
8位的处理器，不存在16位的寄存器。所以一次简单的16位运算需要被分成两半进行，同时还要处理标志位（SBC为带借位减法）。
当相应ROM上的库被映射为可写后，就要进行一些正常的计算了——将库偏移量增加到对应主机堆指针nes6502_context::mem_page[6]处。这是一个非常精确的内存损坏漏洞，需要等到下一帧才会生效，保证0x6000能精确的指向nes6502_context::mem_page[6]，即我们要映射的任何库偏移量的位置。
**3：在每帧一次的循环中，进行一系列读取/添加/写入操作**
有了6502虚拟地址0x6000指向nes6502_context::mem_page[6]的条件之后，我们就可以开始使用6502操作指令精确读写全部主机堆（栈/BSS/或者是任何可以找到的指针）了。如果我们修改mem_page数组，那么到下一帧访问6502内存时才会生效，所以我们每一帧只简单的做一次内存修改。
读取/添加/写入的一些列操作位于ROM中偏移量为0x20的地方，每个操作都是8字节，如第一个操作：
    50 60 08 60 60 6f ff ff
这个操作代表，从0x6050读取8字节，加上0xffff6f60（符号扩展，这里相当于减法），然后写入到虚拟地址0x6008处。
**4：计算libgstnsf.so中BSS段的地址**
nes6502_context::read_handler指向BSS中的一个对象，是一个位于BSS段开头固定位置的值，而这个值现在已经存储在虚拟地址0x6050中了。我们计算出BSS的起始位置，然后写入到虚拟地址0x6008处，即nes6502_context::mem_page[7]的位置。也就是说，我们把BSS映射到了一个可读可写的6502虚拟地址0x7000处。
**5：修改memset()的GOT表**
在GOT表偏移量0xf8的位置，是memset()的函数指针。这个指针指向glibc，而指针现在被映射到虚拟地址0x70f8处。你知道glic中还有什么相对偏移量固定的函数指针么？system()。通过增加一个固定值到GOT表中的memset()函数指针，我们可以实现后续调用memset()函数时变成调用system()函数。
**6：将nes6502_context::read_handler对象映射到0x7000处**
下面是read_handler的定义；read_handler指针指向一个如下的数组：
    typedef struct
    {
       uint32 min_range, max_range;
       uint8 (*read_func)(uint32 address);
    } nes6502_memread;
下面是数组中的一些记录：
    static nes6502_memread default_readhandler[] = {
      {0x0800, 0x1FFF, read_mirrored_ram},
      {0x4000, 0x4017, apu_read},
      {(uint32) - 1, (uint32) - 1, NULL}
    };
如你所见，这个对象中包含函数指针，很有用处。另外，那些对6502某个虚拟地址进行内存访问操作中会调用的函数指针也很有用。
**7：更改apu_read()的函数指针**
通过访问虚拟地址0x7018，我们现在访问到了read_handler BSS对象的0x18偏移处，存储着读取0x4000 –
0x4017的apu_read()函数指针。我们向该函数指针增加一些偏移量（0x1d0），从而使函数指针指向改变到了apu_reset()函数。你马上就能知道为什么要这么做了！
**8：计算BSS变量apu的地址，再次利用nes6502_context::read_handler中的一个固定相对偏移量**
apu定义如下：
    /* pointer to active APU */
    static apu_t *apu;
通过计算，使虚拟地址0x7000指向apu的值。
**9：将apu指针的值复制到内存中的库映射，以便我们间接引用虚拟地址0x7000上的apu对象**
这里只需要一定程度的间接指针跟随，因为BSS的值只是一个指向堆中实际对象的指针。
**10：将字符串“xcalc”写入到apu对象中**
apu对象的大小还是比较大的：
    typedef struct apu_s
    {
       rectangle_t rectangle[2];
       triangle_t triangle;
       noise_t noise;
       dmc_t dmc;
       uint8 enable_reg;
       apudata_t queue[APUQUEUE_SIZE];
       …
通过向0x70f0进行写入，我们就可以实现对apu结构中偏移量为0xf0的地方进行写入，即queue的缓冲区域。我们将字符串“xcalc”写入到此处。
**11：从0x4000地址处进行读取**
然后就弹出了一个计算器！难道是黑魔法？当然不是，我们之前的步骤中的一系列小心的操作造成了这个计算器的弹出。下面是本步骤背后的一些执行顺序：
1\. 6502从0x4000开始读取。
2\. 这个特殊的内存地址，本来是应该调用apu_read()函数指针来处理读取访问的。
3\. 然而，调用的却是apu_reset()，因为我们之前已经更改了对应的函数指针。
4\. apu_reset()包含这句代码：memset (&apu->queue, 0, APUQUEUE_SIZE * sizeof
(apudata_t));
5\. 但是，我们将memset()函数的GOT表指向了system()函数，并且向apu->queue中写入了字符串“xcalc”。
6\. 因此，执行的是system("xcalc")，然后就弹出了计算器。
一些漏洞利用的附加说明：
在如下一些程序中，该漏洞利用文件一样可以进行工作：
Totem
Rhythmbox（效果太好，以至于会弹出两个计算器）
gst-launch-0.10
nautilus (有可能是启动了一个子进程——totem-video-thumbnailer)
我们不需要考虑堆布局的变化。这些代码能扫描堆中可利用的元数据对象，而不是依靠一个固定的偏移量来定位，因而提供了更大的可靠性。聪明的读者可能会注意，对堆的扫描只能向前进行，并且只能扫描大小约32kB的空间。因此，如果堆抖动导致所有重要的元数据对象都被分配到了ROM数据之前怎么办？这的确有可能，但是在这个例子中并不会造成太大的麻烦。因为NSF解码器运行在一个全新的线程，通常都会分配一个新的堆上，从而在堆布局上较为得当。这样，元数据对象会临时分配到ROM数据之后，因此，通常在堆中也会被放到ROM数据之后。即便如此，如果ROM数据足够大的话，是有可能被放到元数据对象之后的（确切的说，是由于固定的堆大小导致的）。
最后一点关于堆布局的说明，如果需要的话，我们是能做一些堆“修饰”的。例如除了攻击者控制的ROM大小，还有一些不固定长度的文件头字符串（音乐标题等）会被分配到堆上。另外，gstreamer中格式检测的代码非常复杂，有可能提供更多的机会去控制堆的状态。