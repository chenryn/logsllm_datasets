omnetpp
x264
leela
deepsjeng
xalancbmk
exchange2
cactuBSSNlbm
wrf
pop2
imagick nab
Figure 7: Runtime overhead of FLARE on SPEC CPU 2017.
FLARE, the process creation takes on average 61.14 µs (n = 105, σ ¯x
= 0.27). Similarly, there is no difference in the syscall latency. In
both cases, the latency is on average 1.03 µs (n = 105, σ ¯x = 0.006).
For a real-world workload, we evaluated the runtime overhead
using the SPEC CPU 2017 benchmark. We ran the benchmark once
with our mitigation and once without it on an Intel Xeon Silver 4208.
We excluded some benchmarks in both the intspeed and fpspeed
benchmark as they already crashed or did not compile on our vanilla
Linux system. Figure 7 shows the results. As expected by the design
of FLARE, we exhibit next to no runtime overhead.
Module Loading. Next, we evaluated the increase in module load-
ing time. We first establish a baseline by loading and unloading a
simple test module 104 times. We then load the FLARE proof of
concept, which requires removing and re-applying the dummy map-
ping for every module load, thus overapproximating the overhead
of our mitigation. We again load and measure the required time 104
times. We only observe a 4 % increase from 2.39 ms to 2.48 ms per
module load. When implemented in the Linux kernel, the module
memory allocation logic is made aware of the dummy mappings so
that they are treated like free memory. Thus, overheads are avoided
entirely except in cases where the modules have to be re-padded,
where we observe the overheads to be negligible.
Memory. Finally, we analyzed the memory overhead of FLARE,
which is minimal in our proof of concept. We always map the same
dummy page in the paging hierarchy and re-use the same page
directory and page table. We do not need a new PDPT, as we are
working on existing 1 GB ranges. Therefore, we only require one
page each for the new page directory, page table, and one page
to point to. As all these pages are 4 kB, the maximum overhead
is 12 kB. To map huge dummy pages, the maximum overhead is
only increased by 2 MB. The direct-physical map padding with 1 GB
pages does not consume additional memory (cf. Section 4).
5.2 Mitigate Microarchitectural KASLR Breaks
In a first step, we evaluated the effectiveness of FLARE in prevent-
ing breaking the randomization of the kernel text segment. Using
a vanilla Linux 5.0 kernel, we test microarchitectural attacks on
KASLR that are not mitigated through orthogonal countermeasures
(cf. Section 3.5) with KPTI disabled (cf. Figure 8). In all cases, we first
establish a baseline of the attack without FLARE in place, which
shows the exact position of the kernel with all attacks.
We then load FLARE and re-evaluate all attacks. We see for
each attack that the kernel can no longer be distinguished from
other positions. With EchoLoad (Figure 8a), all offsets are backed
by a physical page, the load succeeds, but the CPU returns zero
for the illegal access. The stall percentage is based on cache hits
and misses on the probe array, not performance counter values.
With the prefetch side channel (Figure 8b), we see that the prefetch
instruction can now also prefetch all other possible locations, miti-
gating the KASLR break. Data Bounce (Figure 8c) also no longer
distinguishes kernel locations from dummy mappings as store-to-
load forwarding works for all possible offsets. The double-page
fault (Figure 8d) as well as the DrK attack (Figure 8e) also do not
work anymore, exhibiting the same timing across the whole address
range. With Fallout (Figure 8f), we also see no difference anymore
as every page allows to trigger the WTF effect. An attack that tries
to detect our dummy mapping based on timing the page-table walk
is also not possible. Even though the physical page is shared across
all dummy mappings, a TLB entry for one mapping is not shared
with another. Hence, each access to a new page requires a full page-
table walk. Our dummy mapping can also not be uncoverd via the
cache as an access to a privileged address does not load the data
into it [42, 76, 79]. Based on the results shown in Figure 8, none of
the currently known microarchitectural attacks that are not mit-
igated through orthogonal countermeasures (cf. Section 3.5) can
de-randomize the kernel location despite FLARE. This empirically
confirms that we solve challenge C1.
Next, we de-randomize the kernel based on the timing difference
between executable and NX pages [49]. We confirm that tackling
only C1 and C2 is insufficient (cf. Figure 9). However, full FLARE
(cf. Figure 9) separates the regions and the switch from executable
to NX is not visible in this region anymore but at the pre-defined
start of the randomization range (cf. Figure 6).
Next, we used the prefetch side-channel attack to try to break
KASLR based on different page sizes. The different levels visible in
the default case of Figure 8b show the different paging levels for
the address we test. If nothing is mapped in the PML4, we observe
the highest time. There is a drop in the access time for addresses
with no PDPT entry, and another drop for addresses that map to
an entry in the page table, i.e., a 4 kB page. Thus, the prefetch side
channel shows the different paging levels [32]. With FLARE in place,
we can no longer see the difference in page sizes as all possible
locations as well as the kernel are mapped using 4 kB pages. Thus,
we empirically confirmed that our strategy for C3 works, defeating
microarchitectural attacks on KASLR based on different page sizes.
6 RELATED WORK
With the advent of KASLR, many different attacks have been pro-
posed to break KASLR. One problem is that the kernels of the major
OSs cannot change the randomization at runtime. Hence, if an
attacker knows the KASLR offset, it is valid until the next time
the OS is rebooted. So far, most of the attacks on KASLR relied
either on software vulnerabilities or side-channel attacks on the
microarchitecture as discussed in Section 3.5.
6.1 Software-based KASLR Breaks
On Linux, parts of kernel pointers are often disclosed inadvertently
through kernel interfaces, e.g., due to uninitialized structure fields
or structure padding [84]. There have been many such software vul-
nerabilities in kernels (e.g., CVE-2012-6138, CVE-2013-1825, 1826,
1827, 1873, 2634, 2635, 2636) that revealed parts of kernel addresses.
Similarly, for Windows, multiple methods leak kernel pointers, e.g.,
]
%
[
s
l
l
a
t
S
e
m
i
t
t
l
u
a
f
-
e
g
a
P
100
50
0
-16 -8
8
16 24 32 40
0
Kernel offset [MB]
(a) EchoLoad
2,960
2,940
2,920
2,900
-16 -8
8
16 24 32 40
0
Kernel offset [MB]
e
m
i
t
h
c
t
e
f
e
r
P
e
m
i
t
X
S
T
500
400
300
200
100
-16 -8
340
320
300
280
260
-16 -8
8
16 24 32 40
0
Kernel offset [MB]
(b) Prefetch [32]
8
16 24 32 40
0
Kernel offset [MB]
s
n
o
i
t
i
t
e
p
e
R
30
20
10
0
-16 -8
8
16 24 32 40
0
Kernel offset [MB]
]
%
[
s
s
e
c
c
u
s
F
T
W
(c) Data Bounce [76]
100
50
0
-16 -8
8
16 24 32 40
0
Kernel offset [MB]
(d) Double page fault [37]
(e) DrK [49]
(f) Fallout [9]
Figure 8: Detecting the kernel (offset 0 to 32 MB) with all known microarchitectural attacks on KASLR without FLARE (
and with FLARE (
). For all attacks, FLARE successfully prevents the detection of the kernel.
)
170
160
150
140
e
m
i
t
X
S
T
Kernel
Text
Read-only
Data
0
8
16
24
Kernel offset [MB]
170
160
150
140
e
m
i
t
X
S
T
Kernel
Text
0
8
16
24
Kernel offset [MB]
Figure 9: DrK [49] distinguishes executable from NX pages.
An attacker can observe the switch to NX pages directly after
the executable pages (left), when tackling only C1 and C2
(
) FLARE. With full FLARE
(right), this attack is also fully mitigated.
) and entirely without (
using the Win32ThreadInfo or the Desktop heap [74]. Other at-
tacks on KASLR relied on the fact that kernel addresses were used as
unique identifiers [84], or as seed for pseudo-random numbers [52].
For debugging reasons, kernel addresses were often visible in log
files or debugging interfaces such as the perf subsystem [18].
6.2 Mitigating Software-based KASLR Attacks
While software bugs causing KASLR breaks can be easily fixed,
there are also general concepts for preventing address leakage from
the kernel. Linux introduced a setting to mask kernel pointers in log
files with a random mask [73]. Thus, a developer sees which point-
ers are the same, but an attacker cannot learn the actual pointer
value and, thus, the KASLR offset. This mitigation reduces the risk
of leaking the KASLR offset without impairing the debugging capa-
bilities. The PaX Team proposed STACKLEAK [15], a mechanism to
clear kernel-stack memory which is no longer in use. This reduces
accidental address leakage from uninitialized stack values.
6.3 Mitigate Microarchitectural KASLR Breaks
While microarchitectural attacks on KASLR cannot be simply fixed
in software, there are software-based workarounds. Gruss et al. [31,
32] proposed stronger kernel isolation to prevent microarchitectural
attacks on the kernel by unmapping the kernel address space when