(TSetup, TCom, TVfy, TForceOp) is CCA secure with gap ğœ–  ËœT and all ğœ† âˆˆ N, all PRAM algorithms
A = (A1, A2) where A2â€™s parallel running time is bounded by Tğœ–,
it holds that
Pr
ğ‘ = ğ‘â€²
âˆ§ ğ‘ âˆ‰ Q
crs â† TSetup(1ğœ†, 1T)
(ğ‘š0, ğ‘š1) â† AO
1 (crs)
ğ‘ â† {0, 1}
(ğ‘, ğœ‹) â† TCom(crs, ğ‘šğ‘)
ğ‘â€² â† AO
2 (ğ‘, ğœ‹)
(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)
 â‰¤ 1/2 + negl(ğœ†)
where O is an oracle to which the adversary can query with (ğ‘, ğœ‹) and
if TVfy(crs, ğ‘, ğœ‹) = 1, the oracle uses TForceOp(crs, ğ‘) and returns
the output. Here Q denotes the set of commitments queried by A to
the oracle O.
Homomorphic Evaluation. We define an additional homomor-
phic evaluation algorithm that is going to be useful for our main
scheme.
Definition 5.5 (Homomorphic Evluation). A homomorphic
evaluation algorithm TEval for a function family F is defined as
follows.
TEval(crs, ğ‘“ , (ğ‘1, . . . , ğ‘ğ‘›)): On input a common reference string crs, a
function ğ‘“ âˆˆ F , and a set of commitments (ğ‘1, . . . , ğ‘ğ‘›), the evaluation
algorithm returns a new commitment Ëœğ‘.
We only require the following notion of correctness. For all
ğœ† âˆˆ N, all time parameters T âˆˆ N, all functions ğ‘“ âˆˆ F , and all
messages (ğ‘š1, . . . , ğ‘šğ‘›) it holds that
Pr[TForceOp(crs, ğ‘âˆ—) = ğ‘“ (ğ‘š1, . . . , ğ‘šğ‘›)] = 1
where ğ‘âˆ— := TEval(crs, ğ‘“ , (ğ‘1, . . . , ğ‘ğ‘›)), crs â† TSetup(1ğœ†, 1T) and
(ğ‘ğ‘–, ğœ‹ğ‘–) â† TCom(crs, ğ‘šğ‘–).
Session 10C: Foundations CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea26705.2 Construction
In the following we present our efficient scheme for CCA timed
commitments. We assume the existence of a homomorphic time-
lock puzzle (PSetup, PGen, PEval, Solve) over Zğ‘ from class groups
(cf. Section 4) defined over some DDH-hard group G (cf. Theo-
rem B.2) and a DDH-hard prime-order group (cf. Theorem B.1)
generation algorithm ( ËœG, Ëœğº, Ëœğ¾) â† GGen(1ğœ†, Ëœğ‘) that, on input the
security parameter 1ğœ† and a uniformly sampled prime Ëœğ‘ (of ğœ† bits)
returns a group description ËœG and two generators ( Ëœğº, Ëœğ¾). We let
ğ›¼ := âŒŠlog Ëœğ‘âŒ‹ + 1.
In addition, we assume the existence of a simulation sound NIZK
(Appendix E) proof system (Setup, Prv, Vfy) for each of the follow-
ing languages. For groups of unknown order where computing
square roots is easy, the languages we are able to prove are slightly
different from those in groups of known order. In particular, we
cannot prove the knowledge of the integer value of an exponent ğ‘¥,
but we can prove the knowledge of two integers ğ‘˜ and ğœŒ such that
ğ‘¥ = ğ‘˜ Â· 2âˆ’ğœŒ modulo the unknown order, which is sufficient for our
applications. An honest prover always sets ğœŒ := 0 when running
the proving algorithm for all of the following languages.
â€¢ Language L1 contains all statements (ğº, ğ¾) such that ğ¾ is gen-
erated by ğº, defined as
(cid:110)(ğº, ğ¾)(cid:12)(cid:12)(cid:12) âˆƒ ğ‘˜, ğœŒ, s.t. ğ¾ = ğºğ‘˜Â·2âˆ’ğœŒ(cid:111) .
L1 :=
(cid:110)(ğº0, ğº1, ğ»0, ğ»1)(cid:12)(cid:12)(cid:12)âˆƒ ğ‘ , ğœŒ s.t. ğ»0 = ğºğ‘ Â·2âˆ’ğœŒ
â€¢ Language L2 contains all the DDH-tuples, defined as
L2 :=
â€¢ Language L3 contains pairs of ciphertexts encrypting the same
AND ğ»1 = ğºğ‘ Â·2âˆ’ğœŒ
(cid:111)
0
1
bit, defined as
(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)
AND
âˆƒ {ğ‘ ğ‘–, Ëœğ‘ ğ‘–, ğœŒğ‘– }ğ‘–âˆˆ[ğ›¼] s.t.
(ğ‘ğ‘–,0, ğ‘ğ‘–,1) = (ğºğ‘ ğ‘–Â·2âˆ’ğœŒğ‘– , ğ¾ğ‘ ğ‘–Â·2âˆ’ğœŒğ‘– )
( Ëœğ‘ğ‘–,0Ëœ,ğ‘ğ‘–,1) = ( Ëœğº Ëœğ‘ ğ‘– , Ëœğ¾ Ëœğ‘ ğ‘–)
(ğ‘ğ‘–,0, ğ‘ğ‘–,1) = (ğºğ‘ ğ‘–Â·2âˆ’ğœŒğ‘– , ğ¾ğ‘ ğ‘–Â·2âˆ’ğœŒğ‘–
( Ëœğ‘ğ‘–,0, Ëœğ‘ğ‘–,1) = ( Ëœğº Ëœğ‘ ğ‘– , Ëœğ¾ Ëœğ‘ ğ‘– Â· Ëœğº)
AND
OR
Â· ğº)
L3 :=
(ğº, ğ¾, Ëœğº, Ëœğ¾)
{ğ‘ğ‘–,0, ğ‘ğ‘–,1}ğ‘–âˆˆ[ğ›¼]
{ Ëœğ‘ğ‘–,0, Ëœğ‘ğ‘–,1}ğ‘–âˆˆ[ğ›¼]
Efficiency and Instantiations. The setup algorithm internally
runs the setup of the homomorphic time-lock puzzles, the setup
of the NIZK proof system, and the group generation algorithm
for the DDH-hard prime order group of order Ëœğ‘. All of the above
three algorithms are public coin algorithms (cf. Section 4 and Ap-
pendix E) and therefore our CCA timed commitment scheme also
has a public coin setup. As for the efficiency, the running time of
the setup is proportional to ğœ† and T (the latter dependency is due
to PSetup(1ğœ†, 1T)), however the size of the public parameters is a
fixed polynomial in ğœ† and it is in particular independent of T.
The commitment algorithm runs the puzzle generation of the
homomorphic time-lock puzzle and generates ElGamal-like cipher-
texts (that encrypt single bits) both in the class group and in the
prime order group. In total, we have [ğ›¼] (where ğ›¼ := âŒŠlog Ëœğ‘âŒ‹ + 1)
ciphertexts in both groups. The algorithm also computes a NIZK
proof of well-formedness (cf. Appendix E). The running time of
the commitment algorithm is bounded by a fixed polynomial in ğœ†
and in particular is independent of T. The verification algorithm
simply runs the verifier routine of the NIZK proof system. The
force open algorithm solves the time-lock puzzle that takes T se-
quential computational steps and the evaluation algorithm runs the
homomorphic evaluation algorithm of the time-lock puzzle.
Analysis. It is easy to show that the scheme satisfies perfect cor-
rectness and perfect binding. In the below theorem we formally
state the security of our CCA timed commitment construction, and
defer the proof to Appendix D.
Theorem 5.6. Let (PSetup, PGen, PEval, Solve) be a secure time-
lock puzzle over a DDH-hard group G, GGen be a DDH-hard group
generator, and (Setup, Prv, Vfy) be simulation-sound NIZK proof sys-
tem. Then the timed commitment construction from Figure 3 satisfies
CCA security and verifiability.
Highly Efficient Heuristic Variant. Provided we assume the
sigma protocol for language L2 is simulation extractable1 with
a straight-line (i.e. non-rewinding) extractor, we can omit proofs
for languages L2 and L3. Note that simulation soundness of the
sigma protocol can be proven, but extraction requires rewinding.
Our heuristic has a flavor of â€œknowledgeâ€-type assumptions which
we believe is a reasonable compromise for a significant gain in
efficiency. Similar assumptions about sigma protocols are quite
common: For example, several works in threshold ECDSA signa-
tures [41, 53] propose protocols requiring UC-secure (in particular
straight-line simulation extractable) NIZK. However, favoring ef-
ficiency, their actual implementation uses non-UC-secure sigma
protocols.
6 DISTRIBUTED RANDOMNESS
GENERATION
We now show how a CCA timed commitment allows us to build an
efficient distributed randomness generation protocol.
6.1 Definition
We consider a setting where there are ğ‘› parties (ğ‘ƒ1, . . . , ğ‘ƒğ‘›) want to
jointly compute a random string. The definitions that we present,
are tailored to our settings and allow us to model the following
properties of interest:
â€¢ Public-Coin Setup: The protocol assumes a one-time (public-coin)
setup that produces a short string (pp) that is made available to
all participants.
â€¢ Non-Interactive: The protocol consists of a single round of inter-
â€¢ All-but-one Corruption: The protocol is resilient against the cor-
action among users.
ruption of all but one participants.
Syntactically, the protocol consists of the following interfaces. A
setup algorithm RSetup is run at the beginning that outputs the
public parameters pp to all the parties in the system. The parties
locally run a randomness generation algorithm RGen that outputs
a randomness commitment ğ‘£, which is then published on a bulletin
board or broadcast to all parties. Finally, each participant can locally
run the randomness computation algorithm RComp to generate
the final random value. The formal interfaces are given below.
1A notion where the simulator is able to simulate proofs for an adversary and is also
able to extract the witness from a proof output by the adversary [44].
Session 10C: Foundations CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea2671TSetup(1ğœ†, 1T): On input the security parameter 1ğœ† and the time parameter 1T, do the following:
â€¢ Sample pp â† PSetup(1ğœ†, 1T, ğ‘) and parse pp = (ğº, ğ», ğ¹, Ëœğ‘). Sample crsâ€² â† Setup(1ğœ†) and ( ËœG, Ëœğº, Ëœğ¾) â† GGen(1ğœ†, Ëœğ‘).
â€¢ Set crs = (crsâ€², pp, ËœG, Ëœğº, Ëœğ¾) and output crs.
TCom(crs, ğ‘š): On input a common reference string crs and a message ğ‘š, do the following:
â€¢ Sample ğ‘Ÿ â† Z Ëœğ‘, and compute ğ‘ â† PGen(pp, ğ‘š; ğ‘Ÿ), where ğ‘ = (ğ‘1, ğ‘2) = (ğºğ‘Ÿ ,ğœ“ğ‘(ğ»ğ‘Ÿ) Â· ğ¹ğ‘š).
â€¢ Sample ğ‘˜ â† Z Ëœğ‘ and set ğ¾ := ğºğ‘˜. Let ğ›¼ := âŒŠlog Ëœğ‘âŒ‹ + 1.
â€¢ For ğ‘– âˆˆ [ğ›¼], sample (ğ‘ ğ‘–, Ëœğ‘ ğ‘–) â† Z Ëœğ‘, and let ğ‘Ÿğ‘– is the ğ‘–-th bit of ğ‘Ÿ. Compute
â€¢ Compute the NIZK proof ğœ‹ for the statement stmt := (ğ‘, ğº, ğ¾, Ëœğº, Ëœğ¾, {ğ‘ğ‘–,0, ğ‘ğ‘–,1, Ëœğ‘ğ‘–,0, Ëœğ‘ğ‘–,1}ğ‘–âˆˆ[ğ›¼]) that certifies that
(ğ‘ğ‘–,0, ğ‘ğ‘–,1) = (ğºğ‘ ğ‘– , ğ¾ğ‘ ğ‘– Â· ğºğ‘Ÿğ‘–) and ( Ëœğ‘ğ‘–,0, Ëœğ‘ğ‘–,1) = ( Ëœğº Ëœğ‘ ğ‘– , Ëœğ¾ Ëœğ‘ ğ‘– Â· Ëœğºğ‘Ÿğ‘–)
(ğº, ğ¾) âˆˆ L1 and
ğº, ğ¾,
ğ‘2ğ‘–âˆ’1
ğ‘–,0 ,
ğ‘2ğ‘–âˆ’1
ğ‘–,1
Â· ğ‘âˆ’1
1
âˆˆ L2 and (ğº, ğ¾, Ëœğº, Ëœğ¾, {ğ‘ğ‘–,0, ğ‘ğ‘–,1, Ëœğ‘ğ‘–,0, Ëœğ‘ğ‘–,1}ğ‘–âˆˆ[ğ›¼]) âˆˆ L3
(cid:32)
ğ›¼
ğ‘–=1
ğ›¼
ğ‘–=1
(cid:33)
â€¢ Set the commitment ğ‘ = (ğ‘, ğ¾, {ğ‘ğ‘–,0, ğ‘ğ‘–,1, Ëœğ‘ğ‘–,0, Ëœğ‘ğ‘–,1}ğ‘–âˆˆ[ğ›¼]) and return (ğ‘, ğœ‹)
TVfy(crs, ğ‘, ğœ‹): On input a common reference string crs, a commitment ğ‘ := (ğ‘, ğ¾, {ğ‘ğ‘–,0, ğ‘ğ‘–,1, Ëœğ‘ğ‘–,0, Ëœğ‘ğ‘–,1}ğ‘–âˆˆ[ğ›¼]) (where ğ›¼ := âŒŠlog Ëœğ‘âŒ‹ + 1),
and a proof ğœ‹, return 1 if and only if Vfy(crs, stmt, ğœ‹) = 1.
TForceOp(crs, ğ‘): On input a common reference string crs and a commitment ğ‘, return Solve(pp, ğ‘).
TEval(crs, ğ‘“ , (ğ‘1, . . . , ğ‘ğ‘›)): On input a common reference string crs, a function ğ‘“ âˆˆ F , and a set of commitments (ğ‘1, . . . , ğ‘ğ‘›), return
PEval(pp, ğ‘“ , (ğ‘1, . . . , ğ‘ğ‘›)).
Figure 3: Construction of CCA Timed Commitments
Definition 6.1 (Distributed Randomness Generation). A
distributed randomness generation protocol Î DRG consists of three
PPT algorithms (RSetup, RGen, RComp) that are defined as follows.
pp â† RSetup(1ğœ†): the setup algorithm takes as input the security
parameter 1ğœ† and outputs the public parameters pp.
ğ‘£ â† RGen(pp): the randomness generation algorithm takes as input
the public parameters pp, and internally samples random coins to
output a randomness commitment ğ‘£.
ğ‘Ÿ â† RComp(pp, {ğ‘£1, . . . , ğ‘£ğ‘›}): the distributed randomness
computation algorithm takes as input the public parameters pp, a set
of values ğ‘£1, . . . , ğ‘£ğ‘› and outputs a beacon value ğ‘Ÿ.
In terms of security, we want that the final random value gener-
ated by RComp is indistinguishable from a uniform random string.
More precisely, we consider a time bound T on the duration of
the randomness generation protocol and we consider an adversary
whose parallel running time is bounded by T. The adversary cor-
rupts any proper subset of the parties involved and has access to an
oracle that mimics the behaviour of honest parties: That is, the ora-
cle runs the randomness generation algorithm RGen by internally
sampling random coins and returning the output to the adversary.
The adversary outputs the randomness commitment values of all