# 方法
---
- https://www.kancloud.cn/imxieke/ruby-base/107294
---
# 方法的调用
**简单的方法调用**
调用方法的语法如下所示：
```ruby
对象. 方法名( 参数 1, 参数 2, … , 参数 n )
```
以对象开头，中间隔着句点，后面接着是方法名，方法名后面是一排并列的用 `()` 括起来的参数。不同的方法定义的参数个数和顺序也都不一样，调用方法时必须按照定义来指定参数。另外，调用方法时 `()` 是可以省略的。
上面的对象被称为接收者（receiver）。在面向对象的世界中，调用方法被称为“向对象发送消息（message）”，调用的结果就是“对象接收（receive）了消息”。也就是说，方法的调用就是把几个参数连同消息一起发送给对象的过程。
**带块的方法调用**
`each` `方法、loop` 方法，方法本身可以与伴随的块一起被调用。这种与块一起被调用的方法，我们称之为带块的方法。
带块的方法的语法如下：
```ruby
对象. 方法名( 参数, …) do | 变量 1, 变量 2, …|
 块内容
end
```
`do ～ end` 这部分就是所谓的块。除 do ～ end 这一形式外，我们也可以用 `{～}` 将块改写为其他形式：
```ruby
对象. 方法名( 参数, …) { | 变量 1, 变量 2, …|
 块内容
}
```
> 使用 do ～ end 时，可以省略把参数列表括起来的 `()`。使用 `{ ～ }` 时，只有在没有参数的时候才可以省略 `()`，有一个以上的参数时就不能省略。
在块开头的 `～` 部分中指定的变量称为块变量。在执行块的时候，块变量由方法传到块内部。不同的方法对应的块变量的个数、值也都不一样。之前介绍过的 times 方法有一个块变量，执行块时，方法会从 0 开始依次把循环次数赋值给块变量
```ruby
5.times do |i|
  puts "第#{i} 次循环。"
end
```
**运算符形式的方法调用**
Ruby 中有些方法看起来很像运算符。四则运算等的二元运算符、`-`（负号）等的一元运算符、指定数组、散列的元素下标的 `[]` 等，实际上都是方法。
- obj + arg1
- obj =~ arg1
- -obj
- !obj
- obj[arg1]
- obj[arg1] = arg2
这些虽然与一般的方法调用的语法有点不一样，但我们可以将 `obj` 理解为接收者，将 `arg1`、`arg2` 理解为参数，这样一来，它们就又是我们所熟知的方法了。我们可以自由定义这种运算符形式的方法。
# 方法的分类
根据接收者种类的不同，Ruby 的方法可分为 3 类：
1. 实例方法
2. 类方法
3. 函数式方法
**实例方法**
实例方法是最常用的方法。假设有一个对象（实例），那么以这个对象为接收者的方法就被称为实例方法。
下面是实例方法的一些例子：
```ruby
p "10, 20, 30, 40".split(",")    #=> ["10", "20", "30", "40"]
p [1, 2, 3, 4].index(2)          #=> 1
p 1000.to_s                      #=> "1000"
```
在本例中，从上到下，分别以字符串、数组、数值对象为接收者。
对象能使用的实例方法是由对象所属的类决定的。调用对象的实例方法后，程序就会执行对象所属类预先定义好的处理。
虽然相同名称的方法执行的处理大多都是一样的，但具体执行的内容则会根据对象类型的不同而存在差异。例如，几乎所有的对象都有 to_s 方法，这是一个把对象内容以字符串形式输出的方法。然而，虽然都是字符串形式，但在数值对象与时间对象的情况下，字符串形式以及字符串的创建方法却都不一样。
```ruby
p 10.to_s        #=> "10"
p Time.now.to_s  #=> "2013-03-18 03:17:02 +900"
```
**类方法**
接收者不是对象而是类本身时的方法，我们称之为类方法。例如，我们在创建对象的时候就使用到了类方法。
```ruby
Array.new                 # 创建新的数组
File.open("some_file")    # 创建新的文件对象
Time.now                  # 创建新的 Time 对象
```
此外，不直接对实例进行操作，只是对该实例所属的类进行相关操作时，我们也会用到类方法。例如，修改文件名的时候，我们就会使用文件类的类方法。
```ruby
File.rename(oldname, newname)    # 修改文件名
```
类方法也有运算符的形式。
```ruby
File::rename(oldname, newname)    # 修改文件名
```
调用类方法时，可以使用 `::` 代替 `.`。在 Ruby 语法中，两者所代表的意思是一样的。
**函数式方法**
没有接收者的方法，我们称之为函数式方法。
虽说是没有接收者，但并不表示该方法就真的没有可作为接收者的对象，只是在函数式方法这个特殊情况下，可以省略接收者而已。
```ruby
print "hello!"    # 在命令行输出字符串
sleep(10)         # 在指定的时间内睡眠，终止程序
```
函数式方法的执行结果，不会根据接收者的状态而发生变化。程序在执行 print 方法以及 sleep 方法的时候，并不需要知道接收者是谁。反过来说，不需要接收者的方法就是函数式方法。
# 方法的标记法
接下来，我们来介绍一下 Ruby 帮助文档中方法名的标记方法。标记某个类的实例方法时，就像 Array#each、Array#inject 这样，可以采用以下标记方法：
```
类名 # 方法名
```
请注意，这只是写帮助文档或者说明时使用的标记方法，程序里面这么写是会出错的。
另外，类方法的标记方法，就像 Array.new 或者 Array::new 这样，可以采用下面两种写法：
- 类名 . 方法名
- 类名 :: 方法名
这和实际的程序语法是一致的。
# 方法的定义
定义方法的一般语法如下：
```ruby
def 方法名( 参数 1, 参数 2, …)
希望执行的处理
end
```
方法名可由英文字母、数字、下划线组成，但不能以数字开头。
```ruby
def hello(name)
  puts "Hello, #{name}."
end
hello("Ruby")
```
> 虽然在说明如何定义实例方法或类方法之前，应该先说明如何定义类，但关于类的定义我们还未说明。因此，现在我们只需掌握一点，即定义了方法后，就能像省略接收者的函数式方法那样调用方法了。
通过 hello 方法中的 name 变量，我们就可以引用执行时传进来的参数。该程序的参数为字符串 Ruby，执行结果如下：
```ruby
> ruby hello_with_name.rb
Hello, Ruby.
```
也可以指定默认值给参数。参数的默认值，是指在没有指定参数的情况下调用方法时，程序默认使用的值。定义方法时，用参数名 = 值这样的写法定义默认值。
```ruby
def hello(name="Ruby")
  puts "Hello, #{name}."
end
hello()         # 省略参数的调用
hello("Newbie") # 指定参数的调用
```
执行示例
```ruby
> ruby hello_with_default.rb
Hello, Ruby.
Hello, Newbie.
```
方法有多个参数时，从参数列表的右边开始依次指定默认值。例如，希望省略三个参数中的两个时，就可以指定右侧两个参数为默认值。
```ruby
def func(a, b=1, c=3)
  ┊
end
```
请注意只省略左边的参数或者中间的某个参数是不行的。
**方法的返回值**
我们可以用 `return` 指定方法的返回值。
return 值
下面我们来看看求立方体体积的例子。参数 `x`、`y`、`z` 分别代表长、宽、高。`x * y * z` 的结果就是方法的返回值。
```ruby
def volume(x, y, z)
  return x * y * z
end
p volume(2, 3, 4)    #=> 24
p volume(10, 20, 30) #=> 6000
```
可以省略 `return` 语句，这时方法的最后一个表达式的结果就会成为方法的返回值。下面我们再通过求立方体的表面积这个例子，来看看如何省略 `return`。这里，`area` 方法的最后一行的 `(xy + yz + zx) * 2` 的结果就是方法的返回值。
```ruby
def area(x, y, z)
  xy = x * y
  yz = y * z
  zx = z * x
(xy + yz + zx) * 2
end
p area(2, 3, 4)    #=> 52
p area(10, 20, 30) #=> 2200
```
方法的返回值，也不一定是程序最后一行的执行结果。例如，在下面的程序中，比较两个值的大小，并返回较大的值。`if` 语句的结果就是方法的返回值，即 `a > b` 的结果为真时，`a` 为返回值；结果为假时，则 `b` 为返回值。
```ruby
def max(a, b)
  if a > b
    a
  else
    b
  end
end
p max(10, 5)    #=> 10
```
因为可以省略，所以有些人就会感觉好像没什么机会用到 `return`，但是有些情况下我们会希望马上终止程序，这时 `return` 就派上用场了。用 `return` 语句改写的 `max` 方法如下所示，大家可以对比一下和之前有什么异同。
```ruby
def max(a, b)
  if a > b
    return a
  end
  return b    # 这里的return 可以省略
end
p max(10, 5)  #=> 10
```
如果省略 return 的参数，程序则返回 nil。方法的目的是程序处理，所以 Ruby 允许没有返回值的方法。Ruby 中有很多返回值为 nil 的方法，第 1 章中介绍的 print 方法就是其中一。
print 方法只输出参数的内容，返回值为 nil。
```ruby
p print("1:")    #=> 1:nil
                 #  （显示print 方法的输出结果1: 与p 方法的输出结果nil）
```
**定义带块的方法**
之前我们已经介绍过带块的方法，下面就来介绍一下如何定义带块的方法。
首先我们来实现 myloop 方法，它与利用块实现循环的 loop 方法的功能是一样的。
```ruby
def myloop
  while true
    yield               # 执行块
  end
end