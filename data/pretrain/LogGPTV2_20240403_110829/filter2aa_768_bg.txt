### 优化后的文本

#### CPU 异常处理机制
当 CPU 在执行过程中检测到错误情况但尚未进行任何算术计算时，这种异常不属于计算后异常。数值溢出、数值下溢和结果不精确则属于计算后异常。

对于这六类异常中的每一种，MXCSR 寄存器都配备了一个屏蔽位和一个标志位。屏蔽位用于控制该类异常是否被屏蔽，而标志位则用于报告该类异常的发生。

**图 C-2: MXCSR 控制和状态寄存器**

当 CPU 检测到这些异常情况时，如果某类异常的屏蔽位为 1（即该异常被屏蔽），CPU 将自动处理该异常，生成一个合理的结果，并继续执行程序。若屏蔽位为 0（即该异常未被屏蔽），CPU 会检查 CR4 寄存器中的 OSXMMEXCPT 标志来判断操作系统是否支持 SIMD 浮点异常。如果 OSXMMEXCPT 标志为 1（表示支持 SIMD 异常），CPU 会产生一个 SIMD 浮点异常并执行相应的异常处理例程。反之，若标志为 0（表示不支持 SIMD 异常），CPU 则会产生一个无效操作码（#UD）异常。

值得注意的是，与 x87 FPU 浮点异常的延迟处理策略不同，SIMD 浮点异常是立即报告的。因此，不会出现 WAIT/FWAIT 或其他 SSE/SSE2/SSE3 指令等待 SIMD 浮点异常的情况。另外，如果在 SIMD 浮点异常发生时该异常已被屏蔽，CPU 会设置 MXCSR 寄存器中对应的标志位，但不会报告该异常。即使之后取消了该异常的屏蔽，之前发生的异常也不会被再次报告。

在对一组包含 2 或 4 个子操作数的操作数进行计算时，SSE/SSE2/SSE3 SIMD 浮点指令可能会检测到多个 SIMD 浮点异常。如果每个子操作数的异常情况不超过一个，CPU 会为所有异常情况设置相应的标志位。例如，一个子操作数的无效异常不会妨碍另一个子操作数的除零异常标志位的设置。然而，如果一个子操作数存在多种异常情况，CPU 将根据表 C-5 所示的优先级顺序仅报告最高优先级的一种异常。表 C-5 定义了异常的优先级，使得高优先级的错误情况会被报告，而低优先级的情况则被忽略。

**表 C-5: SIMD 浮点异常优先级**

| 优先级 | 描述 |
|--------|------|
| 1（最高） | 因 SNaN 操作数导致的无效运算异常，或者对任何 NaN 操作数进行最大值、最小值、或某些比较和转化运算 |
| 2 | QNaN（并非异常，但在处理 QNaN 操作数时比低优先级的异常更优先，例如 QNaN 除零会导致 QNaN 而不是除零异常） |
| 3 | 任何上面未提到的无效运算异常和除零异常* |
| 4 | 非规格化操作数异常* |
| 5 | 数值溢出或下溢异常，可能与结果不精确异常同时发生* |
| 6（最低） | 结果不精确异常 |

* 如果异常被屏蔽，指令将继续执行，可能会有更高优先级的异常发生。

**错误代码**: 无，可以通过 MXCSR 寄存器获取进一步信息。

**保存的程序指针**: 保存的 CS 和 EIP 值指向导致 SIMD 浮点异常的 SSE/SSE2/SSE3 指令。

**程序状态变化**: 不会导致程序状态变化，因为处理器检测到错误情况后会立即报告异常（除非被屏蔽）。异常处理程序可以通过检查 MXCSR 寄存器和其他信息来判断并纠正错误情况，然后恢复程序继续运行。

### 《软件调试》补编说明
《软件调试》出版后，许多读者反馈这本书太厚，难以阅读。尽管内容较难理解，作者在写作时希望“略懂计算机的人就能读懂”。

为了鼓励大家的阅读兴趣，作者在高端调试网站（http://advdbg.org）上撰写了一系列导读文章，目前已完成以下四篇：
- 《软件调试》导读之提纲挈领
- 《软件调试》导读之绪论篇
- 《软件调试》导读之 CPU 篇
- 《软件调试》导读之操作系统篇

这些导读文章也收录在此补编中，希望能对读者有所帮助。

### 《软件调试》导读之提纲挈领
拙作《软件调试》出版两个月以来，热心读者建议我分享一些阅读方法。为了满足读者的需求，计划为《软件调试》的每一篇写一个导读短文。首先从书的整体结构谈起，用软件术语来说就是架构，用写作术语则是提纲。

**最初的书名**
早在 2003 年，我就萌生了写一本关于软件调试的书的想法。软件调试是一个广泛的话题，需要选择合适的角度才能写出好书。通过研究当时已有的书籍，最终确定了第一个版本的规划，书名为《高级系统调试》（Advanced System Debugging, ASD）。目标是解决系统级的调试任务，与模块范围内的常规调试相对。

2004 年下半年，初步规划成型。针对系统调试和常规调试的不同，从以下几个方面进行了比较：
- **范围**: 系统范围 vs. 模块/产品范围
- **问题类型**: 应用程序或操作系统挂起/崩溃 vs. 功能失败
- **源代码依赖**: 不依赖源代码 vs. 基于源代码
- **时间框架**: 系统调试更关注产品部署前后的严重问题

强调了系统调试需要不同的工具且更具挑战性：
- 处理的问题更为严重（如挂起、崩溃、自动重启等）
- 定位问题涉及整个系统（包括硬件）
- 可能在没有源代码和完整文档的情况下工作
- 需要广泛的跨领域知识（操作系统、硬件、固件等）

最初的主要内容包括：
1. **调试基础**
   - 调试器的工作原理
   - CPU 和操作系统的调试支持
   - 通用调试机制
   - 软件工程中的调试
2. **异常**
   - 软件和硬件异常的理解
   - 异常处理机制
   - 用户模式和内核模式下的未捕获异常
   - 常见异常
3. **方法学和工具**
   - 高级检查
     - 查看系统组件内部
     - 检查二进制文件和进程
   - 高级监控/间谍
     - 监控系统活动和内核对象
     - 探索操作系统启动过程
   - 高级跟踪
     - 中断应用程序、驱动程序和操作系统
     - WinDbg 技巧
4. **蓝屏（BSOD）**
   - BSOD 的原因
   - 解释 BSOD
   - 内存转储的启用和分析
   - 使用 WinDbg 进行 BSOD 跟踪
   - 其他高级主题
5. **调试实践**
   - 用户模式调试实践
   - 内核模式调试实践
   - ACPI 问题调试

**2005 年的选题列选单**
2005 年初，开始细化写作内容和篇章结构。第一版章节计划产生了，以下是当时的选题列选单摘要：

软件调试是软件开发及维护中最重要且最富挑战性的工作之一。大多数软件工程师认为他们 50%以上的工作时间用于调试。然而，调试无论在实践中还是学术界都未得到足够重视。本书旨在填补这一空白，系统全面地阐述软件调试的理论和实践。全书分为 4 篇 18 章：
- **基础篇** (1~4 章)
- **开发篇** (5~7 章)
- **工具篇** (8~12 章)
- **实践篇** (13~18 章)

**重构**
动笔后，发现写书难度超出预期。第 2 章和第 3 章分别用了很长时间才完成，且篇幅较长。决定重新组织结构，更侧重调试原理，将工程实践所需的基础知识和技能融入原理中。主要改动如下：
- 将原来的 2、3、4 章升级为篇
- 去掉实践篇
- 工具篇只集中讨论调试器

新的架构分为 6 篇 30 章，核心部分包括 CPU、操作系统和编译器提供的调试支持。了解这些支持是掌握调试技术的关键。