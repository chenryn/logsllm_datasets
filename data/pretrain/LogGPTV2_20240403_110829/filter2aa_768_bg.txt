是算当 CPU 检测到错误情况使还没有进行任何算术计算。数值溢出、数值下溢和结果不
精确属于计算后异常。 
对于以上六类情况的每一种，MXCSR 寄存器配备了一个屏蔽位和一个标志位分别用
于屏蔽该类异常和报告该类异常发生。 
图 C-2  MXCSR 控制和状态寄存器 
当 CPU 检测到以上异常情况时，如果该类异常被屏蔽（MXCSR 寄存器的对应屏蔽
位为 1），那么 CPU 便会自动处理该异常，产生一个合理的结果，然后让程序继续运行。
如果该类异常没有被屏蔽（MXCSR 寄存器的对应屏蔽位为 0），那么 CPU 会通过检查 CR4
寄存器的 OSXMMEXCPT 标志来判断操作系统是否支持 SIMD 浮点异常，如果
OSXMMEXCPT 标志为 1（表示操作系统支持 SIMD 异常），那么 CPU 便会产生一个 SIMD
浮点异常，然后执行该异常对应的异常处理例程。如果 OSXMMEXCPT 标志为 0（表示
操作系统不支持 SIMD 异常），那么 CPU 会产生一个无效操作码（#UD）异常。 
值得注意的是，与 x87 FPU 浮点异常的延迟处理策略不同，SIMD 浮点异常是被立即汇
报的。因此 WAIT/FWAIT 或其它 SSE/SSE2/SSE3 指令遇到等待报告的 SIMD 浮点异常的情
况是不会发生的。另一种情况是，当一个 SIMD 浮点异常发生时该类异常是被屏蔽的，这
时 CPU 会设置 MXCSR 寄存器中对应的标志位，但不会报告该异常，而后如果取消屏蔽该
《软件调试》补编 
- 130 – 
Copyright © 2009 ADVDBG.ORG All Rights Reserved 
类异常，那么取消屏蔽时并不会导致 CPU 汇报这个前面发生的异常。 
当 SSE/SSE2/SSE3 SIMD 浮点指令对一组操作数（包含 2 或 4 个子操作数）进行计算
时，CPU 可能检测到多个 SIMD 浮点异常的情况。如果一个子操作数的异常情况不超过
一个，那么 CPU 会为设置所有异常情况所对应的标志位。例如，为一个子操作数的无效
异常设置异常标志位不会妨碍为另一个子操作数的除零异常设置对应的标志位。但是如果
一个子操作数被检测到几个异常情况，那么 CPU 会根据表 C-5 所示的先后顺序只报告一
种情况。表 C-5 所定义的顺序会使 CPU 汇报高优先级的错误情况，忽略低优先级的情况。 
表 C-5  SIMD 浮点异常优先级 
优先级 
描述 
1（最高） 
因为 SNaN 操作数导致的无效运算异常，或者对任何 NaN 操作数进行最
大值、最小值、或某些比较和转化运算 
2 
QNaN（并非异常，但是处理 QNaN 操作数比低优先级的异常更优先，比
如 QNaN 除零会导致 QNaN，而不是除零异常） 
3 
任何上面没有提到的无效运算异常和除零异常* 
4 
非规格化操作数异常* 
5 
数值溢出或下溢异常，可能与结果不精确异常同时发生* 
6（最低） 
结果不精确异常 
* 如果被屏蔽，那么指令会继续执行，可能会有第优先级的异常发生。 
错误代码：无，可以通过 MXCSR 寄存器判断异常的进一步信息。 
保存的程序指针：保存的 CS 和 EIP 值指向的是导致 SIMD 浮点异常的那条
SSE/SSE2/SSE3 指令。也就是从中检测到错误情况的那条指令。 
程序状态变化：不会导致程序状态变化，因为处理器检测到错误情况后会立即报告异
常（除非被屏蔽）。异常处理程序可以通过检查 MXCSR 寄存器和其它信息判断并纠正错
误情况，然后恢复程序继续运行。 
《软件调试》补编 
- 131 – 
Copyright © 2009 ADVDBG.ORG All Rights Reserved 
补编内容
补编内容
补编内容
补编内容 10 《
《
《
《软件调试
软件调试
软件调试
软件调试》
》
》
》导读
导读
导读
导读 
补编说明： 
《软件调试》出版后，不少反馈是嫌这本书太厚了，不好读。当然不好读的
原因也有书中的内容比较难懂。 
其实作者写作这本书时，是很有一个让“略懂计算机的人就能读懂”的远大
理想的。 
为了鼓励一下大家的阅读兴趣，我在高端调试网站（http://advdbg.org）上
写了一系列导读性的文章，至今已经完成下面四篇： 
《软件调试》导读之提纲挈领 
《软件调试》导读之绪论篇 
《软件调试》导读之 CPU 篇 
《软件调试》导读之操作系统篇 
也把这个内容放入这个补编中吧，希望能有人觉得有点帮助。 
《软件调试》补编 
- 132 – 
Copyright © 2009 ADVDBG.ORG All Rights Reserved 
《软件调试》导读之提纲挈领 
拙作《软件调试》出版两个月了，有热心读者建议我讲些阅读这本书的方法。有读者
愿意读自己的书，当然是好事，再说读者是客户，他们的意见就是命令，不能怠慢。粗略
思考一番，计划先为《软件调试》的每一篇写一个导读短文。总为开篇，今日先谈谈《软
件调试》这本书的篇章结构，用软件的术语就是架构，用写作的术语也就是提纲。 
从最初的书名说起 
早在 2003 年，我就萌生了写一本关于软件调试的书的念头。但是软件调试是个大话
题，有很多东西可以写，必须选择好一个角度才能写出一本好书来。于是我开始搜索当时
已经有的书，无论是美国出的，还是英国出的，一共找到了十来本。而后，逐一了解了已
有的这些书，归纳了它们的主要内容和特色。 
2004 年下半年，第一个版本的规划初步成型了，书名叫 Advanced System Debugging
（《高级系统调试》）（简称 ASD）。针对的目标问题是系统级的调试任务，简单理解，
就是在系统范围找 BUG，是与模块范围内的常规调试相对而言的。在当时的规划书中，
我特意从以下四个方面比较了系统调试和常规调试的不同： 
Ÿ Scope 
Ø System wide vs. Module/Product wide  
Ÿ Addressed Issues 
Ø Application or OS Hang/Crash vs. Feature Failure 
Ÿ Source Code 
Ø Not depends on source code vs. Based on source code 
Ÿ Time Frame 
Ø System Debugging is more relevant with issues near or after product deployment 
并强调系统调试需要不同的工具，并且更具挑战性： 
Ÿ Addressed issues are more serious 
Ø Hang, Crash, Halt,  auto Restart, etc. 
Ÿ Locate Issues in system wide 
Ø Any component, including hardware, maybe the root cause 
Ÿ Without source code and complete document 
Ÿ Very broad knowledge is needed 
Ø OS, Hardware, Firmware, etc.  
当时确定的主要内容有以下几个部分： 
《软件调试》补编 
- 133 – 
Copyright © 2009 ADVDBG.ORG All Rights Reserved 
（一）调试基础 
Ÿ How debugger works? 
Ø Break, stack trace, memory view, and variable watch 
Ÿ CPU & OS support to Debugging 
Ø Post Mortem (JIT) debug, Attach Debugger 
Ÿ General debug mechanism 
Ø Dump, asserts, event log, and debug outputs 
Ÿ Debugging in software engineering 
（二）异常 
Ÿ Understand software and hardware exceptions;  
Ÿ Exception handling mechanism;  
Ÿ What if exceptions uncaught in user mode and kernel mode;  
Ÿ Frequent exceptions. 
（三）方法学和工具 
Ÿ Advanced Inspecting 
Ø View system components inside;  
Ø Examine binary (program) files and process; 
Ÿ Advanced Monitoring/Spying 
Ø Monitor system activities and kernel objects; 
Ø Exploring OS boot process; 
Ÿ Advanced Tracing 
Ø Interrupt an application, driver, and OS; 
Ø Skills for WinDbg 
（四）蓝屏（BSOD） 
Ÿ Why BSOD? 
Ÿ Interpret BSOD 
Ø Illustrate Stop Code one by one 
Ÿ Enable and analyze memory dump 
Ÿ Trace BSOD by WinDbg 
Ø Kernel debugging 
Ÿ Advanced topics about BSOD 
Ø Crash handler 
Ø More serious issues than BSOD 
（五）调试实践 
Ÿ User mode debugging practice 
《软件调试》补编 
- 134 – 
Copyright © 2009 ADVDBG.ORG All Rights Reserved 
Ø Dr. Watson, MiniDump 
Ÿ Kernel mode debugging practice 
Ø Kernel debug using COM, 1394 and Virtual PC 
Ø Debug driver issues 
Ÿ Debug ACPI issues 
Ø Resolve tough S3/S1 issues by actual sample   
现在回过头来看第一版计划，可以看到，其中包含了大多数后来要写的内容。而且这
种从整个计算机系统的角度来着眼的思想一直保持到最后。 
2005 年时的选题列选单 
2005 年年初，开始和电子出版社协商出版计划。我开始进一步细化写作内容和篇章
结构。于是第一个版本的章节计划产生了，下面是从当时的选题列选单中摘录下来的： 
软件调试是软件开发及维护中最重要且最富有挑战性的工作之一，大多数软件工程师
都认为他们 50%以上的工作时间是用在软件调试上的。但是软件调试无论是在软件工程实
践中还是在学术界至今都还没有得到应有的重视，少数效率低下的调试方法仍在普遍使
用，如何提高软件调试的效率和增强软件的可调试性还很少得到关注。特别是，纵观浩如
烟海的计算机图书世界，目前还找不到一本系统全面阐述软件调试理论和实践的作品。本
书正是出于这种考虑，力争填补软件领域和国内外出版界的一大空白。本书本着深入全面
和理论与实践并重的原则，多方位的向读者展现软件调试的原理、方法和技巧。全书分为
4 篇，18 章。基础篇（1~4 章）除了介绍基本的概念和术语（第 1 章）外，系统的阐述
了 CPU（第 2 章）、操作系统（第 3 章）和编译器（第 4 章）是如何支持软件调试的。
开发篇（5~7 章）开创性的提出如何在软件工程的各个环节中，尤其是设计阶段，融入软
件调试策略，提高软件的可调试性，以从根本上降低软件调试的复杂度，提高调试效率（第
5 章）。该篇不仅全面归纳比较了常用的提高软件可调试性的方法（第 6 章），还提出
了一些新的模型和实现，有很强的实践参考价值（第 7 章）。工具篇（8~12 章）在对各
类调试工具进行概括性介绍（第 8 章）后，深入的解析了三类常用调试工具的原理和用
法以及一批经典工具。第 9 章在介绍微软的著名内核调试器 WinDbg 的同时，深入地揭
示了内核调试的原理（目前还没有一本书包含此内容）。第 10 章通过深入解析微软.Net 调
试器的源代码，介绍了目前流行的中间/脚本语言（比如.Net 和 Java）调试的原理。第 11 
章以介绍 JTAG 原理为线索，探索了极富挑战性的嵌入式调试领域，介绍了如何调试常见
的嵌入式系统（xScale 系统, ARM 系统等）。第 12 章把近百个经典、小巧、免费的调试
工具归纳为几类，对它们做了个大检阅（这些工具是附带光盘工具箱的一部分）。实践篇
（13~18 章）首先归纳了被国内外专家普遍认可的一些调试规则和方法（第 13 章），然
后结合真实的案例，介绍了解决几类难度较大的调试问题的方法和技巧。第 14 章介绍了
远程调试、RPC 调试等用户态调试任务。第 15 章在介绍非常热门的 Windows 内核/驱
动程序调试的同时，还向读者揭示了如何探索 Windows 内核的一些技巧。第 16 章全面
的探讨了著名的蓝屏崩溃问题。第 17 章介绍了如何在没有源代码和文档的情况下定位系
统故障。第 18 章以最富挑战性的 ACPI 问题为例，探讨了如何利用前面介绍的方法和工
具解决软件、硬件、固件相结合的棘手问题，并总结全书。 
归纳一下，首先当时把要写的内容分为如下四篇：基础篇、开发篇、工具篇和实践篇。
另外，将书名从 ASD 改为《软件调试》。现在看来，这一版本的架构与 AWD（Advanced 
《软件调试》补编 
- 135 – 
Copyright © 2009 ADVDBG.ORG All Rights Reserved 
Windows Debugging）颇有相通之处，特别是基础篇和实践篇与 AWD 的第一篇和第二篇
是一个思路。 
软件调试的最初 300 页就是按照以上架构来写作的，写的是上面规划中的第 2 章和第
3 章。 
重构 
动笔后，更深的感觉到写书难。本来计划两个月完成的第 2 章，写到 2005 年年底也
没完成。又因为春节的大块时间用来探索 Windows 调试子系统，所以 2006 年 3 月才完成
第 2 章的第一稿。2006 年 8 月完成了第 3 章的初稿。这两章完成后，一个明显的问题是
这两章的篇幅都很长，第 2 章有 100 页，第 3 章有 210 多页。这两章的长度让我觉得很不
称心，我觉得一章太长，不易于阅读，也不方便编辑和排版。记得当时我还特意找了几本
书，在 Windows Internals 中，有接近和超过 100 页的两章，第 3 章系统机制（98 页），
和第 7 章内存管理（110 页）。 
一边写作，一边思考了几周后，我终于下定决心重新组织结构。重构的一个指导思想
是更侧重调试原理，将工程实践所需的基础知识和技能融入到原理中去，不再面向问题组
织篇章和“就事论事”。 根据这一思想，做了如下几个大的改动： 
将原来的 2，3，4 章升级为篇，以便更好的组织这些原理性和基础性的内容。  
砍去实践篇，以便使这本书具有更好的通用性。因为实践篇中本来的内容还是面向问
题的，深入讨论其中的每个问题域都可以单独写一本书，如果把这些内容放在同一本
书中写，那么很难深入，喜欢一个问题域的读者通常也不需要深入了解另外的问题域。  
在工具篇中，只集中讨论调试器，去掉本来安排的 10～12 章。  
根据以上策略调整后，新的架构便是今天的样子，全书分为 6 篇，30 章。 
目前的架构 
下图中画出了 2006 年重构后的篇章结构，也就是目前使用的架构。 
在新的架构中，2、3、4 篇是全书的核心，它们所描述的对象也恰好是计算机系统中
的三个核心：即硬件核心 CPU，软件核心操作系统和生产软件的核心工具编译器。从调
试的角度来看，这三个核心所提供的调试支持是支撑软件调试大厦的三块基石。或者说，
上层的很多调试技术都是这三个核心所提供支持的应用。因此，了解这些调试支持是了解
《软件调试》补编 
- 136 – 
Copyright © 2009 ADVDBG.ORG All Rights Reserved 
调试技术的关键。 
另外，从从事计算机相关工作的技术人员（本书读者）的角度来看，了解这三个核心
也是至关重要的，对于提高软件开发能力、调试能力和对计算机系统的认知力都非常有益。
从这个因素出发，第 2、3、4 篇的开头一章，即第 2 章，第 8 章和第 20 章，都是介绍这
篇所描述核心的基础知识。 