# 【技术分享】CVE-2015-1860分析：Qt模块处理gif图导致崩溃(附PoC)
|
##### 译文声明
本文是翻译文章，文章来源：安全客
译文仅供参考，具体内容表达以及含义原文为准。
****
**作者：**[ **simp1e_Pwn**
****](http://bobao.360.cn/member/contribute?uid=2814776946)
**预估稿费：400RMB**
******投稿方式：发送邮件至**[ **linwei#360.cn**](mailto:PI:EMAIL) **，或登陆**[
**网页版**](http://bobao.360.cn/contribute/index) **在线投稿******
**漏洞背景**
Qt是一个跨平台的图形化界面编程框架，其版本在小于4.8.7和5.x小于5.4.2解析图片的过程中对于越界检查的处理不当，会导致memcpy的过程中发生越界错误，这个漏洞已经被公开了，但是Qt作为基础库，许多基于Qt的软件并没有更新，同时Qt在跨平台的软件中广泛应用，因此也存在很大风险，同时网络上没有PoC，笔者经过分析写出来PoC。
**漏洞成因**
QGIFFormat::nextY()在处理时，对于越界没有检查，外面被置上了越界标志，内部依然照样运行，这就会出现问题。
代码问题，我们可以对照Qt的code Review来看看。
最终问题在/src/gui/image/gifhandler.cpp
的QGIFFormat::nextY()的memcpy，这里我们可以控制left,使得right-left
小于0，那么拷贝的时候就可以很大了，但是因为这样拷贝的数据过大，只能导致崩溃，不能利用。
    void QGIFFormat::nextY(unsigned char *bits, int bpl)
    {
        int my;
        switch (interlace) {my = qMin(7, bottom-y);
    // Don't dup with transparency
    if (trans_index 
这里就不再赘述，直接给大家一个和Qt的GIFFormat::decode函数里面的变量对应好的例子吧。
下面我们先来看源码QGIFFormat::decode()函数中的部分代码。从490行到560行，这里是涉及到调用QGIFFormat::nextY函数的核心代码，中间主要是一段涉及到LZW的解码算法，解码之后得到GlobalColormap中的index，并把这些像素点对应的颜色值复制到bits对应的数组里面去。
    if (needfirst) {
        firstcode=oldcode=code;
        if (!out_of_bounds && image->height() > y && ((frame == 0) || (firstcode != trans_index)))
            ((QRgb*)FAST_SCAN_LINE(bits, bpl, y))[x] = color(firstcode);
        x++;
        if (x>=swidth) out_of_bounds = true;
        needfirst=false;
        if (x>=left+width) {
            x=left;
            out_of_bounds = left>=swidth || y>=sheight;
            nextY(bits, bpl);
        }
    } else {
        incode=code;
        if (code>=max_code) {
            *sp++=firstcode;
            code=oldcode;
        }
        while (code>=clear_code+2) {
            if (code >= max_code) {
                state = Error;
                return -1;
            }
            *sp++=table[1][code];
            if (code==table[0][code]) {
                state=Error;
                return -1;
            }
            if (sp-stack>=(1=max_code_size)
             && (max_code_sizeheight();
        QRgb *line = 0;
        if (!out_of_bounds && h > y)
            line = (QRgb*)FAST_SCAN_LINE(bits, bpl, y);
        while (sp>stack) {
            const uchar index = *(--sp);
            if (!out_of_bounds && h > y && ((frame == 0) || (index != trans_index))) {
                line[x] = color(index);
            }
            x++;
            if (x>=swidth) out_of_bounds = true;
            if (x>=left+width) {
                x=left;
                out_of_bounds = left>=swidth || y>=sheight;
                nextY(bits, bpl);
                if (!out_of_bounds && h > y)
                    line = (QRgb*)FAST_SCAN_LINE(bits, bpl, y);
            }
        }
    }
我们来看memcpy里面的各个参数是受到什么影响的
    memcpy(FAST_SCAN_LINE(bits, bpl, y+i)+left*sizeof(QRgb), FAST_SCAN_LINE(bits, bpl, y)+left*sizeof(QRgb),
                   (right-left+1)*sizeof(QRgb));
    #define FAST_SCAN_LINE(bits, bpl, y) (bits + (y) * bpl)//bits 和 bpl的来源
     gifhandler.cpp - line 356
    if (image->isNull()) {
        (*image) = QImage(swidth, sheight, format);
        bpl = image->bytesPerLine();
        bits = image->bits();
        memset(bits, 0, image->byteCount());
    }