and performance optimizations are tuned specifically to this model.
Why You Might Not Love Go
We recognize that Go isn’t a perfect solution to every problem. Here are 
some of the downsides of the language: 
Binary size ’Nuff said. When you compile a binary in Go, the binary 
is likely to be multiple megabytes in size. Of course, you can strip debug-
ging symbols and use a packer to help reduce the size, but these steps 
xxii   Introduction
require attention. This can be a drawback, particularly for security 
practitioners who need to attach a binary to an email, host it on a 
shared filesystem, or transfer it over a network.
Verbosity While Go is less verbose than languages like C#, Java, or 
even C/C++, you still might find that the simplistic language construct 
forces you to be overly expressive for things like lists (called slices in Go), 
processing, looping, or error handling. A Python one-liner might easily 
become a three-liner in Go.
Chapter Overview
The first chapter of this book covers a basic overview of Go’s syntax and 
philosophy. Next, we start to explore examples that you can leverage for tool 
development, including various common network protocols like HTTP, DNS, 
and SMB. We then dig into various tactics and problems that we’ve encoun-
tered as penetration testers, addressing topics including data pilfering, packet 
sniffing, and exploit development. Finally, we take a brief step back to talk 
about how you can create dynamic, pluggable tools before diving into crypto, 
attacking Microsoft Windows, and implementing steganography.
In many cases, there will be opportunities to extend the tools we show 
you to meet your specific objectives. Although we present robust examples 
throughout, our real intent is to provide you with the knowledge and foun-
dation through which you can extend or rework the examples to meet your 
goals. We want to teach you to fish.
Before you continue with anything in this book, please note that we—
the authors and publisher—have created this content for legal usage only. 
We won’t accept any liability for the nefarious or illegal things you choose 
to do. All the content here is for educational purposes only; do not perform 
any penetration-testing activities against systems or applications without 
authorized consent. 
The sections that follow provide a brief overview of each chapter.
Chapter 1: Go Fundamentals
The goal of this chapter is to introduce the fundamentals of the Go pro-
gramming language and provide a foundation necessary for understanding 
the concepts within this book. This includes an abridged review of basic 
Go syntax and idioms. We discuss the Go ecosystem, including supporting 
tools, IDEs, dependency management, and more. Readers new to the pro-
gramming language can expect to learn the bare necessities of Go, which 
will allow them to, hopefully, comprehend, implement, and extend the 
examples in later chapters.
Chapter 2: TCP, Scanners, and Proxies
This chapter introduces basic Go concepts and concurrency primitives and 
patterns, input/output (I/O), and the use of interfaces through practical 
TCP applications. We’ll first walk you through creating a simple TCP port 
Introduction   xxiii
scanner that scans a list of ports using parsed command line options. This 
will highlight the simplicity of Go code compared to other languages and will 
develop your understanding of basic types, user input, and error handling. 
Next, we’ll discuss how to improve the efficiency and speed of this port 
scanner by introducing concurrent functions. We’ll then introduce I/O by 
building a TCP proxy—a port forwarder—starting with basic examples and 
refining our code to create a more reliable solution. Lastly, we’ll re-create 
Netcat’s “gaping security hole” feature in Go, teaching you how to run oper-
ating system commands while manipulating stdin and stdout and redirect-
ing them over TCP.
Chapter 3: HTTP Clients and Remote Interaction with Tools
HTTP clients are a critical component to interacting with modern web 
server architectures. This chapter shows you how to create the HTTP 
clients necessary to perform a variety of common web interactions. You’ll 
handle a variety of formats to interact with Shodan and Metasploit. We’ll 
also demonstrate how to work with search engines, using them to scrape 
and parse document metadata so as to extract information useful for 
organizational profiling activities.
Chapter 4: HTTP Servers, Routing, and Middleware
This chapter introduces the concepts and conventions necessary for creat-
ing an HTTP server. We’ll discuss common routing, middleware, and tem-
plating patterns, leveraging this knowledge to create a credential harvester 
and keylogger. Lastly, we’ll demonstrate how to multiplex command-and-
control (C2) connections by building a reverse HTTP proxy.
Chapter 5: Exploiting DNS
This chapter introduces you to basic DNS concepts using Go. First, we’ll 
perform client operations, including how to look for particular domain 
records. Then we’ll show you how to write a custom DNS server and DNS 
proxy, both of which are useful for C2 operations.
Chapter 6: Interacting with SMB and NTLM
We’ll explore the SMB and NTLM protocols, using them as a basis for a 
discussion of protocol implementations in Go. Using a partial implementa-
tion of the SMB protocol, we’ll discuss the marshaling and unmarshaling 
of data, the usage of custom field tags, and more. We’ll discuss and demon-
strate how to use this implementation to retrieve the SMB-signing policy, as 
well as perform password-guessing attacks.
Chapter 7: Abusing Databases and Filesystems 
Pillaging data is a critical aspect of adversarial testing. Data lives in 
numerous resources, including databases and filesystems. This chapter 
introduces basic ways to connect to and interact with databases across a 
xxiv   Introduction
variety of common SQL and NoSQL platforms. You’ll learn the basics of 
connecting to SQL databases and running queries. We’ll show you how to 
search databases and tables for sensitive information, a common technique 
used during post-exploitation. We’ll also show how to walk filesystems and 
inspect files for sensitive information.
Chapter 8: Raw Packet Processing
We’ll show you how to sniff and process network packets by using the 
gopacket library, which uses libpcap. You’ll learn how to identify available 
network devices, use packet filters, and process those packets. We will then 
develop a port scanner that can scan reliably through various protection 
mechanisms, including syn-flood and syn-cookies, which cause normal 
port scans to show excessive false positives.
Chapter 9: Writing and Porting Exploit Code 
This chapter focuses almost solely on creating exploits. It begins with creat-
ing a fuzzer to discover different types of vulnerabilities. The second half 
of the chapter discusses how to port existing exploits to Go from other lan-
guages. This discussion includes a port of a Java deserialization exploit and 
the Dirty COW privilege escalation exploit. We conclude the chapter with 
a discussion on creating and transforming shellcode for use within your 
Go programs.
Chapter 10: Go Plugins and Extendable Tools
We’ll introduce two separate methods for creating extendable tools. The 
first method, introduced in Go version 1.8, uses Go’s native plug-in mecha-
nism. We’ll discuss the use cases for this approach and discuss a second 
approach that leverages Lua to create extensible tools. We’ll demonstrate 
practical examples showing how to adopt either approach to perform a 
common security task.
Chapter 11: Implementing and Attacking Cryptography
This chapter covers the fundamental concepts of symmetric and asymmetric 
cryptography using Go. This information focuses on using and understand-
ing cryptography through the standard Go package. Go is one of the few 
languages that, instead of using a third-party library for encryption, uses 
a native implementation within the language. This makes the code easy to 
navigate, modify, and understand.
We’ll explore the standard library by examining common use cases and 
creating tools. The chapter will show you how to perform hashing, message 
authentication, and encryption. Lastly, we’ll demonstrate how to brute-
force decrypt an RC2-encrypted ciphertext.
Introduction   xxv
Chapter 12: Windows System Interaction and Analysis
In our discussion on attacking Windows, we’ll demonstrate methods of inter-
acting with the Windows native API, explore the syscall package in order to 
perform process injection, and learn how to build a Portable Executable (PE) 
binary parser. The chapter will conclude with a discussion of calling native C 
libraries through Go’s C interoperability mechanisms.
Chapter 13: Hiding Data with Steganography
Steganography is the concealment of a message or file within another file. 
This chapter introduces  one variation of steganography: hiding arbitrary 
data within a PNG image file’s contents. These techniques can be useful for 
exfiltrating information, creating obfuscated C2 messages, and bypassing 
detective or preventative controls.
Chapter 14: Building a Command-and-Control RAT
The final chapter discusses practical implementations of command-and-
control (C2) implants and servers in Go. We’ll leverage the wisdom and 
knowledge gained in previous chapters to build a C2 channel. The C2 
client/server implementation will, by nature of being custom-made, avoid 
signature-based security controls and attempt to circumvent heuristics and 
network-based egress controls.
This chapter will guide you through the 
process of setting up your Go development 
environment and introduce you to the 
language’s syntax. People have written entire  
books on the fundamental mechanics of the language;  
this chapter covers the most basic concepts you’ll need 
in order to work through the code examples in the following chapters. We’ll 
cover everything from primitive data types to implementing concurrency. 
For readers who are already well versed in the language, you’ll find much 
of this chapter to be a review.
Setting Up a Development Environment
To get started with Go, you’ll need a functional development environment. 
In this section, we’ll walk you through the steps to download Go and set up 
your workspace and environment variables. We’ll discuss various options 
for your integrated development environment and some of the standard 
tooling that comes with Go.
1
GO F U N DA M E N TA L S
2   Chapter 1
Downloading and Installing Go
Start by downloading the Go binary release most appropriate to your oper-
ating system and architecture from https://golang.org/dl/. Binaries exist for 
Windows, Linux, and macOS. If you’re using a system that doesn’t have 
an available precompiled binary, you can download the Go source code 
from that link.
Execute the binary and follow the prompts, which will be minimal, 
in order to install the entire set of Go core packages. Packages, called 
libraries in most other languages, contain useful code you can use in 
your Go programs.
Setting GOROOT to Define the Go Binary Location
Next, the operating system needs to know how to find the Go installation. 
In most instances, if you’ve installed Go in the default path, such as /usr 
/local/go on a *Nix/BSD-based system, you don’t have to take any action 
here. However, in the event that you’ve chosen to install Go in a nonstandard 
path or are installing Go on Windows, you’ll need to tell the operating system 
where to find the Go binary. 
You can do this from your command line by setting the reserved GOROOT 
environment variable to the location of your binary. Setting environment 
variables is operating-system specific. On Linux or macOS, you can add this 
to your ~/.profile:
set GOROOT=/path/to/go
On Windows, you can add this environment variable through the 
System (Control Panel), by clicking the Environment Variables button.
Setting GOPATH to Determine the Location of Your Go Workspace
Unlike setting your GOROOT, which is necessary in only certain installation 
scenarios, you must always define an environment variable named GOPATH 
to instruct the Go toolset where your source code, third-party libraries, 
and compiled programs will exist. This can be any location of your choos-
ing. Once you’ve chosen or created this base workspace directory, create 
the following three subdirectories within: bin, pkg, and src (more on these 
directories shortly). Then, set an environment variable named GOPATH that 
points to your base workspace directory. For example, if you want to place 
your projects in a directory called gocode located within your home directory 
on Linux, you set GOPATH to the following:
GOPATH=$HOME/gocode
The bin directory will contain your compiled and installed Go execut-
able binaries. Binaries that are built and installed will be automatically 
placed into this location. The pkg directory stores various package objects, 
including third-party Go dependencies that your code might rely on. For 
Go Fundamentals   3
example, perhaps you want to use another developer’s code that more 
elegantly handles HTTP routing. The pkg directory will contain the binary 
artifacts necessary to consume their implementation in your code. Finally, 
the src directory will contain all the evil source code you’ll write. 
The location of your workspace is arbitrary, but the directories within 
must match this naming convention and structure. The compilation, 
build, and package management commands you’ll learn about later in 
this chapter all rely on this common directory structure. Without this 
important setup, Go projects won’t compile or be able to locate any of 
their necessary dependencies! 
After configuring the necessary GOROOT and GOPATH environment vari-
ables, confirm that they’re properly set. You can do this on Linux and 
Windows via the set command. Also, check that your system can locate 
the binary and that you’ve installed the expected Go version with the go 
version command:
$ go version
go version go1.11.5 linux/amd64
This command should return the version of the binary you installed.
Choosing an Integrated Development Environment
Next, you’ll probably want to select an integrated development environ-
ment (IDE) in which to write your code. Although an IDE isn’t required, 
many have features that help reduce errors in your code, add version-
control shortcuts, aid in package management, and more. As Go is still 
a fairly young language, there may not be as many mature IDEs as for 
other languages. 
Fortunately, advancements over the last few years leave you with sev-
eral, full-featured options. We’ll review some of them in this chapter. For 
a more complete list of IDE or editor options, check out the Go wiki page 
at https://github.com/golang/go/wiki/IDEsAndTextEditorPlugins/. This book is 
IDE/editor agnostic, meaning we won’t force you into any one solution.
Vim Editor
The Vim text editor, available in many operating-system distributions, pro-
vides a versatile, extensible, and completely open source development envi-
ronment. One appealing feature of Vim is that it lets users run everything 
from their terminal without fancy GUIs getting in the way.
Vim contains a vast ecosystem of plug-ins through which you can cus-
tomize themes, add version control, define snippets, add layout and code-
navigation features, include autocomplete, perform syntax highlighting and 
linting, and much, much more. Vim’s most common plug-in management 
systems include Vundle and Pathogen. 
To use Vim for Go, install the vim-go plug-in (https://github.com/fatih/vim-go/) 
shown in Figure 1-1. 
4   Chapter 1
Figure 1-1: The vim-go plug-in
Of course, to use Vim for Go development, you’ll have to become com-
fortable with Vim. Further, customizing your development environment 
with all the features you desire might be a frustrating process. If you use 
Vim, which is free, you’ll likely need to sacrifice some of the conveniences 
of commercial IDEs.
GitHub Atom
GitHub’s IDE, called Atom (https://atom.io/), is a hackable text editor with a 
large offering of community-driven packages. Unlike Vim, Atom provides 
a dedicated IDE application rather than an in-terminal solution, as shown 
in Figure 1-2. 
Figure 1-2: Atom with Go support 
Go Fundamentals   5
Like Vim, Atom is free. It provides tiling, package management, version 
control, debugging, autocomplete, and a myriad of additional features out 
of the box or through the use of the go-plus plug-in, which provides dedi-
cated Go support (https://atom.io/packages/go-plus/).
Microsoft Visual Studio Code
Microsoft’s Visual Studio Code, or VS Code (https://code.visualstudio.com), is 
arguably one of the most feature-rich and easiest IDE applications to con-
figure. VS Code, shown in Figure 1-3, is completely open source and distrib-
uted under an MIT license. 
Figure 1-3: The VS Code IDE with Go support 
VS Code supports a diverse set of extensions for themes, versioning, 
code completion, debugging, linting, and formatting. You can get Go inte-
gration with the vscode-go extension (https://github.com/Microsoft/vscode-go/).
JetBrains GoLand
The JetBrains collection of development tools are efficient and feature-rich, 
making both professional development and hobbyist projects easy to accom-
plish. Figure 1-4 shows what the JetBrains GoLand IDE looks like.
GoLand is the JetBrains commercial IDE dedicated to the Go language. 
Pricing for GoLand ranges from free for students, to $89 annually for indi-
viduals, to $199 annually for organizations. GoLand offers all the expected 
features of a rich IDE, including debugging, code completion, version con-
trol, linting, formatting, and more. Although paying for a product may not 
sound appealing, commercial products such as GoLand typically have official 
support, documentation, timely bug fixes, and some of the other assurances 
that come with enterprise software.
6   Chapter 1
Figure 1-4: The GoLand commercial IDE
Using Common Go Tool Commands
Go ships with several useful commands that simplify the development pro-
cess. The commands themselves are commonly included in IDEs, making 
the tooling consistent across development environments. Let’s take a look 
at some of these commands.
The go run Command
One of the more common commands you’ll execute during development, go 
run will compile and execute the main package—your program’s entry point.
As an example, save the following code under a project directory within 
$GOPATH/src (remember, you created this workspace during installation) 
as main.go:
package main
import (
    "fmt"
)
func main() {
    fmt.Println("Hello, Black Hat Gophers!")
}
From the command line, within the directory containing this file, 
execute go run main.go. You should see Hello, Black Hat Gophers! printed 
to your screen. 
The go build Command
Note that go run executed your file, but it didn’t produce a standalone 
binary file. That’s where go build comes in. The go build command com-
piles your application, including any packages and their dependencies, 
Go Fundamentals   7
without installing the results. It creates a binary file on disk but doesn’t 
execute your program. The files it creates follow reasonable naming con-
ventions, but it’s not uncommon to change the name of the created binary 
file by using the -o output command line option.
Rename main.go from the previous example to hello.go. In a terminal 
window, execute go build hello.go. If everything goes as intended, this 
command should create an executable file with the name hello. Now 