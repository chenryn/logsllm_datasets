from the ﬁgure that the runtime overhead was less than 5%
for these applications. The instrumentation increases the
size of the enclave binary by roughly 64%, mostly due to the
D´ej`a Vu helper function library.
8. DISCUSSION
Core utilization. As discussed in Sec. 6, our design asks
that the OS pin enclave threads (both the application threads
and our reference-clock thread) to dedicated cores, so as to
minimize the frequency of interrupts (and so AEXs) incurred
by the enclave threads. This does not increase our trust of
the OS; the OS’ failure to abide by this contract will in-
crease the interrupts (and so AEXs) detected by D´ej`a Vu,
resulting in self-termination of the enclave (if that is what
the security policy speciﬁes). A malicious OS could accom-
plish the same ends by simply never scheduling the enclave
threads in the ﬁrst place.
Despite not requiring trust of the OS, this contract does
come with costs, speciﬁcally interfering with the normal
scheduling policy of the OS. Coupled with the fact that
our design adds an additional thread to the enclave (the
reference-clock thread), D´ej`a Vu does somewhat interfere
with optimally making use of all available cores on the com-
puter. That said, this contract also provides distinct ben-
eﬁts. In particular, this contract isolates the enclave work-
load from the non-enclave workload. So, for example, a busy
web server running on (and incurring frequent interrupts on)
other cores will not interfere with D´ej`a Vu.
Training coverage. D´ej`a Vu requires dynamic training
of the execution time of each execution pathlet in the CFG
of the programs. Although the execution times of execution
pathlets are not very sensitive to inputs, coverage of training
data is a limitation of our training-based detection method.
However, as discussed in Sec. 6, a default timing threshold
16is provided for each pathlet that is not covered in the train-
ing data. This threshold is basically the minimum time for
an AEX, which is typically much larger than the execution
time of the pathlets. Therefore, this threshold should lead
to few superﬂuous app-AEX alarms but should still ensure
detection of AEXs on the application thread, causing the de-
tection system to work reasonable well even when the train-
ing data does not completely cover every execution pathlet.
Nevertheless, future work will explore approaches to maxi-
mize the training coverage by exploiting techniques such as
concolic execution [17].
Security policy upon AEX detection. Similar to any
intrusion detector, D´ej`a Vu requires the users to specify
a policy that dictates how AEXs detections should be ad-
dressed. We anticipate two general categories of applications
that may need diﬀerent treatment. The ﬁrst category is ap-
plications that contain short secrets, such as cryptographic
keys, that may be leaked through privileged side channels
with relatively few side-channel observations. For these ap-
plications, it would be warranted to set AEX-detection thresh-
olds more conservatively to increase app-AEX alarm preci-
sion, and to take even a low number of AEX detections
as a serious indication of a threat (e.g., stopping the com-
putation or changing keys). The second category includes
applications like libjpeg and freetype that contain much
larger secrets that might eventually leak over the course of
a longer execution [53]. These applications may be toler-
ant of more AEXs, and so leaving the thresholds as, say,
set in Sec. 6 and alerting a remote administrator in case of
excessive AEXs might suﬃce.
Especially for the ﬁrst category above, however, it is im-
portant to note that some AEXs will occur even when no at-
tacks are underway, owing to the normal interrupts and page
faults that occur on computers (even if the enclave threads
are pinned to their own cores). So, a zero-tolerance policy is
unlikely to be viable, even in conjunction with a very high
precision. For this reason, particularly fragile applications
might need to incorporate additional defenses (e.g., frequent,
proactive key updates) to compensate for the fundamentally
ambiguous situation (with respect to side-channel attacks)
that the enclave is in.
Other side-channel threats. While D´ej`a Vu is an eﬀec-
tive defense against side-channel attacks that induce AEXs
(e.g., controlled-channel attacks, and side channels in per-
core caches), there remains the possibility of other side-
channel attacks against an enclave. For example, last-level
cache side-channel attacks [25, 33], which do not require the
attacker to preempt the victim to conduct, should be equally
potent against an enclave and, since existing system-level
defenses (e.g., [27, 61]) presume a trusted OS, these attacks
require additional research to address in this context (or
hardware support, e.g., [51, 26]).
9. CONCLUSION
In this paper we detailed the design and implementation
of D´ej`a Vu, a system for detecting privileged side-channel
attacks mounted by an untrusted OS on an SGX enclave.
D´ej`a Vu detects AEXs that could give rise to such attacks,
by timing each execution pathlet of the enclave application
and detecting when its execution timing suggests that it was
interrupted. The key challenge that D´ej`a Vu addresses is
the lack of any reliable time source accessible to the en-
clave to measure pathlet execution times. To ﬁll this need,
D´ej`a Vu builds a novel reference clock leveraging hardware
transactional support now available on Intel platforms. This
transactional support allows us to construct a reference clock
that will incur a transaction abort with high probability
when the reference-clock thread is interrupted. Moreover,
when it is not interrupted, the reference clock can be used
to eﬀectively delineate between when a pathlet suﬀered an
AEX and when it did not. Our evaluations showed D´ej`a Vu
reliably detects AEXs during pathlet executions. While the
best policy for reacting to detections is application-speciﬁc,
the detections supported by D´ej`a Vu are an important in-
gredient in defending SGX enclaves against privileged side-
channel attacks.
Acknowledgements. This research was supported in part
by NSF grants 1330599 and 1566444.
10. REFERENCES
[1] Intel 64 and IA-32 architectures software developer’s manual,
combined volumes:1,2A,2B,2C,3A,3B and 3C.
http://www.intel.com/content/www/us/en/processors/
architectures-software-developer-manuals.html. version 052,
retrieved on Dec 25, 2014.
[2] Intel 64 and IA-32 architectures software developer’s manual
volumes 3d: System programming guide, part 4. http://www.
intel.eu/content/www/eu/en/architecture-and-technology/
64-ia-32-architectures-software-developer-vol-3d-part-4-manual.
html. Order Number: 332831-059US, June 2016.
[3] Intel Software Guard Extensions programming reference.
https://software.intel.com/sites/default/ﬁles/managed/48/88/
329298-002.pdf. October 2014.
[4] nbench-byte benchmarks.
http://www.math.cmu.edu/˜ﬂorin/bench-32-64/nbench/.
[5] O. Acii¸cmez. Yet another microarchitectural attack: exploiting
I-Cache. In 2007 ACM Workshop on Computer Security
Architecture, 2007.
[6] O. Acii¸cmez, B. B. Brumley, and P. Grabher. New results on
instruction cache attacks. In 12th International Conference on
Cryptographic Hardware and Embedded Systems, 2010.
[7] A. Baumann, M. Peinado, and G. Hunt. Shielding applications
from an untrusted cloud with Haven. ACM Transactions on
Computer Systems, 33(3), Aug. 2015.
[8] S. Checkoway and H. Shacham. Iago attacks: Why the system
call API is a bad untrusted RPC interface. In 18th
International Conference on Architectural Support for
Programming Languages and Operating Systems, 2013.
[9] H. Chen, F. Zhang, C. Chen, Z. Yang, R. Chen, B. Zang, and
W. Mao. Tamper-resistant execution in an untrusted operating
system using a virtual machine monitor. Technical report,
Fudan University, Aug. 2007.
[10] X. Chen, T. Garﬁnkel, E. C. Lewis, P. Subrahmanyam, C. A.
Waldspurger, D. Bohen, J. Dwoskin, and D. R. K. Ports.
Overshadow: A virtualization-based approach to retroﬁtting
protection in commodity operating systmes. In 13th
International Conference on Architectural Support for
Programming Languages and Operating Systems, pages 2–13.
[11] Y. Cheng, X. Ding, and R. H. Deng. AppShield: Protecting
applications against untrusted operating system. Technical
report, Singapore Management University, October 2013.
[12] J. V. Cleemput, B. Coppens, and B. De Sutter. Compiler
mitigations for time attacks on modern x86 processors. ACM
Trans. Archit. Code Optim., 8(4), Jan. 2012.
[13] S. Crane, A. Homescu, S. Brunthaler, P. Larsen, and M. Franz.
Thwarting cache side-channel attacks through dynamic
software diversity. In 2015 Network and Distributed System
Security (NDSS) Symposium, 2015.
[14] J. Criswell, N. Dautenhahn, and V. Adve. Virtual ghost:
Protecting applications from hostile operating systems. In 19th
International Conference on Architectural Support for
Programming Languages and Operating Systems. ACM, 2014.
[15] L. Domnitser, A. Jaleel, J. Loew, N. Abu-Ghazaleh, and
D. Ponomarev. Non-monopolizable caches: Low-complexity
mitigation of cache side channel attacks. ACM Trans. Archit.
Code Optim., 8(4), Jan. 2012.
17[16] G. Doychev, D. Feld, B. Kopf, L. Mauborgne, and J. Reineke.
Cacheaudit: A tool for the static analysis of cache side
channels. In 22nd USENIX Security Symposium, 2013.
[17] P. Godefroid, N. Klarlund, and K. Sen. Dart: Directed
automated random testing. SIGPLAN Not., 40(6):213–223,
June 2005.
[18] D. Gruss, R. Spreitzer, and S. Mangard. Cache template
attacks: Automating attacks on inclusive last-level caches. In
24th USENIX Security Symposium, 2015.
International Conference on Information Security and
Cryptology. Springer-Verlag, 2006.
[39] M. Neve and J.-P. Seifert. Advances on access-driven cache
attacks on AES. In 13th International Conference on Selected
Areas in Cryptography, 2007.
[40] Y. Oren, V. P. Kemerlis, S. Sethumadhavan, and A. D.
Keromytis. The spy in the sandbox: Practical cache attacks in
javascript and their implications. In 22nd ACM Conference on
Computer and Communications Security. ACM, 2015.
[19] L. Guan, J. Lin, B. Luo, J. Jing, and J. Wang. Protecting
[41] C. Percival. Cache missing for fun and proﬁt. In 2005
private keys against memory disclosure attacks using hardware
transactional memory. In 36th IEEE Symposium on Security
and Privacy, 2015.
[20] D. Gullasch, E. Bangerter, and S. Krenn. Cache games –
bringing access-based cache attacks on AES to practice. In
32nd IEEE Symposium on Security and Privacy, 2011.
[21] M. Herlihy and J. E. B. Moss. Transactional memory:
Architectural support for lock-free data structures. SIGARCH
Comput. Archit. News, 21(2):289–300, May 1993.
[22] O. S. Hofmann, S. Kim, A. M. Dunn, M. Z. Lee, and
E. Witchel. InkTag: Secure applications on an untrusted
operating system. In 18th International Conference on
Architectural Support for Programming Languages and
Operating Systems, 2013.
[23] R. Hund, C. Willems, and T. Holz. Practical timing side
channel attacks against kernel space ASLR. In 34th IEEE
Symposium on Security and Privacy, 2013.
[24] M. S. Inci, B. Gulmezoglu, G. Irazoqui, T. Eisenbarth, and
B. Sunar. Seriously, get oﬀ my cloud! Cross-VM RSA key
recovery in a public cloud. Cryptology ePrint Archive, Report
2015/898, 2015. http://eprint.iacr.org/.
[25] G. Irazoqui, T. Eisenbarth, and B. Sunar. S$A: A shared cache
attack that works across cores and deﬁes VM sandboxing—and
its application to AES. In 36th IEEE Symposium on Security
and Privacy, 2015.
[26] G. Keramidas, A. Antonopoulos, D. N. Serpanos, and
S. Kaxiras. Non deterministic caches: A simple and eﬀective
defense against side channel attacks. Design Automation for
Embedded Systems, 12(3), 2008.
[27] T. Kim, M. Peinado, and G. Mainar-Ruiz. STEALTHMEM:
system-level protection against cache-based side channel attacks
in the cloud. In 21st USENIX Security Symposium, 2012.
[28] C. Lattner and V. Adve. LLVM: A compilation framework for
lifelong program analysis and transformation. In International
Symposium on Code Generation and Optimization:
Feedback-directed and Runtime Optimization. IEEE Computer
Society, 2004.
[29] P. Li, D. Gao, and M. K. Reiter. Mitigating access-driven
timing channels in clouds using StopWatch. In 43rd
IEEE/IFIP International Conference on Dependable Systems
and Networks, 2013.
[30] Y. Li, J. McCune, J. Newsome, A. Perrig, B. Baker, and
W. Drewry. Minibox: A two-way sandbox for x86 native code.
In 2014 USENIX Annual Technical Conference, 2014.
[31] D. Lie, C. A. Thekkath, and M. Horowitz. Implementing an
untrusted operating system on trusted hardware. In 19th ACM
Symposium on Operating Systems Principles. ACM, 2003.
[32] F. Liu and R. B. Lee. Random ﬁll cache architecture. In 47th
Annual IEEE/ACM International Symposium on
Microarchitecture. IEEE, 2014.
[33] F. Liu, Y. Yarom, Q. Ge, G. Heiser, and R. B. Lee. Last-level
cache side-channel attacks are practical. In 36th IEEE
Symposium on Security and Privacy, 2015.
[34] Y. Liu, Y. Xia, H. Guan, B. Zang, and H. Chen. Concurrent
and consistent virtual machine introspection with hardware
transactional memory. In 20th International Symposium on
High Performance Computer Architecture, 2014.
[35] H. Mantel and A. Starostin. Transforming Out Timing Leaks,
More or Less. Springer International Publishing, 2015.
[36] R. Martin, J. Demme, and S. Sethumadhavan. Timewarp:
rethinking timekeeping and performance monitoring
mechanisms to mitigate side-channel attacks. In 39th Annual
International Symposium on Computer Architecture, 2012.
[37] J. M. McCune, B. J. Parno, A. Perrig, M. K. Reiter, and
H. Isozaki. Flicker: An execution infrastructure for TCB
minimization. In 3rd ACM European Conference on Computer
Systems, 2008.
[38] D. Molnar, M. Piotrowski, D. Schultz, and D. Wagner. The
program counter security model: Automatic detection and
removal of control-ﬂow side channel attacks. In 8th
BSDCan, 2005.
[42] D. R. K. Ports and T. Garﬁnkel. Towards application security
on untrusted operating systems. In 3rd Workshop on Hot
Topics in Security, 2008.
[43] A. Rane, C. Lin, and M. Tiwari. Raccoon: Closing digital
side-channels through obfuscated execution. In 24th USENIX
Security Symposium, 2015.
[44] M.-W. Shih, S. Lee, T. Kim, and M. Peinado. T-SGX:
Eradicating controlled-channel attacks against enclave
programs. In ISOC Network and Distributed System Security
Symposium, 2017.
[45] S. Shinde, Z. L. Chua, V. Narayanan, and P. Saxena.
Preventing page faults from telling your secrets. In 11th ACM
Asia Conference on Computer and Communications Security,
2016.
[46] R. Ta-Min, L. Litty, and D. Lie. Splitting interfaces: Making
trust between applications and operating systems conﬁgurable.
In 7th USENIX Symposium on Operating Systems Design and
Implementation, 2006.
[47] E. Tromer, D. A. Osvik, and A. Shamir. Eﬃcient cache attacks
on AES, and countermeasures. J. Cryptol., 23(2):37–71, Jan.
2010.
[48] V. Varadarajan, T. Ristenpart, and M. Swift. Scheduler-based
defenses against cross-VM side-channels. In 23th USENIX
Security Symposium, 2014.
[49] B. C. Vattikonda, S. Das, and H. Shacham. Eliminating ﬁne
grained timers in Xen. In 3rd ACM Workshop on Cloud
Computing Security, 2011.
[50] Z. Wang and R. B. Lee. New cache designs for thwarting
software cache-based side channel attacks. In 34th annual
international symposium on Computer architecture, 2007.
[51] Z. Wang and R. B. Lee. A novel cache architecture with
enhanced performance and security. In 41st IEEE/ACM
International Symposium on Microarchitecture, 2008.
[52] J. C. Wray. An analysis of covert timing channels. In IEEE
Symposium on Security and Privacy, 1991.
[53] Y. Xu, W. Cui, and M. Peinado. Controlled-channel attacks:
Deterministic side channels for untrusted operating systems. In
36th IEEE Symposium on Security and Privacy. IEEE, 2015.
[54] J. Yang and K. G. Shin. Using hypervisor to provide data
secrecy for user applications on a per-page basis. In 4th ACM
SIGPLAN/SIGOPS International Conference on Virtual
Execution Environments (VEE). ACM, 2008.
[55] Y. Yarom and K. E. Falkner. FLUSH+RELOAD: A high
resolution, low noise, L3 cache side-channel attack. In 23rd
USENIX Security Symposium, 2014.
[56] F. Zhang, J. Chen, H. Chen, and B. Zang. Cloudvisor:
Retroﬁtting protection of virtual machines in multi-tenant
cloud with nested virtualization. In 23rd ACM Symposium on
Operating Systems Principles. ACM, 2011.
[57] T. Zhang, Y. Zhang, and R. Lee. Cloudradar: A real-time
side-channel attack detection system in clouds. In 19th
International Symposium on Research in Attacks, Intrusions
and Defenses (RAID), 2016.
[58] Y. Zhang, A. Juels, M. K. Reiter, and T. Ristenpart. Cross-VM
side channels and their use to extract private keys. In ACM
Conference on Computer and Communications Security,
2012.
[59] Y. Zhang, A. Juels, M. K. Reiter, and T. Ristenpart.
Cross-tenant side-channel attacks in PaaS clouds. In ACM
Conference on Computer and Communications Security,
2014.
[60] Y. Zhang and M. K. Reiter. D¨uppel: Retroﬁtting commodity
operating systems to mitigate cache side channels in the cloud.
In 20th ACM Conference on Computer and Communications
Security, 2013.
[61] Z. Zhou, M. K. Reiter, and Y. Zhang. A software approach to
defeating side channels in last-level caches. In 23rd ACM
Conference on Computer and Communications Security,
2016.
18