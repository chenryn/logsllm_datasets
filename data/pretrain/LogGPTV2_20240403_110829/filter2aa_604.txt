Fingerprinting and Cracking Java 
Obfuscated Code
Yiannis Pavlosoglou
A total of 36 slides
Brief Outline
1.
Background
2.
Motivation
3.
Methodology
4.
Fingerprinting Tool
5.
Examples
6.
Conclusions
1. Background
•
Java Bytecode Operations
•
Language Security Mechanisms 
•
Disassembling HelloWorld.java
•
From Bytecode to Source
•
What Popular Obfuscators Offer?
1.1 Java Bytecode
Architecture (x86, PPC, Alpha)
Java Virtual Machine
Class 
Loader
Execution 
Engine
MyProject.jar
MyProject.class
Host Operating System (Windows, Linux, etc.)
Native 
Method 
Calls
Bytecode
1.2 Language Security Mechanisms
•
Type, memory and control flow checks
–
Instruction sets of the virtual machine [1]
•
Object creation
–
Privilege escalation [2]
•
Function calls
•
Exception handling
–
Verification (format, type, other violations) [3]
•
Security vulnerabilities lsd-pl.net [4]
1.3 HelloWorld
in Bytecode
HelloWorld.java
HelloWorld.class
HelloWorld.bc
(javac)
(javap)
1.4 Bytecode to Source
•
Java is Platform Independent Code
–
Simplifies reversing compared to C/C++
•
Popular Java Decompilers [5]
•
Particular obfuscators are written with the 
operations of java Decompilers in mind [6]
1.5 What do obfuscators offer?
•
Operations:
–
Less Human Readable 
Code
–
Remove Debug 
Information
–
Alter the Control Flow
–
“Encrypt”
Constants
–
Restructure Simple 
Logic
–
Inject Unnecessary Code
•
Usability:
–
Used for applications 
that are delivered to the 
user
–
Generally, used in J2SE 
Applets, Installed 
Applications, etc.
–
Generally, not used in 
Java Enterprise 
Environments
2. Motivation
•
Basic Obfuscation Techniques
•
Reverse Engineering Particulars
•
Who is Using Obfuscators?
2.1 Basic Obfuscation Techniques
•
Renaming of objects and methods
–
a.class, b.class, a.c(5), etc.
•
Extending classes
–
public class a extends d {
•
Removing line numbers
•
Encoding String Values
•
Variable Splitting Techniques
–
boolean
z becomes int
x=1; if (x perl elucidate.pl -h
•
Elucidate v0.1 -
Java Obfuscator Fingerprinting/Cracking Tool
•
Usage: elucidate.pl [-options *]
•
-h               
: Print this usage message
•
-v              
: Verbose option
•
-o              
: Print supported obfuscators
•
-t               
: Test current java environment
•
-f file         
: Specify class file to identify
•
-j jar file      
: Specify jar file to identify
•
-d directory     
: Specify directory to identify
•
Examples:
•
elucidate.pl -f MyClass.class
•
elucidate.pl -d MyJar.jar
4.4 Target Deliverables of elucidate
•
Given a jar file, or class files
•
Identify which obfuscator has been used
•
Recover known Strings within the file
•
Give an estimate of the complexity
•
Provide a map, as a tool of the application
5. Examples
•
Examine the following commercial tools:
–
Zelix
KlassMaster
(4.5.0)
–
JShrink
(2.3.7)
–
RetroGuard
(2.2.0)
5.1 Zelix
KlassMaster
4.5.0 (1/4)
•
String literals three levels: Normal, 
Aggressive and Flow Obfuscate. 
•
PasswordCheck.class
through javap:
6
:
ldc
#8; //String ,bw:)q`iqv,=\"
14
:
ldc
#6; //String (km:N}?ps&,
22
:
ldc
#3; //String ,oa(-↓#wDecoded:
Password Correct!
•
64:
tableswitch{ //0 to 3
•
0: 96;
•
1: 101;
•
2: 105;
•
3: 109;
•
default: 114 }
•
96:bipush
124
•
98:goto
116
•
101:
iconst_3
•
102:
goto
116
•
105:
iconst_4
•
106:
goto
116
•
109:
bipush
73
•
111:
goto
116
•
114:
bipush
94
•
116:
ixor
•
117:
i2c
5.1 Zelix
KlassMaster
4.5.0 (4/4)
•
String literals: Normal, Aggressive and 
Flow Obfuscate. 
•
The algorithm used for all three appears 
to be identical. 
•
Yet, the keys used, change at every 
obfuscation attempt. 
5.2 JShrink
2.3.7 (1/4) 
•
Creates a new package, with a single class 
•
Replaces String code with:
23:  bipush
62
25:  invokestatic
#48; //Method 
I/I.I:(I)Ljava/lang/String;
28:  invokevirtual
#7; //Method 
java/lang/String.equals:(Ljava/lang/Objec
t;)Z
•
Equivalent to: ( I.I.I( 79 ) );
5.2 JShrink
2.3.7 (2/4)
•
Contents of package I include 
a file called I.gif
•
However, this file is not an 
image file:
•
As a file is being accessed, a decompiler
can be 
used to view I.class
5.2 JShrink
2.3.7 (3/4)
1.
public class I {
2.
…
3.
public static synchronized final String I(int
int1){
4.
int
int2 = int1 & 0xFF;
5.
if( close[int2] != int1 ) {
6.
String String3;
7.
close[int2] = int1;
8.
if( int1 < 0 ) {
9.
int1 = int1
& 0xFFFF;
10.
String3 = new String( SDQU, int1, SDQU[int1 -
0x1] & 0xFF ).intern();
11.
append[int2] = String3;
12.
}
13.
return append[int2];
14.
}
15.
…
16.
static {
17.
try {
18.
Object Object1 = new I().getClass().getResourceAsStream( "" + 'I' + '.' + 'g' 
+ 'i' + 'f' );
5.2 JShrink
2.3.7 (4/4)
•
Creates an invalid gif file storing the 
encrypted Strings
•
Uses a separate class and method to 
perform decryption
•
Replaces Strings with: I.I(int) e.g. I.I(97)
•
Does not alter Strings declared as 
static and final
•
Introduces exceptions if the wrong int
is 
passed as argument
5.3 RetroGuard
2.2.0
•
Does offer String encryption
•
Goes to show that some obfuscators 
simply don’t use this approach
•
The creators of RetroGuard
quote: 
“obfuscation is not encryption”
6. Final
Conclusions
•
Static obfuscation is at a primitive level
•
Encrypted Strings are an excellent entry 
point into understanding the application
•
Identifying the crypto used: 
–
yields the obfuscator tool used 
–
yields what changes to expect in snippets
6. Final
Conclusions
•
Propose polymorphic obfuscation 
–
Developers map out critical elements
•
Understanding of what an obfuscator can do
–
Obfuscator changes behaviour depending on file
•
UI treated differently to say, protocol implementation
–
Algorithms vary according to key file
•
In how many ways can you write a for/while loop? 
Questions
•
PI:EMAIL