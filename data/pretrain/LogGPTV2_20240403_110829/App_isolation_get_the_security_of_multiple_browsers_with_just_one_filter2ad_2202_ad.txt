the RenderingEngine and accessing cookies issued by the
app. For state isolation without entry-point restriction, the
Alloy analyzer found a violation of assertion 2 above that
is very similar to the violation we found in the model with
both mechanisms. We will therefore describe both results
together in the next paragraphs.
When checking the model with both mechanisms, the Alloy
analyzer found no violations to assertion 1 above but did
ﬁnd a violation for assertion 2. This violation occurs because
our implementation at the time did not consider the app
container as part of its notion of “same-origin” when applied
to entry-point restriction. Figure 3 illustrates this violation,
as well as the violation found for state isolation without
entry-point restriction. The scenario is as follows:
Alice opens a session with bank.com as an app with a ded-
icated app renderer and receives credentials. Alice also visits
attack.com with the browser’s ordinary renderer, causing
attack.com to send a script which compromises the ordinary
renderer. The attacker creates a bank.com script context
in the ordinary renderer. Then the attacker causes the
bank.com script context to open a new window with top-
level URL pointed at an exploitable non-entry URL within
the bank.com app. This new window will open in the app
renderer, because its initial URL is within the app, and its
request for the non-entry URL will pass entry point checks,
because the script context which caused the request is “same-
origin” (owned by bank.com). Similarly, the request will also
be sent if entry-point restriction is absent. This last request
thus causes the attack to succeed.
The discovery of this vulnerability underscores two points
regarding app containers. The ﬁrst is that both entry-point
restriction and state isolation mechanisms are necessary to
stop a rendering engine attacker. The second is that the same-
origin policy must be extended to include app containers. In
eﬀect, app containers divide a previously atomic origin into
two new origins, one inside and one outside the container. As
Figure 4: Entry points to popular sites observed
by 10,551 Mozilla Test Pilot browsers. Numbers in
parentheses indicate the total number of incoming
links observed.
such, the entry-point restriction policy should have rejected
the last request in our scenario, because its source was outside
the app container and its target was inside. We implemented
this updated notion of same-origin in our model and veriﬁed
that both assertions were now upheld, up to the ﬁnite sizes
we tried, again up to 10 NetworkEvents.
7.2 Complexity of Adoption
Entry-point restriction requires web sites to identify all
URLs that they wish make public to other web sites. Highly
socially integrated sites like Facebook or content-oriented
sites like New York Times will have diﬃculty adopting entry-
point restriction due to the inherent complexity in capturing
all the possible entry points. On the other hand, we believe
non-social web sites such as online banking applications will
have an easier time identifying valid entry-points, making it
practical to deploy entry-point restriction.
To gain additional insight into the eﬀort required for dif-
ferent web sites to adopt entry-point restriction, we used
the Mozilla Test Pilot platform [8]. Mozilla Test Pilot is
a Firefox extension installed on more than 3 million active
Firefox browsers. Our evaluation was performed on 10,551
of those browsers over a period of 3 days. In our study, we
simulated entry-point restriction for 9 web sites shown in
Figure 4. These sites consist of popular email and web appli-
cations, online banking pages of major ﬁnancial institutions,
news and social networks, and popular Chrome Web Store
applications.
For each site, we gathered URL hashes of all incoming
links to the site that appear on all pages that Test Pilot
Browsers visited. Each incoming link represents either an
actual HTML link or an embedded resource pointing to
the site (e.g., a.com/logo.png would be an incoming link
to a.com). Our results demonstrate several ideas. First,
they verify our hypothesis that web sites that encourage
the sharing of content will have a diﬃcult time opting in
to entry-point restriction (e.g., New York Times, Facebook,
and Last.fm). Second, web sites with no intention of sharing
attack.comApp Rendering EngineCompromised Rendering Engineowner: bank.comowner: bank.comowner: bank.combank.com1. gets user     credentialsUser Browser2a. visits       attack.com2b. compromises       rendering engineScript Context3. opens new script context4. request for     exploitable URL051015202530354045500102030405060708090100Number of entry pointsPercent incoming links covered (%)  Flixster (13)Wells Fargo (56)Gmail (239,957)Capital One (33)Grooveshark (90)Bank of America (477)Facebook (1,019,100)New York Times (12,503)Last FM (5,289)content can opt in to entry-point restriction with relatively
few entry points (e.g., Wells Fargo, Capital One and Flixster,
a Chrome Web Store application). For certain sites such as
Gmail and Bank of America, the compatibility with entry-
point restriction is less clear. While 10 entry points can
cover up to 95 percent of the incoming links, fully covering
all incoming links appears to be a non-trivial task. For
Gmail, we suspect this to be due to Gmail widgets, multiple
login URLs (e.g., mail.google.com/mail/u/0/), and web
mail portals from numerous organizations hosted by Gmail
(e.g., mail.google.com/a/west.cmu.edu/). It is diﬃcult to
conﬁrm this hypothesis from the data set, as we only collected
hashes of the URLs to protect user privacy. For the online
banking application for Bank of America, each entry point
path is valid at a number of regional load-balancing domains,
thus accounting for the large number of total entry point
URLs.
Web applications that consist of multiple subdomains some-
times face an interesting challenge, if some subdomains are
more amenable to app isolation than others. For example, a
bank may have some of its login-guarded functionality on a
online subdomain, while also having a separate creditcards
subdomain with signiﬁcant numbers of entry points. If pages
on the creditcards subdomain can also recognize when a
user is logged in, then it is diﬃcult to isolate the two subdo-
mains from each other. Such apps may either face diﬃculties
adopting app isolation or be forced to specify less precise
entry points.
To assist web site owners with identifying valid entry points
and determining whether app isolation is suitable for their
site, we propose a report-only mode similar to that of Content
Security Policy [33]. Instead of enforcing a policy violation,
report-only mode will send a violation report to the app’s
server. Report-only mode can thus be used to generate a
suitable policy ﬁle that avoids false positives.
Web developers interested in adopting app isolation should
consider the speciﬁc feature trade-oﬀs they will be making.
Their apps should have limited deep incoming links as entry
points. They should not rely on authenticated resources
from third parties, and they should not depend on their own
authenticated resources being loaded on third party sites.
Overall, we found that certain types of sites, including several
online banks, do appear to be good candidates for adopting
app isolation.
7.3 Performance
In this section, we evaluate the performance overhead of
app isolation due to entry-point restriction and state isolation.
While extra disk space is required for isolated caches, the
overhead is generally far less than using multiple browsers.
7.3.1 Navigation Latency
In an entry-point restriction enabled browser, every web
resource load for an app is preceded by an entry-point check.
This check determines whether the URL of the web resource
matches one of the known entry-points. Entry-point lookup
can be made eﬃcient using a hash table, imposing negligible
cost on navigation latency. We measured the load times of
the Alexa Top 100 Web sites with and without entry-point
restriction enabled. For an artiﬁcially high list of 10000 entry
points, the overhead incurred from hash table lookups was
small enough to be lost in the noise (less than 0.1 ms per
page load).
Storage and Memory Overhead
Besides entry-point lookup, policy ﬁles must also be fetched.
The fetch of the policy ﬁle is done only once at app installa-
tion time, and thus we do not include it in the performance
overhead.
7.3.2
To see the impact of state isolation, we measured the
disk and memory space required for visiting 12 popular sites
in their own tabs, similar to the sites used in Figure 4.
Chromium stores a user’s persistent state in a conﬁgurable
proﬁle directory, so we compared three conditions: all sites
in a single Chromium proﬁle, all in a single Chromium proﬁle
as isolated apps, and each in a separate Chromium proﬁle.
For sites that did not require HTTPS, we used pre-recorded
network data to reduce variability. For Gmail, Bank of
America, and Chase Bank, we logged into an account. We
report the average of three trials.
Visiting all sites in a single proﬁle required 19 MB of disk
space. Using isolated apps required 86 MB, while multiple
browsers required 117 MB. Each of these proﬁles includes
a partial download of Chromium’s Safe Browsing database
(2.6 MB), which is a source of overhead for each additional
browser proﬁle.
We were surprised that isolated apps required over 4 times
the space of a single proﬁle. This is because Chromium
aggressively allocates disk space for each cache. This behavior
could be modiﬁed to be less aggressive for isolated apps.
Users could also opt for an in-memory cache for isolated
apps, which retains the security beneﬁts and lowers the disk
space required to 9.6 MB.
The total resident memory required for visiting all sites
in separate tabs of a single proﬁle was 729 MB.1 We found
that using isolated apps used a comparable 730 MB, while
using a separate browser for each site used an aggregate of
1.83 GB memory.
These results show that by using isolated apps rather than
multiple browsers, we can reduce the performance trade-oﬀ
required for our security beneﬁts.
8. CONCLUSION
We have shown that a single browser can achieve the
security beneﬁts of using multiple browsers, by implementing
entry-point restriction and state isolation to isolate sensitive
apps. These mechanisms might not be appropriate for every
web site, but they can be eﬀective for many high-value web
sites, such as online banks. Using this approach, these high-
value web sites can help protect themselves and their users
from a broad spectrum of attacks with minimal eﬀort.
Acknowledgements
We thank John Mitchell for his helpful suggestions and feed-
back. We thank David Chan, Sid Stamm, Jono Xia, Jinghua
Zhang and the entire Mozilla Test Pilot team for giving us
the opportunity to use Mozilla’s Test Pilot platform. This
work was supported by a Google Focused Research Award
on the security of cloud and Web clients.
1Chromium over counts memory usage by not fully account-
ing for shared memory, but this is consistent across our three
conditions.
9. REFERENCES
[1] R. Cook, “The Next Big Browser Exploit,” CSO
Magazine, p. 15, Feb 2008.
[2] E. Iverson, “Two Web Browsers can be More Secure
than One.”
http://www.blueridgenetworks.com/securitynowblog/
dual-web-browsers-can-avoid-information-disclosures
[3] D. Jang, R. Jhala, S. Lerner, and H. Shacham, “An
empirical study of privacy-violating information ﬂows
in JavaScript web applications,” in Proceedings of the
17th ACM Conference on Computer and
Communications Security. ACM, 2010, pp. 270–283.
[4] C. Jackson, A. Bortz, D. Boneh, and J. C. Mitchell,
“Protecting browser state from web privacy attacks,” in
Proceedings of the 15th International Conference on
World Wide Web, ser. WWW ’06. New York, NY,
USA: ACM, 2006, pp. 737–744. [Online]. Available:
http://doi.acm.org/10.1145/1135777.1135884
[5] E. Felten and M. Schneider, “Timing attacks on web
privacy,” in Proceedings of the 7th ACM Conference on
Computer and Communications Security. ACM, 2000,
pp. 25–32.
[6] A. Barth, C. Jackson, and C. Reis, “The Security
Architecture of the Chromium Browser,” 2008
Technical Report.
[17] S. Crites, F. Hsu, and H. Chen, “OMash: enabling
secure web mashups via object abstractions,” in ACM
Conference on Computer and Communications Security,
2008, pp. 99–108.
[18] S. Stamm, B. Sterne, and G. Markham, “Reining in the
Web with Content Security Policy,” in International
Conference on World Wide Web (WWW), 2010.
[19] T. Oda, G. Wurster, P. V. Oorschot, and A. Somayaji,
“SOMA: Mutual Approval for Included Content in Web
Pages,” in ACM Conference on Computer and
Communications Security, 2008.
[20] L. D. Baron. (2010) Preventing attacks on a user’s
history through CSS :visited selectors.
http://dbaron.org/mozilla/visited-privacy
[21] Z. Weinberg, E. Y. Chen, P. Jayaraman, and
C. Jackson, “I Still Know What You Visited Last
Summer: Leaking browsing history via user interaction
and side channel attacks,” in IEEE Symposium on
Security and Privacy, 2011.
[22] D. Morin, “Announcing Facebook Connect,” 2008,
https://developers.facebook.com/blog/post/108/.
[23] E. Hammer-Lahav, “Web Host Metadata,” 2010,
http://tools.ietf.org/html/draft-hammer-hostmeta-13.
[24] C. Jackson and A. Barth, “Beware of Finer-Grained
Origins,” in Web 2.0 Security and Privacy, 2008.
[7] Mozilla Foundation Security Advisory 2009-29,
[25] Google, “Packaged Apps,”
“Arbitrary code execution using event listeners.”
http://www.mozilla.org/security/announce/2009/
mfsa2009-29.html
[8] Mozilla, “Test Pilot,”
https://testpilot.mozillalabs.com/.
[9] D. Akhawe, A. Barth, P. E. Lam, J. Mitchell, and
D. Song, “Towards a Formal Foundation of Web
Security,” Computer Security Foundations Symposium,
Proceedings of, IEEE, vol. 0, pp. 290–304, 2010.
[10] Mozilla, “Prism,” http://prism.mozillalabs.com/.
[11] T. Ditchendorf, “Fluid,” http://ﬂuidapp.com/.
[12] M. Silbey and P. Brundrett, “Understanding and
working in Protected Mode Internet Explorer,” 2006,
http:
//msdn.microsoft.com/en-us/library/bb250462.aspx.
[13] C. Grier, S. Tang, and S. T. King, “Secure Web
Browsing with the OP Web Browser,” in IEEE
Symposium on Security and Privacy, 2008, pp. 402–416.
[14] H. J. Wang, C. Grier, A. Moshchuk, S. T. King,
P. Choudhury, and H. Venter, “The Multi-Principal OS
Construction of the Gazelle Web Browser,” in USENIX
Security Symposium, 2009, pp. 417–432.
[15] L.-S. Huang, Z. Weinberg, C. Evans, and C. Jackson,
“Protecting Browsers from Cross-Origin CSS Attacks,”
in ACM Conference on Computer and Communications
Security), 2010.
[16] R. S. Cox, S. D. Gribble, H. M. Levy, and J. G.
Hansen, “A Safety-Oriented Platform for Web
Applications,” in IEEE Symposium on Security and
Privacy, 2006, pp. 350–364.
http://code.google.com/chrome/extensions/apps.html.
[26] Mozilla, “Manifest File,” https://developer.mozilla.org/
en/OpenWebApps/The Manifest.
[27] Google, “Veriﬁed Author,”
http://www.google.com/support/chrome webstore/
bin/answer.py?hl=en&answer=173657.
[28] G. Aggarwal, E. Bursztein, C. Jackson, and D. Boneh,
“An Analysis of Private Browsing Modes in Modern
Browsers,” in USENIX Security Symposium, 2010, pp.
79–94.
[29] C. Reis and S. D. Gribble, “Isolating Web Programs in
Modern Browser Architectures,” in ACM European
Conference on Computer Systems (EuroSys), 2009.
[30] D. Jackson, “Alloy: a lightweight object modelling
notation,” ACM Transactions on Software Engineering
and Methodology (TOSEM), vol. 11, no. 2, pp. 256–290,
2002.
[31] ——, Software Abstractions: Logic, Language, and
Analysis. The MIT Press, 2006.
[32] F. Kerschbaum, “Simple cross-site attack prevention,”
in Security and Privacy in Communications Networks
and the Workshops, 2007. SecureComm 2007. Third
International Conference on, Sept. 2007, pp. 464 –472.
[33] Mozilla, “CSP speciﬁcation,” 2011, https://wiki.mozilla.
org/Security/CSP/Speciﬁcation#Report-Only mode.