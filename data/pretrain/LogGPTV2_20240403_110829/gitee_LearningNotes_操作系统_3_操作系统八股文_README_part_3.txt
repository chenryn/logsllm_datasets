**DMA直接存储器存取**
在ＤＭＡ出现之前，CPU与外设之间的数据传送方式有程序传送方式、中断传送方式。CPU是通过系统总线与其他部件连接并进行数据传输。
DMA的出现就是为了解决批量数据的输入/输出问题。DMA是指外部设备不通过CPU而直接与系统内存交换数据的接口技术。这样数据的传送速度就取决于存储器和外设的工作速度。
**死锁**：一个进程集合中每个程序都在等待只能由该进程集合中其他进程才能引发的事件，那么说明该进程集合是死锁
**死锁的四个必要条件**
- 互斥条件
- 占有和等待
- 不可抢占
- 环路等待
处理死锁的四种策略
- 鸵鸟算法；发生的概率是很低的
- 检测死锁并且恢复
  - 通过深搜+回溯来找环，如果所有节点都是可以则是安全的
  - 每种类型多个资源的死锁检测（E+R+A矩阵）
  - 恢复地方法
    - 抢占
    - 利用回滚
    - 杀死进程来恢复
- 死锁避免
  - 资源轨迹图：不安全不代表一定会死锁，只代表有可能死锁
  - 银行家算法；分配然后回收看是否可以全部满足
- 死锁预防：从四个条件去破坏
  - 破坏互斥条件：避免在非绝对必要时分配资源；申请资源的进程越少越好
  - 破坏占有和等待条件：规定开始执行前必须获得所有资源；当它请求时先释放自己手上的资源
  - 破坏不可抢占条件：如果遭到拒绝就释放自己的资源
  - 破坏环形等待：给资源编号，申请后面的必须先获得前面的资源
**两阶段锁**
第一阶段：进程试图对所有所需资源的记录进行加锁。如果成功执行第二阶段，完成后释放锁，第一阶段并没有做实际工作
如果第一阶段所需的锁已经被加锁，则释放全部锁，从头再来
**通信死锁**
通过超时中断死锁
**活锁**
互相谦让，但是没有进展
**饥饿**
无限制推后，虽然没有被阻塞
# 操作系统
#### 进程与线程
进程的创建
- 系统启动
- 执行正在进行的进程调用进程的创建
- 用户申请创建
- 批处理的初始化
进程的结束
- 完成任务
- 发生了错误（自愿）
- 发生严重错误（非自愿）
- 被其他进程杀死
三个状态
- 运行
- 就绪
- 阻塞
运行到就绪：调用程序选择另一个进程
**进程的内部结构**
代码块、数据、堆、栈、PCB进程控制块（用户内用、系统内用、寄存器信息）
**切换的步骤**
- 保存PCB
- 加载PCB
- 刷新内存缓存
- 改变地址映射
###### 父进程和子进程
新创建的子进程**几乎**和父进程完全一样，子进程会获得父进程用户级虚拟地址空间（但是独立）一份副本，包括**代码和数据段、堆、共享库以及与用户栈**，子进程获得父进程任何打开**文件描述符相同的副本**，也就是子进程可以读取父进程中打开的任何文件。最大区别是拥有不同的PID；只是在创建的时候是一样的，后续的改变是相互独立的。
**僵死进程**
发生在子进程回收过程中，当进程由于某种原因终止时，内核不会立刻从系统中删除，而是保持已终止状态，直到父进程回收。所以一个终止了但是还没被回收的进程时**僵死进程**
如果父进程终止了，但是还没有回收子进程，会有一个init进程成为其养父进程，来回收子进程
###### fork和execve
fork会创建一个子进程，并且返回两次（用来区别父进程和子进程）；execve是在原来的进程的**上下文中加载运行另一个新程序**，如果成功不会返回
- 系统中的每个程序都是运行在某个进程的**context**中的。context是由程序正确运行所需的状态组成的，这个状态包括存放在存储器中的**程序的代码和数据**，它的**栈**、**通用目的寄存器的内容**、**程序计数器**（PC）、**环境变量**以及打开的**文件描述符的集合**。
- 每个**线程**都有它自己的线程context，包括一个唯一的整数线程ID、栈、栈指针、程序计数器（PC）、通用目的寄存器和条件码。
- 每个线程和运行在同一进程内的其他线程一起共享进程context的**剩余部分**。这包括整个用户虚拟地址空间，它是由**只读文本（代码）**、**读/写数据**、**堆以及所有的共享库代码和数据区域组成**。线程也同样共享打开文件的集合。
###### 线程的过程
**创建线程**
- pthread_create:创建一个新的线程，可以在参数中绑定返回的线程tid，传入函数用于让新创线程执行这个函数，设置可以传入参数改变线程的默认值
**线程终止**
- 当顶层的线程例程返回时，线程也就隐式终止
- 通过调用pthread_exit函数，线程会显示结束。主线程调用pthread_exit会让其他所有对等线程终止
- 其他对象线程调用exit，该函数会终止进程导致该进程相关的线程都终止
- 零杠一个对等线程通过以线程id传入**pthread_cancel**来终止其他线程
**回收已终止线程的资源**
pthread_join函数可以等待一个函数终止
**分离线程**
线程是可结合的也可以是分离的，一个结合的线程能够被其他线程收回和杀死；分离的线程是不能被其他线程杀死或者回收，**他的资源在它终止的时候由系统自动释放**。
使用pthread_detach
###### 信号
一个小消息，通知进程系统发生了某一种类型的事件。通知用户进程发生了异常；如通过kill9一个进程向另一个进程来强制终止它；ctrl+c内核向前台进程组发送信号，一般是挂起前台进程；
发送但是还没接受的信号称为待处理信号（pending singal）；任何时候，一个类型最多只有一个待处理信号。如果同一个类型的信号收到多个，就会被丢弃。
**线程**
- 如何能使多个程序更好地并发执行，同时又尽量减少系统的开销，成为设计操作系统的重要目标。
- 将进程的两个基本属性分开，由操作系统分开处理：对于作为调度和分派的基本单位，不同时作为拥有资源的单位，可以做到“轻装上阵”； 
- 对于拥有资源的基本单位，又不对之进行频繁的切换。‘’
修改为进程作为资源分配的单位，线程作为调度的单位
线程不拥有系统的资源，但是拥有其运行时必须的数据结构（TCB，程序计数器，寄存器，栈）
当然也有自己独有的部分：程序计数器、寄存器、栈、状态
**线程的不同实现方案**
纯用户态：线程表放在用户态中，可以自己定制调度算法，阻塞会一起阻塞（某个线程去IO）；线程占有CPU，除非资源放弃，其他线程不能保证
内核态中实现：线程表放在内核中，用池化技术循环利用
**轻量级进程**
与普通进程相比，*LWP*与其它进程**共享所有（或大部分）逻辑地址空间和系统资源**，一个进程可以创建多个*LWP*，这样它们共享大部分资源；*LWP*有它自己的*[**进程标识符**](http://zh.wikipedia.org/w/index.php?title=进程标识符&action=edit&redlink=1)*，并和其他进程有着*[**父子关系**](http://zh.wikipedia.org/w/index.php?title=父进程&action=edit&redlink=1)*；*LWP*与普通进程的区别也在于它只有一个最小的执行上下文和调度程序所需的统计信息；
**用户线程与内核线程**
1）可移植性：因为ULT完全在用户态实现线程，因此也就和具体的内核没有什么关系，可移植性方面ULT略胜一筹；
2）可扩展性：ULT是由用户控制的，因此扩展也就容易；相反，KLT扩展就很不容易，基本上只能受制于具体的操作系统内核；
3）性能：由于ULT的线程是在用户态，对应的内核部分还是一个进程，因此ULT就没有办法利用多处理器的优势，而KLT就可以通过调度将线程分布在多个处理上运行，这样KLT的性能高得多；另外，一个ULT的线程阻塞，所有的线程都阻塞，而KLT一个线程阻塞不会影响其它线程。
4）编程复杂度：ULT的所有管理工作都要由用户来完成，而KLT仅仅需要调用API接口，因此ULT要比KLT复杂的多。
**Linux的进程**