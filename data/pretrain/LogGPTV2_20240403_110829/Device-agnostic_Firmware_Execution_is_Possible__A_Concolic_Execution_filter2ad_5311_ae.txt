12
Device-agnostic Firmware Execution
Anonymous Submission to MobiCom, 2020
Laelaps works on lightweight RTOS and bare-metal sys-
tems. We offer a set of peripheral-specific search heuristics
to mitigate the path explosion for peripheral emulation.
To be able to execute firmware in an emulated environ-
ment, many previous work forwards the peripheral access
requests to the real hardware [24, 27, 32, 42, 44]. However, a
real device does not always have an interface for exchanging
data with the emulator. Furthermore, this approach is not
scalable for testing large-scale firmware images because for
every firmware image a real device is needed. Instead of
relying on real devices, our approach infers proper inputs
from peripherals on-the-fly using symbolic execution. Our
approach inherits many benefits of a traditional emulator.
For example, we can store a snapshot at any time and replay
it for repeated analyses.
A very related work [21] to ours was recently proposed
by Eric Gustafson et. al. The authors proposed to “learn” the
interactions between the original hardware and the firmware
from the real hardware. As a result, analysts do not need to
program a specific back-end peripheral emulator for every
target hardware. This approach achieves similar dynamic
analysis capability with ours, however, it still needs the real
hardware in the “learning” process.
Finally, previous work has made tremendous progress in
analyzing Linux-based firmware [9, 46]. The high-level idea
is to design a generic kernel for all the devices. This ap-
proach leverages the abstraction layer offered by the Linux
kernel. For example, the WiFi interface can be easily sup-
ported by providing a standard emulated Ethernet interface,
since the POSIX API is being used. However, for microcon-
troller firmware, there is no such a unified interface between
the tasks and the kernel. Even if some MCU OSs provide hard-
ware abstraction layer (HALs), the ecosystem is severely seg-
mented. Lastly, many MCU firmware images are bare-metal
and directly work on diverse hardware. Our work does not
rely on any abstraction layers and directly interacts with the
previously-unseen hardware. Therefore, our approach can
deal with more kinds of firmware.
8 CONCLUSION & FUTURE WORK
We present Laelaps, a device-agnostic emulator for ARM
microcontroller. The high-level idea is to leverage concolic
execution to generate proper peripheral inputs to steer de-
vice emulator on the fly. Dynamic symbolic execution is a
perfect fit for this task based on our observations and experi-
mental validations. To find a right input, the key is to identify
the most promising branch. We designed a path selection al-
gorithm based on a set of generally applicable heuristics. We
have implemented this idea on top of QEMU and angr, and
have conducted extensive experiments. Of all the collected
30 firmware images from different manufacturers, we found
13
that our prototype can successfully execute 20 of them with-
out any human intervention. We also tested fuzzing testing
on top of Laelaps. The results showed that Laelaps is able
to correctly boot the system into an analyzable state. As a re-
sult, Laelaps can identify both self-injected and real-world
bugs. In the future, we plan to extend our prototype to sup-
port a border spectrum of devices including ARM Cortex-A
and MIPS devices.
A IMPLEMENATION MISCELLANEOUS
In this section, we provide supplementary information about
implementation details for interested readers.
A.1 Precise PC in QEMU
When transferring processor state from QEMU to angr, we
found that the PC register always points to the start of the
current translated block, instead of the real PC. We borrow
the code from PANDA [16] to address this problem. In par-
ticular, we injected into the intermediate language some
instructions so that the PC can be updated together with
each translated guest instruction.
A.2 Extending Interrupt in QEMU
The official QEMU supports 16 system exceptions and 64
hardware interrupts. A real device often uses more interrupts.
Therefore, we extended the supported number of interrupt
to 140 in our prototype.
A.3 Bit-banding
Bit-banding is an optional feature in many ARM-based mi-
crocontrollers [2] . It maps a complete word of memory onto
a single bit in the corresponding bit-banding region. Writ-
ing to a word sets or clears the corresponding bit in the
bit-banding region. Therefore, it enables efficient atomic ac-
cess of a bit in memory. In particular, a read-modify-write
sequence can be replaced by a single write operation. QEMU
has already perfectly supported this feature while angr has
not. We extended the memory model of angr to honor the
defined behavior when writing to a bit-band region. This aug-
mentation has been used by Laelaps to successfully emulate
STM32 devices in our experiments.
A.4 CBZ/CBNZ Instruction
A CBZ instruction causes a branch if the operand is zero,
while CBNZ does the opposite. By definition, these instruc-
tions mark the end of basic blocks because they branch to
new basic blocks. However, in the default implementation
of angr, due to optimization, they are not treated as basic
block terminators. In fact, angr uses a basic block variant
called IRSB (Intermediate Representation Super-Block) which
can have multiple exits. This results in abnormal behaviors
Anonymous Submission to MobiCom, 2020
Anon.
when Laelaps selects a branch. Fortunately, angr provides
a configuration option that enables using strict basic blocks.
Therefore, we enable this option throughout the use of angr.
A.5 Memory Alias
Some STM32 boards heavily depend on memory alias during
booting. We extended the memory model of angr to redi-
rect memory accesses when encountering memory regions
configured to be an alias to others.
B DETATILS OF COLLECTED FIRMWARE
IMAGES
We briefly describe the functionality of each firmware image.
Also, we summarize the details of execution results of these
firmware images in Table 6.
(1) It sets up the RTC hardware block to trigger an alarm
after a user specified time period. The test will set the
current date and time to a predefined value. The alarm
will be set with reference to this predefined date and
time.
(2) User should indicate a channel to provide a voltage
signal (can be controlled by user) as the ADC16’s sam-
ple input. When running the project, typing any key
into debug console would trigger the conversion. The
execution would check the conversion completed flag
in loop until the flag is asserted, which means the con-
version is completed. Then read the conversion result
value and print it to debug console.
(3) It uses the systick interrupt to realize the function of
timing delay. The example takes turns to shine the
LED.
(4) It uses notification mechanism and prints the power
mode menu through the debug console, where the user
can set the MCU to a specific power mode. The user
can also set the wakeup source by following the debug
console prompts.
(5) It shows how to use DAC module simply as the general
DAC converter.
(6) It sets up the PIT hardware block to trigger a periodic
interrupt every 1 second. When the PIT interrupt is
triggered a message a printed on the UART terminal
and an LED is toggled on the board.
(7) In the example, you can send characters to the console
back and they will be printed out onto console instantly
using lpuart.
(8) The TPM project is a demonstration program of gener-
ating a combined PWM signal by the SDK TPM driver.
(9) User should indicate an input channel to capture a
voltage signal (can be controlled by user) as the CMP’s
14
positive channel input. On the negative side, the in-
ternal 6-bit DAC is used to generate the fixed voltage
about half value of reference voltage.
(10) EWM counter is continuously refreshed until button
is pressed. Once the button is pressed, EWM counter
will expire and interrupt will be generated. After the
first pressing, another interrupt can be triggered by
pressing button again.
(11) Quick test is first implemented to test the wdog. And
then after 10 times of refreshing the watchdog in None-
window mode, a timeout reset is generated.
(12) The CMT is worked as Time mode and used to modu-
lation 11 bit numbers of data. The CMT is configured
to generate a 40000hz carrier generator signal through
a modulator gate configured with different mark/space
time period to represent bit 1 and bit 0.
(13) It sets up the FTM hardware block to trigger an inter-
rupt every 1 millisecond. When the FTM interrupt is
triggered a message a printed on the UART terminal.
(14) It sets up the LPTMR hardware block to trigger a peri-
odic interrupt after every 1 second. When the LPTMR
interrupt is triggered a message a printed on the UART
terminal and an LED is toggled on the board.
(15) The example configures one FlexCAN Message Buffer
to Rx Message Buffer and the other FlexCAN message
buffer to Tx message buffer with same ID. After that,
the example will send a CAN message from the Tx
message buffer to the Rx message buffer through inter-
nal loopback interconnect and print out the Message
payload to terminal.
(16) It uses the RNGA to generate 32-bit random numbers
and prints them to the terminal.
(17) It excuates one shot transfer from source buffer to
destination buffer using the SDK EDMA drivers.
(18) One sai instance records the audio data from input and
playbacks the audio data.
(19) It uses the KSDK software to generate checksums for
an ASCII string.
(20) The SYSMPU example defines protected/unprotected
memory region for the core access and tested whether
memory protection interrupt events can be delivered
if memory violations are detected.
(21) The ENET example tests FreeRTOS+TCP network stack.
(22) This example introduces simple logging mechanism
(23) It prints the "Hello World" string to the terminal using
based on message passing.
the SDK UART drivers.
(24) The RTC demo application demonstrates the impor-
tant features of the RTC Module by using the RTC
Peripheral Driver. It tested the calendar, alarm and
seconds interrupt.
Device-agnostic Firmware Execution
Anonymous Submission to MobiCom, 2020
(25) The bubble application demonstrates basic usage of the
on-board accelerometer to implement a bubble level.
It uses the FTM/TPM to modulate the duty cycle of
green and blue colors of onboard RGB LED to gradually
increase intensity of the colors as the board deviates
from a level state.
(26) It is a simple demonstration program that uses the SDK
UART driver in combination with FreeRTOS.
(27) It outputs the printf message on the Hyperterminal
using USARTx.
in FreeRTOS.
(28) It coordinates two tasks with the help of semaphore
(29) It flashes the board LED using a thread, by pressing
the button located on the board and output a string on
the serial port SD2 (USART2).
(30) It is the same image used in paper [33]. It reads XML
files from UART and uses expat to parse them.
REFERENCES
[1] Amazon Web Services. 2018. The FreeRTO Kernel. https://www.
freertos.org/.
[2] Arm Holdings. 2015. ARM Cortex-M3 Processor Technical Reference
Manual. https://developer.arm.com/docs/100165/0201.
[3] Clark Barrett and Cesare Tinelli. 2018. Satisfiability Modulo Theories.
Springer International Publishing.
[4] Fabrice Bellard. 2005. QEMU, a Fast and Portable Dynamic Transla-
tor. In Proceedings of the 2005 USENIX Annual Technical Conference
(ATC’05).
[5] Ella Bounimova, Patrice Godefroid, and David Molnar. 2013. Billions
and Billions of Constraints: Whitebox Fuzz Testing in Production. In
ICSE’13.
[6] Derek Bruening, Chris Adeniyi-Jones, Edmund Grimley-Evans, and
Kevin Zhou. 2017. Building Dynamic Tools with DynamoRIO on x86
and ARMv8. 2017 International Symposium on Code Generation and
Optimization Tutorial.
[7] Cristian Cadar, Daniel Dunbar, and Dawson Engler. 2008. KLEE: Unas-
sisted and Automatic Generation of High-coverage Tests for Complex
Systems Programs. In Proceedings of the 8th USENIX Conference on
Operating Systems Design and Implementation (OSDI’08).
[8] Cristian Cadar, Vijay Ganesh, Peter M. Pawlowski, David L. Dill, and
Dawson R. Engler. 2006. EXE: Automatically Generating Inputs of
Death. In Proceedings of the 2006 ACM Conference on Computer and
Communications Security (CCS’06).
[9] Daming D. Chen, Manuel Egele, Maverick Woo, and David Brumley.
2016. Towards Automated Dynamic Analysis for Linux-based Em-
bedded Firmware. In Proceedings of the 2016 Network and Distributed
System Security Symposium (NDSS’16).
[10] Vitaly Chipounov and George Candea. 2010. Reverse Engineering of
Binary Device Drivers with RevNIC. In Proceedings of the 5th European
Conference on Computer Systems (EuroSys’10).
[11] Vitaly Chipounov, Volodymyr Kuznetsov, and George Candea. 2011.
S2E: A Platform for In-vivo Multi-path Analysis of Software Systems.
SIGPLAN Not. 47, 4 (March 2011), 265–278. https://doi.org/10.1145/
2248487.1950396
[12] Vitaly Chipounov, Volodymyr Kuznetsov, and George Candea. 2011.
S2E: A Platform for In-Vivo Multi-path Analysis of Software Systems.
In Proceedings of the 16th International Conference on Architectural Sup-
port for Programming Languages and Operating Systems (ASPLOS’11).
[13] Clark, James. 2018. Expat XML parser. https://libexpat.github.io/.
[14] Nassim Corteggiani, Giovanni Camurati, and Aurélien Francillon. 2018.
Inception: System-Wide Security Testing of Real-World Embedded Sys-
tems Software. In Proceedings of the 27th USENIX Security Symposium
(USENIX Security’18).
[15] Drew Davidson, Benjamin Moench, Thomas Ristenpart, and Somesh
Jha. 2013. FIE on Firmware: Finding Vulnerabilities in Embedded Sys-
tems Using Symbolic Execution. In Presented as part of the 22nd USENIX
Security Symposium (USENIX Security 13). USENIX, Washington,
D.C., 463–478. https://www.usenix.org/conference/usenixsecurity13/
technical-sessions/paper/davidson
[16] Brendan Dolan-Gavitt, Josh Hodosh, Patrick Hulin, Tim Leek, and
Ryan Whelan. 2015. Repeatable Reverse Engineering with PANDA.
In Proceedings of the 5th Program Protection and Reverse Engineering
Workshop (PPREW-5).
[17] howpublished=https://www.fcc.gov/oet/ea/fccid Federal Communica-
tions Commission. [n.d.]. FCC ID Search.
[18] Vijay Ganesh and David L. Dill. 2007. A Decision Procedure for Bit-
vectors and Arrays. In Proceedings of the 2007 International Conference
in Computer Aided Verification (CAV’07).
[19] Patrice Godefroid, Nils Klarlund, and Koushik Sen. 2005. DART: Di-
rected Automated Random Testing. In PLDI’05.
[20] Patrice Godefroid, Michael Y. Levin, and David Molnar. 2008. Auto-
mated Whitebox Fuzz Testing. In NDSS’08.
[21] Eric Gustafson, Marius Muench, Chad Spensky, Nilo Redini, Aravind
Machiry, Yanick Fratantonio, Davide Balzarotti, Aurélien Francillon,
Yung Ryn Choe, Christophe Kruegel, and Giovanni Vigna. 2019. To-
ward the Analysis of Embedded Firmware through Automated Re-
hosting. In Proceedings of the 22nd International Symposium on Research
in Attacks, Intrusions and Defenses (RAID’19).
[22] Grant Hernandez, Farhaan Fowze, Dave (Jing) Tian, Tuba Yavuz, and
Kevin R.B. Butler. 2017. FirmUSB: Vetting USB Device Firmware Using
Domain Informed Symbolic Execution. In Proceedings of the 2017 ACM
SIGSAC Conference on Computer and Communications Security (Dallas,
Texas, USA) (CCS ’17). ACM, New York, NY, USA, 2245–2262. https:
//doi.org/10.1145/3133956.3134050
[23] Andreas Ibing and Alexandra Mai. 2015. A Fixed-Point Algorithm for
Automated Static Detection of Infinite Loops. In Proceedings of the 16th
IEEE International Symposium on High Assurance Systems Engineering
(HASE’15).
[24] Markus Kammerstetter, Christian Platzer, and Wolfgang Kastner. 2014.
PROSPECT Peripheral Proxying Supported Embedded Code Testing.
In Proceedings of the 9th ACM Symposium on Information, Computer
and Communications Security (AsiaCCS’14). ACM.
[25] Ori Karliner. 2018. FreeRTOS TCP/IP Stack Vulnerabilities – The De-
tails. https://blog.zimperium.com/freertos-tcpip-stack-vulnerabilities-
details/.
[26] James C. King. 1976. Symbolic Execution and Program Testing. Com-
mun. ACM 19, 7 (July 1976), 385–394.
[27] Karl Koscher, Tadayoshi Kohno, and David Molnar. 2015. SURRO-
GATES: Enabling Near-Real-Time Dynamic Analyses of Embedded
Systems. In 9th USENIX Workshop on Offensive Technologies (WOOT’15).
USENIX Association, Washington, D.C.
https://www.usenix.org/
conference/woot15/workshop-program/presentation/koscher
[28] Volodymyr Kuznetsov, Vitaly Chipounov, and George Candea. 2010.
Testing Closed-source Binary Device Drivers with DDT. In Proceedings
of the 2010 USENIX Annual Technical Conference (ATC’10).
[29] You Li, Zhendong Su, Linzhang Wang, and Xuandong Li. 2013. Steer-
ing Symbolic Execution to Less Traveled Paths. In Proceedings of the
2013 ACM SIGPLAN International Conference on Object Oriented Pro-
gramming Systems Languages & Applications (OOPSLA’13).
15
Anonymous Submission to MobiCom, 2020
Anon.
Table 6: Details of Firmware Samples