long SetArrayLong(long id, long idx, long value)
 。将整数value
 存储到按id
 引用的数组中idx
 指定的位置。如果操作成功，则返回 1，否则返回 0。如果数组 id
 无效，这个操作将会失败。
long SetArrayString(long id, long idx, string str)
 。将字符串 value
 存储到按id
 引用的数组中 idx
 指定的位置。如果操作成功，则返回 1，否则返回 0。如果数组 id
 无效，这个操作将会失败。
string or long GetArrayElement(long tag, long id, long idx)
 。虽然一些特殊的函数可以根据数据类型将数据存储到数组中，但是，只有一个函数可以从数组中提取数据。这个函数可以从指定数组（id
 ）的指定索引（idx
 ）位置提取一个整数或字符串值。提取的是整数还是字符串，由 tag
 参数的值决定，这个值必须是常量 AR_LONG
 （提取整数）或AR_STR
 （提取字符串）。
long DelArrayElement(long tag, long id, long idx)
 。从指定数组中删除指定数组位置的内容。tag
 的值决定是删除指定索引位置的整数值还是字符串值。
void DeleteArray(long id)
 。删除按 id
 引用的数组及其所有相关内容。创建一个数组后，即使一个脚本终止，它也继续存在，直到调用DeleteArray
 从创建它的数据库中删除这个数组。
long RenameArray(long id, string newname)
 。将按id
 引用的数组重命名为 newname
 。如果操作成功，将返回 1，否则返回 0。
全局数组的作用包括模拟全局变量、模拟复杂的数据类型、为所有脚本调用提供永久存储。在数组开始执行时创建一个全局数组，然后将全局值存储到这个数组中，即可模拟这个数组的全局变量。要共享这些全局值，可以将数组句柄传递给要求访问这些值的函数，或者要求请求访问这些值的函数对相关数组进行名称查询。
IDC 全局数组中存储的值会在执行脚本的数据库中永久存在。你可以通过检查 CreateArray
 函数的返回值，测试一个数组是否存在。如果一个数组中存储的值仅适用于某个特定的脚本，那么，在这个脚本终止前，应该删除该数组。删除数组可以确保全局值不会由同一个脚本的上一次执行传递到随后的执行中。
15.3 关联IDC 脚本与热键
有时开发一个脚本后，你会惊奇地发现，你必须进行一两次键击才能访问这个脚本。这时，你可能希望使用一个热键组合，以迅速激活脚本。幸好 IDA 提供了一种分配热键的简单方法。每次启动IDA ，它都会执行/idc/ida.idc中的脚本。这个脚本的默认版本包含一个空的main函数，因此，它不执行任何操作。为了将热键与脚本关联起来，你需要在 ida.idc 文件中添加两行代码。在第一行代码中，必须添加一个 include
 指令，将脚本文件包含在 ida.idc 文件中。在第二行代码中，必须在 main
 函数中添加一个对 AddHotkey
 函数的调用，将特定的热键与 IDC脚本关联起来。修改后的 ida.idc 文件如下所示。
#include   
#include   
static main() {  
   AddHotkey("z", "MyAmazingFunc");  //Now 'z' invokes MyAmazingFunc  
}
如果你尝试与脚本关联的热键已经分配给另一项 IDA 操作（菜单热键或插件激活热键），这时，AddHotkey
 函数将悄无声息地失败，除了在你按下热键组合后，函数不会运行外，你无法通过其他方式检测到这种失败。
这里你需要记住两个要点：第一，IDC 脚本的标准存储目录为/idc；第二，不能将脚本函数命名为 main
 。如果希望 IDA 能够轻易找到脚本，可以将它复制到/idc目录中。如果要将脚本文件存储在其他位置，你需要在 include
 语句中指定脚本的完整路径。在测试脚本时，使用main
 函数以独立程序的方式运行脚本会有好处。但是，一旦你准备将脚本与热键关联起来，就不能使用 main
 这个名称，因为它会与 ida.idc 中的main
 函数相互冲突。必须重命名 main
 函数，并在调用 AddHotkey
 时使用新的名称。
15.4 有用的IDC 函数
现在，你已经拥有了编写格式完整的 IDC 脚本所需的全部信息。但是，你仍然无法与 IDA进行任何有益的交互。IDC 提供了大量内置函数用于以各种方式访问数据库。IDA 帮助系统的Index of IDC functions （IDC 函数目录）主题对所有这些函数进行了一定程度的说明。多数情况下，这些说明不过是从 IDC 的主要包含文件 idc.idc 中复制的几行相关内容。在学习 IDC 的过程中，弄懂这些简短的说明是一个令人沮丧的经历。“在IDC 中，我该如何完成 x？”这个问题通常没有明确的答案。要想完成某个任务，最常用的方法是浏览 IDC 的函数列表，根据其名称寻找一个似乎能够满足需求的函数。函数是根据用途来命名的，这一推断并非总是成立。例如，许多时候，从数据库中提取信息的函数叫做 GetXXX
 ；但其他情况下，函数名并不使用 Get
 前缀。更改数据库的函数可能直接叫做 SetXXX
 、MakeXXX
 或其他别的名称。总体来说，如果你想要使用IDC函数，请经常浏览函数列表并仔细阅读函数说明。如果你完全不知所措，请访问 Hex-Rays 的支持论坛1
 。
1. 该支持论坛当前的地址为http://www.hex-rays.com/forum
 。
在本节的剩余部分，我们将介绍一些有用（根据我们的经验）的 IDC 函数，并根据功能对它们分类。即使你只计划使用Python 编写脚本，了解下面这些函数仍会对你有所帮助，因为IDAPython 为这里的每一个函数提供了对应的 Python 函数。由于 IDA 帮助系统已经讨论了这些函数，所以我们并不打算介绍每一个 IDC 函数。
15.4.1 读取和修改数据的函数
下面的函数可用于访问数据库中的各个字节、字和双字。
long Byte(long addr)
 ，从虚拟地址addr
 处读取一个字节值。
long Word(long addr)
 ，从虚拟地址addr
 处读取一个字（2 字节）值。
long Dword(long addr)
 ，从虚拟地址 addr
 处读取一个双字（4 字节）值。
void PatchByte(long addr, long val)
 ，设置虚拟地址 addr
 处的一个字节值。
void PatchWord(long addr, long val)
 ，设置虚拟地址 addr
 处的一个字值。
void PatchDword(long addr, long val)
 ，设置虚拟地址 addr
 处的一个双字值。
bool isLoaded(long addr)
 ，如果addr
 包含有效数据，则返回 1，否则返回 0。
在读取和写入数据库时，这里的每一个函数都考虑到了当前处理器模块的字节顺序（小端或大端）。PatchXXX
 函数还根据被调用的函数，通过仅使用适当数量的低位字节，将所提供的值调整到适当大小。例如，调用 PatchByte(0x401010, 0x1234)
 将使用字节值0x34（0x1234
 的低位字节）修改0x401010
 位置。如果在用Byte
 、Word
 和Dword
 读取数据库时提供了一个无效的地址，它们将分别返回值 0xFF
 、0xFFFF
 和0xFFFFFFFF
 。因为你没有办法将这些错误值与存储在数据库中的合法值区分开来，因此，在尝试从数据库中的某个地址读取数据之前，你可能希望调用isLoaded
 函数，以确定这个地址是否包含任何数据。
由于IDA 在刷新反汇编窗口时“行为古怪”，你可能会发现，修补操作的结果并不会立即在窗口中显示出来。这时，你可以拖动滚动带离开被修补的位置，然后返回这个位置，即可迫使窗口正确进行更新。
15.4.2 用户交互函数
为了进行用户交互，需要熟悉 IDC 的输入/输出函数。下面详细介绍 IDC 的一些重要的接口函数。
void Message(string format, ...)
 ，在输出窗口打印一条格式化消息。这个函数类似于 C 语言的printf
 函数，并接受 printf
 风格的格式化字符串。
void print(...)
 ，在输出窗口中打印每个参数的字符串表示形式。
void Warning(string format, ...)
 ，在对话框中显示一条格式化消息。
string AskStr(string default, string prompt)
 ，显示一个输入框，要求用户输入一个字符串值。如果操作成功，则返回用户的字符串；如果对话框被取消，则返回 0。
string AskFile(long doSave, string mask, string prompt)
 ，显示一个文件选择对话框，以简化选择文件的任务。你可以创建新文件保存数据（doSave=1
 ），或选择现有的文件读取数据（doSave=0
 ）。你可以根据mask
 （如*.*或*.idc
 ）过滤显示的文件列表。如果操作成功，则返回选定文件的名称；如果对话框被取消，则返回 0。
long AskYN(long default, string prompt)
 ，用一个答案为“是”或“否”的问题提示用户，突出一个默认的答案（1 为是，0 为否，-1 为取消）。返回值是一个表示选定答案的整数。
long ScreenEA()
 ，返回当前光标所在位置的虚拟地址。
bool Jump(long addr)
 ，跳转到反汇编窗口的指定地址。
因为IDC 没有任何调试工具，你可能需要将 Message
 函数作为你的主要调试工具。其他几个AskXXX
 函数用于处理更加专用的输入，如整数输入。请参考帮助系统文档了解可用的 AskXXX
 函数的完整列表。如果希望创建一个根据光标位置调整其行为的脚本，这时，ScreenEA
 函数就非常有用，因为你可以通过它确定光标的当前位置。同样，如果你的脚本需要将用户的注意力转移到反汇编代码清单中的某个位置，也需要用到 Jump
 函数。
15.4.3 字符串操纵函数
虽然简单的字符串赋值和拼接操作可以通过 IDC 中的基本运算符实现，但是，更加复杂的操作必须使用字符串操纵函数实现，这些函数如下所示。
string form(string format, ...)//preIDA5.6
 ，返回一个新字符串，该字符串根据所提供的格式化字符串和值进行格式化。这个函数基本上等同于C 语言的 sprint
 函数。
string sprintf(string format,...)//IDA5.6+
 ，在 IDA5.6中，sprint
 用于替代 form
 （参见上面）。
long atol(string val)