Geoﬀrey Washburn, Stephanie Weirich, and the anonymous referees for their helpful
suggestions and comments on earlier drafts of this work. This research was sup-
ported in part by NSF grant CCR-0311204, Dynamic Security Policies and NSF
grant CNS-0346939 CAREER: Language-based Distributed System Security.
REFERENCES
Abadi, M. 1998. On SDSI’s linked local name spaces. Journal of Computer Security 6, 1-2, 3–21.
Abadi, M., Banerjee, A., Heintze, N., and Riecke, J. 1999. A core calculus of dependency. In
Proc. 26th ACM Symp. on Principles of Programming Languages (POPL). San Antonio, TX,
147–160.
Abadi, M., Burrows, M., Lampson, B. W., and Plotkin, G. D. 1993. A calculus for access
control in distributed systems. Transactions on Programming Languages and Systems 15, 4
(Sept.), 706–734.
Agat, J. 2000. Transforming out timing leaks.
In Proc. 27th ACM Symp. on Principles of
Programming Languages (POPL). Boston, MA, 40–53.
Aspinall, D. 1994. Subtyping with Singleton Types. In Computer Science Logic. 1–15.
Banerjee, A. and Naumann, D. A. 2002. Secure information ﬂow and pointer conﬁnement in
a java-like language. In Proc. of the 15th IEEE Computer Security Foundations Workshop.
253–267.
Banerjee, A. and Naumann, D. A. 2003. Using access control for secure information ﬂow in
a Java-like language. In Proc. of the 16th IEEE Computer Security Foundations Workshop.
IEEE Computer Society Press, 155–169.
Chothia, T., Duggan, D., and Vitek, J. 2003. Type-Based Distributed Access Control. In Proc.
of the IEEE Computer Security Foundations Workshop. 170.
ACM Transactions on Programming Languages and Systems, Vol. TBD, No. TDB, Month Year.
·
42
Stephen Tse and Steve Zdancewic
Crary, K., Kliger, A., and Pfenning, F. 2004. A monadic analysis of information ﬂow security
with mutable sate. Journal of Functional Programming 15, 2 (Mar.), 249 – 291.
Crary, K., Walker, D., and Morrisett, G. 1999. Typed memory management in a calculus
of capabilities. In Proc. 26th ACM Symp. on Principles of Programming Languages (POPL).
San Antonio, Texas, 262–275.
Crary, K., Weirich, S., and Morrisett, G. 2002. Intensional polymorphism in type erasure
semantics. Journal of Functional Programming 12, 6 (Nov.), 567–600.
Fournet, C. and Gordon, A. 2002. Stack inspection: Theory and variants. In Proc. 29th ACM
Symp. on Principles of Programming Languages (POPL). 307–318.
Gasser, M. and McDermott, E. 1990. An architecture for practical delegation in a distributed
system. In Proc. IEEE Symposium on Security and Privacy. IEEE Computer Society Press,
20–30.
Goguen, J. A. and Meseguer, J. 1982. Security policies and security models. In Proc. IEEE
Symposium on Security and Privacy. IEEE Computer Society Press, 11–20.
Gunter, C. A. and Jim, T. 2000. Generalized certiﬁcate revocation. In Proc. 27th ACM Symp. on
Principles of Programming Languages (POPL). ACM Press, Boston, Massachusetts, 316–329.
Heintze, N. and Riecke, J. G. 1998. The SLam calculus: Programming with secrecy and integrity.
In Proc. 25th ACM Symp. on Principles of Programming Languages (POPL). San Diego,
California, 365–377.
Howell, J. and Kotz, D. 2000. End-to-end authorization. In Proc. USENIX Symp. on Operating
Systems Design and Implementation (OSDI). 151–164.
Jim, T. 2001. SD3: a trust management system with certiﬁcate revocation. In IEEE Symposium
on Security and Privacy. 106–115.
Jouvelot, P. and Gifford, D. K. 1991. Algebraic reconstruction of types and eﬀects. In ACM
Symposium on Principles of Programming Languages. 303–310.
Li, P., Mao, Y., and Zdancewic, S. 2003. Information integrity policies. In Proceedings of the
Workshop on Formal Aspects in Security & Trust (FAST). 53–70.
Mitchell, J. C. 1996. Foundations for Programming Languages. Foundations of Computing
Series. The MIT Press.
Myers, A. C., Chong, S., Nystrom, N., Zheng, L., and Zdancewic, S. 1999. Jif: Java infor-
mation ﬂow.
Myers, A. C. and Liskov, B. 1998. Complete, safe information ﬂow with decentralized labels.
In Proc. IEEE Symposium on Security and Privacy. Oakland, CA, USA, 186–197.
Myers, A. C. and Liskov, B. 2000. Protecting privacy using the decentralized label model. ACM
Transactions on Software Engineering and Methodology 9, 4, 410–442.
Myers, A. C., Sabelfeld, A., , and Zdancewic, S. 2004. Enforcing Robust Declassiﬁcation. In
Proc. of the IEEE Computer Security Foundations Workshop. 172–186.
Myers, A. C., Sabelfeld, A., and Zdancewic, S. 2006. Enforcing robust declassiﬁcation and
qualiﬁed robustness. 14, 2, 157–196.
Pierce, B. C. 2002. Types and Programming Languages. MIT Press.
Pitts, A. 1998. Existential Types: Logical Relations and Operational Equivalence. In Interna-
tional Colloquium on Automata, Languages and Programming. 309 – 326.
Information ﬂow inference for free.
Pottier, F. and Conchon, S. 2000.
In Proc. 5th ACM
SIGPLAN International Conference on Functional Programming (ICFP). 46–57.
Pottier, F. and Simonet, V. 2002.
Information ﬂow inference for ML.
In Proc. 29th ACM
Symp. on Principles of Programming Languages (POPL). Portland, Oregon, 319 – 330.
Pottier, F., Skalka, C., and Smith, S. F. 2001. A Systematic Approach to Static Access
Control. In European Symposium on Programming. 344 – 382.
Sabelfeld, A. and Myers, A. C. 2003. Language-based information-ﬂow security. IEEE Journal
on Selected Areas in Communications 21, 1 (Jan.), 5–19.
Sabelfeld, A. and Sands, D. 2001. A PER model of secure information ﬂow in sequential
programs. Higher-Order and Symbolic Computation 14, 1 (Mar.), 59–91.
ACM Transactions on Programming Languages and Systems, Vol. TBD, No. TDB, Month Year.
Run-time Principals in Information-ﬂow Type Systems
·
43
Simonet, V. 2003. Flow caml in a nutshell. In Proceedings of the ﬁrst APPSEM-II workshop,
G. Hutton, Ed. 152–165.
Simonet, V. and Pottier, F. 2004. Constraint-Based Type Inference with Guarded Algebraic
Data Types. Submitted to toplas.
Tse, S. and Zdancewic, S. 2004. Run-time Principals in Information-ﬂow Type Systems. In
IEEE Symposium on Security and Privacy.
Tse, S. and Zdancewic, S. 2005. Designing a Security-typed Language with Certiﬁcate-based
Declassiﬁcation. In European Symposium on Programming.
Volpano, D., Smith, G., and Irvine, C. 1996. A sound type system for secure ﬂow analysis.
Journal of Computer Security 4, 3, 167–187.
Wadler, P. 1989. Theorems for Free! In ACM Functional Programming Languages and Computer
Architecture. 347–359.
Wallach, D. S., Appel, A. W., and Felten, E. W. 2000. The security architecture formerly
known as stack inspection: A security mechanism for language-based systems. ACM Transac-
tions on Software Engineering and Methodology 9, 4 (Oct.), 341 – 378.
Wallach, D. S. and Felten, E. W. 1998. Understanding Java stack inspection. In Proc. IEEE
Symposium on Security and Privacy. Oakland, California, USA, 52–63.
Zdancewic, S. 2003. A type system for robust declassiﬁcation. In Proceedings of the Nineteenth
Conference on the Mathematical Foundations of Programming Semantics. Electronic Notes in
Theoretical Computer Science.
Zdancewic, S. and Myers, A. C. 2001. Secure information ﬂow and CPS. In Proc. of the 10th
European Symposium on Programming. Lecture Notes in Computer Science, vol. 2028. 46–61.
Zdancewic, S. and Myers, A. C. 2002. Secure information ﬂow via linear continuations. Higher
Order and Symbolic Computation 15, 2/3, 209–234.
Zheng, L. and Myers, A. C. 2004. Dynamic Security Labels and Noninterference. In Formal
Aspects in Security and Trust.
A. FULL SYNTAX OF λRP
p
::=
α
X
::= · | p, s
::= · | p : s
::= · | c; d
::= {d!s}
s
c
d
l
∆ ::= · | ∆, p (cid:22) p
A ::= · | A, X (cid:22) X
Γ ::= · | Γ, x : t
::= · | π, p . i
π
::= · | δ, α 7→ X
δ
::= · | γ, x 7→ v
γ
Principals
variable
name
Principal sets
Policies
Policy sets
Labels
Principal environments
Acts-for hierarchies
Term environments
Authority
Principal substitutions
Term substitutions
ACM Transactions on Programming Languages and Systems, Vol. TBD, No. TDB, Month Year.
·
44
Stephen Tse and Steve Zdancewic
t
u
::= ul
::=
1
t + t
[π] t → t
∀α (cid:22) p. t
∃α (cid:22) p. t
Pp
C
v
::=
e
::=
*
inl v
inr v
λx: t. e
Λα (cid:22) p. e
pack (p (cid:22) q, e)
X
let (X1 (cid:22) X2) in v
X{i}
v
x
inl e
inr e
case e v v
e e
e [p]
open (α, x) = e in e
if (e (cid:22) e) e e
let (e (cid:22) e) in e
if (e ⇒ e . i) e e
declassify e t
endorse e p
acquire e . i
i
::=
declassify
endorse
delegatep(cid:22)p
Security types
Plain types
unit
sum
function
universal
existential
principal
capability
Values
unit
left injection
right injection
function
generalization
packing
principal constant
let delegate
capability
Terms
value
variable
left injection
right injection
sum case
application
instantiation
opening
if delegate
let delegate
if certify
declassify
endorse
acquire
Privileges
declassiﬁcation
endorsement
delegation
ACM Transactions on Programming Languages and Systems, Vol. TBD, No. TDB, Month Year.