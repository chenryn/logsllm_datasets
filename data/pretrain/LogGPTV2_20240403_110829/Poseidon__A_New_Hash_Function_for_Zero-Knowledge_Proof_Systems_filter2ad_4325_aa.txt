title:Poseidon: A New Hash Function for Zero-Knowledge Proof Systems
author:Lorenzo Grassi and
Dmitry Khovratovich and
Christian Rechberger and
Arnab Roy and
Markus Schofnegger
Poseidon: A New Hash Function for 
Zero-Knowledge Proof Systems
Lorenzo Grassi, Radboud University Nijmegen; Dmitry Khovratovich, 
Ethereum Foundation and Dusk Network; Christian Rechberger, IAIK, 
Graz University of Technology; Arnab Roy, University of Klagenfurt; 
Markus Schofnegger, IAIK, Graz University of Technology
https://www.usenix.org/conference/usenixsecurity21/presentation/grassi
This paper is included in the Proceedings of the 30th USENIX Security Symposium.August 11–13, 2021978-1-939133-24-3Open access to the Proceedings of the 30th USENIX Security Symposium is sponsored by USENIX.POSEIDON: A New Hash Function for Zero-Knowledge Proof Systems
Lorenzo Grassi1, Dmitry Khovratovich2, Christian Rechberger3, Arnab Roy4, and Markus Schofnegger3
1Radboud University Nijmegen
2Ethereum Foundation and Dusk Network
3IAIK, Graz University of Technology
4University of Klagenfurt
PI:EMAIL, PI:EMAIL, ﬁPI:EMAIL, PI:EMAIL
Abstract
The area of practical computational integrity proof systems,
like SNARKs, STARKs, Bulletproofs, is seeing a very dy-
namic development with several constructions having ap-
peared recently with improved properties and relaxed setup
requirements. Many use cases of such systems involve, of-
ten as their most expensive part, proving the knowledge of a
preimage under a certain cryptographic hash function, which
is expressed as a circuit over a large prime ﬁeld. A notable
example is a zero-knowledge proof of coin ownership in the
Zcash cryptocurrency, where the inadequacy of the SHA-256
hash function for such a circuit caused a huge computational
penalty.
In this paper, we present a modular framework and concrete
instances of cryptographic hash functions which work natively
with GF(p) objects. Our hash function POSEIDON uses up to
8x fewer constraints per message bit than Pedersen Hash.
Our construction is not only expressed compactly as a cir-
cuit, but can also be tailored for various proof systems using
specially crafted polynomials, thus bringing another boost in
performance. We demonstrate this by implementing a 1-out-
of-a-billion membership proof with Merkle trees in less than
a second by using Bulletproofs.
5 Cryptanalysis Summary of POSEIDON
5.1 Deﬁnitions . .
. . . . .
5.2 Security Claims . . . .
5.3 Summary of Attacks
5.4 Security Margin . . . .
5.5 Attack details .
. . . . . . . .
. . . . . . . .
.
.
. . . . . . . . . .
.
. . . . . . . . . . . . .
. . . . . .
. . . . . .
. . . . . . . .
.
.
.
.
.
.
.
Statistical Attacks
5.5.1
.
5.5.2 Algebraic Attacks . .
.
. . .
6.1 State of the Art
6.2 SNARKs with POSEIDONπ . . . .
6 POSEIDON in Zero-Knowledge Proof Systems
.
.
.
.
.
.
. . . . . . . . .
. . .
. . . . . . . . . .
. . . . . . . . . .
. . . . . .
. . . . . . . . . .
6.3 Comparison with Other Hash Algorithms
6.4 STARKs with POSEIDONπ . . . .
. . .
6.2.1 Groth16 . . .
6.2.2 Bulletproofs
6.2.3
PLONK . .
6.2.4 RedShift
. . . . .
. .
.
7 Acknowledgements
1
Introduction
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
8
.
8
.
8
.
9
.
9
.
9
.
9
. 10
11
. 11
. 12
. 12
. 13
. 13
. 14
. 14
. 14
15
Contents
1
Introduction
2 The POSEIDON Hash Function
2.1 Sponge Construction for POSEIDONπ
. . .
2.2 The HADES Design Strategy for Hashing . .
2.3 The Permutation Family POSEIDONπ .
. . .
.
.
3 Applications
4 Concrete Instantiations of POSEIDONπ
.
4.1 Main Instances
.
4.2 Domain Separation for POSEIDON .
.
.
.
.
.
.
.
.
.
.
.
. . . .
. .
. .
The recent advances in computational integrity proof systems
made a number of computational tasks veriﬁable in short time
and/or in zero knowledge. Several protocols appeared that
require one party to prove the knowledge of a seed-derived
secret, of an element being part of a large set, or their combina-
tion. Whereas accumulator-based solutions [20, 21] and alge-
braic Schnorr proofs exist in the area, they are quite involving
and thus error-prone, require a trusted setup, are limited in
statement language, and are often slow. An alternative is to
express secret derivation using cryptographic hash functions,
and to prove set membership by presenting an opening in a
properly chosen Merkle tree, also built on a cryptographic
hash function. Such hash-based protocols require a compu-
tational integrity proof system, which can be applied to an
arbitrary arithmetic circuit. However, for the protocol to be
1
4
4
5
5
7
7
7
8
USENIX Association
30th USENIX Security Symposium    519
efﬁcient, proofs must be generated and veriﬁed in reasonable
time, which in turn requires the hash function to be cheap in
a certain metric depending on the proof system.
40.
In the middle of 2020, the most popular proof systems are ZK-
SNARKs (Pinocchio [49], Groth16 [35], PLONK [27], Mar-
lin [23] to name a few), Bulletproofs [19], ZK-STARKs [9],
and MPC-in-the-head systems [7, 22, 29]. The former two
groups have already been applied to a number of real-world
protocols, whereas the latter ones are the most promising from
the perspective of post-quantum security. These systems use
two quite different circuit descriptions so that the proof size
and generation time are computed differently:
• The R1CS format (rank-1 quadratic constraints) de-
scribes the circuit as a set of special quadratic polyno-
mials of the form L1(X)· L2(X) = L3(X), where X is
the tuple of internal and input variables, Li are afﬁne
forms and · is the ﬁeld multiplication, and (possibly in
an afﬁne-equivalent form) is used in almost all SNARKs
and Bulletproofs. The circuit multiplication and addi-
tion gates are deﬁned over a prime ﬁeld GF(p). The
proof generation complexity is directly proportional to
the number T of constraints, which often corresponds
to the number of multiplication gates. The prime ﬁeld
GF(p) is the scalar ﬁeld of an elliptic curve, where for
ZK-SNARKs the curve should be pairing-friendly and
for Bulletproofs it should just be a secure curve.
• The AET metric is used in ZK-STARKs and (to some
extent) in the PLONK proof system. The computation
is expressed as a set of internal program states related
to each other by polynomial equations of degree d. The
state consists of w ﬁeld elements and undergoes T trans-
formations. The proof generation is roughly proportional
to the product w· d · T . The number and sparsity of poly-
nomial constraints do not play a major role.
Our goal was to design a family of hash functions that are
optimal in the R1CS (as the most widespread) and good in
the AET metric, while also supporting different ﬁnite ﬁeld
sizes. It turned out that the substitution-permutation network
(SPN) design, well-known in symmetric cryptography, al-
lows for a generic hash function framework where the only
security-critical parameter that has to be changed for each
instance is the number of rounds, and we provide an efﬁcient
and transparent strategy for its choice. The S-box is chosen
as the power map x (cid:55)→ xd, where d ≥ 3 is usually chosen as
the smallest integer that guarantees invertibility and provides
non-linearity. In particular, the cube function x3 is almost uni-
versally chosen, apart from cases of ﬁelds where this function
is not a bijection. Instead, we suggest other S-boxes such as
x5 or 1/x for these cases. Thanks to a succinct representation
of the functions and a low S-box degree, we are able to opti-
mize the circuit signiﬁcantly for PLONK and RedShift proof
systems, with performance improvements by a factor of up to
Our Contributions. We design and analyze a family of
hash functions over GF(p) named POSEIDON. The internal
permutation is called POSEIDONπ and is based on the HADES
design strategy [31], which is essentially a strategy based on
substitution-permutation networks with t cells, but including
the use of so-called partial rounds, which use non-linear func-
tions only for part of the state. In our speciﬁc construction,
only one S-box is used in these partial rounds, while full non-
linear layers (i.e., t S-boxes) are used in all other rounds. This
is done to reduce the R1CS or AET cost.
We aim to support security levels of 80, 128, and 256 bits,
where the security is the same for collision and preimage re-
sistance. For each pair (basic ﬁeld, security level) we suggest
a concrete instance of POSEIDON. In our hash function, a few
S-box elements are reserved for the capacity (roughly double
the security level in bits), and the rest for the rate. The permu-
tation width is determined by the application: It is set close to
1280 bits for long-message hashing, whereas for Merkle trees
we support various widths to enable 2:1, 4:1, and other arities
and thus higher ZK performance.
We provide an extensive cryptanalysis of POSEIDON with an
accent on algebraic methods as these prove to be the most
effective. We explore different variants of interpolation, Gröb-
ner basis, and higher-order differential attacks. As our per-
mutations are quite wide, we do not aim for them behaving
like randomly chosen permutations. Instead, for a security
level of M bits we require that no attack could exhibit a non-
random (but relevant for collision/preimage search) property
of a permutation faster than in 2M queries. We then calculate
the maximum number of rounds for each ﬁeld, security level,
and ﬁxed permutation width that can be attacked. Then we
select the number of rounds for concrete instances together
with a security margin.
We have evaluated the number of constraints in POSEIDON
instances for the R1CS metric and the AET metric. Our pri-
mary proposals POSEIDON-80/128/256 are listed in Table 1
(BLS being BLS12-3811, BN being BN254 [52], Ed being
the Ristretto group2) and are compared to similar-purpose
designs. Finally, we refer to [30, Appendix A] for a complete
overview of our auxiliary ﬁles, including reference implemen-
tations and scripts to create POSEIDONπ instances.
We also have third-party benchmarks of POSEIDON for reg-
ular hashing3 (Table 1) and in ZK proof systems: PLONK
(Table 6), Groth16 (Table 3), and Bulletproofs (Table 5).
1https://electriccoin.co/blog/new-snark-curve/
2https://ristretto.group
3https://github.com/shamatar/poseidon_hash and https:
//github.com/shamatar/rescue_hash
520    30th USENIX Security Symposium
USENIX Association
Table 1: Our primary proposals and their competitors. “Tree” refers to the Merkle tree arity and is equal to the rate/capacity ratio.
“Curve” denotes the curve (BLS12-381, BN254, Ed25519) whose (subgroup) scalar ﬁeld determines the prime size. The R1CS/bit
costs are obtained by dividing the R1CS prover costs by the message rate. Timings are from a third-party implementation of
Rescue and POSEIDON on an i9-8950 CPU @2.9 Ghz and 32 GB RAM.
SB size Tree RF RP
(log2 p)
Curve
Scalar ﬁeld
Name
S-box
Rate
bits/perm.
POSEIDON-80
POSEIDON-128
POSEIDON-256
Pedersen Hash
x5
x5
x5
x5
x5
x5
x5
-
Rescue
x5 & x1/5
510
1020
510
1020