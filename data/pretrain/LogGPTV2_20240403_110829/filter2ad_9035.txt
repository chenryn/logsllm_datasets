原文地址：
去年11月，我们写过一篇[文章](https://blog.sucuri.net/2020/11/css-js-steganography-in-fake-flash-player-update-malware.html
"文章")，介绍了攻击者是如何使用JavaScript注入技术从合法的CSS文件中加载恶意代码的。
乍一看，这些注入的文件中除了一些正常的CSS规则外，似乎没有其他方面的内容。实际上，如果对.CSS文件进行更深入的分析的话就会发现，其中有56,964行貌似空行，但其实却包含了不可见的制表符（0x09）、空格符（0x20）和换行符（0x0A）等内容——这些字符首先被转换为二进制字符表示形式，之后被进一步转换为可执行JavaScript代码的文本形式。
没过多久，我们就发现PHP恶意软件中也采用了同样的方法。以下是我们的恶意软件分析师[Liam
Smith](https://twitter.com/liamsmith86 "Liam
Smith")最近在处理一个包含多个后门和黑客上传的webshell的网站时发现的样本。
## 可疑的license.php文件
实际上，Liam在该网站上发现了许多可疑文件，其中就包括`system/license.php`。
正如该文件名所暗示的那样，该文件中保存的是许可证协议的文本，更具体地说，是[GNU通用公共许可证](https://www.gnu.org/licenses/gpl-3.0.en.html
"GNU通用公共许可证")第3版的文本。
通过观察，我们发现这些许可证文本被放在一个多行的PHP注释中。然而，在第134行，我们看到两个注释之间有一个明显的空隙，并且其中含有可执行的PHP代码。
隐藏在`license.php`文件中的PHP代码
实际上，在注释块中隐藏恶意代码是黑客惯用的一种混淆技术。
很明显，这些被隐藏的代码肯定是恶意的，但乍看起来，根本搞不清楚该恶意软件的代码都放到了这里，还是这里只是其中的部分代码，而其他部分则位于文件中的其他地方。但是，有一点是不难看出的，即它试图用`file_get_contents(basename($_SERVER[‘PHP_SELF’])))`来读取自身内容并进行某些处理。然而，迅速检查该文件后，并没有发现任何其他可以转换为有效的PHP代码的空隙。
## 分析可见的恶意代码
为了了解恶意代码到底做了什么，我们对所有的语句都进行了逐条分析。
其中，第一个子句的作用是，以分号为分隔符，将文件的内容用分割成若干部分，并将最后一部分分配给`$cache`变量。通俗的说，这段代码的作用是处理文件中位于最后一个分号之后的内容。
事实上，文件中最后一个分号也是许可协议的最后一个字符：“But first, please read
`;`”。
在原始的许可协议中，最后一个字符是句号，说明攻击者对这个条款的文本做了手脚。
在这最后一个分号之后，并没有什么清晰可见的内容。为了理解文件的末尾部分是如何处理的，我们需要分析被恶意修改的条款后面的内容。
## 空白符解码器
    for($i=0;$i  
创建虚假的`license.php`文件的恶意Uploader
## 小结
虽然使恶意内容肉眼无法分辨似乎是一个不错的主意，但该恶意软件中使用的基于空白符的混淆技术，在隐身方面做的并不是非常理想。因为它包含了一个易于检测的PHP部分——如果将其删除，将导致不可见的payload无法正常使用。这种方法的另一个缺点是会令文件尺寸变得过于臃肿。例如，这里的恶意软件令文件大小增加了10倍，这很容易引起人们的怀疑。
黑客通常会借助于混淆技术来隐藏代码和恶意行为。就目前已知的混淆类型来说，已经多达成百上千种之多，但是，攻击者仍在努力寻找绕过安全检测的新方法。
对于网站管理员来说，好消息是您不必对恶意文件进行解码或了解如何查找和删除这种类型的恶意软件。一个简单的完整性控制解决方案就足以检测出可疑的文件修改行为。
每当您发现文件遭到了修改，但是不确定是否为恶意修改时，最安全的方法是将文件替换为已知的干净版本——毕竟您早已经做好了备份，对吧？