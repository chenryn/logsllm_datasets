# 特别加餐 | 倒排检索加速（一）：工业界如何利用跳表、哈希表、位图进行加速？

你好，我是陈东。欢迎来到检索专栏的第一次加餐时间。

许多同学在留言区提问，基础篇中提到的检索数据结构和算法在实际系统中的应用情况是怎样的？真实的检索系统和算法又是什么样子？为了帮助大家更好地将这些基础知识与实际应用相结合，我特别准备了两篇加餐文章，来探讨这些看似简单的技术是如何在工业界发挥重要作用的。

在很多大型系统中，倒排索引是最常用的检索技术之一，广泛应用于搜索引擎、广告引擎和推荐引擎等场景。而在倒排索引的检索过程中，两个posting list求交集是一个非常关键且耗时的操作。因此，今天我们将重点讨论倒排索引在求交集时如何通过跳表、哈希表和位图这三种基础数据结构进行加速。

## 跳表法加速倒排索引

在第5讲中我们提到，倒排索引中的posting list通常使用链表实现。当需要合并两个posting list A 和 B 并求其交集时，如果采用归并法，则时间复杂度为O(m+n)，其中m和n分别为A和B的长度。然而，对于这种归并过程，工业界有何优化手段呢？

以一个具体例子说明：假设A包含从1到1000递增排列的元素，而B仅包含3个元素{1, 500, 1000}。按照传统方法，找到第一个相同元素1后，还需遍历498次才能定位到下一个匹配项500，效率低下。实际上，在诸如搜索引擎及Lucene、Elasticsearch等软件中，常采用跳表替代链表实现posting list。如此一来，从A的第二个元素开始查找至第500个只需log(498)级别的操作次数，显著加快了速度。

此外，还有一种称为“相互二分查找”的策略可以进一步提高性能。该方法基于以下原则：若A当前节点值小于B，则用B的当前值作为键在A中快速前进；反之亦然。这种方法能够有效提升整体检索效率。另外，当posting list可完全驻留在内存中且变化不大时，使用可变长数组代替链表也是可行方案之一，因为连续存储有利于CPU利用局部性原理加速访问。

## 哈希表法加速倒排索引

哈希表以其O(1)级的查询性能著称，那么是否也能用于加速倒排索引呢？答案是肯定的。当处理大小悬殊的两个集合时，可以先将较大集合转换成哈希表形式，然后逐个检查较小集合中的元素是否存在于此表中。例如，给定上述A（含1000个元素）与B（仅3个），则预先构建A的哈希表示，之后每次针对B中的每个条目执行一次O(1)查询即可完成任务。

需要注意的是，此方法要求提前分析哪些posting list频繁参与交集运算，并将它们预存入哈希表内；同时保留原始列表以便于后续可能发生的其他类型操作。此外，只有当存在大量短小的posting list时，哈希表的优势才会更加明显。

## 位图法加速倒排索引

除了哈希表外，位图也是一种有效的加速工具。它通过将所有posting list转换成固定长度的位串来进行高效检索。具体来说，首先为每个key生成一致长度的位图表示整个对象空间；接着，若某元素存在于特定posting list中，则将其对应位置设为1。这样便完成了初步转换工作。

接下来，在查询阶段，可通过直接对两个位图执行AND逻辑运算来迅速获得共同项信息。由于位运算速度快且位图尺寸固定，因此只要总长度不是特别庞大，位图法能提供极高的检索效率。不过，这种方法也存在一定局限性，如只适合简单ID列表、不适用于稀疏分布的数据集以及会消耗较多存储资源等问题。

### Roaring Bitmap: 升级版位图

为解决普通位图的空间浪费问题，工业界常用Roaring Bitmap作为改进版本。它将32位整数分为高低各16位两部分分别处理：高16位存放在有序数组里形成“桶”，低16位则映射到相应桶内的位图上。查询时先定位桶再查找内部位图，从而实现了良好的压缩效果同时保持了较快的速度。

总之，通过对基本数据结构如跳表、哈希表、位图及其变种Roaring Bitmap的理解与灵活运用，我们可以设计出更高效的检索系统。希望本文对你有所帮助，也欢迎大家就相关话题展开深入交流！

**课堂讨论**

在Roaring Bitmap求交集的过程中，涉及到位图-位图、数组-数组以及位图-数组三种类型的交集计算。请问最终结果应选择哪种格式保存更为合适？请分享你的想法。