based on the worst-case hardness of lattice problems. In Asiacrypt, 2008.
41. D. E. Knuth. The art of computer programming, Volume II: Seminumerical Algo-
rithms, 3rd Edition. Addison-Wesley, 1998.
42. J. Li, N. Li, and R. Xue. Universal accumulators with eﬃcient nonmembership
proofs. In ACNS, 2007.
43. B. Libert, S. Ling, F. Mouhartem, K. Nguyen, and H. Wang. Zero-knowledge
In
arguments for matrix-vector relations and lattice-based group encryption.
Asiacrypt 2016.
44. B. Libert, S. Ling, F. Mouhartem, K. Nguyen, and H. Wang. Signature schemes
with eﬃcient protocols and dynamic group signatures from lattice assumptions. In
Asiacrypt, 2016.
45. B. Libert, S. Ling, K. Nguyen, and H. Wang. Zero-knowledge arguments for lattice-
based accumulators: Logarithmic-size ring signatures and group signatures without
trapdoors. In Eurocrypt, 2016.
46. B. Libert, S. Ling, K. Nguyen, and H. Wang. Zero-knowledge arguments for
lattice-based PRFs and applications to e-cash. In Asiacrypt, 2017. To appear.
30
47. B. Libert, T. Peters, and M. Yung. Scalable group signatures with revocation. In
Eurocrypt, 2012.
48. S. Ling, K. Nguyen, D. Stehl´e, and H. Wang. Improved zero-knowledge proofs of
knowledge for the ISIS problem, and applications. In PKC 2013, 2013.
49. H. Lipmaa. On Diophantine complexity and statistical zero-knowledge arguments.
In Asiacrypt, 2003.
50. H. Lipmaa, N. Asokan, and V. Niemi. Secure vickrey auctions without threshold
trust. In Financial Cryptography, 2002.
51. V. Lyubashevsky. Lattice-Based Identiﬁcation Schemes Secure Under Active Attacks.
In PKC, 2008.
52. V. Lyubashevsky, C. Peikert, and O. Regev. On ideal lattices and learning with
errors over rings. In Eurocrypt, 2010.
53. R. C. Merkle. A Certiﬁed Digital Signature. In Crypto, 1989.
54. D. Micciancio and C. Peikert. Trapdoors for lattices: Simpler, tighter, faster, smaller.
In Eurocrypt, 2012.
55. D. Micciancio and C. Peikert. Hardness of SIS and LWE with small parameters. In
Crypto 2013, 2013.
56. D. Micciancio and S. Vadhan. Statistical zero-knowledge proofs with eﬃcient
provers: Lattice problems and more. In Crypto, 2003.
57. T. Nakanishi, H. Fujii, Y. Hira, and N. Funabiki. Revocable group signature schemes
with constant costs for signing and verifying. In PKC, 2009.
58. T. Pedersen. Non-interactive and information-theoretic secure veriﬁable secret
sharing. In Crypto, volume 576 of LNCS, pages 129–140. Springer, 1991.
59. O. Regev. On lattices, learning with errors, random linear codes, and cryptography.
In STOC, 2005.
60. J. Stern. A new paradigm for public key identiﬁcation. Information Theory, IEEE
Transactions on, 42(6), 1996.
61. X. Xie, R. Xue, and M. Wang. Zero knowledge proofs from ring-LWE. In CANS,
2013.
A Detailed Description of the Protocol of Section 5.2
The tree paths. We walk the paths from y and z to the root u and capture
all the relations as equations modulo q and modulo 2. Let use denote the nodes
on the path from y by d(cid:96) = y, d(cid:96)−1, . . . , d1, d0 = u ∈ {0, 1}k and their siblings
by e(cid:96), e(cid:96)−1, . . . , e1 ∈ {0, 1}k, respectively. Recall that the bits determining this
path are denoted by v(cid:96)−1, . . . , v0.
Following the construction of the tree from Section 2.1, ∀i ∈ {(cid:96) − 1, . . . , 1, 0},
we have:
(cid:40)
di =
hB(di+1, ei+1), if vi = 0;
hB(ei+1, di+1), if vi = 1.
⇔ di = vi · hB(di+1, ei+1) + vi · hB(ei+1, di),
which can be interpreted as:
B0 · (vi · di+1) + B1 · (vi · di+1) + B0 · (vi · ei+1) + B1 · (vi · ei+1) = G· di mod q.
For each i = (cid:96) − 1, . . . , 0, let
31
...
– di+1 = d(cid:63)
– ei+1 = e(cid:63)
i + d(cid:48)
i + e(cid:48)
i, where d(cid:63)
i, where e(cid:63)
i = vi · di+1 and d(cid:48)
i = vi · ei+1 and e(cid:48)
i = vi · di+1.
i = vi · ei+1.
Then, we have the following equations modulo q:
(cid:96)−1 + B1 · e(cid:63)
(cid:96)−2 + B1 · e(cid:63)
(cid:96)−1 + B1 · d(cid:48)
(cid:96)−2 + B1 · d(cid:48)
(cid:96)−1 + B0 · e(cid:48)
(cid:96)−2 + B0 · e(cid:48)
B0 · d(cid:63)
B0 · d(cid:63)
(cid:96)−1 − G · d(cid:96)−1 = 0 mod q;
(cid:96)−2 − G · d(cid:96)−2 = 0 mod q;
(27)
B0 · d(cid:63)
0 + B1 · d(cid:48)
0 + B0 · e(cid:48)
0 + B1 · e(cid:63)
0 = G · u mod q.
By re-writing the matrix-vector products in 27 as sums of vector-bit products,
and then combining the equations together, we obtain one linear equation modulo
q that contains a total of 5k(cid:96) − k secret bits.
modulo 2, for all i = (cid:96) − 1, . . . , 0:
Meanwhile, we also have the following (5k + 1)(cid:96) linear and quadratic equations
i,j = 0 mod 2,∀j ∈ [0, k − 1]
vi + vi = 1 mod 2;
i,j + d(cid:48)
di+1,j + d(cid:63)
i,j + vi · di+1,j = 0 mod 2,∀j ∈ [0, k − 1]
d(cid:63)
i,j + vi · di+1,j = 0 mod 2,∀j ∈ [0, k − 1]
d(cid:48)
i,j + vi · ei+1,j = 0 mod 2,∀j ∈ [0, k − 1]
e(cid:63)
i,j + vi · ei+1,j = 0 mod 2,∀j ∈ [0, k − 1]
e(cid:48)
i and di+1
// The relation between vi and vi
// The bits of di+1, d(cid:63)
// The bits of d(cid:63)
// The bits of d(cid:48)
// The bits of e(cid:63)
// The bits of e(cid:48)
i and ei+1
i and ei+1.
i and di+1
i and di+1
Note that these equations contain (7k + 2)(cid:96) secret bits and 4k(cid:96) quadratic terms.
Next, we proceed analogously for the path from z to u, which is determined
by the bits w(cid:96)−1, . . . , w0, and also obtain a linear equation involving 5k(cid:96) − k
secret bits over Zq, as well as (5k + 1)(cid:96) equations over Z2, which contain (7k + 2)(cid:96)
secret bits and 4k(cid:96) quadratic terms.
The range membership Y  SM . If V (cid:48) ∈ [1, M − 1], then SV (cid:48) and SV (cid:48)+1
are consecutive elements of Set and SV (cid:48) < X(cid:48) < SV (cid:48)+1. In either case, we obtain
that X(cid:48)(cid:48) = X(cid:48) (cid:54)∈ Set, which yields a contradiction.
The security of our protocol thus relies on the binding property of the com-
mitment COM used in the interaction, the binding property of the commitment
used to commit X, and the security of the Merkle hash tree being used. These
ingredients all rely on the assumption that SIVP(cid:101)O(n) is hard.
(cid:16)O(cid:0)(m1 + m2) log q(cid:1) + O(cid:0)N + |T|(cid:1)(cid:17) · κ = O(n log2 q · log M ) · κ = (cid:101)O(n · log M ).
If we repeat the protocol κ = ω(log n) times to achieve negligible soundness
error, then the total communication cost will be of order
The above description of the protocol assumes that the bit-size k of all
i=1 equals k = n(cid:100)log q(cid:101), which is necessary to build the Merkle tree
elements {Si}M
in a bottom-up fashion by recursively hashing strings using the same SIS-based
33
i=1 cost less than n(cid:100)log q(cid:101) bits to
hash function as in [45]. If set elements {Si}M
represent, we can simply pad them with zeroes until they reach the desired
length. In applications where their binary representation exceeds n(cid:100)log q(cid:101) bits,
we can ﬁrst apply a collision-resistant hash function in order to have strings of
length k = n(cid:100)log q(cid:101). In this case, the leaves of the Merkle tree should be sorted
in the lexicographical order of their k-bit hash values. In order to preserve the
compatibility of the whole protocol with zero-knowledge arguments, we can use a
SIS-based hash function HSIS : {0, 1}m → Zn
q like Ajtai’s function [2] as it allows
proving that a committed m-bit element hashes into some k-bit string which is
not a leaf of the Merkle tree.
34