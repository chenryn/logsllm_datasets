In this section, we will prove security of all our main constructions,
that is, Protocols 2, 3, and 4. We do not provide a full proof for
Protocol 6, but as we discuss in Section 6, this proof can be obtained
directly by taking the one given by Boyle et al. [9] and replacing
their MPFSS construction by ours. As described in Section 2.6, we
split our proofs in three phases, i.e., we (i) define correctness and
security requirements, (ii) define ideal functionalities that satisfy
these requirements, and (iii) prove our key generation protocols
securely implement the ideal functionalities.
We note that our definitions are also closely related to the Pseu-
dorandom Correlation Generators (PCGs) of Boyle et al. [11]. How-
ever, as our key generators take additional arguments beyond the
security parameter, we cannot use their definition out-of-the-box.
Still, our (ğ‘› âˆ’ 1)-out-of-ğ‘›-ROT is defined in a similar way as PCGs.
For our FSS variants, we stick to pure simulation-based proofs us-
ing Definition 2.2, which ensures they cen be used as a drop-in
replacement for the constructions of Boyle et al. [9].
(ğ‘› âˆ’ 1)-out-of-ğ‘›-ROT
A.1
Definition A.1 (Pseudorandom (ğ‘› âˆ’ 1)-out-of-ğ‘›-OT Generator). A
pseudorandom (ğ‘›âˆ’1)-out-of-ğ‘›-OT generator for a group G consists
of the following two algorithms:
â€¢ (ğ¾1, ğ¾2) â† ROT.Gen(1ğœ†, ğ‘›, ğ‘–) - Outputs two keys when
given an output size ğ‘› and a single index ğ‘– âˆˆ [ğ‘›].
â€¢ vğ‘ â† ROT.Expand(ğ‘, ğ¾ğ‘) - Given an evaluation key ğ¾ğ‘ for
ğ‘ âˆˆ {1, 2}, outputs a vector of length ğ‘›.
Here, ğœ† âˆˆ N denotes a security parameter. Additionally, the follow-
ing properties must hold:
Correctness. For any ğ‘› âˆˆ N and ğ‘– âˆˆ [ğ‘›], any pair (ğ¾1, ğ¾2) in the
image of ROT.Gen(1ğœ†, ğ‘›, ğ‘–), and vğ‘ â† ROT.Expand(ğ‘, ğ¾ğ‘)
for ğ‘ âˆˆ {1, 2}, we have that v1 is computationally indistin-
guishable from a uniformly random vector from Gğ‘›, and
ğ‘£1
ğ‘— = ğ‘£2
ğ‘— for all ğ‘— âˆˆ [ğ‘›] \ {ğ‘–}.
15
Functionality 7: ğ‘› âˆ’ 1-out-of-ğ‘›-ROT
Public Parameter: ğ‘˜
Key Generation (ROT.Gen(1ğœ†, ğ‘›, ğ‘–)):
(1) Run steps (1) and (2) from Protocol 2 as P1 to obtain a
ğ‘˜-ary GGM tree ğ‘‡ with root ğ‘ 0 and depth ğ›¼ = logğ‘˜(ğ‘›),
using seeds of size ğœ†.
(2) For each level ğ‘™ âˆˆ [ğ›¼], let (ğ‘1, . . . , ğ‘ğ‘˜ğ‘™) be the seeds of
the ğ‘™th level of ğ‘‡ , and for each ğ‘— âˆˆ [ğ‘˜] \ {ğ‘ğ‘™}, compute
ğ‘ğ‘™,ğ‘— â† 
ğ‘ âˆˆ{ğ‘ğ‘¥ : ğ‘¥ â‰¡ ğ‘— mod ğ‘˜}
(3) Let (ğ‘1, . . . , ğ‘ğ›¼) be a ğ‘˜-ary encoding of ğ‘– âˆ’ 1. Return
Expansion (ROT.Expand(ğ‘, ğ¾ğ‘)):
Let ğ›¼ = logğ‘˜(ğ‘›).
ğ¾1 â† ğ‘ 0 and ğ¾2 â†(cid:0)ğ‘–, (ğ‘ğ‘™,ğ‘—)ğ‘™âˆˆ[ğ›¼],ğ‘— âˆˆ[ğ‘˜]\{ğ‘ğ‘™ }(cid:1).
â€¢ If ğ‘ = 2, parse ğ¾ğ‘ as(cid:0)ğ‘–, (ğ‘ğ‘™,ğ‘—)ğ‘™âˆˆ[ğ›¼],ğ‘—âˆˆ[ğ‘˜]\{ğ‘ğ‘™ }(cid:1), where
the ğ‘› leaves of ğ‘‡ .
(ğ‘1, . . . , ğ‘ğ›¼) is a ğ‘˜-ary encoding of ğ‘– âˆ’ 1. Then run steps
(5) and (7) of Protocol 2 as P2.
â€¢ If ğ‘ = 1, compute the GGM tree ğ‘‡ = ğ‘‡ (ğ¾ğ‘, ğ›¼) and output
ğ‘ .
Security. There are ppt simulators Simğ‘ for ğ‘ âˆˆ {1, 2} such that
for any ğ‘› âˆˆ N and ğ‘– âˆˆ [ğ‘›],
(cid:26)
ğ¾1
and(cid:40)
ğ¾2, ğ‘£1
ğ‘–
(cid:27) ğ‘â‰ˆ
(cid:12)(cid:12)(cid:12)(cid:12) (ğ¾1, ğ¾2) ğ‘…â† ROT.Gen(1ğœ†, ğ‘›, ğ‘–),
(cid:12)(cid:12)(cid:12)(cid:12) ğ¾1
(cid:26)
(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)
(ğ¾1, ğ¾2) ğ‘…â† ROT.Gen(1ğœ†, ğ‘›, ğ‘–),
v1 â† ROT.Expand(1, ğ¾1)
ğ¾1
(cid:26)
(cid:12)(cid:12)(cid:12)(cid:12) ğ¾2
ğ¾2, ğ‘£1
ğ‘–
ğ‘…â† Sim2(1ğœ†, ğ‘›, ğ‘–), ğ‘£1
ğ‘–
ğ‘…â† G
ğ‘…â† Sim1(1ğœ†, ğ‘›)
(cid:41)
ğ‘â‰ˆ
(cid:27)
(cid:27)
,
(2)
.
(3)
Informally, the above security definition ensures that P1 does not
learn anything about ğ‘–, while P2 does not learn anything about ğ‘£1
ğ‘– ,
i.e., the random value it chooses not to receive, beyond the fact that
it is random.
Theorem A.2. Functionality 7 is a pseudorandom generator for
(ğ‘› âˆ’ 1)-out-of-ğ‘›-OT.
uniformly at random, v1 â† ROT.Expand(1, ğ¾1) =(cid:0)ğ¹ğ‘ 0( ğ‘—)(cid:1)
Proof. Correctness. First, observe that a GGM tree ğ‘‡ with ğ‘›
leaves and initial seed ğ‘ 0 implements a PRF ğ¹ğ‘ 0 : [ğ‘›] â†’ {0, 1}ğœ† with
key ğ‘ 0, where ğ¹ğ‘ 0( ğ‘—) is the ğ‘—-th leaf of ğ‘‡ [32, 37]. Since ğ‘ 0 is chosen
ğ‘— âˆˆ[ğ‘›] is
indistinguishable from a vector drawn uniformly at random from
Gğ‘›. Second, observe that in ROT.Expand(2, ğ¾2) in Functionality 7,
all seeds of sub-trees of ğ‘‡ that do not lie on the path to the ğ‘–-th leaf
are recovered. Since the expansion of ğº is deterministic, all leaves
of these sub-trees are equal to the corresponding leaves in ğ‘‡ , and
therefore ğ‘£1
Security. We construct simulators Simğ‘ for ğ‘ âˆˆ {1, 2} as follows.
ğ‘— for all ğ‘— âˆˆ [ğ‘›] \ {ğ‘–}.
ğ‘— = ğ‘£2
ğ‘™,ğ‘—
0 âˆˆ {0, 1}ğœ† and output ğ‘ â€²
ğ‘ = 1. Sample a random seed ğ‘ â€²
2 â†(cid:0)ğ‘–, (ğ‘â€²
ğ‘™,ğ‘—)ğ‘™âˆˆ[ğ›¼],ğ‘—âˆˆ[ğ‘˜]\{ğ‘ğ‘™ }(cid:1).
0. Indistin-
guishability of the two sides in Eq. (2) follows immediately
as ğ¾1 on the left hand side is also sampled uniformly from
{0, 1}ğœ†.
ğ‘ = 2. Let ğ›¼ = logğ‘˜(ğ‘›), and let (ğ‘1, . . . , ğ‘ğ›¼) be a ğ‘˜-ary encoding of
ğ‘–âˆ’1. Construct a partial GGM tree by following the path from
the root to the ğ‘–-th leaf, sampling uniformly random seeds for
all siblings of nodes on that path, and expanding them using
the GGM construction. Now, for each level ğ‘™ âˆˆ [ğ›¼] and each
ğ‘— âˆˆ [ğ‘˜] \ {ğ‘ğ‘™}, compute ğ‘â€²
as in Step (2) of Functionality 7,
and output ğ¾â€²
We will now show the indistinguishability of the two sides
of Eq. (3) using a hybrid argument. We construct ğ›¼ +1 hybrid
distributions by successively modifying ROT.Gen as follows.
Let H0 be the left-hand side of Eq. (3), and let (ğ‘1, . . . , ğ‘ğ›¼)
denote the nodes on the path from the root to the ğ‘–-th leaf of
the GGM tree generated in ROT.Gen. Now, for each ğ‘™ âˆˆ [ğ›¼],
construct Hğ‘™ from Hğ‘™âˆ’1 by replacing the result of the PRG
expansion of ğ‘ğ‘™ by ğ‘˜ uniformly random strings from {0, 1}ğœ†,
and proceeding normally from then on to compute ğ¾â€²
2. Note
that neither ğ»ğ‘™âˆ’1 nor ğ»ğ‘™ contain ğ‘ğ‘™, but both contain at least
one of the children. Thus, any distinguisher between Hğ‘™âˆ’1
and Hğ‘™ could be used to distinguish the output of a PRG
from random. Now, by construction of Sim2 above, H ğ›¼ is
precisely the right-hand side of Eq. 3 which concludes the
security proof.
â–¡
What remains to be shown is that the key generation of Proto-
col 2 securely implements Functionality 7. We reduce this to the
security of the (ğ‘˜ âˆ’ 1)-out-of-ğ‘˜-OT sub-protocol used in Protocol 2.
Theorem A.3. Steps (1) â€“ (4) of Protocol 2 implement Functional-
ity 7 in the (ğ‘˜ âˆ’ 1)-out-of-ğ‘˜-OT-hybrid model with security against
semi-honest adversaries.
Proof. For each ğ‘ âˆˆ {1, 2}, we construct a simulator Simğ‘ for
the view of Pğ‘ in the (ğ‘˜ âˆ’ 1)-out-of-ğ‘˜-OT-hybrid model.
ğ‘ = 1. Since P1 does not receive any messages in Protocol 2, Sim1
is the identity function. Since the computation performed
is the same in Protocol 2 and Functionality 7, the simulated
and real views are identically distributed.
ğ‘ = 2. Here, in addition to the outputs of the ideal functionality, P2
receives the outputs of the OTs in Step (4). However, note
that these are directly passed through to P2â€™s output and are
therefore trivially simulatable. Since the values computed
in Step (2) of Functionality 7 are precisely the ones selected
by the OT functionality, the two views are again identically
distributed.
â–¡
We can now compose Protocol 2 with any (ğ‘˜ âˆ’ 1)-out-of-ğ‘˜-OT
protocol using a standard modular composition theorem, as for
example given by Canetti [14], thus obtaining a secure protocol in
the plain model.
16
(cid:0)ğ¾ROT1
Functionality 8: Known-Index SPFSS
Key Generation (SPFSS.Gen(1ğœ†, ğ‘“ğ‘–,ğ›½)):
Let [ğ‘›] denote the domain of ğ‘“ğ‘–,ğ›½.
(1) Generate keys for a (ğ‘› âˆ’ 1)-out-of-ğ‘›-ROT scheme
(2) Compute v1 = ROT.Expand(1, ğ¾1) and Ëœğ‘Ÿ = ğ›½ âˆ’ ğ‘£1
ğ‘– .
(3) Output ğ¾1 = ğ¾ROT1
Expansion (SPFSS.Eval(ğ‘, ğ¾ğ‘, ğ‘¥)):
Let G denote the image of ğ‘“ğ‘–,ğ›½.
(cid:1) â† ROT.Gen(1ğœ†, ğ‘›, ğ‘–).
and ğ¾2 =(cid:0)ğ¾ROT2
, Ëœğ‘Ÿ(cid:1).
, ğ¾ROT2
â€¢ If ğ‘ = 1, compute v1 â† ROT.Expand(1, ğ¾1) and output
ğ‘£1
ğ‘¥.
contains
â€¢ If ğ‘ = 2, parse ğ¾2 as(cid:0)ğ¾ROT2
compute v2 â† ROT.Expand(cid:0)2, ğ¾ROT2
, Ëœğ‘Ÿ(cid:1). Note that ğ¾ROT2
(cid:1) and output âˆ’ğ‘£2
the non-zero index ğ‘–. If ğ‘¥ = ğ‘–, output Ëœğ‘Ÿ. Otherwise,
ğ‘¥.
A.2 Known-Index SPFSS
Here, we define out Known-Index SPFSS as an instance of Defini-
tion 2.2 from the preliminaries section.
Definition A.4 (Known-Index SPFSS). Let F = {ğ‘“ğ‘–,ğ›½ : [ğ‘›] â†’ G}
denote a class of point functions, where for all ğ‘¥ âˆˆ [ğ‘›],
(cid:26) ğ›½
0
ğ‘“ğ‘–,ğ›½ =
if ğ‘¥ = ğ‘–,
otherwise.
A Known-Index Single-Point Function Secret Sharing (Known-Index
SPFSS) scheme is a FSS scheme for F , where Leak1(ğ‘“ğ‘–,ğ›½) = (ğ¼, G)
and Leak2(ğ‘“ğ‘–,ğ›½) = (ğ¼, G, ğ‘–), i.e., we allow the recipient of ğ¾2 to
additionally learn the non-zero index ğ‘– (but not the value ğ›½).
In Functionality 8, we define key generation and evaluation pro-
cedures for our known-index FSS scheme. We will now prove that
this functionality indeed satisfies Definition A.4, and that Protocol 3
implements the key generation phase securely.
Theorem A.5. Functionality 8 is a Known-Index Single-Point
Function Secret Sharing scheme.
Proof. Correctness. For any ğ‘— âˆˆ [ğ‘›] \ {ğ‘–}, the correctness of the
ğ‘— , and hence SPFSS.Eval(1, ğ¾1, ğ‘—)+
ROT scheme guarantees that ğ‘£1
ğ‘— = ğ‘£2
SPFSS.Eval(2, ğ¾2, ğ‘—) = ğ‘£1
ğ‘— âˆ’ ğ‘£2
ğ‘— = 0. On the other hand, for ğ‘— = ğ‘–,
we have SPFSS.Eval(1, ğ¾1, ğ‘—) + SPFSS.Eval(2, ğ¾2, ğ‘—) = ğ‘£1
ğ‘– + Ëœğ‘Ÿ =
ğ‘– + ğ›½ âˆ’ ğ‘£1
ğ‘£1
Security. We construct the following simulators Simğ‘ for ğ‘ âˆˆ
{1, 2}, assuming simulators SimROT
for the random OT scheme
used.
ğ‘ = 1. Output SimROT1
(1ğœ†, ğ‘›). Indistinguishability follows from Eq. (2)
ğ‘– = ğ›½.
ğ‘
ğ‘…â† G and output(cid:0)SimROT2