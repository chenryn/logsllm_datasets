# 九、管理工作流
在本章中，我们将把前几章中描述的不同流程整合到一个通用工作流中，这样我们就可以对单个微服务进行更改。我们将从获取新功能请求的过程继续到本地开发、审查、在演示环境中测试，以及批准更改并将其发布到实时集群。
这与我们在[第 4 章](04.html)、*创建管道和工作流*中介绍的管道概念有关。然而，在本章中，我们将讨论任务的过程。管道和建筑结构在那里，以确保任何提议的变更符合质量标准。在这一章中，我们将重点关注该技术的团队合作方面，以及如何在跟踪不同变化的同时实现流畅的交互。
在本章中，我们将涵盖以下主题:
*   了解功能的生命周期
*   审查和批准新功能
*   设置多个环境
*   扩展工作流程并使其发挥作用
到本章结束时，我们将清楚地看到为我们的一个微服务设置新功能所涉及的不同步骤，以及我们如何使用多个环境来测试并确保发布成功。
# 了解功能的生命周期
遵循敏捷原则，任何团队的主要目标都是能够快速实现新特性，而不会影响系统的质量或稳定性。变化的第一个要素是**特征请求**的形状。
A feature request is a description of a change in the system in non-technical terms. Feature requests are normally generated by non-engineers (product owners, managers, and CEOs) who are looking to improve the system for business-related reasons, such as making a better product or increasing revenue.
Feature requests can be simple, such as *updating the logo of the company in the main page*, or big and complicated, such as *adding support to the new 5G network*. Feature requests may include bug reports. While they don't usually, they will for the purpose of this chapter.
复杂的特性请求可能需要被细分成更小的独立的特性请求，这样我们就可以以小的增量迭代。
Our focus is on the elements that need to be taken into account due to the microservices approaches and practices more than agile practices. Such practices deal with how to structure feature requests into tasks and estimations, but they are not specific to the underlying technologies.
Take a look at the *Further reading* section at the end of this chapter to find out more about agile practices and methodologies.
在一个整体中，所有的元素都在同一个代码基础下。因此，无论特定功能请求有多复杂，都只会影响一个系统。整体中只有一个单一的系统。然而，一旦我们迁移到微服务，情况就不是这样了。
在微服务架构中，我们需要分析任何传入的特性请求，看它影响什么微服务。如果我们正确设计我们的微服务，大多数请求将只影响单个微服务。然而，最终，一些功能请求会太大，无法整齐地放入单个微服务中，并且需要分成两个或更多步骤，每个步骤改变一个不同的微服务。
例如，如果我们有一个新的功能请求，允许我们在一个想法的文本中提到一个用户(类似于一个提及在推特上是如何工作的)，那么这个提及将必须存储在想法后端，并显示在前端。这个特性影响两个微服务:前端和思想后端。
In this section, we are referring to concepts that we introduced in the previous chapters and are joining them together from a global point of view.
在下一小节中，我们将研究影响多个微服务的特性。
# 影响多个微服务的功能
对于多微服务功能请求，您需要将该功能分成几个技术功能，每个功能影响一个微服务。
每个技术特性都应该涵盖与其影响的微服务相关的一个方面。如果每个微服务都有一个明确的目的和目标，那么这个特性将被完成和推广，以便它可以用于以后的请求。
The basis for a successful microservice architecture is to have loosely coupled services. Ensuring that the API of each microservice makes sense on its own is important if we wish to avoid blurring the lines between services. Not doing so may mean that independent work and deployments aren't allowed.
还应该考虑请求和微服务之间的依赖关系，以便工作可以前后安排。这意味着准备添加额外数据或功能的新特性，但默认情况下保留旧行为。这样做之后，可以部署一个使用这些额外数据的新特性。这种工作方式确保了在任何给定时间的向后兼容性。
We will look at the features that affect multiple microservices in more detail in [Chapter 11](11.html), *Handling Change, Dependencies, and Secrets in the System*. We'll also learn how to coordinate work and dependencies in more detail.
回到我们前面的例子，要在用户的想法中添加用户的提及，我们需要让想法后端能够处理对用户的可选引用。这是一个独立的任务，不会影响现有的功能。它可以被部署和测试。
然后，我们可以在 Frontend 中进行相应的更改，以允许外部用户通过一个 HTML 界面与其进行交互。
正如我们在[第 1 章](01.html)、*行动起来——设计、规划和执行*中所讨论的，对于任何微服务架构来说，我们能够独立部署服务是至关重要的。这使我们能够独立测试服务，并避免任何需要复杂部署的开销，如果出现错误，我们很难进行调试和回滚。
如果不同的团队在不同的微服务上独立工作，那么他们也需要协调。
在下一节中，我们将学习如何在单个微服务中实现一个特性。
# 实现功能
一旦我们有了独立技术特性的定义，它就可以实现了。
Defining a technical feature in a clear manner can be challenging. Remember that a single feature may need to be further subdivided into smaller tasks. However, as we mentioned previously, the objective here is not to structure our tasks. 
通过创建一个新的 Git 分支来开始您的任务。代码可以更改，以反映该分支中的新功能。正如我们在[第 2 章](02.html)、*用 Python 创建 REST 服务*和[第 3 章](03.html)、*使用 Docker* 构建、运行和测试您的服务时所看到的，可以运行单元测试来确保这项工作不会破坏构建。
As we described in [Chapter 3](03.html), *Build, Run, and Test Your Service Using Docker*, in the *Operating with an immutable container* section, we can use `pytest` arguments to run subsets of tests to speed up development, thereby enabling quick feedback when running tests. Make sure you use it. 
可以通过部署本地集群来检查该功能如何与整个系统相关地工作。这将启动可能受该分支中的工作影响的其他微服务，但它有助于确保当前工作不会中断任何影响其他微服务的现有调用。
基于这个管道，任何推送到 Git 的提交都将运行它的所有测试。这将及早发现问题，并确保在与主分支合并之前构建是正确的。
在这个过程中，我们可以使用拉请求来检查主分支和新特性之间的变化。我们可以在合并之前检查我们的 GitHub 配置，以确保代码状态良好。
一旦特性准备好并与主分支合并，就应该创建一个新的标签来允许它的部署。作为已配置管道的一部分，此标记将触发一个构建，该构建在注册表中生成一个映像，并用相同的标记标记该映像。标签和映像是不可变的，所以我们可以确定代码不会在不同的环境中改变。您可以放心地向前和向后滚动，代码将与标签中定义的代码完全相同。
正如我们在[第 8 章](08.html)*中看到的，使用 GitOps 原则*，可以通过遵循 GitOps 原则来部署标签。部署在 Git 控制下的 Kubernetes 配置文件中进行描述，并在需要批准的请求中进行审查。一旦拉取请求与主分支合并，它将由 Flux 自动部署，如我们在[第 8 章](08.html)、*中使用 GitOps 原则*所述，在*中设置 Flux 来控制 Kubernetes 集群*部分。此时，该功能在集群中可用。
让我们回顾一下这个生命周期，从技术请求的描述到何时部署到集群:
This is a more complete version of the Flow that we introduced in [Chapter 4](04.html), *Creating a Pipeline and Workflow*.
1.  技术请求已准备好实现到单个微服务中。
2.  将创建一个新的特征分支。
3.  微服务的代码在这个分支中被改变，直到特性准备好。
4.  创建用于将特征分支合并到主分支的拉请求。如[第 4 章](04.html)、*创建管道和工作流*中所述，在*理解持续集成实践*部分，运行 CI 流程以确保其高质量。
5.  拉取请求被审查、批准并合并到主分支中。
6.  将创建一个新标签。
7.  在 GitOps 存储库中创建一个部署分支，将微服务的版本更改为新的标签。
8.  将创建一个用于合并此部署分支的请求。然后，它被审查和合并。
9.  一旦代码被合并，集群会自动发布微服务的新版本。
10.  最后，集群中提供了新功能！
This is a simplified version of the life cycle; in reality, it may be more complicated. Later in this chapter, we will look at a situation where the life cycle needs to be deployed to more than one cluster.
在下一节中，我们将了解一些关于审查和批准请求的建议。
# 审查和批准新功能
正如我们在[第 4 章](04.html)、*创建管道和工作流*中描述的管道模型所指定的，候选代码经过一系列阶段，如果有问题就停止。
正如我们前面提到的，如果我们希望在微服务的代码中引入新的特性，并且希望通过 GitOps 实践将这些变化部署到集群中，那么使用 GitHub pull 请求进行审查是可行的。
在这两种情况下，我们都可以通过自动化测试和流程自动检查这一点。然而，还有最后一步需要人工干预:知识传授和多一双眼睛。一旦审阅者认为新功能已经准备好，他们就可以批准它。
这些工具是相同的，尽管审查过程的工作方式略有不同。这是因为目标不一样。对于功能代码，在它被批准并合并到主分支之前，评审更容易被讨论。另一方面，审查和批准一个版本通常更直接、更快。
让我们从学习如何检查功能代码开始。
# 查看功能代码
代码审查可以在功能开发期间启动，并且已经打开了合并它的请求。正如我们已经看到的，在 GitHub 中，代码可以在**拉取请求**阶段被检查。
代码评审基本上是关于代码和新特性的成型讨论；也就是说，在将代码引入主分支之前，我们正在检查代码。这为我们提供了在功能开发过程中以及成为系统组件之前对其进行改进的机会。
在这里，团队的一个成员可能会阅读尚未合并的代码，并给作者一些反馈。这可以反复进行，直到审阅者认为代码可以合并并批准它。本质上，除了该特性的作者之外，其他人需要同意新代码符合要求的标准。
Code bases grow over time and their components can help each other out. Merging code into the main branch states that you fully accept that the new code will be maintained by the team as part of the code base.
代码可能需要由一个或多个人员或特定人员批准。
In GitHub, you can enable code owners. These are engineers who are responsible for approving repositories, or parts of repositories. Check out the GitHub documentation for more information: [https://help.github.com/en/articles/about-code-owners](https://help.github.com/en/articles/about-code-owners).
如今，代码审查是一个非常常见的过程，在 GitHub 中使用拉请求的流行性和易用性已经传播开来。大多数开发人员都熟悉这个过程。
然而，实现一个好的反馈文化比看起来更难。写代码是一种深刻的个人体验；没有两个人会写同样的代码。对于开发人员来说，除非有明确的规则，否则让您的代码受到他人的批评可能是一种困难的体验。
以下是一些建议:
*   告诉你的审稿人他们应该寻找什么。一定要遵循清单。这有助于在团队中培养一种文化，使他们关心共同的核心价值观。这也有助于初级开发人员知道要寻找什么。这可能会因团队而异，但以下是一些示例: