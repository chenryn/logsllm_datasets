any age-restricted items when you placed the order. In this case,
switch back to the application and create a new order that includes
one or more of these items.
Download from finelybook PI:EMAIL
672
10. Open the audit-nnnnnn.xml file by using Visual Studio. This file
contains a list of the age-restricted items in the order together with the
order number and date. The file is in XML format and should look
similar to this:
Close the file in Visual Studio when you finish examining this list.
11. Open the dispatch-nnnnnn.txt file by using Notepad. This file contains a
summary of the order, listing the order ID and the value. This is an
ordinary text file and should look similar to this:
Close Notepad, return to Visual Studio 2017 and stop debugging.
12. In Visual Studio, notice that the solution consists of the following
projects:
• Delegates This project contains the application itself. The
MainPage.xaml file defines the user interface, and the application logic
is contained in the MainPage.xaml.cs file.
• AuditService This project contains the component that implements
the auditing process. It is packaged as a class library and contains a
single class named Auditor. This class exposes a single public method,
AuditOrder, that examines an order and generates the audit-
nnnnnn.xml file if the order contains any age-restricted items.
Download from finelybook PI:EMAIL
673
• DeliveryService This project contains the component that performs
the shipping logic, packaged as a class library. The shipping
functionality is contained in the Shipper class, and it provides a public
method named ShipOrder that handles the shipping process and also
generates the dispatch note.
Note You are welcome to examine the code in the Auditor and
Shipper classes, but it is not necessary to fully understand the inner
workings of these components in this application.
• DataTypes This project contains the data types used by the other
projects. The Product class defines the details of the products
displayed by the application, and the data for the products is held in the
ProductsDataSource class. (The application currently uses a small
hard-coded set of products. In a production system, this information
would be retrieved from a database or web service.) The Order and
OrderItem classes implement the structure of an order; each order
contains one or more order items.
13. In the Delegates project, display the MainPage.xaml.cs file in the Code
and Text Editor window and examine the private fields and MainPage
constructor in this file. The important elements look like this:
...
private Auditor auditor = null;
private Shipper shipper = null;
public MainPage()
{
    ...
    this.auditor = new Auditor();
    this.shipper = new Shipper();
}
The auditor and shipper fields contain references to instances of the
Auditor and Shipper classes, and the constructor instantiates these
objects.
Download from finelybook PI:EMAIL
674
14. Locate the CheckoutButtonClicked method. This method runs when the
user clicks Checkout to place an order. The first few lines look like this:
Click here to view code image
private void CheckoutButtonClicked(object sender,
RoutedEventArgs e)
{
    try
    {
        // Perform the checkout processing
        if (this.requestPayment())
        {
            this.auditor.AuditOrder(this.order);
            this.shipper.ShipOrder(this.order);
        }
        ...
    }
    ...
}
This method implements the checkout processing. It requests payment
from the customer and then invokes the AuditOrder method of the
auditor object followed by the ShipOrder method of the shipper object.
Any additional business logic required in the future can be added here.
The remainder of the code in this method (after the if statement) is
concerned with managing the user interface: displaying the message box
to the user and clearing out the Order Details pane.
Note For simplicity, the requestPayment method in this application
currently just returns true to indicate that payment has been received. In
the real world, this method would perform the complete payment
processing and verification.
Although the application operates as advertised, the Auditor and Shipper
components are tightly integrated into the checkout processing. If these
components change, the application will need to be updated. Similarly, if you
need to incorporate additional logic into the checkout process, possibly
performed by using other components, you will need to amend this part of the
Download from finelybook PI:EMAIL
675
application.
In the next exercise, you will see how you can decouple the business
processing for the checkout operation from the application. The checkout
processing will still need to invoke the Auditor and Shipper components, but
it must be extensible enough to allow additional components to be easily
incorporated. You will achieve this by creating a component called
CheckoutController. The CheckoutController component will implement the
business logic for the checkout process and expose a delegate that enables an
application to specify which components and methods should be included
within this process. The CheckoutController component will invoke these
methods by using the delegate.
Create the CheckoutController component
1. In Solution Explorer, right-click the Delegates solution, point to Add,
and then click New Project.
2. In the Add New Project dialog box, in the left pane, under Visual C#,
click the Windows Universal node. In the middle pane, select the Class
Library (Universal Windows) template. In the Name box, type
CheckoutService, and then click OK.
3. In the New Universal Windows Project dialog box, accept the default
values for Target Version and Minimum Version, and then click OK.
4. In Solution Explorer, expand the CheckoutService project, right-click
the file Class1.cs, and then click Rename. Change the name of the file to
CheckoutController.cs and then press Enter. Allow Visual Studio to
rename all references to Class1 as CheckoutController when prompted.
5. Right-click the References node in the CheckoutService project, and
then click Add Reference.
6. In the Reference Manager - CheckoutService dialog box, in the left
pane, click Solution. In the middle pane, select the DataTypes project,
and then click OK.
The CheckoutController class will use the Order class defined in the
DataTypes project.
Download from finelybook PI:EMAIL
676
7. In the Code and Text Editor window displaying the
CheckoutController.cs file, add the following using directive to the list
at the top of the file:
using DataTypes;
8. Add a public delegate type called CheckoutDelegate to the
CheckoutController class, as shown in the following in bold:
Click here to view code image
public class CheckoutController
{
    public delegate void CheckoutDelegate(Order order);
}
You can use this delegate type to reference methods that take an Order
parameter and that do not return a result. This just happens to match the
shape of the AuditOrder and ShipOrder methods of the Auditor and
Shipper classes.
9. Add a public delegate called CheckoutProcessing based on this delegate
type, like this:
Click here to view code image
public class CheckoutController
{
    public delegate void CheckoutDelegate(Order order);
    public CheckoutDelegate CheckoutProcessing = null;
}
10. Display the MainPage.xaml.cs file of the Delegates project in the Code
and Text Editor window and locate the requestPayment method (it is at
the end of the file). Cut this method from the MainPage class. Return to
the CheckoutController.cs file, and paste the requestPayment method
into the CheckoutController class, as shown in bold in the following:
Click here to view code image
public class CheckoutController
{
    public delegate void CheckoutDelegate(Order order);
    public CheckoutDelegate CheckoutProcessing = null;
    private bool requestPayment()
    {
      // Payment processing goes here
Download from finelybook PI:EMAIL
677
      // Payment logic is not implemented in this example
      // - simply return true to indicate payment has been
received return true;
    }
}
11. Add the StartCheckoutProcessing method shown below in bold to the
CheckoutController class:
Click here to view code image
public class CheckoutController
{
    public delegate void CheckoutDelegate(Order order);
    public CheckoutDelegate CheckoutProcessing = null;
    private bool requestPayment()
    {
      ...
    }
    public void StartCheckoutProcessing(Order order)
    {
        // Perform the checkout processing
        if (this.requestPayment())
        {
            if (this.CheckoutProcessing != null)
            {
                this.CheckoutProcessing(order);
            }
        }
    }
}
This method provides the checkout functionality previously
implemented by the CheckoutButtonClicked method of the MainPage
class. It requests payment and then examines the CheckoutProcessing
delegate; if this delegate is not null (it refers to one or more methods), it
invokes the delegate. Any methods referenced by this delegate will run
at this point.
12. In Solution Explorer, in the Delegates project, right-click the References
node and then click Add Reference.
13. In the Reference Manager - Delegates dialog box, in the left pane, click
Solution. In the middle pane, select the CheckoutService project, and
then click OK (leave the other projects selected as well).
Download from finelybook PI:EMAIL
678
14. Return to the MainPage.xaml.cs file of the Delegates project and add the
following using directive to the list at the top of the file:
using CheckoutService;
15. Add a private variable named checkoutController of type Checkout-
Controller to the MainPage class, and initialize it to null, as shown in
bold in the following:
Click here to view code image
public ... class MainPage : ...
{
    ...
    private Auditor auditor = null;
    private Shipper shipper = null;
    private CheckoutController checkoutController = null;
    ...
}
16. Locate the MainPage constructor. After the statements that create the
Auditor and Shipper components, instantiate the CheckoutController
component, as follows in bold:
Click here to view code image
public MainPage()
{
    ...
    this.auditor = new Auditor();
    this.shipper = new Shipper();
    this.checkoutController = new CheckoutController();
}
17. After the statement you just entered, add the following statements shown
in bold to the constructor:
Click here to view code image
public MainPage()
{
    ...
    this.checkoutController = new CheckoutController();
    this.checkoutController.CheckoutProcessing +=
this.auditor.AuditOrder;
    this.checkoutController.CheckoutProcessing +=
this.shipper.ShipOrder;
}
Download from finelybook PI:EMAIL
679
This code adds references to the AuditOrder and ShipOrder methods of
the Auditor and Shipper objects to the CheckoutProcessing delegate of
the CheckoutController object.
18. Find the CheckoutButtonClicked method. In the try block, replace the
code that performs the checkout processing (the if statement block) with
the statement shown here in bold:
Click here to view code image
private void CheckoutButtonClicked(object sender,
RoutedEventArgs e)
{
    try
    {
        // Perform the checkout processing
        this.checkoutController.StartCheckoutProcessing(this.order);
        // Display a summary of the order
        ...
    }
    ...
}
You have now decoupled the checkout logic from the components that
this checkout processing uses. The business logic in the MainPage class
specifies which components the CheckoutController should use.
Test the application
1. On the Debug menu, click Start Debugging to build and run the
application.
2. When the Wide World Importers form appears, select some items
(include at least one age-restricted item), and then click Checkout.
3. When the Order Placed message appears, make a note of the order
number, and then click Close.
4. Switch to File Explorer and move to the
%USERPROFILE%\AppData\Local\Packages\yyy\ LocalState folder,
where yyy is an identifier value that begins with the GUID for the
application that you noted previously. Verify that a new audit-
nnnnnn.xml file and dispatch-nnnnnn.txt file have been created, where
nnnnnn is the number that identifies the new order. Examine these files
Download from finelybook PI:EMAIL
680
and verify that they contain the details of the order.
5. Return to Visual Studio 2017 and stop debugging.
Lambda expressions and delegates
All the examples of adding a method to a delegate that you have seen so far
use the method’s name. For example, in the automated factory scenario
described earlier, you add the StopFolding method of the folder object to the
stopMachinery delegate like this:
Click here to view code image
this.stopMachinery += folder.StopFolding;
This approach is very useful if there is a convenient method that matches
the signature of the delegate. But what if the StopFolding method actually
had the following signature:
Click here to view code image
void StopFolding(int shutDownTime); // Shut down in the specified
number of seconds
This signature is now different from that of the FinishWelding and
PaintOff methods, and therefore you cannot use the same delegate to handle
all three methods. What do you do?
Creating a method adapter
One way around this problem is to create another method that calls
StopFolding, but that takes no parameters itself, like this:
Click here to view code image
void FinishFolding()
{
   folder.StopFolding(0); // Shut down immediately
}
You can then add the FinishFolding method to the stopMachinery
delegate in place of the StopFolding method, using the same syntax as before:
Click here to view code image
Download from finelybook PI:EMAIL
681
this.stopMachinery += folder.FinishFolding;
When the stopMachinery delegate is invoked, it calls FinishFolding,
which in turn calls the StopFolding method, passing in the parameter 0.
Note The FinishFolding method is a classic example of an adapter: a
method that converts (or adapts) a method to give it a different
signature. This pattern is very common and is one of the sets of patterns
documented in the book Design Patterns: Elements of Reusable Object-
Oriented Software by Erich Gamma, Richard Helm, Ralph Johnson, and
John Vlissides (Addison-Wesley Professional, 1994).
In many cases, adapter methods such as this are small, and it is easy to
lose them in a sea of methods, especially in a large class. Furthermore, the
method is unlikely to be called except for its use in adapting the StopFolding
method for use by the delegate. C# provides lambda expressions for
situations such as this. Lambda expressions are described in Chapter 18, and
there are more examples of them earlier in this chapter. In the factory
scenario, you can use the following lambda expression:
Click here to view code image
this.stopMachinery += (() => folder.StopFolding(0));
When you invoke the stopMachinery delegate, it will run the code defined
by the lambda expression, which will, in turn, call the StopFolding method
with the appropriate parameter.
Enabling notifications by using events
You have now seen how to declare a delegate type, call a delegate, and create
delegate instances. However, this is only half the story. Although you can
invoke any number of methods indirectly by using delegates, you still have to
invoke the delegate explicitly. In many cases, it would be useful to have the
Download from finelybook PI:EMAIL
682
delegate run automatically when something significant happens. For
example, in the automated factory scenario, it could be vital to be able to
invoke the stopMachinery delegate and halt the equipment if the system
detects that a machine is overheating.
The .NET Framework provides events, which you can use to define and
trap significant actions and arrange for a delegate to be called to handle the
situation. Many classes in the .NET Framework expose events. Most of the
controls that you can place on a form in a UWP app, and the Windows class
itself, use events to run code when, for example, the user clicks a button or
types something in a field. You can also declare your own events.
Declaring an event
You declare an event in a class intended to act as an event source. An event
source is usually a class that monitors its environment and raises an event
when something significant happens. In the automated factory, an event
source could be a class that monitors the temperature of each machine. The
temperature-monitoring class would raise a “machine overheating” event if it
detects that a machine has exceeded its thermal radiation boundary (that is, it
has become too hot). An event maintains a list of methods to call when it is
raised. These methods are sometimes referred to as subscribers. These
methods should be prepared to handle the “machine overheating” event and
take the necessary corrective action: shut down the machines.
You declare an event similarly to how you declare a field. However,
because events are intended to be used with delegates, the type of an event
must be a delegate, and you must prefix the declaration with the event
keyword. Use the following syntax to declare an event:
Click here to view code image
event delegateTypeName eventName
As an example, here’s the StopMachineryDelegate delegate from the
automated factory. It has been relocated to a class named
TemperatureMonitor, which provides an interface to the various electronic
probes monitoring the temperature of the equipment (this is a more logical
place for the event than the Controller class):
Click here to view code image
Download from finelybook PI:EMAIL
683
class TemperatureMonitor
{
    public delegate void StopMachineryDelegate();
    ...
}
You can define the MachineOverheating event, which will invoke the
stopMachineryDelegate,  like this:
Click here to view code image
class TemperatureMonitor
{
    public delegate void StopMachineryDelegate();
    public event StopMachineryDelegate MachineOverheating;
    ...
}
The logic (not shown) in the TemperatureMonitor class raises the
MachineOverheating event as necessary. (You will see how to raise an event
in an upcoming section.) Also, you add methods to an event (a process
known as subscribing to the event) rather than add them to the delegate on
which the event is based. You will look at this aspect of events next.
Subscribing to an event
Like delegates, events come ready-made with a += operator. You subscribe
to an event by using this += operator. In the automated factory, the software
controlling each machine can arrange for the shutdown methods to be called
when the MachineOverheating event is raised like this:
Click here to view code image
class TemperatureMonitor
{
    public delegate void StopMachineryDelegate();
    public event StopMachineryDelegate MachineOverheating;
    ...
}
...
TemperatureMonitor tempMonitor = new TemperatureMonitor();
...
tempMonitor.MachineOverheating += (() => { folder.StopFolding(0); });
tempMonitor.MachineOverheating += welder.FinishWelding;
tempMonitor.MachineOverheating += painter.PaintOff;
Notice that the syntax is the same as for adding a method to a delegate.
Download from finelybook PI:EMAIL
684
You can even subscribe by using a lambda expression. When the
tempMonitor.MachineOverheating event runs, it will call all the subscribing
methods and shut down the machines.
Unsubscribing from an event
Knowing that you use the += operator to attach a delegate to an event, you
can probably guess that you use the –= operator to detach a delegate from an
event. Calling the –= operator removes the method from the event’s internal
delegate collection. This action is often referred to as unsubscribing from the
event.