Term:
t (cid:70) v | (t, t ) | t t | fix t | if t then t else t
| t1 ⊔ t2 | t1 ⊓ t2 | t1 ⊑ t2
| return t | t ≫= t
| label t t | labelOf t | unlabel t
| getLabel | getClearance | lowerClearance t
| toLabeled t t | l
l{l t }
| store t t | fetch τ t t
τ (cid:70) Bool | () | Label | (τ , τ )
τ (cid:70) τ | (τ , τ ) | τ → τ | CLIO τ | Labeled τ
Ground Type:
Type:
Figure 2: Syntax for Clio values, terms, and types.
Similarly, before performing a side-effect visible to label l, LIO
ensures the current label flows to l (lcur ⊑ l).
Once the current label within a given computation is raised,
it can never be lowered. This can be very restrictive, since, for
example, as soon as confidential data is accessed by a computation,
the computation will be unable to output any public data. To address
this limitation, the toLabeled operation allows evaluation of an
LIO computation m in a separate compartment: toLabeled l m will
run m to completion, and produce a labeled value ‹v : l›, where
v is the result of computation m, and l is an over-approximation
of the final current label of m. Note that the current label of the
enclosing computation is not affected by executing toLabeled l m.
In general, given a labeled value ‹v :l›, label l is an upper bound on
the information conveyed by v. Labeled values can also be created
from raw values using operation label, and a labeled value can
be read into the current scope with operation unlabel. Creating a
labeled value with label l can be regarded as writing into a channel
at security level l. Similarly, observing (i.e., unlabeling) a labeled
value at l is analogous to reading from a channel at l.
LIO security guarantees. LIO provides a termination-insensitive
noninterference-based security guarantee [24]. Intuitively, if a pro-
gram is noninterfering with respect to confidentiality, then the
public outputs of a program reveal nothing about the confidential
inputs. More precisely, an attacker A that can observe inputs and
outputs with confidentiality label at most lA learns nothing about
any input to the program with label l such that l (cid:64) lA. Similarly,
a program is noninterfering for integrity if an attacker that can
control untrusted inputs cannot influence trusted outputs.
2.1 Clio
Clio calculus. Clio is formalized as a typed λ-calculus with call-
by-name evaluation, in the same style as LIO [54]. Figure 2 gives
the syntax of Clio values, terms, and types. In addition to standard
λ-calculus features, Clio includes several security-related exten-
sions that mirror those in LIO, and two operations for interacting
with the key-value store, namely store and fetch. As those primi-
tives have nontrivial semantics that involve the external storage,
we defer their discussion to Section 3. Security labels have type
Label and labeled values have type Labeled τ. Computation on
Session I2:  Information FlowCCS’17, October 30-November 3, 2017, Dallas, TX, USA1895LabelOf
Return
Bind
Label
Unlabel
⟨lcur, lclr | labelOf (‹t :l1›)⟩ −→ ⟨lcur, lclr | l⟩
⟨lcur, lclr | return t⟩ −→ ⟨lcur, lclr | tCLIO⟩
⟨lcur, lclr | t1CLIO ≫= t2⟩ −→ ⟨lcur, lclr | (t2 t1)⟩
lcur ⊑ l1
l1 ⊑ lclr
⟨lcur, lclr | label l1 v⟩ −→ ⟨lcur, lclr | return (‹v :l1›)⟩
lcur ⊔ l1 = l2
l2 ⊑ lclr
⟨lcur, lclr | unlabel (‹t2 :l1›)⟩ −→ ⟨l2, lclr | return t2⟩
ToLabeled
Reset
lcur ⊑ l1
l1 ⊑ lclr
⟨lcur, lclr | toLabeled l1 t⟩ −→ ⟨lcur, lclr | lcur
lclr
{l1 t }⟩
lcur ⊑ l2
⟨lcur, lclr | l1
l3
{l2 tCLIO }⟩ −→ ⟨l1, l3 | label l2 t⟩
Figure 3: Clio language semantics (selected rules).
l′{l′′
labeled values occur in the CLIO monad using the return and
(≫=) monadic operators. The nonterminals tCLIO and l
t } are
only generated by intermediate reduction steps and are not valid
source-level syntax. For convenience, we also distinguish values
that can be easily serialized as ground values, v. Ground values are
all values except functions and Clio computations. To facilitate our
extension of LIO with cryptography, we require labeled values to
contain only ground values.
Static type checking is performed in the standard way. We elide
the typing rules⊢ t : τ since they are mostly standard2. LIO enforces
information flow control dynamically, so it does not rely on its type
system to provide security guarantees.
The semantics is given by a small-step reduction relation −→
over Clio configurations (Figure 3)3. Configurations are of the form
⟨lcur, lclr | t⟩, where lcur is the current label and t is the Clio term
being evaluated. Label lclr is the current clearance and is an upper
bound on the current label lcur. The clearance allows a programmer
to specify an upper bound for information that a computation is
allowed to access. We write c −→ c′ to express that configuration
c can take a reduction step to configuration c′. We define −→∗
as the reflexive and transitive closure of −→. Given configuration
c = ⟨lcur, lclr | t⟩ we write PC(c) for lcur, the current label of c.
Rules return and bind encode the core monadic operations. The
intermediate value tCLIO is used to represent a Clio computation
which produces the term t, without any further effects on the con-
figuration. In rule label, the operation label l v returns a labeled
value with label l holding v (‹v :l›), provided that the current label
flows to l (lcur ⊑ l) and l flows to the current clearance (l ⊑ lclr).
Note that we force the second argument to be a ground value, i.e.
it should be fully normalized. Rule unlabel expresses that, given a
labeled value lv with label l, the operation unlabel lv returns the
value stored in lv and updates the current label to lcur⊔l, to capture
2Complete definitions given in the technical report [59].
3The rest can be found in the technical report [59].
the fact that a value with label l has been read, provided that this
new label flows to the current clearance (l ⊑ lclr). The operations
getLabel and getClearance can be used to retrieve the current label
and clearance respectively.
Rules toLabeled and reset deserve special attention. To evalu-
ate toLabeled l1 t, we first check that l1 is a valid target label
(lcur ⊑ l1 ⊑ lclr) and then wrap t in a compartment using the
{l1 t }, recording the current label and
special syntactic form lcur
lclr
clearance at the time of entering toLabeled and the target label of
the operation, l1. Evaluation proceeds by reducing t in the context of
the compartment to a value of the form t1CLIO. Next, the rule reset
{l1 t1CLIO }, first checking that the current
evaluates the term lcur
lclr
label flows to the target of the current toLabeled (lcur ⊑ l2). Finally,
the compartment is replaced by a normal label operation and the
current label and clearance are restored to their saved values.
DC Labels. LIO is parametric in the label format, but for the
purposes of this paper in Clio we use DC labels [53] with three
components to model confidentiality, integrity, and availability poli-
cies. A label ⟨lc , li , la⟩ represents a policy with confidentiality lc,
integrity li, and availability la. Information labeled with ⟨lc , li , la⟩
can be read by lc, is vouched for by li, and is hosted by la. We
write C(l ), I(l ), A(l ) for the confidentiality, integrity, and availabil-
ity components of l, respectively. Each component is a conjunction
of disjunctions of principal names, i.e., a formula in conjunctive
normal form. A disjunction A ∨ B in the confidentiality component
means that either A or B can read the data; in the integrity compo-
nent, it means that one of A or B vouch for the data, but none of
them take sole responsibility; in terms of availability, it means that
one of A or B can deny access to the data. Conjunctions A∧ B mean
that only A and B together can read the data (confidentiality), that
they jointly vouch for the data (integrity), or that they can jointly
deny access to the data (availability). Data may flow between differ-
ently labeled entities, but only those with more restrictive policies:
those readable, vouched for, or hosted by fewer entities. A label
⟨lc , li , la⟩ can flow to any label where the confidentiality compo-
nent is at least as sensitive than lc, the integrity component is no
more trustworthy than li, and the availability is no more than la,
i.e. l1 ⊑ l2 if and only if C(l2) =⇒ C(l1), I(l1) =⇒ I(l2), and
A(l1) =⇒ A(l2). We use logical implication because it matches
the intuitive meaning of disjunctions and conjunctions, e.g., data
readable by A ∨ B is less confidential than data readable only by
A, and data vouched for by A ∧ B is more trustworthy than data
vouched for only by A. In the rest of the paper, we consider only
Clio computations that work on labels of this form.
3 Interacting with an Untrusted Store
Clio extends LIO with a key-value store. The language is extended
with two new commands: store tk tv puts a labeled value tv in the
store indexed by key tk; fetch τ tk tv command fetches the entry
with key tk and if it cannot be fetched, returns the labeled value
tv. In both commands, tk must evaluate to a ground value and the
labeled value tv must evaluate to a labeled ground value with type
τ.
Session I2:  Information FlowCCS’17, October 30-November 3, 2017, Dallas, TX, USA1896Store
lcur ⊑ ℓ
lcur ⊑ l1
⟨lcur, lclr | store vk ‹v :l1›⟩ α−−→ ⟨lcur, lclr | return ()⟩
α = put ‹v :l1› at vk
Fetch-Valid
A(ℓ) ⊑A A(ld )
α = got τ ‹v :l› at vk
l ⊑ ld
⟨lcur, lclr | fetch τ vk ‹vd :ld›⟩ α−−→ ⟨lcur, lclr | return ‹v :ld›⟩
Fetch-Invalid
A(ℓ) ⊑A A(ld )
(α = nothing-at vk ) or (α = got τ ‹v :l› at vk and l ̸⊑ ld )
⟨lcur, lclr | fetch τ vk ‹vd :ld›⟩ α−−→ ⟨lcur, lclr | return ‹vd :ld›⟩
Figure 4: Clio language semantics (store and fetch rules).
Semantics for fetch and store are shown in Figure 4. We modify
the semantics to be a labeled transition system, where step relation
α−−→ is annotated with store events α. Store event α is one of:
• skip (representing no interaction with the store, i.e., an internal
step; we typically elide skip for clarity),
• put ‹v :l› at vk (representing putting a labeled ground value
‹v :l› indexed by vk),
• got τ ‹v :l› at vk (representing reading a labeled value from the
store indexed by vk), or
• nothing-at vk representing no value is indexed by vk.
Labeling transitions with store events allows us to cleanly fac-
tor out the implementation of the store, enabling us to easily use
either an idealized (non-cryptographic) store, or a store that uses
cryptography to help enforce security guarantees. We describe the
semantics of store events in both these settings later.
We associate a label ℓ with the store. Intuitively, store level
ℓ describes how trusted the store is: it represents the inherent
protections provided by the store and the inherent trust by the store
in Clio. For example, the store may be behind an organization’s
firewall so data is accessible only to organization members due to
an external access control mechanism (i.e., the firewall), so Clio
can safely store the organization’s information there. Dually, there
may be integrity requirements that Clio is trusted to uphold when
writing to the store. For example, the store may be used as part of a
larger system that uses the store to perform important operations
(e.g., ship customer orders). Thus the integrity component of the
store label is a bound on the untrustworthiness of information that
Clio should write to the store (e.g., Clio should not put unendorsed
shipping requests in the store). The availability component of the
store label specifies a bound on who is able to corrupt information in
the store and thus make it unavailable. (Note that we are concerned
with information availability rather than system availability.) In
general, this would describe all the principals who have direct and
indirect write-access to the store.
Rule Store (Figure 3) is used to put a labeled value ‹v :l› in the
store, indexed by key vk. We require that the current label lcur is
bounded above by store level ℓ. In terms of confidentiality, this
means that any information that may be revealed by performing
the store operation (i.e., lcur) is permitted to be learned by users
of the store. For integrity, the decision to place this value in the
store (possibly overwriting a previous value) should not be influ-
enced by information below the integrity requirements of the store.
For availability, the information should not be derived from less
available sources than the store’s availability level.
Additionally, we require the current label to flow to l, the label
of the value that is being stored (i.e., lcur ⊑ l1). Intuitively, this is
because an entity that learns the labeled value also learns that the
labeled value was put in the store. Current label lcur is an upper
bound on the information that led to the decision to perform the
store, and l1 bounds who may learn the labeled value.
For command fetch τ vk ‹vd :ld›, labeled value ‹vd :ld› serves
double duty. First, if the store cannot return a suitable value (e.g., be-
cause there is no value indexed by key vk, or because cryptographic
signature verification fails), then the fetch command evaluates to
the default labeled value ‹vd :ld› (which might be an error value
or a suitable default). Second, label ld specifies an upper bound on
the label of any value that may be returned: if the store wants to
return a labeled value ‹v :l› where l ̸⊑ ld, then the fetch command
evaluates to ‹vd :ld› instead. This allows programmers to specify
bounds on information they are willing to read from the store.
Rule Fetch-Valid is used when a labeled value is successfully
fetched from the store. Store event got τ ‹v :l› at vk indicates that
the store was able to return labeled value ‹v :l› indexed by the key
vk. Rule Fetch-Invalid is used when a labeled value cannot be found
indexed at the index requested or it does not safely flow to the
default labeled value (i.e., it is too secret, too untrustworthy or not
available enough), and causes the fetch to evaluate to the specified
default labeled value. Since the label of the default value ld will be
used for the label of the fetched value in general, the availability of
the store level should be bounded above by the availability of the
label of the default value (i.e., A(ℓ) ⊑A A(ld )) in both rules, as the
label of the fetched value should reflect the fact that anyone from