### 优化后的文本

#### 使用 GDB 和 QEMU 监视器检查内存
尽管 GDB 可以通过虚拟地址访问 QEMU 的内存，它也常被用来在配置虚拟内存时检查物理内存。请参阅实验工具指南中关于 [QEMU 监视器命令](https://sipb.mit.edu/iap/6.828/labguide/#qemu) 的部分，特别是 `xp` 命令，它可以用于检查物理内存。要访问 QEMU 监视器，在终端中按下 `Ctrl-a c`（使用相同的绑定返回到串行控制台）。

利用 QEMU 监视器的 `xp` 命令和 GDB 的 `x` 命令来检查相应的物理内存和虚拟内存，确保两者显示的数据一致。

我们修改过的 QEMU 版本提供了一个非常有用的 `info pg` 命令：该命令可以展示当前页表的详细信息，包括所有已映射的内存范围、权限以及标志。原版 QEMU 也提供了 `info mem` 命令，用于显示已映射的虚拟内存范围及其权限。

#### 内存引用与地址类型
在 CPU 运行于保护模式下（这是在 `boot/boot.S` 中启动的第一步），代码无法直接使用线性地址或物理地址。所有的内存引用都被解释为虚拟地址，并由 MMU 转换，这意味着 C 语言中的指针都是虚拟地址。例如，在物理内存分配器中，JOS 经常需要维护一个难以理解的值或整数作为地址，而无需反向引用。这些地址有时是虚拟地址，有时是物理地址。为了在代码中区分它们，JOS 源文件定义了两种类型：`uintptr_t` 表示虚拟地址，`physaddr_t` 表示物理地址。这两种类型实际上是 32 位整数 (`uint32_t`) 的同义词，因此编译器不会阻止你将一种类型的数据赋给另一种类型。由于它们都是整数类型而不是指针类型，尝试反向引用它们会导致编译错误。

JOS 内核可以通过将其转换为指针类型来反向引用 `uintptr_t` 类型。相反，内核不能反向引用 `physaddr_t`，因为所有的内存引用都由 MMU 转换。如果你将 `physaddr_t` 转换为指针类型并反向引用它，虽然硬件会将其解释为虚拟地址，但你不会得到预期的内存位置。

| C 类型 | 地址类型 |
| --- | --- |
| `T*` | 虚拟 |
| `uintptr_t` | 虚拟 |
| `physaddr_t` | 物理 |

**问题 1:**
假设下面的 JOS 内核代码是正确的，那么变量 `x` 应该是什么类型？`uintptr_t` 还是 `physaddr_t`？

![](/data/attachment/album/201811/06/161734c90qt09q5949mqz1.jpg)

#### 物理地址与虚拟地址的转换
JOS 内核有时需要读取或修改只知道其物理地址的内存。例如，添加一个映射到页表可能需要分配物理内存来存储页目录并初始化它们。然而，内核像其他软件一样，不能跳过虚拟地址转换，因此不能直接加载和存储物理地址。为此，JOS 将从物理地址 `0` 开始的所有物理地址重映射到虚拟地址 `0xf0000000` 处，以便内核能够读写这些内存。要将物理地址转换为内核可以实际读写的虚拟地址，必须将 `0xf0000000` 添加到物理地址上，以找到重映射区域中的相应虚拟地址。你应该使用 `KADDR(pa)` 来执行这个操作。

JOS 内核还需要能够通过给定的内核数据结构中存储的虚拟地址找到内存中的物理地址。内核全局变量和通过 `boot_alloc()` 分配的内存位于从 `0xf0000000` 开始的重映射区域内。因此，要将这些区域中的虚拟地址转换为物理地址，只需简单地减去 `0xf0000000` 即可。你应该使用 `PADDR(va)` 来执行这个操作。

#### 引用计数
在后续实验中，你可能会遇到多个虚拟地址（或多个环境下的地址空间）同时映射到同一物理页面的情况。你将在 `struct PageInfo` 数据结构中的 `pp_ref` 字段记录每个物理页面的引用计数器。如果某个物理页面的引用计数器为 0，表示该页面已被释放，因为它不再被使用。通常情况下，该计数器应等于所有页表中物理页面出现在 `UTOP` 之下的次数（`UTOP` 之上的映射大多是在引导时由内核设置的，并且永远不会被释放，因此不需要引用计数器）。我们也使用它来跟踪指向页目录页的指针数量，即页目录到页表页的引用数量。

使用 `page_alloc` 时需注意，它返回的页面引用计数总是 0。因此，一旦对返回的页面进行了某些操作（如将其插入页表），就应该增加 `pp_ref`。有时这需要通过其他函数（如 `page_insert`）来处理，有时则直接调用 `page_alloc`。

#### 页表管理
接下来，你需要编写一套管理页表的代码，包括插入和删除线性地址到物理地址的映射，并在需要时创建页表。

**练习 4:**

在文件 `kern/pmap.c` 中，实现以下函数：

- `pgdir_walk()`
- `bootmapregion()`
- `page_lookup()`
- `page_remove()`
- `page_insert()`

`check_page()` 函数会在 `mem_init()` 中被调用，测试你的页表管理函数。在继续下一步之前，请确保它成功运行。

### 第 3 部分：内核地址空间
JOS 将处理器的 32 位线性地址空间分为两部分：用户环境（进程）和内核。用户环境控制低位部分的内容，而内核始终完全控制高位部分。分割线在 `inc/memlayout.h` 中通过符号 `ULIM` 定义，为内核保留了约 256MB 的虚拟地址空间。这就是为什么我们在实验 1 中为内核选择了一个高位链接地址的原因：如果不这样做，内核的虚拟地址空间将不足以同时映射到用户空间。

你可以在 `inc/memlayout.h` 中找到一张图表，有助于理解 JOS 内存布局，这对本实验及后续实验都很有用。

#### 权限与故障隔离
由于内核和用户的内存都在各自的地址空间中，我们需要在 x86 页表中使用权限位，以允许用户代码仅访问其所属地址空间的部分。否则，用户代码中的错误可能会覆盖内核数据，导致系统崩溃或其他奇怪的问题；用户代码还可能窥探其他环境的私有数据。

对于 `ULIM` 以上的内存，用户环境没有任何权限，只有内核才能读写这部分内存。对于 `[UTOP, ULIM]` 地址范围，内核和用户具有相同的权限：可以读取但不能写入。这个地址范围用于向用户环境暴露某些只读的内核数据结构。低于 `UTOP` 的地址空间供用户环境使用；用户环境将为访问这些内核设置权限。

#### 初始化内核地址空间
现在，你需要配置 `UTOP` 以上的地址空间：内核部分的地址空间。`inc/memlayout.h` 展示了你将使用的布局。请编写相关代码，以配置线性地址到物理地址的映射。

**练习 5:**

完成 `mem_init()` 中调用 `check_page()` 后缺失的代码。

此时，你的代码应该通过 `check_kern_pgdir()` 和 `check_page_installed_pgdir()` 的检查。

**问题:**

1. 在此时刻，页目录中的条目（行）是什么？它们映射的虚拟地址基址是什么？以及它们映射到哪里？换句话说，尽可能多地填写下表：

| 条目 | 虚拟地址基址 | 指向（逻辑上） |
| --- | --- | --- |
| 1023 | ? | 物理内存顶部 4MB 的页表 |
| 1022 | ? | ? |
| . | ? | ? |
| . | ? | ? |
| . | ? | ? |
| 2 | 0x00800000 | ? |
| 1 | 0x00400000 | ? |
| 0 | 0x00000000 | [见下一问题] |

2. 我们将内核和用户环境放在相同的地址空间中。为什么用户程序不能读取和写入内核内存？有什么特殊机制保护内核内存？

3. 该操作系统能支持的最大物理内存是多少？为什么？

4. 如果我们确实拥有最大数量的物理内存，有多少开销用于管理内存？这个开销可以减少吗？

5. 复习 `kern/entry.S` 和 `kern/entrypgdir.c` 中的页表设置。一旦我们启用分页，EIP 仍是一个很小的数字（略大于 1MB）。在什么情况下，我们会转而在 KERNBASE 之上的 EIP 上运行？当我们启用分页并开始在 KERNBASE 之上运行 EIP 时，是什么让我们能够在很低的 EIP 上继续运行？为什么这种转变是必要的？

#### 其他地址空间布局选项
在 JOS 中使用的地址空间布局并不是唯一的选择。操作系统可以将内核映射到低位线性地址，而为用户进程保留高位线性地址。然而，x86 内核通常不采用这种方法，因为 x86 向后兼容模式之一（称为“虚拟 8086 模式”）不可改变地在处理器使用线性地址空间的最低部分，所以内核映射到这里将无法使用。

尽管很困难，但设计这样的内核是有可能的，即不为处理器自身保留任何固定的线性地址或虚拟地址空间，从而有效地允许用户级进程不受限制地使用整个 4GB 的虚拟地址空间 —— 同时还要充分保护内核和其他进程之间的相互保护！

将内核的内存分配系统推广到支持各种大小的页，从 4KB 到某个合理的最大值。你需要有一种方法，将较大的分配单位按需分割为较小的单位，以及在需要时将多个较小的单位合并为较大的单位。思考一下在这种系统中可能出现的问题。

实验至此结束。确保你通过了所有测试，并记得在 `answers-lab2.txt` 中写下上述问题的答案。提交你的更改（包括添加 `answers-lab2.txt` 文件），并在 `lab` 目录下输入 `make handin` 提交实验。

---

via:
作者：[Mit](https://sipb.mit.edu/iap/6.828/lab/lab2/)  
译者：[qhwdw](https://github.com/qhwdw)  
校对：[wxy](https://github.com/wxy)  
本文由 [LCTT](https://github.com/LCTT/TranslateProject) 原创编译，[Linux中国](https://linux.cn/) 荣誉推出