尽管修复软件 bug 时，开发者经常会在提交日志中留下关于这个 bug 的原始的重要信息；例如，为什么会产生 bug，以及怎么去修复 bug。我们利用很多信息去分类 bug，与 Tan 的 *et al* 类似。    13  ，   24 
首先，我们基于 bug 的  原因   Cause  和  影响   Impact  进行分类。\_ 原因 \_ 进一步分解为不相关的错误子类：算法方面的、并发方面的、内存方面的、普通编程错误，和未知的。bug 的 *影响* 也分成四个不相关的子类：安全、性能、失败、和其它的未知类。因此，每个 bug 修复提交也包含原因和影响的类型。[表 5](http://deliveryimages.acm.org/10.1145/3130000/3126905/t5.jpg) 展示了描述的每个 bug 分类。这个类别分别在两个阶段中被执行：
[![t5.jpg](/data/attachment/album/201806/28/180109an4zzypzor8n4won.jpg)](http://deliveryimages.acm.org/10.1145/3130000/3126905/t5.jpg)
*表 5 bug 分类和在整个数据集中的描述*
**(1) 关键字搜索** 我们随机选择了 10% 的 bug 修复信息，并且使用一个基于关键字的搜索技术去对它们进行自动化分类，作为可能的 bug 类型。我们对这两种类型（原因和影响）分别使用这个注释。我们选择了一个限定的关键字和习惯用语集，如 [表 5](http://deliveryimages.acm.org/10.1145/3130000/3126905/t5.jpg) 所展示的。像这种限定的关键字和习惯用语集可以帮我们降低误报。
**(2) 监督分类** 我们使用前面步骤中的有注释的 bug 修复日志作为训练数据，为监督学习分类技术，通过测试数据来矫正，去对剩余的 bug 修复信息进行分类。我们首先转换每个 bug 修复信息为一个词袋（LCTT 译注：bag-of-words，一种信息检索模型）。然后，删除在所有的 bug 修复信息中仅出现过一次的词。这样减少了具体项目的关键字。我们也使用标准的自然语言处理技术来解决这个问题。最终，我们使用支持向量机（LCTT 译注：Support Vector Machine，缩写为 SVM，在机器学习领域中，一种有监督的学习算法）去对测试数据进行分类。
为精确评估 bug 分类器，我们手动注释了 180 个随机选择的 bug 修复，平均分布在所有的分类中。然后，我们比较手动注释的数据集在自动分类器中的结果。最终处理后的，表现出的精确度是可接受的，性能方面的精确度最低，是 70%，并发错误方面的精确度最高，是 100%，平均是 84%。再次运行，精确度从低到高是 69% 到 91%，平均精确度还是 84%。
我们的 bug 分类的结果展示在 [表 5](http://deliveryimages.acm.org/10.1145/3130000/3126905/t5.jpg) 中。大多数缺陷的原因都与普通编程错误相关。这个结果并不意外，因为，在这个分类中涉及了大量的编程错误，比如，类型错误、输入错误、编写错误、等等。我们的技术并不能将在任何（原因或影响）分类中占比为 1.4% 的 bug 修复信息再次进行分类；我们将它归类为未知。
#### 2.5 统计方法
我们使用回归模型对软件项目相关的其它因素中的有缺陷的提交数量进行了建模。所有的模型使用 负二项回归   negative binomial regression （缩写为 NBR）（LCTT 译注：一种回归分析模型） 去对项目属性计数进行建模，比如，提交数量。NBR 是一个广义的线性模型，用于对非负整数进行响应建模。   4 
在我们的模型中，我们对每个项目的编程语言，控制几个可能影响最终结果的因素。因此，在我们的回归分析中，每个（语言/项目）对是一个行，并且可以视为来自流行的开源项目中的样本。我们依据变量计数进行对象转换，以使变量保持稳定，并且提升了模型的适用度。   4  我们通过使用 AIC 和 Vuong 对非嵌套模型的测试比较来验证它们。
去检查那些过度的多重共线性（LCTT 译注：多重共线性是指，在线性回归模型中解释变量之间由于存在精确相关关系或高度相关关系而使模型估计失真或难以估计准确。）并不是一个问题，我们在所有的模型中使用一个保守的最大值 5，去计算每个依赖的变量的膨胀因子的方差。   4  我们通过对每个模型的残差和杠杆图进行视觉检查来移除高杠杆点，找出库克距离（LCTT 译注：一个统计学术语，用于诊断回归分析中是否存在异常数据）的分离值和最大值。
我们利用 *效果* ，或者 *差异* ，编码到我们的研究中，以提高编程语言回归系数的表现。   4  加权的效果代码允许我们将每种编程语言与所有编程语言的效果进行比较，同时弥补了跨项目使用编程语言的不均匀性。   23  去测试两种变量因素之间的联系，我们使用一个独立的卡方检验（LCTT 译注：Chi-square，一种统计学上的假设检验方法）测试。   14  在证实一个依赖之后，我们使用 Cramer 的 V，它是与一个 `r × c` 等价的正常数据的 `phi(φ)` 系数，去建立一个效果数据。
### 3 结果
我们从简单明了的问题开始，它非常直接地解决了人们坚信的一些核心问题，即：
#### 问题 1：一些编程语言相比其它语言来说更易于出现缺陷吗？
我们使用了回归分析模型，去比较每个编程语言对所有编程语言缺陷数量平均值的影响，以及对缺陷修复提交的影响（查看 [表 6](http://deliveryimages.acm.org/10.1145/3130000/3126905/t6.jpg)）。
[![t6.jpg](/data/attachment/album/201806/28/180110c9aauni19ij95h7j.jpg)](http://deliveryimages.acm.org/10.1145/3130000/3126905/t6.jpg)
*表 6. 一些语言的缺陷要少于其它语言*
我们包括了一些变量，作为对明确影响反应的控制因子。项目 年龄   age 也包括在内，因为，越老的项目生成的缺陷修复数量越大。 提交   commits 数量也会对项目反应有轻微的影响。另外，从事该项目的 开发人员   dev 的数量和项目的原始 大小   size ，都会随着项目的活跃而增长。
上述模型中估算系数的大小和符号（LCTT 译注：指 “+”或者“-”）与结果的预测因子有关。初始的四种变量是控制变量，并且，我们对这些变量对最终结果的影响不感兴趣，只是说它们都是积极的和有意义的。语言变量是指示变量，是每个项目的变化因子，该因子将每种编程语言与所有项目的编程语言的加权平均值进行比较。编程语言系数可以大体上分为三类。第一类是，那些在统计学上无关紧要的系数，并且在建模过程中这些系数不能从 0 中区分出来。这些编程语言的表现与平均值相似，或者它们也可能有更大的方差。剩余的系数是非常明显的，要么是正的，要么是负的。对于那些正的系数，我们猜测可能与这个编程语言有大量的缺陷修复相关。这些语言包括 C、C++、Objective-C、Php，以及 Python。所有的有一个负的系数的编程语言，比如 Clojure、Haskell、Ruby，和 Scala，暗示这些语言的缺陷修复提交可能小于平均值。
应该注意的是，虽然，从统计学的角度观察到编程语言与缺陷之间有明显的联系，但是，大家不要过高估计编程语言对于缺陷的影响，因为，这种影响效应是非常小的。异常分析的结果显示，这种影响小于总异常的 1%。
[![ut1.jpg](/data/attachment/album/201806/28/180111w61eo2zgbts86s6s.jpg)](http://deliveryimages.acm.org/10.1145/3130000/3126905/ut1.jpg)
我们可以这样去理解模型的系数，它代表一个预测因子在所有其它预测因子保持不变的情况下，这个预测因子一个 单位   unit 的变化，所反应出的预期的响应的对数变化；换句话说，对于一个系数 β i ，在 β i 中一个单位的变化，产生一个预期的 e β   i  响应的变化。对于可变因子，这个预期的变化是与所有编程语言的平均值进行比较。因此，如果对于一定数量的提交，用一个处于平均值的编程语言开发的特定项目有四个缺陷提交，那么，如果选择使用 C++ 来开发，意味着我们预计应该有一个额外的（LCTT 译注：相对于平均值 4，多 1 个）缺陷提交，因为 e 0.18 × 4 = 4.79。对于相同的项目，如果选择使用 Haskell 来开发，意味着我们预计应该少一个（LCTT 译注：同上，相对于平均值 4）缺陷提交。因为， e −0.26 × 4 = 3.08。预测的精确度取决于剩余的其它因子都保持不变，除了那些微不足道的项目之外，所有的这些都是一个极具挑战性的命题。所有观察性研究都面临类似的局限性；我们将在第 5 节中详细解决这些事情。
**结论 1：一些编程语言相比其它编程语言有更高的缺陷相关度，不过，影响非常小。**
在这篇文章的剩余部分，我们会在基本结论的基础上详细阐述，通过考虑不同种类的应用程序、缺陷、和编程语言，可以进一步深入了解编程语言和缺陷倾向之间的关系。
软件 bug 通常落进两种宽泛的分类中：