recv (Unix style)
Table 2: Elapse times for the micro-benchmarks and the
Unix-style concurrent server (see Section 3). No authen-
tication is performed in any of these cases. The time
speciﬁed are all in micro seconds.
5.4.1 System call overhead (no authentication)
Our ﬁrst measurements determine the authorization over-
heads for netAuth, by using a light weight authentication
with minimal overhead. The authorization mechanism
limits which users can use the service, it is implemented
outside of application.
The measurements are given in Table 2, are of netAuth
vs. unmodiﬁed Linux:
• the time to perform a bind by a server increased
by 12.5% due to the overhead of doing the autho-
rization checks.
• the time to complete a connect (as measured) on
the client-side increased by 14.28%, due to client-
side and server-side authorization checks. The
elapsed time includes a round trip packet time.
• the
time
to
do
is
(The
client
a connect-send-recv
considered
(as measured) on the
server must do a accept-
next.
fork-setuid-recv-send).
send
and recv are 128 bytes of data. For the UNIX case,
the total time was about 145 µ seconds while for the
NetAuth case the time was about 157 µ seconds, an
overhead of 8.27%. The most costly operation is
the fork performed at the server to create a new
per-user process.
The
We note that these overheads are best case [26], normally
latency issues are higher. Moreover, no performance tun-
ing has yet been done on the netAuth implementation.
5.4.2 Using netAuth authentication
This section describes the case of a server in which the
process for user Ui satisﬁes all of the requests from Ui,
234 
17th USENIX Security Symposium 
USENIX Association
for a particular service (as described in Section 5). There
does not exist a comparable scenario in UNIX. Hence,
we report the latencies observed on the client side in Ta-
ble 3.
Connection
netAuth
(with auth.)
Linux
(w/o auth.)
ﬁrst
successive
4200 µs
67 µs
147 µs
147 µs
Table 3: Elapse times observed on the client side to per-
form a connect-send-recv. The netAuth connec-
tions are established with user authentication. Successive
netAuth connections are to the same per-user server pro-
cess created by the ﬁrst connection on the server. The
UNIX connections are established without user authenti-
cation.
For the ﬁrst connection, using netAuth authentication
mechanisms, a new connection results in the following
set of actions: (1) on the client, the kernel requests an
authenticator from the user-space daemon; (2) the client
generates the authenticator and sends it to the server
where it is veriﬁed; (3) there is a RTT for sending the au-
thenticator to the server and receiving response from the
server; (4) there may be context-switch times (between
client process and authentication daemon); and (5) there
may scheduling delays. The costliest operation by far is
the cryptographic signing of the authenticator.
All subsequent connections on behalf of the same user
run much faster because they re-use the same server pro-
cess and fast authentications. In comparison, the elapse
time for the UNIX case is the same for all cases because
there are no schemes for a client to re-use a previously
created per-user process. The values for UNIX shown in
the Table are without authentication overhead.
5.4.3 Server throughput
We next consider server throughput in terms of new con-
nections.
In netAuth, although the ﬁrst authentication
must be signed, successive authentications require only a
very fast cryptographic hash. From table 1, the service-
based veriﬁcation of signatures takes only 80µseconds.
Hence, a single core can perform authentication for
45,000,000 users per hour assuming authentications are
cached for one hour. We believe that such performance
levels eliminate the need to consider weaker authentica-
tion mechanisms, even for very high volume services.
5.5 Alternative implementations
Our ﬁrst implementation, which is described here, is a
kernel-level implementation. Of course, we would like
the APIs described here to be available on other systems
without kernel modiﬁcations, particularly for those OSes
for which the source code is not available.
We consider here only the client side issues as we
would like netAuth services to be usable from any op-
erating system. (Server OS, on the other hand, is under
the control of the service provider.)
In section 6.2 we
describe a proxy implementation which uses netAuth,
but which could be easily extended into one which im-
plemented netAuth at the protocol level from user space
rather than using netAuth APIs.
6 Porting applications to netAuth
To show the effectiveness of netAuth we ported a UBNS
service. We have not yet attempted to port a service
which is not UBNS organized (such as Apache), as that
is a far more difﬁcult problem. We chose an applica-
tion, dovecot, which supports both privilege separation
and UBNS.
Process name
master
auth
login
imap
executable name
dovecot
dovecot-auth
imap-login
pop3-login
imap
user ID
root
root
dovecot
dovecot
U
Table 4: Dovecot processes and their respective user
ID’s. Here U refers to the user ID of the (remote) user
whose is accessing her mail.
Dovecot is an open source IMAP and POP mail server
(and is included in Linux distributions such as Debian
and Ubuntu). Users can access dovecot-based services
remotely using a Mail Viewer Agent (MVA) such as Thun-
derbird or Outlook. The MVA on the client communicates
with dovecot using the IMAP or POP protocols over SSL
or unencrypted connections.
Dovecot was built with security as a primary goal.
Since January 2006, its developer has offered an as-yet-
uncollected reward of 1000C for the ﬁrst provable se-
curity hole9. To support both privilege separation and
UBNS, dovecot has four process types, running under
root, dovecot pseudo user, and the user U retrieving her
mail, as shown in Table 4.
Table 5, shows the code organization of the dovecot
distribution supporting IMAP (v1.0.9)10. Dovecot also
uses pam, crypto, and ssl libraries which are not included
in these line counts. The source distribution to support
IMAP is 24,628 lines of code, of which 9,30711 (37.8%)
are associated with authentication and encryption. The
port consisted of removing this code, and copying over
less than 1,000 lines from master (conﬁguration and
USENIX Association  
17th USENIX Security Symposium 
235
the concurrent server loop) and login (the initial hand-
shake code) to imap.
The port reduces the number of process types from
four to one. With a traditional Unix authorization model,
the port still requires root to bind to port 143 and to do
setuid; but unlike the pre-port version, our imap process
never reads user input while running as root and thus is
not subject as root to buffer overﬂow attack. (The privi-
leges can be still reduced further using netAuth’s autho-
rization model).
When implementing a imap service from scratch,
only 4 netAuth speciﬁc lines would be needed to pro-
vide authentication and encryption over that required for
an unauthenticated service.
6.1 Dovecot before and after
The standard version of dovecot is more complex be-
cause of the privilege separation mechanism and espe-
cially the complexity of using standard authentication
and cryptographic mechanisms. We describe ﬁrst the
processes and then later the operations needed to retrieve
IMAP mail in standard dovecot.
6.1.1 Standard dovecot
The dovecot distribution is composed of the following
processes:
master process starts the auth process and n (by de-
fault, 3) login processes. The master process is
also responsible for the creation of an imap process
after a successful authentication.
auth process authenticates new users for the login
process (over a UNIX socket). The auth pro-
cess also veriﬁes successful authentications to the
master before it creates a mail process.
login process listens on the appropriate port (e.g., 143
for IMAP) for new connections. Once a connec-
tion is established it negotiates with the MVA pro-
cess to initialize the connection (sending server ca-
pabilities, setting up SSL, etc.) and requests authen-
tication of the user. Upon successful authentication,
the login process requests the master process to
create a new imap process and then exits.
imap process receives the socket descriptor over a
UNIX socket from the login process. The imap
process then communicates with the remote MVA to
access the user’s mailbox on the server.
1. Messages 1a and 1b establish the initial connection
between the MVA and dovecot. During this step,
the MVA requests and receives the server capabili-
ties (not shown in the ﬁgure).
2. authentication step (shown as messages 2a-2e and
action 2f). (a) The MVA sends the user’s authentica-
tion information as part of a LOGIN message. (b)
In response, the login process requests the auth
process to authenticate the user (c) The login
process request the auth process to authenticate,
(d) on successful authentication the login process
sends a response back to the MVA and (e) requests
the master process to create a new imap pro-
cess. (f) the master, after verifying a successful
authentication with the auth process, creates the
new mail process running on behalf of user Uk.
3. The imap process then services the MVA’s future
requests.
6.1.2 Porting dovecot to netAuth
The porting of dovecot to netAuth consists of (a) remov-
ing code, (b) moving some code into the imap process
and (c) removing three of the four processes. A dove-
cot process ported to netAuth is not expected to per-
form the following functions: message encryption us-
ing OpenSSL, GNU-TLS or the like; user authentication;
performing the complex setuid() operation and re-
lated code to ensure that the process does not have any
privileged left-overs (in the form of ﬁle descriptors) in
the unprivileged process. Hence, code for these secu-
rity sensitive operations need not be implemented by the
dovecot executable and can be removed. Thus, summa-
rizing the dovecot port to netAuth:
• the auth process (and its code) is eliminated com-
pletely as the user authentication is performed by
the OS as part of connection establishment.
• from the master process, only the code to bind to
the privileged port and to conﬁgure a new mail pro-
cess with the appropriate set of environment vari-
ables is retained. (Dovecot passes conﬁguration in-
formation to the imap process as environment vari-
ables)
• from the login process, only the initialization of a
new connection (1a and 1b in Figure 4) is retained.
• the core functionality of accessing and maintaining
mailboxes in the imap process is retained.
Figure 4 shows the sequence of events that are nec-
essary to create a new imap process to service requests
from the MVA.
Thus, the dovecot port to netAuth runs as a single pro-
cess type (following the design for a concurrent server
implementation shown in Figure 2). The master, auth
236 
17th USENIX Security Symposium 
USENIX Association
directory
master
auth
imap-login
imap
lib-auth
lib
login-common
lib-imap
lib-settings
lib-ntlm
lib-sql
lib-dict
lib-storage
lib-mail
total
lines
total
of code
2,460
5,469
484
3,456
490
6,268
1,138
1,069
101
304
882
470
574
1,463
24,628
process
master
auth
login
imap
libraries
dovecot’s
used
lib
lib, lib-settings,
lib-ntlm, lib-sql
lib, login-common,
lib-auth, lib-imap
lib, lib-dict, lib-mail,
lib-imap, lib-storage
lines
total
of code
8,728
13,024
9,449
13,300
dynamic
libraries
pam
crypto
ssl
crypt
ssl
Table 5: Table with lines of code in the various directories in dovecot. The command ‘cat *.c *.h | grep
";" | wc -l’ was used to determine this count.
Client
Server
Auth
Master
2
b
:
a
2
c
:
u
t
h
V
e
a
l
i
d
n
t
i
c
u
s
e
r
a
t
e
U
U
k
k
process
mail
2e:create
Mail
Viewer
Agent
1a:SYN
1b:OK Dovecot Ready.
2a:LOGIN Uk
2d:OK Logged in.
2f:fork,
setuid
Login1
Loginn
3:access mailbox
imap
U1
imap