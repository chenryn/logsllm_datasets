title:Bringing Balance to the Force: Dynamic Analysis of the Android Application
Framework
author:Abdallah Dawoud and
Sven Bugiel
Bringing Balance to the Force: Dynamic Analysis of
the Android Application Framework
Abdallah Dawoud
Sven Bugiel
CISPA Helmholtz Center for Information Security
CISPA Helmholtz Center for Information Security
abdallah.dawoud@cispa.saarland
bugiel@cispa.saarland
Abstract—Android’s  application  framework  plays  a  crucial 
part  in  protecting  users’  private  data  and  the  system  integrity. 
Consequently,  it  has  been  the  target  of  various  prior  works 
that  analyzed  its  security  policy  and  enforcement.  Those  works 
uncovered different security problems, including incomplete doc-
umentation, permission re-delegation within the framework, and 
inconsistencies  in  access  control.  However,  all  but  one  of  those 
prior  works  were  based  on  static  code  analysis.  Thus,  their 
results provide a one-sided view that inherits the limitations and 
drawbacks  of  applying  static  analysis  to  the  vast,  complex  code 
base of the application framework. Even more, the performances 
of  different  security  applications—including  malware  classiﬁca-
tion and least-privileged apps—depend on those analysis results, 
but  those  applications  are  currently  tarnished  by  imprecise  and 
incomplete  results  as  a  consequence  of  this  imbalanced  analysis 
methodology.  To  complement  and  reﬁne  this  methodology  and 
consequently  improve  the  applications  that  are  dependent  on  it, 
we  add  dynamic  analysis  of  the  application  framework  to  the 
current research landscape and demonstrate the necessity of this 
move for improving the quality of prior results and advancing the 
ﬁeld.  Applying  our  solution,  called  DYNAMO,  to  four  prominent 
use-cases from the literature and taking a synoptical view on the 
results,  we  verify  but  also  refute  and  extend  the  existing  results 
of  prior  static  analysis  solutions.  From  the  manual  investigation 
of the root causes of discrepancies between results, we draw new 
insights and expert knowledge that can be valuable in improving 
both  static  and  dynamic  testing  of  the  application  framework.
I. 
INTRODUCTION
Android provides apps with rich features, such as location 
tracking,  taking  pictures,  sensing,  or  access  to  managed  user 
data.  Those  features  are  offered  to  app  developers  through 
Android’s application framework API and are implemented by 
system  services  and  system  apps.  The  application  framework 
is  responsible  for  controlling  access  to  system  resources  and 
user  data,  and  consequently  plays  a  crucial  role  in  protecting 
system integrity and user privacy. This access control is based 
on  the  privileges  (”permissions”),  identity,  or  other  attributes 
of  calling  processes.  However,  the  application  framework  has 
continuously grown over the various Android releases and has 
become  a  massive  code-base  that  is  even  further  extended 
and  modiﬁed  by  OEMs  for  their  own  purposes.  As  a  result, 
the  framework  also  became  less  and  less  transparent,  and  the 
correct  enforcement  of  security  policies  harder  to  judge.  This
Network  and  Distributed  Systems  Security  (NDSS)  Symposium  2021
21-25  February  2021, Virtual
ISBN  1-891562-66-5
https://dx.doi.org/10.14722/ndss.2021.23106
www.ndss-symposium.org
problem is best exempliﬁed by the seemingly simple task to
determine which API of the application framework is guarded
by which security conditions (i.e., a permission mapping),
something that has not been satisfyingly solved until today.
In fact, over the last decade, Android’s application frame-
work has been the target of a still ongoing line of research [20],
[11], [12], [47], [6], [4], [28], [5] to analyze and model the
complex security policy protecting the APIs of system services.
The modeled policy has been central to research and industrial
applications in assisting developers to write least-privileged
apps [51], to detect malware and over-privileged apps [18],
[48], [44], [9], [57], [40], [27], to detect vulnerabilities in
the application framework itself [47], [56], [6], [4], [28],
[29], and other use-cases [13], [35], [43]. This large body of
research and its applications underline the signiﬁcance of a
complete and sound modeling of the security policy enforced
in Android’s application framework. The consequences from
lacking such a model include, for instance, developers writing
over-privileged apps that contribute to eroding users’ trust
and comprehension of the permission system [37], [31], app
analysis relying on incomplete and inaccurate information to
determine the severity of apps’ API calls and consequently
misclassifying apps or malware [9], unclear consequences of
OEM modiﬁcations on the default security policy and whether
they weaken it [6], or mistakes in the default security policy
jeopardizing system’s integrity and user’s privacy [29].
Looking back at this line of research, we make some ob-
servations on the methodology. Although this research started
with a dynamic analysis solution by Porter Felt et al. [20], ever
since all subsequent solutions [11], [12], [47], [6], [4], [28],
[5] have been exclusively relying on static analysis. The switch
to static analysis is understandable given that there exist well-
established and available static analysis tools (predominantly
Wala [3] and Soot [50]), which are capable of achieving
high code coverage. However, static analysis also has its own
well-known limitations, especially when applied to a massive,
complex code base like that of the application framework,
including over-approximation, simpliﬁcation of analysis, and
inefﬁciency in bridging IPC. Given that there is no ground truth
for the security policy in Android and there is no systematic
approach for verifying results of static analysis at scale, it is
hard to judge the accuracy and completeness of those results.
In fact, looking at other software testing domains [22], [52],
[15], [58], [7], [42], it is common to compensate for inherent
limitations of static analysis by combining it with other tech-
niques, such as dynamic testing. Given the recent advances in
dynamic analysis techniques for Android, e.g., dynamic code
instrumentation and the emergence of powerful fuzzing tools,
committing to only static approaches for analyzing Android’s
application framework is an unjustiﬁed methodology whose
results will be tipped to a one-sided view and be unnecessarily
bound by inherent limitations.
Drawing inspiration from the software engineering do-
main [22], [52], [15], [58], [7], [42], we show that combining
static and dynamic analysis should be the natural next step
in this line of work to analyze Android’s pivotal application
framework. The concrete challenge at hand is that while there
exist well-established static analysis tools [3], [50], no proper
solution for dynamically testing and modeling the security pol-
icy of the application framework exists—the last solution [20]
is obsolete and technically as well as conceptually limited (see
Section III for a detailed discussion).
Our contributions: First, to ﬁll the gap that is caused by the
absence of a dynamic testing tool for analyzing the application
framework, we introduce in this paper a dynamic testing tool,
called DYNAMO, that is designed with two objectives in mind:
(1) analyzing the security policy of the application framework
for different versions of Android, and (2) revisiting the existing
results of static analysis tools. While DYNAMO uses well-
known techniques of dynamic testing and fuzzing (e.g., run-
time instrumentation, feedback-driven testing), the novelty of
this work comes from the right application of those techniques
in studying the security policy of the application framework.
As such, DYNAMO does not replace current solutions in this
domain but complements the current methodology that has
been tipped towards static analysis. To enable the community
to reproduce and extend our results, we open source our tool
and results [16].
Second, we use our tool to reproduce, extend, and ver-
ify the results of prior works for building permission map-
pings [12], [5], [11], for discovering permission re-delegation
vulnerabilities [29], and for detecting inconsistencies in the
security policy of two Android versions [47]. We further
use a permission mapping built by DYNAMO for the latest
Android release to assess the correctness and completeness of
permission annotations in Android’s developer documentation.
DYNAMO’s results have an immediate security impact (i.e.,
better developer documentation and discovery of permission
inconsistencies and misconﬁgurations) but also have an im-
plicit impact through more trustworthy permission mappings
for a wide range of dependent security applications on An-
droid (e.g., [44], [40], [9], [18], [27], [36], [48], [57], [4], [6],
[28], [29], [47], [56], [13], [35], [43], [51]).
Third, our root cause analysis of the discrepancies between
existing results and our dynamic analysis results provides
valuable feedback to the designers of both static and dynamic
testing tools. Concretely, we highlight
implementation and
approach-inherent shortcomings in existing tools that are based
on static analysis. Through a quantitative and qualitative anal-
ysis, we measure the negative impact of those shortcomings
on previous results. We additionally contribute new insights
that help to better understand how system services are in-
terconnected and protected, and we add crucial contextual
information about access control enforcement, such as the
resolution of the subject’s identity and locality and order
of security checks (which are fundamental to permission re-
delegation and inconsistency analysis [29]).
DYNAMO clearly improves on the status quo. Speciﬁcally,
our evaluation of the permission mapping by Arcade [5]—
the latest and most sophisticated permission mapping—shows
that the mapping of 76.1% of 951 analyzed APIs (that exist in
both Arcade’s and DYNAMO’s mapping) are veriﬁed, 3.1% are
incorrect, and 10.6% are incomplete. DYNAMO additionally re-
ports permission mappings for 343 APIs that are missing from
Arcade’s results while DYNAMO misses 247 APIs reported by
Arcade. We shared our ﬁndings with Arcade’s authors who,
following our discussion, upgraded their tool and published a
new permission mapping accordingly. We discuss the changes
to their original permission mapping separately in Section 3.
We also evaluated results from ARF [29] for discovering
permission re-delegations within system services and found
that 5 out of 33 reported vulnerabilities are False Positives
(FPs) while 10 could be conﬁrmed as true vulnerabilities. Our
consistency analysis of the permission enforcement revealed
5 sensitive APIs that are unprotected and 65 APIs with
permission misconﬁgurations. Finally, evaluating Android’s
developer documentation [24] for 439 APIs showed that it
is incomplete (66 APIs) and imprecise (9 APIs), which we
reported to Google for corrective actions. Section VI discusses
the security impact of these ﬁndings.
All in all, our contributions demonstrate the importance of
a more diverse set of analysis tools for Android’s middleware
and the feedback loop between those tools. The fact
that
DYNAMO reproduces the vast majority of results of previous
works, reports new ﬁndings, and adds trustworthiness to the
results along the way, shows how static and dynamic analysis
can go hand-in-hand in providing better results.
II. BACKGROUND
Android is a Linux-based OS that is characterized by its
open-source software stack. Most relevant to this work from
that stack is the application framework, which offers a variety
of system services that expose a wide range of features to
app developers and other components of the framework. Those
features are implemented as Service APIs and they are
reachable over an Inter-Process Communication (IPC), called
Binder. A subset of those APIs is encapsulated in Manager
APIs (e.g., by WiﬁManager and LocationManager classes) that
sanitize inputs and invoke service APIs over IPC (e.g., of
WiﬁService and LocationManagerService classes). However,
the manager APIs can be circumvented by invoking service
APIs directly, e.g., via Java reﬂection or native code.
Invoking an API is a multi-step operation (see Figure 1)
that starts by querying for the reference to the target service
from a central directory, called ServiceManager that keeps
track of all registered system services in the system. This
reference is then used to construct a proxy object that exposes
the APIs of the target service. When a speciﬁc API from the
proxy is invoked, the kernel transfers the call’s payload to the
service side, conveying the Linux UID and PID of the calling
process along the way. At the receiving end, the payload is
decoded and the target method is invoked.
One of the crucial features of the Binder IPC is conveying
the caller’s identity (i.e., UID and PID of the calling process) to
the callee. This feature is used to implement high-level access
2
app on top of a modiﬁed build of Android that logged the per-
missions checked for the testing app. To invoke the APIs and
trigger the permission checks, the app executed unit tests that
were semi-automatically generated by Randoop [2]. Motivated
by the low code coverage of Stowaway’s dynamic approach
and its considerable manual effort, PScout [11] proposed a
static analysis technique using the Soot framework [50] to
build permission mappings. It constructed a call graph of
the application framework, marking all permission checks
(e.g., checkPermission method), and performed backward
reachability analysis starting from those check points to the
APIs that use them. Axplorer [12] revisited the problem but
based on the WALA framework [3]. It highlighted new insights
(e.g., how to identify entry points) and handled new design
patterns (e.g., message passing) that were not covered by
PScout, causing imprecision in the produced mapping. Most
recently, Arcade [5] used static analysis also based on WALA
to add path-sensitivity to the reported mapping (i.e., different
execution paths that are controlled by inputs require different
sets of permissions). Arcade’s mapping considers the relation
between different security checks (e.g., whether enforced in
conjunction or disjunction). It additionally considered more
attributes that inﬂuence the access control decision besides
the permissions (e.g., caller’s UID/PID). Closely related to
building permission mappings in Android, Kobold [17] studied
the security policy of APIs that are exposed over IPC to third-
party app developers in iOS. Kobold’s approach is similar to
Stowaway in its design but is currently more limited by the
closed source nature of iOS.
Vulnerability Detection in the Security Policy: Another
line of research that studied Android’s application framework
focused on discovering discrepancies in access control en-
forcement within system services, e.g.,
two APIs that are
protected by different security conditions but lead to the same
functionality or data sink. The ﬁrst task to enable such analysis
is to model the security policy of system APIs. Kratos [47],
DiffDroid [6], and AceDroid [4] used a predeﬁned list of au-
thorization checks, e.g., checkPermission and hasUserRestric-
tion, and incrementally but manually complemented this list to
deﬁne the security policy of individual APIs. To remove the
dependency on the user-deﬁned list of authorization checks,
ACMiner [28] introduced a semi-automatic and heuristic-
driven approach to build this list. Centaur [41] proposed
symbolic execution in conjunction to static analysis to discover
and verify the inconsistencies. However, Centaur requires
access to the source code and cannot be used for closed-source
OEM images. Other works [59], [30] analyzed parameter-
sensitive APIs that are improperly protected. Exploiting those
APIs would disturb the system’s state or escalate the caller’s
privileges. Closely related to inconsistency detection, ARF [29]
employed static analysis and manual code inspection tech-
niques to discover permission re-delegation within Android
system services where one API calls another protected API
and enforces less restricting permissions compared to the ones
that are enforced when directly calling the target API.
Fuzzing for Vulnerability Detection: One of the early
works applying fuzzing to Android’s application framework is
Buzzer [14], which is a black-box fuzzing tool that focused
on testing input validation of system APIs using manually
crafted inputs. Another similar, but more advanced, work is
BinderCracker [21] that fuzzed the system APIs with faulty
Fig. 1. Multi-Step Binder IPC to call Service API
control protecting sensitive APIs. This access control relies on
permissions as the main policy. Permissions are special strings
centrally managed by the PackageManagerService (PMS)
and assigned to the apps, e.g., after being granted to the app
by the user. Every app is identiﬁed by its UID and granted per-
missions are bound to the UID. The access control further uses
three other known types of checks to regulate access to sensi-
tive APIs. Those types are: 1) Checks of the caller’s UID and
PID that are retrieved via Binder.getCallingUid/Pid()
and are used to allow calls from speciﬁc privileged contexts.
For example, they can be used to exclusively allow the system
(getCallingUid()== 1000) or calls from the same process
(getCallingPid()== currentPid) to execute a speciﬁc
API. 2) Across-proﬁle checks that use the caller’s userId
derived from the caller’s UID to distinguish between calls from