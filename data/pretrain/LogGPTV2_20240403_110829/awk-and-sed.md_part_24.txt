第七章
编写 awk 脚本
---
## Page 165
终的余额。代码如下：
这个脚本的核心任务是必须得到初始的余额，并从余额中减去每个支票的金
使用支票的场所和支票金额。这3个字段由制表符分隔，账户的数据用负数表
在第一行列出了初始的余额。其他的每一行提供了单个支票的信息：支票号，
假设已经输入了一个如下的文件：
票薄的方法，但使用awk 来完成某事的速度会快得令人惊奇。
这事一个简单的应用，用于处理支票登记条目。虽然不一定是最简单的结算支
支票薄的结算
符 ORS 设置为两个换行符。
额
符来实现。这样，
格。如果希望将这些字段输出在不同的行上，可以将OFS 的值改变为一个换行
这两个字段输出在同一行是因为默认的输出字段分隔符（OFS）仍然是一个空
例子的运行结果如下：
。我们可以为每个支票提供详细的行来与支票登记内容比较。最后打印出最
"u\u\ = Sao "u\ = SHo 
#1期望第一条记录为初始余额。
BEGIN {FS = "\t" }
# checkbook. awk
Bill Gold 1-707-724-0000
Alice Gold (707) 724-0000
$ awk -f block. awk phones.block 
Jeffrey Willis 914-636-0000
John Robinson 696-0987
# $1 = name; $NF = phone number
129 Gasoline -16.10
125 Market -125.45
1000
Phyllis Chapman 879-0900 
28
[ print $1, $NF ↓
Book Store -14.32
Video Store -7.45
Hardware Store -34.95
，存款就可以用证书表示。
 你可能希望用空格将记录分隔开，因此必须将输出记录分隔
QQ 群：
50192241
-165
第七章 
编写 awk 脚本
---
## Page 166
操作符
表 7-4：关系操作符
Y
个
√
>
操作符。
关系操作符和布尔操作符 
的时间。而使用 awk可以很容易地将基本功能独立出来并加以实现。
编程。可以用许多精心的设计来改善这个程序，
间，其中一个原因是，
的脚本仅需要几分钟。如果用类似于C的语言来编写这样的程序将需要更长
式。最重要的是该脚本执行了我们所期望做的事情。注意，在 awk 中编写这样
这个报告很难阅读，但在后面我们将学习使用 printf 语句来格式化报告的格
运行这段程序得到的结果如下：
关
系操作符和布尔操作符用于在两个表达式之间进行比较。表7-4列出了关系
801.73
874.55
$ awk -f checkbook. awk checkbook.test
129 Gasoline -16.10
817.83
128 Book Store -14.32
125 Market -125.45 
Beginning Balance: 1000
print balance += $3 # 支票数额有负数
{print $1，$2, $3 
#2应用与每个支票记录，将余额与数量相加。
next #取得下一条记录并结束
832.1
127
839.6
126H
balance = $1 
I$ "+\ :aoueieg uuuisag. zu!ud 1 l == aN
15
Video Store -7.45
Hardware Store -34.95
6
大于或等于
小于或等于
大于
小于
描
QQ 群：
述
你必须写更多行的代码，而且可能需要进行更低层次的
50192241
166
第七章
编写 awk 脚本
---
## Page 167
匹配）时，右边的表达式可以是awk 中的任意表达式；awk将它作为一个字符
正则表达式经常用斜杠包围。
检测当前记录号是否大于1，
下的表达式：
只有具有6个字段的记录才能被打印。
我们可以在试图打印数据库 phonelist 的记录之前用一个关系表达式来检测。
注意：
真，那么就进行相应的处理，否则不进行处理。
这个关系表达式将NF（每个输入记录的字段数）的值和5想比较。如果结果为
记录包含5个字段，则可以用下面的表达式：
串并用来指定一个正则表达式（注5）。我们曾学习了一个使用~操作符的例
一个字符串常量一样。我们已经看到很多这样例子：
于(>）或小于( 1
NF == 6 { print $1,$6 }
NF == 5 
也常常不局限于正则表达式常量。
“=”
代替“==”
不匹配
匹
不等的
相等的
QQ群：
配
或大于等于（>=）
来检测相等性是一个普通的错误。
50192241
在下章我们将看到，
这经常被作为正则表达式常量，正如“Hello”是
- 167 -
，或小于等于（ 1 & NF >= 2) II $1 ~ /\t/
NR > 1 && NF >= 2 II $1 ~ /\t/ 
NF == 6 && NR > 1 
$5~ state {print $1 ",“ $6 }
$5 ~/MA/ ↓print $1 "," $6 
在脚本 phonelist中，
当调用match(）、split()、sub（个gsub（函数时，也可以使用字符
串代替正则表达式常量。
逻辑非
逻辑与
逻辑或
定义
QQ群：
只有当给定的表达式之一的值为真（非零或非空）
50192241
因为在脚本执行过程中可以动态改变模式。例如，
我们可以用 state 来代替“/MA/”，
- 168
因此正则表达式可以用变量来提供。
第七章
编写 awk 脚本
，并编写一个过
---
## Page 169
注6:
取标准的输入。
当前目录。因此Is 命令的输出可以传给 awk，即使没有给出文件名也能自动读
件名、目录或ls 命令的附加选项。如果没有指定参数，
第一个变量，但是传递所有的变量将具有更大的灵活性）。这些参数可能是文
shelI使用$*变量来扩展通过命令行传递的所有变量（这里可以使用$1 来传递
印出该文件列表中选定的字段。为了完成这项操作，
在第一个例子中，
隔，我们可以将每个列看做是一个字段。
数显示在第五列，文件名显示在最后一列。在列之间由一个或多个空格来分
一行上。文件列表由9个列组成。
这个列表是一个报告，
得到的一个长列表样本（注6）：
现在我们来学习处理UNIX命令Is 的输出的几个脚本。下面的执行命令ls－丨
获取文件的信息
如果圆括号中的表达式的值为假，那么上面的表达式的结果就为真。这个操作
无法一个表达式的值为真或为假，操作符！都对其值取反。
第一个条件必须为真，而且另外两个条件中必须有一个为真。
以用圆括号来改变优先规则，例如，
换句话说，圆括号中的两个表达式必须都为真或圆括号右边的表达式为真。
后
符
面我们将会看到）。当然它还有其他的用途。
存与 awk 的in 操作符结合起来非常有用，
Is -l $*| awk’ script'
-rwxrwxrwx 1 dale project 1202 Jan 2 23:06 format.idx
$ls-l
！(NR >1＆&NF > 3)
NR > 1 && (NF >= 2 II $1 ~ 八\t/)
-rw-rw-rw- 
-rwxrwxrwx
-rw-rw-rw-
注意在 Berkeley 4.3BSD 派生的 UNIX 系统上，例如 UItrix或
-1 dale project 1446 Feb 15 22:32 dang
，我们将这个命令的输出结果导入一个awk 脚本中，该脚本打
1 dale project 6041 Jan 1 12:31 com.tmp
QQ 群：
，其中的数据按行和列显示。每个文件信息显示在单独的
50192241
，文件的操作权限出现在第一列，
- 169 -
下面的例子规定两个条件必须都为真。
可用来判断某个下标否在数组中（在
我们将创建一个 shelI脚
第七章 
“$*”将为空并且显示
编写 awk 脚本
文件的字
可
---
## Page 170
生的总数必须打印出来，因此，
我们所编写的操作将应用于所有的输入行。当 awk读入所有的输入行后，所产
每次表达式计算一次，计数器加1.
的当前值上。
第一个表达式使用赋值操作符+=。
加列表中文件的数量。
个输入行。我们创建变量 sum来累加列表中文件的大小，
还能够跟踪文件的数量并计算出总数。增加这些功能包括两部分。首先累计每
提供的。我们将每个文件的大小相加，
以上程序所做的工作就是读入一个长列表并将其减少为两个字段。现在我们来
如果将上面的代码保存在文件fls 中并运行该文件，则可以将fls 作为一个命
九个字段（$9）。
我们希望awk 脚本能够打印文件的大小和名字。即打印第五个字段（$5）和第
END { print "Total: ", sum, 
print $5,
++filenum
sum += $5
1778 comb ine. idx
6041 com.tmp
$ fls com* 
1446 dang
1778 combine. id
6041 com.tmp
$ fls 
print $5，
1202 format. idx
显示的相同的报告格式。
Sun0S4.1x,Is－丨产生一个8列的报告；使用Is－Ig得到与这里
第二个表达式递增变量filenum的值。该变量作为一个计数器，
，"\t"， $9
"\t",
QQ群：
6$
50192241
，我们编写了一个由END 规则控制的操作：
，它的功能是将第五个字段的值加到变量 sum
"bytes (" filenum " files)"
- 170 -
，得到列表中所有文件的总字节数。我们
第七章
用变量filenum来
编写 awk 脚本
累
---
## Page 171
的是，我们可以设计规则来处理这类情况。我们来看下面修改后的、加了注释
我们前面的脚本忽略了这行及其前面的空行，但是仍然递增文件计数器。幸运
子目录old，ls－IR将产生一个空行，
传
如果想列出子目录中的文件，
件总的大小上。因此，指出这是一个目录可能是有用的。
（960B）并不表示子目录下的文件的大小，
第一-列（文件的操作权限）中的首字符“d”表示该文件是子目录。文件的大小
中的一行：
这个脚本还有一个问题，也就是它如何处理子目录。参见下面Is－“执行结果
有
我们对块总数并不感兴趣，
录都列出来，那么在输出中将会包含下面的一行：
（所有以“c”开头的文件）中的部分列表中没有包含这一行。但是如果整个目
命令显示整个目录时，
在显示基本机制之后，
这个命令的优点是能够确定一个目录或某个文件组中文件的大小。
现在，我们将这些程序代码防御文件filenum 中并作为一个单词命令运行。
我们还可以使用 BEGIN 规则给报告增加列标题。
递给Is命令。然而，当它识别每个目录时，列表有一些区别。例如，要识别
打印这一行，但是它读入了这一行并使计数器filenum得到了递增。
drwxrwxrwx 3 dale project 960 Feb 1 15:47 sed
BEGIN { print "BYTES", "\t", "FILE" }
. /old: 
total 555
Total: 12459 bytes (5 files
BYTES FILE
$ filesum c*
1778 combine.
6041 com.
1987 ch04
1771 ch03
882 ch01
 tmp
QQ群：
.idx
列表中包含一个指定目录中块的总数的行。在前面例子
还需要注意几个问题。
，因为程序显示了文件的总的大小。
50192241
可以在命令行中提供-R（递归）选项。该选项将
- 171 -
气候跟随：
因此，
第一个问题出现在当使用ls
 经常错误地把这个数加到文
第七章 
、现在 filesum没
编写 awk 脚本
一
---
## Page 172
用正则表达式或关系表达式来编写一些匹配这一行的模式。
规则4 用于测试由ls－IR产生的列表的特殊形式（“./old;”）。我们可以使
的脚本：
真
相
文
的
使
或
数