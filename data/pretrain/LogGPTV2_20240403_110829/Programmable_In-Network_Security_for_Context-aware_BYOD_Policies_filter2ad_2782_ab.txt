compromise the kernel or obtain root privileges. It is possible
to further relax these assumptions by directly establishing
the root of trust in hardware [28, 30, 74]. In the case where
untrusted devices may connect to the network, Poise needs to
perform authentication on context signals before using them
for decision making, e.g., by adding support for cryptography
in P4 switches. We discuss this in more detail in §7.
3 Programmable In-Network Security
We call this new paradigm programmable in-network security.
Scenario. Consider the enterprise network shown in Figure 2,
which hosts several types of private data, such as employee
records and sales records, and also provides connectivity to
the Internet. The operator wants to enforce dynamic access
control of sensitive enterprise data in the presence of BYOD
clients. For instance, the policy might specify that a) sales
records should only be accessed by devices belonging to
the sales department; b) during regular work hours; c) from
devices that are properly patched to address some recently
discovered vulnerability; and, d) a device can only access the
sales records if the sales manager is online. Poise is designed
for context-aware security policies such as these.
USENIX Association
29th USENIX Security Symposium    597
Employee database
Internet
Switch 
programs
Context 
packets
Access 
Point
Sales records
Device 
configurations
Figure 2: Poise compiles high-level policies into a) switch
programs, and b) device conﬁgurations. The clients send peri-
odic context packets to the network, and Poise enforces the
policy in the switches.
The Poise system. At the heart of Poise is a novel switch
primitive that can enforce CAS policies in hardware. The de-
sign of this primitive also tackles a practical challenge. Since
P4 programs specify low-level packet processing behaviors,
they are akin to “assembly-level” programs, and one often
needs to hand-optimize P4 programs to reduce resource usage.
Therefore, we allow network operators to specify CAS poli-
cies in a declarative language that is much higher-level than
P4. Our compiler can then generate optimized P4 programs
automatically, which are different versions of the security
primitive. The Poise compiler also generates conﬁgurations
for the context collection module at the clients. It collects con-
text signals based on the conﬁguration, and sends out periodic
context packets to the network. Policy changes can be easily
supported by a recompilation. Client conﬁgurations need not
be affected by policy updates, unless the new policies require
new types of context signals to be collected.
Next, we ﬁrst describe the Poise language and compiler,
then the switch primitive, and ﬁnally, the client module and
how these components work together.
4 The Poise Language and Compiler
The policy language in Poise is inspired by the Frenetic family
of SDN programming languages [38, 54, 68, 69, 79], but we
adapt them a) from an OpenFlow setting to P4, which supports
richer header operations and state, and b) from a network man-
agement setting to security, by supporting security contexts.
Speciﬁcally, we have designed the Poise language based on
Pyretic NetCore [69], where network policies are written as a
series of match/action statements. In terms of the semantics
of the language, a policy represents a function that maps an in-
coming packet to zero (i.e., drop), one (i.e., unicast), or more
(i.e., multicast) outgoing packets. A policy could be as simple
as drop, which drops all packets, although practically, the pol-
icy would make a decision based on the context a packet car-
ries, such as if match(dip==66.220.144.0) then drop,
which blacklists a block of destination IP addresses, or if
match(0800, =0800)&( time 0) then fwd( server )
Advanced policies. Inspired by the literature of “continuous
authentication” [37, 49, 50, 92], we propose a set of advanced
policies that use device context to detect subtle but important
indicators of potential attacks. Due to space constraints, we
only describe the high-level policies, but not the programs. P5:
Block requests without explicit user interaction, which denies
access to a sensitive service if all apps are running in the back-
ground and there is no user interaction with the touchscreen
to trigger the request; such requests are likely generated by
malware. P6: Scrub trafﬁc if UIs are overlapping, which for-
wards trafﬁc through a middlebox if the context information
shows that app UIs are overlapping—a potential sign for UI
hijacking [55]. P7: Conduct deep packet inspection if cam-
era/recorder is on, which detects if sensitive information is
being leaked through an active camera/recorder app [36].
4.3 Compilation
Next, we discuss how the Poise compiler processes the key
language constructs and generates P4 implementations.
Compiling security contexts. The Poise compiler generates
P4 headers for each context. Context packets have special IP
protocol numbers (143 for TCP, 144 for UDP), and they have
no payload. Context headers follow the TCP/UDP headers
(e.g., Eth|IP|TCP|Ctxt). Poise switches recognize the context
headers by the IP protocol number, whereas legacy switches
forward these packets based on destination IPs. User trafﬁc
is not modiﬁed by Poise in any way. (See Figure 13 in Ap-
pendix.) As a concrete example, Figure 4(a) shows the P4
headers for the gps signals: latitude and longitude.
Compiling context operations. The Poise compiler distin-
guishes between ﬁve classes of context operations: arithmetic
operations, bitwise operations, comparisons, context matches,
and membership tests. The ﬁrst three classes are simpler to
handle, as they can be directly translated into their P4 coun-
terparts; the latter two require the compiler to generate ad-
ditional code components in P4. First off, all context ﬁelds
are compiled into header deﬁnitions and references to these
USENIX Association
29th USENIX Security Symposium    599
header gps_t {
bit lat;
bit lon;
} //ctxt def.
control Ingress {
//switch ingress def.
apply {
bit d;
d=lat^2+lon^2;
if (d  monitor;
register ts;
if (admin.isValid()) {
//update monitor result
monitor++; 
} //other users denied
} else if (NOW-ts > timeo){
}
…
apply(admin)
//timeout
monitor=0;
}
ts = NOW;
(a)	Security	context
(b)	Context	operations
(c)	Constant	lists	+	membership	tests
(d)	Network-wide	monitors
Figure 4: The Poise compiler processes the key language constructs and generates P4 implementations. The P4 snippets shown
are simpliﬁed for clarity of presentation. For instance, in (b), the instantiation of the thresh register is not shown; in (d), the
timestamp of a packet is obtained via the ingress_global_timestamp ﬁeld instead of a variable called NOW.
headers, as discussed above. Then, for arithmetic, bitwise, or
comparison operations over header ﬁelds, such as lat*lat,
sensors&0x01, or time<10, our compiler forms expressions
using the corresponding P4 operations over the headers. For
arithmetic operations, the current P4 speciﬁcation supports ad-
dition, subtraction, and multiplication, which are all supported
by the Poise compiler. Notably missing from the list are di-
vision and modulo operations, which tend to be expensive to
implement in switch hardware (although sometimes they can
be approximated by bit shifts if the divisor is a power of two).
If a Poise program involves operations unimplementable in
P4, our compiler would reject the policy during compilation.
As an example, Figure 4(b) shows simpliﬁed P4 snippets
that our compiler generates for computing the distance be-
tween a pair of GPS coordinates to a pre-deﬁned center (as-
sumed to be (0,0)). Our compiler also generates conditional
statements based on the policy, e.g., if-else branches to
test if the distance exceeds a threshold. Context operations
are performed within an apply block at control Ingress,
which means the switch ingress pipeline.
Context matches, on the other hand, are compiled into
match/action tables in P4. A match can be an exact match,