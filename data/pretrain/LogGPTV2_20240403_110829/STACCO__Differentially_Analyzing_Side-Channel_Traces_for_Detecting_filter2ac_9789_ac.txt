and branch-level control-flow inference attacks, the vulnerability
analyzer is able to tell whether the tested library is vulnerable to
such attacks and, if so, pinpoints the exploitable vulnerabilities.
Packet generator. The packet generator is in charge of generating
the input to the framework. It prepares encrypted packets with
specified plaintext or ciphertext (with specified errors) to be sent
to the peer at any stage of an SSL/TLS connection. In our imple-
mentation, we adopted an open-source tool, TLS-attacker [67]. It is
able to complete an SSL/TLS handshake or replace any packet in
this process. It is also able to send arbitrary data records after the
SSL/TLS connection has been successfully established.
Trace recorder. A core component of the framework is the execu-
tion trace recorder. We implemented the trace recorder on top of
Intel Pin. Pin [46] is a dynamic binary instrumentation framework
that is suitable for a range of program analysis tasks. It enables
various tools, called Pintools, to be developed using the framework.
Of interest to our purpose is its capability of dynamic instrumenting
a software program without changing its memory layout, which is
essential for detecting sensitive control-flow vulnerabilities. Partic-
ularly, a Pintool provided by Pinplay kit [55] can be used to create
the Dynamic Control-Flow graph (DCFG) of a program [75].
DCFG is defined by Intel as an extension of the control-flow
graphs (CFG) [14]. An example of a DCFG can be found in Figure 7.
Generally speaking, a DCFG shows the portion of a CFG that has
been executed. An edge in a DCFG is augmented with a counter,
which records the number of times this edge is executed. Pinplay kit
also provides an option to record the exact sequence of the executed
edges in the DCFG, which is called DCFG-Trace. Combining the
DCFG with the DCFG-Trace, Stacco is able to generate a trace of
basic blocks that has been executed by the instrumented programs.
In order to improve the runtime performance and to facilitate
data analysis, we need to specify which parts of the execution we
are most interested in. For example, if we are looking for vulner-
abilities in the handshake protocol, the execution trace should be
recorded only when the handshake APIs are called. However, we
found that such a selective tracing functionality that could have
been enabled by control options enter_func and exit_func in the
Pintool could not work properly with the SSL/TLS libraries. As a
solution, we added in the SSL/TLS program two empty functions
Figure 7: An example of DCFG.
foo() and bar() to wrap the functions that we are interested in,
by adding a call to foo() before it and bar() after it. Thus we
could control the Pintool to selectively trace functions when the
option -log:control start:address:foo,stop:address:bar
is enabled.
The output of the trace recorder consists of two JSON files. One
includes the DCFG as well as basic information such as base ad-
dresses of the libraries and the offsets of each of the basic blocks in
the libraries. The other JSON file contains a trace of DCFG edges.
We then extended the Pintool using Pin DCFG APIs to merge the
two files into a trace of basic blocks. Because the base addresses
of the libraries change every time we run the program, we use the
name of the library and the offset of the basic block to uniquely
identify a basic block.
It might be worthwhile noting here, that Pin has bugs when exe-
cuting certain functions (e.g., gnutls_record_recv() in GnuTLS)
and, as a result, the DCFG traces of these functions cannot be cor-
rectly recorded. For this special case, we replace the Pin-based trace
recorder with a Callgrind-based trace recorder. Callgrind is a tool
of Valgrind [53, 72] which is also a dynamic instrumentation frame-
work. We extend Callgrind to include timestamps for each function
call in order to recover the complete call trace from the call graph
generated by Callgrind. Unfortunately, Callgrind does not provide
fine-grained basic block tracing (e.g., DCFGs) like Pin.
The diff tools. Because the Pin-generated basic-block traces are
ordered sequences of basic blocks, the diff command of Linux OS
turns out to be enough to identify the differences between the two
traces. In contrast, the Callgrind-generated function call traces are
less structured. We, therefore, implemented a Python tool based on
difflib to compare Callgrind-generated function call traces, which
first converts the call traces to call trees with nodes associated with
timestamps, and then represent the call trees using XML, which
can be compared using difflib.
Vulnerability analyzer. Given the results of the diff tools, we
build a vulnerability analyzer in Python to examine sensitive control-
flow vulnerabilities. Particularly, the differences in the basic-block
traces are by themselves vulnerability to branch-level attacks. To
detect vulnerabilities at the cacheline level or the page level, we
need to convert the basic-block traces into traces of cachelines and
pages. Specifically, the virtual address of the beginning of each basic
block is calculated. The corresponding page trace can be obtained
by dividing the virtual addresses of the basic blocks by 4096, the
size of a memory page, and then merge consecutive basic blocks
together if they have the same page address. Similarly, cacheline
traces can be generated by dividing virtual addresses of the basic
blocks by 64, which is the size of a cacheline. After the conversion,
if the trace differences in the basic-block sequences render the same
cacheline trace or page trace, the program, as per this test, is not
vulnerable to cacheline-level or page-level control-flow inference
attacks.
4.2 Evaluation and Results
We applied Stacco to detect two types of oracle attacks, CBC
padding oracle attacks, and Bleichenbacher attacks, in the latest
versions (as of February 2017) of five popular open-source libraries
(see Table 1)1.
4.2.1 Bleichenbacher Tests. To detect vulnerabilities that en-
able Bleichenbacher attacks, we conducted a series of differential
tests. In each of the tests, we differentially analyzed two varia-
tions of the ClientKeyExchange messages in the handshake pro-
tocol. One of the two variations is a non-conformant message in
which the first two bytes of the plaintext is not 0x0002, which
we call the “standard error”; the other variation is a message
following one of the ten rules specified in Table 1. For example,
“PKCS#1 conformant” means that the ClientKeyExchange mes-
sage is correctly formatted according to PKCS#1 standard, but with
an incorrect PMS. If this message is not differentiable from the
“standard error”, the library is not vulnerable to Bleichenbacher
attacks. “Wrong Version” stands for the two version-number bytes
are incorrect. In the “No 0x00 Byte” test case, the delimiter 0x00
byte after the padding bytes is changed into a non-0x00 byte. The
test cases “0x00 in PKCS Padding” and “0x00 in Padding”
mean that some bytes in the corresponding padding bytes are mod-
ified to 0x00, which they should not if the messages are confor-
mant. Note that the first 8 bytes of the padding string are the PKCS
paddings while the rest bytes are regular paddings. They are treated
by the SSL/TLS library differently. “PMS Size” test cases are per-
formed by moving the 0x00 byte to somewhere in the middle of the
PreMasterSecret (PMS) so that PMS is truncated. For example,
“PMS Size=2” is done by moving 0x00 to the third last byte. Note
all the PreMasterSecret (PMS) in these tests are invalid so that
the error handling procedure is always triggered.
The results of the analysis are shown in Table 1. “D” suggests
that in the differential analysis, the two traces, when converted
to the corresponding level, are differentiable; “N” means the two
traces are not differentiable. If “PKCS#1 conformant” is differen-
tiable from “standard error”, it means we can construct an oracle
that when it returns true, we are certain that the corresponding
plaintext message starts with 0x0002. This means the tested library
is considered exploitable by a Bleichenbacher attack (labeled “✓” in
the row with the header “Exploitable”). However, what we do not
1As of August 2017, Intel’s SGX SDK [7] only contained a cryptographic library; and
the SSL/TLS implementation was not completed. Therefore, we could not conduct
tests on Intel’s official SGX SSL/TLS implementation.
know is whether the oracle returning false means the message does
not begin with 0x0002. If, at the same time, some of the other 9 tests
yield differentiable traces, it means we have a higher probability to
assert that when the oracle returns false the message does not start
with 0x0002, which leads to a stronger oracle.
In the cacheline-level and branch-level control-flow inference
attacks, the oracle strength is 1 for all libraries; this is because the
oracle only returns false when “standard error” happens. In these
cases, we have a very strong oracle that can help break the secret
with fewer queries. The page-level attacks against GnuTLS and
mbedTLS also have an oracle strength of 1, but those for OpenSSL
256)49) ≈
256)8 × (1 − ( 255
and LibreSSL are lower, which is roughly ( 255
0.1691 when the RSA key size is 2048 (see Figure 3)2. It means the
0.1691 = 5.9×) queries
1
adversary needs to send more (roughly,
to the “weaker” oracle compared to using a stronger oracle (i.e.,
oracle strength is 1). The oracle strength for page-level control-flow
inference attacks against WolfSSL is the lowest, because most of
the differential tests render non-differentiable, making the oracle
attack very slow.
4.2.2 Padding Oracle Tests. To detect vulnerabilities that give
rise to CBC padding oracle attacks, we also performed a series of
tests. In each test, the framework is provided with two applica-
tion data messages that are encrypted with symmetric keys in the
CBC mode. All messages are four blocks in length. One message
only has an incorrect MAC, the “standard error”, and the other
message has both an incorrect MAC and one of the six padding
errors listed in Table 1. Specifically, the six test cases can be divided
into two groups: The first group of tests is conducted by modifying
the “Padding Length Byte” which is the last byte of a record;
the second group modify the last “Padding Byte” which is the
second last byte of a record. The two groups each generate one
error padding case by (1) XORing the target byte with 1, (2) set-
ting it to 0x00 and (3) setting it to 0xFF. We note that the test of
“Padding Length Byte = 0x00” is special. When it yields differen-
tiable traces, it means the padding length cannot be 0x00, therefore
our test should break the last two bytes together (by looking for
paddings of 0x0101). Otherwise, the attack can start with guessing
the last byte, greatly reducing the complexity of the attacks. None
of the SSL/TLS implementations we tested allow padding length to
be 0x00. But it only makes the attack slightly longer and does not
eliminate its vulnerability.
When the “standard error” can be differentiated from the
various padding errors, the library is vulnerable to padding oracle
attacks. The results of the analysis are shown in Table 1. We can see
that almost all libraries, except for OpenSSL, are vulnerable to all
levels of control-flow inference attacks. OpenSSL 1.0.2j is not vul-
nerable to page-level attacks because all its distinguishable traces
are contained in the same page. Another exception is GnuTLS. As
we have mentioned before, the Pintool does not support GnuTLS’s
gnutls_record_recv() function due to a bug in the tool. Conse-
quently, we used Callgrind-based trace recorder, which does not
support analysis at the branch level and the cacheline level.
4.2.3
Findings. Although some cryptographic libraries, such as
OpenSSL, aim to enforce constant-time implementations, Stacco
2It requires 0x00 in the 8-byte PKCS padding and No 0x00 in the last 48 + 1 bytes.
Table 1: Experiment results of the differential analyses. B: vulnerable to branch-level attacks? C: vul-
nerable to cacheline-level attacks? P: vulnerable to page-level attacks? D: Differentiable; N: Not differ-
entiable; N/A: unable to test.
Test Name
OpenSSL
1.0.2j
mbedTLS WolfSSL
3.10.0
2.4.1
B C P
B C P
LibreSSL
2.5.0
GnuTLS
3.4.17
C
D
D
D
D
D
D
D
D
D
D
✓
B
D
D
D
D
D
D
D
D
D
D
✓
PKCS#1 Conformant
0x00 in PKCS Padding
Wrong Version
No 0x00 Byte
0x00 in Padding
PMS Size=0
PMS Size=2
PMS Size=8
PMS Size=16
PMS Size=32
Exploitable
B C P
D D D
D D D
D D N
D D D
D D N
D D D
D D D
D D D
D D D
D D D
✓ ✓ ✓
P
B C P
D D D D D D D D D D
D D D D D D N D D D
D D D D D D N D D N
D D D D D D N D D D
D D D D D D D D D N
D D D D D D N D D D
D D D D D D N D D D
D D D D D D N D D D
D D D D D D N D D D
D D D D D D N D D D
✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓
Padding Length Byte XOR 1 D D N N/A N/A D D D D D D D D D D
Padding Length Byte = 0x00 D D N N/A N/A D D D D D D D D D D
Padding Length Byte = 0xFF D D N N/A N/A D D D D D D D D D D
D D N N/A N/A D D D D D D D D D D
Last Padding Byte XOR 1
D D N N/A N/A D D D D D D D D D D
Last Padding Byte = 0x00
D D N N/A N/A D D D D D D D D D D
Last Padding Byte = 0xFF
✓ ✓ ✗ N/A N/A ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓
Exploitable
r
e
h
c
a
b
n
e
h
c
i
e
l
B
s
k
c
a
t
t
a
e
l
c
a
r
O
g
n
i
d
d
a
P
s
k
c
a
t
t
a
finds that all five SSL/TLS libraries are vulnerable to control-flow
inference attacks. In most cases, page-level attacks are sufficient to
create an oracle and perform oracle attacks against these libraries.
We scrutinized the identified vulnerabilities and found that there are
primarily two reasons for the leakage. First, the oracles for Bleichen-
bacher attacks are typically caused by the improper error logging
and reporting mechanisms in the library. Second, the oracles for
padding oracle attacks are typically created by the improper im-
plementation of constant-time cryptography in the patches for the
existing side-channel attacks (e.g., the Lucky Thirteen attack, cache
attacks, etc.). We briefly summarize one example in this section,
and list vulnerable code for other vulnerabilities in Appendix A.