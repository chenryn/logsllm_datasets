-0.58%
4.45%
-1.72%
0.03%
-0.0344
-7.168
0.510
-901.548
0.694
-189.919
B. Cooperative Semantic Reconstruction
As we previously explained in Section V-C, in OP-TEE
all arguments to TA are typed (i.e., pointer or value), and all
pointers are already checked to ensure that they are within
the common-memory region. Thus, we were able to im-
plement our CSR defense by simply adding a new pointer
parameter type, RAW_PTR, and modifying the trusted OS to
perform the required callback to the untrusted OS for every
RAW_PTR. We also changed the untrusted OS’s client library
(i.e., libteec.so) to use the RAW_PTR as the default type
for all pointers. The untrusted kernel driver was similarly
modiﬁed to handle the callback function. We implemented
our PTRSAN function in the callback, which veriﬁes that
the argument is a valid virtual address within the appropriate
untrusted application (referenced by its PID). Upon veriﬁ-
cation, we then resolve the corresponding physical memory
pages, set them to be non-pageable, and return the physical
addresses back to the secure world. All of our modiﬁcations
to OP-TEE are backward-compatible and can easily co-exist
with the existing DSMR defense. These modiﬁcations resulted
in only 91 modiﬁed lines of code in the OP-TEE trusted OS
(see Table II to see the modiﬁcations per component).
As explained in Section VII-C, most of the additional
overhead introduced by CSR is caused by the callbacks from
the trusted OS to the untrusted OS for every RAW_PTR
argument type. In OP-TEE, all of the pointer arguments are
ﬁrst sanitized by the trusted OS before invoking the TA. Hence,
all of our results for CSR do not include the calls between
in Figure 8).
the TA and the trusted OS (i.e.,
Nevertheless, we similarly measured the incurred overhead
of CSR by running the xtest suite, which made a total of
3,885 callbacks throughout its tests. The average time taken
for the trusted OS to confer with the untrusted OS to sanitize
pointers ( 5 - 6 - 7 - 8 ) over all 3,885 callbacks was 26.891
µs, 21.909 µs of which were spent within the untrusted OS
doing validation and memory page pinning ( 6 ). This is almost
identical to the 21.777 µs overhead incurred by the DSMR
defense.
and 9
4
C. Comparative Evaluation
To get an idea of the speciﬁc performance of memory
management operations with the two defenses, we analyzed
13
the proﬁling data for the various operations performed by both
approaches and found that performance for a single memory
access with DSMR is slightly better, 5.113 µs faster, than CSR.
However, the performance across the entire range of tests is
much more interesting.
A summary of the testing data, in terms of the average
overhead of CSR over DSMR for each test category, is shown
in Table III. Note that a negative value indicates CSR was
faster than DSMR for the corresponding category. The Trusted-
Untrusted Communication category represents CSR’s worst
performance in terms of the percentage of overhead. There
are 14 tests in this category and all of them primarily perform
a lot of SMC operations (approximately 200) to test inter-
world communication. CSR allocates and deallocates memory-
tracking structures during each SMC, as it cannot know ahead
of time when memory arguments are to be used. This con-
tributes a very small overhead for each SMC, which is reﬂected
as a larger percentage in these particular tests, although even
here, this net overhead in terms of time is still low.
In the context of the other 49 tests performed, the percent-
age of overhead contributed by CSR versus DSMR is very
small. CSR introduces no more than 0.03% overhead in the
worst case and improves performance by up to 1.72% in others.
For those tests with non-secure memory operations, we
observed that the DSMR overhead varied signiﬁcantly, whereas
the overhead of CSR remained constant for a given number of
memory operations. The main reasons for variance in DSMR
overhead are:
• Synchronized access: The allocation and release of shared
memory involves acquiring a global
lock. For a multi-
threaded application making simultaneous shared memory
requests and releases will result in idle tasks as they wait
for the global lock, increasing the overhead of DSMR. We
observed this in one of the tests of the Basic Functionality
category, which creates several threads, all of which make
requests to a TA. During this subtest, the overhead for a
shared memory allocation went up to 80 microseconds and
in total CSR beat DSMR by 11.72 seconds of execution
time.
• Additional copying: In DSMR, untrusted applications need
to copy data to or from shared memory to communicate with
the TA. This copying time can be an overhead, if a large
amount of data is being exchanged between the untrusted
application and the corresponding TA. For example, one of
the tests in the Trusted-Untrusted Communication category,
which passes a large amount of data, suffered a 26%
overhead because of this memory copying.
• Memory Fragmentation: Depending on how shared memory
is allocated and released, it could get severely fragmented.
As DSMR in OP-TEE uses a best-ﬁt algorithm to ﬁnd free
regions of shared memory, fragmentation increases the time
to ﬁnd a free chunk, thus increasing the overhead of DSMR.
Although CSR is slightly outperformed by DSMR in some
tests, in practice CSR is the best candidate for an all-around
defense. CSR offers the best security properties, requires min-
imal modiﬁcation for implementation, incurs minimal overall
performance overhead, and actually boosts performance for
multi-threaded applications. Thus, per our evaluation, CSR
appears to be the ideal defense against BOOMERANG.
IX. CONCLUSION
In this work, we identiﬁed a previously unknown class of
vulnerabilities, BOOMERANG, that affects systems where the
secure world (i.e., the TEEs) and the non-secure world (i.e.,
the traditional OS) share resources. The vulnerability arises
from the critical semantic gap when passing data between
the two worlds, speciﬁcally memory pointers, and ﬂaws in
sanitizing these pointers. We identiﬁed BOOMERANG vulner-
abilities in four of the most popular commercial TEE platforms
(affecting hundreds of millions of devices world-wide). In
order to explore the generality and severity of BOOMERANG,
we developed a static-analysis tool to automatically identify
BOOMERANG bugs in real-world TEE applications. These
ﬁndings have resulted in major efforts from the respective
parties (e.g., Google and Qualcomm) to ﬁx their implemen-
tations, as the identiﬁed vulnerabilities could be leveraged to
completely compromise the untrusted OS (e.g., Android) of
the affected devices. We similarly analyzed three potential
BOOMERANG defenses, comparing the trade-offs and design
considerations of each. Due to the limitations of the existing
defenses (i.e., shared memory and page table introspection),
we devised a novel solution, Cooperative Semantic Recon-
struction, which addresses the shortcomings of the previous
proposals, while still offering an efﬁcient and easy-to-use
interface.
ACKNOWLEDGEMENTS
This material is based on research sponsored by the Ofﬁce
of Naval Research under grant number N00014-15-1-2948 and
by DARPA under agreement number N66001-13-2-4039. The
U.S. Government is authorized to reproduce and distribute
reprints for Governmental purposes notwithstanding any copy-
right notation thereon.
This work is also sponsored by a gift from Google’s Anti-
Abuse group.
Sandia National Laboratories is a multi-mission laboratory
managed and operated by Sandia Corporation, a wholly owned
subsidiary of Lockheed Martin Corporation, for the U.S. De-
partment of Energy’s National Nuclear Security Administration
under contract DE-AC04-94AL85000.
The views and conclusions contained herein are those of
the authors and should not be interpreted as necessarily repre-
senting the ofﬁcial policies or endorsements, either expressed
or implied, of DARPA, Sandia National Laboratories, or the
U.S. Government.
REFERENCES
[1] AOSP, “/dev/ion driver!” https://lwn.net/Articles/480055/, 2006.
[2] ARM, “ARM TrustZone,” http://www.arm.com/products/processors/tec
hnologies/trustzone/index.php, 2015.
[3] ARM, “Securing the Future of Authentication with ARM TrustZone-
based Trusted Execution Environment and Fast
Identity Online
(FIDO),” https://www.arm.com/files/pdf/TrustZone-and-FIDO-white-
paper.pdf, 2015.
[4] A. M. Azab, P. Ning, J. Shah, Q. Chen, R. Bhutkar, G. Ganesh, J. Ma,
and W. Shen, “Hypervision Across Worlds: Real-time Kernel Protection
from the ARM TrustZone Secure World,” in Proceedings of the 2014
ACM SIGSAC Conference on Computer and Communications Security
(CCS), 2014.
14
[5]
J. Bangert, S. Bratus, R. Shapiro, and S. W. Smith, “The Page-
Fault Weird Machine: Lessons in Instruction-less Computation,” in
Proceedings of the 7th USENIX Workshop on Offensive Technologies
(WOOT), 2013.
[6] A. Barth, C. Jackson, and J. C. Mitchell, “Robust Defenses for Cross-
Site Request Forgery,” in Proceedings of
the 15th ACM SIGSAC
Conference on Computer and Communications Security (CCS), 2008.
J. Bennett, “Devices with Trustonic TEE,” https://www.trustonic.com/n
ews-events/blog/devices-trustonic-tee, 2015.
[7]
[8] S. Bugiel, L. Davi, A. Dmitrienko, T. Fischer, A.-R. Sadeghi, and
B. Shastry, “Towards Taming Privilege-Escalation Attacks on Android,”
in Proceedings of the 19th Annual Network and Distributed System
Security Symposium (NDSS), 2012.
[9] M. Dietz, S. Shekhar, Y. Pisetsky, A. Shu, and D. S. Wallach, “Quire:
Lightweight Provenance for Smart Phone Operating Systems,” in Pro-
ceedings of the 20th USENIX Security Symposium, 2011.
[10] M. Egele, M. Woo, P. Chapman, and D. Brumley, “Blanket Execution:
Dynamic Similarity Testing for Program Binaries and Components,” in
Proceedings of the 23rd USENIX Security Symposium, 2014.
[11] X. Ge and T. Jaeger, “Sprobes: Enforcing Kernel Code Integrity on
the TrustZone Architecture,” in Proceedings of the Mobile Security
Technologies 2014 Workshop (MoST), 2014.
[12] GlobalPlatform, TEE System Architecture, 2011.
[13] ——, TEE Internal Core API Speciﬁcation v.1.1.1, 2016.
[14] N. Golde and D. Komaromy, “Breaking Band: reverse engineering and
exploiting the shannon baseband,” in REcon, 2016.
[15] Google, “QSEEComAPI.h,” https://android.googlesource.com/platfor
m/hardware/qcom/keymaster/+/master/QSEEComAPI.h, 2012.
[16] ——, “Trusty TEE,” http://source.android.com/security/trusty/, 2016.
[17] N. Hardy, “The Confused Deputy: (or why capabilities might have been
invented),” ACM SIGOPS Operating Systems Review, 1988.
[18] Huawei, “Security Advisory - Multiple Security Vulnerabilities in
Huawei Smart Phone Products,” http://www.huawei.com/en/psirt/secu
rity-advisories/huawei-sa-20161123-01-smartphone-en, 2016.
J. Jang, S. Kong, M. Kim, D. Kim, and B. B. Kang, “SeCReT:
Secure Channel between Rich Execution Environment and Trusted
Execution Environment,” in Proceedings of the 22nd Annual Network
and Distributed System Security Symposium (NDSS), 2015.
[19]
[20] Y. Jang, S. Lee, and T. Kim, “DrK: BreakingKernel Address Space
Layout Randomization with Intel TSX,” in BlackHat USA, 2016.
[21] N. Keltner,
“Here Be Dragons: Vulnerabilities
in TrustZone,”
https://atredispartners.blogspot.com/2014/08/here-be-dragons-vulnerab
ilities-in.html, 2014.
[22] V. P. Kemerlis, M. Polychronakis, and A. D. Keromytis, “ret2dir:
the 23rd USENIX
Rethinking Kernel Isolation,” in Proceedings of
Security Symposium, 2014.
[23] K. Kostiainen, J.-E. Ekberg, N. Asokan, and A. Rantala, “On-board
Credentials with Open Provisioning,” in Proceedings of the 4th Inter-
national Symposium on Information, Computer, and Communications
Security (Asia CCS), 2009.
[24] K. Lady, “Sixty Percent of Enterprise Android Phones Affected by
Critical QSEE Vulnerability,” https://duo.com/blog/sixty-percent-of-ent
erprise-android-phones-affected-by-critical-qsee-vulnerability, 2016.
laginimaineb, “Bits, Please!” https://bits-please.blogspot.com/, 2016.
[25]
[26] Lenovator, “HiKey (LeMaker version) 2GB RAM,” http://www.lenovat
or.com/product/90.html.
[27] Linaro Security Working Group, “Linux Kernel, OP-TEE driver,”
https://github.com/linaro-swg/linux/blob/optee/drivers/tee/optee/core.c,
2016.
[28] M. Lu, “TrustZone, TEE and Trusted Video Path Implementation
Considerations,” http://www.arm.com/files/event/Developer Track 6
TrustZone TEEs and Trusted Video Path implementation considera
tions.pdf, 2013.
[31] ——, “Shared memory allocated by tee linux kernel driver is not zeroed
out,” https://github.com/linaro-swg/linux/issues/13/, 2016.
[32] ——, “Shared Memory IDs are stored globally,” https://github.com/lin
aro-swg/linux/issues/14/, 2016.
[33] B. McGillion, T. Dettenborn, T. Nyman, and N. Asokan, “Open-TEE–
An Open Virtual Trusted Execution Environment,” in Proceedings of
the 14th IEEE International Conference on Trust, Security and Privacy
in Computing and Communications, 2015.
[34] H. Nahari, “TLK: A FOSS Stack for Secure Hardware To-
kens,” http://www.w3.org/2012/webcrypto/webcrypto-next-workshop/
papers/webcrypto2014 submission 25.pdf, 2012.
[35] OP-TEE, “optee os,” https://github.com/OP-TEE/optee os/blob/maste
r/core/arch/arm/kernel/tee ta manager.c, May 2016.
[36] Qualcomm, “Msm scm communicator,” https://android.googlesource.c
om/kernel/msm/+/android-5.1.0 r0.6/arch/arm/mach-msm/scm.c.
[37] ——, “Qualcomm Secure Execution Environment Communicator
(QSEECOM) driver,” https://android.googlesource.com/kernel/msm.g
it/+/77cac325253126dd9e6c480d885aa51f1abf3c40/drivers/misc/qseec
om.c.
[38] D. Rosenberg, “Reﬂections on Trusting TrustZone,” in BlackHat USA,
2014.
[39] K. Rubinov, L. Rosculete, T. Mitra, and A. Roychoudhury, “Automated
Partitioning of Android Applications for Trusted Execution Environ-
ments,” in Proceedings of the 38th International Conference on Software
Engineering (ICSE), 2016.
[40] G. Rydstedt, E. Bursztein, D. Boneh, and C. Jackson, “Busting frame
busting: a study of clickjacking vulnerabilities at popular sites,” IEEE
Oakland Web 2.0 Security and Privacy (W2SP), 2010.
[41] Samsung, “Knox Technology,” https://www.samsungknox.com/en/knox
-technology, 2015.
[42] Samsung Knox News, “Real-time Kernel Protection (RKP),” https://ww
w2.samsungknox.com/en/blog/real-time-kernel-protection-rkp, 2016.
[43] D. Shen, “Attacking your “Trusted Core,” Exploiting TrustZone on
Android,” in BlackHat USA, 2015.
[44] Y. Shoshitaishvili, R. Wang, C. Salls, N. Stephens, M. Polino,
A. Dutcher, J. Grosen, S. Feng, C. Hauser, C. Kruegel, and G. Vigna,
“SoK: (State of) The Art of War: Offensive Techniques in Binary
Analysis,” in Proceedings of the IEEE Symposium on Security and
Privacy (SP), 2016.
[45] Sierraware, “Open Virtualizations SierraVisor and SierraTEE,” http://op
envirtualization.org, 2016.
[46] ——, “SierraWare Trusted Execution Environment,” http://www.sierr
aware.com/, 2016.
[47] STMicroelectronics and Linaro Security Working Group, “OP-TEE
non-secure world kernel driver,” https://github.com/linaro-swg/linux/tr
ee/optee/drivers/tee.
[48] ——, “OP-TEE non-secure world/secure world SMC call,” https://gith
ub.com/linaro-swg/linux/blob/optee/drivers/tee/optee/call.c#L117.
[49] ——, “OP-TEE normal world client library,” https://github.com/OP-TE
E/optee client.
[50] ——, “OP-TEE Test Suite,” https://github.com/OP-TEE/optee test.
[51] ——, “Open Source TEE,” https://github.com/OP-TEE/optee os.
[52] H. Sun, K. Sun, Y. Wang, J. Jing, and S. Jajodia, “TrustDump: Reliable
Memory Acquisition on Smartphones,” in Proceedings of
the 19th
European Symposium on Research in Computer Security (ESORICS),
2014.
[53] Trustonic, “Trustonic,” https://www.trustonic.com/.
[54] ——, “tee-mobicore-driver.kernel,” https://github.com/TrustonicNwd/
tee-mobicore-driver.kernel/blob/MC12/drivers/gud/MobiCoreDriver/f
astcall.h, 2015.
[55] ——, “trustonic-tee-user-space,” https://github.com/Trustonic/truston
ic-tee-user-space/blob/e3b0b06025605b06fc1e19588098e5011f6afc83/
MobiCoreDriverLib/Daemon/MobiCoreDriverDaemon.cpp, 2015.
[56] ——, “tee-mobicore-driver.daemon,” https://github.com/TrustonicNwd/
[29] A. Machiry, “Potential Heap Buffer overﬂow in tee supp com.c,” https:
//github.com/OP-TEE/optee linuxdriver/issues/52/, 2016.
[57]
[30] ——, “Potential invalid MEMREF translation, this could be used for
bad,” https://github.com/OP-TEE/optee linuxdriver/issues/53/, 2016.
15
tee-mobicore-driver.daemon, 2016.
J. Williams, “Inspecting data from the safety of your trusted execution
environment,” in BlackHat USA, 2015.