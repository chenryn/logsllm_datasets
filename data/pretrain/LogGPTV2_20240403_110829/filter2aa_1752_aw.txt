### 8.1 进程地址空间

Linux 系统通过进程地址空间来管理内存。每个进程都有一个虚拟地址空间（Virtual Address Space），该空间的大小通常是 0 到 2^64-1 字节。

#### 8.1.1 页和页面调度

虚拟地址空间被划分为多个页，每一页的大小通常是 4KB（32位系统）或 8KB（64位系统）。页可以是有效的（valid）或无效的（invalid）。有效的页要么在物理内存中，要么映射到磁盘上的文件。无效页则表示该页尚未分配或已被释放。

当进程访问无效页时，会发生页错误（page fault）。此时，操作系统会处理这个错误，并将需要的页从磁盘加载到内存中，或者分配新的物理内存给该页。为了优化性能，操作系统还会将不常用的页移出内存（paging out），以便为其他更频繁使用的页腾出空间。

##### 8.1.1.1 共享和写时复制

多个进程可以通过共享相同的物理页来提高内存利用率。这种共享机制允许不同的进程映射同一块物理内存。对于只读的共享页，所有进程都可以直接访问。而对于可写的共享页，当某个进程试图修改该页时，系统会采用写时复制（Copy-On-Write, COW）技术，创建一个新的副本供该进程使用，从而避免了同步问题。

### 8.1.2 存储器区域

存储器区域（memory regions）是进程地址空间中的逻辑段或映射。常见的存储器区域包括：

- **文本段（Text Segment）**：包含程序的机器代码，通常是只读的。Linux 中，文本段通常对应于可执行文件或动态链接库。
- **栈段（Stack Segment）**：用于存储局部变量和函数调用信息。栈段的大小可以在运行时动态调整。
- **数据段（Data Segment）** 和 **堆段（Heap Segment）**：用于存储全局变量、静态变量和动态分配的内存。数据段包含已初始化的数据，而 BSS 段则包含未初始化的数据。
- **BSS 段（BSS Segment）**：用于存储未初始化的全局变量和静态变量，默认值为 0。

通过工具如 `/proc/self/maps` 或 `pmap` 可以查看进程的内存映射情况。

### 8.2 动态内存分配

动态内存分配允许程序在运行时请求和释放内存。C 语言提供了多种内存管理函数，如 `malloc`、`calloc`、`realloc` 和 `free`。

#### 8.2.1 数组分配

`calloc` 函数用于分配并初始化内存。它接受两个参数：元素个数和每个元素的大小，并返回指向分配内存的指针。与 `malloc` 不同，`calloc` 会将分配的内存初始化为 0。

```c
int *x, *y;
x = malloc(50 * sizeof(int));
if (!x) {
    perror("malloc");
    return -1;
}
y = calloc(50, sizeof(int));
if (!y) {
    perror("calloc");
    return -1;
}
```

#### 8.2.2 调整已分配内存大小

`realloc` 函数用于调整已分配内存的大小。它接受两个参数：指向当前内存块的指针和新的大小。如果新的大小大于当前大小，`realloc` 会尝试扩展内存；如果小于当前大小，则可能缩减内存。

```c
void *realloc(void *ptr, size_t size);
```

#### 8.2.3 动态内存的释放

`free` 函数用于释放之前通过 `malloc`、`calloc` 或 `realloc` 分配的内存。

```c
void free(void *ptr);
```

#### 8.2.4 内存对齐

某些情况下，程序需要对齐内存以满足特定硬件或软件的要求。POSIX 提供了 `posix_memalign` 函数来分配对齐的内存。

```c
int posix_memalign(void **memptr, size_t alignment, size_t size);
```

此外，还有 `valloc` 和 `memalign` 函数可以用于分配对齐的内存。

```c
void *valloc(size_t size);
void *memalign(size_t boundary, size_t size);
```

这些函数可以帮助确保内存按指定的边界对齐，从而提高性能和兼容性。