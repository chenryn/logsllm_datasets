何内存的程内页。
8.1 进程地址空间
的操作 Linux 将的理内存。进程能
理内存上 Linux 内进程的
空间（virtual address space。空间性的 0 
。
8.1.1 页和页面调度
空间页。的以及页的小（页
的小的的页的小 4K(32 )  8K(64 )∗。
页效（invalid效 (valid) 效页（valid
page理页或存相或
上的文件。效页（invalid page
或。对效页的段。空间的。
然性实上间的小。
进程能处存的页页理内存
∗的页小原页小 ABI（程进
的。程时页小我们我
们将以。
– 256 –
 8 
内存理
 的 页 相  。    进 程       的 页   存    理 单
（MMU页（page fault。然内存
的页。存理内存（
上同空间以内页理内
存出 (paging out) 存将的页出空间。内
将能的页出以性能。
8.1.1.1 共享和写时复制
存的页属同进程的空间能映
射同理页。同的空间（share理内存上
的。的能读的或读写的。
进程写的写页时能以。
单的内操作页的进程将
写操作的。的进程对同页读写程上的
作同步。
 MMU 写操作异作内
的页的以进程进写操作。我们将方
写时（copy-on-write（COW∗。读的以效的
空间。进程写页时以页的
内工作进程自的。写时
以页单进的文件以效的进程。进
程对页写时能新的。
8.1.2 存储器区域
内将相同的页（blocks读写。
存（memory regions段（segments或映射（mappings.
进程以的存
• 文段（text segment进程的
读的。 Linux 文段读文件（程
或文件映射内存。
• 段 (stack) 进程的的的或
∗ fork() 写时子进程进程的空间。
– 257 –
 8 
内存理
。程的 (local variables) 的。
• 段 (data segment) (heap)进程的存空
间。段写的的小以的。空间
malloc 的 (将)。
• BSS 段∗(bss segment) 的。
同的 C 的 ( 0)。
Linux 方。段存的
的以 (ld) 实上将的存对文件。
以进文件的小。段内存时内单的
写时的原将们映射 0 的页上效的设
的。
• 空间映射文件文件自 C 或
的文件。以 /proc/self/maps或 pmap 程的出我们
能进程的映文件。
将 Linux 提的何内存、映射的。
8.2 动态内存分配
内存同以自内存理的
内存的以及的。内存进程时
的时的的小时
。作程程的空间或
内存的时间内存。文件
或的存内存的时。文件的小以及内的
的的小的程读
内存。
C 提内存的。 C 提内存
 struct pirate ship 的提内存
空间存 pirate ship。程对内存进操作
子 struct pirate ship*。
C 的内存的 malloc():
∗的原 block started by symbol 。
– 258 –
 8 
内存理
#include 
void *malloc (size_t size);
调 malloc() 时 size 小的内存
内存的。内存的内的自 0. 
时 malloc()  NULL设 errno  ENOMEM。
malloc() 的单的子。小的内存
char *p;
/* give me 2 KB! */
p = malloc (2048);
if (!p)
perror (”malloc”);
或空间存
struct treasure_map *map;
/*
* allocate enough memory to hold a treasure_map
stucture
* and point ’map’ at it
*/
map = malloc (sizeof (struct treasure_map));
if (!map)
perror (”malloc”);
调时 C 自的 void 的。
以子调时将 malloc() 的。
 C++ 提自的。 C++ 的对
malloc() 的作:
char *name;
/* allocate 512 bytes */
name = (char *) malloc (512);
if (!name)
– 259 –
 8 
内存理
perror (”malloc”);
 C 的程喜将（ malloc的
void。我对。的
 void 的时出。更的的
时的 BUG∗。 malloc 时
能。
 malloc 以 NULL对的程
的。程的 malloc() malloc()  NULL
时程。程们作 xmalloc()
/* like malloc(), but terminates on failure */
void *xmalloc (size_t size)
{
void *p;
p = malloc (size);
if (!p) {
perror (”xmalloc”);
exit (EXIT_FAILURE);
}
return p;
}
8.2.1 数组分配
的内存小的时内存将更。
内存的子。时的小的
的。处理 C 提 calloc() 
#include 
void *calloc (size_t nr, size_t size);
∗的 int 的。 Int 的自的以
。。
– 260 –
 8 
内存理
调 calloc() 时以存的内存
(nr  size )。以内存方式的内存小
的（能的
int *x, *y;
x = malloc (50 * sizeof (int));
if (!x) {
perror (”malloc”);
return -1;
}
y = calloc (50, sizeof (int));
if (!y) {
perror (”calloc”);
return -1;
}
的的。 malloc 同的 calloc 将的
 0 进。 y 的 50  0 x 的
的。程上给的 50 程
calloc() 的的。的进
0  0 的。
 0 的内存即内存存
的。的我们 memset 提的
内存的。 calloc 更内以提 0 的内
存。
时 malloc()  calloc()  NULL设 errno 
ENOMEM。
我们 C 提 calloc 以的以及
。以们自的
/* works identically to malloc( ), but memory is
zeroed */
void *malloc0 (size_t size)
– 261 –
 8 
内存理
{
return calloc (1, size);
}
我们以方的将 malloc0 我们的 xmalloc 
/* like malloc( ), but zeros memory and
terminates on failure */
void *xmalloc0 (size_t size)
{
void *p;
p = calloc (1, size);
if (!p) {
perror (”xmalloc0”);
exit (EXIT_FAILURE);
}
return p;
}
8.2.2 调整已分配内存大小
C 提（或小的内存的
小
#include 
void *realloc (void *ptr, size_t size);
调 realloc() 将 ptr 的内存的小 size 。
新空间的扩内存的时的能 ptr。
 realloc 能的空间上 size 小 size 
小的空间将原的新空间然将的空间。何
新的小的原内存的内。
的操作以扩原的 realloc() 操作能相时的。
 size  0效 ptr 上调 free() 相同。
– 262 –
 8 
内存理
 ptr  NULL malloc() 。 ptr  NULL 的
调的 malloc(), calloc(), 或 realloc() 的。的时
realloc()  NULL 设 errno  ENOMEM。时 ptr 的内存
。
我们原存的。我们 calloc() 
的空间存 map 的 struct map *p;
/* allocate memory for two map structures */
p = calloc (2, sizeof (struct map));
if (!p) {
perror (”calloc”);
return -1;
}
/* use p[0] and p[1]... */
我们的以我们内存的小将的空
间给 (能的操作 map 我们
的 map 时间时):
/* we now need memory for only one map */
r = realloc (p, sizeof (struct map));
if (!r) {
/* note that ’p’ is still valid! */
perror (”realloc”);
return -1;
}
/* use ’r’... */
free (r);
 realloc() 调 p[0] 。的原。
 realloc()  p 以然的。我们
内存。方调我们 p
 r（ p 的空间小。我们的
时 r 。
– 263 –
 8 
内存理
8.2.3 动态内存的释放
自内存空间自。同的内
存将进程空间的式。程
们将的内存给。（然进程出的时
的存然存。
 malloc(), calloc(), 或 realloc() 的内存的时
free() 给
#include 
void free (void *ptr);
调 free()  ptr 的内存。 ptr 调 malloc(), calloc(), 或
 realloc() 的。能 free() 的内存
空间间的。
ptr 能 NULL时 free() 调 free() 时
 ptr  NULL。
我们子
void print_chars (int n, char c)
{
int i;
for (i = 0; i 
int posix_memalign (void **memptr,
size_t alignment,
size_t size);
调 posix memalign()时 size 的内存
alignment 进对的。 alignment  2 的以及 void 小的
。的内存的存 memptr  0.
调时内存 memptr 的
EINVAL
 2 的或 void 的。
ENOMEM 的内存满的。
的对 errno 设给
出。
 posix memalign() 的内存 free() 。单
char *buf;
int ret;
/* allocate 1 KB along a 256-byte boundary */
ret = posix_memalign (&buf, 256, 1024);
if (ret) {
fprintf(stderr, ”posix_memalign: %s\n”,
strerror (ret));
return -1;
}
/* use ’buf’... */
free (buf);
更的。 POSIX  posix memalign( )  BSD  SunOS 
提
#include 
void * valloc (size_t size);
– 267 –
 8 
内存理
void * memalign (size_t boundary, size_t size);
 valloc() 的能 malloc() 的页对的。
页的小 getpagesize() 。
相 memalign() 以 boundary 对的 boundary  2
的。子的内存存 ship 
页的上
struct ship *pirate, *hms;
pirate = valloc (sizeof (struct ship));
if (!pirate) {
perror (”valloc”);
return -1;
}
hms = memalign (getpagesize ( ), sizeof (struct
ship));
if (!hms) {
perror (”memalign”);
free (pirate);
return -1;
}
/* use ’pirate’ and ’hms’... */
free (hms);
free (pirate);
 Linux 的内存以 free() 。的
Unix 提的
内存。出性能 free（
以上的内存。
更的上时 Linux 的程以
。 posix memalign()。 malloc() 的
满对时。
– 268 –
 8 
内存理
8.2.4.2 其它对齐问题
的对内存对以进扩展。
的的对将的更。对同的