title:simFI: From single to simultaneous software fault injections
author:Stefan Winter and
Michael Tretter and
Benjamin Sattler and
Neeraj Suri
simFI: From Single to Simultaneous
Software Fault Injections
Stefan Winter, Michael Tretter, Benjamin Sattler, Neeraj Suri
DEEDS Group, Dept. of CS, TU Darmstadt, Germany
{sw, tretter, bsattler, suri}@cs.tu-darmstadt.de
Abstract—Software-implemented fault injection (SWIFI) is an
established experimental technique to evaluate the robustness of
software systems. While a large number of SWIFI frameworks
exist, virtually all are based on a single-fault assumption, i.e.,
interactions of simultaneously occurring independent faults are
not investigated. As software systems containing more than a
single fault often are the norm than an exception [1] and current
safety standards require the consideration of “multi-point faults”
[2], the validity of this single-fault assumption is at question for
contemporary software systems.
To address the issue and support simultaneous SWIFI (simFI),
we analyze how independent faults can manifest in a generic
software composition model and extend an existing SWIFI tool
to support some characteristic simultaneous fault types. We
implement three simultaneous fault models and demonstrate their
utility in evaluating the robustness of the Windows CE kernel.
Our ﬁndings indicate that simultaneous fault injections prove
highly efﬁcient in triggering robustness vulnerabilities.
Keywords—Software fault injections, fault models, robustness
testing
I.
INTRODUCTION
Software-implemented fault injection (SWIFI) is used to
evaluate the resilience of software to perturbations in its
operational environment. However, the conclusiveness of such
evaluations fundamentally depends on the proper choice of the
applied fault models [3], [4] that specify how faults manifest
in the system spanning fault dimensions of timing, duration,
and location [5], [4].
Despite the large number of fault models behind the various
proposed SWIFI frameworks (e.g., [6], [7], [4], [8]; see [9] for
an overview), virtually all of them consider only injections of
a single fault per experiment run. The implicit assumptions
driving this design choice usually are that
1) apart from error propagation [10], no error interactions
occur (i.e., all errors resulting from different fault activa-
tions are independent or have a necessary and sufﬁcient
causal relationship) or that
2) such effects are of no or negligible relevance for the
outcome of the experiments.
Therefore, experimental assessments with existing tools do
not account for the possibility of interactions between multiple
faults, although software systems containing more than a single
fault are reported to be a common occurrence [1]. However,
if the consideration of multiple coincident faults signiﬁcantly
affects the outcome of a robustness evaluation, it would be a
fallacy to disregard them.
The ISO standard 26262 for the functional safety of road
vehicles explicitly considers multiple-point failures, i.e., fail-
ures resulting from the combination of several independent
faults [2]. In order to assess the degree to which systems are
vulnerable to such multiple-fault conditions, new approaches
are needed and this forms the focus of this paper.
The goal of this paper is to (a) conceptually develop
a notion of what fault coincidence actually implies in the
context of SWIFI-based robustness evaluations, and (b) to
experimentally assess the impact (positive or negative) of
its consideration on evaluation effectiveness and applicable
overheads. On this background the paper contributions are:
(C1) Coincidence notion: We establish fault coincidence
notions and discuss their applicability within a general model
of SWIFI-based robustness assessments for software compo-
sitions (Sections II and IV).
(C2) Impact criteria: We identify and discuss SWIFI
experimentation aspects affected by simultaneous faults. As
these aspects have direct implications on the efﬁciency of
SWIFI experiments, they form a set of criteria for assessing
both the overhead and the beneﬁts of simultaneous fault
injections (Section III).
(C3) Simultaneous fault model design: The utility of
coincident injections is shown via the design and implemen-
tation of three simultaneous fault models (Section V) that are
instances of the abstract fault coincidence notion developed as
(C1).
(C4) Quantitative evaluation of simFI: We quantitatively
compare the efﬁciency of (a) three simultaneous and (b) three
discrete fault models (Section V).
II. SYSTEM & BASIC FAULT MODELS
We consider robustness evaluations of component-based
software systems, where components interact via contractually
speciﬁed interfaces [11]. The implementation of each com-
ponent’s functionality is accessible through sets of services
offered by the component, termed interfaces. Compositions
implement their functionality using services of their individual
components. The set of services that a component provides is
termed the component’s export interface. The corresponding
import interface spans the external services it depends on.
We assume the availability of functional service speciﬁca-
tions for components as the minimum information required for
composition. We do not assume source code access or other
component implementation details.
978-1-4799-0181-4/13/$31.00 ©2013 IEEE
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 07:56:01 UTC from IEEE Xplore.  Restrictions apply. 
related literature [5], [4], [13] we model faults according to
their location (where to inject), type (what to inject), trigger
(when to inject) and latency (for how long to inject).
Individual experiments are termed injection runs. Injection
runs with the same system conﬁguration (CUE clients, servers,
IUEs) and the same fault model, but different fault model
instances being injected, are called injection campaigns. Mul-
tiple injection campaigns for the same CUE, but with different
fault models and different system conﬁgurations constitute an
evaluation of the CUE.
III. FAULT SIMULTANEITY ASPECTS IN SWIFI-BASED
SOFTWARE ASSESSMENTS
In cases where multiple independent faults can affect the
dependable operation of a software system, the application of
tools and processes based on a single-fault assumption is likely
to generate incorrect or imprecise results. In addition to this
obvious impact on the validity of obtained results, the consider-
ation of simultaneous faults in SWIFI-based assessments may
have a number of conceptual and technical implications on
experimental assessments, which we discuss in the following.
A. Likelihood vs. Criticality of Rare Events
Assuming that
the same time is Qi∈1...n pfi ≤ pfj
the probability of some fault f being
activated is pf , the probability of n independent faults f1 . . . fn
for
being active at
any j ∈ 1 . . . n. The activation of n faults is less probable
than the activation of an individual fault fj if at least one
other fault has an activation probability less than 1. This
makes the co-occurrence of multiple fault activations less
likely than individual fault activations. Thus, the risk they
impose may be regarded negligible for very low probabilities
of occurrence, especially when contrasted with high testing
efforts required to cover all possible cases. This resembles the
fundamental assumption driving test case reductions in com-
binatorial testing [14]: Fault interactions are so rare that they
can be neglected during tests without signiﬁcantly affecting
the outcome in the common case.
However, in safety engineering, critical failures (accidents)
are often considered to result from unlikely, rare, and uncon-
sidered combinations of events, which is also reﬂected by the
ISO 26262 safety standard [2], [15]. Due to their improbability,
such conditions often escape the focus of testers and are
sometimes very difﬁcult to construct in the test environment.
Empirical work shows this to apply for critical software
failures as well [16], [17].
B. Experiment Acceleration vs. Counts
Single fault injections are capable of identifying one in-
ternal fault per injection run. If a simultaneous fault injection
reveals multiple internal faults at the same time, this implies
a considerable speed-up in terms of experiment time required
for the identiﬁcation of the same amount of internal faults.
However, the outcome of a simultaneous fault injection run
may also lead to more ambiguous results.
If multiple faults are injected, one activated fault (termed
error [10]) can potentially mask another fault or error. If, for
instance, a fault f1 leads to a corrupted data value in memory
Fig. 1: System model and SWIFI experiment setup
SWIFI and Software Fault Models
Aviˇzienis et al. [10] deﬁne service failure as the deviation
of a service from its speciﬁcation. The cause of a service
failure is the impact of an unintended state (termed error)
of the component providing that service. The cause of an
error is the activation of a fault. Component-external events
causing fault activation constitute external
faults, whereas
faults activated inside the component are called internal faults.
From the robustness notion in [12], our work considers the
problem of detecting internal faults (robustness vulnerabilities)
by exposing software components to external faults (perturba-
tions). If an external fault is injected and a component failure is
observed, then an internal fault exists, which has been triggered
by the injection of the external fault. This detection mechanism
is sound but incomplete, i.e., it never raises false alarms but
existing internal faults may remain undetected.
Figure 1 shows our general system model for these experi-
mental assessments. In a composition, the presence of internal
robustness vulnerabilities in a component under evaluation
(CUE) is assessed. The CUE is being used by one or more
other components, which we term CUE clients, via its export
interfaces. To provide services to these client components, the
CUE depends on services from other components, termed CUE
servers, whose services it imports. We inject external faults to
the CUE by either mutating its servers or by corrupting data
that the servers send to the CUE via both its exported and
imported interfaces. The intended effect is that the servers’
behavior differs from their speciﬁed behavior expected by the
CUE’s implementation. As for a given experiment setup only
a fraction of all CUE interfaces may be used by the chosen
server components, the used interface between the CUE and its
servers is termed the interface under evaluation (IUE). When
components interact only via contractually speciﬁed interfaces,
component failures can only affect other components via these
interfaces. Injections at the interface level are a sound method
to accelerate fault injection experiments in these cases, as all
erroneous behavior that can affect any other components must
be observable at the faulty component’s interfaces. We utilize
failure detectors in the CUE’s run-time environment to observe
the CUE’s response to injections. This data is evaluated ofﬂine
for the identiﬁcation of internal faults.
Despite choosing a speciﬁc system model and SWIFI setup,
the number of possible external faults for an individually
targeted service is extremely large. Faults are therefore catego-
rized into fault models and in accordance with other SWIFI-
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 07:56:01 UTC from IEEE Xplore.  Restrictions apply. 
and by activation of a different fault f2 that particular memory
the effect of f1’s activation
location is never referenced,
never becomes visible although it would have if f2 had not
been activated. From such an experiment, it is not possible
to determine whether the activation of f1 would have been
tolerated or it would have caused the component to fail.
If the injection of simultaneous faults results in a system
failure, a similar ambiguity can occur: It is unclear whether
the activation of all injected faults is actually necessary to
trigger the observed failure. This makes it difﬁcult to spot the
robustness vulnerability or vulnerabilities responsible for the
failure. Note that this problem is different from error masking,
as error masking may lead to an error being tolerated or miti-
gated unlike the presumed software failure in this case. In both
cases the ambiguity can be resolved at the cost of additional
experiments with single faults constituting the simultaneous
fault condition. However, this may add considerably to the
number of overall required experiments.
Even without the potential need for additional experiments
to resolve ambiguities, the consideration of coincident faults
by itself leads to higher numbers of possible experiments,
thereby aggravating test case selection: While the individual
injection of n faults yields n experiments, this expands to
(cid:0)n
k(cid:1) experiments for k coincident faults, assuming all possible
combinations as feasible.
We experimentally investigate the impact of coincident
faults on the evaluation efﬁciency in Section V.
C. Sequential vs. Concurrent Executions
Unlike classical sequential processing, modern processors
provide higher performance via higher degrees of parallelism
instead of higher execution rates. In order to exploit these
performance gains, software applications are designed for
the parallel execution of independent threads. This parallel
execution of different
instructions belonging to the same
software component enables the simultaneous activation of
independent internal faults within one component. With an
increasing degree of parallelism, the rate of failures resulting
from simultaneous fault activations naturally increases.
We develop notions of “temporal” and “spatial” fault coin-
cidence that apply for both sequential and concurrent execution
models in the following section.
IV. MODELING SIMULTANEOUS FAULTS
Attempting to deﬁne simultaneous fault models strictly on
the fault notion and system model in Section II is problematic.
The fault notion of Aviˇzienis et al. [10] implies that a software
component cannot be exposed to two independent external
faults. As an external fault is deﬁned as something that triggers
an internal fault and an internal fault is deﬁned as something
possibly resulting in a component failure, there are two possi-
bilities: Either the simultaneous injection of two independent
alterations does not lead to a failure and, consequently, does
not constitute a fault, or they lead to an observable component
failure, in which case they are considered one external fault.
However, if we assume software components to be them-
selves composed of components, simultaneous faults can be
deﬁned via subcomponent faults. Consider component A to
Fig. 2: Intuition for external fault simultaneity
be composed of components B and C as shown in Figure 2.
Assume B to have the internal fault fB and C to have the
internal fault fC . If there exist external faults fB, fC , fBC , so
that fB triggers fB, fC triggers fC , fBC triggers both fB and
fC , then we call fBC a simultaneous fault if it is an external
fault to A, i.e., if it results in a failure of A.
The external faults fB, fC are distinguishable, as they
trigger different internal faults that constitute external faults
to distinct subcomponents. While temporally coincident, they
differ in location. There may also be different external faults
triggering the same internal fault. These are perceived as
distinct cases if they occur at different
instances of time.
Hence, we distinguish between temporally coincident faults
(that differ in location) and spatially coincident faults (that
differ in timing). While temporal fault coincidence is the
more intuitive notion and less considered in existing work,
we ﬁrst discuss “spatially coincident but temporally spread”
faults, as they facilitate the accurate deﬁnition of temporal fault
coincidence.
A. Spatial Coincidence and Temporal Resolution
Deﬁnition 1: An external fault is termed spatially coinci-
dent but temporally spread if it triggers the same internal fault
at different instances of time.
The precise timing and even an approximate timing with
respect to real execution times can be difﬁcult to measure
if the component’s implementation is not accessible for in-
strumentation. Therefore, we relax the notion for black-box
components and only require observability at their interfaces
during different usage sequences.
Deﬁnition 2: An external fault of a black-box component
temporally spread if it
is termed spatially coincident but
triggers the same internal fault within more than one temporal
usage sequence of the functional interface. Temporal usage
sequence may refer to an evaluation, an injection campaign, a
single injection run, or an individual service invocation during
an injection run. The choice of the usage sequence is referred
to as temporal resolution.
For simplicity we write “temporally spread” to mean “spa-
tially coincident but temporally spread”. An example for a tem-
porally spread fault with coarse-grained temporal resolution is
the injection into a component that maintains some state across
different evaluations, e.g., injections that lead to accumulating
corruptions in persistent storage. It is important to note that the
external fault is only considered temporally spread if it targets
the same internal fault in multiple evaluations. An example
of a ﬁne-grained temporal resolution is the repeated injection
of the same external fault into the same service over multiple
service invocations.
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 07:56:01 UTC from IEEE Xplore.  Restrictions apply. 
Interface 0
Interface 1
Service 0
Service 1
Parameter 0 Parameter 1
Bit 0
Bit 1
Component
Interface k
Service k
Parameter k
Bit k
. . .
. . .
. . .
. . .
. . .
. . .
. . .
. . .
Interface n
Service n
Parameter n
Bit n
Fig. 3: Relationship of spatial entities
Temporally spread fault injections are more widely applied
than temporally coincident fault injections, e.g., for the the
injection of intermittent or permanent faults. They are also
applied to investigate fault effect accumulation, often referred
to as “software aging”. While we do not develop temporally
spread fault models in this paper, we discuss existing work
addressing temporally spread injections in Section VI.
B. Temporal Coincidence and Spatial Resolution
Deﬁnition 3: An external fault of a component is termed
temporally coincident if it triggers internal faults in more than
one sub-component.
As two internal faults are triggered by one event occurring
at one instance of time, their causation is considered tem-
porally coincident. While this deﬁnition works well for cases
where the internal structure of a component under evaluation is
known, it cannot be directly applied to black-box components
for which the internal structure is not known to the evaluator.
We, therefore, approximate the internal structure of black-box
components by reference to their accessible interfaces.
Deﬁnition 4: An external fault of a black-box component
is termed temporally coincident if it triggers internal faults
through different spatial entities in the component’s interface
during the same temporal usage sequence. Spatial entity may
refer to a component interface, a service provided by the
component, a parameter passed to the component upon service
invocation, or a data element of the parameter. The choice of
the spatial entity is referred to as spatial resolution.
Figure 3 depicts the relationship between the considered
spatial entities. An example for a temporally coincident fault
of a black-box component with a spatially coarse-grained
resolution is when services of different component interfaces
are invoked with illegal parameter values within a single
injection run. An example of a ﬁne-grained spatial resolution
is the simultaneous modiﬁcation of two individual bits within
the same parameter.
Note that
the redeﬁnition of temporal coincidence for
black-box components requires the previously introduced no-
tion of temporal usage sequences. We recognize that the tem-
poral and spatial dimensions of fault models are not indepen-
dent for black-box components. Depending on the considered
temporal resolution (i.e., the choice of the temporal usage
sequence) only a subset of spatial entity choices (i.e., spatial
resolutions) is possible: If an individual service invocation is
the temporal scope, only different parameters of that service or
multiple locations within one parameter are possible choices
for temporally coincident spatial entities. We develop fault
models for these two cases in the following section.
V. EXPERIMENTAL EVALUATION
We deﬁne three simultaneous fault models according to
the temporal coincidence notion developed in Section IV (C3)
and investigate the impact of these models on the evaluation
efﬁciency, taking masking and ampliﬁcation effects into ac-
count (C4). We conclude that the evaluation effort resulting
from the higher numbers of experiments for simultaneous fault
injections is well justiﬁed in this case study (C2). Before going
into the details of the developed models and their performance,
we brieﬂy describe the experimental setup for our case study.
A. Experimental Setup
We apply SWIFI to the Windows CE 4.21 operating system
(OS), speciﬁcally targeting device drivers. Device drivers are
known to be error prone and constitute a common cause for
OS failures [18], [19], [20], [21]. We therefore choose to
investigate the effects that device driver failures have on the
overall system by injecting faults at the OS’s driver interface
and observing the results at
its application interface. The
approach is similar to previous studies [22], [6] and aims at the
identiﬁcation of vulnerable OS services, so that runtime fault-
tolerance mechanisms (e.g., [23]) can be selectively applied if
required.
Windows CE loads device drivers as dynamically linked
library (DLL) binaries. We use a serial port driver and an Eth-
ernet driver for our case study. Both drivers export a Windows
stream driver interface [24]. The serial port driver imports
the CEDDK [25] and COREDLL [26] kernel interfaces. The
Ethernet driver imports COREDLL and NDIS [27].
We inject external faults at the kernel interface by intercept-
ing service invocations between the drivers and the kernel, and
modifying parameter and return values passed to the kernel.
Service invocations at the kernel/driver interface are triggered
by synthetic workloads designed to trigger executions of the
targeted drivers. The applied failure detectors are capable of
detecting four different classically known outcomes of an
injection run [28]. Upon fault injection the system may respond
with the following:
• Not Failing (NF) in any detectable manner
• Failing without violating OS speciﬁcations by delivering
wrong, yet plausible results (Application Error, AE)
• Violating the service speciﬁcation of an individual OS
service upon which the application fails and becomes
unresponsive (Application Hang, AH)
• System Crash (SC), rendering the whole system unavail-
able and often necessitating a manual restart.
B. Fault Models: From Discrete to Simultaneous
Our injection framework supports a large number of fault
models with a variety of injection triggers and latencies.
While it supports various injection locations, i.e., injections
1The choice of Windows CE is deliberate for (a) its structure being
representative for a large class of component-based software systems and (b)
its wide research usage providing an extensive published basis to objectively
compare results for a variety of single-fault models.
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 07:56:01 UTC from IEEE Xplore.  Restrictions apply. 
into device driver binaries as well as injections into service
parameter values, we only consider the latter in our evaluation
because of the strong effects this difference in location has
on the evaluation outcome [3], [29]. For parameter value
corruptions the framework supports three classical discrete
fault models.
• Bit ﬂips (BF): An individual bit in the binary representa-
tion of the passed parameter value is being ﬂipped, i.e.,
altered to one if it was zero and vice versa.
• Fuzzing (FZ): A passed parameter value is replaced by a
random value of the same binary length.
• Data type-speciﬁc (DT): A passed parameter value is
replaced by a data type-speciﬁc boundary value, e.g.,
MAXINT, MININT, −1, 0, 1 for the integer data type.
We use BF and FZ models as a basis for constructing three
temporally simultaneous fault models (C3), i.e., models of
faults that are activated within the same temporal usage
sequence in different spatial locations. We choose individual
service invocations as the considered temporal usage sequence.
Simultaneous faults can then manifest themselves as faults
in distinct parameters of the same service call or as distinct
faults within one single parameter of the targeted service call,
depending on the spatial resolution.
1) The Simultaneous FuzzFuzz Model: While the fuzzing
fault model mandates the replacement of an individual pa-
rameter value of a service call, the FuzzFuzz model applies
fuzzing to two distinct parameters of the same service in-
vocation. Note that fuzzing is only usefully applicable for
spatial resolutions lower than the individual parameter level:
If fuzzing was simultaneously applied to the same parameter,
the resulting injection would not differ from a single fuzzing
injection (one parameter value is replaced by a random value).
Consider a service invocation foo(a,b) to a component
under evaluation. Fuzzing mandates to replace either parameter
value a or b by a random value. If fuzzing was applied to the
same parameter twice, the result would be indistinguishable
from a single parameter fuzzing. We therefore consider si-
multaneously fuzzing different parameters with the FuzzFuzz
model, thereby implicitly restricting its applicability to services
that are taking at least two parameters as inputs.