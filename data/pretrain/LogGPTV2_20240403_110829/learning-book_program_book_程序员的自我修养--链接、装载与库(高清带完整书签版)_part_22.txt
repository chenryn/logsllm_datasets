---
## Page 123
100
第4章静态链接
Object Flle A
Ovtput File
File Heade
.text
re Heder
Objet File B
bextsecton
date sectior
data
bessectlon
Object File C
bss
图4-2实际的空间分配策略
正如我们前文所提到的，“.bss”段在目标文件和可执行文件中并不占用文件的空间，但
是它在装载时占用地址空间。所以链接器在合并各个段的同时，也将“.bss”合并，并且分
配虚拟空间。从“.bss”段的空间分配上我们可以思考一个间题，那就是这里的所谓的“空
间分配”到底是什么空间？
一个是在输出的可执行文件中的空间：第二个是在装载后的虚拟地址中的虚拟地址空间，对
间，因为它们在这两者中都存在：面对于“.bss”这样的段来说，分配空间的意文只局限于
虚拟地址空间，因为它在文件中并没有内容，事实上，我们在这里谈到的空间分配只关注于
虚拟地址空间的分配，因为这个关系到链接器后面的关于地址计算的步骤，面可执行文件本
身的空间分配与链接过程关系并不是很大。
关于可执行文件和虚拟地址空间之间的关系清参考第10章“可执行文件的装载与进程”。
现在的链接器空间分配的策略基本上都采用上述方法中的第二种，使用这种方法的链接
器一般都采用一种叫两步链接（Two-passLinking）的方法。也就是说整个链接过程分两步。
程序员的自我修养——链接、装载与库
---
## Page 124
4.1空间与地址分配
101
第一步空间与地址分配扫描所有的输入目标文件，并且获得它们的各个段的长度、
属性和位置，并且将输入目标文件中的符号表中所有的符号定义和符号引用收集起来，统
放到一个全局符号表。这一一步中，链接器将能够获得所有输入目标文件的段长度，并且将它
们合并，计算出输出文件中各个段合并后的长度与位置，并建立映射关系。
第二步符号解析与重定位使用上面第-步中收集到的所有信息，读取输入文件中段
的数据、重定位信息，并且进行符号解析与重定位、调整代码中的地址等。事实上第二步是
链接过程的核心，特别是重定位过程。
我们使用Id链接器将“ao”和“b.o”链接起米：
$1d a.o b.o -e main =o ab
-emain表示将 main函数作为程序入口，ld链接器默认的程序入口为_start。
-0ab表示链接输出文件名为ab，默认为a.out。
让我们使用objdump来查看链接前后地址的分配情况，代码如清单4-1所示。
清单4-1链接前后各个段的属性
$objdump -h a.0
Sections:
Idx Name
22000000000000000000000000000000
Size
VMA
LMA
File off Algn
0.text
CONTENTS,
ALLOC, LOAD, RELOC, READONLY, CODE
1data
00000000
0000000000000000
89000000
2.bss
2789000000000000000000000000000000
CONTENTS, ALLOC, LOAD, DATA
ALLOC
$ objdump -h b.o
Sections :
Idx Name
0.text
02TS
0000003e000000000000000000000034
VMA
LMA
File offAlgn
，ALLOC, LOAD, READONLY, CODE
2**2
1.data
CONTENTS,
00000004
2200000000000000000000000
CONTENTS, ALLOC, LOAD, DATA
2.bss
2▪Z82000000000000000000000000000000
ALLOC
$objdunp -h ab
Sections:
Idx Name
0.text
Size
VMA
LMA
File off Algn
1,data
CONTENTS,
000000040804910808049108000001082**2
ALLOC, LOAD, READONLY, CODE
CONTENTS, ALLOC, LOAD, DATA
程序员的自我修养一链接、装载与库
---
## Page 125
102
第4章静态链接
VMA表示Virtual Memory Address，即虚拟地址，LMA 表示 Load Memory Address，
即加载地址，正常情况下这两个值应该是一样的，但是在有些嵌入式系统中，特别是
在都些程序放在ROM的系统中时，LMA和VMA是不相同的。这里我们只要关注VMA
即可。
链接前后的程序中所使用的地址已经是程序在进程中的虚拟地址，即我们关心上面各个
段中的VMA（Virtual Memory Address）和 Size，而忽略文件偏移（File off）。我们可以
看到，在链接之前，目标文件中的所有段的VMA都是0，因为虚拟空间还没有被分配，所
以它们默认都为0。等到链接之后，可执行文件“ab”中的各个段都被分配到了相应的虚拟
地址。这里的输出程序“ab”中，“text”段被分配到了地址0x08048094，大小为0x72字节：
“.data”段从地址0x08049108开始，大小为4字节。整个链接过程前后，目标文件各段的
分配、程序虚拟地址如图4-3所示。
8.0
Process Virtual
Memory Layout
0x34Flle Header
Operating
ab
System
0xC0000000
0x34text section
b.o
.text
0x72
0x34
File Header
0x0
data
0x0804910C
0x3e
.lext section
data
0x08049108
.data
text
0x08048166
0x0
section
0x08048094
图4-3目标文件、可执行文件与进程空间
我们在图4-3中忽略了像.comment这种无关紧要的段，只关心代码段和数据段。由于在
代码段被先后叠加起来，合并成“ab”的一个.Jext段，加起来的长度为0x72。所以“ab”
的代码段里面肯定包含了main函数和swap函数的指令代码，
程序员的自我修养一链接、装载与库
---
## Page 126
4.2符号解析与重定位
103
分配0x08049108？而不是从虚拟空间的0地址开始分配呢？这涉及操作系统的进程虚拟地
址空间的分配规则，在Linux下，ELF可执行文件默认从地址0x08048000开始分配。关于
进程的虚拟地址分配等相关内容我们将在第6章“可执行文件的装载与进程”这一章进行详
细的分析。
4.1.3符号地址的确定
我们还是以“ao”和“b.o”作为例子，米分析这两个步骤中链接器的工作过程，在第
一步的扫描和空间分配阶段，链接器按照前面介绍的空间分配方法进行分配，这时候输入文
件中的各个段在链接后的虚拟地址就已经确定了，比如“.text”段起始地址为0x08048094.
“.data”段的起始地址为0x08049108。
当前面一步完成之后，链接器开始计算各个符号的虚拟地址，因为各个符号在段内的相
只不过链接器须要给每个符号加上一个偏移量，使它们能够调整到正确的虚拟地址，比如我
并以后，“a.o“的“.text“段位于虚拟地址0x08048094，那么“main”的地址应该是0x08048094
偏移为0，所以“main”这个符号在最终的输出文件中的地址应该是0x08048094+0，即
0x08048094。我们也可以通过完全一样的计算方法得知所有符号的地址，在这个例子里面，
只有三个全局符号，所以链接器在更新全局符号表的符号地址以后，各个符号的最终地址如
表4-1所示。
表 4-1
符号类型地址
main
函数
0x08048094
swap
函数
0x080480c8
shared
变量
0x08048108
4.2符号解析与重定位
4.2.1重定位
在完成空间和地址的分配步骤以后，链接器就进入了符号解析与重定位的步骤，这也是
静态链接的核心内容。在分析符号解析和重定位之前，首先让我们来看看“ao”里面是怎
程序员的自我修养一链接、装载与库
---
## Page 127
104
第4章静态链接
么使用这两个外部符号的，也就是说我们在”ac“的激程序里面使用了“shared"变量和"swap”
函数，那么编译器在将“ae”编译成指令时，它如何访问“shared”变量？如何调用“swap”
函数？
$objdump -d a.0
a.0:
Eile format elf32-i386
Disassembly of section .text:
00000000 1
0 :
8d 4c 24 04
83 e4 f0
lea
and
0x4 ($esp) , becx
4 :
ff 71 fc
push1
Oxfffffffc(ecx)
$oxfffffffo, 8esp
a :
:q
89 e5
55
push
gesp, tebp
$ebp
d:
51
push
moV
83 ec 24
sub
$0x24,e8p
Becx
11 :
e:
c7 45 f8 64 00 00 00
TAOU
$0x64,0xfffffff8 ($ebp)
18 :
1f :
c7 44 24 04 00 00 00
00
mov1
$0x0,0x4 ($esp)
20 :
8d 45 f8
1ea
Oxfffffff8 ($ebp) , $eax
23 :
890424
26 :
e8 fe ff ff ff
Ca11
nov
27 
Beax, (Besp)
2b: