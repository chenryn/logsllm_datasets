### 优化后的文本

#### 代码逻辑解析
```c
if (*(_DWORD *)a2 == *(_DWORD *)a4 && *(_DWORD *)a2 && !memcmp(*(const void **)(a2 + 4), *(const void **)(a4 + 4), *(_DWORD *)a2)) {
    v5 = 1;
    if (!v4) {
        v4 = &v9;
    }
    v6 = a3;
    if (!a3) {
        v6 = &v9;
    }
    if (*v4 == *v6) {
        if (!*v4 || !memcmp((const void *)v4[1], (const void *)v6[1], *v4)) {
            v5 = 0;
        }
    }
}

// 如果判断失败，则会再次调用CryptVerifyCertificateSignatureEx验证签名。
// 这次会验证该证书是否由系统信任证书签发，如果没有验证成功，就会进入ChainLogMSRC54294Error函数记录错误日志。
if (v37 > 0) {
    if (CryptVerifyCertificateSignatureEx(0, 1u, 2u, pvSubject, 2u, pvIssuer, 0, 0)) {
        goto LABEL_40;
    }
    v27 = *(_DWORD *)(v9 + 0x108);
    ChainLogMSRC54294Error((PCCERT_CONTEXT)pvIssuer);
    v26 = v37 == 0;
}
```

#### 算法参数比较
接下来展示伪造根证书的自定义算法参数，并与真正的Microsoft ECC Product Root Certificate Authority 2018证书的算法参数进行比较。

##### 伪造根证书的自定义算法参数
```plaintext
dx -r1 (*((combase!_CRYPTOAPI_BLOB *)0x568cec))
(*((combase!_CRYPTOAPI_BLOB *)0x568cec)) [Type: _CRYPTOAPI_BLOB]
    [+0x000] cbData: 0x15b [Type: unsigned long]
    [+0x004] pbData: 0x5691d6 : 0x30 [Type: unsigned char *]

db 0x5691d6 l15b
005691d6  30 82 01 57 02 01 01 30-3c 06 07 2a 86 48 ce 3d  0..W...0.....k..-....n.
00569266  81 41 12 03 14 08 8f 50-13 87 5a c6 56 39 8d 8a  .A.....P..Z.V9..
00569276  2e d1 9d 2a 85 c8 ed d3-ec 2a ef 03 15 00 a3 35  ...*.....*.....5
00569286  92 6a a3 19 a2 7a 1d 00-89 6a 67 73 a4 82 7a cd  .j...z...jgs..z.
00569296  ac 73 04 61 04 c7 11 16-2a 76 1d 56 8e be b9 62  .s.a....*v.V...b
005692a6  65 d4 c3 ce b4 f0 c3 30-ec 8f 6d d7 6e 39 bc c8  e......0..m.n9..
005692b6  49 ab ab b8 e3 43 78 d5-81 06 5d ef c7 7d 9f ce  I....Cx...]..}..
005692c6  d6 b3 90 75 de 0c b0 90-de 23 ba c8 d1 3e 67 e0  ...u.....#...>g.
005692d6  19 a9 1b 86 31 1e 5f 34-2d ee 17 fd 15 fb 7e 27  ....1._4-.....~'
005692e6  8a 32 a1 ea c9 8f c9 7e-18 cb 2f 3b 2c 48 7a 7d  .2.....~../;,Hz}
005692f6  a6 f4 01 07 ac 02 31 00-ff ff ff ff ff ff ff ff  ......1.........
00569306  ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff  ................
00569316  c7 63 4d 81 f4 37 2d df-58 1a 0d b2 48 b0 a7 7a  .cM..7-.X...H..z
00569326  ec ec 19 6a cc c5 29 73-02 01 01                 ...j..)s...
```

##### 真正的Microsoft ECC Product Root Certificate Authority 2018证书的算法参数
```plaintext
dx -r1 (*((combase!_CRYPTOAPI_BLOB *)0x579b7c))
(*((combase!_CRYPTOAPI_BLOB *)0x579b7c)) [Type: _CRYPTOAPI_BLOB]
    [+0x000] cbData: 0x7 [Type: unsigned long]
    [+0x004] pbData: 0x579506 : 0x6 [Type: unsigned char *]

db 0x579506 l7
00579506  06 05 2b 81 04 00 22
```

#### 证书链验证过程
`ChainGetMatchInfoStatus` 和 `CryptVerifyCertificateSignatureEx` 函数关系着每一层证书的验证。可以通过在这两个函数下设置断点来推测整个证书链的验证过程。

1. 获取用户证书并为其建立 `CCertObject` 结构。
2. 通过 `ChainGetMatchInfoStatus` 函数判断该证书的 `Issuer` 和 `Subject` 字段是否相同（目的是为了找到自签名证书）。
3. 通过一个大循环来判断这些证书，直到找到可以通过 `ChainGetMatchInfoStatus` 和 `CryptVerifyCertificateSignatureEx` 验证的自签名证书。
4. 为自签名证书建立 `CChainPathObject` 结构（验证的方向是从根证书向下的）。
5. 调用 `ChainGetSubjectStatus` 函数验证自签名证书对证书的签名是否正确，如果正确则设置属性和标志。
6. 通过 `FindElementInCollectionStore` 函数寻找和自签名证书相匹配的系统信任证书，并为其建立 `CChainPathObject` 结构。
7. 再次调用 `ChainGetSubjectStatus` 函数，比较伪造证书和找到的证书公钥散列值是否相同，相同则成功返回。
8. 循环这一过程，直到所有证书都验证通过。

#### 创建CERT_CHAIN_CONTEXT结构
当成功返回 `CCertChainEngine::CreateChainContextFromPathGraph` 函数并进行一些额外校验后，会调用 `CChainPathObject::CreateChainContextFromPath` 函数来创建 `CERT_CHAIN_CONTEXT` 结构，其包含简单证书链和一个信任状态结构。

```plaintext
dt CERT_CHAIN_CONTEXT @eax
combase!CERT_CHAIN_CONTEXT
   +0x000 cbSize: 0x38
   +0x004 TrustStatus: _CERT_TRUST_STATUS
   +0x00c cChain: 1
   +0x010 rgpChain: 0x005eac64 -> 0x005eac68 _CERT_SIMPLE_CHAIN
   +0x014 cLowerQualityChainContext: 0
   +0x018 rgpLowerQualityChainContext: (null)
   +0x01c fHasRevocationFreshnessTime: 0n1
   +0x020 dwRevocationFreshnessTime: 0xcd
   +0x024 dwCreateFlags: 0x48000001
   +0x028 ChainId: _GUID {00000000-0000-0000-0000-000000000000}

dt _CERT_SIMPLE_CHAIN 0x005eac68
combase!_CERT_SIMPLE_CHAIN
   +0x000 cbSize: 0x20
   +0x004 TrustStatus: _CERT_TRUST_STATUS
   +0x00c cElement: 2
   +0x010 rgpElement: 0x005eac88 -> 0x005eac90 _CERT_CHAIN_ELEMENT
   +0x014 pTrustListInfo: (null)
   +0x018 fHasRevocationFreshnessTime: 0n1
   +0x01c dwRevocationFreshnessTime: 0xcd

dx -r1 ((combase!_CERT_CHAIN_ELEMENT *)0x5eac90)
((combase!_CERT_CHAIN_ELEMENT *)0x5eac90) [Type: _CERT_CHAIN_ELEMENT *]
   [+0x000] cbSize: 0x20 [Type: unsigned long]
   [+0x004] pCertContext: 0x568ee0 [Type: _CERT_CONTEXT *]
   [+0x008] TrustStatus [Type: _CERT_TRUST_STATUS]
   [+0x010] pRevocationInfo: 0x5eaf58 [Type: _CERT_REVOCATION_INFO *]
   [+0x014] pIssuanceUsage: 0x5ea618 [Type: _CTL_USAGE *]
   [+0x018] pApplicationUsage: 0x5e9d08 [Type: _CTL_USAGE *]
   [+0x01c] pwszExtendedErrorInfo: 0x0 [Type: wchar_t *]

dx -r1 ((combase!_CERT_CONTEXT *)0x568ee0)
((combase!_CERT_CONTEXT *)0x568ee0) [Type: _CERT_CONTEXT *]
   [+0x000] dwCertEncodingType: 0x1 [Type: unsigned long]
   [+0x004] pbCertEncoded: 0x568408 : 0x30 [Type: unsigned char *]
   [+0x008] cbCertEncoded: 0x299 [Type: unsigned long]
   [+0x00c] pCertInfo: 0x568b98 [Type: _CERT_INFO *]
   [+0x010] hCertStore: 0x55ee70 [Type: void *]

dx -r1 ((combase!_CERT_CHAIN_ELEMENT *)0x5eacb0)
((combase!_CERT_CHAIN_ELEMENT *)0x5eacb0) [Type: _CERT_CHAIN_ELEMENT *]
   [+0x000] cbSize: 0x20 [Type: unsigned long]
   [+0x004] pCertContext: 0x5e9d60 [Type: _CERT_CONTEXT *]
   [+0x008] TrustStatus [Type: _CERT_TRUST_STATUS]
   [+0x010] pRevocationInfo: 0x0 [Type: _CERT_REVOCATION_INFO *]
   [+0x014] pIssuanceUsage: 0x0 [Type: _CTL_USAGE *]
   [+0x018] pApplicationUsage: 0x0 [Type: _CTL_USAGE *]
   [+0x01c] pwszExtendedErrorInfo: 0x0 [Type: wchar_t *]

dx -r1 ((combase!_CERT_CONTEXT *)0x5e9d60)
((combase!_CERT_CONTEXT *)0x5e9d60) [Type: _CERT_CONTEXT *]
   [+0x000] dwCertEncodingType: 0x1 [Type: unsigned long]
   [+0x004] pbCertEncoded: 0x579380 : 0x30 [Type: unsigned char *]
   [+0x008] cbCertEncoded: 0x327 [Type: unsigned long]
   [+0x00c] pCertInfo: 0x579b40 [Type: _CERT_INFO *]
   [+0x010] hCertStore: 0x5722d0 [Type: void *]
```

#### 漏洞总结
在非对称加密算法中，每个主体有一对密钥，即公钥和私钥。公钥是公开的，私钥是自己保留的。用公钥加密的信息可以使用对应的私钥来解密，而在另一个场景下，用私钥加密的信息可以使用对应的公钥来解密。在签名算法中，主体使用其私钥来进行签名，如果他人可成功使用该主体的公钥解开其签名的内容，那证明这个东西确实是该主体签的（因为理论上除了他自己，没人会知道他的私钥）。

在ECC加密算法中，公钥Q、私钥d和基点G的关系是Q = d×G。只给出公钥Q和基点G是很难推测出私钥d的。但在证书标准中允许指定自定义算法参数，这其中包括基点G。crypt32库中对自签名证书的验证主要是通过检查其与系统信任证书的公钥哈希值是否匹配（使用自签名证书对下级证书进行验证，然后再比较这个自签名证书和系统信任证书公钥散列值是否相同），而忽略了对算法参数的检查。这使得攻击者可以选取一对基点G'、私钥d'，使得 d'×G' = Q（要伪造证书的公钥）。攻击者可将要伪造的证书算法参数中的基点G修改为自己构造的G'（也可以修改其它参数，只要保证 d'×G' = Q即可），然后同时也拥有了和伪造证书相匹配的私钥d'。攻击者可选择伪造系统信任的证书，并使用伪造的私钥对其他证书进行签名，然后进一步可对恶意程序等进行签名。由于签名具有不可否认性，存在此漏洞的系统就会认为这证书确实是由那个被伪造证书的主体签发的，然后恶意程序的数字签名就会被验证通过。

另外，可通过提取并判断自签名证书中的算法参数来检测针对该漏洞的攻击，即该ECC证书提供了自定义算法参数，但并不能完全匹配标准的椭圆曲线参数，尤其在其公钥和已知证书相同的情况下。

#### 参考文章
（请在此处添加参考文章链接或详细信息）