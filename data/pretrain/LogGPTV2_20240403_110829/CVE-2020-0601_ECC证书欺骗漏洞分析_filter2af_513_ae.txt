        && a4
        && *(_DWORD *)a2 == *(_DWORD *)a4
        && *(_DWORD *)a2
        && !memcmp(*(const void **)(a2 + 4), *(const void **)(a4 + 4), *(_DWORD *)a2) )
      {
        v5 = 1;
        if ( !v4 )
          v4 = &v9;
        v6 = a3;
        if ( !a3 )
          v6 = &v9;
        if ( *v4 == *v6 )
        {
          if ( !*v4 || !memcmp((const void *)v4[1], (const void *)v6[1], *v4) )
            v5 = 0;
        }
如果判断失败，则会再次调用CryptVerifyCertificateSignatureEx验证签名，这次就会验证该证书是否由系统信任证书签发，如果没有验证成功，就会进入ChainLogMSRC54294Error函数记录错误日志。
      if ( v37 > 0 )
      {
        if ( CryptVerifyCertificateSignatureEx(0, 1u, 2u, pvSubject, 2u, pvIssuer, 0, 0) )
          goto LABEL_40;
        v27 = *(_DWORD *)(v9 + 0x108);
        ChainLogMSRC54294Error((PCCERT_CONTEXT)pvIssuer);
        v26 = v37 == 0;
      }
既然都看到这里了，就给你们展示一下算法参数吧，下面这个是编码后的自定义算法参数，来自伪造根证书（可以拿去和上面解析的证书参数进行比较）：
    0:000> dx -r1 (*((combase!_CRYPTOAPI_BLOB *)0x568cec))
    (*((combase!_CRYPTOAPI_BLOB *)0x568cec))                 [Type: _CRYPTOAPI_BLOB]
        [+0x000] cbData           : 0x15b [Type: unsigned long]
        [+0x004] pbData           : 0x5691d6 : 0x30 [Type: unsigned char *]
    0:000> db 0x5691d6 l15b
    005691d6  30 82 01 57 02 01 01 30-3c 06 07 2a 86 48 ce 3d  0..W...0.....k..-....n.
    00569266  81 41 12 03 14 08 8f 50-13 87 5a c6 56 39 8d 8a  .A.....P..Z.V9..
    00569276  2e d1 9d 2a 85 c8 ed d3-ec 2a ef 03 15 00 a3 35  ...*.....*.....5
    00569286  92 6a a3 19 a2 7a 1d 00-89 6a 67 73 a4 82 7a cd  .j...z...jgs..z.
    00569296  ac 73 04 61 04 c7 11 16-2a 76 1d 56 8e be b9 62  .s.a....*v.V...b
    005692a6  65 d4 c3 ce b4 f0 c3 30-ec 8f 6d d7 6e 39 bc c8  e......0..m.n9..
    005692b6  49 ab ab b8 e3 43 78 d5-81 06 5d ef c7 7d 9f ce  I....Cx...]..}..
    005692c6  d6 b3 90 75 de 0c b0 90-de 23 ba c8 d1 3e 67 e0  ...u.....#...>g.
    005692d6  19 a9 1b 86 31 1e 5f 34-2d ee 17 fd 15 fb 7e 27  ....1._4-.....~'
    005692e6  8a 32 a1 ea c9 8f c9 7e-18 cb 2f 3b 2c 48 7a 7d  .2.....~../;,Hz}
    005692f6  a6 f4 01 07 ac 02 31 00-ff ff ff ff ff ff ff ff  ......1.........
    00569306  ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff  ................
    00569316  c7 63 4d 81 f4 37 2d df-58 1a 0d b2 48 b0 a7 7a  .cM..7-.X...H..z
    00569326  ec ec 19 6a cc c5 29 73-02 01 01                 ...j..)s...
下面就是真正的Microsoft ECC Product Root Certificate Authority
2018证书的算法参数啦，只有7个字节，这是椭圆曲线secp384r1的OID的编码形式，其OID为1.3.132.0.34。第一个字节06指明这是一个OID类型数据，然后后面的05代表OID编码后的长度，然后OID有个编码算法，这里不再展开说明，有兴趣的话可以自己查一下。新增的对算法参数的比较就是对pCertInfo->SubjectPublicKeyInfo.Algorithm.Parameters
CRYPTOAPI_BLOB结构中内容的比较（包括参数编码长度）。看，长度明显不一样的。
    0:000> dx -r1 (*((combase!_CRYPTOAPI_BLOB *)0x579b7c))
    (*((combase!_CRYPTOAPI_BLOB *)0x579b7c))                 [Type: _CRYPTOAPI_BLOB]
        [+0x000] cbData           : 0x7 [Type: unsigned long]
        [+0x004] pbData           : 0x579506 : 0x6 [Type: unsigned char *]
    0:000> db 0x579506 l7
    00579506  06 05 2b 81 04 00 22   
由于ChainGetMatchInfoStatus函数和CryptVerifyCertificateSignatureEx函数关系着每一层证书的验证，所以可以在这两个函数下断点，从而推测整个证书链的验证过程。首先获取用户证书并为其建立CCertObject结构，通过ChainGetMatchInfoStatus函数来判断该证书的Issuer和Subject字段是否相同（目的是为了找到自签名证书）。应该有个大循环去判断这些，直到找到可以通过ChainGetMatchInfoStatus函数以及CryptVerifyCertificateSignatureEx函数验证的自签名证书，然后为其建立CChainPathObject结构（所以验证的方向应该是自根证书向下的）。然后调用ChainGetSubjectStatus函数（ChainGetSubjectStatus应该是验证Issuer对Subject的签名是否正确以及Issuer身份是否可信的一个函数）来验证自签名证书对证书的签名是否正确，正确的话设置属性和标志。当标志设置了之后又通过FindElementInCollectionStore函数寻找和自签名证书相匹配的系统信任证书，并为其建立CChainPathObject结构。之后再次调用ChainGetSubjectStatus函数，由于签名验证标志已经设置，所以只比较了伪造证书和找到的这个证书公钥散列值是否相同，相同就成功返回。然后循环这一过程，直到所有证书都验证通过。PS：可以通过CERT_INFO结构中的时间或公钥来判断是哪个证书。
当成功返回CCertChainEngine::CreateChainContextFromPathGraph函数并进行一些额外校验后会调用CChainPathObject::CreateChainContextFromPath函数来创建CERT_CHAIN_CONTEXT结构，其包含简单证书链和一个信任状态结构，可以看出这个链中的根证书是系统的根证书（我在调试的时候记住了这几个证书的cbCertEncoded的大小）。
    0:000> dt CERT_CHAIN_CONTEXT @eax
    combase!CERT_CHAIN_CONTEXT
       +0x000 cbSize           : 0x38
       +0x004 TrustStatus      : _CERT_TRUST_STATUS
       +0x00c cChain           : 1
       +0x010 rgpChain         : 0x005eac64  -> 0x005eac68 _CERT_SIMPLE_CHAIN
       +0x014 cLowerQualityChainContext : 0
       +0x018 rgpLowerQualityChainContext : (null) 
       +0x01c fHasRevocationFreshnessTime : 0n1
       +0x020 dwRevocationFreshnessTime : 0xcd
       +0x024 dwCreateFlags    : 0x48000001
       +0x028 ChainId          : _GUID {00000000-0000-0000-0000-000000000000}
    0:000> dt _CERT_SIMPLE_CHAIN 0x005eac68
    combase!_CERT_SIMPLE_CHAIN
       +0x000 cbSize           : 0x20
       +0x004 TrustStatus      : _CERT_TRUST_STATUS
       +0x00c cElement         : 2
       +0x010 rgpElement       : 0x005eac88  -> 0x005eac90 _CERT_CHAIN_ELEMENT
       +0x014 pTrustListInfo   : (null) 
       +0x018 fHasRevocationFreshnessTime : 0n1
       +0x01c dwRevocationFreshnessTime : 0xcd
    0:000> dx -r1 ((combase!_CERT_CHAIN_ELEMENT * *)0x5eac88)
    ((combase!_CERT_CHAIN_ELEMENT * *)0x5eac88)                 : 0x5eac88 [Type: _CERT_CHAIN_ELEMENT * *]
        0x5eac90 [Type: _CERT_CHAIN_ELEMENT *]
    0:000> dx -r1 ((combase!_CERT_CHAIN_ELEMENT *)0x5eac90)
    ((combase!_CERT_CHAIN_ELEMENT *)0x5eac90)                 : 0x5eac90 [Type: _CERT_CHAIN_ELEMENT *]
        [+0x000] cbSize           : 0x20 [Type: unsigned long]
        [+0x004] pCertContext     : 0x568ee0 [Type: _CERT_CONTEXT *]
        [+0x008] TrustStatus      [Type: _CERT_TRUST_STATUS]
        [+0x010] pRevocationInfo  : 0x5eaf58 [Type: _CERT_REVOCATION_INFO *]
        [+0x014] pIssuanceUsage   : 0x5ea618 [Type: _CTL_USAGE *]
        [+0x018] pApplicationUsage : 0x5e9d08 [Type: _CTL_USAGE *]
        [+0x01c] pwszExtendedErrorInfo : 0x0 [Type: wchar_t *]
    0:000> dx -r1 ((combase!_CERT_CONTEXT *)0x568ee0)
    ((combase!_CERT_CONTEXT *)0x568ee0)                 : 0x568ee0 [Type: _CERT_CONTEXT *]
        [+0x000] dwCertEncodingType : 0x1 [Type: unsigned long]
        [+0x004] pbCertEncoded    : 0x568408 : 0x30 [Type: unsigned char *]
        [+0x008] cbCertEncoded    : 0x299 [Type: unsigned long]
        [+0x00c] pCertInfo        : 0x568b98 [Type: _CERT_INFO *]
        [+0x010] hCertStore       : 0x55ee70 [Type: void *]
    0:000> dx -r1 ((combase!_CERT_CHAIN_ELEMENT * *)0x5eac88+1)
    ((combase!_CERT_CHAIN_ELEMENT * *)0x5eac88+1)                 : 0x5eac8c [Type: _CERT_CHAIN_ELEMENT * *]
        0x5eacb0 [Type: _CERT_CHAIN_ELEMENT *]
    0:000> dx -r1 ((combase!_CERT_CHAIN_ELEMENT *)0x5eacb0)
    ((combase!_CERT_CHAIN_ELEMENT *)0x5eacb0)                 : 0x5eacb0 [Type: _CERT_CHAIN_ELEMENT *]
        [+0x000] cbSize           : 0x20 [Type: unsigned long]
        [+0x004] pCertContext     : 0x5e9d60 [Type: _CERT_CONTEXT *]
        [+0x008] TrustStatus      [Type: _CERT_TRUST_STATUS]
        [+0x010] pRevocationInfo  : 0x0 [Type: _CERT_REVOCATION_INFO *]
        [+0x014] pIssuanceUsage   : 0x0 [Type: _CTL_USAGE *]
        [+0x018] pApplicationUsage : 0x0 [Type: _CTL_USAGE *]
        [+0x01c] pwszExtendedErrorInfo : 0x0 [Type: wchar_t *]
    0:000> dx -r1 ((combase!_CERT_CONTEXT *)0x5e9d60)
    ((combase!_CERT_CONTEXT *)0x5e9d60)                 : 0x5e9d60 [Type: _CERT_CONTEXT *]
        [+0x000] dwCertEncodingType : 0x1 [Type: unsigned long]
        [+0x004] pbCertEncoded    : 0x579380 : 0x30 [Type: unsigned char *]
        [+0x008] cbCertEncoded    : 0x327 [Type: unsigned long]
        [+0x00c] pCertInfo        : 0x579b40 [Type: _CERT_INFO *]
        [+0x010] hCertStore       : 0x5722d0 [Type: void *]
这个结构最终放在CertGetCertificateChain函数的第8个参数*ppChainContext中，其中CERT_TRUST_STATUS结构中存放了证书链的错误码和状态码。dwErrorStatus
为0，表示没有错误，证书是有效的。
    0:000> dt PCCERT_CHAIN_CONTEXT 00cf8b4c
    combase!PCCERT_CHAIN_CONTEXT
    0x005eab28 
       +0x000 cbSize           : 0x38
       +0x004 TrustStatus      : _CERT_TRUST_STATUS
       +0x00c cChain           : 1
       +0x010 rgpChain         : 0x005eab84  -> 0x005eab88 _CERT_SIMPLE_CHAIN
       +0x014 cLowerQualityChainContext : 0
       +0x018 rgpLowerQualityChainContext : (null) 
       +0x01c fHasRevocationFreshnessTime : 0n1
       +0x020 dwRevocationFreshnessTime : 0xcd
       +0x024 dwCreateFlags    : 0x48000001
       +0x028 ChainId          : _GUID {00000000-0000-0000-0000-000000000000}
    0:000> dx -r1 (*((combase!_CERT_TRUST_STATUS *)0x5eab2c))
    (*((combase!_CERT_TRUST_STATUS *)0x5eab2c))                 [Type: _CERT_TRUST_STATUS]
        [+0x000] dwErrorStatus    : 0x0 [Type: unsigned long]
        [+0x004] dwInfoStatus     : 0x0 [Type: unsigned long]
最后，通俗地总结一下这个漏洞吧。在非对称加密算法中，每个主体有一对密钥，即公钥和私钥。公钥是公开的，私钥是自己留下的。用公钥加密的信息可以使用对应的私钥来解密，而在另一个场景下，用私钥加密的信息可以使用对应的公钥来解密。在签名算法中，主体使用其私钥来进行签名，如果他人可成功使用该主体的公钥解开其签名的内容，那证明这个东西确实是该主体签的（因为理论上除了他自己，没人会知道他的私钥）。在ECC加密算法中，公钥Q
、私钥d和基点G的关系是Q =
d×G，只给出公钥Q和基点G是很难推测出私钥d的。而在证书标准中是允许指定自定义算法参数的，这其中包括基点G，并且crypt32库中对自签名证书的验证主要是通过检查其与系统信任证书的公钥哈希值是否匹配（使用自签名证书对下级证书进行验证，然后再比较这个自签名证书和系统信任证书公钥散列值是否相同），而忽略了对算法参数的检查。这使得攻击者可以选取一对基点G’
、私钥d’，使得 d’×G’= Q（要伪造证书的公钥）。攻击者可将要伪造的证书算法参数中的基点G修改为自己构造的G’（也可以修改其它参数，只要保证
d’×G’ =
Q即可），然后同时也拥有了和伪造证书相匹配的私钥d’。攻击者可选择伪造系统信任的证书，并使用伪造的私钥对其他证书进行签名，然后进一步可对恶意程序等进行签名。由于签名具有不可否认性，存在此漏洞的系统就会认为这证书确实是由那个被伪造证书的主体签发的，然后恶意程序的数字签名就会被验证通过。另外，可通过提取并判断自签名证书中的算法参数来检测针对该漏洞的攻击，即该ECC证书提供了自定义算法参数，但并不能完全匹配标准的椭圆曲线参数，尤其在其公钥和已知证书相同的情况下。
## 参考文章