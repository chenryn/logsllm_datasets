在线diff源码，发现 OGNL 在 v3.1.25 版本加入了基于黑名单的沙箱机制
限制对某些特定方法的调用，以及在OGNL invokeMethod()中没有(明显的)合法用例存在的某些类/接口的所
有方法的调用，比如命令执行需要的 Runtime、ProcessBuilder等。
例子：
将 OGNL 版本升到有黑名单限制的版本，执行带命令执行的表达式，会抛出以下异常
因为方法 invokeMethod() 中 调用了 isAssignableFrom() 方法判断 Class  对象所表示的类或接
口与指定的 Class  参数所表示的类或接口是否相同，或是否是其超类或超接口。如果是则返回 true ，
抛出异常：
Prevent calls to some specific methods, as well as all methods of certain 
classes/interfaces for which no (apparent) legitimate use cases exist for their 
usage within OGNL invokeMethod().
Confluence EL Injection via OGNL
No. 9 / 22
测试效果
0x03 框架 WebWork 分析
WebWork 部分:
简单介绍Confluence 是如何处理 HTTP 请求的
一张 Confluence 的架构图 (远古)
https:developer.atlassian.com/server/confluence/images/42732834.png
采用的HTTP 请求的处理框架：WebWork2, 在官网找到了一份 03 年的 ppt 有做介绍：
Q：如何绕过其内置的黑名单呢？
A：方式挺多的，这里以 ScriptEngine 为例
Confluence EL Injection via OGNL
No. 10 / 22
一张百度百科的 WebWork 架构图
把一个请求的生命周期描述得很清楚，关注3个关键部分
Confluence EL Injection via OGNL
No. 11 / 22
名称
说明
Actions
代表一次请求或调用，其Action类需要实现Action接口或继承基础类
ActionSupport，实现了默认的execute方法，并返回一个在配置文件中定义的
Result。Action也可以只是一个POJO，不用继承任何类也不用实现任何接口。
Action是一次请求的控制器，同时也充当数据模型的角色。
Results
一个结果页面的定义，用来指示Action执行之后，如何显示执行的结果。Result
Type表示如何以及用哪种视图技术展现结果。通过Result Type，WebWork可以方
便的支持多种视图技术(即Jsp、FreeMarker、Velocity等)。
Interceptors
WebWork的拦截器，WebWork截获Action请求，在Action执行之前或之后调用拦截
器方法。这样，可以用插拔的方式将功能注入到Action中。WebWork框架的很多功能
都是以拦截器的形式提供出来。例如：参数组装，验证，国际化，文件上传等等。
以动态调试的方式跟一下大致的处理流程
com.opensymphony.webwork.dispatcher.ServletDispatcher#service 下断点
发起请求
http:10.1.1.1:8090/xxx/login.action
命中断点
经过一系列的 Filter 处理后，走到 ServletDispatcher#service ,接着会调用以下方法获取相应的值
以 getNameSpace() 为例,其处理流程如下：
this.getNameSpace()
this.getActionName() 
this.getRequestMap()
this.getParameterMap() 
this.getSessionMap()
request.getServletPath()  getNamespaceFromServletPath(servletPath)  
servletPath.substring(0, servletPath.lastIndexOf("/"))
Confluence EL Injection via OGNL
No. 12 / 22
namespace  请求路径最后一个 /  之前的内容
若请求 /login.action   namespace 就是 ""
若请求 /xxx/login.action   name 则等于 /xxx
如图：
然后会走到 DefaultActionInvocation#invoke ，首先获取一个实现了List接口的数组，有 32 个拦
截器
开始迭代循环
com.opensymphony.xwork.DefaultActionInvocation#invoke 
com.opensymphony.xwork.interceptor.AroundInterceptor#intercept 
com.opensymphony.xwork.DefaultActionInvocation#invoke 
Confluence EL Injection via OGNL
No. 13 / 22
当 resultCode 不为 null  时则跳出循环，然后执行 this.executeResult() -> 
this.createResult() ,根据 resultCode 获取 resultConfig
接着调用 ObjectFactory#buildResult()  构建 result , 获取到 login.action 对应的模板文
件位置 /login.vm
此时 this.result  对应的类为 EncodingVelocityResult  继承自 
WebWorkResultSupport ， this.result.execute()  调用的是 
WebWorkResultSupport.execute()
Confluence EL Injection via OGNL
No. 14 / 22
可见都会执行到 execute(),实现该方法的类也不多，就8个，而且 ActionChainResult  明晃晃地
排在首位
然后在方法 Result#excute()  里调用 TextParseUtil#translateVariables()  对 Variable 
进行 Translate
最后再调用 VelocityResult#doExecute()  使用 Velocity 模板引擎加载模板文件 login.vm  
进行渲染，然后返回结果。
# 题外话 (事后诸葛亮)
如果在分析 Confluence 历史漏洞时肯耐心地像这样梳理一遍 Confluence 对 HTTP 请求的处理过
程，其实只要跟进了 translateVariables() 方法里，还是有很大地机会挖到 CVE-2022-26134 
的，毕竟 findValue() 就在那里 :)
# 若 expression 可控
可以构造形如 ${xxx} 的 payload，触发 stack.findValue()，达到 RCE 的效果
Confluence EL Injection via OGNL
No. 15 / 22
如图：
至此，Confluence 的 HTTP 请求的处理流程梳理完毕。
流程总结：
客户端发起对 /xxx/login.action  的 HTTP 请求
经过一系列 Filter 处理后，会走到 ServletDispatcher#service()  进行分发请求
通过 this.getNameSpace()、this.getActionName()等方法获取所需的属性，如: namespace等
会对 拦截器数组进行迭代循环，直到 resultCodenull 跳出循环
根据 resultCode  构建 this.result  并获取 login.action 对应的模板文件 /login.vm
执行 this.result.excute() 时会调用 translateVariables() 对一些变量进行 Translate
Converted object from variable translation.
会对表达式进行解析，存在 OGNL Injection 的风险
最后就是加载模板文件进行处理 & 渲染，然后返回给客户端。
0x04 CVE-2022-26134 pre-auth RCE
Security Advisory
Confluence - CVE-2022-26134 - Critical severity unauthenticated RCE 
vulnerability
Atlassian has been made aware of current active exploitation of a critical 
severity unauthenticated remote code execution vulnerability in Confluence Data 
Center and Server. The OGNL injection vulnerability allows an unauthenticated user 
to execute arbitrary code on a Confluence Server or Data Center instance. 
关键信息:
漏洞条件: unauthenticated  不需要任何权限
漏洞利用:
OGNL injection  漏洞本质 表达式语言 OGNL 的问题
Confluence EL Injection via OGNL
No. 16 / 22
补丁分析
diff补丁
移除了 ActionChainResult#execute()  中对 TextParseUtil.translateVariables()  的调
用。在 0x03 小节中，已经知道 translateVariables() 是存在 OGNL Injection 风险的:
现在只需要分析出如何触发 ActionChainResult#execute()  中的 OGNL Injection 即可。
com.opensymphony.xwork.ActionChainResult#execute
如图所示，调用 translateVariables()  对 namespace 进行处理，而 namespace 在 0x03  小
节中已确认为可控点:
Confluence EL Injection via OGNL
No. 17 / 22
所以 26134  也就呼之欲出了。
构造 poc 验证想法
1. 在 namespace 处插入 OGNL 表达式
如图，发现和预想的结果并不一样
经过之前的分析已知，对 /login.cation  请求在构建 result  时，取得的类是继承自 
WebWorkResultSupport 的 EncodingVelocityResult ，最后执行的 Result#excute()  是
WebWorkResultSupport ，而不是 ActionChainResult 。
回忆一下：
针对 /xxx/login.action 的请求，在构建 this.result  时会根据 resultCode"input"  
从 Map results  中取 resultConfig ，其 ClassName 决定了调用 Result#execute()
的子类。
/${2*2}/login.action
Q: 问题来了，如何构造请求可让其执行到 ActionChainResult#execute() 呢 ？
Confluence EL Injection via OGNL
No. 18 / 22
所以若想要调用到 ActionChainResult#execute() ，需要控制 resultConfig 的 className 为 
ActionChainResult, resultConfig 由 resultCode 决定
从 results  分析可得，当  resultCode 等于以下值时:
可以让执行流程成功进入到 ActionChainResult#execute()。
最后对 notpermitted 进行搜索找到以下描述
notpermittedpersonal
readonly
notpermitted
notfound
Q: 该如何构造请求让其 resultCode 等于以上值呢 ？
A: 暂时没啥思路，只能继续啃文档。
Confluence EL Injection via OGNL
No. 19 / 22
顾名思义，访问一个没有权限的路径即可？比如图中的 /dashboard.action 。
再次构造 poc 验证想法
2. 在 namespace 处插入 OGNL 表达式
如图，和预想的结果一样，resultCode  notpermitted
执行流程走到 ActionChainResult#execute , 调用 TextParseUtil.translateVariables 对 
namespace 进行处理。
如图:
/${2*2}/dashboard.action
Confluence EL Injection via OGNL
No. 20 / 22
将 ${} 中的表达式提取出来执行，成功触发 OGNL Injection。
至此, 漏洞分析部分结束。 
整个过程中，不管是梳理 Conflunence 的 HTTP 请求的处理流程时"意外"发现 OGNL Sink ，还是从 
Sink 逐步定位到 Source ，都还蛮有意思。
漏洞复现
弹计算器
执行成功
curl -kI 
"http:10.1.1.1:8090/%24%7B%40java.lang.Runtime%40getRuntime%28%29.exec%28%22c
alc%22%29%7D/dashboard.action"
Confluence EL Injection via OGNL
No. 21 / 22
0x05 小结
未完待续。。。
Confluence Velocity SSTI 
Confluence OGNL Injection
Confluence Post-Exploitation
参考:
1. https:commons.apache.org/proper/commons-ognl/
2. https:y4er.com/posts/cve-2022-26134-confluence-server-data-center-ognl-rce/
3. https:baike.baidu.com/item/webwork/486050
不足之处还请师傅们多多指点和纠正, respect
考虑到文章中难免会出现错误，所以后续若有纠正会在个人博客：https:pen4uin.github.io/ 进行
修改
Confluence EL Injection via OGNL
No. 22 / 22