以下是优化后的文本，使其更加清晰、连贯和专业：

---

### 参考文献

[55] Kai Lei, Yining Ma, and Zhi Tan. 2014. 性能比较与评估：PHP、Python 和 Node.js 的 Web 开发技术. In 2014 IEEE 第十七届计算科学与工程国际会议. IEEE, 661–668.

[56] Zhiming Liu, Nafees Qamar, and Jie Qian. 2013. 医疗数据去标识化工具的性能和可扩展性的定量分析. In 国际健康信息学基础工程与系统研讨会. Springer, 274–289.

[57] Goran Martinovic, Josip Balen, and Bojan Cukic. 2012. 最新 Windows 操作系统的性能评估. J. UCS 18, 2 (2012), 218–263.

[58] MDN. 2020. WebAssembly.Memory(). https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WebAssembly/Memory

[59] MDN. 2021. Number.MAX_SAFE_INTEGER - JavaScript: MDN. https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/MAX_SAFE_INTEGER

[60] Tianhui Meng, Katinka Wolter, and Qiushi Wang. 2015. 移动卸载系统在时序攻击下的安全性和性能权衡分析. In 欧洲性能工程研讨会. Springer, 32–46.

[61] Microsoft. 2020. 下载新版 Microsoft Edge 浏览器: Microsoft. https://www.microsoft.com/en-us/edge

[62] Mnater. 2021. Mnater/Hyphenator. https://github.com/mnater/Hyphenator

[63] Mnater. 2021. Mnater/Hyphenator/Hyphenopoly-Loader.js. https://github.com/mnater/Hyphenator/blob/master/Hyphenator_Loader.js

[64] Mnater. 2021. Mnater/Hyphenopoly. https://github.com/mnater/Hyphenopoly

[65] Mnater. 2021. Mnater/Hyphenopoly/Hyphenopoly-Loader.js. https://github.com/mnater/Hyphenopoly/blob/master/Hyphenopoly_Loader.js

[66] Mozilla. 2020. Firefox: 为人民服务，而非盈利. https://www.mozilla.org/en-US/

[67] Mozilla. 2020. WebAssembly 内存. https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WebAssembly/Memory

[68] Mozilla. 2021. Geckoview. https://mozilla.github.io/geckoview/

[69] Mozilla. 2021. SpiderMonkey JavaScript/WebAssembly 引擎. https://spidermonkey.dev/docs/

[70] Marius Musch, Christian Wressnegger, Martin Johns, and Konrad Rieck. 2019. 新生力量：WebAssembly 在实际应用中的普及研究. In 国际入侵检测、恶意软件和漏洞评估会议. Springer, 23–42.

[71] Shravan Narayan, Craig Disselkoen, Daniel Moghimi, Sunjay Cauligi, Evan Johnson, Zhao Gang, Anjo Vahldiek-Oberwagner, Ravi Sahita, Hovav Shacham, Dean Tullsen, and Deian Stefan. 2021. Swivel: 防御 Spectre 攻击的 WebAssembly 硬化. In 第三十届 USENIX 安全研讨会 (USENIX Security 21). USENIX 协会, 1433–1450. https://www.usenix.org/conference/usenixsecurity21/presentation/narayan

[72] Shravan Narayan, Tal Garfinkel, Sorin Lerner, Hovav Shacham, and Deian Stefan. 2019. Gobi: 实用路径上的 WebAssembly 库沙箱. arXiv 预印本 arXiv:1912.02285 (2019).

[73] Wasm pack 贡献者. 2019. Wasm 速度并不比 JS 快. https://github.com/rustwasm/wasm-pack/issues/558

[74] Senthil Padmanabhan and Pranav Jha. 2020. eBay 中的 WebAssembly：一个实际案例. https://tech.ebayinc.com/engineering/webassembly-at-ebay-a-real-world-use-case/

[75] Louis-Noël Pouchet, U Bondugula, and T Yuki. 2016. PolyBench/C 4.2. 多面体基准套件.

[76] Raghu Ramakrishnan and Arvinder Kaur. 2020. 网页性能预测模型的经验比较. 信息技术与软件技术 (2020), 106307.

[77] Alan Romano, Xinyue Liu, Yonghwi Kwon, and Weihang Wang. 2021. WebAssembly 编译器中错误的实证研究. In 2021 年第 36 届 IEEE/ACM 自动化软件工程国际会议 (ASE).

[78] Alan Romano and Weihang Wang. 2020. WASim: 通过分类理解 WebAssembly 应用程序. In 2020 年第 35 届 IEEE/ACM 自动化软件工程国际会议 (ASE). 1321–1325. https://doi.org/10.1145/3324884.3415293

[79] Alan Romano and Weihang Wang. 2020. WasmView: WebAssembly 应用程序的可视化测试. In 第 42 届国际软件工程大会伴刊 (首尔, 韩国) (ICSE’20 Companion). 计算机协会, 纽约, 美国, 4 页. https://doi.org/10.1145/3377812.3382155

[80] Alan Romano, Yunhui Zheng, and Weihang Wang. 2020. MinerRay: 语义感知分析以实现不断进化的挖矿检测. In 2020 年第 35 届 IEEE/ACM 自动化软件工程国际会议 (ASE). 1129–1140. https://doi.org/10.1145/3324884.3416580

[81] Prabhjot Sandhu, David Herrera, and Laurie Hendren. 2018. 网络上的稀疏矩阵：JavaScript 和 WebAssembly 中稀疏矩阵向量乘法的性能特征和最优格式选择. In 第 15 届托管语言与运行时国际会议论文集. 1–13.

[82] Marija Selakovic and Michael Pradel. 2016. JavaScript 中的性能问题和优化：一项实证研究. In 第 38 届国际软件工程会议论文集. 61–72.

[83] Yuliang Shi, Xudong Zhao, Shanqing Guo, Shijun Liu, and Lizhen Cui. 2016. SRConfig: 一种用于提高 n 层应用程序性能的互依赖软配置经验方法. In 2016 年 IEEE 服务计算国际会议 (SCC). IEEE, 601–608.

[84] Daniel Smilkov, Nikhil Thorat, and Ann Yuan. 2020. 介绍 TensorFlow.js 的 WebAssembly 后端. https://blog.tensorflow.org/2020/03/introducing-webassembly-backend-for-tensorflow-js.html

[85] The Clang Team. 2020. clang - Clang C, C++, and Objective-C 编译器. https://clang.llvm.org/docs/CommandGuide/clang.html#cmdoption-o0 — Clang 11 文档.

[86] Leaning Technologies. 2020. Cheerp | C/C++ 到 WebAssembly 编译器. https://leaningtech.com/pages/cheerp.html

[87] Aaron Turner. 2018. WebAssembly 很快：WebAssembly 与 ES6 的真实世界基准测试. https://medium.com/@torch2424/webassembly-is-fast-a-real-world-benchmark-of-webassembly-vs-es6-d85a23f8e193

[88] Vladimir. 2018. WebAssembly 对比其他技术. 是否应该使用 WebAssembly? https://blog.sqreen.com/webassembly-performance/

[89] W3C. 2021. Web Cryptography API. https://w3c.github.io/webcrypto/

[90] Evan Wallace. 2016. Evanw/thinscript: 一种受 TypeScript 启发的低级编程语言. https://github.com/evanw/thinscript

[91] Conrad Watt, John Renner, Natalie Popescu, Sunjay Cauligi, and Deian Stefan. 2019. CT-Wasm: 面向 Web 生态系统的类型驱动安全加密. Proc. ACM Program. Lang. 3, POPL, Article 77 (Jan. 2019), 29 页. https://doi.org/10.1145/3290390

[92] Junjun Zheng, Hiroyuki Okamura, and Tadashi Dohi. 2016. 基于 VM 的入侵容忍系统的性能评估. In 2016 年第四届计算与网络国际研讨会 (CANDAR). IEEE, 181–187.

### A. Google Chrome 中使用的实验参数

表 11: Google Chrome 参数

| 章节       | 图表/表格   | 参数                                   | 影响                                                         |
|------------|-------------|----------------------------------------|--------------------------------------------------------------|
| 第 4.2 节  | 图 5, 6     | chrome.exe                             | 防止浏览器缓存基准测试                                       |
|            | 表 2        | --incognito                            |                                                              |
| 第 4.3 节  | 图 9        | chrome.exe --incognito                 | 防止浏览器缓存基准测试                                       |
|            | 表 3, 4, 5, 6 |                                        |                                                              |
| 第 4.4 节  | 图 10       | chrome.exe --incognito                 | 防止浏览器缓存基准测试                                       |
|            | 表 7        |                                        |                                                              |
|            | 图 10       | chrome.exe --js-flags="--no-opt" --incognito | 默认情况下（无额外参数），同时启用 LiftOff 和 TurboFan 编译器。 "–no-opt" 仅对 JavaScript 基准测试启用 LiftOff 编译器。 |
|            | 表 7        |                                        |                                                              |
|            | 图 10       | chrome.exe --js-flags="--liftoff --no-wasm-tier-up" --incognito | "–liftoff –no-wasm-tier-up" 仅对 WebAssembly 基准测试启用 LiftOff 编译器。 |
|            | 表 7        |                                        |                                                              |
|            | 图 10       | chrome.exe --js-flags="--no-liftoff --no-wasm-tier-up" --incognito | "–no-liftoff –no-wasm-tier-up" 仅对 WebAssembly 基准测试启用 TurboFan 编译器。 |
| 第 4.5 节  | 图 11, 12   | chrome.exe --incognito                 | 防止浏览器缓存基准测试                                       |
|            | 表 8        |                                        |                                                              |
| 第 4.6 节  | 表 9, 10, 11 | chrome.exe --incognito                 | 防止浏览器缓存基准测试                                       |

表 11 显示了我们在第 4 节各小节中使用 Google Chrome 的参数及其对结果的影响。

### B. 编译器优化结果的统计分析

图 11 显示了桌面版 Chrome 上不同优化级别下 JS、WASM 和 x86 的执行时间、代码大小和内存使用的统计数据。x 轴表示执行时间、代码大小和内存使用的结果，y 轴表示结果的五数摘要：最小值、第一四分位数、中位数、第三四分位数和最大值。

总体而言，JS、WASM 和 x86 的执行时间随优化级别的变化而变化。虽然 JS 和 WASM 在不同优化级别下的执行时间中位数接近 1，但 x86 在 O1/O2 和 Oz/O2 优化级别下的执行时间中位数高于 1（O1/O2 为 1.29，Oz/O2 为 1.16）。这一结果与表 2 中 x86 执行时间的几何平均值一致（O1/O2 为 1.36 倍，Oz/O2 为 1.22 倍）。另一方面，代码大小和内存使用的变化很小，接近 1 倍，除了 'x86 Code Size Ofast/O2'。根据表 2，x86 代码大小在 Ofast/O2 优化级别下的几何平均值为 1.11 倍，这与图 11 中的结果一致。

### C. Long.js 中的操作

表 12: Long.js 操作数量

| 基准测试    | 乘法         | 除法         | 余数         | JS/WASM ADD | MUL | DIV | REM | SHIFT | AND | OR | 总计 |
|-------------|--------------|--------------|--------------|--------------|-----|-----|-----|-------|-----|----|------|
| JS          | 510k         | 350k         | 550k         | 0            | 0   | 160k| 10k | 20k   | 0   | 100k| 10k  |
| WASM        | 60k          | 60k          | 60k          | 100k         | 10k | 100k| 0   | 110k  | 0   | 160k| 0    |
|             | 80k          | 0            | 170k         | 0            | 0   | 0   | 0   | 0     | 0   | 0  | 10k  |
|             | 120k         | 30k          | 10k          | 30k          | 120k| 30k | 110k| 0     | 0   | 0  | 0    |
|             | 20k          | 20k          | 20k          | 20k          | 20k | 20k | 20k | 20k   | 20k | 20k| 20k  |

为了获得 Long.js 程序中的算术操作数量，我们手动检测了 JavaScript 和 WebAssembly 程序的算术操作。表 12 显示了结果。观察到 JavaScript 版本运行的指令数量远多于 WebAssembly 版本。

这是因为这些 64 位操作在 WebAssembly 中涉及较少的计算。具体来说，WebAssembly 通过将每个 64 位整数输入视为两个 32 位整数来执行计算，并将结果合并为一个 64 位整数。相比之下，Long.js 库通过将一个 64 位整数拆分为四个 16 位整数来避免溢出 [23]。

### D. 不同浏览器和平台的结果

图 12 显示了 WebAssembly 和 JavaScript 在桌面版 Chrome、桌面版 Firefox、桌面版 Edge、移动版 Chrome、移动版 Firefox 和移动版 Edge 上的执行时间。每个基准测试都使用默认输入进行测试，编译器优化级别为 -O2。

图 13 显示了 WebAssembly 和 JavaScript 在桌面版 Chrome、桌面版 Firefox、桌面版 Edge、移动版 Chrome、移动版 Firefox 和移动版 Edge 上的内存使用情况。这些结果的统计数据汇总在表 8 中。

---

希望这些优化后的文本能够更好地传达信息并提高整体质量。如果有任何进一步的需求或修改，请告诉我。