如果由于某种原因目的地是不可到达的，则 IP 模块将通知 TCP 模块，然后 TCP 模块
通知 Telnet 虚拟终端服务，最后 Telnet 将在屏幕上显示一个报文，通知用户这个报文是不
可传递的。
另一类 ICMP 报文被称为“ 源断开” 报文。它是一种拥塞控制方法。如果在 IP 网关接
收了较多的包，超出控制能力，则可以靠 ICMP 进行摆脱，典型做法是经过缓冲器析溢出，
然后网关发出一个“ 源断开” 报文，以命令发送模块降低发送率。这些报文只是在短期生
效。接收到“ 源断开” 报文后，暂时降低了传输率。然后自动逐渐恢复一直到达原来的传
输率为止。当接到新的“ 源断开” 报文时，再次降低传输率。“ 源断开” 报文增强了基于窗
口的流量控制能力。
ICMP 报文的另一种类型仍旧是路由选择变化请求，它有几种不同的请求内容。例如，
大，当网关得知所选择的网关不是去目的地的最佳网关时，便向源主机发送一个“ 重定向
数据请求”。这些报文也用来规定重定向某些类型的服务。当网关接到一个标有生存期限的
包时，便发送一个“ 长路由通知”。当 IP 模块遇到生存期满的包时，也通知源主机。
第四类 ICMP 报文用于计时打印请求和确认。这些报文用于估算网络上的平均往复时
延，以便确定特定的程序所使用的最佳传输率和路由（传输设备）。为了估算这种往复时延
使用了四种计时打印：
（1）发送方计时打印请求包。
（2）当接收方接收到包时打印包。
（3）当它发送回答报文时再次打印。
（4）当源发方接收到回答报文时打印回答报文。
计时打印（2）和（3）提供了处理这种信息需要多长时间的基本估算，计时打印（1）
和（4）提供了包在网络上传输所需时间总量。反复计算多次打印可产生平均时延。
5.6.3  传输控制协议（TCP）
原始的 TCP/IP 主机是经过电话线连接的。70 年代早期通信工具和当今的通信设备截
然不同，线路的噪声非常大，不能处理数据，因此 TCP 协议具有严格的内装差错检验算法
确保数据的完整性。下面几段文章解释了 TCP 协议的结构严格性。
TCP 是重要的传输层协议，它和 UDP 不同，传输层软件 TCP 的目的是允许数据同网
络上的另外站点进行可靠的交换。它能提供端口编号的译码，以识别主机的应用程序，而
且完成数据的可靠传输。
为了说明 TCP 结构的严格性，让我们先来打个比方。假设你正在向某人讲述一个故事。
如果那个人只是站在那里不应答你，你将不能辩明他是否了解你所讲述的内容。如果那个
人用点头之类的方式应答，那么你将知道你所讲的话他是了解的，因此能继续同他交谈。
与此相似，TCP 协议使用顺序编号和确认信息同网络上另外的站点交谈。使用顺序编号来
确定包内数据的排序并发现故障的包。因为网际上不同的包不一定会以发送它们的顺序到
达（例如，路由器废弃一系列传输包中的某一个），所以要对包中的数据进行排序，以确保
与发送的顺序相同。此外，接收站点还可能接收两个同样的包，为了进行可靠类型的通信，
使用带有确认信息的顺序编号，这种处理被称为全双工。连接的每一端都必须考虑到另一
端的需要而维持它自己的顺序编号。
第五章通信协议简介
- 133 -
TCP 是面向字节的顺序协议，这意味着包内的每个字节被分配一个顺序编号，并分配
给每包一个顺序编号。分配给包那每个字节的顺序编号可以合理的重复。
TCP 的顺序编号方法与它的产生年代有关，那时的通信手段落后，不是所有的网络都
采用这种办法（使用一个独立的传输层软件）。例如：NetWare 是依靠网络层软件传输数据
NetWare 控制协议提供包的顺序编号。
为可靠的完成数据传输任务，TCP 将报文或数据分成可管理的长度并加上 TCP 头。图
5-3 表示一个 TCP 头。它描述了 TCP 头中一些主要的字段：
图 5-3  TCP 头信息
源端口（16 位）。源发站点的端口编号。
目的地端口（16 位）。接收站点的端口编号。
顺序号数（32 位）。分配给 TCP 包的编号。
除设置 SYN 位指出包的开始字节编号外，如果设置了这个位，顺序编号是最初的顺序
号数（ISN），第一个数据字节是 ISN+1。
确认编号数（32 位）。
目的地站点向源站点发送的编号。对以前所接收的包（或许多包）表明确认。该序号
指出目的地站点希望接收下一个顺序编号。一旦建立了连接就始终设置这个字段。
数据偏移（4 位）。
指出 TCP 头的长度（即 TCP 头中的 32 位字的数）。它表明数据开始和 TCP 头结束。
对于正常的 20 字节的头，这个字段设置成 0101。
保留位（6 位）。
为未来使用而保留。必须设置为 0。
控制位（6 位）。
用作个别控制位，见表 5-6。
表 5-6  控制位的取值及其含义
URG
紧急指示字段
ACK
如果设置，该包包含确认。
PSH
推入功能
RST
恢复连接。用于这种情况：一个功能是不接收连接请求
SYN
用于建立序号（同步序号）。
- 134 -
Linux网络编程
FIN
数据不在从连接的发送点进入，结束总报文。
窗口（16 位）。
窗口字段也称接收窗口大小，表示在 TCP 连接上准备由主机接收的的 8 位字节的数目。
CRC 校验和（16 位）。
一个差错检验数，用于确定被接收的数据报文在传输期间是否被讹误。包括 TCP 头和
所有数据。
紧急指示字段（16 位）。
它指出了紧接紧急数据的字节的顺序编号。
选项。
长度变量，它考虑到 TCP 使用的各种选项：
（1）选项表的结束
（2）无操作
（3）最大分段长度
TCP 提供的主要服务有：
（1）建立、维持和终结两个进程之间的连接。
（2）可靠的包传递（经过确认过程）。
（3）编序包（可靠的数据传送）。
（4）控制差错的机制。
（5）通过使用端口，允许在个别的源和目的地主机内部实现和不同进程多重连接的能
力。
（6）使用全双工操作的数据交换。
5.6.4  用户数据报文协议
UDP 也是 TCP/IP 的传输层协议，它是无连接的，不可靠的传输服务。当接收数据时
它不向发送方提供确认信息，它不提供输入包的顺序，如果出现丢失包或重份包的情况，
也不会向发送方发出差错报文。这一点很象 IP 协议。UDP 的主要作用是分配和管理端口
编号，以正确无误的识别运行在网络站点上的个别应用程序。由于它执行功能时具有低的
开销，因而执行速度比 TCP 快。它多半用于不需要可靠传输的应用程序，例如网络管理域，
域名服务器等。
图 5-4  UDP 头
第五章通信协议简介
- 135 -
任何与 UDP 相配合作为传输层服务的应用程序必须提供确认和顺序系统，以确保包是
以发送它们的同样顺序到达。也就是说，使用 UDP 的应用程序必须提供这类服务。（参见
后面章节中关于 tftp 协议的介绍）
图 5-4 表示一个一个 UDP 头，应用数据被封装在 UDP 头那。传输层具有它自己的，
与所有其它层不相关的帧头。然后 UDP 头及其数据被封装在 IP 头内，由 IP 协议将这个数
据报文发送到数据链路层，依次下去，数据链路层又使用它的帧头包装这个报文，最后将
数据送到物理层实际传输。
当接收包时，数据链路层将把地址解释为它自己的，剥去它的帧头，将包传递给 IP 层，
IP 层将根据 IP 头上的正确 IP 地址接受包。剥去它的头，最后将包交给 UDP 软件，UDP
接受包，而且必须按 UDP 头上的端口编号进行译码。
5.7  小结
本章介绍了几种 LAN 协议。其中，着重讨论了 TCP/IP 协议。
TCP/IP 现在正在被越来越多的团体用户所接收。目前 TCP/IP 已经演变成最成熟的联
网环境之一。事实上最近几年来 TCP/IP 和 UNIX 已经提供了多厂家产品互联性的模式，
TCP/IP 的最大价值是它的不同平台之间提供互联性的能力。
在 OSI 真正履行自己的承诺以前，不太完善的通信协议结构，如 SNA、DECnet 和 TCP/IP
将继续流行。
- 136 -
Linux网络编程
第六章  Berkel ey 套接字
6.1  引言
网络程序设计全靠套接字接受和发送信息，尽管套接字这个词好象显得有些神秘，但
其实这个概念极易理解。
这章主要讲述 Sockets API（Application Program Interface），以及一些其他的细节（比
如 Socket 的历史、数据中的常用结构等），通过这些介绍，使读者慢慢掌握 Linux 下的 Socket
编程。
6.2  概述
在开始介绍有关编程的知识之前，首先让我们来了解一些与 socket 有关的背景知识。
6.2.1  Socket 的历史
在 80 年代早期，远景研究规划局（Advanced Research Projects Agency, ARPA）资助了
佳利福尼亚大学伯克利分校的一个研究组，让他们将 TCP/IP 软件移植到 UNIX 操作系统
中，并将结果提供给其他网点。作为项目的一部分，设计者们创建了一个接口，应用进程
使用这个接口可以方便的进行通信。他们决定，只要有可能就使用以有的系统调用，对那
些不能方便的容入已有的函数集的情况，就再增加新的系统调用以支持 TCP/IP 功能。
这样做的结果就出现了插口接口（Berkeley Socket），这个系统被称为 Berkeley UNIX
或 BSD UNIX。(TCP/IP 首次出现在 BSD 4.1 版本 release 4.1 of Berkeley Software
Distribution)。
由许多计算机厂商，都采用了 Berkeley UNIX，于是许多机器上都可以使用 Socket 了。
这样，Socket 接口就被广泛使用，到现在已经成为事实上的标准。（图 6-1）
6.2.2  Socket 的功能
Socket 的英文原意就是“ 孔” 或“ 插座”，现在，作为 BSD UNIX 的进程通讯机制，
取其后一种意义。日常生活中常见的插座，有的是信号插座，有的是电源插座，有的可以
接受信号（或能量），有的可以发送信号（或能量）。假如电话线与电话机之间安放一个插
座（相当于二者之间的接口，这一部分装置物理上是存在的）则 Socket 非常相似于电话插
座。
将电话系统与面向连接的 Socket 机制相比，有着惊人相似的地方。以一个国家级的电
话网为例。电话的通话双方相当于相互通信的两个进程；通话双方所在的地区（享有一个
全局唯一的区号）相当于一个网络，区号是它的网络地址；区内的一个单位的交换机相当
于一台主机，主机分配给每个用户的局内号码相当于 Socket 号（下面将谈到）。
第 6 章  berkeley 套接字
- 137 -
图 6-1  socket 接口示意图
任何用户在通话之前，首先要占有一部电话机，相当于申请一个 Socket 号；同时要知
道对方的电话号码，相当于对方有一个 Socket。然后向对方拨号呼叫，相当于发出连接请
求（假如对方不在同一区内，还要拨对方区号，相当于给出网络地址）。对方假如在场并
空闲（相当于通信的另一主机开机且可以接受连接请求），拿起电话话筒，双方就可以正
式通话，相当于连接成功。双方通话的过程，是向电话机发出信号和从电话机接受信号的
过程，相当于向 Socket 发送数据和从 Socket 接受数据。通话结束后，一方挂起电话机，
相当于关闭 Socket，撤消连接。
在电话系统中，一般用户只能感受到本地电话机和对方电话号码的存在，建立通话的
过程、话音传输的过程以及整个电话系统的技术细节对它都是透明的，这也与 Socket 机制
非常相似。Socket 利用网间网通信设施实现进程通信，但它对通信设施的细节毫不关心，
只要通信设施能提供足够的通信能力，它就满足了。
至此，我们对 Socket 进行了直观的描述。抽象出来，Socket 实质上提供了进程通信的
端点。进程通信之前，双方首先必须各自创建一个端点，否则是没有办法建立联系并相互
通信的。正如打电话之前，双方必须各自拥有一台电话机一样。
每一个 Socket 都用一个半相关描述：
{协议，本地地址，本地端口}
一个完整的 Socket 则用一个相关描述
{协议，本地地址，本地端口，远程地址，远程端口}
每一个 Socket 有一个本地的唯一 Socket 号，由操作系统分配。
最重要的是，Socket 是面向客户－服务器模型而设计的，针对客户和服务器程序提供
不同的 Socket 系统调用。客户随机申请一个 Socket 号（相当于一个想打电话的人可以在
- 138 -
Linux网络编程
任何一台入网的电话上拨叫呼叫）；服务器拥有全局公认的 Socket，任何客户都可以向它
发出连接请求和信息请求（相当于一个被呼叫的电话拥有一个呼叫方知道的电话号码）。
Socket 利用客户—服务器模式巧妙的解决了进程之间建立通信连接的问题。服务器
Socket 为全局所公认非常重要。两个完全随机的用户进程之间，因为没有任何一方的 Socket
是固定的，就像打电话却不知道别人的电话号码，要通话是不可能的。
6.2.3  套接字的三种类型
套接字有三种类型：流式套接字（SOCK_STREAM），数据报套接字（SOCK_DGRAM）
及原始套接字。
1．流式套接字（SOCK_STREAM）
流式的套接字可以提供可靠的、面向连接的通讯流。如果你通过流式套接字发送了顺
序的数据：“ 1”、“ ２”。那么数据到达远程时候的顺序也是“ １”、“ ２”。
流式套接字可以做什么呢？你听说过 Telnet 应用程序吗？听过？哦，最常用的 BBS 服
务，以及系统的远程登陆都是通过 Telnet 协议连接的。Telnet 就是一个流式连接。你是否
希望你在 Telnet 应用程序上输入的字符（或汉字）在到达远程应用程序的时候是以你输入
的顺序到达的？答案应该是肯定的吧。还有 WWW 浏览器，它使用的 HTTP 协议也是通过
流式套接字来获取网页的。事实上，如果你 Telnet 到一个 Web Site 的 80 端口上，然后输
入 “ GET 网页路径名” 然后按两下回车（或者是两下 Ctrl+回车）然后你就得到了“ 网页
路径名” 所代表的网页！
流式套接字是怎样保证这种应用层次上的数据传输质量呢？它使用了 TCP（The
Transmission Control Protocol）协议（可以参考 RFC-793 来得到 TCP 的细节）。TCP 保证
了你的数据传输是正确的，并且是顺序的。TCP 是经常出现的 TCP/IP 中的前半部分。IP
代表 Internet Protocol（因特网协议，参考 RFC-791）IP 只处理网络路由。
第 6 章  berkeley 套接字
- 139 -
图 6-2  面向连接的 socket 的工作流程
2．数据报套接字（SOCK_DGRAM）
数据报套接字定义了一种无连接的服务，数据通过相互独立的报文进行传输，是无序
的，并且不保证可靠，无差错。原始套接字允许对低层协议如 IP 或 ICMP 直接访问，主要
用于新的网络协议实现的测试等。
数据报套接字（Datagram Sockets）怎样呢？为什么它叫做“ 无连接” ？应该怎样处理
它们呢？为什么它们是不可靠的？好的，这里有一些事实：
如果你发送了一个数据报，它可能不会到达。
它可能会以不同的顺序到达。
如果它到达了，它包含的数据中可能存在错误。
数据报套接字也使用 IP，但是它不使用 TCP，它使用使用者数据报协议 UDP（User
Datagram Protocol 可以参考 RFC 768）
为什么说它们是“ 无连接” 的呢？因为它（UDP）不像流式套接字那样维护一个打开
- 140 -
Linux网络编程
的连接，你只需要把数据打成一个包，把远程的 IP 贴上去，然后把这个包发送出去。这个
过程是不需要建立连接的。UDP 的应用例子有： tftp, bootp 等。
那么，数据包既然会丢失，怎样能保证程序能够正常工作呢？事实上，每个使用 UDP
的程序都要有自己的对数据进行确认的协议。比如， TFTP 协议定义了对于每一个发送出
去的数据包，远程在接受到之后都要回送一个数据包告诉本地程序：“ 我已经拿到了！”（一
个 “ ACK”  包）。如果数据包发的送者在 5 秒内没有的得到回应，它就会重新发送这个
数据包直到数据包接受者回送了 “ ACK”  信号。这些知识对编写一个使用 UDP 协议的
程序员来说是非常必要的。
无连接服务器一般都是面向事务处理的，一个请求一个应答就完成了客户程序与服务
程序之间的相互作用。若使用无连接的套接字编程，程序的流程可以用图 6-3 表示。
图 6-3  无连接的 socket 工作流程
面向连接服务器处理的请求往往比较复杂，不是一来一去的请求应答所能解决的，而
且往往是并发服务器。使用面向连接的套接字编程,可以通过图 6-2 来表示。
套接字工作过程如下:服务器首先启动，通过调用 socket()建立一个套接字，然后调用
bind()将该套接字和本地网络地址联系在一起，再调用 listen()使套接字做好侦听的准备，
并规定它的请求队列的长度,之后就调用 accept()来接收连接。客户在建立套接字后就可调
用 connect()和服务器建立连接。连接一旦建立，客户机和服务器之间就可以通过调用 read()
和 write()来发送和接收数据。最后，待数据传送结束后，双方调用 close()关闭套接字。
3．原始套接字
原始套接字主要用于一些协议的开发，可以进行比较底层的操作。它功能强大，但是
没有上面介绍的两种套接字使用方便，一般的程序也涉及不到原始套接字。
第 6 章  berkeley 套接字
- 141 -
6.3  Li nux 支配的网络协议
网络协议是系统进行系统与系统间通讯的的接口。在 Linux 系统上， TCP/IP