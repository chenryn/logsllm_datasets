Theorem 2 (Strong Compositionality) Let P be the process keys
(k1, . . . ,kn).(I1(cid:2)!S1| . . .|In(cid:2)!Sn). Then (cid:14) (cid:15) P : [] if and only if (cid:14) (cid:15)
keys(k1, . . . ,kn).Ii(cid:2)!Si : [],∀i ∈ [1, n].
As a corollary, a protocol is safe if so are all the protocol partici-
pants. In addition, judging a participant safe only requires knowl-
edge of the long-term keys it shares with other participants. This is
a fairly mild assumption as the information conveyed by the keys is
relative to identities of the parties sharing them, not to the protocol
they are running. Consequently, unlike similar results proved of
existing typing systems for authentication, notably [11, 12], Theo-
rem 2 may be directly applied to the veriﬁcation of multi-protocol
system (see [20, 21] for details). This ﬂexibility has a price, how-
ever, in that our result relies critically on the run-time checks on the
message tags provided by pattern-matching.
4. A CASE STUDY
We illustrate our system with a slightly modiﬁed version of the
SPLICE/AS Protocol (see the remark at the end of this section):
Msg 1 B → A : B, nB
Msg 2 A → B : A, B,{|B, nB,{|nA|}Pub(kB)|}Priv(kA)
Msg 3 B → A : {|B, nA|}Pub(kA)
This protocol should mutually authenticate A and B. In the ﬁrst two
messages, B exploits a POSH nonce handshake to authenticate A, as
nB is sent in clear and received encrypted. In the second message,
A sends a (nested) challenge to B using a SOSH scheme. How-
ever, this second part is ﬂawed as shown by the following attack
sequence:
Msg 2.a
E : B, nB
A : B, nB
B →
Msg 1.a
Msg 1.b E(B) →
A → E(B) : A, B,{|B, nB,{|nA|}Pub(kB)|}Priv(kA)
Msg 2.b
E →
B : E, B,{|B, nB,{|nA|}Pub(kB)|}Priv(kE)
B →
E : {|B, nA|}Pub(kE)
Msg 3.a
A : {|B, nA|}Pub(kA)
Msg 3.b E(B) →
There are two parallel sessions: a and b. Session a is between
E and B, and E exploits such a session to impersonate B with A in
session b. In particular, the enemy uses B as an oracle to decrypt
message {|nA|}Pub(kB) (messages 2.a and 3.a). Looking at corre-
spondence assertions we have a commit(A, B) 3 (session b) which
does not match run(B, E) (session a). Notice that this attack is sim-
ilar to the well known one on the Needham-Schroeder public-key
protocol [17]. In ρ-spi calculus , we capture these attack sequences
thanks to the possibility of providing the enemy with long-term
keys.
Since the protocol is unsafe it cannot be type-checked. We give
the intuition of why this happens. A may be speciﬁed as follows:
(Msg 1)
(Msg 2)
(Msg 3)
in(B, x) .
new(nA) . encrypt {nA}Pub(kB) as z .
encrypt {B, x, z}Priv(kA) as w . out(A, B, w) .
in(y).decrypt y as {B, nA}Priv(kA).commit(A, B)
There is no tagging that makes the sequential process above type-
check. In particular, rule SOPH/SOSH COMMIT requires that the
nonce nA has type nonce(B, A). This implies that the encryption of
this nonce is regulated by the rule SOPH/SOSH INQUIRY . This
rules always requires an identity label tagged by Id to be encrypted
with the nonce, which is not the case in encrypt {nA}Pub(kB) as z.
Since type-checking fails because of a missing identiﬁer, it is
natural to add it in order to try and repair the protocol. As a matter
of fact changing message 2 into:
Msg 2 A → B : A, B,{|B, nB,{|A, nA|}Pub(kB)|}Priv(kA)
{|Id(A), Verif?(nA)|}Pub(kB)|}Pr i v (kA)
{|B, nA|}Pub(kA)
we obtain the repaired protocol suggested by Gavin Lowe in [19].
To see how this protocol is checked using our type and effect sys-
tem, consider the following tagged version of it:
Msg 1 B → A : B, nB
Msg 2 A → B : A, B,{|Id(B), Verif(nB),
Msg 3 B → A :
In Message 2, A communicates to B that B is the veriﬁer of
the current authentication session and asks B whether or not he
is willing to start an authentication session with her. Thus, we
tag nB by Verif and nA by Verif?.
In the second ciphertext, B
sends back the nonce thus no tag is needed. The ρ-spi calcu-
lus speciﬁcation of the protocol is reported in Table 7: notice that
we analyze an unbounded number of sessions, where A and B play
both the initiator and the responder role. To check mutual au-
thentication, we alternatively decorate the protocol with two dif-
ferent pairs of correspondence primitives run1(I, J), commit1(J, I)
and run2(I, J), commit2(J, I). Each of these pairs checks one di-
rection of authentication, i.e., Initiator with respect to Responder
and vice-versa. For the sake of readability we have written both
3When two parties do not want to authenticate any message, we use
an empty message (cid:6), which is omitted by the speciﬁcation together
with Auth((cid:6))
the decorations together, but the typing is performed by consider-
ing only one of them at a time. The protocol can be typed (with
respect to each of the decorations) with empty effect and environ-
ment, i.e., /0 (cid:15) ProtocolS : []. The rule used for typing each primitive
is reported on the right side.
This speciﬁcation can be easily extended to prove the protocol
correct even with an unbounded number of entities (see [10] for
details).
Remark 1. In the original version of the SPLICE/AS protocol,
the format of Message 2 is
A, B,{|A, nB,{|nA|}Pub(kB)|}Priv(kA)
with A, rather than B, as the entity identiﬁer of the top-level en-
crypted packet. With our present system, there is no tagging for
this message enabling a successful validation of the protocol. We
believe the problem can be circumvented, and the protocol veriﬁed,
by enhancing the system to allow (messages encrypted by) public
keys to be treated as entity identiﬁers, and to be tagged as such.
5. CONCLUSION AND RELATED WORK
We have proposed a type and effect system for authentication
protocols. We have tested our analysis on several authentication
protocols. Some results are reported in Table 8: in all cases, the
analysis provide safety proofs for the correct versions of the pro-
tocols, while it consistently fails to validate the ﬂawed versions
(CCITT X.509 passes our analysis since it provides authentication
even if it is affected by an attack on conﬁdentiality). The main
advantages of our proposal are
• scalability: since the authentication guarantees are local, safe
sequential processes (possibly modeling different protocols)
may be safely composed together;
• limited human effort: tagging is simple as it just requires to
disambiguate the meaning of identiﬁers and nonces in some
encrypted messages;
• simplicity: the type and effect system is simple but expres-
sive enough to verify many existing protocols.
Moreover, our analysis can verify authentication in presence of en-
emies provided with long-term keys. This kind of analysis is not
carried out in [11, 12].
The set of rules presented here and in [10] is general enough for
analyzing many of the authentication protocols presented in liter-
ature. However we are now studying a method to “mechanically”
extend the set of authentication rules, so that the safety result is
preserved. The idea is to give meta-rules that dictate the shape of
“good rules”. We are also developing a tool for type checking and
tag inference.
Related Work. Tagging is not a new idea and it is proposed and
used for veriﬁcation purposes in [3, 4, 11, 12, 16]. Typically, tag-
ging amounts to add a different label to each encrypted protocol
message, so that ciphertexts cannot be confused. Our tagging is less
demanding, as we do not require that every message is unambigu-
ously tagged since we tag only certain components. In particular,
for protocols implemented with stronger tagging techniques, our
tags can be safely removed without compromising the protocols’
safety.
The Strand Spaces formalism [13, 14, 15, 22] is an interesting
framework for studying authentication. There are interesting simi-
larities between our analysis and the way the three kinds of nonce-
handshakes are checked in Strand Spaces. It would be interesting to
explore how our type system could be applied in such a framework,
in order to provide mechanical proofs of safety.
The recent work by Bodei et al. on a control-ﬂow analysis for
message authentication in Lysa [6, 5] is also strongly related to our
present approach. The motivations and goals, however, are differ-
ent, since message authentication concerns the origin of a message
while agreement provides guarantees about the presence in the cur-
rent session of the claimant and its willingness to authenticate with
the veriﬁer.
Finally, we are currently formally comparing our type and effect
system with the one by Gordon and Jeffrey [11, 12] and investigat-
ing a possible encoding of the former within the latter.
6. REFERENCES
[1] M. Abadi and C.Fournet. Private authentication. In Proceedings of
the 2002 Workshop on Privacy Enhancing Technologies, Lecture
Notes in Computer Science, pages 27–40. Springer-Verlag, 2003.
[2] M. Abadi and A. D. Gordon. A calculus for cryptographic protocols:
The spi calculus. Information and Computation, 148(1):1–70, 1999.
[3] M. Abadi and R. Needham. Prudent engineering practice for
cryptographic protocols. IEEE Transactions on Software
Engineering, 22(1):6–15, 1996.
[4] B. Blanchet and A. Podelski. Veriﬁcation of cryptographic protocols:
Tagging enforces termination. Proceedings of Foundations of
Software Science and Computation Structures, pages 136–152, 2003.
[5] C. Bodei, M. Buchholtz, P. Degano, F. Nielson, and H. Riis Nielson.
Automatic validation of protocol narration. In Proceedings of the
16th IEEE Computer Security Foundations Workshop (CSFW’03),
pages 126–140. IEEE Computer Society Press, June 2003.
[6] C. Bodei, M. Buchholtz, P. Degano, F. Nielson, and H. Riis Nielson.
Control ﬂow analysis can ﬁnd new ﬂaws too. In Proceedings of the
Workshop on Issues on the Theory of Security (WITS’04), ENTCS.
Elsevier, 2004.
[7] M. Boreale. Symbolic trace analysis of cryptographic protocols. In
Proceedings of ICALP 01, volume 2076, pages 667–681. LNCS
2076, Springer Verlag, 2001.
[8] M. Boreale, R. De Nicola, and R. Pugliese. Proof techniques for
cryptographic processes. In Logic in Computer Science, pages
157–166, 1999.
[9] M. Bugliesi, R. Focardi, and M. Maffei. Principles for entity
authentication. In Proceedings of 5th International Conference
Perspectives of System Informatics (PSI 2003), volume 2890 of
Lecture Notes in Computer Science, pages 294–307. Springer-Verlag,
July 2003.
[10] M. Bugliesi, R. Focardi, and M. Maffei. Compositional analysis of
authentication protocols. In Proceedings of European Symposium on
Programming (ESOP 2004), volume 2986 of Lecture Notes in
Computer Science, pages 140–154. Springer-Verlag, 2004.
[11] A. Gordon and A. Jeffrey. Authenticity by typing for security
protocols. In Proceedings of 14th IEEE Computer Security
Foundations Workshop (CSFW’01), pages 145–159. IEEE Computer
Society Press, June 2001.
[12] A. Gordon and A. Jeffrey. Types and effects for asymmetric
cryptographic protocols. In Proceedings of 15th IEEE Computer
Security Foundations Workshop (CSFW’02), pages 77–91. IEEE
Computer Society Press, 24-26 June 2002.
[13] J.D. Guttman, F.J. Thayer, J.A. Carlson, J.C.Herzog, J.D. Ramsdell,
and B.T. Sniffen. Trust management in strand spaces: a
rely-guarantee method. In Proceedings of European Symposium on
Programming (ESOP 2004), volume 2986 of Lecture Notes in
Computer Science, pages 325–339. Springer-Verlag, 2004.
[14] Joshua D. Guttman and F. Javier Thayer. Protocol independence
through disjoint encryption. In Proceedings of 13th IEEE Computer
Security Foundations Workshop (CSFW’00), pages 24–34. IEEE
Computer Society Press, July 2000.
[15] Joshua D. Guttman and F. Javier Thayer. Authentication tests and the
structure of bundles. Theoretical Computer Science, 283(2):333–380,
2002.
[16] J. Heather, G. Lowe, and S. Schneider. How to prevent type ﬂaw
attacks on security protocols. In Proceedings of 13th IEEE Computer
Table 7 Amended SPLICE/AS Protocol in ρ-spi calculus
ProtocolS (cid:1)
let kA = asym-key(A).
let kB = asym-key(B).
let kE = asym-key(E).
(| ∀I ∈ {A,B}
I(cid:2)!InitiatorS(I, J, Priv(kI), Pub(kJ)) |
I(cid:2)!ResponderS(I, J, Priv(kI), Pub(kJ)))
∀J ∈ {A,B,E},J (cid:17)= I
new(nI : Un).
out(I, nI).
in(J, I, y).
decrypt y as
commit2(I, J).
(cid:11)
decrypt z
as
{|Id(I), Verif(nI), z
(cid:11)|}Pub(kJ). ASYMMETRIC DECRYPT
POSH COMMIT
{|Id(J), Verif?(x)|}Priv(kI).
run1(I, J).
encrypt {|I, x|}Pub(kJ) as z
(cid:11)(cid:11).
out(z
(cid:11)(cid:11))
ASYMMETRIC DECRYPT
SOPH/SOSH CONFIRM
ASYMMETRIC ENCRYPT
OUTPUT
InitiatorS(I, J, Priv(kI), Pub(kJ)) (cid:1)
NEW NAME
OUTPUT
INPUT
ResponderS(I, J, Priv(kI), Pub(kJ)) (cid:1)
new(nI : nonce(J, I)).
in(J, x).
run2(I, J).
encrypt {|Id(I), Verif?(nI)|}Pub(kJ) as z.
encrypt {|Id(J), Verif(x), z|}Priv(kI) as z
out(I, J, z
in(y).
decrypt y as {J, nI}Priv(kI).
commit1(I, J)
(cid:11)).
NEW SECRET NONCE
INPUT
RUN
SOPH/SOSH INQUIRY
(cid:11). POSH REQUEST
OUTPUT
INPUT
ASYMMETRIC DECRYPT
SOPH/SOSH COMMIT
Table 8 Some Case Studies
Protocols
CCITT X.509
SPLICE/AS