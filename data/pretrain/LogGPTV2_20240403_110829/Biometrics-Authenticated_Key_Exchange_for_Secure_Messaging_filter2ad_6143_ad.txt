each point ğ‘ƒğ‘œğ‘–ğ‘›ğ‘¡ ğ‘—,ğœŒ (ğœŒ âˆˆ [1, 4]), find the nearest ğœ‡ points ğ‘ƒğ‘œğ‘–ğ‘›ğ‘¡ ğ‘—,ğœŒ,ğœ
(ğœ âˆˆ [1, 4]). We define vecğ‘—,ğœŒ,ğœ (ğœ âˆˆ [1, 4]) as the vector from
ğ‘ƒğ‘œğ‘–ğ‘›ğ‘¡ ğ‘—,ğœŒ to ğ‘ƒğ‘œğ‘–ğ‘›ğ‘¡ ğ‘—,ğœŒ,ğœ . Let ğ‘‘ ğ‘—,ğœŒ,ğœ denote the length of the vector
vecğ‘—,ğœŒ,ğœ and ğœ™ ğ‘—,ğœŒ,ğœ” (ğœ” âˆˆ [1, 6]) denote the angles. Similarly, we can
represent the vector vğ‘—,ğœŒ = (ğ‘‘ ğ‘—,ğœŒ,1, ğ‘‘ ğ‘—,ğœŒ,2, ğ‘‘ ğ‘—,ğœŒ,3, ğ‘‘ ğ‘—,ğœŒ,4, ğœ™ ğ‘—,ğœŒ,1, ğœ™ ğ‘—,ğœŒ,2,
ğœ™ ğ‘—,ğœŒ,3, ğœ™ ğ‘—,ğœŒ,4, ğœ™ ğ‘—,ğœŒ,5, ğœ™ ğ‘—,ğœŒ,6) (ğœŒ, ğœ âˆˆ [1, 4]). Finally, a fingerprint vec-
tor is represented as vğ‘— = (vğ‘—,0, vğ‘—,1, vğ‘—,2, vğ‘—,3, vğ‘—,4) that is concate-
nated with 50 values.
Since the above fingerprint processing method is based on the
relative position of minutiae points, rotating images does not affect
the fingerprint representation.
4.3.2 Tolerating Fingerprint Noise with Lattice. Similar to the iris
vector, a fingerprint vector also should be processed to mitigate
noise. To this end, we also employ a well-chosen lattice. We omit
the repeatability description and refer to Section 4.2.2 for details.
Session 10B: Crypto and Protocol Security CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea2624Algorithm 2: Minutiae-based Fingerprint Vector Set Con-
structing Algorithm
1 for ğ‘ƒğ‘œğ‘–ğ‘›ğ‘¡ ğ‘— âˆˆ {ğ‘ƒğ‘œğ‘–ğ‘›ğ‘¡1, . . . , ğ‘ƒğ‘œğ‘–ğ‘›ğ‘¡ğ‘› } do
Set ğ‘ƒğ‘œğ‘–ğ‘›ğ‘¡ ğ‘— as the center and find the nearest ğœ‡ points
Construct ğœ‡ vectors {vecğ‘—,ğœŒ }ğœ‡
Compute vector lengths {ğ‘‘ ğ‘—,ğœŒ }ğœ‡ for {vecğ‘—,ğœŒ }ğœ‡
Compute inter-vector angles {ğœ™ ğ‘—,ğœ”} ğœ‡Â·(ğœ‡âˆ’1)
in {vecğ‘—,ğœŒ }ğœ‡
Represent vector vğ‘—,0 with {ğ‘‘ ğ‘—,ğœŒ }ğœ‡ and {ğœ™ ğ‘—,ğœ” } ğœ‡Â·(ğœ‡âˆ’1)
for ğœŒ âˆˆ [1, ğœ‡] do
2
2
initializes the whole system and realizes all oracles, then gives all
public information to A, A then interacts with C via a series of
queries on ğ¸ğ‘¥ğ‘’ğ‘ğ‘¢ğ‘¡ğ‘’, ğ‘†ğ‘’ğ‘›ğ‘‘, ğ‘…ğ‘’ğ‘£ğ‘’ğ‘ğ‘™, and ğ¶ğ‘œğ‘Ÿğ‘Ÿğ‘¢ğ‘ğ‘¡. In the meanwhile,
A issues a ğ‘‡ ğ‘’ğ‘ ğ‘¡ query, and keeps querying other oracles afterward
as before. Finally, A terminates this experiment and outputs a guess
bit ğ‘ (cid:4) for the choice bit ğ‘ inğ‘‡ ğ‘’ğ‘ ğ‘¡. For BAKE, an instance of the sender
represents an online attack if both the following cases are true at the
time of theğ‘‡ ğ‘’ğ‘ ğ‘¡ query, (1) at some point, A queried ğ‘†ğ‘’ğ‘›ğ‘‘1 (Pğ‘–
, âˆ—) (vs.
0
ğ‘—
ğ‘†ğ‘’ğ‘›ğ‘‘2 (P
)).
1
The number of online attacks represents a bound on the number
of biometric secret keys that A could have tested in an online
fashion. A PPT A may succeed with probability 1 by trying all
biometric secret keys if the size of the biometric dictionary is small.
Therefore, A is only said to have succeeded if A asks a single ğ‘‡ ğ‘’ğ‘ ğ‘¡
query, outputs a guess bit ğ‘ (cid:4) such that ğ‘ (cid:4) = ğ‘. The advantage of A
in attacking BAKE is formally defined by
, âˆ—)); (2) at some point, A queriedğ‘‡ ğ‘’ğ‘ ğ‘¡ (Pğ‘–
0
ğ‘—
) (vs.ğ‘‡ ğ‘’ğ‘ ğ‘¡ (P
1
2
3
4
5
6
7
8
9
10
11
12
13
Set ğ‘ƒğ‘œğ‘–ğ‘›ğ‘¡ ğ‘—,ğœŒ as the core and find the nearest ğœ‡ points
Construct ğœ‡ vectors {vecğ‘—,ğœŒ,ğœ }ğœ‡
Compute vector lengths {ğ‘‘ ğ‘—,ğœŒ,ğœ }ğœ‡ for {vecğ‘—,ğœŒ,ğœ }ğœ‡
Compute inter-vector angles {ğœ™ ğ‘—,ğœŒ,ğœ” } ğœ‡Â·(ğœ‡âˆ’1)
{vecğ‘—,ğœŒ,ğœ }ğœ‡
Represent vector vğ‘—,ğœŒ with {ğ‘‘ ğ‘—,ğœŒ,ğœ }ğœ‡ and
{ğœ™ ğ‘—,ğœŒ,ğœ” } ğœ‡Â·(ğœ‡âˆ’1)
in
2
Represent {vecğ‘—,ğœŒ}ğœ‡ as vector vğ‘— = (vğ‘—,0,vğ‘—,1,vğ‘—,2,vğ‘—,3,vğ‘—,4)
2
AdvA (ğœ†) = |2 Â· Pr[ğ‘ = ğ‘ (cid:4)] âˆ’ 1|.
(1)
5 SECURITY
We detail security analysis with Find-then-Guess (FtG) paradigm
in the Bellare-Pointcheval-Rogaway (BPR) model [7], where the
adversary A is given access to oracles through the following oracle
queries. Particularly, users who hold biometrics (from a specific
biometric dictionary) are modeled as PPT algorithms that respond
ğ‘—
to queries. Pğ‘–
1 ) denotes instance ğ‘– (vs. ğ‘—) of user P0 (vs. P1)
who executes the protocol multiple times with different partners
(we use vs. to simply describe the similar case of the other user).
0 (vs. P
Execute. This oracle models a passive A (e.g., an eavesdropper)
who receives all the transcripts of an honest execution between an
instance of a sender Pğ‘–
ğ‘—
0 and an instance of a receiver P
1 .
Send. This oracle models an active adversary A who can inter-
cept a message, modify it, create a new one, or simply forward it
to the intended party. For example, A could launch impersonation
attacks via Send queries. Particularly, we separate three kinds of
ğ‘†ğ‘’ğ‘›ğ‘‘ oracles in BAKE, ğ‘†ğ‘’ğ‘›ğ‘‘0 (Pğ‘–
) implies that P0 initiates an
0
ğ‘—
execution with P1, ğ‘†ğ‘’ğ‘›ğ‘‘1 (Pğ‘–
, ğ‘š) implies a mes-
, ğ‘š) and ğ‘†ğ‘’ğ‘›ğ‘‘2 (P
0
1
ğ‘—
sage ğ‘š is sent by A to the instance Pğ‘–
1 , and outputs the first
and second message that the instance of the user who generates
upon receipt of the messages.
0 and P
ğ‘—
, P
1
Reveal. This oracle models the misuse of session keys by a user,
and A gets the session key held by the user.
Test. This oracle models A is given either a session key or a
random value (depending on a choice bit ğ‘) and must distinguish
ğ‘—
them. If no session key for instance Pğ‘–
1 ) is defined , then
return the undefined symbol âŠ¥. Otherwise, return a guess bit ğ‘ (cid:4) âˆˆ
{0, 1} for the choice bit ğ‘.
0 (vs. P
Corrupt. This oracle models the client outputs the biometric
secret key, which does not reveal the internal state, but reveals the
secret key and can be made at any point during the protocol.
Advantage of the adversary. Freshness oracle is defined to
restrict the queries to a target session. The security experiment is
performed as a game between a challenger C and an adversary A
based on BAKE with a security parameter ğœ†. Concretely, C first
Definition 5.1. BAKE is said to be secure if for every biometric
dictionary ğ· with size (cid:12)ğ· (cid:12) and for all PPT A making at most ğ‘„ğ‘ 
online dictionary attacks (i.e., the number of ğ‘†ğ‘’ğ‘›ğ‘‘ queries), it holds
that AdvA (ğœ†) â‰¤ ğ‘„ğ‘  /(cid:12)ğ· (cid:12) + ğ‘›ğ‘’ğ‘”ğ‘™ (ğœ†).
Remark 1. Fuzzy aPAKE [21] is using an ideal cipher as a block
cipher that takes as input a plaintext or a ciphertext. In our solution,
we instantiate the block cipher using our proposed AFEM instead.
Theorem 5.2. BAKE is secure with the advantage AdvA (ğœ†) â‰¤
ğ‘„ğ‘  /(cid:12)ğ· (cid:12) + ğ‘›ğ‘’ğ‘”ğ‘™ (ğœ†) if AFEM is semantic secure and assuming all
collision-resistant hash functions are random oracles H , where ğ‘„ğ‘ 
is the number of the online attacks (i.e., the number of ğ‘†ğ‘’ğ‘›ğ‘‘ queries)
and the bit-length of the output of H is â„“.
Proof of Theorem 5.2. We use A to construct a simulator S that
controls all oracles to which A has the ability to access. S executes
the Init phase including selecting biometric characteristics for each
user, and answers Aâ€™s queries as defined in the ğ¸ğ‘¥ğ‘’ğ‘ğ‘¢ğ‘¡ğ‘’, ğ‘‡ ğ‘’ğ‘ ğ‘¡, and
ğ‘†ğ‘’ğ‘›ğ‘‘ oracles. Thus, A succeeds in breaking the semantic security
of AFEM if it can guess the bit ğ‘ that S uses during the ğ‘‡ ğ‘’ğ‘ ğ‘¡-query.
The proof uses a sequence of hybrids, starting from the real case
and ending at the ideal (or simulation) case where the advantage
(ğœ†) denote the advantage of A in the hybrid
of A is 0. Let Adv
Hy.ğ‘–. To prove the desired bound on AdvA (ğœ†) = Adv
(ğœ†), we
bound the effect of each change in the hybrid on the advantage of
A, and then illustrate that Adv
(ğœ†) â‰¤ ğ‘„ğ‘  /(cid:12)ğ· (cid:12).
Hy0
A
Hyğ‘–
A
Hy7
A
0 (vs. P
Hy.0. A real hybrid follows BAKE specification. Hy.0 corre-
sponds to the real attack that the honest users have their key-pair
(ğ‘ğ‘˜0, ğ‘ ğ‘˜0) (vs. (ğ‘ğ‘˜1, ğ‘ ğ‘˜1)). ğ¸ğ‘¥ğ‘’ğ‘ğ‘¢ğ‘¡ğ‘’ and ğ‘†ğ‘’ğ‘›ğ‘‘ are answered exactly
as the honest users with their keys; ğ‘…ğ‘’ğ‘£ğ‘’ğ‘ğ‘™ to an instance of the
ğ‘—
participant Pğ‘–
1 ) is answered by issuing the session key (i.e.,
,ğ‘ 1) vs. ğ‘˜1 = ğ» (ğ‘ğ‘˜0, ğ‘ğ‘˜1, ğ‘0, ğ‘1, ğ‘ 0, ğ‘  (cid:4)
ğ‘˜0 â†ğ» (ğ‘ğ‘˜0, ğ‘ğ‘˜1, ğ‘0, ğ‘1,ğ‘  (cid:4)
)) that
1
0
ğ‘—
is generated by Pğ‘–
0 (vs. P
1 ) during the execution of the protocol
(or âŠ¥ if no session key is set); and ğ‘‡ ğ‘’ğ‘ ğ‘¡ to a fresh instance Pğ‘–
0 (vs.
ğ‘—
1 ) is answered after flipping a coin ğ‘, by either the output of
P
)) or ğ‘ ğ‘˜ $â† {0, 1}âˆ—. By definition, we
ğ‘…ğ‘’ğ‘£ğ‘’ğ‘ğ‘™ (Pğ‘–
0
have AdvA (ğœ†) = Adv
ğ‘—
) (vs. ğ‘…ğ‘’ğ‘£ğ‘’ğ‘ğ‘™ (P
1
Hy0
(ğœ†) = |2 Â· Pr[ğ‘ = ğ‘ (cid:4)] âˆ’ 1|.
A
Session 10B: Crypto and Protocol Security CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea2625Hy.1. Hy.1 is identical to Hy.0 on simulating all the instances
for ğ‘†ğ‘’ğ‘›ğ‘‘, ğ¸ğ‘¥ğ‘’ğ‘ğ‘¢ğ‘¡ğ‘’, ğ‘‡ ğ‘’ğ‘ ğ‘¡ and ğ¶ğ‘œğ‘Ÿğ‘Ÿğ‘¢ğ‘ğ‘¡ queries, except that we sim-
ulate the random oracle H on new queries (ğ‘ğ‘˜0, ğ‘ğ‘˜1, ğ‘0, ğ‘1, ğ‘  (cid:4)
, ğ‘ 1)
0
and (ğ‘ğ‘˜0, ğ‘ğ‘˜1, ğ‘0, ğ‘1, ğ‘ 0, ğ‘  (cid:4)
), and we obtain two associated random
1
outputs as session keys, either ğ‘˜0 â† ğ» (ğ‘ğ‘˜0, ğ‘ğ‘˜1, ğ‘0, ğ‘1, ğ‘  (cid:4)
, ğ‘ 1) or
(cid:5)
0
ğ‘˜1 â† ğ» (ğ‘ğ‘˜0, ğ‘ğ‘˜1, ğ‘0, ğ‘1, ğ‘ 0, ğ‘  (cid:4)
) in all of the sessions. For keeping con-
1
, ğ‘ 1), ğ‘˜0
sistent, the corresponding valid records
are stored in the list Î›ğ» that is used
and
to give the same answer if the same query is asked twice. This hy-
brid excludes the collision, the protocol halts and A fails if any
instance chooses any input of the random oracle that has been used.
This is a perfect simulation of the random oracle H , and we have
(ğ‘ğ‘˜0, ğ‘ğ‘˜1, ğ‘0, ğ‘1, ğ‘ 0, ğ‘  (cid:4)
1
(ğ‘ğ‘˜0, ğ‘ğ‘˜1, ğ‘0, ğ‘1, ğ‘  (cid:4)
0
), ğ‘˜1
(cid:4)
(cid:4)
(cid:5)
Claim 1.
|Adv
Hy0
A
(ğœ†) âˆ’ Adv
Hy1
A
(ğœ†)| is negligible.
(cid:4)
Proof. This claim is guaranteed by the collision resistance and
one-wayness of the hash function. All executions will be halted if a
collision occurs in the transcript
since the in-
puts ğ‘ğ‘˜0, ğ‘0, ğ‘ğ‘˜1, ğ‘1 are simulated and chosen uniformly at random.
Thus, the collision in the transcript is still regarded as negligi-
(ğœ†) â‰¤
ble for convenience, and the probability is at most Adv
(ğ‘ğ‘˜0, ğ‘0), (ğ‘ğ‘˜1, ğ‘1)
(cid:5)
Hy0
A
Hy1
A
(ğœ†) + (ğ‘„ğ‘  +ğ‘„ğ‘’ ) 2
via the birthday paradox, where ğ‘„ğ‘  and ğ‘„ğ‘’
Adv
are the numbers of ğ‘†ğ‘’ğ‘›ğ‘‘ and ğ¸ğ‘¥ğ‘’ğ‘ğ‘¢ğ‘¡ğ‘’ queries, and â„“ is the bit-length
(cid:2)
of the output of H .
2â„“
ğ‘—
, P
1
Hy.2. ğ¸ğ‘¥ğ‘’ğ‘ğ‘¢ğ‘¡ğ‘’ queries between compatible users, before corrup-
tion. In this hybrid, we first deal with the passive attacks between
two compatible users because ğ¸ğ‘¥ğ‘’ğ‘ğ‘¢ğ‘¡ğ‘’ models the behavior of the
passive adversary. Indeed, there is a simple query to the ğ¸ğ‘¥ğ‘’ğ‘ğ‘¢ğ‘¡ğ‘’
oracle (in either Hy.3 or Hy.2), and the transcript (ğ‘ğ‘˜0, ğ‘0, ğ‘ğ‘˜1, ğ‘1)
is returned to A. In order to respond to ğ¸ğ‘¥ğ‘’ğ‘ğ‘¢ğ‘¡ğ‘’ (Pğ‘–
), the pub-
0
lic key ğ‘ğ‘˜0 â† AFEM.PubGen(ğ‘ ğ‘˜0) for the sender P0 (vs. ğ‘ğ‘˜1 â†
AFEM.PubGen(sk1) for the receiver P1) with the associated cor-
rect secret key ğ‘ ğ‘˜0 derived from the biometric characteristics (i.e.,
SK) for the sender P0 (vs. ğ‘ ğ‘˜1 for the receiver P1) is replaced by
encrypting a random sampled ğ‘ ğ‘˜0 (vs. ğ‘ ğ‘˜1) from SK. Additionally,
the message ğ‘ 0 for P0 (vs. the message ğ‘ 1 for P1) is encrypted un-
der a dummy public key ğ‘ğ‘˜ğ‘– â† AFEM.PubGen(ğ‘ ğ‘˜ğ‘– ) (for ğ‘– = 0, 1)
instead of ğ‘ğ‘˜ğ‘– â† AFEM.PubGen(ğ‘ ğ‘˜ğ‘– ). Thus, we obtain ğ‘0 â†
, ğ‘ 1) for P1).
AFEM.Enc(ğ‘ğ‘˜
for P0 and ğ‘˜1 â† {0, 1}â„“
Next, random session keys ğ‘˜0 â† {0, 1}â„“
(cid:4)
for P1 are drawn uniformly, and the list Î›Hy.2
stores the records
ğ»
, ğ‘0, ğ‘1, ğ‘ 1, ğ‘  (cid:4)
, ğ‘ğ‘˜
(ğ‘ğ‘˜
. Thus,
0
0
we consider A wins this hybrid if Î›Hy.2
ğ» âˆ© Î›ğ» â‰  âˆ…. To summarize
what has been mentioned above, we utilize Hy.2 to exclude pas-
sive attacks between compatible users by ğ¸ğ‘¥ğ‘’ğ‘ğ‘¢ğ‘¡ğ‘’, where Hy.2 is
indistinguishable from Hy.1 unless the two aforementioned records
have been queried to H . Thus, we have
, ğ‘ 0) for P0 (vs. ğ‘1 â† AFEM.Enc(ğ‘ğ‘˜
, ğ‘0, ğ‘1, ğ‘ 0, ğ‘  (cid:4)
1
), ğ‘˜0
), ğ‘˜1
and
, ğ‘ğ‘˜
(ğ‘ğ‘˜
(cid:5)
(cid:4)
(cid:5)
1
0