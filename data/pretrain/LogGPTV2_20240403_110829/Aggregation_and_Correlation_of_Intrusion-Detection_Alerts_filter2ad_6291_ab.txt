and-feel, and allow them to use intrusion detection like any other application
in their realm.
Our prototype is implemented on top of the Tivoli Enterprise Console (TEC),
a commercial event-handling product. It takes advantage of the existing fa-
cilities for event acquisition, storage in a database and display. The ACC is
implemented as a set of prolog rules for the prolog engine that sits inside the
TEC and processes events.
Conﬁgurability. The ACC must allow an easy reconﬁguration of the reason-
ing parameters (i.e. severity, conﬁdence, speciﬁc known-bad or known-good
hosts). This should alleviate but not solve the false-alert problem, as opera-
tors observing false alerts could reduce the trust or level of the corresponding
alerts, so that their weight in the correlation process is lowered accordingly.
In our prototype, conﬁguration remains manual, by means of conﬁguration
ﬁles.
Performance. Network management environments are often capable of han-
dling hundreds of alerts per second. However, given the complexity of the
processing required to achieve meaningful correlation and the diversity of
information contained in the alerts, it is diﬃcult for an ACC to achieve
the same performance. Therefore, ACCs have to be carefully designed and
implemented so that they oﬀer optimal performance [2].
Our ACC is developed with the target of handling one alert per second. This
corresponds to the maximum alert rate we observe in the environment for
which our prototype was built.
4 Representation of Alerts
The ﬁrst task we faced when developing the ACC was to develop a uniﬁed
framework for intrusion-detection alerts that would allow us to process them
regardless of their origin. This led to the deﬁnition of a system architecture to
gather alerts and the deﬁnition of a data model in the form of a class hierarchy.
92
H. Debar and A. Wespi
e
l
o
s
n
o
C
e
s
i
r
p
r
e
t
n
E
i
l
o
v
i
T
TEC _tasks
Alert reaction
TEC _rules
Alert correlation
TEC _reception
Alert reception
h
c
t
a
p
s
i
d
_
C
E
T
y
a
l
p
s
i
D
t
r
e
l
A
Tivoli  Framework communication channel
(Corba )
Intrusion-detection probe
(WebIDS )
ISS  Pre-adapter
Cisco  Pre-adapter
Private communication channel
Intrusion-detection probe
(ISS )
Intrusion-detection probe
(Cisco )
Fig. 2. System architecture for the ACC.
4.1 System Architecture
The ACC acquires alerts from the intrusion-detection probes as shown in Figure
2. We distinguish between two kinds of probes, Tivoli-aware and not.
A Tivoli-aware probe can send events directly to the Tivoli Enterprise Con-
sole (TEC); our architecture in this case assumes that the probe also knows the
data model and the appropriate format for events. An example of such a probe
is Web IDS [6].
A non-Tivoli-aware probe requires an additional interface component to real-
ize the transformation of native events into our data model. This probe-speciﬁc
interface component is called a pre-adapter. It runs on the probe and knows how
to read alert information in real time (or as close to it as possible). It formats
the alert according to the alert class hierarchy described in Section 4.2. It then
ships this formatted alert using the Tivoli Framework communication facility to
the TEC where the ACC is implemented. Currently, the pre-adapter has no ad-
ditional function. However, if performance becomes an issue, we envisage giving
it more functionality, such as providing alert counts, to reduce the workload of
the ACC.
Note that alerts are deﬁned in both places: in the probe or the pre-adapter
and in the TEC. If the two do not match, the alerts will not be processed by the
Aggregation and Correlation of Intrusion-Detection Alerts
93
correlation rules. Also note that this architecture does not prevent us from using
the standard event sources (e.g. syslog) already found in information systems.
Additional adaptation can be performed by the ACC, with some performance
cost (see Section 5.1).
4.2 Alert Class Hierarchy
One of the main challenges of this work was the creation of a uniﬁed data model
for acquiring intrusion-detection alerts. This data model is vital to the project
for two reasons: ensuring independence between the correlation algorithms and
the actual alerts generated by the probes, and ensuring that any probe can easily
be integrated into the system and beneﬁt from the generic correlation rules. The
data model deployed in our prototype was also used as the basis of the IDWG
work on a standard message-exchange format.
There are two kinds of classes. Abstract classes represent generic alert con-
cepts that can be used by all intrusion-detection probes. Implementation classes
inherit from abstract classes and carry speciﬁc alerts generated by a speciﬁc
probe. The design of the abstract classes is partially shown using UML notation
in Figure 3.
The abstract classes hierarchy heavily uses the inheritance relationship pro-
vided by object-oriented design methods. This inheritance mechanism provides
a very strong structure to the model and prevents ambiguities when deciding
where an implementation class for an alert belongs in the hierarchy.
The model is data-driven, which means that specialized classes must provide
more information than the more general classes from which they are derived; in
practice this translates into adding attributes to the derived classes.
The data model is roughly organized in layers to facilitate understanding,
illustrated as shaded boxes in Figure 3. They are described from top to bottom.
Probe layer. The probe layer carries information about the probe itself (pri-
marily error or conﬁguration messages) as well as very generic information
about the alert, e.g., a short alert description or the time stamp of the alert.
Target layer. The target layer ensures that all alerts instantiated by a class
inheriting from this level include target information, i.e. the identiﬁcation
of one or multiple hosts that are the possible victims of an attack. When
the alert reports that multiple hosts are targets of the attack, at least a
headcount is provided.
Source layer. The source layer ensures that all alerts instantiated by a class
inheriting from this level include source information, i.e. some identiﬁcation
of the host from which the attack appears to be launched. We distinguish
between two kinds of sources, real and spoofed sources. Real unfortunately
does not mean that the source of the attack is identiﬁed reliably; it simply
means that there are no indications of obvious spooﬁng. Spoofed on the other
hand is used only when the attack by construction requires IP spooﬁng.
We expect most alerts to provide at least this level of detail. In fact, 90% of
the alerts we generate inherit from children of the ES RealOrigin class.
94
H. Debar and A. Wespi
PROBE LAYER
IDS Alert
IDS Probe
  date
  signature
  name
  level
  trust
generated_by
1
probe
  tool
  hostname
  address
  process
  token
Host
  hostname
  address
  token
E_Weird
  reason
TARGET LAYER
E_MultipleHosts
 number of hosts
E_SingleHost
1
target
Target
Source
1..*
targets
EM_Range
has as targets
SOURCE LAYER
ES_SpoofedOrigin
ES_RealOrigin
DETAILED TARGET LAYER
ES_Application
1
1..*
ESS_SingleService
ESS_MultipleServices
1..*
1
  pty
  source port
  destination port
  service name
  process id
  number of services
ESSM_Services
ESR_MultipleServices
ESR_SingleService
ESR_RIP
ESR_ICMP
  number of services
ESRM_Services
  metric
  route
  code
  type
Fig. 3. Description of the alert class hierarchy.
Detailed target layer. At this layer, detailed information is provided about
the target. In particular, additional information such as email addresses,
URLs, and ICMP information is provided by classes deﬁned at this layer.
To give a better idea of the complexity of the data model, there are about 45
abstract classes, 175 implementation classes for the RealSecure preadapter and
80 for the Cisco Secure IDS pre-adapter.
Aggregation and Correlation of Intrusion-Detection Alerts
95
5 The Aggregation and Correlation (AC) Algorithm
The goal of the aggregation and correlation algorithm is to form groups of alerts
by creating a small number of relationships that are exposed to the operator,
instead of exposing the raw alerts. The ACC uses two diﬀerent kind of relation-
ships:
Correlation relationship. The algorithm creates correlation relationships be-
tween related events according to explicit rules programmed into the ACC
or derived by the ACC from conﬁguration information. Once events are in
a relationship, they are considered part of the same trend of attacks and as
such they are processed together. There are currently two kinds of correlation
relationships between events: duplicates and consequences.
Aggregation relationship. The algorithm groups events together according
to certain criteria (similar to database views) to compute an aggregated
severity level. Whereas the individual severity level of each event might not
be suﬃcient to warrant speciﬁc analysis, the grouping may reveal trends and
associations that clarify the intentions of the attacker.
The AC algorithm is applied in steps. It processes ﬁrst the incoming alert by
extracting common information, such as source and target host, and tries to ﬁnd
a match for these attributes in previous observations. It then creates correlation
relationships by checking for duplicates and consequences, and ﬁnally creates
the aggregation relationships through the situations. Once the situations have
been updated, the appropriate alarms are generated, if necessary, and the alert
is stored in a database. In Sections 5.1 - 5.3 each step is described in more detail.
5.1 Preprocessing of Alerts
Preprocessing is needed to unify the information available in an alert and pro-
vides some error checking to verify that the alert does not contain information
that is obviously wrong, e.g. an invalid time stamp, and would prevent the cor-
relation algorithm from working correctly.
Probes identify the source and target of an attack in diﬀerent ways. In par-
ticular, network-based systems are very likely to provide IP addresses, whereas
host-based systems will provide host names. To ensure unique identiﬁcation of
these actors, each is assigned a token. The preprocessing translates the informa-
tion available in the alert into three tokens: probe, source and target. This
translation process does not use external information acquisition, such as DNS
queries, because of the latency involved in retrieving the information, but relies
on information available in conﬁguration ﬁles.
Each of the three token deﬁnitions is separate. This means that if a host
acts as probe, source and target, it has to be conﬁgured three times. If a host
is not conﬁgured, the AC algorithm generates the appropriate token and stores
whatever information is available in the alert in this token. The original tokens
were integers assigned via a monotonically increasing function. However, this
96
H. Debar and A. Wespi
scheme poses the problem of synchronizing tokens between multiple ACCs in a
distributed environment. The current token scheme uses the IP address of the
host as a token. When dealing with multi-homed hosts or name aliasing, one
IP address needs to be selected as the primary identiﬁcation token of the host.
Then, many associations of this token IP address with host names or additional
alternate IP addresses can be conﬁgured to identify the host as a single entity.
The AC algorithm needs a uniﬁed time reference for alerts. This translates
into the requirement that probes be synchronized. For example, in the current
implementation we require that the time of the probes does not diﬀer by more
than two seconds. This does not mean that alerts should arrive in a time-ordered
way at the ACC, only that their time stamps were generated in the same time
frame. The AC algorithm keeps the time of the most recent event received and
updates this time as events arrive. When a large diﬀerence between this “most
recent” time and the time of the current event is observed, the AC algorithm can
underevaluate the severity of events. This is abnormal and the ACC generates a
warning message. In this case, the “most recent” date is reset to the time of the
last alert received.
In addition, the normalization process provides mechanisms for translating
well-known service names into port numbers and vice versa.
5.2 The Correlation Relationship: Duplicates and Consequences
This part of the AC algorithm deals with alerts that are logically linked with
each other. The reasoning is separated into two parts. First, a backward-looking
part determines whether an alert represents a cause that has already been taken