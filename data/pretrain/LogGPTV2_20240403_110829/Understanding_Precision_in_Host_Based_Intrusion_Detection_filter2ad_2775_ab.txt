The language Ef contains both valid executions and also executions that occur due
to an attack. In the example program, any block may appear after blocks B6, B7, and
B8 in sequences of Ef because it may be possible for an attacker to change the targets
of the control transfers found in those blocks to any address in memory.
The effectiveness of any IDS can be improved by restricting the set of feasible execu-
tion paths. Non-writable code (NWC), a standard assumption in almost all systems, re-
stricts feasible execution by disallowing executions that directly modify program code.
Non-executable data (NXD) restricts Ef so that executions containing code injection
attacks would no longer be feasible behavior. For practical use, the system-call based
systems of Section 3.3 require neither NWC nor NXD, but the control-ﬂow based sys-
tems in Section 3.4 require at least NWC. Throughout the paper, we assume the usage
of NWC.
3.2 Approach of Comparing Precision
We now deﬁne how the precision of IDS models can be compared in our framework.
For any IDS that models a particular set of events X generated by a program, we can
generate the language of valid sequences of such events from the execution language
Ev. We will use the notation EX
v to denote the language containing any sequence of
basic blocks that generate a valid sequence of such events. Therefore, any feasible ex-
ecution of the program that will be considered valid by the IDS is in Ef ∩ EX
v . An
execution e ∈ Ef is detected as an anomaly when e /∈ EX
v . We will use the following
deﬁnition for comparing precision of various approaches (illustrated in Figure 3):
v and Ev ⊆ EY
v .
Deﬁnition 1. Given the sequence of basic blocks considered valid by two IDSs model-
ing event categories X and Y from valid executions in Ev are EX
v respectively,
the former is more precise than the latter if EX
v , but not vice versa while keeping
Ev ⊆ EX
v
From the deﬁnition above, IDS modeling X can detect any anomaly detected by the
IDS modeling Y . This is because for any feasible execution e ∈ Ef , if e /∈ EY
v then
e /∈ EX
v also. However, more attacks are detectable by the IDS modeling the events X,
which are executions in Ef ∩ (EY
v and EY
⊆ EY
− EX
v ).
v
3.3 System Call Sequence Based Intrusion Detection
Our approach for formalizing the precision of system call sequence based schemes is to
ﬁrst derive the language of system call sequences homomorphic to Ev, and then use the
inverse homomorphism to identify the language of actual execution behavior allowed by
a system call model, which we denote as ES
v . Let ΣS be the set of symbols containing
all system calls. Without loss of generality, we assume that a basic block contains at
most one system call because a block can be subdivided into multiple blocks to meet
the requirement. Let σ (cid:2) b hold if basic block b contains system call σ. Deﬁne the
∗
homomorphism hs : B
f
S as follows. For any b ∈ Bf ,
∗
→ Σ
(cid:2)
hs(b) =
if σ (cid:2) b;
otherwise.
σ,
,
Understanding Precision in Host Based Intrusion Detection
27
Fig. 3. Illustration of the comparison of precision of
two different approaches modeling different types of
events.
Fig. 4. Relations among various lan-
guages in our proofs. Edges indicate
functional or homomorphic relation-
ships.
The language Sv of all system call sequences produced by any valid execution of P r is
then Sv = hs(Ev). The language containing sequence of basic blocks producing valid
→
system call sequences ES
B
v can be found using the inverse homomorphism h
∗
f on Sv. It produces the language ES
v that is less restrictive than Ev:
−1
s
: Σ
∗
S
ES
v = h
s (Sv) = {e ∈ B
−1
f : hs(e) ∈ Sv}
∗
The imprecision of system call sequence based approaches can be realized in our
framework from Ev ⊆ ES
v . Figure 4 illustrates this relationship along with other lan-
guages presented throughout the paper. Using the homomorphism, e ∈ Ev =⇒ s =
hs(e) ∈ Sv =⇒ e ∈ ES
v . The contrapositive states that if an executing program
generates a system call sequence s /∈ Sv, then s is generated by a program execution
e /∈ Ev. An invalid system call sequence implies invalid execution. However, the con-
verse is not true; an invalid execution does not imply an invalid system call sequence.
∩ Ef ⊇ Ev to be considered
This imprecision allows any feasible execution in ES
v
valid. Mimicry attacks [32, 21] that utilize invalid execution exploit this imprecision.
Our framework can be used to derive the known results of Gao et al. [12] indicating
that a system call’s program counter [27] and calling context [10] improve the precision
of system call models by producing a more restrictive ES
v . However, unless an execution
sequence generates a unique system call sequence, ES
v can never be as precise as Ev.
Using control-ﬂow sequences, we can capture the association between consecutively
executed basic blocks in order to uniquely represent executions.
3.4 Control-Flow Sequence Based Intrusion Detection
In order to be able analyze the precision of any control-ﬂow based model, in this section
we present a control-ﬂow sequence based IDS model, which for now, assumes the expo-
sure of all control-ﬂow transfers in a program. We prove that given Ev, we can always
derive a control-ﬂow sequence model that provides detection as precise as Ev. This pro-
vides an important theoretical result: for any system-call sequence based model derived
using any program analysis approach, there always exists a more precise control-ﬂow
based model.
28
M. Sharif et al.
A control-ﬂow sequence based model characterizes the sequences of control transfer
instructions or events that move execution ﬂow from the end of one basic block to the
start of another. Let bS be a special start symbol. Then ΣC = ((Bf ∪{bS})× Bf) is the
alphabet of control-ﬂow events. Each alphabet symbol represents a pair of the addresses
representing a block containing a control-ﬂow transfer instruction and targeted block of
control transfer.
A control-ﬂow sequence language is a subset of Σ
∗
C. We cannot directly derive a
control-ﬂow sequence language from an execution sequence language using a homo-
morphism because a control-ﬂow transfer depends on two basic blocks—the source
∗
∗
and the destination. Instead, we deﬁne a function cf low : B
C that derives
f
the control-ﬂow sequence from an execution sequence string as follows. For any string
e = b1b2b3...bk−1bk ∈ B
∗
f ,
→ Σ
cf low(e) = (bS, b1)(b1, b2)(b2, b3)...(bk−1, bk)
In a minor overloading of notation, we also denote the application of cf low to every
sentence in a language as cf low(L) = {cf low(e) : e ∈ L}. Then, we can derive the
language LC ⊆ Σ
Any language representing a sequence of basic blocks is homomorphic to a language
∗
C.
of control-ﬂow sequences:
Theorem 1. For any language L ⊆ B
∗
f there exists a control-ﬂow sequence language
LC ⊆ Σ
∗
∗
C and a homomorphism hc : Σ
C
Proof. Our proof is by construction. We ﬁrst construct a control-ﬂow sequence lan-
→ B
∗
guage LC using LC = cf low(L). We now deﬁne the homomorphism hc : Σ
f
as follows:
∗
f such that L = hc(LC).
→ B
∗
C
hc((b1, b2)) = b2
The homomorphism hc is constructed in such a way that we can use it on a control-ﬂow
sequence c = cf low(e) derived from some execution sequence e ∈ L, and get the
execution string e back, i.e. e = hc(c). Therefore, L = hc(LC).
We use cf low to derive control-ﬂow sequence languages from Ev and Ef . The lan-
guage Cv = cf low(Ev) contains only valid control-ﬂow sequences, and Cf =
cf low(Ef ) contains feasible sequences. Figure 4 illustrates the relations.
v = cf low
−1(Cv). Our approach is to show that cf low
−1(Cv). We are going to show that Ev = EC
This control-ﬂow sequence model precisely characterizes execution. Let EC
v de-
note the language of all basic block sequences that can generate valid control-ﬂow
sequences, giving EC
v . From
the deﬁnition, Ev ⊆ cf low
−1(Cv) is con-
tained in Ev. We ﬁrst prove that every execution sequence generates a unique control-
ﬂow sequence by showing that cf low is one-to-one.
Theorem 2. Let e1, e2 ∈ B
Proof. Assume that cf low(e1)= cf low(e2). Let c1 = cf low(e1). Then e1 = hc(c1) =
hc(cf low(e1)). Similarly, e2 = hc(c2). Since c1 = c2, e1 = e2, which is a contradic-
tion. Therefore, cf low(e1) (cid:9)= cf low(e2).
From Theorem 2, it is clear that cf low is injective, and ∀c ∈ Cv : ∃e = cf low
hc(c) ∈ Ev. Hence, cf low
f . Then e1 (cid:9)= e2 =⇒ cf low(e1) (cid:9)= cf low(e2).
∗
−1(c) =
−1(Cv) = hc(Cv) = Ev.
−1(Cv) ⊆ Ev. Therefore, cf low
Understanding Precision in Host Based Intrusion Detection
29
An execution sequence is therefore an anomaly if and only if its control-ﬂow sequence
is an anomaly.
Corollary 1. For any system call sequence model Sv derived from a valid/normal
execution Ev, there always exists a more precise control-ﬂow sequence model Cv :
−1
s (Sv).
EC
v
Therefore, any attack that can be detected by a system call sequence language Sv can
be detected using the control-ﬂow sequence language Cv, along with more attacks as
described in the next section.
−1(Cv) = Ev and ES
⊆ ES
v , but not vice versa where EC
v = cf low
v = h
3.5 Mimicry Attacks
A mimicry attack [32] is a variant of an attack that achieves the same goal, but can evade
detection by an IDS. Better model precision limits opportunities of possible mimicry
attacks. For the models of this paper, we set a broad deﬁnition of mimicry attacks:
Deﬁnition 2. Given a malicious sequence of events required for an attack, a mimicry
attack A ∈ Ef is a feasible execution that can achieve the same malicious goal and
A ∈ EX
v being the basic block sequence language considered valid by an IDS
modeling events X.
v for EX
Mimicry attacks on system call based IDS have the freedom of generating feasible exe-
cutions outside of Ev but in ES
v to evade detection [21]. Since the control-ﬂow sequence
based model is as precise as Ev, any such mimicry attack for which A /∈ Ev can be
detected. However, any mimicry attack that switches between valid execution paths,
or modiﬁes data only without altering paths cannot be detected. This is a fundamental
limitation of any approach based on execution sequences without data.
4 Applying Formalisms to Real Intrusion Detection
Our control-ﬂow sequence based model provides the foundation to analyze any control-