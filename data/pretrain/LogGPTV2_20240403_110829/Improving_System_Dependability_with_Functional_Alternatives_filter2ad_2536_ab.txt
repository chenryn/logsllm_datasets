### Dependencies and Valid Configurations

The dependencies among components due to data flow in the architecture significantly reduced the number of valid configurations. In the systems we evaluated, over 90% of the total possible configurations were invalid because missing components disrupted the necessary data flow from sensors to actuators, essential for system functionality. The second insight was that we could use feature subset definitions to form a hierarchical structure, enabling us to calculate system utility based on feature subset component configurations rather than a flat system component configuration. Since feature subsets generally have fewer components than the entire system, this approach reduced the number of configurations that needed to be manually evaluated. We applied this model to analyze the elevator system and identify where functional alternatives could be implemented to improve dependability.

### Implementing Functional Alternatives

This section describes our approach for designing functional alternatives, some initial techniques for applying them to a system architecture, and our evaluation mechanism. Our model identifies all feature subsets in the system and their dependencies, which serve as a basis for identifying functional alternatives. The model also allows us to evaluate the relative utility of any configuration with failed components, helping us determine combinations of component or feature subset failures that may cause significant reductions in system utility or complete system failure. While the model does not provide direct guidance on how to apply functional alternatives to maximize dependability, it offers a means to evaluate design choices for resource allocation and redundancy. Additionally, the model can be used as a validation tool to ensure that the configurations evaluated in the architecture model provide their specified relative utility in the system implementation.

#### Designing Functional Alternatives

Alternative functionality encompasses various existing redundancy mechanisms, such as triplex modular hardware redundancy [14], recovery blocks [12], and multi-version software redundancy [1]. These mechanisms can improve system dependability but come with significant costs in terms of resources and design complexity.

Another form of functional alternative is heterogeneous redundancy, which can take many forms. For example, analytical redundancy [11] involves using related sensors to monitor different aspects of the environment. If one sensor fails, its data can be synthesized from the readings of other sensors. For instance, if a system has sensors for temperature, pressure, and volume of a gas, a software component can be designed to synthesize the output of one sensor based on the readings of the other two, thus tolerating a single sensor failure without adding redundant sensors.

The simplex architecture [2] is another technique for implementing functional alternatives. It is a control system architecture that uses design diversity to improve the reliability of a software control system. This architecture defines trade-offs between low-performance, more reliable controllers and high-performance controllers that may contain more residual design defects. Instead of developing multiple versions of software from the same specification, the simplex architecture requires at least two different control algorithms with different specifications and requirements to be implemented as separate software controllers. Each alternate algorithm is targeted to satisfy different levels of system objectives: one focusing on high reliability, and the other on high performance.

We can also enhance the effectiveness of alternative functionality by designing individual components (and feature subsets) to be robust to input failures. If a component can tolerate the loss of a system variable when all of its input sources fail, it may still provide reduced utility and prevent a system failure. One approach is to initially specify the component’s outputs to provide a "base level" utility with a minimum of system variable inputs and a default behavior. Additional inputs should be treated as "advice" that modifies the default behavior in specific ways. This technique assumes that received inputs will not be erroneous, aligning with our fail-fast, fail-silent component fault model.

#### Applying Functional Alternatives

Each alternative functionality mechanism can potentially improve system dependability by providing redundant functions for satisfying primary system objectives. However, it is not feasible to add alternative functionality to every feature subset due to increased design and resource costs. Ideally, we would identify existing feature subsets that can serve as functional alternatives with little or no modification. For example, if one feature subset's output is semantically similar to another, it may be a candidate for a functional alternative with the addition of an adapter component to transform its output to match the other feature subset's interface. This process requires domain knowledge to recognize similar interfaces across feature subsets and components. Our model provides a basis for this analysis by identifying all feature subset interfaces.

#### Evaluating System Implementation

To validate whether the system implementation can tolerate the component failure configurations, we can use the model to predict and measure system utility. In an ideal case, a utility model should perfectly reflect each component and feature subset’s contribution to system utility. If we have a utility metric that incorporates all desired system properties defined in the system’s requirements, and these attributes can be measured in the system implementation, then every system configuration’s actual measured utility should equal the utility predicted by the model. Figure 1 illustrates the ideal case of predicted model utility versus measured system utility.

In practice, many system properties such as usability, maintainability, and dependability cannot be readily quantified. Therefore, we use relative utility values to rank all 2N configurations in order of increasing utility according to the model. We select measurable system properties, such as performance and reliability, as a proxy for system utility. By graphing the system configurations, we expect a monotonically increasing curve, where configurations with higher utility values in the model have higher system property measurements. Any configurations that do not fit this curve may indicate inaccuracies in the system model, dependability problems in the system implementation, or violations of the model’s assumptions. This iterative analysis helps refine the system model and identify dependability bottlenecks.

### Case Study: Elevator System

In addition to using the model to determine where functional alternatives should be applied, we can also use it to validate the system implementation. We applied this approach to a relatively complex distributed elevator control system, designed by an engineer with industrial experience in elevator architecture. The system was implemented in a discrete event simulator written in Java as a course project. With a complete architectural specification and implementation, we observed how alternative functionality affects the system's ability to tolerate component failures through simulation experiments.

A requirements document specifies each system component’s inputs, outputs, and functional behavior. Component interfaces are defined by a message dictionary. We created a system model and used the analysis techniques described in Section 4 to apply functional alternatives and improve the system's dependability. We then conducted experiments on the elevator system using both the original and the new architecture with our improvements, failing several combinations of components and observing the effect on the system’s ability to deliver passengers.

Figure 2 shows a high-level view of the original elevator system architecture, with software components, sensors, and actuators allocated to distributed processors connected by a fault-tolerant broadcast network. The elevator consists of a single car in a hoistway with access to a set number of floors. The car has two independent left and right doors and door motors, a drive that can accelerate the car to two speeds (fast and slow), an emergency stop brake for safety, and various buttons and lights for determining passenger requests and providing feedback [17].

#### Applying Functional Alternatives to the Elevator System

The most basic requirements of an elevator system are to protect passenger safety and transport passengers to their destination floors without stranding or trapping them. We specified these as the minimum primary objectives. Other services, such as providing appropriate passenger feedback, efficiently processing passenger requests, and minimizing passenger travel time, were considered auxiliary objectives. As long as the elevator maintains passenger safety and can eventually service all floors, it can still be considered "working."

Based on the software components defined for this elevator system, the safety, drive control, and door control functionalities were prioritized. We applied functional alternatives to these critical components to ensure the system's dependability.