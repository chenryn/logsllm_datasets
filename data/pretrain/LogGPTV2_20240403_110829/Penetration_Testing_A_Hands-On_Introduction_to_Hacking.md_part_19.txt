sibly upload scripts that will allow attackers to get a foothold on the system
through the web server. And, as you can see in Figure 6-16, WebDAV is
indeed present on this server.
Figure 6-16: WebDAV install
We can use the tool Cadaver to interact with WebDAV servers. In
Listing 6-11, we use Cadaver to try to connect to the WebDAV server at
http://192.168.20.10 and test the default credential set.
150 Chapter 6
root@kali:/# cadaver http://192.168.20.10/webdav
Authentication required for XAMPP with WebDAV on server `192.168.20.10':
Username: wampp
Password:
dav:/webdav/> u
Listing 6-11: Using Cadaver
The Cadaver login is successful u. Our Windows XP target uses the
default credentials for WebDAV, which we will be able to exploit. Now that
we have access to WebDAV, we can upload files to the web server.
manual analysis
Sometimes, no solution will work nearly as well as manual vulnerability
analysis to see if a service will lead to a compromise, and there’s no better
way to improve than practice. In the sections that follow we’ll explore some
promising leads from our port and vulnerability scanning.
Exploring a Strange Port
One port that has failed to come up in our automated scans is 3232 on our
Windows target. If you try scanning this port with an Nmap version scan (as
we did at the end of Chapter 5), you’ll notice that it crashes. This behavior
suggests that the listening program is designed to listen for a particular
input and that it has difficulty processing anything else.
This sort of behavior is interesting to pentesters, because programs
that crash when handling malformed input aren’t validating input properly.
Recall from Chapter 5 that in the process of crashing the program, the out-
put led us to believe that the software is a web server. Connecting to the port
with a browser, as shown in Figure 6-17, confirms this.
Figure 6-17: Web server on port 3232
The web page served doesn’t tell us much, but from here we can con-
nect to the port manually using Netcat. We know this is a web server, so we
will talk to it as such. We know we can browse to the default web page, so
we can enter GET / HTTP/1.1 to ask the web server for the default page (see
Listing 6-12).
Finding Vulnerabilities 151
root@kali:~# nc 192.168.20.10 3232
GET / HTTP/1.1
HTTP/1.1 200 OK
Server: Zervit 0.4 u
X-Powered-By: Carbono
Connection: close
Accept-Ranges: bytes
Content-Type: text/html
Content-Length: 36
hi
root@bt:~#
Listing 6-12: Connecting to a port with Netcat
The server announces itself as Zervit 0.4 u. It doesn’t look good for the
software because the first autocomplete entry in a search for Zervit 0.4 on
Google is “Zervit 0.4 exploit.” This web server software is subject to mul-
tiple security issues, including a buffer overflow and a local file inclusion
vulnerability, which allows us to serve other files on the system. This service
is so sensitive that it may be best to avoid buffer overflow attacks, because
one false move will crash it. The local file inclusion, on the other hand,
looks promising. We know the server can process HTTP GET requests. For
example, we can download Windows XP’s boot.ini file by moving back five
directories to the C drive using GET, as shown in Listing 6-13.
root@kali:~# nc 192.168.20.10 3232
GET /../../../../../boot.ini HTTP/1.1
HTTP/1.1 200 OK
Server: Zervit 0.4
X-Powered-By: Carbono
Connection: close
Accept-Ranges: bytes
Content-Type: application/octet-stream
Content-Length: 211
[boot loader]
timeout=30
default=multi(0)disk(0)rdisk(0)partition(1)\WINDOWS
[operating systems]
multi(0)disk(0)rdisk(0)partition(1)\WINDOWS="Microsoft Windows XP Home
Edition" /fastdetect /NoExecute=OptIn
Listing 6-13: Local file inclusion in Zervit 0.4
We’re able to pull down boot.ini, a config file that tells Windows which
operating system options to display at boot time. We’ll use this local file
inclusion to pull down additional sensitive files in Chapter 8.
152 Chapter 6
Finding Valid Usernames
We can drastically increase our chances of a successful password attack if
we know valid usernames for services. (We’ll explore this in more detail in
Chapter 9.) One way to find valid usernames for mail servers is to use the
VRFY SMTP command, if it is available. As the name implies, VRFY verifies if a
user exists. NSE found the VRFY verb is enabled on the Windows XP target in
the previous chapter. Connect to TCP port 25 using Netcat, and use VRFY to
check for usernames, as shown in Listing 6-14.
root@kali:~# nc 192.168.20.10 25
220 georgia.com SMTP Server SLmail 5.5.0.4433 Ready ESMTP spoken here
VRFY georgia
250 Georgia
VRFY john
551 User not local
Listing 6-14: Using the SMTP VRFY command
Using VRFY we see that georgia is a valid username, but there is no user
called john. We will look at using valid usernames to try to guess passwords
in Chapter 9.
summary
In this chapter, we have touched on various methods to find exploitable vul-
nerabilities on our targets. Using a variety of tools and techniques, we were
able to find myriad ways to go after our targets, including our trusty MS08-
067 exploit against our Windows XP SMB server and a local file inclusion
vulnerability on the Zervit 0.4 web server that will allow us to download
system files. Using VRFY, we found a valid username that we can use in
password-guessing attacks on the mail server.
We learned that the SLMail server may have a vulnerability in the
POP3 service based on its reported version number (though we were not
able to find out for sure), and we found an open phpMyAdmin install on
the web server that gives us root access to the underlying database, as well
as an XAMPP install with default credentials for WebDAV that will allow
us to upload files to the web server. On the Linux target, we found an NFS
share with write access that allows us to write to a user’s .ssh directory, and
we discovered a not-readily-apparent TikiWiki install on the web server
that appears to contain a code execution vulnerability. The Vsftpd 2.3.4
FTP server may have a hidden backdoor due to a compromise of the Vsftpd
repositories.
At this point in the book we can see that our Windows XP and Linux
target machines suffer from a lot of issues. The lack of attack surface on our
Windows 7 target makes it seem pretty safe, but as we will see a bit later, that
solid exterior hides a few holes underneath. Before we move on to exploit-
ing these vulnerabilities, the next chapter will look at capturing traffic to
gain sensitive information such as login credentials.
Finding Vulnerabilities 153
7
CaPturing tr affiC
Before we move on to exploitation, we’ll use the
Wireshark monitoring tool, as well as other tools, to
sniff and manipulate traffic to gain useful informa-
tion from other machines on the local network. On
an internal penetration test, when we’re simulating an
insider threat or an attacker who has breached the
perimeter, capturing traffic from other systems in the network can give
us additional interesting information (perhaps even usernames and pass-
words) that can help us with exploitation. The trouble is that capturing
traffic can produce a massive amount of potentially useful data. Capturing
all traffic on just your home network could quickly fill several Wireshark
screens, and discovering which traffic is useful for a pentest can be difficult.
In this chapter, we’ll look at several ways to manipulate a network to get
access to traffic we have no business being able to see.
networking for Capturing traffic
If you find yourself in a network that uses hubs rather than switches, cap-
turing traffic not intended for your machine will be easy, because when a
network hub receives a packet, it rebroadcasts it on all ports, leaving it up
to each device to decide whom the packet belongs to. In a hubbed network,
capturing other systems’ traffic is as easy as selecting Use promiscuous mode
on all interfaces in Wireshark. This tells our Network Interface Controller
(NIC) to grab everything it sees, which in a hubbed network will be every
packet.
Unlike hubs, switches send traffic only to the intended system, so on a
switched network, we won’t be able to view, for example, all the traffic to
and from the domain controller without fooling the network into sending
us that traffic. Most networks you encounter on pentests will probably be
switched networks; even some legacy network hardware that claims to be
a hub may have the functionality of a switch.
Virtual networks seem to act like hubs, because all your virtual machines
share one physical device. If you capture traffic in promiscuous mode in
a virtual network, you may be able to see traffic from every virtual machine
as well as the host machine, even if you are using a switch instead of a hub in
your environment. To simulate a non-virtualized network, we’ll turn off Use
promiscuous mode on all interfaces in Wireshark, which means we will have
to work a little harder to capture traffic from our target virtual machines.
using wireshark
Wireshark is a graphical network protocol analyzer that lets us take a deep
dive into the individual packets moving around the network. Wireshark
can be used to capture Ethernet, wireless, Bluetooth, and many other kinds
of traffic. It can decode different protocols that it sees, so you could, for
instance, reconstruct the audio of Voice over IP (VoIP) phone calls. Let’s
take a look at the basics of using Wireshark to capture and analyze traffic.
Capturing Traffic
Let’s start by using Wireshark to capture traffic on our local network.
Start Wireshark in Kali, as shown here. Click through any warnings about
using Wireshark as root being dangerous.
root@kali:~# wireshark
Tell Wireshark to capture on the local network interface (eth0) by select-
ing Capture4Options, and selecting the eth0 option, as shown in Figure 7-1.
Remember to uncheck the Use promiscuous mode on all interfaces option so
that the results will be like those on a physical switched network rather than
the VMware network. Exit the Options menu. Finally, click Capture4Start
to begin the traffic capture.
156 Chapter 7
You should start to see traffic coming in, and you should be able to cap-
ture all traffic intended for the Kali machine as well as any broadcast traffic
(traffic sent to the entire network).
Figure 7-1: Starting a Wireshark capture
To illustrate the traffic we can capture in a switched network, let’s start
by contacting our Windows XP target from our Kali machine over FTP.
Log in as anonymous, as shown in Listing 7-1, to see the captured traffic in
Wireshark. (In the previous chapter, we discovered that the anonymous user
is allowed on the Windows XP target. Although anonymous requires that you
enter a password, it doesn’t matter what it is. Traditionally, it is an email
address, but the FTP server will accept whatever you would like to use.)
root@kali:~# ftp 192.168.20.10
Connected to 192.168.20.10.
220-FileZilla Server version 0.9.32 beta
220-written by Tim Kosse (PI:EMAIL)
220 Please visit http://sourceforge.net/projects/filezilla/
Name (192.168.20.10:root): anonymous
331 Password required for anonymous
Password:
230 Logged on
Remote system type is UNIX.
ftp>
Listing 7-1: Logging in via FTP
Capturing Traffic 157
You should see packets in Wireshark from the system with IP address
192.168.20.9 to 192.168.20.10 and vice versa, with the Protocol field marked
as FTP. Wireshark is capturing the traffic moving to and from our Kali
machine.
Switch over to your Ubuntu Linux target machine, and log in to the
FTP server on the Windows XP target. Looking back at Wireshark in Kali,
you should see that no additional FTP packets have been captured. In our
simulated switched network, any traffic not destined for our Kali machine
will not be seen by the network interface and, thus, will not be captured by
Wireshark. (We’ll learn how to rectify this situation and capture other sys-
tems’ traffic in “ARP Cache Poisoning” on page 160.)
Filtering Traffic
The sheer volume of network traffic captured by Wireshark can be a bit
overwhelming because, in addition to our FTP traffic, every other packet
to or from the Kali system is captured. To find specific interesting packets,
we can use Wireshark filters. The Filter field is located at the top left of
the Wireshark GUI. As a very simple first Wireshark filtering example, let’s
look for all traffic that uses the FTP protocol. Enter ftp in the Filter field
and click Apply, as shown in Figure 7-2.
Figure 7-2: Filtering traffic in Wireshark
As expected, Wireshark filters the captured packets to show only those
that use the FTP protocol. We can see our entire FTP conversation, includ-
ing our login information, in plaintext.
158 Chapter 7
We can use more advanced filters to further fine-tune the packets
returned. For example, we can use the filter ip.dst==192.168.20.10 to return
only packets with the destination IP address 192.168.20.10. We can even
chain filters together, such as using the filter ip.dst==192.168.20.10 and ftp
to find only FTP traffic destined for 192.168.20.10.
Following a TCP Stream
Even after filtering traffic, there may be multiple FTP connections captured
during the same time frame, so it could still be difficult to tell what’s going
on. But once we find an interesting packet, such as the beginning of an FTP
login, we can dig deeper into the conversation by right-clicking the packet
and selecting Follow TCP Stream, as shown in Figure 7-3.
Figure 7-3: Following the TCP stream in Wireshark
The resulting screen will show us the full contents of our FTP connec-
tion, including its credentials in plaintext, as shown in Listing 7-2.
220-FileZilla Server version 0.9.32 beta
220-written by Tim Kosse (PI:EMAIL)
220 Please visit http://sourceforge.net/projects/filezilla/
USER anonymous
331 Password required for anonymous
PASS PI:EMAIL
230 Logged on
SYST
215 UNIX emulated by FileZilla
Listing 7-2: FTP login conversation
Capturing Traffic 159
Dissecting Packets
By selecting a specific captured packet, we can get more information about
the captured data, as shown in Figure 7-4. At the bottom of the Wireshark
screen, you can see details of the selected packet. With a little guidance,
Wireshark will break down the data for you. For example, we can easily
find the TCP destination port by selecting the TCP entry and looking for
Destination port, as highlighted in the figure. When we select this field,
the entry in the raw bytes of the packet is highlighted as well.
Figure 7-4: Packet details in Wireshark
arP Cache Poisoning
While it is nice to see the details of our own traffic, for pentesting purposes,
it would be preferable to see the traffic that wasn’t intended for our Kali
system. Perhaps we’ll be able to capture another user’s login session that
uses an account other than anonymous to log in; that would give us working
credentials for the FTP server, as well as a set of credentials that might be
reused elsewhere in the environment.
To capture traffic not intended for the Kali system, we need to find
some way to have the relevant data sent to our Kali system. Because the
network switch will send only packets that belong to us, we need to trick
our target machine or the switch (or ideally both) into believing the traffic
belongs to us. We will perform a so-called man-in-the-middle attack, which