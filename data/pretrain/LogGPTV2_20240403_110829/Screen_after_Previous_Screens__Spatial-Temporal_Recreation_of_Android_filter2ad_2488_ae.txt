25th USENIX Security Symposium  1147
(a)Screen-10.(b)Screen-9.(c)Screen-8.(d)Screen-7.(e)Screen-6.(f)Screen-5.(g)Screen-4.(h)Screen-3.(i)Screen-2.(j)Screen-1.(k)Screen0.Figure6:HTCOneChaseBankingRecovery.4.2CaseStudyI:BehindtheLogoutWenowelaborateontheChaseBankingappcaseandhighlightRetroScope’sabilitytorecreateanapp’sprevi-ousscreensevenaftertheuserhasloggedout.Table1Row32showsthatRetroScoperecovered11outof11screens(thehighestofallcases).Notsurprisingly,therecoveryrequiredthemostreanimatedbyte-codeinstruc-tions(584,587)andJNIfunctioninvocations(12,591),aswellasthemostre-allocatedJavaobjects(2,091)andC/C++structures(266,965).TherecoveredscreensareshowninFigure6.Start-ingfromtheAccountscreen(Screen-10),the“suspect”looksupanearbyATM(Screen-9).Hethenreviewshisrecentmoneytransfers(Screen-8)andbeginsanewtransfertoafriendviatheapp’soptionsmenu(Screen-7).Screens-6to-4ﬁllinthetransfer’srecipientandamount.Screen-3askstheusertoconﬁrmthetrans-fer.Screen-2showstheapp’s“LogOut”menu,Screen-1presentsaloadingscreenwhiletheapplogsout,andScreen0is(asexpected)theapp’sloginscreen.Thiscaseyieldssomeinterestingobservations:First,ithighlightstherobustnessofRetroScopetorecoveralargenumberofscreenswhenanapp’sinternaldatacontinuestoaccumulate.Moreimportantly,thecaseshowsthat,afterloggingout,theChaseapp(aswellasmanyotherswehavetested)doesnotclearitsinternaldata.Thisisnotsurprisingbecauseprogrammersusuallyconsidertheirapp’smemorytobeprivate(comparedtonetworkcommunicationsorﬁlesonpersistentstorage).ThisisfurtherevidencedbytheTextSecureapp,whichalsoallowsforasigniﬁcantpost-logoutrecovery(ofpre-logoutscreens),despitetheapp’smessagedatabasebe-inglockedinthedevice’sstorage.4.3CaseStudyII:BackgroundUpdatesAnotherinterestingcaseisWhatsAppMessengerontheSamsungS4.Table1Row15showsthatRetroScopere-animated402,536byte-codeinstructionsand8,186JNIfunctionsin23minutes,10seconds,yieldinganaver-ageof50,317instructionsand1,023JNIfunctionsperscreen.WhatwasunexpectedhoweveristhatRetro-Scoperecoveredanextrascreen(8outofthe7expectedscreens)fromthememoryimage.Ourinvestigationintothisextrascreenfoundthatitwasnotascreenwehadpreviouslyseenduringourphoneusage.Instead,afterwehadﬁnishedinteractingwithWhatsApp,theappreceivedanewchatmessagewhileitwasinthebackgroundand,tooursurprise,thispromptedtheapptoprepareanewchatscreenthatap-pendedthenewlyreceivedmessagetothechat.Figure7presentsthescreensrecoveredbyRetroScope,andagainweseeacleartemporalprogressionthroughtheappbythe“suspect.”First,Screen-6showsthecalllogscreen.Theapp’sSettingsscreenisseeninScreen-5followedbyascreenthatisonlyaccessiblethroughtheSettings:thedeviceowner’sproﬁle(ourﬁctitiousdeviceownerisDr.KingSchultz)inScreen-4.Screen-3showstherecentchats;Screen-2showsthe“suspect’s”chatwithafriend;thenDr.Schultzplacesacalltothatfriend1148  25th USENIX Security Symposium 
USENIX Association
(a)Screen-6.(b)Screen-5.(c)Screen-4.(d)Screen-3.(e)Screen-2.(f)Screen-1.(g)Screen0.(h)Screen+1.Figure7:SamsungS4WhatsAppRecovery.(a)Screen-4.(b)Screen-3.(c)Screen-2.(d)Screen-1.(e)Screen0.Figure8:LGG3WeChatRecovery.inScreen-1.Lastly,Screen0showsthefriend’spro-ﬁle.Then,theextraScreen+1showsthechatscreenaspreparedbytheappwhileinthebackground.Indeeditshowsthenewlyreceivedmessage,eventime-stamped(“TODAY”and“4:51AM”inFigure7(h))afterthepre-viouschathadtakenplace.Toensurethatthisresultwasnotanaccident,were-peatedtheexperiment(receivingchatmessageswhiletheappwasinthebackground)sixmoretimes(twiceperde-vice).Ineverytest,wefoundthatRetroScoperecoveredtheadditionalpre-builtchatscreencontainingthenewmessage.Strangely,aftertestingtheotherappswhichcanreceivebackgroundupdates,wefoundthatWhat-sAppistheonlyapp,amongour15apps,thatexhib-itedthisbehavior.WesuspectthatthisisaWhatsApp-speciﬁcimplementationfeaturetospeedupdisplayingthechatscreen(Screen+1)whenthedeviceuserclicksthe“NewMessage”pop-upnotiﬁcation.4.4CaseStudyIII:DeletedMessagesInadditiontotheWhatsAppcaseabove,RetroScopere-coveredextrascreensforfourothercasesinTable1:Telegram(Row12),WeChat(Row29),WhatsApp(Row30),andTextSecure(Row43).However,theextrascreenshereareforadifferentreason:RetroScopecanrecoverexplicitlydeletedchatmessages.Inthesetests,webeganachatineachappandthenexplicitlydeletedoneofthemessages(asasuspectwoulddoinanat-tempttohideevidence),andthenusedRetroScopetorecoverthedeletedmessage.Additionally,RetroScopealsorecoveredproofofthesuspect’sintenttodeletethemessage:ForWeChatandWhatsApp,RetroScopere-coveredtheapp’spop-upmenu(justpriortothedeletedmessage)whichdisplaysthe“DeleteMessage”option.ForTextSecure,RetroScoperecoveredboththepop-upmenuandaloadingscreenshowingthetext“DeletingMessages.”Figure8showsoneexample:RetroScope’srecoveryfortheWeChatappontheLGG3.Screen-4showsthe“suspect’s”recentchatsfollowedbyachatconver-sationwithafriendinScreen-3.Screen-2isthepop-upmenudisplayingthe“Delete”option.Thedeletedmessage(nowdisconnectedfromthepreviouschatwin-dow)isdisplayedinScreen-1,andthefriend’sproﬁlepage(whichthe“suspect”navigatedtolast)isshowninScreen0.Thisresult,inparticular,highlightsoneofthemostpowerfulfeaturesofRetroScope,giventhatitworksformanyappsandevenprovidesproofofthesuspect’sin-tent.Further,allfourappstouttheirencryptedcommuni-cationandsome(e.g.,TextSecure)evenencryptthemes-sagedatabaseinthedevice.Inlightofthis,lawenforce-menthasroutinelyhadtroubleconvincingdevelopersofsuchappstobackdoortheirencryptioninsupportofin-vestigations[4,5].DespitethefewhardeningmeasuresdiscussedinSection5,RetroScopecanprovidesuchal-ternativeevidencewhichwouldotherwisebeunavailabletoinvestigators.5 Privacy Implications and Discussion
RetroScope provides a powerful new capability to foren-
sic investigators. But despite being developed to aid
criminal investigations, RetroScope also raises privacy
concerns. In digital forensics practice, the privacy of de-
vice users is protected by strict legal protocols and regu-
lations [9,21], the most important of which is the require-
ment to obtain a search warrant prior to performing “in-
vasive” digital forensics such as memory image analysis.
Outside the forensics context, even some of the authors
were surprised by the temporal depth of screens that Ret-
roScope recovered for many privacy-sensitive apps (e.g.,
banking, tax, and healthcare). In light of this, we discuss
possible mitigation techniques which, despite their sig-
niﬁcant drawbacks, might be considered worthwhile by
privacy-conscientious users/developers.
RetroScope’s recovery is based on two fundamental
features of Android app design:
(1) All apps which
present a GUI must draw that GUI through the provided
View class’s draw function and (2) The Android frame-
work calls drawing functions on-demand and prevents
those drawing functions from performing blocking oper-
ations (ﬁle/network reads/writes, etc.). As such, an app
that aims to disrupt RetroScope’s recovery would need to
hinder its own ability to draw screens.
Previous anti-memory-forensics schemes focused on
encrypting in-memory data after its immediate use. This
ensures that traditional memory scanning or data struc-
ture carving approaches (e.g., [25, 26, 37, 41]) would not
ﬁnd any useful evidence beyond the few pieces of de-
crypted in-use data. However, these solutions cannot
hinder RetroScope’s recovery because RetroScope re-
covers evidence via the app’s existing draw functions,
which would have to include decryption routines as part
of building the app screen. App developers may add
state-dependent conditions to their draw functions which
would crash when executed by RetroScope, but as seen
in Section 4 these can still be handled via additional de-
bugging/reverse engineering efforts to skip/ﬁx the condi-
tions.
One approach that may disable RetroScope’s recov-
ery is to overwrite (i.e., zero) all app-internal data im-
mediately after they are drawn on screen. By doing
so, RetroScope would ﬁnd that the app’s internal state
could not support the execution of any of its draw
functions. Unfortunately, this approach would signif-
icantly degrade usability and increase implementation
complexity: First, frequently overwriting app-internal
data would incur execution overhead (especially during
screen changes which are expected to be fast and dy-
namic). More importantly, this would require the app
to download its internal data from a remote server ev-
ery time the app needs to draw a screen. An app may
attempt to amortize these overheads (e.g., only zeroing
a prior session’s memory upon logout) but this would
require: (1) tracking used/freed memory throughout the
session (to be zeroed later) and (2) users to regularly log
out, which is uncommon and inconvenient for frequently
used apps such as email, messengers, etc.
Current vs. Future Android Runtimes.
It is worth
noting that Google has begun shifting the Android frame-
work’s runtime from the Dalvik JVM to a Java-to-native
compilation and native execution environment (named
ART). Our implementation of RetroScope was based on
the original (and still the most widely used by far [17])
Dalvik JVM runtime. However, during our development
of RetroScope, speciﬁc care was taken to design Retro-
Scope to utilize only features present in both runtimes.
Speciﬁcally, ART still provides the same Java runtime
tracking and support as Dalvik does (implemented now
via C/C++ libraries) and all apps’ implementations (e.g.,
their Views and draw functions) remain unchanged. Our
study of ART revealed that the only engineering effort
required to port RetroScope is the interception of state-
changing instructions in the compiled byte-code, rather
than the literal byte-code as it exists in Dalvik. We leave
this as future work.
6 Related Work
RetroScope is most related to GUITAR [35] which,
by recovering the remaining “puzzle pieces” (GUI data
structures) from a memory image, is able to piece to-
gether an app’s Screen 0. Motivated by GUITAR’s
“Screen 0-only” limitation (i.e., spatial recovery), Ret-
roScope enables the fundamentally more powerful capa-
bility of recovering Screens 0, -1, -2, ... -N (i.e., spatial-
temporal recovery). Technically, GUITAR is based on
geometric matching of GUI pieces; whereas RetroScope
is based on selective reanimation of GUI code and data.
A number of other (spatial) memory forensics tools
have also been developed recently for Android. Many of
these approaches recover raw instances of app-speciﬁc
data structures to reveal evidence: App-speciﬁc login
credentials were recovered by Apostolopoulos et al. [8].
Macht [28] followed by Dalvik Inspector [6] involved
techniques to recover Dalvik-JVM control structures and
raw Java object content. Earlier, Thing et al. [42] found
that text-based message contents could be recovered
from memory images. Most recently, our VCR [36] tech-
nique made it possible to recover images/video/preview
frames from a phone’s camera memory.
In a mobile device-agnostic effort, DEC0DE [44] in-
volved an effective technique to carve plain-text call logs
and address book entries from phone storage using prob-
abilistic ﬁnite state machines.
USENIX Association  
25th USENIX Security Symposium  1149
RetroScope shares the philosophy of leveraging exist-
ing code for memory content rendering with our prior
memory forensics technique DSCRETE [37]. However,
DSCRETE renders a single application data structure,
whereas RetroScope renders full app display screens in
temporal order. More importantly, DSCRETE requires
application-speciﬁc (actually, data structure-speciﬁc)
identiﬁcation and extraction of data rendering code,
while RetroScope is totally app-agnostic, requiring no
analysis of app-internal data or rendering logic. Fi-
nally, DSCRETE works on Linux/x86 whereas Retro-
Scope works on the Android/ARM platform.
Many prior memory forensics techniques leverage
memory image scanning and data structure signature
generation approaches [11,12,16,26,32,34,38,41]. Data
structure signatures can be content-based [16] or “points-
to” structure-based [13, 15, 25, 26, 30]. For binary pro-
grams without source code, a number of reverse en-
gineering techniques have been proposed to infer data
structure deﬁnitions [24, 27, 39]. As a fundamentally
new memory forensics technique, RetroScope requires
neither data structure signature generation nor memory
scanning.
7 Conclusion
We have presented RetroScope, a spatial-temporal mem-
ory forensics technique (and new paradigm) that recov-
ers multiple previous screens of an app from an Android
phone’s memory image. RetroScope is based on a novel
interleaved re-execution engine which selectively rean-
imates an app’s screen redrawing functionality without
requiring any app-speciﬁc knowledge. Our evaluation
results show that RetroScope can recover visually accu-
rate, temporally ordered screens (ranging from 3 to 11
screens) for a variety of apps on three different Android
phones.
Acknowledgments
We thank the anonymous reviewers for their insightful
comments and suggestions. This work was supported in
part by NSF under Award 1409668.
References
[1] Advanced jtag mobile device forensics training.
http:
//www.teeltech.com/mobile-device-forensics-
training/jtag-forensics/, 2015.
[2] Forensics wiki
- memory
imaging
tools.
http:
//forensicswiki.org/wiki/Tools:Memory_Imaging,
2015.
[3] ISIS still using Telegram channels
- Business
Insider.
http://www.businessinsider.com/isis-telegram-
channels-2015-11, 2015.
[4] Signal, the Snowden-Approved Crypto App, Comes to Android.
http://www.wired.com/2015/11/signals-snowden-
approved-phone-crypto-app-comes-to-android/,
2015.
[5] Apple vs.
the FBI: Google, WhatsApp, John McAfee and
more are taking sides - LA Times. http://www.latimes.
com/business/technology/la-fi-tn-tech-response-
apple-20160218-snap-htmlstory.html, 2016.
[6] 504ENSICS LABS.
Dalvik Inspector.
http://www.
504ensics.com/automated-volatility-plugin-
generation-with-dalvik-inspector/, 2013.
[7] 504ENSICS LABS. LiME Linux Memory Extractor. https:
//github.com/504ensicsLabs/LiME, 2013.
[8] APOSTOLOPOULOS, D., MARINAKIS, G., NTANTOGIAN, C.,
AND XENAKIS, C. Discovering authentication credentials in
volatile memory of android mobile devices.
In Collaborative,
Trusted and Privacy-Aware e/m-Services. 2013.
[9] ASHCROFT, J., DANIELS, D. J., AND HART, S. V. Forensic
examination of digital evidence: A guide for law enforcement.
U.S. National Institute of Justice, Ofﬁce of Justice Programs, NIJ
Special Report NCJ 199408 (2004).
[10] BECHER, M., DORNSEIF, M., AND KLEIN, C. Firewire: all
your memory are belong to us. CanSecWest (2005).
[11] BETZ, C. Memparser forensics tool. http://www.dfrws.org/
2005/challenge/memparser.shtml, 2005.
[12] BUGCHECK, C. Grepexec: Grepping executive objects from pool
memory. In Proc. Digital Forensic Research Workshop (2006).
[13] CARBONE, M., CUI, W., LU, L., LEE, W., PEINADO, M., AND
JIANG, X. Mapping kernel objects to enable systematic integrity
checking. In Proc. CCS (2009).
[14] CARRIER, B. D., AND GRAND, J. A hardware-based memory
acquisition procedure for digital investigations. Digital Investi-
gation 1 (2004).
[15] CASE, A., CRISTINA, A., MARZIALE, L., RICHARD, G. G.,
AND ROUSSEV, V. FACE: Automated digital evidence discovery
and correlation. Digital Investigation 5 (2008).
[16] DOLAN-GAVITT, B., SRIVASTAVA, A., TRAYNOR, P., AND
GIFFIN, J. Robust signatures for kernel data structures. In Proc.
CCS (2009).
[17] GOOGLE,
INC.
Android dashboards - platform versions.
https://developer.android.com/about/dashboards/
index.html, 2015.
[18] GRUHN, M. Windows nt pageﬁle. sys virtual memory analysis.
In Proc. IT Security Incident Management & IT Forensics (IMF)
(2015).
[19] HALDERMAN, J. A., SCHOEN, S. D., HENINGER, N., CLARK-
SON, W., PAUL, W., CALANDRINO, J. A., FELDMAN, A. J.,
APPELBAUM, J., AND FELTEN, E. W. Lest we remember:
cold-boot attacks on encryption keys. In Proc. USENIX Security
(2008).
[20] HILGERS, C., MACHT, H., MULLER, T., AND SPREITZEN-
BARTH, M. Post-mortem memory analysis of cold-booted an-
droid devices. In Proc. IT Security Incident Management & IT
Forensics (IMF) (2014).
[21] JARRETT, H. M., BAILIE, M. W., HAGEN, E., AND JUDISH,
N. Searching and seizing computers and obtaining electronic ev-
idence in criminal investigations. U.S. Department of Justice,
Computer Crime and Intellectual Property Section Criminal Di-
vision (2009).
[22] KOLL ´AR, I. Forensic ram dump image analyser. Master’s Thesis,
Charles University in Prague (2010).
1150  25th USENIX Security Symposium 
USENIX Association
[44] WALLS, R., LEVINE, B. N., AND LEARNED-MILLER, E. G.
In Proc.
Forensic triage for mobile phones with DEC0DE.
USENIX Security (2011).
[45] YANG, S. J., CHOI, J. H., KIM, K. B., AND CHANG, T. New
acquisition method based on ﬁrmware update protocols for an-
droid smartphones. Digital Investigation 14 (2015).
Appendix
A. Memory Image Acquisition
A prerequisite of memory forensics is the timely acquisi-
tion of a memory image from the subject device. Mem-
ory images typically contain a byte-for-byte copy of the
entire physical RAM of a device or the virtual memory
of an operating system or speciﬁc process(es). Tradi-
tionally, acquisition is performed by investigators, be-
fore the subject device is powered down, using mini-
mally invasive software (e.g., fmem [22], LiME [7]) or
hardware (e.g., Tibble [14], CoPilot [31]) tools. Other
notable techniques have used the DMA-capable Firewire
port [10] to acquire memory images, existing hibernation
or swap ﬁles [18, 23, 32, 33], or cold/warm booted de-
vices [19,20,43], but such approaches are only employed
for highly specialized investigations. A more compre-
hensive list of memory image acquisition tools can be
found in [2].
Android memory forensics was initially proposed dur-
ing the development of memory acquisition tools for the
devices. Most known among these are the software-
based LiME [7] and TrustDump [40] techniques. In an
alternative approach, Hilgers et al. [20] proposed cold-
booting Android phones to perform memory forensics.
Our evaluation of RetroScope used both LiME and a
ptrace-based tool we developed (also available with the
open source RetroScope code). Meanwhile, hardware-
based memory acquisition from a mobile device is often
performed via the ARM processor’s JTAG port [1, 45].
[23] KORNBLUM, J. D. Using every part of the buffalo in windows
memory analysis. Digital Investigation 4 (2007).
[24] LEE, J., AVGERINOS, T., AND BRUMLEY, D. TIE: Principled
reverse engineering of types in binary programs. In Proc. NDSS
(2011).
[25] LIN, Z., RHEE, J., WU, C., ZHANG, X., AND XU, D. DIM-
SUM: Discovering semantic data of interest from un-mappable
memory with conﬁdence. In Proc. NDSS (2012).
[26] LIN, Z., RHEE, J., ZHANG, X., XU, D., AND JIANG, X. Sig-
Graph: Brute force scanning of kernel data structure instances
using graph-based signatures. In Proc. NDSS (2011).
[27] LIN, Z., ZHANG, X., AND XU, D. Automatic reverse engi-
neering of data structures from binary execution. In Proc. NDSS
(2010).
[28] MACHT, H. Live memory forensics on android with volatility.
Friedrich-Alexander University Erlangen-Nuremberg (2013).
[29] MEALY, G. H. A Method for Synthesizing Sequential Circuits.
Bell System Technical Journal 34, 5 (1955), 1045–1079.
[30] MOVALL, P., NELSON, W., AND WETZSTEIN, S. Linux phys-
ical memory analysis. In Proc. USENIX Annual Technical Con-
ference, FREENIX Track (2005).
[31] PETRONI, N., FRASER, T., MOLINA, J., AND ARBAUGH, W.
Copilot - a coprocessor-based kernel runtime integrity monitor.
In Proc. USENIX Security (2004).
[32] PETRONI JR, N. L., WALTERS, A., FRASER, T., AND AR-
BAUGH, W. A. FATKit: A framework for the extraction and anal-
ysis of digital forensic data from volatile system memory. Digital
Investigation 3 (2006).
[33] RICHARD, G. G., AND CASE, A. In lieu of swap: Analyzing
compressed ram in mac os x and linux. Digital Investigation 11
(2014).
[34] SALTAFORMAGGIO, B. Forensic carving of wireless network
information from the android linux kernel. University of New
Orleans (2012).
[35] SALTAFORMAGGIO, B., BHATIA, R., GU, Z., ZHANG, X.,
AND XU, D. GUITAR: Piecing together android app GUIs from
memory images. In Proc. CCS (2015).
[36] SALTAFORMAGGIO, B., BHATIA, R., GU, Z., ZHANG, X.,
AND XU, D. VCR: App-agnostic recovery of photographic evi-
dence from android device memory images. In Proc. CCS (2015).
[37] SALTAFORMAGGIO, B., GU, Z., ZHANG, X., AND XU, D.
DSCRETE: Automatic rendering of forensic information from
memory images via application logic reuse.
In Proc. USENIX
Security (2014).
[38] SCHUSTER, A. Searching for processes and threads in microsoft
windows memory dumps. Digital Investigation 3 (2006).
[39] SLOWINSKA, A., STANCESCU, T., AND BOS, H. Howard: A
In
dynamic excavator for reverse engineering data structures.
Proc. NDSS (2011).
[40] SUN, H., SUN, K., WANG, Y., JING, J., AND JAJODIA, S.
Trustdump: Reliable memory acquisition on smartphones.
In
Proc. European Symposium on Research in Computer Security.
2014.
[41] THE VOLATILITY
FRAMEWORK.
https://www.
volatilesystems.com/default/volatility.
[42] THING, V. L., NG, K.-Y., AND CHANG, E.-C. Live memory
forensics of mobile phones. Digital Investigation 7 (2010).
[43] VIDAS, T. Volatile memory acquisition via warm boot memory
survivability. In Proc. Hawaii International Conference on Sys-
tem Sciences (2010).
USENIX Association  
25th USENIX Security Symposium  1151