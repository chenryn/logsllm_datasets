title:Error Propagation Profiling of Operating Systems
author:Andr&apos;eas Johansson and
Neeraj Suri
Error Propagation Proﬁling of Operating Systems
Department of Computer Science, Technische Universit¨at Darmstadt
Andr´eas Johansson and Neeraj Suri
{aja,suri}@informatik.tu-darmstadt.de
Abstract
An Operating System (OS) constitutes a fundamental
software (SW) component of a computing system. The ro-
bustness of its operations, or lack thereof, strongly inﬂu-
ences the robustness of the entire system. Targeting en-
hancement of robustness at the OS level via use of add-on
SW wrappers, this paper presents an error propagation pro-
ﬁling framework that assists in a) systematic identiﬁcation
and location of design and operational vulnerabilities, and
b) quantiﬁcation of their potential impact. Focusing on data
(value) errors occurring in OS drivers, a set of measures is
presented that aids a designer to locate such vulnerabilities,
either on an OS service (system call) basis or a per driver
basis. A case study and associated experimental process,
using Windows CE .Net, is presented outlining the utility of
our proposed approach.
1. Introduction
The robustness of the OS, i.e., the ability to withstand
perturbations with continued service provision, directly af-
fects the robustness of the whole system. As applications
depend on the OS delivering correct and timely services, a
failure to do so will likely impact the system’s ability to de-
liver its services. In spite of the signiﬁcant ongoing efforts
to enhance OS robustness, and advances in the underlying
SW development processes, OS’s still occasionally fail to
deliver stipulated services. One reason is the complexity
of OS level interactions with varied SW components in the
system that are often unknown at OS design time, e.g., ap-
plications, drivers, libraries. This “dynamic” nature of OS’s
makes it hard to design an OS to be comprehensively robust
against errors that can occur in its operational environment.
This paper focuses on delivering a methodology whereby
the OS platform can be proﬁled using experimental fault in-
jection (FI) and data error propagation path analysis. This
proﬁling characterizes the behavior of the OS when exposed
to perturbation in its interaction with other system compo-
nents. The targeted errors are errors occurring in device
drivers. Drivers are reported to be a signiﬁcant source of OS
failures [5, 16, 19]. This arises as they are often not tested as
rigorously as the OS kernel; are often designed external to
the OS development team, lacking complete details of the
system; represent a signiﬁcant part of the system in terms
of code size; and may also be directly affected by malfunc-
tioning hardware or external errors. Throughout this paper,
errors refer to data level errors, i.e., errors that affect the
value of some variable in a program.
The goal of this paper is to demonstrate a quantiﬁable
and repeatable method for assessing error propagation for
an OS, where no source code access is viable, as is the case
for most commercial OS’s. The lack of source code poses
two main obstacles: (a) no changes can be made internally
to the components, neither the OS nor its drivers, and (b) the
error propagation analysis must be based on observations
made only on the interface between components. Error
propagation information reveals which errors occurring in
the OS environment (device drivers) will “ﬂow through” the
OS and ultimately affect applications. The non-dependency
on source code also makes it possible to target systems with-
out source code readily available. It also avoids the problem
of having the code bias the testing results, which sometimes
is a problem for white-box testing approaches.
To demonstrate the proposed proﬁling methodology a
case study is presented, using the Windows CE .Net operat-
ing system. The target was chosen for its OS representative-
ness and also as it offers a high degree of control and limited
complexity. The results from the case study are interpreted
using a set of measures, deﬁned to capture the error propa-
gation properties of the OS. We study the relations between
individual OS services to services in drivers as well as com-
posite metrics describing the exposure of errors on OS ser-
vices and the diffusion of errors from speciﬁc drivers. Two
drivers are studied and the error diffusion properties of the
two drivers are compared. The main results of the study
conclude that many errors do not propagate, or propagate
in a robust manner, i.e., the effect of an error is visible at
the application level, but does not lead to a failure. How-
ever, a few signiﬁcant error propagation paths are identiﬁed
which represent a serious threat to a highly robust design.
Proceedings of the 2005 International Conference on Dependable Systems and Networks (DSN’05) 
0-7695-2282-3/05 $20.00 © 2005 IEEE
To recap, the contributions found in this paper include:
- Development of OS error propagation measures.
- Quantiﬁable methods for assessing the aforemen-
tioned measures without source code availability.
- A case study to demonstrate the experimental as-
sessment process.
Paper Organization: Sec. 2 puts our work in context
by discussing related work. Sec. 3 presents the system and
error model used in this work. Sec. 4 develops and details
the measures used for proﬁling an OS for errors in drivers.
Sec. 5 and 6 present the case study and obtained results.
Analysis and discussion of the results and future research
directions are presented in Sec. 7. Sec. 8 presents conclu-
sions.
2. Related Work
Robustness studies of large SW systems have been con-
ducted for many years. In [8] the robustness of C-libraries
was evaluated and enhanced using wrappers. POSIX in-
terfaces are the targets in [14], where OS’s are compared
using failure mode analysis. The techniques used in [14]
correspond, in part, to ours (injection strategy, error model,
etc), but with applications instead of drivers as the source of
errors. The effects of driver errors on the Linux kernel were
studied in [1]. The main difference with our approach is
that we focus on error propagation measures, as a facilitator
for wrapper placement. The work presented herein comple-
ments [1] in this respect, as the approaches and error models
are similar. In [2] an extensive failure mode analysis was
performed, using code mutations in drivers with the pur-
pose of building a dependability benchmark. Micro-kernels
have also been targets for studies [3], where bit-ﬂips in ei-
ther kernel API’s or memory are used to simulate hardware
(HW) as well as SW faults. The main contribution of our
work, with respect to the other studies, are again that we fo-
cus on quantiﬁable measures of error propagation. Also, we
focus speciﬁcally on data level errors, whereas other studies
have used other error models such as bit-ﬂips [3] and code
mutations [2].
In our prior work, the EPIC framework (Exposure, Per-
meability, Impact and Criticality), together with the sup-
porting experimental tool PROPANE [11, 12], proﬁles sta-
tic, modular software (ﬁxed set of modules that interact in a
predeﬁned manner) for error propagation to ascertain effec-
tive placement of wrappers. The framework focuses on pro-
ﬁling the signals used in the interaction between modules
using both error propagation and effect proﬁles. Using the
permeability, and exposure metrics, propagation proﬁles re-
veal information on where errors propagate through the sys-
tem and which modules/signals are more exposed to propa-
gating errors. In our current OS-themed work, the emphasis
is on dynamic software interactions as the set of applications
is not generally known in advance. Thus, all possible inter-
action paths (and consequently error propagation paths) are
not known a priori.
Tools have also been developed with the speciﬁc purpose
to protect a system from malfunctioning drivers.
In [19]
drivers are wrapped to track erroneous memory accesses,
which is a major problem in device drivers. One issue raised
in [19] was that some data level errors cannot automatically
be traced. We believe that our approach complements [19]
to this end. In [18] an Interface Deﬁnition Speciﬁcation is
used to improve driver robustness. In the Microsoft SLAM
project [4] a static veriﬁcation technique is used to verify
that device drivers adhere to a given interface. This project
effectively has the same goal as ours, with the difference
that we use no source code knowledge or formal speciﬁca-
tion of the interfaces. Both approaches are promising and
will likely coexist for different scenarios.
3. System and Error Model
Given the diversity of OS implementations, we target
a simple system model that comprises four major layers;
hardware, drivers, OS and applications, see Figure 1. This
model is generic enough to be representative and applica-
ble to most modern OS’s, e.g., Windows, GNU/Linux and
UNIX. Each system layer supplies a set of services to its
neighboring layers. For us, a service is typically a function
call, e.g., function entry points in drivers and OS system
calls. We say that a set of services constitutes an interface,
for instance the OS-driver interface.
Application layer
[OS-Application inteface]
OS Layer
[OS-Driver interface]
Driver Layer
Hardware Layer
...
APP
...
...
...
APP
...
...
Operating System
...
...
...
...
...
...
...
D1
...
D2
...
...
DN
Hardware Platform
}si
}osx.y
}dsx.z
Figure 1. Generalized system model.
The driver layer is responsible for handling interactions
between the hardware and the OS. Direct interactions with-
out the involvement of a driver are indeed possible, how-
ever, we focus only on the general case of interactions with
Proceedings of the 2005 International Conference on Dependable Systems and Networks (DSN’05) 
0-7695-2282-3/05 $20.00 © 2005 IEEE
driver involvement. We have chosen to treat drivers as com-
ponents of the system and not as a subcomponent of the OS.
One may argue that drivers are actually an intrinsic part of
the OS, but our view facilitates fuller representation of com-
ponent interactions.
The system has a number of drivers enumerated as
{D1, D2,··· , DN}. Each driver both imports (for instance
via system calls) and exports services to the OS (provided
by the driver) and we consider each category of driver-OS
interactions separately. Each driver exports a set of services.
These can be enumerated as {dsx.1, dsx.2,··· , dsx.M},
where dsx.y is the yth service exported by driver Dx.
In the OS layer, we include shared libraries existing in
the system, reﬂecting the viewpoint of a programmer, i.e.,
libraries support functionalities that programs need. For this
layer we deﬁne two primary sets of interfaces where inter-
action takes place. First, through the OS-Application in-
terface, the OS provides a set of services {s1, s2,··· , sS},
through which applications interact with the OS. The sec-
ond interface contains the interactions between the OS and
the drivers (through the OS-Driver interface). For a speciﬁc
driver Dx, the set of services it imports from the OS is de-
noted {osx.1, osx.2 ··· osx.K}. Using the same notation as
for driver services, osx.q is the qth imported OS service by
Dx. Note that the same services can be used by both drivers
and applications.
Applications running on the system utilize services pro-
vided by the OS to, in turn, provide services to the users
of the system. Thus, as different OS services have different
robustness properties, the way applications make use of OS
services will impact the robustness of their operations.
Throughout this paper we use a black-box software
model, i.e., no source code level knowledge is assumed
about the components, only their interface speciﬁcations.
This system view corresponds to the view of developers us-
ing the system for a particular design. The speciﬁcation
can be textual, like a reference manual, but also header ﬁles
needed for compiling a program are considered to be part of
the speciﬁcation. Components are supplied in binary form.
We assume that we have access, and possibilities to inspect
and modify the binary image of the driver and the possi-
bility of inspecting and modifying them such that that the
interaction between the layers can be monitored and modi-
ﬁed. Note that this does not require source code access!
3.1. Error Model
Our error model is transient data level errors, which are
the result of implementation defects in the driver as well
as value faults related to malfunctioning HW. This error
model, when used for error injection, has three basic com-
ponents: a) the type, or nature of the error, b) the location of
the error, and c) the timing of the injection. In the following
paragraphs we deﬁne each of these properties.
Error Types: For this study we chose data level er-
rors, based on the C-type of each parameter, i.e., the data
type used for the parameter. We use C-types as the OS-
Driver interface for this target is deﬁned using the C lan-
guage. We ﬁnd data errors of high interest as they are hard
to detect with general error detection techniques (like track-
ing of memory accesses) and may still lead to severe fail-
ures. They also allow for ﬂexible insertion using a black-
box view of the system. Sec. 2 discusses other error models
found in literature.
Error
Integers
Void
Characters
Boolean
Enums
Structs
C-Type
int
unsigned int
long
unsigned long
short
unsigned short
LARGE INTEGER
* void
char
unsigned char
wchar t
bool
multiple cases
multiple cases
#Cases
7
5
7
5
7
5
7
3
7
5
5
1
#identiﬁers
1
Table 1. The error types used in this study.
We have currently implemented this error model for 27
different C-types, both basic and user deﬁned (here the
“user” refers to the OS). Table 1 shows an overview of the
types needed to perform the case study presented later in
Sec. 5, and shows the number of test cases deﬁned for
each type. For each C-type, different data values are cho-
sen as test cases, including offset values, common values
and boundary values. The values are chosen to both cover
equivalent classes of values and boundary values. As an ex-
ample, table 2 shows the errors for type int. Note that
Cases 1 and 2 allow for under/overﬂow to happen.
Case #
New value
1
2
3
4
5
6
7
(Previous value) - 1
(Previous value) + 1
1
0
-1
INT MIN
INT MAX
Table 2. Error cases for type int.
Error Location: As already mentioned, we focus on
data errors in the OS-driver interface. By introducing errors
in the parameters used in this interface we simulate errors
Proceedings of the 2005 International Conference on Dependable Systems and Networks (DSN’05) 
0-7695-2282-3/05 $20.00 © 2005 IEEE
occurring within the driver in question. An example of an
OS service in this interface is shown below:
LONG RegQueryValueEx([in]
[in]
[in]
[out]
[out]
[in/out] LPDWORD lpcbData);
HKEY
LPCWSTR lpValueName,
LPDWORD lpReserved,