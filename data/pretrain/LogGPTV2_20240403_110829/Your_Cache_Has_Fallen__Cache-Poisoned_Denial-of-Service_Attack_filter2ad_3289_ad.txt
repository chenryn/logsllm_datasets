### 5.3 Feasibility of HHO Attacks

Table 3 presents the results of our study on request header size limits, including the documented limits specified in the corresponding HTTP implementation documentation when available. We have excluded web frameworks such as ASP.NET, Django, Flask, Laravel, Rails, Symfony, and Spring Boot from this table because their request header size limits are dependent on the specific web server and deployment environment used.

Our findings reveal significant variations in request header size limits among different HTTP implementations. Notably, CloudFront offers a much higher request header size limit compared to many other HTTP implementations we tested. Additionally, CloudFront caches the error code 400 Bad Request by default (see Table 1), which is commonly returned by most HTTP implementations when the request header size limit is exceeded. Consequently, our experiments show that any HTTP implementation with a lower request header size limit than CloudFront, which returns a 400 Bad Request status code when the limit is exceeded, is vulnerable to HHO CPDoS attacks. For example, Apache HTTPD and Nginx, which are often used as web servers or reverse proxies, have lower request header size limits than CloudFront.

Apache HTTPD and Nginx are among the most widely used web servers, according to a Netcraft survey [28]. These systems are frequently deployed with other intermediate systems. When these HTTP implementations are used in conjunction with CloudFront, they become susceptible to HHO CPDoS attacks. This vulnerability extends to scenarios where Apache HTTPD and Nginx are configured as intermediate reverse proxies in front of other web applications. Furthermore, these web servers are often used as the deployment environment for web frameworks like Rails, Django, Flask, Symfony, and Laravel. All these web frameworks are also vulnerable to HHO CPDoS if deployed with Apache HTTPD or Nginx.

Spring Boot and ASP.NET can also be affected by HHO CPDoS attacks, as both require a web server in production. Spring Boot can be deployed with Tomcat, and ASP.NET can use IIS. Both Tomcat and IIS have request header size limits lower than CloudFront and return a 400 Bad Request error for oversized headers. Heroku, another popular deployment platform, supports frameworks such as Django, Flask, Laravel, Rails, and Symfony. Since Heroku has a lower request header size limit than CloudFront, web applications using Heroku in conjunction with CloudFront are also vulnerable.

Other HTTP implementations vulnerable to HHO CPDoS when using CloudFront include Play 2 and cloud services like Amazon S3, GitHub Pages, and Heroku. Play 1 is also vulnerable, even though it does not return an error page when the request header size limit is exceeded. Instead, it does not return any response, leaving the TCP socket open until the web application shuts down. In this case, CloudFront returns a 502 Bad Gateway error, which is then cached and reused for subsequent requests. Google Storage, however, is not vulnerable to HHO CPDoS despite having a lower request header size limit than CloudFront. It returns a 413 Payload Too Large error for oversized headers, which is not cached by any of the analyzed web caching systems.

Table 3 also includes results for Nginx with the WAF plugin ModSecurity. In this configuration, the request header limit is reduced to 8,190 bytes, making it easier to conduct an HHO CPDoS attack. While ModSecurity is designed to prevent web application attacks, it inadvertently facilitates HHO CPDoS in this scenario.

IIS and web frameworks like ASP.NET running on IIS are also vulnerable to HHO CPDoS attacks when using CloudFront. However, they may also be vulnerable when using Akamai, Fastly, CDN77, Cloudflare, and Varnish. IIS allows setting a size limit for specific request headers, and if this limit is exceeded, it returns a 404 Not Found error, which is cached by these CDNs.

### 5.4 Feasibility of HMC Attacks

Table 4 summarizes the results of our third set of experiments, which focused on the handling of strings containing meta characters. For clarity, we only list characters and strings that are blocked or sanitized by at least one of the tested HTTP implementations. Web frameworks like ASP.NET, Django, Flask, Laravel, Spring Boot, and Symfony are omitted from this table because their handling of meta characters depends on the web server and deployment environment.

Our evaluation shows that many of the analyzed systems consider control characters as a potential threat. Suspicious characters or strings are either blocked with an error code or sanitized from the request header. However, the handling of meta characters varies significantly. For instance, CloudFront blocks the character \u0000 and sanitizes \n, \v, \f, \r, but forwards other control characters like \a, \b, and \e without modification. If Apache HTTPD, IIS, or Varnish is used with CloudFront, these systems will block the forwarded header containing forbidden characters with a 400 Bad Request error, which CloudFront then caches. This means that all tested HTTP implementations, which block harmful strings and characters not rejected or sanitized by CloudFront, are vulnerable to HMC CPDoS attacks. This includes Apache HTTPD, IIS, Varnish, GitHub Pages, GitLab Pages, BeeGo, Gin, Meteor.js, and Play 2. Express.js is also vulnerable to HMC CPDoS, even though it does not block any tested string with an error code. The issue here is similar to the one described for Play 1, where no response is returned, leading to a 502 Bad Gateway error from CloudFront.