a corresponding virtual address within the memory space of
the handling thread (i.e., TA). Thus when the TA accesses
any pointer arguments, it can access them as normal pointers
(i.e., without any additional veriﬁcation calls). However, the
TA must strictly ensure that the types of all of the arguments
are as expected, or else type-confusion attacks could be utilized
to exploit the TA or trusted kernel. For example, if a memory
pointer could be disguised as a value, bypassing PTRSAN,
memory regions outside of the shared memory region could
be passed to a TA, which would result in a BOOMERANG
vulnerability. This process is shown in Figure 5.
4) BOOMERANG on OP-TEE: Although the use of
common-memory prevents all TAs from accessing the un-
trusted OS’s memory, the shared memory ids (shmids) as-
signed to the different untrusted applications are stored in a
global structure. This allows a malicious untrusted applica-
tion to read and write the corresponding common-memory
assigned to another untrusted application resulting in
BOOMERANG vulnerabilities [31], [32]. As described above,
common-memory provides a shared memory communica-
tion channel between untrusted applications and TAs, and,
depending on the TA, this memory region can contain sensitive
information (e.g., DRM decrypted content, passwords, or cryp-
tographic keying material). Moreover, we also found a heap
overﬂow [29] and an out-of-bounds read [30] in the PTRSAN
function of the untrusted kernel driver. The OP-TEE developers
responded promptly, ﬁxing all of these issues; however, these
various bugs demonstrate just how difﬁcult a shared memory
management
implementation can be to deploy in practice.
While shared memory regions can be used to defend against
general BOOMERANG vulnerabilities, they present a signiﬁcant
degree of complexity and subtlety that must be overcome.
There are also other technical limitations introduced with this
approach (e.g., performance, limited parameters), which we
discuss in detail in Section VI.
D. Huawei
We analyzed the TrustZone implementation from Huawei,
with tens of millions of devices in circulation.
1) Untrusted Application and Untrusted OS: This TEE
implementation,
like Trustonic, employs a kernel driver
/dev/tc_ns_client and a service teecd, which all
user-space applications must use to communicate with the
secure world. The permissions are similarly set such that
untrusted user applications cannot communicate with the driver
directly. Similar to OP-TEE, all parameters in the secure-world
interface are one of two broad types: pointers and values, and
all calls to secure world support up to four parameters, which
can take either of those types.
However, in this instance, untrusted applications can di-
rectly pass an address with an offset as a pointer argument
in their commands. The kernel driver attempts to perform
PTRSAN by ﬁrst checking that the corresponding address is
indeed in the requesting application’s memory before replacing
the address with the corresponding physical address, incre-
mented by the provided offset.
2) Untrusted OS and Trusted OS: The interactions be-
tween the untrusted world OS and the trusted world OS
are, again, done using the standard SMC instruction. All
parameters to be passed are packed into a common structure
(TC_NS_SMC_CMD), and the physical address of this structure
is passed as the argument to the SMC call (similar to QSEE).
3) Trusted OS and Trusted Application: As with other
trusted world implementations, each TA runs in an isolated
process and interacts with the trusted OS through system calls
(using SVC instructions). However, in this instance, the entire
non-secure world memory space is mapped into every TA,
which makes exploiting BOOMERANG vulnerabilities trivial.
4) BOOMERANG on Huawei: BOOMERANG exists on this
implementation for a few reasons. First, PTRSAN fails to
validate the offset value; a malicious untrusted application
can use this to pass an arbitrary physical address to the TA.
Second, almost all
the TAs we examined do not validate
the types of parameters, allowing one to bypass PTRSAN
entirely, by misrepresenting the type of an argument to the
kernel driver as a non-pointer, while still being correctly
interpreted as a pointer by the TA. Type-confusion attacks
within the TA are cumbersome to avoid, as each function that
handles the parameter must independently verify that the type
of the argument is correct, since the parent function has no
insight into the ultimate use of each parameter. We found both
instances of BOOMERANG (i.e., PTRSAN bypass and type-
confusion) in different components within this implementation,
as we show in Section VI-A.
E. Sierraware Trusted Execution Environment (SierraTEE)
SierraTEE is a Trusted Execution Environment devel-
oped by Sierraware [46]. They published an open source
version of their implementation under the Open Virtualiza-
tion project [45]. Similar to OP-TEE,
this adheres to the
GlobalPlatform speciﬁcation [13] and provides libraries to
support development. Although SierraTEE is used in academic
projects [39], we were unable to determine whether it is used
in any commercial device.
1) Untrusted Application and Untrusted OS: Simi-
lar
to OP-TEE, SierraTEE employs
a kernel driver
/dev/otz_client and a client library libotzapi.so
for ease of development. Applications can either use the driver
or library to interact with the TAs. Similar to OP-TEE, all
parameters to the TA are strongly typed, with three possible
types: pointer, 32-bit value, or array. To pass a pointer,
untrusted applications should ﬁrst use mmap on the driver
to allocate memory of the required size. The kernel driver
then allocates the memory and associates it with the requested
address (i.e., usr_addr), which can be used by the corre-
sponding application as a shared memory id (shmid). Similar
to Huawei, a pointer argument is passed as a tuple of (shmid,
length, offset).
2) Untrusted OS and Trusted OS: First, PTRSAN is per-
formed on all the pointer arguments by computing the physical
8
TABLE I: Summary of
BOOMERANG across the various TEE implementations.
the various manifestations of
Vendor
QSEE
Trustonic
OP-TEE
Huawei
SierraTEE
Common Entity
Shared Memory
Unique Identiﬁer
B∗
P tr
bP tr
Physical Address
BP tr
BP tr, BT ype
BP tr
B - Full BOOMERANG (arbitrary non-secure memory access)
B∗ - Full BOOMERANG, but requires an additional exploit
b - Partial BOOMERANG (access to speciﬁc regions of non-secure memory)
P tr - PTRSAN bypass vector present
T ype - Type-confusion vector present
address corresponding to the provided shmid. The resulting
physical address and its corresponding length are packed as
the new pointer argument. Next, all the arguments are packed
into an otz_smc_cmd structure, and the physical address of
this structure is passed as the argument to the SMC instruction,
and therefore to the trusted OS.
3) Trusted OS and Trusted Application: Similar
to
OP-TEE, each TA runs as an unprivileged application within
the secure world, in its own thread. Privileged operations must
be performed through system calls (SVC instructions), and are
handled by the trusted OS. All parameters from the untrusted
OS and applications are directly passed to the destination TA.
As mentioned above, these take the form of physical memory
addresses and region lengths, which must be mapped by the
TA prior to use.
4) BOOMERANG on SierraTEE: Similar
to Huawei,
PTRSAN in SierraTEE fails to validate the offset for
pointer arguments. This allows a malicious untrusted appli-
cation to pass an arbitrary physical address to the TA leading
to a BOOMERANG vulnerability. Furthermore, we noticed that
PTRSAN also fails to verify the length parameter, which
increases the exploitability of this ﬂaw.
We notiﬁed Sierraware of our ﬁndings on multiple oc-
casions, beginning in October 2016, and received no reply.
We suggest that the users of the open source version of the
SierraTEE be aware of this issue, and contact Sierraware to
obtain an appropriate ﬁx.
F. Observed Instances of BOOMERANG
In summary, we have observed two distinct instances of
BOOMERANG in practice: PTRSAN bypass attacks, where
the pointer sanitization function can be bypassed altogether,
and type-confusion attacks, where TAs can be tricked into
treating a non-pointer value as a pointer. This general ﬂaw
(i.e., the secure world’s ability to freely inﬂuence non-secure
memory) exists on each system, regardless of the common
entity used for passing memory references between worlds.
Table I demonstrates how the various bugs affect the vendors
that we examined. It is worth noting that every analyzed TEE
implementation is affected by BOOMERANG to some degree.
The table only outlines the bugs that we personally were able
to verify; however, we have reasons to believe Trustonic also
likely contains a pointer-confusion attack, but we are unable
to verify this hypothesis without access to the un-encrypted
TAs.
9
VI. FINDING BOOMERANG VULNERABILITIES
To evaluate the severity of BOOMERANG, we explored
two very popular commercially available TEE implementations
(i.e., QSEE and Huawei) to see if exploitable BOOMERANG
ﬂaws existed in deployed TAs. We were unable to perform
our analysis on Trustonic’s implementation because all of
their TAs are encrypted. Similarly, we did not evaluate any
TAs developed for the OP-TEE and SierraTEE architectures,
as they have not been deployed on any commercial devices.
We, indeed, found the BOOMERANG vulnerabilities in all of
the evaluated TAs that accepted pointers from the non-secure
world, some of which we used to craft exploits.
A. Detecting Potential Vulnerabilities
As we showed in Section V, all of the TrustZone im-
plementations that we analyzed will, at some point, pass
commands from the untrusted application to the TA through
the untrusted OS and the trusted OS. This data usually contains
an application-dependent structure, and, in malicious instances,
its contents may contain un-sanitized memory pointers. Thus,
the general approach to our detection technique is to perform
data-ﬂow analysis to track all of the data that is passed from
the non-secure world, and annotate any functions that use any
portion of this data as a pointer. By capturing any function that
dereferences non-secure data as a pointer, an analyst could
then trivially use manual analysis to see if that data can be
controlled by an untrusted application in a way that bypasses
PTRSAN, which would result in a BOOMERANG vulnerability.
We created a static analysis technique to locate these
instances using simulated execution, which we implemented
using the angr [44] static analysis and reverse-engineering
framework. Our analysis works in the following way: First, we
analyze the control ﬂow graph and perform function recovery
on a given TA, which identiﬁes function entry points based on
standard ARM calling conventions. This step requires that the
binary is not obfuscated (e.g., encrypted or packed). Next, we
locate the source of any input data, by locating the primary
command dispatcher of the TA. This function is TEE-speciﬁc,
but can be found easily through reverse engineering (e.g.,
identifying entry points in the program or using symbols) and
is applicable to every TA for that TEE implementation. In
QSEE’s implementation, we referenced prior work to locate
the command dispatcher [25], which accepts 4 arguments,
consisting of the input and output buffers and their sizes
(i.e., send_buf, send_len, resp_buf, resp_len). On
Huawei, we were able to locate the symbol referring to the
command dispatcher, which takes a list of inputs, and a list of
the associated data types for each argument.
Once the command dispatcher function is located, we then
perform data-ﬂow analysis (similar to static taint tracking) on
the data in the input buffers to detect any instances where any
part of the input is used as a pointer. This pointer dereferencing
may be done explicitly in the code itself, but could also be
delegated to system calls within the trusted OS. Since the
semantics of system calls are TEE-speciﬁc, we require that an
analyst annotates those calls that handle the reading or writing
to non-secure memory for each TEE (e.g., cryptographic
operations or secure ﬁle-system operations). With the given
system calls identiﬁed, our data-ﬂow analysis can detect and
return relevant paths in the TA.
Fig. 6: Examples of the different types of data ﬂows that our tool would detect as being vulnerable to BOOMERANG.
Our analysis starts with the input buffers or argument lists
as a source and performs a blanket execution [10] of the
program, where all of the basic blocks in the control-ﬂow graph
(CFG) are executed, until the data from the source reaches a
sink (i.e., an annotated system call or memory operation). TAs
usually contains many possible commands, selectable by a TA-
speciﬁc command identiﬁer included as part of the request,
which is typically checked by the TA at the beginning of
execution. We can therefore locate a unique “handler” for
the different commands (i.e., cases in the main switch-case
statement of the command dispatcher), by analyzing all of the
call sites in the command dispatcher function. This information
is useful when determining exploitability, as it helps to identify
the major functionality of the TA that is exercised with the
identiﬁed vulnerability. Our tool will produce as output the call
chain from the input to the memory operation or system call,
and whether the ﬁnal operation is a read or a write. Figure 6
provides a high-level overview of our technique.
B. Vulnerabilities in QSEE
While hundreds of millions of devices use QSEE as their
TEE implementation, only a few TAs are actually widely
distributed for the platform. We were able to obtain the binaries
for KeyMaster, WideVine, and PlayReady, which to the best
of knowledge are the only 3 QSEE TAs that accept user input.
KeyMaster is the standard cryptographic application that is
included on all Android-based devices with a TEE. WideVine
is a Google-owned DRM technology, used most prominently in
the Netﬂix and YouTube applications. PlayReady is a similar
DRM technology provided by Microsoft, which provides DRM
support for Windows Media ﬁles, amongst others.
After running our static analysis technique on the three
Fig. 7: One of the three outputs of our data-ﬂow analysis
described in Section VI-A for the KeyMaster TA on QSEE.
10
TAs described above, we found that all of them were vul-
nerable to BOOMERANG attacks. KeyMaster contained three
separate call-chains that permit an untrusted application to read
arbitrary physical memory from within the non-secure world,
using functionality within the TA. Similarly, WideVine and
PlayReady both contained call-chains that permit an unprivi-
leged application to decrypt data to arbitrary physical memory
within the non-secure world, which could be leveraged for an
arbitrary physical memory write.
1) Proof-of-Concept (Memory Read): We were able to
easily leverage one of the three call chains located in QSEE’s
KeyMaster to craft a proof-of-concept arbitrary memory leak
exploit. Figure 7 shows a graphical representation of the
discovered path,
including the addresses of each function
call instruction between the input and a controllable memory
operation, as well as the type of memory operation (e.g.,
“read,” “write,” or in this case, “syscall”). The tool also
indicates the vulnerable “handler,” which is the start address
of the ﬁrst unique function seen among the set of all the call
chains.
In this case, the call chain terminates in QSEE system
call number 0x06, which was identiﬁed as the system call
that prepares for memory read operations from the non-
secure world. Using manual analysis, we were easily able to
determine the purpose of the handler function on our chosen
path, at 0x5ac, which generates cryptographic signatures of
data from the non-secure world. While the returned value
is signed, the attacker can select the key, cipher, data, and
data length. To recover the original non-secure world data, the
signature is performed on a single byte, with a known key, and
the result checked against a pre-computed table of signatures
for all of 256 possible values of a byte with that key. To control
the data that is to be signed, we can bypass PTRSAN in the
non-secure world using QSEECom_send_cmd (as shown in
Figure 3). The resulting exploit allows a malicious untrusted
application, in the non-secure world, to read any amount of
memory from an arbitrary location in the non-secure world,
including memory of all other applications and the kernel.
We disclosed this vulnerability, and proof-of-concept, to