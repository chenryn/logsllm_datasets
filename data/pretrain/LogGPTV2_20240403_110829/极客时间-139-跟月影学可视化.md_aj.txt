# 10 \| 图形系统如何表示颜色？你好，我是月影。从这一节课开始，我们进入一个全新的模块，开始学习视觉基础。 在可视化领域中，图形的形状和颜色信息非常重要，它们都可以用来表达数据。我们利用基本的数学方法可以绘制出各种各样的图形，通过仿射变换还能改变图形的形状、大小和位置。但关于图形的颜色，虽然在前面的课程中，我们也使用片元着色器给图形设置了不同的颜色，可这只是颜色的基本用法，Web图形系统对颜色的支持是非常强大的。 所以这一节课，我们就来系统地学习一下，Web图形系统中表示颜色的基本方法。我会讲四种基本的颜色表示法，分别是 RGB 和RGBA 颜色表示法、HSL 和 HSV 颜色表示法、CIE Lab 和 CIE Lch颜色表示法以及 Cubehelix 色盘。 不过，因为颜色表示实际上是一门非常复杂的学问，与我们自己的视觉感知以及心理学都有很大的关系，所以这节课我只会重点讲解它们的应用，不会去细说其中复杂的算法实现和规则细节。但我也会在课后给出一些拓展阅读的链接，如果你有兴趣，可以利用它们深入来学。 RGB 和 RGBA 颜色作为前端工程师，你一定对 RGB 和 RGBA 颜色比较熟悉。在 Web开发中，我们首选的颜色表示法就是 RGB 和RGBA。那我们就先来说说它的应用。 1. RGB 和 RGBA 的颜色表示法我们在 CSS 样式中看到的形式如 #RRGGBB 的颜色代码，就是 RGB颜色的十六进制表示法，其中 RR、GG、BB分别是两位十六进制数字，表示红、绿、蓝三色通道的**色阶**。色阶可以表示某个通道的强弱。 因为 RGB(A)颜色用两位十六进制数来表示每一个通道的色阶，所以每个通道一共有 256阶，取值是 0 到 255。RGB 的三个通道色阶的组合，理论上一共能表示224] slate-object="inline" 也就是一共 16777216 种不同的颜色。因此，RGB颜色是将人眼可见的颜色表示为**红、绿、蓝**三原色不同色阶的混合。我们可以用一个三维立方体，把 RGB能表示的所有颜色形象地描述出来。效果如下图： ![](Images/dcbc92783f6b0c88045f56abd22822ca.png)savepage-src="https://static001.geekbang.org/resource/image/5f/70/5ff37612dff2e7a89c58fcdc91236270.jpg"}RGB的所有颜色那 RGB 能表示人眼所能见到的所有颜色吗？事实上，RGB色值只能表示这其中的一个区域。如下图所示，灰色区域是人眼所能见到的全部颜色，中间的三角形是RGB能表示的所有颜色，你可以明显地看出它们的对比。 ![](Images/96eb050380571785f85812c122af6ca7.png)savepage-src="https://static001.geekbang.org/resource/image/95/6d/950d5507a41978byyd28d32bb81e736d.jpg"}人眼看到的颜色vsRGB能表示的颜色尽管 RGB 色值不能表示人眼可见的全部颜色，但它可以表示的颜色也已经足够丰富了。一般的显示器、彩色打印机、扫描仪等都支持它。 在浏览器中，CSS 一般有两种表示 RGB 颜色值的方式：一种是我们前面说的#RRGGBB 表示方式，另一种是直接用 rgb(red, green, blue)表示颜色，这里的"red、green、blue"是十进制数值。RGB颜色值的表示方式，你应该比较熟悉，我就不多说了。 好，理解了 RGB 之后，我们就很容易理解 RGBA 了。它其实就是在 RGB的基础上增加了一个 Alpha 通道，也就是透明度。一些新版本的浏览器，可以用#RRGGBBAA 的形式来表示 RGBA 色值，但是较早期的浏览器，只支持 rgba(red,green, blue, alpha) 这种形式来表示色值（注意：这里的 alpha 是一个从 0 到1的数）。所以，在实际使用的时候，我们要注意这一点。 WebGL 的 shader 默认支持 RGBA。因为在 WebGL 的 shader中，我们是使用一个四维向量来表示颜色的，向量的 r、g、b、a分量分别表示红色、绿色、蓝色和 alpha 通道。不过和 CSS的颜色表示稍有不同的是，WebGL 采用归一化的浮点数值，也就是说，WebGL的颜色分量 r、g、b、a 的数值都是 0 到 1之间的浮点数。 2. RGB 颜色表示法的局限性RGB 和 RGBA 的颜色表示法非常简单，但使用起来也有局限性（因为 RGB 和RGBA本质上其实非常相似，只不过后者比前者多了一个透明度通道。方便起见，我们后面就用RGB 来代表 RGB 和 RGBA 了）。 因为对一个 RGB颜色来说，我们只能大致直观地判断出它偏向于红色、绿色还是蓝色，或者在颜色立方体的大致位置。所以，在对比两个RGB 颜色的时候，我们只能通过对比它们在 RGB立方体中的相对距离，来判断它们的颜色差异。除此之外，我们几乎就得不到其他任何有用的信息了。 也就是说，**当要选择一组颜色给图表使用时，我们并不知道要以什么样的规则来配置颜色，才能让不同数据对应的图形之间的对比尽可能鲜明**。因此，RGB颜色对用户其实并不友好。 这么说可能还是比较抽象，我们来看一个简单的例子。这里，我们在画布上显示3 组颜色不同的圆，每组各 5个，用来表示重要程度不同的信息。现在我们给这些圆以随机的 RGB颜色，代码如下：     import {Vec3} from '../common/lib/math/vec3.js';    const canvas = document.querySelector('canvas');    const ctx = canvas.getContext('2d');    function randomRGB() {      return new Vec3(        0.5 * Math.random(),        0.5 * Math.random(),        0.5 * Math.random(),      );    }    ctx.translate(256, 256);    ctx.scale(1, -1);    for(let i = 0; i    [ /  ]? )而且，一些 JavaScript 库也已经可以直接处理 Lab颜色空间了，如d3-colorslate-object="inline"。下面，我们通过一个代码例子来详细讲讲，d3.lab 是怎么处理Lab 颜色的。如下面代码所示，我们使用 d3.lab 来定义 Lab 色彩。这个例子与HSL 的例子一样，也是显示两排圆形。这里，我们让第一排相邻圆形之间的 lab色值的欧氏空间距离相同，第二排相邻圆形之间的亮度按 5阶的方式递增。     /* global d3 */    for(let i = 0; i = a 时，返回1。 ![](Images/df55331170527f62286f2b7cb0b77601.png)savepage-src="https://static001.geekbang.org/resource/image/6d/52/6dcd4de27bb6753274814a6b0e8c8852.jpeg"}Step函数因此，d1 和 d2 分别有 2种取值情况。![](Images/2f7a08e6767106ba5b9d9c2af046d79f.png)savepage-src="https://static001.geekbang.org/resource/image/9b/5e/9baa897a9180ce776b72cb90a8cfd45e.jpg"}最后，我们要根据 d1 \* d2的值，决定背景网格使用哪个颜色来绘制。要实现这个目的，我们就要使用到第三个函数mix。mix 是线性插值函数，mix(a, b, c) 表示根据 c 是 0 或 1，返回 a 或者b。 比如在上面的代码中，当 st.x 小于 0.9 且 st.y 大于 0.1，也就是 d1 \*d2 等于 1 的时候，mix(vec3(0.8), vec3(1.0), d1 \* d2) 的结果是vec3(1.0)，也就是白色。否则就是vec3(0.8)，也就是灰色。最后，因为 rows 决定网格重复的次数，所以最终的效果和 rows的取值有关。为了让你有更直观的感受，我把 row 分别取 1、4、16、32、64时的效果都绘制出来了，你可以看看。![](Images/945eea0173aca38adbf998f9aa7c6ec7.png)savepage-src="https://static001.geekbang.org/resource/image/19/e6/19fd5561b5ac779f1de9d49c4d8bbbe6.gif"}rows为1、4、16、32、64的效果这就是我们用 Shader 实现重复图案的完整过程。它的优势在于，不管我们给rows 取值多少，图案都是一次绘制出来的，并不会因为 rows增加而消耗性能。所以，使用 Shader绘制重复图案，不管绘制多么细腻，图案重复多少次，绘制消耗的时间几乎是常量，不会遇到性能瓶颈。如何绘制分形图案说完了重复图案，我们再来说分形。它不仅是自然界中存在的一种自然现象，也是一种优美的数学模型。通俗点来说，一个分形图案可以划分成无数个部分，而每个部分的形状又都和这个图案整体具有相似性。所以，典型的分形效果具有局部与整体的自相似性以及无限细节（分形可以无限放大），能产生令人震撼的视觉效果。![](Images/5b4eafd6f5d80dcc157e45d11a21a140.png)savepage-src="https://static001.geekbang.org/resource/image/34/64/341085ab7bf1076255a3d151e563cc64.jpg"}自然界中的分形：罗马花椰菜实际上，分形在实践中偏向于视觉和 UI设计。虽然它在实际的可视化项目中不太常用，但总能够起到画龙点睛的作用。所以，了解分形在视觉呈现中的实现技巧还是很有必要的。下面，我们就来详细讲讲分形是怎么实现的。首先，我们来认识一下分形公式，MandelbrotSet，也叫曼德勃罗特集。它是由美国数学家曼徳勃罗特教授发现的迭代公式构成的分形集合。这个公式中Zn] slate-object="inline"和 Zn+1] slate-object="inline"是复数，C是一个实数常量。![](Images/d021d1864ea5f96915336e24ddc3d002.png)savepage-src="https://static001.geekbang.org/resource/image/db/77/db02b5eddd8721e9f5299853ace9d077.jpeg"}这个迭代公式使用起来非常简单，只要我们给定一个初始值，它就能产生许多有趣的图案。接下来，我们就一起来看一个有趣的例子。首先我们实现一个片元着色器，代码如下：    #ifdef GL_ES    precision mediump float;    #endif    varying vec2 vUv;    uniform vec2 center;    uniform float scale;    vec2 f(vec2 z, vec2 c) {      return mat2(z, -z.y, z.x) * z + c;    }    void main() {        vec2 uv = vUv;        vec2 c = center + 4.0 * (uv - vec2(0.5)) / scale;        vec2 z = vec2(0.0);        bool escaped = false;        int j;        for (int i = 0; i  iterations) break;          j = i;          z = f(z, c);          if (length(z) > 2.0) {            escaped = true;            break;          }        }        gl_FragColor.rgb = escaped ? vec3(float(j)) / float(iterations) : vec3(0.0);        gl_FragColor.a = 1.0;    }我们设置了初始的 z 和c，然后执行迭代。理论上曼德勃罗特集应该是无限迭代的，但是我们肯定不能让它无限循环，所以我们要给一个足够精度的最大迭代次数，比如65536。在迭代过程中，如果 z 的模大于2，那它就结束计算，否则就继续迭代，直到达到循环次数。我们把 (0, 0) 设置为图案中心点，放大系数初始设为1，即原始大小，然后开始渲染，代码如下：    const program = renderer.compileSync(fragment, vertex);    renderer.useProgram(program);    renderer.uniforms.center = [0, 0];    renderer.uniforms.scale = 1;    renderer.uniforms.iterations = 256;    renderer.setMeshData([{      positions: [        [-1, -1],        [-1, 1],        [1, 1],        [1, -1],      ],      attributes: {        uv: [          [0, 0],          [0, 1],          [1, 1],          [1, 0],        ],      },      cells: [[0, 1, 2], [2, 0, 3]],    }]);    renderer.render();![](Images/32e777c89e684dbb360b2fffd7bbf91f.png)savepage-src="https://static001.geekbang.org/resource/image/0d/5a/0d33586fd494f7ba55cfe17a7e9e105a.jpeg"}画布上最终的渲染结果这个图案本身似乎没有什么特别的效果，我们可以修改一下 Shader中的代码，改变渲染颜色的规则，根据迭代次数和迭代深度的比值来渲染不同的颜色，然后将它局部放大，就能得到非常有趣的图案了。![](Images/e4ff91d690173711f4cb59350f1a5db1.png)savepage-src="https://static001.geekbang.org/resource/image/b6/9e/b61a71e0de654958d1ee033b3b0a939e.gif"}如何给图案增加随机效果那分形图案为什么这么吸引人呢？如果你多看几个，就会发现，它们的无限细节里同时拥有重复和随机这两个规律。那对于其他非分形的图案，如果也想让它变得吸引人，我们其实可以给它们增加**随机效果**。不知道，你还记得我们开篇词中的那个抽奖程序吗？实际上它就是一个随机效果的应用。![](Images/243b47f6fccace9e45fe2a788fbcf890.png)savepage-src="https://static001.geekbang.org/resource/image/e7/eb/e7025fcba897df3b78205d1d711cb9eb.jpg"}产生随机色块的抽奖程序要想实现类似这样的随机效果，在 Shader中，我们可以使用伪随机函数。下面，我以一个常用的伪随机函数为例，来讲讲随机效果是怎么生成的。代码如下：    float random (vec2 st) {        return fract(sin(dot(st.xy,                             vec2(12.9898,78.233)))*            43758.5453123);    }这个伪随机函数的原理是，取正弦函数偏后部的小数部分的值来模拟随机。如果我们传入一个确定的st 值，它就会返回一个符合随机分布的确定的 float值。 我们可以测试一下这个伪随机函数，代码如下：    #ifdef GL_ES    precision highp float;    #endif    varying vec2 vUv;    float random (vec2 st) {        return fract(sin(dot(st.xy,                            vec2(12.9898,78.233)))*            43758.5453123);    }    void main() {        gl_FragColor.rgb = vec3(random(vUv));        gl_FragColor.a = 1.0;    }它的执行结果是一片噪点，效果如下图所示。![](Images/a280c5d13f57a85d35544052cab21c60.png)savepage-src="https://static001.geekbang.org/resource/image/65/22/65539f5eda08e26a22caaf84a66f5822.jpeg"}这些噪点显然不能满足我们想要的随机效果，因为它们只有一个像素，而且太小了。所以下一步，我们可以用floor取整函数，来生成随机的色块。      #ifdef GL_ES      precision highp float;      #endif      varying vec2 vUv;      float random (vec2 st) {          return fract(sin(dot(st.xy,                              vec2(12.9898,78.233)))*              43758.5453123);      }      void main() {          vec2 st = vUv * 10.0;          gl_FragColor.rgb = vec3(random(floor(st)));          gl_FragColor.a = 1.0;      }floor 函数和 JavaScript 的 Math.floor一样，都是向下取浮点数的整数部分，不过，glsl 的 floor可以直接对向量使用。我们通过 floor(st) 实际上取到了 0,0 到 9,9，一共 10行 \*10 列 =100 个方块。然后我们通过 random函数给每一个方块随机一个颜色，最终实现的结果如下：![](Images/a95e2ef4e2ab0bcda26a3162641ae7c9.png)savepage-src="https://static001.geekbang.org/resource/image/ac/c5/ac66f16a9d1fd8baf0ed86442462fbc5.jpeg"}此外，我们还可以结合随机和动态效果。具体的方法就是传入一个代表时间的uTime变量，实际代码和最终效果如下：    #ifdef GL_ES    precision highp float;    #endif    varying vec2 vUv;    uniform float uTime;    float random (vec2 st) {        return fract(sin(dot(st.xy,                            vec2(12.9898,78.233)))*            43758.5453123);    }    void main() {        vec2 st = vUv * vec2(100.0, 50.0);        st.x -= (1.0 + 10.0 * random(vec2(floor(st.y)))) * uTime;        vec2 ipos = floor(st);  // integer        vec2 fpos = fract(st);  // fraction        vec3 color = vec3(step(random(ipos), 0.7));        color *= step(0.2,fpos.y);        gl_FragColor.rgb = color;        gl_FragColor.a = 1.0;    }![](Images/dce66670b6a3e48a30403ad07d8da1bc.png)savepage-src="https://static001.geekbang.org/resource/image/8c/9c/8cee3889c8034f0d94211fcc1ec72b9c.gif"}除此之外，我们用 Shader来实现网格类的效果也特别方便。比如，下面我们就在 Shader 中用 smoothstep函数生成可以随机旋转方向的线段，从而生成一个迷宫。    #ifdef GL_ES    precision mediump float;    #endif    #define PI 3.14159265358979323846    varying vec2 vUv;    uniform vec2 u_resolution;    uniform int rows;    float random (in vec2 _st) {        return fract(sin(dot(_st.xy,                            vec2(12.9898,78.233)))*            43758.5453123);    }    vec2 truchetPattern(in vec2 _st, in float _index){        _index = fract(((_index-0.5)*2.0));        if (_index > 0.75) {            _st = vec2(1.0) - _st;        } else if (_index > 0.5) {            _st = vec2(1.0-_st.x,_st.y);        } else if (_index > 0.25) {            _st = 1.0-vec2(1.0-_st.x,_st.y);        }        return _st;    }    void main() {        vec2 st = vUv * float(rows);        vec2 ipos = floor(st);  // integer        vec2 fpos = fract(st);  // fraction        vec2 tile = truchetPattern(fpos, random( ipos ));        float color = 0.0;        color = smoothstep(tile.x-0.3,tile.x,tile.y)-                smoothstep(tile.x,tile.x+0.3,tile.y);        gl_FragColor = vec4(vec3(color),1.0);    }![](Images/9c9f3768193cf2c4e5c9d7af406fef68.png)savepage-src="https://static001.geekbang.org/resource/image/a3/3b/a3ae93b53bb2e3992267a1c996a5583b.jpeg"}要点总结今天，我们讲了可视化中三种常用图案的生成原理。第一种，批量重复图案。一般来说，在绘制批量重复图案的时候，我们可以采用2 种方案。首先是使用 CSS 的 background-image 属性，利用 backgroud-repeat快速重复绘制。其次，我们可以使用片元着色器，利用 GPU的并行渲染的特点来绘制。第二种，分形图案。绘制分形图案有一个可以直接的公式，曼德勃罗特集。我们可以使用它来绘制分形图案。第三种是在重复图案上增加随机性，我们可以在片元着色器中使用伪随机函数，来给重复图案实现随机效果。虽然我们说几何图形是用来承载数据信息，图案是来强化视觉效果的，但实际上，它们也并没有绝对的界限，有时候我们也可以将图案与数据信息一起管理。比如说，在上面那个动态效果的例子中，我们可以调整动态参数，让图形的运动速度或者黑白块的分布和数据量或者信息内容联系起来。这会大大强化可视化的视觉效果，从而加深用户对信息的理解。在这一节课，我们讲了大量关于 WebGL的片元着色器的知识。这是因为，片元着色器是最适合生成和绘制这些图案的技术，但这也并不意味着用其他图形系统，比如SVG 或者 Canvas就没法很好地生成并绘制这些图案了。实际上，它们的基本原理是相同的，所以用 SVG 或 Canvas同样可以绘制这些图案。只不过，因为 SVG 和 Canvas 渲染不能深入控制 GPU底层，所以就没法做到像 WebGL 这样并行高效地渲染这些图案。那如果在选择SVG 和 Canvas的可视化应用中，需要绘制大量的这些图案，就必然会导致性能瓶颈，这也是为什么我们一定要了解和掌握WebGL技术，只有这样，我们才能真正掌握绘制极有视觉冲击力的复杂图案的能力。最后，我还要啰嗦几句，如果你对片元着色器应用还不是很熟悉，对上面的代码还有疑问或者不是很理解，那也没有关系，你可以花一点时间，仔细研究一下GitHub 仓库slate-object="inline"的源代码。要记住，动手实践永远是我们最好的学习方式，没有之一。另外，在接下来的课程里，我们还会大量使用片元着色器创建更多有趣、炫酷的视觉效果。所以，我也建议你去从头看看这份关于片元着色器的学习资料，The Book ofShaders  slate-object="inline"，相信你会非常有收获。小试牛刀1.       在前面的例子里，我们实现了一个 10\*10    的灰色块方阵，这里我们使用的是灰度颜色，你能够渲染出彩色方块吗？你可以尝试将随机数映射成    HSV 坐标中的    H，然后绘制出不同的彩色方阵。        2.       在实现抽奖程序的时候，我们在 Shader 中使用的是伪随机函数    random。那如果要实现真正的随机数，我们该怎么做呢？如果我们希望实现的迷宫图案，在我们每次刷新网页的时候都不相同，这个功能你可以实现吗？你可以    fork GitHub    仓库的代码，然后把伪随机迷宫图案修改成真正随机迷宫图案，然后把你的代码和实际效果分享出来。        3.       我们知道，使用 background-image    的弊端是，当我们用坐标变换来缩放或移动图形的时候，作为元素背景的网格是不会随着缩放或移动而改变的。但使用    Shader，我们就能够避免这个问题了。        不过，我们在课程中没有给出缩放和移动图形的例子。你能够扩展我给出的例子，实现图案随着图形的缩放和移动变化的效果吗（这里，我再给你一个小提示，你可以使用顶点着色器和仿射变换矩阵来实现）？欢迎在留言区和我讨论，分享你的答案和思考，也欢迎你把这节课分享给你的朋友，我们下节课见！  源码课程示例代码slate-object="mark"}推荐阅读 \[1\]基于 WebGL 底层简单封装的基础库 \[gl-renderer\]的官方文档(https://github.com/akira-cn/gl-rendererslate-object="mark"}) ，它可以大大简化 WebGL代码的书写难度slate-object="mark"} \[2\]很棒的学习片元着色器的教程 [[The Book ofShaders  [. 