title:CRLite: A Scalable System for Pushing All TLS Revocations to All
Browsers
author:James Larisch and
David R. Choffnes and
Dave Levin and
Bruce M. Maggs and
Alan Mislove and
Christo Wilson
2017 IEEE Symposium on Security and Privacy
CRLite: A Scalable System for
Pushing All TLS Revocations to All Browsers
James Larisch∗
Bruce M. Maggs‡
David Choffnes∗
Alan Mislove∗
Dave Levin†
Christo Wilson∗
∗ Northeastern University
† University of Maryland
‡ Duke University and Akamai Technologies
Abstract—Currently, no major browser fully checks
for
TLS/SSL certiﬁcate revocations. This is largely due to the fact
that the deployed mechanisms for disseminating revocations
(CRLs, OCSP, OCSP Stapling, CRLSet, and OneCRL) are
each either incomplete, insecure, inefﬁcient, slow to update, not
private, or some combination thereof. In this paper, we present
CRLite, an efﬁcient and easily-deployable system for proactively
pushing all TLS certiﬁcate revocations to browsers. CRLite
servers aggregate revocation information for all known, valid TLS
certiﬁcates on the web, and store them in a space-efﬁcient ﬁlter
cascade data structure. Browsers periodically download and use
this data to check for revocations of observed certiﬁcates in real-
time. CRLite does not require any additional trust beyond the
existing PKI, and it allows clients to adopt a fail-closed security
posture even in the face of network errors or attacks that make
revocation information temporarily unavailable.
We present a prototype of CRLite that processes TLS cer-
tiﬁcates gathered by Rapid7, the University of Michigan, and
Google’s Certiﬁcate Transparency on the server-side, with a
Firefox extension on the client-side. Comparing CRLite to an
idealized browser that performs correct CRL/OCSP checking,
we show that CRLite reduces latency and eliminates privacy
concerns. Moreover, CRLite has low bandwidth costs: it can
represent all certiﬁcates with an initial download of 10 MB (less
than 1 byte per revocation) followed by daily updates of 580 KB
on average. Taken together, our results demonstrate that complete
TLS/SSL revocation checking is within reach for all clients.
I. INTRODUCTION
The TLS protocol, coupled with the web’s Public Key
Infrastructure (PKI), is the cornerstone of security for billions
of users and organizations. TLS1 relies on certiﬁcates issued
and cryptographically signed by Certiﬁcate Authorities (CAs)
to provide integrity, conﬁdentiality, and authentication for web
trafﬁc. To date, most web browsing occurs over HTTPS [18].
One critical, but sometimes overlooked, facet of the web’s
PKI is certiﬁcate revocation. When a CA erroneously issues a
certiﬁcate [2], or when a certiﬁcate’s private key is potentially
compromised [76], it is imperative that the affected certiﬁcate
be revoked. Otherwise—if an erroneous or compromised cer-
tiﬁcate is not revoked—client software (e.g., web browsers)
will continue to believe that
the certiﬁcate is valid until
it expires, which may not occur for years [76]. Attackers
could use such certiﬁcates to perform effective Man-in-the-
Middle (MitM) and phishing attacks against users. Thus, it
is crucial that certiﬁcate owners revoke erroneous or compro-
mised certiﬁcates in a timely manner, and that client software
1In this paper, we refer to the more modern TLS protocol, although our
work also applies to the older SSL protocol.
© 2017, James Larisch. Under license to IEEE.
DOI 10.1109/SP.2017.17
539
properly checks for revocations. Failing to do so is particularly
worrisome in the wake of large-scale vulnerabilities like the
Debian PRNG bug [75] and Heartbleed [19], [76], which
potentially compromised millions of private keys.
Despite the importance of revocations, many client ap-
plications do not properly check for certiﬁcate revocations.
Liu et al. [49] found that recent versions of Chrome only
make Certiﬁcate Revocation List (CRLs) or Online Certiﬁcate
Status Protocol (OCSP) requests for Extended Validation (EV)
certiﬁcates (a very small subset of all certiﬁcates); Firefox only
supports revocation checks via OCSP; and no major mobile
browsers check for revocations at all. This unfortunate state
of affairs has several root causes, including latency concerns
(contacting third-parties to perform revocation checks in-
creases connection latencies), bandwidth considerations (some
CRLs are over 70 MB), privacy risks (OCSP checks leak the
user’s browsing behavior), and ambiguity (CRL and OCSP
servers may be temporarily unavailable due to network errors,
or an active attack) [42], [41].
Recent efforts aim to address these problems by mov-
ing from a pull model
(wherein clients download revo-
cation information on-demand) to a push model, such as
OCSP Stapling [22], Google’s CRLSets [40], and Mozilla’s
OneCRL [31]. (We review these in detail in § II.) Although
these efforts by browser vendors are a step in the right
direction, they are far from comprehensive: as of January
30, 2017, CRLSet and OneCRL contained 14,436 and 357
revocations, respectively, while we ﬁnd that there are over
12.7M revoked (but otherwise valid) certiﬁcates that were
issued by major CAs (details in § IV). In fact, CRLSet and
OneCRL would have signiﬁcant difﬁculty scaling to handle
millions of certiﬁcates, because their data formats use 110 and
1,928 bits per revocation, respectively, meaning they would
require between 166 MB and 2.9 GB to store all 12.7M revoca-
tions (see § VII-E). Additionally, CRLSet and OneCRL require
users to place unconditional trust in Google and Mozilla, since
these data structures are not auditable.
In this paper, we present CRLite, a system for proactively
pushing all certiﬁcate revocations to browsers on a regular
basis. CRLite is implemented in two parts: a server-side
system that aggregates revocation information for all known,
valid TLS certiﬁcates2 on the web and places them in a ﬁlter,
2We validate certiﬁcates against the roots in the macOS certiﬁcate store.
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:23:56 UTC from IEEE Xplore.  Restrictions apply. 
Revocations
Covered
Bandwidth Cost
Update
Speed
Deployable
Today?
All
All
14,436
357
All∗
All∗
All∗
29 KB per CRL†
1.3 KB per request†
250 KB per day
34 KB per day
—
0 B (421.8bps of FM RDS)
10 MB initially, 580 KB per day†
CRL
OCSP
CRLSet [40]
OneCRL [31]
Rev. Trans. [44]
RevCast [65]
CRLite
TABLE I: Comparison of CRLite to other existing and proposed revocation dissemination systems. ∗: these systems aggregate
revocations for all known certiﬁcates on the web. †: these results are averages based on empirical measurements (see § VII).
‡: these results are the median times that clients may cache responses, based on empirical measurements (see § VII).
7 days‡
4 days‡
1 day
1 day
—
10s of seconds
1 day
Yes
Yes
Yes
Yes
Yes
No
Yes
Private?
Yes
No
Yes
Yes
No
Yes
Yes
Auditable?
Yes
Yes
No
No
Yes
Yes
Yes
Failure
Model
fail-open
fail-open
fail-open
fail-open
fail-open
fail-closed
fail-closed
Push
Model?
No
No
Yes
Yes
No
Yes
Yes
and a client-side component that downloads ﬁlters and uses
them to check for revocations of observed certiﬁcates.
CRLite’s ﬁlters provide browsers with a precise mapping
of all certiﬁcates to their revocation status. We make use of
a ﬁlter cascade [74], [64], which is a sequence of compact,
probabilistic data structures (e.g., Bloom ﬁlters [6]) without
either false positives or negatives. We rigorously show in
§ III-C how to minimize the size of ﬁlter cascades, and we
empirically show they have small incremental updates, as well.
CRLite’s design addresses six challenges:
1) Efﬁciency. CRLite compresses the revocation status of
all certiﬁcates using a ﬁlter. The entire data structure
requires only 10 MB to represent the status of over 30M
certiﬁcates, achieving a signiﬁcant size savings over
naïve approaches.
2) Timeliness. CRLite uses delta-updates to keep clients
up-to-date with recent revocations, meaning clients only
need to download the complete ﬁlter once. We cre-
ate deltas on a daily basis, which are typically small
(∼580 KB). In contrast, the median CRL has a lifetime
of 7 days, while the median OCSP response of an
Alexa Top-1M website expires after 4 days, meaning that
clients using CRLite have more up-to-date revocation
information than clients that cache traditional revocation
information.
3) Failure Model. Because CRLite contains all revocations
and has no false positives, it allows clients to adopt a
fail-closed security posture. All other deployable revo-
cation dissemination schemes and all modern browsers
that we are aware of adopt a fail-open model, i.e., if
revocation information about a certiﬁcate is unavailable,
the client assumes that the certiﬁcate is valid.3
4) Privacy. Unlike OCSP, CRLs, or other on-demand re-
vocation checking schemes, users using CRLite do not
reveal their browsing history to third parties.
5) Deployability. CRLite is deployable today, requires no
support from CAs or changes to TLS, and can be easily
integrated into modern browsers.4
6) Auditability. Although CRLite relies on a central-
ized system to aggregate and produce ﬁlters, clients
do not have to blindly trust
it. CRLite provides
cryptographically-signed logs that allow any interested
party to audit each ﬁlter, e.g., to check for erroneous
insertions or omissions. We also present an additional
deployment model for CRLite that eliminates the need
for auditing if CAs become part of the ﬁlter generation
process (see § VIII).
We present a prototype of our system that uses Spark to
create the ﬁlter on the server-side, and a Firefox extension on
the client-side. We rely on certiﬁcate data from full IPv4 scans
of the Internet conducted by the University of Michigan [71]
and Rapid7 [60], as well as Google’s Certiﬁcate Transparency
logs [45]. As of January 2017, our dataset contains 184M
total certiﬁcates, from which we identify 30M valid, unexpired
certiﬁcates. From these certiﬁcates, we extract 10K unique
Certiﬁcate Revocation Lists (CRLs) and 743 unique OCSP re-
sponders, which enable us to check the certiﬁcates’ revocation
status. We crawl these each day to produce updated ﬁlters.
We perform extensive evaluations on our CRLite prototype
using real data. On the client-side, we show that our Firefox
extension has low CPU overhead (10 milliseconds to check
each certiﬁcate chain) and nominal memory usage, and that
it
induces an order of magnitude less delay per HTTPS
connection than using CRL and OCSP. Having low delay
is crucial, as browser makers acknowledge that it is their
primary concern related to online revocation checking [40].
Also note that our implementation would be even faster if it
was implemented natively within the browser, rather than a
JavaScript extension.
Table I compares CRLite to six other revocation dissem-
ination schemes. Revocation Transparency is a proposed,
centralized, Merkle Tree-based scheme [45] that is similar to
historical proposals from Micali and others [51], [38], [55],
[52]; RevCast [65] is a system that disseminates certiﬁcate
revocations over FM radio. CRLite incorporates the best parts
3Browser vendors choose to “fail-open”—essentially prioritizing availabil-
ity over security—to avoid having to refuse a connection (and cause perceived
unreliability) when the CRL or OCSP server cannot be contacted. [41]
4Our prototype targets Firefox because it makes TLS APIs available to
extensions. Other browser do not export TLS APIs, and would thus require
additional modiﬁcation.
540
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:23:56 UTC from IEEE Xplore.  Restrictions apply. 
of existing systems (e.g., user privacy, no centralization of
trust, a fail-closed security posture, instant deployability) while
using less bandwidth than an average webpage (2.3 MB as of
2016) [27] and covering all revocations. CRLite is also ideally
suited for mobile and resource constrained devices, since it
uses a push model to deliver data (like CRLSet and OneCRL)
while covering all certiﬁcates (like CRL and OCSP).
Outline.
This paper is organized as follows. In § II, we
discuss background related to the web’s PKI and certiﬁcate
revocation. In § III, we detail the design of the ﬁlter cascade.
We present the server- and client-side design of CRLite in
§ IV, and evaluate its security properties in § V. We present the
implementation of our prototype in § VI, which we use to eval-
uate CRLite and compare it to other revocation mechanisms
in § VII. In § VIII, we present an alternative design of CRLite
that shows that auditing can be far less expensive provided
modest CA participation. Finally, we conclude in § IX.
II. BACKGROUND
In this section, we brieﬂy overview the web’s PKI, with
a focus on certiﬁcate revocation. We also discuss how web
browsers currently implement revocation checking, and survey
recent work on alternate strategies for distributing revocations.
A. The TLS Ecosystem
Authenticity and conﬁdentiality of communication on the
web are provided by HTTPS, which uses a combination of the
TLS protocol and a hierarchical PKI. In the web’s PKI, trusted
CAs are vested with the authority to issue X.509 certiﬁcates