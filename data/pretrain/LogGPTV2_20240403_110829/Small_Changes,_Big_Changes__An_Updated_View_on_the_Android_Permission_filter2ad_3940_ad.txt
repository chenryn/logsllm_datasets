this permission. In our study, we have also discovered one particular permission
CHANGE NETWORK STATE, which in Android 6.0 were an appop permission. How-
ever, with the release 6.0.1 (i.e., still within API 23) its protection level was
relaxed to normal.
Development permissions. These permissions (with FLAG DEVELOPMENT set),
although being of the signature protection level, can be granted to third-party
applications by using the pm grant shell command. While the code for granting
and revoking development permissions in Android 6.0 was merged with the one
handling runtime permissions, these groups are quite diﬀerent. First, develop-
ment permissions are granted simultaneously to all system users, while runtime –
only to the current user. Second, they are not displayed in the user interface as
runtime permissions.
Pre-23 permissions. The permissions with FLAG PRE23 set are automatically
granted to all legacy (whose target API level is below 23) applications requesting
them.
Installer and veriﬁer permissions. These signature permissions are auto-
matically granted to the apps marked as required installer and veriﬁer.
(5) The deprecated signature|system protection level. Although the sig-
nature|system protection level is now deprecated, Fig. 3a and b show that there
are still many permissions using this deprecated value. What is even more con-
fusing, 9 new permissions of this level appeared in API 23. We attribute this
inconsistency to the lack of communication among the groups of developers
responsible for diﬀerent modules. We have developed and submitted to AOSP [1]
patches to ﬁx these issues. Currently, out of 9 submitted patches, 2 patches were
merged into the master branch, while 3 were veriﬁed and 5 were code-reviewed.
(6) Some dangerous permissions are now normal. In Android 6.0 the
amount of dangerous permissions was considerably reduced. For 22 dangerous
permissions the protection level was lowered to normal. Thus, the users now
do not have any control over functionality protected with these permissions:
normal permissions are not displayed and are automatically granted upon the
installation. At runtime, a user can neither check them nor revoke. For instance,
the INTERNET permission controlling the access of apps to the Internet, which
was widely used by malware [55] especially in combination with other permis-
sions [32], is now granted automatically.
From the security perspective, this is one of the most controversial changes,
because many permissions regarded before as sensitive are now granted auto-
matically. The fact that 22 permissions (including, e.g., NFC, BLUETOOTH,
WRITE PROFILE, MANAGE ACCOUNTS) have been demoted in the security level
emphasizes that the Android security architecture is far from being stable.
362
Y. Zhauniarovich and O. Gadyatskaya
6.2
Interesting Findings
(1) Protection level ﬂags. Developers cannot use protection level ﬂags in
their third-party apps. An application containing permission declaration with
protection level ﬂags will not pass validation checks during the compilation. The
developers may only select one of the four main protection levels for their custom
permissions: (normal, dangerous, signature and signature|system). At the same
time, the validation check is performed only during application compilation.
During installation of an app similar checks are not ﬁred, and it is possible
to add a protection level ﬂag through app repackaging, e.g., using apktool5.
Clearly, the checks in IDEs should conform to the new permission speciﬁcations,
i.e., the signature|system protection ﬂag should be removed, and there should
be a possibility for third-party application developers to assign protection level
ﬂags to their custom permissions.
In Android 6.0 the protection level ﬂag FLAG PREINSTALLED was added. Pre-
viously, all signature permissions were divided into privileged, which could be
obtained only if a system app was installed in the special folder, and others, which
could be obtained by apps signed with the same certiﬁcate. FLAG PREINSTALLED
relaxes this strict division, and permits all system apps to receive automatically
the permissions with this ﬂag set.
(2) Additional ﬂags. Currently there are no restrictions for a third-party
developer on assigning additional ﬂags to custom permissions. For instance, it is
possible to declare a permission with FLAG COSTS MONEY set. As a result, on older
systems you will see the corresponding permission accompanied with a special
coins icon. Similarly, the usage of FLAG HIDDEN is also not restricted. This may
be used by a developer to conceal a permission from the list of app’s dangerous
permissions. While we cannot say if this functionality can be used with malicious
purposes, these edge cases violate the principle of least privilege.
Moreover, as mentioned in Sect. 4.2, 2 out of 3 ﬂags can be set by a devel-
oper, while the third ﬂag FLAG INSTALLED can be installed only by the operat-
ing system. Such behavior is considered as security anti-pattern, when publicly
accessible data is combined with private information.
(3) Hard-coded screens for granting permissions. Every permission group
deﬁned in the core AndroidManifest.xml ﬁle has its own screen, where a user
grants and revokes permissions assigned to this group (see Fig. 1c for the entry
points to these screens). At the same time, permission groups deﬁned in the
system or third-party packages do not have dedicated screens. The “Additional
permissions” screen collects all of them. There is no separation between groups
and single permissions on this screen. E.g., Fig. 1d shows that the permission
group (test permission group) and the single permission (test single permission)
are listed on the same screen along with other groups deﬁned in system packages.
As we mentioned, the groups and single permissions will be displayed on this
screen only if the corresponding package targets API 23.
5 https://ibotpeaches.github.io/Apktool/.
An Updated View on the Android Permission System
363
(4) Permission groups. We mentioned that there is no restriction on adding
custom permissions to the system permission groups. If a custom permission has
the dangerous protection level, then, when an app requests this permission at
runtime, it is also granted with all permissions from the same group. At the
same time, if the protection level of a custom permission is not dangerous, the
remaining permissions from the group will not be automatically granted. Thus,
to our point of view, there is no reason to group permissions beside those with
the dangerous protection level. We analyzed system non-dangerous permissions
to detect if there are any assigned to groups. For the API level 23 we found 6 such
package permissions and 2 core permissions. For example, the USE FINGERPRINT
permission assigned to the SENSORS permission group has the normal protection
level, while ACCESS IMS CALL SERVICE belonging to the PHONE group has the
signature|system level. We do not see reasons for this assignment and expect
these issues to be ﬁxed in the future Android releases.
(5) Permission declaration duplicates. During our analysis we found
that
some permission declarations are duplicated even within AOSP.
The most frequent duplicates are declarations of INSTALL SHORTCUT and
UNINSTALL SHORTCUT permissions. These ﬂags are declared both in the core and
package manifest ﬁles. Before API 19 there were no declarations of these per-
missions on the core level, but due to a bug they were added to the core man-
ifest ﬁle [6]. Interestingly, these permissions in the core and packages manifest
ﬁles have diﬀerent protection levels: normal
in the former case and danger-
ous in the latter. Additionally, while exploring this issue, we discovered that
in API 17 the declarations of two permissions (SET SCREEN COMPATIBILITY
and CHANGE CONFIGURATION) were duplicated even within the core ﬁle. This
shows that some classes and conﬁguration ﬁles reached critical complexity within
AOSP. It is necessary either to refactor them, or to use extensively static ana-
lyzers to prevent these inconsistencies.
7 Related Work
Studies in the literature investigated many aspects of the Android permission
system [34,37]. Indeed, the permission system is a cornerstone of the Android
security model [31], while permission misuse is a great concern [27,51], and
permission request patterns in apps are widely used for pinpointing malicious
or dubious behavior (e.g., [21,28,46,52]). At the same time, Android develop-
ers require guidance for understanding permissions and using them correctly.
For example, [26,35] looked at permission enforcement in Android and have
shown that the principle of least privilege was often neglected by developers.
Many studies looked into improving the permission system design and proposing
more secure or more usable solutions (e.g., [29,41,45,54]), while some researchers
argued that ﬁner granularity of permissions could be viable [38]. In absence of
a reliable documentation from Google, researchers had also to provide a means
of linking permissions to precise platform APIs that are protected with these
364
Y. Zhauniarovich and O. Gadyatskaya
permissions (a permission map) [23,24,26,35,40,48]. Outside the Android plat-
form, smartphone permission systems were explored in [22,39,47].
Wei et al. [49] have performed an early study of the permission system evolu-
tion in Android demonstrating that the permission system has become even more
complex over time from the user’s perspective (since its introduction in 2008 till
the study publication in 2012). [49] revealed that the principle of least privilege
was more and more violated with the time (the amount of overprivileged apps
had consistently grown). Moreover, the permission system had become more
complex: the total number of permissions had increased, and the amount of
dangerous permissions had grown.
Au et al. [23] performed another longitudinal study of Android permissions
with a focus on the sensitive API and permission changes spanning Android
versions 2.2 up to Android 4.0. This study showed that the number of docu-
mented APIs requiring permissions had grown signiﬁcantly in Android 4.0, and
that many APIs changed their permission requirements over Android versions;
this is also consistent with our own ﬁndings. The diﬀerence of our study with
[23] is that we explore the changes in the permission system in the whole, while
Au et al. concentrated on relations between permissions and API calls.
The studies by Wei et al. [49] and Au et al. [23] were reported in 2012. Thus,
our study incrementally adds to theirs by surveying also more recent platform
versions. To the best of our knowledge, the new Android permission system
architecture, including runtime permissions, has not yet been extensively stud-
ied by the security research community. However, runtime permission requests
were previously suggested by security researchers [50], and the eﬀect of dynamic
permission revocation on the Android apps has been empirically evaluated [33].
8 Conclusion
In this paper, we conducted a comprehensive study of the Android permission
system. Driven by the aspiration to understand new runtime permissions, we
discovered that the permission system has considerably evolved after its semi-
nal description in [31]. To help security researchers and Android developers to
understand better the new model and its implications, we presented an updated
view on the permission system. Besides giving the overview and intrinsic details
of the new design, we have shown its main changes during the last 6 years. At the
individual permission level we discovered and reported many issues that have
implications on the Android security state and research. These ﬁndings empha-
sise the dynamic complexity of the Android permission system that needs to be
taken into account by the community.
References
1. Android Open Source Project. http://source.android.com/. Accessed 31 Mar 2016
2. Commit 2af5708: Add per UID control to app ops. https://android.googlesource.
com/platform/frameworks/base/+/2af5708
An Updated View on the Android Permission System
365
3. Commit 2ca2c87: More adjustments to permissions. https://android.googlesource.
com/platform/frameworks/base/+/2ca2c87
4. Commit 33f5ddd: Add permissions associated with app ops. https://android.
googlesource.com/platform/frameworks/base/+/33f5ddd
5. Commit 3e7d977: Grant installer and veriﬁer install permissions robustly. https://
android.googlesource.com/platform/frameworks/base/+/3e7d977
6. Commit 4516798: Moving launcher permission to framework. https://android.
googlesource.com/platform/frameworks/base/+/4516798
7. Commit 6d2c0e5: Remove not needed contacts related permissions. https://
android.googlesource.com/platform/frameworks/base/+/6d2c0e5
8. Commit a90c8de: Add new “preinstalled” permission ﬂag. https://android.
googlesource.com/platform/frameworks/base/+/a90c8de
9. Commit ccbf84f: Some system apps are more system than others. https://android.
googlesource.com/platform/frameworks/base/+/ccbf84f
10. Commit cfbfafe: Additional permissions aren’t properly disabled after toggling
them oﬀ. https://android.googlesource.com/platform/frameworks/base/+/cfbfafe
11. Commit de15eda: Scope WRITE SETTINGS and SYSTEM ALERT WINDOW
to an explicit toggle to enable in Settings. https://android.googlesource.com/
platform/frameworks/base/+/de15eda
12. Commit e639da7: New development permissions. https://android.googlesource.
com/platform/frameworks/base/+/e639da7
13. Dashboards. http://goo.gl/mFciT7. Accessed 31 Mar 2016
14. Google says Android has 1.4 billion active users. http://goo.gl/aUuUNw. Accessed
31 Mar 2016
15. Microsoft Excel. https://play.google.com/store/apps/details?id=com.microsoft.
oﬃce.excel. Accessed 31 Mar 2016
16. Microsoft
PowerPoint.
https://play.google.com/store/apps/details?id=com.
microsoft.oﬃce.powerpoint. Accessed 31 Mar 2016
17. Not just for phones and tablets: what other devices run Android? http://goo.gl/
kQ4Pi8. Accessed 31 Mar 2016
18. Play store permissions change opens door to rogue apps. http://goo.gl/nJCwoY.
Accessed 31 Mar 2016
19. Requesting permissions at run time. http://developer.android.com/training/
permissions/requesting.html
20. Smartphone OS market share, 2015 Q2. http://goo.gl/WQwfZO. Accessed 31 Mar
2016
21. Arp, D., Speizenbarth, M., Hubner, M., Gascon, H., Rieck, K.: DREBIN: eﬀective
and explainable detection of Android malware in your pocket. In: Proceedings of
NDSS (2014)
22. Au, K., Zhou, Y.F., Huang, Z., Gill, P., Lie, D.: Short paper: a look at smartphone
permission models. In: Proceedings of SPSM (2011)
23. Au, K.W.Y., Zhou, Y.F., Huang, Z., Lie, D.: PScout: analyzing the Android per-
mission speciﬁcation. In: Proceedings of CCS (2012)
24. Backes, M., Bugiel, S., Derr, E., Weisgerber, S., McDaniel, P., Octeau, D.: On
demystifying the Android application framework: re-visiting Android permission
speciﬁcation analysis. In: Poster Session of IEEE EuroS&P (2016)
25. Barrera, D., Kayacik, H.G., van Oorschot, P.C., Somayaji, A.: A methodology
for empirical analysis of permission-based security models and its application to
Android. In: Proceedings of CCS (2010)
366
Y. Zhauniarovich and O. Gadyatskaya
26. Bartel, A., Klein, J., Le Traon, Y., Monperrus, M.: Automatically securing
permission-based software by reducing the attack surface: an application to
Android. In: Proceedings of ASE (2012)
27. Bugiel, S., Davi, L., Dmitrienko, A., Fischer, T., Reza-Sadeghi, A., Shastry, B.:
Towards taming privilege-escalation attacks on Android. In: Proceedings of NDSS
(2012)
28. Chen, K.Z., Johnson, N., D’Silva, V., Dai, S., MacNamara, K., Magrino, T., Wu,
E., Rinard, M., Song, D.: Contextual policy enforcement in Android applications
with permission event graphs. In: Proceedings of NDSS (2013)
29. Conti, M., Crispo, B., Fernandes, E., Zhauniarovich, Y.: CRˆePE: a system for
enforcing ﬁne-grained context-related policies on Android. IEEE Trans. Inf. Foren-
sics Secur. 7(5), 1426–1438 (2012)
30. Elenkov, N.: Android Security Internals: An In-Depth Guide to Android’s Security
Architecture, 1st edn. No Starch Press, San Francisco (2014)
31. Enck, W., Ongtang, M., McDaniel, P.: Understanding Android security. IEEE
Secur. Priv. Mag. 7(1), 50–57 (2009)
32. Enck, W., Ongtang, M., McDaniel, P.: On lightweight mobile phone application
certiﬁcation. In: Proceedings of CCS (2009)
33. Fang, Z., Han, W., Li, D., Guo, Z., Guo, D., Wang, X.S., Qian, Z., Chen, H.:
revDroid: code analysis of the side eﬀects after dynamic permission revocation of
Android apps. In: Proceedings of ASIACCS (2016)
34. Fang, Z., Han, W., Li, Y.: Permission based Android security: issues and counter-
measures. Comput. Secur. 43, 205–218 (2014)
35. Felt, A.P., Chin, E., Hanna, S., Song, D., Wagner, D.: Android permissions demys-
tiﬁed. In: Proceedings of CCS (2011)
36. Felt, A.P., Ha, E., Egelman, S., Haney, A., Chin, E., Wagner, D.: Android per-
missions: user attention, comprehension, and behavior. In: Proceedings of SOUPS
(2012)
37. Fragkaki, E., Bauer, L., Jia, L., Swasey, D.: Modeling and enhancing Android’s
permission system. In: Proceedings of ESORICS (2013)
38. Fratantonio, Y., Bianchi, A., Robertson, W., Egele, M., Kruegel, C., Kirda, E.,
Vigna, G.: On the security and engineering implications of ﬁner-grained access
controls for Android developers and users. In: Almgren, M., Gulisano, V., Maggi,
F. (eds.) DIMVA 2015. LNCS, vol. 9148, pp. 282–303. Springer, Heidelberg (2015)
39. Gadyatskaya, O., Massacci, F., Zhauniarovich, Y.: Security in the ﬁrefox OS and
Tizen mobile platforms. IEEE Comput. 47(6), 57–63 (2014)
40. Gibler, C., Crussell, J., Erickson, J., Chen, H.: AndroidLeaks: automatically detect-
ing potential privacy leaks in Android applications on a large scale. In: Katzen-
beisser, S., Weippl, E., Camp, L.J., Volkamer, M., Reiter, M., Zhang, X. (eds.)
Trust 2012. LNCS, vol. 7344, pp. 291–307. Springer, Heidelberg (2012)
41. Jeon, J., Micinski, K.K., Vaughan, J.A., Fogel, A., Reddy, N., Foster, J.S., Mill-
stein, T.: Dr. Android and Mr. Hide: ﬁne-grained permissions in Android applica-
tions. In: Proceedings of SPSM (2012)
42. Murphy, M.: Libraries and dangerous permissions. https://goo.gl/NJAjMx.
Accessed 25 June 2016
43. Murphy, M.: Runtime permissions, ﬁles, and ACTION SEND. https://goo.gl/
slhHoI. Accessed 25 June 2016
44. Murphy, M.: You cannot hold non-existent permissions. https://goo.gl/nyDjUj.
Accessed 25 June 2016
An Updated View on the Android Permission System
367
45. Nauman, M., Khan, S., Zhang, X.: Apex: extending Android permission model and
enforcement with user-deﬁned runtime constraints. In: Proceedings of ASIACCS
(2010)
46. Pandita, R., Xiao, X., Wang, W., Enck, W., Xie, T.: WHYPER: towards automat-
ing risk assessment of mobile applications. In: Proceedings of USENIX Security
(2013)
47. Singh, K.: Practical context-aware permission control for hybrid mobile applica-
tions. In: Stolfo, S.J., Stavrou, A., Wright, C.V. (eds.) RAID 2013. LNCS, vol.
8145, pp. 307–327. Springer, Heidelberg (2013)
48. Vidas, T., Christin, N., Cranor, L.F.: Curbing Android permission creep. In: Pro-
ceedings of W2SP (2011)
49. Wei, X., Gomez, L., Neamtiu, I., Faloutsos, M.: Permission evolution in the Android
ecosystem. In: Proceedings of ACSAC (2012)
50. Wijesekera, P., Baokar, A., Hosseini, A., Egelman, S., Wagner, D., Beznosov, K.:
Android permissions remystiﬁed: a ﬁeld study on contextual integrity. In: Proceed-
ings of USENIX Security (2015)
51. Xing, L., Pan, X., Wang, R., Yuan, K., Wang, X.: Upgrading your Android, elevat-
ing my malware: privilege escalation through mobile OS updating. In: Proceedings
of S&P (2014)
52. Zhang, Y., Yang, M., Xu, B., Yang, Z., Gu, G., Ning, P., Wang, X.S., Zang, B.:
Vetting undesirable behaviors in Android apps with permission use analysis. In:
Proceedings of CCS (2013)
53. Zhauniarovich, Y., Ahmad, M., Gadyatskaya, O., Crispo, B., Massacci, F.: Sta-
DynA: addressing the problem of dynamic code updates in the security analysis of
Android applications. In: Proceedings of CODASPY (2015)
54. Zhauniarovich, Y., Russello, G., Conti, M., Crispo, B., Fernandes, E.: MOSES: sup-
porting and enforcing security proﬁles on smartphones. IEEE Trans. Dependable
Secure Comput. 11(3), 211–223 (2014)
55. Zhou, Y., Jiang, X.: Dissecting Android malware: characterization and evolution.
In: Proceedings of S&P (2012)