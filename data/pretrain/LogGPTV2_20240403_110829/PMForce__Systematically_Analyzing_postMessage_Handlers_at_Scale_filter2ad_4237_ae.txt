block = a[_$_8e7c[46]][_$_8e7c[48]](r)[3]; //
↩→
size = a[_$_8e7c[46]][_$_8e7c[48]](r)[2]; //
↩→
message = a[_$_8e7c[46]][_$_8e7c[48]](r)[1]; //
↩→
s = a[_$_8e7c[46]][_$_8e7c[48]](r)[0] //
↩→
event.data.split('~@#bdf#@~')[2]
event.data.split('~@#bdf#@~')[0]
} catch (ex) {}
;if (s === _$_8e7c[49]) { // s == 'Ad'
event.data.split('~@#bdf#@~')[1] contains our payload
try {
// ...
ad = message; // sets global ad value to our injected payload
if (block == _$_8e7c[50]) { // block == 'true'
} else {
// ...
}
;setIfr(currentIframe, size[_$_8e7c[48]](_$_8e7c[57])[0],
↩→
↩→
size[_$_8e7c[48]](_$_8e7c[57])[1]) // does document.write
with ad variable on currentIframe
} catch (ex) {
// ...
}
}
// ...
}
}
// hosted on the attackers page with target pointing to the vulnerable frame
target.postMessage('Ad~@#bdf#@~~@#bdf#@~a~@#bdf#@~true')
Figure 9: Obfuscated Ad handler
place, unveils the use of Double Submit cookies for CSRF preven-
tion. While the Bot prevention also means that any further request
is blocked unless a captcha was solved, the attacker can rely on
the user to assist in this endeavor. Once the captcha is solved, the
handler sets a cookie from the bot prevention service for the tar-
get domain indicating the success, thus allowing any subsequent
requests until it reclassifies the behavior as suspicious. After the
captcha was solved, the attacker can perform the cross-site request
and circumvent the protection due to the previously planted cookie.
6 DISCUSSION
In this section, we discuss limitations of our prototype implemen-
tation and draw overarching conclusions from our work.
6.1 Limitations
While initial work from 2010 by Saxena et al. [20] showed promising
results in using symbolic execution, taint analysis, and fuzzing to
uncover XSS on a small scale, it remained an open problem to scale
this approach to the web. We could show the feasibility of such a
large-scale approach in an in-browser solution that does not rely
on patching the underlying JavaScript engine. Furthermore, we
remove the necessity of relying on fuzzing with constraint solving.
Nevertheless, our approach obviously has limitations related to the
applicability of existing tools to our problem space.
Our approach leverages the fact that most postMessage handlers
in the wild make use of a subset of Javascript behavior that can be
reasonably represented in current state of the art SMT solvers. In
21 handlers of our total 252 unique handlers with data flows to rel-
evant sinks, we encountered two types of behavior that interfered
with the analysis. First off, certain behavior is not transferrable
to the constraint language. In particular, Z3 only supports ASCII
characters. In addition, JavaScript’s usage of bind, apply or call,
which cannot be handled in a generic fashion. Moreover, Z3 lacks
support for backreferences and capture groups in regular expres-
sions, and cannot reason about the length of arrays, as these are
represented as functions within Z3. Second, our approach inherits
limitations of the open-source software used in our prototype. As
an example, the open-source lexer that we used raises errors for spe-
cific regular expressions encountered in the wild. Hence, we cannot
analyze such handlers. We nevertheless believe this does not impair
the conceptual applicability of our approach. Unfortunately, arbi-
trary programs might induce further issues. In particular, behavior,
such as changes to prototypes, usage of implicit type conversions,
complex objects such as Sets or Maps, need further modeling.
Additionally, relying on SMT solvers naturally comes with the
limitation that satisfiability is NP-complete. We have seen in our
analysis that a total of 21 constraints could not be solved due to
timeouts. While this is a general limitation that any such analysis
faces, there are nonetheless two conclusions we can draw from this
limitation. First, if we think of applying PMForce in a development
environment, any of the costly operations that lead to timeouts can
be rewritten by developers to produce constraints that are easier
to test for. For example, we have seen that performing further
operations on strings split by a separator, e.g., when passing several
values inside one string, quickly exceeds the capabilities that Z3
can solve in reasonable time. However, since postMessages allow
for arbitrary serializable objects, those values could also be sent as
an array. Furthermore, developer feedback might further be useful
to steer the forced execution away from unsolvable paths in the
program, e.g., paths that only work for legacy browsers.
Secondly, even in those cases where constraint solving fails, the
output of our force execution paired with the taint analysis provides
precise information about the constraints that need to be fulfilled
to reach a critical path in the program. This information can then
be used in further manual analysis to verify exploitability.
6.2 Security and Privacy Issues in postMessage
Handlers are Still Prevalent
Son and Shmatikov [24] showed with their manual analysis of
postMessage handlers back in 2013, that they are a prime target for
XSS and even allow attackers to manipulate the state of the site.
Compared to today, the number of sites making use of postMessage
and in particular the sheer number of handlers has exploded. During
our analysis of the top 100,000 sites we found 27,499 handlers and
looking at the top 10,000 specifically we could find 7,599 hash-
unique handlers. Comparing this to the amount of handlers found in
2013 this constitutes an increase by a factor of 55. While the number
of handlers that are vulnerable did not increase accordingly and is
slim compared to the overall corpus of all handlers, this highlights
the need for an automated analysis.
Furthermore, our results beg the question of how we can better
support developers in securing their sites. We think that providing
tool support is a first step in helping developers understand the
dangers associated with insecure postMessage handlers; however,
we also believe that we should reconsider making the postMessage
API secure by default. While an investigation of how we can adapt
the postMessage API to make it secure and usable for developers
in this work would not do it justice, we nonetheless want to high-
light two observations that we hope to be influential for developers
and standard authorities alike. First, most of the handlers that pro-
tect sensitive behavior implement origin checks correctly. Second,
postMessage relays can undermine the security of correct origin
checks. PMForce could be used by a first party to vet their trusted
third-party scripts, not to include such a relay. Overall, we hope
that our work raises awareness and re-opens the discussion about
the security of the postMessage API.
6.3 Ethical Considerations
During our large-scale analysis, we try to impact the live versions
of the web sites as little as possible, while allowing a thorough
assessment of the threat landscape. We restrict our crawlers not
to visit more than ten pages of any given site and produce similar
resource consumptions as an average user visiting the page and
clicking through 10 subpages. We notified the affected parties if
we could find any contact on their sites or using well-established
security reporting mechanisms (VRPs or security.txt). We have
already heard back from some vendors and are in active discussions
in assisting them in implementing appropriate fixes for the en-
countered vulnerabilities. We firmly believe that making PMForce
available helps developers uncover postMessage handler related
issues before being exposed to the public in production systems.
7 CONCLUSION
We showed that the amount of postMessage handlers has increased
tremendously over the recent years, rendering any manual efforts
to measure the security- and privacy-relevant behavior inept.
We tackle these issues by presenting an in-browser solution that
can selectively apply forced execution, and dynamic taint analysis
to postMessage handlers found while crawling the 100,000 most
popular sites. We track data flows originating from the received
postMessage into sensitive sinks such as eval for code-execution
flaws and document.cookie for state-alteration flaws. Once we
encounter such potentially dangerous flows, we utilize path con-
straints collected in our execution framework augmented with what
we dubbed Exploit Templates and solve all these constraints using
state-of-the-art SMT solvers. Doing so shows that most behavior
exhibited by handler functions found in the wild can be represented
in our chosen constraint language.
We use the assignments generated by the constraint solver to
create exploit candidates that we validate automatically with the un-
instrumented handler functions. Doing so allows us to automatically
uncover abusable flaws in 111 handlers, which affect 379 sites, out of
which 80, affecting 219 sites, do not perform any origin checks, such
that a web attacker can trivially exploit those. Contrary to previous
analyses, we show that the majority of origin checks protecting
sensitive behavior are implemented correctly; thus, no longer allow
an attacker to bypass them. Additionally, we report on an analysis of
the threat of postMessage relays and privacy leaks via postMessage
handlers showcasing how our framework can be further used to
uncover flaws in real-world sites.
Table 2: Exploit Templates used
regular expression
/^alert\(1\)\/\*(.*)\*\/$/
/^\(alert\(1\)\/\*(.*)\*\/\)$/
/^\/\*(.*)\*\/alert\(1\)$/
sample code context
if(event.data.indexOf('foobar') !== -1){
eval(event.data)
}
if(event.data.indexOf('foobar') !== -1){
eval('('+event.data+')')
}
if(event.data.indexOf('foobar') !== -1){
eval(event.data)
}
/\.toString\(\),alert\(1\)$/
eval('globalLib.' + event.data.fun)
/=1,alert\(1\)$/
eval('foo=' + value)
/\(function\(\){alert\(1\)}\)\(\);\/\/(.*)/
let fun = eval('function(){' + value + '}')
T1
T2
T3
T4
T5
T6
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
// site 1, with origin check
function actual_functionality(e) {
if (e.origin == 'https://foo.com') {
eval(e.data);
}
}
// generic handler on which we calculate structure uniqueness
function dispatcher(e) { actual_functionality(e) };
window.addEventListener("message", dispatcher);
// site 2, no origin check
function actual_functionality(e) {
eval(e.data)
}
// generic handler on which we calculate structure uniqueness
function dispatcher(e) { actual_functionality(e) };
window.addEventListener("message", dispatcher);
Figure 10: Example of simple dispatcher functions
A EXPLOIT TEMPLATES
Table 2 represents examples of our templates that capture all con-
texts that we currently cover for JavaScript sinks. Note that while
the template is represented as a regular expression, we used startsWith-
/endsWith constraints to lessen the burden on the SMT solver.
REFERENCES
[1] 2020. PMForce Code. (2020). https://github.com/mariussteffens/pmforce
[2] Ahmed Elsobky. 2018. Unleashing an Ultimate XSS Polyglot . https://github.com/
[ac-
0xsobky/HackVault/wiki/Unleashing-an-Ultimate-XSS-Polyglot. (2018).
cessed 06-Apr-2020].
[3] Adam Barth, Collin Jackson, and John C Mitchell. 2009. Securing frame commu-
[4] blukat29. 2020.
nication in browsers. Commun. ACM 52, 6 (2009).
crossword-solver. (2020). [accessed 06-Apr-2020].
regex-crossword-solver. https://github.com/blukat29/regex-
[5] Cristian Cadar, Daniel Dunbar, Dawson R Engler, et al. 2008. KLEE: Unassisted and
Automatic Generation of High-Coverage Tests for Complex Systems Programs.
In OSDI.
devtools-protocol/. (2020). [accessed 06-Apr-2020].
[6] Google. 2020. Chrome DevTools Protocol. https://chromedevtools.github.io/
[7] Xunchao Hu, Yao Cheng, Yue Duan, Andrew Henderson, and Heng Yin. 2017.
Jsforce: A forced execution engine for malicious javascript detection. In Interna-
tional Conference on Security and Privacy in Communication Systems.
[8] Kyungtae Kim, I Luk Kim, Chung Hwan Kim, Yonghwi Kwon, Yunhui Zheng,
Xiangyu Zhang, and Dongyan Xu. 2017. J-force: Forced execution on javascript.
In WWW.
[9] Clemens Kolbitsch, Benjamin Livshits, Benjamin Zorn, and Christian Seifert.
2012. Rozzle: De-cloaking internet malware. In IEEE Symposium on Security &
Privacy.
[10] Sebastian Lekies, Ben Stock, and Martin Johns. 2013. 25 million flows later:
[11] Guodong Li, Esben Andreasen, and Indradeep Ghosh. 2014. SymJS: automatic
Large-scale detection of DOM-based XSS. In CCS.
symbolic testing of JavaScript web applications. In FSE.
[12] Blake Loring, Duncan Mitchell, and Johannes Kinder. 2017. ExpoSE: practical
symbolic execution of standalone JavaScript. In Proceedings of the 24th ACM
SIGSOFT International SPIN Symposium on Model Checking of Software.
[13] Felix Maier. 2020. Iroh. https://github.com/maierfelix/Iroh. (2020). [accessed
06-Apr-2020].
[14] William Melicher, Anupam Das, Mahmood Sharif, Lujo Bauer, and Limin Jia.
2018. Riding out domsday: Towards detecting and preventing dom cross-site
scripting. In NDSS.
[15] Mozilla Developer Network. 2020. Symbol. https://developer.mozilla.org/en-
US/docs/Web/JavaScript/Reference/Global_Objects/Symbol. (2020). [accessed
06-Apr-2020].
[16] Mozilla Developer Network. 2020.
The structured clone algorithm.
https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/
Structured_clone_algorithm. (2020). [accessed 06-Apr-2020].
[17] OWASP. 2020.
Cross-Site Request Forgery (CSRF) Prevention Cheat
Sheet. https://owasp.org/www-project-cheat-sheets/cheatsheets/Cross-Site_
Request_Forgery_Prevention_Cheat_Sheet#double-submit-cookie. (2020). [ac-
cessed 06-Apr-2020].
[18] OWASP. 2020. Session fixation. https://owasp.org/www-community/attacks/
Session_fixation. (2020). [accessed 06-Apr-2020].
[19] Victor Le Pochat, Tom Van Goethem, Samaneh Tajalizadehkhoob, Maciej Kor-
czyński, and Wouter Joosen. 2019. Tranco: A research-oriented top sites ranking
hardened against manipulation. NDSS (2019). https://tranco-list.eu/list/NZQW/
100000
[20] Prateek Saxena, Devdatta Akhawe, Steve Hanna, Feng Mao, Stephen McCamant,
and Dawn Song. 2010. A symbolic execution framework for javascript. In IEEE
Symposium on Security & Privacy.
[21] Prateek Saxena, Steve Hanna, Pongsin Poosankam, and Dawn Song. 2010. FLAX:
Systematic Discovery of Client-side Validation Vulnerabilities in Rich Web Ap-
plications. In NDSS.
[22] Yan Shoshitaishvili, Ruoyu Wang, Christopher Salls, Nick Stephens, Mario Polino,
Andrew Dutcher, John Grosen, Siji Feng, Christophe Hauser, Christopher Kruegel,
et al. 2016. Sok:(state of) the art of war: Offensive techniques in binary analysis.
In IEEE Symposium on Security & Privacy.
[23] Suphannee Sivakorn, Iasonas Polakis, and Angelos D Keromytis. 2016. The
cracked cookie jar: HTTP cookie hijacking and the exposure of private informa-
tion. In IEEE Symposium on Security & Privacy.
tacking and Defending postMessage in HTML5 Websites. In NDSS.
[25] Marius Steffens, Christian Rossow, Martin Johns, and Ben Stock. 2019. Don’t
Trust The Locals: Investigating the Prevalence of Persistent Client-Side Cross-Site
Scripting in the Wild.. In NDSS.
[26] Ben Stock, Martin Johns, Marius Steffens, and Michael Backes. 2017. How the
Web Tangled Itself: Uncovering the History of Client-Side Web (In)Security. In
USENIX Security.
solver for vulnerability detection in web applications. In CCS.
[28] Yunhui Zheng, Xiangyu Zhang, and Vijay Ganesh. 2013. Z3-str: A z3-based string
solver for web application analysis. In Proceedings of the 2013 9th Joint Meeting
on Foundations of Software Engineering.
[24] Sooel Son and Vitaly Shmatikov. 2013. The Postman Always Rings Twice: At-
[27] Minh-Thai Trinh, Duc-Hiep Chu, and Joxan Jaffar. 2014. S3: A symbolic string