title:Shredder: Breaking Exploits through API Specialization
author:Shachee Mishra and
Michalis Polychronakis
Shredder: Breaking Exploits through API Specialization
Shachee Mishra
Stony Brook University
PI:EMAIL
Michalis Polychronakis
Stony Brook University
PI:EMAIL
ABSTRACT
Code reuse attacks have been a threat to software security since
the introduction of non-executable memory protections. Despite
signi(cid:27)cant advances in various types of additional defenses, such
as control (cid:30)ow integrity (CFI) and leakage-resilient code random-
ization, recent code reuse attacks have demonstrated that these
defenses are often not enough to prevent successful exploitation.
Sophisticated exploits can reuse code comprising larger code frag-
ments that conform to the enforced CFI policy and which are not
a(cid:29)ected by randomization.
As a step towards improving our defenses against code reuse at-
tacks, in this paper we present Shredder, a defense-in-depth exploit
mitigation tool for the protection of closed-source applications. In
a preprocessing phase, Shredder statically analyzes a given appli-
cation to pinpoint the call sites of potentially useful (to attackers)
system API functions, and uses backwards data (cid:30)ow analysis to
derive their expected argument values and generate whitelisting
policies in a best-e(cid:29)ort way. At runtime, using library interposi-
tion, Shredder exposes to the protected application only specialized
versions of these critical API functions, and blocks any invocation
that violates the enforced policy. We have experimentally evalu-
ated our prototype implementation for Windows programs using
a large set of 251 shellcode and 30 code reuse samples, and show
that it improves signi(cid:27)cantly upon code stripping, a state-of-the-art
code surface reduction technique, by blocking a larger number of
malicious payloads with negligible runtime overhead.
ACM Reference Format:
Shachee Mishra and Michalis Polychronakis. 2018. Shredder: Breaking Ex-
ploits through API Specialization. In 2018 Annual Computer Security Applica-
tions Conference (ACSAC ’18), December 3–7, 2018, San Juan, PR, USA. ACM,
New York, NY, USA, 16 pages. https://doi.org/10.1145/3274694.3274703
1 INTRODUCTION
After more than two decades of advances in code reuse attacks [24,
36, 51, 52], defending e(cid:29)ectively against return-oriented program-
ming (ROP) [63] and its recent more sophisticated forms [12, 15,
21, 26, 59, 61, 65, 66] remains a challenging problem. By diverting
the hijacked control (cid:30)ow into carefully selected existing code frag-
ments (dubbed “gadgets”) or even whole functions, modern exploits
can bypass not only non-executable memory protections, but also
(depending on the application and various other conditions) an
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for pro(cid:27)t or commercial advantage and that copies bear this notice and the full citation
on the (cid:27)rst page. Copyrights for components of this work owned by others than ACM
must be honored. Abstracting with credit is permitted. To copy otherwise, or republish,
to post on servers or to redistribute to lists, requires prior speci(cid:27)c permission and/or a
fee. Request permissions from permissions@acm.org.
ACSAC ’18, December 3–7, 2018, San Juan, PR, USA
© 2018 Association for Computing Machinery.
ACM ISBN 978-1-4503-6569-7/18/12. . . $15.00
https://doi.org/10.1145/3274694.3274703
array of additional exploit mitigation approaches, such as control
(cid:30)ow integrity, code diversi(cid:27)cation, and code pointer protection.
Control (cid:30)ow integrity (CFI) [2] con(cid:27)nes control (cid:30)ow transfers
within a set of targets, preventing the execution of gadgets that
are not part of the legitimate control (cid:30)ow graph. Recent works,
however, have shown that exploitation is still possible by trans-
ferring control to gadgets or functions without violating the en-
forced policy [12, 15, 26, 59, 61]. Address space layout randomiza-
tion (ASLR) [69] randomizes the load address of shared libraries and
main executables, while code randomization [44] alters not only
the location but also the structure of code, breaking ROP payloads
that rely on gadgets present in the original code.
By leveraging a memory leakage vulnerability, however, exploit
code can dynamically harvest gadgets and construct a functional
“just-in-time” ROP (JIT-ROP) payload for a particular diversi(cid:27)ed
process [65]. Recent leakage-resilient protections against JIT-ROP
exploits, which rely on the concept of execute-only memory to block
the on-the-(cid:30)y discovery of gadgets [6, 13, 18, 20, 32, 57, 67, 73], can
under certain conditions also be bypassed [59]. Code pointer protec-
tions prevent code reuse attacks at their initial step, by preventing
the corruption of pointers in memory. Even this strong form of
protection, however, can be bypassed when certain code constructs
are present, by corrupting non-pointer data [70].
Despite these shortcomings, the continuous deployment of ex-
ploit mitigation technologies has undoubtedly been making vulnera-
bility exploitation harder, as evident by the complexity and sophisti-
cation of the above exploitation techniques [12, 15, 26, 59, 61, 65, 70].
Especially when orthogonal mitigations are combined (e.g., control
(cid:30)ow integrity and code pointer integrity), bypassing all of them
becomes challenging even under favorable conditions [70]. Unfor-
tunately, in practice, most of the above protections have not seen
widespread deployment due to their reliance on source code or de-
bug symbols, and the often non-negligible runtime overhead they
incur. It is thus pertinent to focus part of our defense e(cid:29)orts on ap-
proaches that i) can complement existing protection mechanisms to
collectively provide stronger protection, ii) can be transparently de-
ployed for the protection of (closed-source) third-party applications,
and iii) introduce negligible runtime overhead.
A promising approach that ful(cid:27)lls the above requirements is code
surface reduction through the removal of unused code [48, 50, 58].
Code reuse attacks rely on the abundance of code in the address
space of a vulnerable process. For most applications, the bulk of this
code comes from libraries: DLLs on Windows or shared libraries
on UNIX systems. These libraries are either bundled with the ap-
plication, or are provided by the OS to expose system interfaces
and services. Applications typically use only a fraction of these
functions, so a natural approach for reducing the code surface of
a process is to remove any unneeded functions from its address
space after each DLL is loaded [50, 58].
1
ACSAC ’18, December 3–7, 2018, San Juan, PR, USA
Shachee Mishra and Michalis Polychronakis
A particular implementation of this approach for closed-source
Windows programs is dubbed code stripping [50]. Removing un-
used system API functions not only reduces the number of gadgets
that can potentially be used by an attacker, but also restricts what
potentially harmful OS operations (e.g., the allocation of executable
memory) can be performed in the (cid:27)rst place. For example, server
applications often do not need to create new network connections
(just accept incoming connections); removing connect() will thus
break any exploit code (either shellcode or ROP code) that attempts
to connect back to an attacker-controlled system [50].
As an added bene(cid:27)t, the removal of unused code can eliminate
potential vulnerabilities due to bugs in “forgotten” parts of the
code. At the same time, this approach does not incur any addi-
tional overhead (in fact, it may slightly improve performance due
to reduced memory utilization), and is applicable to closed-source
third-party applications. This is particularly important in the Win-
dows ecosystem, which is probably the most severely plagued by
ROP exploits against vulnerable third-party applications—Mulliner
and Neugschwandtner [50] have demonstrated the bene(cid:27)ts of code
stripping for the protection of commonly targeted closed-source
Windows applications such as Adobe Reader.
Unfortunately, although unneeded code removal reduces the
number of ROP gadgets at the disposal of attackers—and even whole
potentially useful (for attackers) system API functions—the code of
several system operations that are essential for both legitimate and
malicious code is unlikely to be removed. For instance, consider
kernel32.dll, which is typically loaded by all Windows processes,
as it provides a host of useful system operations. Among its exported
functions are VirtualAlloc() and VirtualProtect(), which are
used by ROP exploits to either allocate writable and executable
(WX) memory, or change the permissions of existing memory to
WX (to facilitate the execution of second-stage injected shellcode
or malicious DLLs). These functions are also indispensable to most
programs for generic memory allocation, and thus cannot be simply
removed. We observe though that, with a few exceptions, most
programs rarely need to allocate executable memory—precisely
what malicious code needs.
Based on the observation that part of an API function’s capabil-
ities may not ever be needed by the target program, in this work
we propose API specialization, a defense-in-depth approach that re-
stricts the interface of the loaded instances of critical API functions
according to the actual needs of a given program. This is achieved
by neutralizing any unneeded functionality which may be essential
for malicious code, such as the allocation of executable memory
(e.g., by not accepting “X” as an allowable permission).
We have developed a prototype of this approach for the protec-
tion of closed-source Windows applications, called Shredder. In a
preprocessing phase, Shredder statically analyzes a given program
to pinpoint the call sites of sensitive system API functions, and
uses backwards program data (cid:30)ow analysis to derive their expected
argument values in a best-e(cid:29)ort way. At runtime, using library
interposition, Shredder exposes to the protected application only
the specialized versions of these functions, and blocks any invo-
cation that violates the enforced policy. We have experimentally
evaluated Shredder using a large set of 251 shellcode and 30 ROP
payload samples from real-world and proof-of-concept exploits.
When applied for the protection of 10 popular Windows 64-bit
applications, Shredder blocked signi(cid:27)cantly higher number of ma-
licious payloads compared to code stripping [50], with negligible
runtime overhead.
In summary, our work makes the following main contributions:
• We propose API specialization, a best-e(cid:29)ort code slimming
technique for close-source applications that limits the func-
tionality of system API functions to the absolutely necessary
operations that a given program needs.
• We have implemented a prototype tool, call Shredder, that
employs API specialization to transparently protect Win-
dows applications by blocking the execution of shellcode or
ROP code that violates the enforced policy.
• We have experimentally evaluated Shredder with popular
Windows applications and a large set of exploit code, and
demonstrate that it breaks 18.3% more shellcode and 298%
more ROP code samples compared to code stripping [50],
while incurring a negligible runtime overhead.
2 BACKGROUND AND MOTIVATION
The (cid:27)rst stage of recent exploits (typically implemented as a ROP
payload) usually performs a simple task, such as enabling the exe-
cution of a more complex second-stage shellcode, or dropping and
invoking a malicious executable. This unavoidably requires some
interaction with the OS through the system call interface, e.g., to
carry out system operations related to (cid:27)le and network activity,
memory allocation, and module loading.
In Unix-like systems, the system call interface is exposed to user
space through a single library (e.g., libc), which provides a mostly
one-to-one mapping between the available system calls and the
exported API functions that programs can invoke. Windows, in
contrast, does not expose system calls to user-level programs in
such an obvious and direct way. Instead, programs interact with
the OS through the Windows API [47], which is organized into
several DLLs. In turn, these DLLs call functions from the (largely
undocumented) Native API [60] (implemented in ntdll.dll) to
invoke kernel-level services.
In both cases, the overall set of system operations available to
user programs through the provided APIs is quite large. Depending
on the application, however, it is unlikely that all available system
operations will be needed. For instance, a program might never
need to create network connections or write (cid:27)les to disk. Still, as
long as a program needs to perform even a single system operation,
it has to import the corresponding function from the respective
system library (e.g., libc.so in Linux or kernel32.dll in Win-
dows), which means that the whole library will be loaded into
the process’ address space. Although none of the other API func-
tions will ever be used, they are still available in the address space
of the process to be used as part of exploit code. As an example,
kernel32.dll is almost always imported by Windows applications,
and provides a large variety of critical functionality for exploit code
(e.g., change memory permissions to bypass non-executable mem-
ory protections, connect to remote hosts and download malicious
components or ex(cid:27)ltrate information, or create new processes and
threads to perform malicious actions).
If an API function will never be used by a given application,
why making it available to attackers? This is the idea behind code
2Shredder: Breaking Exploits through API Specialization
ACSAC ’18, December 3–7, 2018, San Juan, PR, USA
Table 1: Number of imported functions from Windows API
DLLs for various 64-bit programs.
DLL name:
kernel32
advapi
user32
ole32
Exported functions:
1941
902
1152
167
Imported functions by:
7Zip
Google Chrome
Microso(cid:28) Edge
Mozilla Firefox
iTunes
PhotoViewer
Notepad++
Powershell
VLC
Winrar
94
201
46
105
336
115
173
80
38
180
19
36
-
29
52
16
13
13
2
26
84
33
-
8
212
136
177
1
1
152
12
8
-
-
29
23
2
6
-
12
stripping [50], which at load time identi(cid:27)es all the non-imported
functions from external system libraries and removes them from the
address space of the protected process. In addition, code stripping
is combined with image freezing, which prevents the addition of
new code, i.e., new executable memory pages, once the process has
been initialized. This is achieved by (cid:27)ltering through API hooking
the memory-related functions that may receive an “execute” (cid:30)ag. A
function that tries to use the “execute” (cid:30)ag succeeds only if it was
part of the original program. Both code stripping and image freezing
essentially have no runtime overhead, as both are performed only
during startup.
Given that invoking system calls directly is usually not an op-
tion in Windows exploits (due to the frequent system call number
changes across di(cid:29)erent Windows versions, and the complexity
of the Native API [55, 64]), if the API function for a given system
operation is missing, any exploit code that relies on it will break.
This would prevent attackers from, for instance, accessing the net-
work, if a given application never has to do it. At the same time,
by actually removing the code of each unneeded function from the
process’ memory, the number of ROP gadgets at the disposable of
attackers is reduced, while any potentially exploitable bugs present
in those functions are also e(cid:29)ectively eliminated.
To give an intuition about the great potential of this approach
for attack surface reduction, Table 1 shows the number of exported
API functions by four commonly used Windows 10 system DLLs
(upper part), and the number of actually imported functions from
those DLLs by a set of popular Windows applications (lower part).
As evident, all applications use only a fraction of the available
functions, which means that code stripping can potentially prevent
exploits from performing a wide range of system operations.
Unfortunately, however, although part of the system APIs may
be neutralized by code stripping, it is very likely that some system
functions that may be critical for malicious code will also be needed
by the protected application—this is especially true for larger and