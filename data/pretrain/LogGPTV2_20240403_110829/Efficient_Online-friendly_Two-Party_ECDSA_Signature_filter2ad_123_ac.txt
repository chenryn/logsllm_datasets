9ğœ… (288B)
ğœ… (32B)
14ğœ… (505B)
9ğœ… (288B)
9ğœ… (288B)
ğœ… (32B)
ğœ… (32B)
ğœ… (32B)
ğœ… (32B)
offline
32â„“ğ‘ + 67ğœ… (12KB)
40â„“ğ‘ + 18ğœ… (15.5KB)
118â„“ğ‘ + 20ğœ… (44KB)
16â„“ğ‘ + 11ğœ… (6.3KB)
12ğœ… (192B)
16â„“ğ‘ + 18ğœ… (6.6KB)
10â„“ğ‘ + 12ğœ… (4.1KB)
6ğœ… (208B)
140ğœ… (4.5KB)
140ğœ… (4.5KB)
53ğœ… (1.7KB)
16ğœ…2 (169.8KB)
20ğœ…2 (180KB)
8ğœ…2 (90.9KB)
Passes
8
9
4
3
3
9
3
3
8
8
3
2
7
3
required. There are several solutions to simply or even remove these
proofs, such as range proof with slack [26], and a non-standard
Paillier-EC assumption [19] (refer to Appendix D.3). Using range
proof with slack and Paillier-EC assumption, a Paillier-based MtA
requires 8 Paillier exponentiations and a transmission of 10 log ğ‘
bits. Depending on Paillier-EC assumption is applied or not, we
propose two Paillier-based schemes.
Castagnos et al. [7] replace Paillier encryption with Castagnos
and Laguillaumie [9] encryption over class group. The key feature
of CL-encryption is that it allows instantiations where the message
space is exactly Zğ‘. However, this kind of MtA requires new zero-
knowledge proofs performed on unknown order groups, which is
the heaviest part of all these constructions. Follow-up works [8, 33]
further improve the underlying zero-knowledge proof system.
We note that there are other instantiations from noisy Reed-
Solomon encodings (RS) [20] and Ring-LWE [2]. However, these
constructions are not very suitable for the parameters related to
ECDSA. We leave it as the future work to improve the underlying
MtA protocol with these techniques.
1.4 Related Works and Discussion
1.4.1 Related works. Efficient constructions of threshold ECDSA
fall into the following three categories. For more details, please
refer to [1].
Paillier-based Schemes. Following [27], Lindell [25] proposed a
competitive two-party ECDSA utilizing multiplicative sharing of
secret and nonce in combination with Paillier encryption. Lindellâ€™s
scheme has the best overall efficiency while its online phase needs to
perform a Paillier decryption. Later, Lindell et al. [26], and Gennaro
and Goldfeder [19] proposed a full threshold ECDSA protocol with
additive shares. They both require at least 8 communication rounds
and their online phase is interactive. Recently, Canetti et al. [6]
proposed an online-friendly three-pass threshold ECDSA at the
cost of extra overhead.
CL-based Schemes. Castagnos et al. [7] addressed the problem of
relying on non-standard assumption in [25] by replacing Paillier
encryption with CL-encryption [9] which allows the message space
to match that of the signature space (Zğ‘). Castagnos et al. [8] further
extended their work to full threshold by following Gennaro and
Goldfederâ€™s blueprint. Very recently, Yuen et al. [33] improves the
underlying zero-knowledge proof of Castagnos et al.â€™s protocol,
thus reduces the overall bandwidth and running time. However,
the online phase of these schemes either requires the computation
of decryption or is interactive.
OT-based Schemes. The OT-based schemes are online-friendly
and do not require extra assumptions. Doerner et al. [15] used
multiplicative sharing of the signing key and the nonce as [7, 25],
and achieved fast online computation with the help of two MtA
Session 2D: Secure Multiparty Computation CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea561from the oblivious transfer. They also generalized their work to 2-
of-ğ‘› cases. Later, they [16] proposed a full threshold scheme. These
schemes are very fast in signing time, while the communication
cost is the bottleneck.
1.4.2 Discussion. We further discuss issues related to round com-
plexity and which party obtain the final signature in existing ap-
proaches.
On the Communication Rounds of Signing. As shown in Table
2, our scheme and [7, 25] require only 3 rounds (i.e., passes). All the
other protocols except [15] require more communication rounds.
However, as mentioned by [15, Sec. III], it relied on the generic
group model (GGM) [31] to achieve this round reduction. Otherwise,
4 rounds are needed.
On the Generation of Final Signature. There are two commonly
used syntax regarding the output of the protocol, namely, 1) each
party generates a â€œsignature share" and anyone (including a third
party) could compute the final signature from the signature shares;
2) only one party obtains the final signature. Notable examples of
the former include [6, 8, 16, 19, 26], and the latter include [7, 15, 25]
as well as our scheme. The obstacle in adding this property to our
scheme and [7, 15, 25] is that the nonce is shared multiplicatively,
and thus signature component â€œs" cannot be reconstructed from a
simple linear combination of signature shares.
1.5 Paper Organization.
The rest of paper is organised as follows. We review preliminaries
in section 2. Then we propose our protocol and prove its security in
section 3. In section 4, we show several instantiations of 2ECDSA.
Finally, section 5 presents a comprehensive analysis and comparison
with existing schemes.
2 PRELIMINARY
2.1 The ECDSA Signature
Let G be an elliptic curve group of order ğ‘ with base point (genera-
tor) ğ‘ƒ. The algorithm makes use of the hash function ğ». Curve co-
ordinates and scalars are represented in ğœ… = log ğ‘ bits. The ECDSA
scheme works as follows [11].
(1) Keygen(1ğœ…): on input 1ğœ…
(2) Sign(ğ‘¥, ğ‘š): on input sign key ğ‘¥ and message ğ‘š
â€¢ Choose a random ğ‘¥ â† Zğ‘, set ğ‘¥ as the private key.
â€¢ Compute ğ‘„ = ğ‘¥ Â· ğ‘ƒ, and set ğ‘„ as the public key.
â€¢ Choose a random ğ‘˜ â† Zğ‘, compute ğ‘… = (ğ‘Ÿğ‘¥, ğ‘Ÿğ‘¦) = ğ‘˜ Â· ğ‘ƒ.
â€¢ Compute ğ‘Ÿ = ğ‘Ÿğ‘¥ mod ğ‘ and ğ‘  = ğ‘˜âˆ’1(ğ»(ğ‘š) + ğ‘Ÿğ‘¥) mod ğ‘.
â€¢ Output (ğ‘Ÿ, ğ‘ ) as the signature.
(3) Verify(ğ‘š; (ğ‘Ÿ, ğ‘ )) calculates (ğ‘Ÿğ‘¥, ğ‘Ÿğ‘¦) = ğ‘… = ğ‘ âˆ’1ğ»(ğ‘š)Â·ğ‘ƒ +ğ‘ âˆ’1ğ‘Ÿ Â·
ğ‘„ and outputs 1 if and only if ğ‘Ÿ = ğ‘Ÿğ‘¥ mod ğ‘.
It is well known that for every valid signature (ğ‘Ÿ, ğ‘ ), the pair (ğ‘Ÿ,âˆ’ğ‘ )
is also a valid signature. To make (ğ‘Ÿ, ğ‘ ) unique, in this paper, we
mandate that the â€œsmaller" of {ğ‘ ,âˆ’ğ‘ } is the output.
2.2 Ideal Functionality for Two-Party ECDSA
The ideal functionality FECDSA for two-party ECDSA is shown in
Figure 1. It consists of two functions, namely, a key generation
Consider an elliptic curve group G of order ğ‘ with generator ğ‘ƒ,
then:
Keygen: On receiving Keygen(G, ğ‘ƒ, ğ‘) from ğ‘ƒ1 and ğ‘ƒ2
â€¢ Generate key pair (ğ‘„, ğ‘¥) where ğ‘¥ â† Zğ‘ and ğ‘„ = ğ‘¥ Â· ğ‘ƒ.
â€¢ Choose a hash function ğ» : {0, 1}âˆ— â†’ {0, 1}ğœ….
â€¢ Send ğ‘„ and ğ» to ğ‘ƒ1 and ğ‘ƒ2.
â€¢ Store (G, ğ‘ƒ, ğ‘, ğ», ğ‘¥, ğ‘„) and ignore further calls.
Sign: On receiving Sign(sid, ğ‘š) from both ğ‘ƒ1 and ğ‘ƒ2, where keys
have been generated from a call to Keygen and sid has not been
used
â€¢ Choose ğ‘˜ â† Zğ‘ and compute ğ‘… = (ğ‘Ÿğ‘¥, ğ‘Ÿğ‘¦) = ğ‘˜ Â· ğ‘ƒ.
â€¢ Compute ğ‘Ÿ = ğ‘Ÿğ‘¥ mod ğ‘ and ğ‘  = ğ‘˜âˆ’1(ğ»(ğ‘š) + ğ‘Ÿğ‘¥) mod ğ‘.
â€¢ Send (ğ‘Ÿ, ğ‘ ) to both ğ‘ƒ1 and ğ‘ƒ2.
â€¢ Store (Complete, sid) in the memory.
Figure 1: The functionality FECDSA for two-party ECDSA
signature.
Setup: On receiving (setup) from ğ‘ƒ1 and ğ‘ƒ2
â€¢ Store and send (setup-complete) to ğ‘ƒ1 and ğ‘ƒ2.
Multiplication: On receiving (input, sid, ğ‘ âˆˆ Zğ‘) from ğ‘ƒ1,
(input, sid, ğ‘ âˆˆ Zğ‘) from ğ‘ƒ2 where sid has not been used, if (setup-
complete) exists,
â€¢ Sample ğ›¼ âˆˆ Zğ‘ and compute ğ›½ = ğ‘ğ‘ âˆ’ ğ›¼ mod ğ‘.
â€¢ Send (output-1, sid, ğ›¼) to ğ‘ƒ1
â€¢ Send (output-2, sid, ğ›½) to ğ‘ƒ2.
Figure 2: The functionality FMtA of multiplicative-to-
additive protocol.
function Keygen, called once, and a signing function Sign, called
an arbitrary number of times under the generated key.
2.3 The Multiplicative-to-Additive (MtA)
Functionality
The FMtA functionality, listed in Figure 2, is parameterized by the
group order ğ‘. It runs with two parties, ğ‘ƒ1 and ğ‘ƒ2, who may partici-
pate in the Setup phase once, and the Multiplication phases as many
times as they wish. FMtA runs and outputs ğ›¼, ğ›½, from two parties
inputs, respectively, ğ‘ and ğ‘, under the restriction that ğ›¼ + ğ›½ = ğ‘ğ‘
mod ğ‘.
It could be instantiated from OT [15], Paillier encryption [19, 26],
CL encryption [8], etc. Please refer to Sec. 4 for more details.
2.4 Zero-Knowledge Proof
Let R be a polynomial-time-decidable binary relation. The corre-
sponding language ğ¿ consists of statement ğ‘¥ such that there exists
witness ğ‘¤ and (ğ‘¥, ğ‘¤) âˆˆ R. We specify ğ¿ as an NP language.
An interactive proof consists of an interactive prover algorithm
ğ‘ƒ and a verifier algorithm ğ‘‰ that runs in PPT time. We call (ğ‘ƒ, ğ‘‰)
an interactive proof for relation R if it has the completeness and
soundness properties. Completeness means that for every ğ‘¥ âˆˆ ğ¿,
âŸ¨ğ‘ƒ, ğ‘‰âŸ©(ğ‘¥) is always 1. Soundness means that for every ğ‘¥ âˆ‰ ğ¿ and ev-
ery prover ğ‘ƒâˆ—, Pr[âŸ¨ğ‘ƒâˆ—, ğ‘‰âŸ©(ğ‘¥) = 1] is negligible. When the soundness
holds for computationally bounded provers, the system is usually
Session 2D: Secure Multiparty Computation CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea562called an â€œargument". In this paper, both proof and argument are
collectively referred to as proof.
Definition 2.1 (zero-knowledge). Let (ğ‘ƒ, ğ‘‰) be an interactive proof
for some language ğ¿. (ğ‘ƒ, ğ‘‰) is zero knowledge if for every PPT
verifier ğ‘‰ âˆ— there exists a PPT simulator Sim such that the two
ensembles {ğ‘‰ ğ‘–ğ‘’ğ‘¤ ğ‘ƒ
if the two ensembles are statistically (resp. computationally) indis-
tinguishable.
ğ‘‰ âˆ—(ğ‘¥)}ğ‘¥âˆˆğ¿ and {Sim(ğ‘¥)}ğ‘¥âˆˆğ¿ are identical.
We could also define statistical (resp. computational) zero-knowledge,
Definition 2.2 (proof-of-knowledge). Let ğœ : {0, 1}âˆ— â†’ [0, 1] be a
function. (ğ‘ƒ, ğ‘‰) is a proof of knowledge for relation R with knowl-
edge error ğœ if the following properties are satisfied:
â€¢ Completeness: If ğ‘ƒ and ğ‘‰ follow the protocol on input ğ‘¥
and private input ğ‘¤ to ğ‘ƒ where (ğ‘¥, ğ‘¤) âˆˆ R, then ğ‘‰ always
accepts.
â€¢ Knowledge Soundness: there exists a probabilistic oracle ma-
chine Ext such that for every prover function ğ‘ƒâˆ— and every
ğ‘¥ âˆˆ ğ¿, Ext satisfies the following: Denote ğœ–(ğ‘¥) the proba-
bility that ğ‘‰ accepts on input ğ‘¥ after interacting with ğ‘ƒâˆ—.
If ğœ–(ğ‘¥) > ğœ (ğ‘¥), on input ğ‘¥ with access to ğ‘ƒâˆ—, Ext runs in
expected polynomial time and outputs a string ğ‘¤ such that
(ğ‘¥, ğ‘¤) âˆˆ R with probability at least ğœ–(ğ‘¥) âˆ’ ğœ (ğ‘¥).
We remark that every zero-knowledge proof of knowledge (ZKPoK)
in this paper is transformed to non-interactive [4] using the Fiat-
Shamir paradigm [18] in the random oracle model.
ZKPoK of Discrete Logarithm. Define the relation
|ğ‘…, ğ‘ƒ âˆˆ G, ğ‘… = ğ‘¥ Â· ğ‘ƒ},
(ğ‘…, ğ‘ƒ), ğ‘¥(cid:1)
Rğ·ğ¿ := {
(cid:0)