20
s
e
g
a
p
l
e
b
a
h
s
i
u
g
n
i
t
s
i
d
f
o
%
the measurement method. Fig. 14 shows
Effect of
FixSched and Attack results for Firefox and Chrome on
the same chart, demonstrating that FixSched experiments
accurately represent recognizability under the actual attack
(we are using FixSched solely for scalability). Not only
are the distributions similar, but the same pages that have
high recognizability under FixSched overwhelmingly have
it under Attack (this is not shown on the chart). Fig. 15
shows Attack results for all three browsers.
Recognizability appears to be higher in Attack experi-
ments because they use a smaller ambiguity set. The smaller
the set, the lower the maximum similarity between any target
page and the “best” false positive from the ambiguity set,
the lower the threshold that must be used by the matching
algorithm to avoid false positives. Therefore, some mem-
prints that match the page signature in Attack experiments
no longer match in FixSched experiments, which use bigger
ambiguity sets and thus higher matching thresholds.
0
10% 20% 30% 40% 50% 60% 70% 80% 90% 100%
% of recognizable visits
Figure 13.
distinguishable pages (FixSched measurement). No false positives.
Chrome and Firefox: Recognizability of 1,000 random
Fig. 13 shows the results for Chrome and Firefox. As
many as 75% of the distinguishable pages have recognizabil-
ity above 20% (i.e., at least 1 out of 5 visits produces a rec-
ognizable memprint). For a quarter of the pages, every visit
produces a recognizable memprint, with no false positives.
Figs. 11 and 12 show that if a non-negligible false positive
rate is acceptable, the recognition rate is much higher.
s
e
g
a
p
l
e
b
a
h
s
i
u
g
n
i
t
s
i
d
f
o
%
100
80
60
40
20
0
Chrome (FixSched)
Chrome (Attack)
Firefox (FixSched)
Firefox (Attack)
10% 20% 30% 40% 50% 60% 70% 80% 90% 100%
% of recognizable visits
s
e
g
a
p
l
e
b
a
h
s
i
u
g
n
i
t
s
i
d
f
o
%
100
80
60
40
20
0
With PostMark
No Load
10% 20% 30% 40% 50% 60% 70% 80% 90% 100%
% of recognizable visits
Figure 14. Chrome and Firefox: Recognizability of 100 random distin-
guishable pages (Attack and FixSched measurements). No false positives.
Figure 16. Chrome: Recognizability of 20 random distinguishable pages,
no signiﬁcant load vs. PostMark running concurrently (Attack measure-
ment). No false positives.
152
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 11:47:37 UTC from IEEE Xplore.  Restrictions apply. 
Effects of concurrent workload. Other processes running
concurrently with the victim and the attacker do not reduce
the efﬁcacy of the attack. They slow down both the victim’s
memory allocations and the attacker’s measurements, but the
patterns measured by the attacker remain roughly the same.
Fig. 16 shows the results for our attack in the presence
of a concurrent, CPU- and I/O-intensive workload on the
host. In this experiment, the victim and the attacker run in
parallel with a PostMark benchmark, which simulates an
email, network news, and e-commerce client. PostMark is
executing in a loop with 100, 000 ﬁle-system transactions
in each iteration, causing 36% CPU load. In this case, the
concurrent workload slows the browser process more than
the attack process, enabling the latter to obtain more mea-
surements. The resulting memprint matches the signature of
the page better than in the absence of the workload.
s
e
g
a
p
l
e
b
a
h
s
i
u
g
n
i
t
s
i
d
f
o
%
100
80
60
40
20
0
10 samples/millisec
50 samples/millisec
100 samples/millisec
10% 20% 30% 40% 50% 60% 70% 80% 90% 100%
% of recognizable visits
Figure 17. Chrome: Recognizability of 20 random distinguishable pages
with different measurement rates (Attack measurement). No false positives.
Effects of the measurement rate. Fig. 17 shows that
even if the attack process decreases the rate at which it
measures the memory footprint of the browser process and
thus produces smaller memprints, recognition rates remain
high for distinguishable pages.
Fig. 18 shows that the Linux CPU cheat does not signiﬁ-
cantly affect accuracy of the attack. Our attack process only
uses this cheat to decrease its reported CPU usage and thus
hide its measurement activity.
Variations of the basic attack. Algorithm 1 has many
variations. For example, matching can ignore total footprint
sizes and only consider the sequence of deltas, or focus on
changes caused by allocating and de-allocating large images.
These variations work well for some pages and browsers.
For example, to process a large image, Firefox allocates a
big buffer, uncompresses the image into this buffer, then
frees the buffer after rendering the image. If the buffer
is bigger than 4MB, de-allocation results in immediately
returning memory to the OS. The corresponding change
153
s
e
g
a
p
l
e
b
a
h
s
i
u
g
n
i
t
s
i
d
f
o
%
100
80
60
40
20
0
With CPU cheat
No CPU cheat
10% 20% 30% 40% 50% 60% 70% 80% 90% 100%
% of recognizable visits
Figure 18. Chrome: Recognizability of 20 random distinguishable pages
with and without CPU cheat (Attack measurement). No false positives.
FIREFOX: AMOUNT OF MEMORY (>= 4 MB) FREED IMMEDIATELY
AFTER LOADING DIFFERENT WEBPAGES.
Table II
Webpage
of
de-
Sequence
allocations (in KB)
9216, 4096, 14336, 4096
8196, 8196, 8196, 8196
journaldesfemmes.com 8196, 8196, 8196, 8196,
playboy.com (adult)
exbii.com (adult)
cnn.com
8196, 10240, 5120
5120
in the drs ﬁeld of /proc//statm is observable
by the attacker. Therefore, the variation of the matching
algorithm that correlates deltas in the footprint with images
tends to do well at recognizing pages with many big, high-
resolution images (see Table II). This category includes the
front pages of many adult sites such as playboy.com.
VII. ADVANCED ATTACKS
In Section VI, we showed how to use the dynamics of
memory usage to recognize pages browsed by the victim.
We now show how to combine them with secondary side
channels to infer more private information. All attacks in
this section work against all tested browsers, but for clarity,
each ﬁgure only shows the results for a particular browser.
Inferring the state of Web sessions. Most changes in the
browser’s footprint occur while a page is being loaded and
rendered. The footprint then remains stable until the user
requests a new page. For example, Fig. 19 shows changes
in the footprint as the user enters a search query, views the
results, and clicks on a link. The increments and the size of
the stable footprints vary depending on the page within the
site. These differences can leak sensitive information.
Figs. 20 and 21 show that a successful login into, respec-
tively, Google Health and OkCupid (a dating site) results
in a signiﬁcant increase in the footprint since proﬁle pages
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 11:47:37 UTC from IEEE Xplore.  Restrictions apply. 
45000
40000
s
e
u
a
v
l
S
R
D
t
c
n
i
t
s
i
D
35000
30000
25000
20000
15000
10000
0
waiting for
user input
5000
10000
15000
20000
25000
30000
Time (in milliseconds)
Figure 19.
search session.
Evolution of the Firefox memory footprint during a Google
Figure 20. Google Health state transitions in Firefox. Changes visible to
the attacker are shown in bold.
tend to use more JavaScript than login pages. The attacker
can thus infer whether the victim is a member of the site.
Paid users of OkCupid do not see ads, while free users see
Flash advertisements. The Flash plugin runs as a separate
process, allowing the attacker to infer whether the victim is
a paid member of the dating site or not.
When the victim views medical records from Google
Health, a new PDF reader process appears. The ﬁle name in
its command-line arguments (available via proc on Linux,
but not Android) reveals the victim’s username.
Fig. 22 shows that the attacker can infer the medical con-
dition the victim is interested in by measuring the increase in
the browser’s memory footprint after the victim has clicked
on a link from webmd.com.
Disambiguating similar memprints. Secondary side chan-
nels can help disambiguate pages that otherwise have similar
memprints. For example, google.com and google.de
use the same template, thus their memprints are very similar.
Fig. 23 shows how they can be be distinguished by their
duration if the browser is located in the US.
Once the attack process is running concurrently with the
browser, it can directly observe which shared libraries are
used by the browser. Fig. 24 shows that if the matching
algorithm considers changes in the size of shared memory
in addition to changes in the main footprint (DRS), the
Figure 21. OkCupid state transitions in Firefox. Changes visible to the
attacker are shown in bold.
3500
3000
2500
2000
1500
1000
500
)
s
e
g
a
p
y
r
o
m
e
m
n
i
(
S
R
D
n
i
s
t
n
e
m
e
r
c
n
I
0
Cancer
Diabetes
Bipolar
Cholesterol
Depression
Figure 22.
webmd.com main page to different illness-related pages.
Chrome footprint
increments for
transitions from the
recognition rate improves for moderately stable pages.
Other useful side channels include timing of DNS reso-
lutions (they reveal whether a particular domain is in the
DNS cache), command-line arguments of various processes,
etc. In section VIII, we show how to use CPU scheduling
statistics—conveniently revealed by proc—to disambiguate
pages with similar memprints.
VIII. EXPLOITING CPU SCHEDULING STATISTICS
Zhang and Wang showed that the ESP (stack pointer)
value revealed by proc leaks information about keystroke
timings [20]. Their attack is unlikely to work on Android
because Dalvik-based Android applications—such as the
MMS app we attack below—are highly nondeterministic.
To illustrate our thesis that any accounting information
about a process can leak its secrets, we show how to use
scheduling statistics for keystroke snifﬁng. Unlike ESP, these
statistics are used by top and thus available in all versions
of Unix. Zhang and Wang mention the possibility that the
number of interrupts can be used for keystroke snifﬁng
but do not describe a concrete attack. The interrupt count
is global, not process-speciﬁc, thus the feasibility of this
attack remains open. Scheduling statistics, on the other hand,
provide a much more robust, process-speciﬁc channel.
Linux. In Linux, the number of context switches made by
a process can be found in /proc//schedstat,
154
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 11:47:37 UTC from IEEE Xplore.  Restrictions apply. 
40000
35000
30000
25000
20000
s
e
u
a
v
l
S
R
D
t
c
n
i
t
s
i
D
15000
10000