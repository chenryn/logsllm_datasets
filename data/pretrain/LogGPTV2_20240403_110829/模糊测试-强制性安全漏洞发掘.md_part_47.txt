个列表。VARIANT类型被表示为一个整数，该整数通过索引前面生成的VARIANT映射被转换
为一个名字。
该脚本在AdobeAcrobatPDFActiveX控件的IAcroAXDocShim接口上的最终执行结果如下
所示：
properties:
nethods:
srcO
LoadF11eO
f11eName, VT_BSTR
setShowToolbar)
On,VT_B00L
gotoFirstPageO)
gotoLastPage()
gotoPreviousPage()
setCurrentPageO
---
## Page 221
206
第二部分目标和自动化
n,VT_I4
goForwardStackO
goBackwardStackO
setPageMode()
pageHode，VT_BSTR
setLayoutMode()
1ayoutMode,VT_BSTR
setNanedDest()
nanedDest, VT_BSTR
PrintO
setZoom)
percent,VT_R4
setZoomScro110)
percent,VT_R4
1eft,VT_R4
setviewO
top, VT_R4
vlewMode,VT_BSTR
setViewScro11O
vieMode,VT_BSTR
offset, VT_R4
setViewRect)
1eft, VT_R4
top,VT_R4
he1ght, VT_R4
width,VT_R4
printPages()
from,VT_I4
to,VT_I4
printPagesFitO
from,VT_I4
to,VT_I4
shrinkToFit,VT_B00L
阳
printA11FitO
printAl1O
两版
shrinkToFit,VT_Bo0L
setShowScro11bars()
CetVersions()
On,VT_BOOL
setCurrentHight1ight()
a,VT_I4
b,VT_I4
C,VT_I4
d,VT_I4
setCurrentHigh11ghtC)
a,VT_I4
b,VT_I4
C,VT_I4
d,VT_I4
postMessage()
strArray.VT_VARIANT
messageHandler()
---
## Page 222
第18章Web浏览器的模糊测试：自动化207
根据所输出的结果，我们可以看到在该类型中定义了39个方法（函数），但是并没有定义
任何属性。每个方法的参数和类型列表被成功地枚举并显示。这个信息在智能模糊器的开发过
程中是非常重要的，它应当被用于测试用例的生成以确保每个变量被正确地模糊化。例如，考
虑对一个短整数（VT_I2）和一个长整数（VT_I4）进行模糊测试的比较。不将这些类型看作是
普通的整数，那么就可以节省宝贵的时间，方法是通过在从0到0xFFFF（65535）的有效区间
内对短整数进行模糊测试，而不是在从扩展的0到0xFFFFFFFF（4294967295）的全长整数
（长整数）的有效区间内对其进行模糊测试。
到目前为止，我们已经讨论了为一个给定系统中的、可以访问InternetExplorer的每个
ActiveX控件枚举其每个属性、方法和参数所必需的步骤。下一步就是要选择合适的模糊测试
启发式准则并开始测试。
18.2.3模糊测试和监视
第6章“自动化的测试数据生成”讨论了选择智能字符串和整数模糊值的重要性。所选择
的模糊测试启发式准则被设计为使错误发生的可能性最大化。本书中所描述的绝大部分模糊器
和测试用例实际上都是被设计来发现低层错误的，如缓冲区溢出，而不是发现诸如访问受限资
源那样的逻辑错误。目录遍历修饰符就是启发式准则的一个例子，它被用来发现类似的安全漏
润。当对ActiveX控件进行模糊测试时，对行为违规的搜索要特别谨慎，因为研究者经常发现
控件不应当通过InternetExplorer来被访问。
例如，考虑WinZipFileViewActiceX控件的不安全方法暴露漏润°。在这个例子中
ActiveX控件及其ProgIDWZFILEVIEW.FileViewCtrl.61作为脚本安全而发布，允许一个恶意Web
站点将控件加载到浏览器并利用其暴露的功能。更加特别的是，方法ExeCmdForA11Selected和
ExeCmdForFolder允许调用者从任意位置拷贝、移动、删除并执行文件，这些位置包括网络共
享库、FTP目录以及Web目录。这就为攻击者提供了一种简使的手段，即通过控制一个恶意的
Web站点来下载并执行一个任意的可执行文件，而不发出任何警告信息。WinZip针对此问题提
出了一种处理方法，即删除脚本安全设置井为特定的控件设置一个销毁位。
除了前面所使用的典型的模糊测试启发式准则之外，有效文件路径、命令以及URL应当被
包含在模糊数据中以帮助发现类似于WinZipFileView漏洞的错误。当然，模糊监视器必须要包
含所需要的功能以确定所提供的任何资源是否被成功访问。我们将在后面对这个念进行深入
讨论。
一且生成了模糊数据的一个合适的列表，下一步就是创建一系列的测试用例。完成此任务
的一种方法是使用前面所提到的任意一种方法来创建嵌入在目标ActiveX控件中的一个HTML
页，然后使用模糊化的参数来调用一个目标方法。可以为每个测试生成一个单独的文件，于是
单独的测试用例就可以被加载到InternetExplorer中。另外，目标控件也可以被直接加载和测试。
根据我们前面提到的例子，下面的Python代码片段将实例化一个AdobeAcrobatPDFActiveX控
 http://www.zerodayinitiative.com/advisories/ZD1-06-040.html
---
## Page 223
208第二部分目标和自动化
件，并访问它所暴露的方法中的两个：
adobe = win32con.c1ient.Dispatch("AcroPDF.PDF.1")
print adobe.GetVersions()
adobe.LoadFile(*c:\\test.pdf")
该代码片段的第一行负责实际创建AdobeCOM对象的一个实例，该实例可以通过名为
adobe的变量来访问。一旦该实例被创建，该对象就可以很自然地通过接口来访问。第二行输
出了调用GetVersions（）函数的结果，第三行使该控件将一个PDF文件加载到AdobeReader查看
器。将这个例子进行扩展以对其他的方法、参数和控件进行模糊测试就是非常简单的事情了。
该问题的剩余环节就是模糊器中的监视器部分。除了PythonCOM模块之外，我们利用
PaiMei逆向工程库来实现一个基于调试器的模糊测试监视器。该库将在后续章节中被扩展使
用，在那里我们将讨论一些更深层次的内容。从本质上来说，轻量级调试器的创建就是为了封
装目标ActiveX控件的执行。当一个低层次漏洞如缓冲区溢出被发现时，调试器被应用，并且
错误的特定细节信息被记录下来。PaiMei库也提供了钩住API调用的功能。该特性被用来监视
异常行为问题。通过对微软库调用函数如CreateFile（）和CreateProcess（）的参数进行观
察，我们就可以确定目标ActiveX控件是否成功访问了一个它不应当访问的资源。对API钩子功
能的细节进行评审，作为一个练习留给读者来完成。
最后需要注意的一点是，使用简单的正则表达式搜索来检查所暴露属性和方法的名字是值
得进行的一项工作。如果遇到了名为GetURL（），DownLoadF11e（）或Execute（）等的方法，那么
你可能想要立即给予它们某些特别的关注。
18.3小结
在本章中，我们讨论了微软的COM技术的发展历史，并且指出了从InternetExplorerWeb
浏览器对一个ActiceX控件进行访问的需求。研究了所需要的PythonCOM接口，同时研究了枚
举可访问的ActiveX控件及其属性、方法、参数和参数类型所需要的特定步骤。本章中所研究
的代码片段引自于一个具有完整特性的COM模糊器，该模糊器可以从本书的官方Web站点
(http://www.fuzzing.org)上下载。
 https:/w.openrce.rg/dowsloads/detail/208/PaiMei
http://msdn.microsoft.com/library/default.asp?url=/library/en-us/fileio/fs/createfile.asp
---
## Page 224
第19章内存数据的模糊测试
“它是白的。
GeorgeW.Bush，在英国被一个小孩问白宫像什么之后的四答，2001年7月19日
在本章中，我们引入内存数据模糊测试的概念，它是一种以前较少被人们所关注的新的模
期测试方法，目前还没有针对该方法的具有完整特性的概念验证工具被公开发布。从本质上来
说，该技术的目标是将模糊测试从所熟悉的客户机——服务器（或客户机——目标机）模型，
转换到只面向内存目标的模型中。尽管从技术上来看，它是一种更加复杂的方法，要求熟练掌
握汇编语言、进程内存规划以及进程工具的低层知识，但是在我们进人任何特定的实现细节之
前，我们会指出使用该技术同样会带来许多的益处。
在上一章中，我们采用一种协商的方法从UNIX和Windows的视角都提供了一个无偏见的
观点。由于该模期测试技术所具有的复杂性，本章中我们将关注的焦点限制在一个单一的平台
上。我们选择微软的Windows作为关注的平台，其原因如下：首先，这种模糊测试技术在不开
源的目标应用中应用的更好，而二进制软件在Windows平台上的分布要比其在UNIX平台上的
分布更加广泛.其次，Windows为进程工具提供了丰富而功能强大的调试API，这并不是说调
试API在UNIX平台上是不可用的，但我们认为UNIX平台上的调试API的健壮性不强。当然，
可以采用这里所讨论的通用概念和方法以应用到不同的平台中。
19.1内存数据模糊测试的概念及实施该测试的原因
到目前为止我们所讨论的每一种模糊测试方法都要求通过所期望的通道来生成和传输数
和第13章“文件格式测试：Windows平台上的自动化测试”中，被变异的文件直接被应用程序
所加载。在第14章“网络协议模糊测试”，第15章“网络协议模糊测试：UNIX平台上的自动化
测试”和第16章“网络协议模糊测试：Windows平台上的自动化测试”中，模糊数据通过网络
socket来传递到目标服务，这两种情形都要求我们向目标提供整个文件或一个完整的协议，即
使我们只对一个特定域的模糊测试感兴趣，同时在这两种情况下，我们完全没有察觉到也完全
不关心是哪些底层代码被执行以响应我们的输人，
内存数据模糊测试是一种完全不同的测试方法。它不是关注于一个特定的协议或者文件格
式，它所关注的是实际的底层代码。我们将测试的关注焦点从数据输人转换到负责解析数据输
人的函数以及单个的汇编指令，采用这种方式，我们忽略了所期望的数据通信通道，而是关注
于在目标应用程序的内存中变异或生成数据。
这种方法在什么时候可以给我们带来益处呢？考虑这样一个情形，即你正在对一个实现了
---
## Page 225
210
第二部分目标和自动化
复杂包加密或模糊模式的不开源网络daemon程序进行模糊测试。为了成功地对该目标应用进行
模糊测试，首先需要实现一个完整的逆向工程，并重新生成模糊模式。这是内存数据模糊测试
的一个主要应用场景。不是关注于不必要的协议封装，我们将分析目标应用的内存空间以寻找
感兴趣的时间点，例如，当所接受的网络数据被模糊化之后。作为另外一个例子，考虑下面的
情形，即我们期望对一个特定函数的健壮性进行测试。假定通过进行某些逆向工程工作，我们
阻止了含有单一字符串参数（即邮件地址）的一个邮件解析例程，并以某种方式将其进行解析。
我们能够生成并传输包含变异后的邮件地址的网络包或测试文件，但是在内存数据模糊测试中，
我们可以通过直接对目标例程进行模糊测试来关注所要做的工作。
这些概念将在本章的后续部分以及下一章中给子进一步的详细述。然面，我们需要首先
来学习一些相关的背景知识。