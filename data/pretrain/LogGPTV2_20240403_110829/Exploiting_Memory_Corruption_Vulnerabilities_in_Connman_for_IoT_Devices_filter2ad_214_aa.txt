title:Exploiting Memory Corruption Vulnerabilities in Connman for IoT Devices
author:K. Virgil English and
Islam Obaidat and
Meera Sridhar
2019 49th Annual IEEE/IFIP International Conference on Dependable Systems and Networks (DSN)
Practical Experience Report: Exploiting Memory Corruption
Vulnerabilities in Connman for IoT Devices
Department of Software and Information Systems, UNC Charlotte, Charlotte, NC, USA
K. Virgil English, Islam Obaidat, and Meera Sridhar
{kenglis8,iobaidat,msridhar}@uncc.edu
Abstract—In the recent past, there has been a rapid increase
in attacks on consumer Internet-of-Things (IoT) devices. Several
attacks currently focus on easy targets for exploitation, such as
weak conﬁgurations (weak default passwords). However, with
governments, industries, and organizations proposing new laws
and regulations to reduce and prevent such easy targets in the IoT
space, attackers will move to more subtle exploits in these devices.
Memory corruption vulnerabilities are a signiﬁcant class of
vulnerabilities in software security through which attackers can
gain control of the entire system. Numerous memory corruption
vulnerabilities have been found in IoT ﬁrmware already deployed
in the consumer market.
This paper presents an approach for exploiting stack-based
buffer-overﬂow attacks in IoT ﬁrmware, to hijack the device
remotely. To show the feasibility of this approach, we demonstrate
exploiting a common network software application, Connman,
used widely in IoT ﬁrmware such as Samsung smart TVs. A
series of experiments are reported on, including: crashing and
executing arbitrary code in the targeted software application in
a controlled environment, adopting the attacks in uncontrolled
environments (with standard software defenses such as W⊕X and
ASLR enabled), and installing publicly available IoT ﬁrmware
that uses this software application on a Raspberry Pi. The
presented exploits demonstrate the ease in which an adversary
can control IoT devices.
I. INTRODUCTION
Vulnerabilities in consumer Internet-of-Things (IoT) devices
are quickly becoming rampant [1–7]. Operational factors such
as low power consumption, business factors such as the need
to keep the cost of the device low and the time to market,
and many consumer IoT device manufacturers failing to adopt
reasonable security practices, lead to the usage of IoT devices
without proper security protection [8–12].
While research efforts in IoT security are invested exten-
sively into IoT system and network security solutions [4],
[13], [14], a NIST report indicates that 77% of all reported
vulnerabilities are in the software applications, not
in the
operating systems or networks [15].
Recent work shows the increasing prevalence of memory
corruption vulnerabilities in IoT devices (cf., [16]), largely
due to 66% of embedded software development using the C
language [17], [18], which is highly susceptible to such vul-
nerabilities [19]. Generally, buffer-overﬂow attacks are among
the most widespread exploitations of memory corruption vul-
nerabilities [20]. In this class of attacks, stack-based buffer-
overﬂows are among the most dangerous [21].
In this paper, we report on a series of proof-of-concept (PoC)
exploits for a known stack-based buffer-overﬂow vulnerability,
This research was supported in part by NSF CRII award #1566321
978-1-7281-0057-9/19/$31.00 ©2019 IEEE
DOI 10.1109/DSN.2019.00036
247
published as CVE-2017-12865 [22], in Connman [23], an
open source lightweight network connection manager software
that
is widely used in many IoT ﬁrmware such as Nest
thermostats [24], NAO robots [25], [26], and most smart
devices from Samsung such as smart watches and smart TVs.
The buffer-overﬂow vulnerability exists within the DNS proxy
module of Connman. This allows a crafted DNS response
to be sent to the DNS proxy module of Connman, which
can result in denial-of-service (DoS) or remote code execution
(RCE). To our knowledge, there is no existing PoC available
for CVE-2017-12865.
We ﬁrst report on a series of PoC exploits conducted in a
controlled environment. For this purpose, we install Connman
in a virtual machine running Ubuntu 16.04 LTS (compatible
with x86) and Ubuntu Mate 16.04 LTS (compatible with
ARMv7), and use gdb in both OSes to construct attacks
that are able to bypass different levels of two standard soft-
ware memory protection defenses, Writable XOR Executable
(W⊕X) [27], [28] and Address Space Layout Randomization
(ASLR) [29]. We begin our experiments with a traditional
code-injection attack. Without W⊕X or ASLR enabled, we
send an unexpected long string in DNS responses that consist
of NOP sled, shellcode, and repeated return address [30].
Then, we assume W⊕X protection is enabled, and construct
an attack to bypass W⊕X. Our last experiment assumes
the device has both W⊕X and ASLR enabled. To bypass
these protection mechanisms, we construct a code-reuse at-
tack (cf., [31]). Our proof-of-concept exploits demonstrate a
method for achieving arbitrary code execution (e.g., spawning
a root shell) through this vulnerability.
Having successful PoC exploits that bypass W⊕X and
ASLR in a controlled environment, we conduct the previous
series of PoC exploits in a non-controlled environment. To
achieve this, we install publicly available IoT ﬁrmware that
uses Connman on Raspberry Pi. Next,
to conduct a
realistic man-in-the-middle attack scenario, we use a Wi-Fi
Pineapple [32], a wireless network tool that is capable of
impersonating any Wi-Fi SSID scan request, to hijack the
IoT trafﬁc and route it to a fake DNS server that constructs
malicious DNS responses to trigger the vulnerability.
Our main contributions include:
• We construct a series of PoC exploits that can execute
arbitrary commands for a known stack-based buffer-
overﬂow vulnerability in Connman, a software applica-
tion that is used widely in IoT devices.
• Our exploits are constructed for Connman running on
x86 and ARMv7, under different levels of memory pro-
tection techniques, including W⊕X and ASLR.
• We adopt these exploit scenarios in non-controlled envi-
ronments, against IoT devices equipped with Connman.
Our experiments demonstrate that: (i) it is easy for adver-
saries to exploit these types of vulnerabilities even if IoT
devices use standard countermeasures such as W⊕X and
ASLR, and (ii) such vulnerabilities persist, even months after
being discovered, especially in up-to-date IoT devices. We
hope that
this study will bring better awareness of these
problems to the software security community and lead to
developing more robust defenses.
Buffer-overﬂow vulnerabilities are extensively targeted in
traditional systems, and we expect will become popular for
exploits in IoT ecosystems. Such attacks are not yet popular
in the IoT ecosystem since attackers are able to conduct
very low-cost attacks that exploit weak conﬁgurations, such
as default passwords. However, we expect that as these basic
security holes such as default or weak passwords are ﬁxed, and
governments and IoT vendors start providing protection and
awareness about the above [33–35], code-injection/code-reuse
attacks will provide fertile ground for IoT attackers [36].
The rest of this paper is organized as follows: Section II
presents an overview of Connman and the targeted vulner-
ability; Section III reports on the construction of the PoCs,
including a discussion of the main challenges that were
encountered; Section IV describes suggested mitigations, and
current work towards them; Section V discusses adapting our
approach to exploit other vulnerabilities; Section VI discusses
related work, and Section VII presents future work.
II. OVERVIEW
In this section, we present an overview of Connman and
its buffer-overﬂow vulnerability. We selected Connman from
recent work that surveys control-ﬂow hijacking vulnerabilities
in IoT devices [16]. We chose Connman because: (1) it
is a networking application that is used in a large number
of IoT devices, (2) it contains a stack-based buffer-overﬂow
vulnerability, and (3) adversaries can compromise and control
IoT devices with this vulnerability remotely.
Connman: Connman [23] is an open-source network
management daemon with a lightweight, low overhead design,
ideal for Linux embedded devices. Connman can manage con-
nections over Wi-Fi, Ethernet, cellular, and Bluetooth, using
plug-ins such as oFono [37] and Bluez [38]. This plug-
in based architecture provides customizable implementations,
and allows network functions such as DHCP and DNS to
be handled by one daemon instead of multiple. Connman’s
versatility comes from its ability to be used as a whole or
in parts, allowing Connman to work side-by-side with other
network management software to form a comprehensive suite.
The lightweight and customizable design of Connman make
it ideal for use in IoT devices.
Several smart devices and OSes currently use Connman,
such as Nest thermostats [24], Mer [39], Yocto [40], Jolla
OS [41], Ostro [42], Sailﬁsh OS [43], Tizen OS [44], [45],
Controlled Environment
Uncontrolled Environment
VM
DEP
ASLR
DNS_server.py
HOST
Wi-Fi Pineapple
2
DNS Manipulation
Forged SSID: CAFÉ_NET
3
1
MITM
SSID: CAFÉ_NET
DNS_server.py
Fig. 1. Experimental Setup for PoCs
used in most Samsung smart devices including tablets, smart-
phones, netbooks, smart TVs, and other smart home devices.
Connman is also the default network manager for NAO
OS [26], used in NAO robots, and many IoT development
platforms, such as Intel Galileo [46].
Vulnerability: CVE-2017-12865 [22] (henceforth refer-
enced as “the vulnerability”) is a stack-based buffer-overﬂow
vulnerability in the DNS-proxy feature of Connman 1.34 and
earlier. DNS-proxy sends DNS queries from localhost
to external DNS servers. The received DNS response,
if
malformed, can cause a DoS or RCE. This vulnerability is
located in the dnsproxy.c ﬁle of Connman.
The parse_response function of dnsproxy.c has
a buffer, name, which is used when Connman expands a
compressed DNS name to cache DNS responses of type
A, which is a 32-bit IPv4 lookup response, or type AAAA,
a 128-bit IPv6 lookup response [47]. For this purpose, the
parse_response function calls get_name function. List-
ing 1 shows the call of memcpy libc function in get_name
function with no proper length checking. The pre-deﬁned limit
of the buffer name size is 1024. A DNS response crafted with
a length over this limit overwrites adjacent memory, allowing
DoS and RCE attacks to be executed.
name [ (∗ name len ) ++] = l a b e l
∗ name len += l a b e l
l e n ;
1 memcpy ( name + ∗ name len , p + 1 ,
2
l e n ;
l a b e l
l e n + 1 ) ;
Listing 1. Unchecked memcpy used in get_name function
The vulnerability has been patched in subsequent versions
of Connman as of August 2017 [48]. Size checks have been
added to the data to be copied into the name buffer, returning
out if the size is larger than the buffer size. The ﬁxed version,
version 1.35, is the latest release. However, all prior versions
(1.34 and below) contain this vulnerability [49].
III. EXPERIMENTS
An attacker-controlled DNS server can exploit the vulnera-
bility by sending crafted messages to execute a DoS attack. We
construct a PoC to simulate this scenario. We create a simple
DNS server to act as a proxy for Connman’s DNS request.
On receiving a request from Connman, our DNS server sends
248
a Type A response with length greater than the name buffer
size. When Connman decompresses and adds the message to
the name buffer, the application crashes.
For this experiment, we use a 32-bit operating system, as
it more accurately portrays the limited resource environment
of most IoT devices. In this section, we report on six usable
attacks we construct that exploit this vulnerability. The six
attacks are conducted using three protection levels: (1) no
protections enabled, (2) (W⊕X) enabled, and (3) W⊕X with
ASLR enabled. We bypass each protection level on two differ-
ent architectures: Intel x86 architecture running Ubuntu 16.04,
and on a Raspberry Pi 3 Model B v1.2 with ARMv7
architecture running Ubuntu Mate, a popular embedded OS.
Each exploit construction presents its own set of require-
ments and challenges, which we discuss in the following
sections. Our experiments demonstrate that unpatched versions
of the vulnerability are susceptible to attack regardless of
what OS-level protections are present. Speciﬁcally, we found
three major embedded operating systems that still contain
vulnerable versions of Connman: the Yocto project, a popular
embedded OS development platform, compiles distributions
with Connman 1.31; OpenELEC, a popular media streaming
OS, comes with Connman 1.34, the last vulnerable version
of Connman; Tizen OS, a bedrock for Samsung devices,
utilizes a vulnerable version of Connman up until version
4.0. Following our successful exploitation of the vulnerability
in a controlled environment, we plan to target all three OSes
for simulated attacks.
Experimental Setup: The goal of all these experiments
is to interrupt
the ﬂow of Connman and spawn a root
shell. Connman natively runs with root permissions, so no
permission change is required for this to occur. All code
presented is written in Python.
Due to the nature of the vulnerability in Connman, all
exploits have to be sent over DNS responses, speciﬁcally