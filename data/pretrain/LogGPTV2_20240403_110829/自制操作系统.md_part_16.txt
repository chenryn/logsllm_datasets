init_screen(binfo->vram, binfo->scrnx, binfo->scrny);
putfont8(binfo->vram, binfo->scrnx, 8, 8, COL8_FFFFFF, hankaku + 'A' * 16);
putfont8(binfo->vram, binfo->scrnx, 16, 8, COL8_FFFFFF, hankaku + 'B' * 16);
putfont8(binfo->vram, binfo->scrnx, 24, 8, COL8_FFFFFF, hankaku + 'C' * 16);
putfont8(binfo->vram, binfo->scrnx, 40, 8, COL8_FFFFFF, hankaku + '1' * 16);
putfont8(binfo->vram, binfo->scrnx, 48, 8, COL8_FFFFFF, hankaku + '2' * 16);
putfont8(binfo->vram, binfo->scrnx, 56, 8, COL8_FFFFFF, hankaku + '3' * 16);
for (;;) {
io_hlt();
}
}
66 显示字符串（harib02f）
仅仅显示6个字符，就要写这么多代码，实在不太好看。
putfont8(binfo->vram, binfo->scrnx, 8, 8, COL8_FFFFFF, hankaku + 'A' * 16);
putfont8(binfo->vram, binfo->scrnx, 16, 8, COL8_FFFFFF, hankaku + 'B' * 16);
putfont8(binfo->vram, binfo->scrnx, 24, 8, COL8_FFFFFF, hankaku + 'C' * 16);
putfont8(binfo->vram, binfo->scrnx, 40, 8, COL8_FFFFFF, hankaku + '1' * 16);
putfont8(binfo->vram, binfo->scrnx, 48, 8, COL8_FFFFFF, hankaku + '2' * 16);
putfont8(binfo->vram, binfo->scrnx, 56, 8, COL8_FFFFFF, hankaku + '3' * 16);
所以笔者打算制作一个函数，用来显示字符串。既然已经学到了目前这一步，做这样一个函
数也没什么难的。嗯，开始动手吧……好，做完了。
void putfonts8_asc(char *vram, int xsize, int x, int y, char c, unsigned char *s)
{
extern char hankaku[4096];
for (; *s != 0x00; s++) {
putfont8(vram, xsize, x, y, c, hankaku + *s * 16);
x += 8;
}
return;
}
图灵社区会员 metorm 专享 尊重版权
7 显示变量值（harib02g） …… 97
C语言中，字符串都是以0x00结尾的，所以可以这么写。函数名带着asc，是为了提醒笔者字
1
符编码使用了ASCII。
这里还要再说明一点，所谓字符串是指按顺序排列在内存里，末尾加上0x00而组成的字符编
2
码。所以s是指字符串前头的地址，而使用*s就可以读取字符编码。这样，仅利用下面这短短的
一行代码就能够达到目的了。
3
putfonts8_asc(binfo->vram, binfo->scrnx, 8, 8, COL8_FFFFFF, "ABC 123");
试试看吧。……顺利运行了。 4
我们再稍微加工一下，……好，完成了。
5
整理后的HariMain
void HariMain(void)
{ 5
struct BOOTINFO *binfo = (struct BOOTINFO *) 0x0ff0;
init_palette();
init_screen(binfo->vram, binfo->scrnx, binfo->scrny); 7
putfonts8_asc(binfo->vram, binfo->scrnx, 8, 8, COL8_FFFFFF, "ABC 123");
putfonts8_asc(binfo->vram, binfo->scrnx, 31, 31, COL8_000000, "Haribote OS.");
putfonts8_asc(binfo->vram, binfo->scrnx, 30, 30, COL8_FFFFFF, "Haribote OS.");
8
for (;;) {
io_hlt();
}
} 9
10
11
12
13
77 显示变量值（harib02g）
现在可以显示字符串了，那么这一节我们就来显示变量的值。能不能显示字符串，对于操作 14
系统的开发影响很大。这是因为程序运行与想象中不一致时，将可疑变量的值显示出来是最好的
方法。 15
习惯了在Windows中开发程序的人，如果想看到变量的值，用调试器①（debugger）很容
——————————
16
① 指调试程序中的错误（bug）时所用的工具，英文是debugger。另外，调试（动词）是debug。
图灵社区会员 metorm 专享 尊重版权
98 …… 第5天：结构体、文字显示与GDT/IDT初始化
易就能看到，但是在开发操作系统过程中可就没那么容易了。就像用Windows的调试器不能
对Linux的程序进行调试一样，Windows的调试器也不能对我们的“纸娃娃操作系统”的程
序进行调试，更不要说对操作系统本身进行调试了。如果在“纸娃娃操作系统”中也要使用
调试器的话，那只有自己做一个调试器了（也可以移植）。在做出调试器之前，只能通过显
示变量值来查看确认问题的地方。
闲话就说这么多，让我们回到正题。那怎么样显示变量的值呢？可以使用sprintf函数。它是
printf函数的同类，与printf函数的功能很相近。在开始的时候，我们曾提到过，自制操作系统中
不能随便使用printf函数，但sprintf可以使用。因为sprintf不是按指定格式输出，只是将输出内容
作为字符串写在内存中。
这个sprintf函数，是本次使用的名为GO的C编译器附带的函数。它在制作者的精心设计之下
能够不使用操作系统的任何功能。或许有人会认为，什么呀，那样的话，怎么不做个printf函数
呢？这是因为输出字符串的方法，各种操作系统都不一样，不管如何精心设计，都不可避免地要
使用操作系统的功能。而sprintf不同，它只对内存进行操作，所以可以应用于所有操作系统。
■■■■■
我们这就来试试这个函数吧。要在C语言中使用sprintf函数，就必须在源程序的开头写上
#include ，我们也写上这句话。这样以后就可以随便使用sprintf函数了。接下来在HariMain
中使用sprintf函数。
sprintf(s, "scrnx = %d", binfo->scrnx);
putfonts8_asc(binfo->vram, binfo->scrnx, 16, 64, COL8_FFFFFF, s);
sprintf函数的使用方法是：sprintf（地址，格式，值，值，值，……）。这里的地址指定所生
成字符串的存放地址。格式基本上只是单纯的字符串，如果有%d这类记号，就置换成后面的值
的内容。除了%d，还有%s，%x等符号，它们用于指定数值以什么方式变换为字符串。%d将数
值作为十进制数转化为字符串，%x将数值作为十六进制数转化为字符串。
关于格式的详细说明
%d 单纯的十进制数
%5d 5位十进制数。如果是123，则在前面加上两个空格，变成" 123"，强制达到5位
%05d 5位十进制数。如果是123，则在前面加上0，变成"00123"，强制达到5位
%x 单纯的十六进制数。字母部分使用小写abcdef
%X 单纯的十六进制数。字母部分使用大写ABCDEF
%5x 5位十六进制数。如果是456（十进制），则在前面加上两个空格，变成" 1c8" ，强制达到5位。还有%5X的
形式
%05x 5位十六进制数。如果是456（十进制），则在前面加上两个0，变成"001c8"，强制达到5位。还有%05X的形式
图灵社区会员 metorm 专享 尊重版权
8 显示鼠标指针（harib02h） …… 99
我们来运行一下看看。……运行正常。 1
说点题外话。因为这本书是在笔者吭哧吭哧写完
之后大家才看到的，所以虽然讲到“能显示变量的值 2
了”，“以后调试就容易了”，恐怕大家也很难体会到
其中的艰辛。但是，笔者是真刀真枪地编程，在此过
3
程中犯了很多的错（大多都是低级错误）。以前，因
为不能显示变量的值，所以发现运行异常的时候，只
4
能拼命读代码，想象变量的值来修改程序，非常辛苦。
但从今以后可以显示变量的值就轻松多了。
5
话说，在分辨率是320×200的屏幕上，8×16的字体可是很大哟（笑）。
88 显示鼠标指针（harib02h） 5
估计后面的开发速度会更快，那就赶紧趁着这势头再描画一下鼠标指针吧。思路跟显示字符
7
差不多，程序并不是很难。
首先，将鼠标指针的大小定为16×16。这个定下来之后，下面就简单了。先准备16×16=256
8
字节的内存，然后往里面写入鼠标指针的数据。我们把这个程序写在init_mouse_cursor8里。
9
void init_mouse_cursor8(char *mouse, char bc)
/* 准备鼠标指针（16×16） */
{
static char cursor[16][16] = { 10
"**************..",
"*OOOOOOOOOOO*...",
"*OOOOOOOOOO*....", 11
"*OOOOOOOOO*.....",
"*OOOOOOOO*......",
"*OOOOOOO*.......",
12
"*OOOOOOO*.......",
"*OOOOOOOO*......",
"*OOOO**OOO*.....",
"*OOO*..*OOO*....", 13
"*OO*....*OOO*...",
"*O*......*OOO*..",
"**........*OOO*.", 14
"*..........*OOO*",
"............*OO*",
".............***" 15
};
int x, y;
16
for (y = 0; y vram, binfo->scrnx, 16, 16, mx, my, mcursor, 16);
也不知能不能正常运行，试试看。……好，能运行！
图灵社区会员 metorm 专享 尊重版权
9 GDT与IDT的初始化（harib02i） …… 101
1
2
3
4
99 GDT 与 IDT 的初始化（harib02i）
5
鼠标指针显示出来了，我们想做的第一件事就是去移动它，但鼠标指针却一动不动。那是当
5
然，因为我们还没有做出这个功能。……嗯，无论如何想让它动起来。
要怎么样才能让它动呢？……（思考中）……有办法了！首先要将GDT和IDT初始化。不过
7
在此之前，必须说明一下什么是GDT和IDT。
GDT也好，IDT也好，它们都是与CPU有关的设定。为了让操作系统能够使用32位模式，需
8
要对CPU做各种设定。不过，asmhead.nas里写的程序有点偷工减料，只是随意进行了一些设定。
如果这样原封不动的话，就无法做出使用鼠标指针所需要的设定，所以我们要好好重新设置一下。
9
那为什么要在asmhead.nas里偷工减料呢？最开始就规规矩矩地设定好不行吗？……嗯，
这个问题一下子就戳到痛处了。这里因为笔者希望尽可能地不用汇编语言，而用C语言来写，
这样大家更容易理解。所以，asmhead.nas里尽可能少写，只做了运行bootpack.c所必需的一 10
些设定。这次为了使用这个文件，必须再进行设定。如果大家有足够能力用汇编语言编写程
序，就不用模仿笔者了，从一开始规规矩矩地做好设定更好。 11
从现在开始，学习内容的难度要增加不小。以后要讲分段呀，中断什么的，都很难懂，很
多程序员都是在这些地方受挫的。从难度上考虑，应该在20天以后讲而不是第5天。但如果现在 12
不讲，几乎所有的装置都不能控制，做起来也没什么意思。笔者不想让大家做没有意思的操作
系统。
13
所以请大家坚持着读下去，先懂个大概，然后再回过头来仔细咀嚼。在一天半以后，内容的
难度会回到以前的水平，所以这段时间大家就打起精神加油吧！
14
■■■■■
15
先来讲一下分段①。回想一下仅用汇编语言编程时，有一个指令叫做ORG。如果不用ORG指
——————————
16
① 英文是segmentation。
图灵社区会员 metorm 专享 尊重版权
102 …… 第5天：结构体、文字显示与GDT/IDT初始化
令明确声明程序要读入的内存地址，就不能写出正确的程序来。如果写着ORG 0x1234，但程序
却没读入内存的0x1234号，可就不好办了。
发生这种情况是非常麻烦的。最近的操作系统能同时运行多个程序，这一点也不稀奇。这种
时候，如果内存的使用范围重叠了怎么办？这可是一件大事。必须让某个程序放弃执行，同时报
出一个“因为内存地址冲突，不能执行”的错误信息。但是，这种错误大家见过吗？没有。所以，
肯定有某种方法能解决这个问题。这个方法就是分段。
所谓分段，打个比方说，就是按照自己喜欢的方式，将合计4GB①的内存分成很多块（block），
每一块的起始地址都看作0来处理。这很方便，有了这个功能，任何程序都可以先写上一句ORG 0。
像这样分割出来的块，就称为段（segment）。顺便说一句，如果不用分段而用分页②（paging），
也能解决问题。不过我们目前还不讨论分页，可以暂时不考虑它。
需要注意的一点是，我们用16位的时候曾经讲解过的段寄存器。这里的分段，使用的就是
这个段寄存器。但是16位的时候，如果计算地址，只要将地址乘以16就可以了。但现在已经是
32位了，不能再这么用了。如果写成“MOV AL,[DS:EBX]”，CPU会往EBX里加上某个值来计
算地址，这个值不是DS的16倍，而是DS所表示的段的起始地址。即使省略段寄存器（segment
register）的地址，也会自动认为是指定了DS。这个规则不管是16位模式还是32位模式，都是一
样的。
■■■■■
按这种分段方法，为了表示一个段，需要有以下信息。