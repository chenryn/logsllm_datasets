in a Flicker-based secure execution mode that is realized
using Intel TXT [15]. Additionally, the program performs
the attestation after the UTP Flicker session has completed.
In the common usage scenario, the user opens the web
site of the online web shop in Firefox and selects items
to buy. When the user is ready to submit her order, she
presses the “Submit” button on the ﬁnal summary page of
the web shop. The extension then detects that this button
has been clicked (because it has a special ID) and connects
to the web server to request a nonce and a conﬁrmation
message. When the extension receives the requested ﬁles, it
calls the client utility program, which invokes text mode in
the graphics card5 and formats the received data as inputs
for a Flicker session. Note that leveraging the untrusted
code to invoke text mode simpliﬁes the work that must
be done inside the Flicker-protected session. When invoked,
the Flicker framework executes using TXT-based hardware
protections, with the UTP module as its PAL. Figure 5 shows
the additional modules we have implemented.
Table I shows the lines of code (LoC) for the implemented
modules on the client side, as well as the code size of
the existing Flicker framework that we build upon and that
belongs to the TCB of our UTP agent. The overall size of the
TCB (including drivers for user I/O) is only a few thousand
LoC.
Conﬁrmation Agent (client-side): When invoked, the
UTP module displays the conﬁrmation message. It prompts
the user to enter a randomly chosen character sequence (to
avoid habituation by simply hitting ENTER). Figure 4 shows
our sample conﬁrmation dialog.
When the correct character sequence has been entered,
UTP extends PCR 19 with the nonce and the conﬁrmation
5We have used text mode for simplicity, since a basic VGA driver is
straightforward to implement inside Flicker. A fully graphical conﬁrmation
page could also be implemented, but it would require additional support
inside Flicker for the graphics mode(s) of interest.
Authorized licensed use limited to: Tsinghua University. Downloaded on March 18,2021 at 14:44:30 UTC from IEEE Xplore.  Restrictions apply. 
FlickerPALVeriﬁcation programClient utility programServer side scriptExtensionClient Browser7Module
d Client utility program
Language
C
JavaScript
C
e
t
s
u
r
t
n
u
d
e
t
s
u
r
t
Firefox extension
AIK generation program
Sum
Keyboard & display drivers a C
C
Flicker PAL
C/Assembly
Flicker TCB
UTP helper functions
C
Sum
LoC
321
95
540
956
254
260
741
1080
2335
Table I
CODE SIZES ON CLIENT SIDE.
aThe given LoC include the PS/2 and VGA drivers. Support for USB
keyboards would increase the code size by 1500-2000 LoC.
text string that was provided by the server. If an incorrect
sequence is entered (or if the user chooses not to conﬁrm
the transaction), then a failure message is extended into the
PCR. Finally, a special value denoting that the secure session
is ending is extended into PCRs 18 and 19. Though a well-
behaved OS will prevent application software from accessing
the TPM at localities 2 and 3, a malicious OS can access
those addresses. On Intel hardware, PCR 17 can only be
extended by Intel’s SINIT Authenticated Code Module (we
use Q35 SINIT 17.BIN for our prototype).
After the UTP module returns, the utility program requests
a TPM Quote that includes PCRs 17 and 18 (containing
measurements of Flicker and the UTP code), and PCR
19, which contains the hashed nonce and conﬁrmation text
string. The nonce will also be used by the TPM for signature
generation during the attestation operation.
Conﬁrmation Veriﬁcation (server-side): The veriﬁca-
tion script receives the data and veriﬁes it according to the
following criteria:
• The signature is valid and from a registered TPM (i.e.,
one that has been registered during the enrollment phase).
We currently authenticate the client device based on a
simple whitelist of allowed devices, realized as a list
of known public AIKs. We note that more sophisticated
authentication methods are readily applicable (e.g., [23],
[24], [25]).
• The PCR values for Flicker and the UTP code are correct
in PCRs 17 and 18, i.e., they are on the known-good list.
• The PCR value of the nonce and conﬁrmation text string
in PCR 19 is correct, i.e., corresponding to those sent by
the veriﬁer for this transaction conﬁrmation.
When all checks are successfully performed, the transaction
is accepted by the web server, and the user will see a
corresponding message in the (well-behaved) web browser.
Detailed PCR Contents: Here we describe in detail the
exact data that is extended into PCRs 17–19 in our prototype.
This helps to illustrate precisely what code and operations
comprise the software Trusted Computing Base (TCB) for
the UTP veriﬁcation session.
• PCR 17: (these values represent the SINIT module for
SinitMleData.Version 6 [10]):
Extend(SHA1(SinitMleData.SinitHash |
Extend(SHA1(SinitMleData.BiosAcm.ID |
SinitMleData.EdxSenterFlags))
SinitMleData.MsegValid |
SinitMleData.StmHash |
SinitMleData.PolicyControl |
SinitMleData.LcpPolicyHash |
(OsSinitData.Capabilities,0)))
• PCR 18: (this is precisely the hash of the Flicker-based
PAL that we have written for UTP):
Extend(SinitMleData.MleHash)
• PCR 19: (these are the input and output parameters of
the UTP Flicker session, where 1 means conﬁrmed, and
0 means not conﬁrmed):
Extend(1|0); Extend(nonce); Extend(SHA1(ConfMsg))
C. Deployment
The design of our UTP conﬁrmation agent is generic
and not service provider-speciﬁc. Since the conﬁrmation
message is provided by the server for each transaction, the
service providers can adapt the content or look and feel of
these messages without the need to redesign the UTP agent.
The end user is not required to have any understanding of
the code that runs in secure mode, nor is there any need to
do per-system or per-TPM generation of expected hashes.
To use our UTP agent, the user only needs to download
the agent code and the browser extension and install it on an
OS that supports the Flicker framework (currently Linux).
The same agent code and browser extension can be reused
across many platforms. There may need to be a few variants
(e.g., Windows vs Linux, Intel vs AMD), but we do not
foresee a signiﬁcant scalability problem.
To support a wide range of hardware for user input,
our prototype includes drivers for VGA display and PS/2
keyboards, and optionally USB keyboards. On PC-class
platforms there is a basic set of VGA and PS/2 I/O available
(even on systems with USB keyboards). These can be used
as a widely available fall-back in the event that more sophis-
ticated drivers for a particular platform are not available. Our
current prototype is built with the assumption that the OS is
the lowest layer of system software. However, Flicker and
UTP can coexist with virtualization software. A hypervisor
such as Xen [36] could be readily modiﬁed to enable Flicker
and thus our UTP agent.
D. Performance Evaluation
We have implemented and tested our prototype on a Dell
Optiplex 755, with a 3.0 GHz Intel Core2 Duo E6850 and
ST Microelectronics v1.2 TPM. We run Ubuntu 9.04 (i386)
and Linux kernel 2.6.30-6.
Authorized licensed use limited to: Tsinghua University. Downloaded on March 18,2021 at 14:44:30 UTC from IEEE Xplore.  Restrictions apply. 
8Figure 6 shows the timeline of a typical
transaction
conﬁrmation. While the system waits for user conﬁrmation
in secure mode, the rest of the OS is halted, and thus the
user’s current work is suspended. However, all of the steps
before entering secure mode and after resuming the system
happen in background and are transparent to the user. There
is a delay time of approximately one second before the actual
conﬁrmation summary is displayed. This time includes the
time to switch the graphics card to text mode, enter secure
mode, and initialize the video device in the Flicker PAL.
However, such a short delay is quite common across web
sites when waiting for a summary of a transaction.
Figure 6. Timeline of a typical UTP session.
V. SECURITY ANALYSIS
The security of our approach relies mainly on the follow-
ing three properties: (1) the server accepts only transactions
that are properly conﬁrmed; (2) the UTP agent is executed in
an isolated mode where it is protected against software-based
tampering, and where it solely controls the user-centric I/O
devices (keyboard, screen, mouse); and (3) the remote server
can get assurance as to whether the conﬁrmation agent was
actually executed in the secure mode and that the user indeed
conﬁrmed the transaction via the keyboard. Also required
is that the user actually read the transaction summary. We
discuss different attack scenarios in the following.
A. Transactions Must Be Conﬁrmed
The essence of our approach is that a specially designed
conﬁrmation agent is executed in an isolated environment on
the client system to enable the user to conﬁrm a proposed
transaction. Given the strength of our adversary (superuser
privileges on the legacy OS), we ultimately depend on the
user during a ﬁnal conﬁrmation step. Thus, the usability of
the conﬁrmation procedure is of utmost importance.
We also brieﬂy comment on the ability of attackers to at-
tach malicious input devices or compromise other peripheral
devices and reprogram them to masquerade as input devices.
While heuristics such as refusing to verify a transaction
on a system with more than one USB keyboard attached
may offer some level of protection, fundamentally this is
a signiﬁcant challenge. However, solutions where the user
must transcribe a few digits from the display again raises the
bar for attackers, as they would also need a malicious video
interface card. This is a signiﬁcantly more complex task than
compromising [37] or impersonating a USB keyboard.
In our implementation, the server sends the conﬁrmation
message to be displayed by the UTP conﬁrmation agent.
The agent displays the message, and requests that the user
enter a few (randomly chosen) characters as conﬁrmation.
The adversary (e.g., malware on the user’s computer) may
modify a user-generated, or construct a new, transaction
request and send it to the server. He has this power because
he can control the execution of the web browser and OS as
long as the isolated execution environment is inactive.
Though the details of the malicious transaction are dis-
played on-screen, the user could potentially conﬁrm the
modiﬁed transaction through an oversight. For example,
a study of transaction authentication via mobile phones
as used in some online banking applications has shown
that users do not always check the conﬁrmation message
carefully enough [38]. Thus, the particular details of the
displayed message, and the actions required of the user that
will be interpreted as conﬁrmation, are of great interest.
Here, we focus on the technical realization of the one-
way trusted path to realize secure transaction conﬁrmation.
The deﬁnition of conﬁrmation messages is up to the service
provider. The transaction conﬁrmation may be improved by
letting the user enter a transaction-speciﬁc detail as con-
ﬁrmation instead of a few random characters. Researchers
have shown that users’ intentions are more accurately cap-
tured when the user actively re-selects the destination of a
transaction from a list of different destinations [29].
B. Isolated Execution
Our conﬁrmation agent executes with hardware-enforced
isolation, taking advantage of Intel TXT and the Flicker
architecture to protect itself from all other code and de-
vices on the system. Our conﬁrmation agent is speciﬁcally
constructed to take control of the user-centric I/O devices,
i.e., the keyboard and graphics display. The adversary has
two options for tampering with the conﬁrmation agent: (1)
manipulate or replace the conﬁrmation agent code when it
is going to be executed, or (2) execute an entirely different
application that fakes the conﬁrmation agent display on
screen (thereby fooling the user).
In case (1) the malicious agent will execute, and the user
may be tricked into conﬁrming a different transaction than
the one that the malicious code will attempt to submit to
the web server. However, activation of the secure mode of
Intel TXT will result in hashing the agent’s code into PCR
18. We show in §V-C that this will be detected by the web
server, which will invalidate the transaction.
In case (2) neither the conﬁrmation agent nor the isolated
execution mode are invoked. Instead, an application in the
untrusted mode simulates the conﬁrmation dialog. The user
is not able to detect a faked dialog since we do not have a
full trusted path with the ability to authenticate the currently
Authorized licensed use limited to: Tsinghua University. Downloaded on March 18,2021 at 14:44:30 UTC from IEEE Xplore.  Restrictions apply. 
9running application to the user.6 However, even if the user
conﬁrms the faked conﬁrmation dialog, the malicious code
is unable to cause PCR 18 to reset and be extended with
the hash of the conﬁrmation agent expected by the server.
Again, §V-C shows how the web server detects this.
C. Remote Attestation
As our adversary has superuser privileges on the untrusted
OS, he may be able to invoke an isolated execution envi-
ronment with code and inputs of his choosing. Or, he may
fake the entire process from the perspective of the user.
In either case, our defense rests upon the contents of the
PCRs in the client system’s TPM. Speciﬁcally, PCRs 17–19
contain (respectively) hashes of the chipset-speciﬁc signed
code from the chipset vendor (e.g., Intel), the hash of the
conﬁrmation agent code itself, and hashes summarizing the
nonce, conﬁrmation string that was displayed to the user,
and the user’s response.
PCR 17 can only be extended by the CPU or Intel-signed
SINIT Authenticated Code Module. Thus, the remote server
can learn precisely what code was invoked in the isolated
environment and is able to detect unintended code execution
when it veriﬁes the values during the attestation process.
This gives the web server the ability to detect and deny
transactions that originate on hardware with known chipset
or CPU vulnerabilities. Perhaps more importantly, it also
enables the web server to detect that no such operation took
place, i.e., that the isolated environment was not invoked.
PCR 18 is extended as part of the dynamic root of
trust operation that invokes the isolated execution environ-
ment (e.g., GETSEC[SENTER]). It will contain the hash
of precisely the code that received control following the
reset of the dynamic PCRs (including 17–19) and platform
reinitialization by the Authenticated Code Module. On a
well-behaved system,
this will be the hash of the UTP
conﬁrmation agent code. Again, the web server can verify