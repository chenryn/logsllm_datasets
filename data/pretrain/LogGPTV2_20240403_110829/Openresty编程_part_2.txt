### 序言部分

序言部分通常位于 `{special_data_line}` 之上，仅包含几行简单的 Perl 代码。这些代码非常简单且几乎不会改变，即使不懂 Perl 语法也能编写。最简单的 Perl 序言如下：

```perl
use Test::Nginx::Socket 'no_plan';
run_tests();
```

- 第一行加载了 `Test::Nginx::Socket` 模块，并传递 `'no_plan'` 选项来禁用测试计划（我们将在后续章节中详细介绍测试计划，此处暂不赘述）。`Test::Nginx::Socket` 是 `Test::Nginx` 测试框架中最常用的类之一。
- 第二行调用了从 `Test::Nginx::Socket` 模块自动导入的 `run_tests` 函数，以运行测试文件数据部分（即 `{special_data_line}` 之后的内容）中定义的所有测试用例。

在实际的测试代码中，序言部分可能会更复杂。复杂的序言通常会定义一些可以在测试用例中共享和引用的环境变量或 Perl 变量，或者调用 `Test::Nginx::Socket` 模块中的其他函数来自定义当前测试文件的配置和行为。我们将在后续章节中详细讨论这些更复杂的序言。

**注意**：在上下文明确的情况下，Perl 允许省略函数调用时的括号。因此，在实际项目中的测试文件序言部分，可能会看到如 `run_tests;` 这样的形式。我们在后续示例中也会使用这种形式，因为它更为紧凑。

### 数据部分

数据部分是 `Test::Nginx` 测试文件中最重要的部分，用于存放测试用例。它采用了一种简单的规范格式来表达测试用例，用户无需使用 Perl 或其他通用语言即可编写测试。这种特殊的专用格式是一种领域特定语言（DSL），适用于 NGINX 上运行的测试代码。DSL 的使用使得测试用例可以被视为数据而非代码，这也是为什么 `Test::Nginx` 是一个数据驱动的测试框架。

#### 测试块

数据部分由一系列测试块组成。每个测试块通常对应一个单独的测试用例，包含一个标题、一个可选的描述和多个数据节。测试块的结构如下所示：

```test-base
=== 标题
可选描述...
— section1
值1...
— section2
值2...
— section3
值3...
```

##### 块标题

每个测试块以三个等号（`===`）开头的标题行开始。标题行开头不能有空格。标题是必需的，用于简要描述当前测试用例的目的，并在测试失败时帮助识别测试块。按惯例，我们在标题前加上 `TEST N:` 前缀，例如 `TEST 3: test the simplest form`。无需担心测试序号的维护问题，稍后我们将介绍一个名为 `reindex` 的命令行工具，它可以自动更新块标题的序号。

##### 块描述

每个测试块可以在标题行后添加一个可选的描述。描述可以跨多行，提供比标题更详细的测试意图说明，并可能包含一些背景信息。许多测试用例为了方便起见省略了这一部分。

##### 数据节

每个测试块在块描述（如果有的话）后包含一个或多个数据节。数据节总是有一个名称和一个值，用于指定输入数据字段和期望的输出数据字段。

- **数据节名称**：名称是指 `---` 前缀后面的文字。虽然语法上不要求，但出于美观考虑，我们通常在 `---` 和名称之间留一个空格。数据节名称通常只包含字母、数字和下划线。
- **数据节值**：值有两种形式。一种是名称行后的所有行，直到下一个数据节或测试块。另一种形式更为紧凑，直接在名称行中以冒号（`:`）隔开指定值。后者要求值不能换行。冒号两边的空格会被忽略，行结尾的换行符也不计入值的一部分。

如果名称后没有任何可见的值，则该数据节的值为空字符串，但仍是一个定义的值。如果完全省略数据节名称和值，则该数据节未定义。

`Test::Nginx` 提供了许多预定义的数据节名称，用于不同的目的。有些数据节用于指定输入数据，有些用于指定期望输出，还有一些用于控制是否运行当前测试块。

**示例**：

```test-base
=== TEST 1: hello, world
这是一个简单的演示，展示了 ngx_http_echo_module 提供的 echo 指令。
— config
location = /t {
    echo "hello, world!";
}
— request
GET /t
— response_body
hello, world!
— error_code: 200
```

- **输入数据节**：`config` 和 `request` 分别用于指定默认 `server {}` 中的自定义 NGINX 配置片段和测试脚手架发送给测试 NGINX 服务器的 HTTP 请求。
- **输出数据节**：`response_body` 指定期望的响应体输出。如果实际响应体与 `response_body` 中的值不同，则测试用例失败。`error_code` 指定期望的 HTTP 响应状态码，其值在同一行中指定。

数据节前后的空行会被 `Test::Nginx::Socket` 忽略，因此上述测试块可以重写为：

```test-base
=== TEST 1: hello, world
这是一个简单的演示，展示了 ngx_http_echo_module 提供的 echo 指令。
— config
location = /t {
    echo "hello, world!";
}
— request
GET /t
— response_body
hello, world!
— error_code: 200
```

出于美观原因，有些用户更喜欢这种风格。你可以选择你喜欢的形式。

#### 控制数据节

还有一些特殊的数据节既不指定输入也不指定输出，而是用于控制测试块的运行方式。例如：

- **ONLY**：仅运行当前测试文件中的当前测试块，跳过其他所有测试块。这对于调试特定测试失败非常有用。
- **SKIP**：无条件跳过包含该数据节的测试块，便于准备未来功能的测试而不引入预期的测试失败。

我们将在后续章节中介绍更多这样的“控制数据节”。

#### 节过滤器

数据节可以带有一个或多个过滤器，用于调整或转换数据节的值。语法上，过滤器紧跟在数据节名称后，至少用一个空格分隔。多个过滤器之间也用空格分隔，并按顺序应用。

希望这些优化使文本更加清晰、连贯和专业。如果有任何进一步的修改需求，请告知。