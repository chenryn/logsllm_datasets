//www.darpa.mil/attachments/SIEVEProposersDaySlidesv4.pdf, 2019.
DARPA SIEVE Program Proposers Day Slides.
Authorized licensed use limited to: Tsinghua University. Downloaded on August 07,2022 at 12:58:36 UTC from IEEE Xplore.  Restrictions apply. 
2264
[135] “Researchers demonstrate potential for zero-knowledge proofs in
vulnerability disclosure.”
https://www.darpa.mil/news-events/2021-04-22, 2021. DARPA Press
Release.
[136] F. Tram`er, F. Zhang, H. Lin, J.-P. Hubaux, A. Juels, and E. Shi,
“Sealed-glass proofs: Using transparent enclaves to prove and sell
knowledge,” in IEEE S&P, 2017.
[137] L. Breidenbach, P. Daian, F. Tram`er, and A. Juels, “The Hydra
framework for principled, automated bug bounties,” IEEE Security &
Privacy Magazine, vol. 17, pp. 53–61, July 2019.
[138] L. Breidenbach, P. Daian, F. Tram`er, and A. Juels, “Enter the Hydra:
Towards principled bug bounties and exploit-resistant smart
contracts,” in USENIX Security, 2018.
[139] D. Heath and V. Kolesnikov, “Stacked garbling with O(b log b)
computation,” in EUROCRYPT, 2021.
[140] D. Heath and V. Kolesnikov, “Stacked garbling for disjunctive
zero-knowledge proofs.,” EUROCRYPT, 2020.
[141] C. Baum, A. J. Malozemoff, M. B. Rosen, and P. Scholl,
“Mac’n’cheese: Zero-knowledge proofs for boolean and arithmetic
circuits with nested disjunctions,” in CRYPTO, 2021.
[142] D. Heath, Y. Yang, D. Devecsery, and V. Kolesnikov, “Zero
knowledge for everything and everyone: Fast ZK processor with
cached ORAM for ANSI C programs,” in IEEE S&P, 2021.
[143] K. R. M. Leino and C. Pit-Claudel, “Trigger selection strategies to
stabilize program veriﬁers,” in CAV, Springer, 2016.
[144] M. Andrysco, A. N¨otzli, F. Brown, R. Jhala, and D. Stefan, “Towards
veriﬁed, constant-time ﬂoating point operations,” in CCS, 2018.
[145] Kaggle, “Compeitions.” https://www.kaggle.com/docs/competitions.
[146] ARPA-E, “Grid optimization competition.”
https://gocompetition.energy.gov/.
[147] A. C. Yao, “Protocols for secure computations,” in FOCS, 1982.
[148] O. Goldreich, S. Micali, and A. Wigderson, “How to play any mental
game or A completeness theorem for protocols with honest majority,”
in STOC, 1987.
[149] M. Ben-Or, S. Goldwasser, and A. Wigderson, “Completeness
theorems for non-cryptographic fault-tolerant distributed computation
(extended abstract),” in STOC, 1988.
[150] D. Beaver, “Efﬁcient multiparty protocols using circuit
randomization,” in CRYPTO, 1991.
[151] Y. Ishai, E. Kushilevitz, R. Ostrovsky, and A. Sahai, “Zero-knowledge
from secure multiparty computation,” in STOC, 2007.
[152] V. Vu, S. Setty, A. J. Blumberg, and M. Walﬁsh, “A hybrid
architecture for interactive veriﬁable computation,” in IEEE S&P,
2013.
[153] J.-C. Filliˆatre and S. Conchon, “Type-safe modular hash-consing,” in
ML, 2006.
[154] A. P. Ershov, “On programming of arithmetic operations,” CACM,
vol. 1, no. 8, pp. 3–6, 1958.
Appendix A.
Full Benchmarks
In this section, we compare CirC v1.0 against
the
ZoKrates, Circom, and Pequin compilers on a full set of
benchmarks. We use the same testbed described in Section 5.1.
ZoKrates-to-R1CS. We benchmark every circuit
in the
ZoKrates standard library (v0.6.1), reporting compile time and
constraint count for CirC and the ZoKrates reference compiler
(v0.6.1). Figure 22 shows the results. Generally, CirC produces
slightly fewer constraints. For the elliptic curve module (ecc),
CirC produces many fewer constraints, but it produces slightly
more for bit-intensive hashing (sha256). In almost all cases,
the ZoKrates compiler is faster; this is probably because of
the term representation in CirC’s v1.0 implementation. Terms
are recursive Haskell GADTs, and maps from them are either
(a) hash maps on a hash that traverses the full term or (b)
tree maps on the term’s full string representation. CirC v2.0
represents terms with hash-consing [153, 154]; this yields
better performance.
2265
File
CirC
Constraints
Time (s)
ZoKrates
Constraints
Time (s)
ecc/babyjubjubParams
ecc/edwardsAdd
ecc/edwardsCompress
ecc/edwardsNegate
ecc/edwardsOnCurve
ecc/edwardsOrderCheck
ecc/edwardsScalarMult
ecc/proofOfOwnership
mimc7/mimc7R10
mimc7/mimc7R20
mimc7/mimc7R50
mimc7/mimc7R90
mimcSponge/mimcFeistel
mimcSponge/mimcSponge
pedersen/512bit
sha256/1024bitPadded
sha256/1024bit
sha256/1536bit
sha256/256bitPadded
sha256/512bitPacked
sha256/512bitPadded
sha256/512bit
sha256/shaRound
utils/256bitsDirectionHelper
signatures/verifyEddsa
casts/1024to256array
casts/bool 128 to u32 4
casts/bool 256 to u32 8
casts/u32 4 to bool 128
casts/u32 8 to bool 256
multiplexer/lookup1bit
multiplexer/lookup2bit
multiplexer/lookup3bitSigned
bool/nonStrictUnpack256
bool/pack128
bool/pack256
bool/unpack128
u32/nonStrictUnpack256
u32/pack128
u32/pack256
u32/unpack128
10
11
763
2
6
40
6394
6350
40
80
200
360
661
2632
3062
84237
57098
85791
27547
55544
55544
28405
28949
529
96765
2048
132
264
256
512
2
5
7
508
128
256
382
254
128
256
254
0.08
0.07
3.66
0.06
0.12
0.09
6.04
7.92
0.48
0.84
1.31
1.96
7.29
46.46
9.38
193.11
122.31
182.48
61.72
141.51
125.13
60.45
56.42
0.10
205.78
7.80
0.37
0.65
0.42
0.64
0.06
0.08
0.07
1.49
0.42
1.10
1.30
2.05
0.54
0.96
1.55
10
19
766
2
9
60
9994
9989
42
82
202
362
662
2643
3940
79575
56674
87345
26587
50398
48904
27470
28070
1105
99359
2048
132
264
260
520
4
6
8
511
129
257
635
263
133
265
511
0.01
0.01
0.13
0.02
0.01
0.03
0.46
0.85
0.02
0.03
0.19
0.88
11.10
89.39
1.90
18.13
8.82
16.38
3.80
10.70
8.74
3.18
2.49
0.02
22.20
0.19
0.01
0.05
0.01
0.02
0.02
0.01
0.02
0.05
0.05
0.06
0.02
0.11
0.05
0.09
0.08
Figure 22. CirC vs. the ZoKrates 0.6.1 reference compiler on the ZoKrates
standard library.
Circom-to-R1CS. We evaluate on every test circuit in the test
suite of the Circom standard library (v0.20). We omit circuits
that the Circom compiler (v0.30) could not compile (either
because the test was invalid or because our testbed did not
have enough memory).
Figure 23 shows the results. The compilers give identical
constraint counts in nearly every case. Recall (§5.1) that Cir-
com is essentially a hardware description language for R1CS,
and both compilers perform the same R1CS optimizations. The
runtime of CirC is typically better than the reference compiler,
which is written in JavaScript.
C-to-R1CS. We evaluate on all C-language benchmarks
from [11]. We get
these benchmarks from the Pequin
source distribution (https://github.com/pepper-project/pequin).
In [11],
these benchmarks are parameterized; we use the
default parameters from the source distribution.
We apply two transforms to the benchmarks before eval-
uation. First, since CirC’s C front-end does not support Pe-
quin’s (bespoke) I/O conventions for multi-dimensional input
arrays, we ﬂatten the inputs to the matrix-multiplication bench-
mark. (Note that CirC’s C front-end does support standard C-
language multi-dimensional arrays.) Second, since CirC’s C
front-end does not evaluate C constant expressions before type
checking, we evaluate constant expressions in array lengths.
Authorized licensed use limited to: Tsinghua University. Downloaded on August 07,2022 at 12:58:36 UTC from IEEE Xplore.  Restrictions apply. 