---
title:  scan operator
description: Learn how to use the scan operator to scan data, match, and build sequences based on the predicates.
ms.reviewer: alexans
ms.topic: reference
ms.date: 08/24/2023
---
# scan operator
Scans data, matches, and builds sequences based on the predicates.
Matching records are determined according to predicates defined in the operator’s steps. A predicate can depend on the state that is generated by previous steps.
The output for the matching record is determined by the input record and assignments defined in the operator's steps.
## Syntax
*T* `| scan` [ `with_match_id` `=` *MatchIdColumnName* ] [ `declare` `(` *ColumnDeclarations* `)` ] `with` `(` *StepDefinitions* `)`
### *ColumnDeclarations* syntax
*ColumnName* `:` *ColumnType*[`=` *DefaultValue* ] [`,` ... ]
### *StepDefinition* syntax
`step` *StepName* [ `output` = `all` | `last` | `none`] `:` *Condition* [ `=>` *Column* `=` *Assignment* [`,` ... ] ] `;`
[!INCLUDE [syntax-conventions-note](../../includes/syntax-conventions-note.md)]
## Parameters
| Name | Type | Required | Description |
|--|--|--|--|
|*T*| `string` | :heavy_check_mark:|The input tabular source.|
| *MatchIdColumnName* | `string` | |  The name of a column of type `long` that is appended to the output as part of the scan execution. Indicates the 0-based index of the match for the record. |
| *ColumnDeclarations* | `string` | | Declares an extension to the schema of *T*. These columns are assigned values in the steps. If not assigned, the *DefaultValue* is returned. Unless otherwise specified, *DefaultValue* is `null`.|
| *StepName* | `string` |  :heavy_check_mark: | Used to reference values in the state of scan for conditions and assignments. The step name must be unique.|
| *Condition* | `string` |  :heavy_check_mark: | An expression that evaluates to `true` or `false` that defines which records from the input match the step. A record matches the step when the condition is `true` with the step’s state or with the previous step’s state.|
| *Assignment* | `string` | | A scalar expression that is assigned to the corresponding column when a record matches a step.|
| `output` | `string` | | Controls the output logic of the step on repeated matches. `all` outputs all records matching the step, `last` outputs only the last record in a series of repeating matches for the step, and `none` doesn't output records matching the step. The default is `all`.|
## Returns
A record for each match of a record from the input to a step. The schema of the output is the schema of the source extended with the column in the `declare` clause.
## Scan logic
`scan` goes over the serialized input data, record by record, comparing each record against each step’s condition while taking into account the current state of each step.
### State
The underlying state of the `scan` operator can be thought of as a table with a row for each `step`. Each step maintains its own state with the latest values of the columns and declared variables from all of the previous steps and the current step. If relevant, it also holds the match ID for the ongoing sequence.
If a scan operator has *n* steps named *s_1*, *s_2*, ..., *s_n* then step *s_k* would have *k* records in its state corresponding to *s_1*, *s_2*, ..., *s_k*. The *StepName*.*ColumnName* format is used to reference a value in the state. For instance, `s_2.col1` would reference column `col1` that belongs to step *s_2* in the state of *s_k*. For a detailed example, see the [scan logic walkthrough](#scan-logic-walkthrough).
The state starts empty and updates whenever a scanned input record matches a step. When the state of the current step is nonempty, the step is referred to as having an *active sequence*.
### Matching logic
Each input record is evaluated against all of the steps in reverse order, from the last step to the first. When a record *r* is evaluated against some step *s_k*, the following logic is applied:
* **Check 1:** If the state of the previous step (*s_k-1*) is nonempty, and *r* meets the *Condition* of *s_k*, then a match occurs. The match leads to the following actions:
    1. The state of *s_k* is cleared.
    1. The state of *s_k-1* is promoted to become the state of *s_k*.
    1. The assignments of *s_k* are calculated and extend *r*.
    1. The extended *r* is added to the output and to the state of *s_k*.
    > [!NOTE]
    > If **Check 1** results in a match, **Check 2** is disregarded, and *r* moves on to be evaluated against *s_k-1*.
* **Check 2:** If the state of *s_k* has an active sequence or *s_k* is the first step, and *r* meets the *Condition* of *s_k*, then a match occurs. The match leads to the following actions:
    1. The assignments of *s_k* are calculated and extend *r*.
    2. The values that represent *s_k* in the state of *s_k* are replaced with the values of the extended *r*.
    1. If *s_k* is defined as `output=all`, the extended *r* is added to the output.
    1. If *s_k* is the first step, a new sequence begins and the match ID increases by `1`. This only affects the output when `with_match_id` is used.
Once the checks for *s_k* are complete, *r* moves on to be evaluated against *s_k-1*.
For a detailed example of this logic, see the [scan logic walkthrough](#scan-logic-walkthrough).
## Examples
### Cumulative sum
Calculate the cumulative sum for an input column. The result of this example is equivalent to using [row_cumsum()](row-cumsum-function.md).
> [!div class="nextstepaction"]
> Run the query
```kusto
range x from 1 to 5 step 1 
| scan declare (cumulative_x:long=0) with 
(
    step s1: true => cumulative_x = x + s1.cumulative_x;
)
```
**Output**
|x|cumulative_x|
|---|---|
|1|1|
|2|3|
|3|6|
|4|10|
|5|15|
### Cumulative sum on multiple columns with a reset condition
Calculate the cumulative sum for two input columns, reset the sum value to the current record value whenever the cumulative sum reached 10 or more.
> [!div class="nextstepaction"]
> Run the query
```kusto
range x from 1 to 5 step 1
| extend y = 2 * x
| scan declare (cumulative_x:long=0, cumulative_y:long=0) with 
(
    step s1: true => cumulative_x = iff(s1.cumulative_x >= 10, x, x + s1.cumulative_x), 
                     cumulative_y = iff(s1.cumulative_y >= 10, y, y + s1.cumulative_y);
)
```
**Output**
|x|y|cumulative_x|cumulative_y|
|---|---|---|---|
|1|2|1|2|
|2|4|3|6|
|3|6|6|12|
|4|8|10|8|
|5|10|5|18|
### Fill forward a column
Fill forward a string column. Each empty value is assigned the last seen nonempty value.
> [!div class="nextstepaction"]
> Run the query
```kusto
let Events = datatable (Ts: timespan, Event: string) [
    0m, "A",
    1m, "",
    2m, "B",
    3m, "",
    4m, "",
    6m, "C",
    8m, "",
    11m, "D",
    12m, ""
]
;
Events
| sort by Ts asc
| scan declare (Event_filled: string="") with 
(
    step s1: true => Event_filled = iff(isempty(Event), s1.Event_filled, Event);
)
```
**Output**
|Ts|Event|Event_filled|
|---|---|---|
|00:00:00|A|A|
|00:01:00||A|
|00:02:00|B|B|
|00:03:00||B|
|00:04:00||B|
|00:06:00|C|C|
|00:08:00||C|
|00:11:00|D|D|
|00:12:00||D|
### Sessions tagging
Divide the input into sessions: a session ends 30 minutes after the first event of the session, after which a new session starts. Note the use of `with_match_id` flag, which assigns a unique value for each distinct match (session) of *scan*. Also note the special use of two *steps* in this example, `inSession` has `true` as condition so it captures and outputs all the records from the input while `endSession` captures records that happen more than 30m from the `sessionStart` value for the current match. The `endSession` step has `output=none` meaning it doesn't produce output records. The `endSession` step is used to advance the state of the current match from `inSession` to `endSession`, allowing a new match (session) to begin, starting from the current record.
> [!div class="nextstepaction"]
> Run the query
```kusto
let Events = datatable (Ts: timespan, Event: string) [
    0m, "A",
    1m, "A",
    2m, "B",
    3m, "D",
    32m, "B",
    36m, "C",
    38m, "D",
    41m, "E",
    75m, "A"
]
;
Events
| sort by Ts asc
| scan with_match_id=session_id declare (sessionStart: timespan) with 
(
    step inSession: true => sessionStart = iff(isnull(inSession.sessionStart), Ts, inSession.sessionStart);
    step endSession output=none: Ts - inSession.sessionStart > 30m;
)
```
**Output**
|Ts|Event|sessionStart|session_id|
|---|---|---|---|
|00:00:00|A|00:00:00|0|
|00:01:00|A|00:00:00|0|
|00:02:00|B|00:00:00|0|
|00:03:00|D|00:00:00|0|
|00:32:00|B|00:32:00|1|
|00:36:00|C|00:32:00|1|
|00:38:00|D|00:32:00|1|
|00:41:00|E|00:32:00|1|
|01:15:00|A|01:15:00|2|
### Events between Start and Stop
Find all sequences of events between the event `Start` and the event `Stop` that occur within 5 minutes. Assign a match ID for each sequence.
> [!div class="nextstepaction"]
> Run the query
```kusto
let Events = datatable (Ts: timespan, Event: string) [
    0m, "A",
    1m, "Start",
    2m, "B",
    3m, "D",
    4m, "Stop",
    6m, "C",
    8m, "Start",
    11m, "E",
    12m, "Stop"
]
;
Events
| sort by Ts asc
| scan with_match_id=m_id with 
(
    step s1: Event == "Start";
    step s2: Event != "Start" and Event != "Stop" and Ts - s1.Ts  `Tornado` -> `Thunderstorm Wind` by `State` with custom thresholds on the times between the events (`Tornado` within `1h` and `Thunderstorm Wind` within `2h`). This example is similar to the [funnel_sequence_completion plugin](funnel-sequence-completion-plugin.md), but allows greater flexibility.
> [!div class="nextstepaction"]
> Run the query
```kusto