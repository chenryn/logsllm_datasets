Windows Process Injection in 2019 
Amit Klein, Itzik Kotler 
Safebreach Labs 
Introduction 
Process injection in Windows appears to be a well-researched topic, with many techniques now known 
and implemented to inject from one process to the other. Process injection is used by malware to gain 
more stealth (e.g. run malicious logic in a legitimate process) and to bypass security products (e.g. AV, 
DLP and personal firewall solutions) by injecting code that performs sensitive operations (e.g. network 
access) to a process which is privileged to do so. 
In late 2018, we decided to take a closer look at process injection in Windows. Part of our research 
effort was to understand the landscape, with a focus on present-day platforms (Windows 10 x64 1803+, 
64-bit processes), and there we came across several problems: 
• 
We could not find a single location with a full list of all injection techniques. There are some 
texts that review multiple injection techniques (hat tip to Ashkan Hosseini, EndGame for a nice 
collection https://www.endgame.com/blog/technical-blog/ten-process-injection-techniques-
technical-survey-common-and-trending-process and to Csaba Fitzl AKA “TheEvilBit” for some 
implementations https://github.com/theevilbit/injection), but they’re all very far from capturing 
all (or almost all) techniques.  
• 
The texts that describe injection techniques typically lump together “true injection techniques” 
(the object of this paper) with other related topics, such as process hollowing and stealthy 
process spawning. In this paper, we’re interested only in injection from one 64-bit process 
(medium integrity) to another, already running 64-bit process (medium integrity). 
• 
The texts often try to present a complete injection process, therefore mixing writing and 
execution techniques, when only one of them is novel. 
• 
Many texts target 32-bit processes, and it was not clear whether they apply to 64-bit processes.  
• 
Many texts target pre-Windows 10 platforms, and it is not clear whether they apply to Windows 
10, with its implementation changes and with its new security features. 
• 
Some attacks require privilege elevation, and as such are not interesting.  
• 
The texts that describe process injection lack analysis – discussion of requirements and 
limitations, impact of Windows 10 security features, etc. 
• 
The texts usually provide a PoC, but it’s “too well written” – meaning, the PoC checks for return 
code, handles errors, handles 32-bit and 64-bit processes, edge conditions, etc. Also, the PoC 
implements an end-to-end injection (not just the novel write/execute technique). As such, the 
PoC becomes pretty big and difficult to follow.  
In this paper, we address all the above issues. We provide the first comprehensive catalogue of true 
process injection techniques in Windows. We categorize the individual techniques into write primitives 
and execution methods. We test the techniques against 64-bit processes (medium integrity) running on 
Windows 10 x64. We test them with and without process protection techniques (CFG, CIG), we analyze 
each technique and explain its requirements and limitations. Finally, we provide stripped down, 
minimalistic PoC code that works, and at the same time is short enough to clearly show the technique at 
hand.  
We tried to be as comprehensive as possible, i.e. really cover all different techniques. But of course, this 
is a live document, as new techniques will surely be discovered, and as we probably missed a few. We 
also tried to give credit to the original inventor of the technique, if we could find one. Again, this is 
probably imperfect, and readers are encouraged to send us corrections. 
Finally, we get back to our original goal, and describe a new injection technique that inherently bypasses 
CFG. 
Windows Process injection in 2019 
Classes of Injection Techniques 
We classify injection techniques as follows: 
1. Process spawning – these methods create a process instance of a legitimate executable binary, 
and typically modify it before the process starts running. Process spawning is very “noisy” and as 
such these techniques are suspicious, and not stealthy. 
2. Injecting during process initialization – these methods cause processes that are beginning to 
run, to load their code (e.g. AppInit DLLs). Typically these techniques require UAC elevation (due 
to writing to privileged registry keys and/or privileged folders). Additionally, such methods are 
typically mitigated by the Extension Point Disable Policy. 
3. Injecting into running processes (“true process injection”) – these are the most interesting 
techniques, which are the focus of this paper. 
Injecting into running processes typically involves two sub-techniques: preparing memory in the target 
process (which contains the payload – the logic to be run, either as native code, or as ROP chain stack), 
and executing logic in the target process. 
The present time landscape: Windows 10 64-bit (x64), and new security features 
In recent years, Windows 10 (and the x64 hardware platform) gained a lot of popularity. This change of 
landscape has a great impact on process injection techniques: 
- 
x64 (vs. x86): In Windows x86, all calling conventions except fastcall place all arguments on the 
stack. In x64, the calling convention places the first 4 arguments in registers (RCX, RDX, R8 and 
R9), and the remaining arguments on stack. This makes it harder to design a payload for x64, 
since such payload must control several registers in order to invoke a function. In x86, a payload 
just needs to correctly arrange the stack in order for a function invocation to succeed. 
Theoretically this could have been elegantly handled by the single byte instruction POPA 
(opcode 0x61), which pops all data registers from stack, however this instruction is simply not 
available in x64 mode.  
- 
New security features: Windows 10 introduced several new process exploitation mitigation 
features, which can be controlled via the SetProcessMitigationPolicy API (from the target 
process). These are: 
o CFG (Control Flow Guard): this is Microsoft’s implementation of the CFI (Control Flow 
Integrity) concept for Windows (8.1, 10). The compiler precedes each indirect CALL/JMP 
(CALL/JMP reg) with a call to _guard_check_icall to check the validity of the call target. 
Validity is also provided by the compiler as a list of 16-byte aligned valid targets per 
module (loaded to memory as a “bitmap” for fast access). Both caller module and callee 
module must support CFG in order for it to be in effect. 
o Dynamic Code prevention: this feature prevents the calling process from calling 
VirtualAlloc with PAGE_EXECUTE_*, MapViewOfFile with FILE_MAP_EXECUTE option, 
VirtualProtect with PAGE_EXECUTE_* etc. and reconfiguring the CFG bitmap via 
SetProcessValidCallTargets (from 
https://www.troopers.de/media/filer_public/f6/07/f6076037-85e0-42b7-9a51-
507986edafce/the_joy_of_sandbox_mitigations_export.pdf). Note that for e.g. 
VirtualProtectEx, the policy enforced is the policy of the caller process. 
o Binary Signature Policy (CIG – Code Integrity Guard): only allow modules signed by 
Microsoft/Microsoft Store/WHQL to be loaded into the process memory. A weaker 
control is Image Load Policy, which can prevent loading modules from remote locations 
or files with low integrity label; This is enforced at the calling process. 
o Extension Point Disable Policy: disable “extensions” that load DLLs into the process 
space – AppInilt DLLs, Winsock LSP, Global Windows Hooks, IMEs (from 
https://theryuu.github.io/ifeo-mitigationoptions.txt).  
It should be noted that explorer.exe, the classic injection target, as well as several other native 
Windows processes/applications (e.g. Edge’s broker processes) are protected with CFG, and the 
Edge broker processes are protected almost to the maximum possible level with the above 
techniques. 
Defining our scope 
Per the above, our interest is in true process injection techniques for Windows 10 x64. Specifically: 
• 
Windows 10 x64 at recent build (1803/1809/1903) 
• 
All processes (injector/malware, target) are 64-bit 
• 
All processes are medium integrity 
• 
Target process is already running (i.e. “true process injection” is needed) 
• 
No privilege elevation required (this rules out AppInit_Dlls, AppCertDlls and shims, as the former 
two require writing to privileged registry keys - HKLM\Software\Microsoft and HKLM\System 
respectively, and the latter one requires UAC to run sbdinst.exe). Same for AddPrintProcessor, 
AddPrinterDriver and AddMonitor, all of which require the DLL to reside under 
C:\Windows\System32. 
• 
Evaluation is done against fully protected process (CFG, CIG, etc.) or vanilla process (where 
applicable) 
Evaluating Process injection techniques  
Bypassing Windows protection mechanisms 
Microsoft provides a standard API (SetProcessValidCallTargets) for “whitelisting” (from CFG perspective) 
an arbitrary address in the target process. Tal Liberman from EnSilo described its internal 
implementation as a call to ntdll!NtSetInformationVirtualMemory with VmInformationClass= 
VmCfgCallTargetInformation (https://blog.ensilo.com/documenting-the-undocumented-adding-cfg-
exceptions).  
HANDLE p = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_OPERATION, FALSE, 
process_id); 
MEMORY_BASIC_INFORMATION meminfo; 
VirtualQueryEx(p, target, &meminfo, sizeof(meminfo)); 
CFG_CALL_TARGET_INFO cfg; 
cfg.Offset = ((DWORD64)target) - (DWORD64)meminfo.AllocationBase; 
cfg.Flags = CFG_CALL_TARGET_VALID; 
SetProcessValidCallTargets(p, meminfo.AllocationBase, meminfo.RegionSize, 1, 
&cfg); 
We found a simple way to deactivate all other Windows protections (specifically CFG cannot be 
deactivated in this manner) for Windows 10 version 1803. Microsoft provides a standard API 
(SetProcessMitigationPolicy) for turning on/off these features in the process itself. This function needs 
to be run from the target process and provided with 3 arguments – for example, 
ProcessDynamicCodePolicy, a pointer to an array of 
sizeof(PROCESS_MITIGATION_DYNAMIC_CODE_POLICY) zeros, and the size of the said array – which is 
sizeof(PROCESS_MITIGATION_DYNAMIC_CODE_POLICY). Finding an array of zeros is trivial, e.g. the load 
image address of ntdll.dll + 0x20. Running a target function with 3 arguments is possible via invoking 
ntdll!NtQueueApcThread. 
HANDLE th=OpenThread(THREAD_SET_CONTEXT, FALSE, thread_id); 
ntdll!NtQueueApcThread(th, SetProcessMitigationPolicy, 
(void*)ProcessDynamicCodePolicy, ((char*)GetModuleHandleA("ntdll")) + 0x20, 
sizeof(PROCESS_MITIGATION_DYNAMIC_CODE_POLICY)); 
NOTE: this technique stopped working at Windows 10 version 1809 – once protection is set (by 
SetProcessMitigationPolicy), it cannot be unset – SetProcessMitigationPolicy returns status 
ERROR_ACCESS_DENIED. 
Given that CFG can be turned off by the injecting process, why do we need to analyze for CFG? We 
anticipate that the mere action of disabling (or attempt to) of a security feature by a process may be 
monitored and possibly even prevented by security products. As such, in the future, injecting processes 
may prefer to stay away from this exact functionality. Also, at some point in the future, Microsoft may 
disable or restrict CFG manipulation (just like they did with SetProcessMitigationPolicy). 
Steps in true process injection 
Typically, process injection follows these 3 steps: 
• 
Memory allocation 
• 
Memory writing (using a memory write primitive) 
• 
Execution 
Sometimes the allocation and memory writing are technically carried out in the same step, using the 
same API. Sometimes the memory allocation step is implicit, i.e. the memory is pre-allocated. 
Sometimes it is impossible to separate memory writing from execution.  
Oftentimes, memory allocation and writing is done multiple times before the execution step. 
Evaluation Criteria 
We evaluate memory write primitives based on: 
• 
Prerequisites 
• 
Limitations 
• 
CFG/CIG-readiness 
• 
Controlled vs. uncontrolled write address 
• 
Stability 
We evaluated execution methods based on: 
• 
Prerequisites 
• 
Limitations 
• 
CFG/CIG-readiness 
• 
Control over registers 
• 
Cleanup required 
A note about memory allocation 
In general, memory writing primitives require the target memory to be allocated. This can happen in 
two ways:  
1. The injector process can invoke VirtualAllocEx (or NtAllocateVirtualMemory) to allocate new 
memory in the target process. In such a case, the injector can request this memory to be 
readable and/or writable and/or executable. Note that “the default behavior for executable 
pages allocated is to be marked valid call targets for CFG” (https://docs.microsoft.com/en-
us/windows/desktop/Memory/memory-protection-constants). 
2. The injector process can designate an existing (allocated) memory within the target process, for 
overwriting. There are several options:  
a. Stack – either the stack in use, or area beyond the TOS. The stack is RW. Writing to the 
stack requires addressing several considerations: (i) when writing beyond TOS, it should 
be kept in mind that this area may be overwritten by subsequent calls to inner functions 
or system functions; (ii) when writing before TOS, it should be kept in mind that this 
overwrites existing stack used  
b. Image – the data sections of some DLLs contain “spare” allocation beyond the actual 
need of the static variables mapped to there. This “cave” is RW, and initialized with 
zeros. 
c. Heap – any data object allocated on the heap, whose address is known to the injector 
process, can be theoretically used (though the memory area may be modified/recycled 
as the object is manipulated or destroyed). Again – RW. 
VirtualProtectEx can be used to assign different privileges (e.g. execution) to a memory region. 
Note that “the default behavior for VirtualProtect [and VirtualProtectEx] protection change to 
executable is to mark all locations as valid call targets for CFG” 
(https://docs.microsoft.com/en-us/windows/desktop/Memory/memory-protection-constants).  
A notable exception is ntdll!NtMapViewOfSection which can be invoked in such way that it allocates 
memory for the section in the target process. 
A survey and Analysis of injection techniques 
Notation: 
• 
Standard Microsoft Visual Studio coloring scheme 
• 
Bold+italics – user parameters. Specifically: 
o payload – an array of bytes in the injecting process, with the data to copy to the target 
process 
o 
sizeof(payload) – the size (in bytes) of the payload array 
o target_payload – the address, in the injected process, into which the payload is injected 
o target_execution – the address, in the injected process, into which control should be 
transferred (can be target_payload if it is executable, or a ROP gadget e.g. stack pivot, 
pointing RSP to target_payload) 
o process_id / thread_id – the target process ID / thread ID to inject to 
• 
Bold (ntdll!NtXXX or ntdll!ZwXXX) – dynamically linked functions (NtXXX/ZwXXX), a shorthand 
for fptr=GetProcAddress(GetModuleHandleA(“ntdll”)),function_name); (*fptr)(arguments); 
• 
Yellow background – cleanup code 
The techniques (in chronological order, where known): 
1. Classic WriteProcessMemory write primitive (prehistoric) 
a. Make sure the target address is allocated (e.g. with VirtualAllocEx) 
b. Write data or raw code to memory using WriteProcessMemory 
Code: 
HANDLE h = OpenProcess(PROCESS_VM_WRITE | PROCESS_VM_OPERATION, FALSE, 
process_id); 
LPVOID target_payload=VirtualAllocEx(h,NULL,sizeof(payload), MEM_COMMIT | 
MEM_RESERVE, PAGE_EXECUTE_READWRITE);  // Or any other memory allocation technique 
WriteProcessMemory(h, target_payload, payload, sizeof(payload), NULL); 
Evaluation: 
o Prerequisites: none 
o Limitations: none 
o CFG/CIG-readiness: not affected 
o Controlled vs. uncontrolled write address: address is fully controlled 
o Stability: stable 
2. Classic DLL injection execution method (prehistoric) 
a. Write a malicious 64-bit DLL to disk, DllMain should contain a bootstrap payload (not 
shown). 
b. Write memory (DLL path string) using any write primitive, e.g. 
VirtualAllocEx(…,PAGE_READWRITE)+WriteProcessMemory (not shown) 
c. Load (and execute) the DLL using 
CreateRemoteThread(…,LoadLibraryA,DLL_path_string)  (internal functions 
NtCreateThreadEx and RtlCreateUserThread can also be used) 
Variant 1: use QueueUserAPC instead of CreateRemoteThread (thread must be in alertable 
state) 
Variant 2: Instead of writing the DLL path to the target process memory, find a NUL-terminated 
string that looks like a valid path in one of the system DLLs, write the DLL to a file in that name, 
and point the LoadLibrary argument to the string. For example, ntdll.dll contains the NUL-
terminated string “\ntdll\ldrsnap.c”, thus placing the DLL in file C:\ntdll\ldrsnap.c (assuming 
standard installation of Windows to drive C:) should do the trick. 
Code: 
HANDLE h = OpenProcess(PROCESS_CREATE_THREAD, FALSE, process_id); 
CreateRemoteThread(h, NULL, 0, (LPTHREAD_START_ROUTINE)LoadLibraryA, 
target_DLL_path, 0, NULL); 
Evaluation: 
o Prerequisites: malicious DLL written to disk, memory write primitive, thread in alertable 
state (only when using APC) 
o Limitations: DllMain code runs in with loader-lock locked, hence some restrictions apply 
(https://docs.microsoft.com/en-us/windows/desktop/dlls/dynamic-link-library-best-
practices) 
o CFG/CIG-readiness: CIG prevents loading on non-Microsoft signed DLL. An attempt to do 
so results in error 0xC0000428 (STATUS_INVALID_IMAGE_HASH – “The hash for image 
%hs cannot be found in the system catalogs. The image is likely corrupt or the victim of 
tampering.” - https://msdn.microsoft.com/en-us/library/cc704588.aspx)  
o Control over registers: none (but typically not a problem due to linking) 
o Cleanup required: none 
3. CreateRemoteThread execution method (prehistoric) 
a. Write raw code to memory using any write primitive. 
b. Execute the code using CreateRemoteThread (requires CFG-valid target) 
Code: 
HANDLE h = OpenProcess(PROCESS_CREATE_THREAD, FALSE, process_id); 
CreateRemoteThread(h, NULL, 0, (LPTHREAD_START_ROUTINE) target_execution, RCX, 0, 
NULL); 
Evaluation: 
o Prerequisites: target address must be RX at minimum. 
o Limitations: none 
o CFG/CIG-readiness: target entry point must be CFG-valid. 
o Control over registers: RCX 
o Cleanup required: none 
4. APC execution method (prehistoric) 
Thread must be in alertable state (https://docs.microsoft.com/en-
us/windows/desktop/fileio/alertable-i-o), i.e. in one of 5 functions: SleepEx, 
WaitForSingleObjectEx, WaitForMultipleObjectsEx, SignalObjectAndWait, 
MsgWaitForMultipleObjectsEx (probably RealMsgWaitForMultipleObjectsEx). 
a. Write raw code to memory using any write primitive. 
b. Execute the code using QueueUserAPC/NtQueueApcThread (requires CFG-allowed 
target) 
Code: 
HANDLE h = OpenThread(THREAD_SET_CONTEXT, FALSE, thread_id); 
QueueUserAPC((LPTHREAD_START_ROUTINE)target_execution, h, RCX); 
or 
ntdll!NtQueueApcThread(h, (LPTHREAD_START_ROUTINE)target_execution, RCX, RDX, R8); 
Evaluation: 
o Prerequisites: Target address must be RX (at least). Thread must be in alertable state 
o Limitations: none 
o CFG/CIG-readiness: target entry point must be CFG-valid. 
o Control over registers: RCX (also RDX and R8 if using NtQueueApcThread) 
o Cleanup required: none. 
5. Thread Execution Hijacking “Suspend-Inject-Resume” execution method (prehistoric?) 
a. Write code/data to memory using any write primitive e.g. 
VirtualAllocEx(…,PAGE_EXECUTE_READWRITE)+WriteProcessMemory (not shown). 
b. Execute the code using SetThreadContext (the thread needs to be suspended and 
resumed) – set RIP to point at the code written in step (a) or to a ROP gadget, and 
maybe RSP to point at a new stack. 
Variant: use NtQueueApcThread(thread,SetThreadContext,-2 /* GetCurrentThread pseudo 
handle */,context,NULL) instead of SetThreadContext (thread must be in alertable state) 
Code for executable memory: 
HANDLE t = OpenThread(THREAD_SET_CONTEXT, FALSE, thread_id); 
SuspendThread(t); 
CONTEXT ctx; 
ctx.ContextFlags = CONTEXT_CONTROL; 
ctx.Rip = (DWORD64)target_execution; 
SetThreadContext(t, &ctx); 
ResumeThread(t); 
Evaluation: 
o Prerequisites: execution target must be RX (at least) 
o Limitations: none 
o CFG/CIG-readiness: RSP (if set) must be within stack limits (this is enforced by 
SetThreadContext) 
o Control over registers: see “SetThreadContext anomaly” 
o Cleanup required: yes; the original thread needs to resume execution and for that, its 
registers and stack must be restored. 
The SetThreadContext anomaly: for some processes, the volatile registers (RAX, RCX, RDX, R8-
R11) are set by SetThreadContext, for other processes (e.g. Explorer, Edge) they are ignored. 
Best not rely on SetThreadContext to set those registers. Open research question: why does 
SetThreadContext behave differently for some processes? 
Since there’s no CFG check for SetThreadContext, we can also use ROP gadgets with a non-
executable arbitrary memory (stack). We use a “beyond the TOS” memory cell to store the new 
stack address (so as not to modify the original stack).  
Code for non-executable memory (ROP-chain): 
HANDLE t = OpenThread(THREAD_GET_CONTEXT | THREAD_SET_CONTEXT, FALSE, thread_id); 
SuspendThread(t); 
CONTEXT ctx; 
ctx.Rip = GADGET_pivot; // pop rsp; ret 
ctx.Rsp -= 8; 
WriteProcessMemory(p, (LPVOID)ctx.Rsp, &new_stack_address, 8, NULL); // Or any 
other memory write technique  
//make sure stack is 16-byte aligned before the return address; make sure there’s 