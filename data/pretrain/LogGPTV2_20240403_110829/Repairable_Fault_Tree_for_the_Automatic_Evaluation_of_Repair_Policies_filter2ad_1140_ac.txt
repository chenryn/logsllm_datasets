iting every CSM in the list and removing from the list
the roots of the CSMs contained in the currently con-
sidered CSM. At this point any minimal SSM and any
maximal CSM is indicated by its root contained in the spe-
ciﬁc list; they are solved in the proper way and replaced by
a basic event, while their roots are removed from the spe-
ciﬁc list. Now, the SSM list contains all the remaining
modules to be reclassiﬁed and eventually solved in isola-
tion; the whole process is repeated until the SSM list is
empty, when the whole RFT has been solved.
4.3. RFT models solution process
The classiﬁcation of the RFT modules into CSMs and
SSMs requires that two different solution techniques are ap-
plied to a RFT models: combinatorial for CSM and state
space based for SSM. The OsMoSys [15] framework sup-
ports multi-solution processes by means of an adaptive
programmable GUI and an extensible solution architec-
ture. The RFT model we obtain is automatically trans-
lated by means of a post processor connected to the Os-
MoSys framework,
low-level model
based on two formalisms, FT and GSPN, to run the pre-
sented solution process. In Fig. 2 the steps needed to solve
a RFT are depicted. The RFT is drawn by means of the
in an equivalent
Proceedings of the 2004 International Conference on Dependable Systems and Networks (DSN’04) 
0-7695-2052-9/04 $ 20.00 © 2004 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 11:50:14 UTC from IEEE Xplore.  Restrictions apply. 
5. Repair boxes and their GSPN semantics
In this section we propose some possible semantics for
the repair boxes, which correspond to possible RB types in-
troduced in the previous sections. We ﬁrst discuss possi-
ble choices and general assumptions for RB semantics, and
highlight which choices and assumptions have been consid-
ered in our framework, then we show how the considered
RB types semantics can be expressed by means of a para-
metric GSPN model. The GSPN model semantics is also
used for the automatic GSPN generation and related state
space analysis of SSM.
5.1. RepairBox Types
Each repair action the designer may want to model in
the RFT formalism must have a trigger condition and a re-
pair policy. The trigger condition can be (a) a failure event
included in the FT or (b) a condition expressed as a func-
tion of a set of events included in the FT, but not corre-
sponding to any event present in the FT (this can be use-
ful to model preventive maintenance). In our framework we
only allow option (a): the trigger condition coincides with
the event connected to the repair box.
The repair policy allows to specify (a) which basic compo-
nents have to be repaired upon a given repair action has been
triggered, (b) possibly the repair order of such components,
(c) the number of available repair facilities. In our frame-
work the basic components to be repaired correspond to the
basic event connected to the RB (the so called basic cov-
erage set of the RB). Repair time can be speciﬁed in detail,
that is separately for each basic component, or in a more ab-
stract way as a single global repair time: in the latter case the
number of available repair facilities need not be speciﬁed as
a separate parameter, but of course it must be taken into ac-
count when deﬁning the global repair time. The global re-
pair time might be state dependent, i.e. it might depend on
the actual set of basic events to be repaired when the re-
pair action is triggered.
Another important aspect is the deﬁnition of when a repair
action should be considered as completed: (a) it may be
completed only when all basic components have been re-
paired, or (b) it may be completed as soon as the trigger
condition is no more true (minimal set of repair steps that
allow to restore the subsystem functionality): in our frame-
work we only consider option (a). A relevant aspect in the
speciﬁcation of the RB semantics which is orthogonal with
respect to the chosen repair policy, is the inﬂuence of the re-
pair action on the basic event failure processes: (a) they may
be stopped until repair ends or (b) they may continue during
the repair action so that new failures may occur while the re-
pair is taking place. If option (b) is chosen, and at the same
time only a global repair time is speciﬁed, this time may
Figure 2. The RFT solution steps in OsMoSys
DrawNET++ GUI[14], that generates a XML 2 represen-
tation of the model. This XML ﬁle is passed to the RFT
Hierarchical Post-processor whose role consists of: de-
tecting and classifying modules; generating the XML
code for each module; executing the proper solving pro-
cedure for each module; gathering the partial results;
passing to DrawNET++ the ﬁnal result for visualiza-
tion.
The analysis of CSM is performed by means of the
SHARPE [11] package; in order to represent the mod-
ule in the SHARPE formalism, we implemented the
FT2SHARPE translator that translates the XML represen-
tation of the module in the SHARPE formalism.
The solving procedure for SSM is more compli-
cated; a SSM requires state space analysis and contains
both the failure and repair events; for a SSM, two GSPN
are automatically generated: one to represent
the fail-
ure events (by means of the FT2PN translator) and an-
other one for each RB in the module (by means of the
RFT2PN translator) to represent the repair events asso-
ciated with that RB. The appendix shows an example of
model representing the failure events. All the nets are gen-
erated in the input format required by the GreatSPN
tool [5] and are then composed to obtain a unique com-
prehensive model of the whole SSM by means of the
Algebra tool [5]. The resulting Petri net is solved by us-
ing one of the GreatSPN tool solution modules. Great-
SPN has been chosen as GSPN solver because it
is
able to solve SWN too; the RB formalism may be ex-
tended to PFT, using SWN instead of GSPN to solve SSMs.
In any case, the OsMoSys framework is ﬂexible and exten-
sible: it has been designed in order to be able to use differ-
ent solvers. For example, in this case, Markov chains could
be directly used instead of GSPN and a different analy-
sis tool could be adopted instead of GreatSPN.
2
eXtended Markup Language
Proceedings of the 2004 International Conference on Dependable Systems and Networks (DSN’04) 
0-7695-2052-9/04 $ 20.00 © 2004 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 11:50:14 UTC from IEEE Xplore.  Restrictions apply. 
need to be adjusted as the failed basic event set changes dur-
ing repair.
5.2. GSPN semantics of RepairBox Types
According to the RFT formal deﬁnition of Section 3,
RBs have an associated type, deﬁning a repair policy. De-
pending on the type, the RB speciﬁcation may include a set
of repair policy parameters and a set of repair rates which
depend on its basic coverage set. The GSPN model repre-
senting the semantics of a given RB type can be divided
into three sections: the ﬁrst one, called General Policy Sec-
tion (GPS), has a ﬁxed structure, representing a part of
the repair action which is common to all basic events in-
volved in the action, and which may depend on the RB re-
pair policy parameters; the second one, called Special
Policy Section (SPS), comprises a set of similar but dis-
tinct blocks for each basic event in the basic coverage set
of RB and represents the repair policy aspects that con-
cern speciﬁcally each basic event:
this section must
thus be instantiated following a given template, accord-
ing to the number of basic events in the coverage set, and to
the basic event repair rates (if the policy requires to spec-
ify them). The third section, called Module Flush-out Sec-
tion (MFS) depends on the structure of the module and
implements reset process for all non-basic events af-
fected by the repair; this section may also contain a set of
inhibitor arcs to prevent further failures during repair. No-
tice that in the actual implementation of this section all
the events in the coverage set are cleared, even if they de-
pend or have inﬂuence on some events that are in the mod-
ule but not involved in the repair process. This approach is
not a limitation because if a fault is still present in the mod-
ule after repair due to non repairable basic events, it will
be propagated again automatically by the submodel repre-
senting the fault tree logic. This structure is very ﬂexible
and allows to represent a variety of policies correspond-
ing to the choices outlined in Subsection 5.1. Obviously,
one of the sections can be logically absent to represent poli-
cies that only have a common behaviour for all basic
events or no common behaviour. Rather complex poli-
cies can be described by including rich GPS/MFS fea-
tures such as (for example): prevention of additional
failures in the subsystem while it is under repair; the possi-
bility of letting the repaired subsystem come up and work
as soon as enough basic event have been repaired, accord-
ing to Minimal Cut Set (MCS) analysis; imposing a re-
pair order on the SPS; repair interruption as soon as the
minimal number of components that can make the sub-
system working has been repaired. Moreover, a repair
action can be implemented using a set of repair facil-
ities which can be ﬁnite or inﬁnite. In the rest of this
section, we deﬁne and show the translation of three com-
monly used repair policies assuming failure of the sub-
system to be repaired as trigger condition, repairing all
basic events in the coverage set of the RB, with an in-
ﬁnite or ﬁnite number of repair facilities inﬂuencing
SPS behaviour and with a unique or differentiated re-
pair time.
The GSPN models implementing the considered RB types
follows the three sections structure and all GPS, MFS and
SPS are automatically generated by taking into account the
structure of the FT, the arcs connecting it to the RB, param-
eters and repair rates. For each RB type we show a GSPN
model template including the GPS section and a para-
metric version of the SPS and MFS where replicated
subnets appear only once. To highlight the three sec-
tions, each of them is included into a box labelled with
the name of the section and interface places and transi-
tions (i.e. those places and transitions that must be eventu-
ally glued with the fault propagation GSPN model in or-
der to obtain the complete GSPN model of a SSM)
are shadowed. For the sake of space the GSPN formal-
ism is not introduced in the paper, the reader may re-
fer to [12]. The ﬁrst policy we present is a simple Global
Repair Time (GRT) policy: only one parameter, repre-
senting the global time needed to repair the whole set of
basic events connected with the RB, is given; when the re-
pair time elapses, then all basic events connected with
the RB are immediately repaired. This policy is de-
scribed in Fig. 3. The subsystem repair activity is triggered
by the failure event of the subsystem itself (immedi-
ate transition StartRep and place RepSub). A time elapses
representing the global repair time (timed transition Time-
ToRepSub). Then the token in place RemoveFailure
causes all
the non basic event failures in the cover-
age set of the subsystem and all the basic event pointed by
the repair box to be cleared. Also the non basic event fail-
ures on the path from the subsystem failure event
to
the top event of the module including the repairable sub-
tree must be cleared. All the cleared non basic failure events
that are still true are automatically reconstructed by the
GSPN representing the Fault Tree logic. In GSPN immedi-
ate transitions (ﬁring in zero time, and represented as black
bars in the depicted models) can be assigned different pri-
orities: observe that the (cid:0) (cid:2)(cid:3) (cid:2)(cid:5)(cid:2) transitions have prior-
ity (cid:8)(cid:0) (cid:2)(cid:3) (cid:2)(cid:5)(cid:2) greater than (cid:8)(cid:9)(cid:10)(cid:11)(cid:2), the priority
of the immediate transition representing the end of a re-
pair action. Both (cid:8)(cid:0) (cid:2)(cid:3) (cid:2)(cid:5)(cid:2) and (cid:8)(cid:9)(cid:10)(cid:11)(cid:2) are
greater than all immediate transitions of the GSPN rep-
resenting the FT logic, so that the clear action is atomic
w.r.t.
the transitions implementing the fault propaga-
tion logic. In Fig. 3, the MFS square is divided into two
parts: in general, a part is related to events in the mod-
ule that are in the coverage set of the RB, and is always
present. The other is related to other events in the mod-
Proceedings of the 2004 International Conference on Dependable Systems and Networks (DSN’04) 
0-7695-2052-9/04 $ 20.00 © 2004 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 11:50:14 UTC from IEEE Xplore.  Restrictions apply. 
Figure 3. RB Structure for GRT policy
Figure 5. RB Structure for SRT-F policy and 1
facility
Figure 4. RB Structure for SRT-I policy
ule, and is only present if the module root does not coin-
cide with the trigger event of the repair box.