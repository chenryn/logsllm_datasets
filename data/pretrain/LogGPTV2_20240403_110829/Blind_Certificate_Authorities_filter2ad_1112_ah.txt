fragment within which the proxy will inject its private
message M∗
. For simplicity and ease of exposition, we
assume that the blocks of the proxy and the client are
multiplicatives of the block size, 128 bits.
t = (M1, . . . , M(cid:2)) be the messages of the client, M s
The encryption of the AES-GCM works as follows.
Let K be the key that the client and server shared. Let
M p
t =
(M(cid:2)+k+1, . . . , Mm), and let M∗ = (M(cid:2)+1, . . . , M(cid:2)+k)
be the messages of the proxy. The secure channel injection
protocol is as follows:
(1) The client chooses a random IV of 96 bits.
(2) Call 2P-CTR where the client
t , the key K, while the proxy inputs M∗
inputs IV and
. Let
t , M 2
M p
(cid:18)(cid:17)(cid:20)(cid:17)
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:40:08 UTC from IEEE Xplore.  Restrictions apply. 
(C1, . . . , Cq) and (Cq+r+1, . . . , Ct) be the output of
the client, and let (Cq+1, . . . , Cq+r) be the output of
the proxy.
(3) Let A be the data that is being authenticated but not
encrypted, where |A|= u is of size ≤ 128 (u = 104 in
TLS 1.2). Let A(cid:3) = A||0128−u. The parties engage
in 2P-GMAC where the client inputs IV, K, A(cid:3)
,
(C1, . . . , Cq) and (Cq+r+1, . . . , Ct, len(A)||len(C))
and the proxy inputs (Cq+1, . . . , Cq+r). The proxy
receives as output a tag T .
(4) The client sends the proxy the value IV and
all ciphertexts. The proxy sends to the server
IV, (C1, . . . , Ct) and the tag T .
We discuss the security of this protocol in the full
version of this paper.
Theorem 8. Modeling AES as an ideal cipher, the SCI-
TLS protocol is a secure channel injection protocol for
TLS with AES-GCM mode (i.e., satisﬁes Deﬁnition 2 with
respect to Functionality 6).
C. Security Proofs for our SCI-TLS Protocols
We follow the standard deﬁnition of secure computa-
tion protocols in the presence of a malicious adversary
in the stand alone settings, as well as hybrid models, and
refer to [13, 28] to the formal deﬁnition.
Modeling f and AES. In the case of CBC with HMAC,
We model f as a random oracle and AES as an ideal
cipher. In the case of AES-GCM, there is no function
f, but we still model AES as ideal cipher. We prove the
security of the protocols in which all parties have access
to the same oracles f : {0, 1}v × {0, 1}d → {0, 1}v,
{0, 1}d × {0, 1}n → {0, 1}n and
AES
{0, 1}d × {0, 1}n → {0, 1}n, where
AES−1
for every key K ∈ {0, 1}d and every message
M ∈ {0, 1}n it holds that AES(K, AES−1(K, M )) =
AES−1(K, AES−1(K, M )) = M. The functions
f, AES, AES−1 are chosen uniformly at random in the
respective domain in the initial phase of the execution.
We assume that the distinguisher (between the ideal and
the real) does not receive access to the oracles, and its
knowledge about the oracles is limited to the queries that
the adversary A made during the execution.
:
:
1) Security of SCI-TLS with CBC and HMAC
We are now ready to the security proof of the SCI-TLS
protocol. We ﬁrst prove the protocol in the FAES-hybrid
model and in the aforementioned random oracle (or ideal
cipher model). In fact, we will show that the protocol is
statistically-secure in this hybrid model. We then replace
the f-random oracle with SHA256 and AES with an AES
implementation, and derive security in FAES heuristically
according to the random oracle methodology [4]. We then
derive security in the plain model by replacing the FAES
functionality with the instantiated AES function, with a
general-purpose secure computation protocol computing
this functionality. Security is concluded due to sequential
composition [13, 28]. We prove:
Theorem 9 (Theorem 5, restated). The SCI-TLS protocol
is a secure channel injection protocol for TLS with AES-
CBC and HMAC-SHA-256 (i.e., satisﬁes Deﬁnition 2),
assuming that f is a random oracle and AES is an ideal
cipher.
t |, |M s
We prove the Theorem with respect to the adjusted
injection functionality (i.e., Functionality 6), but in which
the trusted party always sets Δ = 0, i.e., the client cannot
“shift” the output of the proxy.
Proof Sketch. For simplicity, we ﬁrst focus the case
where the message template is such that |M∗|≥ 2n.
Moreover, for simplicity we ignore for now the SQN and
HDR and alignment of the messages of the MAC and the
t | and
AES, and just assume that all messages |M p
|M∗| are multiples of d and n. In the full paper we show
how to adjust the proof for the other cases as well. We
prove now the case of corrupted client in full, and sketch
the proof for the case of a corrupted proxy.
Corrupted client. This case is essentially the “injection
secrecy”, that is, the client cannot learn M∗
during the
protocol interaction. Formally, we show that this is the
case by constructing a simulator that does not know M∗
,
but is able to simulate the view of the client, which
consists of the messages computed by the proxy and the
server, and extracting its input.
For simplicity, we describe the simulator S as it re-
ceives an access to some random instance of the random
oracle f, AES, AES−1, and note that the simulator could
have simulated these queries on its own.
The simulator S. The simulator S works as follows:
(1) It invokes the adversary A on an auxiliary input z.
Throughout the execution, S answers the queries of
A using its own oracles f, AES, AES−1, and it just
forwards these queries.
(2) S simulates the TLS handshake protocol as an honest
(3) The simulator chooses a message M∗
server, and thus learns the keys Kaes, Khmac.
0 uniformly at
random. It simulated an honest proxy interacting with
the client in 2P-HMAC and 2P-CBC with the input
M∗
0 , and also simulates the FAES-functionality inside
2P-CBC (where it just receives some key from the
adversary).
(4) Using the ciphertexts C0, . . . , Ct and the key Kaes,
the simulator extracts the underlying plaintexts,
M p
t , M s
t , and the tag T . Then, it veriﬁes the MAC. If
the tag is valid, it sends the messages M p
t as the
input of the corrupted client. Otherwise, it sends ⊥.
t , M s
(cid:18)(cid:17)(cid:20)(cid:18)
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:40:08 UTC from IEEE Xplore.  Restrictions apply. 
The only difference between the real and the ideal
executions is the message M∗
that the simulator uses. In
particular, in the ideal execution the simulator does not
know the message M∗
that the proxy receives from the
trusted party, and it simulates the protocol with respect to
a different random message M∗
0 for the proxy. As a result,
the view of the adversary in the ideal corresponds to M∗
0 ,
while the inputs/outputs of the honest parties correspond
to M∗ (cid:11)= M∗
0 . In the real execution, both the view and the
inputs/outputs of the honest parties correspond to M∗
.
We show that the unless A makes some speciﬁc queries
the random oracle, its view is in fact independent to
the message M∗
and therefore the distinguisher cannot
distinguish between the two executions. Moreover, we
show that the probability that a poly-query adversary
(even with unbounded computational power) makes these
particular queries is exponentially small, for a polynomial
poly, and therefore the distinguishing probability of the
distinguisher is exponentially small.
(cid:2)+j) =
(P ∗
q+r) be the injected message (for both the
ideal and real). We deﬁne the set of offending queries
in the real execution, denotes by Sreal, to be one of the
following queries:
• f-queries: Any one of the queries that an honest proxy
/ simulator make in order to compute s(cid:2)+j+1 (given
s(cid:2) that was sent by the adversary). That is, s(cid:2)+1 =
f (s(cid:2), M∗
• AES-queries. Any one of
the AES-queries that
an honest proxy /
to
compute Cq+1, . . . , Cq+r by the FAES invocations,
given the value Cq
sent by the adversary. That
is, Cq+1 = AES(Kaes, Cq ⊕ P ∗
q+1), . . . , Cq+r =
AES(Kaes, Cq+r−1 ⊕ P ∗
• AES−1-queries. Any one of the queries that are cor-
related to Cq+1, . . . , Cq+r−1 (note that the adversary
can make a query to AES−1(Kaes, Cq+r), as its view
contains Cq+r).
Towards this end, let M∗ = (M∗
q+1, . . . , P ∗
(cid:2)+1), . . . , s(cid:2)+j+1 = f (s(cid:2)+j, M∗
simulator make in order
(cid:2)+1, . . . , M∗
q+r).
(cid:2)+j).
Let Sideal denote the set of corresponding queries in
the ideal execution, deﬁned with respect to M∗
0 . Let B
denote the (bad) even in which A makes a call to any
one of the queries in Sreal and Sideal in the corresponding
execution. Since M∗, M∗
0 are distributed uniformly, each
query contains a block value that is hidden from the view
of the adversary unless the adversary makes this speciﬁc
query. With each query, the adversary A learns one value,
which is also distributed uniformly. As such, it is easy to
see that as long as no offending query is made, the view
of the adversary is distributed identically in both execu-
tions as the view is completely independent to M∗, M∗
0 .
Moreover, the event B has the same probability in both
processes. This implies that Pr[B] ≤ (|Sideal|+|Sreal|) ·
(q + 1) · (2−n + 2−d), where q bounds the number of
queries that A makes, n is the block size of AES and d is
the size of the message part in HMAC.
Corrupted proxy. In this case, we essentially prove the
“transport privacy”, that is, that the proxy does not learn
anything about other messages other than M∗
. Moreover,
we show “transcript integrity”, and that the proxy cannot
modify parts of the message transcript besides M∗
. We
proceed with a description of the simulator S:
(1) The simulator plays the role of the client and the
server in the handshake phase, and transmits the
message throw A. It learns Kaes and Khmac.
(2) The simulator chooses arbitrary inputs M p
t of
the corresponding sizes, and runs an honest execution
of the protocol with respect to this messages.
t , M s
q be the messages sent by the adversary
to the simulator, that are supposed to be delivered
to the server (these might be different than the ci-
phertexts replied by the simulator during 2P-CBC).
S decrypts C(cid:3)
1, . . . , C(cid:3)
q using Kaes and learns the
1, . . . , P (cid:3)
underlying plaintext P (cid:3)
q. It acts like an honest
server and checks that they messages are well-formed
according to the TLS protocol. It extracts the under-
lying messages ˜M p
(4) It checks that the extracted messages are those used
t = M s
t .
(5) If all veriﬁcations pass, the simulator sends ˜M∗ to
t (cid:3) ˜M∗(cid:3) ˜M s
in the simulation, that is, ˜M p
the trusted party. Otherwise, it sends ⊥.
Based on this simulator, in the full version of the paper
t , and veriﬁes the tag.
t and ˜M s
t = M p
(3) Let C(cid:3)
1, . . . , C(cid:3)
we conclude the proof.
2) Security of SCI-TLS with AES-GCM
Due to lack of space, we omit the security proof of
SCI-TLS with AES-GCM and refer to the full paper.
We give just a high-level idea of how the proof works.
The view of the corrupted client is simply the output of
the oblivious polynomial evaluation protocol, which is a
uniform random ﬁeld element due to the masking that
the proxy adds to the polynomial p∗(·). On the other
hand, the counter mode enables the client to make the
add some “shift” Δ the plaintext of the proxy, and also
provide the right authentication for this shift. As a result,
the server obtains some message M∗ + Δ instead of just
M∗
. However, the simulator can easily extract this Δ, and
send it to the trusted party.
The case of corrupted proxy is similar to the corre-
sponding one in Theorem 9, and the simulator runs an
honest execution of the protocol with respect to some
arbitrarily messages M p
(showing “transport pri-
vacy”). Additionally, it also veriﬁes that the messages
decrypted by the simulated server are those that were sent
by the simulated client (i.e., checks “transport integrity”).
Integrity follows by reducing the protocol to the authen-
tication of AES-GCM.
t , M s
t
(cid:18)(cid:17)(cid:20)(cid:19)
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:40:08 UTC from IEEE Xplore.  Restrictions apply.