原文链接：[https://one.tuisec.win/detail.jsp?id=https://hackerone.com/reports/409850&&search_by_html=url](https://one.tuisec.win/detail.jsp?id=https://hackerone.com/reports/409850&&search_by_html=url)
# **1.背景**
Steam的聊天客户端是一个攻击起来特别有趣的系统，因为它是使用一组具有强大安全特性的现代技术构建的。
它主要是基于React框架，而关于React，它具有任何现代Javascript应用程序框架的一些最强大的安全特性，并且避免使用不安全dangerously的函数系列。
虽然部署了内容安全策略，但有unsafe-inline。这是一个小小的不便，但前进了一个有趣的步骤。
与大多数使用Web技术的桌面应用程序不同，聊天客户端运行在Chrome Embedded
Framework的自定义高度锁定版本中。在大多数类似电子的系统中，通过window对象向Javascript
VM授予特权访问权限。聊天客户端采用有趣且可能更安全的运行方式，实质上是常规网页的权限，只允许通过PostMessage执行特权操作，以及与父进程通信的环回WebSocket。  
WebSocket带有一个非常难以通过网络剖析的自定义二进制协议，并通过一些常见错误，我还没有找到Chrome Dev
Tools的根本原因如果断点在页面加载时崩溃（我认为它是某种竞争，当WebWorkers处于活动状态并且Javascript资源很庞大时发生的竞争。）
DOM重型应用程序的趋势对我来说很有意思，因为安全行业中的许多人仍然严重依赖于在这些情况下无法准确反映应用程序状态的HTTP代理。
# **2.技术**
## 2A.React安全问题
由于Steam聊天客户端是基于React构建的，因此XSS的可行方式要少得多。我有几种寻找方式：  
· React没有特殊地编码任何标签的属性。具有DOM操作属性的属性是危险的。
通常可以看到``属性由用户输入生成，其中javascript: input uri在单击时会产生XSS。对javascript:
URI的手动对策仍然很差，并且经常使用不打算在防御中使用的URL解析器。
style通过字符串连接生成包含用户输入的标签并不罕见，其中图像（例如作为背景URL）可以通过Referer标头从URL注入IP地址信息和令牌。即使在最佳的上下文感知XSS库中，CSS清理也不是真正的东西。对于使用selector[value=string]或定义字体的基于CSS的攻击，使用或定义每个字符的HTTP请求以有条件地加载资源和泄露数据，在信息安全圈之外几乎完全是未知的。
React不会尝试提供其他不安全的Javacript功能的强化版本，也不会禁用它们。通常看到React应用程序用于document.location =
xxx更改浏览器的位置，该浏览器也容易受到Javascript URI引发的攻击。
同样，对HTTP
API的请求也不会从React获得增强的安全性。使用拼接到未正确编码的URL的用户输入来请求数据仍然很常见。React开发人员喜欢使用花哨的REST语法来生成请求路径"/user/"
+ encodeURIComponent(username) + "profile"，即使据我所知，在vanilla
Javascript中编码URL路径也没有安全的方法。即使../编码到哪里..%2F，几乎所有的Web服务器都忽略了%2F和之间的词汇差异/。
·
某些协议，如OEMBED，通过返回HTML设计是不安全的。要使用这些API，必须使用包括此在内的React应用程序dangerouslySetInnerHTML。经常可以看到React被引用来获取生成的元素和直接调用的innerHTML的句柄，这可以避免测试人员为“不安全”而抱怨。
返回HTML的协议，甚至那些仍然不会定期返回的协议Content-Type:
text/html，这意味着如果受害者导航到API结果，例如通过提交HTML表单，如果存在XSS的话，即使客户端将安全地处理输出，浏览器也不会。
## 2B.高级DevTools功能
我想介绍一些我的infosec朋友使用不多DevTools功能，这对于我发现bug很有帮助。
### 2b I.控制台抽屉
当你打开devtools按escape键时，一个抽屉会从底部拉上来。从这里，您可以在浏览源代码或网络日志的同时访问一些非常强大的特性。
这最棒的特点就是拉出的控制台。当一个断点被触发并暂停执行时，你可以在这里执行你想要的任何代码，它将在调试器所在的当前行的上下文中执行。这对于修改和检查在多个抽象级别上运行的代码是绝对必不可少的。
### 2b II.代码搜索，相当不错的打印
DevTools包含一个非常强大的搜索功能，可搜索加载到当前窗口中的每个资源。它可以通过底部抽屉访问（单击三个点）。如果你在DOM中找到一个元素并想知道它是如何生成的，你可以在这里搜索它并跳转到它所提到的位置。
在那里，您可能想要点击左下角的漂亮打印按钮{}和ctrl-f来查找您可能感兴趣的文件中的任何内容。
### 2b III.打破事件
你有一些预期会发生的事件是很常见的，比如XHR或postMessage，但你不知道处理程序的定义在哪里。别担心！如果滚动到Sources最右侧面板的底部，则可以为XHR
/ fetch和事件侦听器设置断点。
### 2b IV.调用堆栈
在“Sources”面板中，一旦一个断点触发，您将得到右边断点之前的完整调用堆栈。当然，你在大多数语言中都能得到这个。
假设您知道一个用户操作最终调用XHR，但是您希望找到XHR请求的高级构造。如果您设置XHR /
fetch断点，那么您最终将深入到某种通常提供很少上下文的库中。
实际上，现在您可以通过单击每个调用、查看作用域中的代码、变量和它所在的文件来后退一步遍历调用堆栈，直到找到一些看起来专门为这个应用程序编写的内容为止。我发现在现代的小型应用程序中，这对于逃避库调用是不可缺少的。
### 2b V.注入代码
虽然chrome
devtools确实能够在网页中动态编辑Javascript代码，但这不适用于缩小代码，因为不能在打印精美的文件上这样做。不过，你可以使用一个特殊的技巧。
如果右键单击行号，可以使用“插入条件断点”。条件断点是完全特色的javascript，在语句出现时会中断true。console.log始终返回undefined，因此如果您想在程序运行时检查多个值，您可以注入console.log调用以将其值打印到控制台，这是类似但效果较差的“监视”功能无法实现的。
在有心跳的系统中，断点通常会导致断开连接。使用条件断点可以允许您在不停止执行和使用控制台的情况下添加代码。
### 2b VI.网络搜索
当然你从某个地方获得了一些数据，但不知道在哪里？您可以单击网络面板中的放大镜图标来搜索完整的请求，响应及其标题。
### 2b VII.网络过滤器表达式
在发送大量XHR请求的应用程序中，特别是那些定期轮询的应用程序，可能很快就无法导航网络面板中的所有请求。您可以使用筛选器表达式将请求缩小到您认为重要的请求。
### 2b VIII.曲向复制
使用devtools可以做很多事情，但是你通常不能绕过像同源策略这样的web安全原语，而且重制和自定义请求并不容易。您可以单击network面板中的任何请求，然后转到“曲向复制”以获得该请求的精确复制，您可以对其进行迭代以打乱请求表单。
# **3.方法**
在典型的上一代聊天应用程序中，安全问题最有可能出现在从输入文本生成HTML的位置。毕竟，解析语言不仅是一个超级难题，而且特别难以向用户提供HTML功能的强大功能，而不会无意中允许他们通过操纵这些功能来控制浏览器。
## \- 3A.侦察
我首先意识到的是，部署在Steam桌面应用程序中的应用程序与 
上的在线应用程序是一样的，这使得将DevTools注入测试流变得容易得多。
在那之后，我花了一点时间与DevTools的空闲的网络面板聊天，发现我们没有受到XHR轮询的攻击。这可能意味着我们使用的是WebSocket。打开网络面板刷新页面(只有打开WebSocket连接时才能看到它们)，我浏览了一下WS面板，注意到客户端在完全不可理解的二进制框架上进行通信。
注意到聊天系统支持难以置信的安全实施的嵌入式内容，我开始对“OEMBED”和其他非常容易获得XSS的通用嵌入系统进行代码搜索。
此时，我发现该应用程序是一个React应用程序，并切换到，至少部分使用React
Chrome扩展来检查DOM。这个扩展非常容易跳到生成元素的代码，而且因为React组件将它们所依赖的所有信息都表示为道具(可以在扩展中查看)，所以就更容易掌握应用程序结构。
我搜索了一下dangerously，innerHTML等等，并设置所有的断点。我试图通过跟踪调用堆栈来触发这些函数。dangerously是真的被称为可以由聊天服务器发送的某些“oembed元素”。
我在加载OEMBED内容(如YouTube)时触发的xhr和其他事件上设置断点。当它们被触发时，我退回调用堆栈，以访问对用户输入进行清理并通过二进制WebSocket将其发送到聊天服务器的函数。
## \- 3B.实现XSS
事实证明这有令人惊讶的结果。我最终会为每个发送的消息触发两次断点：一次是当用户发出一个发送请求，客户端将一个假定的服务器响应写入DOM时 -第二次当它被服务器返回的实际响应覆盖时。在某些情况下，这些渲染可能会有很大差异，特别是在使用OEMBED时。
如果我在聊天中发送Vimeo链接，则客户端在发送消息时最初将其呈现为HTML链接。然后，当服务器更新聊天室时，它将用BBCode（是的，bbcode！）[OEMBED]标签替换该链接，该标签基本上只是原始HTML。
我立即跳过了这一点，并在调用后使用断点来清理BBCode的用户输入，我尝试发送包含恶意HTML的OEMBED标记，希望它们会被服务器反应回来。但是，服务器会在响应之前完全剥离这些标记。