the EENTER instruction to transfer control to the enclave
code. More speciﬁcally, control is transferred to an enclave
USENIX Association
29th USENIX Security Symposium    843
AppurtsEnclavetrtsEENTEREEXITHostSGXOCALLECALLHost ViewEnclave Viewreadable (r- -/rw-)executable (r-x)Application CodeEnclave CodeEnclave DataApplication Dataenclave {
trusted { // ECALLs
public void ecall_size1( // explicit size
[in, size=100] void* ptr);
public void ecall_size2( // variable size in len
[in, size=len] void* ptr, size_t len);
public void ecall_user( // dangerous user_check
[user_check] void* ptr);
};
};
Figure 2: Example for the EDL syntax.
entry point in the SDK’s trusted runtime (trts). The trts takes
care of the context switch and sets up the enclave execution
environment: (1) it switches the stack to a stack in enclave
memory, (2) allocates secure memory and copies the argu-
ments into the enclave, (3) calls the actual ECALL function,
and ﬁnally (4) clears the registers before returning to the host
application’s code. Similarly, the SDK also supports calling
functions of the untrusted host application, which is referred
to as OCALLs (outside calls). For OCALLs, the trts saves the
enclave’s execution state to enclave memory and restores it
when the call returns.
3.2 The EDL Interface Speciﬁcations
The Intel SGX SDK uses the EDL (Enclave Deﬁnition Lan-
guage), a custom speciﬁcation language to deﬁne the ECALL
and OCALL interface of an enclave. The EDL language re-
sembles a C-header ﬁle with additional syntax to specify
SGX-speciﬁc information. It allows the developer to specify
the prototypes of functions available as ECALL and the valid
data format of input arguments. Based on the EDL ﬁle, the
SDK generates wrapper code to transparently connect the
function stubs in the host application with the ECALLs in
the enclave. The parameters of ECALLs are transferred using
auto-generated data structures. When the application invokes
an ECALL, the SDK-generated code stores all parameters
in the prepared structure in the untrusted host application
memory. These will then be fetched by the SDK code in the
enclave and unpacked for the actual ECALL code.
The SDK must be able to determine the size of the argu-
ments to allocate a ﬁtting buffer in the secure memory. Thus,
every pointer type has to be annotated with a size such that
the SDK can determine the size of the underlying buffer. Cur-
rently, the Intel SGX SDK supports copying C data types such
as basic integer types, composed basic data types (struct) with-
out nested pointers, 0-terminated/C-style strings, and pointers
to arrays of ﬁxed length.
Figure 2 shows an example of different features of the EDL
language. In this example, a void* pointer is annotated with
[in, size=100]. The SDK will generate code that allocates
100 bytes in enclave memory and copies 100 bytes from un-
trusted memory into the enclave. Alternatively, the developer
can also specify dynamic lengths, which then refer to other
parameters by name. However, when writing the interface
deﬁnition in EDL, there are some peculiarities that have to be
taken into account. First, it is possible to disable the SDK fea-
tures. A pointer that is annotated as [user_check] is passed
to the enclave without any auto-generated check. It is up to
the enclave developer to validate the underlying buffer. Sec-
ond, compound data types are only shallow copied. They are
treated as buffers with a ﬁxed size and are simply copied into
secure memory. Data structures are not recursively copied, i.e.
it is not checked if any of the ﬁelds in the structure is a pointer
type. So, even if a developer uses the Intel SGX SDK to pro-
tect the ECALL API, there are many cases that additionally
require custom validation code, which is error-prone.
4 TEEREX Symbolic Enclave Analyzer
We develop a novel symbolic execution framework, called
TEEREX,1 to automatically identify vulnerabilities of SGX en-
claves. Our framework does not only identify vulnerabilities,
but also generates a detailed vulnerability report which signiﬁ-
cantly simpliﬁes the process of constructing proof-of-concept
exploits against the vulnerable SGX enclave. It supports all
platforms supported by the Intel SGX SDK: Windows (PE)
and Linux (ELF) binaries and both 32 and 64-bit enclaves.
Note that we apply symbolic execution on the binary level to
be able to analyze closed-source, proprietary enclaves. Our
prototype of TEEREX supports the standard enclave format
of the Intel SGX SDK and leaves support of custom enclave
formats and loaders (e.g., the Graphene framework [61]) as
future work. Further, we focus our analysis on unencrypted
enclave code. In case the enclave code is encrypted neither
TEEREX nor any other static analysis tool can analyze the
enclave without knowing the secret key. TEEREX must be
able to read and properly load the enclave’s code.
In what follows, we describe the overall architecture of
TEEREX (Section 4.1), elaborate on several challenges and
how we tackled them (Section 4.2), and ﬁnally describe our
vulnerability detection engines in detail (Section 4.3).
4.1 Architecture
Symbolic execution was ﬁrst proposed in the 70’s as a gener-
alization of testing [8, 42] and has become one of the standard
tools for high coverage testing and vulnerability analysis [5,
10, 12, 58]. However, the modeling of side effects caused by
the operating system (OS) is highly challenging, e.g., sym-
bolic execution must typically simulate and support all OS
system calls and manage a simulated ﬁle system [5]. For-
tunately, there are several SGX peculiarities that simplify
symbolic execution for SGX enclaves: enclave code is self-
contained (i.e., no external dependencies like libraries) and
1TEEREX stands for Trusted Enclave Ecall Runtime EXploiter
844    29th USENIX Security Symposium
USENIX Association
Figure 3: Architecture of TEEREX
isolated from the rest of the system. SGX enclaves are prohib-
ited to perform any system calls and any interaction with the
OS is handled by means of an OCALL to the untrusted host
application.
Figure 3 shows the architecture of TEEREX’ symbolic
analysis pipeline. The main goal of TEEREX is to ﬁnd vulner-
able states during the symbolic exploration. Further, it aims
to collect meta-data to eventually generate a detailed vulner-
ability report. This is achieved by executing each ECALL
symbolically and checking every state for different vulnera-
bility classes. To produce accurate vulnerability reports, we
add pointer tracking to the symbolic execution engine. This
allows us to track pointer dereferences and propagate labels
that allow us to distinguish between data loaded from enclave
and host memory. As a result, TEEREX can spot vulnerable
instructions that read data from outside of the protected en-
clave memory. This is a necessary design decision as enclaves
can be loaded by arbitrary (malicious) host applications.
We leverage the well-known ANGR framework [58] as our
symbolic explorer. This allows us to extract memory con-
straints from enclave code, which is subsequently needed for
vulnerability analysis. ANGR itself does not support executing
SGX enclaves because: (1) ANGR cannot jump from the host
application to the enclave (2) there is no setup for an initial
environment to directly execute ECALLs, (3) enclaves utilize
CPU instructions not supported by ANGR, (4) TEEREX lever-
ages enclave speciﬁcs to scale over multiple processes and
machines, while ANGR is limited to one thread, and (5) the
common trusted functions for memory allocation are not di-
rectly supported by ANGR. Furthermore, ANGR does not per-
form any vulnerability analysis by itself: its purpose is to
provide a robust and comprehensive framework to perform
static analysis and symbolic execution. As we will describe
in Section 4.2, TEEREX tackles all the above mentioned chal-
lenges. As shown in Figure 3, TEEREX is split into several
major components.
Preprocessor: The ﬁrst step in the pipeline depicted in Fig-
ure 3 is to pre-process the enclave binary to (1) identify in-
structions and functions that cannot be executed symbolically,
and (2) to locate the ECALL table and extract the addresses
of the ECALL functions. This preliminary static analysis step
allows us to instrument speciﬁc binary instructions to increase
the performance and coverage of the analysis.
Enclave Loader: The enclave loader sets up the initial en-
vironment to execute one ECALL. It replaces the identiﬁed
common functions and special instructions with emulating
Python code. Further, it creates the argument structure for the
ECALL with unconstrained symbolic values.
Symbolic Explorer: The symbolic execution performed by
the ANGR framework can be distributed across multiple ma-
chines, as the ECALLs are analyzed individually. The results
are merged later in the vulnerability reports for the analyst.
Vulnerability Detection: TEEREX analyzes the symbolic
states during ANGR’s symbolic exploration for vulnerabilities
in the enclaves. It speciﬁcally analyzes instructions that access
memory and jumps. This is described in detail in Section 4.3.
Pointer Tracking: The majority of vulnerabilities in SGX
enclaves are due to insecure pointer usage and lack of pointer
validation. TEEREX implements pointer tracking by analyz-
ing all pointer dereferences and propagating labels between
symbolic values. More speciﬁcally, TEEREX uses a taint-style
analysis annotating every value loaded from memory with
the address, where the value was loaded from. This allows
TEEREX to determine the source of a value, e.g., whether
a function pointer used for an indirect call was loaded from
enclave, host memory, or loaded via a parameter passed to the
ECALL function.
Furthermore, TEEREX places hooks on Intel SGX SDK
functions that are used to validate whether an address is within
secure memory. Whenever the enclave uses one of these func-
tions, TEEREX forks the symbolic execution into two states:
one where the address is within enclave memory and one
USENIX Association
29th USENIX Security Symposium    845
Preprocessor(Static Analysis)IdentifyECALLsSymbolic Hooksfor commonFunctionsEnclaveBinaryExploitTEEREXVulnerability ReportControlled PointerSymbolicExecution TraceVuln. InstructionVulnerability ClassAnalystEmulationof SpecialInstructionsPointerTrackingSymbolicExplorerEnclaveLoaderVulnerability DetectionControlled BranchesControlled WritesNULL-Pointer DereferencesSymbolic ExecutionTEEREXwhere the address is outside enclave memory. This informa-
tion is used by TEEREX to assess whether a bug is exploitable
and report identiﬁed vulnerabilities more accurately.
Vulnerability Report: Finally, TEEREX produces a vulner-
ability report, which contains (1) the type of the vulnerability,
(2) the location in the binary, (3) the controlled pointer and its
position in the attacker-controlled input and (4) an execution
trace to reach the vulnerable instruction. The vulnerability
report provides sufﬁcient detailed information to an analyst
for constructing a proof-of-concept exploit, even for closed-
source enclaves (see Section 5).
4.2 Challenges
Next, we will describe several challenges when applying sym-
bolic execution to enclave binaries and how our design tackles
them.
C1: Accuracy and Scalability. Enclaves built with the Intel
SGX SDK deﬁne only a few (often one) entry point in the
thread-control structure (TCS). This entry point is the trusted
runtime (trts) that is responsible for setting up the enclave
execution environment, calling exception handlers, and multi-
plexing ECALLs. For this, the arguments of an ECALL are
packed by the untrusted runtime (urts) to be unpacked upon
entering the enclave by the trts. This introduces an additional
layer of pointer indirection for all ECALL parameters. The
speciﬁcs of the enclave management in the trts are heavily
dependent on the intrinsics of the SGX instructions and the
enclave’s internal metadata, which are not present in the em-
ulated environment. This introduces high complexity and a
major challenge for a symbolic execution analysis because
(1) the enclave initialization routines result in many memory
accesses through symbolic addresses, which is a notoriously
hard problem for symbolic execution engines in general [5,
12], and (2) due to the low-level nature of the trts code the
symbolic execution lacks semantic information about the exe-
cution context when it ﬁnally reaches the ECALL functions.
Hence, it is not feasible to map symbolic memory ranges to
ECALL parameters once the symbolic execution analyzes the
actual ECALL function.
However, symbolically executing the whole trts code is
conceptually uninteresting for identifying vulnerabilities in
ECALLs as the trts is independent of ECALLs. As such, we
designed TEEREX in such a way that it is able to skip sym-
bolic execution of the trts and instead targets ECALL func-
tions directly. To do so, TEEREX ﬁrst extracts the ECALL
table from the enclave binary. Next, symbolic execution is
started at the beginning of every ECALL separately. This al-
lows TEEREX to produce very accurate vulnerability reports
as it is now possible to directly control the arguments passed
to the ECALL function. At the same time, it reduces the over-
head of executing code that is not meaningful for identifying
exploitable bugs in enclaves. Furthermore, starting the analy-
sis for each ECALL function separately and skipping the SDK
runtime components allows parallelization of the symbolic
execution process. Note that ANGR is originally restricted to
one thread due to the limits of the Python implementation.
C2: Standard Memory Functions. Another source of path
complexity arises from the standard memory functions. Meth-
ods like memcpy or malloc are reimplemented in ANGR as
so-called SimProcedures at a higher level. Instead of symbol-
ically executing the binary code of a function like memcpy,
ANGR instead invokes the corresponding SimProcedure to
update the symbolic state. This is possible because most ap-
plications load these functions dynamically from a library in
the system, which can be easily intercepted. However, the self-
contained enclave code comes with its own trusted version
of these functions. As such, TEEREX searches the enclave
code for trusted versions of these functions and places hooks
to invoke the corresponding SimProcedure instead.
C3: Unsupported CPU Instructions. Since SGX has been
recently integrated into new Intel CPUs, there are several
advanced instructions included in enclave code that are un-
supported by the symbolic explorer either because they are
too new or too complex to be easily implemented symboli-
cally. This includes the primary SGX instruction enclu to en-
ter/exit an enclave, but also the non-SGX-speciﬁc instructions
rdrand and xsave/xrstor, which are used in OCALLs to
save and restore all registers from memory when the execution
passes the host-enclave boundary. To tackle this challenge,
we avoid executing the SGX-speciﬁc entry instructions but
directly invoke the ECALL functions during the symbolic
execution. We deal with other unsupported, but frequently
executed instructions, by hooking into them. The hooks re-
implement and emulate the instructions in Python to update
the symbolic state accordingly.
C4: Global State of Enclaves and Chains of ECALLs. En-
claves can be entered multiple times at different ECALLs with
different attacker-controlled input data, with each of the calls
altering the internal global state of the enclave. Hence, the
control-ﬂow of an ECALL does not only depend on its argu-
ments, but also on all prior invoked ECALLs. Taking this into
account, an accurate symbolic exploration of an ECALL re-
quires exhaustive knowledge about the effects of all ECALLs.
To address this issue, TEEREX analyzes each ECALL individ-
ually and treats all (secure) global state (i.e., global variables
in the data and bss sections) of an enclave as initialized with
unconstrained symbolic values. This allows our tool to also
explore paths of an ECALL that are not reachable with an
enclave’s initial global state. However, the global state is typi-
cally not fully attacker-controlled but rather initialized to zero
or changed to some value by a different ECALL. Thus, the as-
sumption that the global state is completely unconstrained can
potentially lead to a situation, where our TEEREX wrongly
reports an attacker-controlled jump or write although the state
might be limited to only safe values. Nevertheless, the analysis
846    29th USENIX Security Symposium