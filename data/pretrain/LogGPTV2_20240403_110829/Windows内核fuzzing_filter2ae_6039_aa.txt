# Windows内核fuzzing
##### 译文声明
本文是翻译文章，文章原作者 Netanel Ben-Simon、Yoav Alon，文章来源：research.checkpoint.com
原文地址：
译文仅供参考，具体内容表达以及含义原文为准。
## 背景
在[先前的研究](https://research.checkpoint.com/2018/50-adobe-cves-in-50-days/)中，我们使用[WinAFL](https://github.com/googleprojectzero/winafl)对Windows上运行的用户空间应用程序进行fuzz，并在Adobe
Reader和Microsoft Edge中发现了50多个漏洞。
对于下一个挑战，我们决定追求更大的目标：
Windows内核模糊测试。作为额外的好处，我们可以利用已有的用户空间漏洞，并将它们与我们发现的任何内核漏洞一起使用，以创建完整攻击链——因为没有沙箱逃逸/特权提升的RCE如今几乎毫无价值。
有了目标，我们开始着手探索内核fuzzer领域，看看在追求目标的过程中有哪些选择，也许会大量修改现有工具以更好地满足我们的需求。
本白皮书引用了我们今年早些时候在[OffensiveCon](https://www.offensivecon.org/speakers/2020/netanel-ben-simon-yoav-alon.html)和[BlueHatIL](https://www.bluehatil.com/abstracts#collapse-FuzzingWindowsKernel)上进行的演讲。
视频链接：
## 探索内核fuzzer
我们在[AFL](https://github.com/google/AFL)和[WinAFL](https://github.com/googleprojectzero/winafl)方面拥有丰富的经验，因此我们开始寻找可用于攻击Windows内核的类似模糊测试工具。
我们使用Google搜索到了[kAFL](https://github.com/RUB-SysSec/kAFL)，即带有前缀’k’的AFL，看起来完全符合我们的需要。
###  kAFL
[kAFL](https://www.usenix.org/system/files/conference/usenixsecurity17/sec17-schumilo.pdf)是德国波鸿鲁尔大学的研究性fuzzer，它利用AFL样式fuzzing来攻击OS内核。看上去这似乎正是我们想要的。kAFL支持Linux、macOS和Windows，并被用来查找Linux内核Ext4文件系统和macOS中的漏洞。
kAFL具有与AFL相似的原理，但是由于它以OS内核为目标，因此它需要围绕fuzzing循环做更多的工作。Fuzzing循环是一个过程，在该过程中，每个循环周期中的测试用例都针对其目标进行测试，并处理反馈（参见图1）。
图1：fuzzing循环周期
当kAFL首次启动时，fuzzer(1)会从保存状态生成运行目标OS的多个虚拟机。在VM快照中，VM内部运行着一个预加载的代理agent(2)。
代理agent(2)和fuzzer(1)协同以推动fuzzing处理过程。代理运行在用户空间，通过[hypercalls](https://wiki.xenproject.org/wiki/Hypercall)与fuzzer进行通信，并将目标驱动程序的地址范围发送给fuzzer，这些地址仅限制代理提供范围内的代码覆盖率跟踪。
在循环开始时，fuzzer通过共享内存将输入input(3)发送到代理。kAFL使用类似于AFL的突变策略来生成新的输入。
接下来，代理通知hypervisor开始(4)收集覆盖率。然后，代理将输入发送(5)到目标内核组件：例如，如果我们以负责解析压缩映像的名为test.sys的驱动程序(6)为目标，则代理将生成的输入发送到驱动程序以对其进行测试。
最后，代理要求停止(7)从[KVM](https://www.linux-kvm.org/page/Main_Page)(8)收集覆盖率，而fuzzer将处理覆盖率跟踪。kAFL的覆盖率实现使用 [Intel Processor
Trace](https://software.intel.com/en-us/blogs/2013/09/18/processor-tracing)（IntelPT或IPT）作为覆盖率反馈机制。  
当guest OS尝试启动、停止或(9)收集覆盖率时，它将向[KVM](https://www.linux-kvm.org/page/Main_Page)发出hypercall。
kAFL崩溃检测机制（参见图2）的工作方式如下：
图2： kAFL崩溃检测
VM内的agent(1)使用 **BugCheck** 和 **BugCheckEx**
的地址向KVM发出hypercall(2)，KVM(3)使用shellcode(5)依次对这些地址进行打补丁(4)，该shellcode在执行时会发出hypercall。
因此，当机器遇到bug时，内核会调用补丁版本的 **BugCheck** 或 **BugCheckEx**
发出hypercall，以通知(6)fuzzer产生了崩溃。
现在，我们了解了这些机制，考虑如何根据Windows环境的需要进行调整。
## 攻击什么？
Windows内核非常庞大，有[几千万行代码](https://techcommunity.microsoft.com/t5/Windows-Kernel-Internals/One-Windows-Kernel/ba-p/267142)和[数百万的源文件](https://github.com/dwizzzle/Presentations/blob/master/David%20Weston%20-%20Keeping%20Windows%20Secure%20-%20Bluehat%20IL%202019.pdf)。我们的重点是那些可以从用户空间访问的部分，这些部分相当复杂，并且可以用于本地特权提升（PE）。
根据我们的经验，AFL适合以下目标：
• 快速目标，每秒可以执行100次以上的迭代；
• 解析器，特别是针对二进制格式。
这与Michał Zalewski
在[AFL的README](https://github.com/google/AFL/blob/master/README.md#9-fuzzer-dictionaries)中所写的内容一致：“默认情况下，afl-fuzz突变引擎针对紧凑的数据格式进行了优化，例如图像、多媒体、压缩数据、正则表达式语法或shell脚本。它不太适合具有格式繁琐和冗余数据的语言，特别是包括HTML、SQL或JavaScript等的语言。”  
在Windows内核（图3）中寻找合适的目标。
图3： Windows内核组件
这些是我们考虑的目标：
• 文件系统，例如NTFS、FAT、VHD等。  
• 注册表配置单元。  
• 加密/代码完整性（CI）。  
• PE格式。  
• 字体（从Windows 10开始已迁移到用户空间）。  
• 图形驱动程序。
###  Windows中的典型内核漏洞
我们退后一步，研究了一个非常典型的内核漏洞：[CVE-2018-0744](https://crbug.com/project-zero/1389)。
图4： win32k中的典型漏洞
该程序包含多个系统调用，这些系统调用将高度结构化的数据作为输入，例如结构体、常量（魔数）、函数指针、字符串和标志。
此外，系统调用之间存在依赖性：一个系统调用的输出用作其他系统调用的输入。这种类型的结构在内核缺陷的情况下非常常见，在这种情况下，使用一系列的系统调用来达到触发漏洞的错误状态。
可以在[此处](https://github.com/google/fuzzing/blob/master/docs/structure-aware-fuzzing.md)找到结构感知型fuzzing的重要性和示例。
###  Windows内核攻击面：kAFL VS Syscall fuzzer
在观察到上述bug之后，我们意识到使用AFL样式的fuzzer将会限制我们使用相对较小的内核部分。Windows内核的大部分内容可以通过涉及高度结构化数据的系统调用来访问，但是使用kAFL会将我们限制在内核中的二进制解析器中，例如设备驱动程序、文件系统、PE格式、注册表等。与可以从系统调用中访问的代码量相比，这些部分相对较少。因此，如果我们有一个系统调用fuzzer（syscall
fuzzer），就可能会接触到更多的攻击面，例如虚拟内存管理、进程管理器、图形、user winapi、gdi、安全性、网络等等。
至此，我们意识到需要寻找一个系统调用fuzzer。
###  Syzkaller简介
[Syzkaller](https://github.com/google/syzkaller)是一个覆盖率引导的结构感知型内核fuzzer（又名智能系统调用fuzzer）。它支持多种操作系统，并且可以在多种机器类型（Qemu、GCE、手机等）和多种架构（x86-64、aarch64）上运行。
到目前为止，Syzkaller
已经在Linux内核中[发现](https://syzkaller.appspot.com/upstream)了3700个bug，并且保守估计有六分之一是安全漏洞。
Syzkaller是结构感知的fuzzer，这意味着它具有每个系统调用的描述。系统调用描述以类似于go的[语法](https://github.com/google/syzkaller/blob/master/docs/syscall_descriptions_syntax.md#syscall-description-language)写入文本文件。Syz-sysgen是Syzkaller工具之一，用于解析和格式化系统调用描述。成功完成此过程后，它将文本文件转换为”go”代码，并将其与fuzzer代码一起编译到一个名为syz-fuzzer的可执行文件中。
Syz-fuzzer是驱动guest
VM内部的fuzzing处理过程的主要可执行文件。Syzkaller具有自己的语法来描述程序、系统调用、结构体、联合等等，生成的程序也称为syz程序。这里有一个[示例](https://github.com/google/syzkaller/blob/master/docs/syscall_descriptions.md#syscall-descriptions)。
Syzkaller采用了一些[突变策略](https://github.com/google/syzkaller/blob/ed8812ac86c117831a001923d3048b0acd04ed3e/prog/mutation.go#L33)来对现有程序进行突变。以[syz格式](https://github.com/google/syzkaller/blob/master/docs/syscall_descriptions.md#programs)提供新代码覆盖的程序被Syzkaller保存在数据库中，这个数据库也称为语料库。这允许我们停止fuzzer，进行更改，然后从停止的位置继续。
图5： Syzkaller架构（Linux）
Syzkaller的主要二进制文件是syz-manager(1)，当它启动时执行以下操作：
从之前的运行中加载程序的语料库(2)，启动多个测试(3)机器，使用ssh(4)将executor(6)和fuzzer(5)二进制文件复制到机器中，执行Syz-fuzzer(5)。
然后，Syz-fuzzer(5)从管理器中获取语料库并开始生成程序。每个程序都被送回管理器保护起来以防崩溃。然后，Syz-fuzzer通过IPC(7)将程序发送到executor(6)，该executor运行系统调用(8)并从内核(9)收集覆盖率（如果是Linux，则为KCOV）。
[KCOV](https://www.kernel.org/doc/html/v4.17/dev-tools/kcov.html)具有编译时插桩功能，它使我们可以从用户空间获取整个内核中每个线程的代码覆盖率。如果检测到新的覆盖率跟踪，则fuzzer(11)报告给管理器。
Syzkaller的目标是成为一个无监督的fuzzer，这意味着它试图使整个fuzzing过程自动化。这个属性的一个例子是，在发生崩溃的情况下，Syzkaller会生成多个复制的机器，以从程序日志中分析崩溃的syz程序。这些复制的机器尝试尽可能地最小化崩溃的程序。该过程完成后，
Syzkaller通常会重新生成一个syz程序或一段C代码用于复现崩溃。Syzkaller还能够从git中提取维护者列表，并通过电子邮件将崩溃的详细信息发送给他们。
Syzkaller支持Linux内核，并有令人印象深刻的结果。看着Syzkaller，我们想：如果能在Windows上对Linux内核进行模糊测试就好了。这促使我们探索WSL。
###  WSLv1背景知识
[Windows下的Linux子系统（WSL）](https://docs.microsoft.com/en-us/windows/wsl/install-win10)是一个在Windows上运行原生Linux二进制可执行文件的兼容层，它在Linux系统调用和Windows