 2
Number of threads
 8  16 32 
Swapping item between queues
No kill
1 kill every 100ms
 2
)
s
/
 1
6
0
1
×
(
s
n
o
i
t
c
a
s
n
a
r
T
 64
 2
 4
 8
 16
 32
Number of processes
Figure 12: Persistent queues (left) and impact of failures (right).
On the hash set shown in Fig. 11, the number of traversed
nodes is rarely above 2, bringing OneFile even closer to
the Romulus implementations and again surpassing PMDK
by an order of magnitude in most scenarios. For an update
ratio of 100% the OneFile-PTM performs 30% less than
RomulusLog but on the other hand, provides lock-free
progress.
On the left plot of Fig. 12 we show multiple persistent
queues, all singly-linked list based. At the exception of the
160
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 11:13:27 UTC from IEEE Xplore.  Restrictions apply. 
FHMP queue, which is the hand-made lock-free designed
by Friedman, Herlihy, Marathe and Petrank [63], all other
queues are sequential implementations wrapped in a PTM.
The original design for the FHMP queue uses the system
allocator which means that it is blocking for allocation,
has no embedded memory reclamation (nodes are never
deleted and the memory will eventually ﬁll up), and the
allocator does not work on NVM. Up until now, no NVM
allocator has been presented with lock-free progress, and
neither has a lock-free memory reclamation scheme. Seen as
FHMP does not allocate in persistent memory, all pwb and
pfence associated with memory allocation/de-allocation
are omitted during its execution. If an NVM allocator and
reclamation scheme is added to FHMP,
its performance
will decrease. The queues made with the OneFile PTMs
have a performance close to the hand made lock-free queue
FHMP and surpass it in single thread workloads, while
providing failure-resilience memory allocation/de-allocation
and reclamation.
In addition, the advantage of lock-free PTMs over hand-
made lock-free data structures is relevant when having
operations over multiple instances. Consider two instances
of a lock-free queue designed for NVM, q1 and q2. If the
user wants to dequeue an item x from q1 and place it in
q2, with lock-free progress and in an atomic way, there is
no easy way to do it. If a failure occurs after the dequeue
of item x from q1 and before the enqueue of x on q2,
upon restart, the contents of q1 and q2 will be recovered
to consistent state, with neither of the queues having the
item x. In this case, the item x will be effectively lost.
With OneFile-PTM the user can create a transaction that
encompasses the dequeue from q1 and the enqueue in q2,
thus preventing the loss of the item in the event of a failure.
Moreover, as memory allocation and reclamation are part
of the transaction, in the event of a failure there will be
no memory leakage or allocator metadata corruption when
removing the node in q1 and creating a new node in q2.
Based on this scenario, we implemented a test where
multiple processes execute a transaction which modiﬁes two
shared queues, while one of these processes is randomly
killed. The test consists of executing N processes each with
a single thread. Its thread continually executes a transaction
that takes an item out of a queue and places the item in
another queue. There are two queues in persistent memory,
shared among the N processes. Enqueuing allocates one
node of the queue while dequeueing de-allocates another
node, per transaction. This test executes during 100 seconds,
with N being 2, 4, 8, 16 or 32 processes and the number of
transactions per second are shown on the right-side plot of
Fig. 12 as no kill. We then repeated the same test, but with a
script that randomly kills one of the N processes, every 100
milliseconds and immediately re-spawns a similar process,
also shown on the right plot of Fig. 12. This means there
are 1,000 failures for the duration of the test.
From these results we can conclude the following: due to
the null-recovery property, OneFile provides fast recovery
time, with no measurable performance impact for the tested
scenario of 1,000 failures during 100 seconds; we never
observed memory leaks nor allocator metadata corruption
and no breakage of application invariants either; and the lack
of performance difference with and without processes being
killed shows that OneFile is resilient to failures, allowing
the non-failed processes to continue executing normally.
To help understand the factors that impact the perfor-
mance of the different PTMs in §V, we summarize in the
following table the number of pwb, pfence and synchro-
nization primitives on update transactions, as a function of
the number of modiﬁed words Nw in a transaction.
PMDK
RomulusLog
pwb
2.25 Nw
3 + 2N w
pfence CAS or DCAS
2 + 2N w
4 or less
1
1
OF (Lock-Free) 1 + 1.25 Nw
OF (Wait-Free) 2 + 1.25 Nw
0
0
2 +N w
3 +N w
VI. CONCLUSION
STMs have a bad reputation for mishandling large trans-
actions and high contention, and deservingly so. The wait-
free OneFile is immune to starvation and has predictable
latency, regardless of contention or transaction size.
Transactions in OneFile-PTM require two persistence
fences, are durable linearizable, and have bounded wait-
free progress including memory allocation, de-allocation and
reclamation. The novel technique for memory reclamation
in OneFile-PTM uses an optimistic approach that allows to
safely access memory locations with no need to announce
its access to concurrent threads. Furthermore, a transaction
with a de-allocation and allocation of an object of the same
size can re-use the same memory block, which reduces
the number of pwbs and improves cache locality. This
immediate re-usage of blocks is not possible on previously
known lock-free memory reclamation schemes.
So far in the current literature, a single lock-free data
structure has been shown for NVM, a lock-free queue [63].
We provide a generic approach with integrated memory
reclamation. With OneFile-PTM we have implemented for
NVM, a wait-free queue, a wait-free linked list set, a wait-
free resizable hash map, and a wait-free balanced tree. And
other containers can be implemented.
The initial intent of Herlihy and Moss’s paper [4] was to
propose Transactional Memory as a simple way of producing
lock-free data structures. It took more than 25 years but
ﬁnally, an efﬁcient and easy to use lock-free STM is now
available for users to develop their own lock-free and wait-
free data structures. Furthermore, OneFile-PTM goes above
this goal by giving end users the ability to design their own
failure-resilient wait-free data structures for NVM, enabling
them to create reliable applications with fast wait-free ACID
transactions with serializable isolation.
161
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 11:13:27 UTC from IEEE Xplore.  Restrictions apply. 
REFERENCES
[1] E. W. Dijkstra, “Cooperating sequential processes,” in The
origin of concurrent programming. Springer, 1968, pp. 65–
138.
[2] R. K. Treiber, Systems programming: Coping with par-
International Business Machines Incorporated,
allelism.
Thomas J. Watson Research Center New York, 1986.
[3] M. Herlihy, “Wait-free synchronization,” ACM Transactions
on Programming Languages and Systems (TOPLAS), vol. 13,
no. 1, pp. 124–149, 1991.
[4] M. Herlihy and J. E. B. Moss, Transactional memory: Archi-
tectural support for lock-free data structures. ACM, 1993,
vol. 21, no. 2.
[5] N. Shavit and D. Touitou, “Software transactional memory,”
Distributed Computing, vol. 10, no. 2, pp. 99–116, 1997.
[6] H. Volos, A. J. Tack, and M. M. Swift, “Mnemosyne:
Lightweight persistent memory,” in ACM SIGARCH Com-
puter Architecture News, vol. 39, no. 1. ACM, 2011, pp.
91–104.
[7] A. Correia, P. Felber, and P. Ramalhete, “Romulus: Efﬁcient
algorithms for persistent transactional memory,” in Proceed-
ings of the 30th on Symposium on Parallelism in Algorithms
and Architectures. ACM, 2018, pp. 271–282.
[8] J. Izraelevitz, H. Mendes, and M. L. Scott, “Linearizability
of persistent memory objects under a full-system-crash failure
model,” in International Symposium on Distributed Comput-
ing. Springer, 2016, pp. 313–327.
[9] D. E. Lowell and P. M. Chen, “Free transactions with rio
vista,” in ACM SIGOPS Operating Systems Review, vol. 31,
no. 5. ACM, 1997, pp. 92–101.
[10] J. Izraelevitz, T. Kelly, and A. Kolli, “Failure-atomic persis-
tent memory updates via justdo logging,” ACM SIGARCH
Computer Architecture News, vol. 44, no. 2, pp. 427–442,
2016.
[11] J. Coburn, A. M. Caulﬁeld, A. Akel, L. M. Grupp, R. K.
Gupta, R. Jhala, and S. Swanson, “Nv-heaps: making persis-
tent objects fast and safe with next-generation, non-volatile
memories,” ACM Sigplan Notices, vol. 46, no. 3, pp. 105–118,
2011.
[12] D. R. Chakrabarti, H.-J. Boehm, and K. Bhandari, “Atlas:
Leveraging locks for non-volatile memory consistency,” ACM
SIGPLAN Notices, vol. 49, no. 10, pp. 433–452, 2014.
[13] PMDK team, “Persistent Memory Programming,” http://
pmem.io, 2018.
[14] P. Felber, C. Fetzer, P. Marlier, and T. Riegel, “Time-based
software transactional memory,” IEEE Transactions on Paral-
lel and Distributed Systems, vol. 21, no. 12, pp. 1793–1807,
2010.
[15] P. Felber, C. Fetzer, and T. Riegel, “Dynamic performance
tuning of word-based software transactional memory,” in Pro-
ceedings of the 13th ACM SIGPLAN Symposium on Principles
and practice of parallel programming. ACM, 2008, pp. 237–
246.
[16] D. Hendler, I. Incze, N. Shavit, and M. Tzafrir, “Flat com-
bining and the synchronization-parallelism tradeoff,” in Pro-
ceedings of the twenty-second annual ACM symposium on
Parallelism in algorithms and architectures. ACM, 2010,
pp. 355–364.
[17] S. M. Fernandes and J. Cachopo, “Lock-free and scalable
multi-version software transactional memory,” in ACM SIG-
PLAN Notices, vol. 46, no. 8. ACM, 2011, pp. 179–188.
[18] J. Cachopo and A. Rito-Silva, “Versioned boxes as the basis
for memory transactions,” Science of Computer Program-
ming, vol. 63, no. 2, pp. 172–185, 2006.
[19] C. Fu, Z. Wu, X. Wang, and X. Yang, “A review of software
transactional memory in multicore processors,” Information
Technology Journal, vol. 8, no. 8, pp. 1269–1274, 2009.
[20] P. Felber, V. Gramoli, and R. Guerraoui, “Elastic transac-
tions,” in International Symposium on Distributed Computing.
Springer, 2009, pp. 93–107.
[21] D. Dice, O. Shalev, and N. Shavit, “Transactional locking
ii,” in International Symposium on Distributed Computing.
Springer, 2006, pp. 194–208.
[22] T. L. Harris, K. Fraser, and I. A. Pratt, “A practical multi-word
compare-and-swap operation,” in International Symposium on
Distributed Computing. Springer, 2002, pp. 265–279.
[23] K. Fraser and T. Harris, “Concurrent programming without
locks,” ACM Transactions on Computer Systems (TOCS),
vol. 25, no. 2, p. 5, 2007.
[24] M. Pavlovic, A. Kogan, V. J. Marathe, and T. Harris, “Brief
announcement: Persistent multi-word compare-and-swap,” in
Proceedings of the 2018 ACM Symposium on Principles of
Distributed Computing. ACM, 2018, pp. 37–39.
[25] T. Wang, J. Levandoski, and P.-A. Larson, “Easy lock-free
indexing in non-volatile memory,” in 2018 IEEE 34th Inter-
national Conference on Data Engineering (ICDE).
IEEE,
2018, pp. 461–472.
[26] A. Israeli and L. Rappoport, “Disjoint-access-parallel imple-
mentations of strong shared memory primitives,” in Proceed-
ings of the thirteenth annual ACM symposium on Principles
of distributed computing. ACM, 1994, pp. 151–160.
[27] H. Sundell, “Wait-free multi-word compare-and-swap using
greedy helping and grabbing,” International Journal of Par-
allel Programming, vol. 39, no. 6, pp. 694–716, 2011.
[28] S. Feldman, P. LaBorde, and D. Dechev, “A practical wait-
free multi-word compare-and-swap operation,” in Many-Core
Architecture Research Community (MARC) Symposium at
SPLASH, vol. 2013. Citeseer, 2013.
[29] S. Doherty, D. L. Detlefs, L. Groves, C. H. Flood,
V. Luchangco, P. A. Martin, M. Moir, N. Shavit, and G. L.
Steele Jr, “Dcas is not a silver bullet for nonblocking algo-
rithm design,” in Proceedings of the sixteenth annual ACM
symposium on Parallelism in algorithms and architectures.
ACM, 2004, pp. 216–224.
[30] S. R. Dulloor, “Systems and applications for persistent mem-
ory,” Ph.D. dissertation, Georgia Institute of Technology,
2015.
[31] N. Cohen, M. Friedman, and J. R. Larus, “Efﬁcient logging
in non-volatile memory by exploiting coherency protocols,”
Proceedings of the ACM on Programming Languages, vol. 1,
no. OOPSLA, p. 67, 2017.
[32] M. Herlihy, “A methodology for implementing highly con-
current data structures,” in ACM SIGPLAN Notices, vol. 25,
no. 3. ACM, 1990, pp. 197–206.
[33] P. Fatourou and N. D. Kallimanis, “A highly-efﬁcient wait-
free universal construction,” in Proceedings of the twenty-
162
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 11:13:27 UTC from IEEE Xplore.  Restrictions apply. 
third annual ACM symposium on Parallelism in algorithms
and architectures. ACM, 2011, pp. 325–334.
ence on Object-Oriented Programming, Systems, Languages,
and Applications. ACM, 2016, pp. 677–694.
[34] V. Bushkov and R. Guerraoui, “Liveness in transactional
memory,” in Transactional Memory. Foundations, Algorithms,
Tools, and Applications. Springer, 2015, pp. 32–49.
[35] P. E. McKenney and J. D. Slingwine, “Read-copy update:
Using execution history to solve concurrency problems,” in
Parallel and Distributed Computing and Systems, 1998, pp.
509–518.
[36] M. M. Michael, “Hazard pointers: Safe memory reclamation
for lock-free objects,” IEEE Transactions on Parallel and
Distributed Systems, vol. 15, no. 6, pp. 491–504, 2004.
[37] M. Herlihy, V. Luchangco, and M. Moir, “The repeat offender
problem: A mechanism for supporting dynamic-sized lock-
free data structures,” 2002.
[38] A. Braginsky, A. Kogan, and E. Petrank, “Drop the an-
chor: lightweight memory management for non-blocking data
structures,” in Proceedings of the twenty-ﬁfth annual ACM
symposium on Parallelism in algorithms and architectures.
ACM, 2013, pp. 33–42.
[39] N. Cohen and E. Petrank, “Efﬁcient memory management for
lock-free data structures with optimistic access,” in Proceed-
ings of the 27th ACM symposium on Parallelism in Algorithms
and Architectures. ACM, 2015, pp. 254–263.
[40] ——, “Automatic memory reclamation for lock-free data
structures,” in ACM SIGPLAN Notices, vol. 50, no. 10. ACM,
2015, pp. 260–279.
[41] P. Ramalhete and A. Correia, “Brief announcement: Hazard
eras-non-blocking memory reclamation,” in Proceedings of
the 29th ACM Symposium on Parallelism in Algorithms and
Architectures. ACM, 2017, pp. 367–369.
[42] D. Alistarh, P. Eugster, M. Herlihy, A. Matveev, and
N. Shavit, “Stacktrack: An automated transactional approach
to concurrent memory reclamation,” in Proceedings of the
Ninth European Conference on Computer Systems. ACM,
2014, p. 25.
[43] T. A. Brown, “Reclaiming memory for lock-free data struc-
tures: There has to be a better way,” in Proceedings of the
2015 ACM Symposium on Principles of Distributed Comput-
ing. ACM, 2015, pp. 261–270.
[44] D. Alistarh, W. M. Leiserson, A. Matveev, and N. Shavit,
“Threadscan: Automatic and scalable memory reclamation,”
in Proceedings of the 27th ACM symposium on Parallelism
in Algorithms and Architectures. ACM, 2015, pp. 123–132.
[45] D. Dice, M. Herlihy, and A. Kogan, “Fast non-intrusive
memory reclamation for highly-concurrent data structures,”
in Proceedings of the 2016 ACM SIGPLAN International
Symposium on Memory Management. ACM, 2016, pp. 36–
45.
[46] H. Wen, J. Izraelevitz, W. Cai, H. A. Beadle, and M. L. Scott,
“Interval-based memory reclamation,” in Proceedings of the
23rd ACM SIGPLAN Symposium on Principles and Practice
of Parallel Programming. ACM, 2018, pp. 1–13.
[47] M. Pöter and J. L. Träff, “Stamp-it: A more thread-efﬁcient,
concurrent memory reclamation scheme in the c++ memory
model,” arXiv preprint arXiv:1805.08639, 2018.
[48] K. Bhandari, D. R. Chakrabarti, and H.-J. Boehm, “Makalu:
Fast recoverable allocation of non-volatile memory,” in Pro-
ceedings of the 2016 ACM SIGPLAN International Confer-
[49] T. David, A. Dragojevic, R. Guerraoui, and M. I. Zablotchi,
“Log-free concurrent data structures,” Tech. Rep., 2017.
[50] M. M. Michael and M. L. Scott, “Simple, fast, and practical
non-blocking and blocking concurrent queue algorithms,”
in Proceedings of the ﬁfteenth annual ACM symposium on
Principles of distributed computing. ACM, 1996, pp. 267–
275.
[51] P. Ramalhete and A. Correia, “Poster: A wait-free queue with
wait-free memory reclamation,” in Proceedings of the 22nd
ACM SIGPLAN Symposium on Principles and Practice of
Parallel Programming. ACM, 2017, pp. 453–454.
[52] A. Morrison and Y. Afek, “Fast concurrent queues for x86
processors,” in ACM SIGPLAN Notices, vol. 48, no. 8. ACM,
2013, pp. 103–112.
[53] P. Ramalhete and A. Correia, “Faaarrayqueue — mpmc
lock-free queue,” http://www.concurrencyfreaks.com/2016/
11/faaarrayqueue-mpmc-lock-free-queue-part.html, 2016.
[54] M. M. Michael, “High performance dynamic lock-free hash
tables and list-based sets,” in Proceedings of the fourteenth
annual ACM symposium on Parallel algorithms and architec-
tures. ACM, 2002, pp. 73–82.
[55] T. L. Harris, “A pragmatic implementation of non-blocking
linked-lists,” in International Symposium on Distributed Com-
puting. Springer, 2001, pp. 300–314.
[56] A. Natarajan and N. Mittal, “Fast concurrent lock-free binary
search trees,” in ACM SIGPLAN Notices, vol. 49, no. 8.
ACM, 2014, pp. 317–328.
[57] T. Brown, F. Ellen, and E. Ruppert, “A general technique
for non-blocking trees,” in ACM SIGPLAN Notices, vol. 49,
no. 8. ACM, 2014, pp. 329–342.
[58] Y. Lu, J. Shu, and L. Sun, “Blurred persistence in trans-
actional persistent memory,” in Mass Storage Systems and
Technologies (MSST), 2015 31st Symposium on.
IEEE, 2015,
pp. 1–13.
[59] Y. Lu, J. Shu, L. Sun, and O. Mutlu, “Loose-ordering consis-
tency for persistent memory,” in Computer Design (ICCD),
2014 32nd IEEE International Conference on.
IEEE, 2014,
pp. 216–223.
[60] V. Gogte, S. Diestelhorst, W. Wang, S. Narayanasamy, P. M.
Chen, and T. F. Wenisch, “Persistency for synchronization-
free regions.” PLDI, 2018.
[61] M. Liu, M. Zhang, K. Chen, X. Qian, Y. Wu, W. Zheng, and
J. Ren, “Dudetm: Building durable transactions with decou-
pling for persistent memory,” in Proceedings of the Twenty-
Second International Conference on Architectural Support for
Programming Languages and Operating Systems.
ACM,
2017, pp. 329–343.
[62] A. Memaripour, A. Badam, A. Phanishayee, Y. Zhou, R. Ala-
gappan, K. Strauss, and S. Swanson, “Atomic in-place updates
for non-volatile main memories with kamino-tx,” in Pro-
ceedings of the Twelfth European Conference on Computer
Systems. ACM, 2017, pp. 499–512.
[63] M. Friedman, M. Herlihy, V. Marathe, and E. Petrank, “A
persistent lock-free queue for non-volatile memory,” in Pro-
ceedings of the 23rd ACM SIGPLAN Symposium on Princi-
ples and Practice of Parallel Programming. ACM, 2018,
pp. 28–40.
163
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 11:13:27 UTC from IEEE Xplore.  Restrictions apply.