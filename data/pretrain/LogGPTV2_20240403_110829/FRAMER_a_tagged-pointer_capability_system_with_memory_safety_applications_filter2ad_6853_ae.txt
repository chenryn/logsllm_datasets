### 优化后的文本

#### 图9：归一化最大驻留集大小
- perlbench
- bzip2
- h264
- ks
- anag

0 - 访问头
20 - 访问条目
40 - 分支
60 - 计算
80 - 去标签
100

#### 图10：元数据管理和检索的运行时开销（不包括边界检查）
MPKI（缓存未命中）和分支预测未命中 MPKI。基线 D 缓存未命中率为 2.48%（表 2），但在启用 FRAMER 后，由于对同一缓存数据的重复访问，该比率有所改善。

在图 11 中，我们将缓存未命中归一化为未检测的数据。平均归一化缓存未命中率分别为 store-only 模式的 0.66 和 full-checking 模式的 0.38。未命中率降低是因为我们添加的操作具有高缓存亲和性，从而稀释了应用程序的基本未命中率。

尽管 ASan 在四个测试中显示了增加，但 ASan 的平均归一化未命中率为 0.73，高于 FRAMER 的 0.38。ASan 的最高开销是 bc 的 197%，有两个测试的开销超过 100%。对于 FRAMER，power 的开销为 48%，主要是由于指令执行数量的轻微增加导致 MPKI 的产生。其余基准测试的未命中率下降，在 full-checking 模式下，28 个测试中有 21 个的归一化未命中率低于 0.5，而 ASan 只有 13 个测试低于 0.5。总体缓存未命中率表明 FRAMER 是高效的且稳定的。

虽然随着指令数量的膨胀，缓存未命中（MPKI）可能看起来减少，但我们还展示了总缓存未命中数的增加。图 13 显示了 SPEC 中大型程序的归一化缓存未命中数。FRAMER (Full) 和 ASan 的平均值分别为 1.24 和 2.40，整个测试集的平均值分别为 1.40 和 2.31。这表明 FRAMER 访问元数据时缓存未命中数的增加是最小的。在 FRAMER 上，除一个测试（voronoi 的 277%）外，所有测试的增加率都低于 100%。在 ASan 上，有 7 个测试的增加率超过 100%，bc 的增加率为 1160%。

#### 7.4 执行的指令
图 12 报告了每个基准测试的归一化开销。FRAMER 在 store-only 模式下增加了 124% 的动态指令计数，在 full checking 模式下增加了 425%。这种增加是导致性能下降的主要原因。动态指令惩罚来自设置和使用标记指针。主要的增长来源是算术操作。如图 10 所示，元数据管理和检索的 75% 运行时开销是由（1）内存访问时头部地址的计算和（2）分配时标签的计算所主导的。这种成本可以通过硬件加速与 ISA 解决。

利用顶部位的惩罚是过度检测——除非静态证明单个内存访问是无标签的，否则我们必须对其进行检测（即清除标签），以避免在所有主要架构中发生段错误，要求顶部位为零（或 ARM8 中的特殊指针认证代码）。这导致剥离无标签指针的标签字段。

ASan 的平均开销为 226%，低于 FRAMER。排除最高测试（bh 的 1336%）后的平均值为 184%，而 FRAMER 排除最高测试（mcf 的 1098%）后的平均值为 400%。平均减速的差异（FRAMER: 213%，ASan: 139%）并不大，这是由于 FRAMER 的缓存效率。ASan 使用较少的动态指令，因为仅存储影子空间元数据有助于简化元数据位置的推导，利用对象的重新对齐，作为空间和高局部性的权衡。

未来的实现可以优化保守分析揭示不需要添加标签的情况。更多关于优化的讨论见第 8.3 节。

#### 图 11：每千条指令归一化的 L1 D 缓存加载未命中数 (MPKI)

#### 图 12：归一化的动态指令计数

#### 图 13：归一化的 L1 D 缓存加载未命中数

#### 7.5 分支未命中
FRAMER 中的额外条件分支来自于检查是否使用小帧或大帧以及指针有效性检查本身。许多使用影子空间的方法在元数据检索时免去了这些分支。

如表 2 第 7 列所示，FRAMER 仪器下的动态分支密度略有下降，但分支误预测率大大降低（第 8 列）。store-only 和 full-checking 的归一化分支未命中率分别为 0.62 和 0.42。这表明额外的分支实现了高度准确的分支预测，并且分支预测器没有过载。新增的分支中，检查小/大帧大小的分支完全可静态预测，因为检查代码实例与给定对象相关联。而检查指针有效性的分支也完美预测，因为未检测到任何越界错误。

#### 8 讨论
##### 8.1 与其他方法的比较
基于影子空间的方法通过减少执行指令来降低减速。在大多数系统开发过程中，数据内存的权衡是可以接受的。然而，在实际部署中，它们的减速仍然很高，某些系统中的内存占用非常关键，例如在嵌入式系统或 I/O 密集型服务器负载中运行的 ARM。使用影子空间时，不可避免地需要填充和重新对齐对象以避免条目冲突 [3, 25, 39]。ASan 为每个对象进行填充以获得更广泛的检测范围和更多的对齐填充，这会增加空间负担，而 FRAMER 的虚假填充和包装帧不会消耗任何空间。此外，它们在访问远程内存区域中的元数据时会有更高的缓存未命中（包括 ASan 在释放时重置条目），使其运行时开销不可预测。

与 ASan 相比，FRAMER 在内存占用（FRAMER: 23%，ASan: 784%）和缓存未命中数开销（FRAMER: 40%，ASan: 131%）方面表现出更好的效率。ASan 显示了较高的缓存未命中率和较大的内存占用。