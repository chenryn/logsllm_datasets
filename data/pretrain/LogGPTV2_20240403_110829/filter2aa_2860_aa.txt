1
Julian Grizzard
DEFCON 13
Surgical Recovery from
Kernel-Level Rootkit Installations
Linux Based Systems
Julian Grizzard
July 2005
DEFCON THIRTEEN
2
Julian Grizzard
DEFCON 13
Latest Slides and Tools
PLEASE DOWNLOAD THE LATEST SLIDES AND TOOLS
[ Latest slides available ]
http://www.ece.gatech.edu/research/labs/nsa/presentations/dc13_grizzard.pdf
[ Latest system call table tools ]
http://www.ece.gatech.edu/research/labs/nsa/sct_tools.shtml
[ Latest spine architecture work ]
http://www.ece.gatech.edu/research/labs/nsa/spine.shtml
3
Julian Grizzard
DEFCON 13
Problem
What does a rootkit do?
• Retain Access
– Trojan sshd client with hard coded user/pass for root
access
– Initiate remote entry by specially crafted packet
stream
• Hide Activity
– Hide a process including resource usage of process
– Hide malicious rootkit kernel modules from lsmod
4
Julian Grizzard
DEFCON 13
Most Widely Accepted Solution
Format and Reinstall
5
Julian Grizzard
DEFCON 13
Monolithic Operating System
6
Julian Grizzard
DEFCON 13
Kernel Space
7
Julian Grizzard
DEFCON 13
User Space
8
Julian Grizzard
DEFCON 13
Microkernel Operating System
9
Julian Grizzard
DEFCON 13
Microkernel Operating System
10
Julian Grizzard
DEFCON 13
Microkernel Operating System
11
Julian Grizzard
DEFCON 13
Intel Descriptor Privilege Level
•
Level 3
– Minimal hardware access
– User space processes run at
level 3
•
Level 2
– Limited hardware access
– N/A in Linux
•
Level 1
– Limited hardware access
– N/A in Linux
•
Level 0
– Unlimited hardware access
– Kernel space threads run at
level 0
Kernel Space
User Space
12
Julian Grizzard
DEFCON 13
Testing Privilege Level - User (R3)
#include 
#include 
int main()
{
        uint16_t cs_reg;
        asm("mov %%cs,%0" : "=m" (cs_reg));
        cs_reg = cs_reg & 0x0003;
        printf("ring: %d\n", cs_reg);
        return 0;
}
13
Julian Grizzard
DEFCON 13
Testing Privilege Level - User (R3)
14
Julian Grizzard
DEFCON 13
Testing CPL - Kernel (R0)
#include 
#include 
#include 
static int __init get_cpl_init(void)
{
        uint16_t cs_reg;
        asm("mov %%cs,%0" : "=m" (cs_reg));
        cs_reg = cs_reg & 0x0003;
        printk(KERN_ALERT "ring: %d\n", cs_reg);
        return 0;
}
static void __exit get_cpl_exit(void)
{
}
module_init(get_cpl_init);
module_exit(get_cpl_exit);
15
Julian Grizzard
DEFCON 13
Testing CPL - Kernel (R0)
16
Julian Grizzard
DEFCON 13
User-Level Rootkit Attacks
Modify/replace system binaries
e.g. ps, netstat, ls, top, passwd
17
Julian Grizzard
DEFCON 13
User-Level Rootkit Attacks
Modify/replace system binaries
e.g. ps, netstat, ls, top, passwd
18
Julian Grizzard
DEFCON 13
Kernel-Level Rootkit Attacks
Modify running kernel code and data structures
19
Julian Grizzard
DEFCON 13
Example 1 (System Call Table)
20
Julian Grizzard
DEFCON 13
0x80ith IDT Entry Lookup
21
Julian Grizzard
DEFCON 13
System Call Handler
22
Julian Grizzard
DEFCON 13
System Call Lookup
23
Julian Grizzard
DEFCON 13
System Call Executes
24
Julian Grizzard
DEFCON 13
Attack Points
25
Julian Grizzard
DEFCON 13
Manual Recovery Algorithm
1)
Copy clean system calls to kernel memory
(get from kernel image with modified gdb)
2)
Create new system call table
3)
Copy system call handler to kmem (set new
SCT)
4)
Query the idtr register (interrupt table)
5)
Set 0x80ith entry to new handler
26
Julian Grizzard
DEFCON 13
Copying Kernel Functions
• Some trickery involved with algorithm
• x86 code has call instructions with a
relative offset parameter
• Could recompile the code
• Chose to recompute relative offset and
modify the machine code
27
Julian Grizzard
DEFCON 13
/dev/kmem Details from SucKIT
• SucKIT accesses kernel memory from
user space
• Redirects entire system call table
• How does sucKIT find the system call
table?
• How does sucKIT allocate kernel
memory?
28
Julian Grizzard
DEFCON 13
Find System Call Handler
struct idtr idtr;
struct idt idt80;
ulong old80;
/* Pop IDTR register from CPU */
asm("sidt %0" : "=m" (idtr));
/* Read kernel memory through /dev/kmem */
rkm(fd, &idt80, sizeof(idt80), idtr.base +
0x80 * sizeof(idt80));
/* Compute absolute offset of
 * system call handler for kmem
 */
old80 = idt80.off1 | (idt80.off2 << 16);
29
Julian Grizzard
DEFCON 13
Find System Call Handler
struct idtr idtr;
struct idt idt80;
ulong old80;
/* Pop IDTR register from CPU */
asm("sidt %0" : "=m" (idtr));
/* Read kernel memory through /dev/kmem */
rkm(fd, &idt80, sizeof(idt80), idtr.base +
0x80 * sizeof(idt80));
/* Compute absolute offset of
 * system call handler for kmem
 */
old80 = idt80.off1 | (idt80.off2 << 16);
30
Julian Grizzard
DEFCON 13
Find System Call Handler
struct idtr idtr;
struct idt idt80;
ulong old80;
/* Pop IDTR register from CPU */
asm("sidt %0" : "=m" (idtr));
/* Read kernel memory through /dev/kmem */
rkm(fd, &idt80, sizeof(idt80), idtr.base +
0x80 * sizeof(idt80));
/* Compute absolute offset of
 * system call handler for kmem
 */
old80 = idt80.off1 | (idt80.off2 << 16);
31
Julian Grizzard
DEFCON 13
Find System Call Handler
struct idtr idtr;
struct idt idt80;
ulong old80;
/* Pop IDTR register from CPU */
asm("sidt %0" : "=m" (idtr));
/* Read kernel memory through /dev/kmem */
rkm(fd, &idt80, sizeof(idt80), idtr.base +
0x80 * sizeof(idt80));
/* Compute absolute offset of
 * system call handler for kmem
 */
old80 = idt80.off1 | (idt80.off2 << 16);
32
Julian Grizzard
DEFCON 13
Kmalloc as a System Call (sucKIT)
#define rr(n, x) ,n ((ulong) x)
#define __NR_oldolduname 59
#define OURSYS __NR_oldolduname
#define syscall2(__type, __name, __t1, __t2)    \
   __type __name(__t1 __a1, __t2 __a2)          \
   {                                            \
      ulong __res;                              \
      __asm__ volatile                          \
      ("int $0x80"                              \
      : "=a" (__res)                            \
      : "0" (__NR_##__name)                     \
      rr("b", __a1)                             \
      rr("c", __a2));                           \
      return (__type) __res;                    \
   }
#define __NR_KMALLOC OURSYS
static inline syscall2(ulong, KMALLOC, ulong, ulong);
33
Julian Grizzard
DEFCON 13
Demos
System Call Table Tools
Demonstration
34
Julian Grizzard
DEFCON 13
System Calls Used for Recovery
• Using /dev/kmem
– sys_open, sys_read, sys_write
• Using kernel module
– sys_create_module, sys_init_module
Problem: system call table has been
redirected by a rootkit
35
Julian Grizzard
DEFCON 13
Solution
• Intrusion Recovery System (IRS)
– Use spine architecture to minimize chance of
rootkit attack
– IRS capable of verifying integrity of system
– Contains copy of known good state for entire
system (including kernel) in isolated area
called statehold
36
Julian Grizzard
DEFCON 13
Spine - Based on Microkernel
37
Julian Grizzard
DEFCON 13
Spine - Based on Microkernel
20,000 lines of code - small
38
Julian Grizzard
DEFCON 13
L4 System Calls (Fiasco)
• 9 IPC Calls
– l4_ipc_call, l4_ipc_receive
– l4_ipc_reply_and_wait
– l4_ipc_send_deceiting, l4_ipc_reply_deciting_and_wait
– l4_ipc_send, l4_ipc_wait
– l4_nchief
– l4_fpage_unmap
• 5 Thread calls
– l4_myself
– l4_task_new
– l4_thread_ex_regs
– l4_thread_schedule
– l4_thread_switch
39
Julian Grizzard
DEFCON 13
Spine Architecture
40
Julian Grizzard
DEFCON 13
Spine Architecture - Microkernel
Use Fiasco L4 implementation
41
Julian Grizzard
DEFCON 13
Spine Architecture - Guest
L4Linux runs on top of Fiasco
42
Julian Grizzard
DEFCON 13
Spine Architecture - Processes
User processes run on L4Linux
43
Julian Grizzard
DEFCON 13
Spine Architecture - Separation
Only Fiasco runs in kernel mode
44
Julian Grizzard
DEFCON 13
Spine Architecture - IRS
Component of IRS at each level
45
Julian Grizzard
DEFCON 13
Memory Hierarchy Detail
46
Julian Grizzard
DEFCON 13
Memory Hierarchy Detail