## Page 369
8.7.1消除冗余的加载和保存指令
的，这两个指令必须在同一个基本块内。
在第二个指令之前执行，因此不能删除这个保存指令。换句话说，为了保证这样的转换是安全
经被加载到寄存器 RO中。请注意，假如保存指令有-一-个标号，我们就不能保证第一个指令总是
我们就可以删除其中的保存指令，因为不管这个保存指令何时执行，第--个指令将保证a的值已
特点的程序变换的例子。
来说，为了获得最大的好处就需要多次扫描目标代码。在本节中，我们将给出下列具有窥孔优
尽管有些实现要求代码连续。窥孔优化的特点是每一次改进又可能产生出新的优化机会。一般
示形式的质量。
的指令来替换窗口中的指令序列。也可以在中间代码生成之后直接应用窥孔优化来提高中间表
优化的时候检查目标指令的一个滑动窗口（即窥孔），并且只要有可能就在窥孔内用更快或更短
下都是最优的。不管怎么说，很多简单的转换可以有效地改善目标程序的运行时间和空间需求。
的质量。这里使用术语“优化”具有一定的误导性，因为不能保证得到的代码在任何数学度量之
译器使用另一种策略：它们先生成原始的代码，然后对目标代码进行“优化"转换，提高目标代码
8.7
中得到的三地址代码转换为机器代码。请给出每一个步骤之后的寄存器和地址描述符。
假设你有任意多个寄存器可用。
的首元素(第0个元素)。重复练习8.6.1的4 和5 部分。
和在本章之前有关数组访问的例子中一样，它们给出了同名数组的第0个元素的位置。
假设其中的所有数组元素都是整数，每个元素占四个字节。在4 和5 部分，假设a、b、c是常数。
练习8.6.3：把在练习8.6.1中得到的三地址代码转换为本节给出的机器模型的机器代码
代码生成
窥孔是程序上的一个小的滑动窗口。窥孔优化技术并不要求在窥孔中的代码一定是连续的
--个简单却有效的、用于局部改进目标代码的技术是窥孔优化（peephole optimization）。它在
虽然大部分编译器产品通过仔细的指令选择和寄存器分配来生成优质代码，但还有一些编
练习8.6.5：重复练习8.6.4，但是假设只有两个可用的寄存器。
练习8.6.4：假设有三个可用的寄存器，使用本节中的简单代码生成算法，把在练习8.6.1
这种类型的冗余加载/保存指令不会由前一节中的简单代码生成算法生成。但是，一个类似
！练习8.6.2:假设数组 a、b、c 分别通过指针 pa、pb 和 pc 定位。这些指针指向各自数组
如果我们在目标程序中看到指令序列
机器特有指令的使用
·控制流优化
●冗余指令消除
窥孔优化
++b*=++d*（9
5) a[i][j] =b[i][k] +c[k][];
4)a[i] =b[c[i]];
l)x= a + b*c;
代数化简
353
---
## Page 370
可以被替换为序列
可以被替换为序列
消除这个语句。
替换为
可以通过下面几种窥孔优化技术从中间代码或者目标代码中消除。我们可以把序列
转指令的无条件跳转指令，或者到达无条件跳转指令的条件跳转指令。这些不必要的跳转指令
8.7.3控制流优化
打印调试信息的所有语句都变成了不可达语句，因此可以被逐一消除。
的代码序列可以被替换为：
个代码看起来可能就像
型程序中可能含有一些只有当变量debug 等于1时才运行的代码片断。在中间表示形式中，这
令可以被删除。通过重复这个运算，就可以删除一个指令序列。比如，为了调试的目的，一个大
8.7.2消除不可达代码
于8.1.3节中的原始的代码生成器可能生成类似的冗余代码序列。
简单的中间代码生成算法经常生成目标为无条件跳转指令的无条件跳转指令，到达条件跳
另一个窥孔优化的机会是消除不可达的指令。一个紧跟在无条件跳转之后的不带标号的指
354
最后，假设只有一个到达 Li 的跳转指令，且L1 之前是一个无条件跳转指令，那么序列
L1: goto L2
类似地，序列
如果没有跳转到L1 的指令，并且语句L1：goto L2之前是一个无条件跳转指令，所以可以
L1: goto L2
L1: goto L2
L1: goto L2
现在，第一个语句的条件值总是true，因此这个语句可以被替换为 goto L2。替换之后，
如果 debug 在程序开始的时候被设置为 0，常量传播优化将把这个序列转换为
L2:
一个显而易见的窥孔优化方法是消除级联跳转指令。因此，不管 debug 的值是什么，上面
L2:
gotoL1
if a< b goto L2
goto
print debugging information
 print debugging information
a<b goto L1
第8章
---
## Page 371
生成很多不必要的其他寄存器的加载和保存运算指令。虽然如此，在大多数计算环境中还是要
器的使用效率较低：有些被占用的寄存器在相当数量的代码运行中没有被使用到，同时却不得不
的寄存器，等等。
可以确定把基地址指派给一组寄存器，算术计算则使用另一组寄存器，栈顶指针指派给一个固定
常重要的。本节将给出不同的策略，用于确定在程序的每个点上，哪个值应该存放在寄存器口
上，处理器速度要比内存速度快一个数量级以上。因此，寄存器的有效利用对生成优质代码是非
8. 8
强度消减。
8.7.68.7节的练习
（寄存器分配)以及各个值应该存放在哪个寄存器中(寄存器指派)。
在使用一个运算分量的值之前或之后，将运算分量的值自动加一或减一。在参数传递时的压栈
况可以显著地降低运行时间。比如，有些机器具有自动增量和自动减量的寻址模式。这些指
8.7.5使用机器特有的指令
数
价运算的特殊情况来使用。比如，用x*x实现x²的代价总是比通过调用求幂函数实现x²的代
低的等价运算。有些机器指令和另--些指令相比其代价要低很多，它们经常被当作相应的高代
的三地址语句。
或者 
化器用于消除窥孔中类似于
8.7.4代数化简和强度消减
而在第一个序列中却不可能。因此，第二个序列的运行时间要优于第一-个序列的运行时间。
成
1
这个方法的优点是使代码生成器的设计变得简单。但因为它的应用有太多限制，所以寄存
的代码中使用。
出栈运算中使用这个模式可以大大提高代码的质量。这个模式也可以在类似于×=×+1的语
点。
为常数的浮点除法可以通过乘数为该常量倒数的乘法来求近似值。后一种做法的代价要小
要低。对于乘数(除数)为2的幂的定点数乘法(除法），用移位运算实现的代价要低一些。除
在8.5节，我们讨论了可以用于简化 DAG的代数恒等式。这些代数恒等式也可以被窥孔优
代码生成
寄存器分配和指派的方法之一是把目标程序中的特定值分配给特定的寄存器。比如，我们
目标机可能会有一些能够高效实现某些特定运算的硬件指令。检测允许使用这些指令的情
类似地，强度消减转换也可以应用到窥孔中，把代价比较高的运算替换为目标机器上代价较
只涉及寄存器运算分量的指令要比那些涉及内存运算分量的指令运行得快。在现代的机器
练习8.7.3：构造一个算法，它可以在目标机器代码上的滑动窥孔中进行简单的代数简化和
练习8.7.1：构造一个算法，它可以在目标机器代码上的滑动窥孔中进行冗余指令消除。
X=X*1
X=X+0
练习8.7.2：构造一个算法，它可以在目标机器代码上的滑动窥孔中进行控制流优化。
虽然两个序列中的指令个数相同，但是在第二个序列中我们有时可以跳过无条件跳转指令，
寄存器分配和指派
L3:
if a<b goto L2
355
中
---
## Page 372
的假设之上的。因此在特定的机器上，有可能需要设计--个与式(8.1)类似，但具有一定差异的
是因为一个循环中的各基本块的运行频率实际是不同的，也因为式(8.1)是基于循环被多次选代
予一个值，则liue(x,B)的取值为1，否则live(x，B)为0。请注意，式8.1只是一个估算公式。这
其中，use(x，B)是x在B 中被定值之前被使用的次数。如果在B的出口处活跃并在B 中被赋
此，在循环L中把一个寄存器分配给所得到的好处的－-个估算公式是
循环将迭代多次，我们可以忽略这些支出。因为每次进入循环时，这些指令只会运行一次。因
在B 的某个L之外的后继的入口处活跃，我们必须以2个单位的代价把×保存起来。然而，假设
寄存器中。这个加载的成本是两个成本单元。类似地，对于循环L的每个出口基本块B，如果x
处活跃的基本块，手
指令和之后的加载指令。因此，如果×被分配在某个寄存器中，对于每个向×赋值且在其出口
如果我们能够避免在某个基本块的结尾把×保存回内存，我们也可以省略2个单位的开销：保存
被使用，且在同一基本块中×没有被先行赋值时，我们才认为这次使用节约了一个单位的开销
加载的)成本。然而，如果x在一个基本块中被计算之后又在同--个基本块中被使用，那么当
销。在本节我们假设，如果把x分配在寄存器中，对的每一次引用可以节省--个单位的（用于
8.8.2使用计数
程序运行的热点代码。
多程序的运行速度，但是应该鼓励程序员在分配寄存器之前先获取程序的运行时刻特征并确定
来使得某些值在一个过程运行期间都保存在寄存器中。明智地使用寄存器声明确实可以提高很
分配的最佳数量。但是这个方法实现起来很简单，它曾经被用在 Fortran H 中。这是 IBM 在 20 世
不同的循环中所选择的值也有所不同。没有被分配的寄存器可以如8.6 节中说的那样用于存放
使用。下一个章将介绍用于计算这些信息的技术。
设我们知道一个流图的循环结构，并且我们知道在一个基本块中计算的哪些值会在该基本块外
寄存器指派方法是试图在整个循环中把频繁使用的值存放在固定的寄存器中。从现在开始，假
(即全局的)指派保持一致。因为程序的大部分时间花在它的内部循环上，所以一个自然的全局
指令，我们可以把一些寄存器指派给频繁使用的变量，并且使得这些寄存器在不同基本块中的
块的结尾处，所有活跃变量的值都被保存到内存中。为了省略一部分这样的保存及相应的加载
8.8.1全局寄存器分配
公式。
用
纪
用
保留一些寄存器。这些被保留的寄存器可以被用作基址寄存器、栈顶指针寄存器或其他类似的
用8.6节中的算法来生成基本块代码时，有很大的机会被仍然保存在寄存器中。（因此对的
在早期的C编译器中，程序员可以明确地参与某些寄存器分配过程。他们使用寄存器声明
60 年代后期为360系列计算机开发的Fortran 优化编译器。
8.6节中的代码生成算法在单个基本块的运行期间使用寄存器来存放值。但是，在每个基本
在支出方面，如果×在循环头部的人口处活跃，我们必须在进人循环L之前把加载到它的
途。其他寄存器则由代码生成器在它认为适当的时候使用。
通过在循环L运行时把一个变量保存在寄存器里面，我们可以节省从内存中加载的开
全局寄存器分配的策略之一-是分配固定多个寄存器来存放每个内部循环中最活跃的值。在
356
我们节省了两个单位的开销。
use(x,B) +2*live(x,B)
第8章
(8.1)
使
---
## Page 373
像通常那样把代码显示成为一个序列。
8-17中，我们没有为略去的各个基本块结尾处的条件或无条件跳转指令生成代码，因此我们没有
节中介绍的策略用于生成各个基本块的代码，图8-18 显示了根据图 8-17生成的汇编代码。在图
别选择 a、b、d。把 RO 用于存放é 或f是另一种选择，显然这样做具有同样的收益。假设 8.6
位。对b、c、d、e和f，式(8.1)的值分别是5、3、6、4 和4。因此，我们可以为 R0、R1、R2 分
式(8.1)的值是4。也就是说，如果选择某个全局寄存器来存放a 的值，可以节约的4 个成本单
们观察到a 在B，的出口处活跃且在B，中
入口处活跃的变量的并集。
般
处
的结尾处活跃，但是只有é在 B2的人口
方
的活跃变量分别显示在基本块的上方和下
图8-17中，各个基本块的人口处/出口
放整个循环范围内的值。为方便起见，在
略了。假设寄存器 RO、R1 和 R2 用于存
例8.17
集合是那些在该基本块的后继基本块的
来说，在一个基本块的结尾处活跃的变
活跃，只有在 B的人口处活跃。一
复杂问题。比如,请注意e 和f 都在 B
。我们将在下一章中讨论关于活跃变量
代码生成
为了计算当x=α时式(8.1)的值，
考虑图8-17中所示的内部循环中的基本块。图中的跳转指令和条件跳转指令都被省
图 8-18使用全局寄存器指派的代码序列
，我