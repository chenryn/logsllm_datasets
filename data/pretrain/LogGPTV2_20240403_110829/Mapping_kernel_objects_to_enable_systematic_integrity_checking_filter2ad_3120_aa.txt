title:Mapping kernel objects to enable systematic integrity checking
author:Martim Carbone and
Weidong Cui and
Long Lu and
Wenke Lee and
Marcus Peinado and
Xuxian Jiang
Mapping Kernel Objects to Enable Systematic
Integrity Checking
Martim Carbone
Weidong Cui
Long Lu
Georgia Institute of Technology
Atlanta, GA, USA
PI:EMAIL
Microsoft Research
Redmond, WA, USA
PI:EMAIL
Georgia Institute of Technology
Atlanta, GA, USA
PI:EMAIL
Wenke Lee
Georgia Institute of Technology
Atlanta, GA, USA
PI:EMAIL
Marcus Peinado
Microsoft Research
Redmond, WA, USA
PI:EMAIL
Xuxian Jiang
North Carolina State University
Raleigh, NC, USA
PI:EMAIL
ABSTRACT
Keywords
Dynamic kernel data have become an attractive target for kernel-
mode malware. However, previous solutions for checking kernel
integrity either limit themselves to code and static data or can only
inspect a fraction of dynamic data, resulting in limited protection.
Our study shows that previous solutions may reach only 28% of the
dynamic kernel data and thus may fail to identify function pointers
manipulated by many kernel-mode malware.
To enable systematic kernel integrity checking, in this paper we
present KOP, a system that can map dynamic kernel data with nearly
complete coverage and nearly perfect accuracy. Unlike previous
approaches, which ignore generic pointers, unions and dynamic ar-
rays when locating dynamic kernel objects, KOP (1) applies inter-
procedural points-to analysis to compute all possible types for generic
pointers (e.g., void*), (2) uses a pattern matching algorithm to re-
solve type ambiguities (e.g., unions), and (3) recognizes dynamic
arrays by leveraging knowledge of kernel memory pool boundaries.
We implemented a prototype of KOP and evaluated it on a Win-
dows Vista SP1 system loaded with 63 kernel drivers. KOP was
able to accurately map 99% of all the dynamic kernel data.
To demonstrate KOP’s power, we developed two tools based on
it to systematically identify malicious function pointers and un-
cover hidden kernel objects. Our tools correctly identiﬁed all mali-
cious function pointers and all hidden objects from nine real-world
kernel-mode malware samples as well as one created by ourselves,
with no false alarms.
Categories and Subject Descriptors
D.4.6 [OPERATING SYSTEMS]: Security and Protection; F.3.2
[LOGICS AND MEANINGS OF PROGRAMS]: Semantics of
Programming Languages—Program analysis
General Terms
Security
Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proﬁt or commercial advantage and that copies
bear this notice and the full citation on the ﬁrst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciﬁc
permission and/or a fee.
CCS’09, November 9–13, 2009, Chicago, Illinois, USA.
Copyright 2009 ACM 978-1-60558-352-5/09/11 ...$10.00.
Kernel Integrity, Malware, Introspection, Pointer Analysis, Mem-
ory Analysis
1.
INTRODUCTION
Modern operating systems are vulnerable to various types of at-
tacks. In particular, kernel-mode malware represents a signiﬁcant
threat because of its ability to compromise the security of the ker-
nel and, hence, the entire software stack. For example, kernel-
mode malware can tamper with kernel code and data to hide it-
self and collect useful information from certain system events (e.g.,
keystrokes). To mitigate this security threat, the integrity of the
complete kernel code and data needs to be veriﬁed.
It is relatively easy to check the integrity of kernel code and
static data in a running system given their read-only nature and
well-deﬁned locations in memory. However, it is much harder
to check the integrity of dynamic data due to their unpredictable
memory locations and volatile nature. Not surprisingly, dynamic
data have become one of the most attractive targets for kernel-mode
malware [11, 12, 25].
Previous solutions for checking kernel integrity either limit them-
selves to kernel code and static data (e.g., system call tables) [13,
20, 24, 29], or can reach only a fraction of the dynamic kernel
data [3, 22], resulting in limited security. Our study shows that
previous systems [3,22] may miss up to 72% of the dynamic kernel
data and thus may fail to identify function pointers manipulated by
many kernel-mode malware. It is straightforward for an attacker,
for instance, to implement new kernel-mode malware that tampers
only with function pointers in objects that cannot be reached by
these systems. Clearly, a complete and accurate understanding of
all kernel memory is critical for checking the kernel’s integrity.
Locating dynamic kernel objects in memory and identifying their
types is the ﬁrst and perhaps most difﬁcult step towards enabling
systematic integrity checks of dynamic kernel data. We call this
process mapping. To locate a dynamic object, a reference to it must
be found, usually in the form of a pointer. This pointer could, of
course, be located in another dynamic object, turning this into a
recursive problem. Mapping all the dynamic objects involves per-
forming a complete traversal of the memory, starting from a set of
globally well-deﬁned objects and following each pointer reference
to the next object, until all have been covered.
This basic idea was applied in previous security systems [3, 22].
However, these systems suffer from three major limitations. First,
they cannot follow generic pointers (e.g., void*) because they only
555leverage type deﬁnitions and thus cannot know the target types of
generic pointers. Second, these systems cannot follow pointers
deﬁned inside unions since they cannot tell which union subtype
should be considered. Third, they cannot recognize dynamic arrays
and thus the objects inside them. Since generic pointers, unions,
and dynamic arrays are programming paradigms commonly used in
OS kernels, ignoring them may result in a very incomplete memory
traversal as we observed in our study. Furthermore, previous sys-
tems require signiﬁcant manual annotations in the source code. For
example, in [3, 22], all linked list constructs needed to be annotated
so that the corresponding objects can be correctly identiﬁed by the
traversal. We have observed more than 1,500 doubly linked list
types in the Windows Vista SP1 kernel. This large number makes
an annotation process error-prone and time-consuming.
In this paper, we address the problem of automatically mapping
all kernel objects to enable systematic kernel integrity checking.
We present KOP (Kernel Object Pinpointer), a system that can map
kernel data objects in a memory snapshot with nearly complete cov-
erage and nearly perfect accuracy. Unlike previous systems, KOP is
designed to address the challenges in pointer-based memory traver-
sal. KOP’s system architecture is shown in Figure 1. KOP ﬁrst
performs static analysis on the kernel’s source code to construct an
extended type graph. This extended type graph has not only type
deﬁnitions and global variables but also all candidate target types
for generic pointers. Given a memory snapshot, KOP then per-
forms a memory analysis based on the extended type graph. KOP
resolves type ambiguities caused by unions or generic pointers with
multiple candidate target types and identiﬁes dynamic arrays. The
output is an object graph that contains all the identiﬁed kernel ob-
jects and their pointers to other objects. Systematic kernel integrity
checking can be performed on this object graph.
KOP’s ability to map kernel objects with high coverage and ac-
curacy enables a variety of systematic kernel integrity checks. To
concretely demonstrate the power of KOP, we have developed two
tools based on it, namely, SFPD (for Subverted Function Pointer
Detector) and GHOST (for General Hidden Object Scanning Tool).
SFPD can systematically identify function pointers manipulated
by kernel-mode malware. Compared with previous work such as
SBCFI [22], SFPD’s key advantages are: (1) it can check almost all
function pointers due to the high coverage and accuracy of KOP’s
memory traversal, and (2) it can verify implicit function pointers—
any function pointer ﬁeld deﬁned inside a union or not deﬁned as
a function pointer type (e.g., unsigned int) but sometimes used as
a function pointer. GHOST is a tool that can systematically un-
cover hidden kernel objects. Unlike previous tools [21, 28] that
rely on speciﬁc knowledge of a particular data type (e.g., process
constructs), GHOST can work with arbitrary kinds of system ob-
jects without having to know how exactly they are organized in
memory. Instead, GHOST can derive a view of certain system at-
tributes (such as the list of active processes) from the kernel objects
identiﬁed by KOP and compare it with information collected from
an internal program. Mismatches in this comparison reveal hidden
kernel objects.
We have implemented a prototype system of KOP using the Phoenix
compiler framework [16] and evaluated it on a Windows system.
Our system runs the Windows Vista SP1 kernel along with 63 drivers.
Our experiments show that KOP’s traversal reached 99% of all the
dynamic kernel data. By verifying 94% of the mapped kernel data
whose types were manually determined, we found that KOP cor-
rectly identiﬁed the types of 99%. We were not able to verify the
other 6% simply because of the large number of different alloca-
tion contexts which we would have had to analyze manually. We
also implemented a prototype system of SFPD and GHOST based
Kernel Integrity 
Checking 
Object 
Graph 
Memory 
Analysis 
Memory 
Snapshot 
Static 
Analysis 
Extended 
Type Graph 
Source 
Code 
Figure 1: The KOP system architecture.
on KOP. We tested SFPD with eight real-world kernel-mode rootk-
its. Our experiments show that SFPD identiﬁed all malicious func-
tion pointers, including implicit ones. We tested GHOST with two
real-world kernel-mode rootkits and showed that it uncovered all
the objects hidden by them. To compare KOP and its applications
with previous approaches, we also conducted memory traversals in
a way similar to the one described in [3, 22]. We found that pre-
vious approaches can only reach up to 28% of the dynamic kernel
data and thus miss malicious function pointers for six of the eight
rootkits we tested. A complete memory traversal with KOP cur-
rently takes eight minutes. This allows KOP to be used for a vari-
ety of ofﬂine applications. For instance, one can build SFPD-like
tools based on KOP to analyze a memory snapshot taken from an
infected machine for forensic analysis, or to proﬁle memory foot-
prints of kernel-mode malware for malware analysis.
In summary, we make the following contributions:
• We designed a points-to analysis algorithm to perform an
inter-procedural, ﬁeld-sensitive, and context-sensitive anal-
ysis of a large C/C++ program such as an OS kernel (Sec-
tion 3.1).
• We designed an algorithm to infer candidate types for generic
pointers based on a points-to graph (Section 3.2).
• We designed a set of techniques to resolve type ambiguities
in memory traversal (Section 4.1).
• We designed an approach to recognize dynamic arrays and
their sizes in a memory snapshot (Section 4.2).
• We developed the ﬁrst tool that can identify implicit function
pointers manipulated by kernel-mode malware (Section 5).
• We developed a prototype system of KOP that can map dy-
namic kernel data in a Windows system loaded with a large
number of drivers with nearly complete coverage and nearly
perfect accuracy (Section 6).
2. OVERVIEW
The goal of KOP is to completely and accurately map all kernel
objects in a memory snapshot in order to enable systematic kernel
integrity checking. In KOP, we refer to a live instance of a data type
(or, a data structure) as an object. KOP has two main components:
a static analysis component and a memory analysis component.
5561:
SLIST_ENTRY WrapDataListHead;
2:
3:
4:
5:
6:
typedef struct _WRAP_DATA {
SLIST_ENTRY List;
int32
Type;
PData;
void*
} WRAP_DATA;
typedef struct _BIN_DATA {
7:
8:
9:
10: } BIN_DATA;
int32
char*
BinLength;
BinData;
_InsertWrapList:
= ENTERFUNCTION
#21
#21
_type, _data
#22
t282, {*CallTag} = CALL* &_AllocateWrapData
#22
_WrapData
#23
t283
#23
[t283]*
#24
t284
#24
[t284]*
#25
t285
t286
#25
CALL* &_InsertSList, &_WrapDataListHead, t286 #25
#26
= ASSIGN t282
= ADD _WrapData, 4
= ASSIGN _type
= ADD _WrapData, 8
= ASSIGN _data
= ADD _WrapData, 0
= CONVERT t285
EXITFUNCTION
11: typedef struct _TXT_DATA {