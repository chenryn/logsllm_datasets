title:SoK: All You Ever Wanted to Know About x86/x64 Binary Disassembly
But Were Afraid to Ask
author:Chengbin Pang and
Ruotong Yu and
Yaohui Chen and
Eric Koskinen and
Georgios Portokalidis and
Bing Mao and
Jun Xu
2
1
0
0
0
.
1
2
0
2
.
1
0
0
0
4
P
S
/
9
0
1
1
.
0
1
:
I
O
D
|
E
E
E
I
1
2
0
2
©
0
0
.
1
3
$
/
1
2
/
5
-
4
3
9
8
-
1
8
2
7
-
1
-
8
7
9
|
)
P
S
(
y
c
a
v
i
r
P
d
n
a
y
t
i
r
u
c
e
S
n
o
m
u
i
s
o
p
m
y
S
E
E
E
I
1
2
0
2
2021 IEEE Symposium on Security and Privacy (SP)
SoK: All You Ever Wanted to Know About x86/x64
Binary Disassembly But Were Afraid to Ask
Chengbin Pang∗‡§ Ruotong Yu∗ Yaohui Chen† Eric Koskinen∗ Georgios Portokalidis∗ Bing Mao‡
Jun Xu∗
∗Stevens Institute of Technology
†Facebook Inc.
‡Nanjing University
Abstract—Disassembly of binary code is hard, but necessary
for improving the security of binary software. Over the past
few decades, research in binary disassembly has produced many
tools and frameworks, which have been made available to
researchers and security professionals. These tools employ a
variety of strategies that grant them different characteristics.
The lack of systematization, however, impedes new research in
the area and makes selecting the right tool hard, as we do
not understand the strengths and weaknesses of existing tools.
In this paper, we systematize binary disassembly through the
study of nine popular, open-source tools. We couple the manual
examination of their code bases with the most comprehensive
experimental evaluation (thus far) using 3,788 binaries. Our
study yields a comprehensive description and organization of
strategies for disassembly, classifying them as either algorithm
or else heuristic. Meanwhile, we measure and report the impact
of individual algorithms on the results of each tool. We ﬁnd that
while principled algorithms are used by all tools, they still heavily
rely on heuristics to increase code coverage. Depending on the
heuristics used, different coverage-vs-correctness trade-offs come
in play, leading to tools with different strengths and weaknesses.
We envision that these ﬁndings will help users pick the right tool
and assist researchers in improving binary disassembly.
I. INTRODUCTION
The disassembly of binary programs is a crucial task in
reverse engineering and software security, and it is a core
component of innumerable works on malware analysis [54],
code-similarity measurement [17, 42, 55], vulnerability dis-
covery [25, 66, 82, 95], security retroﬁtting [2, 78, 80,
100, 104, 109, 111] and patching [11]. However, correctly
disassembling a binary is challenging, mainly owing to the
loss of information (e.g., symbols and types) occurring when
compiling a program to machine code and the complexity of
constructs (e.g., jump tables, data embedded in code, etc.) used
to efﬁciently implement language features.
Binary disassembly has seen remarkable advancements in
the past decade, awarding researchers and developers with a
variety of tools and frameworks, under both open source [3,
33, 90, 94, 95, 102, 103] and commercial [36, 74] licenses.
These tools have lifted a signiﬁcant burden off researchers
that aim to develop new, advanced binary analysis techniques.
This new plurality of options encapsulates a broad variety
of underlying strategies with different guarantees, which fall
under two categories:
§Pang is a PhD student at Nanjing University. This work was done while Pang
was a Visiting Scholar at Stevens Institute of Technology.
TABLE I: The group of open-source tools that our study covers
and representative works that use those tools.
Tool (Version)
PSI (1.0)
UROBOROS (0.11)
DYNINST (9.3.2)
OBJDUMP (2.30)
GHIDRA (9.0.4)
MCSEMA (2.0.0)
ANGR (8.19.7.25)
BAP (2.1.0)
RADARE2 (4.4.0)
Source (Release Date)
Website [63] (Sep 2014)
Github [93] (Nov. 2016)
Github [79] (April 2017)
GNU [47] (Jan. 2018)
Github [75] (May 2019)
Github [13] (Jun. 2019)
Github [8] (Oct. 2019)
Github [26] (Mar. 2020)
Github [89] (April 2020)
Public Use
[50, 88, 111]
[103]
[7, 18, 69, 73, 96]
[21, 103, 111]
[24, 45, 91]
[22, 41, 44]
[20, 71, 81, 98, 112]
[10, 16, 64]
[4, 31, 52, 58]
• Algorithms typically produce results with some correct-
ness guarantees. They mostly leverage knowledge from the
binary (e.g., symbols), the machine (e.g., instruction set),
and/or the ABI (e.g., calling conventions).
• Heuristics are based on common patterns and typically do
not offer assurances of correctness.
Moreover, each tool adopts a different set of strategies, with
technical details not always fully documented or publicized.
To complicate the matters, the implemented strategies have
evolved over time, further deviating from documentation. The
above have created a knowledge gap that impedes the users
of these tools and, speciﬁcally, binary analysis researchers. To
bridge the gap, we must answer several questions:
• Q1 – What are the algorithms and heuristics used in existing
disassembly tools and how do they interact?
• Q2 – What is the coverage & accuracy of heuristic methods
in comparison to algorithmic ones? Are there trade-offs?
• Q3 – What errors do existing disassembly tools make and
what are the underlying causes?
To answer these questions, this paper presents a system-
atization of binary disassembly research, through the study
of nine popular open-source tools shown in Table I. Unlike
past research [5, 56, 68, 77, 105], we study these tools both
qualitatively and quantitatively to understand the tools not only
as a whole, but also their individual algorithms and heuristics.
More speciﬁcally, our qualitative study of the tools is
based on manually inspecting source code. This allows us
to answer Q1 by presenting their exact and most recent
strategies, avoiding ambiguities and out-of-date information
found in documentation and publications. The quantitative
study answers questions Q2–Q3 by applying the tools on a
corpus of 3,788 benchmark binaries, consisting of utilities,
client/server programs, and popular libraries on both Linux
© 2021, Chengbin Pang. Under license to IEEE.
DOI 10.1109/SP40001.2021.00012
833
Authorized licensed use limited to: Tsinghua University. Downloaded on February 25,2022 at 12:27:37 UTC from IEEE Xplore.  Restrictions apply. 
and Windows systems (see Table IV). To evaluate the tools
in terms of coverage and accuracy, we built an analysis
framework based on LLVM, GCC, the Gold Linker, and Visual
Studio to automatically collect the ground truth while building
the corpus. We evaluate the tools by individually measuring
different disassembly phases to quantify the effectiveness of
the strategies employed. Our evaluation presents the degree of
use, precision, and pitfalls of each component of each tool.
By systematically dissecting and evaluating the tools, we
were able to make new observations that amend or comple-
ment prior knowledge. Our major observations include: (1)
For better coverage, mainstream tools incorporate heuristics in
nearly every phase of disassembly. These heuristics are heavily
used in disassembling real-world binaries and, without them,
the tools cannot provide practical utility in many tasks. (2)
Heuristics typically cannot provide correctness assurances and
lead to various errors, particularly when encountering complex
constructs. Moreover, previous works may have overestimated
the reliability of those heuristics. For instance, a recent study
[5] (unintentionally) overstated the accuracy of linear sweep
because many benchmarks containing data-in-code were not
considered. (3) Tools may share the same group of algorithms
and heuristics, however,
they organize and combine them
differently, leading to different accuracy-coverage trade-offs.
(4) Tools have different strengths across different tasks. For
instance, commercial tools are better at recovering instructions
but open source tools can better identify cross-references.
Contributions: Our main contributions are as follows:
• We present a thorough systematization of binary disassem-
bly from the perspective of algorithms and heuristics. To our
knowledge, this is the ﬁrst research that can answer Q1–Q3.
• We developed a compiler-based framework for automated
end-to-end collection of ground truth for binary disassembly.
We used it to compose a benchmark data set for assessing
binary disassembly tools. The framework and benchmarks
are available at https://github.com/junxzm1990/x86-sok.
• We present,
to our knowledge,
the most comprehensive
evaluation of open-source disassembly tools. Our analysis
unveils the prevalence of heuristics, their contribution to
disassembly, and shortcomings.
• We make new observations and improve the understanding
of binary-disassembly strategies and tools. We envision that
these insights will facilitate future research in the area of
disassembly and drive improvements in existing tools.
II. SCOPE OF SYSTEMATIZATION
A. Functionality
In general, binary disassembly can involve different tasks
based on the context of use. This work focuses on tasks that
relate to binary-software security. Table II classiﬁes popular
security works and summarizes the information each class
needs to recover from binary code. Our study accordingly
concentrates on the disassembly aspects of providing them:
Disassembly is the process of recovering the assembly in-
structions of a binary. Perfect disassembly separates data from
TABLE II: Popular solutions of binary security and the in-
formation the solutions need from binary disassembly. “Inst”,
“CFG”, “Func”, and “Xrefs” respectively mean legitimate in-
structions, control ﬂow graph, functions, and cross references.
Category
Vulnerability Finding
Control Flow
Integrity
Code Layout
Randomization
Execute-only Code
Legacy-code Patching
Code Similarity
Measurement
Software Fault Isolation
Software De-bloating
Solutions & Required Information
[25, 34, 97]
[37, 80, 100, 108, 109, 111]
[19, 38, 51, 72, 85, 87, 99]
[28, 53, 60, 104]
[61, 65, 78, 106, 109]
[21, 110]
[11, 101, 102, 103]
[14, 17, 40, 42, 55, 57, 82]
[15, 29, 30, 43, 62, 70, 83]
[38, 39, 67, 107]
[46, 86, 92]
Inst, CFG, Func, Xrefs
Inst, CFG, Func
Inst, CFG, Func, Xrefs
Inst, CFG
Inst, CFG, Func, Xrefs
Inst, CFG, Func
Inst, CFG, Func
Inst, CFG, Func
code regions and correctly identiﬁes the instructions that were
emitted by the compiler or introduced by the developer.
Symbolization determines cross-references (xrefs for short)
or precisely, numeric values in the binary that are references
of other code or data objects. Depending on the location of the
reference and the location of the target, there are four types
of xrefs: code-to-code (c2c), code-to-data (c2d), data-to-code
(d2c), and data-to-data (d2d).
Function Entry Identiﬁcation locates the entry points of
functions. A special but important case is the main function.
CFG Reconstruction re-builds the control ﬂow graph (CFG)
of a binary program. We consider direct control transfers,
indirect jumps/calls, tail calls, and non-returning functions.
B. Targeted Binaries
Similarly to the majority of the works we study, we focus on
binaries with the following key properties: (1) They have been
produced with mainstream compilers and linkers; (2) Binaries
may include hand-written assembly; (3) They have not been
obfuscated; (4) We do not assume symbol availability, i.e.,
binaries are stripped; (5) We only consider X86/X64 binaries.
The majority of effort in prior works has focused on such
binaries, owing to the popularity of the architectures; (6) They
run on Linux or Windows operating systems.
C. Targeted Tools
Our systematization is based on study of disassembly tools.
We use ﬁve criteria to select tools: (1) They are designated for
disassembly or have an independent module for disassembly.
(2) They can do automated disassembly without user interac-
tions. (3) They are open source tools so that we can study
their implemented strategies. (4) They have unique strategies
that are not fully covered by other tools. (5) They can run our
targeted binaries to support our quantitative evaluation.
Following the above criteria, we selected 9 tools, as listed
in Table I. We also looked at JakStab [59], RetDec [32],
and BinCat [12] but excluded them in the study because (1)
JakStab cannot run our benchmark binaries due to a parsing
error (https://github.com/jkinder/jakstab/issues/9); (2) RetDec
aims for de-compilation;
it uses preliminary strategies for
disassembly, which are all covered by other tools we selected;
(3) BinCat requires user interactions to do disassembly. The
disassembly results vary upon different user interactions.
Authorized licensed use limited to: Tsinghua University. Downloaded on February 25,2022 at 12:27:37 UTC from IEEE Xplore.  Restrictions apply. 
834
TABLE III: The speciﬁcs of existing algorithms (numbered with rings like ) and heuristics (numbered with discs like ).
Alg.
Algorithms & Heuristics
Goals
y
l
b
m
e
s
s
a
s
i
D
n
o
i
t
a
z
i
l
o
b
m
y
S
y
r
t
n
E
n
o
i
t
c
n