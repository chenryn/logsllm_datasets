title:Flexible and Fine-grained Mandatory Access Control on Android for
Diverse Security and Privacy Policies
author:Sven Bugiel and
Stephan Heuser and
Ahmad-Reza Sadeghi
Flexible and Fine-grained Mandatory 
Access Control on Android for Diverse Security 
and Privacy Policies
Sven Bugiel, Saarland University; Stephan Heuser, Fraunhofer SIT;  
Ahmad-Reza Sadeghi, Technische Universität Darmstadt and Center for Advanced Security 
Research Darmstadt
Open access to the Proceedings of the 22nd USENIX Security Symposium is sponsored by USENIXThis paper is included in the Proceedings of the 22nd USENIX Security Symposium.August 14–16, 2013 • Washington, D.C., USAISBN 978-1-931971-03-4Flexible and Fine-Grained Mandatory Access Control on Android
for Diverse Security and Privacy Policies
Sven Bugiel∗
PI:EMAIL
Saarland University, Germany
Stephan Heuser
PI:EMAIL
Fraunhofer SIT, Germany
Ahmad-Reza Sadeghi
PI:EMAIL
Technische Universität Darmstadt / CASED, Germany
Abstract
In this paper we tackle the challenge of providing
a generic security architecture for the Android OS
that can serve as a ﬂexible and eﬀective ecosystem
to instantiate diﬀerent security solutions.
In con-
trast to prior work our security architecture, termed
FlaskDroid, provides mandatory access control si-
multaneously on both Android’s middleware and
kernel layers. The alignment of policy enforcement
on these two layers is non-trivial due to their com-
pletely diﬀerent semantics. We present an eﬃcient
policy language (inspired by SELinux) tailored to
the speciﬁcs of Android’s middleware semantics. We
show the ﬂexibility of our architecture by policy-
driven instantiations of selected security models such
as the existing work Saint as well as a new privacy-
protecting, user-deﬁned and ﬁne-grained per-app ac-
cess control model. Other possible instantiations
include phone booth mode, or dual persona phone. Fi-
nally we evaluate our implementation on SE Android
4.0.4 illustrating its eﬃciency and eﬀectiveness.
1 Introduction
Mobile devices such as smartphones and tablets have
become very convenient companions in our daily lives
and, not surprisingly, also appealing to be used for
working purposes. On the down side, the increased
complexity of these devices as well as the increasing
amount of sensitive information (private or corporate)
stored and processed on them, from user’s location
data to credentials for online banking and enterprise
VPN, raise many security and privacy concerns. To-
day the most popular and widespread smartphone
operating system is Google’s Android [4].
∗Author was aﬃliated with Technische Universität Darm-
stadt/CASED at the time this work was conducted.
Android’s vulnerabilities. Android has been
shown to be vulnerable to a number of diﬀerent
attacks such as malicious apps and libraries that mis-
use their privileges [57, 40, 25] or even utilize root-
exploits [55, 40] to extract security and privacy sen-
sitive information; taking advantage of unprotected
interfaces [14, 12, 53, 32] and ﬁles [49]; confused
deputy attacks [16]; and collusion attacks [46, 34].
Solutions. On the other hand, Android’s open-
source nature has made it very appealing to academic
and industrial security research. Various extensions
to Android’s access control framework have been
proposed to address particular problem sets such as
protection of the users’ privacy [19, 28, 15, 52, 7, 30];
application centric security such as Saint enabling
developers to protect their application interfaces [39];
establishing isolated domains (usage of the phone
in private and corporate context) [9]; mitigation of
collusion attacks [8], and extending Android’s Linux
kernel with Mandatory Access Control [48].
Observations. Analyzing the large body of litera-
ture on Android security and privacy one can make
the following observations: First, almost all proposals
for security extensions to Android constitute manda-
tory access control (MAC) mechanisms that are tai-
lored to the speciﬁc semantics of the addressed prob-
lem, for instance, establishing a ﬁne-grained access
control to user’s private data or protecting the plat-
form integrity. Moreover, these solutions fall short
with regards to an important aspect, namely, that
protection mechanisms operate only at a speciﬁc
system abstraction layer, i.e., either at the middle-
ware (and/or application) layer, or at the kernel-layer.
Thus, they omit the peculiarity of the Android OS
design that each of its two software layers (middle-
ware and kernel) is important within its respective
semantics for the desired overall security and privacy.
USENIX Association  
22nd USENIX Security Symposium  131
Only few solutions consider both layers [8, 9], but
they support only a very static policy and lack the
required ﬂexibility to instantiate diﬀerent security
and privacy models.
The second observation concerns the distinguishing
characteristic of application development for mobile
platforms such as Android: The underlying oper-
ating systems provide app developers with clearly
deﬁned programming interfaces (APIs) to system
resources and functionality – from network access
over personal data like SMS/contacts to the onboard
sensors. This clear API-oriented system design and
convergence of functionality into designated service
providers [54, 36] is well-suited for realizing a security
architecture that enables ﬁne-grained access control
to the resources exposed by the API. As such, mobile
systems in general and Android in particular provide
better opportunities to more eﬃciently establish a
higher security standard than possible on current
commodity PC platforms [31].
Challenges and Our Goal. Based on the obser-
vations mentioned above, we aim to address the fol-
lowing challenges in this paper: 1) Can we design a
generic and practical mandatory access control ar-
chitecture for Android-based mobile devices, that
operates on both kernel and middleware layer, and
is ﬂexible enough to instantiate various security and
privacy protecting models just by conﬁguring security
policies? More concretely, we want to create a generic
security architecture which supports the instantia-
tion of already existing proposals such as Saint [39]
or privacy-enhanced system components [58], or even
new use-cases such as a phone booth mode. 2) To
what extent would the API-oriented design of An-
droid allow us to minimize the complexity of the
desired policy? Note that policy complexity is an
often criticized drawback of generic MAC solutions
like SELinux [33] on desktop systems [54].
Our Contribution.
In this paper, we present the
design and implementation of a security architec-
ture for the Android OS that addresses the above
mentioned challenges. Our design is inspired by the
concepts of the Flask architecture [50]: a modular
design that decouples policy enforcement from the
security policy itself, and thus provides a generic
architecture where multiple and dynamic security
policies can be supported by the system. In particu-
lar, our contributions are:
1. System-wide security framework. We present an
Android security framework that operates on both
the middleware and kernel layer. It addresses many
problems of the stock Android permission framework
and of related solutions which target either the mid-
dleware or the kernel layer. We base our implemen-
tation on SE Android [48], which has already been
partially merged into the oﬃcial Android source-code
by Google1.
2. Security policy and type enforcement at mid-
dleware layer. We extended Android’s middleware
layer with type enforcement and present our policy
language, which is speciﬁcally designed for the rich
semantics at this layer. The alignment of middleware
and kernel layer policies in a system-wide security
framework is non-trivial, particularly due to the dif-
ferent semantics of both layers.
3. Use-cases. We show how our security framework
can instantiate selected use-cases. The ﬁrst one is an
attack-speciﬁc related work, the well-known applica-
tion centric security solution Saint [39]. The second
one is a privacy protecting solution that uses ﬁne-
grained and user-deﬁned access control to personal
data. We also mention other useful security models
that can be instantiated with FlaskDroid.
4. Eﬃciency and eﬀectiveness. We successfully eval-
uate the eﬃciency and eﬀectiveness of our solution
by testing it against a testbed of known attacks and
by deriving a basic system policy which allows for
the instantiation of further use-cases.
2 Background
In this section, we ﬁrst present a short overview of
the standard Android software stack, focusing on the
relevant security and access control mechanisms in
place. Afterwards, we elaborate on the SE Android
Mandatory Access Control (MAC) implementation.
2.1 Android Software Stack
Android is an open-source software stack tailored to
mobile devices, such as smartphones and tablets. It is
based on a modiﬁed Linux kernel responsible for basic
operating system services (e.g. memory management,
ﬁle system support and network access).
Furthermore, Android consists of an application
framework implementing (most of) the Android API.
System Services and libraries, such as the radio inter-
face layer, are implemented in C/C++. Higher-level
services, such as System settings, the Location- and
Audiomanager, are implemented in Java. Together,
these components comprise the middleware layer.
1http://www.osnews.com/story/26477/Android_4_2_
alpha_contains_SELinux
132  22nd USENIX Security Symposium 
USENIX Association
Android applications (apps) are implemented in
Java and may contain native code. They are posi-
tioned at the top of the software stack (application
layer) and use kernel and middleware Services. An-
droid ships with standard apps completing the im-
plementation of the Android API, such as a Contacts
(database) Provider. The user can install additional
apps from, for example, the Google Play store.
Android apps consist of certain components: Acti-
vities (user interfaces), Services (non user-interactive
tasks), ContentProviders (SQL-like databases), and
Broadcast Receivers (mailboxes for broadcast mes-
sages). Apps can communicate with each other on
multiple layers: 1) Standard Linux Inter-Process
Communication (IPC) using, e.g., domain sockets;
2) Internet sockets; 3) Inter-Component Commu-
nication (ICC) [21], a term abstractly describing a
lightweight IPC mechanism between app components,
called Binder. Furthermore, predeﬁned actions (e.g.,
starting an Activity) can be triggered using an Intent,
a unicast or broadcast message sent by an application
and delivered using the Android ICC mechanism.
2.2 Security Mechanisms
Sandboxing. Android uses the Linux discretionary
access control (DAC) mechanism for application sand-
boxing by assigning each app a unique user identiﬁer
(UID) during installation2. Every process belonging
to the app is executed in the context of this UID,
which determines access to low level resources (e.g.
app-private ﬁles). Low-level IPC (e.g. using domain
sockets) is also controlled using Linux DAC.
Permissions. Access control is applied to ICC us-
ing Permissions [21]: Labels assigned to apps at
install-time after being presented to and accepted
by the user. These labels are checked by reference
monitors at middleware- and application level when
security-critical APIs are accessed. In addition to
Android’s default permissions, app developers can
deﬁne their own permissions to protect their applica-
tions’ interfaces. However, it should be noted that
the permission model is not mandatory access control
(MAC), since callees must discretely deploy or deﬁne
the required permission check and, moreover, permis-
sions can be freely delegated (e.g., URI permissions).
Permissions are also used to restrict access to some
low level resources, such as the world read-/writeable
external storage area (e.g. a MicroSD card) or net-
work access. These permissions are mapped to Linux
group identiﬁers (GIDs) assigned to an app’s UID
2Developers may use the same UID (Shared UID, SUID)
for their own apps. These apps will share the same sandbox.
during installation and checked by reference monitors
in the Linux kernel at runtime.
2.3 SELinux
Security Enhanced Linux (SELinux) [33] is an instan-
tiation of the Flask security architecture [50] and
implements a policy-driven mandatory access control
(MAC) framework for the Linux kernel. In SELinux,
policy decision making is decoupled from the policy
enforcement logic. Various access control enforce-
ment points for low-level resources, such as ﬁles, IPC,
or memory protection enforce policy decisions re-
quested from a security server in the kernel. This
security server manages the policy rules and contains
the access decision logic. To maintain the security
server (e.g., reload the policy), SELinux provides a
number of userspace tools.
Access Control Model. SELinux supports diﬀer-
ent access control models such as Role-Based Access
Control and Multilevel Security. However, Type En-
forcement is the primary mechanism: each object
(e.g., ﬁles, IPC) and subject (i.e., processes) is labeled
with a security context containing a type attribute
that determines the access rights of the object/sub-
ject. By default, all access is denied and must be
explicitly granted through policy rules—allow rules
in SELinux terminology. Using the notation intro-
duced in [26], each rule is of the form
allow TSub TObj ∶ CObj OC
where TSub is a set of subject types, TObj is a set of
object types, CObj is a set of object classes, and OC
is a set of operations. The object classes determine
which kind of objects this rule relates to and the
operations contain speciﬁc functions supported by
the object classes. If a subject whose type is in TSub
wants to perform an operation that is in OC on an
object whose class is in CObj and whose type is in
TObj, this action is allowed. Otherwise, if no such
rule exists, access is denied.
Dynamic policies. SELinux supports to some ex-
tent dynamic policies based on boolean ﬂags which
aﬀect conditional policy decisions at runtime. These
booleans and conditions have to be deﬁned prior
to policy deployment and new booleans/conditions
can not be added after the policy has been loaded
without recompiling and reloading the entire policy.
The simplest example for such dynamic policies are
booleans to switch between “enforcing mode” (i.e.,
access denials are enforced) and “permissive mode”
(i.e., access denials are not enforced).
Userspace Object Managers. A powerful feature
of SELinux is that its access control architecture can
USENIX Association  
22nd USENIX Security Symposium  133
be extended to security-relevant userspace daemons
and services, which manage data (objects) indepen-
dently from the kernel. Thus, such daemons and
services are referred to as Userspace Object Managers
(USOMs). They are responsible for assigning security
contexts to the objects they manage, querying the
SELinux security server for access control decisions,
and enforcing these decisions. A prominent example
for such USOMs on Linux systems is GConf [13].
2.4 SE Android
SE Android [48] prototypes SELinux for Android’s
Linux kernel and aims to demonstrate the value of
SELinux in defending against various root exploits
and application vulnerabilities. Speciﬁcally, it con-
ﬁnes system Services and apps in diﬀerent kernelspace
security domains even isolating apps from one an-
other by the use of the Multi-Level Security (MLS)
feature of SELinux. To this end, the SE Android
developers started writing an Android-speciﬁc policy
from scratch. In addition, SE Android provides a
few key security extensions tailored for the Android
OS. For instance, it labels application processes with
SELinux-speciﬁc security contexts which are later
used in type enforcement. Moreover, since (in the
majority of cases) it is a priori unknown during policy
writing which apps will be installed on the system
later, SE Android employs a mechanism to derive the