在进一步探讨之前，先让我们来了解一些插桩技术的背景知识。
**DBI和DynamoRIO的简要介绍**
Selfie使用DynamoRIO（VMWare的框架）来提供动态代码插桩（DBI）功能。
有关DBI和DynamoRIO的简要背景知识，我们不妨参考http://uninformed.org/index.cgi?v=7&a=1&p=3页面的介绍：
“动态代码插桩（DBI）是一种通过注入插桩代码在二进制应用程序运行时分析其行为的方法。插桩代码被注入之后，会作为正常指令流的一部分执行。在大多数情况下，测试代码对于被注入的应用程序来说是完全透明的。在运行时分析应用程序能够深入了解该应用程序在各个执行点的行为和状态。这是静态二进制分析和动态二进制分析之间的主要区别之一。与考察可能发生什么事情不同，动态二进制分析有利于对实际发生的事情直接进行干预。虽然在应用程序所有代码路径上无法面面俱到，但它能够帮助我们详细了解应用程序的具体执行状态，从而弥补了这一点。
…
DynamoRIO是DBI框架的一个实例，允许自定义的插桩代码以动态库的形式进行集成。这个工具本身是由HP研究人员开发的动态优化引擎Dynamo和MIT开发的RIO（Runtime
Introspection and
Optimization）结合而成的。我们不打算介绍DynamoRIO在实现方面的具体细节，对于本文来说，重点在于了解其基本概念。
…
具体来说，Dynamo是在指令流执行的时候对其进行处理。为了实现这一点，Dynamo需要承担起执行指令流的责任。它使用反汇编器来识别将要执行的代码中的下一个分支指令的目标地址。反汇编的指令集被称为片段（更常见的叫法是基本块）。如果分支指令的目标地址在Dynamo的片段缓存中，则它会在片段缓存中执行该（可能优化过的）代码。当这段代码执行完以后，它会把控制权返回Dynamo，以便反汇编下一个片段。当Dynamo遇到目的地址不在其片段缓存中的分支的时候，它会将其添加到片段缓存中并对其进行优化。这是将插桩代码注入到针对分支目的地址而生成的优化片段的完美机会。在此级别注入插桩代码对于应用程序是完全透明的。虽然应用DynamoRIO后事情会变得异常简单，但至少应该对Dynamo的功能有所了解。
从分析师的角度来看，DynamoRIO的最佳特性之一是它提供了一个框架，用于在片段被插入到片段缓存期间注入插桩代码。这对于拦截应用程序内的内存访问来说格外有用。创建片段时，DynamoRIO为注入到所生成的片段中的指令提供相应的分析库。为了优化性能，DynamoRIO提供了多级反汇编信息。在最高优化级别中，仅提供指令的最基本信息。在最低优化级别，可以获得关于指令及其操作数的非常详细的信息。分析库可以自由地控制它们检索的信息的级别。
**深入了解Selfie**
通过DynamoRIO的API，我们能够编写自己客户端——实际上，客户端就是DLL。DynamoRIO为每次放入代码缓存的代码都提供了hook。通过这些hook，客户端能够检查和转换将放入代码缓存中的任何代码片段。这样，我们实现了完全控制，只要我们喜欢，就可以执行任何动作。
**Selfie使用指南**
我们的Selfie的算法机制如下：
第1步：我们在Selfie的入口点即dr_init()处，检索用于主可执行文件（比如malware.exe）的模块数据
第2步：保存主模块的起始地址、结束地址和IAT大小。
图20：Selfie的入口点
第3步：使用dr_register_bb_event()为基本块事件的注册回调函数。
图21：注册回调函数
第4步：回调函数On_event_basic_block
通过dr_register_bb_event()注册的基本块创建事件，客户端能够在执行代码之前检查和转换任何代码段。对于每个新块，我们使用instrlist_first()/
instr_get_next()例程来遍历块指令。
图22：基本块创建事件
第5步：遍历块指令。
当instr的操作码是OP_call或OP_call_far(instr_is_call_direct())或instr的操作码是OP_call_ind或OP_call_far_ind（instr_is_call_indirect（））的时候，我们就调用基本块回调函数（on_call_event）：
图23：调用插桩代码
第6步：确定OEP
1\. 检查该调用（被调用方）的目标地址是否在主可执行代码的起始地址和结束地址之间。
2\. 如果答案是肯定的，我们就调用GetImportAddressTableSize（）来获取当前的IAT大小。
3\. 如果当前IAT大小不同于原始IAT大小（就像我们在主函数中得到的），被调用方地址就是可疑的OEP。
**注入Selfie**
为了将Selfie注入到malware.exe的进程中，我们使用drrun.exe，具体参数如下所示：
**Selfie在行动**
Selfie做得怎么样呢？
首先，让我们对上面手动脱壳的恶意软件（Shylock）运行Selfie：
图24：针对Shylock运行Selfie
现在让我们来考察一个Win32 / Xswkit（别名Gootkit）恶意软件。
对于那些不熟悉Xswkit恶意软件的人来说，它就是Win32 /
Poweliks的一个克隆，只不过提供了一些额外的功能（它是通过使用微软的shim引擎以及不同的启动方法（rundll +
mshta.exe）实现UAC绕过的）。
有关该样本的工作机制的详细信息，请参阅kernel_mode.info论坛中EP_X0FF提供的完整分析。
对于该样本加壳和脱壳后的代码，也可以从kernelmode.info论坛下载。感谢Tigzy和R136a1为我们提供了这些样本代码，以及EP_X0FF提供的未加壳的样本代码。
加壳之后的：
在运行Selfie之前，我们看到的是这样的：
图25：加壳后的恶意软件Xswkit的样本。
请注意映像基址和AddressOfEntryPoint（EP）字段。
脱壳之后的：
图26：未加壳的Xswkit恶意软件样本。注意映像基址和AddressOfEntryPoint（EP）字段。脱壳后的样本中的EP是实际的OEP
现在让我们看看，利用Selfie工具是否能够得到类似的结果：
图27：事实上，这里的OEP与未加壳的样本中的OEP的值是一致的
**结束语**
我们已经在GNU / PL许可下公开发布了Selfie工具及其相应的代码。如果你是研究员，请随意使用该工具。
欢迎大家积极提供反馈、评论和改进建议。
可执行文件和代码下载地址：。