### 插桩技术背景知识

在深入讨论之前，让我们先了解一下插桩技术的基础知识。

#### DBI和DynamoRIO简介
Selfie利用DynamoRIO（VMWare的框架）提供动态代码插桩（DBI）功能。关于DBI和DynamoRIO的基本概念，可以参考[uninformed.org](http://uninformed.org/index.cgi?v=7&a=1&p=3)的相关介绍：

**动态代码插桩 (DBI)** 是一种通过注入插桩代码来分析二进制应用程序运行时行为的方法。这些插桩代码作为正常指令流的一部分执行，对被注入的应用程序通常是透明的。动态二进制分析与静态分析的主要区别在于，前者能够直接干预并观察实际发生的行为，而不是仅仅推测可能发生的情况。尽管它无法覆盖所有代码路径，但能提供详细的执行状态信息。

**DynamoRIO** 是一个具体的DBI框架实例，允许以动态库的形式集成自定义插桩代码。该工具结合了HP研究人员开发的动态优化引擎Dynamo和MIT开发的RIO（运行时内省和优化）。本文的重点是理解其基本概念而非实现细节。

具体来说，Dynamo在指令流执行时对其进行处理。它使用反汇编器识别下一个分支指令的目标地址，并将反汇编后的指令集称为片段（或基本块）。如果目标地址在片段缓存中，Dynamo会执行缓存中的（可能经过优化的）代码；否则，它会将其添加到缓存中并进行优化。这是将插桩代码注入到生成的优化片段中的理想时机。此级别的插桩对应用程序完全透明。

从分析师的角度来看，DynamoRIO的优势之一是在片段插入缓存期间提供了注入插桩代码的框架，这对于拦截内存访问特别有用。此外，DynamoRIO还提供了多级反汇编信息，以便根据需要获取不同详细程度的指令信息。

### 深入了解Selfie

通过DynamoRIO的API，我们可以编写自己的客户端——实际上是一个DLL。DynamoRIO为每个放入代码缓存的代码片段提供了hook，使客户端能够检查和转换这些代码片段，从而实现完全控制。

### Selfie使用指南

以下是Selfie的工作流程：

1. **初始化**：在Selfie的入口点`dr_init()`处，检索主可执行文件（如`malware.exe`）的模块数据。
2. **保存模块信息**：记录主模块的起始地址、结束地址和导入地址表 (IAT) 大小。
3. **注册回调函数**：使用`dr_register_bb_event()`注册基本块事件的回调函数。
4. **回调函数**：在基本块创建事件中，客户端可以在执行代码之前检查和转换任何代码段。对于每个新块，我们使用`instrlist_first()`/ `instr_get_next()`例程遍历块指令。
5. **调用插桩代码**：当指令操作码为`OP_call`或`OP_call_far`（直接调用）或`OP_call_ind`或`OP_call_far_ind`（间接调用）时，调用基本块回调函数`on_call_event`。
6. **确定OEP**：
   - 检查调用的目标地址是否在主可执行代码的起始地址和结束地址之间。
   - 如果是，则调用`GetImportAddressTableSize()`获取当前的IAT大小。
   - 如果当前IAT大小不同于原始IAT大小，则该调用地址可能是可疑的原始入口点 (OEP)。

### 注入Selfie

为了将Selfie注入到`malware.exe`进程中，我们使用`drrun.exe`，具体参数如下所示。

### Selfie实战

#### 针对Shylock恶意软件
首先，我们对手动脱壳的Shylock恶意软件运行Selfie，结果如下图所示。

#### 针对Xswkit恶意软件
Xswkit（别名Gootkit）是Win32/Poweliks的一个克隆，具有额外的功能，例如通过微软的shim引擎和不同的启动方法（rundll + mshta.exe）绕过UAC。

- **加壳前**：查看加壳后的Xswkit样本，注意映像基址和`AddressOfEntryPoint`字段。
- **脱壳后**：查看未加壳的Xswkit样本，注意映像基址和`AddressOfEntryPoint`字段。脱壳后的样本中的EP是实际的OEP。
- **使用Selfie**：利用Selfie工具得到的结果显示，这里的OEP与未加壳样本中的OEP一致。

### 结束语

我们已在GNU/PL许可下公开发布了Selfie工具及其相应代码。欢迎研究员们使用该工具，并积极提供反馈、评论和改进建议。

可执行文件和代码下载地址：[链接]

希望这些改进使文档更加清晰、连贯和专业。如果有任何进一步的需求，请随时告知。