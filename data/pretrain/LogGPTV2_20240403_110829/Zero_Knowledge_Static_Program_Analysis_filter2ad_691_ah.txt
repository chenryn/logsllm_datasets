Flow Analysis by Abstract Interpretation. In Static Analysis, MarÃ­a Alpuente and
GermÃ¡n Vidal (Eds.). Springer Berlin Heidelberg, Berlin, Heidelberg, 347â€“362.
[56] Flemming Nielson, Hanne R. Nielson, and Chris Hankin. 2010. Principles of
[57] Bryan Parno, Jon Howell, Craig Gentry, and Mariana Raykova. 2013. Pinocchio:
Program Analysis. Springer Publishing Company, Incorporated.
Nearly practical verifiable computation. In S&P 2013. 238â€“252.
[58] David Pichardie. 2005. InterprÃ©tation abstraite en logique intuitionniste : extraction
dâ€™analyseurs Java certifiÃ©s. Ph.D. Dissertation. UniversitÃ© Rennes 1. In french.
[59] Polyspace Code Prover. 2014. Static Analysis with Polyspace Products. Mathworks,
June (2014).
[60] Jacob T Schwartz. 1979. Probabilistic algorithms for verification of polynomial
identities. In International Symposium on Symbolic and Algebraic Manipulation.
Springer, 200â€“215.
[61] Srinath Setty. 2020. Spartan: Efficient and general-purpose zkSNARKs without
trusted setup. In Annual International Cryptology Conference. Springer, 704â€“737.
[62] Srinath Setty, Sebastian Angel, Trinabh Gupta, and Jonathan Lee. 2018. Proving
the correct execution of concurrent services in zero-knowledge. In 13th {USENIX}
Symposium on Operating Systems Design and Implementation ({OSDI} 18). 339â€“
356.
[63] Olin Grigsby Shivers. 1991. Control-Flow Analysis of Higher-Order Languages of
Taming Lambda. Ph.D. Dissertation. USA. UMI Order No. GAX91-26964.
[64] Julien Signoles, Pascal Cuoq, Florent Kirchner, Nikolai Kosmatov, Virgile Prevosto,
and Boris Yakobowski. 2012. Frama-c: a Software Analysis Perspective. Formal
Aspects of Computing 27. https://doi.org/10.1007/s00165-014-0326-7
[65] Arnaud Venet and Guillaume Brat. 2004. Precise and Efficient Static Array Bound
Checking for Large Embedded C Programs. SIGPLAN Not. 39, 6 (June 2004),
231â€“242. https://doi.org/10.1145/996893.996869
[66] Riad S. Wahby, Srinath T. V. Setty, Zuocheng Ren, Andrew J. Blumberg, and
Michael Walfish. 2015. Efficient RAM and control flow in verifiable outsourced
computation. In 22nd Annual Network and Distributed System Security Symposium,
NDSS 2015, San Diego, California, USA, February 8-11, 2015.
[67] Riad S Wahby, Ioanna Tzialla, Abhi Shelat, Justin Thaler, and Michael Walfish.
2018. Doubly-efficient zkSNARKs without trusted setup. In 2018 IEEE Symposium
on Security and Privacy (SP). IEEE, 926â€“943.
[68] Guannan Wei, Yuxuan Chen, and Tiark Rompf. 2019. Staged Abstract Interpreters.
(2019).
[69] Tiacheng Xie, Jiaheng Zhang, Yupeng Zhang, Charalampos Papamanthou, and
Dawn Song. 2019. Libra: Succinct Zero-Knowledge Proofs with Optimal Prover
Computation. In Advances in Cryptology (CRYPTO).
[70] Jiaheng Zhang, Tiancheng Xie, Yupeng Zhang, and Dawn Song. [n.d.]. Trans-
parent Polynomial Delegation and Its Applications to Zero Knowledge Proof. In
S&P 2020.
[71] Yupeng Zhang, Daniel Genkin, Jonathan Katz, Dimitrios Papadopoulos, and
Charalampos Papamanthou. 2017. vSQL: Verifying arbitrary SQL queries over
dynamic outsourced databases. In Security and Privacy (SP), 2017 IEEE Symposium
on. IEEE, 863â€“880.
[72] Yupeng Zhang, Daniel Genkin, Jonathan Katz, Dimitrios Papadopoulos, and Char-
alampos Papamanthou. 2017. A Zero-Knowledge Version of vSQL. Cryptology
ePrint.
[73] Yupeng Zhang, Daniel Genkin, Jonathan Katz, Dimitrios Papadopoulos, and
Charalampos Papamanthou. 2018. vRAM: Faster verifiable RAM with program-
independent preprocessing. In Proceeding of IEEE Symposium on Security and
Privacy (S&P).
[74] Richard Zippel. 1979. Probabilistic algorithms for sparse polynomials. In Interna-
tional Symposium on Symbolic and Algebraic Manipulation. Springer, 216â€“226.
A ZERO-KNOWLEDGE ARGUMENTS
A zero-knowledge argument is a protocol between a computationally-
bounded prover P and a verifier V for an NP relationship R. At
the end of the protocol, P convinces V that she knows a witness
ğ‘¤ such that (ğ‘¥; ğ‘¤) âˆˆ R for some input ğ‘¥. â€œPPT" standards for prob-
abilistic polynomial time. We use G to represent the algorithm to
generate the public parameters. Formally, a zero-knowledge argu-
ment of knowledge is defined below, where R is known to P and
V.
Definition 1. Let R be an NP relation. A tuple of algorithm
(G, P,V) is a zero-knowledge argument of knowledge for R if the
following holds.
â€¢ Completeness. For every pp output by G(1ğœ†), (ğ‘¥; ğ‘¤) âˆˆ R and
ğœ‹ â† P(ğ‘¥, ğ‘¤, pp), Pr[V(ğ‘¥, ğœ‹, pp) = 1] = 1
â€¢ Knowledge Soundness. For any PPT prover Pâˆ—, there exists a
PPT extractor E such that given the access to the entire executing
process and the randomness of Pâˆ—, E can extract a witness ğ‘¤ such
that pp â† G(1ğœ†), ğœ‹âˆ— â† Pâˆ—(ğ‘¥, pp) and ğ‘¤ â† EPâˆ—(pp, ğ‘¥, ğœ‹âˆ—):
Pr[(ğ‘¥; ğ‘¤) âˆ‰ R âˆ§ V(ğ‘¥, ğœ‹âˆ—, pp) = 1] â‰¤ negl(ğœ†).
â€¢ Zero-knowledge. There exists a PPT simulator S such that for any
PPT algorithm Vâˆ—, (ğ‘¥; ğ‘¤) âˆˆ R, pp output by G(1ğœ†), it holds that
View(Vâˆ—(pp, ğ‘¥)) â‰ˆ SVâˆ—(ğ‘¥).
We say that (G, P,V) is a succinct argument system if the total
communication between P and V (proof size) is poly(ğœ†, |ğ‘¥|, log |ğ‘¤|).
In the definition of zero-knowledge, View(Vâˆ—(pp, ğ‘¥)) denotes
the veiw the verifier sees during the execution of the interactive
process with P while SVâˆ—(ğ‘¥) denotes the view generated by S
given input ğ‘¥ and transcript of Vâˆ—, and â‰ˆ denotes two distribu-
tions perfect indistinguishable. This definition is commonly used in
existing transparent zero-knowledge proof schemes [11, 15, 23, 67].
In addition, in order to build our zero-knowledge abstract in-
terpretation scheme, we need an additional property formalized
as â€œCommit-and-Proveâ€ in [24]. It allows the prover to commit to
the witness first, and later prove statements about the commit-
ted value. It is naturally supported by most of ZKP systems. We
denote the algorithm as comğ‘¤ â† Commit(ğ‘¤, pp). It is executed
after G and before P, and V additionally takes comğ‘¤ as an in-
put. It satisfies the extractability of commitment. Similar to the
extractability in Definition 1, there exists a PPT extractor E, given
any tuple (pp, ğ‘¥, comâˆ—
ğ‘¤) and the executing process of Pâˆ—, it could
always extract a witness ğ‘¤âˆ— such that comâˆ—
ğ‘¤ â† Commit(ğ‘¤âˆ—, pp)
except for negligible probability in ğœ†. Formally speaking, comâˆ—
ğ‘¤ =
Commit(EPâˆ—(pp, ğ‘¥, comâˆ—
Protocol 1 (Zero-Knowledge Abstract Interpretation(zkAI)). Let ğœ†
be the security parameter, F be a prime field, ğ‘ be the secret program, ğ¶ be
the arithmetic circuit in Figure 2. Let P and V be the prover and the verifier
respectively. We use ZKP.G, ZKP.Commit, ZKP.P, ZKP.V to represent the
algorithms of the backend ZKP protocol.
â€¢ pp â† zkAI.G(1ğœ†): pp = ZKP.G(1ğœ†)
â€¢ comğ‘â†zkAI.Commit(ğ‘, pp): comğ‘ = ZKP.Commit(ğ‘, pp).
â€¢ ğœ‹ â† zkAI.P(ğ‘, (ğ¿â€², ğ‘“ â€², ğ‘”, Alg), pp):
(1) P runs the algorithm Alg with input ğ‘, ğ¿â€² and ğ‘“ â€² to get ğ‘† =
Alg(ğ‘, ğ¿â€², ğ‘“ â€²). Then generates the witness ğ‘¤ = (ğ¶ğ¹ğº,ğ‘‡ ğ‘Ÿ) for the
circuit ğ¶ during the procedure of the abstract interpretation algo-
rithm. ğ¶ğ¹ğº and ğ‘‡ ğ‘Ÿ represents the extended witness in Figure 2. Let
comğ‘¤ â† ZKP.Commit(ğ‘¤, pp). P sends comğ‘¤ to V.
(2) After receiving the randomness râ€² for checking consistency of the pro-
gram and the control flow graph, P invokes ZKP.P(ğ¶, ğ‘, râ€², ğ‘¤, ğ‘ğ‘) to
get ğœ‹. Sends ğœ‹ to V.
â€¢ {0, 1} â† zkAI.V(comğ‘, comğ‘¤, (ğ¿â€², ğ‘“ â€², Alg, ğ‘”), ğœ‹, pp): V outputs 1 if
ZKP.V(ğ¶, comğ‘, râ€², ğœ‹, comğ‘¤, ğ‘ğ‘) = 1, otherwise it outputs 0.
ğ‘¤), pp).
Session 11B: Zero Knowledge II CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea2965B DEFINITIONS OF ZERO-KNOWLEDGE
ABSTRACT INTERPRETATION
Definition 2. We say that a scheme is a zero-knowledge abstract
interpretation if the following holds:
â€¢ Completeness. For any program ğ‘ and analysis (valâ™¯, Ağ‘,ğ‘™ , Alg, ğ‘”),
pp â† zkAI.G(1ğœ†), comğ‘ â† zkAI.Commit(ğ‘, pp), (ğ‘¦, ğœ‹) â†
zkAI.P(ğ‘, (valâ™¯, Ağ‘,ğ‘™ , Alg, ğ‘”), pp), it holds that
zkAI.V(comğ‘, (valâ™¯, Ağ‘,ğ‘™ , Alg, ğ‘”), ğ‘¦, ğœ‹, pp) = 1
= 1
â€¢ Soundness. For any PPT adversary Adv, the following probability
(cid:105)
is negligible in ğœ†:
Pr
pp â† zkAI.G(1ğœ†)
(ğ‘âˆ—, comğ‘âˆ—, (valâ™¯, Ağ‘,ğ‘™ , Alg, ğ‘”), ğ‘¦, ğœ‹âˆ—) â† Adv(1ğœ†, pp)
comğ‘âˆ— = zkAI.Commit(ğ‘âˆ—, pp)
zkAI.V(comğ‘âˆ—, (valâ™¯, Ağ‘,ğ‘™ , Alg, ğ‘”), ğ‘¦, ğœ‹âˆ—, pp) = 1
ğ‘”(Alg(ğ‘, valâ™¯, Ağ‘,ğ‘™)) â‰  ğ‘¦
â€¢ Zero-Knowledge. For security parameter ğœ†, pp â† zkAI.G(1ğœ†),
for a program ğ‘, PPT algorithm Adv, and simulator S = (S1,S2),
consider the following two experiments:
Pr(cid:104)
ğ‘ ğ‘—
to prove that if the prover gives a wrong value pair in the sequence
of memory accesses, then it is impossible for him to give a final ğ‘€ğ‘¡
such that ğ‘€0 âˆª ğ‘Š ğ‘† = ğ‘€ğ‘¡ âˆª ğ‘…ğ‘†.
Now let us consider the first inconsistent value in the sequence
of memory accesses, happening at step ğ‘—, where 1 â‰¤ ğ‘— â‰¤ ğ‘¡ w.l.o.g.
Since the prover faithfully gives the correct value up to step ğ‘— âˆ’ 1,
we can write ğ‘€ğ‘—âˆ’1 = ğ‘€0 âˆª ğ‘Š ğ‘† ğ‘—âˆ’1 \ ğ‘…ğ‘† ğ‘—âˆ’1, which is the state
of the memory before step ğ‘—. If the prover gives the value pair
, ğ‘¡â€²
(ğ‘ ğ‘— , (ğ‘£â€²
ğ‘ ğ‘—)) that is inconsistent with the real value (ğ‘ ğ‘— , (ğ‘£ğ‘ ğ‘— , ğ‘¡ğ‘ ğ‘—)),
ğ‘ ğ‘—
then this means it is not in ğ‘€ğ‘—âˆ’1. Moerover, this fake value pair
can not appear in following ğ‘Š ğ‘† \ ğ‘Š ğ‘† ğ‘—âˆ’1 because all value pairs in
ğ‘Š ğ‘† \ğ‘Š ğ‘† ğ‘—âˆ’1 has a time step larger than ğ‘¡â€²
which is ensured by the
condition ğ‘¡ â‰¤ ğ‘¡ğ‘  at each step, and ğ‘¡ğ‘  is increasing by 1. As a result,
it is impossible to find ğ‘€ğ‘¡ such that equation 1 holds
ğ‘€ğ‘—âˆ’1 âˆª (ğ‘Š ğ‘† \ ğ‘Š ğ‘† ğ‘—âˆ’1) = (ğ‘…ğ‘† \ ğ‘…ğ‘† ğ‘—âˆ’1) âˆª ğ‘€ğ‘¡ ,
(1)
because the fake pair is not in ğ‘€ğ‘—âˆ’1 or (ğ‘Š ğ‘† \ ğ‘Š ğ‘† ğ‘—âˆ’1), but in (ğ‘…ğ‘† \
ğ‘…ğ‘† ğ‘—âˆ’1). Finally, recall that ğ‘€ğ‘—âˆ’1 = ğ‘€0âˆªğ‘Š ğ‘† ğ‘—âˆ’1\ğ‘…ğ‘† ğ‘—âˆ’1. Substituting
it into Equation 1 shows that ğ‘€0 âˆªğ‘Š ğ‘† = ğ‘…ğ‘† âˆª ğ‘€ğ‘¡ cannot hold. â–¡
D PROOF OF THEOREM 1
Completeness. As explained in Section 3.2, the circuit in zkAI.P
outputs 1 if ğ‘”(Alg(ğ‘, ğ¿â€², ğ‘“ â€²)) = 1. Therefore, the correctness of
Protocol 1 follows the zero-knowledge proof protocol by Theorem 2.
Soundness. By the extractability of the commitment in the zero
knowledge proof backend (Definition 1), with overwhelming prob-
ability, there exists a PPT extractor E such that given comğ‘¤, it ex-
tracts a witness ğ‘¤âˆ— such that comğ‘¤ = ZKP.Commit(ğ‘¤âˆ—, pp). By the
soundness of zkAI in Definition 2, if comğ‘ = zkAI.Commit(ğ‘, pp)
and zkAI.V(comğ‘, (ğ¿â€², ğ‘“ â€², Alg, ğ‘”), ğœ‹, pp) = 1 but ğ‘”(Alg(ğ¿â€², ğ‘“ â€²)) = 0,
let comğ‘¤ = ZKP.Commit(ğ‘¤âˆ—, pp2) during the interactive process
in Protocol 1, then there are two cases.
â€¢ Case 1: ğ‘¤âˆ— = (ğ¶ğ¹ğºâˆ—,ğ‘‡ğ‘Ÿâˆ—, ğ‘Ÿ) such that ğ¶((comğ‘, ğ¶ğ¹ğºâˆ—,ğ‘‡ğ‘Ÿâˆ—, râ€²);
ğ‘¤âˆ—) = 1. Then we know either the control flow graph is not
consistent with the program representation or the iteration check
fails. The probability of both events are negl(ğœ†) as claimed by
the soundness of the checks in 3.2. Hence, the probability that P
could generate such ğ‘¤âˆ— is also negl(ğœ†) by the union bound.
â€¢ Case 2: ğ‘¤âˆ— = (ğ¶ğ¹ğºâˆ—,ğ‘‡ğ‘Ÿâˆ—, ğ‘Ÿ) but ğ¶((comğ‘, ğ¶ğ¹ğºâˆ—,ğ‘‡ğ‘Ÿâˆ—, râ€²); ğ‘¤âˆ—) =
0. Then according to the soundness of Aurora, given the commit-
ment comâˆ—
ğ‘¤, the adversary could generate a proof ğœ‹ğ‘¤ making
V accept the incorrect witness and output 1 with probability
negl(ğœ†).
Combining these two cases, the soundness of the zkAI scheme is
also negl(ğœ†).
Zero-knowledge. The zero-knowledge property follows directly
from the commitment scheme and the zero-knowledge backend we
use.
E ADDITIONAL EXPERIMENTAL RESULTS
Circuit size for our zkAI on synthetic programs. The size of
circuits produced by our zero-knowledge abstract interpretation
schemes for various analyses and sizes are shown in Figure 6.
RealAdv,ğ‘(pp):
(1) comğ‘ â† zkAI.Commit (ğ‘, pp)
(2) (valâ™¯, Ağ‘,ğ‘™ , Alg, ğ‘”) â† Adv(comğ‘, pp)
(3) (ğ‘¦, ğœ‹) â† zkAI.P(ğ‘, (valâ™¯, Ağ‘,ğ‘™ , Alg, ğ‘”), pp)
(4) ğ‘ â† Adv(comğ‘, (valâ™¯, Ağ‘,ğ‘™ , Alg, ğ‘”), ğ‘¦, ğœ‹, pp)
(5) Output b
IdealAdv,SAdv(pp, â„):
(1) com â† S1(1ğœ†, pp)
(2) (valâ™¯, Ağ‘,ğ‘™ , Alg, ğ‘”) â† Adv(com, pp)
(3) (ğ‘¦, ğœ‹) â†SAdv2
(com, (valâ™¯, Ağ‘,ğ‘™ , Alg, ğ‘”), pp),
(4) ğ‘ â† Adv(com, (valâ™¯, Ağ‘,ğ‘™ , Alg, ğ‘”), ğ‘¦, ğœ‹, pp)
(5) Output b
For any PPT algorithm Adv and all programs ğ‘, there exists simu-
lator S such that the following probability is negl(ğœ†):
| Pr[RealAdv,ğ‘(pp) = 1] âˆ’ Pr[IdealAdv,SAdv(pp, â„) = 1]|.
C PROOF OF MEMORY CHECKING
Theorem 2. Let ğ‘€0 be the initial state of the memory of size ğ‘š
known to the verifier. Let (ğ‘1, ğ‘2, ..., ğ‘ğ‘¡) be the sequence of addresses to
access. Following the procedure mentioned in Section 3.2 to construct
ğ‘…ğ‘† and ğ‘Š ğ‘† set, with the additional requirement that ğ‘¡ â‰¤ ğ‘¡ğ‘  at each
step ,if the prover manages to give ğ‘€ğ‘¡ that has the same size as ğ‘€0,
and satisfy ğ‘€0 âˆª ğ‘Š ğ‘† = ğ‘€ğ‘¡ âˆª ğ‘…ğ‘†, then all the values in ğ‘…ğ‘† given by
the prover is consistent with values in the memory computed honestly.
Proof. We use ğ‘…ğ‘†ğ‘–,ğ‘Š ğ‘†ğ‘– to denote the first ğ‘– element of ğ‘…ğ‘† and
ğ‘Š ğ‘† respectively, i.e., the read set and write set after step ğ‘–. We use
ğ‘€ğ‘– to denote the content of memory after step ğ‘–.
First, observe that if the prover faithfully computes the sets and
the memory up to step ğ‘–, then ğ‘€ğ‘– = ğ‘€0 âˆª ğ‘Š ğ‘†ğ‘– \ ğ‘…ğ‘†ğ‘–. We would like
Session 11B: Zero Knowledge II CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea2966(a) Tainting Analysis
(b) Interval Analysis
(c) Control Flow Analysis
Figure 6: Circuit size of our zkAI schemes.
2526272829210211212213214Lines216217218219220221222223224225Circuit Size10variables30variables50variables70variables5010030050010002000Lines219220221222223224225Circuit Size30variables,20%inloop30variables,40%inloop50variables,20%inloop50variables,40%inloop50100300500100020004000Lines219220221222223224225Circuit SizeMultiplicity=1Multiplicity=2Multiplicity=4Multiplicity=8Session 11B: Zero Knowledge II CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea2967