entry->next = LIST_POISON1; 
entry->prev = LIST_POISON2; 
} 
B 
A 
control_ports 
C 
LIST_POISON 
entry = A 
next = B 
prev = control_ports 
A->prev = A->next = POISON 
• Two following objects are deleted 
– Simultaneously! 
• control_ports points to a FREE data 
– LIST_POISON worked – No longer mappable 
– Spraying af_unix_dgram works 
• Iterations on control_ports? 
– Just close a client_port! 
– Notification to all control_ports with  
post_pkt_to_port 
static int post_pkt_to_port(struct msm_ipc_port *UAF_OBJECT, 
    struct rr_packet *pkt, int clone) 
{ 
struct rr_packet *temp_pkt = pkt; 
void (*notify)(unsigned event, void *oob_data, 
       size_t oob_data_len, void *priv); 
void (*data_ready)(struct sock *sk, int bytes) = NULL; 
struct sock *sk; 
mutex_lock(&UAF_OBJECT->port_rx_q_lock_lhc3); 
__pm_stay_awake(UAF_OBJECT->port_rx_ws); 
list_add_tail(&temp_pkt->list, &UAF_OBJECT->port_rx_q); 
wake_up(&UAF_OBJECT->port_rx_wait_q); 
notify = UAF_OBJECT->notify; 
sk = (struct sock *)UAF_OBJECT->endpoint; 
if (sk) { 
read_lock(&sk->sk_callback_lock); 
data_ready = sk->sk_data_ready; 
read_unlock(&sk->sk_callback_lock); 
} 
mutex_unlock(&UAF_OBJECT->port_rx_q_lock_lhc3); 
if (notify) 
notify(pkt->hdr.type, NULL, 0, UAF_OBJECT->priv); 
else if (sk && data_ready) 
data_ready(sk, pkt->hdr.size); 
return 0; 
} 
• wake_up function 
– Macros to __wake_up_common 
static void __wake_up_common( 
wait_queue_head_t *q 
.......) 
{ 
wait_queue_t *curr, *next; 
list_for_each_entry_safe(curr, next, 
 &q->task_list, task_list) { 
... 
if (curr->func(curr, mode, 
 wake_flags, key)) 
break; 
} 
} 
• wake_up function 
– Macros to __wake_up_common 
• New primitive! 
– A call to function with first controllable param 
• Not good enough for commit_creds 
• Upgrade primitives 
• Find a function that can call an arbitrary    
function with address-controlled parameters 
• usb_read_done_work_fn receives a function pointer  
and a function argument 
static void usb_read_done_work_fn( 
struct work_struct *work) 
{ 
struct diag_request *req = NULL; 
struct diag_usb_info *ch = container_of( 
work, struct diag_usb_info, 
read_done_work); 
... 
req = ch->read_ptr; 
... 
ch->ops->read_done(req->buf, 
req->actual,  
ch->ctxt); 
} 
• Chaining function calls –  
__wake_up_common  usb_read_done_work_fn  any function 
static void __wake_up_common( 
wait_queue_head_t *q 
.......) 
{ 
wait_queue_t *curr, *next; 
list_for_each_entry_safe(curr, next, 
 &q->task_list, task_list) { 
... 
if (curr->func(curr, mode, 
 wake_flags, key)) 
break; 
} 
} 
Create UAF situation using the vulnerability 
Spray unix_dgrams to catch the UAF 
UAF 
LIST_POISON 
Trigger list iteration 
UAF 
LIST_POISON 
Sprayed 
Spray unix_dgrams to catch the UAF 
__wake_up_common 
UAF->port_rx_wait_q->task_list 
usb_read_work_done_fn 
usb_read_work_done_fn 
usb_read_work_done_fn 
qdisc_list_del 
enforcing_setup 
commit_creds 
control_ports is empty 
SELinux is permissive 
 UID=0 
cap=CAP_FULL_SET 
Qualaroot 
Ashmem 
IPC  
Router 
GPU 
Thermal 
Performance 
• ID to pointer translation service 
• Handle to kernel objects from user mode 
without using pointers 
User Mode 
Kernel Mode 
Create Object Request 
Return Safe ID 
IDR mechanism 
0xFF6DE000 
1 
1 
create_object() 
CVE-2016-2503 
• SyncSource objects  
– Used to synchronize activity between the GPU  
and the application 
• Can be created using IOCTLs to the GPU 
– IOCTL_KGSL_SYNCSOURCE_CREATE 
– IOCTL_KGSL_SYNCSOURCE_DESTROY 
• Referenced with the IDR mechanism 
1 
2 
1 
0 
long kgsl_ioctl_syncsource_destroy( 
struct kgsl_device_private *dev_priv, 
unsigned int cmd, void *data) 
{ 
struct kgsl_syncsource_destroy *param = data; 
struct kgsl_syncsource *syncsource = NULL; 
syncsource = kgsl_syncsource_get( 
dev_priv->process_priv, 
 param->id); 
     if (!syncsource) 
         goto done; 
/* put reference from syncsource creation */ 
kgsl_syncsource_put(syncsource); 
/* put reference from getting the syncsource above */ 
kgsl_syncsource_put(syncsource); 
done: 
return 0; 
long kgsl_ioctl_syncsource_destroy( 
struct kgsl_device_private *dev_priv, 
unsigned int cmd, void *data) 
{ 
struct kgsl_syncsource_destroy *param = data; 
struct kgsl_syncsource *syncsource = NULL; 
syncsource = kgsl_syncsource_get( 
dev_priv->process_priv, 
 param->id); 
     if (!syncsource) 
         goto done; 
/* put reference from syncsource creation */ 
kgsl_syncsource_put(syncsource); 
/* put reference from getting the syncsource above */ 
kgsl_syncsource_put(syncsource); 
done: 
return 0; 
Any “pending free” check here? 
Thread A 
CVE-2016-2503 
Thread B 
REFCOUNT == 2 
REFCOUNT == 1 
REFCOUNT == 0 
REFCOUNT == 0 
REFCOUNT == -1 
syncsource = kgsl_syncsource_get(id); 
… 
… 
kgsl_syncsource_put(syncsource); 
… 
… 
kgsl_syncsource_put(syncsource); 
free, sprayable data 
syncsource = kgsl_syncsource_get(id); 
… 
… 
kgsl_syncsource_put(syncsource); 
… 
… 
kgsl_syncsource_put(syncsource); 
CVE-2016-2503 
• Create a syncsource object 
– A predictable IDR number is allocated 
• Create 2 threads constantly destroying the same  
IDR number 
• Ref-count will be reduced to -1 
– Right after getting to zero, object can be sprayed 
Use After Free  
Ashmem 
IPC  
Router 
GPU 
Thermal 
Performance 
CVE-2016-2504 
• GPU main module (kgsl-3d0) 
• Map user memory to the GPU 
– IOCTL_KGSL_MAP_USER_MEM 
– IOCTL_KGSL_GPUMEM_FREE_ID 
• Referenced by a predictable ID 
– IDR mechanism 
long kgsl_ioctl_gpumem_free_id( 
struct kgsl_device_private *dev_priv, 
unsigned int cmd, void *data) 
{ 
struct kgsl_gpumem_free_id *param = data; 
struct kgsl_mem_entry *entry = NULL; 
entry = kgsl_sharedmem_find_id(private, 
         param->id); 
if (!entry) { 
return -EINVAL; 
} 
return _sharedmem_free_entry(entry); 
} 
static long _sharedmem_free_entry( 
struct kgsl_mem_entry *entry) 
{ 
bool should_free = atomic_compare_exchange( 
entry->pending_free, 
 0, /* if pending_free == 0 */ 
  1); /* then set pending_free = 1 */ 
kgsl_mem_entry_put(entry); 
if(should_free) 
kgsl_mem_entry_put(entry); 
return 0; 
} 
static int 
kgsl_mem_entry_attach_process( 
struct kgsl_mem_entry *entry, 
struct kgsl_device_private *dev_priv) 
{ 
id = idr_alloc(&process->mem_idr, 
 entry, 1, 0, GFP_NOWAIT); 
... 
ret = kgsl_mem_entry_track_gpuaddr( 
process, entry); 
... 
ret = kgsl_mmu_map(pagetable, 
 &entry->memdesc); 
if (ret) 
kgsl_mem_entry_detach_process(entry); 
return ret; 
} 
CVE-2016-2504 
1 
2 
3 
4 
5 
6 
6 
entry = kgsl_mem_entry_create(); 
… 
… 
id = idr_alloc(…, entry, …); 
… 
… 
initialize_entry(entry); 
entry = kgsl_sharedmem_find_id(id); 
… 
… 
if(!entry) 
return –EINVAL; 
… 
… 
_sharedmem_safe_free_entry(entry); 
IDR items 
Thread B - releaser 
Thread A - allocator 
Thread B - releaser 
CVE-2016-2504 
Thread A - allocator 
1 
2 
3 
4 
5 
6 
free, sprayable data 
IDR items 
entry = kgsl_sharedmem_find_id(id); 
… 
… 
if(!entry) 
return –EINVAL; 
… 
… 
_sharedmem_safe_free_entry(entry); 
entry = kgsl_mem_entry_create(); 
… 
… 
id = idr_alloc(…, entry, …); 
… 
… 
initialize_entry(entry); 
CVE-2016-2504 
• Map memory 
• Save the IDR 
– Always get the first free IDR – predictable 
• Another thread frees the IDR 
– Before the first thread returns from the IOCTL 
UAF in kgsl_mem_entry_attach_process on ‘entry’ parameter 
Syncockaroot (CVE-2016-2503) 
4th April, 2016 
Vulnerability disclosure to 
Qualcomm 
2nd May, 2016 
Qualcomm confirmed the 
vulnerability 
6th July, 2016 
Qualcomm released a public 
patch 
6th July 
Google deployed the patch to 
their Android devices 
Kangaroot (CVE-2016-2504) 
4th April, 2016 
Vulnerability disclosure to 
Qualcomm 
2nd May, 2016 
Qualcomm confirmed the 
vulnerability 
6th July, 2016 
Qualcomm released a public 
patch 
1st August, 2016 
Google deployed the patch to 
their Android devices 
ASHmenian Devil (CVE-2016-5340) 
10th April, 2016 
Vulnerability disclosure to 
Qualcomm 
02nd May, 2016 
Qualcomm confirmed the 
vulnerability 
28th July, 2016 
Qualcomm released a public 
patch 
TBD 
Google deployed the patch to 
their Android devices 
Qualaroot (CVE-2016-2059) 
2nd February, 2016 
Vulnerability disclosure to 
Qualcomm 
10th February, 2016 
Qualcomm confirmed the 
vulnerability 
29th April, 2016 
Qualcomm released a public 
patch 
TBD 
Google deployed the patch to 
their Android devices 
• Disclosure 
SELinux, for being liberal, 
letting anyone access mechanisms like Qualcomm’s IPC 
commit_creds for always being there for me 
Absense of kASLR,  
for not breaking me and commit_creds apart 
Google Play 
QuadRooter Scanner 
Adam Donenfeld 
PI:EMAIL