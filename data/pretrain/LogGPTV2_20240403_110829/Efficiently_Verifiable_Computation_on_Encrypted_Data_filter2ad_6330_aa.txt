title:Efficiently Verifiable Computation on Encrypted Data
author:Dario Fiore and
Rosario Gennaro and
Valerio Pastro
Eﬃciently Veriﬁable Computation on Encrypted Data(cid:63)
Dario Fiore1, Rosario Gennaro2, and Valerio Pastro2
1 IMDEA Software Institute
PI:EMAIL
2 Center for Algorithms and Interactive Scientiﬁc Software, The City College of New York
{rosario,pastro}@cs.ccny.cuny.edu
Abstract. We study the task of veriﬁable delegation of computation on encrypted data. We improve
previous deﬁnitions in order to tolerate adversaries that learn whether or not clients accept the result
of a delegated computation. In this strong model, we construct a scheme for arbitrary computations
and highly eﬃcient schemes for delegation of various classes of functions, such as linear combinations,
high-degree univariate polynomials, and multivariate quadratic polynomials. Notably, the latter class
includes many useful statistics. Using our solution, a client can store a large encrypted dataset on a
server, query statistics over this data, and receive encrypted results that can be eﬃciently veriﬁed and
decrypted.
As a key contribution for the eﬃciency of our schemes, we develop a novel homomorphic hashing
technique that allows us to eﬃciently authenticate computations, at the same cost as if the data
were in the clear, avoiding a 104 overhead which would occur with a naive approach. We support our
theoretical constructions with extensive implementation tests that show the practical feasibility of our
schemes.
(cid:63) An extended abstract of this paper appears in the proceedings of ACM CCS 2014. This is the full version.
Table of Contents
1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
1.1 Our Contribution . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
1.2 Other Related Work . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2 Problem Deﬁnition . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
3 A Generic Solution . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
3.1 Homomorphic Encryption . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
3.2 The Generic Scheme . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
4 Tools . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
4.1 A Somewhat Homomorphic Encryption for Quadratic Functions . . . . . . . . . . . . . . . . .
4.2 Homomorphic Hash Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
4.3 Amortized closed-form Eﬃcient Pseudorandom Functions . . . . . . . . . . . . . . . . . . . . . . .
5 Computing Multi-Variate Polynomials of Degree 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
6 Computing Polynomials of Large Degree . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
7 Computing Linear Combinations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
8 Computing Linear Functions over the ring Z
2k . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
9 Applications . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
9.1 Statistics on Encrypted Data Sets . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
9.2 Distance and Correlation Measures on Encrypted Data Sets . . . . . . . . . . . . . . . . . . . . .
9.3 Discrete Fourier Transform . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
10 Experimental Evaluation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
10.1 Setup . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
10.2 Timings . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
3
3
7
8
11
12
12
14
15
17
20
23
29
31
33
36
36
37
38
38
38
39
1 Introduction
Can an outside party compute for us, without learning our private data? Can we eﬃciently check
that it performed the computation correctly? These are some central questions related to the privacy
and the security of cloud computing, a paradigm where businesses buy computational time from a
service, rather than purchase and maintain their own resources. Both questions have a long research
history.
Computing arbitrary functions on encrypted data was a research interest recognized very early
by cryptographers [52], and it remained open until Gentry’s construction of the ﬁrst fully homo-
morphic encryption (FHE) scheme [29]. Gentry’s work revealed a new set of techniques that were
immediately used for many more eﬃcient schemes [30,57,31,20,19,32,18]; today we seem to stand
at the verge of having FHE schemes which can be used in practice.
Eﬃcient veriﬁcation of arbitrarily complex computations was the underlying goal of interactive
proofs [4,37], where a powerful (e.g. super-polynomial) prover can (probabilistically) convince a
weak (e.g. polynomial) veriﬁer of the truth of statements that the veriﬁer could not compute on its
own. Research on making the veriﬁer as eﬃcient as possible led to the concept of probabilistically
checkable proofs (PCPs) [3,6,5], and their cryptographic applications: the arguments of Kilian
[42,43] and Micali’s non-interactive CS Proofs [48].
The application to cloud computing has rekindled attention to this area, particularly in the
search for protocols where arbitrary poly-time (as opposed to superpoly-time) computations can
be eﬃciently veriﬁed by a linear (or quasi-linear) veriﬁer, and performed by a prover without too
much overhead. Starting with the work on proofs for muggles [35], a line of research revisited and
“scaled down” the PCP machinery [36,13,14]. Another line of work explored alternative ways of
arithmetizing computations to construct eﬃcient proofs [38,45,27]. Yet another approach used FHE
as a tool to build eﬃcient veriﬁcation of arbitrary computations [26,2,23]. Several implementational
eﬀorts [24,54,55,59,49,11,60] show that also in this area we are on the verge of achieving practical
eﬃciency, with the quadratic span program techniques of [27,49] showing particular promise.
1.1 Our Contribution
Given the practical and theoretical relevance of this topic, as well as the level of maturity of the
ﬁeld, it is somewhat surprising that most of the research was focused on solving either one of the
two main questions. There are many results about ﬁnding eﬃcient FHE schemes, and therefore
eﬃcient computation on encrypted data, but without veriﬁcation of its correctness. On the other
hand, the works on verifying computation mostly focused on the case where the data is in the clear
or in a restricted model for privacy – a notable exception is the construction of Goldwasser et al.
[34], based on functional encryption.
The protocols for veriﬁable computation (VC) in [26,23,2] use FHE as a tool for veriﬁability,
and almost as a by-product, they achieve data privacy as well, but in a restricted sense: namely,
only if the client’s acceptance bit is kept hidden from the server, i.e. the server is not allowed to
issue veriﬁcation queries. Also, in [26] only the topology of the function is revealed [10]. In [26], a
formal deﬁnition of all the properties needed by a VC scheme is given, including input privacy, but
still in absence of veriﬁcation queries.
This model is quite restrictive in practice, as in real life the client’s acceptance bit may leak
due to multiple reasons: error messages, protocol termination, recomputation, etc.
3
To the best of our knowledge, no deﬁnition of private and secure VC with presence of veriﬁcation
queries can be found in the literature. We give such deﬁnitions, provide schemes that satisfy them,
and support our constructions with experimental results. Our contribution, in a list:
1. An upgrade to the deﬁnition in [26] that allows veriﬁcation queries by the adversary, and an
extension of this deﬁnition that models adaptive security and function privacy. This is the
strongest possible model in which we can deﬁne security.
2. A protocol based on FHE for arbitrary computations.
3. Constructions for speciﬁc families of functions to compute: multivariate quadratic polynomials,
univariate polynomials of high degree, linear combinations – all on encrypted data (details on
Table 1). Using our schemes a client can outsource the storage of large, privacy-sensitive, data
sets (e.g. location, medical, genomic data) on a server, and get statistics or distance measures
(computed by the server) on them, with guarantees of correctness of the computation and
privacy of the data.
4. A key technical contribution is the introduction of a homomorphic hashing technique that
allowed us to obtain improvements of more than four orders of magnitude compared to a naive
approach.
5. Implementations and performance numbers of our schemes for practical security parameters.
Now, we discuss our contribution and the related work more in detail.
Our Generic Protocol. Our protocol assumes the existence of an FHE scheme and a not-
necessarily private, but secure VC scheme, e.g. [27]. The basic idea is to encrypt the data x with
the FHE scheme, and to run the VC scheme on the function EvalFHE(f ), instead of f , and on input
EncFHE(x) instead of x. This technique prevents the server from using the client as a decryption
oracle for the FHE, since the acceptance bit is determined before decryption, just according to the
correctness of the evaluation of EvalFHE(f ).
Ad-Hoc Protocols. We focus on the problem where a client stores a large data set x = (x0, . . . , xt)
on a server and later asks the server to compute functions f over x. Our solutions work in the amor-
tized model in which the client spends a single pre-processing phase whose cost is as running f (x),
and later amortizes this one-time cost over several function evaluations. Moreover, our protocols
work also in the so-called streaming model: clients can process and outsource single data items xi
in a separate fashion. This is desirable for storing applications, since it enables clients to work with
a very small memory, independent of the size of the (possibly huge) data set. As an example, think
of a set of weak devices that read the temperature in given locations, and daily send the data to a
server to store for later analysis (e.g. calculate the mean temperature in a year).
We focus on the case where the data sets consist of elements in a ﬁnite ﬁeld Fp, and the
outsourced functions can be: (1) quadratic multi-variate polynomials, (2) univariate polynomials
of large degree, and (3) linear combinations.
Multi-Variate Quadratic Polynomials. We constructed a VC scheme in the case the client
stores several encrypted data sets at the server, and then asks it to compute a quadratic polynomial
f on any of the outsourced sets. In our solution, after a single pre-processing for every f , the client
can verify results in constant time. Moreover, our scheme achieves input and output privacy.
In terms of applications, this scheme allows to compute several statistics (average, variance,
covariance, RMS, linear regression, correlation coeﬃcient, and many more) on remotely stored data
sets in a private and veriﬁable manner. We also consider the application in which a client stores a
large matrix X on the server, and then asks to compute a distance measure (e.g. Euclidean distance)
4
Scheme
Linear combinations
t-variables over Fp
Linear combinations
t-variables over Z
2k
Univariate Poly
of degree t over Fp
t-variate Poly
of degree 2 over Fp
t-variate Restricted Poly
of degree 2 over Fp
Input
Privacy
Function
Privacy
Amortized
Veriﬁcation
(cid:88)
(cid:88)
×
(cid:88)
(cid:88)
(cid:88)
×
(cid:88)
×
(cid:88)
O(t)
O(1)
O(1)
O(1)
O(1)
Table 1. Summary of our schemes.
between a given vector y and any row of X. We propose a variant of our scheme that is function
private for a restricted class of quadratic polynomials (privacy holds only for the coeﬃcients of the
linear terms). Yet, since the above application ﬁts such restriction, we give a solution in which both
X and y are private.
We are not aware of any other existing solution for privately evaluating multivariate quadratic
polynomials, except by instantiating our paradigm with existing tools [19,7]. Even compared to
these solutions, our experiments show that our ad-hoc protocol improves signiﬁcantly: for instance,
in our scheme the computation of the variance function at the server is more than 104 times faster!
If we consider cloud computing, in which clients pay for the server’s CPU cycles, such improvement
leads to worthwhile savings.
Px(z) = (cid:80)t
Polynomials of High Degree. We also constructed a VC scheme for a setting which is comple-
mentary to the one above. Namely, we think of x as the coeﬃcients of a uni-variate polynomial
j=0 xizi of degree t. With our protocol the client stores the large polynomial Enc(Px)
at the server, and then asks it to compute Enc(Px(z)) on many diﬀerent points z (provided in the
clear). Here, after the single preprocessing to outsource Px, the client can verify all the computations
in constant time. Moreover, our scheme is function private as Px is encrypted.
In terms of applications, we discuss how this solution can be used to outsource the Discrete
Fourier Transform computation on encrypted vectors.
Linear Combinations. Finally, we considered the task of outsourcing linear combinations. For
this we constructed a very clean and eﬃcient solution which provides both input and function
privacy, but has no eﬃcient veriﬁcation. However, the client can work with a very short memory in
the streaming model. We note that a solution with eﬃcient veriﬁcation (achieving both input and
function privacy) can be obtained by using our variant scheme for quadratic polynomials. Compared
to the latter, the advantage of our dedicated scheme is eﬃciency: we achieve veriﬁability by using
information-theoretic techniques that do not require expensive, cryptographic computations (e.g.
over bilinear groups).
An Overview of Our Techniques. To design our protocols we follow the blueprint of our generic
scheme and we develop additional techniques that provide signiﬁcant eﬃciency improvements. Our
basic idea is to encrypt the data with a somewhat homomorphic encryption scheme (for privacy),
5
and to add an authentication mechanism on top of the ciphertexts (for security). For the encryption,
we chose a slightly modiﬁed version of the scheme by Brakerski and Vaikuntanathan (BV) [20].
The server stores µ = (µ0, . . . , µt) where µi is a BV encryption of xi. For authentication, we rely on
homomorphic MACs [28]. In a nutshell, this primitive enables a client to use a secret key to authen-
ticate a set of messages m1, . . . , mt by producing corresponding tags σ1, . . . , σt. Later, given such
tags, anyone (without any secret key) can produce a tag σ that authenticates m = f (m1, . . . , mt)
as the output of f on the previously authenticated inputs. Interestingly, veriﬁcation can be per-
formed without knowing the original messages, and recently proposed schemes [7] allow to verify
more eﬃciently than running f . The generic idea for our schemes is to generate a MAC σi for