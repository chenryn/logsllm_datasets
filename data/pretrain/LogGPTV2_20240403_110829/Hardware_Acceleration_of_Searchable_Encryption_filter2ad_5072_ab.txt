5:
6:
7:
8:
9:
11:
12:
13:
15:
5
9:
3:
6:
8:
else
2:
3:
4:
5:
6:
Scheme 1 IM-DSSE Scheme (continued)
(√´,)‚Üê IM-DSSE.(,): Given search token and encrypted index, return sets of (cid:27)le identi(cid:27)ers
√´ and encrypted (cid:27)les‚äÜ  matching with
1: for=1,‚Ä¶, do
‚Üê[].
if(=(,)‚à®[,].=1) then
[,]‚Üê[,]‚äï(||||) and set[,].‚Üê0
[,]‚Üê[,]‚äï(||||) and set[,]‚Üê[,]‚äï(||||)
7:‚Üê0
8: for each‚àà{1,‚Ä¶,} satisfying[,]=1 do
‚Üê+1 and‚Üê
10: √´‚Üê{1,‚Ä¶,}
11:‚Üê(,),‚Üê{(1,1),‚Ä¶,(,)}
12: return(√´,)
(,)‚Üê IM-DSSE.(√≠,): Given key√≠ and a (cid:27)le, generate add token and ciphertext of
1:‚Üê2(),‚Üê(),[].‚Üê[].+1 and‚Üê[].
2: for=1,‚Ä¶, do
‚Üê3(||), where‚Üê[].
4: Extract(1,‚Ä¶,) from and set[‚àó,]‚Üê0
5: for=1,‚Ä¶, do
‚Üê2(),‚Üê(),[,]‚Üê1
7: for=1,‚Ä¶, do
[,]‚Üê[,]‚äï(||||)
9:‚Üê(,), where‚Üê √ß.1(,||)
10: return(,) where‚Üê(,)
(,)‚Üê IM-DSSE.(,,,): Add token and ciphertext to encrypted index and set, resp.
1: Set[,]‚Üê[,] and[,].‚Üê1, for1‚â§‚â§
2:[].‚Üê[].+1
3: return(,), where‚Üê(,) and‚Üê ‚à™{(,)}
‚Üê IM-DSSE.(√≠,): Given key√≠ and deleted (cid:27)le, generate deletion token
1: Execute steps (1-3) of Algorithm that produces(,,1,‚Ä¶,) and increases[]. to 1
2: for=1,‚Ä¶, do
[]‚Üê(|||)
4: return , where‚Üê(,)
(,)‚Üê IM-DSSE.(,,): Update token in encrypted index and delete a (cid:27)le from set
1: Set[,]‚Üê[,] and[,].‚Üê1, for1‚â§‚â§
2:[].‚Üê[].+1
3: return(,), where‚Üê(,),‚Üê {(,)}
scheme as follows: Assume the client wants to update (cid:27)le by adding (or removing) some keywords,
Keyword update for existing (cid:27)les. Some existing schemes (e.g., [24]) only permit adding or deleting a
(cid:27)le, but do not permit updating keywords in an existing (cid:27)le directly. It is easy to achieve this in our
3:
6
of the algorithm remains the same.
overall end-to-end search delay which is dominated by the network communication latency between
client and server. Moreover, notice that all sub-linear DSSE schemes [27, 5] are less secure and some-
cally less e(cid:28)cient than other DSSE schemes (e.g., [5, 3]), we show in the experiment that, this impact is
insigni(cid:27)cant in practice for personal cloud usage with moderate database size where all optimizations
she will prepare a new column[,]‚Üê for1‚â§‚â§, where=1 if is added and=0 if
otherwise and‚Üê() with‚Üê2() as in IM-DSSE. algorithm (steps 4-6). The rest
Analytical analysis. For keyword search, IM-DSSE incurs invocations of hash function and
XOR operations. Despites the fact that IM-DSSE has linear search complexity which is asymptoti-
computation times can be reduced to/ and/, respectively, where is the number of processors in
are taken into account. Speci(cid:27)cally, since IM-DSSE is fully parallelizable, the search and update
the system. Therefore, cryptographic operations in IM-DSSE only contribute a small portion to the
times incur more costly updates than IM-DSSE. For (cid:27)le update operation, IM-DSSE incurs
invocations of and XOR operations along with bits of transmission.
Regarding to storage overhead, IM-DSSE costs2‚ãÖ+‚ãÖ+|| bits at the server for
encrypted index and (cid:27)le hash table . At the client side, IM-DSSE requires(+)+|| +3
bits for two hash tables, and secret key√≠.
We now present e(cid:28)cient extended schemes derived from IM-DSSE scheme in Section 2 that our
In IM-DSSE, we encrypt each cell of with a unique key-counter pair, which requires invocations
of during keyword search. This might not be ideal for some applications that require extremely
ing the index bit-by-bit as in IM-DSSE scheme, IM-DSSEI leverages-bit block cipher encryption
to encrypt successive cells with the same key-counter pair. This is achieved by interpreting columns
of as=‡§Ñ‡§Ö blocks, each being IND-CPA encrypted using counter (CTR) mode with block cipher
size. The counter will be stored via a block counter array (denoted) instead of[‚ãÖ]. as in the
main scheme. The update state is maintained for each block rather than each cell of[,]. Hence, is
decomposed into two matrices with di(cid:29)erent sizes:.‚àà{0,1}√ó and.‚àà{0,1}√ó.
cally, we substitute encryption and decryption using(||||) with√ß.(‚ãÖ,||) and√ß.(‚ãÖ,||),
respectively, where is a block counter stored in. Since is encrypted by blocks, the client needs to
modi(cid:27)cations for (cid:27)le deletion follow the same principle. The and algorithms of IM-DSSEI are
retrieve a whole block and the states (cid:27)rst before being able to update a column residing in the block
during (cid:27)le update. Therefore, the reduction of search cost increases the cost of communication over-
head for the update as a trade-o(cid:29). We present modi(cid:27)ed algorithms for (cid:27)le addition in Scheme 2. The
3 Extended IM-DSSE Schemes
IM-DSSE framework also supports.
3.1 IM-DSSEI: Minimized search latency
prompt search delay. Hence, we introduce an extended scheme called IM-DSSEI, which aims at achiev-
ing a very low search latency with the cost of increasing update delay. Speci(cid:27)cally, instead of encrypt-
IM-DSSEI requires some straightforward algorithmic modi(cid:27)cations from the main scheme. Speci(cid:27)-
identical to those of the main scheme.
7
5:
8:
9:
10:
11:
12:
16:
17:
18:
Scheme 2 IM-DSSEI Scheme
(,)‚Üê(√≠,): Given key√≠ and a (cid:27)le, generate addition token and ciphertext of
1:‚Üê2(),‚Üê(),‚Üê√¶‚àí1√¶,‚Üê[]
2:‚Üê(‚ãÖ)+1,‚Üê‚ãÖ(+1)
3: Extract(1,‚Ä¶,) from
4: for=1,‚Ä¶, do
‚Üê2(),‚Üê()
6: Get from server([‚àó,‚Ä¶]) and[‚àó,].
7: for=1,‚Ä¶, do
‚Üê[].
if (>1‚àß[,].=0) then
‚Üê‚àí1
‚Üê3(||)‚Ä†
[,‚Ä¶,]‚Üê √ß.([,‚Ä¶],||)
13:[,]‚Üê0 for1‚â§‚â§ and[,]‚Üê1 for1‚â§‚â§
14:[]‚Üê[]+1,‚Üê[]
15: for=1,‚Ä¶, do
if (>1‚àß[,].=0) then
‚Üê3(||+1)
[,‚Ä¶]‚Üê √ß.([,‚Ä¶],||)
19:[].‚Üê[].+1 and‚Üê[].
20:‚Üê(,) where‚Üê √ß.1(,||)
21: return(,) where‚Üê(,)
(,)‚Üê(,,,): Add token and ciphertext to encrypted index and ciphertext set, resp.
1:‚Üê√¶‚àí1√¶,‚Üê(‚ãÖ)+1,‚Üê(+1)
2:[,]‚Üê[,], for1‚â§‚â§ and‚â§‚â§
3:[]‚Üê[]+1 and[‚àó,].‚Üê1
4: return(,), where‚Üê(,) and‚Üê ‚à™{}
‚Ä† should generate a suitable key for√ß (e.g.,128-bit key for AES-CTR)
Analytical analysis. For keyword search, IM-DSSEI requires/ invocations of √ß, which is theoret-
ically times faster than the main scheme. Given the CTR mode, the search time can be reduced to
/(‚ãÖ), where is the number of processors in the system. For update, IM-DSSEI requires transmis-
sion of(2+1)‚ãÖ bits along with decryption and encryption operations at the client side, compared
with non-interactive transmission and encryption-only in the main scheme. Thus, IM-DSSEI o(cid:29)ers a
trade-o(cid:29) where the search speed is increased by a factor of (e.g.,=128) with the cost of transmitting
(2+1)‚ãÖ bits in update operation. IM-DSSEI reduces the server storage overhead to‚ãÖ||+‚ãÖ‚ãÖ(+1)


bits, while the client storage remains the same as in IM-DSSE.
3.2 IM-DSSEII: Achieving cloud SaaS infrastructure with backward privacy
All DSSE schemes introduced so far require the server to perform some computation (i.e., encryp-
tion/decryption) during keyword search, which might not be fully compatible with typical cloud sys-
tems (e.g., Dropbox, Google Drive, Amazon S3) that generally only o(cid:29)ers storage-only services. Hence,
8
Scheme 3 IM-DSSEII Scheme
(√´,)‚Üê(√≠,): Given keyword and key √≠, return sets of (cid:27)le identi(cid:27)ers √´ and encrypted (cid:27)les
‚äÜ  matching with
1:‚Üê2(),‚Üê(),‚Üê3(),‚Üê0
2: Fetch the‚Äôth row data[,‚àó] from server
3: for=1,‚Ä¶, do
‚Üê[].
[,]‚Üê[,]‚äï(||||)
6: for each‚àà{1,‚Ä¶,} satisfying[,]=1 do
‚Üê+1 and‚Üê
8: √´‚Üê{1,‚Ä¶,}
9: Send√´ to server and receive={(1,1),‚Ä¶,(,)}
10:‚Üê√≠() for1‚â§‚â§
11: return(√´,√®), where√®‚Üê{1,‚Ä¶,}
we propose another extended scheme derived from IM-DSSE scheme called IM-DSSEII, where all
4:
5:
7:
forward-privacy during update. The detail is as follows.
computations during keyword search are performed at the client side while the server does nothing
rather than serving as a storage service. This simple trick makes IM-DSSEII not only compatible with
the current infrastructure of SaaS clouds, but also more importantly, achieve the backward-privacy
property. This is because the server is no longer able to decrypt any part of encrypted index to keep
track of historical update operations. Additionally, IM-DSSEII also reduces the storage overhead at
both client and server sides by eliminating the need of state matrix and keywords counters, which is
used in IM-DSSE and IM-DSSEI schemes to perform correct decryption during keyword search and
To search a keyword, the client sends to the server the‚Äôs row index and receives the corre-
sponding row. The client decrypts row, obtains the column indexes, where[,]=1. The client
then fetches and decrypts encrypted (cid:27)les indexed at to obtain the search result. We present the key-
word search of IM-DSSEII in Scheme 3, which is a protocol combined from IM-DSSE. and
IM-DSSE. algorithms in IM-DSSE scheme. Since everything is computed by the client, it is
not required to derive new keys for forward-privacy and therefore, state matrix[‚àó,‚àó]. as well as (cid:27)le
hash table at the server and keyword counters. at the client are not needed in IM-DSSEII.
Therefore, the modi(cid:27)cations of IM-DSSE., IM-DSSE., IM-DSSE., IM-DSSE.,
IM-DSSE. algorithms are straightforward by (i) substituting row key generation ‚Üê
3(,) by‚Üê3(), (ii) omitting all keyword counters, block states[‚àó,‚àó]., at the server
(e.g., step 2, IM-DSSE. algorithm) and all operations involved.
Analytical analysis. The computation cost of IM-DSSEII is identical to the main scheme (i.e., and
 invocations of for search and update resp.), except that the decryption is performed at the client,
instead of the server during keyword search. However, IM-DSSEII requires bits of transmission and a
two-round communication. IM-DSSEII reduces the client and sever storage costs to+||+‚ãÖ+3
and‚ãÖ bits, respectively.
IM-DSSEI and IM-DSSEII schemes. Speci(cid:27)cally in IM-DSSEI+II, the incidence matrix is encrypted
with-bit block cipher encryption, and the decryption is performed by the client during search. Since
Our IM-DSSE also supports IM-DSSEI+II, an extended DSSE scheme which is the combination between
3.3 IM-DSSEI+II: Low search latency, backward-privacy and compatible with cloud
SaaS infrastructure
9
IM-DSSEI+II inherits all properties of IM-DSSEI and IM-DSSEII schemes, IM-DSSEI+II is highly desirable
for cloud SaaS infrastructure that requires a very low search latency and backward-privacy with the
costs of more delayed update and an extra communication round during search.
4 Security Analysis
In this section, we analyze the security and update privacy of all DSSE schemes provided in our IM-DSSE
framework.
the same keyword has been searched in the past or not.
We consider the following leakage functions, in the line of [16] that captures dynamic (cid:27)le addi-
tion/deletion in its security model as we do, but we leak much less information compared to [16].
4.1 Security Model
Most known e(cid:28)cient SSE schemes (e.g., [27, 5, 24]) reveal the search and (cid:27)le-access patterns de(cid:27)ned as
follows:
‚Ä¢ Given search query at time, the search pattern(, Query,) is a binary vector of length with a 1
at location if the search time‚â§ was for, and 0 otherwise. The search pattern indicates whether
‚Ä¢ Given search query at time, the (cid:27)le-access pattern∆ä(,√®,,) is identi(cid:27)ers√´ of (cid:27)les having.