it places no restrictions on the set of acceptable certiﬁcates
beyond what the user agent would normally enforce. That
is, HSTS simply requires any valid TLS connection with a
trusted certiﬁcate. It
is not designed as a defense against
insecure HTTPS due to rogue certiﬁcates (see Section II-C),
only against the absence of HTTPS completely.
2) HSTS headers: The primary means
for a server
to establish HSTS is by setting the HTTP header
[5]
Strict-Transport-Security. Compliant user agents
will apply an HSTS policy to a domain once the header has
been observed over an HTTPS connection with no errors. Note
that setting the header over plain HTTP has no effect although
a number of sites do so anyway (see Section IV-E).
In addition to the optional includeSubDomains di-
rective, an HSTS header must specify a max-age directive
instructing the user agent on how long to cache the HSTS
policy. This value is speciﬁed in seconds and represents a
commitment by the site to support HTTPS for at least that
time into future. It is possible to “break” this commitment by
serving an HSTS header with max-age=0 but this directive
must be served over HTTPS.
For regularly-visited HSTS domains (at
least once per
max-age period), the policy will be continually updated and
prevent HTTP trafﬁc indeﬁnitely. This can be described as a
continuity policy.5 A known shortcoming of HSTS is that it can
not protect initial connections or connections after extended
inactivity or ﬂushing of the browser’s HSTS state. HSTS policy
3Jackson and Barth [21] originally proposed that servers would request
HSTS status by setting a special cookie value, but this was ultimately changed
to be an HTTP header.
4Note that includeSubDomains covers subdomains to arbitrary depth
unlike wildcard certiﬁcates, which only apply to one level of subdomain [14].
5HSTS can also be described as a “trust-on-ﬁrst-use” (TOFU) scheme. We
prefer the term continuity which does not imply permanent trust after ﬁrst use.
3
caching may also be restricted by browser privacy concerns.
For example, policies learned during “private browsing” ses-
sions should be discarded because they contain a record of
visited domains.
HSTS is also vulnerable to an attacker capable of manipu-
lating the browser’s notion of time so that it thinks a policy has
expired, for example by manipulating the NTP protocol [22].
3) HSTS preloads: To address the vulnerability of HTTPS
stripping before the user agent has visited a domain and
observed an HSTS header, Chrome and Firefox both now ship
with a hard-coded list of domains receiving a preloaded HSTS
policy.This approach reduces security for preloaded domains
to maintaining an authentic, up-to-date browser installation.
receive
an
domains
Preloaded
automatic HSTS
policy from the browser
and may optionally specify
includeSubDomains.6 There is no per-domain max-age
speciﬁcation, however in Chrome’s implementation, the entire
preload list has an expiration date if the browser is not
regularly updated.
4) HTTPS Everywhere: The EFF’s HTTPS Everywhere
browser extension7 (available for Chrome and Firefox) pro-
vides similar protection for a much larger list (currently over
5,000 domains). It has been available since 2011. The HTTPS
Everywhere extension relies on a large group of volunteers
to curate a preload list in a distributed manner. Because it
is an optional (though popular) browser extension, HTTPS
Everywhere is willing to tolerate occasional over-blocking
errors in return for increased coverage compared to the more
conservative preload lists. Because HTTPS Everywhere is
crowd-sourced, errors are due to the developers and not site
operators themselves. Hence we do not study it in this work.
C. Key pinning
HSTS is useful for forcing trafﬁc to utilize HTTPS; how-
ever, it has no effect against an attacker able to fraudulently
obtain a signed certiﬁcate for a victim’s domain (often called
a rogue certiﬁcate) and use this certiﬁcate in a man-in-the-
middle attack. Because every trusted root in the browser can
sign for any domain, an attacker will succeed if they are
able to obtain a rogue certiﬁcate signed by any trusted root
(of which there are hundreds [23]–[25]). This vulnerability
has long been known and security researchers have obtained
several rogue certiﬁcates by exploiting social engineering and
other ﬂaws in the certiﬁcate authority’s process for validating
domain ownership [3].
However, in 2010 it was reported publicly for the ﬁrst time
that commercial software was available for sale to government
agencies to utilize rogue certiﬁcates to intercept trafﬁc en
masse [6]. This report raised the concern of governments
using compelled certiﬁcates obtained by legal procedures or
extralegal pressure to perform network eavesdropping attacks.
In addition to the risk of government pressure, a number
of high-proﬁle CA compromises have been detected since
6The syntax between HSTS preloads and HSTS headers is unfortunately
incompatible, with includeSubDomains speciﬁed in the former and
include_subdomains used in the latter along with other minor details
we will omit for clarity.
7https://www.eff.org/https-everywhere
20118 [26] including security breaches at Comodo and Dig-
iNotar (which has since been removed as a trusted CA from all
browsers) and improperly issued subordinate root certiﬁcates
from TrustWave and T¨urkTrust. Collectively, these issues have
demonstrated that simply requiring HTTPS via HSTS is not
sufﬁcient given the risk of rogue certiﬁcates.
1) Pinning security model: Key pinning speciﬁes a limited
set of public keys which a domain can use in establishing
a TLS connection. Speciﬁcally, a key pinning policy will
specify a list of hashes (typically SHA-1 or SHA-256) each
covering the complete Subject Public Key Info ﬁeld of an
X.509 certiﬁcate. To satisfy a pinning policy, a TLS connection
must use a certiﬁcate chain where at least one key appearing
in the chain matches at least one entry in the pin set. This
enables site operators to pin their server’s end-entity public
key, the key of the server’s preferred root CA, or the key of any
intermediate CA. Pinning makes obtaining rogue certiﬁcates
much more difﬁcult, as the rogue certiﬁcate must also match
the pinning policy which should greatly reduce the number of
CAs which are able to issue a usable rogue certiﬁcate.
In fact, the browsers’ default policy can be viewed as “pin-
ning” all domains with the set of all trusted root certiﬁcate au-
thorities’ keys. Explicit pinning policies further reduce this set
for speciﬁc domains. Much like HSTS, pinning policies apply
at the domain level but an optional includeSubDomains
directive extends this protection to all subdomains.
The risk of misconﬁgured pinning policies is far greater
than accidentally setting HSTS. HSTS can be undone as long
as the site operator can present any acceptable certiﬁcate,
whereas if a site declares a pinning policy and then can’t obtain
a usable certiﬁcate chain satisfying the pins (for example, if
it loses the associated private key to a pinned end-entity key),
then the domain will effectively be “bricked” until the policy
expires. For this reason, pinning policies often require a site
to specify at least two pins to mitigate this risk.
2) Pinning preloads: Chrome has deployed preloaded
pinning policies since 2011, although only a handful of
non-Google domains currently participate. Firefox shipped
preloaded pinning in 2014 with policies for a subset of
Chrome’s pinned domains plus several Mozilla domains. Like
with preloaded HSTS, preloaded pinning policies have no
individual expiration date but the entire set expires if the
browser is not frequently updated. No other browsers have
publicly announced plans to implement preloaded pinning.
3) Pinning headers (HPKP): A draft RFC speciﬁes HTTP
Public Key Pinning (HPKP) by which sites may declare pin-
ning policies via the Public-Key-Pins HTTP header [7].
The syntax is very similar
to HSTS, with an optional
includeSubDomains directive and a mandatory max-age
directive. Pinning policies will only be accepted when declared
via a valid TLS connection which itself satisﬁes the declared
policy.
Unlike HSTS,
the HPKP standard adds an additional
Public-Key-Pins-Report-Only header. When this
policy is declared, instead of failing if pins aren’t satisﬁed,
8It should be noted that most of these issues were detected due to Chrome’s
deployment of key pinning. It is possible a large number of CA compromises
occurred before pinning was deployed but evaded detection.
the user agent will send a report to a designated address. This
is designed as a step towards adoption for domains unsure
if they will cause clients to lose access. Additionally, the
standard recommends that user agents limit policies to 60 days
of duration from the time they are declared, even if a longer
max-age is speciﬁed, as a hedge against attackers attempting
to brick a domain by declaring a pinning policy which the
genuine owner can’t satisfy.
Currently, no browsers support HPKP and the standard
remains a draft. Chrome and Firefox have both announced
plans to support the standard when it is ﬁnalized.
III. MEASUREMENT SETUP
To study how HSTS and pinning are deployed in practice,
we made use of an automated web measurement platform. Our
goal was to measure web sites by simulating real browsing
as accurately as possible while also collecting as much data
as possible. To this end we used a version of the Firefox
browser modiﬁed only for automation and data capture. Our
approach combined static analysis of downloaded page content
with dynamic analysis of all connections actually made by the
browser on behalf of rendered page content.
OpenWPM: We utilized OpenWPM as the backbone for
our testing. OpenWPM is an open-source web-crawling and
measurement utility designed to provide a high level of repro-
ducibility [8]. OpenWPM is itself built on top of the well-
known Selenium Automated Browser [27] which abstracts
away details such as error handling and recovery.
Static Resources: Selenium provides an interface for in-
specting the parsed DOM after pages have completed loading.
We utilized this interface to extract all tags of interest to check
for potential mixed content errors that were not triggered by
our browsing.
Dynamic Resources: By itself, neither Selenium nor Open-
WPM contain an API to instrument the browser as it executes
scripts and loads resources on behalf of the page. We utilized
the Firefox add-on system to build a custom Firefox extension
to instrument and record all resource calls as the page was
loaded to capture dynamic resource loading. Our extension
implements the nsIContentPolicy interface in the Firefox
extension API, which is called prior to any resource being
loaded. This interface is designed to allow extensions to
enforce arbitrary content-loading restrictions. In our case, we
allowed all resource loads but recorded the target URL, the
page origin URL, as well as the context in which that request
was made, for example if it was the result of an image being
loaded or an XMLHttpRequest (Ajax).
Sites tested: We conducted three main crawls in our study.
The ﬁrst was a depth-one9 sputtering of every domain listed
in Chrome and Firefox’s preloaded HSTS/pinning lists. We
tried fetching both the exact domain and the standard www
subdomain. Some domains were not accessible, as we discuss
in Section IV. We did not attempt to ﬁnd alternate pages for
domains without an accessible home page. Manual inspection
suggested that all domains which failed to resolve were either
9By “depth-one”, we mean we crawled the original page and followed every
link on that page.
4
content-delivery networks without a home page by design or
domains which have ceased operation.
The second crawl was an expanded crawl of the sites with
a preloaded pinning policy. For Twitter, Dropbox, Facebook,
and Google domains, we performed this crawl while “logged
in,” that is, using valid session cookies for a real account. The
other pinned domains did not implement a login system.
Finally, we performed a HTTP and HTTPS header-only
crawl of the exact domain and www subdomain of all sites in
the Alexa top million [9] list to test for the presence of HSTS
or HPKP. We performed this crawl using ZMap [28], a tool
designed for efﬁcient probing of a large number of hosts. For
the domains attempting to set HSTS or HPKP headers, we also
ran our full OpenWPM crawl to extract cookies and test for
various additional issues.
IV. CURRENT DEPLOYMENT
In this section we provide an overview of current deploy-
ment of HSTS and pinning using crawling and inspection of
the preload lists used by Chrome and Firefox. Our statistics
are all based on observations from November 2014.
A. Preload implementations
Chrome’s preload list is canonically stored10 in a single
JSON ﬁle11 containing both pinning and HSTS policies.There
is also a supporting ﬁle specifying named keys referenced in
pinning policies. Some are speciﬁed as complete certiﬁcates
(although only the keys are germane for pinning) and other
are speciﬁed as SHA-1 hashes of keys.
Until 2014,
the criteria for inclusion in Chrome’s list
were not formally documented and inclusion required email
communication with an individual engineer responsible for
maintaining the list [29], [30]. In mid-2014, Google rolled
out an automated web form12 for requesting inclusion into
Chrome’s preload list. In addition to submitting this form,
domains must redirect from HTTP to HTTPS and set an HSTS
header with includeSubDomains, a max-age value of at
least 10,886,400 (one year), and a special preload directive.
As seen in Figure 1,
this automated process has led to
a signiﬁcant increase in the numbers of preloaded entries.
However, the new requirements have not been retroactively
enforced on old entities and new sites can be added at
the discretion of Google without meeting these requirements
(e.g. Facebook and Yahoo! were recently added but do not
set includeSubDomains). Additionally, while requests for
inclusion can now be submitted automatically, they are still
manually reviewed and take months to land in a shipping
version of the browser and there still is not an automated
method of submitting preloaded pinsets.
During our crawl, we observed 456 entries on the preload
list which present the preload token, accounting for 1.0%
of the list. Since this token was only recently introduced, this
number is a clear indication of both the effect of Google’s
10This ﬁle is not shipped with the browser but is parsed at build-time into
a machine-generated C++ ﬁle storing the policies
11Technically,
the ﬁle is not valid JSON because it
includes C-style
comments.
12https://hstspreload.appspot.com
Fig. 1. Growth of preloaded HSTS in Google Chrome.
automated entry and the growth of the HSTS list. We also
observed 127 additional sites setting the preload token in
our top million crawl that are not yet in the preloaded list.
Several of these sites (32.3%) are presenting invalid headers
so were most likely rejected by Google for inclusion in the
list; however, the remaining sites do set valid HSTS header
and must be awaiting manual conﬁrmation.
Mozilla’s implementation uses two separate ﬁles for
preloaded HSTS and pinning policies. The preloaded HSTS
ﬁle is compiled as C code. Currently, the list is a strict subset
of Chrome’s list based on those domains in Chrome’s list
which also set an HSTS header with a max-age of at least
18 weeks [31]. The includeSubDomains parameter must