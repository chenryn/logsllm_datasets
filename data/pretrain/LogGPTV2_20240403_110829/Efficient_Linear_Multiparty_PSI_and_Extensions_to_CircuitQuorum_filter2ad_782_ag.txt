figurable parameter for correctness of the construction. Hence, by
the property of 𝜓, 𝑃1 gets the required comparison bit comp. We
formally describe the protocol in Figure 8.
𝜏
𝜓(𝑥) =
Parameters: There are 𝑛 parties 𝑃1, · · · , 𝑃𝑛 with (𝑛, 𝑡)−
shares [𝑎], of 𝑎 ∈ F𝑝 and 𝑎  𝑛 > 𝑘, 𝑛 > 2𝑡, 𝜏 is a configurable
parameter for correctness of construction and 𝐽 = ⌈
log |F𝑝 |⌉.
Additions and multiplications are over the field F𝑝.
Define the polynomial 𝜓 (publicly known to all parties):
if 𝑘 ≥ 𝑛
2
if 𝑘 < 𝑛
2
(𝑥 − 𝑘) · (𝑥 − (𝑘 + 1)) · · · (𝑥 − 𝑛) ,
𝑥 · (𝑥 − 1) · (𝑥 − 2) · · · (𝑥 − (𝑘 − 1)) ,
Input: For each 𝑖 ∈ [𝑛], 𝑃𝑖 inputs its (𝑛, 𝑡)− share [𝑎]𝑖.
Protocol:
(1) Pre-processing: 𝑃1, · · · , 𝑃𝑛 run:
[𝑠1], · · · , [𝑠𝐽 ] ← RandomF𝑛,𝑡 (𝐽).
(2) Evaluating the polynomial: 𝑃1, · · · , 𝑃𝑛 do:
• On input [𝑎], invoke MultF𝑛,𝑡 to compute all the re-
quired [𝑎𝑖], followed by scalar multiplications and ad-
ditions to compute [𝜓(𝑎)].
- [𝑣 𝑗] ← MultF𝑛,𝑡 ([𝜓(𝑎)], [𝑠 𝑗]).
- 𝑣 𝑗 ← Reveal𝑛,𝑡 ([𝑣 𝑗]).
• For each 𝑗 ∈ [𝐽], do:
Output: If 𝑘 ≥ 𝑛/2, if 𝑣 𝑗 = 0,∀𝑗 ∈ [𝐽], 𝑃1 sets comp = 1,
else sets comp = 0. If 𝑘 < 𝑛/2, if 𝑣 𝑗 = 0,∀𝑗 ∈ [𝐽], 𝑃1 sets
comp = 0 else sets comp = 1. Other parties get no output.
Figure 8: WEAK COMPARISON PROTOCOL I
Theorem 5.2. The protocol in Figure 8 securely realizes F 𝑝,𝑘,𝑛,𝑡
w-CMP in
the F -hybrid model, where F = (RandomF𝑛,𝑡 , MultF𝑛,𝑡 , Reveal𝑛,𝑡 ),
against a semi-honest adversary corrupting 𝑡 < 𝑛/2 parties. The total
amortized communication cost of the protocol is at most 14𝑘′(𝑛 −
1)(⌈log 𝑛⌉+1)+17𝜏(𝑛−1) and the round complexity is 6+2𝑘′, where
𝑘′ = min{𝑘 − 1, 𝑛 − 𝑘}.
We give a complete proof of Theorem 5.2 in Appendix E.1 and
discuss the complexities in Appendix F.2.1.
5.2.2 Weak Comparison Protocol w-CMP2. This protocol is a slight
modification of the comparison protocol from [12]. The main idea
of their comparison protocol is as follows: For 0 ≤ 𝑎, 𝑘 < 𝑛,
(cid:107)
𝑎 ≥ 𝑘 iff(cid:106) (𝑎−𝑘)
of(cid:106) (𝑎−𝑘)
2𝛾
2𝛾
= 0 (where 𝛾 = ⌈log 𝑛⌉ + 1). Hence, the pro-
tocol takes the (𝑛, 𝑡)− shares of 𝑎 and evaluates the (𝑛, 𝑡)− shares
(cid:107). This protocol invokes the multiparty functionalities
MultF𝑛,𝑡, RandomF𝑛,𝑡 and Reveal𝑛,𝑡 . Corresponding to the instan-
tiations of these functionalities used in [12], their protocol has an
𝑛2 factor in the communication complexity. Instead, we use the
instantiations from [21] for these functionalities, which reduces
the communication complexity of their protocol. For complete-
ness, we give the full protocol, which is modified (and simplified)
appropriately to instantiate F 𝑝,𝑘,𝑛,𝑡
w-CMP
, in Appendix E.2.
6 IMPLEMENTATION AND EVALUATION
In this section, we discuss the performance of our mPSI (multiparty
PSI) protocols8. Let Protocol A, Protocol B and Protocol C denote
our mPSI protocols when instantiated with polynomial-based batch
OPPRF [65], table-based OPPRF [51] and relaxed batch OPPRF [13]
respectively. We compare the performance of our mPSI protocols
with the state-of-the-art mPSI protocol in literature [51].
Protocol Parameters. We set statistical security parameter 𝜅=40
and computational security parameter 𝜆=128. Correctness of The-
orem 3.1 requires Cuckoo hashing failure in Step 2 (Figure 4) to
be at most 2−41. Similar to [13, 51, 65, 67], we use the empirical
analysis to instantiate the parameters of Cuckoo hashing scheme
in the stash-less setting as 𝛽 = 1.28𝑚 for 𝐾 = 3 (see Section 2.2).
Based on Theorem 3.1, we set size of elements 𝜎 = 𝜅 + ⌈log 𝑚⌉ +3 to
achieve statistical security of 𝜅 bits. Hence, the minimum element
size 𝜎 required in mPSI protocol to ensure that the failure probabil-
ity is at most 2−40 is 55, 59 and 63 for input set sizes 212, 216 and
220 respectively. In the implementation of Step 4 (see Figure 4) of
mPSI protocol for input set size 212 and 216, we perform arithmetic
over prime field where the prime is the Mersenne prime 261 − 1.
For input set size 220, we choose the prime field with Mersenne
prime 2127 − 1 for the LAN setting; for WAN setting we choose the
Galois Field over an irreducible polynomial where each element is
represented in 64 bits. This is due to compute vs communication
trade-offs between the two fields.
Based on correctness analysis, we set 𝜎 = 𝜅+⌈log 𝑚⌉+⌈log 𝑛⌉+2
for our Circuit PSI and qPSI protocols, i.e., larger of the element
size required by these two protocols.
Implementation Details. We make use of the implementation
of polynomial-based batch OPPRF [65] and table-based OPPRF
[51] available at [25] and [60] respectively. For implementation
of relaxed batch OPPRF [13] and equality test functionality F ℓ
EQ
[13, 23, 32, 68], we use the code available at [58]. For Boolean to
Arithmetic share conversion functionality F F
[68], we use the
B2A
implementation of correlated OTs available at [57]. Finally, we use
the code available at [20] for multiparty functionalities [21, 52] (see
Section 2.5).
Experimental Setup. Similar to [51], we ran our experiments on a
single machine with 64-core Intel Xeon 2.6GHz CPU and 256GB
RAM, and simulated the network environment using the Linux
𝑡𝑐 command. We configure a LAN connection with bandwidth 10
8Code available at https://aka.ms/PQC-mPSI
Session 4C: Private Set Intersection CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea1192𝑛, 𝑡
𝑚
KMPRT
Protocol A
4, 1
216
114.1
49.4
212
7.2
3.2
220
2057.7
790.2
212
13.4
4.6
5, 2
216
211.2
72.7
220
3805.4
1162.8
212
44.7
12.3
10, 4
216
706.2
192.4
220
12730.4
3077.2
212
103.4
22.5
15, 7
216
1635.4
353.4
220
29487.9
5652.9
Table 2: Total communication in MB of mPSI protocols: KMPRT [51] and Protocol A.
𝑛, 𝑡
𝑚
KMPRT
Protocol A
4, 1
216
51.9
19.9
212
3.3
1.3
220
935.2
318.0
212
4.9
1.5
5, 2
216
77.8
23.3
220
1402.0
372.6
212
8.3
2.0
10, 4
216
131.7
30.8
220
2373.5
492.1
212
13.1
2.4
15, 7
216
207.5
38.8
220
3741.0
620.1
Table 3: Client communication in MB of mPSI protocols: KMPRT [51] and Protocol A.
𝑛, 𝑡
𝑚
KMPRT
Ours
𝑛, 𝑡
𝑚