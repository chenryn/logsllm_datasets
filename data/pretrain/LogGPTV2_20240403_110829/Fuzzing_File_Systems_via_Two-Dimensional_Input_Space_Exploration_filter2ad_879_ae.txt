3.0k
1.5k
0.0k
3.0k
2.5k
2.0k
1.5k
1.0k
0.5k
0.0k
2.1k
1.8k
1.5k
1.2k
0.9k
0.6k
0.3k
0.0k
JANUSi
JANUSs
JANUS
(d) XFS (v5)
(f) F2FS
(h) HFS+
(f) VFAT
0
2
4
6
Time (h)
8
10
12
Fig. 8: The overall path coverage of using Syzkaller and JANUS to fuzz eight ﬁle system images for 12 hours. The y-axis represents the
number of unique code paths of each ﬁle system visited during the fuzzing process. In particular, JANUSi and Syzkalleri only mutate bytes
on a seed image and perform a ﬁxed sequence of system calls on a mutated image and JANUSi outperforms Syzkalleri up to 4.17×. JANUSs
and Syzkallers generate random system calls to be executed on a ﬁxed seed image, in which JANUSs achieves up to 2.24× higher coverage
than Syzkallers. JANUS and Syzkaller fuzz both image bytes and ﬁle operations, and JANUS visits at most 4.19× unique paths.
fact, syz_mount_image() can be invoked anywhere and several
times in a program generated by Syzkaller. Unlike Syzkaller,
JANUS fuzzes each image separately with a clean LKL instance.
If mounting a mutated image succeeds, the executor will
execute context-aware workloads afterward and terminate with
umount(). As we mentioned in §V-B, the comparison for XFS
is partially unfair due to the limitation of Syzkaller in handling
dense images. Another advantage of JANUS is that it utilizes
many fewer CPU and memory resources for LKL instances
but still outperforms Syzkaller, which relies on VMs.
Result.
JANUS achieves higher code coverage than both
JANUSs and JANUSi, which proves the importance of mutating
both images and operations in ﬁle system fuzzing. Moreover,
JANUS outperforms Syzkaller on all eight ﬁle systems. In
particular, JANUS outperforms Syzkaller at most 4.19× on
Btrfs, one of the popular ﬁle systems that has an extremely
complex design. Our evaluation result shows the effectiveness
of JANUS in fuzzing a ﬁle system by exploring its two-
dimensional input space.
E. Reproducing Crashes
To evaluate whether the library OS used by JANUS (i.e.,
LKL) helps to reproduce more found crashes compared to
VMs, for each collected crashing input generated in the ﬁnal
experiment where both of two types of inputs are mutated (see
§V-D), we ﬁrst use our PoC generator to parse out the image
(cid:25)(cid:19)(cid:25)
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:52:33 UTC from IEEE Xplore.  Restrictions apply. 
File System
ext4 (com.)
ext4
XFS v4
XFS v5
Btrfs
F2FS
GFS2
HFS+
ReiserFS
VFAT
Syzkaller
0/7 (0%)
0/3 (0%)
0/2517 (0%)
0/6 (0%)
0/0 (0%)
0/1288 (0%)
0/916 (0%)
0/8 (0%)
0/2535 (0%)
0/0 (-)
JANUS
16/16 (100%)
196/196 (100%)
24/24 (100%)
67/67 (100%)
1793/2054 (88%)
2390/2458 (97%)
1030/1080 (95%)
815/815 (100%)
1800/1800 (100%)
0/0 (-)
#Unique
6
8
2
2
18
28
12
6
20
0
TABLE IV: The bug reproducibility of Syzkaller and JANUS using
KVM instances and LKL-based executors, respectively. For each X/Y
pair in the table, X indicates the number of crashes triggered by a
fuzzer during our experiment in §V-D, and Y represents the number of
crashes that can be reproduced again with saved crashing inputs. The
column #Unique reports the unique crashes among the ones found
by JANUS in the experiment based on their crashing PC values.
Reboot VM Revert snapshot
1.4s
14.5s
LKL
10.7ms
TABLE V: The average time costs of VM-based (i.e., KVM) fuzzer
and JANUS for a non-aging OS and ﬁle system. The total time includes
reloading a clean-slate OS and mounting an image.
and a particular sequence of system calls. We then mount
the image and execute system calls under the mounting point
again to see if the kernel crashes. Based on the crashing PC
values, we also count the number of unique crashes among
those reproducible ones. Table IV summarizes the number of
crashes and reproducible ones found by JANUS and Syzkaller.
Note that Syzkaller originally records these numbers in its logs.
Because of the fundamental limitation of using an aging OS, in
which Syzkaller mounts different images and invokes system
calls without initialization, Syzkaller fails to reproduce any of
its found crashes. On the contrary, JANUS can reproduce more
than 95% of crashes found in most ﬁle systems, except Btrfs.
Btrfs launches multiple kernel threads completing different
transactions in parallel, which results in non-deterministic
kernel execution. In addition, F2FS and GFS2 also spawns few
worker threads to accomplish particular tasks, such as garbage
collection, logging, etc. Note that, in theory, it is possible
to reproduce 100% of crashes if we can control the thread
scheduling, which is currently outside the scope of this work.
We also estimate the performance overhead of bringing up a
fresh copy of OS (non-aging OS) for a VM-based fuzzer to test
every generated input. More speciﬁcally, we evaluate the total
time that a KVM instance (two cores and 2GB memory) spends
on either rebooting VM or reverting an existing snapshot and
testing an input image, and compare it to the corresponding
time that our LKL executor requires. Table V presents the
evaluation result. By simply invoking fork() to launch a new
LKL instance, our LKL-based executor spends negligible time
on setting up a clean OS and a fresh ﬁle system compared
with a KVM instance.
Result. LKL, on which JANUS relies, provides a clean-slate
OS that has more stable execution than an OS running in a
VM. This approach results in reproducing most of the crashes.
In particular, JANUS is able to reproduce at least 88% of the
crashes found during a 12-hour fuzzing period. By contrast, a
VM-based fuzzer (i.e., Syzkaller) fails to reproduce any of its
crashes. Moreover, re-initializing OS states in a VM suffers
from unacceptable overhead.
F. Miscellany
Besides ﬁnding previously unknown bugs, JANUS contributes
the following notable results to the ﬁle system development
community.
Malicious image samples. The development communities of
several ﬁle systems including Btrfs, F2FS, etc., have already
added a number of corrupted images generated by JANUS
into their repositories for internal fuzzing and for future
regression testing. Currently, developers consider these images
as representative malicious samples that involve diverse error
bytes in various metadata ﬁelds for testing the functionality of
ﬁle systems.
General patches for ﬁle system hardening. F2FS developers
have not only ﬁxed the bugs reported by us in the kernel
module but also extended corresponding security checks into
the user-space tool (i.e., fsck.f2fs) to help users detect these
image corruptions in advance, i.e., before the Linux kernel
mounts images containing critical error bytes.
VI. DISCUSSION
We have demonstrated that JANUS effectively explores the
code paths and discovers unknown bugs in a disk ﬁle system
in the Linux kernel. We now discuss the limitations of JANUS
and our future directions.
Library OS based executor. JANUS relies on LKL to test in-
kernel ﬁle systems. In fact, other OS fuzzers can use it to test
other kernel sub-systems, except MMU-dependent components.
For instance, JANUS cannot fuzz the DAX mode of a ﬁle
system [31] without modiﬁcation on LKL. We could also use
user-mode Linux (UML), as done by Oracle’s kernel fuzzer [48].
However, UML suffers from the limitation of its multi-process
design, which complicates the spotting of a kernel crash and
termination of all its processes during each iteration. Therefore,
UML does not support fuzzing the kernel as a user application
well.
Minimal PoC generator. An ideal PoC for developers to
debug crashes consists of an image that only has essential error
bytes and a program with the least ﬁle operations. To achieve
this, JANUS currently uses a brute force approach to revert
every mutated byte and also tries to remove every invoked
ﬁle operation to check whether the kernel still crashes at the
expected location. Although this approach is sub-optimal, we
can leverage certain ﬁle system utilities such as fsck and
debugfs and system call trace distillation techniques [22, 49]
to pinpoint root-causing bytes and system calls. Another
possibility is to apply taint tracking on the kernel.
Fuzzing FUSE drivers. Currently, JANUS does not support
ﬁle systems (e.g., NTFS [70], GVfs [67], SSHFS [55], etc.)
(cid:25)(cid:19)(cid:26)
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:52:33 UTC from IEEE Xplore.  Restrictions apply. 
that rely on FUSE (Filesystem in Userspace) [32]. We can
easily extend the fuzzing engine of JANUS to fuzz such ﬁle
systems as long as they store user data in a disk image and
support certain ﬁle operations for users to interact with data.
Fuzzing ﬁle system utilities. Developers heavily rely on
system utilities (e.g., mkfs, fsck, etc.), to manage ﬁle systems.
For instance, Linux automatically launches fsck for recovering
disk data from a sudden system crash. Moreover, users use
fsck to check the consistency of an untrusted disk image before
mounting the disk. Hence, developers desire such utilities to
be bug free. We believe that developers can easily extend the
image mutator of JANUS to generate corrupted images for
fuzzing these tools, thereby improving their robustness. In fact,
we use JANUS to ﬁnd two unknown bugs in fsck.ext4, and
one has already been ﬁxed.
Extending to fuzz ﬁle systems on other OSes. Extending
JANUS for fuzzing in-kernel ﬁle systems on other OSes will be
straightforward if the corresponding library OS solution exists.
For instance, Drawbridge [52] enables Windows to efﬁciently
run in a process. Moreover, we can also integrate the core
fuzzing engine of JANUS with other general kernel fuzzing
frameworks such as kAFL [61] built upon QEMU and KVM
to fuzz ﬁle systems used by other commodity OSes such as
Windows and macOS.
Improving other ﬁle system testing tools. The goal of JANUS
is to ﬁnd general security bugs in ﬁle systems, contrary to the
goals of other tools, including crash-consistency checkers [6,
73] and semantic correctness checkers [36, 58]. However, these
tools also need sequences of ﬁle operations. Hence, JANUS
becomes a one-stop solution on which other tools can rely.
VII. RELATED WORK
Structured input fuzzing. Numerous approaches have been
proposed to fuzz inputs that are highly structured like ﬁle
system images. Unlike JANUS, a number of generation fuzzers
( [14, 23, 41, 42, 50]) construct syntactically correct inputs
from scratch based on input speciﬁcations described through
manual efforts. Furthermore, EXE [7] relies on symbolic
execution to build valid inputs that satisfy deep path constraints.
More advanced approaches such as [3, 16, 24] learn the
input structures from a set of samples. On the other side,
mutation-based fuzzers [4, 5, 10, 15, 18, 34, 76] generate new
inputs by mutating valid samples. The generated inputs have
correct structures with slight errors, and hopefully trigger bugs.
Considering the complexity of a ﬁle system image and the
diversity in image format among different ﬁle systems, JANUS
adopts mutation-based strategies to fuzz images. Similar to
ﬁle system images, many ﬁle formats involve checksums for
integrity checks. JANUS speciﬁcally ﬁxes metadata checksums
with expertise knowledge. Nevertheless, some checksum-aware
fuzzers [33, 71] identify checksum ﬁelds and bypass checksum
checks at runtime through dynamic taint analysis.
OS kernel fuzzers. To ﬁnd security bugs in OSes, a number
of general kernel fuzzing frameworks
[20, 43, 46, 61] and
[22, 25, 44, 45, 47] have been
OS-speciﬁc kernel fuzzers
proposed. Unlike JANUS, all these fuzzers generate random
system calls based upon predeﬁned grammar rules, which is
ineffective in the context of ﬁle system fuzzing. Several recent
OS fuzzers such as IMF [22] and MoonShine [49] focusing
on seed distillation are orthogonal to this work. Nevertheless,
JANUS can start with seed programs of high quality by utilizing
their approaches.
File system semantic correctness checkers.
JUXTA [36]
and SibylFS [58] are other types of ﬁle system checkers, that
aim to ﬁnd whether the implementation of a ﬁle system exactly
meets the standard (e.g., the POSIX standard, man pages,
etc.) through static analysis and high-level modeling of ﬁle
system behaviors. They are orthogonal to JANUS regarding their
purposes and methodologies. Similarly, JANUS can generate
meaningful system calls to ﬁnd crash consistency bugs [6, 73].
File system abstraction. Several studies [65, 66] propose
general
interfaces for ﬁle system utilities to access and
manipulate the on-disk metadata of various ﬁle systems through
high-level abstraction. By utilizing these interfaces, JANUS
can compress disk images in a more general manner without
implementing an image parser for every target ﬁle system.
VIII. CONCLUSION
In this work, we propose JANUS, an evolutionary ﬁle system
fuzzer, that explores an in-kernel ﬁle system by exploring its
two-dimensional input space (i.e., images and ﬁle operations).
Unlike existing ﬁle system fuzzers, JANUS efﬁciently mutates
metadata blocks of input images while emitting context-aware
workloads on an image. Rather than traditional VMs, JANUS
relies on a library OS that supports fast reloading to test
OS functionalities, thereby avoiding unstable executions and
irreproducible bugs. We reported 90 bugs found by JANUS
in the upstream kernel, 43 of which have been ﬁxed with 32
CVEs assigned. JANUS outperforms Syzkaller by exploring at
most 4.19× more code paths when fuzzing popular ﬁle systems
for 12 hours and manages to reproduce 88–100% of found
crashes. We will open source our implementation of JANUS,
which has been requested by several ﬁle system development
communities due to our notable results. We believe that JANUS
will be one-stop solution for ﬁle system testing, as JANUS
can act as a basic infrastructure to design new semantic and
crash-consistency checkers for ﬁle systems.
IX. ACKNOWLEDGMENT
We thank the anonymous reviewers, and our shepherd,
Thorsten Holz, for their helpful feedback. We also thank all
the ﬁle system developers, including Theodore Ts’o, Darrick
J. Wong, Dave Chinner, Eric Sandeen, Chao Yu, Wenruo
Qu and Ernesto A. Fernández for handling our bug reports.
This research was supported, in part, by the NSF award
CNS-1563848, CNS-1704701, CRI-1629851 and CNS-1749711
ONR under grant N000141512162, DARPA TC (No. DARPA
FA8650-15-C-7556), and ETRI IITP/KEIT[B0101-17-0644],
and gifts from Facebook, Mozilla and Intel.
(cid:25)(cid:20)(cid:17)
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:52:33 UTC from IEEE Xplore.  Restrictions apply. 
REFERENCES
[1] N. Agrawal, W. J. Bolosky, J. R. Douceur, and J. R. Lorch. A Five-year
Study of File-system Metadata. In Proceedings of the ACM Transactions
on Storage (TOS), 2007.
[2] Apple Inc. macOS High Sierra. https://www.apple.com/macos/high-sierra,
2018.
[3] O. Bastani, R. Sharma, A. Aiken, and P. Liang. Synthesizing program
input grammars. In ACM SIGPLAN Notices, pages 95–110. ACM, 2017.
[4] M. Böhme, V.-T. Pham, and A. Roychoudhury. Coverage-based greybox
fuzzing as markov chain. In Proceedings of the 23rd ACM Conference
on Computer and Communications Security (CCS), Vienna, Austria, Oct.
2016.
[5] M. Böhme, V.-T. Pham, M.-D. Nguyen, and A. Roychoudhury. Directed
greybox fuzzing.
In Proceedings of the 24th ACM Conference on
Computer and Communications Security (CCS), Dallas, TX, Oct.–Nov.
2017.
[6] J. Bornholt, A. Kaufmann, J. Li, A. Krishnamurthy, E. Torlak, and
X. Wang. Specifying and checking ﬁle system crash-consistency models.
In Proceedings of the 21st ACM International Conference on Architectural
Support for Programming Languages and Operating Systems (ASPLOS),
Atlanta, GA, Apr. 2016.
[7] C. Cadar, V. Ganesh, P. M. Pawlowski, D. L. Dill, and D. R. Engler.
EXE: automatically generating inputs of death. ACM Transactions on
Information and System Security (TISSEC), 12(2):10, 2008.
[8] M. Cao, S. Bhattacharya, and T. Ts’o. Ext4: The next generation of
ext2/3 ﬁlesystem. In USENIX Linux Storage and Filesystem Workshop,
2007.
[9] H. Chen, D. Ziegler, A. Chlipala, M. F. Kaashoek, E. Kohler, and
N. Zeldovich. Specifying Crash Safety for Storage Systems. In 15th
USENIX Workshop on Hot Topics in Operating Systems (HotOS) (HotOS
XV), Kartause Ittingen, Switzerland, May 2015.
[10] P. Chen and H. Chen. Angora: Efﬁcient Fuzzing by Principled Search.
In Proceedings of the 39th IEEE Symposium on Security and Privacy
(Oakland), San Francisco, CA, May 2018.
[11] J. Corbet. Improving ext4: bigalloc, inline data, and metadata checksums.
https://lwn.net/Articles/469805, 2011.
[12] J. Corbet. Filesystem mounts in user namespaces. https://lwn.net/Articles/
652468, 2015.
[13] J. Dike. User-mode Linux. In Annual Linux Showcase Conference, 2001.
[14] I. Fratric. DOM fuzzer. https://github.com/googleprojectzero/domato,
2018.
[15] S. Gan, C. Zhang, X. Qin, X. Tu, K. Li, Z. Pei, and Z. Chen. CollAFL:
Path Sensitive Fuzzing. In Proceedings of the 39th IEEE Symposium on
Security and Privacy (Oakland), San Francisco, CA, May 2018.
[16] P. Godefroid, H. Peleg, and R. Singh. Learn&fuzz: Machine learning
for input fuzzing. In Proceedings of the 32nd IEEE/ACM International
Conference on Automated Software Engineering (ASE), Champaign, IL,
Oct. 2017.
[17] Google. KernelAddressSanitizer, a fast memory error detector for the
Linux kernel. https://github.com/google/kasan, 2016.
[18] Google. OSS-Fuzz - Continuous Fuzzing for Open Source Software.
https://github.com/google/oss-fuzz, 2018.
[19] Google. syzbot. https://syzkaller.appspot.com, 2018.
[20] Google. syzkaller is an unsupervised, coverage-guided kernel fuzzer.
https://github.com/google/syzkaller, 2018.
[21] S. Grubb. fsfuzzer-0.7. http://people.redhat.com/sgrubb/ﬁles/fsfuzzer-
0.7.tar.gz, 2009.