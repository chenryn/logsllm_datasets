（2）删除所有包含"乙："字符串的行，并另存为"甲.txt"。
因此就可以使用g命令，例如这样操作：
![alt](images/00436.jpeg){.calibre3}
当然，为了保险，我们还可以更严格地限定只过滤每一行开头为"甲："字符串的行：
![alt](images/00437.jpeg){.calibre3}
后面的"d"的意思就是删除行。也就是对所有由g命令根据字符串"甲："过滤出来的行，执行删除操作。这之后，再运行命令：
![alt](images/00438.jpeg){.calibre3}
就将文件另存为了"乙.txt"文件。另一个"甲.txt"也如法炮制即可。
当然，我们也可以用v命令，过滤出所有不带"甲："的行，就是这样：
![alt](images/00439.jpeg){.calibre3}
这个命令的意思就是过滤出所有不带"甲："的行，然后将过滤内容直接存为"乙.txt"文件。
虽然MM的要求总是很复杂，不过懒蜗牛倒是都一一满足了。但这不过是Vim编辑器的牛刀小试，他的文本编辑功能，基本上已经强大到只有你想不到，没有他做不到的程度了。
[7.5 本章小结]{.kai}
这些日子，咱们这位懒蜗牛同学可是没少忙活。又是C，又是C++，又是PHP，又是Java的，配置了不少语言的开发环境。并且为了更好地编程，懒蜗牛还学习了Vim的使用。可是也没见他写出什么有用的东西来。当然，也许生活，就是一个HelloWorld，接着另一个HelloWorld吧。
等HelloWorld写腻了，也许他就该用Vim去写点有意思的程序了。
[]{#part0012.html}
第8章 程序是怎样炼成的
懒蜗牛同学搭建好了各种语言的开发环境，并且开发出了不少的HelloWorld。但他显然并不想就此罢休。凡事都喜欢刨根问底的懒蜗牛同学，还要搞明白一个软件从源代码到打包为成品的整个过程。
[8.1 施工队]{.kai}
软件的最初状态自然就是源代码，要把C语言的源代码变成二进制的程序，离不开GCC。那么GCC到底对源代码做了什么，才能把一段段冰冷的代码变成一只只鲜活的程序呢？（为啥要用"只"......）
8.1.1 懒蜗牛的日记A
"2010年9月3日 降雨
学了这么几天，觉得还是C语言最有意思、最灵活高效。听说好多Linux系统的软件都是拿C语言写的，连Linux内核也是以C语言为主创造的。我能不能也写出一个自己的小软件来呢？不要求功能有多么复杂，但要符合Linux的精神------只做一件事，但要做到最好。
仅仅编译一个HelloWorld很简单，只有一个.c文件，只用一条命令。我应该设计些复杂的程序，实现点有意思的功能才会有进步。编个什么程序好呢？"
8.1.2 编译多个源文件的程序
懒蜗牛同学之前写过一个HelloWorld程序，但是觉得那个程序实在太简单，没什么意思。于是这回他决定写个稍微复杂点的程序。
【无聊的rubbish 1号】
只见他冥思苦想之后，写下一个源码文件，叫做rubbish.c，看来这懒蜗牛同学还真谦虚。在rubbish.c文件中写了些代码后，懒蜗牛就叫来GCC进行编译，运行了这么个命令：
![alt](images/00440.jpeg){.calibre3}
命令后面那个"-o
rubbish"的意思，就是指定编译后的二进制文件的文件名叫做rubbish。这样就不会每回都输出为a.out文件了。编译出来后，还冒着热气的rubbish就被懒蜗牛叫进内存运行起来。只见rubbish飞身跳进内存，跑进内存后抢过标准输出设备，对着那个设备大喊一声："I
am a
Rubbish!"然后，就跑回硬盘继续睡觉去了。我说懒蜗牛同学呀，不是说设计个复杂点的程序吗？您这个rubbish跟那个HelloWorld有啥区别呀？
![alt](images/00011.jpeg){.tpzz}**提示：**[标准输出设备，即/dev/stdout设备文件，一般该文件映射到当前字符终端。]{.kai1}
我们后来管这个弱智的程序叫做rubbish
1号，因为懒蜗牛同学很快又创造出了很多的rubbish。
【同样无聊的rubbish 2号】
不一会儿，懒蜗牛又拿来rubbish
1号的图纸改起来。10分钟后，图纸完成，交给GCC编译，懒蜗牛很自觉地把这个程序命名为rubbish2。
![alt](images/00441.jpeg){.calibre3}
很快，rubbish 2号诞生！毫无悬念地，懒蜗牛马上让我叫醒rubbish
2号起来干活。于是我走进硬盘，叫醒rubbish 2号。只见rubbish
2号立刻飞身跳进内存，依旧是对着标准输出设备大喊一声："I am a
Ru～Ru～Ru～Rubbish～～～～!"喊完了就跑回去继续睡觉了。懒蜗牛同学成功地利用for循环创造了一个结巴。
【多个文件的rubbish 3号】
15分钟后，rubbish
3号的图纸再次毫无悬念地完成。这回的图纸不光是一个rubbish.c文件了，而是包含了3个文件：rubbish.c、input.c和input.h。这回懒蜗牛依旧是叫来了GCC，他运行这么个命令：
![alt](images/00442.jpeg){.calibre3}
这就是当代码包含多个.c文件时候的编译方式。有人问，那个.h文件呢？.h文件一般是要被包含进某个.c文件的，这个包含的动作一般在预处理的时候就给处理了，不需要在编译命令里写上.h文件。至于什么叫预处理，您别忙，咱们一会儿就会说到。
rubbish 3号这会儿已经起床，跑进内存向懒蜗牛发问："How many Ru do you
want？"然后就等待懒蜗牛输入。懒蜗牛同学输入了一个6，于是就听见rubbish
3号大喊："I am a Ru～Ru～Ru～Ru～Ru～Ru～Rubbish!"------程控结巴！
【系统调用的rubbish 4号】
rubbish
4号的图纸诞生啦。Vim告诉我说，这回懒蜗牛调用了创建线程的库函数（因为懒蜗牛是用Vim编程的嘛，所以Vim能知道写了些什么）。果然，在编译的时候懒蜗牛运行了：
![alt](images/00443.jpeg){.calibre3}
其中，-lpthread的意思就是要连接创建线程相关的库函数。图纸交给GCC后，很快rubbish
4号诞生，并且很快就起床跑进内存。只见他念动咒语"唵木哒咪咪呀......分！"然后白光一闪，rubbish
4号变成了2个！2个4号同时喊：
"I am a Ru～Ru～Ru～Ru～Rubbish!"
"I am a Ru～Ru～Ru～Ru～Rubbish!"
二重结巴！
8.1.3 编译过程详解
刚才咱们见到了编译一个（或一坨）C语言源文件时的操作，下面就仔细说说编译的过程。
在编译的时候，虽然用户用的只有一个"gcc"命令，然而我们说过，GCC是一个编译器套装。他不是一个人，不是只有一个"gcc"命令就能完成整个编译过程的！他们是一个团队，一个以"gcc"命令为首的源代码编译施工队。
施工队主要成员有gcc、cpp、as和ld这么4个命令。其中gcc命令是老大，其他几个干什么活都得听他的调遣，用户一般也只跟gcc命令打交道。当写好了图纸之后（也就是源代码，就比如刚才懒蜗牛写的rubbish.c），虽然用户直接把图纸交给gcc命令就不管了，但其实gcc命令需要去调动其他命令进行各种处理，才能完成编译工作。
（以下文中出现的小写"gcc"均代表gcc命令，而不是整个GCC开发套件。）
【施工第1步------预处理】
一般来说，gcc拿到图纸后，会首先叫来cpp进行预处理。
预处理主要就是将文件里的宏定义进行展开。什么是宏定义呢？人类用户一般都比较懒，或者说，人类能力有限，不愿意写很多重复的，相似的东西，就把这些都定义成宏。比如，这么写：
![alt](images/00444.jpeg){.calibre3}
这就是定义一个叫做TOTAL_NUMBER的宏，从名字看，这个宏代表了一个总数，数值是18353226。那么以后再要用到这个总数的时候，就直接写TOTAL_NUMBER就可以了，不用写那一大串数字。而且，如果总数变了，只要在最初#define的位置修改一次就可以，反正就是为了偷懒。
cpp的任务就是把这类的宏定义都替换回去。把所有的TOTAL_NUMBER都替换成18353226；把所有#include引用的文件内容都粘贴进来等。这么说可能不形象，那咱们找个实例吧，比如有一个hello.c文件，内容是这样的：
![alt](images/00445.jpeg){.calibre3}
那么经过了预处理之后的内容是什么样呢？如果您想体验一下，可以自己试着运行：