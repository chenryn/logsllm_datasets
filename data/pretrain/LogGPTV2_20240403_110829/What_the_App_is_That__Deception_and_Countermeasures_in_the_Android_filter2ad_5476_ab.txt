mount GUI confusion attacks. We have also identified Enhancing
Techniques: abilities (such as monitoring other apps) that do not
present a GUI security risk in themselves, but can assist in making
attacks more convincing or stealthier.
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:09:15 UTC from IEEE Xplore.  Restrictions apply. 
TABLE I: Attack vectors and enhancing techniques. We indicate
with a dash attacks and techniques that, to the best of our knowledge,
have not been already mentioned as useful in GUI confusion attacks.
Category
Attack vector
Mentioned in
Draw on top
UI-intercepting draw-over
Non-UI-intercepting draw-over
Toast message
[3], [5]
[3], [4], [5]
[3], [10]
App switch
Fullscreen
Enhancing
techniques
startActivity API
Screen pinning
moveTaskTo APIs
killBackgroundProcesses API
Back / power button (passive)
Sit and wait (passive)
non-“immersive” fullscreen
“immersive” fullscreen
“inescapable” fullscreen
getRunningTask API
Reading the system log
Accessing proc file system
App repackaging
[6]
—
—
—
—
—
—
—
—
[5]
[11]
[6], [12]
[13], [14], [15]
A. Attack vectors
1) Draw on top: Attacks in this category aim to draw graphical
elements over other apps. Typically, this is done by adding graphical
elements in a Window placed over the top Activity. The Activity
itself is not replaced, but malware can cover it either completely
or partially and change the interpretation the user will give to certain
elements.
Apps can explicitly open new Windows and draw content in
them using the addView API exposed by the WindowManager
Service. This API accepts several flags that determine how the new
Window is shown (for a complete description, refer to the original
documentation3). In particular, flags influence three different aspects
of a Window:
• Whether it is intercepting user input or is letting it “pass through”
• Its type, which determines the Window’s Z-order with respect
• The region of the screen where it is drawn.
to underlying Windows.
to others.
Non-system apps cannot open Windows of some types, while
Windows with a higher Z-order than the top-activity Window
require the SYSTEM ALERT WINDOW permission.
Windows used to display toasts, text messages shown for a
limited amount of time, are an interesting exception. Intended to
show small text messages even when unrelated apps control the
main visualization, toast messages are usually created with specific
APIs and placed by the system in Windows of type TOAST, drawn
over the top-activity Window. No specific permission is necessary
3http://developer.android.com/reference/android/view/WindowManager.Layou
tParams.html
933933934
to show toast messages. Their malicious usage has been presented
by previous research (refer to Table I).
Two other types of attack are possible:
• UI-intercepting draw-over: A Window spawned using, for
instance, the PRIORITY PHONE flag can not only overlay the
top-activity Window with arbitrary content, but also directly steal
information by intercepting user input.
• Non UI-intercepting draw-over: By forwarding all user input
to the underlying Windows, classical “click-jacking” attacks are
possible. In these attacks, users are lured to perform an unwanted
action while thinking they are interacting with a different element.
2) App switch: Attacks that belong to this category aim to
steal focus from the top app. This is achieved when the malicious
app seizes the top Activity: that is, the malicious app replaces the
legitimate top Activity with one of its own. The malicious app that
we developed for our user study (Section VII) uses an attack in this
category: it waits until the genuine Facebook app is the top app, and
then triggers an app switch and changes its appearance to mimic
the GUI of the original Facebook app.
Replacing the currently running app requires an active app
switch. Passive app switches are also possible: in this case, the
malicious application does not actively change the Activity stack,
nor it shows new Windows, but it waits for specific user’s input.
We have identified several attack vectors in this category:
startActivity API. New Activities are opened using the
startActivity API. Normally, the newly opened Activity does not
appear on top of Activities of other apps. However, under particular
conditions the spawned Activity will be drawn on top of all the
existing ones (even if belonging to different apps) without requiring
any permission. Three different aspects determine this behavior: the
type of the Android component from which the startActivity API
is called, the launchMode attribute of the opened Activity, and flags
set when startActivity is called.
Given the thousands of different combinations influencing this
behavior and the fact that the official documentation4 does not state
clearly when a newly Activity will be placed on top of other apps’
Activities, we decided to develop a tool to systematically explore
the conditions under which this happens.
Our tool determined that opening an Activity from a Service,
a Broadcast Receiver, or a Content Provider will always place it
on top of all the others, as long as the NEW TASK flag is specified
when the startActivity API is called. Alternatively, opening an
Activity from another one will place the opened Activity on top
of all the others if the singleInstance launch mode is specified. In
addition, our tool found other, less common, situations in which
an Activity is placed on top of all the others. For more details and
a description of our tool, refer to Section IV-A.
moveTaskTo APIs. Any app with the REORDER TASKS
permission can use the moveTaskToFront API to place Activities
on top of the stack. We also found another API, moveTaskToBack,
requiring the same permission, to remove another app from the top
of the Activity stack.
Screen pinning. Android 5.0 introduces a new feature called
“screen pinning” that locks the user interaction to a specific app.
Specifically, while the screen is “pinned,” there cannot be any switch
4http://developer.android.com/guide/components/tasks-and-back-stack.html
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:09:15 UTC from IEEE Xplore.  Restrictions apply. 
to a different application (the Home button, the Recent button, and
the status bar are hidden). Screen pinning can be either manually en-
abled by a user or programmatically requested by an app. In the latter
case, user confirmation is necessary, unless the app is registered as a
“device admin” (which, again, requires specific user confirmation).
killBackgroundProcesses API.
This API (requiring the
KILL BACKGROUND PROCESSES permission) allows killing
the processes spawned by another app. It can be used maliciously
to interfere with how benign apps work: besides mimicking their
interface, a malicious app could also prevent them from interacting
with the user. Android does not allow killing the app controlling
the top Activity, but other attack vectors can be used to first remove
it from the top of the stack.
Back/Power Button. A malicious app can also make the user
believe that an app switch has happened when, in fact, it has not.
For example, an app can intercept the actions associated with the
back button. When the user presses the back button, she expects
one of two things: either the current app terminates, or the previous
Activity on the stack is shown. A malicious app could change its
GUI to mimic its target (such as a login page) in response to the user
pressing the back button, while at the same time disabling the normal
functionality of the back button. This might make the user believe
that an app switch has occurred, when, in fact, she is still interacting
with the malicious app. A similar attack can be mounted when the
user turns off the screen while the malicious app is the top app.
Sit and Wait. When a malicious app is in the background, it
can change its GUI to that of a victim app, so that when the user
switches between apps looking, for example, for the legitimate
banking application, she could inadvertently switch to the malicious
version instead. This type of attack is known in the browser world
as tabnabbing [16].
3) Fullscreen: Android apps have the possibility to enter the so
called fullscreen mode, through which they can draw on the device’s
entire screen area, including the area where the navigation bar is
usually drawn. Without proper mitigations, this ability could be
exploited by malicious apps, for example, to create a fake home
screen including a fake status bar and a fake navigation bar. The
malicious app would therefore give the user the impression she is
interacting with the OS, whereas her inputs are still intercepted by
the malicious app.
Android implements specific mitigations against this threat [17]:
An app can draw an Activity on the entire screen, but in principle
users always have an easy way to close it and switch to another
app. Specifically, in Android versions up to 4.3, the navigation bar
appears on top of a fullscreen Activity as soon as the user clicks
on the device screen. Android 4.4 introduces a new “immersive”
fullscreen mode in which an Activity remains in fullscreen mode
during all interactions: in this case, the navigation bar is accessed
by performing a specific “swipe” gesture.
Given the large number of possible combinations of flags that
apps are allowed to use to determine the appearance of a Window
in Android, these safety functionalities are intrinsically difficult
to implement. In fact, the implementation of the Android APIs in
charge of the creation and display of Windows has thousands of lines
of code, and bugs in this APIs are likely to enable GUI confusion
attacks. Therefore, we used our API exploration tool to check if it
is possible to create a Window that covers the entire device’s screen
area (including the navigation bar) without giving any possibility
to the user to close it or to switch to another application. We call a
Window with these properties an “inescapable” fullscreen Window.
Our tool works by spawning Windows with varying input
values of GUI-related APIs and, after each invocation, determines
whether an “inescapable” fullscreen mode is entered. By using it,
several such combinations were found, thus leading to the discovery
of vulnerabilities in different Android versions. Upon manual
investigation, we found that Google committed a patch5 to fix a bug
present in Android 4.3; however, our tool pointed out that this fix
does not cover all possible cases. In fact, we found a similar problem
that affects Android versions 4.4 and 5.0. We notified Google’s
Security Team: a review is in progress at the time of this writing.
Section IV-B presents more technical details about the tool we
developed and its findings.
There is effectively no limit to what a malicious programmer
can achieve using an “inescapable” fullscreen app. For instance, one
can create a full “fake” environment that retains full control (and
observation powers) while giving the illusion of interacting with
a regular device (either by “proxying” app Windows or by relaying
the entire I/O to and from a separate physical device).
B. Enhancing techniques
Additional techniques can be used in conjunction with the
aforementioned attack vectors to mount more effective attacks.
1) Techniques to detect how the user is currently interacting with
the system: To use the described attack vectors more effectively, it
is useful for an attacker to know how the user is currently interacting
with the device.
For instance, suppose again that a malicious app wants to steal
bank account credentials. The most effective way would be to
wait until the user actually opens the specific login Activity in the
original app and, immediately after, cover it with a fake one. To do
so, it is necessary to know which Activity and which app the user
is currently interacting with.
We have identified a number of ways to do so: some of them
have been disabled in newer Android versions, but others can still
be used in the latest available Android version.
Reading the system log. Android implements a system log
where standard apps, as well as system Services, write logging and
debugging information. This log is readable by any app having the
relatively-common READ LOGS permission (see Table IV in the
next section). By reading messages written by the ActivityManager
Service, an app can learn about the last Activity that has been drawn
on the screen.
Moreover, apps can write arbitrary messages into the system log
and this is a common channel used by developers to receive debug
information. We have observed that this message logging is very
commonly left enabled even when apps are released to the public,
and this may help attackers time their actions, better reproduce the
status of an app, or even directly gather sensitive information if
debug messages contain confidential data items.
Given the possible malicious usage of this functionality, an app
can only read log messages created by itself in Android version 4.1
and above.
5https://android.googlesource.com/platform/frameworks/base/+/b816bed
934934935
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:09:15 UTC from IEEE Xplore.  Restrictions apply. 
getRunningTasks API. An app can get information about
currently running apps by invoking the getRunningTasks API. In
particular, it is possible to know which app is on top and the name
of the top Activity. The relatively-common GET TASKS permission
is required to perform such queries.
The functionality of this API has been changed in Android
5.0, so that an app can only use it to get information about its own
Activities. For this reason, in Android 5.0 this API cannot be used
anymore to detect which application is currently on top.
Accessing the proc file system. It is possible to get similar
information by reading data from the proc file system, as previous
research [6], [12] studied in detail both in a generic Linux system
and in the specific setup of an Android device.
For instance, an app can retrieve the list of running applications
by listing the /proc directory and reading the content of the file:
/proc//cmdline. However, most of the apps have
a process running in the background even when a user is not
interacting with them, so this information cannot be used to detect
the app showing the top Activity.
More interestingly, we have identified a technique to detect
which is the app the user is currently interacting with. In particular,
the content of the file /proc//cgroups changes (from
“/apps/bg non interactive” to “/apps”) when the app on top is run by
the . This is due to the fact that Android (using Linux
cgroups) uses the specific “/apps” scheduling category for the app
showing the top activity. We have tested this technique in Android
5.0 and, to the best of our knowledge, we are the first one pointing
out the usage of this technique for GUI-related attacks in Android.
[6], by reading the content of
/proc//statm, an application can infer the graphical
state of another app, and precisely identify the specific Activity with
which a user is interacting.
Finally, as studied in
2) Techniques to create graphical elements mimicking already
existing ones: To effectively replace an Activity of a “victim
app,” a convincing copy is necessary. Of course, an attacker could
develop a malicious app from scratch with the same graphical
elements as the original one. However, it is also possible to take
the original app, change its package name, and just add the attack
and information-gathering code.
The procedure of modifying an existing app (called repackaging)
is well-known in the Android ecosystem. In the context of this
paper, repackaging is a useful technique to expedite development
of interfaces that mimic those of other apps. Note, however, that
the attacks described in this section are entirely possible without
repackaging. Detecting and defending from repackaging is outside
the scope of this paper.
C. Attack app examples
In practice, malicious apps can combine multiple attack vectors
and enhancing techniques to mount stealthy attacks. For instance,
the attack app we implemented for our user study portraits itself
as a utility app. When launched, it starts to monitor other running
apps, waiting until the user switches to (or launches) the Facebook
app. When that happens, it uses the startActivity API to spawn a
malicious app on top of the genuine Facebook app. The malicious
app is a repackaged version of the actual Facebook app, with the
additional functionality that it leaks any entered user credentials to