System
80 1
0xC0000000
Process
User
3 GB
0x00000000
图6-1Linux进程虚拟空间分布
整个4GB被划分成两部分，其中操作系统本身用去了一部分：从地址0xC00000000到
0xFFFFFFFF，共1 GB。剩下的从0x00000000 地址开始到 0xBFFFFFFF共3 GB的空间都是
留给进程使用的。那么从原则上讲，我们的进程最多可以使用3GB的虚拟空间，也就是说
整个进程在执行的时候，所有的代码、数据包括通过C语言malloc(）等方法申请的虚拟空间
之和不可以超过3GB。在现代的程序中，3GB的虚拟空间有时候是不够用的，比如一些大
型的数据库系统、数值计算、图形图像处理、虚拟现实、游戏等程序需要占用的内存空间较
大，这使得32位硬件平台的虚拟地址空间显得提襟见时，当然一本万利的方法就是使用64
程序员的自我修养一链接、装载与库
---
## Page 175
152
第6章可执行文件的装载与进程
位处理器，把虚拟地址空间扩展到17179869184GB，当然不是人人都能顺利地更换64位
处理器，更何况有很多现有的程序只能运行在32位处理器下。那么32位CPU的平台能不
能使用超过4GB的空间呢？这个问题我们将在后面的“PAE”一节中进行介绍。
不知读者是否注意到，上文提到这3GB的空间“原则上”是可以给进程使用的，但令
人遗撼的是，进程并不能完全使用这3GB的虚拟空间，其中有一部分是预留给其他用途的，
我们在后面还会提到。
对于Windows操作系统来说，它的进程虚拟地址空间划分是操作系统占用2GB，那么
进程只剩下2GB空间。2GB空间对一些程序来说太小了，所以Windows有个启动参数可
以将操作系统占用的虚拟地址空间减少到1GB，即跟Linux分布一样。方法如下：修改
Windows系统盘根目录下的 Boot.ini，加上“/3G”参数。
[boot loader]
defau1t=mu1ti (0)disk (0) rdisk (0) part ition (1) \WINDOwS
tineout=30
[operating sy8tems]
multi (0)disk(0)rdiek(0)partition(1)\wINDows=*Microsoft Windows XP
Professional* /3G /fastdetect /NoExecute=OptIn
PAE
32位的CPU下，程序使用的空间能不能超过4GB呢？这个间题其实应该从两个角度
来看，首先，问题里面的“空间”如果是指虚拟地址空间，那么答案是“否”。因为32位的
CPU只能使用32位的指针，它最大的寻址范围是0到4GB：如果问题里面的“空间*指
计算机的内存空间，那么答案为“是“。Intel自从1995年的PentiumPro CPU开始采用了36
位的物理地址，也就是可以访问高达64GB的物理内存。
从硬件层面上来讲，原先的32位地址线只能访问最多4GB的物理内存。但是自从扩
展至36位地址线之后，Intel修改了页映射的方式，使得新的映射方式可以访同到更多的物
理内存。Intel把这个地址扩展方式叫做PAE（Physical Address Extension）。
当然扩展的物理地址空间，对于普通应用程序来说正常情况下感觉不到它的存在，因为
这主要是操作系统的事，在应用程序里，只有32位的虚拟地址空间。那么应用程序该如何
使用这些大于常规的内存空间呢？一个很常见的方法就是操作系统提供一个窗口映射的方
法，把这些额外的内存映射到进程地址空间中来，应用程序可以根据需要来选择申请和映射，
程序可以从高于4GB的物理空间中中请多个大小为256MB的物理空间，编号成A、B、C
等，然后根据需要将这个窗口映射到不同的物理空间块，用到A时将0x10000000～
0x20000000映射到A，用到B、C时再映射过去，如此重复操作即可。在Windows下，这
种访间内存的操作方式叫做 AWE（Address Windowing Extensions）：面像Linux等UNIX
程序员的自我修养一链接、装载与库
---
## Page 176
6.2装载的9方式
153
类操作系统则采用mmapO系统调用来实现。
当然这只是种补枚32位地址空间不够大时的非常规手段，真正的解决方法还是应该
使用64位的处理器和操作系统，这不仅使人想起了DOS时代16位地址不够用时，也采用
了类似的16位CPU字长，20位地址线长度，系统有着640KB、1MB等诸多访问限制。
由于很多应用程序须访问超过IMB的内存，所以当时也有很多类似PAE和AWE的方法，
Windows 下的 PAE和AWE可以使用与/3G 相似的启动选项/PAE和/AWE打开。
6.2
装载的方式
程序执行时所需要的指令和数据必须在内存中才能够正常运行，最简单的办法就是将程
序运行所需要的指令和数据全都装入内存中，这样程序就可以顺利运行，这就是最简单的静
态装入的办法。但是很多情况下程序所需要的内存数量大于物理内存的数量，当内存的数量
不够时，根本的解决办法就是添加内存。相对于磁盘米说，内存是昂贵且稀有的，这种情况
自计算机磁盘诞生以来一直如此。所以人们想尽各种办法，希望能够在不添加内存的情况下
让更多的程序运行起来，尽可能有效地利用内存。后来研究发现，程序运行时是有局部性原
理的，所以我们可以将程序最常用的部分驻留在内存中，面将一些不太常用的数据存放在慰
盘里面，这就是动态装入的基本原理。
覆盖装入（Overlay）和页映射（Paging）是两种很典型的动态装载方法，它们所采用
的思想都差不多，原则上都是利用了程序的局部性原理。动态装入的思想是程序用到哪个模
块，就将哪个模块装入内存，如果不用就暂时不装入，存放在磁盘中。
注
按照2009年2月的数据，以一个普通的希捷7200RPM的桌面PC硬盘为例，它拥有
8MB缓存，500GB的容量，价格是459元。按照每GB的价格来算，DDR2667内存
每GB约150元，而硬盘每GB的价格不到1元，价格大约是内存的1/200。
6.2.1覆盖装人
覆盖装入在没有发明虚拟存储之前使用比较广泛，现在已经几乎被淘汰了，虽然这种方
法很整脚，在被虚拟存储惯坏了的现代PC机程序员眼里可能不屑一顾，但是它在计算机发
展的初期的确为程序能够在内存受限的机器下正常运行提供了一种解决方案。它所体现的
些思想还是很有意义的。值得一提的是，在一些现代嵌入式的内存受限环境下，特别是诸如
DSP等，这种方法或许还有用武之地。
覆盖装入的方法把挖掘内存潜力的任务交给了程序员，程序员在编写程序的时候必须手
程序员的自我修养一链接、装载与库
---
## Page 177
154
第6章可执行文件的装载与进程
工将程序分割成若干块，然后编写一个小的辅助代码来管理这些模块何时应该驻留内存面何
时应该被替换掉。这个小的辅助代码就是所调的覆盖管理器（Overlay Manager）。最简单的
情况下，一个程序有主模块“main”.main 分别会调用到模块A和模块B，但是A和B 之
间不会相互调用：这三个模块的大小分别是1024字节、512字节和256字节。假设不考虑
内存对齐、装载地址限制的情况，理论上运行这个程序需要有1792个字节的内存。如果我
们采用覆盖装入的办法，那么在内存中可以这样安排，如图6-2所示。
Overlay Me
568yte
Physical Memory
图6-2简单盖载入
由于模块A和模块B之间相互调用依赖关系，我们可以把模块A和模块B在内存中"相
互覆盖”，即两个模块共享块内存区域。当main模块调用模块A时，覆盖管理器保证将模
块A从文件中读入内存：当模块main调用模块B时，则覆盖管理器将模块B从文件中读入
内存，由于这时模块A不会被使用，那么模块B可以装入到原来模块A所占用的内存空间，
很明显，除了覆盖管理器，整个程序运行只需要1536个字节，比原来的方案节省了256字
节的空间。覆盖管理器本身往往很小，从数十字节到数百字节不等，一般都常驻内存。
上面的例子是最简单的覆盖情况，但是事实上程序往往不止两个模块，而模块之间的调
用关系也比上面的例子要复杂。在多个模块的情况下，程序员需要手工将模块按照它们之间
的调用依赖关系组织成树状结构。
按照图6-3的组织关系，模块main依赖于模块A和B，模块A依赖于C和D：模块B
依赖于E和F，则它们在内存中的覆盖方式如图中所示。很明显，这个程序的运行方式与前
面的例子大同小异，值得注意的是，覆盖管理器需要保证两点。
程序员的自我修养一链接、装载与库
---
## Page 178
6.2装载的方式
155
ofevew AeuaAO
Physical Memory
图6-3复杂的覆盖载入
这个树状结构中从任何一个模块到树的根（也就是main）模块都叫调用路径。当该模
块被调用时，整个调用路径上的模块必须都在内存中。比如程序正在模块E中执行代
码，那么模块B和模块main必须都在内存中，以确保模块E执行完毕以后能够正确返
回至模块B和模块main。
禁止跨树间调用。任意一个模块不允许跨过树状结构进行调用。比如上面例子中，模
块A不可以调用模块B、E、F：模块C不可以调用模块D、B、E、F等。因为覆盖管
理器不能够保证跨树间的模块能够存在于内存中。不过很多时候可能两个子模块都需
要依赖于某个模块，比如模块E和模块C都需要另外一个模块G，那么最方便的做法
是将模块G并入到main模块中，这样G就在E和C的调用路径上了。
当然，由于跨模块间的调用都需要经过覆盖管理器，以确保所有被调用到的模块都能够
正确地驻留在内存，而且一且模块没有在内存中，还需要从磁盘或其他存储器读取相应的模
块，所以覆盖装入的速度肯定比较慢，不过这也是一种折中的方案，是典型的利用时间换取
空间的方法。
6.2.2页映射
页映射是虚拟存储机制的一部分，它随着虚拟存储的发明而诞生。前面我们已经介绍了
页映射的基本原理，这里我们再结合可执行文件的装载来闸述一下页映射是如何被应用到动
态装载中去的。与覆盖装入的原理相似，页映射也不是一下子就把程序的所有数据和指令都
程序员的自我修养一链接、装载与库
---
## Page 179
156
第6章可执行文件的装载与进程
装入内存，而是将内存和所有磁盘中的数据和指令按照“页（Page）”为单位划分成若干个
页，以后所有的装载和操作的单位就是页。以目前的情况，硬件规定的页的大小有4096字
节、8192字节、2MB、4MB等，最常见的Intel1A32处理器一般都使用4096字节的页，
那么512MB的物理内存就拥有512*1024*1024/4096=131072个页。
为了演示页映射的基本机制，假设我们的32位机器有16KB的内存，每个页大小为4096
字节，则共有4个页，如表6-1所示。
表6-1
页编号
地址
F0
0x00000000x00000FFF
F1
0x000010000x00001FFF
F2
0x00002000—0x00002FFF
F3
0x000030000x00003FFF
号为P0~P7。很明显，16KB的内存无法同时将32KB的程序装入，那么我们将按照动态
装入的原理来进行整个装入过程。如果程序刚开始执行时的入口地址在PO，这时装载管理
器（我们假设装载过程由一个叫装载管理器的家伙来控制，就像覆盖管理器一样）发现程序
的PO不在内存中，于是将内存FO分配给P0，并且将PO的内容装入F0：运行一段时间以
后，程序需要用到P5，于是装裁管理器将P5装入F1：就这样，当程序用到P3和P6的时
候，它们分别被装入到了F2和F3，它们的映射关系如图6-4所示。
P7
P6
P5
P4
P3
F3
P2
F2
P1
F1
PO
F0
Executable
Physical Memory
图6-4页映射与页装载
很明显，如果这时候程序只需要P0、P3、P5和P6这4个页，那么程序就能一直运行
下去。但是问题很明显，如果这时候程序需要访问P4，那么装载管理器必须做出抉择，它
必须放弃目前正在使用的4个内存页中的其中一个来装载P4。至于选择哪个页，我们有很
程序员的自我修养一链接、装载与库
---
## Page 180
6.3从操作系统角度看可执行文件的装载
157
多种算法可以选择，比如可以选择F0，因为它是第一个被分配掉的内存页（这个算法我们
可以称之为FIFO，先进先出算法）：假设装载管理器发现F2很少被访问到，那么我们可以
选择F2（这种算法可以称之为LUR，最少使用算法）。假设我们放弃PO，那么这时候FO就
装入了4。程序接看按照这样的方式运行。
可能很多读者已经发现了，这个所谓的装载管理器就是现代的操作系统，更加准确地讲
就是操作系统的存储管理器。目前几乎所有的主流操作系统都是按照这种方式装载可执行文
件的，我们熟悉的Windows 对PE文件的装载及Linux对ELF文件的装载都是这样完成的。
接着我们将从操作系统的角度米看可执行文件的装载。
6.3从操作系统角度看可执行文件的装载
从上面页映射的动态装入的方式可以看到，可执行文件中的页可能被装入内存中的任
意页。比如程序需要P4的时候，它可能会被装入F0～F3这4个页中的任意个。很明显，
如果程序使用物理地址直接进行操作，那么每次页被装入时都需要进行重定位。正如我们
在第1章中所提到的，在虚拟存储中，现代的硬件MMU都提供地址转换的功能。有了硬
件的地址转换和页映射机制，操作系统动态加载可执行文件的方式跟静态加载有了很大的
区别。
我们经常看到各种可执行文件的装载过程的描述，虽然大致能够明白这个过程，但是总
觉得似乎还有那么一层迷雾阻隔着，一且涉及细节总是有一些模期。本节我们将站在操作系
统的角度来阐述一个可执行文件如何被装载，并且同时在进程中执行。
6.3.1进程的建立
事实上，从操作系统的角度来看，一个进程最关键的特征是它拥有独立的虚拟地址空间，
这使得它有别于其他进程。很多时候一个程序被执行同时都伴随着一个新的进程的创建，那
么我们就来看看这种最通常的情形：创建一个选程，然后装较相应的可执行文件并且执行。
在有虚拟存储的情况下，上述过程最开始只需要做三件事情：
·创建一个独立的虚拟地址空间。
·读取可执行文件头，并且建立虚拟空间与可执行文件的映射关系。
·将CPU的指令寄存器设置成可执行文件的入口地址，启动运行。
首先是创建虚拟地址空间，回亿第1章的页映射机制，我们知道一个虚拟空间由一组页
映射函数将虚拟空间的各个页映射至相应的物理空间，那么创建一个虚拟空间实际上并不是
创建空间而是创建映射函数所需要的相应的数据结构，在i386的Linux下。创建虚拟地址
程序员的自我修养一键接、装载与库
---
## Page 181
158
第6章可执行文件的装载与进程
空间实际上只是分配一个页目录（Page Directory）就可以了，甚至不设置页映射关系，这些
映射关系等到后面程序发生页错误的时候再进行设置。
读取可执行文件头，井且建立虚拟空间与可执行文件的映射关系。上面那一步的页映射
关系函数是虚拟空间到物理内存的映射关系，这一步所做的是虚拟空间与可执行文件的映射
关系。我们知道，当程序执行发生页错误时，操作系统将从物理内存中分配一个物理页，然
后将该“缺页”从磁盘中读取到内存中，再设置缺页的虚拟页和物理页的映射关系，这样程
序才得以正常运行。但是很明显的一点是，当操作系统捕获到缺页错误时，它应知道程序当
前所需要的页在可执行文件中的哪一个位置。这就是虚拟空间与可执行文件之间的映射关
系。从某种角度来看，这一步是整个装裁过程中最重要的一步，也是传统意义上“装载”的
过程。
由于可执行文件在装载时实际上是被映射的虚拟空间，所以可执行文件很多时候又被
叫做映像文件（Image）。