computes c1, c2 in the encrypted domain, i.e., an encrypted DGK evaluation of
Bob’s ciphertexts EpkB (vb,1), EpkB (vb,2) with Alice’s input va,1, va,2:
c1[0] = − EpkB (vb,1)[0] + EpkB (vb,2)[0]
− 2 · va,2 · EpkB (vb,2)[0]
c1[1] =va,1 · P1 − EpkB (vb,1)[1] + P1 + va,2 · P1
+ EpkB (vb,2)[1] − 2 · va,2 · EpkB (vb,2)[1]
c2[0] = − EpkB (vb,2)[0]
c2[1] =va,2 · P1 − EpkB (vb,2)[1] + P1
(4)
Alice could send c1, c2 to Bob by publishing them on the blockchain, and Bob
could then decrypt them. If one of them decrypts to 0, Bob would know va  2 parties.
Along the same lines, it is actually unnecessary in the case of only two parties
to run the third round and publish the outcome of evaluations. Both Alice and
Bob already know after the second round whether va  2 parties where a minority of τ  2 and arbitrary integer bit length (cid:96) ≥ 1. We institute two major changes
to the simpliﬁed two-party, two-bit protocol. For n > 2 parties, we can achieve
malicious security, if the majority of parties is honest. First, we veriﬁably secret
share each party’s private key during the ﬁrst round, using the blockchain as a
broadcast channel. Second, we append another round on demand. If a malicious
party Pi is aborting the protocol at any time or caught cheating in their ZK
proofs, (honest) parties agree to run another round. In this round, parties will
re-assemble shares of Pi’s secret key and reveal Pi’s input integer. Thereby, we
determine the party with the kth-ranked integer, even if this integer comes from
a malicious Pi.
4.3.1 First Round
Let VSS(t, n, G1, pklt
1 , . . . , pklt
Algorithm 2 presents details for BOREALIS’ ﬁrst round. The ﬁrst step in this
ﬁrst round is, for each party, to generate and secret share a fresh session key.
While there exists a large body of work on eﬃcient (publicly) veriﬁable secret
sharing (VSS), we use a new variation of Schoenmakers [50]’s solution due to
its simplicity and eﬃciency. We brieﬂy summarize our variation in Appendix A
and only state its main property here.
n) be a veriﬁable secret sharing scheme. Param-
eter n denotes the total number of parties, t the number of parties required to
reconstruct a secret, G1 a group where the DDH holds, and pklt
n the
i · P1
parties long-term public keys. Note that public keys are of type pklt
where P1 generates G1 and sklt
i ∈ Zp is the private key. As one can see, VSS
accepts exactly BOREALIS’ long-term public keys as input. The output of VSS
is a random private key sk ∈ Zp, internal commitments C, encryptions Yj of
shares under the other parties Pjs’ public keys, and a ZK proof ProofVSS proving
consistency of the shares (Appendix A).
So, each party Pi invokes VSS, gets private session key ski, and computes
public session key pki = ski · P1 ∈ G1. Pi also generates random strings rj
1 , . . . , pklt
i = sklt
14
p;
p
;
2
3
4
5
6
7
1 , . . . , pklt
n);
1 foreach party Pi, 1 ≤ i ≤ n do
Let η = (cid:96) · log (cid:96) − (cid:96)
2 .
// Let Pi’s long term public key be pklt
i .
(ski,C0, . . . ,Cτ−1,Y1, . . . ,Yn, Proof VSS,i) ← VSS(τ − 1, n, G1, pklt
pki = ski · P1;
{ri,1, . . . , ri,(cid:96)} $← Z(cid:96)
{(Ri,1,1, . . . , Ri,1,(cid:96)), . . . , (Ri,n−1,1, . . . , Ri,n−1,(cid:96))} $← Z(n−1)·(cid:96)
{(βi,1,1, . . . , βi,1,η), . . . , (βi,n−1,(cid:96), . . . , βi,n−1,(cid:96))} $← {0, 1}(n−1)·η;
publish pki, Com(ski), Proof KeyECDLP,i,C0, . . . ,Cτ−1,
Y1, . . . ,Yn, Proof VSS,i, Com(vi,1), . . . , Com(vi,(cid:96)), Proof Bit,i,1, . . . , Proof Bit,i,(cid:96),
Com(ri,1), . . . , Com(ri,(cid:96)), ci,1 = Epki (vi,1), . . . , ci,(cid:96) = Epki (vi,(cid:96)), Proof Enc,i,1,
. . . , Proof Enc,i,(cid:96), Com(Ri,1,1), . . . , Com(Ri,1,(cid:96)), . . . , Com(Ri,n−1,(cid:96)),
(Com(βi,1,1), . . . , Com(βi,1,η)), (Com(βi,n−1,1), . . . , Com(βi,n−1,η)),
(Proof Bit,i,1,1, . . . , Proof Bit,i,1,η), . . . , (Proof Bit,i,n−1,1, . . . , Proof Bit,i,n−1,η) on
blockchain;
8 end
Algorithm 2: BOREALIS’ ﬁrst round
for use in encryption, random strings Rj for blinding, and random bits βj for
shuﬄing, lines 2 to 6 in Algorithm 2. Pi publishes this information together
with corresponding ZK proofs of correctness on the blockchain, see Line 7. In
detail, Pi publishes:
 public key pki, a commitment to private key ski, ZK correctness proof ProofKeyECDLP,
 VSS commitments C, ski’s encrypted shares Y, and the VSS ZK proof of
correctness,
 Groth and Sahai commitments to each bit vi,j and ZK proofs ProofBit which
prove that each vi,j is a bit; random strings ri,j used for encryptions of bits
and additively homomorphic Elgamal encryptions Epki(vi,j) = (ri,j · P1, ri,j ·
pki + vi,j · P1) of each bit; ZK proofs of correctness ProofEnc for each bit,
 commitments to (n − 1) · (cid:96) random R used later during blinding,
 commitments to (n − 1) · ((cid:96) · log (cid:96) − (cid:96)
2 ) bits β used later during shuﬄing, and
corresponding (n − 1) · ((cid:96) · log (cid:96) − (cid:96)
2 ) ZK proofs ProofBit that the βs are bits.
Note that all Pi perform their computations and publish their output in
parallel at the same time. Therefore, the ﬁrst round requires one block latency.
4.3.2 Second Round
Both the second and third round start by parties verifying ZK proofs. To keep
exposition clean, we defer details about handling invalid ZK proofs as well as
parties aborting protocol execution to Section 4.4. In the following, assume that
proofs are successfully veriﬁed.
After verifying ZK proofs, the main part of the second round starts (Al-
gorithm 3). Each party Pi homomorphically computes a DGK comparison for
each other party. Speciﬁcally, Pi computes for each other party’s integer vj and
15
1 foreach party Pi, 1 ≤ i ≤ n do
foreach j (cid:54)= i do
for u = 2 to (cid:96) do
2
3
4
5
6
7
8
9
10
11
12
13
14
15
// Compute XORs
wu = Epkj (vj,u)[0] − 2 · vi,u · Epkj (vj,u)[0];
Wu = vi,u · P1 + Epkj (vj,u)[1] − 2 · vi,u · Epkj (vj,u)[1];
end
for u = 1 to (cid:96) do
// Ciphertexts ci,j,u = (ci,j,u[0], ci,j,u[1])
ci,j,u[0] = −Epkj (vj,u)[0] +(cid:80)(cid:96)
ci,j,u[1] = vi,u · P1 − Epkj (vj,u)[1] + P1 +(cid:80)(cid:96)
δ=u+1 wδ;
δ=u+1 Wδ);
i,j,u
publish Com(ci,j,u[0]), Com(ci,j,u[1]), Proof DGK,i,j,u on blockchain;
// Blinded ciphertexts c(cid:48)
c(cid:48)
i,j,u = (Ri,j,u · ci,j,u[0], Ri,j,u · ci,j,u[1]);
i,j,u[0]), Com(c(cid:48)