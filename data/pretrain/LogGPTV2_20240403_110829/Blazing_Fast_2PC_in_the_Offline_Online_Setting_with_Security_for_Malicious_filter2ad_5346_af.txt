180
176
169
234
211
196
Table 6: Running times of AES and SHA-1 in WAN conﬁguration using the parameters of Table 3 (in ms) for s = 80. The roundtrip
between the parties was 75 ms.
Number of buckets
Ofﬂine total Ofﬂine per bucket
32
128
1024
6915
18367
93613
216
143
91
Online time per bucket
1 thread
5 threads
9 threads
17
12
8
12
10
6
12
10
6
Table 7: Running times of AES (in ms) in LAN conﬁguration using the parameters of Table 2 on c4.2xlarge instances. (The costs for
s = 80 are about 2-3 times larger.)
[15] Y. Huang, J. Katz, V. Kolesnikov, R. Kumaresan, and A. J.
Malozemoff. Amortizing garbled circuits. In CRYPTO 2014,
Springer (LNCS 8617), pages 458–475, 2014.
[16] V. Kolesnikov and T. Schneider. Improved garbled circuit:
Free xor gates and applications. In ICALP 2008, Springer
(LNCS 5126), pages 486–498, 2008.
[17] B. Kreuter, A. Shelat, and C.-H. Shen. Billion-gate secure
computation with malicious adversaries. In USENIX
Security, pages 14–14, 2012.
[18] Y. Lindell. Highly-efﬁcient universally-composable
commitments based on the DDH assumption. In
EUROCRYPT 2011, Springer (LNCS 6632), pages 446–466,
2011.
[19] Y. Lindell. Fast cut-and-choose based protocols for malicious
and covert adversaries. In CRYPTO 2013, Springer (LNCS
8043), pages 1–17, 2013.
[20] Y. Lindell and B. Pinkas. An efﬁcient protocol for secure
two-party computation in the presence of malicious
adversaries. In EUROCRYPT 2007, Springer (LNCS 4515),
pages 52–78, 2007.
[21] Y. Lindell and B. Pinkas. A proof of security of Yao’s
protocol for two-party computation. Journal of Cryptology,
22(2):161–188, 2009.
[22] Y. Lindell and B. Pinkas. Secure two-party computation via
cut-and-choose oblivious transfer. In the 8th TCC, Springer
(LNCS 6597), pages 329–346, 2011.
[23] Y. Lindell and B. Riva. Cut-and-choose yao-based secure
computation in the online/ofﬂine and batch settings. In
CRYPTO 2014, Springer (LNCS 8617), pages 476–494,
2014.
[24] P. Mohassel and M. K. Franklin. Efﬁciency tradeoffs for
malicious two-party computation. In PKC 2006, Springer
(LNCS 3958), pages 458–473, 2006.
[25] P. Mohassel and B. Riva. Garbled circuits checking garbled
circuits: More efﬁcient and secure two-party computation. In
CRYPTO 2013, Springer (LNCS 8043), pages 36–53, 2013.
[26] J. B. Nielsen, P. S. Nordholt, C. Orlandi, and S. S. Burra. A
new approach to practical active-secure two-party
computation. In CRYPTO 2012, Springer (LNCS 7417),
pages 681–700, 2012.
[27] B. Pinkas, T. Schneider, N. P. Smart, and S. C. Williams.
Secure two-party computation is practical. In ASIACRYPT
2009, Springer (LNCS 5912), pages 250–267, 2009.
[28] M. O. Rabin, Y. Mansour, S. Muthukrishnan, and M. Yung.
Strictly-black-box zero-knowledge and efﬁcient validation of
ﬁnancial transactions. In ICALP 2012, Springer (LNCS
7391), pages 738–749, 2012.
[29] A. Shelat and C.-H. Shen. Two-output secure computation
with malicious adversaries. In EUROCRYPT 2011, Springer
(LNCS 6632), pages 386–405. Springer, 2011.
[30] A. Shelat and C.-h. Shen. Fast two-party secure computation
with minimal assumptions. In ACM CCS, pages 523–534,
2013.
[31] N. Smart. Personal communication, February 2015.
[32] A. C.-C. Yao. How to generate and exchange secrets. In
FOCS, pages 162–167, 1986.
APPENDIX
A. THE FULL PROTOCOL
SPECIFICATION
FIGURE A.1
(THE OFFLINE STAGE).
Setup:
(cid:104)
that
x,y(1),y(2)(cid:17)
(cid:16)
x, (Ey(1))⊕ y(2)(cid:17)
(cid:16)
• s is a statistical security parameter, N is the number of online
2PC executions that P2 wishes to run, p, p(cid:48) are probabilities,
and B,B(cid:48) are chosen according to Lemmas 2.2 and 2.3.
computes
• The parties decide on two circuits:
f
(1) A circuit
C
,
with y(2) being public-input wires.
(2) A cheating-
C(cid:48)(x,D,d(1),d(2))
that
computes
recovery
D = ((E(cid:48)d(1))⊕ d(2)) ? x | 0
, with d(2) and D being
public-input wires. E and E(cid:48) are chosen at random by P2 as
discussed in Section 2.3.
For simplicity of the description here, we require that both
circuits are constructed as described in Section 2.3 so that
the value of Ey(1) (or E(cid:48)d(1)) remains private even if s − 1
bits of y(1) (or d(1)) are revealed.
circuit
(cid:105)
Running the cut-and-choose for C and for C(cid:48):
• The parties run the cut-and-choose sub protocol from Fig-
ure A.1 with the circuit C and parameters p,N and B.
• The parties run the cut-and-choose sub protocol from Fig-
ure A.1 with the circuit C(cid:48) and parameters p(cid:48),N and B(cid:48). (Note
that the same N is used in both cut-and-choose, so both result
in the same number of buckets.)
588FIGURE A.2
(THE OFFLINE STAGE (CONTINUED) AND SUB-PROTOCOLS).
The Ofﬂine Stage – Continued
Running the cut-and-choose for C and for C(cid:48) (cont.): We chose to simplify the description by using the cut-and-choose as a sub-protocol.
However, the calls to FExCom∆ZK for the masks of C and C(cid:48) must be done together since P2 should learn the XORs of the masks for the circuits
that are placed in the same bucket. In the proof, we assume that the steps of the two cut-and-choose sub protocols are done in parallel, and thus
the calls to FExCom∆ZK can be done together.
From now on, we refer to the elements of the second cut-and-choose with prime. E.g. π(cid:48) is the mapping function of the second execution from
above (while π is of the ﬁrst one). Also, denote the remaining garbled circuits according to their placement by π, i.e. let gc j,i be the ith circuit
of the jth bucket (for j = 1, . . . ,N and i = 1, . . . ,B).
Running OTs for C and for C(cid:48):
1 , . . . ,y(1)
• P2 chooses y(1)
• P1 acts as the sender in Fot and P2 as the receiver. For bucket j = 1, . . . ,N, the parties execute |y(1)| OTs, in which in the ith OT P2
, and P1 inputs the set of labels that correspond to 0 in the ith bit, and the set of labels that correspond to 1, both
N ∈R {0,1}|y(1)|, and d(1)
N ∈R {0,1}|d(1)|.
1 , . . . ,d(1)
inputs the ith bit of y(1)
j
concatenated with their decommitments related to lc-s. (Recall that the labels are XORed with λ j.)
The players do the same for circuit C(cid:48), where P2 inputs the bits of d(1)
j,i .
Storing buckets for the online stage: For bucket j = 1, . . . ,N:
• P1 stores (seed j,i,m j,i,lc j,i, ld j,i,λ j,i) for i = 1, . . . ,B, and similarly for all the bundles of C(cid:48).
• P2 stores y(1)
, lc j,i and gc j,i for i = 1, . . . ,B. In addition, it stores the labels it has received for its input y(1)
j
j
∆ j, and similarly for all the bundles of C(cid:48).
from the OTs, the values of
• A circuit C(x,y(1),y(2)) with y(2) being public-input wires, or, a circuit C(x,D,y(1),y(2)) with D,y(2) being public-input wires
Creating a Garbled-Circuit Bundle
Public Parameters:
Constructing the bundle:
• Pick a seed seed ∈R {0,1}k. All the randomness needed in the next steps is derived from PRFseed (·). Pick m ∈R {0,1}|x|.
• Construct a garbled circuit gc in which the output-wire labels are the actual output bits concatenated with random labels. (E.g., the
output label for bit zero is 0|l where l ∈R {0,1}k). We use an adaptively-secure garbling scheme as discussed in Section 2.2, in which
all input-wire labels are XORed with λ .
(cid:110)(cid:16)
• Commit to x’s input-wire labels, permuted according to m, by
i ))(cid:9)
• Commit to all input-wire labels of y(1) and y(2) by(cid:8)(i, commit(λ ⊕W 0
• If D is an input to the circuit, commit to all input-wire labels of D by(cid:8)(i, commit(λ ⊕W 0
(cid:1) .
• Commit to all output-wire labels by commit(cid:0){i,W 0
i ), commit(λ ⊕W 1
i, commit(λ ⊕W mi
i
i ,W 1
i }i∈Out(C)
), commit(λ ⊕W 1−mi
)
i
.
i∈In(C,x)
i∈In(C,y(1))∪In(C,y(2)).
i ), commit(λ ⊕W 1
i∈In(C,D).
• Let lc be the union of the above sets of label commitments, and let ld be the set of all the corresponding decommitments.
• Output (gc,lc;seed,ld,m,λ ).
(cid:17)(cid:111)
i ))(cid:9)
Public parameters:
The Cut-and-Choose Mechanism
• Let s,N,B ∈ N and p ∈ (0,1) parameters. Let M = NB
p . (Assume no rounding of M is needed.) Denote the circuit by C.
Picking the cut, the buckets, and the ofﬂine inputs:
• The cut: P2 sets σ to be a random string of length M that has exactly NB ones.
• The mapping: P2 picks a PRF seed seedπ and uses PRFseedπ (·) to compute a mapping function π : [N · B] → [N] that maps exactly B
elements to each bucket.
Deﬁne πσ : [M] → [N] to be the function that maps an index j that is the ith non-zero bit in σ to π(i). Let Bi be the set { j|πσ ( j) = i}
for i = 1, . . . ,N.
• P2 commits on σ and seedπ using ExtractCom(·).
The cut-and-choose:
ExtractCom(λ1), . . . , ExtractCom(λM).
• P1 runs the garbled-circuit bundle procedure above with the circuit C, and receives (gc j,lc j; seed j,ld j,m j,λ j), for j = 1, . . . ,M.
• P1 sends gc1, . . . ,gcM and lc1, . . . ,lcM, and commits on their seeds and λ s by ExtractCom(seed1), . . . , ExtractCom(seedM) and
• P2 inputs to FExCom∆ZK the sets Bi, for i = 1, . . . ,N, while P1 inputs the values m1, . . . ,mM. P2 learns the sets ∆i for each bucket,
• P2 decommits σ and seedπ . P1 veriﬁes that they are consistent with J and the Bi-s received in the last step.
• Let J be the indexes that did not appear in any Bi. For j ∈ J, P1 asks FExCom∆ZK to reveal m j, and in addition decommits seed j and λ j.
• P2 computes the set {gci,lci} j∈J using the seeds it received and veriﬁes that everything is correct.
whereas P1 learns sets Bi-s.
589FIGURE A.3
(THE ONLINE STAGE).
We focus here on a single 2PC with a single bucket. For simplicity, we omit the bucket index j when we refer to its garbled circuits, etc.
Private inputs: P1’s input is x. P2’s input is y.
Evaluating C:
• P2 sends y(2) = y⊕ y(1)
• P1 sends x1 = x⊕ m1.
• For i = 1, . . . ,B,
j E.
– P1 decommits λi.
– P1 sends the input-wire labels for y(2) and for xi = x1⊕m1⊕mi in gci, and the decommitments of those labels for the corresponding
commitments in lci. (Recall that P2 knows m1 ⊕ mi from ∆ j, thus, can compute the value of xi by itself.)
• P1 picks D ∈R {0,1}k.
• For v ∈ Out(C),
i,v be the b-th label of output wire v of gci, where v ∈ Out(C). P1 sends W 0
– P1 chooses Rv ∈R {0,1}k.
– Let W b
• P1 sends H(D).
• P2 evaluates gci, for i = 1, . . . ,B, and then uses the output wire labels to “decrypt” the associated Rv and Rv ⊕ D values. In case it learns
both Rv and Rv ⊕ D for some output wire, it checks if the XOR of them is indeed D (by applying H(·) and comparing with the value
that P1 has sent). If so, it sets d to D. Otherwise, it sets d ∈ {0,1}s.
i,v ⊕ Rv ⊕ D for i = 1, . . . ,B.
i,v ⊕ Rv,W 1
• If all evaluations (that ended) returned the same output, set z to be that output.
Evaluating C(cid:48):
• Let d(1) the input that P2 used in the OTs for circuit C(cid:48) in bucket j. P2 sends d(2) = d ⊕ d(1)E(cid:48).
• P1 sends D, and for i = 1, . . .B(cid:48), and:
for C).
• P1 decommits the commitments on the output labels of gci, for i = 1, . . .B (i.e. revealing all output wire labels of the garbled circuits
• P2 veriﬁes all decommitments, all the value W 0
i,v ⊕ Rv ⊕ D, for i = 1, . . . ,B and v ∈ Out(C), and the hash H(D), and aborts if
• P2 evaluates gc(cid:48)
i, for i = 1, . . .B(cid:48), and takes the majority output to be ˆx.
i,v ⊕ Rv,W 1
there is a problem.
P2’s output:
• If all evaluation circuits of C returned the same output z, then P2 outputs z.
• Else, if P2 has learned earlier d such that H(d) = H(D), then it outputs f ( ˆx,y).
• Else, let gci be a circuit for which all the output labels that P2 received from its evaluation were also the labels that were decommitted
earlier from lci. P2 outputs the output of gci.
– P1 decommits λ(cid:48)
i .
– Sends the labels that correspond to D and d(2) in gc(cid:48)
i in gc(cid:48)
– Sends the input-wire labels for x(cid:48)
i from ∆ j.)
i. (Again, recall that P2 knows m1 ⊕ m(cid:48)
i = x1⊕m1⊕m(cid:48)
in lc(cid:48)
i, and decommits the corresponding commitments from lc(cid:48)
i.
i, and the decommitments of those labels for the corresponding commitments
590