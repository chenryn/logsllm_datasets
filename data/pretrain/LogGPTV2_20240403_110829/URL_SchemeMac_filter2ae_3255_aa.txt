# 如何利用自定义URL Scheme远程突破Mac
|
##### 译文声明
本文是翻译文章，文章来源：objective-see.com
原文地址：
译文仅供参考，具体内容表达以及含义原文为准。
## 一、前言
在最近几篇文章中，我们讨论了macOS中存在的一些漏洞或者缺陷，使得恶意代码能够执行各种恶意操作，比如绕过SIP、允许安装内核扩展、转储keychain数据以及其他操作。然而，这些漏洞利用技术都需要恶意代码已经（通过某种方式）获取目标系统上的初始代码执行权限。换句话说，这些技术都属于本地攻击范畴，通常会在攻击活动的第二阶段所使用。
今天我们将讨论恶意软件一直在使用的一种远程攻击技术，这种技术可以用来获取已打全补丁macOS系统的初始访问权限，属于第一阶段攻击技术。如果与之前介绍的各种第二阶段攻击技术结合起来，就可以通过优雅又有害的方法来攻击macOS系统。
> 注意：
>
> 虽然这种远程攻击方法仍需要一些用户交互操作，然而的确能够搞定具有安全意识的macOS目标用户。换句话说，大家需要小心这种攻击方法。
8月30日，来自DarkMatter LLC的Taha
Karim在[HITB会议](https://gsec.hitb.org/sg2018/)上做了[“The Trails of WINDSHIFT
APT”](https://gsec.hitb.org/sg2018/sessions/commsec-the-trails-of-windshift-apt/)主题演讲，他总结道：
> WINDSHIFT
> APT是最近发现的一个隐蔽的网络间谍组织，专门攻击为政府工作的人员。这个攻击组织拥有专门的高级渔叉式钓鱼基础设施，可以为钓鱼邮件以及SMS攻击提供服务，在侦察阶段不间断地跟踪目标人员，也可以通过假冒全球及本地的服务商平台，在凭据收集阶段欺骗目标用户。
>
> WINDSHIFT
> APT组织之所以与其他APT组织有所不同，原因在于他们会根据间谍和监控目的，只关注特定的个体，并且由于他们惯用的攻击手段，我们很难对其追踪溯源。WINDSHIFT
> APT组织很少使用恶意软件攻击目标，Dark Matter
> LLC发现了该攻击组织发起的几次攻击活动，并且分析了相关的macOS恶意软件。最后，WINDSHIFT
> APT有独特的macOS感染技巧，滥用macOS的原生功能自动将恶意软件投递到目标。
演讲中比较有趣的一个内容就是攻击者会滥用这种攻击方法，成功远程感染中东某政府的Mac系统。
> 注意：
>
> 本文的并不是简单地重述Taha的演讲内容，而是在此基础上进一步深入分析这款恶意软件的感染机制：
>
> 1、讨论macOS上的一些相关细节；
>
> 2、提供某些PoC代码片段；
>
> 3、讨论这种远程攻击方式的缓解措施。
## 二、Document Handler及URL Scheme
简而言之，WINDSHIFT APT组织滥用了自定义的URL
Scheme来远程感染macOS目标。尽管该过程中需要用户交互，但成本很小，并且一定程度上可以受攻击者“控制”。此外，这种攻击方法已经有成功的攻击案例（攻击中东的政府目标），表明需要用户交互并不是一种无法突破的“屏障”。
在macOS上，应用程序可以“声明”自己能够支持（或者“处理”）各种文档类型以及/或者自定义的URL
Scheme。想象一下，某个应用可能会说“如果有用户尝试打开`foo`文档类型或者`bar`这种URL
Scheme，我可以处理这种场景”。大家肯定在macOS上碰到过这种场景。比如，当我们双击一个`.pdf`文档，`Preview.app`就会被启动来处理该文档。或者在浏览器中，我们点击了指向Mac
App Store中的一个链接，`App Store.app`就会启动来处理这个请求。
不幸的是，Apple对Document Handler（文档处理程序）以及自定义URL Scheme的实现（或者“注册”）方法决定了攻击者可以滥用这种功能。
> 从操作系统的角度来看，尽管文档处理程序以及URL Scheme略有不同，但本质上是一样（因此实现方法也非常相似）。
首先我们来快速看一下Document Handler，前阶段我刚研究过这方面内容，写过一篇介绍性文章。
在之前的[文章](https://objective-see.com/blog/blog_0x12.html)中，我分析了`Mac File
Opener`这款广告软件（adware），该软件滥用了自定义的文档处理程序来实现隐蔽的持久化目标。简而言之，这款恶意软件“声明”自己能够支持超过200种类型的文件，一旦用户打开其中一种文件，恶意软件就会被操作系统自动启动来处理（理论上是显示）文档。非常耐心的持久化方法。
> 注意：如果已经有一个程序注册了一种文件类型（比如`.pdf`、`.html`等），（据我所知）这种绑定关系无法被篡改。
当然这里第一个问题是，`Mac File
Opener`广告软件（或者其他应用）如何“声明”自己能够支持哪些文件（因此在用户访问此类文件时会被调用）。第二个问题是，操作系统如何处理并注册这种信息？我推荐大家阅读[这篇文章](https://objective-see.com/blog/blog_0x12.html)，其中详细回答了这两个问题，但是这里我们也会简单地做一下总结。
那么应用程序如何告诉操作系统自己能够处理哪类文件？答案就在于程序的`Info.plist`文件总。前面提到过，`Mac File
Opener`支持超过200种文件类型，我们可以导出它的`Info.plist`文件：
在“原始的”plist中，这个信息存放在一个数组中（`CFBundleDocumentTypes`键）。根据Apple的说法：
> `CFBundleDocumentTypes`（iOS及OS
> X上的数组）包含一个字典数组，将一个或多个文档类型与具体应用关联起来。每个字典都为类型定义（type-> definition）字典，包含用来定义文档的具体键（key）。
举个例子，`.7z`（7Zip）文件类型的`Mac File
Opener`详细信息如下所示，请注意其中的`CFBundleTypeExtensions`这个key，对应的值为该广告软件声明的可以处理的文件扩展名：
    $ cat "Mac File Opener.app/Contents/Info.plist"
            BuildMachineOSBuild
            14F27
            CFBundleDevelopmentRegion
            en
            CFBundleDocumentTypes
                            CFBundleTypeExtensions
                                    7z
                            CFBundleTypeName
                            DocumentType
                            CFBundleTypeOSTypes
                                    ????
                            CFBundleTypeRole
                            Viewer
                            LSHandlerRank
                            Alternate
                            NSDocumentClass
                            Document
为了回答第二个问题，我们需要确定macOS如何处理这些文件的“注册”请求。在[“Click File, App
Opens”](https://objective-see.com/blog/blog_0x12.html)这篇文章中提到，这是一个自动化过程，一旦应用保存到本地磁盘上就会执行该操作。简单总结下，大致步骤如下：
1、应用（或者恶意软件）下载或者保存到本地文件系统中；
2、该过程会导致一个`XPC`消息发送到launch services daemon（`lsd`）；
3、`lsd`守护进程解析该应用，将应用的“document handlers”信息提取并保存到一个数据库中。
    # fs_usage -w -f filesystem | grep Info.plist
    open  /Users/user/Desktop/Mac File Opener.app/Contents/Info.plist  lsd.16457
    fstat64  F=4  lsd.16457
    read  F=4  B=0x18a97  lsd.16457
    # /usr/libexec/lsd
    ...
    (lldb) po $rsi
    { path = '/var/folders/np/85lyz_4545d5lz8wvy04xvlm0000gn/0//com.apple.LaunchServices-134501.csstore' }
我们可以利用`lsregister`（具体路径为`/System/Library/Frameworks/CoreServices.framework/Frameworks/LaunchServices.framework/Support/`）来转储`lsd`的数据库。当使用`-dump`标志调用时，`lsregister`可以显示指定了“document
handler”的所有应用，`lsd`会自动注册这些“document handler”。比如，我们可以看到其中包含`Mac File
Opener`及其注册的文档（文件类型，比如`.7z`等）：
    $ lsregister -dump
    ...
    Container mount state: mounted
    bundle id: 2592
    Mach-O UUIDs: 88225C07-0FDC-3875-A3B4-C5328E509B9E, 20A99135-975D-3A7B-A8DD-B7DF2CE428D0
    path: /Users/user/Downloads/Mac File Opener.app
    name: Mac File Opener
    identifier: com.pcvark.Mac-File-Opener (0x80025f61)
    executable: Contents/MacOS/Mac File Opener
    --------------------------------------------------------    claim id: 31508
      name: DocumentType
      rank: Alternate
      roles: Viewer
      flags: doc-type
      bindings: .7z
    ...
一旦应用（或者广告软件）自动注册了document handler，那么当用户尝试打开匹配的文档时，应用或广告软件就会被自动调用。
这个过程由`launch services
framework`负责，更具体一些，是`_LSBundleCopyOrCheckNode`方法（以及`_LSBundleCopyOrCheckNode_block_invoke`）负责匹配过程（查找与文档类型匹配的已注册的应用）然后执行已注册的应用：
    (lldb) b ___LSBundleCopyOrCheckNode_block_invoke
    ...
    (lldb) x/gx $rdx
    0x700000115c48: 0x00007fd3b4a9c520