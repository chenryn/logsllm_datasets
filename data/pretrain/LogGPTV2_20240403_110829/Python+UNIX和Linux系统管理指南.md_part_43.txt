的，它确实有它的优点。
在产品环境中这个方法或许不是最好的，但是当做开发工作时，或是出于个人使用的目
If I ever need to reattach I can run:
/home/noahgift/trac-instance/conf/password,tracadminaccount /home/example/trac-instance/
例10-16：在screen中运行Python进程
Ctrl-A进行分离。如果希望重新连接，使用Ctrl-D。
在例10-16中，我们告诉tracd在screen中运行。
302|
编程技术（OOP）经验有限，或根本没有任何经验，那么这个示例或许会令你有一些
要理解面向对象编程，这一点非常重要。这或许会有点挑战，并且如果你对面向对象的
为了与KISS主旨相一致，让我们使用一个可能是最简单的线程示例。将模块线程化需
个web页，对服务器进行压力测试，执行网络相关的任务。
用方法，对于系统管理员每天的管理任务是非常有帮助的：网络自动发现，同时取回多
对于系统管理员，知道一些线程相关的基本编程知识也是必要的。以下是一些线程的使
说，创建追踪库在解决复杂问题时成了一个非常方便的工具。
现数据中心的SNMP发现系统时，单纯的需要去创建的线程的规模就令其很难应对。
Type"screen [-d]-r [pid.]tty.host" to resume one of them.
4797.pts-0.cent
here are several suitable screens on:
root@cent~]#screen-r
-r --single-env --auth=*,
丨第10章
(Detached)
(Detached)
www.TopSage.com
一旦进程开始运行，可以简单地使用
---
## Page 317
done with
done with stuff
done with stuff
donewithstuff
Thread #
[ngift@Macintosh-6][H:10464][3:0]> python thread1.py
#subtly bad design because of shared state
例10-17：KISS 线程示例
的方法，因为队列会处理共享状态的复杂性。参见例10-17。
一个全局计数器，这样多个线程可以共享状态。通常在使用线程时使用队列是非常不错
在众多实现方法中，这个示例有些过分简单，而且有一个不太好的设计，因为我们使用
量，然后重载线程的run方法。最后，我们发起5个线程，明确地打印他们的号码。
一步介绍。在这个简单的线程脚本中，我们从线程进行继承。线程设置一个全局计数变
因为本书是关于Python的实用技术，我们使用或许是最简单的线程示例来对线程进行进
本的OOP知识。最后需要指出的，实践OOP编程也是学习OOP的最好方式。
术。但我们建议你阅读Mark Lutz的《LearningPython》（O'Reilly)，来进一步理解一些基
Thread #
Thread#
Thread#
lass KissThread(threading.Thread):
8
importtime
importthreading
cmd_stub = 'ping -c 5 %s'
IP_LIST = [ 'google.com',
import time
#common.py
for t in range(5):
import subprocess
ironport.com'
clearink.com'
freebase.com
'yelp.com'
'yahoo.com'
5：
KissThread().start()
print "done with stuff"
1：
time.sleep(2)
count += 1
global count
1stuff
Pretending
Pretending
Pretending
Pretending
stuff
stuff
www.TopSage.com
进程与并发丨303
ODG
---
## Page 318
现在我们有等同于Hello World这样的线程，让我们实际动手来做一些让系统管理员欣赏
304
润
意：对于接下来的线程示例，需要注意的是它们是一些比较复杂的示例，
for p, ip in z:
:(xppe)8urd'op tap
#for
z =[]
import time
from common import IP_LIST, do_ping
Z.append((p, ip))
return subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE)
最有效的方法。
并发通常是出于平衡的考虑。一个模块可以适合所有的情况通常是困难的，不管它是线程
中使用subprocess.Popen是比较适合的。在演示的多个示例中，需要格外强调的是并发，
subprocess.Popen是一个非常好的选择。如果你需要与每一个进程进行通信，那么在线程
第10章
Apr
Apr
do_ping(ip)
in
in range(0,
19 06:46:58
19 06:45:57
19 06:45:57
19 06:45:57
19 06:45:57
6
6
6
6
6
6
6
6
6
6
6
906:45:57
906:45:47
06:45:47
06:45:47
06:45:47
06:45:43
06:45:43
06:45:43
06:45:43
06:45:
06:45:43
06:45:43 2008
06:45:57
06:45:47
一
06:45:47
len(IP_LIST)):
2008
2008
2008
2008
2
2008
2008
2008
2008
2008
2008
2008
2008
2008
2008
2008
2008
2008
"WAITING FOR", ip
"DOING PING FOR", addr
8ironport.com RETURNED o
WAITINGFORironport.com
3 WAITING FOR clearink.com
freebase.com RETURNED 0
WAITING FOR freebase.com
WAITING FOR amazon.com
yelp.com RETURNED 0
WAITING FOR google.com
amazon.com RETURNED 1
DOING PING FOR ironport.com
DOING PING
DOING
DOING
DOING
DOING
PI
PING
PING
ING
www.TopSage.com
GFOR
FOR
FOR
FOR
FOR
clearink.com
freebase.com
google.com
amazon.com
yelp.com
。
因为同样的事情
---
## Page 319
#!/usr/bin/env python
例10-18：线程化的 ping扫瞄
通用网络工具中的入门级工具。
的事情。略微修改示例来创建一个小的脚本来ping一个网络，并等待响应。这可以说是
当我们运行这段代码时，
print"Done”
print "Main Thread Waiting"
for ip in ips:
for i in range(num_threads):
q
def
num_threads = 3
ueue = Queue()
ueue.put(ip)
om Queue import Queue
portsubprocess
10.0.1.11: did not respond
10.0.1.3: is alive
Thread 1: Pinging 10.0.1.3
Thread o: Pinging 10.0.1.1
[ngift@Macintosh-6][H:10432][J:o]# python ping_thread _basic.py
worker.setDaemon(True)
worker = Thread(target=pinger, args=(i, queue))
Done
10.0.1.51: is alive
10.0.1.1:
while True:
q.task_done()
else:
if ret ==
print "%s: did not respond" % ip
print
is alive
0：
"10.0.1.3",
is alive" % ip
，可以看到下面的输出结果：
，"10.0.1.11", "10.0.1.51"]
，参见例10-18。
www.TopSage.com
"（.m,
进程与并发丨305
ODG
---
## Page 320
向乌鸦。
你需要在篮子中创建一个石子队列，然后分配几个工人分别从篮子中取出石子并迅速扔
你可以理解到这一问题的解决方案其实非常简单。
想象一下，你是一个生活在中世纪的农场主或科学家。你已经注意到一群乌鸦（通常称
能力。如果你发现需要使用线程，那么使用队列模块会是一个好选择。这是为什么呢？
现在，重新看看我们使用的这个简单的脚本，查看一些实现的细节。首先要去查看的事
线程将是一个理想的选择。
心中有多少个子网存在？20个？30个？50个？显然，顺序编程会很快地变得不现实，
对于网络编程非常重要的原因。现在进一步考虑一个现实的情况。在一个典型的数据中
254*（~3秒），总计12.7分钟。如果使用线程，可以缩短一些时间。这就是为什么线程
这表示如果写一个ping扫描程序，连续检查一个具有254个地址的C类网络，它会占用
态：响应状态和超时状态。一个典型的网络将是一个响应与超时的混合。
一个普通的没有使用线程的Python程序会占用N*（平均响应时间/ping）。ping有两个状
程开发一个ping扫描程序来对一个子网进行扫描，是使用线程的一个非常不错的示例。
看docstring，会看到queue.join()的声明如下：
在集中方式下，队列代表了任务。示例程序的最为重要的一部分内容是join()。如果查
钟的时间就可以向50只乌鸦扔掷石头。这在Python中是线程和队列的基本关系。你指定
使用这个新策略，如果你分配30个工人从篮子中取石子，并扔向乌鸦，你会用不到10秒
几分钟已经可以对你的庄稼造成严重破坏。如果你是一名学习数学或自然科学的学生，
子，而乌鸦的数量有时会增加到50只。为了吓走所有的乌鸦，会占用几分钟，而仅仅这
因为这些乌鸦非常聪明，通过扔石子几乎无法将他们吓走，因为你最快每3秒扔一块石
为“杀手”
内部的一个信号量进行保护了。
因为队列模块通过信号量的使用会明显减轻数据保护的需要，因为队列本身已经是通过
中所介绍的，不带队列使用线程会将它变得非常复杂，大大超出许多人可以实际操控的
情是要载入的模块，而尤其需要查看的两件事情是线程和队列。正如我们在第一个示例
这个示例值得仔细剖析，应该认真理解每一行代码，但是首先要进行一些说明。使用线
306
一组工人，当队列为空，则工作完成。
Blocks until all items in the Queue have been gotten and processed.
Docstring:
Definition:
File:
Namespace:
Queue.py
丨第10章
，原因可以咨询Wikipedia），通常20多只组成一队，攻击你的庄稼。
/System/Library/Frameworks/Python.framework/Versions/2.5/lib/python2.5/
Interactive
Queue.Queue.join(self)
www.TopSage.com
而
---
## Page 321
task_done中的docstring:
从队列中提取元素的工作。或者简单地说，工作完成了。让我们看一下Queun.Queue.
q.task_done()在while循环结束时被调用。这非常重要，因为它告诉join()已经完成
个列表中一样。这样操作允许我们取出每一个元素，直到队列为空。最后请注意，
时，这个函数会由线程执行。值得注意的是，一个新的IP地址出栈时就像它是在一
这是一个完成程序中所有工作的函数。当每一线程每次从队列中提取出一个IP地址
例，最后，ips是IP地址的列表，这些地址会最终放入到队列中：
传递给一个程序的普通值进行了硬编码。num_threads是工人线程数，queue是队列的实
在具有了线程和队列的背景知识之后，我们看一下以下几行代码。这里，我们对通常会
Original exception was:
Unhandled exception in thread started by
Main Thread Waiting
例10-19:main线程在worker线程之前退出的示例
接下来，我们看一下例10-19。
queue.join这一行：
我们的示例中，如果对queue.join()进行注释，可以看到相反的结果：首先，注释掉
Error in sys.excepthook:
到农场的比喻中，类似于当工人排队等候扔石子时，农场主扔下一篮石子离开了。在
join是防止主线程在其他线程获得机会完成队列中的任务之前从程序中退出的方式。
Docstring:
Definition:
File:
ips = ["10.0.1.1", "10.0.1.3", "10.0.1.11", "10.0.1.51"]
num_threads = 3