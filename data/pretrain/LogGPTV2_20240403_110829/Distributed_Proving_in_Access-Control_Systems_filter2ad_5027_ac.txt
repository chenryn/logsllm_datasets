prompting Alice to ask Bob to prove the original goal,
Bob says F .
In order to force the system to always terminate, we
must impose an additional constraint—a request-depth
limiter that increments a counter before each remote re-
quest, and decrements it after the request terminates. The
counter value is passed along with the request, so that
the remote prover can use the value during subsequent
requests. When the counter exceeds a preset value, the
prover will return false, thus breaking any possible cy-
cles. While it is possible that this modiﬁcation will pre-
vent the prover from discovering a proof, in practice the
depth of a proof is related to the depth of the policy, which
is bounded. Even in this environment, we would like to
show that distributed proof generation is beneﬁcial. As a
step towards this, we introduce the following lemma:
Lemma 1 A locally terminating distributed prover oper-
ating in an environment where provers use different tactic
sets, in conjunction with a request-depth limiter, will ter-
minate on any input.
Proof Sketch We construct a prover bc-ask(cid:1)
that will oper-
ate in a scenario with multiple tactic sets by removing the
else statement from Line 15 of bc-ask, causing Lines 16–
20 to be executed regardless of the outcome of Line 10.
If the request depth is greater than the maximum, Line 11
will immediately return failure. If the request depth is less
than the maximum, we use induction over the recursion
depth of bc-ask(cid:1)
to show that Lines 11 and 17 terminate,
which means that bc-ask(cid:1)
terminates. 2
Although it is necessary that a distributed prover termi-
nate when operating under multiple tactic sets, our goal
is to show that such a prover can prove a larger set of
goals than any node operating on its own. This is accom-
plished by forcing the distributed prover to attempt to lo-
cally prove any goals for which a remote request failed.
Theorem 2 A locally terminating distributed prover op-
erating in an environment where provers use different tac-
tic sets, in conjunction with a request-depth limiter, will
prove at least as many goals as it could prove without
making any requests.
Proceedings of the 2005 IEEE Symposium on Security and Privacy (S&P’05) 
1081-6011/05 $ 20.00 IEEE
University
CMU
Campus
Police
Facilities
Management
Department
Head
External Law
Enforcement
CA
CMUsigner
Facilities
Manager
Floor {1-4}
Manager
Floor {1-4}
Secretary
Networking
Manager
Smart Card
Issuer
Key Issuer
Electrical
Closets
Key Issuer's 
Office
(master key)
Key Closet 
(master key 2)
Labs
Regular Rooms
Conference
Rooms
Wiring & 
Networking
Closets
Figure 3. The authorization scheme for physical
space in Hamerschlag Hall, home of the Carnegie
Mellon Electrical & Computer Engineering Depart-
ment
Proof Sketch We deﬁne a localized prover LP to be a
prover that does not interact with other principals, and DP
to be a distributed prover as described above. We want to
show that if LP can ﬁnd a proof of a goal G, then DP can
ﬁnd a proof as well. Both LP and DP use bc-ask(cid:1)
which
we construct from bc-ask by removing the else statement
from Line 15, causing Lines 16–20 to be executed regard-
less of the outcome of Line 10. Indirectly from Lemma 1,
the call on line 11 will always terminate, which means
that lines 10–14 will terminate. If lines 10–14 produce a
solution, we are done. If lines 10–14 do not produce a
solution, DP will try to ﬁnd a solution in the same man-
ner as LP. We use induction to show that the results of
further recursive calls will be identical between the sce-
narios, which means that DP will produce a solution if LP
does. 2
5. Empirical Evaluation
To fully understand the performance of lazy proving,
we have undertaken a sizeable empirical study; we present
the results here.
We implemented our proving algorithm in Prolog, tak-
ing advantage of Prolog’s built in backchaining. We aug-
mented the prover to maintain the current network loca-
tion, and extended the deﬁnition of certiﬁcates such that
the prover may only use certiﬁcates known to its current
location. A request is recorded whenever the location of
CMU.CA.Prin1
CMU.CA.PrinX
Key1
KeyX
Dept. A Head
CMU.CA.Prin1
Dept. B Head
CMU.CA.Prin6
Floor 1 Manager
Floor 2 Manager
CMU.CA.Prin2
CMU.CA.Prin3
CMU.CA.Prin4
CMU.CA.Prin5
Figure 4. An expanded version of the authorization
scheme for Hamerschlag Hall, modiﬁed for use in an
digital access-control system
the prover changes. We note that our techniques are spe-
ciﬁc neither to prolog nor our choice of tactics and could
be implemented in other automated theorem proving en-
vironments (e.g., [20]).
5.1. Constructing a Policy
One of the difﬁculties in evaluating distributed autho-
rization systems is the lack of well-deﬁned policies with
which they can be tested.
In the absence of such poli-
cies, it is often hard to conjecture how the performance of
a system on simple example policies would relate to the
performance of the same system if used in practice.
To remedy this problem, we ﬁrst undertook to map the
physical access-control policy for rooms in our depart-
ment’s building (Figure 3). Such policies are often not
explicitly recorded, however the policy reﬂects the hierar-
chical structure of authorization in our department, which
leads us to believe that it is representative of most orga-
nizations. A close examination of this policy reveals that
it contains elements that would be superﬂuous in a digi-
tal access-control system. For example, delegation of au-
thority is conveyed either through physical tokens (the key
issuer gives a user a key) or through the organizational hi-
erarchy (the head of the department delegates to the ﬂoor
manager the responsibility of managing access to all the
rooms on a ﬂoor, but doesn’t provide him with a physi-
cal token). In a digital access-control policy, delegation
of authority is always explicitly represented; furthermore,
in the digital domain it is unnecessary to have a policy in-
clude elements, such as the Key Issuer and Smart Card Is-
suer, whose sole purpose is the distribution of physical to-
kens. At the same time, a practical digital policy requires
the mapping of keys to names. Universities typically have
a registrar’s ofﬁce that performs similar bookkeeping; we
add to the registrar the duties of a local certiﬁcation au-
thority. Another characteristic of physical access-control
Proceedings of the 2005 IEEE Symposium on Security and Privacy (S&P’05) 
1081-6011/05 $ 20.00 IEEE
s
s
e
c
c
A
r
e
p
s
t
s
e
u
q
e
R
f
o
r
e
b
m
u
N
e
g
a
r
e
v
A
 4000
 3500
 3000
 2500
 2000
 1500
 1000
 500
 0
Eager: No Cache
Eager: Positive Cache
Eager: Positive & Negative Cache
Lazy: No Cache
Lazy: Positive Cache
Lazy: Positive & Negative Cache
(1,1,1)
(2,1,1)
(2,2,10)
(2,2,2)
Authorization Tree
(2,4,10)
(2,4,30)
Tree
(1,1,1)
(2,1,1)
(2,2,2)
(2,2,10)
(2,4,10)
(2,4,30)
Tree
(1,1,1)
(2,1,1)
(2,2,2)
(2,2,10)
(2,4,10)
(2,4,30)
Eager
No Cache
Principals
Requests
STDEV
Positive &
Negative Cache
Requests
6
9
17
49
93
253
37
90
226
706
1398
3798
0
53
132.9
409.5
810.5
2196.1
20
34.5
65.5
177.5
334.5
894.5
STDEV
0
14.5
29.8
94.3
184.5
507.8
STDEV
0
11.5
20.4
48.0
88.2
226.7
Positive &
Negative Cache
Requests
Lazy
No Cache
Principals
Requests
6
9
17
49
93
253
28
61
141
397
781
2061
STDEV
0
33
80.1
227.4
450.1
1189.1
16
27.5
44.5
92.5
164
404
Figure 5. Performance of initial access with different caching strategies
policies used in practice is the difﬁculty in maintaining the
separation between users and the roles they inhabit (for
example, the role of department head and the person who
has that position). In a digital system, where delegation
of authority is always explicit, this separation is easier to
manage. Due to the importance of the university’s key,
we split it into a master key and a signing key. Figure 4
roughly illustrates our derived policy.
Ideally, we would like to simulate the deployment of
our system on a university-wide scale. However, helped
by the hierarchical organization of the university’s access-
control policy (and access-control policies in general), the
search for proofs is limited to a small subset of the over-
all population; consequently, we restrict our simulation to
several such subsets without signiﬁcantly impacting the
accuracy of our results.
We chose to structure the authorization tree from the
university to individual users as a complete tree. We de-
scribe a policy with a (j, k, l) tree to indicate that there
are j department heads, k ﬂoor managers under each de-
partment head, and l users under each ﬂoor manager. We
test our algorithms with several different (j, k, l) trees. We
chose to use complete trees for simplicity only; when sim-
ulating unbalanced trees constructed by randomly remov-
ing a ﬁxed number of nodes from a complete tree, our
results differ by less than 4% 2.
the policies protecting a
room re-
Each of
quires that
the university approve access to it (e.g.,
CMU says action(room15)). The proof that a user
may access the room is based on a chain of certiﬁ-
cates leading from CMU to the user himself. The
proof also shows which inference rules (of the logic
described in Section 3.1) need to be applied to the
2We constructed 20 unbalanced trees with 253 principals each by ran-