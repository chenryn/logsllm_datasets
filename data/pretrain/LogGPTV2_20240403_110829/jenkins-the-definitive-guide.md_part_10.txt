Directory Description
userContent You can use this directory to place your own custom content onto
your Jenkins server. You can access files in this directory at http://
myserver/hudson/userContent (if you are running Jenkins on an
application server) or http://myserver/userContent (if you are
running in stand-alone mode).
users If you are using the native Jenkins user database, user accounts will
be stored in this directory.
war This directory contains the expanded web application. When you
start Jenkins as a stand-alone application, it will extract the web
application into this directory.
Figure 3.7. The Jenkins home directory
The jobs directory is a crucial part of the Jenkins directory structure, and deserves a bit more attention.
You can see an example of a real Jenkins jobs directory in Figure 3.8, “The Jenkins jobs directory”.
61
Figure 3.8. The Jenkins jobs directory
This directory contains a subdirectory for each Jenkins build job being managed by this instance of
Jenkins. Each job directory in turn contains two subdirectories: builds and workspace, along with
some other files. In particular, it contains the build job config.xml file, which contains, as you might
expect, the configuration details for this build job. There are also some other files used internally by
Jenkins, that you usually wouldn’t touch, such as the nextBuildNumber file (which contains the
number that will be assigned to the next build in this build job), as well as symbolic links to the
most recent successful build and the last stable one. A successful build is one that does not have any
compilation errors. A stable build is a successful build that has passed whatever quality criteria you may
have configured, such as unit tests, code coverage and so forth.
Both the build and the workspace directories are important. The workspace directory is where
Jenkins builds your project: it contains the source code Jenkins checks out, plus any files generated by
the build itself. This workspace is reused for each successive build—there is only ever one workspace
directory per project, and the disk space it requires tends to be relatively stable.
The builds directory contains a history of the builds executed for this job. You rarely need to intervene
directly in these directories, but it can be useful to know what they contain. You can see a real example
of the builds directory in Figure 3.9, “The builds directory”, where three builds have been performed.
Jenkins stores build history and artifacts for each build it performs in a directory labeled with a timestamp
(“2010-03-12_20-42-05” and so forth in Figure 3.9, “The builds directory”). It also contains symbolic
links with the actual build numbers that point to the build history directories.
62
Figure 3.9. The builds directory
Each build directory contains information such as the build result log file, the Subversion revision
number used for this build (if you are using Subversion), the changes that triggered this build, and any
other data or metrics that you have asked Jenkins to keep track of. For example, if your build job keeps
track of unit test results or test coverage metrics, this data will be stored here for each build. The build
directory also contains any artifacts you are storing—binary artifacts, but also other generated files such
as javadoc or code coverage metrics. Some types of build jobs, such as the Jenkins Maven build jobs,
will also archive binary artifacts by default.
The size of the build directory will naturally grow over time, as the build history cumulates. You will
probably want to take this into account when designing your build server directory structure, especially
if your build server is running in a Unix-style environment with multiple disk partitions. A lot of this
data takes the form of text or XML files, which does not consume a large amount of extra space for each
build. However, if your build archives some of your build artifacts, such as JAR or WAR files, they
too will be stored here. The size of these artifacts should be factored into your disk space requirements.
We will see later on how to limit the number of builds stored for a particular build job if space is an
issue. Limiting the number of build jobs that Jenkins stores is always a trade-off between disk space
and keeping useful build statistics, as Jenkins does rely on this build history for its powerful reporting
features.
63
Jenkins uses the files in this directory extensively to display build history and metrics data, so you should
be particularly careful not to delete any of the build history directories without knowing exactly what
you are doing.
3.14. Backing Up Your Jenkins Data
It is important to ensure that your Jenkins data is regularly backed up. This applies in particular to the
Jenkins home directory, which contains your server configuration details as well as your build artifacts
and build histories. This directory should be backed up frequently and automatically. The Jenkins
executable itself is less critical, as it can easily be reinstalled without affecting your build environment.
3.15. Upgrading Your Jenkins Installation
Upgrading Jenkins is easy—you simply replace your local copy of the jenkins.war file and restart
Jenkins. However you should make sure there are no builds running when you restart your server. Since
your build environment configuration details, plugins, and build history are stored in the Jenkins home
directory, upgrading your Jenkins executable will have no impact on your installation. You can always
check what version of Jenkins you are currently running by referring to the version number in the bottom
right corner of every screen.
If you have installed Jenkins using one of the Linux packages, Jenkins can be upgraded using the same
process as the other system packages on the server.
If you are running Jenkins as a stand-alone instance, you can also upgrade your Jenkins installation
directly from the web interface, in the Manage Jenkins section. Jenkins will indicate if a more recent
version is available, and give you the option to either download it manually or upgrade automatically
(see Figure 3.10, “Upgrading Jenkins from the web interface”).
64
Figure 3.10. Upgrading Jenkins from the web interface
Once Jenkins has downloaded the upgrade, you can also tell it to restart when no jobs are running. This
is probably the most convenient way to upgrade Jenkins, although it will not work in all environments.
In particular, you need to be running Jenkins as a stand-alone application, and the user running Jenkins
needs to have read-write access to the jenkins.war file.
If you are running Jenkins on an application server such as Tomcat or JBoss, you might need to do a
bit more tidying up when you upgrade your Jenkins instance. Tomcat, for example, places compiled
JSP pages in the CATALINA_BASE/work directory. When you upgrade your Jenkins version, these files
need to be removed to prevent the possibility of any stale pages being served.
Any plugins you have installed will be unaffected by your Jenkins upgrades. However, plugins can also
be upgraded, independently of the main Jenkins executable. You upgrade your plugins directly in the
Jenkins web application, using the Jenkins Plugin Manager. We discuss plugins in more detail further
on in this book.
3.16. Conclusion
In this chapter, we have seen how to install and run Jenkins in different environments, and learned a few
basic tips on how to maintain your Jenkins installation once running. Jenkins is easy to install, both as a
stand-alone application and as a WAR file deployed to an existing application server. The main things
you need to consider when choosing a build server to host Jenkins are CPU, memory, and disk space.
65
Chapter 4. Configuring Your Jenkins
Server
4.1. Introduction
Before you can start creating your build jobs in Jenkins, you need to do a little configuration, to ensure
that your Jenkins server works smoothly in your particular environment. Jenkins is highly configurable,
and, although most options are provided with sensible default values, or are able to find the right build
tools in the system path and environment variables, it is always a good idea to know exactly what your
build server is doing.
Jenkins is globally very easy to configure. The administration screens are intuitive, and the contextual
online help (the blue question mark icons next to each field) is detailed and precise. In this chapter, we
will look at how to configure your basic server setup in detail, including how to configure Jenkins to
use different versions of Java, build tools such as Ant and Maven, and SCM tools such as CVS and
Subversion. We will look at more advanced server configuration, such as using other version control
systems or notification tools, further on in the book.
4.2. The Configuration Dashboard—The Manage Jenkins
Screen
In Jenkins, you manage virtually all aspects of system configuration in the Manage Jenkins screen (see
Figure 4.1, “You configure your Jenkins installation in the Manage Jenkins screen”). You can also get
to this screen directly from anywhere in the application by typing “manage” in the Jenkins search box.
This screen changes depending on what plugins you install, so don’t be surprised if you see more than
what we show here.
Figure 4.1. You configure your Jenkins installation in the Manage Jenkins screen
This screen lets you configure different aspects of your Jenkins server. Each link on this page takes you
to a dedicated configuration screen, where you can manage different parts of the Jenkins server. Some
of the more interesting options are discussed here:
Configure System
This is where you manage paths to the various tools you use in your builds, such as JDKs, and
versions of Ant and Maven, as well as security options, email servers, and other system-wide
configuration details. Many of the plugins that you install will also need to be configured here—
Jenkins will add the fields dynamically when you install the plugins.
Reload Configuration from Disk
As we saw in the previous chapter, Jenkins stores all its system and build job configuration
details as XML files stored in the Jenkins home directory (see Section 3.4, “The Jenkins Home
Directory”). It also stores all of the build history in the same directory. If you are migrating build
jobs from one Jenkins instance to another, or archiving old build jobs, you will need to add or
remove the corresponding build job directories to Jenkins’s builds directory. You don’t need
to take Jenkins offline to do this—you can simply use the “Reload Configuration from Disk”
option to reload the Jenkins system and build job configurations directly. This process can be a
little slow if there is a lot of build history, as Jenkins loads not only the build configurations but
also all of the historical data as well.
68
Manage Plugins
One of the best features of Jenkins is its extensible architecture. There is a large ecosystem of
third-party open source plugins available, enabling you to add extra features to your build server,
from support for different SCM tools such as Git, Mercurial or ClearCase, to code quality and
code coverage metrics reporting. We will be looking at many of the more popular and useful
plugins throughout this book. Plugins can be installed, updated and removed through the Manage
Plugins screen. Note that removing plugins needs to be done with some care, as it can sometimes
affect the stability of your Jenkins instance—we will look at this in more detail in Section 13.6,
“Migrating Build Jobs”.
System Information
This screen displays a list of all the current Java system properties and system environment
variables. Here, you can check exactly what version of Java Jenkins is running in, what user it
is running under, and so forth. You can also check that Jenkins is using the correct environment
variable settings. Its main use is for troubleshooting, so that you can make sure that your server
is running with the system properties and variables you think it is.
System Log
The System Log screen is a convenient way to view the Jenkins log files in real time. Again, the
main use of this screen is for troubleshooting.
You can also subscribe to RSS feeds for various levels of log messages. For example, as a Jenkins
administrator, you might want to subscribe to all the ERROR and WARNING log messages.
Load Statistics
Jenkins keeps track of how busy your server is in terms of the number of concurrent builds and
the length of the build queue (which gives an idea of how long your builds need to wait before
being executed). These statistics can give you an idea of whether you need to add extra capacity
or extra build nodes to your infrastructure.
Script Console
This screen lets you run Groovy scripts on the server. It is useful for advanced troubleshooting:
since it requires a strong knowledge of the internal Jenkins architecture, it is mainly useful for
plugin developers and the like.
Manage Nodes
Jenkins handles parallel and distributed builds well. In this screen, you can configure how many
builds you want. Jenkins runs simultaneously, and, if you are using distributed builds, set up
build nodes. A build node is another machine that Jenkins can use to execute its builds. We will
look at how to configure distributed builds in detail in Chapter 11, Distributed Builds.
Prepare for Shutdown
If you need to shut down Jenkins, or the server Jenkins is running on, it is best not to do so when
a build is being executed. To shut down Jenkins cleanly, you can use the Prepare for Shutdown
69
link, which prevents any new builds from being started. Eventually, when all of the current builds
have finished, you will be able to shut down Jenkins cleanly.
We will come back to some of these features in more detail later on in the book. In the following sections,
we will focus on how to configure the most important Jenkins system parameters.
4.3. Configuring the System Environment
The most important Jenkins administration page is the Configure System screen (Figure 4.2, “System
configuration in Jenkins”). Here, you set up most of the fundamental tools that Jenkins needs to do its
daily work. The default screen contains a number of sections, each relating to a different configuration
area or external tool. In addition, when you install plugins, their system-wide configuration is also often
done in this screen.
Figure 4.2. System configuration in Jenkins
The Configure System screen lets you define global parameters for your Jenkins installation, as well as
external tools required for your build process. The first part of this screen lets you define some general
system-wide parameters.
The Jenkins home directory is displayed, for reference. This way, you can check at a glance that you are
working with the home directory that you expect. Remember, you can change this directory by setting
the JENKINS_HOME environment variable in your environment (see Section 3.4, “The Jenkins Home
Directory”).
70
The System Message field is useful for several purposes. This text is displayed at the top of your Jenkins
home page. You can use HTML tags, so it is a simple way to customize your build server by including
the name of your server and a short blurb describing its purpose. You can also use it to display messages
for all users, such as to announce system outages and so on.
The Quiet Period is useful for SCM tools like CVS that commit file changes one by one, rather than
grouped together in a single atomic transaction. Normally, Jenkins will trigger a build as soon as it
detects a change in the source repository. However, this doesn’t suit all environments. If you are using
an SCM tool like CVS, you don’t want Jenkins kicking off a build as soon as the first change comes
in, as the repository will be in an inconsistent state until all of the changes have been committed. You
can use the Quiet Period field to avoid issues like this. If you set a value here, Jenkins will wait until
no changes have been detected for the specified number of seconds before triggering the build. This
helps to ensure that all of the changes have been committed and the repository is in a stable state before
starting the build.
For most modern version control systems, such as Subversion, Git or Mercurial, commits are atomic.
This means that changes in multiple files are submitted to the repository as a single unit, and the source
code on the repository is guaranteed to be in a stable state at all times. However, some teams still use an
approach where one logical change set is delivered in several commit operations. In this case, you can
use the Quiet Period field to ensure that the build always uses a stable source code version.
The Quiet Period value specified here is in fact the default system-wide value—if required, you can
redefine this value individually for each project.
You also manage user accounts and user rights here. By default, Jenkins lets any user do anything. If
you want a more restrictive approach, you will need to activate Jenkins security here using the Enable
Security field. There are many ways to do this, and we look at this aspect of Jenkins later on (see
Chapter 7, Securing Jenkins).
4.4. Configuring Global Properties
The Global Properties (see Figure 4.3, “Configuring environment variables in Jenkins”) section lets you
define variables that can be managed centrally but used in all of your build jobs. You can add as many
properties as you want here, and use them in your build jobs. Jenkins will make them available within
your build job environment, so you can freely use them within your Ant and Maven build scripts. Note
that you shouldn’t put periods (“.”) in the property names, as they won’t be processed correctly. So
ldapserver or ldap_server is fine, but not ldap.server.
71
Figure 4.3. Configuring environment variables in Jenkins
There are two ways you typically use these variables. Firstly, you can use them directly in your build
script, using the ${key} or $key notation (so ${ldapserver} or $ldapserver in the example give
above. This is the simplest approach, but means that there is a tight coupling between your build job
configuration and your build scripts.
If your script uses a different property name (one containing dots, for example), you can also pass the
value to your build script in the build job configuration. In Figure 4.4, “Using a configured environment
variable” we pass the ldapserver property value defined in Figure 4.3, “Configuring environment
variables in Jenkins” to a Maven build job. Using the -D option means that this value will be accessible
from within the build script. This is a flexible approach, as we can assign the global properties defined
within Jenkins to script-specific variables in our build scripts. In Figure 4.4, “Using a configured
environment variable”, for example, the ldapserver property will be available from within the Maven
build via the internal ${ldap.server} property.
Figure 4.4. Using a configured environment variable
4.5. Configuring Your JDKs
Historically, one of the most common uses of Jenkins has been to build Java applications. So Jenkins
naturally provides excellent built-in support for Java.
By default, Jenkins will build Java applications using whatever version of Java it finds on the system
path, which is usually the version that Jenkins itself is running under. However, for a production build
server, you will probably want more control than this. For example, you may be running your Jenkins
server under Java 6, for performance reasons. However, your production server might be running under
Java 5 or even Java 1.4. Large organizations are often cautious when it comes to upgrading Java versions
in their production environments, and some of the more heavyweight application servers on the market
are notoriously slow to be certified with the latest JDKs.
72
In any case, it is always a wise practice to build your application using a version of Java that is close
to the one running on your production server. While an application compiled with Java 1.4 will usually
run fine under Java 6, the inverse is not always true. Or you may have different applications that need
to be built using different versions of Java.
Jenkins provides good support for working with multiple JVMs. Indeed, Jenkins makes it very easy
to configure and use as many versions of Java as you want. Like most system-level configuration, we
do this in the Configure System screen (see Figure 4.2, “System configuration in Jenkins”). Here, you
will find a section called JDK which allows you to manage the JDK installations you need Jenkins to
work with.
The simplest way to declare a JDK installation is simply to supply an appropriate name (which will be
used to identify this Java installation later on when you configure your builds), along with the path to