# 【技术分享】Exploiting Internet Explorer 11 64-bit on Windows 8.1 Preview
|
##### 译文声明
本文是翻译文章，文章来源：ifsec
原文地址：
译文仅供参考，具体内容表达以及含义原文为准。
****
******翻译：**[ **Ox9A82**](http://bobao.360.cn/member/contribute?uid=2676915949)
**稿费：250RMB（不服你也来投稿啊！）**
******投稿方式：发送邮件至**[ **linwei#360.cn** ****](mailto:PI:EMAIL) **，或登陆**[
**网页版**](http://bobao.360.cn/contribute/index) **在线投稿**
**前言**
在今年的早些时候微软发布了几个安全奖励计划，其中的一个就是寻找在IE11中的漏洞。我参加了这次活动，并且很快找到了一个内存破坏类漏洞。尽管我相信这个漏洞是可以被利用来进行任意代码执行的，但是因为缺少时间我当时并没有写出可以利用的exp。然而，出于对新版本操作系统中全新的浏览器exp编写难度的兴趣，我决定来动手开发一个可用的exp。在这篇文章中，我将首先对这个漏洞进行一个介绍，然后在64位Windows
8.1 Preview版本上开发一个可用的exp。
当我尝试开发exp时，我并没有试图去实现一个100％可靠的exp（我的目的是在新的平台下做个试验，而不是要做一个实际的攻击武器）但是，我给自己设置了一些限制，这将使这个练习更具有挑战性：
1\. 漏洞exp的利用不应依赖于其他插件（所以没有Flash和Java），我想让它工作在默认的安装环境。
2\.
该漏洞必须能够在64位Windows上的64位IE进程中工作。使用32位IE进程其实是在作弊，因为许多漏洞缓解技术（如堆基址随机化）在32位操作系统和进程上并不生效。此外就是现在64位Windows下的exp比较少。
3\. 不组合使用其他漏洞（例如为了绕过ASLR而组合使用另一个漏洞）
关于利用64位Internet Explorer的一个事先注意事项是：在Windows
8和8.1中，当直接在桌面上运行IE时，IE的主进程是64位的，但是渲染器进程将是32位。如果使用新的接口（指windows8的触摸屏），那么两个进程都会是64位的。这一有趣的选择使得桌面版本的IE不太安全。因此在默认环境中，这里展示的exp实际上是针对IE的触摸屏版本的。
为了进行exploit的开发需要强制IE进程在桌面上也使用64位模式，我强制IE使用了单进程模式（TabProcGrowth注册表项）。但是请注意，这里仅供调试使用，如果用于浏览随机页面，它会使IE更不安全，因为它会禁用IE的沙盒模式。
**漏洞分析**
能够触发该漏洞的一个简短的poc例程如下所示
    aaaaaaaaaa aaaaaaaaaa
这是错误输出：
    (4a8.440): Access violation - code c0000005 (first chance)
    First chance exceptions are reported before any exception handling.
    This exception may be expected and handled.
    MSHTML!Layout::ContainerBox::ContainerBox+0x1e6:
    00007ff8`e0c90306 488b04d0        mov     rax,qword ptr [rax+rdx*8] ds:000000a6`e1466168=????????????????
    0:010> r
    rax=000000a6d1466170 rbx=000000a6d681c360 rcx=000000000000007f
    rdx=0000000001ffffff rsi=000000a6d5960330 rdi=00000000ffffffff
    rip=00007ff8e0c90306 rsp=000000a6d61794b0 rbp=000000a6d5943a90
    r8=0000000000000001  r9=0000000000000008 r10=00000000c0000034
    r11=000000a6d61794a0 r12=00000000ffffffff r13=00000000ffffffff
    r14=000000000000000b r15=00000000ffffffff
    iopl=0         nv up ei pl nz na pe nc
    cs=0033  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00010202
    MSHTML!Layout::ContainerBox::ContainerBox+0x1e6:
    00007ff8`e0c90306 488b04d0        mov     rax,qword ptr [rax+rdx*8] ds:000000a6`e1466168=????????????????
    0:010> k
    Child-SP          RetAddr           Call Site
    000000a6`d61794b0 00007ff8`e0e49cc0 MSHTML!Layout::ContainerBox::ContainerBox+0x1e6
    000000a6`d6179530 00007ff8`e0e554a8 MSHTML!Layout::TableGridBox::TableGridBox+0x38
    000000a6`d6179590 00007ff8`e0e553c2 MSHTML!Layout::TableGridBoxBuilder::CreateTableGridBoxBuilder+0xd8
    000000a6`d6179600 00007ff8`e0c8b720 MSHTML!Layout::LayoutBuilder::CreateLayoutBoxBuilder+0x2c9
    000000a6`d61796c0 00007ff8`e0c8a583 MSHTML!Layout::LayoutBuilderDriver::StartLayout+0x85f
    000000a6`d61798d0 00007ff8`e0c85bb2 MSHTML!Layout::PageCollection::FormatPage+0x287
    000000a6`d6179a60 00007ff8`e0c856ae MSHTML!Layout::PageCollection::LayoutPagesCore+0x2aa
    000000a6`d6179c00 00007ff8`e0c86389 MSHTML!Layout::PageCollection::LayoutPages+0x18e
    000000a6`d6179c90 00007ff8`e0c8610f MSHTML!CMarkupPageLayout::CalcPageLayoutSize+0x251
    000000a6`d6179db0 00007ff8`e0df85ca MSHTML!CMarkupPageLayout::CalcTopLayoutSize+0xd7
    000000a6`d6179e70 00007ff8`e12d472d MSHTML!CMarkupPageLayout::DoLayout+0x76
    000000a6`d6179eb0 00007ff8`e0d9de95 MSHTML!CView::EnsureView+0xcde
    000000a6`d617a270 00007ff8`e0d1c29e MSHTML!CElement::EnsureRecalcNotify+0x135
    000000a6`d617a310 00007ff8`e1556150 MSHTML!CElement::EnsureRecalcNotify+0x1e
    000000a6`d617a350 00007ff8`e1555f6b MSHTML!CElement::focusHelperInternal+0x154
    000000a6`d617a3b0 00007ff8`e19195ee MSHTML!CElement::focus+0x87
    000000a6`d617a400 00007ff8`e06ed862 MSHTML!CFastDOM::CHTMLElement::Trampoline_focus+0x52
    000000a6`d617a460 00007ff8`e06f0039 jscript9!amd64_CallFunction+0x82
    000000a6`d617a4b0 00007ff8`e06ed862 jscript9!Js::JavascriptExternalFunction::ExternalFunctionThunk+0x154
    000000a6`d617a550 00007ff8`e06f26ff jscript9!amd64_CallFunction+0x82
从上面可以看出，IE进程崩溃在MSHTML!Layout:ContainerBox:ContainerBox函数中，因为试图读取rax + rdx *
8指向的未初始化内存。rax实际上是指向一个CFormatCache对象的内存，而rdx（0x0000000001ffffff）的值是很有趣的。所以我查看了ContainerBox：ContainerBox函数的代码，想看看这个值是从哪里来的，以及如果攻击者控制了rax
+ 0xffffff8处的内存之后可以做什么。
    00007ffb`dac00145 83cdff          or      ebp,0FFFFFFFFh
    ...
    00007ffb`dac0023e 440fb64713      movzx   r8d,byte ptr [rdi+13h]
    00007ffb`dac00243 410fb6c0        movzx   eax,r8b
    00007ffb`dac00247 c0e805          shr     al,5
    00007ffb`dac0024a 2401            and     al,1
    00007ffb`dac0024c 0f84048f6200    je      MSHTML!Layout::ContainerBox::ContainerBox+0x562 (00007ffb`db229156)
    00007ffb`dac00252 440fb76f68      movzx   r13d,word ptr [rdi+68h]
    ...
    00007ffb`db229156 448bed          mov     r13d,ebp
    00007ffb`db229159 e9f9709dff      jmp     MSHTML!Layout::ContainerBox::ContainerBox+0x137 (00007ffb`dac00257)
    ...
    00007ffb`dac002db 410fbffd        movsx   edi,r13w
    ...
    00007ffb`dac002fb 8bcf            mov     ecx,edi
    00007ffb`dac002fd 8bd7            mov     edx,edi
    00007ffb`dac002ff 48c1ea07        shr     rdx,7
    00007ffb`dac00303 83e17f          and     ecx,7Fh
    00007ffb`dac00306 488b04d0        mov     rax,qword ptr [rax+rdx*8] ds:0000007a`390257f8=????????????????
    00007ffb`dac0030a 488d0c49        lea     rcx,[rcx+rcx*2]
    00007ffb`dac0030e 488d14c8        lea     rdx,[rax+rcx*8]
    00007ffb`dac00312 8b4cc810        mov     ecx,dword ptr [rax+rcx*8+10h]
    00007ffb`dac00316 8b420c          mov     eax,dword ptr [rdx+0Ch]
    00007ffb`dac00319 3bc8            cmp     ecx,eax
    00007ffb`dac0031b 0f83150d7500    jae     MSHTML!Layout::ContainerBox::ContainerBox+0x750f16 (00007ffb`db351036)
    00007ffb`dac00321 ffc0            inc     eax
    00007ffb`dac00323 89420c          mov     dword ptr [rdx+0Ch],eax
崩溃时rdx的值是由ebp值经过几次赋值之后得来的，ebp在函数开头部分被初始化为0xFFFFFFFF（注意，ebp/rbp在这里不用作栈指针）。我的假设是，值0xFFFFFFFF（-1）是用作CFormatCache索引变量的初始值的。在稍后的代码中，获取了一个指向CTreeNode对象的指针，然后检查CTreeNode中的标志，如果它被设置，则从CTreeNode对象中复制索引值。然而，如果未设置标志（如PoC中的情况），则使用初始值。值0xFFFFFFFF然后被分成上下两部分（CFormatCache看起来像是一个2个DWORD值的数组）。较高索引（将等于0x1ffffff）的值将乘以8（void
*的大小），然后将此偏移量加到rax，并将此内存位置处的内容写回到rax。然后，让索引低位（将为0x7f）的值乘以24（可能是CCharFormat元素的大小），并将该偏移量加到eax，然后将此内存位置的内容写入rdx。最后，这是与利用相关的部分：取出[rdx
+ 0C]处的数字，自增之后再写回[rdx + 0C]
用C++描述会简化一些，相关的代码会是这样的：
    int cacheIndex = -1;
    if(treeNode->flag) {
      cacheIndex = treeNode->cacheIndex;
    } 
    unsigned int index_hi = cacheIndex, index_lo = cacheIndex;
    index_hi = index_hi >> 7;
    index_lo = index_lo & 0x7f;
    //with sizeof(formatCache[i]) == 8 and sizeof(formatCache[i][j]) == 24
    formatCache[index_hi][index_lo].some_number++;
出于实际利用的目的，情况是这样的：一个指向有效内存（CFormatCache指针）的指针会增加0x0FFFFFF8（256M）的大小，并且相加得到的地址的值会被当作另一个指针来处理。让我们调用地址（CFormatCache地址+0x0FFFFFF8）P1和它指向的指针P2。在P2+0xBF4处的DWORD值将被加1（注意，0xBF4的值是这么来的：0x7F
* 3 * 8 + 0x0C）。
**漏洞利用**
如果我们是在为一个32位的进程编写一个exp，那么一个直接（但不是很优雅）的方法是利用堆喷射来喷射出一个32位的地址，使得当0xBF4与它相加之后的地址上存在有趣的东西（例如字符串或数组长度）。这个所谓的“有趣的东西”可以通过另一个堆喷射来进行布局。
然而这个exp是针对具有全ASLR保护的64位进程编写的，因此我们不知道或者不能够猜测到“有趣”对象的地址。我们当然不会去填充64位进程的地址空间，因为堆基址将被随机化从而使得堆上对象的地址不可预测。
**堆喷射**
然而，即使在这种情况下，堆喷射仍然可用于漏洞利用的第一部分。注意，当触发漏洞时，P1会被计算为有效堆地址加0x0FFFFFF8（256M）的值。如果我们进行堆喷，来分配相对于堆基地址的内存。通过喷射大约256M的内存，我们可以将P2设置为任意值。
总而言之，尽管64位进程和堆地址随机化中的地址空间明显更大，但是在脆弱的程序对堆基地址+一个大偏移处的内存进行解引用的时候，堆喷射仍然有效。而且这是越界访问漏洞的典型行为，所以很常见。除了这里讨论的这个漏洞之外，以前我写过exp的IE漏洞也有这种表现。