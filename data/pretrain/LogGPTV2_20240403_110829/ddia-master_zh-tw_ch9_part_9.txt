[^x]: 从形式上讲，线性一致读写暂存器是一个 “更容易” 的问题。全序广播等价于共识【67】，而共识问题在非同步的崩溃 - 停止模型【68】中没有确定性的解决方案，而线性一致的读写暂存器 **可以** 在这种模型中实现【23,24,25】。然而，支援诸如 **比较并设定（CAS, compare-and-set）**，或 **自增并返回（increment-and-get）** 的原子操作使它等价于共识问题【28】。因此，共识问题与线性一致暂存器问题密切相关。
全序广播是非同步的：讯息被保证以固定的顺序可靠地传送，但是不能保证讯息 **何时** 被送达（所以一个接收者可能落后于其他接收者）。相比之下，线性一致性是新鲜性的保证：读取一定能看见最新的写入值。
但如果有了全序广播，你就可以在此基础上构建线性一致的储存。例如，你可以确保使用者名称能唯一标识使用者帐户。
设想对于每一个可能的使用者名称，你都可以有一个带有 CAS 原子操作的线性一致暂存器。每个暂存器最初的值为空值（表示未使用该使用者名称）。当用户想要建立一个使用者名称时，对该使用者名称的暂存器执行 CAS 操作，在先前暂存器值为空的条件，将其值设定为使用者的账号 ID。如果多个使用者试图同时获取相同的使用者名称，则只有一个 CAS 操作会成功，因为其他使用者会看到非空的值（由于线性一致性）。
你可以透过将全序广播当成仅追加日志【62,63】的方式来实现这种线性一致的 CAS 操作：
1. 在日志中追加一条讯息，试探性地指明你要宣告的使用者名称。
2. 读日志，并等待你刚才追加的讯息被读回。[^xi]
4. 检查是否有任何讯息声称目标使用者名称的所有权。如果这些讯息中的第一条就是你自己的讯息，那么你就成功了：你可以提交声称的使用者名称（也许是透过向日志追加另一条讯息）并向客户端确认。如果所需使用者名称的第一条讯息来自其他使用者，则中止操作。
[^xi]: 如果你不等待，而是在讯息入队之后立即确认写入，则会得到类似于多核 x86 处理器记忆体的一致性模型【43】。该模型既不是线性一致的也不是顺序一致的。
由于日志项是以相同顺序送达至所有节点，因此如果有多个并发写入，则所有节点会对最先到达者达成一致。选择冲突写入中的第一个作为胜利者，并中止后来者，以此确定所有节点对某个写入是提交还是中止达成一致。类似的方法可以在一个日志的基础上实现可序列化的多物件事务【62】。
尽管这一过程保证写入是线性一致的，但它并不保证读取也是线性一致的 —— 如果你从与日志非同步更新的储存中读取资料，结果可能是陈旧的。（精确地说，这里描述的过程提供了 **顺序一致性（sequential consistency）**【47,64】，有时也称为 **时间线一致性（timeline consistency）**【65,66】，比线性一致性稍微弱一些的保证）。为了使读取也线性一致，有几个选项：
* 你可以透过在日志中追加一条讯息，然后读取日志，直到该讯息被读回才执行实际的读取操作。讯息在日志中的位置因此定义了读取发生的时间点（etcd 的法定人数读取有些类似这种情况【16】）。
* 如果日志允许以线性一致的方式获取最新日志讯息的位置，则可以查询该位置，等待该位置前的所有讯息都传达到你，然后执行读取。（这是 Zookeeper `sync()` 操作背后的思想【15】）。
* 你可以从同步更新的副本中进行读取，因此可以确保结果是最新的（这种技术用于链式复制（chain replication）【63】；请参阅 “[关于复制的研究](ch5.md#关于复制的研究)”）。
#### 使用线性一致性储存实现全序广播
上一节介绍了如何从全序广播构建一个线性一致的 CAS 操作。我们也可以把它反过来，假设我们有线性一致的储存，接下来会展示如何在此基础上构建全序广播。
最简单的方法是假设你有一个线性一致的暂存器来储存一个整数，并且有一个原子 **自增并返回** 操作【28】。或者原子 CAS 操作也可以完成这项工作。
该演算法很简单：每个要透过全序广播发送的讯息首先对线性一致暂存器执行 **自增并返回** 操作。然后将从暂存器获得的值作为序列号附加到讯息中。然后你可以将讯息传送到所有节点（重新发送任何丢失的讯息），而收件人将按序列号依序传递（deliver）讯息。
请注意，与兰伯特时间戳不同，透过自增线性一致性暂存器获得的数字形式上是一个没有间隙的序列。因此，如果一个节点已经发送了讯息 4 并且接收到序列号为 6 的传入讯息，则它知道它在传递讯息 6 之前必须等待讯息 5 。兰伯特时间戳则与之不同 —— 事实上，这是全序广播和时间戳排序间的关键区别。
实现一个带有原子性 **自增并返回** 操作的线性一致暂存器有多困难？像往常一样，如果事情从来不出差错，那很容易：你可以简单地把它储存在单个节点内的变数中。问题在于处理当该节点的网路连线中断时的情况，并在该节点失效时能恢复这个值【59】。一般来说，如果你对线性一致性的序列号生成器进行过足够深入的思考，你不可避免地会得出一个共识演算法。
这并非巧合：可以证明，线性一致的 CAS（或自增并返回）暂存器与全序广播都等价于 **共识** 问题【28,67】。也就是说，如果你能解决其中的一个问题，你可以把它转化成为其他问题的解决方案。这是相当深刻和令人惊讶的洞察！
现在是时候正面处理共识问题了，我们将在本章的其余部分进行讨论。
## 分散式事务与共识
**共识** 是分散式计算中最重要也是最基本的问题之一。从表面上看似乎很简单：非正式地讲，目标只是 **让几个节点达成一致（get serveral nodes to agree on something）**。你也许会认为这不会太难。不幸的是，许多出故障的系统都是因为错误地轻信这个问题很容易解决。
尽管共识非常重要，但关于它的内容出现在本书的后半部分，因为这个主题非常微妙，欣赏细微之处需要一些必要的知识。即使在学术界，对共识的理解也是在几十年的过程中逐渐沉淀而来，一路上也有著许多误解。现在我们已经讨论了复制（[第五章](ch5.md)），事务（[第七章](ch7.md)），系统模型（[第八章](ch8.md)），线性一致以及全序广播（本章），我们终于准备好解决共识问题了。
节点能达成一致，在很多场景下都非常重要，例如：
* 领导选举
  在单主复制的资料库中，所有节点需要就哪个节点是领导者达成一致。如果一些节点由于网路故障而无法与其他节点通讯，则可能会对领导权的归属引起争议。在这种情况下，共识对于避免错误的故障切换非常重要。错误的故障切换会导致两个节点都认为自己是领导者（**脑裂**，请参阅 “[处理节点宕机](ch5.md#处理节点宕机)”）。如果有两个领导者，它们都会接受写入，它们的资料会发生分歧，从而导致不一致和资料丢失。
* 原子提交
  在支援跨多节点或跨多分割槽事务的资料库中，一个事务可能在某些节点上失败，但在其他节点上成功。如果我们想要维护事务的原子性（就 ACID 而言，请参阅 “[原子性](ch7.md#原子性)”），我们必须让所有节点对事务的结果达成一致：要么全部中止 / 回滚（如果出现任何错误），要么它们全部提交（如果没有出错）。这个共识的例子被称为 **原子提交（atomic commit）** 问题 [^xii]。
  [^xii]: 原子提交的形式化与共识稍有不同：原子事务只有在 **所有** 参与者投票提交的情况下才能提交，如果有任何参与者需要中止，则必须中止。共识则允许就 **任意一个** 被参与者提出的候选值达成一致。然而，原子提交和共识可以相互简化为对方【70,71】。**非阻塞** 原子提交则要比共识更为困难 —— 请参阅 “[三阶段提交](#三阶段提交)”。
> ### 共识的不可能性
>
> 你可能已经听说过以作者 Fischer，Lynch 和 Paterson 命名的 FLP 结果【68】，它证明，如果存在节点可能崩溃的风险，则不存在 **总是** 能够达成共识的演算法。在分散式系统中，我们必须假设节点可能会崩溃，所以可靠的共识是不可能的。然而这里我们正在讨论达成共识的演算法，到底是怎么回事？