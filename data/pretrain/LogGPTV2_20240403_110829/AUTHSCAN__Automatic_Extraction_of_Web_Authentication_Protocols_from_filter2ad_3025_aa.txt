title:AUTHSCAN: Automatic Extraction of Web Authentication Protocols from
Implementations
author:Guangdong Bai and
Jike Lei and
Guozhu Meng and
Sai Sathyanarayan Venkatraman and
Prateek Saxena and
Jun Sun and
Yang Liu and
Jin Song Dong
AUTHSCAN: Automatic Extraction of Web Authentication Protocols
from Implementations‚àó
Guangdong Bai(cid:63), Jike Lei(cid:63), Guozhu Meng(cid:63), Sai Sathyanarayan Venkatraman(cid:63),
Prateek Saxena(cid:63), Jun Sun‚Ä†, Yang Liu‚Ä°, and Jin Song Dong(cid:63)
‚Ä†Singapore University of Technology and Design
‚àóNational University of Singapore
‚Ä°Nanyang Technological University
Abstract
Ideally, security protocol implementations should be for-
mally veriÔ¨Åed before they are deployed. However, this is
not true in practice. Numerous high-proÔ¨Åle vulnerabilities
have been found in web authentication protocol implemen-
tations, especially in single-sign on (SSO) protocols imple-
mentations recently. Much of the prior work on authentica-
tion protocol veriÔ¨Åcation has focused on theoretical foun-
dations and building scalable veriÔ¨Åcation tools for checking
manually-crafted speciÔ¨Åcations [17, 18, 44].
In this paper, we address a complementary prob-
lem of automatically extracting speciÔ¨Åcations from im-
plementations. We propose AUTHSCAN, an end-to-end
platform to automatically recover authentication protocol
speciÔ¨Åcations from their implementations. AUTHSCAN
Ô¨Ånds a total of 7 security vulnerabilities using off-the-shelf
veriÔ¨Åcation tools in speciÔ¨Åcations it recovers, which include
SSO protocol implementations and custom web authentica-
tion logic of web sites with millions of users.
1
Introduction
Web authentication mechanisms evolve fast. Many web
sites implement their own authentication protocols and rely
on third-party mechanisms to manage their authentication
logic. For example, recent single-sign on (SSO) mecha-
nisms (e.g., Facebook Connect, SAML-based SSO, OpenID
and BrowserID) have formed the basis of managing user
identities in commercial web sites and mobile applications.
For example, OpenID currently manages over one billion
user accounts and has been adopted by over 50,000 web
sites, including many well-known ones such as Google,
Facebook and Microsoft [5]. As another example, Face-
book Connect is employed by 2 million web sites and more
‚àóPrateek Saxena, Jun Sun and Yang Liu have contributed equally to this
work.
than 250 million people reportedly use it every month as of
2011 [7]. Ideally, authentication protocols should be for-
mally veriÔ¨Åed prior to their implementations. However,
majority of web sites do not follow this principle. Au-
thentication protocols have historically been hard to design
correctly and implementations have been found susceptible
to logical Ô¨Çaws [31, 41]. Web authentication protocols are
no exception‚Äîseveral of these implementations have been
found insecure in post-deployment analysis [16, 29, 39, 42].
There are three key challenges in ensuring that appli-
cations authenticate and federate user identities securely.
First, most prior protocol veriÔ¨Åcation work has focused on
checking the high-level protocol speciÔ¨Åcations, not their
implementations [13,21,44]. In practice, however, checking
implementations is difÔ¨Åcult due to lack of complete infor-
mation, such as missing source code of some protocol par-
ticipants. Second, verifying authentication using off-the-
shelf tools requires expert knowledge and, in most prior
work, conversion of authentication protocol speciÔ¨Åcations
to veriÔ¨Åcation tools has been done manually. However, sev-
eral custom authentication protocols are undocumented. As
new protocols emerge and the implementations of existing
protocols evolve, manual translation of every new proto-
col becomes infeasible. Moreover, manual translation is
tedious and can be error-prone. Finally, the authentication
of the communication between protocol participants often
goes beyond the initial establishment of authentication to-
kens, which the high-level speciÔ¨Åcations dictate. In prac-
tice, checking the end-to-end authentication of communica-
tion involves checking if the authentication tokens are ac-
tually used in all subsequent communications and making
sure they are not sent on public communication channels
or stored in persistent devices from which they can leak.
Techniques to address these practical problems of existing
implementations are an important area which has received
relatively lesser attention.
Our Approach.
In this paper, we present a frame-
work called AUTHSCAN to automatically extract the formal
speciÔ¨Åcations of authentication protocols from their imple-
mentations. Then, these speciÔ¨Åcations are directly checked
for authentication and secrecy properties using off-the-shelf
veriÔ¨Åcation tools [10, 18, 22]. AUTHSCAN can automati-
cally conÔ¨Årm the candidate attacks generated by the ver-
iÔ¨Åcation tools and report the true positives (conÔ¨Årmed at-
tacks) in most cases we study. In some cases, AUTHSCAN
does not know the attacker‚Äôs knowledge set enough to gen-
erate conÔ¨Årmed attacks ‚Äî in such cases, it generates secu-
rity warnings containing precise communication tokens that
need to be manually reviewed by the security analyst.
We design an intermediate language TML to bridge the
gap between the detailed implementation of an authentica-
tion protocol and its high level semantics that can be used
by the veriÔ¨Åcation tools. We show that TML is sufÔ¨Åcient
to capture the communications between protocol partici-
pants and their internal actions. AUTHSCAN assumes no
knowledge of the protocol being inferred and does not re-
quire the full source code of the implementation. We pro-
pose a reÔ¨Ånement method to deal with partial availability
of the code implementing the protocol (e.g., if the code
located on a web server is not available).
It starts with
an initial abstraction of the protocol speciÔ¨Åcation, and it-
eratively reÔ¨Ånes the abstraction until it reaches a Ô¨Åxpoint.
To perform this reÔ¨Ånement, we propose a novel hybrid in-
ference approach to combine a whitebox program analysis
with a blackbox differential fuzzing analysis. In particular,
the whitebox analysis performs dynamic symbolic analysis
on the available code to extract precise data semantics and
the internal actions of the protocol participants. The black-
box analysis infers the protocol implementation by prob-
ing the protocol participants and comparing the changes in
their response. Our Ô¨Ånal inferred speciÔ¨Åcation in TML can
be directly translated into modeling languages used by off-
the-shelf veriÔ¨Åcation tools and can be conÔ¨Ågured to verify
against a variety of attacker models [17, 24].
Our techniques focus on recovering as much protocol se-
mantics as possible from dynamic executions of the proto-
col; we do not aim to Ô¨Ånd complete speciÔ¨Åcations. Instead,
we aim to recover fragments of the protocol with enough
precision to Ô¨Ånd interesting logic Ô¨Çaws. We apply AUTH-
SCAN to study several real-world web sites, including three
popular SSO protocols ‚Äî Facebook Connect Protocol (2
web sites), Browser ID (3 web sites) and Windows Live
Messenger Connect (1 web site). We also test several stan-
dalone web sites which implement their custom authentica-
tion logic and have millions of users sharing personal in-
formation. AUTHSCAN successfully recovers precise (but
partial) models of their authentication logic, and formally
veriÔ¨Åes their authentication and secrecy properties against
a broad range of attacker models. We have found 7 se-
curity Ô¨Çaws in these implementations without their prior
knowledge‚Äîone of these was found independently by a
concurrent work [33] and the remaining are previously un-
known. In particular, we Ô¨Ånd two Ô¨Çaws in Facebook Con-
nect Protocol and one Ô¨Çaw in BrowserID, which arise be-
cause the freshness of messages is not guaranteed in the
protocol implementations. An attacker is thus able to perpe-
trate replay attacks to acquire unauthorized authentication
credentials. Several other vulnerabilities are due to unsafe
implementation errors in creating and maintaining secrecy
of authentication tokens. For example, we Ô¨Ånd that a web
site employing Windows Live Messenger Connect grants
the end user a publicly known value as a credential after the
user has been authenticated to Windows Live.
Contributions. We make the following main contributions
in this paper:
‚Ä¢ Automatic Extraction Techniques. We propose au-
tomatic techniques to extract the authentication pro-
tocol speciÔ¨Åcations from their implementations. Our
approach works with only minimal number of user in-
puts (Section 2.3) and reasonable assumptions (Sec-
tion 3.2), without requiring any knowledge of the pro-
tocol. Our techniques gracefully adjust the precision of
the inferred protocol based on how much source code
implementing the protocol is visible to the analysis.
‚Ä¢ End-to-end System. We build AUTHSCAN, an end-
to-end system that embodies these techniques. AUTH-
SCAN is designed to be extensible and conÔ¨Ågurable‚Äî
it can utilize several off-the-shelf veriÔ¨Åcation tools
(ProVerif [18] or PAT [38]), and can be extended to
model different attack models.
‚Ä¢ Practical Results. We apply our approach to several
real-world web sites, including several using impor-
tant SSO protocols like Facebook Connect Protocol,
BrowserID and Windows Live Messenger Connect.
We successfully Ô¨Ånd 7 security Ô¨Çaws in their imple-
mentations.
2 Challenges & Overview
Security analysts often need to guarantee the correctness
of authentication protocol implementations without having
complete access to the source code. In this section, we ex-
plain the problem and its challenges with an example.
2.1 A Running Example
Consider one execution of a hypothetical single-sign on
(SSO) protocol (similar to Facebook Connect) as shown
in Figure 1-(a). In our example, Alice wants to authenti-
cate herself to a service provider (SP) web site hosted at
sp.com by using her login credentials with an identity
provider (IDP) hosted at idp.com1. This example shows
1One sample IDP is facebook.com in Facebook Connect and one
sample SP is cnn.com which uses the Facebook Connect protocol.
Figure 1: An SSO example: Alice authenticates herself to the SP (sp.com) by using her login credentials with the IDP (idp.com). The
circled numbers indicate the login process, and the capital letters stand for client code.
that much of the communication between the IDP and the
SP occurs through the web browser (using postMessage
between client-side iframes), which is similar to real-
world protocols [27, 42]. This enables security analysts to
analyze protocol behaviors.
The authentication protocol, which the security analyst
aims to infer, is as follows:
‚Ä¢ Step x: When Alice visits the SP‚Äôs site and initiates
the intent to authenticate, the client-side SP code sends
the pre-registered ID and domain of the SP to the IDP‚Äôs
iframe. The fact that each SP is pre-registered with
the IDP is not known to the security analyst by observ-
ing this protocol execution.
‚Ä¢ Step y: Assuming that Alice has already logged into
the IDP, the IDP generates an HTTP request to its
backend server. The request contains a nonce (anti-
CSRF) and the session ID of Alice‚Äôs ongoing web ses-
sion with the IDP.
‚Ä¢ Step z: The IDP replies with Alice‚Äôs registered
email identity uEmail and an authentication token
authToken, which authorizes all access to Alice‚Äôs
personal information stored at the IDP. The IDP cre-
ates a cryptographic signature over the terms uEmail
and authToken as an authentication credential to be
veriÔ¨Åed by the SP.
‚Ä¢ Step {: Client-side IDP code (code A in Figure 1-(c))
relays the HTTP data received in step z to the SP‚Äôs
iframe.
‚Ä¢ Step |: Client-side SP code (code B in Figure 1-
(c)) veriÔ¨Åes that the signature is valid and extracts the
uEmail and authToken. The SP‚Äôs iframe sends
Alice‚Äôs identity and authToken back to the SP‚Äôs
server. This allows the SP‚Äôs server to access Alice‚Äôs in-
formation stored at the IDP, and allows the IDP to log
all SP‚Äôs actions on Alice‚Äôs data for audit (not shown).
The security analyst can only observe the network trafÔ¨Åc
and code execution at the browser end; the server-side logic
of the protocol participants is not available for analysis.
Security Flaws. The protocol has several vulnerabilities.
We only describe three of them and they can be found auto-
matically if the protocol can be inferred precisely:
‚Ä¢ Man-in-the-middle (MITM) Attack. The proto-
col is susceptible to several MITM attacks by a web
attacker.
For example, consider the target of the
postMessage call in the client-side code (line 19).
This target is derived from an HTTP parameter called
next (at line 2 of Figure 1-(c)). A malicious SP, say
Eve, can change the next parameter to its own do-
main, leaving the spid parameter as it is. In this at-
tack, the token granted to the sp.com is actually sent
to Eve by code labeled as A in step {. This attack is
Browser            www.sp.com/login www.idp.com/login ‚ë† IDP/login server 1 2 3 4 5 6 7 8 GET    https://www.idp.com/login?spid=SID&spDomain=sp.             com&redirect_url=http://www.idp.com/granter?next=            http:// www.sp.com/login Host: www.idp.com Referer: https://www.idp.com/login Cookie: sessionID=0x12345678  ----------------------------------------                CSRFtoken=sLd2f93 9 10 11 12 13 14 15 16 17 18 19 20 HTTP/1.1 200 Set-Cookie: cookie1=87654321; domain=.idp.com     ----------------------------------------    21 22 23 24 25 26 27 28 29 30 31 window.addEventListener('message',function(event) {     var uEmail=extractUser(event.data);     var authToken=extractToken(event.data);     var idpSign=extractSign(event.data);     var data=uEmail+"&"+authToken;     var idpPubKey=loadPubKey();     if(verify(data, idpSign, idpPubKey)){          var message=uEmail+"&" +authToken;          var request = $.ajax({url: login, data: { token: message}});}     else     {‚Ä¶}},false); B SP server A ‚ë£ B ‚ë° ‚ë¢ ‚ë§ ‚ë° ‚ë¢ A ‚ë† SP_C     IDP_C spid, spDomain, next ‚ë° IDP_C   IDP_S spid, spDomain, sessionID, CSRFToken ‚ë¢ IDP_S   IDP_C uEmail, authToken, {uEmail, authToken} ‚ë£ IDP_C   SP_C                   (next) uEmail, authToken, {uEmail, authToken} ‚ë§ SP_C   SP_S uEmail, authToken ùëòùêºùê∑ùëÉ‚àí1 ùëòùêºùê∑ùëÉ‚àí1 (a)  The process of Alice authenticates herself to the SP though the IDP (b) Communication actions of the participants (IDP_C: IDP client code, IDP_S: IDP server, SP_C: SP client code, SP_S: SP server) (c)Parts of exchanged HTTP message and client code similar to a recently reported real-world attack on the
site zoho.com employing Facebook Connect [42].
‚Ä¢ Replay Attack. The protocol is susceptible to a replay
attack, as the IDP‚Äôs server does not use any nonce or
timestamp to guarantee the freshness of the authentica-
tion token authToken. If a malicious SP obtains the
signed assertion in step {, it can replay the message to
sp.com in a new web session and log in as Alice.
‚Ä¢ Guessable Tokens. Even if the authentication to-
ken is kept secret by carefully using only secure (pri-
vate) communication channels, additional problems
can exist. For example, authToken remains constant
across all of Alice‚Äôs sessions, which is not apparent
from observing a single protocol run. We refer to such
tokens as long-lived tokens. Long-lived tokens may
be used in replay attacks. Similarly, if the IDP uses
a weak or guessable scheme to generate authentication
tokens, such as a sequentially incrementing counter, an
attacker can precisely guess the tokens used in other
web sessions.
2.2 Challenges
This example shows that implementation-dependent se-
curity properties need to be checked in real web applica-
tions, where the formal speciÔ¨Åcations are required. In the
following, we list a number of practical challenges in infer-
ring speciÔ¨Åcations from their implementations.
Inferring Semantics. A key challenge is to infer the precise
semantics of data elements exchanged in the communica-
tion. For example, it is important to know that authToken
remains constant across all of Alice‚Äôs sessions with the IDP
and does not include a nonce or a timestamp. Inferring this
information is critical to discover the replay attack in the
protocol. Similarly, identifying that the communication tar-
get in { is not a Ô¨Åxed domain but instead a variable de-
rived from the HTTP parameter next is crucial to Ô¨Ånd the
MITM attack. These semantics are not obvious from the
values observed in one message or even in one execution of
the protocol.
Partial Code. Only the part of the protocol implementa-
tion that executes in the web browser is visible for analy-
sis. For instance, we can infer using whitebox analysis over
the client-side code that idpSign is a cryptographic signa-