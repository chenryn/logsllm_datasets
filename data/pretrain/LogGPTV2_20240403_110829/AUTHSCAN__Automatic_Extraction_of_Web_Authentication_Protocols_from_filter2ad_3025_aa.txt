# AUTHSCAN: Automatic Extraction of Web Authentication Protocols from Implementations

## Authors
Guangdong Bai, Jike Lei, Guozhu Meng, Sai Sathyanarayan Venkatraman, Prateek Saxena, Jun Sun, Yang Liu, and Jin Song Dong

### Affiliations
- Guangdong Bai, Jike Lei, Guozhu Meng, Sai Sathyanarayan Venkatraman, Prateek Saxena, and Jin Song Dong: National University of Singapore
- Jun Sun: Singapore University of Technology and Design
- Yang Liu: Nanyang Technological University

## Abstract
Ideally, security protocol implementations should be formally verified before deployment. However, in practice, this is often not the case. Numerous high-profile vulnerabilities have been discovered in web authentication protocol implementations, particularly in single-sign on (SSO) protocols. Much of the prior work on authentication protocol verification has focused on theoretical foundations and building scalable verification tools for manually crafted specifications.

In this paper, we address the complementary problem of automatically extracting specifications from implementations. We introduce AUTHSCAN, an end-to-end platform designed to automatically recover authentication protocol specifications from their implementations. AUTHSCAN identifies a total of 7 security vulnerabilities using off-the-shelf verification tools in the specifications it recovers, including SSO protocol implementations and custom web authentication logic used by websites with millions of users.

## 1. Introduction
Web authentication mechanisms are rapidly evolving. Many websites implement their own authentication protocols and rely on third-party mechanisms to manage their authentication logic. For example, recent SSO mechanisms such as Facebook Connect, SAML-based SSO, OpenID, and BrowserID form the basis of managing user identities in commercial websites and mobile applications. OpenID currently manages over one billion user accounts and is adopted by over 50,000 websites, including well-known ones like Google, Facebook, and Microsoft. Similarly, Facebook Connect is employed by 2 million websites, with over 250 million people reportedly using it every month as of 2011.

Ideally, authentication protocols should be formally verified before implementation. However, many websites do not follow this principle. Authentication protocols have historically been difficult to design correctly, and their implementations have been found to be susceptible to logical flaws. Several web authentication protocol implementations have been found insecure in post-deployment analysis.

There are three key challenges in ensuring that applications authenticate and federate user identities securely:
1. Most prior protocol verification work has focused on checking high-level protocol specifications, not their implementations. In practice, checking implementations is difficult due to incomplete information, such as missing source code of some protocol participants.
2. Verifying authentication using off-the-shelf tools requires expert knowledge, and in most prior work, the conversion of authentication protocol specifications to verification tools has been done manually. This process is tedious and error-prone, especially for undocumented custom authentication protocols.
3. The authentication of communication between protocol participants often extends beyond the initial establishment of authentication tokens, which the high-level specifications dictate. In practice, checking the end-to-end authentication of communication involves verifying that authentication tokens are used in all subsequent communications and ensuring they are not sent over public channels or stored in persistent devices where they can leak.

### Our Approach
In this paper, we present AUTHSCAN, a framework to automatically extract formal specifications of authentication protocols from their implementations. These specifications are then directly checked for authentication and secrecy properties using off-the-shelf verification tools. AUTHSCAN can automatically confirm candidate attacks generated by the verification tools and report true positives in most cases. In cases where the attacker's knowledge set is insufficient, AUTHSCAN generates security warnings containing precise communication tokens that need manual review by a security analyst.

We design an intermediate language, TML, to bridge the gap between the detailed implementation of an authentication protocol and its high-level semantics. TML is sufficient to capture the communications between protocol participants and their internal actions. AUTHSCAN assumes no prior knowledge of the protocol being inferred and does not require the full source code of the implementation. We propose a refinement method to handle partial availability of the code implementing the protocol. This method starts with an initial abstraction of the protocol specification and iteratively refines the abstraction until it reaches a fixpoint.

To perform this refinement, we propose a novel hybrid inference approach combining whitebox program analysis with blackbox differential fuzzing analysis. The whitebox analysis performs dynamic symbolic analysis on the available code to extract precise data semantics and internal actions of the protocol participants. The blackbox analysis infers the protocol implementation by probing the protocol participants and comparing changes in their responses. The final inferred specification in TML can be directly translated into modeling languages used by off-the-shelf verification tools and configured to verify against a variety of attacker models.

Our techniques focus on recovering as much protocol semantics as possible from dynamic executions of the protocol. We apply AUTHSCAN to study several real-world websites, including three popular SSO protocols: Facebook Connect Protocol (2 websites), Browser ID (3 websites), and Windows Live Messenger Connect (1 website). We also test several standalone websites that implement their custom authentication logic and have millions of users sharing personal information. AUTHSCAN successfully recovers precise (but partial) models of their authentication logic and formally verifies their authentication and secrecy properties against a broad range of attacker models. We have found 7 security flaws in these implementations, one of which was independently discovered by concurrent work, and the remaining are previously unknown. Specifically, we find two flaws in Facebook Connect Protocol and one flaw in BrowserID, arising because the freshness of messages is not guaranteed in the protocol implementations, allowing replay attacks. Several other vulnerabilities are due to unsafe implementation errors in creating and maintaining the secrecy of authentication tokens.

### Contributions
The main contributions of this paper are:
- **Automatic Extraction Techniques**: We propose automatic techniques to extract authentication protocol specifications from their implementations. Our approach works with minimal user inputs and reasonable assumptions, without requiring any prior knowledge of the protocol. Our techniques gracefully adjust the precision of the inferred protocol based on the visibility of the source code.
- **End-to-end System**: We build AUTHSCAN, an end-to-end system embodying these techniques. AUTHSCAN is designed to be extensible and configurable, utilizing several off-the-shelf verification tools (ProVerif or PAT) and can be extended to model different attack scenarios.
- **Practical Results**: We apply our approach to several real-world websites, including those using important SSO protocols like Facebook Connect Protocol, BrowserID, and Windows Live Messenger Connect. We successfully find 7 security flaws in their implementations.

## 2. Challenges & Overview
Security analysts often need to guarantee the correctness of authentication protocol implementations without complete access to the source code. In this section, we explain the problem and its challenges with an example.

### 2.1 A Running Example
Consider an execution of a hypothetical SSO protocol (similar to Facebook Connect) as shown in Figure 1-(a). Alice wants to authenticate herself to a service provider (SP) website hosted at sp.com using her login credentials with an identity provider (IDP) hosted at idp.com. The communication between the IDP and SP occurs through the web browser (using postMessage between client-side iframes), similar to real-world protocols. This enables security analysts to analyze protocol behaviors.

The authentication protocol is as follows:
- **Step x**: When Alice visits the SP’s site and initiates the intent to authenticate, the client-side SP code sends the pre-registered ID and domain of the SP to the IDP’s iframe. The fact that each SP is pre-registered with the IDP is not known to the security analyst by observing this protocol execution.
- **Step y**: Assuming Alice has already logged into the IDP, the IDP generates an HTTP request to its backend server. The request contains a nonce (anti-CSRF) and the session ID of Alice’s ongoing web session with the IDP.
- **Step z**: The IDP replies with Alice’s registered email identity (uEmail) and an authentication token (authToken), which authorizes all access to Alice’s personal information stored at the IDP. The IDP creates a cryptographic signature over the terms uEmail and authToken as an authentication credential to be verified by the SP.
- **Step {:** Client-side IDP code (code A in Figure 1-(c)) relays the HTTP data received in step z to the SP’s iframe.
- **Step |:** Client-side SP code (code B in Figure 1-(c)) verifies that the signature is valid and extracts the uEmail and authToken. The SP’s iframe sends Alice’s identity and authToken back to the SP’s server. This allows the SP’s server to access Alice’s information stored at the IDP and logs all SP’s actions on Alice’s data for audit (not shown).

The security analyst can only observe the network traffic and code execution at the browser end; the server-side logic of the protocol participants is not available for analysis.

#### Security Flaws
The protocol has several vulnerabilities:
- **Man-in-the-middle (MITM) Attack**: The protocol is susceptible to several MITM attacks by a web attacker. For example, the target of the postMessage call in the client-side code (line 19) is derived from an HTTP parameter called next (at line 2 of Figure 1-(c)). A malicious SP, say Eve, can change the next parameter to its own domain, leaving the spid parameter as it is. In this attack, the token granted to sp.com is actually sent to Eve by code labeled as A in step {. This attack is similar to a recently reported real-world attack on the site zoho.com employing Facebook Connect.
- **Replay Attack**: The protocol is susceptible to a replay attack, as the IDP’s server does not use any nonce or timestamp to guarantee the freshness of the authentication token authToken. If a malicious SP obtains the signed assertion in step {, it can replay the message to sp.com in a new web session and log in as Alice.
- **Guessable Tokens**: Even if the authentication token is kept secret by carefully using only secure (private) communication channels, additional problems can exist. For example, authToken remains constant across all of Alice’s sessions, which is not apparent from observing a single protocol run. Such tokens, referred to as long-lived tokens, may be used in replay attacks. Similarly, if the IDP uses a weak or guessable scheme to generate authentication tokens, such as a sequentially incrementing counter, an attacker can precisely guess the tokens used in other web sessions.

### 2.2 Challenges
This example highlights the need to check implementation-dependent security properties in real web applications, where formal specifications are required. The following practical challenges arise in inferring specifications from their implementations:

- **Inferring Semantics**: A key challenge is to infer the precise semantics of data elements exchanged in the communication. For example, it is crucial to know that authToken remains constant across all of Alice’s sessions with the IDP and does not include a nonce or a timestamp. Inferring this information is critical to discovering the replay attack in the protocol. Similarly, identifying that the communication target in { is not a fixed domain but instead a variable derived from the HTTP parameter next is crucial to finding the MITM attack. These semantics are not obvious from the values observed in one message or even in one execution of the protocol.
- **Partial Code**: Only the part of the protocol implementation that executes in the web browser is visible for analysis. For instance, we can infer using whitebox analysis over the client-side code that idpSign is a cryptographic signature. However, the full context and behavior of the server-side code are not accessible, making it challenging to fully understand the protocol's security properties.