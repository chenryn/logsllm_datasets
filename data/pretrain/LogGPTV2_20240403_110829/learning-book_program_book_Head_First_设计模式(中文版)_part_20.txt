大师：我知道你能够体会。现在请进一步调节对象的依赖。
136第4章
---
## Page 173
工厂模式
一个很依赖的比萨店
harpenyourpencil
假设你从未听说过OO工厂。下面是一个不使用工厂模式的比萨店版本。数一数，这个类
所依赖的具体比萨对象有几种。如果又加了一种加州风味比萨到这个比萨店中，那么届时
又会依赖几个对象？
public class DependentPizzaStore {
public Pizza createPizza(String style, String type)(
Pizza pizza = null;
if (style.equals("Ny"))(
if (type.equals("cheese"))(
pizza = new NYStyleCheesePizza() :
处理所有组约风味
}else if (type.equals("veggie")){
pizza = new NYStyleVeggiePizza ();
比萨。
}else if (type.equals("clam")){
pizza = new NYStyleClamPizza() ;
}else if (type.equals("pepperoni")){
pizza = new NYStylePepperoniPizza ();
}else if (style.equals("Chicago")){
if (type.equals("cheese")){
处理所有延加哥风
pizza = new ChicagoStyleCheesePizza():
}else if (type.equals("veggie")){
味比萨。
pizza = new ChicagoStyleVeggiePizza() ;
}else if (type.equals("clam))(
pizza = new ChicagoStyleClamPizza();
}else if (type.equals("pepperoni"))(
pizza = new ChicagoStylePepperoniPizza ();
}else{
System.out.println("Error: invalid type of pizza");
return null;
pizza.prepare ();
pizza.bake ();
pizza.cut ();
pizza.box() ;
return pizza;
可以把答素写在
这里：
数0
加上加州风味后的数目
你现在的位置》
137
---
## Page 174
对象依赖
看看对象依赖
当你直接实例化一个对象时，就是在依赖它的具体类。请返回前
页看看这个依赖性很高的比萨店例子，它由比萨店类来创建所有
的比萨对象，而不是委托给工厂。
如果把这个版本的比萨店和它依赖的对象画成一张图，看起来是
这样的：
这个版本的PixxaStore依赖于所有
的比萨对象，因为它查接创建这
些比萨对象。
因为对于比萨具体实现的任何改
如果这些类的实现改变了.
变都金影响到PixxaStore。我们说
那么可能必须修改PixxaStore。
PixxaStore“依赖于”比萨的实现。
ZZ
eVeqy
每新增一个比萨种类，就等于
让PixxaStone多了一个依赖。
PDG
138
第4章
---
## Page 175
工厂模式
依赖倒置原则
很清楚地，代码里减少对于具体类的依赖是件“好事”。
事实上，有一个00设计原则就正式阐明了这一点，这个
原则甚至还有一个又响亮又正式的名称：“依赖倒置原
则”（Dependency Inversion Principle）。
这个专有名调可以今周圈
通则如下：
的人对你利目相看。你所
获得的加薪，将比买本书
所付出的钱更多，而且还
设计原则
会赢得其他开发人员的饮
要依赖抽象，不要依赖具体类。
佩。
首先，这个原则听起来很像是“针对接口编程，不针
对实现编程”，不是吗？的确很相似，然而这里更强
调“抽象”。这个原则说明了：不能让高层组件依赖低
所调“高居”组件，是由其
层组件，而且，不管高层或低层组件，“两者”都应该
他低层组件定义其行为的类。
依赖于抽象。
例如，PixxaStore是个高层组
件.因为它的行为是由比萨
这到底是什么意思？
定义的：PixxaStore创建所有
不同的比萨对象，准备、烘
这个嘛，让我们再次看看前一页比萨店的图。
烤、切片、装盒：而比萨本
身属于低层组件。
很清楚地，PizzaStore依赖这些具体比萨类。
现在，这个原则告诉我们，应该重写代码以便于我们依
赖抽象类，而不依赖具体类。对于高层及低层模块都应
该如此。
但是怎么做呢？我们来想想看怎样在“非常依赖比萨
店”实现中，应用这个原则
你现在的位置》
139
---
## Page 176
依赖倒置原则
原则的应围
非常依赖比萨店的主要问题在于：它依赖每个比萨类型。因为它是在自己
的orderPizza(方法中，实例化这些具体类型的。
虽然我们已经创建了一个抽象，也就是Pizza，但我们仍然在代码中，实际
地创建了具体的Pizza，所以，这个抽象没什么影响力。
如何在orderPizza(）方法中，将这些实例化对象的代码独立出来？我们都知
道，工厂方法刚好能派上用场。
所以，应用工厂方法之后，类图看起来就像这样：
PizxaStote现在依赖Pixxa这
个抽象类
Pixza是一个抽象
类…也就是“
这些具体比萨类也依赖Pixxa抽象
个抽象”
因为它们实现了Pixxa接口（别忘
了.所谓的“接口”，是广义的
说法）。
在应用工厂方法之后，你将注意到，高层组件（也就是PizzaStore）和低层组件（也
就是这些比萨）都依赖了Pizza抽象。想要遵循依赖倒置原则，工厂方法并非是唯一
PDG
的技巧，但却是最有威力的技巧之一。
140
第4章
---
## Page 177
工厂模式
好吧！我已经知递什么是
依赖，但为什么叫做依
赖“倒置”？
O
依赖倒置原则，究竟倒置在哪里？
在依赖倒置原则中的倒置指的是和一般OO设计的思考方
式完全相反。看看前一页的图，你会注意到低层组件现
在竞然依赖高层的抽象。同样地，高层组件现在也依赖
相同的抽象。前几页所绘制的依赖图是由上而下的，现
在却倒置了，而且高层与低层模块现在都依赖这个抽象。
让我们好好地回顾一个设计过程来看看，究竞使用了这
个原则之后，对设计的思考方式会被怎样地倒置
PDG
你现在的位置
141
---
## Page 178
倒置你的思考方式
倒置你的思考方式
好的，所以你需要实现一个比萨店，你第一件
嗯！比萨店进行准备、烘烤、装盒
想到的事情是什么？
C
所以我的店必须能制作许多不同风
味的比萨，例如：芝士比萨、素食
比萨、蛤比萨…
没错！先从顶端开始，然后往下到具体类。但
是，正如你所看到的你不想让比萨店理会这些
具体类，要不然比萨店将全都依赖这些具体类。
是的，芝士比萨、素食比萨和
现在，“倒置”你的想法.别从顶端开始，
给比萨都是比萨，所以它们
而是从比萨（Pizza）开始，然后想想看能抽象
应该共享一个Pizza接。
Q
化些什么。
对了，你想要抽象化一个Pizza。好，现在回头
重新思考如何设计比萨店。
既然我已经有一个比萨抽象，
就可以开始设计比萨店，而不用
理会具体的比萨类了。
很接近了，但是要这么做，必须靠一个工厂来
将这些具体类取出比萨店。一旦你这么做了，
各种不同的具体比萨类型就只能依赖一个抽象，
而比萨店也会依赖这个抽象。我们已经倒置了
一个商店依赖具体类的设计，而且也倒置了你的
思考方式。
142
第4章
---
## Page 179
工厂模式
几个指导方针帮助你遵循此原则··.··
下面的指导方针，能帮你避免在00设计中违反依赖倒置原则：
如果使用new，就会持有具体类
的引用。你可以酸用工厂来避开
■变量不可以持有具体类的引用。
这样的做法。
不要让类派生自具体类。
如果派生自具体类，你就会依赖
具体类。请派生自一个抽象（接
或抽象类）。
不要覆盖基类中已实现的方法。
如果覆盖基类已实现的方法，那么你的
基类就不是一个真正适合被继承的抽象。
基类中已实现的方法，应该由所有的子
类共享。
但是，等等，要完全遵守这
些指导方针似乎不太可能吧？
如果遵守这些方针，我连一个筒
单程际都写不出采！
O
你说的没错！正如同我们的许多原则一样，应该尽量达到这个原则，
而不是随时都要遵循这个原则。我们都很清楚，任何Java程序都有
违反这些指导方针的地方！
但是，如果你深入体验这些方针，将这些方针内化成你思考的一部
分，那么在设计时，你将知道何时有足够的理由违反这样的原则。
比方说，如果有一个不像是会改变的类，那么在代码中直接实例化
具体类也就没什么大碍。想想看，我们平常还不是在程序中不假思
索地就实例化字符串对象吗？就没有违反这个原则？当然有！可以
这么做吗？可以！为什么？因为字符串不可能改变。
另一方面，如果有个类可能改变，你可以采用一些好技巧（例如工厂
方法）来封装改变。
你现在的位置
143
---
## Page 180
原料家族
再回到比萨店····
比萨店的设计变得很棒：具有弹性的框架，而且遵循设
面团
计原则。
意式腊肠
现在，对象村比萨店成功的关键在于新鲜、
高质量的原料，而且通过导入新的框架，
加盟店将遵循你的流程，但是有一些加盟
店，使用低价原料来增加利润。你必须
采取一些手段，以免长此以往毁了对象
村的品牌。
确保原料的一致
芝士
要如何确保每家加盟店使用高质量的原料？你打算建
馨科
造一家生产原料的工厂，并将原料运送到各家加盟店。
对于这个做法，现在还剩下了一个问题：加盟店座落在不同的区域，纽约
的红酱料和芝加哥的红酱料是不一样的。所以对于纽约和芝加哥，你准备了
两组不同的原料。让我们看得更仔细些：
芝加哥
纽约
我们有相同的产品
比萨菜单
家族（面团、意式
比萨菜单
芝士比萨
腊肠、馨料、丝士、
番茄酱料、意大利白干酪、Parmesan干酪、比萨
蔬莱、肉），但是
芝士比萨
制作方式根据区域
大蒜番茄酱料、Reggiano干酪、大蒜
草
素食比萨
的不同而有差异。
素食比萨
番酱料、意大利白干酪、Parmesan干酪、茄子、
大蒜香酱料、Reggiano干酪、菇、详葱、红椒
菜、黑橄榄
蛤州比萨
大蒜香茄酱料、Reggiano于酪、新鲜蛤
始比萨
香酱料、意大利白干酪、Parmesan干酪、蛤姻
意式腊肠比萨
意式胎肠比萨
大蒜番茄酱料、
、Reggiamo干酪。兼菇、洋葱、红
香蒸酱料、意大利白干酪、Parmesan干酪、萄子、
板，意式腊肠
菜、黑橄榄、意式赠肠
144
第4章
---
## Page 181
工厂模式
原料家族
纽约使用一组原料，而芝加哥使用另
芝加哥
一组原料。对象村比萨是如此受欢迎，
可能不久之后加州就有加盟店了，到
时候又需要运送另一组区域的原料。
PlumTomatoSauce
ThickCrustDough
接着呢？西雅图吗？
想要行得通，必须先清楚如何处理原
料家族。
纽约
所有对象村的比萨都是使用相同的组件制造而
成的，但是每个区域对于这些组件却有不同的
实现。
加州
ReggianoCheese
BruschettaSa
VeryThinCrust
每个家族都包含了一种面团、一种替
科、一种芝士.以及一种海鲜佐科
（还有一些没写出来的原料，例如装
莱与香科）的类型。
整体来说，这三个区域组成了原科家族，每个区域实现了
一个究整的原科家族。
你现在的位置
145
---
## Page 182
原料工厂
建造原料工厂
现在，我们要建造一个工厂来生产原料；这个工厂将负责创建原料
家族中的每一种原料。也就是说，工厂将需要生产面团、酱料、芝士
等。待会儿，你就会知道如何处理各个区域的差异了。
开始先为工厂定义一个接口，这个接口负责创建所有的原料：
public interface PizzaIngredientFactory (
public Dough createDough() ;
public Sauce createSauce();
在提口中，每个原科都有一个对应
public Cheese createCheese();
的方法创建该原科。
public Veggies[] createVeggies () ;
public Pepperoni createPepperoni();
public Clams createClam() ;
如果签个工厂实例内都有某一种通
这里有许多新类，每个原
用的“机制”电要实现，就可以把
科都是一个类。
这个例子改写成抽象类
要做的事情是：
①
为每个区域建造一个工厂。你需要创建一个继承自PizzalngredientFactory的子类来
实现每一个创建方法。
实现一组原料类供工厂使用，例如ReggianoCheese、RedPeppers、ThickCrust-
Dough。这些类可以在合适的区域间共享。
③
然后你仍然需要将这一切组织起来，将新的原料工厂整合进旧的PizzaStore代码
中。
146
第4章
---
## Page 183
工厂模式
创建纽约原料工厂