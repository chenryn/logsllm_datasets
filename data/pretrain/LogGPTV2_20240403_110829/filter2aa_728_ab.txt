𝒪(1)
𝒪(n)
Delete
𝒪(1)
𝒪(n)
Search
𝒪(1)
𝒪(n)
𝒪(𝑛2)
Insert  n elements
Microsoft IIS        Hash Table
Lots of data such as HTTP-Headers, Server-Variables, Caches and 
Configurations are stored in Hash Table.
Microsoft's Two Hash Table
• TREE_HASH_TABLE
• LKRHash Table
TREE_HASH_TABLE
• The most standard code you have seen in your textbook
• Use chaining through Linked-List as the collision resolution
• Rehash all records at once when the table is unhealthy
• Combine DJB-Hash with LCGs as its Hash Function
LKRHash Table
• A successor of Linear Hashing, which aims to build a scalable 
Hash Table on high-concurrent machines.
• Invented at Microsoft in 1997 (US Patent 6578131) 
• Paul Larson
- from Microsoft Research
• Murali Krishnan - from IIS Team
• George Reilly
- from IIS Team
• Allow applications to customize their table-related functions such as 
Key-Extractor, Hash-Calc and Key-Compare operations.
Outline
1.
Introduction
2. Our Research
a) Hash Table Implementation
b) Hash Table Usage
c) IIS Cache Mechanism
3. Vulnerabilities
4. Recommendations
Hash Table Implementation
• Memory corruption bugs
• Logic bugs 
• E.g. CVE-2006-3017 discovered by Stefan Esser - PHP didn't 
distinguish the type of hash-key leads to unset() a wrong element.
• Algorithmic Complexity Attack such as Hash-Flooding Attack
Hash Table Usage
• Since LKRHash is designed to be a customizable implementation that 
can be applied to various scenarios, applications have to configure 
their own table-related functions during initialization.
• Is the particular function good?
• Is the logic of the Key-Calculation good?
• Is the logic of the record selection good?
• More and more…
HTTP.SYS
Windows Process 
Activation Service
(WAS)
World Wild Web 
Publishing Service
(W3SVC)
IISSvcs (svchost.exe)
HTTP.SYS
Windows Process 
Activation Service
(WAS)
World Wild Web 
Publishing Service
(W3SVC)
IISSvcs (svchost.exe)
applicationHost.config
HTTP.SYS
Windows Process 
Activation Service
(WAS)
World Wild Web 
Publishing Service
(W3SVC)
IISSvcs (svchost.exe)
applicationHost.config
HTTP.SYS
Windows Process 
Activation Service
(WAS)
World Wild Web 
Publishing Service
(W3SVC)
IISSvcs (svchost.exe)
Worker (w3wp.exe)
Initializing
iisutil.dll
w3tp.dll
w3dt.dll
…
iiscore.dll
applicationHost.config
HTTP.SYS
Windows Process 
Activation Service
(WAS)
World Wild Web 
Publishing Service
(W3SVC)
IISSvcs (svchost.exe)
Worker (w3wp.exe)
IIS Modules
static.dll
filter.dll
isapi.dll
…
iislog.dll
cachuri
Initializing
iisutil.dll
w3tp.dll
w3dt.dll
…
iiscore.dll
Native IIS Modules
CustomErrorModule
StaticCompression
HttpRedirection
CgiModule
ProtocolSupport
DefaultDocument
CustomLogging
DirectoryListing
WindowsAuthModule
RequestFiltering
FileCacheModule
HttpLoggingModule
TokenCacheModule
AnonymousAuthModule
HTTPCacheModule
StaticFileModule
IsapiModule
BasicAuthModule
UriCacheModule
DynamicCompression
…
Global Cache Provider/Handler
CustomErrorModule
StaticCompression
HttpRedirection
CgiModule
ProtocolSupport
DefaultDocument
CustomLogging
DirectoryListing
WindowsAuthModule
RequestFiltering
FileCacheModule
HttpLoggingModule
TokenCacheModule
AnonymousAuthModule
HTTPCacheModule
StaticFileModule
IsapiModule
BasicAuthModule
UriCacheModule
DynamicCompression
…
applicationHost.config
HTTP.SYS
Windows Process 
Activation Service
(WAS)
World Wild Web 
Publishing Service
(W3SVC)
IISSvcs (svchost.exe)
Worker (w3wp.exe)
IIS Modules
static.dll
filter.dll
isapi.dll
…
iislog.dll
cachuri
Initializing
iisutil.dll
w3tp.dll
w3dt.dll
…
iiscore.dll
Request-
Notify Events-
Request-Level Notify Events
PreExecuteRequestHandler
ExecuteRequestHandler
ReleaseRequestState
UpdateRequestCache
EndRequest
LogRequest
BeginRequest
AuthenticateRequest
AuthorizeRequest
ResolveRequestCache
AcquireRequestState
MapRequestHandler
Global-Level Notify Events
TraceEvent
ThreadCleanup
CacheCleanup
CacheOperation
…
CustomNotification
StopListening
ApplicationStart
ApplicationStop
HealthCheck
FileChange
ConfigurationChange
Request-Level Cache
BeginRequest
AuthenticateRequest
AuthorizeRequest
ExecuteRequest
MapRequest
LogRequest
EndRequest
…
FileCacheModule
cachFile.dll
TokenCacheModule
cachTokn.dll
UriCacheModule
cachUri.dll
HTTPCacheModule
cachHttp.dll
ResolveRequestCache
UpdateRequestCache
Global-Level Cache
BeginRequest
AuthorizeRequest
ResolveRequestCache
ExecuteRequest
MapRequest
UpdateRequestCache
LogRequest
EndRequest
…
AuthenticateRequest
FileCacheModule
cachFile.dll
TokenCacheModule
cachTokn.dll
UriCacheModule
cachUri.dll
HTTPCacheModule
cachHttp.dll
Raise Global Notification
GL_CACHE_OPERATION
Outline
1.
Introduction
2. Our Research
3. Vulnerabilities
a) CVE-2022-22025 - IIS Hash Flooding Attack
by-default   large-bounty   demo
b) CVE-2022-22040 - IIS Cache Poisoning Attack
c) CVE-2022-30209 - IIS Authentication Bypass
by-default   demo
4. Recommendations
IIS Hash Flooding Attack
CVE-2022-22025
Hash Flooding Attack on IIS
• The Spoiler:
• TREE_HASH_TABLE: Vulnerable to Hash Flooding DoS by default.
• LKRHash: Vulnerable only If a poor Hash Function is configured.
UriCacheModule
• Cache URI information and configuration
• Accessible by default
• Every URL access triggers a Hash Table Lookup / Insert / Delete
• Use TREE_HASH_TABLE
0
50
100
150
200
250
5k
10k
15k
20k
25k
30k
35k
40k
45k
50k
55k
60k
65k
70k
75k
80k
85k
90k
95k
100k
 Random
 Collision
Time of Every 1000 New Records
s
s
s
s
s
s
What is this Jitter?
0
50
100
150
200
250
5k
10k
15k
20k
25k
30k
35k
40k
45k
50k
55k
60k
65k
70k
75k
80k
85k
90k
95k
100k
 Random
 Collision
s
1
bool TREE_HASH_TABLE::InsertRecord(TREE_HASH_TABLE *this, void *record) {
2 
/* omitting */
3     hashKey = this->vt->GetHashKey(this, record);
4
sig    = TREE_HASH_TABLE::CalcHash(this, hashKey);
5  
bucket  = this->_ppBuckets[sig % this->_nBuckets];
6
7     /* check for duplicates */
8     while ( !bucket->_pNext ) {
9       /* traverse the linked-list */
10     }
11
12
/* add to the table */
13 
ret = TREE_HASH_TABLE::AddNodeInternal(this, key, sig, keylen, bucket, &bucket);
14 
if ( ret >= 0 ) {
15
TREE_HASH_TABLE::RehashTableIfNeeded(this);
16     }
17
}
1
bool TREE_HASH_TABLE::InsertRecord(TREE_HASH_TABLE *this, void *record) {
2 
/* omitting */
3     hashKey = this->vt->GetHashKey(this, record);
4
sig    = TREE_HASH_TABLE::CalcHash(this, hashKey);
5  
bucket  = this->_ppBuckets[sig % this->_nBuckets];
6
7     /* check for duplicates */
8     while ( !bucket->_pNext ) {
9       /* traverse the linked-list */
10     }
11
12
/* add to the table */
13 
ret = TREE_HASH_TABLE::AddNodeInternal(this, key, sig, keylen, bucket, &bucket);
14 
if ( ret >= 0 ) {
15
TREE_HASH_TABLE::RehashTableIfNeeded(this);
16     }
17
}
1
void TREE_HASH_TABLE::RehashTableIfNeeded(TREE_HASH_TABLE *this) {
2
3
if ( this->_nItems > TREE_HASH_TABLE::GetPrime(2 * this->_nBuckets) ) {
4
CReaderWriterLock3::WriteLock(&this->locker);
5
Prime = TREE_HASH_TABLE::GetPrime(2 * this->_nBuckets);
6
7
if ( this->_nItems > Prime && Prime _nBuckets; i++ ) {
12 
/* move all records to new table*/
13 
}
14
15 
this->_ppBuckets = newBuckets;
16 
this->_nBuckets
= Prime;
17 
}
18 
/* omitting */
19 
}
20 }
Questions to be solved…
1.
How much of the Hash-Key we can control?
2. How easy the Hash Function is collide-able?
Cache-Key Calculation
• For the given URL: http://server/foobar
MACHINE/WEBROOT/APPHOST/DEFAULT WEB SITE/FOOBAR
Site Name
Config Path
Absolute Path
1
DWORD TREE_HASH_TABLE::CalcHash(wchar_t *pwsz) {
2
DWORD dwHash = 0;
3
4 
for (  ;  *pwsz;  ++pwsz)
5 
dwHash = dwHash * 101 + *pwsz;
6
7 
return ((dwHash * 1103515245 + 12345) >> 16)
8 
| ((dwHash * 69069 + 1) & 0xffff0000);
9 }