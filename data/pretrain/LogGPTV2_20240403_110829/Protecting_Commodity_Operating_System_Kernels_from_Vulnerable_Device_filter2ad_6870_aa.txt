title:Protecting Commodity Operating System Kernels from Vulnerable Device
Drivers
author:Shakeel Butt and
Vinod Ganapathy and
Michael M. Swift and
Chih-Cheng Chang
2009 Annual Computer Security Applications Conference
Protecting Commodity Operating System Kernels from Vulnerable Device Drivers∗
Shakeel Butt
Chih-Cheng Chang
Rutgers University Rutgers University University of Wisconsin-Madison Rutgers University
Michael M. Swift
Vinod Ganapathy
Abstract
Device drivers on commodity operating systems execute
with kernel privilege and have unfettered access to kernel
data structures. Several recent attacks demonstrate that such
poor isolation exposes kernel data to exploits against vulner-
able device drivers, for example through buﬀer overruns in
packet processing code. Prior architectures to isolate kernel
data from driver code either sacri ce performance, execute
too much driver code with kernel privilege, or are incompat-
ible with commodity operating systems.
In this paper, we present the design,
implementation
and evaluation of a novel security architecture that bet-
ter isolates kernel data from device drivers without sac-
ri cing performance or compatibility.
In this architec-
ture, a device driver is partitioned into a small, trusted
kernel-mode component and an untrusted user-mode com-
ponent. The kernel-mode component contains privileged
and performance-critical code.
It communicates via RPC
with the user-mode component which contains the rest of the
driver code. A RPC monitor mediates all control and data
transfers between the kernel- and user-mode components.
In particular, it veri es that all data transfers from the un-
trusted user-mode component to the kernel-mode component
preserve kernel data structure integrity. We also present a
runtime technique to automatically infer such integrity spec-
i cations. Our experiments with a Linux implementation of
this architecture show that it can prevent compromised de-
vice drivers from aﬀecting the integrity of kernel data and do
so without impacting common-case performance.
1. Introduction
Device drivers execute with kernel privilege in most com-
modity operating systems and have unrestricted access to
kernel data structures. Because the kernel is part of the
Trusted Computing Base (TCB) of the system, vulnerabili-
ties in driver code can jeopardize the entire system.
Several studies indicate that device drivers are rife with
exploitable security holes. A recent study of user/kernel bugs
in the Linux kernel found that 9 out of 11 of these bugs
were in device drivers [23]. An audit of the Linux kernel by
Coverity also found that over 50% of bugs were in device
drivers [13]. Our own analysis of vulnerability databases
revealed several device drivers that are vulnerable to mal-
formed input from untrusted user-space applications, allow-
ing an attacker to execute arbitrary code with kernel privi-
lege [4, 30]. Similarly, device drivers by their very nature
copy untrusted data from devices to kernel memory. Because
the kernel does not restrict the memory locations accessible
∗Supported by NSF awards 0831268, 0915394 and 0931992.
1063-9527/09 $26.00 © 2009 IEEE
DOI 10.1109/ACSAC.2009.35
301
to devices, a compromised driver can write arbitrary values
to sensitive kernel data structures. For example, a compro-
mised driver could overwrite the table of interrupt handlers in
the operating system with pointers to attacker-deﬁned code.
As demonstrated by recently published exploits against wire-
less device drivers in Windows XP [7, 9] and Mac OS X [27],
vulnerabilities in drivers are an increasingly attractive target
for attackers.
Microkernels [26, 39, 41] oﬀer one way to isolate ker-
nel data from vulnerable device drivers. They execute de-
vice drivers as user-mode processes and can prevent ma-
licious modiﬁcations to kernel data by enforcing domain-
speciﬁc rules, e.g., as done in Nexus [39]. However, mi-
crokernels restructure the operating system, and the protec-
tion mechanisms that they oﬀer are not applicable to com-
modity operating systems, which are structured as macro-
kernels. Moreover, enforcing security policies on device
drivers may impose signiﬁcant performance overhead. For
example, Nexus reports CPU overheads of 2.5× on a CPU-
intensive media streaming workload. User-mode driver
frameworks [3, 11, 16, 24, 28, 38] allow commodity oper-
ating systems to execute device drivers in user mode. How-
ever, porting drivers to these frameworks often requires com-
plete rewrites of device drivers and the resulting performance
overheads are often signiﬁcant [3, 38].
This paper extends prior work on Microdrivers [21] and
proposes a security architecture that oﬀers commodity op-
erating systems the beneﬁts of executing device drivers in
user mode without aﬀecting common-case performance. In
this architecture, each device driver is composed of a trusted
kernel-level component, called a k-driver, and an untrusted
user-level component, called a u-driver. The k-driver con-
tains code that requires kernel privilege (e.g., interrupt pro-
cessing functions) and performance-critical code (e.g., func-
tions on the I/O path). The rest of the code, which contains
functions to initialize, shutdown, and conﬁgure the device,
neither requires kernel privilege nor is on the critical path and
executes as a user mode process. The combination of the u-
driver and the k-driver is called a microdriver. A prior study
with 297 Linux device drivers comprising network, sound
and SCSI drivers showed that as much as 65% of driver code
can execute in user mode without requiring kernel privilege
or aﬀecting common-case performance [21].
A u-driver and its corresponding k-driver communicate
via an RPC-like interface. When the k-driver receives a re-
quest from the kernel to execute functionality implemented
in the u-driver, such as initializing or conﬁguring the de-
vice, it forwards this request to the u-driver. Similarly, the
u-driver may also invoke the k-driver to perform privileged
operations or to invoke functions that are implemented in the
kernel. However, the u-driver is untrusted and all requests
that it sends to the k-driver must be monitored. For example,
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 13:08:20 UTC from IEEE Xplore.  Restrictions apply. 
a u-driver that has been compromised by exploiting a buﬀer
overrun vulnerability may potentially send spurious updates
to kernel data structure in its requests to the k-driver. Be-
cause the k-driver applies these updates to kernel data struc-
tures, the compromised u-driver may aﬀect the security of
the entire operating system.
We present a RPC monitor to interpose upon all commu-
nication between the u-driver and the k-driver, and to ensure
that each message conforms to a security policy. The RPC
monitor checks both data values and function call targets in
these messages. Data values in messages may contain up-
dates to data structures that the u-driver shares with the k-
driver. The RPC monitor enforces integrity constraints on
updates to kernel data structures initiated by the u-driver. In
our implementation, these integrity constraints are speciﬁed
as data structure invariants—constraints that must always be
satisﬁed by the data structure. For example, one such invari-
ant may state that the list of network devices must not change
during an invocation of a u-driver function to obtain device
conﬁguration settings. We present an approach to automati-
cally extract such data structure invariants using Daikon [19],
a state-of-the-art invariant inference tool. Similarly, the RPC
monitor also ensures that k-driver function calls that are in-
voked by the u-driver via RPC are allowed by a control trans-
fer policy that is extracted using static analysis of the driver.
This paper makes two key contributions over prior work
on Microdrivers [21]. First, it presents the design and imple-
mentation of the RPC monitor to mediate u-driver/k-driver
communication. In prior work on Microdrivers, all commu-
nication between a u-driver and a k-driver was unchecked,
thereby poorly isolating kernel data from untrusted u-drivers.
Second, it presents a technique to automatically infer data
structure integrity constraints to be enforced by the RPC
monitor. The key property of these constraints is that they ex-
press invariants over heap data structures, thereby constrict-
ing the updates that a compromised u-driver can apply to ker-
nel data structures.
Although the security architecture described in this paper
reduces kernel mode driver code, is compatible with com-
modity operating systems, and protects kernel data without
aﬀecting common-case performance, it is not a panacea and
cannot completely prevent a compromised u-driver from hi-
jacking the kernel. Nevertheless, our experiments show that
it can prevent a signiﬁcant fraction of attacks from propagat-
ing to and hijacking the kernel.
We have implemented our security architecture in the
Linux-2.6.18.1 kernel and have applied it to four device
drivers. Experiments show that our architecture can protect
against compromised u-drivers and do so without aﬀecting
common-case performance.
2. Background and scope
Device drivers for commodity operating systems execute
in the same protection domain as the rest of the kernel to
achieve good performance and easy access to hardware. This
architecture does not isolate kernel data from vulnerabilities
in device drivers, which are written in C by third-party ven-
dors. Such vulnerabilities, especially in packet-processing
code and ioctl handlers, can be exploited by malicious user-
space applications. For example, recent work [7, 9] shows
that a remote attacker can hijack control of Windows ma-
chine by exploiting a buﬀer over ow in beacon and probe
response processing code in an 802.11 device driver.
In-
deed, our study of vulnerability databases revealed several
exploitable buﬀer overrun and memory allocation vulnera-
bilities in driver code [4, 30].
The threats posed to kernel data by compromised device
drivers can broadly be classiﬁed into two categories.
• Threats at the kernel/driver interface. Kernel data struc-
tures are routinely updated by device drivers, and the kernel
imposes no restrictions on the memory regions accessible to
drivers or devices. This freedom can be misused by com-
promised drivers in a variety of ways. Compromised device
drivers can corrupt kernel data structures, causing the kernel
to crash. Similarly, drivers can update kernel hooks to point
to attacker-deﬁned code, leading to arbitrary code execution
that cannot be detected by user-mode security tools.
• Threats at the driver/device interface. A compromised
driver can maliciously modify the state of the device, e.g., by
writing arbitrary values to its registers or exhausting its re-
sources. More seriously, a driver can harm kernel data struc-
ture integrity using DMA. The driver can initiate DMA trans-
fers to an arbitrary physical memory address by simply writ-
ing this address to a device register. Because the kernel
does not restrict the memory regions accessible to a device,
a DMA transfer will overwrite these memory locations.
The architecture proposed in this paper helps detect and
prevent several threats at the kernel/driver interface. By rel-
egating a large portion of the device driver to a user-space
u-driver and monitoring all data and control transfers at the
user/kernel boundary, it restricts the amount of driver code
that can directly access kernel memory. Our architecture can
therefore protect against requests originating from a compro-
mised u-driver. However, to ensure good performance, our
architecture does not mediate the kernel/k-driver interface.
Consequently, it cannot protect against malicious k-drivers
and other kernel-resident malware. The k-driver is trusted in
our architecture and can be protected using prior fault iso-
lation techniques [18, 42], although we do not do so in our
implementation.
We do not address threats at the driver/device interface in
this paper. Monitoring data transfers from the device to ker-
nel memory either requires the use of new hardware mech-
anisms for virtualized I/O (such as IOMMU [2] and VT-
D [1]) as done in iKernel [36], or reference monitoring at the
driver/device interface as done in Nexus [39]. These tech-
niques are orthogonal to, and may possibly be used in con-
junction with, the architecture proposed here.
We also assume the availability of driver source code.
This is because our driver partitioning tool (discussed in
Section 4) operates on source code. While this limitation
precludes us from partitioning and protecting against device
drivers that are only distributed in binary form, a partition-
ing tool that works at the binary level would allow even such
drivers to be adapted to our architecture.
3. Design
Our security architecture aims to protect kernel data from
vulnerable device drivers that can be compromised by mali-
cious inputs from untrusted user-space applications and from
hardware. We begin by outlining our design goals.
• Kernel data structure integrity. The architecture must
monitor kernel data structure modiﬁcations initiated by de-
302
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 13:08:20 UTC from IEEE Xplore.  Restrictions apply. 
(cid:12)(cid:13)(cid:13)(cid:5)(cid:8)(cid:11)(cid:14)(cid:15)(cid:8)(cid:16)(cid:4)
(cid:10)(cid:6)(cid:7)(cid:3)(cid:8)(cid:9)(cid:2)(cid:3)
(cid:10)(cid:6)(cid:7)(cid:3)(cid:8)(cid:9)(cid:2)(cid:3)
(cid:17)(cid:18)(cid:4)(cid:15)(cid:8)(cid:19)(cid:2)
(cid:1)(cid:2)(cid:3)(cid:4)(cid:2)(cid:5)
(cid:1)(cid:6)(cid:7)(cid:3)(cid:8)(cid:9)(cid:2)(cid:3)
(cid:17)(cid:18)(cid:4)(cid:15)(cid:8)(cid:19)(cid:2)
(cid:17)(cid:20)(cid:21)
(cid:22)(cid:16)(cid:4)(cid:8)(cid:15)(cid:16)(cid:3)
(cid:1)(cid:6)(cid:7)(cid:3)(cid:8)(cid:9)(cid:2)(cid:3)
(cid:7)(cid:2)(cid:9)(cid:8)(cid:11)(cid:2)
Figure 1. Design of our device driver secu-
rity architecture. The solid lines show the
performance-critical path while the dashed
lines show the non-performance-critical path.
vice drivers and ensure that these updates comply with a se-
curity policy. Each device driver is associated with a security
policy that speciﬁes permissible updates to kernel data struc-
tures. These security policies specify kernel data structure
integrity constraints, and may either be speciﬁed manually
using domain-speciﬁc rules, e.g., as in Nexus [39], or ex-
tracted automatically, as in our implementation.
• Good common-case performance. Device drivers are on
the critical path that transfers data between user-space ap-
plications and external devices. Hence, to be practical, the
architecture must not signiﬁcantly impact I/O throughput.
• Compatibility. Modern operating systems support several
thousand device drivers. The architecture must secure the
kernel without requiring signiﬁcant changes to either the op-
erating system or requiring a rewrite of device drivers.
The above design goals are con icting and are challeng-
ing to achieve simultaneously. Commodity operating sys-
tems often share several kernel data structures with device
drivers that are updated on performance critical I/O paths