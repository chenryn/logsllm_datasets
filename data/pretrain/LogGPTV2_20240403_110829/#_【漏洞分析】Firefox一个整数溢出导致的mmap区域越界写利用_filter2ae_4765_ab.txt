分配大量的ArrayBuffer与96字节的存储
溢出并创建一个假的自由单元格内的竞技场下面我们的缓冲区
分配更多的相同大小的ArrayBuffer对象，看看它们中的一个是否放在另一个ArrayBuffer的数据内（只是扫描所有“old”ArrayBuffers为非零内容）
**对GC的需要**
不幸的是，这不是那么容易：为了让Spidermonkey在我们的目标（损坏） Arena中分配一个对象， Arena必须以前被标记为（部分）free。
这意味着我们需要在每个竞技场至少释放一个slot。 我们可以通过删除每25个ArrayBuffer（因为每个Arena有25个），然后强制垃圾收集机制。
Spidermonkey由于各种 原因触发垃圾收集。 似乎最容易触发的是TOO_MUCH_MALLOC
：它只是在通过malloc分配了一定数量的字节时被触发。 因此，以下代码足以触发垃圾回收：
    function gc() {
        const maxMallocBytes = 128 * MB;
        for (var i = 0; i lastAnimationTime + PRMJ_USEC_PER_SEC  95％）。
如果10+个其他选项卡已打开，漏洞利用仍然有效，但如果目前正在加载大型Web应用程序，则可能会失败。
**结论**
虽然从攻击者的角度来看，这个漏洞并不理想，但它仍然可以被相当可靠地利用并且没有太多的带宽使用。
有趣的是看到各种技术（压缩，相同的页面合并，…）可以使一个更容易利用的bug。
想想如何防止这样的bug的可利用性，一些事情想起来了。 一个相当通用的缓解是保护页（每当以某种方式访问时，导致segfault的页）。
这些将必须在每个mmap分配区域之前或之后分配，并且因此将防止利用诸如这一个的线性溢出。 然而，它们不能防止非线性溢出，例如这个错误 。
另一种可能性是引入内部mmap随机化以分散遍及地址空间的分配区域（可能仅在64位系统上有效）。 这最好由内核执行，但也可以在用户空间中执行。