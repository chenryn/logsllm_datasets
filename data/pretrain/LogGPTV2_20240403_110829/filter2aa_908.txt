大可(Dark) 
 熟悉的语言:C/C++ , PASCAL , ASM 
 专长:windows 程式设计&逆向工程 
 讲课经验:在ZCamp2008讲过课 
 兴趣:程式设计&资讯安全&美食&聊天&动漫&
睡觉&看电影&听音乐&弹钢琴&打电玩 
 Hackshield是一款防止外挂程式的入侵的软件， 
执行游戏时，Hackshield会侦防外挂使用者的
电脑， 并封锁不正常的程式码， 有效防止按键
精灵、加速器等的外挂的运行。 
 转自 
 http://eco.gamecyber.com.tw/tw/hanckshield01.html 
 CE (Cheat Engine) 
 读写记忆体 
 按照使用者指定的方式去比对记忆体的资料 
 有开放原始码 
 UCE(Undetected Cheat Engine) 
 防外挂软体会封锁CE 
 有人改CE原始码,改成防外挂检测不到 
 不需要再去找Bypass HS(hackshield)版的UCE 
 也不用自己修改CE原始码 
 可以写一个程式 , 使”任何工具”绕过HS 
 其实这部分很容易, 前提是要知道如何绕过HS 
 可以把绕过HS的方法,写成DLL 
 然后把DLL inject到指定的外挂工具中 
可以归纳为"攻" 与 "守" 两个动作 
 目的:侦测对游戏不利的程式 
 inline hook SSDT- NtDeviceIoControlFile:    
 拦截分析: 由于CE(Cheat Engine)从driver呼叫 CE内
部的OpenProcess方式，所以Usermode 必须呼叫 
DeviceIoControl 跟 driver交换讯息。 
 不定期取得process的资讯。 
 enum window寻找可疑的视窗。 
• 目的:让游戏记忆体不被外部程式Access,并防止HS遭修改 
• Inline hook SSDT- NtOpenProcess 
– 防止被外部程式获得Process Handle， 
– 然而工作管理员却是白名单(可以给我们利用) 
• Hook shadow SSDT-NtUserSendInput 
– 防止模拟键盘滑鼠输入 
• 此外会不定期对游戏的code segment做CRC check 
– 防止游戏程式码被修改! 
 Inline hook SSDT– NtReadVirtualMemory 
 防止游戏记忆体被读取 
 Inline hook SSDT– NtWriteVirtualMemory 
 防止游戏记忆体被写入 
 外挂也可以分为攻与守两个方式 
 攻:绕过,防护对游戏记忆体做读写 
 守:防止工具被HS检验到 
 上面两点都达到大概就圆满落幕了 
 Hook NtLoadDriver 
 这样就能使HS的驱动不正常运作 
                 但是 
 防外挂不只包含那个驱动, 有其他模组会检查HS
驱动执行是否正常 
 不正常就关闭游戏 
 追踪 HS载入的地方 
 修改程式，完全拔掉 HS 
 可以完全拔掉... 
       但是 
 游戏会发"确认HS运作正常"的封包 
 如果破坏 hackshield 的完整性 
 要进行繁琐的修复动作  
 分析伺服器送出的确认封包 
 模仿加密过程送出 
 才能让游戏正常执行 
 So , 选择与hackshield共存 
 透过hook , 来载入我们的dll 
 防止 HS对Executable Module list做验证 
 dll injection成功之后,把dll module给隐藏  
 就能直接存取游戏的记忆体空间 
 别用ReadProcessMemory 或 
WriteProcessMemory读写记忆体 
 游戏有对这两个API做Inline SSDT Hook 
 找到PEB(Process Environment Block) 
 在fs[0x30]可以找到peb ,像这样” mov  eax , fs: [0x30]” 
 到PEB->Ldr, 去enum下面三个module的List_Entry
结构 
 InLoadOrderModuleList  
 InMemoryOrderModuleList 
 InInitializationOrderModuleList 
 比对module,把要隐藏的module连结弄断 
 Current->Blink->Flink=Current->Flink 
 Current->Flink->Blink=Current->Blink 
 指定的dll module就会被孤立  
•
开工作管理员可以结束掉游戏的process 
– 可见工作管理员能对游戏做OpenProcess的动作 
– 工作管理员(taskmgr.exe)在HS的白名单里面 
•
从 PEB 到
_RTL_USER_PROCESS_PARAMETERS 结构，
改掉ImagePathName来伪装  
void Fake_Fake_FakeXD (WCHAR* wszImagePathName) 
{ 
_asm 
{ 
mov eax,fs:[0x30]     //eax points to PEB 
mov eax,[eax+0x010]  //eax points to _RTL_USER_PROCESS_PARAMETERS 
add eax,0x38 
 //eax points to ImagePathName(UNICODE_STRING) 
add eax,0x4 
 //UNICODE_STRING.Buffer 
mov ebx,wszImagePathName 
mov [eax],ebx 
} 
} 
 HS针对 NtOpenProcess 弄了一个inline hook，
侦测这个hook是否有效 
 无效的话就BSOD。 
 先不要动NtOpenProcess,他们忘记了
NtOpenProcess上面的老大 
 ObOpenObjectByPointer 
 利用这来获得Process Handle 
利用 KeAttachProcess 这个Native API 
弄个Read&WriteProcessMemoryByPid 
如此就不用烦恼取得Process Handle的种种问题! 
 hook shadow SSDT , 把获得视窗Handle的函数
hook掉 
 例如 
 NtUserQueryWindow 
 NtUserGetForegroundWindow 
 NtUserWindowFromPoint 
 NtUserFindWindowEx 
 NtUserBuildHwndList 
防止外挂的Process Handle被HS拿去用 
防止HS从Process List获得我们外挂的一些资讯
Afert 
要保护游戏是件不容易的事情 
DKOM(Direct Kernel Object Manipulation)  
http://www.blackhat.com/presentations/win-usa-04/bh-win-04-butler.pdf 
HOWTO: Implement your own NtOpenProcess in kernel-mode 
http://wj32.wordpress.com/2009/02/19/howto-implement-your-own-
ntopenprocess-in-kernel-mode/ 
Undocument-PEB Structure 
http://undocumented.ntinternals.net/UserMode/Undocumented%20Functions/
NT%20Objects/Process/PEB.html 
简单说说SSDT 
http://icylife.net/yunshu/show.php?id=435 
NEXON采用的新反作弊软件--Hack Shield Pro 介绍 
http://qbar.games.qq.com/popkart/165052.htm?owner=66191052 
Cheat Engine 
http://www.cheatengine.org/ 
Email: PI:EMAIL 
Blog: http://cl4rk.pixnet.net/blog/  
    ANY Question?