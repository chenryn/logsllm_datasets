req *compat-commit(ID, pid)
vid â† HG.commit(ID, pid)
(ğ›¾[ID], ğ¼,ğ‘Špub, Wpriv,ğ‘‡ ) â† Commit(ğ›¾[ID], PM[pid]; ğ‘Ÿ)
Key[vid] â† ğ¼
BR[vid] â† (ğ‘Ÿ Ì¸= âŠ¥)
for IDâ€² âˆˆ HG.roster(V-Pt[ID])
(ID1, . . . , IDğ‘š) â† Props.addedIDs(pid)
for ğ‘– = 1, . . . , ğ‘š
CM[vid, IDâ€²] â† ğ‘‡
WMpub[vid, IDğ‘–] â† ğ‘Špub
WMpriv[vid, IDğ‘–] â† Wpriv[IDğ‘–]
return (vid,ğ‘‡ ,ğ‘Špub, Wpriv)
Figure 11: Oracles for group creation, add, remove, update
proposals and commits of the security game for continuous
group key agreement schemes. The compatibility functions are
described in the accompanying text; a formal description is
provided in Figure 14.
// Process commit msg for ID and epoch vid
process(vid, ID)
req *compat-process(vid, ID)
ğ‘‡ â† CM[vid, ID]
P â† PM[HG[vid].pid]
(ğ›¾[ID], GI, ğ¼) â† Proc-Com(ğ›¾[ID],ğ‘‡ , P)
if Â¬HG.checkGI(vid, GI) âˆ¨ Key[vid] Ì¸= ğ¼
if Â¬Del[ID]
win
V-Tr[ID] â† V-Pt[ID]
if HG.isRemoved(vid, ID)
V-Pt[ID] â† vidroot
V-Pt[ID] â† vid
else
ğ‘–[ID] â† 0
P-St[ID] â† âˆ…
return GI
// Reveal the update secret of epoch vid
reveal(vid)
req Key[vid] Ì¸= ğœ–
req Â¬(Reveal[vid] âˆ¨ Chall[vid])
Reveal[vid] â† true
return Key[vid]
// Challenge the update secret of epoch vid
chall(vid)
req Key[vid] Ì¸= ğœ–
req Â¬(Reveal[vid] âˆ¨ Chall[vid])
ğ¼0 â† Key[vid]
ğ¼1 â† I
Chall[vid] â† true
return ğ¼ğ‘
// Welcome msg. of epoch vid delivered to ID
dlv-WM(vid, ID)
req *compat-dlv-WM(vid, ID)
ğ‘Špub â† WM-pub[vid, ID]
ğ‘Špriv â† WM-priv[vid, ID]
ikid â† HG.addedIK(vid, ID)
isk â† IK-SK[ikid]
let ğ‘£ s.t. ğ‘£.vid = vid
orig â† ğ‘£.orig = vid
(ğ›¾[ID], GI, ğ¼) â† Join(ID, orig,ğ‘Špub,ğ‘Špriv, isk)
if Â¬HG.checkGI(vid, GI) âˆ¨ Key[vid] Ì¸= ğ¼
if Â¬Del[ID]
IK-St[ID] âˆ’â† ikid
V-Pt[ID] â† vid
return GI
win
IK-Tr[ID] +â† ikid
Figure 12: Part one of oracles for message processing, cor-
ruption, and challenges of the security game for continuous
group key agreement schemes. The compatibility functions are
described in the accompanying text; a formal description is
provided in Figure 14.
Session 5C: Messaging and Privacy CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea1479// Corrupt ID
corr(ID)
V-Lk +â† {(vid, ID) | vid âˆˆ {V-Pt[ID]} âˆª V-Tr[ID]}
IK-Lk +â† IK-St[ID] âˆª IK-Tr[ID]
HG.corrHanging(ID)
return ğ›¾[ID]
// Enable no-delete for ID
no-del(ID)
disable deletions for ID
Del[ID] â† false
return âˆ€vid : Chall[vid] =â‡’ *CGKA-priv(vid)
// Safety for privacy
*priv-safe
Figure 13: Part two of oracles for message processing, cor-
ruption, and challenges of the security game for continuous
group key agreement schemes. The compatibility functions are
described in the accompanying text; a formal description is
provided in Figure 14.
as a child of IDâ€™s current epoch V-Pt[ID] and returns vid = ğ‘£.vid.
Note that the key output by Commit is stored in array Key. Further-
more, observe that the algorithm outputs (one) public and several
private welcome messages (one for each newly added party). The
private welcome messages are not returned to A and are deliv-
ered securely to their intended recipientâ€”the idea being that these
messages are encrypted by the higher-level application.
Process control messages. The oracles process and dlv-WM (Fig-
ure 13) allow the attacker to deliver commit messages (to existing
group members) resp. welcome messages (to new group members).
The oracles works much like their SGM counterparts, except that
all the information required by Proc-Com resp. Join is supplied by
the game. The oracles also check that the key ğ¼ output by Proc-Com
resp. Join and matches the one stored in array Key during the cor-
responding call to commit.
Key-reveal and challenge oracles. For each epoch, the attacker A
gets to either see the actual key output by the protocol or a challenge
by calling reveal or chall (Figure 13), respectively. Oracle chall
outputs either the real key or a completely random one, depending
on the secret internal bit ğ‘ chosen at the onset of the game.
Corruption oracles. The oracles related to corruption in the CGKA
game (Figure 13) are:
â€¢ corr(ID): leaks the state of ID to A;
â€¢ no-del(ID): instructs ID to stop deleting old values.
Safety. At the end of the execution of the CGKA security
A.2.6
game, the procedure *priv-safe ensures that the attacker has only
challenged in epochs that are considered secure by the (generic)
safety predicate *CGKA-priv. If the condition is not satisfied, the
attacker loses the game.
A.2.7 Advantage. Let Î  = *CGKA-priv be the generic safety pred-
icate used in the CGKA definition. The attacker A is parameterized
by itâ€™s running time, ğ‘¡, and the number of challenge queries, ğ‘, and
referred to as (ğ‘¡, ğ‘)-attacker. The advantage of A against a CGKA
scheme K w.r.t. to predicate Î  is denoted by AdvK
CGKA,Î (A).
Definition A.1. A CGKA scheme K is (ğ‘¡, ğ‘, ğœ€)-secure w.r.t. predicate
Î , if for all (ğ‘¡, ğ‘)-attackers,
AdvK
CGKA,Î (A) â‰¤ ğœ€ .
*compat-create(ID, ikid)
chk ikid âˆˆ IK-St[ID]
return V-Pt[ID] = vidroot
*compat-prop(op, ID, IDâ€², ikid)
vid â† V-Pt[ID]
chk vid Ì¸= vidroot
ğº â† HG.roster(vid)
select op
case add do
chk âˆƒipkâ€² : IK-PK[ikidâ€²] = ipkâ€²
chk IDâ€² /âˆˆ ğº
chk IDâ€² âˆˆ ğº
case rem do
*compat-commit(ID, pid)
return true
vid â† V-Pt[ID]
chk vid Ì¸= vidroot
G â† HG.roster(vid)
for pid âˆˆ pid
ğ‘ â† Props[pid]
chk ğ‘.vid = vid
G â† *app-prop(G, ğ‘)
chk G Ì¸= âŠ¥
chk ID /âˆˆ G
return true
*compat-process(vid, ID)
chk HG.isChild(V-Pt[ID], vid)
return true
*app-prop(G, ğ‘)
req ğ‘.orig âˆˆ G
select ğ‘.op
case add do
(IDâ€², Â·) â† ğ‘.data
req IDâ€² /âˆˆ G
G +â† IDâ€²
case rem do
IDâ€² â† ğ‘.data
req IDâ€² âˆˆ ğº
G âˆ’â† IDâ€²
return G
*compat-dlv-WM(vid, ID)
chk V-Pt[ID] = vidroot
ikid â† HG.addedIK(vid, ID)
chk ikid Ì¸= âŠ¥
âˆ§ ikid âˆˆ IK-St[ID]
return true
Figure 14: Compatibility oracles of the security game for con-
tinuous group key agreement schemes.
Session 5C: Messaging and Privacy CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea1480B FORWARD-SECURE GROUP AEAD
B.1 Syntax
â€¢ ğ‘£ â† Init(ğ‘˜ğ‘’, ğ‘›, ID): takes as input a key ğ‘˜ğ‘’, the group size ğ‘›,
as well as a party ID ID and generates the initial state.
â€¢ (ğ‘£â€², ğ‘’) â† Send(ğ‘£, ğ‘, ğ‘š) generates ciphertext ğ‘’ encrypting
plaintext ğ‘š and authenticating associated data ğ‘;
â€¢ (ğ‘£â€², S, ğ‘–, ğ‘š) â† Rcv(ğ‘£, ğ‘, ğ‘’): decrypts ciphertext ğ‘’ to plaintext
ğ‘š and verifies associated data ğ‘; also outputs a pair (S, ğ‘–)
consisting of sender ID S and message index ğ‘–.
B.2 Security
B.2.1 Main oracles. The oracles of the FS-GAEAD game are de-
picted in Figure 15.
Initialization. At the onset of the FS-GAEAD security game, a
random bit ğ‘ and a uniformly random key ğ‘˜ğ‘’ are chosen, and the
initialization algorithm is run for all group members in ğº (which
is specified by an argument to the initialization procedure). The
security game also initializes a message counter ğ‘–[ID] for each party.
Additionally, the game maintains the following variables, which
work analogously to their counterparts in the SGM game.
by S was a challenge,
deleted key material by ID,
â€¢ a set Chall of pairs (S, ğ‘–) recording that the ğ‘–th message sent
â€¢ a trash array AM-Tr[ID] of pairs (S, ğ‘–) keeping track of non-
â€¢ a set AM-Lk of elements (ID, AM-Rcvd, AM-Tr[ID]), where
AM-Tr[ID] keeps track of the messages whose key material is
leaked via corruption of ID, and AM-Rcvd are the messages
that have been already received at the time of corruption.
â€¢ a Boolean array Del[ID] keeping track of which parties are
â€¢ an array AM[S, ğ‘–, R] of triples (ğ‘, ğ‘š, ğ‘’) consisting of associated
deleting old values, and
data (AD), plaintext, and ciphertext.
The recorded data informs a safety predicate *priv-safe evaluated
at the end of the game to determine whether a given execution was
legal.
Sending messages and challenges. The oracle send(S, ğ‘, ğ‘š) allows
the attacker to have party S send AD ğ‘ and message ğ‘š (to all
other group members). The oracle runs algorithm Send, which
produces a ciphertext ğ‘’. The triple (ğ‘, ğ‘š, ğ‘’) is recorded in array AM.
Oracle chall works similarly, except that it takes two (equal-length)
messages as input and passes one of them to Send; which one is
chosen is determined by the secret random bit ğ‘ chosen initially.
Furthermore, the pair (S, ğ‘–[S]) is recorded as being a challenge.
Delivering and injecting ciphertexts. Oracle dlv-AM(S, ğ‘–, R) allows
A to have the ciphertext corresponding to the ğ‘–th message sent
by S delivered to R. The ciphertext and the corresponding AD are
fed to algorithm Rcv, which must correctly decrypt the ciphertext
and identify sender S and message number ğ‘–. The pair (S, ğ‘–) is set as
â€œreceivedâ€ by R by setting AM[S, ğ‘–, R] â† received which indicates
that the corresponding key material should now have been deleted
by R; in case R does not delete old values (i.e., Del[R] = false), the
pair is added to AM-Tr.
// Initialize group
init(ğº)
ğ‘ â† {0, 1}
ğ‘˜ğ‘’ â† K
for ID âˆˆ ğº
ğ‘£[ID] â† Init(ğ‘˜ğ‘’, |ğº |, ID)
ğ‘–[ID] â† 0
Chall â† âˆ…
AM-Tr[Â·] â† âˆ…
AM-Lk â† âˆ…
AM[Â·, Â·, Â·] â† ğœ–
Del[Â·] â† ğœ–
// S sends ğ‘š with AD ğ‘
send(S, ğ‘, ğ‘š)
(ğ‘£[S], ğ‘’) â† Send(ğ‘£[S], ğ‘, ğ‘š)
ğ‘–[S]++
for R âˆˆ ğº \ {S}
return ğ‘’
AM[S, ğ‘–[S], R] â† (ğ‘, ğ‘š, ğ‘’)
// Corruption of ID
corr(ID)
AM-Rcvd â† {(S, ğ‘–) | AM[S, ğ‘–, ID] = received}
AM-Lk +â† (ID, AM-Rcvd, AM-Tr[ID])
return ğ‘£[ID]
// Message delivery
dlv-AM(S, ğ‘–, R)
req AM[S, ğ‘–, R] Ì¸= {ğœ–, received}
(ğ‘, ğ‘š, ğ‘’) â† AM[S, ğ‘–, R]
(ğ‘£[R], Sâ€², ğ‘–â€², ğ‘šâ€²) â† Rcv(ğ‘£[R], ğ‘, ğ‘’)
if (Sâ€², ğ‘–â€², ğ‘šâ€²) Ì¸= (S, ğ‘–, ğ‘š)
win
if Â¬Del[R]
AM-Tr[R] +â† (S, ğ‘–)
AM[S, ğ‘–, R] â† received
// stop deletions for ID
no-del(ID)
Del[ID] â† false
// Message injection
inj-AM(ğ‘â€², ğ‘’â€², R)
req âˆ€S, ğ‘–, ğ‘– : AM[S, ğ‘–, R] Ì¸= (ğ‘â€², ğ‘–, ğ‘’â€²)
(ğ‘£[S], Sâ€², ğ‘–â€², ğ‘šâ€²) â† Rcv(ğ‘£[R], ğ‘, ğ‘’)
if ğ‘šâ€² Ì¸= âŠ¥
win
AM[Sâ€², ğ‘–â€², R] â† received
return (Sâ€², ğ‘–â€², ğ‘šâ€²)
// S challs ğ‘š0, ğ‘š1
chall(S, ğ‘, ğ‘š0, ğ‘š1)
req |ğ‘š0|= |ğ‘š1|
(ğ‘£[S], ğ‘’) â† Send(ğ‘£[S], ğ‘, ğ‘šğ‘)
ğ‘–[S]++
for R âˆˆ ğº \ {S}
Chall +â† (S, ğ‘–)
return ğ‘’
AM[S, ğ‘–[S], R] â† (ğ‘, ğ‘š, ğ‘’)
// Safety predicate