by identifying the key behavioral aspects that must be captured,
present a formal deﬁnition, and then present a real example to
demonstrate these aspects.
3.1 Key Behavioral Aspects
We consider the following aspects as essential when describing
the semantic-level behaviors of an Android malware sample:
1) API Dependency. API calls (including reﬂective calls to the
private framework functions) indicate how an app interacts with
the Android framework. It is essential to capture what API calls
an app makes and the dependencies among those calls. Prior
works on semantic- and behavior-based malware detection and
classiﬁcation for desktop environments all make use of API de-
pendency information [16, 21]. Android malware shares the
same characteristics.
2) Context. An entry point of an API call is a program entry
point that directly or indirectly triggers the call. From a user-
awareness point of view, there are two kinds of entry points:
user interfaces and background callbacks. Malware authors com-
monly exploit background callbacks to enable malicious func-
tionalities without the user’s knowledge. From a security ana-
lyst’s perspective, it is a suspicious behavior when a typical user
interactive API (e.g., AudioRecord.startRecording()) is
called stealthily [10]. As a result, we must pay special attention
to APIs activated from background callbacks.
3) Constant. Constants convey semantic information by revealing
the values of critical parameters and uncovering ﬁne-grained
API semantics. For instance, Runtime.exec() may execute
[0,0,0,0.9,…,0.8][1,0.6,0,0,…,0.7][0,0.9,0.7,0,…,0]...[0.6,0.9,0,0,…,0][0.8,0,0.8,0,…,1]Android AppsBehavior Graph GenerationGraph-based Feature Vector ExtractionAnomaly & Signature DetectionScalable Graph Similarity Query{} buckets{}[0,0,...,0,0,0,0,1][0,0,...,0,0,0,1,0][0,0,...,0,0,0,1,1]...[1,0,...,1,1,1,1,1][1,1,...,1,1,1,1,1]{}Figure 3: WC-ADG of Zitmo
varied shell commands, such as ps or chmod, depending upon
the input string constant. Constant analysis also discloses the
data dependencies of certain security-sensitive APIs whose benign-
ness is dependent upon whether an input is constant. For exam-
ple, a sendTextMessage() call taking a constant premium-
rate phone number as a parameter is a more suspicious behavior
than the call to the same API receiving the phone number from
user input via getText(). Consequently, it is crucial to extract
information about the usage of constants for security analysis.
Once we look at app behaviors using these three perspectives, we
perform similarity checking, rather than seeking an exact match,
on the behavioral graphs. Since each individual API node plays a
distinctive role in an app, it contributes differently to the graph sim-
ilarity. With regards to malware detection, we emphasize security-
sensitive APIs combined with critical contexts or constant param-
eters. We assign weights to different API nodes, giving greater
weights to the nodes containing critical calls, to improve the “qual-
ity” of behavior graphs when measuring similarity. Moreover, the
weight generation is automated. Thus, similar graphs have higher
similarity scores by design.
3.2 Formal Deﬁnition
To address all of the aforementioned factors, we describe app be-
haviors using Weighted Contextual API Dependency Graphs (WC-ADG).
At a high level, a WC-ADG consists of API operations where some
of the operations have data dependencies. A formal deﬁnition is
presented as follows.
tions in Σ;
cies between operations;
Deﬁnition 1. A Weighted Contextual API Dependency Graph is
a directed graph G = (V, E, α, β) over a set of API operations Σ
and a weight space W , where:
• The set of vertices V corresponds to the contextual API opera-
• The set of edges E ⊆ V × V corresponds to the data dependen-
• The labeling function α : V → Σ associates nodes with the la-
bels of corresponding contextual API operations, where each label
is comprised of 3 elements: API prototype, entry point and constant
parameter;
• The labeling function β : V → W associates nodes with their
corresponding weights, where ∀w ∈ W , w ∈ R, and R represents
the space of real numbers.
3.3 A Real Example
Zitmo is a class of banking trojan malware that steals a user’s
SMS messages to discover banking information (e.g., mTANs).
Figure 3 presents an example WC-ADG that depicts the malicious
behavior of a Zitmo malware sample in a concise, yet complete,
Figure 4: Callgraph for asynchronously sending an SMS message.
“e” and “a” stand for “event handler” and “action” respectively.
manner. This graph contains ﬁve API call nodes. Each node con-
tains the call’s prototype, a set of any constant parameters, and the
entry points of the call. Dashed arrows that connect a pair of nodes
indicates that a data dependency exists between the two calls in
those nodes.
By combining the knowledge of API prototypes with the data
dependency information shown in the graph, we know that the app
is forwarding an incoming SMS to the network. Once an SMS is
received by the mobile phone, Zitmo creates an SMS object from
the raw Protocol Data Unit by calling createFromPdu(byte[]).
It extracts the sender’s phone number and message content by call-
ing getOriginatingAddress() and getMessageBody(). Both
strings are encoded into an UrlEncodedFormEntity object and
enclosed into HttpEntityEnclosingRequestBase by using the
setEntity() call. Finally, this HTTP request is sent to the net-
work via AbstractHttpClient.execute().
Zitmo variants may also exploit various other communication-
related API calls for the sending purpose. Another Zitmo instance
uses SmsManager.sendTextMessage() to deliver the stolen in-
formation as a text message to the attacker’s phone. Such variations
motivate us to consider graph similarity metrics, rather than an ex-
act matching of API call behavior, when determining whether a
sample app is benign or malicious.
The context provided by the entry points of these API calls in-
forms us that the user is not aware of this SMS forwarding behav-
ior. These consecutive API invocations start within the entry point
method onReceive() with a call to createFromPdu(byte[]).
onReceive() is a broadcast receiver registered by the app to re-
ceive incoming SMS messages in the background. Therefore, the
createFromPdu(byte[]) and subsequent API calls are activated
from a non-user-interactive entry point and are hidden from the
user.
Constant analysis of the graph further indicates that the forward-
ing destination is suspicious. The parameter of execute() is nei-
ther the sender (i.e., the bank) nor any familiar parties from the
contacts. It is a constant URL belonging to an unknown third-party.
3.4 Graph Generation
We have implemented a graph generation tool on top of Soot [2]
in 20k lines of code. This tool examines an Android app to conduct
entry point discovery and perform context-sensitive, ﬂow-sensitive,
and interprocedural dataﬂow analyses. These analyses locate API
call parameters and return values of interest, extract constant pa-
rameters, and determine the data dependencies among the API calls.
Entry Point Discovery.
Entry point discovery is essential to revealing whether the user
is aware that a certain API call has been made. However, this
identiﬁcation is not straightforward. Consider the callgraph seen
in Figure 4. This graph describes a code snippet that registers a
, BroadcastReceiver.onReceive, Ø, BroadcastReceiver.onReceive, Ø, BroadcastReceiver.onReceive, Ø (java.util.List)>, BroadcastReceiver.onReceive, Ø, BroadcastReceiver.onReceive, Ø, BroadcastReceiver.onReceive, SetcSetc = {”http://softthrifty.com/security.jsp”}e2OnClickListener.onClickRunnable.runHandler.handleMessagee3a3Runnable.startHandler.sendMessageSmsManager.sendTextMessagee1a1a2Algorithm 1 Entry Point Reduction for Asynchronous Callbacks
Mentry ← {Possible entry point callback methods}
CMasync ← {Pairs of (BaseClass, RunM ethod) for asynchronous
calls in framework}
RSasync ← {Map from RunM ethod to StartM ethod for asyn-
chronous calls in framework}
for mentry ∈ Mentry do
c ← the class declaring mentry
base ← the base class of c
if (base, mentry) ∈ CMasync then
mstart ← Lookup(mentry) in RSasync
for ∀ call to mstart do
r ← “this” reference of call
P ointsT oSet ← PointsToAnalysis(r)
if c ∈ P ointsT oSet then
Mentry = Mentry − {mentry}
BuildDependencyStub(mstart, mentry)
end if
end for
end if
end for
output Mentry as reduced entry point set
onClick() event handler for a button. From within the event han-
dler, the code starts a thread instance by calling Thread.start(),
which invokes the run() method implementing Runnable.run().
The run() method passes an android.os.Message object to the
message queue of the hosting thread via Handler.sendMessage().
A Handler object created in the same thread is then bound to this
message queue and its Handler.handleMessage() callback will
process the message and later execute sendTextMessage().
The sole entry point to the graph is the user-interactive callback
onClick(). However, prior work [23] on the identiﬁcation of pro-
gram entry points does not consider asynchronous calls and recog-
nizes all three callbacks in the program as individual entry points.
This confuses the determination of whether the user is aware that an
API call has been made in response to a user-interactive callback.
To address this limitation, we propose Algorithm 1 to remove any
potential entry points that are actually part of an asynchronous call
chain with only a single entry point.
Algorithm 1 accepts three inputs and provides one output. The
ﬁrst input is Mentry, which is a set of possible entry points. The
second is CMasync, which is a set of (BaseClass, RunM ethod)
pairs. BaseClass represents a top-level asynchronous base class
(e.g., Runnable) in the Android framework and RunM ethod is
the asynchronous call target (e.g., Runnable.run()) declared in
this class. The third input is RSasync, which maps RunM ethod
to StartM ethod. RunM ethod and StartM ethod are the callee
and caller in an asynchronous call (e.g., Runnable.run() and
Runnable.start()). The output is a reduced Mentry set.
We compute the Mentry input by applying the algorithm pro-
posed by Lu et al. [23], which discovers all reachable callback
methods deﬁned by the app that are intended to be called only by
the Android framework. To further consider the logical order be-
tween Intent senders and receivers, we leverage Epicc [25] to
resolve the inter-component communications and then remove the
Intent receivers from Mentry.
Through examination of the Android framework code, we gener-
ate a list of 3-tuples consisting of BaseClass, RunM ethod and
StartM ethod. For example, we capture the Android-speciﬁc call-
ing convention of AsyncTask with AsyncTask.onPreExecute()
being triggered by AsyncTask.execute(). When a new asyn-
chronous call is introduced into the framework code, this list is
updated to include the change. Table 1 presents our current model
for the calling convention of top-level base asynchronous classes in
Android framework.
Table 1: Calling Convention of Asynchronous Calls
Top-level Class
Runnable
AsyncTask
AsyncTask
AsyncTask
Message
Run Method
run()
onPreExecute()
doInBackground()
onPostExecute()
handleMessage()
Start Method
start()
execute()
onPreExecute()
doInBackground()
sendMessage()
public class AsyncTask{
public AsyncTask execute(Params... params){
executeStub (params);
}
public AsyncTask executeStub (Params...params){
onPreExecute();
Result result = doInBackground(params);
onPostExecuteStub (result);
}
public void onPostExecuteStub (Result result){
onPostExecute(result);
}
}
Figure 5: Stub code for dataﬂow of AsyncTask.execute
Given these inputs, our algorithm iterates over Mentry. For ev-
ery method mentry in this set, it ﬁnds the class c that declares this
method and the top-level base class base that c inherits from. Then,
it searches the pair of base and mentry in the CMasync set. If a
match is found, the method mentry is a “callee” by convention.
The algorithm thus looks up mentry in the map SRasync to ﬁnd
the corresponding “caller” mstart. Each call to mstart is further
examined and a points-to analysis is performed on the “this” refer-
ence making the call. If class c of method mentry belongs to the
points-to set, we can ensure the calling relationship between the
caller mstart and the callee mentry and remove the callee from
the entry point set.
To indicate the data dependency between these two methods,
we introduce a stub which connects the parameters of the asyn-
chronous call to the corresponding parameters of its callee. Fig-
ure 5 depicts the example stub code for AsyncTask, where the
parameter of execute() is ﬁrst passed to doInBackground()
through the stub executeStub(), and then the return from this
asynchronous execution is further transferred to onPostExecute()
via onPostExecuteStub().
Once the algorithm has reduced the number of entry point meth-
ods in Mentry, we explore all code reachable from those entry
points, including both synchronous and asynchronous calls. We
further determine the user interactivity of an entry point by exam-
ining its top-level base class. If the entry point callback overrides a
counterpart declared in one of the three top-level UI-related inter-
faces (i.e., android.graphics.drawable.Drawable.Callback,
android.view.accessibility.AccessibilityEventSource,
and android.view.KeyEvent.Callback), we then consider the
derived entry point method as a user interface.
Constant Analysis.
We conduct constant analysis for any critical parameters of se-
curity sensitive API calls. These calls may expose security-related
behaviors depending upon the values of their constant parameters.
For example, Runtime.exec() can directly execute shell com-
mands, and ﬁle or database operations can interact with distinctive
targets by providing the proper URIs as input parameters.
To understand these semantic-level differences, we perform back-
ward dataﬂow analysis on selected parameters and collect all possi-
ble constant values on the backward trace. We generate a constant
set for each critical API argument and mark the parameter as “Con-
stant” in the corresponding node on the WC-ADG. While a more
complete string constant analysis is also possible, the computation
of regular expressions is fairly expensive for static analysis. The
substring set currently generated effectively reﬂects the semantics
of a critical API call and is sufﬁcient for further feature extraction.
API Dependency Construction.
We perform global dataﬂow analysis to discover data dependen-
cies between API nodes and build the edges on WC-ADG. How-
ever, it is very expensive to analyze every single API call made by
an app. To address computational efﬁciency and our interests on
security analysis, we choose to analyze only the security-related
API calls. Permissions are strong indicators of security sensitivity
in Android systems, so we leverage the API-permission mapping
from PScout [8] to focus on permission-related API calls.
Our static dataﬂow analysis is similar to the “split”-based ap-
proach used by CHEX [23]. Each program split includes all code
reachable from a single entry point. Dataﬂow analysis is performed
on each split, and then cross-split dataﬂows are examined. The dif-
ference between our analysis and that of CHEX lies in the fact that
we compute larger splits due to the consideration of asynchronous