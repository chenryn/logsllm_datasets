### 4.2 False Positive Analysis

A false positive occurs when a packet is incorrectly identified as containing an exploit. To evaluate the false positive rate, we collected network traffic over a five-day period from users in our lab engaged in normal activities. The majority of the traffic consisted of UDP, FTP, HTTP, SSL, and other TCP data packets. Notably, more than 90% of the FTP and TCP packets contained downloaded executables, video files, and streaming video. In total, over 4 million packets were captured, with a combined payload size exceeding 5 GB.

The payloads from these packets were extracted and individually analyzed using the proposed method. Most exploits are small (a few tens of bytes) and can fit within a single packet. The false positive rate was calculated as:

\[
\text{False Positive Rate} = \frac{\text{Number of Falsely Identified Packets}}{\text{Total Number of Packets}}
\]

For the analysis of Windows executables, we used files from the `C:\Windows\System32` directory on a machine running Microsoft Windows XP with Service Pack 2. The total size of these files was approximately 1 GB. Each executable was packetized into a sequence of packets, and each packet was analyzed separately. The false positive rate for this dataset was also calculated using the same formula.

The results indicated a false positive rate of 0.0126% for Windows executables and 0.0002% for captured network traffic. Only 8 out of more than 4 million packets were falsely identified, and manual inspection confirmed that these packets did not contain any exploits.

### 4.3 Processing Cost

To measure the processing cost of the core detection algorithm, we used the standard C function `clock()` to record the elapsed time. Pairwise `clock()` calls were inserted to measure the execution time of the target detection procedures. The experiments were conducted on a machine running Microsoft Windows XP with Service Pack 2, equipped with a Pentium(R)D 3.00GHz CPU and 2GB of RAM. We analyzed network packets and Windows executables of various sizes, ranging from several bytes to millions of bytes.

The processing speed of our method was calculated by comparing the size of the processed data against the corresponding processing time. The results, shown in Figure 4, indicate a nearly linear relationship between packet size and running time. The current non-optimized implementation achieves a processing speed of approximately 1.5 MB/s. Further optimizations are expected to significantly improve this performance.

### 5. Attack Analysis

We now discuss potential methods to defeat the proposed detection method.

#### Fragmentation
Decryption routines are typically small and can be contained within a single packet. However, attackers may deliberately fragment the exploit traffic across multiple packets. Reassembling these fragments is trivial, but it can complicate the detection process. Our method is designed to handle such fragmentation, but further improvements are necessary to ensure robustness.

### 6. Conclusions

In this paper, we presented a novel method for detecting self-decrypting polymorphic exploits. The proposed method scans network traffic for the presence of a decryption routine, a characteristic feature of such exploits. Compared to previous proposals [10, 23, 19, 22, 9], our method more accurately identifies the starting location of the decryption routine with fewer assumptions. It can also detect the decryption routine even if self-modifying code has been used to conceal its presence.

Evaluation results show that the proposed method has a 100% detection rate for realistic exploits, including those that use self-modifying code or lack a NO-OP sled. On a large dataset of network traffic and Windows executables, the method achieved a very low false positive rate. The non-optimized implementation's running time is roughly linear with the amount of data processed, indicating its potential for use in automated network defense against both targeted attacks and large-scale zero-day worm outbreaks.

Future work will focus on generalizing the method for less obvious sequences of byte decoding and testing it on non-exploit code that uses code obfuscation, encryption, and self-modification for legitimate purposes, such as reverse-engineering prevention and license verification. We expect the usage of these techniques to differ significantly from exploit code.

### 7. References

[1] Common vulnerabilities and exposures.
http://cve.mitre.org/cve/downloads/full-cve.csv.

[2] Computer Economics.
http://www.computereconomics.com.

[3] Intel Architecture Software Developers Manual.
Volume 2: Instruction Set Reference.

[4] Metasploit project.
http://www.metasploit.org.

[5] The ADMmutate polymorphic engine.
http://www.ktwo.ca/ADMmutate-0.8.4.tar.gz.

[6] The CLET polymorphism engine.
http://www.phrack.org/show.php?p=61&a=9.

[7] Bro Intrusion Detection System, 2003.
http://www.bro-ids.org.

[8] Snort: An open source network intrusion prevention and detection system, 2005.
http://www.snort.org.

[9] P. Akritidis, E. Markatos, M. Polychronakis, and K. Anagnostakis. STRIDE: Polymorphic Sled Detection through Instruction Sequence Analysis. In Proceedings of the 20th IFIP International Information Security Conference (SEC’05), pages 375–392, June 2005.

[10] R. Chinchani and E. Berg. A Fast Static Analysis Approach to Detect Exploit Code Inside Network Flows. In Proceedings of the 8th International Symposium on Recent Advances in Intrusion Detection (RAID’05), pages 284–308, September 2005.

Figure 4: Running Time Overhead
Our non-optimized implementation demonstrates modest processing speed. The results show a nearly linear relationship between packet size and running time. The current implementation achieves a speed of roughly 1.5 MB/s. This method has not been optimized yet, and substantial speedups should be possible.