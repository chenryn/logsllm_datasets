regarded as a false positive.
We collected network traﬃc for ﬁve days from users in
our lab, engaging in normal activities. Most of the traﬃc
was UDP, FTP, HTTP, SSL, and other TCP data packets.
Among these packets, the number of FTP and TCP packets
containing downloaded executables, video ﬁles, and stream-
ing video was signiﬁcant (>90%). Over 4 million packets
were captured, with a total payload size of more than 5 GB.
The data payloads from these packets were extracted and
presented to the proposed method for testing, a packet at a
time. Most exploits are small (a few tens of bytes) and easily
ﬁt within a single packet. (We discuss the limitations of this
approach in section 5.) A packet incorrectly identiﬁed as
containing an exploit was a false positive. The false positive
rate was calculated as:
(# of falsely identiﬁed packets) / (Total # of packets)
Windows executables were also analyzed to determine the
ability of the proposed method to distinguish exploit code
from non-exploit code. Executables in the C: \ windows
\system32 directory of a machine running Microsoft Win-
dows XP, service pack 2, were used for this purpose. The
total size of these ﬁles was around 1 GB. For analysis, we
packetized each executable into a sequence of packets, and
analyzed each packet separately. The false positive rate was
calculated as above.
The results were as follows. The false positive rate was
0.0126% for the case of Windows executables, and 0.0002%
for the case of captured network traﬃc. Only 8 out of more
than 4 million packets resulted in false identiﬁcations, or
alerts. The packet contents were manually inspected to ver-
ify that they did not contain exploits.
4.3 Processing Cost
We also measured the running time cost of the core de-
tection algorithm of the proposed approach. The standard
C function clock() was used for this purpose. Pairwise
clock() functions were inserted appropriately to embrace
the target detection procedures. The elapsed time between
the pairwise clock() measurements was collected and accu-
mulated. In these experiments, network packets and Win-
dows executables of various sizes, ranging from several bytes
to millions of bytes in length, were analyzed. The processing
speed of our method is calculated as the sizes of processed
packets or ﬁles against the corresponding processing time.
The experiments were performed on a machine running Mi-
crosoft Windows XP, service pack2, with a Pentium(R)D
3.00GHz CPU, and 2GB of RAM. Figure 4 shows the nor-
malized results.
of instructions. If the code contains a lengthy loop, or
one which does not terminate, analysis may fail or may
require an excessive amount of time. Nevertheless, our
approach can still be useful as a ﬁrst-stage detection
method. Polychronakis et al.
[19] demonstrated that
long loops in normal network traﬃc are rare.
6. CONCLUSIONS
In this paper, we presented a new method for detection of
self-decrypting polymorphic exploits. The proposed method
scans network traﬃc for the presence of a decryption rou-
tine, which is characteristic of such exploits. The proposed
method outperforms previous proposals [10, 23, 19, 22, 9]
in its capability to identify more precisely the starting lo-
cation of the decryption routine, with fewer assumptions.
The method also can identify the decryption routine even if
self-modifying code has been used to conceal its presence.
The evaluation results show that the proposed method has
a 100% detection rate on realistic exploits of many types, in-
cluding those that use self-modifying code, and/or that do
not have a NO-OP sled. On a large collection of network
traﬃc and Windows executables, a very low false positive
rate was observed. The non-optimized implementation run-
ning time is roughly linear in the amount of data processed.
These results indicate the proposed method is likely to be
useful as part of an automated network defense again both
targeted attacks, and large-scale zero-day worm outbreaks.
Future work will focus on generalizing the method for less
obvious sequences of byte decoding. In addition, we will test
the method on non-exploit code that uses code obfuscation,
code encryption, and self-modiﬁcation for legitimate pur-
poses (e.g., to prevent reverse-engineering, and to protect
license veriﬁcation). We expect the way these techniques
are used to be substantially diﬀerent than exploit code.
7. REFERENCES
[1] Common vulnerabilities and exposures.
http://cve.mitre.org/cve/downloads/full-cve.csv.
[2] Computer Economics.
http://www.computereconomics.com.
[3] Intel Architecture Software Developers Manual.
Volume 2: Instruction Set Reference.
[4] Metasploit project. http://www.metasploit.org.
[5] The ADMmutate polymorphic engine.
http://www.ktwo.ca/ADMmutate-0.8.4.tar.gz.
[6] The CLET polymorphism engine.
http://www.phrack.org/show.php?p=61&a=9.
[7] Bro Intrusion Detection System, 2003.
http://www.bro-ids.org.
[8] Snort: an open source network intrusion prevention
and detection system, 2005. http://www.snort.org.
[9] P. Akritidis, E. Markatos, M. Polychronakis, and
K. Anagnostakis. STRIDE: Polymorphic Sled
Detection through Instruction Sequence Analysis. In
Proceedings of the 20th IFIP International
Information Security Conference (SEC’05), pages
375–392, June 2005.
[10] R. Chinchani and E. Berg. A Fast Static Analysis
Approach To Detect Exploit Code Inside Network
Flows. In Proceedings of the 8th International
Symposium on Recent Advances in Intrusion Detection
(RAID’05), pages 284–308, September 2005.
Figure 4: Running Time Overhead
Our non-optimized implementation demonstrates a mod-
est processing speed. The results show almost a linear re-
lationship between the packet size, and running time. The
current implementation achieves a speed of roughly 1.5M/s.
This method has not been optimized yet, and substantial
speedups should be possible.
5. ATTACK ANALYSIS
We discuss now the possibility of defeating the the pro-
posed detection method.
Fragmentation. Decryption routines are normally of small
size. They can be contained within single packets.
However, the attackers may deliberately split exploit
traﬃc across multiple packets. It is trivial to reassem-