Source Code
Source Code
B.C
b.e
←
Objet File
8.0
→
图2-8链接过程
程序员的自我修养一链接、装载与库
---
## Page 75
52
第2章编译和链接
形成最终可执行文件。面最常见的库就是运行时库（RuntimeLibrary），它是支持程序运行
的基本函数的集合。库其实是一组目标文件的包，就是一些最常用的代码编译成目标文件后
打包存放，关于库本书的后面还会再详细分析。
我们认为对于Object文件没有一个很合适的中文名称，把它叫做中间目标文件比较合
适，简称为目标文件，所以本书后面的内容都将称Object文件为目标文件，很多时候
我们也把目标文件称为模块。
现代的编译和链接过程也并非想象中的那么复杂，它还是一个比较容易理解的概念。比
如我们在程序模块main.c中使用另外一个模块func.c中的函数fooO。我们在main.c模块中
每一处调用foo的时候都必须确切知道foo这个函数的地址，但是由于每个模块都是单独编
译的，在编译器编译main.c的时候它并不知道foo函数的地址，所以它暂时把这些调用foo
的指令的目标地址置，等待最后链接的时候由链接器去将这些指令的目标地址修正。如果
没有链接器，须要我们手工把每个调用foo的指令进行修正，则填入正确的foo函数地址。
当func.c模块被重新编译，foo函数的地址有可能改变时，那么我们在main.c中所有使用到
foxo的地址的指令将要全部重新调整。这些繁琐的工作将成为程序员的墨梦。使用链接器，
候，会根据你所引l用的符号foo，白动去相应的func.c模块查找foo的地址，然后将main.c
模块中所有引用到foo的指令重新修i正，让它们的目标地址为真正的foo函数的地址。这就
是静态链接的最基本的过程和作用。
在链接过程中，对其他定义在目标文件中的函数调用的指令须要被重新调整，对使用其
他定义在其他目标文件的变量来说，也存在同样的问题。让我们结合具体的CPU指令来了
解这个过程。假设我们有个全局变量叫做var，它在目标文件A里面。我们在目标文件B里
面要访问这个全局变量，比如我们在目标文件B里面有这么一条指令：
mov1
Ies 'ezx0s
这条指令就是给这个var变量赋值0x2a，相当于C语言里面的语句var=42。然后我们
编译目标文件B，得到这条指令机器码，如图2-9所示。
mov 指令码
常量
C7 05
00 00 00 00
28 00 00 00
目标地址
图2-9传送指令
程序员的自我修养一链接、装载与库
---
## Page 76
2.5本章小结
由于在编译目标文件B的时候，编译器并不知道变量var的目标地址，所以编译器在没
法确定地址的情况下，将这条mov指令的目标地址置为0，等待链接器在将目标文件A和B
链接起米的时候再将其修正。我们假设A和B链接后，变量var的地址确定下来为0x1000，
那么链接器将会把这个指令的目标地址部分修改成0x10000.这个地址修正的过程也被叫做
重定位（Relocation），每个要被修正的地方叫一个重定位入口（Relocation Entry），重定位
所做的就是给程序中每个这样的绝对地址引用的位置“打补丁”，使它们指向正确的地址。
2.5本章小结
在这一章中，我们首先回顾了从程序源代码到最终可执行文件的4个步骤：预编译、编
译、汇编、链接，分析了它们的作用及相互之间的联系，IDE集成开发工具和编译器默认的
命令通常将这些步骤合并成一步，使得我们通常很少关注这些步骤。
我们还详细回顾了上面这4个步骤中的主要部分，即编译步骤，介绍了编译器将C程
序源代码转变成汇编代码的若干个步骤：词法分析、语法分析、语义分析、中间代码生成、
目标代码生成与优化。最后我们介绍了链接的历史和静态链接的一系列基本概念：重定位、
符号、符号决议、目标文件、库、运行库等概念。
程序员的自我修养一链接、装载与库
---
## Page 78
目标文件里有什么
3.1目标文件的格式
3.2目标文件是什么样的
3.3挖掘SimpleSection.o
3.4ELF文件结构描述
3.5
链接的接口—符号
3.6调试信息
3.7本章小结
程序员的自我修养——链接、装载与库
---
## Page 79
56
第3章自标文件里有什么
编译器编译源代码后生成的文件叫做目标文件，那么目标文件单面到底存放的是什么
呢？或者我们的源代码在经过编译以后是怎么存储的？我们将在这一节剥开目标文件的层
层外壳，去探索它最本质的内容。
目标文件从结构上讲，它是已经编译后的可执行文件格式，只是还没有经过链接的过程，
其中可能有些符号或有些地址还没有被调整。其实它本身就是按照可执行文件格式存储的，
只是跟真正的可执行文件在结构上稍有不同。
可执行文件格式涵盖了程序的编译、链接、装载和执行的各个方面。了解它的结构并深
入剖析它对于认识系统、了解背后的机理大有好处。
3.1
自标文件的格式
现在PC平台流行的可执行文件格式（Executable）主要是Windows下的PE（Portable
Executable）和 Linux 的 ELF（Executable Linkable Format）,它们]都是 COFF (Common file
format）格式的变种。目标文件就是源代码编译后但未进行链接的那些中间文件（Windows
的.obj和Linux下的.o），它跟可执行文件的内容与结构很相似，所以一般跟可执行文件格式
以我们可以广义地将目标文件与可执行文件看成是一种类型的文件，在Windows下，我们
可以统称它们为PE-COFF文件格式。在Linux下，我们可以将它们统称为ELF文件。其他
不太常见的可执行文件格式还有 Intel/Microsoft 的 OMF(Object Module Format)、Unix a.out
格式和MS-DOS.COM格式等。
不光是可执行文件（Windows 的.exe和 Linux下的 ELF可执行文件）按照可执行文件
格式存储。动态链接库（DLL，Dynamic Linking Library）（Windows 的.dll 和 Linux 的.so)
及静态链接库（Static LinkingLibrary）（Windows 的.lib和 Linux的.a）文件都按照可执行文
件格式存储。它们在Windows下都按照PE-COFF格式存储，Linux下按照ELF格式存储。
静态链接库稍有不同，它是把很多目标文件棚绵在一起形成一个文件，再加上一些索引，你
可以简单地把它理解为一个包含有很多目标文件的文件包，ELF文件标准里面把系统中采用
ELF格式的文件归为如表3-1所列举的4类。
表3-1
ELF文件类型
说明
实例
可重定位文件
这类文件包含了代码和数据，可以被用来
链接成可执行文件或共享目标文件，静态
Linux .0
( Relocatable File )
链接库也可以归为这一类
Windows .obj
程序员的自我修养—链接、装载与库
---
## Page 80
3.1目标文件的格式
57
续表
ELF文件类型
说明
实例
可执行文件
这类文件包含了可以直接执行的程序，它
的代表就是ELF可执行文件，它们一般都
比如/bin/bash 文件
( Executable File )
没有扩展名
Windows .exe
这种文件包含了代码和数据，可以在以下
两种情况下使用，一种是链楼器可以使用
共享目标文件
这种文件跟其他的可重定位文件和共享目
Linux 的 .so ， 如/lib/
( Shared Object File )
标文件链接，产生新的目标文件。第二种
是动态健接器可以将几个这种其享目标文
glibc-2.5.so
Windows  DLL
件与可执行文件结合，作为进程映像的一
部分来运行
核心转储文件
当进程意外终止时，系统可以将该进程的
( Core Dump File )
地址空间的内容及终止时的一些其他信息
Linux 下的 core dump
转储到核心转储文件
我们可以在Linux下使用file命令来查看相应的文件格式，上面儿种文件在file命令下
会显示出相应的类型：
$file foobar.o
foobar.o: ELF 32-bit LSB relocatable, Intel 80386, version 1 (SYSV), not
stripped
$ file /bin/bash
GNU/Linux 2,6.8, dynamica1ly 1inked (uses shared 1ibs), stripped
/bin/bash: ELF 32-bit LSB executable, Intel 80386, version 1 (SYsV), for
$ fi1e /1ib/1d-2.6.1.so
/1ib/1ibc-2.6.1.so: ELF 32-bit LSB abared obfect, Intel 80386, version 1
(SYSV), for GNU/Linux 2.6.8, stripped
目标文件与可执行文件格式的小历史
目标文件与可执行文件格式跟操作系统和编译器密切相关，所以不同的系统平台下会
有不同的格式，但这些格式又大同小异，目标文件格式与可执行文件格式的历史几乎
是操作系统的发展史。
COFF是由UnixSystemVRelease 3首先提出并且使用的格式规范，后来微软公司基
于COFF 格式，制定了PE格式标准，并将其用于当时的Windows NT系统。System
V Release 4在COFF 的基础上引I入了 ELF 格式，目前流行的 Linux系统也以 ELF 作
为基本可执行文件格式。这也就是为什么目前PE和ELF如此相似的主要原因，因为
它们都是源于同一种可执行文件格式COFF。
Unix最早的可执行文件格式为a.out格式，它的设计非常地简单，以至于后来共享库
这个概念出现的时候，a.out格式就变得提襟见肘了。于是人们设计了COFF格式来解
决这些问题，这个设计非常通用，以至于COFF的继承者到目前还在被广泛地使用。
程序员的自我修养—链接、装载与库
---
## Page 81
58
第3章目标文件里有什么
COFF的主要贡献是在目标文件里面引入了“段”的机制，不同的目标文件可以拥有
不同数量及不同类型的“段”。另外，它还定义了调试数据格式。
注
下文的剖析我们以ELF结构为主。然后会专门分析PE-COFF文件结构，并对比其与ELF
的异同。
3.2
目标文件是什么样的
我们大概能猜到，目标文件中的内容至少有编译后的机器指令代码、数据。没错，除了
这些内容以外，目标文件中还包括了链接时所须要的一些信息，比如符号表、调试信息、字
符串等。一般目标文件将这些信息按不同的属性，以“节”（Section）的形式存储，有时候
也叫“段”（Segment），在般情况下，它们都表示一个一定长度的区域，基本上不加以区
别，唯一的区别是在ELF的链接视图和装载视图的时候，后面会专门提到。在本书中，默
认情况下统一将它们称为“段”
程序源代码编译后的机器指令经常被放在代码段（CodeSection）里，代码段常见的名
字有“.code”或“.text”：全局变量和局部静志变量数据经常放在数据段（DataSection），
如图 3-1 所可
C code with various storage classes
int global_init_var = 84;
Executable File /
int global_uninit_var;
Object File
void funel( int i )
File Header
printf( "td\n", I }:
text section
int main (void)
.data section
85:
static int atatic_var2;
.bss section
int a = 1:
->
int b:
return 0;
a + b ):
图3-1程序与目标文件
程序员的自我修养一链接、装载与库
---
## Page 82
3.2自标文件是什么样的
59
假设图3-1的可执行文件（目标文件）的格式是ELF，从图中可以看到，ELF文件的开
头是一个“文件头”，它描述了整个文件的文件属性，包括文件是否可执行、是静态链接还
是动态链接及入口地址（如来是可执行文件）、目标硬件、目标操作系统等信息，文件头还
包括-个段表（SectionTable），段表其实是一个描述文件中各个段的数组。段表描述了文
件中各个段在文件中的偏移位置及段的属性等，从段表里面可以得到每个段的所有信息。文
件头后面就是各个段的内容，比如代码段保存的就是程序的指令，数据段保存的就是程序的
静态变量等。
对照图3-1来看，一般C语言的编译后执行语句都编译成机器代码，保存在.text段：已
初始化的全局变量和局部静态变量都保存在.data段：未初始化的全局变量和局部静态变量
一般放在一个叫“bss”的段里。我们知道未初始化的全局变量和局部静态变量默认值都为
0.本来它们也可以被放在.data段的，但是因为它们都是0，所以为它们在data段分配空间
并且存放数据0是没有必要的。程序运行的时候它们的确是要占内存空间的，并且可执行文
件必须记录所有未初始化的全局变量和局部静态变量的大小总和，记为.bss段。所以.bss 段
只是为未初赔化的圣局变量和局部静态要量预留位置而已，它并没有内容，所以它在文件中
也不占据空间。
BSS历史
BSS (Block Started by Symbol) 这个词最初是 UASAP 汇编器 ( United Aircraft