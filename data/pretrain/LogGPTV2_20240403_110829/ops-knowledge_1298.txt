User: 请回答以下安全问题Linux内核熵——这对/dev/urandom重要吗？最小值是多少？这个问题已经被问了好几次了，但从其他答案中仍然无法清楚地理解
我有一些服务器运行自定义构建的linux内核（最少的驱动程序模块等），并且没有连接磁盘（一切都基于NAS）。内核entropy_avail在大多数情况下可以是180-200，在其他情况下可以低至140。我的应用使用/dev/urandom（一个使用SecureRandom（）的java应用，该应用内部使用/dev/urandom）
从这篇不错的文章中可以看出，/dev/urandom随机流主要取决于安装时生成的种子文件（以及稍后在引导时重新播种）。这是否意味着entropy_avail数字对/dev/urandom生成的随机数没有影响。问题是，/dev/urandom随机数在任何方面都取决于可用的熵吗？
如果是，系统中可用熵的可接受下限是多少？（200256？有很多报价。）
如果没有，请引用手册页。
从/dev/urandom设备读取不会阻止等待更多
熵。如果没有足够的熵，一个伪随机数
生成器用于创建请求的字节。
这难道不矛盾吗？
熵的意义。我们从手册页中了解到，全熵池大小为4096位，这意味着结果有2^4096种可能性。那么，如果entropy_avail是140，是否意味着它收缩到2^140？我仍然认为这是一个巨大的数字，我应该从什么开始担心？
在我的情况下，正如您所看到的，entropy_avail可能低于在普通桌面系统上观察到的值。我应该考虑软件熵生成工具（haveged、rngd等）还是一些特定的硬件来帮助改进它。这真的会影响/dev/urandom的输出吗？

Assistant: 熵在以下意义上是必需的：如果PRNG只有n位熵，那么这意味着它（概念上）只有2n个可能的内部状态，因此可以通过对这2n个状态的残酷枚举来打破，前提是n足够低，这样的暴力攻击是可行的。
然后事情变得复杂起来，因为内核报告的“熵水平”不是熵。不是我上面说的那个。
从密码学的角度来看，计算/dev/random和/dev/urandom输出的算法是一种（据称）加密安全的PRNG。实际上，对于实际安全来说，重要的是内部状态的累积熵。除非PRNG中存在密码弱点（目前还不知道），否则熵只能随着时间的推移而增加或保持不变。事实上，“熵”也可以被称为“攻击者不知道的东西”，如果PRNG确实是加密安全的，那么，根据定义，观察千兆字节的输出只会产生关于内部状态的微不足道的信息。这就是加密安全的含义。
因此，如果/dev/urandom在上次启动后的某个时刻有200比特的熵，那么它仍然有200比特，甚至更多。
从编写该代码的人（以及可怕的相应手册页）的角度来看，熵在使用时会“耗尽”。这是一个为了论证而假设PRNG在密码上不安全的人的立场，事实上，它在某种程度上等同于简单地按原样输出内部状态。从这个角度来看，如果/dev/random从n位熵开始并输出k位，那么它现在有n-k位熵。
然而，这种观点最终是站不住脚的，因为尽管它是基于PRNG完全崩溃和无操作的假设，但同时它也基于这样的假设，即PRNG在密码上仍然足够安全，可以将“硬件熵”（假设为有点随机的数据元素的源）变成一个很好的统一比特序列。简言之，熵损耗的概念只有在我们假设PRNG完全弱的情况下才有效，但在这种假设下，对实际熵的估计是完全不正确的。
从本质上讲，这种观点是自相矛盾的。不幸的是，/dev/random实现了一种依赖于这种有缺陷的熵估计的阻塞策略，这非常不方便。
/dev/urantom从不阻塞，不管自上次启动以来收集了多少“硬件熵”。然而，在“正常”的Linux安装中，在引导过程的早期会插入一个随机种子；该种子在上一次引导时保存，并在插入后立即更新。这个种子在很大程度上扩展了/dev/urandom在重启过程中的熵。因此，断言变成了：如果/dev/urandom自操作系统首次安装以来的任何时候都有200位熵，那么它仍然有200位的熵。
对于某些特定情况，例如无盘启动，这种行为可能仍然有些麻烦。引导机器在访问其文件之前可能需要一些随机性（例如，建立到达包含所述文件的服务器所需的IPsec上下文）。/dev/urandom的更好实现将阻塞，直到收集到足够数量的硬件熵（例如128位），但随后将“永远”产生位，而不实现某种熵损耗。这正是FreeBSD的/dev/urandom所做的。这很好。
总结：别担心。如果内核中使用的PRNG在加密方面是安全的，那么“entropy_avail”计数就没有意义了。如果内核中使用的PRNG在加密方面不安全，那么“entropy_avail”计数仍然存在缺陷，无论如何，您都会陷入困境。
请注意，虚拟机快照打破了熵，因为恢复后虚拟机的行为始终取决于快照中保存的状态，并且只会通过新硬件事件的积累而产生分歧（这在虚拟机中可能很棘手，因为虚拟机硬件不是真正的硬件）。内核的“entropy_avail”计数器和/dev/random阻塞行为对此没有任何改变。对于系统PRNG来说，虚拟机快照/恢复是一个比“entropy_avail”试图捕获（但实际上未能捕获）的学术、纯粹理论场景更可信的安全漏洞。