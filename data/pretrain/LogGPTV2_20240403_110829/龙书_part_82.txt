是否否
是否
否否
Reached 位
第7章
0
---
## Page 323
化。我们不再需要一个空闲空间列表，需要的只是一个指向唯一空闲块的起始位置的指针fee。
用，那么就可以从数据预取中得到好处。不仅如此，用以维护空闲空间的数据结构也可以得到简
部性，因为几乎同时创建的对象将被分配在相邻的存储块中。如果这些相邻的块中的对象一起使
象。同时，通过使数据占用更少的缓存线和内存页，重新定位可以提高程序的时间局部性和空间片
的引用和根集中的引用。
7.6.4标记并压缩的垃圾回收器
我们检查该块的左端和右端，如果有一端为空闲就进行合并。
做，那么在图7-21的第(10)行或图7-25 的第(8)行上，每次我们将一个存储块放人空闲列表时，
们同样会被移出 Free 列表，力
Unreached 列表重新初始化，使之恰好包含这些对象。我们假设，当存储管理器创建新对象时，
它们的存储块。然后，第(9)行处理所有处于已扫描状态的对象，即所有的可达对象，并将
的某一个o'还没有被访问过，则第(7)行将o'改变为待扫描状态。
就是说，第(5)行到第(7)行的 for循环检查了一个待扫描对象。中的所有引用，如果这些引用中
列表中删除。第(3)行到第(7)行是一-个使用这些列表的基本标记－清扫式算法的简单实现。也
对象都在 Unreached 列表中（这个表同时也由存储管理器在为对象分配存储块时维护）。
现。对象中的 reached 位没有被使用，但是我们假定每个对象中都包含了一些二进制位，指明该
用
存
已扫描状态上的所有对象。像7.4.4节中讨论的那样，这些列表可以通过嵌人式的双重链表来实
Unreached、Unscanned、Scanned 的四个列表。这些列表分别保存了处于空闲、未被访问、待扫描和
月使之指向新的存储位置并不需要增加很多工作量。我们需要改变的全部引用包括可达对象中
运行时刻环境
进行重新定位(relocating)的垃圾回收器会在堆区内移动可达对象以消除存储碎片。通常,
在本节介绍的两个算法中，我们都假设返回给空闲列表的存储块仍然保持被回收前的样子。
将所有可达对象放在一段连续的位置上可以减少内存空间的碎片，使得它更容易存储较大的对
然片
第(1）、（2)行将 Scanned 列表初始化为空列表，并将 Unscanned 列表初始化为仅包含那些可
然后，第(8)行处理所有仍然在 Unreached 列表中的对象，将它们移到 Free 列表中，从而回收
二
Unreached = Scanned:
Free = Free U Unreached:
Scanuen = 0;
加人到Unreached列表中。
图7-25Baker 的标记－清扫式算法
将o从 Uureached 移动到Unscamned 中:：
canned 移动到Scanned;
307
局
它
---
## Page 324
均时间为某个常量，这个时间和堆区内的对象数量无关。
散列表，因此“set"和“gel”操作所需要的平
结构，虽然你可以假设 NevoLocation 是一个
的值。
地址。
树或其他数据结构：
意一-个实现了如下两个操作的散列表、搜
的开始位置。
在初始时刻，所有的对象都是未被访问的。
说一个对象的 reached 位为1或0时，我们分
中相同。为了使我们的描述简单，当我们要
中的 Unscanned 列表。
使用下列的数据结构：
算法7.15
一个名为NewLocation 的结构中。
址从堆的最低端开始分配，因此在可达对象之间没有空闲存储窗口。每个对象的新地址记录在
定位之前预留了空间：
3）指针fee，标记了堆区中未分配空间
我们不会关心到底使用了什么样的数据
②给定对象o，得到 NewLocation（o)
①将NeuLocation（o）设为对象o的新
4）NewLocation 表。
2）所有对象的reached 位也和算法7.12
1）一个 Unscanned 列表，同算法 7.12
308
输入：一个由对象组成的根集，一个堆，以及一个标记空闲空间的起始位置的指针fee。
新的地址可以在NewLocation 中找到。
3）最后，算法将对象拷贝到它们的新地址，更新对象中的所有引用，使之指向相应的新地
2）在第二阶段，算法扫描堆区中的已分配内存段，并为每个可达对象计算新的地址。新地
存在多种进行重新定位的回收器，其不同之处在于它们是在本地进行重新定位，还是在重新
方法：图7-26 给出了这个算法，此算法
输
1）首先是标记阶段，它和前面描述的标记－清扫式算法的标记阶段类似。
算法7.15中的标记并压缩垃圾回收器有3个阶段：
·7.6.5 节中给出了更高效、更流行的拷贝回收器（copying collector），它把对象从内存的-一
·本节描述的标记并压缩回收器（mark-and-compact collector)在本地压缩对象。在本地重新
出：指针free 的新值。
移动它。
个区域移到另－-个区域。保留额外的空间用于重新定位可以使得一发现可达对象就立刻
定位可以降低存储需求。
一个标记并压缩的垃圾回收器。
。这个结构可以是
索
刊
for（根集中的每个引用）
/*标记*/
图7-26
重新设置引用目标并移动已被访问的对象*/
=
if（o是已被访间的）
NewLocation(r):
端开始，
一个标记并压缩回收器
将口拷贝到NewLocation(o) ;
for（o中的每个引用o.r）
frec =
if(o是未被访问的）
NewLoc
堆区中的每个存储块0）{
将o加人到列表Unscanned 中；
0.r
将o标记为已被访问的；
第7章
---
## Page 325
置，则为其分配一个 To空间中的新地址。所有新地址都被记录在一个结构 NewLocation 中，特殊
的辅助函数LoobupNewLocation。该函数的输人是一个对象o，如果在To 空间中还没有对应的位
们时立刻把它们拷贝到 To 半空间。这种放置方法将相关对象放在一起，从而提高空间局部性。
始位置。From半空间此时全部空闲。
算法7.16
中分配对象。
内分配内存，直到它被填满。此时增变者停止，垃圾回收器将可达对象拷贝到另一个半空间，比
赖关系。整个存储空间被划分为两个半空间(semispace)A 和 B。增变者在半空间之一（比如 A)
7.6.5拷贝回收器
间包含
象)移动到堆区的底部，同时内部指针被修改，指向已被访问对象的新位置。
对象，它们可能是静态分配对象或栈分配对象。图7-27说明了如何将可达对象（图中无阴影的对
NeuLocation表用来确定这个新的地址。然后，第（17)行将内部引用已被更新的对象。移动到新的
可达对象。第(15)、（16)行将一个已被访问到的对象。的所有内部指针替换为它们的新地址，
指向空闲空间的开始位置。
予下一个可用地址；在第(11)行，我们根据对象o需要的存储数量增加free 指针，因此free 仍然
可用的新地址。我们只会为标记为已被访问的对象。创建新的地址。在第（10)行中，对象。被赋
间的对象已经被我们移走了。
很重要，它可以保证我们在重新定位对象时总是将对象向左移，那么在移动时，原来占据目标空
--个存储块。结果，被分配给存储块的新地址与它们的老地址按照同样的顺序增长。这个顺序
是从第(8)行到第(12)行。该阶段从左边(或者说从低地址端)开始访问堆中的已分配部分的每
方法：图7-28 显示了这个算法。Cheney 算法在 From 半空间中找出可达对象，并且访问到
输出：最后，To 半空间保存已分配的对象。free 指针指明了 To 半空间中剩余空闲空间的开
说 B。当垃圾回收完成时，两个半空间的角色进行对换。增变者可以继续运行，并在半空间
拷贝回收器预先保留了可以将对象移入的空间，因而解除了跟踪和发现空闲空间之间的依
置。最后，第(18)和(19)行重新确定根集元素中的指针指向的目标，这些元素本身不是堆
第(8)行首先将free 指针设定为指向堆区的低端。在这个阶段，我们使用free 来指示第--
运行时刻环境
在探讨算法本身（即图7-28 中的函数CopyingCollector)之前，首先考虑第（11)行到第（16）行
输入：一-个由对象组成的根集，一个包含了 From 半空间和 To 半空间的堆区，其中 From 半空
从第(13)行到第(17)行是最后阶段，此时我们再次按照第二阶段中的自左向右的顺序访问
第(1)行到第(7)行的第一(或标记)阶段在本质上和算法7.12 的第一阶段相同。第二阶段
含了已分配对象，T半空间全部是空闲的。
Cheney 的拷贝回收器。
下一轮垃圾回收将把可达对象移动到 A。下面的算法是由 C.J. Cheney 提出的。
图7-27
将已被访问对象移动到堆的前部,同时保持内部指针的指向关系
空闲
空闲
7
309
B
口
---
## Page 326
用，从它在 From 半空间中的原值被翻译为在 To半空间中的值。请注意，因为函数副作用，如果
待扫描状态的对象。第(7)行处理下一个待扫描的对象0。在第(8）、（9)行，对于中的每个引
时将进人第(6)行到第(10)行的循环。然后，这个循环扫描所有已经被加人到 To 空间中并处于
此，除非没有被根集引用的对象(在这种情况下，整个堆区都是垃圾)，当程序第--次运行到这里
对 LookupNenuLocation 的某些调用会在 To 中为这些对象分配存储块，同时增加 free 指针的值。
中检查的对象中的所有引用都是指向 From 空间的。
我们就完成了垃圾回收工作。请注意，我们是在To空间中完成垃圾回收工作的，尽管在第(8)行
态。因此,fee 总是在 unscanned 的前面。当后者追上前者时就表示不存在更多的待扫描对象了.
unscanned 的对象将处于已扫描状态，而那些位于unscanned 和free 之间的对象则处于待扫描状
free 将总是指向 To半空间中空闲空间的起始位置。当我们往 To 空间加人对象时，那些地址低于
在第(3)行中，我们初始化两个指针unscanned 和free，使它们都指向 To半空间的开始位置。指针
的位置，第(16)行返回在To空间中的位置。
用。这个副作用发生在我们第一次为这个对象寻找新地址的时候。不管之前有没有设定对象（
空间拷贝到To 空间。因此，对象从一个半空间到另一个半空间的移动实际上是一个函数的副作
空间的开始位置。第(14)行使free 指针增加。所占的空间数量。在第(15)行，我们将o从 From
化，但是现在假设它是-一个哈希表就行了。
值 Null用来表示还没有为。分配空间。和算法 7.15一样，NenLocation 结构的具体形式可以变
在一个典型的数据结构中(如散列表)，如果。没有被赋予一个位置，那么在这个结构中就没有相关信息。
第(4)行和第(5)行处理可以从根集访问到的对象。请注意，因为函数副作用，在第(5)行
如果我们在第(12)行发现。没有存储位置，那么在第(13)行上它将被赋予 To半空间中空闲
310
现在我们可以考虑这个算法本身了。第(2)行确保 From 空间中的所有对象都还没有新地址。
GEEEE
否则将对象设置为待扫描状态*/
/*如果一个对象已经被移动过了，查找这个对象的新位置*/
CopyingCollector () {
return NewLocation(o);
while (uns
for（根集中的每个引用r）
图7-28
将对象o拷贝到NewLocation(o);
free = free +
unscanned =
将r替换为LookupNeuLocations(r);
0.7 =
jree
一个拷贝垃圾回收器
unscanned + sizcof(o)
To空间的开始地址；
第7章
因
中
---
## Page 327