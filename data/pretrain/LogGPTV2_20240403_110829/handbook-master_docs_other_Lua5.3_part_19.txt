### io.write
> io.write (···)
等价于 io.output():write(···)。
### file:close
> file:close ()
关闭 file。 注意，文件在句柄被垃圾回收时会自动关闭， 但是多久以后发生，时间不可预期的。
当关闭用 io.popen 创建出来的文件句柄时， file:close 返回 os.execute 会返回的一样的值。
### file:flush
> file:flush ()
将写入的数据保存到 file 中。
### file:lines
> file:lines (···)
返回一个迭代器函数， 每次调用迭代器时，都从文件中按指定格式读数据。 如果没有指定格式，使用默认值 "l" 。 看一个例子
     for c in file:lines(1) do body end
会从文件当前位置开始，中不断读出字符。 和 io.lines 不同， 这个函数在循环结束后不会关闭文件。
在出错的情况下，函数抛出错误而不是返回错误码。
### file:read
> file:read (···)
读文件 file， 指定的格式决定了要读什么。 对于每种格式，函数返回读出的字符对应的字符串或数字。 若不能以该格式对应读出数据则返回 nil。 （对于最后这种情况， 函数不会读出后续的格式。） 当调用时不传格式，它会使用默认格式读下一行（见下面描述）。
提供的格式有
- "n": 读取一个数字，根据 Lua 的转换文法，可能返回浮点数或整数。 （数字可以有前置或后置的空格，以及符号。） 只要能构成合法的数字，这个格式总是去读尽量长的串； 如果读出来的前缀无法构成合法的数字 （比如空串，"0x" 或 "3.4e-"）， 就中止函数运行，返回 nil。
- "i": 读取一个整数，返回整数值。
- "a": 从当前位置开始读取整个文件。 如果已在文件末尾，返回空串。
- "l": 读取一行并忽略行结束标记。 当在文件末尾时，返回 nil 这是默认格式。
- "L": 读取一行并保留行结束标记（如果有的话）， 当在文件末尾时，返回 nil。
- number: 读取一个不超过这个数量字节数的字符串。 当在文件末尾时，返回 nil。 如果 number 为零， 它什么也不读，返回一个空串。 当在文件末尾时，返回 nil。
格式 "l" 和 "L" 只能用于文本文件。
### file:seek
> file:seek ([whence [, offset]])
设置及获取基于文件开头处计算出的位置。 设置的位置由 offset 和 whence 字符串 whence 指定的基点决定。基点可以是：
- "set": 基点为 0 （文件开头）；
- "cur": 基点为当前位置了；
- "end": 基点为文件尾；
当 seek 成功时，返回最终从文件开头计算起的文件的位置。 当 seek 失败时，返回 nil 加上一个错误描述字符串。
whence 的默认值是 "cur"， offset 默认为 0 。 因此，调用 file:seek() 可以返回文件当前位置，并不改变它； 调用 file:seek("set") 将位置设为文件开头（并返回 0）； 调用 file:seek("end") 将位置设到文件末尾，并返回文件大小。
### file:setvbuf
> file:setvbuf (mode [, size])
设置输出文件的缓冲模式。 有三种模式：
- "no": 不缓冲；输出操作立刻生效。
- "full": 完全缓冲；只有在缓存满或当你显式的对文件调用 flush（参见 io.flush）时才真正做输出操作。
- "line": 行缓冲； 输出将到每次换行前， 对于某些特殊文件（例如终端设备）缓冲到任何输入前。
对于后两种情况，size 以字节数为单位 指定缓冲区大小。 默认会有一个恰当的大小。
### file:write
> file:write (···)
将参数的值逐个写入 file。 参数必须是字符串或数字。
成功时，函数返回 file。 否则返回 nil 加错误描述字符串。
## 操作系统库
这个库都通过表 os 实现。
### os.clock
> os.clock ()
返回程序使用的按秒计 CPU 时间的近似值。
### os.date 
> os.date ([format [, time]])
返回一个包含日期及时刻的字符串或表。 格式化方法取决于所给字符串 format。
如果提供了 time 参数， 格式化这个时间 （这个值的含义参见 os.time 函数）。 否则，date 格式化当前时间。
如果 format 以 '!' 打头， 日期以协调世界时格式化。 在这个可选字符项之后， 如果 format 为字符串 "*t"， date 返回有后续域的表： year （四位数字），month （1–12），day （1–31）， hour （0–23），min （0–59），sec （0–61）， wday （星期几，星期天为 1 ）， yday （当年的第几天）， 以及 isdst （夏令时标记，一个布尔量）。 对于最后一个域，如果该信息不提供的话就不存在。
如果 format 并非 "*t"， date 以字符串形式返回， 格式化方法遵循 ISO C 函数 strftime 的规则。
如果不传参数调用， date 返回一个合理的日期时间串， 格式取决于宿主程序以及当前的区域设置 （即，os.date() 等价于 os.date("%c")）。
在非 POSIX 系统上， 由于这个函数依赖 C 函数 gmtime 和 localtime， 它可能并非线程安全的。
### os.difftime
> os.difftime (t2, t1)
返回以秒计算的时刻 t1 到 t2 的差值。 （这里的时刻是由 os.time 返回的值）。 在 POSIX，Windows，和其它一些系统中，这个值就等于 t2-t1。
### os.execute
> os.execute ([command])
这个函数等价于 ISO C 函数 system。 它调用系统解释器执行 command。 如果命令成功运行完毕，第一个返回值就是 true， 否则是 nil otherwise。 在第一个返回值之后，函数返回一个字符串加一个数字。如下：
"exit": 命令正常结束； 接下来的数字是命令的退出状态码。
"signal": 命令被信号打断； 接下来的数字是打断该命令的信号。
如果不带参数调用， os.execute 在系统解释器存在的时候返回真。
### os.exit
> os.exit ([code [, close]])
调用 ISO C 函数 exit 终止宿主程序。 如果 code 为 true， 返回的状态码是 EXIT_SUCCESS； 如果 code 为 false， 返回的状态码是 EXIT_FAILURE； 如果 code 是一个数字， 返回的状态码就是这个数字。 code 的默认值为 true。
如果第二个可选参数 close 为真， 在退出前关闭 Lua 状态机。
### os.getenv
> os.getenv (varname)
返回进程环境变量 varname 的值， 如果该变量未定义，返回 nil 。
### os.remove
> os.remove (filename)
删除指定名字的文件（在 POSIX 系统上可以是一个空目录） 如果函数失败，返回 nil 加一个错误描述串及出错码。
### os.rename
> os.rename (oldname, newname)
将名字为 oldname 的文件或目录更名为 newname。 如果函数失败，返回 nil 加一个错误描述串及出错码。
### os.setlocale
> os.setlocale (locale [, category])
设置程序的当前区域。 locale 是一个区域设置的系统相关字符串； category 是一个描述有改变哪个分类的可选字符串： "all"，"collate"， "ctype"， "monetary"， "numeric"， 或 "time"； 默认的分类为 "all"。 此函数返回新区域的名字。 如果请求未被获准，返回 nil 。
当 locale 是一个空串， 当前区域被设置为一个在实现中定义好的本地区域。 当 locale 为字符串 "C"， 当前区域被设置为标准 C 区域。
当第一个参数为 nil 时， 此函数仅返回当前区域指定分类的名字。
由于这个函数依赖 C 函数 setlocale， 它可能并非线程安全的。
### os.time
> os.time ([table])
当不传参数时，返回当前时刻。 如果传入一张表，就返回由这张表表示的时刻。 这张表必须包含域 year，month，及 day； 可以包含有 hour （默认为 12 ）， min （默认为 0）， sec （默认为 0），以及 isdst （默认为 nil）。 关于这些域的详细描述，参见 os.date 函数。
返回值是一个含义由你的系统决定的数字。 在 POSIX，Windows，和其它一些系统中， 这个数字统计了从指定时间（"epoch"）开始经历的秒数。 对于另外的系统，其含义未定义， 你只能把 time 的返回数字用于 os.date 和 os.difftime 的参数。
### os.tmpname
> os.tmpname ()
返回一个可用于临时文件的文件名字符串。 这个文件在使用前必须显式打开，不再使用时需要显式删除。
在 POSIX 系统上， 这个函数会以此文件名创建一个文件以回避安全风险。 （别人可能未经允许在获取到这个文件名到创建该文件之间的时刻创建此文件。） 你依旧需要在使用它的时候先打开，并最后删除（即使你没使用到）。
只有有可能，你更应该使用 io.tmpfile， 因为该文件可以在程序结束时自动删除。
## 调试库
这个库提供了 Lua 程序调试接口（§4.9）的功能。 其中一些函数违反了 Lua 代码的基本假定 （例如，不会从函数之外访问函数的局部变量； 用户数据的元表不会被 Lua 代码修改； Lua 程序不会崩溃）， 因此它们有可能危害到其它代码的安全性。 此外，库里的一些函数可能运行的很慢。
这个库里的所有函数都提供在表 debug 内。 所有操作线程的函数，可选的第一个参数都是针对的线程。 默认值永远是当前线程。
### debug.debug
> debug.debug ()
进入一个用户交互模式，运行用户输入的每个字符串。 使用简单的命令以及其它调试设置，用户可以检阅全局变量和局部变量， 改变变量的值，计算一些表达式，等等。 输入一行仅包含 cont 的字符串将结束这个函数， 这样调用者就可以继续向下运行。
注意，debug.debug 输入的命令在文法上并没有内嵌到任何函数中， 因此不能直接去访问局部变量。
### debug.gethook
> debug.gethook ([thread])
返回三个表示线程钩子设置的值： 当前钩子函数，当前钩子掩码，当前钩子计数 （debug.sethook 设置的那些）。
### debug.getinfo
> debug.getinfo ([thread,] f [, what])
返回关于一个函数信息的表。 你可以直接提供该函数， 也可以用一个数字 f 表示该函数。 数字 f 表示运行在指定线程的调用栈对应层次上的函数： 0 层表示当前函数（getinfo 自身）； 1 层表示调用 getinfo 的函数 （除非是尾调用，这种情况不计入栈）；等等。 如果 f 是一个比活动函数数量还大的数字， getinfo 返回 nil。
只有字符串 what 中有描述要填充哪些项， 返回的表可以包含 lua_getinfo 能返回的所有项。 what 默认是返回提供的除合法行号表外的所有信息。 对于选项 'f' ，会在可能的情况下，增加 func 域保存函数自身。 对于选项 'L' ，会在可能的情况下，增加 activelines 域保存合法行号表。
例如,表达式 debug.getinfo(1,"n") 返回带有当前函数名字信息的表（如果找的到名字的话）， 表达式 debug.getinfo(print) 返回关于 print 函数的 包含有所有能提供信息的表。
### debug.getlocal
> debug.getlocal ([thread,] f, local)
此函数返回在栈的 f 层处函数的索引为 local 的局部变量 的名字和值。 这个函数不仅用于访问显式定义的局部变量，也包括形参、临时变量等。
第一个形参或是定义的第一个局部变量的索引为 1 ， 然后遵循在代码中定义次序，以次类推。 其中只计算函数当前作用域的活动变量。 负索引指可变参数； -1 指第一个可变参数。 如果该索引处没有变量，函数返回 nil。 若指定的层次越界，抛出错误。 （你可以调用 debug.getinfo 来检查层次是否合法。）
以 '(' （开括号）打头的变量名表示没有名字的变量 （比如是循环控制用到的控制变量， 或是去除了调试信息的代码块）。
参数 f 也可以是一个函数。 这种情况下，getlocal 仅返回函数形参的名字。
### debug.getmetatable
> debug.getmetatable (value)
返回给定 value 的元表。 若其没有元表则返回 nil 。
### debug.getregistry
> debug.getregistry ()
返回注册表（参见 §4.5）。
### debug.getupvalue
> debug.getupvalue (f, up)