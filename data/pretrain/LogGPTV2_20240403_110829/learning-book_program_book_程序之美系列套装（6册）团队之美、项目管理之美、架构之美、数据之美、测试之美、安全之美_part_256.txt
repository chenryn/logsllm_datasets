## Page 1447
想象从一个不相关的系统中得到了第三条记录，比如会员俱乐部登
记系统，它反映了家庭地址和家庭电话号码之间先前未知的链接。
什么样的企业系统会用于检测这种被我们称之为“非显署关系”
(nnobviousrelationship)的条件？
数据发现数据，包括非显著关系条件，要求人们首先解决“企业的
可发现性"问题。
1值得注意的是，赌场监督的作用是提供情报。他们报告自已的
观察和发现，但是没有执行力；执行力是安全部门所发挥的作用。
[2]这种被称为"无明显的关系意识"(Nn-ObviousRelationship
Awareness,NORA)技术，由Systems Research&Development，即SRD
公司（由JefJonas成立）为拉斯维加斯的游戏行业开发。SRD公司
从那以后被IBM收购，现在是IBM的实体分析部门的一部分。这里
有一些额外的信息——IEEE论文：Threat&FraudIntelligence-Las
Vegas
tml) 。
企业的可发现性
当企业中有新的信息到达时，不论是来了一个新员工、员工的某条
记录更新、剽窃者信息或者是会员俱乐部登记，人们需要记住其他
什么组织数据和这个信息相关。
企业发现的一个常见办法是采用“联合搜索”技术，把查询传递给每
个相关的业务系统。正如我们所证明的，这种方式对于数据发现数
据系统并不适用。可发现性，尤其是在大规模、实时的环境中，目
录是必需的。
联合搜索不是万能的
企业组织有众多的业务系统，每个系统都有自已专用的业务功能、
定制的信息结构、分析和报告。二级数据聚合是很常见的，而且包
含如数据仓库、业务数据存储和数据集市。数据聚合存在无数的信
息孤岛，每个孤岛都和特定的任务或功能相关。
1446
---
## Page 1448
传统的联合搜索系统涉及用户查询每个孤岛的数据库，获取相关内
容。更复杂的联合搜索系统使用智能中间件，为数据库的每个查询
做代理；智能中间件是一个模型，在该模型中，中间件通过自动结
合各种信息来处理查询，并对查询的结果进行编制，返回集成的结
果集给查询者。
在需要信息的时候，联合搜索“即时"收集跨孤岛的数据。虽然这种
类型的联合搜索在一些场景下是可用的，但是无法很好地适合于高
性能的企业可发现性，后者需要根据数据发现数据来生成。
有两种主要的原因使得联合搜索无法扩展：
现有的系统通常不包含高效定位一条记录所需的必要的索引。如支
付系统通常会包·含预先构建的索引（对数据定义指针），从而有助
于在员工号码、纳税ID号码和名字进行查询。支付系统很少会包含
高效的方式来定位地址或者电话号码上的记录。假设新发现的赌博
诈骗者暴露了他的地址和电话号码。我们的支付系统保留所有员工
的电话号码和地址记录（毕竞它需要发送支票）。但是该支付系统
无法简单地生成（如果它可以）员工的列表，这些员工和之前提到
的赌博诈骗有相同的地址或电话号码。即使在支付系统中为员工的
电话号码中创建了一条索引，但是它仍然无法使人们在相同的系统
中定位紧急联系电话号码。如果我们无法对赌博诈骗者的验证信息
和所有相关的员工数据进行比较，我们还是错过了发现员工和诈骗
著之间的联系。
如果某个字段不在索引中，在数据库中定位一条记录的方法称为
“表扫描”。在表扫描过程中，对搜索的值和表中每条记录的值进行
比较一—从数据库中的第一条记录开始比较，到第二条，等等。因
此，数据库越大，每次搜索花费的时间越长，因而主服务器系统上
的计算压力就越大。
更糟糕的是，联合搜索需要递归处理（某些情况下需要重复一些步
骤），这对于分·布式查询环境简直是一场墨梦。假设你执行一条联
合查询，是为了发现和某个特定的人相关的企业记录一—也就是
说，根据某个特定的人的名字和出生日期并始查询。如果联合查询
返回这个人的一些新的属性，如一些地址和电话号码，那么你就了
解了一些新的东西。为了更全面地了解，需要最大化利用所了解到
的关于这个人的新数据，也就是说，初始化另一个企业范围的联合
查询，防止基于这些新的数据点，定位额外的数据。因此，如果第
1447
---
## Page 1449
二次的联合查询发现了另一个地址，拼写名字的多种方式，以及一
两个别名，那么又会发生什么情况呢？更具体全面地说，每次了解
一些能够发现先前丢失的记录的知识，发现过程必须执行另一个企
业范围的联合查询。
下面这个真实的案例强调了这一点。某个企业组织（一个商业实
体，不是政府）有2000多个数据库。用户查询被定向到这些数据库
中来收集相关的记录。为优化搜索过程而设计的优秀的中间件产品
需要花很多年的时间，以及儿百万美元的成本。这种智能的系统会
识别哪个数据库应该处理哪个查询，确定合理的数据库访问方式，
把查询同时传播给所有相关的集合，并汇集了解到的知识。但是，
这种联合搜索方式永远都无法克服一个严重的设计缺陷：每次发现
了解一些知识（如一个别名或者一个新的电话号码），优秀的中间
件必须重新把这些查询发给很多数据库。这种递归过程运行在大规
模的计算机集群中，最终需要定制为每8分钟停止处理。注意下一
次的递归查询可能最终会发现一条重要记录。
但是，需要8分钟！这意味着用户或者系统只能等着，无法执行任
何操作，因为在这段期间内无法获取到任何答案。然而，在数据发
现数据的情况下，数据是个问题。这意味着每当有新的数据到达，
在处理这些数据之前会有最多高达8分钟的延迟。想象一下，在整
个企业网络，每秒提交成百上千的联合查询的规模下，通过无数的
业务系统递归执行，使用联合查询这种方式是多么得不切实际！
如果以上提到的因素还不具有足够的吸引力，联合搜索的致命一击
是所有必须搜索的系统在物理上必须是可访问的，而不是处于维护
或者备份状态，或者处在周期性的半夜或者月末的批处理过程中。
当然，连接性也必须是完全可运作的。考虑这些需求以及由成百上
千的涉及建筑、时区和大陆的系统组成的组织。联合搜索无法支持
“数据发现数据”的任务，因为它无法大规模地基于企业的发现力来
发布数据。
目录：无价之宝
想想一个图书馆。把图书馆的地板、走廊和书架想象成存储信息的
孤岛。有价值的信息被搁置一边，等待着我们去发现。人们不需要
为了寻找特定的一本书而走遍图书馆大厅。相反地，人们会使用卡
片分类目录，在主题、标题和作者上执行交叉索引来帮助查找相关
1448
---
## Page 1450
的文档。目录、索引和分类目录基本上指的是相同的东西：都是用
于定位其他东西。
定位器的例子包括图书馆的卡片目录、电话号码目录和eBay等。对
于每种定位器，目录相当于定位器服务：当对它们提供一个或者多
个查询项时，这些定位器会返回引用信息（指针）。在图书馆，卡
片分类目录是为了促进高效的企业搜索的一个特定目录，它为用户
提供指向文档的特定的指针（如：使用Dewey十进制系统）。当提
供给用户一个指针后，就变成“联合搜索”。注意（有用的）联合搜
索和（无用的）联合搜索之间的区别。
G公司的搜索也不是扫描整个地球来获取搜索结果；相反，它是搜
索G公司创建的一个特定目录，然后把搜索结果指向真正文档的指
针返回给查询者。
企业范围的可发现性的唯一可扩展解决方案是使用目录。这并不奇
怪。因此，一个特定的目录是最根本的部分，它允许“数据发现数
据”系统有规模地处理可发现性和实时地确定相关性。
不是所有的目录都是等同的。传统的"上下文无关"的目录和能够累
计并持久的上下文的目录之间存在很大的区别。上下文相关的目录
使得数据发现数据可以通过非常令人意外（不显著）的、实时、大
量的方式，而且效率非常高效。
上下文无关的目录是最常见的目录类型：每个文档的索引和所有其
他文档不相关。换句话说，新的企业交易（文档）更新目录，并不
关心该交易（索引的元数据）和其他交易之间的关系。上下文无关
的目录是为了给用户提供最基本的定位文档的能力而设计的（如所
有和"BillytheKid"相关的书）。
语义上一致的目录是那些试着利用同义词的目录，使用不同的单
theKid"）应该能够找到其他“相同"的东西（如"WilliamAntrim"，他
的一个别名）。当一个新报告的实体引用了之前观察到的实体，语
义一致的目录能够做出识别。包含语义一致的数据的目录可以看成
是图书馆的一个卡片文件，这有一个很大区别：和类似的实体相关
的卡片被胶合在一起。这意味着如果一个搜索定位到了一张卡片，
“作为奖励”，它不需要付出额外的努力就可以发现所有其他相关的
1449
---
## Page 1451
卡片。最显著的是，在这些胶合在一起的图书馆卡片中，有些甚至
不包含被搜索时的原始数据项。
坦白地说，这一切看起来很神奇。当试着去发现该企业对于某个
Email地址的了解程度时，查询者会发现和该Email地址相关的记录
以及关于这个人在企业中的其他记录一举个例子，某个会员俱乐
部，虽然实际上它的记录中从来都没有包含Email地址。语义上协调
身份的算法（如人们或者组织）有时被认为是身份识别21。确定多
个实体什么时候是相同的实体的算法需要非常深入细致的讨论，因
而超出了本章讨论的范围。
语义一致且“有关系意识"(rlationship-aware)的目录是提供了更高程
度的上下文的一种目录类型，它通过允许用户发现额外文档，如那
些和私人相关的关联（如BillytheKid就是WilliamAntrim)。可能知
道实际上确实有WilliamAntrim可能也是很重要的，而且这个人碰巧
是BillytheKid的继父。对这些达到可视化的方式是在脑海里画一张
图书馆卡片目录，其中一些卡片如前所述，已经通过胶带系在一
起，还有一些线条连接到一些卡片捆绑(bndle)到其他卡片以及其他
卡片捆绑。人们可以搜索任意术语的某个集合，并定位一个卡片捆
绑，并且在那时弄清楚该捆绑是如何和其他捆绑关联（相关）的。
有些关联的线条比其他线条粗，这表明它们关联关系更强。通过一
条线找到另一个卡片捆绑，人们可以马上看到是什么线条连接到下
一个捆绑。通过这种方式，人们可以观察到这些卡片捆绑分离的程
度，如KevinBacon所提出的六度分割理论。
当思考“数据发现数据”系统时，必须记住当有新的交易发生时，可
能是把当前已经存在的实体增加到上下文中，那么就有可能会发生
由于捆绑和线条的重新组织，新的信息改变了图片的大小。
持久性上下文(Prsistentcontext)是个术语，用于表示一致的、“有关
系意识"的当前状态。从本质上讲，它指的是不断变化和越来越复
杂的当前状态。持久性上下文是保存了事物间相关性，优于在联合
搜索系统中用到的“即时"性上下文(Jst-in-timecontext)。
持久性上下文（语义上一致且“有关系意识"的路径）能够促使高性
能的发现、流语境化以及实时检测相关性。同样值得注意的是，如
果相关性检测可以在获取数据时发生，其计算代价是最低的。从这
方面来看，图书管理员（负责把新数据补到目录中）是第一个发现
新到来的数据和待发布的数据是否有足够的相关性。
1450
---
## Page 1452
意识的溪流胜过沸腾的海洋。想象这一点的一种清晰的方式是想象
一个企业组织有4exabytes（1exabytes=216字节）的历史数据，每
分钟接收5TB的数据。你觉得他们是在周末启动一个进程，用来发
现发生的事吗？在整个地球上，可能没有足够的计算机或者能源来
做这件事。（注意：规模上设想的行为在设计非常高效的系统时，
被证明是非常有效的。）
[1]定义为“当两个东西描述上虽然不同，但实质相同，能够做出识
别”。
[2].不要把身份识别和类似的有时被称为匹配/归并或归并/清洗的一
组方法混淆。更多关于它们之间的区别，可参考文章“Entity
Resolution Systems vs.Match Merge/Merge Purge/List De-duplication