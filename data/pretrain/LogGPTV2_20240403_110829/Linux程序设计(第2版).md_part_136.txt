schar: setting timer up_again, 4096 data now
schar: putting process with pid 889 to sleep
1024个字节。定时器处理器在每次运行时都会唤醒那个读数据进程（如果你运行不止一个进程，
就会把它们都唤醒），告诉它们可供读取的数据已经增加了。当数据池里的数据量达到4096个字
节时，cp命令就会接收它的第一段数据，然后再重新开始这一过程。
加入jaVa编程群：524621833
---
## Page 735
718Linux程序设计
21.4.3让出处理器
与其循环等待一段时间的流逝，不如采用“把当前进程的执行挂起来，等这段时间流逝过
以后再恢复执行”这种更好的办法。改变进程的状态并调用进程调度器（scheduler）就可以实
现这一目的。我们在前面的内容里解释过Linux的任务结构，这个结构里的state项给出的就是任
务的状态，它可以取表21-10中任何--个值：
表21-10
TASK_RUNNING
进程测度器上次运行时选择这个任务，它目前正处于运行状态。当的进程适人
驱动程序时就是这个状态
TASK_INTERRUPTIBLE
任务处于一种休眠状态，短可以被信号唤醒
TASK_IUNINTERRUPTIBLE
任务处于一种体账状态，并且不能被信号唤眼。这种进可能正在等待某个事件
的发生，而在事件发生之前唤醒它是没有意义的
还有--些其他的状态，但与我们这里的情况没有什么关系。在linux/sched.h文件里可以金到
全部的任务状态。
在调用进程调度器之前，必须把current->state的值设置为TASK_INTERRUPTIBLE或
TASK_UNINTERRUPTIBLE。具体使用哪个状态要视进程等待的条件面定。对有的进程来说，
在它等待的事件发生之前唤醒它是没有意义的，并且把它放到一种不可中断的休眠状态是最
符合逻辑的选择一只有对这样的情况才应该使用后一种设置。大多数问题都不需要这样来解
决-—如果你用grep命令检索Linux的源代码，就会发现只有非常少的几个地方使用了
TASK_UNINTERRUPTIBLE。其中的一个例子是：当需要把属于某个进程的内存页面从硬盘
上的交换分区加载到内存里来的时候，如果这项工作还没有完成，我们就不能让那个进程被
唤醒。
下面是设置任务状态的原理性代码：
Cvrrent ->state = TASK_INTERRUPTIBLE :
schedule() ;
进程被挂了起来，调度器开始运行。可我们怎样才能知道进程何时重返回来呢？如果接下
来没有合适的进程来运行，就会再次选中并执行同一任务，而它几乎是立刻又停止在刚才的位
置上了。这就是schedule_timcout出马的时候了-一我们不再调用schedule面是调用
schedule_timeout，它返回的是进程还将休眠的时基数字。调度器将保证在设定的时间流逝过去
之前不选择该进程去执行。如下所示：
/* put che process away for a second */
current->state = TASK_INTERRUPTIBLE;
schedule_timeout (H2) :
参数HZ是进程再次执行之前将要休眠的时基数。schedule_imeout的内部上作原理是很有意
思的一它使用了一个内核定时器，定时器的data参数就是当前进程的地址。在安排好定时器之
后，schedule_timeout再调用schedule来调度白己；它的定时器处理函数的工.作很简单---根据保
存在data参数里的地址把与之对应的进程唤醒就完事了。如果读者有兴趣，可以自行研究
kernel/sched.c文件。
加入jaVa编程群：524621833
---
## Page 736
第21章设备驱动程序
719
21.4.4任务队列
我们已经知道如何利用定时器在未来的某个时刻去唤醒进程了。定时器确实很方便，而1
我们还可以利用它把工作推迟到未来某个时刻去执行、等到我们和中断处理例程及中断的后处
理（它们与任务队列密切相关）打交道的时候，这就更有意息了。我们现在先来看看任务队列
的情况，中断处理方面的内容留到下一小节再讨论：
struct tq_struct (
struct tq_struct *next:
/* 1inked list ot active bh's *
void {*routinel(void *):
unsigned long sync;
/*nust be initialized to zero*/
/* argument to function */
void *data:
这个结构定义出现在linux/tqueue.h头文件里。和往常一样，大家最好不要自已去改动这个
结构里的数据域。内部使用的*next指针把队列中的任务串在一个链接列表里，参数sync将保证
同一任务不会在队列里出现两次。这会造成链接列表的数据崩溃，有了sync之后，如果你还想
让--个任务排两次队，你的第二次排队请求就会被屏蔽。
内核里有一些预先定义好的任务队列：我们先介绍如何定义自己的队列：
DSCLARE_TASK_QUEUE q_task) 
( NULL, 0. (void *)q_task_handler;
sq_task }:
这就是队列中结构的定义。这基本上就是从头文件里直接抄下来内容，惟一不同的是我们
定义了自己的任务队列处理函数，并且在定义之后立刻把它投人了使用。在上面的代码里，
DECLARE_TASK_QUEUE是把队列初始化为NULL的宏定义；q_task就是我们的任务队列；任
务队列q_run调用q_task_handler函数对队列里的任务进行处理。给这个任务队列添加一个新进程
要使用：
queue_task1&q_run, &q_task 1;
queue_task可以被调用任意次数，准备好执行队列里的任务时，调用run_task_queue，排在
q.task队列里的任务会依次得到处理。如下所示：
run_task_queue (&q_task 1;
21.4.5预定义任务队列
我们不准备对用户定义的任务队列做过多的讨论，因为内核已经预备下儿个任务队列供我
们使用，而大部分情况下有它们就足够了。你儿乎不需要创建自己的任务队列见表21-11。
表21-11
tq_immediate
这个队列里的任务会尽可能还速地得到运行。我们将在中断处理部分对它做详细讨论
tα_cimer
定时器每跳动--个数字，tq_imer就得到一次运行机会。这个队列是内核提供给内核定时
益内部使用的
tq_scheduler
调度器每调用一次，这个队列就得到一次运行机会—如果这个队列男有任务在排认的话
tq_disk
VFS和数器块处理承数大多使用这个队列来处理操作请求
加入jaVa编程群：524621833
---
## Page 737
720Linux程序设计
很明显，前三个队列是最有意思的；第四个tqg_disk队列有非常特殊的用途，所以你最好离
它远点。排除tg_disk队列不算，前三个队列是按照任务进人其中后得到运行机会的快慢顺序排
列的（第-个最快）
在使用内建的任务队列的时候，根本用不着你自己去发出run_task_queue调用。根据你使用
的是哪一个队列，你只要在任务添加到其中之后给那个队列加上一个标记、它就会自动运行了。
在介绍如何给队列加上运行标记之前，我们先来快速了解一下如何在linux里实现中断的后处理。
在讲述中断处理内容的小节里我们将对中断的后处理做更深入的讨论，但它们与任务队列
有密切的关系，所以我们先在这里用它们做个例子.简单地说，中断处理可以被分为两个部分
一前处理和后处理。前处理部分负责接收中断并完成紧急、基本的处理，比如把它通知给设备
等：而后处理部分会销后再运行、它负责对前处理部分接收到的数据进行具体的处理。这就使
Linux里的中断处理器能够处理的中断个数要多于它能管理的中断种类数。
事实，任务队列在Linux里被实现为后处理。内核从调度器里通过do_bottom_half来执行
被标记为活跃的后处理部分。内核在linux/interrupL.h文件里维护着一个各种可能的后处理名单。
下面是具中的一段：
enum [
TIMER_SH = 0.
CONSOLE_BH
TQUEUE_BH.
IMMEDIATE_BH,
r
这是一些老式的嵌人式后处理，它们都有特殊的用途，模块不能直接访问它们。在这个头
文件里你找不到与tg_scheduler对应的项，这是因为它不需要加上执行标记。调度器做的第-一件
事就是查看tq_scheduler里有没有排队的任务，如果有就执行它们。这也就意味着每次调用调度
器的时候，这个队列都会被运行：这取决于许多因素。
如果tq_timer队列里有排着队的任务，就会在定时器每次跳动的时候被运行，因此它也不需
要加上执行标记。这也意味着等候在这个队列里的任务是在中断时间里运行的，这就给它们能
够完成的工作加上了一定的限制，比如说，在中断时间里运行的函数不允许阻塞或休眠。这听
起来好象并不难做到，但你不要忘记这需要把这样一个函数的整个调用路径都考虑进来一一也就
是说，你不能调用任何可能会阻塞的函数。
最后一个可以考虑用做一般用途的队列是tq_immediate。正如这个名字表示的那样（单词
immediate的意思是“立刻”），这个队列得到运行的机会是相当快的。它通常被用来推迟中断处
理器里的部分工作，我们会在中断处理部分用到它见表21-12。
表21-12
void init_bh(int nr,void(*routine) (void))
把函数routine设置为ar的后处理部分
void mark_bh(int nr)
把nr的对应位标记为bh_active：这样，当调度器被
湖用时就会运行这个任务队列
tq_immediate是惟一需要明确标记的队列，这是因为它的预定用途是做为后处理部分。我们
加入jaVa编程群：524621833
---
## Page 738
第21章设备驱动程序
721
将在中断处理部分给出几个任务队列和后处理的例子。
21.4.6小结
我们从时基开始了这小节的学习、它可以被看嫩是内核的心跳。标准内核的时基类率是
每秒100，每经过一个时基就给jiffies变斌增加一个值。jiffie迟早会溢出归零，然后再从零重新
开始计时。因此，我们向驱动程序的编写人员介绍了四个宏命令来帮助他们判断一段预定的时
间是否已经流逝过去了：我们介绍了进程的再调度，它既可以通过一个倒计时数值来实现，也
可以通过强制调度器运行来选择一个新的进程去执行（此时它可能会再次选中同一个进程）：
我们还向大家介绍了内核定时器，并且演示了如何在Schar里通过它在今后某个给定的时刻
来调用一个特定的定时器处理函数。任务队列是推迟工作稍后再执行的另-种方法，但它们不
能准确地在未来某个给定的时刻被调用：并且，从整体上看，任务队列更适合需要快速响应的
处理工作或者运行成批的计算机作业。
21.5内存管理
在开始学习如何在驱动程序里正确地分配内存之前，我们先来看看内存管理方面的基本知
说的到底是什么可能还不太清楚。当你在用户空间应用程序里分配内存的时候，得到的并不
是计算机RAM里的一个完全归你个人使用的区段。当然，也许有一种操作系统在内存分配方
面使用的就是这种办法。如果真是这样，郑么，它允许你运行的应用程序也就只有其物理内
存能够容纳的那么多。Linux可不是这样-它假定还有更多的内存可供使用（这就是“虚拟
内存”这个术语的出处，意思是“不是真正存在的内存”），面分配给应用程序的都是些虚拟
地址。
虚拟地址和物理地址之间的映射保存在好几个结构里，它们构成了内存页面表。内存页面
表由三个层次组成-内存页面目录、内存页面中间目录和内存页面表项目，页面表项目指向的
内存页提供了一个虚拟地址的偏移量。这是内存管理的最底层，驱动程序的设计人员通常并不
需要直接与内存页面表打交道见图21-3。
层次！
层次2
层次3
内存页面
偏移量
虚拟地址到物理地址的转换
图21-3
加入jaVa编程群：524621833
---
## Page 739
722
Linux程序设计
21.5.1虚拟内存区
上面说的内存页而表驻留在虚拟内存区里。它们是一大片连续的虚拟内存地址，就向提供
给应用程序时那样。
struct vm_area_struct {
unsigned Long vm_start;
unsigned 1ong vm_end;
:0xdabed12o.d6d
struct vn_operations_struct *vm_ops;
struct f1le *vm_file;
unsigned long vm_offset;
这只是该结构一个高度浓缩了的版本，大家可以在linux/mm.h里查到它。我们对这个结构里我
们一会儿将会用到的几个成员做个介绍：vm_stan和vm_end分别代表虚拟内存区的开始和结尾；
v_page_prot是分配给这个虚拟内存区的保护属性一一它可以是共享、私用、可执行，等等：
vm_ops类似于字符设备和块设备使用的file_operations文件操作结构，它总结虚拟内存区上的操作
并把它们抽象为个结构；vm_offset是这个区域里的偏移量：而vm_file则用来把文件的内存映射
再进一步映射到虚拟内存区里。我们将在分析Schar的mmap函数时再对这个结构做深人的介绍。
某个特定进程所做的映射可以在/proc//maps处查到，它们每个都对应于-个独立的
vm_area_struct结构。与某个映射关联的虚拟内存区长度、总长度、保护属性等许多信息都可以
从proc注册项里读出来。
21.5.2地址空间
整个可编址内存区（在32位平台上是4GB）被分为两个主要部分内核空间和用户空间
4GB
内核
空间
PAGE_OFFSET, xC000000
应用程序
空间
16MB
Q
围21-4
加入jaVva编程群：524621833
---
## Page 740
第21章设备驱动程序723
（或者叫应用程序空间）。PAGE_OFFSET定义了这两个部分的分界线，这个值是可以修改的，
它的定义在asm/page.h文件里。内核空间被安排在分界线的上面，用户空间则位于分界线的下
面。PAGE_OFFSET在Intel平台上的缺省值是0xc0000000，也就是说，它给内核提供了大约
1GB的内存空间，剩下3GB给用户空间使用。因此，在intel平台上，从内核方面看到的虚拟地
址直接就是物理地址的一个偏移量。在其他平台上就未必如此了，那就必须对这两种地址进行
转换（图21-4）。
21.5.3内存地址的类型
做为一名设备驱动程序的编写者，你必须弄清楚有三个类型的地址：
·物理地址：这是“真正的”地址，它被用来描述计算机主板上的内存总线。
·虚拟地址：只有CPU和内核（通过它的内存页面表和TLB）知道虚拟地址。
·总线地址：CPU以外的所有设备：在某些平台上它与物理地址相同。
可见，如果你打算和一个外设卡进行交谈，你就不能给它一个虚拟地址并告诉它给你传递
多少多少字节来。因为外设卡访间不到内存页面表，所以它完全不知道内核和CPU采用的是什
么样的编址方案，也就不会懂得内存地址代表的是什么地方。类似地，内核对一切事物都使用
虚拟地址，而总线内存的访问则会随平台的不同而变化。Linux为这三种地址之间的转换准备了
一些方便的宏定义和函数。
void *phys_to_virt (unsigned 1ong address)
ansigned long virt_to_phys(void *address)
unsigned 1ong virt_to_bus(void *address)
void *bus_to_virt(unsigned long address)
与外部设备交谈需要在虚拟地址（内核知道哪对嘟）和总线地址（设备知道哪对哪）来回
进行转换。这与外设安装在哪种类型的总线上没有关系，它可以是PCI、ISA或者其他任何类型。
注意：只有在确实需要把一个指向内存区的指针明确地直接传递给设备的时候，才有必要跳过
不使用那些地址转换操作；DMA传输就是一个这样的例子。在其他情况里，我们一般都是从设
备的I/O内存或V/O端口那里来读取数据的。
21.5.4在设备驱动程序里申请内存
在目标机器上，内存都是以PAGE_SIZE长的内存块为单位而分配的。Intel平台上的页面长
度是4KB，面Alpha平台使用的是8KB的页面长度、而且这不是一个允许用户配置的选项。千万
记住页面长度在不同的平台上是不一样的。为驱动程序分配内存的办法有很多，最底层的办法