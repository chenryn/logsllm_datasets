这里，使用”.*”指代所有权限（配置，以及写和读）。”.*”意味着匹配任何队列
或者交换器名字。这样就允许cashing-tier对任何队列或者交换器执行配置、写
和读命令了。另一个例子可能会解释得更清楚。
假设你为cashing-tier授予在oakvhost上的权限。你想要允许该用户对任
何队列或者交换器可执行读操作，同时限制其只能对名字以checks-开始的队列和
交换器允许写操作。同时，你想要完全阻止配置操作。为达目的，你需要设计三个
正则表达式²：
■＂.*"匹配任何队列和交换器
■""不匹配队列和交换器（这就是如何对用户拒绝指定的权限）
把所有整合起来，像这样执行set_permissions：
$ ./rabbitmqctl set_permissions -p oak \
-S all cashing-tier "" "checks-.*" ".*"
...done.
你可以通过使用rabbitmqctl的1ist_permissions命令来验证权限是否正
确地赋予给了oakvhost。
Listing permissions in vhost "oak" ...
cashing-tier
checks-.*
all
...done.
2RabbitMQ权限支持标准的Perl兼容的正则表达式（PCRE）语法。
---
## Page 75
3.2请求许可
53
从显示的结果中可以看到，在cashing-tier和"checks-.*”之间的空白列
就是你为设置配置权限传入的空白（“”）值。你会发现，权限配置正确地应用到了
oakvhost上，同时队列／交换器也如你所愿被保护起来了。如果想要删除这些权限
控制，该怎么办呢？你可以通过使用rabbitmqctl的clear_permissions命令
移除一个用户在任何vhost上的权限：
$./rabbitmqctl clear_permissions -p oak cashing-tier
Clearing permissions for user "cashing-tier" in vhost "oak" ...
...done.
通过运行list_permissions命令，你会看到权限都已经被移除干净了。
... "xeo" asoua uT SuotsstWrad buTaSTT
...done.
有权限。如果你只想要修改用户现存的权限，则只需设置新的权限值并执行set_
permissions即可。如果你想要查看用户在RabbitMQ服务器所有vhost上的权限，
那么请使用rabbitmqctl的list_user_permissions命令：
$./rabbitmqctl list_user_permissions cashing-tier
Listing permissions for user "cashing-tier" ...
oak
checks-.*
*
al1
sycamore
all
...done.
RabbitMQ的权限容易创建且非常灵活。这种灵活性允许你为vhost创建复杂的
权限结构。当你需要的时候，你会从中收益；但是如果你把它们设置得非常复杂的话，
它们就很难理解。如果可能的话，尽量使用vhost分隔作为你的主要手段来确保应
用程序的安全，并最小化每个vhost的访问控制条目。这样会帮助你避免难以调试
的意外权限行为。
现在你能够连接并确保Rabbit服务器的安全，你也许想看看服务器内部到底发
生了什么。也许你需要知道有多少条资源调配消息在用户创建队列中。也许你想知
道交换器是否存在于正确的vhost上。一个健康的RabbitMQ服务器的最重要的组成
部分之一就是能够监控其内部状态。因此，让我们看看如何检查自己的Rabbit服务
i器
---
## Page 76
54
第3章运行和管理Rabbit
3.3检查
到目前为止，你已经学习了RabbitMQ管理一如何启动和停止服务器，添加
用户，管理权限，等等一但是如果你想要检查服务器状态，或者有多少个队列时，
你该如何做呢？在之前章节里创建的1ogs-exchange是topic类型还是fanout类
型？msg-inbox-logs队列上是否还有等待消费的消息呢？所有这些问题都能由
强大的rabbitmqctl来回答！
3.3.1查看数据统计
你可能已经注意到当我们之前运行rabbitmqctl脚本时，它接收了许多选项
和命令。其中一个你经常见到的是-P 选项。它指明了虚拟主机或者路径信息。如
果忽略该选项，rabbitmqctl会将“7”作为默认路径。
为了通过rabbitmqctl进行实验操作，我们需要先准备测试环境。让我们
先创建一个交换器并将其绑定到一对队列上，这样你就有一些样板数据进行测试
了。你应该知道本书的大部分例子都是用PHP或Python编写的。你已经设置好了
Python，所以现在该用PHP来编写这段简单的脚本了。让我们看看开发环境还需
要安装些什么。首先你需要适合你的操作系统的PHP包。由于PHP非常流行，因
此应该不会有什么问题。有可能你的操作系统已经预先安装了PHP。如果你仍然需
要自行安装，则我们建议你选择5.3.x中的一个版本。因为PHP自从5.3版后在内
存管理和垃圾收集上有巨大的改进。在PHP安装好后，下载PHPAMQP库，这在
整本书的讲解中都会用到。这个库叫作php-amqplib，可以从https://github.com
videlalvaro/php-amqplib获得。为你的PHP例子创建文件夹，然后将库也下载到此处：
$ mkdir php
$cdphp
$ wget https://github.com/videlalvaro/php-amqplib/tarball/v1.0\
--no-check-certificate
$tar -xzvf v1.0
$ mv videlalvaro-php-amqplib-b0b8696 php-amqplib
首先创建一个名为 php的文件夹，然后cd到该文件夹下。之后通过wget 命令
从GitHub获取库压缩文件并解压缩。最后你把库移动到最合适的位置，这样之后
可以少打点字。
现在php-amqplib已经下载好了，创建PHP脚本来初始化队列和交换器吧。
---
## Page 77
3.3检查
55
新创建一个名为rabbitmqctl-examples.php的文件，并把以下清单中的代码添
加进来。
清单3.1rabbitmqctl示例
dude>
require_once('./php-amqplib/amqp.inc');
define('HOsT','localhost');
define('PORT'，5672）;
define('USER'，'guest'）;
define('PASS'，'guest'）;
获得连接和信道
$conn = new AMQPConnection(HOST,PORT,USER,PASS);
$channel = $conn->channel();
$channel->exchange_declare('logs-exchange',
queue_declare('msg-inbox-errors',
false,true,false,false);
$channel->queue_declare('msg-inbox-logs',
queue_declare('all-logs',false,
把队列
true,false, false);
4绑定到
交换器
$channel->queue_bind('msg-inbox-errors',
上
'logs-exchange','error.msg-inbox');
$channel->queue_bind('msg-inbox-logs'
'logs-exchange'，'*,msg-inbox'）;
?>
这段脚本非常简单。我们不会深入探讨这里调用的AMQP方法，因为我们已
经花了整整一个章节专门讲AMQP的使用。现在让我们尝试理解这段脚本的基础知
识。首先你连接到代理服务器并获得了一条信道1，这样你就可以和RabbitMQ进
行通信了。获得信道之后，你声明了一个叫作logs-exchange②的交换器，然后
创建了三个队列:msg-inbox-errors、msg-inbox-logs和all-logs③。最后，
你将这三个队列中的两个绑定到了logs-exchange上，第一处使用的是error.
msg-inbox绑定规则，第二处使用的是*.msg-inbox绑定规则4。这段脚本的目
的是当你运行rabbitmqctl命令列出交换器、队列和绑定时，会显示相应的内容。
确保require_once这行代码所指向的位置你安装了amap.inc库。使用以下命令
执行代码：
---
## Page 78
56
第3章运行和管理Rabbit
$ php./rabbitmqctl-examples.php
如果一切正常，那么你就准备好用rabbitmqctl进行实验吧。
列出队列和消息数目
就让我们从list_queues 命令开始吧。在终端上，更改当前目录到sbin 文
件夹下（或者到rabbitmqctl所在的目录）并输人：
$./rabbitmqctl list_queues
该命令的输出依赖于服务器上已声明的队列，但是你看到的应该和这个很像：
Listing queues ..
msg-inbox-logs 0
msg-inbox-errors 0
all-logs 3
...done.
在这里你可以看到队列名字以及在每个队列上的消息总数。如我们所说的，这
些都是默认vhost上的信息。如果你想要获得另一个vhost信息的话，则可尝试像这
样添加-p选项：
这样就会展示在sycamorevhost上的队列了。
现在让我们看看这个命令的其他选项。如果你运行rabbitmqctl命令而不携
带任何选项的话，就会展示帮助信息。在帮助文本中，你会看到这个：
list_queues
[-p ][...]
你已经知道VHostPath的含义。往下滚动一点你就会看到QueueInfoItem接
收哪些选项：
must be a member of the list [name,durable,
auto_delete,arguments,pid,owner_pid,exclusive_consumer_pid,
exclusive_consumer_tag, messages_ready, messages_unacknowledged,
messages_uncommitted,messages,acks_uncommitted,consumers,
transactions, memory]. The default is to display name and (number of)
messages.
这段内容说明了如果你想要了解更多队列的信息的话，例如名字、消息数目或
---
## Page 79
3.3检查
57
者消费者数目，以及内存使用情况，则可以发送以下命令：
Listing queues ...
msg-inbox-1ogs 02 34632
msg-inbox-errors 0 1 34632
a11-1ogs 3043664
...done.
正如期望的那样，rabbitmqctl返回了队列的名称，msg-inbox-logs;消息数目，
0：附加的消费者数目，0；以及内存使用情况，43664字节。
你可以检查声明队列时使用的属性：
$ ./rabbitmqctl list_queues name durable auto_delete
Listing queues..
msg-inbox-logs true false
msg-inbox-errors truefalse
all-logs true false
...done.
你可以看到队列是可持久化的，同时auto_delete属性被设置成false。
当然，你可以在命令行上放手尝试其他选项。
查看交换器和绑定
现在我们来查看交换器的信息。在这种情况下，获取默认信息的命令如下：
$./rabbitmqctllist_exchanges
Listing exchanges ...
logs-exchange
topic
amq.rabbitmq.log
topic
amq.match
headers
amq.headers
headers
amq.topic
topic
amq.direct
direct
amq.fanout
fanout
direct
..done.
默认情况下，这个命令返回交换器名称和类型。你会发现若干个交换器早已声
明好了，例如amq.topic、amq.direct和amq.fanout。AMQP规范里对这些
交换器有规定。在列表的顶部你可以看到自己定义的logs-exchanges，类型为
topic。如果你仔细观察结果的底部，就会发现只有一个direct类型而没有交换器
---
## Page 80
58
第3章运行和管理Rabbit
名称。这就是我们在第1章提到过的匿名交换器。之后你就会看到，每个队列默认
都会绑定到该交换器。
让我们不携带参数运行rabbitmqctl命令，看一下listexchanges的参数：
$./rabbitmqctl
 must be a member of the list [name, type,
durable, auto_delete, arguments]. The default is to display name
and type.
这里的信息是之前用来声明交换器的选项。让我们看看：
$ ./rabbitmqctl list_exchanges name type durable auto_delete
logs-exchange
topic
true
false
amq.topic
topic
true
false
amq.direct
direct
true
false
amq.fanout
fanout
true
false
direct
true
false