%mysql --max_allowed_packet=16M
如果只是偶尔需要以16 MB的数据包限制来调用mysql或mysqldum，可以这么做：
客户端没有执行连接操作，就不需要连接缓冲区。（反之，如果客户端使用了复杂的涉
存储引擎调整
系统性能可能就会因资源消耗过大而下降。
.其他选项。
12.7服务器调整
445
缓
记
---
## Page 466
到列表的最后，并被丢弃。
表里的缓存块会随着时间的推移，越过新旧子列表的分界线。
随着时间的流逝，如果某个缓存块没有任何访问发生，那么它会被逐渐移到列表最后。新子列
访问便会立即发生；但如果缓存块是因为预读取而被插入的，访问可能就不会立即发生。
缓存块时，将其移动到新子列表的前面。如果缓存块是因为查询需要而被插入的，那么第一次
才会发生。
将其插入缓冲池。插入缓存块不同于访问它。
会将其放置在旧子列表前面(那里正好是新子列表的尾部）。
访问较多和较少的缓存块。InnoDB使用的是中点插入策略，即当把新的缓存块添加到缓冲池时，
12.7.2.1
细节。
保留在内存里的意义。
太大，以致用光机器上所有可用的内存。这样会导致缓存本身分页，从而失去使用缓存将信息
并且MySQL自身也有其他的内存需要，如连接（connection）缓冲、排序和连接（join）缓
小，
盘访问次数。如果服务器管理了许多特定于某种存储引擎的表，并且这种引擎的缓存当前还很
它会减少为了给新缓存块腾出空间而丢弃旧缓存块的需要，并且会最小化索引处理所需要的磁
用到的索引值的缓存块通常会长时间地停留在缓存里，较大的缓存可以提高命中机率。反过来，
446
区、临时表，以及查询缓存。同样地，在增加存储引擎的缓存大小时也要小心，不要让它变行
当访问新子列表里的缓存块时，仅当它还不是太靠前时，才会被移动到这个列表的前面，
默认情况下，InnoDB会把缓存块插到旧子列表的前面，接着会在插入之后第一次访问这个
当查询需要缓存块，或者缓存块的预读取试探器预测到不久便需要用到它时，InnoDB便会
InnoDB把它的缓冲池看作一个块列表，该列表被分为新、旧两个子列表，分别包含最近被
接下来的几节将提供与特定引擎（包括InnoDB和MyISAM）相关的表信息缓存配置的
，那么增加它的大小通常是可采取的最为有用的配置更改措施中的一种。
下面两个系统变量可以控制InnoDB缓冲池的大小和控制它是否可被分为更小的缓冲池，
不过，设置缓存大小也需要综合考虑。不要饿着服务器主机上运行的其他需要内存的进程，
虽然小型的缓存也可以带来这些好处，但是较大的缓存会带来更明显的效果。包含经常被
口i
口因为在缓存中找到的信息不需要再从磁盘里读取，所以对磁盘的读取操作会更少。
改缓冲起来，成组地写入磁盘，比单个的写入操作更高效。
的值，以便每个实例的大小都至少为1GB。使用多个缓冲池的情况通常仅限于大型系
效果，需要选择好 innodb_buffer_pool_size 和 innodb_buffer_pool_instances
因为在每个实例里试图访问其共享数据结构的会话会更少。（例如，即使一个会话对某
pool_size至少为1 GB，并且你将innodb_buffer_pool_instances 设置成大于1,
默认情况下，这个变量值为1，并且只有一个单独的缓冲池。如果innodb_buffer_
80%，此外还需要考虑其他MySQL资源和服务器主机上其他进程所产生的内存需求。
拥有更多可用内存的系统，可以把这个值增大。一般的指导原则是使用系统内存的70%～
分配给缓冲池的总内存，单位为字节。默认大小为128 MB。对于需要大量处理 InnoDB表并
1因为对缓存信息的修改不需要立即写入磁盘，所以对磁盘的写入操作会更少。将多次的更
个缓冲池拥有独占锁，使用其他缓冲池的工作也仍然可以继续进行。）要想达到最好的
InnoDB会把从磁盘读取到的缓存块随机分配给某个给定的缓冲池实例，这会减少竞争，
那么InnoDB会把这个缓冲池处理成许多个小的缓冲池实例，其中的每一个都独立运作。
innodb_buffer_pool_instances
第12章MySQL的基本管理
配置InnoDB的缓冲池
“访问”只在查询对缓存块的内容进行实际检查时
，旧子列表里的缓存块会逐步老化
得
---
## Page 467
这几项功能来对缓存操作进行更多的控制。
避免同表竞争问题，但
取，竞争都会出现。
但是在这个缓存里仍然会存在竞争。无论这些键是从同一个表里读取，还是从其他一些表里读
存已满，那么就会产生竞争，此时，必须丢弃当前缓存中的值，下次需要它们时，再从磁盘读取。
512MB，可以将下面几行内容放置到某个选项文件里：
是个非常保守的值。如果你使用了大量的MyISAM表，并且有多余的内存可以使用，那么把键
12.7.2.2
先前的那个值。
old_blocks_time的值设置为0，并扫描该表以将其加载到缓存里，然后将这个变量值恢复成
一方面，要想把你希望频繁访问的表的内容预先加载到缓冲池，可以把innodb
设置为大于0。当执行备份时（它会涉及大量的一次性扫描)，这是个值得推荐使用的设置。
问而导致的为填充新子列表而丢弃其他缓存块的现象，可以把innodb_old_blocks_time的值
的LRU算法产生影响。
针对此问题，MyISAM 提供了一种解决办法。
如果某个MyISAM表被使用的频率非常高，那么确保其键保留在内存里能带来很多好处，
配置缓冲区的方法是，对系统变量key_buffer_size进行设置。例如，要想把大小设置为
如果某个表被使用的频率非常高，你又有足够的内存将其索引加载到缓存里，那么这些功
口可以使用默认的单个键缓存，也可以创建多个缓存。
MyISAM键缓冲区在所有MyISAM表之间默认是共享的。如果在缓存中找不到键值，且缓
对 MyISAM存储引擎操作影响最为重要的参数是其键缓冲区的大小。默认大小为8MB,
口可以将表分配给某些特定的缓存，并把表索引预加载到其中的某个缓存。
MyISAM在存储表时使用了单独的数据文件和索引文件，对处理它们的方式也有所不同。
表扫描往往会快速连续地多次访问表块，此后便不再访问。为防止出现因这种一次性的访
口可以控制总的缓存大小、缓存块大小和缓冲区丢弃算法。
key_buffer_size=512M
[mysqld]
口
口为缓存从数据文件读取到的数据行，或者是写到数据文件的数据行，MyISAM依托操作系
 innodb_old_blocks_time
 innodb_old_blocks_pct
作，以及索引的创建和修改操作。
为处理索引文件，MyISAM维护了一个键缓冲区，用它来执行基于索引的检索和排序操
统，使用了它的文件系统缓存机制。
移到新子列表里去。
子列表里。默认值为0，表示的是：插到旧子列表里的缓存块，在第一次访问发生时会立即
一个缓存块在第一次访问之后、下次访问之前，需要在旧子列表里待多少毫秒才能移动到新
小的值或更大的值会分别导致新子列表里的缓存块更慢或更快地老化至旧子列表。
新子列表退化至旧子列表时）。默认值为37（即缓冲池的3/8）。允许的取值范围为5~95。更
时，仅仅是通过来回移动指针的方式来表明新旧子列表之间的边界（例如，当某个缓存块从
缓冲池的旧子列表所占的百分比。这个百分比是一个近似值，因为InnoDB在管理某些操作
统，如拥有大量内存的64位系统。
2配置MyISAM的键缓冲区
但是来自其他表的键仍然会争抢缓存里的空间。
你或许可以通过把键缓存增大到足以完全容纳给定表全部索引的方式，来
，因为它支持多个键缓存，所以可以通过下面
12.7服务器调整
447
另
---
## Page 468
president 分配给名为 my_cache 的缓存：
会指定一个键缓存以及一个或多个表，将它们分配给该表。
想
被
个
它们进行访问：
变
起
缓存不会与其他表的产生竞争（它是通过默认的缓存进行处理的）。
在内存里完成。
需要任何磁盘I/O 操作。此外，也不需要从缓存中丢弃那些键值，针对该表的键查找也都可以
个表的索引的缓存，并将此缓存设置为仅供这个表使用。在所有键都加载到缓存之后，便不再
能就会有用处。同表竞争和它表竞争都可以避免，方法是：创建一个足够大的能完全容纳下一
448
服务器的选项文件里：
思在服务器启动时创建一个名为my_cache、大小为 24 MB的缓存，可以将下面这几行添加到
要想创建新的键缓存，可以把值赋给与之关联的那个缓存变量的任何组成部分。例如，要
皮引用（参考2.2节）。
变量。键缓存名必须是合法的标识符，并且不区分大小写。它们可以像所有其他标识符一样
量。这种结构化变量是简单系统变量的扩展，因此可以使用“缓存名+变量名”的语法形式对
要想在MyISAM表创建好之后将其分配给某个键缓存，
要想在运行时创建键缓存，可以使用下面这条语句：
my_cache.key_buffer_size=24M
有一个默认键缓存，其名字为default。当应用于默认缓存时，对键缓存组成变量的引用
另一个常见的策略是，将一组被频繁使用的表分配给一个单独的键缓存，以使它们的索引
关
[mysqld]
口
口
由于这些变量是相关的，因此可以将它们分为多个组成部分，共同组成一个结构化的系统
要想允许对MyISAM键缓存进行配置，服务器需要将每一个缓存都与一组系统变量关联-
口
要想设置它们，就必须拥有SUPER权限。
键字GLOBAL必不可少，因为键缓存是全局性的。访问各组成部分的值时不需要特殊权
高，缓冲块被允许停留在热子链里的时间越长。其默认值为300，最小值为100。
一个键缓存结构化变量都有下面几个组成部分。
它指的是，未使用的缓冲块在被移到暖子链之前，可以在键缓存的热子链里保留多久。值越
InnoDB缓冲池的新旧子列表相似。）
是会从暖子链里选择要重用和覆盖的缓冲块。（MyISAM 键缓冲区的热子链和暖子链与
有
冲区子链占键缓存的百分比，其取值范围为1~100。
缓存会
存会使用最近最少使用策略来决定重用哪些缓存缓冲区。如果设置值小于100，那么键
这个变量会对缓存缓冲区的重用算法产生影响。如果设置为它的默认值100，那么键缓
key_cache_limit
键缓存的块大小，单位为字节。默认情况下，缓存块的大小为1024字节。
key_cache_block_size
键缓存的总大小，单位为字节。
key_buffer_size
第12章MySQL的基本管理
热子链里。缓冲块会随着被访问次数的增加或减少，在热子链或暖子链之间移动。服务器总
有了使用暖子链和热子链的中点插入策略之后，服务器会尽力把最常被访问的缓冲块保留在
会使用中点插入策略将缓存分为暖子链和热子链。key_cache_limit的值为暖缓
，可以使用CACHE INDEX。这条语句
下面这条语句将把表 member
和
---
## Page 469
能往往会得到很大的提升。查询缓存有这样几个特点。
12.7.3使用查询缓存
器时，将系统变量init_file 的名字设置为该文件的名字。
以将适合的CACHEINDEX和LOADINDEXINTO CACHE语句放置在某个文件里，并在启动服务
存占月
表索引，
认缓存。
才等待获取它们的方式相比，这种做法更有效率。
引预先加载到分配给它们的那个缓存里：
MySQL服务器可以使用查询缓存来加快处理那些需要重复执行的 SELECT语句。最终的性
键缓存分配只会持续到服务器退出为止。要想实现在服务器每次启动时都能进行分配，可
query_cache_size。它决定了分配给缓存的内存数量，单位为字节。
口 query_cache_type。它决定了查询缓存的操作模式。下表展示了所有可能的模式值。
对于支持查询缓存的服务器，缓存操作依赖于下面三个系统变量的值。
要想确定服务器是否支持查询缓存，可以检查系统变量 have_query_cache:
口查询缓存是以服务器接收到的查询字符串文本为基础的。如果这些查询的文本完全相同，
口服务器下次看到这条语句时，就不必再执行了。它可以直接从查询缓存里提取结果，并将
口某条给定的SELECT语句在第一次执行时，服务器会记住这条查询语句的文本和它返回的
用，但同时也会降低性能。
要想销毁键缓存，可以将其大小设置为零。所有分配给这个缓存的表都会被重新分配给默
CACHE INDEX和 LOADINDEXINTO CACHE语句要求你对指定表拥有INDEX 权限。
预加载索引不是必需的，但如果这样做了，
LOAD INDEX INTO CACHE member,president;
之后，你可以将其他表分配给同一个缓存。也可以使用LOAD INDEX INTO CACHE 将表索
Variable_name
口
口
CACHE INDEX member,president IN my_cache;
have_query_cache
器返回过时的结果。
其返回给客户端。
当表被修改时，指向它的所有缓存查询都将变为无效，并且会被丢弃。这样可以防止服务
的推移返回不同的结果，因此它不会被缓存。
如果某个查询返回的结果不确定，它就不会被缓存。例如，使用NOW（)的查询会随着时间
用相同的表（例如，它们引用了不同数据库中具有相同名字的表）的话，它们也是不同的。
信协议的客户端，那么就认为它们是不同的。就算它们在其他方面都相同，但实际并没有引
那么就认为它们是相同的。如果这些查询的大小写不同，或者来自使用了不同字符集或通
结果。
这种处理方式跟处理MyISAM数据文件的方式是一样的。这样可以最小化服务器的内
，如果将默认键缓存的大小设置为零，那么就要使用文件系统的缓存来处理分配给它的
模式
0
根据需要只将那些以SELECT SQL_CACHE为开头的可缓存查询缓存起来
将可缓存的查询缓存起来，那些以SELECT SQL_NO_CACHE为开头的查询除外
不缓存查询结果，不检索缓存结果
1Value
YES
服务器就会顺序读取各个索引块。与在需要时
含义
12.7服务器调整
449
---
## Page 470
使数据在内存里保留得更久，并减少从磁盘获取信息的需要。
更长。
所遵循的原则是一致的：尽可能多地把信息放置在快速存储里，并尽可能让它能够在那里待得
来同样的好处。当对可以采取何种硬件改进措施进行评估时，最重要的原则与服务器参数调整
如果你有更好的硬件，就可以让服务器运行得更快。但是，并非所有与硬件相关的更改都能带
12.7.4硬件优化
询，明确告知服务器不要缓存它们的结果，会更具意义。
询缓存对它们来说很可能毫无价值。在这种情况下，使用修饰符SQL_NO_CACHE来执行这些查
任何查询结果都会迅速失效。这意味着，尽管你可能会反复地执行这些汇总查询，但是这个查
表运行一组汇总查询。一个非常繁忙的 Web服务器，会频繁地向表中插入新行，因此表缓存的
果被缓存。使用 SELECTSQL_NO_CACHE语句会导致结果不被缓存。
如果缓存模式为ON或者DEMAND，那么在可缓存查询里使用 SELECT SQL_CACHE语句会导致结
相同的。在SET语句里，符号值OFF、ON和DEMAND 分别对应着0、1和2。
表明的。
些情形下，它起不到什么作用，甚至还会影响到性能。
被禁用。
在 query_cache_size 的大小设置为零时，即使 query_cache_type 为非零值，查询缓存也会
的内存。为了避免浪费内存，请将这个大小设置为零，除非你计划要启用这种缓存。请注意，
450