become tainted. In other words, these data entities must appear
in the taint slices. The data entities outside the slices do not
need to have their shadows, because they are irrelevant to the
taint propagation. More speciﬁcally, we need to shadow the
following types of data entities: 1) local variable; 2) function
parameter; 3) function return value; and 4) class data ﬁeld
(including both static ﬁeld and instance ﬁeld). They need to
be shadowed in different ways.
Local Variables. To shadow local variables, we can create
a boolean variable for each local variable within the same
function scope. To support taint tracking of multiple sources,
we introduce one separate shadow variable for one single taint
source. For example, to shadow a local variable r4, we create
a boolean variable r4 s0 t for one taint source and r4 s1 t
for another. The shadow variable r4 s0 t is set to 1 (true) if
r4 is tainted from the ﬁrst source, and 0 (false) otherwise. The
code snippet below depicts this case.
$r4 = virtualinvoke $r3.("gps");
r4_s0_t = 1;
Notice that another design option is to always use a
collection object (e.g., Vector) to hold and pass all the taints of
a variable. We do not take this design option for two reasons:
1) operations on collection objects are more expensive than
simple operations on boolean variables; and 2) the compiler
normally refuses to optimize collection objects due to their side
effects. Using boolean variables as shadow, on the contrary, is
more lightweight and amenable to various standard compiler
optimization methods such as constant propagation, dead code
elimination, etc.
Static/Instance Fields. Static and instance ﬁelds are shadowed
by adding boolean ﬁelds in the class deﬁnition. The code
snippet below shows how we add a boolean static ﬁeld to
shadow a static ﬁeld in the class deﬁnition. Notice that, ﬁelds,
that are declared in different children classes of the same
parent, are associated with different dedicated shadow ﬁelds.
This helps to accurately determine the taint status for objects
of derived classes.
private static android.location.Location location;
public static boolean location_s0_t;
Parameters and Return Value. To shadow function param-
eters and the return value, we have to modify the function
prototype to add parameters. These new parameters are used to
shadow the function parameters and the return value. However,
we cannot directly add boolean parameters like we do for
local variables and static and instance ﬁelds. This is because
primitive boolean parameters are passed by value in Java’s
calling convention. It means that the changes in these boolean
parameters will not be reﬂected back to the caller, resulting in
broken taint propagation. To solve this problem, we have to
pass an object reference instead of a simple boolean variable as
a function parameter. We deﬁne a new class BoolWrapper
for this purpose. This class only contains one boolean instance
6
: $r4 = virtualinvoke $r3.("gps");: return $r4;: $r1 = virtualinvoke r0.();: $r3 = ;: $r2 = virtualinvoke r0.();: $r3 = virtualinvoke $r2.();: $r4 = virtualinvoke $r3.("url");: $d0 = virtualinvoke $r3.();: $r4 = staticinvoke ($d0);: $r5 = virtualinvoke $r1.($r4);: $r6 = virtualinvoke $r5.(",");: $r9 = virtualinvoke $r6.($r8);: $r10 = virtualinvoke $r9.();: r2 = virtualinvoke $r10.();: virtualinvoke r0.($r11, r2);: virtualinvoke r6.(r2, 0, $i0);Static FieldInstance Field: $r11 = r0.;: $b3 = virtualinvoke r0.($b2): b0 := @parameter0: byte: $b2 = b0 ^ $b1: return $b2: $b3 = virtualinvoke r0.($b2): r2[i0] = $b3: $b2 = r2[i0]: r1 := @parameter0: String;: r2 := @parameter1: byte[];: specialinvoke $r3.(String)>(r1);: $r4 = virtualinvoke $r3.();: r5 = (java.net.HttpURLConnection) $r4;: r6 = virtualinvoke r5.();ﬁeld, which holds the taint status, and a default constructor, as
shown below. Notice that the Java Boolean class cannot serve
the same purpose because it is treated the same as primitive
boolean type once passed as parameter.
public class BoolWrapper extends java.lang.Object{
r3 = UNOP r4; //unary operation
r3_t = r4_t;
r3 = r4 BINOP r5 //binary operation
r3_t = r4_t | r5_t;
r6 = r7 BINOP r8
r6_t = r7_t | 0; //r8 is not shadowed
public boolean b;
public void (){
BoolWrapper r0;
r0 := @this: BoolWrapper;
specialinvoke r0.()>();
return;
}
}
C. Instrumenting the Source
Right after the taint source statement, we can simply
insert an assignment to set the corresponding shadow variable
to 1 (true), indicating that the tainted source has just been
introduced.
To address component hijacking problem, we consider
external Intents as sources. In other words, if an Intent comes
from inside the app, we do not set the taint. Consequently,
we need to differentiate the internal requests and external
ones. Unfortunately, except for IPC through a bound Service
or Activities started by startActivityForResult(),
so far, there exists no way to know the origin of an In-
tent by Android design. Thus, we have to rewrite existing
Intent code in the app so that internal Intent can carry an
extra secret integer, and further, at the public interfaces (e.g.,
Activites, BroadcastReceivers), we distinguish internal and
external Intents by checking the secret with an introduced
method isExternalIntent(). Notice that this method
does not exist in the original app, so the attacker can hardly
exploit it. Further, the method name can be randomized during
rewriting process. To prevent an attacker from forging an
internal Intent, we generate a random secret number every time
the app starts. Of course, it is always possible to adjust our
design provided Intent origin is supported by future Android
framework.
D. Instrumenting Taint Propagation
For each node within the taint slices, depending on its
statement type, we need to instrument it in different way.
Simple Assignments. For each simple assignment statement
in the taint slice, we need to insert a statement thereafter
to propagate taint accordingly. For deﬁnition statement and
unary operation, we insert an deﬁnition statement on the
shadow variables. For binary operation, we insert a binary OR
operation on the shadow variables. Note that in the original
statement, not all variables are shadowed, because they do not
appear in the def-use chain and will certainly not be tainted. In
this case, we replace their shadow variable with a constant 0
(false), indicating that they are always clean. The code snippet
below illustrates these cases. Hereafter, we will omit the source
label (e.g., s0, s1) for convenience when presenting shadow
variable names, if all taint propagations in the snippet are for
one single source.
r1 = r2; //definition statement
r1_t = r2_t;
Function Calls. If the statement
to be instrumented is a
function call deﬁned within the application, we need to insert
statements to bind shadow variables for actual arguments to
the shadow variables for the formal parameters. As mentioned
earlier, in order to reﬂect the value changes from the callee
back to the caller, we create new instances of boolWrapper
class and pass the references into the extended parameter
list. The code snippet below shows how we instrument an
invocation to crypt in our running example.
$b2_t_w = new BoolWrapper;
specialinvoke $b2_t_w.()>();
$b2_t_w. = $b2_t;
r0_t_w = new BoolWrapper;
specialinvoke r0_t_w.()>();
r0_t_w. = r0_t;
$b3_t_w = new BoolWrapper;
specialinvoke $b3_t_w.()>();
$b3_t_w. = $b3_t;
$b3 = virtualinvoke r0.
($b2, $b2_t_w, r0_t_w, $b3_t_w);
$b3_t = $b3_t_w.;
r0_t = r0_t_w.;
$b2_t = $b2_t_w.;
More speciﬁcally, we have expanded the parameter list of
crypt to include three extra BoolWrapper references, one
for shadowing the ﬁrst argument, one for shadowing “this”
pointer, and the last one for the return value. Before the
invocation, the three BoolWrapper instances are created
and initialized to receive their taint statuses. Then after the
invocation, the taint statuses in these BoolWrapper instances
are passed back to the shadow variables in the caller’s context.
We also add instrumentation code in the function body of
crypt to pass taint status from formal parameters into local
variables and in the end pass the new status back, as shown
below.
public byte crypt(byte, BoolWrapper,
BoolWrapper, BoolWrapper) {
r0 := @this: VulActivity;
b0 := @parameter0: byte;
w_p0 := @parameter1: BoolWrapper;
w_t := @parameter2: BoolWrapper;
w_r := @parameter3: BoolWrapper;
r0_t = w_t.;
b0_t = w_p0.;
$b2_t = w_r.;
$b1 = r0.;
$b2 = b0 ˆ $b1;
$b2_t = b0_t | 0;
w_t. = r0_t;
w_p0. = b0_t;
w_r. = $b2_t;
return $b2;
}
7
API Calls. Some statements involve calling Android APIs.
Since the method body of an Android API is not included
in the program, we have to add instrumentation code to
implement the taint propagation logic for that API. These APIs
can be generally put into the following categories:
•
•
•
•
APIs like getString() and toString(), have
very simple taint propagation logic, always propagat-
ing taint from parameters to their return values. There-
fore, we generate a default rule, which propagates taint
from any of the input parameters to the return value.
APIs like android.widget.TextView.setText()
can be modeled as a simple assignment. They propa-
gate taint from one parameter to another reference or
“this” reference.
APIs like Vector.add(Object) can be modeled
as a binary operation, such that the object is tainted
if it is already tainted or the newly added element is
tainted.
APIs like android.content.ContentValues.put(
String key, Byte value) that operate on (key,
value) pairs can have more precise handling. In this
case, the elements are stored and accessed according
to a “key”. To track taint more precisely, we keep a
taint status for each key, so the taint for each (key,
value) pair is updated individually.
Tracking References. We shadowed local variable in our
design, while some of local variables are references to objects.
Further, some of them are referencing the same object. If one
of the references is tainted, all other references should also be
tainted. In order to maintain the internal equivalence of such
references, we leverage the common origin of the references as
a bridge. To be more speciﬁc, once the shadow variable of one
reference is set, we set the taint variable of its origin; whenever
the taint status of a reference needs to be examined, we
evaluate the shadow variable of corresponding origin instead.
Simply put, instead of tracking multiple references, we rely on
the taint status of the unique origin.
E. Cleaning the Taint
It is not enough to only instrument the statements in the
taint slice, because the slice only includes the statements
involved in taint propagation. Statements outside the slice may
clean a tainted variable in the slice. To properly clean the
taint, for each variable appearing in the def-use chain inside
the slice, we need to ﬁnd all its deﬁnitions. Then for the
deﬁnitions outside the slice, we need to insert a statement after
that deﬁnition to set its shadow variable to 0 (false). The code
snippet below shows such a case in our running example.
$r4 = virtualinvoke $r3.("url");
r4_s1_t = 1;
if $r4 != null goto label0;
$r4 = r0.
r4_s1_t = 0;
label0:
F.
Instrumenting the Sink
We instrument the sink to check the taint status of the
sink variables. If they are tainted by certain sources, we can
raise a pop-up dialog to the user, asking for decision. Our
decision dialog offers the user two choices, “restart the app”
or “continue running”. If the user chooses the ﬁrst option, we
defeat the dangerous execution by immediately restarting the
app. Though this solution is not perfect, it is acceptable in
the Android environment because application context can be
saved to Shared Preferences programmatically for restore. It is
possible that malicious message also gets saved, but so does the
corresponding shadow variable. Therefore, whenever program
state is recovered, taint tracking resumes and the attack is
still blocked. Again, our goal is not to replace the ﬁnal patch
from developers, but rather to automatically and quickly offer
a viable solution, which can serve users’ need temporarily.
Below shows how we instrument the raw socket sending
as the sink in our running example. In this case, we trigger
decision making procedure if both the outgoing data parameter
is tainted by source s0, and OutputStream (constructed with
URL) is tainted by source s1.
public void post(java.lang.String, byte[],
BoolWrapper, BoolWrapper, BoolWrapper) {
....
if r2_s0_t == 1 && r6_s1_t == 1 goto label0;
goto label1;
label0:
label1:
staticinvoke ();
virtualinvoke r6.(r2, 0, $i0);
...
}
V. PATCH OPTIMIZATION
A. Optimization Phases
After the patch statements being placed in right positions,
we further perform a series of optimizations to reduce the
amount of patch statements as much as possible. As an op-
timization framework, Soot is capable of conducting common
optimizations on Java bytecode program. However, directly
applying these existing optimization methods will not generate
good results, because of the uniqueness in our inserted patch
statements. Therefore, we develop three custom optimizations
and apply them sequentially on the instrumented code. After
going through these custom optimizations, the program is more
amenable to Soot’s built-in optimizations. Therefore, we apply
Soot’s built-in optimizations in the end to generate a nearly
optimal patch.
Removing Redundant BoolWrappers (O1). As described
earlier, we introduce a new class BoolWrapper to en-
able taint propagation across the function boundary. Many
BoolWrapper related statements are redundant and can be
optimized. However, Soot refuses to optimize these statements,
because these statements operate on an instance ﬁeld in the
class, which may cause side effects to the rest of the pro-
gram execution. In this case, we are conﬁdent that redundant
BoolWrapper related statements can be removed safely. So,
we force to optimize these statements. In particular, to remove
8
redundant BoolWrapper-related statements, we perform copy
propagation and dead assignment elimination on them within
each instrumented function.
Removing Redundant Function Parameters (O2). After
removing redundant BoolWrapper related statements, a Bool-
Wrapper parameter in the function prototype may become
completely useless. In other words,
in the function body,