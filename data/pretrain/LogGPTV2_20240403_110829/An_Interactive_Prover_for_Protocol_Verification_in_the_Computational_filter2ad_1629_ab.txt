contribution is developed in Sections V and VI.
Our third contribution is the implementation of the interac-
tive prover SQUIRREL [50], which allows to reason on proto-
cols speciﬁed in an applied pi-calculus using our framework.
Thanks to basic automation techniques coming from ﬁrst-order
logic, we have been able to carry out several case studies
using this tool. These results, presented in Section VII, cover a
variety of primitives (hashes, signatures, Difﬁe-Hellman expo-
nentiation, encryption) and security properties (authentication,
strong secrecy, unlinkability). Although this is not our primary
goal, some of the proofs obtained here are ﬁrsts.
Related Work: We have already discussed the limitations
that are inherent
to symbolic models, and now focus on
tools which provide guarantees in the computational model.
Several such systems exist, based on different approaches.
For instance, CRYPTOVERIF [21] proofs are based on high-
level game transformations, EASYCRYPT [13] is built on
a general-purpose probabilistic relational Hoare logic which
can be used to formalize most pen-and-paper cryptographic
proofs, and CRYPTHOL [17] goes even further by embedding
the computational model in the proof assistant Isabelle/HOL.
Finally, F(cid:63) [19] is a general-purpose program veriﬁcation
framework which can be used (via external arguments) to
provide computational security guarantees. The various ap-
proaches can be compared on several criteria [12]; we mention
Authorized licensed use limited to: Tsinghua University. Downloaded on February 25,2022 at 12:10:06 UTC from IEEE Xplore.  Restrictions apply. 
538
a few to highlight differences with our tool.
Like CRYPTOVERIF, our protocol speciﬁcations are given
in the applied pi-calculus, although our language is less
detailed and does not provide a link with implementations.
The strongest
tools for verifying implementations remain
EASYCRYPT and, chieﬂy, F(cid:63).
Unlike EASYCRYPT and CRYPTOVERIF, we only provide
asymptotic security bounds. Our approach hides from the user
all quantitative aspects such as probabilities and the security
parameter and, on the surface, our tool is as simple as symbolic
veriﬁcation frameworks. In contrast, EASYCRYPT users often
have to carry out probabilistic reasoning, and come up with
complex security bounds, which can result in long proofs.
Such aspects are automated in CRYPTOVERIF. In general, the
current level of automation of our tool sits somewhere between
EASYCRYPT and CRYPTOVERIF.
The most important difference between our tool and earlier
ones is the associated proof methodology: CRYPTOVERIF
relies on game transformations and EASYCRYPT performs
Hoare-style proofs of programs, while we reason over exe-
cution traces of protocols. Our proofs are akin to TAMARIN’s
backward reachability analysis, driven e.g. by our unforgeabil-
ity tactic. We give in Appendix E an in-depth comparison with
EASYCRYPT and CRYPTOVERIF, based on the analysis of the
Basic Hash protocol in the three tools.
II. OVERVIEW
In this section, we give an overview of our framework and
tool, using as a running example the Basic Hash protocol. The
SQUIRREL prover and our case studies can be found in [50].
Example 1. We consider the Basic Hash protocol as described
in [23], which is an RFID protocol involving multiple tags and
readers. Each tag stores a secret key that is never updated,
and the readers have access to a shared database containing
all these keys. The protocol is as follows:
T → R : (cid:104)n, H(n, key)(cid:105).
Here, n is a fresh name and key is the secret key. When
receiving a message, the reader checks that it is a pair whose
second component is a hash of the ﬁrst component using one
of the keys from the database.
hash H
abstract ok : message
abstract error : message
name key : index → message
channel c
process tag(i,j:index) =
new n; out(c, (cid:104) n, H(n,key[i])(cid:105))
process reader(j:index) =
in(c,x);
try find i such that snd(x)=H(fst(x),key[i])
in out(c,ok)
else out(c,error)
system (!j R: reader(j) | !i !j T: tag(i,j)).
Listing 1. Basic Hash protocol in SQUIRREL
Listing 1 shows a formal description of the Basic Hash
protocol written in the input language of our tool, which is
close to the classical applied pi-calculus. More speciﬁcally,
we consider a scenario featuring several reader sessions with
access to the database, and several tags where each tag can
play multiple sessions. The try ﬁnd instruction encodes the
database lookup performed by the reader: the then branch
is executed with some value of i for which the required
condition holds, if any such i exists, otherwise the else branch
is executed.
We now describe informally how to instantiate our frame-
work to analyze this protocol — in practice, our tool performs
this instantiation automatically from the applied pi-calculus
speciﬁcation. We consider a set of actions representing each
step of the protocol: T[i, j] is the action performed by the
jth session of tag i, R[j, i] represents the action of a reader
session j when it has found a value i for which the second
component of its input is a hash of its ﬁrst component with
key[i], and R1[j] represents the action of a reader session j
when no such i can be found.
Using the user syntax, we now express an authentication
property on the Basic Hash protocol.
goal auth :
forall (i:index, j:index),
cond@R(j,i) ⇒
exists (j':index), T(i,j') < R(j,i)
&& fst(input@R(j,i)) = fst(output@T(i,j'))
&& snd(input@R(j,i)) = snd(output@T(i,j')).
Listing 2. Reachability goal in SQUIRREL
Here cond@R[j, i] is a macro which stands for the exe-
cutability condition of action R[j, i], where the reader recog-
nizes a valid input message w.r.t. some key key[i]. Our au-
thentication goal expresses that, whenever this condition holds,
there must be some session j(cid:48) of tag i (the one using key[i])
that has been executed before R[j, i]. Moreover, the output
of the tag’s action coincides with the input of the reader’s
action. We may note that we express this correspondence
on each projection. Indeed, for some implementations of the
pairing primitive, the equality of projections does not imply
the equality of pairs.
This authentication goal can be proved in our tool using a
succession of four tactics:
simpl. expand cond@R(j,i). euf M0. exists j1.
The ﬁrst tactic simply introduces variables i and j and the
assumption cond@R[j, i] identiﬁed by M0. The second tactic
expands this macro into its meaning, i.e.
snd(input@R[j, i]) = H(fst(input@R[j, i]), key[i]).
We then use the EUF-CMA assumption:
the condi-
tion states that
if snd(input@R[j, i]) is a valid hash of
fst(input@R[j, i]), thus the term fst(input@R[j, i]) must be
equal
i.e.
some m such that H(m, key[i]) appears in snd(input@R[j, i])
or fst(input@R[j, i]). Actually,
input@R[j, i] refers to all
messages outputted so far in the execution, and the only
to a message that has previously been hashed,
Authorized licensed use limited to: Tsinghua University. Downloaded on February 25,2022 at 12:10:06 UTC from IEEE Xplore.  Restrictions apply. 
539
hashed messages outputted by the protocol with the key
key[i] are the names n[i, j] (note that n is parametrized by i
and j since it has been generated below the replications
indexed by i and j). Therefore we deduce that there exists
a tag’s session j1 occurring before the action R[j, i] such that
n[i, j1] = fst(input@R[j, i]). We conclude by instantiating the
existential quantiﬁcation over j(cid:48) by j1.
Our framework does not only provide a proof system for
trace properties, but also allows to prove equivalence prop-
erties. For illustration purposes, let us consider the following
unlinkability property for the Basic Hash protocol: we want to
prove that a scenario where a tag with identity i can play many
sessions is indistinguishable to a scenario where each tag with
identity i can play only one session. To this end, we make use
of bi-processes with diff terms (as done e.g. in PROVERIF [22]
or TAMARIN [16]), and we replace in the protocol speciﬁcation
given in Listing 1 every key[i] with diﬀ(key[i], key
[i, j]). On
the left side of the bi-process, the key is the same for all
sessions of the tag with identity i, whereas on the right side
each session j of the tag with identity i uses a new key.
(cid:48)
We can then prove that the two projections of this bi-
process are observationally equivalent. The proof proceeds by
induction: we show that indistinguishability holds between the
left and right-hand side’s frames at any point of any trace,
assuming that the same holds for the previous points. We then
consider the three possible actions of the processes. For an
action T[i, j], we use the PRF assumption on the hash function
to replace the hashes of the fresh messages H(n[i, j], . . .) by
fresh names; we can then conclude since indistinguishability
is preserved by the addition of fresh names on both sides. For
a reader’s action R[j, i], we must show the equivalence (up-
to negligible probability) between the conditions of the action
for the two projections of our bi-process. This is an immediate
consequence of the previous authentication property (and its
obvious converse) which holds for our two projections. The
case of actions R1[j] is handled similarly.
III. MODELLING PROTOCOLS – SYNTAX
In this section, we introduce the syntax of our meta-
logic, which is an extension of the base logic of [11] with
timestamps, indices and macros, before describing how to use
it to model protocols. Along this section, we illustrate our
notions using the Basic Hash protocol introduced in Section II.
A. Meta-Logic
Syntactically, our meta-logic is a many-sorted ﬁrst-order
logic. Terms of the meta-logic (meta-terms) are of three
possible sorts:
• terms of sort message represent bitstrings manipulated
and exchanged by protocol’s participants;
• terms of sort
timestamp represent
time points in an
execution trace of a protocol;
• terms of sort
index are used to identify unbounded
collections of objects, e.g. sessions of a role or items
in a database.
T := τ | init | a[i1, . . . , ik] | pred(T )
t
:= x | n[i1, . . . , ik] | f[i1, . . . , ik](t1, . . . , tn)
|
|
|
input@T | output@T | frame@T
if φ then t else t(cid:48)
ﬁnd (cid:126)i suchthat φ in t else t(cid:48)
A := t = t(cid:48) | i = i(cid:48)
T = T (cid:48) | T ≤ T (cid:48) | cond@T | exec@T
φ := A | (cid:62) | ⊥ | φ ∧ φ(cid:48) | φ ∨ φ(cid:48) | φ ⇒ φ(cid:48) | ¬φ
∀i.φ | ∃i.φ | ∀τ.φ | ∃τ.φ
|
|
Fig. 1. Syntax of meta-terms and meta-formulas
We assume three inﬁnite sets of variables: X (whose el-
ements are noted x, y, z) for message variables; I (whose
elements are noted i, j) for index variables; T (whose elements
are noted τ) for timestamp variables.
We assume a set F of indexed function symbols (used to
model encryptions, pairs, . . . ). Each of these symbols comes
with an index arity as well as a message arity: if f ∈ F
has index arity k and message arity n, then for all index
variables i1, . . . , ik and meta-terms t1, . . . , tn, we have that
f[i1, . . . , ik](t1, . . . , tn) is a meta-term.
Example 2. Function symbols representing cryptographic
primitives will have index arity 0, and a message arity
depending on the kind of primitive. For instance, we use H
of message arity 2 to model a keyed hash, (cid:104)·,·(cid:105) of message
arity 2 to model concatenation, and fst (resp. snd) of message
arity 1 to model the ﬁrst (resp. second) projection. Function
symbols representing identities (for example, a constant value
associated to each tag) have 0 as message arity and 1 (or
even more) as index arity.
We assume a set N of indexed name symbols (modelling
random samplings of length η, the security parameter) and a
set of indexed action symbols A (modelling speciﬁc times-
tamps). These indexed symbols only have an index arity: they
cannot be applied to meta-terms.
Example 3. To model the Basic Hash protocol in our frame-
work, we consider two names key, n ∈ N : key has index
arity 1, and key[i] models the key associated to the tag i;
n has index arity 2, and n[i, j] represents the name used by
the session j of the tag i. Regarding actions symbols we let
A be the set of three indexed action symbols: aT and aR of
index arity 2 and aR1 of index arity 1. These action symbols
correspond to what is called T, R, R1 in Section II.
Deﬁnition 1. Given a meta-logic signature Σ = (F,N ,A)
and some sets of variables X , I and T , we give in Fig. 1 the
syntax of meta-terms of sort message (noted t) and timestamp
(noted T ), and the syntax of meta-formulas (noted φ). The
only meta-terms of sort index are index variables.
For any meta-term t, we let st(t) and fv(t) be, resp., the set
Authorized licensed use limited to: Tsinghua University. Downloaded on February 25,2022 at 12:10:06 UTC from IEEE Xplore.  Restrictions apply. 
540
of subterms of t and the free variables of t of any sort.
Note that meta-terms and meta-formulas are mutually in-
ductive, due to conditional and lookup constructs in terms.
Lookups generalize conditionals: ﬁnd (cid:126)i suchthat φ in t else t(cid:48)
evaluates to t where indices (cid:126)i are bound to values such that φ
holds if such values exist, and t(cid:48) otherwise. Again, this lookup
construct can be computed thanks to the ﬁniteness of the
domain of interpretation of indices. The special timestamp
constant init stands for the initial time point.
A key ingredient of our meta-logic are macros, which are
used to refer to protocol executions. We have message macros
input@T and output@T to refer to the input and output mes-
sages of the action executed at time T . The macro frame@T
represents all the information available to the attacker at that
time: essentially, it is the sequence of all output messages from
the start of the protocol until time T . We also have boolean
macros cond@T and exec@T which respectively encode the
execution condition of the action at time T and the conjunction
of all such conditions until time T .
B. Protocols as Sets of Actions
We model a protocol as a ﬁnite set of actions. Each action
represents a basic step of the protocol where the attacker
provides an input, a condition is checked, and ﬁnally an output
is emitted. Formally, an action is deﬁned by an action symbol
identifying it, and an action description giving its semantics.
Actions are indexed, allowing for unbounded executions.
Deﬁnition 2. An action a[i1, . . . , ik].(φ, o) is formed from an
action symbol a of index arity k, distinct indices i1, . . . , ik,
a meta-logic formula φ and a meta-logic term o of sort
message such that fv(φ, o) ⊆ {i1, . . . , ik}. The formula φ is
the condition of the action, and o its output.
An action a[i1, . . . , ik].(φ, o) models that o will be emitted
provided that φ holds, but does not specify a failure case.
Conditional branching may be modelled using two actions:
one with the condition for the positive branch, and one
with the negation of the condition for the negative branch.
Alternatively, a single action with a trivial condition may
be used, and an output term that performs the conditional
branching. As we shall see, actions are chosen by the attacker,
hence the second option gives less power to the attacker.
A protocol is a set of actions equipped with a dependency
relation, which constrains the order of execution of actions.
Deﬁnition 3. Given a ﬁnite set A of action symbols, a protocol
P = (PA, <) over A is a ﬁnite set PA of actions, one for each
action symbol, equipped with a partial order < over terms of
the form a[(cid:126)i] with a ∈ A. We require that:
• < is insensitive to the choice of speciﬁc index variables:
a[i1, . . . , ik] < a(cid:48)[j1, . . . , jk(cid:48)] iff a[σ(i1), . . . , σ(ik)] <
a(cid:48)[σ(j1), . . . , σ(jk(cid:48))] for any a, a(cid:48),(cid:126)i and (cid:126)j and for any
bijective variable renaming σ : I → I;
• actions only refer to information about previously exe-
cuted actions; for every a[(cid:126)i].(φ, o) ∈ PA, each subterm
of φ and o of sort timestamp:
(i) either appears in an input macro input@a[(cid:126)i],