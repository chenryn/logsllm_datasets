### Specific Patterns in Applications and Future Work
To more accurately identify specific patterns in these applications, we defer a detailed exploration to future work. Across all applications, we observe that pilots with Masked, SDC-Good, and Detected outcomes exhibit almost perfect (>99.9%) validation accuracy. Both Blackscholes and FFT show significant improvements (>90%) when a user-defined quality threshold (QT) is applied. For brevity, we present results for QT=5, but we have conducted this experiment with a range of different QT values, observing consistently high validation accuracy. This suggests that even for pilots that fail to predict quality at a fine granularity, the grouping of equivalence classes is sufficiently accurate for many realistic use cases. On average, when a quality threshold is provided, the validation accuracy exceeds 97% for both store and control heuristics (and their combination). The techniques used by gem5-Approxilyzer are highly accurate in characterizing error profiles for x86 applications.

### Error Profiles for Different ISAs
Figure 4 compares the distribution of error outcomes (for all error sites) in each application for the x86 and SPARC ISAs. The error outcome profiles for the same application differ significantly between the two ISAs. Some of these differences are expected due to the CISC vs. RISC nature of the instructions and the fact that x86 uses many more implicit registers (which we do not inject into) compared to SPARC. The graph indicates that SPARC has a higher percentage of more severe outcomes. For example, while Blackscholes-x86 has many error sites leading to SDC-Good, SDC-Maybe, and SDC-Bad outcomes, the error outcomes in Blackscholes-SPARC produce such poor-quality output that they become DDCs. A deeper analysis of the causes for these differences is left for future work.

### Resiliency Analysis
Figure 5 shows the percentage of static instructions that require resiliency protection and those that are approximable for the same QT across the two ISAs. The wide differences between the two ISAs and the lack of a clear trend further emphasize the importance of tools that can analyze applications at the binary level to develop customized resiliency and approximation solutions for different architectures. Source-code or IR-level error analysis may not lead to the most optimized solutions.

### Related Work
gem5-Approxilyzer re-implements Approxilyzer [25] and Relyzer [26] in gem5 [28] and the x86 ISA. Other tools for resiliency analysis, such as MeRLiN [23], use GeFIN [41] (also built on top of gem5) to simulate micro-architectural injections in an x86 O3 CPU. It performs fault pruning to accelerate statistical micro-architectural fault injections and provides fine-grained reliability estimates for hardware structures and SDC vulnerability estimates for software. gem5-Approxilyzer's analysis is at the architectural level, and its primary goal is to determine precisely if and how an error in an instruction impacts the final output.

GemFI [42] is another error-injection tool that operates at the micro-architectural level, built on top of gem5, and supports both Alpha and x86 ISAs. Other error-injection tools, such as LLFI [19], analyze applications at the compiler intermediate representation (IR) level. IR is ISA-independent by design, so such an analysis would ideally hold regardless of the hardware architecture. However, there may be a loss in error site accuracy because IR still requires additional transformations before producing the assembly [43].

FAIL* [20] performs ISA-level analysis. A benefit of performing ISA-level injections is that the results provide instruction-level resiliency information, which system designers can use to create soft error protection schemes at the instruction level [44], [45]. FAIL* also uses gem5 and supports ARM but is limited to one pruning technique: def-use analysis.

### Conclusion and Future Work
We have presented gem5-Approxilyzer, an open-source re-implementation of Approxilyzer for the gem5 simulation environment. The goal of gem5-Approxilyzer is to enable support for multiple ISAs within an open-source infrastructure, starting with x86. We demonstrate that gem5-Approxilyzer is both effective and highly accurate in predicting the program's final output quality in the presence of soft errors. To further motivate the need for such tools, we perform a preliminary comparison of our workloads across two ISAs, x86 and SPARC. The differences in error profiles for the same applications across ISAs underscore the need for a tool like gem5-Approxilyzer. Expanding gem5-Approxilyzer to support different error models is part of our future work.