1
Sender
Receiver
Figure 1: Example of the GGM tree generated by the sender and partially learnt by the receiver. Here, ğ‘˜ = 2, ğ‘› = 8, and ğ‘– = 3.
Thus, the path not learnt by the receiver is (010). For each level, the parties run an OT where the receiver learns an XOR of
either the left children or the right children of that level. Using previously expanded sub-trees, this information allows the
receiver to learn a new seed (nodes filled in blue) which can be expanded by repeatedly calling ğº (the nodes resulting from
such expansions are filled in black).
can then appropriately set the ğ‘–th entry of r2 so that ğ‘Ÿ1
ğ‘– = ğ›½.
Note that, as long as P2 obtains ğ‘…ğ›½ in the key generation phase, the
corrections can be applied during expansion. Our construction is
presented in Protocol 3 in terms of the key generation and expansion
procedures for (ğ‘› âˆ’ 1)-out-of-ğ‘›-ROT from the previous section,
which encompasses the steps from above.
ğ‘– + ğ‘Ÿ2
Lemma 4.1. Protocol 3 securely implements Known-Index SPFSS
over a domain of size ğ‘› in the (ğ‘› âˆ’ 1)-out-of-ğ‘›-ROT hybrid model.
With (ğ‘› âˆ’ 1)-out-of-ğ‘›-ROT instantiated by the construction of Pro-
tocol 2, Protocol 3 requires ğ‘‚(ğœ† log ğ‘›) communication and ğ‘‚(ğœ†ğ‘›)
computation per party where ğœ† is the security parameter of the ROT.
Proof Sketch. The main argument in the security proof is that
ğ‘…ğ›½ is a one-time pad that masks ğ›½1, given the property of (ğ‘› âˆ’
1)-out-of-ğ‘›-ROT that the output of P1 is a random vector. A detailed
proof is given in Appendix A.2.
5 KNOWN-INDICES MPFSS VIA CUCKOO
HASHING
In this section we present a reduction from known-index multi-
point FSS to known index single point FSS. The multi-point setting
is analogous to the SPFSS functionality of Protocol 3, but extended
to functions that fix the value of ğ‘¡ â‰¥ 1 points. We formalize our
Known-Indices MPFSS variant in Definition A.7 in the appendix. A
naive reduction executes ğ‘¡ independent instances of known-index
SPFSS on the original database. However, as observed by Boyle
et al. [9], this requires evaluating all ğ‘¡ SPFSS instances on the whole
domain, which results in an Î©(ğ‘¡ğ‘›) computational overhead.
Protocol 3: Distributed Known-Index Single Point FSS
Params and Building Blocks: (ğ‘› âˆ’ 1)-out-of-ğ‘›-ROT;
Point function ğ‘“ : [ğ‘›] â†’ G, ğ‘“ (ğ‘–) = ğ›½, ğ‘“ ( ğ‘—) = 0 âˆ€ ğ‘— â‰  ğ‘–
Random shares ğ›½1, ğ›½2 : ğ›½1 + ğ›½2 = ğ›½; ğ‘ âˆˆ {0, 1}
Parties: P1, P2
Inputs: P1 : ğ›½1, P2 : ğ›½2, ğ‘–
Key Generation (SPFSS.Gen(1ğœ†, ğ‘“ğ‘–,ğ›½)):
(1) The parties run a secure ROT.Gen(1ğœ†, ğ‘›, ğ‘–) protocol to
(2) The parties execute locally ROT.Expand, from which P1
obtain keys ğ¾ROT1
gets ğ‘› random values {ğ‘Ÿğ‘–}ğ‘— âˆˆ[ğ‘›], and P2 obtains
{ğ‘Ÿğ‘–}ğ‘— âˆˆ[ğ‘›],ğ‘—â‰ ğ‘–.
and ğ¾ROT2
.
(3) Let ğ‘… =ğ‘— âˆˆ[ğ‘›] ğ‘Ÿğ‘–. P1 sends to P2 the value ğ‘…ğ›½ = ğ‘… âˆ’ ğ›½1.
(4) P2 computes Ëœğ‘Ÿ = ğ›½2 âˆ’ ğ‘…ğ›½ +ğ‘— âˆˆ[ğ‘›]\{ğ‘–} ğ‘Ÿğ‘–.
â€¢ If ğ‘ = 2, parse ğ¾2 as(cid:0)ğ¾ROT2
compute v2 â† ROT.Expand(cid:0)2, ğ¾ROT2
(5) P1 outputs ğ¾1 â† ğ¾ROT1
(6) P2 outputs ğ¾2 â† (ğ¾ROT2
Expansion (SPFSS.Eval(ğ‘, ğ¾ğ‘, ğ‘¥)):
â€¢ If ğ‘ = 1, compute v1 â† ROT.Expand(1, ğ¾1) and output ğ‘£1
ğ‘¥.
, Ëœğ‘Ÿ(cid:1). If ğ‘¥ = ğ‘–, output Ëœğ‘Ÿ. Otherwise,
(cid:1) and output âˆ’ğ‘£2
, Ëœğ‘Ÿ).
ğ‘¥.
A general idea to improve on this baseline is to rely on batching
schemes that split the domain of size ğ‘› into ğ‘š small parts in a way
that allows to distribute the ğ‘¡ SPFSS instances across the ğ‘š smaller
parts. One can instantiate this general idea using a combinatorial
object called batch codes (see Ishai et al. [36] for an introduction).
7
ğ‘š Buckets
Hash Table ğ‘‡
ğ‘¡ Indices
â„1
â„2
â„3
ğ‘–
ğ‘–
ğ‘–
ğ‘–1
.
.
.
ğ‘– ğ‘—
.
.
.
ğ‘–ğ‘¡
â„3
ğ‘– ğ‘—
1
2
...
ğ‘–
...
ğ‘›
Public
ğ‘ƒ2
Figure 2: The domain of the MP function is hashed ğœ… times
into ğ‘š Buckets using ğœ… different hash functions (this ar-
rangement is public). P2 privately builds a cuckoo hash ta-
ble of the indices of the MP function. Then, an instance of
known-index SPFSS is executed for each bucket.
A batch code with parameters ğ‘›, ğ‘¡, ğ‘˜, ğ‘š gives a partition of a data-
base of size ğ‘› into ğ‘š parts such that any ğ‘¡ indices from [ğ‘›] can
be recovered by reading at most ğ‘˜ entries in each of the ğ‘š parts.
Although batch codes are attractive in that they offer very strong
provable guarantees, they can be hard to instantiate in practice.
This issue arises in the construction proposed by Boyle et al. [9],
who explore Combinatorial Batch Codes (CBCs) for batching mul-
tiple FSS instances to obtain MPFSS. Since explicit constructions
of the expander graphs required for instantiating a CBC do not
satisfy their efficiency requirements, Boyle et al. propose a heuris-
tic construction of a CBC. This leads to a small failure probability,
which asymptotically depends on ğ‘¡ and the expansion factor of the
batch code. However, concrete parameters for the heuristic CBC
construction are not given by Boyle et al., and in their running time
estimates, the authors assume ğ‘¡ SPFSS instances on disjoint subsets
of [ğ‘›] instead of full MPFSS.
A second approach to baching is given by Angel et al. [1], who
introduce a relaxed notion of Probabilistic Batch Codes (PBCs).
Unlike the heuristic CBC construction of Boyle et al. [9], batching
here may fail on each insertion of ğ‘¡ indices with a certain probability
(which can be made arbitrarily small). The PBC construction of
Angel et al. [1] is inspired by many works in the PSI literature [15,
21, 26, 49], where cuckoo hashing [47] is commonly used to reduce
PSI to private set membership queries. We follow this line of work,
and base our MPFSS construction on probabilistic batching.
5.1 Batching Known-Index SPFSS
5.1.1 Cuckoo hashing as a PBC. Our approach to build MPFSS from
single point FSS is to use Cuckoo hashing [47] and simple hashing
in a similar manner as in PSI and PIR protocols [1, 15, 21, 26, 49].
Cuckoo hashing [47] is a multi-choice hashing scheme with eviction
parameterized by ğœ… universal hash functions â„1, . . . , â„ğœ…. Cuckoo
hashing achieves the goal of distributing ğ‘¡ items in a table ğ‘‡ of size
ğ‘š in a manner that guarantees that each location in ğ‘‡ is occupied
8
by at most one item. The insertion algorithm puts the item to be
inserted ğ‘¥ at ğ‘‡ [â„1(ğ‘¥)] and, if this position is occupied, evicts the
item in that position and relocates it using â„2, which may cause
yet another eviction resolved using â„3, and so on. This insertion
algorithm may fail when a cycle of evictions is found, and thus
cuckoo hashing has a failure probability that depends on parameters
ğœ…, ğ‘›, ğ‘¡ and ğ‘š. Several works [15, 21, 49] that use cuckoo hashing
in secure computation protocols have empirically studied such
parameters and how they relate to the failure probability. In our
work we use the estimates of Demmler et al. [21], which leads to the
same parameter choices used by Angel et al. [1] and Chen et al. [15].
While we present our concrete parameter choices in Section 8.2,
we keep these symbolic in the protocol description for presentation
purposes. We therefore introduce a statistical security parameter
ğœ‚, meaning that the probability of failing at hashing ğ‘¡ items is
bounded by 2âˆ’ğœ‚. More specifically, we denote by ParamGen(ğ‘›, ğ‘¡, ğœ‚)
the function that generates cuckoo hashing parameters, i.e., number
of hash functions ğœ… and cuckoo table size ğ‘š, that guarantee this
statistical bound on the insertion failure probability. Note that in
the case of such an insertion failure, P1 learns of it in Step (1) of the
protocol and thus can handle this case in several ways in practice.
For example, it could simply abort the protocol, or it could sample
new hash functions until the hashing step succeeds or a maximum
number of trials is reached. In these cases, hashing failures result
in leakage, as the adversary can infer information about the indices
from the fact that they failed (or did not fail) to hash. A second
option is to sacrifice correctness instead, and simply ignore indices
that failed to hash. This way, no information is leaked from the
generated MPFSS keys, but the multi-point function changes with a
small probability. As discussed in [1, 15], the strategy for handling
hashing failures depends a lot on the exact use case. In the case of
vector OLE, we choose to drop indices that fail to hash (cf. Section 6).
This is also the approach suggested by Boyle et al. [9] for their
heuristic batch code construction. Our protocol therefore achieves
the same type of security guarantee, while at the same time being
concretely efficient.
5.1.2 Our protocol. Our construction is shown in Protocol 4. We
use a cuckoo hashing scheme with capacity ğ‘¡ instantiated with ğœ…
hash functions mapping [ğ‘›] to [ğ‘š], where (ğ‘š, ğœ…) = ParamGen(ğ‘›, ğ‘¡, ğœ‚)
as described above. In step (1), the party holding the ğ‘¡ non-zero
evaluation points of the multi-point function computes a cuckoo
hash table ğ‘‡ of size ğ‘š that contains them. In step (2), the two parties
use all of the ğœ… hash functions to simple-hash the whole domain [ğ‘›].
This results in ğ‘š buckets ğ¼1, . . . , ğ¼ğ‘š, with ğœ… copies of each integer
in [ğ‘›] distributed across them uniformly at random. An important
point is that this arrangement is public (see left side of Figure 2).
The parties also fix an order within each bucket ğ¼ğ‘™, and compute
the reverse mapping posğ‘™ from items to positions.
After having assigned indices to buckets, our protocol securely
runs an SPFSS key generation for each bucket ğ¼ğ‘™. First, in step (3),
the parties obtain shares of the vector v of values to be fixed in each
of the SPFSS instances (the value ğ›½ in Protocol 3). This needs to be
done in a secure computation because both parties share all ğ›½ğ‘–â€™s,
while only P2 knows which ğ›½ğ‘– maps to which bucket. The secure
computation can be implemented using permutation networks [53]
in a garbled circuit, or using additive homomorphic encryption.
Protocol 4: Distributed Known-Indices MPFSS
Public Params: Input domain [ğ‘›], number of points ğ‘¡,
statistical security parameter ğœ‚,
Cuckoo hash parameters: table size ğ‘š, and number of hash
functions ğœ…, (ğ‘š, ğœ…) = ParamGen(ğ‘›, ğ‘¡, ğœ‚)
Point function ğ‘“i,ğœ· : [ğ‘›] â†’ F, ğ‘“i,ğœ· (ğ‘– ğ‘—) = ğ›½1
ğ‘— âˆˆ [ğ‘¡], ğ‘“i,ğœ· ( ğ‘—â€²) = 0 for all other inputs.
Parties: P1, P2
Inputs: P1: ğ‘¥, ğ›½1
ğ‘¡ ; P2: ğ‘–1, . . . ğ‘–ğ‘¡, ğ›½2
Key Generation (MPFSS.Gen(1ğœ†, ğ‘“i,ğœ·)):
(1) P2 randomly chooses ğœ… hash functions (â„ ğ‘—)ğ‘— âˆˆ[ğœ…], with
1, . . . , ğ›½1
1, . . . , ğ›½2
ğ‘— for all
ğ‘— + ğ›½2
ğ‘¡
â„ ğ‘— : [ğ‘›] â†’ [ğ‘š]. P2 inserts ğ‘–1, . . . ğ‘–ğ‘¡ into a Cuckoo hash table
ğ‘‡ of size ğ‘š using â„1, . . . , â„ğœ…, and it sends the ğœ… hash
functions to P1. Let empty bins in ğ‘‡ be denoted by âŠ¥.
(2) P1 and P2 do simple hashing with all ğ‘˜1, . . . , â„ğœ… on the
domain [ğ‘›], to independently build ğ‘š buckets ğ¼1, . . . , ğ¼ğ‘š, i.e.
ğ¼ğ‘™ = (ğ‘¥ âˆˆ [ğ‘›] | âˆƒğ‘ âˆˆ [ğœ…] : â„ğ‘(ğ‘¥) = ğ‘™), for ğ‘™ âˆˆ [ğ‘š], each
sorted in some canonical order. The parties compute
functions posğ‘™ : ğ¼ğ‘™ â†’ [|ğ¼ğ‘™|] that map values to their
position in the ğ‘™-th bucket.
ğ‘— + ğ›½2
ğ‘— âˆˆ[ğ‘¡], where ğ‘™ ğ‘— is the location of ğ‘– ğ‘— in
ğ‘‡ . The parties run a secure 2PC protocol to obtain random
shares v1, v2 of the vector v âˆˆ Fğ‘š defined as
(3) Let u =(cid:0)(ğ›½1
ğ‘— , ğ‘™ ğ‘—)(cid:1)
(cid:26) ğ‘
vğ‘— =
0
if (ğ‘, ğ‘—) âˆˆ u,
otherwise.
(4) For all ğ‘™ âˆˆ [ğ‘š], P1 and P2 run ğ‘†ğ‘ƒğ¹ğ‘†ğ‘†.ğºğ‘’ğ‘›(1ğœ†, ğ‘”ğ‘™)
(Protocol 3) to obtain seeds (ğ¾ğ‘™