Fig. 2. (continued)
Although the intent of WSDL is to give the syntax of a Web service interface,
some level of semantics or meaning is necessary for the interface and its operations to
be usable. The real issue is not whether WSDL descriptions themselves have any
semantics, but rather how complete and precise are the semantics, and whether the
semantics can be effectively and automatically processed.
2.3.2 SAWDL
WSDL as it stands is most useful if standards (naming conventions and even standard
predefined interfaces) are used. Then automation is possible if exact matching is used
and you are sure everyone has fully followed the standard. Automation tools for dis-
covery and composition may blindly find and connect components. Unfortunately,
this brittle solution has only worked in the past in narrow domains or with controlled
organizations and is unlikely to scale to the Web.
Web Services Discovery Utilizing Semantically Annotated WSDL 247
Table 1. Allowable SAWSDL annotations
Model Lifting Lowering
Reference SchemaMapping SchemaMapping
 Yes No No
 Yes No No
 Yes Yes Yes
 Yes Yes Yes
 Yes Yes Yes
 Yes No No
 Yes No No
One could jump to an approach that provides a much richer and more formalized
description of Web services (e.g., OWL-S [14]), but maybe a simple augmentation of
WSDL may suffice (or at least provide substantial improvement). This is the idea
behind WSDL-S [16] and the even simpler Semantic Annotations for WSDL
(SAWSDL). As of August 2007, SAWSDL has been accepted as a W3C recommen-
dation or standard for augmenting WSDL and associated XML Schema documents
with semantic annotations. Although SAWSDL was designed for WSDL 2.0, which
itself was accepted as a W3C recommendation in July 2007, SAWSDL also works
with WSDL 1.1 as it is the one currently in predominate use. SAWSDL focuses on
the Interface portion of WSDL 2.0 (or PortType in WSDL 1.1) and its sub-elements.
Semantics is attached to the principal elements within an interface description, simply
by annotating them with concepts from a semantic model (e.g., classes within an
OWL ontology). These annotations are innocuous in that they can be easily filtered
out, leaving the original WSDL.
There are three types of annotations provided by SAWSDL: model references, lift-
ing schema mappings and lowering schema mappings. The model references tell what
an element means in the ontological world, while the mappings allow data to be trans-
formed up (lifted) to the ontological world and returned back down (lowered). Note
that these mappings are really descriptions as well, since they need not be applied
directly at run time. For example, when one service may need to invoke another, a
semantic discovery and composition tool could use these mappings to determine what
services can talk to each other. In composition, the mappings could be composed
providing transformations from one XSD to another and never actually going up to
the ontological world. In Table 1, the SAWSDL annotations are cross referenced with
the elements they annotate.
Let us now consider how this information can be used to discover Web services.
Note that this information is also useful in the composition of Web services, but that
is not the focus of this paper (see [17] for its use in composition). One may reasonably
discover Web services by either looking for operations or interfaces. The other ele-
ments annotated by SAWSDL are too low level, but of course come into play when
looking for operations or interfaces. Let us begin by considering the discovery of
operations. The following is a fragment of SAWSDL from the Rosetta Ontology [18].
248 J. Cardoso, J.A. Miller, and S. Emani
The annotation of the operation named order is a model reference to the Request-
PurchaseOrder class in the purchaseorder ontology. This ontology is loosely
based on the RosettaNet standard for e-commerce, which includes well-defined opera-
tions and sub-operation in their Partner Interface Process (PIP) specifications. In other
words, essential functionality is prescribed. One could view this as a high-level descrip-
tion of functionality or in some cases simply as a categorization of functionality. Other
aspects of an operation include the inputs and outputs and even preconditions and ef-
fects (preconditions and effects are part of WSDL-S, but are initially left out of
SAWSDL for simplicity). Next we look at annotations related to the order operation’s
input.
Here the OrderRequest element is annotated with OrderRequest from the
ontology. This reference opens up the richer typing structures of a language like
OWL versus XSD (e.g., classes, subclasses, named references and restrictions) as
well as inferencing capabilities (e.g., subsumption). Finally, we examine annotations
related to the order operation’s output.
Web Services Discovery Utilizing Semantically Annotated WSDL 249
Here the OrderResponse element is annotated with OrderConfirmation from the
ontology. Similar annotations can be provided for faults, while this is likely to be
more important for composition than discovery.
Although operation discovery is fundamental, practically speaking one often
wishes to invoke multiple operations from a Web service, so in this sense interface
discovery is also important. In this paper, we mainly leave this aspect for future work,
but of course some of the obvious issues are the following: discovery of a set of
operations, temporal dependencies between the operations and statefulness. From a
two party point of view these issues are of concern to a conversation protocol, if gen-
eralized to multiple parties they are of concern to a choreographer (e.g., following the
emerging WS-CDL standard). From the point of view of one of the parties, they can
orchestrate their interactions with the other parties (or partners) via a process specifi-
cation (e.g., following the WS-BPEL standard).
2.3.3 Using Radiant to Add Semantics to WSDL
Radiant [19] is a tool that can be used for marking up Web service descriptions with
ontologies. Radiant is a part of an ongoing project, METEOR-S, in an effort to create
semantic Web processes, at the LSDIS lab – University of Georgia. This tool provides
support for WSDL-S, a joint UGA-IBM specification and SAWSDL. WSDL-S and
SAWSDL allow users to easily add semantics to Web services by using the extensi-
bility elements of WSDL. Radiant provides an intuitive UI for annotation of WSDL
files using ontologies. All the annotations described in the WSDL-S/SAWSDL speci-
fications are supported by this tool. The framework includes algorithms to match and
annotate WSDL files with relevant ontologies using domain ontologies to categorize
Web services into domains. A key enabling capability is to achieve annotation with as
much automation as possible without losing quality (see [19] to understand how
automation is achieved). Figure 3 shows a screenshot of the interface used for annota-
tion. In this figure, the interface provides the user with capabilities of a specifying
WSDL file (on the left side) and an ontology (on the right side) used for mapping.
The user may then simply drag an element (a class or property) from the ontology on
drop it an element in the WSDL file.
While many other efforts have talked about adding semantics to Web services,
practical implications of actually annotating Web services with the use of real world
applications and ontologies have not been discussed in great detail. Manifestly, there
is a lack of real world systems and solutions. The following steps can be followed to
annotate Web services using Radiant
1. Start the Eclipse Workbench1.
2. Open the “Help“ menu.
3. Open the “Software Updates“ submenu
4. Select “Find and Install“
5. Select the “Search for new features to install“ radio button and click next
6. Click “New Remote Site“
7. Enter “http://lsdis.cs.uga.edu/Radiant/UpdateSite“ without the quotes in the URL
box.
8. Enter “Radiant“ without quotes for the name field.
1 http://www.eclipse.org/
250 J. Cardoso, J.A. Miller, and S. Emani
Fig. 3. Radiant tool to annotated WSDL-S and SAWSDL documents
9. Make sure there is a check in the box next to Radiant and click next.
10. Click Finish.
11. When the new dialog box opens, put a check next to Radiant and click next.
12. Select the “I accept terms in the license agreement“ radio button and click next.
13. Then follow any onscreen dialogs and the plug-in will be installed.
14. Click on window drop down menu select open perspective and select Radiant.
The Eclipse screen is divided into three parts one is the navigator/outline part, the
uddi, wsdl viewer and editor, ontology navigator.
1. Create a new project and open an existing WSDL document.
2. On the ontology navigator load the ontology by clicking on or icon.
3. From the Annotation type drop down menu select the annotation type.
4. Click on outline to get the tree view of the WSDL document and select the con-
cept for annotation. Drag the element to the appropriate section of the WSDL
tree. The annotations are added to the document automatically.
3 Matching Algorithm for Semantic Web Services
This section presents an algorithm for matching semantic Web services, called SM-T
(Semantic Matching Web services using Tversky’s model). The algorithm presented
computes the degree of match between two output concepts, two input concepts, and
two functionality concepts of a service request and advertisement, represented by an
Web Services Discovery Utilizing Semantically Annotated WSDL 251
ontology. Given a service request and several advertisements for available Web ser-
vices, this algorithm can be used to find the more suitable Web services. Web services
can be annotated using Radiant [20], as explained previously, and MWSDI [7] and
Lumina [21] can use the SM-T algorithm as part of its discovery infrastructure to
discover Web services.
We exploit the fact that the input, output, and functionality concepts which are
matched may have (in addition to their name) properties (e.g., in the form of attrib-
utes) associated with them, and we also take into account the level of generality
(or specificity) of each concept within the ontology as well as their relationships with
other concepts. Notice that in contrast to semantic-based matching, syntactic-based
matching cannot use this information.
Matching input, output, and functionality concepts differs slightly from calculating
their semantic similarity. One difference is that the functions to compute the semantic
similarity of ontological concepts are usually symmetric, while matching functions
are asymmetric [6]. For example, let us assume that SUMO Finance Ontology2 in
Figure 4 is used to semantically annotate or describe a set of Web services (only an
extract of the ontology is shown). The METEOR-S SUMO Finance Ontology was
created by converting SUMO financial ontology from KIF to OWL.
Fig. 4. Example of the SUMO Finance ontology used to semantically annotate a set of Web
services
2 http://lsdis.cs.uga.edu/projects/meteor-s/wsdl-s/ontologies/SUMO_Finance.owl
252 J. Cardoso, J.A. Miller, and S. Emani
Let us assume that we have a semantic Web service request R with the input con-
cept FinanceAccount (c ) and an advertisement A with the input concept Contract
1
(c ). In this scenario, request R matches advertisement A (i.e., match(c , c )=true),
2 1 2
since FinanceAccount is a subclass of Contract. Our rationale is that if A is able to
deal with the input Contract it must also be able to deal with the input FinanceAc-
count. We can think that when the Web service is invoked there will be some kind of
cast (as in C programming) from FinanceAccount to Contract. This idea and concept
have been first introduced in [22].
Now, let us assume that we have a semantic Web service request R with the input
concept Contract (c ) and an advertisement A with the input concept FinanceAccount
2
(c ). In this scenario, it is possible that the semantic Web service A cannot be invoked
1
with the input Contract since A may need properties that only exist in the class Fi-
nanceAccount. Therefore, match(c , c )=false. As we can see from these two scenar-
2 1
ios, the function match is asymmetric, since match(c , c ) ≠ match (c , c ).
1 2 2 1
3.1 Formal Definition of a Semantic Web Service
One way to handle functionality of a Web service operation is through preconditions,
postconditions and effects. These specifications are usually detailed and precise enough
to work at runtime and may be unwieldy for discovery. Usually, they should be speci-
fied in a rule language like SWRL or RIF. For discovery, however, there are advantages
to sticking with description logic (e.g., OWL). Like other concepts in semantic Web
services, a functionality concept is given meaning according to where it stands in a
hierarchy and by considering its sub-functions. Of course, a fully detailed specification
of sub-functions along with control and data flow could degenerate into a complete
specification of the code for the service. What we are looking for is a concise, high-level
description that facilitates comparison between services. Consequently, we assign a
concept from an ontology to describe the overall functionality of the Web service opera-
tion. This functional concept must specialize its parent concept and generalize all of its
child concepts.
The functional concept can include component functional concepts (children)
which one can think of as carrying out the steps required for the overall functional
concept. Again, programmatic level details should not be included, as they would get
in the way (similar to the situation in the early and mid phases of software design
following a software engineering methodology). The need for annotating inputs and