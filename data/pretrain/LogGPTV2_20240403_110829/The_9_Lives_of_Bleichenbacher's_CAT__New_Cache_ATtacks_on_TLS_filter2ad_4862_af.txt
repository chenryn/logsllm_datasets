Jan. 1999.
[20] T. Dierks and E. Rescorla, “The Transport Layer Security (TLS) Protocol
Version 1.1,” RFC 4346, Apr. 2006.
[21] ——, “The Transport Layer Security (TLS) Protocol Version 1.2,” RFC
5246, Aug. 2008.
[22] C. Disselkoen, D. Kohlbrenner, L. Porter, and D. M. Tullsen,
“Prime+Abort: A timer-free high-precision L3 cache attack using intel
TSX,” in USENIX Sec, 2017.
[23] T. Duong and J. Rizzo, “Here come the ⊕ ninjas,” 2011.
[24] D. Evtyushkin, D. Ponomarev, and N. B. Abu-Ghazaleh, “Understand-
ing and mitigating covert channels through branch predictors,” TACO,
vol. 13, no. 1, 2016.
[25] D. Evtyushkin, D. V. Ponomarev, and N. B. Abu-Ghazaleh, “Jump over
ASLR: attacking branch predictors to bypass ASLR,” in MICRO, 2016.
[26] D. Evtyushkin, R. Riley, N. B. Abu-Ghazaleh, and D. Ponomarev,
“BranchScope: A new side-channel attack on directional branch pre-
dictor,” in ASPLOS, 2018.
[27] Q. Ge, Y. Yarom, D. Cock, and G. Heiser, “A survey of microarchitec-
tural timing attacks and countermeasures on contemporary hardware,”
J. Cryptographic Engineering, vol. 8, no. 1, 2018.
[28] Q. Ge, Y. Yarom, and G. Heiser, “No security without time protection:
We need a new hardware-software contract,” in APSys, Aug. 2018.
[29] D. Genkin, L. Pachmanov, I. Pipman, E. Tromer, and Y. Yarom,
“ECDSA key extraction from mobile devices via nonintrusive physical
side channels,” in CCS, 2016.
[30] D. Genkin, L. Valenta, and Y. Yarom, “May the fourth be with you: A
microarchitectural side channel attack on several real-world applications
of Curve25519,” in CCS, 2017.
[31] D. Genkin, L. Pachmanov, E. Tromer, and Y. Yarom, “Drive-by key-
extraction cache attacks from portable code,” in ACNS, 2018.
[32] D. Gruss, R. Spreitzer, and S. Mangard, “Cache template attacks:
Automating attacks on inclusive last-level caches,” in USENIX Sec,
2015.
[33] D. Gruss, C. Maurice, K. Wagner, and S. Mangard, “Flush+Flush: A
fast and stealthy cache attack,” in DIMVA, 2016.
[34] N. Howgrave-Graham and N. P. Smart, “Lattice attacks on digital
signature schemes,” Des. Codes Cryptography, vol. 23, no. 3, 2001.
[35] M. S. Inci, B. G¨ulmezoglu, T. Eisenbarth, and B. Sunar, “Co-location
detection on the cloud,” in COSADE, 2016.
[36] M. S. Inci, B. G¨ulmezoglu, G. Irazoqui, T. Eisenbarth, and B. Sunar,
“Cache attacks enable bulk key recovery on the cloud,” in CHES, 2016.
mitigations,”
“Speculative
[37] Intel,
execution
channel
side
https://software.intel.com/sites/default/ﬁles/managed/c5/63/336996-
Speculative-Execution-Side-Channel-Mitigations.pdf, May 2018.
[38] G. Irazoqui, T. Eisenbarth, and B. Sunar, “S$A: A shared cache attack
that works across cores and deﬁes VM sandboxing - and its application
to AES,” in IEEE SP, 2015, pp. 591–604.
[39] G. Irazoqui, M. S. Inci, T. Eisenbarth, and B. Sunar, “Lucky 13 strikes
back,” in ASIA CCS, 2015.
[40] T. Jager, S. Schinzel, and J. Somorovsky, “Bleichenbacher’s attack
strikes again: Breaking PKCS#1 v1.5 in XML encryption,” in ESORICS,
2012.
[41] T. Jager, J. Schwenk, and J. Somorovsky, “On the security of TLS 1.3
and QUIC against weaknesses in PKCS#1 v1.5 encryption,” in CCS,
2015.
[42] V. Kl´ıma, O. Pokorn´y, and T. Rosa, “Attacking RSA-based sessions in
SSL/TLS,” in CHES, 2003.
[43] P. Kocher, J. Horn, A. Fogh, D. Genkin, D. Gruss, W. Haas, M. Haburg,
M. Lipp, S. Mangard, T. Prescher, M. Schwartz, and Y. Yarom, “Spectre
attacks: Exploiting speculative execution,” in IEEE SP, 2019.
[44] S. Lee, M. Shih, P. Gera, T. Kim, H. Kim, and M. Peinado, “Inferring
ﬁne-grained control ﬂow inside SGX enclaves with branch shadowing,”
in USENIX Sec, 2017.
[45] A. K. Lenstra, H. W. Lenstra, and L. Lov´asz, “Factoring polynomials
with rational coefﬁcients,” Mathematische Annalen, vol. 261, no. 4,
1982.
[46] F. Liu, Y. Yarom, Q. Ge, G. Heiser, and R. B. Lee, “Last-level cache
side-channel attacks are practical,” in IEEE SP, 2015.
[47] J. Manger, “A chosen ciphertext attack on RSA optimal asymmetric
encryption padding (OAEP) as standardized in PKCS #1 v2.0,” in
CRYPTO, 2001.
[48] C. Meyer, J. Somorovsky, E. Weiss, J. Schwenk, S. Schinzel, and
E. Tews, “Revisiting SSL/TLS implementations: New Bleichenbacher
side channels and attacks,” in USENIX Sec, 2014.
[49] D. Migault and I. Boureanu, “LURK extension version 1 for (D)TLS
1.2 authentication,” IETF, Internet-Draft draft-mglt-lurk-tls12-01, 2018.
[50] A. Moghimi, G. Irazoqui, and T. Eisenbarth, “CacheZoom: How SGX
ampliﬁes the power of cache attacks,” in CHES, 2017.
[51] Mozilla, “SSL handshake key exchange algorithm for full handshake,”
https://mzl.la/2BQjcMO.
[52] P. Q. Nguyen, Public-Key Cryptanalysis, ser. Contemporary Mathemat-
ics. AMS–RSME, 2009, vol. 477.
[53] P. Q. Nguyen and I. E. Shparlinski, “The insecurity of the Digital Sig-
nature Algorithm with partially known nonces,” J. Cryptology, vol. 15,
no. 3, 2002.
[54] OpenSSL, “RSA public encrypt,” https://www.openssl.org/docs/man1.
0.2/crypto/RSA private decrypt.html.
[55] Y. Oren, V. P. Kemerlis, S. Sethumadhavan, and A. D. Keromytis,
“The spy in the sandbox: Practical cache attacks in JavaScript and their
implications,” in CCS, 2015.
[56] D. A. Osvik, A. Shamir, and E. Tromer, “Cache attacks and counter-
measures: The case of AES,” in CT-RSA, 2006.
[57] C. Percival, “Cache missing for fun and proﬁt,” in Proceedings of
BSDCan, 2005.
[58] T. Ristenpart, E. Tromer, H. Shacham, and S. Savage, “Hey, you, get
off of my cloud: exploring information leakage in third-party compute
clouds,” in CCS, 2009.
[59] R. L. Rivest, A. Shamir, and L. M. Adleman, “A method for obtain-
ing digital signatures and public-key cryptosystems,” Commun. ACM,
vol. 21, no. 2, 1978.
(cid:21)(cid:21)(cid:25)
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:53:49 UTC from IEEE Xplore.  Restrictions apply. 
[60] E. Ronen, K. G. Paterson, and A. Shamir, “Pseudo constant
implementations of TLS are only pseudo secure,” in CCS, 2018.
[61] PKCS #1 v2.2: RSA Cryptography Standard, RSA Laboratories, 2012.
[62] S. Schmidt, “Introducing s2n, a new open source tls implemen-
tation,” https://aws.amazon.com/blogs/security/introducing-s2n-a-new-
open-source-tls-implementation/, 2015.
[63] The Sage Developers, SageMath, the Sage Mathematics Software System
time
(Version 8.3), www.sagemath.org, 2018.
[64] Y. Tsunoo, T. Saito, T. Suzaki, M. Shigeri, and H. Miyauchi, “Cryptanal-
ysis of DES implemented on computers with cache,” in CHES, 2003.
[65] V. Varadarajan, Y. Zhang, T. Ristenpart, and M. M. Swift, “A placement
vulnerability study in multi-tenant public clouds,” in USENIX Sec, 2015.
[66] Y. Xiao, M. Li, S. Chen, and Y. Zhang, “STACCO: differentially
analyzing side-channel traces for detecting SSL/TLS vulnerabilities in
secure enclaves,” in CCS, 2017.
[67] M. Yan, C. W. Fletcher, and J. Torrellas, “Cache telepathy: Leverag-
ing shared resource attacks to learn DNN architectures,” CoRR, vol.
abs/1808.04761, 2018.
adelaide.edu.au/∼yval/Mastik/Mastik.pdf, 2017.
[68] Y. Yarom, “Mastik: A micro-architectural side-channel
toolkit,” cs.
[69] Y. Yarom and K. Falkner, “FLUSH+RELOAD: A high resolution, low
noise, L3 cache side-channel attack,” in USENIX Sec, 2014.
[70] X. Zhang, Y. Xiao, and Y. Zhang, “Return-oriented Flush-Reload side
channels on ARM and their implications for Android devices,” in CCS,
2016.
[71] Y. Zhang, A. Juels, M. K. Reiter, and T. Ristenpart, “Cross-tenant side-
channel attacks in PaaS clouds,” in CCS, 2014.
[72] ——, “Cross-tenant side-channel attacks in PaaS clouds,” in CCS, 2014.
APPENDIX A
VULNERABILITIES DESCRIPTION
A. OpenSSL TLS Implementation
Perhaps aware of the side channel
issues in its RSA
decryption API, OpenSSL does not use the code described
in Section IV-B for its own TLS implementation. Instead,
OpenSSL reimplemented the RSA PKCS #1 v1.5 padding
veriﬁcation as part of its TLS protocol code. This constant time
implementation does not appear to be vulnerable to a cache-
based padding oracle attack. However, OpenSSL’s code does
contain two side channel vulnerabilities. One vulnerability has
been described in Section IV-A and the other is presented here.
We note that OpenSSL replaced the vulnerable code in both
locations with constant-time implementations independently of
our disclosure.
Leaky Data Conversation. As mentioned in Section IV, the
big numbers representing the RSA ciphertext and plaintext
are typically saved as an array of 32-bit words, while the
result of the PKCS #1 v1.5 padding is an array of bytes.
To convert
the data from one representation to the other,
OpenSSL uses a serialization function which takes as input
a big number and serializes it into a byte array (where index
0 is the most signiﬁcant byte). To avoid creating a padding
oracle, it is important that the serialization function be written
in a constant-time manner, and not leak the length of the RSA
plaintext during the serialization process.
The pseudocode of OpenSSL’s serialization function is
presented in Listing 5. Notice the while loop in Line 9,
which performs as many iterations as the number of non-
zero bytes of the RSA plaintext, resulting in a Manger-type
padding oracle. Traditionally, mounting such precise microar-
chitectural attacks is difﬁcult, as a single loop iteration takes
less time than the channel’s temporal resolution. However,
i = BN_num_bytes(bn);
tolen=i
// Padding code removed for brevity
while (i--) {
1 int BN2binpad((bn, to)){
2 //bn is big number (storing the RSA plaintext)
3 //to is the output buffer
4 //BN_BYTES is the number of bytes in each bn word
5
6
7
8
9
10
11
12
13
14
15 }
l = bn[i / BN_BYTES];
*(to++) = (unsigned char)
( l>> (8 * (i % BN_BYTES))) & 0xff;
}
return tolen;
Listing 5. Pseudocode of big number serialization functions
recent works [16, 17, 50] have shown that mounting high
precision side channel attacks is possible in the case of trusted
execution environments (e.g., Intel SGX), often with cycle-
accurate resolution.
B. Amazon s2n
S2n is Amazon’s implementation of the TLS protocol, used
as part of Amazon Web Services. It simpliﬁes the OpenSSL
TLS implementation, removing uncommon and deprecated
TLS conﬁgurations. The implementation of RSA decryption
(Listing 6) invokes the OpenSSL RSA private decrypt API
function to process and remove the PKCS #1 v1.5 padding
(Line 6). We have already discussed the weakness due to the
use of the OpenSSL function (Section IV-B). We now discuss
another vulnerability in the s2n code.
Leaky PKCS #1 v1.5 Veriﬁcation.
In case the decryption
and PKCS #1 v1.5 veriﬁcation succeeds and the output is of
the expected length, s2n copies the data to the output array
(Line 7). Moreover, the decision of whether to copy and the
copy itself is done in constant time to avoid leaking the result
of the result of the PKCS #1 v1.5 unpadding.
However, the s2n API relies on the error status returned
from OpenSSL to identify padding failures or mis-formatted
output. Thus, s2n uses an if macro, which compiles to a
conditional branch (see Line 8), which yields an FFFT oracle.
C. MbedTLS
MbedTLS aims at providing a portable, easy to use and
to read implementation of the TLS protocol and is designed
primerly to be used in low powered embedded devices. We
have identiﬁed vulnerabilities in both the data conversion
and the PKCS #1 v1.5 veriﬁcation stages of the mbedTLS
implementation which we now describe.
Leaky PKCS #1 v1.5 Veriﬁcation.
Listing 7 shows the
relevant parts of the mbedTLS PKCS #1 v1.5 veriﬁcation
For brevity we omit the padding format and plaintext length
validation, which execute in constant-time. The rest of the
code, however uses conditional branches to handle padding
validation failures (Lines 7–10) and incorrect plaintext length
(Lines 12–15). Thus, despite the constant-time validation, the
following form of oracles are still exposed.
(cid:21)(cid:21)(cid:26)
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:53:49 UTC from IEEE Xplore.  Restrictions apply. 
1 int s2n_rsa_decrypt(priv, in, out){
unsigned char intermediate[4096];
2
const s2n_rsa_private_key *key = &priv->key.rsa_key;
3
S2N_ERROR_IF(s2n_rsa_private_encrypted_size(key) > sizeof(intermediate), S2N_ERR_NOMEM);
4
S2N_ERROR_IF(out->size > sizeof(intermediate), S2N_ERR_NOMEM);
5
int r = RSA_private_decrypt(in->size, in->data, intermediate, key->rsa, RSA_PKCS1_PADDING);
6
GUARD(s2n_constant_time_copy_or_dont(out->data, intermediate, out->size, r != out->size));
7
S2N_ERROR_IF(r != out->size, S2N_ERR_SIZE_MISMATCH);
8
return 0;
9
10 }
Listing 6. Pseudocode of Amazon s2n’s wrap for OpenSSL’s API
1 int mbedtls_rsa_rsaes_pkcs1_v15_decrypt(
2 ilen, olen, input, output, output_max_len) {
3
4
...
//Omited code checks for valid padding and
length of decrypted plaintext
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24 }
bad |= ( pad_count  output_max_len ){
ret = MBEDTLS_ERR_RSA_OUTPUT_TOO_LARGE;
goto cleanup;
}
*olen = ilen - (p - buf);
memcpy( output, p, *olen );
ret = 0;
cleanup:
mbedtls_zeroize( buf, sizeof( buf ) );
return( ret );
Listing 7. MbedTLS’s unpadding function
• Potentially Leaky Comparison. First, the comparison in
Line 6 may be implemented using conditional statements,
which would leak via branch prediction. This does not
happen in our test environment, where the comparison is
implemented using a conditional set
instruction, which
to the best of our knowledge executes in constant-time.
However without a guarantee that the compiler will use a
constant-time implementation there is a potential for a leak
in other environments.
• Length Dependant Branches. Both if statements in Lines 7
and 12 can be exploited for a branch prediction attack. The
former allows a FFTT Bleichenbacher oracle and the latter
allows an FFFT oracle variant. In fact, the oracle is slightly
stronger than a standard FFFT oracle because the test is
one sided, i.e. it only checks for maximum size instead of
checking for exact size.
• Length Dependant Early Termination.
Finally, due
to early termination on bad inputs, the code that copies
to the output (Line 18) is only executed if the plaintext
is PKCS #1 v1.5 conforming. Thus we can implement an
FFFT oracle via an instruction cache attack, monitoring
either the call to memcpy or the code of memcpy itself.
Leaky Data Conversion. The last step in the implementation
of RSA decryption in mbedTLS is to copy the plaintext to the
size_t j;
mask = 1 >= 1;
for( j = 0; j < biL; j++ ){
}
return j;
Listing 8. MbedTLS’s bit length checking function function
output. As discussed in Section IV, there is no a-priory method
for determining the plaintext’s length, and applications can
only determine the length after decryption. To determine the