### References

1. **Jan. 1999.**
2. **T. Dierks and E. Rescorla, "The Transport Layer Security (TLS) Protocol Version 1.1," RFC 4346, Apr. 2006.**
3. **——, "The Transport Layer Security (TLS) Protocol Version 1.2," RFC 5246, Aug. 2008.**
4. **C. Disselkoen, D. Kohlbrenner, L. Porter, and D. M. Tullsen, "Prime+Abort: A timer-free high-precision L3 cache attack using Intel TSX," in USENIX Sec, 2017.**
5. **T. Duong and J. Rizzo, "Here come the ⊕ ninjas," 2011.**
6. **D. Evtyushkin, D. Ponomarev, and N. B. Abu-Ghazaleh, "Understanding and mitigating covert channels through branch predictors," TACO, vol. 13, no. 1, 2016.**
7. **D. Evtyushkin, D. V. Ponomarev, and N. B. Abu-Ghazaleh, "Jump over ASLR: attacking branch predictors to bypass ASLR," in MICRO, 2016.**
8. **D. Evtyushkin, R. Riley, N. B. Abu-Ghazaleh, and D. Ponomarev, "BranchScope: A new side-channel attack on directional branch predictor," in ASPLOS, 2018.**
9. **Q. Ge, Y. Yarom, D. Cock, and G. Heiser, "A survey of microarchitectural timing attacks and countermeasures on contemporary hardware," J. Cryptographic Engineering, vol. 8, no. 1, 2018.**
10. **Q. Ge, Y. Yarom, and G. Heiser, "No security without time protection: We need a new hardware-software contract," in APSys, Aug. 2018.**
11. **D. Genkin, L. Pachmanov, I. Pipman, E. Tromer, and Y. Yarom, "ECDSA key extraction from mobile devices via nonintrusive physical side channels," in CCS, 2016.**
12. **D. Genkin, L. Valenta, and Y. Yarom, "May the fourth be with you: A microarchitectural side channel attack on several real-world applications of Curve25519," in CCS, 2017.**
13. **D. Genkin, L. Pachmanov, E. Tromer, and Y. Yarom, "Drive-by key-extraction cache attacks from portable code," in ACNS, 2018.**
14. **D. Gruss, R. Spreitzer, and S. Mangard, "Cache template attacks: Automating attacks on inclusive last-level caches," in USENIX Sec, 2015.**
15. **D. Gruss, C. Maurice, K. Wagner, and S. Mangard, "Flush+Flush: A fast and stealthy cache attack," in DIMVA, 2016.**
16. **N. Howgrave-Graham and N. P. Smart, "Lattice attacks on digital signature schemes," Des. Codes Cryptography, vol. 23, no. 3, 2001.**
17. **M. S. Inci, B. Gülmezoglu, T. Eisenbarth, and B. Sunar, "Co-location detection on the cloud," in COSADE, 2016.**
18. **M. S. Inci, B. Gülmezoglu, G. Irazoqui, T. Eisenbarth, and B. Sunar, "Cache attacks enable bulk key recovery on the cloud," in CHES, 2016.**
19. **Intel, "Speculative execution side channel mitigations," https://software.intel.com/sites/default/files/managed/c5/63/336996-Speculative-Execution-Side-Channel-Mitigations.pdf, May 2018.**
20. **G. Irazoqui, T. Eisenbarth, and B. Sunar, "S$A: A shared cache attack that works across cores and defies VM sandboxing - and its application to AES," in IEEE SP, 2015, pp. 591–604.**
21. **G. Irazoqui, M. S. Inci, T. Eisenbarth, and B. Sunar, "Lucky 13 strikes back," in ASIA CCS, 2015.**
22. **T. Jager, S. Schinzel, and J. Somorovsky, "Bleichenbacher’s attack strikes again: Breaking PKCS#1 v1.5 in XML encryption," in ESORICS, 2012.**
23. **T. Jager, J. Schwenk, and J. Somorovsky, "On the security of TLS 1.3 and QUIC against weaknesses in PKCS#1 v1.5 encryption," in CCS, 2015.**
24. **V. Klíma, O. Pokorný, and T. Rosa, "Attacking RSA-based sessions in SSL/TLS," in CHES, 2003.**
25. **P. Kocher, J. Horn, A. Fogh, D. Genkin, D. Gruss, W. Haas, M. Haburg, M. Lipp, S. Mangard, T. Prescher, M. Schwartz, and Y. Yarom, "Spectre attacks: Exploiting speculative execution," in IEEE SP, 2019.**
26. **S. Lee, M. Shih, P. Gera, T. Kim, H. Kim, and M. Peinado, "Inferring fine-grained control flow inside SGX enclaves with branch shadowing," in USENIX Sec, 2017.**
27. **A. K. Lenstra, H. W. Lenstra, and L. Lovász, "Factoring polynomials with rational coefficients," Mathematische Annalen, vol. 261, no. 4, 1982.**
28. **F. Liu, Y. Yarom, Q. Ge, G. Heiser, and R. B. Lee, "Last-level cache side-channel attacks are practical," in IEEE SP, 2015.**
29. **J. Manger, "A chosen ciphertext attack on RSA optimal asymmetric encryption padding (OAEP) as standardized in PKCS #1 v2.0," in CRYPTO, 2001.**
30. **C. Meyer, J. Somorovsky, E. Weiss, J. Schwenk, S. Schinzel, and E. Tews, "Revisiting SSL/TLS implementations: New Bleichenbacher side channels and attacks," in USENIX Sec, 2014.**
31. **D. Migault and I. Boureanu, "LURK extension version 1 for (D)TLS 1.2 authentication," IETF, Internet-Draft draft-mglt-lurk-tls12-01, 2018.**
32. **A. Moghimi, G. Irazoqui, and T. Eisenbarth, "CacheZoom: How SGX amplifies the power of cache attacks," in CHES, 2017.**
33. **Mozilla, "SSL handshake key exchange algorithm for full handshake," https://mzl.la/2BQjcMO.**
34. **P. Q. Nguyen, Public-Key Cryptanalysis, ser. Contemporary Mathematics. AMS–RSME, 2009, vol. 477.**
35. **P. Q. Nguyen and I. E. Shparlinski, "The insecurity of the Digital Signature Algorithm with partially known nonces," J. Cryptology, vol. 15, no. 3, 2002.**
36. **OpenSSL, "RSA public encrypt," https://www.openssl.org/docs/man1.0.2/crypto/RSA_private_decrypt.html.**
37. **Y. Oren, V. P. Kemerlis, S. Sethumadhavan, and A. D. Keromytis, "The spy in the sandbox: Practical cache attacks in JavaScript and their implications," in CCS, 2015.**
38. **D. A. Osvik, A. Shamir, and E. Tromer, "Cache attacks and countermeasures: The case of AES," in CT-RSA, 2006.**
39. **C. Percival, "Cache missing for fun and profit," in Proceedings of BSDCan, 2005.**
40. **T. Ristenpart, E. Tromer, H. Shacham, and S. Savage, "Hey, you, get off of my cloud: exploring information leakage in third-party compute clouds," in CCS, 2009.**
41. **R. L. Rivest, A. Shamir, and L. M. Adleman, "A method for obtaining digital signatures and public-key cryptosystems," Commun. ACM, vol. 21, no. 2, 1978.**
42. **E. Ronen, K. G. Paterson, and A. Shamir, "Pseudo constant implementations of TLS are only pseudo secure," in CCS, 2018.**
43. **PKCS #1 v2.2: RSA Cryptography Standard, RSA Laboratories, 2012.**
44. **S. Schmidt, "Introducing s2n, a new open source TLS implementation," https://aws.amazon.com/blogs/security/introducing-s2n-a-new-open-source-tls-implementation/, 2015.**
45. **The Sage Developers, SageMath, the Sage Mathematics Software System (Version 8.3), www.sagemath.org, 2018.**
46. **Y. Tsunoo, T. Saito, T. Suzaki, M. Shigeri, and H. Miyauchi, "Cryptanalysis of DES implemented on computers with cache," in CHES, 2003.**
47. **V. Varadarajan, Y. Zhang, T. Ristenpart, and M. M. Swift, "A placement vulnerability study in multi-tenant public clouds," in USENIX Sec, 2015.**
48. **Y. Xiao, M. Li, S. Chen, and Y. Zhang, "STACCO: differentially analyzing side-channel traces for detecting SSL/TLS vulnerabilities in secure enclaves," in CCS, 2017.**
49. **M. Yan, C. W. Fletcher, and J. Torrellas, "Cache telepathy: Leveraging shared resource attacks to learn DNN architectures," CoRR, vol. abs/1808.04761, 2018.**
50. **Y. Yarom, "Mastik: A micro-architectural side-channel toolkit," cs.adelaide.edu.au/~yval/Mastik/Mastik.pdf, 2017.**
51. **Y. Yarom and K. Falkner, "FLUSH+RELOAD: A high resolution, low noise, L3 cache side-channel attack," in USENIX Sec, 2014.**
52. **X. Zhang, Y. Xiao, and Y. Zhang, "Return-oriented Flush-Reload side channels on ARM and their implications for Android devices," in CCS, 2016.**
53. **Y. Zhang, A. Juels, M. K. Reiter, and T. Ristenpart, "Cross-tenant side-channel attacks in PaaS clouds," in CCS, 2014.**
54. **——, "Cross-tenant side-channel attacks in PaaS clouds," in CCS, 2014.**

### Appendix A: Vulnerabilities Description

#### A. OpenSSL TLS Implementation

OpenSSL is aware of the side-channel issues in its RSA decryption API and has not used the code described in Section IV-B for its own TLS implementation. Instead, OpenSSL reimplemented the RSA PKCS #1 v1.5 padding verification as part of its TLS protocol code. This constant-time implementation does not appear to be vulnerable to a cache-based padding oracle attack. However, OpenSSL's code contains two side-channel vulnerabilities. One vulnerability is described in Section IV-A, and the other is presented here. It is noted that OpenSSL replaced the vulnerable code in both locations with constant-time implementations independently of our disclosure.

**Leaky Data Conversion:**
As mentioned in Section IV, big numbers representing the RSA ciphertext and plaintext are typically saved as an array of 32-bit words, while the result of the PKCS #1 v1.5 padding is an array of bytes. To convert the data from one representation to the other, OpenSSL uses a serialization function that takes a big number as input and serializes it into a byte array (where index 0 is the most significant byte). To avoid creating a padding oracle, it is important that the serialization function be written in a constant-time manner and not leak the length of the RSA plaintext during the serialization process.

The pseudocode of OpenSSL's serialization function is presented in Listing 5. Notice the while loop in Line 9, which performs as many iterations as the number of non-zero bytes of the RSA plaintext, resulting in a Manger-type padding oracle. Traditionally, mounting such precise microarchitectural attacks is difficult, as a single loop iteration takes less time than the channel's temporal resolution. However, recent works [16, 17, 50] have shown that mounting high-precision side-channel attacks is possible in the case of trusted execution environments (e.g., Intel SGX), often with cycle-accurate resolution.

```c
int BN2binpad(bn, to) {
    // bn is big number (storing the RSA plaintext)
    // to is the output buffer
    // BN_BYTES is the number of bytes in each bn word
    int i = BN_num_bytes(bn);
    int tolen = i;
    // Padding code removed for brevity
    while (i--) {
        l = bn[i / BN_BYTES];
        *(to++) = (unsigned char)((l >> (8 * (i % BN_BYTES))) & 0xff);
    }
    return tolen;
}
```

#### B. Amazon s2n

s2n is Amazon's implementation of the TLS protocol, used as part of Amazon Web Services. It simplifies the OpenSSL TLS implementation by removing uncommon and deprecated TLS configurations. The implementation of RSA decryption (Listing 6) invokes the OpenSSL RSA private decrypt API function to process and remove the PKCS #1 v1.5 padding (Line 6). We have already discussed the weakness due to the use of the OpenSSL function (Section IV-B). We now discuss another vulnerability in the s2n code.

**Leaky PKCS #1 v1.5 Verification:**
If the decryption and PKCS #1 v1.5 verification succeed and the output is of the expected length, s2n copies the data to the output array (Line 7). Moreover, the decision of whether to copy and the copy itself is done in constant time to avoid leaking the result of the PKCS #1 v1.5 unpadding. However, the s2n API relies on the error status returned from OpenSSL to identify padding failures or mis-formatted output. Thus, s2n uses an if macro, which compiles to a conditional branch (see Line 8), which yields an FFFT oracle.

```c
int s2n_rsa_decrypt(priv, in, out) {
    unsigned char intermediate[4096];
    const s2n_rsa_private_key *key = &priv->key.rsa_key;
    S2N_ERROR_IF(s2n_rsa_private_encrypted_size(key) > sizeof(intermediate), S2N_ERR_NOMEM);
    S2N_ERROR_IF(out->size > sizeof(intermediate), S2N_ERR_NOMEM);
    int r = RSA_private_decrypt(in->size, in->data, intermediate, key->rsa, RSA_PKCS1_PADDING);
    GUARD(s2n_constant_time_copy_or_dont(out->data, intermediate, out->size, r != out->size));
    S2N_ERROR_IF(r != out->size, S2N_ERR_SIZE_MISMATCH);
    return 0;
}
```

#### C. MbedTLS

MbedTLS aims to provide a portable, easy-to-use, and easy-to-read implementation of the TLS protocol, designed primarily for use in low-powered embedded devices. We have identified vulnerabilities in both the data conversion and the PKCS #1 v1.5 verification stages of the mbedTLS implementation, which we now describe.

**Leaky PKCS #1 v1.5 Verification:**
Listing 7 shows the relevant parts of the mbedTLS PKCS #1 v1.5 verification. For brevity, we omit the padding format and plaintext length validation, which execute in constant time. The rest of the code, however, uses conditional branches to handle padding validation failures (Lines 7–10) and incorrect plaintext length (Lines 12–15). Thus, despite the constant-time validation, the following forms of oracles are still exposed.

```c
int mbedtls_rsa_rsaes_pkcs1_v15_decrypt(ilen, olen, input, output, output_max_len) {
    ...
    // Omited code checks for valid padding and length of decrypted plaintext
    bad |= (pad_count < 8 || pad_count > ilen - 11);
    if (bad) {
        ret = MBEDTLS_ERR_RSA_INVALID_PADDING;
        goto cleanup;
    }
    p = buf + ilen - *olen;
    if (*olen > output_max_len) {
        ret = MBEDTLS_ERR_RSA_OUTPUT_TOO_LARGE;
        goto cleanup;
    }
    *olen = ilen - (p - buf);
    memcpy(output, p, *olen);
    ret = 0;
cleanup:
    mbedtls_zeroize(buf, sizeof(buf));
    return ret;
}
```

- **Potentially Leaky Comparison:** The comparison in Line 6 may be implemented using conditional statements, which would leak via branch prediction. This does not happen in our test environment, where the comparison is implemented using a conditional set instruction, which, to the best of our knowledge, executes in constant time. However, without a guarantee that the compiler will use a constant-time implementation, there is a potential for a leak in other environments.
- **Length-Dependent Branches:** Both if statements in Lines 7 and 12 can be exploited for a branch prediction attack. The former allows a FFTT Bleichenbacher oracle, and the latter allows an FFFT oracle variant. In fact, the oracle is slightly stronger than a standard FFFT oracle because the test is one-sided, i.e., it only checks for maximum size instead of checking for exact size.
- **Length-Dependent Early Termination:** Finally, due to early termination on bad inputs, the code that copies to the output (Line 18) is only executed if the plaintext is PKCS #1 v1.5 conforming. Thus, we can implement an FFFT oracle via an instruction cache attack, monitoring either the call to `memcpy` or the code of `memcpy` itself.

**Leaky Data Conversion:**
The last step in the implementation of RSA decryption in mbedTLS is to copy the plaintext to the output. As discussed in Section IV, there is no a priori method for determining the plaintext's length, and applications can only determine the length after decryption. To determine the bit length, mbedTLS uses the function shown in Listing 8.

```c
size_t j;
mask = 1 >= 1;
for (j = 0; j < biL; j++) {
    ...
}
return j;
```

This function, while seemingly simple, can also be a source of side-channel leaks if not implemented carefully.