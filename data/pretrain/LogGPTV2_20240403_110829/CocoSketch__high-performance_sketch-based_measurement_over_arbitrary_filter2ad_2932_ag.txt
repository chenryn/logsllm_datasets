1 âˆ’ ğ‘
ğ‘—
ğ‘¤2
ğ‘
=
= 2ğ‘¤ ğ‘“ğ‘—
âˆ’ ğ‘“ 2
ğ‘—
â–¡
CocoSketch: High-Performance Arbitrary Partial Key Measurement
SIGCOMM â€™21, August 23â€“28, 2021, Virtual Event, USA
otherwise. We define
ğ¶ğ‘–,ğ‘— (ğ‘’) =
We have
Var(cid:104)(cid:100)ğ¶ğ‘–,ğ‘— (ğ‘’)(cid:105)
Lemma 5. For any flow ğ‘’ of any key ğ‘˜ â‰º ğ‘˜ğ¹ , in the hardware-
friendly CocoSketch,
Proof. In the ğ‘–ğ‘¡â„ array, let ğ¼ğ‘–,ğ‘— (ğ‘’) be 1 if ğ‘˜(ğµğ‘–[ ğ‘—].ğ¾) = ğ‘’ and 0
ğ‘™
=
ğ‘˜(ğ‘)=ğ‘’
â„ğ‘– (ğ‘)=ğ‘—
ğ‘“ (ğ‘’) Â· ğ‘“ (ğ‘’)
Var(cid:104)(cid:98)ğ‘“ğ‘–(ğ‘’)(cid:105)

ğ‘“ (ğ‘), (cid:100)ğ¶ğ‘–,ğ‘— (ğ‘’) = ğ¼ğ‘–,ğ‘— (ğ‘’) Â· ğµğ‘–[ ğ‘—].ğ‘‰
= ğ¶ğ‘–,ğ‘— (ğ‘’) Â· E(cid:2)ğµğ‘–[ ğ‘—].ğ‘‰ âˆ’ ğ¶ğ‘–,ğ‘— (ğ‘’)(cid:3) = ğ¶ğ‘–,ğ‘— (ğ‘’) Â· ğ‘“ (ğ‘’)
Cov(cid:104)(cid:100)ğ¶ğ‘–,ğ‘— (ğ‘’),(cid:100)ğ¶ğ‘–,ğ‘˜(ğ‘’)(cid:105)
 ğ‘™
Var(cid:104)(cid:98)ğ‘“ğ‘–(ğ‘’)(cid:105)
(cid:100)ğ¶ğ‘–,ğ‘— (ğ‘’)
ğ‘—=1
ğ¶ğ‘–,ğ‘— (ğ‘’) Â· ğ‘“ (ğ‘’)
= 0, ğ‘— â‰  ğ‘˜
ğ‘™
= Var
ğ‘™
E
A.2 Error Bound
In this section, we first prove the unbiasedness of both basic Co-
coSketch and hardware-friendly CocoSketch. Then, we prove the
error bound of Theorem 3 shown in Â§5.2.
ketch,
= ğ‘“ (ğ‘’)
Lemma 3. For any flow ğ‘’ of any key ğ‘˜ â‰º ğ‘˜ğ¹ , in the basic CocoS-
(cid:104)(cid:98)ğ‘“ (ğ‘’)(cid:105)
= ğ‘“ (ğ‘’). Let(cid:98)ğ‘“ ğ‘¡ (ğ‘’) be the estimated size
the expected increment to(cid:98)ğ‘“ ğ‘¡ (ğ‘’) is ğ‘¤ if ğ‘’ = ğ‘’ğ‘– and 0 otherwise.
basic CocoSketch, E
of ğ‘’ before ğ‘¡ğ‘¡â„ insertion. Suppose that the incoming packet is (ğ‘’ğ‘–, ğ‘¤)
for the ğ‘¡ğ‘¡â„ insertion. We prove the unbiasedness by showing that
Proof. We first prove that, for any flow ğ‘’ of full key ğ‘˜ğ¹ , in the
(cid:104)(cid:98)ğ‘“ (ğ‘’)(cid:105)
If ğ‘’ = ğ‘’ğ‘–, there are two cases. Case 1: If ğ‘’ is recorded, the estimated
size will be increased by ğ‘¤. Case 2: If ğ‘’ is not recorded, suppose
that the mapped bucket whose value is the smallest is in the ğ‘˜ğ‘¡â„
array. The expected increment is
(ğµğ‘˜ [â„ğ‘˜(ğ‘’)].ğ‘‰ + ğ‘¤) Â·
ğ‘¤
If ğ‘’ â‰  ğ‘’ğ‘–, there are two cases. Case 1: If ğ‘’ is recorded and the
corresponding bucket will be updated, the expected increment is
(ğµğ‘˜ [â„ğ‘˜(ğ‘’)].ğ‘‰ + ğ‘¤) = ğ‘¤
(cid:16)(cid:98)ğ‘“ ğ‘¡ (ğ‘’) + ğ‘¤(cid:17) Â·
Therefore, the expected increment to(cid:98)ğ‘“ ğ‘¡ (ğ‘’) is ğ‘¤ if ğ‘’ = ğ‘’ğ‘–.
(cid:98)ğ‘“ ğ‘¡ (ğ‘’)
(cid:16)(cid:98)ğ‘“ ğ‘¡ (ğ‘’) + ğ‘¤(cid:17) âˆ’(cid:98)ğ‘“ ğ‘¡ (ğ‘’) = 0
the expected increment to(cid:98)ğ‘“ ğ‘¡ (ğ‘’) is 0 if ğ‘’ â‰  ğ‘’ğ‘–.
 =

full key. Then, for any flow ğ‘’ of any key ğ‘˜ â‰º ğ‘˜ğ¹ , we have
(cid:104)(cid:98)ğ‘“ (ğ‘’)(cid:105)
ğ‘“ (ğ‘) = ğ‘“ (ğ‘’)
(cid:98)ğ‘“ (ğ‘)

ğ‘˜(ğ‘)=ğ‘’
ğ‘˜(ğ‘)=ğ‘’
= E
E
Case 2: Otherwise, the estimated size does not change. Therefore,
As a result, the basic CocoSketch achieves unbiasedness for the
Let(cid:98)ğ‘“ğ‘–(ğ‘’) be the estimated size of flow ğ‘’ in the ğ‘–ğ‘¡â„ array of the
â–¡
hardware-friendly CocoSketch.
Lemma 4. For any flow ğ‘’ of any key ğ‘˜ â‰º ğ‘˜ğ¹ , in the hardware-
friendly CocoSketch,
E
(cid:104)(cid:98)ğ‘“ğ‘–(ğ‘’)(cid:105)
= ğ‘“ (ğ‘’)
Proof. Note that in a bucket, the probability of occupying the
bucket is proportional to the size of each flow. Therefore, after the
insertion process,
P [ğµğ‘–[â„ğ‘–(ğ‘’)].ğ¾ = ğ‘’] =
ğ‘“ (ğ‘’)
ğµğ‘–[â„ğ‘–(ğ‘’)].ğ‘‰
Based on the probability, we can get the expectation of the estimated
size in each array.
(cid:104)(cid:98)ğ‘“ğ‘–(ğ‘’)(cid:105)
E
ğ‘“ (ğ‘’)
ğµğ‘–[â„ğ‘–(ğ‘’)].ğ‘‰
=
Â· ğµğ‘–[â„ğ‘–(ğ‘’)].ğ‘‰ = ğ‘“ (ğ‘’)
Then, we can get the variance for the ğ‘–ğ‘¡â„ array is that
ğ‘™
=
=
ğ‘—=1
ğ‘“ (ğ‘’) Â· ğ‘“ (ğ‘’)
ğ‘™
(cid:115)
(cid:35)
ğ‘“ (ğ‘’)
ğ‘“ (ğ‘’)
â©½ ğ›¿
(cid:34)
ğ‘…(ğ‘’) â©¾ ğœ– Â·
P
â–¡
Theorem 3. Let ğ‘™ = 3 Â· ğœ–âˆ’2 and ğ‘‘ = ğ‘‚(log ğ›¿âˆ’1). For any flow ğ‘’ of
arbitrary partial key ğ‘˜ğ‘ƒ â‰º ğ‘˜ğ¹ ,
P
(cid:35)
(cid:115)
ğ‘…ğ‘–(ğ‘’) â©¾ ğœ– Â·
Proof. Let ğ‘…ğ‘–(ğ‘’) be the relative error of flow ğ‘’ based on its
coSketch. According to the variance and Chebyshevâ€™s inequality,
we have
estimated size(cid:98)ğ‘“ğ‘–(ğ‘’) in the ğ‘–ğ‘¡â„ array of the hardware-friendly Co-
(cid:34)
(cid:104)(cid:12)(cid:12)(cid:12)(cid:98)ğ‘“ğ‘–(ğ‘’) âˆ’ ğ‘“ (ğ‘’)(cid:12)(cid:12)(cid:12) â©¾ ğœ– Â·(cid:112)ğ‘“ (ğ‘’) Â· ğ‘“ (ğ‘’)(cid:105)
Var(cid:104)(cid:98)ğ‘“ğ‘–(ğ‘’)(cid:105)
(cid:115)
(cid:35)
By setting ğ‘™ = 3 Â· ğœ–âˆ’2, we have
â©½
= ğœ–âˆ’2 Â· ğ‘™âˆ’1
ğœ–2 Â· ğ‘“ (ğ‘’) Â· ğ‘“ (ğ‘’)
ğ‘“ (ğ‘’)
ğ‘“ (ğ‘’)
= P
(cid:34)
ğœ–Â·(cid:112)ğ‘“ (ğ‘’)/ğ‘“ (ğ‘’), at least ğ‘‘/2 ğ‘…ğ‘–(ğ‘’) must be larger than ğœ–Â·(cid:112)ğ‘“ (ğ‘’)/ğ‘“ (ğ‘’).
Because the final estimated size is the median result, if the ğ‘…(ğ‘’) â©¾
Based on the Chernoffâ€™s inequality, setting ğ‘‘ = ğ‘‚(log ğ›¿âˆ’1) can make
such probability reduce to ğ›¿.
â–¡
Let ğ‘€ = ğ‘‘Â·ğ‘™. Then we analyze ğ‘€ needed for different ğ‘‘ to achieve
given ğœ– and ğ›¿. Based on the proof above, we have
ğ‘“ (ğ‘’)
ğ‘“ (ğ‘’)
â©½
1
3
ğ‘…ğ‘–(ğ‘’) â©¾ ğœ– Â·
P
(cid:19)ğ‘‚(ğ‘‘)
(cid:18)
ğ‘‘
ğœ–2 Â· ğ‘€
â–¡
ğ›¿ =
SIGCOMM â€™21, August 23â€“28, 2021, Virtual Event, USA
If two configuration ğ‘€1, ğ‘‘1 and ğ‘€2, ğ‘‘2 achieve the same error bound,
we have
ğ‘€2 â‰ˆ ğ‘‘2 Â· ğ›¿âˆ’ 1
ğ‘‘1 Â· ğ›¿âˆ’ 1
We can get that, ğ‘‘ â‰ˆ ln ğ›¿âˆ’1 can achieve the smallest ğ‘€ for given ğ›¿.
For other ğ‘‘, we need around ğ‘‘Â·(1/ğ›¿)1/ğ‘‘
times more memory, where
ğ‘’Â·ln(1/ğ›¿)
ğ‘’ is the Eulerâ€™s number.
Â· ğ‘€1
ğ‘‘2
ğ‘‘1
A.3 Recall Rate
In this section, we prove Theorem 4 shown in Â§5.3.
Theorem 4. For any flow ğ‘’ of full key ğ‘˜ğ¹ ,
1 + ğ‘™ Â· ğ‘“ (ğ‘’)
ğ‘“ (ğ‘’)
P [ğ‘(ğ‘’) = 1] â©¾ 1 âˆ’
(cid:18)
(cid:19)âˆ’ğ‘‘
Proof. In the ğ‘–ğ‘¡â„ array, let ğ‘ğ‘–(ğ‘’) be a 0-1 function. ğ‘ğ‘–(ğ‘’) = 1
if and only if ğ‘’ is recorded in the ğ‘–ğ‘¡â„ array of the CocoSketch.
According to the Jensenâ€™s inequality, we have
P [ğµğ‘–[â„ğ‘–(ğ‘’)].ğ‘‰ = ğ‘š]
P [ğ‘ğ‘–(ğ‘’) = 1] =

ğ‘“ (ğ‘’)
Because the hash functions are independent,
ğµğ‘–[â„ğ‘–(ğ‘’)].ğ‘‰
ğ‘™ Â· ğ‘“ (ğ‘’)
ğ‘“ (ğ‘’) + ğ‘™ Â· ğ‘“ (ğ‘’)
ğ‘š
ğ‘“ (ğ‘’)
â©¾
E [ğµğ‘–[â„ğ‘–(ğ‘’)].ğ‘‰] =
P [ğ‘(ğ‘’) = 1] = 1 âˆ’ ğ‘‘
(cid:18)
ğ‘–=1
(cid:18)
1 âˆ’
1 + ğ‘™ Â· ğ‘“ (ğ‘’)
ğ‘“ (ğ‘’)
â©¾ 1 âˆ’
= 1 âˆ’
ğ‘“ (ğ‘’) + ğ‘™ Â· ğ‘“ (ğ‘’)
ğ‘™ Â· ğ‘“ (ğ‘’)
(cid:19)âˆ’ğ‘‘
(1 âˆ’ P [ğ‘ğ‘–(ğ‘’) = 1])
(cid:19)ğ‘‘
Y. Zhang et al.
â–¡
B BASIC COCOSKETCH IMPLEMENTATION
CPU Implementation: We implement the basic CocoSketch (Â§4.1)
using C++. The hash functions are implemented using the 32-bit Bob
Hash [83] with different hash seeds. We implement and evaluate
them on a machine with one 4-core processor (8 threads, Intel(R)
Core(TM) i5-8259U CPU @ 2.30GHz) and 16 GB DRAM memory.
The processor has 64KB L1 cache, 256KB L2 cache for each core,
and 6MB L3 cache shared by all cores.
OVS Implementation: We implement CocoSketch on OVS v2.12.1
with DPDK 18.11.10. We use ring buffers as the shared memory to
connect the datapath in OVS and the measurement process of the
CocoSketch. When a packet enters the datapath, its packet header
will be written into ring buffers. The measurement process continu-
ously reads packet header information from ring buffers by polling.
Our testbed has two servers that are directly connected. One server
runs OVS, and another server generates high-speed TCP traffic
using pktgen-dpdk (version 3.7.2). Each server is equipped with a
Mellanox ConnectX-3 40G NIC, an Intel Core PI:EMAIL
CPU, and 16GB DRAM. To accelerate the process, we assign multi-
ple (e.g., 4) Rx queues for the DPDK receive port in OVS. Different
Rx queues are pinned to different cores and are polled by different
Poll Mode Driver threads.