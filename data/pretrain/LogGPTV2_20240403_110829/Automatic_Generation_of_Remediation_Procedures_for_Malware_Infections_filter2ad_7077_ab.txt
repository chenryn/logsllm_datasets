s t a r t
. . . ) ;
. . . ) ;
RegSetKeyValue ( r , valuename , REG_SZ , filename ,
. . . ) ;
. . . ) ;
i n f e c t u s e r 3 2 . d l l
. . .
/ /
g = CreateFile ( "c:\windows\user32.dll" , FILE_APPEND_DATA ,
WriteFile ( g , malicious_buf ,
. . .
/ / h i j a c k HTTP c o n n e c t i o n s
h = CreateFile ( "c:\windows\system32\drivers\etc\hosts" ,
ReadFile ( h , buf ,
WriteFile ( f , "67.42.10.3 www.google.com\n67.42.10.3 www.citibank.com" ,
. . .
/ / d e l e t e main e x e c u t a b l e
DeleteFile ( "c:\malware.exe" ) ;
t o www . g o o g l e . com and www . c i t i b a n k . com
. . . ) ;
. . . ) ;
. . . , OPEN_EXISTING ,
. . . ) ;
. . . , OPEN_EXISTING ,
. . . ) ;
Figure 1: Pseudo-code of a sample malicious program.
possible to observe the malware long enough to see all
possible variants of the payload ﬁle name.
3.2 Architecture Overview
The architecture we have developed for generating re-
mediation procedures from malware binaries is shown in
Figure 2. It has three primary components: (1) an execu-
tion monitor that infers the malware’s high-level behav-
iors from a low-level trace, (2) a component that gener-
alizes the high-level behaviors from multiple executions
of the malware, and (3) a component that produces exe-
cutable remediation procedures from generalized behav-
iors. The entire system works sequentially, with each
component using the information produced by the one
preceding it.
High-Level Behavior Extraction: The high-level be-
havior extraction component (numbered 1 in Figure 2)
analyzes the semantics of a program to produce a se-
quence of meaningful behaviors relevant to remediation.
Because malware authors usually obfuscate their bina-
ries, we rely on dynamic information to infer these be-
haviors; we execute binaries in a special environment (an
emulator) to extract a low-level execution trace, perform
analysis using manually constructed rules, and arrive at a
high-level trace [11]. Table 1 lists the high-level behav-
iors we consider. Each behavior modiﬁes the state of the
system in some way and is parameterized by a set of ar-
guments that determine which aspects of the system state
are affected. The behaviors currently listed correspond to
those that commonly occur in malware, that are manda-
tory to infect a system, and were constructed manually to
reﬂect the salient behavioral features of most malware.
However, our technique can be extended to operate over
a wider set of high-level behaviors.
The environment in which a program runs typically
affects its behavior, and malware often exhibits a certain
degree of nondeterminism. To account for these factors,
we collect several high-level behavior traces for each
sample. To do so, we vary the environment by chang-
ing factors that malware typically rely on, such as lo-
cale, service pack level, and so forth. Although not sup-
ported by our current implementation, path exploration
techniques [12] can be applied in this component to ac-
count for a more complete subset of the malware’s be-
havior, as in Bouncer [5]. The lack of path exploration
techniques is not a fundamental limitation of our system,
and can be easily plugged into our system.
Our high-level behavior extractor would infer that
the sample malware from Figure 1 demonstrates the
FileCreation, RegistryCreation, DropAndAutostart,
and FileInfection behaviors, with different argu-
ments
and
DropAndAutostart on each execution.
for FileCreation,
RegistryCreation,
Behavior Generalization: After producing a set of
high-level behavior traces for a malware sample, we at-
tempt to account for nondeterminism by creating a gen-
eral, abstract model of behavior that accounts for all of
the concrete traces we observed (numbered 2 in Fig-
ure 2). Note that generalization attempts to overapprox-
imate existing paths, thus encompassing future paths,
rather than explore as many new paths as possible. In ef-
fect, this patches some of the incompleteness of dynamic
4
Malware
1
Behavior
monitoring
2
Cluster gen-
eralization
C1
C2
C3
4
S
3
S
S
2
S
1
1
C
2
C
C
3
High-level
behavior
analysis
B1
B2
B3
B4
Behavior
clustering
3
Remediation
procedure
generation
Remediation
procedure
Figure 2: Architecture of the system for generating remediation procedures. In this ﬁgure, S denotes a system call
trace, B denotes a high-level behavior trace inferred from a system call trace, C denotes a cluster, and ¯C denotes a
generalized cluster.
analysis by extrapolating observed information to future,
unseen executions of the malware. This is accomplished
by recognizing when distinct behaviors from multiple
high-level traces, with possibly different arguments, are
actually instances of the same malicious activity. We re-
fer to this matching of behaviors as clustering. When a
cluster is identiﬁed, the arguments of its constituent be-
haviors are generalized to tolerate any differences that
may be present in the actual values. Thus, nondetermin-
ism is accounted for via overapproximation by ensuring
that this generalization extends to future, unseen execu-
tions.
In the malware from Figure 1, our technique would
cluster all instances of the same high-level behavior to-
gether. For example, all instances of DropAndAutostart
instances of
would be clustered together and all
FileInfection would be clustered together.
Be-
cause there is likely variation among the arguments of
DropAndAutostart, we construct a regular expression
to tolerate minor differences while ensuring that be-
nign ﬁles are not mistakenly identiﬁed. The ﬁnal re-
sult of the computation for this behavior would be a
DropAndAutoStart behavior with generic ﬁle argument
c:\windows\po[[:alpha:]]{3}.exe to generalize the
random ﬁlename at line 2, generic registry key/value pair
...\CurrentVersion\Run for the registry touched at line
11, and (qv|vq) for the registry value randomly created
at line 3.
Remediation Procedure Generation: The third com-
ponent of our architecture (numbered 3 in Figure 2) gen-
erates executable remediation procedures from the gen-
eralized behaviors produced in the previous step. The
resulting procedure examines the state of the system on
which it runs in search of symptoms of an infection, and
removes the symptoms whenever possible.
It attempts
to match each resource (ﬁle, process, or registry key) on
the system against the constraints associated with each
generalized high-level behavior. For our running exam-
ple, each ﬁle is matched against the regular expression
c:\windows\po[[:alpha:]]{3}.exe associated with the
ﬁrst argument of the DropAndAutoStart behavior, an-
other regular expression associated with the second ar-
gument, and a ﬁnal one describing the content of the ﬁle.
If such a ﬁle is found, then the registry values under the
key ...\CurrentVersion\Run are matched against the
regular expression (qv|vq). If such a value is found and
its data matches the current ﬁlename being considered,
then all of the resources (the ﬁle and registry key pair)
are removed. Currently, we only produce remediation
procedures that operate on system ﬁles. For technical
reasons explained in Section 4, we do not handle user-
speciﬁc ﬁles and resources. While this is a limitation
of our current approach, we hope to remove it in future
work.
4 Generating Remediation Procedures
In this section, we present
the details of our sys-
tem for generating remediation procedures. We begin
by formalizing the problem solved by our system and
continue component-by-component describing the algo-
rithms used to solve the problem.
4.1 Problem Description
When malware runs on a system, it may infect the system
by changing its persistent state in an undesirable way.
5
Behavior
FileCreation
RegistryCreation
DropAndAutostart
Arguments
File name and content
Key name and content
File name and content. Key name
and content
e
c
r
u
o
s
e
R
n
o
i
t
a
e
r
c
DropAndExecute
File and process name
Description
Creation of a new ﬁle
Creation of a new registry value
Creation of a new ﬁle and of a registry value con-
taining its name (to execute the ﬁle automatically at
every boot)
Creation and execution of a new executable
n FileInfection
File name and content. List of pre-
served regions
Infection of an existing ﬁle
e
c
r
u
o
s
e
R
o
i
t
c
e
f
n
i
RegistryInfection Key name and content
Replacement of an existing registry value
e
c
r
u
o
s
e
R
n
o
i
t
e
l
e
d
FileDeletion
RegistryDeletion
File name
Key name
Deletion of an existing ﬁle
Deletion of an existing registry value
Table 1: High-level behaviors considered for remediation.
For our purposes, the state S of a system is modeled
as an association from resource names N to data from
a domain D.
Individual elements of S are referred to
as resources. To simplify notation, we let S stand for
the set of possible system states. Because most malware
is written for Windows platforms, our targeted resource
namespace consists of Windows ﬁlenames, registry key
and value names, and process names. The data domain
is the set of all ﬁnite-length bit strings.
The infection behavior of a malware can be under-
stood as a transition relation between system states.
There are three ways in which the malware can mod-
ify the state of a system: (1) resources may be com-
pletely removed from the system, (2) new resources may
be added to the system, and (3) the data corresponding
to existing resources may be mutated. Because the infec-
tion behavior of a malware can be succinctly described
in terms of these three operations and the resources over
which they operate, we represent it using an infection re-
lation R ⊆ S × N × S × S that encodes this informa-
tion. Intuitively, the infection relation describes the way
in which a particular malware changes the state of a sys-
tem. Given an element (S, Nrem , Sadd , Smut) ∈ R, the
malware transforms state S into a new state by removing
the resources labeled by Nrem, adding the resources in
Sadd , and modifying the resources in Smut . Note that the
infection behavior is described as a relation rather than a
function mapping. This is because of the fact that mal-
ware may behave nondeterministically when it infects a
system—it may infect the same system state in different
ways on two distinct executions.
After a given piece of malware has infected a system,
the goal of remediation is to undo the effects of the in-
fection, returning the system to a clean state. More pre-
cisely, given a malware binary, we seek to construct an
infection relation for that malware that describes its be-
havior. We can then use the information in the infection
relation to enact changes on the system that remediate
the effects of the malware: restoring any ﬁles that were
removed (Nrem) or mutated (Smut ), and removing ﬁles
that were added (Sadd ). We package this functionality
as an executable remediation procedure, as described in
Section 3.2. In general, there are a number of approaches
that may realize the goal of constructing the infection re-
lation corresponding to a given malware. In this paper,
we focus on applying dynamic analysis to the malware
sample to extract the information necessary to construct
the infection relation.
In practice, it is not usually possible to reconstruct the
true infection relation from a malware binary. Rather, we
compute a relation that overapproximates the actual be-
havior for a ﬁnite set of execution paths exhibited by the
malware. For example, we overapproximate the resource
names involved in the DropAndAutoStart behavior
of Figure 1 by creating a regular expression that matches
all of the resource names on the set of execution traces
we observed. Furthermore, our approximate infection re-
lations do not contain information regarding the removal
or mutation of non-system ﬁles, as it is generally not pos-
sible to restore this state without additional information
not encoded in the malware. Of course, using an ap-
proximate infection relation for remediation introduces
the possibility of false negatives and false positives. A
false negative occurs when the remediation fails to prop-
erly reverse the changes left by the malware. Similarly, a
false positive occurs when remediation affects resources
that were not touched by the malware. Both types of er-
ror are possible given the way we construct approximate