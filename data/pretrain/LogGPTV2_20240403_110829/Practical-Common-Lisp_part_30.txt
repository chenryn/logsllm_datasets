数的REMOVE家族的回收性版本。
管如此，并非所有函数都是这样，其中包括几个更常用的回收性函数。例如NCONC，它是APPEND
数。一般来说，回收性函数和它们的非破坏性同伴带有相同的名字，除了一个起始的字母N。尽
的头节点。不需要分配新的点对单元，也没有产生垃圾。
点对单元。最终返回的点对单元曾经是旧列表的最后一个点对单元，而现在则成为逆序后的列表
任何CAR或CDR），但典型的实现可能会沿着列表依次改变每个点对单元的CDR，使其指向前一个
的点对单元。虽然故意没有说明NREVERSE的明确的副作用（它可以修改列表中任何点对单元的
现中，立即重用已有的点对单元会比分配新的点对单元并让老的变成垃圾更加高效。
表中的点对单元不被任何其他位置引用，它们现在可以被作为垃圾收集了。不过，在许多Lisp实
逆序的列表的每个元素分配一个新的点对单元。但假如写出了类似下面的代码：
坏性函数，与它的回收性版本NREVERSE进行比较。由于REVERSE不修改其参数，它必须为将要
用回收性函数之后不再需要原先列表的情况下，回收性函数才可以被安全地使用。
对单元作为原材料来重用，如有必要它将修改其CAR和CDR来构造想要的结果。这样，只有当调
诸如APPEND这种在返回列表中包含未经修改的点对单元的函数有所不同的是，
一种优化手段。特别地，它们在构造结果时会重用来自它们实参的特定点对单元。
和APPEND一样，NCONC返回其列表实参的连结体，但是它以下面的方式构造其结果：对于
NREVERSE就能让你这么做。函数名字中N的含义是non-consing，意思是它不需要分配任何新
为了观察回收性函数是怎样工作的，让我们将REVERSE，即返回一个序列的逆序版本的非破
128
但有一组回收性函数带有可靠的明确指定的副作用，这使得事情变得更复杂了。它们是
总之，你可以用与回收性函数的非破坏性同伴相同的方式来使用它们，但只有当你知道参数
NSUBSTITUTE及其变体可靠地沿着列表实参的列表结构向下遍历，将任何带有旧值的点对单
(defparameter *x*
像NREVERSE这样的回收性函数大多都带有对应的能产生相同结果但没有破坏性的同伴函
*x*→（123456）
通过将REVERSE的结果赋值回*list*，你就删除了对*list*原先的值的引I用。假设原先列
(setf*list*（reverse*list*))
第12章LISP名字的由来：列表处理
（1ist123））
www.TopSage.com
回收性函数将点
尽管如此，和
弘网
---
## Page 146
用法来构造一个由从0开始的前n个数字组成的列表：?
而NREVERSE只需穿过列表并重新赋值每个元素的CDR。由于列表完全是在函数之内创建，所以
表里，然后返回对其NREVERSE的结果。
在列表前端不断做点对分配操作的函数返回，通常是将元素PUSH进一个保存在局部变量中的列
前提的，而使用回收性函数则要求精确地知道哪些点对单元会在哪里被引用到。
以正常工作。或者换另一种说法，使用共享结构是基于不在乎究竟由哪些点对单元构成列表这一
单元永远不会被修改的假设下返回带有共享结构的列表，但是回收性函数却通过违反这一假设得
的境遇。
是，如果不小心将一个回收性函数用在了以后会用到的参数上，你肯定会遭遇搬起石头砸自己脚
12.4
返回值，这种做法不但完全可以接受，甚至还是一种好的编程风格。
规则的例外。忽视它们副作用的可靠性，而像任何其他回收性函数一样来使用它们，只用来产生
SUBSTITUTE计算得到的结果相同的值。?
元的CAR部分SETF到新的值上，否则保持列表原封不动。然后它返回最初的列表，其带有与
关于NCONC和NSUBSTITUTE，关键是需要记住，它们是不能依赖于回收性函数的副作用这--
这是一种构造列表的有效方式，因为每次PUSH都只创建一个点对单元并修改一个局部变量
③ 当然，还有其他方法来做到相同的事。例如，扩展的LOOP宏尤其方便做到这一点，并且.很可能会生成比
在实践中，回收性函数会有一些习惯用法。其中最常见的一种是构造一个列表，它是由一个
使事情变得更糟的是，共享结构和回收性函数会用于不同的目的。非破坏性列表函数在点对
② 例如，在一次对Common Lisp Open Code Collection（CLOCC，即一个由许多开发者所写的功能丰富的库集合）中
所有回收性函数的使用情况进行评测中，PUSH/NREVERSE习惯用法在所有的回收性函数使用中占据了将近一半。
(upto 10) → (0 12 3 4 5 6 7 8 9)
(defun upto (max)
尽管可以在函数实参在函数调用之后不会被使用的情况下使用回收性函数，但值得注意的
无论如何，重要的是能够识别PUSH/NREVERSE习惯用法，因为其相当普遍。
PUSH/NREVERSE版本更高效的代码。
回与其不带N的同伴相同的结果，但被指定在原位修改其字符串参数。
(defun upto (max)
(let ((result nil))
组合回收性函数和共享结构
(loop for i below max collect i))
(nreverse result)))
(dotimes (i max)
(push i result))
www.TopSage.com
12.4组合回收性函数和共享结构
一它们返
129
---
## Page 147
要确保可以保存排序函数的结果，因为原先的实参很可能已经一团糟了。例如：
又不破坏它时，你需要传给排序函数一个由COPY-LIST生成的列表副本。无论哪种情况，你都需
时，它们也是回收性函数。
表操作替换成相应的回收性操作，但只有当你确定其他任何位置不会引用实参列表时才可以这样做。
论是回收性的还是其他。一旦运行了代码，如果性能评估显示需要进行优化，你可以将非破坏性列
列表实参的内容而不应该修改它们。当然，按照这样的规则将会排除对任何破坏性函数的使用，无
使用是可能的，但需要小心地跟踪哪些函数返回共享的结构而哪些没有。
的点对单元而不会修改*1ist-3*中的任何点对单元。在这种情况下,*1ist-2*将不会受到影响。
*list-2*的第一个点对单元，所以上述操作也改变了*list-2*：
列表中断开了第四个保存了数字4的点对单元。由于*list-3*的第三个点对单元同时也是
对单元的列表*list-2*和*list-3*：
DELETE来代替REMOVE可能会破坏其他那些列表的结构。例如早先那两个共享了它们最后两个点
法，你在使用时也需小心一些。如果foo和在其他位置上引用的列表共享了一些结构，那么使用
回收性版本：
被回收的值的位置上。例如，你经常看到像下面这样的表达式，它使用了DELETE，即REMOVE的
总之，当操作列表时，最好是以函数式风格来编写自己的代码—一函数应当只依赖于它们的
PUSH/NREVERSE和SETF/DELETE的习惯用法很可能占据了80%的回收性函数使用。其他的
130
?
①这一习惯用法在CLOCC代码库里占据了30%的回收性使用。
最后需要注意的是，当第11章里提到的排序函数SORT、STABLE-SORT和MERGE应用于列表
如果使用REMOVE来代替DELETE，它将会构造一个含有值1、2和O的列表，在必要时创建新
*list-2*→（0）
不过，DELETE将很可能进行必要的删除，通过将第三个点对单元的CDR设置为NIL，从而从
还有一个最常见的回收性习惯用法，“是将回收性函数的返回值立即重新赋值到含有可能会
CL-USER> *list*
CL-USER> (sort *list* #' (defparameter *list* (list 4 3 2 1))
可以像下面这样将4从*1ist-3*中删除：
*list-3*
*list-2*→(0 4)
(  )  *-  ) ** )
这将foo的值设置到了它的旧值上，只是所有的NIL都被移除了。不过，即便是这种习惯用
（4）
(setf foo (delete nil foo))
实，并出于一致性的目的仅使用它们的返回值。
SORT和STABLE-SORT在向量上可被用作副作用性操作，但由于它们仍然返回排序了的向量，你应当忽略这一事
*LIST*
第12章LISP名字的由来：列表处理
→(120 4)
，?不过，这些函数并没有非破坏性的同伴，因此当需要对列表排序而
www.TopSage.com
； whoops!
;looks good
---
## Page 148
方式。
长的组合。尽管如此，
元素。换句话说，这些函数其实是用于树而不是列表的：
出给定列表的CAR的CAR，因此传递给它的列表必须含有另一个列表，并将该列表用作其第一个
用。因此我们可以得到：
因此无法在没有跟随n个cDR引用的情况下得到一个列表的第n个元素。?
n次的结果。（这样，(nthcdr O.．．）简单地返回最初的列表，而(nthcdr1．.．)等价于REsT。)
返回列表中第n个（从O开始）元素。类似地，NTHCDR接受一个索引和一个列表，并返回调用cDR
元素，但这样可能有点冗长。因此，Common Lisp提供了以从SECOND到TENTH的由其他序数命名
调用（用于深入列表）和一个FIRST调用（用于抽取元素）组合起来，以获得一个列表中的任意
12.5列表处理函数
28个复合CAR/CDR函数则是另一个不时会用到的函数家族。每个函数都是通过将由最多四个
②5
① NTH基本上等价于序列函数ELT，但只工作在列表上。另外容易使人困惑的是，NTH接受其索引作为第一个参数，
现在这些函数不像以前那样常用了，并且即便是最顽固的守旧Lisp黑客也倾向于避免使用过
但要注意，这其中许多函数仅当应用于含有其他列表的列表时才有意义。例如，CAAR抽取
前面已经介绍了获取列表中元素的基本函数：FIRST和REST。尽管可以通过将足够多的REST
有了前面这些背景知识，现在就可以开始学习Common Lisp为处理列表而提供的函数库了。
达式：
特别地，在发明解构参数列表之前，它们通常被用来解出传递给宏的表达式的不同部分。例如，你可以将下列表
NTH将返回NIL。
caadr
cadr
(caar
(caar (list 1
(cadadr list) = (car (cdr (car (cdr list))))
而BLT正相反。另一个区别是，如果你试图在一个大于或等于列表长度的索引上访问一个元素，BLT将报错，而
(cadr
(caar list) = (car (car list))
;; the condition 
像下面这样拆开：
(when (> x 10) (print x))
?
cadr
the body,
(list
(list (list 1 2)(list 3 4)))→ 3
list)
(list
= (car 
23))
，它们还是被用在很多古老的Lisp代码上，因此至少应当去理解它们的工作
x 10) (print x))） → (> X 10)
1i
2}
2）3)）
(cdr
(list 3 4)))
list))
www.TopSage.com
→
→ error
(34)
12.5列表处理函数
131
---
## Page 149
的应用会从每个列表中各接受一个元素。每次函数调用的结果都被收集到一个新列表中。例如：
实参的列表。除此之外，它和MAP的行为相同：函数被应用在列表实参的相继元素上，每次函数
类型实参。作为替代，它的第一个参数是想要应用的函数，而后续参数是其元素将为该函数提供
列表结构的点对单元上。
这6个函数之间的区别在于它们构造结果的方式，以及它们究竞会将函数应用到列表的元素还是
向量（也就是说，任何类型的序列），但Common Lisp另外还提供了6个特定用于列表的映射函数。
作为返回值的函数。前面章节里出现过几个高阶函数，例如MAP。尽管MAP可被同时用于列表和
12.6映射
位置。
MAPCAR是最接近MAP的函数。因为它总是返回一个列表，所以它并不要求MAP所要求的结果
如果你正在非函数式地使用列表，这些FIRST-TENTH和CAR、CADR等函数也可用作SETF的
132
函数式风格的另一个重要方面是对高阶函数的使用，即那些接受其他函数作为参数或将函数
(mapcar #(lambda (x) (* 2 x)) (list 1 2 3)) →(2 4 6)
NULL
LISTP
ATOM
CONSP
NRECONC
MARE-LIST
LIST#
TAILP
LDIFF
NBUTLAST
BUTLAST
LAST
第12章
数
LISP 名字的由来：列表处理
布尔假时文体上推荐使用
到第二个参数上。没有可靠的副作用
第二个参数上
关键字参数所指定的值
这个列表最后一个节点的CDR。
后n个单元
，用来测试一个对象是否为NIL的谓词。功能上等价于NOT但在测试空列表而非
用来测试一个对象是否为点对单元或NIL的谓词
用来测试一个对象是否为点对单元的谓词
REVAPPEND的回收性版本。像NRVERSE那样求逆第一个参数，再将其追加