2. #include 
3. #include 
4. #include 
5. #include “snarf.h”
6.
7. static int socket_fd = -1;
8.
9. /* Copy src buffer to dst removing cookies*/
10. int remove_cookies(char *dst, const void *src, 
11. int size);
12. /* Callback for the so_socket system call. */
13. int my_so_socket (int a, int b, int c, char *d,
14. int e) {
15.
16.
17.
18.
19.
20.
21. }
strata_policy_begin(SYS_so_socket);
/* Make the system call and record the */
/* file descriptor */
socket_fd = syscall(SYS_so_socket,a,b,c,d,e);
strata_policy_end(SYS_so_socket);
return socket_fd;
22. /* Callback for the write system call */
23. int my_write (int fd, void *buf, int size) {
24.
25.
char new_buf[1024];
int s, new_size;
26.
27.
28.
29.
30.  
strata_policy_begin(SYS_write);
/* Only look at writes to socket_fd 
/* and only rewrite HTTP headers. */
if (fd == socket_fd && 
(new_size = 
remove_cookies(new_buf,buf,size)))
31.
32.
33.
34.
35.
36. }
s = syscall(SYS_write,fd,new_buf,new_size);
else
s = syscall(SYS_write,fd,buf,size);
strata_policy_end(SYS_write);
return s;
37. void init_syscall() {
38.
(*TI.watch_syscall)(SYS_so_socket,my_so_socket);
39.
40. }
(*TI.watch_syscall)(SYS_write,my_write);
41. int main(int argc, char *argv[]) {
42.
43. }
snarf_main(argc, argv);
Listing 4:  Code to remove cookies.
While it is somewhat ironic that we wrote our sam-
ple security policies using C (a cause of many security
vulnerabilities in general) we did so to make the tech-
niques  and  policies  accessible  to  the  largest  audience.
The policies presented here could have been written in
any language. The only requirements are that bindings
of  Strata’s  security  API  must  be  implementable  in  the
new  target language and that a compiler  for the  target
language is available which emits object code. Provid-
ing a new language implementation of Strata’s security
API is easy since the API consists of four simple func-
tions.
Our  current  implementation  does,  however,  have  a
few limitations on the types of SVE systems that can be
built.  For  instance,  Strata  does  not  currently  handle
Proceedings of the 18th Annual Computer Security Applications Conference (ACSAC(cid:146)02) 
1063-9527/02 $17.00 ' 2002 IEEE 
multi-threaded code. We are currently extending Strata
so  that  SVE  designers  can  build  systems  that  handle
threaded code.  Nonetheless, we feel  that our approach
provides a useful and complementary approach to help-
ing provide software security.
Another important issue to consider is the overhead
of  using  SDT  for  SVE.  High  overheads  will  limit  the
applicability of using SDT in SVE systems. In a previ-
ous paper,  we  discussed  techniques for reducing over-
head  and  showed  that  SDT  was  competitive  with
previously developed techniques for preventing certain
classes  of  security  breaches  [14].  Currently,  the  slow-
down of running an application under Strata is negligi-
ble,  but  in  some  cases  can  be  as  much  as  1.32X.  For
many  types  of  applications,  30  percent  overhead  is
acceptable.  Examples  include  executing  an  e-mail
attachment  which  includes  a  self-extracting  archive,
opening  a  foreign  document  that  contains  malicious
macros which destroy valuable information, and many
setuid  programs  which  perform  simple  administrative
functions. For these situations, a slowdown of 20 to 30
percent would not be noticeable to the user.
For  some  applications  such  as  web  servers,  web
browsers,  and  databases,  an  overhead  of  30  percent
might not be acceptable. Indeed for these types of appli-
cations, any overhead is unlikely to be acceptable. For-
tunately,  previous  research  on  dynamic  optimization
has  shown  that  it  is  possible  to  achieve  substantial
speedups  in long  running  applications [1, 2, 11].  Thus
we  believe  that  by  combining  a  dynamic  security
checker  with  a  dynamic  optimizer,  CPU-intensive
applications  can  be  run  securely without  overhead.  To
this end, we are working to incorporate additional opti-
mizations within Strata’s framework. If successful, our
approach  to SVE  implementation  would  be  applicable
to an even wider range of applications.
6. Related Work
Many  researchers  have  proposed  and  implemented
system  call  interposition  layers.  Mike  Jones  proposed
interposition  agents  an  object-oriented,  high-level
framework for building interposition layers [14]. Inter-
position agents are portable as long as the host operat-
ing  system  provides  a  system  call  interception  and
redirection  interface.  Ghormley,  et.  al.,  proposed  an
interposition system based on a non-standard, reconfig-
urable, kernel-resident system call redirection API [12].
Fraser, et.al., have proposed a similar interposition sys-
tem based on kernel loadable modules [11]. 
Considerable research has been conducted on execu-
tion  monitoring  [18],  a  technique  similar  to  interposi-
tion  layers.  The  Janus  system  monitors  system  calls
executed by a program in order to determine whether or
not a security policy has been violated [13]. Janus uses
the operating system ptrace facility to register callbacks
to  policy enforcement  code. Not all operating  systems
have  such  a  facility,  precluding  Janus’s  use  on  those
platforms.  Janus  also  refrains  from  monitoring  fre-
quently executed system calls (e.g., write()) in order to
keep overhead low.  The SASI system, like Janus, also
performs execution monitoring [9]. Rather than relying
on  an  operating  system  facility,  or  restricting  itself  to
monitoring only system calls, SASI inserts monitoring
code  required  by  the  security  policy  directly  into  the
program  binary  before  execution.  Consequently  SASI
cannot  enforce  the  security  policy  on  self-modifying
code or dynamically generated code.
There are a variety of tools which dynamically pre-
vent  buffer  overflow  attacks  using  specialized  code
generation  and/or  binary  rewriting  techniques.  The
StackGuard  system  is  a  customized  C  compiler  that
generates  code  to  dynamically  detect  and  prevent  the
occurrence  of  most  stack  buffer  overflows  (i.e.,  a
“stack-smashing”  attack) [4]. The libverify  tool  uses a
combination  of  late  program  modification  and  tech-
niques  borrowed  from  StackGuard  to  prevent  buffer
overflows, but  without requiring  a  special  compiler or
access to source code [3]. While both of these tools are
very useful, they are restricted to one specific safe vir-
tual  execution  task,  one  programming  language  (C),
and  in  the  case  of  StackGuard,  require  a  special  com-
piler as well as special versions of standard libraries.
In  addition  to  the  dynamic  execution  management
techniques discussed in this paper, there are also a vari-
ety  of  static  techniques  for  improving  the  trustworthi-
ness of programs. As mentioned earlier, proof carrying
code systems [17] prevent untrusted binaries from ever
executing  if  their  trustworthiness  cannot  be  statically
proven.  When  source  code  is  available,  a  variety  of
static  analysis  techniques  can  be  used  to  locate  buffer
overflow  vulnerabilities  [10,  15],  API  misusages  [5],
and other programming errors that may result in secu-
rity vulnerabilities [8, 22]. These techniques, and many
other static source code analyses, are complementary to
the dynamic techniques discussed in this paper.
7. Summary
In this paper we have shown that powerful safe vir-
tual execution systems can be easily constructed using
SDT  and  the  Strata  framework.  Some  SVE  applica-
tions, such as stack-smashing prevention can be imple-
mented in relatively few lines of code and are portable
across  any  of  Strata’s  supported  architectures.  Other
SVE  applications,  such  as  system  call  interposition,
require on the order of twenty  lines  of code per target
architecture. Implementing either of these SVE systems
Proceedings of the 18th Annual Computer Security Applications Conference (ACSAC(cid:146)02) 
1063-9527/02 $17.00 ' 2002 IEEE 
from scratch would require significantly greater imple-
mentation  efforts,  thus  making  Strata  a  particularly
attractive starting point for SVE developers.
We have also shown several applications of our sys-
tem call interposition API. These applications perform
useful  tasks,  such  as  preventing  the  execution  of  root
shells,  limiting  the  effectiveness  of  network  denial  of
service tasks, and helping users maintain the privacy of
personal information.  Moreover each of these applica-
tions were relatively simple to implement using Strata.
Given Strata’s portability, extensibility, and the dem-
onstrated  ease  with  which  it  can  be  used  to  develop
powerful SVE systems, we are confident that SDT and
Strata  will  find  use  in  the  development  of  novel  SVE
systems.
8. Acknowledgements
This work was supported in part by an Intel Founda-
tion  Graduate  Fellowship  and  by  NSF  grant  EIA-
0072043.  We would like to thank Siva Velusamy for
his  work  on  Strata/x86  and  Naveen  Kumar and Bruce
Childers  for  their  work  on  Strata/MIPS.    Lastly  we
would like to thank Shannon Hunt, whose careful read-
ing of this paper greatly improved its quality.
9. References
[1]
BALA, V., DUESTERWALD, E., AND BANERJIA, S. Dynamo: A
transparent  dynamic  optimization  system.  In  SIGPLAN  ’00  Confer-
ence on Programming Language Design and Implementation (2000),
pp. 1–12.
[2]
CHERNOFF,  A.,  HERDEG,  M.,  HOOKWAY,  R.,  REEVE,  C.,
RUBIN, N., TYE, T., YADAVALLI, S. B., AND YATES, J. FX!32: A pro-
file-directed  binary  translator.  IEEE  Micro  18,  2  (Mar.slash  Apr.
1998), 56–64. Presented at Hot Chips IX, Stanford University, Stan-
ford, California, August 24–26, 1997.
[3]
CMELIK,  B.,  AND  KEPPEL,  D.  Shade:  A  fast  instruction-set
simulator  for  execution  profiling.  In  Proceedings  of  the  1994  ACM
SIGMETRICS Conference on the Measurement and Modeling of Com-
puter Systems (May 1994), pp. 128–137.
[4]
COWAN,  C.,  PU,  C.,  MAIER,  D.,  HINTON,  H.,  BAKKE,  P.,
BEATTIE,  S.,  GRIER,  A.,  WAGLE,  P.,  ,  AND  ZHANG,  Q.  Stackguard:
Automatic  adaptive  detection  and  prevention  of  buffer-overflow
attacks.  In  Proceedings  of  the  1998  USENIX  Security  Symposium
(1998).
[5]
DELINE, R., AND FÄHNDRICH, M. Enforcing High-Level pro-
tocols in Low-Level software. In Proceedings of the ACM SIGPLAN
’01 Conference on Programming Language Design and Implementa-
tion (PLDI-01) (N.Y., June  20–22 2001), C. Norris and J. J. B. Fen-
wick, Eds., vol. 36.5 of ACM SIGPLAN Notices, ACMPress, pp. 59–
69.
[7]
EBCIOGLU, K., AND ALTMAN, E. DAISY: Dynamic compila-
tion for 100% architectural compatibility. In 24th Annual International
Symposium on Computer Architecture (1997), pp. 26–37.
[8]
ENGLER, D., CHELF, B., CHOU, A., AND HALLEM, S. Checking
system  rules  using  system-specific,  programmer-written  compiler
extensions. In  Symposium  on  Operating Systems Design and  Imple-
mentation (OSDI 2000) (San Diego, CA, 23–25 Oct. 2000).
[9]
ERLINGSSON, Ú., AND SCHNEIDER, F. B. SASI enforcement of
security policies: A retrospective. In New Security Paradigms Work-
shop  (Caledon  Hills,  Ontario,  Canada,  Sept.  1999),  ACM  SIGSAC,
ACM Press, pp. 87–95.
[10]
EVANS,  D.,  AND LAROCHELLE,  D. Improving security  using
extensible lightweight static analysis. IEEE Software 19, 1 (Jan./ Feb.
2002), 42–51.
[11]
FRASER,  T.,  BADGER,  L.,  AND  FELDMAN,  M.  Hardening
COTS software with generic software wrappers. In IEEE Symposium
on Security and Privacy (1999), pp. 2–16.
[12]
GHORMLEY,  D. P.,  PETROU,  D.,  RODRIGUES,  S. H.,  AND
ANDERSON, T. E. SLIC: An extensibility system for commodity oper-
ating systems. pp. 39–52.
[13]
GOLDBERG, I., WAGNER, D., THOMAS, R., AND BREWER, E. A
secure  environment  for untrusted  helper  applications:  Confining  the
wily hacker. In Proceedings of the 1996 USENIX Security Symposium
(1996).
[14]
JONES, M. B. Interposition agents: Transparently interposing
user code at the system interface. In Symposium on Operating Systems
Principles (1993), pp. 80–93.
[15]
LAROCHELLE, D., AND EVANS, D. Statically detecting likely
buffer overflow vulnerabilities. In Proceedings of the 2001 USENIX
Security Symposium (2001).
LINDHOLM,  T.,  AND  YELLIN,  F.  The  Java  Virtual  Machine
[16]
Specification, 1 ed. Addison-Wesley, Reading/Massachusetts, 1996.
[17]
NECULA, G. C. Proof-carrying code. In Conference Record of
POPL ’97: The 24th ACM SIGPLAN-SIGACT Symposium on Princi-
ples of Programming Languages (Paris, France, jan 1997), pp. 106–
119.
SCHNEIDER, F. B. Enforceable security policies. Information
[18]
and System Security 3, 1 (2000), 30–50.
SCOTT,  K.,  AND  DAVIDSON,  J.  Low-overhead  software
[19]
dynamic translation. Tech. Rep. CS-2001-18, 2001.
[20]
SCOTT,  K.,  AND  DAVIDSON,  J.  Strata:  A  software  dynamic
translation  infrastructure.  In  IEEE  Workshop  on  Binary  Translation
(2001).
[21]
UNG,  D.,  AND  CIFUENTES,  C.  Machine-adaptable  dynamic
binary translation. In Proceedings of the ACM Workshop on Dynamic
Optimization Dynamo ’00 (2000).
[22]
VIEGA, J., BLOCH, J. T., KOHNO, T., AND MCGRAW, G. ITS4:
A  static  vulnerability  scanner  for  C  and  C++  code.  In  16th  Annual
Computer Security Applications Conference (Dec. 2000), ACM.
[23] WAHBE,  R.,  LUCCO,  S.,  ANDERSON,  T. E.,  AND  GRAHAM,
S. L. Efficient software-based fault isolation. ACM SIGOPS Operat-
ing Systems Review 27, 5 (December 1993), 203–216.
DITZEL,  D. R.  Transmeta’s  Crusoe:  Cool  chips  for  mobile
[6]
computing. In Hot Chips 12: Stanford University, Stanford, California,
August 13–15, 2000 (1109 Spring Street, Suite 300, Silver Spring, MD
20910, USA, 2000), IEEE, Ed., IEEE Computer Society Press.
[24] WITCHEL, E., AND ROSENBLUM, M. Embra: Fast and flexible
machine simulation. In Proceedings of the ACM SIGMETRICS Inter-
national Conference on Measurement and Modeling of Computer Sys-
tems (May 1996), pp. 68–79.
Proceedings of the 18th Annual Computer Security Applications Conference (ACSAC(cid:146)02) 
1063-9527/02 $17.00 ' 2002 IEEE