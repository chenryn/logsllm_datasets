(540) 1261980
(874) 1632885
(286)254-2860
(292) 108518
(129) 441379
(458) 2731642
(686) 2998268
(198)3072440
(END)
另一方面，vim支持基本的正则表达式，所以我们用于搜索的表达式看起来像这样：
/([09]{3)[09]\{3[09]{4}
我们看到表达式几乎一样；然而，在扩展表达式中，许多被认为是元字符的字符在基本的表
达式中被看作是文本字符。只有用反斜杠把它们转义之后，它们才被看作是元字符。
依赖于系统中vim的特殊配置，匹配项将会被高亮。如若不是，试试这个命令模式：
:hlsearch
来激活搜索高亮功能。
注意：依赖于你的发行版，vim有可能支持或不支持文本搜索高亮功能。尤其是Ubuntu自
带了一款非常简化的vim版本。在这样的系统中，你可能要使用你的软件包管理器来安装一个
功能更完备的vim版本。
269
---
## Page 271
20.14总结归纳
在这章中，我们已经看到几个使用正则表达式例子。如果我们使用正则表达式来搜索那些使用
正则表达式的应用程序，我们可以找到更多的使用实例。通过查找手册页，我们就能找到：
[ne@linuxbox -]$ cd /usr/share/man/nan1
z3.* uotsoadxo xenox|xo8ox, t3- dox?z $[tuem xoqxnu[gou]
这个zgrep程序是grep的前端，允许grep来读取压缩文件。在我们的例子中，我们在手册
“regularexpression”的文件列表。正如我们所看到的，正则表达式会出现在大量程序中。
基本正则表达式中有一个特性，我们没有涵盖。叫做反引用，这个特性在下一章中会被讨论
到。
20.15拓展阅读
有许多在线学习正则表达式的资源，包括各种各样的教材和速记表。
另外，关于下面的背景话题，Wikipedia有不错的文章。
· POSIX: http://en.wikipedia.org/wilki/Posix
•ASCII: http://en.wilkipedia.org/wiki/ Ascii
270
---
## Page 272
21”文本处理
所有类Unix的操作系统都严重依赖于几种数据存储类型的文本文件。所以，有许多用于处理
文本的工具就说的通了。在这一章中，我们将看一些被用来“切割”文本的程序。在下一章中
我们将查看更多的文本处理程序，但主要集中于文本格式化输出程序和其它一些人们需要的工
具。
这一章会重新拜访一些老朋友，并且会给我们介绍一些新朋友：
·cat一连接文件并且打印到标准输出
·sort一给文本行排序
·uniq一报告或者省略重复行
·cut一从每行中删除文本区域
·Paste一合并文件文本行
·join一基于某个共享字段来联合两个文件的文本行
·comm一逐行比较两个有序的文件
·diff一逐行比较文件
·patch一给原始文件打补丁
·tr一翻译或删除字符
·sed一用于筛选和转换文本的流编辑器
·aspell一交互式拼写检查器
271
---
## Page 273
21.1文本应用程序
到目前为止，我们已经知道了一对文本编辑器（nano和vim），看过一堆配置文件，并且目睹
了许多命令的输出都是文本格式。但是文本还被用来做什么？它可以做很多事情。
21.1.1文档
许多人使用纯文本格式来编写文档。虽然很容易看到一个小的文本文件对于保存简单的笔记会
很有帮助，但是也有可能用文本格式来编写大的文档。一个流行的方法是先用文本格式来编写
一个大的文档，然后使用一种标记语言来描远已完成文档的格式。许多科学论文就是用这种方
法编写的，因为基于Unix的文本处理系统位于支持技术学科作家所需要的高级排版布局的一
流系统之列。
21.1.2网页
世界上最流行的电子文档类型可能就是网页了。网页是文本文档，它们使用HTML（超文本标
记语言）或者是XML（可扩展的标记语言）作为标记语言来描述文档的可视格式。
21.1.3电子邮件
从本质上来说，email是一个基于文本的媒介。为了传输，甚至非文本的附件也被转换成文本
表示形式。我们能看到这些，通过下载一个email信息，然后用less来浏览它。我们将会看到
这条信息开始于一个标题，其描述了信息的来源以及在传输过程中它接受到的处理，然后是信
息的正文内容。
21.1.4打印输出
在类Unix的系统中，输出会以纯文本格式发送到打印机，或者如果页面包含图形，其会被转
换成一种文本格式的页面描述语言，以PostScript著称，然后再被发送给一款能产生图形点阵
的程序，最后被打印出来。
21.1.5程序源码
在类Unix系统中会发现许多命令行程序被用来支持系统管理和软件开发，并且文本处理程序
也不例外。许多文本处理程序被设计用来解决软件开发问题。文本处理对于软件开发者而言至
关重要是因为所有的软件都起始于文本格式。源代码，程序员实际编写的一部分程序，总是文
本格式。
272
---
## Page 274
21.2回顾一些老朋友
回到第7章（重定向），我们已经知道一些命令除了接受命令行参数之外，还能够接受标准输
入。那时候我们只是简单地介绍了它们，但是现在我们将仔细地看一下它们是怎样被用来执行
文本处理的。
21.2.1cat
这个cat程序具有许多有趣的选项。其中许多选项用来帮助更好的可视化文本内容。一个例子
是-A选项，其用来在文本中显示非打印字符。有些时候我们想知道是否控制字符嵌入到了我们
的可见文本中。最常用的控制字符是tab字符（而不是空格）和回车字符，在MS-DOS风格
的文本文件中回车符经常作为结束符出现。另一种常见情况是文件中包含末尾带有空格的文本
行
让我们创建一个测试文件。用cat程序作为一个简单的文字处理器。为此，我们将键入cat
命令（随后指定了用于重定向输出的文件），然后输入我们的文本，最后按下Enter键来结束
这一行，然后按下组合键Ctrl-d，来指示cat程序，我们已经到达文件末尾了。在这个例子中，
我们文本行的开头和末尾分别键入了一个tab字符以及一些空格。
[ne@linuxbox -]$ cat >foo.txt
The quick brovn fox junped over the lazy dog
[nedlinuxbox -]$
下一步，我们将使用带有-A选项的cat命令来显示这个文本：
[ne@linuxbox -]$ cat -A foo.txt
3op zet oga xono podum xog uszq xornb ouI
[nedlinuxbox -]$
在输出结果中我们看到，这个tab字符在我们的文本中由I字符来表示。这是一种常见的
表示方法，意思是“Control-I”，结果证明，它和tab字符是一样的。我们也看到一个$字符出
现在文本行真正的结尾处，表明我们的文本包含末尾的空格。
273
---
## Page 275
MS-DOS 文本 Vs.Unix文本
可能你想用cat程序在文本中查看非打印字符的一个原因是发现隐藏的回车符。
那么隐藏的回车符来自于哪里呢？它们来自于DOS和Windows！Unix和DOS在
文本文件中定义每行结束的方式不相同。Unix通过一个换行符（ASCII10）来结束
一行，然而MS-DOS和它的衍生品使用回车（ASCII13）和换行字符序列来终止每
个文本行。
有几种方法能够把文件从DOS格式转变为Unix格式。在许多Linux系统中，
有两个程序叫做dos2unix和unix2dos，它们能在两种格式之间转变文本文件。然
而，如果你的系统中没有安装dos2unix程序，也不要担心。文件从DOS格式转变
为Unix格式的过程非常简单：它只简单地涉及到删除违规的回车符。通过随后本
章中讨论的一些程序，这个工作很容易完成。
cat程序也包含用来修改文本的选项。最著名的两个选项是-n，其给文本行添加行号和-s
禁止输出多个空白行。我们这样来说明：
[neglinuxbox -]$ cat > foo.txt
The quick brown fox
junped over the lazy dog.
1  The quick broun fox
2
3jumped over the lazy dog
[nedlinuxbox -]$
在这个例子里，我们创建了一个测试文件foo.txt的新版本，其包含两行文本，由两个空白
行分开。经由带有-ns选项的cat程序处理之后，多余的空白行被删除，并且对保留的文本行进
行编号。然而这并不是多个进程在操作这个文本，只有一个进程。
21.2.2 sort
这个sort程序对标准输入的内容，或命令行中指定的一个或多个文件进行排序，然后把排序结
果发送到标准输出。使用与cat命令相同的技巧，我们能够演示如何用sort程序来处理标准输
入：
274
---
## Page 276
[ne@linuxbox -]$ sort > foo.txt
C
[neglinuxbox -]$ cat foo.txt
a
输入命令之后，我们键入字母“e”.“b”，和“a”，然后再按下Ctrl-d组合键来表示文件的
结尾。随后我们查看生成的文件，看到文本行有序地显示。
因为sort程序能接受命令行中的多个文件作为参数，所以有可能把多个文件合并成一个有
序的文件。例如，如果我们有三个文本文件，想要把它们合并为一个有序的文件，我们可以这
样做：
sort file1.txt file2.txt file3.txt > final_sorted_list.txt
sort程序有几个有趣的选项。这里只是一部分列表：
选项
长选项
描述
-b
ignore-leading-blanks
默认情况下，对整行进行排序，从每行的第一个
字符开始。这个选项导致sort程序忽略每行开
头的空格，从第一个非空白字符开始排序。
J-
ignore-case
让排序不区分大小写。
-1I
numeric-sort
基于字符申的数值来排序。使用此选项允许根
据数字值执行排序，而不是字母值。
-I
reverse
按相反顺序排序。结果按照降序排列，而不是
升序。
-key=field1 [,field2]
对从field1到field2之间的字符排序。而不是整
个文本行。看下面的讨论。
-m
merge
把每个参数看作是一个预先排好序的文件。把
多个文件合并成一个排好序的文件，而没有执
行额外的排序。
275
---
## Page 277
-0
-output=file
把排好序的输出结果发送到文件，而不是标准
输出。
-t
field-separator=char
定义域分隔字符。默认情况下，域由空格或制
表符分隔。
表21-1：常见的sort程序选项
虽然以上大多数选项的含义是不言自喻的，但是有些也不是。首先，让我们看一下-n选项，
被用做数值排序。通过这个选项，有可能基于数值进行排序。我们通过对du命令的输出结果
排序来说明这个选项，du命令可以确定最大的磁盘空间用户。通常，这个du命令列出的输出
结果按照路径名来排序：
[ne@linuxbox -]$ du =s /usr/share/* I head
252
/usr/share/ac1ocal
96
xoddns-rdse/ozeqs/xsm/
8
/usr/share/adduser
196
/usr/share/alacarte
344
/usr/share/alsa
8
/usr/share/alsa-base
12488
/usr/share/anthy
8
/usr/share/apnd
21440
/usr/share/app-instal1
48
/usr/share/application-registzy
在这个例子里面，我们把结果管道到head命令，把输出结果限制为前10行。我们能够产
生一个按数值排序的列表，来显示10个最大的空间消费者：
[ne@linuxbox -]$ du -s /usr/share/* | sort -nr 1 head
509940
/usr/share/locale-langpack
242660
/usr/share/doc
197560
/usr/share/fonts
179144
/usr/share/gnone
146764
/usr/share/nyspel1
144304
/usr/share/ginp
135880
/usr/share/dict
276
---
## Page 278
76508
/usr/share/icons
68072
/usr/share/apps
62844
/usr/share/foonatic
通过使用此-nr选项，我们产生了一个反向的数值排序，最大数值排列在第一位。这种排序
起作用是因为数值出现在每行的开头。但是如果我们想要基于文件行中的某个数值排序，又会
怎样呢？例如，命令1s-1的输出结果：
[ne@linuxbox -]$ 1s -1 /usr/bin 1 head
total 152948
rvxr-xr-x 1 root
root
348242008040402:42[
rWxr-xr-x 1 rootroot
1015562007-11-2706:08 a2p
此刻，忽略ls程序能按照文件大小对输出结果进行排序，我们也能够使用sort程序来完成
此任务：
peou 1 g - xu- qzos | utq/xsn/ [- sT $[- xoqxnuteou]
rvxr-xr-x 1 rootroot82342162008-04-0717:42 inkscape
rvxr-xr-x 1 rootroot8222692 2008-04-07 17:42 inkviev
sort程序的许多用法都涉及到处理表格数据，例如上面ls命令的输出结果。如果我们把数
据库这个术语应用到上面的表格中，我们会说每行是一条记录，并且每条记录由多个字段组成
例如文件属性，链接数，文件名，文件大小等等。sort程序能够处理独立的字段。在数据库术
语中，我们能够指定一个或者多个关键字段，来作为排序的关键值。在上面的例子中，我们指
定n和r选项来执行相反的数值排序，并且指定-k5.让sort程序使用第五字段作为排序的关