### 睡眠与唤醒
从**生产者-消费者问题**中发现消费者与生产者之间需要一系列的睡眠-唤醒操作
### 信号量
信号量（Semaphore）是一个整型变量，可以对其进行原子操作，并且可以用来实现同步。
- down：如果信号量大于 0 ，执行 -1 操作；如果信号量等于 0，进程睡眠，等待信号量大于 0
- up ：对信号量执行 +1 操作，唤醒睡眠的进程让其完成 down 操作
#### 互斥量
信号量的一个简化版本，值只能取0或者1
- 快速用户区互斥量futex：混合使用用户态自旋锁以及内核等待队列，类似[锁升级](/编程语言/JAVA/JVM/自动内存管理/内存结构.md#对象内存布局)
- pthread中的互斥量 **条件变量**
### 管程
一个管程由过程、变量、数据结构等组合成的一个集合，是一种编程语言概念
```pascal
monitor ProducerConsumer
    integer i;
    condition c;
    procedure insert();
    begin
        // ...
    end;
    procedure remove();
    begin
        // ...
    end;
end monitor;
```
管程的原语确定：在一个时刻只能有一个进程使用管程，管程被JAVA中的[synchronized](/编程语言/JAVA/JAVA并发编程/基础概念.md#synchronized)所实现了
进程可以在任何时候通过管程间接获取数据，但是不能直接获取数据。当多个进程同时试图进入管程内部时，只允许一个进程进入，其他进程则在入口等待队列中等待
### 消息传递
```c
send(目的,&msg);
receive(源,&msg);
```
用消息传递解决生产者-消费者问题 **消息传递接口**
这种接口是建立在计算机网络、互斥量、同步等上的一个高级接口
### 屏障
当一个进程到达屏障时，就会被阻拦，直到所有进程都到达屏障为止，[CyclicBarrier](/编程语言/JAVA/JAVA并发编程/并发工具类.md#CyclicBarrier（栅栏）)
![屏障](/assets/202242423455.png)
### 避免锁：读-复制-更新（RCU）
最快所的就是没有锁
要么读取旧版本，要么读取新版本
## 调度
**调度程序使用调度算法完成调度**
进程的行为分为IO活动与CPU计算，也就是IO密集型和计算密集型
![进程行为](/assets/202242521445.png)
何时进行调度：
- 运行一个新进程后
- 一个进程退出后
- 一个进程阻塞后
- IO中断
### 调度算法
调度算法分为两种：
- **非抢占式**：直到一个进程阻塞或者主动释放CPU
- **抢占式**：运行一段时间，后调度程序进行调度挑选下一个运行的进程
在对响应时间有要求的情况下，抢占式是很有必要，这能保证计算资源不会一直被某个进程占着
#### 目标
- 所有系统中
  - 公平：给每个进程公平的CPU份额
  - 策略强制执行：保证规定的策略被执行
  - 平衡：保持系统的所有部分都忙碌
- 批处理系统中
  - 吞吐量：每小时最大作业数
  - 周转时间：从提交到终止间的最小时间
  - CPU利用率：保持CPU始终忙碌
- 交互式系统中
  - 响应时间：快速响应请求
  - 均衡性：满足用户的期望
- 实时系统中
  - 满足截止时间：避免丢失数据
  - 可预测性：在多媒体系统中避免品质降低
#### 批处理系统
在该系统中，调度算法目标是保证吞吐量和周转时间
- 先来先服务 first-come first-serverd（FCFS）
![FCFS](/assets/2022710143658.webp)
有个问题就是对段任务不够公平，时间片会大量被长任务进程所占用
- 短作业优先 shortest job first（SJF）
![SJF](/assets/2022710143831.webp)
可能导致长任务一直得到不到执行，产生饥饿
- 最短剩余时间优先 shortest remaining time next（SRTN）
和 SJF 差不多，但是放回队列的时候按照作业剩余时间排序，优先调度剩余完成时间最短的任务
![SRTN](/assets/2022710143936.webp)
#### 交互式系统
在该系统中调度算法的目标是快速地进行响应
- 时间片轮转
每次调度时，把 CPU 时间分配给队首进程，该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 时间分配给队首的进程，该算法效率与时间片大小有关，时间片过于小，会造成进程切换频繁，过大实时性无法得到保证
- 优先级调度
为每个进程分配一个优先级，按优先级进行调度
为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级
- 多级反馈队列
它设置了多个队列，每个队列时间片大小都不同，例如 1,2,4,8,..。进程在第一个队列没执行完，就会被移到下一个队列，在这种情况下，就能有效避免一个进程需要执行连续多个时间片而造成的切换频繁问题
![202031164556](/assets/202031164556.png)
- 最短进程优先：利用历史的进程调度数据判断进程可能的执行时间，从而让预测最短的进程优先执行
- 公平分享保证调度：若是多用户系统，则保证每个用户CPU计算能力的1/n
- 彩票调度：每次需要调度时，随机挑选进程进行调度，但是每个进程被选中的概率是根据优先级计算出来的，优先级越高，越有可能被挑中
#### 实时系统
- **硬实时**：必须满足一定的截止时间
- **软实时**：可以容忍一定的超时
静态的调度算法在系统运行之前就已确定好如何调度，结果肯定是可预测的
动态的调度算法则运行时完成
### 策略和机制
使用[策略模式](/软件工程/设计模式/行为模式.md#策略模式)分离调度机制与调度策略
### 线程调度
- 用户级调度：操作系统调度选择进程后，内部线程如何调度则由进程决定
- 内核级调度：由内核直接调度线程，这种方式问题在于线程切换成本比在用户级高
## 经典进程同步问题
### 哲学家就餐问题
五个哲学家围着一张圆桌，每个哲学家面前放着食物。哲学家的生活有两种交替活动：吃饭以及思考。当一个哲学家吃饭时，需要先拿起自己左右两边的两根筷子，并且一次只能拿起一根筷子
![20203117217](/assets/20203117217.jpg)
一种解法是哲学家发现与其他人冲突时，放弃操作，等待随机的一段时间，这种方式很有效，在[以太网](/计算机网络/链路层.md#以太网)中有二进制指数回退，在[raft协议](/软件工程/架构/系统设计/分布式/分布式共识算法.md#Raft)中有随机的竞选超时时间
### 读者-写者问题
允许多个进程同时对数据进行读操作，但是不允许读和写以及写和写操作同时发生 这一般需要两把锁来完成，也就是通过[读写锁](/编程语言/JAVA/JAVA并发编程/并发工具类.md#ReentrantReadWriteLock)
## 进程通信
- 进程同步：控制多个进程按一定顺序执行；
- 进程通信：进程间传输信息
为了能够达到进程同步的目的，需要让进程进行通信
### 管道
- 只支持半双工
- 只支持父子进程或者兄弟进程
![202031171046](/assets/202031171046.png)
### FIFO(命名管道)
![202031183319](/assets/202031183319.png)
有名管道以磁盘文件的方式存在，可以实现本机任意两个进程通信
### 消息队列
- 消息队列可以独立于读写进程存在，从而避免了 FIFO 中同步管道的打开和关闭时可能产生的困难
- 避免了 FIFO 的同步阻塞问题，不需要进程自己提供同步方法
- 读进程可以根据消息类型有选择地接收消息，而不像 FIFO 那样只能默认地接收
### 信号量
用于为多个进程提供共享对象的访问
### 共享存储
多个进程可以使用一个给定的存储区进行通信
可以使用文件或者内存
### 套接字
用于不同机器之间的进程通信