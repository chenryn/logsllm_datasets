title:Worry-free encryption: functional encryption with public keys
author:Amit Sahai and
Hakan Seyalioglu
Worry-Free Encryption:
Functional Encryption with Public Keys
∗
Amit Sahai
Department of Computer Science
University of California - Los Angeles
PI:EMAIL
†
Hakan A. Seyalioglu
Department of Mathematics
University of California - Los Angeles
PI:EMAIL
ABSTRACT
In this work, we put forward the notion of Worry-Free En-
cryption. This allows Alice to encrypt conﬁdential informa-
tion under Bob’s public key and send it to him, without
having to worry about whether Bob has the authority to
actually access this information. This is done by encrypting
the message under a hidden access policy that only allows
Bob to decrypt if his credentials satisfy the policy. Our no-
tion can be seen as a functional encryption scheme but in a
public-key setting. As such, we are able to insist that even
if the credential authority is corrupted, it should not be able
to compromise the security of any honest user.
We put forward the notion of Worry-Free Encryption and
show how to achieve it for any polynomial-time computable
policy, under only the assumption that IND-CPA public-
key encryption schemes exist. Furthermore, we construct
CCA-secure Worry-Free Encryption, eﬃciently in the ran-
dom oracle model, and generally (but ineﬃciently) using
simulation-sound non-interactive zero-knowledge proofs.
Categories and Subject Descriptors
E.3 [Data Encryption]: Public Key Cryptosystems
General Terms
Security, Algorithms
Keywords
Functional Encryption, Public Key Cryptography
∗Research supported in part from NSF grants 0830803,
0627781, 0716389, 0456717, and 0205594, an equipment
grant from Intel, and an Okawa Foundation Research Grant.
†Research supported in part by a NSF Graduate Research
Fellowship.
Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proﬁt or commercial advantage and that copies
bear this notice and the full citation on the ﬁrst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciﬁc
permission and/or a fee.
CCS’10, October 4–8, 2010, Chicago, Illinois, USA.
Copyright 2010 ACM 978-1-4503-0244-9/10/10 ...$10.00.
1.
INTRODUCTION
Consider the following scenario: As an employee with ac-
cess to privileged information, you’re caught oﬀ-guard by a
co-worker’s request for sensitive data. While he claims to
have suﬃcient clearance, you don’t want to risk unautho-
rized access. One approach to solve this problem would be
to check the requester’s credentials in a database or with
an authority charged with validating credentials. However,
this raises several problems of its own. Most fundamentally,
it may be that your co-workers level of clearance is sensi-
tive information in itself, and therefore any system utilizing
a database storing users’ credentials would be unacceptable
(e.g. while you may have ‘Top-Secret’ clearance, you may
not have the authority to know whether someone else does).
Your needs would be met (and your worries relieved) if
you had an encryption scheme that guaranteed that your
co-worker could only recover the data if he has the proper
credentials. Then, you could simply encrypt the data with
respect to an access policy appropriate to the data, and be
sure that you did not give unauthorized access.
Deﬁning and constructing a scheme with such a guarantee
is the focus of this work. Informally, we require the following
security guarantees:
• The scheme should be secure against eavesdroppers,
satisfying usual notions of indistinguishability.
• The policy of a ciphertext should remain hidden, even
to a user that can decrypt the ciphertext, except for
the information that the user’s credentials satisfy the
policy. This requirement can be crucial in many set-
tings: For example, if a naval vessel sends out an en-
crypted message with a policy limiting access to “Spe-
cialists in analyzing enemy submarine activity,” then
one could reasonably conclude that an enemy subma-
rine was spotted just by observing the access policy.
In fact, we will consider an even more general form
of encryption where a general function f is encrypted.
The recipient only learns f (x), where x is an encoding
of the credentials of the recipient. Nothing else about
the function is revealed.
• A user’s public key should leak no information about
his credentials.
• Even if the certiﬁcation authority (that validates cre-
dentials) is corrupted, it should not be able to com-
promise the security of any encryptions prepared for
honest users.
463We shall call a scheme which provides the above guarantees
of security a Worry-Free Encryption Scheme, since a sender
does not need to worry about whether a recipient is autho-
rized to obtain a message before sending it. Deﬁning and
constructing such a scheme is the focus of this work.
1.1 Related Work
Worry-Free Encryption is most closely related to two no-
tions previously considered in the literature: functional en-
cryption [17] and conditional disclosure of secrets [5, 1].
Functional encryption (with Attribute-Based Encryption
as a special case) seeks to deal with a very similar setting to
ours, but with notable diﬀerences that make the notions in-
comparable. Most fundamentally, functional encryption re-
quires a greater degree of trust in a central authority: there
must be a Key Generation Authority, which if corrupted,
can then decrypt messages sent to all users in the system.
Reducing trust in these systems is an area of much inter-
est and current research [6]. Such central trust is avoided
in Worry-Free Encryption, where even if the Certiﬁcation
Authority is corrupted, it will not be able to compromise
messages encrypted to any honest user. At the same time,
by having the Key Generation Authority, functional encryp-
tion is able to avoid the need for public keys. This feature
allows functional encryption to be applicable to a number of
important settings, such as searching on encrypted data [10]
and secure cloud storage [8, 3] where the identities of recip-
ients may not be known during encryption. We stress that
Worry-Free Encryption is not designed to address these set-
tings; in our setting, encryption is done with respect to a
particular user’s public key.
When we examine some of the most active areas of re-
search in functional encryption, other important diﬀerences
emerge. For example, in Attribute Based Encryption [17, 3,
7, 13] a user can only decrypt if his credentials satisfy a pol-
icy associated with the ciphertext1. However, the privacy of
the policy on the ciphertext is not protected. As illustrated
by the submarine example above, this can be problematic
in many contexts. Furthermore, known results generally re-
strict policies to a fairly restrictive class.
For certain forms of functional encryption, (also known
as Predicate Encryption [4, 10, 19, 18, 11, 13]) the privacy
of the policy associated with a given ciphertext is a central
issue. However, the functions that can be encrypted by the
best current work are extremely limited, with the state of
the art being the ability to check if a dot product of two
vectors is zero. In contrast, as detailed below, for Worry-
Free Encryption we will be able to handle all polynomial-
time computable functions.
Our notion is also closely related to the notion of proto-
cols for conditional disclosure of secrets [5, 1], where (for the
two-party setting), a receiver is able to obtain the sender’s
secret if a ﬁxed condition C is satisﬁed by the receiver’s
input. Such protocols have been typically considered for
speciﬁc (usually algebraic) conditions C. In contrast, in our
setting, this condition itself is both chosen by the sender and
must remain secret from the receiver.
1.2 Results
Our work has two main contributions:
1We speciﬁcally are deﬁning Ciphertext-Policy ABE, there
is also a notion of Key-Policy ABE where policies are asso-
ciated with attributes are assigned to ciphertexts.
• We introduce the notion of Worry-Free Encryption.
• We provide several constructions:
◦ Our basic construction of Worry-Free Encryption works
for arbitrary polynomial-time functions and is secure
under chosen-plaintext attacks. The scheme requires
only the existence of IND-CPA public-key encryption.
The main ingredient is Yao’s garbled circuits [20].
◦ We build a Worry-Free Encryption scheme that is se-
cure against adaptive chosen-ciphertext attacks in the
random oracle model. Our transformation is quite eﬃ-
cient, and the new scheme requires only one additional
public-key operation over our basic scheme. No addi-
tional assumptions are needed. To achieve this goal,
we give a novel method to prove the well-formedness
of a collection of ciphertexts.
◦ Finally, we show that if non-interactive zero knowl-
edge proofs for NP exist, there exists IND-CCA2 se-
cure Worry-Free Encryption without random oracles.
Additionally, we consider the problem of a dishonest cer-
tiﬁcation authority that is colluding with a dishonest user
Alice. We stress that the standard deﬁnition of Worry-Free
Encryption already guarantees that the security of messages
sent to other parties cannot be compromised. However,
there is another concern. What if (honest) Bob is send-
ing Alice the encryption of some function f , expecting her
to only be able to recover f (x) where x is Alice’s credentials.
With no other security requirements, Alice and the authority
together may be able to recover f completely, and thereby
obtain information the Bob never intended any individual
recipient to gain. To deal with this, we deﬁne a strength-
ening of our notion that guarantees that even when Alice
and the authority collude, when Bob encrypts a message to
Alice, nothing beyond f (x(cid:48)) for some particular input x(cid:48) will
be learned by Alice and the authority. We obtain this higher
level of security, under the assumption that a variant of one-
round 1-out-of-2 Oblivious Transfer exists. Our extension is
a natural one which at least one classical OT protocol [15,
1] satisﬁes.
2. PRELIMINARIES
Throughout the paper, we will use arrowed variables to
denote vectors (e.g. (cid:126)C, (cid:126)v), x[i] to denote the ith bit of a
string x, b to denote b ⊕ 1 for a bit b and [1, k] to denote all
integers between 1 and k inclusive. We also use the notation
x ◦ y to denote the concatenation of the strings x and y and
|g| to denote the size of a circuit g. A function is called neg-
ligible if it grows slower than any inverse polynomial in an
implied parameter (usually λ, the security parameter), and
non-negligible if it is not negligible. A probability will be
said to be overwhelming if it is within a negligible additive
factor of 1. We use x $←− E to denote that x is chosen uni-
formly from the set E. Mm×n is the set of m by n matrices
with possibly null entries.
We will also make use of an existentially unforgeable sig-
nature scheme S = (KeyGen, Sign, V er) which while not
necessary to satisfy our security deﬁnitions, is required un-
less another method to ensure users only encrypt using pub-
lic keys that the certiﬁcation authority (CA) publishes (such
as a secure database to store public keys). Furthermore,
464while we only explicitly state it for the Setup algorithm,
we assume all parties have access to the security parameter
λ and are restricted to running in polynomial time in this
parameter.
2.1 Randomized Encodings
Our main construction will use decomposable randomized
encodings heavily. A decomposable randomized encoding of
g : {0, 1}n → {0, 1}k represented as a circuit of size polyno-
mial in the security parameter λ will split g into 2n compo-
nents: ([g]i,b : i ∈ [1, n], b ∈ {0, 1}) such that for a given x,
([g]i,x[i] : i ∈ [1, n]) will suﬃce to reconstruct g(x) but will
computationally leak no other information about g except
the size of the circuit (this problem can be addressed by
padding). Randomized encodings as used in this paper can
be constructed for any function g which can be represented
as a polynomial size circuit by using garbled circuits [20].
Definition 2.1. [2] A decomposable randomized encod-
ing consists of a pair of algorithms E, the encoder, and D,
the decoder, such that for security parameter λ:
◦ Decomposability: For f a circuit from {0, 1}n → {0, 1}k:
E(f, 1λ) → ([f ]i,b ∈ {0, 1}m : i ∈ [1, n], b ∈ {0, 1})
for m a function of n,|f|, k, λ with m = poly(λ) if |f| =