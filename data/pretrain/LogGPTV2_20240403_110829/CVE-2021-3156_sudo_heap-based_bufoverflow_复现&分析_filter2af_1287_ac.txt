        new_service = (service_user *) malloc (sizeof (service_user)
                                               + (line - name + 1));
        // 赋值
        *nextp = new_service;
        nextp = &new_service->next;
        continue;
      }
    }
当配置文件中所有的服务规范全部处理完毕之后，形成了下面的列表，其中链表头存储在`libc`中。
    pwndbg> p &service_table
    $52 = (name_database **) 0x7ffff7f457a8 
    pwndbg> p *service_table
    $53 = {
      entry = 0x5555555829d0,
      library = 0x0
    }
    pwndbg> p *service_table->entry
    $54 = {
      next = 0x555555582a70,
      service = 0x5555555829f0,
      name = 0x5555555829e0 "passwd"
    }
    pwndbg> p *service_table->entry->next
    $55 = {
      next = 0x5555555885b0,
      service = 0x555555588530,
      name = 0x555555582a80 "group"
    }
    pwndbg> p *service_table->entry->next->service
    $56 = {
      next = 0x555555588570,
      actions = {NSS_ACTION_CONTINUE, NSS_ACTION_CONTINUE, NSS_ACTION_CONTINUE, NSS_ACTION_RETURN, NSS_ACTION_RETURN},
      library = 0x0,
      known = 0x0,
      name = 0x555555588560 "files"
    }
经过调试发现`get_user_info`函数中的堆块申请顺序如下
    malloc(0x100)
    malloc(0x400)
    malloc(0x1d8)// tcache
    malloc(0x10)
    malloc(0x78)// 固定0x80 // 释放
    malloc(0x1000) 
    malloc(0x17)// 以下均为固定申请，且不会释放
    malloc(0x36) 
    malloc(0x38)
    malloc(0x16)
    malloc(0x36)// group files
在`glibc>2.27`版本之上由于存在`tcache`，因此在申请堆块的时候会首先判断`tcache`中是否存在空闲的堆块。我们的目的是覆写`group
files`堆块，攻击如下首先是获取了`free`的原语，得到可以释放任意大小和数量的堆块之后进行了下面的布置。首先是`2`个`0x40`大小的堆块用来满足`passwd`的`service_user`的堆块的申请，然后释放一个堆块，用来满足`user_args`堆块的申请，然后再释放一个`0x40`大小的堆块用来满足`group
files service_user`的堆块的申请。
那么在`get_user_info`函数初始化所有的`service_user`堆块之后，在之后溢出`user_args`的时候就可以直接溢出到`group
files`的`service_user`结构体，就可以进行加载我们自己的动态链接库`getshell`。
###  free 原语
`sudo`在`main`函数的起始位置`sudo.c:154`调用了`setlocale(LC_ALL,
"");`函数，其中`locale=""`表示根据环境变量来设置`locale`。`setlocale`会申请和释放大量的堆块。来看一下`setlocale`函数的源码
    //setlocale(LC_ALL, "");
    //glibc/locale/setlocale.c
    char *
    setlocale (int category, const char *locale)
    {
      char *locale_path;
      size_t locale_path_len;
      const char *locpath_var;
      char *composite;
      //...
      if (category == LC_ALL)
      {
       //...
        /* Load the new data for each category.  */
        while (category-- > 0)
          if (category != LC_ALL)
          {
            // 循环查找环境变量中的LC*环境变量的值，并根据优先级顺序进行加载，环境变量的值会存储在newnames中
            newdata[category] = _nl_find_locale (locale_path, locale_path_len,
                                                 category,
                                                 &newnames[category]);
            //...
          }
        /* Create new composite name.  */
        composite = (category >= 0
                     ? NULL : new_composite_name (LC_ALL, newnames));
        if (composite != NULL)
        {
          //setname&setdata，即为_nl_global_locale.__names数组赋值，该数组中存储有所有的环境变量的值
          // 如果数组中原来存储有值，且不是默认的"C"，那么会释放原有的堆块
        }
        else
          for (++category; category next)
        if (retval->filename != NULL)
        {
          int compare = strcmp (retval->filename, abs_filename);
          if (compare == 0)
            /* We found it!  */
            break;
          if (compare < 0)
          {
            /* It's not in the list.  */
            retval = NULL;