“主从”关系来表示这种信息：其中的试验课题标识信息和标准初
#时间可选（可能为NULL）
#日期是必需的
，用另一个列来表示英寸。这种做法让算术运算变得稍微容
后的值。这种表示方法的优点是，计算
这样的值。这种表示形式的优点是
3.6选择数据类型
在
185
失
要
精
适
三
是
---
## Page 206
的最大长度也会对能用的列类型产生影响。如果需要存储的字符串短于256个字符，那么可以
数
0~100，那么选择TINYINTUNSIGNED即可满足需要，
于讨论，我们在创建该列时选用的类型是INT。但是，你现在可以看到，如果成绩的范围都是在
项
得更大些。
进而加快索引搜索的速度。
读取较短的值时，所需的磁盘读写操作会更少，并且可以把更多的键值放入内存索引缓冲区里，
从MEDIUMINT到BIGINT之间的某一种。
间的任何一种类型。如果取值范围超过了200万，则不能使用SMALLINT，可以选择的类型变为
值的范围则决定了可选用的类型。如果取值范围是0~1000，那么可以选择SMALLINT~BIGINT之
储
择
值的范围，会有助于把选择缩小到该范畴里的某个特定类型上。假设，需要存储某些整数值。
3.6.2
种
分则输入NULL。另一种可能是使用DATE值，并将其中的年、月或日这几个部分设置为O。这
须将其分成年、月和日三个列来使用。然后，对于你所拥有的日期，输入其存在部分，其余部
死亡年份（或年和月），而非精确的日期。如果选用DATE列来记录这些信息，那么你只能输入
研究，你正在收集某些人的出生和死亡日期。有时，你所能收集到的资料只包括某人的出生或
者解释清楚，并确信在为特定数据创建表之前，已对它们的各项特征了然于心。
致
表行之间的关联关系。即使你保留了一份独立的信息记录，情况也是乱如麻，并且很可能会导
立的数据源，如原始书面记录，那么将很难修复已有的行。另外，你根本无法理清从表行与主
主表的行错误地交织在一起。很遗憾，为时已晚！
同样的试验，并在输入这些课题的数据之后，开始变得焦头烂额，想方设法要防止从表的行与
些情况下，他们是正确的。但是，我也见过很多与之相同的人，他们后来在一天之内做了多次
那么你将无法把该课题具体的行与相应的主表行关联起来。
列和TIME列（两列都必须填写）。在没有记录时间值时，如果有课题一天之内进行了两次试验，
186
要。如果猜测的类型偏小，那么也不是就无药可救。将来，还可以使用ALTER TABLE让该列变
者空间。此外，你还将获得更好的性能，因为与较长的列相比，较短的列的处理速度更快。
BIGINT)。但是，如果选用足以满足使用目的的最小类型，那么将可以最小化表所使用的存
中“模糊”日期可以用来表示不完整的日期值。
有完整日期格式的日期值。如果需要把你拥有的信息（哪怕它不完整）都记录下来，那么必
收你已编写好的使用到这些表的应用程序出问题。最好的解决办法是，把这类问题向表的拥有
如果某个字符串列用于表示某种固定集合的值，那么可以考虑使用数据类型ENUM或SET。
有时，你也会发现可以把某个列调整得小一点。在1.4.6.2节的3小节里，我们为成绩考评
如果无法获知各种可能值的范围，则只能靠猜测，或者使用BIGINT以满足最坏情况的需
当然，你完全可以为你要存储的那类值选择一种最“大”的类型（如在上一段的示例里选
有时，你所掌握的数据并不完整，而这也将影响到你对数据类型的选择。假设，
有时候，可以通过往表里增加一个 TIME 列来解决此问题。
我曾听到有人声称：“我不需要记录时间值，我在同一天绝不会做两次相同的试验。”在有
字符串类型没有像数字类型列那样的“取值范围”，
那么可以使用UNSIGNED 属性；否则，不可使用。
数据的取值范围，也会对与数据类型一起使用的属性产生影响。如果所有值都不可能为负
如果你已确定了一个大致范畴，计划从中选择列的数据类型，那么多考虑一下所要表示的
所有值是否都在某个特定的区间内
第3章数据类型
，因为这样占用的存储空间会更少。
，但它们都有长度的概念，并且实际需要
。不幸的是，如果你没有某种独
为了家谱
鼎
在
便
---
## Page 207
是“例外会发生吗？”
你在创建表时，可千万不要有这样的想法。你需要提出的问题不是“例外会经常发生吗？”，
设计的人们总是会有这样的认识误区：只要例外情况不是经常发生，那么它们就无足轻重。
存在某种例外情况，哪怕只有一次，你也必须考虑到它。你可能会发现，那些与你讨论数据库
（这时，可以使用ALTERTABLE来补救。）
被对方接受。但是，如果对方不接受，那么你将不得不记录“－1”，即不能使用UNSIGNED 列。
于表示“学生因病缺席”。糟糕！他们当初可没提及这一点！使用NULL来表示这种值，可能会
了UNSIGNED。后来你才发现，这些人在用程序把些数据录入数据库时，有时也会用“－1”，用
有了这句话，所以你决定选用TINYINT类型；又因为这些值总是为非负数，所以你把它设置为
己的数据“总
恰当的地方。当你在了解他人数据的情况时，如果对方说出了这两个词，则需要引起特别的注
为负")，因为它们可以进一步约束你对数据类型的选择。但千万注意不要把这两个词用在并不
允许值列表里的字符串进入数据库。更多相关细节请参考3.3节。
从而可以节省更多空间。此外，如果启用了SQL的严格模式，那么还可以防止那些并未列在
方式进行，这使它们的处理效率比其他字符串类型的更高。它们也比其他字符串类型更紧凑，
它们之所以是很好的选择，那是因为它们在内部都被表示为数字。对它们的操作都是按数字
有时，顺便多问一个问题（如“会有例外吗？”)，这种情况便可能会变得易于处理。只要
在确定取值范围时，最常用的两个词“总是”和“绝不”（如“总是小于1000”或“绝不
假设，
你正在为一组调查员设计表，他们告诉你：“我们的考试成绩总是在0～100。”因
总
是”具备某种特征时，其实是想说“几乎总是”。
只要有例外发生，你就必须考虑它们。
或“绝不”
”时，一定要确认他们真的那个意思。有时，当人们在说自
3.6选择数据类型
187
而
为
---
## Page 208
方式。视图提供了一种简单的运行复杂查询的方式，通过这种方式可以简化应用程序的开发。
上又不包含数据。其实，它是根据表或其他视图来进行定义的，并且提供了另一种查看表数据的
视图和存储程序
存储程序（stored program）是另一种类型的存储对象。它们有多种形式，有些可以按需调
口存储程序。它是存储函数、存储过程、触发器和事件的总称。
本章会用到以下术语。
口存储程序可以把复杂的计算封装成一个程序单元，从而可以轻易地通过名字来调用它。
口所有用于定义存储程序的代码，都会在这个程序创建时通过网络一次性发送出去，而不
口存储对象的可执行部分可以使用复合语句——它对SQL语法进行了扩展，可以包括代
事件（event）。它会根据计划在预定时刻自动执行。
口存储函数（storedfunction）。它可以用在表达式里返回某个计算的结果。
而其他的则可以在修改表或达到预定时间时自动执行。
视图（view）是一种类型的存储对象。视图是一个虚拟表。也就是说，它像一个表，但实际
口
存储程序有以下几个优点和功能。
存储过程（stored procedure）
行，从而启用对敏感数据的访问控制。
它们可以提高数据库的安全性，
它们提供了一种错误处理机制。
存储程序提供了一种标准化计算操作的方式，因为所有使用它的应用程序都会以相同
码块、循环和条件语句。
的方式来执行这些操作。
是每一次需要执行它时才发送。这样可以减少执行时间上的开销。
语句进行修改时，它会自动执行。
者生成可以传递回到客户端的结果集。
第4章
。它不会直接返回结果，但可以用来完成一般的运算，或
因为它们可以限制具有哪些权限的存储程序才能执
---
## Page 209
(base table），但它未列在视图定义里，你也不能引用它：
到视图的定义里，以便进一步限制检索结果：
权限，以及拥有对该语句里其他地方所引用的所有列的SELECT权限。
可以使用SELECT*，并且只会获得在视图定义里通过名字指定的那些列：
检索出来。具体的解决办法是定义一个视图，让它只检索想要的那些列：
同时，你也不想使用SELECT*。虽然这个写起来更简单，但是用*会把那些你并不想要的列也
都写出来：
last_name、first_name、city 和 state 这4列，但是并不想使用下面这种方式将这几个列
算和连接等操作，因此查询视图更易于编写出简单的用于获得所要信息的查询。
就等效于查询定义它的那条语句，只是视图将细节隐藏了起来。视图定义里可以包含表达式计
4.1
更多语法有关的信息请参考附录E。
程序的共同之处，并且常用于控制对数据的访问。
SELECT last_name, first_name, city, state FROM president;
在使用视图时，只能引用在该视图定义里列出的那些列。也就是说，即使某个列属于基表
一个基本的视图可以只选择表的部分列。假设你经常想要从 president 表里只选取
视图是一个虚表，
这里所讨论的是与CREATE语句有关的语法描述，其中只展示了最为重要的那几个子句。
如果添加ORDERBY、LIMIT 等子句，也会有同样的效果。
在创建视图时，
mysql> SELECT * FROM vpres;
现在，这个视图就像一个“窗口”，透过它只能看到你想的那些列。这意味着，在视图里也
SELECT last_name,
CREATE VIEW vpres AS
本章展示了如何创建和使用视图与存储程序。还介绍了DEFINER子句一
I last_name I first_name
口存储例程（stored routine）。它主要特指存储函数和存储过程。这两种对象的定义语法很
Adams
Adams
Monroe
Madison
Washington
last_name
使用视图
Jefferson
Adams
书并没有按照那种方式来使用这个术语。
这一术语来同时指代存储函数和存储过程。但个人认为那样很容易引起混淆，所以本
相似，因此会把它们放在一起讨论。事实上，也有许多数据库文献使用“存储过程”
John Quincy
John
，必须拥有对视图的CREATEVIEW权限，拥有对SELECT语句所选列的操作
James
James
George
first_name
Thomas
John
，它是在表或其他视图的基础上，使用 SELECT 语句来定义的。查询视图
first_name, city, state FROM president;
city
Braintree
Braintree
Westmoreland County
Wakefield
city
PortConway
Albemarle
Braintree
Istate
WW
County
state
A
4.1使用视图
一这是视图和存储
189
---
## Page 210
么只需要指定日期即可，当在执行它时，MySQL会将WHERE子句添加到视图的定义里。视图
易地检索到相同的信息：
藏复杂性，并轻易地查询到重要的输出信息。在1.4.9.10节，我们为成绩考评项目开发了一个
那些名字：
改用其他的列名，那么需要在视图定义里，紧跟视图名字的后面用括号列出那些新名字：
让查询真正需要的信息变得很简单：
查
190
查询，用于检索考试和测验的统计信息。我们可以把这个查询定义为一个视图，从而能够更轻
的引用此视图时，
如果只想看到某些列，那么可以列出它们的名字。如果只想看到某个特定事件的信息，那
CREATE VIEW grade_stats AS
除视图的 SELECT 语句较为复杂以外，前面的视图定义还是相对比较简单的。这样可以隐
mysql> SELECT last_name, first_name FROM vpres2;
mysql> CREATE VIEW vpres2(1n, fn) AS
在默认情况下，视图里的列名与其SELECT 语句里列出的输出列名相同。如果想要显式地
mysql>SELEcT date, category, count, average
通
COUNT(score.score)
MAX(score.score)
SELECT
mysql> SELECT 1n,
2012-10-01
2012-09-23
2012-09-06
2012-09-03
date
/Sql> SELECT *FROM grade_stats;
通过这个视图进行查询，会执行连接操作，并检索计算的结果：
OMSCOreINNERJOIN
IN(score.score)
Monroe
Madison
Jefferson
Adams
Washington
1n
2012-09-16
第4章视图和存储程序
-> SELECT last_name, first_name FROM president;