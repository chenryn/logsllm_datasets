 1800
 1600
 1400
 1200
 1
 2
 3
 4
 5
 6
 7
 8
No of threads
Figure 7.
Performance of PostMark with ClamAV anti-virus on-access
scanning of ﬁles whenever they are opened. We use non-buffered I/O and
set the number of ﬁle-system transactions to 100,000.
For PostMark tests, we use a multi-threaded policy man-
ager (Fig. 7). As we increase the number of threads, perfor-
mance of TXBOX increases at a fast rate while performance
of Linux+Dazuko remains roughly the same. With 4 threads
TXBOX is 2.3 times better than Linux+Dazuko.
VII. LIMITATIONS
Kernel-based security monitor is vulnerable to kernel at-
tacks. Like any OS-based security enforcement mechanism,
including existing system-call monitors, TXBOX is intended
to provide security against malicious user-level code. If the
OS kernel is compromised, malicious code can potentially
disable TXBOX or interfere with its operation. Defenses
against kernel-based malware are outside the scope of this
paper, but,
in general, maintaining integrity of security
enforcement in the face of kernel attacks requires a source of
trust outside the OS, such as provided by trusted hardware
(e.g., [43, 50]) or a virtual machine (e.g., [44, 57]).
342
Transactional semantics may change the behavior of
sandboxed processes. One possible side effect of running
every untrusted process inside a TXBOX sandbox is that
an access to a shared resource by a benign sandboxed
process may fail due to a transactional conﬂict with another
sandboxed process (see Section IV). This usually indicates a
race condition, which may very well be a problem by itself.
Furthermore, we expect that in a normal execution, only
untrusted applications are sandboxed and thus the number
of sandboxed processes on the host machine is fairly small.
TxOS has an auto-retry mechanism which, if set, attempts
to re-execute the failed transaction transparently to the
process. The number of retries is a conﬁgurable parameter.
If the transaction is aborted due to a security violation, it is
not re-started automatically (see Section V-A).
A secondary concern with automatically wrapping appli-
cations in system transactions arises when the application
itself uses system transactions for internal synchronization.
Currently, TXBOX only provides ﬂat nesting; a nested
transaction uses the same working set as its parent. TXBOX
could isolate nested sibling transactions from each other with
fairly straightforward extensions to the system transaction
mechanism, which we leave for future work.
Transactional state is not shared. Our parallelization
experiments use ClamAV [9], a relatively simple scanner
which looks for bit patterns associated with known viruses.
More sophisticated anti-virus tools may need to observe
the execution of the program in order to decide whether
it is malicious or not. To run such tools in parallel with
the sandboxed process, TXBOX must share the transactional
state of the process with the tool. This is not supported in
our current prototype but presents no conceptual difﬁculties.
Colluding malware may evade security policies. Any non-
trivial policy that involves more than one system call may be
violated by two or more colluding malicious programs which
execute on the same host independently. Consider a very
simple policy: “a program is malicious if it makes system
call A followed by system call B.” The ﬁrst malicious
program makes call A and saves its internal state in a
local ﬁle. The second program reads in the state of the
ﬁrst program and makes call B, achieving the same effect
as a single violating program. Obviously, more complex
policies can be bypassed by a similar attack. No sandboxing
mechanism can reliably prevent this.
Processes that generate very large worksets are killed.
The sandboxed process may try to bloat its transactional
workset by performing irrelevant operations. If TXBOX runs
out of memory to store the workset of any process, the
process is killed and the transaction is rolled back. TXBOX
does not currently support swapping out a process’s workset
as this may open up opportunities for denial of service.
This approach also prevents sandboxing very long-lived
applications because TXBOX cannot tell the difference be-
tween a program that has been running for a long time and
legitimately accumulated a large workset and a malicious
program which is deliberately bloating its workset.
An alternative approach is to perform intermediate com-
mits. When the workset of the sandboxed process gets too
big, TXBOX checks if the process has already violated
the sandboxing policy. If so, the process is killed and the
transaction is rolled back. If the policy is not (yet) violated,
the transaction is committed and a new one started, but
TXBOX keeps trace information from the old transaction
and merges it into the trace of the new transaction.
This approach preserves the ability of TXBOX to detect
violations that span the commit point, but sacriﬁces full
recoverability when a violation is detected because the
process can only be rolled back to the last commit point. This
is a strict generalization of standard system-call monitoring,
since the latter commits on every system call.
VIII. CONCLUSIONS
Increasing popularity of multi-core architectures is driving
the development of new mechanisms for managing con-
currency in software applications. One such mechanism is
system transactions, which allow a sequence of updates to
the system state made by one process to be performed atom-
ically, in isolation from other processes. We demonstrate
that system transactions provide a powerful primitive for
implementing secure, efﬁcient sandboxes for untrusted code.
TXBOX, our prototype sandboxing system based on a
modiﬁed Linux, enables speculative execution of untrusted
programs and automatic recovery from their harmful effects.
By inspecting system calls made by the program and its ac-
cesses to system resources, the TXBOX security monitor can
determine whether the programs satisﬁes the desired security
policy. Supported policies include system-call automata, as
well as data-ﬂow and access-control policies spanning mul-
tiple system calls. If a security violation is detected, TXBOX
aborts the transaction wrapping the malicious program, and
the system is restored as if the process never executed.
Unlike many system-call interposition tools and monitors
based on speculative execution, TXBOX cannot be circum-
vented by TOCTTOU (time-of-check-to-time-of-use) and
other concurrency attacks, nor by attacks that exploit incor-
rect mirroring of the kernel or ﬁle-system state, nor by split-
personality malware whose behavior changes depending on
whether it is instrumented with security checks or not.
TXBOX combines kernel-based enforcement with user-
level policies. This yields low performance overheads, en-
abling the use of TXBOX in production systems, especially
ones that already need system transactions to manage con-
current access to system resources. TXBOX also improves
the performance of on-access anti-virus scanning on multi-
core processors by executing the untrusted application on
one core and performing the scan in parallel on another core.
As system transactions increase in popularity and support
becomes available in commodity operating systems, security
enforcement mechanisms should take advantage of them. We
view TXBOX as a step in this direction.
Acknowledgements. We are grateful to our shepherd David
Wagner for many helpful comments and to Emmett Witchel
for his insightful advice and for guiding the development of
TxOS. The research described in this paper was partially
supported by the NSF grants CNS-0746888 and CNS-
0905602, Google research award, and the MURI program
under AFOSR Grant No. FA9550-08-1-0352.
REFERENCES
[1] M. Abadi, M. Budiu, U. Erlingsson, and J. Ligatti. Control-ﬂow
integrity. In CCS, 2005.
[2] A. Acharya and M. Raje. MAPbox: Using parameterized behavior
classes to conﬁne applications. In USENIX Security, 2000.
[3] A. Berman, V. Bourassa, and E. Selberg. TRON: Process-speciﬁc ﬁle
protection for the UNIX operating system. In USENIX Winter, 1995.
[4] M. Bernaschi, E. Gabrielli, and L. Mancini. REMUS: A security-
enhanced operating system. TISSEC, 5(1), 2002.
[5] S. Bhatkar, A. Chaturvedi, and R. Sekar. Dataﬂow anomaly detection.
In S&P, 2006.
[6] A. Birgisson, M. Dhawan, U. Erlingsson, V. Ganapathy, and L. Iftode.
Enforcing authorization policies using transactional memory intro-
spection. In CCS, 2008.
[7] M. Christodorescu, S. Jha, and C. Kruegel. Mining speciﬁcations of
malicious behavior. In ESEC-FSE, 2007.
[8] J. Chung, M. Dalton, H. Kannan, and C. Kozyrakis. Thread-safe
In HPCA,
dynamic binary translation using transactional memory.
2008.
[9] Clam AntiVirus. http://www.clamav.net/lang/en/.
[10] D. Clark and D. Wilson. A comparison of commercial and military
computer security policies. In S&P, 1987.
[11] C. Cowan, S. Beattie, G. Kroah-Hartman, C. Pu, P. Wagle, and
V. Gligor. SubDomain: Parsimonious server security. In LISA, 2000.
http://www.
[12] Dazuko. Dateizugriffskontrolle (ﬁle access control).
dazuko.org.
[13] J. Douceur, J. Elson, J. Howell, and J. Lorch. Leveraging legacy code
to deploy desktop applications on the web. In OSDI, 2008.
[14] G. Dunlap, S. King, S. Cinar, M. Basrai, and P. Chen. ReVirt: En-
abling intrusion analysis through virtual-machine logging and replay.
In OSDI, 2002.
[15] P. Efstathopoulos, M. Krohn, S. VanDeBogart, C. Frey, D. Ziegler,
E. Kohler, D. Mazi`eres, F. Kaashoek, and R. Morris. Labels and
event processes in the Asbestos operating system. In SOSP, 2005.
[16] U. Erlingsson and F. Schneider.
SASI enforcement of security
policies: A retrospective. In NSPW, 1999.
[17] H. Feng, O. Kolesnikov, P. Fogla, W. Lee, and W. Gong. Anomaly
detection using call stack information. In S&P, 2003.
[18] B. Ford and R. Cox. Vx32: Lightweight userlevel sandboxing on the
x86. In USENIX ATC, 2008.
[19] T. Fraser, L. Badger, and M. Feldman. Hardening COTS software
with generic software wrappers. In S&P, 1999.
[20] D. Gao, M. Reiter, and D. Song. Gray-box extraction of execution
graphs for anomaly detection. In CCS, 2004.
[21] T. Garﬁnkel. Traps and pitfalls: Practical problems in system call
interposition based security tools. In NDSS, 2003.
[22] T. Garﬁnkel, K. Adams, A. Warﬁeld, and J. Franklin. Compatibility
is not transparency: VMM detection myths and realities. In HotOS,
2007.
[23] T. Garﬁnkel, B. Pfaff, J. Chow, M. Rosenblum, and D. Boneh. Terra:
In SOSP,
A virtual machine-based platform for trusted computing.
2003.
[24] T. Garﬁnkel, B. Pfaff, and M. Rosenblum. Ostia: A delegating
architecture for secure system call interposition. In NDSS, 2004.
343
[25] T. Garﬁnkel and M. Rosenblum. A virtual machine introspection
[44] N. Petroni and M. Hicks. Automated detection of persistent kernel
based architecture for intrusion detection. In NDSS, 2003.
control-ﬂow attacks. In CCS, 2007.
[26] J. Gifﬁn, S. Jha, and B. Miller. Efﬁcient context-sensitive intrusion
[45] Hard link vulnerability.
http://plash.beasts.org/wiki/PlashIssues/
detection. In NDSS, 2004.
[27] I. Goldberg, D. Wagner, R. Thomas, and E. Brewer. A secure
environment for untrusted helper applications: Conﬁning the wily
hacker. In USENIX Security, 1996.
[28] Google. V8 benchmark suite.
http://v8.googlecode.com/svn/data/
benchmarks/v2/.
HardLinkVulnerability?highlight=%28PlashIssues/%29|
%28CategoryPostponed%29.
[46] open() with O CLOEXEC returns an error. http://plash.beasts.org/
wiki/PlashIssues/CloexecOpenFails?highlight=%28PlashIssues/%29|
%28CategoryPostponed%29.
[47] D. Porter. Operating system transactions. PhD thesis, The University
[29] T. Harris and S. Peyton-Jones. Transactional memory with data
of Texas at Austin, 2010.
invariants. In TRANSACT, 2006.
[48] D. Porter, O. Hofmann, C. Rossbach, A. Benn, and E. Witchel.
[30] M. Hill, D. Hower, K. Moore, M. Swift, H. Volos, and D. Wood.
A case for deconstructing hardware transactional memory. Technical
Report CS-TR-2007-1594, Dept. of Computer Sciences, University of
Wisconsin-Madison, 2007.
[31] S. Hofmeyr, S. Forrest, and A. Somayaji. Intrusion detection using
sequences of system calls. J. Comput. Secur., 6(3), 1998.
[32] K. Jain and R. Sekar. User-level
infrastructure for system call
interposition: A platform for intrusion detection and conﬁnement. In
NDSS, 2000.
[33] C. Kolbitsch, P. Milani, C. Kruegel, E. Kirda, X. Zhou, and X. Wang.
Effective and efﬁcient malware detection at the end host. In USENIX
Security, 2009.
[34] M. Krohn, A. Yip, M. Brodsky, N. Cliffer, F. Kaashoek, E. Kohler,
and R. Morris. Information ﬂow control for standard OS abstractions.
In SOSP, 2007.
[35] B. Lampson. A note on the conﬁnement problem. CACM, 16(10),
1973.
[36] A. Lanzi, D. Balzarotti, C. Kruegel, M. Christodorescu, and E. Kirda.
AccessMiner: Using system-centric models for malware protection. In
CCS, 2010.
[37] J. Larus and R. Rajwar. Transactional Memory. Morgan & Claypool,
2006.
[38] M. Locasto, A. Stavrou, G. Cretu, and A. Keromytis. From STEM
to SEAD: Speculative execution for automated defense. In USENIX
ATC, 2007.
[39] Mozilla Firefox JavaScript engine vulnerability. http://cve.mitre.org/
cgi-bin/cvename.cgi?name=CVE-2009-3982.
[40] E. Nightingale, D. Peek, P. Chen, and J. Flinn. Parallelizing security
checks on commodity hardware. In ASPLOS, 2008.
[41] Novell. AppArmor application security for Linux. http://www.novell.
com/linux/security/apparmor/.
[42] NSA.
Security-enhanced Linux.
http://www.nsa.gov/research/
selinux/.
[43] N. Petroni, T. Fraser, J. Molina, and W. Arbaugh. Copilot - a
In USENIX
coprocessor-based kernel runtime integrity monitor.
Security, 2004.
Operating system transactions. In SOSP, 2009.
[49] N. Provos.
Improving host security with system call policies.
In
USENIX Security, 2003.
[50] R. Sailer, X. Zhang, T. Jaeger, and L. van Doorn. Design and
implementation of a TCG-based integrity measurement architecture.
In USENIX Security, 2004.
[51] M. Seaborn. Plash. http://plash.beasts.org/wiki/.
[52] R. Sekar, M. Bendre, D. Dhurjati, and P. Bollineni. A fast automaton-
based method for detecting anomalous program behaviors. In S&P,
2001.
[53] M. Seltzer, Y. Endo, C. Small, and K. Smith. Dealing with disaster:
Surviving misbehaved kernel extensions. In OSDI, 1996.
[54] S. Sidiroglou and A. Keromytis. Execution transactions for defending
against software failures: use and evaluation. Int. J. Inf. Secur., 5(2),
2006.
[55] W. Sun, Z. Liang, R. Sekar, and V. Venkatakrishnan. One-way isola-
tion: An effective approach for realizing safe execution environments.
In NDSS, 2005.
[56] D. Wagner and D. Dean. Intrusion detection via static analysis. In
S&P, 2001.
[57] Z. Wang, X. Jiang, W. Cui, and P. Ning. Countering kernel rootkits
with lightweight hook protection. In CCS, 2009.
[58] R. Watson. Exploiting concurrency vulnerabilities in system call
wrappers. In WOOT, 2007.
[59] R. Watson, J. Anderson, K. Kennaway, and B. Laurie. Capsicum:
Practical capabilities for UNIX. In USENIX Security, 2010.
[60] A. Wespi, M. Dacier, and H. Debar. Intrusion detection using variable-
length audit trail patterns. In RAID, 2000.
[61] Microsoft Windows JavaScript engine arbitrary code execution vul-
nerability. http://tools.cisco.com/security/center/viewAlert.x?alertId=
18969.
[62] B. Yee, D. Sehr, G. Dardyk, B. Chen, R. Muth, T. Ormandy,
S. Okasaka, N. Narula, and N. Fullagar. Native Client: A sandbox
for portable, untrusted x86 native code. In S&P, 2009.
[63] N. Zeldovich, S. Boyd-Wickizer, E. Kohler, and D. Mazi`eres. Making
information ﬂow explicit in HiStar. In OSDI, 2006.
344