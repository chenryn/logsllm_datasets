is used to call a method, speciﬁed by name, on each
object contained in an array. The attacker can use this
function to trick the honest page into calling a univer-
sal DOM method, such as setTimeout. Suppose
the attacker has a JavaScript pointer to an array named
honest_array from an honest document that uses
the Prototype library (for how this might occur, see Sec-
tion 4.3) and that honest_window is the honest docu-
ment’s global object. The attacker can inject a malicious
script into the honest security origin as follows:
honest_array.push(honest_window);
honest_array.invoke("setTimeout",
"... malicious script ...", 0);
The attacker ﬁrst adds the honest_window object
to the array and then asks the honest principal to call
the setTimeout method of the honest_window.
When the JavaScript engine attempts to call
the
setTimeout DOM API, the DOM permits the call be-
cause the honest invoke method (acting as a confused
deputy) issued the call. The DOM then runs the mali-
cious script supplied by the attacker in the honest secu-
rity origin.
2.4 Consequences
Once the attacker is able to run a malicious script in the
honest security origin, all the browser’s cross-origin se-
curity protections evaporate. The situation is as if every
Web site contained a cross-site scripting vulnerability:
the attacker can steal the user’s authentication cookie or
password, learn conﬁdential information present on the
Web site (e.g., read email messages on a webmail site),
and issue transactions on behalf of the user (e.g., trans-
fer money out of the user’s bank account). Because these
cross-origin JavaScript capability leaks are browser vul-
nerabilities, there is little a Web site can do to defend
itself against these attacks.
3
In this section, we describe the design and implementa-
tion of an algorithm for detecting cross-origin JavaScript
capability leaks. Although the algorithm has a modest
overhead, our instrumented browser performs compara-
bly to Safari 3.1, letting us analyze complex Web appli-
cations.
3.1 Design
Assigning Security Origins. To detect cross-origin
JavaScript capability leaks, we monitor the heap graph,
the “points-to” relation between JavaScript objects in the
JavaScript Capability Leak Detection
JavaScript heap (see Section 3.2 for details about the
“points-to” relation). We annotate each JavaScript ob-
ject in the heap graph with a security origin indicating
which security origin “owns” the object. We compute
the security origin of each object directly from the “is-
prototype-of” relation in the heap graph using the fol-
lowing algorithm:
1. Let obj be the JavaScript object in question.
2. If obj was created with a non-null prototype, as-
sign obj the same origin as its prototype.
3. Otherwise, obj must be the object prototype for
some document d. In that case, assign obj the se-
curity origin of d (i.e., the scheme, host, and port of
that d’s URL).
This algorithm is unambiguous because, when created,
each JavaScript object has a unique prototype, identi-
ﬁed by its __proto__ property. Although an object’s
__proto__ can change over time, we ﬁx the security
origin of an object at creation-time.
Minimal Capabilities. This algorithm for assigning
security origins to objects is well-suited to analyzing
leaks of JavaScript pointers for two reasons. First,
the algorithm is deﬁned largely without reference to
the DOM, letting us catch bugs in the DOM. Second,
the algorithm reﬂects an object-capability perspective
in that each JavaScript object is a strictly more pow-
erful object-capability than the Object.prototype
object that terminates its prototype chain. An attacker
with a JavaScript pointer to the object can follow the
object’s prototype chain by repeatedly dereferencing the
object’s __proto__ property and eventually obtain a
JavaScript pointer to the Object.prototype object.
In these terms, we view the Object.prototype ob-
ject as the “minimal object-capability” of an origin.
Suspicious Edges. After annotating the heap graph
with the security origin of each object, we detect a
leaked JavaScript pointer as an edge from an object in
one security origin to an object in another security ori-
gin. These suspicious edges represent failures of the
JavaScript engine to segregate JavaScript objects into
distinct security origins. Not all of these suspicious
edges are actually security vulnerabilities because the
HTML speciﬁcation requires some JavaScript objects,
such as the global object, be visible to foreign security
origins. To prevent exploits, browsers equip these ob-
jects with a reference monitor that prevents foreign se-
curity origins from getting or setting arbitrary properties
of the object. In addition to the global object, a hand-
ful of other JavaScript objects required to be visible to
foreign security origins. These objects are annotated in
WebKit’s Interface Description Language (IDL) with the
attribute DoNotCheckDomainSecurity.
3.2 The “Points-To” Relation
In our heap graph, we include two kinds of points in
the “points-to” relation: explicit pointers that are stored
as properties of JavaScript objects and implicit pointers
that are stored internally by the JavaScript engine.
Explicit Pointers. A script can alter the properties of
an object using the get, set, and delete operations.
• get looks up the value of an object property.
• set alters the value of an object property.
• delete removes a property from an object.
To monitor the “points-to” relation between JavaScript
objects in the JavaScript heap, we instrument the set
operation. Whenever the JavaScript engine invokes the
set operation to store a JavaScript object in a prop-
erty of another JavaScript object, we add an edge be-
tween the two objects in our representation of the heap
graph. If the set operation overwrites an existing prop-
erty, we remove the obsolete edge from the graph. To
improve performance, we ignore JavaScript values be-
cause JavaScript values cannot hold JavaScript pointers
and therefore are leaves in the heap graph. We remove
JavaScript objects from the heap graph when the objects
are deleted by the JavaScript garbage collector.
Implicit Pointers. The above instrumentation does
not give us a complete picture of the “points-to” relation
in the JavaScript heap because the operational seman-
tics of the JavaScript language [14] rely on a number of
implicit JavaScript pointers, which are not represented
explicitly as properties of a JavaScript object. For exam-
ple, consider the following script:
var x = ...
function f() {
var y = ...
function g() {
var z = ...
function h() { ... }
}
}
Function h can obtain the JavaScript pointers stored in
variables x, y, and z even though there are no JavaScript
pointers between h and these objects. The function h
can obtain these JavaScript pointers because the algo-
rithm for resolving variable names makes use of an im-
plicit “next” pointer that connects h’s scope object to
the scope objects of g, f, and the global scope. Instead
of being stored as properties of JavaScript objects, these
implicit pointers are stored as member variables of na-
tive objects in the JavaScript engine. To improve the
completeness of our heap graph, we include these im-
plicit JavaScript pointers explicitly as edges between the
JavaScript scope objects.
Figure 1: The heap graph of an empty document.
Implementation
3.3
We implemented our leak detection algorithm in a 1,393
line patch to WebKit’s Nitro JavaScript engine. Our al-
gorithm can construct heap graphs of complex Web ap-
plications, such as Gmail or the Apple Store. For exam-
ple, one heap graph of a Gmail inbox contains 54,140
nodes and 130,995 edges. These graphs are often vi-
sually complex and difﬁcult to interpret manually. Fig-
ure 1 illustrates the nature of these graphs by depicting
the heap graph of an empty document. Although our in-
strumentation slows down the browser, the instrumented
browser is still faster than Safari 3.1, demonstrating that
our algorithm scales to complex Web applications.
4 Vulnerabilities and Exploitation
In this section, we use our leak detector to detect cross-
origin JavaScript capability leaks in WebKit. After
discovering two new vulnerabilities, we illuminate the
vulnerabilities by constructing proof-of-concept exploits
using three different techniques. In addition, we apply
our understanding of JavaScript pointers to breaking the
Subspace [11] mashup design.
4.1 Test Suite
To ﬁnd example cross-origin JavaScript capability leaks,
we run our instrumented browser through a test suite.
Ideally, to reduce the number of false negatives, we
would use a test suite with high coverage. Because our
goal is to ﬁnd example vulnerabilities, we use the We-
bKit project’s regression test suite. This test suite exer-
cises a variety of browser security features and tests for
the non-existence of past security vulnerabilities. Using
this test suite, our instrumentation found two new high-
severity cross-origin JavaScript capability leaks. Instead
of attempting to discover and patch all these leaks, we
recommend a more comprehensive defense, detailed in
Section 5.
WebKit’s regression test suite uses a JavaScript ob-
ject named layoutTestController to facilitate its
tests. For example, each tests notiﬁes the testing harness
that the test is complete by calling the notifyDone
method of the layoutTestController. We mod-
iﬁed this notifyDone method to store the JavaScript
heap graph in the ﬁle system after each test completes.
Figure 2: Selected nodes from a heap graph showing a
cross-origin JavaScript capability leak of the document
object, object@0x1a9e3c20, after a navigation.
The layoutTestController contains a number of
objects that are shared between all security origins. Our
instrumentation ﬂags JavaScript pointers to these objects
as suspicious, and, in fact, these pointers are exploitable
in the test conﬁguration of the browser. However, these
pointers are not present in the release conﬁguration of
the browser because the layoutTestController
itself is present only during testing. We white listed
these objects as visible to multiple security origins.
4.2 Navigation and Document
Vulnerability. When the browser navigates a window
from one Web page to another, the browser replaces the
document originally displayed in the window with a new
document retrieved from the network. Our instrumen-
tation found that WebKit leaks a JavaScript pointer to
the new document object every time a window navi-
gates because the DOM updates the document prop-
erty of the old global object to point to the new doc-
ument occupying the frame. This leak is visible in
the heap graph (see Figure 2) as a dashed line from
Attacker Global Object@0x1a9e1420 to the
honest document object, object@0x1a9e3c20.
Window Shell - 1c700000object - 1c700020__proto__object prototype - 1c7000a0__proto__object - 1c700aa0constructorobject - 1c700240__deﬁneGetter__object - 1c700280__deﬁneSetter__object - 1c7002c0__lookupGetter__object - 1c700300__lookupSetter__object - 1c700180hasOwnPropertyobject - 1c700200isPrototypeOfobject - 1c7001c0propertyIsEnumerableobject - 1c700100toLocaleStringobject - 1c7000c0toStringobject - 1c700140valueOfGlobal Object - 1c700040windowwindow@SCOPECHAIN GLOBAL__proto__object - 1c700b20Arrayobject - 1c700be0Booleanobject - 1c700c60Dateobject - 1c700da0Errorobject - 1c700de0EvalErrorobject - 1c700ae0Functionobject - 1c700c20NumberObjectobject - 1c700e20RangeErrorobject - 1c700e60ReferenceErrorobject - 1c700d60RegExpobject - 1c700b60Stringobject - 1c700ea0SyntaxErrorobject - 1c700ee0TypeErrorobject - 1c700f20URIErrorobject - 1c701140decodeURIobject - 1c701180decodeURIComponentobject - 1c701240dumpHeapobject - 1c7011c0encodeURIobject - 1c701200encodeURIComponentobject - 1c7010c0escapeobject - 1c700f80evalobject - 1c701080isFiniteobject - 1c701040isNaNobject - 1c701280kjsprintobject - 1c701340documentdocumentlocal - documentobject - 1c701000parseFloatobject - 1c700fc0parseIntobject - 1c701100unescapeobject - 1c700f60MathMath1c710090NaNNaNaundeﬁnedundeﬁned1c7100a0InﬁnityInﬁnityfunction prototype - 1c700060__proto__array prototype - 1c700400prototype__proto__boolean prototype - 1c700440prototype__proto__date prototype - 1c700680prototypeobject - 1c700ce0UTCobject - 1c700d20nowobject - 1c700ca0parse__proto__error prototype - 1c7007c0prototype__proto__object - 1c700860prototype__proto__prototype__proto__number prototype - 1c7004e0prototypeprototype__proto____proto__object - 1c7008c0prototype__proto__object - 1c700920prototype__proto__regExp prototype - 1c7006a0prototype__proto__string prototype - 1c700420prototypeobject - 1c700ba0fromCharCode__proto__object - 1c700980prototype__proto__object - 1c7009e0prototype__proto__object - 1c700a40prototype__proto____proto____proto____proto____proto____proto____proto____proto____proto____proto__object - 1c701320__proto____proto____proto____proto__constructorobject - 1c700380applyobject - 1c7003c0callobject - 1c700340toString__proto____proto____proto____proto____proto____proto____proto____proto____proto____proto____proto____proto____proto____proto__constructor__proto__constructor__proto__constructorobject - 1c700460toStringobject - 1c7004a0valueOf__proto____proto____proto__constructorobject - 1c700600toExponentialobject - 1c7005c0toFixedobject - 1c700540toLocaleStringobject - 1c700640toPrecisionobject - 1c700500toStringobject - 1c700580valueOf__proto____proto____proto____proto____proto____proto____proto__constructor__proto__constructorobject - 1c7006c0compileobject - 1c700700execobject - 1c700740testobject - 1c700780toString__proto____proto____proto____proto____proto__constructorobject - 1c700820toString__proto__constructor__proto__constructor__proto__constructor__proto__constructor__proto__constructor__proto__constructor__proto____proto____proto____proto____proto____proto__object - 1c7012c0__proto__object - 1c7012e0__proto__object - 1c701300__proto____proto__Attacker Global Object@0x1a9e1420object@0x1a9e3c20documentVictim Global Object@0x1a9e2940documentobject@0x1a9e3380ObjectObject Prototype@0x1a9e2980object@0x1a9e3c00__proto__object@0x1a9e3be0__proto__object@0x1a9e3bc0__proto__object@0x1a9e3ba0__proto____proto__prototypeto the old global object and access
Exploit. Crafting an exploit for this vulnerability is
subtle. An attacker cannot simply hold a JavaScript
pointer
its
document property because all JavaScript pointers to
global objects are updated to the new global object when
a frame is navigated navigation [10]. However, the prop-
erties of the old global object are still visible to func-
tions deﬁned by the old document via the scope chain
as global variables. In particular, an attacker can exploit
this vulnerability as follows:
1. Create an  to http://attacker.
com/iframe.html, which deﬁnes the following
function in a malicious document:
function exploit() {
var elmt = document.
createElement("script");
elmt.src =
"http://attacker.com/atk.js";
document.body.appendChild(elmt);
}
the exploit function refers to
Notice that
the document as a global variable, document,
and not as a property of
the global object,
window.document.
2. In the parent frame, store a pointer to the exploit
function by running the following JavaScript:
window.f = frames[0].exploit;
3. Navigate the frame to http://example.com/.
4. Call the function: window.f().
After the attacker navigates the child frame to http://
example.com/, the DOM changes the document
variable in the function exploit to point to the honest
document object instead of the attacker’s document ob-
ject. The exploit function can inject arbitrary script
into the honest document using a number of standard
DOM APIs. Once the attacker has injected script into
the honest document, the attacker can impersonate the
honest security origin to the browser.
4.3 Lazy Location and History
Vulnerability. For performance, WebKit instantiates
the window.location and window.history ob-
jects lazily the ﬁrst time they are accessed. When instan-
tiating these objects, the browser constructs their proto-
type chains. In some situations, WebKit constructs an
incorrect prototype chain that connects these objects to
the Object.prototype of a foreign security origin,
creating a vulnerability if, for example, a document uses
the following script to “frame bust” [12] in order to avoid
clickjacking [7] attacks:
top.location.href =