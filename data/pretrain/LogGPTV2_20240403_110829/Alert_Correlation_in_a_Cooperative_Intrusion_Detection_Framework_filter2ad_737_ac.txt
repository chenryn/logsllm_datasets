will have always the form “MIR-xxxx”. This corresponds
to  an  internal  classification  of  attacks  used  within  the
MIRADOR  project.  This  classification  is  used  by  the
merging 
specific”
classification  into  a  common  classification  so  that  it  is
thus  possible  to  make  correspondence  between  alert
classifications generated by two different IDS (see [3] for
more details).
translate 
function 
“vendor 
to 
3. Explicit correlation
We 
identified 
two  main  approaches 
to  achieve
correlation3:
•  Explicit correlation of events is used when the security
administrator  is  able  to  express  some  connection
between events that he knows. This connection may be
a logical link based on knowledge of relations between
alerts. It may be also a link depending on the topology
of information system's components [7,6].
•  Implicit  correlation  of  events  is  used  when  data
analysis brings out some mappings (may be statistical
ones) and relations between events.  This approach is
mainly  based  on  observing  groups  of  alerts  and
extracting  implicit  relations  between  them.  Many
works  show  that  intrusion  detection  probes  produce
groups  of  alerts  according  to  the  configuration  data,
the  traffic  and  the  topology  of  information  system
under  surveillance.  Such  approaches  are  based  on
learning  techniques  (classification  [9],  data  mining
[15], neural network [10], …) and should significantly
reduce the amount of alerts we have to deal with.
We  opt  for  the  explicit  approach  to  carry  out  the
correlation function. Thus, it must be possible to express
explicitly  known  logical  links  between  attacks.  This  is
achieved by using the following predicate:
•  attack_correlation(Attack1,Attack2): 
this  predicate
says that Attack1 may be correlated with Attack2, that
is  Attack1  enables  the  intruder  to  then  perform
Attack2.
3  Notice  that  several  authors  use  the  terms  “alert  correlation”  for
functions that actually correspond to “alert merging” in our terminology
(see  [13]  for  instance).  We  do  not  consider  such  approaches  in  the
remainder of this paper.
Proceedings of the 2002 IEEE Symposium on Security and Privacy (S&P(cid:146)02) 
1081-6011/02 $17.00 ' 2002 IEEE 
alert_correlation(Alert1,Alert2) :- 
Rule conclusion 
  alert(Alert1), 
  target(Alert1,Target1), 
  target_node(Target1,Target_node1), 
  address(Target_node1,Target_address1), 
  target_service(Target1,Target_service1), 
  service_name(Target_service1,Service_name1), 
  classification(Alert1,"M IR-0066"), 
 alert(Alert2), 
  target(Alert2,Target2), 
  target_node(Target2,Target_node2), 
  address(Target_node2,Target_address2), 
  classification(Alert2,"M IR-0162"), 
  Target_address1 = Target_address2, 
  Service_name1 = "mountd". 
Premise part 1: 
Description of Alert1 
Premise part 2: 
Description of Alert2 
Premise part 3: 
Correlation conditions 
Figure 3: Example of correlation rule between alerts corresponding to attacks
“MIR-0066” (rpcinfo) and “MIR-162” (showmount)
occurrence  of  attack  B  because  we  can  assume  that  the
intruder  has  performed  A  as  a  step  that  enables  him  to
perform B.
To formally define this kind of correlation between the
post-condition  of  an  attack  and  the  pre-condition  of
another  attack, 
logical  formula
representing the post-condition of attack A and pre(B) be
the  logical  formula  representing  the  pre-condition  of
attack B. Of course, we can correlate attack A and attack
B if post(A) logically implies pre(B), that is:
let  post(A)  be 
the 
post(A) Å pre(B)
However, this definition is generally too strong. This is
because it is sufficient to correlate attack A with attack B
that attack A “contributes” to the realization of attack B.
This is formally specified as follows:
post(A) ∧ hyp  Å pre(B)
where  hyp  is  an  hypothesis  that,  when  combined  with
post(A),  implies  pre(B).  Of  course,  the  hypothesis  hyp
alone  must  not  be  sufficient  to  imply  pre(B),  that  is  we
must not have hyp Å pre(B). Another requirement is that
hyp must be consistent with post(A) because if this is not
the case then one can derive anything from post(A) ∧ hyp,
in particular pre(B).
The  work  we  have  done  is  based  on  this  general
definition of correlation. However, this  first  definition  is
not  very  manageable.  Next  sections  present  more
practical definitions of correlation. The implementation of
the  correlation  function  in  CRIM  is  actually  based  on
these definitions.
As the reader may  notice, specifying correlation rules
would be a quite complex task to perform manually:
•  It would be tedious for the administrator at least from a
syntactical point of view.
•  It is not obvious to be exhaustive, that is not to forget
correlation rules specifying pairs of alerts that may be
correlated.
•  It  is  also  not  always  obvious  to  specify  the  right
correlation conditions.
This  is  the  reason  why  it  would  be  very  interesting  to
have a method to automatically generate correlation rules.
We  have  developed  such  a  method,  called  semi-explicit
correlation. It is presented in the following section.
4. Semi-explicit correlation in LAMBDA
4.1. Background of the approach
This  section  presents  the  approach  we  suggest  to
performing  alert  correlation.  This  approach  is  based  on
the analysis of attack description specified in LAMBDA.
The central idea of the approach is to recognize  whether
executing a given attack can contribute to execute another
attack.
This  idea  is  modeled  by  specifying  possible  logical
links  between  the  post-condition  of  an  attack  A  and  the
pre-condition of an attack B. If such a link exists, then it
is possible to correlate an occurrence of attack A with an
Proceedings of the 2002 IEEE Symposium on Security and Privacy (S&P(cid:146)02) 
1081-6011/02 $17.00 ' 2002 IEEE 
are not unifiable, correlation of “MIR-0164” with “MIR-
0163” fails.
condition  of 
Let  us  now  try  to  correlate  attack  “MIR-0162”
(Showmount) with attack “MIR-0163” (Mount partition).
A  possible  post 
is
“MIR-0162” 
knows(Source_user,mounted_partition(Target_address,
Partition)),  that  is  the  intruder  Source_user  knows  what
partitions are  mounted on the target  whose  IP  address  is
Target_address. 
hand,
mounted_partition(Target_address,Partition)  appears 
in
pre(“MIR-0163”). However, due to  knows  modality,  this
last  expression  is  not  directly  unifiable  with  post(“MIR-
0162”). This is intuitively not satisfactory since executing
Showmount enables the intruder to then mount a partition
observed in Showmount.5
other 
On 
the 
Therefore,  we  slightly  modify  definition  1  so  that
attack  “MIR-0162”  can  be  correlated  with  “MIR-0163”.
This leads to the following definition:
Definition 2: Direct correlation (general case)
We  say  that  attack  A  and  attack  B  are  directly
correlated if one of the following conditions is satisfied:
•  there exists i in [1,m] and j in [1,n] such that exprAi and
exprBj are unifiable through a mgu θ.
or
•  there exists i in [1,m] and j in [1,n] such that exprAi and
knows(User,exprBj) are unifiable through a mgu θ.
4.3. Indirect correlation
Let  us  now  consider  attacks  “MIR-0073”  (TCPScan)
and  “MIR-0036”  (Winnuke”).  These  two  attacks  are  not
correlated using definition 2. However, attack Winnuke to
succeed  requires  that  the  operating  system  used  on  the
target  system  is  Windows.  The  intruder  can  obtain  this
knowledge  about 
target  system  by  performing
TCPScan  and  by  observing  that  port  139  is  open
(meaning  that  a  NetBios  session  is  open  which  is
characteristic of Windows system).
the 
Therefore,  it  would  be  suitable  to  correlate  attacks
“TCPScan” and “Winnuke” in the case where port 139 is
scanned  (and  open).  For  this  purpose,  the  solution  we
suggest  is  to  specify  ontological  rules  to  represent
possible  relations  between  predicates.  These  ontological
rules are also represented using a pre and post condition.
Figure  4  shows  an  example  of  such  a  rule.  This
ontological rule says that if a system whose IP address is
System_address uses service NetBios, then the operating
system used on this system is Windows.
5  To  justify  this  point  we  actually  assume  that  modality  knows
satisfies the following axion for each User and Expr: knows(User,Expr)
→ Expr, that is if User knows that Expr then Expr is true.
4.2. Definition of alert correlation
Let A and B be two attacks and let Post(A) and Pre(B)
respectively  be  the  post  condition  of  attack  A  and  pre
condition  of  attack  B.  Let  us  assume  that  Post(A)  and
Pre(B) respectively have the following form:4
•  Post(A) = exprA1 , exprA2 , … , exprAm
•  Pre(B) = exprB1 , exprB2 , … , exprBn
where  each  expri  must  have  one  of  the  following
forms:
•  expri = pred
•  expri = not(pred)
•  expri = knows(User,pred)
•  expri = knows(User, not(pred))
where pred is a predicate.
Definition 1: Direct correlation (simple case)
We  say  that  attack  A  and  attack  B  are  directly
(Modification  of 
correlated if the following condition is satisfied:
•  there  exists  i  in  [1,m]  and  j  in  [1,n]  such  that  exprAi
and exprBj are unifiable through a most general unifier
(mgu) θ.
For  instance,  attacks  “MIR-0163”  (NFS  Mount)  and
“MIR-0164” 
.rhost)  are  directly
correlated. This is because post(“MIR-0163”) is equal to
can_access(Source_user,Partition)  and  this  predicate  also
appears in pre(“MIR-0164”). After renaming the variables
of  can_access(Source_user,Partition) 
that  respectively
appear  in  post(“MIR-0163”)  and  pre(“MIR-0164”)  into
can_access(Source_user1,Partition1) 
and
can_access(Source_user2,Partition2),  we  can  conclude
that  these  expressions  are  unifiable  through  mgu  θ  such
that  Source_user1  =  Source_user2  and  Partition1  =
Partition2.
On  the  other  hand,  the  converse  is  not  true,  that  is
attack  “MIR-0164”  is  not  directly  correlated  with  attack
“MIR-0163”. This is because post(“MIR-0164”) is equal
to 
access_level(Source_user,Target_address,user).
Predicate
access_level(Source_user,Target_address,remote) appears
in pre(“MIR-0163”) but  since  constants  user  and  remote
4  Notice  that  we  assume  that  the  pre  and  post  conditions  do  not
include  disjunction.  This  is  a  restriction  that  is  used  to  simplify
definition of correlation below. From a practical point of view, including
disjunction in the pre condition does  not  really  increase  the  expressive
power  of  our  attack  description  language  since  disjunctions  in  the  pre
condition might be split into several sub-rules corresponding to each part
of the disjunction. On the other hand, disjunction in the post condition is
useful since it would enable us to specify some non-determinism in the
effect of an attack. So, generalyzing correlation definitions below to take
into account such disjunctions represents further work that remains to be
done.
Proceedings of the 2002 IEEE Symposium on Security and Privacy (S&P(cid:146)02) 
1081-6011/02 $17.00 ' 2002 IEEE 
is 
correlated  with 
also appears in the precondition of “MIR-0036”, “RULE-
0001” 
“MIR-0036”  when
System_address = Target_address. Thus, we can conclude
that  attack  “MIR-0073”  is  indirectly  correlated  with
“MIR-0036”.
4.4. Generating correlation rules
In this section, we show how to automatically generate
correlation rules similar to the one presented in section 3.
The process we suggest is the following.
Let  us  consider  two  attacks  Attack1  and  Attack2
whose descriptions are correlated according to  definition
2  through  a  mgu  θ.  After  renaming  the  variables  that
appear in the descriptions of Attack1 and Attack2 so that
there  is  no  common  variable  in  these  descriptions,  we
shall  generate  a  correlation  rule  having  the  following
form:
  correlation_rule(Alert1,Alert2) :-
cond_detection(Attack1),
cond_detection(Attack2),
θ.
where  Alert1  and  Alert2  are 
the
(renamed)  variables  that  appear  in  the  detection  field  of
Attack1  and  Attack26.  For  example,  figure  5.a  presents
the correlation rule corresponding to attacks “MIR-0163”
(NFS Mount) and “MIR-0164” (Modification of .rhost).
respectively 
This  rule  is  correct  but  it  is  not  fully  optimized7.  In
particular,  target  descriptions  of  the  two  alerts  might  be
removed  since  they  are  not  related  to  the  correlation
condition.  Notice  also  that  our  process  also  generates
condition Partition1 = Partition2. This is correct since, in
this  attack  scenario,  the  intruder  must  modify  the  .rhost
file  of  a  partition  previously  mounted  with  attack  NFS
Mount.  But,  as  Partition1  and  Partition2  remains  free
variables, this condition will be always evaluated to true.
This  is  because  we  assume  that  information  about  the
mounted partition is not provided by alerts corresponding
to NFS Mount and Modification of .rhost.
The  case  where  two  attacks  Attack1  and  Attack2  are
indirectly  correlated  using  ontological  rules  is  slightly
more  complicated.  If  Attack1  and  Attack2  are  indirectly
correlated using ontological rules R1, …, Rn through a set
of mgu θ0, …, θn, then we shall generate a correlation rule
having the following form: