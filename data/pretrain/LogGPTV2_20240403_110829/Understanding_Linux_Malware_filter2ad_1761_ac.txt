prevalence of each of these aspects. Our goal
to
differentiate between different classes of malware or different
malware families (i.e., to distinguish botnets from backdoors
from ransomware samples), but instead to focus on the tricks
and techniques commonly used by malware authors—such
as packing, obfuscation, process injection, persistence, and
evasion attempts. To date,
this is the most comprehensive
discussion on the topic, and we hope that the insights we offer
will help to better understand how Linux-based malware works
and will serve as a reference for future research focused on
improving the analysis of this type of malware.
A. ELF headers Manipulation
The Executable and Linkable Format (ELF) is the standard
format used to store (among others) all Linux executables. The
format has a complex internal layout, and tampering with some
of its ﬁelds and structures provides attackers a ﬁrst line of
defense against analysis tools.
Some ﬁelds, such as e_ident (which identiﬁes the
type of ﬁle), e_type (which speciﬁes the object type), or
e_machine (which contains the machine architecture), are
needed by the kernel even before the ELF ﬁle is loaded in
memory. Sections and segments are instead strictly dependent
on the source code and the compilation process, and are needed
respectively for linking and relocation purposes and to tell the
kernel how the binary must be loaded in memory for program
execution.
Our data shows that malware developers often tamper with
the ELF headers to fool the analyst or crash common analysis
tools. In particular, we identiﬁed two classes of modiﬁcations:
those that resulted in anomalous ﬁles (but that still follow the
ELF speciﬁcations), and those that produced invalid ﬁles—
which however can still be properly executed by the operating
system.
Anomalous ELF. The most common example in the ﬁrst
category (5% of samples in our dataset) consists in removing
all information about the ELF sections. This is valid according
to the speciﬁcations (as sections information are not used at
runtime), but it is an uncommon case that is never generated
by traditional compilers. Another example of this category
consists of reporting false information about the executable.
For example, a Linux program can report a different operating
system ABI (e.g., FreeBSD) and still be executed correctly
by the kernel. Samples of the Mumblehard family report in
the header the fact that they require FreeBSD, but then test
the system call table at runtime to detect the actual operating
system and execute correctly under both FreeBSD and Linux.
For this reason, in our experiments we did not trust such
information and we always tried to execute a binary despite
the values contained in its identiﬁcation ﬁeld. If the required
ABI was indeed different, the program would crash at run-
time trying to execute invalid system calls—a case that was
recognized by our system to ﬁlter out non-Linux programs.
Invalid ELF. This category includes instead those samples
with malformed or corrupted sections information (2% of sam-
ples in our dataset), typically the result of an invalid e_shoff
(offset of the section header table), e_shnum (number of
entries in the section header table), or e_shentsize (size
166
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:37:40 UTC from IEEE Xplore.  Restrictions apply. 
of section entries) ﬁelds in the ELF header. We also found
evidence of samples exploiting the ELF header ﬁle format
to create overlapping segments header. For instance,
three
samples belonging to the Mumblehard family declared a single
segment starting from the 44th byte of the ELF header itself and
zeroed out any ﬁeld unused at runtime. Table II summarizes
the most common ELF manipulation tricks we observed in our
dataset.
Impact on Userspace Tools. To measure the consequences
of the previously discussed transformations, in Table III we
report how popular tools (used to work with ELF ﬁles) react to
unusual or malformed ﬁles. This includes readelf (part of GNU
Binutils), pyelftools (a convenient Python library to parse and
analyze ELF ﬁles), GDB (the de-facto standard debugger on
Linux and many UNIX-like systems), and IDA Pro 7 (the latest
version, at the time of writing, of the most popular commercial
disassembler, decompiler, and reverse engineering tool).
Our results show that all tools are able to properly process
anomalous ﬁles, but unfortunately often result in errors when
dealing with invalid ﬁelds. For example, readelf complained
for the absence of a valid table on hundreds of sample, but
was able to complete the parsing of the remaining ﬁelds in
the ELF header. On the other side, pyelftools denies further
analysis if the section header table is corrupted, while it can
instead parse ELF ﬁles if the table is declared as empty.
Because of this poor management of erroneous conditions, for
our experiments we decided to write our own custom ELF
parser, which was speciﬁcally designed to work in presence of
unusual settings, inconsistencies, invalid values, or malformed
header information.
Despite its widespread use in the *nix world, GDB showed a
severe lack of resilience in dealing with corrupted information
coming from a malformed section header table. The presence
of an invalid value results in GDB not being able to recognize
the ELF binary and in its inability to start the program.
Finally, IDA Pro 7 was the only tool we used in our analysis
pipeline that was able to handle correctly the presence of any
corrupted section information or other ﬁelds that would not
affect the program execution.
B. Persistence
Persistence involves a conﬁguration change of the infected
system such that the malicious executable will be able to
run regardless of possible reboot and power-off operations
performed on the underlying machine. This, along with the
ability to remain hidden,
is one of the ﬁrst objectives of
malicious code.
A broad and well-documented set of techniques exists for
malware authors to achieve persistence on Microsoft Windows
platforms. The vast majority of these techniques relies on the
modiﬁcation of Registry keys to run software at boot, when
a user logs in, when certain events occurs, or to schedule
particular services. Linux-based malware needs to rely on
different strategies, which are so far more limited both in
number and in nature. We group the techniques that we
observed in our dataset in four categories, described next.
ELF BINARIES ADOPTING PERSISTENCE STRATEGIES
TABLE IV
Path
/etc/rc.d/rc.local
/etc/rc.conf
/etc/init.d/
/etc/rcX.d/
/etc/rc.local
systemd service
˜/.bashrc
˜/.bash_profile
X desktop autostart
/etc/cron.hourly/
/etc/crontab
/etc/cron.daily/
crontab utility
File replacement
File infection
Total
Samples
w/o root
w/ root
-
-
-
-
-
-
19
18
3
-
-
-
6
-
5
1393
1236
210
212
11
2
8
8
1
70
70
26
6
110
26
1644 (21.10%)
Subsystems Initialization. This appears to be the most com-
mon approach adopted by malware authors and takes advantage
of the well known Linux init system. Table IV shows that
more than 1000 samples attempted to modify the system rc
script (executed at the end of each run-level). Instead, 210
samples added themselves under the /etc/init.d/ folder
and then created soft-links to directories holding run-level
conﬁgurations. Overall, we found 212 binaries displacing links
from /etc/rc1.d to /etc.rc5.d, with 16 of them using
the less common run-levels dedicated to machine halt and
reboot operations. Note how malicious programs still largely
rely on the System-V init system and only two samples in
our dataset supported more recent initialization technologies
(e.g., systemd). More important, this type of persistence only
works if the running process has privileged permissions. If
the user executing the ELF is not root or a user under
privileged policies, it is usually impossible to modify services
and initialization conﬁgurations.
Time-based Execution. This technique is the second choice
commonly used by malware and relies on the presence of cron,
the time-based job scheduler for Unix systems. Malicious ELF
ﬁles try to modify, with success when running under adequate
higher privileges, cron conﬁguration ﬁles to get scheduled ex-
ecution at a ﬁxed time interval. As for subsystem initialization,
time-based persistence will not work if the malware is launched
by unprivileged users unless the sample invokes the system
utility crontab (a SUID program speciﬁcally designed to mod-
ify conﬁguration ﬁles stored under /var/spool/cron/).
File Infection and Replacement. Another approach for mal-
ware to maintain a foothold in the system is by replacing
(or infecting) applications that already exist
in the target.
This includes both a traditional virus-like behavior (where the
malware locates and infect other ELF ﬁles without a strategy)
as well as more targeted approaches that subvert the original
functionalities of speciﬁc system tools.
167
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:37:40 UTC from IEEE Xplore.  Restrictions apply. 
ELF PROGRAMS RENAMING THE PROCESS
TABLE V
Process name
sshd
telnetd
cron
sh
busybox
other tools
empty
other *
random
Total
Samples
Percentage
406
33
31
14
11
22
2034
973
618
4091
5.21%
0.42%
0.40%
0.18%
0.14%
0.28%
26.11%
12.49%
7.93%
52.50%
* Names not representing system utilities
Our dynamically analysis reports allow us to observe infec-
tion and replacement of system and user ﬁles. Examples in this
category are samples in the family EbolaChan, which inject
their code at the beginning of the ls tool and append the origi-
nal code after the malicious data. Another example are samples
of the RST, Sickabs and Diesel families, which still use a 20
years old ELF infections techniques [13]. The ﬁrst group limits
the infection to other ELF ﬁles located in the current working
directory, while the second adopts a system-wide infection
that also targets binaries in the /bin/ folder. Interestingly,
samples of this family were ﬁrst observed in 2001, according
to a Sophos report they were still widespread in 2008 [14], and
our study shows that they are still surprisingly active today. A
different approach is taken by samples in the Gates family,
which fully replace system tools in /bin/ or /usr/bin/
folders (e.g., ps and netstat) after creating a backup copy
of the original code in /usr/bin/dpkgd/.
User Files Alteration. As shown in the middle part of
Table IV, very few samples modify conﬁguration ﬁles in the
user home directory such as shell conﬁgurations. Malware
writers adopting this method can ensure persistence at user
level, but other Linux users, beside the infected one, will not
be affected by this persistence mechanism. While the most
common, changes to the shell conﬁguration are not the only
form of per-user persistency. Few samples (such as those in
the Handofthief family) that target desktop Linux installations,
modiﬁed instead the .desktop startup ﬁles used by the
windows manager.
Table IV reports a summary of the amount of samples using
each technique. Surprisingly, only 21% of our ELF ﬁles imple-
mented at least one persistence strategy. However, samples that
do try to be persistent often try multiple techniques in a row
to reach their objective. As an example, in our experiments
we noticed that user ﬁles alteration was a common fallback
mechanism when the sample failed to achieve system-wide
persistency.
C. Deception
Stealthy malware may try to hide their nature by assuming
names that look genuine and innocuous at a ﬁrst glance, with
the objective of tricking the user to open an apparently benign
ELF SAMPLES GETTING PRIVILEGES ERRORS OR
TABLE VI
PROBING IDENTITIES
Motivation
EPERM error
EACCES error
Query user identity *
Query group identity *
Total
Samples
Percentage
986
716
1609
877
2637
12.65%
9.19%
20.65%
11.26%
33.84%
* Also include checks on effective and real identity
BEHAVIORAL DIFFERENCES BETWEEN USER/ROOT ANALYSIS
TABLE VII
Different behavior
Execute privileged shell command
Drop a ﬁle into a protected directory
Achieve system-wide persistence
Tamper with Sandbox
Delete a protected ﬁle
Run ptrace request on another process
Samples
Percentage
579
426
259
61
47
10
21.96%
16.15%
9.82%