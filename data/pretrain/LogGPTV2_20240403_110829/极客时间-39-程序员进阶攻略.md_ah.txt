## 二、交互视图交互视图，表达了系统或服务与外部系统或服务的协作关系，也即：依赖与被依赖。由于咚咚系统的业务场景繁多，拆分出来的服务种类也比较多，交互关系复杂。所以可以像地图一样通过不同倍率的缩放视角来表达和观察服务之间的交互关系。如下图，是一张宏观大倍率的整体交互视图示例。它隐藏了内部众多服务的交互细节，强调了终端和服务端，以及服务端内部交互的主要过程。这里依然以地图作类比，它体现了整体系统主干道场景的运动过程。而每一个服务本身，在整体的交互图中，都会有其位置，有些在主干道上，而有些则在支线上。![](Images/7bdb64a9fa539c422dce658de74f6e45.png){savepage-src="https://static001.geekbang.org/resource/image/4b/f4/4bf63fcd735af78c2258c1ddd8cde0f4.png"}```{=html}```交互视图示例]{.reference}```{=html}```如果我们把目光聚焦在一个服务上，以其为中心的表达方式，就体现了该服务的依赖协作关系。所以，可以从不同服务为中心点出发，得到关注点和细节更明确的局部交互细节图，而这样的细节图一般掌握在每个服务开发者的脑中。当我们需要写关于某个服务的设计文档时，这样的局部细节交互图也应该是必不可少的。在逻辑的层面了解了服务间的协作与交互后，则需要更进一步了解这些服务的部署环境与物理结构。
## 三、部署视图部署视图，表达系统的部署结构与环境。部署视图，从不同的人员角色出发，关注点其实不一样，不过从应用开发和架构的角度来看，会更关注应用服务实际部署的主机环境、网络结构和其他一些环境元素依赖。下面是一张强调服务部署的机房结构、网络和依赖元素的部署图示例。![](Images/366a6ff25a3db650e0f71b8ad4a2b1aa.png){savepage-src="https://static001.geekbang.org/resource/image/90/c7/90a43e28e56c0a21af03f741c358bac7.png"}```{=html}```部署视图示例]{.reference}```{=html}```部署视图本身也可以从不同的视角来画，这取决于你想强调什幺元素。上面这张示例图，强调的是应用部署的IDC及其之间的网络关系，和一些关键的网络通讯延时指标。因为这些内容可能影响系统的架构设计和开发实现方式。至此，组成、交互和部署图更多是表达系统的宏观视图：关注系统组合、协作和依存的关系。但还缺乏关于系统设计或实现本身的表达，这就引出了流程和状态两类视图。
## 四、流程视图流程视图，表达系统内部实现的功能和控制逻辑流程。可能有人喜欢用常见的流程图来表达系统设计与实现的流程，但我更偏好使用 UML的序列图，个人感觉更清晰些。下图是咚咚消息投递的一个功能逻辑流程表达，看起来就像是 UML的序列图，但并没有完全遵循 UML的图例语法（主要是我习惯的画图工具不支持）。而且，我想更多人即使是程序员也并不一定会清楚地了解和记得住UML的各种图例语法，所以都用文字做了补充说明，也就没必要一定要遵循其语法了，重点还是在于要把逻辑表达清楚。![](Images/060e2cd67b678b46ca0471263dfe2abd.png){savepage-src="https://static001.geekbang.org/resource/image/2b/2c/2b8ea4c772c314e3bb7b246501bea32c.png"}```{=html}```流程视图示例]{.reference}```{=html}```逻辑流程一般分两种：业务与控制。有些系统业务逻辑很复杂，而有些系统业务逻辑不复杂但请求并发很高，导致对性能、安全与稳定的要求高，所以控制逻辑就复杂了。这两类复杂的逻辑处理流程都需要表达清楚，而上图就是对业务功能逻辑的表达示例。除了逻辑流程的复杂性，系统维持的状态变迁很可能也是另一个复杂性之源。
## 五、状态视图状态视图，表达系统内部管理了哪些状态以及状态的变迁转移路径。像咚咚这样的 IM 消息系统，就自带一个复杂的状态管理场景：消息的已读 /未读状态。它的复杂性体现在，它本身就处在一个不可控的分布式场景下，在用户的多个终端和服务端之间，需要保持尽可能的最终一致性。为什么没法满足绝对严格的最终一致性？如下图所示，IM 的 "已读 / 未读"状态需要在用户的多个终端和服务端之间进行分布式的同步。按照分布式 CAP原理，IM 的业务场景限定了 AP 是必须满足的，所以 C 自然就是受限的了。![](Images/f470c4a03e54b1a07088f18fc5f8e1b4.png){savepage-src="https://static001.geekbang.org/resource/image/6b/c3/6bbb1c9be59fcd472efd77d89cb057c3.png"}```{=html}```状态视图示例]{.reference}```{=html}```所有的业务系统都一定会有状态，因为那就是业务的核心价值，并且这个系统只要有用户使用，用户就会产生行为，行为导致系统状态的变迁。比如，IM中用户发出的消息，用户的上下线等等都是行为引发的状态变化。但无状态服务相比有状态的服务和系统要简单很多，一个系统中不是所有的服务都有状态，只会有部分服务需要状态，我们的设计仅仅是围绕在，如何尽可能地把状态限制在系统的有限范围内，控制其复杂性的区域边界。至此，关于软件系统设计，我感觉通用的维度与视图就这些，但每个具体的系统可能也还有其独特的维度，也会有自己独有的视图。用更系统化的视图去观察和思考，想必也会让你得到更成体系化的系统设计。以上就是我关于系统设计的一些通用维度与视图的思考，那么你平时都用怎样的方式来表达程序系统设计呢？![](Images/a1e61bd5d0a80da9fdfd53ba1e12f2e4.png){savepage-src="https://static001.geekbang.org/resource/image/45/b8/456def9c2e16edaec6543cfa03376cb8.jpg"}
# 08 \| 代码与分类：工业级编程的代码分类与特征编程，就是写代码，那么在真实的行业项目中你编写的这些代码可以如何分类呢？回顾我曾经写过的各种系统代码，按代码的作用，大概都可以分为如下三类：-   功能-   控制-   运维如果你想提高编程水平，写出优雅的代码，那么就必须要清晰地认识清楚这三类代码。
## 一、功能功能代码，是实现需求的业务逻辑代码，反映真实业务场景，包含大量领域知识。一个程序软件系统，拥有完备的功能性代码仅是基本要求。因为业务逻辑的复杂度决定了功能性代码的复杂度，所以要把功能代码写好，最难的不是编码本身，而是搞清楚功能背后的需求并得到正确的理解。之后的编码活动，就仅是一个"翻译"工作了：把需求"翻译"为代码。当然，"翻译" 也有自己独有的技术和积累，并不简单。而且 "翻译"的第一步要求是"忠于原文"，也即真正地理解并满足用户的原始需求。可这个第一步的要求实现起来就很困难。为什么搞清楚用户需求很困难？因为从用户心里想要的，到他最后得到的之间有一条长长的链条，如下所示：> 用户心理诉求 -\> 用户表达需求 -\> 产品定义需求 -\> 开发实现 -\>> 测试验证 -\> 上线发布 -\> 用户验收需求信息源自用户的内心，然后通过表达显性地在这个链条上传递，最终固化成了代码，以程序系统的形态反馈给了用户。``{=html}但信息在这个链条中的每个环节都可能会出现偏差与丢失，即使最终整个链条上的各个角色都貌似达成了一致，完成了系统开发、测试和发布，但最终也可能发现用户的心理诉求要么表达错了，要么被理解错了。因为我近些年一直在做即时通讯产品（IM），所以在这儿我就以微信这样一个国民级的大家都熟悉的即时通讯产品为样本，举个例子。微信里有个功能叫：消息删除。你该如何理解这个功能背后的用户心理诉求呢？用户进行删除操作的期待和反馈又是什么呢？从用户发消息的角度，我理解其删除消息可能的诉求有如下几种：1.  消息发错了，不想对方收到。2.  消息发了后，不想留下发过的痕迹，但期望对方收到。3.  消息已发了，对于已经收到的用户就算了，未收到的最好就别收到了，控制其传播范围。对于第一点，微信提供了两分钟内撤回的功能；而第二点，微信提供的删除功能正好满足；第三点，微信并没有满足。我觉着第三点其实是一个伪需求，它其实是第一点不能被满足情况下用户的一种妥协。用户经常会把他们的需要，表达成对你的行为的要求，也就是说不真正告诉你要什么，而是告诉你要做什么。所以你才需要对被要求开发的功能进行更深入的思考。有时，即使是日常高频使用的产品背后的需求，你也未必能很好地理解清楚，而更多的业务系统其实离你的生活更远，努力去理解业务及其背后用户的真实需求，才是写好功能代码的基本能力。程序存在的意义就在于实现功能，满足需求。而一直以来我们习惯于把完成客户需求作为程序开发的主要任务，当功能实现了便感觉已经完成了开发，但这仅仅是第一步。