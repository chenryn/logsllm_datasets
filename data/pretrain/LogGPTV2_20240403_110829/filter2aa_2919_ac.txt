OpenJPEG, which have heavily been tested by the state-of-the-art fuzzer, OSSFuzz, on 
Google’s distributed fuzzing infrastructure.” [26] 
An approach related to symbolic and concolic execution is taint-based fuzzing. With this 
technique, input data is tainted and the taint status is propagated during execution. Because 
of this propagation, the fuzzer can query which checks depend on which input bytes to focus 
fuzzing these bytes or to eliminate checks. In 2012 such a taint based fuzzing approach was 
proposed [34] by Bekrar et al., employees at VUPEN. VUPEN is the predecessor company 
of the well-known exploit broker Zerodium and won the first prizes in Pwn2Own in 2011, 
2012, 2013 and 2014. In 2015 VUPEN did not participate in Pwn2Own because it’s 
successor company Zerodium was founded. Clients of VUPEN’s exploit service subscription 
were among others the NSA 28, the German BSI 29 and hacking team 30. In 2017 the idea of 
fuzzing supported by dynamic taint analysis was researched again by Rawat et al. in VUzzer 
[35], an application-aware evolutionary fuzzer. 
LibFuzzer 31 is another frequently used fuzzer, especially by developers. It is an in-process, 
coverage-guided, evolutionary fuzzer shipped with the clang compiler. It requires the 
development of small fuzzer functions, but it stands out with its huge fuzzing speed which 
can be achieved because of the in-process fuzzer design. Major projects like the v8 
28 https://www.darkreading.com/risk-management/nsa-contracted-with-zero-day-vendor-vupen/d/d-id/1111564? 
29 https://www.spiegel.de/spiegel/vorab/bnd-will-informationen-ueber-software-sicherheitsluecken-einkaufen-a-
1001771.html 
30 https://tsyrklevich.net/2015/07/22/hacking-team-0day-market/ 
31 http://llvm.org/docs/LibFuzzer.html 
18 
JavaScript engine or Chromium are shipped with hundreds of such fuzzer scripts 32 33 
developed for LibFuzzer.  
Further work in the field of improving fuzzing performance was done by Xu et al. [36] by 
shortening the time of each fuzzing iteration. For this, three new primitives in the operating 
system kernel were developed and integrated to AFL and LibFuzzer. 
With respect to web browsers, feedback-based fuzzing is in most cases not efficient and 
further researcher is required. Feedback-based fuzzing is mainly used to fuzz binary 
protocols and formats which can achieve a high execution speed of several hundred or 
thousand executions per second. 
Browser fuzzing on the other hand is typically implemented by using large test cases with 
execution times of several seconds per test case. Fratric from Google Project Zero 
experimented with feedback mechanisms applied to browser fuzzing in 2017 and concluded: 
"[...] more investigation is required in order to combine coverage information with DOM 
fuzzing in a meaningful way" [37]. Feedback based fuzzing is typically mainly used to fuzz 
specific function implementations or the handling of image, video or audio file formats in 
browsers, mainly with LibFuzzer. 
Another fuzzing technique is generation-based fuzzing. With this technique code is 
generated based on pre-defined rules. This is often achieved with gramma-based fuzzers 
where a gramma defines how input should be generated. An example of such a fuzzer is 
domato 34, which already found a huge amount of browser vulnerabilities over the last years. 
Another such fuzzer is grammarinator [38], developed by Hodován et al., which has 
capabilities for input generation as well as input mutation. The Mozilla Firefox security team 
developed the Dharma fuzzer 35, which is a grammar-based fuzzer similar to Domato. Most 
notable is especially the newer Domino 36 fuzzer, which was developed over three years by 
the Firefox fuzzing team. The basic idea of this fuzzer is to use WebIDL definition files as 
grammar. WebIDL is internally used in the source code of browsers to describe implemented 
APIs and is therefore the most complete and up-to-date available grammar.  
Groß proposed in 2018 new research by fuzzing JavaScript engines with feedback-based 
mutations using the fuzzilli fuzzer [39]. For this, Groß created an IL on which mutations are 
performed to ensure that only valid JavaScript code is created. 
Han et al. published [40] in 2019 a technique named semantic-aware code generation 
together with the Code Alchemist 37 fuzzer. With this technique JavaScript code samples are 
split into small code bricks which are then recombined by the fuzzer to generate semantically 
32 https://github.com/v8/v8/tree/master/test/fuzzer 
33 https://github.com/chromium/chromium/tree/master/testing/libfuzzer/fuzzers 
34 https://github.com/googleprojectzero/domato 
35 https://github.com/MozillaSecurity/dharma 
36 https://hacks.mozilla.org/2020/04/fuzzing-with-webidl/ 
37 https://github.com/SoftSec-KAIST/CodeAlchemist 
19 
correct code samples. A similar idea is implemented in this thesis. However, coverage 
feedback is used to generate a corpus of code snippets. 
Park et al. proposed [10] in 2020 a technique which uses aspect-preserving mutations to 
fuzz JavaScript engines. This approach resulted in the discovery of 48 bugs in ChakraCore, 
JavaScriptCore and V8. The paper was published after most experiments for this thesis were 
already performed and it contains similar ideas as presented in this work. The authors used 
similar sources to create an initial corpus, used coverage feedback during fuzzing and 
implemented aspect-preserving mutations. Aspect-preserving in this context means that the 
structure or type semantics are not modified during mutations which help to identify 
variations of previous vulnerabilities. While the goals of Park et al. and the goals of this thesis 
are the same, the used methods to achieve them are different. Park et al. used carefully 
designed mutation strategies to not change the structure or types of variables in a test case.  
In this thesis, another approach is used. A template corpus is used to test different code 
structures as explained in chapter 5.2.2. To preserve type information, type feedback is 
extracted, see chapter 5.2.3. 
Sanitizers are an important concept in fuzzing. Some vulnerabilities do not necessarily lead 
to a crash when they occur and can therefore not easily be detected during fuzzing. This 
problem was partially solved by AFL by introducing a custom heap implementation named 
libDisclocator 38. New compilers, such as LLVM, ship sanitizers which add code during 
compilation to detect more vulnerabilities. The most important sanitizer is ASAN (address 
sanitizer) [41] which detects a wide variety of vulnerabilities. Other important sanitizers are 
MSAN (memory sanitizer) [42] and UBSAN (undefined-behavior sanitizer) 39.  
Google Chrome and Mozilla Firefox ship pre-build ASAN builds for their current releases 40 
41 to support researchers. The Tor browser was even shipped as a hardened version 42 as 
an ASAN build. Moreover, fine-grained ASLR was integrated in the hardened version with 
SelfRando [43]. The hardened project was discontinued in 2017 43. 
Google regularly fuzzes ASAN, MSAN and UBSAN Chrome builds using their ClusterFuzz 
infrastructure. In 2016 they used 500 VMs with ASAN, 100 VMs with MSAN and 100 VMs 
with UBSAN resulting in the identification of 112 new bugs in 30 days. In these 30 days 
14,366,371,459,772 unique test inputs were created and tested. [44] 
During the last years Google spent huge computation resources on fuzzing their software 
and open source projects. The following cites underline this: 
38 http://lcamtuf.coredump.cx/afl/releases/afl-latest.tgz 
39 https://clang.llvm.org/docs/UndefinedBehaviorSanitizer.html 
40 https://commondatastorage.googleapis.com/chromium-browser-asan/index.html 
41 https://developer.mozilla.org/en-US/docs/Mozilla/Testing/ASan_Nightly_Project 
42 https://blog.torproject.org/tor-browser-55a4-hardened-released 
43 https://blog.torproject.org/discontinuing-hardened-tor-browser-series 
20 
• 
“Using these techniques and large amounts of compute power, we’ve found hundreds of 
bugs in our own code, including Chrome components such as WebKit and the PDF 
viewer. We recently decided to apply the same techniques to fuzz Adobe’s Flash Player, 
which we include with Chrome in partnership with Adobe. [..] Turns out we have a large 
index of the web, so we cranked through 20 terabytes of SWF file downloads followed 
by 1 week of run time on 2,000 CPU cores to calculate the minimal set of about 20,000 
files. Finally, those same 2,000 cores plus 3 more weeks of runtime were put to good 
work mutating the files in the minimal set (bitflipping, etc.) and generating crash cases.” 
[45] 
• 
In another blogpost from 2017 Google Project Zero fuzzed browsers and published their 
results: "We tested 5 browsers with the highest market share: Google Chrome, Mozilla 
Firefox, Internet Explorer, Microsoft Edge and Apple Safari. We gave each browser 
approximately 100,000,000 iterations with the fuzzer and recorded the crashes. […] 
Running this number of iterations would take too long on a single machine and thus 
requires fuzzing at scale, but it is still well within the pay range of a determined attacker." 
[37] This experiment lead to the discovery of 17 Safari, six Edge, four Internet Explorer, 
four Firefox and two Chrome vulnerabilities. [37] 
• 
In 2016 Serebryany [46] mentioned that several teams at Google work on hundreds of 
fuzzers which run on over 5,000 CPU cores and fuzz 24 hours and 7 days a week. This 
resulted in the identification of over 5,000 bugs in Google Chromium. 
• 
In a browser research study [4] conducted in 2017, Google revealed their internal fuzzing 
numbers: “The Google Chrome browser is subject to extensive continuous fuzzing by 
the Chrome Security Team. […] The object code of the Chromium project is fuzzed 
continuously with 15,000 cores” [4]. In addition to that, the Google Chrome Security 
Team selectively invites external researchers to write effective fuzzers and run them on 
their systems and reward bugs found in this process [4]. 
• 
Two years later, in 2019, the Chrome Security Team mentioned in a talk 44 that they 
use 25,000 cores to constantly fuzz Chrome code. 
• 
Google also runs the OSS-Fuzz project which uses AFL and LibFuzzer to fuzz common 
open source applications and libraries. “Five months ago, we announced OSS-Fuzz [...] 
Since then, our robot army has been working hard at fuzzing, processing 10 trillion test 
inputs a day. Thanks to the efforts of the open source community who have integrated a 
total of 47 projects, we’ve found over 1,000 bugs” [47]. Two years later, the OSS-Fuzz 
project already found by June 2020 over 20,000 bugs in 300 open source projects [48]. 
44 https://youtu.be/lv0lvJigrRw?list=PLNYkxOF6rcICgS7eFJrGDhMBwWtdTgzpx&t=432 
21 
4 Analysis of vulnerability patterns 
“The enormous complexity of v8 means it contains entirely new and unique vulnerability 
classes.” [49] 
In this chapter, recently exploited vulnerabilities are categorized to analyze the underlying 
structure of them. For the analysis, the internet has been sought for vulnerabilities with 
publicly available exploits. The discovered vulnerabilities are categorized and analyzed in 
depth. The extracted information is summarized in the generalization for variation analysis 
paragraphs. These paragraphs contain the key learnings which are used to enhance a 
current state-of-the-art fuzzer to improve its ability to find similar vulnerabilities. 
The vulnerabilities were selected based on the following criteria: 
• 
An exploit is available, exploitability was publicly demonstrated, or it is coherent that 
an exploit can be written for the vulnerability. This ensures that only exploitable 
vulnerabilities are analyzed which increases the fuzzer’s likelihood to find similar 
patterns and therefore exploitable vulnerabilities. 
• 
Vulnerabilities affecting Google Chrome were preferred because of its huge user 
base. In addition to that, vulnerabilities in Mozilla Firefox, Apple Safari and Microsoft 
Edge are considered.  
• 
Recently exploited vulnerabilities were favored but actively exploited older 
vulnerabilities were also included. As a hard limit only vulnerabilities from 2014 or 
later were considered. 
• 
Vulnerability categories are only listed if vulnerabilities in them meet the above 
criteria. Categories such as stack-based buffer overflows are therefore not discussed 
in this work. 
• 
Only vulnerabilities affecting the main browser code are considered. Vulnerabilities 
in third-party libraries are not discussed because such vulnerabilities are specific to 
these libraries. Sandbox escapes are out-of-scope of this work. 
In total 55 vulnerabilities fulfilled these criteria.  They split into 33 Chrome, 14 Firefox, four 
Safari and four Edge vulnerabilities. 
The Proof-of-Concepts (PoCs) are taken from the JS-Vuln-DB 45 project or from the 
referenced bug trackers. Comments have been added to increase the readability of the code.  
Not every implementation detail of the vulnerabilities’ root cause is discussed. Instead, the 
focus is laid on the knowledge required to enhance fuzzers and therefore on the JavaScript 
code triggering the vulnerabilities and on understanding the underlying concepts.  
The vulnerabilities in the sub-chapters are logically ordered and not ordered by date. The 
chapters are based on each other which means later explanations depend on knowledge 
obtained from previous chapters. Later categories or vulnerabilities are more complex. 
45 https://github.com/tunz/js-vuln-db 
22 
4.1 Classic vulnerabilities in the render engine 
In this chapter classic vulnerabilities in the render engine are discussed. Exploitation of such 
vulnerabilities is nowadays not so common anymore because browsers employ additional 
hardening techniques such as hardened heap allocators, like PartitionAlloc in Chrome, or 
segmented or isolated heaps, as implemented in JSC. In addition, such vulnerabilities are 
often harder to debug because the debugger must be attached to the full browser which is a 
time-consuming task. Moreover, finding such vulnerabilities with fuzzing is also slower 
because starting a complete browser with a GUI consumes more time. 
4.1.1 OOB memory access 
OOB (Out-of-bound) memory access occurs when bound checks are incorrectly 
implemented. In simple programs they often arise when strings are manually parsed. An 
example can be a loop which iterates through a string with a break condition which checks 
for a space character. If the programmer forgot to check for the null termination, the loop 
could lead to OOB access. The following examples show a similar problem. In a loop the 
root tag of an HTML element is searched which was assumed to be always the html tag. 
However, by embedding the HTML element in an SVG context, the root element is the svg 
tag which leads to OOB access in the loop. 
Examples: 
Firefox bug 1246014, CVE-2016-1960 – nsHtml5TreeBuilder memory corruption 
01: document.body.innerHTML = ''; 
02: var tmp = ''; 
03: document.getElementById('AAAA').innerHTML = tmp; 
In line 1 an img element is created with ID AAAA. The img element is wrapped inside a svg 
tag. Typically, the root element is a HTML tag. However, while parsing the fragments in line 
3, the code did not consider that the img tag can be wrapped inside a svg tag resulting in an 
OOB memory access.  
Public exploits are available at 46 and at 47 which use a bruteforce attack. An exploit for 32-
bit browsers using JIT spraying is available at 48. 
Generalization for variation analysis: 
• 
The fuzzer must have access to a grammar which defines that attributes such as 
innerHTML or functions like getElementById exist. The correct property names and 
46 https://www.exploit-db.com/exploits/42484 
47 https://github.com/offensive-security/exploitdb/blob/master/exploits/windows/remote/42484.html#L969 
48 https://github.com/rh0dev/expdev/blob/master/CVE-2017-5375_ASM.JS_JIT-Spray/CVE-2016-
1960_Firefox_44.0.2_float_pool_spray.html 
23 
functions must be accessible for every possible type. It is desired that the number of 
function arguments and their types is available in the grammar. 
• 
Wrapping HTML elements in an SVG context can lead to similar bugs. 
Firefox bug 1270381, CVE-2016-2819 – HTML5 parser memory corruption 
01: document.body.innerHTML = ''; 
02: var tmp = ' '; 
03: tmp += 'hr { }'; 
04: document.getElementById('BBBB').outerHTML = tmp; 
05: window.location.reload(); 
The vulnerability is a variation of CVE-2016-1960. Instead of an img tag a div tag is used 
and the HTML code in line 2 and 3 slightly differs. The root cause of the vulnerability is similar 
to the previous vulnerability. The different HTML code triggers the same programming flaw 
just in a different code location. 
A public exploit targeting 32-bit Firefox on Windows 10 is available at 49. 
Generalization for variation analysis: 
• 
This example demonstrates that small variations of vulnerabilities can lead to the 
discovery of new vulnerabilities. 
• 
Calling window.location.reload() can trigger vulnerabilities because a reload of 
the page leads to various heap operations. 
49 https://github.com/rh0dev/expdev/blob/master/CVE-2017-5375_ASM.JS_JIT-Spray/CVE-2016-
2819_Firefox_46.0.1_float_pool_spray.html 
24 
4.1.2 Integer overflows 
Integer overflows occur when the result of a calculation does not fit into the assigned data 
type. The value wraps, which often results in the bypass of security checks or OOB data 
access. Another common problem is the interpretation of an unsigned value as signed value 
or vice versa. 
Examples: 
Chromium issue 359802, CVE-2014-1736 – ImageData sign error 
01: var oContext2d = document.createElement("canvas").getContext("2d"); 
02: var oImageData = oContext2d.createImageData(0x10FFFFFF, 1); 
03: function addressToIndex(iAddress) { 
04:     return iAddress + (iAddress < 0x7fff0000 ? +0x80010000 : -0x7fff0000); 
05: } 
06: oImageData.data[addressToIndex(0x41414141)] = 0x42; // Writes 0x42 to [0x41414141] 
The allocation in line 2 always happens at address 0x7FFF0000 and it creates a huge pixel 
image array because of a sign error. When the length 0x10FFFFFF is stored in line 2 in an 
internal variable, no checks are performed to verify that the passed value fits into the smaller 
used data type. This results in a sign extension which leads to a negative length value. Since 
array bound checks are unsigned comparisons, the negative length value is interpreted as 
a huge positive number which effectively removes the bound check. Since the base address 
is always the same address, it leads to arbitrary read and write access as demonstrated in 
line 6. 
A full exploit for this vulnerability can be found at 50. 
Generalization for variation analysis: 
• 
To find similar vulnerabilities with a fuzzer, the fuzzer needs to know that a canvas 
element has a 2d context on which the createImageData function can be called. 
Furthermore, the fuzzer needs to know the number of arguments and that the 
returned value is an array. This requires a comprehensive grammar definition. 
• 
Values which can lead to sign errors, such as 0x10FFFFFF, should be used during 
fuzzing. 