none have reached widespread commercial adoption. In this
section, we evaluate the industry’s proposed solution, USB
Type-C Authentication [121]. Type-C Authentication (TCA)
is the ﬁrst attempt by the USB 3.0 Promoter Group and
USB-IF to address issues related to security. However, the
security properties of TCA are not yet widely understood
by the security community.2 We begin with a description of
the features and assumptions of TCA. Then, using the Type-
C Authentication revision 1.0 speciﬁcation (released on Feb
2, 2017), we formally model and verify the protocol using
ProVerif [21], demonstrate multiple attacks, and discuss other
issues within the spec. We ﬁnally evaluate TCA using ﬁndings
2At the time of writing, the only commercial products supporting TCA are
software from Siliconch [107] and a USB PD controller from Renesas [96].
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:33:49 UTC from IEEE Xplore.  Restrictions apply. 
1041
10
HostDeviceDigest Query GetDigest Certiﬁcate Read GetCertiﬁcateAuthentication Challenge ChallengeReqHeaderNonceResHeaderslot#slot#OthersCertChainHashSaltContextHashSigcertiﬁcate veriﬁcation process in cases where the certiﬁcate
chain has already been cached and veriﬁed.
Certiﬁcate Read: This operation allows the host to retrieve
a speciﬁc certiﬁcate chain using the GetCertificate
request.
Challenge: As shown in Figure 5,
this operation deﬁnes
initiates by
a challenge-response protocol where the host
sending a Challenge request. The request contains a slot
identiﬁer in the request header and a 32-byte nonce. The
response echoes the same slot identiﬁer in the response header
and contains a 32-byte SHA256 hash of the chosen certiﬁcate
chain, a 32-byte salt, a 32-byte SHA256 hash of all USB
descriptors for USB devices and all zeros for PD devices, and
a 64-byte ECDSA digital signature on the challenge message
and the response message using the corresponding private key
of the device.
3) Secure Key Storage and Processing: To protect certiﬁ-
cate private keys, a non-volatile secure enclave is needed,
shown in Figure 6. As discussed above,
this storage is
partitioned into 8 slots supporting 8 private keys. Similarly,
the certiﬁcate chain region also has 8 slots, containing the
corresponding certiﬁcate chain if there is a private key in
the associated slot. The TCA speciﬁcation does not specify
whether certiﬁcate chains should also be secured.
To support the authentication protocol, a hardware crypto-
graphic engine supporting ECDSA is also required. Presum-
ably, this should be the only component which can access
the secure storage. Other hardware components, besides the
basic MCU, may be needed for both security and performance
reasons, including TRNG and SHA256.
4) Security Policy: Following device authentication,
the
TCA speciﬁcation suggests the introduction of a policy mech-
anism for peripheral management. The speciﬁcation explains
that “Policy deﬁnes the behavior of Products. It deﬁnes the ca-
pabilities a Product advertises, its Authentication requirements,
and resource availability with respect to unauthenticated Prod-
ucts” (Page 14, Section 1.4) and “USB Type-C Authentication
allows an organization to set and enforce a Policy with regard
to acceptable Products.” (Page 11, Section 1). Unfortunately,
beyond this description a concrete deﬁnition for policy is not
provided; all implementation details are left to the OEM.
B. Formal Veriﬁcation
To discover possible vulnerabilities in the design, in this sec-
tion we formally verify the TCA protocol using ProVerif [21],
which has been applied on Signal [69] and TLS 1.3 Draft [19].
ProVerif uses the concept of channels to model an untrusted
communication environment (e.g., the Internet) where adver-
saries may attack the protocol. However, because the USB
communication channel does not provide conﬁdentiality by
default and is trusted in most cases,3 we instead model
the device ﬁrmware as our channel. This accurately models
attacks such as BadUSB [85], where the attacker is either a
malicious USB device or a non-root hub trying to spoof the
3We do not consider side-channel or hardware attacks against the USB bus.
Figure 6: USB device internal architecture with secure storage
and hardware to support Type-C Authentication.
authentication protocol. In ProVerif, we deﬁne this ﬁrmware
channel as free fw:channel.
We also need to deﬁne the security properties we wish to
prove. For example, since the private keys inside USB devices
should never be leaked, we seek to understand if attackers
can learn the key from eavesdropping or participating in the
protocol. The Type-C authentication spec clearly states (Page
11, Section 1.2) that “it permits assurance that a Product is
1) Of a particular type from a particular manufacturer with
particular characteristics
2) Owned and controlled by a particular organization”.
This means the authentication protocol should guarantee both
the original conﬁguration and the true identity of the device.
The original conﬁguration should be the one designed by the
vendor for this product (e.g., a webcam). The true identity
combines the usage of certiﬁcate chains (tying to a particular
organization) and private keys baked into the device to provide
the ability to cryptographically verify the original conﬁgura-
tion. We abstract these security goals in ProVerif:
free slot_key:pri_key [private].
free slot_cert_chain:cert_chain.
free orig_conf:usbpd_config.
query attacker(slot_key).
query d:usbpd; event(goodAuth(d, true)) ==>
event(useConfig(d, orig_conf)).
query d:usbpd; event(goodAuth(d, true)) ==>
(event(useCert(d, slot_cert_chain)) &&
event(usePrivkey(d, slot_key))).
To simplify the abstraction, we model one private key and
the corresponding certiﬁcate chain rather than implementing
all 8 slots. We also make the following assumptions:
• We ignore the veriﬁcation process for a certiﬁcate chain,
which is critical to the security of the entire protocol but
out of the scope of the protocol.
• We assume the veriﬁcation process to be successful by
default.
Our modeling is based on the communication between the
USB host and the USB device. PD products share the same
procedure via different signaling mappings. To mimic the
caching behavior involved in the protocol, we use a “table”
in the host side, supporting reading and writing a certiﬁ-
cate chain: table cert_chain_cache(cert_chain,
digest).
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:33:49 UTC from IEEE Xplore.  Restrictions apply. 
1042
11
FirmwareCertiﬁcate ChainsPrivate Keysslot0slot1slot7slot0slot1slot7ConﬁgMCUECDSASHA256TRNGC. Results
Unsurprisingly, attackers cannot obtain the private key in-
side the USB device by protocol messages alone since none
of these messages are designed to transmit the key. However,
this protocol fails to meet
its goals; neither the original
conﬁguration nor the true identity of the device could be
guaranteed even if the authentication protocol succeeds, due
to certiﬁcate chain caching inside the USB host:
get cert_chain_cache(chain, =dig) in known_device(config)
else new_device(config).
Since the certiﬁcate chains are not secret, a malicious device
can compute the digest of the expected chain. This digest
can be sent as a response to the GetDigest request and
impersonate the legitimate device. Unless the conﬁguration of
the legitimate device is saved and compared with the current
conﬁguration by the host, a malicious device can claim any
functionality it wants. Thus, the certiﬁcate chain cache is
vulnerable to spooﬁng attacks.
We then remove the certiﬁcate chain cache from the host,
forcing every device to go through a complete certiﬁcate
request. Again, the private key is secure. Unfortunately, the
authentication can still be spoofed as shown in this attacking
trace:
attacker(sign((non_1883,hash(chain_1877),sal_d_1881,
config_d_1879),prik_1876)).
To exploit this vulnerability, the attacker hardcodes a certiﬁcate
chain and a private key in the ﬁrmware rather than using the
ones in the slot and modiﬁes the original conﬁguration (e.g.,
by adding a malicious HID functionality). This means that
without ﬁrmware veriﬁcation to prevent BadUSB attacks,
these also allow circumventing the TCA protocol, rendering
it useless for its stated goals.
To demonstrate how ﬁrmware veriﬁcation corrects this
issue, we then assume ﬁrmware is trusted (e.g., signed by
the vendor and veriﬁed by the MCU before ﬂashing). We
model this in ProVerif by marking the ﬁrmware channel as
private: free fw:channel [private]. We assume that
valid, legitimate ﬁrmware will use the certiﬁcate chains and
private keys inside the slots during authentication and that the
original conﬁguration of the device does not contain malicious
functionality.
Using this model, ProVerif conﬁrms that successful authen-
tication guarantees both the original conﬁguration and the true
identity of the device:
RESULT event(goodAuth(d,true)) ==>
(event(useCert(d,slot_cert_chain[])) &&
event(usePrivkey(d,slot_key[]))) is true.
RESULT event(goodAuth(d_2076,true)) ==>
event(useConfig(d_2076,orig_conf[])) is true.
RESULT not attacker(slot_key[]) is true.
These results show that correct authentication using the
TCA protocol is possible only when the ﬁrmware is veriﬁed.
D. Other Issues
speciﬁcation uncovered other serious and systemic design
ﬂaws. These ﬂaws reﬂect both a lack of understanding of
secure protocol design and a lack of awareness to the present
state of threats to peripheral devices. Responsibility for solving
the most difﬁcult security challenges raised by Type-C, such
as a USB Certiﬁcate Authority system or a rich language
for expressing security policies, is delegated wholesale to the
OEMs. As a result, we are left to conclude that Type-C is
based on an intrinsically broken design. Below, we catalog
these issues:
1) No Binding for Identiﬁcation with Functionality: In
addition to the VID, PID, and serial number of the device,
a device’s leaf certiﬁcate also carries Additional Certiﬁcate
Data (ACD). ACD contains physical characteristics of PD
products (e.g., peak current and voltage regulation) but no
functionality (interface) information for other USB prod-
ucts.4 One explanation is that the protocol was designed to
address low-quality Type-C cables that were damaging host
machines [18] but was later extended to support other USB
products. For PD, the speciﬁcation clearly states that it does
not consider alternative modes. As a result, a successful
authentication does not specify the device’s original con-
ﬁguration (e.g., storage device, keyboard, normal charging
cable).
2) Volatile Context Hash: As shown in Figure 5, the chal-
lenge response contains the context hash, which is all zeros
for PD products but a SHA256 hash of all descriptors for
USB products. This seems intended to solve the function-
ality binding issue for USB products mentioned above but
is broken when the ﬁrmware is not trusted. However, the
ﬁrmware can provide its own set of USB descriptors and
feed them into the hardware ECDSA signing module to
generate the challenge response, as shown in Figure 6. As
a result, BadUSB attacks are still possible.
3) Unidirectional Authentication: For PD products, either
a PD sink or a PD source can initiate an authentication
challenge. The authentication between PD devices is thus
mutual. However, the TCA speciﬁcation only allows USB
host controllers to initiate an authentication challenge for
USB devices. This is unfortunate, as our survey of defen-
sive solutions demonstrates that host authentication is an
essential feature for device self-protection. As a result, the
TCA speciﬁcation does not provide a way for smart devices
such as mobile phones to make informed trust decisions.
4) Nebulous Policy Component: Following device authen-
tication, the TCA speciﬁcation calls for the creation of a
security policy to handle different connected products, but
does not adequately describe what a policy is or how to
create one. The speciﬁcation does not deﬁne the security
policy language, encoding, installation method, or how it
interacts with the USB host controller. Policies are only
described anecdotally, indicating a lack of forethought as
to how TCA policy can appreciably enhance security.
While our formal veriﬁcation of the authentication protocol
uncovered major ﬂaws, our manual analysis of the TCA
4 Note that using a self-signed root certiﬁcate from the vendor itself may
not solve the problem, especially when the vendor is not trusted.
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:33:49 UTC from IEEE Xplore.  Restrictions apply. 
1043
12
Finding
F1. Trust by Default
F2. Attacks Transcend Layers
F3. Trust Anchors As Design Tradeoff
F4. Single-Layer Solutions Are Not Effective
F5. Defenses for Signal Injection Are Missing
TCA Strength
CA model & Certiﬁcates
N/A
Private keys
N/A
Charging proﬁles
TCA Weakness
1. Certiﬁcate chain cache; 2. Firmware implementation; 3. No support for legacy devices
1. Dependence on nebulous “Policy”
1. Unidirectional authentication; 2. Key protection requirement; 3. No revocation
1. Dependence on nebulous “Policy”
1. No binding for identiﬁcation with functionality; 2. Volatile context hash
Table IV: TCA evaluation using ﬁndings based on our systematization – While TCA has successfully pinpointed some urgent
needs to solve the USB security problem, the design ﬂaws and limitations render its goals in vain.
5) Impractical Key Protection Requirement: The private
keys in the slots are the most important property a prod-
uct needs to protect besides the ﬁrmware. Although the
speciﬁcation does not detail how to secure private keys, it
does list more than 10 attacks a product needs to defend
against from leaking keys, including side-channel attacks,
power analysis, micro-probing, etc. It is unlikely that a $10
USB product [96] could stop advanced invasive attacks,
e.g., using Focused Ion Beam (Appendix C, TCA Spec),
which makes certiﬁcate revocation critical when a private
key is leaked.
6) No Revocation: The speciﬁcation states that the validity
time of a product certiﬁcate is ignored, suggesting that once
the certiﬁcate is loaded onto the device, there is no way to
revoke it. The use of certiﬁcate chain caching to accelerate
the authentication process is also based on the fact that all
certiﬁcates along a chain stay legitimate forever once the
chain is veriﬁed.
7) No Support for Legacy Products: With the help of
converters, Type-C can be fully compatible with legacy
USB devices, and leaves it to the end user to set a security
policy that blacklists devices that cannot participate in the
authentication protocol. As breaking backwards compat-
ibility is in direct conﬂict with the USB’s core design
principle of universality, very few organizations will elect
to set such a policy. As a result, TCA is likely to be trivially
bypassed by applying a converter to a Type-C device.
We map TCA as a new defense primitive against all attack
primitives in Table III, which shows the limitation of TCA
as a complete USB security solution. Not surprisingly, TCA
works best for signal injection attacks since it was designed
to solve the problem of low-quality charging cables. All other
limited defense effects are the results of trusting the identity
and the ﬁrmware once the device passes the authentication
protocols, and assuming some security policies deployed on
the host machines using the identity of the device.
We then evaluate TCA using all the ﬁndings based on our
systematization, as shown in Table IV. One one hand, TCA
is aware of some urgent issues in USB security, taking initial