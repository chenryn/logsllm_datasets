### Workflow Integration Alleviates Identity and Access Management in Serverless Computing

**ACSAC 2020, December 7–11, 2020, Austin, USA**

#### 6.3.2 Conditional Policy Evaluation

All internal function requests are directed to the conditional policy evaluation routine. This routine trivially accepts all absolute function requests, as their access permissions have already been verified during the mandatory policy evaluation. However, for functions listed in the conditional permission look-up table \( T \), this routine determines whether the workflow should continue or not. It checks if the required permissions \( C \) for the target function \( f \) are satisfied in the set of granted permissions \( P \). Requests with unsatisfied permissions are aborted, while accepted requests are forwarded to the gateway for routing to the correct function instance.

#### 6.4 Request Handler

In serverless platforms, a small web server (i.e., a request handler) runs inside the function container, which accepts function invocation requests. The request handler parses the incoming request object and initiates the function execution. will.iam extends the design of this request handler to remove the in-band headers used by will.iam before passing the request to the function. This ensures that will.iam is completely transparent to the function implementation and can be easily deployed on existing platforms without any modifications. Additionally, the request handler runs a reverse proxy for communication with other functions in the workflow. This reverse proxy adjusts the in-band will.iam-specific headers in outgoing requests and then redirects them to the policy evaluation service to verify conditional violations.

#### 7 Implementation

We integrated will.iam into the OpenFaaS serverless framework. OpenFaaS can be deployed on multiple container orchestration platforms, but for this paper, we deployed it on Kubernetes. We primarily modified two components of OpenFaaS: the "gateway" and "of-watchdog," adding approximately 400 lines of Go code.

- **Gateway**: The gateway is exposed to the public internet and accepts incoming requests to functions. We added an extra HTTP middleware to modify the body of incoming requests. This middleware exchanges the token specified in the "Authorization" header for a policy. The gateway uses the policy name and policy graph to build a list of data permissions granted to the request. It also uses the target function name, specified in the URI path, and the Protection State graph to determine the absolute and conditional data permissions required. If there is an element in the set of absolute permissions that is not in the request’s permission set, the gateway rejects the incoming request with an unauthorized error. If there are conditional violations, the gateway encodes the allowed data permissions for the request into a serialized in-band header and transmits them to the target function.

- **Of-Watchdog**: The of-watchdog server is only reachable from within the OpenFaaS cluster. It handles receiving incoming requests from the gateway and passing them to the function. We added extra HTTP middleware to remove the in-band header containing the encoded access control logic from the gateway. We also modified the watchdog to launch a reverse proxy server bound to a port within the cloud function’s container. When the HTTP middleware removes the in-band header from the request, it stores it in a map for later lookup. The reverse proxy retrieves the in-band header associated with a request and adds it back before sending the request to the gateway as an intra-function request.

- **Configuration**: The access control policy writer must provide a JSON configuration file that includes information about each function and policy in the access control model. An example configuration file is shown in Figure 4.

#### 8 Evaluation

We evaluated our access control system using Hello, Retail! [88], a serverless application developed by Nordstrom Technology as a proof-of-concept for event-driven computing in the retail industry. Hello, Retail! has been used in many past studies of serverless computing [80], including access control research [36, 47, 59].

We compared the performance of will.iam against two state-of-the-art serverless information flow control systems: Trapeze [36] and Valve [47]. Trapeze is a language-based approach that traces information flow at the language level, while Valve is a system-based approach that, like will.iam, mediates events at the function level. We used the modified version of the application from Alpernas et al. [36], which replaces AWS-specific components with open-source components deployable on Kubernetes and OpenFaaS. This provided a consistent baseline for comparison.

All experiments were performed on a server-class machine with an Intel(R) Xeon(R) CPU E5-2683v4 running at 2.10GHz and 135 GB of RAM. The containerization and orchestration software used was Docker 19.03.11 and Kubernetes 1.18.3. For testing, the Kubernetes cluster was configured as a single node cluster, and all Docker images were pre-pulled to minimize external networking variations.

- **8.1 Build Time Performance**: The build time and build size overheads, averaged across 30 invocations of each function, are shown in Figures 5 and 6. These figures indicate that will.iam imposes very little overhead at build time compared to Vanilla OpenFaaS and substantially outperforms both Trapeze and Valve. The slightly increased container size over Vanilla is due to the additional Go code compiled into the of-watchdog binary for every function container. In contrast, Trapeze and Valve require copying many additional files into the container image, leading to significantly larger build sizes and longer build times.

- **8.2 Orchestration Performance**: Orchestration refers to platform management tasks, specifically the deployment and teardown of containers as functions are requested to be invoked. Overheads for deployment and teardown, averaged across 30 invocations of each function, are shown in Figures 7 and 8. We did not observe any meaningful differences between the benchmarked systems, which aligns with our expectations, as the overhead is dominated by the orchestration system's performance rather than the specific containers being handled.

- **8.3 Runtime Workflow Performance**: We compared the performance of will.iam to Vanilla OpenFaaS and Trapeze using three end-to-end Hello, Retail! workflows. We measured the end-to-end latency of a request for three representative workflows: Catalog Builder, Catalog API, and Product Purchase. Results, shown in Figure 9, are averaged over 1000 repetitions of each workflow. Across all three workflows, we observed negligible overheads imposed by will.iam, averaging 0.51% and, in the worst case, 5.2%. This overhead is due to the searches required to determine if the request has the required permissions and the encoding and decoding of the in-band header. In contrast, Trapeze imposes significant overheads on two of the three flows, particularly in conditions with many datastore read operations.

- **Proactive Authorization**: The above experiments assumed all operations in the workflow were authorized. To demonstrate the performance benefits of will.iam's proactive authorization, we measured the latency of 100 concurrent requests with increasing proportions of unauthorized ("bad") traffic. Results, shown in Figure 10, indicate that will.iam greatly outperforms other systems as the proportion of bad requests increases. This is due to will.iam's ability to preemptively reject requests with absolute violations at the gateway, preventing partial processing and subsequent rejection.

This comprehensive evaluation demonstrates that will.iam provides robust and efficient access control in serverless environments, with minimal overhead and significant performance advantages over existing systems.