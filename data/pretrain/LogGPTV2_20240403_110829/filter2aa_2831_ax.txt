class, 
you 
would 
use
m_xMyClass.AddRef(). If you didn't want to use the MFC macros,
you could just type in the required definitions. 
Adding Code for the Nested Classes
We will put the implementation of this class in the source
file MfcClient.cpp. The standard AppWizard application code is
already created, so we're going to add a nested class defined in
the BEGIN_INTERFACE_PART macro. This is a fairly basic class,
other than the nested definition. Here is the top portion of this
file.
BEGIN_INTERFACE_MAP( CMyCallback, CCmdTarget )
INTERFACE_PART(CMyCallback, IID_ICallBack, MyEvents)
END_INTERFACE_MAP()
The macros above are implementing an MFC interface map.
This code ties in with the DECLARE_INTERFACE_MAP macro in
the header. An interface map is a MFC/OLE concept. It is quite
similar to a standard MFC message map, which reads and pro-
cesses Windows messages. The interface map takes care of a lot
of the plumbing of a COM object in MFC. This includes reference
counting with AddRef() and Release(), as well as handling COM
aggregation. This is all functionality that is handled automatically
by ATL. Since we aren't using ATL in this client, we have to
implement things in the MFC/OLE way.
Let's continue with the class implementation. Here's the
standardized part of the CPP implementation. 
// Standard COM interfaces -- implemented 
// in nested class XClientSink
STDMETHODIMP_(ULONG) CMyCallback::XMyEvents::AddRef()
{
274    Chapter 16 •
Other Topics 
METHOD_PROLOGUE_EX(CMyCallback, MyEvents)
return (ULONG)pThis->ExternalAddRef();
} 
STDMETHODIMP_(ULONG) CMyCallback::XMyEvents::Release()
{
METHOD_PROLOGUE_EX(CMyCallback, MyEvents)
return (ULONG)pThis->ExternalRelease();
}
STDMETHODIMP CMyCallback::XMyEvents::QueryInterface(
REFIID iid, LPVOID far* ppvObj)
{
METHOD_PROLOGUE_EX(CMyCallback, MyEvents)
return (HRESULT)pThis->ExternalQueryInterface(
&iid, ppvObj);
} 
One unfamiliar part of this code may be the use of the
METHOD_PROLOGUE_EX macro. This macro automatically gets
the this pointer from the outside class. This is possible because
the nested class and its outside class are declared as 'friends'.
The METHOD_PROLOGUE_EX macro creates an outside pointer
named pThis. (The outside class is CMfcClient).
We use the pThis pointer to delegate the AddRef(),
Release(), and QueryInterface functions to the outside CMfcCli-
ent class, which knows how to handle them. These functions are
implemented in the base class CCmdTarget. 
All of what has preceded this point is boilerplate COM code.
The only 'custom' aspect of this code is the names of the classes.
Finally, we're going to add our one-and-only custom method.
// Pop up a message box to announce callback
STDMETHODIMP CMyCallback::XMyEvents::Awake(long lVal)
{
    CString msg;
    msg.Format( "Message %d Received\n", lVal);
    AfxMessageBox( msg );
    return S_OK;
}
This code is self-explanatory. It displays a message box.
Building a COM Object with MFC
275
Additonal Information and Updates: http://www.iftech.com/dcom
Accessing the Nested Class
The syntax of accessing the nested class is somewhat
unusual. We'll assume you are accessing an instance of the CCm-
dTarget class called pMyClass. In this example, we'll extract an
ICallBack object from the class.
ICallBack *pC;
hr = pMyClass->m_xMyEvents.QueryInterface(
IID_ICallBack, (void**)&pC);
if (SUCCEEDED(hr))
{
pC->Awake( 1 );
pC->Release();
}
We have presented this example to show that there are
other ways besides ATL to implement COM. Working with MFC
COM is a whole different experience from using ATL. There are
numerous books on OLE and MFC that cover this area in minute
detail - now that you understand the fundamentals of COM,
these books become much easier to comprehend!
276    Chapter 16 •
Other Topics 
A
P
P
E
N
D
I
X
Appendix
COM Error 
Handling   
Much of the frustration of using COM arises when things don’t
work. You create a COM server and its client, run the client but
the server never activates. Solving this type of problem can be a
time-consuming, maddening activity. This appendix  is dedicated
to the discovery and elimination of bugs that prevent a COM cli-
ent from finding and starting a COM server, as well as other bugs
that gum up the works between a client and a server.  
One of the hardest parts about working with COM is dealing
with errors.  The debugging cycle with COM programs is more
complex then with standard C++ programs. There are a number
of reasons for this. 
First, much COM error checking is done at run-time. Using
the wizards, it's relatively easy to build a client and server appli-
cation. Everything looks fine, until you run it. A COM program is
really a complex combination of different programs, the registry,
and operating system components. Any of these parts can go
wrong, and they do.
Secondly, when you get COM error messages, they often
aren't very specific about the problem. Perhaps the worst exam-
ple of this is the RPC_S_SERVER_UNAVAILABLE error that you
commonly get when working across networks. Even at their
best, HRESULT's offer pretty meager information about the prob-
278    Appendix •
COM Error Handling 
lem. The context of an error can be extremely important in inter-
preting its cause.
Also, a huge part of the COM system is hidden from the pro-
grammer. The COM subsystem is responsible for server location
and activation. As an application developer, we hope and pray
that all the elements of this connection are correct.
Security just makes matters more difficult. COM is designed
to provide inter-process and inter-network connections. Unfortu-
nately, these avenues of communication are highly subject to
break-ins. This means that the security layers of the network and
operating system are going to insist that access is legitimate.
Another characteristic of security subsystems is that they don't
give very informative error diagnostics. When a connection fails,
the security subsystem probably won't tell you why - to do so
would be a security breach.
Finally, we've got to admit that the COM environment is
quirky and prone to bugs. Only a few people really understand
this complex system enough to diagnose tough problems. When
you're just starting with COM, you probably don't have access to
these people.
Fortunately, COM is getting easier. Microsoft is exerting con-
siderable effort in on making COM more usable. Each new
Developer Studio product has better integration. Also the advent
of tools like ATL have made a big difference. As COM grows in
prevalence (if not always popularity), there's more information
available.
Sources of Information
The primary source for information about COM is the MSDN
library. There is quite a lot of COM related material on these
CD's, but it is poorly organized and sometimes not clearly writ-
ten. Nevertheless, the MSDN Libraries are a must-have for serious
Visual C++ and COM developers. If you don't get the CD's, the
online resources at Microsoft’s web site are quite useful as a fall-
back.
Common Error Messages
279
Additonal Information and Updates: http://www.iftech.com/dcom
There are several good COM FAQ's available on the Inter-
net. Searching these archives can give help with commonly
encountered problems. One example is the "FAQ: COM Security
Frequently Asked Questions", Article ID: Q158508
There is also a DCOM list server resource, which archives
COM-related mailing lists. If you subscribe to the mailing lists,
you'll never have to worry about an empty inbox. The archive
holds a huge volume of material about COM. You'll find posts by
some of the experts in the COM world, including COM develop-
ers. You'll also find thousands of questions about topics that are
irrelevant to your application. 
Here are two of these resources:
http://discuss.microsoft.com/archives/atl.html 
http://discuss.microsoft.com/archives/dcom.html. 
Reading the messages on the list server will also give you
some idea about the desperation of COM developers who are
debugging problems. You should spend some time searching
these archives before posting questions. Almost all the questions
have been asked, and answered several times before.
Common Error Messages
In the following section we're going to look at some of the more
common errors you will encounter when working with COM.
I've encountered most of these, usually when working with
remote servers.  
These errors are arranged in alphabetical order.
Error
Decimal
Hex
CO_E_BAD_SERVER_NAME
-2147467244
80004014
CO_E_CANT_REMOTE
-2147467245
80004013
CO_E_NOTINITIALIZED
-2147221008
800401f0
CO_E_SERVER_EXEC_FAILURE
-2146959355
80080005
E_ACCESSDENIED
-2147024891
80070005
E_FAIL
-2147467259
80004005
280    Appendix •
COM Error Handling 
CO_E_BAD_SERVER_NAME • A Remote activation was necessary
but the server name provided was invalid.
This is one of the few self-explanatory error messages. Note
that this doesn't mean you entered the wrong server name.
Unrecognized 
servers 
show 
up 
with 
the
RPC_S_SERVER_UNAVAILABLE error.
• Check the server name for invalid characters.
• Check the parameters to the COSERVERINFO structure.
CO_E_CANT_REMOTE • A Remote activation was necessary but
was not allowed.
This is an uncommon problem. You are trying to improperly
start a server.
• Check the CLSCTX in CoCreateInstance. Be sure it
matches the type of server.
CO_E_NOTINITIALIZED •  CoInitialize has not been called.
This is an easy problem. You probably just forgot to call
CoInitialize. It may also indicate that you have a threading prob-
lem. CoInitialize should be called on each thread.
• Call CoInitialize or CoInitializeEx before other COM calls.
• Be sure you call CoInitialize for each thread. COM inter-
actions must be marshaled between threads.
E_NOINTERFACE
-2147467262
80004002
E_OUTOFMEMORY 
-2147483646
80000002
E_POINTER
-2147483643
80000005
ERROR_INVALID_PARAMETER
-2147024809
80070057
ERROR_SUCCESS
0
0
REGDB_E_CLASSNOTREG
-2147221164
80040154
RPC_S_SERVER_UNAVAILABLE
-2147023174
800706ba
Table A.1
Typical COM errors
Error
Decimal
Hex
Common Error Messages
281
Additonal Information and Updates: http://www.iftech.com/dcom
CO_E_SERVER_EXEC_FAILURE •  Server execution failed.
Often occurs when calling CoCreateInstanceEx.
• Set the "Remote Connect" flag to "Y" on your server. The
registry 
key 
is 
HKEY_LOCAL_MACHINE\Soft-
ware\Microsoft\Ole EnableRemoteConnect='Y'. You are
required to reboot after changing this setting.
E_ACCESSDENIED •  General access denied error.
This is an error from the security subsystem. The server sys-
tem rejected a connection. Also known as “the error from hell”
because it is often very difficult to resolve. Access Denied prob-
lems can be very difficult to diagnose. This error is most likely
encountered when using DCOM for remote connections.
• The server must already be started on remote Windows
95/98 computers. You will sometimes get this instead of
RPC_S_SERVER_UNAVAILABLE when trying to start a
remote server located on a Windos 95/98 machine. 
• Check COM security, file protection, and network access.
Check launch permissions, etc using DCOMCNFG. There
are many levels of security that can be incorrect. Be sure
the server identity is not set as "Launching User". See
Chapter 14.
• The server program may be registered, but the EXE may-
missing from or inproperly located on a remote computer.
Try re-installing and re-registering the server.
• Check File and Print Sharing for Microsoft Networks on
Windows 95. If you have Novell installed, check NetWare
File/Print Sharing.
• The server may not allow remote activation. If so, it can-
not start. Change the server.
• Check the parameters of CoInitializeSecurity. See Chapter
14.
• See if the remote server is starting. The server may be
starting, but may have a problem with call-level security.
• A server running as an NT service may be running under
"SYSTEM" or some other account that does not have per-
mission to access resources. This may mean the system
282    Appendix •
COM Error Handling 
account is trying to access network resources, such as
network disks. Launch the service with a different user
name; use the Services applet in the Control Panel.
E_FAIL •  Unspecified error.
This error doesn't tell you much. Often servers return this
code when they have a general processing failure or exception.
In our example code, we often return this code to indicate a
domain-specific problem.
• A COM method failed on the server. Check the server
implementation.
E_NOINTERFACE •  No such interface supported.
You asked a server for an interface it doesn't support. This
means your CLSID is probably ok, but the IID is not. This call is
returned by QueryInterface (or through CoCreateInstance) when
it doesn't recognize an interface. It may also be a Proxy/Stub
problem.
• Check the IID or name of the interface you requested. Be
sure you typed in the correct CLSID. Be sure the coclass
supports the interface.
• The Proxy/Server DLL for the server is not properly regis-
tered. You may have forgotten to build and register the
"ps.mk" file.
• The interface was not properly registered in the registry.
Re-register your server application. Look for the interface
with OLEVIEW. 
• You forgot the COM_INTERFACE_ENTRY in your ATL
server's header.
E_OUTOFMEMORY • Ran out of memory.
This message may be unrelated to the actual error. Uncom-
monly seen.
• DefaultAccessPermissions does not include the SID, or
security identifier, for the SYSTEM account. Use DCOMC-
Common Error Messages
283
Additonal Information and Updates: http://www.iftech.com/dcom
NFG or the OLE/COM Object Viewer to add "SYSTEM" to
the security id's in the default access permissions. 
E_POINTER • Invalid pointer.
This error indicates a general problem with pointers. You
probably passed a NULL to a method that was expecting a valid
pointer.
• You passed a null or invalid pointer in a method call.
• You passed in invalid (IUnknown*) or (void**). Did you
forget an ampersand?
• Check the ref and unique attributes in the IDL code.
ERROR_INVALID_PARAMETER • The parameter is incorrect.
You have a problem in one of the parameters to your func-
tion call. This is commonly seen in functions such as CoCreateIn-
stance, CoCreateInstanceEx, CoInitializeSecurity, etc.  
• Check for missing ampersand (&) on pointers.
• Check for missing ampersand on references, such as REF-
CLSID parameter.
• Check all parameters carefully. 
ERROR_SUCCESS • The operation completed successfully.
The same message as S_OK and NO_ERROR. This message
is a wonderful oxymoron.  
• You did everything right.
REGDB_E_CLASSNOTREG • Class not registered.
You'll get this error if you had problems registering the
server. It may also indicate in incorrect CLSID was requested.
• You called CoCreateInstance or CoGetClassObject on a
class that has no registered server. The CLSID was not rec-
ognized.
• Check the registry. See if the CLSID is registered. Look up
the CLSID under the HKEY_CLASSES_ROOT\CLSID key.
284    Appendix •
COM Error Handling 
• Try re-registering the server. Type "servername -regserver"
at the DOS prompt.
• Check the GUID's.
• Use OLEVIEW to verify that the server is properly regis-
tered.
RPC_S_SERVER_UNAVAILABLE • RPC server is unavailable.
This problem is very common when working with remote
servers. This is a generic remote connection error. RPC is the
protocol used to implement DCOM. This can be a system set-up
problem or a security problem. You're about to learn a lot about
networking!
• Test the remote connection with PING.
• Test the remote connection with TRACERT
• You may have entered an invalid server name. This may
also be a name resolution problem. If so, try using the
TCP/IP address of the server instead of the name.
• The server computer may not be running, or it may be
disconnected from the network. It may also be unreach-
able because of the network configuration.
• The RPCSS service may not be started on the remote Win-
dows NT computer.
• Be sure DCOM is configured on the server. Run DCOMC-
NFG and check all the possibilities. Check EnableRemote-
Connect and EnableDCOM.
• If you are connecting to a remote windows 95/98 system,
the server must be running. DCOM will not automatically
start a server remotely on Windows 95/98. 
• Be sure the COM server is registered on the remote com-
puter. You may get this instead of  "Class Not Registered"
when connecting to remote machines.
• Check the TCP/IP installation on both the client and
server computer.
• See if you can run the client and server locally on both
computers. It is a lot easier to debug COM problems on a
local computer. If it doesn't work locally, it probably
won't work over the network.
DCOM Errors
285
Additonal Information and Updates: http://www.iftech.com/dcom