本文主要内容有：
  * 如何查找函数调用
  * 如何查找属性使用
  * 如何进行数据流分析
  * 寻找fastjson jndi反序列化链
## Workshop 学习
这部分是学习这个codeql的[workshop](https://github.com/githubsatelliteworkshops/codeql/blob/master/java.md)的笔记。Struts
有个漏洞 [CVE-2017-9805](http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2017-9805)
，是由于用户控制的输入直接传到了`XStream.fromXML`，造成了反序列化漏洞。这个workshop主要是分析如何利用codeql数据流分析功能找到这个洞。
`Struts`有个 `contentypehandler` 的`interface` 里面有个方法是`toObject(Reader in, Object
target)`, 这个方法是用来根据用户请求的`content-type`来进行处理请求。现在已知这个`in`
是由用户完全控制的，可以算是一个`source`，另外一个已知是`com.thoughtworks.xstream.fromXML`
存在反序列化问题，可以算是一个`sink`.
所以进行数据流分析可以是从`toObject`这个`Method`的`in`
这个`Parameter`，流到`fromXML`这个`MethodAccess`的`arguement`
下面是`parameter` 和
`argument`的区别。简单的来说`parameter`是函数定义时候的变量，`argument`是调用时传进去的变量。
> A parameter is a variable in a method definition. When a method is called,
> the arguments are the data you pass into the method's parameters.
>  
>  
>     public void MyMethod(string myParam) { }
>  
>     ...
>  
>     string myArg1 = "this is my argument";
>     myClass.MyMethod(myArg1);
### Method
#### 根据Method name查询
    import java
    from Method method
    where method.hasName("toObject")
    select method
把这个方法的`class` `name`也查出来
    import java
    from Method method
    where method.hasName("toObject")
    select method, method.getDeclaringType()
点击右侧的可以看到相应的代码片段。
这里比较奇怪，为啥8，9会出现。
查看代码可以发现这是一个匿名类。看到这里感觉codeql还是比较牛逼的。
#### 根据Method name 和 class name 查询
比如我想查询`Xstream` 这个类的`fromXML` 方法。
> predicate
> [hasQualifiedName](https://help.semmle.com/qldoc/java/semmle/code/java/Type.qll/predicate.Type$RefType$hasQualifiedName.2.html)([string](https://help.semmle.com/qldoc/java/type.string.html)
> package, [string](https://help.semmle.com/qldoc/java/type.string.html) type)
    import java
    from Method method
    where method.hasName("fromXML") and method.getDeclaringType().hasQualifiedName("com.thoughtworks.xstream", "XStream")
    select method
#### 根据Method name 和 interface name 查询
比如我想查询`ContentTypeHandler` 的所有子类`toObject`方法
    import java
    from Method method
    where method.hasName("toObject") and method.getDeclaringType().getASupertype().hasQualifiedName("org.apache.struts2.rest.handler", "ContentTypeHandler")
    select method
这样会比直接根据method name查少一个结果,少的结果是`ContentTypeHanlder`他自己。
可以用`getAnAncestor()`
> Gets a direct or indirect supertype of this type, including itself.
>
>
> [RefType](https://help.semmle.com/qldoc/java/semmle/code/java/Type.qll/type.Type$RefType.html)
> [getAnAncestor](https://help.semmle.com/qldoc/java/semmle/code/java/Type.qll/predicate.Type$RefType$getAnAncestor.0.html)()
    import java
    from Method method
    where method.hasName("toObject") and method.getDeclaringType().getAnAncestor().hasQualifiedName("org.apache.struts2.rest.handler", "ContentTypeHandler")
    select method
也可以用`getDeclaringType()*` 类似的还有`getDeclaringType()+`
有个问题是，万一一个类实现了多个接口是不是也可以这么用？ 答案是是的
`getAxxxx`，如果有多个结果会以多行的形式按照一定的顺序显示出来。
比如`getAParamType`
#### 获取Method的parameter
>
> [getAParamType()](https://help.semmle.com/qldoc/java/semmle/code/java/Member.qll/predicate.Member$Callable$getAParamType.0.html)
> Gets the type of a formal parameter of this callable
>
>
> [getAParameter()](https://help.semmle.com/qldoc/java/semmle/code/java/Member.qll/predicate.Member$Callable$getAParameter.0.html)
> Gets a formal parameter of this callable
>
>
> [getNumberOfParameters()](https://help.semmle.com/qldoc/java/semmle/code/java/Member.qll/predicate.Member$Callable$getNumberOfParameters.0.html)
> Gets the number of formal parameters of this callable.
>
> [getParameter(int
> n)](https://help.semmle.com/qldoc/java/semmle/code/java/Member.qll/predicate.Member$Callable$getParameter.1.html)
> Gets the formal parameter at the specified (zero-based) position.
>
> [getParameterType(int
> n)](https://help.semmle.com/qldoc/java/semmle/code/java/Member.qll/predicate.Member$Callable$getParameterType.1.html)
> Gets the type of the formal parameter at the specified (zero-based) position
    import java
    from MethodAccess call, Method method
    where method.hasName("toObject") and method.getDeclaringType().getAnAncestor().hasQualifiedName("org.apache.struts2.rest.handler", "ContentTypeHandler") and call.getMethod() = method
    select method.getParameter(0)
### MethodAccess
一般是先查`method`，与`MethodAccess.getMethod()` 进行比较。
比如查`ContentTypeHandler` 的 `toObject()` 方法的调用。
    import java
    from MethodAccess call, Method method
    where method.hasName("toObject") and method.getDeclaringType().getASupertype().hasQualifiedName("org.apache.struts2.rest.handler", "ContentTypeHandler") and call.getMethod() = method
    select call
上面这种查询方式不行，只能查到`JsonLibHandler` 这样显式定义的。
对于这种, 真正用的并没有查到
怎么改进呢？  
也可以使用`getAnAncestor()` 或者`getASupertype()*`
    import java
    from MethodAccess call, Method method
    where method.hasName("toObject") and method.getDeclaringType().getAnAncestor().hasQualifiedName("org.apache.struts2.rest.handler", "ContentTypeHandler") and call.getMethod() = method
    select call
这种查询能够涵盖上面的两种情况
从上面可以看到`MethodAccess` 的查询依赖于`Method` 的查询。
#### 获取MethodAccess 的 argument
>
> [getATypeArgument](https://help.semmle.com/qldoc/java/semmle/code/java/Expr.qll/predicate.Expr$MethodAccess$getATypeArgument.0.html)
> Gets a type argument supplied as part of this method access, if any.  
>
> [getAnArgument](https://help.semmle.com/qldoc/java/semmle/code/java/Expr.qll/predicate.Expr$MethodAccess$getAnArgument.0.html)
> Gets an argument supplied to the method that is invoked using this method
> access.  
>  [getArgument(int
> n)](https://help.semmle.com/qldoc/java/semmle/code/java/Expr.qll/predicate.Expr$MethodAccess$getArgument.1.html)
> Gets the argument at the specified (zero-based) position in this method
> access.
>
> [getTypeArgument(int
> n)](https://help.semmle.com/qldoc/java/semmle/code/java/Expr.qll/predicate.Expr$MethodAccess$getTypeArgument.1.html)
> Gets the type argument at the specified (zero-based) position in this method
> access, if any.
    import java
    from MethodAccess call, Method method
    where method.hasName("toObject") and method.getDeclaringType().getAnAncestor().hasQualifiedName("org.apache.struts2.rest.handler", "ContentTypeHandler") and call.getMethod() = method
    select call.getArgument(0)
### dataflow
从source，到sink 有没有一条路径。
也就是从toObject的in parameter 到 fromXML的in argument 有没有一条路径。
数据流分析要继承`DataFlow::Configuration` 这个类，然后重载`isSource` 和`isSink` 方法
    class MyConfig extends DataFlow::Configuration {
      MyConfig() { this = "Myconfig" }
      override predicate isSource(DataFlow::Node source) {
        ....
        )
      }
        override predicate isSink(DataFlow::Node sink) {
        ....
        )
      }
    }
先介绍一下`exists` 的用法。
> #### `exists`
>
> This quantifier has the following syntax:
>  
>  
>     exists( | )
>
> You can also write `exists( | | )`. This is equivalent to `exists( | and )`.
>
> This quantified formula introduces some new variables. It holds if there is
> at least one set of values that the variables could take to make the formula
> in the body true.
>
> For example, `exists(int i | i instanceof OneTwoThree)` introduces a
> temporary variable of type `int` and holds if any value of that variable has
> type `OneTwoThree`.
说人话就是，`variable`满足`formula` 则返回true 否则返回false
Node 的 方法
>
> [asExpr](https://help.semmle.com/qldoc/java/semmle/code/java/dataflow/internal/DataFlowUtil.qll/predicate.DataFlowUtil$Node$asExpr.0.html)
> Gets the expression corresponding to this node, if any.  
>
> [asParameter](https://help.semmle.com/qldoc/java/semmle/code/java/dataflow/internal/DataFlowUtil.qll/predicate.DataFlowUtil$Node$asParameter.0.html)
> Gets the parameter corresponding to this node, if any.
完整的数据流分析代码如下
    import java
    import semmle.code.java.dataflow.DataFlow
    class StrutsUnsafeDeserializationConfig extends DataFlow::Configuration {
      StrutsUnsafeDeserializationConfig() { this = "StrutsUnsafeDeserializationConfig" }
      override predicate isSource(DataFlow::Node source) {