### Line 1: Overwriting the Handler with a Mutated Address

At Line 1, the handler is overwritten with a mutated address. Subsequently, the program calls `printf` to display the name on the screen. Since `printf` is an external call, A2C decodes the input buffer `name`. Specifically, in our implementation of the decoding function, when A2C decodes a buffer for a library call, it allocates a new buffer, copies the original encoded buffer, and then decodes it in the new buffer before passing it. Because A2C does not decode the original buffer, the injected malicious payload remains mutated.

### Line 3: Calling the Overwritten Handler

At Line 3, the program calls the handler. Although the handler has been overwritten, the function pointer no longer points to the injected shellcode. It is worth noting that the privilege field can also be overwritten to launch non-control data attacks [16]. A2C mitigates these attacks by encoding inputs from untrusted sources, thereby preventing the attacker from controlling the overwritten value.

### Example Code Snippet

```c
void process(RECORD* p) {
    1: fread(p->name, ...);
    2: printf("Name: %s\n", Decode(p->name));
    3: p->handler(p->privilege);
}
```

### Related Work

#### Control-Flow Integrity (CFI)
Recent advances in control-flow integrity have developed robust systems for preventing malicious or abnormal control flows within a victim program. These systems typically monitor execution to enforce predetermined control flow paths [44], [9], [66], [31], [73], [74], [72], [43], [68], [40]. In contrast, A2C provides protection by corrupting input payloads, which is a perspective orthogonal to the enforcement of a program’s legitimate control flow graph. Therefore, A2C is complementary to and can be deployed alongside CFI, e.g., to prevent exploit injection attacks that may employ indirect calls or not violate control flow integrity [24], [29], [15], [55], [54], [40], [19], [14].

#### Malicious Payloads Detection
In [67] and [37], researchers proposed analyzing inputs to detect malicious payloads with minimal runtime overhead. However, Fogla et al. [28] demonstrated that polymorphism techniques can defeat these approaches. Dynamic analysis using emulation [46], [61] has been proposed to uncover polymorphic payload injection attacks, but they cause significant performance penalties. A2C mutates all input buffers from untrusted sources, making it resilient to polymorphism. It does not require emulation and causes low overhead. Nozzle [48] proposed a novel technique to detect heap spraying attacks at runtime by using runtime interpretation and static analysis to analyze suspicious objects in the heap. While Nozzle focuses on detecting heap spraying in JavaScript, A2C takes a more general approach to prevent a wider range of input injection attacks.

#### Randomization Approaches
Address Space Layout Randomization (ASLR) is one of the most widely deployed defense mechanisms to mitigate payload injection and triggering. ASLR randomizes the memory layout of a program when the OS loads the binary and dynamic libraries. It is already a default defense mechanism in most operating systems, including Linux, macOS, BSD, and Windows. Address space layout perturbation [34] and fine-grained randomization techniques [70], [42], [7], [22], [17], [30] have been developed to provide higher entropy. Instruction set randomization [33], [47], [41] aims to change the underlying instruction set to prevent executing injected code. However, recent studies have shown that randomization can be evaded by brute-force attacks [58], [8], memory disclosure attacks [11], [57], [36], and just-in-time code reuse attacks [62]. In [23], researchers presented a novel defense technique to mitigate counterfeit object-oriented programming (COOP) attacks [54] by randomizing the layout of the code pointer table and planting booby-traps to prevent brute-force attacks. Compared to these techniques, A2C provides protection by working from the input perspective, which is complementary to randomization. Data randomization [6], [13] dynamically decrypts a buffer upon each buffer access and encrypts it again after the access. It encrypts all buffers, including those not related to inputs, and uses different keys for various buffers. A2C shares a similar idea of buffer encoding with data randomization but focuses on input-related buffers, encoding only once for each input and decoding only at the decoding frontier, resulting in relatively lower overhead. PointGuard [20] encrypts pointer values at runtime.

#### Bounds Checking
Stackguard [21] inserts a secret value (canary) before each return address and frame pointer. However, it can be defeated through information leak attacks that reveal the canary value [49], [12]. Compile-time code analysis [69], [35] has been proposed to detect unsafe array and pointer accesses, but these often generate many false positives and focus on specific kinds of vulnerabilities. Cling [4] and AddressSanitizer [56] provide pointer safety to prevent exploiting pointer-related bugs such as use-after-free. However, as shown in our case study, they can hardly handle advanced attacks [71]. In contrast, A2C aims to break the weakest link of attacks, which is the payload itself.

### Conclusion
We present A2C, which provides general protection against a wide spectrum of payload injection attacks. It mutates all input buffers from untrusted sources to break malicious payloads. To ensure the program functions correctly on legitimate inputs, it decodes them right before they are used to produce new values. A2C automatically identifies such places using a novel constraint-solving-based approach and sophisticated static analysis. Our experiments on a set of real-world programs show that A2C effectively prevents known payload injection attacks on these programs with reasonably low overhead (6.94%).

### Acknowledgment
We thank the anonymous reviewers for their constructive comments. This research was supported, in part, by DARPA under contract FA8650-15-C-7562, NSF under awards 1409668 and 0845870, ONR under contract N000141410468, and Cisco Systems under an unrestricted gift. Any opinions, findings, and conclusions in this paper are those of the authors only and do not necessarily reflect the views of our sponsors.

### References
[1] Exploits database by offensive security. https://www.exploit-db.com/.
[2] The LLVM Compiler Infrastructure. http://llvm.org/.
[3] Penetration Testing Software. Metasploit. https://www.metasploit.com/.
[4] P. Akritidis, C. Cadar, C. Raiciu, M. Costa, and M. Castro. Preventing Memory Error Exploits with WIT. In S&P’08.
...
[74] M. Zhang and R. Sekar. Control Flow Integrity for COTS Binaries. In SEC’13.