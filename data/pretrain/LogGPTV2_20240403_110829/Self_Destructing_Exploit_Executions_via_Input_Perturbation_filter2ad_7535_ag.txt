Line 1, the handler is overwritten with a mutated address.
Then, the program calls printf to display the name on
the screen. As printf is an external call, A2C decodes
the input buffer name. Speciﬁcally, in our implementation
of the decoding function, when A2C decodes a buffer for
a library call, it allocates a new buffer, copies the original
encoded buffer, and then decodes it in the new buffer before
passing it. Since A2C does not decode the original buffer,
the injected malicious payload remains mutated. At Line 3,
the program calls handler. Although it is overwritten, the
function pointer no longer points to the injected shellcode.
Note that the privilege ﬁeld can also be overwritten to
launch non-control data attacks [16]. A2C mitigates the attacks
by encoding the inputs from untrusted sources. As a result, the
attacker cannot control the overwritten value.
13
       void process_font_table (...) {         ...331:  char name[255];          ✁341:  while (w2) {342:    tmp = word_string(w2);343:    if ( tmp &&                  Decode( tmp[0] ) != '\\' ) 344:      strcat( name, tmp );convert.c(a) Injected ROP gadgets0x804d820mov ebx,0x0; ret0x804ec7dmov eax,0x806275c; ret......AddressInstructions(b) Mutated ROP gadgets0xa2ae728aInvalid address0xa2ae46d7Invalid address......AddressInstructionsEnglish Shellcode and Mutated English Shellcode push    esp push    0x20657265 ...AssemblyOpcodeASCII 54 68 65 72 65 20  ...There is a majorcenter of economic activity, ... inc      dl iret ... fe c2  cf  ...No ASCII character found      void process(RECORD* p) {1:      fread( p->name, ✁ );2:      printf("Name: %s\n",                    Decode( p->name ));3:      p->handler( p->privilege );Program.ctypedef struct tag_RECORD {    char name[255];    void (*handler)(int);     int privilege;} RECORD;Program.hVII. RELATED WORK
Control-ﬂow Integrity (CFI). Recent advances in control-
ﬂow integrity have developed very robust systems for prevent-
ing malicious/abnormal control ﬂows within a victim program.
These typically monitor execution to enforce pre-determined
control ﬂow paths [44], [9], [66], [31], [73], [74], [72], [43],
[68], [40]. In contrast, A2C provides protection by corrupting
input payloads, which is a perspective orthogonal to the en-
forcement of a program’s legitimate control ﬂow graph. There-
fore, A2C is complementary to and can be deployed alongside
CFI, e.g., to prevent exploit injection attacks that may employ
indirect calls or not violate control ﬂow integrity [24], [29],
[15], [55], [54], [40], [19], [14].
Malicious Payloads Detection. In [67] and [37], researchers
proposed analyzing inputs to detect malicious payloads with
little runtime overhead. However, Fogla at el. [28] demon-
strated that polymorphism techniques can defeat these ap-
proaches. Dynamic analysis using emulation [46], [61] have
been proposed to uncover polymorphic payload injection at-
tacks, but they cause non-negligible performance penalty. A2C
mutates all input buffers from untrusted sources and thus is
resilient to polymorphism. It does not require emulation and
causes low overhead. Nozzle [48] proposed a novel technique
to detect heap spraying attacks at runtime. It uses runtime
interpretation and static analysis to analyze suspicious objects
in the heap. While Nozzle focuses on detecting heap spraying
on JavaScript, A2C takes a more general approach to prevent
a wider range of input injection attacks.
Randomization Approaches. Address space layout random-
ization (ASLR) is one of the most widely deployed defense
mechanism to mitigate payload injection and triggering. ASLR
randomizes the memory layout of a program when the OS
loads the binary and dynamic libraries. ASLR is already a de-
fault defense mechanism in most operating systems including
Linux, MacOS, BSD, and Windows. Address space layout per-
turbation [34] and ﬁne-grained randomization techniques [70],
[42], [7], [22], [17], [30] have been developed to provide
higher entropy. Instruction set randomization [33], [47], [41]
aims to change the underlying instruction set
to prevent
executing injected code. However, it was shown recently that
randomization could be evaded by brute-force attacks [58],
[8], memory disclosure attacks [11], [57], [36], and just-in-
time code reuse attacks [62]. In [23], researchers presented a
novel defense technique to mitigate counterfeit object-oriented
programming (COOP) attacks [54]. They randomize the layout
of the code pointer table and plant booby-traps to prevent
brute-force attacks. Compared to these techniques, A2C pro-
vides protection by working from the input perspective, which
is complementary to randomization. Data randomization [6],
[13] dynamically decrypts a buffer upon each buffer access
and encrypts it again after the access. It encrypts all buffers
including those not related to inputs. It also uses different
keys for various buffers. A2C shares a similar idea of buffer
encoding with data randomization. The differences lie in that
A2C focuses on input related buffers; it encodes only once for
each input and decodes only at the decoding frontier. As such,
A2C has relatively lower overhead. PointGuard [20] encrypts
pointer values at runtime.
Bounds Checking. Stackguard [21] inserts a secret value (ca-
nary) before each return address and frame pointer. However, it
can be defeated through information leak attacks that reveal a
canary value [49], [12]. Compile-time code analysis [69], [35]
have been proposed to detect unsafe array and pointer accesses.
However, they often generate many false positives and focus
on speciﬁc kinds of vulnerabilities. Cling [4] and AddressSan-
itizer [56] provide pointer safety to prevent exploiting pointer
related bugs such as use-after-free. However, as shown in our
case study, they can hardly handle advanced attacks [71]. In
contrast, A2C aims to break the weakest link of attacks, which
is the payload itself.
VIII. CONCLUSION
We present A2C that provides general protection against a
wide spectrum of payload injection attacks. It mutates all input
buffers from untrusted sources to break malicious payloads. To
assure the program functions correctly on legitimate inputs, it
decodes them right before they are used to produce new values.
A2C automatically identiﬁes such places at which it needs to
decode using a novel constraint solving based approach and a
sophisticated static analysis. Our experiments on a set of real-
world programs show that A2C effectively prevents known
payload injection attacks on these programs with reasonably
low overhead (6.94%).
ACKNOWLEDGMENT
We thank the anonymous reviewers for their construc-
tive comments. This research was supported,
in part, by
DARPA under contract FA8650-15-C-7562, NSF under awards
1409668 and 0845870, ONR under contract N000141410468,
and Cisco Systems under an unrestricted gift. Any opinions,
ﬁndings, and conclusions in this paper are those of the authors
only and do not necessarily reﬂect the views of our sponsors.
REFERENCES
[1] Exploits database by offensive security. https://www.exploit-db.com/.
[2] The llvm compiler infrastructure. http://llvm.org/.
[3] Penetration testing software. metasploit. https://www.metasploit.com/.
[4] P. Akritidis, C. Cadar, C. Raiciu, M. Costa, and M. Castro. Preventing
memory error exploits with wit. In S&P’08.
[5] C. Anley. Creating arbitrary shellcode in unicode expanded strings,
https://www.helpnetsecurity.com/dl/articles/
the “venetian” exploit.
unicodebo.pdf, 2002.
[6] S. Bhatkar and R. Sekar. Data space randomization. In DIMVA’08.
[7] D. Bigelow, T. Hobson, R. Rudd, W. Streilein, and H. Okhravi. Timely
rerandomization for mitigating memory disclosures. In CCS’15.
[8] A. Bittau, A. Belay, A. Mashtizadeh, D. Mazi`eres, and D. Boneh.
Hacking blind. In S&P’14.
[9] T. Bletsch, X. Jiang, and V. Freeh. Mitigating code-reuse attacks with
control-ﬂow locking. In ACSAC’11.
[10] T. Bletsch, X. Jiang, V. W. Freeh, and Z. Liang.
Jump-oriented
programming: A new class of code-reuse attack. In ASIACCS’11.
[11] E. Buchanan, R. Roemer, H. Shacham, and S. Savage. When good
instructions go bad: Generalizing return-oriented programming to risc.
In CCS’08.
[12] Bulba and Kil3r.
phrack.org/issues/56/5.html, 2000.
Bypassing stackguard and stackshield.
http://
[13] C. Cadar, P. Akritidis, M. Costa, J.-P. Martin, and M. Castro. Data
randomization. Technical Report MSR-TR-2008-120.
[14] N. Carlini, A. Barresi, M. Payer, D. Wagner, and T. R. Gross. Control-
ﬂow bending: On the effectiveness of control-ﬂow integrity. In SEC’15.
[15] N. Carlini and D. Wagner. Rop is still dangerous: Breaking modern
defenses. In SEC’14.
[16] S. Chen, J. Xu, E. C. Sezer, P. Gauriar, and R. K. Iyer. Non-control-data
attacks are realistic threats. In SEC’05.
14
[17] Y. Chen, Z. Wang, D. Whalley, and L. Lu. Remix: On-demand live
randomization. In CODASPY’16.
[18] R. Chinchani and E. van den Berg. A fast static analysis approach to
detect exploit code inside network ﬂows. In RAID’05.
[19] M. Conti, S. Crane, L. Davi, M. Franz, P. Larsen, M. Negro,
C. Liebchen, M. Qunaibit, and A.-R. Sadeghi. Losing control: On the
effectiveness of control-ﬂow integrity under stack attacks. In CCS’15.
Pointguardtm:
[20] C. Cowan, S. Beattie, J. Johansen, and P. Wagle.
Protecting pointers from buffer overﬂow vulnerabilities. In SEC’03.
[21] C. Cowan, C. Pu, D. Maier, H. Hintony, J. Walpole, P. Bakke, S. Beattie,
A. Grier, P. Wagle, and Q. Zhang. Stackguard: Automatic adaptive
detection and prevention of buffer-overﬂow attacks. In SEC’98.
[22] S. Crane, C. Liebchen, A. Homescu, L. Davi, P. Larsen, A.-R. Sadeghi,
S. Brunthaler, and M. Franz. Readactor: Practical code randomization
resilient to memory disclosure. In S&P’15.
[23] S. J. Crane, S. Volckaert, F. Schuster, C. Liebchen, P. Larsen, L. Davi,
A.-R. Sadeghi, T. Holz, B. De Sutter, and M. Franz. It’s a trap: Table
randomization and protection against function-reuse attacks. In CCS’15.
[24] L. Davi, A.-R. Sadeghi, D. Lehmann, and F. Monrose. Stitching the
gadgets: On the ineffectiveness of coarse-grained control-ﬂow integrity
protection. In SEC’14.
[25] L. De Moura and N. Bjørner.
Z3: An efﬁcient smt solver.
TACAS’08/ETAPS’08, Berlin, Heidelberg. Springer-Verlag.
[26] T. DETRISTAN, T. ULENSPIEGEL, Y. MALCOM, and V. UN-
DERDUK. Polymorphic shellcode engine using spectrum analysis.
http://phrack.org/issues/61/9.html, 2003.
[27] Y. Ding, T. Wei, T. Wang, Z. Liang, and W. Zou. Heap taichi: Exploiting
memory allocation granularity in heap-spraying attacks. In ACSAC’10.
[28] P. Fogla, M. Sharif, R. Perdisci, O. Kolesnikov, and W. Lee. Polymor-
phic blending attacks. In SEC’06.
[29] E. G¨oktas¸, E. Athanasopoulos, M. Polychronakis, H. Bos, and G. Por-
tokalidis. Size does matter: Why using gadget-chain length to prevent
code-reuse attacks is hard. In SEC’14.
J. Hiser, A. Nguyen-Tuong, M. Co, M. Hall, and J. W. Davidson. Ilr:
Where’d my gadgets go? In Proceedings of the S&P’12.
[30]
[31] D. Jang, Z. Tatlock, and S. Lerner. SafeDispatch: Securing C++ virtual
calls from memory corruption attacks. In NDSS’14.
[32] K2. Admmutate documentation.
0.8.4.tar.gz, 2003.
http://www.ktwo.ca/ADMmutate-
[33] G. S. Kc, A. D. Keromytis, and V. Prevelakis. Countering code-injection
attacks with instruction-set randomization. In CCS’03.
[34] C. Kil, J. Jun, C. Bookholt, J. Xu, and P. Ning. Address space layout
permutation (aslp): Towards ﬁne-grained randomization of commodity
software. In ACSAC’06.
[35] D. Larochelle and D. Evans. Statically detecting likely buffer overﬂow
vulnerabilities. In SEC’01.
[36] B. Lee, L. Lu, T. Wang, T. Kim, and W. Lee. From zygote to morula:
Fortifying weakened aslr on android. In S&P’14.
[37] Z. Liang and R. Sekar.
Fast and automated generation of attack
signatures: A basis for building self-protecting servers. In CCS’05.
[38] C. Linn and S. Debray. Obfuscation of executable code to improve
resistance to static disassembly. In CCS’03.
J. Mason, S. Small, F. Monrose, and G. MacManus. English shellcode.
In CCS’09.
[39]
[40] B. Niu and G. Tan. Per-input control-ﬂow integrity. In CCS’15.
[41] A. Papadogiannakis, L. Loutsis, V. Papaefstathiou, and S. Ioannidis.
In
Asist: architectural support for instruction set randomization.
CCS’13.
[42] V. Pappas, M. Polychronakis, and A. D. Keromytis. Smashing the
gadgets: Hindering return-oriented programm ing using in-place code
randomization. In S&P’12.
[43] V. Pappas, M. Polychronakis, and A. D. Keromytis. Transparent rop
exploit mitigation using indirect branch tracing. In SEC’13.
[44] P. Philippaerts, Y. Younan, S. Muylle, F. Piessens, S. Lachmund, and
T. Walter. Code pointer masking: Hardening applications against code
injection attacks. In DIMVA’11.
15
[45] M. Polychronakis, K. G. Anagnostakis, and E. P. Markatos. Compre-
hensive shellcode detection using runtime heuristics. In ACSAC’10.
[46] M. Polychronakis, K. G. Anagnostakis, and E. P. Markatos. Emulation-
In
based detection of non-self-contained polymorphic shellcode.
RAID’07.
[47] G. Portokalidis and A. D. Keromytis. Fast and practical instruction-set
randomization for commodity systems. In ACSAC’10.
[48] P. Ratanaworabhan, B. Livshits, and B. Zorn. Nozzle: A defense against
heap-spraying code injection attacks. In SEC’09.
[49] G. Richarte et al. Four different tricks to bypass stackshield and
stackguard protection. World Wide Web, 1, 2002.
[50] R. Roemer, E. Buchanan, H. Shacham, and S. Savage. Return-oriented
programming: Systems, languages, and applications. ACM Trans. Inf.
Syst. Secur., 15(1):2:1–2:34, Mar. 2012.
J. Salwan. Shellcodes database for study cases. http://shell-storm.org/
shellcode/.
[51]
[52] S. Schirra. ROPgadget - Gadgets ﬁnder and auto-roper. http://shell-
storm.org/project/ROPgadget/.
[53] S. Schirra. Ropper - rop gadget ﬁnder and binary information tool.
https://scoding.de/ropper/.
[54] F. Schuster, T. Tendyck, C. Liebchen, L. Davi, A.-R. Sadeghi, and
T. Holz. Counterfeit object-oriented programming: On the difﬁculty
of preventing code reuse attacks in c++ applications. In S&P’15.
[55] F. Schuster, T. Tendyck, J. Pewny, A. Maaß, M. Steegmanns, M. Contag,
and T. Holz. Evaluating the effectiveness of current anti-rop defenses.
In RAID’14.
[56] K. Serebryany, D. Bruening, A. Potapenko, and D. Vyukov. Address-
sanitizer: A fast address sanity checker. In ATC’12.
[57] F. Serna. Cve-2012-0769, the case of the perfect info leak. http://
zhodiac.hispahack.com/my-stuff/security/Flash ASLR bypass.pdf.
[58] H. Shacham, M. Page, B. Pfaff, E.-J. Goh, N. Modadugu, and D. Boneh.
On the effectiveness of address-space randomization. In CCS’04.
[59] M. I. Sharif, A. Lanzi, J. T. Gifﬁn, and W. Lee.
Impeding Malware
Analysis Using Conditional Code Obfuscation. In NDSS’08.
[60] Skylined. http://www.edup.tudelft.nl/˜bjwever/advisory iframe.html.php.
[61] K. Snow, S. Krishnan, F. Monrose, and N. Provos. Shellos: Enabling
fast detection and forensic analysis of code injection attacks. In SEC’11.
[62] K. Z. Snow, F. Monrose, L. Davi, A. Dmitrienko, C. Liebchen, and A.-
R. Sadeghi. Just-in-time code reuse: On the effectiveness of ﬁne-grained
address space layout randomization. In S&P’13.
[63] M. Suenaga. Evolving shell code. Whitepaper, Symantec Security
Response, Japan, 2006.
[64] W. N. Sumner, Y. Zheng, D. Weeratunge, and X. Zhang. Precise calling
context encoding. In ICSE’10.
[65] M. D. Team. Metasploit project. http://metasploit.com, 2006.
[66] C. Tice, T. Roeder, P. Collingbourne, S. Checkoway, U. Erlingsson,
L. Lozano, and G. Pike. Enforcing forward-edge control-ﬂow integrity
in gcc & llvm. In SEC’14.
[67] T. Toth and C. Kruegel. Accurate buffer overﬂow detection via abstract
payload execution. In RAID’02.
[68] V. van der Veen, D. Andriesse, E. G¨oktas¸, B. Gras, L. Sambuc,
A. Slowinska, H. Bos, and C. Giuffrida. Practical context-sensitive
cﬁ. In CCS’15.
[69] D. Wagner, J. S. Foster, E. A. Brewer, and A. Aiken. A ﬁrst step towards
automated detection of buffer overrun vulnerabilities. In NDSS’00.
[70] R. Wartell, V. Mohan, K. W. Hamlen, and Z. Lin. Binary stirring:
Self-randomizing instruction addresses of legacy x86 binary code. In
CCS’12.
[71] E. Wimberley. Bypassing AddressSanitizer. https://packetstormsecu-
rity.com/ﬁles/123977/Bypassing-AddressSanitizer.html.
[72] Y. Xia, Y. Liu, H. Chen, and B. Zang. Cﬁmon: Detecting violation of
control ﬂow integrity using performance counters. In DSN’12.
[73] C. Zhang, T. Wei, Z. Chen, L. Duan, L. Szekeres, S. McCamant,
D. Song, and W. Zou. Practical control ﬂow integrity and randomization
for binary executables. In S&P’13.
[74] M. Zhang and R. Sekar. Control ﬂow integrity for cots binaries.
SEC’13.
In