Using virtualization, most of the results of the methods discussed in this section can
be achieved. This can be done with any available technology including commercial
offerings such as VMware, as well as open source options such as Xen and Bochs.
By running the target program in a virtualized environment, it can be monitored
and controlled by looking at how the operating system is interacting with the vir-
tual hardware. Likewise, exceptions generated by programs can be caught and
acted upon. Additionally, when supported, virtual machines have the advantage
that they can restore the entire operating system and target application to a known
“good state” using snapshot technology. This can have a big advantage over simply
6.3
Advanced Methods
183
restarting a troubled target application since the file system, configuration files, reg-
istry entries, or back-end databases may have been corrupted during fuzz testing.
Overall, this shows great promise, but is still a topic of research.
6.4
Monitoring Overview
• Valid case instrumentation:
+ Will detect state-machine failures
+ Platform independent
– Will not detect exceptions that the application tries to hide
• System monitoring:
+ Can catch file system abnormalities
+ No need for source code
– Will catch crash-level exceptions only
– Platform dependent
• Remote monitoring:
+ Can access information on many system resources
+ Monitoring from fuzzing system
– Will catch crash-level exceptions only
– Will not have the same access as on the system
– Not always supported
• Application monitoring
+ Will detect all exceptions
– Platform dependent
– May miss nonexception-related vulnerabilities
6.5
A Test Program
Now that we’ve had the chance to see some of the tools at our disposal, let us run
them on a small test program to see how effective they can be.
6.5.1
The Program
#include 
#include 
#include 
char static_buffer1[16];
char static_buffer2[16];
void (*fn)(int);
int main(int argc, char *argv[]){
char stack_buffer1[16];
char stack_buffer2[16];
char *heap_buffer1 = (char *) malloc(16);
184
Target Monitoring
char *heap_buffer2 = (char *) malloc(16);
char *dummy;
fn = exit;
if(argc < 3){
printf("Need 2 arguments\n");
exit(-1);
}
int x = atoi(argv[1]);
switch(x){
case 0:
// Stack overflow
strcpy(stack_buffer2, argv[2]);
break;
case 1:
// Heap overflow
strcpy(heap_buffer1, argv[2]);
break;
case 2:
// Static overflow
strcpy(static_buffer2, argv[2]);
break;
case 3:
// wild write
heap_buffer1[atoi(argv[2])] = 0;
break;
case 4:
// memory exhaustion (and buffer overflow)
dummy = (char *) malloc(atoi(argv[2]));
memset(dummy, 0x41, atoi(argv[2]));
strcpy(dummy, "hello");
break;
}
free(heap_buffer2);
free(heap_buffer1);
fn(0);
}
This program accepts two arguments. The first is an integer that controls what the
program does, and the second is an argument to that particular functionality of the
program. Obviously, this program has a number of serious issues.
6.5.2
Test Cases
Below are a number of test cases that trigger various vulnerabilities in the test
program,
6.5
A Test Program
185
1.
./test 0 AAAAAAAAAAAAAAAAAAAA
2.
./test 0
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAA
3.
./test 1 AAAAAAAAAAAAAAAAAAA
4.
./test 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAA
5.
./test 2 AAAAAAAAAAAAAAAAAAAAAAAAAA
6.
./test 2 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
7.
./test 3 18
8.
./test 3 20
9.
./test 4 10
10. ./test 4 914748364
These test cases have the property that they all cause some kind of security
problem in the program. The first four types of input cause a memory corruption,
and the final one can cause a memory consumption denial of service. In the last
one, the vulnerability really is that the user controls the size of a malloc without a
check on the length. The odd-numbered test cases execute the vulnerable lines of
code, but do not cause the program to crash or exhibit obviously bad behavior. The
even-numbered test cases do cause a program failure:
[cmiller@Linux ~]$ ./test 0 AAAAAAAAAAAAAAAAAAAA
[cmiller@Linux ~]$ ./test 1 AAAAAAAAAAAAAAAAAAA
[cmiller@Linux ~]$ ./test 2 AAAAAAAAAAAAAAAAAAAAAAAAAA
[cmiller@Linux ~]$ ./test 3 18
[cmiller@Linux ~]$ time ./test 4 10
real
0m0.002s
user
0m0.000s
sys
0m0.004s
So despite the fact the vulnerable lines are executed and in the first four, memory is
corrupted, the program shows no sign of harm. The even-numbered test cases
demonstrate the fact the vulnerabilities are real:
[cmiller@Linux ~]$ ./test 0
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAA
Segmentation fault
[cmiller@Linux ~]$ ./test 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAA
*** glibc detected *** ./test: double free or corruption (out):
0x086c8020 ***
...
[cmiller@Linux ~]$ ./test 2 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
Segmentation fault
[cmiller@Linux ~]$ ./test 3 20
*** glibc detected *** ./test: free(): invalid pointer: 0x09d91020 ***
...
186
Target Monitoring
[cmiller@Linux ~]$ time ./test 4 914748364
real
0m54.942s
user
0m0.228s
sys
0m1.516s
Therefore, the odd-numbered test cases illustrate the fact that inputs can be sent
into the program, which, without detailed monitoring, would fail to find the vulner-
ability. Let us see if the advanced monitoring solutions we’ve discussed would be
able to detect the five vulnerabilities, even if only the less-effective, odd-numbered
test cases were available.
6.5.3
Guard Malloc
Guard Malloc is used by running the target program with the appropriate environ-
ment variables set. For example,
charlie-millers-computer:~ cmiller$
DYLD_INSERT_LIBRARIES=/usr/lib/libgmalloc.dylib ./test 1
AAAAAAAAAAAAAAAAAAA
GuardMalloc: Allocations will be placed on 16 byte boundaries.
GuardMalloc:
- Some buffer overruns may not be noticed.
GuardMalloc:
- Applications using vector instructions (e.g., SSE or
Altivec) should work.
GuardMalloc: GuardMalloc version 18
Bus error
So in this case, running the program with Guard Malloc enabled caused a bus error
and thus did find the vulnerability that would have otherwise been missed. Not sur-
prisingly, it did not find the vulnerability associated with the input ‘0’ since this is
a stack-based vulnerability and Guard Malloc only modifies the way heap buffers
are allocated,
charlie-millers-computer:~ cmiller$
DYLD_INSERT_LIBRARIES=/usr/lib/libgmalloc.dylib ./test 0
AAAAAAAAAAAAAAAAAAAA
GuardMalloc: Allocations will be placed on 16 byte boundaries.
GuardMalloc:
- Some buffer overruns may not be noticed.
GuardMalloc:
- Applications using vector instructions (e.g., SSE or
Altivec) should work.
GuardMalloc: GuardMalloc version 18
Notice that the program exited without a bus error, failing to detect the stack
overflow. Likewise, it did not help find the vulnerability associated with ‘2’. It did
succeed in finding the bug from test case number 7. It did not find the one for test
case 9, but did for case 10 and gave the following error:
6.5
A Test Program
187
GuardMalloc[test-1140]: Attempting excessively large memory
allocation: 914748368 bytes
Overall, Guard Malloc worked as advertised. It located vulnerabilities associ-
ated with heap allocations such as heap overflows and wild memory writes on the
heap. It also logged when excessive memory allocations occurred. It did not help
with stack-based or static-variable-based vulnerabilities.
6.5.4
Valgrind
Performing the same experiment as above with Valgrind gives pretty much the same
results. It helps find the heap-based bugs and not the others. It also warns of an
excessive memory allocation. However, notice the much more detailed reporting
provided by Valgrind, which points out the line number and exactly what has
occurred. This kind of information can help reduce the time required for post-
fuzzing analysis. Here is what the output looks like when Valgrind fails to find a
vulnerability:
[cmiller@Linux ~]$ valgrind ./test 0 AAAAAAAAAAAAAAAAAAAA
...
==6107== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 12 from
1)
...
Here is some detailed information about the two bugs it does find:
[cmiller@Linux ~]$ valgrind ./test 1 AAAAAAAAAAAAAAAAAAA
...
==6110== Invalid write of size 1
==6110==
at 0x40069D8: strcpy (mc_replace_strmem.c:272)
==6110==
by 0x8048576: main (test.c:30)
==6110==
Address 0x401F038 is 0 bytes after a block of size 16
alloc'd
==6110==
at 0x40053D0: malloc (vg_replace_malloc.c:149)
==6110==
by 0x80484D3: main (test.c:12)
...
==6110== ERROR SUMMARY: 4 errors from 2 contexts (suppressed: 12 from
1)
and
[cmiller@Linux ~]$ valgrind ./test 3 18
...
==6154== Invalid write of size 1
==6154==
at 0x80485AF: main (test.c:38)
==6154==
Address 0x401F03A is 2 bytes after a block of size 16
alloc'd
188
Target Monitoring
==6154==
at 0x40053D0: malloc (vg_replace_malloc.c:149)
==6154==
by 0x80484D3: main (test.c:12)
Looking at the first of these outputs shows that it correctly identifies the buffer
overflow due to a strcpy on line 30 of test.c, and furthermore that it is trying to
write past a buffer of size 16 that was allocated in line 12 of test.c. Likewise, the
other bug is correctly identified as a write of 1 byte that takes place on line 38 of
test.c and is 2 bytes after an allocated buffer of size 16.
6.5.5
Insure++
Insure++ is a commercial product that adds memory checks at compile time. Below
is an excerpt from the instrumented source code for the test program that shows the
types of checks added to the source code.
...
auto void *_Insure_1i;
_insure_decl_lwptr(_Insure_fid_1, 9L, 0, 9, (void *)(&_Insure_1i),
65536, 2);
_Insure_0i = (16);
_Insure_1i = malloc(_Insure_0i);
_insure_assign_ptra_after_call((void **)(&_Insure_1i), 9,
&_Insure_spmark);
_insure_ptra_check(9, (void **)(&_Insure_1i), (void *)_Insure_1i);
if (_Insure_1i) {
_insure_alloca(10, _insure_get_heap_handle(0), (void **)(&_Insure_1i),
_Insure_0i, 0, 4096, (char *)0, 0);
}
_insure_assign_ptraa(9, (void **)(&heap_buffer1), (void
**)(&_Insure_1i),
(void *)((char *)_Insure_1i));
heap_buffer1 = (char *)_Insure_1i;
...
_Insure_3_es = atoi(argv[2]);
_insure_after_call(&_Insure_spmark);
_insure_index2_checka(21, (void **)(&heap_buffer1), (void
*)heap_buffer1,
(int)_Insure_3_es, sizeof(char), 0L);
(heap_buffer1[_Insure_3_es]) = (0);
...
This excerpt consists of the lines relevant to case 3. The first set of lines is the
allocation of heap_buffer1. There are various calls to internal Insure++ functions
such as _insure_assign_ptra_after_call() and _insure_alloca(), which set up
the allocation. Later, when an index into the buffer is used, checks are made to
ensure this is safe, using the _insure_index2_checka() function.
6.5
A Test Program
189
Figure 6.8
Insure++ reports on all issues it has helped detect.
Insure++ has the most information available, and it is not surprising that it does
the best job of monitoring. In fact, it finds all the memory corruption bugs (Figure
6.8), which is significantly better than the other tools we’ve discussed, all of which
missed two. It did not complain about the denial of service issue.
Insure++ also quickly points out the exact cause and location of problems,
including line numbers. In fact, Figure 6.9 shows that not only does it find where
the wild pointer write occurs, but also identifies the first spot where a problem
occurs because of it.
This type of detailed information can save a tremendous amount of time when
analyzing the results of fuzzing.
6.6
Case Study: PCRE
The last example illustrated the strengths and weaknesses of some monitoring tools
in a test environment. Now, let us try them on an example that is a little more real-
istic. The Perl Compatible Regular Expression library is used by many open-source
applications including Firefox, Safari, Apache, and Postfix. This library has had
various vulnerabilities associated with it throughout its lifetime. The current version
190
Target Monitoring
as of the writing of this book is 7.4. Let us look back in time at version 6.2, which
can still be found on the Internet. It turns out that a modified version of this library
was shipped with Apple’s iPhone in April 2007, and the bugs we’re considering here
allowed for remote exploitation of the device. This library can be built with the
commands:
./configure
./make
gcc -g -I. pcredemo.c -o pcredemo .libs/libpcre.a
This produces a small sample program called pcredemo, which takes two argu-
ments. The first argument is a regular expression and the second is a string to exam-
ine with the supplied regular expression. For example,