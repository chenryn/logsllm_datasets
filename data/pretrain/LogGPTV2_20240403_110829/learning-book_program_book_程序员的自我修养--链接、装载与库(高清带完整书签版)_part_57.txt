e8 95 ff
cal1
80483cb:
8d 8d 78 ff ff ff
sub
80483ce:
Lea
esp.
ecx,
4
80483d4 :
8d 95 f8 fe
ff ff
1ea
[0t-dq].xp9
[ebp-87h]
80483da1
0000000899
mov
eax ,80h
80483df :
0 9Z 5 68
89 44 24 08
mOV
xea *[ug+ds9]
80483e3:
moV
[esp+4h], edx
80483e7:
80483ea:
e8 cl te ff ff
89 0c 24
cal1
mOV
80482b0
[esp]. ecx
与MSVC9的反汇编对比，可以发现，ebp-0x107的位置上是临时对象temp的地址，而
ebp-0x87则是n的地址。这样，这段代码和用MSVC9反汇编得到的代码是一样的，都是通
过栈上的隐藏参数传递临时对象的地址，只不过在将临时对象写回到实际的目标对象n的时
候，MSVC9 使用了rep movs 指令，而 goc调用了memcpy 函数。可见在这里VC和gcc 的
思路大同小异。最后来看看如果函数返回一个C++对象会如何：
#include 
using namespace std;
struct cpp_obj
() qodd
cout > anoo
cpp_obj6 operator= (const cpp_obj& rhs1
cout << *operator=\n*:
return *this;
~cpp_obj ()
cout <<
*dtor\n*;
) :
cPp_obj return_te8t ()
q{qo"dd
程序员的自我修养一链接、装载与库
---
## Page 327
304
第10章内存
cout << *before return\n*:
return b;
int main ()
n = return_test (1;
u [qo"dd
在没有开启任何优化的情况下，直接运行一下，可以发现程序输出为：
ctor
before return
ctor
dtor
copy ctor
operator=
dtor
dtor
我们可以看到在函数返回之后，进行了一个拷贝构造函数的调用，以及一次operaore
的调用，也就是说，仍然产生了两次拷贝。因此C++的对象同样会产生临时对象。
注
返回对象的拷贝情况完全不具备可移植性，不同的编译器产生的结果可能不同。
意
我们可以反汇编main函数来确认这一点：
n = return_test [) ;
00411C2C
1ea
00411C32
push
eax, [ebp-0DDh]
00411C33
return_test (4111F4h)
eax
00411C38
00411C3B
add
dword ptr [ebp-0E8h],eax
esp, 4
00411C41
mov
moV
00411C47
dword ptr [ebp-08ch],ecx
ecx, dword ptr [ebp-0E8h]
00411C4D
mov
00411C51
mov
mOV
edx,dword ptr [ebp-oEch]
byte ptr [ebp-4],1
00411C57
00411C58
push
lea
edx
00411C5B
ca11
cpp_obj::operator= (41125Dh)
ecx, [ebp-11h]
00411C60
00411C64
mov
1ea
byte ptr (ebp-4].0
00411C6A
cpp_obj::~cpp_ob5 (41119Ah)
ecx, [ebp-0DDh]
Cal1
可以看出，这段汇编与之前的版本结构是一致的，临时对象的地址仍然通过隐藏参数传
递给函数，只不过最后没有使用rep movs米拷贝数据，面是调用了函数的operator=来进行。
同时，这里还对临时对象调用了一次析构函数。
函数传递大尺寸的返回值所使用的方法并不是可移植的，不同的编译器、不同的平台、
不同的调用惯例甚至不同的编译参数都有权力采用不同的实现方法，因此尽管我们实验得到
程序员的自我修养一—链接、装载与库
---
## Page 328
10.3堆与内存管理
305
的结论在MSVC和gcc下惊人地相似，读者也不要认为大对象传递只有这一种情况。
【小知识】
声名狼雍的C++返回对象
正如我们看到的，在C++里返回一个对象的时候，对象要经过2次拷贝构造函数的调用
才能够完成返回对象的传递、1次拷贝到栈上的临时对象里，另一次把临时对象拷员到存储
返因值的对象里，在某些编译器里，返回一个对象甚至要经过更多的步骤。
这样带来的恶果就是返回一个较大对象会有非常多的额外开销，因此C++程序中都尽量
避免返回对象，此外，为了减小退回对象的开销，C++提出了返回值优化（RetumValue
Optimization，RVO）这样的技术，可以将某些场合下的对象拷贝减少1次，例如：
cpp_obj return_test ()
return cpp_obj (1 ;
在这个例子中，构造一个cpp_obj对象会调用一次cpp_obj的构造函数，在返回这个对
象时，还会调用cpp_obj的拷贝构造函数。C++的退团值优化可以持这两步合并，直接将对
象构造在传出时使用的临时对象上，因此可以减少一次复制过程。
10.3堆与内存管理
相对于栈而言，堆这片内存面临一个稍微复杂的行为模式：在任意时刻，程序可能发出
请求，要么申请一段内存，要么释放一段已中请过的内存，面且申请的大小从儿个字节到数
GB都是有可能的，我们不能假设程序会一次申请多少维空间，因此，堆的管理显得较为复
杂。下面让我们来了解·下堆的工作原理。
10.3.1什么是堆
光有栈对于面向过程的程序设计还远远不够，因为栈上的数据在函数返回的时候就会被
释放掉，所以无法将数据传递至函数外部，而全局变量没有办法动态地产生，只能在编译的
时候定义，有很多情况下缺乏表现力。在这种情况下，堆（Heap）是唯-一的选择。
堆是一块巨大的内存空间，常常占据整个虚拟空间的绝大部分。在这片空间里，程序可
以请求一块连续内存，并自由地使用，这块内存在程序主动放弃之前都会一直保持有效。下
面是一个中请堆空间最简单的例子。
程序员的自我修养一链接、装载与库
---
## Page 329
306
第10章内存
int nain1)
/* use p as an array of size 1000*/
(00)ooea(xeq) = d , xeo
free (p) :
在第3行用malloc申请了1000个字节的空间之后，程序可以自由地使用这1000个字
节，直到程序用free函数释放它。
那么malloc到底是怎么实现的呢？有一种做法是，把进程的内存管理交给操作系统内
核去做，既然内核管理着进程的地址空间，那么如果它提供一个系统调用，可以让程序使用
这个系统调用申请内存，不就可以了吗？当然这是一种理论上可行的微法，但实际上这样做
的性能比较差，因为每次程序中请或者释放堆空间都需要进行系统调用。我们知道系统调用
的性能开销是很大的，当程序对堆的操作比较频繁时，这样做的结果是会严重影响程序的性
能的，比较好的做法就是程序向操作系统申请一块适当大小的堆空间，然后由程序自己管理
这块空间，而具体来讲，管理着堆空间分配的往往是程序的运行库。
全部“售完”或程序有大量的内存需求时，再根据实际需求向操作系统“进货”，当然运行
库在向程序零售堆空间时，必须管理它批发来的堆空间，不能把同一块地址出售两次，导致
地址的冲突。于是运行库需要一个算法来管理堆空间，这个算法就是堆的分配算法。不过在
了解具体的分配算法之前，我们先来看看运行库是怎么向操作系统批发内存的。
10.3.2Linux进程堆管理
从本章的第一节可知，进程的地址空间中，除了可执行文件、共享库和栈之外，剩余的
未分配的空间都可以被用来作为堆空间。Linux下的进程堆管理稍微有些复杂，因为它提供
了两种堆空间分配的方式，即两个系统调用：一个是brk（系统调用，另外一个是mmap()。
brkO的C语言形式声明如下：
int brk (void* end_data_segment)
brk0的作用实际上就是设置进程数据段的结束地址，即它可以扩大或者缩小数据段
（Linux下数据段和BSS合并在一起统称数据段）。如果我们将数据段的结束地址向高地址
移动，那么扩大的那部分空间就可以被我们使用，把这块空间拿来作为堆空间是最常见的做
法之一（我们还将在第12章详细介绍brk的实现）。Glibc中还有一个函数叫sbrk，它的功
能与brk类似，只不过参数和返回值略有不同。sbrk以一个增量（Increment）作为参数，即
离要增加（负数为减少）的空间大小，返回值是增加（或减少）后数据段结束地址，这个函
数实际上是对brk系统调用的包装，它是通过brk0实现的。
mmapO的作用和Windows系统下的VirtualAlloe很相似，它的作用就是向操作系统申请
程序员的自我修养一链接、装载与库
---
## Page 330
10.3堆与内存管理
307
一段虚拟地址空间，当然这块虚拟地址空间可以映射到某个文件（这也是这个系统调用的最
初的作用），当它不将地址空间映射到某个文件时，我们又称这块空间为匿名（Anonymous）
空间，匿名空间就可以拿来作为堆空间。它的声明如下：
void *mnap (
void *start,
int prot,
size_t length,
int flags.
int fd,
off_t offset) :
mmap的前两个参数分别用于指定需要中请的空间的起始地址和长度，如果起始地址设
置为0，那么Linux系统会自动挑选合适的起始地址。prou/flags这两个参数用于设置申请的
空间的权限（可读、可写、可执行）以及映射类型（文件映射、匿名空间等），最后两个参
数是用于文件肤射时指定文件描述符和文件偏移的，我们在这里并不关心它们。
glibc的malloc函数是这样处理用户的空间请求的：对于小于128KB的请求来说，它会
在现有的堆空间里面，按照堆分配算法为它分配一块空间并返回：对于大于128KB的请求
来说，它会使用mmap0函数为它分配一块匿名空间，然后在这个匿名空间中为用户分配空
间。当然我们直接使用mmap也可以轻而易举地实现malloc函数：
void *ma11oc (size_t nbytes)
void* ret = mmap (0, nbytes, PROT_READ 1 PROT_WRITE,
if (ret = MAP_PAILED)
MAP_PRIVATE 1 MAP_ANONYMOUS, 0, 01 :
return 0;
return ret;
mmap 的详细使用说明请查阅 Linux的 manpage
由于mmapO函数与VirtualAllocO类似，它们都是系统虚拟空间中请函数，它们申请的
空间的起始地址和大小都必须是系统页的大小的整数倍，对于字节数很小的请求如果也使用
mmap的话，无疑是会浪费大量的空间的，所以上述的做法仅仅是演示而已，不具有实用性。
了解了Linux系统对于堆的管理之后，可以再来详细分析一下第6章里面的一个问题，
那就是malloc到底一次能够申请的最大空间是多少？为了回答这个问题，就不得不再回头
仔细研究一下图9-1了，我们可以看到在有共享库的情况下，留给堆可以用的空间还有两处。
第一处就是从BSS段结束到0x40000000，即大约1GB不到的空间：第二处是从共享库到
栈的这块空间，大约是2GB不到。这两块空间大小都取决于栈、共享库的大小和数量。于
是可以估算到malloc最大的申请空间大约是2GB不到，这似乎与在第6章中得到的2.9GB
的实验结论并不一致。
那么事实是怎么样的呢？实际上2.9GB的结论是对的，2GB的推论也并没有错。造成
程序员的自我修养—链接、装载与库
---
## Page 331