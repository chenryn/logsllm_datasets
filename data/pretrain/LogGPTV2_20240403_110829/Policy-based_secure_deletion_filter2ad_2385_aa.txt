title:Policy-based secure deletion
author:Christian Cachin and
Kristiyan Haralambiev and
Hsu-Chun Hsiao and
Alessandro Sorniotti
Policy-based Secure Deletion
Christian Cachin
IBM Research - Zurich
PI:EMAIL
Kristiyan Haralambiev
Hsu-Chun Hsiao
IBM Research - Zurich
PI:EMAIL
CyLab / CMU
PI:EMAIL
Alessandro Sorniotti
IBM Research - Zurich
PI:EMAIL
ABSTRACT
Securely deleting data from storage systems has become difﬁcult
today. Most storage space is provided as a virtual resource and tra-
verses many layers between the user and the actual physical stor-
age medium. Operations to properly erase data and wipe out all
its traces are typically not foreseen, particularly not in networked
and cloud-storage systems. This paper introduces a general cryp-
tographic model for policy-based secure deletion of data in stor-
age systems, whose security relies on the proper erasure of crypto-
graphic keys. Deletion operations are expressed in terms of a policy
that describes data destruction through deletion attributes and pro-
tection classes. The policy links attributes as speciﬁed in deletion
operations to the protection class(es) that must be erased accord-
ingly. A cryptographic construction is presented for deletion poli-
cies given by directed acyclic graphs; it is built in a modular way
from exploiting that secure deletion schemes may be composed
with each other. The model and the construction unify and gener-
alize all previous encryption-based techniques for secure deletion.
Finally, the paper describes a prototype implementation of a Linux
ﬁlesystem with policy-based secure deletion.
Categories and Subject Descriptors
D.4.3 [File Systems Management]: Access methods; D.4.3 [File
Systems Management]: File organization; D.4.6 [Security and
Protection]: Cryptographic controls
Keywords
Secure deletion; security policy; ﬁlesystem security
1.
INTRODUCTION
Modern storage systems do not include operations to reliably
destroy stored information. Common deletion operations simply
mark the occupied space as free and remove an entry from the di-
rectory, but some of the stored data may remain accessible for much
longer. A technically knowledgeable user with low-level access to
the storage system can still obtain the data. This description applies
to simple magnetic storage devices like disks or tapes, but holds as
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full cita-
tion on the ﬁrst page. Copyrights for components of this work owned by others than
ACM must be honored. Abstracting with credit is permitted. To copy otherwise, or re-
publish, to post on servers or to redistribute to lists, requires prior speciﬁc permission
and/or a fee. Request permissions from permissions@acm.org.
CCS’13, November 4–8, 2013, Berlin, Germany.
Copyright 2013 ACM 978-1-4503-2477-9/13/11 ...$15.00.
http://dx.doi.org/10.1145/2508859.2516690.
well for networked storage services, such as storage controllers in
a data center, ﬁle servers, or cloud storage. Storage systems nowa-
days contain many layers of virtualization and perform aggressive
caching for increased performance. They leave around traces of
stored data beyond the control of the users, because such data can-
not be securely wiped out through the usual service interface.
However, users would like to control the deletion of their infor-
mation because supposedly deleted data that reappears later may
have undesirable consequences. Many companies have installed
detailed polices for retaining data and for deleting expired data;
also the Electronic Frontier Foundation recommends controlled de-
letion of data as a means to maintaining user privacy [9]. The Eu-
ropean Data Protection Directive mandates that personal data must
be erased upon request of the data subject [11].
With the advent of cloud computing, many clients who outsource
storage want to take control over the shredding of their data them-
selves. They would like to retain an element of control that lets
them erase their outsourced data from the cloud, without relying on
the cooperation of the storage service. At the same time, providers
of storage services are also interested to offer guaranteed destruc-
tion as a feature to their customers. For instance, providers would
like to erase data so that no trace of it reappears later, not even
during a forensic investigation.
In this paper, we explore the use of encryption and key man-
agement for securely deleting data. When data is stored encrypted,
only the corresponding key has to be destroyed for erasing the data.
Deleting (remote) data becomes a problem of managing and delet-
ing (local) keys. We introduce the concept of policy-based secure
deletion, where the stored data is grouped into protection classes,
and attributes control the selective erasure of data through a pol-
icy. The design relies on a master key stored in a controlled and
erasable memory, so that operations to delete data manipulate the
master key, e.g., by updating it or erasing parts of it. No bulk data
is ever re-encrypted.
This paper makes the following contributions.
• We introduce the notion of a secure deletion scheme and pro-
vide ﬁrst formal model and a security deﬁnition for encryp-
tion-based secure deletion. It uses a coercive adversary that
obtains the master key at the time of attack. The notion is
formulated in the secret-key setting, but it can be extended to
a public-key model.
• We construct a secure deletion scheme from encryption and
threshold secret sharing; it supports arbitrary policies that are
modeled as a circuit with AND, OR, and threshold gates.
• We show how secure deletion schemes can be composed in a
modular way. Our approach uniﬁes and generalizes all exist-
ing constructions for cryptographic secure deletion.
259• We present a prototype implementation of a Linux ﬁlesystem
with policy-based secure deletion.
Our encryption-based deletion methods apply to all kinds of stor-
age systems, regardless of their physical storage media, and they
can be integrated into existing systems with minimal effort. In con-
trast, solutions based on overwriting at the physical level [16, 23]
only work in close connection with the media properties. This work
aims at erasing data from large networked storage systems and as-
sumes a small, controlled, and erasable keystore. Thus, it lever-
ages physical (local) deletion to achieve secure deletion on (remote)
large-scale data stores.
1.1 Related work
Secure deletion. Many systems have been proposed which es-
sentially overwrite the data in order to delete it [16, 23]. Some
methods are very ﬂexible and can be integrated with arbitrary ﬁle-
systems [17], provided their source code is available. Recent work
has addressed solid-state storage, which requires completely dif-
ferent approaches than magnetic disks for destroying data [28, 22].
However, all solutions using overwriting depend heavily on the
properties of the underlying physical storage. With cloud comput-
ing and the virtualized storage models that are widely used today,
physical control over data-storage locations is no longer feasible.
Therefore we do not further consider secure deletion mechanisms
based on overwriting or other physical properties.
Employing encryption for the explicit goal of erasing informa-
tion goes back to the work of Boneh and Lipton [4]. Di Crescenzo
et al. [8] introduce a tree construction for efﬁcient secure deletion
of arbitrary ﬁles among a group of ﬁles. The master key at the root
of the tree is kept in erasable memory, and every key in the tree
encrypts several keys below, until the keys at the leaves encrypt the
ﬁles themselves.
Mitra and Winslett [19] describe a method for creating an in-
verted index of keywords found in stored data records. The method
uses encryption and allows to selectively delete a data record and
the corresponding keywords in the index by assuming the encryp-
tion keys can be destroyed.
Perlman’s Ephemerizer [20] employs a temporal sequence of
keys modeling different expiration times for encrypted data. The
FADE system [27] uses public-key cryptography and introduces
some simple policies with Boolean operators governing deletion.
FADE comes closest to our approach among the existing work.
The policies of FADE are restricted to one- or two-level Boolean
expressions, though, and its policies are intertwined with an im-
plementation from a particular public-key cryptosystem. In con-
trast, our work permits general policies using Boolean expressions
with threshold operators, may use generic cryptosystems, including
secret-key systems, and supplies security proofs for all construc-
tions.
Peterson et al. [21] use all-or-nothing transforms (AONT) at the
block level for secure deletion, in combination with overwriting.
The idea is to store every block through an AONT and then to over-
write only a part of it, which will render the whole block inaccessi-
ble.
Vanish [13] is a practical system for publishing content online
with an expiration date, e.g., providing secure deletion for user data
published in social networks. It encrypts the content and splits the
key using secret sharing. The shares are then maintained by a peer-
to-peer distributed system that gradually forgets the stored items
unless they are refreshed. This gives the user some control over the
expiration of his content.
Key-assignment schemes. Our approach to secure deletion is
related to monotone secret sharing schemes and to key-assignment
schemes for hierarchical access control. The survey by Crampton
et al. [6] presents a summary of the literature on key assignment.
Key assignment considers a publisher and multiple users. The pub-
lisher distributes one key to each user; every user can later derive
suitable keys that allow the user to access information according
to a hierarchical policy. The constructions may use public storage
as well [1, 7]. Many constructions and improvements are avail-
able in the literature [6, 1, 2, 5]; they may be applied to the policy
formulation and to the implementation of secure deletion schemes
described here.
Attribute-based encryption. Our work also relates to the attri-
bute-based encryption (ABE) schemes developed in the last few
years [24], especially to ciphertext-policy ABE (CP-ABE) sche-
mes [3]. Similar to CP-ABE, our policy-based secure deletion
construction maintains keys for different attributes and the dele-
tion policy is linked to the protected ﬁles. Many existing CP-
ABE constructions suffer from creating large ciphertexts, though
this deﬁciency has been removed recently [15]. While conceptu-
ally related to secure deletion in the sense that data is encrypted
in a policy-speciﬁc way, CP-ABE does not already yield secure
deletion. CP-ABE maintains a master key from which it produces
attribute-speciﬁc decryption keys. Without knowing the attributes
relevant in future decryption operations, either all such possible de-
cryption keys must be generated in advance so the master key can
be deleted or it must be kept around for generating decryption keys.
However, this either is not efﬁcient or contradicts the goal of secure
deletion under coercion, when the master key must be revealed.
1.2 Organization
Section 2 introduces our notion of policy-based secure deletion.
Multiple implementations of secure deletion schemes and the com-
position operation appear in Section 3, and Section 4 discusses their
efﬁciency and other properties. Finally, Section 5 presents a ﬁlesys-
tem with policy-based secure deletion.
2. MODEL
This section deﬁnes policy-based secure deletion schemes using
a deletion policy represented by a graph.
2.1 Selective secure deletion
The goal of a policy-based secure deletion scheme is to main-
tain, on a permanent storage medium, a collection of ﬁles and to
selectively delete some of them. Each ﬁle consists of a bit string of
arbitrary length and is protected under a protection class from a set
P, as speciﬁed by a deletion policy; the formal deﬁnition of a dele-
tion policy will be presented in the next section. A protection class
is a logical grouping of ﬁles governed by an identical deletion rule.
The universe of protection classes is denoted by P = {p1, p2, . . . }.
The scheme provides operations for protecting a ﬁle, for access-
ing a ﬁle, and for securely deleting ﬁles. Secure deletion schemes
in our model represent specialized encryption schemes and provide
cryptographic security. We model only a secret-key secure deletion
scheme, where the same key serves for protection of ﬁles and ac-
cess to ﬁles; our model applies also to public-key schemes that may
be deﬁned analogously.
At the beginning, ﬁles of all protection classes are protected un-
der an initial master key. The master key is stored in a closely
guarded erasable memory, which is kept secret from an adversary.
The master key will be changed later as a result of deletion opera-
tions. In contrast, all other data produced by the scheme is called
ciphertext and stored in immutable non-erasable memory, which is
public and exposed to the adversary at all times.
260Each protection class is deﬁned by means of attributes from a
set A of strings over a ﬁxed alphabet. Secure deletion operates on
a subset of attributes, by ensuring that protection classes subject
to those attributes become inaccessible. When a secure deletion
operation is executed, a new master key is computed and stored
in the erasable memory; the master key stored there previously is
erased. Secure deletion may also change the ciphertext, i.e., add
new ciphertext to the non-erasable memory.
2.2 Policy graph
A deletion policy graph G suitable for a secure deletion scheme
is given by a pair (V, E) with V = A ∪ P such that (V, E) is a
directed acyclic graph (DAG). It has two kinds of nodes, sources
and interior nodes. Nodes with no incoming edges (indegree zero)
are sources and correspond one-to-one to the attributes in A. All
other nodes are called interior nodes; each of them is associated
with a threshold parameter m, which is a positive integer less than
or equal to the indegree of the node. Every interior node is labeled
by a distinct protection class in P. A policy graph must contain at
least one source and one interior node, hence, the minimum policy
graph has two nodes and one edge from the source node to the
interior node.
Every node and every edge of the graph is associated to a Boolean
value. All outgoing edges from a node take the same value as the
node. The source nodes are assigned a value through the secure
deletion scheme. An interior node with threshold m and n in-
coming edges corresponds to a Boolean threshold gate with thresh-
old m: the node is TRUE whenever at least m among the n incom-
ing edges are TRUE. Notice that G has a natural interpretation as a
Boolean circuit whose sources correspond to A. Threshold nodes
subsume AND and OR gates as special cases.
2.3 Operation
Intuitively, deletion operations can be triggered by setting a sub-
set of attributes to TRUE. The corresponding source nodes in G are
then set to TRUE, which may cause some protection classes of G
to become TRUE. This means that all ﬁles protected under these
classes are deleted. Multiple secure deletion steps may follow each
other.
More precisely, secure deletion works as follows. All protection
classes are initially accessible, i.e., all source nodes and all their
outgoing edges are FALSE at the start. As the circuit is monotone,
this means that also all other nodes initially evaluate to FALSE ac-
cording to G. Hence, none of the protection classes speciﬁed has
been deleted and all ﬁles are accessible in the sense that their plain-
text can be obtained from the ciphertext with the master key. A se-
cure deletion operation takes a subset of the attributes as parameter
and changes the associated source nodes, and, consequently, some
edges in G to TRUE. Those ﬁles governed by protection classes
that change their value to TRUE are no longer accessible after the
master key has been updated. This model allows secure deletion
of many ﬁles according to the policy and the given attributes. The