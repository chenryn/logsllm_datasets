title:Provably secure browser-based user-aware mutual authentication over
TLS
author:Sebastian Gajek and
Mark Manulis and
Ahmad-Reza Sadeghi and
J&quot;org Schwenk
Provably Secure Browser-Based User-Aware
Mutual Authentication over TLS
(Full version)
Sebastian Gajek1 and Mark Manulis2 and Ahmad-Reza Sadeghi1 and Jörg Schwenk1
1 Horst Görtz Institute for IT-Security, Ruhr University Bochum, Germany
{sebastian.gajek|joerg.schwenk}@nds.rub.de
PI:EMAIL
2 UCL Crypto Group, Belgium
PI:EMAIL
Abstract. The standard solution for user authentication on the Web is to establish a TLS-based secure
channel in server authenticated mode and run a protocol on top of TLS where the user enters a password
in an HTML form. However, as many studies point out, the average Internet user is unable to identify the
server based on a X.509 certiﬁcate so that impersonation attacks (e.g., phishing) are feasible. We tackle this
problem by proposing a protocol that allows the user to identify the server based on human perceptible au-
thenticators (e.g., picture, voice). We prove the security of this protocol by reﬁning the game-based security
model of Bellare and Rogaway and present a proof of concept implementation.
Key words: Browser-based security protocols, human-perceptible authentication, TLS, phishing
1 Introduction
1.1 Motivation
The World Wide Web has grown and become a fundamental technology of the information society whereby
the browser plays an indispensable function both as the user’s interface to access the rich world of Web-based
services and provider of security tools in order for safeguarding a honest perception of the Web. This constrains
the design of applications and security protocols to TLS, HTTP and higher order protocols, such as AJAX,
AFLEX or SOAP. We call protocols realizable within the constraints of commodity Web browsers browser-
based protocols.
An immediate need on the Web is to authenticate users and permit access to services or private information.
A widely adopted approach is to use TLS in server authenticated mode and execute a protocol on top of TLS
whereby the user enters a password in a Web form. A folklore belief is that the user is able to authenticate
the server through a X.509 certiﬁcate. Recent studies point out however that average-skilled Internet users
understand neither server certiﬁcates nor browsers’ security indicators [17, 25, 37]. Users are overstrained by
the veriﬁcation procedure and tend to ignore browser’s warnings; in fact, they evaluate Web sites on the basis of
non-technical indicators (e.g., brands, logos). This ceremony3 provides a wrong sense of security. An adversary
may fake the site and disclose the user’s password (“phishing attacks”).
Apart from the user, an alternative problem is the X.509 public key infrastructure for server authentication.
Various Certiﬁcation Authorities (CAs) have stored their root certiﬁcates in browsers and are thus trusted per
se. Although CAs may considerably differ in their issuing policies browsers equally treat the certiﬁcates. Adver-
saries may exploit weak issuing policies, retrieve certiﬁcates for rogue servers, and do a lot of harm (e.g., [21]).
In addition to that, the browser remains a potential point of attack. The browser is partly controllable by
a remote party, using the facets of Web languages. An adversary is capable of sending queries that alter the
internal state of the browser or reveal temporary connection information, including access to the browser’s user
interface (chrome), cache, cookies, history and has led to several vulnerabilities in browser-based protocols
(e.g., [22, 29, 35]).
3 Carl Ellison coined at Crypto 2005 Rump Session the term ceremony to denote the paradigm that a provably secure
cryptosystem becomes insecure when it is interfaced to a user. See [19].
This is the full version of the extended abstract which appeared in: Proceedings of the ACM Symposium on Information, Computer and Communications Security (ASIACCS'08), March 18-20, 2008 M. Abe, V. Gligor (Eds.), ACM, pp. 300--311.2
Sebastian Gajek, Mark Manulis, Ahmad-Reza Sadeghi, and Jörg Schwenk
1.2 Our Contribution
We solve the above problems by presenting a protocol that explicitly considers the user and the browser as
protocol participants, and ties the user’s authentication to the TLS secure channel. We relieve the user from the
responsibility of authenticating the server by mediating the roles of authentication between the user, browser
and server.
We ﬁrst make the server identify the browser on the basis of client certiﬁcates. This step ensures that the
server establishes a secure channel to the browser, however does not authenticate the user. In order to prove
its identity to the user, the server sends a human perceptible authenticator (HPA) (e.g., personal picture, voice
recording). The user has to recognize the authenticator; veriﬁcation of server certiﬁcates (and the underlying
public key infrastructure) and any security indicator (e.g., URL, padlock) is irrelevant. Finally, the user au-
thenticates to the server, using a password. We call the proposed protocol BBMA and the corresponding security
goal browser-based mutual authentication (BBMA). Using BBMA has the following advantages over previous
browser-based protocols:
1. BBMA provides user-aware authentication which takes into account human skills. BBMA reduces the secu-
rity of browser-based protocols to the assumption that users are capable of identifying human perceptible
authenticators—as they are used to do in the physical world where identities are provided in an easily
recognizable fashion. Based on results of human authentication protocols [15, 16, 26, 38], visual authenti-
cators are appealing; however, BBMA is ﬂexible in the choice of authenticators. TLS in client authentication
mode, by contrast, ensures browser-aware server authentication. In this context browser-aware authentica-
tion means that the browser authenticates whenever the server certiﬁcate is valid. This is especially true for
rogue servers using valid certiﬁcates. Client certiﬁcates prevent the adversary from the impersonation of the
browser; they do not prevent that a user discloses sensitive information requested by such rogue servers, as
the browser indicates an authenticated communication.
2. We prove BBMA secure in the reﬁned model for authentication due to Bellare and Rogaway [7]. The reﬁne-
ments concern partitioning of the client entity into user and browser entities, since both entities are active
participants of browser-based protocols and target of different attacks. This requires to formulate the user
and browser behavior. To the best of our knowledge, it is the ﬁrst browser-based protocol that has been
formally analyzed in the model.
3. BBMA is ﬂexible. The protocol ﬁts into the standard TLS speciﬁcation since the human perceptible au-
thenticator and the password are exchanged as HTML payloads over the secure TLS channel. We have
implemented the protocol [32] in a proof of concept. The implementation comprises an online registration
protocol where the user may setup client certiﬁcates for different browsers in a user-convenient way. That
is, we do not need client certiﬁcates to be issued by a trusted CA. They may be self-signed. The server has
to store the hash value of the public key as a unique cryptographic identiﬁer of the browser.
The use of both client certiﬁcates and passwords in BBMA may seem redundant at ﬁrst glance, since the meth-
ods are commonly regarded as orthogonal mechanisms to authenticate the user. We stress the fact that a client
certiﬁcate only authenticates the browser. It rules out the ability to distinguish between multiple users, having
access to the browser. Moreover, some business models require a ﬁne-grained access control where the user is
permitted to sign on different accounts (e.g., online banking). Using passwords in addition to client certiﬁcates
(instead of multiple client certiﬁcates) is a design solution for ease of use that complies with requirements of
browser-based protocols and is provably secure in our model.
1.3 Related Work
Browser-based authentication protocols originate from HTTP Basic Authentication [20] which has been a stan-
dard tool to authenticate users for static Web pages. With the advent of dynamic Web page generation, it proved
more useful to deliver the password to the scripting language as the value of an HTML form input ﬁeld.
Another, independent line of development are password-based authenticated key exchange protocols (PAKE).
Bellovin and Merritt [10], Bellare et al. [6,9], Boyko et al. [11], and McKenzie [11,30] proposed various PAKE
structures that have been augmented to provide resiliency against ofﬂine dictionary attacks [27] and to provide
Provably Secure Browser-Based User-Aware Mutual Authentication over TLS
3
forward secrecy under various assumptions [2, 12, 13, 28]. Later Abdalla and Pointcheval [3] proposed SPAKE
a simpliﬁed PAKE structure that provides more ﬂexibility in the choice of groups. Steiner et al. [36] and Abdalla
et al. [1] have shown that PAKE structures may be incorporated into the TLS protocol framework and proposed
provably secure ciphersuites for password-based authenticated key exchange.
The analysis of these PAKE protocols has in common that protocol participants are assumed to be machines
that are able to strictly obey the protocol speciﬁcation. From this follows a model for authentication that idealizes
the user and browser. Such a model does not thoroughly reﬂect the Web where ordinary Internet users are
involved in the protocol and browsers naively trust certiﬁcates that origin from any pre-installed authority. The
model presented in this paper relaxes these assumptions in a way that neither a trusted CA exists nor the user
understands the meaning of public key infrastructures. Under these assumptions PAKE protocols are vulnerable
to attacks where the adversary simply mimics the password dialog. In order to thwart such attacks, BBMA
makes use of passwords and client secret keys. Then, impersonation of the user without compromising the
client secret is infeasible, even if the adversary has revealed the password.
So far, few browser-based protocols have been subject to rigorous security analysis: Kormann and Rubin [29]
show that Microsoft’s .NET passport, a Web-based realization of the Kerberos protocol for single sign on, is
susceptible to attacks where the adversary steals the ticket granting ticket cookie. Groß [22] analyzes SAML,
an alternative single sign on protocol, and shows that the protocol is vulnerable to adaptive attacks where the
adversary intercepts the authentication token contained in the URL. Soghoian and Jakobsson [35] investigate
the SiteKey-protocol (a.k.a. PassMark Security Inc.’s Two-Factor-Two-Way AuthenticationTM) that displays a
previously negotiated image in addition to password forms in order to signal that the user is connected to the
benign server. The authors show the feasibility of stealing the shared secret that is stored in a cookie.
By contrast, BBMA has formal security arguments and is provably secure in a revised version of the standard
model for authentication due to Bellare and Rogaway. The model takes into account that the adversary controls
the network and may circumvent the browser’s same origin policy (see Section 2.1) in order to corrupt weak
identiﬁers, such as cookies. BBMA uses cryptographically strong bindings, i.e., client certiﬁcates that are not
affected in case of possible violation of the same origin policy.
Groß et al. prove in [24] the security of WS-Federation passive Requestor Proﬁle—a browser-based protocol
for federated identity management. The proof is carried out in the browser model [23] that is build on the
Reactive Simulatability framework due to Pﬁtzmann and Waidner [31]. The model abstracts away the TLS-
protected channel through an ideal functionality that captures the same cryptographic task and presupposes
ideal users who are able to identify servers based on certiﬁcates. There exists no soundness proof that TLS is
simulatable and realizes such functionality, especially with respect to the user behavior. BBMA takes explicitly
into account the TLS protocol and is shown to be provably secure in the Random Oracle Model when instantiated
with the key transport ciphersuite in server authentication mode.
1.4 Organization
The remaining sections are structured as follows. In Section 2, we present the formal security model for browser-
based authentication protocols. We describe BBMA in a high level description of TLS and prove that it is secure
in Section 3. In Section 4, we discuss variants of realizing BBMA. Finally, we conclude the paper in Section 5.
2 Modeling Browser-Based Mutual Authentication (BBMA)
In this section we reﬁne the original security model for mutual authentication from [7] according to our idea on
partitioning the client party into the entities representing the participating user and browser. Similar to [7] we
consider an active probabilistic polynomial time (PPT) adversary who interacts with involved parties through
queries and controls all the communication.
2.1 Communication Model
Protocol Participants and Long-Lived Keys We consider the server S, the browser B, and the human user
U as participants of a BBMA protocol Π. Furthermore, by C we denote the client given by a pair (U,B).
4
Sebastian Gajek, Mark Manulis, Ahmad-Reza Sadeghi, and Jörg Schwenk
According to our reﬁnement and contrary to the current cryptographic literature, we explicitly model the user as
a stand-alone entity. We start from scratch and make the weakest security assumptions to represent a practical
setting namely that U is security-unaware and B supports standard techniques of commodity Web browsers.
The human user U is modeled as a probabilistic machine with “very limited” computational capabilities.
Intuitively, it is clear that human users are not able to perform the same computations as browser and server.
More speciﬁcally, we assume that human users are unable to perform cryptographic operations, but may rec-
ognize high-entropy data if it is in a human-recognizable form and may output low-entropy passwords. More
technically, we assume that U holds a long-lived key LLU ∈ {0, 1}p1(κ) which is typically some set of pairs
that consists of a human-memorable password pw ∈ D and a human perceptible authenticator (HPA) w ∈ W.
Here and in the following pi : N → N, i ∈ [1, 5] is a polynomial, κ ∈ N is a security parameter and D,W are
dictionaries.
The browser B is modeled as a PPT machine that exchanges protocol messages with S through physical
communication links and interacts with U, using various visualization techniques and user input (e.g., via HTML
forms). We assume that B holds a high-entropy long-lived secret LLB ∈ {0, 1}p2(κ). Typically, LLB consists
of a private key skB for which B maintains the corresponding public key certiﬁcate. The server S is modeled
in a classical way namely as a PPT machine with the long-lived key LLS ∈ {0, 1}p2(κ) which usually consists
of the own private key and further secrets shared with U and B. We model the communication ﬂow from B
to U through an abstract channel whose input is interfaced to the visualization function render and output is
interfaced to the human perception function recognize. We also assume that there is a channel allowing U
to provide inputs to B running on the user’s device, i.e., through common interfaces such as keyboards, mice,
touch-screens, etc. In the following we specify the relationship between the functions render and recognize.
In its simplest form, we could model the user as a deterministic Turing machine that waits for a certain, high-
entropy input (the authenticator), and then outputs a low-entropy secret (the password). By using the render
and recognize functions, we are able to express a more complex behavior of the user.
Modeling Browser Message Processing via render-Function The browser plays the role of a messenger and