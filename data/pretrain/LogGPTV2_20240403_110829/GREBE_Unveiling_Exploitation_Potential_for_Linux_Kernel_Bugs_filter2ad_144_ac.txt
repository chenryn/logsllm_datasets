that
backward taint analysis aims to ﬁnd critical structures, i.e.,
those structures involved in the error speciﬁed in the given
bug report. To do it, we again extract the call trace from the
bug report. Based on the trace, we then construct its control
ﬂow graph and propagate the taint source backward on the
graph.
Along with the backward propagation, we use the following
strategy to perform variable tainting. If the tainted variable is
a ﬁeld of a nested structure or a union variable, we further
taint its parent structure variable and treat the parent structure
as a critical structure. The reason is that the nested structure or
the union variable is part of the parent structure variable in the
memory. If a ﬁeld of the nested structure or the union variable
carries an invalid value, it likely results from inappropriate use
of its parent structure variable.
When backward taint propagation encounters a loop, we
also propagate the taint to the loop counter if the taint source
was updated inside the loop. An example of this practice is
some of the out-of-bound access errors in which the loop
counter is corrupted, unexpectedly enlarged, and eventually
used as an offset to reach out to an invalid memory region.
By extending the taint to the loop variable, we can include the
corrupted variable, which could further help us identify other
structure variables relevant to the corruption.
In this work, we terminate our backward taint process until
one of the following conditions holds. First, we terminate
our taint analysis if the backward propagation reaches out to
the deﬁnition of a tainted variable. Second, we terminate our
taint propagation if it reaches out to a system call’s entry, an
interrupt handler, or the entry of the function that starts the
scheduler of work queue. It is simply because they indicate the
sites where the kernel debugging features start to trace kernel
execution for later stage debugging. It should be noted that,
while performing backward taint propagation, we also extend
propagation to the aliases of the tainted variable. In this work,
we treat structural types of all the taint variables as the critical
structure candidates for our kernel fuzzing guidance.
B. Kernel Structure Ranking
By analyzing a kernel bug report and performing the back-
ward taint analysis above, we can identify all the kernel struc-
tures pertaining to the error in the report. However, as we will
discuss below, using the structures identiﬁed to guide kernel
fuzzing and explore the bug’s other error behaviors, we could
still confront low efﬁciency and even poor effectiveness. As a
Authorized licensed use limited to: Tsinghua University. Downloaded on August 07,2022 at 12:56:04 UTC from IEEE Xplore.  Restrictions apply. 
2082
union {
struct rb_node rbnode;
1 // definition of struct sk_buff
2 struct sk_buff {
3
4
5
6
7
8 };
};
...
struct skb_ext *extensions;
Listing 4: The code snippet indicating structure deﬁnition.
result, before applying these structures and their corresponding
objects to guide our kernel fuzzing, we need to further narrow
down the kernel structures for kernel fuzzing guidance.
Kernel structure selection. To maintain the code quality, the
Linux kernel developers employ plenty of design patterns [9].
These patterns provide a suggested practice and framework
to manage data in a commonly recognized fashion. Take
the double-linked list as an example. The struct list_head
(cid:44)→ structure can be embedded anywhere in a data structure,
and the list_head from many instances of that structure can be
linked together. As a result, the kernel objects can be managed
by standard interfaces, such as container_of which gets access
to the parent for a given child structure, and list_add/del
which performs list operations. The struct list_head is used
pervasively in the entire kernel codebase. If including such
popular structures and the corresponding objects for kernel
fuzzing guidance, the kernel fuzzer would inevitably explore
a large code space, driving the fuzzer away from its attention
to the buggy code attributing to the kernel error speciﬁed in
the report. Therefore, to preserve the kernel fuzzer’s efﬁciency
in exploring a bug’s multiple behaviors, we need to exclude
these structures from our kernel fuzzing guidance.
In addition to the structures mentioned above, Linux kernel
developers also implement many other structures pertaining
to abstract interfaces. These interfaces are coupled with im-
plementation layers in support of a large number of devices
and features. For example, the kernel creates a struct socket
(cid:44)→ for all networking services requested from userspace no
matter what protocol is speciﬁed. Such structures are also
popular, appearing in many kernel code sites across various
kernel modules. As a result, similar to struct list_head, they
should also be eliminated from the later-stage kernel fuzzing.
The structures mentioned above are just examples of popular
structures. To pinpoint and exclude them for multiple error
behavior exploration, we design a systematic approach to
ranking the kernel structures based on their popularity. At
a high level, this method constructs a graph describing the
reference relationship between kernel structures. Each node in
the graph represents a kernel structure, and the directed edges
between nodes indicate the reference relationships. On the
graph, we apply PageRank [10] which assigns each structure
a weight. In this work, we deem the structure with a higher
weight a more popular structure than others and exclude
them while performing kernel fuzzing for other error behavior
exploration.
Structure graph construction. To construct
the structure
graph mentioned above, we ﬁrst analyze all the structures
deﬁned in the kernel source code. Given one structure, we
return skb->data;
1 static inline void *__skb_push(struct sk_buff *skb, ...)
2 {
3
4 }
5
6 int ip6_fraglist_init(...)
7 {
8
9
10
11 }
struct frag_hdr *fh;
// type casting from void* to struct frag_hdr*
fh = __skb_push(skb, sizeof(struct frag_hdr));
Listing 5: The code snippet indicating type casting.
go through all its ﬁeld members. If the ﬁeld is a pointer to
another structure, we link the given structure to the referenced
structure. Suppose the ﬁeld is a nested structure or union, in
that case, we expand them repeatedly until we identify a self-
referenced structure, or there is no more nested structure/union
in the deﬁnition. We link the given structure directly to the
structure in the last layer of expansion, ignoring the union in
the middle to shrink graph size. For example, in Listing 4,
extensions is a pointer referencing struct skb_ext. We link
struct sk_buff to struct skb_ext in our graph. However, it
should be noted that struct rb_node is a self-referenced struc-
ture in an anonymous union. Following the method above,
we skip the anonymous union and link only struct sk_buff
directly to struct rb_node without further expansion.
In addition to analyzing the structure deﬁnition in kernel
source code, we also construct the structure graph with the
consideration of type casting. Since the kernel supports poly-
morphism that uses a single interface to describe different
devices and features, one abstract data type can be cast to
a more concrete type. Take the function ip6_fraglist_init
(cid:44)→ in Listing 5 as an example. In this function, skb->data
is cast from void* to struct frag_hdr* which is further used
in the IPV6 networking stack. The void* is an abstract data
type, whereas the destination structural type struct frag_hdr
(cid:44)→ * is more concretized. As such, we add one more edge
to our structure graph, which links struct skb_buff to struct
(cid:44)→ frag_hdr.
Intuition suggests that the structures with more references
are more popular ones. They are more likely to be abstract data
types. Besides, the structures referenced by popular structures
can also be popular because they can also be used in many
program sites in the kernel. For these structures, they are too
prevalent to improve our kernel fuzzer’s efﬁciency in better
exploring the error behavior of a kernel bug. To identify these
kernel structures, we utilize the PageRank algorithm on the
graph to rank their popularity. In this work, we use only those
kernel structures and objects with lower ranks to guide our
fuzzing process. In Section V, we discuss how we choose
the page-rank score threshold to distinguish popular structures
from less popular ones.
Technical discussion. While the elimination of popular kernel
structures narrows the focus of our kernel fuzzer, intuition
suggests that it could also potentially restrict our kernel fuzzer
from exploring other error behaviors for a given kernel bug.
On the one hand, if the removed popular structures are the root
Authorized licensed use limited to: Tsinghua University. Downloaded on August 07,2022 at 12:56:04 UTC from IEEE Xplore.  Restrictions apply. 
2083
cause of the kernel bug, our fuzzer may no longer reach out to
them and thus miss the opportunity to trigger the bug of our
interest. On the other hand, if most of the kernel bugs’ root
causes are popular structures, our proposed technique might
have only limited utility in helping a bug ﬁnd its multiple error
behaviors.
In this work, we argue the concerns above are not likely to
be raised in the real world. First, based on our observation
of hundreds of real-world kernel bugs, the root causes of
most kernel bugs tie to less popular structures. As such, the
removal of popular structures does not negatively inﬂuence
the fuzzer in triggering the bug of our interest. Second, even
if the eliminated popular structures are related to the root cause
of our interest’s kernel bug, having the fuzzer focused on
those less popular structures can still allow us to reach out
to some objects in the popular structural types. The reason is
that less popular structures are usually composed of popular
ones (e.g., the rare structure struct napi_struct contains the
popular structure struct hrtimer in Listing 1). Paying attention
to those less popular structures still provides opportunities
to touch popular structures through fewer instances of these
structures. In Section VI, we show several cases in which the
corresponding bugs’ root causes are relevant to those removed
popular kernel structures. We demonstrate that our fuzzing
approach can still trigger our interest’s bugs and explore their
other error behaviors even for those cases.
C. Object-driven Kernel Fuzzing
With the critical structures identiﬁed, we now discuss how
we utilize these structures to facilitate kernel fuzzing and thus
explore multiple error behaviors for a single kernel bug.
Instrumentation. Conventional kernel fuzzing methods in-
strument tracing functions to keep track of basic blocks that
have been executed. In this work, our fuzzing mechanism
preserves this instrumentation ability and, further, introduces
one additional instrumentation component. Our instrumenta-
tion component is designed as a compiler plugin. The plugin
examines each statement in basic blocks and identiﬁes those
basic blocks that take the responsibility of the allocation, de-
allocation, and the usage of critical objects (i.e., the objects
in the type of critical structures). More speciﬁcally, the in-
strumentation component introduces a new tracing function
that replaces the most signiﬁcant 16 bits of the recorded
basic block address with a magic number to differentiate these
basic blocks from others. With this instrumentation along with
the inherited one, by observing the most signiﬁcant 16 bits
of addresses in the code coverage feedback, we can easily
pinpoint which basic block pertaining to the critical objects is
under the operation of the corresponding fuzzing program.
Seed selection. With the instrumentation’s facilitation above,
when running a fuzzing program, we can easily determine
whether it reaches out to a critical object. Once we identify
a new critical object coverage, we can add the corresponding
fuzzing program into the corpus of our seed fuzzing programs.
In this work, we include the mutated seed program or the
newly generated seed program into the seed corpus only if
1 r0 = openat(...,
2 ’/dev/dsp1\x00’);
3 ioctl(r0, ...);
4 write(r0, ...);
5 read(r0, ...);
1 // initial PoC: max = -1
2 bpf$MAP_CREATE(...,
3
4 // exit triggers GFP
5 exit(0);
@max=0xffffffffffffffff);
(a) 7022420
(b) 692a8c2
TABLE I: The example code snippets extracted from the PoC
programs in two different kernel bug reports – 7022420 [11]
and 692a8c2 [12].
one of the following two conditions holds. First, the program
reaches out to an unseen basic block involving critical object
operations. Second, at least one system call in the program
covers more code, and the same system call has demonstrated
critical object operation in previous fuzzing. It should be
noted that we include the second condition because this allows
kernel fuzzing to accumulate kernel states and thus increase
the possibility for future mutations to reach out to unseen basic
blocks involving critical objects.
Seed generation & mutation. In this work, we initialize
the seed corpus with the PoC program enclosed in the bug
report under our examination. Every time, when generating
a new seed fuzzing program, we assemble the new fuzzing
program by using only the system calls that have already
been included in the seed corpus. It should be noted that this
is very different from the seed fuzzing program generation
method used in the state-of-the-art fuzzing technique (e.g.,
Syzkaller), which generates a seed fuzzing program by not
only adopting the system calls enclosed in the corpus but
also bringing in the new system calls. The reason behind our
design change is that exploring multiple error behaviors of
a kernel bug requires triggering a critical object accessing
under different contexts or through different execution paths.
Randomly introducing new system calls into the new seed
fuzzing program could enlarge the code coverage that the
fuzzing program can explore. However, it inevitably detours
the fuzzing program away from the critical objects.
Intuition suggests that using the aforementioned seed gen-
eration approach alone is not likely to explore a sufﬁcient
number of contexts and paths pertaining to the critical objects.
As such, we further introduce the mutation mechanism used
in the existing kernel fuzzing technique (i.e., Syzkaller). This
mutation mechanism introduces into the seed fuzzing program
new system calls that are relevant to the system calls already
enclosed in the seed corpus. In this way, we expect
the
fuzzing program could still stick with the critical object and,
at the same time, diversify the execution contexts or the paths
towards the object.
Mutation optimization. When performing the mutation for a
fuzzing program, the mutation mechanism of Syzkaller utilizes
pre-deﬁned templates to guide the synthesis of new fuzzing
programs. A template speciﬁes the dependency between sys-
tem calls and the argument format of corresponding system
calls. For example, Syzkaller’s template speciﬁes that
the
system call read requires a resource (i.e., a ﬁle descriptor)
Authorized licensed use limited to: Tsinghua University. Downloaded on August 07,2022 at 12:56:04 UTC from IEEE Xplore.  Restrictions apply. 
2084
as one of its arguments, and the syscall openat, as well
as the system call socket, will generate the corresponding
resource. Under the guidance of this template, Syzkaller could
perform mutation against a fuzzing program by appending
the system call read or the system call socket to the system
call openat. The mutation under template guidance ensures the
seed program is legitimate and thus avoids the kernel’s early
rejection against the fuzzing program.
As is mentioned above, our mutation mechanism borrows
the method used in Syzkaller. As we will show in Section VI,
while this approach is useful in avoiding generating invalid
kernel fuzzing programs, it is still inefﬁcient and sometimes
ineffective in guiding our kernel fuzzer to expose multiple
behaviors for a single kernel bug. As we elaborate below, the
reasons behind this are two folds.
First, while performing a fuzzing program mutation, the
Syzkaller attempts to introduce various system calls rele-
vant to the seed program and randomly manipulate system
calls’ arguments. However, we note that both the resource
and arguments that system calls operate are necessary for
successfully triggering a target kernel bug. Mutation without
the consideration of these two factors would inevitably incur
low effectiveness in exploring multiple error behaviors.
Take the case depicted in Table Ia as the ﬁrst example.
The table shows a code snippet indicating a PoC program
that triggers a kernel bug [11]. Taking this PoC as a seed
program and performing mutation, Syzkaller inserts the system