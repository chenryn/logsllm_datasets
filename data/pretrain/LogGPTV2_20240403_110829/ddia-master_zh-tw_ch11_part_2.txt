许多讯息传递系统使用生产者和消费者之间的直接网路通讯，而不透过中间节点：
* UDP 组播广泛应用于金融行业，例如股票市场，其中低时延非常重要【8】。虽然 UDP 本身是不可靠的，但应用层的协议可以恢复丢失的资料包（生产者必须记住它传送的资料包，以便能按需重新发送资料包）。
* 无代理的讯息库，如 ZeroMQ 【9】和 nanomsg 采取类似的方法，透过 TCP 或 IP 多播实现释出 / 订阅讯息传递。
* StatsD 【10】和 Brubeck 【7】使用不可靠的 UDP 讯息传递来收集网路中所有机器的指标并对其进行监控。（在 StatsD 协议中，只有接收到所有讯息，才认为计数器指标是正确的；使用 UDP 将使得指标处在一种最佳近似状态【11】。另请参阅 “[TCP 与 UDP](ch8.md#TCP与UDP)”
* 如果消费者在网路上公开了服务，生产者可以直接传送 HTTP 或 RPC 请求（请参阅 “[服务中的资料流：REST 与 RPC](ch4.md#服务中的资料流：REST与RPC)”）将讯息推送给使用者。这就是 webhooks 背后的想法【12】，一种服务的回拨 URL 被注册到另一个服务中，并且每当事件发生时都会向该 URL 发出请求。
尽管这些直接讯息传递系统在设计它们的环境中执行良好，但是它们通常要求应用程式码意识到讯息丢失的可能性。它们的容错程度极为有限：即使协议检测到并重传在网路中丢失的资料包，它们通常也只是假设生产者和消费者始终线上。
如果消费者处于离线状态，则可能会丢失其不可达时传送的讯息。一些协议允许生产者重试失败的讯息传递，但当生产者崩溃时，它可能会丢失讯息缓冲区及其本应传送的讯息，这种方法可能就没用了。
#### 讯息代理
一种广泛使用的替代方法是透过 **讯息代理**（message broker，也称为 **讯息伫列**，即 message queue）传送讯息，讯息代理实质上是一种针对处理讯息流而最佳化的资料库。它作为伺服器执行，生产者和消费者作为客户端连线到伺服器。生产者将讯息写入代理，消费者透过从代理那里读取来接收讯息。
透过将资料集中在代理上，这些系统可以更容易地容忍来来去去的客户端（连线，断开连线和崩溃），而永续性问题则转移到代理的身上。一些讯息代理只将讯息储存在记忆体中，而另一些讯息代理（取决于配置）将其写入磁碟，以便在代理崩溃的情况下不会丢失。针对缓慢的消费者，它们通常会允许无上限的排队（而不是丢弃讯息或背压），尽管这种选择也可能取决于配置。
排队的结果是，消费者通常是 **非同步（asynchronous）** 的：当生产者传送讯息时，通常只会等待代理确认讯息已经被快取，而不等待讯息被消费者处理。向消费者递送讯息将发生在未来某个未定的时间点 —— 通常在几分之一秒之内，但有时当讯息堆积时会显著延迟。
#### 讯息代理与资料库的对比
有些讯息代理甚至可以使用 XA 或 JTA 参与两阶段提交协议（请参阅 “[实践中的分散式事务](ch9.md#实践中的分散式事务)”）。这个功能与资料库在本质上非常相似，尽管讯息代理和资料库之间仍存在实践上很重要的差异：
* 资料库通常保留资料直至显式删除，而大多数讯息代理在讯息成功递送给消费者时会自动删除讯息。这样的讯息代理不适合长期的资料储存。
* 由于它们很快就能删除讯息，大多数讯息代理都认为它们的工作集相当小 —— 即伫列很短。如果代理需要缓冲很多讯息，比如因为消费者速度较慢（如果记忆体装不下讯息，可能会溢位到磁碟），每个讯息需要更长的处理时间，整体吞吐量可能会恶化【6】。
* 资料库通常支援次级索引和各种搜寻资料的方式，而讯息代理通常支援按照某种模式匹配主题，订阅其子集。虽然机制并不一样，但对于客户端选择想要了解的资料的一部分，都是基本的方式。
* 查询资料库时，结果通常基于某个时间点的资料快照；如果另一个客户端随后向资料库写入一些改变了查询结果的内容，则第一个客户端不会发现其先前结果现已过期（除非它重复查询或轮询变更）。相比之下，讯息代理不支援任意查询，但是当资料发生变化时（即新讯息可用时），它们会通知客户端。
这是关于讯息代理的传统观点，它被封装在诸如 JMS 【14】和 AMQP 【15】的标准中，并且被诸如 RabbitMQ、ActiveMQ、HornetQ、Qpid、TIBCO 企业讯息服务、IBM MQ、Azure Service Bus 和 Google Cloud Pub/Sub 所实现 【16】。
#### 多个消费者
当多个消费者从同一主题中读取讯息时，有两种主要的讯息传递模式，如 [图 11-1](../img/fig11-1.png) 所示：
* 负载均衡（load balancing）
  每条讯息都被传递给消费者 **之一**，所以处理该主题下讯息的工作能被多个消费者共享。代理可以为消费者任意分配讯息。当处理讯息的代价高昂，希望能并行处理讯息时，此模式非常有用（在 AMQP 中，可以透过让多个客户端从同一个伫列中消费来实现负载均衡，而在 JMS 中则称之为 **共享订阅**，即 shared subscription）。
* 扇出（fan-out）
  每条讯息都被传递给 **所有** 消费者。扇出允许几个独立的消费者各自 “收听” 相同的讯息广播，而不会相互影响 ——  这个流处理中的概念对应批处理中多个不同批处理作业读取同一份输入档案 （JMS 中的主题订阅与 AMQP 中的交叉系结提供了这一功能）。
![](../img/fig11-1.png)
**图 11-1 （a）负载平衡：在消费者间共享消费主题；（b）扇出：将每条讯息传递给多个消费者。**
两种模式可以组合使用：例如，两个独立的消费者组可以每组各订阅同一个主题，每一组都共同收到所有讯息，但在每一组内部，每条讯息仅由单个节点处理。
#### 确认与重新传递
消费者随时可能会崩溃，所以有一种可能的情况是：代理向消费者递送讯息，但消费者没有处理，或者在消费者崩溃之前只进行了部分处理。为了确保讯息不会丢失，讯息代理使用 **确认（acknowledgments）**：客户端必须显式告知代理讯息处理完毕的时间，以便代理能将讯息从伫列中移除。
如果与客户端的连线关闭，或者代理超出一段时间未收到确认，代理则认为讯息没有被处理，因此它将讯息再递送给另一个消费者。（请注意可能发生这样的情况，讯息 **实际上是** 处理完毕的，但 **确认** 在网路中丢失了。需要一种原子提交协议才能处理这种情况，正如在 “[实践中的分散式事务](ch9.md#实践中的分散式事务)” 中所讨论的那样）
当与负载均衡相结合时，这种重传行为对讯息的顺序有种有趣的影响。在 [图 11-2](../img/fig11-2.png) 中，消费者通常按照生产者传送的顺序处理讯息。然而消费者 2 在处理讯息 m3 时崩溃，与此同时消费者 1 正在处理讯息 m4。未确认的讯息 m3 随后被重新发送给消费者 1，结果消费者 1 按照 m4，m3，m5 的顺序处理讯息。因此 m3 和 m4 的交付顺序与生产者 1 的传送顺序不同。
![](../img/fig11-2.png)
**图 11-2 在处理 m3 时消费者 2 崩溃，因此稍后重传至消费者 1**
即使讯息代理试图保留讯息的顺序（如 JMS 和 AMQP 标准所要求的），负载均衡与重传的组合也不可避免地导致讯息被重新排序。为避免此问题，你可以让每个消费者使用单独的伫列（即不使用负载均衡功能）。如果讯息是完全独立的，则讯息顺序重排并不是一个问题。但正如我们将在本章后续部分所述，如果讯息之间存在因果依赖关系，这就是一个很重要的问题。