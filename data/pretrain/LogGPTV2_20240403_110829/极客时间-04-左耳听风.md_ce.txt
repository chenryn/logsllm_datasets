# 小结好了，我们来总结一下今天分享的主要内容。首先，限流的目的是为了保护系统不在过载的情况下导致问题。接着讲了几种限流的策略。然后讲了，限流的算法，包括计数器、队列、漏斗和令牌桶。然后讨论了如何基于响应时间来限流。最后，我总结了限流设计的要点。下篇文章中，我们讲述降级设计。希望对你有帮助。也欢迎你分享一下你实现过怎样的限流机制？文末给出了《分布式系统设计模式》系列文章的目录，希望你能在这个列表里找到自己感兴趣的内容。-   弹力设计篇    -   [认识故障和弹力设计](https://time.geekbang.org/column/article/3912)    -   [隔离设计        Bulkheads](https://time.geekbang.org/column/article/3917)    -   [异步通讯设计        Asynchronous](https://time.geekbang.org/column/article/3926)    -   [幂等性设计        Idempotency](https://time.geekbang.org/column/article/4050)    -   [服务的状态        State](https://time.geekbang.org/column/article/4086)    -   [补偿事务 Compensating        Transaction](https://time.geekbang.org/column/article/4087)    -   [重试设计 Retry](https://time.geekbang.org/column/article/4121)    -   [熔断设计 Circuit        Breaker](https://time.geekbang.org/column/article/4241)    -   [限流设计        Throttle](https://time.geekbang.org/column/article/4245)    -   [降级设计        degradation](https://time.geekbang.org/column/article/4252)    -   [弹力设计总结](https://time.geekbang.org/column/article/4253)-   管理设计篇    -   [分布式锁 Distributed        Lock](https://time.geekbang.org/column/article/5175)    -   [配置中心 Configuration        Management](https://time.geekbang.org/column/article/5819)    -   [边车模式        Sidecar](https://time.geekbang.org/column/article/5909)    -   [服务网格 Service        Mesh](https://time.geekbang.org/column/article/5920)    -   [网关模式        Gateway](https://time.geekbang.org/column/article/6086)    -   [部署升级策略](https://time.geekbang.org/column/article/6283)-   性能设计篇    -   [缓存 Cache](https://time.geekbang.org/column/article/6282)    -   [异步处理        Asynchronous](https://time.geekbang.org/column/article/7036)    -   [数据库扩展](https://time.geekbang.org/column/article/7045)    -   [秒杀 Flash        Sales](https://time.geekbang.org/column/article/7047)    -   [边缘计算 Edge        Computing](https://time.geekbang.org/column/article/7086)![](Images/1c1e992cf41f5294df097aabed82f9e4.png){savepage-src="https://static001.geekbang.org/resource/image/fc/e9/fcc761001867c60f526665e237f831e9.jpg"}
# 50 \| 弹力设计篇之"降级设计"所谓的降级设计（Degradation），本质是为了解决资源不足和访问量过大的问题。当资源和访问量出现矛盾的时候，在有限的资源下，为了能够扛住大量的请求，我们就需要对系统进行降级操作。也就是说，暂时牺牲掉一些东西，以保障整个系统的平稳运行。我记得我在伦敦参与诺丁山狂欢节的时候，以及看阿森纳英超足球比赛的时候，散场时因为人太多，所有的公交系统（公交车，地铁）完全免费，就是为了让人通行得更快。而且早在散场前，场外就备着一堆公交车和地铁了，这样就是为了在最短时间内把人疏散掉。虽然亏掉了一些钱，但是相比因为人员拥塞造成道路交通拥塞以及还可能出现的一些意外情况所造成的社会成本的损失，公交免费策略真是很明智的做法。与此类似，我们的系统在应对一些突发情况的时候也需要这样的降级流程。``{=html}一般来说，我们的降级需要牺牲掉的东西有：-   **降低一致性**。从强一致性变成最终一致性。-   **停止次要功能**。停止访问不重要的功能，从而释放出更多的资源。-   **简化功能**。把一些功能简化掉，比如，简化业务流程，或是不再返回全量数据，只返回部分数据。
# 降低一致性我们要清楚地认识到，这世界上大多数系统并不是都需要强一致性的。对于降低一致性，把强一致性变成最终一致性的做法可以有效地释放资源，并且让系统运行得更快，从而可以扛住更大的流量。一般来说，会有两种做法，一种是简化流程的一致性，一种是降低数据的一致性。
## 使用异步简化流程举个例子，比如电商的下单交易系统，在强一致的情况下，需要结算账单，扣除库存，扣除账户上的余额（或发起支付），最后进行发货流程，这一系列的操作。如果需要是强一致性的，那么就会非常慢。尤其是支付环节可能会涉及银行方面的接口性能，就像双11 那样，银行方面出问题会导致支付不成功，而订单流程不能往下走。在系统降级时，我们可以把这一系列的操作做成异步的，快速结算订单，不占库存，然后把在线支付降级成用户到付，这样就省去支付环节，然后批量处理用户的订单，向用户发货，用户货到付款。![](Images/e00177a6091e1a145d09199813640412.png){savepage-src="https://static001.geekbang.org/resource/image/2c/43/2c8ea19d132f2efb333ea9e741ea8543.png"}如上图所示，一开始需要的全同步的方式，降级成了全异步的方式，库存从单笔强一致性也变成了多笔最终一致性，如果库存不够了，就只能根据先来后到取消订单了。而支付也从最开始的下单请求时的强一致性，变成了用户到付的最终一致性。一般来说，功能降级都有可能会损害用户的体验，所以，最好给出友好的用户提示。比如，"系统当前繁忙，您的订单已收到，我们正努力为您处理订单中，我们会尽快给您发送订单确认通知......还请见谅"诸如此类的提示信息。
## 降低数据的一致性降低数据的一致性一般来说会使用缓存的方式，或是直接就去掉数据。比如，在页面上不显示库存的具体数字，只显示有还是没有库存这两种状态。对于缓存来说，可以有效地降低数据库的压力，把数据库的资源交给更重要的业务，这样就能让系统更快速地运行。对于降级后的系统，不再通过数据库获取数据，而是通过缓存获取数据。关于缓存的设计模式，我在CoolShell中有一篇叫《缓存更新的套路》的文章中讲述过缓存的几种更新模式，你有兴趣的话可以前往一读。在功能降级中，我们一般使用Cache Aside 模式或是 Read Through 模式。也就是下图所示的这个策略。![](Images/f0dc44c9980ba9db6cdb2ccdee47dc66.png){savepage-src="https://static001.geekbang.org/resource/image/bd/c4/bdf7522a231ec2c1136a70f07db0c5c4.png"}-   **失效**：应用程序先从 cache    取数据，如果没有得到，则从数据库中取数据，成功后，放到缓存中。-   **命中**：应用程序从 cache 中取数据，取到后返回。-   **更新**：先把数据存到数据库中，成功后，再让缓存失效。Read Through模式就是在查询操作中更新缓存，也就是说，当缓存失效的时候（过期或 LRU换出），Cache Aside 是由调用方负责把数据加载到缓存，而 Read Through则用缓存服务自己来加载，从而对应用方是透明的。