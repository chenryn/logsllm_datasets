their Bulletproofs into a single proof.
1.2.5. Short Non-Interactive Protocols for Arithmetic
Circuits without a Trusted Setup. Non-interactive zero-
knowledge protocols for general statements are not possible
without using a common reference string, which should be
known by both the prover and the veriﬁer. Many efﬁcient
non-interactive zero-knowledge proofs and arguments for
arithmetic circuit satisﬁability have been developed [4]–[6],
[32]–[34], and highly efﬁcient protocols are known. How-
ever, aside from their performance, these protocols differ in
the complexity of their common reference strings. Some,
such as those in [4], are highly structured, and sometimes
feature a trapdoor, while some are simply chosen uniformly
at random. Security proofs assume that the common refer-
ence string was honestly generated. In practice, the common
reference string can be generated by a trusted third party, or
using a secure multi-party computation protocol. The ladder
helps to alleviate concerns about embedded trapdoors, as
with the trusted setup ceremony used to generate the public
parameters for [35].
Zero-knowledge SNARKs have been the subject of ex-
tensive research [4], [5], [36]–[40]. They generate constant-
sized proofs for any statement, and have extremely fast ver-
iﬁcation time. However, they have highly complex common
reference strings which require lengthy and computation-
ally intensive protocols [41] to generate distributively. They
also rely on strong unfalsiﬁable assumptions such as the
knowledge-of-exponent assumption.
A uniformly-random common reference strings, on the other
hand, can be derived from common random strings, like the
digits of π or by assuming that hash functions behave like
random oracle. Examples of non-interactive protocols that
do not require a trusted setup include [6], [7], [32], [42],
[43].
Ben-Sasson et al. present a proof system [44] and im-
plementation [43] called Scalable Computational Integrity
(SCI). While SCI has a simple setup, and relies only on
collision-resistant hash functions, the system is not zero-
knowledge and still experiences worse performance than [4],
[7]. The proof sizes are roughly 42 MB large in practice
for a reasonable circuit. In subsequent work Ben-Sasson
et al. presented STARKs [6], which are zero-knowledge
and more efﬁcient
than SCI. However even with these
improvements the proof size is still over 200 KB (and grows
logarithmically) at only 60-bit security for a circuit of size
217. A Bulletproof for such a circuit at twice the security
would be only about 1 KB. Constructing STARKs is also
very costly in terms of memory requirements because of the
large FFT that is required to make proving efﬁcient. Ames
et al. [45] presented a proof system with linear veriﬁcation
time but only square root proof complexity building on the
MPC in the head technique. Wahby [46] recently present a
cryptographic zero-knowledge proof system which achieves
square root veriﬁer complexity and proof size based on the
proofs for muggles [47] techniques in combination with a
sub-linear polynomial commitment scheme.
1.3. Additional Related Work
Much of the research related to electronic payments
that predates Bitcoin [48] focused on efﬁcient anonymous
and conﬁdential payments [20], [49] . With the advent of
blockchain-based cryptocurrencies, the question of privacy
and conﬁdentiality in transactions has gained a new rele-
vance. While the original Bitcoin paper [48] claimed that
Bitcoin would provide anonymity through pseudonymous
addresses early work on Bitcoin showed that the anonymity
is limited [50], [51]. Given these limitations, various meth-
ods have been proposed to help improve the privacy of
Bitcoin transactions. CoinJoin [14], proposed by Maxwell,
allows users to hide information about the amounts of trans-
actions by merging two or more transactions. This ensures
that among the participants who join their transactions, it
is impossible to tell which transaction inputs correspond
to which transaction outputs. However, users do require
some way of searching for other users, and furthermore,
should be able to do so without relying on a trusted third
party. CoinShufﬂe [52] tried to fulﬁll this requirement by
taking developing the ideas of CoinJoin and proposing a new
Bitcoin mixing protocol which is completely decentralized.
Monero [53] is a cryptocurrency which employs crypto-
graphic techniques to achieve strong privacy guarantees.
These include stealth addresses, ring-signatures [54], and
318
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:29:05 UTC from IEEE Xplore.  Restrictions apply. 
transactions [13]. ZeroCash [35] offers
ring conﬁdential
optimal privacy guarantees but comes at the cost of expen-
sive transaction generation and the requirement of a trusted
setup.
Range proofs. Range proofs are proofs that a secret value,
which has been encrypted or committed to, lies in a certain
interval. Range proofs do not leak any information about
the secret value, other than the fact that they lie in the
interval. Lipmaa [55] presents a range proof which uses
integer commitments, and Lagrange’s four-square theorem
which states that every positive integer y can be expressed
as a sum of four squares. Groth [56] notes that the argument
can be optimized by considering 4y ` 1, since integers of
this form only require three squares. The arguments require
only a constant number of commitments. However, each
commitment is large, as the security of the argument relies
on the Strong RSA assumption. Additionally, a trusted setup
is required to generate the RSA modulus or a prohibitively
large modulus needs to be used [57]. Camenisch et al. [58]
use a different approach. The veriﬁer provides signatures on
a small set of digits. The prover commits to the digits of
the secret value, and then proves in zero-knowledge that the
value matches the digits, and that each commitment corre-
sponds to one of the signatures. They show that their scheme
can be instantiated securely using both RSA accumulators
[59] and the Boneh-Boyen signature scheme [60]. However,
“
these range proofs require a trusted setup. Approaches based
on the n-ary digits of the secret value are limited to proving
0, nk ´ 1
.
that the secret value is in an interval of the form
One can produce range proofs for more general intervals
by using homomorphic commitments to translate intervals,
and by using a combination of two different range proofs
to conduct range proofs for intervals of different widths.
However, [61] presented an alternative digital decomposition
which enables an interval of general width to be handled
using a single range proof.
‰
2. Preliminaries
Before we present Bulletproofs, we ﬁrst review some of
the underlying tools. In what follows, a PPT adversary A is
a probabilistic interactive Turing Machine that runs in poly-
nomial time in the security parameter λ. We will drop the
security parameter λ from the notation when it is implicit.
2.1. Commitments
Deﬁnition 1 (Commitment). A non-interactive commit-
ment scheme consists of a pair of probabilistic polyno-
mial time algorithms pSetup, Comq. The setup algorithm
pp Ð Setupp1λq generates public parameters pp for the
scheme, for security parameter λ. The commitment algo-
rithm Compp deﬁnes a function Mpp ˆ Rpp Ñ Cpp for
message space Mpp, randomness space Rpp and commit-
ment space Cpp determined by pp. For a message x P Mpp,
the algorithm draws r $ÐÝ Rpp uniformly at random, and
computes commitment com “ Compppx; rq.
ˇˇˇˇˇˇˇˇˇˇP
»
————–b “ b
1
ˇˇˇˇˇˇˇˇˇˇ
Ð Apppq,
pp Ð Setupp1λq;
px0, x1q P M2
b $ÐÝ t0, 1u, r $ÐÝ Rpp,
com “ Compxb; rq,
1 Ð Appp, comq
pp
b
ﬁ
ﬃﬃﬃﬃﬂ ´ 1
2
ˇˇˇˇˇˇˇˇˇˇ
ď μpλq
Deﬁnition 2 (Homomorphic Commitments). A homomor-
phic commitment scheme is a non-interactive commitment
scheme such that Mpp, Rpp and Cpp are all abelian groups,
and for all x1, x2 P Mpp, r1, r2 P Rpp, we have
Compx1; r1q ` Compx2; r2q “ Compx1 ` x2; r1 ` r2q
Deﬁnition 3 (Hiding Commitment). A commitment scheme
is said to be hiding if for all PPT adversaries A there exists
a negligible function μpλq such that.
where the probability is over b, r, Setup and A. If μpλq “ 0
then we say the scheme is perfectly hiding.
Deﬁnition 4 (Binding Commitment). A commitment scheme
is said to be binding if for all PPT adversaries A there exists
ﬁ
a negligible function μ such that.
ﬂ ď μpλq
where the probability is over Setup and A. If μpλq “ 0
then we say the scheme is perfectly binding.
ˇˇˇˇˇˇ pp Ð Setupp1λq,
»
–Compx0; r0q
“ Compx1; r1q
^x0 ‰ x1
x0, x1, r0, r1 Ð Apppq
P
In what follows,
the order p of the groups used is
implicitly dependent on the security parameter λ to ensure
that discrete log in these groups is intractable for PPT
adversaries.
Deﬁnition 5 (Pedersen Commitment). Mpp, Rpp “ Zp,
Cpp “ G of order p.
Setup : g, h $ÐÝ G
Compx; rq “ pgxhrq
Deﬁnition 6 (Pedersen Vector Commitment). Mpp “ Zn
p ,
Rpp “ Zp, Cpp “ G with G of order p
Setup : g “ pg1, . . . , gnq, h $ÐÝ G
Compx “ px1, . . . , xnq; rq “ hrgx “ hr
i P G
ś
i g
xi
The Pedersen vector commitment is perfectly hiding
and computationally binding under the discrete logarithm
assumption. We will often set r “ 0, in which case the
commitment is binding but not hiding.
2.2. Zero-Knowledge Arguments of Knowledge
Bulletproofs are zero-knowledge arguments of knowl-
edge. A zero-knowlege proof of knowledge is a protocol in
which a prover can convince a veriﬁer that some statement
holds without revealing any information about why it holds.
A prover can for example convince a veriﬁer that a conﬁ-
dential transaction is valid without revealing why that is the
case, i.e. without leaking the transacted values. An argument
is a proof which holds only if the prover is computationally
bounded and certain computational hardness assumptions
319
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:29:05 UTC from IEEE Xplore.  Restrictions apply. 
hold. We give a formal deﬁnition of zero-knowledge argu-
ments of knowledge in Appendix A
2.3. Notation
p
p is denoted as A ¨ b “ c P Zn
Let G denote a cyclic group of prime order p, and let
Zp denote the ring of integers modulo p. Let Gn and Zn
p be
vector spaces of dimension n over G and Zp respectively.
p denote Zpzt0u. Generators of G are denoted by
‹
Let Z
g, h, v, u P G. Group elements which represent commit-
ments are capitalized and blinding factors are denoted by
Greek letters, i.e. C “ gahα P G is a Pedersen commitment
to a. If not otherwise clear from context x, y, z P Z
‹
p are
uniformly distributed challenges. Throughout the paper, we
will also be using vector notations deﬁned as follows. Bold
font denotes vectors, i.e. a P Fn is a vector with elements
a1, . . . , an P F. Capitalized bold font denotes matrices, i.e.
A P Fnˆm is a matrix with n rows and m columns such
that ai,j is the element of A in the ith row and jth column.
For a scalar c P Zp and a vector a P Zn
xa, by “řn
p , we denote by
b “ c¨ a P Zn
p the vector where bi “ c¨ ai. Furthermore, let
i“1 ai ¨ bi denote the inner product between two
vectors a, b P Fn, and a ˝ b “ pa1 ¨ b1, . . . , an ¨ bnq P Fn
the Hadamard product or entry wise multiplication of two
vectors. The matrix product between a matrix A P Znˆm
ci “ řm
and a vector b P Zm
p with
j“1 ai,j ¨ bj P Zp. Note that the product is not
such that dj “řn
commutative, i.e. for c P Zn
p : c ¨ A “ d P Zm
p and d P Zm
Further, we extend the vector notation to vectors of group
vector of generators then C “ ga “śn
elements. This is useful when dealing with Pedersen vector
commitments. Speciﬁcally let g “ pg1, . . . , gnq P Gn be a
ai
i“1 g
is a binding
(but not hiding) commitment to vector a P Zn
i
p . Given such
commitment C and a vector b P Zn
such that C “śn
p with non-zero entries,
it is possible to view C as a new commitment to a˝ b. This
ai¨bi.
is done by deﬁning g
The binding property of this new commitment holds if the
old commitment was binding.
Let a} b denote the concatenation of two vectors: if a P Zn
and b P Zm
p then a} b P Zn`m
p
. We denote slices of vectors
using Python notation:
ar:ks “ pa1, . . . , akq P F
, ark:s “ pak`1, . . . , anq P F
.
For k P Z
‹
p we use kn to denote the vector containing the
ﬁrst n powers of k, i.e. kn “ p1, k, k2, . . . , kn´1q P pZ‹
pqn.
For example, 2n “ p1, 2, 4, . . . , 2n´1q. Equivalently
´1qn “ p1, k
´n “ pk
(
(cid:5)pPublic Input; Witnessq : Relation
Finally, we write
to
denote the relation Relation using the speciﬁed Public Input
and Witness.
i“1 ci ¨ ai,j P Zp.
´1, . . . , k
´n`1q.
i “ g
1
pb´1
i
i“1 g
n´k
k
1
i
q
k
p
i
p
3. Improved Inner-Product Argument
Bootle et al. [7] introduced a communication efﬁcient
inner-product argument and show how it can be leveraged
320
to construct zero-knowledge proofs for arithmetic circuit
satisﬁability with low communication complexity. The ar-
gument is an argument of knowledge that the prover knows
the openings of two binding Pedersen vector commitments
that satisfy a given inner product relation.
pnq in [7] to only 2 log2
We reduce the communication complexity of the ar-
pnq, where
gument from 6 log2
n is the dimension of the two vectors. We achieve this
improvement by modifying the relation being proved. Our
argument is sound, but is not zero-knowledge. We then
show that this protocol gives a public-coin communication
efﬁcient zero-knowledge range proof on a set of committed
values, and a zero-knowledge proof system for arbitrary
arithmetic circuits (Sections 4 and 5). By applying the Fiat-
Shamir heuristic we obtain a short non-interactive proof
(Section 4.4).
Overview. The inner product argument takes as input a
binding vector commitment to the two vectors a, b P Zn
p , as
well as c P Zp, and proves that c “ xa, by. Logarithmic
communication is achieved by running log2 n iterations,
where in each iteration the the dimension of a and b is
halved.
To give some intuition, consider a simple example: for
independent generators g1, g2, suppose the veriﬁer is given
g1, g2 and a binding commitment P “ g
P G. The
prover can prove knowledge of a1, a2 by sending both values
to the veriﬁer, but we can do better. Suppose the veriﬁer
has R “ g
a1
2 . It sends to the prover a random
challenge x P Zp and they both compute:
a1
1 g
a2
2
.
g
px´2q
and P
1 “ pg
1 “ a1 ¨ x ` a2 ¨ x
1qa1
px2q ¨ P ¨ R