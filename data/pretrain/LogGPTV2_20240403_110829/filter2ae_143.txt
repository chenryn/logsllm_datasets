# 简述
XSS攻击通常指的是通过利用网页开发时留下的漏洞，通过巧妙的方法注入恶意指令代码到网页，使用户加载并执行攻击者恶意制造的网页程序。这些恶意网页程序通常是JavaScript，但实际上也可以包括Java，VBScript，ActiveX，Flash或者甚至是普通的HTML。攻击成功后，攻击者可能得到更高的权限（如执行一些操作）、私密网页内容、会话和cookie等各种内容。
# 常用的XSS攻击手段和目的
    1.盗用cookie，获取敏感信息。
    2.利用植入Flash，通过crossdomain权限设置进一步获取更高权限；或者利用Java等得到类似的操作。
    3.利用iframe、frame、XMLHttpRequest或上述Flash等方式，以（被攻击）用户的身份执行一些管理动作，或执行一些一般的操作如发微博、加好友、发私信等操作。
    4.利用可被攻击的域受到其他域信任的特点，以受信任来源的身份请求一些平时不允许的操作，如进行不当的投票活动。
    5.在访问量极大的一些页面上的XSS可以攻击一些小型网站，实现DDOS攻击的效果。
# 分类
## 反射型
    反射型跨站脚本（Reflected Cross-Site Scripting）是最常见，也是使用最广的一种，可将恶意脚本附加到 URL 地址的参数中。
    反射型 XSS 的利用一般是攻击者通过特定手法（如电子邮件），诱使用户去访问一个包含恶意代码的 URL，当受害者点击这些专门设计的链接的时候，恶意代码会直接在受害者主机上的浏览器执行。此类 XSS 通常出现在网站的搜索栏、用户登录口等地方，常用来窃取客户端 Cookies 或进行钓鱼欺骗。
## 存储型
    持久型跨站脚本（Persistent Cross-Site Scripting）也等同于存储型跨站脚本（Stored Cross-Site Scripting）。
    此类 XSS 不需要用户单击特定 URL 就能执行跨站脚本，攻击者事先将恶意代码上传或储存到漏洞服务器中，只要受害者浏览包含此恶意代码的页面就会执行恶意代码。持久型 XSS 一般出现在网站留言、评论、博客日志等交互处，恶意脚本存储到客户端或者服务端的数据库中。
## DOM型
    传统的 XSS 漏洞一般出现在服务器端代码中，而 DOM-Based XSS 是基于 DOM 文档对象模型的一种漏洞，所以，受客户端浏览器的脚本代码所影响。客户端 JavaScript 可以访问浏览器的 DOM 文本对象模型，因此能够决定用于加载当前页面的 URL。换句话说，客户端的脚本程序可以通过 DOM 动态地检查和修改页面内容，它不依赖于服务器端的数据，而从客户端获得 DOM 中的数据（如从 URL 中提取数据）并在本地执行。另一方面，浏览器用户可以操纵 DOM 中的一些对象，例如 URL、location 等。用户在客户端输入的数据如果包含了恶意 JavaScript 脚本，而这些脚本没有经过适当的过滤和消毒，那么应用程序就可能受到基于 DOM 的 XSS 攻击。
# 无任何过滤情况下
## 一些常见标签
**PS：下面我列举的标签大部分是可以自动触发js代码的，无需用户去交互，大部分情况下我们也是希望是自动触发而不是等用户去触发，还有我测试的浏览器是火狐，Chrome，IE11.0，其它的浏览器没有去测试，有兴趣的师傅可以测试一下
=。=**
### ``
    alert("xss");
### ``
### ``
    竞争焦点，从而触发onblur事件
    通过autofocus属性执行本身的focus事件，这个向量是使焦点自动跳到输入元素上,触发焦点事件，无需用户去触发
### ``
    使用open属性触发ontoggle事件，无需用户去触发
### ``
### ``
    通过autofocus属性执行本身的focus事件，这个向量是使焦点自动跳到输入元素上,触发焦点事件，无需用户去触发
### ``
### ``
### ``
### ``
利用换行符以及autofocus，自动去触发onscroll事件，无需用户去触发
### ``
### ``
     //仅限火狐
### ``
     //Chrome不行，火狐和IE都可以
### ``
    //仅限于IE
### 利用link远程包含js文件
**PS：在无CSP的情况下才可以**
### javascript伪协议
``标签
    xss
``标签
``标签
    //IE7以下
``标签
### 其它
expression属性
     // IE7以下
     //IE7以下
     // IE7以下
background属性
     //在Opera 10.5和IE6上有效
# 有过滤的情况下
## 过滤空格
用`/`代替空格
## 过滤关键字
### 大小写绕过
### 双写关键字
有些waf可能会只替换一次且是替换为空，这种情况下我们可以考虑双写关键字绕过
### 字符拼接
利用eval
利用top
### 其它字符混淆
有的waf可能是用正则表达式去检测是否有xss攻击，如果我们能fuzz出正则的规则，则我们就可以使用其它字符去混淆我们注入的代码了  
下面举几个简单的例子
    可利用注释、标签的优先级等
    1.alert("xss");//
    2.> //因为title标签的优先级比img的高，所以会先闭合title，从而导致前面的img标签无效
    3.
### 编码绕过
Unicode编码绕过
url编码绕过
Ascii码绕过
hex绕过
八进制
base64绕过
## 过滤双引号，单引号
1.如果是html标签中，我们可以不用引号。如果是在js中，我们可以用反引号代替单双引号
2.使用编码绕过，具体看上面我列举的例子，我就不多赘述了
## 过滤括号
当括号被过滤的时候可以使用throw来绕过
## 过滤url地址
### 使用url编码
### 使用IP
1.十进制IP
2.八进制IP
3.hex
4.html标签中用`//`可以代替`http://`
5.使用`\\`
    但是要注意在windows下\本身就有特殊用途，是一个path 的写法，所以\\在Windows下是file协议，在linux下才会是当前域的协议
Windows下  
Linux下  
6.使用中文逗号代替英文逗号  
如果你在你在域名中输入中文句号浏览器会自动转化成英文的逗号
    //会自动跳转到百度
# 如何防止xss
  * 过滤一些危险字符，以及转义`&  " ' /`等危险字符
  * HTTP-only Cookie: 禁止 JavaScript 读取某些敏感 Cookie，攻击者完成 XSS 注入后也无法窃取此Cookie。
  * 设置CSP(Content Security Policy)
  * 输入内容长度限制
# 后记
感觉总结的不是很全面，以后会查漏补缺，如果有师傅发现错误之处，还望斧正
# Reference
[很全的xss总结](https://blog.csdn.net/qq_29277155/article/details/51320064
"很全的xss总结")  