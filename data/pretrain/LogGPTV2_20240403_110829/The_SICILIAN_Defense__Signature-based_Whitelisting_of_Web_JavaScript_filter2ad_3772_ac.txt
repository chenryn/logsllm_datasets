tree grammar shown in Figure 1. We describe the construction of
the AST for the script snippet var x = 10,y; y = x+1; in
Figure 2. First, the node Program is generated using the produc-
tion rule (1) shown in Figure 2.a. Then, the left-hand subtree of the
AST is generated by application of the production rule (2), that is
1546(1) (cid:104)Program(cid:105)
(2) (cid:104)SourceElement(cid:105)
(3) (cid:104)FunctionDeclaration(cid:105)
(4) (cid:104)Identiﬁer(cid:105)
(5) (cid:104)FunctionBody(cid:105)
(6) (cid:104)ParameterList(cid:105)
(7) (cid:104)Statement(cid:105)
(8) (cid:104)EmptyStatement(cid:105)
(9) (cid:104)ExpresionStatement(cid:105)
(10) (cid:104)ReturnStatement(cid:105)
(11) (cid:104)Block(cid:105)
(12) (cid:104)VariableStatement(cid:105)
(13) (cid:104)VariableDeclaration(cid:105)
(14) (cid:104)Initializer(cid:105)
(15) (cid:104)Expression(cid:105)
(16) (cid:104)IfStatement(cid:105)
(17) (cid:104)Literal(cid:105)
(18) (cid:104)BinaryExpression(cid:105)
(19) (cid:104)LHSExpression(cid:105)
(20) (cid:104)AssignmentExpression(cid:105)
]
]
|= Program [(cid:104)SourceElement(cid:105)∗
|= (cid:104)FunctionDeclaration(cid:105) | (cid:104)Statement(cid:105)
|= FunctionDeclaration [(cid:104)Identiﬁer(cid:105) Structure [(cid:104)ParameterList(cid:105) (cid:104)FunctionBody(cid:105)]]
|= Identiﬁer [IdentiﬁerName]
|= Body [(cid:104)SourceElement(cid:105)∗
]
|= ParameterList [(cid:104)Identiﬁer(cid:105)∗
|= (cid:104)Block(cid:105) | (cid:104)VariableStatement(cid:105) | (cid:104)ReturnStatement(cid:105) | (cid:104)EmptyStatement(cid:105) | . . . | (cid:104)IfStatement(cid:105) | (cid:104)ExpressionStatement(cid:105)
|=
|= (cid:104)Expression(cid:105)
|= Return [(cid:104)Expression(cid:105)]?
|= Block [(cid:104)Statement(cid:105)∗
|= VariableDeclaration [(cid:104)VariableDeclaration(cid:105)+]
|= VariableDeclarator [(cid:104)Identiﬁer(cid:105) Structure [(cid:104)Initializer(cid:105)]]
|= Init [(cid:104)Expression(cid:105) | Undeﬁned]
|= (cid:104)Literal(cid:105) | (cid:104)Identiﬁer(cid:105) | (cid:104)ObjectExpression(cid:105) | (cid:104)ArrayExpression(cid:105) | (cid:104)BinaryExpression(cid:105) | . . . | (cid:104)AssignmentExpression(cid:105)
|= IfStatement [Test [(cid:104)Expression(cid:105)] Consequent [(cid:104)Statement(cid:105)] (Alternate [(cid:104)Statement(cid:105)])?]
|= Literal [value]
|= BinaryExpression [(cid:104)BinaryOperator(cid:105) (cid:104)LHSExpression(cid:105) (cid:104)RHSExpression(cid:105)]
|= left [(cid:104)Expression(cid:105)]
|= AssignmentExpression [(cid:104)AssignmentOperator(cid:105) (cid:104)LHSExpression(cid:105) (cid:104)RHSExpression(cid:105)]
]
Figure 1: A part of the Tree Grammar for AST construction. This grammar has been derived from BNF JavaScript grammar. The nodes of the AST are shown
as boldfaced letters (terminals) and the non-terminals are shown between angle brackets <>.
 to  and then rule (7) (Figure 2.b) to
generate the non-terminal . Note that no new
nodes have been added to the AST after the Program node because
no new terminals have been produced. On application of the rule
(12), a child node of Program is created called VariableDecla-
ration which in turn produces the VariableDeclarator node (rule
(13)) with children  and the node Structure. The child
of Structure, which is a nonterminal , is also gener-
ated (Figure 2.c). Applying (4), (14), (15) and (17) will generate
the syntax subtree corresponding to var x = 10 part of the snip-
pet (Figure 2.d). Similarly, the tree-grammar will generate the en-
tire AST as shown in Figure 2.e by application of rules shown in
Figure 1.
A simple signature scheme here is to treat the structure (AST)
obtained by parsing as the signature for the given source code. We
describe the mechanism to represent this structure with a unique
hash value in Section 3.5.1. However, we would also like to relax
the signature mechanism a bit more such that it allows two struc-
turally similar pieces of code to have the same hash value (signa-
ture) — thereby allowing syntactic changes in the code while pre-
serving the semantics. We achieve this by allowing two forms of
isomorphism on the ASTs and explain the isomorphisms in Sec-
tions 3.5.2 and 3.5.3. Note that these isomorphisms are designed in
a way to be secure in the sense that whenever we treat two pieces
of code to have the same signature they only differ in syntax and
will not differ in the semantics. We will revisit these security points
when we describe our isomorphisms.
3.5 Structural Signature
Structural signature is a signature mechanism for representing
the structure (AST) of the code with a unique hash value. Our
mechanism for computing structural signatures, denoted as S#, is
based on the techniques used in set ﬁngerprinting [33] and Merkle
Hash Trees [35]. We detail the algorithm for computing structural
signatures in Algorithm 1 and describe the isomorphisms in Sec-
tion 3.5.2 and Section 3.5.3.
3.5.1 Bottom-Up Computation
After obtaining the AST of the script code, we traverse the tree
depth-ﬁrst from left to right and perform a bottom-up signature
computation as shown in the Algorithm 1. We compute the struc-
tural signatures as follows. Consider a node β labeled lβ and chil-
dren b1, b2 . . . bk with structural signatures S#(b1), S#(b2), . . . ,
S#(bk). The structural signature for node β is deﬁned as
S#(β) = H(H(lβ)||S#(b1)||S#(b2)|| . . .||S#(bk))
(1)
where H is a cryptographically secure hash function like SHA256.
This is represented in the lines 16-21 in the algorithm. For the base
case where the node is a non-identiﬁer leaf node, we just compute
its hash as its structural signature represented in the lines 5-6. For
when the node is an identiﬁer leaf node, we handle it Section 3.5.3.
Our mechanism computes the structural signature for the entire
tree in a bottom-up fashion. The structural signature of the root
node is the signature for the entire AST and hence of the corre-
sponding code.
3.5.2
This is the ﬁrst isomorphism that we deﬁne on the AST which
allows ASTs of two programs differing in the order of the nodes to
have the same signature. The mechanism described in Section 3.5.1
can be relaxed to achieve this isomorphism. While computing the
structural signature of a node, we sort the structural signatures of
its children and then concatenate them in the sorted order. For the
example node β mentioned in Section 3.5.1, the structural signature
will be redeﬁned as follows:
Isomorphism 1: Node Permutations
S#(β) = H(H(lβ)||S#(bπ(1))|| . . .||S#(bπ(k)))
where π(i) is the index of the ith node in the sorted order.
However, enforcing such isomorphism for every node type might
lead to semantic differences. For example, the ordering of children
nodes corresponding to arguments of a CallExpression or param-
eters of a FunctionDeclaration is important as allowing permuta-
tion here may lead to semantically different code. Thus, we impose
the sorting mechanism for the unordered node-types like properties
(2)
1547Figure 2: An AST representation of the code snippet "var x = 10, y; y = x+1;" derived from the tree-grammar production rules speciﬁed in
Figure 1. The solid rectangular nodes represent the terminals of the tree grammar (belong to the AST nodes) and the dotted rectangular are the non-terminals
of the grammar.
if is_non_identiﬁer(n) then
else if n ∈ StructId then
s ← H(n.type||ln)
s ← StructId[n]
IdentityP os[n].append(pos||“Identif ier”)
n_struct ← STRUCTURE_NODE(n)
s ← H(H(n.type)|| STRUCT_SIGN(n_struct, pos))
StructId[n] = s
else
Algorithm 1 Structural Signature Algorithm
1: StructId ← {} //contains structural identities
2: IdentityP os ← {} //contains positions of an identiﬁer
3: procedure STRUCT_SIGN(n, pos)
4:
5:
6:
7:
8:
9:
10:
11:
12:
13:
14:
15:
16:
17:
18:
19:
20:
21:
22:
23:
24:
25:
sign.append(STRUCT_SIGN(each, pos || n.type))
s ← H(H(ln) || join(sorted(sign)))
s ← H(H(ln) || join(sign))
if n is an child of Program then
sign ← {}
for each ∈ n.children do
UPDATE_STRUCTIDS(s)
FLUSH_IDENTITYPOS()
if n is of UnorderedType then
if is_leaf(n) then
else
else
return s
of an object. We do not perform such sorting for function argu-
ments and parameters. The lines 15-21 in Algorithm 1 perform this
computation. This isomorphism enables the snippets in Listing 8 to
have the same signature. This isomorphism can be easily extended
to take into account permutation of independent code statements at
the same level in the AST, the order of variable declarators and the
order of function declarations in the global scope.
Safety. The isomorphism under node permutations restricted to un-
ordered node types is secure because ASTs that only differ in the
order of these unordered node types will have the same structural
signature. Such ASTs correspond to code that are syntactically dif-
ferent but have the same code semantics.
3.5.3 Isomorphism 2: Label Renaming
The name of the identiﬁer, which is its label, is unique and can
be used for computing its structural signature, i.e., S#(x) = H(x)
for an identiﬁer x. However, in our experiments, we ﬁnd that iden-
tiﬁers get consistently renamed with no change in the logic of the
1 // Script during first visit
2 var f = parseInt(o.css("margin-top")),
3 h = f + d;
4 t.is("textarea") || (h =
parseInt(o.prevAll(":visible").eq(0)
.css("margin-bottom")) + f), o.css("margin-top",
h)
5
6 // Script during second visit
7 var h = parseInt(o.css("margin-top")),
8 f = h + d;
9 t.is("textarea") || (f =
parseInt(o.prevAll(":visible").eq(0)
.css("margin-bottom")) + h), o.css("margin-top",
f)
Listing 5: An example of variable renaming in a script monitored over
two subsequent visits. Underlined variables are renamed during the
second visit.
source code, as shown by code hosted at sstatic.net in List-
ing 5. So, we would like two pieces of code differing only in vari-
able names to have the same structural signature. To achieve this,
we deﬁne the isomorphism under renaming of the labels. The iso-
morphism proceeds by trying to deﬁne a unique identity for every
identiﬁer which can further be used to replace the identiﬁer’s name
in the signature computation. If it is not possible to represent an
identiﬁer with a unique identity, then we do not apply this kind of
relaxation — we fallback to using the name of the identiﬁer and re-
sort to the signature computation as explained in Section 3.5.1 and
Section 3.5.2 in order to avoid semantically different code to have
the same signature.
Structural Identity of an Identiﬁer. In order to deﬁne an identity
for an identiﬁer, we ﬁrst take into account the identiﬁer during its
declaration. Consider the following variable declaration var x
= 10. From this statement, we can infer that x can be identiﬁed
as a variable which has a number 10 assigned to it. In general, the
type and the initialization value can be used to identify an identiﬁer.
We refer to this as the initial identity of the identiﬁer. The type of
an identiﬁer can either be VariableType or ObjectType and
the initialization value is either the value it is assigned to during
declaration or undeﬁned if nothing is assigned to it.
Note that type and initialization alone do not always uniquely
identify the identiﬁer as there may be more than one identiﬁers ini-
tialized to the same value. These identiﬁers then may be used in
different statements and at different positions in a statement. Sim-
ply using type and initialization value as the identity might lead
to semantically different code having the same structural signature.
Therefore, we propose to use the position set of the identiﬁer in the
statement to further reﬁne its identity. The position set of an iden-
tiﬁer describes the structure of the statements it is used in and the
position(s) of the identiﬁer in these statements. For example, the
LiteralIdentifierrightleftBinaryOperatorBinaryExpressionIdentifierrightleftAssignmentOperatorAssignmentExpressionLiteralInitStructureIdentifierVariableDeclaratorVariableDeclaratorVariableDeclarationProgramUndefinedInitStructureIdentifierx1x+10=yyProgramProgramProgramVariableDeclarationVariableDeclaratorStructureProgramVariableDeclarationVariableDeclaratorIdentifierStructurexLiteralInit10(d)(e)(c)(b)(a)1548variables x and y in the statement "y = x + 1;" are in differ-
ent positions — y is positioned as the left-hand side of the assign-
ment expression while x positioned as the left-hand side of a binary
expression which is also the right-hand side of the assignment ex-
pression (Figure 2.e). Therefore, the set of positions at which an
identiﬁer is used in the statement along with the structure of the
statement captures the usage pattern of the identiﬁer and thereby
uniquely identiﬁes it.
We refer to the identity of the identiﬁer as "structural identity"
as it is based on its structure that consists of the type, initialization
value and the position set in the AST. An identiﬁer initially has a
structural identity based on its initial structure (type, initialization
value) which gets reﬁned during the tree traversal according to the
statements it is used in and its positions in the statements. This re-
ﬁnement takes place at the end of each statement or, in terms of the
tree grammar, at the end of the signature computation of the source
elements2. Henceforth, we will use statement and source elements
interchangeably whereas both terms refer to source elements.
The above idea of structural identity readily extends for function
identiﬁers whose initial structural identity is based on the structure
of the function body and the parameter list and further gets reﬁned
as per its usage in the whole Program’s scope. We explain how to
compute structural identities next.
Structural Identity Initialization. As previously mentioned, any
identiﬁer when declared has an initial structure and hence a struc-
tural identity. To capture this initial structure, we add a new node to
the language constructs called Structure as shown in Figures 2[c-
e]. The generation of the Structure node is described in rules (3)
and (13) of the grammar in Figure 1. This structure node, along
with the type deﬁnes the structural identity of the identiﬁer, referred
to as StructId. For example, the StructId of the identiﬁer
node x in Figure 2 is computed as follows
StructId(x) = H(H(”V ariableT ype”)||S#(Structure))
(3)
Here, S#(Structure) node is computed in the bottom up fashion
as described in Algorithm 1. The lines 9-11 of the algorithm return
a signature for the identiﬁer node that is independent of its name
but completely dependent on its initial structure. StructId of the
identiﬁer is stored in the datastructure StructId and updated ac-
cording to the line 13 of Algorithm 1. The structural signature of x
is the same as its structural identity. After computing the structural
identity of x, the signature computation proceeds in the bottom-up
fashion to compute signatures of the parent nodes.
Reﬁning Structural Identity. The initial structural identity needs
to be reﬁned as per the usage of the identiﬁer in the code. We
propose to use the position set of the identiﬁer in the AST to reﬁne
its identity. The position set of an identiﬁer consists of two things:
i) structure of the statement it is used in and ii) the positions of the
identiﬁer in the statement.
The structural signature of a node deﬁnes the structure of the en-
tire subtree rooted at itself. This is because of the bottom-up com-
putation nature of structural signatures. Referring to the AST of
our example statement in Figure 2, the signature of Assignment-
Expression compactly describes the structure of the statement y
= x + 1. Additionally, to deﬁne the position(s) of an identiﬁer