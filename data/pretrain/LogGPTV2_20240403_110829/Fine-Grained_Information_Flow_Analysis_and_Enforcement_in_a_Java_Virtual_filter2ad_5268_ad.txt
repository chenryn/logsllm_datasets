the reference label. Therefore ﬁeld accesses are expensive,
making assignments expensive in total.
The left part of Figure 5 shows the overhead for Section 2
applications. These are routines that carry out speciﬁc op-
erations frequently needed by scientiﬁc applications. The
overheads range from 23% to 159%.
Finally, the right part of Figure 5 shows overheads for
large, more realistic applications. These applications are
a mix of computationally intensive and I/O bound applica-
tions, and try to represent real world applications. The over-
heads range from 25% for the molecular dynamics to 100%
for the ray tracer application.
These overheads are substantially lower than we had ex-
pected. A slowdown of a factor of two for a realistic pro-
gram, while noticeable, may be perfectly tolerable in many
application domains when taken in the context of added
information-ﬂow security.
5. Related Work
Bell and LaPadula [7] pioneered the use of a state ma-
chine to model security policies that specify security levels
for data, and access rules for users with different clearance
levels. Every event in a system is mapped to a transition
in a corresponding state machine. Safety of a system is en-
sured by allowing transitions only to secure states. A secure
state is deﬁned as one in which the user has adequate clear-
ance, as deﬁned by the security policy, to access the data.
The model also ensures data integrity by only allowing pro-
472472
cesses or users with the same clearance level to perform
destructive writes to an object. Non-destructive writes are
allowed to low-level clearance processes as long as this does
not lead to an information leak.
Bell and LaPadula used an ordered set of labels such as
unclassiﬁed, classiﬁed, and secret. Our work uses a label-
ing scheme that is similar to what Bell and LaPadula pro-
posed, i.e. a fully ordered set. The decision to use a scheme
like this over a lattice structure was for efﬁciency purposes,
since we calculate the label at runtime.
Fenton’s Data Mark Machine (DMM) [20] was an ab-
stract machine that applied the concepts that were proposed
by Bell and LaPadula. The problem with these early works
in information ﬂow was that they were completely dynamic
and hence were not good at detecting implicit ﬂows.
Denning and Denning [13, 14] were the ﬁrst to point out
that the information ﬂow property should be enforced stat-
ically to contain label creep. They also proposed using a
lattice structure for label hierarchy, which is more expres-
sive than the label hierarchy of Bell-LaPadula. Since their
analysis was completely static, it could afford to perform
expensive label computations on a lattice without impacting
the runtime performance. Lots of later work in information
ﬂow [19, 27, 28, 29, 3, 4, 6, 10, 9] was motivated by Den-
ning and Denning’s work—primarily trying to formalize the
ideas they had proposed.
More recently, the non-interference property has been
studied and formulated in terms of type systems, particu-
larly in pure λ-calculi [1, 2, 23]. Volpano et al. [37, 38]
formalized the soundness of Denning’s analysis by develop-
ing a type system that is equivalent to the rules proposed by
Denning. They then proved that this type-system observes
non-interference. Banerjee and Naumann [5] extend the
scope of Volpano’s work to encompass data-ﬂow via muta-
ble object ﬁelds and control-ﬂow in dynamically dispatched
method calls. The non-interference property is proved in
much richer context with constructs of pointers and muta-
ble state, private ﬁelds and class-based visibility, dynamic
binding and inheritance, casts and type tests, and mutually
recursive classes and methods. Bernardeschi and et al. [8]
use type-based abstract interpretation (which is similar to
bytecode veriﬁcation) to prove information ﬂow safety of
Java bytecode. They, like Denning, handle implicit ﬂows
and make use of the immediate post-dominator relation to
declassify the security label of the execution context. Our
approach is different from their purely static analysis as we
use both dynamic and static techniques, which makes the
analysis more ﬂexible and precise.
Several research projects apply static analysis to C pro-
grams. Evans’ Split static analyzer [18] takes as input C
source code annotated with “tainted” and “untainted” an-
notations. This is accompanied by rules for how objects
can be converted from one into the other, and which func-
tions expect what kinds of arguments. Shankar et al [34]
use a similar approach in which C source code is annotated,
but they use type qualiﬁers instead. The WebSSARI [24]
project analyzes information ﬂow in PHP applications stat-
ically. It inserts runtime guards in potentially insecure re-
gions of code. It differs from approaches such as Myers’
Jﬂow and Jif [30, 31] in that it does not require source an-
notations.
RIFLE [35] is a system that tracks information ﬂow dy-
namically using a combination of hardware and software.
The underlying hardware architecture is modiﬁed to explic-
itly track information ﬂow labels on words. At load time,
binaries are rewritten from the standard instruction set to
a new one that also appends security labels to instructions.
This translation also does a data-ﬂow and reachability anal-
ysis on the binary. It converts implicit ﬂows to explicit ﬂows
that can then be tracked by the architecture. This is the
ﬁrst approach that uses a combination of static and dynamic
techniques to perform information ﬂow analysis.
Our analysis comes closest to RIFLE since we also use
combination of static and dynamic information ﬂow analy-
sis. However, there are major differences between RIFLE
and our system. Our solution is software-only and does
not require modiﬁcations to the underlying hardware archi-
tecture. RIFLE analyzes native binaries while we use Java
bytecode. Due to the very low-level semantics of native
binaries, their static analysis is far more conservative than
ours. Java bytecode has much higher level semantics and
stricter guarantees, which helps our analysis to more pre-
cisely reason about program behavior.
6. Summary and Conclusion
Our information-ﬂow framework demonstrates that by
adding statically gathered information to dynamic informa-
473473
tion ﬂow techniques, one can make the dynamic analysis
more intelligent about implicit ﬂows while still retaining the
ﬂexibility of a dynamic analysis.
We took a lot of care during the implementation of our
analysis to make sure that the runtime overhead is minimal.
The results show that even for large applications, execution
times no more than double. Such an overhead may be per-
fectly acceptable in many contexts that are particularly se-
curity sensitive.
While we tried to minimize the impact of label calcula-
tions, we still have relied on standard compiler optimiza-
tions. In the future, we want to investigate compiler tech-
niques speciﬁcally targeted at reducing the overhead of la-
bel computations. We are conﬁdent that the cost of informa-
tion ﬂow for the Java Virtual Machine can be reduced even
further using dedicated compiler optimizations. We hope
that eventually, the Java community will embrace informa-
tion ﬂow techniques with the goal of making Java even safer
than it is today.
Acknowledgement
This research effort was partially funded by the United
States Homeland Security Advanced Research Projects
Agency (HSARPA) and Air Force Research Laboratory
(AFRL) under agreement number FA8750-05-2-0216, and
by the National Science Foundation (NSF) under grant CT-
ISG-0627747. The views and conclusions contained herein
are those of the authors and should not be interpreted as nec-
essarily representing the ofﬁcial policies or endorsements,
either expressed or implied, of HSARPA, AFRL, NSF, or
any other agency of the United States Government.
References
[1] M. Abadi, A. Banerjee, N. Heintze, and J. G. Riecke. A core
calculus of dependency. In POPL ’99: Proceedings of the
26th ACM SIGPLAN-SIGACT symposium on Principles of
programming languages, pages 147–160, 1999.
[2] M. Abadi, B. Lampson, and J.-J. Levy. Analysis and caching
of dependencies.
In ICFP ’96: Proceedings of the First
ACM SIGPLAN International Conference on Functional
Programming, pages 83–91, 1996.
[3] J.-P. Banˆatre and C. Bryce.
Information ﬂow control in a
parallel language framework.
In CSFW ’93: Proceedings
of the 6th IEEE Computer Security Foundations Workshop,
pages 39–52, 1993.
[4] J.-P. Banˆatre, C. Bryce, and D. Le M´etayer. An approach
to information security in distributed systems. In Proceed-
ings of the IEEE International Workshop on Future Trends
in Distributed Computing Systems, pages 384–394, 1995.
[5] A. Banerjee and D. A. Naumann. Secure information ﬂow
and pointer conﬁnement in a java-like language. In CSFW
’02: Proceedings of the 15th IEEE Computer Security Foun-
dations Workshop, pages 253–267, 2002.
[6] H. Barendregt. The Lambda Calculus, Its Syntax and Se-
mantics. North-Holland, 1984.
[7] D. Bell and L. LaPadula. Secure computer systems: mathe-
matical foundations. Report MTR 2547 v2, MITRE, Novem-
ber 1973.
[8] C. Bernardeschi, N. D. Francesco, and G. Lettieri. Using
standard veriﬁer to check secure information ﬂow in java
bytecode. In COMPSAC ’02: Proceedings of the 26th Inter-
national Computer Software and Applications Conference,
pages 850–855, 2002.
[9] C. Bodei, P. Degano, F. Nielson, and H. R. Nielson. Static
analysis for secrecy and non-interference in networks of pro-
cesses. In PACT ’01: Proceedings of the 6th International
Conference on Parallel Computing Technologies, pages 27–
41, 2001.
[10] C. Bodei, P. Degano, F. Nielson, and H. Riis Nielson. Static
analysis for the π-calculus with applications to security. In-
formation and Computation, 168:68–92, 2001.
[11] J. Bull, L. Smith, M. Westhead, D. Henty, and R. Davey.
Benchmarking Java Grande applications. In Proceedings of
the Second International Conference on The Practical Ap-
plications of Java, pages 63–73, April 2000.
[12] K. Cooper, T. Harvey, and K. Kennedy. A simple, fast dom-
inance algorithm. Available at http://www.cs.rice.edu/ kei-
th/embed., 2001.
[13] D. E. Denning. A lattice model of secure information ﬂow.
Communications of the ACM, 19(5):236–243, 1976.
[14] D. E. Denning and P. J. Denning. Certiﬁcation of programs
for secure information ﬂow. Communications of the ACM,
20(7):504–513, 1977.
[15] Department of Defense. Trusted Computer System Evalua-
[16]
tion Criteria, DOD standard 5200.28-STD. 1985.
´U. Erlingsson and F. B. Schneider. SASI Enforcement of Se-
curity Policies: A Retrospective. In New Security Paradigms
Workshop, pages 87–95, Ontario, Canada, 22–24 1999.
ACM SIGSAC, ACM Press.
[17] U. Erlingsson and F. B. Schneider. IRM enforcement of Java
stack inspection. In IEEE Symposium on Security and Pri-
vacy, pages 246–255, 2000.
[18] D. Evans and D. Larochelle. Improving security using ex-
tensible lightweight static analysis. IEEE Software, Jan/Feb,
2002.
[19] R. J. Feiertag, K. N. Levitt, and L. Robinson. Proving multi-
level security of a system design. In SOSP ’77: Proceedings
of the sixth ACM symposium on Operating systems princi-
ples, pages 57–65, 1977.
[20] J. Fenton. Information Protection Systems. PhD thesis, Uni-
versity of Cambridge, England, 1973.
[21] V. Haldar, D. Chandra, and M. Franz. Dynamic taint prop-
agation for Java.
In ACSAC ’05: Proceedings of the 21st
Annual Computer Security Applications Conference, pages
303–311, 2005.
[22] V. Haldar, D. Chandra, and M. Franz. Practical, dynamic in-
formation ﬂow for virtual machines. In International Work-
shop on Programming Language Interference and Depen-
dence, September 2005.
[23] N. Heintze and J. G. Riecke. The SLam calculus: program-
ming with secrecy and integrity. In POPL ’98: Proceedings
of the 25th ACM SIGPLAN-SIGACT symposium on Princi-
ples of programming languages, pages 365–377, 1998.
[24] Y.-W. Huang, F. Yu, C. Hang, C.-H. Tsai, D.-T. Lee, and
S.-Y. Kuo. Securing web application code by static analysis
and runtime protection. In WWW ’04: Proceedings of the
13th international World Wide Web conference, pages 40–
52, 2004.
[25] P. A. Karger, T. E. Leonard, and A. H. Mason. Computer
with virtual machine mode and multiple protection rings,
U.S. Patent No. 4787031, November 1988.
[26] B. W. Lampson. A note on the conﬁnement problem. Com-
munications of the ACM, 16(10):613–615, 1973.
[27] J. K. Millen. Security kernel validation in practice. Commu-
nications of the ACM, 19(5):243–250, 1976.
[28] J. K. Millen. Information ﬂow analysis of formal speciﬁca-
tions. In SP ’81: Proceedings of the 1981 IEEE Symposium
on Security and Privacy, page 3, 1981.
[29] M. Mizuno and D. A. Schmidt. A security ﬂow control algo-
rithm and its denotational semantics correctness proof. For-
mal Aspects of Computing, 4(6A):727–754, 1992.
[30] A. C. Myers.
JFlow: Practical mostly-static information
ﬂow control. In Symposium on Principles of Programming
Languages, pages 228–241, 1999.
[31] A. C. Myers. Mostly-static decentralized information ﬂow
control. PhD thesis, Massachusetts Institute of Technol-
ogy, Dept. of Electrical Engineering and Computer Science,
1999.
[32] R. Rhode.
Secure multilevel virtual computer systems.
Technical Report ESD-TR-74-370, MITRE Corp., Bedford,
Massachussetts, 1975.
[33] F. B. Schneider. Enforceable Security Policies. ACM Trans-
actions on Information and System Security, 3(1):30–50,
2000.
[34] U. Shankar, K. Talwar, J. S. Foster, and D. Wagner. Detect-
ing format string vulnerabilities with type qualiﬁers. In 10th
USENIX Security Symposium, pages 201–220, 2001.
[35] N. Vachharajani, M. J. Bridges, J. Chang, R. Rangan, G. Ot-
toni, J. A. Blome, G. A. Reis, M. Vachharajani, and D. I.
August. Riﬂe: An architectural framework for user-centric
information-ﬂow security. In 37th International Symposium
on Microarchitecture, December 2004.
[36] R. Vallee-Rai, L. Hendren, V. Sundaresan, P. Lam,
E. Gagnon, and P. Co. Soot - a Java bytecode optimization
framework. In CASCON ’99: Proceedings of the 1999 IBM
Center for Advanced Studies Conference on Collaborative
research, pages 125–135, 1999.
[37] D. Volpano and G. Smith. Eliminating covert ﬂows with
minimum typings. In CSFW ’97: Proceedings of the 10th
IEEE Computer Security Foundations Workshop, page 156,
Washington, DC, USA, 1997. IEEE Computer Society.
[38] D. Volpano, G. Smith, and C. Irvine. A sound type sys-
tem for secure ﬂow analysis. Journal of Computer Security,
4(3):167–187, 1996.
[39] C. Weissman. Secure computer operation with virtual ma-
chine partitioning. In National Computer Conference, May
19-22, 1975, Anaheim, California, pages 929–934, 1975.
474474