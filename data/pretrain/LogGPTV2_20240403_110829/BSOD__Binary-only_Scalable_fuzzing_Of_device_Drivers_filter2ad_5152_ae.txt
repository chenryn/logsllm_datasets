coverage
KCOV bp-edge
131091
1072
11025
3585
30
7381
bp-block
28994
246
7041
Table 2: Syzkaller fuzzing statistics by coverage mode.
Figure 9: BSOD-AFL fuzzing throughput for bp-edge/bp-
block coverage modes.
Figure 8: BSOD-AFL fuzzing executions for bp-edge/bp-
block coverage modes.
Table 2 shows the statistics for the three tested modes in this
experiment and Figure 6 depicts the number of program executions.
According to the total executions, breakpoint coverage in edge
mode causes an overhead of 36x compared to KCOV, whereby the
block mode reduces the overhead to 4.5x. As expected, the block
mode involves a slower start at the beginning compared to the edge
mode due to the overhead of switching between triage phases but
quickly improves over time.
Figure 7 shows the respective program execution speed for the
three tested modes. High variance is noticeable for the KCOV curve
that is related to system reboots due to encountered crashes. Be-
cause of the higher execution speed, the fuzzer triggered crashes
more often, which resulted in a considerable penalty of multiple
reboots for that instance.
The overhead of breakpoint coverage compared to statically
instrumented binaries is quite large, but we expected this status
as it also applies to user space fuzzers. We decreased the overhead
by lowering the tracing accuracy to improve the throughput to an
acceptable value.
BSOD-AFL. We performed another evaluation to measure the
effectiveness of block coverage to reduce tracing overhead. This
time, we execute the BSOD-AFL setup on the main kernel module
with the emulated device model and compare the edge tracing and
block tracing modes.
Table 3 shows the statistics of the experiment and Figure 8 shows
the number of executions for both modes respectively. When com-
paring the total executions, we can observe the primary advantage
of block coverage since it outperforms the edge coverage mode by
a factor of 17.
Figure 10: BSOD-AFL paths for bp-edge/bp-block coverage
modes.
Figure 11: BSOD-AFL coverage for bp-edge/bp-block modes.
total execs
mean exec/s
total paths
coverage
bp-edge
bp-block
7.58M 129.29M
213
1447
4058
4664
852
9800
Table 3: BSOD-AFL fuzzing statistics for bp-edge/bp-block
coverage modes.
Figure 9 shows the execution speed for both modes respectively.
The mean execution speed in block coverage mode is significantly
higher compared to the edge coverage mode. Both modes show a
high variance in the execution speeds, which is related to the code
depth of the test cases generated by the fuzzer.
For block coverage mode, the tracing cost mainly reduces down
to the overhead of providing new test cases between two executions
since each reached code location is only reported once. We can
02x1074x1076x1078x1071x1081.2x1081.4x10800:0001:0002:0003:0004:0005:0006:0007:0008:0009:0010:00execstimebp-blockbp-edge0100020003000400050006000700000:0001:0002:0003:0004:0005:0006:0007:0008:0009:0010:00throughput in execs/stimebp-blockbp-edge40050060070080090010001100120013001400150000:0001:0002:0003:0004:0005:0006:0007:0008:0009:0010:00total pathstimebp-blockbp-edge01000200030004000500060007000800090001000000:0001:0002:0003:0004:0005:0006:0007:0008:0009:0010:00coveragetimebp-blockbp-edge57BSOD: Binary-only Scalable fuzzing Of device Drivers
RAID ’21, October 6–8, 2021, San Sebastian, Spain
clearly see when the fuzzer has caused the guest to crash based on
the times when the throughput temporarily drops to zero.
Figure 10 shows the total paths found for both modes respec-
tively. We provided 467 input seeds of dumped ioctl structures,
which defines the starting value in the origin. Both curves share an
increased slope at the beginning that continuously decreases over
time, which can be explained with an increased probability to find
new paths when starting the experiment that decreases over time
since there are fewer new paths to discover.
Generally, the number of found paths in block coverage mode
is lower than in edge coverage mode, which does not necessarily
mean that the block mode explores fewer paths. The reason is the
lower tracing granularity since the tracer reports only previously
unreached basic blocks and cannot distinguish between block tran-
sitions and identify the paths. The curve for the block coverage
mode effectively shows the number of test cases that reached at
least one new code location.
Figure 11 depicts the achieved coverage for block and edge modes.
We can observe that both curves increase with jumps depending
on whether a test case was executed that reaches a certain number
of new code locations. If we compare total paths and coverage, we
can observe that as coverage increases, the number of total paths
increases, which is expected by definition.
It seems contradictory that the block mode explores about half
the amount of paths but more than twice the number of coverage
compared to the edge mode, due to its reduced tracing granularity.
The greatly increased throughput of the block mode pays off as it
achieves faster and more coverage compared to the edge mode.
Interestingly, the coverage in block mode suddenly jumps at
about 2 hours and 5 hours of the experiment. At the same time, the
total paths increase only minimally, which means that only a few
test cases were necessary to reach many previously unseen code
locations.
The overall achieved coverage is below the coverage reached
when running our sample application, whose exchanged data we
used as seeds for AFL. Since the minimal application already trig-
gered above 400 highly dependent ioctl system calls, it becomes
very unlikely for the fuzzer to trigger similar behavior in short
time.
The performance gain from using the block mode in this ap-
proach is higher compared to Syzkaller that must use a mixture of
block and edge modes due to the triage phase.
5.2 Scaling Using BSOD-fakedev
To run BSOD-fakedev, the tester needs to determine the PCI speci-
fications needed: the target’s hardware vendor and device IDs and
the layout of the BARs. The test device used during this work is an
NVIDIA GeForce GTX 760 with a GK104 chipset (Kepler) and 2 GB
VRAM and contains three memory regions. To work around initial
state problems with the replay device, we needed to implement
custom logic for some memory addresses to avoid unexpected data
for the driver.
To evaluate the functionality of BSOD-fakedev, the emulated
hardware device, we compare the coverage in terms of reached
basic block addresses and the throughput when fuzzing with the
physical hardware device via VFIO and the emulated device model.
Figure 12: Syzkaller coverage for physical/emulated hard-
ware device.
Figure 13: Syzkaller fuzzing throughput for physical/emu-
lated hardware device.
total progs
mean progs/min
overall coverage
exclusive coverage
17
4445
451
VFIO Device Model
57450
57024
17
4411
417
Table 4: Syzkaller fuzzing statistics for physical/emulated
hardware device.
For this purpose, we have chosen the Syzkaller setup that targets
all the modules coming from the proprietary driver package.
Figure 12 shows the reached coverage for both devices in 48
hours. Both graphs progress nearly identical, starting with an in-
creased slope in the first 30 minutes until it reaches a coverage value
of about 1500. An increased slope at the beginning is typical since
all defined system calls should trigger new behavior. Afterward, the
slope continuously reduces for both graphs. Figure 13 shows the
execution speed of Syzkaller programs with the physical device and
the emulated model during the same experiment. In this case, also
both graphs behave very similarly and reach a mean throughput of
17 programs per minute, which shows that the virtual device model
involves no further overhead. Table 4 shows the final results of the
experiment. The first three rows indicate that both experiments
ran very similarly. The last row reveals the number of exclusively
reached basic blocks for the experiment after executing the test
cases in the other configuration, which indicates that some func-
tionality deviates depending on the used device. With 3994 blocks
in common, both setups reach about 90% of the same coverage
in this experiment. These insights show that the emulated device
model is suitable to replace a physical device for fuzzing purposes.
In the following, we use BSOD-fakedev for fuzzing with Syzkaller
and AFL.
0500100015002000250030003500400045005000100100010000100000coveragetime in sphysicalemulated010203040506006:0012:0018:0000:0006:0012:0018:0000:00    execs/min (physical)    execs/min (emulated)58RAID ’21, October 6–8, 2021, San Sebastian, Spain
Toepfer and Maier
Figure 14: Syzkaller coverage for emulated device and bp-
block in 15 days (log scale).
Figure 15: Syzkaller fuzzing throughput for emulated device
and bp-block in 15 days.
BSOD-Syzkaller & fakedev. As the previous evaluations have
shown, the emulated device model reaches similar behavior without
overheads. It allows performing fuzzing on multiple VMs in parallel
without the need for specific hardware devices. We utilized this
feature and started a fuzzing campaign targeting the kernel driver
modules using the Syzkaller approach over 15 days. We executed
the fuzzing environment inside a guest on a server running an
AMD EPYC 7281 16-Core Processor. Inside the guest, we executed
Syzkaller with ten worker instances.
Figure 14 shows the reached coverage during the period of the
experiment. The coverage value exceeded 5000 within the first day.
From then on, it increased further only very slowly but continuously
over time, even on the last day of the experiment up to a total
coverage value of 5497.
Figure 15 depicts the execution speed of the programs. The mean
fuzzing execution speed during the experiment is 125 progs/min.
It shows a high variance, which has several reasons that depend
on the generated programs and active worker guests. Syzkaller
restarts the guests after running for one hour without a crash
to initialize a clean system state that results in short downtimes.
Additionally, when the fuzzer triggered previously unseen crash
reports, Syzkaller tries to reproduce them on several worker guests
from the pool. The points at which the execution speed drops
noticeable down are explainable by a reduced number of active
worker guests due to crash reproduction. Overall, while running ten
instances simultaneously, we scaled up the throughput compared to
a single instance, as shown in Figure 13, although we must consider
a penalty due to nested-virtualization.
BSOD-AFL & fakedev. We applied BSOD-AFL on the main kernel
module driver by setting up multiple AFL instances in parallel mode.
As [13] have stated during their evaluation, the optimal parameters
used for fuzzing depend heavily on the target. Therefore, using
variations of the available parameters across fuzzing instances is
beneficial. Variations in this context include selecting different
power schedules, edge and block coverage modes, and usage of
physical and emulated devices.
On the test system, we have four cores available and thus used
four fuzzing instances. Since we have one physical GPU device
present, we attached it to the master fuzzing instance and executed
the remaining three instances with the emulated device model.
We executed the master node with the exploit power schedule,
and the secondary nodes with mmopt, cut-off-exponential coe, and
quadratic quad.
The power schedule coe and quad depend on a parameter, which
indicates the number of generated inputs that exercise the same
path as the compared seed. Additionally, coe depends on a parame-
ter, which is the average number of generated inputs that exercise a
path [3]. We execute these two instances with edge coverage mode
to provide meaningful values for these parameters. We chose to
execute the other two instances with exploit and mmopt schedules
in block coverage mode for high throughput.
The next chapter presents some findings that we encountered
during the evaluation.
5.3 Findings
Linux. During the evaluation of BSOD-AFL with the emulated
device model, we encountered multiple kernel crashes of type gen-
eral protection fault in __kmalloc, as shown in Listing 4.
g e n e r a l p r o t e c t i o n f a u l t , probably f o r non−c a n o n i c a l a d d r e s s 0
RIP :
x 7 b a a e a f 1 8 d f c d f 8 5 : 0000 [ # 1 ] PREEMPT SMP KASAN NOPTI
0 0 1 0 : __kmalloc +0 x18b /0 x420
1
2
Listing 4: Excerpt of crash report
The bug is reproducible on the host system with the physical
hardware device present and causes the system to freeze and no
longer respond. The stack traces vary across multiple testings,
which indicates the root cause of the bug is triggered at an earlier
point in time and causes faults for different tasks depending on the
state of the operating system. Additionally, BSOD-AFL triggered
multiple instances of page faults and bugs in __vunmap that cause
recursive faults. During the evaluation of Syzkaller with the emu-
lated device model, it was able to uncover multiple crashes due to
NULL pointer dereference bugs.
1