title:Q: Exploit Hardening Made Easy
author:Edward J. Schwartz and
Thanassis Avgerinos and
David Brumley
Q: Exploit Hardening Made Easy
Edward J. Schwartz, Thanassis Avgerinos and David Brumley
Carnegie Mellon University, Pittsburgh, PA
{edmcman, thanassis, dbrumley}@cmu.edu
Abstract
Prior work has shown that return oriented programming
(ROP) can be used to bypass W⊕X, a software defense
that stops shellcode, by reusing instructions from large
libraries such as libc. Modern operating systems have
since enabled address randomization (ASLR), which ran-
domizes the location of libc, making these techniques
unusable in practice. However, modern ASLR implemen-
tations leave smaller amounts of executable code unran-
domized and it has been unclear whether an attacker can
use these small code fragments to construct payloads in
the general case.
In this paper, we show defenses as currently deployed
can be bypassed with new techniques for automatically
creating ROP payloads from small amounts of unran-
domized code. We propose using semantic program ver-
iﬁcation techniques for identifying the functionality of
gadgets, and design a ROP compiler that is resistant to
missing gadget types. To demonstrate our techniques, we
build Q, an end-to-end system that automatically gener-
ates ROP payloads for a given binary. Q can produce
payloads for 80% of Linux /usr/bin programs larger
than 20KB. We also show that Q can automatically per-
form exploit hardening: given an exploit that crashes
with defenses on, Q outputs an exploit that bypasses both
W⊕X and ASLR. We show that Q can harden nine real-
world Linux and Windows exploits, enabling an attacker
to automatically bypass defenses as deployed by industry
for those programs.
1
Introduction
Control ﬂow hijack vulnerabilities are extremely danger-
ous.
In essence, they allow the attacker to hijack the
intended control ﬂow of a program and instead execute
whatever actions the attacker chooses. These actions
could be to spawn a remote shell to control the program,
to install malware, or to exﬁltrate sensitive information
stored by the program.
Luckily, modern OSes now employ W⊕X and ASLR
together — two defenses intended to thwart control ﬂow
hijacks. Write xor eXecute (W⊕X, also known as DEP)
prevents an attacker’s payload itself from being directly
executed. Address space layout randomization (ASLR)
prevents an attacker from utilizing structures within the
application itself as a payload by randomizing the ad-
dresses of program segments. These two defenses, when
used together, make control ﬂow hijack vulnerabilities
difﬁcult to exploit.
However, ASLR and W⊕X are not enforced com-
pletely on modern OSes such as OS X, Linux, and Win-
dows. By completely, we mean enforced such that no
portion of code is unrandomized for ASLR, and that in-
jected code can never be executed by W⊕X. For example,
Linux does not randomize the program image, OS X does
not randomize the stack or heap, and Windows requires
third party applications to explicitly opt-in to ASLR and
W⊕X. Enforcing ASLR and W⊕X completely does not
come without cost; it may break some applications, and
introduce a performance penalty.
Previous work [41] has shown that systems that do
not randomize large libraries like libc are vulnerable to
return oriented programming (ROP) attacks. At a high
level, ROP reuses instruction sequences already present
in memory that end with ret instructions, called gad-
gets. Shacham showed that it was possible to build a
Turing-complete set of gadgets using the program code
of libc. Finding ROP gadgets has since been, to a large
extent, automated when large amounts of code are left un-
randomized [16, 21, 38]. However, it has been left as an
open question whether current defenses, which randomize
large libraries like libc but leave small amounts of code
1
unrandomized, are sufﬁcient for all practical purposes, or
permit such attacks.
In this paper, we show that current implementations are
vulnerable by developing automated ROP techniques that
bypass current defenses and work even when there is only
a small amount of unrandomized code. While it has long
been known that ASLR and W⊕X offer important protec-
tion in theory, our main message is that current practical
implementations make compatibility and performance
tradeoffs, and as a result it is possible to automatically
harden existing exploits to bypass these defenses.
Bypassing defenses on modern operating systems re-
quires ROP techniques that work with whatever unran-
domized code is available, and not just pre-determined
code or large libraries. To this end, we introduce several
new ideas to scale ROP to small code bases.
One key idea is to use semantic deﬁnitions to deter-
mine the function, if any, of an instruction sequence. For
instance, rather than deﬁning movl *, *; ret as a
move gadget [21, 38], we use the semantic deﬁnition
OutReg ← InReg. This allows us to ﬁnd unexpected
gadgets such as realizing imul $1, %eax, %ebx;
ret1 is actually a move gadget.
Another key point is that our system needs to grace-
fully handle missing gadget types. This is comparable
to writing a compiler for an instruction set architecture,
except with some key instructions removed; the com-
piler must still be able to add two numbers even when
the add instruction is missing. We use an algorithm
that searches over many combinations of gadget types in
such a way that will synthesize a working payload even
when the most natural gadget type is unavailable. Prior
work [16, 21, 38] focuses on ﬁnding gadgets for all gad-
get types, such that a compiler can then create a program
using these gadget types. This direct approach will not
work without additional logic if some gadget types are
missing. However, we are not aware of prior work that
considers this. This is essential in our application domain,
since most programs will be missing some gadget types.
Our results build on existing ROP research. Previous
ROP research was either performed by hand [6, 9, 41], or
focused on large code bases such as libc [38] (1,300KB),
a kernel [21] (5,910KB) or mobile libraries [16, 24] (size
varies; on order of 1,000KB). In contrast, our techniques
work on small amounts of code (20KB). In our evaluation
(Section 7), we show that Q can build ROP payloads for
80% of Linux programs larger than 20KB. Q can also
transplant the ROP payloads into an existing exploit that
does not bypass defenses, effectively hardening the origi-
1We use AT&T assembly syntax in this paper, i.e., the source operand
comes ﬁrst.
nal exploit to bypass W⊕X and ASLR. Recent work in
automatic exploit generation [2, 5] can be used to gen-
erate such exploits. We show that Q can automatically
harden nine exploits for real binary programs on Linux
and Windows to bypass implemented defenses. Since
these defenses can automatically be bypassed, we con-
clude that they provide insufﬁcient security.
Contributions. Our main contribution is demonstrating
that existing ASLR and W⊕X implementations do not
provide adequate protection by developing automated
techniques to bypass them. First, we perform a survey
of modern implementations and show that they often do
not protect all code even when they are “turned on”. This
motivates our problem setting. Second, we develop ROP
techniques for small, unrandomized code bases as found
in most practical exploit settings. Our ROP techniques
can automatically compile programs written in a high-
level language down to ROP payloads. Third, we evaluate
our techniques in an end-to-end system, and show that
we can automatically bypass existing defenses for nine
real-life vulnerabilities on both Windows and Linux.
2 Background and Defense Survey
There is a notion that code reuse attacks like return ori-
ented programming are not possible when ASLR is en-
abled at the system level. This is only half true. If ASLR
is applied to all program segments, then code reuse is in-
tuitively difﬁcult, since the attacker does not know where
any particular instruction sequence will be in memory.
However, ASLR is not currently applied to all program
segments, and we will show that attackers can use this
to their advantage. In this section, we explain the W⊕X
and ASLR defenses in more detail, focusing on when a
program segment may be left unprotected.
Table 1 summarizes some of these limitations. The key
insight that we make use of in this paper is that program
images are always unrandomized unless the program ex-
plicitly opts in to randomization. On Linux, for instance,
this mean that developers must set non-default compiler
ﬂags to enable randomization. Another surprise is that
W⊕X is often disabled when older hardware is used;
some virtualization platforms by default will omit the
virtual hardware needed to enable W⊕X.
2.1 W⊕X
W⊕X prevents attackers from injecting their own payload
and executing it by ensuring that protected program seg-
ments are not writable and executable at the same time
2
Operating System W⊕X
Ubuntu 10.04
Debian Sarge
Windows Vista, 7
Mac OS X 10.6
Yes
HW
HW
HW
ASLR
libraries
Yes
Yes
Opt-In
Yes
program
image
Opt-In
Opt-In
Opt-In
No
stack,
heap
Yes
Yes
Yes
No
Table 1: Comparison of defenses on modern operating
systems for the x86 architecture with default settings. Opt-
In means that programs and libraries must be explicitly
marked by the developer at compile time for the protection
to be enabled, and that some compilers do not enable
the marking by default. HW denotes that the level of
protection depends on hardware.
(Writable ⊕ eXecutable2). Attackers have traditionally
included shellcode (executable machine code) in their
exploits as payloads. Since shellcode must be written to
memory at runtime, it cannot be executed because of the
W⊕X property.
W⊕X Implementation W⊕X is implemented [29, 30,
35] using a NX (no execute) bit that the hardware platform
enforces: if execution moves to a page with the NX bit
enabled, the hardware raises a fault. On x86, this bit can
be set using the PAE addressing mode [22].
PAE support is disabled by default in Ubuntu Linux,
since some older hardware does not support it. The Ex-
ecShield [31] patch, which is included in Ubuntu, can
emulate W⊕X by using x86 segments, even when hard-
ware NX support is not available. Other distributions (such
as Debian) do not include the ExecShield patch, and do
not provide any W⊕X protection in default kernels.
Windows 7 enables W⊕X3 by default for processors
supporting the NX bit. However, it only enforces W⊕X
for binaries and libraries marked as W⊕X compatible.
Many notable third-party software programs such as Ora-
cle’s Java JRE, Apple Quicktime, VLC Media Player and
others do not opt-in to W⊕X [36].
Limitations The main limitation of W⊕X is that it only
prevents an attacker from utilizing new payload code. The
attacker can still reuse existing code in memory. For
instance, an attacker can call system by launching a
2W⊕X is actually a misnomer, because memory is allowed to be
3W⊕X is called DEP by the Windows community. Windows also
unwritable and non-executable, but 0 ⊕ 0 = 0.
contains software DEP, but this is unrelated to W⊕X [30].
return-to-libc attack, in which the attacker creates an ex-
ploit that will call a function in libc without injecting any
shellcode. W⊕X does not prevent return-to-libc attacks
because the executed code is in libc and is intended to
be executable at compile time. Return Oriented Program-
ming is another, more advanced attack on W⊕X, which
we discuss in Section 2.3.
2.2 ASLR
ASLR prevents an attacker from directly referring to ob-
jects in memory by randomizing their locations. This
stops an attacker from being able to transfer control to his
shellcode by hardcoding its address in his exploit. Like-
wise, it makes return-to-libc and ROP using libc difﬁcult,
because the attacker will not know where libc is located
in memory.
Implementation ASLR implementations randomize
some subset of the stack, heap, shared libraries (e.g., libc),
and program image (e.g., the .text section).
Linux [31, 34] randomizes the stack, heap, and shared
libraries, but not the program image. Programs can be
manually compiled into position independent executables
(PIEs) which can then be loaded to multiple positions
in memory. Modern distributions [14, 44] only compile
a select group of programs as PIEs, because doing so
introduces a performance overhead at runtime.
Windows Vista and 7 [29, 43] can randomize the loca-
tions of the program image, stack, heap, and libraries, but
only when the program and all of its libraries opt-in to
ASLR. If they do not, some code is left unrandomized.
Many third-party applications including Oracle’s Java
JRE, Adobe Reader, Mozilla Firefox, and Apple Quick-
time (or one of their libraries) are not marked as ASLR
compatible [36]. Ultimately, this means most Windows
binaries have unrandomized code.
Limitations Some attacks on ASLR implementations
take advantage of the low entropy available for random-
ization. For instance, Shacham, et al. [42] show that
brute forcing ASLR on a 32-bit platform takes about 200
seconds on average. (We do not consider attacks that
take more than one attempt in this paper; we create ex-
ploits that succeed on the ﬁrst try.) Other attacks, such as
ret2reg attacks, allow the attacker to transfer control
to their payload by utilizing pointers leaked in registers
or memory [32]. For instance, the strcpy function re-
turns such a pointer to the destination string in the %eax
register. The applicability of these attacks are heavily
dependent on the vulnerable program.
3
ret
ret
pop %ebp
ret
pop %eax
Consumed By
Instruction
nextAddr
addr3
memAddr
addr2
memValue
addr1
32-bits
y
r
o
m
e
M
r
e