这时候也会在客户端出现确认页面，如图11-11所示。
点击恢复数据即可。现在如果想改了这个应用锁的密码，直接修改XML中密码数值，如下所示：
::: bodypic-c
![](OEBPS/Images/175-2-i.jpg){.calibre452}
:::
然后再保存成ab文件进行还原，密码就被修改了。比如有些应用把一些隐私的链接URL这样的信息保存到XML中，就可以导出来数据，然后修改URL为自己的URL再还原，而这些URL如果是一些上报、或者是登录的URL，就可以在这里做手脚，达到想要的目的了。
::: bodypic-c
![](OEBPS/Images/11a11-i.jpg){.calibre453}
:::
图11-11 数据还原\
[]{#071.xhtml}
#### 11.4 本章小结 {.bodycontent-title2}
从本章内容可以看到，对一个属性不留意会带来多大的风险，这个属性也是很容易忽视的，它默认值是true，必须手动设置成false才可以。这个属性导致现在市场上很多App都存在这样的风险。本章主要分析了一个应用锁应用的信息，发现它犯了一个最大的错误就是把密码用明文的方式保存在XML中，破解难度为0。所以开发者在开发一个App的时候，不仅考虑是用户体验，而且要对用户的隐私负责。用户在下载和安装一些App的时候也需要多留点心。
[]{#072.xhtml}
### 第12章 Android中的签名机制 {.bodycontent-title4}
Android开发者对于签名校验机制应该不陌生，就是为了安全，不让别人修改apk，防止恶意破解者在反编译apk之后再重新安装。如果重新安装系统会提示安装失败，因为apk的内容发生改变，签名结果不一样，Android系统中是不允许安装同一个包名但是签名不一样的apk程序的。
[]{#073.xhtml}
#### 12.1 基本概念 {.bodycontent-title2}
在讲Android签名之前，需要了解几个知识点：
·数据摘要（数据指纹）、签名文件、证书文件。
·jarsign工具和signapk工具。
·keystore文件和pk8文件、x509.pem文件的关系。
·如何手动签名apk。
###### 1.数据摘要 {.section-subtitle}
数据摘要其实也是一种算法，就是对一个数据源进行一个算法操作之后得到一个摘要，也叫作数据指纹，不同的数据源，数据指纹肯定不一样，就和人一样。
消息摘要算法（Message Digest
Algorithm）是一种能产生特殊输出格式的算法，其原理是根据一定的运算规则对原始数据进行某种形式的信息提取，提取出的信息就称为原始数据的数据摘要。
著名的数据摘要算法有RSA公司的MD5算法和SHA-1算法及其大量的变体。
数据摘要的主要特点有：
·无论输入的消息有多长，计算出来的数据摘要的长度总是固定的。例如应用MD5算法摘要的消息有128位，用SHA-1算法摘要的消息最终有160位。
·一般来说（不考虑碰撞的情况下），只要输入的原始数据不同，对其进行摘要以后产生的数据摘要也必不相同，即使原始数据稍有改变，输出的数据摘要便完全不同。但是，相同的输入必会产生相同的输出。
·具有不可逆性，即只能进行正向的数据摘要，而无法从摘要中恢复出任何的原始消息。
###### 2.签名文件和证书文件 {.section-subtitle}
签名文件和证书文件是成对出现的，二者不可分离，而且后面通过源码可以看到，这两个文件的名字也是一样的，只是后缀名不一样。
数字签名要确保可靠通信，必须要解决两个问题：首先，要确定消息的来源确实是其申明的那个人；其次，要保证信息在传递的过程中不被第三方篡改，即使被篡改了，也可以发觉出来。
所谓数字签名，就是为了解决这两个问题而产生的，它是对前面提到的非对称加密技术与数字摘要技术的一个具体的应用。
对于消息的发送者来说，先要生成一对公私钥对，将公钥给消息的接收者。
如果消息的发送者有一天想给消息接收者发消息，在发送的信息中，除了要包含原始的消息外，还要加上另外一段消息。这段消息通过如下两步生成：
1）对要发送的原始消息提取数据摘要。
2）对提取的数据摘要用自己的私钥加密。
通过这两步得出的消息，就是所谓的原始信息的数字签名。
而对于信息的接收者来说，他所收到的信息，将包含两个部分，一是原始的消息内容，二是附加的那段数字签名。他将通过以下三步来验证消息的真伪：
1）对原始消息部分提取数据摘要，注意这里使用的数据摘要算法要和发送方使用的一致。
2）对附加上的那段数字签名，使用预先得到的公钥解密。
3）比较前两步所得到的两段消息是否一致。如果一致，则表明消息确实是期望的发送者发的，且内容没有被篡改过；相反，如果不一致，则表明传送的过程中一定出了问题，消息不可信。
这种数字签名技术确实可以有效解决可靠通信的问题。如果原始消息在传送的过程中被篡改了，那么在消息接收者那里，对被篡改的消息提取的摘要肯定和原始的不一样。并且，由于篡改者没有消息发送方的私钥，即使他可以重新算出被篡改消息的摘要，也不能伪造出数字签名。
综上所述，数字签名其实就是只有信息的发送者才能产生的别人无法伪造的一段数字串，这段数字串同时也是对信息的发送者发送信息真实性的一个有效证明。
不知道大家有没有注意，前面讲的这种数字签名方法，有一个前提，就是消息的接收者必须要事先得到正确的公钥。如果一开始公钥就被别人篡改了，那坏人就会被你当成好人，而真正的消息发送者给你发的消息会被你视作无效的。而且，很多时候根本就不具备事先沟通公钥的信息通道。那么如何保证公钥的安全可信呢？这就要靠数字证书来解决了。
数字证书一般包含以下一些内容：
·证书的发布机构（Issuer）
·证书的有效期（Validity）
·消息发送方的公钥
·证书所有者（Subject）
·数字签名所使用的算法
·数字签名
可以看出，数字证书其实也用到了数字签名技术。只不过要签名的内容是消息发送方的公钥，以及一些其他信息。但与普通数字签名不同的是，数字证书中签名者不是随随便便一个普通的机构，而是要有一定公信力的机构。这就好像你的大学毕业证书上签名的一般都是德高望重的校长一样。一般来说，这些有公信力机构的根证书已经在设备出厂前预先安装到了你的设备上了。所以，数字证书可以保证数字证书里的公钥确实是这个证书的所有者的，或者证书可以用来确认对方的身份。数字证书主要是用来解决公钥的安全发放问题。
综上所述，总结一下，数字签名和签名验证的大体流程如图12-1所示。
::: bodypic-c
![](OEBPS/Images/12a1-i.jpg){.calibre454}
:::
图12-1 签名过程
###### 3.jarsign和signapk工具 {.section-subtitle}
了解到完了签名中的三个文件的知识点之后，下面继续来看Android中签名的两个工具：jarsign和signapk
开始使用这两个工具很容易混淆，它们到底有什么区别吗？其实这两个工具很好理解，jarsign是jdk本身自带的一个工具，它可以对jar进行签名。而signapk是后面专门为了Android应用程序apk进行签名的工具，它们的签名算法没什么区别，主要是签名时使用的文件不一样。
###### 4.keystore文件和pk8、x509.pem文件的区别 {.section-subtitle}
上面了解到了jarsign和signapk两个工具都可以进行Android中的签名，那么它们的区别在于签名时使用的文件不一样：
·jarsign工具签名时使用的是keystore文件。
·signapk工具签名时使用的是pk8、x509.pem文件。
在使用Eclipse工具编写程序出debug包的时候，默认用的是jarsign工具进行签名的，而且Eclipse中有一个默认签名文件，如图12-2所示。
::: bodypic-c
![](OEBPS/Images/12a2-i.jpg){.calibre455}
:::
图12-2 Eclipse中默认签名文件\
有默认签名的keystore文件，当然也可以选择指定的keystore文件。看到上面有MD5和SHA1的摘要，这个就是keystore文件中私钥的数据摘要，这个信息也是在申请很多开发平台账号的时候需要填入的信息，比如申请百度地图、微信SDK等，会需要填写应用的MD5或者SHA1信息。
###### 5.手动签名apk包 {.section-subtitle}
（1）使用keytool和jarsigner来进行签名
当然，在正式签名处release包的时候，需要创建一个自己的keystore文件，如图12-3和图12-4所示。
::: bodypic-c
![](OEBPS/Images/12a3-i.jpg){.calibre456}
:::
图12-3 导出签名apk
::: bodypic-c
![](OEBPS/Images/12a4-i.jpg){.calibre457}
:::
图12-4 导出签名apk
这里可以对keystore文件起自己的名字，而且后缀名也是无关紧要的。创建完文件之后，也会生成MD5和SHA1值，这个值可以不用记录的，可以通过命令查看keystore文件的MD5和SHA1的值：keytool-list-keystore
debug.keystore，如下所示：
::: bodypic-c
![](OEBPS/Images/180-i.jpg){.calibre458}
:::
这里看到用Eclipse自动签名和生成一个keystore文件，也可以使用keytool工具生成一个keystore文件。这个方法网上有，就不做太多的介绍了。然后可以使用jarsign来对apk包进行签名了。可以手动生成一个keystore文件：
::: bodypic-c
![](OEBPS/Images/180-2-i.jpg){.calibre459}
:::
::: bodypic-c
![](OEBPS/Images/181-i.jpg){.calibre460}
:::
这个命令有点长，有几个重要的参数需要说明：
·-alias是定义别名，这里是debug。
·-keyalg是规定签名算法，这里是DSA，这里的算法直接关系到后面apk中签名文件的后缀名，到后面会详细说明。
再用jarsigner工具进行签名，如下所示：
::: bodypic-c
![](OEBPS/Images/181-2-i.jpg){.calibre64}
:::
::: bodypic-c
![](OEBPS/Images/181-3-i.jpg){.calibre304}
:::
这样就成功地对apk进行签名了。
签名的过程中遇到的问题：
1）证书链找不到的问题，如下所示：
::: bodypic-c
![](OEBPS/Images/181-4-i.jpg){.calibre461}
:::
这是因为最后一个参数alias是keystore的别名输错了。
2）生成keystore文件的时候提示密码错误，如下所示：
::: bodypic-c
![](OEBPS/Images/181-5-i.jpg){.calibre462}
:::
这个原因是因为在当前目录已经有debug.ketystore了，再生成一个debug.keystore的话，就会报错。
3）找不到别名的问题，如下所示：
::: bodypic-c
![](OEBPS/Images/181-6-i.jpg){.calibre463}
:::
这个问题的原因是使用keytool生成keystore的时候，起了debug的别名，这个问题困扰了我很久，最后做了很多例子才发现的，只要keystore文件的别名是debug的话，就会报这样的错误。这个应该和系统默认的签名debug.keystore中的别名是debug有关系。
[注意：]{.yanse}Android中是允许使用多个keystore对apk进行签名的，这里就不再粘贴命令了，创建了几个keystore对apk进行签名，如图12-5所示。
::: bodypic-c
![](OEBPS/Images/12a5-i.jpg){.calibre464}
:::
图12-5 签名文件目录\
这里把签名之后的apk进行解压之后，发现有三个签名文件和证书（.SF/.DSA）。也可以注意到，签名时用的是DSA算法，这里的文件后缀名就是DSA，而且文件名是keystore的别名，这里算是理清了如何使用keytool产生keystore，以及用jarsigner来进行签名。
（2）用signapk来进行签名
下面再来看看signapk工具进行签名：
::: bodypic-c
![](OEBPS/Images/182-i.jpg){.calibre465}
:::
这里需要两个文件.pk8和.x509.pem：
·pk8是私钥文件。
·x509.pem是含有公钥的文件。
需要注意的是：signapk签名之后的apk，META-INF文件夹中的三个文件的名字，如图12-6所示。
::: bodypic-c
![](OEBPS/Images/12a6-i.jpg){.calibre466}
:::
图12-6 签名文件\
因为signapk在前面的时候不像jarsigner会自动使用别名来命名文件，就是写死了是CERT的名字，不过文件名不影响的，后面分析Android中的apk校验过程中会说道，只会通过后缀名来查找文件。
（3）两种的签名方式有什么区别
jarsigner签名时用的是keystore文件，signapk签名时用的是pk8和x509.pem文件，而且都是给apk进行签名的，那么keystore文件和pk8、x509.pem之间是不是有什么联系呢？答案是肯定的，网上搜了一下，果然它们之间是可以转化的，这里就不再分析如何进行转化的，网上的例子很多，有专门的工具可以进行转化。
[]{#074.xhtml}
#### 12.2 Android中签名流程 {.bodycontent-title2}
下面开始从源码中去分析Android中的签名机制和原理流程。因为网上没有找到jarsigner的源码，但是找到了signapk的源码，下面就来看看signapk的源码：源码位置是com/android/signapk/sign.java。
通过上面的签名可以看到，Android签名apk之后，会有一个META-INF目录，这里有三个文件：
·MANIFEST.MF
·CERT.SF
·CERT.RSA
下面来看看这三个文件到底是干啥的。
###### 1.MANIFEST.MF文件 {.section-subtitle}
这个文件主要包括apk文件中所有文件的数据摘要内容，如下所示：
::: bodypic-c
![](OEBPS/Images/183-i.jpg){.calibre467}
:::
下面来看看源码：
::: bodypic-c
![](OEBPS/Images/183-2-i.jpg){.calibre468}
:::
::: bodypic-c
![](OEBPS/Images/184-i.jpg){.calibre469}
:::
在main函数中，需要输入四个参数，然后开始写MANIFEST.MF文件内容：
::: bodypic-c
![](OEBPS/Images/184-2-i.jpg){.calibre431}