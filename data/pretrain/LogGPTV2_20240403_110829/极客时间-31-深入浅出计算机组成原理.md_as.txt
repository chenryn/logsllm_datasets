## 课后思考对于 BCD 编码的定点数，如果我们用 7 个比特来表示连续两位十进制数，也就是00～99，是不是可以让 32比特表示更大一点的数据范围？如果我们还需要表示负数，那么一个 32 比特的BCD 编码，可以表示的数据范围是多大？欢迎你在留言区写下你的思考和疑问，和大家一起探讨。你也可以把今天的文章分享给你朋友，和他一起学习和进步。![](Images/79d06107d349635530fbf82aa8dfb625.png){savepage-src="https://static001.geekbang.org/resource/image/28/29/281ca28b90c8aa0aecbb5adc08394f29.jpg"}
# 16 \| 浮点数和定点数（下）：深入理解浮点数到底有什么用？上一讲，我们讲了用"浮点数"这样的数据形式，来表示一个不能确定大小的数据范围。浮点数可以大到]{.MathJax_Previewstyle="color: inherit; display: none;"}[``{=html}[[3.40]{#17.html#MathJax-Span-3.mn style="font-family: MathJax_Main;"}[×]{#17.html#MathJax-Span-4 .mostyle="font-family: MathJax_Main; padding-left: 0.238em;"}[10]{#17.html#MathJax-Span-6.mnstyle="font-family: MathJax_Main;"}[]{style="display: inline-block; width: 0px; height: 4.002em;"}]{style="position: absolute; clip: rect(3.202em, 1000.94em, 4.144em, -999.998em); top: -3.998em; left: 0em;"}[38]{#17.html#MathJax-Span-9.mnstyle="font-size: 70.7%; font-family: MathJax_Main;"}]{#17.html#MathJax-Span-8.mrow}]{#17.html#MathJax-Span-7.texatom}[]{style="display: inline-block; width: 0px; height: 4.002em;"}]{style="position: absolute; top: -4.374em; left: 0.991em;"}]{style="display: inline-block; position: relative; width: 1.791em; height: 0px;"}]{#17.html#MathJax-Span-5.msubsup style="padding-left: 0.238em;"}]{#17.html#MathJax-Span-2.mrow}[]{style="display: inline-block; width: 0px; height: 2.355em;"}]{style="position: absolute; clip: rect(1.367em, 1004.85em, 2.496em, -999.998em); top: -2.351em; left: 0em;"}]{style="display: inline-block; position: relative; width: 4.849em; height: 0px; font-size: 125%;"}[]{style="display: inline-block; overflow: hidden; vertical-align: -0.056em; border-left: 0px solid; width: 0px; height: 1.238em;"}]{#17.html#MathJax-Span-1.mathstyle="width: 6.073em; display: inline-block;"}``{=html}[$3.40 \times 10^{38}$]{.MJX_Assistive_MathMLrole="presentation"}]{#17.html#MathJax-Element-1-Frame .MathJaxtabindex="0" style="position: relative;"mathml="3.40×1038"role="presentation"}$$，也可以小到 []{.MathJax_Previewstyle="color: inherit; display: none;"}[``{=html}[[1.17]{#17.html#MathJax-Span-12.mn style="font-family: MathJax_Main;"}[×]{#17.html#MathJax-Span-13 .mostyle="font-family: MathJax_Main; padding-left: 0.238em;"}[10]{#17.html#MathJax-Span-15.mnstyle="font-family: MathJax_Main;"}[]{style="display: inline-block; width: 0px; height: 4.002em;"}]{style="position: absolute; clip: rect(3.202em, 1000.94em, 4.144em, -999.998em); top: -3.998em; left: 0em;"}[−]{#17.html#MathJax-Span-18.mostyle="font-size: 70.7%; font-family: MathJax_Main;"}[38]{#17.html#MathJax-Span-19.mnstyle="font-size: 70.7%; font-family: MathJax_Main;"}]{#17.html#MathJax-Span-17.mrow}]{#17.html#MathJax-Span-16.texatom}[]{style="display: inline-block; width: 0px; height: 4.002em;"}]{style="position: absolute; top: -4.374em; left: 0.991em;"}]{style="display: inline-block; position: relative; width: 2.355em; height: 0px;"}]{#17.html#MathJax-Span-14.msubsup style="padding-left: 0.238em;"}]{#17.html#MathJax-Span-11.mrow}[]{style="display: inline-block; width: 0px; height: 2.355em;"}]{style="position: absolute; clip: rect(1.367em, 1005.41em, 2.496em, -999.998em); top: -2.351em; left: 0em;"}]{style="display: inline-block; position: relative; width: 5.414em; height: 0px; font-size: 125%;"}[]{style="display: inline-block; overflow: hidden; vertical-align: -0.056em; border-left: 0px solid; width: 0px; height: 1.238em;"}]{#17.html#MathJax-Span-10.mathstyle="width: 6.779em; display: inline-block;"}``{=html}[$1.17 \times 10^{- 38}$]{.MJX_Assistive_MathMLrole="presentation"}]{#17.html#MathJax-Element-2-Frame .MathJaxtabindex="0" style="position: relative;"mathml="1.17×10−38"role="presentation"}$$ 这样的数值。同时，我们也发现，其实我们平时写的0.1、0.2 并不是精确的数值，只是一个近似值。只有 0.5 这样，可以表示成]{.MathJax_Previewstyle="color: inherit; display: none;"}[``{=html}[[[[[2]{#17.html#MathJax-Span-23.mnstyle="font-family: MathJax_Main;"}[]{style="display: inline-block; width: 0px; height: 4.002em;"}]{style="position: absolute; clip: rect(3.202em, 1000.47em, 4.144em, -999.998em); top: -3.998em; left: 0em;"}[−]{#17.html#MathJax-Span-26.mostyle="font-size: 70.7%; font-family: MathJax_Main;"}[1]{#17.html#MathJax-Span-27.mnstyle="font-size: 70.7%; font-family: MathJax_Main;"}]{#17.html#MathJax-Span-25.mrow}]{#17.html#MathJax-Span-24.texatom}[]{style="display: inline-block; width: 0px; height: 4.002em;"}]{style="position: absolute; top: -4.374em; left: 0.52em;"}]{style="display: inline-block; position: relative; width: 1.461em; height: 0px;"}]{#17.html#MathJax-Span-22.msubsup}]{#17.html#MathJax-Span-21.mrow}[]{style="display: inline-block; width: 0px; height: 2.308em;"}]{style="position: absolute; clip: rect(1.32em, 1001.46em, 2.449em, -999.998em); top: -2.304em; left: 0em;"}]{style="display: inline-block; position: relative; width: 1.461em; height: 0px; font-size: 125%;"}[]{style="display: inline-block; overflow: hidden; vertical-align: -0.056em; border-left: 0px solid; width: 0px; height: 1.179em;"}]{#17.html#MathJax-Span-20.mathstyle="width: 1.838em; display: inline-block;"}``{=html}[$2^{- 1}$]{.MJX_Assistive_MathMLrole="presentation"}]{#17.html#MathJax-Element-3-Frame .MathJaxtabindex="0" style="position: relative;"mathml="2−1"role="presentation"}$$ 这种形式的，才是一个精确的浮点数。你是不是感到很疑惑，浮点数的近似值究竟是怎么算出来的？浮点数的加法计算又是怎么回事儿？在实践应用中，我们怎么才用好浮点数呢？这一节，我们就一起来看这几个问题。
## 浮点数的二进制转化我们首先来看，十进制的浮点数怎么表示成二进制。我们输入一个任意的十进制浮点数，背后都会对应一个二进制表示。比方说，我们输入了一个十进制浮点数9.1。那么按照之前的讲解，在二进制里面，我们应该把它变成一个"**符号位 s+指数位 e+ 有效位数f**"的组合。第一步，我们要做的，就是把这个数变成二进制。首先，我们把这个数的整数部分，变成一个二进制。这个我们前面讲二进制的时候已经讲过了。这里的9，换算之后就是 1001。``{=html}接着，我们把对应的小数部分也换算成二进制。小数怎么换成二进制呢？我们先来定义一下，小数的二进制表示是怎么回事。我们拿0.1001这样一个二进制小数来举例说明。和上面的整数相反，我们把小数点后的每一位，都表示对应的2 的 -N 次方。那么 0.1001，转化成十进制就是：]{.MathJax_Previewstyle="color: inherit; display: none;"}[``{=html}[[1]{#17.html#MathJax-Span-30.mn style="font-family: MathJax_Main;"}[×]{#17.html#MathJax-Span-31 .mostyle="font-family: MathJax_Main; padding-left: 0.238em;"}[2]{#17.html#MathJax-Span-33.mnstyle="font-family: MathJax_Main;"}[]{style="display: inline-block; width: 0px; height: 4.002em;"}]{style="position: absolute; clip: rect(3.202em, 1000.47em, 4.144em, -999.998em); top: -3.998em; left: 0em;"}[−]{#17.html#MathJax-Span-36.mostyle="font-size: 70.7%; font-family: MathJax_Main;"}[1]{#17.html#MathJax-Span-37.mnstyle="font-size: 70.7%; font-family: MathJax_Main;"}]{#17.html#MathJax-Span-35.mrow}]{#17.html#MathJax-Span-34.texatom}[]{style="display: inline-block; width: 0px; height: 4.002em;"}]{style="position: absolute; top: -4.374em; left: 0.52em;"}]{style="display: inline-block; position: relative; width: 1.461em; height: 0px;"}]{#17.html#MathJax-Span-32.msubsup style="padding-left: 0.238em;"}[+]{#17.html#MathJax-Span-38 .mostyle="font-family: MathJax_Main; padding-left: 0.238em;"}[0]{#17.html#MathJax-Span-39.mnstyle="font-family: MathJax_Main; padding-left: 0.238em;"}[×]{#17.html#MathJax-Span-40.mostyle="font-family: MathJax_Main; padding-left: 0.238em;"}[2]{#17.html#MathJax-Span-42.mnstyle="font-family: MathJax_Main;"}[]{style="display: inline-block; width: 0px; height: 4.002em;"}]{style="position: absolute; clip: rect(3.202em, 1000.47em, 4.144em, -999.998em); top: -3.998em; left: 0em;"}[−]{#17.html#MathJax-Span-45.mostyle="font-size: 70.7%; font-family: MathJax_Main;"}[2]{#17.html#MathJax-Span-46.mnstyle="font-size: 70.7%; font-family: MathJax_Main;"}]{#17.html#MathJax-Span-44.mrow}]{#17.html#MathJax-Span-43.texatom}[]{style="display: inline-block; width: 0px; height: 4.002em;"}]{style="position: absolute; top: -4.374em; left: 0.52em;"}]{style="display: inline-block; position: relative; width: 1.461em; height: 0px;"}]{#17.html#MathJax-Span-41.msubsup style="padding-left: 0.238em;"}[+]{#17.html#MathJax-Span-47 .mostyle="font-family: MathJax_Main; padding-left: 0.238em;"}[0]{#17.html#MathJax-Span-48.mnstyle="font-family: MathJax_Main; padding-left: 0.238em;"}[×]{#17.html#MathJax-Span-49.mostyle="font-family: MathJax_Main; padding-left: 0.238em;"}[2]{#17.html#MathJax-Span-51.mnstyle="font-family: MathJax_Main;"}[]{style="display: inline-block; width: 0px; height: 4.002em;"}]{style="position: absolute; clip: rect(3.202em, 1000.47em, 4.144em, -999.998em); top: -3.998em; left: 0em;"}[−]{#17.html#MathJax-Span-54.mostyle="font-size: 70.7%; font-family: MathJax_Main;"}[3]{#17.html#MathJax-Span-55.mnstyle="font-size: 70.7%; font-family: MathJax_Main;"}]{#17.html#MathJax-Span-53.mrow}]{#17.html#MathJax-Span-52.texatom}[]{style="display: inline-block; width: 0px; height: 4.002em;"}]{style="position: absolute; top: -4.374em; left: 0.52em;"}]{style="display: inline-block; position: relative; width: 1.461em; height: 0px;"}]{#17.html#MathJax-Span-50.msubsup style="padding-left: 0.238em;"}[+]{#17.html#MathJax-Span-56 .mostyle="font-family: MathJax_Main;"}]{#17.html#MathJax-Span-29.mrow}[]{style="display: inline-block; width: 0px; height: 2.355em;"}]{style="position: absolute; clip: rect(1.367em, 1012.85em, 2.591em, -999.998em); top: -2.351em; left: 0em;"}]{style="display: inline-block; position: relative; width: 12.896em; height: 0px; font-size: 125%;"}[]{style="display: inline-block; overflow: hidden; vertical-align: -0.174em; border-left: 0px solid; width: 0px; height: 1.297em;"}]{#17.html#MathJax-Span-28.mathstyle="width: 16.144em; display: inline-block;"}``{=html}[$1 \times 2^{- 1} + 0 \times 2^{- 2} + 0 \times 2^{- 3} +$]{.MJX_Assistive_MathMLrole="presentation"}]{#17.html#MathJax-Element-4-Frame .MathJaxtabindex="0" style="position: relative;"mathml="1×2−1+0×2−2+0×2−3+"role="presentation"}$$\]{.MathJax_Previewstyle="color: inherit; display: none;"}[``{=html}[[1]{#17.html#MathJax-Span-59.mn style="font-family: MathJax_Main;"}[×]{#17.html#MathJax-Span-60 .mostyle="font-family: MathJax_Main; padding-left: 0.238em;"}[2]{#17.html#MathJax-Span-62.mnstyle="font-family: MathJax_Main;"}[]{style="display: inline-block; width: 0px; height: 4.002em;"}]{style="position: absolute; clip: rect(3.202em, 1000.47em, 4.144em, -999.998em); top: -3.998em; left: 0em;"}[−]{#17.html#MathJax-Span-65.mostyle="font-size: 70.7%; font-family: MathJax_Main;"}[4]{#17.html#MathJax-Span-66.mnstyle="font-size: 70.7%; font-family: MathJax_Main;"}]{#17.html#MathJax-Span-64.mrow}]{#17.html#MathJax-Span-63.texatom}[]{style="display: inline-block; width: 0px; height: 4.002em;"}]{style="position: absolute; top: -4.374em; left: 0.52em;"}]{style="display: inline-block; position: relative; width: 1.461em; height: 0px;"}]{#17.html#MathJax-Span-61.msubsup style="padding-left: 0.238em;"}[=]{#17.html#MathJax-Span-67 .mostyle="font-family: MathJax_Main; padding-left: 0.285em;"}[0.5625]{#17.html#MathJax-Span-68.mnstyle="font-family: MathJax_Main; padding-left: 0.285em;"}]{#17.html#MathJax-Span-58.mrow}[]{style="display: inline-block; width: 0px; height: 2.355em;"}]{style="position: absolute; clip: rect(1.32em, 1007.3em, 2.496em, -999.998em); top: -2.351em; left: 0em;"}]{style="display: inline-block; position: relative; width: 7.344em; height: 0px; font-size: 125%;"}[]{style="display: inline-block; overflow: hidden; vertical-align: -0.056em; border-left: 0px solid; width: 0px; height: 1.238em;"}]{#17.html#MathJax-Span-57.mathstyle="width: 9.179em; display: inline-block;"}``{=html}[$1 \times 2^{- 4} = 0.5625$]{.MJX_Assistive_MathMLrole="presentation"}]{#17.html#MathJax-Element-5-Frame .MathJaxtabindex="0" style="position: relative;"mathml="1×2−4=0.5625"role="presentation"}$$和整数的二进制表示采用"除以2，然后看余数"的方式相比，小数部分转换成二进制是用一个相似的反方向操作，就是乘以2，然后看看是否超过 1。如果超过 1，我们就记下 1，并把结果减去1，进一步循环操作。在这里，我们就会看到，0.1其实变成了一个无限循环的二进制小数，0.0[0011]{.orange}0011。这里的"0011"会无限循环下去。![](Images/79724bf5bb74d00aaac6a5d20cc1af1f.png){savepage-src="https://static001.geekbang.org/resource/image/f9/ae/f9213c43f5fa658a2192a68cd26435ae.jpg"}然后，我们把整数部分和小数部分拼接在一起，9.1 这个十进制数就变成了1001.0[0011]{.orange}0011...这样一个二进制表示。上一讲我们讲过，浮点数其实是用二进制的科学计数法来表示的，所以我们可以把小数点左移三位，这个数就变成了：]{.MathJax_Previewstyle="color: inherit; display: none;"}[``{=html}[[1.0010]{#17.html#MathJax-Span-71.mn style="font-family: MathJax_Main;"}]{#17.html#MathJax-Span-70.mrow}[]{style="display: inline-block; width: 0px; height: 2.355em;"}]{style="position: absolute; clip: rect(1.555em, 1002.73em, 2.496em, -999.998em); top: -2.351em; left: 0em;"}]{style="display: inline-block; position: relative; width: 2.779em; height: 0px; font-size: 125%;"}[]{style="display: inline-block; overflow: hidden; vertical-align: -0.056em; border-left: 0px solid; width: 0px; height: 1.003em;"}]{#17.html#MathJax-Span-69.mathstyle="width: 3.485em; display: inline-block;"}``{=html}[$1.0010$]{.MJX_Assistive_MathMLrole="presentation"}]{#17.html#MathJax-Element-6-Frame .MathJaxtabindex="0" style="position: relative;"mathml="1.0010"role="presentation"}$$[[]{.MathJax_Previewstyle="color: inherit; display: none;"}[``{=html}[[0011]{#17.html#MathJax-Span-74.mn style="font-family: MathJax_Main;"}]{#17.html#MathJax-Span-73.mrow}[]{style="display: inline-block; width: 0px; height: 2.355em;"}]{style="position: absolute; clip: rect(1.555em, 1001.93em, 2.496em, -999.998em); top: -2.351em; left: 0em;"}]{style="display: inline-block; position: relative; width: 2.026em; height: 0px; font-size: 125%;"}[]{style="display: inline-block; overflow: hidden; vertical-align: -0.056em; border-left: 0px solid; width: 0px; height: 1.003em;"}]{#17.html#MathJax-Span-72.mathstyle="width: 2.544em; display: inline-block;"}``{=html}[$0011$]{.MJX_Assistive_MathMLrole="presentation"}]{#17.html#MathJax-Element-7-Frame .MathJaxtabindex="0" style="position: relative;"mathml="0011"role="presentation"}]{.orange}$$``{=html}[]{.MathJax_Previewstyle="color: inherit; display: none;"}[``{=html}[[0011]{#17.html#MathJax-Span-77.mn style="font-family: MathJax_Main;"}[...]{#17.html#MathJax-Span-78.mostyle="font-family: MathJax_Main; padding-left: 0.191em;"}[×]{#17.html#MathJax-Span-79.mostyle="font-family: MathJax_Main; padding-left: 0.238em;"}[2]{#17.html#MathJax-Span-81.mnstyle="font-family: MathJax_Main;"}[]{style="display: inline-block; width: 0px; height: 4.002em;"}]{style="position: absolute; clip: rect(3.202em, 1000.47em, 4.144em, -999.998em); top: -3.998em; left: 0em;"}[[3]{#17.html#MathJax-Span-82.mnstyle="font-size: 70.7%; font-family: MathJax_Main;"}[]{style="display: inline-block; width: 0px; height: 4.002em;"}]{style="position: absolute; top: -4.374em; left: 0.52em;"}]{style="display: inline-block; position: relative; width: 0.944em; height: 0px;"}]{#17.html#MathJax-Span-80.msubsup style="padding-left: 0.238em;"}]{#17.html#MathJax-Span-76.mrow}[]{style="display: inline-block; width: 0px; height: 2.355em;"}]{style="position: absolute; clip: rect(1.367em, 1005.55em, 2.496em, -999.998em); top: -2.351em; left: 0em;"}]{style="display: inline-block; position: relative; width: 5.555em; height: 0px; font-size: 125%;"}[]{style="display: inline-block; overflow: hidden; vertical-align: -0.056em; border-left: 0px solid; width: 0px; height: 1.238em;"}]{#17.html#MathJax-Span-75.mathstyle="width: 6.967em; display: inline-block;"}``{=html}[$0011\ldots \times 2^{3}$]{.MJX_Assistive_MathMLrole="presentation"}]{#17.html#MathJax-Element-8-Frame .MathJaxtabindex="0" style="position: relative;"mathml="0011…×23"role="presentation"}$$那这个二进制的科学计数法表示，我们就可以对应到了浮点数的格式里了。这里的符号位s = 0，对应的有效位 f=0010**0011**0011...。因为 f 最长只有 23位，那这里"0011"无限循环，最多到 23位就截止了。于是，f=0010**0011001100110011****001]{.orange}**。最后的一个"0011"循环中的最后一个"1"会被截断掉。对应的指数为e，代表的应该是 3。因为指数位有正又有负，所以指数位在 127之前代表负数，之后代表正数，那 3 其实对应的是加上 127 的偏移量130，转化成二进制，就是 130，对应的就是指数位的二进制，表示出来就是1000**0010**。![](Images/e6261c1ddfc07f69de10ee773ff6fac1.png){savepage-src="https://static001.geekbang.org/resource/image/9a/27/9ace5a7404d1790b03d07bd1b3cb5a27.jpeg"}然后，我们把"s+e+f"拼在一起，就可以得到浮点数 9.1的二进制表示了。最终得到的二进制表示就变成了：01000**0010** 0010 **0011001100110011** **001]{.orange}**如果我们再把这个浮点数表示换算成十进制， 实际准确的值是9.09999942779541015625。相信你现在应该不会感觉奇怪了。我在这里放一个[链接](https://www.h-schmidt.net/FloatConverter/IEEE754.html)，这里提供了直接交互式地设置符号位、指数位和有效位数的操作。你可以直观地看到，32位浮点数每一个 bit的变化，对应的有效位数、指数会变成什么样子以及最后的十进制的计算结果是怎样的。这个也解释了为什么，在上一讲一开始，0.3+0.6=0.899999。因为 0.3转化成浮点数之后，和这里的 9.1 一样，并不是精确的 0.3 了，0.6 和 0.9也是一样的，最后的计算会出现精度问题。
## 浮点数的加法和精度损失搞清楚了怎么把一个十进制的数值，转化成 IEEE-754标准下的浮点数表示，我们现在来看一看浮点数的加法是怎么进行的。其实原理也很简单，你记住六个字就行了，那就是**先对齐、再计算**。两个浮点数的指数位可能是不一样的，所以我们要把两个的指数位，变成一样的，然后只去计算有效位的加法就好了。比如 0.5，表示成浮点数，对应的指数位是 -1，有效位是 00...（后面全是0，记住 f 前默认有一个 1）。0.125 表示成浮点数，对应的指数位是-3，有效位也还是 00...（后面全是 0，记住 f 前默认有一个 1）。那我们在计算 0.5+0.125的浮点数运算的时候，首先要把两个的指数位对齐，也就是把指数位都统一成两个其中较大的-1。对应的有效位 1.00...也要对应右移两位，因为 f 前面有一个默认的1，所以就会变成 0.01。然后我们计算两者相加的有效位 1.f，就变成了有效位1.01，而指数位是 -1，这样就得到了我们想要的加法后的结果。实现这样一个加法，也只需要位移。和整数加法类似的半加器和全加器的方法就能够实现，在电路层面，也并没有引入太多新的复杂性。![](Images/c0e1945fe0fc33996776d759e5fc0553.png){savepage-src="https://static001.geekbang.org/resource/image/d7/f0/d7a6e87da9c0d0b874980ca4306a55f0.jpg"}同样的，你可以用刚才那个链接来试试看，我们这个加法计算的浮点数的结果是不是正确。回到浮点数的加法过程，你会发现，其中指数位较小的数，需要在有效位进行右移，在右移的过程中，最右侧的有效位就被丢弃掉了。这会导致对应的指数位较小的数，在加法发生之前，就**丢失精度**。两个相加数的指数位差的越大，位移的位数越大，可能丢失的精度也就越大。当然，也有可能你的运气非常好，右移丢失的有效位都是0。这种情况下，对应的加法虽然丢失了需要加的数字的精度，但是因为对应的值都是0，实际的加法的数值结果不会有精度损失。32 位浮点数的有效位长度一共只有 23 位，如果两个数的指数位差出 23位，较小的数右移 24位之后，所有的有效位就都丢失了。这也就意味着，虽然浮点数可以表示上到]{.MathJax_Previewstyle="color: inherit; display: none;"}[``{=html}[[3.40]{#17.html#MathJax-Span-85.mn style="font-family: MathJax_Main;"}[×]{#17.html#MathJax-Span-86 .mostyle="font-family: MathJax_Main; padding-left: 0.238em;"}[10]{#17.html#MathJax-Span-88.mnstyle="font-family: MathJax_Main;"}[]{style="display: inline-block; width: 0px; height: 4.002em;"}]{style="position: absolute; clip: rect(3.202em, 1000.94em, 4.144em, -999.998em); top: -3.998em; left: 0em;"}[38]{#17.html#MathJax-Span-91.mnstyle="font-size: 70.7%; font-family: MathJax_Main;"}]{#17.html#MathJax-Span-90.mrow}]{#17.html#MathJax-Span-89.texatom}[]{style="display: inline-block; width: 0px; height: 4.002em;"}]{style="position: absolute; top: -4.374em; left: 0.991em;"}]{style="display: inline-block; position: relative; width: 1.791em; height: 0px;"}]{#17.html#MathJax-Span-87.msubsup style="padding-left: 0.238em;"}]{#17.html#MathJax-Span-84.mrow}[]{style="display: inline-block; width: 0px; height: 2.355em;"}]{style="position: absolute; clip: rect(1.367em, 1004.85em, 2.496em, -999.998em); top: -2.351em; left: 0em;"}]{style="display: inline-block; position: relative; width: 4.849em; height: 0px; font-size: 125%;"}[]{style="display: inline-block; overflow: hidden; vertical-align: -0.056em; border-left: 0px solid; width: 0px; height: 1.238em;"}]{#17.html#MathJax-Span-83.mathstyle="width: 6.073em; display: inline-block;"}``{=html}[$3.40 \times 10^{38}$]{.MJX_Assistive_MathMLrole="presentation"}]{#17.html#MathJax-Element-9-Frame .MathJaxtabindex="0" style="position: relative;"mathml="3.40×1038"role="presentation"}$$，下到 []{.MathJax_Previewstyle="color: inherit; display: none;"}[``{=html}[[1.17]{#17.html#MathJax-Span-94.mn style="font-family: MathJax_Main;"}[×]{#17.html#MathJax-Span-95 .mostyle="font-family: MathJax_Main; padding-left: 0.238em;"}[10]{#17.html#MathJax-Span-97.mnstyle="font-family: MathJax_Main;"}[]{style="display: inline-block; width: 0px; height: 4.002em;"}]{style="position: absolute; clip: rect(3.202em, 1000.94em, 4.144em, -999.998em); top: -3.998em; left: 0em;"}[−]{#17.html#MathJax-Span-100.mostyle="font-size: 70.7%; font-family: MathJax_Main;"}[38]{#17.html#MathJax-Span-101.mnstyle="font-size: 70.7%; font-family: MathJax_Main;"}]{#17.html#MathJax-Span-99.mrow}]{#17.html#MathJax-Span-98.texatom}[]{style="display: inline-block; width: 0px; height: 4.002em;"}]{style="position: absolute; top: -4.374em; left: 0.991em;"}]{style="display: inline-block; position: relative; width: 2.355em; height: 0px;"}]{#17.html#MathJax-Span-96.msubsup style="padding-left: 0.238em;"}]{#17.html#MathJax-Span-93.mrow}[]{style="display: inline-block; width: 0px; height: 2.355em;"}]{style="position: absolute; clip: rect(1.367em, 1005.41em, 2.496em, -999.998em); top: -2.351em; left: 0em;"}]{style="display: inline-block; position: relative; width: 5.414em; height: 0px; font-size: 125%;"}[]{style="display: inline-block; overflow: hidden; vertical-align: -0.056em; border-left: 0px solid; width: 0px; height: 1.238em;"}]{#17.html#MathJax-Span-92.mathstyle="width: 6.779em; display: inline-block;"}``{=html}[$1.17 \times 10^{- 38}$]{.MJX_Assistive_MathMLrole="presentation"}]{#17.html#MathJax-Element-10-Frame .MathJaxtabindex="0" style="position: relative;"mathml="1.17×10−38"role="presentation"}$$这样的数值范围。但是在实际计算的时候，只要两个数，差出]{.MathJax_Previewstyle="color: inherit; display: none;"}[``{=html}[[[[[2]{#17.html#MathJax-Span-105.mnstyle="font-family: MathJax_Main;"}[]{style="display: inline-block; width: 0px; height: 4.002em;"}]{style="position: absolute; clip: rect(3.202em, 1000.47em, 4.144em, -999.998em); top: -3.998em; left: 0em;"}[24]{#17.html#MathJax-Span-108.mnstyle="font-size: 70.7%; font-family: MathJax_Main;"}]{#17.html#MathJax-Span-107.mrow}]{#17.html#MathJax-Span-106.texatom}[]{style="display: inline-block; width: 0px; height: 4.002em;"}]{style="position: absolute; top: -4.374em; left: 0.52em;"}]{style="display: inline-block; position: relative; width: 1.273em; height: 0px;"}]{#17.html#MathJax-Span-104.msubsup}]{#17.html#MathJax-Span-103.mrow}[]{style="display: inline-block; width: 0px; height: 2.308em;"}]{style="position: absolute; clip: rect(1.273em, 1001.27em, 2.449em, -999.998em); top: -2.304em; left: 0em;"}]{style="display: inline-block; position: relative; width: 1.273em; height: 0px; font-size: 125%;"}[]{style="display: inline-block; overflow: hidden; vertical-align: -0.056em; border-left: 0px solid; width: 0px; height: 1.238em;"}]{#17.html#MathJax-Span-102.mathstyle="width: 1.602em; display: inline-block;"}``{=html}[$2^{24}$]{.MJX_Assistive_MathMLrole="presentation"}]{#17.html#MathJax-Element-11-Frame .MathJaxtabindex="0" style="position: relative;"mathml="224"role="presentation"}$$，也就是差不多 1600万倍，那这两个数相加之后，结果完全不会变化。你可以试一下，我下面用一个简单的 Java 程序，让一个值为 2000 万的 32位浮点数和 1 相加，你会发现，+1 这个过程因为精度损失，被"完全抛弃"了。    public class FloatPrecision {  public static void main(String[] args) {    float a = 20000000.0f;    float b = 1.0f;    float c = a + b;    System.out.println("c is " + c);    float d = c - a;    System.out.println("d is " + d);  }}对应的输出结果就是：    c is 2.0E7d is 0.0
## Kahan Summation 算法那么，我们有没有什么办法来解决这个精度丢失问题呢？虽然我们在计算浮点数的时候，常常可以容忍一定的精度损失，但是像上面那样，如果我们连续加2000 万个 1，2000 万的数值都会被精度损失丢掉了，就会影响我们的计算结果。一个常见的应用场景是，在一些"积少成多"的计算过程中，比如在机器学习中，我们经常要计算海量样本计算出来的梯度或者loss，于是会出现几亿个浮点数的相加。每个浮点数可能都差不多大，但是随着累积值的越来越大，就会出现"大数吃小数"的情况。我们可以做一个简单的实验，用一个循环相加 2000 万个 1.0f，最终的结果会是1600 万左右，而不是 2000 万。这是因为，加到 1600万之后的加法因为精度丢失都没有了。这个代码比起上面的使用 2000 万来加 1.0更具有现实意义。    public class FloatPrecision {  public static void main(String[] args) {    float sum = 0.0f;    for (int i = 0; i `{=html}3.**Execute**（**执行指令**），也就是实际运行对应的 R、I、J这些特定的指令，进行算术逻辑操作、数据传输或者直接的地址跳转。4\. 重复进行 1～3 的步骤。这样的步骤，其实就是一个永不停歇的"**Fetch - Decode -Execute**"的循环，我们把这个循环称之为**指令周期**（InstructionCycle）。![](Images/dc4c46535a13d78274ad8d5f99dbf386.png){savepage-src="https://static001.geekbang.org/resource/image/18/a7/1840bead02cfbe5d8f70e2f0a7b962a7.jpg"}```{=html}```指令周期（Instruction Cycle）]{.reference}```{=html}```在这个循环过程中，不同部分其实是由计算机中的不同组件完成的。不知道你还记不记得，我们在专栏一开始讲的计算机组成的五大组件？在取指令的阶段，我们的指令是放在**存储器**里的，实际上，通过 PC寄存器和指令寄存器取出指令的过程，是由**控制器**（ControlUnit）操作的。指令的解码过程，也是由**控制器**进行的。一旦到了执行指令阶段，无论是进行算术操作、逻辑操作的R 型指令，还是进行数据传输、条件分支的 I型指令，都是由**算术逻辑单元**（ALU）操作的，也就是由**运算器**处理的。不过，如果是一个简单的无条件地址跳转，那么我们可以直接在**控制器**里面完成，不需要用到运算器。![](Images/5636ac01d51c296bfdc68a381a51d564.png){savepage-src="https://static001.geekbang.org/resource/image/bd/67/bde3548a4789ba49cab74c8c1ab02a67.jpeg"}```{=html}```不同步骤在不同组件之内完成]{.reference}```{=html}```除了 Instruction Cycle 这个指令周期，在 CPU里面我们还会提到另外两个常见的 Cycle。一个叫**MachineCycle**，**机器周期**或者**CPU 周期**。CPU内部的操作速度很快，但是访问内存的速度却要慢很多。每一条指令都需要从内存里面加载而来，所以我们一般把从内存里面读取一条指令的最短时间，称为CPU 周期。还有一个是我们之前提过的**ClockCycle**，也就是**时钟周期**以及我们机器的主频。一个 CPU周期，通常会由几个时钟周期累积起来。一个 CPU 周期的时间，就是这几个Clock Cycle 的总和。对于一个指令周期来说，我们取出一条指令，然后执行它，至少需要两个 CPU周期。取出指令至少需要一个 CPU 周期，执行至少也需要一个 CPU周期，复杂的指令则需要更多的 CPU 周期。![](Images/afb774f71fc4a14c75bffc27e67d6a29.png){savepage-src="https://static001.geekbang.org/resource/image/1a/48/1a7d2d6cf7cb78a8f48775268f452e48.jpeg"}```{=html}```三个周期（Cycle）之间的关系]{.reference}```{=html}```所以，我们说一个指令周期，包含多个 CPU 周期，而一个 CPU周期包含多个时钟周期。
## 建立数据通路在专栏一开始，不少同学留言问到，ALU就是运算器吗？在讨论计算机五大组件的运算器的时候，我们提到过好几个不同的相关名词，比如ALU、运算器、处理器单元、数据通路，它们之间到底是什么关系呢？名字是什么其实并不重要，一般来说，我们可以认为，数据通路就是我们的处理器单元。它通常由两类原件组成。第一类叫**操作元件**，也叫组合逻辑元件（CombinationalElement），其实就是我们的 ALU。在前面讲 ALU的过程中可以看到，它们的功能就是在特定的输入下，根据下面的组合电路的逻辑，生成特定的输出。第二类叫**存储元件**，也有叫状态元件（StateElement）的。比如我们在计算过程中需要用到的寄存器，无论是通用寄存器还是状态寄存器，其实都是存储元件。我们通过数据总线的方式，把它们连接起来，就可以完成数据的存储、处理和传输了，这就是所谓的**建立数据通路**了。下面我们来说**控制器**。它的逻辑就没那么复杂了。我们可以把它看成只是机械地重复"Fetch -Decode -Execute"循环中的前两个步骤，然后把最后一个步骤，通过控制器产生的控制信号，交给ALU 去处理。听起来是不是很简单？实际上，控制器的电路特别复杂。下面我给你详细解析一下。一方面，所有 CPU支持的指令，都会在控制器里面，被解析成不同的输出信号。我们之前说过，现在的Intel CPU 支持 2000 个以上的指令。这意味着，控制器输出的控制信号，至少有2000 种不同的组合。运算器里的 ALU和各种组合逻辑电路，可以认为是一个固定功能的电路。控制器"翻译"出来的，就是不同的控制信号。这些控制信号，告诉ALU去做不同的计算。可以说正是控制器的存在，让我们可以"编程"来实现功能，能让我们的"存储程序型计算机"名副其实。![](Images/6db51807907dd54d93a768694730186f.png){savepage-src="https://static001.geekbang.org/resource/image/46/6f/46087a894b4ac182fab83ac3786cad6f.jpeg"}```{=html}```指令译码器将输入的机器码，解析成不同的操作码和操作数，然后传输给 ALU进行计算]{.reference}```{=html}```