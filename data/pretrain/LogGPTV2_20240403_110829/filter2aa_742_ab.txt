{
)
echo $line_array[$index];)
echo "";)
})
})
else )
{)
echo "File $file cannot be read!";)
})
})
else )
{)
echo "No file was selected";)
})
?>)
)
)
先是设置`ile变量为post的`ileselection后⾯通过`ile函数对⽂件进⾏操作并没有限制
任何路径，以及能读取到的⽂件类型。导致了任意⽂件读取。)
app_download_zipped_logs.php)
)
)
)
)
)
)
)
)
)
SW Status )
-)
Download Log Files )
-)
Download Zipped Log Files )
)
)
)
$value))
{)
if (gettype($value)=="array"))
{)
foreach ($value as $two_dim_value))
{)
if (empty($files)))
{)
$files=$two_dim_value;
)
})
else )
{)
$files=$files." ".$two_dim_value;)
})
$error=0;)
})
})
else)
{)
if (empty($files)))
{)
$files=$value;)
})
else )
{)
$files=$files." ".$value;)
})
$error=0;)
})
})
)
$docRoot = getWebRootDir();)
if($docRoot == "unknown"))
{)
echo "Failed to locate www document root directory. 
Aborting!";)
return;)
})
)
$download_path=$docRoot."/downloads/";)
if(!is_dir($download_path)))
{)
$command=$docRoot."/scripts/mk_dir.sh ".$download_path;)
$out=shell_exec($command." 2>&1");)
print "Created download directory: $out\n";)
})
)
$command="/usr/bin/zip ".$download_path."kic_logs.zip ".$files;)
echo "";)
if (file_exists($download_path."kic_logs.zip")) )
{)
unlink($download_path."kic_logs.zip");)
})
exec($command);)
)
if (file_exists($download_path."kic_logs.zip")))
{)
echo "  Right click on file 
to download "; )
echo "kic_logs.zip";)
})
if (empty($_POST)))
{)
echo "No file was selected";)
})
else if ($error))
{)
echo "Couldn't create Log package!";)
})
?>)
)
)
这⾥没有看到⿊盒对应的`ileselection[]参数，但`iles变量(这⾥通过foreach随便输
⼊Post参数都⾏，不⼀定⾮得`ileselection[])是从app_download_logs.php)获取过来
的，我们可以看看app_download_logs.php这个⽂件。)
)
)
)
)
)
)
)
)
)
SW Status )
Download Log Files )
)
)
)
)
 Download Log Files )
)
   Select log file(s) to download:)
";)
while (false !== ($file = readdir($handle))))
{)
$pos1 = strrpos($file, ".");)
if ($file != "." && $file != ".." && $pos1 == true))
{)
if( strpos($file, ".00") || strrpos($file, 
".log") ))
{)
if (strlen($file)-$pos1 == 4))
{)
$path = $file_path.$file;)
echo "";)
print_file_info($path);)
})
})
})
})
echo "";)
echo "";)
closedir($handle);)
})
else)
{)
echo "loglist_download-file cannot be read!";)
})
// note: this is also in config_status.php and others also)
function print_file_info($path))
{)
if (file_exists($path)))
{)
echo $path;)
echo "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|
&nbsp;&nbsp;Modified: ";)
echo date("D d M Y g:i",filemtime($path));)
echo "";)
})
})
?>)
)
)
)
我们可以看到app_download_logs.php)其实是有做过滤的，但
app_download_zipped_logs.php)没做后端过滤，我想开发者本意是想通过
app_download_logs.php过滤再传⼊到app_download_zipped_logs.php)做zip打包处
理，但我们明显没按他逻辑先从app_download_logs.php输⼊下载到路径，再打包
⽂件下载。⽽是直接调⽤app_download_zipped_logs.php进⾏打包，所以他这个过
滤等于脱裤⼦放屁。)
漏洞修复建议： 
1.前⾯两个未授权添加上authorization.php进⾏鉴权)
2.限制⽬录穿越，以及可读取跟下载的⽂件内容。)
3.上传功能限制⽬录以及上传⽬录设置不可执⾏，只读权限，限制⽂件上传类型。)
总结： 
我这⾥是先通过找到未授权任意⽂件读取、以及任意⽂件打包，把源码下载后再分
析上传接⼜找到任意⽂件上传。挖掘IOT相关的Web系统的时候可以优先考虑先看
看有没NTP服务、Ping等命令执⾏的地⽅，很⼤概率会调⽤危险函数，可以通过参
数注⼊的⽅式执⾏命令，然后就是上传功能点。⾄于命令执⾏，这⾥太监⼀下，有
意识的⼩伙伴⼤概能从⽂章⾥判断出是什么系统，有个别版本（由于不太通⽤懒得
放出来了）是有上传接⼜可以通过命令注⼊的⽅式执⾏命令RCE，也有聪明的⼩伙
伴可以看到有固件升级的位置，可以考虑构造恶意的固件包，通过升级⽅式进⾏
RCE。)