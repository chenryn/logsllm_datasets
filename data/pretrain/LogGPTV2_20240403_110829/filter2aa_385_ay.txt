information,andwecreatedvariousutilitiesthatallowusto
searchforthisjuicyinformation.
Inthenextchapter,you’lltakealookatpracticalpacket
processing.Specifically,you’lllearnhowtosniffand
manipulatenetworkpackets.
8
RAWPACKETPROCESSING
Inthischapter,you’lllearnhowtocaptureandprocess
networkpackets.Youcanusepacketprocessingformany
purposes,includingtocapturecleartextauthentication
credentials,altertheapplicationfunctionalityofthepackets,
orspoofandpoisontraffic.YoucanalsouseitforSYN
scanningandforportscanningthroughSYN-flood
protections,amongotherthings.
We’llintroduceyoutotheexcellentgopacketpackagefrom
Google,whichwillenableyoutobothdecodepacketsand
reassemblethestreamoftraffic.Thispackageallowsyouto
filtertrafficbyusingtheBerkeleyPacketFilter(BPF),also
calledtcpdumpsyntax;readandwrite.pcapfiles;inspect
variouslayersanddata;andmanipulatepackets.
We’llwalkthroughseveralexamplestoshowyouhowto
identifydevices,filterresults,andcreateaportscannerthat
canbypassSYN-floodprotections.
SETTINGUPYOURENVIRONMENT
Beforeworkingthroughthecodeinthischapter,youneedto
setupyourenvironment.First,installgopacketbyenteringthe
following:
$gogetgithub.com/google/gopacket
Now,gopacketreliesonexternallibrariesanddriversto
bypasstheoperatingsystem’sprotocolstack.Ifyouintendto
compiletheexamplesinthischapterforuseonLinuxor
macOS,you’llneedtoinstalllibpcap-dev.Youcandothiswith
mostpackagemanagementutilitiessuchasapt,yum,orbrew.
Here’showyouinstallitbyusingapt(theinstallationprocess
lookssimilarfortheothertwooptions):
$sudoapt-getinstalllibpcap-dev
Ifyouintendtocompileandruntheexamplesinthis
chapteronWindows,youhaveacoupleofoptions,basedon
whetheryou’regoingtocross-compileornot.Settingupa
developmentenvironmentissimplerifyoudon’tcross-
compile,butinthatcase,you’llhavetocreateaGo
developmentenvironmentonaWindowsmachine,whichcan
beunattractiveifyoudon’twanttoclutteranother
environment.Forthetimebeing,we’llassumeyouhavea
workingenvironmentthatyoucanusetocompileWindows
binaries.Withinthisenvironment,you’llneedtoinstall
WinPcap.Youcandownloadaninstallerforfreefrom
https://www.winpcap.org/.
IDENTIFYINGDEVICESBYUSING
THEPCAPSUBPACKAGE
Beforeyoucancapturenetworktraffic,youmustidentify
availabledevicesonwhichyoucanlisten.Youcandothis
easilyusingthegopacket/pcapsubpackage,whichretrievesthem
withthefollowinghelperfunction:pcap.FindAllDevs()(ifs[]Interface,
errerror).Listing8-1showshowyoucanuseittolistall
availableinterfaces.(Allthecodelistingsattherootlocation
of/existundertheprovidedgithubrepo
https://github.com/blackhat-go/bhg/.)
packagemain
import(
"fmt"
"log"
"github.com/google/gopacket/pcap"
)
funcmain(){
❶devices,err:=pcap.FindAllDevs()
iferr!=nil{
log.Panicln(err)
}
❷for_,device:=rangedevices{
fmt.Println(device.Name❸)
❹for_,address:=rangedevice.Addresses{
❺fmt.Printf("IP:%s\n",address.IP)
fmt.Printf("Netmask:%s\n",address.Netmask)
}
}
}
Listing8-1:Listingtheavailablenetworkdevices(/ch-8/identify/main.go)
Youenumerateyourdevicesbycallingpcap.FindAllDevs()❶.
Thenyouloopthroughthedevicesfound❷.Foreachdevice,
youaccessvariousproperties,includingthedevice.Name❸.You
alsoaccesstheirIPaddressesthroughtheAddressesproperty,
whichisasliceoftypepcap.InterfaceAddress.Youloopthrough
theseaddresses❹,displayingtheIPaddressandnetmaskto
thescreen❺.
ExecutingyourutilityproducesoutputsimilartoListing8-
2.
$gorunmain.go
enp0s5
IP:10.0.1.20
Netmask:ffffff00
IP:fe80::553a:14e7:92d2:114b
Netmask:ffffffffffffffff0000000000000000
any
lo
IP:127.0.0.1
Netmask:ff000000
IP:::1
Netmask:ffffffffffffffffffffffffffffffff
Listing8-2:Outputshowingtheavailablenetworkinterfaces
Theoutputliststheavailablenetworkinterfaces—enp0s5,
any,andlo—aswellastheirIPv4andIPv6addressesand
netmasks.Theoutputonyoursystemwilllikelydifferfrom
thesenetworkdetails,butitshouldbesimilarenoughthatyou
canmakesenseoftheinformation.
LIVECAPTURINGANDFILTERING
RESULTS
Nowthatyouknowhowtoqueryavailabledevices,youcan
usegopacket’sfeaturestocapturelivepacketsoffthewire.In
doingso,you’llalsofilterthesetofpacketsbyusingBPF
syntax.BPFallowsyoutolimitthecontentsofwhatyou
captureanddisplaysothatyouseeonlyrelevanttraffic.It’s
commonlyusedtofiltertrafficbyprotocolandport.For
example,youcouldcreateafiltertoseeallTCPtraffic
destinedforport80.Youcanalsofiltertrafficbydestination
host.AfulldiscussionofBPFsyntaxisbeyondthescopeof
thisbook.ForadditionalwaystouseBPF,takeapeekat
http://www.tcpdump.org/manpages/pcap-filter.7.html.
Listing8-3showsthecode,whichfilterstrafficsothatyou
captureonlyTCPtrafficsenttoorfromport80.
packagemain
import(
"fmt"
"log"
"github.com/google/gopacket"
"github.com/google/gopacket/pcap"
)
❶var(
iface="enp0s5"
snaplen=int32(1600)
promisc=false
timeout=pcap.BlockForever
filter="tcpandport80"
devFound=false
)
funcmain(){
devices,err:=pcap.FindAllDevs()❷
iferr!=nil{
log.Panicln(err)
}
❸for_,device:=rangedevices{
ifdevice.Name==iface{
devFound=true
}
}
if!devFound{
log.Panicf("Devicenamed'%s'doesnotexist\n",iface)
}
❹handle,err:=pcap.OpenLive(iface,snaplen,promisc,timeout)
iferr!=nil{
log.Panicln(err)
}
deferhandle.Close()
❺iferr:=handle.SetBPFFilter(filter);err!=nil{
log.Panicln(err)
}
❻source:=gopacket.NewPacketSource(handle,handle.LinkType())
forpacket:=rangesource.Packets()❼{
fmt.Println(packet)
}
}
Listing8-3:UsingaBPFfiltertocapturespecificnetworktraffic(/ch-
8/filter/main.go)
Thecodestartsbydefiningseveralvariablesnecessaryto
setupthepacketcapture❶.Includedamongtheseisthename
oftheinterfaceonwhichyouwanttocapturedata,the
snapshotlength(theamountofdatatocaptureforeachframe),
thepromiscvariable(whichdetermineswhetheryou’llbe
runningpromiscuousmode),andyourtime-out.Also,you
defineyourBPFfilter:tcpandport80.Thiswillmakesureyou
captureonlypacketsthatmatchthosecriteria.
Withinyourmain()function,youenumeratetheavailable
devices❷,loopingthroughthemtodeterminewhetheryour
desiredcaptureinterfaceexistsinyourdevicelist❸.Ifthe
interfacenamedoesn’texist,thenyoupanic,statingthatit’s
invalid.
Whatremainsintherestofthemain()functionisyour
capturinglogic.Fromahigh-levelperspective,youneedto
firstobtainorcreatea*pcap.Handle,whichallowsyoutoread
andinjectpackets.Usingthishandle,youcanthenapplya
BPFfilterandcreateanewpacketdatasource,fromwhich
youcanreadyourpackets.
Youcreateyour*pcap.Handle(namedhandleinthecode)by
issuingacalltopcap.OpenLive()❹.Thisfunctionreceivesan
interfacename,asnapshotlength,abooleanvaluedefining
whetherit’spromiscuous,andatime-outvalue.Theseinput
variablesarealldefinedpriortothemain()function,aswe
detailedpreviously.Callhandle.SetBPFFilter(filter)tosettheBPF
filterforyourhandle❺,andthenusehandleasaninputwhile
callinggopacket.NewPacketSource(handle,handle.LinkType())tocreatea
newpacketdatasource❻.Thesecondinputvalue,
handle.LinkType(),definesthedecodertousewhenhandling
packets.Lastly,youactuallyreadpacketsfromthewireby
usingalooponsource.Packets()❼,whichreturnsachannel.
Asyoumightrecallfrompreviousexamplesinthisbook,
loopingonachannelcausesthelooptoblockwhenithasno
datatoreadfromthechannel.Whenapacketarrives,youread
itandprintitscontentstoscreen.
TheoutputshouldlooklikeListing8-4.Notethatthe
programrequireselevatedprivilegesbecausewe’rereading
rawcontentoffthenetwork.
$gobuild-ofilter&&sudo./filter
PACKET:74bytes,wirelength74caplength74@2020-04-2608:44:43.074187
-0500CDT
-Layer1(14bytes)=Ethernet{Contents=[..14..]Payload=[..60..]
SrcMAC=00:1c:42:cf:57:11DstMAC=90:72:40:04:33:c1EthernetType=IPv4
Length=0}
-Layer2(20bytes)=IPv4{Contents=[..20..]Payload=[..40..]Version=4
IHL=5
TOS=0Length=60Id=998Flags=DFFragOffset=0TTL=64Protocol=TCP
Checksum=55712
SrcIP=10.0.1.20DstIP=54.164.27.126Options=[]Padding=[]}
-Layer3(40bytes)=TCP{Contents=[..40..]Payload=[]SrcPort=51064
DstPort=80(http)Seq=3543761149Ack=0DataOffset=10FIN=falseSYN=true
RST=false
PSH=falseACK=falseURG=falseECE=falseCWR=falseNS=false
Window=29200
Checksum=23908Urgent=0Options=[..5..]Padding=[]}
PACKET:74bytes,wirelength74caplength74@2020-04-2608:44:43.086706
-0500CDT
-Layer1(14bytes)=Ethernet{Contents=[..14..]Payload=[..60..]
SrcMAC=00:1c:42:cf:57:11DstMAC=90:72:40:04:33:c1EthernetType=IPv4
Length=0}
-Layer2(20bytes)=IPv4{Contents=[..20..]Payload=[..40..]Version=4
IHL=5
TOS=0Length=60Id=23414Flags=DFFragOffset=0TTL=64Protocol=TCP
Checksum=16919
SrcIP=10.0.1.20DstIP=204.79.197.203Options=[]Padding=[]}
-Layer3(40bytes)=TCP{Contents=[..40..]Payload=[]SrcPort=37314
DstPort=80(http)Seq=2821118056Ack=0DataOffset=10FIN=falseSYN=true
RST=false
PSH=falseACK=falseURG=falseECE=falseCWR=falseNS=false
Window=29200
Checksum=40285Urgent=0Options=[..5..]Padding=[]}
Listing8-4:Capturedpacketsloggedtostdout
Althoughtherawoutputisn’tverydigestible,itcertainly
containsaniceseparationofeachlayer.Youcannowuse
utilityfunctions,suchaspacket.ApplicationLayer()andpacket.Data(),to
retrievetherawbytesforasinglelayerortheentirepacket.
Whenyoucombinetheoutputwithhex.Dump(),youcandisplay
thecontentsinamuchmorereadableformat.Playaroundwith
thisonyourown.
SNIFFINGANDDISPLAYING
CLEARTEXTUSERCREDENTIALS
Nowlet’sbuildonthecodeyoujustcreated.You’llreplicate
someofthefunctionalityprovidedbyothertoolstosniffand
displaycleartextusercredentials.
Mostorganizationsnowoperatebyusingswitched
networks,whichsenddatadirectlybetweentwoendpoints
ratherthanasabroadcast,makingithardertopassively
capturetrafficinanenterpriseenvironment.However,the
followingcleartextsniffingattackcanbeusefulwhenpaired
withsomethinglikeAddressResolutionProtocol(ARP)
poisoning,anattackthatcancoerceendpointsinto
communicatingwithamaliciousdeviceonaswitched
network,orwhenyou’recovertlysniffingoutboundtraffic
fromacompromiseduserworkstation.Inthisexample,we’ll
assumeyou’vecompromisedauserworkstationandfocus
solelyoncapturingtrafficthatusesFTPtokeepthecodebrief.
Withtheexceptionofafewsmallchanges,thecodein
Listing8-5isnearlyidenticaltothecodeinListing8-3.
packagemain
import(
"bytes"
"fmt"
"log"
"github.com/google/gopacket"
"github.com/google/gopacket/pcap"
)
var(
iface="enp0s5"
snaplen=int32(1600)
promisc=false
timeout=pcap.BlockForever
❶filter="tcpanddstport21"
devFound=false
)
funcmain(){
devices,err:=pcap.FindAllDevs()
iferr!=nil{
log.Panicln(err)
}
for_,device:=rangedevices{
ifdevice.Name==iface{
devFound=true
}
}
if!devFound{
log.Panicf("Devicenamed'%s'doesnotexist\n",iface)
}
handle,err:=pcap.OpenLive(iface,snaplen,promisc,timeout)
iferr!=nil{
log.Panicln(err)
}
deferhandle.Close()
iferr:=handle.SetBPFFilter(filter);err!=nil{
log.Panicln(err)
}
source:=gopacket.NewPacketSource(handle,handle.LinkType())
forpacket:=rangesource.Packets(){
❷appLayer:=packet.ApplicationLayer()
ifappLayer==nil{
continue
}
❸payload:=appLayer.Payload()
❹ifbytes.Contains(payload,[]byte("USER")){
fmt.Print(string(payload))
}elseifbytes.Contains(payload,[]byte("PASS")){
fmt.Print(string(payload))
}
}
}
Listing8-5:CapturingFTPauthenticationcredentials(/ch-8/ftp/main.go)
Thechangesyoumadeencompassonlyabout10linesof
code.First,youchangeyourBPFfiltertocaptureonlytraffic
destinedforport21(theportcommonlyusedforFTPtraffic)
❶.Therestofthecoderemainsthesameuntilyouprocessthe
packets.
Toprocesspackets,youfirstextracttheapplicationlayer
fromthepacketandchecktoseewhetheritactuallyexists❷,
becausetheapplicationlayercontainstheFTPcommandsand
data.Youlookfortheapplicationlayerbyexaminingwhether
theresponsevaluefrompacket.ApplicationLayer()isnil.Assuming
theapplicationlayerexistsinthepacket,youextractthe
payload(theFTPcommands/data)fromthelayerbycalling
appLayer.Payload()❸.(Therearesimilarmethodsforextracting
andinspectingotherlayersanddata,butyouonlyneedthe
applicationlayerpayload.)Withyourpayloadextracted,you
thencheckwhetherthepayloadcontainseithertheUSERor
PASScommands❹,indicatingthatit’spartofalogin
sequence.Ifitdoes,displaythepayloadtothescreen.
Here’sasamplerunthatcapturesanFTPloginattempt:
$gobuild-oftp&&sudo./ftp
USERsomeuser
PASSpassw0rd
Ofcourse,youcanimprovethiscode.Inthisexample,the
payloadwillbedisplayedifthewordsUSERorPASSexist
anywhereinthepayload.Really,thecodeshouldbesearching
onlythebeginningofthepayloadtoeliminatefalse-positives
thatoccurwhenthosekeywordsappearaspartoffilecontents
transferredbetweenclientandserveroraspartofalonger
wordsuchasPASSAGEorABUSER.Weencourageyoutomake
theseimprovementsasalearningexercise.
PORTSCANNINGTHROUGHSYN-
FLOODPROTECTIONS
InChapter2,youwalkedthroughthecreationofaport
scanner.Youimprovedthecodethroughmultipleiterations
untilyouhadahigh-performingimplementationthatproduced
accurateresults.However,insomeinstances,thatscannercan
stillproduceincorrectresults.Specifically,whenan
organizationemploysSYN-floodprotections,typicallyall
ports—open,closed,andfilteredalike—producethesame
packetexchangetoindicatethattheportisopen.These
protections,knownasSYNcookies,preventSYN-flood
attacksandobfuscatetheattacksurface,producingfalse-
positives.
WhenatargetisusingSYNcookies,howcanyou
determinewhetheraserviceislisteningonaportoradeviceis
falselyshowingthattheportisopen?Afterall,inbothcases,
theTCPthree-wayhandshakeiscompleted.Mosttoolsand
scanners(Nmapincluded)lookatthissequence(orsome
variationofit,basedonthescantypeyou’vechosen)to
determinethestatusoftheport.Therefore,youcan’trelyon
thesetoolstoproduceaccurateresults.
However,ifyouconsiderwhathappensafteryou’ve
establishedaconnection—anexchangeofdata,perhapsinthe
formofaservicebanner—youcandeducewhetheranactual
serviceisresponding.SYN-floodprotectionsgenerallywon’t
exchangepacketsbeyondtheinitialthree-wayhandshake
unlessaserviceislistening,sothepresenceofanyadditional
packetsmightindicatethataserviceexists.
CheckingTCPFlags
ToaccountforSYNcookies,youhavetoextendyourport-
scanningcapabilitiestolookbeyondthethree-wayhandshake