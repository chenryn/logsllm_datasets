类型
31
1615
0
段选择器
偏移量15.0
DPL
权限描述符
Offset
程序进人点偏移量
保留的
P
段当前标志
Segmentselector
目标段选择器
要覆盖的区域
IST
中断栈表
图3.4x86-64中断/陷阱门条目
为了在我们的控制下添加一个新的内核门，可以简单地替换一个条目。实际上，假如漏洞
不允许重置或简化操作，可以通过选择覆盖IDT、DPL、RIPOFFSET的部分条目来达到目的。
（3）。并且，需要修改RIPOFFSET的值使之指向用户级路径。最简单的方法是在用户态/内核
态地址空间模式简单选择一个用户态路径，然后将它的地址写入OFFSET。这是因为我们控制
了用户地址空间，虽然也可以修改一些最重要的地址然后让它指向内核态/用户态的某个地方。
需要注意的是，在这种情况下，我们没有全部控制地址值，并且为了能够成功地将控制转移到
---
## Page 67
58第一部分内核态
常规情况，我们也许需要用到NOP技术之类的技术，就像之前在“放置shellcode”节中描述
的那样。
堆内存破坏
大多数内核临时缓冲区和数据结构体都分配在内核堆上。通常，性能是这些设置的主
要因素，因为堆对象的分配和回收必须尽可能高效。因此，第2章中曾提到，通常在产品
则。现在感兴趣的是，我们是否可以以及如何影响分配器的行为，并且当产生溢出的时候该
如何处理。
控制堆内存分配程序的行为
用户态进程不能直接与内核堆分配程序进行交互，但是它可以通过调用不同的系统调用来
驱动不同种类基于堆的对象的分配。典型的内核提供数百个系统调用以及各种各样的选择。让我
们回到之前的文件系统例子：一个用户进程打开文件，迫使内核结构分配去持续追踪文件的打开
状态。这个结构（其他结构潜在地连接到这个）需要从堆上分配。通过打开成百上千的文件然
后关闭它们，一个用户级程序可以或多或少地增大或缩小内核堆。但是为什么这个重要呢？
内核堆分配程序通常以一种可预测的方式分配和释放对象。通常的工作方式如下：
·为每个通常大小/类型的对象维护一个空闲列表。每次释放一个对象时将其加入这个列表
中（或者在顶端或者在底端）。每次申请对象时返回列表的第一个对象。这种典型的空闲
链表实现了一个后进先出的方法，这就意味着最后释放的对象将在下次分配时返回。
·每个空闲对象维护了一个指向下一个空闲对象的指针，在元数据里面存储着指向下个空
闲对象的指针。为了避免混淆，我们称第一个指针为对象指针，第二个指针为缓存指针。
在每时每刻，总有和空闲对象一样多的对象指针（每个对象保存着下个空闲对象的地址，
最后一个保存着一些终正信息）和一个缓存指针，保存着将要返回的下一个空闲对象的
地址。无论何时请求一个对象，缓存指针都要更新，它表示正在使用这个对象，然后返
回。选中的对象指针保存在缓存指针中。每次释放一个对象时，用存储在缓存指针里面
的地址来更新它的对象指针。
在其生命期的某个时间，分配器将消耗掉所有的空闲对象。在这种情况下，分配器会分
配一个新的页，这个页会以对象为单位划分，然后用来装载空闲链表（如果用的是第1种分配
器），或者初始化指向下一个空闲区的地址，然后标记为空闲（如果用的是第2种分配器）。
正如您所能想象的，不会按分配对象的顺序释放它们，这就意味着，空闲对象在内存里面
不是连续的。由于空闲对象列表影响了分配对象的地址，因此分配对象的地址也不连续了。运
行系统的典型堆布局图就是这样的片段，如图3.5所示。虽然图3.5只给出了一个缓存的状态，
但是这对系统的各种缓存都适用。
正如前面内容所介绍的，可以分配大量大小相等的对象。这就意味着，可以充满缓存然后
迫使它分配新页。当分配一个新页时，某个特定对象接下来将要分配对象的位置一般是可以预
测的。这正是我们所想要利用的。遗憾的是，并不是那么容易，原因如下：
·为了优化性能，分配器会有一些额外的变量。经典的例子是，在SMP系统上，出于性能
---
## Page 68
第3章成功内核利用进阶59
考虑，当需要分配器时，对象的地址还会依赖于当前正运行的处理器，我们可能不能控
制这个属性。这个属性通常定义为位置。
一个特定的系统调用会影响到系统的其他部分，反过来也可能会影响分配程序的行为。
例如，打开上千的文件会产生大量线程，反过来，这会迫使分配程序分配其他不同的对
象。我们必须认真地研究来精确地理解不同的交互。
·需要找到一个打开对象的内核路径，然后保存它的打开状态，直到我们决定关闭它。在
系统调用的生命周期中，许多路径根据运行状况来分配对象和释放对象。这些路径与我
们的目标无关。另外，一些路径可能依赖于用户传递分配空间大小的选项。这些路径对
填充不同的缓存会相当有用。
控制结构
分配的对象
自由对象
自由对象
物理页
缓存
缓存
控制结构
分配的
分配的
自由
自由对象
对象
对象
对象
控制结构
自由
分配的
自由
自由
对象
对象
对象
对象
非连续的物理页
图3.5堆布局图片段
堆溢出利用技术
我们可以在一定程度上控制堆的布局，然后驱动它在特定的位置分配对象。虽然我们不知
道这个位置的虚拟地址，但是可以或多或少确定（决定于我们控制分配器的程度）它与其他对
象的位置关系，如内存、缓存元数据信息以及物理地址范围的其他页。利用堆包括下面3个最
经典的场景，下面我们将详细描述。
重写相邻对象
这个是最常用以及最值得信赖的技术，它可以在几乎任何分配程序上工作。它基本上包
含溢出对象周围的所有重写对象。如果您再次调用在“控制堆内存分配程序的行为”部分的例
子，它基本上意味着通过写入A来溢出C。为了成功使用这个技术，C需要有一些敏感信息。
最理想的选择是为C保存一个指针，这样我们就可以得到“重写全局结构函数指针”部分的结
果，或者在写操作里用到一个数据指针，这样会得到“任意内存重写”部分的结果。
提示虽然找到函数指针是典型的方法，但是这不是唯一的选择。您可以寻找在接下
来的分配中的一个用作长度的变量、一个引用计数器，或者一个操作锁，以及其他选
择，只要您能想得到。
---
## Page 69
60第一部分内核态
生成这样一个场景（通常是以后进先出释放对象的情景）的步骤如下：
1）迫使为缓存分配一个新页。
2）分配一个占位符对象。
3）分配目标对象。
4）释放占位符对象。
5）分配受害对象。
6）触发受害对象中的漏洞（如缓冲区溢出），重写目标对象。
7）迫使目标对象之外的执行。
8）（最终）执行必要的恢复操作作为之前重写的结果。
如果缓存不是以后进先出方式实现的空闲列表，那么需要使用含有两个相邻对象的算法来
替代第2步和第5步，因为这样在目标对象分配后，受害对象会立即分配。如果分配对象和引
起对象溢出是2个解耦操作（例如，您可以得到一个引用然后决定什么时候产生溢出），那么
占位对象变得没必要了。图3.6展示了这种情况的例子。
控制
自由
自由
自由
自由
自由
结构
对象
对象
对象
对象
对象
分配一个新的slab
控制
占位
占位
占位
目标
自由
结构
对象
对象
对象
对象
对象
把目标对象放在紧接最后占位对象之后
控制
占位
占位
自由
目标
自由
结构
对象
对象
对象
对象
对象
释放最后占位对象
控制
占位
占位
被害
目标
自由
结构
对象
对象
对象
对象
对象
把被害对象紧靠目标对象之前
控制
占位
占位
被害
自由
PDC
结构
对象
对象
对象
对象
在目标对象中从被害对象触发溢出
图3.6
重写相邻对象技术
---
## Page 70
第3章成功内核利用进阶61
重写控制结构
一些堆分配器的实现使用了in-cache甚至in-object的控制结构。在这种情况下，我们引
人一种新的基于控制结构中适当成员变量的攻击向量。让我们更仔细地看看它们，首先从in-
cache结构开始。
in-cache结构可能位于每个已分配的页的页首或页尾以持有对象。如果在页首，您几乎不
能做什么，除非您很幸运地控制了一个对象的缓冲区溢出（写缓冲区前面的内容，例如，一个
偏移为负的结果）。我们将在“重写相邻页”部分讨论这种情况下的另一种选择。现在，让我
们集中讨论位于页尾的in-cache控制结构。
有这样一种结构，它拥有各种描述缓存的成员。这些成员的类型和位置在操作系统中随时
变化，但有一些却是相对固定的：
·缓存或者类似标识符的名字
·指向下一个自由对象的指针
·缓存对象的数量
·（最后）在创建和释放对象时调用的构造函数和析构函数（为了了解这有什么用途，请考
虑析构函数添加的大量开销，所以您会想把它放在缓存里）
这并不是一个详尽的潜在成员的列表，但是它确实展示了一些有趣的进入点：
·重写下一个自由对象指针，这可能允许您把分配器指向您控制的可用/可修改的内存。
·重写构建器和析构器的指针（如果它是固定的），这可能导致直接执行代码（在一种和在
“重写全局结构函数指针”部分介绍的很相似的流行方式下）。
·改变缓存里对象的数量，这可能导致一些有趣的分配器行为（例如，尝试从不属于缓存
的内存区域搜集统计数据，从而导致信息泄露）。
我们现在考虑开发多种利用向量，而不是只开发一种并使用它，因为在某些情况下，可能
最终只有几个字节的溢出，并无法达到我们的选择。
现在我们对要重写什么有了一个非常清晰的指导，以下是操作步骤：
1）消耗完缓存以促使分配一个新的页。