getContext-
ClassLoader
getFields
getParent
11
19
11
11
12
12
17
219,792
668,000
36,696
∅ 80,602
Σ 967,227
22
22
11
∅ 14
∪ 24
SUMMARY OF RUNTIMES OF MICRO BENCHMARKS IN MICROSECONDS
(μS) PER SINGLE INVOCATION
TABLE III
Without SM
Orig. Mod.
1000%: getParent, getContext-
ClassLoader, getClassLoader, getSystemClass-
Loader. In all these cases, however, the original execution
time was signiﬁcantly 10 μs per single call, while the
remaining 30 methods show overheads between 0.2 μs and
4 μs. Those two outliers are the same methods that showed
the largest absolute overhead without the security manager.
One of those two outliers is the longest running method before
and after transformation. As can be seen in the second row in
columns 4 and 5, it has a runtime of 79.15 μs per single call in
the original OpenJDK, and 99.65 μs in the modiﬁed OpenJDK.
These two outliers, as discussed before, greatly inﬂuence the
average runtimes. With the security manager in place, the
average runtime increases from 3.80 μs per single method
call to 6.18 μs, which is an average overhead of 2.38 μs.
The median runtime increases from 0.45 μs to 2.05 μs per
single method call, and the median overhead is 1.17 μs. None
of the methods under investigation became faster through our
modiﬁcations, if the security manager is in place.
In summary, one can see that when measuring modi-
ﬁed methods in isolation there is a measurable performance
penalty. However, these penalties are very small in absolute
terms, which is why they do not inﬂuence the runtimes of
real-world applications such as the DaCapo benchmarks.
switching from a shortcut-containing platform to a shortcut-
free platform, and (b) standard permissions of the Java plat-
form cannot equivalently represent some of the privileges
originally gained through shortcuts in terms of their semantics.
In the following, we will elaborate on these issues and discuss
the solution space to spark further research and to aid an actual
application of the proposed hardening into Java’s code base.
We have reported our ﬁndings to the security team at Oracle
Inc. who is, based on our discussions here, considering an
application of this hardening for a future version of Java.
Adjusting security policies
An application’s privileges are usually deﬁned by a set of
permissions granted explicitly in a security policy. This is
not the case for privileges gained through shortcuts, because
they are hard-wired into the JCL. Removing shortcuts will
cause permission checks to be executed that would have
been skipped otherwise, which will require permissions that
were not needed before the change. Some legacy applications
will thus require adjustments to their security policy when
upgrading to a runtime environment that is shortcut-free. This
task can either be done manually by determining the required
permissions through code reviews and dynamic testing, or
automatically by means of a static analysis that computes the
set of required permissions for any given application class.
Appropriate approaches have been proposed earlier [26].
Not all legacy applications are affected by this issue. No
changes of the security policy are required for applications
that do not immediately call shortcut-containing methods, call
them in a way that does not trigger a shortcut, have already
been granted all required permissions anyway, or run without
a security manager.
D. Reason for lack of performance effects
Reworking Java’s standard permissions
The positive performance results might appear surprising at
ﬁrst, however, there is a simple explanation for why a shortcut-
free implementation does not suffer from performance penal-
ties. The reason is that the calls to doPrivileged that the
proposed hardening introduces have, in terms of performance,
a similar effect to shortcuts: At runtime, they cause the stack
walk to terminate early. The JVM checks only the permissions
of code that executes within the doPrivileged-wrapper
but not the calling code’s permissions. This greatly reduces
the number of stack frames that permission checks must
traverse and avoids a performance penalty with current JVM
technology.
VI. PRODUCTIVE USE AND FURTHER RESEARCH
Our proposed solution is functional and comprehensive,
because it allows for the execution of legacy applications and
it avoids the dangers of implicit privilege elevation. Our proof
of concept code shows that such a change is possible without
signiﬁcantly impacting the runtimes of a set of real-world
applications. However, implementing our proposed solution
for productive use requires reconsideration of two aspects: (a)
policies for legacy applications may have to be adjusted when
standard
privileges
cannot
through
permissions
gained
the security policies of
all
shortcuts
their semantics. As an example, a shortcut
Java’s
equivalently
express
in
terms of
in
Class.getDeclaredFields skips a permission check
to access ﬁelds of classes that were
if callers attempt
loaded with the same classloader. After
removing this
the permission check will always be executed
shortcut,
and all
required to have permission
callers will be
RuntimePermission ’accessDeclaredMembers’. As explained
before,
legacy applications can
be updated to grant this permission when upgrading to a
shortcut-free runtime environment with little to no effort.
that granting this permission
However,
provides applications more privileges
than the original
shortcut implementation, as it will allow callers to access
ﬁelds of arbitrary
including private members
the security implications
of
of
because RuntimePermission
’accessDeclaredMembers’ only allows for member access,
i.e., retrieving instances of java.lang.reflect.Field
or java.lang.reflect.Method, and not for reading or
writing any private ﬁeld values, or calling private methods.
system classes. Note that
this
limited
very
are
the problem is
classes,
1037
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:24:58 UTC from IEEE Xplore.  Restrictions apply. 
This is nevertheless an issue, and it is caused by the fact that
some standard permissions are too coarse-grained to be used
in a meaningful manner. Permissions that are supposed to
restrict the use of reﬂection only allow for on/off decisions,
thus either alowing reﬂective access to all available classes,
or none at all.
in contrast
The consequence of coarse-grained standard permissions
is that, when upgrading to a shortcut-free platform, applica-
tions may have to be granted permissions that provide more
privileges than originally granted through shortcuts. This is
inherently risky, as it violates the principle of least privilege.
Even when letting the consequences of our proposed changes
aside, we consider permissions like the reﬂection permissions
as too coarse to be really useful in a security-sensitive setting.
This circumstance is not caused by technical issues, but is
simply a design ﬂaw. Consider Java’s standard ﬁle permission,
which,
to the reﬂection permissions, provides
great ﬂexibility for ﬁne-grained access decisions. It allows
for specifying the ﬁle path to which the permission applies,
as well as the speciﬁc actions that shall be granted, such as
’read’ or ’write’. Similar expressiveness is desired for securely
restricting the use of reﬂection of untrusted applications, and
for adequately compensating for the removal of shortcuts.
We thus argue that a thorough redesign of Java’s standard
permissions is both possible and required. This is a complex
task in itself that needs to take into account technical aspects,
as well as various organizational and human factors. One
of the major challenges is to allow for ﬁne-grained access-
control decisions that support the principle of least privilege,
without being hard to use or performance-wasting. Further,
the permission model should be designed to better support
automatic policy generation for existing applications. We hope
that future research will take on the challenge of developing a
permission model that is both ﬂexible, and usable within the
settings that it is designed for.
VII. LESSONS LEARNED
The work presented here speciﬁcally focuses on access
control as it is implemented in Java. Due to the widespread
use of this platform, our results are of high relevance to
the security of a large number of servers and workstations.
Furthermore, the Java security model is an interesting research
subject, as it is one of the most sophisticated models of its kind
found in modern software. The rigorous analysis presented
here sheds light on how such a complex model is weakened
in practice. Besides the impact our results may have on further
developments of the Java platform, we can also view this work
as a case study and derive a set of general recommendations
for the development of secure software. In the following, we
will highlight general lessons learned, that hopefully serve as
guidance for the design and implementation of other complex
security models.
Explicit privilege elevation aids the protection of privileges.
Our research clearly shows that by elevating privileges ex-
plicitly through constructs such as doPrivileged, one can
avoid the accidental reexposure of those privileges to attackers.
One reason is that doPrivileged elevates privileges tem-
porarily and only within a given lexical scope. Any code refac-
torings performed will move the explicit doPrivileged-
call along with the other code, causing privileges to be raised
only where required. A second reason, though, is the pure
presence of the doPrivileged-call. To JCL maintainers it
not only serves as a security construct but can serve also as a
warning ﬂag: privileges are elevated at this point and need to
be properly protected from being leaked to the outside.
Stick to the security model.
Security models of complex systems are planned and de-
signed prior to implementation. Inconsistencies between de-
sign and implementation can be risky as they hamper proper
evaluation and maintenance. In the concrete case we studied
here, shortcuts are used instead of proper stack-based access
control, which is a deviation from the Java security model that
increases the attack surface. A common practice in software
engineering is to readjust a project plan if it drifts apart from
reality. It should be just as normal to readjust and revaluate a
security model if strictly implementing it as prescribed is not