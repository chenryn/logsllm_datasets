1462    27th USENIX Security Symposium
USENIX Association
startReq1[state] = stateReq1[uri].startwith(‘https://’)code in uripost(code)return uidreturn Nonenot Req0FlagReq0Flag  simplified path network callpath constraintvarsymbolic variable......not refresh_token in Req1not code in urinot Req1[uri].startwith(‘https://’)       return uidrectly generated/ processed in the case of symbolizing
request orders. We take the code variable as the exam-
ple to illustrate the problem. With Req0 (i.e., Step 1 of
Fig. 1), S3KVetter can get a code from the IdP in Step
4 (note that S3KVetter simulates the client device).
If
S3KVetter skips this request and directly sends Req1, to
exchange for an access token in Step 6, S3KVetter has no
choice but to either use an old value or locally generate
a seemingly legitimate code. For both cases, the IdP re-
turns error since the code should be generated by the
IdP server and can only be used for once. As such, the
ﬁrst approach will get stuck in non-core error-processing
paths.
The second solution is to check the return type of the
external function and then returns a random value of
this type without executing the external functions (e.g.,
DART [22]). However, this solution can lead to false
positives. Consider the example above, even when a
code is already used, DART may still return an access
token string (instead of an error message) to the SDK. In
this case, the testing tool may report a false positive: An
attacker can use an old code to login. The third approach
(e.g., KLEENet [40]) is to symbolically explore the ex-
ternal functions as well. However, this is not a viable
approach for our case as we do not have the source code
or binary of the remote IdP server to support symbolic
exploration.
Solution. Due to the different views perceived by
different parties, some requests with nonce parameters,
which are considered to be legitimate by the RP, may
be rejected by the IdP. To tackle such inconsistency,
S3KVetter concretely simulates, and more importantly,
modiﬁes, the entire external world for the SDK under
test. Speciﬁcally, S3KVetter analyzes the IdP behaviors
and directly responds to the RP SDK as if it is the IdP. In-
stead of strictly following the IdP’s behaviors, S3KVetter
modiﬁes the response so that every party has the same
synchronized view on the global system state. To be
more speciﬁc, S3KVetter simulates a slightly different
IdP as follows:
1. Once a nonce parameter is consumed, S3KVetter,
unlike the real-world IdP server, will ﬁrst generate
a new nonce value internally.
2. When S3KVetter starts to explore another path, it
will ﬁrst check whether the previously generated
nonce value satisﬁes the constraints of the path to be
explored or not. If so, directly use this new value.
3. Otherwise, S3KVetter checks the local SDK condi-
tions related to this nonce. Therefore, it uses the
value solved by the constraint solver and stores the
previously generated value for later use.
Since S3KVetter drives the SDK execution, the status
of the SDK is closely tracked by S3KVetter. Therefore,
S3KVetter can internally force its simulated remote IdP
Figure 5: Scheduling for out-of-order requests
attempts to skip any important logic check, break the
multi-step operations or replay requests (as can be seen
in Figure 5). For example, the schedule of {Req1, Req2}
guides S3KVetter to skip the ﬁrst request, a key mile-
stone of the SSO business process, which leads to the
discovery of the vulnerability of use-before-assignment
of the state variable (Section 7.3). Another important
feature is to break/ subvert the order of requests (e.g.,
{Req1, Req0, Req2}), which can lead to the so-called
“failure to revoke authorization” problem [49]. Finally,
the replay function is achieved since every schedule (e.g.,
{Req2}, {Req1,Req2}) will start to explore the SDK
with the same requests (where Req2 is replayed).
Note that S3KVetter will not generate a complete set
of request orderings since an attacker, in theory, can gen-
erate inﬁnite number of request orderings, e.g., by repeat-
ing each request arbitrary number of times. However,
according to our experience, the scheduler we incorpo-
rated into S3KVetter can generate a rich set of promising
patterns/ request orderings. Nonetheless, with the frame-
work of S3KVetter, it is relatively straightforward to in-
corporate additional patterns, if any, developed in the fu-
ture.
4.1.2 Coordinating among Multiple Parties Silently
SSO applications need to communicate among multi-
ple parties. Unfortunately, existing symbolic execution
frameworks are not designed for distributed multi-party
systems. To ﬁll this gap, researchers actually have devel-
oped different approaches, but none of them work per-
fectly for SSO-like applications. The key problem of
existing solutions is that different parties have different
views of the entire system status if we break the request
orders. The case becomes worse in the existence of one-
time-use parameters (e.g., code, state, etc.). Below we
illustrate the limitations of existing approaches.
The ﬁrst approach is to concretely run the external
functions. However, since the IdP server typically im-
poses limit on API access rate, a large number of invoca-
tions of the external functions can easily hit the control
threshold and lead to unexpected responses. Worse still,
the widely used one-time-use parameters cannot be cor-
USENIX Association
27th USENIX Security Symposium    1463
Req0Req1Req2Req2Req2Req1Req2Req0Req2Req0Req1InputSchedule 1Schedule 2Schedule 3Schedule 4Time Sequenceto bypass logic checksto break multi-step operation4.2 Translating the Predicate Tree
To support formal reasoning, we should translate the ex-
tracted tree (e.g., Fig. 4) to a set of Boolean logic for-
mulae. Given the simple syntax of logic languages (e.g.,
SMT-Lib v2.0), the translation is relatively straightfor-
ward. We also observe that every node in the predicate
tree can be readily represented as a logic formula. Ob-
serve from Fig. 4 that the node which checks whether
uri contains a code parameter can be represented as
(str.contains uri code) in the language of SMT-Lib.
To get the ﬁnal computation result (i.e., reach the leaf
node), all the node logic formulae from the root to the
target leaf node should be satisﬁed. Therefore, a pro-
gram path can be represented as the conjunction of all
the node logic formulae along this path. Similarly, we
can use the disjunction of all the path logic formulae to
represent the entire predicate tree.
4.3 Reasoning Predicates
The goal of S3KVetter is to detect ﬂawed SDK imple-
mentations by checking the logic in the SDK internals.
To achieve this goal, we may proceed in two ways. The
ﬁrst is to model all the incorrect logic patterns. However,
it is difﬁcult to generate such an exhaustive list. There-
fore, we take an alternative approach by modeling the
correct logic that should be enforced by the SDK. Then
we can check whether the SDK under test follows these
logical conditions or not.
4.3.1 Deﬁning Security Property
An SSO system involves interactions among the user,
the RP server and the IdP server, where any weak com-
munication links (i.e., 11 steps in Fig. 1) can lead to
logic ﬂaws. It is difﬁcult to develop the security require-
ments for each link since neither protocol speciﬁcation
nor developer documentation explicitly deﬁnes the secu-
rity goal for each method/ API call. Typically, the de-
veloper guidelines instruct a party to complete a set of
operations and hope that the ﬁnal security guarantee can
be automatically reached by these operations. It is there-
fore more intuitive to deﬁne the ﬁnal security goal (i.e.,
authentication property) for the RP server, which is the
focus of this paper.
In particular, we have one key observation to secure
the Single Sign-On service: An RP server should login a
user if and only if the exact user has actually authorized
this speciﬁc RP. To be more speciﬁc, an RP server can
accept a user’s login request in Step 5 of Fig. 1 if and
only if the exactly same user has authenticated and/or
authorized this speciﬁc RP in Step 3. Given this insight,
we develop the predicates which must be satisﬁed by a
secure SSO transaction, as presented in Listing 1.
Figure 6: Illustration of multiparty coordination
server to synchronize its own state with the SDK. As
such, both parties can automatically share the same view
without any code changes by the SDK. Below, we illus-
trate this idea with the code example.
Code Example: Fig. 6 illustrates how S3KVetter
can coordinate multiple parties with the code example.
Through Path1, the RP can obtain the user information
with a fresh code. Upon completion of Path1, the used
code is invalidated. But at the same time, S3KVetter
dynamically generates a new random code(cid:48). When ex-
ploring Path2 (where we skip Req0), S3KVetter ﬁnds
that code(cid:48) satisﬁes the path constraint (code(cid:48) (cid:54)= None)
and therefore provides the code(cid:48) for the SDK. Now this
code(cid:48) is pre-generated and becomes valid. For Path3,
S3KVetter ﬁnds that this path requires len(code) = 0.
As such, S3KVetter provides an empty value solved by
the constraint solver for the SDK (and puts another on-
the-ﬂy generated code(cid:48)(cid:48) aside).
Implementations: The implementation requires to
model the IdP server so that S3KVetter, in most cases,
can rely on the SDK as the real IdP. One key observation
is that IdPs typically follow the speciﬁcation and provide
similar functions. Therefore, we just need to model one
IdP server, and the resultant model can work for multiple
SDKs. The implementation involves two major steps.
The ﬁrst step is to infer and model the real-world IdP
behaviors, which turns out to be not that challenging.
On one hand, we follow existing work [5, 46] to per-
form blackbox differential fuzzing analysis (i.e., under
different input arguments and app settings) for a better
understanding of the conditional checking enforced by
real IdPs. On the other hand, we also refer to the proto-
type IdP implementations provided by some open source
projects [17]. Second, we implement stub methods for
all the common network API methods of Python (e.g.,
requests, urllib, etc.). Upon any network requests, our
instrumented functions are invoked instead and reply the
SDK on behalf of the IdP server.
1464    27th USENIX Security Symposium
USENIX Association
startReq1[uri].startwith(‘https://’)code in uripost(code)return uidnot RT in Req1not code in uripost(code’)post(none)return errorPath1Path2Path3return uidw/ or w/o Req0 The clause in Line 1 (Clause 1) asserts that the user
stored by the RP session should be the owner of the re-
ceived access token, so does the code and refresh token
(if exist) in the second and third clauses. Clause 4 and
Clause 5 assert that the access token and refresh token
(if any) should be correctly passed to the intended RP,
not to any other RPs (which would then use this token
to log into this RP illegally). Clause 6 reﬂects the re-
quirements that the ﬁnal logged-in user should be the one
who authenticates/ authorizes with the IdP. We know that
S3KVetter simulates the IdP behavior. Therefore, the
IdP’s session data can be readily accessed by S3KVetter.
Listing 1: Security Property for SSO Services6
1 RPsession.uid == TokenRecordsOnIdP[
RPsession.access_token].uid and
2 RPsession.uid == CodeRecordsOnIdP[
RPsession.code].uid and
3 RPsession.uid == TokenRecordsOnIdP[
RPsession.refresh_token].uid and
4 client_id == TokenRecordsOnIdP[RPsession
.access_token].client_id and
5 client_id == TokenRecordsOnIdP[RPsession
.refresh_token].client_id and
6 RPsession.uid == IdPsession.uid
By checking against the required list of security prop-
erties, one can effectively expose the presences of nu-
merous vulnerabilities. Any violation of a security prop-
erty can lead to a vulnerability in practice. For exam-
ple, if Clause 1 does not hold, then it means the RP does
not use the access token to identify the user, which can
make proﬁle attacks [47] possible. A more elaborated
example is Clause 6, which can be violated in two dif-
ferent cases: (1) it is possible that an attacker eaves-
drops the victim’s code and uses it to sign into the RP
(i.e., RPsession.uid = victim and IdPsession.uid =
attacker) ; (2) it can also be the result of a CSRF attack,
in which the attacker makes the victim’s browser to send
the RP a crafted request with the attacker’s code (i.e.,
RPsession.uid = attacker and IdPsession.uid =
victim).
5
Implementations of S3KVetter
We have implemented a full-featured prototype of
S3KVetter in Python with 5064 lines of code. While
its current implementation only focuses on SSO SDKs
written in Python, our techniques can be naturally ap-
plied to SDK developed in other languages. To avoid
reinventing the wheel, we have integrated and extended
several open-source programs as supporting modules for
S3KVetter. In Module 1 of Fig. 2, we extend PyExZ3 [6],
a concolic execution engine for Python, to enhance the
extraction of program predicates from production-level
SDKs. We also substitute the default constraint solver
of PyExZ3 (Z3) with CVC4 because the latter has better
support for our heavily-used string operations with neg-
ligible performance penalty7. For Module 2 in Fig. 2, we
choose SMT-Lib v2.0 which uses ﬁrst-order logic with
quantiﬁer to represent the translated predicate tree. The
logic language provided by SMT-Lib is not only expres-
sive enough but also widely accepted by most theorem
provers. This also allows us to directly use CVC4 in
Module 3 of Fig. 2 to reason about the program predi-
cates.
6 Evaluation
To determine the effectiveness of our approach, we per-
form evaluations on ten popular Single-Sign-On SDKs.
S3KVetter shows considerable improvement in terms of
code coverage when comparing to an unmodiﬁed sym-
bolic execution engine (without our proposed extensions
and heuristics). More importantly, we uncover four types
of previously unknown vulnerabilities and provide new
insights of SSO services.
6.1 Dataset
Table 1 shows the statistics of the SDKs under test.
These SDKs are carefully selected from ofﬁcial refer-
ences and high-proﬁle open source SDKs in Github. In
particular, they have covered the two most popular pro-
tocols (i.e., OAuth2.0 and OpenID Connect) and both of
the widely used authorization grant ﬂows, namely, the
implicit ﬂow and the authorization code ﬂow. The num-
ber of downloads for each SDK was retrieved on Oct
2017 from PyPI statistics [2] – a website which provides
runtime statistics of PyPI published packages. Note that
these statistics provide a conservative estimate on the us-
age of these SDKs: only the installation of released ver-
sion via pip counts. If developers install a SDK directly
from its source code (e.g., via ofﬁcial webpage or Git),
the suggested way for many IdPs (e.g., Facebook, We-
ichat, Renren, Douban), then the installation will not be
included in the statistics.
Regarding the lines of code, some libraries (e.g.,
Request-OAuthLib and OAuthLib) are considerably
larger. This is because those SDKs provide general-
ized, full-featured and speciﬁcation-compliant support
for multiple IdPs.
In contrast, some small SDKs only
implement simple and basic functions for a speciﬁc IdP.
6For ease of presentation, we use the line number to represent the
clause. For example, the clause in the ﬁrst line is denoted as Clause 1.
7CVC4 and Z3 perform very similarly in different benchmarks dur-
ing the Satisﬁability Module Theories (SMT) competition [4].
USENIX Association
27th USENIX Security Symposium    1465
Table 1: Statistics of SDK under Study
SDK Names
Lines of
code
# of
downloads
Grant ﬂow
under study
Facebook SDK
Request-OAuthLib
OAuthLib
Sinaweibopy
OAuth2Lib
Rauth
Python-weixin
Boxsdk
Renrenpy
Douban-client
976
15432
17917
800
971
9241
2736
15277
251
2092
602,291
4,785,778
6,476,894
28,019
not found
487,275
1,404
77,074
10,387
30,601
implicit
code
code
code
code
code
code
code
code
implicit
Baseline with unmodiﬁed PyExZ3
Improved result with S3KVetter
# of path
discovered
8
322
640
2
2
2
2
2
2
1
statement
coverage
45%
37%
41%
43%