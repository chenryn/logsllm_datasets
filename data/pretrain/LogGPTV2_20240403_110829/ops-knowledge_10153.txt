User: 请回答以下安全问题为什么我们不应该自己滚？为什么我们不应该创建自己的安全方案？
我在这里看到了很多关于自定义加密和自定义安全机制的问题，尤其是关于密码哈希的问题。
考虑到这一点，我正在寻找一个具有以下属性的规范答案：
新手很容易理解。
清楚而明确地说明为什么自己滚动是个坏主意。
提供了强有力的例子。
强制性xkcd。

Assistant: 你可以自己滚动，但如果你不是安全/密码学专家，或者让多名专家分析了你的方案，你可能会犯下重大的安全错误。我更愿意把赌注押在一个公开的开源加密方案上，让所有人都能看到和分析。更多的眼睛意味着当前版本更有可能没有重大漏洞，而不是由非专家内部开发的漏洞。
摘自Phil Zimmermann（PGP创建者）的《密码学导论》（第54页）：
70年代初，当我在大学时，我设计了一个我认为非常棒的
加密方案。一个简单的伪随机数流被添加到
明文流以创建密文。这似乎会阻碍任何
密码文本的频率分析，甚至对
最足智多谋的政府情报机构。我为我的
成就
几年后，我在几次介绍中发现了同样的方案
密码学文本和教程论文。多好啊。其他密码学家
想到了同样的方案。不幸的是，该计划被介绍为
关于如何使用初等密码分析的简单作业
琐碎地破解它的技巧。我的绝妙计划到此为止。
从这次令人谦卑的经历中，我了解到陷入错误的感觉是多么容易
设计加密算法时的安全性。大多数人没有意识到
设计一种能够
经受住足智多谋的对手长期而坚决的进攻。
（这个问题对上面的引用有更多的讨论。）
如果你不相信“Don't Roll Your Own[Cryptography/Security]”，那么你可能不是专家，你可能会犯很多错误。
您的应用在以下方面是否稳健：
定时攻击。例如，完全坏的密钥和部分坏的密钥总共需要相同的时间才能失败吗？否则，可以利用此计时信息来查找正确的密钥/密码。
琐碎的暴力攻击；例如，这可以在几秒钟到几年内完成（当你担心它在几年内被破坏时）。也许你的安全概念可能是十亿分之一（100000）的机会闯入（如果有人使用机器人网络尝试了几十亿次怎么办？）。我的想法是瞄准大约2128分之一（3400000000000000000000000000000000000000），这大约是安全性的1000亿倍，完全超出了猜测的范围。
并行攻击用户帐户；例如，你可以在数据库中的所有密码散列上使用相同（或者更糟的是没有）的“salt”来散列密码，就像泄露的LinkedIn散列一样。
简单地攻击任何特定帐户。也许每个简单散列（例如MD5/SHA1/SHA2）密码都有一个唯一的随机盐，但由于每秒可以在任何散列上尝试数十亿个可能的密码，因此使用常见的密码列表、字典攻击等，攻击者可能只需要几秒钟就可以破解大多数帐户。使用像bcrypt或PBKDF2这样的强密码散列，以适当的因子（通常为10（3-8））来避免或密钥加强常规散列。
对可猜测/弱“随机”数字的攻击。也许你像几年前Debian OpenSSL那样，使用微时间/MT rand或太少的信息来生成伪随机数。
绕过保护的攻击。也许您在web应用的客户端进行了散列/输入验证，但这被用户更改脚本所绕过。或者您有一个本地应用，客户端尝试在虚拟机中运行，或者对其进行反汇编以对其进行逆向工程/更改内存/或以其他方式作弊。
其他攻击，包括（但不试图成为完整列表）CSRF、XSS、SQL注入、网络窃听、重放攻击、中间人攻击、缓冲区溢出等。最好的保护措施很快总结出来。
CSRF：要求在POST操作上随机生成CSRF令牌；XSS：在输入数据库并显示给用户/浏览器之前，始终验证/转义不受信任的用户输入。
SQLi：始终使用绑定参数并限制返回的结果数量。
窃听：加密敏感网络流量。
重放：在每个事务中放入唯一的一次性随机数。
缓解措施：信任网站/与上次访问的网站相同/由受信任的CA颁发的证书。
缓冲区溢出：安全编程语言/库/可执行空间保护等）。
你只有和你最薄弱的可利用环节一样强大。同样，仅仅因为你没有推出自己的计划，并不意味着你的计划会是安全的，很可能创建你推出的计划的人不是专家，或者创建了一个薄弱的计划。