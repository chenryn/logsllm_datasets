个字母（k值），字母e的ASClI码是101，而字母y的ASCII码是121，显然eT，适因值>0，若S=T，返图0，若S0）
1
n-StrLength（s）;
1得到主串S的长度·/
m=StrLength（T）;
/得到子串T的长度
1-pos;
while（iT[0]）
returni-T[0];
else
return 0;
分析一下，最好的情况是什么？那就是一开始就区配成功，比如“googegood”
中去找googke”，时间复杂度为0（1）.稍差一些，如果像刚才例子中第二、三、四位
一样，每次都是首字母就不匹配，那么对T串的循环就不必进行了，比如
“abcdefgooge”中去找“googe”。那么时间复杂度为0（n+m)，其中n为主串长度，
m为要匹配的子串长度。根据等概率原则，平均是（n+m）/2次查找，时间复杂度为
O(n+m)-
那么最坏的情况又是什么？就是每次不成功的匹配都发生在串T的最后一个字
符。举一个很极端的例子。主串为S=“000000000000000000000000000000000000
06晋牌1000000000申6210000000000000
1个“1”的主串，后者是9个“0”和1个“1”的子串。在匹配时，每次都得将T
中字符循环到最后一位才发现：哦，原来它们是不匹配的。这样等于T串需要在S串
的前40个位置都需要判断10次，并得出不匹配的结论，如图5-6-6所示。
50位字符
50位字符
….1
000-..01
10位字特
10位字持