3.3取非匹配
21
结果
TOPMARGIN=** LEFTMARGIN=*8′>
MARGINWIDTH=′θ* MARGINHEIGHT=*@*
分析
这里使用的模式以普通字符#开头，随后是6个同样的[e-9A-Fa-f]
字符集合。这将匹配一个由字符开头，然后是6个数字或字母A到F（大
小写均可）的字符串。
3.3取非匹配
字符集合通常用来指定一组必须匹配其中之一的字符。但在某些场
合，我们需要反过来做，给出一组不需要得到的字符。换句话说，除了
邢个字符集合里的宇符，其他宇符都可以匹配。
最先想到的办法是，用一个字符集合把你需要的字符一一列举出来，
但如果只需要把一小部分字符排除在外的话，那么做既麻烦又容易有遗
漏，其实这里有一个更简明的办法：用元字符来表明你想对一个字符集
合进行取非匹配。这与逻辑非运算很相似，只是这里的操作数是字符集合
面已。
文本
sales1.xls
orders3.x1s
sales2.x1s
sales3.x1s
apac1.x1s
europe2.x1s
na1 x1s
sam.x1s
na2.x1s
ca1,x1s
sa1,×1s
正则表达式
[ns]a[ ~0 ·9]1 .×1s
结果
sales1.x1s
---
## Page 32
22
第3章匹配一组字符
orders3.x1s
sales3.x1s
sales2.x1s
apac1.x1s
europe2.x1s
san.xls
na1 ×1s
na2.x1s
sa1-x1s
ca1.x1s
分析
这个例子里使用的模式与前面的例子里使用的模式刚好相反。前面
[0-9]只匹配数字，而这里[~0-9]匹配的是任何不是数字的字符。也就是
说，[ns]a[~0-9]\.x1s将匹配sam,x1s，但不匹配na1.x1s、na2.x1s或
sal.xls.
注意的效果将作用于给定字符集合里的所有字符或字符区
间，而不是仅限于紧跟在字将后面的那一个字符或字符区间。
3.4小结
元字符[和】用来定义一个字符集合，其含义是必须匹配该集合里的
字符之一。定义一个字符集合的具体做法有两种：一是把所有的字符都
列举出来：二是利用元字符-以字符区间的方式给出。字符集合可以用元
字符来求非：这将把给定的字符集合强行排除在匹配操作以外，除了该
字符集合里的字符，其他字符都可以被匹配。
---
## Page 33
使用元字符
本书第一次提到元字符的章节是第2章。在这一章里，你们将学习如
何使用更多的元字符去匹配特定的字符或字符类型。
4.1对特殊字符进行转义
在介绍其他元字符的用法之前，我们认为应该先把特殊字符的转义
问题向大家解释清楚。
元字符是一些在正则表达式里有着特殊含义的字符，英文句号（，）
是一个元字符，它可以用来匹配任何一个单个字符（详见第2章）。类似
地，左方括号（[）也是一个元字符，它标志着一个字符集合的开始（详
见第3章）。
因为元字符在正则表达式里有着特殊的含义，所以这些字符就无法
用来代表它们本身。比如说，你不能使用一个[来匹配[本身，也不能使
用，来匹配.本身。来看一个例子，我们打算用一个正则表达式去匹配一
个包含着[和]字符的JavaScript数组：
文本
var myArray = ner Array();
if (myArray[0] -- 0) (
正则表达式
myArray[8]
---
## Page 34
24第4章使用元宇符
结果
var myArray = ner Array();
if (myArray[e] == ) {
分析
在这个例子里，原始文本是一段JavaScript代码，正则表达式则是程
序员在使用一个文本编辑器去编写JavaScript代码时经常会用到的搜索字
符串。我们的本意是用这个正则表达式把代码里的myArray[0]记号找出
来，可结果与预期完全不一样。为什么会这样？因为[和]在正则表达式
里是用来定义一个字符集合（而不是【和]本身）的元字符，所以，
myArray[e]将匹配myArray后面跟着一个该集合成员的情况，而那个集合
只有一个成员0。因此，myArray[@]只能匹配到myArray@
正如我们在第2章里解释的那样，在元字符的前面加上一个反斜杠就
可以对它进行转义：转义序列\.将匹配，本身，转义序列\[将匹配[本身。
每个元字符都可以通过给它加上有个反斜杠前缓的办法来转义，如此得
到的转义序列将匹配那个字符本身而不是它特殊的元字符含义。要想匹
配[和]，就必须对这两个字符进行转义。下面的例子与刚才的问题完全
一样，但我们这次对正则表达式里的元字符都进行了转义。
文本
var myArray = new Array();
if (myArray[e] = ) {
正则表达式
nyArray\ [0]
结果
var myArray = new Array();
if (myArray[0] -- 0)(
---
## Page 35
4.1对特殊字持进行转义
25
分析
这次搜索取得了预期的结果。\[将匹配[，\]将匹配]，所以
myArray\[@\]匹配到了myArray[0] 。
具体到这个例子，用一个正则表达式来进行搜索多少有点儿小题大
做，因为一个简单的文本匹配操作已足以完成这一任务，而且还会更容易
一些。但如果你想查找的不仅仅是myArray[θ]，还包括了myArray[1]、
myArray[2]等，用一个正则表达式来进行搜索就很有必要了。具体做
法是，对[和]进行转义，再列出需要在它们之间得到匹配的字符。如
果你想匹配数组元素0到9，你构造出来的正则表达式应该是下面这个
样子：
I [6 -11,AeJJAu
提示任何一个元字符都可以通过给它加上一个反斜杠字符
（）作为前级的办法来转义，能够被转义的元字符并不仅局限
于我们这里提到的那几个。
警告配对的元字符（比如[或]）不用作元字符时必须被转义，
否则正则表达式分析器很可能会抛出一个错误。
对元字符进行转义需要用到\字符。这意味着\字符也是一个元字
符，它的特殊含义是对其他元字符进行转义。正如你在第2章里看到的那
样，在需要匹配\本身的时候，我们必须把它转义为\\。
者者下面这个简单的例子。例子中的原始文本是一个包含者反斜杠
字符的文件路径（用于DOS和Windows系统），而我们想在一个Linux或
Unix系统上使用这个路径，也就是说，我们需要把这个路径里的反斜杠字
符（\）全部替换为正斜杠字符（/）：
文本
(hone\ben)sales)
---
## Page 36
第4章使用元字符
正则表达式
11
结果
[hone(benjsales]
分析
\匹配\，总共找到了4个匹配。如果你在这个正则表达式里只写出
了一个\，你应该会看到一条出错消息。这是因为正则表达式分析器会认
为你的正则表达式不完整，在一个完整的正则表达式里，字符\的后面永
远跟着另一个字符。
4.2匹配空白字符
元字符大致可以分为两种：一种是用来匹配文本的（比如.），另一
种是正则表达式的语法所要求的（比如[和】）。随着学习的深入，你将发
现越来越多的这两种元字符，而我们现在要介绍给大家的是一些用来匹
配各种空白字符的元字符。
在进行正则表达式搜索的时候，我们经常会遇到需要对原始文本里
的非打印空白字符进行匹配的情况。比如说，我们可能需要把所有的制
表符找出来，或者我们需要把换行符找出来，这类字符很难被直接输入
到一个正则表达式里，但我们可以使用表4-1列出的特殊元字符来输入
它们。
表4-1空白元字符
元字符
说明
[b]
回退（并删除)一个字符（Backspacel健)
\f
换页符
 In
换行符
回车符
\t
别表符（Tab键)
1v
垂直制表符
---
## Page 37
4.2医配空白宇符27
我们来看一个例子。例子中的原始文本包含着一些以逗号分隔（CSV
格式）的数据记录，面我们的任务是在对这些记录做进一步处理之前，
先把夹杂在这些数据里的空白行去掉。我们是这么做的：
文本
*102°,*Jim′,*Janes′
'101°, *Ben′,°Forta′
*184*,*Bob′,*Bobson*
‘1e3°, *Roberta′, *Robertson’
正则表达式
le,n1n
结果
"101°,*Ben*,*Forta”
*102°,*Jin′, *James*
“104°,*Bob*,*Bobson”
*1e3°, *Roberta*,*Robertson”
分析
\r\n匹配一个“回车+换行”组合，有许多操作系统（比如Windows）
都把这个组合用作文本行的结束标签。使用正则表达式\r\n\r\n进行的
搜索将匹配两个连续的行尾标签，面那正是两条记录之间的空白行。
提示r\n是Windows所使用的文本行结束标签。Unix和Linux
系统只使用一个换行符来结来一个文本行：换句话说，在
Unix/Linux系统上匹配空白行只使用\n\n即可，不需要加上\r。
同时适用于Windows和Unix/Linux系统的正则表达式应该包含
一个可选的\r和一个必须被匹配的\n。你可以在下一章看到一
个这样的例子。
般来说，需要匹配\r、\n和\t（制表符）等空白字符的情况比较
多见，需要匹配其他空白字符的情况要相对少一些。
---
## Page 38
28
第4章使用元字符
了吗？，和[是元字持，但前提是你没有对它们进行转义。f和n
也是元字符，但前提是你对它们进行了转义。如果你没有对f
和n进行转义，它们将被解释为普通字符、只能匹配它们本身。
4.3
匹配特定的字符类别
到目前为止，你已经见过如何匹配特定的字符、如何匹配任意单个
字符（用.）、如何匹配多个字符中的某一个（用【和]）以及如何进行取
非匹配（用~）。字符集合（匹配多个字符中的某一个）是最常见的匹配
形式，面一些常用的字符集合可以用特殊元字符来代替。这些元字符匹
配的是某一类别的字符（术语称之为“字符类”）。类元字符并不是必不
可少的东西（你总是可以通过逐一列举有关字符或是通过定义一个字符
区间的办法来匹配某一类字符），但用它们构造出来的正则表达式简明易
懂，在实践中很有用。
下面列出的字符类都是最基本的，几乎所有的正则表达
式实现都支持它们。
4.3.1匹配数字（与非数字）
我们在第3章讲过，[0-9]是[0123456789】的简写形式，它可以用来
匹配任何一个数字。如果你想匹配的是除数字以外的其他东西，那么把
这个集合“反”过来写成[~0-9]就行了。表4-2列出了用来匹配数字和非
数字的类元字符。
表4-2数字元字符
元字符
说明
Id
任何一个数字字符（等价干[0-9]）
（[）
为了演示这些元字符的用法，我们来看一个在前面见过的例子：
---
## Page 39
4.3匹配特定的字符类别
29
文本
var myArray = nee Array();
if (myArray[0] -- 0)(
正则表达式
myArray [1d.]
结果
var myArray = new Array();
if (myArray[0] -- 0) (
分析
\[匹配[，\d匹配任意单个数字字符，\]匹配]，所以myArray\[\d\]匹
配出myArray[0]。myArray\[\d\]是myArray\[[0-9]\]的简写形式,而后
者又是myArray[[0123456789】\]的简写形式。这个正则表达式还可以匹配