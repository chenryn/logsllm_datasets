to the readers. To sum up, DPRFs ﬁnd excellent applica-
tion in authentication and access control in RFIDs, enabling
bandwidth-eﬃcient tag key delegation from the TC to the
reader. Moreover, policy-private DPRFs provide stronger
protection for the tag IDs against the readers.
Batch queries in searchable symmetric encryption.
Searchable symmetric encryption (SSE) (e.g., [11, 24]) en-
ables processing queries directly on ciphertexts generated
with symmetric encryption. Although SSE corresponds to a
general paradigm, various works primarily support the spe-
cial case of keyword queries. Here, we focus on the deﬁni-
tions and schemes of [11] that provide an acceptable level
of provable security. The general framework underlying [11]
is as follows. In an oﬄine stage, a client encrypts his data
with his secret key k, and uploads the ciphertexts c to an
untrusted server. He also creates and sends a secure index I
on the data for eﬃcient keyword search, which is essentially
an encrypted lookup table or inverted index. Given a key-
word w, the client generates a query token τw using k, and
forwards it to the server. It is important to stress that this
“trapdoor” is merely comprised of one or more PRF values
computed on w with k, which were used as keys to encrypt
I. For simplicity and w.l.o.g., we assume that τw is a single
PRF value. The server uses τw on I and retrieves the IDs
of the ciphertexts associated with w. The results c1, . . . , cm
are retrieved and transmitted back to the client, who even-
tually decrypts them with his key. The security goal is to
protect both the data and the keyword from the server.
Suppose that the client wishes to search for a batch of
N keywords w1, . . . , wN . For instance, the client may ask
for documents that contain multiple keywords of his choice
(instead of just a single one). As another example, assume
that the client’s data are employee records, and each record
contains a salary attribute that takes as values intervals of
679
the form [iK, (i + 1)K] (i.e., instead of exact salaries). These
intervals can serve as keywords in SSE search. Suppose that
the client wishes to retrieve records with salaries in a range
of intervals, e.g., [1K, 10K]. Observe that this cannot be pro-
cessed with a single keyword query (no record is associated
with [1K, 10K]). To overcome this while utilizing the SSE
functionality, the client can ask 9 distinct queries with key-
words “[1K, 2K]”, “[2K, 3K]”, . . ., “[9K, 10K]”, which cover
the query range [1K, 10K]. Such scenarios are handled with
“traditional” SSE as shown in Figure 5(a). Given a predi-
cate P that describes the keywords w1, . . . , wN in the batch
query, the client generates N trapdoors τw1 , . . . , τwN using
the standard SSE trapdoor algorithm. These trapdoors are
sent to the server, which then searches I with every τwi fol-
lowing the SSE protocol. Obviously, for large N , the client’s
computational and communication cost is greatly impacted.
(a) “Traditional” SSE.
(b) SSE augmented with DPRFs.
Figure 5: Batch keyword query processing in SSE.
We can augment the discussed SSE framework with DPRF
functionality, in order to support batch queries with sublin-
ear (in N ) processing and communication cost at the client,
while providing provable security along the lines of [11]. Fig-
ure 5(b) illustrates our enhanced SSE architecture. Recall
that τwi is practically a PRF value, computed on wi with
key k. Therefore, instead of computing a PRF value for ev-
ery wi itself, the client delegates the computation of these
PRF values to the server by employing a DPRF scheme
(F, T, C), where F is deﬁned over the domain of the key-
words. Given predicate P and k, the client runs T and
generates trapdoor τ , which is sent to the server. The latter
executes C on τ to produce τw1 , . . . , τwN . Execution then
proceeds in the same manner as in “traditional” SSE. Ob-
serve that, for the special case of ranges, if URC is used as
the DPRF, the computational and communication cost at
the client decreases from O(N ) to O(log(N )). This trans-
formation would work “out of the box” in combination to
any SSE scheme that uses a PRF for creating tokens.
The above framework can be proven secure against adap-
tive adversaries along the lines of [11]. The most important
alteration in the security game and proof is the formulation
of the information leakage of the C algorithm of the DPRF.
In particular, the level of keyword privacy that is provided
by the construction is dictated by the level of policy privacy
that is attained by the underlying DPRF. Speciﬁcally, given
a DPRF with multi-instance policy privacy, it is easy to
show that the same level of keyword privacy as in [11] can be
achieved. Weaker notions of policy privacy (such as single-
instance or union) result in correspondingly weaker notions
of keyword privacy. For instance, recall that union policy
privacy ensures indistinguishability of delegation queries not
intersecting with previously asked queries. Thus, combin-
ing PRF-based SSE with our URC construction will provide
this level of keyword privacy. Given the lower bound argu-
ments for tree-wise constructions we sketched in Section 3,
the privacy loss incurred by this tree-based design is the un-
avoidable cost for the exponential eﬃciency improvement in
client-to-server communication. Eﬃcient constructions at-
taining higher level of policy privacy might be feasible, but
they will have to follow a non tree-base design paradigm.
Broadcast encryption. In a broadcast encryption scheme
(e.g., [14, 31, 32]) a sender wishes to transmit data to a set
of receivers so that at each transmission the set of receivers
excluded from the recipient set can be chosen on the ﬂy
by the sender.
In particular, this means that the sender
has to be able to make an initial key assignment to the
recipients, and then suitably use the key material so that
only the speciﬁc set of users of its choosing can receive the
message.
In such schemes, it was early on observed that
there is a natural tradeoﬀ between receiver memory storage
and ciphertext length (e.g., see lower bounds in [26]). The
intuition behind this is that if the receivers have more keys,
this gives to the sender more ﬂexibility in the way it can
encrypt a message to be transmitted.
In the above sense one can think of the key assignment
step of a broadcast encryption scheme as a PRF deﬁned
over the set Φ which contains all distinct subsets that the
broadcast encryption scheme assigns a distinct key. Given
this conﬁguration, the user u will have to obtain all the keys
corresponding to subsets S ∈ Φ for which it holds that u ∈ S
(we denote those subsets by Su ⊆ Φ). In DPRF language
this would correspond to a delegation policy for a PRF: users
will need to store the trapdoor that enables the evaluation
of any value in the delegated key set Su.
Seen in this way, any DPRF is a key assignment mecha-
nism for a broadcast encryption scheme that saves space on
receiver storage. For example, our constructions for range-
based policies give rise to the following broadcast encryption
scheme: Receivers [n] = {1, . . . , n} are placed in sequence;
each receiver u ∈ [n] is initialized with the trapdoor for a
range [u − t, u + t] for some predetermined parameter t ∈ Z.
In this broadcast encryption scheme the sender can very ef-
ﬁciently enable any range of receivers that is positioned at
distance at most t from a ﬁxed location v ∈ [n]. This is
done with a single ciphertext (encrypted with the key of lo-
cation v). Any receiver of suﬃcient proximity t to location
v can derive the corresponding decryption key from its trap-
door. Furthermore, given the eﬃciency of our construction,
storage on receivers is only logarithmic on t. While the se-
mantics of this scheme are more restricted than a full-ﬂedged
broadcast encryption scheme (which enables the sender to
exclude any subset of users on demand), it succinctly illus-
trates the relation between broadcast encryption and DPRF;
further investigation in the relation between the two primi-
tives from a construction point of view will be motivated by
our notion. Speciﬁcally, an eﬃcient DPRF with domain Φ
over a policy set P = {Su | u ∈ [n]} will provide an eﬃcient
key assignment for a broadcast encryption scheme operating
680
Clientk,Pτw1,...,τwNc1,...,cmServerTrapdoorSearchI,cClientk,Pc1,...,cmServerSearchI,cCTτw1,...,τwNDPRFτover Φ. Interestingly, the reverse is also true and a (suit-
ably structured) broadcast encryption scheme will provide a
DPRF with domain Φ and the policy set {Su | u ∈ [n]}.
Regarding policy privacy, it is interesting to point out
that this security property is yet unstudied in the domain of
broadcast encryption. A diﬀerent privacy notion has been
considered in [3, 13, 25] that deals with the structure of ci-
phertexts in such schemes. Our policy privacy on the other
hand deals with the privacy of memory contents from the
receiver’s point of view. Maintaining the indistinguishabil-
ity of the storage contents is a useful security measure in
broadcast encryption schemes, and our DPRF primitive will
motivate the study of this security property in the context of
broadcast encryption—note that none of the tree-like key-
delegation methods used in broadcast encryption schemes
prior to our work satisﬁes policy privacy.
6. CONCLUSION
We have introduced the concept of delegatable pseudoran-
dom functions (DPRFs), a new cryptographic primitive that
allows for policy-based computation at an untrusted proxy
of PRF values, without knowledge of a secret or even the
input values. We provided formal deﬁnitions of the core
properties of DPRFs for (1) correctness, the ability of the
proxy to compute PRF values only for inputs that satisfy
a given predicate, (2) security, the standard pseudorandom-
ness guarantee, but against a stronger adversary that also
issues delegation queries, and (3) policy privacy, which pre-
vents leakage of the secret preimages of the computed PRF
values. Moreover, we presented two DPRF constructions
for PRF delegation controlled by range-based policies, along
with a comprehensive analysis in terms of their security and
privacy guarantees and some inherent trade-oﬀs with eﬃ-
ciency. Our proposed DPRF schemes are generic, yet practi-
cal, based on the well-understood and widely-adopted GGM
design framework for PRFs and, as we showed, they ﬁnd di-
rect application in many key-delegation or key-derivation
settings providing interesting new results.
Further exploration of DPRFs holds promise for many
directions of interest. Open problems include: Designing
DPRFs for other classes of predicates, establishing upper
and lower bounds on the connection between eﬃciency and
policy privacy, and studying applications in other settings.
Acknowledgments
We thank all anonymous reviewers for providing detailed
comments and suggestions. The ﬁrst and fourth authors
were supported by projects CODAMODA of the European
Research Council, Marie Curie RECUP, and respectively
FINER of GSRT.
7. REFERENCES
[1] M. J. Atallah and K. B. Frikken. Securely outsourcing
linear algebra computations. In Proc. of the 5th
Symposium on Information, Computer and Comm.
Security (ASIACCS), pages 48–59. ACM, 2010.
[2] G. Ateniese, K. Fu, M. Green, and S. Hohenberger.
Improved proxy re-encryption schemes with
applications to secure distributed storage. ACM
Trans. Inf. Syst. Secur., 9(1):1–30, Feb. 2006.
[3] A. Barth, D. Boneh, and B. Waters. Privacy in
encrypted content distribution using private broadcast
encryption. In Proc. of the 10th Int. Conf. on
Financial Cryptography and Data Security, pages
52–64. Springer, 2006.
[4] S. Benabbas, R. Gennaro, and Y. Vahlis. Veriﬁable
delegation of computation over large datasets. In Proc.
of the 31st Annual Conf. on Advances in Cryptology
(CRYPTO), pages 111–131. Springer, 2011.
[5] M. Blaze, G. Bleumer, and M. Strauss. Divertible
protocols and atomic proxy cryptography. In Proc. of
the 17th Int. Conf. on the Theory and Application of
Cryptographic Techniques (EUROCRYPT), pages
127–144. Springer, 1998.
[6] A. Boldyreva, A. Palacio, and B. Warinschi. Secure
proxy signature schemes for delegation of signing
rights. Journal of Cryptology, 25:57–115, 2012.
[7] D. Boneh and B. Waters. Constrained pseudorandom
functions and their applications. In Proc. of the 19th
Int. Conf. on the Theory and Application of
Cryptology and Information Security (ASIACRYPT),
2013. To appear; full version in Cryptology ePrint
Archive, 2013:352.
[8] E. Boyle, S. Goldwasser, and I. Ivan. Functional
signatures and pseudorandom functions. IACR
Cryptology ePrint Archive, 2013:401, 2013.
[9] R. Canetti, B. Riva, and G. N. Rothblum. Practical
delegation of computation using multiple servers. In
Proc. of the 18th Conf. on Computer and Comm.
Security (CCS), pages 445–454. ACM, 2011.
[10] K.-M. Chung, Y. T. Kalai, and S. P. Vadhan.
Improved delegation of computation using fully
homomorphic encryption. In Proc. of the 30th Annual
Conf. on Advances in Cryptology (CRYPTO), pages
483–501. Springer, 2010.
[11] R. Curtmola, J. Garay, S. Kamara, and R. Ostrovsky.
Searchable symmetric encryption: Improved
deﬁnitions and eﬃcient constructions. In Proc. of the
13th Conf. on Computer and Comm. Security (CCS),
pages 79–88. ACM, 2006.
[12] Y. Dodis and A. Yampolskiy. A veriﬁable random
function with short proofs and keys. In Proc. of the
8th Int. Workshop on Public Key Cryptography
(PKC), pages 416–431. Springer, 2005.
[13] N. Fazio and I. M. Perera. Outsider-anonymous
broadcast encryption with sublinear ciphertexts. In
Proc. of the 15th Int. Conf. on Public Key
Cryptography (PKC), pages 225–242. Springer, 2012.
[14] A. Fiat and M. Naor. Broadcast encryption. In Proc.
of the 13st Annual Conf. on Advances in Cryptology
(CRYPTO), pages 480–491. Springer, 1993.
[15] D. Fiore and R. Gennaro. Publicly veriﬁable
delegation of large polynomials and matrix
computations, with applications. In Proc. of the 19th
Conf. on Computer and Comm. Security (CCS), pages
501–512. ACM, 2012.
[16] M. J. Freedman, Y. Ishai, B. Pinkas, and O. Reingold.
Keyword search and oblivious pseudorandom
functions. In Proc. of the 2nd Theory of Cryptography
Conference (TCC), pages 303–324. Springer, 2005.
[17] O. Goldreich, S. Goldwasser, and S. Micali. How to
construct random functions. J. ACM, 33(4):792–807,
1986.
681
[18] S. Goldwasser, Y. T. Kalai, and G. N. Rothblum.
[33] B. Parno, M. Raykova, and V. Vaikuntanathan. How
Delegating computation: interactive proofs for
muggles. In Proc. of the 40th Annual Symposium on
Theory of Computing (STOC), pages 113–122. ACM,
2008.