u
d
e
e
p
S
 8
 7
 6
 5
 4
 3
 2
 1
 5
 10
 0
Fig. 5: Speedup for ofﬂine processing.
Threads
 20
 15
 25
 30
 35
 40
s
r
u
o
h
n
i
e
m
T
i
 9
 8
 7
 6
 5
 4
 3
 2
 1
 0
1
4
20
Threads
40
s
r
u
o
h
n
i
e
m
T
i
 14
 12
 10
 8
 6
 4
 2
 0
1
4
20
Threads
40
(a) Movielens
Fig. 6: Prediction update time in X-REC.
(b) FilmTrust
D. Performance Comparison
Comparison with J-REC. We now compare X-REC with
a state-of-the-art private recommender, proposed by Jeckmans
et al. [24],
leveraging homomorphic encryption to ensure
system-level privacy which we denote as J-REC. To ensure
a fair comparison, we compare X-REC and J-REC using the
synthetic datasets used in [24] to evaluate J-REC. The datasets
consist of 50, 100, or 200 friends where each friend has rated
25 books. The total number of books is either 500, 1,000, or
2,000. Note that, as indicated in J-REC, it is not possible for
50 friends to rate 2,000 books, with only 25 ratings per friend
(denoted with n/a in Table IV). We demonstrate how X-REC
compares, in (end-user) latency, with J-REC when the number
of users or items increases. 18
We ﬁrst compare X-REC with the ofﬂine and online
versions of J-REC. J-REC online version (J-REC On) requires
all users to remain logged-in. The ofﬂine version (J-REC Of f )
of J-REC does not require the users to stay logged-in but
spends slightly more time in protecting the privacy of ofﬂine
(logged-out) users. For the sake of fairness, we ran X-REC on a
single core. Figure 7 compares X-REC with J-REC (J-REC On
and J-REC Of f ) in terms of latency. The results clearly show
that on all datasets, X-REC signiﬁcantly outperforms J-REC.
J-REC requires multiple communication rounds with the users
to compute the similarities and predictions whereas X-REC
requires one single communication round with the TP. Also,
for each user, J-REC uses a vector of all items in the dataset
(items not rated by a user are given a rating of 0) which is
necessary for its encrypted similarity computation. Moreover,
as we see from Table IV, as the number of users and items
increases, the improvement margin also increases.
Books
500
1,000
2,000
Users (J-REC On)
Users (J-REC Of f )
50
200
50
5×
10.4× 5.9×
5.1× 6.85× 10.5×
6×
11×
n/a
n/a
100
6.8×
7.2×
100
200
8.5×
13.4×
8.5×
13.4×
11.1× 15.5×
Comparison with FHE. We evaluate here the overhead of
X-REC over a fully homomorphic encryption scheme. We im-
plemented a non-private version of X-REC using the NX-REC
algorithm, as a baseline for comparison. We then compare the
(end-user) latency achieved by X-REC, a non-private version
of X-REC (NX-REC), and a similar approach relying on a
fully homomorphic encryption (FHE) scheme. We compute
the latency of FHE based on a state-of-art implementation
by K. Rohloff et al. [5]. Figure 9 displays the results of the
comparison. X-REC provides slightly higher latency than a
non-encrypted one 19 and drastically reduces the latency when
compared to a FHE-based one.
E. Dynamicity
New users keep joining the service in a real-world de-
ployment. Hence, the system should be scalable to handle
this dynamicity (user churn). We evaluate the performance of
X-REC with an increasing number of users. We analyze the
speedup of the prediction update time (involves the x-server)
in X-REC with an increasing number of users in the database.
Figure 8 demonstrates the speedup achieved by X-REC on
all three datasets. We observe that the speedup of X-REC
increases with the growing number of users in all the three
datasets. This improvement in scalability is due to the fact
that more computations are performed as the number of the
users increases.
F. Privacy Comparison
In this subsection, we evaluate the security of our imple-
mentation of X-HE. We use four standard attack schemes
to compare the privacy for the encryption schemes in X-
REC and that in J-REC namely: EXHAUSTIVE SEARCH (EX)
[33], MEET-IN-THE-MIDDLE (MITM) [33], BLUM-KALAI-
WASSERMAN scheme (BKW) [34], and BOUNDED DISTANCE
DECODING (BDD) [32].
Successfully running an attack breaks the security of an
encryption scheme with high probability. The bit-level security
denotes the logarithm of the number of operations for a
successful attack. Figure 10(a) compares the bit-level security
of our scheme with the scheme in J-REC against the attacks:
EX, MITM and BKW. We observe that BKW is the best attack
against both X-REC and J-REC. However, X-REC provides
slightly better bit-level security than J-REC against the BKW
attack.
A success probability denotes the probability of distin-
guishing a ciphertext of 0 and a ciphertext of 1. To enable
a fair comparison, we compare X-REC and J-REC on the
−32, as shown
BDD attack with a success probability s = 2
in Figure 10(b). While J-REC reports 275 seconds for the
BDD attack [32] on a 2.3GHz AMD Opteron machine [24],
X-REC estimates 233.04 seconds for the same attack on the
same machine against our X-HE implementation. Although
the BDD attack requires less time for X-REC, a good choice
of security guarantee ensures 40M dollardays as a cost for
attacks following Lenstra’s discussion about the key sizes [37].
Assuming the cost estimate for an AMD Opteron machine as
390$ (price on Amazon), X-REC ensures 39.9M dollardays
against BDD, which is a good choice for security.
TABLE IV: End-user latency improvement over J-REC.
18The datasets are provided by the authors of [24].
19The slightly higher latency is due to the overhead of privacy.
448
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 13:37:11 UTC from IEEE Xplore.  Restrictions apply. 
X-REC
J-RECOn
(a) Dataset with 500 books
J-RECOff
(b) Dataset with 1000 books
l
i
)
e
a
c
s
c
m
h
t
i
r
a
g
o
L
(
s
m
n
i
e
m
T
i
106
105
104
103
102
101
106
105
104
103
102
101
106
105
104
103
102
101
(c) Dataset with 2000 books
100
Users
200
50
100
Users
200
50
Fig. 7: End-user latency comparison with J-REC.
100
Users
200
#users=100
#users=500
#users=943
#users=100
#users=500
#users=1000
#users=1508
#users=100
#users=1000
#users=3000
#users=6040
p
u
d
e
e
p
S
 2.4
 2.2
 2
 1.8
 1.6
 1.4
 1.2
 1
 0
 5
 10
 15
 20
 25
 30
 35
 40
Threads
(a) ML.
NX-REC
X-REC
FHE
(a) Movielens
p
u
d
e
e
p
S
 3
 2.8
 2.6
 2.4
 2.2
 2
 1.8
 1.6
 1.4
 1.2
 1
 0
 5
 10
 15
 20
 25
 30
 35
 40
Threads
(b) FilmTrust.
p
u
d
e
e
p
S
 2.6