值为char *类型。
B)：也很简单，与C）表达式相比，唯一不同的就是函数的返回值类型为char**，是个
二级指针。
A)：fun1 是函数名吗？回忆一下前面讲解数组指针时的情形。我们说数组指针这么定
义或许更清晰：
int (*)[10] p；
再看看A）表达式与这里何其相似！明白了吧。这里fun1 不是什么函数名，而是一个
指针变量，它指向一个函数。这个函数有两个指针类型的参数，函数的返回值也是一个指针。
同样，我们把这个表达式改写一下：char * (*)(char * p1,char * p2) fun1; 这样子
是不是好看一些呢？只可惜编译器不这么想。^_^。
4.7.2 函数挃针的使用
4.7.2.1 函数指针使用的例子
上面我们定义了一个函数指针，但如何来使用它呢？先看如下例子：
#include 
#include 
char * fun(char * p1,char * p2)
{
int i = 0;
i = strcmp(p1,p2);
if (0 == i)
{
return p1;
}
else
{
return p2;
}
}
intmain()
{
char * (*pf)(char * p1,char * p2);
pf = &fun;
(*pf) ("aa","bb");
return 0;
}
我们使用指针的时候，需要通过钥匙（“*”）来取其指向的内存里面的值，函数指针
- 91 -
使用也如此。通过用(*pf)取出存在这个地址上的函数，然后调用它。这里需要注意到是，
在Visual C++6.0 里，给函数指针赋值时，可以用&fun 或直接用函数名fun。这是因为函
数名被编译之后其实就是一个地址，所以这里两种用法没有本质的差别。这个例子很简单，
就不再详细讨论了。
4.2.7.2 *(int*)&p ----这是什么？
也许上面的例子过于简单，我们看看下面的例子：
void Function()
{
printf("Call Function!\n");
}
intmain()
{
void (*p)();
*(int*)&p=(int)Function;
(*p) ();
return 0;
}
这是在干什么？*(int*)&p=(int)Function;表示什么意思？别急，先看这行代码：
void (*p)();
这行代码定义了一个指针变量p，p 指向一个函数，这个函数的参数和返回值都是void。
&p 是求指针变量p 本身的地址，这是一个32 位的二进制常数（32 位系统）。
(int*)&p 表示将地址强制转换成指向int 类型数据的指针。
(int)Function 表示将函数的入口地址强制转换成int 类型的数据。
分析到这里，相信你已经明白*(int*)&p=(int)Function;表示将函数的入口地址赋
值给指针变量p。那么(*p) ();就是表示对函数的调用。
讲解到这里，相信你已经明白了。其实函数指针与普通指针没什么差别，只是指向的内
容不同而已。使用函数指针的好处在于，可以将实现同一功能的多个模块统一起来标识，这
样一来更容易后期的维护，系统结构更加清晰。或者归纳为：便于分层设计、利于系统抽象、
降低耦合度以及使接口与实现分开。
4.7.3 (*(void(*) ())0)()------返是什么？
是不是感觉上面的例子太简单，不够刺激？好，那就来点刺激的，看下面这个例子：
(*(void(*) ())0)();这是《C Traps and Pitfalls》这本经典的书中的一个例子。
没有发狂吧？下面我们就来分析分析：
第一步：void(*) ()，可以明白这是一个函数指针类型。这个函数没有参数，没有返
回值。
第二步：(void(*) ())0，这是将0 强制转换为函数指针类型，0 是一个地址，也就
是说一个函数存在首地址为0 的一段区域内。
第三步：(*(void(*) ())0)，这是取0 地址开始的一段内存里面的内容，其内容就是
保存在首地址为0 的一段区域内的函数。
- 92 -
第四步：(*(void(*) ())0)()，这是函数调用。好像还是很简单是吧，上面的例子再
改写改写：
(*(char**(*) (char **,char **))0) ( char **,char **);
如果没有上面的分析，恐怕不容易把这个表达式看明白吧。不过现在应该是很简单的一
件事了。读者以为呢？
4.7.4 函数挃针数组
现在我们清楚表达式“char * (*pf)(char * p)”定义的是一个函数指针pf。既然
pf 是一个指针，那就可以储存在一个数组里。把上式修改一下：
char * (*pf[3])(char * p);
这是定义一个函数指针数组。它是一个数组，数组名为pf，数组内存储了3 个指向函
数的指针。这些指针指向一些返回值类型为指向字符的指针、参数为一个指向字符的指针的
函数。这念起来似乎有点拗口。不过不要紧，关键是你明白这是一个指针数组，是数组。
函数指针数组怎么使用呢？这里也给出一个非常简单的例子，只要真正掌握了使用方
法，再复杂的问题都可以应对。如下：
#include 
#include 
char * fun1(char * p)
{
printf("%s\n",p);
return p;
}
char * fun2(char * p)
{
printf("%s\n",p);
return p;
}
char * fun3(char * p)
{
printf("%s\n",p);
return p;
}
intmain()
{
char * (*pf[3])(char * p);
pf[0] = fun1; // 可以直接用函数名
pf[1] = &fun2; // 可以用函数名加上取地址符
pf[2] = &fun3;
pf[0]("fun1");
pf[0]("fun2");
pf[0]("fun3");
return 0;
}
- 93 -
4.7.5 函数挃针数组的挃针
看着这个标题没发狂吧？函数指针就够一般初学者折腾了，函数指针数组就更加麻烦，
现在的函数指针数组指针就更难理解了。
其实，没这么复杂。前面详细讨论过数组指针的问题，这里的函数指针数组指针不就是
一个指针嘛。只不过这个指针指向一个数组，这个数组里面存的都是指向函数的指针。仅此
而已。
下面就定义一个简单的函数指针数组指针：
char * (*(*pf)[3])(char * p);
注意，这里的pf 和上一节的pf 就完全是两码事了。上一节的pf 并非指针，而是一个
数组名；这里的pf 确实是实实在在的指针。这个指针指向一个包含了3 个元素的数组；这
个数字里面存的是指向函数的指针；这些指针指向一些返回值类型为指向字符的指针、参数
为一个指向字符的指针的函数。这比上一节的函数指针数组更拗口。其实你不用管这么多，
明白这是一个指针就ok 了。其用法与前面讲的数组指针没有差别。下面列一个简单的例子：
#include 
#include 
char * fun1(char * p)
{
printf("%s\n",p);
return p;
}
char * fun2(char * p)
{
printf("%s\n",p);
return p;
}
char * fun3(char * p)
{
printf("%s\n",p);
return p;
}
intmain()
{
char * (*a[3])(char * p);
char * (*(*pf)[3])(char * p);
pf = &a;
a[0] = fun1;
a[1] = &fun2;
a[2] = &fun3;
pf[0][0]("fun1");
pf[0][1]("fun2");
pf[0][2]("fun3");
return 0;
}
- 94 -
第五章 内存管理
欢迎您进入这片雷区。我欣赏能活着走出这片雷区的高手，但更欣赏“粉身碎骨浑不怕，
不留地雷在人间”的勇者。请您不要把这当作一个扫雷游戏，因为没有人能以游戏的心态取
胜。
曾经很短暂的使用过一段时间的C#。头三天特别不习惯，因为没有指针！后来用起来
越来越顺手，还是因为没有指针！几天的时间很轻易的写了1 万多行C#代码，感觉比用C或
C++简单多了。因为你根本就不用去考虑底层的内存管理，也不用考虑内存泄漏的问题，更
加不怕“野指针”（有的书叫“悬垂指针”）。所有这一切，系统都给你做了，所以可以很
轻松的拿来就用。但是C 或C++，这一切都必须你自己来处理，即使经验丰富的老手也免不
了犯错。我曾经做过一个项目，软件提交给客户很久之后，客户发现一个很严重的bug。这
个bug 很少出现，但是一旦出现就是致命的，系统无法启动！这个问题交给我来解决。由
于要再现这个bug 十分困难，按照客户给定的操作步骤根本无法再现。经过大概2 周时间
天天和客户越洋视频之后，终于找到了bug 的原因——野指针！所以关于内存管理，尤其
是野指针的问题，千万千万不要掉以轻心，否则，你会很惨的。
5.1 什么是野挃针
那到底什么是野指针呢？怎么去理解这个“野”呢？我们先看别的两个关于“野”的词：
野孩子：没人要，没人管的孩子；行为动作不守规矩，调皮捣蛋的孩子。
野狗：没有主人的狗，没有链子锁着的狗，喜欢四处咬人。
对付野孩子的最好办法是给他定一套规矩，好好管教。一旦发现没有按规矩办事就好好
收拾他。对付野狗最好的办法就是拿条狗链锁着它，不让它四处乱跑。
对付野指针恐怕比对付野孩子或野狗更困难。我们需要把对付野孩子和野狗的办法都用
上。既需要规矩，也需要链子。
前面我们把内存比作尺子，很轻松的理解了内存。尺子上的0 毫米处就是内存的0 地
址处，也就是NULL 地址处。这条栓“野指针”的链子就是这个“NULL”。定义指针变量的
同时最好初始化为NULL，用完指针之后也将指针变量的值设置为NULL。也就是说除了在使
用时，别的时间都把指针“栓”到0 地址处。这样它就老实了。
5.2 栈、堆和静态区
对于程序员，一般来说，我们可以简单的理解为内存分为三个部分：静态区，栈，堆。
很多书没有把把堆和栈解释清楚，导致初学者总是分不清楚。其实堆栈就是栈，而不是堆。
堆的英文是heap；栈的英文是stack，也翻译为堆栈。堆和栈都有自己的特性，这里先
不做讨论。再打个比方：一层教学楼，可能有外语教室，允许外语系学生和老师进入；还可
能有数学教师，允许数学系学生和老师进入；还可能有校长办公室，允许校长进入。同样，