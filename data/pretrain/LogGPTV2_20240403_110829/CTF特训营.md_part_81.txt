PUSH
(R3,LR)
BL
LOR
L
HDUS
1.
00H
8.
1.
0,
6.
-0x2000008C
A,DC
CUDE
6001884+521
f98+t81008qns
loc_8001cc
1.
0,
LBR
1
[R1
图27-9固件main函数的位置
由图27-9可以看到，跳转处有一些字符串的操作，判断跳转到的
是main函数，然后进行验证。这里有几个地方十分显眼，那就是以
0x40000000开头的地址和0x20000000开头的地址，从前面的
---
## Page 1018
CTF特训营：技术详解、解题方法与
27.4备存器地址和SRAM地址的处理方法
1018/1144
memorymap中我们了解到，前者是特殊功能寄存器的基地址，而后
者是SRAM的起始地址。接下来再来看看伪代码，如图27-10所示。
uoid _fastcall sub_8001084(int a1)
intv1;//r0@1
int v2;//r0@1
U2-sub_80006A4（u1);
u1=sub_8008A08（a1）;
sub_80007F0(u2);
sub_8000A50(115200);
Sub_8000AA8(0x40013800,
64);
sub_8000560（0x2000000C,0x2000026C);
hile（1）
if（
255551
sub 8008BA4（"Key is：0x08x，0x08x,0x208x,0x208x\r\n"，
026555558
=0;
if（1sub_80007E2（0x40010800,2))
sub_800055C（0x2000008C,0x2000826C);
sub_8000248（0x2000001C,0x2000031C);
sub_8000AA8（0x40013800,64);
0x802x802x802x802>13:008000805
图27-10main函数的伪代码
程序中频繁调用了这些寄存器和内存地址，那么现在问题来了，
既然这些地址都是具有特殊意义的，在程序中也经常被访问，但以这
种格式显示，并不便于我们分析。所以下面，我们将介绍一些处理这
些地址的技巧。
---
## Page 1019
CTF特训营：技术详解、解题方法与
27.4奇存器地址和SRAM地址的处理方法
1019/1144
首先，如果我们要将操作数转为Ofset，那么首先需要添加一个
对应地址段的segment，因为程序在加载时只识别了以ox08000000开
始的segment，所以我们要手动添加以ox40000000开头的segment
添加方法为：[Edit]-[Segments]-[Createsegment...]，这里的设置如图
27-11所示。
LDR
R5,=UX4UU138UU
MOUS
R1,#0x40
Createanewsegment
×
Start address and end address should be valid
End address>Start address
Segment nane
REGS
√
01
Start address
0x40000000
L
C-notation:
EF:S
End address
0x40030000
hex is 0x..
1084+
Base
0x40000000
in paragraphs
Class
√
(class is any text)
16-bit segment
Use sparse storage
32-bit segment
18
OK
Cancel
Help
STRB
R0,[R4]
---
## Page 1020
CTF特训营：技术详解、解题方法与
27.4寄存器地址和SRAM地址的处理方法
1020/1144
图27-11添加segment界面
其中，Endaddress需要尽可能大，涵盖memorymap中所关心的
寄存器地址范围即可，但也不宜过大，否则IDA容易卡。点击OK按钮
之后，segment就加上了。然后，我们将鼠标放在0x40013800这个数
上，按O键，数据就被转换为对应的offset了，如图27-12所示。
seg000:0800108A
BL
sub_80006A4
seg000:0800108E
BL
sub_80007F0
seg000:08001092
HOU.W
R0,#0x1C200
seg000:08001096
BL
sub_8000A50
seq000:0800109A
LDR
R5，-unk 4013880
seg000:0800109c
HOUS
R1,
#0x40
Seg000:0800109E
HOU
R0,R5
seg000:080010A0
BL
sub_800DAA8
seg000:08001004
LDR
R1,=0x2000026C
seg000:080010A6
LDR
RO,
=0x20000000
seg000:080010A8
BL
sub 8000560
seg000: 080010AC
LDR
R4,=0x2000000C
seg000:080010AE
LDR
R6，=0x40010800
seg000:08001080
sans
R4,#0xC
seg000:08001082
Seg000:88001082 10c_80010B2
；C0DE XREF:Sub_8001084+
seg000:08001082
；sub_8001084+861j
seg000:08001082
LDRB
R0,[R4]
seg000:08001084
283
R0,10c_81acC
seg000:08001086
LDR
R1,
00000002x0-
seg000:08001088
LDR
RO,
[R1,#0xC]
seg000:0800108A
STR
RO,
[8aen+sn'ds]
seg000:0800108C
LDR
R3,[R1,#8]
Sseg000:080010BE
LDR
R1,[R1]
R2,[R1,#]
seg000:080010C0
LDR
seg000:080010C2
ADR
R0,aKeyIsBx08xx08;"Keyis:0x
图27-12
2将数据转换为指针的效果
当然，我们还可以更进一步，将unk_40013800改为寄存器的名
字，从memorymap中，我们查到0x40013800地址为USART1的基地
---
## Page 1021
CTF特训营：技术详解、解题方法与
27.4斋存器地址和SRAM地址的处理方法
1021/1144
址，所以这里就将其名字改为USART1，右击rename即可，如图
27-13所示。
Rename address
Address:0x40013800
Hame
USART1|
Maximum length ofnew names
15
Local name prefix
@@
Localname
Include in nameslist
Public name
Autogenerated name
Weak name
10B
Create name anyway
XF
OK
Cancel
Help
LDR
R1,
=0x2000000C
LDR
Rθ,
[R1,#0xC]
no
ren
---
## Page 1022
CTF特训营：技术详解、解题方法与
27.4寄存器地址和SRAM地址的处理方法
1022/1144
图27-13修改地址名字界面
向SRAM的地址0x20000000添加segment的方法与此同理，这里
不再赘述。全部添加完毕后，我们再看一下反编译窗口，如图27-14
所示。
1uoid
fastcall
noreturn sub80e1084(int a1)
2
3
intu1；7/r81
intu2;//r0@1
5
6
U1=Sub_8000A00（a1）;
7
u2-sub_80006A4（u1）;
sub_80007F0（u2);
9
sub_8000A50(115200);
10
Sub_8000AA8（&USART1,64);
11
Sub_8000560（&unk_2000000c,&unk_2000026c);
12
while（1）
13
14
if（unk 20090000）
15
19
20
21
sub_800055c（Gunk_2000000c,&unk_2000026c);
22
sub_8000248（&unk_2000001c,&unk 2000031c);
23
SUb_8000AA8（GUSART1,64);
24
Sub_8000BA4(F14g 15:PCTF<%08x08x%08x208x}\r\n"，unk_2000031C
25
26
27}
图27-14修改地址名字后的效果
更进一步的，我们还可以将连续的存储区域改为数组，以及通过
---
## Page 1023
CTF特训营：技术详解、解题方法与
27.4寄存器地址和SRAM地址的处理方法
1023/1144
一些较为明显的函数可以将其改为猜测的名称，于是程序又变成了如
图27-15所示的样子。
1uoid
fastcall
noreturn sub_8001084(int a1)
2
3
intu1;//r0@1
4
intu2;//r0@1
5
6
U1=Sub_8000A00（a1）;
7
u2=Sub_80006A4（u1）;
8
sub_80007F0（u2);
9
Sub_8000A50（115200);
10
SUb8000AA8（&USART1,64);
11
sub_8000560（du0rd_2000000c,&unk2000026c);
12
while（1）
13
14
if
（unk20000000）
15
16
printf(
17
"Keyis:0x%08x,0x208x,0x%08x,0x%08x\r\n,
18
duord_200000oc[0],
19
duord_2000000c[1],
20
dvord_2880000c[2],
21
duord_200000oc[3]);
22
unk_20000000-0;
23
24
if
（！SUb_80007E2（&GPI0A,2)）
25
26
sub_800055C（dword_2000000C，&unk_2000026c);
27
sub_8000248（&unk_2000001c,dw0rd_2000031c);
28
Sub_8000AA8（&USART1,64）;
29
printf(
30
"F14g
1s:PCTF<%08x08x08x08x}\r\n
31
duord_2000031c[0],
32
duord_2000031c[1],
33
duord_2000031c[2],
34
duord_2000031c[3]);
35
36
37}
---
## Page 1024