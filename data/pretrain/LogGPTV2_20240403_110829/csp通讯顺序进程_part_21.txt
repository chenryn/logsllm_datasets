求如前例一般快速，故至少需要
这个问题的解答可能能实际
i是结合的，故以后在这种进程链中
如
（P>Q）本身也是一个导管，它也可以和别的导管连成链，
输入的，（P>Q）的右通道上输出的消息至是由Q输出的。
屏蔽。它还表示了，（P>Q）的左通道上输入的消息全是由P
其示意图为图4.8中的链状结构。
不被它们的环境所察觉。连接后的结果记作
举例
这个连接图中不标明连接通道的名字，以此表示连接通道的
这种链接进程的合法性显然依赖于字母表的约束条件
QUADRUPLE= DOUBLE>DOUBLE
lefr
(P>Q)>R,
(P>Q) =aleft(P) Uaright(Q)
aright(P) =aleft(Q)
UNPAGK>PACK
《d
(P>O)>(R>S)
图4.8
139
---
## Page 163
缓存用来存储由进程UNPACK形成而尚未被PACK进程消耗的
当读卡机不工作时，叉可连续打印（见4.2节X9）
单的妙法，即插人一个附加的进程。这类模块结构是由设计操作
这种差别会造成很多戚烦。为避开这个问题，这里使用了一个简
X3和X2的描述只有很小的差别，但在传统的顺序程序设计中，
X3同X2，但把连续出现的星号对换为“★”（见4.2节X5）
完全一致，
答案中，在两个进程中都分别包含有循环，和原来问题中的结构
出一-行循环一次。MichaelJackaon称之为结构冲突。上面给出的
为弄不清主循环应该是，每输人一张穿孔卡重复一次，还是每输
注意，
上可缓存一行字符
存。X4答案的另一个版本是，在输人上可缓存一张穿孔卡，输出
的个数。蓝至采用4.2节中X1的COPY进程，这是一个单元的缓
X5无限缓存是无法实现的，为此我们通常限止所缓存的消息
扩充，直到把所有的存储空间用光为止。
法调节。如果读卡机的平均速度总快于打印机，缓存将无限止地
果读卡机的平均速度总慢于打印机，那末缓存几乎总是空的，无
化。但它不可能解决产生和消耗的长时间的速率不匹配问题。如
的输入服务。因之，缓存可用来调节产生和消耗的速率的断续变
字符。当UNPACK进程临时延误工作时，缓存可为PACK进程
X4同X2，但当打印机不工作时，可连续输入穿孔卡；稍后，
系统的人提出和运用的。
用惯用的结构式程序设计的技术，设计这个进程是很困难的，因
140
COPY的前后两个实例的字母表是不同的，这可由它们所
UNPACK>SQUASH>PACK
---
## Page 164
4.4.1法则
它的行为类似于CHAIN2(2.6节X4)和VMS2（1.1.3节X6)。
央的导管是不能直接和环境通信的
法则L5中的算子>换成》R》后，仍然成立：
L5
若两个进程都要和外界通信，那末，哪一个都可能先发生
信，那末，和外部的通信将首先发生，而内部通信将留待以后
若两个进程中的一个想与另一个通信，而另一个却准备与外界通
L2 (right[u→P)>(left?y→Q(y))=P>Q(u)
进程；而且这个通信是被屏蔽的，故有
开始就从左方输入消息，那末消息V就由前面的进程传到后面的
的进程，若一开始就要向右方输出消息，而>右方的进程，“
则提供的符号运算，能用来简化进程的表述。例如，位于》左方
余下的法则是说明，导管中的输入和输出是如何实现的，这些法
L1P>(Q>R)=(P>Q)>R
消息，可定义为
X6:
处的上下文看出。
L.6
L4
(0miyo!)《y(tight1w-=Q)
(right1u-P)>(right1w-→Q)
(left?x-→P(x))>(left?y→Q(y))
链状进程的最有用的代数性质是结合性，即
一个两单元的缓存，在输出第一个消息前至多可接受两个
(0R>(right!w-→Q))
=(teft?x→(P(x)>(rightw→Q))
=left?x-→(P(x)>(left?y→Q(y)))
[rightIw-→((left?x-→P(x))>Q))
COPY>COPY
因为处于链的中
141
---
## Page 165
L8若R是进程链，其中各进程均以从左方输入作为开始，则
L7若R是进程链，其中各进程均以向右方输出作为开始，则
将L6中的类似情况推广到其它法则
X3由X1的最后一行可得
X2 COPY>GOPY
息。上越证明的推理过程和2.3.1节的X1非常类似。
备输出已输入的消息，也准备在输出第一个消息前再输入一个消
上述推导说明，一个两单元的缓存，在输入第一个消息后，既准
2
142
R(y)= (right1y→COPY)
R(y)=(left?x-→rightjx-→COPY)>(right1y-COPY)
R(y) = (righL1y-=COPY)>COPY
让我们定义
举例
((1d00+fi2y51s)R(x)
>(left?x-→right!x-+COPY)
(left?x-→P(x))>R=left?x→(P(x)>R)
[right{y-→left?x-→R(x))
(0COPY))
=left?x→R(x)
=left?x-→((right{x-→COPY)>COPY)
COPY的定义
R（x）的定义
X2
5
5
口
口
---
## Page 166
至于输入和输出操作的实施，则参见4.2.1节。
（3）或者，环境愿在右通道上通信，则由Q处理。
（2）不然，如果环境欲在左通道上通信，则由P处理。
（1）若在内部连接通道上可发生通信，则不理睬外部环境，随即
4.4.2实施
用于彼此通信，从而使（P》Q）永不和外部世界通信。这类发
是，链算子可能导致另外一种危险。即进程P和Q 将所有的时间
进程P和Q都不终止，则进程（P》Q）亦不会停止。可惜的
4.4.3
chain(P,Q) =
else Ax. if x="right
链算子用一条通道连接两个进程：因此不会导致死锁。如果
then chain(cdr(P("right)), Q("left)(car(P("right))))
实现内部通信。如果出现内部通信的无穷序列，则该进程发
在实施（P》Q）时，要区分三种情形
散（参见3.5.2节）。
活锁
else if x="le}t
else cons (oar(Q("right)),
else "BLEEP
else Ay.chain (P("left)(y),Q)
chain(P,cdr(Q("rioht))))
情形（2)
情形（3）
情形(1)