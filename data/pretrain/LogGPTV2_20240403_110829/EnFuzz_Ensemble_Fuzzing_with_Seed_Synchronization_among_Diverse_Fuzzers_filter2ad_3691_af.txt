diversity =
1
n
n
∑
i=1
(
2
− mean)
Take the diversity of AFLFast, FairFuzz, Radamsa, QSYM,
and libFuzzer for example, as shown in the statistics presented
in Table 14 of the appendix, compared with AFL on different
applications, the diversity of AFLFast is 0.040; the diversity
of FairFuzz is 0.062; the diversity of Radamsa is 0.197; the
diversity of QSYM is 0.271; the diversity of libFuzzer is
11.929. In the same way, the deviation on branches covered
and the bugs detected can be calculated. We can add these
three values together with different weight for the ﬁnal di-
versity quantiﬁcation. For example, the bug deviation should
be assigned with more weights, because from prior research,
coverage metrics (the number of paths or branches) are not
necessarily correlated well with bugs found. A more advanced
way to evaluate the amount of diversity would be to count
how many paths/branches/bugs were found by one fuzzer and
not by any of the others.
The second potential threat is the mechanism scalability
of the ensemble architecture. Section 4.2 describes the en-
semble architecture design, and proposes the globally asyn-
chronous and locally synchronous based seed synchronization
mechanism. The seed synchronization mechanism focuses
on enhancing cooperation among these base fuzzers during
their fuzzing processes. With the help of seeds sharing, the
performance of ensemble fuzzing is much improved and is
better than any of the constituent base fuzzers with the same
computing resources usage. However, this mechanism can
still be improved for better scalability on different applica-
tions and fuzzing tasks. EnFuzz only synchronizes the coarse-
grained information – interesting seeds, rather than the ﬁne-
grained information. For example, we could synchronize the
execution trace and array index values of each base fuzzer
to improve their effectiveness in cooperation. Furthermore,
we currently select and mix base fuzzers manually accord-
ing to three heuristics. When scaled to arbitrary number of
cores, it should be carefully investigated with huge number
of empirical evaluations. A possible solution is that the base
fuzzers will be dynamically selected and initiated with dif-
ferent number of cores according to the real-time number of
paths/branches/bugs found individually by each fuzzer. In
the beginning, we have a set of different base fuzzers; then
Enfuzz selects n (this number can be conﬁgured) base fuzzers
randomly. If one fuzzer cannot contribute to coverage for a
long time, then it will be terminated, and one new base fuzzer
from the sets will be setup for fuzzing or the existing live base
fuzzer with better coverage will be allocated with more cores.
We can also apply some effective ensemble mechanisms in
ensemble learning such as Boosting to ensemble fuzzing to
improve the scalability. Boosting is a widely used ensemble
mechanism which will reweigh the base learner dynamically
to improve the performance of the ensemble learner: exam-
ples that are misclassiﬁed gain weight and examples that are
classiﬁed correctly lose weight. To implement this idea in
ensemble fuzzing, we could start up a master thread to moni-
tor the execution statuses of all base fuzzers and record more
precise information of each base fuzzer, then reassign each
base fuzzer some interesting seeds accordingly.
For the number of base fuzzers and parameters in ensemble
fuzzing implementation, it is scalable for integration of most
fuzzers. Theoretically, the more base fuzzers with diversity,
the better ensemble fuzzing performs. We only use four base
fuzzers in our evaluation with four CPU cores. The more
computing resources we get, higher performance the fuzzing
practice acquires. Furthermore, in our implementation, we
have tried different values of period time, and the results are
very sensitive to the speciﬁc setting of this value. It only
affects the performance in the beginning, but affects little in
the end. Furthermore, refering to the GALS system design,
we can also allocate a different synchronization frequency for
each local fuzzer dynamically.
7 Conclusion
In this paper, we systematically investigate the practical en-
semble fuzzing strategies and the effectiveness of ensemble
fuzzing of various fuzzers. Applying the idea of ensemble
fuzzing, we bridge two gaps. First, we come up with a method
for deﬁning the diversity of base fuzzers and propose a way of
selecting a diverse set of base fuzzers. Then, inspired by AFL
in parallel mode, we implement a concrete ensemble archi-
tecture with one effective ensemble mechanism, a seed syn-
chronization mechanism. EnFuzz always outperforms other
popular base fuzzers in terms of unique bugs, path and branch
coverage with the same resource usage. EnFuzz has found 60
new bugs in several well-fuzzed projects and 44 new CVEs
were assigned. Our ensemble architecture can be easily uti-
lized to integrate other base fuzzers for industrial practice.
Our future work will focus on three directions: the ﬁrst
is to try some other heuristics and more accurate accumu-
lated quantiﬁcation of diversity in base fuzzers; the second
is to improve the ensemble architecture with more advanced
en- semble mechanism and synchronize more ﬁne-grained
information; the last is to improve the ensemble architecture
with intelligent resource allocation such as dynamically ad-
justing the synchronization period for each base fuzzer, and
allocating more CPU cores to the base fuzzer that shares more
interesting seeds.
Acknowledgments
We thank the anonymous reviewers, and our shepherd
Thorsten Holz, for their helpful feedback and the support
from Huawei. Yu Jiang is the correspondence author.
USENIX Association
28th USENIX Security Symposium    1979
References
[1] Fuzzer
automation with
spike.
//resources.infosecinstitute.com/
fuzzer-automation-with-spike/.
accessed 12-February-2018].
[2] Cert bff
- basic fuzzing framework.
//vuls.cert.org/confluence/display/tools/
CERT+BFF+-+Basic+Fuzzing+Framework,
[Online; accessed 10-April-2018].
2012.
http:
[Online;
https:
[3] Aﬂ in parallel mode.
https://github.com/
mcarpenter/afl/blob/master/docs/parallel_
fuzzing.txt, 2016. [Online; accessed 10-April-2019].
[4] Continuous
fuzzing for open
source
software.
https://opensource.googleblog.com/2016/
12/announcing-oss-fuzz-continuous-fuzzing.
html, 2016. [Online; accessed 10-April-2018].
[5] Google. honggfuzz. https://google.github.io/
honggfuzz/, 2016. [Online; accessed 10-April-2018].
[6] libfuzzer in parallel mode.
https://github.
com/google/fuzzer-test-suite/blob/master/
tutorial/libFuzzerTutorial.md, 2016.
accessed 10-April-2019].
[Online;
[7] Technical details for aﬂ. http://lcamtuf.coredump.
cx/afl/technical_details.txt, 2016. [Online; ac-
cessed 10-April-2019].
[8] fuzzer-test-suite.
fuzzer-test-suite, 2017.
April-2018].
https://github.com/google/
[Online; accessed 10-
[9] Google
security
blog.
security.googleblog.com/2017/05/
oss-fuzz-five-months-later-and.html,
[Online; accessed 10-April-2018].
https://
2017.
[10] libfuzzer.
https://llvm.org/docs/LibFuzzer.
html, 2017. [Online; accessed 10-April-2018].
[11] Sanitizercoverage in llvm.
https://clang.llvm.
org/docs/SanitizerCoverage.html, 2017. [Online;
accessed 10-April-2018].
[12] Clusterfuzz
document.
https://github.
com/google/oss-fuzz/blob/master/docs/
clusterfuzz.md, 2018.
November-2018].
[Online;
accessed 2-
[13] Clusterfuzz
integration
document.
https:
//chromium.googlesource.com/chromium/src/
testing/libfuzzer/+/HEAD/clusterfuzz.md,
2018. [Online; accessed 2-November-2018].
[14] BENJAMIN, J. R., AND CORNELL, C. A. Probabil-
ity, statistics, and decision for civil engineers. Courier
Corporation, 2014.
[15] BÖHME, M., PHAM, V.-T., NGUYEN, M.-D., AND
ROYCHOUDHURY, A. Directed greybox fuzzing. In Pro-
ceedings of the 2017 ACM SIGSAC Conference on Com-
puter and Communications Security (CCS17) (2017).
[16] BÖHME, M., PHAM, V.-T., AND ROYCHOUDHURY, A.
Coverage-based greybox fuzzing as markov chain. In
Proceedings of the 2016 ACM SIGSAC Conference on
Computer and Communications Security (2016), ACM,
pp. 1032–1043.
[17] CHA, S. K., WOO, M., AND BRUMLEY, D. Program-
adaptive mutational fuzzing. In Security and Privacy
(SP), 2015 IEEE Symposium on (2015), IEEE, pp. 725–
741.
[18] CHEN, P., AND CHEN, H. Angora: Efﬁcient fuzzing
by principled search. arXiv preprint arXiv:1803.01307
(2018).
[19] DOLAN-GAVITT, B., HULIN, P., KIRDA, E., LEEK, T.,
MAMBRETTI, A., ROBERTSON, W., ULRICH, F., AND
WHELAN, R. Lava: Large-scale automated vulnerability
In Security and Privacy (SP), 2016 IEEE
addition.
Symposium on (2016), IEEE, pp. 110–121.
[20] EDDINGTON, M. Peach fuzzing platform. Peach Fuzzer
(2011), 34.
[21] GODEFROID, P., KIEZUN, A., AND LEVIN, M. Y.
In ACM Sigplan
Grammar-based whitebox fuzzing.
Notices (2008), vol. 43, ACM, pp. 206–215.
[22] HELIN, A. Radamsa. https://gitlab.com/akihe/
radamsa, 2016.
[23] HOCEVAR, S. zzuf - multi-purpose fuzzer. http://
caca.zoy.org/wiki/zzuf, 2007. [Online; accessed
10-April-2018].
[24] HOLLER, C., HERZIG, K., AND ZELLER, A. Fuzzing
with code fragments. In USENIX Security Symposium
(2012), pp. 445–458.
[25] KLEES, G., RUEF, A., COOPER, B., WEI, S., AND
HICKS, M. Evaluating fuzz testing. In Proceedings of
the 2018 ACM SIGSAC Conference on Computer and
Communications Security (2018), ACM, pp. 2123–2138.
[26] LEMIEUX, C., AND SEN, K. Fairfuzz: Targeting rare
branches to rapidly increase greybox fuzz testing cover-
age. arXiv preprint arXiv:1709.07101 (2017).
[27] LIANG, J., JIANG, Y., CHEN, Y., WANG, M., ZHOU,
C., AND SUN, J. Paﬂ: extend fuzzing optimizations
of single mode to industrial parallel mode. In Proceed-
ings of the 2018 26th ACM Joint Meeting on European
Software Engineering Conference and Symposium on
the Foundations of Software Engineering (2018), ACM,
pp. 809–814.
1980    28th USENIX Security Symposium
USENIX Association
[28] LIANG, J., WANG, M., CHEN, Y., JIANG, Y., AND
ZHANG, R. Fuzz testing in practice: Obstacles and
In 2018 IEEE 25th International Confer-
solutions.
ence on Software Analysis, Evolution and Reengineering
(SANER) (2018), IEEE, pp. 562–566.
[29] OGNAWALA, S., HUTZELMANN, T., PSALLIDA, E.,
AND PRETSCHNER, A. Improving function coverage
with munch: a hybrid fuzzing and directed symbolic
execution approach. In Proceedings of the 33rd Annual
ACM Symposium on Applied Computing (2018), ACM,
pp. 1475–1482.
[30] PETSIOS, T., ZHAO, J., KEROMYTIS, A. D., AND
JANA, S. Slowfuzz: Automated domain-independent
detection of algorithmic complexity vulnerabilities. In
Proceedings of the 2017 ACM SIGSAC Conference on
Computer and Communications Security (2017), ACM,
pp. 2155–2168.
[31] SIRER, E. G., AND BERSHAD, B. N. Using produc-
tion grammars in software testing. In ACM SIGPLAN
Notices (1999), vol. 35, ACM, pp. 1–13.
[32] STEPHENS, N., GROSEN, J., SALLS, C., DUTCHER,
A., WANG, R., CORBETTA, J., SHOSHITAISHVILI, Y.,
KRUEGEL, C., AND VIGNA, G. Driller: Augmenting
fuzzing through selective symbolic execution. In NDSS
(2016), vol. 16, pp. 1–16.
[33] VEGGALAM, S., RAWAT, S., HALLER, I., AND BOS, H.
Ifuzzer: An evolutionary interpreter fuzzer using genetic
programming. In European Symposium on Research in
Computer Security (2016), Springer, pp. 581–601.
[34] WANG, J., CHEN, B., WEI, L., AND LIU, Y. Skyﬁre:
Data-driven seed generation for fuzzing, 2017.
[35] WANG, M., LIANG, J., CHEN, Y., JIANG, Y., JIAO, X.,
LIU, H., ZHAO, X., AND SUN, J. Saﬂ: increasing and
accelerating testing coverage with symbolic execution
and guided fuzzing. In Proceedings of the 40th Interna-
tional Conference on Software Engineering: Companion
Proceeedings (2018), ACM, pp. 61–64.
[36] XU, W., KASHYAP, S., MIN, C., AND KIM, T. De-
signing new operating primitives to improve fuzzing
performance. In Proceedings of the 2017 ACM SIGSAC
Conference on Computer and Communications Security
(2017), ACM, pp. 2313–2328.
[37] YANG, X., CHEN, Y., EIDE, E., AND REGEHR, J. Find-
ing and understanding bugs in c compilers. In ACM
SIGPLAN Notices (2011), vol. 46, ACM, pp. 283–294.
[38] YUN, I., LEE, S., XU, M., JANG, Y., AND KIM, T.
{QSYM}: A practical concolic execution engine tai-
lored for hybrid fuzzing. In 27th {USENIX} Security
Symposium ({USENIX} Security 18) (2018), pp. 745–
761.
[39] ZALEWSKI, M. American fuzzy lop. https://github.
com/mcarpenter/afl, 2015.
A Preliminary demonstration of diversity
among base fuzzers
To help select base fuzzers with larger diversity, we need to
estimate the diversity between each base fuzzer. In general,
the more differently they perform on different applications,
the more diversity among these base fuzzers. Accordingly,
we ﬁrst run each base fuzzer in single mode, with one CPU
core on Google’s fuzzer-test-suite for 24 hours. Table 14 and
Table 15 show the number of paths and branches covered
by AFL, AFLFast, FairFuzz, libFuzzer, Radamsa and QSYM.
Table 16 shows the corresponding number of unique bugs. Be-
low we present the performance effects of the three diversity
heuristics proposed in Section 4.1 in detail.
1) Effects of seed mutation and seed selection strategy –
what kind of mutation and selection strategy you use, what
kind of path and branch you would cover The ﬁrst three
columns of Table 14 show the performance of the AFL fam-
ily tools. Their differences are the seed mutation and seed
selection strategies. The original AFL performs the best on 5
applications, but performs the worst on other 10 applications.
AFLFast performs the best on 13 applications, and only per-
forms the worst on 4 applications. FairFuzz also performs the
best on 8 applications, but the worst on the other 9 applica-
tions. Although the total number of paths covered improves
slightly, the performance variation on each application is huge,
ranging from -57% to 38% in single cases.
From the ﬁrst three columns in Table 15 and Table 16, we
get the same observation that the performance of these opti-
mized fuzzers varies signiﬁcantly on different applications.
Although the total number of covered branches and unique
crashes improves slightly, the deviation of each application
is huge. AFLFast selects seeds that exercise low-frequency
paths to mutate more times. Take project lcms for exam-
ple, this seed selection strategy exercises more new paths by
avoiding covering “hot paths” too many times, but on project
libarchive, its “hot path” may be the key to further paths. Fair-
Fuzz mutates seeds to hit rare branches. Take project libxml2
for example, the rare branch fuzzing strategy guides FairFuzz
into deeper areas and covers more branches. However, on
libarchive, this strategy fails. FairFuzz spends much time in
deep paths and branches, ignoring breadth search. Unlike
libxml2, the breadth ﬁrst search strategy of other fuzzers is
more effective on libarchive. In general, the mutation and
selection strategy decides the depth and breath of the covered
branch and path.
2) Effects of coverage information granularity–what kind of
guided information you use, what kind of coverage metric you
improve. The diversity between AFL and libFuzzer is their
coverage information granularity. According to the fourth col-
umn of Table 14, we ﬁnd that compared with AFL, libFuzzer
performs better on 17 applications, and covers 30.3% more
paths in total. However, according to the fourth column of
the Table 15, compared with AFL, libFuzzer only performs
better on 11 applications, which means on 6 applications, lib-
Fuzzer covers more paths but less branches. For total branch
count, AFL covers 7.3% more than libFuzzer. The reason
is that AFL mutates seed by tracking edge hit counts while
libFuzzer utilizes the SanitizerCoverage instrumentation to
track block hit counts. AFL prefers to cover more branches
USENIX Association
28th USENIX Security Symposium    1981
while libFuzzer is better at executing more paths. In general,
edge-guided means more branches covered, and block-guided
means more paths covered.
Table 14: Average number of paths for single mode.
Project
boringssl
c-ares
guetzli
lcms
libarchive
libssh
libxml2
openssl-1.0.1
openssl-1.0.2
openssl-1.1.0
pcre2
proj4
re2
woff2
freetype2
harfbuzz
json
libjpeg
libpng
llvm
openthread
sqlite
vorbis
wpantund
Total
AFL AFLFast FairFuzz libFuzzer Radamsa QSYM
1207
1334
72
80
1268
1382
605
656
3756
3505
87
64
5098
5762
2397
2330
1947
2456
2439
2416
32310
24501
208
220
5084
5860
15
14
7748
7188
6793
6881
504
466
638
704
577
170
4096
4830
104
141
179
180
891
898
2975
2959
83575
72422
3528
1682
123
78
1773
1562
338
550
10124
4570
201
63
19663
9392
1709
2303
1881
2108
1897
2311
37850
20981
334
182
6327
5418
224
10
16360
9825
10800
5688
564
499
448
634
493
263
4593
5646
976
144
431
256
848
875
3510
3146
108884 94296
1760
88
1030
434
1630
62
8028
2285
2040
2501
36176
218
5016
12
10714
8668
408
722
76
5360
127
172