ℎ
ℎ
)⦄𝑘0
𝑗
𝑗
𝑗
𝑗
)⦄𝑘0
)⦄𝑘1
)⦄𝑘0
)⦄𝑘1
⦄𝑘0
⦄𝑘0
)⦄𝑘1
)⦄𝑘0
⦄𝑘1
)⦄𝑘1
,
,
𝑗
𝑗
𝑗
𝑖
𝑖
𝑖
𝑗
𝑖
⦄𝑘0
⦄𝑘0
⦄𝑘1
⦄𝑘1
𝑖
𝑖
𝑖
,
),
,
))
),
⦄𝑘1
𝑖
ℎ
≡ 𝜋[𝐵𝑖](𝜋[𝐵𝑗](⦃⦃(𝖡⊕𝜇(𝑧𝑖,𝑧𝑗)
⦃⦃(𝖡⊕𝜇(𝑧𝑖,1−𝑧𝑗)
𝜋[𝐵𝑗](⦃⦃(𝖡⊕𝜇(1−𝑧𝑖,𝑧𝑗)
⦃⦃(𝖡⊕𝜇(1−𝑧𝑖,1−𝑧𝑗)
ℎ
ℎ
ℎ
ℎ
ℎ
, 𝖪⊕𝜇(𝑧𝑖,𝑧𝑗)
, 𝖪⊕𝜇(𝑧𝑖,1−𝑧𝑗)
, 𝖪⊕𝜇(1−𝑧𝑖,𝑧𝑗)
ℎ
ℎ
, 𝖪⊕𝜇(1−𝑧𝑖,1−𝑧𝑗)
ℎ
𝑖
𝑖
𝑖
ℎ
, 𝑘1
, 𝖪𝑧ℎ
𝑧𝑗
, 𝑘
𝑗
⊕𝑧𝑗
, 𝑏
𝑗
, 𝖪1−𝑧ℎ
∉ 𝑆, and 𝑏⊕𝑧𝑖
where 𝜇(𝑑𝑖, 𝑑𝑗) = (𝑑𝑖 ↑ 𝑑𝑗) ⊕ 𝑧ℎ for 𝑑𝑖, 𝑑𝑗 ∈ {0, 1}. In par-
ticular, 𝜇(𝑧𝑖, 𝑧𝑗) = 0. By Condition 1, 𝑘𝑧𝑖
ℎ ∈ 𝑆,
1−𝑧𝑗
𝑘1−𝑧𝑖
∈ 𝐏𝐚𝐫𝐭𝐬(𝐩(𝑒, 𝑆)).
, 𝑘
𝑖
𝑗
So 𝑘0
, 𝑘0
𝑗 ∈ 𝛼(𝑆), 𝑘1
𝑗 ∉ 𝛼(𝑆), and the pattern
𝛼(𝐩( ̃𝐶′, 𝑆)) = 𝐩(𝛼( ̃𝐶′), 𝛼(𝑆)) is equivalent to
⦄𝑘0
,⦃⦃⦇𝔹, 𝕂⦈⦄𝑘1
𝜋[𝐵𝑖](𝜋[𝐵𝑗](⦃⦃(𝖡ℎ, 𝖪0
ℎ)⦄𝑘0
𝜋[𝐵𝑗](⦃⦃⦇𝔹, 𝕂⦈⦄⦄𝑘1
,⦃⦃⦇𝔹, 𝕂⦈⦄⦄𝑘1
, 𝑘0
𝑗
ℎ ∉ 𝑇 . So the pattern 𝐩( ̂𝐶′, 𝑆) of
On the other hand, by Lemma 8, 𝑘0
𝑘1
𝑖
))
ℎ ∈ 𝑇 and
, 𝖪0
̂𝐶′ is
⦄𝑘0
, 𝑘1
𝑗
, 𝖪1
),
𝑖
𝑖
𝑗
𝑗
𝑖
𝑖
𝑖
𝑖
𝜋[𝐵𝑖](𝜋[𝐵𝑗](⦃⦃(𝖡ℎ, 𝖪0
ℎ)⦄𝑘0
⦄𝑘0
,⦃⦃⦇𝔹, 𝕂⦈⦄𝑘1
),⦃⦃⦇𝔹, 𝕂⦈⦄⦄𝑘1
𝜋[𝐵𝑗](⦃⦃⦇𝔹, 𝕂⦈⦄⦄𝑘1
𝑗
𝑗
𝑖
⦄𝑘0
𝑖
,
))
𝑗
𝑗
Thus 𝐩( ̃𝐶′, 𝑆) ≈𝛼 𝐩( ̂𝐶′, 𝑇 ).
0 and 𝐶′
0) and 𝐶′ = 𝐶′
0
circuits 𝐶′
also holds for the cases 𝐶′ = 𝐅𝐢𝐫𝐬𝐭(𝐶′
Therefore our claim follows.
For the induction step, assuming the claim holds for sub-
1 of 𝐶, it is easy to check that the claim
⋙ 𝐶′
1.
For the second part, let 𝑦 = 𝐶(𝑥). Then for any 𝑖 ∈ [𝑚], 𝑦𝑖
is the actual value of the corresponding output wire. Since ̃𝑥 =
((𝖪𝑥1
1
), (𝑏1, … , 𝑏𝑚)), we can calculate
𝑛, 𝖡𝑛), (𝑏⊕𝑦𝑖
So ̃𝑥 ≈𝛼 ̂𝑥, and thus 𝐩( ̃𝑥, 𝑆) ≈𝛼 𝐩( ̂𝑥, 𝑇 ).
, 𝖡1), … , (𝖪0
𝛼( ̃𝑥) = ((𝖪0
1
), … , (𝖪𝑥𝑛
, … , 𝑏⊕𝑦𝑚
𝑚 )) = ̂𝑥.
𝑛 , 𝖡⊕𝑥𝑛
, 𝖡⊕𝑥1
1
1
𝑛
Therefore the theorem holds.
As a corollary of Theorem 3 and 5, we can now conclude
that our garbled circuit scheme is computationally secure.
Corollary 1. For any circuit 𝐶 ∈ Circuit(𝑠, 𝑡) and any
𝑥 ∈ {0, 1}𝑛 where 𝑠 is a shape of 𝑛 wires, the probability
distributions (cid:2)𝙶𝚊𝚛𝚋𝚕𝚎(𝐶, 𝑥)(cid:3) and (cid:2)𝚂𝚒𝚖𝚞𝚕𝚊𝚝𝚎(𝐶, 𝐶(𝑥))(cid:3) are
computationally indistinguishable.
VI. IMPLEMENTATION AND AUTOMATED TESTS
As a proof of concept, we have implemented our symbolic
framework as well as the garbling scheme and the simulator in
Haskell. The source code can be found at https://github.com/
b5li/SymGC. Our symbolic framework implementation closely
follows the deﬁnitions in Section II-A. In addition, we added
a normalization operation norm on patterns, for example:
𝚗𝚘𝚛𝚖 (𝙽𝚘𝚝 (𝙱𝚒𝚝 𝙵𝚊𝚕𝚜𝚎)) = 𝙱𝚒𝚝 𝚃𝚛𝚞𝚎
𝚗𝚘𝚛𝚖 (𝙽𝚘𝚝 (𝙱𝚒𝚝 𝚃𝚛𝚞𝚎)) = 𝙱𝚒𝚝 𝙵𝚊𝚕𝚜𝚎
𝚗𝚘𝚛𝚖 (𝙽𝚘𝚝 (𝙽𝚘𝚝 𝑒)) = 𝚗𝚘𝚛𝚖 𝑒
𝚗𝚘𝚛𝚖 (𝙿𝚎𝚛𝚖 (𝙱𝚒𝚝 𝙵𝚊𝚕𝚜𝚎) 𝑝 𝑞) = 𝙿𝚊𝚒𝚛 (𝚗𝚘𝚛𝚖 𝑞) (𝚗𝚘𝚛𝚖 𝑝)
𝚗𝚘𝚛𝚖 (𝙿𝚎𝚛𝚖 (𝙱𝚒𝚝 𝚃𝚛𝚞𝚎) 𝑝 𝑞) = 𝙿𝚊𝚒𝚛 (𝚗𝚘𝚛𝚖 𝑝) (𝚗𝚘𝚛𝚖 𝑞)
𝚗𝚘𝚛𝚖 (𝙿𝚎𝚛𝚖 (𝙽𝚘𝚝 𝑏) 𝑝 𝑞) = 𝚗𝚘𝚛𝚖 (𝙿𝚎𝚛𝚖 𝑏 𝑞 𝑝)
)),
The equivalence relation ≡ on patterns, deﬁned in Sec-
tion II-A, is checked using syntactic equality on normalized
patterns. Random bit renaming and pseudo-random key re-
naming are implemented using maps on normalized bit and
key patterns. Thus we can check equivalence up to renaming
by ﬁrst applying renaming maps to normalized patterns and
then checking for equivalence.
To build symbolic expressions of the real and the simulated
garbled circuits, the pseudo-code deﬁnitions of the garbling
scheme and the simulator in Sections IV and V were directly
translated into Haskell code. The bit and key renamings 𝛼𝐵 and
𝛼𝐾 were constructed recursively as in the proof of Lemma 5.
So far, given a circuit and a boolean vector of an appropriate
shape, our programs are able to produce symbolic expressions
of the real and the simulated garbled circuits, compute their
patterns, and check if these patterns are equivalent up to
renaming. The whole implementation consists of about 500
158
VII. CONCLUSION