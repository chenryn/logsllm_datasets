â„
â„
)â¦„ğ‘˜0
ğ‘—
ğ‘—
ğ‘—
ğ‘—
)â¦„ğ‘˜0
)â¦„ğ‘˜1
)â¦„ğ‘˜0
)â¦„ğ‘˜1
â¦„ğ‘˜0
â¦„ğ‘˜0
)â¦„ğ‘˜1
)â¦„ğ‘˜0
â¦„ğ‘˜1
)â¦„ğ‘˜1
,
,
ğ‘—
ğ‘—
ğ‘—
ğ‘–
ğ‘–
ğ‘–
ğ‘—
ğ‘–
â¦„ğ‘˜0
â¦„ğ‘˜0
â¦„ğ‘˜1
â¦„ğ‘˜1
ğ‘–
ğ‘–
ğ‘–
,
),
,
))
),
â¦„ğ‘˜1
ğ‘–
â„
â‰¡ ğœ‹[ğµğ‘–](ğœ‹[ğµğ‘—](â¦ƒâ¦ƒ(ğ–¡âŠ•ğœ‡(ğ‘§ğ‘–,ğ‘§ğ‘—)
â¦ƒâ¦ƒ(ğ–¡âŠ•ğœ‡(ğ‘§ğ‘–,1âˆ’ğ‘§ğ‘—)
ğœ‹[ğµğ‘—](â¦ƒâ¦ƒ(ğ–¡âŠ•ğœ‡(1âˆ’ğ‘§ğ‘–,ğ‘§ğ‘—)
â¦ƒâ¦ƒ(ğ–¡âŠ•ğœ‡(1âˆ’ğ‘§ğ‘–,1âˆ’ğ‘§ğ‘—)
â„
â„
â„
â„
â„
, ğ–ªâŠ•ğœ‡(ğ‘§ğ‘–,ğ‘§ğ‘—)
, ğ–ªâŠ•ğœ‡(ğ‘§ğ‘–,1âˆ’ğ‘§ğ‘—)
, ğ–ªâŠ•ğœ‡(1âˆ’ğ‘§ğ‘–,ğ‘§ğ‘—)
â„
â„
, ğ–ªâŠ•ğœ‡(1âˆ’ğ‘§ğ‘–,1âˆ’ğ‘§ğ‘—)
â„
ğ‘–
ğ‘–
ğ‘–
â„
, ğ‘˜1
, ğ–ªğ‘§â„
ğ‘§ğ‘—
, ğ‘˜
ğ‘—
âŠ•ğ‘§ğ‘—
, ğ‘
ğ‘—
, ğ–ª1âˆ’ğ‘§â„
âˆ‰ ğ‘†, and ğ‘âŠ•ğ‘§ğ‘–
where ğœ‡(ğ‘‘ğ‘–, ğ‘‘ğ‘—) = (ğ‘‘ğ‘– â†‘ ğ‘‘ğ‘—) âŠ• ğ‘§â„ for ğ‘‘ğ‘–, ğ‘‘ğ‘— âˆˆ {0, 1}. In par-
ticular, ğœ‡(ğ‘§ğ‘–, ğ‘§ğ‘—) = 0. By Condition 1, ğ‘˜ğ‘§ğ‘–
â„ âˆˆ ğ‘†,
1âˆ’ğ‘§ğ‘—
ğ‘˜1âˆ’ğ‘§ğ‘–
âˆˆ ğğšğ«ğ­ğ¬(ğ©(ğ‘’, ğ‘†)).
, ğ‘˜
ğ‘–
ğ‘—
So ğ‘˜0
, ğ‘˜0
ğ‘— âˆˆ ğ›¼(ğ‘†), ğ‘˜1
ğ‘— âˆ‰ ğ›¼(ğ‘†), and the pattern
ğ›¼(ğ©( Ìƒğ¶â€², ğ‘†)) = ğ©(ğ›¼( Ìƒğ¶â€²), ğ›¼(ğ‘†)) is equivalent to
â¦„ğ‘˜0
,â¦ƒâ¦ƒâ¦‡ğ”¹, ğ•‚â¦ˆâ¦„ğ‘˜1
ğœ‹[ğµğ‘–](ğœ‹[ğµğ‘—](â¦ƒâ¦ƒ(ğ–¡â„, ğ–ª0
â„)â¦„ğ‘˜0
ğœ‹[ğµğ‘—](â¦ƒâ¦ƒâ¦‡ğ”¹, ğ•‚â¦ˆâ¦„â¦„ğ‘˜1
,â¦ƒâ¦ƒâ¦‡ğ”¹, ğ•‚â¦ˆâ¦„â¦„ğ‘˜1
, ğ‘˜0
ğ‘—
â„ âˆ‰ ğ‘‡ . So the pattern ğ©( Ì‚ğ¶â€², ğ‘†) of
On the other hand, by Lemma 8, ğ‘˜0
ğ‘˜1
ğ‘–
))
â„ âˆˆ ğ‘‡ and
, ğ–ª0
Ì‚ğ¶â€² is
â¦„ğ‘˜0
, ğ‘˜1
ğ‘—
, ğ–ª1
),
ğ‘–
ğ‘–
ğ‘—
ğ‘—
ğ‘–
ğ‘–
ğ‘–
ğ‘–
ğœ‹[ğµğ‘–](ğœ‹[ğµğ‘—](â¦ƒâ¦ƒ(ğ–¡â„, ğ–ª0
â„)â¦„ğ‘˜0
â¦„ğ‘˜0
,â¦ƒâ¦ƒâ¦‡ğ”¹, ğ•‚â¦ˆâ¦„ğ‘˜1
),â¦ƒâ¦ƒâ¦‡ğ”¹, ğ•‚â¦ˆâ¦„â¦„ğ‘˜1
ğœ‹[ğµğ‘—](â¦ƒâ¦ƒâ¦‡ğ”¹, ğ•‚â¦ˆâ¦„â¦„ğ‘˜1
ğ‘—
ğ‘—
ğ‘–
â¦„ğ‘˜0
ğ‘–
,
))
ğ‘—
ğ‘—
Thus ğ©( Ìƒğ¶â€², ğ‘†) â‰ˆğ›¼ ğ©( Ì‚ğ¶â€², ğ‘‡ ).
0 and ğ¶â€²
0) and ğ¶â€² = ğ¶â€²
0
circuits ğ¶â€²
also holds for the cases ğ¶â€² = ğ…ğ¢ğ«ğ¬ğ­(ğ¶â€²
Therefore our claim follows.
For the induction step, assuming the claim holds for sub-
1 of ğ¶, it is easy to check that the claim
â‹™ ğ¶â€²
1.
For the second part, let ğ‘¦ = ğ¶(ğ‘¥). Then for any ğ‘– âˆˆ [ğ‘š], ğ‘¦ğ‘–
is the actual value of the corresponding output wire. Since Ìƒğ‘¥ =
((ğ–ªğ‘¥1
1
), (ğ‘1, â€¦ , ğ‘ğ‘š)), we can calculate
ğ‘›, ğ–¡ğ‘›), (ğ‘âŠ•ğ‘¦ğ‘–
So Ìƒğ‘¥ â‰ˆğ›¼ Ì‚ğ‘¥, and thus ğ©( Ìƒğ‘¥, ğ‘†) â‰ˆğ›¼ ğ©( Ì‚ğ‘¥, ğ‘‡ ).
, ğ–¡1), â€¦ , (ğ–ª0
ğ›¼( Ìƒğ‘¥) = ((ğ–ª0
1
), â€¦ , (ğ–ªğ‘¥ğ‘›
, â€¦ , ğ‘âŠ•ğ‘¦ğ‘š
ğ‘š )) = Ì‚ğ‘¥.
ğ‘› , ğ–¡âŠ•ğ‘¥ğ‘›
, ğ–¡âŠ•ğ‘¥1
1
1
ğ‘›
Therefore the theorem holds.
As a corollary of Theorem 3 and 5, we can now conclude
that our garbled circuit scheme is computationally secure.
Corollary 1. For any circuit ğ¶ âˆˆ Circuit(ğ‘ , ğ‘¡) and any
ğ‘¥ âˆˆ {0, 1}ğ‘› where ğ‘  is a shape of ğ‘› wires, the probability
distributions (cid:2)ğ™¶ğšŠğš›ğš‹ğš•ğš(ğ¶, ğ‘¥)(cid:3) and (cid:2)ğš‚ğš’ğš–ğšğš•ğšŠğšğš(ğ¶, ğ¶(ğ‘¥))(cid:3) are
computationally indistinguishable.
VI. IMPLEMENTATION AND AUTOMATED TESTS
As a proof of concept, we have implemented our symbolic
framework as well as the garbling scheme and the simulator in
Haskell. The source code can be found at https://github.com/
b5li/SymGC. Our symbolic framework implementation closely
follows the deï¬nitions in Section II-A. In addition, we added
a normalization operation norm on patterns, for example:
ğš—ğš˜ğš›ğš– (ğ™½ğš˜ğš (ğ™±ğš’ğš ğ™µğšŠğš•ğšœğš)) = ğ™±ğš’ğš ğšƒğš›ğšğš
ğš—ğš˜ğš›ğš– (ğ™½ğš˜ğš (ğ™±ğš’ğš ğšƒğš›ğšğš)) = ğ™±ğš’ğš ğ™µğšŠğš•ğšœğš
ğš—ğš˜ğš›ğš– (ğ™½ğš˜ğš (ğ™½ğš˜ğš ğ‘’)) = ğš—ğš˜ğš›ğš– ğ‘’
ğš—ğš˜ğš›ğš– (ğ™¿ğšğš›ğš– (ğ™±ğš’ğš ğ™µğšŠğš•ğšœğš) ğ‘ ğ‘) = ğ™¿ğšŠğš’ğš› (ğš—ğš˜ğš›ğš– ğ‘) (ğš—ğš˜ğš›ğš– ğ‘)
ğš—ğš˜ğš›ğš– (ğ™¿ğšğš›ğš– (ğ™±ğš’ğš ğšƒğš›ğšğš) ğ‘ ğ‘) = ğ™¿ğšŠğš’ğš› (ğš—ğš˜ğš›ğš– ğ‘) (ğš—ğš˜ğš›ğš– ğ‘)
ğš—ğš˜ğš›ğš– (ğ™¿ğšğš›ğš– (ğ™½ğš˜ğš ğ‘) ğ‘ ğ‘) = ğš—ğš˜ğš›ğš– (ğ™¿ğšğš›ğš– ğ‘ ğ‘ ğ‘)
)),
The equivalence relation â‰¡ on patterns, deï¬ned in Sec-
tion II-A, is checked using syntactic equality on normalized
patterns. Random bit renaming and pseudo-random key re-
naming are implemented using maps on normalized bit and
key patterns. Thus we can check equivalence up to renaming
by ï¬rst applying renaming maps to normalized patterns and
then checking for equivalence.
To build symbolic expressions of the real and the simulated
garbled circuits, the pseudo-code deï¬nitions of the garbling
scheme and the simulator in Sections IV and V were directly
translated into Haskell code. The bit and key renamings ğ›¼ğµ and
ğ›¼ğ¾ were constructed recursively as in the proof of Lemma 5.
So far, given a circuit and a boolean vector of an appropriate
shape, our programs are able to produce symbolic expressions
of the real and the simulated garbled circuits, compute their
patterns, and check if these patterns are equivalent up to
renaming. The whole implementation consists of about 500
158
VII. CONCLUSION