keyboard in conjunction with the single step debugging mode of the UHCI con-
troller (see, [28, p.11]), the information was retrieved from the Linux debug ﬁle
system in /sys/kernel/debug/usb/uhci/, and PMUs counting BUS TRANS MEM
events.
Counting USB Device Events: With the same setup we determined how many
bus transactions are needed when the USB device has new data that are to
be transmitted into the main memory. For our USB keyboard we ﬁgured out
that exactly two bus transactions are needed to handle a keypress event. The
same is true for a key release event. The Linux driver handles such events with
an interrupt routine. Hence, to determine the expected bus activity AUHCI
we
request the number of handled interrupts from the OS and duplicate it. That
means for the overall number of bus transactions in our example: 4280 + 2 ·
#U SB interrupts = AUHCI
.
e
e
Further Bus Masters: To handle the bus activity of the whole computer plat-
form, the behavior of all other bus masters, such as the ethernet controller and
10
P. Stewin
(cid:1)(cid:25)(cid:5)(cid:1)(cid:25)(cid:5)
(cid:1)(cid:2)(cid:3)(cid:4)(cid:5)
(cid:1)(cid:2)(cid:3)(cid:4)(cid:5)
(cid:1)(cid:2)(cid:3)(cid:4)(cid:4)(cid:5)
(cid:1)(cid:2)(cid:3)(cid:4)(cid:4)(cid:5)
(cid:6)(cid:7)(cid:8)(cid:2) (cid:18)(cid:18)(cid:18)(cid:18)(cid:18)(cid:18)(cid:18)(cid:18)
(cid:3)(cid:3)(cid:3)
(cid:3)(cid:3)(cid:3)
(cid:17)(cid:15)(cid:8)(cid:11)(cid:7)(cid:18)(cid:19)(cid:20)(cid:4)(cid:12)(cid:13)(cid:7)(cid:15)
(cid:18)(cid:18)(cid:18)(cid:18)(cid:6)(cid:7)(cid:8)(cid:2)
(cid:3)(cid:3)(cid:3)
(cid:3)(cid:3)(cid:3)
(cid:1)(cid:24)(cid:5)(cid:1)(cid:24)(cid:5)
(cid:18)(cid:18)(cid:18)(cid:18)(cid:6)(cid:7)(cid:8)(cid:2)
(cid:1)(cid:8)(cid:5)(cid:1)(cid:8)(cid:5)
(cid:21)(cid:22)(cid:7)(cid:22)(cid:7)(cid:18)(cid:23)(cid:7)(cid:8)(cid:2)
(cid:6)(cid:7)(cid:8)(cid:2)
(cid:21)(cid:22)(cid:7)(cid:22)(cid:7)(cid:18)(cid:23)(cid:7)(cid:8)(cid:2)
(cid:14)(cid:7)(cid:15)(cid:11)(cid:4)(cid:12)(cid:8)(cid:13)(cid:7)(cid:16)
(cid:6)(cid:7)(cid:8)(cid:2)
(cid:9)(cid:10)(cid:7)(cid:11)(cid:7)(cid:12)(cid:13)
(cid:6)(cid:7)(cid:8)(cid:2) (cid:18)(cid:18)(cid:18)(cid:18)(cid:18)(cid:18)(cid:18)(cid:18)
(cid:3)(cid:3)(cid:3)
(cid:3)(cid:3)(cid:3)
(cid:17)(cid:15)(cid:8)(cid:11)(cid:7)(cid:18)(cid:19)(cid:20)(cid:4)(cid:12)(cid:13)(cid:7)(cid:15)
(cid:3)(cid:3)(cid:3)
(cid:3)(cid:3)(cid:3)
(cid:21)(cid:22)(cid:7)(cid:22)(cid:7)(cid:18)(cid:23)(cid:7)(cid:8)(cid:2)
(cid:6)(cid:7)(cid:8)(cid:2) (cid:18)(cid:18)(cid:18)(cid:18)(cid:18)(cid:18)(cid:18)(cid:18)
(cid:3)(cid:3)(cid:3)
(cid:3)(cid:3)(cid:3)
(cid:17)(cid:15)(cid:8)(cid:11)(cid:7)(cid:18)(cid:19)(cid:20)(cid:4)(cid:12)(cid:13)(cid:7)(cid:15)
(cid:6)(cid:7)(cid:8)(cid:2)
(cid:14)(cid:7)(cid:15)(cid:11)(cid:4)(cid:12)(cid:8)(cid:13)(cid:7)(cid:16)
(cid:3)(cid:3)(cid:3)
(cid:3)(cid:3)(cid:3)
(cid:6)(cid:7)(cid:8)(cid:2)
(cid:21)(cid:22)(cid:7)(cid:22)(cid:7)(cid:18)(cid:23)(cid:7)(cid:8)(cid:2)
(cid:6)(cid:7)(cid:8)(cid:2)
(cid:9)(cid:10)(cid:7)(cid:11)(cid:7)(cid:12)(cid:13)
(cid:14)(cid:7)(cid:15)(cid:11)(cid:4)(cid:12)(cid:8)(cid:13)(cid:7)(cid:16)
Fig. 4. UHCI Schedule Information (simpliﬁed): The schedule reveals that int
and async queues are in use. The physical addresses of queue link targets are denoted in
brackets. A queue link or queue element, which terminates, contains the value 00000001
instead of a physical address. The int16 queue is responsible for our USB keyboard.
the harddisk controller, must also be analyzed similar to the UHCI controller.
We had to analyze one more bus master when we tested our detection model
on Lenovo Thinkpad laptops. We were unable to turn oﬀ the ﬁngerprint reader
(FR) via the BIOS on an older Thinkpad model. Hence, we analyzed the ﬁnger-
print reader and considered this bus master for our implementation. We ﬁgured
out that it causes four bus transactions per millisecond. For this paper, or more
precisely, to verify our hypothesis, it is suﬃcient to consider up to ﬁve bus mas-
ters for BARM. Besides from the two CPU-based bus masters and the UHCI
controller we also consider Intel’s Manageability Engine (ME) as a bus master.
During normal operation we assume AME
= 0. To be able to prove that our
detection model works with a computer platform we do not use all bus masters
available on the platform in our experiment. For example, we operate the Linux
OS completely from the computer’s main memory in certain tests of our evalu-
ation (see Section 5). This allows us to make use of the harddisk controller I/O
functionality as needed. We are preparing a technical report with further bus
master details, i. e., ethernet and harddisk controller, etc.
e
Summary of Bus Master Analysis: With the analysis presented in the pre-
vious sections we can already determine which bus master caused what amount
of memory transactions. This intermediate result is depicted in Figure 5.
4.3 Bus Agent Runtime Monitor
With the background information that we introduced in Section 4.1 we were able
to implement BARM in the form of a Linux kernel module. In this section we
describe how we implemented a monitoring strategy that permanently monitors
and also evaluates bus activity.
Revealing Stealthy Peripheral-Based Attacks on Main Memory
11
(cid:9)
(cid:8)
(cid:7)
(cid:6)
(cid:5)
(cid:4)
(cid:3)
(cid:2)
(cid:1)
(cid:11)
(cid:14)
(cid:8)
(cid:17)
(cid:16)
(cid:15)
(cid:13)
(cid:11)
(cid:14)
(cid:13)
(cid:6)
(cid:12)
(cid:7)
(cid:11)
(cid:2)
(cid:10)
(cid:26)
(cid:25)
(cid:24)
(cid:23)
(cid:8)
(cid:22)
(cid:7)
(cid:21)
(cid:5)
(cid:20)
(cid:13)
(cid:15)
(cid:19)
(cid:18)
(cid:3)(cid:5)(cid:6)(cid:1)(cid:8)
(cid:3)(cid:5)(cid:6)(cid:1)(cid:7)
(cid:3)(cid:1)(cid:1)(cid:4)(cid:1)(cid:1)(cid:1)
(cid:3)(cid:1)(cid:4)(cid:1)(cid:1)(cid:1)
(cid:3)(cid:4)(cid:1)(cid:1)(cid:1)
(cid:3)(cid:1)(cid:1)
(cid:3)(cid:1)
(cid:3)
(cid:1)(cid:2)(cid:3)
(cid:1)
(cid:3)(cid:1)
(cid:9)(cid:1)
(cid:10)(cid:1)
(cid:11)(cid:1)
(cid:12)(cid:1)
(cid:7)(cid:1)
(cid:8)(cid:1)
(cid:19)(cid:13)(cid:3)(cid:27)(cid:20)(cid:17)(cid:14)(cid:23)(cid:7)(cid:17)(cid:14)(cid:7)(cid:24)(cid:25)(cid:28)(cid:29)(cid:3)(cid:11)(cid:7)(cid:19)(cid:16)(cid:5)(cid:27)(cid:11)
(cid:13)(cid:14)(cid:14)(cid:15)(cid:16)(cid:17)(cid:18)(cid:5)(cid:5)(cid:15)(cid:19)(cid:20)(cid:21)(cid:15)(cid:22)(cid:23)(cid:21)(cid:24)(cid:5)(cid:18)(cid:21)
(cid:25)(cid:26)(cid:24)(cid:17)(cid:27)(cid:20)(cid:24)(cid:15)(cid:3)(cid:21)(cid:24)(cid:15)(cid:28)(cid:29)(cid:30)(cid:15)(cid:19)(cid:20)(cid:21)(cid:15)(cid:22)(cid:23)(cid:21)(cid:24)(cid:5)(cid:18)
(cid:25)(cid:26)(cid:24)(cid:17)(cid:27)(cid:20)(cid:24)(cid:15)(cid:3)(cid:21)(cid:24)(cid:15)(cid:23)(cid:31)(cid:32)(cid:15)(cid:9)(cid:31)(cid:32)(cid:15)(cid:28)(cid:29)(cid:30)(cid:15)(cid:19)(cid:20)(cid:21)(cid:15)(cid:22)(cid:23)(cid:21)(cid:24)(cid:5)(cid:18)(cid:21)
(cid:33)(cid:27)(cid:15)(cid:13)(cid:34)(cid:24)(cid:26)(cid:35)(cid:5)(cid:15)(cid:19)(cid:20)(cid:21)(cid:15)(cid:22)(cid:23)(cid:21)(cid:24)(cid:5)(cid:18)(cid:21)
Fig. 5. Breakdown of Memory Transactions Caused by Three Active Bus
Masters: The curve at the top depicts the number of all memory transactions of
all active bus masters (in our setup), that is, Am. The curve below depicts Am re-
duced by the expected memory transactions of the ﬁrst CPU bus master, that is,
− ACP U BA#1
Am − ACP U BA#0
.
The curve at the bottom represents Am − ACP U BA#0
− AU HCI
. The next curve below represents Am − ACP U BA#0
− ACP U BA#1
.
e
e
e
e
e
e
m
and ACP U
Permanent Monitoring: The performance monitoring units are already conﬁg-
ured to measure BUS TRANS MEM events. The permanent monitoring of Am, i. e.,
ACP U
m , is implemented using the following steps: (i) Reset counters
and store initial I/O statistics of all non-CPU bus masters (e. g., UHCI, FR,
ME, HD, ETH, VC). (ii) Start counting for a certain amount of time t (imple-
mented using high precision timer). (iii) Stop counters when t is reached. (iv)
(see Section 4.2) as well as updated I/O
statistics of all non-CPU bus agents. (v) Continue with step (i) and determine
Store counter values for Am and ACP U
Ae in parallel by waking up the according evaluation kernel thread.
m
m
m
and ACP U
using the stored counter values for Am and ACP U
Comparison of Measured Bus Activity and Expected Bus Activity: BARM com-
pares ACP U
when executing the evaluation kernel thread as follows:
(i) Determine ACP U
(see
Section 4.2). (ii) Calculate ACP U
, AHD
,
AET H
, etc. that are determined by utilizing the diﬀerence of the stored
updated I/O statistics and the stored initial I/O statistics. Note, to facilitate
= 0, etc. (iii) Compare ACP U
our implementation we assume AHD
and ACP U
, report results and, if necessary, apply a defense mechanism.
by considering AUHCI
e = 0, AET H
m
, AME
, AF R
, AV C
m
e
e
e
e
e
e
e
e
e
e
Tolerance Value: For practicality we need to redeﬁne how Aa is calculated.
We use Aa to interpret the PMU measurements in our PoC implementation.
One reason is that PMU counters cannot be started/stopped simultaneously.
Very few processor cycles are needed to start/stop a counter and counters are
started/stopped one after another. The same can occur in the very short amount
of time, where the counters are stopped to be read and to be reset (see time-
frame between step (iii) and step (ii) when permanently monitoring). Similar
inaccuracies can occur when reading I/O statistics logged by the OS. Hence, we
introduce the tolerance value T ∈ N and reﬁne Aa:
12
P. Stewin
(cid:3)
AT a =
if |Am − Ae| ∈ {0,··· ,T }
|Am − Ae| , if |Am − Ae| /∈ {0,··· ,T }
0,
The value of T is a freely selectable number in terms of bus transactions that
BARM can tolerate when checking for additional bus traﬃc. Our evaluation
demonstrates that a useful T is rather a small value (see Section 5). Nonetheless,
we have to consider that T > 0 theoretically gives the attacker the chance to
hide the attack, i. e., to execute a transient attack. In the best case (see Figure 6)
the stealthy attack can have 2T bus transactions at most. It is very unlikely that
2T bus transactions are enough for a successful attack. Data is most likely at a
diﬀerent memory location after a platform reboot. Hence, the memory must be
scanned for valuable data and this requires a lot of bus transactions. Mechanisms
such as Address Space Layout Randomization (ASLR, [29, p.246ﬀ.]) that are
applied by modern OSes can also complicate the search phase. This results in
additional bus transactions. Furthermore, the attacker needs to know the very