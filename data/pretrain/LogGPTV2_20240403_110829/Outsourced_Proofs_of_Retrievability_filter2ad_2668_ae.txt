### 4.1 Implementation Setup

We implemented a prototype of Fortress in Java. For the construction of dispersal codes, we used the Jerasure library [4], which is instantiated with Reed-Solomon coding. To provide a baseline for comparison, we also implemented the PSW and public POR schemes (with both BLS and RSA variants) as described in Appendix A. Our implementation relied on 160-bit SHA1, the Java built-in random number generator, HMAC based on SHA1, and the JPBC library [7] (which is based on the PBC cryptographic library [3]) for BLS signatures.

Table 1 summarizes the default parameters used in our setup. The implementations were deployed on a private network consisting of two 24-core Intel Xeon E5-2640 machines, each with 32GB of RAM. Communication between the machines was facilitated by a 100 Mbps switch. The storage server was hosted on one machine, while the clients and auditors were co-located on the second machine to ensure a fair comparison of the overheads incurred in the SW POR schemes and Fortress.

To emulate a realistic Wide Area Network (WAN), we used NetEm [27]. We added a Pareto distribution with a mean of 20 ms and a variance of 4 ms to shape the traffic exchanged over the network interfaces, simulating the packet delay variance typical of WANs [21].

In our setup, each client operates in a closed loop, meaning that a client can have at most one pending operation at a time. Before the setup phase, each client disperses their files using a (9,12) code. In our evaluation, we abstracted away the time required to encrypt the file before erasure-coding and did not measure the upload/download times, as these overheads are common to all investigated schemes.

Each client queries the availability of an individual file stored on the local disk of the server. This approach eliminates the need for different clients to synchronize on a common file descriptor when querying pieces from the storage servers. Clients acquire Bitcoin block hashes by invoking an HTTP request to a getblockhash tool provided by the Bitcoin block explorer [1].

We evaluated the latency incurred in Fortress and the private and public POR schemes of [35] with respect to the number of challenges, block size, and number of sectors. For Fortress, we spawned multiple threads on the auditor machine, each corresponding to a unique audit performed on behalf of a client. Each data point in our plots is averaged over 10 independent measurements, and we include the corresponding 95% confidence intervals where appropriate.

### 4.2 Evaluation Results

Before evaluating the performance of Fortress, we analyzed the impact of block size on the latencies incurred in the verification of POR in the private and public SW schemes [35]. We abstracted away the network delays and focused on measuring the time required by the clients/auditor to verify the cloud's response. Note that this verification in Fortress corresponds to that of the private SW scheme. Our results (Figure 6 in Appendix C) show that modest block sizes of 16 KB yield the most balanced performance across all investigated schemes. Therefore, we set the block size to 16 KB for the rest of our evaluation.

**POR Protocol Performance:**
In Figure 2(a), we evaluate the time required by the auditor to perform a single POR in Fortress compared to the SW schemes. We vary the fraction of challenged blocks relative to the total number of blocks in the file. In Fortress, the number of user-challenges is set to 10% of the auditor-challenges by default. Our results show that Fortress incurs a small additional overhead in time (~10%) compared to PSW due to the need to sample challenges based on the latest Bitcoin block and the additional overhead required to create and verify user-challenges. These operations enable Fortress to achieve a stronger security level than PSW. The time to perform POR in Fortress increases linearly with the fraction of challenged blocks, similar to the other investigated schemes. Fortress improves the performance of the BLS-based SW POR by almost 17% and the RSA-based SW POR by 50%.

Figure 2(b) shows the latency incurred in Fortress and PSW with respect to the number of concurrent POR operations, assuming 10% of the stored blocks are challenged in each POR. Our findings indicate that Fortress results in a tolerable performance degradation compared to PSW under heavy load, despite the additional procedures (e.g., GetRandomness, user-challenges) employed in Fortress.

In a separate experiment, we evaluated the peak throughput exhibited by Fortress when verifying POR (i.e., verifying Equation 1). We measured peak throughput by requiring each client to perform back-to-back POR verification operations and then increasing the number of clients until the aggregated throughput was saturated. The peak throughput is computed as the maximum aggregated number of POR operations that can be performed per second. Our results show that the peak throughput of Fortress is approximately 5200 POR verification operations per second.

Figure 2(c) measures the latency incurred in Fortress compared to the SW POR schemes with respect to the number of concurrent POR verifications that can be performed by the auditor per second. Verification in Fortress is similar to that of PSW (i.e., verification of Equation 1). Our results show that POR verifications in Fortress are almost 2000 times faster than BLS SW POR and 3000 times faster than the RSA counterpart, demonstrating that Fortress scales well with the number of clients compared to existing unbounded public POR schemes.

**Store Protocol Performance:**
In Figure 3, we measure the time required for the store procedure in the investigated POR schemes. As expected, the store time increases almost linearly with the file size in all POR schemes (note the logarithmic y-axis scale). Our results show that the store latency incurred on the auditor in Fortress is almost 5 times slower than in PSW, mainly due to the generation of various commitments by the auditor. This process is 100 times faster than the store in public BLS SW and almost 25 times faster than the public RSA scheme. On the other hand, the time required by the user to complete the store procedure is considerably larger, as the user needs to verify the correctness of the ZKP of all the auditor POR parameters. This process is almost 100 times slower compared to the store performance of the auditor; however, the store time incurred on the user in Fortress is 20% faster than that required by the public BLS SW scheme. Although the store procedure is expensive for the user, it is only performed once, after which the user does not need to perform any further operations.

**User Verification (CheckLog):**
In Figure 4, we evaluate the time incurred on the user when verifying the auditor logs with respect to the number of verified log entries. The user requests a number of log entries for verification, which are accumulated into one response and sent by the auditor to the user, who can batch-verify them in a single computation. In our implementation of Fortress, the size of each log entry stored by the auditor is approximately 32 KB (8 bytes for the Bitcoin block, 20 bytes for the Bitcoin hash, 32800 bytes for the cloud response, and 256 bytes for the signatures). This implies almost 100% storage blowup compared to the standalone PSW scheme (i.e., the size of the cloud response in PSW is around 16400 bytes). This is because in Fortress, the auditor needs to store both the response of the cloud to his challenges and the user-based challenges. Our results show that the latency incurred on the user increases linearly with the number of verified log entries. This effort is only a small fraction of the burden incurred on the auditor and can be tolerated in practical settings, as this is an optional verification and is only seldomly performed by the user.

**Comparison with the PDP of [11]:**
In an additional experiment, we measured the performance of Fortress compared to the publicly verifiable PDP scheme of [11]. Note that the latter PDP scheme can be seen as a variant of the public RSA SW scheme in which each block comprises a single sector. Recall that the PDP of [11] is not secure in the OPOR model (see Appendix B). Our results (cf. Figure 5) show that the latency of performing a POR in Fortress—featuring 80 bits sector size—is considerably faster than that of [11] when the block size is modest (e.g., ≤ 8000 bits). As the block size increases, the PDP of [11] results in smaller latencies, likely due to the large number of I/O operations required by Fortress to fetch the numerous sectors from each challenged block. Indeed, as the number of sectors per block decreases in Fortress (e.g., when the sector size increases to 1 KB), our results show that Fortress considerably improves the performance over the PDP of [11].

### 5. Related Work

Juels and Kaliski [24] present a POR scheme that relies on indistinguishable blocks, hidden among regular file blocks, to detect data modification by the server. This proposal supports a bounded number of POR queries, after which the storage server can learn all the embedded sentinels. The authors also propose a Merkle-tree construction for constructing public POR, which can be verified by any external party without the need for a secret key. Bowers et al. [15] propose various improvements to the original POR in [24], which tolerate a Byzantine adversarial model. Shacham and Waters [35] propose private-key-based and public-key-based POR schemes that utilize homomorphic authenticators to yield compact proofs. Dodis et al. [22] generalize the schemes of [24,35] and introduce the notion of POR codes, which combine concepts in POR and hardness amplification.

Ateniese et al. [11] propose a variant of POR called proofs of data possession (PDP), which supports an unbounded number of challenge queries and enables public verifiability of the PDP. This proposal was later extended in [12] to address dynamic writes/updates from the clients. Erway et al. [23] present a dynamic PDP that leverages authenticated dictionaries based on rank information. Similarly, Cash et al. [17] propose a dynamic POR scheme that relies on oblivious RAM protocols. Shi et al. [37] propose a dynamic POR scheme that improves the performance of [17] by using a Merkle hash tree. Other contributions propose the notion of delegable verifiability of POR; for instance, in [32, 36], the authors describe schemes that enable the user to delegate the verification of POR and prevent further re-delegation. Curtmola et al. [19] propose a multiple-replica PDP, which enables a user to verify that a file is replicated at least across t replicas by the cloud. HAIL [14] enables a set of servers to prove to a client that a stored file is intact and retrievable against a mobile adversary, i.e., one that may progressively corrupt the full set of storage servers. Bowers et al. [16] propose a scheme that enables a user to verify if their data is stored (redundantly) at multiple servers by measuring the time taken for a server to respond to a read request for a set of data blocks.

Proofs of location (PoL) [28, 38] aim to prove the geographic position of data, e.g., if it is stored on servers within a certain country. Watson et al. [38] provide a formal definition for PoL schemes by combining geolocation techniques with the SW POR schemes. Proofs of ownership schemes [29] also share similarities with POR. A proof of ownership scheme aims to provide assurance that a client indeed possesses a given file, which is, for example, already stored in the cloud.

Popa et al. [30] present a scheme that allows proving the occurrence of violations in the cloud against data integrity, write-serializability, and freshness to a third party. First introduced in 2008, Bitcoin has attracted considerable attention from the research community [10, 18, 20, 25, 26, 31, 33]. To the best of our knowledge, this is the first contribution that proposes relying on Bitcoin Proof of Work (PoW) as a secure time-dependent pseudorandomness source.

### 6. Conclusion

In this paper, we introduced the notion of outsourced proofs of retrievability (OPOR), an extension of the traditional POR concept, and proposed an efficient instantiation of OPOR, dubbed Fortress. We implemented a prototype based on Fortress and evaluated its performance in a realistic cloud setting. Our results show that our proposal incurs minimal overhead on the user and scales well with the number of users.

We argue that Fortress motivates a novel business model in which customers and external auditors establish a contract to ensure the security of their files. By doing so, Fortress increases the users' trust in the cloud while incurring minimal user interaction. We believe that our work lays the foundation for realizing secure external auditing of cloud services and will provide a stepping stone for establishing a cyber-insurance market for cloud services.

In terms of future work, we plan to explore efficient mechanisms to optimize the store procedure in Fortress, investigate a generic transformation to turn any POR into an OPOR, and design an OPOR scheme that supports dynamic updates of the stored file.

### 7. Acknowledgements

The authors would like to thank the anonymous reviewers for their valuable feedback and comments. This work was partly supported by the EU FP7 SECCRIT project, funded by the European Commission under grant agreement no. 312758.

### 8. References

[1] Bitcoin real-time stats and tools. http://blockexplorer.com/q.
[2] Cloud Computing: Cloud Security Concerns. http://technet.microsoft.com/en-us/magazine/hh536219.aspx.
[3] PBC Library. http://crypto.stanford.edu/pbc/, 2007.
[4] Jerasure.