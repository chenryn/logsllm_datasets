a realistic cloud setting and we compare the performance of Fortress
to the private- and public-POR schemes due to [35] and to the PDP
scheme of [11].
4.1
Implementation Setup
We implemented a prototype of Fortress in Java. In our imple-
mentation, we relied on the Jerasure library [4] for constructing
the dispersal codes (instantiated using Reed-Solomon coding). For
a baseline comparison, we also implemented PSW and the pub-
lic POR (with its two BLS and RSA variants) schemes (see Ap-
pendix A for a description of the SW POR schemes). Here, we
relied on 160-bit SHA1, the Java built-in random number genera-
tor, HMAC based on SHA1, and the JPBC library [7] (based on
the PBC cryptographic library [3]) to implement BLS signatures.
Table 1 summarizes the default parameters assumed in our setup.
We deployed our implementations on a private network consist-
ing of two 24-core Intel Xeon E5-2640 with 32GB of RAM. In
our network, the communication between various machines was
bridged using a 100 Mbps switch. The storage server was running
on one of the 24-core Xeon E5-2640 machine, whereas the clients
and auditors were co-located on the second 24-core Xeon E5-2640
machine; this ensures a fair comparison between the overhead in-
curred on the user in the SW POR schemes and on the auditor in
(a) Latency incurred in POR w.r.t. the frac-
tion of challenged blocks.
(b) Latency incurred in POR w.r.t. number of
concurrent operations.
(c) Latency incurred in POR veriﬁcations
w.r.t. number of concurrent operations.
Figure 2: Performance of the POR phase in Fortress in comparison to the private and public POR of [35]. Each data point in our
plots is averaged over 10 independent runs; where appropriate, we also show the corresponding 95% conﬁdence intervals.
Fortress.
To emulate a realistic Wide Area Network (WAN), we relied on
NetEm [27]. For that purpose, we add a Pareto distribution with a
mean of 20 ms and a variance of 4 ms, to shape all trafﬁc exchanged
on the networking interfaces to emulate the packet delay variance
speciﬁc to WANs [21].
In our setup, each client invokes an operation in a closed loop,
i.e., a client may have at most one pending operation. Prior to the
setup phase, each client disperses his ﬁles with a (9,12) code. In
our evaluation, we abstract away the time to encrypt the ﬁle (prior
to erasure-coding), and we do not measure the upload/download
times of the ﬁle to/from the cloud, since this overhead is common
to all investigated schemes.
In our implementations, each client queries for the availability
of an individual ﬁle stored on a local disk in the server. This pre-
vents the need for different clients to synchronize on a common ﬁle
descriptor when querying pieces from the storage servers. To ac-
quire Bitcoin block hashes, our clients invoke an HTTP request to
a getblockhash tool offered by the Bitcoin block explorer4 [1].
We evaluate the latency incurred in Fortress and in the private
and public POR schemes of [35], with respect to the number of
challenges, the block size, and the number of sectors. When im-
plementing Fortress, we spawned multiple threads on the auditor
machine, each thread corresponding to a unique audit performed
on behalf of a client. Each data point in our plots is averaged over
10 independent measurements; where appropriate, we include the
corresponding 95% conﬁdence intervals.
4.2 Evaluation Results
Before evaluating the performance of Fortress, we start by an-
alyzing the impact of the block size on the latencies incurred in
the veriﬁcation of POR in the private and public SW schemes [35].
Here, we abstract away the network delays and focus on measuring
the time required by the clients/auditor to verify the response of the
cloud. Note that this veriﬁcation in Fortress corresponds to that of
the private SW scheme. Our results (Figure 6 in Appendix C) show
that modest block sizes of 16 KB yield the most balanced perfor-
mance, on average, across all investigated schemes. Throughout
the rest of our evaluation, we therefore set the block size to 16 KB.
POR protocol performance: In Figure 2(a), we evaluate the time
required by the auditor to perform a single POR in Fortress, when
4For example,
the hash of Bitcoin block ‘X’ can be ac-
quired by invoking https://blockexplorer.com/q/
getblockhash/X.
compared to the SW schemes. For this purpose, we vary in the x-
axis the fraction of challenged blocks of the total number of blocks
of the ﬁle. In Fortress, the number of user-challenges are set by
default to 10% of the auditor-challenges. Our results show that
Fortress incurs a small additional overhead in time (~10%) in the
POR when compared to PSW, due to the need to sample the chal-
lenges based on the latest Bitcoin block, and owing to the addi-
tional overhead required to create and verify the user-challenges.
Recall that these operations enable Fortress to achieves a stronger
security level than that of PSW. Moreover, the time to perform
POR in Fortress increases linearly with the fraction of challenged
blocks; all investigated schemes also exhibited a similar perfor-
mance. Fortress however improves the performance of the BLS-
based SW POR by almost 17%, and the RSA-based SW POR by
50%. Figure 2(b) depicts the latency incurred in Fortress and in
PSW w.r.t. to the number of concurrent POR operations in the nom-
inal case where 10% of the stored blocks are challenged in each
POR. Our ﬁndings show that Fortress results in a tolerable per-
formance degradation when compared to PSW under heavy load,
in spite of the additional procedures (e.g., GetRandomness, user-
challenges) employed in Fortress.
In a separate experiment that we conducted, we evaluated the
peak throughout exhibited by Fortress when verifying POR (i.e.,
when verifying Equation 1). We measure peak throughput as fol-
lows: we require that each client performs back to back POR ver-
iﬁcation operations; we then increase the number of clients in the
system until the aggregated throughput attained by all clients is sat-
urated. The peak throughput is then computed as the maximum ag-
gregated number of POR operations that can be performed with the
storage servers per second. Our results show that the peak through-
put of Fortress is approximately 5200 POR veriﬁcation operations
per second.
In Figure 2(c), we measure the latency incurred in Fortress when
compared to the SW POR schemes, w.r.t. the number of concurrent
POR veriﬁcations that can be performed by the auditor per second.
Recall that this veriﬁcation in Fortress is specular to that of PSW
(i.e., veriﬁcation of Equation 1). Our results show that POR veriﬁ-
cations in Fortress is almost 2000 times faster than BLS SW POR,
and 3000 times faster than the RSA counterpart. This clearly shows
that Fortress scales well with the number of clients when compared
to existing unbounded public POR schemes.
Store protocol performance:
In Figure 3, we measure the time
required in the store procedure of the investigated POR schemes.
As expected, the store time increases almost linearly with the ﬁle
%10%25%50%75%100Fractionofchallengedblocks10321003161000Latency(sec)FortressPSWPublicBLSSWPublicRSASW020406080100120140NumberofPOR020004000600080001000012000Latency(sec)FortressPSW2000400060008000100001200014000NumberofPORveriﬁcations110100100010000Latency(sec)Fortress/PSWPublicBLSSWPublicRSASWFigure 3: Latency in store w.r.t. to the ﬁle size.
Figure 4: User veriﬁcation latency in the CheckLog procedure
of Fortress w.r.t. the number of veriﬁed log entries.
size in all POR schemes (note the logarithmic y-axis scale). Our re-
sults show that the store latency incurred on the auditor in Fortress
is almost 5 times slower than of PSW; this overhead is mainly
due to the generation of the various commitments by the audi-
tor. We point out that this process is 100 times faster than that
the store in public BLS SW, and almost 25 times faster than the
public RSA scheme. On the other hand, the time required by the
user to complete the store procedure is considerably larger, since
the user needs to verify the correctness of the ZKP of all the au-
ditor POR parameters.
Indeed, this process is almost 100 times
slower compared to the store performance of the auditor; the store
time incurred on the user in Fortress is however 20% faster than
that required by the public BLS SW scheme. Although the store
procedure is expensive on the user, this process is only performed
once—after which the user does not need to perform any operation.
User veriﬁcation (CheckLog): In Figure 4, we evaluate the time
incurred on the user when verifying the auditor logs with respect
to the number of veriﬁed log entries. Here, the user requests a
number of log entries for veriﬁcation; these entries are accumu-
lated into one response and sent by the auditor to the user who can
batch-verify them in a single computation. In our implementation
of Fortress, the size of each log entry stored by the auditor is ap-
proximately 32 KB (8 bytes for the Bitcoin block, 20 bytes for the
Bitcoin hash, 32800 bytes for the cloud response, and 256 bytes for
the signatures). This implies almost 100% storage blowup when
compared to the standalone PSW scheme (i.e., the size of cloud
response in PSW is around 16400 bytes); this is due to the fact
that in Fortress, the auditor needs to store both the response of the
cloud to his challenges, and to the user-based challenges. Our re-
sults show that the latency incurred on the user increases linearly
with the number of veriﬁed log entries. Note that this effort is only
a small fraction of the burden incurred on the auditor. Indeed, this
overhead can be, to a large extent, tolerated in practical settings;
recall that this is an optional veriﬁcation, and is only seldomly per-
formed by the user.
Figure 5: Performance of the POR phase in Fortress in compar-
ison to the PDP of [11] with respect to the block size. We rely
on a modulus size of 1024 bits when implementing the PDP.
Comparison with the PDP of [11]: In an additional experiment
that we conducted, we measure the performance of Fortress when
compared to publicly veriﬁable PDP scheme of [11]. Note that
the latter PDP scheme can be seen as a variant of the public RSA
SW scheme in which each block comprises of a single sector. Re-
call that the PDP of [11] is not secure in the OPOR model (see
Appendix B). Our results (cf. Figure 5) show that the latency of
performing a POR in Fortress—featuring 80 bits sector size—is
considerably faster than that of [11] when the block size is modest
(e.g., ≤ 8000 bits). As the block size increases, the PDP of [11]
results in smaller latencies; we believe that this is due to the large
number of I/O operations required by Fortress to fetch the numer-
ous sectors from each challenged block. Indeed, as the number of
sectors per block decreases in Fortress (e.g., when the sector size
increases to 1 KB), our results show that Fortress considerably im-
proves the performance over the PDP of [11].
5. RELATED WORK
Juels and Kaliski [24] present a POR scheme, which relies on
sentinels that are indistinguishable blocks, hidden among regular
ﬁle blocks in order to detect data modiﬁcation by the server. This
proposal only supports a bounded number of POR queries, after
which the storage server can learn all the embedded sentinels. The
authors also propose a Merkle-tree construction for constructing
public POR, which can be veriﬁed by any external party without
the need of a secret key. Bowers et al. [15] propose various im-
provements to the original POR in [24], which tolerates a Byzan-
tine adversarial model. Shacham and Waters [35] propose private-
key-based and public-key-based POR schemes which utilize homo-
morphic authenticators to yield compact proofs. Dodis et al. [22]
generalize the schemes of [24,35] and introduce the notion of POR
codes, which combines concepts in POR and hardness ampliﬁca-
tion.
In [11], Ateniese et al. propose a variant of POR called proofs of
data possession (PDP). It supports an unbounded number of chal-
lenge queries and enables public veriﬁability of the PDP. This pro-
posal was later extended in [12] to address dynamic writes/updates
from the clients. Erway et al. [23] present a dynamic PDP which
leverages on authenticated dictionaries based on rank information.
Similarly, Cash et al. [17] propose a dynamic POR scheme which
relies on oblivious RAM protocols. In [37], Shi et al. propose a
dynamic POR scheme that considerably improves the performance
of [17] by relying on a Merkle hash tree. Other contributions pro-
pose the notion of delegable veriﬁability of POR; for instance, in
[32, 36], the authors describe schemes that enable the user to dele-
1MB16MB32MB64MBFileSize0.010.1110100Latency(min)Fortress(User)Fortress(Auditor)PSWPublicBLSSWPublicRSASW2060100200500NumberofLogEntries102030406080Latency(sec)101K16K32KBlockSize(bytes)131031100Latency(sec)Fortress(80bitsectors)Fortress(1KBsectors)PDP[11]gate the veriﬁcation of POR and to prevent their further re-delega-
tion. Curtmola et al. propose in [19] a multiple-replica PDP, which
enables a user to verify that a ﬁle is replicated at least across t repli-
cas by the cloud. HAIL [14] enables a set of servers to prove to a
client that a stored ﬁle is intact and retrievable against a mobile
adversary, i.e., one that may progressively corrupt the full set of
storage servers. In [16], Bowers et al. propose a scheme that en-
ables a user to verify if his data is stored (redundantly) at multiple
servers by measuring the time taken for a server to respond to a
read request for a set of data blocks.
Proofs of location (PoL) [28, 38] aim at proving the geographic
position of data, e.g., if it is stored on servers within a certain coun-
In [38], Watson et al. provide a formal deﬁnition for PoL
try.
schemes by combining the use of geolocation techniques together
with the SW POR schemes. Proofs of ownership schemes [29] also
share similarities with POR. A proof of ownership scheme aims to
provide assurance that a client indeed possesses a given ﬁle, which
is e.g., already stored at the cloud.
In [30], Popa et al. present a scheme which allows to prove the
occurrence of violations in the cloud against data integrity, write-
serializability and freshness to a third party.
First introduced in 2008, Bitcoin has considerably attracted the
attention of the research community [10, 18, 20, 25, 26, 31, 33]. As
far as we are aware, this is the ﬁrst contribution which proposes
the reliance on Bitcoin PoW as a secure time-dependent pseudo-
randomness source.
6. CONCLUSION
In this paper, we introduced the notion of outsourced proofs of
retrievability (OPOR), an extension of the traditional POR con-
cept, and proposed an efﬁcient instantiation of OPOR, dubbed
Fortress. We implemented a prototype based on Fortress, and eval-
uated its performance in a realistic cloud setting. Our results show
that our proposal incurs minimal overhead on the user and scales
well with the number of users.
We argue that Fortress motivates a novel business model in which
customers and external auditors establish a contract by which cus-
tomers can rest assured about the security of their ﬁles. By doing
so, Fortress increases the users’ trust in the cloud, while incurring
minimal user interaction. We therefore argue that our work lays
basic foundations for realizing secure external auditing of cloud
services; we believe that such auditor-based schemes will provide
a stepping stone for establishing a cyber-insurance market for cloud
services.
In terms of future work, we plan to explore efﬁcient mechanisms
to optimize the store procedure in Fortress, to investigate a generic
transformation to turn any POR into an OPOR, and to design an
OPOR scheme that supports dynamic updates of the stored ﬁle.
7. ACKNOWLEDGEMENTS
The authors would like to thank the anonymous reviewers for
their valuable feedback and comments. This work was partly sup-
ported by the EU FP7 SECCRIT project, funded by the European
Commission under grant agreement no. 312758.
8. REFERENCES
[1] Bitcoin real-time stats and tools.
http://blockexplorer.com/q.
[2] Cloud Computing: Cloud Security Concerns.
http://technet.microsoft.com/en-us/
magazine/hh536219.aspx.
[3] PBC Library. http://crypto.stanford.edu/pbc/,
2007.
[4] Jerasure.