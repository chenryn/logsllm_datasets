Thus, the engine ID can be considered a unique identifier of a
device: once it is generated, it is not recommended to change. While
we do not expect collisions when devices use MAC addresses for
engine ID, we acknowledge that they may use non-device unique
strings, be empty, or be ill-formatted. We address these issues via a
thorough filtering process in Section 4.
(Last reboot time, Engine boots) Tuple as a Unique Identifier:
As shown in Figure 3, the synchronization request also returns the
SNMP agent‚Äôs engine time and engine boots. The engine time is
the number of seconds since the last time the authoritative SNMP
engine has been ‚Äúbooted‚Äù. By subtracting the scan time we obtain
the last reboot time, i.e., the time and date at which the SNMP
engine was last rebooted. The engine boots value on the other hand
is the number of times the authoritative SNMP engine has restarted.
These values are included as part of the synchronization in order
to provide timeliness mechanisms, i.e., to prevent replay attacks
and to detect duplicate messages [56].
It is unlikely that two devices have exactly the same last reboot
time and engine boots. The only case that this occurs is if these
devices take an identical amount of time to boot, and were restarted
at exactly the same point in time, e.g., if they are co-located when
a power outage occurs. Although the combination of (last reboot
time, engine boots) is a slightly weaker unique identifier, it can
be used in combination with the engine ID to differentiate, e.g.,
devices with the same engine ID due to misconfiguration. We find
that more than 97% of all IPs provide (last reboot time, engine boots)
tuples belonging to a unique engine ID (cf. Appendix B).
3 METHODOLOGY
Conceptually, our methodology is straightforward. As depicted in
Figure 1, we send unsolicited UDP SNMPv3 synchronization packets
to IPv4 or IPv6 addresses without username or password credentials
(e.g., to IP ùê¥ in step 1). Note that we send well-formed, compliant
SNMPv3 packets. If the router with the target IP address is running
SNMPv3, it will return the engine ID, uptime, and boots meta-data as
part of the normal protocol synchronization (step 2). The meta-data
can frequently be used to identify the SNMPv3 implementation and
device vendor, for instance when it is formed from a MAC address
(in this example, the engine ID is 11:22:33:44:55:66).
This single packet exchange process repeats for all target IPv4
and IPv6 addresses in the scan campaign. If a probe to an IP address
returns the same unique identifier, then we have inferred an alias.
For example, in steps 3 and 4 of Figure 1, IP ùêµ returns the same
MAC address as received when ùê¥ was queried. Finally, by probing
both IPv4 and IPv6 addresses, we can discover dual-stack aliases,
and thus infer that IPv4 addresses ùê¥ and ùêµ are also aliases of IPv6
address ùê∂.
3.1 Using SNMPv3 Unique Identifiers
When both the engine ID and the (engine time, engine boots) tuple
are present in the response, we have two strong unique identifiers
that can be used to identify a single device. Further, we find that
in practice, we must employ a series of filters and tests to ensure
consistent and reliable inferences. We describe these filtering oper-
ations in Section 4.2.
By collecting this information from SNMPv3 responses, we can
perform a number of measurement tasks that otherwise would have
required extensive active probing, massive data analysis, complex
techniques, and would lack ‚Äúground truth‚Äù information. Further,
our technique is complementary to existing approaches, which
often cannot obtain a usable response from a target, such that it
increases overall inference coverage.
SNMPv3-based Alias Resolution: Router interface IPs that are
associated with the same unique identifier are mapped to the same
router.
SNMPv3-based Dual-stack Inference: Router interface IPs of
different protocols (IPv4 and IPv6) that are associated with the same
unique identifier are mapped to the same router.
SNMPv3-based Vendor Fingerprinting: The information con-
tained in the engine ID can be used to infer the vendor of the router.
Our confidence in the inference of device vendor is highest when
the engine ID is generated using a MAC address, as the upper three
bytes encode the IEEE Organizational Unique Identifier (OUI), i.e.,
the company that registered a particular block of MAC addresses.
Nevertheless, useful information about the vendor can be retrieved
if the engine ID is generated differently. The Enterprise ID, that
encodes the manufacturer of the device, is always present in the
SNMPv3 response if RFC 3411 is followed, and can provide more
confidence or be used as an alternative when the engine ID does
not unveil the vendor.
152
IMC ‚Äô21, November 2‚Äì4, 2021, Virtual Event, USA
Taha Albakour et al.
SNMPv3-based Uptime: In addition, the engine time value allows
us to determine the uptime of routers. This can be valuable informa-
tion in order to determine, e.g., the patch status of devices, network
reliability, and outage statistics.
3.2 SNMPv3 Active Scanning Campaigns
As there are no Internet-wide SNMPv3 scan results available, we
perform our own active scanning campaigns. We use ZMap [22] to
initiate SNMPv3 unsolicited synchronization requests by sending
an SNMPv3 payload to UDP port 161. During the scans, we capture
all SNMPv3 synchronization replies. We perform our IPv4 probing
from a single server in a well-connected European data center and
send at a rate of 5 kpps. For IPv6 we probe from a server located in
a research network at a rate of 20 kpps.
3.3 Ethical Considerations
In designing our active scanning, we endeavored to minimize any
potential ethical implications or harm from our study. First, the
packets we send are not only well-formed and conforming to the
SNMPv3 protocol, they are ‚Äúnormal‚Äù packets that any SNMP agent
would expect in the course of its operation. Our randomized prob-
ing spreads the load and each IP receives at most one SNMP packet.
Thus, we have no reason to believe that our packets would im-
pair SNMP agents. Our probes are connectionless UDP packets,
which are generally more innocuous as compared to TCP packets,
and greatly reduce the potential for unintended issues related to
maintaining state, e.g., by firewalls or middleboxes. Second, we
coordinated with our local network administrators to ensure that
our scanning did not harm the local or upstream network.
Next, we follow active scanning best practices [20, 22, 47] and
ensure that our prober‚Äôs IP address has a meaningful DNS PTR
record, and we run a web server with experiment and opt-out in-
formation. To date, we have not received any complaints or opt-out
requests. This is in striking contrast to other active scan campaigns
performed in the past, e.g., TLS scanning and Web port scanning,
which received complaints from the target IP owners and system ad-
ministrators of the data centers hosting the scanning infrastructure.
We observe that some scanning targets reply with a large number
of responses (cf. Section 8). Finally, our work uncovers potentially
sensitive security, robustness, and business information about net-
work providers. We therefore aggregate and anonymize our results
so as to not identify any individual network. We publish regularly
updated graphs of aggregated results at https://snmpv3.io.
3.4 Limitations
While our technique provides a new method for fingerprinting and
alias resolution, as well as affording novel insights into operational
network deployments, we do note several limitations of our method
and study.
First, in this work, we limit our study to network routers in order
to provide meaningful comparisons with existing topology datasets
and alias resolution methods. However, in our Internet-wide IPv4
and IPv6 scans we obtain a large number of responses from SNMP
agents that cannot be matched to known router alias sets. These
responses may represent routers missing in CAIDA or RIPE topolo-
gies, or may be servers, Customer Premise Equipment (CPE), or
other devices, e.g., IoT. In future work, we plan to investigate these
responses and devices in more detail.
Second, a deployed router may not be configured to enable SN-
MPv3, or may block outside queries by IP-level or other access
control mechanisms. In such instances, our technique naturally
cannot provide any vendor or alias inferences. However, because
it uses a distinct and previously unused identifier, our method is
complementary to existing approaches.
Third, while we seek to measure core network routers, our data
can capture edge and periphery devices, especially in IPv6 where
residential devices are a routed hop [49]. In such cases, the IP
address of these devices can change on time-scales shorter than our
scans [23, 50], causing different engine IDs to be returned from the
same IP address. While we filter these instances of inconsistency
from our data, we plan to investigate this effect in more detail in
future work.
4 SCANNING FOR SNMPV3 DEVICES
SNMP has been a popular protocol for decades and, thus, has been
the subject of many measurement studies [3, 19, 33, 37]. However,
this prior measurement work targets SNMPv2. In addition, Cen-
sys [14] and Shadowserver [53] report regular Internet-wide scan-
ning results, but solely for SNMPv2. Moreover, compared to our
SNMPv3 measurements both services report substantially lower
responsive IPv4 addresses, with 1.6M for Censys and 1.2M for Shad-
owserver, respectively.
4.1 Active Scan Targets
We perform active scans for SNMPv3 in IPv4 as well as IPv6. Table 1
shows an overview of our measurements. In addition to our own
measurements, we utilize multiple third-party datasets containing
known router IP addresses and aliases as shown in Table 2.
IPv4 & IPv6 SNMPv3 Scans. We launch two Internet-wide
4.1.1
SNMPv3 campaigns for the IPv4 protocol in April 2021. By em-
ploying two measurements instead of a single one, we can filter
out ephemeral addresses (cf. Section 4.4). We target all ~2.9 Billion
routable IPv4 addresses. We receive valid SNMPv3 responses from
about 31M IPv4 addresses. For each IPv4 address, we send one
packet with size 88 bytes. For the large majority of responses, we
receive one packet1 with an average size of 130 bytes.
For IPv6, we target ~364M addresses in non-aliased IPv6 prefixes
[23] of the IPv6 Hitlist Service [24]. We run two consecutive scans
on April 13 and 14, 2021. In contrast to IPv4 we receive only about
180k SNMPv3 responses from these IPv6 scans. For each IPv6 ad-
dress, we send one packet with size 108 bytes and receive a response
of on average 150 bytes.
4.1.2 Router Interface Tagging. To annotate IP addresses belong-
ing to router interfaces, we use publicly available datasets, namely
CAIDA‚Äôs ITDK [6] and intermediate hop IPs extracted from RIPE
Atlas traceroute measurements [44] for IPv4 and IPv6. The ITDK is
a curated dataset that also includes IPv4 router-level topologies, as
inferred by MIDAR [34] and IPv6 router-level topologies inferred
1We receive multiple packets for about 0.6% of the responding IPv4 addresses, see
Section 8 for a discussion.
153
Third Time‚Äôs Not a Charm: Exploiting SNMPv3 for Router Fingerprinting
IMC ‚Äô21, November 2‚Äì4, 2021, Virtual Event, USA
Measurement Date
IPv4 scan 1
IPv4 scan 2
IPv6 scan 1
IPv6 scan 2
Apr. 16‚Äì20, 2021
Apr. 22‚Äì27, 2021
Apr. 13, 2021
Apr. 14, 2021
#IPs
31.8M
31.5M
182k
180k
#Engine IDs
18.8M
18.6M
68k
67k
#IPs w/ valid engine ID #IPs w/ valid engine ID & engine time
} 12.5M
} 140k
} 27.0M
} 152k
Table 1: Overview of our SNMPv3 measurement campaigns: Number of unique SNMPv3-responsive IPs, number of unique
engine IDs, number of IPs with valid (i.e., consistent and non-filtered) engine ID, engine ID and engine time values, respectively.
Mar. 2021
Apr. 2021
2020‚Äì2021
IPv4 addrs. (SNMPv3)
2.9M (447k)
560k (85k)
n/a
3.1M (461k)
Router dataset Date
ITDK
RIPE Atlas
IPv6 Hitlist
Union
IPv6 addrs. (SNMPv3)
533k (36k)
260k (36k)
63.7M (54k)
65M (78k)
Table 2: Overview of router datasets: Number of unique
router IP addresses and coverage in our SNMPv3 measure-
ments for IPv4 and IPv6, respectively.
via the Speedtrap technique [38]. For IPv6 only we use router ad-
dresses obtained from the IPv6 Hitlist Service traceroutes [24]. In
Table 2 we show an overview of these router datasets as well as the