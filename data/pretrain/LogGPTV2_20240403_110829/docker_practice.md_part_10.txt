之后，可以 在Docker Hub 的 自动创建页面 中跟踪每次创建的状态。
115
Docker Hub
116
私有仓库
私有仓库
有时候使用 Docker Hub 这样的公共仓库可能不方便，用户可以创建一个本地仓库
供私人使用。
本节介绍如何使用本地仓库。
docker-registry 是官方提供的工具，可以用于构建私有的镜像仓库。
安装运行 docker-registry
容器运行
在安装了 Docker 后，可以通过获取官方 registry 镜像来运行。
$ sudo docker run -d -p 5000:5000 registry
这将使用官方的 registry 镜像来启动本地的私有仓库。 用户可以通过指定参数来配
置私有仓库位置，例如配置镜像存储到 Amazon S3 服务。
$ sudo docker run \
-e SETTINGS_FLAVOR=s3 \
-e AWS_BUCKET=acme-docker \
-e STORAGE_PATH=/registry \
-e AWS_KEY=AKIAHSHB43HS3J92MXZ \
-e AWS_SECRET=xdDowwlK7TJajV1Y7EoOZrmuPEJlHYcNP2k4j49T
\
-e SEARCH_BACKEND=sqlalchemy \
-p 5000:5000 \
registry
`
此外，还可以指定本地路径（如 /home/user/registry-conf ）下的配置文
件。
117
私有仓库
$ sudo docker run -d -p 5000:5000 -v /home/user/registry-conf:/r
egistry-conf -e DOCKER_REGISTRY_CONFIG=/registry-conf/config.yml
registry
默认情况下，仓库会被创建在容器的 /tmp/registry 下。可以通过 -v 参数来
将镜像文件存放在本地的指定路径。 例如下面的例子将上传的镜像放到
/opt/data/registry 目录。
$ sudo docker run -d -p 5000:5000 -v /opt/data/registry:/tmp/reg
istry registry
本地安装
对于 Ubuntu 或 CentOS 等发行版，可以直接通过源安装。
Ubuntu
$ sudo apt-get install -y build-essential python-dev libeven
t-dev python-pip liblzma-dev
$ sudo pip install docker-registry
CentOS
$ sudo yum install -y python-devel libevent-devel python-pip
gcc xz-devel
$ sudo python-pip install docker-registry
也可以从 docker-registry 项目下载源码进行安装。
$ sudo apt-get install build-essential python-dev libevent-dev p
ython-pip libssl-dev liblzma-dev libffi-dev
$ git clone https://github.com/docker/docker-registry.git
$ cd docker-registry
$ sudo python setup.py install
然后修改配置文件，主要修改 dev 模板段的 storage_path 到本地的存储仓库的
路径。
118
私有仓库
$ cp config/config_sample.yml config/config.yml
之后启动 Web 服务。
$ sudo gunicorn -c contrib/gunicorn.py docker_registry.wsgi:appl
ication
或者
$ sudo gunicorn --access-logfile - --error-logfile - -k gevent -
b 0.0.0.0:5000 -w 4 --max-requests 100 docker_registry.wsgi:appl
ication
此时使用 curl 访问本地的 5000 端口，看到输出 docker-registry 的版本信息说明运
行成功。
*注： config/config_sample.yml 文件是示例配置文件。
在私有仓库上传、下载、搜索镜像
创建好私有仓库之后，就可以使用 docker tag 来标记一个镜像，然后推送它到
仓库，别的机器上就可以下载下来了。例如私有仓库地址为
192.168.7.26:5000 。
先在本机查看已有的镜像。
$ sudo docker images
REPOSITORY TAG IMAGE ID
CREATED VIRTUAL SIZE
ubuntu latest ba5877dc9b
ec 6 weeks ago 192.7 MB
ubuntu 14.04 ba5877dc9b
ec 6 weeks ago 192.7 MB
119
私有仓库
使用 docker tag 将 ba58 这个镜像标记为 192.168.7.26:5000/test （格
式为 docker tag IMAGE[:TAG] [REGISTRYHOST/]
[USERNAME/]NAME[:TAG] ）。
$ sudo docker tag ba58 192.168.7.26:5000/test
root ~ # docker images
REPOSITORY TAG IMAGE ID
CREATED VIRTUAL SIZE
ubuntu 14.04 ba5877dc9b
ec 6 weeks ago 192.7 MB
ubuntu latest ba5877dc9b
ec 6 weeks ago 192.7 MB
192.168.7.26:5000/test latest ba5877dc9b
ec 6 weeks ago 192.7 MB
使用 docker push 上传标记的镜像。
$ sudo docker push 192.168.7.26:5000/test
The push refers to a repository [192.168.7.26:5000/test] (len: 1
)
Sending image list
Pushing repository 192.168.7.26:5000/test (1 tags)
Image 511136ea3c5a already pushed, skipping
Image 9bad880da3d2 already pushed, skipping
Image 25f11f5fb0cb already pushed, skipping
Image ebc34468f71d already pushed, skipping
Image 2318d26665ef already pushed, skipping
Image ba5877dc9bec already pushed, skipping
Pushing tag for rev [ba5877dc9bec] on {http://192.168.7.26:5000/
v1/repositories/test/tags/latest}
用 curl 查看仓库中的镜像。
120
私有仓库
$ curl http://192.168.7.26:5000/v1/search
{"num_results": 7, "query": "", "results": [{"description": "",
"name": "library/miaxis_j2ee"}, {"description": "", "name": "lib
rary/tomcat"}, {"description": "", "name": "library/ubuntu"}, {"
description": "", "name": "library/ubuntu_office"}, {"descriptio
n": "", "name": "library/desktop_ubu"}, {"description": "", "nam
e": "dockerfile/ubuntu"}, {"description": "", "name": "library/t
est"}]}
这里可以看到 {"description": "", "name": "library/test"} ，表明镜像已
经被成功上传了。
现在可以到另外一台机器去下载这个镜像。
$ sudo docker pull 192.168.7.26:5000/test
Pulling repository 192.168.7.26:5000/test
ba5877dc9bec: Download complete
511136ea3c5a: Download complete
9bad880da3d2: Download complete
25f11f5fb0cb: Download complete
ebc34468f71d: Download complete
2318d26665ef: Download complete
$ sudo docker images
REPOSITORY TAG IMAGE ID
CREATED VIRTUAL SIZE
192.168.7.26:5000/test latest ba5877dc9
bec 6 weeks ago 192.7 MB
可以使用 这个脚本 批量上传本地的镜像到注册服务器中，默认是本地注册服务器
127.0.0.1:5000 。例如：
121
私有仓库
$ wget https://github.com/yeasy/docker_practice/raw/master/_loca
l/push_images.sh; sudo chmod a+x push_images.sh
$ ./push_images.sh ubuntu:latest centos:centos7
The registry server is 127.0.0.1
Uploading ubuntu:latest...
The push refers to a repository [127.0.0.1:5000/ubuntu] (len: 1)
Sending image list
Pushing repository 127.0.0.1:5000/ubuntu (1 tags)
Image 511136ea3c5a already pushed, skipping
Image bfb8b5a2ad34 already pushed, skipping
Image c1f3bdbd8355 already pushed, skipping
Image 897578f527ae already pushed, skipping
Image 9387bcc9826e already pushed, skipping
Image 809ed259f845 already pushed, skipping
Image 96864a7d2df3 already pushed, skipping
Pushing tag for rev [96864a7d2df3] on {http://127.0.0.1:5000/v1/
repositories/ubuntu/tags/latest}
Untagged: 127.0.0.1:5000/ubuntu:latest
Done
Uploading centos:centos7...
The push refers to a repository [127.0.0.1:5000/centos] (len: 1)
Sending image list
Pushing repository 127.0.0.1:5000/centos (1 tags)
Image 511136ea3c5a already pushed, skipping
34e94e67e63a: Image successfully pushed
70214e5d0a90: Image successfully pushed
Pushing tag for rev [70214e5d0a90] on {http://127.0.0.1:5000/v1/
repositories/centos/tags/centos7}
Untagged: 127.0.0.1:5000/centos:centos7
Done
122
配置文件
仓库配置文件
Docker 的 Registry 利用配置文件提供了一些仓库的模板（flavor），用户可以直接
使用它们来进行开发或生产部署。
模板
在 config_sample.yml 文件中，可以看到一些现成的模板段：
common ：基础配置
local ：存储数据到本地文件系统
s3 ：存储数据到 AWS S3 中
dev ：使用 local 模板的基本配置
test ：单元测试使用
prod ：生产环境配置（基本上跟s3配置类似）
gcs ：存储数据到 Google 的云存储
swift ：存储数据到 OpenStack Swift 服务
glance ：存储数据到 OpenStack Glance 服务，本地文件系统为后备
glance-swift ：存储数据到 OpenStack Glance 服务，Swift 为后备
elliptics ：存储数据到 Elliptics key/value 存储
用户也可以添加自定义的模版段。
默认情况下使用的模板是 dev ，要使用某个模板作为默认值，可以添加
SETTINGS_FLAVOR 到环境变量中，例如
export SETTINGS_FLAVOR=dev
另外，配置文件中支持从环境变量中加载值，语法格式为
_env:VARIABLENAME[:DEFAULT] 。
示例配置
123
配置文件
common:
loglevel: info
search_backend: "_env:SEARCH_BACKEND:"
sqlalchemy_index_database:
"_env:SQLALCHEMY_INDEX_DATABASE:sqlite:////tmp/docker-re
gistry.db"
prod:
loglevel: warn
storage: s3
s3_access_key: _env:AWS_S3_ACCESS_KEY
s3_secret_key: _env:AWS_S3_SECRET_KEY
s3_bucket: _env:AWS_S3_BUCKET
boto_bucket: _env:AWS_S3_BUCKET
storage_path: /srv/docker
smtp_host: localhost
from_addr: PI:EMAIL
to_addr: PI:EMAIL
dev:
loglevel: debug
storage: local
storage_path: /home/myself/docker
test:
storage: local
storage_path: /tmp/tmpdockertmp
选项
124
数据管理
Docker 数据管理
这一章介绍如何在 Docker 内部以及容器之间管理数据，在容器中管理数据主要有
两种方式：
数据卷（Data volumes）
数据卷容器（Data volume containers）
125
数据卷
数据卷
数据卷是一个可供一个或多个容器使用的特殊目录，它绕过 UFS，可以提供很多有
用的特性：
数据卷可以在容器之间共享和重用
对数据卷的修改会立马生效
对数据卷的更新，不会影响镜像
数据卷默认会一直存在，即使容器被删除
*注意：数据卷的使用，类似于 Linux 下对目录或文件进行 mount，镜像中的被指定
为挂载点的目录中的文件会隐藏掉，能显示看的是挂载的数据卷。
创建一个数据卷
在用 docker run 命令的时候，使用 -v 标记来创建一个数据卷并挂载到容器
里。在一次 run 中多次使用可以挂载多个数据卷。
下面创建一个名为 web 的容器，并加载一个数据卷到容器的 /webapp 目录。
$ sudo docker run -d -P --name web -v /webapp training/webapp py
thon app.py
*注意：也可以在 Dockerfile 中使用 VOLUME 来添加一个或者多个新的卷到由该镜
像创建的任意容器。
删除数据卷
数据卷是被设计用来持久化数据的，它的生命周期独立于容器，Docker不会在容器
被删除后自动删除数据卷，并且也不存在垃圾回收这样的机制来处理没有任何容器
引用的数据卷。如果需要在删除容器的同时移除数据卷。可以在删除容器的时候使
用 docker rm -v 这个命令。无主的数据卷可能会占据很多空间，要清理会很麻
烦。Docker官方正在试图解决这个问题，相关工作的进度可以查看这个PR。
挂载一个主机目录作为数据卷
126
数据卷
使用 -v 标记也可以指定挂载一个本地主机的目录到容器中去。
$ sudo docker run -d -P --name web -v /src/webapp:/opt/webapp tr
aining/webapp python app.py
上面的命令加载主机的 /src/webapp 目录到容器的 /opt/webapp 目录。这个
功能在进行测试的时候十分方便，比如用户可以放置一些程序到本地目录中，来查
看容器是否正常工作。本地目录的路径必须是绝对路径，如果目录不存在 Docker
会自动为你创建它。
*注意：Dockerfile 中不支持这种用法，这是因为 Dockerfile 是为了移植和分享用
的。然而，不同操作系统的路径格式不一样，所以目前还不能支持。
Docker 挂载数据卷的默认权限是读写，用户也可以通过 :ro 指定为只读。