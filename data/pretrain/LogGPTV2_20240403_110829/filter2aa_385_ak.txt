3/shodan/cmd/shodan/main.go)
StartbyreadingyourAPIkeyfromtheSHODAN_API_KEY
environmentvariable❶.Thenusethatvaluetoinitializea
newClientstruct❷,s,subsequentlyusingittocallyourAPIInfo()
method❸.CalltheHostSearch()method,passinginasearch
stringcapturedasacommandlineargument❹.Finally,loop
throughtheresultstodisplaytheIPandportvaluesforthose
servicesmatchingthequerystring❺.Thefollowingoutput
showsasamplerun,searchingforthestringtomcat:
$SHODAN_API_KEY=YOUR-KEYgorunmain.gotomcat
QueryCredits:100
ScanCredits:100
185.23.138.1418081
218.103.124.2398080
123.59.14.1698081
177.6.80.2138181
142.165.84.16010000
--snip--
You’llwanttoadderrorhandlinganddatavalidationto
thisproject,butitservesasagoodexampleforfetchingand
displayingShodandatawithyournewAPI.Younowhavea
workingcodebasethatcanbeeasilyextendedtosupportand
testtheotherShodanfunctions.
INTERACTINGWITHMETASPLOIT
Metasploitisaframeworkusedtoperformavarietyof
adversarialtechniques,includingreconnaissance,exploitation,
commandandcontrol,persistence,lateralnetworkmovement,
payloadcreationanddelivery,privilegeescalation,andmore.
Evenbetter,thecommunityversionoftheproductisfree,runs
onLinuxandmacOS,andisactivelymaintained.Essentialfor
anyadversarialengagement,Metasploitisafundamentaltool
usedbypenetrationtesters,anditexposesaremoteprocedure
call(RPC)APItoallowremoteinteractionwithits
functionality.
Inthissection,you’llbuildaclientthatinteractswitha
remoteMetasploitinstance.MuchliketheShodancodeyou
built,theMetasploitclientyoudevelopwon’tcovera
comprehensiveimplementationofallavailablefunctionality.
Rather,itwillbethefoundationuponwhichyoucanextend
additionalfunctionalityasneeded.Wethinkyou’llfindthe
implementationmorecomplexthantheShodanexample,
makingtheMetasploitinteractionamorechallenging
progression.
SettingUpYourEnvironment
Beforeyouproceedwiththissection,downloadandinstallthe
Metasploitcommunityeditionifyoudon’talreadyhaveit.
StarttheMetasploitconsoleaswellastheRPClistener
throughthemsgrpcmoduleinMetasploit.Thensettheserver
host—theIPonwhichtheRPCserverwilllisten—anda
password,asshowninListing3-12.
$msfconsole
msf>loadmsgrpcPass=s3cr3tServerHost=10.0.1.6
[*]MSGRPCService:10.0.1.6:55552
[*]MSGRPCUsername:msf
[*]MSGRPCPassword:s3cr3t
[*]Successfullyloadedplugin:msgrpc
Listing3-12:StartingMetasploitandthemsgrpcserver
Tomakethecodemoreportableandavoidhardcoding
values,setthefollowingenvironmentvariablestothevalues
youdefinedforyourRPCinstance.Thisissimilartowhatyou
didfortheShodanAPIkeyusedtointeractwithShodanin
“CreatingaClient”onpage58.
$exportMSFHOST=10.0.1.6:55552
$exportMSFPASS=s3cr3t
YoushouldnowhaveMetasploitandtheRPCserver
running.
BecausethedetailsonexploitationandMetasploituseare
beyondthescopeofthisbook, let’sassumethatthroughpure
cunningandtrickeryyou’vealreadycompromisedaremote
Windowssystemandyou’veleveragedMetasploit’s
Meterpreterpayloadforadvancedpost-exploitationactivities.
Here,youreffortswillinsteadfocusonhowyoucanremotely
communicatewithMetasploittolistandinteractwith
establishedMeterpretersessions.Aswementionedbefore,this
codeisabitmorecumbersome,sowe’llpurposelypareit
backtothebareminimum—justenoughforyoutotakethe
codeandextenditforyourspecificneeds.
FollowthesameprojectroadmapastheShodanexample:
reviewtheMetasploitAPI,layouttheprojectinlibrary
format,definedatatypes,implementclientAPIfunctions,and,
finally,buildatestrigthatusesthelibrary.
First,reviewtheMetasploitAPIdeveloperdocumentation
atRapid7’sofficialwebsite
(https://metasploit.help.rapid7.com/docs/rpc-api/).The
functionalityexposedisextensive,allowingyoutodojust
aboutanythingremotelythatyoucouldthroughlocal
interaction.UnlikeShodan,whichusesJSON,Metasploit
communicatesusingMessagePack,acompactandefficient
binaryformat.BecauseGodoesn’tcontainastandard
MessagePackpackage,you’lluseafull-featuredcommunity
1
implementation.Installitbyexecutingthefollowingfromthe
commandline:
$gogetgopkg.in/vmihailenco/msgpack.v2
Inthecode,you’llrefertotheimplementationasmsgpack.
Don’tworrytoomuchaboutthedetailsoftheMessagePack
spec.You’llseeshortlythatyou’llneedtoknowverylittle
aboutMessagePackitselftobuildaworkingclient.Goisgreat
becauseithidesalotofthesedetails,allowingyoutoinstead
focusonbusinesslogic.Whatyouneedtoknowarethebasics
ofannotatingyourtypedefinitionsinordertomakethem
“MessagePack-friendly.”Beyondthat,thecodetoinitiate
encodinganddecodingisidenticaltootherformats,suchas
JSONandXML.
Next,createyourdirectorystructure.Forthisexample,you
useonlytwoGofiles:
$treegithub.com/blackhat-go/bhg/ch-3/metasploit-minimal
github.com/blackhat-go/bhg/ch-3/metasploit-minimal
|---client
||---main.go
|---rpc
|---msf.go
Themsf.gofileresideswithintherpcpackage,andyou’ll
useclient/main.gotoimplementandtestthelibraryyoubuild.
DefiningYourObjective
Now,youneedtodefineyourobjective.Forthesakeof
brevity,implementthecodetointeractandissueanRPCcall
thatretrievesalistingofcurrentMeterpretersessions—thatis,
thesession.listmethodfromtheMetasploitdeveloper
documentation.Therequestformatisdefinedasfollows:
["session.list","token"]
Thisisminimal;itexpectstoreceivethenameofthe
methodtoimplementandatoken.Thetokenvalueisa
placeholder.Ifyoureadthroughthedocumentation,you’ll
findthatthisisanauthenticationtoken,issueduponsuccessful
logintotheRPCserver.Theresponsereturnedfrom
Metasploitforthesession.listmethodfollowsthisformat:
{
"1"=>{
'type'=>"shell",
"tunnel_local"=>"192.168.35.149:44444",
"tunnel_peer"=>"192.168.35.149:43886",
"via_exploit"=>"exploit/multi/handler",
"via_payload"=>"payload/windows/shell_reverse_tcp",
"desc"=>"Commandshell",
"info"=>"",
"workspace"=>"Project1",
"target_host"=>"",
"username"=>"root",
"uuid"=>"hjahs9kw",
"exploit_uuid"=>"gcprpj2a",
"routes"=>[]
}
}
Thisresponseisreturnedasamap:theMeterpretersession
identifiersarethekeys,andthesessiondetailisthevalue.
Let’sbuildtheGotypestohandleboththerequestand
responsedata.Listing3-13definesthesessionListReqand
SessionListRes.
❶typesessionListReqstruct{
❷_msgpackstruct{}`msgpack:",asArray"`
Methodstring
Tokenstring
}
❸typeSessionListResstruct{
IDuint32`msgpack:",omitempty"`❹
Typestring`msgpack:"type"`
TunnelLocalstring`msgpack:"tunnel_local"`
TunnelPeerstring`msgpack:"tunnel_peer"`
ViaExploitstring`msgpack:"via_exploit"`
ViaPayloadstring`msgpack:"via_payload"`
Descriptionstring`msgpack:"desc"`
Infostring`msgpack:"info"`
Workspacestring`msgpack:"workspace"`
SessionHoststring`msgpack"session_host"`
SessionPortint`msgpack"session_port"`
Usernamestring`msgpack:"username"`
UUIDstring`msgpack:"uuid"`
ExploitUUIDstring`msgpack:"exploit_uuid"`
}
Listing3-13:Metasploitsessionlisttypedefinitions(/ch-3/metasploit-
minimal/rpc/msf.go)
Youusetherequesttype,sessionListReq❶,toserialize
structureddatatotheMessagePackformatinamanner
consistentwithwhattheMetasploitRPCserverexpects—
specifically,withamethodnameandtokenvalue.Noticethat
therearen’tanydescriptorsforthosefields.Thedataispassed
asanarray,notamap,soratherthanexpectingdatain
key/valueformat,theRPCinterfaceexpectsthedataasa
positionalarrayofvalues.Thisiswhyyouomitannotations
forthoseproperties—noneedtodefinethekeynames.
However,bydefault,astructurewillbeencodedasamapwith
thekeynamesdeducedfromthepropertynames.Todisable
thisandforcetheencodingasapositionalarray,youadda
specialfieldnamed_msgpackthatutilizestheasArraydescriptor
❷,toexplicitlyinstructanencoder/decodertotreatthedataas
anarray.
TheSessionListRestype❸containsaone-to-onemapping
betweenresponsefieldandstructproperties.Thedata,as
shownintheprecedingexampleresponse,isessentiallya
nestedmap.Theoutermapisthesessionidentifiertosession
details,whiletheinnermapisthesessiondetails,represented
askey/valuepairs.Unliketherequest,theresponseisn’t
structuredasapositionalarray,buteachofthestruct
propertiesusesdescriptorstoexplicitlynameandmapthedata
toandfromMetasploit’srepresentation.Thecodeincludesthe
sessionidentifierasapropertyonthestruct.However,because
theactualvalueoftheidentifieristhekeyvalue,thiswillbe
populatedinaslightlydifferentmanner,soyouincludethe
omitemptydescriptor❹tomakethedataoptionalsothatit
doesn’timpactencodingordecoding.Thisflattensthedataso
youdon’thavetoworkwithnestedmaps.
RetrievingaValidToken
Now,youhaveonlyonethingoutstanding.Youhaveto
retrieveavalidtokenvaluetouseforthatrequest.Todoso,
you’llissuealoginrequestfortheauth.login()APImethod,
whichexpectsthefollowing:
["auth.login","username","password"]
Youneedtoreplacetheusernameandpasswordvalueswith
whatyouusedwhenloadingthemsfrpcmoduleinMetasploit
duringinitialsetup(recallthatyousetthemasenvironment
variables).Assumingauthenticationissuccessful,theserver
respondswiththefollowingmessage,whichcontainsan
authenticationtokenyoucanuseforsubsequentrequests.
{"result"=>"success","token"=>"a1a1a1a1a1a1a1a1"}
Anauthenticationfailureproducesthefollowingresponse:
{
"error"=>true,
"error_class"=>"Msf::RPC::Exception",
"error_message"=>"InvalidUserIDorPassword"
}
Forgoodmeasure,let’salsocreatefunctionalitytoexpire
thetokenbyloggingout.Therequesttakesthemethodname,
theauthenticationtoken,andathirdoptionalparameterthat
you’llignorebecauseit’sunnecessaryforthisscenario:
["auth.logout","token","logoutToken"]
Asuccessfulresponselookslikethis:
{"result"=>"success"}
DefiningRequestandResponseMethods
MuchasyoustructuredtheGotypesforthesession.list()
method’srequestandresponse,youneedtodothesamefor
bothauth.login()andauth.logout()(seeListing3-14).Thesame
reasoningappliesasbefore,usingdescriptorstoforcerequests
tobeserializedasarraysandfortheresponsestobetreatedas
maps:
typeloginReqstruct{
_msgpackstruct{}`msgpack:",asArray"`
Methodstring
Usernamestring
Passwordstring
}
typeloginResstruct{
Resultstring`msgpack:"result"`
Tokenstring`msgpack:"token"`
Errorbool`msgpack:"error"`
ErrorClassstring`msgpack:"error_class"`
ErrorMessagestring`msgpack:"error_message"`
}
typelogoutReqstruct{
_msgpackstruct{}`msgpack:",asArray"`
Methodstring
Tokenstring
LogoutTokenstring
}
typelogoutResstruct{
Resultstring`msgpack:"result"`
}
Listing3-14:LoginandlogoutMetasploittypedefinition(/ch-3/metasploit-
minimal/rpc/msf.go)
It’sworthnotingthatGodynamicallyserializesthelogin
response,populatingonlythefieldspresent,whichmeansyou
canrepresentbothsuccessfulandfailedloginsbyusinga
singlestructformat.
CreatingaConfigurationStructandanRPC
Method
InListing3-15,youtakethedefinedtypesandactuallyuse
them,creatingthenecessarymethodstoissueRPCcommands
toMetasploit.MuchasintheShodanexample,youalsodefine
anarbitrarytypeformaintainingpertinentconfigurationand
authenticationinformation.Thatway,youwon’thaveto
explicitlyandrepeatedlypassincommonelementssuchas
host,port,andauthenticationtoken.Instead,you’llusethe
typeandbuildmethodsonitsothatdataisimplicitly
available.
typeMetasploitstruct{
hoststring
userstring
passstring
tokenstring
}
funcNew(host,user,passstring)*Metasploit{
msf:=&Metasploit{
host:host,
user:user,
pass:pass,
}
returnmsf
}
Listing3-15:Metasploitclientdefinition(/ch-3/metasploit-minimal/rpc/msf.go)
Nowyouhaveastructand,forconvenience,afunction
namedNew()thatinitializesandreturnsanewstruct.
PerformingRemoteCalls
YoucannowbuildmethodsonyourMetasploittypeinorderto
performtheremotecalls.Topreventextensivecode
duplication,inListing3-16,youstartbybuildingamethod
thatperformstheserialization,deserialization,andHTTP
communicationlogic.Thenyouwon’thavetoincludethis
logicineveryRPCfunctionyoubuild.
func(msf*Metasploit)send(reqinterface{},resinterface{})❶error{
buf:=new(bytes.Buffer)
❷msgpack.NewEncoder(buf).Encode(req)
❸dest:=fmt.Sprintf("http://%s/api",msf.host)
r,err:=http.Post(dest,"binary/message-pack",buf)❹
iferr!=nil{
returnerr
}
deferr.Body.Close()
iferr:=msgpack.NewDecoder(r.Body).Decode(&res)❺;err!=nil{
returnerr
}
returnnil
}
Listing3-16:Genericsend()methodwithreusableserializationanddeserialization
(/ch-3/metasploit-minimal/rpc/msf.go)
Thesend()methodreceivesrequestandresponseparameters
oftypeinterface{}❶.Usingthisinterfacetypeallowsyouto
passanyrequeststructintothemethod,andsubsequently
serializeandsendtherequesttotheserver.Ratherthan
explicitlyreturningtheresponse,you’llusetheresinterface{}
parametertopopulateitsdatabywritingadecodedHTTP
responsetoitslocationinmemory.
Next,usethemsgpacklibrarytoencodetherequest❷.The
logictodothismatchesthatofotherstandard,structureddata
types:firstcreateanencoderviaNewEncoder()andthencallthe
Encode()method.Thispopulatesthebufvariablewith
MessagePack-encodedrepresentationoftherequeststruct.
Followingtheencoding,youbuildthedestinationURLby
usingthedatawithintheMetasploitreceiver,msf❸.Youusethat
URLandissueaPOSTrequest,explicitlysettingthecontent
typetobinary/message-packandsettingthebodytotheserialized
data❹.Finally,youdecodetheresponsebody❺.Asalluded
toearlier,thedecodeddataiswrittentothememorylocation
oftheresponseinterfacethatwaspassedintothemethod.The
encodinganddecodingofdataisdonewithouteverneedingto
explicitlyknowtherequestorresponsestructtypes,making
thisaflexible,reusablemethod.
InListing3-17,youcanseethemeatofthelogicinallits
glory.
func(msf*Metasploit)Login()❶error{
ctx:=&loginReq{
Method:"auth.login",
Username:msf.user,
Password:msf.pass,
}
varresloginRes
iferr:=msf.send(ctx,&res)❷;err!=nil{
returnerr
}
msf.token=res.Token
returnnil
}
func(msf*Metasploit)Logout()❸error{
ctx:=&logoutReq{
Method:"auth.logout",
Token:msf.token,
LogoutToken:msf.token,
}
varreslogoutRes
iferr:=msf.send(ctx,&res)❹;err!=nil{
returnerr
}
msf.token=""
returnnil
}
func(msf*Metasploit)SessionList()❺(map[uint32]SessionListRes,error){
req:=&SessionListReq{Method:"session.list",Token:msf.token}
❻res:=make(map[uint32]SessionListRes)
iferr:=msf.send(req,&res)❼;err!=nil{
returnnil,err
}
❽forid,session:=rangeres{
session.ID=id
res[id]=session
}