---
author: ''
category: 技术
comments_data: []
count:
  commentnum: 0
  favtimes: 3
  likes: 3
  sharetimes: 0
  viewnum: 9943
date: '2013-11-11 22:19:00'
editorchoice: false
excerpt: "在这个第四部分里，我们将继续配置更多的设置和特性。\r\n\r\n这里我们被问及关于&quot;IBM Calgary IOMMU support
  (CALGARY_IOMMU)&quot;。这个选项将会提供对IBM xSeries x366和x460的IOMMU的支持。这也将让那些32位PCI的设备工作
  \ ..."
fromurl: ''
id: 2242
islctt: true
largepic: /data/attachment/album/201311/11/212246ngkdbnzgwskn5n3b.png
permalink: /article-2242-1.html
pic: /data/attachment/album/201311/11/212246ngkdbnzgwskn5n3b.png.thumb.jpg
related: []
reviewer: ''
selector: ''
summary: "在这个第四部分里，我们将继续配置更多的设置和特性。\r\n\r\n这里我们被问及关于&quot;IBM Calgary IOMMU support
  (CALGARY_IOMMU)&quot;。这个选项将会提供对IBM xSeries x366和x460的IOMMU的支持。这也将让那些32位PCI的设备工作
  \ ..."
tags:
- Linux
- 内核
- 配置
- IOMMU
- 技巧
- 教程
thumb: false
title: 戴文的Linux内核专题：08 配置内核(4)
titlepic: false
translator: geekpi
updated: '2013-11-11 22:19:00'
---
在这个第四部分里，我们将继续配置更多的设置和特性。
![](/data/attachment/album/201311/11/212246ngkdbnzgwskn5n3b.png)
这里我们被问及关于"IBM Calgary IOMMU support (CALGARY\_IOMMU)"。这个选项将会提供对IBM xSeries x366和x460的IOMMU的支持。这也将让那些32位PCI的设备工作正常——在这些系统上不支持双地址周期(DAC : Double Address Cycle)——因为该系统设置在访问超过3GB内存的时候会有问题。如果需要这些IOMMU设备可以用"iommu=off"在启动时关闭。(这些内核/模块参数会在以后的文章中讨论)
IOMMU(input/output memory management unit)是一个内存管理单元(MMU)，它连接具有DMA功能的I/O总线到主内存上。DMA(Direct Memory Access)是许多计算机支持的一种允许特定设备不借助CPU直接访问内存的特性。双地址周期(Double Address Cycle, DAC)是64位DMA；而通常的DMA使用32位。
下面，我们被问及是否默认启用Calgary(Should Calgary be enabled by default? (CALGARY\_IOMMU\_ENABLED\_BY\_DEFAULT))。Calgary与上面提到的IOMMU是同一个概念。这两者之间的不同是IOMMU可以支持许多设备而Calgary只能支持IBM IOMMU设备。如果禁用了它，但是以后需要使用到它，可以使用内核参数(iommu=calgary)。
这里有个问题需要小心处理(Enable Maximum number of SMP Processors and NUMA Nodes (MAXSMP))。只有在内核运行在拥有很多SMP处理器和NUMA节点的情况下才启用它，如Core i7和许多AMD CPU芯片。如果系统缺乏或者只有少量的SMP处理器和NUMA节点，内核就会变得低效。这个最好选择"No"。
非一致性内存访问(Non-Uniform Memory Access (NUMA))是一个每块内存都需要花费更长时间访问其他部分内存的系统。一个节点就是一组内存。例如，一个NUMA系统可能有三块内存芯片。每块芯片是一个节点，在带CPU的主板上有一个节点/芯片(这是最快的节点)，另外两个在不同的总线上。这两个节点需要比第一个节点花费更长的时间去访问。
注意：ccNUMA和NUMA目前是一样的，至少是非常相似的。
对称多处理器(Symmetric Multi-Processing (SMP))是NUMA的替代品。它的内存在同一根总线上。只有限定数量的CPU可以访问总线，所以这限制了SMP系统上处理器的数量。然而它内存的访问速度一样块。
注意：我是在为AMD64系统在编译内核，所以我会告诉你我的选择，来帮助读者理解过程和选择。如果我没有指出我的选择，那么我用的就是默认选择。如果你在为不同的系统编译或者你有不同的需求，你需要在你的情况下做出替代的选择。
接下来，除非配置工具已经为你做了选择，选择一个内核需要支持的最多CPU的数量。这个配置根据你给的数量优化内核。
接着启用或禁用"SMT (Hyperthreading) scheduler support (SCHED\_SMT)"（超线程调度器支持）。SMT调度器提升了在使用了超线程技术的Pentium 4处理器上的CPU决策能力。然而，这会带来额外的功耗，在一些系统上最好像我一样选择"no"。
超线程一种专有的SMT并行微处理器(Intel 实现了它)。这是多任务/多线程(同时做许多任务)的一种特殊形式，并行多线程(Simultaneous multithreading (SMT))提升了多线程执行的效率。
在这之后，启用或者禁用"Multi-core scheduler support (SCHED\_MC)"。这样也是一种提升多核CPU决策的特性。然而这回带来额外功耗，我选择了"No"。
在下一个选项中可以选择抢占模式。
Preemption Model（抢占模式）
1. No Forced Preemption (Server) (PREEMPT\_NONE) （非强制抢占）
> 2. Voluntary Kernel Preemption (Desktop) (PREEMPT\_VOLUNTARY) （自愿内核抢占）
3. Preemptible Kernel (Low-Latency Desktop) (PREEMPT) （可抢占内核）
choice[1-3]: 2
抢占就是暂停一个意图让它之后继续执行的中断任务的过程。抢占强制一个进程暂停，执行中的任务无法忽视抢占。
接着，我们被询问关于"Reroute for broken boot IRQs (X86\_REROUTE\_FOR\_BROKEN\_BOOT\_IRQS)"。这是一个对于假中断的简单修复。假中断是一种无用的硬件中断，这些通常是有电子干扰或者错误连接的电子产品触发。记住，中断是发送给处理器需要马上注意的信号。
这个选项对任何机器都很重要；我怀疑任何人可能都会有禁用这个特性的理由(Machine Check / overheating reporting (X86\_MCE))。内核必须意识到过热和数据损坏，不然，系统将会继续操作，这样只会导致进一步的破坏。
下面，用户可以启用禁用"Intel MCE features (X86\_MCE\_INTEL)"，这是一种额外的对像热度监控的Intel MCE特性的支持。因为我是为AMD64处理器编译内核所以我选择了"no"。机器检测异常(MCE)是一种当处理器发现硬件问题时的错误输出。MCE通常会导致内核严重错误(kernel panic)(相当于Windows中的"蓝屏")。
这个除了是AMD设备外是同一个问题Intel MCE features (X86\_MCE\_INTEL)。
下一个是我会禁用的调试特性(Machine check injector support (X86\_MCE\_INJECT))。这个会允许注射检查。如果你偶尔执行机器注射，那最好编译成模块而不是编译进内核。机器注射可以使设备即使实际没有错误也可以发送一个伪造的错误信息。这个用来确认内核和其他进程可以正常处理错误。比如，如果CPU过热，接着应该关机，但是开发者如何在不损坏CPU的情况下测试代码。注射错误是一种最好的方法，因为它只是一种告诉硬件发送错误信号的软件。
注:模块是对可能被使用或者很少执行的特性/驱动而言的。只加入在许多使用该内核的系统中用到的特性/驱动到内核中。
如果内核很可能用在Dell笔记本上，那么启用这个特性(Dell laptop support (I8K))。否则，如果一些用户可能在戴尔笔记本电脑上用到这个内核，将其作为一个模块加入。如果这个内核不打算支持Dell笔记本，那就像我一样忽略掉它。特别地，这个支持是一个允许Dell Inspiron 8000系列笔记本访问处理器的系统管理模式的驱动。系统管理模式的目的是得到处理器的温度和风扇状态，这对一些需要控制风扇的系统有用。
下面，用户可以选择微码加载支持(CPU microcode loading support (MICROCODE))。这可以允许用户在支持这个特性的AMD或者Intel芯片上更新微码。
注意：为了加载微码，你必须拥有一个为你的处理器设计的合法的二进制微代码拷贝。
如果要加载微码补丁(修复bug或加入次要的特性)到intel芯片上(Intel microcode loading support (MICROCODE\_INTEL))，这个就必须启用。这里我禁用了它。
然后是AMD芯片的类似选项(AMD microcode loading support (MICROCODE\_AMD))。
启用这个支持(/dev/cpu/\*/msr - Model-specific register support (X86\_MSR))可以允许某个处理器有权限使用x86特殊模块寄存器(Model-Specific Registers (MSRs))。这些寄存器是一些字符设备，包括major 202下minor 0到31的设备((/dev/cpu/0/msr to /dev/cpu/31/msr))。这个特性用在多处理器系统上。每个虚拟字符设备都连接到一个特定的CPU。