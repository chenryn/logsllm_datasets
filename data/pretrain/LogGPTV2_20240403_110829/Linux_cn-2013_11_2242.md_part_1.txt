### 戴文的Linux内核专题：08 配置内核(4)

#### 作者:  
#### 分类: 技术
#### 标签: Linux, 内核, 配置, IOMMU, 技巧, 教程
#### 发布日期: 2013-11-11 22:19:00
#### 更新日期: 2013-11-11 22:19:00
#### 翻译者: geekpi

---

在这个第四部分中，我们将继续配置更多的设置和特性。

![](/data/attachment/album/201311/11/212246ngkdbnzgwskn5n3b.png)

首先，我们被问及是否启用“IBM Calgary IOMMU支持 (CALGARY_IOMMU)”。这个选项提供了对IBM xSeries x366和x460服务器上的IOMMU的支持。这将使那些32位PCI设备在这些系统上正常工作，因为这些系统不支持双地址周期（DAC）。如果需要禁用这些IOMMU设备，可以在启动时使用`iommu=off`参数（这些内核/模块参数将在以后的文章中讨论）。

IOMMU（输入/输出内存管理单元）是一种连接具有DMA功能的I/O总线到主内存的内存管理单元。DMA（直接内存访问）是许多计算机支持的一种特性，允许特定设备直接访问内存而不借助CPU。双地址周期（Double Address Cycle, DAC）是64位DMA；而通常的DMA使用32位。

接下来，我们被问及是否默认启用Calgary（Should Calgary be enabled by default? (CALGARY_IOMMU_ENABLED_BY_DEFAULT)）。Calgary与上面提到的IOMMU是同一个概念，但IOMMU可以支持多种设备，而Calgary仅支持IBM IOMMU设备。如果禁用了它，但以后需要使用，可以使用内核参数`iommu=calgary`来启用。

随后，有一个问题需要小心处理：是否启用最大数量的SMP处理器和NUMA节点（MAXSMP）。只有当内核运行在拥有很多SMP处理器和NUMA节点的系统上时才应启用此选项，例如Core i7和许多AMD CPU芯片。如果系统缺乏或只有少量的SMP处理器和NUMA节点，内核可能会变得低效。因此，这里最好选择“No”。

非一致性内存访问（Non-Uniform Memory Access, NUMA）是指系统中的每块内存都需要花费更长时间访问其他部分内存。一个节点是一组内存。例如，一个NUMA系统可能有三块内存芯片。每块芯片是一个节点，在带CPU的主板上有一个节点/芯片（这是最快的节点），另外两个在不同的总线上。这两个节点需要比第一个节点花费更长的时间去访问。

注意：ccNUMA和NUMA目前是一样的，至少是非常相似的。

对称多处理器（Symmetric Multi-Processing, SMP）是NUMA的替代品。它的内存在同一根总线上。只有限定数量的CPU可以访问总线，所以这限制了SMP系统上处理器的数量。然而，它内存的访问速度一样快。

注意：我是在为AMD64系统编译内核，所以我会告诉你我的选择，以帮助读者理解过程和选择。如果我没有指出我的选择，那么我用的就是默认选择。如果你在为不同的系统编译或者你有不同的需求，你需要根据自己的情况做出选择。

接下来，除非配置工具已经为你做了选择，选择一个内核需要支持的最多CPU的数量。这个配置根据你给的数量优化内核。

接着，启用或禁用“SMT (Hyperthreading)调度器支持 (SCHED_SMT)”（超线程调度器支持）。SMT调度器提升了在使用了超线程技术的Pentium 4处理器上的CPU决策能力。然而，这会带来额外的功耗，在一些系统上最好像我一样选择“No”。

超线程是一种专有的SMT并行微处理器（Intel 实现了它）。这是多任务/多线程（同时做许多任务）的一种特殊形式，并行多线程（Simultaneous multithreading, SMT）提升了多线程执行的效率。

之后，启用或禁用“多核调度器支持 (SCHED_MC)”。这也是提升多核CPU决策的特性。然而，这会带来额外的功耗，我选择了“No”。

在下一个选项中可以选择抢占模式：

1. **无强制抢占 (Server) (PREEMPT_NONE)**：适用于服务器环境。
2. **自愿内核抢占 (Desktop) (PREEMPT_VOLUNTARY)**：适用于桌面环境。
3. **可抢占内核 (低延迟桌面) (PREEMPT)**：适用于低延迟桌面环境。

抢占就是暂停一个意图让它之后继续执行的中断任务的过程。抢占强制一个进程暂停，执行中的任务无法忽视抢占。

然后，我们被询问是否启用“修复损坏的启动IRQ (X86_REROUTE_FOR_BROKEN_BOOT_IRQS)”。这是一个简单的修复假中断的方法。假中断是一种无用的硬件中断，通常是由于电子干扰或错误连接触发的。记住，中断是发送给处理器需要立即处理的信号。

这个选项对任何机器都很重要；我怀疑任何人可能都会有禁用这个特性的理由（Machine Check / overheating reporting (X86_MCE)）。内核必须意识到过热和数据损坏，否则系统将继续操作，从而导致进一步的破坏。

接下来，用户可以启用或禁用“Intel MCE特性 (X86_MCE_INTEL)”，这是一种额外的对热度监控的Intel MCE特性的支持。因为我是在为AMD64处理器编译内核，所以我选择了“No”。机器检测异常（MCE）是一种当处理器发现硬件问题时的错误输出。MCE通常会导致内核严重错误（相当于Windows中的“蓝屏”）。

接下来的问题是关于调试特性“机器检查注入支持 (X86_MCE_INJECT)”。这个选项允许注入机器检查。如果你偶尔执行机器检查，最好将其编译成模块而不是编译进内核。机器检查可以使设备即使实际没有错误也能发送伪造的错误信息，用于测试代码。例如，如果CPU过热，应该关机，但开发者如何在不损坏CPU的情况下测试代码？注入错误是一种最好的方法，因为它只是告诉硬件发送错误信号的软件。

注：模块是对可能被使用或很少执行的特性/驱动而言的。只加入在许多使用该内核的系统中用到的特性/驱动到内核中。

如果内核很可能用在Dell笔记本上，那么启用这个特性“Dell笔记本支持 (I8K)”。否则，如果一些用户可能在戴尔笔记本电脑上用到这个内核，将其作为一个模块加入。如果这个内核不打算支持Dell笔记本，那就像我一样忽略掉它。特别地，这个支持是一个允许Dell Inspiron 8000系列笔记本访问处理器的系统管理模式的驱动。系统管理模式的目的是获取处理器的温度和风扇状态，这对一些需要控制风扇的系统有用。

接下来，用户可以选择微码加载支持“CPU微码加载支持 (MICROCODE)”。这可以允许用户在支持这个特性的AMD或Intel芯片上更新微码。

注意：为了加载微码，你必须拥有一个为你的处理器设计的合法的二进制微代码拷贝。

如果要加载微码补丁（修复bug或添加次要特性）到Intel芯片上，“Intel微码加载支持 (MICROCODE_INTEL)”就必须启用。这里我禁用了它。

然后是类似的选项“AMD微码加载支持 (MICROCODE_AMD)”。

启用这个支持“/dev/cpu/*/msr - 特定于模型的寄存器支持 (X86_MSR)”可以允许某个处理器有权限使用x86特定于模型的寄存器（Model-Specific Registers, MSRs）。这些寄存器是一些字符设备，包括major 202下minor 0到31的设备（/dev/cpu/0/msr 到 /dev/cpu/31/msr）。这个特性用于多处理器系统。每个虚拟字符设备都连接到一个特定的CPU。

通过以上配置，我们可以确保内核在各种硬件平台上都能高效且稳定地运行。希望这些步骤能帮助你在配置内核时做出正确的选择。