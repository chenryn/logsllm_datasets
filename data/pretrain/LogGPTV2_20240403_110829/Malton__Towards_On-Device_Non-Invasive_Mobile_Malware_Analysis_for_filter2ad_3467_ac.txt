Write a value to memory.
Ist Store
Ist StoreG Write a value to memory with guard.
Ist Dirty
Call a C function.
information in the upper layers, such as the method invo-
cations for identifying the information ﬂow, etc.
To propagate taint tags across different layers, Malton
works at the instruction layer because the codes of all
upper layers become ARM instructions during execution.
Since these ARM instructions will be translated into IR s-
tatements [53], Malton performs taint propagation on IR
statements with byte precision by inserting helper func-
tions before selected IR statements.
Table 3: Taint propagation related IR expressions.
IR Expression
Iex Const
Iex RdTmp
Iex ITE
Iex Get
Iex GetI
Iex Unop
Iex Binop
Iex Triop
Iex Qop
Iex Load
Iex CCall
Representation
A constant-valued expression.
The value held by a VEX temporary.
A ternary if-then-else operation.
Get the value held by a guest register at a ﬁxed offset.
Get the value held by a guest register at a non-ﬁxed offset.
A unary operation.
A binary operation.
A ternary operation.
A quaternary operation.
Load the value stored in memory.
A call to a pure (no side-effects) helper C function.
For Malton, there are 9 types IR statements related to
the taint propagation, which are listed in Table 2. For
the Ist WrTmp statement, since the source value may be
the result of an IR expression, we also need to parse the
logic of the IR expression for taint propagation. The IR
expressions that can affect the taint propagation are sum-
marized in Table 3. During the execution of the target ap-
p, Malton parses the IR statements and expressions in the
helper functions, and propagates the taint tags according
to the logic of the IR statements and expressions.
Malton supports taint sources/sinks in different layers
(i.e., the framework layer and the system layer). For ex-
ample, Malton can take the arguments and results of both
Java methods and C/C++ methods as the taint sources,
and check the taint tags of the arguments and the result-
s of sink methods. By default, at the framework layer,
11 types of information are speciﬁed as taint sources,
including device information (i.e., IMSI, IMEI, SN and
phone number), location information (i.e., GPS location,
network location and last seen location) and personal
information (i.e., SMS, MMS, contacts and call logs).
Malton also checks the taint tags of the arguments and
results when each framework method is invoked. In the
system layer, Malton takes system calls sys write() and
294    26th USENIX Security Symposium
USENIX Association
sys sendto() as taint sinks by default, because the sensi-
tive information is usually stored to ﬁles or leaked out of
the device through these system calls. As malware can
receive commands from network, Malton takes system
call sys recvfrom() as the taint source by default. Note that
Malton can be easily extended to support other method-
s as taint sources and sinks in both the framework layer
and the system layer.
Instruction Layer: Path Exploration
3.6
Advanced malware samples usually execute malicious
payloads according to the commands received from the
C&C server or the special context (e.g., date, locations,
etc.). To trigger as many malicious behaviors as possi-
ble for analysis, Malton employs the efﬁcient path ex-
ploration technique, which consists of taint analysis, in-
memory concolic execution with an ofﬂoading mecha-
nism, and direct execution engine. Speciﬁcally, tain-
t analysis helps the analyst identify the code paths de-
pending on the inputs, such as network commands, and
the concolic execution module can generate the required
inputs to explore the interested code paths. When the
inputs cannot be generated, we rely on the direct exe-
cution engine to forcibly execute certain code paths. S-
ince concolic execution [27] is a well-known technique
in the community, we will not introduce it in the fol-
lowing. Instead, we detail the ofﬂoading mechanism and
the in-memory optimization used in the concolic execu-
tion module, and explain how the direct execution engine
works.
Concolic Execution: Ofﬂoading Mechanism It is non-
trivial to apply concolic execution in analyzing Android
malware on real devices, because concolic execution re-
quires considerable computational resources, resulting in
unacceptable overhead on the mobile devices. To allevi-
ate this limitation, Malton utilizes an ofﬂoading mech-
anism that moves the task of solving constraints to the
resourceful desktop computers, and then sends back the
satisfying results to the mobile devices as inputs. Our
approach is motivated by the fact that the time consump-
tion for solving constraints occupies the overall runtime
of concolic execution. For example, the percentage of
time used to solve constraints is nearly 41% of the KLEE
system, even after optimizations [25].
More precisely, when the malware sample is running
in our system, Malton redirects all the constraints to
the logcat messages [4], which could be retrieved by
the desktop computer using the ADB (Android Debug
Bridge) tool. Then, the constraint solver, which is im-
plemented based on Z3 [33], generates the satisfying in-
puts and feeds the inputs back to Malton through a ﬁle.
Since we may have multiple code paths that need to be
explored, this process could be repeated several times un-
til the constraint solver pushes an empty input ﬁle to the
device for notifying Malton to ﬁnish path exploring.
Concolic Execution: In-memory Optimization To
speed up the analysis, especially when there are multiple
execution paths, each of which depends on the special in-
put, we propose in-memory optimization to restrict con-
colic execution within the interested code region speci-
ﬁed by the analyst without repeatably running from the
beginning of the program. By default, the analyst is re-
quired to specify the arguments or variables as the input
of the concolic execution, which will be represented as
symbolic values during concolic execution. For exam-
ple, the analyst can select the SMS content acquired from
the method getMessageBody() (Line 37 in Listing 1) as the
input. Moreover, the analyst can select the IR statement
that lets the input have concrete values as the entry point
of the code region, and choose the exit statement (i.e.,
Ist Exit) or the next statement (i.e., Ist Next) of the
subroutine as the exit point of the code region.
Malton runs the malware sample until the exit point of
the interested code region for collecting constraints and
generating new inputs for different code paths through
an SMT solver. Then, it forces the execution to return
to the entry point of the code region through modifying
the program counter and feeds the inputs by writing the
new inputs directly into the corresponding locations (i.e.,
memories or registers). Moreover, Malton needs to re-
cover the execution context and the memory state at the
entry point of the code region.
the ﬁrst
To recover the execution context, Malton conduct-
s instrumentation at the beginning of the code region,
and inserts a helper function to save the execution con-
text (i.e., register states at
iteration). Af-
ter that, the saved register states will be recovered in
the later iterations. As Valgrind uses the structure
VexGuestArchState to represent the register states,
we save and recover the register states by reading and
writing the VexGuestArchState data in the memory.
To recover the memory states, Malton replaces the
system’s memory allocation/free functions with our cus-
tomized implementations to monitor all the memory al-
location/free operations. Malton can also free the allo-
cated memory or re-allocate the freed memory. Besides,
Malton inserts a helper function before each memory
store (i.e., Ist Store and Ist StoreG) statement to
track the memory modiﬁcations, so that all the modiﬁed
memory could be restored.
Alternatively, the analyst can choose the target code
region according to the method call graph, or ﬁrst use
static analysis tool to identify code paths and then select
a portion of the path as the interested code region.
Direct Execution The concolic execution may not be
able to explore all the code paths of the interested code
region, because the constraint solver may not ﬁnd satis-
USENIX Association
26th USENIX Security Symposium    295
fying inputs for complex constraints, such as ﬂoat-point
operations and encryption routines. For the condition-
al branches with unresolved constraints, Malton has the
capability to directly execute certain code paths.
The direct execution engine of Malton is implement-
ed through two techniques: a) modifying the arguments
and the results of methods, including library functions,
system calls and Java methods; b) setting the guard value
of the conditional exit statement (i.e., Ist Exit). The
guard value is the expression used in the Ist Exit state-
ment to determine whether the branch should be taken.
It’s straightforward to modify arguments and the re-
turn values of library functions and system calls by lever-
aging Valgrind APIs. However, it’s challenging to deal
with the Java methods because there is no interface in
Valgrind to wrap Java methods. Fortunately, we have ob-
tained the entry point and exit points of the compiled Java
method in the framework layer (Section 3.2). Hence, we
could wrap the Java method by adding instrumentation at
its entry point and exit points. For example, to change the
source telephone number of a received SMS to explore
certain code path (Line 41 in Listing 1), Malton can wrap
the framework API SmsMessage.getOriginatingAddress()
and modify its return value to a desired number at the
exit points.
To set the guard value of the Ist Exit statement, we
insert a helper function before each Ist Exit statement
and specify the guard value to the result of the helper
In an IR block, the program can only con-
function.
ventionally jump out of the IR block at the location of
the Ist Exit statement (e.g., an if-branch in the pro-
gram). The Ist Exit statement is deﬁned with the for-
mat “if(t) goto ” in Valgrind, where t and
dst represent the guard value and destination address,
respectively. By returning “1” or “0” in the helper func-
tion, we can let t satisfy or dissatisfy the condition for
exploring different code paths.
Table 4: Comparison of the capability of capturing the
sensitive behaviors of malware samples.
CopperDroid
435 (85.0%)
351 (68.5%)
438 (85.5%)
52 (10.1%)
26 (5.1%)
DroidBox
Malton
135 (26.4%)
511 (99.8%)
211 (41.2%)
445 (86.9%)
509 (99.4%)
512 (100%)
1 (0.2%)
59 (11.5%)
15 (2.9%)
28 (5.5%)
NA 509 (99.4%)
512 (100%)
NA
4 (0.8%)
NA 160 (31.2%)
4 (0.8%)
NA
Behavior
Personal Info
Network access
File access
Phone call
Send SMS
Java code loading
Anti-debugging
Native code loading
4 Evaluation
Q1: Can Malton capture more sensitive operations than
other systems?
Q2: Can Malton analyze sophisticated malware samples
(e.g., packed malware) to provide a comprehensive view
of malicious behaviors?
Q3: Is the path exploration mechanism effective and ef-
ﬁcient?
4.1 Sensitive Behavior Monitoring
To answer Q1, we compare Malton’s capability of cap-
turing sensitive behaviors with CopperDroid [73] and
DroidBox [34]. These two systems are implemented
by instrumenting Android emulator and modifying the
Android system, respectively. Since CopperDroid’s web-
site3 has just queued all our uploaded malware sam-
ples, we cannot obtain the corresponding analysis re-
sults. Therefore, we downloaded the analysis reports
of 1,362 malware samples that have been analyzed by
CopperDroid. According to their md5s, we collected 512
samples, and run them using Malton and DroidBox, re-
spectively. The comparison results are listed in Table 4.
The ﬁrst column shows the type of sensitive behaviors,
and the following columns list the numbers and percent-
ages of malware samples that have been detected by each
system due to the corresponding sensitive behaviors . We
can see that for all the sensitive behaviors Malton detect-
ed more samples than the other two systems.
We further manually analyze the malware samples
to understand why Malton detects more sensitive be-
haviors in those samples than the other two systems.
First, Malton monitors malware’s behaviors in multi-
ple layers, and thus it can capture more behaviors than
the systems focusing on one layer. For instance, the
malware sample4 retrieves the serial number and op-
erator information of the SIM card through the frame-
work APIs TelephonyManager.getSimSerialNumber() and
TelephonyManager.getSimOperator(), respectively. How-
ever, CopperDroid does not support reconstructing such
behaviors from system calls and DroidBox does not mon-
itor these framework APIs. Second, Malton runs on re-
al devices, and hence it could circumvent many anti-
emulator techniques. For instance, the malware sample5
detects the existence of emulator based on the value of
android id and Build.DEVICE. If the obtained value in-
dicates that it is running in an emulator, the malicious
behaviors will not be triggered.
Note that these samples were analyzed by CopperDroid
before 2015 and it is likely that their C&C servers were
active at that time. However, not all C&C servers
We evaluate Malton using real-world Android malware
samples to answer the following questions.
3http://copperdroid.isg.rhul.ac.uk/copperdroid/reports.php
4md5: 021cf5824c4a25ca7030c6e75eb6f9c8
5md5: a0000a85a2e8e458660c094ebedc0c6e
296    26th USENIX Security Symposium
USENIX Association
String@0x6fd57360 ((cid:256)_id(cid:257))
String@0x6fd86b70 ((cid:256)display_name(cid:257))
01
CursorWrapper.
getColumnIndex()
Int 0xd
02
CursorWrapper.
getString() 
03
CursorWrapper.
getColumnIndex() 
Int 0x6
04
CursorWrapper.
getString()
15
LoggingPrintStream.
println()
Arg1: String@0x12ccc3d8 ((cid:256)send Message to Jeremy 1(cid:257))
String@0x12d94fd8 ((cid:256)(cid:11585)(cid:17935)(cid:1120)(cid:952)(cid:257))
String@0x1312c938 ((cid:256)http://cdn.yyupload.com/
down/4279193/XXshenqi.apk(cid:257))
String@0x12d5d168 ((cid:256)1(cid:257))
String@0x12d5d2e8 ((cid:256)Jeremy(cid:257))
10
StringBuilder.
11
StringBuilder.
append() 
12
StringBuilder.
append() 
Uri@0x6ff41410 ((cid:256)com.android.contact(cid:257))
ContentResolver$CursorWrapperInner@0x12d8b8b8
String@0x130b2c28 ((cid:256)Jeremy(cid:11579)(cid:17929)(cid:1114)(cid:712)http://cdn.yyupload.com/down/4279193/XXshenqi.apk(cid:257))
13
StringBuilder.
toString() 
05
ContentResolver.