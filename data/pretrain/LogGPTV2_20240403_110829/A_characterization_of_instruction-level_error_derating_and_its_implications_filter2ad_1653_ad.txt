rors from being introduced into architected state by means
other than incorrect execution. While logically performing
the same comparisons, the granularity and mechanism of
the techniques differ.
The lock-step approach ensures that both processors per(cid:173)
form the same operations each cycle and compares the up(cid:173)
dates performed by each processor to architected state ev(cid:173)
In the event of any deviation, an error is re(cid:173)
ery cycle.
ported. This scheme not only requires very high band(cid:173)
width between the two processors, but also, in relation to
this work, will detect any propagating fault as an error to
be corrected. Thus, the derating rate resulting from this er(cid:173)
ror detection technique corresponds precisely to the passing
no-propagate rates reported in Figure 5.
To reduce the required bandwidth between the two
processors,
the other two techniques summarize the the
changes to the register file (which are most of the changes
to architectural state) in the form of a signature, and com(cid:173)
pare these signatures periodically in addition to comparing
a trace of branch outcomes as well as store addresses and
data [22]. These techniques reduce the required bandwidth
at the cost of introducing a small possibility of false nega-
1-4244-2398-9/08/$20.00 ©2008 IEEE
489
DSN 2008: Cook &Zilles
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 13:20:33 UTC from IEEE Xplore.  Restrictions apply. 
International Conference on Dependable Systems &Networks: Anchorage, Alaska, June 24-27 2008
tives, but the rate of false negatives can be controlled by the
size of the signature.
The first periodic technique, incremental periodic, con(cid:173)
structs the signature by incrementally folding into the signa(cid:173)
ture the information relating to writes to the register file as
they retire from the processor. Because it includes the val(cid:173)
ues produced by every instruction, incremental periodic's
derating rate is identical to that of lock-step.
In contrast, snapshot periodic, constructs its signature
from a snapshot of the architected state. As the snapshot is
only taken periodically, faulty values have the opportunity
to be masked (overwritten) before the snapshot is created.
As a result, the software derating available includes both
that of the passing no-propagate as well as a fraction of the
passing propagate; as we show in the black bars in Figure 7,
the fraction depends on how frequently the comparisons are
performed. Therefore snapshot periodic is guaranteed to
achieve a derating rate that equals or exceeds that of the
other two techniques, supporting our assertion that error de(cid:173)
tection rates can be different due to propagating errors that
are later masked.
The data shown in Figure 7 was collected using the
same fault injection methodology described in Section 3,
augmented with the error detection mechanisms described
above. The first bar in each graph (LS) denotes the error de(cid:173)
rating of the lock-step and incremental periodic techniques.
For snapshot periodic, the error derating rate depends on
the frequency of the checking, so we plot this function of
frequency. In our implementation, we identify a subset of
instructions (control, store, and system call instructions),
which we will refer to as check-fence instructions. We only
generate snapshots after these instructions, because we have
found that doing so increases the number of masked errors
without significantly introducing complexity in checking.
We measure the derating rates that occur when checking at
every check-fence instruction and at intervals of 10, 100,
and 1000 checkfence instructions.! We show data for five
of the twelve SPEC CINT2000 benchmarks run at full op(cid:173)
timization (-03), whose results we believe to be represen(cid:173)
tative for the whole suite; in addition, we include the aver(cid:173)
age results for these programs without optimization (-00)
which result in the same basic trends with slightly higher
levels of masking.
As previously noted,
the black bars demonstrate that
snapshot periodic error derating increases as we increase
the interval between checks. While increased derating is
beneficial, it is important that it not come at a huge increase
in the latency to detect errors. For example, if an error oc(cid:173)
curs once every 105 instructions, then performing error de(cid:173)
tection once every 5,000 instructions will result in roughly
2.5% loss in performance, plus the overhead for recovery, as
1In these experiments, we do not actually reduce the register state to a
signature, as doing so only adds the possibility of false negatives.
on average the faulting instruction will occur in the middle
of the error detection interval. With a check-fence instruc(cid:173)
tion occurring roughly every 4 instructions in our experi(cid:173)
ment, the intervals in Figure 7 correspond to checking for
errors every 4, 40, 400, and 4,000 instructions.
A significant factor leading to increased derating with
larger intervals is more temporal opportunity for a register
containing an incorrect, and usually dead, value to be over(cid:173)
written (i.e., the average fraction of registers with faulty val(cid:173)
ues decreases with time, as previously shown in Figure 6).
Clearly, comparing the entire architected state is sufficient
but not necessary for correctness; any values that are dead
(i.e., it is known that they will not be referenced again) need
not be checked, since they cannot affect further computa(cid:173)
tion. To explore what further fraction of unnecessary er(cid:173)
ror recoveries could be eliminated, we modified the LLVM
compiler to record static2 register liveness information [16]
associated with each check-fence instruction. In a second
set of experiments shown in Figure 7, we show that by com(cid:173)
paring only statically live register values between proces(cid:173)
sors, almost 90% of the instruction-level error derating can
be achieved, even with very small error detection intervals.
6. Conclusion
logical operations, overflow/precision,
In this work, we demonstrated the mechanisms that re(cid:173)
sult in instruction-level error derating; that is, how incorrect
architectural state or incorrect instruction execution can re(cid:173)
sult in correct program behavior. We classified the mech(cid:173)
anisms into six categories: value comparison, sub-word
operations,
lucky
loads, and dynamically dead values. Unlike previous work
on software derating that exploits the structure of the com(cid:173)
putation (e.g., [26]) or the numerical properties of specific
applications (e.g., [15]), these are general-purpose instruc(cid:173)
tion properties found in all of the programs that we stud(cid:173)
ied. Even if we conservatively restrict the opportunity for
instruction-level derating by considering a fault as an er(cid:173)
ror if it propagates to the memory system or affects control
flow, we find that 36% of architecturally visible faults are
derated and masked.
Knowledge of the mechanisms of software derating pro(cid:173)
vides system builders the opportunity to exploit them. We
considered two instruction-level derating-motivated oppor(cid:173)
tunities in the context of systems that exploit the presence of
error detection mechanisms to improve performance or re(cid:173)
duce power consumption. First, we demonstrated that com(cid:173)
paring architeeted state via periodic snapshots permits faults
to be masked that would otherwise lead to error recovery
2To be clear, static liveness information makes no assumptions about
the further path of execution, so some false positives will still occur for
values that are dynamically dead (will not be used on the control flow path
that ends up to be taken) and will later be recognized as statically dead at
some later point in the code.
1-4244-2398-9/08/$20.00 ©2008 IEEE
490
DSN 2008: Cook &Zilles
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 13:20:33 UTC from IEEE Xplore.  Restrictions apply. 
International Conference on Dependable Systems &Networks: Anchorage, Alaska, June 24-27 2008
actions if the result of every instruction were incorporated.
Second, we demonstrated that the rate of derating can be
further increased by excluding the contents of known dead
registers from the comparison.
Looking forward, we believe there are other applications
that are enabled by an understanding of the mechanism of
instruction-level derating. In particular, we are interested in
investigating the degree to which instruction-level derating
can be increased by the optimizations performed by a com(cid:173)
piler and how it handles code generation.
Acknowledgment
This research was supported in part by NSF CCF(cid:173)
0702501 and NSF CAREER award CCF-0347260. The au(cid:173)
thors would also like to thank Lee Baugh, Brian Greskamp,
Edward Lee, Naveen Neelakantam, and Pierre Salverda for
their many useful comments.
References
[1] The LLVM Compiler
Infrastructure.
Home page:
http://llvm.cs.uiuc.edu/.
[2] T. Austin, E. Larson, and D. Ernst. Simplescalar: An infras-
IEEE Computer,
tructure for computer system modeling.
35(2):59-67, Feb. 2002.
[3] T. M. Austin. DIVA: A reliable substrate for deep submi(cid:173)
cron microarchitecture design. In Proc. ofthe IntI. Symp. on
Microarchitecture, pages 196-207, 1999.
[4] 1. Blome, S. Mahlke, D. Bradley, and K. Flautner. A
microarchitectural analysis of soft error propagation in a
production-level embedded microprocessor. In Proc. of the
Workshop on Architectural Reliability, 2005.
[5] S. Borkar et al. Parameter variations and impact on circuits
and microarchitecture. In Proc. of the Annual Conf. on De(cid:173)
sign Automation, pages 338-342, 2003.
[6] 1. A. Butts and G. S. Sohi. Characterizing and predicting
value degree of use. In Proc. of the IntI. Symp. on Microar(cid:173)
chitecture, pages 15-26, Nov. 2002.
[7] H. Cha, E. M. Rudnick, J. H. Patel, R. K.
Iyer, and
G. S. Choi. A gate-level simulation environment for alpha(cid:173)
particle-induced transient faults. IEEE Trans. on Computers,
45( 11): 1248-1256, Nov. 1996.
[8] J. J. Cook and C. Zilles. Characterizing instruction-level
In Proc. of the IEEE Workshop on Silicon
error derating.
Errors in Logic System Effects, Mar 2008.
[9] D. Ernst, N. S. Kim, S. Das, S. Pant, R. Rao, T. Pham,
C. Zeisler, D. Blaauw, T. Austin, K. Flautner, and T. Mudge.
Razor: A low-power pipeline based on circuit-level timing
speculation. In Proc. ofthe IntI. Symp. on Microarchitecture,
pages 7-18, 2003.
[10] M. Favalli and C. Metra. Optimization of error detecting
codes for the detection of crosstalk originated errors.
In
Proc. of the Conf. on Design, Automation and Test in Eu(cid:173)
rope, 2001.
[11] M. Gomaa, C. Scarbrough, T. N. Vijaykumar, and I. Pomer(cid:173)
anz. Transient-fault recovery for chip multiprocessors.
In
Proc. ofthe IntI. Symp. on Computer architecture, pages 98(cid:173)
109,2003.
[12] B. Greskamp and 1. Torrellas. Paceline: Improving single(cid:173)
thread performance in nanoscale cmps through core over(cid:173)
clocking. In Proc. ofthe IntI. Conf. on Parallel Architecture
and Compilation Techniques, pages 213-224, 2007.
[13] W. Gu, Z. Kalbarczyk, R. Iyer, and Z. Yang. Character(cid:173)
In Proc. of
ization of linux kernel behavior under errors.
the IntI. Conf. on Dependable Systems and Networks, June
2003.
[14] G. A. Kanawati, N. A. Kanawati, and J. A. Abraham. FER(cid:173)
RARI: A flexible software-based fault and error injection
IEEE Trans. on Computers, 44(2):248-260, Feb.
system.
1995.
[15] X. Li and D. Yeung. Application-level correctness and its
In Proc. of the IntI. Symp. on
impact on fault tolerance.
High-Performance Computer Architecture, 2007.
[16] M. M. Martin, A. Roth, and C. N. Fischer. Exploiting dead
In Proc. of the IntI. Symp. on Microar(cid:173)
value information.
chitecture, pages 125-135, 1997.
[17] F. Mesa-Martinez and J. Renau. Effective optimistic-checker
tandem core design through architectural pruning. In Proc.
ofthe IntI. Symp. on Microarchitecture, 2007.
[18] S. Mitra, N. Seifert, M. Zhang, Q. Shi, and K. S. Kim. Ro(cid:173)
bust system design with built-in soft-error resilience. IEEE
Computer, 38(2):43-52, Feb. 2005.
[19] S. S. Mukherjee, C. Weaver, 1. Emer, S. K. Reinhardt, and
T. Austin. A systematic methodology to compute the archi(cid:173)
tectural vulnerability factors for a high-performance micro(cid:173)
processor. In Proc. of the IntI. Symp. on Microarchitecture,
pages 29-40, 2003.
[20] G. P. Saggese, A. Vetteth, Z. Kalbarczyk, and R. Iyer. Mi(cid:173)
croprocessor sensitivity to failures: control vs. execution and
combinational vs. sequential logic. In Proc. ofthe IntI. Conf.
on Dependable Systems and Networks, pages 760-769, June
2005.
[21] P. Shivakumar, M. Kistler, S. W. Keckler, D. Burger, and
L. Alvisi. Modeling the effect of technology trends on the
In Proc. of the IntI.
soft error rate of combinational logic.
Conf. on Dependable Systems and Networks, pages 389(cid:173)
398, June 2002.
[22] J. C. Smolens, B. T. Gold, J. Kim, B. Falsafi, J. C. Hoe,
and A. G. Nowatzyk. Fingerprinting: bounding soft-error
detection latency and bandwidth. In Proc. of the IntI. Conf.
on Architectural Support for Programming Languages and
Operating Systems, pages 224-234, 2004.
[23] J. Srinivasan, S. V. Adve, P. Bose, and 1. A. Rivers. The case
In Proc. of
for lifetime reliability-aware microprocessors.
the IntI. Symp. on Computer Architecture, 2004.
[24] K. Sundaramoorthy, Z. Purser, and E. Rotenberg. Slipstream
Improving both performance and fault toler(cid:173)
processors:
In Proc. of the IntI. Conf. on Architectural Support
ance.
for Programming Languages and Operating Systems, pages
257-268, Nov. 2000.
[25] D. D. Thaker, D. Franklin, V. Akella, and F. T. Chong. Reli(cid:173)
ability requirements of control, address, and data operations
In Proc. of the Workshop on
in error-tolerant applications.
Architectural Reliability, 2005.
[26] N. Wang, M. Fertig, and S. Patel. Y-branches: When
In Proc. of the
you come to a fork in the road, take it.
IntI. Conf. on Parallel Architectures and Compilation Tech(cid:173)
niques, page 56, 2003.
[27] N. 1. Wang, A. Mahesri, and S. J. Patel. Examining ACE
In Proc.
analysis reliability estimates using fault-injection.
ofthe IntI. Symp. on Computer Architecture, pages 460-469,
2007.
[28] N. J. Wang, 1. Quek, T. M. Rafacz, and S. 1. Patel. Charac(cid:173)
terizing the effects of transient faults on a high-performance
processor pipeline. In Proc. ofthe IntI. Conf. on Dependable
Systems and Networks, pages 61-70, June 2004.
1-4244-2398-9/08/$20.00 ©2008 IEEE
491
DSN 2008: Cook &Zilles
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 13:20:33 UTC from IEEE Xplore.  Restrictions apply.