REVERSE和APPEND的组合。像REVERSB那样求逆第一个参数，再将其追加到
构造一个n项的列表。该列表的初始元素是NIL或者通过：initial-element
用来测试一个对象是否不是点对单元的谓词
构造一个列表来保存除最后一个参数外的所有参数，然后让最后一个参数成为
返回真，如果给定对象是作为列表一部分的点对单元
返回列表直到某个给定点对单元的副本
BUTLAST的回收性版本。可能修改并返回其参数列表但缺少可靠的副作用
返回列表的一个副本，最后一个点对单元除外。带有一个整数参数时，排除最
返回列表的最后一个点对单元。带有一个整数参数时，返回最后n个点对单元
www.TopSage.com
表12-1
其他列表处理函数描述
换句话说，它组合了
描
送
LIST和 APPEND
---
## Page 150
这类函数。
其他函数也允许你使用点对单元来表示树、集合以及两类键/值映射表。我将在第13章讨论一些
列表的列表来表示树。正如本章所讨论的函数允许你将构建在点对单元上的结构视为列表那样，
12.7
MAPLIST/MAPCON家族。
当映射函数的副作用有用时，它们才是有用的。MAPC是MAPCAR和MAPCAN的近亲，而MAPL属于
则像MAPLIST那样来传递点对单元。
果中提供任意数量的元素。MAPCAN像MAPCAR那样把列表的元素传递到映射函数中，而MAPCON
将结果（必须是列表）用NCONC拼接在一起来产生它们的结果。这样，每次函数调用都可以向结
MAPCAR和MAPLIST会构造一个全新的列表来保存函数调用的结果，而MAPCAN和MAPCON则通过
CAR），还可以访问到列表的其余部分（通过CDR）。
而是实际的点对单元。这样，该函数不仅可以访问到列表中每个元素的值（通过点对单元的m
最后，函数MAPC和MAPL是伪装成函数的控制构造，它们只返回第一个列表实参，因此只有
除构造结果的方式不同，MAPCAN和MAPCON与MAPCAR和MAPLIST的工作方式很相似。
②在没有像REMOVE这样的过滤函数的LiSP方言中，过滤一个列表的惯用方法是使用MAPCAN：
①因此，MAPLIST是两个函数中更基本的。如果你只有MAPLIST，你可以在它的基础上构造出MAPCAR，但你不可
尽管点对单元和列表通常被视作同义词，但这并不很准确。正如我早先提到的，你可以使用
MAPLIST也和MAPCAR较为相似，它们之间的区别在于MAPLIST传递给函数的不是列表元素
能在MAPCAR的基础上构造MAPLIST。
（mapcan #(lambda （x)（if（=x 10）nil (listx））) list）=（remove 10 list)
其他结构
www.TopSage.com
---
## Page 151
的CAR均指向与原来列表结构中的点对单元的CAR相同的对象。这样，COPY-LIST就不会复制子
就是说，它根据虚线框之内的每个点对单元生成一个对应的新点对单元。每一个这些新点对单元
制这些点对单元的方式。作为一个列表函数COPY-LIST只复制那些构成列表结构的点对单元。也
列表结构仅包括虚线框之内的三个点对单元，而树结构则包含全部的点对单元。
对单元。因此，树中的值就是该树结构中所有点对单元引用的非点对单元的值。
素的一个列表的头部。“而另一方面，树结构则是同时跟随CAR和CDR引用，只要它们指向其他点
点对单元带有一个引用到其他点对单元的CAR，那么被引用的点对单元将被视为作为外部列表元
直到遇到NIL。列表元素就是由列表结构点对单元的CAR所引用的对象。如果列表结构中的一个
函数所查找的点对单元称为列表结构，其查找方式是以第一个点对单元开始，然后跟着CDR引I用
式，树不就是一种列表的列表吗？将一组点对单元作为列表来看待的函数与将同样的点对单元作
13.1
开始编写更复杂的宏以及需要将Lisp代码作为数据处理时，这其中有很多函数会很有用。
集合及查询表。本章将简要介绍这其中的一些数据结构及其处理函数。和列表处理函数一样，在
为了搞清列表函数和树函数之间的区别，你可以考查一下函数COPY-LIST和COPY-TREE复
））
①有可能构造出一串点对单元，其中最后一个点对单元的CDR不为NIL而是一些其他的原子。这被称为点列表，因
由点对单元构建的数据结构既然可看作成列表，自然也可看成是树。毕竟，换另一种思考方
没有点的列表（其最后一个CDR为NIL）称为正则列表。
(cons 1
为其最后一个元素前带有一个点。
树
(cons
2
其他用法
超越列表：点对单元的
www.TopSage.com
1
(123
4）
---
## Page 152
键字参数的测试），函数就认为它们相等。
当这两棵树具有相同的形状以及它们对应的叶子是EQL等价时（或者如果它们满足带有：test关
由原先的树和COPY-TREE所产生的复制共同引用的唯一对象就是数字1～6以及符号NIL。
同的结构连接在一起，如下图所示:
列表(1 2)、(3 4)或(56)，如下图所示:
另一个在树的点对单元的CAR和CDR上都进行遍历的函数是TREE-EQUAL。它会比较两棵树，
当原先的点对单元中引用了一个原子值时，复制中的相应点对单元也将指向相同的值。这样
另一方面，COPY-TREB将会为图中的每个点对单元都生成一个新的点对单元，并将它们以相
W9E9NEeKWE
-→
新的点对单元
www.TopSage.com
2 NIL
3
NIL
→ 4NIL
5
6 NIL
新的点对单元
135
---
## Page 153
返回的值赋值到该列表所来自的位置上。PUSHNEW修改宏可以自动做到这点。
和CONS一样，ADJOIN不会影响原先的列表—如果打算修改一个特定的列表，则需要将ADJOIN
先的列表并返回它。否则，它返回原先的列表。
列表。如果该项没有被找到，那么ADJOIN就会创建一个保存该项的新点对单元，并让其指向原
代表集合的列表，其中含有该项和原先集合中的所有项。为了检测该项是否存在，它必须扫描该
也总能将列表替换成构建在哈希表或位向量之上的集合。
它们可能会比其他替代实现更为高效。如果性能评估显示这些函数成为代码的性能瓶颈，那么你
组织方式，当集合变得更大时，这些操作将会越来越低效。
供的几个函数可用于对列表进行集合论意义上的操作。但你应当在头脑中牢记，由于列表结构的
13.2
必须总是保存这些函数的返回值，因为无法保证其结果与原先的树是EQ等价的。
享结构的危险时，才可以将这些函数作为它们非破坏性同伴的原位替代品来使用。特别的是，你
是SUBST系列函数的回收性版本。和其他大多数回收性函数一样，只有在明确知道不存在修改共
也是一样，只不过那些测试返回NIL的值才会被替换。NSUBST、NSUBST-IF和NSUBST-IF-NOT
一个原子值上都会被调用,并且当它返回真时，新树中的对应位置将被填充成新值。SUBST-IF-NOT
先的树具有相同形状的新树，只不过其中所有旧项的实例都被替换成新项。例如：
个旧项和一棵树（跟序列的情况刚好相反)，以及：key和：test关键字参数，然后返回一棵与原
于树的类似版本及其-IF和-IF-NOT变体。函数SUBST会像SUBSTITUTE一样接受一个新项、一
ADJOIN也接受：key和：teSt关键字参数，它们被用于检测该项是否存在于原先的列表中。
可以使用函数ADJOIN来构造集合。ADJOIN接受一个项和一个代表集合的列表并返回另一个
136
① NSUBST家族的函数确实可以就地修改树。不过，这里有一种边界情况：当被传递的“树”事实上是一个原子时，
集合也可以用点对单元来实现。事实上，你可以将任何列表都看作是集合，Common Lisp提
其他一些以树为中心处理对象的函数包括SUBSTITUTE和NSUBSTITUTE这两个序列函数用
CL-USER> (defparameter *set* ())
SUBST-IF与SUBSTITUTE-IF相似。它接受一个单参数函数而不是一个旧项，该函数在树的每
NIL
CL-USER>
CL-USER>
CL-USER>(subst 10 1'(1 2(3 2 1)（(1 1)(2 2))))
它不可能被就地修改，因此NsUBST的结果是将与其参数不同的对象：（nsubst‘×‘
集合
第13章超越列表：点对单元的其他用法
(setf *set* (adjoin 1 *set*))
*set*
(adjoin 1 *set*)
www.TopSage.com
'y'y) ->x。
---
## Page 154
后被移除时原先的映射还可以再次暴露出来。
时，它还能找出一个对应的键。alist也支持添加键/值映射来掩盖已有的映射，并且当这个映射以
这既是因为对于小型的表而言，它们可以比哈希表更加高效，同时也是因为它们的一些专有属性
尽管alist与plist都不能用于大型表(那种情况下你可以使用哈希表)，但是值得去了解其使用方式，
表会经常用到，这两者都是前面章节里提到过的。它们是关联表，也称为alist、属性表以及plist。
13.3查询表：alist和plist
中。列表中元素的顺序无关紧要。
第二个列表的一个子集时返回真，也就是说，第一个列表中的每一个元素也都存在于第二个列表
唯一区别在于后者的名字带有一个前缀N。
参数列表中的一个而不是两者的那些元素。这些函数中的每一个也都有一个相应的回收性函数
不出现在第二个参数中的所有元素。而SET-EXCLUSIVE-OR则返回一个列表，其含有仅来自两个
返回一个由两个参数中可找到的所有元素组成的列表。UNION返回一个列表，其含有来自两个参
返回一个新列表，其代表了在两个列表上进行适当的集合论操作所得到的结果：INTERSECTION
SET-EXCLUSIVE-OR。这些函数中的每一个都接受两个列表以及:key和:teSt关键字参数，并
开始的子列表。当指定项不在列表中时，所有三个函数均返回NIL。
于列表。当指定项存在时，它们并不返回该项，而是返回含有该项的那个点对单元，即以指定项
十分有用。
在一个集合中。这些函数与序列函数FIND、FIND-IF以及FIND-IF-NOT相似，不过它们只能用
其余的集合论函数提供了批量操作：INTERSECTION、UNION、SET-DIFFERENCE以及
① UNION从每个列表中只接受一个元素，但如果任何一个列表含有重复的元素，那么结果可能也含有重复的元素。
从底层来看，alist本质上是一个列表，其每一个元素本身都是一个点对单元。每个元素可以
 alist是一种数据结构，它能将一些键映射到值上，同时也支持反向查询，并且当给定一个值
除了树和集合以外，你还可以用点对单元来构建表将键映射到值上。有两类基于点对的查询
最后，函数SUBSETP接受两个列表以及通常的：key和：teSt关键字参数，并在第一个列表是
NIL
(（ ). (  ). dasq1s)  *set*
(2 1)
CL-USER>
-USER> (pushnew 2 *set*)
1
(pushnew 2 *set*)
www.TopSage.com
13.3
查询表：alist和 plist 
137
---
## Page 155
后面带有相同键的其他键值对。
不一定EQL等价。
关键字参数的标准组合来改变这一行为。例如，如果想要用字符串的键，则可以这样写。
元，或是在没有找到匹配时返回NIL。
将符号A映射到数字1、B映射到2，c映射到3的alist的方框和箭头图例：PSdQ
被想象成是一个键值对，其中键保存在点对单元的CAR中而值保存在CDR中。例如，
（dottedpair）。例如上图所表示的alist将被打印成下面的样子：
138
但为方便起见，CommonLisp提供了函数AcoNs，它可以让你这样写：
由于ASSOC搜索列表时会从列表的前面开始扫描，
如果没有指定：teSt为STRING=，ASSOC将可能返回NIL，因为带有相同内容的两个字符串
在默认情况下，指定的键使用EQL与alist中的键进行比较，但你可以通过使用：key和：test
为了得到一个给定键的对应值，可以简单地将ASSOC的结果传给CDR。
alist的主查询函数是ASsoc，其接受一个键和一个alist并返回第一个cAR匹配该键的点对单
（(A.1）（B.2）（C.3））
除非CDR中的值是一个列表，否则代表键值对的点对单元在表示成S-表达式时将是一个点对
(acons‘new-key 'new-value alist)
可以像下面这样使用coNs向一个alist的前面添加键值对。
（A.10）
CL-USER>（assoca((a.10)（a.1）（b.2)(c.3）))
NIL
CL-USER>（assoc"a"′(（"a".1)("b".2)("c”.3）):test#′string=)
CL-USER>（cdr（assoc'a(（a.1)（b.2)（c.3）））)
NIL
CL-USER>
C
CL-USER>
CL-USER>（assoc'a'((a.1)（b.2)（c.3)))
第13章超越列表：点对单元的其他用法
（assoc'd(（a.1）（b.2）（c.3））)
（assocc（（a.1）（b.2）（c.3））)
www.TopSage.com
A1B2
，因此alist中的一个键值对可以遮盖列表中
C3
下面是一个