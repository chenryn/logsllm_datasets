**作者：HuanGMz@知道创宇404实验室  
时间：2020年10月30日**
> .NET 相关漏洞中，ViewState也算是一个常客了。Exchange CVE-2020-0688，SharePoint
> CVE-2020-16952 中都出现过ViewState的身影。其实ViewState 并不算漏洞，只是ASP.NET
> 在生成和解析ViewState时使用ObjectStateFormatter
> 进行序列化和反序列化，虽然在序列化后又进行了加密和签名，但是一旦泄露了加密和签名所使用的算法和密钥，我们就可以将ObjectStateFormatter
> 的反序列化payload 伪装成正常的ViewState，并触发ObjectStateFormatter 的反序列化漏洞。
>
> 加密和签名序列化数据所用的算法和密钥存放在web.confg 中，Exchange 0688 是由于所有安装采用相同的默认密钥，而Sharepoitn
> 16952 则是因为泄露web.confg 。
>
> .NET 反序列化神器 ysoserial.net 中有关于ViewState
> 的插件，其主要作用就是利用泄露的算法和密钥伪造ViewState的加密和签名，触发ObjectStateFormatter
> 反序列化漏洞。但是我们不应该仅仅满足于工具的使用，所以特意分析了ViewState 的加密和签名过程作成此文，把工具用的明明白白的。
>
> 初接触.NET，文中谬误纰漏之处在所难免，如蒙指教不胜感激。
### 1\. 调试.Net FrameWork
#### 1.1 .Net 源码
对于刚接触.Net反序列化，甚至刚接触C#的朋友来说，有一个舒适方便的调试环境实在是太重要了。这里就简单介绍一下如何进行.net framework
的底层调试。
.Net Framework
已经被微软[开源](https://referencesource.microsoft.com/)了，你可以在官方网站上下载源码或者直接在线浏览。目前开源的版本包括
.Net 4.5.1 到 4.8。但是要注意，虽然微软开源了.Net
的源码，以及相应的VS项目文件，但是只能用于代码浏览，而无法进行编译。因为缺少重要组件（包括xaml文件和资源文件）。
#### 1.2 调试
微软官文档有说明如何使用VS进行.Net源码的调试。其原理大概是通过pdb+源码的方式来进行单步调试。但经过实际尝试，发现并不是所有.net
程序集文件都有完整的pdb文件，其中一部分程序集的pdb是没有源码信息的。也就是说，只有一部分的程序集可以通过vs进行单步调试。
细节参考以下连接：
支持源码调试的程序集列表为：
在放弃使用vs进行调试后，我发现还可以使用dnspy 进行.net底层调试。dnspy
是一个开源的.Net反编译工具，与经典工具Reflector相比，它不仅可以用于反编译，还可以借助反编译直接进行调试。dnspy
的github链接在[这里](https://github.com/dnSpy/dnSpy)。可以下载源码进行编译，也可以直接下载编译好的版本，不过要注意满足它要求的.net
framework 版本。
**设置环境变量 COMPLUS_ZapDisable=1**
为什么要设置这个环境变量，为了禁用所有NGEN映像（* .ni.dll）的使用。
假如你的windows服务器上安装有IIS服务，并且上面运行一个网站。使用浏览器打开该网站，这会使IIS在后台创建一个工作进程，用于运行该网站。这时我们用
process explore去查看 w3wp.exe 进程加载的dll，你会发现为什么程序集后面都有一个.ni的后缀。System.Web.dll 变为了
System.Web.ni.dll ，并且该dll的描述中还特意写了 "System.Web.dll"。其实这就是在使用.Net的优化版代码。
设置环境变量 COMPLUS_ZapDisable=1
，重启windows（一定要重启，因为重启IIS服务才能应用到我们设置的新环境变量）。仍然用ie打开网站，然后使用Process
explore去查看w3wp.exe，这时你就会发现：网站工作进程加载的程序集变回了我们所熟知的System.Web.dll。
> 注意1：设置环境变量后要重启
>
> 注意2：如果找不到w3wp.exe，使用管理员运行process explore。
**使用dnspy 进行调试**
首先我们用process
explore检查`w3wp.exe`加载的程序集所在的位置。因为你的系统上可能安装有多个版本的.Net或者是不同位数的.Net。如果你在dnsPy
中打开了错误的程序集，你在上面下断点的时候会提示你：无法中断到该断点，因为没有加载该模块。
选择32位或者64位的
dnspy(与被调试进程匹配)，以管理员权限启动。随便找一个程序集，比如System.Web.dll，点开后我们看他第一行中所写的路径是否与目标进程加载的程序集相同：
如果不相同，左上方 文件->全部关闭，然后 文件->打开列表，从中选择一个版本合适的 .Net 。
然后上方
调试->附加到进程，选择`w3wp.exe`，如果有多个进程，我们可以通过进程号来确定。那么如何判断哪一个进程是我们需要的呢？方法有很多种，你可以通过
process explore 查看`w3wp.exe`的启动命令，看哪个是运行目标网站的工作进程。又或者，以管理员权限启动cmd，进入
C:\Windows\System32\inetsrv，然后运行appcmd list wp。
我们可以看到进程号和对应的网站集名称。
然后就是给目标函数下断点，刷新页面，会中断到断点。
### 2\. ViewState基础知识
在我们尝试利用ViewState反序列化之前，我们需要一些了解相关的知识。
> ASP.NET是由微软在.NET
> Framework框架中所提供，开发Web应用程序的类别库，封装在System.Web.dll文件中，显露出System.Web名字空间，并提供ASP.NET网页处理、扩展以及HTTP通道的应用程序与通信处理等工作，以及Web
> Service的基础架构。
也就是说，ASP.NET 是.NET Framework 框架提供的一个Web库，而ViewState则是ASP.NET所提供的一个极具特点的功能。
**出现ViewState的原因** ：
HTTP模型是无状态的，这意味着，每当客户端向服务端发起一个获取页面的请求时，都会导致服务端创建一个新的page类的实例，并且一个往返之后，这个page实例会被立刻销毁。假如服务端在处理第n+1次请求时，想使用第n次传给服务器的值进行计算，而这时第n次请求所对应的page实例早已被销毁，要去哪里找上一次传给服务器的值呢？为了满足这种需求，就出现了多种状态管理技术，而VewState正是ASP.NET
所采用的状态管理技术之一。
**ViewState是什么样的？**
要了解ViewState，我们要先知道什么叫做服务器控件。
> ASP.NET 网页在微软的官方名称中，称为 Web Form，除了是要和Windows
> Forms作分别以外，同时也明白的刻划出了它的主要功能：“让开发人员能够像开发 Windows Forms 一样的方法来发展 Web 网页”。因此
> ASP.NET Page 所要提供的功能就需要类似 Windows Forms 的窗体，每个 Web Form 都要有一个 runat="server" >区块，所有的 ASP.NET 服务器控件都要放在这个区域中，这样才可以让 ViewState
> 等服务器控制能够顺畅的运作。
无论是HTML服务器控件、Web服务器控件 还是 Validation服务器控件，只要是ASP.NET 的服务器控件，都要放在的区块中，其中的属性 runat="server" 表明了该表单应该在服务端进行处理。
ViewState原始状态是一个 字典类型。在响应一个页面时，ASP.NET 会把所有控件的状态序列化为一个字符串，然后作为 hidden input 的值
插入到页面中返还给客户端。当客户端再次请求时，该hidden input
就会将ViewState传给服务端，服务端对ViewState进行反序列化，获得属性，并赋给控件对应的值。
**ViewState的安全性:**
在2010年的时候，微软曾在《MSDN杂志》上发过一篇文章，讨论ViewState的安全性以及一些防御措施。文章中认为ViewState主要面临两个威胁：信息泄露和篡改。
信息泄露威胁：
原始的ViewState仅仅是用base64编码了序列化后的binary数据，未使用任何类型的密码学算法进行加密，可以使用LosFormatter（现在已经被ObjectStateFormatter替代）轻松解码和反序列化。
    LosFormatter formatter = new LosFormatter();
    object viewstateObj = formatter.Deserialize("/wEPDwULLTE2MTY2ODcyMjkPFgIeCHBhc3N3b3JkBQlzd29yZGZpc2hkZA==");
反序列化的结果实际上是一组System.Web.UI.Pair对象。
为了保证ViewState不会发生信息泄露，ASP.NEt 2.0 使用 ViewStateEncryptionMode属性
来启用ViewState的加密，该属性可以通过页面指令或在应用程序的web.config 文件中启用。
ViewStateEncryptionMode 可选值有三个：Always、Never、Auto
篡改威胁：
加密不能防止篡改
，即使使用加密数据，攻击者仍然有可能翻转加密书中的位。所以要使用数据完整性技术来减轻篡改威胁，即使用哈希算法来为消息创建身份验证代码（MAC)。可以在web.config
中通过EvableViewStateMac来启用数据校验功能。
注意：从.NET 4.5.2 开始，强制启用ViewStateMac 功能，也就是说即使你将
EnableViewStateMac设置为false，也不能禁止ViewState的校验。安全公告[KB2905247](https://docs.microsoft.com/en-us/security-updates/SecurityAdvisories/2013/2905247?redirectedfrom=MSDN)(于2014年9月星期二通过补丁程序发送到所有Windows计算机)将ASP.NET
设置为忽略EbableViewStateMac设置。
启用ViewStateMac后的大致步骤：
> (1)页面和所有参与控件的状态被收集到状态图对象中。
>
> (2)状态图被序列化为二进制格式
>
> a. 密钥值将附加到序列化的字节数组中。  
>  b. 为新的序列化字节数组计算一个密码哈希。  
>  c. 哈希将附加到序列化字节数组的末尾。
>
> (3) 序列化的字节数组被编码为base-64字符串。
>
> (4)base-64字符串将写入页面中的__VIEWSTATE表单值。
**利用ViewState 进行反序列化利用**
其实ViewState 真正的问题在与其潜在的反序列化漏洞风险。ViewState 使用ObjectStateFormatter
进行反序列化，虽然ViewState
采取了加密和签名的安全措施。但是一旦泄露web.config，获取其加密和签名所用的密钥和算法，我们就可以将ObjectStateFormatte
的反序列化payload
进行同样的加密与签名，然后再发给服务器。这样ASP.NET在进行反序列化时，正常解密和校验，然后把payload交给ObjectStateFormatter
进行反序列化，触发其反序列化漏洞，实现RCE。
### 3\. web.config 中关于ViewState 的配置
ASP.NET 通过web.config 来完成对网站的配置。
在web.config 可以使用以下的参数来开启或关闭ViewState的一些功能：
**enableViewState** ： 用于设置是否开启viewState，但是请注意，根据 **安全通告KB2905247**
中所说，即使在web.config中将enableViewState 设置为false，ASP.NET服务器也始终被动解析
ViewState。也就是说，该选项可以影响ViewState的生成，但是不影响ViewState的被动解析。实际上，
**viewStateEncryptionMode** 也有类似的特点。
**enableViewStateMac** ： 用于设置是否开启ViewState Mac (校验)功能。在 **安全通告KB2905247**
之前，也就是4.5.2之前，该选项为false，可以禁止Mac校验功能。但是在4.5.2之后，强制开启ViewState Mac
校验功能，因为禁用该选项会带来严重的安全问题。不过我们仍然可以通过配置注册表或者在web.config
里添加危险设置的方式来禁用Mac校验，详情见后面分析。
**viewStateEncryptionMode** ： 用于设置是否开启ViewState Encrypt
(加密)功能。该选项的值有三种选择：Always、Auto、Never。
  * Always表示ViewState始终加密；
  * Auto表示 如果控件通过调用 RegisterRequiresViewStateEncryption() 方法请求加密，则视图状态信息将被加密，这是默认值；
  * Never表示 即使控件请求了视图状态信息，也永远不会对其进行加密。
在实际调试中发现，viewStateEncryptionMode
影响的是ViewState的生成，但是在解析从客户端提交的ViewState时，并不是依据此配置来判断是否要解密。详情见后面分析。
在web.config 中通过machineKey节 来对校验功能和加密功能进行进一步配置：
例子：
其中的 **validationKey** 和 **decryptionKey** 分别是校验和加密所用的密钥， **validation** 和
**decryption** 则是校验和加密所使用的算法（可以省略，采用默认算法）。校验算法包括： SHA1、 MD5、 3DES、 AE、
HMACSHA256、 HMACSHA384、 HMACSHA512。加密算法包括：DES、3DES、AES。 由于web.config
保存在服务端上，在不泄露machineKey的情况下，保证了ViewState的安全性。
了解了一些关于ViewState的配置后，我们再来看一下.NET Framework 到底是如何处理ViewState的生成与解析的。
### 4\. ViewState的生成和解析流程
根据一些先验知识，我们知道ViewState 是通过ObjectStateFormatter的 **Serialize** 和
**Deserialize** 来完成ViewState的序列化和反序列化工作。（LosFormatter
也用于ViewState的序列化，但是目前其已被ObjectStateFormatter替代。LosFormatter的Serialize
是直接调用的ObjectStateFormatter 的Serialize）
ObjectStateFormatter 位于System.Web.UI 空间，我们给他的
Serialize函数下个断点（重载有多个Serialize函数，注意区分）。使用dnspy 调试，中断后查看栈回溯信息：
通过栈回溯，我们可以清晰的看到Page类通过调用 SaveAllState 进入到ObjectStateFormatter的 Seralize 函数。
#### 4.1 Serialize 流程
查看Serialize 函数的代码（这里我使用.Net 4.8 的源码，有注释，更清晰）：
    private string Serialize(object stateGraph, Purpose purpose) {
        string result = null;
        MemoryStream ms = GetMemoryStream();
        try {
            Serialize(ms, stateGraph);
            ms.SetLength(ms.Position);
            byte[] buffer = ms.GetBuffer();
            int length = (int)ms.Length;
    #if !FEATURE_PAL // FEATURE_PAL does not enable cryptography
            // We only support serialization of encrypted or encoded data through our internal Page constructors
            if (AspNetCryptoServiceProvider.Instance.IsDefaultProvider && !_forceLegacyCryptography) {
                // If we're configured to use the new crypto providers, call into them if encryption or signing (or both) is requested.
                ...
            }
            else {
                // Otherwise go through legacy crypto mechanisms
    #pragma warning disable 618 // calling obsolete methods
                if (_page != null && _page.RequiresViewStateEncryptionInternal) {
                    buffer = MachineKeySection.EncryptOrDecryptData(true, buffer, GetMacKeyModifier(), 0, length);
                    length = buffer.Length;
                }
                // We need to encode if the page has EnableViewStateMac or we got passed in some mac key string
                else if ((_page != null && _page.EnableViewStateMac) || _macKeyBytes != null) {
                    buffer = MachineKeySection.GetEncodedData(buffer, GetMacKeyModifier(), 0, ref length);
                }
    #pragma warning restore 618 // calling obsolete methods
            }
    #endif // !FEATURE_PAL
            result = Convert.ToBase64String(buffer, 0, length);
        }
        finally {
            ReleaseMemoryStream(ms);
        }
        return result;
    }
在函数开头处，调用了另一个重载的Serialzie函数，作用是将stateGraph 序列化为binary数据：
        MemoryStream ms = GetMemoryStream();
        try {
            Serialize(ms, stateGraph);
            ms.SetLength(ms.Position);
            ...
之后进入else分支：
    if (_page != null && _page.RequiresViewStateEncryptionInternal) {
        buffer = MachineKeySection.EncryptOrDecryptData(true, buffer, GetMacKeyModifier(), 0, length);