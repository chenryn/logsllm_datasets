Noticethatavariablenamedsize❹isassigneda0value.
Thisisnecessary,asdefinedwithintheWindowsAPI
specification,toreleasetheentireregionofmemorybackinto
areclaimablestate.Finally,wepasstheMEM_RELEASE
operation❺tocompletelyfreetheprocessmemory(andour
discussiononprocessinjection).
AdditionalExercises
Likemanyoftheotherchaptersinthisbook,thischapterwill
providethemostvalueifyoucodeandexperimentalongthe
way.Therefore,weconcludethissectionwithafew
challengesorpossibilitiestoexpandupontheideasalready
covered:
Oneofthemostimportantaspectsofcreatingcodeinjectionismaintaininga
usabletoolchainsufficientforinspectinganddebuggingprocessexecution.
DownloadandinstallboththeProcessHackerandProcessMonitortools.Then,
usingProcessHacker,locatethememoryaddressesofbothKernel32and
LoadLibrary.Whileyou’reatit,locatetheprocesshandleandtakealookatthe
integritylevel,alongwithinherentprivileges.Nowinjectyourcodeintothe
samevictimprocessandlocatethethread.
Youcanexpandtheprocessinjectionexampletobelesstrivial.Forexample,
insteadofloadingthepayloadfromadiskfilepath,useMsfVenomorCobalt
Striketogenerateshellcodeandloaditdirectlyintoprocessmemory.Thiswill
requireyoutomodifyVirtualAllocExandLoadLibrary.
CreateaDLLandloadtheentirecontentsintomemory.Thisissimilartothe
previousexercise:theexceptionisthatyou’llbeloadinganentireDLLrather
thanshellcode.UseProcessMonitortosetapathfilter,processfilter,orboth,
andobservethesystemDLLloadorder.WhatpreventsDLLloadorder
hijacking?
YoucanuseaprojectcalledFrida(https://www.frida.re/)toinjecttheGoogle
ChromeV8JavaScriptengineintothevictimprocess.Ithasastrongfollowing
withmobilesecuritypractitionersaswellasdevelopers:youcanuseitto
performruntimeanalysis,in-processdebugging,andinstrumentation.Youcan
alsouseFridawithotheroperatingsystems,suchasWindows.Createyourown
Gocode,injectFridaintoavictimprocess,anduseFridatorunJavaScript
withinthesameprocess.BecomingfamiliarwiththewayFridaworkswill
requiresomeresearch,butwepromiseit’swellworthit.
THEPORTABLEEXECUTABLEFILE
Sometimesweneedavehicletodeliverourmaliciouscode.
Thiscouldbeanewlymintedexecutable(deliveredthroughan
exploitinpreexistingcode),oramodifiedexecutablethat
alreadyexistsonthesystem,forexample.Ifwewantedto
modifyanexistingexecutable,wewouldneedtounderstand
thestructureoftheWindowsPortableExecutable(PE)file
binarydataformat,asitdictateshowtoconstructan
executable,alongwiththeexecutable’scapabilities.Inthis
section,we’llcoverboththePEdatastructureandGo’sPE
package,andbuildaPEbinaryparser,whichyoucanuseto
navigatethestructureofaPEbinary.
UnderstandingthePEFileFormat
First,let’sdiscussthePEdatastructureformat.TheWindows
PEfileformatisadatastructuremostoftenrepresentedasan
executable,objectcode,oraDLL.ThePEformatalso
maintainsreferencesforallresourcesusedduringtheinitial
operatingsystemloadingofthePEbinary,includingthe
exportaddresstable(EAT)usedtomaintainexported
functionsbyordinal,theexportnametableusedtomaintain
exportedfunctionsbyname,theimportaddresstable(IAT),
importnametable,threadlocalstorage,andresource
management,amongotherstructures.YoucanfindthePE
formatspecificationathttps://docs.microsoft.com/en-
us/windows/win32/debug/pe-format/.Figure12-6showsthe
PEdatastructure:avisualrepresentationofaWindows
binary.
Figure12-6:TheWindowsPEfileformat
Wewillexamineeachofthesetop-downsectionsaswe
buildoutthePEparser.
WritingaPEParser
Throughoutthefollowingsections,wewillwritethe
individualparsercomponentsnecessarytoanalyzeeachPE
sectionwithintheWindowsbinaryexecutable.Asanexample,
we’llusethePEformatassociatedwiththeTelegram
messagingapplicationbinarylocatedathttps://telegram.org,
sincethisappisbothlesstrivialthantheoftenoverusedputty
SSHbinaryexample,andisdistributedasaPEformat.You
canusealmostanyWindowsbinaryexecutable,andwe
encourageyoutoinvestigateothers.
LoadingthePEbinaryandFileI/O
InListing12-14,we’llstartbyusingtheGoPEpackageto
preparetheTelegrambinaryforfurtherparsing.Youcanplace
allthecodethatwecreatewhenwritingthisparserinasingle
filewithinamain()function.
import(
❶"debug/pe"
"encoding/binary"
"fmt"
"io"
"log"
"os"
)
funcmain(){
❷f,err:=os.Open("Telegram.exe")
check(err)
❸pefile,err:=pe.NewFile(f)
check(err)
deferf.Close()
deferpefile.Close()
Listing12-14:FileI/OforPEbinary(/ch-12/peParser/main.go)
PriortoreviewingeachofthePEstructurecomponents,we
needtostubouttheinitialimport❶andfileI/Obyusingthe
GoPEpackage.Weuseos.Open()❷andthenpe.NewFile()❸to
createafilehandleandaPEfileobject,respectively.Thisis
necessarybecauseweintendtoparsethePEfilecontentsby
usingaReaderobject,suchasafileorbinaryreader.
ParsingtheDOSHeaderandtheDOSStub
Thefirstsectionofthetop-downPEdatastructureillustrated
inFigure12-6startswithaDOSheader.Thefollowingunique
valueisalwayspresentwithinanyWindowsDOS-based
executablebinary:0x4D0x5A(orMZinASCII),whichaptly
declaresthefileasaWindowsexecutable.Anothervalue
universallypresentonallPEfilesislocatedatoffset0x3C.The
valueatthisoffsetpointstoanotheroffsetcontainingthe
signatureofaPEfile:aptly,0x500x450x000x00(orPEinASCII).
TheheaderthatimmediatelyfollowsistheDOSStub,
whichalwaysprovidesthehexvaluesforThisprogramcannotberun
inDOSmode;theexceptiontothisoccurswhenacompiler’s
/STUBlinkeroptionprovidesanarbitrarystringvalue.Ifyou
takeyourfavoritehexeditorandopentheTelegram
application,itshouldbesimilartoFigure12-7.Allofthese
valuesarepresent.
Figure12-7:AtypicalPEbinaryformatfileheader
Sofar,wehavedescribedtheDOSHeaderandStubwhile
alsolookingatthehexadecimalrepresentationthroughahex
editor.Now,let’stakealookatparsingthosesamevalues
withGocode,asprovidedinListing12-15.
dosHeader:=make([]byte,96)
sizeOffset:=make([]byte,4)
//DectoAscii(searchingforMZ)
_,err=f.Read(dosHeader)❶
check(err)
fmt.Println("[-----DOSHeader/Stub-----]")
fmt.Printf("[+]MagicValue:%s%s\n",string(dosHeader[0]),
string(dosHeader[1]))❷
//ValidatePE+0+0(ValidPEformat)
pe_sig_offset:=int64(binary.LittleEndian.Uint32(dosHeader[0x3c:]))❸
f.ReadAt(sizeOffset[:],pe_sig_offset)❹
fmt.Println("[-----SignatureHeader-----]")
fmt.Printf("[+]LFANEWValue:%s\n",string(sizeOffset))
/*OUTPUT
[-----DOSHeader/Stub-----]
[+]MagicValue:MZ
[-----SignatureHeader-----]
[+]LFANEWValue:PE
*/
Listing12-15:ParsingtheDOSHeaderandStubvalues(/ch-12/peParser/main.go)
Startingfromthebeginningofthefile,weuseaGofile
Reader❶instancetoread96bytesonwardinordertoconfirm
theinitialbinarysignature❷.Recallthatthefirst2bytes
providetheASCIIvalueMZ.ThePEpackageoffers
convenienceobjectstohelpmarshalPEdatastructuresinto
somethingmoreeasilyconsumable.Itwill,however,still
requiremanualbinaryreadersandbitwisefunctionalitytoget
itthere.Weperformabinaryreadoftheoffsetvalue❸
referencedat0x3c,andthenreadexactly4bytes❹composed
ofthevalue0x500x45(PE)followedby20x00bytes.
ParsingtheCOFFFileHeader
ContinuingdownthePEfilestructure,andimmediately
followingtheDOSStub,istheCOFFFileHeader.Let’sparse
theCOFFFileHeaderbyusingthecodedefinedinListing12-
16,andthendiscusssomeofitsmoreinterestingproperties.
//CreatethereaderandreadCOFFHeader
❶sr:=io.NewSectionReader(f,0,1<<63-1)
❷_,err:=sr.Seek(pe_sig_offset+4,os.SEEK_SET)
check(err)
❸binary.Read(sr,binary.LittleEndian,&pefile.FileHeader)
Listing12-16:ParsingtheCOFFFileHeader(/ch-12/peParser/main.go)
WecreateanewSectionReader❶thatstartsfromthe
beginningofthefileatposition0andreadstothemaxvalue
ofanint64.Thenthesr.Seek()function❷resetsthepositionto
startreadingimmediately,followingthePEsignatureoffset
andvalue(recalltheliteralvaluesPE+0x00+0x00).Finally,we
performabinaryread❸tomarshalthebytesintothepefile
object’sFileHeaderstruct.Recallthatwecreatedpefileearlier
whenwecalledpe.Newfile().
TheGodocumentationdefinestypeFileHeaderwiththestruct
definedinListing12-17.Thisstructalignsquitewellwith
Microsoft’sdocumentedPECOFFFileHeaderformat
(definedathttps://docs.microsoft.com/en-
us/windows/win32/debug/pe-format#coff-file-header-object-
and-image/).
typeFileHeaderstruct{
Machineuint16
NumberOfSectionsuint16
TimeDateStampuint32
PointerToSymbolTableuint32
NumberOfSymbolsuint32
SizeOfOptionalHeaderuint16
Characteristicsuint16
}
Listing12-17:TheGoPEpackage’snativePEFileHeaderstruct
ThesingleitemtonoteinthisstructoutsideoftheMachine
value(inotherwords,thePEtargetsystemarchitecture),isthe
NumberOfSectionsproperty.Thispropertycontainsthenumberof
sectionsdefinedwithintheSectionTable,whichimmediately
followstheheaders.You’llneedtoupdatetheNumberOfSections
valueifyouintendtobackdooraPEfilebyaddinganew
section.However,otherstrategiesmaynotrequireupdating
thisvalue,suchassearchingotherexecutablesections(suchas
CODE,.text,andsoon)forcontiguousunused0x00or0xCC
values(amethodtolocatesectionsofmemorythatyoucan
usetoimplantshellcode),asthenumberofsectionsremain
unchanged.
Inclosing,youcanusethefollowingprintstatementsto
outputsomeofthemoreinterestingCOFFFileHeadervalues
(Listing12-18).
//PrintFileHeader
fmt.Println("[-----COFFFileHeader-----]")
fmt.Printf("[+]MachineArchitecture:%#x\n",pefile.FileHeader.Machine)
fmt.Printf("[+]NumberofSections:%#x\n",
pefile.FileHeader.NumberOfSections)
fmt.Printf("[+]SizeofOptionalHeader:%#x\n",
pefile.FileHeader.SizeOfOptionalHeader)
//Printsectionnames
fmt.Println("[-----SectionOffsets-----]")
fmt.Printf("[+]NumberofSectionsFieldOffset:%#x\n",pe_sig_offset+6)❶
//thisistheendoftheSignatureheader(0x7c)+coff(20bytes)+oh32
(224bytes)
fmt.Printf("[+]SectionTableOffset:%#x\n",pe_sig_offset+0xF8)
/*OUTPUT
[-----COFFFileHeader-----]
[+]MachineArchitecture:0x14c❷
[+]NumberofSections:0x8❸
[+]SizeofOptionalHeader:0xe0❹
[-----SectionOffsets-----]
[+]NumberofSectionsFieldOffset:0x15e❺
[+]SectionTableOffset:0x250❻
*/
Listing12-18:WritingCOFFFileHeadervaluestoterminaloutput(/ch-
12/peParser/main.go)
YoucanlocatetheNumberOfSectionsvaluebycalculatingthe
offsetofthePEsignature+4bytes+2bytes—inotherwords,
byadding6bytes.Inourcode,wealreadydefinedpe_sig_offset,
sowe’djustadd6bytestothatvalue❶.We’lldiscuss
sectionsinmoredetailwhenweexaminetheSectionTable
structure.
TheproducedoutputdescribestheMachineArchitecture❷
valueof0x14c:anIMAGE_FILE_MACHINE_I386asdetailedin
https://docs.microsoft.com/en-us/windows/win32/debug/pe-
format#machine-types.Thenumberofsections❸is0x8,
dictatingthateightentriesexistwithintheSectionTable.The
OptionalHeader(whichwillbediscussednext)hasavariable
lengthdependingonarchitecture:thevalueis0xe0(224in
decimal),whichcorrespondstoa32-bitsystem❹.Thelast
twosectionscanbeconsideredmoreofconvenienceoutput.
Specifically,theSectionsFieldOffset❺providestheoffsettothe
numberofsections,whiletheSectionTableOffset❻providesthe
offsetforthelocationoftheSectionTable.Bothoffsetvalues
wouldrequiremodificationifaddingshellcode,forexample.
ParsingtheOptionalHeader
ThenextheaderinthePEfilestructureistheOptional
Header.AnexecutablebinaryimagewillhaveanOptional
Headerthatprovidesimportantdatatotheloader,whichloads
theexecutableintovirtualmemory.Alotofdataiscontained
withinthisheader,sowe’llcoveronlyafewitemsinorderto
getyouusedtonavigatingthisstructure.
Togetstarted,weneedtoperformabinaryreadofthe
relevantbytelengthbasedonarchitecture,asdescribedin
Listing12-19.Ifyouwerewritingmorecomprehensivecode,
you’dwanttocheckarchitectures(forexample,x86versus
x86_64)throughoutinordertousetheappropriatePEdata
structures.
//GetsizeofOptionalHeader
❶varsizeofOptionalHeader32=uint16(binary.Size(pe.OptionalHeader32{}))
❷varsizeofOptionalHeader64=uint16(binary.Size(pe.OptionalHeader64{}))
❸varoh32pe.OptionalHeader32
❹varoh64pe.OptionalHeader64
//ReadOptionalHeader
switchpefile.FileHeader.SizeOfOptionalHeader{
casesizeofOptionalHeader32:
❺binary.Read(sr,binary.LittleEndian,&oh32)
casesizeofOptionalHeader64:
binary.Read(sr,binary.LittleEndian,&oh64)
}
Listing12-19:ReadingtheOptionalHeaderbytes(/ch-12/peParser/main.go)
Inthiscodeblock,we’reinitializingtwovariables,
sizeOfOptionalHeader32❶andsizeOfOptionalHeader64❷,with224
bytesand240bytes,respectively.Thisisanx86binary,so
we’llusetheformervariableinourcode.Immediately
followingthevariabledeclarationsareinitializationsof
pe.OptionalHeader32❸andpe.OptionalHeader64❹interfaces,which
willcontaintheOptionalHeaderdata.Finally,weperformthe
binaryread❺andmarshalittotherelevantdatastructure:the
oh32basedona32-bitbinary.
Let’sdescribesomeofthemorenotableitemsofthe
OptionalHeader.Thecorrespondingprintstatementsand
subsequentoutputareprovidedinListing12-20.
//PrintOptionalHeader
fmt.Println("[-----OptionalHeader-----]")
fmt.Printf("[+]EntryPoint:%#x\n",oh32.AddressOfEntryPoint)
fmt.Printf("[+]ImageBase:%#x\n",oh32.ImageBase)
fmt.Printf("[+]SizeofImage:%#x\n",oh32.SizeOfImage)
fmt.Printf("[+]SectionsAlignment:%#x\n",oh32.SectionAlignment)
fmt.Printf("[+]FileAlignment:%#x\n",oh32.FileAlignment)
fmt.Printf("[+]Characteristics:%#x\n",pefile.FileHeader.Characteristics)
fmt.Printf("[+]SizeofHeaders:%#x\n",oh32.SizeOfHeaders)
fmt.Printf("[+]Checksum:%#x\n",oh32.CheckSum)
fmt.Printf("[+]Machine:%#x\n",pefile.FileHeader.Machine)
fmt.Printf("[+]Subsystem:%#x\n",oh32.Subsystem)
fmt.Printf("[+]DLLCharacteristics:%#x\n",oh32.DllCharacteristics)
/*OUTPUT
[-----OptionalHeader-----]
[+]EntryPoint:0x169e682❶
[+]ImageBase:0x400000❷
[+]SizeofImage:0x3172000❸
[+]SectionsAlignment:0x1000❹
[+]FileAlignment:0x200❺
[+]Characteristics:0x102
[+]SizeofHeaders:0x400
[+]Checksum:0x2e41078
[+]Machine:0x14c
[+]Subsystem:0x2
[+]DLLCharacteristics:0x8140
*/
Listing12-20:WritingOptionalHeadervaluestoterminaloutput(/ch-
12/peParser/main.go)
AssumingthattheobjectiveistobackdooraPEfile,you’ll
needtoknowboththeImageBase❷andEntryPoint❶inorderto
hijackandmemoryjumptothelocationoftheshellcodeorto
anewsectiondefinedbythenumberofSectionTableentries.The
ImageBaseistheaddressofthefirstbyteoftheimageonceitis
loadedintomemory,whereastheEntryPointistheaddressofthe
executablecoderelativetotheImageBase.TheSizeofImage❸is
theactualsizeoftheimage,initsentirety,whenloadedinto
memory.Thisvaluewillneedtobeadjustedtoaccommodate
anyincreaseinimagesize,whichcouldhappenifyouaddeda
newsectioncontainingshellcode.
TheSectionsAlignment❹willprovidethebytealignment
whensectionsareloadedintomemory:0x1000isarather
standardvalue.TheFileAlignment❺providesthebyte
alignmentofthesectionsonrawdisk:0x200(512K)isalsoa
commonvalue.You’llneedtomodifythesevaluesinorderto
getworkingcode,andyou’llhavetouseahexeditoranda
debuggerifyou’replanningtoperformallthismanually.
TheOptionalHeadercontainsnumerousentries.Insteadof
describingeverysingleoneofthem,werecommendthatyou
explorethedocumentationathttps://docs.microsoft.com/en-
us/windows/win32/debug/pe-format#optional-header-
windows-specific-fields-image-onlytogainacomprehensive
understandingofeachentry.
ParsingtheDataDirectory
Atruntime,theWindowsexecutablemustknowimportant
information,suchashowtoconsumealinkedDLLorhowto
allowotherapplicationprocessestoconsumeresourcesthat
theexecutablehastooffer.Thebinaryalsoneedstomanage
granulardata,suchasthreadstorage.Thisistheprimary
functionoftheDataDirectory.
TheDataDirectoryisthelast128bytesoftheOptional
Headerandpertainsspecificallytoabinaryimage.Weuseit
tomaintainatableofreferencescontainingbothanindividual
directory’soffsetaddresstothedatalocationandthesizeof
thedata.Exactly16directoryentriesaredefinedwithinthe
WINNT.Hheader,whichisacoreWindowsheaderfilethat
definesvariousdatatypesandconstantstobeusedthroughout
theWindowsoperatingsystem.
Notethatnotallofthedirectoriesareinuse,assomeare
reservedorunimplementedbyMicrosoft.Theentirelistof
datadirectoriesanddetailsoftheirintendedusecanbe
referencedathttps://docs.microsoft.com/en-
us/windows/win32/debug/pe-format#optional-header-data-
directories-image-only.Again,alotofinformationis
associatedwitheachindividualdirectory,sowerecommend
youtakesometimetoreallyresearchandgetfamiliarwith
theirstructures.
Let’sexploreacoupleofdirectoryentrieswithintheData
DirectorybyusingthecodeinListing12-21.
//PrintDataDirectory
fmt.Println("[-----DataDirectory-----]")
varwinnt_datadirs=[]string{❶
"IMAGE_DIRECTORY_ENTRY_EXPORT",
"IMAGE_DIRECTORY_ENTRY_IMPORT",
"IMAGE_DIRECTORY_ENTRY_RESOURCE",
"IMAGE_DIRECTORY_ENTRY_EXCEPTION",
"IMAGE_DIRECTORY_ENTRY_SECURITY",
"IMAGE_DIRECTORY_ENTRY_BASERELOC",
"IMAGE_DIRECTORY_ENTRY_DEBUG",