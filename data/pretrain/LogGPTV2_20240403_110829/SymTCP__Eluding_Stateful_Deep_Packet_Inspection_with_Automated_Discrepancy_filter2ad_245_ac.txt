the symbolic mode. S2E also maintains a concrete value for
each symbolic variable and these will be used during concrete
execution. The concrete values are generated by constraint
solving at the ﬁrst time they are accessed in the concrete
execution. We emphasize that this is different from applying
pure concrete execution from the beginning; switching from
the symbolic to the concrete mode still retains the symbolic
variables and propagates them during concrete execution.
By default, even when running in the concrete mode, S2E
collects path constraints as the concrete branches are taken
(standard in concolic execution [4]). The reason for doing so
is that during concrete execution, only one branch is taken,
and the result is bound to that branch. However, this will
result in the previously discussed “over-constraining” problem
(in §II), i.e., forcing certain branches to be taken (because
of the concretization when switching to concrete execution).
More importantly, our focus is on the TCP code base only, and
the executions outside of our scope are irrelevant (regardless of
which paths were taken). We therefore discard any constraints
collected during the concrete execution mode. For example,
the netﬁlter module outside the TCP code base will read
the symbolic TCP header ﬁelds and introduce constraints.
However, the execution results of netﬁlter do not affect the
main TCP logic at all, and therefore we can safely ignore those
constraints. Speciﬁcally, the netﬁlter ConnTrack module tracks
the TCP connections passively and maintains connection states
separately from the main TCP logic. Therefore, its execution
is insigniﬁcant — even if we ignore its constraints and force
a different execution path, it would have no consequence on
the main TCP states we are interested in exploring.
B. Symbolizing the TCP Header and Options
destination port numbers. The symbolized ﬁelds include the
sequence number, acknowledgment number, data offset, ﬂags,
window size, checksum, and urgent pointer. In addition, we
want to symbolize TCP options, which refers to the last part
of the TCP header and has an associated variable length.
Symbolizing the TCP options ﬁeld is intrinsically hard
because it consists of a list of nested TLV (Type-Value-
Length) structures. Currently there are 35 existing TCP option
related numbers assigned by IANA [24], including those that
are standard and others that are obsolete, and the number
is growing. Some options have associated ﬁxed lengths, and
some are of variable length (e.g., SACK). Some options have
associated subtypes (e.g., MPTCP). Although the maximum
length of the TCP option ﬁeld is 40 bytes, the number of
combinations of all top-level option types is still huge. The
problem worsens if we also include illegal cases (e.g., an
option appears multiple times) or also want to consider the
ordering of the options.
Linux only implements 10 TCP options using a parsing
loop, which can still easily cause the path explosion problem.
Theoretically there are at least 210 = 1024 execution paths
even if we just execute the loop once. In practice, when
it is compiled into a binary form, additional branches are
introduced; hence, the number of possible paths is much larger.
The problem is exacerbated exponentially given the already
large number of paths that exist in the TCP logic. Because of
these reasons, we need to bound the search space by limiting
the number of possible combinations of TCP options.
While we attempted to bound the loop execution times and
the number of occurrences of each TCP option, we found that
the number of paths was still prohibitively large even if we
executed the loop just once and allowed each option to occur
at most once. Hence, as a practical means to mitigate this
problem, in addition to bounding the execution times, we also
feed a speciﬁc combination of TCP options as a seed (from
trafﬁc observed on the Internet) to our concolic execution
engine; the execution explores our seed value ﬁrst and then
other values.
C. Abstracting the Checksum Function
The TCP checksum is calculated based on a pseudo-header
that includes the IP addresses, the entire TCP header and the
payload. As mentioned earlier, we do not want to symbolize
the IP header or the payload since this is likely to harm the
symbolic execution performance. Thus, instead, we abstract
the checksum validation function as follows:
if header.checksum == 1
if header.checksum == 0
(cid:26)true
f alse
f (pkt) =
Fig. 5. Symbolized TCP header and options.
Since we limit our scope to TCP-level insertion and evasion
packets, we only symbolize the TCP header of a packet (not
the IP header or the application payload) (see Figure 5).
We symbolize all TCP header ﬁelds except the source and
7
where f denotes the checksum validation function and pkt
is the network packet under consideration. If the checksum
ﬁeld in the TCP header is equal to 1, then it is considered to
be a valid checksum; if it is equal to 0, then it is an invalid
checksum. The constraint solver thus generates a checksum of
1 for a valid checksum case, and 0 for an invalid checksum
case. When we probe the DPI (discussed later), we ﬁll the
checksum ﬁeld with either the proper valid or an invalid check-
sum, correspondingly. By abstracting the checksum function,
Destination PortSource PortSequence NumberAcknowledgment NumberDataOffsetCWRReservedWindow SizeChecksumUrgent PointerOptions (if any)ECEURGACKPSHRSTSYNFIN0816322420 bytesn byteswe avoid solving complex constraints on the TCP header ﬁelds
and thus improve performance.
D. Symbolizing the Server’s Initial Sequence Number
During TCP’s 3-way handshake, the server’s initial se-
quence number (ISN) is a random number generated and
sent in the SYN/ACK packet to the client. When the client
receives the SYN/ACK packet, it needs to echo the server’s
ISN by sending an ACK packet with an acknowledgment
number that is equal to the server’s ISN plus 1. Because the
server’s ISN is randomly generated for each TCP connection,
we need to symbolize the server’s ISN in the ofﬂine symbolic
execution phase and collect the path constraint that expresses
the relationship between the server’s ISN and the client’s
acknowledgment number. Then in the online probing phase
(§VI), we constrain the server’s ISN using the concrete value
obtained from the SYN/ACK packet, and generate concrete
values for the client’s packets on the ﬂy.
E. Multi-round Symbolic Execution
As mentioned earlier in §IV, we start our symbolic execu-
tion from the LISTEN state. We symbolize multiple packets
in order to explore the state machine in more depth (up to the
ESTABLISHED state). Speciﬁcally, we choose to symbolize
3 packets in total for several reasons. First, 3 packets should
offer a reasonable coverage of the TCP state machine because
only 2 packets are needed to advance the TCP state from
LISTEN to ESTABLISHED (the SYN and ACK in a three-
way handshake); the third packet can further explore other
minor states in ESTABLISHED. Second, we prefer shorter
sequences of insertion and evasion packets as longer sequences
can be unreliable in practice (e.g., due to packet losses).
To explore different sequences of packets, we develop a
custom path searcher/scheduler to guide S2E to explore packet
sequences of 1 and 2 ﬁrst (up to certain threshold), and then
allow the third packet to arrive.
As discussed later in §VIII, even though there are not many
accept and drop points in TCP, the number of possible accept
and drop paths is exponential and impossible to exhaust in our
experiments, which motivated our search strategy to balance
the exploration of sequences of different lengths.
VI. GENERATING ONLINE EVASION ATTACKS
By means of the ofﬂine concolic execution phase described
in §V, SYMTCP obtains path constraints that can be used to
generate insertion/evasion packet candidates. In this section,
we describe SYMTCP’s differential testing phase to probe the
DPI to identify behavioral discrepancies between the DPI’s
TCP implementation and that of the server.
A. Constructing insertion/evasion packet candidates
Armed with the constraints relating to each execution path
collected during the symbolic execution, as described in §V,
together with some additional constraints, we can then feed
these to a constraint solver to generate concrete values of
TCP header ﬁelds. Using those values, SYMTCP constructs
a sequence of packets, P1...n(n ≤ 3), to probe the DPI.
There are two additional constraints. The ﬁrst is the server’s
initial sequence number (ISN) as mentioned in §V-D. The
second includes additional constraints on TCP ﬂags, SEQ and
ACK numbers. These are especially necessary for candidate
insertion packets when a packet hits a drop point early (and
practically most ﬁelds are unconstrained). For example, if a
packet is dropped because of an unsolicited MD5 TCP option,
then it has no constraint on TCP ﬂags, SEQ or ACK number.
Since the hope is that the error is ignored by the DPI (not
checking the MD5 TCP option), these other ﬁelds will have a
direct effect on how the DPI processes the packet. Our solution
in such cases is to generate these constraints to make the
packet as legitimate as possible (i.e., with the correct SEQ
and ACK number). For TCP ﬂags, we just enumerate the
most common ones, which are more likely to be accepted
by the DPI (SYN, SYN/ACK, ACK, RST, RST/ACK, FIN,
FIN/ACK). For example, we may generate a RST packet with
an unsolicited MD5 option (with the additional constraint of
the SEQ number to match the next expected one). The server
of course will reject the packet but the DPI will accept it and
terminate the connection incorrectly, allowing subsequent data
to pass through unchecked. For candidate evasion packets, we
do the opposite by generating random values of various ﬁelds
and hope that it will be ignored by the DPI. Note that since
an evasion packet is to be accepted by the server, most of the
ﬁelds are already constrained and so we do not have much
room to select the values of different ﬁelds.
B. Constructing follow-up probe packets
As mentioned in §III-B, after sending a candidate evasion
or insertion packet, we may still need to craft additional follow-
up packets that contain bad keywords targeted by the DPI, in
order to infer if there is any state discrepancy between the DPI
and server (otherwise there is no observable feedback).
To construct follow-up packets, we need to know the
current state of the TCP connection. If the current TCP state
is not in the ESTABLISHED state, we need to send packets
that cause it to transition into it. If the current TCP state is
already the ESTABLISHED state, then we can directly send
the data packet with the correct sequence and acknowledgment
number. Due to this reason, we log the current TCP state after
processing each packet during symbolic execution. Based on
this, we use a simpliﬁed version of the TCP state machine to
generate the follow-up packets for transitioning the connection
from the speciﬁc TCP state to the ESTABLISHED state if need
be. Subsequently, we send a data packet with the sensitive
payload, and observe if it triggers any alarm on the DPI.
VII.
IMPLEMENTATION
Our system is built upon S2E 2.0 [17], which uses KLEE
as its symbolic execution engine. We implement SYMTCP as
a set of S2E plugins written with around 2.5K lines of C++,
and the probing and peripheral scripts were written with around
6.5K lines of Python.
A. Selective Concolic Execution
We start
the selective concolic execution whenever
tcp_v4_rcv() is entered, where the TCP header ﬁelds are
symbolized. When the current program counter is outside the
8
TCP scope, i.e., it leaves the tcp_v4_rcv function or it
wades into some other territory (e.g., netﬁlter), we disable
forking to let S2E run in a way similar to concrete execution,
except that it still maintains and propagates symbolic variables.
In this way, we can switch from symbolic execution to concrete
execution and later switch back to symbolic execution again. In
addition, we modify KLEE to prevent it from adding branch
conditions to the path constraints when forking is disabled;
thus, it does not over-constrain the symbolic variables.
S2E only instruments basic blocks and instructions but
not the edges connecting basic blocks. However, in Linux
TCP implementations, often it is the edge that determines the
reason for acceptance or rejection; for example, an if and
goto statement can enter the same exact basic block, but
representing different reasons (acceptance or rejection). Thus,
we also instrument the edges and implement an event. Finally,
we bound the number of loops that can be traversed and the
number of occurrences of TCP options, by limiting the number
of executions of related edges of interest — we allow at most
5 TCP options in a packet, and each TCP option only occurs
once, except the NOP option. We do not encounter any other
loops where the number of iterations is symbolic.
B. Online Constraint Solving
We use the state-of-the-art Z3 [50] theorem prover as
our online constraint solver to generate concrete values of
TCP header ﬁelds. As mentioned previously, if we receive
a SYN/ACK packet from the server, we then add its initial
sequence number to the constraint and consult Z3 again to gen-
erate new concrete values for the following probing packets.
This is because the following packets will need to acknowledge
that number. Note that when we consult the constraint solver
multiple times (to generate subsequent packets), we need to
carry over the concrete values generated for the previous
packets in order to maintain consistency. For example, the
ﬁrst packet has a payload of 4 bytes, and the second packet’s
sequence number needs to advance by 4.
VIII. EVALUATION
Our evaluations of SYMTCP are run on an server with
72 cores Intel(R) Xeon(R) CPU E5-2695 v4 @ 2.10GHz, and
256GB memory. The host OS is Ubuntu 16.04 64-bit, and the
guest OS is Debian 9.2.1 64-bit. We evaluate our system with
Linux kernel version 4.9.3. We run S2E in parallel mode with
48 cores, which is the maximum number of processes S2E
currently supports.
A. Experiment Setup
Before evaluating the system, we ﬁrst manually label all
the drop points reachable from tcp v4 rcv() which is the
TCP-level entry function for processing incoming packets.
Speciﬁcally, in the Linux kernel, since an incoming packet will
kfree skb(),
eventually be freed after being processed via
we inspect all invocations of it in the TCP implementation
(both direct and indirect through wrapper functions kfree skb
and tcp drop), and identify the program points or the branch
statements (transitions between basic blocks such as if) that
satisfy the deﬁnition of a drop point (see §III-B).
TABLE I.
A SUMMARY OF LABELED DROP POINTS
Reason
TCP checksum error
TCP header length too small
TCP header length too large
MD5 option error
TCP ﬂags invalid
SEQ number invalid
ACK number invalid
Challenge ACK
Receive window closed
Empty data packet
Data overlap in OFO queue
PAWS check failed
Embryonic reset
TCP DEFER ACCEPT drop bare ACK
TCP Fastopen check request failed
Total number
Count
5
1
4
2
7
10
3
6
2
1
1
2
1
1
1
47
TABLE II.
PERFORMANCE OF OFFLINE SYMBOLIC EXECUTION
# of
pkts
20-byte TCP pkts
Time
Covered
40-byte TCP pkts
Time
Covered
60-byte TCP pkts
Time
Covered
1
2
3
Time cost could vary due to randomness in path selection of symbolic execution.
to cover
10s
18m
40m
drop points
8