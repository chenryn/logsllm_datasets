# 浅谈 weblogic CVE-2020-2551 漏洞 & 外网POC构造
|
##### 译文声明
本文是翻译文章
译文仅供参考，具体内容表达以及含义原文为准。
## 0x00 基础概念
学习这个漏洞需要一些前置知识，比如CORBA与RMI
简单的概述一下：
CORBA是OMG制定的一套技术标准，用于分布式应用，其中用到了IDL进行跨语言支持，客户端与服务端之间用IIOP协议进行通信
RMI是另一种分布式应用技术，在JAVA中可以用JNDI进行简化应用，客户端与服务端使用JRMP协议进行通信，不过在weblogic中RMI使用的是T3协议，关于这个之前也爆出过不少[漏洞](https://blog.knownsec.com/2018/04/weblogic-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9Ecve-2018-2628%E6%BC%AB%E8%B0%88/)
[RMI-IIOP](https://docs.oracle.com/javase/8/docs/technotes/guides/rmi-iiop/tutorial.html#7738)结合了RMI与CORBA各自的优点，通过IIOP协议部署RMI应用
[官方文档](https://docs.oracle.com/javase/8/docs/technotes/guides/rmi-iiop/rmi_iiop_pg.html)也提到：
RMI server objects can use the IIOP protocol and communicate with CORBA client
objects written in any language
## 0x01 RMI-IIOP
暂时不提weblogic，先关注一下如何编写一个RMI-IIOP实例：
客户端代码可以参考[Java 中
RMI、JNDI、LDAP、JRMP、JMX、JMS那些事儿（上）](https://paper.seebug.org/1091/#weblogic-rmi)中的[测试项目](https://github.com/longofo/rmi-jndi-ldap-jrmp-jmx-jms/tree/master/rmi-iiop)，可以自己编译HelloClient和HelloServer，也可以用测试项目中编译好的
在命令行启动名称服务器（java自带）：
    start orbd -ORBInitialPort 1050
命令行开启服务端HelloServer并配置远程调试，关于如何用IDEA进行远程调试，可以参考[这里](https://www.anquanke.com/post/id/201762)开头提到的方法
    java -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=5005 HelloServer
当然不远程调试直接看结果也行，直接启动
    java HelloServer
命令行开启客户端
    Java HelloClient
此时会弹出计算器，成功远程调试的话，可以看到如下调用栈
EvilMessage.readObejct()中执行命令
题外话：weblogic的[安装](https://badcode.cc/2018/05/20/WebLogic-%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/)与[调试](https://badcode.cc/2018/05/20/WebLogic-%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/)文章
那么weblogic中的RMI-IIOP呢？[关于 Java 中的 RMI-IIOP](https://paper.seebug.org/1105/)这篇文章中有提到关于weblogic RMI-IIOP的利用，在它的基础上进行了一些研究，[Using WebLogic’s RMI over
IIOP](https://www.oreilly.com/library/view/weblogic-the-definitive/059600432X/ch04s04.html)讲到几种weblogic使用RMI-IIOP客户端的几种方式，包括：
1.独立RMI客户端（配合jndi，不使用weblogic的任何东西）  
2.WebLogic客户端  
3.J2EE clients  
4.CORBA/IDL clients
前两种方式的区别，看来只是JNDI_FACTORY设置上的区别
之前研究weblogic
T3反序列化的时候，在weblogic上部署过Helloserver应用，有sayhello()方法可以利用，尝试设置两种JNDI_FACTORY调用一下，使用第二种JNDI_FACTORY成功调用sayHello()方法
那么修改一下weblogic T3协议的[POC](https://github.com/longofo/rmi-jndi-ldap-jrmp-jmx-jms/blob/master/weblogic-rmi-client/src/main/java/com/longofo/weblogicrmi/Payload1.java)，其实只是把RMI修改为了IIOP，发现jtaTransactionManager利用链执行成功，向本地jrmplisten发出了jrmp请求
看一下流量，在remove()方法调用时，发送remove__java_lang_Object请求，流量中有恶意数据，但没有找到aced魔术头
猜测在服务端进行了特殊的解析后，再反序列化数据，看一下调用栈，可以看到后半部分的执行链跟前面原生RMI-IIOP的执行链很像，前面是从CDRInputStream.read_value()触发，这里是从weblogic中IIOPInputStream.read_value()触发，(read_value这个点，在[19年的议题](https://i.blackhat.com/eu-19/Wednesday/eu-19-An-Far-Sides-Of-Java-Remote-Protocols.pdf)上也提到了)
这里请求会首先给clusterableServerRef.invoke()处理，根据不同的invoker调用this.invoker.invoke()，然后这里调用了Mejb_dj5nps_HomeImpl_WLSkel.invoke()，因为是“remove”，所以进入case
6分支调用IIOPInputStream.readObject()，在read_value()方法中解析IIOPInputStream数据并触发反序列化，这个就是利用remove()方法的POC
## 0x02 CVE-2020-2551
Lucifaer师傅的分析[文章](https://lucifaer.com/2020/02/25/WebLogic%20WLS%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6RCE%E5%88%86%E6%9E%90%EF%BC%88CVE-2020-2551%EF%BC%89/?from=timeline&isappinstalled=0#2-2-Weblogic%E8%A7%A3%E6%9E%90%E6%B5%81%E7%A8%8B)提到了用bind()方法进行利用，这个也是互联网上主流的利用方式，跟一下调用栈
跟前面一样，这里请求会首先给clusterableServerRef.invoke()处理，根据不同的invoker调用this.invoker.invoke()，这里调用了CobraServerRef.invoke()，然后在