could represent a filtering condition as a complete sentence, such as the 
one shown in Figure 7-5.
equal to
Field key
Condition
value
remote TCP port
If the
is
445 
block the connection
Match 
type
Action
,
.
Figure 7-5: Filtering conditions
At this point, we have our rule’s basic “if this, do that” logic,  
but we have yet to deal with some other conditions related to filter 
arbitration.
Assigning Weights and Sublayers
What if our driver has filters to, say, both permit traffic on TCP port 1080 
and block outbound connections on TCP ports greater than 1024? To 
handle these conflicts, we must assign each filter a weight. The greater the 
weight, the higher the priority of the condition, and the earlier it should 
be evaluated. For instance, the filter allowing traffic on port 1080 should 
be evaluated before the one blocking all traffic using ports higher than 
1024 to permit software using port 1080 to function. In code, a weight is 
just an FWP_VALUE (UINT8 or UINT64) assigned in the weight member of the 
FWPM_FILTER structure.
In addition to assigning the weight, we need to assign the filter to a 
sublayer so that it is evaluated at the correct time. We do this by specify-
ing a GUID in the layerKey member of the structure. If we created our own 
sublayer, we would specify its GUID here. Otherwise, we’d use one of the 
default sublayer GUIDs listed in Table 7-1.
Evading EDR (Early Access) © 2023 by Matt Hand
134   Chapter 7
Table 7-1: Default Sublayer GUIDs
Filter sublayer identifier
Filter type
FWPM_SUBLAYER_EDGE_TRAVERSAL (BA69DC66-5176-
4979-9C89-26A7B46A8327)
Edge traversal
FWPM_SUBLAYER_INSPECTION (877519E1-E6A9-41A5-
81B4-8C4F118E4A60)
Inspection
FWPM_SUBLAYER_IPSEC_DOSP (E076D572-5D3D-48EF-
802B-909EDDB098BD)
IPsec denial-of-service (DoS) 
protection
FWPM_SUBLAYER_IPSEC_FORWARD_OUTBOUND_
TUNNEL (A5082E73-8F71-4559-8A9A-101CEA04EF87)
IPsec forward outbound tunnel
FWPM_SUBLAYER_IPSEC_TUNNEL (83F299ED-9FF4-
4967-AFF4-C309F4DAB827)
IPsec tunnel
FWPM_SUBLAYER_LIPS (1B75C0CE-FF60-4711-A70F-
B4958CC3B2D0)
Legacy IPsec filters
FWPM_SUBLAYER_RPC_AUDIT (758C84F4-FB48-4DE9-
9AEB-3ED9551AB1FD)
Remote procedure call (RPC) audit
FWPM_SUBLAYER_SECURE_SOCKET (15A66E17-3F3C-
4F7B-AA6C-812AA613DD82)
Secure socket
FWPM_SUBLAYER_TCP_CHIMNEY_OFFLOAD (337608B9-
B7D5-4D5F-82F9-3618618BC058)
TCP Chimney Offload
FWPM_SUBLAYER_TCP_TEMPLATES (24421DCF-0AC5-
4CAA-9E14-50F6E3636AF0)
TCP template
FWPM_SUBLAYER_UNIVERSAL (EEBECC03-CED4-4380-
819A-2734397B2B74)
Those not assigned to any other 
sublayers
Note that the FWPM_SUBLAYER_IPSEC_SECURITY_REALM sublayer identifier is 
defined in the fwpmu.h header but is undocumented.
Adding a Security Descriptor
The last parameter we can pass to fwpuclnt!FwpmFilterAdd() is a security 
descriptor. While optional, it allows the developer to explicitly set the access 
control list for their filter. Otherwise, the function will apply a default value 
to the filter. This default security descriptor grants GenericAll rights to mem-
bers of the Local Administrators group, and GenericRead, GenericWrite, and 
GenericExecute rights to members of the Network Configuration Operators 
group, as well as the diagnostic service host (WdiServiceHost), IPsec policy 
agent (PolicyAgent), network list service (NetProfm), remote procedure call 
(RpcSs), and Windows firewall (MpsSvc) services. Lastly, FWPM_ACTRL_OPEN and 
FWPM_ACTRL_CLASSIFY are granted to the Everyone group.
After the call to fwpuclnt!FwpmFilterAdd() completes, the callout driver 
has been initialized, and it will process events until the driver is ready to 
be unloaded. The unloading process is outside the scope of this chapter, as 
it is largely irrelevant to security monitoring, but it closes all the previously 
opened handles, deletes created sublayers and filters, and safely removes 
the driver.
Evading EDR (Early Access) © 2023 by Matt Hand
Network Filter Drivers   135
Detecting Adversary Tradecraft with Network Filters
The bulk of the telemetry that a WFP filter driver collects comes from its 
callouts. These are most often classify callouts, which receive information 
about the connection as input. From this data, developers can extract 
telemetry useful for detecting malicious activity. Let’s explore these func-
tions further, starting with their definition in Listing 7-9.
FWPS_CALLOUT_CLASSIFY_FN2 FwpsCalloutClassifyFn2;
void FwpsCalloutClassifyFn2(
 [in] 
const FWPS_INCOMING_VALUES0 *inFixedValues,
 [in] 
const FWPS_INCOMING_METADATA_VALUES0 *inMetaValues,
 [in, out, optional] void *layerData,
 [in, optional] 
const void *classifyContext,
 [in] 
const FWPS_FILTER2 *filter,
 [in] 
UINT64 flowContext,
 [in, out] 
FWPS_CLASSIFY_OUT0 *classifyOut
)
{. . .}
Listing 7-9: The FwpsCalloutClassifyFn definition
On invocation, the callout receives pointers to a few structures con-
taining interesting details about the data being processed. These details 
include the basic network information you’d expect to receive from any 
packet-capturing application (the remote IP address, for example) and 
metadata that provides additional context, including the requesting pro-
cess’s PID, image path, and token.
In return, the callout function will set the action for the stream-layer 
shim to take (assuming the packet being processed is in the stream layer), 
as well as an action for the filter engine to take, such as to block or allow the 
packet. It might also defer the decision-making to the next registered callout 
function. We describe this process in greater detail in the following sections.
The Basic Network Data
The first parameter, a pointer to an FWPS_INCOMING_VALUES structure, is 
defined in Listing 7-10 and contains information about the connection that 
has been passed from the filter engine to the callout.
typedef struct FWPS_INCOMING_VALUES0_ {
 UINT16  
layerId;
 UINT32  
valueCount;
 FWPS_INCOMING_VALUE0 *incomingValue;
} FWPS_INCOMING_VALUES0;
Listing 7-10: The FWPS_INCOMING_VALUES structure
The first member of this structure contains the identifier of the filter 
layer at which the data was obtained. Microsoft defines these values (for 
example, FWPM_LAYER_INBOUND_IPPACKET_V4).
Evading EDR (Early Access) © 2023 by Matt Hand
136   Chapter 7
The second member contains the number of entries in the array 
pointed to by the third parameter, incomingValue. This is an array of  
FWPS_INCOMING_VALUE structures containing the data that the filter engine 
passes to the callout. Each structure in the array has only an FWP_VALUE struc-
ture, shown in Listing 7-11, that describes the type and value of the data.
typedef struct FWP_VALUE0_ {
 FWP_DATA_TYPE type;
 union {
  UINT8 
uint8;
  UINT16 
uint16;
  UINT32 
uint32;
  UINT64 
*uint64;
  INT8 
int8;
  INT16 
int16;
  INT32 
int32;
  INT64 
*int64;
  float 
float32;
  double 
*double64;
  FWP_BYTE_ARRAY16 
*byteArray16;
  FWP_BYTE_BLOB 
*byteBlob;
  SID 
*sid;
  FWP_BYTE_BLOB 
*sd;
  FWP_TOKEN_INFORMATION *tokenInformation;
  FWP_BYTE_BLOB 
*tokenAccessInformation;
  LPWSTR 
unicodeString;
  FWP_BYTE_ARRAY6 
*byteArray6;
};
} FWP_VALUE0;
Listing 7-11: The FWP_VALUE structure definition
To access the data inside the array, the driver needs to know the index 
at which the data resides. This index varies based on the layer identifier 
being processed. For instance, if the layer is FWPS_LAYER_OUTBOUND_IPPACKET_
V4, the driver would access fields based on their index in the FWPS_FIELDS 
_OUTBOUND_IPPACKET_V4 enumeration, defined in Listing 7-12.
typedef enum FWPS_FIELDS_OUTBOUND_IPPACKET_V4_ {
 FWPS_FIELD_OUTBOUND_IPPACKET_V4_IP_LOCAL_ADDRESS,
 FWPS_FIELD_OUTBOUND_IPPACKET_V4_IP_LOCAL_ADDRESS_TYPE,
 FWPS_FIELD_OUTBOUND_IPPACKET_V4_IP_REMOTE_ADDRESS,
 FWPS_FIELD_OUTBOUND_IPPACKET_V4_IP_LOCAL_INTERFACE,
 FWPS_FIELD_OUTBOUND_IPPACKET_V4_INTERFACE_INDEX,
 FWPS_FIELD_OUTBOUND_IPPACKET_V4_SUB_INTERFACE_INDEX,
 FWPS_FIELD_OUTBOUND_IPPACKET_V4_FLAGS,
 FWPS_FIELD_OUTBOUND_IPPACKET_V4_INTERFACE_TYPE,
 FWPS_FIELD_OUTBOUND_IPPACKET_V4_TUNNEL_TYPE,
 FWPS_FIELD_OUTBOUND_IPPACKET_V4_COMPARTMENT_ID,
 FWPS_FIELD_OUTBOUND_IPPACKET_V4_MAX
} FWPS_FIELDS_OUTBOUND_IPPACKET_V4;
Listing 7-12: The FWPS_FIELDS_OUTBOUND_IPPACKET_V4 enumeration
Evading EDR (Early Access) © 2023 by Matt Hand
Network Filter Drivers   137
For example, if an EDR’s driver wanted to inspect the remote IP 
address, it could access this value using the code in Listing 7-13.
if (inFixedValues->layerId == FWPS_LAYER_OUTBOUND_IPPACKET_V4)
{
UINT32 remoteAddr = inFixedValues->
incomingValues[FWPS_FIELD_OUTBOUND_IPPACKET_V4_IP_REMOTE_ADDRESS].value.uint32;
--snip--
}
Listing 7-13: Accessing the remote IP address in the incoming values
In this example, the EDR driver extracts the IP address by referencing 
the unsigned 32-bit integer (uint32) value at the index FWPS_FIELD_OUTBOUND 
_IPPACKET_V4_IP_REMOTE_ADDRESS in the incoming values.
The Metadata
The next parameter that the callout function receives is a pointer to an 
FWPS_INCOMING_METADATA_VALUES0 structure, which provides incredibly valuable 
metadata to an EDR, beyond the information you’d expect to get from a 
packet-capture application such as Wireshark. You can see this metadata in 
Listing 7-14.
typedef struct FWPS_INCOMING_METADATA_VALUES0_ {
 UINT32 
currentMetadataValues;
 UINT32 
flags;
 UINT64 
reserved;
 FWPS_DISCARD_METADATA0 
discardMetadata;
 UINT64 
flowHandle;
 UINT32 
ipHeaderSize;
 UINT32 
transportHeaderSize;
 FWP_BYTE_BLOB 
*processPath;
 UINT64 
token;
 UINT64 
processId;
 UINT32 
sourceInterfaceIndex;
 UINT32 
destinationInterfaceIndex;
 ULONG 
compartmentId;
 FWPS_INBOUND_FRAGMENT_METADATA0 fragmentMetadata;
 ULONG 
pathMtu;
 HANDLE 
completionHandle;
 UINT64 
transportEndpointHandle;
 SCOPE_ID 
remoteScopeId;
 WSACMSGHDR 
*controlData;
 ULONG 
controlDataLength;
 FWP_DIRECTION 
packetDirection;
 PVOID 
headerIncludeHeader;
 ULONG 
headerIncludeHeaderLength;
 IP_ADDRESS_PREFIX 
destinationPrefix;
 UINT16 
frameLength;
 UINT64 
parentEndpointHandle;
Evading EDR (Early Access) © 2023 by Matt Hand
138   Chapter 7
 UINT32 
icmpIdAndSequence;
 DWORD 
localRedirectTargetPID;
 SOCKADDR 
*originalDestination;
 HANDLE 
redirectRecords;
 UINT32 
currentL2MetadataValues;
 UINT32 
l2Flags;
 UINT32 
ethernetMacHeaderSize;
 UINT32 
wiFiOperationMode;
 NDIS_SWITCH_PORT_ID 
vSwitchSourcePortId;
 NDIS_SWITCH_NIC_INDEX 
vSwitchSourceNicIndex;
 NDIS_SWITCH_PORT_ID 
vSwitchDestinationPortId;
 UINT32 
padding0;
 USHORT 
padding1;
 UINT32 
padding2;
 HANDLE 
vSwitchPacketContext;
 PVOID 
subProcessTag;
 UINT64 
reserved1;
} FWPS_INCOMING_METADATA_VALUES0;
Listing 7-14: The FWPS_INCOMING_METADATA_VALUES0 structure definition
We mentioned that one of the main benefits to monitoring network traf-
fic on each endpoint is the context that this approach provides to the EDR. 
We can see this in the processPath, processId, and token members, which give 
us information about the endpoint process and the associated principal.
Note that not all values in this structure will be populated. To see 
which values are present, the callout function checks the currentMetadata 
Values member, which is a bitwise-OR of a combination of metadata filter 
identifiers. Microsoft nicely provided us with a macro, FWPS_IS_METADATA_FIELD 
_PRESENT(), that will return true if the value we’re interested in is present.
The Layer Data
After the metadata, the classify function receives information about the 
layer being filtered and the conditions under which the callout is invoked. 
For example, if the data originates from the stream layer, the parameter 
will point to an FWPS_STREAM_CALLOUT_IO_PACKET0 structure. This layer data con-
tains a pointer to an FWPS_STREAM_DATA0 structure, which contains flags that 
encode the characteristics of the stream (for example, whether it is inbound 
or outbound, whether it is high priority, and whether the network stack will 
pass the FIN flag in the final packet). It will also contain the offset to the 
stream, the size of its data in the stream, and a pointer to a NET_BUFFER_LIST 
that describes the current portion of the stream.
This buffer list is a linked list of NET_BUFFER structures. Each structure 
in the list contains a chain of memory descriptor lists used to hold the data 
sent or received over the network. Note that if the request didn’t originate 
from the stream layer, the layerData parameter will point only to a  
NET_BUFFER_LIST, assuming it is not null.