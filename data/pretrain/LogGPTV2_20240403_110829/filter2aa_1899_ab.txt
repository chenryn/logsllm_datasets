3.
destroying the kmsg leads to msg_port destruction
ipc_kmsg_clean_body
ipc_kmsg_clean
ipc_kmsg_destroy
ipc_object_destroy
ipc_port_release_receive
ipc_port_destroy
ipc_port_destroy
• How to destroy the special_reply_port? There is a simpliﬁed version!
kdata.sync_inheritor_port
kdata.ip_imp_task
…
special_reply_port 
io_references
dst_port 
io_bits
io_references
io_bits
ip_tempowner=1
☜ kdata is a union
What happened?
• How to destroy the special_reply_port? There is a simpliﬁed version!
kdata.sync_inheritor_port
kdata.ip_imp_task
…
special_reply_port 
io_references
dst_port 
io_bits
io_references
io_bits
ip_tempowner=1
ipc_importance_task_release(dst_port)!
ipc_importance_task_release
A type confusion between ipc_port and ipc_importance_task_t!
Consequence of the type confusion
• ipc_importance_task_release leads to iie_bits decrement
io_references
dst_port 
io_bits
iie_made
ipc_importance_task_t 
iie_bits
ipc_importance_task_release(dst_port) leads to decrement of 
dst_port’s io_bits
How the panic happened
IO_BITS_ACTIVE          0x80000000      /* is object alive? */
kdata.sync_inheritor_port
kdata.ip_imp_task
…
special_reply_port 
io_references
dst_port 
0x80000000
io_references
io_bits
ip_tempowner=0
kdata.sync_inheritor_port
kdata.ip_imp_task
…
special_reply_port 
io_references
dst_port 
0x80000000
io_references
io_bits
ip_tempowner=1
How the panic happened
kdata.sync_inheritor_port
kdata.ip_imp_task
…
special_reply_port 
io_references
dst_port 
0x7fffffff
io_references
io_bits
ip_tempowner=1
How the panic happened
destroyed by 
ipc_port_destroy
io_bits decrement due 
to the type confusion
kdata.sync_inheritor_port
kdata.ip_imp_task
…
special_reply_port 
io_references
dst_port 
0x7fffffff
io_references
io_bits
ip_tempowner=1
How the panic happened
trigger the inactive port panic
io_bits decrement due 
to the type confusion
Now forget about the vulnerability, 
just remember: 
A short wrap-up
this piece of code will decrease dst_port’s io_bits by 1
Decrease More! 
this piece of code will decrease dst_port’s io_bits from from to to.
e.g., change a voucher port to a userclient port, and use it as a userclient port
The exploits
Recall our pool
Roughly speaking, we can change port types from higher to lower, and then 
confuse kernel objects from the higher to the lower
Limitations
• Some port types are not implemented in the kernel
• e.g., IKOT_XMM_*
• convert_port_to_* may have extra checks on the kernel objects to prevent 
type confusions
• e.g., convert_port_to_task has the zone_id_require check for the task 
object
Attack 1: (in)direct function pointers
vtable
iouserclient 
retainCount
…
userLandNotiﬁcationKey
UNDReply 
Callback
Lock
…
cl_service
clock 
cl_ops
cl_control
Many kernel objects 
contain (in)direct 
function pointers 
If we have a kernel object 
with controllable value at 
any gray offsets, we can cast 
its port to the target type, 
and then hijack the control 
ﬂow on pre-PAC devices.
…
ideal object  
Controllable value 
Controllable value 
…
Attack 2: info leak via processor_info() 
• convert_port_to_processor only performs a type check
Attack 2: info leak via processor_info() 
• processor_info() fetches CPU information according to the cpu_id value in 
the processor object  (at offset 76)
Attack 2: info leak via processor_info() 
• We have a perfect suitable object that has fully controllable value at offset 
76 — semaphore!
…
semaphore 
task_link
ref_count
+0
count
active
+72
+76
Attack 2: info leak via processor_info() 
Base + arbitrary offset
Attack 3: steal IOUserClients
• In the past, a common attack path against the kernel is:
• Achieve ROP/JOP execution in a system service within a less restrictive sandbox 
• Open an IOUserclient and then exploit kernel vulnerabilities in the kernel extension 
• This way is getting harder and harder now
• More and more system services cannot open any IOUserclients unless they have the com.apple.security.iokit-user-
client-class entitlement
• More and more IOUserclients require the creator task owns dedicated entitlements 
• Besides, IOUserclient ports cannot be sent across tasks 
Attack 3: steal IOUserClients
Task
IORegistryGetRootEntry
 IORegistryEntryGetChildIterator
 IOIteratorNext                                 
IORegistryEntry
Root
Other IOService 
Instances …
AppleCamIn
AppleKeyStore
AppleCamInUserClient
(Applecamerad)
AppleKeyStoreUserClient
(keybagd)
AppleKeyStoreUserClient
(containermanagerd)
A simpliﬁed IOServices Tree
Attack 3: steal IOUserClients
Task
IORegistryGetRootEntry
 IORegistryEntryGetChildIterator
 IOIteratorNext                                 
IORegistryEntry
Root
Other IOService 
Instances …
AppleCamIn
AppleKeyStore
AppleCamInUserClient
(Applecamerad)
AppleKeyStoreUserClient
(keybagd)
AppleKeyStoreUserClient
(containermanagerd)
A simpliﬁed IOServices Tree
Task
IORegistryGetRootEntry
 IORegistryEntryGetChildIterator
 IOIteratorNext                                 
IORegistryEntry
Root
Other IOService 
Instances …
AppleCamIn
AppleKeyStore
AppleCamInUserClient
(Applecamerad)
AppleKeyStoreUserClient
(keybagd)
AppleKeyStoreUserClient
(containermanagerd)
A simpliﬁed IOServices Tree
send right to the user 
client with port type 
IKOT_IOKIT_OBJECT 
Attack 3: steal IOUserClients
IKOT_IOKIT_OBJECT limits the IOUserClient instance to expose 
only the IOService interfaces, rather than its IOUserClient interfaces
Attack 3: steal IOUserClients
• We can change IKOT_IOKIT_OBJECT to IKOT_IOKIT_CONNECT!
• We can traverse the IOService tree and use any IOUserclient instance freely 
• Many “low-hanging fruit” vulnerabilities in some “well-protected” 
IOUserClient interfaces
• Many IOUserClient instances (especially on macOS) that have powerful 
enough capabilities to manipulate the devices, without the need of 
memory corruptions 
Attack 3: steal IOUserClients
• Example 1: AppleH10CamInUserClient
• Require the com.apple.camera.iokit-user-access entitlement to create a new 
AppleH10CamInUserClient instance
• But we now freely use the exiting instances
• Selector 77 triggers a stack overﬂow
A special note: the vulnerable kernel function only uses PACIBSP to protect the return 
address, but doesn’t use the stack guard. As a result, the stack overﬂow can overwrite 
the registers spilled to the stack. 
Attack 3: steal IOUserClients
• Example 2: ApplePPMUserClient
• com.apple.private.ppm.client
• com.apple.private.ppm.superclient
• Heap Overﬂow in ApplePPMUserClient::sRegisterClient (selector 26)
Attack 4: spoofed NMS
• XNU has a very privileged port: 
host_security
• host_security_set_task_token can 
change a task's security token!
• By resetting our token to the kernel 
token, we can send NMS to any port
Attack 4: spoofed NMS - voucher UAF
☞
When a voucher 
object receives a 
NMS, it will call 
ipc_voucher_notify
ipc_voucher_release decreases the voucher’s reference counter 
(iv_refs) and deallocates the voucher object for the last reference
☞
Attack 4: spoofed NMS - voucher UAF PoC
Attack 4: spoofed NMS - semaphore UAF
☞
When a semaphore 
object receives a 
NMS, it will call 
semaphore_notify
semaphore_dereference decreases the semaphore’s ref_count 
and deallocates the semaphore object for the last reference
☞
Attack 4: spoofed NMS - semaphore UAF PoC
• semaphore is a very interesting object. Its ref_count is stored at offset 72.
• semaphore_dereference will decrease the value at offset 72. 
Attack 5: spoofed NMS + type confusion
…
semaphore 
task_link
ref_count
+0
count
active
+72
+76
• We can 1) change a port type to IKOT_SEMAPHORE, and 2) then send 
NMS as many times as we want, so that the value at offset 72 will be 
decreased as many times as we want before it becomes 0.
Attack 5: spoofed NMS + type confusion
Smaller object 
Larger object 
some_value
…
…
semaphore 
task_link
ref_count
+0
count
active
+72
+76
Out-of-bounds 
decreasement
☞
☞
In-bounds 
decreasement
Attack 5: spoofed NMS + type confusion
Change the iterator port from IKOT_IOKIT_OBJECT to 
IKOT_SEMAPHORE, and send NMS to the port
IOUserIterator is 
allocated at 
default.kalloc.32
☞
IOUserIterator
+0
+8
+16
+24
OSArray->array
OSArray->array
Ptr
OSArray->array
+32
+40
+48
+56
+64
+72
semaphore_dereference(IOUserIterator)
decrease any times
Spray OSArray with 
capacity=4, so that array 
buffers are also allocated 
at default.kalloc.32 
☞
☞
Attack 6: trick kuncd  
• kuncd is a user space service that is supposed to only handle mach message from 
the kernel to execute user-space tools on macOS 
• kuncd checks the audit_token in the mach message trailer so that it only handles 
mach messages from the kernel
• Now we can send a mach message to kuncd to launch terminal as root
Attack 7: Access to any Mach services
Task
Launchd
1. bootstrap_lookup
Service
2.send right to the service
3. IPC channel to the service
Kernel
(Sandbox extension)
☜
Query the kernel with 
pid/p_idversion
☜
The mach message carries a trailer
With the fake host security port, we can set our token to 
pid=1, p_idversion=1, which is the launchd’s token
Launchd’s sandbox is super nice, so we can bypass the mach-lookup sandbox check
Attack 7: Access to any Mach services
err = 1100, service_port=0
Before we reset our token to launchd’s token
Attack 7: Access to any Mach services
After we reset our token to launchd’s token
applecamerad will 
return this plist 
ﬁle to our app
☞
Conclusion
• Variant analysis brings surprises
• Port type confusion forms a giant attack surface
• A vulnerability may have many ways to exploit 
Thank you!