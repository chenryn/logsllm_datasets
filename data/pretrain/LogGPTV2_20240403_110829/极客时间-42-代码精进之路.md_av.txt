## 延迟分配在前面讨论怎么写声明的时候，为了避免初始化的遗漏或者不必要的代码重复，我们一般建议"声明时就初始化"。但是，如果初始化涉及的计算量比较大，占用的资源比较多或者占用的时间比较长，声明时就初始化的方案可能会占用不必要的资源，甚至成为软件的一个潜在安全问题。这时候，我们就需要考虑延迟分配的方案了。也就是说，不到需要时候，不占用不必要的资源。下面，我们通过一个例子来了解下什么是延迟分配，以及延迟分配的好处。在 Java 核心类中，ArrayList是一个可调整大小的列表，内部实现使用数组存储数据。它的优点是列表大小可调整，数组结构紧凑。列表大小可以预先确定，并且在大小不经常变化的情况下，ArrayList要比 LinkedList 节省空间，所以是一个优先选项。但是，一旦列表大小不能确定，或者列表大小经常变化，ArrayList的内部数组就需要调整大小，这就需要内部分配新数组，废弃旧数组，并且把旧数组的数据拷贝到新数组。这时候，ArrayList就不是一个好的选择了。``{=html}在 JDK 7 中，ArrayList的实现可以用下面的一小段伪代码体现。你可以从代码中体会下内部数组调整带来的"酸辣"。    package java.util; public class ArrayList extends AbstractList        implements List, RandomAccess, Cloneable, java.io.Serializable {     private transient Object[] elementData;    private int size;     public ArrayList() {        this.elementData = new Object[10];    }     @Override    public boolean add(E e) {        ensureCapacity(size + 1);        elementData[size++] = e;         return true;    }     private void ensureCapacity(int minCapacity) {        int oldCapacity = elementData.length;         if (minCapacity > oldCapacity) {            Object oldData[] = elementData;            int newCapacity = (oldCapacity * 3) / 2 + 1;            if (newCapacity  extends AbstractList        implements List, RandomAccess, Cloneable, java.io.Serializable {     private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};     private transient Object[] elementData;    private int size;     public ArrayList() {        this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;    }     // snipped}改动后的缺省构造方法，不再分配内部数组，而是使用了一个空数组。要等到真正需要存储数据的时候，才为这个数组分配空间。这就是所谓的延迟初始化。这么小的变动带来的好处到底有多大呢？这个改动的报告记录了一个性能测试结果，改动后的内存的使用减少了13%，平均响应时间提高了 16%。你是不是很吃惊这样的结果？这个小改动，看起来真的不起眼。代码的优化对于性能的影响，有时候真的是付出少、收益大。从 ArrayList的上面的改动，我们能够学习到什么东西呢？我学到的最重要的东西是，对于使用频率高的类的实现，微小的性能改进，都可以带来巨大的实用价值。在前面讨论[怎么写声明](https://time.geekbang.org/column/article/78288)的时候，我们讨论到了"**局部变量需要时再声明**"这条原则。局部变量标识符的声明应该和它的使用尽可能地靠近。这样的规范，除了阅读方面的便利之外，还有效率方面的考虑。局部变量占用的资源，也应该需要时再分配，资源的分配和它的使用也要尽可能地靠近。
## 延迟初始化延迟分配的思路，就是用到声明时再初始化，这就是延迟初始化。换句话说，不到需要的时候，就不进行初始化。下面的这个例子，是我们经常使用的初始化方案，声明时就初始化。    public class CodingExample {    private final Map helloWordsMap = new HashMap<>();        private void setHelloWords(String language, String greeting) {        helloWordsMap.put(language, greeting);    }    // snipped}声明时就初始化的好处是简单、直接、代码清晰、容易维护。但是，如果初始化占用的资源比较多或者占用的时间比较长，这个方案就有可能带来一些负面影响。我们就要慎重考虑了。在 JDK 11 之前的 Java 版本中，按照 HashMap类构造方法的内部实现，初始化的实例变量helloWordsMap，要缺省地分配一个可以容纳 16个对象的数组。这个缺省的数组尺寸，比 JDK 7 中的 ArrayList缺省数组还要大。如果后来的方法使用不到这个实例变量，这个资源分配就完全浪费了；如果这个实例变量没有及时使用，这个资源的占用时间就拉长了。这个时候是不是可以考虑延迟初始化？下面的例子，就是一种延迟初始化的实现方法。    public class CodingExample {    private Map helloWordsMap;     private void setHelloWords(String language, String greeting) {        if (helloWordsMap == null) {            helloWordsMap = new HashMap<>();        }                helloWordsMap.put(language, greeting);    }     // snipped}上面的例子中，实例变量 helloWordsMap只有需要时才初始化。这的确可以避免内存资源的浪费，但代价是要使用更多的CPU。检查实例变量是否已经能初始化，需要 CPU 的额外开销。这是一个内存和CPU 效率的妥协与竞争。而且，除非是静态变量，否则使用延迟初始化，一般也意味着放弃了使用不可变的类可能性。这就需要考虑多线程安全的问题。上面例子的实现，就不是多线程安全的。对于多线程环境下的计算，初始化时需要的线程同步也是一个不小的开销。比如下面的代码，就是一个常见的解决延迟初始化的线程同步问题的模式。这个模式的效率，还算不错。但是里面的很多小细节都忽视不得，看起来都很头疼。我每次看到这样的模式，即便明白这样做的必要性，也恨不得先休息半天，再来啃这块硬骨头。    public class CodingExample {    private volatile Map helloWordsMap;     private void setHelloWords(String language, String greeting) {        Map temporaryMap = helloWordsMap;        if (temporaryMap == null) {    // 1st check (no locking)            synchronized (this) {                temporaryMap = helloWordsMap;                if (temporaryMap == null) {    // 2nd check (locking)                    temporaryMap = new ConcurrentHashMap<>();                    helloWordsMap = temporaryMap;                }            }        }                temporaryMap.put(language, greeting);    }     // snipped}延迟初始化到底好不好，要取决于具体的使用场景。一般情况下，由于规范性带来的明显优势，我们优先使用"声明时就初始化"这个方案。所以，我们要再一次强调，只有初始化占用的资源比较多或者占用的时间比较长的时候，我们才开始考虑其他的方案。**复杂的方法，只有必要时才使用**。※注：从 JDK 11 开始，HashMap的实现做了改进，缺省的构造不再分配实质性的数组。以后我们写代码时，可以省点心了。
## 小结今天，我们主要讨论了怎么通过延迟分配减少实例数量，从而降低内存使用。对于局部变量，我们应该坚持"**需要时再声明，需要时再分配**"的原则。对于类的变量，我们依然应该优先考虑"声明时就初始化"的方案。如果初始化涉及的计算量比较大，占用的资源比较多或者占用的时间比较长，我们可以根据具体情况，具体分析，采用延迟初始化是否可以提高效率，然后再决定使用这种方案是否划算。
## 一起来动手我上面写的延迟初始化的同步的代码，其实是一个很固定的模式。对于 Java初学者来说，理解这段代码可能需要费点功夫。评审代码的时候，每次遇到这个模式，我都要小心再小心，谨慎再谨慎，生怕漏掉了某个细节。借着这个机会，我们一起来把这个模式理解透，搞清楚这段代码里每一个变量、每一个关键词扮演的角色。以后遇到它，我们也许可以和它把手言欢。我把这段代码重新抄写在了下面，关键的地方加了颜色。我们在讨论区讨论下面这些问题：1.  helloWordsMap 变量为什么使用 volatile 限定词？2.  为什么要 temporaryMap 变量？3.  temporaryMap 变量为什么要两次设置为 helloWordsMap？4.  为什么要检查两次 temporaryMap 的值不等于空？5.  synchronized 为什么用在第一次检查之后？6.  为什么使用 ConcurrentHashMap 而不是 HashMap？7.  为什么使用 temporaryMap.put() 而不是 helloWordsMap.put()？如果你有更多的问题，请公布在讨论区，也可以和你的朋友一起讨论。弄清楚了这些问题，我相信我们可以对Java 语言的理解更深入一步。![](Images/faf5153f8f55041511d89646749f90ce.png){savepage-src="https://static001.geekbang.org/resource/image/b9/1b/b9f09ce12aea369f0e4959a74d9e4b1b.png"}![](Images/64444bae3ac90f82cb45ef5f1bc68d94.png){savepage-src="https://static001.geekbang.org/resource/image/5a/98/5a96a612403912b80de030e742e2e598.jpg"}
# 25 \| 使用有序的代码，调动异步的事件同步和异步，是两个差距很大的编程模型。同步，就是很多事情一步一步地做，做完上一件，才能做下一件。异步，就是做事情不需要一步一步的，多件事情，可以独立地做。比如一个有小鸟的笼子，如果打开笼门，一个一个地放飞小鸟，就是同步。如果拆了整个鸟笼，让小鸟随便飞，爱怎么飞就怎么飞，这就是异步。
## 为什么需要异步编程？如果我们观察身边的事物，现实中有很多事情是以异步的方式运营的。我们挤地铁的时候，从来都是好几个人一起挤进去的。当我们正在挤地铁时，外面的风照旧吹，雨照旧下，天坛的大爷大妈们正在秀着各种绝活。没有任何事情会因为我们正在挤地铁就停止活动，等我们挤完地铁再恢复运转。可是，要是说到其中的任何一个人，就不能同时做两件事情了。在挤地铁的时候，就不能在天坛秀绝活。我们写的程序也是这样，先执行第一行，再执行第二行。哪怕第二行再怎么费周折，第三行代码也要等着。第二行代码可能需要执行大量的计算，需要很多的CPU；也可能需要大量的传输，占用 I/O通道。可是，它不一定会把所有的计算机资源都占用了。如果第二行代码占用了 I/O，我们能不能把多余的 CPU用起来？如果第二行代码占用了 CPU，我们能不能把空闲的 I/O 用起来?也就是说，能不能把计算机整体资源更有效地使用起来？``{=html}该怎么办呢？想想家里的一把手做事的风格吧。"你去小区菜店买瓶酱油，买回来我们就做饭。"第一道指令发布完毕。"你把垃圾扔出去吧，都有馊味了。"第二道指令发布完毕。"我赶快收拾下屋子，有两天没打扫了。"第三道指令发布完毕。尽管每一道指令都很简短，但是每件事情都交代得很清楚。然后，每个人都忙碌了起来，各忙各的事情。效率也就比一件事情做完再做下一件高出很多。如果我们把三行代码换成三道指令。第三行代码虽然依然要等待，但只需等待第二道指令发布完成，而不是第二道指令背后的事情完成。等待的时间变短，效率也就提升了。我想，这就是异步编程的背后的驱动力量，以及基本的处理逻辑。为了更有效地利用计算资源，我们使用有序的代码，调动起独立的事件。
## 从过程到事件异步编程和我们熟悉的同步编程最大的区别，就是它要我们从事件的角度来编写和理解代码。就像我举的生活中的一些例子，说的做的多是"事情"。由于我们一般先学习的是对象、方法和过程这些模型，已经建立了一定的思考模式，对于事件驱动的编程模型可能会有点不习惯。事实上，熟悉了异步编程的思路，你会发现异步编程很贴近我们的生活模式。在下面的例子，我使用了 JDK 11 新添加的 HttpClient接口。最后一个语句，就是一个异步模式。这个语句的意思，就是交代一件事情："访问www.example.com，并且把响应数据打印到标准输出上。"需要注意的是，这个语句就是发布了这条指令。指令发布完，这个语句的任务就完成了，就可以执行下一个语句了，不需要等待指令交代的任务完成。    // Create an HTTP client that prefers HTTP/2.HttpClient httpClient = HttpClient.newBuilder()               .version(Version.HTTP_2)               .build(); // Create a HTTP request.HttpRequest httpRequest = HttpRequest.newBuilder()               .uri(URI.create("https://www.example.com/"))               .build(); // Send the request and set the HTTP response handlerhttpClient.sendAsync(httpRequest, BodyHandlers.ofString())               .thenApply(HttpResponse::body)               .thenAccept(System.out::println);   // next action我们可以对比一下传统的代码。下面的代码使用了 JDK 10 以前的HttpURLConnection接口。完成的是同样的任务。不同的是，下一件事情的代码需要等待上一件事情的完成，才能执行。也就是说，建立网络连接之后，才能执行读取响应数据的代码。    // Open the connectionURL url = new URL("https://www.example.com/");HttpsURLConnection urlc = (HttpsURLConnection)url.openConnection(); // Read the responsetry (InputStream is = urlc.getInputStream()) {    while (is.read() != -1) {    // read to EOF        // dump the response        // snipped    }} // next action使用 HttpURLConnection接口的代码，无论是连接过程，还是响应数据的读取过程，都依赖于网络环境，而不仅仅是计算机的环境。如果网络环境的响应时间是三秒，那么上面的代码就要阻塞三秒，无法执行下一步操作。而 HttpClient接口的代码，指令发布完，就可以执行下一步操作了。这个指令的执行时间，一般是毫秒以下的数量级别。如果我们不考虑其他因素的影响，那么上面的两个例子中，异步模式在网络阻塞期间，能够更好地利用其他的计算资源，从而提高整体的效率。