...
// the KMOD_EXPLICIT_DECL() macro is defined in osfmk/mach/kmod.h
KMOD_EXPLICIT_DECL(com.osxbook.driver.DummyDriver, "1.0.0d1", _start, _stop)
__private_extern__ kmod_start_func_t *_realmain = 0;
__private_extern__ kmod_stop_func_t *_antimain = 0;
...
In the case of a C++ kext, a particular virtual function may be overridden by another subclass at runtime.
file://C:\Dokumente und Einstellungen\Silvia\Lokale Einstellungen\Temp\~hh4BFC.h... 20.08.2007
Chapter 10. Extending the Kernel Page 22 of 79
Since this cannot be determined at compile time, virtual function calls in a C++ kext are dispatched through
the vtable. Depending on the kext ABI of the running system and the kext ABI of a given kext, the loading
mechanism can patch vtables to maintain ABI compatibility.
OSRuntimeInitializeCPP() calls the preModLoad() member function of OSMetaClass, passing it the
module's name as the argument. preModLoad() prepares the runtime system for loading a new module,
including taking a lock for the duration of the loading. OSRuntimeInitializeCPP() then scans the
module's Mach-O header, seeking segments with sections named __constructor. If any such sections are
found, the constructors within them are invoked. If this process fails, OSRuntimeInitializeCPP() calls the
destructors (that is, sections named __destructor) for those segments that had their constructors
successfully invoked. Eventually, OSRuntimeInitializeCPP() calls the postModLoad() member function
of OSMetaClass. postModLoad() performs various bookkeeping functions and releases the lock that was
taken by preModLoad().
OSRuntimeFinalizeCPP() is called when a module is unloaded. It ensures that no objects represented by
OSMetaClass and associated with the module being unloaded have any instances. It does this by checking
all metaclasses associated with the module's string name and examining their instance counts. If there are
outstanding instances, the unload attempt fails. The actual unloading operation is performed by
OSRuntimeUnloadCPP(), the call to which is surrounded by preModLoad() and postModLoad().
OSRuntimeUnloadCPP() iterates over the module's segments, examining them for sections named
__destructor and, if any are found, calling the corresponding destructor functions.
Next, let us see how libkmod.a (Figure 1010) is used in the implementation of a C-only kmod.
Figure 1010. Implementation of libkmod.a
// libkmod.a: c_start.c
// defined in _info.c
extern kmod_start_func_t *_realmain;
__private_extern___ kern_return_t _start(kmod_info_t *ki, void *data)
{
if (_realmain)
return (*_realmain)(ki, data):
else
return KERN_SUCCESS;
}
// libkmod.a: c_stop.c
// defined in _info.c
extern kmod_stop_func_t *_antimain;
__private_extern__ kern_return_t _stop(kmod_info_t *ki, void *data)
{
if (_antimain)
return (*_antimain)(ki, data);
else
return KERN_SUCCESS;
}
In the case of a C-only kmod object file, which will not contain unresolved references
to .constructors_used and .destructors_used, libkmodc++.a will not be used. The _start and _stop
symbols referenced in _info.c will come from the next library that contains these symbolsthat is,
libkmod.a. As Figure 1011 shows, the _info.c file of such a kernel module will set _realmain and
_antimain to point to the module's start and stop entry points, respectively.
file://C:\Dokumente und Einstellungen\Silvia\Lokale Einstellungen\Temp\~hh4BFC.h... 20.08.2007
Chapter 10. Extending the Kernel Page 23 of 79
Figure 1011. Declaration of the kmod_info structure for a generic kernel module
// _info.c for a generic kernel module (C-only)
...
// the KMOD_EXPLICIT_DECL() macro is defined in osfmk/mach/kmod.h
KMOD_EXPLICIT_DECL(com.osxbook.driver.DummyKExt, "1.0.0d1", _start, _stop)
__private_extern__ kmod_start_func_t *_realmain = DummyKExtStart;
__private_extern__ kmod_stop_func_t *_antimain = DummyKExtStart;
...
In other words, although every kmod has start and stop entry points, they can be implemented by the
programmer only in the case of a generic kernel module. In the case of an I/O Kit driver, these entry points
are unavailable to the programmer because they correspond to the C++ runtime initialization and termination
routines. It follows that these two types of loadable entities cannot be implemented within the same kext.
10.4.3. Management of Kernel Extensions
The functionality for working with kernel extensions is implemented across several Darwin packages, such
as xnu, IOKitUser, kext_tools, cctools, and extenTools. The following are the primary command-line
programs available for managing kernel extensions.
 kextd loads kexts on demand.
 kextload loads kexts, validates them to ensure that they can be loaded by other mechanisms, and
generates debugging symbols.
 kextunload unloads code associated with a kext, terminating and unregistering I/O Kit objects, if
any, associated with the kext.
 kextstat displays the status of currently loaded kexts.
 kextcache creates or updates kext caches.
 mkextunpack extracts the contents of a multikext (mkext) archive.
kexTD, the kernel extension daemon, is the focal point of much of the activity that occurs when kexts are
loaded or unloaded in a normally running system. During the early stages of bootstrapping, kextd is not yet
available. The libsa support library in the kernel handles kernel extensions during early boot. Normally,
libsa's code is removed from the kernel when kextd starts running. If you boot Mac OS X in verbose mode,
you will see a "Jettisoning kernel linker" message printed by the kernel. kextd sends a message to the I/O
Kit to get rid of the in-kernel linker. In response, the I/O Kit invokes destructors for the kernel's __KLD and
__LINKEDIT segments and deallocates their memory. The memory set up by BootX is also freed. kexTD can
be instructed (via the j option) not to jettison the kernel linker. This allows the kernel to continue handling
all load requests. In this case, kexTD exits with a zero status if there is no other error. Bootable optical discs
can use this option in startup scripts, along with an mkext cache, to accelerate booting. For example, as we
saw in Section 5.10.4, Apple's Mac OS X installer disc runs kextd with the j option in /etc/rc.cdrom.
kextd registers com.apple.KernelExtensionServer as its service name with the Bootstrap Server. It
processes signals, kernel requests, and client requests (in that order) in its run loop. kextd and command-
line tools such as kextload and kextunload use the KXKextManager interface for manipulating kernel
extensions. KXKextManager is implemented as part of the I/O Kit framework (IOKit.framework). Figure
1012 shows an overview of kextd's role in the system.
Figure 1012. Kext management
[View full size image]
file://C:\Dokumente und Einstellungen\Silvia\Lokale Einstellungen\Temp\~hh4BFC.h... 20.08.2007
Chapter 10. Extending the Kernel Page 24 of 79
When kexTD starts running, it calls KXKextManagerCreate() to create an instance of KXKextManager and
initializes it by calling KXKextManagerInit(). The latter creates data structures such as a list of kext
repositories, a dictionary of all potentially loadable kexts, and a list of kexts with missing dependencies.
10.4.4. Automatic Loading of Kernel Extensions
If a kext is to be loaded every time the system boots, it must be placed in
the /System/Library/Extensions/ directory. All contents of the kext bundle must have the owner and
group as root and wheel, respectively. Moreover, all directories and files in the kext bundle must have
mode bit values of 0755 and 0644, respectively. The system maintains a cache of installed kexts, along with
their information dictionaries, to speed up boot time. It updates this cache when it detects any change to
the /System/Library/Extensions/ directory. If an installer installs an extension as a plug-in of another,
however, only a subdirectory of /System/Library/Extensions/ is updated, and the automatic cache
update is not triggered. In such a case, the installer must explicitly touch /System/Library/Extensions/
to ensure that the caches are recreated to include the newly installed kext.
A kext can be declared as a boot-time kext by setting the OSBundleRequired property in its Info.plist
file. The valid values this property can take include Root (required to mount root), Local-Root (required to
mount root on locally attached storage), Network-Root (required to mount root on network-attached
storage), Safe Boot (required even in safe-mode boot), and Console (required to provide character console
supportthat is, for single-user mode).
Although a driver kext can be explicitly loaded with kextload, it is preferable to restart the system to ensure
reliable matching so the driver can be considered for all potential devices it can drive. In the case of a
running system, if a driver is already managing a given device, another driver will not be able to manage the
device in question.
10.5. Communicating with the Kernel
file://C:\Dokumente und Einstellungen\Silvia\Lokale Einstellungen\Temp\~hh4BFC.h... 20.08.2007
Chapter 10. Extending the Kernel Page 25 of 79
User programs communicate with kernel components frequently through system calls. Besides traditional
system calls, Mac OS X provides other mechanisms to allow user programs to have a more direct
communication with kernel componentsin particular, for low-level access to hardware.
One of the mechanisms is the I/O Kit Device Interface mechanism. A device interface is a user-space entity
(say, a library) that user programs can call to access a device. Communication from user programs goes
through the device interface to a kernel-resident user client, which in turn dispatches it to the device. From
the kernel's standpoint, the user client is a driver whose class derives from IOService. Each user client
instance represents a user-kernel connection. Note that user clients are not supported by all drivers.
A device interface is a plug-in interface conforming to the Core Foundation plug-in model.
Through the I/O Kit Device Interface mechanism, user programs can communicate with a driver or nub in
the kernel and can therefore access devices, manipulate their properties, and use the associated I/O Kit
services. As is typical of finding I/O Registry objects, a user program creates a matching dictionary
containing one or more properties of the device it wishes to access using the Device Interface mechanism.
For example, a match criterion could seek all FireWire mass-storage devices. This process is termed device
matching. We saw in Section 10.2.11 that driver matching is performed by the I/O Kit during bootstrapping
and results in the population of the I/O Registry. In contrast, device matching results in the I/O Registry
being searched for objects that already exist (corresponding to drivers that are already loaded).
An application communicating with a device through its device interface can be seen as a user-space driver
for that device.
Specification of matching criteria involves providing key-value pairs that identify one or more devices or
servicessay, by describing some of their properties. The key-value pairs are encapsulated in a matching
dictionary, which is essentially a reference to a Core Foundation CFMutableDictionary object. The I/O Kit
framework provides functions such as IOServiceMatching(), IOServiceNameMatching(),
IOOpenFirmwarePathMatching(), and IOBSDNameMatching() to create matching dictionaries. Given a
matching dictionary, devices can be looked up in the I/O Registry using functions such as
IOServiceGetMatchingService(), IOServiceGetMatchingServices(), and
IOServiceAddMatchingNotification(). The latter also installs a notification request of new IOService
objects that match. When one of these functions is called, the I/O Kit compares the values in the provided
matching dictionary against the properties of nodes in the I/O Registry.
The I/O Kit defines several keys that can be used in matching dictionaries. Additional, family-specific keys
are usually available in device families.
After finding a device, a program communicates with it using functions from the I/O Kit framework.
Functions that communicate with the I/O Kit require the I/O Kit master port, which can be retrieved by
using IOMasterPort(). Alternatively, the constant kIOMasterPortDefault can be specified to cause the
I/O Kit framework to look up the default master port.
Another user-kernel communication mechanism is available through device files, which are rather
ubiquitous on Unix-style systems. The I/O Kit automatically supports the device file mechanism for mass-
storage and serial communications devices. On discovering such a device, besides configuring the usual
stack of appropriate drivers, the I/O Kit creates an instance of a user client objectan IOMediaBSDClient or
IOSerialBSDClient. The user client instance calls on the device file system (devfs) module to create the
appropriate device file nodes. Since devfs is normally mounted under the /dev/ directory, these device
nodes are visible within that directoryfor example, /dev/disk0 and /dev/cu.modem.
Similar to the case of a device interface, the kernel-resident user client in this case sits between the kernel
entity representing the device and the user-space program that uses the /dev node to access the device.
The name of the /dev node corresponding to a device can be retrieved from the I/O Kit using device
file://C:\Dokumente und Einstellungen\Silvia\Lokale Einstellungen\Temp\~hh4BFC.h... 20.08.2007
Chapter 10. Extending the Kernel Page 26 of 79
matching functions. The node's path is a property in the I/O Registry.
10.6. Creating Kernel Extensions
In this section, we will discuss how kernel extensions are created and loaded. Note that Apple urges third-
party programmers to avoid programming in the kernel unless absolutely necessary. A legitimate reason for
a device driver to reside in the kernel is if it handles a primary interrupt or if its primary client is kernel
resident.
10.6.1. A Generic Kernel Extension
Let us create a trivial kextone that implements only the start and stop entry points. Once we can compile and
load the kext, we will extend it to implement a couple of sysctl entries. We will call our kext DummySysctl.
We begin with an Xcode project instantiated from the template for generic kernel extensions. Since sysctl
implementation is a BSD-only endeavor, we need to specify our kext's dependency on the BSD KPI. We
will use the kernel version of the printf() function to print messages in our kext. Therefore, we need
libkern, which provides printf(). The key contents of the kext's Info.plist file are as follows:
...
...
CFBundleExecutable
DummySysctl
CFBundleIdentifier
com.osxbook.kext.DummySysctl
...
OSBundleLibraries
com.apple.kpi.bsd
8.0.0
com.apple.kpi.libkern
8.0.0
At least certain values in the stock Info.plist file generated by Xcode must be modified or added before
the compiled kext can be successfully loaded. The CFBundleIdentifier key should be set to a reverse-
DNS-style name for the kext. The OSBundleLibraries key is used to enumerate a kext's dependencies. This
key's value is a dictionaryspecifically, an OSDictionarythat has been serialized into the XML property list
format. It may contain an empty dictionary. Beginning with Mac OS X 10.4, a kext can declare
dependencies either on new-style kernel programming interfaces (KPIs) or on compatibility interfaces. KPI
dependencies are specified through com.apple.kpi.* identifiers, whereas the others are specified through
com.apple.kernel.* identifiers. The former start from version 8.0.0 (Mac OS X 10.4 and newer), whereas
the latter end at version 7.9.9 (Mac OS X 10.3 and older). The kextstat command can be used to list the
interfaces available in the current kernelthe interfaces correspond to the "fake" kexts that represent built-in
kernel components such as Mach, BSD, libkern, and the I/O Kit.
A kext can also declare a dependency on a specific version of the entire kernel by using the
com.apple.kernel identifier. Although this approach would provide the kext access to all available kernel
interfaces, including internal ones, it is not recommended because Apple does not guarantee binary
compatibility across kernel versions to such kexts.
file://C:\Dokumente und Einstellungen\Silvia\Lokale Einstellungen\Temp\~hh4BFC.h... 20.08.2007
Chapter 10. Extending the Kernel Page 27 of 79
$ kextstat | egrep -e 'com.apple.(kernel|kpi)'
1 1 0x0 0x0 0x0 com.apple.kernel (8.6.0)
2 11 0x0 0x0 0x0 com.apple.kpi.bsd (8.6.0)
3 12 0x0 0x0 0x0 com.apple.kpi.iokit (8.6.0)
4 12 0x0 0x0 0x0 com.apple.kpi.libkern (8.6.0)
5 12 0x0 0x0 0x0 com.apple.kpi.mach (8.6.0)
6 10 0x0 0x0 0x0 com.apple.kpi.unsupported (8.6.0)
11 60 0x0 0x0 0x0 com.apple.kernel.6.0 (7.9.9)
12 1 0x0 0x0 0x0 com.apple.kernel.bsd (7.9.9)
13 1 0x0 0x0 0x0 com.apple.kernel.iokit (7.9.9)
14 1 0x0 0x0 0x0 com.apple.kernel.libkern (7.9.9)
15 1 0x0 0x0 0x0 com.apple.kernel.mach (7.9.9)
You can view the list of symbols corresponding to a KPI identifier by running nm on the corresponding
"pseudo-extension"the various pseudo-extensions reside as plug-ins within the System kext.
$ cd /System/Library/Extensions/System.kext/PlugIns
$ ls
AppleNMI.kext IOSystemManagement.kext
ApplePlatformFamily.kext Libkern.kext
BSDKernel.kext Libkern6.0.kext
BSDKernel6.0.kext Mach.kext
IOKit.kext Mach6.0.kext
IOKit6.0.kext System6.0.kext
IONVRAMFamily.kext Unsupported.kext
$ nm BSDKernel.kext/BSDKernel
...
U _vnode_iterate
U _vnode_lookup
U _vnode_mount
...
Besides core kernel components, kexts can depend on various I/O Kit families by using identifiers such as
com.apple.iokit.IOGraphicsFamily, com.apple.iokit.IONetworkingFamily,
com.apple.iokit.IOPCIFamily, and com.apple.iokit.IOStorageFamily.
Figure 1013 shows the source for the kext. The start function is called when the kext is loaded, and the stop
function is called when it is unloaded. Xcode inserts skeletal implementations of these functions in the
automatically generated C file for the Generic Kernel Extension project template. We have added a printf
() statement to both functions.
Figure 1013. Source for the DummySysctl kernel extension
// DummySysctl.c
#include 
kern_return_t
DummySysctl_start(kmod_info_t *ki, void *d)
{
printf("DummySysctl_start\n");
return KERN_SUCCESS;
}
kern_return_t
DummySysctl_stop(kmod_info_t *ki, void *d)
{
printf("DummySysctl_stop\n");
return KERN_SUCCESS;
}
file://C:\Dokumente und Einstellungen\Silvia\Lokale Einstellungen\Temp\~hh4BFC.h... 20.08.2007
Chapter 10. Extending the Kernel Page 28 of 79
Let us now compile the kext. The benefits of Xcode are most evident in the compilation stage, since a
manual compilation would need to specify the appropriate combination of compiler arguments, environment
variables, linker arguments, and so on. Note that it is possible to initiate an Xcode build from the command
line using the xcodebuild program. On successful compilation, the target kext bundle is created in a
subdirectory of the build/ directory within the Xcode project directory.
$ xcodebuild -list
Information about project "DummySysctl":
Targets:
DummySysctl (Active)
Build Configurations:
Debug (Active)
Release
If no build configuration is specified "Release" is used.
$ xcodebuild -configuration Debug -target DummySysctl
=== BUILDING NATIVE TARGET DummySysctl WITH CONFIGURATION Debug ===
...
** BUILD SUCCEEDED **
$ ls build/Debug
DummySysctl.kext
Since loading a kext requires the kext bundle's contents to have root and wheel as the owner and group,
respectively, a typical compile-test-debug cycle would involve copying the kext bundle from the build
directory to a temporary locationsay, to /tmp/and using the chown command on the copy. As we noted
earlier, besides ownership, the modifiability of objects within the bundle also mattersthe bundle's contents
must not be writable by any user except root.
$ sudo rm -rf /tmp/DummySysctl.kext # remove any old bundles
$ cp -pr build/DummySysctl.kext /tmp/ # copy newly compiled bundle to /tmp
$ sudo chown -R root:wheel /tmp/DummySysctl.kext