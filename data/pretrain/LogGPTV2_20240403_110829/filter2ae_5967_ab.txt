两次包的tcp
flag的push位置必须置为1才算一次，两个push才算两次。这里也尝试过前面那个作者的tcp分片，尝试了对http报文使用tcp分片来达到分包效果，然而似乎防火墙并不吃这一套。
上图就是tcp分片的实验截图，并没有用，各位可以自己抓包看一下tcp分片的两个包第一个包并没有标记push所以两个分片被视为一个包。由于HTTP分包不能用，如果需要满足上面列举的几个条件在常见的SSRF协议里几乎很难做到。我分别尝试了以下几个方案：
  1. gopher：不可行，gopher虽然以tcp形式构造任意payload但是不能保持链接，更不能一个链接里发送两次push，更多细节就不赘述了太复杂
  2. 30x条转：更不可行，无论是http的还是其他协议都尝试畸形30x跳转，然而实际情况是30x跳转是以关闭当前链接，创造新的链接的方式进行的，就算是满足了同一个链接也控制不了payload使得其中一个以PORT开头，要知道http的协议开头都是GET和POST等
  3. pipeline：没有场景，正向pipeline是可以的，但是由内而外的pipeline几乎不可能存在
  4. http走私：暂时没想出来可行性，感觉可以但是实际上应该是不行，因为防火墙识别报体的push次数和http的长度、trunk这些不一样
## 0x04 柳暗花明
在瞎几把尝试的时候，我使用了一个命令来模拟http发包：
    curl -X POST -T x.txt http://xxx.xxx.xxx.xxx:21
结果居然成功了，一开始我以为是分片成功了，后来仔细看抓包感觉不太对劲
（这个截图我没有用分片所以没有看到分片的包）注意看划线的部分，可以看到一个post被拆分成两个请求报体，我们看一下是不是push位置都是1
确实都是1，太神奇了，这是怎么回事呢？我仔细看了看报文，发现post请求头里有这个
    Expect: 100-continue
这是什么？百度一下（）
意思就是客户端先发出头部体暂时不发送post body，头部里加入Expect，如果服务器响应说我现在准备好接受post
body了，然后客户端再单独发送post
body。这就直接造成了两次push在一次tcp链接里！完美契合我们的需求！希望有了，可是问题又来了，哪个服务端在实现SSRF的时候会使用
    curl -X POST -T x.txt http://xxx.xxx.xxx.xxx:21
这样的形式来发送呢？怕是脑残才会这样写吧。那这玩意真的就没有地方用吗？答案是有的！远在天边，近在眼前！我们看一下php的curl的实现，搜一搜找到下面的线索：
什么？php的curl在发送post体超过1024个字节的时候会使用expect？？？？？我爱php！马上验证尝试，结果是自然的，有一说一，确实是这样的。那么我们开始构造一个满足要求的post体：
  1. body大于1024个字节
  2. 以命令开头
  3. 加入一些小细节能被防火墙正确识别 直接给出php的demo
好了，现在我们能发出被防火墙识别到触发映射规则的http报文了。
## 0x05 实验观察
这里我建议先准备两个虚拟机，一台模拟外网主机，一台模拟内部主机，然后在内部主机上配上防火墙策略
    sudo iptables -A INPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPTsudo iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPTsudo iptables -P INPUT DROP
然后我们在内网的主机里执行前面的php文件模拟对外发包，发包到我们的外网服务端上（外部服务端要怎么写我就不放出来了，有一些小细节留给大家自己写吧）。在发包之前，我们可以在内网的主机上监听任意一个端口
    nc -l 0.0.0.0:10000
接着在外网的主机上尝试去直接链接
    nc -vv xxxxx 10000
会发现怎么都连不上，连不上才是正常的。接着开启发包，发送一个post请求，接着再次在外部主机上尝试链接，会发现连接成功！
这里有个细节就是一次连接成功后断开再次尝试的时候会发现又连不上了，这才是正常的。一个发包只能映射一次。
## 0x06 拓展攻击面
前面只是演示了一个可能的场景，但其实还可以延伸出其他可能的场景。比如：
  1. 恶意页面这块也可以再尝试一下，部分资料显示有些浏览器在特定情况下也会拆分请求，另外用户在内部浏览页面的话走的pipeline，可能利用这一点也能达成目的
  2. 服务端的websocket服务，如果会把我的请求放在响应当中，可能可以构造命令激活防火墙，我可以把我的发起端口改成21端口，如果防火墙在判断的时候不计较发起方向的话？
  3. 反序列化的时候，类似的发出一个可控ssrf或者是打出一个tcp链接到外部恶意服务器比如jdbc？
  4. 有限getshell的情况下可以自己来触发映射，比如直接对外请求或者shell里直接打命令通过shell传输显示来触发映射等等，如果你的内网限制跳板，那么通过触发花式nat映射，可能可以将外网作为跳板访问当你本来访问不到的服务器
  5. 不仅仅是外网的nat，内网的多个nat，也可以尝试花式触发
  6. 其他ALG协议也有潜在的能力 有人会问，我都有SSRF了我直接打内网不就好了，我映射个啥劲？我只能说，想象力局限了，至于差别在哪里，各位可以自己在深入理解一下。
## 0x07 如何防御
其实我觉得不太好防御，最暴力的方式就是直接干掉related状态，一般情况下是用不到的，尤其是在一些比较严格的网络环境下自然是用不到的。用到的地方通常是比较随意的、便利为主的网络环境，所以在配置这个状态规则时还是要分清楚实际场景需要，而不是抄文档。另外下面是我找到的关于这一块的安全加固的文章，也可以参考一下
## 0x08 写在最后
由于涉及到的知识太多，我直接压缩了很多内容的描述，也压缩了很多细节的推到，我觉得大家真的有兴趣最好自己试一下体会一下，多用wireshark抓包观察一下。这篇文章不是终点，只是一个起点，nat
slipstream也只是个起点，贴合实际泛化后，我相信会有更多的潜在场景被挖掘出来。有兴趣一起研究一起学习的小伙伴可以加入我的知识星球，我会在知识星球里发更多细节以及其他有趣的文章，公众号的文章只是冰山一角。
* * *