is to investigate 
this, an application 
runs, 
with the correct 
jection eventuaIly 
injection can magnify the soft error 
To  determine 
every fault in
three categories: (I) Derated, 
whether the biased  fault 
effects on the software. 
injected with  a fault is run until completion 
or until the 
injected fault causes a crash or a hang. For the completed 
the output of the program is compared 
Therefore, 
following 
exits normaIly 
execution, 
zero return value or a kernel panic/halt, 
Corruption 
yields a different 
CriticalFault 
case (3), which essentially 
error coverage  calculat
aims to maximize the number of case (2) and 
the sample sizes used for 
(2) Abort, where the benchmark 
(SDC), where the benchmark 
falls into one of the 
exits with  a non­
increase 
ions. 
where the benchmark 
and yields the same output as the fault-free 
output. 
or (3)  Silent  Data 
exits normally 
but 
of registers
: 
•  Sixteen 
64-bit general-pur
pose registers  in 
the x86-64 
ISA (rax,  rbx, 
. . .  , rI5), 
•  thirty-two 64-bit temporary 
registers 
that represent 
high 
or low  bits 
of 16  XMM registers, 
•  eleven 64-bit registers 
•  one 6-bit flag register 
used only by /-lOpS, and 
containing 
zero, overflow, 
sign, 
carry, parity, and adjust flags. 
Because registers 
full-system functional 
microarchitectural 
simulator. 
used by /-lOpS are invisible 
to the Simics 
simulator, 
faults 
are injected in 
the FeS2 
Because of the need to expose the end behavior 
of the 
compute­
Fault  is 
and limits the number of injection runs. Compar­
Cook and Zilles conduct a large scale injection but 
injected faults, the  GFI process of Critical 
intensive 
atively, 
terminate 
data, or control 
often find cases where bad memory accesses 
do  not change  the  final 
program output. 
by the application. 
are often  derated 
their experiments 
flow is corrupted 
when memory address, memory 
and control 
Ultimately, 
flows 
faults 
These cases cannot  be 
[ 1 0] .  In our experiments,  we 
output than the fault-free  execution.  Overall, 
Given the available 
amount of computing 
resources, we 
want to balance 
the number of injected /-lOpS and the number 
I CriticalFault 
is capable 
parts of the OS. However. 
of injecting faults 
this is out of the scope of the paper. 
into the system library 
and other 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 18,2021 at 14:50:05 UTC from IEEE Xplore.  Restrictions apply. 
detennined 
by methods such  as 
the use of CriticalFault. 
that of [ 1 0] and thus require 
Vulnerability 
Factor 
of Selected 
Region 
V. RESULTS 
With the experimental 
setup described 
in the last section, 
results 
from the 
and discuss  the 
we now present 
framework.  First, 
we discuss 
analysis  phase 
driven injection 
fault 
injection. Then, we report and analyze experimental 
of our guided fault injection 
CriticalFault 
the vulnerability 
vulnerability­
statistical 
results 
compares  against 
how CriticalFault 
the results  from 
and investigate 
experiments. 
traditional 
100 
90 
80 
70 
60 
50  - - -
40 
30 
20 
10 
0 
- - -
- --
 N   $:  i:l  0.  .2   ., - t.9 
  0  > 
« 
'" 
"" . 
0. 
0. 
·N 
..Q  " 
., 
0-
A. Vulnerability 
Factor and SFI 
As CriticalFault 
driven by vulnerability 
analysis, Figure 3 
Fig.  3. Vulnerability 
Factor of Randomly Selected Region 
factor (VF) of all potentially  ACE 
1 0k-pDp traces of the benchmarks. Overall, 
of the selected 
shows the vulnerability 
states for  the 
the vulnerability 
factors 
quite high (60-80%). In general, 
SFI  is more likely to inject faults into ACE bits that do 
not get derated, 
conservative against 
We also randomly 
SFI. 
selected 
making our evaluation 
if they are to be used in 
of Critical 
benchmark 
faults  as 
a higher VF means that 
Fault more 
traces are 
60 
Identified 
derated 
faults 
by VF in SFI 
50 
40 
30 
20 
10 
I--- I---
if these faults are known to be derated 
via 
analysis. Figure 4 shows the percentage 
of these 
faults that are  identified 
29% of the SFI can be avoided as the chosen faults 
up  to 
The figure also indicates  that 
by VA to be  derated.  On 
0 
 N   $:  i:l  0.  .2   ., - t.9 
  0  > 
  « 
'" 
"" . 
0. 
0. 
·N 
..Q  " 
., 
0-
.., 
be avoided without  impacting  the 
Fig. 4. Derated faults Identified 
by VF in SF! 
of the underlying 
SFI and analyzed 
vulnerability 
selected 
average, 
are known to be benign. 
50% (mcf) of the SFI  can 
evaluation 
that although 
an expected 
out  to be highly vulnerable 
Since CriticalFault 
gears towards 
would  use 
researchers 
hard-to-detect 
would be wasted, 
dramatically 
the results 
Critical 
result 
reliability 
mechanism. We note 
are somewhat conservative,  this 
is 
as  we selected 
program regions 
(vulnerability 
factor is 60-80%). 
that turned 
stress testing, 
we believe 
that 
it for less vulnerable 
to uncover 
faults. In this case, while much of the SFI effort 
regions 
Fault  can 
reduce the injection space 
to allow one to focus only on non-derated 
is very efficient. 
CriticalFault 
faults. 
In 
When compared  to  SFI, 
a soft error is derated 
amount of computation 
program has to be run  until 
many of the OFIs (and SFIs) can be time consuming 
bandwidth 
general, 
and can use up a significant 
because the software 
to determine  if 
the program output.  Although  CriticalFault 
identify 
injection 
guided fault injection experiments. 
injection 
bandwidth 
more efficiently 
employs VA to 
overhead 
as the 
many subsequent 
vulnerable 
map is computed 
for meaningful test cases and can operate 
space with VA, CriticalFault 
bits, it adds negligible 
can free up valuable 
than traditional 
only once for the 
Therefore, 
corrupting 
by slashing 
or silently 
the end 
SFI. 
much 
the 
B. Guided Fault Injection 
per­
injection maps, CriticalFault 
to examine how the system reacts 
faults. Compared to SFI, faults 
Based on the generated 
fonns guided fault injections 
to these likely non-derated 
injected with OFI are more likely to cause a detection 
it recoverable 
although 
with VA, some errors can still be derated 
latency 
(be 
or not) and a silent data corruption. 
can often be caught 
at a  much longer 
level  error  derating 
Hence, OFI would still see 
and are difficult 
instruction 
to identify. 
Further, 
level  error 
masking. 
faults a priori involves 
In general, 
identi­
complex program 
and may not even be computationally 
possible (con­
verge scenarios). Nonethele
ss, 
diverge-and-recon
this type of software 
fying all derated 
analysis 
sidering  all 
our framework 
faults when  compared 
solution 
mechanisms 
Specifica
application-level 
over another, 
eliminate 
in the OS and the application 
lly, an injected error that is not derated 
or a  silent 
or OS-level  abort 
data corruption. 
to detect errors. 
will result 
in a 
a consider
able  amount 
of derated 
to traditional 
our  experiments 
only rely on  existing 
SFI. Without favoring 
one 
Figure 5 presents 
the results 
of the guided fault injection 
The x-axis shows the different 
bars show  the 
three different 
experiments. 
the  stacked 
injected faults in each benchmark 
Derated, 
Abort, and Silent Data Corruption 
(SDC). 
benchmarks 
outcomes 
and 
of the 
(from bottom to top): 
stages, and aborts are likely 
in aborts, 
54% result 
also varies among different 
From Figure 5(a), we can see that 4 1  % of the total injected 
and 5% cause SDCs. 
faults are derated, 
The error behavior 
benchmarks. 
We found that SDCs are likely to occur when faults are 
injected in data value computation 
to happen when memory operation 
faults. For example,  lu  and  fft 
spectively, 
is because 
are highly data-centric. 
program results 
to abort. 
memory access operations, 
in aborts, 
kernels and 
Injected faults are affecting the end 
rather  quickly  without 
On the other hand, since bzip2 and parser have many 
injected faults are highly  to 
Computations 
stages are injected with 
have about  20%  SDC 
which is much higher than other benchmarks. This 
fft and lu are floating-point 
80% and 73%, respectively. 
computation 
causing 
rate re­
result 
the software 
in  other 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 18,2021 at 14:50:05 UTC from IEEE Xplore.  Restrictions apply. 
D Faulty Data D Faulty Address • Faulty Control 
benchmarks 
discussed 
various 
in Section 
V-C. 
in detail 
exhibit 
types of behaviors, 
which will be 
Figure 5(b) shows the similar 
injection results 
for traditional 
injection as comparison. 
As expected, 
SF! has 
statistical  fault 
a higher derating rate 
two If, lu and fft all have lower  SDC 
These  results 
stress testing 
all indicate 
the system than SFI. 
of 55% than GFI's 40% .  Most notably, 
rates in SF! than in GFI. 
that CriticalFault 
is very effective 
in 
Since CriticalFault 
aims to facilitate 
processes, 
we perform a more in-depth 
the fault injection and 
to 
analysis 
understanding 
of the error effects in the following 
analysis 
gain a better 
section. 
100% -r.. .... ---.. __  .-.. __ 
80% 
60% 
40% 
20% 
  QJ  N  u  C.  -
ro  -'"  c.  u  'N  u 
ro  'N tlD  tlD  E 
::J  .0 
cr 
QJ 
C. pDp-Level 
Fault Analysis 
Fig. 6. Fault injection 
immediate 
effects by categories 
Given the results 
in the previous 
various 
section, 
behaviors 
we want to 
of the in­
for  the 
the reasons 
from the hardware 
understand 
jected faults in GFI. Specifically, an injected fault usually 
first propagates 
then corrupts various program 
To  understand 
causing 
our analysis 
behaviors, 
two aspects: immediate 
ef­
fects and propagation 
the 
states 
corrupted 
propagation 
behaviors 
faults propagate 
Immediate 
after faults are injected while 
the states  being 
to the  software 
level and 
and data values prior to 
error. 
examines 
shortly 
describe 
during program execution. 
a software  visible 
behaviors. 
corrupted 
these faulty 
software 
states 
as 
effects  denote 
1) Categorization 
of immediate 
effects of faults by  examining 
effects can be 
jected with faults. Immediate 
faulty effects: We cate­
the fl,OpS 
gorize immediate 
and registers  in
grouped into 
three types: 
Faulty Control: If a  fault 
is injected into registers 
used for conditional 
or 
branches, it is 
that  are 
instructions 
considered 
a faulty control 
two types fall into  this 
into condition 
flags  used 
immediately 
subsequent 
column  of 
are all considered 
tempO is not related 
corrupting 
conditional 
Table III, faults  in
case. Specifica
lly, the following 
injected directly 
category:  faults 
in conditional 
branches 
or faults 
the fl,OpS that produce the flags for 
branches. For example,  in 
jected in r11 ,  rax, and flag zf 
the first 
as faulty control. 
The destination 
register 
to the branch in  this 
case. 
figure, we see that the 
path or 
vary widely. 
benchmarks 
or propagate 
computation. 
to affect the control 
From the 
data corruption 
memory address 
injections in different 
lu and fft have a lot of faulty data injections, 
lead to the higher SDC rates. However, although 
equake also have a high percentage 
of them are causing 
mcf are faulty control 
are causing  aborts. 
SDCs. Interestingly, 
and faulty address 
art and 
of faulty data cases, 
none 
most injections in 
cases but only 42% 
For example, 
which ultimately 
2) Characteristics 
of propagation 
investigates 
the immediate 
last section 
faults, we now analyze 
iors for each category 
the long-term 
described 
above. 
While the 
behaviors: 
effects of the injected 
fault propagation 
behav­
flags, which determines 
of 
cases. 
derating 
of control 
The overall 
of the branches 
into the condition 
the injection results 
about faulty control, 
(zf in the the first column 
used by  the branches. For example, 
flag and show them in Figure 8. From the 
the 
r11  and rax 
flag: faults are 
understanding 
into two types: 1 )  control 
Faulty Control: Figure 7 shows the  injection results 
rate is about 3 8 % .  
w e  group 
data: faults are injected 
which are used for detennining 
faulty control 
To gain a better 
the results 
into the data registers, 
conditions 
in  the first column of Table III, 2) control 
injected directly 
the outcomes 
of Table III). We separate 
data and control 
figure, we can see that control 
than control 
flags, compared to  the 50% derating 
Considering 
analysis 
that vulnerability 
of resilient 
bits in flag registers, 
would be even higher in SFI.  We also found that although 
considers 
vulnerability 
flag bits to be relevant 
for some branches, the injection results 
for branch conditions 
show that only one flag bit  flip  actually 
changes the control 
path. Furthermore, 
the Y-branch effect is important. 
instruction 
outcome does not affect the end  program 
observed 
Y-branches. 
a branch 
a Y-branch if the negated branch 
output [ 1 4 ] .  We 