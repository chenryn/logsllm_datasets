代码清单 /4c/4c-001.php
文件 ：
而以下脚本的作用就是接收文件后将其保存在 /4c/img/ 目录中，并在页面上显示出来。
代码清单 /4c/4c-002.php
">
已上传 
">
正常情况下的执行过程如下所示。
图 4-105 示例脚本的执行范例（正常情况）
专栏：警惕文件名中的 XSS
4c-002.php 中生成图像文件的 URL 时，会通过 urlencode 函数对文件名进行百分号编码，并在显示处理中执行 HTML 转义。这些都是必要的处理。Unix 允许在文件名中使用 、" 等字符，因此需要根据所在位置进行相应的转义处理。当然这些都不是新鲜的内容，只是照理实施 XSS 的防范策略而已。
PHP 脚本的上传与执行
下面就让我们来看一下攻击的例子。这里假设用户上传的不是图像文件，而是以下 PHP 脚本文件。
代码清单 4c-900.php
&lt;?php
  system('/bin/cat /etc/passwd');
?>
这段 PHP 脚本的作用在于通过 system
 函数调用系统命令 cat 来显示 etc/passwd 文件的内容。上传该 PHP 脚本文件后，浏览器的页面显示如下图所示。由于 4c-900.php 并非标准的图像文件，因此页面上显示为红叉。
图 4-106 上传了 PHP 脚本
接下来点击 4c-900.php 链接，就能使浏览器显示刚才上传的 PHP 脚本文件。如图 4-107 所示，点击后页面上显示了 etc/passwd 文件的内容。由此可以得知上传的 PHP 脚本在服务器上被成功执行了。
图 4-107 上传的 PHP 脚本在服务器上被执行
上传的脚本文件在服务器上被执行造成的影响与 OS 命令注入相同。由于 system
 和 passthru
 等函数都能用来调用 OS 命令，因此攻击者就能够执行当前操作系统账号权限范围内的所有操作。
安全隐患的产生原因
上传的文件能被作为脚本执行这一安全隐患的产生需满足如下两项条件。
上传的文件被保存至公开目录
上传后的文件扩展名能被指定为 .php 或 .asp 等表示脚本的扩展名
如果应用中的上传功能满足了上述两项条件，就会滋生安全隐患。因此，防范策略为至少消除上述两项条件中的任意一项。
对策
正如前项所介绍的那样，用户上传的文件能被作为脚本执行的条件为以下两项：文件被保存在公开目录中以及用户能指定文件扩展名为可执行的脚本文件。因此，消除上述任意一项条件就能防范安全隐患。而考虑到如果仅限制文件的扩展名很有可能会产生疏漏，因此，这里我们将主要介绍另一种对策方法，即不将文件保存在公开目录中。
为了避免将上传的文件保存在公开目录中，下载文件时就需要经过脚本。本书把此类脚本称为“下载脚本”。
使用下载脚本将 4c-002.php 加以改良，结果如下所示。
代码清单 /4c/4c-002a.php
">
已上传 
">
可以看出，上述脚本对原先脚本做了 2 处修改。首先，将文件的保存场所从公开目录（/4c/img）改为了由 get_upload_file_name
 函数返回的文件名。另外，取得图像的 URL 时使其经过了下载脚本。get_upload_file_name
 函数的源码如下所示。
代码清单 /4c/4c-002a.php（get_upload_file_name 的定义）
define('UPLOADPATH', '/var/upload');
function get_upload_file_name($tofile) {
  // 校验扩展名
  $info = pathinfo($tofile);
  $ext = strtolower($info['extension']);  // 扩展名（统一为小写字母）
  if ($ext != 'gif' && $ext != 'jpg' && $ext != 'png') {
    die(' 只能上传扩展名为 gif、jpg 或 png 的图像文件 ');
  }
  // 下面的处理为生成唯一的文件名
  $count = 0; // 尝试生成文件名的次数
  do {
    // 生成文件名
    $file = sprintf('%s/%08x.%s', UPLOADPATH, mt_rand(), $ext);
    // 生成文件，如果文件已存在则报错
    $fp = @fopen($file, 'x');
  } while ($fp === FALSE && ++$count  'image/gif', 'jpg' => 'image/jpeg',
'png' => 'image/png',);
$file = $_GET['file'];
$info = pathinfo($file);       // 取得文件信息
$ext = strtolower($info['extension']);     // 扩展名（统一为小写字母）
$content_type = $mimes[$ext]; // 取得 Content-Type
if (! $content_type) {
  die(' 只能上传扩展名为 gif、jpg 或 png 的图像文件  ');
}
header('Content-Type: ' . $content_type);
readfile(UPLOADPATH . '/' . basename($file));
?>
上述脚本是从查询字符串 file
 中取得文件名的。首先获取扩展名，如果不是 gif、jpg 或 png 就报错。接着输出与各扩展名相对应的 Content-Type，然后再使用 readfile
 函数读取文件内容并将其输出。这里将从查询字符串中取得的文件名经过 basename
 函数进行处理是为了防范目录遍历漏洞（参考 4.10 节）。
实施以上防范策略之后，用户上传的文件在服务器端被作为脚本执行这一安全隐患就能够得以消除。但是，如果用户使用的是 Internet Explorer（IE）浏览器，上述脚本就有遭到跨站脚本攻击的风险。此问题将在下一节讲述。
专栏：校验扩展名时的注意点
为了防范通过上传文件而使服务器执行脚本，本书介绍了使用下载脚本的方法。而如果只是为了防范文件被当作脚本执行，也能够采取校验文件扩展名的方法，只是实施周密的校验并不容易。
举例来说，使用名为 SSI（Server Side Include）的功能就能将 HTML 中引入（Include）的文件当作命令（Command）执行。虽然使用 SSI 的 HTML 文件的标准扩展名为 shtml，但是有时通过设置也能使扩展名为 html 的文件允许 SSI 功能。换言之，有些情况下也需要把扩展名为 html 的文件视为脚本文件。
由此可见，应该将哪些扩展名归类为可执行的脚本文件是不确定的。因此，校验扩展名时推荐只允许所需的最低限度。另外，如果没有特殊理由，还是推荐使用下载脚本的方法来加以应对。
4.12.3 文件下载引起的跨站脚本
概要
当用户下载已上传的文件时，浏览器有时会不能正确识别文件的类型。比如，尽管应用中认定某文件为 PNG 格式，但如果该图像文件的数据中包含 HTML 标签，在某些条件下浏览器就会将其误认为 HTML 文件，从而便会执行图像文件中的 JavaScript。这就是文件下载引起的跨站脚本（XSS）。
攻击者会通过上传嵌入 HTML 或 JavaScript 的图像文件或 PDF 文件来对此漏洞发起攻击。虽然用常规的方法阅览时，这些恶意文件并不会被识别为 HTML，但是攻击者会使用一些伎俩促使上传的文件被识别为 HTML。而一旦用户的浏览器将文件识别为 HTML，XSS 攻击就成功了。
文件下载引起的 XSS 攻击所造成的影响，与 4.3.1 节讲述的影响一样。
为此，可通过采取如下对策来防范文件下载引起的 XSS 漏洞。
正确设置文件的 Content-Type
确保图像文件的扩展名与内容（图像文件头）相符
判定为用于下载的文件时，在响应头中指定 Content-Disposition:attachment
文件下载引起的 XSS 漏洞总览