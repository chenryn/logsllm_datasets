checkpoint interval and each message generates bI bits of
trace, the size of the trace generated at a node in a checkpoint
interval due to messages sent by a node (γS) is their product
and is given in Eq. 2.
γS = α bI
(2)
Next, we calculate the size of the trace generated at a node
in a checkpoint interval due to messages received from another
node, γR, as follows. Out of the messages sent to a node in a
checkpoint interval, α, only the fraction (1 − pL) of them are
received and lead to a trace entry, where pL is the probability
of a message being lost. In CADeT, the size of the trace entry
of a received message depends on whether a message was
received in the order expected or not. If a message arrives
when it was expected, then the receive event ’R’ and the sender
alias are recorded in the trace and this requires bI bytes, similar
to recording a message send. However, if a message arrives
earlier or later than expected, then CADeT stores the sequence
number of the message into the trace in addition to the bI bytes
recorded in the trace. If the probability of a message arriving
when expected is pI, γR is given in Eq. 3.
= (1 − pL) (γS + α bS(1 − pI ))
γR = (1 − pL) ((α bI pI ) + (α (bI + bS) (1 − pI )))
(3)
(4)
In addition to tracing message sends and receives, CADeT
dumps the internal tables (AAMap and PCMap) to the trace
once every checkpoint
interval. This is referred to as the
checkpoint. Since the table contains one entry per partner, we
need to estimate the number of partners a node communicates
with in a checkpoint interval.
Each node communicates with its nR nodes regularly called
its regular partners and nO nodes occasionally, called its
occasional partners, over its lifetime. We observe that the
number of partners a node communicates with over its lifetime,
given by nR + nO, is much less than the total number of nodes
in the network (n).
In a checkpoint interval, we assume that a node commu-
nicates with all its regular partners (nR) and some of its
occasional partners (nO pO), where pO is the percentage of
occasional partners a node communicates with in a checkpoint
interval. Now, the number of partners a node communicated
with in a checkpoint interval (nP ) is given by Eq. 5.
nP = nR + nO pO
(5)
The size of that checkpoint, γC, is the product of the size
of the internal table entries, bA and the number of partners
this node communicated within that interval.
γC = (bA + bP ) nP
(6)
Since each node communicates with nP partners in a
checkpoint interval, the trace size due to messages sent and
received by a node is (γS + γR) nP . Thus, γN is given by
Eq. 7.
γN = γC + (γS + γR) nP
(7)
= nP ((bA + bP ) + γS (2 − pL) + α bS (1 − pI ) (1 − pL))
(8)
B. Liblog
A common way to capture message interactions in a dis-
tributed systems for replay is to record the Lamport clock
along with local non-determinism, including capturing entire
messages [29], [18], [33]. Since recording a full message
is prohibitively expensive, we adapt Liblog [29] for WSNs
as follows: record the sender address along with the Lam-
port clock for every message. This was also suggested by
Shea [31]. Henceforth, Liblog refers to this adapted version
of Liblog. Although it may lead to inconsistent replay when
message losses or out-of-order message arrivals can happen
as described before (cf. II-B), we use Liblog because it is the
known state-of-the-art.
We calculate the size of the trace generated by Liblog
in a checkpoint interval, δN , similar to CADeT. Since Li-
blog records Lamport clocks in the trace entry, the periodic
checkpoints taken by CADeT are not required as the clock
value is cumulative. However, the number of bits to record
the Lamport’s clock, bF is larger as Lamport’s clock increases
with each message sent from all the nodes. Therefore, the size
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 07:58:43 UTC from IEEE Xplore.  Restrictions apply. 
(pI ≥ 0.9), CADeT generates smaller size trace because of its
efﬁcient representation of common case. CADeT trace size
is only about 20% of Liblog trace size. When the messages
arrive out of order (pI ≤ 0.1), CADeT trace size is about 40%
of Liblog trace size. The competitive advantage of CADeT
decreased in this case because out-of-order message arrivals
require recording additional information such as recording
full sequence numbers per out-of-order message arrival. Next,
consider the scenario of high message losses (pL ≥ 0.9).
Irrespective of the order of message arrivals, CADeT trace size
is only 15% to 20% of Liblog trace size, which is somewhat
counterintuitive. The reason for this is that the lost messages
do not generate trace entries at the receiver but do have trace
entries at the sender. Since the messages are sent in order,
CADeT compresses trace entries corresponding to message
sends very well as opposed to Liblog. The few messages that
do get delivered at the receiver cause only small increase in
trace size for CADeT.
VI. EMPIRICAL EVALUATION
In order to empirically demonstrate our claims, we imple-
mented our technique CADeT as well as Liblog in TinyOS, a
widely used WSN operating system. Results show that CADeT
saves considerable energy at a moderate increase in program
memory and data memory. We ﬁrst present the evaluation
methodology, followed by energy overhead savings and ﬁnally
memory overhead.
A. Methodology
1) Metrics: We used the following three metrics to evaluate
our approach: (1) energy overhead, (2) program memory,
and (3) data memory. Energy overhead corresponds to the
additional energy required for tracing and is represented as
a percentage of energy consumed by an application without
tracing. Lower overhead is better. Observe that the savings in
energy overhead are mainly due to trace size reductions and
therefore, trace size reduction is implicit in energy overhead
savings obtained. Memory is a precious resource for WSNs
and both program memory and data memory are very limited.
Since saving traces to ﬂash occurs continuously while traces
are collected only upon error detection/suspicion, we omit
the latter overhead. Furthermore, there are techniques [47] to
reduce the trace collection overhead.
2) Benchmarks: For our benchmarks, we used three well-
known representative WSN applications which are packaged
with TinyOS. First, Oscilloscope is a data collection
application with high sensing rate (8 times a second). The
sensor samples are stored in a buffer and the buffer is sent to
the base station when full. Second, Surge is another data
collection application with medium sensing rate (1 in two
seconds). However, Surge is a more complex application
as it supports sophisticated routing and a query interface to
respond to base station queries. Finally, CntToRfmAndLeds
is a counter application that receives and broadcasts counter
values. We use oscil, surge and count respectively to
refer to these benchmarks.
Effect of probability of loss and out-of-order message arrivals on
. The x-axis is pL and each series in the graph correspond to different
Fig. 3.
γN
δN
values of pI.
of the trace generated by Liblog depends on the messages sent
and received. The trace size due to messages sent, δS is given
by Eq. 9.
δS = α bF
(9)
The messages received generate the same size trace entry
irrespective of whether the message was received in order or
not. The size of the trace generated at a node due to messages
received by it is given by Eq. 10.
δR = (1 − pL) α bF
(10)
The size of the trace generated in a checkpoint at a node,
δN is shown in Eq. 11, where nP is the number of partners a
node communicates with in a checkpoint interval and is shown
in Eq. 5.
δN = (δS + δR) nP = nP α bF (2 − pL)
(11)
C. Comparison
Next we compare the trace sizes generated at a single node
by CADeT and Liblog to quantify the advantage of CADeT.
The key difference between these two approaches stems from
the number of bits used to store a trace entry in the common
case, namely, bI for CADeT and bF for Liblog as we show
below.
The ratio of γN and δN is shown in Eq. 12.
(cid:18) bA + bP
(cid:19)
γN
δN
=
T1 =
+
bI
bF
α (2 − pL)
1
bF
, T2 =
T2
T1 +
(1 − pI )(1 − pL)
bS
bF
2 − pL
(12)
The smaller the ratio, the better it is for CADeT. We observe
that the ratio is heavily dependent on bI
because terms T1
bF
and T2 are usually small. Since the number of messages per
checkpoint interval α is large, T1 is usually small. To see
the effect of pL and pI, we varied pL and plotted the ratio
for different values of pI, which is shown in Figure 3. We
used the following values from our empirical evaluation for
other variables, namely bi = 1, bf = 6, bs = 3, ba = 2,
bp = 2 and α = 240. As mentioned above, irrespective of
the message losses and out-of-order message arrivals, the size
of CADeT traces is very small (15% to 40%) compared to
the size of Liblog traces. First consider the scenario of low
message losses (pL ≤ 0.1). When the messages arrive in order
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 07:58:43 UTC from IEEE Xplore.  Restrictions apply. 
0.150.250.350.4500.20.40.60.81pL0.90.50.1(a) Oscil
(b) Count
(c) Surge
Fig. 4. Energy overhead due to CADeT and Liblog as a percentage of energy consumption without tracing. The x-axis shows two conﬁgurations of tracing,
one, when just the messages are traced and the other, when control-ﬂow of the send and receive events along with messages are traced.
3) Simulation: We implemented our
technique using
TinyOS 1.x. While we tested our solution on real test beds, for
ease of measurement and parameter tuning, we used TOSSIM
simulator which allows simulating the code that runs on motes.
TinyOS 1.x was used because we used the open source Tiny-
Tracer [48] to generate interprocedural control ﬂow which uses
TinyOS 1.x. Our implementation is however version-agnostic
and can be used in TinyOS 2.x without any modiﬁcations. The
energy overheads are measured using PowerTOSSIM and the
memory overheads are reported by avr-gcc compiler (TinyOS
does not support dynamic allocation).
We ran our simulations for 7.5 minutes and 20 nodes
including the base station node. The traces generated are stored
in the external ﬂash of the motes. The energy overhead and
memory overhead reported are the averages over all nodes.
As we noted in Section IV, for several fault diagnostics, the
control ﬂow of send and receive events, which give hints
on the message contents such as type of the message, is
very helpful. Therefore, we show the tracing overhead for
two conﬁgurations: (a) just messages are traced and (b) both
messages and control-ﬂow of send and receive events are
traced. By send event control-ﬂow, we mean the control-ﬂow
of the send and sendDone functions at the network layer.
By receive event control ﬂow, we mean the control ﬂow of the
receive event handler at the network layer and the application
layer.
B. Energy Overhead Savings
Figure 4 shows the energy overhead due to CADeT and
Liblog when only messages are traced and when messages
and send/receive event control ﬂow are traced for all three
benchmarks. We used a well-known trace compression al-
gorithm called FCM (ﬁnite context method) [49], [50] to
compress the traces before writing to the ﬂash. We applied
trace compression for both CADeT and Liblog. These results
are shown as CADeT compressed and Liblog compressed.
We ﬁrst observe that CADeT signiﬁcantly reduces the
energy overhead (up to 18× smaller) of message tracing
compared to Liblog for all benchmarks. The savings increase
when trace compression is used. Since CADeT uses fewer
bits to record message sends and receives, CADeT savings
accumulate as many messages are exchanged over time. Fur-
thermore, CADeT encodes the entries such that they can be
highly compressed as opposed to Liblog, which uses clocks
that are not easily compressible.
Figure 5 compares Liblog’s and CADeT’s energy overhead
directly by showing Liblog’s energy overhead as a percentage
of CADeT’s energy overhead. Liblog uses up to 1366% of
the energy used by CADeT for the uncompressed case and
up to 1918% the energy of CADeT for the compressed case.
As explained before, the energy savings are more pronounced
in the compressed tracing case because of the compression
awareness of CADeT traces. The smaller beneﬁts for Surge
is due to its low duty cycle, which means Surge is mostly
idle and sends fewer messages, compared to others.
Fig. 5. Comparison of Liblog and CADeT energy overheads. Liblog energy
overhead is represented as percentage of CADeT energy overhead.
C. Memory Overhead
Since motes use Harvard architecture, which has separate
program memory and data memory (RAM), we measured
overheads on program memory and data memory. Data mem-