# sudo提权（CVE-2021–3156）：从堆溢出到命令执行的最后亿步
|
##### 译文声明
本文是翻译文章
译文仅供参考，具体内容表达以及含义原文为准。
## 1 漏洞说明
参考链接：  
[官方说明](https://blog.qualys.com/vulnerabilities-research/2021/01/26/cve-2021-3156-heap-based-buffer-overflow-in-sudo-baron-samedit)  
[官方说明txt版本](https://www.qualys.com/2021/01/26/cve-2021-3156/baron-samedit-heap-based-overflow-sudo.txt)  
[CVE-2021-3156 sudo漏洞分析与利用](https://www.jianshu.com/p/18f36f1342b3)  
[CVE-2021-3156 sudo 提权漏洞复现与分析](https://ama2in9.top/2021/02/04/cve-2021-3156/)  
[Exploit Writeup for CVE-2021–3156 (Sudo Baron Samedit)](https://datafarm-cybersecurity.medium.com/exploit-writeup-for-cve-2021-3156-sudo-baron-samedit-7a9a4282cb31)  
[参考exp](https://github.com/blasty/CVE-2021-3156)
**所有的分析都是在有tcachebin的情况下，因此要求libc版本大于2.25！！！**
**影响版本：**
  * 1.9.0  `可以既满足if的条件，又可以在参数中任意插入`'\'`，从而进入到存在漏洞的for循环。
  1. 1.NewArgv是字符串指针数组，也就是NewArgv[1]指向的是`argv1`（PS:NewArgv[0]指向的命令本身，同char *argv[]）；
  2. 2.user_args是在堆中申请的内存块（chunk），用于将NewArgv数组中的字符串拼接起来，去掉转义字符（漏洞点），不同参数之间以 **空格** 分隔（ **PS：这点请注意，后面有用** ）。
  3. 3.NULL并不在函数`isspace`检测范围内；
  4. 4.NewArgv指向的字符串在栈中是连续存放的，并且参数之后就是环境变量；  
根据代码可以知道，在sudoedit
-s参数的末尾使用`'\'`，当`from`指向`\`时，from[1]指向NULL字节，from[2]指向的就是环境变量的第一个字节了，执行`*too=*from++`，可以将后面的NULL字节拷贝到`user_args`的堆中，且让`from++`，从而避开了`while(*from）`判断是否读到NULL字节的检测，由于参数后面紧跟环境变量的值，因此通过
**设置环境变量的值来覆盖user_args堆后面的数据** 。
2.堆溢出要覆盖的结构体是`service_user`（ **PS:这个是官方文档中提到的方法中的一个，也是我仅会的一个** ）
    //glibc-2.31\nss\nsswitch.h
    typedef struct service_user
    {
      /* And the link to the next entry.  */
      struct service_user *next;
      /* Action according to result.  */
      lookup_actions actions[5];
      /* Link to the underlying library object.  */
      service_library *library;
      /* Collection of known functions.  */
      void *known;
      /* Name of the service (`files', `dns', `nis', ...).  */
      char name[0];
    } service_user;
    //glibc-2.31\nss\nsswitch.c
    static int
    nss_load_library (service_user *ni)
    {
      if (ni->library == NULL)
        {
          /* This service has not yet been used.  Fetch the service
       library for it, creating a new one if need be.  If there
       is no service table from the file, this static variable
       holds the head of the service_library list made from the
       default configuration.  */
          static name_database default_table;
          ni->library = nss_new_service (service_table ?: &default_table,
                 ni->name);
          if (ni->library == NULL)
      return -1;
        }
      if (ni->library->lib_handle == NULL)
        {
          /* Load the shared library.  */
          size_t shlen = (7 + strlen (ni->name) + 3
              + strlen (__nss_shlib_revision) + 1);
          int saved_errno = errno;
          char shlib_name[shlen];
          /* Construct shared object name.  */
          __stpcpy (__stpcpy (__stpcpy (__stpcpy (shlib_name,
                    "libnss_"),
                ni->name),
            ".so"),
        __nss_shlib_revision);//拼接so文件名
          ni->library->lib_handle = __libc_dlopen (shlib_name);//加载so文件
如果service _user只有`service_user.name`存在值，那么最后会加载  
libnss_.so。  
参考exp中将name覆盖为`X/P0P_SH3LLZ_`  
因此加载的so文件为：`libnss_X/P0P_SH3LLZ_.so`，但实际不是，可以看Makefile，生成的so文件是`'libnss_X/P0P_SH3LLZ_
.so.2'`，多了一个空格。  
参考文档中也都提到了通过`setlocale`方法配合设置的LC_系列的环境变量，能够让分配给`user_args`的chunk在`service_user`使用的chunk前面，再利用堆溢出覆盖，从而达到任意so加载，也就执行任意命令，命令中执行/bin/bash即可获取root的shell，所以离提权也就剩最后亿步了。
## 2 环境准备
选择了参考exp中的环境`Ubuntu 20.04.1 (Focal Fossa) - sudo 1.8.31, libc-2.31`
  1. 1.获取sudo源码，源码直接下载至当前文件夹。 
        sudo apt source sudo
  2. 2.安装可调试的glibc(PS：这一步如果你安装了pwndbg，其实就已经完成了) 
        sudo apt install libc6-dbg
    sudo apt install libc6-dbg:i386
  3. 3.获取glibc源码 
        sudo apt source libc6-dev
  4. 4.确定偏移  
由于没有安装sudo的调试版本，因此需要确定一下漏洞点的偏移，想定位的点为malloc调用(为user_args分配堆空间的地方)。知道这段代码是在sudoers.so（已经不记得哪篇文章里看到的，并不是自己分析出来的）。  
定位方法比较简单，运气成分居多，首先在源码找到漏洞点，这个搜索`set_cmnd`函数即可，然后在函数中看到字符串`"command too
long"`，之后在IDA中搜索该字符串，引用该字符串的只有这一个函数（分析已经重命名过了）  
之后就是F5大法，慢慢看了，最终找到的malloc调用的地方，偏移`0x23133`。  
除了确定这个偏移，还需要确定sudoedit何时加载的sudoers.so，只有加载之后才能在sudoers.so中设置断点。  
仍然没有什么好方法，纯运气，sudoedit拖入IDA，搜索关键字`sudoers.so`  
虽然有两处引用，但是都在同一个函数里（分析已经重命名过了），再查看该函数的引用，就是在main函数中。  
所以在调用该函数的地方下个断点，运行过该函数之后，sudoers.so就加载进入内存了，之后就可以去malloc调用的点下断点。函数调用偏移为`0x6d8e`。
## 3 setlocale函数
此函数跟漏洞点无关，但是跟堆布局有关，想要完全了解可以去看源码，代码在glibc源码中，配合gdb的源码调试会比较清楚。  
 **全局变量**  
`_nl_global_locale`，主要关注其`__names`成员。  
栗子：
`__names`是一个数组，长度为13，下标值在代码中称为`category`，不同`category`值表示含义如下所示
    //glibc-2.31\locale\locale.h
    #define LC_CTYPE          __LC_CTYPE
    #define LC_NUMERIC        __LC_NUMERIC
    #define LC_TIME           __LC_TIME
    #define LC_COLLATE        __LC_COLLATE
    #define LC_MONETARY       __LC_MONETARY
    #define LC_MESSAGES       __LC_MESSAGES
    #define  LC_ALL        __LC_ALL
    #define LC_PAPER    __LC_PAPER
    #define LC_NAME        __LC_NAME
    #define LC_ADDRESS     __LC_ADDRESS
    #define LC_TELEPHONE   __LC_TELEPHONE
    #define LC_MEASUREMENT    __LC_MEASUREMENT
    #define LC_IDENTIFICATION __LC_IDENTIFICATION
    //glibc-2.31\locale\bits\locale.h
    #define __LC_CTYPE       0
    #define __LC_NUMERIC     1
    #define __LC_TIME     2
    #define __LC_COLLATE     3
    #define __LC_MONETARY       4
    #define __LC_MESSAGES       5
    #define __LC_ALL      6
    #define __LC_PAPER       7
    #define __LC_NAME     8
    #define __LC_ADDRESS     9
    #define __LC_TELEPHONE     10
    #define __LC_MEASUREMENT   11
    #define __LC_IDENTIFICATION   12
除了LC_ALL，其余可以看成是单独的项。  
如果其余的值一样，比如都是`C.UTF-8`，那么LC_ALL的值也是`C.UTF-8`。  
如果不是完全一样，那么LC_ALL的值就是`LC_CTYPE=.....;LC_NUMERIC=...;....LC_IDENTIFICATION=....`
###  3.1 setlocale(LC_ALL,””)
    //glibc-2.31\locale\findlocale.c
    struct __locale_data *
    _nl_find_locale (const char *locale_path, size_t locale_path_len,
         int category, const char **name)
    {
      int mask;
      /* Name of the locale for this category.  */
      const char *cloc_name = *name;
      const char *language;
      const char *modifier;
      const char *territory;
      const char *codeset;
      const char *normalized_codeset;
      struct loaded_l10nfile *locale_file;
      if (cloc_name[0] == '\0')
        {
          /* The user decides which locale to use by setting environment
       variables.  */
          cloc_name = getenv ("LC_ALL");
          if (!name_present (cloc_name))
      cloc_name = getenv (_nl_category_names_get (category));
          if (!name_present (cloc_name))
      cloc_name = getenv ("LANG");
          if (!name_present (cloc_name))
      cloc_name = _nl_C_name;
        }
  1. `cloc_name`的值来源是先读取环境变量LC_ALL，若没有再根据category的值去读取对应的环境变量，exp代码都是通过环境变量来控制`cloc_name`的，因此`cloc_name`的值最初就是来源于设置的环境变量，且`cloc_name`的值最终会拷贝至`堆块`，并将字符串指针存入`_nl_global_locale.__names`。
  2. 函数`_nl_find_locale`设置的是除LC_ALL以外的其他category的值，LC_ALL的值是由`new_composite_name`函数确定，逻辑是之前说的。
  3. setlocale(LC_ALL,””)函数在我们视角里需要知道的就是会通过环境变量的值来设置`_nl_global_locale.__names`，并且里面的字符串都是在堆中的。
  4. 设置LC_的值是从尾部开始的，也就是category的值是从12~0来遍历的（跳过6，即LC_ALL）。
###  3.2 setlocale(LC_ALL,NULL)
返回`_nl_global_locale.__names`中LC_ALL对应的值。
    //glibc-2.31\locale\setlocale.c
    char *
    setlocale (int category, const char *locale)
    {