title:ZOZZLE: Fast and Precise In-Browser JavaScript Malware Detection
author:Charlie Curtsinger and
Benjamin Livshits and
Benjamin G. Zorn and
Christian Seifert
ZOZZLE: Fast and Precise In-Browser JavaScript Malware Detection
Charlie Curtsinger
Univ. of Mass., Amherst
Benjamin Livshits and Benjamin Zorn
Microsoft Research
Christian Seifert
Microsoft
Abstract
JavaScript malware-based attacks account for a large
fraction of successful mass-scale exploitation happening
today. Attackers like JavaScript-based attacks because
they can be mounted against an unsuspecting user visit-
ing a seemingly innocent web page. While several tech-
niques for addressing these types of exploits have been
proposed, in-browser adoption has been slow, in part be-
cause of the performance overhead these methods incur.
In this paper, we propose ZOZZLE, a low-overhead so-
lution for detecting and preventing JavaScript malware
that is fast enough to be deployed in the browser.
Our approach uses Bayesian classiﬁcation of hier-
archical features of the JavaScript abstract syntax tree
to identify syntax elements that are highly predictive
of malware. Our experimental evaluation shows that
ZOZZLE is able to detect JavaScript malware through
mostly static code analysis effectively. ZOZZLE has an
extremely low false positive rate of 0.0003%, which is
less than one in a quarter million. Despite this high ac-
curacy, the ZOZZLE classiﬁer is fast, with a throughput of
over one megabyte of JavaScript code per second.
1
Introduction
In the last several years, we have seen mass-scale ex-
ploitation of memory-based vulnerabilities migrate to-
wards heap spraying attacks. This is because more tra-
ditional vulnerabilities such as stack- and heap-based
buffer overruns, while still present, are now often mit-
igated by compiler techniques such as StackGuard [7]
or operating system mechanisms such as NX/DEP and
ALSR [12]. While several heap spraying solutions have
been proposed [8, 9, 21], arguably, none are lightweight
enough to be integrated into a commercial browser.
However, a browser-based detection technique is still
attractive for several reasons. Ofﬂine scanning is often
used in modern browsers to check whether a particular
site the user visits is benign and to warn the user other-
wise. However, because it takes a while to scan a very
large number of URLs that are in the observable web,
some URLs will simply be missed by the scan. Ofﬂine
scanning is also not as effective against transient mal-
ware that appears and disappears frequently.
ZOZZLE is a mostly static JavaScript malware detec-
tor that is fast enough to be used in a browser. While
its analysis is entirely static, ZOZZLE has a runtime com-
ponent: to address the issue of JavaScript obfuscation,
ZOZZLE is integrated with the browser’s JavaScript en-
gine to collect and process JavaScript code that is cre-
ated at runtime. Note that fully static analysis is difﬁcult
because JavaScript code obfuscation and runtime code
generation are so common in both benign and malicious
code.
Challenges: Any technical solution to the problem out-
lined above requires overcoming the following chal-
lenges:
ployed in a mainstream browser;
• performance: detection is often too slow to be de-
• obfuscated malware: because both benign and ma-
licious JavaScript code is frequently obfuscated,
purely static detection is generally ineffective;
• low false positive rates: given the number of URLs
on the web, while false positive rates of 5% are
considered acceptable for, say, static analysis tools,
rates even 100 times lower are not acceptable for
in-browser detection;
• malware transience:
mises the effectiveness of ofﬂine-only scanning.
transient malware compro-
Because it works in a browser, ZOZZLE uses the Java-
Script runtime engine to expose attempts to obscure mal-
ware via uses of eval, document.write, etc. by hooking
the runtime and analyzing the JavaScript just before it
is executed. We pass this unfolded JavaScript to a static
classiﬁer that is trained using features of the JavaScript
AST (abstract syntax tree). We train the classiﬁer with a
collection of labeled malware samples collected with the
NOZZLE dynamic heap-spraying detector [21]. Related
work [4, 6, 14, 22] also classiﬁes JavaScript malware us-
ing a combination of static and dynamic features, but re-
lies on emulation to deobfuscate the code and to observe
dynamic features. Because we avoid emulation, our anal-
ysis is faster and, as we show, often superior in accuracy.
Contributions: this paper makes these contributions:
• Mostly static malware detection. We propose
ZOZZLE, a highly precise, lightweight, mostly static
JavaScript malware detector. ZOZZLE is based on
extensive experience analyzing thousands of real
malware sites found while performing dynamic
crawling of millions of URLs using the NOZZLE
runtime detector.
• AST-based detection. We describe an AST-based
technique that
involves the use of hierarchical
(context-sensitive) features for detecting malicious
JavaScript code. This context-sensitive approach
provides increased precision in comparison to na¨ıve
text-based classiﬁcation.
• Fast classiﬁcation. Because fast scanning is key to
in-browser adoption, we present fast multi-feature
matching algorithms that scale to hundreds or even
thousands of features.
• Evaluation. We evaluate ZOZZLE in terms of per-
formance and malware detection rates, both false
positives and false negatives. ZOZZLE has an ex-
tremely low false positive rate of 0.0003%, which is
less than one in a quarter million, comparable to ﬁve
commericial anti-virus products we tested against.
To obtain these numbers, we tested ZOZZLE against
a collection of over 1.2 million benign JavaScript
samples. Despite this high accuracy, the classiﬁer is
very fast, with a throughput at over one megabyte
of JavaScript code per second.
Classiﬁer-based tools are susceptible to being circum-
vented by an attacker who knows the inner workings of
the tool and is familiar with the list of features being
used, however, our preliminary experience with ZOZZLE
suggests that it is capable of detecting many thousands of
malicious sites daily in the wild. We consider the issue
of evasion in Section 6.
Paper Organization: The rest of the paper is organized
as follows. Section 2 gives some background informa-
tion on JavaScript exploits and their detection and sum-
marizes our experience of performing ofﬂine scanning
with NOZZLE on a large scale. Section 3 describes the
implementation of our analysis. Section 4 describes our
experimental methodology. Section 5 describes our ex-
perimental evaluation. Section 6 provides a discussion
// Shellcode
var shellcode=unescape(’\%u9090\%u9090\%u9090\%u9090...’);
bigblock=unescape(’\%u0D0D\%u0D0D’);
headersize=20;
shellcodesize=headersize+shellcode.length;
while(bigblock.length
Figure 1: Heap spraying attack example.
of the limitations and deployment concerns for ZOZZLE.
Section 7 discusses related work, and, ﬁnally, Section 8
concludes.
Appendices are organized as follows. Appendix A
discusses some of the hand-analyzed malware samples.
Appendix B explores tuning ZOZZLE for better precision.
Appendix C shows examples of non-heap spray malware
and also anti-virus false positives.
2 Background
This section gives overall background on JavaScript-
based malware, focusing speciﬁcally on heap spraying
attacks.
2.1
JavaScript Malware Background
Figure 1 shows an example of real JavaScript malware
that performs a heap spray. Such malware consists of
three relatively independent parts. The shellcode is the
portion of executable machine code that will be placed
on the browser heap when the exploit is executed. It is
typical to precede the shellcode with a block of NOP in-
structions (so-called NOP sled). The sled is often quite
large compared to the size of the subsequence shellcode,
so that a random jump into the process address space is
likely to hit the NOP sled and slide down to the start of
the shellcode. The next part is the spray, which allocates
many copies of the NOP sled/shellcode in the browser
heap. In JavaScript, this is easily accomplished using an
array of strings. Spraying of this sort can be used to de-
feat address space layout randomization (ASLR) protec-
tion in the operating system. The last part of the exploit
triggers a vulnerability in the browser; in this case, the
vulnerability is a well-known ﬂaw in Internet Explorer 6
that exploits a memory corruption issue with function
addBehavior.
Note that the example in Figure 1 is entirely unob-
fuscated, with the attacker not even bothering to rename
variables such as shellcode, nopsled, and spray to make
the attack easier to spot. In practice, many attacks are
obfuscated prior to deployment, either by hand, or using
one of many available obfuscation kits [11]. To avoid de-
tection, the primary technique used by obfuscation tools
is to use eval unfolding, i.e. self-generating code that
uses the eval construct in JavaScript to produce more
code to run.
2.2 Characterizing Malicious JavaScript
ZOZZLE training is based on results collected with the
NOZZLE heap spraying detector. To gather the data we
use to train the ZOZZLE classiﬁer and evaluate it, we em-
ployed a web crawler to visit many randomly selected
URLs and process them with NOZZLE to detect if mal-
ware was present.
Once we determine that JavaScript is malicious, we
invested a considerable effort in examining the code by
hand and categorizing in various ways. One of the in-
sights we gleaned from this process is that once unfolded,
most malware does not have that much variety, following
the traditional long tail pattern. We discuss some of the
hand-analyzed samples in Appendix A.
Any ofﬂine malware detection scheme must deal with
the issues of transience and cloaking. Transient mali-
cious URLs go ofﬂine or become benign after some pe-
riod of time, and cloaking is when an attack hides itself
from a particular user agent, IP address range, or from
users who have visited the page before. While we tried
to minimize these effects in practice by scanning from a
wider range of IP addresses, in general, these issues are
difﬁcult to fully address.
Figure 2 summarizes information about malware tran-
sience. To compute the transience of malicious sites, we
re-scan the set of URLs detected by Nozzle on the previ-
ous day. This procedure is repeated for three weeks (21
days). The set of all discovered malicious URLs were
re-scanned on each day of this three week period. This
means that only the URLs discovered on day one were
re-scanned 21 days later. The URLs discovered on day
one happened to have a lower transience rate than other
days, so there is a slight upward slope toward the end of
the graph.
Any ofﬂine scanning technique will have difﬁculty
keeping up with malware exhibiting such a high rate of
Figure 2: Transience of detected malicious URLs after several days.
The number of days is shown of the x axis, the percentage of remaining
malware is shown on the y axis.
Figure 3: Unfolding tree: an example. Rectangles are documents,
and circles are JavaScript contexts. Gray circles are benign, black are
malicious, and dashed are “co-conspirators” that participate in deob-
fuscation. Edges are labeled with the method by which the context or
document was reached. The actual page contains 10 different exploits
using the same obfuscation.
transience–Nearly 20% of malicious URLs were gone af-
ter a single day. We believe that in-browser detection
is desirable, in order to be able to detect new malware
before it has a chance to affect the user regardless of
whether the URL being visited has been scanned before.
2.3 Dynamic Malware Structure
One of the core issues that needs to be addressed when
talking about JavaScript malware is the issue of obfusca-
0%10%20%30%40%50%60%70%80%90%100%0123456789101112131415161718192021Remaining Malicious URLs es.doowon.ac.kr18.7KB1.0KBeval0.1KB...65Bwww.andywu.com20.2KB50B3.0KBevalevaldepends ondepends on65Bwww.andywu.com2.53KB50B0.6KBevalevaldepends ondepends on...x 10X 13Figure 4: Distribution of context counts for malware and benign code.
tion. In order to avoid detection, malware writers resort
to various forms of JavaScript code obfuscation, some of
which is done by hand, other with the help of many avail-
able obfuscation toolkits [11]. While many approaches
to code obfuscation exist, in our experience we see eval
unfolding as the most commonly used. The idea is to use
the eval language feature to generate code at runtime in
a way that makes the original code difﬁcult to pattern-
match. Often, this form of code unfolding is used repeat-
edly, so that many levels of code are produced before the
ﬁnal, malicious version emerges.
Example 1 Figure 3 illustrates the process of code un-
folding using a speciﬁc malware sample obtained from
a web site http://es.doowon.ac.kr. At the time of
detection, this malicious URL ﬂagged by NOZZLE con-
tained 10 distinct exploits, which is not uncommon for
malware writers, who tend to “over-provision” their ex-
ploits: to increase the changes to successful exploitation,
they may include multiple exploits within the same page.
Each exploit in our example is pulled in with an 
tag.
Each of these exploits is packaged in a similar fashion.
The leftmost context is the result of an eval in the body of
the page that deﬁnes a function. Another eval call from
the body of the page uses the newly-deﬁned function to
deﬁne another new function. Finally, this function and
another eval call from the body exposes the actual ex-
ploit. Surprisingly, this page also pulls in a set of benign
contexts, consisting of page trackers, JavaScript frame-
works, and site-speciﬁc code. (cid:3)
Note, however, that the presence of eval unfolding
does not provide a reliable indication of malicious in-
tent. There are plenty of perfectly benign pages that also
perform some form of code obfuscation, for instance, as
a weak form of copy protection to avoid code piracy.
Many commonly used JavaScript library frameworks do
the same, often to save space through client-side code
generation.
Figure 5: ZOZZLE training illustrated.
We instrumented the ZOZZLE deobfuscator to collect
information about which code context leads to other
code contexts, allowing us to collect information about
the number of code contexts created and the unfolding
depth. Figure 4 shows a distributions of JavaScript con-
text counts for benign and malicious URLs. The ma-
jority of URLs have only several JavaScript code con-
texts, however, many can be have 50 or more, created
through either  or  inclusion or eval un-
folding. Some pages, however, may have as many as 200
code contexts. In other words, a great deal of dynamic
unfolding needs to take place before these contexts will
“emerge” and will be available for analysis.
It is clear from the graph in Figure 4 that, contrary to
what might have been thought, the number of contexts is
not a good indicator of a malicious site. Context counts
were calculated for all malicious URLs from a week of
scanning with NOZZLE and a random sample of benign
URLs over the same period.
3