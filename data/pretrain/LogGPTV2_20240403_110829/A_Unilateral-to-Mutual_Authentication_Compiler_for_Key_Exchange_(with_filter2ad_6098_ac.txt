tant examples serving as motivation for the notion of tran-
script replication attacks introduced in the next section and
central to our analysis (and with direct implications to the
security of client authentication in TLS 1.3).
MACing the server identity S. We show a UA proto-
col that when upgraded to MA via SIGMAC but without
including the server’s identity under the client’s MAC, re-
sults in a MA protocol that is open to a UKS attack (the
necessity of including C under the MAC is more obvious
since anyone can sign the transcript hence such a signature
has no binding to the UA run). The UA protocol is a simple
server-authenticated DH exchange where the client sends a
DH value gx to which the server responds with gy and a sig-
nature on gx and gy. The session key K is derived from gxy.
If we extend this to a MA protocol via SIGMAC but remov-
ing S from the MAC, namely, C sends M ACKa (C) and its
signature on both gx and gy (whose concatenation deﬁnes
sid), the resultant protocol is open to a UKS attack as fol-
lows. A malicious server S(cid:48) relays gy to C but signs it with
its own signature. When C responds with M ACKa (C), S(cid:48)
sends this message to S. In this case Ks is computed by both
C and S. But while S has C as the peer to the exchange, C
has S(cid:48) as the peer, hence resulting in a UKS attack.
Pre-shared key protocols and why sometimes even
signing the whole transcript is not enough. We show
an example of a UA protocol where applying the SIGMAC
compiler with the entire transcript under the client’s signa-
ture does not result in a MA-secure protocol. For this we
consider a UA-secure protocol Π1 where the client uses as
the server’s credentials the server’s identity and a symmetric
pre-shared key (PSK). We assume that this key, that might
have been previously shared by C with S through another
UA key exchange protocol, has been authenticated only by
S (as in the resumption mode of TLS 1.3). We deﬁne Π1 as
an implicitly-authenticated protocol where the parties just
exchange nonces (which form the whole transcript) and the
session key is derived by applying a PRF keyed with PSK
to the nonces. It is not hard to show that Π1 with sid set
to the concatenation of the nonces is UA-secure. Now, con-
sider the protocol Π2 resulting from applying SIGMAC to
Π1 where we set the transcript core included in sid∗ to the
entire transcript. Let S(cid:48) be an attacker that has a shared
key with C and one with S (the two keys may be random
and independent) and interacts as a MitM between C and
S, acting as the server with C and as a client with S. S(cid:48)
simply relays without modiﬁcation the nonces chosen by C
and S. In addition, S(cid:48) forwards C’s signature on sid∗ to S
but replaces the MAC generated by C with a MAC com-
puted by S(cid:48) on identities (C, S) using a MAC key derived
from the PSK that S(cid:48) shares with S. As a result S ends its
session with peer C but with a session key that is known
to S(cid:48)! Note that if we add explicit authentication to Π1 by
sending a MAC from the server to client (using a key derived
from the PSK) but this MAC is not included in sid∗ then
the above attack works as well. Moreover, as we will see in
Section 4.2, in some cases even including the server’s MAC
under the signature is still not enough to provide MA secu-
1442rity (in particular, this indicates that the source of problem
was not in the implicit authentication nature of Π1).
Interestingly, this attack scenario was discovered by the
Tamarin team [11] in their formal analysis of an early draft
of TLS 1.3, showing that this is not just an hypothetical
concern but something that can arise in practice.
SIGMAC security for DH-based protocols (and some
more subtleties). An important and extensive class of
protocols where SIGMAC can be applied to lift a protocol
from UA to MA are protocols that provide forward secrecy
by deriving the session key from a DH value gxy, where
gx, gy are exchanged between C and S and gy is authen-
ticated by S. We show in Section 4.1 that deﬁning sid∗ to
include both values gx, gy is suﬃcient for SIGMAC to ensure
MA security.
As yet another interesting subtlety regarding SIGMAC,
we can show that without including gy under the client’s
signature, MA-security is not guaranteed (this is somewhat
counter-intuitive as one could expect that signing the client’s
message, with some freshness information from the server,
would suﬃce). For this we consider a simple UA protocol,
namely, a DH exchange between C and S where the server
signs the whole transcript. If gy is not included under the
client’s signature, an attacker S(cid:48) can change gy to g2y lead-
ing C to compute its MAC using a key derived from g2xy
while S derives the veriﬁcation key from gxy. Using ideas
similar to the example used in [26] to show the necessity of
the PRF-ODH assumption in the analysis of TLS 1.2, one
can build a KDF and MAC so that the MAC computed on
(chosen) values C and S(cid:48) with a key derived from g2xy re-
sults in the same MAC tag as when computed on values C
and S with key derived from gxy. Also, the session key com-
puted through the KDF is the same when derived from gxy
and g2xy. This results in a UKS attack where both C and S
compute the same session key but while S binds it to peer
C, C binds it to peer S(cid:48) (which signed g2y). While clearly
requiring contrived MAC and KDF functions, this argument
shows that if one does not include gy in sid∗, the SIGMAC
compiler cannot be proved to work without assuming addi-
tional properties of the KDF and MAC functions.
4. TRANSCRIPT-REPLICATION (TREPLI-
CATION) SECURITY
As shown in Section 3.1, the information that needs to
be signed by the client in the SIGMAC compiler, namely
sid∗, plays an essential role in the security of the compiler.
The value sid∗ is comprised of the session id sid and a sub-
set of transcript elements as deﬁned next via the notion of
treplication security.
Definition 1
(Treplication security). We say that
a UA protocol Π is secure against transcript replication (trepli-
cation) attacks with respect to a transcript subset τ (called
a transcript core)4 if any eﬃcient UA-attacker S(cid:48) against Π
has only negligible probability to win the Test experiment on
a fresh session (S, sid) for which there is a session (C, S(cid:48), sid)
with same session identiﬁer sid and same transcript core τ
as (S, sid), and where C is a honest client.
4That is, we view the protocol transcript as an ordered set of
(possibly optional) elements and deﬁne the transcript core
as a speciﬁed subset or projection.
Note that while S(cid:48) is given the same capabilities of a UA at-
tacker and the same indistinguishability Test, the conditions
for the choice of the test session are very diﬀerent than in the
regular UA model (in particular, this is a server’s session,
not a client’s one). Essentially, the requirement is that if S(cid:48)
acts as a man-in-the-middle between honest parties C and S
but cannot change or choose the session id sid and transcript
core τ sent between C and S, then S’ cannot learn informa-
tion on the session key computed by S. This requirement
is incomparable to UA security, namely, it is not implied by
nor it implies UA security.
The importance of the treplication security notion is demon-
strated by Theorem 3 where we show that joint UA and
treplication security suﬃces for the successful use of the SIG-
MAC compiler. Here we prove some important classes of
UA protocols to be treplication-secure (with respect to spe-
ciﬁc deﬁned transcript cores), hence upgradeable to mutual
authentication via SIGMAC. These protocols include those
discussed in Section 3.1 and those with direct application
to TLS 1.3 client authentication (particularly to the PFS
modes of the protocol as well as the non-PFS PSK mode
which also functions as session resumption).
4.1 Treplication security of DH Protocols
In Section 3.1 we showed some of the subtleties arising in
proving treplication security of DH protocols. Here we show
how such security can be achieved. We consider three cases:
(i) plain DH where gxy is only used to derive the session
key; (ii) in addition to deriving the session key from gxy,
additional keys used during the key exchange protocol itself
are derived from gxy - however, we assume that the session
key is secure (indistinguishable from uniform) even if these
additional keys are provided to the attacker; (iii) the expo-
nent x (and/or y) is used for additional computation (not
just for computing gxy). We note that case (i), while be-
ing the simplest and more natural, is generally insuﬃcient
for addressing real-world protocols. Case (ii) is directly rele-
vant to TLS 1.3 in its 1-RTT mode and in the pre-shared key
mode with PFS (the additional gxy-derived keys are used for
handshake traﬃc protection). Case (iii) would show up in a
protocol like QUIC [27], or a similar extension to TLS 1.3,
where two DH keys involving gx are derived: an ephemeral
gxy as well as a key gxs that combines gx with a public key
gs of the server.
Lemma 2. Let Π be a UA-secure Diﬃe-Hellman protocol
of the above types over a group G. Then, under the DDH
assumption on G, Π is treplication-secure if one deﬁnes the
transcript core τ to include the session identiﬁer sid of Π as
well as the two DH values gx and gy.
4.2 Treplication security of PSK Protocols
Here we consider pre-shared key (PSK) key-exchange pro-
tocols, namely, protocols where the parties use as their cre-
dentials a symmetric key they previously shared by some
method (e.g., out-of-band or a previous key exchange exe-
cution). We are interested in protocols that are UA-secure,
hence we assume the shared key to have been authenticated
only by the server (TLS 1.3 resumption presents such a case).
PSK protocols that oﬀer forward secrecy (i.e., derive their
session key through a DH exchange) are treplication-secure
under the conditions demonstrated earlier. Thus, here we fo-
cus on UA PSK protocols without forward secrecy and inves-
tigate under which conditions they are treplication-secure.
1443We’ve seen in Section 3.1 that the basic implicitly-authenticated
PSK protocol where the parties exchange nonces and derive
a session key from their PSK and nonces (without further
authentication) cannot be made treplication-secure even if
the full transcript (the nonces in this case) is included in sid∗.
Thus we consider an extension of this protocol that is UA-
secure with explicit authentication where S sends a MAC
computed on the nonces with a MAC key derived from the
PSK (this MAC would correspond to the server’s Finished
message in TLS). For the moment we restrict the transcript
to only include the random nonces of C and S, denoted
nC , nS, and the server’s MAC. We refer to this protocol as
Basic-UA-PSK and deﬁne the whole transcript as the tran-
script core τ .
Interestingly, this protocol is not treplication-secure for
generic MAC functions. However, we can prove its security
under a mild assumption on MAC security. Please see full
version for the full treatment of treplication security of PSK
protocols.
4.3 One-pass (0-RTT) Protocols
TLS 1.3 supports a so-called 0-RTT handshake consisting
of a one-pass authenticated key-exchange protocol where au-
thentication is carried through the use of a pre-shared key
that client and server exchange in a previous regular hand-
shake, typically with server-only authentication. In partic-
ular, this mode is used to instantiate session resumption
in TLS 1.3. The 0-RTT handshake essentially consists of
the client sending a key identiﬁer (that allows the server
to identify or compute the pre-shared key K) and a nonce.
The session key (used to immediately encrypt client’s data)
is derived from a combination of the key K and the client’s
nonce. Note that there is no server’s nonce assumed in the
protocol which opens this mode to replay attacks. Here we
discuss how client authentication could be added to such a
mode, although TLS 1.3 does not currently support client
authentication for 0-RTT.
We ﬁrst note that one-pass protocols can be framed in the
CK model through an adaptation as presented in [18], and
the above nonce-based protocol can be proven to be UA-
secure in this model. Thus, we can apply SIGMAC to this
protocol MAC-ing the identities of C and S (in the case of
TLS 1.3, the MAC would be implemented via the client’s
Finished message that is part of the 0-RTT exchange) and
signing the client’s nonce (which acts as sid). Note, however,
that SIGMAC assumes a server’s nonce which is not present
here but this requirement can be relaxed if one accepts re-
play attacks in the model (as in [18]). More fundamentally,
the above one-pass protocol is not treplication secure for rea-
sons similar to (and more straightforward than) the inter-
active PSK case discussed in Section 3.1. Speciﬁcally, the
attacker S(cid:48) would establish separate pre-shared keys with
both C and S (with S(cid:48) acting as server and client, respec-
tively) and later run a 0-RTT handshake with both parties,
relaying the client-chosen nonce to S. Clearly, S(cid:48) learns the
key computed by S as it knows the pre-shared key used
by S, hence breaking treplication security.5 Unfortunately,
and in contrast to the interactive PSK case treated earlier,
this treplication insecurity cannot be ﬁxed without includ-
ing the server’s identity (or a value derived from it, such
5The attack is possible even if a nonce by S is involved and
may even work if the key identiﬁer is part of the transcript
core as long as S(cid:48) can choose the same key identiﬁer as S.
as resumption_context discussed before) in the transcript
core. Thus, client authentication for 0-RTT would need to
include the server’s identity (and nonce) under the client’s
signature. Fortunately, in the next section we show that
when the server’s identity is signed by C, SIGMAC ensures
MA security even if the base UA protocol is not treplication
secure.
5. PROOF OF THE SIGMAC COMPILER
We prove the security of the SIGMAC compiler deﬁned in
Section 3 for treplication-secure protocols. We assume the
MAC and signature functions used in SIGMAC to be secure
in the standard chosen-message unforgeability sense.
Theorem 3. Let Π1 be a secure unilaterally authenticated
KE protocol that is also treplication-secure with transcript
core τ and set sid∗ to the concatenation of the session id
sid and τ . Then protocol Π2 resulting from the application
of the SIGMAC compiler with this sid∗ is a secure mutually
authenticated KE protocol.
Before proving the theorem we recall some of the adver-
sarial actions in each model and how they diﬀer in the case