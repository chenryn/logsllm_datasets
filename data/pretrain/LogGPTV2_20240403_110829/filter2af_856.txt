**前言**
这个说来话长,先是学弟发现了弱口令,然后有可恶的waf，然后一起来绕一波,然后还有一波番外情节,先来描述一下番外情结
**番外篇**  
在渗透这个系统的过程中,我抓包在js发现了被注释掉的另外一个网站，手滑顺手访问之,发现竟然和我学校的这个平台一模一样,因为学校有waf所以我就先搞这个一样的平台，同样弱口令进入后台，任意文件上传，getshell
一气呵成 然后 绕了bypassdisable 用的是  
 这个大哥的脚本
这位大哥我是真的佩服 他在freebuf发的文章我也全部看过,真的厉害 回到正题
getshell后我发现这竟然是运维的服务器,后面提了一波权,非常可惜的是,redis反弹root权限shell回来后,我添加完用户,退出shell
去连ssh 发现密码不对..... 同时 我ps -ef 看了一下 瞬间 我的心中有一万只草泥马飞过,
我想一拳锤爆电脑，....redis被打下线了....我苦苦等待了几天，还是没有上线,......机会一去不复返.............运维的机器上有很多宝藏,以后日站可以找找运维的站,一般都会搭建相同的环境，当然比最后线上的脆弱许多.好了不bb太多了
说正文把
**正文**
进后台后，找到上传点,首先我发现改后缀后重新发包生成的文件的后缀没有变化,我第一次后缀是.jpg 第二次改成.x 但是显示上传成功还是jpg
此时有一丝不安涌上心头  
接着我想是不是上图中的moudle值影响 然后我改了moudle值 发包 咦 上传成功 然后返回文件还是jpg 不慌 继续  
然后我改了文件内容 在一发包 嘿嘿 返回文件后缀变成 x了 此时
心中已经是胸有成竹(应该是判断了文件内容,一样的话就不变,之前也没注意文件名..只盯着后缀了)
好像已经日下来了一样(没想到后面绕waf饶了好久)......
刚开始的时候 我发现只要一个包被waf检测到 那直接封几个小时.....我擦了...有这么变态的吗.................然后第一天果断放弃
玩玩游戏什么的不香吗.....
第二天晚上 有点无聊 打开burp 打开浏览器 访问之 , 这次我发包学聪明了,之前一发恶意包 然后wating 好久 然后connect reset
然后凉凉,这次我发现只要在waiting 我直接cancle 我发现这样竟然不会马上封我 可能因为 我提前断开连接了? 还是什么原因不知道
这样就可以继续fuzzing了  
刚开始尝试就给我当头一棒 waf直接检测 ，这告诉 PHP 开始和停止解析二者之间的代码。此种解析方式使得 PHP
可以被嵌入到各种不同的文档中去，而任何起始和结束标记之外的部分都会被 PHP 解析器忽略。  
PHP 也允许使用短标记 ，但不鼓励使用。只有通过激活 php.ini 中的 short_open_tag 配置指令或者在编译 PHP
时使用了配置选项 --enable-short-tags 时才能使用短标记  
因为需要开启一个配置选项,所以说只能是碰碰运气,没想到还真可以,发了个
浏览器访问只有1111出现,嘿嘿，讲到这儿又要说一下怎么绕过 filename='xxxxx.php' 这个地方waf的检测了,也就是如何上传php文件
开始试了几种
    'xx.jpg.php' 'xxx.php.jpg'  截断 还有各种后缀 phtml pht php3 php4 Php 
    filename='xxxxx.jpg'；filename='xxxxx.php'
还有几种奇奇怪怪的模式 等等发现都绕不过 这时候想起来从别人那学到的垃圾数据,你别说,垃圾数据真给力,我生成了30w个1,发包!
一发入魂,成功让waf崩溃或者说waf对filename的长度没有处理什么的 如下图:  
接下来继续说php文件的内容如何绕过waf,经过漫长的尝试我发现 eval() 不能出现 而且很多函数 比如 file_get_contents()
都是不能直接出现的 不过有一些函数可以通过
    $a="file_"+"get_"+"contents"; $a();
这种方式来利用 但是不是所有函数都可以 什么 eval file_put_contents 都不行 本来准备利用
file_put_contents来写文件的这条路也不行了  
还想到了 无字母shell  
可惜直接传不行 需要在后面加一个左括号 ( 或者 右括号 ) 可能检测了括号的匹配对数 然后我尝试 注释掉多余的括号 但是发现 加了注释就绕不过了 ....  
思考的时候,瞅了瞅以前绕waf的一些东西(所以说收集一些免杀东西什么还是有用的),直接放上去都不太行,不过我发现了一个比较关键的 那就是利用注释来进行混淆
几次尝试后发现
    eval(/*-/*-*/$p/*-/*-*//*-/*-*//*-/*-*/);
这个不会被拦截,终于,我看到了希望,只要eval不被拦,什么都有戏,然后就是 如何构造这个$p了 直接
    $p=$_GET['x'];$p=$_POST['x'];$p=$_SERVER['X']
这样都是不行会被封, 不过嘛还有 php//:input 关于php//:input流,我从百度找的介绍:  
php://input :  
php://input 是个可以访问请求的原始数据的只读流。 POST 请求的情况下，最好使用 php://input 来代替
$HTTP_RAW_POST_DATA
通过他能获取参数就是 那么基本的小马就形成了 如下:  
我是希望利用上面这个小马来写文件,下面这个图是测试的phpinfo 就是上面这个图去掉file_put_contents的版本
具体的截图我找不到了...将就一下........
成功 发现disable了一些东西 刚开始也尝试过写cmd马 也没写成功 看来成功了也没用 给禁掉了
然后直接发包
    file_put_contents('1.php',base64_decode('流量加密小马内容'))
还是我太天真了 直接给我封了 过不去 看来还需要一层加密 多加一层base64就ok
测试一下  
nice!
直接写流量加密小马!
蚁剑访问之 看到了 绿色的连接成功 心中一丝舒爽涌上心头
**end**  
写完这个文章也已经12点过了,过几天把漏洞交给学校.附赠一枚上面的小马,有需要的可以拿走.