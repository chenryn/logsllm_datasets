872         if (reserve  (d->
header->root()), together with the lines where the
three objects pointed to by d->header->root() re-
side. In the bottom part, the related C++ source ﬁles are
listed brieﬂy, showing that TCD is able to detect
type
confusion bugs across different ﬁles precisely and inter-
procedurally. By performing our type-aware pointer analysis,
we ﬁnd that d->header in line 688 (qjsonvalue.cpp)
points to the three Header objects allocated in line 79
(qjson.cpp), 840 (qjson_s.h) and 880 (q_jsons.h)
respectively. In line 688, d->header->root() skips these
three Header objects and points to their Base objects
following them in memory layout. Then a dangerous downcast
happens in line 688, where a Base object is downcast to a
QJsonPrivate::Object object. The ad hoc implemen-
tations of C++ inheritance can be seen in lines 77 – 79
(qjson.cpp), 839 – 840 (qjson_s.h) and 867 – 880
(q_jsons.h), where memory blocks larger than the size of a
Base object are allocated. As highlighted in Figure 8, this bug
pattern can lead to out-of-bound memory access. As shown in
Figure 9, a TCD warning can clearly pinpoint where such
potential security vulnerabilities are in large C++ projects.
2) Efﬁciency: TCD spends a total of 26,107 seconds, i.e.,
7.3 hours on analyzing the seven Qt tools totaling 526,385
lines of C++ code. This is not unreasonable.
(cid:20)(cid:17)(cid:17)
B. RQ2: TCD vs. Dynamic Detectors
Of the ﬁve type confusion bugs listed in Tables IV and
V, HexType [6], a dynamic detector, can only detect B1 in
Table IV but not B2 – B5 in Table V. This demonstrates TCD’s
ability to ﬁnd new bugs in large C++ projects that can be
difﬁcult to reach by dynamic tools (as motivated in Figure 2).
Given a C++ program, dynamic detectors such as HexType
perform instrumentation at compile time. In order to detect
type confusion bugs at testing stage, an instrumented C++
program will be run repeatedly with different inputs so that
more bugs can be triggered. While much work has been done
in various sorts of testing techniques [23], [33]–[38], dynamic
detectors still suffer from low code coverage. As motivated
in Figure 2, hard_to_satisfy(), which represents a
complex condition that is very hard to satisfy, represents still
an obstacle to dynamic analysis. However, TCD can often ﬁnd
potentially bugs despite its being path-insensitive.
Another rarely-discussed obstacle is container coverage,
which may require every element of a container (e.g., an
array) to be tested in order to ﬁnd a particular bug. Consider
a simple program in Figure 10. In line 7, a fuzzer [23], [38]
can easily generate a random value x to satisfy x >= 0 &&
x = 0 && x (ptr[x]);
In contrast, TCD is a static detector, which is cur-
ignore the
rently path-insensitive. In Figure 2, TCD will
hard_to_satisfy() condition in line 15 while still being
able to detect the type confusion error in line 18. In Figure 10,
TCD will ignore the condition in line 7 by analyzing ptr
conservatively as a pointer rather than an array of pointers, so
that ptr points to all the objects pointed to individually by
its elements. Under this abstraction, ptr may point to either
a Derived object (line 4) or a Base object (line 6). Thus,
TCD can also expose the type confusion bug in line 8.
By being path-insensitive, TCD can improve code coverage
but may suffer from unavoidable false positives. In a real
program containing lines 7 – 8 in Figure 10, if x can never be
2019 under any program input, then the type confusion error in
line 8 reported by TCD will be a false positive. In addition, as a
static detector, TCD is expected to consume tens of gigabyte
memory space in analyzing large C++ programs. Compared
with dynamic detectors, precise static solutions may not scale
to tens of millions lines of code [39].
V. RELATED WORK
We review the work relevant to TCD, by focusing on
dynamic techniques for detecting type confusion bugs and
control ﬂow integrity (CFI) techniques for enforcing CFI.
tables to detect whether a type cast
Dynamic Type Confusion Detectors. Undeﬁned Behavior
Sanitizer (UBSan) [9] relies on the type information stored
in virtual
is safe or
not and is thus limited to protecting polymorphic classes
only. CAVER [10] instruments C++ programs and maintains
metadata for both polymorphic and non-polymorphic classes.
Since red-black trees are used to store metadata for stack and
global objects at O(log n), it can incur high instrumen-
tation overhead if most of the allocated objects are on the
stack. TypeSan [12] relies on a compact memory shadow-
ing mechanism to trace all objects in a uniform way, such
that the overhead of tracing objects is reduced. But it may
conﬂict with address space layout randomization [40]. The
limitation on high instrumentation overhead has subsequently
been addressed by HexType [6], Bitype [14], and CastSan [15].
Finally, EffeciveSan [13] can detect not only type confusion
bugs but also memory-related bugs.
These dynamic detectors can ﬁnd type confusion bugs
precisely, but suffer from low code coverage and high instru-
mentation overhead. In contrast, TCD can reveal potential type
confusion bugs across the entire program statically, but at the
expense of introducing false positives.
Control Flow Integrity. Type confusion bugs may lead to
control ﬂow attacks, which can be mitigated by control ﬂow
integrity [41]–[44]. CFI states that program execution must
follow the control ﬂow graph (CFG) generated at compile
time. Two main challenges remain: how to make control-
ﬂow targets in the CFG precise and how to make dynamic
checks at these control-ﬂow targets efﬁcient. In general, CFI
defense mechanisms only protect code pointers. However, type
confusion bugs can be exploited to corrupt not only code
pointers but also other sensitive data.
VI. CONCLUSIONS
We have introduced a new static detector, TCD, in LLVM
for ﬁnding type confusion bugs in C++ programs, based
on a type-casting-preserving C++ compiler front-end and a
type-aware pointer analysis. TCD has found four new type
confusion bugs in Qt [32], which have evaded detection of
previous (dynamic) approaches with a low false positive rate.
In one future work, we plan to extend TCD by consider-
ing path-sensitivity to reduce the false positives reported. In
another future work, we plan to combine static and dynamic
analyses to obtain the best of both worlds.
ACKNOWLEDGEMENTS
We thank all the reviewers for their valuable inputs. This
work has been supported by Australian Research Council
Grants (DP170103956 and DP180104069).
(cid:20)(cid:17)(cid:18)
REFERENCES
[1] S. Nagarakatte, J. Zhao, M. M. Martin, and S. Zdancewic, “Softbound:
Highly compatible and complete spatial memory safety for c,” in
Proceedings of the 30th ACM SIGPLAN Conference on Programming
Language Design and Implementation, 2009, pp. 245–258.
[2] ——, “Cets: compiler enforced temporal safety for c,” in ACM Sigplan
Notices, vol. 45, no. 8, 2010, pp. 31–40.
[3] D. Ye, Y. Su, Y. Sui, and J. Xue, “Wpbound: Enforcing spatial memory
safety efﬁciently at runtime with weakest preconditions,” in Proceedings
of the 25th International Symposium on Software Reliability Engineer-
ing, 2014, pp. 88–99.
[4] T. Jim, J. G. Morrisett, D. Grossman, M. W. Hicks, J. Cheney, and
Y. Wang, “Cyclone: A safe dialect of c,” in Proceedings of the USENIX
Annual Technical Conference, 2002, pp. 275–288.
[5] H. Yan, Y. Sui, S. Chen, and J. Xue, “Spatio-temporal context reduction:
A pointer-analysis-based static approach for detecting use-after-free
vulnerabilities,” in Proceedings of the 40th International Conference on
Software Engineering, 2018, pp. 327–337.
[6] Y. Jeon, P. Biswas, S. Carr, B. Lee, and M. Payer, “Hextype: Efﬁcient
detection of type confusion errors for C++,” in Proceedings of the 24th
ACM SIGSAC Conference on Computer and Communications Security,
2017, pp. 2373–2387.
[7] C. Cowan, C. Pu, D. Maier, H. Hintony, J. Walpole, P. Bakke, S. Beattie,
A. Grier, P. Wagle, and Q. Zhang, “Stackguard: Automatic adaptive
detection and prevention of buffer-overﬂow attacks,” in Proceedings of
the 7th Conference on USENIX Security Symposium, 1998, pp. 1–16.
[8] “Common vulnerabilities and exposures,” https://cve.mitre.org/, accessed
May 18, 2019.
[9] “Undeﬁned behavior sanitizer,” https://www.chromium.org/developers/
testing/undeﬁnedbehaviorsanitizer, accessed May 18, 2019.
[10] B. Lee, C. Song, T. Kim, and W. Lee, “Type casting veriﬁcation:
Stopping an emerging attack vector.” in Proceedings of the 24th USENIX
Conference on Security Symposium, 2015, pp. 81–96.
[11] S. Kell, “Dynamically diagnosing type errors in unsafe code,” in
Proceedings of the 31st ACM SIGPLAN International Conference on
Object-Oriented Programming, Systems, Languages, and Applications,
2016, pp. 800–819.
[12] I. Haller, Y. Jeon, H. Peng, M. Payer, C. Giuffrida, H. Bos, and
E. Van Der Kouwe, “Typesan: Practical type confusion detection,” in
Proceedings of the 23rd ACM SIGSAC Conference on Computer and
Communications Security, 2016, pp. 517–528.
[13] G. J. Duck and R. H. Yap, “Effectivesan:
type and memory error
detection using dynamically typed C/C++,” in Proceedings of the 39th
ACM SIGPLAN Conference on Programming Language Design and
Implementation, 2018, pp. 181–195.
[14] C. Pang, Y. Du, B. Mao, and S. Guo, “Mapping to bits: Efﬁciently
detecting type confusion errors,” in Proceedings of the 34th Annual
Computer Security Applications Conference, 2018, pp. 518–528.
[15] P. Muntean, S. Wuerl, J. Grossklags, and C. Eckert, “Castsan: Efﬁcient
detection of polymorphic C++ object type confusions with LLVM,” in
Proceedings of the 23rd European Symposium on Research in Computer
Security, 2018, pp. 3–25.
[16] C. Sadowski, J. van Gogh, C. Jaspan, E. S¨oderberg, and C. Winter,
“Tricorder: Building a program analysis ecosystem,” in Proceedings of
the 37th International Conference on Software Engineering, 2015, pp.
598–608.
[17] Y. Sui and J. Xue, “SVF: interprocedural static value-ﬂow analysis
in LLVM,” in Proceedings of the 25th International Conference on
Compiler Construction, 2016, pp. 265–266.
[18] T. Tan, Y. Li, and J. Xue, “Efﬁcient and precise points-to analysis:
Modeling the heap by merging equivalent automata,” in Proceedings of
the 38th ACM SIGPLAN Conference on Programming Language Design
and Implementation, 2017, pp. 278–291.
[19] C. Lattner and V. Adve, “LLVM: A compilation framework for lifelong
program analysis & transformation,” in Proceedings of the 2nd Interna-
tional Symposium on Code Generation and Optimization, 2004, p. 75.
[20] F. Schuster, T. Tendyck, C. Liebchen, L. Davi, A. Sadeghi, and T. Holz,
“Counterfeit object-oriented programming: On the difﬁculty of prevent-
ing code reuse attacks in c++ applications,” in Proceedings of the 36th
IEEE Symposium on Security and Privacy, 2015, pp. 745–762.
[21] C. Zhang, D. Song, S. A. Carr, M. Payer, T. Li, Y. Ding, and C. Song,
“Vtrust: Regaining trust on virtual calls.” in Network and Distributed
System Security Symposium, 2016.
[22] C. Zhang, C. Song, K. Z. Chen, Z. Chen, and D. Song, “Vtint: Protecting
virtual function tables’ integrity.” in Network and Distributed System
Security Symposium, 2015.
[23] M. Zalewski, “American fuzzy lop (AFL)
fuzzer,” http://lcamtuf.
coredump.cx/aﬂ/, accessed May 18, 2019.
[24] H. Peng, Y. Shoshitaishvili, and M. Payer, “T-Fuzz: fuzzing by program
transformation,” in Proceedings of the 39th IEEE Symposium on Security
and Privacy, 2018, pp. 697–710.
[25] D. J. Pearce, P. H. Kelly, and C. Hankin, “Efﬁcient ﬁeld-sensitive pointer
analysis of c,” ACM Trans. Program. Lang. Syst., vol. 30, no. 1, 2007.
[26] Y. Sui, P. Di, and J. Xue, “Sparse ﬂow-sensitive pointer analysis
for multithreaded programs,” in Proceedings of the 14th International
Symposium on Code Generation and Optimization, 2016, pp. 160–170.
[27] R. P. Wilson and M. S. Lam, “Efﬁcient context-sensitive pointer analysis
for c programs,” in Proceedings of the 16th ACM SIGPLAN Conference
on Programming Language Design and Implementation, 1995, pp. 1–12.
[28] D. Gens, S. Schmitt, L. Davi, and A.-R. Sadeghi, “K-miner: Uncover-
ing memory corruption in linux,” in Network and Distributed System
Security Symposium, 2018.
[29] H. Chen, Y. Xue, Y. Li, B. Chen, X. Xie, X. Wu, and Y. Liu, “Hawkeye:
towards a desired directed grey-box fuzzer,” in Proceedings of the 25th
ACM SIGSAC Conference on Computer and Communications Security,
2018, pp. 2095–2108.
[30] Y. Sui and J. Xue, “On-demand strong update analysis via value-ﬂow
reﬁnement,” in Proceedings of the 24th ACM SIGSOFT International
Symposium on Foundations of Software Engineering, 2016, pp. 460–
473.
[31] T. Ravitch, “Whole program LLVM,” https://github.com/travitch/
whole-program-llvm, accessed May 18, 2019.
[32] “QT,” https://www.qt.io/, accessed May 18, 2019.
[33] Y. Zhang, Z. Chen, J. Wang, W. Dong, and Z. Liu, “Regular property
guided dynamic symbolic execution,” in Proceedings of the 37th Inter-
national Conference on Software Engineering, 2015, pp. 643–653.
[34] C. Cadar, D. Dunbar, D. R. Engler et al., “Klee: Unassisted and auto-
matic generation of high-coverage tests for complex systems programs.”
in Proceedings of the 8th USENIX Symposium on Operating Systems
Design and Implementation, 2008, pp. 209–224.
[35] H. Wang, T. Liu, X. Guan, C. Shen, Q. Zheng, and Z. Yang, “De-
pendence guided symbolic execution,” IEEE Transactions on Software
Engineering, vol. 43, no. 3, pp. 252–271, 2017.
[36] P. Godefroid, M. Y. Levin, D. A. Molnar et al., “Automated whitebox
fuzz testing.” in Network and Distributed System Security Symposium,
2008.
[37] P. Godefroid, N. Klarlund, and K. Sen, “Dart: Directed automated
random testing,” in Proceedings of the 26th ACM SIGPLAN Conference
on Programming Language Design and Implementation, 2005, pp. 213–
223.
[38] M. B¨ohme, V.-T. Pham, M.-D. Nguyen, and A. Roychoudhury, “Directed
greybox fuzzing,” in Proceedings of the 24th ACM SIGSAC Conference
on Computer and Communications Security, 2017, pp. 2329–2344.
[39] T. Zhang, W. Shen, D. Lee, C. Jung, A. M. Azab, and R. Wang, “Pex: A
permission check analysis framework for linux kernel,” in Proceedings
of the 28th USENIX Conference on Security Symposium, 2019, pp. 1205–
1220.
[40] “Address space layout randomization,” https://pax.grsecurity.net/docs/
aslr.txt, accessed May 18, 2019.
[41] M. Abadi, M. Budiu, U. Erlingsson, and J. Ligatti, “Control-ﬂow
integrity,” in Proceedings of the 12th ACM SIGSAC Conference on
Computer and Communications Security, 2005, pp. 340–353.
[42] C. Tice, T. Roeder, P. Collingbourne, S. Checkoway, U. Erlingsson,
L. Lozano, and G. Pike, “Enforcing forward-edge control-ﬂow integrity
in GCC & LLVM,” in Proceedings of the 23rd USENIX Conference on
Security Symposium, 2014, pp. 941–955.
[43] B. Niu and G. Tan, “Per-input control-ﬂow integrity,” in Proceedings of
the 22nd ACM SIGSAC Conference on Computer and Communications
Security, 2015, pp. 914–926.
[44] X. Fan, Y. Sui, X. Liao, and J. Xue, “Boosting the precision of
virtual call integrity protection with partial pointer analysis for c++,”
in Proceedings of the 26th ACM SIGSOFT International Symposium on
Software Testing and Analysis, 2017, pp. 329–340.
(cid:20)(cid:17)(cid:19)