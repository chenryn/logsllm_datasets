图22 -一个极简的DLL，只有一个导入描述符(NTDLL)
## **连接本机NTDLL**
一旦我们修改了挂钩引擎以匹配上述所有限制，我们就可以更深入地了解挂钩机制本身。MinHook以及大多数此类库所使用的挂钩技术被称为“[内联Hook]"(:
    1. 在进程的地址空间中分配一个“蹦床”，并将最终被钩住的函数的序言复制到其中。
    2. 将JMP指令放在蹦床中，就在复制的prolog之后。这个JMP应该指向原函数序言后面的指令。
    3. 在蹦床中放置另一条JMP指令，就在复制的prolog之前。这个JMP应该指向一个detour函数(通常在我们之前注入到进程中的DLL中)。
    4. 用指向蹦床的JMP指令覆盖钩子函数prolog。
图23.1 内联钩子的一般示意图。  
图23.2 蹦床的视图。用红色标记的是跳转到detour函数，用绿色标记的是从钩子函数复制的指令，然后跳转回该函数。  
这个挂钩方法通过修改钩子函数的序言来工作，因此每当应用程序调用它时，都会调用detour函数。然后，detour函数可以执行任何代码之前、之后或替代原始函数。  
在64位模式下，大多数挂钩引擎使用两种不同类型的跳转来实现挂钩功能和蹦床:
  1. 从钩形函数到蹦床的跳转是一个编码为“E9 ”的[相对跳转](https://c9x.me/x86/html/file_module_x86_id_147.html)。由于该指令在dword大小的操作数上运行，因此蹦床距离钩形函数的距离必须不超过2GB。这种形式的跳转通常被选择用于此步骤，因为它只占用5个字节，因此它足够紧凑，可以整齐地放入函数的prolog中。
  2. 从蹦床跳到detour函数再跳到钩子函数，如图23.2所示，是被编码为“FF25 ”(助记形式:JMP qword ptr [rip+偏移])的间接的、与rip相关的跳转。这条指令将跳转到一个64位的绝对地址，存储在RIP指向的位置加上偏移量。
在本地64位进程中运行时，使用这种技术的挂钩引擎工作得很好。可以预料，蹦床与目标函数的距离很短(高达2GB)，因此允许成功的二进制插装。  
然而，最近对WoW64进程内存布局的一些更改保证了，如果没有一些额外的更改，这种技术就不能应用于本机NTDLL。约内斯库亚历克斯在他的博客,最近Windows版本(从Windows
8.1更新3),本机NTDLL已经搬迁:而不是被加载到低4 gb的地址空间与其他过程的模块,现在加载到一个更高的地址。  
图24 Windows 10(左)和Windows 7(右)64位NTDLL的基本地址。  
4GB边界上的其余地址空间(本机NTDLL和本机CFG位图除外)由SEC_NO_CHANGE
VAD保护，因此任何人都不能访问、分配或释放地址空间。这意味着蹦床总是被分配在地址空间的4GB下面。由于64位系统中总的用户模式地址空间是128TB，所以本机NTDLL和蹦床之间的距离肯定会远远大于2GB。这使得大多数挂接引擎释放的JMP都不够用。  
图25 说明WoW64进程在Windows 8.1和更高版本上的内联钩子需要的控制传输。注意，在Windows 10 RS4预览版(build
17115)中，SEC_NO_CHANGE VADs似乎已经不存在了，内存可以在进程地址空间的任何地方分配。
### *** JMP的另一种形式**
为了克服这个问题，我们必须用不同的指令替换相对的JMP，该指令能够通过128TB的距离。在寻找替代品时，我们偶然发现了Gil
Dabah列出了一些可能的选项的帖子。在取消所有“玷污”注册表的选项之后，我们只剩下[几个可行的选项](http://www.ragestorm.net/blogs/?p=107)。最初，我们试图用一种类似于蹦床使用的间接的、与rip相关的JMP替换相对JMP:  
这条指令在Windows 10上运行良好，为我们提供了一种在WoW64进程中测试各种本机API函数的方法。但是，当在Windows 8.1和Windows
7等早期Windows版本上测试修改后的代码时，它并没有完全创建钩子。事实证明，这些Windows版本中的NTDLL函数 比Windows
10的版本短](  
图26 -在Windows 10 RS2(左)和Windows 8.1(右)中实现ZwAllocateVirtualMemory()。  
要使我们的DLL在所有Windows版本中通用，我们必须找到一个更短的指令，仍然能够分支到蹦床。最终，我们提出了一个利用蹦床位置的解决方案:既然蹦床必须分配在地址空间的4GB以下，那么它的8字节地址的上4字节就归零了。这让我们可以使用以下选项，它只占用6个字节:  
这种方法之所以有效，是因为在x64代码中，当与4字节操作数一起提供时，PUSH指令实际上会将8字节的值推送到堆栈上。上面的4字节用作符号扩展，这意味着只要4字节地址不大于2GB，它们就会为零。  
然后我们使用RET指令，它从堆栈中弹出一个8字节的地址并跳转到它。因为我们刚刚把蹦床的地址推到了堆栈的顶部，那就是我们的返回地址。  
图27 NtAllocateVirtualMemory()包含我们修改过的钩子。请注意前两个指令，它们将蹦床的地址推入堆栈，并立即“返回”到它。  
这种方法只剩下一个问题，就是CFG引起的。正如在 [本系列的第2部分 ](https://www.sentinelone.com/blog/deep-hooks-monitoring-native-execution-wow64-applications-part-2/)中提到的，WoW64进程中的所有私有内存分配—包括用于钩子的蹦床—都被单独标记在WoW64 CFG位图中。  
无论何时我们希望从绕道执行原始API函数，我们首先需要调用蹦床，以便运行该函数的prolog。但是，如果我们的DLL是用CFG编译的，它将尝试在调用之前根据本机CFG位图验证蹦床地址。由于这种不匹配，验证将失败，导致流程终止。  
这个问题的解决方案相当简单——控制DLL的配置，我们可以简单地编译它而不启用CFG。这是通过从编译器的命令行中删除/guard:cf标志来完成的。
### **防止无限递归**
在使用挂钩引擎时要考虑的最后一个问题是无限递归。放置钩子之后，每当对钩子函数进行调用时，这个调用就会到达我们的迂回路径。但是，我们的迂回函数也执行它们自己的代码，这些代码本身可能会调用钩形函数，导致我们回到我们的迂回。除非小心处理，否则这会导致无限递归。  
图28 当LdrLoadDll上的钩子试图加载另一个DLL时，无限递归  
对于这个问题，通常有一个简单的解决方案:声明一个线程局部变量，它计算我们所处的递归的“深度”，并且第一次只在detour函数内部执行代码`(counter
== 1)`:  
图29 -计算递归深度的线程局部变量  
不幸的是，我们不能在DLL中使用线程局部变量，原因有两个:  
1.隐式`TLS (__declspec(thread))`很大程度上依赖于CRT，我们无法使用它。  
2.显式`TLS api (TlsAlloc() / TlsFree()`等)完全在kernel32中实现。它的64位版本没有加载到WoW64进程中。  
尽管有这些限制，`wow64.dll`确实使用TLS存储，可以通过查看“!wow64exts.info”命令的输出来验证:  
图30 WoW64 dll使用的TLS变量  
结果是，Wow64。dll不会在运行时动态分配TLS插槽，而是在tlsslot数组中直接从TEB访问的硬编码位置(已经在每个线程的基础上实例化了)。  
图31 Wow64SystemServiceEx将线程局部变量写入TlsSlots数组中的硬编码位置
经过一些经验测试，我们发现`WoW64.dll`从未使用过64位TEB中的大多数TLS插槽，因此对于这个PoC，我们可以预先分配其中一个来存储计数器。不能保证这个插槽在未来的Windows版本中不会使用，所以产品级别的解决方案可能会查看TEB的其他可用成员。  
图32 使用未使用的TEB成员来计算递归的“深度”
## **总结**
这是我们“深钩”系列的第三部分也是最后一部分。在这三篇文章中，我们介绍了几种不同的方法，将64位DLL注入到WoW64进程中，然后使用它在64位NTDLL中挂钩API函数。希望这个选项能够让安全产品更好地了解WoW64进程，并使它们对“天堂之门”之类的绕过更有弹性。
在本系列文章中介绍的方法仍然有其局限性，以[新的缓解选项](https://msdn.microsoft.com/en-us/library/windows/desktop/ms686880\(v=vs.85).aspx)的形式出现，例如动态代码限制、CFG导出抑制和代码完整性保护。当启用时，这些可能会阻止我们创建钩子或完全阻止我们的注入，但在以后的文章中会详细介绍。
> 原文： wow64-applications-part-3>