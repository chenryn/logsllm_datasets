或者是单向散列函数算法，加密后存储在数据库中。这样做是为了尽最大可能地保证密
码的私密性。即使是网站的管理人员，也不能够看到用户的密码。在这种情况下，黑客
即使入侵了网站，导出了数据库中的数据，也无法获取到密码的明文。
2011年12月，国内最大的开发者社区CSDN的数据库被黑客公布在网上。令人震惊
的是，CSDN将用户的密码明文保存在数据库中，致使600万用户的密码被泄露。明文
保存密码的后果很严重，黑客们曾经利用这些用户名与密码，尝试登录了包括QQ、人
人网、新浪微博、支付宝等在内的很多大型网站，致使数以万计的用户处于风险中。
一个提供彩虹表查询的MD5破解网站
为了避免密码哈希值泄露后，黑客能够直接通过彩虹表查询出密码明文，在计算密
码明文的哈希值时，增加一个“Salt”。“Salt”是一个字符串，它的作用是为了增加明文的
复杂度，并能使得彩虹表一类的攻击失效。
Salt的使用如下：
MD5(Username+Password+Salt)
其中，Salt = abcddcba……（随机字符串）。
Salt应该保存在服务器端的配置文件中，并妥善保管。
9.3 多因素认证
对于很多重要的系统来说，如果只有密码作为唯一的认证手段，从安全上看会略显
不足。因此为了增强安全性，大多数网上银行和网上支付平台都会采用双因素认证或多
因素认证。
比如中国最大的在线支付平台支付宝，就提供很多种不同的认证手段：
支付宝提供的多种认证方式
除了支付密码外，手机动态口令、数字证书、宝令、支付盾、第三方证书等都可用
于用户认证。这些不同的认证手段可以互相结合，使得认证的过程更加安全。密码不再
是唯一的认证手段，在用户密码丢失的情况下，也有可能有效地保护用户账户的安全。
多因素认证提高了攻击的门槛。比如一个支付交易使用了密码与数字证书双因素认
证，成功完成该交易必须满足两个条件：一是密码正确；二是进行支付的电脑必须安装
了该用户的数字证书。因此，为了成功实施攻击，黑客们除了盗取用户密码外，还不得
不想办法在用户电脑上完成支付，这样就大大提高了攻击的成本。
9.4 Session与认证
密码与证书等认证手段，一般仅仅用于登录（Login）的过程。当登录完成后，用
户访问网站的页面，不可能每次浏览器请求页面时都再使用密码认证一次。因此，当认
证成功后，就需要替换一个对用户透明的凭证。这个凭证，就是SessionID。
当用户登录完成后，在服务器端就会创建一个新的会话（Session），会话中会保
存用户的状态和相关信息。服务器端维护所有在线用户的Session，此时的认证，只需
要知道是哪个用户在浏览当前的页面即可。为了告诉服务器应该使用哪一个Ses-sion，
浏览器需要把当前用户持有的SessionID告知服务器。
最常见的做法就是把SessionID加密后保存在Cookie中，因为Cookie会随着HTTP请
求头发送，且受到浏览器同源策略的保护（参见“浏览器安全”一章）。
Cookie中保存的SessionID
SessionID一旦在生命周期内被窃取，就等同于账户失窃。同时由于SessionID是用
户登录之后才持有的认证凭证，因此黑客不需要再攻击登录过程（比如密码），在设计
安全方案时需要意识到这一点。
Session劫持就是一种通过窃取用户Ses-sionID后，使用该SessionID登录进目标账
户的攻击方法，此时攻击者实际上是使用了目标账户的有效Session。如果SessionID是
保存在Cookie中的，则这种攻击可以称为Cookie劫持。
Cookie泄露的途径有很多，最常见的有XSS攻击、网络Sniff，以及本地木马窃取。
对于通过XSS漏洞窃取Cookie的攻击，通过给Cookie标记httponly，可以有效地缓解
XSS窃取Cookie的问题。但是其他的泄露途径，比如网络被嗅探，或者Cookie文件被窃
取，则会涉及客户端的环境安全，需要从客户端着手解决。
SessionID除了可以保存在Cookie中外，还可以保存在URL中，作为请求的一个参
数。但是这种方式的安全性难以经受考验。
在手机操作系统中，由于很多手机浏览器暂不支持Cookie，所以只能将SessionID
作为URL的一个参数用于认证。安全研究者kxlzx曾经在博客上列出过一些无线WAP中因
为sid泄露所导致的安全漏洞。其中一个典型的场景就是通过Ref-erer泄露URL中的sid，
QQ的WAP邮箱曾经出过此漏洞，测试过程如下。
首先，发送到QQ邮箱的邮件中引用了一张外部网站的图片：
然后，当手机用户用手机浏览器打开QQ邮箱时：
在手机中浏览QQ邮箱
手机浏览器在解析图片时，实际上是发起了一次GET请求，这个请求会带上
Referer。
Referer的值为：
可以看到sid就包含在Referer中，在www.inbreak.net的服务器日志中可以查看到此
值，QQ邮箱的sid由此泄露了。
在sid的生命周期内，访问包含此sid的链接，就可以登录到该用户的邮箱中。
在生成SessionID时，需要保证足够的随机性，比如采用足够强的伪随机数生成算
法。现在的网站开发中，都有很多成熟的开发框架可以使用。这些成熟的开发框架一般
都会提供Cookie管理、Session管理的函数，可以善用这些函数和功能。
9.5 Session Fixation攻击
什么是Session Fixation呢？举一个形象的例子，假设A有一辆汽车，A把汽车卖给
了B，但是A并没有把所有的车钥匙交给B，还自己藏下了一把。这时候如果B没有给车
换锁的话，A仍然是可以用藏下的钥匙使用汽车的。
这个没有换“锁”而导致的安全问题，就是SessionFixation问题。
在用户登录网站的过程中，如果登录前后用户的SessionID没有发生变化，则会存
在Session Fix-ation问题。
具体攻击的过程是，用户X（攻击者）先获取到一个未经认证的SessionID，然后将
这个Ses-sionID交给用户Y去认证，Y完成认证后，服务器并未更新此SessionID的值
（注意是未改变Ses-sionID，而不是未改变Session），所以X可以直接凭借此
SessionID登录进Y的账户。
X如何才能让Y使用这个SessionID呢？如果SessionID保存在Cookie中，比较难做
到这一点。但若是SessionID保存在URL中，则X只需要诱使Y打开这个URL即可。在上
一节中提到的sid，就需要认真考虑Session Fixation攻击。
在discuz 7.2的WAP版本中，就存在这样的一个Session Fixation攻击。
认证前的URL是
http://bbs.xxxx.com/wap/index.php?
action=forum&fid=72&sid=2iu2pf
其中，sid是用于认证的SessionID。用户登录后，这个sid没有发生改变，因此黑客
可以先构造好此URL，并诱使其他用户打开，当用户登录完成后，黑客也可以直接通过
此URL进入用户账户。
解决Session Fixation的正确做法是，在登录完成后，重写SessionID。
如果使用sid则需要重置sid的值；如果使用Cookie，则需要增加或改变用于认证的
Cookie值。值得庆幸的是，在今天使用Cookie才是互联网的主流，sid的方式渐渐被淘
汰。而由于网站想保存到Cookie中的东西变得越来越多，因此用户登录后，网站将一些
数据保存到关键的Cookie中，已经成为一种比较普遍的做法。Session Fixation攻击的用
武之地也就变得越来越小了。
9.6 Session保持攻击
一般来说，Session是有生命周期的，当用户长时间未活动后，或者用户点击退出
后，服务器将销毁Session。Session如果一直未能失效，会导致什么问题呢？前面的章
节提到Session劫持攻击，是攻击者窃取了用户的SessionID，从而能够登录进用户的账
户。
但如果攻击者能一直持有一个有效的Ses-sion（比如间隔性地刷新页面，以告诉服
务器这个用户仍然在活动），而服务器对于活动的Session也一直不销毁的话，攻击者
就能通过此有效Session一直使用用户的账户，成为一个永久的“后门”。
但是Cookie有失效时间，Session也可能会过期，攻击者能永久地持有这个Session
吗？
一般的应用都会给session设置一个失效时间，当到达失效时间后，Session将被销
毁。但有一些系统，出于用户体验的考虑，只要这个用户还“活着”，就不会让这个用户
的Session失效。从而攻击者可以通过不停地发起访问请求，让Session一直“活”下去。
安全研究者kxlzx曾经分享过这样的一个案例，使用以下代码保持Session：
其原理就是不停地刷新页面，以保持Session不过期：
测试环境
而Cookie是可以完全由客户端控制的，通过发送带有自定义Cookie头的HTTP包，
也能实现同样的效果。
安全研究者cnqing曾经开发过一个叫“Ses-sionIE”的工具，其中就实现了Session状
态的保持：
SessionIE工具的界面
想使得Cookie不失效，还有更简单的方法。
在Web开发中，网站访问量如果比较大，维护Session可能会给网站带来巨大的负
担。因此，有一种做法，就是服务器端不维护Session，而把Ses-sion放在Cookie中加
密保存。当浏览器访问网站时，会自动带上Cookie，服务器端只需要解密Cookie即可得
到当前用户的Session了。这样的Session如何使其过期呢？很多应用都是利用Cookie的
Expire标签来控制Session的失效时间，这就给了攻击者可乘之机。
Cookie的Expire时间是完全可以由客户端控制的。篡改这个时间，并使之永久有
效，就有可能获得一个永久有效的Session，而服务器端是完全无法察觉的。
以下代码由JavaScript实现，在XSS攻击后将Cookie设置为永不过期。
// 让一个Cookie不过期
anehta.dom.persistCookie =
function(cookieName){
if (anehta.dom.checkCookie(cookieName) ==
false){
return false;
}
try{
document.cookie = cookieName + "=" +
anehta.dom.getCookie(cookieName) +
";" + "expires=Thu, 01-
Jan-2038 00:00:01 GMT;";
} catch (e){
return false;
}
return true;
}
攻击者甚至可以为Session Cookie增加一个Expire时间，使得原本浏览器关闭就会
失效的Cookie持久化地保存在本地，变成一个第三方Cookie（third-party cookie）。
如何对抗这种Session保持攻击呢？
常见的做法是在一定时间后，强制销毁Ses-sion。这个时间可以是从用户登录的时
间算起，设定一个阈值，比如3天后就强制Session过期。
但强制销毁Session可能会影响到一些正常的用户，还可以选择的方法是当用户客
户端发生变化时，要求用户重新登录。比如用户的IP、UserA-gent等信息发生了变化，
就可以强制销毁当前的Session，并要求用户重新登录。
最后，还需要考虑的是同一用户可以同时拥有几个有效Session。若每个用户只允
许拥有一个Session，则攻击者想要一直保持一个Session也是不太可能的。当用户再次
登录时，攻击者所保持的Session将被“踢出”。
9.7 单点登录（SSO）
单点登录的英文全称是Single Sign On，简称SSO。它希望用户只需要登录一次，
就可以访问所有的系统。从用户体验的角度看，SSO无疑让用户的使用更加的方便；从
安全的角度看，SSO把风险集中在单点上，这样做是有利有弊的。
SSO的优点在于风险集中化，就只需要保护好这一个点。如果让每个系统各自实现
登录功能，由于各系统的产品需求、应用环境、开发工程师的水平都存在差异，登录功
能的安全标准难以统一。而SSO解决了这个问题，它把用户登录的过程集中在一个地
方。在单点处设计安全方案，甚至可以考虑使用一些较“重”的方法，比如双因素认证。
此外对于一些中小网站来说，维护一份用户名、密码也是没有太大必要的开销，所以如
果能将这个工作委托给一个可以信任的第三方，就可以将精力集中在业务上。
SSO的缺点同样也很明显，因为风险集中了，所以单点一旦被攻破的话，后果会非
常严重，影响的范围将涉及所有使用单点登录的系统。降低这种风险的办法是在一些敏
感的系统里，再单独实现一些额外的认证机制。比如网上支付平台，在付款前要求用户
再输入一次密码，或者通过手机短信验证用户身份等。
目前互联网上最为开放和流行的单点登录系统是OpenID。OpenID是一个开放的单
点登录框架，它希望使用URI作为用户在互联网上的身份标识，每个用户（End User）
将拥有一个唯一的URI。在用户登录网站（Relying Party）时，用户只需要提交他的
OpenID（就是用户唯一的URI）以及OpenID的提供者（OpenID Provider），网站就会
将用户重定向到OpenID的提供者进行认证，认证完成后再重定向回网站。
OpenID的认证流程可以用下图描述。OpenID的认证过程
在使用OpenID时，第一步是向网站提供OpenID。
第二步，网站重定向到OpenID的提供者进行身份认证，在本例中OpenID的提供者
是 my-openid.com。
第三步，用户将在OpenID的提供者网站登录，并重定向回网站。
OpenID模式仍然存在一些问题。OpenID的提供者服务水平也有高有低，作为
OpenID的提供者，一旦网站中断服务或者关闭，都将给用户带来很大的不便。因此目
前大部分网站仍然是很谨慎地使用OpenID，而仅仅是将其作为一种辅助或者可选的登
录模式，这也限制了OpenID的发展。
9.8 小结
本章介绍了认证相关的安全问题。认证解决的是“Who Am I？”的问题，它就像一个
房间的大门一样，是非常关键的一个环节。
认证的手段是丰富多彩的。在互联网中，除了密码可以用于认证外，还有很多新的
认证方式可供使用。我们也可以组合使用各种认证手段，以双因素认证或多因素认证的
方式，提高系统的安全强度。
在Web应用中，用户登录之后，服务器端通常会建立一个新的Session以跟踪用户
的状态。每个Session对应一个标识符SessionID，SessionID用来标识用户身份，一般
是加密保存在Cookie中。有的网站也会将Session保存在Cookie中，以减轻服务器端维
护Session的压力。围绕着Session可能会产生很多安全问题，这些问题都是在设计安全
方案时需要考虑到的。
本章的最后介绍了单点登录，以及最大的单点登录实现：OpenID。单点登录有利
有弊，但只要能够合理地运用这些技术，对网站的安全就都是有益处的。
第10章 访问控制
“权限”一词在安全领域出现的频率很高。“权限”实际上是一种“能力”。对于权限的合
理分配，一直是安全设计中的核心问题。但“权限”一词的中文含义过于广泛，因此本章
中将使用“访问控制”代替。在互联网安全领域，尤其是Web安全领域中，“权限控制”的
问题都可以归结为“访问控制”的问题，这种描述也更精确一些。
10.1 What Can I Do?
在上一章中，我们曾指出“认证（Authentica-tion）”与“授权（Authorization）”的不
同。“认证”解决了“Who am I?”的问题，而“授权”则解决了“What can I do?”的问题。
权限控制，或者说访问控制，广泛应用于各个系统中。抽象地说，都是某个主体
（subject）对某个客体（object）需要实施某种操作（operation），而系统对这种操作
的限制就是权限控制。
在网络中，为了保护网络资源的安全，一般是通过路由设备或者防火墙建立基于IP
的访问控制。这种访问控制的“主体”是网络请求的发起方（比如一台PC），“客体”是网
络请求的接收方（比如一台服务器），主体对客体的“操作”是对客体的某个端口发起网
络请求。这个操作能否执行成功，是受到防火墙ACL策略限制的。
防火墙的ACL策略面板
在操作系统中，对文件的访问也有访问控制。此时“主体”是系统的用户，“客体”是
被访问的文件，能否访问成功，将由操作系统给文件设置的ACL（访问控制列表）决
定。比如在Linux系统中，一个文件可以执行的操作分为“读”、“写”、“执行”三种，分别
由r、w、x表示。这三种操作同时对应着三种主体：文件拥有者、文件拥有者所在的用
户组、其他用户。主体、客体、操作这三者之间的对应关系，构成了访问控制列表。
Linux的文件权限
在一个安全系统中，确定主体的身份是“认证”解决的问题；而客体是一种资源，是
主体发起的请求的对象。在主体对客体进行操作的过程中，系统控制主体不能“无限
制”地对客体进行操作，这个过程就是“访问控制”。
主体“能够做什么”，就是权限。权限可以细分成不同的能力（capability）。在Linux
的文件系统中，将权限分成了“读”、“写”、“执行”三种能力。用户可能对某个文件拥
有“读”的权限，但却没有“写”的权限。
在Web应用中，根据访问客体的不同，常见的访问控制可以分为“基于URL的访问
控制”、“基于方法（method）的访问控制”和“基于数据的访问控制”。
一般来说，“基于URL的访问控制”是最常见的。要实现一个简单的“基于URL的访问
控制”，在基于Java的Web应用中，可以通过增加一个fil-ter实现，如下：
// 获取访问功能
String url=request.getRequestPath();
// 进行权限验证
User user=request.getSession().get("user");