我们在正则式的所有数字部分两边都放了括号。这样可以很容易就获得关于年、月、
日，小时、分钟、秒和时区的对应数字。实例2.9中讲解如何使用圆括号来创建捕获分
组。实例3.9中讲解了如何在过程代码中获得捕获分组匹配到的文本。
对于大多数正则式，我们都给出了另外一个使用命名捕获的解答。对读者或者你们的
同事来说，其中一些日期和时间格式可能会不是那么熟悉。命名捕获会使正则表达式
更加容易理解。.NET、PCRE7、Perl5.10和Ruby1.9都支持命名捕获的group)
语法。本书中讲解的所有PCRE和Python版本都会支持另外一种形式
的group))语法。更多细节，请参考实例2.11和实例3.9。
在所有正则式中的数字范围都是严格的。例如，公历日期被限制在01～31。你永远你
不会得到32日或者13月。本实例中的所有正则式都没有试图去排除不合法的日月组
合，例如2月31日；实例4.5中讲解了如何进行这样的处理。
合法性验证和格式化229
www.TopSage.com
---
## Page 246
虽然其中有些正则式看起来比较长，但是它们都比较容易理解，而且使用的是在实例
4.4和实例4.6中讲解过相同的技巧。
参见
实例4.4、实例4.5和实例4.6。
4.8
限制输入只能为字母数字字符
问题描述
你的程序要求用户的响应中只能使用英语字母表中的一个或多个字母数字字符。
解决方案
既然你可以使用正则表达式，这个问题就变得无比简单了。一个字符类就可以说明所
允许的字符范围。再加上一个量词来重复这个字符类一次或多次，使用定位符来把匹
配定位到字符串的开始和结束。你就大功告成了！
正则表达式
^[A-20-9]+$
正则选项：不区分大小写
正则流派：.NET、Java、JavaScript、PCRE、Perl、Python、Ruby
Ruby
if subject =~/^[A-Z0-9]+$/i
puts "Subject is alphanumeric"
else
puts “Subject is not alphanumeric"
end
其他编程语言
如果读者想了解如何在其他编程语言中实现这个正则表达式，请参考实例3.4和实例3.5。
讨论
我们来分别看一下这个正则表达式中的4个组成部分：
A
#判断字符串的起始位置
[A-20-9】#匹配从"A"到"Z"或从"O"到"9"的一个字符..
+
重复1次或多次
$
判断字符串的结尾位置
正则选项：不区分大小写，宽松排列
正则流派：.NET、Java、PCRE、Perl、Python、Ruby
230
第4章
www.TopSage.com
---
## Page 247
位于正则表达式开头和结尾的两个断言和$>会确保我们测试的是整个输人字符
串。如果没有它们，那幺正则式会匹配一个更长字符串中的任意部分，这样就会导致
出现非法字符。加号量词（+>会重复之前的元素一次或多次。如果想要允许正则式匹配
一个全空的字符串，那么你可以把（+>替换为*。星号量词*会允许0次或多次重
复，实际上也就可以把之前的元素变成可选的。
变体
限制输入为ASCII字符
下面的正则表达式会把输入限制为7比特ASCI1字符表中的128个字符。其中包括了
33个不可见的控制字符：
[\x00-\x7F]+$
正则选项：无
正则流派：.NET、Java、JavaScript、PCRE、Perl、Python、Ruby
限制输入为ASCII非控制字符和换行符
使用下面的正则表达式可以把输人限制为在ASCII字母表中的可见字符和空白，而把
控制字符去掉。换行符和回车符（分别位于位置0x0A和0x0D）是最常用的控制字符，
所以我们使用n>（换行）和r>（回车）把这两个字符明确地包含了进来：
[\n\r\x20~\x7E]+$
正则选项：无
正则流派：.NET、Java、JavaScript、PCRE、Perl、Python、Ruby
限制输入为1SO-8859-1和Windows-1252共享的字符
ISO-8859-1和Windows-1252（通常被称作是ANSI）是两种最常用的8比特字符编码
格式，它们都基于Latin-1标准（更正式的名称是ISO/IEC8859-1）。然而，它们在位置
0x80和0x99之间映射的字符是不兼容的。ISO-8859-1把这些位置用于控制代码，而
Windows-1252则把这些位置用于扩展的字符和标点。
这些区别有时候会造成字符显示的困难，特别是对于没有明确声明它们使用的编码格
式的文档，或者接收者用的不是Windows系统的时候。下面的正则表达式可以用来把
输人限制为只能是ISO-8859-1和Windows-1252中共享的字符（包括共享的控制字符）：
[\x00-\x7F\xA0-\xFF]+$
正则选项：无
正则流派：.NET、Java、JavaScript、PCRE、Perl、Python、Ruby
二
十六进制的记号可能会让这个正则表达式看起来比较难读，但是它的工作原理同
[A-Z0-9]>这样的字符类是一样的。它会匹配下列两个范围之内的字符：x00-ix7F和
xA0-\xFF。
合法性验证和格式化231
www.TopSage.com
---
## Page 248
限制输入为任何语言的字母数字字符
这个正则表达式把输入限制为可以是任何语言或学母表中的学母和数字。它使用的字
[\p{L}\p{N}]+$
正则选项：无
正则流派：.NET、Java、PCRE、Perl、Ruby1.9
不幸的是，并不是本书中的所有正则表达式流派都支持Unicode属性。具体来讲，这个
正则式就不能用于JavaScript、Python或Ruby1.8。另外，在PCRE中使用这个正则式
时要求PCRE必须使用UTF-8来进行编译。如果在正则式中添加了u选项，那么Unicode
属性可以用于PHP中的preg函数类（它依赖的是PCRE）。
在Python中可以使用如下的正则表达式：
[^\W_]+$
正则选项：Unicode
正则流派：Python
这里，我们设法绕开了在Python中不支持Unicode属性的问题，在创建正则表达式的
时候需要使用UNICODE或U标志。这样就可以通过迫使一些正则记号使用Unicode
字符表来改变它们的含义。《w>对我们来说差不多就足够了，但是它会匹配字母数字字
符以及下划线。通过在一个否定字符类中使用的取反（W>），我就可以从这个集
合中把下划线去掉。像这样的双重否定在正则表达式中偶尔会很有用，虽然这可能有
时候会让你有点儿摸不着头脑。
参见
实例4.9中会演示如何限制文本的长度，而不是限制其中的字符集。
4.9限制文本长度
问题描述
你想要检查一个字符串是否是由1～10个A～Z的字母组成的
解决方案
本书中的所有编程语言都会提供简单高效的方式来检查文本的长度。例如，JavaScript
字符串有一个length属性，其中会保存一个说明字符串长度的整数。然而在有些情形
1这种情形还可以更加有趣（如果你可以把它称为有趣）：读者可以尝试把否定型环视（参见实例2.16）
多重的否定。
232第4章
www.TopSage.com
---
## Page 249
下，使用正则表达式来检查文本长度会比较有用，特别是当长度只是用来决定目标文
本是否符合指定模式的多条规则之一的时候。下面的正则表达式会确保目标文本中只
包含1～10个字符，并且还进-一步把文本限制为只能包含大写字母A～Z。你也可以修
改正则表达式，来支持任意的最小和最大文本长度，或者允许出现A一Z之外的字符。
正则表达式
^[A-Z]{1,10}$
正则选项：无
正则流派：.NET、Java、JavaScript、PCRE、Perl、Python、Ruby
Perl
if (SARGV[0]=~/^[A-Z}{1,10}$/){
print "Input is valid\n";
}else{
print "Input is invalid\n";
其他编程语言
关于如何使用其他编程语言来实现这个正则表达式，请参考实例3.5中的讲解。
讨论
下面是对上面这个非常容易理解的正则式的分解：
#判断字符串的起始位置
[A-Z]
#匹配从“A"到"Z"的一个字母..·
{1,10}
#1到10次
$
#判断字符串的结束位置
正则选项：宽松排列
正则流派：.NET、Java、PCRE、Perl、Python、Ruby
两个定位符和S会确保正则表达式匹配整个目标字符串：否则，它就可能会匹配位
于更长文本中的10个字符。字符类[A-Z]会匹配A～Z的任意单个大写字母，而区间
量词{1，10}>会重复该字符类1～10次。通过把区间量词与字符串开始和结束定位符
组合起来之后，如果目标文本的长度不在指定范围之内，这个正则表达式就不会产生
匹配。
注意字符类[A-Z]明确说明了只允许大写字母。如果你想要把a~z的小写字母也加进
来，那么可以选择把字符类替换成[A-Za-z]，或者是使用不区分大小写的选项。更多
细节，请参考实例3.4中的讲解。
正则表达式的新用户常常会犯的个错误是，想要使用字符类范围A-z少来节省几个字
符。一眼看去这样好像可以把所有大小写字母都包含进来。然而，在ASCII字符表中，
A~Z和a~z的范围之间还包含了几个标点字符。因此，实际上和[A-z]等价的是
合法性验证和格式化233
www.TopSage.com
---
## Page 250
《[A-Z[\]^_a-z]>。
变体
限制任意模式的长度
因为像{1,10}这样的量词只能应用到紧跟在它前面的元素，因此如果要对包含超过
个记号的模式所能匹配的字符个数进行限制，那么就需要采用一种不同的方式。
在实例2.16中讲过，顺序环视（以及和它相对的逆序环视）是与和类似的一种特
殊的断言，用来匹配在目标字符串的一个位置，而不会消费任何字符。顺序环视可以
是肯定型或者否定型的，这意味着它们可以在匹配中检查一个模式符合或者不符合当
前的位置。肯定型顺序环视（采用?=...)的格式）可以被用在模式的开头来保证字符
串的长度在指定范围之内。正则表达式的剩余部分则可以去放心检查想要的模式，而
不用再担心文本的长度。下面是一个简单的例子：
(?=.{1, 10}$). *
正则选项：点号匹配换行符
正则流派：.NET、Java、PCRE、Perl、Python、Ruby
(?=[\S\s](1,10} $) [\S\s] *
正则选项：无
正则流派：JavaScript
注意一定要把定位符放到顺序环视之内，因为只有确定在到达上限之后不再存在更
多字符时，我们才能认为它符合最大长度检查。因为在正则式开头的顺序环视会保证
长度的范围，所以剩余的模式可以应用额外的验证规则。在这个例子中，模式（.*（或
者是添加了JavaScript支持的会只匹配ASCII空白字符，而则会匹配
所有其他的字符。在Python中，你可以在创建正则式的时候，使用UNICODE或U标
234第4章
www.TopSage.com
---
## Page 251
志来让<s可以匹配所有的Unicode空白符号。使用Java、PCRE和Ruby1.9的开发人
员，如果想要避免把任何Unicode空白符号算进它们的字符个数中，就需要采用如下的
版本来利用Unicode属性（参考实例2.7）。
[\p{Z}\s] *(？:[^\p{Z}\s][\p{Z}\s]*){10,100}$
定则选项：无
正则流派：.NET、Java、PCRE、Perl、Ruby1.9
PCRE必须使用UTF-8来编译，上述正则式才能工作。在PHP中，需要使用/u模式修
饰符来打开UTF-8支持。