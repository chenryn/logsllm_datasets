13 
 // 创建 entities 包中的 Admin 类型的值 
14 
 a := entities.Admin{ 
15 
 Rights: 10, 
16 
 } 
17 
18 
 // 设置未公开的内部类型的 
19 
 // 公开字段的值 
20 
 a.Name = "Bill" 
21 
 a.Email = "PI:EMAIL" 
22 
23 
 fmt.Printf("User: %v\n", a) 
24 } 
让我们从代码清单 5-76 的第 14 行的 main 函数开始。这个函数创建了 entities 包中的
Admin 类型的值。由于内部类型 user 是未公开的，这段代码无法直接通过结构字面量的方式初
始化该内部类型。不过，即便内部类型是未公开的，内部类型里声明的字段依旧是公开的。既然
内部类型的标识符提升到了外部类型，这些公开的字段也可以通过外部类型的字段的值来访问。 
因此，在第 20 行和第 21 行，来自未公开的内部类型的字段 Name 和 Email 可以通过外部
类型的变量 a 被访问并被初始化。因为 user 类型是未公开的，所以这里没有直接访问内部类型。 
5.7  小结 
使用关键字 struct 或者通过指定已经存在的类型，可以声明用户定义的类型。
方法提供了一种给用户定义的类型增加行为的方式。
设计类型时需要确认类型的本质是原始的，还是非原始的。
接口是声明了一组行为并支持多态的类型。
嵌入类型提供了扩展类型的能力，而无需使用继承。
标识符要么是从包里公开的，要么是在包里未公开的。
第 6 章 并发 
本章主要内容 
使用 goroutine 运行程序
检测并修正竞争状态
利用通道共享数据
通常程序会被编写为一个顺序执行并完成一个独立任务的代码。如果没有特别的需求，最好
总是这样写代码，因为这种类型的程序通常很容易写，也很容易维护。不过也有一些情况下，并
行执行多个任务会有更大的好处。一个例子是，Web 服务需要在各自独立的套接字（socket）上
同时接收多个数据请求。每个套接字请求都是独立的，可以完全独立于其他套接字进行处理。具
有并行执行多个请求的能力可以显著提高这类系统的性能。考虑到这一点，Go 语言的语法和运
行时直接内置了对并发的支持。 
Go 语言里的并发指的是能让某个函数独立于其他函数运行的能力。当一个函数创建为 goroutine
时，Go 会将其视为一个独立的工作单元。这个单元会被调度到可用的逻辑处理器上执行。Go 语言
运行时的调度器是一个复杂的软件，能管理被创建的所有 goroutine 并为其分配执行时间。这个调度
器在操作系统之上，将操作系统的线程与语言运行时的逻辑处理器绑定，并在逻辑处理器上运行
goroutine。调度器在任何给定的时间，都会全面控制哪个 goroutine 要在哪个逻辑处理器上运行。 
Go 语言的并发同步模型来自一个叫作通信顺序进程（Communicating Sequential Processes，CSP）
的范型（paradigm）。CSP 是一种消息传递模型，通过在 goroutine 之间传递数据来传递消息，而不是
对数据进行加锁来实现同步访问。用于在 goroutine 之间同步和传递数据的关键数据类型叫作通道
（channel）。对于没有使用过通道写并发程序的程序员来说，通道会让他们感觉神奇而兴奋。希望读
者使用后也能有这种感觉。使用通道可以使编写并发程序更容易，也能够让并发程序出错更少。 
6.1  并发与并行 
让我们先来学习一下抽象程度较高的概念：什么是操作系统的线程（thread）和进程（process）。
6
第 6 章 并发 
这会有助于后面理解 Go 语言运行时调度器如何利用操作系统来并发运行 goroutine。当运行一个
应用程序（如一个 IDE 或者编辑器）的时候，操作系统会为这个应用程序启动一个进程。可以将
这个进程看作一个包含了应用程序在运行中需要用到和维护的各种资源的容器。 
图 6-1 展示了一个包含所有可能分配的常用资源的进程。这些资源包括但不限于内存地址空
间、文件和设备的句柄以及线程。一个线程是一个执行空间，这个空间会被操作系统调度来运行
函数中所写的代码。每个进程至少包含一个线程，每个进程的初始线程被称作主线程。因为执行
这个线程的空间是应用程序的本身的空间，所以当主线程终止时，应用程序也会终止。操作系统
将线程调度到某个处理器上运行，这个处理器并不一定是进程所在的处理器。不同操作系统使用
的线程调度算法一般都不一样，但是这种不同会被操作系统屏蔽，并不会展示给程序员。 
图 6-1  一个运行的应用程序的进程和线程的简要描绘 
操作系统会在物理处理器上调度线程来运行，而 Go 语言的运行时会在逻辑处理器上调度
goroutine来运行。每个逻辑处理器都分别绑定到单个操作系统线程。在 1.5 版本
①
在图 6-2 中，可以看到操作系统线程、逻辑处理器和本地运行队列之间的关系。如果创建一
个 goroutine 并准备运行，这个 goroutine 就会被放到调度器的全局运行队列中。之后，调度器就
将这些队列中的 goroutine 分配给一个逻辑处理器，并放到这个逻辑处理器对应的本地运行队列
上，Go语言的
运行时默认会为每个可用的物理处理器分配一个逻辑处理器。在 1.5 版本之前的版本中，默认给
整个应用程序只分配一个逻辑处理器。这些逻辑处理器会用于执行所有被创建的goroutine。即便
只有一个逻辑处理器，Go也可以以神奇的效率和性能，并发调度无数个goroutine。 
① 直到目前最新的 1.8 版本都是同一逻辑。可预见的未来版本也会保持这个逻辑。——译者注
中。本地运行队列中的 goroutine 会一直等待直到自己被分配的逻辑处理器执行。 
图 6-2  Go 调度器如何管理 goroutine 
有时，正在运行的 goroutine 需要执行一个阻塞的系统调用，如打开一个文件。当这类调用
发生时，线程和 goroutine 会从逻辑处理器上分离，该线程会继续阻塞，等待系统调用的返回。
与此同时，这个逻辑处理器就失去了用来运行的线程。所以，调度器会创建一个新线程，并将其
绑定到该逻辑处理器上。之后，调度器会从本地运行队列里选择另一个 goroutine 来运行。一旦
被阻塞的系统调用执行完成并返回，对应的 goroutine 会放回到本地运行队列，而之前的线程会
保存好，以便之后可以继续使用。 
如果一个 goroutine 需要做一个网络 I/O 调用，流程上会有些不一样。在这种情况下，goroutine
会和逻辑处理器分离，并移到集成了网络轮询器的运行时。一旦该轮询器指示某个网络读或者写
操作已经就绪，对应的 goroutine 就会重新分配到逻辑处理器上来完成操作。调度器对可以创建
的逻辑处理器的数量没有限制，但语言运行时默认限制每个程序最多创建 10 000 个线程。这个
限制值可以通过调用 runtime/debug 包的 SetMaxThreads 方法来更改。如果程序试图使用
更多的线程，就会崩溃。 
并发（concurrency）不是并行（parallelism）。并行是让不同的代码片段同时在不同的物理处
理器上执行。并行的关键是同时做很多事情，而并发是指同时管理很多事情，这些事情可能只做
了一半就被暂停去做别的事情了。在很多情况下，并发的效果比并行好，因为操作系统和硬件的
总资源一般很少，但能支持系统同时做很多事情。这种“使用较少的资源做更多的事情”的哲学，
也是指导 Go 语言设计的哲学。 
如果希望让 goroutine 并行，必须使用多于一个逻辑处理器。当有多个逻辑处理器时，调度器
会将 goroutine 平等分配到每个逻辑处理器上。这会让 goroutine 在不同的线程上运行。不过要想真
的实现并行的效果，用户需要让自己的程序运行在有多个物理处理器的机器上。否则，哪怕 Go 语
言运行时使用多个线程，goroutine 依然会在同一个物理处理器上并发运行，达不到并行的效果。 
图6-3展示了在一个逻辑处理器上并发运行goroutine和在两个逻辑处理器上并行运行两个并
发的 goroutine 之间的区别。调度器包含一些聪明的算法，这些算法会随着 Go 语言的发布被更新
和改进，所以不推荐盲目修改语言运行时对逻辑处理器的默认设置。如果真的认为修改逻辑处理
器的数量可以改进性能，也可以对语言运行时的参数进行细微调整。后面会介绍如何做这种修改。 
图 6-3  并发和并行的区别 
6.2  goroutine 
让我们再深入了解一下调度器的行为，以及调度器是如何创建 goroutine 并管理其寿命的。
我们会先通过在一个逻辑处理器上运行的例子来讲解，再来讨论如何让 goroutine 并行运行。代
码清单 6-1 所示的程序会创建两个 goroutine，以并发的形式分别显示大写和小写的英文字母。 
代码清单 6-1  listing01.go 
01 // 这个示例程序展示如何创建 goroutine 
02 // 以及调度器的行为 
03 package main 
04 
05 import ( 
06 
 "fmt" 
07 
 "runtime" 
08 
 "sync" 
09 ) 
10 
11 // main 是所有 Go 程序的入口 
12 func main() { 
13 
 // 分配一个逻辑处理器给调度器使用 
14 
 runtime.GOMAXPROCS(1) 
15 
16 
 // wg 用来等待程序完成 
17 
 // 计数加 2，表示要等待两个 goroutine 
18 
 var wg sync.WaitGroup 
19 
 wg.Add(2) 
20 
21 
 fmt.Println("Start Goroutines") 
22 
23 
 // 声明一个匿名函数，并创建一个 goroutine 
24 
 go func() { 
25 
 // 在函数退出时调用 Done 来通知 main 函数工作已经完成 
26 
 defer wg.Done() 
27 
28 
 // 显示字母表 3 次 
29 
 for count := 0; count < 3; count++ { 
30 
 for char := 'a'; char < 'a'+26; char++ { 
31 
 fmt.Printf("%c ", char) 
32 
 } 
33 
 } 
34 
 }() 
35 
36 
 // 声明一个匿名函数，并创建一个 goroutine 
37 
 go func() { 
38 
 // 在函数退出时调用 Done 来通知 main 函数工作已经完成 
39 
 defer wg.Done() 
40 
41 
 // 显示字母表 3 次 
42 
 for count := 0; count < 3; count++ { 
43 
 for char := 'A'; char < 'A'+26; char++ { 
44 
 fmt.Printf("%c ", char) 
45 
 } 
46 
 } 
47 
 }() 
48 
49 
 // 等待 goroutine 结束 
50 
 fmt.Println("Waiting To Finish") 
51 
 wg.Wait() 
52 
53 
 fmt.Println("\nTerminating Program") 
54 } 
在代码清单 6-1 的第 14 行，调用了 runtime 包的 GOMAXPROCS 函数。这个函数允许程序
更改调度器可以使用的逻辑处理器的数量。如果不想在代码里做这个调用，也可以通过修改和这
个函数名字一样的环境变量的值来更改逻辑处理器的数量。给这个函数传入 1，是通知调度器只
能为该程序使用一个逻辑处理器。 
在第 24 行和第 37 行，我们声明了两个匿名函数，用来显示英文字母表。第 24 行的函数显
示小写字母表，而第 37 行的函数显示大写字母表。这两个函数分别通过关键字 go 创建 goroutine
来执行。根据代码清单 6-2 中给出的输出可以看到，每个 goroutine 执行的代码在一个逻辑处理器
6.2  goroutine
127
上并发运行的效果。 
代码清单 6-2  listing01.go 的输出 
Start Goroutines 
Waiting To Finish 
A B C D E F G H I J K L M N O P Q R S T U V W X Y Z A B C D E F G H I J K L M 
N O P Q R S T U V W X Y Z A B C D E F G H I J K L M N O P Q R S T U V W X Y Z 
a b c d e f g h i j k l m n o p q r s t u v w x y z a b c d e f g h i j k l m 
n o p q r s t u v w x y z a b c d e f g h i j k l m n o p q r s t u v w x y z 
Terminating Program 
第一个 goroutine 完成所有显示需要花时间太短了，以至于在调度器切换到第二个 goroutine
之前，就完成了所有任务。这也是为什么会看到先输出了所有的大写字母，之后才输出小写字母。
我们创建的两个 goroutine 一个接一个地并发运行，独立完成显示字母表的任务。 
如代码清单 6-3 所示，一旦两个匿名函数创建 goroutine 来执行，main 中的代码会继续运行。
这意味着 main 函数会在 goroutine 完成工作前返回。如果真的返回了，程序就会在 goroutine 有
机会运行前终止。因此，在第 51 行，main 函数通过 WaitGroup，等待两个 goroutine 完成它们
的工作。 
代码清单 6-3  listing01.go：第 17 行到第 19 行，第 23 行到第 26 行，第 49 行到第 51 行 
16 
// wg 用来等待程序完成
17 
// 计数加 2，表示要等待两个 goroutine
18 
 var wg sync.WaitGroup 
19 
 wg.Add(2) 
23 
// 声明一个匿名函数，并创建一个 goroutine
24 
 go func() { 
25 
// 在函数退出时调用 Done 来通知 main 函数工作已经完成
26 
 defer wg.Done() 
49 
// 等待 goroutine 结束
50 
 fmt.Println("Waiting To Finish") 
51 
 wg.Wait() 
WaitGroup 是一个计数信号量，可以用来记录并维护运行的 goroutine。如果 WaitGroup
的值大于 0，Wait 方法就会阻塞。在第 18 行，创建了一个 WaitGroup 类型的变量，之后在
第 19 行，将这个 WaitGroup 的值设置为 2，表示有两个正在运行的 goroutine。为了减小
WaitGroup 的值并最终释放 main 函数，要在第 26 和 39 行，使用 defer 声明在函数退出时
调用 Done 方法。 
关键字 defer 会修改函数调用时机，在正在执行的函数返回时才真正调用 defer 声明的函
数。对这里的示例程序来说，我们使用关键字 defer 保证，每个 goroutine 一旦完成其工作就调
用 Done 方法。 
基于调度器的内部算法，一个正运行的 goroutine 在工作结束前，可以被停止并重新调度。
调度器这样做的目的是防止某个 goroutine 长时间占用逻辑处理器。当 goroutine 占用时间过长时，
调度器会停止当前正运行的 goroutine，并给其他可运行的 goroutine 运行的机会。 
图 6-4 从逻辑处理器的角度展示了这一场景。在第 1 步，调度器开始运行 goroutine A，而
goroutine B 在运行队列里等待调度。之后，在第 2 步，调度器交换了 goroutine A 和 goroutine B。
由于 goroutine A 并没有完成工作，因此被放回到运行队列。之后，在第 3 步，goroutine B 完成
了它的工作并被系统销毁。这也让 goroutine A 继续之前的工作。 
图 6-4  goroutine 在逻辑处理器的线程上进行交换 
可以通过创建一个需要长时间才能完成其工作的 goroutine 来看到这个行为，如代码清单 6-4
所示。 
代码清单 6-4  listing04.go 
01 // 这个示例程序展示 goroutine 调度器是如何在单个线程上 
02 // 切分时间片的 
03 package main 
04 
05 import ( 
06 
 "fmt" 
07 
 "runtime" 
08 
 "sync" 