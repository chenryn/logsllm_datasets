reconsider the whole policy every time a new module is
added to the system. This option is natural for SELinux
in Fedora, because the modules are created by trusted en-
tities and they are free to modify the system policy, with a
number of types in the existing binary representation that
may have to be updated. As we have already discussed, the
requirements associated with the use of appPolicyModules
in Android are diﬀerent, because in our scenario an appPoli-
cyModule cannot modify the system policy (Req1 in Section
5). In addition to the security beneﬁt, this requirement also
leads to a simpliﬁcation of the management of policy mod-
ules, because the re-installation of the system policy and all
the other modules is not needed. This permits to provide
an “incremental” solution, with a signiﬁcant reduction in the
appPolicyModule installation time.
120406080100# modules0123456install time [s]recompilationincrementalThe graph in Figure 4 describes the time observed in a
scenario where the current system policy has been extended
with 100 modules, adding the modules one by one. The tests
were run 100 times. Each element in the graph describes the
range of measured values and the average. The observations
in the upper part of the graph show that as the number of
modules increases, the re-compilation approach shows a sig-
niﬁcant increase in the compilation time, due to the fact that
at each step the policy becomes larger and its full recompi-
lation more expensive. The incremental approach instead
shows a constant response time, with no observable impact
deriving from the increase in the size of the overall policy.
The average installation time for the incremental approach,
which is the one to use, is near to 0.2 s, compatible with the
requirements of real systems.
8.3.2 Runtime
We evaluated the performance overhead of our approach
at runtime, considering two scenarios with diﬀerent binary
policy sizes.
Table 2: Binary policies used in the tests.
policy
sepolicy
#rules
size
1319
73KB
sepolicy +1000 APMs
35319
631KB
For runtime analysis we used two well known benchmark
apps: (i) AnTuTu [1] by AnTuTu Labs and (ii) Benchmark
by Softweg [16]. Under both benchmarks, we ensured that
the same number of apps/services were loaded and running.
Table 3: AntuTu Benchmark (100 iterations), higher
values are better
sepolicy
1130.467
3334.533
svm
smt
database
630.600
sram
ﬂoat
snand
1534.840
1938.600
1159.320
memory
1121.280
integer
2285.933
sepolicy
+1000 APMs
1132.867
3341.400
631.333
1538.533
1939.200
1159.400
1120.800
2284.133
AnTuTu Benchmark is a popular Android utility for bench-
marking devices. As it was explained in [15], the overhead
introduced by SELinux is very limited and it only aﬀects sd-
write, sdread and database I/O tests. The tests performed
by Smalley et al. take into account a “static” policy. In our
scenario the policy size is not static, but it changes at each
installation and can potentially become quite large. How-
ever, experimental results highlight how the policy size does
not aﬀect the system performance. Table 3 shows the re-
sults of the benchmark. The impact of the larger policy is
not detectable by the experiments.
Table 4 shows the results provided by Benchmark app de-
veloped by Softweg. Similarly to the results obtained by
Table 4: Softweg Benchmark (100 iterations):
for
the Total File System score, higher values are better
sepolicy
sepolicy
+1000 APMs
Create 250 empty ﬁles
Create 1000 empty ﬁles
Delete 250 empty ﬁles
Delete 1000 empty ﬁles
1.222 s
0.302 s
0.351 s
0.130 s
Total ﬁle system score
342.835
1.230 s
0.303 s
0.351 s
0.130 s
341.158
AnTuTu, SELinux does not aﬀect CPU and graphics scores.
For the ﬁlesystem and sdcard tests, the overhead introduced
by the increased size of the policy is negligible. As high-
lighted by the create and delete tests, the time taken to
create or delete 1000 empty ﬁles increased by less than 1
percent. As explained by Smalley et al. [15] the create and
delete tests can be viewed as a worst case, since the over-
head of managing the security context is not amortized over
any real usage of the ﬁle.
9. RELATED WORK
In the past few years a strong interest has been dedicated
to the investigation of Android security. Several solutions
have been proposed to increase the security of the system
and to protect the apps and system components from a va-
riety of threats. The central role of the proposal by Smalley
et al. [15] has already been discussed. We summarize here
other important contributions in the area.
TaintDroid, proposed in [8] by Enck et al., provides func-
tions to detect the unauthorized leakage of sensitive data.
TaintDroid uses dynamic taint analysis (i.e., taint track-
ing) to monitor the exchange of sensitive information among
third-party apps. While this solution try to identify the in-
formation leakage, our proposal goes one step further im-
peding the leakage at the SELinux level.
Other solutions, such as FlaskDroid [6], TrustDroid [5]
and XManDroid [4] show greater similarity to our work.
FlaskDroid [6] is a security architecture for the Android
OS that instantiates diﬀerent security solutions.
It is in-
spired by the concepts of the Flask architecture and is based
on SEAndroid. FlaskDroid provides mandatory access con-
trol on both Android’s middleware and kernel layers. This
represents an enhancement in terms of the isolation that is
provided between separate components, but the two MAC
levels are not coordinated and largely use booleans in the
SELinux policy. In the current SEAndroid implementation,
the use of booleans inside the policy is strongly discouraged,
for two main reasons: (i) it could introduce compatibility
problems, and (ii) it could undermine the default security
goals being enforced via SELinux in AOSP itself. Compared
to our proposal, the focus of Flaskdroid is the security of
system modules and the security of third-party apps is not
supported. Flaskdroid does not permit to dynamically add
policy modules without a recompilation of the entire policy.
TrustDroid [5] and XManDroid [4] provide mandatory ac-
cess control at both the middleware layer and at the ker-
nel layer. At the kernel layer, they rely upon TOMOYO
Linux [9], a path-based MAC framework. TOMOYO sup-
ports policy updates at runtime, but the security model of
SELinux is more ﬂexible and supports richer policies.
RootGuard [14] is an enhanced root-management system
which monitors system calls, to detect the abnormal be-
havior of apps (i.e., malware) with root privileges.
It is
composed by three components (i) SuperuserEx, (ii) Policy
storage database, and (iii) Kernel module, which span the dif-
ferent levels of the Android architecture. The SuperuserEx
is built on top of the open source Superuser app, the Policy
storage database is used to store the RootGuard policy and
the Kernel module introduces a set of hooks in order to inter-
cept system calls. This implementation is similar to the one
used by SELinux, but all the SELinux code is already in the
mainline Linux kernel and provides a more robust solution.
10. CONCLUSIONS
Security is correctly perceived, both by technical experts
and customers, as a crucial property of mobile operating
systems. The integration of SELinux into Android is a sig-
niﬁcant step toward the realization of more robust and more
ﬂexible security services. The attention that has been ded-
icated in the SEAndroid initiative toward the protection of
system components is understandable and consistent with
the high priority associated with the protection of core priv-
ileged resources. Our approach is the natural extension of
that work, which demonstrated a successful deployment, to-
ward a more detailed consideration of the presence of apps.
The paper shows that the potential for the application
of policy modules associated with each app is quite exten-
sive, supporting scenarios where developers deﬁne their own
app policy, and scenarios where policies are automatically
generated to improve the enforcement of privileges and the
isolation of apps. The extensive level of reuse of SELinux
constructs that characterizes the language for the appPoli-
cyModules demonstrates the ﬂexibility of SELinux and facil-
itates the deployment of the proposed solution. An analysis
of the evolution of the oﬃcial SEAndroid project conﬁrms
that appPolicyModules identify a concrete need and that
Android is evolving in this direction.
11. ACKNOWLEDGEMENTS
This work was partially supported by a Google Research
Award (winter 2014), by the Italian Ministry of Research
within the PRIN project “GenData 2020” and by the EC
within the 7FP and H2020, respectively, under grant agree-
ments 257129 and 644579.
12. REFERENCES
[1] AnTuTu labs. AnTuTu Benchmark.
https://play.google.com/store/apps/details?id=
com.antutu.ABenchMark .
[2] M. Arrigoni Neri, M. Guarnieri, E. Magri, S. Mutti,
and S. Paraboschi. Conﬂict Detection in Security
Policies using Semantic Web Technology. In Proc. of
IEEE ESTEL - Security Track, 2012.
privilege-escalation attacks on android. In 19th Annual
Network & Distributed System Security Symposium
(NDSS), volume 17, pages 18–25, 2012.
[5] S. Bugiel, L. Davi, A. Dmitrienko, S. Heuser, A.-R.
Sadeghi, and B. Shastry. Practical and lightweight
domain isolation on android. In Proceedings of the 1st
ACM workshop on Security and privacy in
smartphones and mobile devices. ACM, 2011.
[6] S. Bugiel, S. Heuser, and A.-R. Sadeghi. Flexible and
ﬁne-grained mandatory access control on android for
diverse security and privacy policies. In 22nd USENIX
Security Symposium. USENIX, 2013.
[7] Dolphin Browser. Dolphin Browser for Android.
https://play.google.com/store/apps/details?id=
mobi.mgeek.TunnyBrowser .
[8] W. Enck, P. Gilbert, B.-G. Chun, L. P. Cox, J. Jung,
P. McDaniel, and A. Sheth. Taintdroid: An
information-ﬂow tracking system for realtime privacy
monitoring on smartphones. In OSDI, volume 10,
2010.
[9] T. Harada, T. Horie, and K. Tanaka. Task oriented
management obviates your onus on linux. In Linux
Conference, volume 3, 2004.
[10] J. Lepreau, R. Spencer, S. Smalley, P. Loscocco,
M. Hibler, and D. Andersen. The ﬂask security
architecture: System support for diverse security
policies, 2006.
[11] A. Ludwig. Android - practical security from the
ground up, October 2013. http://goo.gl/z0RIwu .
[12] F. Mayer, K. MacMillan, and D. Caplan. SELinux by
Example: Using Security Enhanced Linux (Prentice
Hall Open Source Software Development Series).
Prentice Hall PTR, NJ, USA, 2006.
[13] C. Mulliner, W. Robertson, and E. Kirda.
Virtualswindle: An automated attack against in-app
billing on android. In Proceedings of the 9th ACM
Symposium on Information, Computer and
Communications Security, ASIACCS ’14, pages
459–470, New York, NY, USA, 2014. ACM.
[14] Y. Shao, X. Luo, and C. Qian. Rootguard: Protecting
rooted android phones. Computer, 47(6):32–40, 2014.
[15] S. Smalley and R. Craig. Security enhanced (se)
android: Bringing ﬂexible mac to android. In Network
and Distributed System Security Symposium (NDSS
13), 2013.
[16] Softweg. Benchmark. https://play.google.com/
store/apps/details?id=softweg.hw.performance .
[17] Titanium Track. Titanium Backup.
https://play.google.com/store/apps/details?id=
com.keramidas.TitaniumBackup .
[18] C. Yang, V. Yegneswaran, P. Porras, and G. Gu.
Detecting money-stealing apps in alternative android
markets. In Proceedings of the 2012 ACM Conference
on Computer and Communications Security, CCS ’12,
pages 1034–1036, New York, NY, USA, 2012. ACM.
[3] M. Balanza, K. Alintanahin, O. Abendan, J. Dizon,
[19] Y. Zhou, Z. Wang, W. Zhou, and X. Jiang. Hey, you,
and B. Caraig. Droiddreamlight lurks behind
legitimate android apps. In Malicious and Unwanted
Software (MALWARE), 2011 6th International
Conference on, pages 73–78. IEEE, 2011.
[4] S. Bugiel, L. Davi, A. Dmitrienko, T. Fischer, A.-R.
Sadeghi, and B. Shastry. Towards taming
get oﬀ of my market: Detecting malicious apps in
oﬃcial and alternative android markets. In NDSS,
2012.