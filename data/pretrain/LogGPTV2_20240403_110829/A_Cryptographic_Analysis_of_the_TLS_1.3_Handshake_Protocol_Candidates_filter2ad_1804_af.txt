agreement on sid2 implies agreement on the respective partner’s identity.
5. Session identiﬁers are distinct for diﬀerent stages.
This holds trivially as session identiﬁers monotonically grow with each stage.
6. At most two sessions have the same session identiﬁer at any stage.
Observe that the group element for the Diﬃe–Hellman key, as well as a random nonce, of both
the initiator and the responder enter the session identiﬁers. Therefore, in order to have a threefold
collision among session identiﬁers of honest parties, the third session would need to pick the same
group element and nonce as one of the other two sessions. The probability that there exists such a
s · 1/q · 2−|nonce| where ns is the maximum number
collision can hence be bounded from above by n2
of sessions, q is the group order, and |nonce| = 256 the nonces’ bit-length.
Theorem 5.2 (Multi-Stage security of draft-05). The draft-05 full handshake is Multi-Stage-secure in
a key-independent and stage-1-forward-secret manner with concurrent authentication properties AUTH =
{(unauth, unauth, unauth), (unauth, unilateral, unilateral), (unauth, mutual, mutual)} (i.e., no authentication,
stage-2 unilateral authentication, and stage-2 mutual authentication). Formally, for any eﬃcient adver-
sary A against the Multi-Stage security there exist eﬃcient algorithms B1, . . . , B7 such that
AdvMulti-Stage,D
(cid:18)
draft-05,A ≤ 3ns·
+ ns ·(cid:16)AdvPRF-ODH
AdvCOLL
+ AdvCOLL
H,B1 + nu · AdvEUF-CMA
H,B3 + nu · AdvEUF-CMA
Sig,B4
Sig,B2
PRF,G,B5 + AdvPRF-sec
PRF,B6 + AdvPRF-sec
PRF,B7
(cid:17)(cid:19)
,
where ns is the maximum number of sessions and nu is the maximum number of users.
If we charge the running time of the original security game to A, then the running times of algorithms
B1, . . . ,B7 are essentially identical to the one of A. This holds as these adversaries merely simulate A’s
original attack with some additional administrative steps.
Proof. First, we consider the case that the adversary makes a single Test query only. This reduces its
advantage, according to a hybrid argument constructing out of A with multiple Test queries to an adversary
B with a single Test query, by a factor at most 1/3ns as there are three stages in each of the ns sessions.10
The main problem we have to deal with is that the session identiﬁers sid2 for the second stages (and hence
also sid3) are not available in clear, but are partly encrypted. This impedes the consistent simulation for B
in terms of identical answers for partnered sessions. Note, however, that we can recover the identiﬁer if we
have the ﬁrst-stage session key, namely, the handshake traﬃc key. Session-key independence and further
arguments about avoiding losing conditions allow us to reveal this key without endangering security of the
second- and third-stage key. We provide the hybrid details in Appendix A.
10We can assume w.l.o.g. that A issues Test queries for a key only after that key was accepted.
21
From now on, we can speak about the session label tested at stage i. Furthermore the hybrid argument
also provides the number of the test session and therefore label, so we can assume that we know label in
advance.
Our subsequent security analysis separately considers the three (disjoint) cases that
A. the adversary tests a client session without honest contributive partner in the ﬁrst stage(i.e., label.role =
B. the adversary tests a server session without honest contributive partner in the ﬁrst stage(i.e., label.role =
C. the tested session has an honest contributive partner in stage 1(i.e., there exists label0 with label.cid1 =
initiator for the test session label and there exists no label0 6= label with label.cid1 = label0.cid1),
responder and there exists no label0 6= label with label.cid1 = label0.cid1), and
label0.cid1).
This allows us to bound the advantage as
(cid:18)
draft-05,A ≤ 3ns·
AdvMulti-Stage,D
draft-05,A
Adv1-Multi-Stage,client without partner
+ Adv1-Multi-Stage,server without partner
+ Adv1-Multi-Stage,test with partner
draft-05,A
(cid:19)
draft-05,A
.
Case A. Test Client without Partner
We ﬁrst consider the case that the tested session is a client (initiator) session without honest contributive
partner in the ﬁrst stage. Since in the moment a client session can ﬁrst be tested (i.e., on acceptance of the
ﬁrst key) cid1 equals sid1, we know that label also has no session partner in stage 1 (i.e., there is no other
label0 with label.sid1 = label0.sid1). Having an honest partner in the second (or later) stage implies having
also one in the ﬁrst stage (as all messages in sid1 are also contained in cid2 = sid2 and cid3 = sid3), hence the
tested session must actually be without honest partner in all stages. Observe that, by the model conditions
and sid1 being set on the client side at the point where K1 is accepted, the adversary cannot win in this case
if the tested key is unauthenticated, hence we can assume that the key is responder-authenticated (i.e.,
label.authi ∈ {unilateral, mutual}). This allows us to focus on Test queries in the stages 2 and 3 according
to the authentication properties AUTH provided.
We proceed in the following sequence of games. Starting from the original Multi-Stage game, we bound
the advantage diﬀerence of adversary A between any two games by complexity-theoretic assumptions until
we reach a game where the advantage of A is at most 0.
Game A.0. This initial game equals the Multi-Stage game with a single Test query where the adversary
is, by our assumption, restricted to test a client (initiator) session without honest contributive partner in
the ﬁrst stage. Therefore,
AdvGA.0
draft-05,A = Adv1-Multi-Stage,client without partner
draft-05,A
.
In this game, we let the challenger abort the game if any two honest sessions compute the
Game A.1.
same hash value for diﬀerent inputs in any evaluation of the hash function H.
Let abortH denote the event that the challenger aborts in this case. We can bound the probability Pr[abortH]
H,B1 of an adversary B1 against the collision resistance of the hash function H. To
by the advantage AdvCOLL
this extent, B1 acts as the challenger in Game A.1, using its description of H to compute hash values, and
running adversary A as a subroutine. If the event abortH occurs, B1 outputs the two distinct input values
to H resulting in the same hash value as a collision.
22
Note that B1 perfectly emulates the attack of A according to GA.0 up to the point till a hash collision
occurs. As B1 wins if abortH is triggered, we have that Pr[abortH] ≤ AdvCOLL
H,B1 and thus
AdvGA.0
draft-05,A ≤ AdvGA.1
draft-05,A + AdvCOLL
H,B1 .
Sig,B2
Game A.2.
In this game, we let the challenger abort if the tested client session receives, within the
ServerCertificateVerify message, a valid signature under the public key pkU of some user U ∈ U such
that the hash value has not been signed by any of the honest sessions.
Let abortSig denote the event that the challenger aborts in this case. We bound the probability Pr[abortSig]
of its occurrence by the advantage of an adversary B2 against the EUF-CMA security of the signature
. In the reduction, B2 ﬁrst guesses a user U ∈ U which it associates with
scheme Sig, denoted AdvEUF-CMA
the challenge public key pk∗ in the EUF-CMA game, then generates all long-term key pairs for the other
users U0 ∈ U \ {U} and runs the Multi-Stage game GA.1 for A, including potentially an abort due to hash
collisions. For any signature to generate for user U in honest sessions for a hash value, B2 calls its signing
oracle about the hash value. When abortSig is triggered, B2 outputs the signature the tested client received
together with the hash value as a forgery.11
Since every honest session has a diﬀerent session identiﬁer than the tested client in the ﬁrst stage (as
the latter has no partnered session in this stage), no honest party will seek to sign the transcript value,
expected by the tested client. Moreover, by the modiﬁcation in Game A.1, there is no collision between any
two honest evaluations of the hash function, so in particular there is none for the hash value computed by
the tested client, implying that the hash value in question has not been signed by an honest party before.
If B2 correctly guessed the user under whose public key the obtained signature veriﬁes, that signature
output by B2 is a valid forgery in the sense that its message was never queried to the EUF-CMA oracle
before. Hence, B2 wins if abortSig occurs and it has guessed the correct user amongst the set of (at most)
nu users and we have that Pr[abortSig] ≤ nu · AdvEUF-CMA
and thus
Sig,B2
draft-05,A ≤ AdvGA.2
draft-05,A + nu · AdvEUF-CMA
Sig,B2
.
AdvGA.1
Finally, if Game A.2 does not abort, we are assured that an honest session outputs the signature
obtained by the tested client session within the ServerCertificateVerify message. The signature is
computed over H(CH, CKS, SH, SKS, EE∗, SCRT, CR∗), i.e., in particular contains all messages in sid1. Hence,
the tested client and the (distinct) honest session outputting the signature agree on sid1, so also on cid1,
and are hence (contributively) partnered in the ﬁrst stage.
The adversary A therefore cannot test a client (initiator) session without honest ﬁrst-stage partner in
Game A.2, resulting in the test bit btest being unknown to A and hence
AdvGA.2
draft-05,A ≤ 0.
Case B. Test Server without Partner
We next consider the case that a server (responder) session is tested without honest contributive partner in
stage 1. Again, this also implies that there is no honest partner in any of the other stages and, moreover,
that also no other session shares the contributive identiﬁers for stages 2 and 3 as they include the full
ﬁrst-stage session identiﬁer and thus also cid1. By deﬁnition, the adversary in this case cannot win if the
tested key is not mutually authenticated, hence we can assume it is, i.e., label.authi = mutual.
11Note that, although the ServerCertificateVerify message containing the signature is sent encrypted, the honest tested
client is simulated by B2 and hence B2 can in particular decrypt this message.
23
We proceed in the following sequence of games, similar to the ﬁrst case, but now geared towards the
(authenticating) client’s signature over the protocol handshake.
Game B.0. This initial game equals the Multi-Stage game with a single Test query where the adversary
this time is restricted to test a responder session without honest contributive partner in the ﬁrst stage.
Clearly again,
AdvGB.0
draft-05,A ≤ Adv1-Multi-Stage,server without partner
draft-05,A
.
Game B.1. As in the ﬁrst case, this game aborts if any two honest sessions compute the same hash value
for diﬀerent inputs in any evaluation of H. Again, we can bound the probability Pr[abortH] that this event
occurs by the advantage of an adversary B3 against the hash function’s collision resistance, constructed as
in the ﬁrst case, and obtain
AdvGB.0
draft-05,A = AdvGB.1
draft-05,A + AdvCOLL
H,B3 .
Game B.2. This game, similar to ﬁrst case, behaves as the previous one but aborts if the tested server
session receives (this time within the ClientCertificateVerify message) a valid signature under some
public key pkU without an honest session outputting this signature. Analogously, we can bound the
probability of this event, Pr[abortSig], by the EUF-CMA security of the signature scheme. The reduction B4
again encodes its challenge public key as a random user’s key (and generates all other key pairs itself) and,
in case of the abortSig event occurs, outputs that very signature which the tested server session obtained
in the ClientCertificateVerify message as its forgery.
As the client’s signature contains all transcript messages up to ClientCertificate, it particularly ﬁxes
the ﬁrst-stage session identiﬁer sid1, meaning that there cannot be a client session signing exactly the
transcript value the tested server session is expecting since, otherwise, this would imply (contributive)
partnering in stage 1. Furthermore, by Game B.1, no session will sign a value colliding under H with the
tested server’s transcript. Hence, if B4 correctly guesses the received signature’s public key, it outputs a
valid forgery and wins if abortSig is triggered and thus
draft-05,A ≤ AdvGB.2
draft-05,A + nu · AdvEUF-CMA
AdvGB.1
Sig,B4
.
Finally, Game B.2 ensures that an honest client session output the ClientCertificateVerify signa-
ture received by the tested server session which, in particular, makes these two sessions agree on sid1, thus
also on cid1, and hence contributively partnered in the ﬁrst stage. The adversary A therefore cannot test
a server (initiator) session without honest contributive ﬁrst-stage partner in Game B.2 anymore, which
allows us to conclude that
AdvGB.2
draft-05,A ≤ 0.
Case C. Test with Partner
We ﬁnally analyze the case that the tested session (client or server) has an honest contributive partner in
the ﬁrst stage, i.e., we know there exists another label0 such that label.cid1 = label0.cid1. Note that, in this
third case, the Test query can be issued in any stage.
Game C.0. Again, we start with an initial game equal to the Multi-Stage game with a single Test query,
but restricting the adversary to only test a session having an honest contributive partner in the ﬁrst stage
in order to have
AdvGC.0
draft-05,A = Adv1-Multi-Stage,test with partner
draft-05,A
.
24
Game C.1. Our ﬁrst modiﬁcation is to guess a session label0 6= label (among the at most ns sessions in
the game) and abort the game in case this session is not the honest contributive partner (in stage 1) of the
tested session, i.e., we abort if label.cid1 6= label0.cid1. Note that we can, without loss of generality, assume
that A always issues a Test query. This reduces the adversary’s advantage by a factor of at most 1/ns.
AdvGC.0
draft-05,A ≤ ns · AdvGC.1
draft-05,A.
From now on, we can speak of the session label0 (contributively) partnered with the tested session label in
stage 1, and can assume that we know label0 in advance.
Game C.2. At this point, having the (honest) contributions to the tested session ﬁxed, we can encode a
Diﬃe–Hellman challenge in the shares gx and gy at the tested session. If a client session is tested, we know
that the partnered session label0 guessed in Game C.1 holds the same shares. However, if a server session