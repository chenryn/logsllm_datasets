title:Knowledge Connectivity vs. Synchrony Requirements for Fault-Tolerant
Agreement in Unknown Networks
author:Fab&apos;ıola Greve and
S&apos;ebastien Tixeuil
Knowledge Connectivity vs. Synchrony Requirements
for Fault-Tolerant Agreement in Unknown Networks∗
Federal University of Bahia (UFBA), Brasil
LRI-CNRS & INRIA Grand Large, France
S´ebastien Tixeuil
Univ. Paris-Sud
PI:EMAIL
Fab´ıola Greve
Computer Science Department
PI:EMAIL
Abstract
In self-organizing systems, such as mobile ad-hoc and
peer-to-peer networks, consensus is a fundamental building
block to solve agreement problems. It contributes to coordi-
nate actions of nodes distributed in an ad-hoc manner in
order to take consistent decisions.
It is well known that
in classical environments, in which entities behave asyn-
chronously and where identities are known, consensus can-
not be solved in the presence of even one process crash. It
appears that self-organizing systems are even less favorable
because the set and identity of participants are not known.
We deﬁne necessary and sufﬁcient conditions under which
fault-tolerant consensus become solvable in these environ-
ments. Those conditions are related to the synchrony re-
quirements of the environment, as well as the connectivity
of the knowledge graph constructed by the nodes in order
to communicate with their peers.
1
Introduction
Wireless sensor and ad hoc networks (and, in a different
context, unstructured peer to peer networks) enable partici-
pating entities access to services and informations indepen-
dently of their location or mobility. This is done by elimi-
nating the necessity of any statically designed infrastructure
or any centralized administrative authority. It is in the na-
ture of such systems to be self-organizing, since additionaly,
entities are allowed to join or leave the network in an arbi-
trary manner, making the whole system highly dynamic.
Agreement problems are fundamental building blocks of
reliable distributed systems, and the issue of designing re-
liable solutions that can cope with the high dynamism and
∗This work is part of the CAPES-COFECUB international cooperation
program. Fab´ıola’s research was supported by grants from CNPQ/Brazil
and Fapesb-Bahia/Brazil. S´ebastien’s research was supported by grants
FRAGILE and SOGEA from ANR.
self-organization nature of sensor and ad-hoc network is a
very active ﬁeld of current research. The core problem be-
hind agreement problems is the consensus problem. Infor-
mally, a group of processes achieves consensus in the fol-
lowing sense: each process initially proposes a value and all
correct processes (i.e. those that are not crashed) must reach
a common decision on some value that is equal to one of the
proposed values. For example, reaching agreement within a
set of mobile robots was recently investigated in [9].
Contrarily to traditional (i.e. wired) networks, where
processes are aware of network topology and have a com-
plete knowledge of every other participant,
in a self-
organizing environment with no central authority, the num-
ber and processes are not known initially. Yet, even
in a classical environment, when entities behave asyn-
chronously, consensus cannot be solved if one of the par-
ticipants is allowed to crash [6]. Thus, solving consensus
when the set of participants is unknown is even more difﬁ-
cult. Nonetheless, due to the essential role of this problem,
we study in this paper the conditions that permit to solve
consensus in unknown asynchronous networks in spite of
participant crashes.
In order to capture the unawareness of self-organizing
systems regarding the topology of the network as well as the
set of participants, Cavin et al. [1] deﬁned a new problem
named CUP (consensus with unknown participants). This
new problem keeps the same deﬁnition of the classical con-
sensus, except for the expected knowledge about the set of
processes in the system. More precisely, they assume that
processes are not aware of Π, the set of processes in the sys-
tem. To solve any non trivial application, processes must
somehow get a partial knowledge about the other processes
if some cooperation is expected. The participant detector
abstraction was proposed to handle this subset of known
processes [1]. They can be seen as distributed oracles that
provides hints about the participating processes in the com-
putation. For example, a way to implement participant de-
tectors for mobile nodes is to make use of local broadcasting
in order to construct a local view formed by 1-hop neigh-
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 12:49:19 UTC from IEEE Xplore.  Restrictions apply. 
37th Annual IEEE/IFIP International Conference on Dependable Systems and Networks (DSN'07)0-7695-2855-4/07 $20.00  © 2007bors. Based on the initial knowledge graph formed by the
participant detectors in the system, Cavin et al. deﬁne nec-
essary and sufﬁcient connectivity conditions of this knowl-
edge graph in order to solve CUP in an asynchronous envi-
ronment but in a fault-free scenario.
In turn, failure detector and leader oracles are elegant
abstractions which encapsulate the extra synchrony neces-
sary to circumvent the impossibility result of fault-tolerant
consensus in traditional networks [3, 8]. A failure detector
of the class 3S can be seen as an oracle that provides hints
on crashed processes [3]. The Ω leader oracle, eventually
provides processes with he same correct process identity
(that is, the same leader) [8]. Both, 3S and Ω have the same
computational power [5], and they have been proved to be
the weakest classes of detectors allowing to solve consensus
in asynchronous known networks [4]. Those failure detec-
tors may make an arbitrary number of mistakes, but, in spite
of their inaccuracy, they will never compromise the safety
properties of the consensus protocol that uses them. These
consensus protocols are considered indulgent towards these
oracles, meaning that they are conceived to tolerate their un-
reliability during arbitrary periods of asynchrony and insta-
bility of the environment. Moreover, any of those indulgent
protocols will solve the uniform version of the consensus.
The uniform consensus ensures the uniformity of the deci-
sion, processes be correct of faulty [7].
In the context of unknown networks, the problem of FT-
CUP (fault-tolerant CUP) has been subsequently studied by
Cavin et al. [2]. By considering the minimal connectivity
requirements over the initial knowledge graph for solving
CUP, they identify a perfect failure detector (P) to fulﬁll
the necessary synchrony requirements for solving FT-CUP.
A perfect failure detector never make mistakes and can only
be implemented in a synchronous system. Thus, solving
FT-CUP in a scenario with the weakest knowledge connec-
tivity demands the strongest synchrony conditions. How-
ever, strong synchrony competes with the high dynamism,
full decentralization and self-organizing nature of wireless
sensor and ad-hoc networks. Moreover, even with a perfect
failure detector, when the minimal knowledge connectivity
is being considered, the uniform version of FT-CUP cannot
be solved in unknown networks [2].
In this paper, we show that there is a trade-off between
knowledge connectivity and synchrony for consensus in
fault-prone unknown networks. In particular, we focus on
solving FT-CUP with minimal synchrony assumption (i.e.
the Ω failure detector), and investigate necessary and suf-
ﬁcient requirement about knowledge connectivity.
If the
system satisﬁes our knowledge connectivity conditions, any
of the indulgent consensus algorithms initially designed for
traditional networks can be reused to solve FT-CUP as well
as uniform FT-CUP.
The remaining of the paper is organized as follows: Sec-
tion 2 provides the model, notations, and statement of the
problem we consider; Section 3 describes abstractions to
solve consensus; Section 4 presents necessary and sufﬁcient
conditions to solve FT-CUP and uniform FT-CUP with min-
imal synchrony assumptions. Section 5 provides some con-
cluding remarks.
2 Preliminaries
Model. We consider a distributed system that consists of a
ﬁnite set Π of n > 1 processes, namely, Π = {p1, . . . , pn}.
In a known network, Π is known to every participating pro-
cess, while in an unknown network, a process pi may only
be aware of a subset Πi of Π.
Processes communicate by sending and receiving mes-
sages through reliable channels, i.e., there is no message
creation, corruption, duplication; moreover, a message m
sent by a process pi to pj is eventually received by pj, if
both pi and pj are correct. A process pi may only send
a message to another process pj if pj ∈ Πi. Of course,
if a process pi sends a message to a process pj such that
pi 6∈ Πj, upon receipt of the message, pj may add pi to Πj
and send a message back to pi. We assume the existence
of a reliable underlying routing layer, in such a way that if
pj ∈ Πi, then pi can send a message reliably to pj. There
are no assumptions on the relative speed of processes or on
message transfer delays, i.e. the system is asynchronous.
A process may fail by crashing, i.e., by prematurely
or by deliberately halting (switched off); a crashed pro-
cess does not recover. A process behaves correctly (i.e.,
according to its speciﬁcation) until it (possibly) crashes.
By deﬁnition, a correct process is a process that does not
crash. A faulty process is a process that is not correct. Let
f denote the maximum number of processes that may crash
in the system. We assume that f is known to every process.
Classical Consensus. The consensus problem is the most
fundamental agreement problem in distributed computing.
Every process pi proposes a value vi and all correct pro-
cesses decide on some unique value v, in relation to the set
of proposed values. More precisely, the consensus is de-
ﬁned by the following properties [3, 6]: (i) Termination: ev-
ery correct process eventually decides some value; (ii) Va-
lidity: if a process decides v, then v was proposed by some
process; (iii) Agreement: no two correct processes decide
differently.
Uniform Consensus.
The uniform version of the
consensus changes the agreement property for: (iii) Uni-
form Agreement: no two processes (correct or not) decide
differently.
Consensus in Unknown Networks. In this paper, we con-
centrate on solving consensus in a fault-prone unknown net-
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 12:49:19 UTC from IEEE Xplore.  Restrictions apply. 
37th Annual IEEE/IFIP International Conference on Dependable Systems and Networks (DSN'07)0-7695-2855-4/07 $20.00  © 2007work. We consider three variants of the problem:
CUP (Consensus with Unknown Participants). The
goal is to solve consensus in an unknown network, where
processes may not crash;
FT-CUP (Fault-Tolerant CUP). The goal is to solve
consensus in an unknown network, where up to f processes
may crash;
Uniform FT-CUP (Uniform Fault-Tolerant CUP).
The goal is to solve the uniform version of the consensus
in an unknown network where up to f processes may crash.
Graph Notations. We consider directed graphs Gdi =
(V, E), deﬁned by a set of vertices V and a set E of edges
(v1, v2), which are ordered pairs of vertices of V . Through-
out the paper, the terms “node”, “vertex” and “process” will
be used indistinctly. The distance between two vertices u, v
(denoted by d(u, v)) is the minimum of the lengths of all
directed paths from u to v (assuming there exists at least
one such path). The out-degree of a vertex v of Gdi is equal
to the number of vertices u such that the edge (v, u) is in
E. A sink is a node with out-degree 0. A directed graph
Gdi(V, E) is k-strongly connected if for any pair of nodes
(vi, vj), vi can reach vj through k distinct node-disjoint
paths. In particular, when k = 1, Gdi is strongly connected.
By Menger’s Theorem [10], it is known that the minimum
number of nodes whose removal from Gdi(V, E) discon-
nects nodes vi from vj is equal to the maximal number of
node-disjoint paths from vi to vj. This result leads to the
following two observations:
1. For any n and k, there exists a n-sized k-strongly con-
nected directed graph Gdi(V, E) such that the removal of k
nodes disconnects the graph.
2. If the graph Gdi is k-strongly connected, removing
(k − 1) nodes leaves at least one path between any pair of
nodes (vi, vj). Thus, the graph remains strongly connected.
3 Synchrony and Knowledge Connectivity
for Consensus in Fault-Prone Systems
3.1 Failure Detector: a Synchrony Ab-
straction
A fundamental result in the consensus literature [6]
states that even if Π is known to all processes in the sys-
tem and the number of faulty processes is bounded by 1,
consensus cannot be solved by a deterministic algorithm in
an asynchronous system. To enable solutions, some level of
synchrony must be assumed. A nice abstraction to model
network synchrony is the failure detector [3]. A failure de-
tector (denoted by FD) can be seen as an oracle that pro-
vides hints on crashed processes. Failure detectors can be
classiﬁed according to the properties (completeness and ac-
curacy) they satisfy. The completeness property refers to
the actual detection of crashes; the accuracy property re-
stricts the mistakes a failure detector is allowed to make. In
this paper, we consider two classes of failure detectors:
Perfect FD (P). Those failure detectors never make mis-
takes. They satisfy the perpetual strong accuracy, stating
that no process is suspected before it crashes, and the strong
completeness property, stating that eventually, every pro-
cess that crashes is permanently suspected by every correct
process.
Eventually Strong FD (3S). Those failure detectors
can make an arbitrary number of mistakes. Yet, there is
a time after which some correct process is never suspected
(eventual weak accuracy). Moreover, they satisfy the strong
completeness property.
Leader Detector (Ω). Another approach for encapsu-
lating eventual synchrony consists of extending the sys-
tem with a leader detector, which is an oracle that even-
tually provides the same correct process identity to all pro-
cesses [8].
It has been proved that 3S and Ω have the same compu-
tational power [5] and that they are the weakest class of de-
tectors allowing to solve the consensus and the uniform con-
sensus problem in a system of known networks [4]. Relying
on 3S and Ω failure detectors to solve agreement problems
assumes that a majority of processes within the group never
fails, i.e., f < n/2.
3.2 Participant Detectors: a Knowledge