# 21 \| 知识串讲（上）：带你开发一个书店应用你好，我是 Chrono。到今天为止，课程里的 C++知识就全部讲完了。前面我们总共学习了四大模块，我再带你做一个简略的回顾。在"概论"单元，我带你从宏观的层面上重新认识了C++，讲了它的四个生命周期和五个编程范式，分别介绍了在编码阶段、预处理阶段、编译阶段，C++能够做哪些事情，接着又重点说了在 C++里，运用哪些特性才能更好地实践面向对象编程。在"语言特性"单元，我们一起研究了自动类型推导、常量、智能指针、异常、函数式编程这五个特性。这些特性是"现代"C++区别于"传统"C++的关键，掌握了它们，你就能够写出清晰、易读、安全的代码。在"标准库"单元，我介绍了字符串、容器、算法和并发。它们是 C++标准库中最核心的部分，也是现代 C++和泛型编程的最佳应用和范例。学会了标准库，你才能说是真正理解了C++。 在"技能进阶"单元，我为你挑选出了一些第三方工具，包括序列化、网络通信、脚本语言和性能分析，它们很好地补充完善了C++语言和标准库，免去了我们"自己造轮子"的麻烦，让我们把精力集中在实现业务逻辑上。除了上面的这"十八般武艺"，我还谈了谈能够帮你更好地运用 C++的设计模式和设计原则，介绍了几个比较重要、常用的模式，希望你在今后的实际开发工作中，能够有意识地写出灵活、可扩展的代码。这么回顾下来，内容还真是不少啊。为了让你更好地把这些知识融会贯通，接下来我会再用两节课的时间，从需求、设计，到开发编码、编译运行，再加上一些我自己的实用小技巧，详细讲解一个C++程序的实际开发过程，把知识点都串联起来。虽然说是"串讲"，但是你只要学过了前面的内容，就可以跟着我做出这个书店程序。不过，我担心有些知识点你可能忘记了，所以，涉及到具体的知识点时，我会给你标注出是在哪一节，你可以随时回去复习一下。项目设计那么，该用个什么样的例子来串讲 C++的这些知识点呢？说实话，找出一个合适的例子真的很难。因为大多数 C++实际项目都很大、很底层，还有各种依赖或者内部库，不好直接学习研究。所以我再三考虑，决定借鉴一下 [C++Primer 里的书店例子，修改一下它的需求，然后完全重新开发，作为我们这个课程的综合示例。先介绍一下咱们这个书店程序。简单来说，就是销售记录管理，从多个渠道把书号、销售册数、销售额都汇总起来，做个统计分析，再把数据定期上报到后台。C++ Primer 里的书店程序是本地运行的，为了演示课程里讲到的的 C++特性，我把它改成了网络版。不过，拓扑结构并不复杂，我画了张图，你可以看一下。![](Images/1f19ee412d0aca1a2725931fdb831413.png)savepage-src="https://static001.geekbang.org/resource/image/62/97/62632ba7426af7731902c83724504097.png"}项目的前期需求就算是定下来了，接着就要开始做设计了，这就要用到设计模式和设计原则的知识了（第 19 讲slate-object="inline"、第 20 讲slate-object="inline"）。不过这个系统还是比较简单的，不需要用什么复杂的分析手段，就能够得出设计，主要应用的是单一职责原则、接口隔离原则和包装外观模式。这里我也画了一个UML图，可以帮助你理解程序的架构。![](Images/bfcb736a8ef0a74d3907d32d093a4b2c.png)savepage-src="https://static001.geekbang.org/resource/image/f0/ef/f08637cf6b49316c230d058cb2a9f5ef.jpg"}下面我就对照这个 UML 类图，结合开发思路和源码，仔细说一下具体的 C++开发，完整的源码都放在了GitHubslate-object="inline"上，课下可以仔细地看一下。核心头文件首先要说的是我写 C++项目的一个习惯，定义核心头文件：**cpplang.hpp**。它集中了 C++标准头和语言相关的定义，被用于其他所有的源文件。注意，在写它的时候，最好要有文件头注释（第 2 讲），而且要有"Includeguard"（ [第 3讲  slate-object="inline"），就像下面这样：    // Copyright (c) 2020 by Chrono    #ifndef _CPP_LANG_HPP        // Include guard    #define _CPP_LANG_HPP        // Include guard    #include            // C++标准头文件    ...    #endif  //_CPP_LANG_HPP在核心头文件里，我们还可以利用预处理编程，使用宏定义、条件编译来屏蔽操作系统、语言版本的差异，增强程序的兼容性。比如，这里我就检查了 C++的版本号，然后定义了简化版的"deprecated"和"static_assert"：    // must be C++11 or later    #if __cplusplus = 201402    
#   define  CPP_DEPRECATED [[deprecated    #else    