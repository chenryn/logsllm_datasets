cOPT=60, Pgoal=0.085
41
40
39
38
37
36
35
65
4
F
f
o
e
u
a
V
l
α=0.17 to 0.33
cOPT=45, Pgoal=0.12
α=0.09 to 0.17 
cOPT=40, Pgoal=0.14
α=0 to 0.09
cOPT=35, Pgoal=0.18
0.25
0.2
0.15
0.1
35
0.05
Probability of attack 
at goal
α=0.46 to 1
cOPT=65, Pgoal=0.06
60
55
50
40
Security Investment Cost (c       )OPT
 for BGP ACT in $
45
Figure 7.
objective function F4 for different values of 𝛼
3D scatter plot of optimal solution points for BGP ACT using
The quality of the solution obtained will be quite sensitive
to the selected weights. The constraint (covered set = A) is as
in Eq. (2). This is a non-linear binary integer programming
problem which is solvable in the same way as objective
function F3, i.e., the non-linear binary integer programming
problem is ﬁrst reduced to a linear one and then the branch
and bound algorithm in Algorithm 3 is used to solve it. A
3D scatter plot of the optimal solution points for BGP ACT
using objective function F4 for different values of 𝛼 plotted
against the values of P𝑔𝑜𝑎𝑙, security investment cost and F4
value is shown in Figure 7. Minimum value of F4 (=35) is
noted for the range 𝛼=(0.46,1).
V. PERFORMANCE EVALUATION
We implemented a module for automatic description and
evaluation of ACTs in SHARPE [13]. For the computation
of probability of attack and mincuts of ACT we simply
call the already existing algorithms for solving fault trees in
SHARPE. We have added the relevant algorithms (described
in [7]) for computing cost, impact and risk in ACT with and
without repeated events in SHARPE. ROI computation is
done by deﬁning functions in the SHARPE textual input
ﬁle. We have implemented all
the relevant optimization
algorithms in SHARPE.
In the absence of a cyclic T matrix, Algorithm 2 is
solvable in polynomial time [15]. Runtime = (total num-
ber of atomic attack events in the ACT)*(total number of
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 07:17:10 UTC from IEEE Xplore.  Restrictions apply. 
s
d
n
o
c
e
s
n
i
e
m
i
t
n
u
R
16
14
12
10
8
6
4
2
Explicit enum. without reduction
Explicit enum. with reduction
SGA without reduction
B&B without reduction
SGA with reduction
B&B with reduction
in minutes
Runtime with implicit enumeration
Runtime with Simple Genetic Algorithm
Runtime with explicit enumeration
in minutes
70
60
50
40
30
20
10
s
d
n
o
c
e
s
n
i
e
m
i
t
n
u
R
100
s
d
n
o
c
e
s
n
i
e
m
i
t
n
u
R
Runtime with explicit enumeration
Runtime with SGA
Runtime B&B algorithm
in minutes
90
80
70
60
50
40
30
20
10
0
0
500
1000
2000
1500
4500
Number of leaf nodes in the ACT
2500
3000
3500
4000
(a)
5000
0
0
1000
2000
4000
Number of leaf nodes in ACT
3000
(b)
5000
0
0
1000
2000
4000
Number of leaf nodes in the ACT
3000
(c)
5000
Figure 9. Runtime plot for optimization (a) with obj. function 𝐹1 with increasing tree size using explicit enumeration, branch and bound (Algorithm
3) and an SGA [6] with and without reduction (b) with obj. function 𝐹2 using explicit enumeration, branch and bound (Algorithm 3) and an SGA with
increasing tree size (c) with obj. function 𝐹3 using explicit enumeration, branch and bound (Algorithm 3) and an SGA with increasing tree size
defense mechanisms in the ACT)*min(∣no of atomic attack
events∣,∣no of defense mechanisms∣) = 𝑂(𝑚𝑛 ∗ 𝑚𝑖𝑛(𝑚, 𝑛))
which indicates polynomial runtime. Recursion tree for an
example cyclic T matrix using Algorithm 3 with objective
function 𝐹2 on an ACT that forms a 4×4 cyclic T matrix
is shown in Figure 8. A binary string represents the partial
solution (P) at any node of the tree. Each bit of the string
(represented by indicator function 1𝑃 (CM𝑖) in Figure 8)
represents a certain countermeasure. Bit 0 indicates the cor-
responding countermeasure is not considered in the partial
solution whereas bit 1 indicates it is considered. A string of
length 1 indicates a partial solution that takes into account
only CM1 whereas the other countermeasures are redundant.
A string of length 2 indicates a partial solution that considers
only CM1 (most signiﬁcant bit) and CM2 (least signiﬁcant
bit) whereas the other countermeasures are redundant and
so on. Thus, a partial solution of 0101 represents a partial
solution where CM2 and CM4 are present and CM1 and
CM3 are absent. The recursion tree in Figure 8 explores
every possible solution and shows cases where the subtree
is pruned by fathoming rules of branch and bound. The tree
shown has 13 nodes as opposed to 31 (24+1-1) nodes in
its explicit enumeration search tree. An analogous pruning
technique was proposed in [24] using BDMP (Boolean Logic
Driven Markov Processes) where the state-space is trimmed
by eliminating attack paths with low success probability to
alleviate the state space explosion problem. In the average
case, the size of the recursion tree generated by the branch
and bound in Algorithm 3 is polynomial in the number of
control variables in the optimization (here no. of counter-
measures). Since the search space is exponential, the worst
case runtime is also exponential. However, this worst case
occurs only when the fathoming or bounding rules are not
satisﬁed at any node of the search tree. Such cases are
negligible.
In Figure 9, we compare the efﬁciency of our approach
T
A1
A2
A3
A4
CM1
1
CM2
1
CM3
0
CM4
0
0
0
1
1
0
0
1
1
0
0
1
1
φ
ZL=0
ZU= ∞
Cost in $
CM1
CM2
CM3
CM4
10
20
15
25
1
ZL=10
ZU= ∞
ZL=0
ZU= 25
0
 P CM
1
(
)
1
11
ZL=30
ZU= ∞
10
ZL=10
ZU= 45
01
ZL=20
ZU= 25
ZL=0
ZU= 25
00
 P CM
1
(
)
2
Success: 
Fathoming 
Test 2
111
ZL=45
ZU= ∞
ZL=25
ZU= 45
101
Success: 
Fathoming 
Test 3
Soln.=1110
ZU=ZL=45
Success: 
Fathoming 
Test 3
Soln.=1010
ZU=ZL=25
ZL=35
ZU= 25
011
Success: 
Fathoming 
Test 1
ZL=45
ZU= 25
0101
010
ZL=20
ZU= 25
  P CM
1
(
)
3
ZL=20
ZU= 25
 P CM
1
(
)
4
0100
Success: 
Fathoming 
Test 1
Success: 
Fathoming 
Test 2
Figure 8. Recursion tree for a cyclic T matrix from Algorithm 3
with existing approaches for large ACTs (for instance, ACT
for compromising a university LAN). For increasing tree
size, runtime (y-axis) for ﬁnding optimal countermeasure
set using objective function 𝐹1, 𝐹2 and 𝐹3 is plotted against
the number of leaf nodes (x-axis) in the ACT in Figure 9(a),
Figure 9(b) and Figure 9(c) respectively. For the objective
function 𝐹1, we compare the runtimes of six different
variants of our methods in Figure 9(a). We compare the
runtimes of (i) explicit enumeration without reduction (ii)
explicit enumeration with reduction, (iii) branch and bound
without reduction (iv) branch and bound with reduction
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 07:17:10 UTC from IEEE Xplore.  Restrictions apply. 
(v) simple genetic algorithm (SGA) used by Dewri et.al
without reduction and (vi) a simple genetic algorithm with
reduction. Methods (iv) and (vi) are shown to have minimum
runtime. For the objective function 𝐹2, our method (branch
and bound) returns an optimal solution for the ACT with
upto 5000 leaf nodes in almost 25 seconds (as shown
in Figure 9(b)) on a system with an Intel(R) Core(TM)2
CPU 1862.103 MHz processor with 2 MB of cache, 4 GB
of memory and the CentOS Release 5.4 (Linux 2.6.34)
operating system which is much better than the runtime
of explicit enumeration technique (almost 70 minutes) and
slightly better than the runtime of a simple genetic algorithm
(nearly 35 seconds) used for the same objective function.
Though the runtime difference between our approach and
SGA approach is in seconds for ACT with 5000 leaf nodes,
this difference will increase for ACT with higher number
of leaf nodes. This demonstrates improved scalability of our
approach. For the objective function 𝐹3, our method (branch
and bound) returns an optimal solution for the ACT with
upto 5000 leaf nodes in 38 seconds on the same system (as
shown in Figure 9(c)) which is much better than the runtime
of explicit enumeration technique (almost 96 minutes) and
slightly better than the runtime of a simple genetic algorithm
(40 seconds) used for the same objective function.
VI. RELATED WORK
Schneier developed the basic attack tree (AT) formalism
[1]. Dewri et.al [6] used genetic algorithms to ﬁnd optimal
security action using single and multi-objective optimization
on ATs. However these methods suffered because AT struc-
ture did not take countermeasures into account. Bistarelli
et.al [25] proposed defense trees (DTs) to incorporate de-
fense mechanisms in AT and applied game theory to ﬁnd
the most cost effective set of countermeasures. However
in DTs, countermeasures could only be placed at the leaf
nodes. Foo et.al [26] used intrusion graphs (I-GRAPHs)
to model dynamic intrusion response but did not deal
with model scalability issues. Zonouz et.al [8] proposed
attack-response trees (ARTs) that incorporate both attacks
and responses but they used a state-space model (partially
observable stochastic game model) to ﬁnd an optimal set
of countermeasures thereby leading to state-space explosion