title:Wobfuscator: Obfuscating JavaScript Malware via Opportunistic Translation
to WebAssembly
author:Alan Romano and
Daniel Lehmann and
Michael Pradel and
Weihang Wang
6
2
6
3
3
8
9
.
2
2
0
2
.
4
1
2
6
4
P
S
/
9
0
1
1
.
0
1
:
I
O
D
|
E
E
E
I
2
2
0
2
©
0
0
.
1
3
$
/
2
2
/
9
-
6
1
3
1
-
4
5
6
6
-
1
-
8
7
9
|
)
P
S
(
y
c
a
v
i
r
P
d
n
a
y
t
i
r
u
c
e
S
n
o
m
u
i
s
o
p
m
y
S
E
E
E
I
2
2
0
2
2022 IEEE Symposium on Security and Privacy (SP)
Wobfuscator: Obfuscating JavaScript Malware via
Opportunistic Translation to WebAssembly
Alan Romano
University at Buffalo, SUNY
Buffalo, United States
PI:EMAIL
Daniel Lehmann
University of Stuttgart
Stuttgart, Germany
PI:EMAIL
Michael Pradel
University of Stuttgart
Stuttgart, Germany
PI:EMAIL
Weihang Wang
University at Buffalo, SUNY
Buffalo, United States
PI:EMAIL
Abstract—To protect web users from malicious JavaScript
code, various malware detectors have been proposed, which
analyze and classify code as malicious or benign. State-of-the-
art detectors focus on JavaScript as the only target language.
However, WebAssembly provides attackers a new and so far
unexplored opportunity for evading malware detectors. This
paper presents Wobfuscator, the first technique for evading
static JavaScript malware detection by moving parts of the
computation into WebAssembly. The core of the technique is a
set of code transformations that translate carefully selected parts
of behavior implemented in JavaScript into WebAssembly. The
approach is opportunistic in the sense that it uses WebAssembly
where it helps to evade malware detection without compromising
the correctness of the code. Evaluating our approach with a
dataset of 43,499 malicious and 149,677 benign JavaScript files,
as well as six popular JavaScript libraries reveals that our
approach is effective at evading state-of-the-art, learning-based
static malware detectors; the obfuscation is semantic-preserving;
and our approach has small overhead, making it practical for
use in real-world programs. By pinpointing limitations of current
malware detectors, our work motivates future efforts on detecting
multi-language malware in the web.
I. INTRODUCTION
The omnipresence of the web makes client-side web ap-
plications an attractive target for attackers. As a result, var-
ious kinds of attacks target the browser, e.g., drive-by mal-
ware [48], [23], [43], malicious code deployed via script-based
browser augmentation markets [58], browser-based cryptomin-
ing without user consent [40], [52], [34], malicious browser
extensions [21], [65], and browser-based phishing [14]. A
recent report estimates that orchestrated phishing campaigns
alone create 1.7 to 2 million malicious payload URLs each
month [44]. Beyond such obviously malicious activities, many
websites employ techniques that are unwanted by users, such
as extensive browser fingerprinting [30] or tracking [25].
To protect users against executing malicious scripts in their
browser, JavaScript malware detectors warn about such scripts
before or while executing them. One line of work statically
analyzes scripts before they are executed [24], [50], [56], [28],
[27], e.g., by intercepting them already in the network, as
part of a browser, or as part of a separate anti-virus tool.
Another line of work dynamically analyzes scripts [36], e.g.,
by instrumenting the code or via a browser extension. To
reduce the runtime overhead imposed by dynamic analysis-
based malware detectors, static detectors often serve as a first
line of defense, e.g., by dynamically analyzing only those
scripts that are deemed dangerous by a static analysis.
To effectively attack users despite the presence of malware
detectors, attackers try to hide the maliciousness of scripts
via obfuscation and evasion techniques [53], [55]. Progress
by attackers and defenders leads to an arms race between
increasingly sophisticated obfuscation and evasion techniques
on one hand and increasingly effective malware detectors on
the other hand. Currently, the most effective malware detec-
tion techniques use learning-based classifiers to distinguish
malicious from benign scripts [24], [50], [28], [27]. These
approaches extract a set of features from a given JavaScript
file, e.g., n-grams of code tokens or AST-based features, or
feed the JavaScript code into a deep neural network [63] to
determine whether the file is likely to be malicious.
While the focus on JavaScript historically makes sense,
JavaScript is not the only language of the client-side web any-
more. WebAssembly [31] is another language that is widely
available in browsers. First announced in 2015, WebAssembly
is supported by all major browsers since November 2017,
and available in 94% of all global browser installations as of
August 20211. The language provides an efficient compilation
target for computation-intensive libraries written in languages
such as C and C++. In addition to the many positive uses
of WebAssembly, the language provides a new opportunity to
attackers for evading malware detectors – an opportunity that,
to the best of our knowledge, has not yet been explored.
This paper presents the first technique for evading JavaScript
malware detection by moving parts of the computation into
WebAssembly. We describe Wobfuscator, a code obfuscation
technique that transforms a given JavaScript file into a new
JavaScript file and a set of WebAssembly modules. By chang-
ing the malicious JavaScript code, our work aims at evading
static malware detectors. The rationale is that static detectors
may be used on their own or serve as a filter for which
scripts to analyze dynamically. That is, evading static malware
detectors gives a huge benefit to attackers.
Transforming parts of a JavaScript file into WebAssembly
is far from trivial. JavaScript is dynamically typed, has com-
plex objects, and provides direct access to browser APIs. In
contrast, WebAssembly is statically typed, has only four low-
1https://caniuse.com/?search=WebAssembly
© 2022, Alan Romano. Under license to IEEE.
DOI 10.1109/SP46214.2022.00064
1574
Authorized licensed use limited to: Tsinghua University. Downloaded on August 07,2022 at 12:59:50 UTC from IEEE Xplore.  Restrictions apply. 
level, primitive data types, and it can access browser APIs only
indirectly by importing them from JavaScript. Because of these
fundamental differences, general JavaScript-to-WebAssembly
translation is practically impossible, which is reflected in the
fact that WebAssembly never has been touted as a replacement
for JavaScript but as a way to complement it [31].
The core technical contribution of this paper is a set of code
transformations that extract carefully selected parts of behavior
implemented in JavaScript for translation into WebAssembly.
The approach is opportunistic in the sense that it translates
JavaScript to WebAssembly where it helps to evade malware
detectors, without compromising the correctness of the code.
For example, we present a transformation that extracts function
calls into a WebAssembly module, obfuscating if and when a
script calls a particular function. Other transformations aim at
obfuscating string literals, control-flow statements, and array
initializations. Preconditions guard each transformation to en-
sure the original behavior is preserved, a property we consider
crucial for an attacker to use an obfuscation technique.
Our work relates to existing obfuscation techniques for
JavaScript. For example, Fass et al. fuse malicious code into
benign code while preserving the AST of the benign code [26].
For a more comprehensive overview of obfuscation techniques
and their prevalence, we refer readers to other work [66],
[55]. All of these approaches obfuscate code via transfor-
mations within the JavaScript language, whereas Wobfuscator
exploits the availability of WebAssembly to obfuscate code by
translating beyond JavaScript. A paper by Wang et al. shares
the general idea of obfuscating code written in one language
by translating parts of it into another language [60]. How-
ever, they describe partially translating C code into Prolog,
which does not address the unique challenges of obfuscating
JavaScript via partial translation to WebAssembly.
We evaluate Wobfuscator with a dataset of 43,499 malicious
and 149,677 benign JavaScript files, as well as six popular
JavaScript libraries. Our results show the following. First,
the approach is effective at evading state-of-the-art, learning-
based static malware detectors: Applying our transformations
reduces the recall of the four studied detectors [50], [24], [28],
[27] to 0.18, 0.63, 0.18, and 0.00, respectively. Second, the
obfuscation preserves the semantics of the transformed code:
Obfuscating six popular JavaScript libraries and running their
2,017 tests shows no observable changes in the behavior of the
tested code. Finally, we find that our tool only takes on average
8.9 seconds to apply all the transformations to a project (with
on average 4,152 lines of code) and adds on average 31.07%
of overhead during runtime. Overall, these results show that
Wobfuscator is practical for use in real-world programs.
In summary, this paper contributes the following:
• The first technique to use WebAssembly as a means for
obfuscating the behavior of malicious JavaScript code.
• A set of code transformations that translates carefully
selected JavaScript code locations into WebAssembly.
• A comprehensive evaluation showing that the approach
effectively evades state-of-the-art static malware detectors
while preserving the semantics of the original code.
Our experiment results are publicly available:
https://github.com/js2wasm-obfuscator/translator
II. BACKGROUND ON WEBASSEMBLY
We present a brief introduction of the core concepts and
syntax of WebAssembly. For space reasons, we refer the
reader to the original publication [31], official website [10],
or specification [64] for more elaborate explanations.
WebAssembly is a low-level byte code language. Web-
Assembly programs are distributed as binaries that are com-
pact to send over the network and quick to parse.
Each WebAssembly program is a single-file module, orga-
nized into several sections. Most importantly, the code section
contains all functions with their bodies. The global section
contains scalar global variables. The memory section declares
a linear, byte-addressable memory, of which parts can be
initialized with the data section.
WebAssembly instructions operate at a low level of abstrac-
tion, without, e.g., classes or complex objects. Instructions and
functions are statically typed, but there are only four primitive
types: 32- and 64-bit integer and floating-point values, respec-
tively. Instructions are executed on a virtual stack machine,
i.e., they pop their operands and push their results onto an
implicit evaluation stack. Instructions are simple and designed
to map closely to hardware instructions, e.g., a WebAssembly
i32.add instruction would be translated into an x86 addl.
Since there is no garbage collector and only primitive scalar
types, complex objects (strings, arrays, records, etc.) are stored
into program-organized linear memory, which is essentially a
growable array of untyped bytes.
WebAssembly does not have a standard library, and for
interaction with the “outside world”, WebAssembly modules
need to import functions from the host environment. In the
browser, that host environment is JavaScript, so any JavaScript
function can be called from WebAssembly. Non-primitive data
needs to be marshalled through the WebAssembly memory
however (which can be accessed from JavaScript as well). The
WebAssembly API in JavaScript provides functions to compile
and instantiate (that is, fulfill the imports of) WebAssembly
modules and call exported WebAssembly functions.
III. THREAT MODEL
Our work is about malicious or unwanted code delivered as
part of a client-side web application. A website may deliver
such code intentionally, e.g., because the domain is controlled
by the attacker, or unintentionally, e.g., via third-party scripts
or advertisements. We assume that the attacker controls the
malicious code on the server side, and hence, can freely
modify it. In particular, they can transform the source code,
split one file into multiple files, or merge multiple code files.
On the defense side, we assume a static malware detector
that scans the client-side code of a web application before it
executes in the browser. The mechanism the malware detector
uses to intercept and check the code is irrelevant to us. For
example, it may be implemented as a network proxy that scans
Authorized licensed use limited to: Tsinghua University. Downloaded on August 07,2022 at 12:59:50 UTC from IEEE Xplore.  Restrictions apply. 
21575
and raw byte memory. In addition, WebAssembly only has
limited control-flow instructions that do not fully replicate
all available JavaScript constructs, such as try/catch state-
ments, for-of loops, and Promises. Another challenge is the
limited data types that can be passed between WebAssembly
and JavaScript. In the initial version of WebAssembly, func-
tions can only accept and return numeric data types, which
cannot replicate the complex objects that JavaScript supports.
Finally, different browsers can impose file-size limits on the
WebAssembly modules used, so we must workaround this
limitation for our technique to be general.
Because of these and other differences, Wobfuscator is
based not on complete but opportunistic translation,
i.e.,
transforming code where it helps to evade malware detectors,
without sacrificing correctness.
B. Transformations
The goal of our approach is to generate WebAssembly
modules that can reproduce the functional behavior of specific
JavaScript code snippets. To produce these modules, Wobfus-
cator is constructed on a core set of transformation rules:
Definition 1 (Transformation rule). A transformation rule is
a tuple (L, t, p) where:
• L represents a set of code locations where the transfor-
mation may apply,
• t is a transformation function that maps JavaScript at a