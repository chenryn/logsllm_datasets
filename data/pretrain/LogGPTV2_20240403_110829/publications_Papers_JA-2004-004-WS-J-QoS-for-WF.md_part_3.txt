corresponds to the use of functions similar to the ones previously defined for tasks’ QoS
(see Table 3).
The initialization of tasks QoS metrics and the initialization of stochastic information
indicating the probability of transitions being fired at runtime give the necessary data to
carry out the QoS computation of workflows. The QoS computation is investigated in the
next section.
6 Workflow QoS Computation
Once QoS estimates for tasks and for transitions are determined, we can compute overall
workflow QoS. We describe a mathematical modeling technique that can be used to
compute QoS metrics for a given workflow process.
6.1 Mathematical Modeling
To compute QoS metrics for workflows based on task’s QoS metrics we have developed
the Stochastic Workflow Reduction (SWR) algorithm (Cardoso 2002). The SWR
algorithm repeatedly applies a set of reduction rules to a workflow until only one atomic
task (Kochut, Sheth et al. 1999) remains. Each time a reduction rule is applied, the
workflow structure changes. After several iterations only one task will remain. When this
state is reached, the remaining task contains the QoS metrics corresponding to the
workflow under analysis.
Graph reduction rules have already been successfully used to verify the correctness of
workflows. Sadiq and Orlowska (1999) present an algorithm that employs a set of graph
reduction rules to identify structural conflicts in workflows. The algorithm starts by
removing all structures from the workflow graph that are correct. This is achieved by
iteratively applying a conflict-preserving reduction process. The reduction process
eventually reduces a structurally correct workflow to an empty graph. If the workflow is
not completely reduced, then structural conflicts exist.
In our approach, the set of reduction rules that can be applied to a given workflow
corresponds to the set of inverse operations that can be used to construct a workflow. We
14
have decided to only allow the construction of workflows which are based on a set of
predefined construction systems; this protects users from designing invalid workflows.
Invalid workflows contain design errors, such as non-termination, deadlocks, and spliting
of instances (Aalst 1999).
Additional reduction rules can be developed. We have decided to present the reduction
concept with only six reduction rules, for three reasons. The first reason is because a vast
majority of workflow systems support the implementation of the reduction rules
presented. A study on fifteen major workflow systems (Aalst, Barros et al. 2000) show
that most systems support, the reduction rules presented. The study does not discuss
network patterns. The network pattern is intended to provide a structural and hierarchical
division of a given workflow design into levels, in order to facilitate its understanding by
the grouping of related tasks into functional units. The second reason is that the reduction
rules are simple, making it easy to understand the idea behind the workflow reduction
process. The last reason is that these rules are supported by the METEOR workflow
management system and form a basic set of rules that should be supported by any modern
workflow system.
The algorithm uses a set of six distinct reduction rules: (1) sequential, (2) parallel, (3)
conditional, (4) fault-tolerant, (5) loop, and (6) network.
Reduction of a Sequential System. Figure 3 illustrates how two sequential workflow
tasks t and t can be reduced to a single task t . In this reduction, the incoming transitions
i j ij
of t and outgoing transition of tasks t are transferred to task t .
i j ij
t t t
i j ij
(a) (b)
Figure 3 - Sequential system reduction
This reduction can only be applied if the following two conditions are satisfied: a) t is
i
not a xor/and split and b) t is not a xor/and join. These conditions prevent this reduction
j
from being applied to parallel, conditional, and loop systems. To compute the QoS of the
reduction, the following formulae are applied:
T(t ) = T(t) + T(t)
ij i j
C(t )= C(t) + C(t)
ij i j
R(t ) = R(t) * R(t)
ij i j
Reduction of a Parallel System. Figure 4 illustrates how a system of parallel tasks t , t ,
1 2
…, t , an and split task t , and an and join task t can be reduced to a sequence of three
n a b
tasks t , t , and t . In this reduction, the incoming transitions of t and the outgoing
a 1n b a
transition of tasks t remain the same. The only outgoing transitions from task t and the
b a
only incoming transitions from task t are the ones shown in the figure below.
b
15
t
1
* *
t t t t t t
a 2 b a 1n b
t
n
(a) (b)
Figure 4 - Parallel system reduction
The QoS of tasks t and t remain unchanged. To compute the QoS of the reduction the
a b
following formulae are applied:
T(t ) = Max {T(t)}
1n I∈{1..n} i
∑
C(t ) = C(t)
1n i
1≤i≤.n
∏
R(t ) = R(t)
1n i
1≤i≤.n
Reduction of a Conditional System. Figure 5 illustrates how a system of conditional
tasks t , t , …, t , a xor split (task t ), and a xor join (task t ) can be reduced to a sequence
1 2 n a b
of three tasks t , t , and t . Task t and task t do not have any other outgoing transitions
a 1n b a b
and incoming transitions, respectively, other than the ones shown in the figure. In this
reduction the incoming transitions of t and outgoing transition of tasks t remain the
a b
same
t
1
p
a1
+ p a2 +
t t t t t t
a 2 b a 1n b
p
an
t
n
(a) (b)
Figure 5 - Conditional system reduction
The QoS of tasks t and t remain unchanged. To compute the QoS of the reduction the
a b
following formulae are applied:
16
∑
T(t ) = p * T(t)
1n ai i
1≤i≤.n
∑
C(t ) = p * C(t)
1n ai i
1≤i≤.n
∑
RR((tt )) == p * R(t)
11nn ai i
1≤i≤.n
Reduction of a Loop System. Loop systems can be characterized by simple and dual
loop systems. Figure 6 illustrates how a simple loop system can be reduced. A simple
n
loop system in task t can be reduced to a task t . In this reduction, p +∑p =1.
i li i oi
i=1
Once the reduction is applied, the probabilities of the outgoing transitions of task t are
li
p n
changed to p = ok , and ∑ p =1. In the reduction of a loop system the loop is
lk 1-p lk
i k=1
removed. Since the loop is removed we need to update the remaining outgoing
transitions. Therefore, the probability of each outgoing transition needs to be divided by
the probability of the loop not being followed (i.e., 1-p).
i
p
i
+ t i +p o1 + t + p l1
li … … … …
p p
(a) on (b) ln
Figure 6 – Simple loop system reduction
To compute the QoS of the reduction the following formulae are applied:
T(t )
T(t ) = i
li
1-p
i
C(t )
C(t ) = i
li
1-p
i
(1-p )*R(t )
R(t ) = i i
li
1-pR(t )
i i
Figure 7 illustrates how a dual loop system can be reduced. A dual loop system
composed of two tasks t and t can be reduced to a single task t . In this reduction,
i j ij
17
n
p+∑p =1. Once the reduction is applied, the probabilities of the outgoing transitions
i oi
i=1
p n
of task t are changed to p = ok and ∑ p =1.
ij lk 1-p lk
i k=1
t
j
p
j
+ t +p o1 + + p l1
i t
ij … … … …
p p
(a) on (b) ln
Figure 7 – Dual loop system reduction
To compute the QoS of the reduction the following formulae are applied:
T(t )+T(t )−(1-p )T(t )
i j j j
T(t ) =
ij
(1-p )
j
C(t )+C(t )−(1-p )C(t )
i j j j
C(t ) =
ij
(1-p )
j
(1-p )*R(t )
j i
R(t ) =
ij
1-p R(t )R(t )
j i j
Reduction of a Fault-Tolerant System. Figure 8 illustrates how a fault-tolerant system
with tasks t , t , …, t , an and split (task t ), and a xor join (task t ) can be reduced to a
1 2 n a b
sequence of three tasks t , t , and t . The execution of a fault-tolerant system starts with
a 1n b
the execution of task t and ends with the completion of task t . Task t will be executed
a b b
only if k tasks from the set {t , t , …, t } are executed successfully. In this reduction, the
1 2 n
incoming transitions of t and the outgoing transition of tasks t remain the same. The
a b
idea of this reduction system is to allow several tasks {t , t , …, t } to be executed in
1 2 n
parallel, carrying out the same function but in a different way, until k tasks have
completed their execution. For example, in genomics several algorithms can be used to
query genome databases given an initial probe. Let us assume that the tasks t , t , …, t
1 2 5
are execute in parallel and each task executes a distinct algorithm. Using a fault-tolerant
system, we can specify that the parallel execution of the tasks continues until two of them
complete their execution. In this scenario, we consider that the answers of the first two
queries to complete are sufficient for the process to continue.
18
t
1
* K
t t t t t t
a 2 b a 1n b
t
n
(a) (b)
Figure 8 – Fault-Tolerant system reduction
The QoS of tasks t and t remain unchanged. To compute the QoS of the reduction the
a b
following formulae are applied:
The function Min(s)selects the set of the k smallest numbers from the set s, and
k
functiong(x)is defined as followed:
0,x <0
g(x) = 
 1,x ≥0
T(t ) = Min({T(t ),...,T(t )})
1n 1 n
k
∑
C(t ) = C(t)
1n I
1≤i≤.n
1 1 n
R(t ) = ∑ …∑g(∑i −k)*((1−i )+(2i −1)R(t ))*...*((1−i )+(2i −1)R(t ))
1n j 1 1 1 n n n
i=0 i =0 j=1
1 n
The formula R(t ) is utilized to compute reliability and corresponds to the sum of all
1n
the probabilistic states for which at least k tasks execute successfully.
A fault-tolerant system with n tasks can generate 2n distinct probabilistic states (the
power set). The function R(t ) adds all the probabilistic states that leads to the successful
1n
execution of the fault-tolerant system (i.e. at least k tasks execute successfully).
In the formula R(t ), the summation over i , …, i generates all the possible
1n 1 n
probabilistic states. Each probabilistic state is represented with a binary sequence (i …
1