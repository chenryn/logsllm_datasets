A. Method Overview
1) Data Structure: A good data structure can be more convenient for us to analyze. We introduced a data structure, the log group, as shown in “Fig. 2”.
The log group is a data structure with four attributes, including Template, Length, TemplateID, and LogIDList. In this paper, italicized and capitalized words indicate attributes. Before the logs are entered in the form of a stream, we first create an empty log group list. When log messages are continuously input, logNG will create log groups and add them to the log group list.Each attribute of the log group has its role. As the name implies, Template and Length are the log template parsed by our parser and the number of tokens. Taking the log group in “Fig. 2” as an example, Length is 4 and Template is“Verification succeeded for ”.
Fig. 2. Data Structure.2) Hierarchical Structure: logNG is divided into 4 hierar-chical structures from beginning to end, as shown in “Fig. 3”. When the raw log message is input into the logNG, it first passes through the preprocessing layer. The preprocessing layer will filter out the header information part of the raw log message first, and mark some fixed format data (such as IP address, block ID, etc.) as “”, to facilitate the subsequent parsing process.In the length layer, logNG will divide log messages into different log groups by length. Taking “Fig. 3” as an example, log messages can be divided into groups of the length less than 3, the length less than 4, and the length equal to 5 and so on.It should be noted that when the length of the log message is less than N, logNG cannot parse this kind of log message because the length is not enough. When logNG encounters this situation, it first checks whether the log group corresponding to this log message has been saved in the log group list. If so, it only adds the ID of the log message to LogIDList of the log group. If not, it creates a new log group directly.In the matching layer, logNG will make N-gram judgments on log messages and divide them into more detailed log
groups. This is because different log templates may exist in log groups of the same length.
In the update layer, logNG identifies the static text and dynamic variable parts in Template of the log group, and updates it.
Matching Layer 	Update Layer
Log Group
Template ID:1Log Group
Template ID:1 
Template:Got allocated containers 1 Length:4 
Log IDs:[1]
| Start | Preprocessing Layer | Log Group1 | Log Group1 | End | Fig. 4. The First Log Group in the Log Group List. |
|---|---|---|---|---|---|
| Start |Preprocessing Layer |Length Layer |Log Group1 |End |Fig. 4. The First Log Group in the Log Group List. |
| Start |Preprocessing Layer |Log Group2 |Log Group2 |End |D. Step 3: N-gram Matching and Update || Start |Preprocessing Layer |Length”using predefined regular expressions, such as IP address or block ID.C. Step 2: Length Judgment
When a raw log message is preprocessed, this method will divide it according to the length. A research [27] has shown that extracting log templates from log messages of the same length can easily achieve good results. If this raw log message is the first data in the log data set, then the log group list is empty. logNG directly creates a new log group and adds it to the log group list. If the log group list is not empty, compare the length of this log message with the length of all log groups. If the match is successful, add it to the log group list, otherwise create a new log group.Take “Fig. 4” as an example. The log message is “Got allocated containers 1”, and TemplateID is set to 1, and LogIDList is [1], and Length is 4, and Template is log message itself, that is, “Got allocated containers 1”. If the log group list is not empty, compare the length of the log message with Length of all log groups. If there is no log group with the same length, then directly create a new log group and add it to the log group list. If there are log groups of the same length, proceed to the next step of judgment.In this section, we will use an intuitive and simple assump-tion: If continuous multiple different tokens appear between log messages, these log messages belong to different log template. N-gram [28] must be used under this assumption. When logNG sets N to 3, we believe that when different tokens appear three times in a row between two log messages, the two log messages do not belong to the same log template. The setting of N is defined by the user. For the convenience of discussion, logNG sets N to 3.We first obtain the 3-gram lists of the log message and Template in the log group respectively. For the two 3-gram lists, we compare each pair of 3-grams one by one in order of position. We check whether each pair of 3-grams is completely different. When no pair of gram (or token) in each pair of 3-grams is the same, we think they are completely different. Note that “” is a variable, and they are different from each other by default. When two 3-gram lists have at least one pair of 3-grams that are completely different, we think that this log message does not belong to this log group, so we skip this log group and compare it with the next log group with the same length. Otherwise we think this log message belongs to this log group.“Fig. 5” shows the comparison of the two cases respectively. We bold the different parts of each pair of 3-grams. In the first case, Template is “PacketResponder 1 for block  terminating” and the log message is “PacketResponder 2 for block  terminating”. In the pair of 3-gram lists obtained by them, there are no completely different pair of 3-grams. For example, in the first pair 3-grams, although token “1” and token “2” are different, but the other parts are the same. So the first pair 3-grams are not completely different. We have reason to believe this log message belongs to this log group. 	In the second case, Template is still “PacketResponder 1 for block  terminating” and the log message is “1 failures on node MININT-FNANLI5.fareast.corp.microsoft.com”. In the pair of 3-gram lists obtained by them, the first pair of 3-grams (i.e., “PacketResponder 1 for” and “1 failures on”) are completely different, which means that this log message doesnot belong to this log group and it is no longer necessary to continue compare.
When we determine that a log message belongs to a certain log group, in addition to adding the ID of this log message to the LogIDList, we also need to update the Template. To update the log group Template is to mark the tokens that are different between the log message and the log group Template as “”.Taking the first case of “Fig. 5” as an example, only the second token(i.e., “1” and “2”) is different between the log message and Template of the log group, so we only need to replace the token in this place with “”. Finally, we get the updated log Template: ”PacketResponder “ for block  terminating”.
TABLE II 
PROPORTION OF CONTINUOUS DYNAMIC VARIABLES
| Dataset | Description | Events(2k) || Dataset | Description | Events(2k) |
|---|---|---|
| HDFS |Distributed System |14 |
| Hadoop |Distributed System |114 |
| Spark |Distributed System |36 |
| Zookeeper |Distributed System |50 |
| BGL |Supercomputer |120 |
| HPC |Supercomputer |46 |
| Thunderbird |Supercomputer |149 |
| HealthApp |Mobile System |75 |
| Apache |Server Application |6 |
| Proxifier |Standalone Software |8 |
TABLE IIITABLE III 
PARSING ACCURACY OF LOG PARSING METHODS