栈
栈
,id)
输人
图4-30有关过程调用和数组引用的产生式
689
parameter_list
expr_list
expr_list
epr
ecpr
, id )...
else ...$
输人
输人
十
K
↓
id ( erpr.list )
parameter
parameter_list，parameter
erpr := erpr
第 4章
口
口
---
## Page 169
是 LR 的。
分析器，它总是能够在某文法的最右句型的句柄出现在栈顶时识别出这个句柄，那么这个文法京
4.6.1
决定时向前看k个输人符号。k=0 和=1 这两种情况具有实践意义，因此这里我们将只考虑
4.6LR 语法分析技术介绍：简单LR 技术
器
器状态。我们可以使用这些状态分离出语法分析冲突的源头。
析器自动生成工具构造得到的，但对基本概念有所了解仍然是有益的。我们首先介绍“项”
方法。
k≤1的情况。当省略（k)时，我们假设k=1。
对输人进行从左到右的扫描，“R”表示反向构造出一个最右推导序列，而k表示在做出语法分析
习 4.5.1。
就称为 LR 文法(LR grammar)。直观地讲，只要存在这样一个从左到右扫描的移人－归约语法
语法分析
中。
LR 语法分析器是表格驱动的，在这一点上它和4.4.4节中提到的非递归LL语法分析器很相
4.7节将介绍两个更加复杂的方法一
 本节将介绍LR语法分析的基本概念，同时还将介绍最简单的构造移人－归约语法分析器的
目前最流行的自底向上语法分析器都基于所谓的LR(l)语法分析的概念。其中，“L”表示
LR 语法分析技术很有吸引力,原因如下：
2）练习4.5.2的文法的串ααα *α++。
·可以使用 LR 方法进行语法分析的文法类是可以使用预测方法或LL方法进行语法分析的
1）练习4.5.1的文法的串000111。
练习4.5.3：对于下面的输人符号串和文法，说明相应的自底向上语法分析过程。
3） aaa * a ++
2) SS+α*α +
1) SSS+α* +
练习4.5.2:对于练习 4.2.1 的文法 S→S S+丨S S＊1α和下面各个最右句型，重复练
2) 00S11
?
1) 000111
这个方法称为“简单LR技术”（或简称为 SLR)。虽然LR语法分析器本身是使用语法
只能向前看该产生式右部推导出的串的前k个符号。因此，LR 文法能够比 LL 文法描述
比 LL(h)文法的要求宽松很多。对于 LL(k)文法，我们在决定是否使用某个产生式时
的右部时，我们再向前看k个符号就可以决定是否使用这个产生式进行归约。这个要求
文法类的真超集。一个文法是 LR(h)的条件是当我们在一个最右句型中看到某个产生式
-个 LR 语法分析器可以在对输人进行从左到右扫描时尽可能早地检测到错误。
他更原始的移入－归约方法(见参考文献)一样高效。
LR语法分析方法是已知的最通用的无回溯移人－归约分析技术，并且它的实现可以和其
见的程序设计语言构造都可以避免使用这样的文法。
造出识别该构造的LR 语法分析器。确实存在非LR 的上下文无关文法，但一般来说，
对于几乎所有的程序设计语言构造，只要能够写出该构造的上下文无关文法，就能够构
为什么使用LR 语法分析器
一规范 LR 和 LALR。它们被用于大多数的 LR 语法分析
就
文
和
分
---
## Page 170
的对应的自动机显示在图4-31中。我们将把它用做讨论规范 LR(0)项集族的连续使用的例子。
确地说，这个LR(0)自动机的每个状态代表了规范LR(0)项集族中的一个项集。表达式文法(4.1)
自动机的基础。该自动机可用于做出语法分析决定。这样的有穷自动机称为LR(O）自动机。更明
XYZ 归约为 A了。
一个能从 YZ 推导得到的串。项A→XYZ·表示我们已经看到了产生式体 XYZ，已经是时候把
分。比如，项A→·XYZ 表明我们希望接下来在输人中看到一个从 XYZ 推导得到的串。项
产生式A→E 只生成—-个项 A→·
生了四个项：
项(简称为项)是G的一个产生式再加上一个位于它的体中某处的点。因此，产生式A→XYZ产
置，从而做出移人－归约决定。这些状态代表了“项”（item)的集合。一个文法G的一个LR(0)
确的动作是移人而不是将 T归约到E呢？
的内容为$T而下一个输入符号是＊时，语法分析器是怎么知道位于栈顶的T不是句柄，因此正
4.6.2项和LR(0)自动机
详细的诊断消息。
从左到右扫描时进行语法分析的构造，那么语法分析器生成工具将对这些构造进行定位，并给出
输人，自动生成一-个该文法的语法分析器。如果该文法含有二义性的构造，或者含有其他难以在
可用，我们将在4.9节讨论其中最常用的工具YacC。这种生成工具将一个上下文无关文法作为
我们需要一个特殊的工具，即--个LR语法分析器生成工具。幸运的是,有很多这样的生成工具
此我们不必将它们包含在这个列表中。
这些项的点位于产生式体的开始处。这些项总是可以根据项集中的其他项重新构造出来，因
可以用这些数对的列表来表示。然而,如我们将看到的，需要用到的项集通常包含“闭包"项
项可以表示为一对整数,第一个整数是基础文法的产生式编号,第二个整数是点的位置。项集
一个称为规范 LR(O)项集族(canonical LR(O）collection）的一组项集提供了构建一个确定有穷
直观地讲，项指明了在语法分析过程中的给定点上，我们已经看到了一个产生式的哪些部
-个LR 语法分析器通过维护一些状态，用这些状态来表明我们在语法分析过程中所处的位
LR 方法的主要缺点是为一个典型的程序设计语言文法手工构造 LR 分析器的工作量非常大。
154
一-个生成自底向上语法分析器的生成工具可能需要便利地表示项和项集。请注意，一个
更多的语言就-一点也不奇怪了。
项集的表示
A→XYZ
A→XY· Z
A-→X· YZ
A→·XYZ
第4章
到
---
## Page 171
例4.40
项，也就是说，如果B→是一个产生式，那么我们把B→·加人到CLOSURE(I)中。
可以从 B 推导得到，而推导时必然要应用某个B产生式。因此我们加人了各个 B产生式对应的
可能会在输人中看到一个能够从 BB 推导得到的子串。这个可从 Bβ 推导得到的子串的某个前缀
中，
项集：
要使用规则 S'→S进行归约时,输人符号串被接受。
告诉语法分析器何时应该停止语法分析并宣称接受输入符号串。也就是说,当且仅当语法分析器
是在 G中加上新开始符号 S'和产生式S"→S 而得到的文法。引人这个新的开始产生式的目的是
两个函数：CLOSURE和 GOTO。如果G是一-个以S 为开始符号的文法，那么G 的增广文法 G'就
语法分析
直观地讲，CLOSURE(I)中的项A→α·Bβ表明在语法分析过程的某点上，我们认为接下来
就将这个项加入其中。不断应用这个规则，直到没有新项可以加入到CLOSURE(I)中为止。
2）如果 A→α·BB在 CLOSURE(I)中,B→是一个产生式，并且项B→·不在 CLOSURE(I)
1）一开始，将Ⅱ中的各个项加人到CLOSURE(I)中。
如果I是文法G的一个项集，那么 CLOSURE(I)就是根据下面的两个规则从I构造得到的
项集的闭包
考虑增广的表达式文法：
41!
EET
id
+T
图4-31
表达式文法(4.1)的 LR(0）自动机
E→E.+T
accept
15
id
F→(E) |id
I*
E-→E + T1 T
↑
F→(E)..
T→T.*F
E→E+T.
155
---
## Page 172
所示。
闭包。
下项：
例4.41
X)描述了当输人为X时离开状态丫的转换。
函数用于定义一个文法的 LR(O)自动机中的转换。这个自动机的状态对应于项集，而 GOTO（I,
定义为I中所有形如[A→α·Xβ}的项所对应的项[A→αX·β}的集合的闭包。直观地讲，GOTO
于表示状态的方框的阴影部分中。
的项的集合,因为我们已知这些非内核项可以通过闭包运算重新生成。在图4-31中，非内核项位
项不可能是内核项。因此，如果我们抛弃所有非内核项，就可以用很少的内存来表示真正感兴趣
将感兴趣的各个项分为如下两类：
到I中的项 B→·列出来,只需要列出这些被加人的产生式的左部非终结符号就足够了。我们
下,不需要真的将那些被 CLOSURE 函数加人
都会被加人到这个闭包中。因此在某些情况
式被加人到的闭包中，那么所有B产生式
的项 B→·时，added[B]被设置为 true。
号。当我们为各个 B 产生式 B→ 加人对应
尔数组 added，该数组的下标是G的非终结符
现函数 closure 的一个便利方法是设置一个布
的F令我们加人F→·（E)和F→·id，然后就不再需要加入任何新的项。
在,后一个项中有一个T在点的右边，因此我们加人T→·T＊F和T→·F。接下来，位于点右边
的右边有一个E，我们加人如下的E产生式，点位于产生式体的左端：E→·E+T和E一→·T。现
_现在我们可以给出构造一个增广文法 G'的规范LR(0)项集族C 的算法。这个算法如图4-33
请注意，如果点在最左端的某个B产生
GOTO 函数
1）内核项：包括初始项S'→·S以及点不在最左端的所有项。
闭包可以按照图4-32中的方法计算。实
156
第二个有用的函数是COTO(I,X)，其中I是一个项集而X是一-个文法符号。GOTO(I,X)被
不仅如此，我们感兴趣的每一个项集都是某个内核项集合的闭包，当然，在求闭包时加人的
2）非内核项：除了 S'→·S之外的点在最左端的所有项。
下面说明一下如何计算这个闭包。根据规则（1），E'→·E被放到 CLOSURE(I)中。因为！
如果”是由一个项组成的项集l[E'一→.E］”，那么CLOSURE(I)包含了图4-31中的项集I。
如果I是两个项的集合[E'→E·］，［E→E·+T]”，那么 GOTO(I，+)包含如
F→·id 
F→·(E)
4·←
T→·T*F
E→E+·T
 SetOfItems CLOsURE(I) {
until 在某一-轮中没有新的项被加人到’中；
repeat
图4-32CLOSURE 的计算
第4章
口
一
---
## Page 173
转换到达状态10，我们压入状态 10(符号F)。
归约。当我们弹出对应于产生式体 id 的状态5后，状态7到达栈顶。因为状态7有一个F上的