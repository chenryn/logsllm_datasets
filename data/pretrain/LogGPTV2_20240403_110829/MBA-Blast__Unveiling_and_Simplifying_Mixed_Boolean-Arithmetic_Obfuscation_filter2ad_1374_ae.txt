the testbed and then use the EncodeArithmetic option in
Tigress to obfuscate these functions.
One interesting observation is that Tigress can recursively
apply MBA obfuscation transformation to generate complex
result. For example, Figure 7a shows two obfuscation trans-
formation in Tigress. By recursively applying these rules, it
translates x − y + z to a more complex MBA expression in
Figure 7b.
Our evaluation result shows that MBA-Blast successfully
simpliﬁes all of the obfuscated output from Tigress, including
these complex cases. As shown in Algorithm 1, MBA-Blast
keeps simplifying sub-linear MBA expressions, so the whole
obfuscated expression is simpliﬁed in a bottom-up way. Fig-
ure 7c shows how MBA-Blast simpliﬁes a complex MBA
expression generated by Tigress.
7.5 Solving MBA-Powered Opaque Predi-
cates
Opaque predicate is a prevalent software obfuscation tech-
nique to complicate control ﬂow. This method has been widely
adopted by obfuscation tools such as Obfuscator-LLVM [61].
Recently, deobfuscation methods based on symbolic execu-
tion [20, 62] and machine learning [63] have been proposed
to detect and reverse engineer opaque predicates in programs.
However, opaque predicates can be further protected by MBA
obfuscation to hide the static features and generate more
variants. MBA-powered opaque predicates bring new chal-
lenges to symbolic execution and machine learning based
countermeasures. First, both Backward-bounded DSE [20]
and LOOP [62] rely on SMT solvers to check whether a
predicate is opaquely true or false, but as we have shown,
SMT solvers cannot solve complex MBA expressions in a
1712    30th USENIX Security Symposium
USENIX Association
050010001500200025008-bit MBA expressions10−210−1100101102103104Z3 Solve Time (Seconds)OriginalSSPAMSyntiaMBA-Blast0500100015002000250064-bit MBA expressions10−210−1100101102103104Z3 Solve Time (Seconds)OriginalSSPAMSyntiaMBA-Blastreasonable time. Second, a large number of heterogeneous
MBA obfuscation rules can be created by the method used in
Dataset 2, so it is very hard for machine learning methods [63]
to learn the patterns of MBA obfuscation.
In this experiment, we show that MBA-Blast can assist solv-
ing MBA-powered opaque predicates. The simpliﬁed output
of MBA-Blast removes the complexity of MBA obfuscation,
hence it unleashes the power of other opaque predicate re-
verse tools. We collect commonly used opaque predicates
from existing work [20, 62] as follows.
∀x ∈ Z.
∀x ∈ Z.
x2 + x mod 2 ≡ 0
x(x + 1)(x + 2) mod 3 ≡ 0
∀x, y ∈ Z. 7y2 − 1 6= x2
∀x ∈ Z.
∀x ∈ Z.
∀x ∈ Z.
∀x ∈ Z.
(x2 + 1) mod 7 6= 0
(x2 + x + 7) mod 81 6= 0
(4x2 + 4) mod 19 6= 0
x2(x + 1)2 mod 4 ≡ 0
We apply MBA obfuscation to these predicates and create 70
variants. For example, we apply x + y → 2(x ∨ y) − (¬x ∧ y) −
(x ∧ ¬y) to x2 + x mod 2 ≡ 0 and the new opaque predicate
is:
∀x ∈ Z. 2(x2 ∨ x) − (¬x2 ∧ x) − (x2 ∧ ¬x) mod 2 ≡ 0
In our experiment, we use Z3 to solve the 70 MBA-powered
opaque predicates, but Z3 does not return any result in the
time limit of ﬁve hours. In contrast, MBA-Blast successfully
simpliﬁes all MBA-powered opaque predicates. Then we
apply Z3 to the outputs of MBA-Blast, and it solves the results
within the similar time as that in previous work. Therefore,
this experiment demonstrates that the simpliﬁcation result
from MBA-Blast helps to harness the full strength of SMT
solver-based deobfuscation methods.
7.6 MBA Usage in Real-World Malware
An interesting question is the popularity of MBA obfuscation
in real-world malware. Unfortunately, unlike binary packers
that reveal distinctive features (e.g., entropy deviation and
code-to-data ratio [23]), blindly searching the presence of
MBA obfuscation in malware binaries is a nontrivial task—
being stealthy is another advantage of MBA obfuscation. Even
so, we observe MBA integrated into commercial software
obfuscator VMProtect [9]. In this experiment, we study the
usage of MBA in the malware obfuscated by VMProtect.
VMProtect is one of the most sophisticated obfuscators that
are also widely used in malware. For example, in May 2019,
hackers infected over 50, 000 servers around the world with
cryptocurrency mining malware, whose kernel-mode rootkit
is protected by VMProtect to frustrate reverse engineers and
malware researchers [64, 65]. VMProtect translates program
Table 6: MBA in malware obfuscated by VMProtect. “N” is
the number of malware samples in each category. “# with
MBA” shows the number of samples that include MBA.
“MBA Expr” reports the number of MBA expressions detected
from the samples in each category. Avg. # of Nodes and Avg.
MBA alternation reports the average MBA complexity in each
category.
Category
Trojan
Virus
Malware
Riskware
CoinMiner
Backdoor
ADware
Rsmware
Spyware
Others
N
Size (MB)
(132) min max
12.5
15.9
15.3
24.4
9.5
6.7
6.6
9.3
10.5
0.7
0.2
0.1
0.1
0.6
2.4
0.4
0.2
0.7
0.3
0.3
36
33
33
8
7
4
4
3
2
2
# with MBA Avg. # of
MBA Expr
(157)
(105)
Nodes
Avg. MBA
Alternation
30
26
26
7
6
2
3
3
1
1
41
40
41
11
9
3
4
5
2
1
6.7
7.5
5.3
9.8
10.9
8.0
8.8
10.6
10.0
5.0
1.6
1.7
1.3
2.6
2.9
2.0
2.0
3.0
3.0
2.0
code into custom bytecode and interprets the bytecode at run
time via an embedded emulator, so that the original code never
reappears in memory. In addition, VMProtect applies MBA
obfuscation to further complicate the operations in bytecode
handlers.
To investigate the usage of MBA in VMProtect obfuscated
malware, we collect 132 samples from VirusTotal [66] by
searching the keywords “vmprotect” and “vmp”. To guar-
antee the collected samples are up-to-date, we restricted the
“Last Submission Date” from 2020/05 to 2020/09. For every
sample, we ﬁrst identify the fetch-dispatching cycle in the
virtual machine. Next, we extract the handlers that performs
various VM operations, such as addition and subtraction. By
manually inspecting the behaviors of these handlers, we ﬁnd
that MBA are used in VMProtect handlers for encoding arith-
metic and bitwise computation. For example, VMProtect uses
the following MBA to encode subtraction:
x − y = ¬(¬x + y) ∧ ¬(¬x + y)
Table 6 summarizes the collected VMProtect malware sam-
ples and the detected MBA with complexity metrics. Among
the 132 malware samples, we identify 157 MBA expressions
in 105 samples from different categories. It indicates that
MBA widely exist in diverse types of VMProtect malware,
from traditional Trojan and virus to modern ransomware and
spyware. Appendix A shows more complex MBA samples
collected from these malware.
For all the MBA expressions identiﬁed from malware sam-
ples, MBA-Blast successfully simpliﬁes them to a concise,
human-readable form. For example, the following procedure
shows how MBA-Blast simpliﬁes the obfuscated expression
above on the right side of the equation and produces the re-
sult x − y. We also run Z3 to verify the correctness of the
simpliﬁcation result. This experiment shows that MBA-Blast
USENIX Association
30th USENIX Security Symposium    1713
can effectively simplify the MBA in virtualization obfuscated
malware so that malware analysts are released from tedious
manual reverse engineering.
¬(¬x + y) ∧ ¬(¬x + y)
= ¬t ∧ ¬t
(¬x + y → t)
of obfuscated malware.
(K ∨ ¬C) + (¬K ∨C) − 2 ∗ (¬(K ∨C)) − 2 ∗ (K ∧C)
= −C + K ∧C − 1 + (−K + K ∧C − 1)−
2(−K −C + K ∧C − 1) − 2(K ∧C)
= K +C − 2(K ∧C)
= K ⊕C
= −t − t + t ∧ t − 1
= −t − 1
= −(¬x + y) − 1
= −(−x − 1) − y − 1
= x − y
(t → ¬x + y)
7.8 Performance
7.7 Case Study: Ransomware Analysis
This section presents our experience of using MBA-Blast
to analyze a ransomware sample1collected from VirusTotal.
Since MBA obfuscation can transform bitwise operations
to complex forms with trivial runtime overhead, it is well
suited for obfuscating crypto algorithms. Ransomware is an
infamous malware type that intensively relies on crypto al-
gorithms to encrypt the victims’ ﬁles. We run the collected
ransomware sample in a sandbox and set up Intel Pin [67] to
record the ransomware execution. After that, we investigate
the recorded trace and identify suspicious MBA transforma-
tions. This ransomware encrypts users’ ﬁles using AES-256
algorithm and shreds ﬁles before removing them from disk.
In the record trace, we observe a suspicious MBA behavior
happening before entering the AES algorithm, so we doubt
that the MBA transformation is related to key generation or
initialization vector (IV). By carefully reverse engineering
the binary code, we understand the ransomware’s behavior
and conﬁrm that the malware developer adopts MBA to ob-
fuscate both the encryption key and IV. More speciﬁcally,
the ransomware generates a key and an IV for every ﬁle it
encrypts, and then it appends the key and IV to the end of ﬁle
after encryption. After the victim pays ransom to the malware
developer, a decryption process is invoked to extract the key
and IV from every ﬁle for decryption. Malware authors must
protect the key and IV, otherwise victims can obtain them
and then recover their ﬁles by running AES-256 decryption
algorithm without paying ransom. We observe an MBA ex-
pression taking the encryption key K and a constant C as
inputs, and then use MBA-Blast to simplify it. The MBA and
MBA-Blast’s simpliﬁcation procedure is listed as follows.
The ﬁnal simpliﬁcation result is K ⊕ C. Therefore, the mal-
ware developer hides the encryption key by calculating ⊕
with a magic number C. MBA obfuscation is adopted for pro-
tecting the ⊕ operation. Similarly, we discover that the IV is
also protected by ⊕ with a different constant. This case study
shows that, although MBA-Blast is not particularly designed
as a malware analysis tool, it can help understand behaviors
1MD5: 218ee40649267be13d85c6ff0a91b603
This section shows MBA-Blast’s performance data. Table 7
presents the time and memory cost when MBA-Blast pro-
cesses MBA expressions with different complexity level.
MBA-Blast is very effective because it does not rely on any
search or heuristic method. Our implementation is based on
AST and SymPy Python library, which can perform expres-
sion substitution and arithmetic reduction efﬁciently. Overall,
MBA-Blast only introduces a negligible overhead.
Table 7: MBA-Blast’s performance on MBA expressions with
different complexity.
# of Nodes Time (Second) Memory (MB)
10
100
200
300
0.0128
0.0528
0.0964
0.1358
0.2
0.5
0.6
0.7
8 Discussion
MBA-Blast demonstrates the feasibility and scalability of au-
tomatically reducing complex MBA expressions. However,
we also note some potential opportunities for future improve-
ment as below.
First, the simpliﬁcation result from MBA-Blast may not
be the simplest form. The normal output form is c1x + c2y +
c3(x ∧ y) − c4. While it does signiﬁcantly reduce the MBA
complexity, this form is not guaranteed as the simplest result.
Table 4 has provided one example. The ReplaceMBAWith-
Bool function alleviates this problem by reversely applying
the transformation in Table 2. MBA-Blast can be further
extended to mitigate this problem by adding more rules in
Table 2 so that it can produce more diverse simpliﬁcation
result.
Similarly, an adversary may attack MBA-Blast by inten-
tionally applying multiple rounds of MBA substitution. The
correct simpliﬁcation requires precisely understanding the
dependency between these rounds. Current MBA-Blast im-