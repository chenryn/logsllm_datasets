number of matches to responses in our more general Internet-wide
SNMPv3 scans described previously.
In IPv4 the ITDK dataset contains 2.9M router IPs with 447k of
those responsive to our SNMPv3 measurements. RIPE Atlas adds
a few thousand additionally tagged router IPs, bringing our total
known SNMPv3 responsive router IPs to 461k.
In IPv6 we find that ITDK Speedtrap and RIPE Atlas tracer-
outes each cover about 36k SNMPv3 addresses. The vast corpus of
IPv6 router addresses from the IPv6 Hitlist Service contains many
Customer Premise Equipment (CPE) device addresses which are
frequently changing [23], thus leading to this large size. With this
dataset we obtain the highest SNMPv3 overlap with more than 54k
IPv6 addresses. The union of all IPv6 router addresses leads to an
overlap of more than 78k SNMPv3 addresses, i.e., more than half of
all addresses with either valid engine ID or engine time (see below).
formats. Almost 60% of engine IDs for IPv4 and IPv6 are MAC-based.
The use of MAC addresses provides a strong unique identifier and
the high share of this engine ID format is therefore crucial for the
uniqueness of engine IDs. In IPv4, opaque byte strings (“Octets”),
non-SNMPv3-conforming, and Net-SNMP-specific engine ID for-
mats contribute 10-20% each. The non-SNMPv3-conforming engine
IDs do not contain any format information but rather just the
byte values (e.g., 0x0300e0acf1325a88). Similarly, the SNMPv3-
conforming Octets format also contains raw bytes values (e.g.,
0x3910910680002970). Net-SNMP on the other hand, is a pop-
ular software-based SNMP implementation [45], which uses an
enterprise-specific format (e.g., 0x0f010e3732bed25e00000000).
For IPv6 we also find a relatively high share of non-SNMPv3-
conforming engine IDs, and a rather low number of Octets and
Net-SNMP formats. Interestingly, we find more than 15% of engine
IDs collected in our IPv6 measurements contain IPv4 addresses.
These might reveal IPv4-IPv6 dual-stack deployments, which we
investigate in detail in Section 5.
To better understand the randomness of Octets and Non-SNMPv3-
conforming, which is crucial to their ability to serve as fingerprint-
ing identifiers, we analyze their Hamming weight distribution. Fig-
ure 6 shows the relative Hamming weight distribution for both
formats. The Hamming weight can be used as an indicator of ran-
domness. Thus, the expectation of a randomly generated number
would have half of its bits set to ‘1’ and the other half set to ‘0’.
The number of ones, i.e., the Hamming weight, for a large set of
randomly generated numbers is therefore distributed according
to the normal distribution N with a mean around half the length
of the bit string. To meaningfully compare Hamming weights of
4.2 Engine ID
To identify an SNMP agent, the protocol uses the engine ID as
defined by RFC 3411 [29]. In our measurements we collect 18.8M
different engine IDs for IPv4 and 68k for IPv6. Many SNMP devices
have more than one IP address assigned to them (e.g., because
they are routers). As such we see the same engine ID for different
IP addresses. Figure 4 shows the distribution of the number of IP
addresses per engine ID for IPv4 and IPv6. In IPv4 more than 80% of
engine IDs are seen on a single IP address. The same is true for more
than half of all engine IDs collected with our IPv6 measurements.
We find that the distribution is heavy-tailed, with the vast majority
of all engine IDs being seen on 10 or fewer IPs, with some outliers
with a single engine ID for more than 1000 IPs (not shown).
The engine ID can be in different formats, e.g., a device’s MAC
address, IP address, a text string, a byte string, or a vendor-defined
format. In Figure 5 we show the distribution of different engine ID
Figure 4: Number of occurrences per engine ID.
154
100101102Number of IPs per engine ID0.00.20.40.60.81.0ECDF: Fraction of engine IDsIPv4IPv6IMC ’21, November 2–4, 2021, Virtual Event, USA
Taha Albakour et al.
Figure 5: Distribution of different engine ID formats for IPv4
and IPv6 scans.
Figure 6: Relative Hamming weight distribution of Octets
engine IDs and non-SNMPv3-conforming engine IDs.
variable-length bit strings, we choose to display the relative Ham-
ming weight, i.e., the fraction of bits set to ‘1’. As Figure 6 shows, the
relative Hamming weight of the Octets format is centered around
the mean of 0.5, indicating a mostly random source behind the
generation of these engine IDs. Non-SNMPv3-conforming engine
IDs on the other hand seem to be distributed on not completely
random input, as the relative Hamming weight distribution has a
positive skew, i.e., more engine IDs with this format have fewer
than expected bits set to ‘1’. For this reason, we apply a series of
filters, which increase the confidence in the uniqueness of SNMP
engine IDs. Note that randomly generated engine IDs can still be
persistent (i.e., they remain the same for every query) and in fact
we enforce engine ID consistency in our filtering pipeline.
4.3 Engine Time and Engine Boots
In addition to the engine ID we also use the engine time and engine
boots SNMPv3 response fields for alias resolution. By subtracting
the engine time from the exact packet receive time, we can derive
the last reboot time for each responsive IP. The tuple of (last reboot
time, engine boots) serves as an additional strong identifier (cf.
Appendix B) in our alias resolution technique (cf. Section 5), while
also being useful for fingerprinting purposes (cf. Section 6).
Figure 7 shows the distribution of the last reboot time of the top
three engine IDs for IPv4 and IPv6. If those would belong to the
same device, then we would expect to see them centered around the
same time, i.e., a single device with a unique engine ID should have
the same last reboot time value. We see, however, that five of the
six most popular engine IDs have last reboot time values spanning
multiple years. One prominent reason for this engine ID reuse are
software bugs in routers, as is highlighted by our #1 IPv4 engine ID
which we find on more than 181k IPs. This artifact can be traced
back to a bug which was acknowledged by the vendor [16], resulting
in a constant MAC-based engine ID. These examples underline the
importance of using the tuple of (last reboot time, engine boots) as
a second identifier in combination with the engine ID.
4.4 Filtering Responses
We perform multiple filtering steps for all SNMPv3 responses:
Missing engine IDs. First, we remove responses with a missing
engine ID. This is mostly due to non-SNMP-compliant responses.
With this filter we remove about 5k IPv4 and 15 IPv6 responses.
Inconsistent engine IDs. In this step we merge the first and
second scans for IPv4 and IPv6, respectively. Due to inconsistent
answering behavior, likely due to devices changing IP addresses in
the interim time between our scans, we have an overlap of 30.2M
IPv4 addresses out of the 31.8M and 31.5M for the first and second
scan respectively. We remove an additional 1.4M responses which
show inconsistent engine ID values for the scans. In IPv6, 172k
out of the 182k and 180k responsive IPs are overlapping, and we
remove 557 instances of inconsistent engine ID values.
Too short engine IDs. As we rely on the uniqueness of engine IDs,
we filter responses with overly short engine IDs. We use a threshold
of four bytes, in order to keep IPv4-based engine IDs in the data set.
We ensure that IPv4 engine IDs provide enough uniqueness in the
following steps. In this step we remove about 5% for each protocol,
i.e., 1.5M for IPv4 and 10k for IPv6.
Promiscuous engine IDs. We leverage the enterprise ID, which is
part of the engine ID field and contains vendor information, to check
for promiscuous engine ID values. Specifically, we check whether
the same engine ID value is present across multiple vendors. If this
is the case we label the engine ID as promiscuous and as a result
we remove 96k IPv4 and 555 IPv6 responses.
Unroutable IPv4 engine IDs. In this filtering step we check
whether IPv4-address-based engine IDs actually contain routable
IPv4 addresses. Non-routable addresses (e.g., reserved, multicast,
private addresses) are not guaranteed to be unique, and we therefore
remove 68k IPv4 responses and and 7.8k IPv6 responses.
Unregistered MAC engine IDs. For all MAC-based engine IDs we
map the contained MAC addresses to get the associated OUI [32].
We remove 113k and 1.4k MACs without matching OUIs for IP4
and IPv6, respectively.
Zero engine time or engine boots. We remove 834k IPv4 and
9.4k IPv6 entries with zero or empty engine time or engine boots
values.
Engine time in the future. Next, we compare the engine time
value with the packet receive time. As we rely on the engine time
155
0.00.20.40.60.81.0Relative hamming weight0.000.050.100.150.20Fraction of unique engine IDsOctets formatNon-SNMPv3conformantThird Time’s Not a Charm: Exploiting SNMPv3 for Router Fingerprinting
IMC ’21, November 2–4, 2021, Virtual Event, USA
Figure 7: Distribution of the last reboot time for the top 3
engine IDs for IPv4 and IPv6.
Figure 8: Distribution of the last reboot time difference be-
tween both scans for all IPv4, IPv6, and router IPv4, IPv6
addresses.
value reflecting a real time value, we remove entries where the
engine time is in the future. In this step we remove 23k and 18 IPs
for IPv4 and IPv6, respectively.
Inconsistent engine boots. In this step we compare the engine
boots values for both scans. If they differ (e.g., because of a reboot)
we can not rely on the reset engine time value and we therefore
remove 3.8M IPv4 entries and 802 IPv6 entries.
Inconsistent last reboot time. We compare the derived last reboot
time value from both scans to check for consistency. As timekeeping
is prone to clock skew [35, 43, 52, 61] and suddenly running clock
synchronization daemons, we first analyze the difference of the last
reboot time as shown in Figure 8. As can be seen, the last reboot time
values in IPv6 overlap very consistently, while they are more spread
out in IPv4. We selectively also depict the distribution for router
IP addresses (cf. Section 4.1.2), which shows more consistent last
reboot time values. We choose a threshold of 10 seconds between
scans, at the “knee” of the IPv4 router IPs distribution. With this
last filter we remove 9.8M IPv4 addresses and 1.7k IPv6 addresses.
After this rigorous filtering pipeline we continue our analy-
sis with the remaining 12.5M IPv4 addresses and 140k IPv6 ad-
dresses. Although this is a significant decrease from the initial set
of SNMPv3-responsive IPs—especially for the more than 30M initial
IPv4 responses—we err on the side of precision by applying this
conservative filtering approach.
5 ALIAS RESOLUTION
Against the filtered IPv4 and IPv6 dataset, we run an alias reso-
lution algorithm—first for IPv4 and IPv6 separately, and then on
the combined set—to identify IP addresses belonging to the same
SNMP device. We try variations of our technique (cf. Appendix A)
and choose an approach which mimics similar thresholds as our
filtering pipeline described in the previous section. We group all
IP addresses together if they contain the same engine ID, the same
engine boots, and a very similar last reboot time for both scans. In
our filtering pipeline we select a last reboot time threshold of 10
seconds. To account for the fact that groups of IP addresses might
deviate 10 seconds each, we map the last reboot time time into 20
second bins.
5.1 IPv4 and IPv6
By grouping based on these six fields (engine ID, engine boots,
and last reboot time, for both scans respectively) we create alias
sets. This results in 4.7M alias sets for IPv4, of which 824k are
non-singletons (i.e., they contain more than one address). As a
result, more than 8.7M of the 12.5M (70%) input IPs are grouped
into non-singleton alias sets. Each alias set contains on average
10.6 IP addresses.
For IPv6, we use the same technique and end up with 59k alias
sets of which 26k are non-singleton sets. These non-singleton IPv6
alias sets contain more than 106k of the initial 140k IPv6 addresses, a
coverage of more than 75%. Due to the lower number of responsive
IPv6 addresses in our measurements, the average number of 4.2
addresses per IPv6 non-singleton alias set is smaller than in IPv4.
Finally, we also resolve dual-stack aliases (i.e., devices with IPv4
and IPv6 addresses) by applying the same alias resolution technique
on the joined IPv4 and IPv6 alias sets. After this final alias resolution
step we have 4.6M IPv4-only alias sets (i.e., alias sets containing
only IPv4 addresses), 27.7k IPv6-only alias sets, and 31.2k dual-
stack alias sets. Of those 796k, 11.3k, and 31.2k are non-singleton
alias sets. These non-singleton alias sets contain 7.4M IPv4-only
addresses (9.3 addresses per set), 49.5k IPv6-only addresses (4.4
per set), and 1.4M dual-stacked addresses (45.4 addresses). We find
that especially the high number of average addresses for dual-stack
alias sets is an impressive confirmation that our technique is able
to reliably identify enterprise routers with many interfaces.
In Figure 9 we show the distribution of IP addresses per alias set
for IPv4, IPv6, and router IPs as identified by at least one router
being part of a well-known router dataset. In contrast to overall
IPv4 and IPv6 alias sets, we find that router alias sets contain many
more addresses. This is an indicator that SNMPv3 is widely used
on routers with many IP addresses and interfaces.
5.2 Comparison with Router Names
Next we compare our identified alias sets with the CAIDA Router
Names dataset. This dataset is built using the technique from Luckie
et al. [39] by getting the reverse DNS name for IP addresses and then
156
2014201620182020Last reboot time0.00.20.40.60.81.0ECDF: Fraction oflast reboot timesIPv4 #1IPv4 #2IPv4 #3IPv6 #1IPv6 #2IPv6 #3020406080100120Absolute difference of last reboot between scans [s]0.00.20.40.60.81.0ECDF: Fraction of IPsIPv4 all IPsIPv4 router IPsIPv6 all IPsIPv6 router IPsIMC ’21, November 2–4, 2021, Virtual Event, USA
Taha Albakour et al.
Figure 9: Distribution of the number of IP addresses per alias
set for IPv4, IPv6, and router addresses.
Figure 10: Coverage of responsive SNMPv3 router IPv4 ad-
dresses per AS.
using regular expressions to group routers together. Specifically,
we obtain the per-domain suffix regular expressions (“regexes”)
created by CAIDA and derived from their most recent March 2021
ITDK topology. These regexes extract the hostname from a com-
plete PTR record to identify the router; multiple interfaces with
a common hostname are then assumed to be aliases of the same
router. Conservatively, we only use regexes where their algorithm
produced a positive predictive value of 0.8 or higher.
We apply each suffix’s regex to the IPv4 and IPv6 interface PTR
records available in the March 2021 CAIDA ITDK. Note that not all