对于C++米说，ABI问题就更为严重了。由于C++非常复杂，它支持诸如模板等一些高
级特性，这些特性对于ABI兼容来说简直就是灾难。因为C++标准对于C++的ABI没有做
出规定，所以不同的编译器甚至同-个编译器的不同版本对于C++的一些特性的实现都有着
各自的方案，而且相互不兼容，比如虚函数表、模板实例化、多重继承等。对于Linux来说，
程序员的自我修养一链接、装载与库
---
## Page 255
232
第8章Linux共享库的组织
如果你要开发一个导出接口为C++的共享库（当然我十分不推荐这么微，使用C的接口会
让事情变得简单得多），需要注意以下事项，以防止ABI不兼容（完全遵循以下准则还是不
能保证ABI完全兼容）：
·不要在接口类中使用虚函数，万不得已要使用虚函数时，不要随意删除、添加或在子
类中添加新的实现函数，这样会导致类的虚函数表结构发生变化。
·不要改变类中任何成员变量的位置和类型。
·不要删除非内嵌的public或protected 成员函数。
·不要将非内嵌的成员函数改变成内账成员函数。
·不要改变成员函数的访问权限。
·不要在接口中使用模板。
·最重要的是，不要改变接口的任何部分或干脆不要使用C++作为共享库接口！
8.1.2共享库版本命名
既然共享库存在这样那样的兼容性问题，那么保持共享库在系统中的兼容性，保证依赖
于它们的应用程序能够正常运行是必须要解决的间题。有儿种办法可用于解决共享库的兼容
性问题，有效办法之一就是使用共享库版本的方法。Linux有一套规则来命名系统中的每一
个共享库，它规定共享库的文件名规则必须如下：
libname.8o.x.y.2
最前面使用前缓“lib”、中间是库的名字和后缓“so”，最后面跟着的是三个数字组成
Number），“z”表示发布版本号（ReleaseVersionNumber），三个版本号的含文不一样。
主版本号表示库的重大升级，不间主版本号的库之间是不兼容的，依赖于旧的主版本号
的程序需要改动相应的部分，并且重新编译，才可以在新版的其享库中运行：或者，系统必
须保留旧版的共享库，使得那些依赖于旧版共享库的程序能够正常运行。
次版本号表示库的增量升级，即增加一些新的接口符号，且保持原来的符号不变，在主
版本号相同的情况下，高的次版本号的库向后兼容低的次版本号的库。一个依赖于旧的次版
本号共享库的程序，可以在新的次版本号共享库中运行，因为新版中保留了原来所有的接口，
并且不改变它们的定文和含义。比如系统中有个共享库为libfoo.so.1.2.x，后来在升级过程中
添加了一个函数，版本号变成了1.3.x。因为1.2.x的所有接口都被保留到1.3.x中了，所以
那些依赖于1.1.x或1.2.x的程序都可以在1.3.x中正常运行。
发布版本号表示库的一些错误的修正、性能的改进等，并不添加任何新的接口，也不对
程序员的自我修养一链接、装载与库
---
## Page 256
8.1共享库版本
233
接口进行更改。相同主版本号、次版本号的共享库，不同的发布版本号之间完全兼容，依赖
于某个发布版本号的程序可以在任何一个其他发布版本号中正常运行，而无须做任何修改。
当然现在Linux中也存在不少不遵守上述规定的“顽固分子”，比如最基本的C语言库
Glibc就不使用这种规则，它的基本C语言库使用libc-x.y.z.so这种命名方式。Glbc
有许多组件，C语言库只是其中一个，动态链接器也是Glibc的一部分，它使用
Id-x.y.z.so 这样的命名方式，还有Gibc的其他部分，比如数学库Ibm、运行时装载
库libdl 等。
Reference: Library Interface Versioning in Solaris and Linux
/http://www.usenix: org/publications/ibrary/proceedings/als00/2000papers/papers/ful
papers/browndavid/browndavid_html/
这篇论文对Salaris和Linux的共享库版本机制和符号版本机制做了非常详细的介绍。
8.1.3SO-NAME
程序需要记录什么
可以这么说，共享库的主版本号和次版本号决定了一个共享库的接口，那么从一个可执
行程序的角度看，如何表示它依赖于哪些版本的哪些共享库？或者说在运行时，动态链接器
怎样知道程序依赖于哪些共享库，它们的版本号又是什么？
我们假设程序中有一个它所依赖的共享库的列表，其中每一项对应于它所依赖的一个共
享库。可以肯定的是，程序中必须包含被依赖的共享库的名字和主版本号，因为我们知道不
同主版本号之间的共享库是完全不兼容的，所以程序中保存一个诸如libfoo.so.2的记录，以
防止动态链接器在运行时意外地将程序与libfoo.so.1或libfoo.so.3链接到一起。通过这个可
以发现，如果在系统中运行旧的应用程序，就需要在系统中保留旧应用程序所需要的旧的主
版本号的共享库。
SO-NAME
对于新的系统来说，包括Solaris和Linux，普遍采用一种叫做SO-NAME的命名机制来
记录共享库的依赖关系。每个共享库都有一个对应的“SO-NAME”，这个SO-NAME即共
享库的文件名去掉次版本号和发布版本号，保留主版本号，比如一个共享库叫做
ibfoo.so0.2.6.1，那么它的 SO-NAME 即 libfoo.so.2。很明显，“SO-NAME”规定了共享库的
接口，“SO-NAME”的两个相同共享库，次版本号大的兼容次版本号小的。在Linux系统中，
（SymbolLink）。比如系统中有存在一个共享库“/Aib/ibfoo.so.2.6.1°，那么Linux中的共享
程序员的自我修养一链接、装载与库
---
## Page 257
234
第8章Linux共享库的组织
享库：
$ 18 -1 /1ib/1ibc*
-rmxr-xr-x 1 root root 1249520 2007-10-25 09:03 1ibc-2.6.1.80
1rwxrwxrwx 1root root
13 2007-11-10 15:49 1ibc.so.6 -> 1ibc-2.6 .1.80
由于历史原因，动态链接器和C语言库的共享对象文件名规则不按Linux标准的共享
库命名方法，但是C语言的 SO-NAME还是按照正常的规则：Glibc的 C语言库
libc-2.6.1.so，它的SO-NAME是libc.so.6：为了“彰显”动态连接器的与众不同，
它的SO-NAME命名也不按照普通的规则，比如动态链接器的文件名是Id-2.6.1.so，
它的 SONAME 是 Idlinux.SO。
中主版本号相问、次版本号和发布版本号最新的共享库。也就是说，比如目录中有两个共享
库版本分别为：/lib/libfoo.so.2.6.1和/lib/libfoo.2.5.3，那么软链接/lib/libfoo.so.2会指向
/ib/libfoo.so.2.6.1.这样保证了所有的以SO-NAME为名的软链接都指向系统中最新版的共
享库。
建立以SO-NAME为名字的软链接目的是，使得所有依赖某个共享库的模块，在编译、
链接和运行时，都使用共享库的SO-NAME，而不使用详细的版本号。我们在前面介绍动态
字段值该如何表示B这个文件呢？如果保存的是B的文件名，即包含次版本号和发布版本
号，那么会有什么问题呢？很直接的问题是，这个文件A只能依赖于某个特定版本的B。
比如程序A依赖于C语言库，它在编译时，系统中存在的C语言库版本是/ib/ibc-2.6.1.s0，
统将C语言库版本升级至2.6.2或2.7.1时，系统必须保留原来的2.6.1的共享库，否则这个
这个程序A就无法正常运行。
但是我们知道，因为根据Linux的共享库版本规定，实际上2.6.2或2.7.1版本的共享库
是兼容2.6.1的，我们不需要继续保留原来的2.6.1，否则系统中将遗留大量的各种版本的共
享库，大大浪费了磁盘和内存空间。所以一个可行的方法就是编译输出ELF文件时，将被
依赖的共享库的SO-NAME保存到“.dynamic”中，这样当动态链接器进行共享库依赖文件
查找时，就会根据系统中各种共享库目录中的SO-NAME软链接自动定向到最新版本的共享
库。比如之前Lib.so的依赖文件：
程序员的自我修养一链接、装戴与库
---
## Page 258
8.2符号版本
235
$ readelf -d Lib.s0
Dynamic section at offset 0x4f4 contains 21 entries:
0x00000001 (NEEDED)
Tag
Type
Shared 1ibrary: [libc.so.6]
Name/Value
当共享库进行升级的时候，如果只是进行增量升级，即保持主版本号不变，只改变次版
本号或发布版本号，那么我们可以直接将新版的共享库替换掉旧版，并且修改SO-NAME
的软链接指向新版本共享库，即可实现升级：当共享库的主版本号升级时，系统中就会存在
多个SO-NAME，由于这些SO-NAME并不相同，所以已有的程序并不会受影响。
总之，SO-NAME表示一个库的接口，接口不向后兼容，SO-NAME就发生变化，这
是基本的原则。
Linux中提供了一个工具叫做“ldconfig”.当系统中安装或更新一个共享库时，就需要
运行这个工具，它会遍历所有的默认共享库目录，比如/lib、usr/lib等，然后更新所有的软
链接，使它们指向最新版的共享库：如果安装了新的共享库，那么ldconfig会为其创建相应
的软链接。
链接名
当我们在编译器里面使用共享库的时候（比如使用GCC的“-1”参数链接某个共享库），
我们使用了更为简洁的方式，比如需要链接一个ibXXX.so.2.6.1的共享库，只需要在编译
器命令行里面指定-IXXX即可，可省略所有其他部分。编译器会根据当前环境，在系统中的
链接名，比如C语言运行库有静态版本（libc.a）和动态版本（libc.so.x-y.z）的区别，如果
在链接时使用参数“-le”，那么链接器会根据输出文件的情况（动态/静态）来选择适合版本
默认情况），它会查找最新版本的libc.so.x.y.z
8.2符号版本
历史回顾
在一些早期的系统中，应用程序在被构建时，静态链接器会把程序所依赖的所有共享库
的名字、主版本号和次版本号都记录到最终的应用程序二进制输出文件中，在运行时，由于
动态链接器知道应用程序所依赖的共享库的确切版本号，所以兼容性问题比较容易处理。比
程序员的自我修养一链接、装载与库
---
## Page 259
236
第8章Linux共享库的组织
如在SunOS4.x中，动态链接器会根据程序的共享库依赖列表中的记录，在系统中查找相同
共享库名和主版本号的共享库：如采某个其享库在系统中存在相同主版本号不同次版本号的
多个副本，那么动态链接器会使用那个最高次版本号的副本。
动态链接器在查找共享库过程中，如果找到的共享库的次版本号高于或等于依赖列表中
的版本，那么链接器就默认共享库满足要求，因为更高次版本号的共享库肯定包含所有需要
的符号：如果找到的共享库次版本号低于所需要的版本，SunOS4.x系统的策略是向用户发
出一个警告信息，表示系统中仅有低次版本号的共享库，但运行程序还是继续运行。程序很
有可能能够正常运行，比如该程序只用了低次版本号中的接口，而没有用到高次版本号中薪
添加的那些接口。当然，程序如果用到了高次版本号中薪添加的接口而目前系统中的低次版
本号的共享库中不存在，那么就会发生重定位错误。有些采取更加保守策略的系统中，对于
这种系统中没有足够高的次版本号满足依赖关系的情况，程序将会被禁止运行，以防止出现
意外情况，
这两种策略或可能导致程序运行错误（第一种只通过警告的策略），或者会阻止那些实
际上能够运行的程序（第二种保守策略）。实际上很多应用程序在高次版本的系统中都有构
建，但实际上它只用到了低次版本的那部分接口，在采取第二种策略的系统中，如果系统中
只有低次版本号的共享库，那么这些程序就不能运行。我们可以把这个问题叫做次版本号交
会问题(Minor-revision Rendezvous Problem),
买版本号交会问题并没有因为SO-NAME而解决
动态链接器在进行动态链接时，只进行主版本号的判断，即只判断SO-NAME，如果某
个被依赖的共享库SO-NAME与系统中存在的实际共享库SO-NAME一致，那么系统就认
为接口兼容，面不再进行兼容性检查。这样就会出现一个问题，当某个程序依赖于较高的次
版本号的共享库，面运行于较低次版本号的共享库系统时，就可能产生缺少某些符号的错误。
因为次版本号只保证向后兼容，并不保证向前兼容，新版的次版本号的共享库可能添加了一
些旧版没有的符号，这种次版本号交会问题并没有因为SO-NAME的存在面得到任何改善。
对于这个问题，现代的系统通过一种更加精巧的方式来解决，那就是符号版本机制，
8.2.1基于符号的版本机制
正常情况下，为了表示某个共享库中增加了一些接口，我们就把这个共享库的次版本号
升高（表示里面添加了一些东西）。但是我们需要一种更为巧妙的方法，来解决次版本号交
会问题。Linux下的Glibc从版本2.1之后开始支持一种叫做基于符合的版本机制（Symbol
Versioning）的方案。这个方案的基本思路是让每个导出和导入的符号都有一个相关联的版
本号，它的实际做法类似于名称修饰的方法。与以往简单地将某个共享库的版本号重新命名
程序员的自我修养一链接、装载与库
---
## Page 260
8.2符号版本
237
不同（比如将 libfoo.so.1.2升级到 libfoo.so.1.3），当我们将 libfoo.so.1.2升级至 1.3 时，仍然
保持libfoo.so.1这个SO-NAME，但是给在1.3这个新版中添加的那些全局符号打上一个标
记，比如“VERS_1.3”.那么，如果一个共享库每一次次版本号升级，我们都能给那些在新
的次版本号中添加的全局符号打上相应的标记，就可以清楚地看到共享库中的每个符号都拥
有相应的标签，比如“VERS_1.1"、"VERS_1.2"、“VERS_1.3”、“VERS_1.4”。
8.2.2Solaris中的符号版本机制
这个基于符号版本的方案最早是Sun在1995年的Solaris2.5中实现的，在这个新的机
制中，Solaris 的Id链接器为共享库新增了版本机制（Versioning）和范围机制（Scoping）。
版本机制的想法很简单，也就是定义一些符号的集合，这些集合本身都有名字，比如叫
“VERS_1.1”、“VERS_1.2”等，每个集合都包含一些指定的符号，除了可以拥有符号以外，
一个集合还可以包含另外一个集合，比如“VERS_1.2”可以包含集合“VERS_1.1”，就概
念而言与其说是“包含”，不如说是“继承”，比如“VERS_1.2”的符号集合包含（继承）
那么，这些集合的定义及它们包含哪些符号是怎样指定的呢？在Solaris中，程序员可
以在链接共享库时编写一种叫做符号版本脚本的文件，在这个文件中指定这些符号与集合之
间及集合与集合之间的继承依赖关系。链接器在髓接时根据符号版本脚本中指定的关系来产
生共享库，并且设置符号的集合与它们之间的关系。
举个简单的例子，假设有个名为libstack.so.1的共享库编写的符号版本脚本文件如下：
SUNW_1.1 (
globa1 :
push;
pop;
SUNWprivate (
pop;
globa1 :
loca11
_push;
在这个脚本文件中，我们可以看到它定义了两个符号集合，分别为“SUNW_1.1”和
"SUNWprivate”（在Solaris系统中，符号的集合名通常由“SUNW”开头），第一个包含了
_do，dod
第二个集合中最后的“local:*”表示：除了上述被标识为全局的“pop”、“push”、“pop”
和“_push”这4个符号以外，共享库中其他的本来是全局的符号都将成为共享库局部符号，
程序员的自我修养一链接、装载与库
---
## Page 261
238
第8章Linux共享库的组织
也就是说链接器会把原先是全局的符号全部变成局部的，这样一来，共享库外部的应用程序
或其他的共享库将无法访问这些符号。这种方式可以用于保护那些共享库内部的公用实用函
数，但是共享库的作者又不希望共享库的使用者能够有意或无意地访问这些函数。这种方法
又被称为范围机制（Scoping），它实际上是对C语言没有很好的符号可见范围的控制机制
的一种补充，或者说是一种补教性质的措施。
假设现在这个共享库升级了，在原有的基础上添加了一个全局函数“swap”，那么新的
符号版本脚本文件可以在原有的基础上添加如下内容：
SUNW_1.2(
globa1 ;
}SUNW_1.1;
上面的脚本就表示了一个典型的向上兼容的接口：1.2版的共享库增加了一个sWap接
口，并且它继承了1.1的所有接口。那么我们可以按照这种方式，共享库中的版本序号
SUNW_1.1、SUNW_1.2、SUNW_1.3.分别表示每次共享库添加接口以后的更新，它们
依次向后继承，向后兼容。这里值得一提的是，跟在“SUNW_”前级后面的版本号由主版
本号与一个次版本号构成，这里的主版本号对应于共享库实际的SO-NAME中的主版本号。
当共享库的符号都有了版本集合之后，一个最明显的效果就是，当我们在构建（编译和
链接）应用程序的时候，链接器可以在程序的最终输出文件中记录下它所用到的版本符号集
合。值得注意的是，程序里面记录的不是构建时共享库中版本最薪的符号集合，而是程序所
依赖的集合中版本号最小的那个（或者那些），比如，一个共享库ibfoo.so.1中有6个符号
版本，从SUNW_1.1到 SUNW_1.6，某个应用程序app_foo在编译时，系统中的 libfoo.so.1
的符号版本为SUNW_1.6，但实际上app_foo只用到了最高到 SUNW_1.3集合的符号，那么
应用程序实际上依赖于SUNW_1.3，而不是SUNW_1.6。链接器会计算出app_foo所用到的