title:ATtention Spanned: Comprehensive Vulnerability Analysis of AT Commands
Within the Android Ecosystem
author:Dave (Jing) Tian and
Grant Hernandez and
Joseph I. Choi and
Vanessa Frost and
Christie Ruales and
Patrick Traynor and
Hayawardh Vijayakumar and
Lee Harrison and
Amir Rahmati and
Michael Grace and
Kevin R. B. Butler
ATtention Spanned: Comprehensive Vulnerability 
Analysis of AT Commands Within  
the Android Ecosystem
Dave (Jing) Tian, Grant Hernandez, Joseph I. Choi, Vanessa Frost, Christie Ruales, and 
Patrick Traynor, University of Florida; Hayawardh Vijayakumar and Lee Harrison, Samsung 
Research America; Amir Rahmati, Samsung Research America and Stony Brook University; 
Michael Grace, Samsung Research America; Kevin R. B. Butler, University of Florida
https://www.usenix.org/conference/usenixsecurity18/presentation/tian
This paper is included in the Proceedings of the 
27th USENIX Security Symposium.
August 15–17, 2018 • Baltimore, MD, USA
ISBN 978-1-939133-04-5
Open access to the Proceedings of the 27th USENIX Security Symposium is sponsored by USENIX.ATtention Spanned: Comprehensive Vulnerability Analysis of
AT Commands Within the Android Ecosystem
Dave (Jing) Tian∗1, Grant Hernandez1, Joseph I. Choi1, Vanessa Frost1, Christie Ruales1,
Patrick Traynor1, Hayawardh Vijayakumar2, Lee Harrison2, Amir Rahmati2,3, Michael Grace2,
and Kevin R. B. Butler1
1Florida Institute for Cybersecurity (FICS) Research, University of Florida, Gainesville, FL, USA
{daveti,grant.hernandez,choijoseph007,vfrost,cruales,traynor,butler}@uﬂ.edu
2Samsung Research America, Mountain View, CA, USA
{h.vijayakuma,lee.harrison,amir.rahmati,m1.grace}@samsung.com
3Department of Computer Science, Stony Brook University, Stony Brook, NY, USA
Abstract
AT commands, originally designed in the early 80s for
controlling modems, are still in use in most modern
smartphones to support telephony functions. The role
of AT commands in these devices has vastly expanded
through vendor-speciﬁc customizations, yet the extent of
their functionality is unclear and poorly documented. In
this paper, we systematically retrieve and extract 3,500
AT commands from over 2,000 Android smartphone
ﬁrmware images across 11 vendors. We methodically
test our corpus of AT commands against eight Android
devices from four different vendors through their USB
interface and characterize the powerful functionality ex-
posed, including the ability to rewrite device ﬁrmware,
bypass Android security mechanisms, exﬁltrate sensitive
device information, perform screen unlocks, and inject
touch events solely through the use of AT commands. We
demonstrate that the AT command interface contains an
alarming amount of unconstrained functionality and rep-
resents a broad attack surface on Android devices.
1
Introduction
Since their introduction, smartphones have offered sub-
stantial functionality that goes well beyond the ability
to make phone calls. Smartphones are equipped with a
wide variety of sensors, have access to vast quantities of
user information, and allow for capabilities as diverse as
making payments, tracking ﬁtness, and gauging baromet-
ric pressure. However, the ability to make calls over the
cellular network is a fundamental characteristic of smart-
phones. One way this heritage in telephony manifests it-
self is through the support of AT commands, which are
designed for controlling modem functions and date to the
1980s [24]. While some AT commands have been stan-
dardized by regulatory and industry bodies [35, 42], they
∗Dave began this project during an internship at Samsung Research
America.
have also been used by smartphone manufacturers and
operating system designers to access and control device
functionality in proprietary ways. For example, AT com-
mands on Sony Ericsson smartphones can be used to ac-
cess GPS accessories and the camera ﬂash [18].
While previous research (e.g., [20, 46, 47]) has demon-
strated that these commands can expose actions poten-
tially causing security vulnerabilities, these analyses have
been ad-hoc and narrowly focused on speciﬁc smartphone
vendors. To date, there has been no systematic study of the
types of AT commands available on modern smartphone
platforms, nor the functionality they enable. In effect, AT
commands represent a source of largely undocumented
and unconstrained functionality.
In this paper, we comprehensively examine the AT
command ecosystem. We assemble a corpus of 2,018
smartphone ﬁrmware images from 11 Android smart-
phone manufacturers. We extract 3,500 unique AT com-
mands from these images and combine them with 222
commands we ﬁnd through standards to create an anno-
tated, cross-referenced database of 3,722 commands. To
our knowledge, this represents the largest known repos-
itory of AT commands. We characterize the commands
based on the evolution of the Android operating system
and smartphone models and determine where AT com-
mands are delivered and consumed within different smart-
phone environments. To determine their impact, we test
the full corpus of 3,500 AT commands by issuing them
through the USB charging interface common to all smart-
phones. We execute these commands across 8 smart-
phones from 4 different manufacturers. We characterize
the functionality of these commands, conﬁrming the op-
eration of undocumented commands through disassembly
of the ﬁrmware images.
Our analysis of discovered AT commands exposes
powerful and broad capabilities, including the ability
to bypass Android security mechanisms such as SEAn-
droid in order to retrieve and modify sensitive informa-
tion. Moreover, we ﬁnd that ﬁrmware images from newer
USENIX Association
27th USENIX Security Symposium    273
smartphones reinstate AT command functionality previ-
ously removed due to security concerns, causing those
vulnerabilities to re-emerge.
In short, we ﬁnd that AT
commands accessed through the USB interface allow al-
most arbitrarily powerful functionality without any au-
thentication required. As such they present a large attack
surface for modern smartphones.
Our contributions can be summarized as follows:
• Systematic Collection and Characterization of
AT Commands. We develop regular expressions
and heuristics for determining the presence of AT
commands in binary smartphone ﬁrmware images,
extracting AT commands into an annotated database
that tracks metadata and provenance for each com-
mand. Our database and code are publicly available
at http://atcommands.org.
• Comprehensive Runtime Vulnerability Analysis.
We systematically test 13 Android smartphones and
1 tablet for exposure to the USB modem interface
and ﬁnd that 5 devices expose the modem by de-
fault while 3 other devices will do so if rooted.
Using this interface, we comprehensively test all
3,722 AT commands to determine the effect of both
standard and vendor-speciﬁc commands on indi-
vidual devices. We characterize notable classes
of commands that can cause vulnerabilities such
as ﬁrmware ﬂashing, bypassing Android security
mechanisms, and leaking sensitive device informa-
tion. We ﬁnd that new smartphone platforms reintro-
duce AT command-based vulnerabilities that were
purportedly previously patched.
• Development of Attack Scenarios and Mitiga-
tions. We demonstrate that previously-disclosed
attacks targeting the lock screen [49], which re-
quired malicious application access, can be per-
formed through a USB cable without requiring any
code on the target phone. We demonstrate that arbi-
trary touchscreen events can be injected over USB.
We discover multiple buffer overﬂow vulnerabili-
ties and commands to expose the contents of /proc
and /sys ﬁlesystems, as well as path traversal vul-
nerabilities. We even discover a method to “brick”
and “unbrick” certain phones. We also discuss how
mechanisms such as “charger” mode and SELinux
policies only partially mitigate the threat that broadly
accessible AT commands can pose to smartphone
platforms.
Figure 1: Android USB architecture diagrams. The left
shows an Android device behaving like a USB modem
when connected with a host machine and the right is an
overview of the Android USB stack.
2 Background
2.1 AT Commands
First developed by Dennis Hayes in 1981, the AT (AT-
tention) command set comprises commands that predom-
inantly start with the string “AT” [16]. The AT command
set rapidly became an industry standard for controlling
modems. It allowed for performing actions such as select-
ing the communication protocol, setting the line speed,
and dialing a number [40]. The International Telephone
Union (ITU-T) codiﬁed the AT command set over the tele-
phone network in Recommendation V.250 [35]. In the late
90s, ETSI standardized the AT command set for GSM [26]
and SMS/CBS [25], and later for UMTS and LTE [27].
Based on the Hayes and GSM AT command sets, ad-
ditional AT commands were introduced for CDMA and
EVDO [42, 43].
Manufacturers of cellular baseband processors (which
provide modem functionality in cellular devices) have
added proprietary and vendor-speciﬁc AT commands to
their chipsets [18, 34, 45]. As a result, smartphones also
support their own AT command sets and expose modem
and/or serial interfaces once connected via USB to receive
these AT commands. In some cases, these vendor-speciﬁc
AT commands are designed to be issued by software to
invoke speciﬁc functionality, (e.g., backing up contact in-
formation on a PC). These vendor-speciﬁc commands of-
ten do not invoke any functionality related to telephony,
but to access other resources on the device. Android
phone makers further extended the AT command set by
adding Android-speciﬁc commands (e.g., to enable de-
bugging over USB) to be consumed by the Android OS
running on the application processor [58]. These AT com-
mands are also usually sent over a USB connection.1
1It is also possible to send a subset of AT commands over Bluetooth,
although functionality is limited [21].
274    27th USENIX Security Symposium
USENIX Association
UDCUDC DriverUSB Gadget CDC ACM DriverApplications (APKs)/dev/ttyXYZNative DaemonsBaseband ProcessorRILModem DriverUSB Device Controller (UDC)USB Device Controller DriverAndroid Composite DriverUsbServiceUSB Gadget DriverUsbDeviceMgrUsbSettingsMgrAndroid Initinit.usb.rcsysfs (/sys/class/android_usb)Kernel SpaceUser Space2.2 USB on Android
As the most important and widely adopted peripheral in-
terface in the Android ecosystem, USB is responsible for
a number of important tasks, including battery charging,
data transmission, and network sharing with other de-
vices. To accomplish these tasks via USB, Android de-
vices support three different USB modes: host, device,
and accessory mode. USB device mode, the most com-
mon mode and our focus because of its widespread use,
is used when the phone connects to a PC and emulates
device functionality such as exposing an MTP (Media
Transfer Protocol) endpoint.
As shown in Figure 1, the Android USB implementa-
tion in device mode relies on both the Linux kernel and
the Android framework. In the kernel space, the Android
composite driver exposes a sysfs entry to user space and
interfaces with the kernel’s USB gadget driver. Different
USB functionalities (such as USB Mass Storage or MTP)
require different gadget drivers to be loaded. The gadget
driver sits above the USB controller driver, which com-
municates with the USB device controller (UDC) hard-
ware. Within the user space, the Android UsbService pro-
vides Java interfaces to applications, instantiating UsbDe-
viceManager and UsbSettingsManager to enable users to
switch between different USB functionalities. The An-
droid init daemon typically takes care of setting user-
requested USB functionality by loading an init.usb.rc
script during startup. This init script contains detailed pro-
cedures for setting functionality on the phone, essentially
writing data to the sysfs.
2.3 Android USB Modem Interface
USB Modem functionality in Android can be accessed if
the smartphone vendor exposes a USB CDC (Communi-
cation Device Class) ACM (Abstract Control Model) in-
terface from within their phones. Once enabled and con-
nected, this creates a tty device such as /dev/ttyACM0,
enabling the phone to receive AT commands over the USB
interface [47]. As shown in Figure 1, the tty device relays
AT commands to the Android user space. Vendor-speciﬁc
native daemons read from the device ﬁle, and take further
actions based on the nature of the AT command. These
daemons can handle vendor/carrier-added AT commands,
such as “AT+USBDEBUG” (enabling USB debugging)
locally, without notifying the upper layer. Otherwise,
(pre-installed) applications will be triggered to process
the commands. These AT commands are often designed
to provide shortcuts for managing, testing, and debugging
within Android. For Hayes and GSM AT commands, such
as “ATD” (which enables voice dialing), the RIL (Radio
Interface Layer) will be triggered to deliver the command
to the baseband processor.
Vendor
ASUS
Google
HTC
Huawei
LG
Lenovo
LineageOS
Motorola
Samsung
Sony
ZTE
Total
# of Firmware
# of AT Commands
210
447
55
83
150
198
199
145
373
128
30
2018
803
291
299
1122
450
1008
535
779
1251
416
696
3500
Table 1: Per vendor counts of ﬁrmware images examined
and AT commands extracted from all images.
2.4 Threat Model
Throughout the paper, we assume a malicious USB host,
such as a PC or a USB charging station controlled by an
adversary, tries to attack the connected Android phone via
USB. We assume the attacker is able to access or switch
to the possibly inactive AT interface — if available. With
access to this interface, the attacker will be able to send
arbitrary AT commands supported by the target device to
launch attacks. We assume that all of these attacks can
be fully scripted and only require a physical USB con-
nection. Additionally, we assume that Developer Options
and USB Debugging are disabled by default. During the
extraction of AT commands from ﬁrmware images, we as-
sume that the existence of AT commands in binaries and
applications are not purposefully obfuscated, encrypted
or compressed.
3 Design & Implementation
We design and implement methods to extract, ﬁlter, and
test AT commands found within the Android ecosystem.
Our procedure for acquiring these commands is shown
in Figure 2. We begin by identifying and retrieving 2,018
Android binary smartphone ﬁrmware images, covering 11
major Android cellphone vendors. The details of this cor-
pus are shown in Table 1. Next, for each ﬁrmware, we
unpack the image using a variety of tools and extract AT
command strings using a regular expression. After addi-
tional ﬁltering, we recover 3,500 unique AT commands,
many of which have differing parameter strings.2 Finally,
using this database, we evaluate the security impact of
these commands on real Android devices by setting up
an automated testing framework to send the commands to
physical Android devices and monitor any side-effects.
2We extracted a total of 7,281 AT commands when different param-
eter strings are included.
USENIX Association
27th USENIX Security Symposium    275
Figure 2: A graphical depiction of our paper’s Android ﬁrmware image processing pipeline.
3.1 AT Command Extraction
qsb splitter [6]) formats.
We ﬁrst gather Android ﬁrmware images from manufac-
turer websites and third-party hosts. For more details on
the downloading process, see Section A.3. With a corpus
of ﬁrmware images, we begin extraction and ﬁltering for
commands. We traverse each Android ﬁrmware image
as deeply as possible, recovering unique AT commands
and parameter combinations. Additionally, we also cap-
ture build information for each image from the standard
Android build properties ﬁle, build.prop. This ﬁle pro-
vides key metadata about the image itself. We also col-
lect any USB init/pre-conﬁguration ﬁles (e.g., init.usb.rc)
found in Android boot images to gain insight into the USB
modes supported by each ﬁrmware.
In order to ﬁnd AT commands present in ﬁrmware im-
ages, we look in every ﬁle for any string containing the
regular expression AT[+*!@#$%^&]. AT commands with
a symbol immediately following the ATtention string are
known as extended AT commands. Original Equipment
Manufacturers (OEMs) are free to add any amount of ex-
tended commands to their products. We focus on solely
collecting AT extended command references within these
ﬁrmware images for later categorization and testing.
Many pieces of ﬁrmware were archived using stan-
dard formats. Vendor-speciﬁc formats included: HTC’s
.exe format, unpackable using the HTC RUU Decrypt
Tool [12]; Huawei’s update.app format, unpackable using
splitupdate [10]; LG’s .kdz/.dz format, unpackable using
LGE KDZ Utilities [7]; and Sony’s .ftf format, unpack-
able using 7-Zip. Any nested archives directly under the
top-level archive (e.g., Samsung images’ several nested
tars) are similarly unpacked.
Once all ﬁles are extracted from the archives, we pro-
cess each ﬁle according to its characteristics. For native
binaries, such as ELF, we are limited to using strings
to extract all possible strings, over which we grep for
any of our target AT preﬁxes. For text-based ﬁles, grep
is applied directly to catch potential AT commands. For
ZIP-like ﬁles, we unzip and traverse the directory to ex-
amine each extracted ﬁle. ZIP-like ﬁles include yaffs (un-
packed using unyaffs [13]), Lenovo’s SZB (unpacked us-
ing szbtool [11]) and Lenovo’s QSB (unpacked using a
If the ﬁle is a VFAT or EXT4 ﬁlesystem image (e.g.,
system.img), we mount the ﬁlesystem and traverse it
once mounted to check each contained ﬁle. Filesystem
images are not always readily mountable. They may be
single or split-apart sparse Android images, which we ﬁrst
convert into EXT4 using the Android simg2img tool [9].