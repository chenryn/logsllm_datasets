* 记住使用者上次更新时间戳的方法变得更加困难，因为一个装置上执行的程式不知道另一个装置上发生了什么。需要对这些元资料进行中心化的储存。
* 如果副本分布在不同的资料中心，很难保证来自不同装置的连线会路由到同一资料中心。（例如，使用者的台式计算机使用家庭宽频连线，而移动装置使用蜂窝资料网路，则装置的网路路由可能完全不同）。如果你的方法需要读主库，可能首先需要把来自该使用者所有装置的请求都路由到同一个资料中心。
### 单调读
在从非同步从库读取时可能发生的异常的第二个例子是使用者可能会遇到 **时光倒流（moving backward in time）**。
如果使用者从不同从库进行多次读取，就可能发生这种情况。例如，[图 5-4](../img/fig5-4.png) 显示了使用者 2345 两次进行相同的查询，首先查询了一个延迟很小的从库，然后是一个延迟较大的从库（如果使用者重新整理网页时每个请求都被路由到一个随机的伺服器，这种情况就很有可能发生）。第一个查询返回了最近由使用者 1234 新增的评论，但是第二个查询不返回任何东西，因为滞后的从库还没有拉取到该写入内容。实际上可以认为第二个查询是在比第一个查询更早的时间点上观察系统。如果第一个查询没有返回任何内容，那问题并不大，因为使用者 2345 可能不知道使用者 1234 最近添加了评论。但如果使用者 2345 先看见使用者 1234 的评论，然后又看到它消失，这就会让人觉得非常困惑了。
![](../img/fig5-4.png)
**图 5-4 使用者首先从新副本读取，然后从旧副本读取。时间看上去回退了。为了防止这种异常，我们需要单调的读取。**
**单调读（monotonic reads）**【23】可以保证这种异常不会发生。这是一个比 **强一致性（strong consistency）** 更弱，但比 **最终一致性（eventual consistency）** 更强的保证。当读取资料时，你可能会看到一个旧值；单调读仅意味著如果一个使用者顺序地进行多次读取，则他们不会看到时间回退，也就是说，如果已经读取到较新的资料，后续的读取不会得到更旧的资料。
实现单调读的一种方式是确保每个使用者总是从同一个副本进行读取（不同的使用者可以从不同的副本读取）。例如，可以基于使用者 ID 的杂凑来选择副本，而不是随机选择副本。但是，如果该副本出现故障，使用者的查询将需要重新路由到另一个副本。
### 一致字首读
第三个复制延迟异常的例子违反了因果律。想象一下 Poons 先生和 Cake 夫人之间的以下简短对话：
*Mr. Poons*
> Mrs. Cake，你能看到多远的未来？
*Mrs. Cake*
> 通常约十秒钟，Mr. Poons.
这两句话之间有因果关系：Cake 夫人听到了 Poons 先生的问题并回答了这个问题。
现在，想象第三个人正在透过从库来听这个对话。Cake 夫人说的内容是从一个延迟很低的从库读取的，但 Poons 先生所说的内容，从库的延迟要大的多（见 [图 5-5](../img/fig5-5.png)）。于是，这个观察者会听到以下内容：
*Mrs. Cake*
> 通常约十秒钟，Mr. Poons.
*Mr. Poons*
> Mrs. Cake，你能看到多远的未来？
对于观察者来说，看起来好像 Cake 夫人在 Poons 先生提问前就回答了这个问题。这种超能力让人印象深刻，但也会把人搞糊涂。【25】。
![](../img/fig5-5.png)
**图 5-5 如果某些分割槽的复制速度慢于其他分割槽，那么观察者可能会在看到问题之前先看到答案。**
要防止这种异常，需要另一种型别的保证：**一致字首读（consistent prefix reads）**【23】。这个保证的意思是说：如果一系列写入按某个顺序发生，那么任何人读取这些写入时，也会看见它们以同样的顺序出现。
这是 **分割槽（partitioned）** 或 **分片（sharded）** 资料库中的一个特殊问题，我们将在 [第六章](ch6.md) 中讨论分割槽资料库。如果资料库总是以相同的顺序应用写入，而读取总是看到一致的字首，那么这种异常不会发生。但是在许多分散式资料库中，不同的分割槽独立执行，因此不存在 **全域性的写入顺序**：当用户从资料库中读取资料时，可能会看到资料库的某些部分处于较旧的状态，而某些则处于较新的状态。
一种解决方案是，确保任何因果相关的写入都写入相同的分割槽，但在一些应用中可能无法高效地完成这种操作。还有一些显式跟踪因果依赖关系的演算法，我们将在 “[“此前发生” 的关系和并发](#“此前发生”的关系和并发)” 一节中回到这个话题。
### 复制延迟的解决方案
在使用最终一致的系统时，如果复制延迟增加到几分钟甚至几小时，则应该考虑应用程式的行为。如果答案是 “没问题”，那很好。但如果结果对于使用者来说是不好的体验，那么设计系统来提供更强的保证（例如 **写后读**）是很重要的。明明是非同步复制却假设复制是同步的，这是很多麻烦的根源。
如前所述，应用程式可以提供比底层资料库更强有力的保证，例如透过主库进行某种读取。但在应用程式程式码中处理这些问题是复杂的，容易出错。
如果应用程式开发人员不必担心微妙的复制问题，并可以信赖他们的资料库 “做了正确的事情”，那该多好呀。这就是 **事务（transaction）** 存在的原因：**资料库透过事务提供强大的保证**，所以应用程式可以更加简单。
单节点事务已经存在了很长时间。然而在走向分散式（复制和分割槽）资料库时，许多系统放弃了事务，声称事务在效能和可用性上的代价太高，并断言在可伸缩系统中最终一致性是不可避免的。这个叙述有一些道理，但过于简单了，本书其余部分将提出更为细致的观点。我们将在 [第七章](ch7.md) 和 [第九章](ch9.md) 回到事务的话题，并将在 [第三部分](part-iii.md) 讨论一些替代机制。
## 多主复制
本章到目前为止，我们只考虑了使用单个主库的复制架构。虽然这是一种常见的方法，但还有其它一些有趣的选择。
基于领导者的复制有一个主要的缺点：只有一个主库，而且所有的写入都必须透过它 [^iv]。如果出于任何原因（例如和主库之间的网路连线中断）无法连线到主库，就无法向资料库写入。
[^iv]: 如果资料库被分割槽（见 [第六章](ch6.md)），每个分割槽都有一个主库。不同的分割槽的主库可能在不同的节点上，但是每个分割槽都必须有一个主库。
基于领导者的复制模型的自然延伸是允许多个节点接受写入。复制仍然以同样的方式发生：处理写入的每个节点都必须将该资料变更转发给所有其他节点。我们将其称之为 **多领导者配置**（multi-leader configuration，也称多主、多活复制，即 master-master replication 或 active/active replication）。在这种情况下，每个主库同时是其他主库的从库。
### 多主复制的应用场景
在单个数据中心内部使用多个主库的配置没有太大意义，因为其导致的复杂性已经超过了能带来的好处。但在一些情况下，这种配置也是合理的。