PackageSid: (null) 
CapabilityCount: 0
Capabilities: 0x0000000000000000 
LowboxNumberEntry: 0x0000000000000000 
Security Attributes: 
 00 Claim Name 
: WIN://SCMUserService 
    Claim Flags: 0x40 - UNKNOWN 
    Value Type 
: CLAIM_SECURITY_ATTRIBUTE_TYPE_UINT64 
    Value Count: 1 
    Value[0]   : 0 
 01 Claim Name 
: TSA://ProcUnique 
    Claim Flags: 0x41 - UNKNOWN 
    Value Type 
: CLAIM_SECURITY_ATTRIBUTE_TYPE_UINT64 
    Value Count: 2 
    Value[0]   : 102 
    Value[1]   : 352550
Process Hacker, a system tool similar to Process Explorer and available at https://processhacker.
sourceforge.io/ is able to extract the same information. 
The debugger displays several pieces of information, including the address of the associated 
security token object:
Kd: 0> !process 0n5936 1
Searching for Process with Cid == 1730
PROCESS ffffe10646205080
    SessionId: 2  Cid: 1730    Peb: 81ebbd1000  ParentCid: 0344
    DirBase: 8fe39002  ObjectTable: ffffa387c2826340  HandleCount: 313.
    Image: svchost.exe
    VadRoot ffffe1064629c340 Vads 108 Clone 0 Private 962. Modified 214. Locked 0.
    DeviceMap ffffa387be1341a0
    Token
ffffa387c2bdc060
    ElapsedTime
00:35:29.441
    ...    
To show the security attributes of the token, you just need to use the !token command fol-
lowed by the address of the token object (which internally is represented with a _TOKEN data 
_TOKEN data 
_TOKEN
structure) returned by the previous command. You should easily confirm that the process is 
hosting a user service by seeing the WIN://ScmUserService security attribute, as shown in the 
following output:
0: kd> !token ffffa387c2bdc060
_TOKEN 0xffffa387c2bdc060
TS Session ID: 0x2
User: S-1-5-21-725390342-1520761410-3673083892-1001
User Groups: 
 00 S-1-5-21-725390342-1520761410-3673083892-513
    Attributes - Mandatory Default Enabled 
...  ...
OriginatingLogonSession: 3e7
PackageSid: (null)
CapabilityCount: 0
Capabilities: 0x0000000000000000
LowboxNumberEntry: 0x0000000000000000
Security Attributes:
 00 Claim Name
: WIN://SCMUserService
    Claim Flags: 0x40 - UNKNOWN
    Value Type
: CLAIM_SECURITY_ATTRIBUTE_TYPE_UINT64
    Value Count: 1
    Value[0]   : 0
 01 Claim Name
: TSA://ProcUnique
    Claim Flags: 0x41 - UNKNOWN
    Value Type
: CLAIM_SECURITY_ATTRIBUTE_TYPE_UINT64
    Value Count: 2
    Value[0]   : 102
    Value[1]   : 352550
Process Hacker, a system tool similar to Process Explorer and available at https://processhacker.
sourceforge.io/ is able to extract the same information. 
sourceforge.io/ is able to extract the same information. 
sourceforge.io/
472 
CHAPTER 10 Management, diagnostics, and tracing
As discussed previously, the name of a user service instance is generated by combining the 
original name of the service and a local unique ID (LUID) generated by the User Manager for 
identifying the user’s interactive session (internally called context ID). The context ID for the 
interactive logon session is stored in the volatile HKLM\SOFTWARE\Microsoft\Windows NT\
CurrentVersion\Winlogon\VolatileUserMgrKey\ \\contextLuid registry 
value, where  and  identify the logon session ID and the user SID. If you 
open the Registry Editor and navigate to this key, you will find the same context ID value as the 
one used for generating the user service instance name.
Figure 10-22 shows an example of a user service instance, the Clipboard User Service, which is run 
using the token of the currently logged-on user. The generated context ID for session 1 is 0x3a182, as 
shown by the User Manager volatile registry key (see the previous experiment for details). The SCM 
then calls ScCreateService, which creates a service record in the SCM database. The new service record 
represents a new user service instance and is saved in the registry as for normal services. The service 
security descriptor, all the dependent services, and the triggers information are copied from the user 
service template to the new user instance service.
FIGURE 10-22 The Clipboard User Service instance running in the context ID 0x3a182.
As discussed previously, the name of a user service instance is generated by combining the 
original name of the service and a local unique ID (LUID) generated by the User Manager for 
identifying the user’s interactive session (internally called context ID). The context ID for the 
interactive logon session is stored in the volatile HKLM\SOFTWARE\Microsoft\Windows NT\
CurrentVersion\Winlogon\VolatileUserMgrKey\ \\contextLuid registry 
value, where  and  identify the logon session ID and the user SID. If you 
open the Registry Editor and navigate to this key, you will find the same context ID value as the 
one used for generating the user service instance name.
CHAPTER 10 Management, diagnostics, and tracing
473
The SCM registers the eventual service triggers (see the “Triggered-start services” section earlier in 
this chapter for details) and then starts the service (if its start type is set to SERVICE_AUTO_START). As 
discussed in the “Service logon” section, when SCM starts a process hosting a user service, it assigns the 
token of the current logged-on user and the WIN://ScmUserService security attribute used by the SCM 
to recognize that the process is really hosting a service. Figure 10-23 shows that, after a user has logged 
in to the system, both the instance and template subkeys are stored in the root services key represent-
ing the same user service. The instance subkey is deleted on user logoff and ignored if it’s still present 
at system startup time.
FIGURE 10-23 User service instance and template registry keys.
Packaged services
As briefly introduced in the “Service logon” section, since Windows 10 Anniversary Update (RS1), the 
Service Control Manager has supported packaged services. A packaged service is identified through the 
SERVICE_PKG_SERVICE (512) flag set in its service type. Packaged services have been designed mainly to 
support standard Win32 desktop applications (which may run with an associated service) converted to 
the new Modern Application Model. The Desktop App Converter is indeed able to convert a Win32 ap-
plication to a Centennial app, which runs in a lightweight container, internally called Helium. More details 
on the Modern Application Model are available in the “Packaged application” section of Chapter 8.
When starting a packaged service, the SCM reads the package information from the registry, and, as 
for standard Centennial applications, calls into the AppInfo service. The latter verifies that the package 
information exists in the state repository and the integrity of all the application package files. It then 
stamps the new service’s host process token with the correct security attributes. The process is then 
launched in a suspended state using CreateProcessAsUser API (including the Package Full Name at-
tribute) and a Helium container is created, which will apply registry redirection and Virtual File System 
(VFS) as for regular Centennial applications.
474 
CHAPTER 10 Management, diagnostics, and tracing
Protected services
Chapter 3 of Part 1 described in detail the architecture of protected processes and protected processes 
light (PPL). The Windows 8.1 Service Control Manager supports protected services. At the time of this 
writing, a service can have four levels of protection: Windows, Windows light, Antimalware light, and 
App. A service control program can specify the protection of a service using the ChangeServiceConfig2 
API (with the SERVICE_CONFIG_LAUNCH_ PROTECTED information level). A service’s main executable (or 
library in the case of shared services) must be signed properly for running as a protected service, follow-
ing the same rules as for protected processes (which means that the system checks the digital signature’s 
EKU and root certificate and generates a maximum signer level, as explained in Chapter 3 of Part 1).
A service’s hosting process launched as protected guarantees a certain kind of protection with 
respect to other nonprotected processes. They can’t acquire some access rights while trying to access 
a protected service’s hosting process, depending on the protection level. (The mechanism is identical 
to standard protected processes. A classic example is a nonprotected process not being able to inject 
any kind of code in a protected service.) 
Even processes launched under the SYSTEM account can’t access a protected process. However, 
the SCM should be fully able to access a protected service’s hosting process. So, Wininit.exe launches the 
SCM by specifying the maximum user-mode protection level: WinTcb Light. Figure 10-24 shows the 
digital signature of the SCM main executable, services.exe, which includes the Windows TCB Component 
EKU (1.3.6.1.4.1.311.10.3.23).
FIGURE 10-24 The Service Control Manager main executable (service.exe) digital certificate.
CHAPTER 10 Management, diagnostics, and tracing
475
The second part of protection is brought by the Service Control Manager. While a client requests an 
action to be performed on a protected service, the SCM calls the ScCheckServiceProtectedProcess rou-
tine with the goal to check whether the caller has enough access rights to perform the requested action 
on the service. Table 10-13 lists the denied operations when requested by a nonprotected process on a 
protected service. 
TABLE 10-13 List of denied operations while requested from nonprotected client 
Involved API Name
Operation
Description
ChangeServiceConfig2
Change Service 
Configuration
Any change of configuration to a protected service is denied.
SetServiceObjectSecurity
Set a new security descrip-
tor to a service
Application of a new security descriptor to a protected service 
is denied. (It could lower the service attack surface.)
DeleteService
Delete a Service
Nonprotected process can’t delete a protected service.
ControlService
Send a control code to a 
service
Only service-defined control code and SERVICE_CONTROL_
INTERROGATE are allowed for nonprotected callers.
SERVICE_CONTROL_STOP is allowed for any protection level 
except for Antimalware.
The ScCheckServiceProtectedProcess function looks up the service record from the caller-specified 
service handle and, in case the service is not protected, always grants access. Otherwise, it imperson-
ates the client process token, obtains its process protection level, and implements the following rules:
I 
If the request is a STOP control request and the target service is not protected at Antimalware
level, grant the access (Antimalware protected services are not stoppable by non-protected
processes).
I 
In case the TrustedInstaller service SID is present in the client’s token groups or is set as the
token user, the SCM grants access regarding the client’s process protection.
I 
Otherwise, it calls RtlTestProtectedAccess, which performs the same checks implemented for
protected processes. The access is granted only if the client process has a compatible protection
level with the target service. For example, a Windows protected process can always operate on
all protected service levels, while an antimalware PPL can only operate on Antimalware and app
protected services.
Noteworthy is that the last check described is not executed for any client process running with the 
TrustedInstaller virtual service account. This is by design. When Windows Update installs an update, it 
should be able to start, stop, and control any kind of service without requiring itself to be signed with a 
strong digital signature (which could expose Windows Update to an undesired attack surface).
Task scheduling and UBPM
Various Windows components have traditionally been in charge of managing hosted or background 
tasks as the operating system has increased in complexity in features, from the Service Control 
Manager, described earlier, to the DCOM Server Launcher and the WMI Provider—all of which are also 
476 
CHAPTER 10 Management, diagnostics, and tracing
responsible for the execution of out-of-process, hosted code. Although modern versions of Windows 
use the Background Broker Infrastructure to manage the majority of background tasks of modern ap-
plications (see Chapter 8 for more details), the Task Scheduler is still the main component that manages 
Win32 tasks. Windows implements a Unified Background Process Manager (UBPM), which handles 
tasks managed by the Task Scheduler.
The Task Scheduler service (Schedule) is implemented in the Schedsvc.dll library and started in a 
shared Svchost process. The Task Scheduler service maintains the tasks database and hosts UBPM, 
which starts and stops tasks and manages their actions and triggers. UBPM uses the services provided 
by the Desktop Activity Broker (DAB), the System Events Broker (SEB), and the Resource Manager for 
receiving notification when tasks’ triggers are generated. (DAB and SEB are both hosted in the System 
Events Broker service, whereas Resource Manager is hosted in the Broker Infrastructure service.) Both 
the Task Scheduler and UBPM provide public interfaces exposed over RPC. External applications can 
use COM objects to attach to those interfaces and interact with regular Win32 tasks.
The Task Scheduler
The Task Scheduler implements the task store, which provides storage for each task. It also hosts the 
Scheduler idle service, which is able to detect when the system enters or exits the idle state, and the 
Event trap provider, which helps the Task Scheduler to launch a task upon a change in the machine 
state and provides an internal event log triggering system. The Task Scheduler also includes another 
component, the UBPM Proxy, which collects all the tasks’ actions and triggers, converts their descrip-
tors to a format that UBPM can understand, and sends them to UBPM. 
An overview of the Task Scheduler architecture is shown in Figure 10-25. As highlighted by the 
picture, the Task Scheduler works deeply in collaboration with UBPM (both components run in the Task 
Scheduler service, which is hosted by a shared Svchost.exe process.) UBPM manages the task’s states 
and receives notification from SEB, DAB, and Resource Manager through WNF states. 
Powershell/WMI
Schedcli.dll
MsTask.dll
Task Scheduler 
(schedsvc.dll)
UbpmProxy
UBPM
Task Host Server (ubpm.dll)
Schedprov.dll
at.exe
Process
WmiPrvSE.exe
Process
Task Control Program
Taskschd.dll
Task
Control
Process
COM
APIs
Taskschd.dll
COM
APIs
COM
APIs
RPCs
RPCs
WNF
WNF
WNF
Task Scheduler
Configuration Tool
Taskschd.dll
Schtasks
Process
COM
RPCs
RPCs
RPCs
Task Scheduler Compat
plugin (taskcomp.dll)
Task Scheduler Service
Desktop Activity
Broker (DAB)
System Events
Broker (SEB)
Resource Manager
BrokerInfrastructure Service
System Events Broker
Service
…
Task Host Client
(taskhostw.exe)
COM Task
Non-Hosted
Task
FIGURE 10-25 The Task Scheduler architecture.
CHAPTER 10 Management, diagnostics, and tracing
477
The Task Scheduler has the important job of exposing the server part of the COM Task Scheduler 
APIs. When a Task Control program invokes one of those APIs, the Task Scheduler COM API library 
(Taskschd.dll) is loaded in the address space of the application by the COM engine. The library requests 
services on behalf of the Task Control Program to the Task Scheduler through RPC interfaces. 
In a similar way, the Task Scheduler WMI provider (Schedprov.dll) implements COM classes and 
methods able to communicate with the Task Scheduler COM API library. Its WMI classes, properties, 