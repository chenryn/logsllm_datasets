### Security Attributes and Process Information

- **PackageSid**: (null)
- **CapabilityCount**: 0
- **Capabilities**: 0x0000000000000000
- **LowboxNumberEntry**: 0x0000000000000000
- **Security Attributes**:
  - **Claim Name**: WIN://SCMUserService
    - **Claim Flags**: 0x40 - UNKNOWN
    - **Value Type**: CLAIM_SECURITY_ATTRIBUTE_TYPE_UINT64
    - **Value Count**: 1
    - **Value[0]**: 0
  - **Claim Name**: TSA://ProcUnique
    - **Claim Flags**: 0x41 - UNKNOWN
    - **Value Type**: CLAIM_SECURITY_ATTRIBUTE_TYPE_UINT64
    - **Value Count**: 2
    - **Value[0]**: 102
    - **Value[1]**: 352550

### Extracting Security Information with Process Hacker

Process Hacker, a system tool similar to Process Explorer, can be used to extract the same information. It is available at [https://processhacker.sourceforge.io/](https://processhacker.sourceforge.io/).

### Debugger Output for Process Information

```plaintext
Kd: 0> !process 0n5936 1
Searching for Process with Cid == 1730
PROCESS ffffe10646205080
    SessionId: 2  Cid: 1730    Peb: 81ebbd1000  ParentCid: 0344
    DirBase: 8fe39002  ObjectTable: ffffa387c2826340  HandleCount: 313.
    Image: svchost.exe
    VadRoot ffffe1064629c340 Vads 108 Clone 0 Private 962. Modified 214. Locked 0.
    DeviceMap ffffa387be1341a0
    Token: ffffa387c2bdc060
    ElapsedTime: 00:35:29.441
```

To display the security attributes of the token, use the `!token` command followed by the address of the token object. This will confirm that the process is hosting a user service, as indicated by the `WIN://ScmUserService` security attribute.

```plaintext
0: kd> !token ffffa387c2bdc060
_TOKEN 0xffffa387c2bdc060
TS Session ID: 0x2
User: S-1-5-21-725390342-1520761410-3673083892-1001
User Groups:
  00 S-1-5-21-725390342-1520761410-3673083892-513
    Attributes - Mandatory Default Enabled
...
OriginatingLogonSession: 3e7
PackageSid: (null)
CapabilityCount: 0
Capabilities: 0x0000000000000000
LowboxNumberEntry: 0x0000000000000000
Security Attributes:
  00 Claim Name: WIN://SCMUserService
    Claim Flags: 0x40 - UNKNOWN
    Value Type: CLAIM_SECURITY_ATTRIBUTE_TYPE_UINT64
    Value Count: 1
    Value[0]: 0
  01 Claim Name: TSA://ProcUnique
    Claim Flags: 0x41 - UNKNOWN
    Value Type: CLAIM_SECURITY_ATTRIBUTE_TYPE_UINT64
    Value Count: 2
    Value[0]: 102
    Value[1]: 352550
```

### User Service Instance Naming

The name of a user service instance is generated by combining the original service name and a local unique ID (LUID) generated by the User Manager. This LUID, known as the context ID, identifies the user's interactive session. The context ID for the interactive logon session is stored in the volatile registry key `HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon\VolatileUserMgrKey\contextLuid`, where the logon session ID and user SID are identified. Opening the Registry Editor and navigating to this key will reveal the same context ID value used for generating the user service instance name.

### Example: Clipboard User Service

Figure 10-22 shows an example of the Clipboard User Service, which runs using the token of the currently logged-on user. The generated context ID for session 1 is 0x3a182, as shown by the User Manager volatile registry key. The Service Control Manager (SCM) calls `ScCreateService` to create a service record in the SCM database, representing a new user service instance. This record is saved in the registry, and the service security descriptor, dependent services, and triggers are copied from the user service template to the new instance.

### Service Triggers and Start

The SCM registers any service triggers and starts the service if its start type is set to `SERVICE_AUTO_START`. When starting a process hosting a user service, the SCM assigns the token of the current logged-on user and the `WIN://ScmUserService` security attribute. Figure 10-23 illustrates that after a user logs in, both the instance and template subkeys are stored in the root services key. The instance subkey is deleted on user logoff and ignored if still present at system startup.

### Packaged Services

Since Windows 10 Anniversary Update (RS1), the SCM has supported packaged services, identified by the `SERVICE_PKG_SERVICE` (512) flag in their service type. Packaged services are designed to support Win32 desktop applications converted to the Modern Application Model. The Desktop App Converter converts Win32 applications to Centennial apps, which run in a lightweight container called Helium. When starting a packaged service, the SCM reads the package information from the registry, verifies the package integrity, and stamps the new service’s host process token with the correct security attributes. The process is launched in a suspended state using `CreateProcessAsUser` API, and a Helium container is created.

### Protected Services

Protected processes and protected processes light (PPL) are detailed in Chapter 3 of Part 1. The Windows 8.1 SCM supports protected services with four levels of protection: Windows, Windows Light, Antimalware Light, and App. A service control program can specify the protection level using the `ChangeServiceConfig2` API. A service’s main executable must be signed properly to run as a protected service. A protected service’s hosting process guarantees certain protections against non-protected processes, such as preventing code injection. Even SYSTEM account processes cannot access a protected process, but the SCM can. Wininit.exe launches the SCM with the maximum user-mode protection level: WinTcb Light.

### Task Scheduling and UBPM

Windows uses the Unified Background Process Manager (UBPM) to handle tasks managed by the Task Scheduler. The Task Scheduler service (Schedule) is implemented in `Schedsvc.dll` and started in a shared `Svchost` process. It maintains the tasks database and hosts UBPM, which starts and stops tasks and manages their actions and triggers. UBPM uses services provided by the Desktop Activity Broker (DAB), System Events Broker (SEB), and Resource Manager for receiving task trigger notifications. Both the Task Scheduler and UBPM provide public interfaces exposed over RPC, allowing external applications to interact with Win32 tasks via COM objects.

### Task Scheduler Architecture

The Task Scheduler implements the task store and hosts the Scheduler idle service and Event trap provider. It also includes the UBPM Proxy, which collects task actions and triggers, converts them to a format UBPM can understand, and sends them to UBPM. The Task Scheduler exposes the server part of the COM Task Scheduler APIs, and the Task Scheduler WMI provider (`Schedprov.dll`) implements COM classes and methods for communication with the Task Scheduler COM API library.