and relays it to the adversary ğ’œ.
âˆ™ When ğ’œ asks ğ’œâ„±â„° to create a ğ‘id for some id, adversary
ğ’œâ„±â„° in turn asks the â„±â„° challenger to do the same.
The â„±â„° challenger randomly chooses a vector xid â†Ë’ Zâ„“
and sends it to ğ’œâ„±â„° who further relays it to ğ’œ.
âˆ™ When ğ’œ makes a key query for an identity id, adver-
sary ğ’œâ„±â„° queries the â„±â„° challenger for a secret key.
Adversary ğ’œâ„±â„° receives the corresponding skid from
the â„±â„° challenger and relays it to ğ’œ.
âˆ™ When ğ’œ chooses a set â„› of up to ğ‘Ÿ revoked users, adver-
sary ğ’œâ„±â„° makes |â„›| key queries to the â„±â„° challenger.
Adversary ğ’œâ„±â„° is given the set skidâ€™s of corresponding
secret keys that is relayed to ğ’œ. Recall that by the defi-
nition of the public traceability game, these queries can
be interleaved with extensions of the number of users
and user corruption queries, in an adaptive manner.
Note that since ğ’œ makes at most ğ‘¡ key queries and |â„›| â‰¤ ğ‘Ÿ,
adversary ğ’œâ„±â„° makes at most ğ‘¡ + ğ‘Ÿ key queries for the â„±â„°
challenger.
ğ‘
âˆ™ Adversary ğ’œ finally produces a pirate decoder ğ’Ÿ4 and
chooses a suspect set ğ’® of cardinality â‰¤ ğ‘¡ that con-
tains ğ’¯ . Then, the adversary ğ’œâ„±â„° executes the Trace
algorithm on ğ’ªğ’Ÿ to find ğ‘– such that |ğ‘ğ‘– âˆ’ ğ‘ğ‘–âˆ’1| is
non-negligible. If Trace outputs âŠ¥ or index ğ‘– such that
idğ‘–âˆ’1 âˆˆ ğ’¯ , then ğ’œâ„±â„° outputs a random bit. We say that
the event Abort occurs in such a case. Otherwise, it sets
y0 = vğ’®ğ‘–âˆ’1 + ğ‘šÂ· vâ„› and y1 = vğ’®ğ‘– + ğ‘šÂ· vâ„›, and sends
them as challenge messages to the â„±â„° challenger.5
4Recall that we assume that ğ’Ÿ is stateless/resettable and replies
independently to successive queries.
5 Here, ğ‘š and ğ‘šâ€² are chosen as in Step (a), vâ„› âˆˆ Zâ„“
as in Step (c), and vğ’®ğ‘–âˆ’1 , vğ’®ğ‘– âˆˆ Zâ„“
ğ‘ is chosen
ğ‘ are chosen as in Step (d) of
algorithm Trace.
Session K1:  Secure ComputationCCSâ€™17, October 30-November 3, 2017, Dallas, TX, USA2286âˆ™ The â„±â„° challenger samples ğ‘ â†Ë’ {0, 1} and then sends
â„±â„°.Enc(pk, yğ‘) to ğ’œâ„±â„° . The adversary ğ’œâ„±â„° runs ğ’ªğ’Ÿ
on input (ğ¶ğ‘, ğ‘š), where ğ¶ğ‘ = (â„±â„°.Enc(pk, yğ‘),â„›).
Then ğ’ªğ’Ÿ outputs the bit ğ‘â€² âˆˆ {0, 1}.
âˆ™ Finally, adversary ğ’œâ„±â„° outputs the same bit ğ‘â€² âˆˆ {0, 1}
if ğ‘ğ‘– âˆ’ ğ‘ğ‘–âˆ’1 > 0 and 1 âˆ’ ğ‘â€² otherwise.
We first argue that ğ’œâ„±â„° is a valid adversary against the â„±â„°
challenger. Recall that when Abort does not occur, we have
idğ‘–âˆ’1 /âˆˆ ğ’¯ but idğ‘–âˆ’1 âˆˆ ğ’®. The keys queried by ğ’œâ„±â„° are for id âˆˆ
â„›âˆªğ’¯ . This set â„›âˆªğ’¯ can be partitioned into â„›âˆª (ğ’¯ âˆ©ğ’®ğ‘–âˆ’1)
and ğ’¯ âˆ© (ğ’®1 âˆ– ğ’®ğ‘–âˆ’1). Note that since idğ‘–âˆ’1 Ì¸âˆˆ ğ’¯ , we have
ğ’¯ âˆ© ğ’®ğ‘–âˆ’1 = ğ’¯ âˆ© ğ’®ğ‘– and thus â„› âˆª (ğ’¯ âˆ© ğ’®ğ‘–âˆ’1) = â„› âˆª (ğ’¯ âˆ© ğ’®ğ‘–).
(1) For id âˆˆ â„›, we have âŸ¨xid, y0âŸ© = âŸ¨xid, y1âŸ© = 0. For
id âˆˆ ğ’®ğ‘–âˆ’1 âˆ© ğ’¯ = ğ’®ğ‘– âˆ© ğ’¯ , we have âŸ¨xid, y0âŸ© = âŸ¨xid, y1âŸ© =
ğ‘š Â· âŸ¨xid, vâ„›âŸ©. Hence for all id âˆˆ â„› âˆª (ğ’¯ âˆ© ğ’®ğ‘–âˆ’1) for
which the skid was queried by ğ’œâ„±â„° , the inner products
âŸ¨xid, y0âŸ© and âŸ¨xid, y1âŸ© have the same value.
(2) Similarly, for id âˆˆ ğ’¯ âˆ© (ğ’®1 âˆ– ğ’®ğ‘–âˆ’1), we have âŸ¨xid, y0âŸ© =
âŸ¨xid, y1âŸ© = ğ‘šâ€² Â· âŸ¨xid, vâ„›âŸ©.
Hence, ğ’œâ„±â„° is a valid adversary against the â„±â„° challenger.
We recollect that in the AD-TT game, we say that ğ’œ wins
if the decryption box ğ’Ÿ output by it is such that when Trace
is executed on input ğ’ªğ’Ÿ, it fails to identify a traitor. In such
a case, Trace either outputs âŠ¥ or it outputs an idğ‘–âˆ’1 Ì¸âˆˆ ğ’¯ with
probability at least 1/ğœ†ğ‘. We next argue that if ğ’œ outputs ğ’Ÿ
that satisfies this winning condition of the AD-TT game, then
ğ’œâ„±â„° has non-negligible advantage in the above game. To see
this, we first observe that when Abort occurs, ğ’œâ„±â„° returns a
random bit and it correctly guesses ğ‘ with probability 1/2.
Then, it suffices to show the following:
âˆ™ In the above game, Abort does not occur with non-
âˆ™ Conditioned on Abort not occurring, Trace outputs
negligible probability.
idğ‘–âˆ’1 such that |ğ‘ğ‘– âˆ’ ğ‘ğ‘–âˆ’1| is non-negligible.
Indeed, the combination of them implies that the advantage
of ğ’œâ„±â„° is non-negligible, since |ğ‘ğ‘– âˆ’ ğ‘ğ‘–âˆ’1| is the advantage of
ğ’œâ„±â„° conditioned on Abort not occurring.
The second item follows because if |ğ‘ğ‘– âˆ’ ğ‘ğ‘–âˆ’1| is not suffi-
ciently large, Trace does not output idğ‘–âˆ’1 at Step (f) of Trace
except for a negligible probability (because of the Hoeffding
bound). Next, we prove the first item. Since we are assuming
ğ’Ÿ satisfies the winning condition, when Trace is executed
on input ğ’ªğ’Ÿ, it outputs âŠ¥ or it outputs an idğ‘–âˆ’1 Ì¸âˆˆ ğ’¯ with
probability at least 1/ğœ†ğ‘. The claim now follows since the for-
mer event occurs only with negligible probability by Lemma
â–¡
3.4.
4 TRACE AND REVOKE FROM
LEARNING WITH ERRORS
Recall that Agrawal et al. [4] provided a construction for
inner product functional encryption from LWE. Instantiating
our generic transformation of Section 3 with this scheme is
possible, but leads to reliance on LWE with subexponential
error rates. In Subsection 4.2, we provide a new construction
of an inner product functional encryption scheme from LWE
in a much weaker model than that considered in [4]. We
restrict to the setting of bounded collusions and also crucially
exploit the fact that the adversaryâ€™s key requests are random
vectors for our application as described in Section 3. The
performances of both resulting trace-and-revoke systems are
discussed in Subsection 4.1.
4.1 Two Trace-and-Revoke Constructions
Our IPFE to trace-and-revoke generic transformation cannot
be directly instantiated with the LWE-based IPFE over Zğ‘
from [4], because the key generation algorithm of the latter is
stateful: it keeps track of all the secret keys it has generated.
The statefulness necessity may be explained as follows. The
master secret key is an integer matrix with small entries.
When the attacker makes a key query for a vector modulo ğ‘,
it learns the integer product between a conversion to the
integers of that vector and the master secret key. If the key
generation algorithm does not maintain a state, then it does
not seem possible to prevent an adversary from making key
queries for vectors that are linearly dependent modulo ğ‘ but
linearly independent over the integers: the attacker could
then make valid key queries but still learn the master secret
key.
The Key Generation State is Unnecessary. In [4], it was
noted that if the vectors queried by the adversary are guar-
anteed to be linearly independent modulo ğ‘, then there is
no need for a stateful key generation algorithm. In our case,
there are as many vectors as users, each vector is uniformly
ğ‘ and the adversary has access to â‰¤ ğ‘Ÿ + ğ‘¡ 
and Z â†Ë’
0, as explained below. Sample A â†Ë’ Zğ‘šÃ—ğ‘›
ğ·2â„“Ã—ğ‘šZ,ğœ0
. Define
. Compute U = Z Â· A âˆˆ Z2â„“Ã—ğ‘›
msk := Z and pk := (A, U).
ğ‘
ğ‘
âˆ™ â„±â„°.KeyGen(msk, x). Given x = (ğ‘¥1, . . . , ğ‘¥2â„“)ğ‘¡ âˆˆ Z2â„“
ğ‘ ,
sample Â¯ğ‘¥ğ‘– â†Ë’ ğ·ğ‘Z+ğ‘¥ğ‘–,ğœ1 for ğ‘– âˆˆ [â„“] and Â¯ğ‘¥ğ‘– â†Ë’ ğ·ğ‘Z+ğ‘¥ğ‘–,ğœ2
for ğ‘– âˆˆ [â„“ + 1, 2â„“]. Set Â¯x := (Â¯ğ‘¥1, . . . , Â¯ğ‘¥2â„“)ğ‘¡ âˆˆ Z2â„“ and
x = Â¯xğ‘¡ Â· Z âˆˆ Zğ‘š. Note that we have Â¯x â‰¡ x mod ğ‘ by
zğ‘¡
construction. Finally, return skx = (Â¯x, zx).
âˆ™ â„±â„°.Enc(pk, y). To encrypt a vector y âˆˆ Z2â„“
s â†Ë’ Zğ‘›
ğ‘ , e0, e1 â†Ë’ ğ·ğ‘šZ,ğ›¼ğ‘ and compute
ğ‘ , sample
c0 = As + e0 âˆˆ Zğ‘š
ğ‘ ,
c1 = Us + e1 + ğ‘ğ‘˜âˆ’1 Â· y âˆˆ Z2â„“
ğ‘ .
Then, return the ciphertext ğ¶ = (c0, c1).
âˆ™ â„±â„°.Dec(skid, ğ¶). Given ğ¶ = (c0, c1) and a secret key
(Â¯x, zx) for x âˆˆ Z2â„“
ğ‘ , compute ğœ‡â€² = âŸ¨Â¯x, c1âŸ©âˆ’âŸ¨zx, c0âŸ© mod
ğ‘ and output the value ğœ‡ âˆˆ Zğ‘ that minimizes |ğ‘ğ‘˜âˆ’1 Â·
ğœ‡ âˆ’ ğœ‡â€²|.
Setting the Parameters. We have to set the parameters so
that the correctness requirement is satisfied and the security
reduction from LWEğ‘›,ğ‘š,ğ‘,ğ›¼â€² works, for some non-trivial error
rate ğ›¼â€². We require that
âˆ™ ğ‘ğ‘˜âˆ’1/4 > ğœ0(ğœ1 + ğœ2)ğ›¼ğ‘
âˆš
â„“ğ‘š Â· ğœ”(log3/2 ğœ†), to ensure
that the error term in decryption has magnitude less
than ğ‘ğ‘˜âˆ’1/4 with probability 1 âˆ’ ğœ†âˆ’ğœ”(1),
the security proof,
apply Lemma 2.5 in the security proof,
ğœ†), to be able to apply Lemma 2.4 in
ğ‘š) and ğœ0, ğ›¼â€²ğ‘ â‰¥ â„¦(
âˆš
âˆ™ ğœ1, ğœ2 â‰¥ ğ‘ Â· â„¦(
âˆš
âˆš
âˆ™ ğ›¼/ğ›¼â€² â‰¥ â„¦(ğœ0
ğœ†), to be able to
âˆ™ ğœ… â‰¥ â„¦(ğœ† + ğ¿ log ğœ†), to ensure the (overwhelmingly
likely) existence of a U as in Lemma 2.9 in the security
proof,
ğœ2 â‰¥ â„¦(ğœ…5/2
1 log3/2(â„“ğœ1)), to be able to apply
Lemma 2.9 in the security proof with ğœ… â‰¥ â„¦(ğœ†+ğ¿ log ğœ†)
as above,
âˆ™ ğœ0 â‰¥ â„¦(ğ‘ğœ…â„“ğœ2) and ğ‘ğ‘›+1/ğ‘ğ‘š â‰¤ 2âˆ’Î©(ğœ…), to be able to
âˆš
â„“ğœ… log â„“), â„“ â‰¥ â„¦(ğœ… log(ğœ1ğœ…)), and
âˆ™ ğœ1 â‰¥ â„¦(
â„“ğœ2
âˆš
apply Lemma 4.2 in the security proof.
To satisfy the above requirements and rely on LWE pa-
rameters for which all known attacks cost 2ğ‘œ(ğœ†), we may set
the parameters as follows. We choose ğœ… = Î˜(ğœ† + ğ¿ log ğœ†),
ğ‘ = ğœ†ğœ”(1), and:7
â„“ = Ìƒï¸€Î˜((ğœ† + ğ¿) log ğ‘)
ğœ0 = Ìƒï¸€Î˜((ğœ† + ğ¿)5(ğ‘ log ğ‘)3ğœ†)
ğœ2 = Ìƒï¸€Î˜((ğœ† + ğ¿)3(ğ‘ log ğ‘)2ğœ†)
1/ğ›¼ = Ìƒï¸€Î˜((ğœ† + ğ¿)9(ğ‘ log ğ‘)6ğœ†2)
1/ğ›¼â€² = Ìƒï¸€Î˜((ğœ† + ğ¿)14.5(ğ‘ log ğ‘)9ğœ†3) ğ‘š = Ìƒï¸€Î˜(ğœ† + ğ¿)
ğ‘ = Ìƒï¸€Î˜((ğœ† + ğ¿)15(ğ‘ log ğ‘)9ğœ†3)
ğ‘› = Ìƒï¸€Î˜(ğœ†)
âˆš
ğœ†)
ğœ1 = Î˜(ğ‘
ğ‘˜ = Î˜(1)
Decryption Correctness. To show the correctness of the
scheme, we first observe that, modulo ğ‘:
â€²
= âŸ¨Â¯x, c1âŸ© âˆ’ âŸ¨zx, c0âŸ© = ğ‘ğ‘˜âˆ’1 Â· âŸ¨x, yâŸ© + âŸ¨Â¯x, e1âŸ© âˆ’ âŸ¨zx, e0âŸ©.
ğœ‡
Below, we show that the magnitude of the term âŸ¨Â¯x, e1âŸ© âˆ’
âˆš
â„“ğ‘šÂ· ğœ”(log3/2 ğœ†) with probability
âŸ¨zx, e0âŸ© is â‰¤ ğœ0(ğœ1 + ğœ2)ğ›¼ğ‘
1âˆ’ ğœ†âˆ’ğœ”(1). Thanks to the parameter choices, the latter upper
bound is smaller than ğ‘ğ‘˜âˆ’1/4, which suffices to guarantee
decryption correctness.