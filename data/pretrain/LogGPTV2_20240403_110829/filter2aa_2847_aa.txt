© NCC Group 2021. All rights reserved
Sleight of ARM:
Demystifying Intel Houdini
Brian Hong
@im_eningeer
whoami
© NCC Group 2021. All rights reserved
Brian S. Hong (@im_eningeer)
• Hardware Enthusiast
• Forward Reverse Engineer
• Like to reverse low-level stuff and break embedded systems
• Android Penetration Testing
• Security Consultant @
• Cooper Union Electrical Engineering
Introduction — Android NDK
© NCC Group 2021. All rights reserved
1 https://gs.statcounter.com/os-market-share/mobile/worldwide
2 https://www.android-x86.org/
• Android is the operating system powering 70%1 of the mobile devices
• Android supports application development in Java and Kotlin, and additionally in
native languages such as C and C++ through the Native Development Kit (NDK)
• ARM is the main hardware platform for Android, with official support for x86
introduced in later versions – Android Lollipop (2014)
• NDK r6 (2011) added support for x86
• NDK r10 (2014) added support for 64 bit ABIs, including x86_64
• There is also out-of-tree support for Android on x86
• Android-x86 (2011)2
Introduction — Android on x86
© NCC Group 2021. All rights reserved
• Two main kinds of x86 devices running Android
(neither of them are phones)
• x86 Chromebooks
• Commercial Android emulators on x86 hosts
• x86 support is generally lacking across apps
• ARM is the primary target platform
• If shipping native code, the Play Store
only requires ARM builds
• Few developers end up shipping x86 binaries
for their APKs, but many apps have native code
• So then how are x86 Android devices supposed to
support popular apps (optimized with native ARM code)?
Houdini — What is it?
© NCC Group 2021. All rights reserved
• Intel’s proprietary dynamic binary translator from ARM to x86
• Co-created by Google for Android
• Enables ARM native applications to run on x86 based platforms
• A black box shrouded in mystery
• Little mention of it on Intel’s websites, seemingly not a public-facing product
• No public documentation
• Several vendors may be obfuscating their use of Houdini?
• There are three variants:
• 32-bit x86 implementing 32-bit ARM
• 64-bit x86 implementing 32-bit ARM
• 64-bit x86 implementing 64-bit ARM
Houdini — Where’s it used?
© NCC Group 2021. All rights reserved
• Physical hardware
• x86-based mobile phones (e.g. Zenfone 2)
• x86 Chromebooks
• This is how we got it
• Commercial Android Emulators
• BlueStacks
• NOX
• Android-x86 Project
Houdini — How’s it work?
© NCC Group 2021. All rights reserved
Interpreted emulator
• Essentially a while loop around a switch (but actually more like a state machine)
• Reads ARM opcodes and produces corresponding behavior in x86
• Doesn’t JIT; no x86 instructions produced at runtime
Two components
• houdini: interpreter used to run executable binaries
• libhoudini: loadable shared object (x86); used to load and link ARM libraries
./houdini
© NCC Group 2021. All rights reserved
Runs ARM executable binaries (static and dynamic)
• Uses dynamic libraries precompiled for ARM+Android from:
• /system/lib/arm
• /system/vendor/lib/arm
./houdini
© NCC Group 2021. All rights reserved
Runs ARM executable binaries (static and dynamic)
• Uses dynamic libraries precompiled for ARM+Android from:
• /system/lib/arm
• /system/vendor/lib/arm
• Loaded in by the Linux kernel binfmt_misc feature
./houdini — binfmt_misc
© NCC Group 2021. All rights reserved
1 https://en.wikipedia.org/wiki/Binfmt_misc
binfmt_misc (Miscellaneous Binary Format) is a capability of the Linux kernel which
allows arbitrary executable file formats to be recognized and passed to certain user
space applications, such as emulators and virtual machines. It is one of a number of
binary format handlers in the kernel that are involved in preparing a user-space program
to run. 1
./houdini — binfmt_misc
© NCC Group 2021. All rights reserved
1 https://en.wikipedia.org/wiki/Binfmt_misc
binfmt_misc (Miscellaneous Binary Format) is a capability of the Linux kernel which
allows arbitrary executable file formats to be recognized and passed to certain user
space applications, such as emulators and virtual machines. It is one of a number of
binary format handlers in the kernel that are involved in preparing a user-space program
to run. 1
./hello
./houdini — binfmt_misc
© NCC Group 2021. All rights reserved
1 https://en.wikipedia.org/wiki/Binfmt_misc
binfmt_misc (Miscellaneous Binary Format) is a capability of the Linux kernel which
allows arbitrary executable file formats to be recognized and passed to certain user
space applications, such as emulators and virtual machines. It is one of a number of
binary format handlers in the kernel that are involved in preparing a user-space program
to run. 1
./hello
->
/system/bin/houdini ./hello
libhoudini.so
© NCC Group 2021. All rights reserved
• Is a shared object (x86)
• Loads in ARM shared objects
• Mainly designed to be used with Android NativeBridge to run ARM native code
Android NativeBridge
© NCC Group 2021. All rights reserved
1 Ye, Roger. Android System Programming: Porting, Customizing, and Debugging Android HAL.
Packt Publishing, 2017.
• Main interface from Android to libhoudini
• Part of the Android Runtime (ART)
• Supports running native libraries in
different processor architectures
1
Android NativeBridge — Initialization
© NCC Group 2021. All rights reserved
• Initialized on boot by Android Runtime (ART)
• NativeBridge reads system property ro.dalvik.vm.native.bridge
• Disabled if set to ”0”
• Otherwise, it provides the name of the library file to be loaded with
NativeBridge (e.g ”libhoudini.so”)
• NativeBridge defines interface with callbacks
• NativeBridgeRuntimeCallbacks
• NativeBridgeCallbacks
Android NativeBridge — Initialization
© NCC Group 2021. All rights reserved
• Initialized on boot by Android Runtime (ART)
• NativeBridge reads system property ro.dalvik.vm.native.bridge
• Disabled if set to ”0”
• Otherwise, it provides the name of the library file to be loaded with
NativeBridge (e.g ”libhoudini.so”)
• Android-x86 project uses ”libnb.so” instead, which is a shim that loads
libhoudini
• NativeBridge defines interface with callbacks
• NativeBridgeRuntimeCallbacks
• NativeBridgeCallbacks
Android NativeBridge — Java Native Interface (JNI)
© NCC Group 2021. All rights reserved
1 https://android.googlesource.com/platform/libnativehelper/+/refs/heads/master/include_jni/jni.h
The JNI is an FFI for calling between JVM
code (e.g. Java) and native code (e.g.
C/C++). Java native methods are mapped
to native symbols. The native functions
receive a JNIEnv* from the JVM, which is a
bag of function pointers providing a
low-level Java/JVM reflection API, including
object allocation, class lookups, and method
invocations. It also provides a type mapping
between Java primitives and C types.
typedef uint8_t
jboolean; /* unsigned 8 bits */
typedef int8_t
jbyte;
/* signed 8 bits */
typedef uint16_t jchar;
/* unsigned 16 bits */
typedef int32_t
jint;
/* signed 32 bits */
typedef int64_t
jlong;
/* signed 64 bits */
typedef const struct JNINativeInterface* JNIEnv;
struct JNINativeInterface {
...
jint
(*GetVersion)(JNIEnv *);
jclass
(*DefineClass)(JNIEnv*, const char*...
jclass
(*FindClass)(JNIEnv*, const char*);
...
jobject
(*AllocObject)(JNIEnv*, jclass);
jobject
(*NewObject)(JNIEnv*, jclass, jmethodID...
...
jmethodID (*GetStaticMethodID)(JNIEnv*, jclass...
jobject
(*CallObjectMethod)(JNIEnv*, jobject...
jboolean
(*CallBooleanMethod)(JNIEnv*, jobject...
...
jbyte
(*GetByteField)(JNIEnv*, jobject, jfieldID);
jchar
(*GetCharField)(JNIEnv*, jobject, jfieldID);
jint
(*GetIntField)(JNIEnv*, jobject, jfieldID);
...
source1
Android NativeBridge — Callbacks
© NCC Group 2021. All rights reserved
1 https://android.googlesource.com/platform/art/+/master/runtime/native_bridge_art_interface.cc
NativeBridgeRuntimeCallbacks
provide a way for native methods to
call JNI native functions.
NativeBridge -> libhoudini
// Runtime interfaces to native bridge.
struct NativeBridgeRuntimeCallbacks {
// Get shorty of a Java method.
const char* (*getMethodShorty)(JNIEnv* env, jmethodID mid);
// Get number of native methods for specified class.
uint32_t (*getNativeMethodCount)(JNIEnv* env, jclass clazz);
// Get at most 'method_count' native methods
// for specified class.
uint32_t (*getNativeMethods)(JNIEnv* env, jclass clazz,
JNINativeMethod* methods, uint32_t method_count);
};
source1
Android NativeBridge — Interface
© NCC Group 2021. All rights reserved
1 https://android.googlesource.com/platform/art/+/master/runtime/native_bridge_art_interface.cc
NativeBridge can interact with
libhoudini via
NativeBridgeCallbacks
Fetched from libhoudini via symbol
NativeBridgeItf
// Native bridge interfaces to runtime.
struct NativeBridgeCallbacks {
uint32_t version;
bool (*initialize)(const NativeBridgeRuntimeCallbacks* runtime_cbs,
const char* private_dir, const char* instruction_set);
void* (*loadLibrary)(const char* libpath, int flag);
void* (*getTrampoline)(void* handle, const char* name,
const char* shorty, uint32_t len);
...
int (*unloadLibrary)(void* handle);
void* (*loadLibraryExt)(const char* libpath, int flag,
native_bridge_namespace_t* ns);
};
source1
Android NativeBridge — Interface
© NCC Group 2021. All rights reserved
1 https://android.googlesource.com/platform/art/+/master/runtime/native_bridge_art_interface.cc
NativeBridge can interact with
libhoudini via
NativeBridgeCallbacks
Fetched from libhoudini via symbol
NativeBridgeItf
• initialize()
• loadLibrary()
"dlopen()"
• getTrampoline() "dlsym()"
// Native bridge interfaces to runtime.
struct NativeBridgeCallbacks {
uint32_t version;
bool (*initialize)(const NativeBridgeRuntimeCallbacks* runtime_cbs,
const char* private_dir, const char* instruction_set);
void* (*loadLibrary)(const char* libpath, int flag);
void* (*getTrampoline)(void* handle, const char* name,
const char* shorty, uint32_t len);
...
int (*unloadLibrary)(void* handle);
void* (*loadLibraryExt)(const char* libpath, int flag,
native_bridge_namespace_t* ns);
};
source1
NativeBridge — Libhoudini
$ objdump -T libhoudini.so
libhoudini.so:
file format elf32-i386
DYNAMIC SYMBOL TABLE:
...
004f8854 g
DO .data 0000003c Base
NativeBridgeItf
NativeBridge — Summary
NativeBridge — Summary
• dlopen(libhoudini.so)
NativeBridge — Summary
• dlopen(libhoudini.so)
• dlsym(NativeBridgeItf)
• initialize()
NativeBridge — Summary
• dlopen(libhoudini.so)
• dlsym(NativeBridgeItf)
• initialize()
• loadLibrary()
"dlopen()"
NativeBridge — Summary
• dlopen(libhoudini.so)
• dlsym(NativeBridgeItf)
• initialize()
• loadLibrary()
"dlopen()"
• getTrampoline() "dlsym()"
NativeBridge — Summary
• dlopen(libhoudini.so)
• dlsym(NativeBridgeItf)
• initialize()
• loadLibrary()
"dlopen()"
• getTrampoline() "dlsym()"
NativeBridge — Summary
• dlopen(libhoudini.so)
• dlsym(NativeBridgeItf)
• initialize()
• loadLibrary()
"dlopen()"
• getTrampoline() "dlsym()"
NativeBridge — Summary
• dlopen(libhoudini.so)
• dlsym(NativeBridgeItf)
• initialize()
• loadLibrary()
"dlopen()"
• getTrampoline() "dlsym()"
NativeBridge — Summary
• dlopen(libhoudini.so)
• dlsym(NativeBridgeItf)
• initialize()
• loadLibrary()
"dlopen()"
• getTrampoline() "dlsym()"
• Houdini provides a ARM version
of JNIEnv
• Handled via trap
instructions
Houdini Emulation — Memory
© NCC Group 2021. All rights reserved
• Dual architecture userland (separate ARM binaries; e.g. libc, etc.)
• Shared virtual address space
• Real world view of memory
• Maintains a separate allocation for ARM stack
00008000-0000a000 rw-p 00000000
[anon:Mem_0x10000002]
0c000000-0c001000 r--p 00000000
/vendor/lib/arm/nb/libdl.so
0c001000-0c002000 r--p 00000000
/vendor/lib/arm/nb/libdl.so
0c200000-0c203000 r--p 00000000
/data/app/com.nccgroup.research.../lib/arm/libnative-lib.so
0c203000-0c204000 r--p 00002000
/data/app/com.nccgroup.research.../lib/arm/libnative-lib.so
0c204000-0c205000 rw-p 00003000
/data/app/com.nccgroup.research.../lib/arm/libnative-lib.so
0c500000-0c5d6000 r--p 00000000
/vendor/lib/arm/nb/libc.so
0c5d6000-0c5da000 r--p 000d5000
/vendor/lib/arm/nb/libc.so
0c5da000-0c5dc000 rw-p 000d9000
/vendor/lib/arm/nb/libc.so
...
0e094000-10000000 rwxp 00000000
[anon:Mem_0x20000000]
12000000-12100000 rwxp 00000000