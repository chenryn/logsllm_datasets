defenses. In USENIX Security Symposium, (2011).
[8] Aafer, Y., Zhang, N., Zhang, Z., Zhang, X., Chen,
K., Wang, X., Zhou, X., Du, W., and Grace, M.
Hare hunting in the wild Android: A study on the threat
of hanging attribute references. In CCS, (2015), ACM.
[9] Roesner, F., Kohno, T., Moshchuk, A., Parno, B.,
Wang, H., and Cowan, C. User-driven access con-
trol: Rethinking permission granting in modern operat-
ing systems. In S&P, (2012), IEEE.
[10] Ringer, T., Grossman, D., and Roesner, F. Auda-
cious: User-driven access control with unmodified oper-
ating systems. In CCS (2016), ACM.
[11] Petracca, G., Reineh, A.-A.,
Sun, Y.,
Grossklags, J., and Jaeger, T. AWare: Pre-
venting abuse of privacy-sensitive sensors via operation
bindings. In USENIX Security Symposium, (2017).
[12] Onarlioglu, K., Robertson, W., and Kirda, E.
Input-driven access control for better pri-
Overhaul:
vacy on traditional operating systems. In DSN, (2016),
IEEE/IFIP.
[13] Nadkarni, A., and Enck, W. Preventing accidental
data disclosure in modern operating systems. In CCS,
(2013), ACM.
[14] Wijesekera, P., Baokar, A., Tsai, L., Reardon,
J., Egelman, S., Wagner, D., and Beznosov, K. The
feasibility of dynamically granted permissions: Aligning
mobile privacy with user preferences.
In S&P (2017),
IEEE.
[15] Olejnik, K., Dacosta,
I., Machado,
Context-aware and automatic
J.S.,
Huguenin, K., Khan, M.E., and Hubaux, J.P.
Smarper:
runtime-
permissions for mobile devices. In S&P, (2017), IEEE.
[16] Jia, Y. J., Chen, Q. A., Wang, S., Rahmati, A.,
Fernandes, E., Mao, Z. M., and Prakash, A. Con-
texIoT: Towards Providing Contextual Integrity to Ap-
pified IoT Platforms. In NDSS, (2017).
[17] Acar, Y., Backes, M., Bugiel, S., Fahl, S., Mc-
Daniel, P. and Smith, M., Sok: Lessons learned from
android security research for appified software platforms.
In S&P, (2017), IEEE.
[18] Li, L., Bartel, A., Bissyandé, T. F., Klein, J.,
Le Traon, Y., Arzt, S., Rasthofer, S., Bodden,
E., Octeau, D., and McDaniel, P. Iccta: Detecting
inter-component privacy leaks in Android apps. In ICSE,
(2015), IEEE.
[19] Octeau, D., McDaniel, P., Jha, S., Bartel, A.,
Bodden, E., Klein, J., and Le Traon, Y. Effec-
tive inter-component communication mapping in An-
droid with Epicc: An essential step towards holistic se-
curity analysis. In USENIX Security Symposium, (2013).
[20] Nadkarni, A., Andow, B., Enck, W., and Jha, S.
In USENIX
Practical DIFC enforcement on Android.
Security Symposium, (2016).
[21] Octeau, D., Luchaup, D., Dering, M., Jha, S.,
and McDaniel, P. Composite constant propagation:
Application to Android inter-component communication
analysis. In ICSE, (2015), IEEE.
[22] Octeau, D., Jha, S., Dering, M., McDaniel, P.,
Bartel, A., Li, L., Klein, J., and Le Traon, Y.
Combining static analysis with probabilistic models to
enable market-scale Android inter-component analysis.
In ACM SIGPLAN Notices, (2016).
[23] Krohn, M.N., Yip, A., Brodsky, M., Cliffer, N.,
In-
Kaashoek, M.F., Kohler, E., and Morris R.
formation flow control for standard OS abstractions. In
SOSP, (2007).
[24] Zeldovich, N., Boyd-Wickizer, S., Kohler, E.,
and Mazières, D. Making information flow explicit
in HiStar. In OSDI, (2006).
[25] Chatterjee, R., Doerfler, P., Orgad, H.,
Havron, S., Palmer, J., Freed, D., Levy, K., Dell,
N., McCoy, D., and Ristenpart, T. The Spyware
Used in Intimate Partner Violence.
In S&P, (2018),
IEEE.
[26] Chin, E., Felt, A. P., Greenwood, K., and Wag-
ner, D. Analyzing inter-application communication in
Android. In MobiSys (2011), ACM.
[27] Huang, L.-S., Moshchuk, A., Wang, H. J.,
Schecter, S., and Jackson, C. Clickjacking: Attacks
and defenses. In USENIX Security Symposium, (2012).
[28] Luo, T., Jin, X., Ananthanarayanan, A., and Du,
W. Touchjacking attacks on web in Android, iOS, and
Windows phone. In FPS (2012).
[29] Enck, W., Gilbert, P., Chun, B.-G., Cox, L. P.,
Jung, J., McDaniel, P., and Sheth, A. N. Taint-
droid: An information-flow tracking system for realtime
privacy monitoring on smartphones. In USENIX OSDI
(2010).
[30] Arzt, S., Rasthofer, S., Fritz, C., Bodden, E.,
Bartel, A., Klein, J., Le Traon, Y., Octeau, D.,
and McDaniel, P. Flowdroid: Precise context, flow,
field, object-sensitive and lifecycle-aware taint analysis
for Android apps. ACM Sigplan Notices, (2014), pp. 259–
269.
[31] Tang, Y., Ames, P., Bhamidipati, S., Bijlani, A.,
Geambasu, R., and Sarda, N. CleanOS: Limiting
mobile data exposure with idle eviction.
In USENIX
OSDI (2012).
[32] Sun, Y., Petracca, G., Ge, X., and Jaeger, T.
Pileus: Protecting user resources from vulnerable cloud
services. In ACSAC, (2016), ACM.
[33] Wijesekera, P., Baokar, A., Hosseini, A., Egel-
man, S., Wagner, D., and Beznosov, K. Android
permissions remystified: A field study on contextual in-
tegrity. USENIX Security Symposium, (2015).
[34] Levy, H. M. Capability-Based Computer Systems.
Digital Press. Available at http://www.cs.washington.
edu/homes/levy/capabook/, (1984).
[35] Prevelakis, V., and Spinellis, D. Sandboxing ap-
In USENIX Annual Technical Conference,
plications.
FREENIX Track, (2001).
582    28th USENIX Security Symposium
USENIX Association
[36] Chang, F., Itzkovitz, A., and Karamcheti, V.
User-level resource-constrained sandboxing. In USENIX
Windows Systems Symposium, (2000).
[37] Smalley, S., Vance, C., and Salamon, W. Imple-
menting SELinux as a Linux security module. NAI Labs
Report #01-043, (2001).
[38] Smalley, S., and Craig, R. Security Enhanced (SE)
Android: Bringing flexible MAC to Android. In NDSS,
(2013).
[39] Ye, Z., Smith, S., and Anthony, D. Trusted paths
for browsers. ACM Transactions on Information and
System Security, (2005).
[40] Zhou, Z., Gligor, V., Newsome, J., and McCune,
J. Building verifiable trusted path on commodity x86
computers. In S&P, (2012), IEEE.
[41] Shapiro, J., Vanderburgh, J., Northup, E., and
Chizmadia, D. Design of the EROS trusted window
system. In USENIX Security Symposium, (2004).
[42] Li, W., Ma, M., Han, J., Xia, Y., Zang, B., Chu,
C.-K., and Li, T. Building trusted path on untrusted
device drivers for mobile devices. In Asia-Pacific Work-
shop on Systems, (2014), ACM.
[43] Eugster, P., Felber, P., Guerraoui, R., and Ker-
marrec, A.-M. The many faces of publish/subscribe.
ACM Computing Surveys, (2003).
[44] Mellor-Crummey, J. M., and Scott, M. L. Scal-
able reader-writer synchronization for shared-memory
multiprocessors. ACM SIGPLAN Notices, (1991).
[45] Felt, A. P., Ha, E., Egelman, S., Haney, A., Chin,
E., and Wagner, D. Android permissions: User atten-
tion, comprehension, and behavior. In SOUPS, (2012),
ACM.
[46] Rivest, R., Shamir, A., and Adleman, L. A method
for obtaining digital signatures and public-key cryptosys-
tems. Communications of the ACM, (1978).
[47] Bianchi, A., Corbetta, J., Invernizzi, L., Fratan-
tonio, Y., Kruegel, C., and Vigna, G. What the
App is that? Deception and countermeasures in the An-
droid user interface. S&P, (2015), IEEE.
[48] Cummings, P., Fullan, D.A., Goldstien, M.J.,
Gosse, M.J., Picciotto, J., Woodward, J.P., and
Wynn, J. Compartmented Model Workstation: Results
through prototyping. S&P, (1987), IEEE.
[49] Schechter, S. Common pitfalls in writing about secu-
rity and privacy human subjects experiments, and how
to avoid them. Microsoft Tech. Rep. (2013).
[50] Felt, A. P., Egelman, S., Finifter, M., Akhawe,
D., and Wagner, D. How to ask for permission. In
USENIX Workshop on Hot Topics in Security (2012).
[51] Sheehan, K.B. Toward a typology of Internet users
and online privacy concerns. The Information Society,
(2012).
[52] Debatin, B., Lovejoy, J.P., Horn, A.K., and
Hughes, B.N. Facebook and online privacy: Attitudes,
behaviors, and unintended consequences.
Journal of
Computer-Mediated Communication, (2009).
[53] Petracca, G., Atamli-Reineh, A., Sun, Y.,
Grossklags, J., and Jaeger, T. Aware: Controlling
app access to I/O devices on mobile platforms. CoRR
abs/1604.02171, (2016).
[54] Ongtang, M., McLaughlin, S., Enck, W., and Mc-
Daniel, P. Semantically rich application-centric secu-
rity in Android. Security and Communication Networks,
(2012).
[55] Dietz, M., Shekhar, S., Pisetsky, Y., Shu, A., and
Wallach, D. Quire: Lightweight provenance for smart
phone operating systems. In USENIX Security Sympo-
sium (2011).
[56] Sasse, M. A., Brostoff, S., and Weirich, D. Trans-
forming the ‘Weakest Link’ — a Human/Computer In-
teraction Approach to Usable and Effective Security BT
Technology Journal, (2001).
[57] Arce, I. The weakest link revisited [information secu-
rity]. In IEEE Security & Privacy, (2003).
[58] Fahl, S., Harbach, M., Acar, Y., and Smith, M.
On the Ecological Validity of a Password Study In Ninth
Symposium on Usable Privacy and Security, (2013).
Appendices
Appendix A - Study Demographics: In total, from
the 69 recruited subjects that completed our study, 34
(49%) were female; 36 (52%) were in the 18-25 years old
range, 27 (39%) in the 26-50 range, and 6 (9%) were in
above the 51 range; 33 (48%) were students from our In-
stitution, 9 of them (13%) were undergraduate and 24
(35%) were graduate students, 2 (3%) were Computer
Science Majors; 11 (16%) worked in Public Administra-
tion, 9 (13%) worked in Hospitality, 6 (9%) in Human
Services, 6 (9%) in Manufacturing, and 4 (6%) worked
in Science or Engineering. All participants reported be-
ing active smartphone users (1-5 hours/day). Also, 42
(61%) of the subjects were long-term Android users (3-5
years), others were long-term iOS users. For our labo-
ratory and field studies, we redistributed the available
participants as evenly as possible. Each lab group had
9 long-term Android users, the remaining 6 long-term
Android users participated in our field study.
Figure 8: Time analysis used to study the possibility of am-
biguous events delegation paths, as discussed in Section 4.2.
Appendix B - Time Constraints Analysis: We
leveraged data collected via the field study to perform
an analysis of time constraints for input events and ac-
tion/operation requests to calibrate the time window
USENIX Association
28th USENIX Security Symposium    583
for the event ambiguity prevention mechanism (Sec-
tion 4.2). Figure 8 reports the measurements of the
gaps15 between consecutive input events and consecu-
tive handoff events, as well as the lags between each
event and the corresponding response from the serving
program. From the measurements, we observed: (1) the
minimum gap between subsequent input events target-
ing the same program (211 ms) is an order of magnitude
larger than the maximum lag required by the program to
serve each incoming event (22 ms); and (2) the minimum
gap (171 ms) between subsequent handoff events target-
ing the same program is an order of magnitude larger
than the maximum lag required by the program to serve
incoming requests (15 ms). Hence, to avoid ambiguity,
we may set the time window to 150 ms to guarantee
that the entire delegation path can be identified before
the next event for the same program arrives. Lastly,
we observed that 87% of the delegation paths had a to-
tal length of three edges (one input event, one handoff
event, and one sensor operation request). The remain-
ing 13% of the delegation paths had a maximum length
of four edges (one additional handoff event), which fur-
ther supports our claim that we can hold events without
penalizing concurrency of such events.
Appendix C - Program Identification: To prove
the programs’ identity to users, EnTrust specifies both
the programs’ name and visual
identity mark (e.g.,
icon) in every delegation request as shown in Figure 6.
EnTrust retrieves programs’ identity by accessing the
AndroidManifest.xml, which must contain a unique
name and a unique identity mark (e.g., icon) for the pro-
gram package. EnTrust verifies programs’ identity via
the crypto-checksum16 of the program’s binary signed
with the developer’s private key and verifiable with the
developer’s public key [46], similarly to what proposed
in prior work [47, 11].
Appendix D - Input Event Authentication:
EnTrust leverages SEAndroid [38] to ensure that pro-
grams cannot inject input events by directly writing
into input device files (i.e., /dev/input/*) correspond-
ing to hardware and software input interfaces attached
to the mobile platform. Hence, only device drivers can
write into input device files and only the Android Input
Manager, a trusted system service, can read such de-
vice files and dispatch input events to programs. Also,
EnTrust leverages the Android screen overlay mecha-
nism to block overlay of graphical user interface com-
ponents and prevent hijacking of input events. Lastly,
EnTrust accepts only voice commands that are pro-
cessed by the Android System Voice Actions module.17
EnTrust authenticates input events by leveraging six-
teen mediation hooks placed inside the stock Android
Input Manager and six mediation hooks placed inside
the System Voice Actions module.
Appendix E - Handoff Event Mediation:
Programs communicate with each other via Inter-
Component Communication (ICC) that, in Android, is
implemented as part of the Binder IPC mechanisms.
The ICC includes both intent and broadcast messages
that can be exchanged among programs. The Binder
and the Activity Manager regulate messages exchanged
among programs via the intent API.18 Programs can
also send intents to other programs or services by using
the broadcast mechanism that allows sending intents as
arguments in broadcast messages. The Activity Man-
ager routes intents to broadcast receivers based on the
information contained in the intents and the broadcast
receivers that have registered their interest in the first
place. To mediate intents and broadcast messages ex-
changed between programs completely, EnTrust lever-
ages mediation hooks placed inside the Activity Man-
ager and the Binder.
Notice that, other operating systems support mech-
anisms similar to Android’s Intents. For instance, Ma-
cOS and iOS adopt the Segue mechanism, while Chrome
OS supports Web Intents, thus EnTrust can be also im-
plemented for other modern systems supporting the co-
operating program abstraction.
Appendix F - Sensor Operation Mediation:
Android uses the Hardware Abstraction Layer (HAL)
interface to allow only system services and privileged
processes to access system sensors indirectly via a well-
defined API exposed by the kernel. Moreover, SEAn-
droid [38] is used to ensure that only system services
can communicate with the HAL at runtime. Any other
programs (e.g., apps) must interact with such system
services to request execution of operations targeting sen-
sors. EnTrust leverages such a mediation layer to iden-
tify operation requests generated by programs, by plac-
ing 12 hooks inside the stock Android Audio System,
Media Server, Location Services, and Media Projection.
Notes
1In this paper, we use the term “delegate” to refer to the use of IPCs
to request help in task processing, not the granting of permissions to
other processes.
2One of the surveillance mobile apps available online (e.g., flexispy).
3Several banks are now offering these services to their clients.
4https://source.android.com
5The runtime permission mechanism enabled users to revoke permis-
sions at any time.
6Source: https://fortune.com
7https://dialogflow.com
8https://source.android.com/compatibility/cts/
9Android Open Source Project - https://source.android.com
10This range was selected based on the size of the delegation graphs
created during our experiments, which should be representative of
real scenarios.
11https://developer.android.com/studio/test/monkey.html
12To stress test our system, we selected a lower bound that is consid-
erably lower than the maximum speed at which a user can possibly
keep tapping on the screen (∼210 ms).
13Chosen among the most-downloaded Android apps from the Google
Play Store and including all apps and system services shipped with
the stock Android OS.
14Equivalent of IPCs for Android OS.
15Gaps higher than 1,500 ms were excluded because not relevant to the
16Android requires all apps and services to be signed by their developers.
17https://developers.google.com/voice-actions/
18https://developer.android.com
analysis.
584    28th USENIX Security Symposium
USENIX Association