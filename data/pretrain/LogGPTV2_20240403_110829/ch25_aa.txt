可编写脚本的负载平衡器
Emil Stolarsky, DigitalOcean (formerly Shopify)
当出现可伸缩性问题时，没有时间返回并重新构建或重构整个 Web 服务。你负责的服务不可避免地会因为超载而导致服务中断。有时，你希望出现奇迹，遇到的是一个易于修复的数据库查询错误，或许也可以简单地增加服务进程的数量。但是当你没有足够的时间、金钱或人力来解决手头的问题时呢？ 幸运的是，有一套新的工具可以在我们行业技术清单中，可以永远改变我们处理可扩展性的方式，也把 SRE 的角色变得更得心应手：可编写脚本的负载均衡器。
 可编写脚本的负载均衡器是可以通过脚本语言（如 Lua）修改其请求/响应处理流的代理。这为基础结构团队分片应用程序、缓解分布式拒绝服务 （DDoS） 攻击和处理高负载开辟了新途径。小团队现在可以通过新颖而优雅的方式解决困难或看似不可能的问题。向负载平衡层添加高性能自定义逻辑的能力并不新鲜;但是，在任何规模的组织中执行此操作的能力是。这就是为什么可编写脚本的负载均衡器可以改变游戏规则的原因。可编写脚本的负载平衡器：新新人类
 看看几乎所有的 Web 服务，通常会发现负载平衡器是请求命中的最前端，正如 #architecture_of_a_typical_web_application 描述的那样。Limoncelli, Thomas A.，Strata R. Chalup 和 Christina J. Hogan（2014）。 “应用程序体系结构。”来自云系统管理实践：Web 服务的 DevOps 和 SRE 实践。 波士顿：Addison-Wesley Professional 一书。这些服务器充当代理，接收请求（HTTP 或其他协议）并将它们转发到指定的上游服务器池。 它们在提高弹性和性能方面的价值已经无处不在。今天，它们通常仅用于安全套接字层（SSL）卸载，简单缓存以及跨多个上游分布负载。
对于典型 Web 应用程序的体系结构，用户请求在路由到应用程序服务器之前会先经过负载均衡器。负载平衡器是我们架构中功能强大的专用组件。他们快速处理请求并提供比上游更多的流量的能力是一个强大的特征。遗憾的是，任何添加复杂应用程序逻辑的尝试都会被负载均衡器附带的限制性配置语言快速关闭。有应用程序感知负载平衡器（例如，Facebook 的 ProxygenShuff, Patrick（2015）。“构建一个十亿用户负载均衡器。”在 SREcon15 EU 大会的讲座。）能够查看请求的内容（例如读取协议头） 并采取行动，但仍需要定制。 该行业的巨头（Facebook、谷歌等）认识到应用程序感知负载平衡器可以带来的价值，并且已经自行开发。 对于那些没有这类专业开发团队的业内其他公司来说，我们完全没有办法分享到好处。
业内一些公司已经开始意识到，传统负载均衡器或需要团队支持的具有应用感知功能的定制负载均衡器之间不需要这种二分法。这个中间地带可以由可编写脚本的负载平衡器填充。使用可编写脚本的负载均衡器，您可以通过编写脚本语言（如 Lua）修改请求/响应处理流（例如，通过修改传出标头）。您可以以高级语言编写扩展，以在负载均衡器的现有功能之上添加应用程序感知功能。脚本负载平衡器的市场仍然很年轻。 目前有两个主要的可编写脚本的负载均衡器项目：   OpenResty 和 nginScript。OpenResty是一个带有嵌入式 LuaJIT 的 Nginx C 模块，由  Yichun“agentzh”Zhang 创建。 一个稳定的社区网络Netcraft（2016）“2016年9月 Web 服务器调查。”围绕它开发、衍生了多个库/模块；它已被 Cloudflare、Tumblr 和 Shopify 等公司采用。 在这两者中，OpenResty 拥有最大的社区，并且拥有超过 10％ 的互联网流量。Roberts，John。（2016）“使用 Cloudflare 控制边缘流量。”https://blog.cloudflare.com/cloudflare-traffic/。紧随其后的是 nginScript，Nginx Inc. 在 Nginx 中实现的 JavaScript 脚本引擎。为什么需要可编写脚本的负载平衡器？
 与定制和常规负载均衡器相比，可编写脚本的负载均衡器具有许多优势。
对于初学者来说，只有一些选定的组织可以腾出必要的时间和人员来构建自己的生产就绪负载平衡器。更实际，很少有工程师在从头开始构建负载平衡器方面拥有经验。工程师理应花时间来提高应用弹性或性能，而不是将时间花在重新发明车轮、处理路由和请求处理引擎上。
即使费了很多力气去进行定制开发，我们添加的自定义逻辑也只能占负载均衡器整体功能的小部分。重建该功能不符合任何人的最佳利益。特别是现在来说许多功能是一个移动的目标，因为有开源社区的不断改进。传统的负载均衡器提供的功能与可编写脚本的负载均衡器不同。一个缺点是传统的负载均衡器附带声明性配置语言，因此难以用来实现应用程序相关的逻辑。有时，甚至无法指定所需的行为。此外，通过配置表示的逻辑很难通过测试完全验证正确性。为了补偿，许多负载均衡器附带一个基于 C 的插件系统，允许开发人员通过模块增强现有功能。这些插件系统解决了许多问题，但与使用嵌入式脚本语言相比，它们会带来大量不必要的缺点。如果没有内置的内存安全性，C 容易出现内存故障（例如缓冲区溢出和分段故障），因此本质上不安全。相反，脚本语言（如 Lua）可以通过严格的运行时和内存保证进行沙盒处理。编写 C 模块时，开发人员不能忽视与当前逻辑不特别相关的较低级别的详细信息，而脚本语言不存在这个问题。 
使困难变得简单使困难变得简单
负载均衡器充当服务的守门员，每个请求都通过它们。它们在我们的 Web 体系结构中的位置支持强大的抽象。这允许 SRE 或基础结构开发人员实现通常很困难的方案。例如，在部署期间暂停请求以避免将错误返回给客户，或将请求代理到正确的数据中心的能力对于 SRE 团队来说非常强大，但很难在现有框架和应用程序中实现。典型的 Web 框架（如 Rails 或 Django）专为满足传统的 CRUD/REST 请求而设计。虽然它们可以执行非传统操作，但代价是恢复能力。本节的其余部分将演示如何使用可编写脚本的负载均衡器来解决常见的基础结构问题，从而产生非常有用的功能。
分片感知路由分片感知路由
 当应用程序增长得足够大时，它们的数据会变得太大而无法存储在单个节点上。解决方案是将数据分解为可管理的块（称为分片），并将其分布在多个节点或数据库中。有时，这是由数据库在内部完成的，所有需要扩展的都是向数据库集群添加更多节点。对于大多数应用程序，数据必须根据数据模型和访问模式进行逻辑分区。Matsudaira，Kate（2012年） “可扩展的Web架构和分布式系统。”引自开源应用程序架构的第二卷：结构、规模和几个大胆的改进。埃德.艾米布朗和格雷格威尔逊。 （CC BY 3.0。）
对应用程序进行分片后，不能保证进程可以访问每个分片。因此，要呈现响应，需要确保请求路由到可以访问所需数据的进程。如何路由特定请求成为需要解决的重要问题。现在，让我们看一些常见的方法，可以将请求路由到正确的分片，以及如何使用可编写脚本的负载均衡器来解决这个棘手的问题。
使用 DNS 路由请求使用 DNS 路由请求
  对于可以按域名分片的数据模型（例如多租户应用程序），可以使用 DNS 路由到正确的分片。每个分片都对应唯一的域名，该域解析为可以为分片提供请求的进程，如#right_parenthesis_client_requests_dns_add中所示。
1）客户端请求分片上的域的 DNS 地址。2） 客户端将请求定向到 DNS 服务器返回的 IP 到第一个分片的位置。3） 客户端请求在单独的分片上使用域的 DNS 地址。4） 客户端向相应的 DC 发送请求。
此方法的明显好处是其简单性。Web 上的任何应用程序都已在使用 DNS。但是，由于我们都太熟悉了，DNS 附带了一大堆问题。路由信息更改中的收敛可能需要很长时间，这是不可预测的。使用 DNS 还可以限制可用于区分分片的内容（即仅区分域名）。
在应用程序中路由查询在应用程序中路由查询
 如果每个进程都可以访问所有分片，则可以避免确保将请求路由到正确进程的问题。正如#for_every_requestcomma_the_app_server_con向我们展示的那样，连接和正确数据库通信的逻辑随后成为应用程序的责任。
对于每个请求，应用服务器都会动态连接到必要的分片。
这增加了大量的复杂性，并损害了应用程序的可伸缩性。当应用程序超过单个数据中心时，跨数据中心连接所需的延迟使得连接到每个分片在性能方面成为一个昂贵的决策。即使额外的延迟不是问题，每个数据库和应用程序进程必须管理的连接数也会导致其自身的问题（例如，达到最大连接限制）。