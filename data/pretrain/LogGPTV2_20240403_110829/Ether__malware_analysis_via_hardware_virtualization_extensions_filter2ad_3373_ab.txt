(iE,0, iE,1, ..., iE,lE ), and T (P, A) = (iA,0, iA,1, ..., iA,lA ).
For the “only if” part of the proof, assume that PA is trans-
parent; we will prove by induction that T (P, E) = T (P, A).
The base case is trivial because the program starts execu-
tion at the same instruction i0, so iE,0 = iA,0 = i0. For the
induction hypothesis, assuming iE,t = iA,t and we need to
prove that iE,t+1 = iA,t+1. Since PA is transparent, accord-
ing to Deﬁnition 1, we have dp(A) = dp(E) = 0, and P will
not change its execution path. Further, dP (A) = 0 implies
that the data/values in mE,t, cE,t, mA,t, and cA,t that are
visible to P , and hence relevant to the execution of P , must
be the same (otherwise, dP (A) = 1). That is, from P ’s point
of view, the execution semantics in A and E are equivalent.
Therefore, the next instruction in IP executed in A has to
be iE,t+1 as in E (i.e., iA,t+1 = iE,t+1). Using induction, we
have T (P, E) = T (P, A). For the “if” part of the proof, we
assume that T (P, E) = T (P, A) for any malware P , and we
need to prove that the PA is transparent. We prove by con-
tradiction. Assume that PA is not transparent. According
to Deﬁnition 1, we have dp(A) = 1. Therefore, without loss
of generality, P will alter its execution in A, which leads to
the contradiction that T (P, E) 6= T (P, A). Therefore, PA is
transparent.
3.3 Requirements for Transparency
We use Deﬁnition 1 and Theorem 1 as guidelines to formu-
late the requirements for the design of a transparent malware
analyzer. Our discussion here uses a generalization of sev-
eral common hardware and operating system features such
as privilege levels, virtual memory, and exception handling,
which also covers other protection features provided by hard-
ware virtualization. We ﬁrst describe these features as parts
of an extension to the basic program execution semantics in-
troduced in Section 3.1, and then discuss the requirements
for transparent malware analysis.
Similar to information ﬂow models in multi-level security
systems [21], the notion of privilege is essential for reasoning
about how to hide these changes from P . Suppose that there
are n rings of privilege where 0 is the most privileged (or
“highest”) level and n is the least. Let the highest privilege
level gained by the program P during execution in E be
denoted by ΠE(P ).
In order to represent virtual memory, suppose V denotes
all possible virtual memory states viewed by instructions
executed at a speciﬁc privilege level. The entire memory
state M can then be deﬁned as M = V n, where each member
m ∈ M is an n-tuple of memory states, and m[k] ∈ V is
the state of the virtual memory at ring k. Virtual memory
mapping can be expressed by functions µ−
E,r→k, which maps
memory of ring r to ring k and µ+
E,k→r, which maps memory
of ring k to ring r for r > k. By assuming that µ−
E,r→k and
µ+
E,k→r are in m[k], we can express how a higher privilege
ring k code can control how a lower privilege ring r views
its memory.
We use exceptions and exception handling to represent
a broad range of system features such as all privileged in-
structions (e.g. system calls), I/O, memory content or CPU
register protection and access violations, and program and
system faults. An exception occurs when an instruction ex-
ecution requires services or data at a higher privilege level k
than the current level r. A function φE,r→k speciﬁes the ﬁrst
instruction of the exception handler at ring k that handles
the particular exception occurring at ring r.
The instruction execution semantics δE introduced in Sec-
tion 3.1 can be extended to include two parts. The ﬁrst is
δ, the low level or basic instruction execution semantics that
do not involve exceptions, and only deals with access to vir-
tual memory and CPU registers (note that we consider I/O
as exceptions). The second is δE,φ, the semantics that deal
with exceptions (e.g., control transfers to and from exception
handlers residing in privileged levels).
In order to achieve transparency (i.e., dP (A) = 0 and
hence T (P, E) = T (P, A)), the memory and CPU states vis-
ible to P need to be identical in both E and A. However, the
presence of PA and its analysis activities introduce changes
to these entities. Using the extended model described above,
we now formulate the requirements for hiding these changes
and achieving transparency.
1. Higher Privilege: We require that the analyzer PA
have higher privilege than the maximum privilege a malware
instance P can gain. If the maximum privilege gained by
P is π = ΠA(P ), then PA should reside in privilege levels
k < π. For any memory state m ∈ M , besides the code
and data of PA, the memory mapping functions µ−
A,π→k and
µ+
A,k→π as well as the exception handler function φA,π→k
should also reside in m[k]. Proper isolation and protection
can be achieved by ensuring µ+
A,k→π does not map any of
these components to virtual memory state of m[π].
2. No non-privileged side eﬀects: This requirement
states that if PA induces side-eﬀects, access to them should
be privileged and through exception handlers at a higher
privilege level(s) than P ’s. This ensures that any access
to the changes in the memory, CPU registers, etc., can be
intercepted using an exception handler that can hide these
side-eﬀects from P . Similarly, since PA can have timing
side-eﬀects, instructions that can access any notion of time
should be privileged as well.
3. Identical Basic Instruction Execution Seman-
tics: Recall that the basic execution semantics do not in-
volve any exception. From the second requirement above,
the basic semantics do not involve any side-eﬀects intro-
duced by PA (which is privileged and requires exception
handling). Thus, the identical basic semantics, plus trans-
parent exception handling (see requirement 4 below), guar-
antee that the same instruction has the same execution (and
will lead to the same next instruction) in both A and E.
4. Transparent Exception Handling: Suppose that
when the tth instruction is executed (in ring π), an exception
occurs and the control is transferred to φA,π→k in ring k < π.
First, consider the case where there was no equivalent ex-
ception handler in environment E for the same instruction
iE,t (i.e., iE,t was a basic instruction in E).
In this case,
the handler code must ﬁrst guarantee the third requirement
above by executing iA,t with the same semantics as for iE,t.
Then, it has to guarantee that execution is returned to iA,t+1
(the same as iE,t+1) at the end of exception handling. In
addition, the changes in mA,t+1 and cA,t+1 by the exception
handler should only be privileged side-eﬀects to fulﬁll the
second requirement above. Second, if this exception han-
dler replaces an original exception handler φE,π→k in E, it
needs to have identical changes made to mA,t+1 and cA,t+1
as φE,π→k would make to mE,t+1 and cE,t+1 (e.g. results of
system calls remain the same). The cases when the handlers
involve timing measurements are addressed separately, as in
ﬁfth requirement below.
5.
Identical Measurement of Time: This require-
ment states that the timing information received by the
tth instruction iA,t in T (P, A) is the same as it were in
T (P, E).
It is necessary because P can use timing mea-
surement to detect the presence of PA. For P to have a
continuous false view of time it is required that A main-
tain a privileged logical clock that is adjusted when excep-
tions (which include any access to the clock) are handled.
Although the requirement of having identical measurement
of time is very diﬃcult to fulﬁll in practice, it can be de-
composed into smaller requirements that may be easier to
satisfy in many cases. Suppose that the time spent in E to
move from tth instruction to (t + 1)th instruction is ∆E,t.
We can deﬁne ∆E,t = ∆E,δ,t + ∆E,φ,t where ∆E,δ,t is the
time for basic instruction execution and ∆E,φ,t is the ex-
ception handling time. Similarly, ∆A,t = ∆A,δ,t + ∆A,φ,t.
A needs to ensure ∆A,t = ∆E,t by making some adjust-
ments ∆′
A,t. Therefore, we have
∆′
A,t = ∆A,δ,t +∆A,φ,t −∆E,δ,t −∆E,φ,t. If the basic instruc-
tion execution requires the same amount of time in both A
and E, we have ∆′
A,t = ∆A,φ,t − ∆E,φ,t. Thus, when no
exceptions occur for both E and A no adjustment in time
is required. When the an exception occurs for A but not
for E, which is usually due to having privileged side-eﬀects,
∆A,φ,t, the time spent by the exception handler φA, has to
be determined and negated. When both environments have
exceptions, if φA is essentially φE plus some extra activities,
then the extra time (i.e., ∆′
A,t) can be measured and negated
because the activities belonging to φE are executed and can
be timed. However, if φA replaces φE (i.e., implements dif-
ferent activities), then it is very diﬃcult to measure ∆′
because φE is not executed.
A,t, where ∆E,t = ∆A,t − ∆′
A,t
3.4 Fulﬁlling the Requirements
We will now use the requirements presented in Section 3.3
to analyze the transparency achievable by various malware
analysis approaches. In particular, we describe which trans-
parency requirements the reduced privilege guest and full
system emulation based approaches cannot satisfy, and dis-
cuss how hardware virtualization extensions in the x86 ar-
chitecture can overcome these limitations.
Previous malware analysis approaches employ user level or
kernel level counterparts residing in the host in which mal-
ware is analyzed; these include VAMPiRE and CWSandbox.
Since malware that use rootkit components can gain kernel
level privileges, these approaches cannot satisfy the ﬁrst re-
quirement of transparency.
Reduced privilege guest-based virtualization approaches
(e.g., VMware [12] and VirtualPC [11] for x86) can fulﬁll
the ﬁrst requirement by emulating a few sensitive instruc-
tions in order to gain higher privilege over the OS kernel in
the virtual machine. Therefore, the second requirement is
partially satisﬁed by these approaches as they can remove
certain memory and CPU side-eﬀects by providing a virtual
view of memory. However, these approaches are not de-
signed with transparency in mind, and the communication
medium between the guest and host operating systems intro-
duces unprivileged side-eﬀects. Moreover, instructions that
can access time are not privileged, making these side-eﬀects
visible in such systems through time measurement. In con-
trast, full system emulators (e.g. QEMU) emulate the entire
low level instruction execution semantics δ to gain privilege
over the guest OS. They have privilege over all instructions
executed, thereby fulﬁlling the second requirement.
An analyzer based on hardware virtualization extensions
can likewise satisfy the ﬁrst and second requirements. The
ﬁrst requirement is satisﬁed because the analyzer can reside
in a domain more privileged than the guest. This privi-
lege is enforced in hardware by the analyzer residing in ring
-1, which has higher privilege than rings 0 to 3.
In addi-
tion, the contents of the analyzer’s domain are completely
isolated through the use of shadow page tables. Hardware
virtualization extensions not only enable basic memory pro-
tections, but also oﬀer privileged access to sensitive CPU
registers and instructions including instructions that access
time, such as RDTSC. A malware analyzer based on these ex-
tensions can therefore intercept and hide these side-eﬀects
from malware.
Neither reduced privilege guest-based approaches nor full
system emulators can guarantee the third requirement. To
elaborate, emulation-based approaches use low-level instruc-
tion execution semantics function δ′ to simulate the entire
low level execution semantics of δ. For reduced privilege
guest-based approaches, δ′ partially simulates δ. The low
level instruction execution semantics of δ can be easily shown
to be Turing complete. Likewise, δ′ is also Turing complete.
In addition, determining whether δ′ is equivalent to δ re-
quires determining whether all programs exhibit the same
behavior under δ′ and δ.
In automata theory, the above problem would be formally
represented as the problem of determining whether the lan-
guage of two Turing machines (L and L’) are equal; it is
otherwise known as the undecidable problem EQT M [41].
In practice, there have been attacks that detect full system
emulator and reduced privilege guest-based approaches by
exploiting incomplete emulation [27]. There is no way to
guarantee the absence of such attacks.
In contrast, hard-
ware virtualization extensions rely on the same hardware
execution semantics δ, thereby guaranteeing that the third
requirement is satisﬁed.
The fourth requirement is an analyzer design issue and
can be satisﬁed by all approaches, with careful design.
Finally, although emulators can have privileged access
over instructions that can access the notion of time, it is
diﬃcult to provide a notion of time that is equivalent to
the environment E. To elaborate, in emulators, almost all
instructions have exception handlers managing their execu-
tion, and the identiﬁcation of ∆E,t is hard without having a
real system execute these instructions in parallel. Moreover,
the determination of ∆A,t requires a cycle-count accurate
execution simulator, which keeps track of the number of cy-
cles required to execute an instruction in a real system.
In contrast, for hardware virtualization extensions-based
approaches, the side eﬀect on time is privileged because the
instructions that access time (e.g., RDTSC) are privileged.
As we describe next in Section 4, hardware virtualization
extensions maintain a separate execution cycle count in the
hypervisor, which allows an analyzer to adjust a cycle value
before it is given to the guest. As such, while there still
exist complex situations that are hard to satisfy, hardware
virtualization extension-based approaches go a long way in
satisfying the ﬁfth requirement.
4.
IMPLEMENTATION
In this section we describe Ether’s architecture, the low-
level details of how it performs instruction and system call
tracing, and the eﬀorts necessary to ensure transparency
in accordance with the requirements for transparency.
In
addition, we describe implementation challenges and current
architectural limitations that prevent full transparency.
4.1 Environment
To create Ether, we needed an analysis mechanism that
was readily available to researchers and would allow for
transparency. We deemed hardware virtualization exten-
sions as the most appropriate, as they do not interfere with
the original instruction stream IP , the CPU registers C,
the memory state M , the original exception handlers, or
the original CPU transition function δ. In addition to this
transparency, processors with such extensions are inexpen-
sive and widely available.
Among available software that can utilize hardware virtu-
alization extensions, we chose the Xen hypervisor [18] ver-
sion 3.1.0 as the base for implementing Ether. Xen was cho-
sen because it is a mature product, it is open source, and it
has existing communication mechanisms that could be lever-
aged in Ether’s implementation. Finally, our work could
also be incorporated into the numerous research projects
currently supporting Xen.
Among hardware virtualization platforms we selected In-
tel VT due to the available documentation, our familiar-
ity with Intel processors, and the availability of Intel-based
hardware. Finally, as the selection of the target operating
system must well represent the actual install base, we chose
Windows XP (Service Pack 2). Windows XP is the most
common PC operating system in use today and therefore a
preferred target of modern malware.
4.1.1 A brief overview of Xen
The Xen hypervisor is software that runs at the lowest
and most privileged layer of the system. This layer presides
over multiple operating systems (OSes), known as domains,
with one domain having special privileges. The privileged
domain is referred to as domain 0; it serves as the adminis-
trative center of a Xen system. Domain 0 is the ﬁrst domain
started and the only domain with direct access to real hard-
ware. The guest OSes, also referred to as domUs, rely on
the hypervisor for privileged operations. The domUs may
be commodity, unmodiﬁed operating systems. Ether runs
as a component in the hypervisor layer, and as a userspace
component in domain 0. The analysis target, Windows XP
with Service Pack 2, runs in a domU.
4.1.2 A brief overview of Intel VT hardware Virtual-
ization Extensions