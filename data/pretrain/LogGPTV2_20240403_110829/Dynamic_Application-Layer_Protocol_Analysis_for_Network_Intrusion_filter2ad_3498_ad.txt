HTTP is, not surprisingly, the most prevalent of the four
protocols: at UCB during the one-day period, 99% of the
roughly 970,000 reported off-port connections are HTTP.
Of these, 28% are attributed to Gnutella, 22% to Apache,
and 12% to Freechal [15]. At MWN, 92% of the 250,000
reported connections are HTTP, and 7% FTP (of these
70% were initiated by the same host). Of the HTTP con-
nections, roughly 21% are attributed to BitTorrent, 20%
to Gnutella, and 14% to SOAP.
That protocol analyzers can now extract protocol se-
mantics not just for HTTP but also for the other proto-
cols proves to be quite valuable. PIA-Bro generates
detailed protocol-level log ﬁles for all connections. A
short glance at, for example, an FTP log ﬁle quickly re-
veals whether an FTP server deserves closer attention.
Figure 3 shows an excerpt of such a log ﬁle for an ob-
tered them on a regular basis. To further reduce the load on the monitor
machines, we excluded a few high volume hosts, including the Plan-
etLab servers at UCB and the heavily accessed leo.org domain at
MWN.
7In this context, a server is an IP address that accepts connections
and participates in the protocol exchange. Due to NAT address space,
we may underestimate or overestimate the number of actual hosts.
266
Security ’06: 15th USENIX Security Symposium
USENIX Association
xxx.xxx.xxx.xxx/2373 > xxx.xxx.xxx.xxx/5560 start
response (220 Rooted Moron Version 1.00 4 WinSock ready...)
USER ops (logged in)
SYST (215 UNIX Type: L8)
[...]
LIST -al (complete)
TYPE I (ok)
SIZE stargate.atl.s02e18.hdtv.xvid-tvd.avi (unavail)
PORT xxx,xxx,xxx,xxx,xxx,xxx (ok)
*STOR stargate.atl.s02e18.hdtv.xvid-tvd.avi, NOOP (ok)
ftp-data video/x-msvideo ‘RIFF (little-endian) data, AVI’
[...]
response (226 Transfer complete.)
[...]
QUIT (closed)
Figure 3: Application-layer log of an FTP-session to a
compromised server (anonymized/edited for clarity).
viously compromised host at MWN. During a two-week
period, we found such hosts in both environments, al-
though UCB as well as MWN already deploy Snort sig-
natures supposed to detect such FTP servers.
With PIA-Bro, any protocol-level analysis automati-
cally extends to non-standard ports. For example, we de-
vised a detector for HTTP proxies which matches HTTP
requests going into a host with those issued by the same
system to external systems. With the traditional setup,
it can only report proxies on well-known ports; with
PIA-Bro in place, it has correctly identiﬁed proxies in-
side the UCB and MWN networks running on different
ports;8 two of them were world-open.
It depends on a site’s policy whether offering a service
on a non-standard port constitutes a problem. Both uni-
versity environments favor open policies, generally tol-
erating offering non-standard services. For the internal
servers we identiﬁed, we veriﬁed that they meet at least
basic security requirements. For all SMTP servers, for
example, we ensured that they do not allow arbitrary re-
laying. One at MWN which did was quickly closed after
we reported it, as were the open HTTP proxies.
5.2 Payload Inspection of FTP Data
According to the experience of network operators, at-
tackers often install FTP servers on non-standard ports
on machines that they have compromised. PIA-Bro
now not only gives us a reliable way to detect such
servers but, in addition, can examine the transferred ﬁles.
This is an impossible task for traditional NIDSs, as FTP
is a protocol for which for the data-transfer connections
by design use arbitrary port combinations. For security
monitoring, inspecting the transferred data for ﬁles ex-
changed via non-standard-port services enables alerts on
sensitive ﬁles such as system database accesses or down-
load/upload of virus-infected ﬁles. We introduced a new
ﬁle analyzer to perform such analysis for FTP data con-
8As observing both internal as well as outgoing requests at border
is rather unusual, this detection methodology generally detects proxies
other than the site’s intended ones.
nections, as well as for other protocols used to trans-
fer ﬁles. When PIA-Bro learns, e.g., via its analysis
of the control session, of an upcoming data transfer, it
adds the expected connection to the dynamic prediction
table (see §4.2). Once this connection is seen, the system
instantiates a ﬁle analyzer, which examines the connec-
tion’s payload.
The ﬁle analyzer receives the ﬁle’s full content as a
reassembled stream and can utilize any ﬁle-based in-
trusion detection scheme. To demonstrate this capabil-
ity, our ﬁle-type identiﬁcation for PIA-Bro leverages
libmagic [25], which ships with a large library of ﬁle-
type characteristics. This allows PIA-Bro to log the
ﬁle-type’s textual description as well as its MIME-type
as determined by libmagic based on the payload at the
beginning of the connection. Our extended FTP analyzer
logs—and potentially alerts on—the ﬁle’s content type.
Figure 3 shows the result of the ﬁle type identiﬁcation
in the ftp-data line. The NIDS categorizes the data
transfer as being of MIME type video/x-msvideo
and, more speciﬁcally, as an AVI movie. As there usu-
ally are only a relatively small number of ftp-data con-
nections, this mechanism imposes quite minimal perfor-
mance overhead.
We envision several extensions to the ﬁle analyzer.
One straight-forward improvement, suggested to us by
the operators at LBNL, is to match a ﬁle’s name with
its actual content (e.g., a ﬁle picture.gif requested
from a FTP server can turn out to be an executable). An-
other easy extension is the addition of an interface to a
virus checker (e.g., Clam AntiVirus [7]). We also plan
to adapt other protocol analyzers to take advantage of
the ﬁle analyzer, such as TFTP (once PIA-Bro has sup-
port for UDP) and SMTP. TFTP has been used in the
past by worms to download malicious code [3]. Simi-
larly, SMTP can pass attachments to the ﬁle analyzer for
inspection. SMTP differs from FTP in that it transfers
ﬁles in-band, i.e., inside the SMTP session, rather than
out-of-band over a separate data connection. Therefore,
for SMTP there is no need to use the dynamic predic-
tion table. Yet, we need the capabilities of PIA-Bro
to pipeline the analyzers: ﬁrst the SMTP analyzer strips
the attachments’ MIME-encoding, then the ﬁle analyzer
inspects the ﬁle’s content.
5.3 Detecting IRC-based Botnets
Attackers systematically install trojans together with bots
for remote command execution on vulnerable systems.
Together, these form large botnets controlled by a hu-
man master that communicates with the bots by sending
commands. Such commands can be to ﬂood a victim,
send spam, or sniff conﬁdential information such as pass-
words. Often, thousands of individual bots are controlled
USENIX Association
Security ’06: 15th USENIX Security Symposium
267
by a single master [1], constituting one of the largest se-
curity threats in today’s Internet.
The IRC protocol [22] is a popular means for commu-
nication within botnets as it has some appealing proper-
ties for remote control: it provides public channels for
one-to-many communication, with channel topics well-
suited for holding commands; and it provides private
channels for one-to-one communication.
It is difﬁcult for a traditional NIDS to reliably detect
members of IRC-based botnets. Often, the bots never
connect to a standard IRC server—if they did they would
be easy to track down—but to a separate bot-server on
some non-IRC port somewhere in the Internet. However,
users also sometimes connect to IRC servers running on
non-standard ports for legitimate (non-policy-violating)
purposes. Even if a traditional NIDS has the capability
of detecting IRC servers on non-standard ports, it lacks
the ability to then distinguish between these two cases.
We used PIA-Bro to implement a reliable bot-
detector that has already identiﬁed a signiﬁcant num-
ber of bot-clients at MWN and UCB. The detector op-
erates on top of the IRC analyzer and can thus perform
protocol-aware analysis of all detected IRC sessions. To
identify a bot connection, it uses three heuristics. First,
it checks if the client’s nickname matches a (customiz-
able) set of regular expression patterns we have found
to be used by some botnets (e.g., a typical botnet “nick”
identiﬁer is [0]CHN|3436036). Second, it examines
the channel topics to see if it includes a typical botnet
command (such as .advscan, which is used by vari-
ants of the SdBot family[1]). Third, it ﬂags new clients
that establish an IRC connection to an already identiﬁed
bot-server as bots. The last heuristic is very powerful, as
it leverages the state that the detector accumulates over
time and does not depend on any particular payload pat-
tern. Figure 4 shows an excerpt of the list of known
bots and bot-servers that one of our operational detec-
tors maintains. This includes the server(s) contacted as
well as the timestamp of the last alarming IRC command.
(Such timestamps aid in identifying the owner of the sys-
tem in NAT’d or DHCP environments.) For the servers,
the list contains channel information, including topics
and passwords, as well as the clients that have contacted
them.
At MWN the bot-detector quickly ﬂagged a large
number of bots. So far, it has identiﬁed more than
100 distinct local addresses. To exclude the danger of
false positives, we manually veriﬁed a subset. To date,
we have not encountered any problems with our detec-
tion. Interestingly, at UCB there are either other kinds
of bots, or not as many compromised machines; during a
two-week time period we reported only 15 internal hosts
to the network administrators. We note that the NIDS,
due to only looking for patterns of known bots, certainly
Detected bot-servers:
IP1 - ports 9009,6556,5552 password(s)  last 18:01:56
channel #vec:
topic ".asc pnp 30 5 999 -b -s|.wksescan 10 5 999 -b -s|[...]"
channel #hv:
topic ".update http://XXX/image1.pif f’’, password(s) XXX"
[...]
Detected bots:
IP2 - server IP3 usr 2K-8006 nick [P00|DEU|59228] last 14:21:59
IP4 - server IP5 usr XP-3883 nick [P00|DEU|88820] last 19:28:12
[...]
Figure 4: Excerpt of the set of detected IRC bots and
bot-servers (anonymized/edited for clarity).
misses victims; this is the typical drawback of such a
misuse-detection approach, but one we can improve over
time as we learn more signatures through other means.
Of the detected bots at MWN, only ﬁve used static IP
addresses, while the rest used IP addresses from a NAT’d
address range, indicating that most of them are private,
student-owned machines. It is very time-consuming for
the MWN operators to track down NAT’d IP addresses
to their actual source. Worse, the experience at MWN is
that even if they do, many of the owners turn out to not
have the skills to remove the bot. Yet, it is important that
such boxes cannot access the Internet.
The MWN operators accomplish this with the help of
our system. They installed a blocking system for MWN’s
NAT subnets to which we interface with our system. The
operators have found the system’s soundness sufﬁciently
reliable for ﬂagging bots that they enabled it to block all
reported bots automatically. They run this setup oper-
ationally, and so far without reporting to us any com-
plaints. In the beginning, just after our system went on-
line, the average number of blocked hosts increased by
10-20 addresses. After about two weeks of operation,
the number of blocked hosts has almost settled back to
the previous level, indicating that the system is effective:
the number of bots has been signiﬁcantly reduced.
Finally, we note that our detection scheme relies on the
fact that a bot uses the IRC protocol in a fashion which
conforms to the standard IRC speciﬁcation. If the bot
uses a custom protocol dialect, the IRC analyzer might
not be able to parse the payload. This is a fundamental
problem similar to the one we face if a bot uses a propri-
etary protocol. More generally we observe that the set-
ting of seeing malicious clients and servers violates an
important assumption of many network intrusion detec-
tion systems: an attacker does not control both endpoints
of a connection [31]. If he does, any analysis is at best a
heuristic.
6 Evaluation
We ﬁnish with an assessment of the performance impact
of the PIA architecture and a look at the efﬁcacy of the
268
Security ’06: 15th USENIX Security Symposium
USENIX Association
multi-step protocol recognition/veriﬁcation process. The
evaluation conﬁrms that our implementation of the PIA
framework does not impose an undue performance over-
head.
6.1 CPU Performance
To understand the performance impact of the PIA exten-
sions to Bro, we conduct CPU measurements for both the
unmodiﬁed Bro (developer version 1.1.52), referred to as
Stock-Bro, and PIA-Bro running on the ﬁrst 66 GB
of the mwn-full-packets trace which corresponds
to 29 minutes of trafﬁc. (This trace again excludes the
domain leo.org.) The trace environment consists of a
dual-Opteron system with 2GB RAM, running FreeBSD
6.0.
In addition to the processing of
the (default)
Stock-Bro conﬁguration, PIA-Bro must also per-
form four types of additional work: (i) examining all
packets; (ii) performing signature matches for many
packets; and (iii) buffering and reassembling the begin-
nings of all streams to enable reliable protocol detection;
(iv) performing application-layer protocol analysis on
additionally identiﬁed connections. In total, these con-
stitute the cost we must pay for PIA-Bro’s additional
detection capabilities.
To measure the cost of each additional analysis ele-
ment, we enable them one by one, as reported in Ta-
ble 4. We begin with basic analysis (Config-A): Bro’s
generation of one-line connection summaries, as well as
application-layer protocol analysis for FTP, HTTP, IRC,
SMTP connections, as identiﬁed via port numbers. The
ﬁrst line reports CPU times for both versions of Bro per-
forming this regular analysis, and the second line when
we also enable Bro signatures corresponding to those
used by PIA-Bro for protocol detection. We ﬁnd the
runtimes of the two systems quite similar, indicating that
our implementation of the PIA architecture does not add
overhead to Bro’s existing processing. (The runtime of
PIA-Bro is slightly less than Stock-Bro due to mi-
nor differences in their TCP bytestream reassembly pro-
cess; this also leads PIA-Bro to make slightly fewer
calls to Bro’s signature engine for the results reported be-
low. The runtimes of both systems exceed the duration
of the trace, indicating that we use a conﬁguration which,
in this environment, requires multiple NIDS instances in
live operation.)
With Config-A, the systems only need to process a
subset of all packets: those using the well-known ports
of the four protocols, plus any with TCP SYN/FIN/RST
control packets (which Bro uses to generate generic TCP
connection summaries). Bro uses a BPF [27] ﬁlter to dis-
card any other packets. However, PIA-Bro cannot use
this ﬁltering because by its nature it needs to examine all
packets. This imposes a signiﬁcant performance penalty,
which we assess in two different ways.
First, we preﬁlter the trace to a version containing only
those packets matched by Bro’s BPF ﬁlter, which in this
case results in a trace just under 60% the size of the orig-
inal. Running on this trace rather than the original ap-
proximates the beneﬁt Bro obtains when executing on
systems that use in-kernel BPF ﬁltering for which cap-
tured packets must be copied to user space but discarded
packets do not require a copy. The Table shows these
timings as Config-A’. We see that, for this environ-
ment and conﬁguration, this cost for using PIA is minor,
about 3.5%.
Second, we manually change the ﬁlters of both sys-
tems to include all TCP packets (Config-B). The user
time increases by a fairly modest 7.5% for Stock-Bro
and 7.4% for PIA-Bro compared to Config-B. Note
that here we are not yet enabling PIA-Bro’s additional
functionality, but are only assessing the cost to Bro of
processing the entire packet stream using the above con-
ﬁguration; this entails little extra work for Bro since it
does not perform application analysis on the additional
packets.
PIA-Bro’s use of signature matching also imposes
overhead. While most major NIDSs rely on signature
matching, the Bro system’s default conﬁguration does
not. Accordingly, applying the PIA signatures to the
packet stream adds to the system’s load. To measure its
cost, we added signature matching to the systems’ con-
ﬁguration (second line of the table, as discussed above).
The increase compared to Config-A is about 15–16%.
When we activate signatures for Config-B, we ob-
tain Config-C, which now enables essentially the full
PIA functionality. This increases runtime by 24–27%
for Stock-Bro and PIA-Bro, respectively. Note that
by the comparison with Stock-Bro running equivalent
signatures, we see that capturing the entire packet stream
and running signatures against it account for virtually all
of the additional overhead PIA-Bro incurs.
As the quality of the signature matches improves when
PIA-Bro has access to the reassembled payload of the
connections, we further consider a conﬁguration based
on Config-C that also reassembles the data which the
central manager buffers. This conﬁguration only ap-
plies to PIA-Bro, for which it imposes a performance
penalty of 1.2%. The penalty is so small because most
packets arrive in order [9], and we only reassemble the
ﬁrst 4KB (the PIA buffer size).
As we can detect most protocols within the ﬁrst KBs
(see §4.2), we also evaluated a version of PIA-Bro that
restricts signature matching to only the ﬁrst 4KB. This
optimization, which we annotate as PIA-Bro-M4K,
yields a performance gain of 16.2%. Finally, adding re-
assembly has again only a small penalty (2.1%).
USENIX Association
Security ’06: 15th USENIX Security Symposium
269
Stock-Bro
PIA-Bro
PIA-Bro-M4K
Config-A
Config-A’
Config-B
Config-C
Standard
Standard + sigs
Standard
All TCP pkts
All TCP pkts + sigs
All TCP pkts + sigs + reass.
3335
3843
3213
3584
4446
—
3254
3778
3142
3496
4436
4488
—
—
—
—