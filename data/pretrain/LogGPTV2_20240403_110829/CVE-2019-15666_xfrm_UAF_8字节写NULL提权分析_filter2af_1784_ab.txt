                continue;
            }
            hlist_for_each_entry(pol, chain, bydst) {
                if (policy->priority >= pol->priority)
                    newpos = &pol->bydst;
                else
                    break;
            }
            if (newpos)
                hlist_add_behind_rcu(&policy->bydst, newpos);
            else
                hlist_add_head_rcu(&policy->bydst, chain);
        }
      ... ...
    }
第（3）步，`[9]`之后，两个policy不再连贯，但`policy2`仍然指向`policy1`
第（4）步，释放`[9]`中`bydst`的`policy1`，由于`policy2`不在`bydst`中，所以没有被释放，且`policy2`的pprev指针仍然指向释放后的
`policy1`。
[xfrm_policy_flush()](https://elixir.bootlin.com/linux/v5.0.18/source/net/xfrm/xfrm_policy.c#L1770)
    int xfrm_policy_flush(struct net *net, u8 type, bool task_valid)
    {
        int dir, err = 0, cnt = 0;
        struct xfrm_policy *pol;
        ... ...
    again:
        list_for_each_entry(pol, &net->xfrm.policy_all, walk.all) {
            dir = xfrm_policy_id2dir(pol->index);
            if (pol->walk.dead ||
                dir >= XFRM_POLICY_MAX ||
                pol->type != type)
                continue;
            __xfrm_policy_unlink(pol, dir);
            spin_unlock_bh(&net->xfrm.xfrm_policy_lock);
            cnt++;
            xfrm_audit_policy_delete(pol, 1, task_valid);
            xfrm_policy_kill(pol);                                                // [10] 释放
            spin_lock_bh(&net->xfrm.xfrm_policy_lock);
            goto again;
        }
        ... ...
    }
    EXPORT_SYMBOL(xfrm_policy_flush);
    static void xfrm_policy_kill(struct xfrm_policy *policy)
    {
        policy->walk.dead = 1;
        atomic_inc(&policy->genid);
        if (del_timer(&policy->polq.hold_timer))
            xfrm_pol_put(policy);
        skb_queue_purge(&policy->polq.hold_queue);
        if (del_timer(&policy->timer))
            xfrm_pol_put(policy);
        xfrm_pol_put(policy);
    }
第（5）步，当`policy2`超时后，将对`policy2`进行unlink操作：[__xfrm_policy_unlink()](https://elixir.bootlin.com/linux/v5.0.18/source/net/xfrm/xfrm_policy.c#L2202)
->
[__hlist_del()](https://elixir.bootlin.com/linux/v5.0.18/source/include/linux/list.h#L697)
    static struct xfrm_policy *__xfrm_policy_unlink(struct xfrm_policy *pol,
                            int dir)
    {
        struct net *net = xp_net(pol);
        if (list_empty(&pol->walk.all))
            return NULL;
        /* Socket policies are not hashed. */
        if (!hlist_unhashed(&pol->bydst)) {
            hlist_del_rcu(&pol->bydst);                    // [11] 对bydst list上 policy2 调用 __hlist_del() 
            hlist_del_init(&pol->bydst_inexact_list);
            hlist_del(&pol->byidx);
        }
        list_del_init(&pol->walk.all);
        net->xfrm.policy_count[dir]--;                    // [8] dir=4, 导致越界减一
        return pol;
    }
    // [11] __hlist_del()
    static inline void __hlist_del(struct hlist_node *n)
    {
        struct hlist_node *next = n->next;
        struct hlist_node **pprev = n->pprev;
        WRITE_ONCE(*pprev, next);                        // [12] policy2 的pprev指针仍然指向释放后的 policy1，这样导致 policy1 的next指针被写为null。导致8字节写
        if (next)
            next->pprev = pprev;
    }
###  1-3 unlink过程分析
插入到bydst后，效果如图。总的来说，最后能往空闲块pol1（[xfrm_policy](https://elixir.bootlin.com/linux/v5.0.18/source/include/net/xfrm.h#L572)
结构）中的`xfrm_policy->bydst.next`写NULL，也就是空闲块的第2个8字节。
    // 删除 pol1
    next = pol1->next = NULL;
    pprev = pol1->pprev = pol2;
    *pprev = next         ==>     pol2->next = NULL;
    next->pprev = pprev  // 没有操作        最终 pol2->pprev = pol1。pol2还引用这释放后的pol1值。可堆喷站位pol1。
    // 删除 pol2
    next = pol2->next =NULL
    pprev = pol2->pprev =pol1
    pprev = next         ==>     pol1->next = NULL
    next->pprev = pprev // 没有操作
[xfrm_policy](https://elixir.bootlin.com/linux/v5.0.18/source/include/net/xfrm.h#L572)
结构如下，大小为0x358（v4.10.7版本），cred结构大小为0xa8。能将cred结构中的`gid/suid`覆盖为NULL，拥有suid =
0的进程就可以成功的利用seteuid, setresuid提权成功。
    // 能将空闲块 xfrm_policy 结构的第2个8字节写NULL
    struct xfrm_policy {
        possible_net_t        xp_net;        // 8 bytes
        struct hlist_node    bydst;        
        struct hlist_node    byidx;
        ...
    }
    typedef struct {        // possible_net_t
    #ifdef CONFIG_NET_NS
        struct net *net;
    #endif
    } possible_net_t;
    struct hlist_node {        // hlist_node
        struct hlist_node *next, **pprev;
    };
    // 对比 cred 结构, 能将对应的 gid/suid 覆盖为0
    struct cred {
        atomic_t    usage;                                        // 4 bytes
        uid_t        uid;        /* real UID of the task */        // 4 bytes
        gid_t        gid;        /* real GID of the task */        // 4 bytes
        uid_t        suid;        /* saved UID of the task */     // 4 bytes
        gid_t        sgid;        /* saved GID of the task */
        uid_t        euid;        /* effective UID of the task */
        gid_t        egid;        /* effective GID of the task */
        uid_t        fsuid;        /* UID for VFS ops */
        gid_t        fsgid;        /* GID for VFS ops */
        unsigned    securebits;    /* SUID-less security management */
        kernel_cap_t    cap_inheritable; /* caps our children can inherit */
        kernel_cap_t    cap_permitted;    /* caps we're permitted */
        kernel_cap_t    cap_effective;    /* caps we can actually use */
        kernel_cap_t    cap_bset;    /* capability bounding set */
    ......
    };
## 2\. 漏洞利用
**堆喷**
：堆喷用到了[setxattr+userfaultfd堆喷](https://xz.aliyun.com/t/2814)。setxattr往内核拷贝的是用户栈上未初始化的0x1000字节，所以利用的关键并非布置数据，而是用作堆占位。那么`kmalloc-1024`（`xfrm_policy`对象）是如何覆盖`kmalloc-192`（`cred`对象，位于
[dedicated cache-cred_jar](https://elixir.bootlin.com/linux/v4.15/source/kernel/cred.c#L573)）堆块的呢？
`cred_jar` 是一个 `kmem_cache` ,每次 释放一个无用的 cred 的时候不会直接释放占用的内存 而是放入
`cred_jar`，高频使用的数据结构都有这样一个缓存机制。
**cache转化**
：SLAB/SLUB分配器采用slabs来管理物理内存页，slabs有三种状态，分别是empty（所有对象都空闲）、partial（包含使用的和空闲的对象）、full（所有对象都被使用）。当Linux内核打算释放
`empty slab`时，相应的物理页返回到可用的页池中，所以某些情况下，这些页可用从一种cache转化为另一种cache。
**利用思路**
：这里我们按照exp中的说法，将这两个policy称为`policy0`和`policy1`。最开始`policy0`和`policy1`都位于`kmalloc-1024`，当`policy0`被释放后，相应的内存被另一种cache
`kmalloc-192`也即cred结构占用，再利用`policy1`对空闲块进行8字节NULL写。详细EXP的步骤如下表所示，从上往下是大致时间线：
(1) 父进程—触发漏洞 | (2) Process 0~249—堆喷射 | (3) Process 250~299—堆喷射 | (4) Process
300~1999—提权  
---|---|---|---  
sleep(2) | 设置userfaultfd() | 设置userfaultfd() |  `sleep(8)` 等待`policy0`被释放  
sleep(2) |  `pthread_create(handler)`错误处理子线程 |  `pthread_create()`错误处理子线程 |  
|  `setxattr()`喷射 1024 字节 | **读`wait_for_pol0[]`时阻塞，等`(1)`** |  
| **`handler()`读`wait_for_bug[]`时阻塞，等`(1)`** |  |  
创建`policy0`：`__xfrm_add_policy0()` |  |  |  
sleep(1) |  |  |  
**`close(wait_for_pol0[])`解除阻塞** |  |  |  
|  |  `setxattr()`喷射 1024 字节 |  
|  | **`handler()`读`wait_for_bug[]`时阻塞，等`(1)`** |  
`policy0`被 `kmalloc-1024`包围 |  |  |  
创建`policy1`：`__xfrm_add_policy1()` timer = 7 -> sleep(7) |  |  |  
`__xfrm_hash_rebuild()` |  |  |  
sleep(1) |  |  |  
`__xfrm_flush_policy0()` 释放`policy0` |  |  |  
**`close(wait_for_bug[])`解除阻塞** |  |  |  
|  `handler()`拷贝数据，释放`kmalloc-1024` |  `handler()`拷贝数据，释放`kmalloc-1024` |  
|  |  | 子进程调用`setgid()`促使内核分配cred  
|  |  | sleep(5)  
`policy1`超时 **触发漏洞** ，`policy0->next`被写NULL |  |  |  
|  |  | 检查cred是否被覆盖为NULL  
|  |  | 如果为root则将当前用户添加到sudo组  
|  |  |  `exit(1)`通知父进程，提权成功！  
**利用步骤** ：
  *     1. 父进程创建`policy0`，用`setattr()`在`policy0`之前和之后喷射`kmalloc-1024`，这样就能保证`policy0`和`policy1`相距很远，且不在同一slab中（便于之后`policy0`所在的slab被释放，接着被cred使用）；
  *     1. 父进程创建`policy1`，并调用`__xfrm_hash_rebuild()`和`__xfrm_flush_policy0()`，等待`policy1`超时触发漏洞；
  *     1. `setxattr()`所喷射的`kmalloc-1024`对象被释放，很有可能与`policy0`相邻，这样相应的slab为empty也被释放；
  *     1. 子进程300~1999调用`setgid()`促使分配子进程的cred结构，很有可能复用了`policy0`的内存。调用链——[setgid()](https://elixir.bootlin.com/linux/v4.15/source/kernel/sys.c#L400) -> [prepare_creds()](https://elixir.bootlin.com/linux/v4.15/source/kernel/cred.c#L244)
  *     1. 如果子进程的`gid`和`suid`被覆盖为NULL（调用`seteuid(0)`来检测），则有了root权限，可以更新`/etc/sudoers`，添加当前用户为sudoer，使当前用户具备持久的root权限。
**成功提权** ：
## 参考
[CVE-2019-15666 Ubuntu / CentOS / RHEL Linux Kernel 4.4 – 4.18 privilege
escalation](https://duasynt.com/blog/ubuntu-centos-redhat-privesc)
[[原创]cve-2019-15666 xfrm_policy 提权漏洞](https://bbs.pediy.com/thread-261968.htm)
[Exploiting CVE-2019-15666 by reversing the binary PoC](https://blog-cyber.riskeco.com/en/exploiting-cve-2019-15666-by-reversing-the-binary-poc/)
[Linux kernel (3.x-5.x) use-after-free in the XFRM
subsystem](https://duasynt.com/pub/vnik/01-0311-2018.pdf)
[CVE-2019-15666-Exploit](https://github.com/riskeco/Lucky/blob/master/lucky0_RE.c)
[信号量释放和等待函数sem_post()和sem_wait()](https://blog.csdn.net/megayangyang/article/details/55662170)
[The Slab Allocator in the Linux kernel](https://hammertux.github.io/slab-allocator)
[因黑客尝试利用超算来挖矿，部分超算被逼下线](https://www.expreview.com/74281.html)
[欧洲多国超级计算机被挖矿软件“团灭”](https://www.aqniu.com/news-views/67510.html)