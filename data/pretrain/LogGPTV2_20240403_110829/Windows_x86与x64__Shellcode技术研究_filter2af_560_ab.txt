函数地址列表RVA(相对虚拟地址)，位于导出表偏移0x01c处。该列表包含全部导出函数入口的RVA。
**(2).AddressOfNames**
函数名称列表RVA，位于导出表偏移0x020处。该列表包含函数名称字符串的RVA。有名称的导出函数的名称字符串RVA都定义在这个表中，但是不是所有的导出函数都有名称，如图2-6所示，在urlmon.dll的导出表中，前4个函数均无名称。  
 **(3)AddressOfNameOrdinals**
函数索引列表的RVA，位于导出表偏移0x024处，该列表与函数名称列表中的项目一一对应，该列表的值代表函数名称列表中的函数在函数地址列表中的索引，这样就可以通过函数名称获取到函数的RVA。例如，函数名称列表的第n
项指向FunctionA，那么可以去查找函数索引列表中的第n 项，假如第n 项中存放的值是x，则表示函数地址表中的第x
项函数地址对应的就是FunctionA的地址。  
至此可以得出由DLL的基址获取函数地址的方法。如图2-6所示，在DLL基址处存储的是PE文件的DOS头；在DOS头偏移0x03c处存储NT头的偏移，在NT头偏移0x18处存储的是NT可选头的地址；NT可选头的偏移0x60处存储的是DataDirectory数组，该数组的第一项是导出表信息结构体，包含导出表地址与大小；获取导出表的地址后，在偏移0x20处获取函数名列表的RVA，遍历函数名列表，与目标函数名FunctionA相比较，确定FunctionA在函数名列表中的索引NO.A，然后在函数索引列表中NO.A索引处获取目标函数在函数地址列表中的索引NO.A’，在函数地址列表的NO.A’索引处获取到的RVA就是FunctionA的RVA，将RVA与DLL基址相加即获得FunctionA的基址。  
综上所述，kernel32.dll可以通过上述方法获取LoadLibrary与GetProcAddress函数地址。然后由LoadLibrary加载其他DLL并获取DLL在内存中的基址，同理可以获取其他函数地址。  
不难发现获取函数地址有两种方法：一是直接根据DLL基址，通过上述在导出表中查找函数名的方法获取函数地址；二是通过上述方法获取kernel32.dll中的GetProcAddress方法，然后通过GetProcAddress获取函数地址。这两种方法各有优缺点：
**(1)方法一：由于直接对PE文件进行操作，不需要Windows API，通用性较好，但是生成的Shellcode较长。**
**(2)方法二：通过GetProcAddress函数获取函数地址，依赖于Windows API 通用性较低，但是生成的Shellcode较短。**
由于Shellcode最终是要放进缓冲区的，所以Shellcode的大小会影响其通用性。当Shellcode中涉及到的函数较多，一般在遍历导出表中的函数名列表时不会直接用函数名(如MessageBoxA)，首先会对函数名进行hash运算，在搜索时也需要对函数名列表中的函数名进行hash运算，然后比较hash所得的摘要。
如代码2-1所示，根据上述可以得出由DLL基址获取导出表基址的汇编代码。如代码2-2所示，由DLL导出表的基址获取具体函数的地址的汇编代码相对复杂，其原理与上述分析一致。
###  2.2 Windows x64 定位函数
Windows
x64与x86定位函数的基本原理与方法是一致的。如图2-8所示，存在的主要区别是导出表在NT可选头中的偏移不同。导出表中的各个字段的偏移都是一致的。由于在PE文件中的偏移地址是32位的，所以32位的获取函数地址的汇编代码2-2试用于Windows
x64。  
## 三、函数调用
通过第一章与第二章的分析，在Windows x86和x64中定位函数地址后，通过指令call
即可调用函数。在Shellcode中还需要解决两个问题：参数传递与堆栈平衡。在Windows
x86中，函数调用约定采用stdcall方式，该方式的特点是：所有参数入栈，通过椎栈传递；二是被调用的函数负责栈指针esp的恢复。Windows
x86的函数调用本文不再详述，下面详细分析Windows x64函数调用的参数传递和堆栈平衡两个问题。  
如图3-1所示，Windows
x64比x86增加了8个64位通用寄存器：R8、R9、R10、R11、R12、R13、R14、R15，另外还增加了8个128位XMM寄存器。x86中原有的寄存器在x64中均为扩展为64位，且名称的第一个字母从E改为R。仍可以在64位程序中调用32位的寄存器，如RAX（64位）、EAX（低32）、AX（低16位）、AL（低8位），相应的有R8、R8D、R8W和R8B。
Windows
x64下函数调用约定与x86的fastcall相似，使用寄存器传参递前四个参数，分别使用RCX、RDX、R8与R9传递，其他多余的参数使用堆栈传递。虽然前4个参数通过寄存器传递，仍然需要在堆栈中为其预留空间。  
堆栈空间由函数调用者管理，程序不再是每经过一个call，堆栈就变化一次。而是在每一个call开头，先计算出所需要的堆栈总空间，然后一次分配全部的空间，到函数结束才全部释放。在调用其他函数时不会再次新建堆栈空间来存放参数，而是直接利用前面新建的空间来进行，入栈操作也从
push指令改为mov指令。所有的栈操作都通过rsp指针来完成，所以rsp在一个函数空间中的值不会变化。栈基指针寄存器ebp在x64中被弃用，只是作为一个普通寄存器使用，因此push
与 pop 这类会改变rsp值的指令是不能随便使用。
下面通过一个例子说明x64的参数传递与堆栈平衡这个问题。如图3-2所示，例子中定义一个函数add，该函数的功能是求和，共有6个参数。使用VS2008的x64平台编译生成可执行程序x64Test.exe。通过WinDbg
x64将x64Test.exe反编译，结果如图3-3和3-4所示。
如图3-2所示，在main函数中首先通过指令[sub rsp,48h]为main函数分配0x48个字节的堆栈空间，在mian函数结束时通过[add
rsp,48h]回收这48h的堆栈空间。分别通过rcx、rdx、r8与r9分别传递第1、2、3与4参数。如图3-5所示，堆栈前0x20
(32)个字节为前4个参数预留，接着就是第5和6个参数。在参数传递时还是按照从右至左的顺序。  
如图3-4所示，在add函数开始时并没有重新分配堆栈空间，只是在栈顶处抬高了8个字节用于存储函数的返回地址(RIP)。如图3-5所示，add函数首先会把前4个参数入栈，由于栈顶指针已经被抬高8个字节，所以第一个参数rcx从[rsp
+ 8]处入栈，入栈顺序也是从右至左。在函数返回时不再需要通过[ret n]平衡堆栈了，因为堆栈没有变化。  
值得一提的是栈需要16字节对齐，由于RCX、RDX、R8、R9四个寄存器预留是0x20个字节，但是call指令会入栈一个8字节的返回值(RIP)，所以函数开始时分配堆栈空间时需分配16n
+ 8个字节来平衡堆栈。
综上所述x64函数调用以下特点：
**(1)的前4个参数通过寄存器传递，其他通过堆栈传递** **。**
**(2) 函数调用者负责管理堆栈。**
**(3) 堆栈空间一次性分配与回收。**
**(4) 堆栈指针rsp不再变化，ebp被弃用，push与pop需慎用。不需要[ret n]平衡堆栈。**
**(5) 函数调用者需为寄存器参数预留堆栈空间。**
所以，在开发x64的shellcode时，不需要过多的关注堆栈的变化，只需在开始时分配足够的堆栈空间即可。
## 四、Shellcode编码
Shellcode编码是Shellcode开发的过程中不可缺少的部分，关系到Shellcode能否正确部署与运行。因为在很多漏洞利用场景中Shellcode的内容会受到一些限制。
**(1) 特殊字符**  
有的漏洞场景要求在Shellcode中只能是可见字符的ASCII或Unicode；有的漏洞场景不能出现某些字符如NULL(0x00)，如在没有检查缓冲区大小时使用strcpy导致缓冲区溢出时，就不能将带有NULL的Shellcode拷贝进缓冲区。
**(2) Shellcode特征**
通过前三章的分析可知，Shellcode在定位kernel32.dll、定位函数等方面的代码相对固定，特征较明显，易被拦截。  
可以通过编码的方法使Shellcode达到要求，但是需求将解码Shellcode的指令加到Shellcode的前面。在执行时，先执行解码指令，将Shellcode释放到指定内存位置，然后执行Shellcode指令。Shellcode编码技术在x86中已经成熟，而且x64与x86差别较小，本章不再详述。
## 五、总结
Windows x64与x86
Shellcode的原理与开发流程基本一致，但是在寄存器、地址偏移与函数调用等很多细节上还是存在较大差异。如果不能掌握这些细节，在开发与移植x64
Shellcode时会遇到很多问题。Shellcode的通用性和长度通常不能兼得，所以不要过度的追求其通用性。另外还有很多关于Shellcode的问题本文没有提到，如指令复用、Shellcode瘦身等。
## 参考
[1].
Windows下shellcode编写入门:  
[2]. Windows X64汇编入门:  
[3]. Windows86与x64
Shellcode框架:  
[4]. Windows x64 shellcode编写指南:  
[5]. DLL导出表结构:  
[6]. Windows x64汇编参数传递:  
[7]. Windows x86的LDR链:  
[8]. PEB与TEB详解:  
[9]. FS寄存器解析:  
[10]. PEB数据解析:  
[11]. 0day安全软件漏洞分析技术.王清  
[12]. 逆向工程核心原理.李承远