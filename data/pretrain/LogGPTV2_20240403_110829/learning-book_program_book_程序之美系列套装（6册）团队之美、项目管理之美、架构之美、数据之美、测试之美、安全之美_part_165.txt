享的。通信由“会话服务”或“通道”来实现中介，它们抽象了通信的
真实端点，而且支持特定的会话和通道从一个服务器移动到另一个
服务器上。因此，所有任务都可以运行在任意一个游戏服务器的实
例上，同时不改变任务的语义。
这使得Darkstar的基本伸缩机制看起来很简单。如果有一台机器超
载了，只要将一些任务从这台机器移到另一台负载较小的机器就行
了。如果所有的机器都超载了，就向运行着Darkstar栈和游戏/虚拟
世界的集群中添加新的机器。底层的负载平衡软件会将负载分发给
新的机器。
对单台机器的负载进行监控并在需要时重新分配负载，这是元服务
的工作。这些元服务是网络层面的服务，对于游戏或虚拟世界的程
序员是不可见的，但是它们对Darkstar栈中的服务是相互可见的。
例如，这些元服务会监控哪些机器正在运行（并监控是否有机器失
效），哪些用户与某台机器有关，不同的机器当前的负载。由于元
服务对于游戏或虚拟世界的程序员是不可见的，所以它们在任何时
候都可以改变，不会影响到游戏逻辑的正确性。这让我们能够尝试
不同的策略和方法，实现系统的动态负载平衡，也让我们能够丰富
基础设施所需的元服务集合。
同样，我们使用实现多机伸缩机制来实现系统的高容错。由于任务
和通信机制所使用的数据是与具体机器无关的，所以很明显，我们
可以将任务从一台机器移到另一台机器上。但是如果机器失效，我
们如何恢复在那台机器上执行的任务呢？答案很简单：任务本身也
是持久对象，保存在系统的“数据服务”中。因此，如果一台机器失
效，该机器上正在执行的所有任务都被视为中断的事务，会重新调
度在不同的机器上执行。尽管这种重新调度比在一台机器上重新调
度中断的任务的延迟要长，但系统的正确性是不变的。系统的用户
（游戏玩家或虚拟世界的居民）顶多会注意到响应时间暂时有点延
长。这样的延迟让人有点不舒服，但总好过现在其他游戏或虚拟世
926
---
## Page 928
界环境中服务器崩溃所造成的影响。在那些环境中，会导致玩家掉
线，还可能导致相当一部分游戏状态的丢失。
[L]更准确地说，所有的任务都由字节码的序列组成，可以在Java虚
拟机上执行。我们不关心源语言是什么，我们只关心从源语言编译
出来的结果可以运行在所有支持游戏或虚拟世界的分布式环境中。
3.4关于架构的思考
也许所有人关于架构及其实现的第一个问题就是它的性能。虽然未
经深思熟虑就对架构进行优化是诸多罪恶之源，但是我们也可能设
计出一个架构，而它的实现根本不可能达到好的性能。由于
Darkstar架构的一项基本选择，这种担心是真实的。而且由于游戏
行业的特点，确定服务器基础设施的性能是很难的。
要确定游戏或虚拟世界服务器基础设施的性能，其难度源自一个简
单的事实：没有针对大规模MIMO或虚拟世界的性能测试标准或共
同接受的例子。缺少性能测试标准并不奇怪，因为绝大多数游戏或
虚拟世界的服务器组件都是针对特定的游戏或虚拟世界从头开发
的。只有少数的通用基础设施可以作为可复用的构建块，这些组件
一般是事后从特定的游戏或虚拟世界中提取出来的，提供给其他构
建类似游戏的人使用。也许是因为游戏行业还比较年轻，或是因为
娱乐业中出现重要技术的偶然性，结果是没有共同接受的性能测试
标准用于测试新的基础设施，也无法对不同的基础设施进行比较。
关于游戏或虚拟世界的预期计算、数据操作和通信负载也基本上没
有什么资料，所以很难创建性能测试标准程序。部分原因是已有的
服务器都是定制的。每台服务器都是为特定的游戏或虚拟世界设计
的，所以考虑的是那款游戏或虚拟世界的具体负载特征。而且，这
种状况也是因为游戏业的强烈的保密性。在游戏业中，关于一款游
戏并发的信息是严格保密的，而且发布游戏的实现方式也是严格保
密的。同时，行业中的许多人对这些信息是不感兴趣的。大量的思
考和讨论集中在艺术设计、故事情节或玩家交互模式上，这些令新
游戏更有趣、更好玩，而不是游戏服务器的设计方式和游戏为支持
并发玩家（这个数字也是严格保密的）所采取的伸缩性技术。所
以，获得现有的游戏和虚拟世界的这种服务器负载信息都很困难。
根据我们的经验，即使我们能够找来开发者，谈论他们的游戏或虚
拟世界加在服务器上的负载，他们也常常会报告错误的信息。这不
927
---
## Page 929
是因为他们想保持商业优势而故意错误报告他们服务器的情况，而
是因为他们真的自己不也了解。在游戏服务器上基本不会加入一些
手段，让他们收集有关服务器真实性能或完成事务的信息。对于这
种服务器的分析一般最多是经验性的。程序员在服务器上工作，直
到它让游戏玩起来有趣，这是一种选代式的工作方式，而不是仔细
对代码本身进行测量。在这些系统中，更多的是手工技术活，而不
是科学测定。
这并不是说，这些游戏或虚拟世界后面的服务器是一些粗制滥造的
代码，也不是说它们做得不好。实际上，许多代码是效率杰作，展
示了聪明的编程技巧，也展示了针对高要求的应用构造一次性、专
门目的服务器的优势。但是，为每个游戏或虚拟世界构建一个新服
也没有共同接受的机制来比较不同的基础设施。
3.4.1并行与延迟
缺少有关服务器可接受的性能的资料，这一点引起了Darkstar团队
的特别关注，因为我们所做的一些关键决定，都是围绕着如何能够
从游戏或虚拟世界服务器中获得好的性能。也许Darkstar架构和一
般实践之间的最大区别就在于，Darkstar架构拒绝在服务器的主内
存中存放任何重要的信息。所有生存周期超过一次具体任务的数据
都需要持久在“数据服务”中，这是实现Darkstar基础设施功能的核
心。这让基础设施能够检测到并发问题，反过来又让系统能够对程
序员隐藏这些问题，同时让服务器能够利用多核架构。它也是实现
整体伸缩性的关键组件，支持任务从一台服务器移动到另一台服务
器，从而在一组机器上实现负载平衡。
在游戏和虚拟世界服务器领域，任何时候都持久保存游戏状态是一
种异端邪说，因为人们普遍很关心延迟。在编写这种服务器时，大
家的观点是只有将所有信息都放在内存中才能让延迟足够小，达到
要求的响应时间。可以偶尔保存状态的快照，但对交互速度的要求
表明，这种长时间的操作只能够偶尔进行，而且要在后台进行。所
以，从表面上看，我们的架构似乎绝不可能达到足够好的性能，从
而服务于它的目标应用。
虽然要求数据持久肯定是这个架构的主要不同之处，而且要求通过
“数据服务”来访问数据会在架构中引入一定的延迟，但我们相信我
们所采取的方式更具有竞争力，原因有儿点。首先，我们相信能够
928
---
## Page 930
让访问内存数据和访问“数据服务”中的数据之间的差异远远小于一
般人们的看法。虽然在概念上每个生命周期超出一次任务的对象都
需要从持久存储中读出，并写入持久存储，但实现这种存储可以利
用人们在数据库缓存和一致性方面多年的研究成果，从而减少因这
种方式而导致的数据访问延迟。
如果我们能够将访问局限在一个特定服务器上的几组特定对象，就
更是如此了。如果用到一组特定对象的那些任务都运行在一台服务
器上，那么就可以利用该服务器的缓存，达到接近内存的对象读写
速度（受到需要满足的持久性约束的影响）。我们可以识别任务属
于哪些玩家或虚拟世界的哪些用户。这样，我们就可以利用基础设
施中服务所接收到的数据访问和通信请求，来收集特定时刻游戏或
虚拟世界中数据访问模式和通信模式的信息。有了这些信息，我们
相信能够非常准确地估计哪些玩家应该与另一些玩家放在一起。因
为我们可以根据需要将玩家移动到任何服务器上，所以能够根据观
察到的运行时行为，主动地将相关的玩家尽可能地放在同一台服务
器上。这让我们能够运用数据库领域熟悉的标准缓存技术，尽量减
少访问和保存持久信息的延迟。
这听起来非常像目前在大规模游戏和虚拟世界中为实现伸缩性而采
用的地理区域分解技术。在这种技术中，服务器开发者将世界分解
成一些区域，将它们指派给一些服务器，不同的区域就成为用户分
区的机制。同一区域的玩家比不同区域的玩家进行交互的可能性更
大，所以这种集中在一个服务器上的优势就体现出来了。不同之处
在于，目前的地理区域分解是在游戏并发过程中进行的，被编入源
代码，放到服务器上。而我们的位置集中基于运行时的信息，可以
根据游戏中发生的实际玩法和交互模式来实现动态调整。这类似于
编译时优化和运行时优化之间的区别。前一种方法试图针对程序所
有可能的运行进行优化，而后一种方法试图针对当前的运行进行优
化。
我们不相信我们能够消除内存访问和持久访问之间的差别，而且我
们也不认为有必要这样做，最后让这种架构比使用内存的架构性能
更好。要知道，通过让所有的数据持久，我们可以支持在服务器上
使用多线程（从而也支持多核）。尽管我们不相信并发是完美的
（即对于每个添加的核，我们都能充分利用），但我们确实相信在
游戏和虚拟世界中可以使用大量的并行运算（初步的结果也证实了
这种看法）。如果可使用的并行运算超过我们可能引入的延迟，那
么游戏或虚拟世界的总体性能就会更好。
929
---
## Page 931
3.4.2赌未来
我们对多核处理器中多线程的信心基本上是在赌处理器将来的发展
方向。目前服务器的处理器提供2～32个核，我们相信将来的芯片
设计将集中向更多的核发展，而不是让现有的核以更高的时钟频率
运行。当我们在几年前并始这个项目时，这种赌博似乎比现在更具
投机性。那时候，我们在做展示时常常说这种设计是一种“假定”的
演练，说我们正尝试一种架构，如果芯片性能更好地支持多线程而
不是单线程的时钟速度，这种架构将是可行的。这就是在研究实验
室中进行这类项目的好处之一，可以接受设计方法中存在很高的风
险，探索一个将来也许在商业上可行的领域。我们决定构建一个以
多线程为中心的架构，与这个决定做出时相比，目前芯片设计的趋
势让我们看得更清楚。!L即使我们只能得到50%的完美并发，如果
我们能把使用持久存储的延迟控制在使用内存的延迟的2～16倍，
就能够在性能上持平。我们相信在并发方面以及减少访问持久状态
和全内存方案之间的差异方面都可以做得更好。但是结果主要取决
于构建于这个基础设施之上的应用的使用模式（我们曾提到，这一
点很难发现）。
我们也不应认为减少延迟就是这个基础设施的唯一目标。通过将游
戏或虚拟世界服务器端的对象全部保存在“数据服务”中，我们把因
服务器失效而导致的数据丢失减到了最小。实际上，在大多数情况
下，服务器失效时用户只会注意到延时有一点增加，因为任务（它
们本身也是持久对象）从失效的服务器移到了另一台服务器上。没
有数据会丢失。一些缓存机制可能导致丢失几秒钟的游戏成果，但
即使是这样，也比在线游戏和虚拟世界目前使用的机制好得多，它
们只是将偶尔进行内存快照作为主要的持久方式。在它们的基础设
施中，如果服务器在不巧的时间崩溃，可能会造成数小时的游戏成
果丢失。只要延迟是可以接受的，Darkstar所使用持久机制的可靠
性更高，这对于在这个基础设施上构建系统的并发者和系统的用户
来说都是优点。
[1].再一次说明，在早期的设计决定中少许的运气是很重要的。
3.4.3简化程序员的工作
实际上，如果在支持伸缩性的同时减少延迟是服务器开发者的唯一
目标，那么开发者最好的方法就是专门针对特定的游戏，编写自己
的分布式和多线程基础设施。但这要求服务器开发者处理复杂的分
930
---
## Page 932
布式和并发编程。在为速度需求而过度烦恼之前，我们应该想到
Darkstar的第二个同样重要的目标，即在支持多线程、分布式游戏
产品的同时，为程序员提供一个单机单线程的并发模型。
在相当大的程度上，我们已经实现了这一目标。通过将所有任务封
装到事务中，并在“数据服务”中检测数据冲突，程序员就能够享受
到多线程的好处，又不必在他们的代码中引入锁协议、同步和信号
量。程序员不必担心如何将玩家从一台服务器移到另一台服务器，
因为Darkstar为他们提供了透明的负载平衡。编程模型虽然有自己
的风格和限制，但社区中的早期成员认为，这对他们开发的那种游