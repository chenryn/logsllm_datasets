## 小结今天我介绍了一些 HTTPS迁移的技术要点，掌握了它们你就可以搭建出一个完整的 HTTPS 站点了。但想要实现大型网站的"全站HTTPS"还是需要有很多的细枝末节的工作要做，比如使用 CSP（Content SecurityPolicy）的各种指令和标签来配置安全策略，使用反向代理来集中"卸载"SSL，话题太大，以后有机会再细谈吧。简单小结一下今天的内容：1.  [从 HTTP 迁移到 HTTPS 是"大势所趋"，能做就应该尽早做；]{.orange}2.  [升级 HTTPS 首先要申请数字证书，可以选择免费好用的"Let's    Encrypt"；]{.orange}3.  [配置 HTTPS 时需要注意选择恰当的 TLS    版本和密码套件，强化安全；]{.orange}4.  [原有的 HTTP 站点可以保留作为过渡，使用 301 重定向到    HTTPS。]{.orange}
## 课下作业1.  结合你的实际工作，分析一下迁移 HTTPS 的难点有哪些，应该如何克服？2.  参考上一讲，你觉得配置 HTTPS 时还应该加上哪些部分？欢迎你把自己的学习体会写在留言区，与我和其他同学一起讨论。如果你觉得有所收获，也欢迎把文章分享给你的朋友。![unpreview](Images/66939de236bace65daa1aeeb26db52e6.png){savepage-src="https://static001.geekbang.org/resource/image/db/ec/dbe386f94df8f69fc0b32d2b52e3b3ec.png"}![unpreview](Images/4913a489805db29b38aefa585223c013.png){savepage-src="https://static001.geekbang.org/resource/image/56/63/56d766fc04654a31536f554b8bde7b63.jpg"}
# 30 \| 时代之风（上）：HTTP/2特性概览在[第 14讲](https://time.geekbang.org/column/article/103746)里，我们看到 HTTP有两个主要的缺点：安全不足和性能不高。刚结束的"安全篇"里的 HTTPS，通过引入 SSL/TLS在安全上达到了"极致"，但在性能提升方面却是乏善可陈，只优化了握手加密的环节，对于整体的数据传输没有提出更好的改进方案，还只能依赖于"长连接"这种"落后"的技术（参见[第17 讲](https://time.geekbang.org/column/article/104949)）。所以，在 HTTPS 逐渐成熟之后，HTTP就向着性能方面开始"发力"，走出了另一条进化的道路。在[第 1 讲](https://time.geekbang.org/column/article/97837)的 HTTP历史中你也看到了，"秦失其鹿，天下共逐之"，Google 率先发明了 SPDY协议，并应用于自家的浏览器 Chrome，打响了 HTTP 性能优化的"第一枪"。随后互联网标准化组织 IETF 以 SPDY 为基础，综合其他多方的意见，终于推出了HTTP/1 的继任者，也就是今天的主角"HTTP/2"，在性能方面有了一个大的飞跃。
## 为什么不是 HTTP/2.0你一定很想知道，为什么 HTTP/2 不像之前的"1.0""1.1"那样叫"2.0"呢？这个也是很多初次接触 HTTP/2 的人问的最多的一个问题，对此 HTTP/2工作组特别给出了解释。他们认为以前的"1.0""1.1"造成了很多的混乱和误解，让人在实际的使用中难以区分差异，所以就决定HTTP 协议不再使用小版本号（minor version），只使用大版本号（majorversion），从今往后 HTTP 协议不会出现HTTP/2.0、2.1，只会有"HTTP/2""HTTP/3"......``{=html}这样就可以明确无误地辨别出协议版本的"跃进程度"，让协议在一段较长的时期内保持稳定，每当发布新版本的HTTP 协议都会有本质的不同，绝不会有"零敲碎打"的小改良。
## 兼容 HTTP/1由于 HTTPS 已经在安全方面做的非常好了，所以 HTTP/2的唯一目标就是改进性能。但它不仅背负着众多的期待，同时还背负着 HTTP/1庞大的历史包袱，所以协议的修改必须小心谨慎，兼容性是首要考虑的目标，否则就会破坏互联网上无数现有的资产，这方面TLS 已经有了先例（为了兼容 TLS1.2 不得不进行"伪装"）。那么，HTTP/2 是怎么做的呢？因为必须要保持功能上的兼容，所以 HTTP/2 把 HTTP分解成了"[语义]{.orange}"和"[语法]{.orange}"两个部分，"语义"层不做改动，与HTTP/1 完全一致（即RFC7231）。比如请求方法、URI、状态码、头字段等概念都保留不变，这样就消除了再学习的成本，基于HTTP 的上层应用也不需要做任何修改，可以无缝转换到 HTTP/2。特别要说的是，与 HTTPS 不同，HTTP/2 没有在 URI里引入新的协议名，仍然用"http"表示明文协议，用"https"表示加密协议。这是一个非常了不起的决定，可以让浏览器或者服务器去自动升级或降级协议，免去了选择的麻烦，让用户在上网的时候都意识不到协议的切换，实现平滑过渡。在"语义"保持稳定之后，HTTP/2 在"语法"层做了"天翻地覆"的改造，完全变更了HTTP 报文的传输格式。
## 头部压缩首先，HTTP/2 对报文的头部做了一个"大手术"。通过"进阶篇"的学习你应该知道，HTTP/1里可以用头字段"Content-Encoding"指定 Body 的编码方式，比如用 gzip压缩来节约带宽，但报文的另一个组成部分------Header却被无视了，没有针对它的优化手段。由于报文 Header 一般会携带"UserAgent""Cookie""Accept""Server"等许多固定的头字段，多达几百字节甚至上千字节，但Body 却经常只有几十字节（比如 GET 请求、204/301/304响应），成了不折不扣的"大头儿子"。更要命的是，成千上万的请求响应报文里有很多字段值都是重复的，非常浪费，"长尾效应"导致大量带宽消耗在了这些冗余度极高的数据上。所以，HTTP/2把"**头部压缩**"作为性能改进的一个重点，优化的方式你也肯定能想到，还是"压缩"。不过 HTTP/2并没有使用传统的压缩算法，而是开发了专门的"**HPACK**"算法，在客户端和服务器两端建立"字典"，用索引号表示重复的字符串，还釆用哈夫曼编码来压缩整数和字符串，可以达到50%\~90% 的高压缩率。
## 二进制格式你可能已经很习惯于 HTTP/1里纯文本形式的报文了，它的优点是"一目了然"，用最简单的工具就可以开发调试，非常方便。但 HTTP/2在这方面没有"妥协"，决定改变延续了十多年的现状，不再使用肉眼可见的 ASCII码，而是向下层的 TCP/IP 协议"靠拢"，全面采用二进制格式。这样虽然对人不友好，但却大大方便了计算机的解析。原来使用纯文本的时候容易出现多义性，比如大小写、空白字符、回车换行、多字少字等等，程序在处理时必须用复杂的状态机，效率低，还麻烦。而二进制里只有"0"和"1"，可以严格规定字段大小、顺序、标志位等格式，"对就是对，错就是错"，解析起来没有歧义，实现简单，而且体积小、速度快，做到"内部提效"。以二进制格式为基础，HTTP/2 就开始了"大刀阔斧"的改革。它把 TCP协议的部分特性挪到了应用层，把原来的"Header+Body"的消息"打散"为数个小片的**二进制"帧"**（Frame），用"HEADERS"帧存放头数据、"DATA"帧存放实体数据。这种做法有点像是"Chunked"分块编码的方式（参见[第 16讲](https://time.geekbang.org/column/article/104456)），也是"化整为零"的思路，但HTTP/2数据分帧后"Header+Body"的报文结构就完全消失了，协议看到的只是一个个的"碎片"。![](Images/0ef04b64e86687bf5ccad42d4c777ae8.png){savepage-src="https://static001.geekbang.org/resource/image/8f/96/8fe2cbd57410299a1a36d7eb105ea896.png"}
## 虚拟的"流"消息的"碎片"到达目的地后应该怎么组装起来呢？HTTP/2为此定义了一个"**流**"（Stream）的概念，**它是二进制帧的双向传输序列**，同一个消息往返的帧会分配一个唯一的流ID。你可以想象把它成是一个虚拟的"数据流"，在里面流动的是一串有先后顺序的数据帧，这些数据帧按照次序组装起来就是HTTP/1 里的请求报文和响应报文。因为"流"是虚拟的，实际上并不存在，所以 HTTP/2 就可以在一个 TCP连接上用"**流**"同时发送多个"碎片化"的消息，这就是常说的"**多路复用**"（Multiplexing）------多个往返通信都复用一个连接来处理。在"流"的层面上看，消息是一些有序的"帧"序列，而在"连接"的层面上看，消息却是乱序收发的"帧"。多个请求/响应之间没有了顺序关系，不需要排队等待，也就不会再出现"队头阻塞"问题，降低了延迟，大幅度提高了连接的利用率。![](Images/daa3f4a6d88b4bf0e94735642a26b09e.png){savepage-src="https://static001.geekbang.org/resource/image/d8/bc/d8fd32a4d044f2078b3a260e4478c5bc.png"}为了更好地利用连接，加大吞吐量，HTTP/2还添加了一些控制帧来管理虚拟的"流"，实现了优先级和流量控制，这些特性也和TCP 协议非常相似。HTTP/2 还在一定程度上改变了传统的"请求 -应答"工作模式，服务器不再是完全被动地响应请求，也可以新建"流"主动向客户端发送消息。比如，在浏览器刚请求HTML 的时候就提前把可能会用到的 JS、CSS文件发给客户端，减少等待的延迟，这被称为"**服务器推送**"（ServerPush，也叫 Cache Push）。