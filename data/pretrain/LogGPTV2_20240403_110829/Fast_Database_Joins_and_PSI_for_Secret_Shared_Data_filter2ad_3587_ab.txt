the shares xi, xi+1 mod 3. We use the notation (cid:74)x(cid:75)i to refer to share xi. (cid:74)x(cid:75) can
locally be converted to a 2-out-of-2 sharingx where Pi holds x(cid:48)
k. x can also be converted
0 and Pj holds x(cid:48)
back to(cid:74)x(cid:75) using one round of communication.
1, e.g. i = 0, j = 1. xk refers to x(cid:48)
1
s.t. x = x(cid:48)
0 ‚äï x(cid:48)
2.4 Cuckoo Hash Tables
The core data structure that our protocols employ is a cuckoo hash table which is
parameterized by a capacity n, two (or more) hash functions h0, h1 and a vector T
which has m = O(n) slots, T [1], ..., T [m]. For any x that has been added to the hash
table, there is an invariant that x will be located at T [h0(x)] or T [h1(x)]. Testing if
an x is in the hash table therefore only requires inspecting these two locations. x is
added to the hash table by inserting x into slot T [hi(x)] where i ‚àà {0, 1} is picked
at random. If there is an existing item at this slot, the old item y is removed and
reinserted at its other hash function location. Typically the required table size is
m ‚âà 1.6n for Œª = 40 bits of statistical security, see [DRRT18].
3 Our Construction
3.1 Overview
First we describe our join algorithm without any privacy and then we will discuss
how this translates to the secret shared setting. Figure 1 depicts our algorithm with
the following phases:
1. Y is inserted into a cuckoo hash table T based on the join-key(s). That is, let
us assume the columns Y1 and X1 are the join keys. Then row Y [i] is inserted
at T [j] for some j ‚àà {h0(Y1[i]), h1(Y1[i])}.
7
(cid:74)Y(cid:75)
T = Cuckoo(Y )
(cid:98)Y 0
(cid:98)Y 1
X
1) Cuckoo hash Y
using oblv. permutation.
‚àÉj s.t. T [hj(Y [i])] = Y [i].
2) Select Cuckoo locations T [hj(X[i])]
using oblv. switching network.
(cid:98)Y j[i] = T [hj(X[i])].
3) Compare (cid:98)Y 0[i],(cid:98)Y 1[i] w/ X[i]
using MPC circuit and
construct output row.
Figure 1: Overview of the join protocol using oblivious switching network.
2. Each row X[i] needs to be compared with the rows T [j] for j ‚àà {h0(X1[i]), h1(X1[i])}.
As such, T [h0(X1[i])] is mapped to a new row (cid:98)Y 0[i] and T [h1(X1[i]) to (cid:98)Y 1[i].
be located at (cid:98)Y 0[i] or (cid:98)Y 1[i]. As such, these rows can directly be compared to
3. It is now the case that if row X[i] has a machining key in Y , then this row will
determine if there is a match on the join keys and the where clause evaluates
to true. Let bi = 1 if there is such a match and 0 otherwise.
4. Various types of joins can then be constructed from locally comparing row i
from these tables, i.e. X[i],(cid:98)Y 0[i],(cid:98)Y 1[i]. For example, an inner join is con-
either (cid:98)Y 0[i] or (cid:98)Y 1[i] depending on which one matches. If there is no match,
structed from all the rows where bi = 1 by selecting the values from X[i] and
then that output row is set to NULL.
The main challenge in bringing the described algorithm to the secret shared
setting is constructing the cuckoo hash table T and selecting rows from T with-
out leaking sensitive information. We achieve this with the use an MPC friendly
randomized encoding and a new three-party protocol called an oblivious switching
network.
Let us continue to assume that the columns X1 and Y1 are the join-keys. Our
protocol begins by generating a randomized encoding for each of the secret shared
this encoding which takes secret shares from the parties, apply a PRF Fk to the
reconstructed value using a internally sampled key k, and returns the resulting value
join-key (cid:74)xi(cid:75) ‚àà(cid:74)X1(cid:75) and (cid:74)yi(cid:75) ‚àà(cid:74)Y1(cid:75). Figure 2 contains the ideal functionality for
to one of the three parties. For (cid:74)xi(cid:75) :=(cid:74)X1(cid:75)[i], P0 will learn Fk(xi) while P1 will
learn Fk(yi) for(cid:74)yi(cid:75) :=(cid:74)Y1(cid:75)[i]. Since the join-keys xi (resp. yi) are unique and k is
Party P1 proceeds by constructing a secret shared cuckoo hash tableT from
the rows of (cid:74)Y(cid:75) where the hash function values for row i are deÔ¨Åned as hj(yi) =
secret shared cuckoo tableT such that row Y [i] is located at T [hj(yi)] for some
H(j||Fk(yi)). Note that P1 knows only the randomized encodings Fk(yi) of each row
Y [i], and not the contents of the row itself. The goal in this step is to construct a
not known, this can be simulated by sending random values to P0 (resp. P1).
8
‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶transformation shown in Figure 1.
switching network, the parties employ an MPC protocol to directly compare these
cret shared between P0 and P1. Party P0, who knows the randomized encodings
In particular, assuming we use two
cuckoo hash functions, then P0 constructs two oblivious switching networks that
how such a network operates is discussed later but the result is two new tables
inputs a permutation œÄ, all parties input secret shares of Y , and the result is secret
shares of ‚ÄúY permuted according to œÄ‚Äù which forms T (details follow later). This
completes Step 1 and is the Ô¨Årst transformation shown in Figure 1.
j. We constructT using a three-party oblivious permutation protocol where P1
It is now the case that T is a valid cuckoo hash table of (cid:74)Y(cid:75) which is se-
Fk(xi) for all (cid:74)xi(cid:75) := (cid:74)X1(cid:75)[i], now must compare the rows of T indexed by
hj(xi) = H(j||Fk(xi)) with the row (cid:74)X(cid:75)[i].
maps the sharesT [h0(xi)] andT [h1(xi)] to be ‚Äúaligned‚Äù with(cid:74)X(cid:75)[i]. Exactly
(cid:98)Y 0,(cid:98)Y 1 such that T [hj(xi)] = (cid:98)Y j[i]. This completes Step 2 and is the second
Once the shares of (cid:98)Y 0[i] = T [h0(xi)],(cid:98)Y 1[i] = T [h1(xi)] are obtained using the
rows with(cid:74)X(cid:75)[i]. That is, they compute a bit(cid:74)b(cid:75) which equals one if the join-keys
are equal and the where clause P ((cid:98)Y j[i],(cid:74)X(cid:75)[i]) outputs one for some j. For each
row, the output row for an inner join is constructed as S((cid:98)Y j[i],(cid:74)X(cid:75)[i]) using MPC
the secret shared Ô¨Çag(cid:74)b(cid:75) indicating whether this row is set to NULL.
all of the rows of X where the comparison bit (cid:74)b(cid:75) is zero. Regardless of the type
Left joins work in a similar way except that all rows of X are output and marked
not NULL. Finally, unions can be computed by including all of Y in the output and
where S is the user deÔ¨Åned selection circuit. In addition, the MPC circuit outputs
of join, the protocols do not reveal any information about the tables. In particular,
not even the cardinality of the join is revealed due to the use of NULL rows.
ality takes as input several tuples ((cid:74)Bi(cid:75),(cid:74)Xi(cid:75), Pi) where Bi ‚àà {0, 1}d is an array of
3.2 Randomized Encodings
The randomized encoding functionality Fencode of Figure 2 enables the parties to
coordinate their secret shares without revealing the underlying values. In particular,
the parties will construct a cuckoo hash table using these encodings. The function-
d bits, Xi ‚àà ({0, 1}œÉ)d is a array of d strings and Pi that denotes that party Pi
should be output the encodings for this tuple. The functionality assigns a random
(cid:96) bit encoding for each input x ‚àà {0, 1}œÉ. For j ‚àà [d], if the bit Bi[j] = 0 then the
functionality outputs the encoding for Xi[j] and otherwise a random (cid:96) bit string.
Looking forward, Bi[j] = 1 will mean that the key Xi[j] is actually set to NULL and
a random encoding should be returned.
LowMC Encodings. We realize this functionality using the LowMC block cipher[ARS+15].
When implemented with the honest majority MPC protocols[AFL+16], this ap-
proach results in extremely high throughput, computing up to one million encodings
per second. Once the parties have their secret shared inputs, they sample a secret
9
[Encode] Upon receiving command (Encode, {((cid:74)Bi(cid:75),(cid:74)Xi(cid:75), Pi)}) from all parties where
Parameters: Input string size of œÉ bits and output encoding size of (cid:96) bits.
Xi ‚àà ({0, 1}œÉ)di, Bi ‚àà {0, 1}di for some di ‚àà Z‚àó.
1. Sample a uniformly random F : {0, 1}œÉ ‚Üí {0, 1}(cid:96). DeÔ¨Åne F (cid:48) : {0, 1} √ó {0, 1}œÉ ‚Üí
{0, 1}(cid:96) as F (cid:48)(b, x) = bF (x) + br where r ‚Üê {0, 1}(cid:96) is sampled each call.
2. For each ((cid:74)Bi(cid:75),(cid:74)Xi(cid:75), Pi), send {F (cid:48)(b, x) | (b, x) ‚àà zip(Bi, Xi)} to Pi.
Figure 2: The Randomized Encoding ideal functionality Fencode
shared LowMC key uniformly and encrypt each input under that key using the MPC
protocol. These encryptions are revealed as the encodings to the appropriate party.
The LowMC cipher is parameterized by a block size (cid:96), keys size Œ∫, s-boxes per
layer m and the desired data complexity d. To set these parameters, observe that the
adversary only sees a bounded number of block cipher outputs (encodings) per key.
As such, the data complexity can be bounded by this value. For our implementation
we upper bound the number of outputs by d = 230. The remaining parameters are
set to be (cid:96) ‚àà {80, 100} and m = 14 which results in r = 13 rounds and computational
security of Œ∫ = 128 bits[ARS+15]. The circuit for (cid:96) = 80 contains 546 and gates
(meaning each party will send only 546 bits per encoding).
One issue with the LowMC approach alone is that the input size is Ô¨Åxed to
be at most (cid:96) ‚àà {80, 100} bits. However, we will see that the larger join protocol
requires an arbitrary input size œÉ. This is accommodated by applying a universal
hash function to the input shares. SpeciÔ¨Åcally, the parties jointly pick a random
matrix E ‚Üê {0, 1}œÉ√ó(cid:96). The parties can then locally multiply each secret shared
input before it is sent into the LowMC block cipher.
The security of this transformation follows from xE (cid:54)= x(cid:48)E with overwhelming
probability if x (cid:54)= x(cid:48). In particular, f (x) = xE is a universal hash function given
that E is independent of x. As such the probability that f (x) = f (x(cid:48)) for any x (cid:54)= x(cid:48)
is 2‚àí(cid:96). Applying the birthday bound we obtain that probability of any collisions
i di is
among the tuples is 2‚àí(cid:96)+p where p = log2 D2/2 = 2 log2(D) ‚àí 1 and D =(cid:80)
the total number of encodings.
Conditioned on the inputs to the block cipher being unique, the outputs of the
block cipher is also distinct and indistinguishable from random (cid:96) bit strings. As
such, in the simulation the real outputs can be replaced with that of the ideal
functionality so long as 2‚àí(cid:96)+p is statistically negligible, i.e. (cid:96) ‚àí p ‚â• Œª.
3.3 Oblivious Switching Network
The ideal functionality of a switching network was introduced by Mohassel and
Sadeghian[MS13]. It obliviously transform a vector A = (A1, ..., An) such that the
output is A(cid:48) = (AœÄ(1), ..., AœÄ(m)) for an arbitrary function œÄ : [m] ‚Üí [n]. The ac-
companying protocol of [MS13] was designed in the two party setting where the Ô¨Årst
party inputs A while the second party inputs a description of œÄ. We introduce a
10
Input, output size of œÉ, (cid:96) bits (respectively). Computational security
Parameters:
parameter Œ∫.
each Xi ‚àà ({0, 1}œÉ)di . Let d = maxi(di).
[Encode] Upon receiving command (Encode, {((cid:74)Bi(cid:75),(cid:74)Xi(cid:75), Pi)}) from all parties where
1. If œÉ > (cid:96), the parties jointly sample a matrix E ‚àà {0, 1}œÉ√ó(cid:96). Otherwise E is the
œÉ √ó (cid:96) identity matrix.
2. The parties have Fmpc evaluate the following circuit:
(a) Uniformly sample a key k for a LowMC cipher with block size (cid:96), security Œ∫
and data complexity at least d blocks.
(b) For each ((cid:74)Bi(cid:75),(cid:74)Xi(cid:75), Pi) input pair, reveal {F (cid:48)(b, x) | (b, x) ‚àà zip(Bi, Xi)}
to Pi where F (cid:48)(b, x) = LowMCk(xE) ‚äï br and r ‚Üê {0, 1}(cid:96) is sampled for
each call.
Figure 3: The randomized encoding LowMC protocol.
Parameters: 3 parties denoted as the Pp, Ps and Pr. Elements are strings in Œ£ := {0, 1}œÉ.
An input vector size of n and output size of m.
[Switch] Upon the command (switch, œÄ,A0) from the Pp and (switch,A1) from
the Ps:
1. Interpret œÄ : [m] ‚Üí [n] and A ‚àà Œ£n.
2. Compute A(cid:48) ‚àà Œ£m s.t. ‚àÄi ‚àà [m], AœÄ(i) = A(cid:48)
i.
3. GenerateA(cid:48) and sendA(cid:48)0 to Pp andA(cid:48)1 to Pr.
Figure 4: The Oblivious Switching Network ideal functionality FSwitch. See Fig-
ure 12, 14 for FPermute and FDuplicate.
new oblivious switching network protocol tailored for the honest majority setting
with signiÔ¨Åcantly eÔ¨Éciency improves. Our protocol has O(n) overhead and is con-
stant round. [MS13] requires O(n log nŒ∫) communication/computation and O(log n)
rounds.
The ideal functionality of our protocol is given in Figure 4 with three parties, a
programmer Pp, a sender Ps and a receiver Pr. Pp has a description of œÄ while Pp,Ps
have a secret sharing of a vector A ‚àà Œ£n where Œ£ = {0, 1}œÉ. Pp and Pr are each
output a share ofA(cid:48) s.t. A(cid:48) = (AœÄ(1), ..., AœÄ(m)). For ease of presentation, we will
initially assume A is the private input of Ps.
Permutation Network. We begin with a restricted class of switching networks where
the programming function œÄ is injective. That is, each input element Ai will be
mapped to a maximum1 of one location in the output A(cid:48). As we will see later, this
property will simplify the implementation since we do not need to duplicate any
element. Intuitively, the Permute protocol of Figure 5 instructs Ps to Ô¨Årst shuÔ¨Ñed
A in a random order (as speciÔ¨Åed by œÄ0) and then secret share it between Pp & Pr.
1Strictly speaking, this protocol implementation a generalization of a permutation network since
it allows some elements to not appear in the output, i.e. m < n and œÄ : [m] ‚Üí [n].
11
Then Pp & Pr will reorder these shares (as speciÔ¨Åed by œÄ1) to be in the desired order
(i.e. œÄ). This is done as follows, Pp samples two random functions œÄ0, œÄ1 such that
œÄ1 ‚ó¶ œÄ0 = œÄ, œÄ0 : [n] ‚Üí [n] is bijective and œÄ1 : [m] ‚Üí [n] is injective. Pp sends œÄ1 to
Pr and œÄ0, S ‚Üê Œ£n to Ps who sends B := (AœÄ0(1) ‚äï S0, ..., AœÄ0(n) ‚äï Sn) to Pr. The
Ô¨Ånal shares of A(cid:48) = œÄ(A) are deÔ¨Åned as Pp holdingA(cid:48)0 := (SœÄ1(1), ..., SœÄ1(m)) and
the Pr holdingA(cid:48)1 := (BœÄ1(1), ..., BœÄ1(m)).
The simulation of this protocol is perfect. The view of Ps contains a uniform
permutation œÄ0 and vector S. Similarly, the view of Pr contains œÄ1 which is uniformly
distributed (when œÄ0 is unobserved) and the uniform vector B. See Section B.1 for
details. In our computational secure setting, œÄ0, S can be generated locally by Pp
and Ps using a common source of randomness, e.g. a seeded PRG. This reduces the
rounds to 1.
Shared Inputs. As presented here in the text our protocols assume the input vector
A being transformed is the private input of the Ps. However, the full protocols
will require the input A to secret shared. Let us assume we have some switching
network protocol Œ† which takes input A from Ps, œÄ from Pp and output shares
of œÄ(A). Then this can be transform to shared inputA. The parties invoke Œ†
where Ps input their share A1 and Pp inputs œÄ. Pp and Pr receive B from
the functionality. The Ô¨Ånal result can then be computed as Pr holding A(cid:48)1 :=
B1 while Pp locally deÔ¨ÅnesA(cid:48)0 :=B0 ‚äï œÄ(A0). It is easy to verify that
A(cid:48) = œÄ(A1)‚äï œÄ(A0) = œÄ(A). The protocol descriptions in Figure 5 include this
shared input modiÔ¨Åcation. However, here in the text we will continue to assume A
is the sole input of Ps.
Duplication Network.
The Duplication protocol of Figure 5 considers a second type of restricted net-
work where œÄ : [n] ‚Üí [n], s.t. œÄ(1) = 1 and œÄ(i) ‚àà {i, œÄ(i ‚àí 1)} for i = 2, ..., n. That
is, each output position is either a copy of the same input position (i.e. œÄ(i) = i)
or is a duplicate of the previous output position (i.e. œÄ(i) = œÄ(i ‚àí 1)). For ex-
ample, let the truth table of œÄ be (œÄ(1), ..., œÄ(6)) = (1, 1, 3, 4, 4, 4) and therefore
A(cid:48) = (A1, A1, A3, A4, A4, A4). Note the only change is that A1, A4 were duplicated
into the next position(s). This transformation can be characterized by a vector
b ‚àà {0, 1}n where bi = 1 denotes that the output position i should be a copy of
output position i ‚àí 1, i.e. b = (0, 1, 0, 0, 1, 1) for the example above. Therefore we
get the relation A(cid:48)
i‚àí1 for i ‚àà [2, n].
i = biAi ‚äï biA(cid:48)
As a warm-up, let us Ô¨Åx some index i and consider the simpler relation where
i = biAi ‚äï biAi‚àí1,
A(cid:48)
i is either Ai or Ai‚àí1 and not A(cid:48)
i.e. A(cid:48)
i‚àí1 as described before. Conceptually, we
will implement this using an OT-like protocol with OT messages (Ai, Ai‚àí1) and
select-bit bi. Ps samples three uniform strings A(cid:48)
bit œÜ ‚Üê {0, 1}. Ps constructs two messages m0 = Ai ‚äïA(cid:48)
Ai‚àí1 ‚äïA(cid:48)
i1, w0, w1 ‚Üê Œ£ and a uniform
i1 ‚äï wœÜ and m1 =
i1 ‚äï wœÜ‚äï1. Ps sends w0, w1 to Pr and sends m0, m1, œÜ to Pp who sends
12
Pp sends œÄ0 and S ‚Üê Œ£n to Ps.
1. Pp uniformly samples a bijection œÄ0 : [n] ‚Üí [n] and let œÄ1 : [n] ‚Üí [m] s.t. œÄ1‚ó¶œÄ0 = œÄ.
Parameters: 3 parties denoted as Pp, Ps and Pr. Elements are strings in Œ£ := {0, 1}œÉ.
An input, output vector size of n, m.
[Permute] Upon the command (Permute, œÄ,A0) from Pp and (Permute,A1)
from Ps. Require that œÄ : [m] ‚Üí [n] is injective andA0,A1 ‚àà Œ£n. Then:
2. Ps sends B := (AœÄ0(1)1 ‚äï S1, ...,AœÄ0(n)1 ‚äï Sn) to Pr.
3. Pp sends œÄ1 and T ‚Üê Œ£m to Pr who outputsA(cid:48)0 := {BœÄ1(1)‚äïT1, ..., BœÄ1(m)‚äïTm}.
Pp outputsA(cid:48)1 := {SœÄ1(1) ‚äï T1 ‚äïAœÄ(1)0, ..., SœÄ1(m) ‚äï Tm ‚äïAœÄ(m)0}.
(Duplicate,A1) from Ps. Require that œÄ :
2. Ps samplesB1, W 0, W 1 ‚Üê Œ£n,B10 ‚Üê Œ£ and œÜ ‚Üê {0, 1}n. Ps redeÔ¨ÅneB11 :=
A11 ‚äïB10. For i ‚àà [2, n], Ps sends
[Duplicate] Upon
œÄ(i) ‚àà {i, œÄ(i ‚àí 1)} for i ‚àà [2, n] and A ‚àà Œ£n. Then:
1. Pp computes the vector b ‚àà {0, 1}m such that b1 = 0 and for i ‚àà [2, n], bi = 1 if
(Duplicate, œÄ,A0)
and
[n] ‚Üí [n] s.t œÄ(1) = 1 and