how to use the API, instead of assuming its usage. At last,
API users can cross-check the usages of API by looking into
how other caller functions use the API. Fourth, checking the
related patches of this API (e.g., through git log) is also
helpful to know the common mistakes.
More applications of pairing analysis. Pairing analysis can
be used in other areas, such as helping API users check func-
tion usage and bug detectors identify other types of bugs.
For example, by identifying the lock/unlock function pairs,
we can infer the functions that can execute concurrently and
further detecting potential race conditions. These function
pairs can be used to detect temporal bugs based on different
temporal rules.
9 Related Work
Function pairs detection. As we compared in §7.2, several
previous works also try to identify function pairs in large pro-
grams. In particular, Mao et al. [28] focused on identifying
refcount-related bugs by comparing the inconsistent paths. To
this end, they collected 800 pairs of refcount-related APIs
by simply string-matching function names, e.g., *_inc and
*_dec. WYSIWIB [22] analyzes the data dependencies of
pointers to collect 304 pairs of allocation and deallocation
functions. Compared to these works, HERO is not limited to
a specific type of pair, and its delta-based pairing is more pre-
cise. PF-Miner [23] and PairMiner [24] have been introduced
in §7.2, which employ data mining and string matching. To
the best of our knowledge, PairMiner represents the state-of-
the-art in automatically detecting various types of function
pairs. Compared to HERO, since PF-Miner and PairMiner
employ simple mining to collect pairs, we believe that the
tools cannot support custom functions and are likely to suffer
from precision issues, although they do not evaluate preci-
sion. Different from these static analysis tools, Bai et al. [3]
employed dynamic tracing to collect 81 function pairs in four
device drivers in Linux, which is not representative of the
whole kernel.
Error-handling analysis. Many previous works also analyze
error-handling code to detect bugs in software like OpenSSL
2054    30th USENIX Security Symposium
USENIX Association
and OS kernels. Rubio-González et al. [45] and EIO [18]
detect error-propagation bugs in file systems. APEx [20],
ErrDoc [53], and EPEx [19] reason about the error-code prop-
agation in open-source SSL implementations, either automat-
ically or via user definitions. Saha et al. [47] proposed an
automatic approach, which can transform the coding style
and structure of the error-handling code to a goto-based stan-
dardized error-handling strategy. Tang [50] proposed a tool to
detect error code misuses in system programs. EESI [13] is a
static analysis tool, which can infer C program function-error
specifications through return-code idiom. EESI can identify
inadequate and inverted error-checks, and also incomplete er-
ror handling bugs. An inherent difference is that these works
focus on reasoning about the “handling” itself—if an error
code is returned, passed, or handled in callers—instead of the
cleanup operations before the handling.
Unlike previous works that aim to make error handling
sufficient, EeCatch [42] instead detects exaggerated (or ex-
cessive) error handling which often causes crashes. EeCatch
employs spatial and temporal cross-checking to identify irreg-
ular and over-severe error handling as potential exaggerated
error-handling bugs. HERO differs from EeCatch in both re-
search goals and approaches. First, HERO aims to detect the
ordering issues in the error-handling code, instead of the in-
correct severity level of error handling. DiEH causes not only
crashes but also memory corruption. Second, HERO’s key
technique is the precise function pairing while EeCatch fea-
tures the spatial and temporal cross-checking. To explore the
structure of error-handling code, Thummalapenta et al. [52]
proposed a mining algorithm, which mining sequence asso-
ciation rules and rule violations of function calls in a large
number of the normal and error paths. Different from this
work, HERO can precisely identify function pairs based on
delta analysis, which can handle the custom functions.
Bug detection in error paths. There is also a line of research
that focuses on finding bugs in cleanup operations in error
paths. In particular, Saha et al. [48] proposed Hector, which
identifies missing resource-release functions in the systems
software. Hector assumes the pointer-returning functions are
allocation functions, and the last pointer-usage function is
a deallocation function. They identify the missing-release
bugs by comparing the inconsistencies in different error paths.
Mao et al. [28] implemented RID, which can identify ref-
count related bugs by analyzing the inconsistent paths in the
function; oftentimes, the bugs are in error paths. Lawall et
al. [21] proposed a tool to detect error-handling bugs in the
Linux kernel and OpenSSL, which are related to API usage
protocols. GUEB [16] and CRED [58] are static-analysis
tools that can identify use-after-free bugs. All these works
focus on a specific type of error-handling bugs, such as miss-
ing release. To the best of our knowledge, none of the tools
could detect incorrect-order and redundant DiEH bugs, which
requires precise and comprehensive identification of function
pairs.
Bug detection with rules inference. Some previous works
also identified bugs though rules inference based on code se-
mantics. APISan [59] detects API misuses by analyzing rich
symbolic contexts. Acharya et al. [1] proposed a mining tech-
nique to check the partial-order rules of API usages and detect
related rules violation bugs. Gruska et al. [17] presented a
tool to mine API usage rules across different projects. Simi-
larly, some previous works [5, 12, 26, 54, 57] detect different
types of bugs in a program through a mining approach to gen-
erate rules and detect violations. Different from these works,
HERO does not rely on unknown-rule mining to detect bugs,
thus it can support custom functions; instead, HERO takes
advantage of the unique structures of the error-handling code.
10 Conclusion
Large programs such as OS kernels usually have compli-
cated error-handling and code-cleanup mechanisms, which
are buggy because they are less tested and hard to implement.
Prior research attempted to detect the bugs, but mainly on
the “handling” part instead of the cleanup mechanisms. This
paper proposed DiEH bugs, a class of error-handling bugs that
are caused by improper cleanup operations—incorrect-order,
redundant, and inadequate cleanups. Through a study, we
show that DiEH is hard to avoid and thus is prevalent; it also
causes critical security problems such as memory corruption
and privilege escalation. This paper then presented a new
detection system, HERO. At its core is a precise function
pairing technique that leverages the unique error-handling
structures in low-level languages. We evaluate HERO on
two OS kernels and the OpenSSL library. The results show
that HERO can precisely identify a large number of function
pairs including custom ones, and can detect 239 critical DiEH
bugs, most of which were confirmed by maintainers. HERO
is generic, and its precise pairing analysis can be applied to
benefit other research such as race detection and temporal-rule
inferences.
11 Acknowledgment
We thank our shepherd, Mathias Payer, and the anonymous
reviewers for their helpful suggestions and comments. We are
grateful to Linux maintainers for providing prompt feedback
on patching the Linux kernel. The authors also thank Peng
Le for helping implement function pairing. This research
was supported in part by the NSF awards CNS-1815621 and
CNS-1931208. Any opinions, findings, conclusions or recom-
mendations expressed in this material are those of the authors
and do not necessarily reflect the views of NSF.
USENIX Association
30th USENIX Security Symposium    2055
References
[1] M. Acharya, T. Xie, J. Pei, and J. Xu. Mining api patterns as partial
orders from source code: from usage scenarios to specifications. In
Proceedings of the the 6th joint meeting of the European software
engineering conference and the ACM SIGSOFT symposium on The
foundations of software engineering, pages 25–34, 2007.
[2] B. Andersson. Linux kernel patch log, 2020. https://git.kernel.
org/pub/scm/linux/kernel/git/torvalds/linux.git/
commit/?id=6e5da6f7d82474e94c2d4a38cf9ca4edbb3e03a0.
[3] J.-J. Bai, H.-Q. Liu, Y.-P. Wang, and S.-M. Hu. Runtime checking for
paired functions in device drivers. In 2014 21st Asia-Pacific Software
Engineering Conference, volume 1, pages 407–414. IEEE, 2014.
[4] F. Bellard. Qemu, a fast and portable dynamic translator. In USENIX
Annual Technical Conference, FREENIX Track, volume 41, page 46,
2005.
[5] P. Bian, B. Liang, Y. Zhang, C. Yang, W. Shi, and Y. Cai. Detecting
bugs by discovering expectations and their violations. IEEE Transac-
tions on Software Engineering, 45(10):984–1001, 2018.
[6] Bootlin-Community.
2020.
source/lib/kobject.c#L464.
kobject_init_and_add(),
https://elixir.bootlin.com/linux/v5.7-rc7/
Linux kernel:
[7] J. Corina, A. Machiry, C. Salls, Y. Shoshitaishvili, S. Hao, C. Kruegel,
and G. Vigna. Difuze: Interface aware fuzzing for kernel drivers. In
Proceedings of the 2017 ACM SIGSAC Conference on Computer and
Communications Security, pages 2123–2138. ACM, 2017.
[8] M. Corporation. Common weakness enumeration (cwe), 2020. https:
//cwe.mitre.org/.
[9] M. Corporation. Owasp top ten 2004 category a9 - denial of service,
2020. https://cwe.mitre.org/data/definitions/730.html.
[10] M. Corporation. Cwe-200: Exposure of sensitive information to
https://cwe.mitre.org/data/
an unauthorized actor, 2020.
definitions/200.html.
[11] M. Corporation. Cwe-416: Use after free, 2020. https://cwe.
mitre.org/data/definitions/416.html.
[12] D. DeFreez, A. V. Thakur, and C. Rubio-González. Path-based function
embedding and its application to specification mining. arXiv preprint
arXiv:1802.07779, 2018.
[13] D. DeFreez, H. M. Baldwin, C. Rubio-González, and A. V. Thakur.
Effective error-specification inference via domain-knowledge expan-
sion. In Proceedings of the 2019 27th ACM Joint Meeting on European
Software Engineering Conference and Symposium on the Foundations
of Software Engineering, pages 466–476, 2019.
[14] D. Engler, D. Y. Chen, S. Hallem, A. Chou, and B. Chelf. Bugs as
deviant behavior: A general approach to inferring errors in systems
code. ACM SIGOPS Operating Systems Review, 35(5):57–72, 2001.
[15] G. Fan, R. Wu, Q. Shi, X. Xiao, J. Zhou, and C. Zhang. Smoke:
scalable path-sensitive memory leak detection for millions of lines of
code. In 2019 IEEE/ACM 41st International Conference on Software
Engineering (ICSE), pages 72–82. IEEE, 2019.
[16] J. Feist, L. Mounier, and M.-L. Potet. Statically detecting use after free
on binary code. Journal of Computer Virology and Hacking Techniques,
10(3):211–217, 2014.
[17] N. Gruska, A. Wasylkowski, and A. Zeller. Learning from 6,000
projects: lightweight cross-project anomaly detection. In Proceedings
of the 19th international symposium on Software testing and analysis,
pages 119–130, 2010.
[18] H. S. Gunawi, C. Rubio-González, A. C. Arpaci-Dusseau, R. H.
Arpaci-Dusseau, and B. Liblit. Eio: Error handling is occasionally
correct. In FAST, volume 8, pages 1–16, 2008.
[19] S. Jana, Y. J. Kang, S. Roth, and B. Ray. Automatically detecting
error handling bugs using error specifications. In USENIX Security
Symposium, pages 345–362, 2016.
[20] Y. Kang, B. Ray, and S. Jana. Apex: Automated inference of error
specifications for c apis. In Proceedings of the 31st IEEE/ACM Interna-
tional Conference on Automated Software Engineering, pages 472–482.
ACM, 2016.
[21] J. Lawall, B. Laurie, R. R. Hansen, N. Palix, and G. Muller. Finding
error handling bugs in openssl using coccinelle. In 2010 European
Dependable Computing Conference, pages 191–196. IEEE, 2010.
[22] J. L. Lawall, J. Brunel, N. Palix, R. R. Hansen, H. Stuart, and G. Muller.
Wysiwib: A declarative approach to finding api protocols and bugs in
linux code. In 2009 IEEE/IFIP International Conference on Depend-
able Systems & Networks, pages 43–52. IEEE, 2009.
[23] H. Liu, Y. Wang, L. Jiang, and S. Hu. Pf-miner: A new paired functions
mining method for android kernel in error paths. In 2014 IEEE 38th
Annual Computer Software and Applications Conference, pages 33–42.
IEEE, 2014.
[24] H.-Q. Liu, J.-J. Bai, Y.-P. Wang, Z. Bian, and S.-M. Hu. Pairminer:
mining for paired functions in kernel extensions. In 2015 IEEE Inter-
national Symposium on Performance Analysis of Systems and Software
(ISPASS), pages 93–101. IEEE, 2015.
[25] K. Lu and H. Hu. Where does it go? refining indirect-call targets with
multi-layer type analysis. In Proceedings of the 2019 ACM SIGSAC
Conference on Computer and Communications Security, pages 1867–
1881, 2019.
[26] K. Lu, A. Pakki, and Q. Wu. Automatically identifying security checks
for detecting kernel semantic bugs.
In K. Sako, S. Schneider, and
P. Y. A. Ryan, editors, Computer Security – ESORICS 2019, pages
3–25, Cham, 2019. Springer International Publishing.
[27] K. Lu, A. Pakki, and Q. Wu. Detecting missing-check bugs via
semantic- and context-aware criticalness and constraints inferences.
In 28th USENIX Security Symposium (USENIX Security 19), pages
1769–1786. USENIX Association, 2019.
[28] J. Mao, Y. Chen, Q. Xiao, and Y. Shi. Rid: finding refcount bugs with
inconsistent path pair checking. In Proceedings of the Twenty-First
International Conference on Architectural Support for Programming
Languages and Operating Systems, pages 531–544, 2016.
[29] C. Minyard and T. Hellstrom.
Cve-2019-0685: A refcount
leak vulnerability., 2004. https://sigpwn.io/blog/2020/5/7/
cve-2019-0685-win32k-reference-count-leak.
[30] MITRE-CVE. A refcount leak vulnerability in the linux kernel, 2019.
https://www.cvedetails.com/cve/CVE-2016-0728/.
[31] MITRE-CVE. A use-after-free in the linux kernel, 2019. https:
//www.cvedetails.com/cve/CVE-2019-15292/.
[32] MITRE-CVE. A double-free in the linux kernel, 2019.
//www.cvedetails.com/cve/CVE-2019-15504/.
https:
[33] MITRE-CVE. A deadlock vulnerability in the linux kernel, 2019.
https://www.cvedetails.com/cve/CVE-2019-15538/.
[34] MITRE-CVE. A null dereference vulnerability in the linux kernel,
2019. https://www.cvedetails.com/cve/CVE-2019-15923/.
[35] MITRE-CVE. A memory leak vulnerability in the linux kernel, 2019.
https://www.cvedetails.com/cve/CVE-2019-16994/.
[36] MITRE-CVE. A memory leak vulnerability in the linux kernel,
2019. https://cve.mitre.org/cgi-bin/cvename.cgi?name=
CVE-2019-5023.
[37] MITRE-CVE. A refcount leak vulnerability in the freebsd, 2019.
https://www.cvedetails.com/cve/CVE-2019-5607/.
[38] MITRE-CVE. A memory leak vulnerability in the linux kernel,
2019. https://cve.mitre.org/cgi-bin/cvename.cgi?name=
CVE-2019-8980.
[39] MITRE-CVE. Cve-2019-0685, 2020. ttps://www.cvedetails.
com/cve/CVE-2019-0685/.
2056    30th USENIX Security Symposium
USENIX Association
[40] MITRE-CVE. A memory leak vulnerability in the linux kernel,
2020. https://cve.mitre.org/cgi-bin/cvename.cgi?name=
CVE-2020-15393.
[41] MITRE-CVE. Cvedetils, 2020. https://www.cvedetails.com/
product/47/Linux-Linux-Kernel.html.
[42] A. Pakki and K. Lu. Exaggerated Error Handling Hurts! An In-Depth
In 27th ACM Conference on
Study and Context-Aware Detection.
Computer and Communications Security (CCS). ACM, 2020.
[43] L. project community. Llvm alias analysis infrastructure, 2020. https:
//llvm.org/docs/AliasAnalysis.html.
[44] H. A. Rosenberg and K. G. Shin.
Software fault injection and
its application in distributed systems. In FTCS-23 The Twenty-Third
International Symposium on Fault-Tolerant Computing, pages 208–217.
IEEE, 1993.
[45] C. Rubio-González, H. S. Gunawi, B. Liblit, R. H. Arpaci-Dusseau,
and A. C. Arpaci-Dusseau. Error propagation analysis for file systems.
In ACM Sigplan Notices, volume 44, pages 270–280. ACM, 2009.
[46] R. Russell. What if I don’t actually like my users?, Apr. 2008. https:
//ozlabs.org/~rusty/index.cgi/tech/2008-04-01.html.
[47] S. Saha, J. Lawall, and G. Muller. An approach to improving the
structure of error-handling code in the linux kernel. In Proceedings of
the 2011 SIGPLAN/SIGBED conference on Languages, compilers and
tools for embedded systems, pages 41–50, 2011.
[48] S. Saha, J.-P. Lozi, G. Thomas, J. L. Lawall, and G. Muller. Hector:
Detecting resource-release omission faults in error-handling code for
In 2013 43rd Annual IEEE/IFIP International
systems software.
Conference on Dependable Systems and Networks (DSN), pages 1–12.
IEEE, 2013.
[49] D. Song, F. Hetzelt, D. Das, C. Spensky, Y. Na, S. Volckaert, G. Vigna,
C. Kruegel, J.-P. Seifert, and M. Franz. Periscope: An effective probing
and fuzzing framework for the hardware-os boundary. In NDSS, 2019.
In
Proceedings of the 28th ACM SIGSOFT International Symposium on
Software Testing and Analysis, pages 428–432, 2019.
Identifying error code misuses in complex system.
[50] W. Tang.
[51] Thgarnie.
syzkaller.
Syzkaller, 2019.
https://github.com/google/
[52] S. Thummalapenta and T. Xie. Mining exception-handling rules as se-
quence association rules. In 2009 IEEE 31st International Conference
on Software Engineering, pages 496–506. IEEE, 2009.
[53] Y. Tian and B. Ray. Automatically diagnosing and repairing error
handling bugs in c. In Proceedings of the 2017 11th Joint Meeting on
Foundations of Software Engineering, pages 752–762. ACM, 2017.
[54] W. Weimer and G. C. Necula. Mining temporal specifications for error
detection. In International Conference on Tools and Algorithms for the
Construction and Analysis of Systems, pages 461–476. Springer, 2005.
[55] Q. Wu, Y. He, S. McCamant, and K. Lu. Precisely characterizing
security impact in a flood of patches via symbolic rule comparison. In
Network and Distributed System Security Symposium (NDSS), 2020.
[56] W. Xu, J. Li, J. Shu, W. Yang, T. Xie, Y. Zhang, and D. Gu. From
collision to exploitation: Unleashing use-after-free vulnerabilities in
linux kernel. In Proceedings of the 22nd ACM SIGSAC Conference on
Computer and Communications Security, pages 414–425. ACM, 2015.
[57] H. Yan, Y. Sui, S. Chen, and J. Xue. Machine-learning-guided typestate
In Proceedings of the
analysis for static use-after-free detection.
33rd Annual Computer Security Applications Conference, pages 42–54,
2017.
[58] H. Yan, Y. Sui, S. Chen, and J. Xue. Spatio-temporal context reduction:
A pointer-analysis-based static approach for detecting use-after-free
vulnerabilities. In 2018 IEEE/ACM 40th International Conference on
Software Engineering (ICSE), pages 327–337. IEEE, 2018.
[59] I. Yun, C. Min, X. Si, Y. Jang, T. Kim, and M. Naik. Apisan: Sanitizing
{API} usages through semantic cross-checking. In 25th {USENIX}
Security Symposium ({USENIX} Security 16), pages 363–378, 2016.
[60] H. Zhang, D. She, and Z. Qian. Android ion hazard: The curse of
In Proceedings of the
customizable memory management system.
2016 ACM SIGSAC Conference on Computer and Communications
Security, pages 1663–1674, 2016.
[61] S. Zhang, J. Zhu, A. Liu, W. Wang, C. Guo, and J. Xu. A novel
memory leak classification for evaluating the applicability of static
analysis tools. In 2018 IEEE International Conference on Progress in
Informatics and Computing (PIC), pages 351–356. IEEE, 2018.
A Appendix
Program
File
Line#
Impact
Category
OpenSSL
FreeBSD
crypto/x509/v3_crld.c
crypto/cms/cms_sd.c
crypto/store/loader_file.c
lib/libkiconv/kiconv_sysctl.c
lib/libkiconv/kiconv_sysctl.c
85
326
406
50
75
ML
ML
DF
ML
ML
D3
D3
D2