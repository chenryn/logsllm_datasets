where M, N, N
also write M â t iï¬€ âˆƒM
messages t.
are messages and k is a key expression. We
(cid:1) âˆˆ t, for a set of
(cid:1) âˆ§ M
. M â M
(cid:1)
Proposition 7.1. (Well-foundedness) Given a property
P on conï¬gurations, if a run
(cid:12)p0, s0, t0(cid:13) e1âˆ’â†’ Â·Â·Â·
erâˆ’â†’ (cid:12)pr, sr, tr(cid:13) er+1âˆ’â†’ Â·Â·Â· ,
contains a conï¬gurations s.t. P(p0, s0, t0) and Â¬P(pj, sj, tj),
then there is an event eh, 0 < h â‰¤ j, such that P(pi, si, ti)
for all i â‰¤ h and Â¬P(ph, sh, th).
We say that a name m âˆˆ N is fresh on an event e if m âˆˆ en
and we write F resh(m, e).
100Proposition 7.2. (Freshness) Within a run
(cid:12)p0, s0, t0(cid:13) e1âˆ’â†’ Â·Â·Â·
erâˆ’â†’ (cid:12)pr, sr, tr(cid:13) er+1âˆ’â†’ Â·Â·Â· ,
the following properties hold:
i) If n âˆˆ si then either n âˆˆ s0 or there is a previous event
ej such that F resh(n, ej).
ii) Given a name n there is at most one event ei s.t.
F resh(n, ei).
iii) If F resh(n, ei) then for all j < i the name n does not
appear in (cid:12)pj, sj, tj(cid:13).
Proposition 7.3. (Control precedence) Within a run
(cid:12)p0, s0, t0(cid:13) e1âˆ’â†’ Â·Â·Â·
erâˆ’â†’ (cid:12)pr, sr, tr(cid:13) er+1âˆ’â†’ Â·Â·Â· ,
if b âˆˆ cei either b âˆˆ Ic(p0) or there is an earlier event ej,
j < i, such that b âˆˆ ej
c.
Proposition 7.4. (Output-input precedence) In a run
(cid:12)p0, s0, t0(cid:13) e1âˆ’â†’ Â·Â·Â·
erâˆ’â†’ (cid:12)pr, sr, tr(cid:13) er+1âˆ’â†’ Â·Â·Â· ,
if M âˆˆ oei, then either M âˆˆ t0 or there is an earlier event
ej, j < i, such that M âˆˆ ej
7.2 An example: authentication for NSL
o.
We will prove authentication for a responder in an NSL
protocol in the sense that: to any complete session of agent
B0 as responder, apparently with agent A0, there corre-
sponds a complete session of agent A0 as initiator. We refer
to the Appendix for the events of NSL.
In the proof itâ€™s helpful to make use of a form of diagram-
matic reasoning which captures the precedence of events.
(cid:1) when e pre-
When the run is understood, we draw e
e
(cid:1)
cedes e
(cid:1)
in the run, allowing e = e
.
Theorem 7.5
(Authentication). If a run of NSL
(cid:12)N SL, s0, t0(cid:13) e1âˆ’â†’ Â·Â·Â·
erâˆ’â†’ (cid:12)pr, sr, tr(cid:13) er+1âˆ’â†’ Â·Â·Â· ,
contains the responder events b1, b2, b3, with actions
act(b1) = resp : B0 : i : in{m0, A0}P ub(B0) ,
act(b2) = resp : B0 : i : out new n0 {m0, n0, B0}P ub(A0) ,
act(b3) = resp : B0 : i : in{n0}P ub(B0) ,
for an index i, and P riv(A0) (cid:26)â t0, then the run contains
initiator events a1, a2, a3 with a3
b3 , where, for some
index j,
act(a1) = init : (A0, B0) : j : out new m0 {m0, A0}P ub(B0) ,
act(a2) = init : (A0, B0) : j : in{m0, n0, B0}P ub(A0) ,
act(a3) = init : (A0, B0) : j : out{n0}P ub(B0) .
Proof. By control precedence we obtain:
b1
b2
b3 .
Consider the property of conï¬gurations
Q(p, s, t) â‡” âˆ€M âˆˆ t. n0 â M â‡’ {m0, n0, B0}P ub(A0) â M .
By freshness, the property Q holds immediately after b2,
but clearly not immediately before b3. By well-foundedness
there is a earliest event following b2 but preceding b3 that
violates Q. Let e be such an event.
b1
b2
b3
?~~~~~
@@@@@
e
Inspecting the events of the N SL protocol (see Appendix),
using the assumption that P riv(A0) (cid:26)â t0, one can show that
(cid:1)
e can only be an initiator event a
3 with action
3) = init : (A, B0) : j : out{n0}P ub(B0)
(cid:1)
act(a
(cid:1)
2 with actions
for some index j and agent A. There must also be preceding
(cid:1)
1, a
events a
1) = init : (A, B0) : j : out new m{m, A}P ub(B0)
(cid:1)
2) = init : (A, B0) : j : in{m, n0, B0}P ub(A)
(cid:1)
act(a
act(a
b1
(cid:1)
1
a
 @@@@@
b2
(cid:1)
2
a
(cid:1)
3
a
b3
?~~~~~
(cid:1)
Since F resh(b2, n0), the event b2 must precede a
2. The
(cid:1)
property Q holds on conï¬gurations up to a
3 and, in par-
(cid:1)
ticular, on the conï¬guration immediately before a
2. From
(cid:1)
this we conclude that m = m0 and A = A0. Hence a
3 = a3,
(cid:1)
(cid:1)
2 = a2, and a
1 = a1 as described below.
a
b1
a1
b2
/ a2
b3
/ a3
(Since F resh(a1, m0), the event a1 precedes b1.)
8. RELATING SECURITY MODELS
We have related our net semantics of SPL to a transition
semantics. Now we establish its relations to the security
models of strand spaces, inductive rules, as well as other
traditional models. In security protocols we are largely in-
terested in safety properties, which reduce to a property
holding of all ï¬nite behaviours. Thus it suï¬ƒces to show
how a ï¬nite behaviour in one model can be matched by the
ï¬nite behaviour in another.
In relating the net semantics
to strand spaces and inductive rules we need to constrain
process terms, to allow some repetition of actions, though
this does not seem unduly restrictive in formalising security
protocols.
8.1 Strand spaces
In relating the net semantics to strand spaces we must
face the fact that strand spaces donâ€™t compose readily, not
using traditional process operations at least. Their form
doesnâ€™t allow preï¬xing by a single event. Nondetermin-
ism only arises through the choice as to where input comes
from, and there is not a recognisable nondeterministic sum
of strand spaces. Even an easy deï¬nition of parallel compo-
sition by juxtaposition is thwarted if â€œunique originationâ€
is handled as a global condition on the entire strand space.
This complicates the relation between a compositional se-
mantics and strand spaces.
We can however relate the net behaviour of a !-par pro-
cess to that of an associated strand space; a !-par process
is a closed process of the form !(cid:11)iâˆˆI pi for which no subterm
101/
/
/
/
/
/
/
/
/
/
/
/
?
/
/
/
/
/
/
/
/
?
/
/
/
/


/
/
O
O
pi contains a parallel composition. In proving the relation
(though unfortunately not in this short write-up) we ï¬nd it
useful to extend strand spaces in order to compose them,
chieï¬‚y with conï¬‚ict to permit their nondeterministic sum,
and then ï¬nally to observe that for processes with replica-
tion the conï¬‚ict can be eliminated, without upsetting the
strand-space behaviour.
(Strand spaces can be viewed as
special forms of event structures - see below; so ideas, such
as the use of a conï¬‚ict relation, can be adapted from there.)
Definition 8.1. A strand space consists of S = (cid:12)Si(cid:13)iâˆˆI
an indexed set of strands. An individual strand Si, where
i âˆˆ I, is a ï¬nite sequence of output or input events carrying
respectively output or input actions of the kind out new(cid:12)nM
or in M , where M is a closed message and (cid:12)n a list of distinct
names that are intended to be fresh (â€œuniquely originatingâ€)
at the event. We permit only strands on which any â€œnewâ€
names do not appear in previous actions of the strand. (A
set of strands is canonically a strand space in which each
strand has itself as index.)
As usual, a strand space can be seen as a graph whose nodes
are of the form (i, l) with i âˆˆ I index of a strand and l
position of an event in that strand (1 â‰¤ l â‰¤ length(si)).
Each node uniquely identiï¬es an event in a strand. Edges are
of two diï¬€erent kinds: â‡’ between two nodes that identify
two events of a same strand, one immediately preceding the
other and â†’ between two nodes identifying respectively an
output event and an input event with the same message. A
bundle of a strand space S is a ï¬nite, acyclic subgraph s.t.
â€¢ if a node belongs to the bundle, so do all nodes that
precede it on its strand, together with their incident
â‡’ edges,
â€¢ each input node has exactly one incoming â†’ edge,
â€¢ two diï¬€erent strands that have a â€œnewâ€ name in com-
mon donâ€™t both contribute to the same bundle.
We write â‡’C and â†’C for edges of a strand space graph
belonging to a bundle C. Our deï¬nition is not quite stan-
dard. But the only signiï¬cant diï¬€erence is in the treatment
of unique origination which is taken care of in the deï¬ni-
tion of bundle rather than being a condition on the entire
strand space - the â€œparametric strand spacesâ€ of [3] achieve
the same eï¬€ect and are closely related.
A strand space can be seen as a form of event struc-
ture [13]. A strand space determines a stable event structure,
whose family of conï¬gurations is the same as the bundles of
the strand space; the bundles of a strand space when ordered
by inclusion form a stable family which ensures not only that
each conï¬guration of events in the family can be equipped
with a local partial order of causal dependency, but that
at the cost renaming events these local partial orders can
be extended to a global partial order of causal dependency,
yielding a prime event structure.
Often in strand spaces the precise identity of indices does
not matter. A re-indexing of a strand space S = (cid:12)Si(cid:13)iâˆˆI is
a permutation Ï€ of I such that Si and SÏ€(i) are sequences
of the same length with the same actions at corresponding
events. A re-indexing of a strand space induces a re-indexing
on its bundles; a bundleâ€™s nodes and arcs are changed ac-
cording to the correspondence given by Ï€.
To relate the net behaviour of a process to its behaviour as
a strand space we need to linearise bundles. More precisely:
Definition 8.2. Given a bundle C of a strand space S, a
linearisation of C is a sequence of nodes e1 . . . ek such that
{e1, . . . , ek} are all the nodes of C and for all e in C and all ei
in L, if eâ‡’Cei or eâ†’Cei then e precedes ei in the sequence.
An event-linearisation of a bundle is the sequence of strand-
space events associated with the nodes of a linearisation.
Let p be a !-par process and s a set of names containing
all names in p. Take T r(p, s) to be the strand space with
strands consisting of all the maximal sequences e1 . . . ek of
events in Ev(p) such that:
i) ce1 âŠ† Ic(p) and
ii) for all i, 1 â‰¤ i < k, we have ei
nâˆ©(sâˆª{ej
n | j < i}) = âˆ…
and ei
c = cei+1.
Sequences satisfying the above conditions are necessarily ï¬-
nite as the size of control conditions strictly decreases along
the sequence. The events of the net are already associated
with input and output actions. The net and strand space
behaviour are closely related:
Theorem 8.3. Given p a !-par process and s set of names
containing all names in p, we have that:
i) The sequence of events in a ï¬nite run in N et(p) from
the initial conï¬guration (cid:12)p, s,âˆ…(cid:13) is an event-linearisa-
tion of a bundle over T r(p, s).
ii) Every bundle over T r(p, s) can be re-indexed so that
any of its event-linearisations is a run in N et(p).
The only way a strand space can cope with there being a
nonempty set of initial output messages is through the slight
clumsiness of introducing extra output events; we avoid this
above by assuming the initial set of output messages is
empty.
8.2
Inductive rules
Paulsonâ€™s inductive rules for a security protocol capture
the actions it and a spy can perform [9]. Through allow-
ing persistent conditions, we can represent a collection of
inductive rules as a net in which the events stand for rule
instances and runs to sequences of rule instances which form
a derivation from the rules. In particular, instances of induc-
tive rules for security protocols can be represented as events
in a net for which all but the name conditions are persistent.
According to such a semantics, once a protocol can input it
can do so repeatedly. Once it can output generating new
names it can do so repeatedly, provided this doesnâ€™t lead
to clashes with names already in use. Paulsonâ€™s traces and
the associated runs of the net will necessarily include such
â€œstuttering.â€
We deï¬ne a net of rule instances from a closed process
term. Take the set of â€œrule-conditionsâ€ to consist of name
conditions and persistent output conditions, as before, but
now with additional persistent conditions consisting of closed
input and output process terms. Let r be the function from
SPL-conditions to rule-conditions which removes the indices
tagging control conditions and leaves output and name con-
ditions unchanged. Extend r to SPL-events: let r replace
all the control conditions of an SPL-event by their images
under r - intuitively, an event is replaced by a rule instance.
Deï¬ne the â€œnet of rule instancesâ€ R(p) of a closed process
term p to be the net with rule-conditions and events the
image r Ev(p).
102âˆ—
For a closed process term p, let p
be the process term
obtained by inserting a replication before every input and
âˆ—
) = R(p) as R
output process subterm in p. Note that R(p
drops indices. Now, having restricted to a process with suf-
ï¬cient replication, we can establish a close relation between
âˆ—
the behaviours of N et(p
âˆ—
) and R(p
).
Theorem 8.4. Let p be a closed process term. Let t be a
subset of closed messages and s a subset of names including
those of p and t. Let M0 = Ic(p
âˆ—
) âˆª s âˆª t.
elâˆ’â†’ Ml of N et(p
âˆ—
) yields a run
i) A run M0
e1âˆ’â†’ Â·Â·Â·
r(e1)âˆ’â†’ Â·Â·Â· r(el)âˆ’â†’ rMl of R(p
âˆ—
).
rM0
ii) To M(cid:1)
0
e(cid:1)
1âˆ’â†’ Â·Â·Â·
e(cid:1)
lâˆ’â†’ M(cid:1)
âˆ—
l a run of R(p
rM0, there is a run M0
e1âˆ’â†’ Â·Â·Â·
i and r(Mi) = M(cid:1)
(cid:1)
with r(ei) = e
) with M(cid:1)
0 =