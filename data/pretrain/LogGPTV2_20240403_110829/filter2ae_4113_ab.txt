    def egcd(a,b):
        if a==0:
            return (b,0,1)
        else:
            g,y,x=egcd(b%a,a)
            return (g,x-(b//a)*y,y)
    def modinv(a,m):
        g,x,y=egcd(a,m)
        if g!=1:
            raise Exception(" error")
        else:
            return x%m
    a1=21856963452461630437348278434191434000066076750419027493852463513469865262064340836613831066602300959772632397773487317560339056658299954464169264467234407
    b1=21856963452461630437348278434191434000066076750419027493852463513469865262064340836613831066602300959772632397773487317560339056658299954464169264467140596
    a2=16466113115839228119767887899308820025749260933863446888224167169857612178664139545726340867406790754560227516013796269941438076818194617030304851858418927
    b2=16466113115839228119767887899308820025749260933863446888224167169857612178664139545726340867406790754560227516013796269941438076818194617030304851858351026
    n=85492663786275292159831603391083876175149354309327673008716627650718160585639723100793347534649628330416631255660901307533909900431413447524262332232659153047067908693481947121069070451562822417357656432171870951184673132554213690123308042697361969986360375060954702920656364144154145812838558365334172935931441424096270206140691814662318562696925767991937369782627908408239087358033165410020690152067715711112732252038588432896758405898709010342467882264362733
    c=75700883021669577739329316795450706204502635802310731477156998834710820770245219468703245302009998932067080383977560299708060476222089630209972629755965140317526034680452483360917378812244365884527186056341888615564335560765053550155758362271622330017433403027261127561225585912484777829588501213961110690451987625502701331485141639684356427316905122995759825241133872734362716041819819948645662803292418802204430874521342108413623635150475963121220095236776428
    p=1
    q=1
    i=1
    l=0
    for i in range(b1+1,a1-1):
        p *= modinv(i,a1)
        p %=a1
    p=sympy.nextprime(p)
    print "p="
    print p
    for i in range(b2+1,a2-1):
        q *=modinv(i,a2)
        q %=a2
    q=sympy.nextprime(q)
    print "q="
    print q
    r=n/q/p
    print "r="
    print r
    fn=(p-1)*(q-1)*(r-1)
    print "fn="
    print fn
    e=4097
    d=modinv(e,fn)
    print "d="
    print d
    m=pow(c,d,n)
    print "m="
    print m
    print long_to_bytes(m)
### 区块链1
做题的时候发现已经有人做出来了，然后去看做出来人的交易记录，发现是薅羊毛，通过逆向做出来人的记录，照抄了一个，payload合约如下：
    /**
    *Submitted for verification at Etherscan.io on 2019-10-08
    */
    pragma solidity ^0.4.24;
    contract P_Bank
    {
      mapping (address => uint) public balances;
      uint public MinDeposit = 0.1 ether;
      Log TransferLog;
      event FLAG(string b64email, string slogan);
      constructor(address _log) public { 
          TransferLog = Log(_log);
        }
      function Ap() public {
          if(balances[msg.sender] == 0) {
              balances[msg.sender]+=1 ether;
          }
      }
      function Transfer(address to, uint val) public {
          if(val > balances[msg.sender]) {
              revert();
          }
          balances[to]+=val;
          balances[msg.sender]-=val;
      }
      function CaptureTheFlag(string b64email) public returns(bool){
        require (balances[msg.sender] > 500 ether);
        emit FLAG(b64email, "Congratulations to capture the flag!");
      }
      function Deposit()
      public
      payable
      {
          if(msg.value > MinDeposit)
          {
              balances[msg.sender]+= msg.value;
              TransferLog.AddMessage(msg.sender,msg.value,"Deposit");
          }
      }
      function CashOut(uint _am) public 
      {
          if(_am= uint)
      require(address3 == msg.sender + 0x32c3edb)
      balanceOf[address1] -= _value;
      balanceOf[address2] += _value;
      allowance[address1][msg.sender] -= _value;
    然后在标准token的sol里面有一个函数：
    function approve(address _spender, uint256 _value) public returns (bool) {
      allowed[msg.sender][_spender] = _value;
      Approval(msg.sender, _spender, _value);
      return true;
    }
通过approve函数给allowance[msg.sender][msg.sender]赋值，随便大于1000的值就行。
然后调用0x5ad0ae39，这里就比较蛋疼了，因为爆破不出这个函数名，没法直接用remix做题，没办法只能写代码了。
过程如图：
### rsa
根据题目文件可知：
    A=(((y%x)**5)%(x%y))**2019+y**316+(y+1)/x
    p=next_prime(z*x*y)
    q=next_prime(z)
    n=p*q
直接爆破A方程可得 x*y=166。（一个是2一个是83，懒得重新写脚本了很好爆。）
然后可得
    p=next_prime(z*166)
    q=next_prime(z)
可以推断出，n和z _z_
166的值相对来说是距离比较近的，根据next_prime可以推测出sqrt(n/166)的值和p和q的其中一个是很接近的，爆破即可。
py2 ：
    import sympy
    import gmpy2
    n=117930806043507374325982291823027285148807239117987369609583515353889814856088099671454394340816761242974462268435911765045576377767711593100416932019831889059333166946263184861287975722954992219766493089630810876984781113645362450398009234556085330943125568377741065242183073882558834603430862598066786475299918395341014877416901185392905676043795425126968745185649565106322336954427505104906770493155723995382318346714944184577894150229037758434597242564815299174950147754426950251419204917376517360505024549691723683358170823416757973059354784142601436519500811159036795034676360028928301979780528294114933347127
    #m是n/166的开放根，和p q 中的一个距离很近
    m=sympy.nextprime(842868045681390934539739959201847552284980179958879667933078453950968566151662147267006293571765463137270594151138695778986165111380428806545593588078365331313084230014618714412959584843421586674162688321942889369912392031882620994944241987153078156389470370195514285850736541078623854327959382156753458029)
    m2=842868045681390934539739959201847552284980179958879667933078453950968566151662147267006293571765463137270594151138695778986165111380428806545593588078365331313084230014618714412959584843421586674162688321942889369912392031882620994944241987153078156389470370195514285850736541078623854327959382156753458029*166
    k=m
    p=0
    q=0
    while (m>10000):
        if(n%m==0):
            #print (m) A=(((y%x)**5)%(x%y))**2019+y**316+(y+1)/x
    根据方程可以直接算出x和y
    a=2683349182678714524247469512793476009861014781004924905484127480308161377768192868061561886577048646432382128960881487463427414176114486885830693959404989743229103516924432512724195654425703453612710310587164417035878308390676612592848750287387318129424195208623440294647817367740878211949147526287091298307480502897462279102572556822231669438279317474828479089719046386411971105448723910594710418093977044179949800373224354729179833393219827789389078869290217569511230868967647963089430594258815146362187250855166897553056073744582946148472068334167445499314471518357535261186318756327890016183228412253724
    x=1
    y=1
    n=0
    c=0
    d=0
    for x in range(1,100):
       for y in range(2,100):
           c=(y+1)/x
           d=x%y
           if(d!=0):
               n=(((y%x)**5)%d)**2019+y**316+c
           if(n==a):
                print (x)
                print (y)
可得x=2 y=83
p=next_prime(z _x_ y)
q=next_prime(z)
n=q*p
因此可以猜测n和（z _x_ y） _z的值也是很接近的，也就是n和z^2_
166是很接近的，那么sqrt(n/166)和q是很接近的。所以从sqrt(n/166)附近查找prime。
e是未知的，但是e的取值范围相对是小的，直接猜或者爆破，结果可知e为65537.
解密脚本
    import sympy
    import math
    import binascii
    from Crypto.Util.number import long_to_bytes
    n=117930806043507374325982291823027285148807239117987369609583515353889814856088099671454394340816761242974462268435911765045576377767711593100416932019831889059333166946263184861287975722954992219766493089630810876984781113645362450398009234556085330943125568377741065242183073882558834603430862598066786475299918395341014877416901185392905676043795425126968745185649565106322336954427505104906770493155723995382318346714944184577894150229037758434597242564815299174950147754426950251419204917376517360505024549691723683358170823416757973059354784142601436519500811159036795034676360028928301979780528294114933347127
    #m即是sqrt(n/166)的近似值
    m=sympy.nextprime(842868045681390934539739959201847552284980179958879667933078453950968566151662147267006293571765463137270594151138695778986165111380428806545593588078365331313084230014618714412959584843421586674162688321942889369912392031882620994944241987153078156389470370195514285850736541078623854327959382156753458029)
    c=86974685960185109994565885227776590430584975317324687072143606337834618757975096133503732246558545817823508491829181296701578862445122140544748432956862934052663959903364809344666885925501943806009045214347928716791730159539675944914294533623047609564608561054087106518420308176681346465904692545308790901579479104745664756811301111441543090132246542129700485721093162972711529510721321996972649182594310700996042178757282311887765329548031672904349916667094862779984235732091664623511790424370705655016549911752412395937963400908229932716593592702387850259325784109798223415344586624970470351548381110529919234353
    p=0
    q=0
    #从m附近查找q或p
    while(m>100):
        if(n%m==0):
            p=m
            print "p="
            print p
            q=n/p
            print "q=" 
            print q
            break
        m=sympy.nextprime(m)
    def egcd(a,b):
        if a==0:
            return (b,0,1)
        else:
            g,y,x=egcd(b%a,a)
            return (g,x-(b//a)*y,y)
    def modinv(a,m):
        g,x,y=egcd(a,m)
        if g!=1:
            raise Exception(" error")
        else:
            return x%m
    e=1
    d=0
    #爆破e
    while(e<100000):
        #try:
        #e=sympy.nextprime(e)
        e=65537 #最后爆破成功的e
        d=modinv(e,(p-1)*(q-1))
        m=pow(c,d,n)
        print long_to_bytes(m)
        m_hex = hex(m)[2:]
       # try:    
        print m_hex
        print("ascii:\n%s"%(binascii.a2b_hex(m_hex).decode("utf8"),))
       # except:
        #    if(e%10000==0):
         #       print e