sets gsk = tsk +hsk. It then calls Oc
X,Y on gsk to complete the
credential. Now, when the adversary creates a signature with
∗) on
a forged credential, we can extract a credential (a
breaking the generalized LRSW assumption.
the fresh gsk
Non-Frameability. An honest platform cannot be framed,
under the Discrete Logarithm (DL) assumption (which is
implied by the assumptions we make). The host sets gpk and ˜g
based on given the DL instance, and must simulate πgpk as it
does not know hsk such that gpk = tpk · ˜ghsk . When signing,
the host also simulates the zero-knowledge proofs. Now, if
an adversary creates a signature that links to a signature of
the honest platform, it must prove knowledge of the discrete
logarithm of gsk. We rewind to extract and break the DL
assumption.
Strong Privacy. Our DAA schemes fulﬁll strong privacy,
meaning that privacy is guaranteed as long as the host is
honest, i.e., even when the TPM involved in the generation of
an attestation is malicious. By Lemma 1, the proofs created
together with a (malicious) TPM are zero knowledge. This
means we can simulate these proofs without the adversary
noticing the difference. Further, note that a platform key gsk =
tsk + hsk is uniformly distributed over Zp as the host picks
hsk uniformly at random from Zp. To prove that signatures
are unlinkable, we let honest hosts pick a fresh key gsk every
time they sign with a new basename. This is indistinguishable
using a hybrid argument, where in the i-th hop, we use a fresh
key for bsn i. Every hop is indistinguishable from the previous
one under the Decisional Difﬁe-Hellman (DDH) assumption.
In a nutshell, the latter is proved as follows. Upon receiving
a DDH instance (α, β, γ), program the random oracle so that
HG1 (1||bsn i) ← β. The host sets α as the gpk value and
simulates proof πgpk . When signing, the host simulates the
proof of knowledge and sets nym ← γ. If the DDH instance
is a DDH tuple, the same key was used to sign, and if it is
not a DDH tuple, a fresh key was used.
Signatures are now done using a fresh key for each base-
name and the proofs are simulated, therefore no adversary can
possibly break the anonymity of signatures.
6. DAA WITH FORWARD ANONYMITY
An important reason to remove the DH oracle in the TPM
interfaces is that such an oracle prevents forward anonymity.
As Xi et al. [8] point out, a host that becomes corrupted can
test whether signatures were generated by the embedded TPM
using the DH oracle.
Modeling the property of forward anonymity requires one
to consider adaptive corruptions, i.e., a signature made by
a host should remain anonymous even when at some later
point the host becomes corrupted. A property-based notion
for this was formally introduced by Xi et al. [8]. However,
extending our ideal speciﬁcation to also provide this property
is nontrivial. First, to enable forward anonymity, the DAA
scheme must allow one to create signatures w.r.t. no basename,
i.e., bsn = ⊥ and forward anonymity only holds for such
signatures. Otherwise, a host
that becomes corrupt could
trivially link previous signatures generated for some basename
bsn (cid:4)= ⊥, by simply requesting a new signature w.r.t. bsn
and test for relation via the link algorithm. This means we
would have to remove signature-based revocation from our
security model. Second, our formal security proof considers
static corruptions, whereas forward anonymity is inherently
about dynamic corruptions. Indeed, realizing a scheme secure
w.r.t. dynamic corruptions would be much less efﬁcient than
the scheme we present in this paper.
Despite this,
the TPM interfaces we deﬁne allow one
to build a DAA scheme with forward anonymity (however,
the other security properties hold only in presence of static
corruptions). That is, if we remove signature-based revocation
from our DAA protocols, they fulﬁll the notion of forward
security by Xi et al. For LRSW-based DAA, signing with
bsn = ⊥ means that nym is omitted from the signature and
proof πcred. For q-SDH-based DAA, if bsn = ⊥ then nym is
replaced by jgsk , where j is taken uniformly at random from
G1 by the TPM, as in the q-SDH-based scheme by Brickell
and Li [3].
Proving the resulting scheme to be forward anonymous
would work as follows. The forward anonymity game consid-
ers a corrupt issuer. This means A can instruct platforms to
join, and A runs the issuer side of the protocol. A can request
complete signatures from joined platforms. Next, A submits
the identities of two platforms and a message. The challenger
chooses one of the two platforms at random and returns a
signature on the given message with basename bsn = ⊥ on
behalf of the chosen platform. The game now models the fact
that the host becomes corrupted by giving A access to the
914
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:27:02 UTC from IEEE Xplore.  Restrictions apply. 
TPM commands of the platforms, and A’s task is to ﬁnd out
which of the two platforms created the signature.
For both schemes, we can prove forward anonymity un-
der the DDH assumption, using a similar proof strategy as
for strong privacy. First, the challenger answers all oracles
correctly. Next, we modify the game slightly. The challenge
signature is now computed under a fresh key, instead of the
key of one of the two platforms that A submitted. In this
modiﬁed game, no adversary can win with probability better
2, as the bit that A has to guess is independent of A’s
than 1
view. This means A can only have non-negligible advantage
by distinguishing the two games. As argued in the strong
privacy proof in Sect. 5.3, the modiﬁcation in the games is
unnoticeable under the DDH assumption. showing that our
protocols without signature-based revocation satisfy forward
anonymity under the DDH assumption.
7. OTHER USES OF OUR TPM INTERFACES
In many protocols, the user would like to store his keys
in secure hardware rather than on a normal computer. This
way, the keys are secure and some security is preserved as
long as the trusted hardware is not compromised, even when
the computer is compromised. This section shows that due
to the generic design of our TPM interface, it can be used
to secure the keys of other cryptographic protocols. As an
example, we consider U-Prove and e-cash with keys stored
in a TPM, such that an attacker cannot use a user’s U-Prove
credential or e-cash wallet without access to the TPM. We
discuss these constructions here only informally, i.e., without
providing a security proof, as a formal treatment would require
a new security model and a detailed proof, which is beyond
the scope of this paper. For ease of presentation, we place the
full key in the TPM, although we could split the key over the
TPM and host as in our DAA schemes.
7.1 Device Bound U-Prove
xd
d ·h
x1
1 . . . gxn
n g
x1
1 . . . gxn
n g
U-Prove [7] is an attribute-based credential system where
credential issuance and credential presentation are unlinkable.
In the issuance protocol, the user receives a credential with
xd
d )α, where x1, . . . , xn are
public key h = (g0g
the attribute values of the user, and xd is the device secret.
The device secret makes sure that a secure device must be
present to use the credential. To show the credential, the user
must prove knowledge of x1, . . . , xn, xd, and α such that
−1/α, with the help of the secure device.
g0 = g
Our proposed changes for TPM 2.0 allow the TPM
to be used as
secure device for U-Prove. The value
xd will be the TPM secret key, and generator gd must
the
be
:
credential presentation proof SPK
−1/α} can be constructed by
g0 = g
(nym, π) ← Prove(0, g0,⊥, 1,⊥, 1,⊥,⊥,
computing
{(a1, g1,⊥,⊥), . . . , (an, gn,⊥,⊥), (1/α, h,⊥,⊥)},⊥,⊥).
By Lemma 3, such proofs can only be made with a
contribution from the TPM, so one’s credentials cannot be
stolen, unless the attacker can access the TPM.
the generator ¯g known to the TPM. Then,
∗{(x1, . . . , xn, xd, α)
x1
1 . . . gxn
n g
· h
xd
d
7.2 Compact E-Cash
Compact E-Cash [11] allows users to withdraw coins from
a bank, and later anonymously spend the coins. The protocol
assumes that every user has a key pair (skU , pkU = gskU ) with
which it can authenticate towards the bank. To withdraw 2l
coins, the user ﬁrst authenticates towards the bank by proving
knowledge of skU . The user picks wallet secrets s, l, where
the bank adds randomness to s, and the bank places signature
σ on committed values skU , s, and l, using a CL signature.
The result of the withdraw protocol is a wallet (skU , s, t, σ, J),
where J is an l-bit counter.
To spend a coin at merchant M, the user computes R ←
H(pkM , info), where the merchant provides info. Next, the
user computes a coin serial number S ← g
s+J+1 and value
T ← pkU · g
t+J+1 which is used to detect double spending of
coins. Finally, it proves
R
1
SPK{(J, skU , s, t, σ) : 0 ≤ J < 2l ∧ S = g
s+J+1 ∧
1
T ← pkU · g
R
t+J+1 ∧ Ver(pkB, (skU , s, t), σ) = 1}
y
z1
skU
2 , Y ← g
2, Z1 ← g
2 , Z2 ← g
We can instantiate Compact E-Cash such that users can
securely store their secret key skU inside a TPM, using a
trick similar as in our LRSW-based DAA scheme. To create
its keys, the bank picks secret key (x, y, z1, z2, z3) ←$ Z5
p and
sets public key X ← gx
z2
2 , and
Z3 ← g
z3
2 . The withdrawal of coins start by the bank picking a
fresh nonce n, and sending n, b ← H(n), a ← b1/y, Ai ← azi
and Bi ← bzi for i = 1, 2, 3 to the user. The user authenticates
1 ∧ d = bskU , as in our LRSW-based
by proving pkU = g
(cid:3), t, and r, and commits to
DAA scheme. In addition, it picks s
them using generators B1, B2, and B3: C ← Bs(cid:2)
1 Bt
2Br
3. The
(cid:3)
, t, r) to the
user sends C with a proof of knowledge of (s
(cid:3) by setting
(cid:3)(cid:3) to s
bank. The bank now adds randomness to s
(cid:3) ← C · Bs(cid:2)(cid:2)
(cid:3)(cid:3), t, and r, by setting
1 and signs skU , s = s
C
c ← (a· d· C
(cid:3)y)x = ax+xy(m+z1s+z2t+z3r). The user now has
signature σ = (a, A1, A2, A3, b, B1, B2, B3, c, d).
(cid:3) + s
To spend a coin, the user must compute R, S, and T ,
and prove that everything is correctly computed, as described
above. The TPM holding skU is only involved in proving that
σ is a valid CL signature on (skU , s, t, r). It randomizes the
signature by taking ρ ← Z
(cid:3) ← aρ, A
i ←
(cid:3)
(cid:3) ← cρ. To prove this randomized
ρ
i , b
A
signature signs (skU , s, t, r), the user creates the following
proof:
∗
p and setting a
(cid:3) ← bρ, B
i ← B
(cid:3)
ρ
i , c
(cid:3)
, g2)/e(a
(cid:3)
1, X)s
∗{(skU , s, t, r) : e(c
(cid:3)
(cid:3)
SPK
e(b
can
, X) =
(cid:3)
2, X)t
, X)skU e(B
e(B
the TPM using
This
proof
created with
, X), n, ρ, X, 1,⊥,⊥,
(∗, π) ← Prove(0, e(c
(cid:3)
(cid:3)
, g2)/e(a
2, X),⊥,⊥)},⊥,⊥). Now, by
1, X),⊥,⊥), (t, e(B
{(s, e(B
(cid:3)
(cid:3)
Lemma 3, a wallet can only be used if the attacker has access
to the TPM holding skU .
3, X)r}.
(cid:3)
e(B
be
8. CONCLUSION
The TPM is a widely deployed security chip that can be
embedded in platforms such that the platform can, among
915
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:27:02 UTC from IEEE Xplore.  Restrictions apply. 
to a remote veriﬁer that
other things, anonymously attest
it is in a secure state. Unfortunately, the current TPM 2.0
speciﬁcation for DAA contains several ﬂaws: it contains a
static DH oracle towards the host and attestations built on
top of this interface cannot be proven to be unforgeable. Fixes
proposed in the literature are either impossible to implement
within the constraints of the TPM, limit the functionality of
the TPM interface, or open a subliminal channel that allows a
malicious TPM to embed information in attestations, harming
the privacy of the host.
We presented a revised TPM 2.0 interface and a Prove
protocol for the host that allows the platform to create provably
secure signature proofs of knowledge. The interface does not
contain a DH oracle, and a corrupt TPM cannot break the
zero-knowledge property of the resulting proofs.
Using the Prove protocol, we constructed two provably
secure DAA schemes, one based on the LRSW assumption
and one on the q-SDH assumption, including DAA extensions
featuring signature-based revocation and attributes. Further-
more, we have shown that our TPM interface supports DAA
schemes with forward anonymity and can be used to protect
keys for other cryptographic schemes, such as e-cash and U-
Prove. These latter applications were only shown informally,
it remains future work to formally treat these applications.
The Trusted Computing Group has already adopted some of
our proposed changes and is currently reviewing the remaining
ones. It is our aim to bring these improvements to all the
existing attestation standards, such as EPID, ISO/IEC 20008-
2, and FIDO attestation, such that all implementations are
provably secure and can make use of TPMs.
Acknowledgments.
The ﬁrst, third, and fourth author have been supported by
the European Research Council (ERC) under Grant #321310
(PERCY).
REFERENCES
[1] E. Brickell, J. Camenisch, and L. Chen, “Direct anonymous attestation,”
in ACM CCS. ACM, 2004, pp. 132–145.
[2] Trusted Computing Group, “TPM main speciﬁcation version 1.2,” 2004.
[3] E. Brickell and J. Li, “A pairing-based DAA scheme further reducing
TPM resources,” in Trust and Trustworthy Computing: TRUST 2010,