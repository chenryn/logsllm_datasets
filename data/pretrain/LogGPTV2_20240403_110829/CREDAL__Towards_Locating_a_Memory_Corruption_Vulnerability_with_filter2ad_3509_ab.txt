10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
static int ngx_http_read_discarded_request_body
(ngx_http_request_t *r){
size_t size;
ssize_t n;
ngx_int_t rc;
ngx_buf_t b;
u_char buffer[NGX_HTTP_DISCARD_BUFFER_SIZE];
...
ngx_memzero(&b, sizeof(ngx_buf_t));
b.temporary = 1;
for ( ;; ) {
...
// Choose the minimum value between the
two arguments
size = (size_t) ngx_min(r->headers_in.
content_length_n,
NGX_HTTP_DISCARD_BUFFER_SIZE);
//copy data to buffer
n = r->connection->recv(r->connection,
buffer, size);
...
b.pos = buffer;
b.last = buffer + n;
rc = ngx_http_discard_request_body_filter
(r, &b);
if (rc != NGX_OK) {
return rc;
}
}
}
Table 1: A code fragment from Nginx-1.4.0 vulnerable to an integer overﬂow
(CVE-2013-2028).
In this example, r->headers_in.content_length_n is
a signed integer type, whereas variable size is an unsigned type.
This inconsistency can potentially triggers a stack overﬂow which
may further results in a crash and even arbitrary code execution.
Speciﬁcally, an attacker can set r->headers_in.content_-
length_n to negative. Due to the inconsistency in variable type,
the value of r->headers_in.content_length_n can be
misinterpreted as a very large positive number when casting to
unsigned type variable size. As is deﬁned in line 8, array
buffer can only carry NGX_HTTP_DISCARD_BUFFER_SIZE
bytes of data. Since the value in size is larger than constant
NGX_HTTP_DISCARD_BUFFER_SIZE, the request can overﬂow
buffer and corrupt the data on the stack.
Figure 1 illustrates part of information in a core dump after ex-
ploiting the aforementioned vulnerability with a public PoC [13].
We observe the exploit overﬂows buffer and corrupts the local
variables, argument and return address of function ngx_http_-
read_discarded_request_body. For this speciﬁc example,
these corrupted data on the stack do not interrupt the process execu-
tion until the function returns. At the time the function returns, the
running process simply restores frame pointer EBP to the previous
value held in it1, and sets program counter EIP to the return address
on the stack. As such, we observe both EBP and EIP are set to an
invalid address (0x41414141) at the time of the crash.
Since EBP is designed to provide a frame pointer for the current
function, and EIP holds the address of the next CPU instruction,
1Note that most compilers provide an option to omit frame pointers.
With that option enabled, it makes debugging even more difﬁcult.
To illustrate the difﬁculty in identifying debugging information in a
core dump, we assume software developers can retrieve information
from EBP to assist their failure diagnosis.
Figure 1: The status of the crashing stack and processor registers after
exploiting the overﬂow vulnerability speciﬁed in CVE-2013-2028. For
simplicity and demonstration, the stack protector has been disabled.
at the time of a program crash, their snapshots typically indicate
the crash function and crash point, respectively. With both process
registers holding an invalid address at the time of the crash, however,
software developers receive no clue as to the program crash. In
the following sections, we will therefore develop new technical
approaches to identify the crash point as well as the stack traces of
a crashing program.
3. OVERVIEW
In this section, we discuss our design principle followed by the
description about how CREDAL performs core dump analysis at a
high level.
3.1 Design Principle
When locating a software defect, it is always beneﬁcial for soft-
ware developers to narrow down the manual efforts to code with as
few lines as possible. Ideally, we would like to minimize the manual
effort of a developer by designing CREDAL to pinpoint a software
defect directly. However, a core dump may carry a certain amount
of corrupted data, and the information held in it only provides a
partial chronology of how the program reached a crash point. To
track down a software defect, therefore, we need to design CREDAL
to infer the ambiguity about program execution. This potentially
increases the uncertainty in the information that CREDAL provides
to the developers. Considering such uncertainty may mislead failure
diagnosis, our design follows a conservative principle – maximizing
the reliability of the information that CREDAL produces by minimiz-
ing the uncertainty in core dump analysis.
3.2 Technical Approach
In an extreme case, we can design CREDAL to achieve zero uncer-
tainty in core dump analysis by giving no information to software
developers. However, such a design sacriﬁces the utility of a core
dump in failure diagnosis. To balance between utility and uncer-
tainty, we therefore design CREDAL as follows.
As mentioned in Section 1, a crash point typically serves as the
starting point of failure diagnosis, and a stack trace can narrow down
the list of candidate ﬁles that possibly contain software defects. As
a result, we design CREDAL to provide this essential information
needed by software developers and security analysts. Considering
memory corruption discards data dependency, and presenting data
dependency mismatch may facilitate failure diagnosis, we also de-
sign CREDAL to highlight the code fragments corresponding to data
dependency mismatch.
rret addrold EBPsizenrcbbuffer…...…...ESPCorrupted dataEIP=0x41414141EBP=0x41414141mov %ebp, %esppop %ebpretFunction EpilogStack Layout531To track down the crash point, CREDAL extracts the ﬁnal value of
the program counter stored in a core dump simply because a program
counter at the crash reveals where a program crash occurred. As
mentioned in Section 2, a memory corruption vulnerability may
overwrite a program counter to an invalid value. Before using it
to pinpoint the crash point, CREDAL therefore checks the validity
of the program counter. For the program counter with an invalid
value, CREDAL attempts to restore its value using the data within a
previously returned stack frame. We will describe more details in
the following section.
To identify a stack trace, CREDAL follows the DWARF stan-
dard [18] to unwind a crashing stack. CREDAL can traceback all the
functions that have been called but not yet returned at the time of the
crash. Note that memory corruption undermines the data on the stack
and may thwart stack frame identiﬁcation. Following the design
principle above, CREDAL stops stack frame identiﬁcation and pro-
duces a partial stack trace when identifying a stack frame that does
not match certain heuristics. Figure 2 shows one situation where
a stack trace cannot be fully identiﬁed in an accurate manner and
CREDAL terminates in advance. The program crashes in function
crash(). Using the remnants stored on its stack frame, CREDAL
computes the Canonical Frame Address (CFA) and tracebacks to
parent function foo(). However, a stack overﬂow occurred in
foo(), overwrote the data held in the frame and made it invalid.
Considering that the program may have an earlier call to bar1() or
bar2(), and there is insufﬁcient information about the execution
path in the lead-up to the crash, CREDAL terminates stack trace iden-
tiﬁcation and outputs a partial stack trace with function crash()
and its caller foo().
To pinpoint data dependency mismatch, CREDAL ﬁrst constructs
a control ﬂow graph (CFG). Given the graph along with the afore-
mentioned crash point and stack trace, CREDAL further performs an
inter-procedural points-to analysis and an inter-procedural reaching
deﬁnition analysis. These analyses allow CREDAL to obtain a set of
data dependency constraints and thus identify the variables with mis-
matching dependency. For the variables with mismatching values,
CREDAL further highlights the code fragments corresponding to the
mismatch, and presents the code fragment with minimal number
of lines of code to software developers (or security analysts). The
intuition here is that these code lines may be potentially used as
reference for locating a memory corruption vulnerability. In the
following section, we will discuss CREDAL with more technical
details.
4. DESIGN
In this section, we discuss the technical details of CREDAL.
Speciﬁcally, we start with crash thread identiﬁcation. Then, we
describe how CREDAL identiﬁes the crash point, stack trace and
data dependency mismatch in detail. In addition, we specify the
uncertainty that CREDAL may introduce in core dump analysis, and
discuss how we leverage technical approaches to minimize this
uncertainty.
As is mentioned earlier, a core dump carries the values of proces-
sor registers and the values stored in memory, which can be directly
consumed by binary-level analysis. As such, we perform core dump
analysis mainly on binaries. Considering data ﬂow analysis is typi-
cally performed on source code, and source code is self-evident for
software developers, we therefore translate the information derived
from binary-level analysis into a form that is amenable to source
code level analysis. In Section 5, we will describe how to imple-
ment CREDAL to map the values in memory and x86 instructions to
variables and the statements in source code.
4.1 Discovering Crashing Thread
A process may contain multiple threads. When it crashes, an
operating system includes recorded state of the working memory
of each thread in a single core dump. To provide useful, interesting
information for crash diagnosis, CREDAL ﬁrst needs to identify the
crashing thread in the core dump.
In this work, CREDAL employs the state of the program counter
to identify a crashing thread. In particular, CREDAL examines the
program counter of each thread at the crash. When CREDAL dis-
covers a program counter that points to an invalid memory address
or an illegal instruction (e.g., the instruction containing an invalid
opcode or incurring a ﬂoating point exception), CREDAL deems
the corresponding thread as the one that crashes the process. For
the situation where a program counter points to a valid instruction
but the instruction attempts to access an invalid memory address,
CREDAL also treats the corresponding thread as the one contributing
to the crash.
4.2 Tracking down Crash Point
As is mentioned in Section 3, a crash point is typically enclosed
in the program counter at the crash. Due to the corrupted data on
stack and in processor registers, the program counter may hold an
invalid value, making crash point identiﬁcation difﬁcult.
Here, we deal with this technical issue using the previously re-
turned stack frames. The intuition here is that a crash function
generally does not overwrite the stack frame allocated for the earlier
function call, and the data on this stack frame can facilitate the iden-
tiﬁcation of the crash point. Figure 2 illustrates an example where
a program unexpectedly terminated in function crash() but the
data on the stack frame corresponding to an earlier call to bar()
has not yet been overwritten. Since the return address of function
bar() is stored on its stack frame, and directly points to the next
instruction that would be executed in function crash(), the crash
function can be easily identiﬁed through this linkage.
However, a crashing stack does not provide sufﬁcient information
that can help pinpoint previously returned stack frames on a crashing
stack. To address this problem, we scan a crashing stack through a
sliding window, looking for the return address of the function that
was just called (but presumably silently returned) before the crash.
The intuition here is that a function pushes the return address of
its child on the stack at the time the child is invoked, and we use
the child as the indicator of the stack frame corresponding to the
function.
In this work, we set the size of the sliding window to memory
address width (e.g., 4 bytes for a 32-bit operating system). The scan
of the crashing stack starts from the top of the stack indicated by
the value of stack pointer ESP plus an offset equal to the memory
address width (e.g., ESP+4 for a 32-bit operating system).
CREDAL follows two criteria when determining if the value held
in the sliding window represents the return address of the previously
returned function. As a return address points to the instruction that
would be executed after a function returns, CREDAL ﬁrst ensures the
value in the window links to a valid instruction. Second, CREDAL
examines the instruction above the one corresponding to the return
address. In particular, CREDAL checks if that instruction is a call