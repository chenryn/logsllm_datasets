④ 执行!process 0 0命令列出所有进程，并在其中找到关于
ImBuggy.exe的内容。
kd> !process 0 0
**** NT ACTIVE PROCESS DUMP ****
…
PROCESS 823ee898  SessionId: 0  Cid: 0774    Peb: 7ffd8000  ParentCid: 065
c
   DirBase: 0ca83000  ObjectTable: e1afa390  HandleCount:  22.
   Image: ImBuggy.exe
…
上面结果中，DirBase的值0ca83000 就是ImBuggy进程的页目录基地
址，执行r cr命令显示CR3寄存器的内容，与此刚好相同。
kd> r cr3
cr3=0ca83000
这说明产生转储时，当前进程就是ImBuggy进程，事实上是这个进
程调用驱动程序realbug.sys导致系统蓝屏崩溃，崩溃后，系统自动产生
了这个转储文件。
⑤ 执行lmvm realbug显示realbug模块的详细信息，注意它的起始地
址和结束地址：
kd> lmvm realbug
start    end        module name
f8c2e000 f8c35000   RealBug …
⑥ 执行s –sa命令，以realbug模块的起始地址和结束地址为界，搜
索其中的所有ASC串：
kd> s -sa f8c2e000 f8c35000
f8c2e04d  "!This program cannot be run in D"
f8c2e06d  "OS mode.
…
⑦ 接下来的目标就是将上面的经典字符串的线性地址f8c2e04d转换
为物理地址。先将这个线性地址转化为二进制：
kd> .formats f8c2e04d
  Binary:  11111000 11000010 11100000 01001101
根据图2-12，高10位是页目录索引，即：
kd> ? 0y1111100011
Evaluate expression: 995 = 000003e3
中间10位是页表索引，即：
kd> ? 0y0000101110
Evaluate expression: 46 = 0000002e
低12位是页内偏移，即04d。
⑧ 根据图2-4，CR3的高20位就是页目录基地址的高20位，低12位
为0，因此，ca83000就是ImBuggy进程的页目录基地址。于是，使用!dd
命令（显示物理内存，注意有！号）就可以显示出页目录表的内容：
kd> !dd 0ca83000
# ca83000 0cabc067 0ca37067 0ca74067 00000000
# ca83010 00000000 00000000 00000000 00000000
…
页目录的每一项是4个字节，根据上一步的页目录索引计算偏移
量，便可以显示出所要找的页目录表项（PDE）：
kd> !dd 0ca83000+3e3*4 L1
# ca83f8c 0101a163
命令中的L1用来限制要观察的内存长度，表示只显示一个32位数
据。至此，我们在ImBuggy进程的页目录表中找到了线性地址f8c2e04d
所使用的页目录项，其内容为0101a163。
⑨ 根据图2-9，PDE的高20位为页表起始地址的高20位，这意味着
0x0101a000就是我们要找的页表基地址。PDE的低12位（163）代表的
是页表属性，将0x163转换为二进制0001 01100011b，便得到其各位由
低到高的含义如下。
位0，Present位，1表示该内存页在物理内存中。
位1，R/W位，即读写权限，1表示可读可写。
位2，U/S位，即用户还是系统权限，0表示系统权限。
位3，Page level Write Through位，用于控制高速缓存（write-back还
是write-through）策略，1表示write-back。
位4，Page level cache disable（禁止页级缓存）位，0表示没有禁止
缓存该页。
位5，A（Accessed）位，内存管理器在把内存页加载到物理内存
后，通常会清除此位，当有访问发生时再设置此位，1表示对应的
内存页（下级页表）被访问过。
位6，D（Dirty）位，1表示对应的内存页被写过。
位7，PS（Page Size）位，即页大小，1表示4MB或2MB（如果启用
了扩展物理寻址（PAE）功能），0表示4KB大小的普通内存页。
位8，G位，即是否为全局页，全局页是Pentium Pro引入的功能，如
果某个内存页被标记为全局页，而且CR4的PGE标志为1，那么当
CR3寄存器内容变化或任务切换时，TLB中用于全局页的页表和页
目录表项不会失效，1表示是全局页。
位9～11，供内存管理软件（操作系统的内存管理器）使用。
⑩ 继续使用!dd命令观察页表，根据第7步，页表索引是0x2e，每个
页表表项的长度是4字节，所以应该观察物理地址0x0101a000+2e*4。
kd> !dd 0x0101a000+2e*4 L1
# 101a0b8 0d566163
也就是说，页目录表项的内容为0d566163，根据图2-9，其含义
为：高20位为所在内存页的起始地址的高20位，即目标地址所在内存页
的基地址是0x0d566000；低12位（163）代表的是内存页的属性，其解
释与第9步中的内容类似，不再赘述。
⑪ 得到了页的基地址后，加上页内偏移（0x04d）便是最终的物理
地址了。综合以上结果，线性地址f8c2e04d的物理地址是0x0d56604d，
使用!db命令观察这个物理地址：
kd> !db 0x0d56604d
# d56604d 21 54 68 69 73 20 70 72-6f 67 72 61 6d 20 63 61 !This program ca
# d56605d 6e 6e 6f 74 20 62 65 20-72 75 6e 20 69 6e 20 44 nnot be run in D
# d56606d 4f 53 20 6d 6f 64 65 2e-0d 0d 0a 24 00 00 00 00 OS mode....$....
可见物理地址0x0d56604d处的内容与我们在第6步看到的线性地址
f8c2e04d处的内容是完全一致的。
⑫ 以上出于学习目的，我们模仿CPU的地址翻译行为，一步步地将
线性地址手工翻译为物理地址。其实，只要执行WinDBG的!pte命令便
可以自动帮我们执行以上步骤：
kd> !pte f8c2e04d
               VA f8c2e04d
PDE at C0300F8C         PTE at C03E30B8
contains 0101A163       contains 0D566163
pfn 101a  -G-DA--KWEV   pfn d566  -G-DA—KWEV
以上结果的含义是，线性地址对应的PDE位于C0300F8C（线性地
址，与第8步中的物理地址ca83f8c等价），其内容为0101A163；PTE位
于C03E30B8，内容为0D566163（与第10步一致）。
最后一行中的pfn是Page Frame Number的缩写，即页帧号。这是内
存管理中的一个常用术语，代表以页为单位的物理内存编号。x86中，
以4KB为页单位，因此页帧号其实就是物理地址的高20位，知道页帧号
后，在其后补上页内偏移（线性地址的低12位），便得到线性地址。以
上面结果为例，pfn是d566，加上低12位04d便得到f8c2e04d对应的物理
地址d56604d。
2.7.2 PAE分页
前面介绍的32位经典分页模式是由386 CPU引入的，是x86架构实现
的第一种分页模式。使用这种分页模式，可以将32位的线性地址映射到
32位的物理地址。从地址空间的角度来讲，使用这种分页模式时，线性
地址和物理地址的空间都是4GB大小。随着计算机的发展，计算机所配
备的物理内存不断增多。为了适应这个发展趋势，于1995年推出的
Pentium Pro处理器引入了一种新的分页模式，物理地址的宽度被扩展为
36位，可以最多支持64GB物理内存，这种分页模式称为物理地址扩
展，简称PAE。相对于上面介绍的32位分页模式，PAE分页的主要变化
如下。
页目录表项和页表表项都从原来的32位扩展到64位，低12位仍为标
志位，从Bit 12到Bit 35的高24位用来表示物理地址的高24位。这样
改变后，物理地址就从原来的32位扩展到36位，最多可以索引
64GB的物理内存。
将原来的二级页表结构改为三级，新增的一级称为页目录指针表
（Page Directory Pointer Table，PDPT）。页目录指针表包含4个64
位的表项，每个表项指向一个页目录。每张页目录描述1GB的线性
地址空间，4张页目录一起刚好描述4GB的线性地址空间。
CR3寄存器的格式略有变化，低5位保留不用，高27位指向页目录
指针表的起始物理地址。
PAE模式下将32位的线性地址映射到4KB内存页时的页表结构和映
射方法如图2-13所示。此时，32位线性地址被分割为如下4个部分。
2位（位30和位31）的页目录指针表索引，用来索引本地址在页目
录指针表中的对应表项。
9位（位21～29）的页目录表索引，用来索引本地址在页目录表中
的对应表项。
9位（位12～20）的页表索引，用来索引本地址在页表中的对应表
项。
12位（位0～11）的页内偏移，这与32位分页模式是相同的。
图2-13 将线性地址映射到4KB内存页的过程（PAE分页）
结合图2-13，对于PAE分页还有以下几点值得说明：首先，因为使
用CR3表示的页目录指针表的起始地址仍为32位，所以就要求页目录指
针表一定要分配在物理地址小于4GB的内存中。其次，因为CR3的低5
位保留不用，所以又要求这个起始地址的低5位为0，可以被32整除。最
后，与32位分页相比，32位线性地址中的页目录索引位和页表索引位都
从10位减少到9位，所以每张页目录和页表的总表项数也由1024项减少
为512，同时每个表项的大小由4个字节增加到8个字节，所以每张页目
录或者页表的总大小仍然是4KB。总体来看，虽然每张页目录和页表的
表项数少了一半，但因为增加了一级映射，页目录的数量由原来的1张
变为最多4张，所以支持的最大页面数仍然是4×512×512 = 220，即2M
个。
 格物致知
下面仍然通过动手试验来加深理解PAE分页。
① 启动WinDBG，打开DUMP文件
C:\swdbg2e\dumps\xpsp3pae\MEMORY.DMP。
② 执行r cr4显示控制寄存器CR4的内容：
kd> r cr4
cr4=000006f9
执行.formats 6f9，得到对应的二进制：
Binary:  00000000 00000000 00000110 11111001
其中，Bit 5为1代表启用了PAE。
③ 执行r cr3显示控制寄存器CR3的内容：
kd> r cr3
cr3=072c0260
这就是当前正在使用的页目录指针表的物理地址，注意这个数值的
低5位全都为0。因为每个进程的页目录指针表的表项只有4个，所以可
以使用!dq命令将当前进程的页目录指针表的所有表项显示出来：
kd> !dq 072c0260 L4
# 72c0260 00000000`1020e001 00000000`1014f001
# 72c0270 00000000`10090001 00000000`1028d001
④ 重复上一个试验的步骤5和步骤6，找到以下字符串的线性地
址：
f8bdd04d  "!This program cannot be run in D"
f8bdd06d  "OS mode."
⑤ 将线性地址f8bdd04d转化为二进制：
Binary:  11111000 10111101 11010000 01001101
⑥ 根据图2-13，先取最高两位0y11，即3，结合步骤3中的页目录指
针表内容，可以得到线性地址对应的页目录表基地址为1028d000。
⑦ 取线性的次高9位作为索引，加上页目录基地址，便可以观察到
页目录项：
kd> !dq 1028d000+(0y111000101)*8 L1
#1028de28 00000000`01033163
将低12位的标志位替换为0，便得到页表基地址，即1033000。
⑧ 将页表基地址加上再次9位代表的页表索引，即得到页表项：
kd> !dq 1033000+(0y111011101)*8 L1
# 1033ee8 00000000`10561163
最低位为1代表对应的内存页有效，将低12位的标志位替换为0，便
得到内存页的基地址10561000，加上最低12位代表的页内偏移，便得到
了线性地址f8bdd04d对应的物理地址1056104d。
⑨ 执行!pte f8bdd04d，让WinDBG自动执行以上翻译过程。
kd> !pte f8bdd04d  
                 VA f8bdd04d
PDE at C0603E28          PTE at C07C5EE8
contains 0000000001033163  contains 0000000010561163
pfn 1033     -G-DA--KWEV  pfn 10561    -G-DA--KWEV
可见，这个结果与我们手工得到的结果完全吻合。
2.7.3 IA-32e分页
在支持64位的Intel 64架构中，对PAE分页做了进一步扩展，页表结
构扩充为4级，可以支持的线性地址和物理地址宽度都大大增加。在英
特尔的软件手册中，这种分页模式称为IA-32e分页。