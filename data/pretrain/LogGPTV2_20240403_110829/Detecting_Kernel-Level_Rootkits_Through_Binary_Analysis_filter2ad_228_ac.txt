the prototype for the control group, resulting in a false pos-
itive rate of 0%. We thus conclude that the detection algo-
rithm is completely successful in distinguishing rootkits ex-
hibiting speciﬁed malicious behavior from legitimate kernel
modules, as no misclassiﬁcations occurred during the entire
detection evaluation.
scan: initializing scan for rootkits/all-root.o
scan: loading kernel symbol table from boot/System.map
scan: kernel memory configured [c0100000-c041eaf8]
scan: resolving external symbols in section .text
scan: disassembling section .text
scan: performing scan from [.text+40]
scan: WRITE TO KERNEL MEMORY [c0347df0] at [.text+50]
scan: 1 malicious write detected, denying module load
Figure 3. all-root rootkit analysis.
Proceedings of the 20th Annual Computer Security Applications Conference (ACSAC’04) 
1063-9527/04 $ 20.00 IEEE 
Rootkit Technique Description
adore
syscalls
all-root
kbdv3
kkeylogger
rkit
shtroj2
synapsys
syscalls
syscalls
syscalls
syscalls
syscalls
syscalls
File, directory, process, and socket hiding
Rootshell backdoor
Gives all processes UID 0
Gives special user UID 0
Logs keystrokes from local and network logins
Gives special user UID 0
Execute arbitrary programs as UID 0
File, directory, process, socket, and module hiding
Gives special user UID 0
Table 1. Evaluation rootkits.
Module Set Modules Analyzed Detections Misclassiﬁcation Rate
Development rootkits
Evaluation rootkits
Fedora Core 1 modules
2
6
985
2
6
0
0 (0%)
0 (0%)
0 (0%)
Table 2. Detection results.
To verify that the detection algorithm performed correctly
on the evaluation rootkits, traces of the analysis performed
by the prototype on each rootkit were examined with re-
spect to the corresponding module code. As a simple exam-
ple, consider the case of the all-root rootkit, the analy-
sis trace of which is shown in Figure 3. From the trace, we
can see that one malicious kernel memory write was detected
at .text+50 (i.e., at an offset of 50 bytes into the .text
section). By examining the disassembly of the all-root
module, the relevant portion of which is shown in Fig-
ure 4, we can see that the overwrite occurs in the module’s
initialization function, init module()1. Speciﬁcally, the
movl instruction at .text+50 is ﬂagged as a malicious
write to kernel memory. Correlating the disassembly with
the corresponding rootkit source code, shown in Figure 5,
we can see that this instruction corresponds to the write to
the sys call table array to replace the getuid() sys-
tem call handler with the module’s malicious version at line
4. Thus, we conclude that the rootkit’s attempt to redirect a
system call was properly detected.
4.2. Performance Results
For the performance evaluation, the elapsed execution
time of the analysis phase of the prototype was recorded
for all modules, legitimate and malicious. Time spent pars-
ing the object ﬁle and patching relocation table entries into
1 Note that this disassembly was generated prior to kernel symbol resolu-
tion, thus the displayed read and write accesses are performed on place
holder addresses. At runtime and for the symbolic execution, the proper
memory address would be patched into the code.
00000040 :
40: a1 60 00 00 00
45: 55
46: 89 e5
48: a3 00 00 00 00
4d: 5d
4e: 31 c0
50: c7 05 60 00 00 00 00
57: 00 00 00
5a: c3
mov 0x60,%eax
push %ebp
mov %esp,%ebp
mov %eax,0x0
pop %ebp
xor %eax,%eax
movl $0x0,0x60
ret
Figure 4. all-root module disassembly.
1 int init_module(void)
2 {
3
orig_getuid =
sys_call_table[__NR_getuid];
4
sys_call_table[__NR_getuid] =
give_root;
5
6
7 }
return 0;
Figure 5. all-root initialization function.
the module was excluded, as these functions are already per-
formed as part of the normal operation of the existing mod-
ule loader. The goal of the evaluation was to provide some
indication about the performance overhead introduced by the
detection process in the loading of a module in a production
kernel. Note that as mentioned previously, no runtime over-
Proceedings of the 20th Annual Computer Security Applications Conference (ACSAC’04) 
1063-9527/04 $ 20.00 IEEE 
head is generated by our technique after the module has been
loaded.
Detection Overhead
 1000
l
s
e
u
d
o
M
f
o
r
e
b
m
u
N
 100
 10
 1
 0
 100
 200
 300
Execution Time (ms)
 400
 500
Figure 6. Detection overhead on module load.
Figure 6 shows the elapsed execution time of all evalu-
ated modules, discretized into log-scale buckets with a width
of 10 ms. As we can see, the vast majority of modules would
experience a delay of 10 ms or less during module load. Sev-
eral modules with more complex initialization procedures
(and thus complex control ﬂow graphs) required more time
to fully analyze, but as can be seen in Table 3, the detection
algorithm never spent more than 420 ms to classify a mod-
ule as malicious or legitimate. Thus, we conclude that the
impact of the detection algorithm on the module load opera-
tion is acceptable for a production system.
Minimum Maximum Median
0.00 ms
0.00 ms
Table 3. Detection overhead statistics.
Std. Deviation
420.00 ms
39.83
5. Discussion
Our prototype is a user-space program that statically an-
alyzes Linux loadable kernel modules for the presence of
rootkit functionality. These modules have to be ELF object
ﬁles that are compiled for the Intel x86 architecture.
The limitation on the classes of modules that can be an-
alyzed stems from the fact that a kernel module needs to be
parsed and its code sections disassembled before the actual
analysis can start. Therefore, additional parsing and disas-
sembly routines would be necessary to process different ob-
ject ﬁle formats or instruction sets. Because a vast majority
of Linux systems run on Intel x86 machines, and because
Linux kernel modules have to be provided as ELF object
ﬁles, we developed our prototype for this combination. The
analysis technique itself, however, can be readily extended
to other systems.
Our tool is currently available as a user program only. In
order to provide automatic protection from rootkits, it would
be necessary to integrate our analyzer into the kernel’s mod-
ule loading infrastructure. As an additional requirement, the
analyzer must not be bypassable when a process with root
permissions attempts to load a module. The reason is that
kernel modules can only be inserted by the root user. Thus,
the threat model has to assume that the attacker has supe-
ruser privileges when attempting to load a kernel module.
Up until Linux 2.4, most work of the module loading pro-
cess was done in user space, using the insmod program. In
this case, adding our checker to insmod would not be use-
ful because an attacker can simply supply a customized ver-
sion without checks. The solution is to move the analyzer
code into kernel space. Interestingly, starting from Linux 2.5,
most of the module loading code has been moved into the
kernel space, providing an optimal place to add our checks.
Unfortunately, mechanisms have been proposed to inject
code directly into the kernel without using the module load-
ing interface. These ideas originated from the fact that some
system administrators disabled the module loading function-
ality as a defense against kernel-level rootkits. These mech-
anisms operate by writing the code directly into kernel space
via the /dev/kmem device, completely bypassing the mod-
ule loading code.
In our opinion, a sensible and secure solution would disal-
low modiﬁcations of kernel memory via /dev/kmem, a fea-
ture that is already offered by Linux security solutions such
as grsecurity [5]. In addition, our kernel-level rootkit analy-
sis system would operate in kernel context behind the mod-
ule loading interface, thus having the opportunity to stati-
cally scan each module before it gets to run as part of the
kernel.
A possible way for rootkits to evade the behavioral spec-
iﬁcation that is based on forbidden kernel symbols (see Sec-
tion 3 for details) is to stop using these symbols. However, to
perform the necessary modiﬁcations of the kernel data struc-
tures or function pointers, their addresses are needed. There-
fore, alternative approaches to resolving these addresses are
required. One option is to use a brute force guessing tech-
nique that works by scanning the kernel memory for the oc-
currence of “known content” that is stored at the target loca-
tion. This is particularly effective for the system call table.
The reason is that its content is known because system call
table entries are pointers to handler functions whose sym-
bols are exported.
Although a brute force guessing approach might not al-
ways be suitable, we propose the addition of a speciﬁca-
tion that considers the scanning of kernel memory as an-
other indication of the presence of a rootkit. This speciﬁ-
cation checks for loops that, starting from any kernel sym-
bol, sequentially read data and compare this data to constant
values. Also, note that the speciﬁcation that checks for il-
Proceedings of the 20th Annual Computer Security Applications Conference (ACSAC’04) 
1063-9527/04 $ 20.00 IEEE 
References
[1] A. Aho, R. Sethi, and J. Ullman. Compilers – Principles,
Techniques, and Tools. World Student Series of Computer
Science. Addison Wesley, 1986.
[2] S. Aubert.
rkscan: Rootkit Scanner.
http:
//www.hsc.fr/ressources/outils/rkscan/
index.html.en, 2004.
[3] Black Tie Affair. Hiding Out Under UNIX. Phrack Maga-
zine, 3(25), 1989.
[4] FuSyS. Kstat v. 1.1-2. http://s0ftpj.org/, November 2002.
[5] grsecurity. An innovative approach to security utilizing a
multi-layered detection, prevention, and containment model.
http://www.grsecurity.net/, 2004.
[6] Halﬂife. Abuse of the Linux Kernel for Fun and Proﬁt. Phrack
Magazine, 7(50), April 1997.
[7] G. Kim and E. Spafford. The Design and Implementation of
Tripwire: A File System Integrity Checker. Technical report,
Purdue University, Nov. 1993.
[8] T. Lawless.
St. Michael and St. Jude.
http://
sourceforge.net/projects/stjude/, 2004.
[9] T. Miller. T0rn rootkit analysis. http://www.ossec.
net/rootkits/studies/t0rn.txt.
[10] T. Miller. Analysis of the KNARK Rootkit. http://www.
ossec.net/rootkits/studies/knark.txt, 2004.
[11] N. Murilo and K. Steding-Jessen. Chkrootkit v. 0.43. http:
//www.chkrootkit.org/.
[12] D. Safford. The Need for TCPA. IBM White Paper, October
2002.
[13] sd and devik. Linux on-the-ﬂy kernel patching without LKM.
Phrack Magazine, 11(58), 2001.
[14] Stealth.
adore. http://spider.scorpions.net/
˜stealth, 2001.
[15] Stealth. Kernel Rootkit Experiences and the Future. Phrack
Magazine, 11(61), August 2003.
[16] Stealth.
adore-ng.
rootkits/, 2004.
http://stealth.7350.org/
[17] TCG. Trusted Computing Group Home. https://www.
trustedcomputinggroup.org/home, 2004.
legitimate memory accesses based on actual destination ad-
dresses works independently of kernel symbols referenced
by the module.
6. Conclusions
Rootkits are powerful attack tools that are used by in-
truders to hide their presence from system administrators.
Kernel-level rootkits, in particular, directly modify the ker-
nel, and, therefore, can intercept and prevent any attempt of
an administrator to determine if the security of the system
has been violated. Because of this, it is important to devise
mechanisms that can protect the integrity of the kernel even
in the aftermath of the compromise of the administrator ac-
count.
This paper presents a technique that is based on static
analysis to identify instruction sequences that are an indi-
cation of rootkits. Informal behavioral speciﬁcations deﬁne
such characteristic instruction sequences as data transfer op-
erations that write to certain illegitimate kernel memory ar-
eas. Symbolic execution is then used to simulate the execu-
tion of the kernel module to detect instructions that fulﬁll
these speciﬁcations. Through this method, it is possible to
detect malicious behavior before a module is loaded into the
kernel, and, in addition, it is possible to operate on closed-
source components, such as proprietary drivers.
We implemented our technique in a prototype tool and we
evaluated both the effectiveness and the performance of the
tool with respect to nine real-world rootkits as well as the
complete set of 985 legitimate kernel modules that are in-
cluded with the Fedora Core 1 Linux distribution. The re-
sults show that all tested rootkits were successfully identi-
ﬁed, and no false positives were raised on legitimate mod-
ules. We thus conclude that the technique can reliably de-
tect malicious kernel modules and, therefore, it represents a
useful tool to harden the operating system kernel. In addi-
tion, we show that detection can be done efﬁciently, despite
the application of a potentially expensive static analysis tech-
nique.
Future work will be centered on devising a more formal
description of the aspects that characterize rootkit-like be-
havior. In addition, we plan to study how attacks that attempt
to bypass our detection procedures can be prevented. Finally,
we intend to integrate the detection component into the ker-
nel module loader infrastructure as a step towards preparing
the system for general usage.
Acknowledgments
This research was supported by the Army Research Of-
ﬁce, under agreement DAAD19-01-1-0484 and by the Na-
tional Science Foundation under grants CCR-0209065 and
CCR-0238492.
Proceedings of the 20th Annual Computer Security Applications Conference (ACSAC’04) 
1063-9527/04 $ 20.00 IEEE