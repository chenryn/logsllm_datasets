belonging to a particular user. If the server has checked
UID 21690 with Alice’s token and 21691 with Bob’s token,
the substitution atack would not have succeeded.
1Note that we do not report the concrete name of this app, since the vulnerability
identiied in the server of W has not been patched yet as the time of this writing.
Session D2:  Vulnerable Mobile AppsCCS’17, October 30-November 3, 2017, Dallas, TX, USA801GET /api/v1//users/21690/notifications?in_app_token=e67315b35aa3
8d4ac8cac3cd9c7f88ae7f576d373f HTTP/1.1
Host: api.*****.com
Connection: close
HTTP/1.1 200 OK
Cache-Control: max-age=0, private, must-revalidate
Content-Type: application/json
ETag: W/"5319d96924bb6d0a761b5f13b248919c"
Server: nginx/1.6.2
X-Request-Id: 5775d45e-cc3b-4665-8bc6-c2c7a2c9180d
X-Runtime: 0.027840
Content-Length: 191
Connection: Close
[{"id":433222,"sender":null,"dog":null,"notification_type":15,"n
otification_text":"Welcome to *****.","object_id":21690,"is_seen
":true,"is_read":true,"created_at":"2017-01-28T23:54:59.831Z"}]
(a) Alice’s first request and response message after login
GET /api/v1//users/21691/notifications?in_app_token=fb153b7d8c0a
0c6ac841d7bfbd9446de627c642858 HTTP/1.1
Host: api.*****.com
Connection: close
HTTP/1.1 200 OK
Cache-Control: max-age=0, private, must-revalidate
Content-Type: application/json
ETag: W/"6ee365b32e7f3e145d5c74778ea243cd"
Server: nginx/1.6.2
X-Request-Id: 4970cafb-9438-4a70-96e0-ca2f789f0d5d
X-Runtime: 0.022889
Content-Length: 192
Connection: Close
[{"id":433227,"sender":null,"dog":null,"notification_type":15,"n
otification_text":"Welcome to *****.","object_id":21691,"is_seen
":true,"is_read":false,"created_at":"2017-01-28T23:56:40.533Z"}]
(b) Bob’s first request and response message after login
Figure 2: Sample Request and Response Messages of
our Running Example. he server name has been
anonymized with *****.
GET /api/v1//users/21691/notifications?in_app_token=e67315b35aa3
8d4ac8cac3cd9c7f88ae7f576d373f HTTP/1.1
Host: api.*****.com
Connection: close
HTTP/1.1 200 OK
Cache-Control: max-age=0, private, must-revalidate
Content-Type: application/json
ETag: W/"6ee365b32e7f3e145d5c74778ea243cd"
Server: nginx/1.6.2
X-Request-Id: 4970cafb-9438-4a70-96e0-ca2f789f0d5d
X-Runtime: 0.022889
Content-Length: 192
Connection: Close
he goal of our AuthScope is exactly designed to identify these
vulnerable servers automatically and in a large scale, by perform-
ing the request message ield inference and substitution systemat-
ically.
3.2 Challenges and Key Insights
From the above running example, we can notice that there will
be a number of challenges in order to achieve our goal and these
include:
- How to obtain the post-authentication messages. Since
we focus on the identiication of the vulnerable authoriza-
tion implementations (which occur ater the user authen-
tication), we must execute the app to reach the state that
generates the post-authentication request messages.
In
other words, we must have a registered legitimate user of
the testing service and obtain a legal post-authentication
message. While we can use manual eforts to register a
legal user in each of the to-be-tested service, this cannot
scale to a large volume of apps. his also contradicts our
goal of fully automation. herefore, we have to design
techniques to drive the app execution to trigger the le-
gitimate post-authentication messages (e.g., the ones illus-
trated in Figure 2).
- How to recognize the protocol ields of interest. With
the traced legitimate request and response messages, we
have to also identify the ields that are of our interest. For
instance, as shown in Figure 2, we have to recognize vari-
ous ields such as in_app_token in which there are ield-
name associated, and those that do not have any ield-
name (e.g., 21690 and 21691 in the URL path though we
suspect it is a UID ield) in the messages. Note that un-
like traditional HTTP request message in which we can
directly recognize the protocol ields by ield names, we
have to systematically recognize all of the protocol ields
including ield-name hidden ones used in URLs such as
those using REST APIs.
- How to identify the vulnerability. Having obtained
the post-authentication messages and recognized the pro-
tocol ields, we still need to systematically substitute the
protocol ields in the request messages to observe how a
server would respond to the substituted request messages.
How to decide whether a server is vulnerable based on the
response message is another challenge.
[{"id":433227,"sender":null,"dog":null,"notification_type":15,"n
otification_text":"Welcome to *****.","object_id":21691,"is_seen
":true,"is_read":false,"created_at":"2017-01-28T23:56:40.533Z"}]
Fortunately, all of the challenges listed above can be solved or
partially solved with the following key insights.
Figure 3: Alice Read Bob’s Private Message.
- No randomness of the UID. If the server does not at-
tempt to enforce the consistency check between the UID
and the corresponding user token, it can make the UID suf-
iciently random and atacker cannot make a predictable
guess, thereby defeating the substitution atack.
- Executing the app with single-sign-on. It is tedious to
manually register a user account one by one for each of
the tested mobile app. Interestingly, we notice that many
of the mobile apps today support social login such as using
Facebook login. With this, we can automatically log in an
app to exercise the post-authentication messages if we are
able to drive the app to execute the Facebook login. he
limitation for this approach is for those that do not use
social login we will not be able to test them automatically.
- Recognizing protocol ields of interest with diferen-
tial traic analysis. With just one request and response
Session D2:  Vulnerable Mobile AppsCCS’17, October 30-November 3, 2017, Dallas, TX, USA802Post-Authentication
Message Generation
1
2
3
Alice’s Request1
Alice’s Request2
Bob’s Request
7
Field-Substituted Alice’s Request Messages (for Bob)
Field Recognition 
and Substitution
Response Message 
Labeling
1
2
3
4
5
6
Alice’s Request1
Alice’s Request2
Bob’s Request
Alice’s Response1
Alice’s Response2
Bob’s Response
Smartphone
Man-in-the-Middle Proxy
Cloud
8
Server Response Messages for the Field-Substituted Request
Figure 4: An Overview of AuthScope.
message pair, it will be challenging to recognize the pro-
tocol ields of our interest. However, if we have two le-
gitimate users and have two such message pairs, we can
easily identify the ields of our interest by aligning the two
corresponding messages and looking for the diferences,
as what we have done in our prior work AutoForge [47].
For instance, if we align the two request messages gener-
ated by Alice and Bob, we can easily recognize the UID
ield and the in_app_token ield as shown in Figure 2.
- Substituting the ields having small Euclidean dis-
tance. We do not have to substitute the cryptographi-
cally generated token ields since it will be so random and
impossible to guess (e.g., the the in_app_token ield in
our running example), and instead we should substitute
the ield whose corresponding difed value has a short dis-
tance (e.g., the UID ield with value 21690 and 21691, which
has just one Euclidean distance, if we convent these two
numbers to integers). his also means we have to convert
all the numbers and strings to computable forms such that
the Euclidean distance can be measured between the two
difed values. Note that there might be some other dis-
tances but euclidean distance can serve our purpose in our
problem seting.
- Labeling server response also with diferential traf-
ic analysis. Ater we substituting the ields of our in-
terest (e.g., the UID ield) as shown in Figure 3, we have
to decide whether the substitution indeed proves the ex-
istence of the vulnerable authorization in the server side.
Fortunately, we notice that when substituting the Alice’s
UID with Bob’s, if the server responses with Bob’s private
message we observed before, then it is indeed vulnera-
ble. More speciically, as demonstrated in our running
example, the response message in Figure 3 is identical to
the response message in Figure 2(b), which truly conirms
that the server side of W app is vulnerable. However, the
response may contain some message speciic information
such as the time stamp. Fortunately, diferential traic
analysis can also identify these ields and ilter them out,
as demonstrated in AutoForge [47].
3.3 System Overview
An overview of AuthScope is presented in Figure 4. here are
three key components: (1) Post-Authentication Message Gen-
eration that drives the app execution and triggers the legitimate
user’s post authentication request messages, (2) Protocol Field
Recognition and Substitution that recognizes the protocol ields
of the request messages and mutates the ield of our interest, and
(3) Response Message Labeling that labels the response mes-
sages and decides whether the server is vulnerable to access con-
trol violation atacks. All of these components run in the client
side (without accessing any server code) either in a mobile device,
or in a man-in-the-middle network proxy.
Scope and Assumptions. We focus on analyzing the mobile apps
that use HTTP/HTTPS protocols, although AuthScope can be ex-
tended to analyze non-text protocols. Also, we focus on the apps
that use the Facebook login; otherwise we will not be able to auto-
matically trigger the post-authentication messages. Regarding the
type of the access control vulnerabilities, we focus on the vulner-
able authorization implementations that are caused by (i) no secu-
rity token, (ii) no randomness of when referring resources at server
side when no token, (iii) no access control enforcement when using
token. Other vulnerabilities of the server access control such as (1)
a user security token is never changed in the life span of the user,
(2) how random a token is, (3) the token is transmited in plaintext,
or (4) no/weak authentication, are out-of-scope of this work.
With respect to the HTTPS traic, since we control the smart-
phone and also the man-in-the-middle proxy, we install a root
certiicate in the phone signed by ourselves, and then we can ob-
serve the traic in the proxy in plaintext. Such a method has
been widely used in many systems to observe the HTTPS traic
between mobile apps and servers (e.g., [5, 46, 47]).
4 DETAILED DESIGN
In this section, we present the detailed design of the three key
components of AuthScope. Based on their execution order, we
irst describe how to trigger the post-authentication message of
a mobile app in §4.1, then explain how to perform the protocol
reverse engineering to recognize and substitute the protocol ields
of interest in §4.2, and inally present how we label the response
Session D2:  Vulnerable Mobile AppsCCS’17, October 30-November 3, 2017, Dallas, TX, USA803message and detect the vulnerable access control of the remote
services in §4.3.
4.1 Post-Authentication Message Generation
Unlike many other mobile app dynamic analyses which only need
to randomly trigger some app activities, we need an analysis that
can allow the app to enter an important state (i.e., the post au-
thentication state). At a high level, this would mean that we need
to irst register a legal user in the remote service when given a
mobile app, and then execute the app with the registered user and
meanwhile successfully log in the server. However, the user regis-
tration (i.e., sign up) interface of a mobile app can actually be quite
sophisticated. We cannot run a dynamic random testing tool such
as Monkey [7] to perform the user sign up because of the various
constraints in the interface such as some input may need to follow
certain format (e.g., username, passwords, emails, zip code, phone
numbers), some input (e.g., passwords, PINs, and emails) may need
to enter twice for consistency checks, and some input must satisfy
some constraints (e.g., age needs to be greater than 18).
It might appear we need to use symbolic execution to collect the
constraints and solve them to inish the server sign up process from
a mobile app. However, many of the constraints checking code
may just exist in the server side, and symbolic execution of mobile
app may not be able to collect these constraints. Meanwhile, many
of the registration processes may also need users to click certain
links sent via the emails. In addition, there might be CAPTCHAs in
the user sign up interface. hese all make user registration process
non-trivial for a large scale study.
Fortunately, we also notice that many mobile apps today use
social login, in which a user just needs to log in the service with her
social account and the server will automatically pull the data from
the corresponding authentication service providers (e.g., Facebook).
With this, we can avoid running the sign up process and instead di-
rectly run the app to trigger the social login interface. Also, it will
be very rare to have sophisticated constraints in order to trigger
the Facebook login, and most of the time the social login interface
can be triggered with the irst few activities if the app does contain
such an interface. We also do not need symbolic execution for our
later stage post-authentication analysis, as long as we can have
one sample request and response message pair (this is based on
the observation that if the server is vulnerable to the authorization,
it is very likely that this vulnerability will exist in many of its
request messages). Meanwhile, most mobile apps are designed to
pull data from servers. An in-depth activity explore shall be able
to trigger at least one such message pair. herefore, we decide
to design a targeted app activity explorer (§4.1.1), which will solve
both automatic service login via social-based single sign on (§4.1.2),
but also the generation of post-authentication messages for our
later stage analysis.
4.1.1 Targeted App Activity Explorer
Again, while we could have just run random dynamic testing tool
such as Monkey to explore the app activities, such an approach
would be very ineicient (cannot meet our large scale study goal)
and cannot provide any guarantees of triggering the code we in-
tended.
Inspired by prior works such as AppsPlayground [34],
SVM-Hunter [35], and Gui Ripping [27, 31] in which UI elements
are recognized and used to drive the app execution, we also design
an approach that parses the UI elements in a given activity and
then leverages a depth-irst-search (DFS) algorithm to explore the
next-layer app activities and trigger the activities of our interest
(such as Facebook Login).
In Android, an activity represents a single screen (can be a win-
dow or a loating window embedded in another activity) interface
that interacts with users. Every activity deined for the app must
be declared in the manifest ile. Within each activity, every UI
element such as a Buton, an ImageButon, a CheckBox, an EditBox,
etc., represents a view. All the views are deined in the layout ile
of an activity or deined by programmers in code. Each view can be
binded to a speciic action. When a user interacts with an activity
(e.g., click a Buton), the action binded to the corresponding speciic
view will be invoked, which might lead to jump to another activity.
Since we would like to explore as many activities (as well as the
views inside an activity) as we can, we have to uniquely identify each
activity and each view such that we do not have to explore the activ-
ity and the view again (e.g., click a Buton again) if we have explored
it before (otherwise our DFS activity exploration may encounter
dead loops). To uniquely identify an activity is trivial, we use the
name of each activity as the signature, due to the uniqueness of the
activity name. However, there is no such a single obvious atribute
to uniquely identify a view. Note that intuitively, the memory ad-
dress of each view object should be unique, but the memory address
of a view can be changed when an activity is refreshed.
View Identiication. In Android, all activities for a task are main-
tained using a stack, and they are arranged in the order according
to the time when each activity is opened. For example, the current
activity is at the top of the stack; when jumping to another activity,
the state of current activity is saved in the top of the stack and then
opens the new activity. When the new activity inishes (e.g., the
user clicks a back Buton), the older activity stored in the top of the
stack will be popped up. Such an activity exploration mechanism
can make each single view appear on the screen multiple times. But
for our analysis, exploring each view only once is enough.
To avoid exploration redundancy and ensure eiciency, we need
to uniquely identify each view. In AuthScope, we use a vector with
six atributes  to uniquely identify a view, more
speciically:
(1) N : the N ame of the activity, to which the view belongs.