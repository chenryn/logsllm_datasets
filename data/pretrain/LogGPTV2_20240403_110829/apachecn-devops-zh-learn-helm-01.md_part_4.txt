这是一个强大的过程，因为包管理器允许用户在报告严重错误或漏洞时快速回滚。
如果您想完全删除一个应用，包管理器也可以处理这个问题。`dnf`为此提供了`remove`子命令:
```
dnf remove htop --assumeyes	
```
在本节中，我们回顾了如何使用 Fedora 上的`dnf`包管理器来管理软件包。Helm，作为 Kubernetes 包管理器，在目的和功能上都与`dnf`相似。`dnf`用于管理 Fedora 上的应用，而 Helm 用于管理 Kubernetes 上的应用。接下来我们将更详细地探讨这一点。
## Kubernetes 包管理器
鉴于 Helm 旨在提供类似于包管理器的体验，有经验的`dnf`或类似工具的用户将立即理解 Helm 的基本概念。事情变得更加复杂，不过，在谈及具体实施细节的时候。`dnf`对提供可执行文件、依赖信息和元数据的`RPM`包进行操作。另一方面，Helm 使用**图表**。一张 Helm 图表可以被认为是一个 Kubernetes 包。图表包含部署应用所需的声明性 Kubernetes 资源文件。类似于`RPM`，它还可以声明应用运行所需的一个或多个依赖关系。
Helm 依靠存储库来提供对图表的广泛访问。图表开发人员创建声明性 YAML 文件，将它们打包成图表，并将其发布到图表存储库中。终端用户然后使用 Helm 搜索现有图表以部署到 Kubernetes 上，类似于`dnf`的终端用户将如何搜索`RPM`包以部署到 Fedora。
让我们来看一个基本的例子。通过使用发布到上游存储库的图表，Helm 可以用来将内存缓存`Redis`部署到 Kubernetes。这可以使用 Helm 的`install`命令来执行:
```
helm install redis bitnami/redis --namespace=redis
```
这将把来自 bitnami 图表库的`redis`图表安装到名为`redis`的 Kubernetes 命名空间中。这一安装将被称为最初的**修订版**，或一个 Helm 图表的最初部署。
如果新版本的`redis`图表可用，用户可以使用`upgrade`命令升级到新版本:
```
helm upgrade redis bitnami/redis --namespace=redis
```
这将升级`Redis`以满足更新的`redis`ha 图表定义的规格。
对于操作系统，如果发现错误或漏洞，用户应该关心回滚。Kubernetes 上的应用也存在同样的问题，Helm 提供了回滚命令来处理这个用例:
```
helm rollback redis 1 --namespace=redis
```
该命令将把`Redis`回滚到它的第一个版本。
最后，Helm 提供了通过`uninstall` 命令完全移除`Redis`的能力:
```
helm uninstall redis --namespace=redis
```
比较`dnf`，Helm 的子命令，以及它们在下表中提供的功能。请注意`dnf`和【Helm】提供了类似的命令，提供了类似的用户体验:
![](img/01.jpg)
了解了 Helm 作为包管理器的功能后，让我们更详细地讨论 Helm 给 Kubernetes 带来的好处。掌舵的好处
在本章的前面，我们回顾了如何通过管理 Kubernetes 资源来创建 Kubernetes 应用，并讨论了其中涉及的一些挑战。以下是 Helm 克服这些挑战的几种方法。
### Kubernetes 资源的抽象复杂性
让我们假设一个开发人员被赋予了在 Kubernetes 上部署 MySQL 数据库的任务。开发人员需要创建配置其容器、网络和存储所需的资源。从头开始配置这样一个应用所需的 Kubernetes 知识量很高，对于新的甚至中级的 Kubernetes 用户来说是一个很大的障碍。
有了 Helm，一个负责部署 MySQL 数据库的开发人员可以简单地在上游图表库中搜索 MySQL 图表。这些图表已经由社区中的图表开发人员编写，并且已经包含部署 MySQL 数据库所需的声明性配置。在这方面，具有这种任务的开发人员将作为简单的最终用户，以类似于任何其他包管理器的方式使用 Helm。
### 正在进行的修订历史
Helm 有一个概念叫做发布历史。当首次安装 Helm 图表时，Helm 会将该初始版本添加到历史记录中。随着版本通过升级而增加，历史会进一步修改，保留不同版本下应用如何配置的各种快照。
下图描述了正在进行的修订历史。蓝色的方块表示从以前版本修改过的资源:
![Figure 1.6: An example of a revision history ](img/Figure_1.6.jpg)
图 1.6 -修订历史示例
跟踪每个修订的过程为回滚提供了机会。Helm 中的回滚非常简单。用户只需将 Helm 指向以前的版本，Helm 就会将实时状态恢复为所选版本的状态。有了 Helm，后援的日子一去不复返了。Helm 允许用户将他们的应用回滚到他们想要的最远的地方，甚至可以回滚到第一次安装的时候。
### 动态配置的声明性资源
声明式创建资源的最大麻烦之一是 Kubernetes 资源是静态的，不能参数化。您可能记得，这导致资源跨应用和类似配置成为样板，使得团队更难将其应用配置为代码。Helm 通过引入**值**和**模板**来缓解这些问题。
数值就是 Helm 所说的图表参数。模板是基于给定的一组值动态生成的文件。这两种结构为图表开发人员提供了编写 Kubernetes 资源的能力，这些资源是根据最终用户提供的值自动生成的。通过这样做，由 Helm 管理的应用变得更加灵活，更少重复，并且更容易维护。
值和模板允许用户进行如下操作:
*   参数化公共字段，例如部署中的映像名称和服务中的端口
*   基于用户输入生成 YAML 配置的长片段，例如部署中的卷装载或配置映射中的数据
*   基于用户输入包括或排除资源
动态生成声明性资源文件的能力使得创建基于 YAML 的资源变得更加简单，同时仍然确保应用是在一个易于复制的 fa 中创建的。
### 本地和活动状态之间的一致性
包管理器防止用户必须手动管理应用及其依赖关系。所有管理都可以通过包管理器本身来完成。Helm 也有同样的想法。因为一个 Helm 图表包含了 Kubernetes 资源的灵活配置，所以用户不应该直接对实时的 Kubernetes 资源进行修改。希望修改其应用的用户可以通过向 Helm 图表提供新值或将其应用升级到相关图表的更新版本来实现。这允许本地状态(由 Helm 图表配置表示)和活动状态在修改过程中保持一致，使用户能够为他们的 Kubernetes 资源配置提供真实来源。
### 智能部署
Helm 通过确定需要创建 Kubernetes 资源的顺序来简化应用部署。Helm 分析图表的每个资源，并根据它们的类型对它们进行排序。存在这种预先确定的顺序是为了确保首先创建通常具有依赖于它们的资源的资源。例如，机密和配置映射应该在部署之前创建，因为部署可能会以卷的形式消耗这些资源。Helm 在没有用户任何交互的情况下执行这种排序，因此这种复杂性是抽象的，并且防止用户需要担心这些资源的应用顺序。
### 自动化生命周期挂钩
与其他包管理器类似，Helm 提供了定义生命周期挂钩的能力。生命周期挂钩是在应用生命周期的不同阶段自动发生的动作。它们可以用来做以下事情:
*   在升级时执行数据备份。
*   回滚时恢复数据。
*   在安装前验证 Kubernetes 环境。
生命周期挂钩是有价值的，因为它们抽象了任务的复杂性，而这些任务可能不是 Kubernetes 特有的。例如，Kubernetes 用户可能不熟悉备份数据库背后的最佳实践，或者可能不知道何时应该执行这样的任务。生命周期挂钩允许专家编写自动化程序，在推荐时执行这些最佳实践，这样用户就可以继续高效工作，而无需担心那些细节。
# 总结
在这一章中，我们从探索采用基于微服务的体系结构的体系结构趋势的变化开始，将应用分解成几个较小的应用，而不是部署一个大的整体。更轻量级和更容易管理的应用的创建已经导致使用容器作为打包和运行时格式来更频繁地产生版本。通过采用容器，引入了额外的操作挑战，并通过使用 Kubernetes 作为容器编排平台来管理容器生命周期来解决这些挑战。
我们的讨论转向了可以配置 Kubernetes 应用的各种方式，包括部署、服务和持久卷声明。这些资源可以用两种不同风格的应用配置来表达:命令式和声明式。这些配置风格中的每一种都会带来一系列部署 Kubernetes 应用的挑战，包括理解 Kubernetes 资源如何工作所需的知识量以及管理应用生命周期的挑战。
为了更好地管理组成应用的每个资产，引入了 Helm 作为 Kubernetes 的包管理器。通过其丰富的功能集，可以轻松管理应用从安装、升级、回滚和删除的整个生命周期。
在下一章中，我们将介绍配置 Helm 环境的过程。我们还将安装使用 Helm 生态系统所需的工具，并遵循本书中提供的示例。
# 进一步阅读
有关构成应用的 Kubernetes 资源的更多信息，请参见 https://Kubernetes . io/docs/concepts/overview/使用对象/kubernetees-Objects/，上的*了解 Kubernetes 对象*页面。
要强调本章中讨论的 Helm 的一些优势，请参考 https://helm.sh/docs/intro/的 Helm 文档[中的*使用 Helm* 页面。(本页还深入探讨了 Helm 的一些基本用法，这将在本书中详细讨论。)](https://helm.sh/docs/intro/using_helm/)
# 问题
1.  单片应用和微服务应用有什么区别？
2.  什么是 Kubernetes？它旨在解决什么问题？
3.  将应用部署到 Kubernetes 时，常用的`kubectl`命令有哪些？
4.  在向 Kubernetes 部署应用时，经常会遇到哪些挑战？
5.  Helm 作为 Kubernetes 的包管理器是如何工作的？它如何应对 Kubernetes 带来的挑战？
6.  假设您想要回滚部署在 Kubernetes 上的应用。哪个 Helm 命令允许您执行此操作？Helm 如何跟踪您的更改以使回滚成为可能？
7.  允许 Helm 作为包管理器运行的四个主要 Helm 命令是什么？