0x30000000$
APPLICATION 
BASE 
SYSTEM 
0x27C00000$
0x2E000000$
0x001B9000$
0x001E0000$
0x001E0000$
.rodata 
.data 
.text 
Virtual Addressing 
Physical Addressing 
FCRAM 
Nintendo’s mitigation: PASLR 
mcopy 
0x00100000$
0x20000000$
0x30000000$
APPLICATION 
BASE 
SYSTEM 
0x27C00000$
0x2E000000$
0x001B9000$
0x001E0000$
0x001E0000$
.rodata 
.data 
.text 
Virtual Addressing 
Physical Addressing 
Bypassing PASLR in ROP 
rop:$
$$gspwn$MCOPY_RANDCODEBIN_COPY_BASE,$MCOPY_RANDCODEBIN_BASE,$MCOPY_CODEBIN_SIZE$
$
$$str_val$MCOPY_SCANLOOP_CURPTR,$MCOPY_RANDCODEBIN_COPY_BASE$-$MCOPY_SCANLOOP_STRIDE$
$
$$scan_loop:$
$$$$ldr_add_r0$MCOPY_SCANLOOP_CURPTR,$MCOPY_SCANLOOP_STRIDE$
$$$$str_r0$MCOPY_SCANLOOP_CURPTR$
$
$$$$cmp_derefptr_r0addr$MCOPY_SCANLOOP_MAGICVAL,$scan_loop,$scan_loop_pivot_after$
$
$$$$str_r0$scan_loop_pivot$+$4$
$$$
$$$$scan_loop_pivot:$
$$$$jump_sp$0xDEADBABE$
$$$$scan_loop_pivot_after:$
$
$$memcpy$MCOPY_RANDCODEBIN_COPY_BASE,$initial_code,$initial_code_end$-$initial_code$
$
$$flush_dcache$MCOPY_RANDCODEBIN_COPY_BASE,$0x00100000$
$
$$gspwn_dstderefadd$(MCOPY_RANDCODEBIN_BASE)$-$(MCOPY_RANDCODEBIN_COPY_BASE),$$$$$$$$$
$$$$$$$$$$$$$$$$$$$$$MCOPY_SCANLOOP_CURPTR,$MCOPY_RANDCODEBIN_COPY_BASE,$0x800,$0$
$
$$.word$MCOPY_SCANLOOP_TARGETCODE$
$
.align$0x4$
$$initial_code:$
$$$$.incbin$"../build/mhax_code.bin"$
$$initial_code_end:$
DMA(PASLRed(code(data(
to(CPU-readable(location(
for(u32*$ptr$=$MCOPY_RAND_COPY_BASE;$
$$$$*ptr$!=$magic_value;$
$$$$ptr$+=$MCOPY_SCANLOOP_STRIDE/4);$
DMA(code(to(known(VA(
and(jump(to(it((
Insert(short(video(showing(hbmenu(booting(from(mhax(
ARM11 Kernel 
Home Menu 
loader 
fs 
GSP 
HID 
System calls 
APPLICATION memory region 
SYSTEM memory region 
BASE memory region 
mcopy 
User-mode application compromised! 
Escalating privilege 
We’re in! …now what? 
Where do we stand? 
•  mcopy(is(just(an(app(
•  It(only(has(access(to(basic(system(calls(
•  It(only(has(access(to(a(few(services(
•  Paths(to(exploitation(
•  Directly(attack(the(ARM9:(difficult(without(access(to(more(services(
•  Attack(the(ARM11(kernel:(definitely(possible(but(easier(with(more(system(
calls(
•  Attack(other(user-mode(processes(
Memory 
CPUs 
Devices 
ARM9(
ARM11(
GPU(
CRYPTO(
NAND(
GPU DMA: range reduction mitigation 
SYSTEM( BASE(
FCRAM(
K/P9(
Kernel11(
WRAM(
VRAM(
ARM9(
internal(
MCOPY(
Memory 
CPUs 
Devices 
ARM9(
ARM11(
GPU(
CRYPTO(
NAND(
GPU DMA range reduction: I lied 
FCRAM(
K/P9(
Kernel11(
WRAM(
VRAM(
ARM9(
internal(
MCOPY(
SYSTEM( BASE(
mcopy heaps 
Home 
menu 
code 
Home menu 
heaps 
mcopy code 
FCRAM 
FCRAM and GPU DMA 
0x20000000$
0x30000000$
APPLICATION 
BASE 
SYSTEM 
0x27C00000$
0x2E000000$
Physical Addressing 
GPU(DMA(accessible(
Not(GPU(DMA(accessible(
Taking over home menu 
•  GPU(DMA(allows(us(to(read/write(home(menu’s(heap(
=>(Find(an(interesting(object,(corrupt(it(and(jump(back(to(home(menu(
(
•  Can’t(use(GPU(DMA(to(get(code(execution(under(home(menu(
=>(Write(a(service(in(ROP(that(runs(under(home(menu(to(give(apps(
access(to(its(privileges(
Side note: GPU DMA range mitigation 
•  Nintendo’s(idea(
•  Different(processes(need(different(GPU(DMA(range(
•  For(example,(apps(never(need(to(DMA(to/from(home(menu(
•  So(why(not(restrict(app/game’s(DMA(more(than(home(menu’s?(
•  Implemented(in(11.3.0-36,(released(on(February(6th(2017(
•  Bypassed(on(New(3DS(on(February(10th(
•  The(problem:(the(DMA(restriction(doesn’t(cover(home(menu’s((whole(heap(
ARM11 Kernel 
Home Menu 
loader 
fs 
GSP 
HID 
System calls 
APPLICATION memory region 
SYSTEM memory region 
BASE memory region 
mcopy 
Home menu compromised, giving access to more services 
Home menu’s privileges 
•  Access(to(the(ns:s(service(
•  NS:(Nintendo(Shell(
•  Allows(us(to(kill(and(spawn(processes(at(will(
⇒ (We(can(access(any(service(accessible(from(an(app(
•  Use(ns:s(to(spawn(the(app(
•  Use(GPU(DMA(to(overwrite(its(code(and(take(it(over(
•  Access(the(service(from(that(app(
(
-(
ldr:ro 
•  Service(provided(by(the(“ro”(process(
•  Handles(loading(dynamic(libraries:(CROs(
•  Basically(like(DLLs(for(the(3DS(
•  Is(the(only(process(to(have(access(to(certain(system(calls(
•  Most(interesting(one:(svcControlProcessMemory(
•  Lets(you(allocate/reprotect(memory(as(RWX(
•  Useful(for(homebrew(among(other(things…(
(
-(
CRO buffer 
CRO buffer 
FCRAM 
ldr:ro: first, application loads CRO into an RW buffer 
app 
0x20000000$
0x30000000$
APPLICATION 
BASE 
SYSTEM 
0x27C00000$
0x2E000000$
Virtual Addressing 
Physical Addressing 
ro 
Loaded(CRO(
CRO buffer 
CRO buffer 
Loaded CRO 
FCRAM 
ldr:ro: second, CRO is locked for the app and mapped to its load address 
app 
0x20000000$
0x30000000$
APPLICATION 
BASE 
SYSTEM 
0x27C00000$
0x2E000000$
Virtual Addressing 
Physical Addressing 
ro 
Loaded(CRO(
Loaded CRO 
CRO buffer 
CRO buffer 
FCRAM 
ldr:ro: third, ro creates a local view of the CRO in its own memory space 
app 
0x20000000$
0x30000000$
APPLICATION 
BASE 
SYSTEM 
0x27C00000$
0x2E000000$
Virtual Addressing 
Physical Addressing 
ro 
Loaded(CRO(
Loaded CRO 
CRO buffer 
CRO buffer 
FCRAM 
ldr:ro: fourth, ro performs processing on CRO (relocations, linking etc) 
app 
0x20000000$
0x30000000$
APPLICATION 
BASE 
SYSTEM 
0x27C00000$
0x2E000000$
Virtual Addressing 
Physical Addressing 
ro 
CRO buffer 
CRO buffer 
FCRAM 
ldr:ro: finally, ro unmaps the CRO and reprotects the app’s loaded view 
app 
0x20000000$
0x30000000$
APPLICATION 
BASE 
SYSTEM 
0x27C00000$
0x2E000000$
Virtual Addressing 
Physical Addressing 
ro 
Loaded CRO 
CRO buffer 
Loaded(CRO(
Loaded CRO 
CRO buffer 
FCRAM 
Key insight: app can’t modify CRO from CPU, but can with GPU 
app 
0x20000000$
0x30000000$
APPLICATION 
BASE 
SYSTEM 
0x27C00000$
0x2E000000$
Virtual Addressing 
Physical Addressing 
ro 
GPU(DMA(accessible(
Not(GPU(DMA(accessible(
CRO tampering with GPU 
•  Nintendo’s(CRO(loader(is(written(with(this(in(mind(
•  Lots(of(checks(to(prevent(malformed(CROs(from(compromising(ro(process(
•  However,(Nintendo(didn’t(account(for(modifying(CRO(*during*(
processing(
•  Lots(of(possible(race(condition(bugs!(
•  Using(GPU(DMA(for(time-critical(memory(modification(is(tricky,(
especially(with(cache(in(the(middle(
•  Kernel(prevents(us(from(double-mapping(the(CRO(memory…(
•  …in(theory(
(
-(
Heap segment 1 
Heap segment 1 
Heap segment 2 
Heap segment 2 
FCRAM 
Kernel keeps physical heap metadata in free physical memory blocks 
app 
0x20000000$
0x27C00000$
APPLICATION 
Virtual Addressing 
Physical Addressing 
Free block 
Free block 
Free 
block 
Heap segment 1 
Heap segment 1 
Heap segment 2 
Heap segment 2 
FCRAM 
app 
0x20000000$
0x27C00000$
APPLICATION 
Virtual Addressing 
Physical Addressing 
Free block 
Free block 
Free 
block 
The metadata is essentially just a linked list 
Heap segment 3 
Heap segment 1 
Heap segment 1 
Heap segment 2 
Heap segment 2 
FCRAM 
app 
0x20000000$
0x27C00000$
APPLICATION 
Virtual Addressing 
Physical Addressing 
Free block 
Free block 
Free 
block 
When allocating a new heap segment, the kernel just walks the list 
?"
Heap segment 1 Heap segment 3 
Heap segment 1 
Heap segment 3 
Heap segment 2 
Heap segment 2 
FCRAM 
app 
0x20000000$
0x27C00000$
APPLICATION 
Virtual Addressing 
Physical Addressing 
Free block 
Free block 
Free 
block 
GPU(DMA(accessible(
Again: app can’t modify heap metadata from CPU, but can with GPU 
Heap metadata authentication 
•  Nintendo(knows(kernel-trusted(DMA-able(heap(metadata(is(bad(
•  Introduced(a(MAC(into(the(metadata(with(a(key(only(known(to(kernel(
•  Prevents(forgery(of(arbitrary(heap(metadata(blocks…(
•  …(but(not(replay(attacks(
(
-(
Heap segment 2 
Heap segment 1 
Heap segment 1 
Heap segment 2 
FCRAM 
app 
0x20000000$
0x27C00000$
APPLICATION 
Virtual Addressing 
Physical Addressing 
Free block 
A 
Free block 
Free block B 
 Creating a double mapping: initial layout 
Heap segment 2 
Heap segment 1 
Heap segment 1 
Heap segment 2 
FCRAM 
app 
0x20000000$
0x27C00000$
APPLICATION 
Virtual Addressing 
Physical Addressing 
Free block 
A 
Free block 
Free block B 
 Creating a double mapping: save free block A and B’s data through DMA 
Heap segment 1 
Primary mapping 
Heap segment 2 
Heap segment 1 
Heap segment 3 
Heap segment 2 
FCRAM 
app 
0x20000000$
0x27C00000$
APPLICATION 
Virtual Addressing 
Physical Addressing 
Free block 
A’ 
Free block 
 Creating a double mapping: allocate segment to fit in B but not A 
Heap segment 1 
Primary mapping 
Heap segment 2 
Heap segment 1 
Heap segment 3 
Heap segment 2 
FCRAM 
app 
0x20000000$
0x27C00000$
APPLICATION 
Virtual Addressing 
Physical Addressing 
Free block 
A 
Free block 
 Creating a double mapping: use DMA to replace A’ with A 
Heap segment 1 
Primary mapping 
Heap segment 2 
Heap segment 1 
Heap segment 3 
Free block B 
Heap segment 2 
FCRAM 
app 
0x20000000$
0x27C00000$