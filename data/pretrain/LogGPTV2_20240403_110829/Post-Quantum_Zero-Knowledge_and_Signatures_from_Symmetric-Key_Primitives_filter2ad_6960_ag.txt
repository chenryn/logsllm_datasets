j
, D
(x
(i)
1 , k
(i)
1 , x
(i)
2 , x
View
. In particular, for each player Pj:
(i)
3 ) ← Share(x, k
(i)
j ← Update(Update(· · · Update(x
(i)
j ← Output(View
, View
(i)
j )
(i)
j ) and let a(i) = (y
(i)
j ] ← Com(k
(i)
2 , k
(i)
1 , y
(i)
2 , y
(i)
3 ),
(i)
j
y
(i)
j
, x
(i)
j+1, k
(i)
j
, k
(i)
j+1) . . .) . . .) . . .),
(i)
3 , C
(i)
1 , C
(i)
2 , C
(i)
3 ).
2. Compute the challenge: e ← H(a(1), . . . , a(t)). Interpret the challenge such that for i ∈ [1, t], e(i) ∈ {1, 2, 3}
(i)
(i)
3. For each iteration ri , i ∈ [1, t], let z(i) = (D
e +1).
e , D
4. Output p = [(a(1), z(1)),(a(2), z(2)),· · · ,(a(t), z(t))]
b ← Verify(y, p):
For public ϕ and y ∈ Lϕ, the prover has x, such that y = ϕ(x). Com(·) is a secure commitment scheme. The prover and verifier use the hash
function H(·), which is modeled as random oracle. The integer t is the number of parallel iterations.
p ← Prove(x):
1. For each iteration ri, i ∈ [1, t]: Sample random tapes k
(i)
1 , k
(i)
2 , k
(i)
3 and run the decomposition to get an output view View
(i)
j and
1. Compute the challenge: e′ ← H(a(1),· · · , a(t)). Interpret the challenge such that for i ∈ [1, t], e′(i) ∈ {1, 2, 3}.
2. For each iteration ri, i ∈ [1, t]: If there exists j ∈ {e′(i), e′(i) + 1} such that Open(C
, D
(i)
j ) = ⊥, output Reject. Otherwise, for all
(i)
j
3. If Reconstruct(y
(i)
j ∈ {e′(i), e′(i) + 1}, set {k
, View
j
(i)
(i)
(i)
3 ) (cid:44) y, output Reject. If there exists j ∈ {e′(i), e′(i) + 1} such that y
2 , y
j
(e)
(j−1)
∈ Viewe, if w
e +1 , ke , ke +1) output Reject.
j
(i)
j ).
(j−1)
(cid:44) Update(view
e
(i)
1 , y
For each wire value w
(i)
j } ← Open(C
, view
(e)
j
(i)
j
, D
4. Output Accept.
(i)
(cid:44) Output(View
j ), output Reject.
Scheme 3: The ZKBoo non-interactive proof system
EXP
(ϕ,x)
decomp:
(0)
(1) First run the Share function on x: view
1 , view
(2) For each of
the three views, call
(j−1)
Update(view
, view
i
(3) From the final views, compute the output share of each view: yi ← Output(Viewi)
Scheme 4: Decomposition Experiment
(j−1)
i +1 , ki , ki +1) for i ∈ [1, 3], j ∈ [1, n]
(0)
3 ← Share(x, k1, k2, k3)
(0)
2 , view
(j)
the update function successively for every gate in the circuit: view
i
=
KeyAddition(i) adds the round key to the state, where the round
key is generated by multiplying the master key with the key matrix
Ki.
Algorithm 1 gives a full description of the encryption algorithm.
2
for
and round constants
2 for i ∈ [1, r].
2
2 and key y ∈ Fk
2
Algorithm 1 LowMC encryption for key matrices Ki ∈ Fn×k
i ∈ [0, r], linear layer matrices Li ∈ Fn×n
Ci ∈ Fn
Require: plaintext p ∈ Fn
s ← K0 · y + p
for i ∈ [1, r] do
s ← Sbox(s)
s ← Li · s
s ← Ci + s
s ← Ki · y + s
end for
return s
C BUILDING BLOCKS
Commitments. Formally a (non-interactive) commitment scheme
consists of three algorithms KG, Com, Open with the following
properties:
KG(1κ) : The key generation algorithm, on input the secu-
rity parameter κ it outputs a public key pk (we henceforth
assume pk to be an implicit input to the subsequent algo-
rithms).
Com(M) : On input of a message M, the commitment algo-
rithm outputs (C(M), D(M)) ← Com(M; R), where R are
the coin tosses. C(M) is the commitment string, while D(M)
is the decommitment string which is kept secret until open-
ing time.
Open(C, D) : On input C, D, the verification algorithm either
outputs a message M or ⊥.
We note that if the sender refuses to open a commitment we can
set D = ⊥ and Open(pk, C,⊥) = ⊥. Computationally secure com-
mitments must satisfy the following properties
15
Correctness If(C(M), D(M)) = Com(M) then Open(pk, C(M),
D(M)) = M.
Hiding For every message pair M, M′ the probability en-
sembles {C(M)}κ∈N and {C(M′)}κ∈N are computationally
indistinguishable for security parameter κ.
Binding We say that an adversary A wins if it outputs C, D, D′
such that Open(C, D) = M, Open(C, D′) = M′ and M (cid:44)
M′. We require that for all efficient algorithms A, the prob-
ability that A wins is negligible in the security parameter.
To simplify our notation, we will often not explicitly generate the
public key pk when we make use of commitments.
Our implementation uses hash-based commitments, which re-
quires modeling the hash function as a random oracle in our security
analysis. Note also that randomizing the Com function may not be
necessary if M has high entropy.
One-Way Functions. We define the notion of families of one-way
functions.
Definition C.1. A family of functions { fk}k ∈Kκ with fk : Dκ →
Rκ is called one-way, if (1) for all κ and for all k ∈ Kκ there exists
a PPT algorithm A1 so that ∀x ∈ Dκ : A1(x) = fk(x), and (2)
(cid:104)
for every PPT algorithm A2 there is a negligible function ϵ(·) such
that it holds that
Pr
Pseudorandom Functions and Generators. We require the no-
tion of pseudorandom functions and generators, which we formally
recall below.
∗ ← A2(1κ , fk(x)) : f (x) = f (x
∗)(cid:105) ≤ ϵ(κ).
k ←R Kκ , x ←R Dκ , x
Definition C.2 (Pseudorandom Function). Let { fk}k ∈Kκ be an ef-
ficiently computable, length-preserving function family with fk :
{0, 1}κ → {0, 1}κ. We say that { fk} is a pseudorandom function
(PRF) family, if for all PPT distinguishers D,
| Pr[Dfk (1κ) = 1] − Pr[DFκ(1κ) = 1]|
is negligible in κ, where k ← {0, 1}κ is chosen uniformly at random
and Fκ is chosen uniformly at random from the set of functions
mapping κ-bit strings to κ-bit strings.
We now define a weaker notion of a pseudorandom function in
which we put an upper bound on the number of queries that the
distinguisher can make to its oracle.
Definition C.3 (q-Pseudorandom Function). Let { fk} and Fκ be as
defined in Definition C.2, and let q be a positive integer constant.
We say that F is a q-pseudorandom function (q-PRF) if for all PPT
distinguishers D that make at most q queries to their oracle,
| Pr[Dfk (1κ) = 1] − Pr[DFκ(1κ) = 1]|
is negligible in κ.
Note that a pseudorandom function is also a q-pseudorandom
function for any constant q. When considering concrete security of
PRFs against quantum attacks, we assume that an n-bit function
provides n/2 bits of security.
Pseudorandom Generators. We require the notion of pseudoran-
dom generators, which we formally recall below.
16
Definition C.4 (Pseudorandom Generator). An (n, ℓ) pseudoran-
dom generator (PRG) is a function P : {0, 1}n → {0, 1}ℓ that ex-
pands an n-bit seed to an ℓ-bit random string. Informally, the PRG
is said to be secure if for randomly chosen seeds, the output is
indistinguishable from the uniform distribution on {0, 1}ℓ.
Concretely, we assume that AES-256 in counter mode provides
128 bits of PRG security, when used to expand 256-bit seeds to
outputs less than 1kB in length.
Signature Schemes. Below we recall a standard definition of sig-
nature schemes.
of PPT algorithms, which are defined as follows:
Definition C.5. A signature scheme Σ is a triple(Gen, Sign, Verify)
Gen(1κ) : This algorithm takes a security parameter κ as in-
put and outputs a secret (signing) key sk and a public
(verification) key pk with associated message space M (we
may omit to make the message space M explicit).
Sign(sk, m) : This algorithm takes a secret key sk and a mes-
sage m ∈ M as input and outputs a signature σ.
Verify(pk, m, σ) : This algorithm takes a public key pk, a mes-
sage m ∈ M and a signature σ as input and outputs a bit
b ∈ {0, 1}.
Besides the usual correctness property, Σ needs to provide some
unforgeability notion. In this paper we are only interested in schemes
that provide existential unforgeability under adaptively chosen mes-
sage attacks (EUF-CMA security), which we define below.
Definition C.6 (EUF-CMA). A signature scheme Σ is EUF-CMA
secure, if for all PPT adversaries A there is a negligible function
ε(·) such that
(cid:104) (sk, pk) ← Gen(1κ), (m∗, σ∗) ← ASign(sk,·)(pk)
Verify(pk, m∗, σ∗) = 1 ∧ m∗ (cid:60) QSign (cid:105) ≤ ε(κ),
Pr
:
where the environment keeps track of the queries to the signing
oracle via QSign.
D SECURITY OF KEY GENERATION
In this section, we argue that using the block cipher in the way we
use it can serve as our hard instance generator to generate keys
for our signature scheme. Below, we recall the definition of hard
instance generators as presented in [84]:
called a hard instance generator for a relation R if
Definition D.1 (Hard Instance Generators). An algorithm G is
(1) there is a negligible function ϵ1(·) so that it holds that
Pr[(y, x) ← G(1κ) : (y, x) ∈ R] ≥ 1 − ϵ1(κ),
(2) and for every PPT algorithm A there is a negligible function
That is, Enc(x, k) denotes the encryption of a single block k ∈
{0, 1}c·κ with respect to key x ∈ {0, 1}c·κ. Upon key generation,
ϵ2(·) so that it holds that
Pr[(y, x) ← G(1κ), x
∗) ∈ R] ≤ ϵ2(κ).
family of block-cipher-based one-way functions { fk} where
To establish a relation between public and secret keys, we use a
∗ ← A(y) : (y, x
fk(x) (cid:66) Enc(x, k).
one first samples a concrete one-way function { fk} with respect to
security parameter κ uniformly at random by sampling a uniformly
random block k ∈ {0, 1}c·κ. This function is then fixed by including
k in the public key of the scheme, which implicitly defines the
relation R. That is
(y, x) ∈ R ⇐⇒ y = fk(x).
Now, we assume that using LowMC in this way yields a suitable
one-way function. As already mentioned by Unruh in [84], a one-
way function directly yields a suitable hard instance generator
(observe the similarity in the definitions). To make our results more
general, we show that any block-cipher where the keysize is equal
to the blocksize, and in particular equal to c · κ (where we set c = 1
in the classical setting, whereas we set c = 2 in the post-quantum
setting to account for the generic speedup imposed by Grover’s
algorithm [52]), when viewed as a family of PRFs, also yields a
suitable one-way function family.
Theorem D.2. Let { fk}k ∈Kκ
with fk : Mκ → Mκ be a family of
is also a family of one-way
pseudorandom functions, then { fk}k ∈Kκ
functions with respect to k for any input x ∈ Mκ .
Proof. The first condition of Definition C.1 clearly holds, as for any κ,
any k ∈ Kκ, and any x ∈ Mκ we can efficiently compute y = fk(x)
by definition C.2. What remains is to prove the second condition. In