-- (prime, exponent) pair
newtype PrimePower = PP (PrimeBin, Pos)
-- List invariant: primes appear in strictly increasing order
-- (no duplicates).
newtype Factored
= F [PrimePower]
To enforce the invariants, we hide the P, PP, and F constructors from clients, and instead only
export operations that verify and maintain the invariants. In particular, we provide functions
that construct valid PrimeBin, PrimePower, and Factored values for any appropriate
positive integer, and we deï¬ne the following arithmetic operations, whose implementations
are straightforward:
fDivides
:: Factored -> Factored -> Bool
fMul, fGCD, fLCM :: Factored -> Factored -> Factored
We use data kinds and singletons to mechanically promote the above data-level deï¬-
nitions to the type level. Speciï¬cally, data kinds deï¬nes an (uninhabited) Factored type
corresponding to each Factored value, while singletons produces type families FDivides,
FMul, etc. that operate on these promoted types. We also provide compile-time â€œmacrosâ€
that deï¬ne Fğ‘š as a synonym for the Factored type corresponding to positive integer ğ‘š,
and similarly for PrimeBin and PrimePower types. Combining all this, e.g., FMul F2 F2
yields the type F4, as does FGCD F12 F8. Similarly, FDivides F5 F30 yields the promoted
type True.
In addition, for each Factored type m, singletons deï¬nes a type Sing m that is inhabited
by a single value, which can be obtained as sing :: Sing m. This value has an internal
structure mirroring that of the corresponding Factored value, i.e., it is essentially a list of
singleton values corresponding to the appropriate PrimePower types. (The same goes for
54
the singletons for PrimePower and PrimeBin types.) Lastly, the withSingI function lets us
go in the reverse direction, i.e., it lets us â€œelevateâ€ a particular singleton value to instantiate
a corresponding type variable in a polymorphic expression.
3.2.8 Applying the Promotions
Here we summarize how we use the promoted types and singletons to generically derive
algorithms for operations in arbitrary cyclotomics. We rely on the â€œsparse decompositionâ€
framework described in section 3.4 below; for our purposes here, we only need that a
value of type Trans r represents a linear transform over a base ring r via some sparse
decomposition.
A detailed example will illustrate our approach. Consider the polymorphic function
crt :: (Fact m, CRTrans r, ...) => Tagged m (Trans r)
which represents the index-m Chinese Remainder Transform (CRT) over a base ring r (e.g.,
Zğ‘ or C). Equation (3.3.1) gives a sparse decomposition of CRT in terms of prime-power
indices, and Equations (3.3.2) and (3.3.3) give sparse decompositions for the prime-power
case in terms of the CRT and DFT for prime indices, and the â€œtwiddleâ€ transforms for
prime-power indices.
Following these decompositions, our implementation of crt works as follows:
1. It ï¬rst obtains the singleton corresponding to the Factored type m, using sing ::
Sing m, and extracts the list of singletons for its PrimePower factors. It then takes
the Kronecker product of the corresponding specializations of the prime power-index
CRT function
crtPP :: (PPow pp, CRTrans r, ...) => Tagged pp (Trans r)
The specializations are obtained by â€œelevatingâ€ the PrimePower singletons to instanti-
ate the pp type variable using withSingI, as described above.
55
(The above-described transformation from Factored to PrimePower types applies
equally well to all our transforms of interest. Therefore, we implement a generic
combinator that builds a transform indexed by Factored types from any given one
indexed by PrimePower types.)
2. Similarly, crtPP obtains the singleton corresponding to the PrimePower type pp, ex-
tracts the singletons for its PrimeBin (base) and Pos (exponent) types, and composes
the appropriate specializations of the prime-index CRT and DFT functions
crtP, dftP :: (Prim p, CRTrans r, ...) => Tagged p (Trans r)
along with prime power-indexed transforms that apply the appropriate â€œtwiddleâ€
factors.
3. Finally, crtP and dftP obtain the singleton corresponding to the PrimeBin type p,
and apply the CRT/DFT transformations indexed by this value, using naÃ¯ve matrix-
vector multiplication. This requires the pth roots of unity in r, which are obtained via
the CRTrans interface.
3.3 Tensor Interface and Sparse Decompositions
In this section we detail the â€œbackendâ€ representations and algorithms for computing in
cyclotomic rings. We implement these algorithms using the sparse decomposition framework
outlined in section 3.4. This section relies heavily on the background and notation given
in section 2.2.
An element of the ğ‘šth cyclotomic ring over a base ring r (e.g., Q, Z, or Zğ‘) can be
represented as a vector of ğ‘› = ğœ™(ğ‘š) coefï¬cients from r, with respect to a particular r-basis
of the cyclotomic ring. We call such a vector a (coefï¬cient) tensor to emphasize its implicit
multidimensional nature, which arises from the tensor-product structure of the bases we use.
The class Tensor (see Figure 3.1) represents the cryptographically relevant operations
on coefï¬cient tensors with respect to the powerful, decoding, and CRT bases. An instance
56
of Tensor is a data type t that itself takes two type parameters: an m representing the
cyclotomic index, and an r representing the base ring. So the fully applied type t m r
represents an index-m cyclotomic tensor over r.
The Tensor class introduces a variety of methods representing linear transformations
that either convert between two particular bases (e.g., lInv, crt), or perform operations
with respect to certain bases (e.g., mulGPow, embedDec). It also exposes some important
ï¬xed values related to cyclotomic ring extensions (e.g., powBasisPow, crtSetDec). An
instance t of Tensor must implement all these methods and values for arbitrary (legal)
cyclotomic indices.
3.3.1 Single-Index Transforms
In this and the next subsection we describe sparse decompositions for all the Tensor
operations. We start here with the dimension-preserving transforms involving a single
index ğ‘š, i.e., they take an index-ğ‘š tensor as input and produce one as output.
Prime-Power Factorization
For an arbitrary index ğ‘š, every transform of interest factors into the tensor product of the
corresponding transforms for prime-power indices. More speciï¬cally, let ğ‘‡ğ‘š denote the
matrix for any of the linear transforms on index-ğ‘š tensors that we consider below. Then
letting ğ‘š =âˆï¸€
â¨‚ï¸
â„“ ğ‘šâ„“ be the factorization of ğ‘š into its maximal prime-power divisors ğ‘šâ„“ (in
some canonical order), we have the factorization
ğ‘‡ğ‘š =
ğ‘‡ğ‘šâ„“
.
(3.3.1)
â„“
This follows directly from the Kronecker-product factorizations of the powerful, decoding,
and CRT bases (e.g., Equation (2.2.2)), and the mixed-product property. Therefore, for the
57
class Tensor t where
-- single-index transforms
scalarPow :: (Ring
r -> t m r
scalarCRT :: (CRTrans mon r, Fact m) => mon (r -> t m r)
r, Fact m) =>
l, lInv
:: (Ring r, Fact m) => t m r -> t m r
mulGPow, mulGDec :: (Ring
t m r
=> t m r ->
r, Fact m)
divGPow, divGDec :: (IntegralDomain r, Fact m)
=> t m r -> Maybe (t m r)
crt, crtInv, mulGCRT, divGCRT :: (CRTrans mon r, Fact m)
=> mon (t m r -> t m r)
tGaussianDec :: (OrdFloat q, Fact m, MonadRandom rnd, ...)
=> v -> rnd (t m q)
gSqNormDec
:: (Ring r, Fact m) => t m r -> r
-- two-index transforms and values
embedPow, embedDec :: (Ring r, m â€˜Dividesâ€˜ mâ€™) => t m
twacePowDec
r -> t mâ€™ r
:: (Ring r, m â€˜Dividesâ€˜ mâ€™) => t mâ€™ r -> t m r
embedCRT :: (CRTrans mon r, m â€˜Dividesâ€˜ mâ€™) => mon (t m r -> t mâ€™ r)
twaceCRT :: (CRTrans mon r, m â€˜Dividesâ€˜ mâ€™) => mon (t mâ€™ r -> t m r)
coeffs :: (Ring r, m â€˜Dividesâ€˜ mâ€™) => t mâ€™ r -> [t m r]
powBasisPow :: (Ring r, m â€˜Dividesâ€˜ mâ€™) => Tagged m [t mâ€™ r]
crtSetDec :: (PrimeField fp, m â€˜Dividesâ€˜ mâ€™, ...)
=> Tagged m [t mâ€™ fp]
Figure 3.1: Representative methods from the Tensor class. For the sake of concision, the
constraint TElt t r is omitted from every method.
58
remainder of this subsection we only deal with prime-power indices ğ‘š = ğ‘ğ‘’ for a prime ğ‘
and positive integer ğ‘’.
Embedding Scalars
Consider a scalar element ğ‘ from the base ring, represented relative to the powerful basis âƒ—ğ‘ğ‘š.
Because the ï¬rst element of âƒ—ğ‘ğ‘š is unity, we have
ğ‘ = âƒ—ğ‘ğ‘¡
ğ‘š Â· (ğ‘ Â· e1),
where e1 = (1, 0, . . . , 0). Similarly, in the CRT basis âƒ—ğ‘ğ‘š (when it exists), unity has the
all-ones coefï¬cient vector 1. Therefore,
ğ‘ = âƒ—ğ‘ğ‘¡
ğ‘š Â· (ğ‘ Â· 1).
The Tensor methods scalarPow and scalarCRT use the above equations to represent
a scalar from the base ring as a coefï¬cient vector relative to the powerful and CRT bases,
respectively. Note that scalarCRT itself is wrapped by Maybe, so that it can be deï¬ned as
Nothing if there is no CRT basis over the base ring.
Converting Between Powerful and Decoding Bases
Let ğ¿ğ‘š denote the matrix of the linear transform that converts from the decoding basis to
the powerful basis:
âƒ—ğ‘‘ğ‘¡
ğ‘š = âƒ—ğ‘ğ‘¡
ğ‘š Â· ğ¿ğ‘š ,
i.e., a ring element with coefï¬cient vector v in the decoding basis has coefï¬cient vector
ğ¿ğ‘š Â· v in the powerful basis. Because âƒ—ğ‘‘ğ‘š = âƒ—ğ‘ğ‘š,ğ‘ âŠ— âƒ—ğ‘‘ğ‘,1 and âƒ—ğ‘‘ğ‘¡
ğ‘,1 Â· ğ¿ğ‘ (both by
ğ‘,1 = âƒ—ğ‘ğ‘¡
59
Equation (2.2.5)), we have
âƒ—ğ‘‘ğ‘¡
ğ‘š = (âƒ—ğ‘ğ‘¡
= âƒ—ğ‘ğ‘¡
ğ‘ Â· ğ¿ğ‘)
ğ‘š,ğ‘ Â· ğ¼ğ‘š/ğ‘) âŠ— (âƒ—ğ‘ğ‘¡
âŸ
ğ‘š Â· (ğ¼ğ‘š/ğ‘ âŠ— ğ¿ğ‘)
 â
.
ğ¿ğ‘š
Recall that ğ¿ğ‘ is the square ğœ™(ğ‘)-dimensional lower-triangular matrix with 1s throughout
is the lower-triangular matrix with 1s on the diagonal, âˆ’1s on
ğ‘ using just ğ‘âˆ’ 1 additions,
its lower-left triangle, and ğ¿âˆ’1
the subdiagonal, and 0s elsewhere. We can apply both ğ¿ğ‘ and ğ¿âˆ’1
by taking partial sums and successive differences, respectively.
ğ‘
The Tensor methods l and lInv represent multiplication by ğ¿ğ‘š and ğ¿âˆ’1
ğ‘š , respectively.
Multiplication by ğ‘”ğ‘š
Let ğºpow
ğ‘š denote the matrix of the linear transform representing multiplication by ğ‘”ğ‘š in the
powerful basis, i.e.,
ğ‘”ğ‘š Â· âƒ—ğ‘ğ‘¡
ğ‘š = âƒ—ğ‘ğ‘¡
ğ‘š Â· ğºpow
ğ‘š .
Because ğ‘”ğ‘š = ğ‘”ğ‘ âˆˆ ğ’ªğ‘ and âƒ—ğ‘ğ‘š = âƒ—ğ‘ğ‘š,ğ‘ âŠ— âƒ—ğ‘ğ‘, we have
ğ‘”ğ‘š Â· âƒ—ğ‘ğ‘š = âƒ—ğ‘ğ‘š,ğ‘ âŠ— (ğ‘”ğ‘ Â· âƒ—ğ‘ğ‘)
= (âƒ—ğ‘ğ‘š,ğ‘ Â· ğ¼ğ‘š/ğ‘) âŠ— (âƒ—ğ‘ğ‘ Â· ğºpow
= âƒ—ğ‘ğ‘š Â· (ğ¼ğ‘š/ğ‘ âŠ— ğºpow
)
,
ğ‘
ğ‘
)
âŸ
 â
ğºpow
ğ‘š
60
ğºpow
ğ‘ =
1
...
,
(ğºpow
ğ‘
)âˆ’1 = ğ‘âˆ’1Â·
â›âœâœâœâœâœâœâœâœâœâœâœâœâœâœâœâœâœâœâœâœâœâœâ
â›âœâœâœâœâœâœâœâœâœâœâœâœâœâœâœâœâœâœâœâœâœâœâ
1
1
1
ââŸâŸâŸâŸâŸâŸâŸâŸâŸâŸâŸâŸâŸâŸâŸâŸâŸâŸâŸâŸâŸâŸâ 
ââŸâŸâŸâŸâŸâŸâŸâŸâŸâŸâŸâŸâŸâŸâŸâŸâŸâŸâŸâŸâŸâŸâ 
1
âˆ’1
...
...
âˆ’1
1
1
âˆ’1 2
2
âˆ’1
Â·Â·Â·
1
1
...
...
âˆ’1
1
âˆ’1 1
â›âœâœâœâœâœâœâœâœâœâœâœâœâœâœâœâœâœâœâœâœâœâœâ