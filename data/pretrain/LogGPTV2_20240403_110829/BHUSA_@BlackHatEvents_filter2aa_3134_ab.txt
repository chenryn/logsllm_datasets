7ffc15144fac EbpfApi!read_elf+0x00000000000000bc
7ffc15114fa0 EbpfApi!load_byte_code+0x0000000000000140
7ffc1510151b EbpfApi!_initialize_ebpf_object_from_elf+0x000000000000016b
7ffc1510374d EbpfApi!ebpf_object_open+0x00000000000001ed
#BHUSA @BlackHatEvents
Information Classification: General
eBPF4Win Service (ebpfsvc.dll)
The eBPF for Windows Service contains PREVAIL and 
uBPF code bases and exposes an RPC based API
The RPC service exports a single API for verifying and 
loading a program:
ebpf_result_t verify_and_load_program(
[ in, ref ] ebpf_program_load_info * info,
[ out, ref ] uint32_t * logs_size,
[ out, size_is(, *logs_size), ref ] char** logs);
#BHUSA @BlackHatEvents
Information Classification: General
eBPF4Win Service (ebpfsvc.dll)
The verify_and_load_program RPC API is called 
through the internal API ebpf_program_load_bytes
function that is ultimately exposed as part of the libbpf
API bpf_prog_load
It is also called by the ebpf_object_load function 
which is contained in EbpfAPI and is how netsh and 
bpftool load programs via the service
#BHUSA @BlackHatEvents
Information Classification: General
PREVAIL Static Verifier
The PREVAIL Static Verifier is “a Polynomial-
Runtime EBPF Verifier using an Abstract 
Interpretation Layer”
Designed to be faster and more precise than the
Linux static verifier and it is dual licensed MIT and 
Apache so it can be used anywhere alongside uBPF
#BHUSA @BlackHatEvents
Information Classification: General
PREVAIL Static Verifier
It includes a simple standalone tool called ‘check’ 
which is easily fuzzed with a file fuzzing approach
#BHUSA @BlackHatEvents
Information Classification: General
Fuzzing PREVAIL
#BHUSA @BlackHatEvents
Information Classification: General
Fuzzing PREVAIL
#BHUSA @BlackHatEvents
Information Classification: General
Fuzzing PREVAIL
#BHUSA @BlackHatEvents
Information Classification: General
Fuzzing PREVAIL
#BHUSA @BlackHatEvents
Information Classification: General
Fuzzing PREVAIL
#BHUSA @BlackHatEvents
Information Classification: General
uBPF
uBPF (Userspace BPF) is an independent 
reimplementation of the eBPF bytecode interpreter 
and JIT engine that is BSD licensed and can run in 
user or kernel contexts 
Similar to PREVAIL, uBPF comes with a simple 
reference implementation of the VM with the ability to 
load and run eBPF programs. It does not have any 
helper functions or maps available and is only a virtual 
CPU and execution environment
#BHUSA @BlackHatEvents
Information Classification: General
Fuzzing uBPF
#BHUSA @BlackHatEvents
Information Classification: General
Fuzzing uBPF
#BHUSA @BlackHatEvents
Information Classification: General
Fuzzing uBPF JIT
#BHUSA @BlackHatEvents
Information Classification: General
Fuzzing uBPF JIT
#BHUSA @BlackHatEvents
Information Classification: General
Fuzzing uBPF JIT
#BHUSA @BlackHatEvents
Information Classification: General
Fuzzing uBPF JIT
#BHUSA @BlackHatEvents
Information Classification: General
Fuzzing ebpfsvc.dll
Our initial attempts at fuzzing involved cross fuzzing 
using the pile of crashes we had found in the 
individual components but we were hitting crashes
too early in the API 
We began fuzzing with WTF but this coincided with 
the checkin of Microsoft’s own libfuzzer harness for 
PREVAIL which found many of the same bugs so no 
new bugs were found
#BHUSA @BlackHatEvents
Information Classification: General
eBPF4Win Kernel (ebpfcore.sys) 
In addition to the RPC interface exposed by the eBPFSvc
the kernel module exposes a set of IOCTLs for
manipulating programs and maps
Currently the ACL on the Device Object requires
Administrator privileges so the impact is limited at this 
point in time, however this is meant to be proactive 
vulnerability analysis so we will fuzz the IOCTL layer
#BHUSA @BlackHatEvents
Information Classification: General
ebpfcore.sys IOCTL Interface
IOCTL Functions
0x0 resolve_helper
0x10 get_ec_function
0x1 resolve_map
0x11 get_program_info
0x2 create_program
0x12 get_pinned_map_info
0x3 create_map
0x13 get_link_handle_by_id
0x4 load_code
0x14 get_map_handle_by_id
0x5 map_find_element
0x15 get_program_handle_by_id
0x6 map_update_element
0x16 get_next_link_id
0x7 map_update_element_with_handle
0x17 get_next_map_id
0x8 map_delete_element
0x18 get_next_program_id
0x9 map_get_next_key
0x19 get_object_info
0xa query_program_info
0x1a get_next_pinned_program_path
0xb update_pinning
0x1b bind_map
0xc get_pinned_object
0x1c ring_buffer_map_query_buffer
0xd link_program
0x1d ring_buffer_map_async_query
0xe unlink_program
0x1e load_native_module
0xf close_handle
0x1f load_native_programs
#BHUSA @BlackHatEvents
Information Classification: General
Fuzzing ebpfcore.sys 
The majority of attack surface is available via fuzzing the 
IOCTL interface for ebpfcore.sys
To fuzz kernel attack surface a more sophisticated 
technique was used
Emulation and snapshot based fuzzing was used 
leveraging the WTF fuzzer tool from Axel Souchet
Multiple IOCTL requests can be sent in sequence 
between memory restoration from snapshot
#BHUSA @BlackHatEvents
Information Classification: General
Snapshot Fuzzing
An advanced fuzzing technique that uses 
emulators to continue code execution of a 
snapshot of a live system to allow researchers to 
fuzz specific areas of code.
Benefits:
•
Allows researchers to create small and quick fuzzing 
loops in complex programs.
•
Allows researchers to create large amounts of complexity 
in the program before fuzzing so that the fuzzer does not 
need to set up complexity.
•
Allows researchers to fuzz "hard to reach" areas of code.
#BHUSA @BlackHatEvents
Information Classification: General
WTF Fuzzer
WTF Fuzzer
Advantages
▪ Distributed
▪ Code-Coverage Guided
▪ Customizable
▪ Cross Platform
Tradeoffs
▪ Out of the box cannot 
handle:
– Task Switching
– Device IO
▪ Still in Development
#BHUSA @BlackHatEvents
Information Classification: General
WTF Fuzzer
To write a fuzzer with WTF, a 
few functions must be 
implemented
Init() sets up breakpoints in the
emulator to handle events
InsertTestcase() is called with 
fuzzed data
#BHUSA @BlackHatEvents
Information Classification: General
WTF Fuzzer
There are also optional 
callbacks for custom data
generators and the snapshot 
restore event
For multi-packet or IOCTL 
requests, the user implements 
a serialization format
#BHUSA @BlackHatEvents
Information Classification: General
WTF vs ebpfcore.sys 
We created a harness based on the excellent tlv_server
harness that is included with WTF. The original is 
designed to simulate sending multiple network packets to 
an interface. 
We forked this code and had it send IOCTL requests via
DeviceIOControlFile calls instead
#BHUSA @BlackHatEvents
Information Classification: General
WTF vs ebpfcore.sys 
For multi IOCTL requests 
we created a JSON based 
serialization format 
The serialized testcase 
contains an array of 
requests that include the 
bytes of the data in the 
Body along with the 
Length, IOCTL 
OperationID, and expected 
ReplyLength
#BHUSA @BlackHatEvents
Information Classification: General
_ebpf_murmur3_32 Crash
Crash Type: Read Access Violation
Crash Cause:
• By setting the length in the packet header to a value 
less than the offset to the path in the packet struct you 
can underflow the length of the string struct created.
• The string is then passed into the ebpf_murmur
function along with the length, at which point the loop 
inside the function will read past the end of the string 
and into memory it should not have access to.
#BHUSA @BlackHatEvents
Information Classification: General
_ebpf_murmur3_32 Crash
#BHUSA @BlackHatEvents
Information Classification: General
ubpf_destroy Crashes
Crash Type: Null Pointer Dereference
Crash Cause:
• ubpf_create runs out of memory while trying to calloc
space for structs due to memory exhaustion.
• The function fails and returns a null value for the vm
which is then passed into ubpf_destroy
causing different null pointer dereferences depending 
on when the program ran out of memory.
• Note: multiple unique variations were found
#BHUSA @BlackHatEvents
Information Classification: General
ubpf_destroy Crashes
#BHUSA @BlackHatEvents
Information Classification: General
trampoline_table Crash
Crash Type: Null Pointer Dereference
Crash Cause:
• When a program is created a callback is added to it which is trigger under certain 
conditions.
• If a resolve helper call is done on the program the callback is triggered, however, if the 
resolve helper function fails then the trampoline_table can become null.
• If the user then tries to load code the program will crash due to a null dereference.
#BHUSA @BlackHatEvents
Information Classification: General
trampoline_table Crash
#BHUSA @BlackHatEvents
Information Classification: General
trampoline_table Crash
#BHUSA @BlackHatEvents
Information Classification: General
AFL-NYX vs ebpfcore.sys 
In addition to WTF, we also ported the same harness to 
the NYX hypervisor based snapshot fuzzer to assess 
capabilities and performance
NYX had significantly faster execution speed compared to 
WTF but did not find unique bugs due to the thoroughness 
of the initial fuzzer design
We did of course find similar bugs..
#BHUSA @BlackHatEvents
Information Classification: General
AFL-NYX vs ebpfcore.sys 
#BHUSA @BlackHatEvents
Information Classification: General
eBPF4Win Kernel Extension Modules
eBPF for Windows is designed with a modular architecture on the kernel side
Instrumentation support is added to eBPF for Windows via “extension modules”
The current implementation provides a network shimming interface to allow for packet 
inspection and rewriting at multiple levels 
#BHUSA @BlackHatEvents
Information Classification: General
eBPF4Win Network Shims (netebpfext.sys)
Microsoft is currently focused on observing and 
instrumenting network packets in the current eBPF
implementation
Hook implementations can contain exploitable bugs 
that may be hard to detect
In this case we did a manual code review of the xdp,
bind, and cgroup hooks and did not find any 
implementation errors.
#BHUSA @BlackHatEvents
Information Classification: General
eBPF4Win Code Hooks 
On Linux, eBPF has strong integration with uprobe, kprobe, and tracepoint code hooking 
interfaces
Microsoft has libraries capable of providing similar code hooking abilities such as Detours
Currently code hooking is not supported via eBPF for Windows 
An additional kernel extension module for code hooking can be added in the future to sit 
alongside netebpfext.sys
#BHUSA @BlackHatEvents
Information Classification: General
Concluding Thoughts
• eBPF is exciting technology for telemetry and instrumentation on modern operating 
systems 
• Microsoft has adapted opensource projects uBPF and PREVAIL to provide the 
foundation for their eBPF implementation 
• We found one serious ACE vulnerability and several robustness bugs during our fuzzing 
of the driver and userland loader code
• Microsoft has been quickly adding fuzz testing to their repo since May which has fixed 
many of the bugs found in the opensource projects
• With the creation of the eBPF foundation backed by several major industry players, 
eBPF is positioned to become a core technology for desktop, server, and cloud
• Trellix is committed to proactive vulnerability research to benefit the community
#BHUSA @BlackHatEvents
Information Classification: General
Thank you!
Richard Johnson, Trellix
@richinseattle on Twitter