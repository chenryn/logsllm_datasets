26% 
0% 
Sensitivity 
of the 
block 
0.4% 
0.0% 
0.9% 
13.3% 
0.5% 
4.0% 
0.9% 
0.0% 
0.2% 
1.2% 
0.0% 
Contribu-
tion from 
unit 
8% 
3% 
25% 
0% 
11% 
7% 
16% 
0% 
21% 
3% 
8% 
Likelihood 
of fault 
masking 
1.7% 
3.2% 
34.2% 
0.0% 
2.8% 
5.4% 
6.1% 
0.0% 
2.5% 
0.5% 
2.9% 
Table 10: Outcomes of the fault injection as function of the component injected 
Functional Block 
Crash 
Fail Silent 
DataViolation 
Incomplete 
Execution 
Execution 
Control 
Speculation 
Memory Interface 
45% 
17% 
17% 
21% 
40% 
24% 
10% 
26% 
17% 
35% 
34% 
14% 
Table 11: Outcomes of the fault injection as function of 
the component injected 
5.4 Propagation Paths 
Analysis  of  fault/error  propagation  between  the  functional 
units  of  the  processor  allows  us  to  (i)  obtain  a  better  under-
standing of how the processor fails and (ii) determine where a 
detection  mechanism  should  be  deployed  in  order  to  maxi-
mize  the  chances  of  detecting  a  fault  before  it  corrupts  the 
state of the processor or propagates outside the processor. 
Generation  of  error  propagation  graph.  As  a  first  step,  a 
static  analysis  on  the  VHDL  gate-level  netlist  of  the  target 
processor is conducted to build a static connectivity diagram,
representing the communication paths between the functional 
units  of  the  processor.  A  sample  of  the  static  connectivity 
diagram is depicted in Figure 3a. Nodes labeled Alu, Rb, Dp, 
Biu correspond  to  the  functional  units  of  the  processor  and 
the  arcs  depict  unidirectional  wires  between  the  units.  The 
procedure  used  to  generate  the  propagation  paths  for  each 
injected fault consists of several steps enlisted below. 
1. Generate an error propagation table for an injected fault in 
the  form  of  a  time-ordered  sequence  of  functional  units  af-
fected  by  the  fault  (until  the  error  surfaces  at  the  processor 
interface).  An  example  of  a  possible  time  ordered  sequence 
for a fault injected in the Alu and spreading into the Rb, Dp, 
and Biu is shown in Figure 3b. 
2. Compare  the  constructed  error  propagation  sequences 
with  the  static  connectivity  diagram  to  eliminate  infeasible 
propagation  paths.  For  instance,  comparing  the  connectivity 
diagram  in  Figure  3a,  with  the  time  ordered  sequence  de-
picted in Figure 3b, two paths Alu → Rb → Biu (black solid 
lines Figure 3c) and Alu → Dp (a gray dashed line in Figure 
3c)  are  extracted  as  potential  error  propagation  paths.  Faults 
cannot propagate from Biu to Dp (no physical path exists) or 
from  Rb  to  Dp  (unidirectional  connection  points  from  Dp  to 
Rb);  consequently,  these  two  paths  are  discarded  as  infeasi-
ble.  Further,  a  fault  cannot  propagate  through  the  path  from 
Dp  to  Rb  due  to  the  timing  order  of  the  occurrence  of  the 
fault at the interface of Dp and Rb.
Rb
Functional
Manifestation
1/2
Rb
Alu
Dp
Biu
Unit
Alu
Rb
Biu
Dp
Time
1000ns
1060ns
1180ns
1240ns
Alu
1/2
Biu
Dp
Paths
Weight
Alu - Rb  - Biu
Alu - Dp
1/2
1/2
a) Static connectivity graph
b) Time order manifestation sequence
c) Possible paths and assigned weights
Figure 3: Constructing the list of fault/error propagation paths 
Proceedings of the 2005 International Conference on Dependable Systems and Networks (DSN’05) 
0-7695-2282-3/05 $20.00 © 2005 IEEE
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 12:09:13 UTC from IEEE Xplore.  Restrictions apply. 
3. Associate/assign  to  each  arc  (of  any  feasible  fault  propa-
gation  path)  a  weight,  which  gives  the  probability  of  occur-
rence  of  that  fault-path.  In  general,  multiple  fault  paths  can 
originate  from  the  same  injected  fault  as  we  cannot  conclu-
sively  determine  which  path  is  actually  taken.  The  weight 
assigned  to  each  arc  originating  from  a  given  node  is  in-
versely proportional to the  number of feasible arcs (or fault-
paths).  In  the  example  scenario  in  Figure  3b,  there  are  two 
feasible paths and, hence, the weight assigned to each outgo-
ing  arc  from  the  node  labeled  Alu  is  1/2.  Note  that  if  a  par-
ticular path has already been traversed by any of the previous 
faults, the current weight is summed to the previous weight. 
4. Collect (feasible) propagation paths for all faults. 
5. Create a global list of unique fault/error propagation paths 
with  weights  adjusted  according  to  the  frequency  of  occur-
rence of that particular path.  
6. Normalize the final weight of each propagation path with 
respect  to  the  total  number  of  manifested  errors  to  obtain  a 
global  list  of  all  propagation  paths  and  the  associated  prob-
ability of taking the path.  
7. Merge the identified paths into a global fault/error propa-
gation graph (global list).
This procedure results in a global list of unique paths with a 
certain  probability  of  occurrence.  Ultimately  the  most  sensi-
tive  fault-paths  are  obtained.  Figure  3  depicts  a  global 
fault/error  propagation  paths  obtained  from  the  analysis  of 
experimental data from the Bubble Sort workload. Each node 
in  the  graph  corresponds  to  one  of  the  functional  units.  Fig-
ures reported along the arcs represent the probability  that an 
error propagates from the source node to the destination node.
Discussion. Analysis of fault propagation paths indicate: 
• As  expected,  the  blocks  from  which  faults  propagate  di-
rectly  to  the  Biu  are  the  If  (10%)  (which  sends  the  program 
counter value), the Lsu (17%) (which sends the address of the 
memory  location  to  be  fetched  by  load  instructions),  the  Wb
(24%) (which sends the address and value of the of the store 
instruction)  and  the  Dp  (5%)  (which  controls  the  proper  op-
eration of the Biu).
• The  Dp  and  Rb  are  two  sources  of  faults  that  propagate  to 
the  If,  potentially  causing  a  change  in  the  program  counter 
(PC) value (10% of the faults in Dp and 26% of the faults in 
Rb propagate to If). The Dp forces the change in PC value in 
case  of  a  misprediction  or  when  there  is  an  exception  while 
decoding an instruction. An exception in the Alu (17%), Mdu
(32%), Lsu (10%), or Bru (36%) is flagged in the Rb, which 
then propagates to the If.
• One  of  the  main  reasons  for  fault  manifestation  is  the  cor-
ruption of the processor state, i.e. state of the Rf. The Rf can 
be corrupted by the Dp (20%), the If (19%), or the Cu (16%). 
Of the three, Dp just resets some of the components of Rf in 
case  of  an  exception,  and  If sends  the  PC  value  at  various 
stages of execution. Consequently, one can assume that Cu is 
the main source of corruption of Rf.
The  most  sensitive  paths  from  our  analysis  are  reported  in 
Table 12. Just 20 most-frequent paths account for about 50% 
of all paths traversed. 
Results from fault/error propagation path analysis can be used 
to  devise  effective  protection  strategies.  For  example,  the  Rf
is  a  complex  block  since  it  occupies  about  22%  of  the  total 
area of the processor. Hence, using replication mechanism to 
detect  an  error  is  an  expensive  technique.  From  the  global 
error propagation path, it is clear that a fault that is generated 
in  the  Rf  corrupts  the  Dp  30%  of  the  time.  The  Dp  gets  the 
contents of the registers from the Rf and delivers this value to 
the  Alu.  Following  this  path  from  Rf  to  Alu,  we  can  under-
stand how an error can corrupt the computation. In the above 
mentioned  case  a  detection  mechanism  can  be  deployed  be-
tween the interfaces of the Rf and the Cu for checking anoma-
lous values of the registers. A possible mechanism would be 
to use a comparator to check the value of the registers against 
boundaries computed by profiling the application. 
Figure 3: Global fault/error propagation paths 
Dp→ Biu 
Dp → Wb → Biu 
Dp → Lsu → Biu 
Dp → Rb → Lsu → Biu 
Dp → If → Biu 
Dp → Cu → Lsu → Biu 
Lsu → Biu 
If → Biu 
If → Lsu → Biu 
Rf → Cu → Wb → Biu 
7.30% 
5.30% 
4.10% 
3.60% 
3.60% 
3.40% 
2.50% 
2.50% 
1.90% 
1.80% 
Table 12: Most frequent error path propagations 
Related Work 
6
Techniques to implement HDL-level fault injectors for hard-
ware systems can be classified into two major groups [21]: (i) 
fault injectors based on modification of the description of the 
target  system  to  inject  faults,  such  as  saboteurs  or  mutants 
[22]; (ii) fault injectors relying on changes of the state of the 
simulation  (e.g.,  the  value  of  variables  or  signals)  through 
simulator commands,  without  modifying the system descrip-
tion [23]. While the tools from the first group enable injecting 
broader range of faults, the injectors in the second group are 
easier to implement and allow speed-up of the simulation.  
Proceedings of the 2005 International Conference on Dependable Systems and Networks (DSN’05) 
0-7695-2282-3/05 $20.00 © 2005 IEEE
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 12:09:13 UTC from IEEE Xplore.  Restrictions apply. 
Several  studies  have  analyzed  a  processor  behavior  using 
fault injection. In [5] the effects of transient faults in a super-
scalar  Alpha-like  processor  are  studied.  Faults  are  injected 
into  memory  elements  (flip-flops  and  RAM)  in  the  RTL  de-
scription  of  this  processor.  The  fault  model  used  is  a  single 
bit-flip  of  a  state  element  (equivalent  to  our  fault  model  for 
flip-flop for one clock cycle). It is observed that about 88% of 
injected faults do not manifest, the most error sensitive units 
are register file and the speculation logic.  
In  [10]  a  performance  model  of  a  processor  is  used  to  esti-
mate the sensitivity of different blocks within the microproc-
essor  to  soft  errors.  The  Architectural  Vulnerability  Factor 
(equivalent to our soft error sensitivity) is introduced to quan-
tify  the  error  sensitivity.  While  the  methodology  is  fast  and 
allows simulating (at instruction level) workload with million 
of instructions, the  used performance  model limits the sensi-
tivity analysis to estimating only the contribution of the faults 
from flip-flops in the blocks affecting the performance of the 
microprocessor.  
A fault injection study of PicoJava II is reported in [6]. Single 
bit-flips are injected into flip-flops at the RTL description of 
the processor. The error sensitivity analysis indicates that the 
microcode unit (or control logic) is as sensitive as the execu-
tion  unit.  In  [7],  a  technique  to  estimate  the  failure  rate  of 
digital  designs,  implemented  on  an  SRAM-based  FPGA  is 
proposed. It is based on the computation of signal probabili-
ties  and  then  of  the  error  propagation  probabilities  based  on 
the  topological  structure  of  the  circuit.  This  technique  can 
compute the system failure probability very fast, but it cannot 
classify the effect of a fault at the application level. 
Conclusions 
7
This paper studies the impact of soft errors in a microproces-
sor  for  embedded  applications.    The  target  system  is  a  gate-
level  implementation  of  a  DLX-like  processor.  The  synthe-
sized  design  is  simulated,  and  transient  faults  are  injected  to 
stress  the  processor  while  it  is  executing  selected  applica-
tions. Collected data are analyzed to assess (i) fault sensitivity 
of  control  and  speculation  logic  as  compared  to  other  func-
tional  blocks,  (ii)  error  contribution  from  combinational  cir-
cuits versus flip-flops, and (iii) error propagation between the 
functional units. The results indicate that the fault sensitivity 
of  control  and  speculation  blocks  is  comparable  or  even  lar-
ger  than  that  of  execution  block.  Also,  the  combinational 
logic,  though  less  sensitive  than  flip-flops,  could  potentially 
lead to increased error manifestation in future technologies. 
Acknowledgments 
8
This work was supported in part by NSF grant ACI 0121658 
ITR/AP, MURI grant N00014-01-1-0576 and Gigascale Sys-
tems  Research  Center  (GSRC/MARCO).  We  thank  Fran 
Baker for her careful reading of an earlier draft of this paper. 
References 
[1]  T. Karnik, P. Hazucha, J. Patel, “Characterization of soft errors 
caused by single event upsets in CMOS processes,” IEEE Trans-
actions on Dependable and Secure Computing, 1(2), 2004. 
[2]  P. Shivakumar, et al., “Modeling the effect of technology trends 
on the soft error rate of combinatorial logic,” Proc. of Int’l Con-
ference on Dependable Systems and Networks, 2002. 
[3]  T. Juhnke, H. Klar, “Calculation of the soft error rate of submi-
cron CMOS logic circuits,” IEEE Journal of Solid-State Circuits,
30, 1995. 
[4]  P. Hazucha, et al., “Measurements and analysis of SER-tolerant 
latch in a 90-nm dual-V/sub T/ CMOS process,” IEEE Journal of 
Solid-State Circuits, 39(9), 2004. 
[5]  N.J. Wang, et al., “Characterizing the effects of transient faults 
on a high-performance pipeline,” Proc. of Int’l Conference on De-
pendable Systems and Networks, 2004. 
[6]  S.  Kim,  A.  K.  Somani,  “Soft  error  sensitivity  characterization 
for microprocessor dependability enhancement strategy,” Proc. of 
Int’l Conference on Dependable Systems and Networks, 2002. 
[7]  G.  Asadi,  M.B.  Tahoori,  “An  analytical  approach  for  soft  error 
rate  estimation  of  SRAM-based  FPGAs,”  Proc.  of  MAPLD  Int’l 
Conference, 2004. 
[8]  Z.  Alkhalifa  et  al.,  “Design  and  evaluation  of  system-level 
checks  for  on-line  control  flow  error  detection,”  IEEE  Trans.  on 
Parallel and Distributed Systems, 10(6), 1999. 
[9]  R.Karri,  B.  Iyer,  “Introspection:  A  register  transfer  level  tech-
nique  for  concurrent  error  detection  and  diagnosis  in  data  domi-
nated  designs,”  ACM  Trans.  Design  Autom.  Electr.  Syst.  6(4), 
2001. 
[10]  S.S. Mukherjee, et al.: “A systematic methodology to compute 
the architectural vulnerability factors for a high-performance mi-
croprocessor,” Proc. of MICRO-36, 2003. 
[11]  J.  L.  Hennessy,  D.  A.  Patterson,  Computer  Architecture:  A 
Quantitative Approach, Morgan Kaufmann, 2002. 
[12]  H. Eveking, SuperScalar DLX documentation, 
http://www.rs.e-technik.tu-darmstadt.de/TUD/res/dlxdocu/DlxPdf.zip.
[13]  L.  B.  Freeman,  “Critical  charge  calculations  for  a  bipolar 
SRAM array,” IBM Journal of Research and Development, 40(1), 
1996. 
[14]  P.  Hazucha,  “Background  radiation  and  soft  errors  in  CMOS 
circuits,”  Linkping  Studies  in  Science  and  Technology,  Disserta-
tions, 2000. 
[15]  http://bwrc.eecs.berkeley.edu/Classes/IcBook/SPICE/.
[16]  G.S. Choi, R.K. Iyer, “FOCUS: Sn experimental environment 
for fault sensitivity analysis,” IEEE Trans. on Computers, 41(12), 
1992. 
[17]  Z.  Kalbarczyk,  et  al.,  “Hierarchical  simulation  approach  to 
accurate  fault  modeling  for  system  dependability  evaluation,” 
IEEE Transactions on Software Engineering, 25(5), 1999. 
[18]  N.  J.  Buchanan  et  al.  “Total  ionizing  dose  effects  in  a  Xilinx 
FPGA,” ATLAS-LARG internal note ATL-LARG-99-003, 1999. 
[19]  K.-T.  Cheng,  S.-Y.  Huang,  W.-J.  Dai,  “Fault  emulation:  A 
new  methodology for fault frading,” IEEE Transactions on CAD,
18(10), 1999. 
[20]  C.  Weaver,  T.  Austin,  “A  fault  tolerant  approach  to  micro-
processor  design,”  Proc.  of  Int’l  Conference  on  Dependable  Sys-
tems and Networks, 2001. 
[21]  J.  Gracia,  et  al.,  “Comparison  and  application  of  different 
VHDL-based fault injection techniques,” Proc. of Int’l Symposium 
on Defect and Fault Tolerance in VLSI Systems, 2001. 
[22]  J.  Boue,  et  al.,  “MEFISTO-L:  A  VHDL-based  fault  injection 
tool  for  the  experimental  assessment  of  fault  tolerance,”  Proc.of 
Int’l Symposium on Fault-Tolerant Computing, 1998. 
[23]  V.  Sieh,  O.  Tschache,  F.  Balbach,  “VERIFY:  Evaluation  of 
reliability using VHDL-models with embedded fault descriptions,” 
Proc. of Int’l Symposium on Fault-Tolerant Computing, 1997. 
[24]  N.  Nakka,  Z.  Kalbarczyk,  R.k.  Iyer,  J.  Xu,  “An  architectural 
framework for providing reliability and security support,” Proc. of 
Int’l Conference on Dependable Systems and Networks, 2004. 
Proceedings of the 2005 International Conference on Dependable Systems and Networks (DSN’05) 
0-7695-2282-3/05 $20.00 © 2005 IEEE
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 12:09:13 UTC from IEEE Xplore.  Restrictions apply.