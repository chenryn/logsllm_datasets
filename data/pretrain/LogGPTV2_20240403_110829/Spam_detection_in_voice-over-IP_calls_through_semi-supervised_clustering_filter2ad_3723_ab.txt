308
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 09:59:55 UTC from IEEE Xplore.  Restrictions apply. 
 features, it works well only with a large fraction of calls with accurate user feedback.  2. Related work  Rosenberg [4] details the problem of VoIP SPIT and gives various high-level conceptual solutions. The solutions can be placed in three categories [7]: (1) Non-intrusive methods based on the exchange and analysis of signaling messages; (2) Interaction methods that create inconveniences for the caller by requesting them to pass a checking procedure before the call is established; (3) Callee interaction methods that exchange information with the callee on each call. An example work in category 1 is [8] where the authors look at the SIP signaling traffic pattern to detect SPIT. However, they do not provide quantitative data on the detection accuracy. Our experimental results indicate solely relying on SIP message patterns will give low detection coverage. The work by Quittek [7] generates a greeting sound or faked ring tone to the caller right after the call is established and monitors the response voice patterns from the caller to differentiate between human caller and a SPIT generator. This falls in category 2. In comparison, our work encompasses categories 1 and 3. Kolan [9] presents an approach which maintains the trust information for each caller. The information can be automatically built up through user feedback, or through a propagation of reputation via social networks. The approach can be used in our system where we can embed the caller’s trust as one of the call features. However, the reputation database may grow large and a reputation system can be gamed by false praise or false blame.  Clustering is a way to learn a classification from the data [10], especially with unlabeled data. Clustering techniques have been used for detecting e-mail spam in [11],[12]. On the other hand, classification techniques such as SVM [13] are popular for data classification. However, they typically require labeled data and do not take unlabeled data into consideration. Recent developments in  semi-supervised classification techniques [14], such as semi-supervised SVM [15], incorporate both labeled and unlabeled data.   3. Design  3.1 Structure of VoIP calls  There are typically three phases involved in a VoIP phone call [16]. The first phase is call establishment through a three-way handshake, which involves (i) the caller sending a SIP INVITE message to the proxy server and the server forwarding the INVITE message to the callee, (ii) the callee replying with a SIP OK message, and (iii) the caller sending SIP ACK message to complete the call establishment phase. The second phase is the conversation, which contains the media stream (voice) transmitted between the caller and the callee typically using RTP/RTCP [17]. The last phase is the call tear down phase, which can be initiated by either the caller or the callee sending a SIP BYE message followed by SIP OK and SIP ACK messages.  3.2 Characteristics of VoIP SPIT calls  A blacklist-based approach can be used at the call establishment phase based on source IP or From URI to drop calls from known SPIT sources. In the media stream phase, a typical pattern one can imagine for SPIT calls is that the caller speaks more than the callee. Another pattern is that the length of the media stream phase, i.e., the call duration, is shorter in the case of calls answered by a live person since SPIT calls are generally undesirable. Also, one can assume that it is more likely that for a SPIT call, a call termination will be initiated by the callee, i.e., the callee sends the SIP BYE message.  Since SPIT calls are usually large volume calls made by some spitter within a period of time, we found that it is also useful to look for patterns in a batch of calls. Certain features are available when looking at the collective set of calls, such as the inter-arrival time between calls. Also statistical learning can only occur with a batch of calls.   3.3 Detection scheme  A VoIP environment typically consists of multiple domains with each domain composed of a few proxy servers and phones belonging to end users. Figure 1 shows an example VoIP environment consisting of two domains. In a VoIP environment, a proxy server’s main function is to route the signaling messages. For the specific example we show, here Proxy #1 is used to route the signaling Figure 1. Detecting Spit Calls in a VoIP EnvironmentSIP based VoIP Proxy Server #1Server-side DetectorSIP based VoIP Proxy Server #2SSABCEFS: normal user: spitterLegendClient-side DetectorClient-side DetectorClient-side DetectorSpit Detector978-1-4244-4421-2/09/$25.00 c(cid:13)2009 IEEE
309
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 09:59:55 UTC from IEEE Xplore.  Restrictions apply. 
 messages among phones {A,B,C}. And similarly, Proxy #2 is used to route the signaling messages among phones {E,F}. Cross domain phone calls {A,B,C}(cid:82){E,F} are collaboratively handled by Proxy #1 and Proxy #2. Once a phone call is established, subsequent messages (signaling and voice) can travel directly between phones without involving the proxies. However, an ISP can mandate all traffic pass through the proxies, which is often the case for billing and security purposes.  Our approach in detecting SPIT calls involves placing local detectors at the SIP proxies and the phones in the managed domain. The domains that have our detection mechanism are called managed domains and others are called unmanaged domains. Essentially, the detectors require observability of the signaling and the media streams within the managed domain. A spitter can exist as any phone in a VoIP environment, whether within a managed (phone B) or an unmanaged domain (phone E).  The embedded detectors collect the information of the phone calls and send them to the SPITDetector, where the logic for differentiating SPIT calls from non-SPIT calls executes. The decoding of the traffic and calculation of the call features are handled by the respective server-side/client-side detectors and only a digest of the necessary information is forwarded up to the detector, thus minimizing network traffic.   SPITDetector supports two modes of detection:  Mode A: Look at each phone call with early detection: In this mode, the SPITDetector has to determine whether a call is a SPIT or not before the media stream of the call is established. This means that the detection has to be completed before the callee picks up the phone. This mode is useful from an end-user’s point of view since SPIT calls can be potentially blocked without further annoyance.  Mode B: Look at the whole batch of phone calls: With Mode B, we assume received calls are kept in a collection which are then presented in a batch to our semi-supervised clustering algorithm. This mode provides higher detection accuracy than Mode A due to the availability of complete call feature information. Mode B is attractive to a service provider, rather than to an end user.   4. SPIT Detection using Semi-Supervised Clustering  4.1 Background  In our problem context, each VoIP call is regarded as one data point. We are interested in clustering call data points into two clusters, one containing the SPIT calls, and the other containing the non-SPIT calls. In general, there may be multiple sub-clusters within each cluster corresponding to radically different kinds of SPIT or non-SPIT calls. We explore this approach of multiple sub-clusters further in Sec. 4.7.  Semi-supervised clustering [18], [19], [6] is a recent development in the data clustering research community that aims to address the issue of selecting the proper criteria for clustering. Semi-supervised clustering allows the use of optional labeled data for a subset of the runtime observations to progressively modify the clustering criteria. This means that one does not need to determine a priori which features of the data points should be used for clustering. The clustering criteria will be trained into generating clusters that obey the user-labeled data as faithfully as possible [6]. The implicit assumption is that user feedback is perfectly accurate. In our work here, we evaluate the impact of noise in the user feedback.   4.2 VoIP call features for clustering  We construct a data point from each VoIP call based on 17 features: 1-2. From/To URI, 3. Start time, 4.Duration, 5. # of SIP INVITE messages, 6. # of ACK messages, 7-8. # of BYE messages from caller/callee, 9. Time since the last call from the originator of the current call, 10-15. # of 1xx, 2xx, 3xx, 4xx, 5xx, and 6xx SIP Response messages, 16. Call frequency of the originator of the current call, 17. Ratio of non-silence duration of the callee to the caller media streams.  For Mode A early detection, only features 1, 2, 3, and 9 are available. Feature 17 is derived from the RTP media stream by client-side detectors if the media streams are configured to flow directly between clients [20] or it can be provided by the server-side detector if the media streams are configured to flow through the SIP Proxy. We select the universe of features using our domain knowledge, to cover different facets of a VoIP call and to limit the number of features so that online clustering is feasible.   4.3 Labeled data via user feedback  Phone calls received in the managed domain can have optional user feedback information indicating whether a call is a SPIT call or a non-SPIT call. The corresponding data point will be labeled with a SPIT or a non-SPIT tag and fed into the semi-supervised clustering process. Such a data point will be used for adjusting the clustering criteria.   4.4 Extended K-Means for semi-supervised clustering: MPCK-Means  For this work, we select the semi-supervised clustering algorithm called MPCK-Means [6].   ()()()()()()2mpckmAxx,xxx,xxxlogdetA           + x,x 1           + x,x 1iiliiijiijiillijMijijMijCijijCwfllwfllχτμ∈∈∈=−−≠=⎛⎞⎜⎟⎝⎠⎡⎤⎣⎦⎡⎤⎣⎦∑∑∑ (1) 978-1-4244-4421-2/09/$25.00 c(cid:13)2009 IEEE
310
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 09:59:55 UTC from IEEE Xplore.  Restrictions apply. 
  ()()T2AxxAxiliiiiiliiμμμ−=−− (2)  ()22AA11x,xxxxx22llijMijijijf=−+− (3)  ()22'''AAx,xxxxxiilljiCijllijf=−−− (4)  ()()()()()()()()()(),'''''',1A1121ihijhijhThhihihxXTijijijijxxMTijhhhhxxCTijijijXxxwxxxxllwxxxxxxxxllμμ∈∈∈−⎛=−−⎜⎝⎡⎤+−−≠⎣⎦⎛+−−⎜⎝⎞⎞⎡⎤−−−=⎟⎟⎣⎦⎠⎠∑∑∑ (5) Eq. (1) is the objective function that MPCK-Means minimizes. li is the cluster that point xi is associated with. The main idea is the same as K-Means where intra-cluster distance is being minimized. However the Euclidean distance metric in MPCK-Means is weighted by a cluster-specific matrix Ali (one can also use the same A matrix across all clusters)[6]. Ali is modified based on user feedback and points in cluster li  following Eq.(5).  The user labeled data in MPCK-Means is supplied in the form of clustering constraints M (must link sets) and C (cannot link set). Here the M set specifies pairs of data points that should be put in the same cluster while the C set specifies those pairs of data points that should not be put in the same cluster. In Eq. (1), the last two terms are used to add penalty to the objective function from the violation of these constraints. The function fM returns a value proportional to the distance between the two points that are in different clusters. The function fC returns a value that is inversely proportional to the distance between two points that are in the same cluster. The points xli′ and xli′′ represent the two farthest data points in Xli with respect to their distance computed using Ali. The pseudo code for MPCK-Means is listed as Algorithm 1 below.  Input: Set of data points {}1NiiXx==, Set of must-link constraints (){},ijMxx= , Set of cannot-link constraints (){},ijCxx= , # of clusters K, Sets of constraints costs W and W, 0t←. Output: Disjoint K-partitioning {}1KhhX=of X such that objective function mpckmτ is locally minimized. Method: 1. Initialize clusters: 1.1. Create the λ neighborhoods {}1PPNλ= from M and C. if Kλ≥ Initialize {}(0)1Khhμ= using weightiest farthest-first traversal starting from the largest NP. Else Initialize {}(0)1hhλμ= with centroids of {}1PPNλ= Initialize remaining clusters at random 2. Repeat until convergence 2.1. For each data point ixX∈  *h=()()(2()AargminlogdetAhtihhhxμ−− ()[]()[])(,)(,),1,1MijjCijjijijijijxxMxxCwfxxhlwfxxhl∈∈+≠+=∑∑ Assign ix to*1thX+ 2.2. For each cluster Xh, {()11(1)tthxXhXthxμ++∈+←∑} 2.3. Update_metrics Ah for all clusters {}1KhhX= (Eq. (5)) 2.4. 1tt←+ Algorithm 1. MPCK-Means (Adapted from [6])  4.4.1 Mapping user feedback to pair-wise constraints in MPCK-Means The system keeps two sets: FS (data points of SPIT calls from feedback) and FN (data points of non-SPIT calls from feedback). For a data point xi, which has user feedback, the user indicates xi ∈ FS or xi ∈ FN. With respect to the MPCK-Means algorithm, must-link constraints M are derived online from pairs of points (xi, xj) ∈ FS or (xi, xj) ∈ FN. Similarly, cannot-link constraints C are created online from (xi, xj), where xi∈FS and xj∈FN.  For ease of exposition, we initially discuss the case with 2 clusters—one each for SPIT and non-SPIT calls. We discuss the extension to multiple clusters in Sec. 4.7. 4.4.2 Building detection predicate  Given a cluster Xh from the clustering algorithm,  we use the number of data points with different user feedback in the cluster to determine the association of the cluster. If hShNXFXF∩>∩, the calls in Xh will be considered SPIT calls; else, they will be considered non-SPIT calls.   4.5 Efficient MPCK-Means  In the cluster assignment step of MPCK-Means (Step 2.1) the time complexity on iterating through the must-link/cannot-link peers of point xi is a O(N) operation. X is the whole set of data points supplied to the clustering algorithm. N=|X| is the number of data points. The determination of the maximally separated points 'hxand''hxused in fc(.) (Step 2.1 of Algorithm 1) and update_metrics (Step 2.3) has time complexity O(N2). This implies MPCK-Means is O(N3) since the operation has to be done for each data point (actually O(cN3) where c is a small fixed number of iterations till convergence). Thus, MPCK-Means does not scale well with large data sets. For our application, where N can be hundreds for a small-sized domain or thousands for a mid-sized domain, it turns out to be prohibitive time-wise to apply the original MPCK-Means directly. Therefore, we adapt MPCK-Means into the eMPCK-Means (efficient MPCK-Means) algorithm (Algorithm 2). In it, the maximally separated points are estimated through an O(1) approximation algorithm. We use an O(N) 978-1-4244-4421-2/09/$25.00 c(cid:13)2009 IEEE