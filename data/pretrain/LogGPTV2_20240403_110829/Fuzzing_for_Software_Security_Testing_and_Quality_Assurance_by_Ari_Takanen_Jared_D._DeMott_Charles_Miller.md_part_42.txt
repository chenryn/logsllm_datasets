therefore every vendor should commit to following best practices on quality assur-
ance in order to eliminate as much of the vulnerabilities as possible.
Designing ICS security should consider all external systems interfacing the
ICS network components. This requires a holistic approach where certification,
segmentation, data diodes, and other good security practices play an essential role.
Sharing network devices should not be done without having clear knowledge on the
implications sharing has for updating the devices. The core ICS network compo-
nent security should be handled with the same formality as with devices related to
safety systems. This means certification and more thorough testing. After all, the
ICS core should be the most dependable part of the process.
9.6 Black-Box Fuzzing for Security researchers
Finally, we conclude this book with an example of auditing a black-box application.
This may occur as part of a formal audit at the end of the software development
cycle, as an engagement by a security consultant, or by a security researcher looking
at a released product. In the first two cases, it is obvious which system is the target.
In the latter case, there is much discretion in choosing the target.
9.6.1 Select Target
For software developers and testers, there is usually not a chance to choose the tar-
get. You must simply test the system you are developing. Likewise, security auditors
are required to test the system given to them for review. The only exception is when
there are a number of systems that need testing, and it becomes important to pick
which one should be tested first or which one requires the most time for examin-
ing. In this case, such a decision needs to be based on factors such as risk, whether
some applications are more exposed than others and how well each product was
developed, for example.
For the security researcher, target selection is very important. If you choose a
target that is very secure and well written, say Apache, it is likely you won’t find
any bugs. If you choose a product that is too obscure, like Tom’s Mail Server, no
one will care if you find any bugs. It’s best to choose something in between. Other
good strategies include choosing products that have not been fuzzed or those with
a recent track record of problems. Examples of the former include SNMP imple-
mentations in 2002 and web browsers in 2006.21,22 We choose the latter path and
examine Apple’s QuickTime media player due to its history of vulnerabilities. In
fact, in 2007, there were over 34 security holes in this product alone.23
21 http://xforce.iss.net/xforce/alerts/id/advise110.
22 www.news.com/Security-expert-dubs-July-the-Month-of-browser-bugs/2100-1002_3-6090959.
html.
23 www.securityfocus.com/brief/645.
6760 Book.indb 300 12/22/17 10:50 AM
9.6 Black-Box Fuzzing for Security Researchers 301
9.6.2 Enumerate Interfaces
Normally, when a system is about to be fuzzed, it is important to determine all the
ways data can be passed to the target. For local applications, this might include com-
mand line arguments, environment variables and files consumed, for example. For
network devices, this might vary from low level packets such as Ethernet packets,
up to the TCP/IP stack, and then any administrative applications such as web serv-
ers on the device. It is important to identify all possible protocols/formats that the
system understands. This might be network protocols or file formats. For example,
a web browser can speak many different protocols including HTTP, FTP, HTTPS,
RTSP, and so on, as well as parse many different image formats.
In our target of QuickTime, we need to know which formats QuickTime sup-
ports. The Apple website lists many formats supported by QuickTime. However,
it is often best to ignore such documentation and go straight to the source. There
is a program for Mac OS X called RCDefaultApp that specifies which formats are
associated with which applications.24 Using this application, a wide variety of for-
mats are found, including
• 3g2;
• aac;
• amc;
• avi;
• caf;
• rtsp.
QuickTime Player supports almost 50 different file extensions. This is one rea-
son it has had so many bugs—it has a very large feature set. At this point it is just
a matter of choosing a protocol and beginning to fuzz. For this fuzzing session, we
chose the Audio Video Interleave (AVI) format.
9.6.3 Choose Fuzzer/Fuzzer Type
Choosing the fuzzer and fuzzer type is sometimes a difficult decision. It usually
boils down to how badly you want to find bugs versus how much time, energy,
and/or money you wish to spend. As we demonstrated in the last chapter, the most
effective method for finding bugs is probably to use a combination of different fuzz-
ers. However, in real life, this is not always feasible. Normally, product shipment
deadlines and other projects force us to choose one fuzzer and may even limit the
amount of time fuzzing can be performed with the single fuzzer.
For this case study, like most security researchers, we have no budget, so com-
mercial tools are out of the question. Therefore, our choice is between an open-
source mutation-based or generational-based fuzzer. We don’t have a lot of time,
and as we’ll see, attacking QuickTime Player with a generational-based fuzzer
is a little like attacking an ant with a sledgehammer, so we’ll go with the easier
24 http://rubicode.com/Software/RCDefaultApp
6760 Book.indb 301 12/22/17 10:50 AM
302 Fuzzing Case Studies
mutation-based approach. We could use something like FileFuzz or the PaiMei file
fuzzer, but we choose to reinvent the wheel. The following simple C program is
used for our fuzzing.25
#include 
#include 
#include 
#define NUM_FILES 8192
#define SIZE 6250577
int main(void)
{
FILE *in, *out, *lout;
unsigned int n, i, j;
char *buf = malloc(SIZE);
char *backup = malloc(SIZE);
char outfile[1024];
int rn, rn2, rn3, rn4;
int rbyte;
int numwrites;
in = fopen(“good.avi”, “r”);
n = read(fileno(in), buf, SIZE);
memcpy(backup, buf, n);
lout=fopen(“list”, “w”);
srand(time(NULL));
for (i=0;i: movzx eax,BYTE PTR [edx]
Closer inspection shows this is within a loop, and eventually edx goes beyond
mapped memory. It appears to be an overflow in the source buffer of a copy. It is
unclear whether this condition is exploitable without more investigation.
9.7 Summary
To conclude the book, in this chapter we went through different use cases with
fuzzing. The purpose of this chapter was not to give a thorough walk-through of
fuzzing in any of these use cases, but to enable you to see the technique in use in
different environments.
Deployment of fuzzing is often technology oriented. We do not want to down-
play that approach, because we definitely know that fuzzing is cool and exciting.
If you get your hands on a fuzzing framework such as a Sulley or Peach, you will
definitely have fun for months and months. The outcome is not necessarily what
you might have hoped for, though. You might catch a flaw here and another there,
but what about the bugs you left behind? The deployment of fuzzing should start
from real need.
In any enterprise space, your CIO will most probably have regular nightmares
on some peculiar threat-scenarios that you could go and eliminate with fuzzing. An
enterprise network is loaded with various network applications and services that are
open to the hostile internet, and all of those are good targets for fuzzing. Any CIO
will immediately understand the value of proactive fuzzing and most often would
look forward to outsourcing fuzzing to a consultant who has experience in the field.
Fuzzing in the carrier and ISP space is a bit different. Whereas in the enterprise
environment you very rarely have the luxury of dedicated test networks, the service
6760 Book.indb 305 12/22/17 10:50 AM
306 Fuzzing Case Studies
providers are well prepared to schedule test-time for fuzzing. Also, because the
worst attack to a service provider is a Denial of Service, you will not have to waste
weeks and weeks explaining what a buffer overflow is. They do not care. Actu-
ally, an attack with a malicious payload would just downplay the vulnerability, as
down-time is much more expensive for them.
Software developers are the most challenging users of fuzzing. The QA people
will only very slowly change their mentality from feature testing into seemingly
ad-lib negative testing, for which you could classify fuzzing. But, slowly, all the
major software-developing companies have seen the light, and hopefully smaller
organizations will follow behind. Acquisitions of some selected web fuzzer compa-
nies by both HP and IBM in 2007 could show that at least the web fuzzing market
is becoming more mature.
Network manufacturers, on the other hand, are driven by requirements set
by the service providers and have been quick to react to fuzzing needs. Again, the
fuzzing deployment has started from the biggest players in the market, all of which
do fuzzing of some sort. Security product vendors have also been quick to follow,
and the development of most security devices already utilizes fuzzing quite early in
the development process.
Next, we discussed fuzzing with SCADA fuzzing. Industrial automation is just
one of the examples of how software has penetrated the national critical infra-
structure, and fuzzing in that space can really be a life saver. Next time when you
read an article about a power blackout, think about SCADA fuzzing for a second.
The same fuzzing concepts that are used in the industry data busses apply for any
traditional industries such as the automobile or airline industries.
Finally, we took a look at fuzzing from the security researcher’s perspective.
This approach is different from the other ones because it is conducted in a black-box
setting since the source code is not available. We stepped though an entire fuzzing
session from target selection through reporting the vulnerabilities. It showed very
plainly just how effective even simple mutation-based fuzzing can be.
Without fuzzing, we will forever stay in the hamster-wheel of patch-and-pen-
etrate, reading about the latest vulnerabilities and crashing electric systems in the
headlines of our morning papers. With that thought, please keep an open mind
and review your own work and the work of your colleagues and see where fuzzing
fits for you and your organization. Please do not hesitate to email us your stories
from the trenches. Our foremost motivation in writing this book was to help you,
the reader, but in order to do that and to keep improving the book, we need your
feedback on what to improve.
6760 Book.indb 306 12/22/17 10:50 AM
About the Authors
Ari Takanen is an investor and startup advisor at the Kielo Growth business incu-
bator company. Ari was a cofounder of Codenomicon, a fuzzing company acquired
by Synopsys. Before that, he was a lecturer and researcher of software quality assur-
ance related topics at University of Oulu, Finland. He is also a noted speaker and
author on software testing and security.
Jared DeMott is an information security expert. He is the founder of the security
company VDA Labs, and previously served as a vulnerability analyst with the NSA.
He holds a Ph.D. from Michigan State University. He regularly speaks on vulner-
abilities at conferences such as RSA, DerbyCon, BlackHat, ToorCon, GrrCon, and
HITB. He was a finalist in Microsoft’s BlueHat prize contest, which helped make
Microsoft customers more secure. Dr. DeMott has been on three winning Defcon