observed overﬂow.
3.3 Analysis Modules
In this subsection, we expand on our methodology from Sub-
sections 3.1 and 3.2 to describe how serious and prevalent
classes of vulnerabilities can be analyzed using ARCUS.
Each class has a reﬁned analysis strategy and deﬁnition of
root cause based on our domain expertise. In our prototype,
each technique is implemented as a pluggable module, sum-
marized in Table 1. Each module description concludes with
a list of contents generated by ARCUS in its reports.
Stack & Heap Overﬂow. The stack and heap overﬂow
module focuses on analyzing control ﬂow hijacking (re-
call that data-only attacks are out of scope, Subsection 2.2),
which requires the adversary to gain control over the program
1992    30th USENIX Security Symposium
USENIX Association
 1. int openhost(const char *hname, ...) { 2.   char *cp; 3.   char name[256]; 4. 5.   cp = hname; 6.   if (*cp == '[') { 7.     cp++; 8.     for (i = 0; *cp && *cp != ']'; cp++, i++) 9.       name[i] = *cp;10.       if (*cp == ']') {11.         name[i] = '\0';12.         hname = name;13.       } else return 0;14.   /* [...] */hname := ['[','A',...,']']hname   := [s1,s2,...]name    := []cp      := {}ret_ptr := {c1}hname   := ['[',s2,...]name    := []cp      := hname+0ret_ptr := {c1}hname   := ['[',s2,...]name    := [s2]cp      := hname+1ret_ptr := {c1}hname   := ['[',s2,...]name    := [s2,s3]cp      := hname+311ret_ptr := {s258}hname   := ['[',s2,...,']']name    := [s2,s3,...]cp      := hname+312ret_ptr := {s258}hname   := ['[',s2,...,']']name    := [s2,s3,...,]cp      := hname+257ret_ptr := {c1}PT: TakenPT: Taken  x312SnapshotPT TraceSymbolic States..."what if"contradictsTable 1: ARCUS Modules Summary
Locating Strategy
Symbolic PC
Symbolic PC
Root Cause
Module
Control Dep.
Stack Overﬂow
Heap Overﬂow
Control Dep.
Integer Overﬂow Overﬂowed Reg/Mem Overﬂow Site
Control Dep.
UAF
Control Dep.
Double Free
Format String
Data Dep.
R/W Freed Address
Track Frees
Symbolic Arguments
counter. As ARCUS reconstructs all the intermediate states
along the executed path, the module checks whether the pro-
gram counter has become symbolic. If it has, this means data
from outside the program can exert direct control over which
code the program executes, which is indicative of control
hijacking.
From this point, the module looks at the previous state to
determine what caused symbolic data to enter the program
counter. Since hijacking can only occur at indirect control
ﬂow transfers, this previous state must have executed a basic
block ending in a return, indirect call, or indirect jump. The
steps we deﬁne for root cause analysis are: 1) identify the
code pointer that became symbolic, 2) identify the basic block
that wrote it, 3) ﬁnd basic blocks that control the execution of
the write block, and 4) test whether additional constraints at
these blocks could have diverted the program away from the
buggy behavior (i.e., by introducing a constraint that would
contradict the buggy state).
To accomplish the ﬁrst task, the module uses backward
tainting over the previously executed basic block, lifted into an
intermediate representation (IR), to identify the registers and
then the memory address used to calculate the code pointer.
The implementation details are in the Subsection 3.7. Once
identiﬁed, the module iterates backwards through the pre-
viously reconstructed states to ﬁnd the one where the data
contained at the identiﬁed address changes, which reveals the
state that corrupted the pointer. We coin this the blame state.
The next step is to identify the basic blocks that control it,
which we refer to as guardians. The module uses forward
analysis over the reconstructed states to generate a control de-
pendency graph (CDG) and ﬁnd them.7 If there are guardians
for the blame state, the closest one is picked in terms of short-
est path, and the prior state to execute this code is revisited to
see if there exists another branch whose constraints contradict
the blame state (solving the “what if” question from Sub-
section 3.2). If contradicting constraints are found, ARCUS
recommends enforcing them at the guardian. Otherwise, only
the blame state is reported because an entirely new guardian
is required.
For heap overﬂows, ARCUS needs to ensure that the heap
objects are allocated exactly as they were in the ﬂagged exe-
cution, which requires careful designing. We elaborate on the
details in Subsection 3.5.
7These graph algorithms are readily available in projects like angr.
Figure 4: CVE-2006-2025. Attacker controls the TIFF image
and thus tdir_count, which can be used to overﬂow cc.
ARCUS automatically ﬁnds a new constraint to prevent it.
Report: Blame state and, if found, the guardian to modify
and new constraints to enforce.
Integer Overﬂow & Underﬂow. The two key challenges
with detecting integer overﬂows and underﬂows (referred to
collectively as overﬂows for brevity) are: 1) inferring the
signedness of register and memory values in the absence of
type info and 2) avoiding false positives due to intentional
overﬂowing by developers and compilers.
To conservatively infer signedness, the module uses hints
provided by instruction semantics (e.g., zero vs. signed ex-
tending [56]), and type info for arguments to known standard
library functions (“type-sinking” [57]). If the signedness is
still ambiguous for an operand, the arithmetic operation is
skipped to err on the side of false negatives.
If an operation can overﬂow, according to the accumulated
data constraints, the result register is ﬂagged and subsequent
stores and loads are tracked by the module. However, this
is not immediately reported as a bug because the overﬂow
may be intentional (second challenge).
Instead, a bug is
only reported if ﬂagged data is passed to another function
(i.e., following a call or ret instruction). The intuition
is that when data crosses a function boundary, it is likely
that the receiver did not consider the possibility of receiving
overﬂowed integers, leading to violated assumptions and bugs.
Prior work has measured this phenomenon [58].
Figure 4 illustrates how the module handles CVE-2006-
2025, showing source code for clarity. In this case, an adver-
sary can craft a TIFF image to overﬂow the register holding
cc (deﬁned at line 3) and pass it to ReadOK at line 7. Since cc
is the product of two unsigned values, cc tdir_type);3.   tsize_t cc = dir->tdir_count * w;4.5.   if (!isMapped(tif)) {6.     /* [...] */7.     if (!ReadOK(tif, cp, cc))8.       goto bad;9.   /* [...] */tdir_count := {s1}w          := {0,1,2,4,8}cc         := {}tdir_count := {s1}w          := {0,1,2,4,8}cc         := {0,...,232-1}cc < w * tdir_counttdir_count := {0,...,536870911}w          := {0,1,2,4,8}cc         := {0,...,232-1}not(cc < w * tdir_count)"what if"that passed cc to ReadOK.
Report: Basic block and IR statement that overﬂowed
the variable, recommended constraints, and basic block that
passed the overﬂowed variable to another function.
Use After Free & Double Free. The UAF and DF modules
monitor all calls to allocation and free functions, which we
assume to know the semantics of in advance. When an allo-
cation call is reached, the size argument is extracted and the
returned pointer is evaluated to a concrete value to maintain
a list of currently allocated buffers. When a free is reached,
the corresponding entry is moved from the allocation list to
a freed buffers list. Subsequent allocations can move freed
entries back to the allocation list, maintaining mutually ex-
clusive sets. For each state, addresses accessed by memory
operations are checked against the freed list to detect the oc-
currence of UAF, upon which the module reports the starting
address, size, and accessed offset. Similarly, the DF module
detects freeing of entries already in the freed list. A CDG
from the free site to the violating block determines and reports
negligent guardians.
Report: Address, size, and offset (if applicable) of the
violated buffer. The freeing and violating basic blocks, along
with a partial CDG for the path between them.
Format String. Programming best-practice is to always
create format strings as constant values in read-only mem-
ory. Unfortunately, buggy programs still exist that allow an
attacker to control a format string and achieve arbitrary reads
or writes. As the analysis reconstructs program states, this
module checks for states entering known format string func-
tions (e.g., printf) and veriﬁes that: 1) the pointer to the
format string is concrete, as it should be if it resides in read-
only memory, 2) the string’s contents are completely concrete,
and 3) all the additional arguments point to mapped memory
addresses. If any of these criteria are violated, the module
knows data from outside the program can directly inﬂuence
the format string function, which is a vulnerability.
Once located, the module locates the violating symbolic
data in memory and examines prior states to ﬁnd the one
that wrote it. This is the blame state for this category of
vulnerability. Since format strings should not be writable in
the ﬁrst place, no further analysis is necessary.
Report: Contents of the symbolic string, the basic block
that wrote it, and where it was passed to a format function.
3.4 Capturing the Executed Path
Analyzing the execution ﬂagged by an end-host runtime mon-
itor, which may reside in a different system, requires an efﬁ-
cient way of tracing the program without relying on instrumen-
tation or binary modiﬁcations that could degrade performance
or be targeted by the attacker. Our solution is to employ a
kernel module to manage PT. For simplicity, we will focus on
Figure 5: Using the trace (left), with snapshot and PT packets,
to recover the executed sequence of instructions (right).
Intel PT, but other modern processors come with their own
hardware implementations.
A trace captures the sequence of instructions executed by
the CPU, which is large given that modern processors execute
millions of instructions per second. To be efﬁcient, Intel PT
assumes that the auditor knows the memory layout of the
audited program, which our kernel module prepends to the
trace as a snapshot, shown on the left side of Figure 5 as
grey packets. The kernel module also captures and inserts
dynamically generated code pages between PT data, allow-
ing complex behaviors to be followed (e.g., JIT). With this,
all the auditor needs from the PT hardware is which path to
follow when a branch is encountered, shown on the left in
blue. For conditional branches, a single taken-not-taken bit
is recorded. For indirect control ﬂow transfers (return, indi-
rect call, and indirect jump) and asynchronous events (e.g.,
interrupts, exceptions), the destination is recorded.
Intel PT is conﬁgured using model speciﬁc registers
(MSRs) that can only be written and read while the CPU
is in privileged mode. Since only the kernel executes in this
mode, only it can conﬁgure Intel PT. The trace is written
directly into memory at physical addresses speciﬁed during
conﬁguration, meaning the kernel can make this data inac-
cessible to all other processes. Intel PT bypasses all caches
and memory translation, which minimizes its impact on the
traced program. When the buffer allocated for tracing is ﬁlled,
the CPU raises a non-maskable interrupt (NMI), which the
kernel module handles immediately so no data is lost.
Challenges with PT & Symbolic Execution.
Intel PT tries
to be as efﬁcient as possible in recording the executed control
ﬂow. As a result, only instructions that produce branching
paths yield trace packets, which excludes instructions for re-
1994    30th USENIX Security Symposium
USENIX Association
0x27ab push %rbp0x284e jmp 0x2898…0x2850 mov $1 %esi…0x287e test %rax %rax0x2881 jne 0x28940x2883 lea 0xf05f %rdi…0x288f call %rax…0x2898 cmp $0x19 %rax0x289c jle 0x28500xfeff push %rbp…TNTTIPSnapshot0x2000-0x3000TNTTIP 0xfeffSnapshot0xf000-0xffffTraceDisassemblerSTARTTable 2: Symbolically Executing CISC Repeat Instructions
Common Usage
String Copy
Type
rep movs
rep stos Memory Initialization
rep cmps
rep scas
String Search (presence)
String Search (offset)
Strategy
Maximize Iterations
Maximize Iterations
Symbolize Register
Symbolize Register
peat string operations — used to speed up common tasks. For
example, rep mov sequentially copies bytes from one mem-
ory location to another until a condition is met and repnz
scas can be used as a replacement for strlen. These instruc-
tions encode an entire traditional loop into a single statement.
When memory is concrete, these complex instructions are
deterministic, so Intel PT does not record how many times
they “repeat.” This creates a problem for symbolic execution
because if these instructions encounter symbolic data in mem-
ory or registers, the state will split and the trace will not have
information on which successor to follow.
Our solution is to take the path that will most likely lead
to a vulnerability, which depends on the type of repeat in-
struction, shown in Table 2. Three repeat types are excluded
(ins, outs and lods) because they are typically used by ker-
nel drivers and not user space programs. For move (movs)
and store (stos), the analysis follows the maximum possible
iterations given the symbolic constraints to check for over-
ﬂow bugs. For comparison (cmps) and scanning (scas), the
analysis skips to the next instruction (i.e., it executes zero iter-
ations) and symbolizes the results register. The constraints for
this register depend on the instruction. For example, repnz
scasb in 64-bit mode scans memory, decreasing RCX by 1 for
each scanned byte, until either RCX becomes 0 or the value
stored in AL is encountered. The analysis therefore constrains
RCX to be between 0 and its starting value.
3.5 Snapshots & Memory Consistency
Symbolic execution requires an initial memory state to start
its analysis from, which can be created with a custom loader
or from a snapshot. The distinction is usually minor, but
ends up being vital for ARCUS because it has to follow the
path recorded by PT, as opposed to generally exploring the
program. We discover that snapshots are essential to AR-
CUS because native loaders have complicated undocumented
behaviors that the custom loaders are likely to contradict,
creating inconsistencies in memory.
One such discrepancy is in how they resolve weak symbols,
which can be resolved to one of several possible locations
depending on the execution environment. For example, libc
contains a weak symbol for memcpy, which is resolved to
point at the most efﬁcient implementation for the processor
model. By our count, out of the 2,211 function symbols in
glibc version 2.28, 30% are weak symbols. Additionally,
shared objects can choose to implement their own resolver
functions, invoked by the loader, to decide values.8
Our solution is for the kernel module to save a concrete
snapshot of the program’s user space at its entry point — af-
ter the initial dynamic loading is complete — and whenever
a new thread or process is created. This captures the en-
vironment variables, command line arguments, and current
program break pointer, the latter of which is important for
heap placement.
Allocation Consistency. Analyzing attacks requires spe-
cial care with replicating the spacing and absolute position of
dynamically allocated buffers. Inconsistencies could cause
overﬂows between objects or exploited writes to not be repro-
ducible in the analysis.
The solution is to capture the program break (brk) pointer
in the snapshot, which marks the end of the program’s data
segment. When functions like malloc do not have enough
space to allocate a new buffer, they make a system call to
move the break. Consequently, all dynamically allocated
objects are placed relative to the starting position of the break.
Therefore, by starting with the same break and following the
trace, ARCUS can ensure a consistent layout.
3.6 Performance Constraints
We prioritize performance in our design, but acknowledge that
storage is also a concern for long running programs, to which
we create two policies. For task-oriented workers, snapshots
are taken as the kernel creates them and the oldest snapshots
are discarded if a user deﬁned threshold is exceeded. If a long
living thread exceeds the threshold, a snapshot is retaken and
the oldest data is discarded. This introduces potential false
negatives due to truncation, but we demonstrate useful results
with practical thresholds in Section 4 and leave improvements
to future work.
Since the analysis is performed ofﬂine only after an alarm
is raised, we relax the performance requirements of the anal-
ysis system. Our evaluation shows real vulnerabilities are
analyzed in minutes, which is sufﬁcient for practical use.
3.7 Vex IR Tainting
Algorithm 1 shows how we perform backwards tainting on
VEX IR lifted from binary code to identify the registers and
memory addresses used to calculate a chosen temporary vari-
able. We start by tainting the chosen variable and iterate back-
wards over the prior statements. Any registers used to store
tainted variables (Put) become tainted. Whenever tainted
variables are assigned a value (WrTmp), any registers, memory
addresses, or additional variables used to produce the value
(i.e., operands) also become tainted. EvalTmp uses the sym-
bolic execution engine to resolve memory address pointers.
8Example: https://sourceware.org/glibc/wiki/GNU_IFUNC.
USENIX Association
30th USENIX Security Symposium    1995
Input: VEX IR statements S starting from last executed.
Tmp n to taint initially.
Result: Addresses A and registers R used to calculate n.
A ← /0
R ← /0
T ← {n}
foreach s in S do
if Type(s) is Put and Type(s.data) is RdTmp then
if s.data.tmp ∈ T then
R ← R∪{s.register}
end
end
if Type(s) is WrTmp and s.tmp ∈ T then
foreach a in s.data.args do
if Type(a) is Get then
R ← R∪{a.register}
end
if Type(a) is RdTmp then
T ← T ∪{a.tmp}
end
if Type(a) is Load then
A ← A∪ EvalTmp(a.address)
end
end
end
end
Algorithm 1: Tainting algorithm to obtain the registers and
addresses used to calculate a VEX IR temporary variable.
To taint multiple basic blocks, we clear T between blocks
while persisting A and R.
4 Evaluation
We aim to answer the following questions in our evaluation:
1. Is ARCUS accurate at detecting bugs within our covered
classes? We perform several micro-benchmarks with
a ground truth set of over 9,000 test cases from the
RIPE [59] and Juliet [60] suites. This ground truth
allows us to verify that ARCUS can ﬁnd root causes
for vulnerabilities with 0 false positives and negatives
(Subsection 4.1).
2. Can ARCUS locate and analyse real-world exploits?