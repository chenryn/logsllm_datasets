        if (ret > 0 && ppos)
            *ppos = kiocb.ki_pos;
        return ret;
    }
`call_write_iter()` 是一个内联函数：
    static inline ssize_t call_write_iter(struct file *file, struct kiocb *kio,
                          struct iov_iter *iter)
    {
        return file->f_op->write_iter(kio, iter);
    }
其它系统调用类似，不再赘述。总之，从 pipe 中读取数据时，最终调用的是 `pipe_read()` 函数；向 pipe 中写入数据时，最终调用的是
`pipe_write()` 函数。
#####  pipe_write()
先来看 `pipe_write()` 函数的主要流程：
  * 如果 pipe 读者的数量为 0，则向进程发送 `SIGPIPE` 信号，并返回 `EPIPE` 错误。
  * 计算要写入的数据总大小是否是页帧大小的倍数，并将余数保存在 `chars` 变量中。
  * 如果 `chars` 不为零，而且 pipe 不为空，则： 
    * 获取 pipe 头部的缓冲区。
    * 如果缓冲区设置了标志位 `PIPE_BUF_FLAG_CAN_MERGE`，且缓冲区中已有的数据长度与 `chars` 的和不超过一个页帧的大小，则将 `chars` 长度的数据写入到当前的缓冲区中。
    * 如果剩余要写入的数据大小为零，则直接返回。
  * 在 for 循环中： 
    * 判断 pipe 的读者数量是否为零。
    * 如果 pipe 没有被填满： 
      * 获取 pipe 头部的缓冲区。
      * 如果还没有为缓冲区分配页帧，则调用 `alloc_page()` 函数分配一个。
      * 使用自旋锁锁住 pipe 的读者等待队列。再次检测 pipe 是否被填满，是则终止当前循环，执行下一次循环。
      * 将 `struct pipe_inode_info` 实例的 `head` 字段值增加 1。并释放自旋锁。
      * 设置当前缓冲区的字段。
      * 如果创建 pipe 时指定了 `O_DIRECT` 选项，则将缓冲区的 `flags` 字段设置为 `PIPE_BUF_FLAG_PACKET`，否则设置为 `PIPE_BUF_FLAG_CAN_MERGE`。
      * 将要写入的数据拷贝到当前的缓冲区中，并设置相应的偏移量字段。
####  splice 系统调用
`splice()` 系统调用避免在内核地址空间与用户地址空间的拷贝，从而快速地在两个文件描述符之间传递数据。函数原型为：
    #define _GNU_SOURCE
    #include 
    ssize_t splice(int fd_in, off64_t *off_in, int fd_out, off64_t *off_out, size_t len, unsigned int flags);
此次漏洞使用的情况是从文件向管道传递数据，因此 `fd_in` 指代一个普通文件，`off_in` 表示从指定的文件偏移处开始读取，`fd_out`
指代一个 pipe，`len` 表示要传输的数据长度，`flags` 表示标志位。详细情况可以参考手册。
看看 `splice()` 系统调用的主要流程。系统调用的定义在 `fs/splice.c` 文件中，主要工作由 `__do_splice()` 函数完成。
`__do_splice()` 在做完简单的参数检查之后，又调用 `do_splice()` 函数实现主要工作。
`do_splice()` 中，会根据两个文件描述符的类型进入不同的分支。当前情况下，`fd_out` 指代一个 pipe，因此会进入 `if
(opipe)` 这个分支。主要工作通过 `do_splice_to()` 函数完成。
    /*
     * Determine where to splice to/from.
     */
    long do_splice(struct file *in, loff_t *off_in, struct file *out,
               loff_t *off_out, size_t len, unsigned int flags)
    {
        struct pipe_inode_info *ipipe;
        struct pipe_inode_info *opipe;
        loff_t offset;
        long ret;
      // 判断两个文件描述符的打开模式是否符合条件
        if (unlikely(!(in->f_mode & FMODE_READ) ||
                 !(out->f_mode & FMODE_WRITE)))
            return -EBADF;
        ipipe = get_pipe_info(in, true);
        opipe = get_pipe_info(out, true);
      // 当 in 和 out 都是 pipe 的情况
        if (ipipe && opipe) {
            if (off_in || off_out)
                return -ESPIPE;
            /* Splicing to self would be fun, but... */
            if (ipipe == opipe)
                return -EINVAL;
            if ((in->f_flags | out->f_flags) & O_NONBLOCK)
                flags |= SPLICE_F_NONBLOCK;
            return splice_pipe_to_pipe(ipipe, opipe, len, flags);
        }
      // 当 in 是 pipe 的情况
        if (ipipe) {
          ......
        }
      // 当 out 是 pipe 的情况
        if (opipe) {
        // 不能为 pipe 设置偏移量
            if (off_out)
                return -ESPIPE;
            if (off_in) {
                if (!(in->f_mode & FMODE_PREAD))
                    return -EINVAL;
                offset = *off_in;
            } else {
                offset = in->f_pos;
            }
            if (out->f_flags & O_NONBLOCK)
                flags |= SPLICE_F_NONBLOCK;
        // 获取 pipe 的锁
            pipe_lock(opipe);
        // 等待 pipe 有可使用的缓冲区
            ret = wait_for_space(opipe, flags);
            if (!ret) {
                unsigned int p_space;
          // 计算能够读取的文件长度，不应该超过 pipe 剩余的缓冲区大小
                /* Don't try to read more the pipe has space for. */
                p_space = opipe->max_usage - pipe_occupancy(opipe->head, opipe->tail);
                len = min_t(size_t, len, p_space  0)
          // 唤醒 pipe 的读者等待队列中的进程
                wakeup_pipe_readers(opipe);
            if (!off_in)
                in->f_pos = offset;
            else
                *off_in = offset;
            return ret;
        }
        return -EINVAL;
    }
#####  do_splice_to()
在 `do_splice_to()` 中，主要功能是通过输入文件的 `splice_read()` 方法实现的。这里以 `ext4` 文件系统为例，在
`fs/ext4/file.c` 文件中查看 `ext4_file_operations` 变量可知，`ext4` 文件系统中，`splice_read`
使用的是定义在 `fs/splice.c` 中的 `generic_file_splice_read()` 方法。接着通过调试可知接下来的函数调用链：
    generic_file_splice_read() -> call_read_iter() -> generic_file_buffered_read() -> copy_page_to_iter() -> copy_page_to_iter_pipe()
`call_read_iter()` 是一个定义在 `include/linux/fs.h` 中的内联函数，实际调用的是输入文件的
`read_iter()` 方法。而 `ext4` 文件系统的 `read_iter()` 方法是
`ext4_file_read_iter()`。在当前情况下，会调用 `generic_file_rad_iter()`，其接着调用
`generic_file_buffered_read()`。
#####  copy_page_to_iter_pipe()
`generic_file_buffered_read()` 是通用的文件读取例程，将文件读取到 page cache 后会通过
`copy_page_to_iter()` 函数将文件对应的 page cache 与 pipe 的缓冲区关联起来。实际的关联操作通过定义在
`/lib/iov_iter.c` 中的 `copy_page_to_iter_pipe()` 实现：
    /*
     * page 是文件对应的内存页帧，pipe 实例被包裹在 struct iov_iter 实例中
    */
    static size_t copy_page_to_iter_pipe(struct page *page, size_t offset, size_t bytes,
                 struct iov_iter *i)
    {
        struct pipe_inode_info *pipe = i->pipe;
        struct pipe_buffer *buf;
        unsigned int p_tail = pipe->tail;
        unsigned int p_mask = pipe->ring_size - 1;
        unsigned int i_head = i->head;
        size_t off;
        if (unlikely(bytes > i->count))
            bytes = i->count;
        if (unlikely(!bytes))
            return 0;
        if (!sanity(i))
            return 0;
        off = i->iov_offset;
        buf = &pipe->bufs[i_head & p_mask];
        if (off) {
            if (offset == off && buf->page == page) {
                /* merge with the last one */
                buf->len += bytes;
                i->iov_offset += bytes;
                goto out;
            }
            i_head++;
            buf = &pipe->bufs[i_head & p_mask];
        }
        if (pipe_full(i_head, p_tail, pipe->max_usage))
            return 0;
        buf->ops = &page_cache_pipe_buf_ops;
      // 增加 page 实例的引用计数
        get_page(page);
      // 将 pipe 缓冲区的 page 指针指向文件的 page
        buf->page = page;
        buf->offset = offset;
        buf->len = bytes;
        pipe->head = i_head + 1;
        i->iov_offset = offset + bytes;
        i->head = i_head;
    out:
        i->count -= bytes;
        return bytes;
    }
###  漏洞复现
####  分析
如果了解了向 pipe 写入数据的过程，以及 `splice()` 系统调用从文件向 pipe
传输数据的过程，就不难理解漏洞的形成原因了。对照漏洞发现者提供的 PoC 来解释漏洞形成原因：
  * 首先创建一个 pipe。接着每次向 pipe 中写入一个页帧大小的数据。从 `pipe_write()` 可知，每次写入都不会进入 `if (chars && !was_empty)` 这个分支，因为写入数据的大小为页帧大小的整数倍时，`chars` 的值总为零。创建 pipe 的时候没有指定 `O_DIRECT` 标志，因此在 for 循环中会将每个 `pipe_buffer` 的标志位设置为 `PIPE_BUF_FLAG_CAN_MERGE`。
  * 接下来打开要覆写的文件，并通过 `splice()` 系统调用向 pipe 中写入一个字节。根据 `splice()` 的实现，将文件从硬盘读取到 page cache 后，会把文件对应的 page 与 `pipe_buffer` 的 `page` 字段关联起来，并且不会重置 `pipe_buffer` 的 `flags` 字段。也就是说，此时 `flags` 字段的值仍为 `PIPE_BUF_FLAG_CAN_MERGE`。
  * 最后向 pipe 中写入小于一个页帧大小的数据。进入 `pipe_write()` 之后，会进入 `if (chars && !was_empty)` 分支。由于在 `copy_page_to_iter_pipe()` 中，将文件的 page 与 `pipe_buffer` 的 `page` 字段关联之后，将 `pipe_inode_info` 实例的 `head` 值增加了 1，因此为了将小于一个页帧的数据写入到前一个 `pipe_buffer` 中， if 分支里获取 `pipe_buffer` 的时候将 `head` 值减 1，从而此时 `pipe_buffer` 的 page 指向的是文件的 page。
####  调试验证
首先创建一个要覆写的文件并用随机字符串填充：
然后在 GDB 中分别在 `pipe_write` 和 `copy_page_to_iter_pipe` 两个函数设置断点：
然后在 GDB 中使用 `continue` 命令让虚拟机继续运行，并执行 PoC 程序。然后会在 `pipe_write` 处停止。使用下面的 GDB
脚本可以看到，pipe 的所有 `pipe_buffer` 中的标志位都为零：
    set $index = 0
    while ($index ring_size)
      print pipe->bufs[$index++]->flags
    end
然后接着执行 15 次 `continue` 命令，在第 16 次向 pipe 中写入数据之前停止。再次查看所有 `pipe_buffer`
的标志位，发现都被置为了 `PIPE_BUF_FLAG_CAN_MERGE`：
当最后一次 `pipe_write` 执行完后，`pipe->head` 的值为 16。
接着执行 `continue` 命令，会在 `copy_page_to_iter_pipe` 处停下来。单步进入几步之后，先把 `pipe`
变量和文件对应的 page 实例的地址保存到变量中。
因为当前 `pipe->head` 的值是 16，而 `pipe->ring_size` 的值时默认的 16，因此第 395 行代码中取到的是第一个
`pipe_buffer`。
接下来将文件的 page 与 `pipe_buffer` 的 `page` 字段关联起来，并将 pipe 的 `head` 字段加一，即此时为 17。
接着 continue，会停在 `pipe_write` 处。接着单步执行，会进入触发漏洞的 if 分支。然后查看 `buf->page`
的值，和之前保存的文件的 page 的地址相同。继续之后，文件覆写成功：
####  低权限用户篡改没有写权限文件的验证
在上面的验证过程中，由于使用的是最简单的内核以及 busybox，因此使用 root 用户。为了验证低权限用户可以成功篡改没有写权限的文件，在此使用
`ArchLinux` 发行版，以 `5.10.69-1-lts` 内核版本作验证：
####  结论
经复现过程可知，漏洞利用方式相对简单，建议受影响的机器立即升级到官方最新版本。
###  参考资料
^1:   
^2:   
^3:   
^4:   
^5:   
^6:   
^7:   
^8:   
^9: 