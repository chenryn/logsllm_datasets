E2
E3
E4
E5
192.168.12.1 
192.168.10.45 
192.168.10.66 
192.168.12.46 
:
192.168.11.123 
Aa…Ab
Ac…Ad
Ag
Al
Am…An
Ao
Ae…Af
Ah…Ai
Aj…Ak
Figure 4: BotHunter Network Dialog Correlation Matrix
at least two forms of outbound bot dialog warnings (E3-
E5). To translate these requirements into a scoring al-
gorithm we employ a regression model to estimate di-
alog warning weights and a threshold value, and then
test our values against a corpus of malware infection
traces. We deﬁne an expectation table of predictor vari-
ables that match our conditions and apply a regression
model where the estimated regression coefﬁcients are the
desired weights shown in Table 2. For completeness,
the computed expectation table is provided in the project
website [1].
E1
E2 rulebase
E2 slade
E3
E4
E5
Coefﬁcients
0.09375
0.28125
0.09375
0.34375
0.34375
0.34375
Standard Error
0.100518632
0.075984943
0.075984943
0.075984943
0.075984943
0.075984943
Table 2: Initial Weighting
These coefﬁcients provide an approximate weighting
system to match the initial expectation table 6. We apply
these values to our expectation table data to establish a
threshold between bot and no-bot declaration. Figure 5
illustrates our results, where bot patterns are at X-axis
value 1, and non-bot patterns are at X-axis 0. Bot scores
are plotted vertically on the Y-axis. We observe that all
but one non-bot patterns score below 0.6, and all but 2
bot patterns score above 0.65. Next, we examine our
scoring model against a corpus of BotHunter IDS warn-
ing sets produced from successful bot and worm infec-
tions captured in the SRI honeynet between March and
April 2007. Figure 6 plots the actual bot scores produced
from these real bot infection traces. All observations pro-
duce BotHunter scores of 0.65 or greater.
When a dialog sequence is found to cross the thresh-
old for bot declaration, BotHunter produces a bot pro-
ﬁle. The bot proﬁle represents a full analysis of roles
6In our model, we deﬁne E1 scans and the E2 anomaly score (pro-
duced by Slade) as increasers to infection conﬁdence, such that our
model lowers their weight inﬂuence.
of the dialog participants, summarizes the dialog alarms
based on which dialog classes (E1-E5) the alarms map,
and computes the infection time interval. Figure 7 (right)
provides an example of a bot proﬁle produced by the
BotHunter correlation engine. The bot proﬁle begins
with an overall dialog anomaly score, followed by the IP
address of the infected target (the victim machine), infec-
tor list, and possible C&C server. Then it outputs the di-
alog observation time and reporting time. The raw alerts
speciﬁc to this dialog are listed in an organized (E1-E5)
way and provide some detailed information.
5 Evaluating Detection Performance
To evaluate BotHunter’s performance, we conducted sev-
eral controlled experiments as well as real world deploy-
ment evaluations. We begin this section with a discus-
sion of our detection performance while exposing BotH-
unter to infections from a wide variety of bot fami-
lies using in situ virtual network experiments. We then
discuss a larger set of true positive and false negative
results while deploying BotHunter to a live VMWare-
based high-interaction honeynet. This recent experi-
ment exposed BotHunter to 2,019 instances of Windows
XP and Windows 2000 direct-exploit malware infections
from the Internet. We follow these controlled experi-
ments with a brief discussion of an example detection
experience using BotHunter during a live operational de-
ployment.
Next, we discuss our broader testing experiences in
two network environments. Here, our focus is on un-
derstanding BotHunter’s daily false positive (FP) perfor-
mance, at least in the context of two signiﬁcantly dif-
ferent operational environments. A false positive in this
context refers to the generation of a bot proﬁle in re-
sponse to a non-infection trafﬁc ﬂow, not to the number
of IDS dialog warnings produced by the BotHunter sen-
sors. As stated previously, network administrators are
not expected to analyze individual IDS alarms. Indeed,
we anticipate external entities to regularly probe and at-
tack our networks, producing a regular ﬂow of dialog
warnings. Rather, we assert (and validate) that the dialog
combinations necessary to cause a bot detection should
USENIX Association
16th USENIX Security Symposium
175
Figure 5: Scoring Plot from Expectation Table
be rarely encountered in normal operations.
5.1 Experiments in an In situ Virtual Network
Our evaluation setup uses a virtual network environment
of three VMware guest systems. The ﬁrst is a Linux
machine with IRC server installed, which is used as the
C&C server, and the other two are Windows 2000 in-
stances. We infect one of the Windows instances and
wait for it to connect to our C&C server. Upon connec-
tion establishment, we instruct the bot to start scanning
and infecting neighboring hosts. We then await the in-
fection and IRC C&C channel join by the second Win-
dows instance. By monitoring the network activity of
the second victim, we capture the full infection dialog.
This methodology provides a useful means to measure
the false negative performance of BotHunter.
We collected 10 different bot variants from three of the
most well-known IRC-based bot families [20]: Agobot/
Gaobot/Phatbot, SDBot/RBot/UrBot/UrXBot, and the
mIRC-based GTbot. We then ran BotHunter in this vir-
tual network and limited its correlation focus on the vic-
tim machine (essentially we assume the HOMENET is
the victim’s IP). BotHunter successfully detected all bot
infections (and produced bot proﬁles for all).
We summarize our measurement results for this vir-
tual network infection experiment in Table 3. We use
Yes or No to indicate whether a certain dialog warning
is reported in the ﬁnal proﬁle. The two numbers within
brackets are the number of generated dialog warnings in
the whole virtual network and the number involving our
victim, respectively. For example, for Phatbot-rls, 2,834
dialog warnings are generated by E2[rb] ([rb] means
Snort rule base, [sl] means SLADE), but only 46 are rel-
evant to our bot infection victim. Observe that although
many warnings are generated by the sensors, only one
bot proﬁle is generated for this infection. This shows that
BotHunter can signiﬁcantly reduce the amount of infor-
mation a security administrator needs to analyze. In our
experiments almost all sensors worked as we expected.
We do not see E1 events for RBot because the RBot fam-
Figure 6: Scoring Plot: 2019 Real Bot Infections
ily does not provide any commands to trigger a vertical
scan for all infection vectors (such as the “scan.startall”
command provided by the Agobot/Phatbot family). The
bot master must indicate a speciﬁc infection vector and
port for each scan. We set our initial infection vector to
DCOM, and since this was successful the attacking host
did not attempt further exploits.
Note that two proﬁles are reported in the gt-with-dcom
case. In the ﬁrst proﬁle, only E2[rb],E2[sl] and E4 are
observed. In proﬁle 2, E4 and E5 are observed (which
is the case where we miss the initial infection periods).
Because this infection scenario is very slow and lasts
longer than our 4-minute correlation time window. Fur-
thermore, note that we do not have any detected E3 di-
alog warnings reported for this infection sequence. Re-
gardless, BotHunter successfully generates an infection
proﬁle. This demonstrates the utility of BotHunter’s
evidence-trail-based dialog correlation model. We also
reran this experiment with a 10-minute correlation time
window, upon which BotHunter also reported a single
infection proﬁle.
5.2 SRI Honeynet Experiments
Our experimental honeynet framework has three integral
components. The ﬁrst component Drone manager is a
software management component that is responsible for
keeping track of drone availability and forwarding pack-
ets to various VMware instances. The address of one of
the interfaces of this Intel Xeon 3 GHz dual core system
is set to be the static route for the unused /17 network.
The other interface is used for communicating with the
high-interaction honeynet. Packet forwarding is accom-
plished using network address translation. One impor-
tant requirements for this system is to keep track of in-
fected drone systems and to recycle uninfected systems.
Upon detecting a probable infection (outbound connec-
tions), we mark the drone as “tainted” to avoid reas-
signing that host to another source. Tainted drones are
saved for manual analysis or automatically reverted back
to previous clean snapshots after a ﬁxed timeout. One
176
16th USENIX Security Symposium
USENIX Association
agobot3-priv4
phat-alpha5
phatbot-rls
rbot0.6.6
rxbot7.5
rx-asn-2-re-workedv2
Rxbot-ak-0.7-Modded.by.Uncanny
sxtbot6.5
Urx-Special-Ed-UltrA-2005
gt-with-dcom-proﬁle1
gt-with-dcom-proﬁle2
gt-with-dcom-10min-proﬁle
Yes(2/2)
Yes(14/4)
Yes(11/3)
No(0)
No(0)
No(0)
No(0)
No(0)
No(0)
No(1/0)
No(1/0)
No(1/0)
Yes(5,785/5,721)
Yes(2,834/46)
E2[rb]
Yes(9/8)
Yes(2/1)
Yes(2/2)
Yes(4/3)
Yes(3/2)
Yes(3/2)
Yes(3/2)
Yes(5/3)
No(5/0)
Yes(5/3)
Table 3: Dialog Summary of Virtual Network Infections
E1
E2[sl]
Yes(6/6)
Yes(6/2)
Yes(6/2)
Yes(2/1)
Yes(2/2)
Yes(3/2)
Yes(3/2)
Yes(3/2)
Yes(3/2)
Yes(6/2)
No(6/0)
Yes(6/3)
E3
Yes(5)
Yes(3/3)
Yes(8/8)
Yes(2/2)
Yes(2/2)
Yes(2/2)
Yes(2/2)
Yes(2/2)
Yes(2/2)
No(0)
No(0)
No(0)
E4
Yes(38/8)
Yes(28/26)
Yes(69/20)
Yes(65/24)
Yes(70/27)
Yes(59/18)
Yes(73/26)
Yes(65/24)
Yes(68/22)
Yes(221/1)
Yes(221/44)
Yes(221/51)
E5
Yes(4/1)
Yes(4/2)
Yes(6/2)
Yes(2/1)
Yes(2/1)
Yes(2/1)
Yes(2/1)
Yes(2/1)
Yes(2/1)
No(4/0)
Yes(4/2)
Yes(4/2)
of the interesting observations during our study was that
most infection attempts did not succeed even on com-
pletely unpatched Windows 2000 and Windows XP sys-
tems. As a result, a surprisingly small number of VM
instances was sufﬁcient to monitor the sources contact-
ing the entire /17 network. The second component is the
high-interaction-honeynet system, which is hosted in a
high-performance Intel Xeon 3 GHz dual core, dual CPU
system with 8 GB of memory. For the experiments listed
in this paper, we typically ran the system with 9 Win-
XP instances, 14 Windows 2000 instances (with two dif-
ferent service pack levels), and 3 Linux FC3 instances.
The system was moderately utilized in this load. The ﬁ-
nal component is the DNS/DHCP server, which dynami-
cally assigns IP addresses to VMware instances and also
answers DNS queries from these hosts.
Over a 3-week period between March and April 2007,
we analyzed a total of 2,019 successful WinXP and
Win2K remote-exploit bot or worm infections. Each
malware infection instance succeeded in causing the hon-
eypot to initiate outbound communications related to the
infection. Through our analysis of these traces using
BotHunter sensor logs, we were able to very reliably ob-
serve the malware communications associated with the
remote-to-local network service infection and the mal-
ware binary acquisition (egg download).
In many in-
stances we also observed the infected honeypot proceed
to establish C&C communications and attempt to prop-
agate to other victims in our honeynet. Through some
of this experiment, our DNS service operated unreliably
and some C&C coordination events were not observed
due to DNS lookup failures.
Figure 7 illustrates a sample infection that was de-
tected using the SRI honeynet, and the corresponding
BotHunter proﬁle. W32/IRCBot-TO is a very recent (re-
leased January 19, 2007) network worm/bot that propa-
gates through open network shares and affects both Win-
dows 2000 and Windows XP systems [37]. The worm
uses the IPC share to connect to the SRVSVC pipe and