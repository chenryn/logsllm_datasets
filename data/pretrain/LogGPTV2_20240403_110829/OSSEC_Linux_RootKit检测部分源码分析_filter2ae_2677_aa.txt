# OSSEC Linux RootKit检测部分源码分析
##### 译文声明
本文是翻译文章
译文仅供参考，具体内容表达以及含义原文为准。
## 一、概述
本文简单介绍了开源的 HIDS 软件 OSSEC的安装和使用，并选择 OSSEC
软件的Linux下rootkit检测功能进行源码分析，讲了讲自己的想法与体会，希望与大家共同学习，不足之处希望大家批评指正。  
OSSEC 是开源的基于主机的入侵检测系统（HIDS），拥有日志分析、完整性检查、Windows 注册表监视、rootkit
检测、实时警报和主动响应等功能。OSSEC 可以在大多数操作系统上运行，包括 Linux、OpenBSD、FreeBSD、Mac OS X、Solaris
和 Windows。
其特点包括：  
1.主机监控  
OSSEC 通过文件完整性监控，日志监控，rootkit 检测和流程监控，全面监控企业资产系统活动的各个方面，对于安全管理提供了依据。  
2.安全告警  
当发生攻击时，OSSEC 会通过发送告警日志和邮件警报让系统管理员及时感知威胁，并在短时间内进行应急处理，最大程度的避免企业遭受损失。OSSEC 还可以通过
syslog 将告警信息导出到任何 SIEM 系统，譬如 OSSIM 进行关联安全分析。  
3.全平台支持  
最难能可贵的是，OSSEC 提供了全平台系统的支持，包括 Linux，Solaris，AIX，HP-UX，BSD，Windows，Mac 和 VMware
ESX，突破性的实现了主机入侵态势感知的全覆盖。  
4.功能扩展  
OSSEC 得到了第三方安全团队的支持，其中 Wazuh 就是基于 OSSEC开发的一个高级版本，在 OSSEC 的自身功能的基础上进行扩展和优化。
## 二、安装OSSEC
###  （一）整体架构
实验环境如上，各主机的作用如下：
###  （二）安装过程
本部分先安装 Server 和 Agent，数据库、ELK 日志存储等配置可放在后面。
**1.linux（本处以 centos 为例）安装 OSSEC SERVER**
**（1）初始化环境安装，分别安装编译库，以及数据库支持库**
# yum -y install make gcc
# yum -y install mysql-devel postgresql-devel
# yum -y install sqlite-devel
**（2）下载 OSSEC 安装包，并进行解压，进入安装目录**
依次执行如下命令，
    wget https://github.com/ossec/ossec-hids/archive/3.1.0.tar.gz
    mv 3.1.0.tar.gz ossec-hids-3.1.0.tar.gz
    tar xf ossec-hids-3.1.0.tar.gz# cd ossec-hids-3.1.0
**（3）运行配置安装选项脚本**
此处运行需要root权限
./install.sh
选项说明
server – 安装服务器端
/var/ossec – 选择安装目录，默认选项
y – 是否启用邮件告警，默认启用
y – 是否启用系统完整性检测模块 Syscheck 功能，默认启用
y – 是否启用后门检测模块 Rootcheck 功能，默认启用
y – 是否启用主动响应模块 active-response 功能，默认启用
n – 是否启用防火墙联动功能，默认启用，此处为关闭
n – 是否添加联动功能白名单，默认启用，此处为关闭
y – 是否接受远程主机发送的 syslog 日志，默认启用
备注
配置完安装脚本之后，按回车键就开始进行编译安装，如果需要改变 OSSEC 的配置,可以等安装完成后，编辑 ossec.conf 配置文件进行修改，并重启
ossec 进程使其生效。
**2.OSSEC-Linux Agent 安装**
**（1）初始化环境安装，安装编译库**
yum -y install make gcc
**（2）下载 OSSEC 安装包，并进行解压，进入安装目录**
    wget https://github.com/ossec/ossec-hids/archive/3.1.0.tar.gz
    mv 3.1.0.tar.gz ossec-hids-3.1.0.tar.gz
    tar xf ossec-hids-3.1.0.tar.gz
    cd ossec-hids-3.1.0
**（3）运行配置安装选项脚本**
./install.sh
选项说明
agent – 安装客户端
/var/ossec – 选择安装目录，默认选项
192.168.31.178 – 输入服务器端 IP 地址
y – 是否启用系统完整性检测模块 Syscheck 功能，默认启用
y – 是否启用后门检测模块 Rootcheck 功能，默认启用
y – 是否启用主动响应模块 active-response 功能，默认启用
**3.OSSEC-WinAgent 安装**
**（1）下载并运行 Agent 安装程序**
-3.1.0-5696.exe
（2）安装并进行配置
这里有关 OSSEC-Server IP的地址和通信密钥的相关操作见下。
**4.OSSEC Server 与 Agent 通信**
OSSEC Server 和 Agent 之间建立通信需要通过认证，在 Server 端为 Agent 生成通讯密钥并导入 Agent
后才能完成信任关系，以及 Server 端需要开放 UDP 1514通讯端口，接收 Agent 上报的信息
**（1）Agent 配置指向 Server IP**
**（2）Server 为 Agent 添加用户并生成通信密钥**
添加用户
生成密钥
选项说明
A – 新增 Agent
agent01 – 设置 Agent 名称
10.40.27.121 – 输入 Agent IP 地址
y – 是否确认新增 Agent
E – 为 Agent 生成通讯 Key
001 – 输入新增 Agent 的 ID，显示 Key 值
**（3）拷贝 Server 生成的通信密钥,并导入 Agent**
选项说明
I – 新增 Agent
MDAxIGFnZW50MDEgM=… – 输入通信 key
y – 输入 Agent IP 地址
**（4）Server 主机防火墙开放 UDP(1514)服务端口**
此时服务器和agent都需要重启下服务，
Server 上检查 Agent 是否可以通信，可以检测到，
备注：
可以通过 /var/ossec/bin/list_agents -h 查询更多 Agent 的状态信息
接下来添加一个windows agent，步骤和上面相似，只列一下过程。
**5.Rootcheck 后门检测实例**
此处以设备目录(/dev)创建隐藏文件为实例做解释，
**（1）测试**
首先在/dev 下创建隐藏文件，
**（2）Rootcheck 告警**
启动OSSEC后，rootcheck 功能确实检测到/dev 目录下存在隐藏文件，OSSEC会产生告警。
五.3 编写OSSEC检测规则和解码器Http Flood攻击检测和响应
HTTP Flood是针对Web服务在第七层协议发起的攻击。其攻击方式简单、防御过滤困难、对主机影响巨大。
HTTP
Flood攻击并不需要控制大批的肉鸡，取而代之的是通过端口扫描程序在互联网上寻找匿名的HTTP代理或者SOCKS代理，攻击者通过匿名代理对攻击目标发起HTTP请求。伪装成正常的用户进行站点的请求，通过巨大的连接数来消耗站点资源。
HTTP
Flood攻击在应用层发起，模拟正常用户的请求行为，与网站业务紧密相关，并没有统一的防御方法可以抵御，过滤规则编写不正确可能会误杀一大批用户。HTTP
Flood攻击会引起严重的连锁反应，当前端不断没请求而且附带大量的数据库操作时，不仅是直接导致被攻击的Web前端响应缓慢，还间接的攻击到后端服务器程序，例如数据库程序。增大它们的压力，严重的情况下可造成数据库卡死，崩溃。甚至对相关的主机，例如日志存储服务器、图片服务器都带来影响。
我们这里对Http Flood进行简单检测与响应，分为两部分：检测，响应。
对Http Flood攻击的检测，成功检测到，
对Http Flood攻击的响应，成功阻止与相应ip的连接，
## 三、源码分析
###  1.总体思想
本文主要针对RootCheck中关于Linux下RootKit检测部分进行源码分析。
Rootkit是一种特殊的恶意软件，它通过加载特殊的驱动，修改系统内核，进而达到隐藏信息的目的。Rootkit的基本功能包括提供root后门，控制内核模块的加载、隐藏文件、隐藏进程、隐藏网络端口,隐藏内核模块等，主要目的在于隐藏自己并且不被安全软件发现，Rootkit几乎可以隐藏任何软件，包括文件服务器、键盘记录器、Botnet
和 Remailer,而Rootcheck就是OSSEC提供的专门用于检测操作系统rootkit的引擎。
Rootcheck For Linux简要来讲可以分为以下3个方面，
1.使用 rootkit_files 文件中包含的已知后门程序文件或目录特征进行扫描识别异常；
2.使用 rootkit_trojans 文件中包含的已知被感染木马文件的签名进行扫描识别异常；
3.对设备文件目录(/dev)、文件系统、隐藏进程、隐藏端口，混杂模式接口的异常检测；
深入一点可以具体分为如下七个小方面（这七个方面之间并不完全分隔，之间有一些互相关联，而且内容量不小，在此就不统一介绍背景内容，而是在实际某个模块用到时再讲）。
（1）读取rootkit_files.txt，这其中包含rootkit及其常用文件的数据库。工具将尝试统计，以文件方式打开和以目录方式打开每个指定文件。工具使用所有系统调用，因为某些内核级的rootkit隐藏在一些系统调用中的文件。我们尝试的系统调用越多，检测越好。此方法更像是需要不断更新的防病毒规则，假阳性的机会很小，但是通过修改rootkit可以产生假阴性。
（2）读取rootkit_trojans.txt，其中包含由rootkits木马感染的文件签名的数据库。多数流行的rootkit的大多数版本都普遍采用这种用木马修改二进制文件的技术。此检测方法的局限性是找不到任何内核级别的rootkit或任何未知的rootkit。
（3）扫描/ dev目录以查找异常。/ dev应该只具有设备文件和Makedev脚本。许多rootkit使用/
dev隐藏文件。该技术甚至可以检测到非公开的rootkit。
（4）扫描整个文件系统以查找异常文件和权限问题。由root拥有的文件具有对他人的写许可，这是非常危险的，rootkit检测将寻找它们。suid文件，隐藏目录和文件也将被检查。
（5）寻找隐藏进程的存在。我们使用getsid（）和kill（）来检查正在使用的所有pid。如果存在某个pid，但“
ps”看不到，则表示内核级rootkit或“ ps”的木马版本。OSSEC还验证了kill和getsid的输出是否相同。
（6）寻找隐藏端口的存在。我们使用bind（）检查系统上的每个tcp和udp端口。如果我们无法绑定到端口（正在使用该端口），但是netstat没有显示该端口，则可能是安装了rootkit。
（7）扫描系统上的所有网卡，并查找启用了“ promisc”模式的网卡。如果网卡处于混杂模式，则“
ifconfig”的输出应显示该信息。如果没有，我们可能已经安装了rootkit。
###  2.总体设计
关于rootkit check部分的架构图如下，
###  3.详细设计
**（1）rootkit及其常用文件检查模块——check_rc_files.c**
整个文件只有一个函数，读取rootkit_files之后，根据特征查找当前系统中有没有符合特征的文件。
这里截取rootkit_files的很小的一部分作为示例，
下面看这个函数，一开始先是些变量的声明，后面会讲到，
开始读取目标文件，这里的读取不是常规意思上的读取，在读取时也做了一定处理，从中提取出有价值的部分，至于空格换行等无用的部分就都删除掉，读取之后，针对取出的数据库中各个已知rootkit的特征，进行了一个类似于遍历的操作，