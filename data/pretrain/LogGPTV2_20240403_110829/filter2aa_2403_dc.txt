a: 
         ldr  
d0, .LC0 
         ret 
.LC0: 
         .word 
0 
         .word 
1077936128 
我们已经知道 ARM64 的指令都是 4 字节（汇编）指令。4 个字节的容量有限，无法封装很大的数。
尽管如此，程序镜像可能会被操作系统加载内存中的任意地址，这就需要（基址）重定位（relocations/relocs）
来进行修正。有关重定位的详细介绍，请参见本书的 68.2.6 节。 
ARM64 成对使用 ADRP 和 ADD 指令来传递 64 位指针地址。ADRP 指令用来获取标签所在处（本例
是 main）的 4KB 分页地址，而 ADD 指令则负责存储偏移量的其余部分。在 Win32 下使用 GCC(Linaro) 4.9
编译了“Hello, word!”程序（即第 6 章的第一个程序），然后使用 objdump 工具分析它的目标文件。 
指令清单 28.6  GCC (Linaro) 4.9 and objdump of object file 
...>aarch64-linux-gnu-gcc.exe hw.c –c 
...>aarch64-linux-gnu-objdump.exe -d hw.o 
... 
① https://en.wikipedia.org/wiki/Minifloat。 
异步社区会员 dearfuture(15918834820) 专享 尊重版权
第 28 章  ARM 指令详解 
407 
0000000000000000 : 
   0:   a9bf7bfd  
     stp     x29, x30, [sp,#-16]! 
   4:   910003fd  
     mov     x29, sp 
   8:   90000000  
     adrp     x0, 0  
   c:   91000000  
     add     x0, x0, #0x0 
  10:   94000000  
     bl  
   0  
  14:   52800000  
     mov     w0, #0x0  
// #0 
  18:   a8c17bfd  
     ldp     x29, x30, [sp],#16 
  1c:   d65f03c0  
     ret 
...>aarch64-linux-gnu-objdump.exe -r hw.o 
... 
RELOCATION RECORDS FOR [.text]: 
OFFSET             TYPE                  VALUE 
0000000000000008 R_AARCH64_ADR_PREL_PG_HI21  .rodata 
000000000000000c R_AARCH64_ADD_ABS_LO12_NC .rodata 
0000000000000010 R_AARCH64_CALL26 printf 
这个目标文件有 3 个地方涉及重定位： 
 第一处首先获取页面地址，把地址的低 12 位舍去，以便在 ADRP 指令里封装地址的高 21 位。ADRP
获取的偏移量的 4KB 地址，其最后 12 位肯定是零，所以可以被忽略；另一方面，ADRP 指令也
只有 21 位空间可以封装数据。 
 其后的 ADD 指令则用于保存偏移量的低 12 位。 
 跳转到 printf()函数的 BL 指令。若把 B/BL 指令逐位的展开，会看到其中只有 26 比特可供存储偏
移量。实际上 ARM 模式和 ARM64 模式的转移指令只可能跳转到 4 的整数倍的偏移量地址，所
以在指令中省略了最后的 2 位（相当于右移 2 位）。在执行转移指令时，相当于先对文件中的偏移
量左移两位后再进行相应跳转。如此一来，转移指令的偏移量空间是 28 位，而不是 26 位；即可
跳转至 PC±128MB 的地址（即偏移量的取值范围）。 
最后生成的可执行文件里并没有再出现重定位。因为在编译过程的后续阶段，“Hello！”字符串的相对
地址、分页地址，以及 puts()函数的相对地址都是可被确定的已知数。链接器 linker 可依次计算出 ADRP、
ADD 和 BL 指令所需的实际偏移量。 
使用 objdump 分析最终的可执行文件，可以看到如下所示的代码。 
指令清单 28.7  objdump of executable file 
0000000000400590 : 
  400590:      a9bf7bfd 
stp  
x29, x30, [sp,#-16]! 
  400594:      910003fd 
mov  
x29, sp 
  400598:      90000000 
adrp  
x0, 400000  
  40059c:      91192000 
add  
x0, x0, #0x648 
  4005a0:      97ffffa0 
bl 
400420  
  4005a4:      52800000 
mov  
w0, #0x0   
// #0 
  4005a8:      a8c17bfd 
ldp  
x29, x30, [sp],#16 
  4005ac:      d65f03c0 
ret 
... 
Contents of section .rodata: 
 400640 01000200 00000000 48656c6c 6f210000 ........Hello!.. 
BL 指令要跳转到的地址可以推算出来。 
假如 BL 那条指令的 opcode 是 0x97ffffa0，即二进制的 10010111111111111111111110100000。依据
［ARM13a］C5.2.26 描述的有关技术规范，opcode 的最后 26 位是 imm26。因此 imm26 的二进制数值为
11111111111111111110100000，即 imm26 = 0x3FFFFA0。但是 imm26 的最高数权位即符号位是 1，所以它是
异步社区会员 dearfuture(15918834820) 专享 尊重版权
408 
逆向工程权威指南（上册） 
负数的补码。要把补码转换为原码，则要进行就取非再加一的运算。由此可得原码为负的 0x5F+1=0x60，
即−0x60。ARM 指令里的偏移量是实际偏移量除以 4，所以实际偏移量是其 4 倍，即−0x180。综上，BL 将
要跳转到的目标地址是 0x4005a0−0x180 = 0x400420。请注意：要以 BL 指令的偏移量为基数进行计算。如
果要对 PC 指针进行计算，那么整个推算过程将完全不同。 
如需深入了解 AM64 的重定位，请参见《ELF for the ARM 64-bit Architecture (AArch64)》（2013）。其
官方下载地址是 http://infocenter.arm.com/help/topic/com.arm.doc.ihi0056b/IHI0056B_aaelf64.pdf。 
异步社区会员 dearfuture(15918834820) 专享 尊重版权
第
第 2299 章
章    M
MIIPPSS 的
的特
特点
点  
29.1  加载常量 
unsigned int f() 
{ 
         return 0x12345678; 
}; 
MIPS 和 ARM 平台的指令都是定长指令。MIPS 程序的指令都是 32 位 opcode。在 MIPS 平台上，我们
不可能只使用单条指令就完成对 32 位常量的赋值操作。所以此类操作至少分两步进行：首先传递 32 位数
据的高 16 位，然后再通过 ORI 操作向寄存器传递立即数的低 16 位。 
指令清单 29.1  GCC 4.4.5 -O3 (assembly output) 
        li    
  $2,305397760                         # 0x12340000 
        j     
  $31 
        ori    
  $2,$2,0x5678 ; branch delay slot 
IDA 能够识别此类组合指令。为了方便阅读，它对后面的 ORi 指令进行了处理：用伪指令 LI 替换了
Ori 指令，而且用完整的 32 位值替换了值的低 16 位。 
指令清单 29.2  GCC 4.4.5 -O3 (IDA) 
        lui    
  $v0, 0x1234 
        jr     
  $ra 
        li     
  $v0, 0x12345678 ; branch delay slot 
GCC 直接生成的汇编输出文件（assembly output）同样使用了 LI 伪指令。不过 GCC 的 LI 实际上是
LUI（Load Upper Immediate）指令，把数据的高 16 位传递给寄存器的高半部分。 
29.2  阅读推荐 
Dominc Sweetman 撰写的《See MIPS Run（第二版）》，2010 年印刷。 
异步社区会员 dearfuture(15918834820) 专享 尊重版权
第
第二
二部
部分
分  
硬
硬件
件基
基础
础  
异步社区会员 dearfuture(15918834820) 专享 尊重版权
412 
逆向工程权威指南 
异步社区会员 dearfuture(15918834820) 专享 尊重版权
第
第 3300 章
章    有
有符
符号
号数
数的
的表
表示
示方
方法
法  
有符号数通常以二进制补码
①
二进制 
的形式存储于应用程序里。维基百科介绍了各种表示方法，有兴趣
的读者可参见：http://en. wikipedia.org/wiki/Signed_number_representations。本节摘录了一些典型的单
字节数值。 
十六进制 
无符号值 
有符号值（补码） 
01111111 
0x7f 
127 
127 
01111110 
0x7e 
126 
126 
... 
00000010 
0x2 
2 
2 
00000001 
0x1 
1 
1 
00000000 
0x0 
0 
0 
11111111 
0xff 
253 
−1 
11111110 
0xfe 
254 
−2 
... 
10000010 
0x82 
130 
−126 
10000001 
0x81 
129 
−127 
10000000 
0x80 
128 
−128 
如果 0xFFFFFFFE 和 0x0000002 都是无符号数，则第一个数（4294967294）就比第二个数（2）大。如
果这两个值表示的是有符号数，那么第一个数（−2）反而比第二个数（2）小了。所以，为了正确操作有
符号数和无符号数，条件转移指令（参见本书第 12 章）特地分为 JG/JL 系列（signed 型）和 JA/JBE 系列
（unsigned 型）两套指令。 
为了便于记忆，我们总结其特点如下。 
 同一个数值即可以表示有符号数，也可以表示无符号数。 
 C/C++的有符号型数据有： 
— int64_t （从-9223372036854775806 至 9223372036854775807 ），即从 0x8000000000000000 至
0x7FFFFFFFFFFFFFFF） 
— int（取值范围从−2147483646 至 2147483647，即 0x80000000 至 0x7FFFFFFF）。 
— char（取值范围从−127 至 128，即从 0x7F 至 0x80）。 
— ssize_t。 
 无符号型数据有： 
— uint64_t（从 0 至 18446744073709551615/0xFFFFFFFFFFFFFFFF）： 
— unsigned int（取值范围从 0 至 4294967295，即从 0 至 0xFFFFFFFF）。 
— unsigned char（取值范围从 0 至 255，即从 0 至 0xFF）。 
— size_t。 
 有符号数的最高数权位是符号位：1 代表负数，0 代表正数。 
 从数据宽度较小的数据转换为数据宽度较大的数据是可行的。可参见前面 24.5 节。 
 负数的补码和原码的双向转换过程是相同的，都是逐位求非再加 1。这种运算过程简单易记：同
一个值的正负数是相反的值，所以要求非；求非之后再加 1 则是因为中间的“零”占了一个数的
① two’s complement；简称为“补码”。 
异步社区会员 dearfuture(15918834820) 专享 尊重版权
414 
逆向工程权威指南（上册） 
位置。 
 加减运算不区分有符号数和无符号数，它们的加减运算指令完全相同。但是乘除法运算还是有区
别的：在 x86 指令集里，有符号数的乘除指令是 IMUL/IDIV，而无符号数的指令是 MUL/DIV。 
 此外，有符号数的操作指令更多一些。例如 CBW/CWD/CWDE/CDQ/CDQE（附录 A.6.3）、MOVSX
（15.1.1 节），SAR（附录 A.6.3）。 
异步社区会员 dearfuture(15918834820) 专享 尊重版权
第
第 3311 章
章    字
字  节
节  序
序  
字节序是指多字节类型的数据在内存中的存放顺序，通常可分为小端、大端两种字节序。小端字节序
（Little-endian）指低数权字节数据存放在内存低地址处，高数权字节数据存放在内存高地址处的内存分布方式；
大端字节序（Big-endian）是高数权字节数据存放在低地址处，低字节数据存放在高地址处的内存分布方式。 
31.1  大端字节序 
在采用大端字节序时，0x12345678 在内存中的存储方式如下所示。 
内存地址 
字节值 
+0 
0x12 
+1 
0x34 
+2 
0x56 
+3 
0x78 
Motorola 68k、IBM POWER 系列 CPU 采用大端字节序。 
31.2  小端字节序 
在采用小端字节序时，0x12345678 在内存中的存储方式如下所示。 
内存地址 
字节值 
+0 
0x78 
+1 
0x56 
+2 
0x34 
+3 
0x12 
Intel x86 系列 CPU 采用小端字节序。 
31.3  举例说明 
为了进行演示，我们可以在QEMU的虚拟化环境中安装MIPS Linux。
①
① Debian 网站提供虚拟机下载：https://people.debian.org/~aurel32/qemu/mips/。 
接下来在 MIPS Linux 里编译下述程序： 
#include  
int main()  
{ 
         int v, i; 
         v=123; 
         printf ("%02X %02X %02X %02X\n", 
异步社区会员 dearfuture(15918834820) 专享 尊重版权
416 
逆向工程权威指南（上册） 
                   *(char*)&v, 
                   *(((char*)&v)+1), 
                   *(((char*)&v)+2), 
                   *(((char*)&v)+3)); 
}; 
然后运行下述指令： 
root@debian-mips:~# ./a.out 
00 00 00 7B 
其中，0x7B 就是十进制的 123。在采用小端字节序的平台上，例如 x86 或 x86-64 的系统上，第一个字
节就是 0x7B。但是 MIPS 采用的是大端字节序，所以数权最高的这个字节排列在最后。 
正是因为 MIPS 的硬件平台可能采用两种不同的字节序，所以 MIPS Linux 又分为采用大端字节序的
MIPS Linux 和采用小端字节序的 mipsel Linux。在采取一种字节序的平台上编译出来的程序，不可能在另
一种字节序的平台上运行。 
本书的 21.4.3 节就介绍过 MIPS 大端字节序的特征。 
31.4  双模二元数据格式 
ARM、PowerPC、SPARC、MIPS、IA64 等 CPU 采用双模二元数据格式（Bi-endian），它们即可以工
作于小端字节序也可以切换到大端字节序。 
31.5  转换字节序 
BSWAP 指令可在汇编层面转换数据的字节序。 
TCP/IP 数据序的封装规范采用大端字节序，所以采用小端字节序平台的系统就需要使用专门的转换字