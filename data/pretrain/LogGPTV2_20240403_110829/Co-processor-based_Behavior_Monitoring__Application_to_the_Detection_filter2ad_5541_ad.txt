]
3
1
[
h
c
t
a
W
p
e
e
D
]
7
[
y
r
t
n
e
S
r
e
p
y
H
]
8
4
[
n
o
M
-
I
K
]
5
5
[
d
r
a
u
G
M
]
9
4
,
2
4
[
I
F
C
e
r
a
w
d
r
a
H
Property
Can monitor SMM code
Flexible
No semantic gap issue
Detect transient attacks
No new/modified hardware
Table 3: Comparison between our work and the related work.
: has the property : does not have the property
In this section, we discuss existing approaches to monitor low-
level components such as firmware and kernels, using a hardware-
based approach. To the best of our knowledge, the only commer-
cially available technology that offers SMM integrity monitoring
is HP Sure Start [37, 38]. It uses the chipset and the CPU to moni-
tor SMM code integrity and relies on additional hardware to take
actions per a predefined policy. The details of its implementation,
however, are not public. Thus, we cannot compare it in details to
other approaches in the literature.
The other approaches presented are not necessarily focused on
monitoring the SMM (i.e., the firmware), but they could be adapted
to that aim. We can distinguish two different types of approaches:
snapshot-based approaches are presented in § 7.1 and event-based
approaches in § 7.2. We summarize the comparison between these
approaches and our work in Table 3.
8We could measure the size of coreboot compiled with gcc, but the size varies when
using clang or gcc.
SMI Handler
EDK II
VariableSmm
SetVariable
GetVariable
QueryVariableInfo
GetNextVariableName
coreboot
Intel i82801gx
APMC/TCO/PM1
AMD Agesa Hudson
APMC/GPE
384
240
299
212
8
4
4
4
4
4
2
0
4
4
4
4
4
4
392
248
208
220
14
8
Table 2: Number of packets sent during one SMI handler
(Number of packets per message type: SS=2, IC=2, SC=4)
6.3.2 Co-processor performance. We measured the time it takes
for the monitor to process all the messages generated by one execu-
tion of each SMI handler. We made an average of 1000 executions.
Results are illustrated in Figure 5.
For each SMI handler there is at least a factor of 4 between
the time it takes for the target to execute the instrumented SMI
handler and the time it takes for the co-processor to process all the
messages that have been sent by the instrumented SMI handler. For
example, we see in Figure 4 that it takes around 52 µs to execute the
SetVariable SMI handler, and in Figure 5 that it takes around 230 µs
to process all the messages. This means that there is a delay between
an intrusion and its detection, but such delay will be less than
a millisecond. Hence, the co-processor could start a remediation
action within one millisecond after an intrusion occurred.
In our threat model, the attacker already has kernel privileges
before attacking the SMM code. Our objective is not to detect intru-
sions that could have been done solely with kernel privileges, such
as leaking confidential data. We consider that the final objective
of the attacker is to remain persistent in the system even in the
case of a reboot. In this case, the remediation action does not have
407)
s
d
n
o
c
e
s
o
r
c
i
m
(
e
m
T
i
50
40
30
20
10
0
Original
Communication overhead
Instrumentation overhead
SetVariable
GetVariable
Query
VariableInfo
GetNext
VariableName
3.0
2.5
2.0
1.5
1.0
0.5
0.0
i82801gx
APMC
i82801gx
TCO
i82801gx
PM1
AMD Agesa
APMC
AMD Agesa
GPE
(a) EDK II VariableSmm
(b) coreboot
Figure 4: Time (in microseconds) to execute each SMI handler (averaged over 100 executions) with the original time, and the
overhead divided between the communication overhead due to pushing packets to the FIFO and the instrumentation overhead.
)
s
d
n
o
c
e
s
o
r
c
i
m
(
e
m
T
i
200
150
100
50
0
230
152
131
137
18
Set
Variable
GetVariable Query
VariableInfo
GNVN
Intel
i82801gx
7
AMD
Agesa
Figure 5: Time (in microseconds) to process all the mes-
sages sent by one execution of each SMI handler for the co-
processor
7.1 Snapshot-based approach
The first approach consists in taking periodic snapshots of all or
any part of the target state and then to analyze these snapshots to
detect intrusions.
To the best of our knowledge, Zhang et al. [81] were the first to
propose a co-processor for intrusion detection using a snapshot-
based approach. However, they did not implement their design.
Notable implementations of such approach are Copilot [63],
DeepWatch [13], and HyperSentry [7]. Copilot is a kernel integrity
monitor using a co-processor on a PCI card to take periodic snap-
shots of the main memory. The authors also described how to write
rules describing the relationships between kernel objects to de-
tect the presence of kernel rootkits [64]. Copilot, however, cannot
monitor the SMM since it does not have access to SMRAM. Deep-
Watch uses a similar approach to Copilot, but the monitor runs on
an embedded core in the chipset, which allows the monitoring of
the SMM. HyperSentry leverages the SMM to perform measure-
ments giving access to the CPU-context, but it impedes its ability
to monitor the SMM itself.
In general, these snapshot-based solutions are unable to de-
tect transient attacks, where an attacker does not make persistent
changes (e.g., one could erase its traces before each snapshot).
7.2 Event-driven approach
All the following event-driven approaches, like our approach, re-
quire a new specific hardware component or a modification of an
existing hardware component.
Vigilare [58] snoops the memory bus traffic of the host by us-
ing an external hardware component to detect modifications of
immutable regions of a kernel. This approach does not suffer from
transient attacks: as soon as an illegal modification is made it is
detected. KI-Mon [48], its successor, also monitors mutable kernel
objects. MGuard [55] follows a similar approach, but incorporates
the integrity monitor inside a DRAM DIMM device. One limitation,
however, that affects these solutions, is their inability to access the
CPU state of the host they are monitoring (semantic gap issue). Jang
et al. [43] demonstrated the practicability of an evasion scheme by
modifying the CR3 register. Our solution, while being event-driven,
is not vulnerable to the CR3 attack since we monitor it as explained
in § 5.4.2.
While our generic approach does not focus on CFI, our evaluation
used CFI as a detection method to demonstrate the applicability of
our approach. Thus, we compare our solution with hardware-based
CFI approaches.
Lee et al. [49] use a co-processor and debugging features available
in ARM processors to enforce CFI on the main CPU. Davi et al. [24]
extend the instruction set of the processor to enforce a similar
policy. A recent document from Intel [42] suggests that future Intel
processors will have a backward-compatible CFI technology in
hardware (and available for the SMM).
Hardware-based CFI approaches modify the processor or use
additional hardware solely to enforce CFI. Our approach, on the
other hand, is more flexible since different detection approaches
could be implemented without modifying our hardware component.
The flexibility of the solution is important, because the types of
vulnerabilities exploited evolves over time.
408As discussed in § 3, CFI can be implemented without hardware
modifications by inlining the detection logic inside the target. Our
approach, however, isolates the critical parts of the detection pro-
cess such as the shadow call stack and the indirect call mappings.
We use the default parameters of the out-of-order x86 simulation,
except the CPU clock, which we set to a higher frequency. For the
ARM Cortex simulation, we derived the parameters from the ARM
technical reference manual [5].
8 CONCLUSION AND FUTURE WORK
In this work, we propose a new event-based approach for low-level
software using three key components: a co-processor to isolate the
monitor, a communication channel to reduce the semantic gap, and
an instrumentation of the software to enforce the communication.
We show that this approach can be followed to detect intrusions
targeting SMM code by using CFI and by ensuring the integrity
of relevant CPU registers (CR3 and SMBASE). However, it can
implement different detection methods. Unlike other approaches,
we solve the challenges of the semantic gap and the transient attacks
while remaining flexible.
We implemented our approach by instrumenting and monitoring
real-world firmware. The results show that we detect state-of-the-
art attacks against the SMM, while remaining below the 150 µs
threshold, thus avoiding any noticeable impact on the user.
For future work, we would like to investigate how we could
leverage such a co-processor-based monitor to (1) start remediation