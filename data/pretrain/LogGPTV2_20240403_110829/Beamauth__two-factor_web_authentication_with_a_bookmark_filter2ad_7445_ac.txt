SSL or by an extra layer of HMAC-based challenge-response.
The server may also store secret token if it wants to let Al-
ice regenerate a bookmark in the future without invalidat-
ing her other already installed bookmarks (e.g. on her other
computers.)
Behavior under Attack. At a high level, we note that it
is diﬃcult for Alice to be tricked into revealing her secret
token, because it is hidden inside her bookmark. This token
appears in the address bar only for a short period of time,
usually never long enough for Alice to even see it, and is then
removed from the address bar and from the browser’s his-
tory when the login page’s code calls the window.location.
replace() standard function call.
If Alice is being phished, she may forget to click her book-
mark and reveal her password to the attacker, or she may re-
member to click her bookmark and be immediately whisked
away to the real login site (again assuming no DNS or IP
spooﬁng, or at least a user who takes the SSL certiﬁcate
warning seriously.) The security of BeamAuth relies on the
fact that it takes both tokens to log in, and that it is diﬃ-
cult to trick Alice into revealing her bookmark token. We
explore attacks in greater detail in Section 5.2.
3.3 Limitations
The URL of the login page must match exactly what the
bookmark expects, otherwise a reload will be triggered. If
the login page needs certain parameters, they should thus
be sent via POST.
Unfortunately, Safari and Opera do not fully support this
approach. In Opera, the login page must be loaded via a
GET operation if the local secret-token injection is to suc-
ceed without a page reload. In Safari, the page will always
reloads on a bookmark click. Thus, for both of these web
browsers, the login server should store any parameters in a
server-side session, so that a page reload will not mistakenly
delete them. This work-around requires more server-side
state. As Safari and Opera together make up about 5%
of the browsing public, it is important to build this work-
around, but it is also reassuring that the extra overhead will
be required only for a small fraction of users.
4.
IMPLEMENTATION
In this section, we describe our BeamAuth implementa-
tion, which is fully functional online and available at:
http://ben.adida.net/projects/beamauth/
4.1 Setup
Hosted Server and Web Client. We used a typical shared-
hosting provider, using a small portion of a quad-processor
Intel Xeon 3.2Ghz server with 4GB of RAM, located in
Houston, Texas. We tested Firefox 2.0.1, Safari 2.0.3, and
Opera 9 on a Macintosh Powerbook G4 running at 1.5Ghz
with 1.5 GB of RAM. We tested Internet Explorer 6 and 7
on Windows XP Professional running on a 1.8Ghz Intel Core
Duo with 1 GB of RAM. Both client PCs were connected
via a Comcast home broadband connection in Boston, Mas-
sachusetts.
Web Server and Application Logic. We use Python 2.4 [47]
as the back-end programming language, with the CherryPy
web environment [10] that simply maps URLs to Python
class methods. The code is simple enough that it should be
fairly easy to read even if one is not familiar with Python
or CherryPy. We use the Apache [5] web server to handle
all HTTP requests, with a mod_proxy interface to bridge
Apache and CherryPy. We built the server-side BeamAuth
features using the built-in CherryPy session support and the
built-in Python HMAC API. The back-end code, including
the mail-back implementation, contains approximately 200
lines of BeamAuth-speciﬁc code plus a few HTML templates
and generic utilities to render these templates.
JavaScript. We use a JavaScript library [26] that imple-
ments HMAC-SHA1. Note that, while SHA1 has recently
been shown to have certain weaknesses [48], its security in an
HMAC setting has not been compromised. If it were to be
compromised, a move to SHA256 would be fairly straight-
forward and only slightly more computationally intensive.
Our small BeamAuth JavaScript library implements:
• polling, reading, and updating the fragment identiﬁer,
• performing the login process, including UI updates,
HMAC, and an HMAC-based challenge-response.
Our BeamAuth-speciﬁc JavaScript, not counting the HMAC
library, is less than 50 lines of code.
4.2 Performance
We evaluated client- and server-side computational needs
for performing HMACs. We determined that, on the slowest
browser (Safari) using the speciﬁed Mac laptop, an HMAC
operation requires just under 50ms. As this is entirely client-
side computation, it is negligible and barely noticeable to the
user. On the server side, in Python, one HMAC operation
took 300µs on our setup, a modest computational require-
ment compared to the average database query.
5. DISCUSSION
We ﬁrst explore, in greater detail, the threat model we
considered. We then examine speciﬁc attacks and how Bea-
mAuth fares. We brieﬂy compare BeamAuth to site-image
systems such as SiteKey [3], and we brieﬂy note the inter-
esting aspect of no-install security deployment.
5.1 Threat Model
We attempt to protect authentication credentials against
phishing attacks, including the simplest user-interface de-
ceptions, deceitful URLs, and pharming attacks that omit
the SSL component on sites that are SSL-enabled. We specif-
ically point out that we do not try to defend against some
of the more involved attacks, including malware that eﬀec-
tively turns a user’s machine against her, or pharming at-
tacks that use SSL and expect the user to ignore the certiﬁ-
cate warning. Certainly, these other attack vectors are worth
considering, though we believe that defending against them
likely requires signiﬁcant changes to browser code. We’ve
attempted to provide a strong defense against a large class
of attacks using only existing deployed web browsers.
We assume that a site implementing BeamAuth will not
allow logging in with only one of the two authentication
factors. When one of the authentication factors needs to be
recovered or reset, it must happen via a secondary channel,
e.g. SMS, voice, or email. We speciﬁcally recommend email
and explore potential attacks accordingly.
We do not attempt to prevent denial of service attacks:
we accept the possibility that a user may get frustrated and
may believe she can no longer log in, as long as this frus-
tration does not lead to a trivial compromise of both her
authentication factors.
We also do not attempt to protect against attackers that
convince Alice she has successfully logged in when she, in
fact, has not, and then proceed to request further conﬁden-
tial information from her. Our focus is on preventing the
attacker from successfully impersonating Alice to the Bea-
mAuth-protected site.
5.2 Speciﬁc Attacks
Phishing with a Deceitful URL, Discouraging the Book-
mark Click. In a classic, unsophisticated phishing attack
where the URL is made to look similar to the purported
destination with exactly the same appearance and instruc-
tions, Alice will click her bookmark and be whisked away
to her true login site. Her credentials remain safe. If Alice
forgets to click her bookmark, possibly because the phish-
ing site omits that instruction or actively encourages her not
to click, she may reveal her password to the malicious site.
Because her bookmark token remains safe, this should not
allow the attacker to log in on her behalf. However, it may
be problematic if Alice uses this same password at another
site that requires only a single authentication token.
Overriding Page Unload. Surprisingly, a site can include
JavaScript that locks the user in and prevents her from leav-
ing, even if she clicks on her bookmark:
window.onunload = function() {
window.location =
‘http://evil.com/stay-here’;
};
In this case, when Alice clicks her BeamAuth bookmark,
she may think she is being taken to her login site, when in
fact the malicious JavaScript interception has sent her to
a spoofed post-bookmark-click page. Though she will not
see her username automatically ﬁlled into the login form,
she may ignore this inconsistency and ﬁll it in herself, enter
her password, and submit the form. In this case, as in the
previous, Alice’s password is compromised. However, again,
her BeamAuth secret token, and thus her login, remain safe.
Importantly, the malicious JavaScript interception cannot
access the URL to which the user intended to navigate: a
call to window.location yields the current URL, not the
new one. Thus, a malicious web site can prevent a user
from navigating to another site, but it cannot determine to
which site the user meant to navigate: the BeamAuth token
remains safe.
Malicious Bookmark Replacement. An attacker might
trick Alice into replacing her BeamAuth bookmark with a
malicious one, using, for example, a spoofed email that mim-
ics the BeamAuth setup email. No matter how intricate a
procedure the attacker asks Alice to perform, one important
point remains: without a signiﬁcant browser bug, an at-
tacker cannot access the content of Alice’s bookmarks, and
thus her BeamAuth token. However, this scenario can cer-
tainly become another mechanism for the attacker to steal
Alice’s password. Again, Alice’s BeamAuth token, and thus
her login, remain safe.
Spooﬁng the Browser Interface. An attack could spoof
the browser interface [53] by opening up a new browser win-
dow, hiding the bookmarks bar, and displaying its own fake
bookmarks bar. Though the attacker would be hard-pressed
to know what bookmarks Alice is supposed to have, there
is a chance it could fool Alice into clicking its fake book-
mark rather than Alice’s real BeamAuth bookmark. This
case then reduces to the previous attack, where the attacker
convinces Alice to replace her BeamAuth bookmark. Alice
may compromise her password, though her BeamAuth token
should remain safe.
Explicit Bookmark Theft. An attacker might use the above
onunload hijacking attack to frustrate Alice because she can
no longer log in. The attacker may then follow up and ask
Alice to reveal the contents of her BeamAuth bookmark as
part of a purported debugging process. BeamAuth attempts
to mitigate this attack: the token is cleared from the ad-
dress bar within milliseconds of the bookmark click, so that
Alice would have to manually copy and paste the BeamAuth
bookmark content and send it to the attacker. For high value
sites, this attack cannot be discounted. It will be important
to tell users to never, under any circumstance, send the con-
tent of their bookmark to anyone, even someone claiming to
be a customer service agent. Even then, one cannot expect
this to be foolproof: a determined attacker may convince
Alice to manually send him her bookmark token, in which
case BeamAuth has been defeated.
Attacking the Email Account. Given the high value of the
BeamAuth token sent via email, an attacker might opt to at-
tack Alice’s credentials for accessing her email account. If
the attacker succeeds, then the BeamAuth token is compro-
mised, and the attacker might then succeed at obtaining
Alice’s password through normal phishing means. In other
words, if an attacker can compromise both Alice’s web and
email channels, he can successfully defeat BeamAuth.
Using the Victim’s Computer. An attacker might tem-
porarily gain access to Alice’s computer, e.g. while she is
at lunch. This attack is worth considering speciﬁcally be-
cause the BeamAuth token is inside a bookmark, which is
easily accessible to an attacker sitting in Alice’s chair. For-
tunately, the attacker will not be able to immediately log
in as Alice, as he still needs her password. However, an at-
tacker can steal Alice’s full credentials if he gains access to
Alice’s computer and later phishes her for her password.
A usually benign variant of this situation is when a fam-
ily shares a common computer and even a single account to
this common computer: all bookmarks are shared between
users.
In this case, each family member would have their
own BeamAuth bookmark for each site. Each account re-
mains protected by the family member’s password, though
it is certainly easier for one family member to steal another’s
credentials, since one authentication factor is immediately
compromised.
Pharming Inattentive Users. An attacker who hijacks a
DNS entry or spoofs an IP address can eﬀectively intercept
and respond to HTTP requests, including the BeamAuth
bookmark click, destined for the legitimate login host. By
sending down malicious code that reads the fragment identi-
ﬁer, an attacker can thus compromise the BeamAuth token.
If the protected site does not use SSL, BeamAuth is com-
pletely vulnerable to this kind of attack. If the protected
site uses SSL, BeamAuth remains vulnerable, except when
users are attentive enough to take the browser’s certiﬁcate
warning seriously.
Malware and Client Compromise. An attacker who in-
jects untrusted code into the user’s client computer can com-
pletely control the system, read the browser’s bookmark
content, and keylog the user’s password. BeamAuth is com-
pletely vulnerable to this kind of attack.
5.3 Comparison to Long-Lasting Cookies
Other two-factor web authentication techniques that do
not require additional client-side code exist, e.g. BankO-
fAmerica’s SiteKey [3] and Yahoo’s Sign-In Seal [52].
In
these schemes, the second-factor token is stored as a long-
lasting cookie, sent only over SSL. A browser is initialized
with this long-lasting cookie if the user successfully answers
a number of veriﬁcation questions. It is worth noting that a
recent study [43] showed that users are still highly vulnera-
ble to phishing with such site-image systems.
Second-Channel Setup. One important diﬀerence between
such site-image systems and BeamAuth is the means by which
the second factor is set up. In BeamAuth, we opt for a com-
pletely separate communication channel—email—so that a
successful man-in-the-middle attack would require intercept-
ing both a web and email connection. We note, of course,
that site-image systems could adopt the same technique for
their long-lasting cookie setup, and that such a defense could
mitigate some of the concerns, as a phisher would not be im-
mediately able to carry out a man-in-the-middle attack.
Cross-Site Scripting. A more fundamental diﬀerence is Bea-
mAuth’s use of a bookmark rather than a cookie to hold
the token. A cookie is vulnerable to cross-site scripting at-
tacks [9]:
if an attacker ﬁnds a way to inject HTML and
JavaScript into a target server’s web space, a user who vis-
its this page could have his cookie hijacked and sent to the
attacker.
A BeamAuth bookmark, on the other hand, cannot be ac-
cessed unless it is explicitly clicked: it takes a deep browser
bug or a pharming attack, not just a single-web-site bug,
to reveal the contents of a bookmark to an attacker. Thus,
in site-image systems, every web page at the protected host