### SSL and HMAC-based Challenge-Response
The server may also store a secret token if it wants to allow Alice to regenerate a bookmark in the future without invalidating her other installed bookmarks (e.g., on her other computers).

### Behavior under Attack
At a high level, it is difficult for Alice to be tricked into revealing her secret token because it is hidden inside her bookmark. The token appears in the address bar for only a short period, usually not long enough for Alice to see it, and is then removed from the address bar and browser history when the login page's code calls the `window.location.replace()` function.

If Alice is being phished, she may forget to click her bookmark and reveal her password to the attacker. Alternatively, if she remembers to click her bookmark, she will be immediately redirected to the real login site (assuming no DNS or IP spoofing, or that the user takes the SSL certificate warning seriously). The security of BeamAuth relies on the fact that both tokens are required for login, and it is difficult to trick Alice into revealing her bookmark token. We explore attacks in greater detail in Section 5.2.

### 3.3 Limitations
The URL of the login page must match exactly what the bookmark expects; otherwise, a reload will be triggered. If the login page requires certain parameters, they should be sent via POST.

Unfortunately, Safari and Opera do not fully support this approach. In Opera, the login page must be loaded via a GET operation if the local secret-token injection is to succeed without a page reload. In Safari, the page always reloads on a bookmark click. Therefore, for these browsers, the login server should store any parameters in a server-side session to prevent their deletion during a page reload. This workaround requires more server-side state. As Safari and Opera together make up about 5% of the browsing public, it is important to build this workaround, but it is reassuring that the extra overhead will be required for only a small fraction of users.

### 4. Implementation
In this section, we describe our BeamAuth implementation, which is fully functional online and available at: http://ben.adida.net/projects/beamauth/

#### 4.1 Setup
**Hosted Server and Web Client:** We used a typical shared-hosting provider, using a small portion of a quad-processor Intel Xeon 3.2Ghz server with 4GB of RAM, located in Houston, Texas. We tested Firefox 2.0.1, Safari 2.0.3, and Opera 9 on a Macintosh Powerbook G4 running at 1.5Ghz with 1.5 GB of RAM. We tested Internet Explorer 6 and 7 on Windows XP Professional running on a 1.8Ghz Intel Core Duo with 1 GB of RAM. Both client PCs were connected via a Comcast home broadband connection in Boston, Massachusetts.

**Web Server and Application Logic:** We use Python 2.4 [47] as the back-end programming language, with the CherryPy web environment [10] that maps URLs to Python class methods. The code is simple enough to be readable even for those unfamiliar with Python or CherryPy. We use the Apache [5] web server to handle all HTTP requests, with a mod_proxy interface to bridge Apache and CherryPy. We built the server-side BeamAuth features using the built-in CherryPy session support and the built-in Python HMAC API. The back-end code, including the mail-back implementation, contains approximately 200 lines of BeamAuth-specific code plus a few HTML templates and generic utilities to render these templates.

**JavaScript:** We use a JavaScript library [26] that implements HMAC-SHA1. Note that, while SHA1 has recently been shown to have certain weaknesses [48], its security in an HMAC setting has not been compromised. If it were to be compromised, a move to SHA256 would be straightforward and only slightly more computationally intensive. Our small BeamAuth JavaScript library implements:
- Polling, reading, and updating the fragment identifier,
- Performing the login process, including UI updates, HMAC, and an HMAC-based challenge-response.
Our BeamAuth-specific JavaScript, not counting the HMAC library, is less than 50 lines of code.

#### 4.2 Performance
We evaluated client- and server-side computational needs for performing HMACs. On the slowest browser (Safari) using the specified Mac laptop, an HMAC operation requires just under 50ms. This is entirely client-side computation and is negligible and barely noticeable to the user. On the server side, in Python, one HMAC operation took 300µs on our setup, a modest computational requirement compared to the average database query.

### 5. Discussion
We first explore, in greater detail, the threat model we considered. We then examine specific attacks and how BeamAuth fares. We briefly compare BeamAuth to site-image systems such as SiteKey [3], and we note the interesting aspect of no-install security deployment.

#### 5.1 Threat Model
We aim to protect authentication credentials against phishing attacks, including the simplest user-interface deceptions, deceitful URLs, and pharming attacks that omit the SSL component on sites that are SSL-enabled. We specifically point out that we do not try to defend against some of the more involved attacks, including malware that effectively turns a user’s machine against her, or pharming attacks that use SSL and expect the user to ignore the certificate warning. These other attack vectors are worth considering, though we believe that defending against them likely requires significant changes to browser code. We’ve attempted to provide a strong defense against a large class of attacks using only existing deployed web browsers.

We assume that a site implementing BeamAuth will not allow logging in with only one of the two authentication factors. When one of the authentication factors needs to be recovered or reset, it must happen via a secondary channel, e.g., SMS, voice, or email. We specifically recommend email and explore potential attacks accordingly.

We do not attempt to prevent denial of service attacks: we accept the possibility that a user may get frustrated and may believe she can no longer log in, as long as this frustration does not lead to a trivial compromise of both her authentication factors.

We also do not attempt to protect against attackers that convince Alice she has successfully logged in when she, in fact, has not, and then proceed to request further confidential information from her. Our focus is on preventing the attacker from successfully impersonating Alice to the BeamAuth-protected site.

#### 5.2 Specific Attacks
**Phishing with a Deceitful URL, Discouraging the Bookmark Click:** In a classic, unsophisticated phishing attack where the URL is made to look similar to the purported destination with exactly the same appearance and instructions, Alice will click her bookmark and be redirected to her true login site. Her credentials remain safe. If Alice forgets to click her bookmark, possibly because the phishing site omits that instruction or actively encourages her not to click, she may reveal her password to the malicious site. Because her bookmark token remains safe, this should not allow the attacker to log in on her behalf. However, it may be problematic if Alice uses the same password at another site that requires only a single authentication token.

**Overriding Page Unload:** Surprisingly, a site can include JavaScript that locks the user in and prevents her from leaving, even if she clicks on her bookmark:
```javascript
window.onunload = function() {
    window.location = 'http://evil.com/stay-here';
};
```
In this case, when Alice clicks her BeamAuth bookmark, she may think she is being taken to her login site, but the malicious JavaScript interception sends her to a spoofed post-bookmark-click page. Though she will not see her username automatically filled into the login form, she may ignore this inconsistency and fill it in herself, enter her password, and submit the form. In this case, Alice’s password is compromised, but her BeamAuth secret token, and thus her login, remain safe. Importantly, the malicious JavaScript interception cannot access the URL to which the user intended to navigate: a call to `window.location` yields the current URL, not the new one. Thus, a malicious website can prevent a user from navigating to another site but cannot determine the intended destination, keeping the BeamAuth token safe.

**Malicious Bookmark Replacement:** An attacker might trick Alice into replacing her BeamAuth bookmark with a malicious one, using, for example, a spoofed email that mimics the BeamAuth setup email. No matter how intricate a procedure the attacker asks Alice to perform, one important point remains: without a significant browser bug, an attacker cannot access the content of Alice’s bookmarks, and thus her BeamAuth token. However, this scenario can certainly become another mechanism for the attacker to steal Alice’s password. Again, Alice’s BeamAuth token, and thus her login, remain safe.

**Spoofing the Browser Interface:** An attack could spoof the browser interface [53] by opening a new browser window, hiding the bookmarks bar, and displaying its own fake bookmarks bar. Though the attacker would be hard-pressed to know what bookmarks Alice is supposed to have, there is a chance it could fool Alice into clicking its fake bookmark rather than her real BeamAuth bookmark. This case then reduces to the previous attack, where the attacker convinces Alice to replace her BeamAuth bookmark. Alice may compromise her password, though her BeamAuth token should remain safe.

**Explicit Bookmark Theft:** An attacker might use the above `onunload` hijacking attack to frustrate Alice because she can no longer log in. The attacker may then follow up and ask Alice to reveal the contents of her BeamAuth bookmark as part of a purported debugging process. BeamAuth attempts to mitigate this attack: the token is cleared from the address bar within milliseconds of the bookmark click, so Alice would have to manually copy and paste the BeamAuth bookmark content and send it to the attacker. For high-value sites, this attack cannot be discounted. It is important to tell users to never, under any circumstance, send the content of their bookmark to anyone, even someone claiming to be a customer service agent. Even then, one cannot expect this to be foolproof: a determined attacker may convince Alice to manually send him her bookmark token, in which case BeamAuth has been defeated.

**Attacking the Email Account:** Given the high value of the BeamAuth token sent via email, an attacker might opt to attack Alice’s credentials for accessing her email account. If the attacker succeeds, then the BeamAuth token is compromised, and the attacker might then succeed at obtaining Alice’s password through normal phishing means. In other words, if an attacker can compromise both Alice’s web and email channels, he can successfully defeat BeamAuth.

**Using the Victim’s Computer:** An attacker might temporarily gain access to Alice’s computer, e.g., while she is at lunch. This attack is worth considering specifically because the BeamAuth token is inside a bookmark, which is easily accessible to an attacker sitting in Alice’s chair. Fortunately, the attacker will not be able to immediately log in as Alice, as he still needs her password. However, an attacker can steal Alice’s full credentials if he gains access to Alice’s computer and later phishes her for her password.

A usually benign variant of this situation is when a family shares a common computer and even a single account to this common computer: all bookmarks are shared between users. In this case, each family member would have their own BeamAuth bookmark for each site. Each account remains protected by the family member’s password, though it is certainly easier for one family member to steal another’s credentials, since one authentication factor is immediately compromised.

**Pharming Inattentive Users:** An attacker who hijacks a DNS entry or spoofs an IP address can effectively intercept and respond to HTTP requests, including the BeamAuth bookmark click, destined for the legitimate login host. By sending down malicious code that reads the fragment identifier, an attacker can compromise the BeamAuth token. If the protected site does not use SSL, BeamAuth is completely vulnerable to this kind of attack. If the protected site uses SSL, BeamAuth remains vulnerable, except when users are attentive enough to take the browser’s certificate warning seriously.

**Malware and Client Compromise:** An attacker who injects untrusted code into the user’s client computer can completely control the system, read the browser’s bookmark content, and keylog the user’s password. BeamAuth is completely vulnerable to this kind of attack.

#### 5.3 Comparison to Long-Lasting Cookies
Other two-factor web authentication techniques that do not require additional client-side code exist, e.g., BankOfAmerica’s SiteKey [3] and Yahoo’s Sign-In Seal [52]. In these schemes, the second-factor token is stored as a long-lasting cookie, sent only over SSL. A browser is initialized with this long-lasting cookie if the user successfully answers a number of verification questions. It is worth noting that a recent study [43] showed that users are still highly vulnerable to phishing with such site-image systems.

**Second-Channel Setup:** One important difference between such site-image systems and BeamAuth is the means by which the second factor is set up. In BeamAuth, we opt for a completely separate communication channel—email—so that a successful man-in-the-middle attack would require intercepting both a web and email connection. We note, of course, that site-image systems could adopt the same technique for their long-lasting cookie setup, and that such a defense could mitigate some of the concerns, as a phisher would not be immediately able to carry out a man-in-the-middle attack.

**Cross-Site Scripting:** A more fundamental difference is BeamAuth’s use of a bookmark rather than a cookie to hold the token. A cookie is vulnerable to cross-site scripting attacks [9]: if an attacker finds a way to inject HTML and JavaScript into a target server’s web space, a user who visits this page could have his cookie hijacked and sent to the attacker. A BeamAuth bookmark, on the other hand, cannot be accessed unless it is explicitly clicked: it takes a deep browser bug or a pharming attack, not just a single-web-site bug, to reveal the contents of a bookmark to an attacker. Thus, in site-image systems, every web page at the protected host must be carefully secured to prevent such attacks.