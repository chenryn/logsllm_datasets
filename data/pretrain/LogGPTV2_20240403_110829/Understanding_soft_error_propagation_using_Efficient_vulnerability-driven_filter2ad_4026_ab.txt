and potentially 
mechanisms 
cause program aborts or SDCs. 
to the method-under-test. 
conserving  computational 
while data-centric computations 
are more 
benchmarks. Our analysis 
of the 
look at the behavior 
in memory addresses most likely 
•  We also take an in-depth 
injected faults in different 
shows that faults 
software aborts 
susceptible 
of the software aborts have 
Further, 
relating 
examples 
can bring to fault-tolerant 
many error derating 
to Y-branch [ 1 4 ] .  These lessons 
of what the CriticalFault 
relative 
to silent 
system researchers. 
short crash latencies. 
are only a few 
cases are caused by effects 
trigger 
injection campaign 
data corruptions. We find that  most 
As researchers  continue 
solutions, 
erate relevant 
robust evaluation 
test  cases  for 
to look into cross-layer reliability 
methods should be in place to gen­
stressing 
the underlying 
reliability 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 18,2021 at 14:50:05 UTC from IEEE Xplore.  Restrictions apply. 
Full System 
Simulator 
Micro-processor 
Simulator 
Critical Fault 
errors  that  are 
of  the  error 
de­
recent 
cross-layer 
To  take 
solutions. 
As traditional 
redundancy-heavy 
the scaling-induced 
solutions 
reliability 
may be exor­
threat, 
low-cost and effective 
effort investigates 
full advantage 
many only handle hardware 
bitant against 
research 
reliability 
rating behavior, 
not derated and cause visible 
effect on the software 
[5], [6] ,  [7] ,  [8], [9]. On the other hand, these schemes are 
often  evaluated 
the  overall 
effects at multiple 
tically  reduce  the 
tolerant 
paper therefore 
aiming to create relevant 
tolerant 
of the enhanced 
levels of hardware 
actual number of  test 
schemes and makes  the 
investigates 
test cases for these  types 
using SFI. Although 
a biased  fault 
reliability 
evaluation 
schemes. 
[4], 
cases  for  the 
fault­
less rigorous. This 
injection approach 
system, error derating 
and software 
can dras­
SF! can fairly measure 
of fault­
Fig. l .  Overall system diagram of CriticalFault 
it is possible to intelligently 
later be derated. 
avoid injecting 
faults that will 
CriticalFault 
is a biased injection framework 
that focuses on 
the reliability  scheme-under-test  by 
eliminating 
analysis. By redirecting 
faults, the computational 
To better understand 
Cook and Zilles 
stud­
error derating, 
behavior 
for errors randomly 
errors to be potentially  harmful 
a 
level [ 1 0] .  They conservatively 
if memory, control, 
However, 
are corrupted. 
because 
of the errors 
the  derating 
ied and classified 
injected at the instruction 
consider 
and system call instructions 
portion 
will be derated 
not capture 
these scenarios 
harmful. In comparison, 
these errors  as  programs  are 
the final outcome. 
at the software 
level, 
this  work 
and treat 
derating-based 
studies  do 
these cases as potentially 
captures 
the end effect  of 
to detennine 
affecting memory and control 
run to completion 
instructions 
via vulnerability 
faults 
be utilized 
stress testing 
known derated 
the focus to likely non-derated 
resources can 
the quality 
will  more 
but unrecoverable 
(SOC), the three outcomes 
system designers
often subjected to further 
the mechanism-under-test. 
error (DUE),  and  a 
. Furthermore, 
likely lead to  a recoverable 
detection, 
silent 
data corruption 
a detected 
that matter most to fault-tolerant 
DUE and SOC events are 
analysis, and potentially 
improve 
much more efficiently. 
Consequently, 
of test cases is higher since an injected fault 
Prior work has also investigated 
AVF  and SF! together. 
by carefully 
that the 
details 
of treating 
to compare AVF obtained 
experiments 
of SFI for evaluating 
differences in SER between 
can be made more accurate 
entities, our work leverages 
a small amount of additional 
with SFI in terms of  SER and found 
in the processor 
as two 
and SF! 
ACE analysis 
derating 
to im­
analysis 
reliability 
techniques 
mechanisms. 
to focus on 
Wang et al. conducted 
from ACE analysis 
that there are non-negligible 
the two methods [21 ] .  Biswas et al. later rebutted 
AVF computation 
choosing 
model [22]. Instead 
separate 
prove the quality 
Relyzer [23] employs error analysis 
maximizing 
likely  generate 
They inject faults into SPARC integer 
latches 
is to maximize 
SDCs and  other 
general-pur
registers 
understand 
Nevertheless, we believe 
helpful 
that error analysis 
in the future. 
injections, 
We inject faults 
errors. 
and Il'op-visible 
which allows us to better 
level. 
techniques 
similar  outcomes  in 
in an x86 architecture, 
the number of non-derated 
the SOC cases by removing 
pose, floating-point 
software  visible 
unites. CriticalFau
CriticalFault 
faults occurring 
the injections that 
of the address 
in enhancing 
generation 
registers 
and output 
lt's goal 
including 
temporary 
into 
are 
near the microarchitecture 
the SPARC architecture. 
Ideally, 
we would want to generate 
a map of vulnerable 
bits 
of a processor at every cycle of the 
and our 
resources 
computation 
error effects, 
we opt to dedicate 
level. After all, the software 
unless an error occurs in 
and memory location
s. Therefore, 
this 
analysis 
on the data and control 
for all gates and latches 
execution. 
Because of limited 
focus on cross-layer hardware 
our effort at the architecture 
execution 
is often not corrupted 
architectural 
work  conducts 
flow of the executing 
approach 
the microarchitecture 
framework 
The CriticalFault 
vulnerability 
can be applied 
level or lower. 
registers 
program. 
Nevertheless, the CriticalFault 
to analyzing 
and injecting faults at 
architecture 
is shown in Fig­
relevant 
with  a microprocessor 
fault 
up of 
and guided fault injection. 
Critical 
analysis 
analysis 
interacts 
to generate 
Fault is  made 
CriticalFault 
injection campaign. 
and a full-system simulator 
ure 1 .  Overall, 
simulator 
sites for  the 
two  phases: vulnerability 
Vulnerability 
analysis. Instead 
execution  (ACE) 
correct 
architectural 
vulnerability 
factor, 
nerable bits in the program trace. 
fault injection (GF!) scheme uses this map to randomly 
the potentially 
we 
describe VA and GF! in greater 
(VA) is similar 
Subsequently, 
VA produces 
vulnerable 
select 
injection sites. In the following, 
our guided 
a map of vul­
detail. 
to the architecturally 
of calculating  the 
III. VULNERABILITy-DRIVEN F AULT INJECTION 
B. Vulnerability 
Analysis 
We constructed 
the vulnerability 
analyzer 
based  on 
the 
A. CriticalFault 
Reliability 
often uses SF! to assess the overall 
and the error coverage 
scheme. Unfortunately, 
research 
system reliability 
fault-tolerant 
injected errors are derated 
evaluation  difficult 
scheme. However, we observe that many of these derated 
errors 
in SF!, making the error coverage 
can be identified using 
as they do not exercise 
vulnerability 
many, if not 
most, of the 
of the underlying 
analysis. Therefore, 
engineers 
data corruptions, the analyzer 
in [ 1 1 ] .  
faults and reliability 
un-ACE bit descriptions 
software-visible 
ried about silent 
single-bit 
the Single Event Upset (SEU) fault model in 
it is a well-known and 
Moreover, 
SEUs. However, 
CriticalFault 
corruptions 
widely adopted 
existing 
in the architectural 
the fault-tolerant 
work on vulnerability 
analysis 
is based on 
are often wor­
focuses on 
registers. We 
employ 
because 
registers 
can adapt to  other 
fault models 
Since this  work 
concerns 
model for soft errors. 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 18,2021 at 14:50:05 UTC from IEEE Xplore.  Restrictions apply. 
DYNAMICALLY DEAD INSTRUCTIONS 
TABLE I 
No /.LOpS 
Type 
1  Id [rbx] -> rex  TDD 
2  add rax rex -> rax FDD 
3  mov r l l  -> r l O  
4  mov rbx -> rax 
5  Id [rdxl -> rex 
given the corresponding 
available. 
vulnerability 
analysis 
component 
is 
To  this 
directly. 
flag bits  in 
that writes the flag 
end, the analyzer 
can be corrupted. 
the injection map. 
instruction 
injected with errors 
checks the flag types used by a branch and include 
the 
appropriate 
Second, the producer 
register 
of these flag-writing instructions 
outcomes. Injected errors are derated 
duce different 
only includes 
in a flag-writing instruction that 
branch outcome provided 
consumed 
register 
is not 
instructions. 
is to determine 
if they do not pro­
flag values. Because of this, our analysis 
into the injection map the register 
bits 
In essence, the only purpose 
that the targeted 
by other subsequent 
change the subsequent 
branch 
an ISA that has 
Of course, 
Generally, 
is vast. Consider 
jection space in a program trace, 
a trace of 1 ,000 instructions 
the possible  in
level, 
even at the architecture 
16 64-bit architectural 
registers, 
has 16x64x 1 ,000= 1 ,024,000 bits that are  considered  for 
ruption. 
at  the sources 
two sources 
still 1 92,000 injection points for merely 1 ,000 instructi
The main goal of vulnerability 
injection 
for fault injections. 
we can shrink the space by only injecting 
of the instructions. 
Assuming 
for each instruction,  there are 
and destinations 
and one destination 
space as much as possible and expose relevant 
bits 
bit systems. Nevertheless, when a program is running 
in 64-bit mode,  some 
32-bit operands, 
ebx and etc, will be zero-extended 
occurring 
masked by zero extension, 
bits resilient. 
instruction 
remove those resilient 
the x86 
operand size during the decode stage and 
in the upper 32  bits  will 
bits from the injection map. 
The vulnerability 
to 64-bil.  A fault 
4) Valid operand size. 
The  current 
is to prune the 
framework 
analysis 
analyzer 
detects 
cor­
ons. 
such as  eax, 
automatically 
be 
targets 64-
making those zero-extended 
The above analysis 
identifies 
both un-ACE instructions 
The analysis 
proceeds 
as follows.  At the beginning, 
a 
used by all non-dead 
ons. With this 
map that 
An example of injection map is shown in Table II. 
an injection 
the analyzer 
constructs 
environment 
bits of the registers 
and the sets of un-ACE bits in ACE instructi
information, 
shows the specific 
instructions. 
In a 64-bit computation 
64-bit instructions 
comparison, 
ACE bits by taking 
that while prior work conducts 
on calculating 
SER but does not make use of the knowledge 
vulnerable 
is used to guide the subsequent 
vulnerability 
the instruction 
In comparison, 
an accurate 
bits  are. 
analysis 
a similar 
biased SFI. 
co-exist, SFI often considers 
this detailed 
analysis, it focuses 
AVF (or PVF) and estimating 
the 
of where the 
is able to remove many un­
type into 
account. 
We note 
where both 32-bit and 
all 64 bits. In 
information 
and a  few million 
trace of dynamic instructions 
thousand 
dynamic  control 
Then, the  analyzer 
following. 
examines 
(usually 
instructions) 
varying 
is collected 
and a 
between  a few 
and data flow graph (COFG) is constructed. 
the COFG and looks for the 
Deadness analysis 
and prunes all data 
through register 
we track dy­
and mem­
writes to a register 
that is sub­
is classified 
as first­
to [ 1 1 ] ,  
rewritten, 
the instruction 
dead  (FOO). Further, 
1) Dynamically dead instructions. 
looks at inter-instruction 
relations 
bits from dead registers. 
Similar 
namically 
dead instructions 
ory. If an instruction 
sequently 
level dynamically 
writes to registers 
instructions, 
dead (TOO). For example, 
(I-l0p) mov in Table I rewrites 
I-lOp add writes to it,  making 
The source register 
by others, 
all source and destination 
instructions 
this instruction 
are not  included  in 
registers 
causing 
rcx in 2nd I-lOp is not consumed 
the 1 st I-lOp ld to be TOO. Thus, 
if an instruction 
that are consumed only by  FOO 
is transitively  dynamically 
C. Guided Fault Injection 
the 4th micro-oper
rax after 2nd 
the 2nd I-l Op a FOO. 
register 
ation 
The main objective of CriticalFault 
sites that are least likely to experience 
injection map produced  by 
this purpose. 
is to choose injection 
error derating. 
The 
the vulnerability  analysis 
serves 
When SFI is conducted, 
injection 
sites are 
chosen at random 
of FOO and TOO 
2) Logical masking. In some instructions, 
the injection map. 
data can be masked. Hence, ex­
temporal-spatial space. At the architecture 
in the available 
level, the dynamic instructions  present 
points and the bits of architectural  registers 
accessed by 
the targeted 
delve into the 
bits and prune immediately  masked  faults 
temporal-spatial points (which processor 
in the processor 
we focus on the architecture 
the architecture 
fault injections into the 
instruction 
small-scale 
of every non-dead 
cycles and which bits 
In this work, 
masking effect allows us to identify 
model) will become available. 
state would affect the software. 
microarchitecture 
this, the vulnerability 
level since only errors 
instructions 
that corrupt 
represent 
the spatial 
different 
of the source register 
amining this logical 
the irrelevant 
from the injection map.  To 
analyzer 
source  registers 
mine bits that potentially 
lead to corrupted 
a subset or all 
temporal 
conducts 
points. As we 
achieve 
In guided fault injection, faults are selected  randomly 