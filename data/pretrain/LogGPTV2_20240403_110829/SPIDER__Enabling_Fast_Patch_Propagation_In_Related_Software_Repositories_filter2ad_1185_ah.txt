O
d
e
t
s
u
r
T
E
E
T
-
P
O
5
1
D
S
B
n
e
p
O
S
O
e
l
b
i
t
a
p
m
o
C
s
w
o
d
n
W
i
s
m
e
t
s
y
S
g
n
i
t
a
r
e
p
O
d
e
t
s
u
r
T
D
S
B
n
e
p
O
2
1
e
r
a
w
m
r
i
F
d
n
a
r
e
d
a
o
l
t
o
o
B
3
4
5
6
7
8
9
0
1
1
1
3
1
4
1
5
1
6
1
7
1
8
1
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 09:21:07 UTC from IEEE Xplore.  Restrictions apply. 
1572
Perc.
40
35
30
25
20
15
10
5
0
Missing Security (Non-CVE) Patches
Missing sps
15.8
15.5
12.1
11.3
18.1
16.5
19
16
14.1
13.3
7.4
6.2
7.5
6
5.8
3.8
2
3
4
5
6
Project IDs
7
8
9
Fig. 5: Distribution of the security (non-CVE) patches (identified
by the SeP Mode of SPIDER) and sps in Mainline Linux kernel
(Project ID 1) that are missing in other related kernel projects.
error = −EINVAL;
goto out put
tmp file ;
( f . f i l e −>f op != &x f s
tmp . f i l e −>f op != &x f s
error = −EINVAL;
goto out put
tmp file ;
f i l e o p e r a t i o n s
f i l e o p e r a t i o n s ) {
||
}
i f
}
+
+
+
+
+
+
ip = XFS I ( f i l e i n o d e ( f . f i l e ) ) ;
t i p = XFS I ( f i l e i n o d e ( tmp . f i l e ) ) ;
Listing 4: a security patch
identified by SPIDER on the main Linux kernel repository (commit
3e0a3965464505). which does not have a corresponding CVE ID.
CVE patches source
Linux
Android bulletin
OpenBSD
OpenSSL
Systemd
VLC
Total
sps / CVE
333 / 611 (54.5%)
98 / 164 (59.75%)
5 / 6 (83.33%)
7 / 21 (33.33%)
4 / 4 (100%)
1 / 3 (33.33%)
448 / 809 (55.37%)
TABLE III: Results of SPIDER on CVE patches.
( u i n t 3 2 t
s t a r t , u i n t 3 2 t
i n t check aboot addr range overlap
{
−
+
/∗ Check for boundary c o n d i t i o n s . ∗/
i f
i f
( ( s t a r t + s i z e ) b ptr = address ;
+Py INCREF ( d l l ) ;
+Py DECREF( f t u p l e ) ;
Listing 6: A non-CVE security patch (commit d77d97c9a1f) fixing
a reference counting vulnerability in the Python interpreter identified
∗) GenericPyCData new ( type , args , kwds ) ;
( ! s e l f )
( ! s e l f ) {
Py DECREF( f t u p l e ) ;
return NULL;
by SPIDER. This patch does not have a corresponding CVE ID.
E. Missing patches in vendor kernels
To identify missing patches in vendor kernels, we check how
many of the Linux Kernel mainline commits identified as sps
still have to be applied to one or more of the eight vendor kernel
repositories that we studied (i.e., projects 2 - 9 in Table II), at the
time of writing. To do that, given a commit identified as an sp,
we extract the affected file’s source code before the change, and
we compare it to the same file, if present, in all the listed kernel
repositories (Table II show the git branch or tag that we studied)
using the git diff technique described in Section VII-B.
The stripe bars in Figure 5 shows the percentage of missing sps
in different vendor kernels. We found that 9,427 of the 20,171 Linux
kernel identified sps (i.e., 46.74%) are still not applied in at least
one of the considered vendor kernels. A significant portion of these
changes not considered useful by the maintainers (e.g., removals
of unused code, small refactoring, etc.), and therefore, not imported.
However, we found out that 297 of them are CVE patching commits
(i.e., the ones that we linked to the corresponding CVEs, as shown
in Section VII-C) that still have to be imported by the maintainers of
some repositories: this supports the findings of previous studies [57],
[53], [22], [41] that report that vulnerability databases are not
always effective in speeding the propagation of security fixes.
Unfixed vulnerabilities in vendor kernels: We also checked the
security patches (which do not have a CVE number) identified by
the SeP mode in the Linux Kernel mainline that still have to be
applied to one or more of the eight Linux Kernel repositories that
we studied (i.e., projects 2 - 9 in Table II). The plain bars in Figure 5
show the percentage of missing non-CVE security patches in
different vendor kernels. There are in total 229 security patches
that do not have a corresponding CVE number and are missing on
different kernel repositories, including the ARM Linux kernel main
repository (i.e., project 2 in Table II): these can be seen as potential
unfixed or n-day vulnerabilities. Given their potential severity, we
manually verified them to assess their impact. For a few of these
vulnerabilities, the impact is less severe because of the variation in
kernel configurations. However, we found several missing patches
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 09:21:07 UTC from IEEE Xplore.  Restrictions apply. 
in critical components like netfilter, which applies to all
kernel configurations. The snippet of a non-CVE security patch
that is missing in the msm kernel (ID 4) is shown in Listing 11, this
patch, as mentioned before also contains the triggering input.
We are in the process of reporting all of these patches to the
corresponding project maintainers and vendors, and submit all the
necessary requests for CVEs.
VIII. LIMITATIONS
Along with the assumptions described in Section V, SPIDER
comes with several limitations. Specifically,
Small patches: As we can see from Figure 6, the majority
(57.1%) of the patches detected as sps are small (0-5 lines).
Furthermore, SPIDER cannot verify patches that modify statements
within a loop. These limitations are mainly because SPIDER tries to
verify a patch to be safe in a sound way. We believe it is important
to have a system with no false positives, that provides stronger
guarantees, and that can be used by the maintainers safely.
Syntactic approach for patch applicability check: We use a
syntactic approach to check for patch applicability in the related
repositories. However, a patch although syntactically applicable to
a file in a project may not be semantically applicable because the
condition fixed by the patch could be impossible to occur in the
project [40]. This limitation is induced by our requirement R1, as
checking for semantic applicability of patches require sound static
analysis techniques which require build environment and access
to all source files, thus violating our requirement R1.
Heuristic approach for error-handling basic blocks detection:
As explained in Section IV-D, we use a heuristic approach to
identify error-handling basic blocks. However, these heuristics may
not hold for other projects resulting in cases where a basic block
matching our heuristics is not a true error-handling basic block.
Consequently, we could have unsafe patches being identified as safe.
To handle this, we provide the NoEB mode of SPIDER (Appendix I)
where we do not ignore the changes in the error-handling basic
blocks. This mode provides a safer version of SPIDER, albeit with
a slight decrease in detection rate.
Susceptible to adversarial evasion: As a consequence of our
assumptions (Section V), SPIDER is susceptible to adversarial
evasion. For instance, as we treat macros as function calls, an
adversarial developer or contributor could use macro calls to
make SPIDER consider otherwise safe patches as unsafe. However,
as we explained in Section I, the main use case of SPIDER is for
developers and maintainers. Furthermore, we assume developers
to be non-malicious users who want to ensure that their applications
are as secure as possible.
Tool dependencies: The current implementation of SPIDER works
only on C source code; however, the parser that we use should
be easily extensible to other languages. The fine-grained diff step
is language agnostic, thus, to extend the tool to other languages,
we would only need to add language-specific heuristics and
preprocessing. A good solution would be to have a configurable
front end for different languages, similar to LLVM [47]. As our
implementation is based on Joern and Gumtree, we also share the
same limitations that these tools have.
IX. RELATED WORK
Source code changes and patches as research topics received
a lot of attention in the past decade. This section covers a
comprehensive portion of prior work on these topics (Section I
already covered state-of-the-art code analysis techniques that were
used in the field, thus they will not be covered here).
Vulnerability finding and exploitation: In Section VII-E we show
how SPIDER can be used to find instances of unpatched code
starting from the identified sps, including vulnerabilities. Finding
unpatched code clones is the focus of most of the prior research
on patches in the security field [50], [41], [49]. In this work, we
do not look for code clones but for instances where the function
affected by a patch is still equal to the unpatched version. Brumley
et al. [28], instead, show how to generate exploits for a vulnerability
starting from the corresponding patch.
Easing the patching process: Prior research has been very
active in designing approaches and building tools to ease and
speedup the process of patching [59], [71], [20], However, most
of these techniques target only specific bug classes [55].Other
studies concentrate on helping developers in applying systematic
changes [78], [54]. Long et al. [51], in contrast with the previously
mentioned studies, use machine learning to model correct code
and generate generic defects fixes, but do not focus on propagating
existing patches as we do in this study. Similar to what we do in
this work, Kreutzer et al. [43] use AST differencing on changes to
extract metrics to help cluster the changes by similarity.
Software evolution: Mining software repositories is a well-
known technique to gain insights into the dynamics of software
evolution [39], [38]. Perl et al. [61] built VCCFinder, a tool that
leverages code metrics and patch features (e.g., keywords in
commits) to identify vulnerability-contributing changes. However,
in this work, we do not rely on the commit messages, and, instead
perform a systematic analysis of the patches.
X. CONCLUSION AND FUTURE WORK
In this work, we designed, implemented, and evaluated SPIDER,
a fast and lightweight tool (R2) based on our sp identification
approach that can determine if a patch is safe using only the original
and the patched source code of the affected file (R1), without the
need for external information (e.g., build environment, commit
message, etc.). Our large-scale evaluation on 341,767 commits ex-
tracted from 32 different open-source repositories, and on 809 CVE
patches, demonstrates the effectiveness of SPIDER, and shows that a
significant amount of security patches could have been automatically
identified (i.e., 55.37%). Furthermore, we show how the SeP mode
of SPIDER can be used to find unpatched security issues.
ACKNOWLEDGEMENTS
We would like to thank the anonymous reviewers and our
shepherd Alina Oprea for their valuable comments and input to
improve our paper.
This material
is based upon work supported by AFRL
under Award No. FA8750-19-C-0003, by ONR under Award
No. N00014-17-1-2011, and by NAVSEA under Award No.
N00024-12-C-6404/0451. This research was also sponsored by
DARPA under agreement number HR001118C0060. The U.S.
Government is authorized to reproduce and distribute reprints for
Governmental purposes notwithstanding any copyright notation
thereon. The views and conclusions contained herein are those of
the authors and should not be interpreted as necessarily representing
the official policies or endorsements, either expressed or implied,
of DARPA, the U.S. Government, or the other sponsors.
1574
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 09:21:07 UTC from IEEE Xplore.  Restrictions apply. 
NOTES
1http://dotat.at/prog/unifdef/
2code.google.com/archive/p/java-diff-utils/
3https://github.com/torvalds/linux.git
4https://github.com/linaro-swg/linux.git
5https://github.com/raspberrypi/linux.git
6https://android.googlesource.com/kernel/msm
7https://android.googlesource.com/kernel/tegra
8https://github.com/MiCode/Xiaomi Kernel OpenSource.git
9https://android.googlesource.com/kernel/x86 64.git
10https://github.com/sonyxperiadev/kernel.git
11https://github.com/aosp-mirror/kernel common.git
12https://github.com/littlekernel/lk.git
13https://source.codeaurora.org/quic/la/kernel/lk
14https://github.com/OP-TEE/optee os.git
15https://github.com/openbsd/src.git
16https://github.com/reactos/reactos.git
17https://github.com/python/cpython.git
18https://github.com/php/php-src.git
19https://gitlab.gnome.org/GNOME/nautilus.git
20https://github.com/Microsoft/winfile.git
21https://github.com/mirror/xserver.git
22https://github.com/videolan/vlc.git
23https://github.com/FFmpeg/FFmpeg.git
24https://github.com/antirez/redis.git
25https://github.com/tmux/tmux.git
26https://github.com/curl/curl.git
27https://salsa.debian.org/gnome-team/evince.git
28https://github.com/git/git.git
29https://github.com/bminor/binutils-gdb.git
30https://github.com/OpenVPN/openvpn.git
31https://github.com/systemd/systemd.git
32https://github.com/glennrp/libpng.git
33https://github.com/openssl/openssl.git
34https://github.com/bminor/glibc.git
REFERENCES
[1] 2016 android security bulletins.
2016.html. Accessed: 2017-02-11.
source.android.com/security/bulletin/
[2] Android 10 msm kernel. https://android.googlesource.com/kernel/msm/+/
refs/tags/android-10.0.0 r0.16. Accessed: 2019-10-28.
[3] Apple’s goto fail bug.
https://www.imperialviolet.org/2014/02/22/
applebug.html. Accessed: 2017-02-13.
[4] The biggest and weirdest commits
in linux kernel git history.
www.destroyallsoftware.com/blog/2017/the-biggest-and-weirdest-commits-
in-linux-kernel-git-history. Accessed: 2017-02-15.
[5] Community reaction to delayed patching. https://twitter.com/RatedG4E/
status/760322614912954368. Accessed: 2017-02-13.
[6] Error handling via goto in c.
https://ayende.com/blog/183521-C/error-
handling-via-goto-in-c. Accessed: 2019-07-13.
[7]
[8]
[9]
[10]
[11]
https://github.com/blog/2470-
[extended version] spider: Enabling fast patch propagation in related
software repositories. https://drive.google.com/file/d/1ZXYv6YjXNgj7-
WbyrsrxwF9Y8aKuVth/view?usp=sharing. Accessed: 2019-07-31.
Introducing security alerts on github.
introducing-security-alerts-on-github. Accessed: 2017-02-13.
Irb human subject
//www.hhs.gov/ohrp/regulations-and-policy/decision-charts/index.html.
Accessed: 2017-02-13.
libebml fixed a vulnerability but no cve was assigned. https://twitter.com/
wdormann/status/1154138404910768134. Accessed: 2017-07-25.
libembl security fix without a cve id. https://github.com/Matroska-Org/
libebml/commit/05beb69ba60acce09f73ed491bb76f332849c3a0. Accessed:
2017-07-25.
regulations exempt decision charts.
https:
[12] Linux kernel configuration.
http://www.tldp.org/HOWTO/SCSI-2.4-
HOWTO/kconfig.html. Accessed: 2017-02-13.
[13] Openssl bug fix for cve-2016-0703. https://git.openssl.org/?p=openssl.git;a=
Accessed:
commit;h=ae50d8270026edf5b3c7f8aaa0c6677462b33d97.
2017-02-13.
[14] Use of goto in systems code. https://blog.regehr.org/archives/894. Accessed:
2019-07-13.
[15] Using goto in linux kernel code. https://koblents.com/Ches/Links/Month-
Mar-2013/20-Using-Goto-in-Linux-Kernel-Code/. Accessed: 2019-07-13.
[16] Vlc media player affected by a major vulnerability in a 3rd library,
libebml. https://hub.packtpub.com/vlc-media-player-affected-by-a-major-
vulnerability-in-a-3rd-library-libebml-updating-to-the-latest-version-may-
help/. Accessed: 2017-07-25.
J. Admanski and S. Howard. Autotest-testing the untestable. In Proceedings
of the Linux Symposium. Citeseer, 2009.
[17]
[18] F. E. Allen. Control flow analysis. In ACM Sigplan Notices, vol. 5, pp. 1–19.
ACM, 1970.
[19] W. Amme and E. Zehendner. Data dependence analysis in programs with
[20]
pointers. Parallel Computing, 24(3-4):505–525, 1998.
J. Andersen, A. C. Nguyen, et al. Semantic patch inference. In Proceedings
of the ACM International Conference on Automated Software Engineering
(ASE). 2012.
[21] G. Antoniol, K. Ayari, et al. Is it a bug or an enhancement?: A text-based
approach to classify change requests. In Proceedings of the Conference of the
Center for Advanced Studies on Collaborative Research (CASCON). 2008.
[22] A. Arora, R. Krishnan, et al. An empirical analysis of software vendors’ patch
release behavior: impact of vulnerability disclosure. Information Systems
Research, 21(1):115–132, 2010.
[23] M. Barnett and K. R. M. Leino. Weakest-precondition of unstructured
programs. In Proceedings of the ACM SIGPLAN-SIGSOFT Workshop on
Program Analysis for Software Tools and Engineering (PASTE). 2005.
[24] G. Bavota. Mining unstructured data in software repositories: Current and
In Proceedings of the IEEE International Conference on
future trends.
Software Analysis, Evolution, and Reengineering (SANER). 2016.
[25] D. Binkley. Using semantic differencing to reduce the cost of regression
testing. In Proceedings of the IEEE International Conference on Software
Maintenance (ICSME). 1992.
[26] D. Binkley, R. Capellini, et al. An implementation of and experiment with
semantic differencing. In Proceedings of the IEEE International Conference
on Software Maintenance (ICSME). 2001.
[27] D. Bleichenbacher. Chosen ciphertext attacks against protocols based on the
rsa encryption standard pkcs# 1. In Proceedings of the Annual International
Cryptology Conference (CRYPTO). 1998.
[28] D. Brumley, P. Poosankam, et al. Automatic patch-based exploit generation is
possible: Techniques and implications. In Proceedings of the IEEE Symposium
on Security and Privacy (SP). 2008.
[29] R. P. Buse and W. R. Weimer. Automatically documenting program changes.
In Proceedings of the ACM International Conference on Automated Software
Engineering (ASE). 2010.
[30] C. Cadar, P. Godefroid, et al. Symbolic execution for software testing
In Proceedings of the International
in practice: preliminary assessment.
Conference on Software Engineering (ICSE). 2011.
J. M. Cardoso and P. C. Diniz. Modeling loop unrolling: Approaches and
open issues. In Proceedings of the International Workshop on Embedded
Computer Systems (SAMOS). 2004.
[31]
[32] F. Chow, S. Chan, et al. A new algorithm for partial redundancy elimination
based on ssa form. In ACM Sigplan Notices, vol. 32, pp. 273–286. ACM, 1997.
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 09:21:07 UTC from IEEE Xplore.  Restrictions apply. 
1575
shared code on vulnerability patching. In Proceedings of the IEEE Symposium
on Security and Privacy (SP). 2015.
[58] F. Nielson, H. R. Nielson, et al. Principles of program analysis. Springer, 2015.
[59] A. Nistor, P.-C. Chang, et al. Caramel: detecting and fixing performance
problems that have non-intrusive fixes. In Proceedings of the International
Conference on Software Engineering (ICSE). 2015.
[60] M. Payer and T. R. Gross. Hot-patching a web server: A case study of asap
code repair. In Proceedings of the Annual Conference on Privacy, Security
and Trust (PST). 2013.
[61] H. Perl, S. Dechand, et al. Vccfinder: Finding potential vulnerabilities in
open-source projects to assist code audits. In Proceedings of the ACM SIGSAC
Conference on Computer and Communications Security (CCS). 2015.
[62] S. Person, M. B. Dwyer, et al. Differential symbolic execution. In Proceedings
of the Joint Meeting on Foundations of Software Engineering (FSE). 2008.
[63] B. C. Pierce and D. N. Turner. Local type inference. ACM Transactions on