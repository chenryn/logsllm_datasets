表明禁止反汇编及反编译。
②AddNum函数仅仅返回两个参数值的相加结果。在实际的编程中，这种函数
是不需要的。为了说明品数调用的机制，这里特意使用了这种简单的品数。
③在命令提示符上运行的程序中，main品数位于程序运行起始位置。而在
Windows上运行的程序中，WinMain函数位于程序运行起始位置。程序运
行起始位置也称为“入口点”。
更多资料请关注裁的新浪薄客http：//blog
---
## Page 192
第10章通过汇编语言了解程序的实际构成
lq + e uxnqex
//调用Addun函数的函数
void MyFume()
c - AddBum(123, 456);
int cj
由Windows开始菜单启动命令提示符，把当前目录变更到Sample4.c
保存的文件夹后，输人下面的命令并按下Enter键。bcc32是启动
BorlandC++编译器的命令。“-c”选项指的是，仅进行编译面不进行链
接”。“-S”选项被用来指定生成汇编语言的源代码。
bce32 -c -S Sample4.c
作为编译的结果，当前目录下会生成一个名为Sample4.asm的汇编
语言源代码。汇编语言源文件的扩展名，通常用”asm”来表示。下面
就让我们使用记事本来看一下Sample4.asm的内容。可以发现，C语言
的源代码和转换成汇编语言的源代码是交叉显示的。而这也为我们对
两者进行比较学习提供了绝好的教材。在该汇编语言代码中，分号（：）
以后是注释。由于C语言的源代码变成了注释，因此就可以直接对
Sample4.asm进行汇编并将其转换成本地代码了（代码清单10-2）。
①当前目录指的是当前正在打开的目录（文件夹）。在命令提示符下对C语言
的源文件进行编译时，该文件所在的目录必颁是当前目录，所以有时候就
需要史换当前目录。变换当前目录时，只需在命令提示持中的“CD”后面
空上一个半角空格，然后加上需要跳转的目录，再按下田车即可。例如，
如果要将Test指定为当前目录的话，只需输入CDTest然后接下回车键印
可。CD是Change Dirctory 的略称。
②键接是指把多个目标文件结合成1个可执行文件。详情请参考第8章。
---
## Page 193
10.2通过编译器出汇编语言的源代码
代码清单10-2编译器生成的汇编语言源代码（一部分做了省略，彩色部分是转换成注
释的C语言源代码）
TEXT
segment dvord puablic use32 ·coDE
_DATA
_TEXT
segment dvord public use32 *DATA"
enda
_BS8
DATA
ende
DGROUP group
BSS
ends
_BSS,_DATA
_TEXTsegment dvord public use32·coDE
_AddNun
proe
near
int Asdhum(int a. int b)
push
ebp
tOV
ebp,esp
cecuxn
+
nOV
eax, dvord ptr [ebp+8]
add
eax,dvord ptr [ebp+12]
pop
ret
ebp
_AddNum
endp
_MyPunc
proe
near
void MyPune()
puah
ebp
nov
ebp,esp
int c1
C=
Puoh
456
push
ca11
123
_Addlun
add
esp.8
---
## Page 194
第10章通过汇编请言了解程序的实际构成
pop
ebp
ret
_MyFunc
endp
_TEXT ends
end
10.3不会转换成本地代码的伪指令
第一次看到汇编语言源代码的读者可能会感到有些难，不过实际
上很简单。而且毫不夸张地说它比C语言还要简单。为了便于阅读汇
编语言编写的源代码，在开始源代码内容的讲解前，让我们先来看一
下下面几个要点。
汇编语言的源代码，是由转换成本地代码的指令（后面讲述的操作
码）和针对汇编器的伪指令构成的。伪指令负责把程序的构造及汇编的
方法指示给汇编器（转换程序）。不过伪指令本身是无法汇编转换成本
地代码的。这里我们把代码清单10-2中用到的伪指令部分摘出，如代
码清单10-3所示。
代码清单10-3从代码清单10-2中摘出的伪指令部分（彩色部分是伪指令）
_TEXT
segment dvord publie uee32 ·copg
_DATA
segment dvord publie uee32 DATA
ende
_DATA
_BSS
segment dvord public use32 Bss1
enda
DGROUP group
_BSS
enda
_BSS,_DATA
_TEXT segment dvoxd public use32 coDg"
_Addlum
PTOC
near
_Addpum
endp
---
## Page 195
10.3不会转换成本地代码的伪指令
_MyFunc
_HyFunc
LXSL
由伪指令segment和ends围起来的部分，是给构成程序的命令和
数据的集合体加上一个名字而得到的，称为段定义。段定义的英文表
达segment具有“区域”的意思。在程序中，段定义指的是命令和数据
等程序的集合体的意思。一个程序由多个段定义构成。
源代码的开始位置，定义了3个名称分别为_TEXT、_DATA、_BSS
的段定义。_TEXT是指令的段定义，_DATA是被初始化（有初始值）
的数据的段定义，BSS是尚未初始化的数据的段定义。类似于这种段
定义的名称及划分方法是BorlandC++的规定，是由BorlandC++的编
译器自动分配的。因而程序段定义的配置顺序就成了_TEXT、_DATA、
BSS，这样也确保了内存的连续性。group这一伪指令，表示的是把
BSS和DATA这两个段定义汇总为名为DGROUP的组。此外，栈和
堆的内存空间会在程序运行时生成，这一点已经在第8章中做过介绍。
围起_AddNum和_MyFun的_TEXT segment 和_TEXT ends，表
示_AddNum和_MyFunc是属于_TEXT这一段定义的。因此，即使在
源代码中指令和数据是混杂编写的，经过编译或者汇编后，也会转换
成段定义划分整齐的本地代码。
_AddNum proc和_AddNum cndp围起来的部分，以及_MyFunc
①段定叉（segment）是用来区分或者划定范国区城的意思。汇编语言的
segmem伪指令表示投定义的起始，ends伪指令表示段定义的结束。段定
又是一个连续的内存空间。
②gOup指的是将源代码中不同的段定义在本地代码程序中整合为一个。
更多资料请关注裁的新浪薄客http：//blog
---
## Page 196
第10章通过汇编语言了解程序的实际构成
proc和MyFunc endp围起来的部分，分别表示AddNum函数和
MyFunc函数的范围。编译后在函数名前附带上下划线（_），是
Borland C++的规定。在C语言中编写的AddNum函数，在内部是以
_AddNum这个名称被处理的。伪指令proc和endp围起来的部分，表
示的是过程（procedure）的范围。在汇编语言中，这种相当于C语言的
函数的形式称为过程。
末尾的end伪指令，表示的是源代码的结束。而至于其他伪指令
的具体意思，大家不了解也没有关系。因为该章的主要目的并不是用
汇编语言来编写程序。大家只需要能读懂汇编语言的源代码就足够了。
10.4汇编语言的语法是“操作码+操作数”
在汇编语言中，1行表示对CPU的一个指令。汇编语言指令的语
法结构是操作码+操作数（也存在只有操作码没有操作数的指令）。
操作码表示的是指令动作，操作数表示的是指令对象。操作码和
操作数罗列在一起的语法，就是一个英文的指令文本。操作码是动词，
操作数相当于宾语。例如，用汇编语言来分析“Giveme money”这个
英文指令的话，Give就是操作码，me和money就是操作数。汇编语言
中存在多个操作数的情况下，要用逗号把它们分割开来，就像Giveme，
money这样。
能够使用何种形式的操作码，是由CPU的种类决定的。表10-1对
代码清单10-2中用到的操作码的功能进行了整理，大家可以看一下。
这些都是32位x86系列CPU用的操作码。操作数中指定了寄存器名、
①在汇编语言中，类似于mov这样的指令称为“操作码”（opcode），作为指
以直接解析运行的二进制的操作码和操作数，就是本地代码。
82
---
## Page 197
10.4汇编语言的语法是操作码+操作数
内存地址、常数等。在表10-1中，操作数是用A和B来表示的。
表10-1代码清单10-2中用到的操作码的功能
操作码
操作数
功能
mov
A,B
把B的值赋给A
and
A, B
把A同B的值相加，并将结果赋给A
push
4
把A的值存储在栈中
pop
从栈中读取出值，并将其赋给A
call
A
调用函数A
rel
无
将处理返回到函数的调用源
本地代码加载到内存后才能运行。内存中存储着构成本地代码的
指令和数据。程序运行时，CPU会从内存中把指令和数据读出，然后
再将其存储在CPU内部的寄存器中进行处理（图10-2）
CPU
内存
寄存样
eax
命令
obx
解析、运行
命令
ecx
命令
edx
命令
e9
数据
读出
数据
edi
ebp
数据
写入
数据
esp
数据
图10-2CPU和内存的关系
更多资料请关注我的新浪薄客t
---
## Page 198
第10章通过汇编语言了解程序的实际构成
寄存器是CPU中的存储区域。不过，寄存器并不仅仅具有存储指
令和数据的功能，也有运算功能。x86系列CPU的寄存器的主要种类
和角色如表10-2所示。寄存器的名称会通过汇编语言的源代码指定给
操作数。内存中的存储区域是用地址编号来区分的。CPU内的寄存器
是用cax及ebx这些名称来区分的。此外，CPU内部也有程序员无法
直接操作的寄存器。例如，表示运算结果正负及溢出状态的标志寄存
器及操作系统专用的寄存器等，都无法通过程序员编写的程序直接进
行操作。
表10-2x86系列CPU的主要寄存器