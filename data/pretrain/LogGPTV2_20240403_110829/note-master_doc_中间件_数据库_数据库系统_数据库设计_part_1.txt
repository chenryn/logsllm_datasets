---
tags: ['数据库']
books: [
  {name: '数据库系统概念'}
]
---
# 数据库设计
- 需求分析
- 概念设计：进行建模，决定数据库应该要有哪些实体，实体要有哪些属性。比如使用ER模型进行设计。
- 逻辑设计：将概念设计得到的模型映射到数据所使用的模型上。
- 物理设计：包括文件组织的形式以及内部的存储结构。
## 设计选择
在设计时，我们必须确保避免两个主要的缺陷：
- 冗余
- 不完整
更大还是更小：
- 更大的模式 比如department模式与student模式进行合并，得到两个模式的连接结果dept_stu 问题：
  - 数据冗余
  - 有些情况无法表示
- 更小的模式： 如何发现一个模式需要分解成n个更小的模式？ **函数依赖** 定义这样的一条规则：如果存在模式（dept_name,budget）,则dept_name可以作为主码，那么这就叫函数依赖 记作：x → y **有损分解**：分解过后无法表达一些重要的信息。 **无损分解**：上面取反
### 设计异常
不符合范式的关系
- 冗余数据
- 修改异常
- 删除异常
- 插入异常
## ER模型
- 实体：对象
- 属性：实体通过一组属性来表示，每个属性都有一个值
  - 每个属性都有一个可取值的集合，称为该属性的域，属性类型的划分：
    - 简单和复合
    - 单值和多值
    - 派生属性
- 实体集：实体构成的集合
- 联系：多个实体间的相互关联，实体在联系中扮演的功能称为实体的角色，联系也可以具有描述性属性
- 联系集：相同类型联系的集合
### 扩展
- ISA
- Part-Of
## 约束
### 映射基数
- 一对一
- 一对多
- 多对一
- 多对多
### 参与约束
- 全部参与
  - 如果实体集E中的每个实体都参与到联系集R的至少一个联系中
  - 那么E在R就是全部参与
- 部分参与
### 码
实体的码是一个足以分区每个实体的属性集，同样，码也可以用于唯一标识联系
## 从实体集中删除冗余属性
当决定好实体集后，必须挑选合适的属性
## ER图
### 基本结构
- 分割成两部分的矩形：实体集
- 菱形：联系集
- 未分割的矩形：联系集的属性
- 线段：实体集与联系集的连接
- 虚线：联系集到联系集的连接
- 双线：实体在联系集中的参与度
- 双菱形：连接到弱实体集的标志性联系集
- 带箭头的线：代表箭头所指的那方实体映射基数为1
- 不带箭头的线：代表箭头所指的那方实体映射基数为多
### 复杂的属性
比如
Address
  - city
  - street
### 角色
通过在菱形和矩形之间的连线上进行标注来表示角色
### 非二元的联系集
即一个联系连接了两个以上的实体
![批注 2020-03-08 205525](/assets/批注%202020-03-08%20205525.png)
### 继承关系
![批注 2020-03-08 205614](/assets/批注%202020-03-08%20205614.png)
### 弱实体集
- 没有足够的属性以形成主码的实体集称为**弱实体集**
- 有主码的实体集称为**强实体集**
## 转换为关系模式
- 逻辑结构设计
### 具有简单属性的强实体集表示
比如实体集student，有三个属性：ID、name、credit，可以转换成如下关系模式：
```sql
student(ID,name,credit)
```
### 具有复杂属性的强实体集的表示
比如student有一个属性address，又有子属性city，street，那么可生成关系模式：
```sql
student(ID,name,credit,city,street)
```
### 弱实体集的表示
设A为一个弱实体集，B为A所依赖的一个强实体集。那么可以创建一个关系模式：
B(a1,a2,a3,x)，其中a1，a2，a3为B的属性，x为B到A的外键约束
### 联系集的表示
设R为联系集，a1，a2...an为参与R的实体集构成的属性集合，b1，b2...bn为R的属性，则R的属性为：
{a1,a2..an}∪{b1,b2,...bn}
如何选取主码：
- 对于多对多的二元联系：参与实体集的主码属性并集成为主码
- 对于一对一的联系集：任何一个实体的主码都可以选作为主码
- 对于多对一或者一对多：多的那一方的实体集可以选取作为主码
#### 模式冗余
一般情况下，连接弱实体集与其所依赖的强实体集的联系集模式是冗余的。
#### 模式的合并
- 在一对一的联系的情况下：联系集的关系模式可以跟参与联系的任何一个实体集的模式进行合并
## ER设计问题
### 用实体集还是用属性
什么构成实体集，什么构成属性？这个问题要根据现实情况进行回答。
- **一个常见的错误是用一个实体集的主码作为另一个实体集的属性，而不是用联系**
- **另一个错误是将相关实体集的主码属性作为联系集的属性**
### 用实体集还是用联系集
一个原则是：**当描述发生在实体间的行为时采用联系集**
### 二元还是n元联系集
数据库中的联系通常都是二元的。
一些非二元的联系可以通过拆分分为二元联系，但是这样做，有时并不那么自然
### 联系属性的布局
属性放到哪里，是实体集还是联系集？这也是要根据实际情况进行决定
## 扩展的E-R特性
### 特化
自顶向下的，可以看做OOP当中父类转换成子类的这么样一个过程
### 概化
同上，类似于OOP中的向上转型
### 属性继承
高层实体集的属性可以被底层实体集继承
### 概化上的约束
数据库设计者可以决定哪些实体能成为给定低层实体集的成员，条件可以如下：
- 条件定义
- 用户定义
### 聚集
E-R模型的一个局限性在于它不能表达联系间的联系。聚集是一种抽象，它把联系视为高层实体，这样就可以表达联系之间的联系了
### 转换为关系模式
#### 概化的表示
- 为高层实体集创建一个模式，为每个低层实体集创建一个模式
- 如果概化是不相交并且完全的，就是说不存在同时属于两个同级的低层实体集的实体
#### 聚集的表示
聚集的主码是定义该聚集的联系集的主码
## 其他建模方式表达
- [UML](/软件工程/理论/UML.md)
## 范式
范式最重要的就是保证数据之间的关联一致性及控制数据冗余，这种保证会影响数据库的性能 所以在大数据量、高并发的场景下提倡反范式以此来提升性能
### 原子域与第一范式
一个域是原子的，如果该域的元素被认为是不可分的单元，我们称一个关系模式R属于第一范式。 简单来说：所有关系模式数据库都符合第一范式
### 第二范式
每个非主属性完全函数依赖于键码，说人话就是数据行的每个属性都可以由主键查询得到
## 函数依赖
### 码和函数依赖
一个关系满足需求定义的现实世界约束，称为关系的合法实例
- 给定R的一个实例，我们说这个实例满足函数依赖x → y 的条件是：对于实例中的所有元组t1，t2 ，若t1[x] = t1[x] ，则t1[y] = t2[y]，说人话就是 一个关系R中有两个属性x和y，如果x能够唯一确定y的值就说y函数依赖于x
- 如果R中的每个合法实例都满足函数依赖，则我们说该函数依赖在R上成立 有两种方式使用函数依赖：
  - 判定关系的实例是否满足给定函数依赖集F