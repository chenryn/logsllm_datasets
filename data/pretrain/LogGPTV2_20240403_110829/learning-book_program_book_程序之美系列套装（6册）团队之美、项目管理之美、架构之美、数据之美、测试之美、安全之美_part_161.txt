重叠，于是开始了“大都市"的城市规划灾难。
2.1.2现状
“大都市"的设计几乎完全是无可救药的一相信我，随着时间的推
移，我们也尝试过修复它。修复工作需要返工、重构、修改代码结
构中的问题，这些已经成为不可能的任务。重写也不是省事的方
案，因为支持老的、巴罗克式的控制协议是需求的一部分。你可以
看到，“大都市”的“设计”产生的后果是残酷的，并且会无情地变得
更糟。很难加入新的特性，所以人们只是忙着添加更多不完善的功
能、救急补丁和编造的谎言。没有人在面对代码时感到愉快，项目
正盘旋着向下裁。缺乏设计导致了不良的代码，从而又导致了不良
的团队精神和不断变长的并发周期。这最终导致了公司严重的财务
问题。最后，管理层宣布“混乱大都市"已经不盈利了，它被抛弃
了。对于任何组织机构来说，这都是勇敢的一步，特别是这个公司
一直都眼高手低，同时文试图避免沉沦。带着团队从以前版本中得
到的所有C++和Linux经验，他们在Windows上用C#重写了系统。猜
猜看会怎么样。
2.1.3来自“大都市"的名信片
那么我们学到了什么？不良的架构会产生深远的影响和严重的反
弹。在“混乱大都市"中缺少预见性和架构设计，导致了下面的问
题：
低品质的软件和漫长的版本发布周期。
系统没有弹性，不能够适应变更或添加新的功能。
无处不在的代码问题。
员工问题（压力大、士气低、跳槽等）。
903
---
## Page 905
大量混乱的公司内部政治。
公司不能成功。
许多痛苦和面对代码深夜加班。
2.2设计之城
形式永远服从功能。
Louis Henry Sullivan
“设计之城"软件项目表面上与“混乱大都市"非常相似。它也是用
C++写的消费音频产品，运行在Linux操作系统上。但是，它的构建
方式有很大不同，所以内部结构也非常不同。
我从一开始就参加了“设计之城"项目。我们用有能力的开发者组成
了一个全新的团队，从头并始构建这个产品。团队很小（并始有4
名程序员），像“大都市"项目一样，团队的结构是扁平的。幸运的
是，没有出现“大都市”项目中的个人对抗，在团队中也没有出现任
何争权夺利的事。在此之前，团队成员之间并不非常熟悉，不知道
我们在一起可以配合得多好，但我们对这个项目都很热心，喜欢这
项挑战。
这样很好。
Linux和C++是项目早期的决定，这项决定确定了团队成员的组成。
从一开始，项目就有清晰定义的目标：具体的首个产品和将来功能
的路线图，代码集必须能够支持这些功能。这将是一个通用目标的
代码集，可以适用于多种产品配置。
开发过程采用了极限编程（XP）（Beck和Andres2004），很多人相
信这种并发过程避并了设计：直接并始编码，不要想太远。实际
上，一些旁观者对我们的选择感到震惊，并预言项目将以泪收场，
就像“大都市”一样。但这是一种常见的误解。XP没有贬低设计，它
贬低的是不必要的工作（即YAGNI原则，YouAren'tGoingToNeed
It）。但是，如果需要前端设计，XP就要求你进行设计。它也鼓励
使用快速原型（所谓的"spike"），快速展现并验证设计的有效性。
这些都非常有用，对最终的软件设计产生了极大的影响。
904
---
## Page 906
2.2.1设计之城的第一步
在设计过程的早期，我们确定了主要的功能领域（这包括核心的音
频通道、内容管理和用户控制/界面）。我们考虑了它们如何在系统
中适配，推出了初步的架构，包括了实现性能需求所必需的核心线
程模型。
系统中各独立部分的相对位置关系体现为传统的分层结构，图2-2展
示了简化后的结果。请注意，这并不是庞大的前端设计。它是有意
为之的“设计之城”的简单概念模型：图中只有一些大块，这是一个
基本的系统设计，可以随着功能模块的添加而轻松地增长。虽然很
基本，但这个初始架构为增长提供了坚实的基础。“大都市"没有总
体规划，在"方便"的地方嫁接（或修补）功能。
我们在系统的核心上花了额外的设计时间：音赖通道。它实际上是
整个系统的一个内部子架构。为了确定它，我们考虑了穿过一系列
组件的数据流，最后得到了一个“过滤器和管道”音频架构，如图2-3
所示。根据产品的不同物理配置，它包含了这样一些管道。同样，
开始时这些管道只是一个概念，即图中的一些方块。我们当时还没
有决定如何将所有模块拼装在一起。
用户界面
控制组件
音频通道
OS/音频编解码
图2-2：“设计之城”的初始架构
905
---
## Page 907
音频文件
音频硬件
图2-3：“设计之城"的音频管道
我们在早期也选择了项目将采用的支持库（例如，可以从
http://www.boost.org获得的BoostC++库和一组支持数据库的库）。
关于一些基本关注点的决定是这时候做出的，目的是确保代码能够
容易而一致地增长，这些决定包括：
我们如何对事物命名。
顶层文件结构。
"内部”展示的风格。
共用的编码惯例。
选择单元测试框架。
支持基础设施（例如版本控制、适合的构建系统和持续集成）。
这些“细节"完美的因素非常重要：它们与软件架构密切相当，影响
到后来的许多决定。
2.2.2故事展开
在团队完成了初始设计之后，“设计之城”项目按照XP过程推进。设
计和编码要么以结对的方式完成，要么经过仔细的复审，确保工作
的正确性。
随着时间的推移，设计和代码不断发展和成熟；随着“设计之城"的
故事逐渐展开，产生了下面的结果。
定位功能
906
---
## Page 908
由于从一开始我们就有系统结构的清晰总体视图，所以新的功能单
元可以一致地添加到代码集的正确功能区域。代码应该属于哪一块
从来就不是问题。在扩展功能或修复问题时，我们总是很容易找到
已有功能的实现代码。
现在，把新的代码放到“正确”的位置有时候比简单“嫁接"到方便而
不妥的地方而更难一些。所以，架构规划的存在有时候让开发者的
工作变得更难一些。这些额外工作的回报就是今后的生活要容易很
多，当我们维护或扩展系统时，不愉快的事情会很少。
注意：架构有助于定位功能：添加功能、修改功能或修复缺陷。它
为你提供了一个模板，让你将工作纳入到一张系统导航图中。
一致性
整个系统是一致的。各个层次的所有决定都是在整个设计的背景下
做出的。开发者从一开始就有意为之，这样得到的所有代码都完全
符合系统设计，并与编写的所有其他代码相匹配。
在项目的历史中，尽管有许多变更，涉及代码集的各处（从单行代
码到系统结构），但这些变更都符合最初的设计模板。
注意：清晰的架构设计将导致一致的系统。所有决定都应该在架构
设计的背景下做出。
顶层设计的好风格和优雅很自然会为较低的层带来好处。即使在最
低层，代码也是统一而整洁的。清晰定义的软件设计确保了没有重
复，熟悉的设计模式到处使用，熟悉的接口惯例普遍采用，没有特
殊的对象生命周期或奇怪的资源管理问题。代码是在城市规划的背
景之中写成的。
注意：清晰的架构有助于减少功能重复。
架构的增长
有一些全新的功能领域出现在了设计“全图”中，例如存储管理和外
部控制功能。在“大都市"项目中，这是致命的一击，难度超乎想
象。但在"设计之城”项目中，事情就不一样了。
907
---
## Page 909
系统设计就像代码一样，被认为是可扩展、可重构的。并发团队的
一项核心原则就是保持敏捷，没有什么是一成不变的，所以在需要
时架构也可以修改。这促使我们让设计保持简单并易于修改。这样
一来，代码可以快速地增长，同时文保持好的内部结构。添加新的
功能块不是问题。
注意：软件架构不是一成不变的。需要时就改变它。要想做到可以
修改，架构就必须保持简单。牺牲简单性的修改要抵制。
延迟设计决定
有一项XP原则确实提高了“设计之城”的架构品质，这就是
YAGNI（如果你不是马上需要，就不要去做）。这促使我们在早期
只设计了重要的部分，将所有余下的决定推迟，直到我们对实际的
需求有了更清晰的理解并知道如何放到系统中最好时，再做出这些
决定。这是一种非常强大的设计方法，在很大的程度上解放了我们
的思想。
·当你还不理解问题时就开始设计，这是一件糟糕的事。YAGNI迫使
你等待，直到你知道真正的问题是什么，它应该怎样由设计来体现
为止。这消除了猜测的工作，确保设计是正确的。
当你并始创建软件设计时就加入所有可能需要的东西（包括厨房水
槽）是危险的。你的大部分设计工作会变成无用功，得到的只是额
外的负担，你不得不在软件的整个变更生命周期中支持这些设计。
它一并始就增加了成本，而且在项目的生命周期中不断增加成本。
注意：延迟设计决定，直到你必须做出这些决定为止。不要在你还
不知道需求的时候就做出架构决定。不要猜测。
保持品质
从一开始，“设计之城”就准备好了一些品质控制过程：
结对编程。
对没有结对编程的工作进行代码/设计复审。
对每一段代码进行单元测试。
908
---
## Page 910
这些过程确保了系统中从未加入不正确的、不合适的变更。所有不
符合软件设计的内容都被拒之门外。这可能听起来有点过于严厉，
但这些是并发者们坚信的过程。
这种信念凸显了一个重要的态度：并发者们相信设计，认为设计对
项目相当重要。他们拥有设计，对设计负责。
注意：必须保持架构品质。只有当并发者们相信它并对它负责时，
才能做到这一点。
管理技术债务
除了这些品质管理方法之外，“设计之城”的并发是相当注重实效
的。随着最后期限的临近，一些不太重要的功能被砍掉，让产品能
够准时推出。小的代码“瑕藏”或设计问题允许存在于代码集中，要
么是为了让功能快一点实现，要么是为了在接近发布时避免高风险
的改动。但是，与“混乱大都市"项目不同的是，这些逃避职责的地
方被标记为技术债务，并安排在后续的版本发布中修正。这些问题