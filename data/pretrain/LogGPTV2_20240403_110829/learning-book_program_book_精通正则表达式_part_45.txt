## Page 297
消除循环
271
与上一个例子一样，固化分组不是必须的，但它能让引擎更快地报告匹配失败。
消除CSV正则表达式中的循环
第5章用了很长的篇幅讨论CSV的处理，最后得到第216页的代码：
(？:~1,)
（？：#或者是匹配双引号字段（其中容许出现连在一起的成对双引号）.：，
“#（起始双引号）
((?：[^"]1")*)
“#（结束双引号）
#·，或者是引号和追号之外的文本..
（[,}*）
)
当时的结论是，最好在开头添加G，这样就能避免驱动过程带来的麻烦，并且效率也会提
高。现在我们知道如何消除循环，就可以此技巧来看看如何应用这个例子。
用来匹配微软的CSV字符串的正则表达式是（？：[^"11"")*，它看起来很不错。其实，这
个表达式已经区分了normal和special部分：[^"]；和"""。下面我们把这个表达式写清楚，
用原来的Perl代码说明消除循环的过程：
while (Sline =~ m(
\G(？:^|,)
(? :
#或者匹配双引号字段（其中容许出现连在一起的成对双引号）？
"#起始双引号
（（[v]<2）（*[uv]<2））
”#结束双引号
#...或者是
或者是引号和追号之外的文本.，
（[=,]*）
1
(x6(
if (defined S2)(
$field = $2;
}else{
sfield=$1;
$field =~ s/**/"/g;
现在处理Sfield...
如其他的例子一样，固化分组不是必须的，但可以提高效率。
---
## Page 298
272
第6章：打造高效正则表达式
消除C语言注释匹配的循环
LInrollingCConments
现在来看个匹配更复杂字符串时消除循环的例子。在C语言中，注释以/*开头，*/结尾，
可以有多行，但不能嵌套（C++、Java和C#也容许这种形式的注释）。匹配此类注释的正
则表达式在许多情况下都有用，例如构建去掉注释的过滤程序。写这个程序时我首先想到
的就是消除循环，而这个技巧现在已经成为我的正则表达式宝库中的重要装备。
真的需要消除吗
我在20世纪90年代早期就开始开发本节讨论的这个正则表达式。在那之前，人们认为用
正则表达式匹配C语言的注释即使不是不可能，也是很困难的事情，所以一些可行的办法
由我开发出来之后，就成为匹配C语言注释的标准方法。不过，在Perl引入忽略优先量词
之后，出现了简单得多的办法：使用能匹配所有字符的点号/\*.*？\*/。
在我写程序的时候忽略优先量词还没有出现，如果当时有这种现成的特性，就不用费这么
多周折了。不过，我的解决办法仍然是有效的，因为即使在首次支持忽略优先量词的那-
版Perl中，使用消除循环技巧的程序仍然要比使用忽略优先量词的快得多（我做了许多种
测试，有时快50%，也有时快360%）。
不过，Perl现在综合了各种优化措施，形势就颠倒过来，忽略优先量词的程序要快上50%
到550%。所以我现在使用*.*？\*/来匹配C语言的注释。
这是否意味着，现在匹配C语言注视用不着消除循环的技巧了？如果引擎不支持忽略优先
量词，消除循环的价值就能体现出来。也不是所有的正则引擎都能综合各种优化：在我测
试的其他任何语言中，消除了循环的程序都要更快一最快的时候速度相差60倍！消除循
环的技巧确实很有用，所以下文讲解如何用它来匹配C语言注释。
因为匹配C语言注释时不存在双引号字符申中转义字符\“的问题，可能有人觉得事情会比
较简单，但问题其实更复杂。因为这里的“结束双引号”*/不止一个字符。直接用
/\*[^*]*\*/可能看起来没问题，但不能匹配/**somecommenthere**/，因为其中还
有‘*'，而这是必须匹配的，所以我们需要另外的办法。
D
---
## Page 299
消除循环
273
换更清晰的表示方法
注释部分的边界符‘*’本身就是正则表达式的元字符，所以得使用反斜线转义，结果正则
表达式看起来让人头疼。为了看得更清楚，我们在这个例子中使用/xx/，而不是/*.*/。
经过这个细微的改动，/\*[^*]*\*/变成了更容易看懂的/x[^x]*x/。这个表达式会随着
我们的讲解变得越来越复杂，到时你会发现这个改动的价值。
直接的办法
在第5章（196），我给出了匹配分隔符之内文本的公式：
1.匹配起始分隔符；
2.匹配正文：匹配“除结束分隔符之外的任何字符”
3.匹配结束分隔符。
现在我们的程序以/x和x/作为开始和结束分隔符，它似乎很符合这个模式。难处在于匹配
“除结束分隔符之外的任何字符”。如果结束分隔符是单个字符，我们可以用排除型字符组。
但字符组不能用来进行多字符匹配，不过如果能使用否定型顺序环视，我们就能使用
（？：（？！x/）.）*1。这就是“除结束分隔符之外的任何字符。
于是我们得到/x（？：（？！x/）.）*x/。它没有问题，但速度很慢（在我做的一些测试中，速
度要比下面的表达式慢几百倍）。这个思路很有用，但缺乏实用性，因为几乎所有支持顺序
环视的流派都支持忽略优先量词，所以效率并不是问题，你完全可以用"/x.*?x/1。
那么，顺着这种分三步走的思路，是否有其他办法匹配第一个×/之前的文本？能想到的办
法有两个。之是把x作为开始分隔符和结束分隔符，也就是说，匹配除×之外的任何字
符，以及之后字符不为斜线的x。这样，“除结束分隔符之外的任何字符”就成了：
·除×之外的任何字符：[^x]
·
之后字符不是斜线的x：x[^/]l。
这样得到（[^x]1x[~/]）*来匹配主体文本，/x（[^x]1x[~/]）*x/来匹配整个注释。我们]
会发现这条路行不通。
---
## Page 300
274
第6章：打造高效正则表达式
另-种办法是，把紧跟在×之后斜线当作结束分隔符。这样“除结束分隔符之外的任何字
符”就成了：
·除斜线外的任何字符：（~/]。
·紧跟在x之后的斜线：[^x]/1。
于是用（（~/]1[^x]/）*匹配主体文本，/x（[~/]1[^x]/）*x/匹配整个注释。
不幸的是，这同样是死路。
如果用/x（[^x]1x[~/1)*x/来匹配‘/xx*foo*xx/'，在‘foo'之后，第-个x由x[~/]！
匹配，这当然没有问题。但是之后，x~/J匹配x/，而这个x应该是标记注释的结束。
于是继续下一轮选代，[^x]：匹配斜线，结果会匹配x/之后的文本。
/x（（~/)1{^x）/)*x/也不能匹配“/x/·foo·/x/’（整个注释都应该匹配）。如果注释结尾
后紧跟斜线，表达式匹配的内容会超过注释的结束分隔符（这也是其他解法的问题）。而在
本例中，回溯可能有些令人迷惑，所以读者最好弄明白/x（[^/]1（^x]/)*x/为什么能匹
配
Years = days /x divide x//365, /x assume non-1eap year x/
（可以在空余时间好好想想这个问题。）
怎么办
让我们来修正这些表达式。在第一种情况下，因为疏忽，x[~/1匹配了结尾的xx/。如果
我们用/x（[^x]1xt[~/])*x/1。我们认为，添加加号之后，x+[~/]匹配以非斜线字符结
尾的一连串x。确实它能够这样匹配，但因为回溯“斜线之外的任意字符”仍然可以是×。
首先，匹配优先的x+匹配我们需要的额外的x，但是如果全局匹配需要，回溯会逐个释放
它们。所以它仍然会匹配过多内容：
/xxAxx/foo()/xxBxx/
要解决这个问题，还得回到之前介绍的办法：准确表达我们希望表达的意思。如果我们说
的“紧跟字符不是斜线的些x”其实就是除×之外的非斜线字符，就应该用x+[~/α]。
它不会匹配“xxx/，一连串x中表示注释结束的那个x。事实上，它还有个问题，就是
无法匹配注释结束之前的任意多个x，所以会在‘"xxx/停下来。因为我们预计结束分
隔符前只有-一个x，所以必须加人‘xt小处理这种情况。
于是得到'/x（[^x]x+[^/x]）*x+/，匹配最终的注释。
---
## Page 301
消除循环
275
在自然语言和正则表达式之间翻译
到两种办法：
x，之后的字符不是斜线：x[~/]1
斜线，之前的字将不是x：[^x]/1
这种做法并不正式一一自然语言的描述与正则表达式是非常不同的，你发现了吗？
要看这两者的差别，想象第一个表达式匹配宇符串‘regex’的情况，最后的x之后
没有斜线，但它不能被'x[^/]匹配。宇符组必须匹配一个宇符，尽管这个宇符不能是
斜线，但它必须存在，可regex”中的x之后没有任何宇符。第二个表达式的情况
与此类似。当时，我们需要的正是符合这两个要求的表达式，所以自然语言的表述是
错误的。
如果能使用顺序环视，“x，之后的字符不是斜线”可以直接写做x（？！/）1。如果不能，
就可以使用x（[^/]1S）。它仍然需要匹配x之后的宇符，但也可以匹配宇符串的结尾。
如果能够使用逆序环视，“斜线，之前的字符不是x”就可以表示为（?<!x）/1。如果
不能，就需要使用（~1[^x]）/1。
在这个例子中，我们没有使用上述的任何一种办法，但知道有这些办法并不是坏事。
这看起来很迷惑，对吗？真正的表达式（用*取代x）就是"/\*（（^*]1\*+[~/*]）*\*+/)，
这样更复杂了，更不容易看懂，所以在理解复杂的正则表达式时，一定要保持清醒的思维。
消除C语言注释的循环
为了提高表达式的效率，我们必须消除这个表达式的循环。下一页的表6-3给出了我们能够
“消除循环”的表达式。
和子域名的例子一样，normal*必须匹配至少一个字符。子域名的例子中是因为normal部
分不能为空。本例中必须的结束分隔符包含两个字符。我们确信，任何以结束分隔符的第
一个字符结尾的任何normal序列，只有在紧跟字符不能组成结束分隔符的情况下，才会把
控制权交给special部分。
---
## Page 302
276
第6章：打造高效正则表达式
表6-3：消除C语言注释的循环
opening normal*(special normal*)* closing
元素
目的
正则表达式
opening
注释开始
/x
norma1*
注释文本，包含一个或多个‘x
[~×] *x+
special
不属于结束边界符的字符
[~/ x]
closing
结尾的斜线
/
所以，按照通用的消除套路，我们得到：
/（+x[x][x/]²）+x[x]×/
请注意标注的位置。正则引擎可能有两种办法到达此处（267页的表达式也是如此）。第一
个是在开头的/x[^x]*x+匹配之后直接前进到此处，第二是在（）*循环的某一轮中。无
论哪种情况，只要到达此处，我们就知道已经匹配了x，到达关键位置（pivotalpoint），可
已经进入了注释的结尾分隔符。如果下面的字符是斜线，则匹配完成。如果是其他字符（当
然不是x），我们知道之前的判断是错误的，然后回到normal部分，等待下一个x。找到之
后我们再一次回到标记位置。
回到现实
/x[^x]*x+（[~/x][^x]*x+）*/还不能直接拿来用。首先，注释是/*.…*/而不是/×x/。
当然，我们可以很容易地把每个x替换为x（字符组中的x替换为*）：
[/x（+[][/])+x1×[]\/
实际情况中，注释通常会包括多行。如果匹配的注释包括多行，这个表达式也应该能够应
付。如果是严格以行为处理单位的工具，例如egrep，当然没办法用一个正则表达式匹配所
有的行。对本书中提到的大多数工具，我们的确可以用这个表达式来匹配多行，删除它们。
在实际中，会遇到许多问题。这个正则表达式能够识别C的注释，但不能识别C语法的其
他重要方面。例如，划线的部分尽管不是注释，也能够匹配：
const char *cstart="/**,*cend="*/*
我们会在下一节接着讨论这个例子。
---
## Page 303
流畅运转的表达式
277
流畅运转的表达式
The Freefloving Regex
我们花了不少时间来构建匹配C的注释的正则表达式，但是没有考虑如何避免字符串中的
错误匹配。使用Perl的话，你可能会想到用下面的程序过滤注释：
（i）#：B{}（/（+\[][/]：）+\[]\/}日~=boxs
表达式中，变量sprog保存的文本会被删除（也就是，被空文本替换掉）。问题在于，如果
在字符串内部找到注释的起始标记，正则表达式的匹配也不会停止，比如这段C代码：
char*CommentStart=*";/*startofcomment*/
char*CommentEnd=**/";endofcomment*/
这里，下画线标注的部分是正则表达式的匹配结果，但是粗体标注的部分才是我们期望的。
引擎寻找匹配时会在目标字符串的每个位置开始尝试匹配表达式。因为这种尝试只有在注
释开始的地方（或者是看起来有可能开始的地方）成功，所以在大部分位置都无法匹配，
传动装置的驱动过程继续向前，进人双引号字符串，其内容似乎是注释的开始。最好是能
够告诉正则引擎，遇见双引号字符串时是应该尝试匹配还是直接跳过。当然，我们确实能
做到这一点。
引导匹配的工具
A Helping Hand to Guide the Matclt
看下面的程序：
/（+\[]/]:）+\[]\/}xb=NNNOS
#匹配注释
{（]1：）}xD=000S
#匹配双引号字符串
Stext=~8/$DOUBLEISCOMMENT//g:
这里出现了两件新事物。其中之一是表达式‘SDOUBLEISCOMMENT，它由两个变量组成，都
使用了Perl特有的qr/…/正则表达式“双引号字符串”操作符。我们曾在第3章仔细讨论
过（101），如果用字符串表示正则表达式，使用字符串的时候必须格外小心。Perl提供的
qr/…/运算符解决了这个问题，它会把操作对象（operand）视为正则表达式，但不会实际
应用它。我们在第2章（76）已经看到，这样非常方便。与m/…/和s/…//一样，我
们可以自己选择分隔符（71)，上面使用的是花括号。
另一点是通过用SDOUBLE来匹配双引号字符串。传动装置驱动到SDOUBLE能匹配的位置时，
会一次性匹配整个双引号字符串。这里使用多选分支完全没有问题，因为二者之间并没有
---