![](../img/fig10-3.png)
**图 10-3 在使用者 ID 上进行的 Reduce 端连线。如果输入资料集分割槽为多个档案，则每个分割槽都会被多个 Mapper 并行处理**
当 MapReduce 框架透过键对 Mapper 输出进行分割槽，然后对键值对进行排序时，效果是具有相同 ID 的所有活动事件和使用者记录在 Reducer 输入中彼此相邻。Map-Reduce 作业甚至可以也让这些记录排序，使 Reducer 总能先看到来自使用者资料库的记录，紧接著是按时间戳顺序排序的活动事件 ——  这种技术被称为 **二次排序（secondary sort）**【26】。
然后 Reducer 可以容易地执行实际的连线逻辑：每个使用者 ID 都会被呼叫一次 Reducer 函式，且因为二次排序，第一个值应该是来自使用者资料库的出生日期记录。Reducer 将出生日期储存在区域性变数中，然后使用相同的使用者 ID 遍历活动事件，输出 **已观看网址** 和 **观看者年龄** 的结果对。随后的 Map-Reduce 作业可以计算每个 URL 的检视者年龄分布，并按年龄段进行聚集。
由于 Reducer 一次处理一个特定使用者 ID 的所有记录，因此一次只需要将一条使用者记录储存在记忆体中，而不需要透过网路发出任何请求。这个演算法被称为 **排序合并连线（sort-merge join）**，因为 Mapper 的输出是按键排序的，然后 Reducer 将来自连线两侧的有序记录列表合并在一起。
#### 把相关资料放在一起
在排序合并连线中，Mapper 和排序过程确保了所有对特定使用者 ID 执行连线操作的必须资料都被放在同一个地方：单次呼叫 Reducer 的地方。预先排好了所有需要的资料，Reducer 可以是相当简单的单执行绪程式码，能够以高吞吐量和与低记忆体开销扫过这些记录。
这种架构可以看做，Mapper 将 “讯息” 传送给 Reducer。当一个 Mapper 发出一个键值对时，这个键的作用就像值应该传递到的目标地址。即使键只是一个任意的字串（不是像 IP 地址和埠号那样的实际的网路地址），它表现的就像一个地址：所有具有相同键的键值对将被传递到相同的目标（一次 Reducer 的呼叫）。
使用 MapReduce 程式设计模型，能将计算的物理网路通讯层面（从正确的机器获取资料）从应用逻辑中剥离出来（获取资料后执行处理）。这种分离与资料库的典型用法形成了鲜明对比，从资料库中获取资料的请求经常出现在应用程式码内部【36】。由于 MapReduce 处理了所有的网路通讯，因此它也避免了让应用程式码去担心部分故障，例如另一个节点的崩溃：MapReduce 在不影响应用逻辑的情况下能透明地重试失败的任务。
#### 分组
除了连线之外，“把相关资料放在一起” 的另一种常见模式是，按某个键对记录分组（如 SQL 中的 GROUP BY 子句）。所有带有相同键的记录构成一个组，而下一步往往是在每个组内进行某种聚合操作，例如：
- 统计每个组中记录的数量（例如在统计 PV 的例子中，在 SQL 中表示为 `COUNT(*)` 聚合）
- 对某个特定栏位求和（SQL 中的 `SUM(fieldname)`）
- 按某种分级函式取出排名前 k 条记录。
使用 MapReduce 实现这种分组操作的最简单方法是设定 Mapper，以便它们生成的键值对使用所需的分组键。然后分割槽和排序过程将所有具有相同分割槽键的记录导向同一个 Reducer。因此在 MapReduce 之上实现分组和连线看上去非常相似。
分组的另一个常见用途是整理特定使用者会话的所有活动事件，以找出使用者进行的一系列操作（称为 **会话化（sessionization）**【37】）。例如，可以使用这种分析来确定显示新版网站的使用者是否比那些显示旧版本的使用者更有购买欲（A/B 测试），或者计算某个营销活动是否值得。
如果你有多个 Web 伺服器处理使用者请求，则特定使用者的活动事件很可能分散在各个不同的伺服器的日志档案中。你可以透过使用会话 cookie，使用者 ID 或类似的识别符号作为分组键，以将特定使用者的所有活动事件放在一起来实现会话化，与此同时，不同使用者的事件仍然散布在不同的分割槽中。
#### 处理偏斜
如果存在与单个键关联的大量资料，则 “将具有相同键的所有记录放到相同的位置” 这种模式就被破坏了。例如在社交网路中，大多数使用者可能会与几百人有连线，但少数名人可能有数百万的追随者。这种不成比例的活动资料库记录被称为 **关键物件（linchpin object）**【38】或 **热键（hot key）**。
在单个 Reducer 中收集与某个名人相关的所有活动（例如他们释出内容的回复）可能导致严重的 **偏斜**（也称为 **热点**，即 hot spot）—— 也就是说，一个 Reducer 必须比其他 Reducer 处理更多的记录（请参阅 “[负载偏斜与热点消除](ch6.md#负载偏斜与热点消除)”）。由于 MapReduce 作业只有在所有 Mapper 和 Reducer 都完成时才完成，所有后续作业必须等待最慢的 Reducer 才能启动。
如果连线的输入存在热键，可以使用一些演算法进行补偿。例如，Pig 中的 **偏斜连线（skewed join）** 方法首先执行一个抽样作业（Sampling Job）来确定哪些键是热键【39】。连线实际执行时，Mapper 会将热键的关联记录 **随机**（相对于传统 MapReduce 基于键杂凑的确定性方法）传送到几个 Reducer 之一。对于另外一侧的连线输入，与热键相关的记录需要被复制到 **所有** 处理该键的 Reducer 上【40】。
这种技术将处理热键的工作分散到多个 Reducer 上，这样可以使其更好地并行化，代价是需要将连线另一侧的输入记录复制到多个 Reducer 上。Crunch 中的 **分片连线（sharded join）** 方法与之类似，但需要显式指定热键而不是使用抽样作业。这种技术也非常类似于我们在 “[负载偏斜与热点消除](ch6.md#负载偏斜与热点消除)” 中讨论的技术，使用随机化来缓解分割槽资料库中的热点。
Hive 的偏斜连线最佳化采取了另一种方法。它需要在表格元资料中显式指定热键，并将与这些键相关的记录单独存放，与其它档案分开。当在该表上执行连线时，对于热键，它会使用 Map 端连线（请参阅下一节）。
当按照热键进行分组并聚合时，可以将分组分两个阶段进行。第一个 MapReduce 阶段将记录传送到随机 Reducer，以便每个 Reducer 只对热键的子集执行分组，为每个键输出一个更紧凑的中间聚合结果。然后第二个 MapReduce 作业将所有来自第一阶段 Reducer 的中间聚合结果合并为每个键一个值。
### Map侧连线
上一节描述的连线演算法在 Reducer 中执行实际的连线逻辑，因此被称为 Reduce 侧连线。Mapper 扮演著预处理输入资料的角色：从每个输入记录中提取键值，将键值对分配给 Reducer 分割槽，并按键排序。
Reduce 侧方法的优点是不需要对输入资料做任何假设：无论其属性和结构如何，Mapper 都可以对其预处理以备连线。然而不利的一面是，排序，复制至 Reducer，以及合并 Reducer 输入，所有这些操作可能开销巨大。当资料透过 MapReduce 阶段时，资料可能需要落盘好几次，取决于可用的记忆体缓冲区【37】。
另一方面，如果你 **能** 对输入资料作出某些假设，则透过使用所谓的 Map 侧连线来加快连线速度是可行的。这种方法使用了一个裁减掉 Reducer 与排序的 MapReduce 作业，每个 Mapper 只是简单地从分散式档案系统中读取一个输入档案块，然后将输出档案写入档案系统，仅此而已。
#### 广播杂凑连线
适用于执行 Map 端连线的最简单场景是大资料集与小资料集连线的情况。要点在于小资料集需要足够小，以便可以将其全部载入到每个 Mapper 的记忆体中。
例如，假设在 [图 10-2](../img/fig10-2.png) 的情况下，使用者资料库小到足以放进记忆体中。在这种情况下，当 Mapper 启动时，它可以首先将使用者资料库从分散式档案系统读取到记忆体中的散列表中。完成此操作后，Mapper 可以扫描使用者活动事件，并简单地在散列表中查询每个事件的使用者 ID [^vi]。
[^vi]: 这个例子假定散列表中的每个键只有一个条目，这对使用者资料库（使用者 ID 唯一标识一个使用者）可能是正确的。通常，杂凑表可能需要包含具有相同键的多个条目，而连线运算子将对每个键输出所有的匹配。