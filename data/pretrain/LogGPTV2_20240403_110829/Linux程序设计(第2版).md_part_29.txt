用nice命令启动这个程序可以改变它的优先级。我们将看到它的优先级被改为+10，结果是
执行这个程序要多花些时间。
S nice limits
Current priority = 10
CPU usage: User s 1.310000, System = 0.840000
Current FS12E 1init: 8oft = 214748364, hard  2147483647
Settang a 2k f1le size linit
File s1ze limit exceeded
操作注释：
limits程序调用work函数来模仿一个典型应用程序的动作。它执行了一些计算并做了一些输
出，本例是向临时文件写大约150K数据。它调用资源函数查看自身的优先级和文件长度限制。
本例中的文件长度限制最初被设置为最大值，在磁盘空间允许的情况下我们可以创建出长达
2GB的文件来。接下来，程序把自己的文件长度限制设置为只有2K，然后再次执行同样的工作。
这一次，work函数失败了，因为它不能再创建出那么大的临时文件了。
注意我们可以通过bash的ulimit命令给一个运行在某个特定shell下的程序加上限制。
在这个例子里，错误信息“Error writing totemporary file”可能不会象我们希望的那样显示
在屏幕上。这是因为某些系统（比如Linux2.2）会在程序超越资源限制的时候自动终止它的运
行，它会发出一个SIGXFSZ信号做到这一点。我们将在第10章对信号及其用法进行学习。其他
加入jaVa编程群：524621833
---
## Page 147
第4章UNIX环境
/29
4.9本章总结
在这一章里，我们学习了UNIX环境，对程序的运行条件进行了研究。我们讨论了命令行参
数和环境变量，这两样东西都能用来改变程序的默认行为，还可以为程序提供有用的操作选项。
我们还看到怎样才能让程序利用库函数处理日期和时间数据，怎样才能获取关于自身、用
户以及在其上运行的计算机的信息。
因为UNIX程序通常都要共享主机上的珍贵资源，所以我们对如何确定和管理资源的问题也
做了介绍。
一
加入jaVa编程群：524621833
---
## Page 148
第5章终端
先认真思考一下，看看对我们在第2章编写的基本应用程序都需要做哪些改进。它最明显的
缺陷莫过于用户操作界面了。在功能方面它倒没有什么问题，就是不够精致。
在这一章里，我们将学习如何加强对用户终端，也就是键盘输人和屏幕输出的控制。程序
需要从一个终端开始运行，而我们进一步的学习将涉及到如何确保用户向终端送去的各种输人
能够被馈人程序，而程序的输出又能够到达屏幕上的正确位置。在学习过程中，我们还将体会
到UNIX先驱们的良苦用心。
虽然重新编写CD唱盘管理软件的构想还要等到下一章才能见到曙光，但我们在这一章里学
习到的内容却是基础性的工作。下一章内容是对curses函数库的讨论。这可不是什么古代咒语大
全之类的东西（英文单词“curse”是咒语的意思），这是一个函数库，它提供了控制屏幕显示的
高级代码。读者可以把本章内容看做是下一章的铺垫，它会让大家熟悉UNIX里终端输人输出的
某些原理和概念。也许，我们在这一章里给出的底层访问手段恰好是读者正在寻找的东西。
在这一章里，我们将学习：
·对终端进行读写。
·终端驱动程序和通用终端接口（GeneralTerminalInterface）。
·termios函数库。
·终端的输出和terminfo功能包。
·检测键盘击键动作。
5.1对终端进行读写
通过第3章的学习，我们已经知道当程序从命令提示符处被调用的时候，shell会安排标准输
人和标准输出流连接到我们的程序。通过getchar和printf功能可以很容易对这些缺省文件流进行
读写，实现程序和用户之间的交流。
我们先用C语言把我们的菜单部分重写一遍，还使用getchar和printf这两个例程，我们给新
程序起名为menul.c。
动手试试：用C语言编写的莱单例程
1）程序开始部分的这些语句定义了一个用来显示菜单内容的字符数组和getchoice函数的框
架模型：
include 
char *nenu{}×{
“-delete record’,
add new record',
加入jaVa编程群：524621833
---
## Page 149
第5章终
'q-quit*,
} :
NULL.
int getchoice(char *greet.char *choices(1):
2）main函数以样本菜单menu为参数调用getchoice函数：
Int sain()
int choice = 0;
do
choice =getchoice(*Please select an action',menu);
}while（choice!'q'）;
printf(*You have chosen:c\n*,choice);
exit(0);
2
3）下面是关键性的代码：显示菜单和读取用户输入的函数getchoice：
int getchoice(char *greet，char *choices[])
int chosen 0:
int selected;
char **option;
do1
printf(*Choice:s\n*,greet):
while（*option）(
option s choices;
printf(*s\n*,*optlon);
option++;
selected =getchar():
while(*option)(
option = choices:
if(selocteds*option(0]）[
chosen = 1:
break;
option++;
1
if(tchosen）{
printf(·Incorrect choice,select again\n*):
}while(lchosen):
return selected;
操作注释：
getchoice函数显示程序的自我介绍greet和样本菜单choices，并提示用户选择一个代表某个
菜单选项的字母。接下来程序进入循环，直到getchar函数返回一个与option数组中某个数据项的
第一个字母匹配的字符为止。
编译并运行这个程序，我们将发现程序的行为和我们预计的并不一样。从下面这些操作对
话里可以看出点迹象来：
Sm1
Choice:
Please select an action
a-add new record
d-delete record
加入jaVva编程群：524621833
---
## Page 150
132Linux程序设计
q ~quit
You have chosen: a
Choice; Please select an action
a
add new record
prosaa ae:ap - p
g-quit
Incorrect choice.seect again
Choice.Please selcct an action
-p
add new record
delete recozd
q - quit
oo  
用户需要输人“a/回车/q/回车”才能做出选择。看起来至少有两个问题，比较严重的那个是
在每次i正确选择的后面都会出现-个“Incorrectchoice”（错误选择）提示。另外个是只有按
下回车键程序才会读取我们的输人。
为什么操作没有成功？
这两个问题是密切相关的。在系统缺省配置情况下，终端输人只有在用户按下回车键以后
才会传递给程序使用。在大多数情况里这样做是有好处的，因为这可以让用户通过Backspace
（后退）键和Delete（删除）键对打字错误进行修改。用户只有在对自己从屏幕上看到的东西满
意的时候才会按下间车键把输人送往程序。
这种行为被称为授权模式，也叫做标准模式。所有输人都是以行为单位进行处理的。在输
的处理都是由终端操作接口把持的，应用程序读不到任何字符。
它的对立面是非授权模式，此时程序对输人字符的处理有了更大的控制权。我们过一会儿
再回到这两种模式上来。
UNIX终端管的事情是挺多的，其中之一是喜欢把中断字符翻译为与之对应的信号，从面自
动地替用户完成对Backspace（后退）键和Delete（翻除）键的处理，而用户也就不必在自已编
写的每一个程序里重新实现它。我们将在第10章里看到更多的信号。
那么，我们的程序又是怎么一回事呢？是这样的：UNIX会在用户按下回车键之前先把输人
字符保存起来，然后把用户选中的字符和紧随其后的回车字符一起送到程序里去。这样，用户
对菜单每做一次选择，程序就会调用geichar对选择字符进行处理；然后再调用-次getchar，而
这次它将会立刻返回一个回车字符。
程序实际看到的字符并不是一个ASCII回车字符CR（十进制的I3，十六进制的OD），面是一
个行进纸字符LF（十进制的10，十六进制的0A）。这是因为，就其内部原理来说，UNIX总是用
个行进纸字符来结束文本行。也就是说，UNIX使用一个单独的行进纸字符来表示一个换行；
而其他系统一比如说DOS，要用两个字符来代表换行，一个回车加一个行进纸。如果输人或输
出设备送来或请求一个回车，UNIX的终端处理部分会负责弄好它。如果读者习惯了DOS或其他
环境，对这种做法多少会感到些奇怪，但UNIX自有其用意。在UNIX里，文本文件和二进制文
件是没有任何实际区别的，这样做也就无可厚非。对UNIX系统来说，只有在用户对某个终端或
加入jaVa编程群：524621833
---
## Page 151
第5章终端133
某些打印机和绘图仪进行输入输出时才需要对回车进行处理。
下面这些代码对多出来的回车字符进行过滤，把它加到我们的菜单程序里就可以改正其主
要错误了：
1op
它解决了我们的燃眉之急。要想解决“必须按下回车键才能让程序继续执行”的问题，我
们先得学点预备知识，最终我们将得到一个精巧的换行符解决方案。
5.1.1对重定向输出进行处理
UNIX程序，甚至交互式的UNIX程序，经常会把自已的输入或输出重定向到文件或其他程
序去。我们来看看当把我们的程序输出重定向到一个文件去的时候会出现什么样的情况：
S menul > f1le
d
我们可以把这种情况看做是成功，因为输出确实被重定向到文件里去了，没有出现在屏幕
上。但有时我们并不想这样做，或者我们想把准备让用户看到的提示信息与其他输出区别对待，
前者仍然能够被用户看到，面后者将被安全地重定向。
检查标准输出是否被重定向的办法很简单，只要查看底层文件描述符是否关连在一个终端
上就可以知道。isatty系统调用可以完成这一工作。我们只需简单地把一个合法的文件描述符传
递给它，它就可以判断出该描述符是否正连接在--个终端上。
#include cunistd.h>
int isatty( int fd };
如果打开的文件描述符fd确实连接在一个终端上，isatty系统调用将返回“1”，否则返回“0"。
我们在程序里使用的是文件流，而isatty只能对文件描述符进行操作。因此，我们必须把
isatty调用和我们在第3章里学到的fileno函数结合使用以完成必要的转换。
如果stdout已经被重定向了我们该怎么办呢？直接退出当然不是个好主意，因为用户没有办
法知道程序为什么会运行失败。向stdout输出一条消息也无济于事，因为它肯定会从终端重定向
到其他地方去。解决这个问题的办法之一是把消息写到stderr去，它不会被shell的“>file”命令
重定向。
动手试试：检查是否存在输出重定向
1）沿用我们在上一小节里编写的menul.c程序，在其中加上一个新的include语句，把main函
数按下列内容进行修改，给新文件起名为menu2.c。
#include 
int nain()
加入jaVa编程群：524621833
---
## Page 152
134Linux程序设计
int choice = 0:
if(lisatty(fileno(stdout)1){
fprintf (stderr,*You are not a terminal!\n*):
exit (11 ;
dof
choice = getchoice(*Please select an action*.menul:
printf(*You have chosen: @c\n*, choice);
}while(choice !='q'};
:{0}11x8
2）请看这个程序给出的样本输出：
Choice: Please select an action
Smenu2
A-
ard new record
d - Gelete record
q ·quit
You are not a terminal!
S nenu2 >file
操作注释：
新代码段用isatty函数检查标准输出是否连接在一个终端上，如果不是，就停止运行。这也
是shell用来决定是否需要提供shell提示符的检测手段。同时对stdout和stderr都进行重定向的情况
也很常见。比如说，我们可以象下面这样把stder文件流重定向到另外一个文件去：
$menu2>file 2>file.error
或者用下面的命令把这两个输出流都重定向到同一个文件去：
$menu2>f1le2>&1
$
如果读者不熟悉重定向操作，请复习一下第2章内容，我们在那里对这一语法现象做了详细
的说明。如果出现上面这样的情况，我们就需要把消息送往控制台。
5.1.2与终端进行“对话”
如果我们不想让我们程序中与用户交互操作的部分被重定向，重定向的东西只限于其他的
输人和输出，就必须把交互操作部分与stdout和stderr隔离开。直接对终端进行读写能够实现我
们的愿望。UNIX从传统上看是一个多用户系统，往往会直接或经由网络连接多个终端，那么，
我们这样才能找到正确的终端并使用它呢？
UNIX已经想到这个问题了，它通过一个特殊的/dev/tty设备消除了我们的顾虑。这个设备永
远是当前终端或当前的登录会话。因为UNIX把一切事物都看做是文件，所以我们可以通过正常
的文件操作对/dev/tty设备进行读写。
继续修改我们的程序，使我们能够通过向getchoice函数传递参数的办法加强对输出的控制。
修改后的程序称为menu3.c。
加入jaVa编程群：524621833
---
## Page 153