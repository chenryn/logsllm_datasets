Buckets通常落后于cloudflare。不幸的是，默认情况下，此设置过去容易受到缓存投毒攻击的影响。
直到 2021 年 8 月 3 日，Cloudflare 过去常常缓存 403 个状态代码，即使没有指令也是如此。这使得在S3
Buckets上托管并通过Cloudflare代理的任何文件都可能中毒。发送无效的授权标头将导致可缓存的 403 错误。`Cache-control`
### S3 Bucket:
### Azure Storage
Exodus使用子域名来提供下载，例如Exodus钱包安装程序。由于文件存储在 Azure Storage Blob
上，因此可能会使用精心构造的授权标头导致可缓存的 403
错误。Exodus团队在收到报告后几个小时就解决了这个问题，并获得了2500美元的赏金。`downloads.exodus.com`
Cloudflare还更改了其默认配置，现在不再默认缓存403响应。
## Fastly主机头注入攻击
在向同一漏洞赏金项目报告了多个缓存投毒漏洞后，他们同意向我发送他们的 Varnish
配置文件，以便我可以更轻松地识别其他问题之处。在浏览文件时，我发现了一个类似于下面的片段：
该代码段用于主机地图镜像的子域。请求镜像将如下所示：
引入的规则规定，当 url 路径与正则表达式匹配时，缓存密钥将仅包含从 url 中提取的坐标，并忽略所有其他 url
组件。因此，上面请求的图像将具有以下缓存密钥：
    /4/151/16
由于该规则仅将提取的坐标包含在路径中，这意味着我可以将任何主机标头发送到后端，并且它仍然与相同的缓存密钥匹配。不幸的是，这不起作用，因为Fastly拒绝任何未列入白名单的主机头。
通过在请求中附加报头，完全绕过了此机制。如果报头包含在白名单值之内，则主机头可以更改为任何内容：`Fastly-host``fastly-host`
虽然可以将主机头注入用于CP-DoS攻击，但我希望获得更多信息，因此我决定更深入地研究。在同一程序上寻找其他Fastly主机时，我发现一个html文件容易受到DOM
XSS的攻击。由于这是在起源之下，因此xss本身没有影响。`redacted-cdn.com``redacted-cdn.com`
在发现主机头正在转发，但快速主机用于生成缓存密钥后，我能够使用标头将其升级。因此，以下请求将与 的缓存键匹配：`fastly-host`
    https://assets.redacted.com/test.html
由于两个主机都位于同一个 loadbalancer 后面，因此可以缓存托管在 下的文件，这本身就允许我将易受攻击的 html
文件移动到不同的域上，并在不同的源下实现 xss。`redacted-cdn.com``assets.redacted.com`
## 注入加密参数
通常，缓存配置为仅在缓存键中包含特定的 GET 参数。这在CDNs 主机镜像中尤其常见，这些 CDN 使用参数来修改图像大小或格式。
当测试一个用于快速缓存镜像的目标时，我注意到该参数包含在缓存密钥中，但所有其他参数都被忽略了。如果添加了两个参数，则这两个参数都包含在缓存密钥中，但后端服务器使用的是最后一个参数中的值。考虑到快速性（Varnish），在生成缓存密钥之前不做任何的url标准化处理，从而我能够提出使用以下DoS攻击方法：sizesize
对第二个参数进行 URL 编码会导致缓存忽略它，但被后端使用。赋予参数一个指定值 0 将导致可缓存的 400 错误请求。`size`
## 用户代理规则
由于FFUF或Nuclei等批量扫描工具的出现，一些开发人员决定拦截与他们相匹配的用户代理发起的请求。讽刺的是，这些微调可能会引入不必要的缓存投毒DoS攻击机会。
我发现这适用于多个目标，使用来自不同工具或扫描器的用户代理。
## 非法报头字段
[RFC7230](https://datatracker.ietf.mrg/doc/html/rfc7230)中定义的报头名称格式如下：
从理论上来说，如果一个报头名称包含 **tchar** 中列出的字符以外的字符，则应使用 400 Bad
请求拒绝它。然而实际上，服务器并不总是尊重RFC。利用这种细微差别的最简单方法是以 Akamai 为目标，Akamai
不会拒绝无效标头，但只要缓存控制标头不存在，就会转发它们并缓存任何 400 错误。
发送包含非法字符的标头将导致可缓存的 400 错误请求错误。这是我在整个测试过程中最常发现的模式之一。`\`
## 查找新报头
除了一些通过请求行属性进行缓存投毒的新情况以外，检测到的大多数缓存投毒漏洞都是由未加密的报头引起的。
由于我想扩展我的报头列表，因此我使用Google的BigQuery在HTTP存档中查询 **Vary** 响应报头中使用的值。 **Vary**
报头包含应由缓存服务器加密的报头名称。这让我能够找到一些额外的易受攻击的实体，否则将无法检测到这些实体。
以下是结合Param-Miner报头的报头列表。
 （2917L）
## 常见报头
下面的列表显示了用于利用 70 多个缓存服务器的所有报头。
## 结论
识别缓存投毒漏洞可以像运行报头暴力破解和检测未加密的报头一样简单，但是将测试限制为该漏洞通常可能会忽略掉存在于服务器堆栈中利用其复杂性来运作的灵活投毒技术。自定义缓存配置、URL
解析差异或未记录的请求头都会引入意外行为，从而导致缓存的任意重定向、DoS 攻击甚至 JS 文件覆盖。