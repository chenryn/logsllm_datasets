a) Gadget requirements: In response to Fallout, RIDL,
and ZombieLoad, recent Intel microcode updates now overwrite
SB, LFB, and LP entries on every enclave and process context
switch [29]. Hence, to reversely exploit SB, LFP, or LP leakage,
we ﬁrst require a P1 gadget to bring interesting data (e.g.,
secrets or attacker-controlled addresses) into the appropriate
buffer. Next, we need a P2 gadget consisting of a trusted load
operation which can be faulted or assisted, followed by a P3
gadget creating a side-channel for data transmission or control
ﬂow redirection. For LVI-SB, we further require that the store
and load addresses in P1 and P2 share the same page offset
and are sufﬁciently close, such that the injected data in P1
has not yet been drained from the store buffer. Alternatively,
for LVI-LFB and LVI-LP, attackers may resort to injecting
poisoned data from a sibling logical core, as LFB and LP are
competitively shared between hyperthreads [29, 53].
b) Gadget exploitation: We found that LVI-SB can be a
particularly powerful primitive, given the prevalence of store
operations closely followed by a return or indirect call. We
illustrate this point in Listing 2 with trusted proxy bridge code
that is automatically generated by Intel’s edger8r tool of
the ofﬁcial SGX-SDK [30]. The edger8r-generated bridge
1 ; %rbx: user-controlled argument ptr (outside enclave)
2 sgx_my_sum_bridge:
3
4
5
6
7
8
...
call my_sum
mov %rax,(%rbx)
xor %eax,%eax
pop %rbx
ret
; compute 0x10(%rbx) + 0x8(%rbx)
; P1: store sum to user address
; P2: load from trusted stack
Listing 2: Intel edger8r-generated code snippet with LVI-SB gadget.
code is responsible for transparently verifying and copying
user arguments to and from enclave memory. The omitted code
veriﬁes that the untrusted argument pointer, which is also used
to pass the result, lies outside the enclave [62].
An attacker can interrupt the enclave after line 4, clear the
supervisor or accessed bit for the enclave stack, and resume
the enclave. As the edger8r bridge code solely veriﬁes that
the attacker-provided argument pointer lies outside the enclave,
it provides the attacker with full control over the lower 12 bits
of the store address (P1). When the enclave code returns at
line 8, the control ﬂow is redirected to the attacker-injected
location, as the faulting or assisted ret (P2) incorrectly picks
up the value from the SB (which in this case is the sum of two
attacker-provided arguments). Similar to LVI-L1D (Figure 5),
an attacker can encode arbitrary enclave secrets by chaining
together one or more P3 gadgets in the victim enclave code.
Finally, note that LVI is not limited to control ﬂow redirection
as secrets may also be encoded directly in the data ﬂow through
a combined P2-P3 gadget (e.g., by means of a double-pointer
dereference as illustrated in the toy example of Listing 1).
c) Applicability to non-SGX environments: Importantly,
in contrast to LVI-L1D above, SB, LFB, and LP leakage does
not necessarily require adversarial manipulation of PTEs, or
rely on microarchitectural conditions that are speciﬁc to Intel
SGX. Hence, given a suitable fault or assist primitive plus the
required victim code gadgets, LVI-SB, LVI-LFB, and LVI-LP
may be relevant for other contexts as well (cf. Section VIII).
C. LVI-NULL: 0x00 Dummy Injection
A highly interesting special case is LVI-NULL, which
is based on the observation that known Meltdown-type at-
tacks [42, 61] commonly report a strong bias to the value
zero for faulting loads. We experimentally conﬁrmed that the
latest generation of acclaimed Meltdown-resistant Intel CPUs
(RDCL_NO [28] from Whiskey Lake onwards) merely zero-out
the results of faulting load micro-ops while still passing a
dummy 0x00 value to dependent transient instructions. While
this nulling strategy indeed sufﬁces to prevent Meltdown-type
data leakage, we show that the ability to inject zero values in the
victim’s transient data stream can be dangerously exploitable.
Hence, LVI-NULL reveals a fundamental shortcoming in
current silicon-level mitigations, and ultimately requires more
extensive changes in the way the CPU pipeline is organized.
a) Gadget requirements: Unlike the other LVI variants,
LVI-NULL does not rely on any microarchitectural buffer to
inject poisoned data, but instead directly abuses dummy 0x00
values injected from the CPU’s silicon circuitry in the P1 phase.
62
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 10:02:52 UTC from IEEE Xplore.  Restrictions apply. 
NULL
2
&P3_gadget
%rbx=NULL(cid:2)
P2_gadget:
mov (%rax), %rbx
call (%rbx)
1
%rax(cid:2)
&trusted_func_pt
&trusted_func
Fig. 6. Transient control-ﬂow hijacking using LVI-NULL: (1) a P2 gadget
inside the enclave dereferences a function pointer-to-pointer, leading to a
faulting load which forwards the dummy value null; (2) the following indirect
call transiently dereferences the attacker-controlled null page outside the
enclave, causing execution to continue at an attacker-chosen P3 gadget address.
The P2 gadget consists of a trusted load operation that can
be faulted or assisted, followed by a P3 gadget which, when
operating on the unexpected value null, creates a side-channel
for secret transmission or control-ﬂow redirection.
In some scenarios, transiently replacing a trusted load micro-
op with the unexpected value zero may directly lead to
information disclosure, as explored in the AES-NI case study of
Section VII-B. Moreover, LVI-NULL is especially dangerous
in the common case of indirect pointer dereferences.
b) Gadget exploitation: While transiently computing on
zero values might at ﬁrst seem rather innocent, we make the
key insight that zero can be regarded as a valid virtual address
and that SGX root attackers can trivially map an arbitrary
memory page at virtual address null. Using this technique,
we contribute an innovative transient null-pointer dereference
primitive that allows to hijack the result of any indirect pointer
dereference in the victim enclave’s transient domain.
We ﬁrst consider the case of a data pointer stored in trusted
memory, e.g., as a local variable on the stack. After revoking
access rights on the respective enclave memory page, loading
the pointer forces its value to zero, causing any following
dereferences in the transient domain to read attacker-controlled
data via the null page. This serves as a powerful “transient
pointer-value hijacking” primitive to inject arbitrary data in a
victim enclaved execution, which can be subsequently used in
a P3 gadget to disclose secrets or redirect control ﬂow.
Figure 6 illustrates how the above technique can furthermore
be exploited to arbitrarily hijack transient control ﬂow in
the case of function pointer-to-pointer dereferences, e.g., a
function pointer in a heap object. The ﬁrst dereference yields
zero, and the actual function address is thereafter retrieved
via the attacker-controlled null page. For the simpler case of
single-level function pointers, we experimentally found that
transient control ﬂow cannot be directly redirected to the zero
address outside the enclave, which is in line with architectural
restrictions imposed by Intel SGX [13]. However, adversaries
might load the relocatable enclave image at virtual address
null. We, therefore, recommend that the ﬁrst page is marked as
non-executable or that a short inﬁnite loop is included at the
base of every enclave image to effectively “trap” any transient
control ﬂow redirections to virtual address null.
Finally, a special case is loading a stack pointer. Listing 3
shows a trusted code snippet from the Intel SGX-SDK [30] to
1 asm_oret: ; (linux-sgx/sdk/trts/linux/trts_pic.S#L454)
2
3
4
5
6
7
; %rsp <- NULL
; %rbp <- *(NULL)
; %rip <- *(NULL+8)
%rbp,%rsp
%rbp
0x58(%rsp),%rbp
; %rbp <- NULL
...
mov
...
mov
pop
ret
Listing 3: LVI-NULL stack hijack gadget in Intel SGX-SDK.
restore the enclave execution context when returning from an
untrusted function.1 An attacker can interrupt the victim code
right before line 3, and revoke access rights on the trusted
stack page used by the enclave entry code. After resuming the
enclave, the victim then page faults at line 3. However, the
transient execution ﬁrst continues with a zeroed %rbp register,
which eventually gets written to the %rsp stack pointer register
at line 5. Crucially, at this point, all subsequent pop and
ret transient instructions dereference the attacker-controlled
memory page mapped at virtual address null. This stack pointer
zeroing primitive essentially allows LVI-NULL attackers to
setup an arbitrary fake transient “shadow stack” at address null.
We experimentally validated that this technique can furthermore
be abused to mount a full transient ROP [56] attack by chaining
together multiple subsequent pop-ret gadgets.
c) Applicability to non-SGX environments: LVI-NULL
does not exploit any microarchitectural properties that are
speciﬁc to Intel SGX, and may apply to other environments as
well. However, we note that exploitation may be hindered by
various architectural and software-level defensive measures that
are in place to harden against well-known architectural null
pointer dereference bugs. Some Linux distributions do not allow
to map virtual address zero in user space. Furthermore, recent
x86 SMAP and SMEP architectural features further prohibit
respectively user-space data and code pointer dereferences in
kernel mode. SMAP and SMEP have been shown to also hold
in the microarchitectural transient domain [10, 26].
VII. LVI CASE STUDIES ON INTEL SGX
A. Gadget in Intel’s Quoting Enclave
In this section, we show that exploitable LVI gadgets may
occur in real-world software. We analyze Intel’s trusted quoting
enclave (QE), which has been widely studied in previous
transient-execution research [11, 53, 61] to dismantle remote
attestation guarantees in the Intel SGX ecosystem. As a
result, the QE trusted codebase has been thoroughly vetted
and hardened against all known Meltdown-type and Spectre-
type attacks by manually inserting lfence instructions after
potentially mispredicted branches, as well as ﬂushing leaky
microarchitectural buffers on every enclave entry and exit.
a) Gadget description: We started from the observation
that most LVI variants ﬁrst require a P1 load-store gadget
with an attacker-controlled address and data, followed by a
faulting or assisted P2 load that picks up the poisoned data.
Similar to the edger8r gadget discussed in Section VI-B, we
1 Note that we also found similar, potentially exploitable gadgets in the
rsp-rbp function epilogues emitted by popular compilers such as gcc.
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 10:02:52 UTC from IEEE Xplore.  Restrictions apply. 
63
1 __intel_avx_rep_memcpy: ; libirc_2.4/efi2/libirc.a
2
3
4
5
6
...
vmovups %xmm0,-0x10(%rdi,%rcx,1)
...
pop
ret
; P1: store to user address
; P2: load from trusted stack
%r12
Listing 4: LVI gadget in SGX-SDK intel_fast_memcpy used in QE.
therefore focused our manual code review on pointer arguments
which are passed to copy input and output data via untrusted
memory outside the enclave [62]. Particularly, we found that
QE securely veriﬁes that the output pointer to hold the resulting
quote falls outside the enclave while leaving the base address
in unprotected memory under attacker control. An Intel SGX
quote is composed of various metadata ﬁelds, followed by the
asymmetric signature (cf. Appendix C). After computing the
signature, but before erasing the EPID private key from enclave
memory, QE invokes memcpy to copy the corresponding quote
metadata ﬁelds from trusted stack memory to the output buffer
outside the enclave. Crucially, we found that as part of the last
metadata ﬁelds, a 64-byte attacker-controlled report_data
value is written to the attacker-provided output pointer.
We reverse engineered the proprietary intel_fast_me
mcpy function used in QE and found that in this case, the
quote is outputted using 128-bit vector instructions. Listing 4
provides the corresponding assembly code snippet, where the
ﬁnal 128-bit store at line 3 (including 12 bytes of attacker data)
is closely followed by a pop and ret instruction sequence at
lines 5-6 when returning from the memcpy invocation. This
forms an exploitable LVI-SB transient control-ﬂow hijacking
gadget: the vmovups instruction (P1) ﬁrst ﬁlls the store buffer
with user data at a user-controlled page offset aligned with the
return address on the enclave stack, and closely afterwards the
faulting or assisted ret instruction (P2) incorrectly picks up
the poisoned user data. The attacker now succeeded to redirect
transient control ﬂow to an arbitrary P3 gadget address in
the enclave code, which may subsequently lead to QE private
key disclosure [11]. Note that when transiently executing the
P3 gadget, the attacker also controls the value of the %r12
register popped at line 5 (which can be injected via the prior
stores similarly to the return address). We further remark that
Listing 4 is not limited to LVI-SB, since the store data may
also have been committed from the store buffer to the L1 cache
and subsequently picked up using LVI-L1D.
The Intel SGX-SDK [30] randomizes the 11 least signiﬁcant
bits of the stack pointer on enclave entry. However, as return
addresses are aligned, the entropy is only 7 bits, resulting on
average in a correct alignment in 1 out of every 128 enclave
entries when ﬁxing the store address in P1.
b) Experimental results: We validate the exploitability
and success rate of the above assembly code using a benchmark
enclave on an i7-8650U with the latest microcode 0xb4. We
inject both the return address and the value popped into %r12
via the store buffer. For P3, we can use the poisoned value in
%r12 to transmit data over an address outside the enclave. We
ensure that the code in Listing 4 is page aligned to interrupt the
victim enclave using a controlled-channel attack [71]. Before
resuming the victim, we clear the user-accessible bit for the
enclave stack. Additionally, to extend the transient window, we
inserted a memory access which misses the cache before line 3.
In the ﬁrst experiment, we disable stack randomization in
the victim enclave to reliably quantify the success rate of the
attack in the ideal case. LVI works very reliably, picking up
the injected values 99 453 times out of 100 000 runs. With
on average 9090 tries per second, we achieve an error-free
transmission rate of 9.04 kB/s for our disclosure gadget.
In the second experiment, we simulate the full attack
environment including stack randomization. As expected, the
success rate drops by an average factor of 128. The injected
return address is picked up 776 times out of 100 000 runs,
leading to a transmission rate of 70.54 B/s. We did not
reproduce this attack against Intel’s ofﬁcially signed quoting
enclave, as we found it especially challenging to debug the
attack for production QE binaries and to locate P3 gadgets that
ﬁt within the limited transient window without excessive TLB
misses. However, we believe that our experiments showcased all
the required primitives to break Intel SGX’s remote attestation
guarantees, as demonstrated before by SGXPectre [11] and
Foreshadow [61]. In response to our ﬁndings, Intel will harden
all architectural enclaves with full LVI software mitigations (cf.
Section IX) so as to restore trust and initiate TCB recovery
for the SGX ecosystem [27].
B. Transient Fault Attack on AES-NI
In this case study, we show that LVI-NULL can be exploited
to perform a cryptographic fault attack [47, 59] on Intel’s
constant-time AES-NI hardware extension. We exploit that a
privileged SGX attacker can induce faulty all-zero round keys
into the transient data stream of a minimal AES-NI enclave.
After the fault, the output of the decryption carries a faulty
plaintext in the transient domain. To simplify the attack, we
consider a known-ciphertext scenario and we assume a side-
channel in the post-processing which allows to recover the
faulty decryption output from the transient domain. Note that
prior research [68] on Spectre-type attacks has shown that
transient execution may ﬁt a signiﬁcant number of AES-NI
decryptions (over 100 rounds on modern Intel processors).
Intel AES-NI [21] is implemented as an x86 vector extension.
The aesdec and aesdeclast instructions perform one
round of AES on a 128-bit register using the round key provided
in the ﬁrst register operand. Round keys are stored in trusted
memory and, depending on the available registers and the
AES-NI software implementation, the key schedule is either
preloaded or consulted at the start of each round. In our case
study, we assume that round keys are securely fetched from
trusted enclave memory before each aesdec instruction.
a) Attack outline: Figure 7 illustrates the different phases
in our transient fault injection attack on AES-NI:
1) We use SGX-Step [63] to precisely interrupt the victim
enclave after executing only the initial round of AES.
2) The root attacker clears the user-accessible bit on the
memory page containing the round keys.
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 10:02:52 UTC from IEEE Xplore.  Restrictions apply. 
64
1
Architectural
(cid:2)Execution
Single Step
3
Transient
(cid:2)Execution
movdqu      (%rdx), %xmm0
movdqu      (%rcx), %xmm4
add             $0x10, %rdx
pxor           %xmm4, %xmm0
I n p u t
Load RK0
2
movdqu      0x10(%rcx), %xmm4
aesdec        %xmm4, %xmm0
movdqu      0x20(%rcx), %xmm4
aesdec         %xmm4, %xmm0
...
movdqu      0xa0(%rcx), %xmm4
aesdeclast   %xmm4, %xmm0
movdqu      %xmm0, -0x10(%r8,%rdx,1) 
Load RK1
Load RK2
Load RK10
Output
access oracle[output[byte_index] * 4096];
4
2
Change Page 
Permission
9
d
e
t
a
e
p
e
R
s
e
m