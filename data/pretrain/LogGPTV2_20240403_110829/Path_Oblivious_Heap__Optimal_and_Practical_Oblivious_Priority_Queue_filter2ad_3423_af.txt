VII. CONCRETE PERFORMANCE IN MPC
We next evaluate our scheme’s concrete performance in
secure multi-party computation (MPC) scenarios.
Schemes to compare with. We compare the cost incurred
for MPC for Wang et al. [44], Jafargholi et al. [25], and
our scheme. The asymptotic circuit sizes incurred by these
schemes are depicted in Table I. Assuming that the key size
is at least log N bits, then roughly speaking, our scheme
asymptotically outperforms Wang et al. [44] by a logarithmic
factor, and we outperform Jafargholi et al. [25] by a log log
factor. Although Wang et al. [44] is asymptotically worse than
Jafargholi et al. [25], as our evaluation results show, Wang et
al. [44] outperforms Jafargholi et al. [25] in practice and in
this sense, Wang et al. [44] represents the state-of-the-art in
terms of concrete performance.
Setup and metrics. As mentioned, the empirical state-of-the-
art is an earlier work by Wang et al. [44] (CCS’14) where they
evaluated the concrete performance of their oblivious priority
queue scheme in a secure multi-party computation scenario.
We adopt the same experimental setup and evaluation metrics
as Wang et al. [44] to best contrast with prior work.
Like Wang et al. [44], we consider an encrypted database
scenario, where Alice stores the encrypted, oblivious priority
queue, and Bob comes with the priority queue requests. After
each query, Alice obtains the new state of the database, without
learning the request Bob has performed, nor the answer.
We use an open-source, semi-honest garbled circuit backend
called FlexSC [1]. As Wang et al. [44] point out, the bottle-
neck is the cost of generating and evaluating garble circuits;
therefore, the number of symmetric encryptions (AES) is an
indicative performance metric. The metric is also platform
independent which facilitates reproducibility of the result.
We note that modern processors with instruction-level AES
support can compute 108 AES-128 operations per second. Just
like Wang et al. [44], our evaluation assmes that the oblivious
data structure is already set up in a preprocessing phase; and
our evaluation focuses on the online cost per request.
Concrete instantiation and parameters. We use the Circuit-
variant for our MPC-related evaluations. We adopt the same
practical optimizations as suggested in the original Circuit
ORAM work [42]: we choose a bucket capacity of 2 although
the theoretical proofs need to assume a larger constant; we
do not perform eviction on the path where an element has
been extracted; and we perform two evictions based reverse-
lexicographical ordering per request. As mentioned, in the
tree-based ORAM and oblivious data structure line of work,
the variants with provable stochastsic bounds always perform
a constant factor worse than the schemes that have been
implemented and are known to enjoy the best empirical per-
formance. Again, we determine concrete security parameters
using a standard methodology detailed in Section VI — but
this time we do it with Circuit ORAM’s eviction algorithm.
For a bucket size of 3 and using a reverse-lexicographical order
for choosing eviction paths, we found that a root-bucket size
of 33 is sufﬁcient for achieving 2−80 security.
Evaluation results. We show the results in Figure 3. When
the database contains 230 entries, our scheme results in 7×
to 8× fewer number of symmetric encryptions than the prior
state of the art [44]. Since our improvement is asymptotic, the
speedup will become greater with larger data sizes.
Additional evaluation results. We also evaluated the concrete
performance of Path Obliviou Sort. Due to space constraints,
we defer these results to the online full version [37].
REFERENCES
[1] https://github.com/wangxiao1254/FlexSC.
Authorized licensed use limited to: Auckland University of Technology. Downloaded on November 03,2020 at 00:37:42 UTC from IEEE Xplore.  Restrictions apply. 
854
[2] https://github.com/data61/MP-SPDZ.
[3] M. Ajtai, J. Koml´os, and E. Szemer´edi. An O(n log n) sorting network.
In STOC, 1983.
[4] G. Asharov, I. Komargodski, W.-K. Lin, K. Nayak, E. Peserico, and
E. Shi. Optorama: Optimal oblivious ram. Cryptology ePrint Archive,
Report 2018/892, 2018. https://eprint.iacr.org/2018/892.
[5] B. Balle, J. Bell, A. Gasc´on, and K. Nissim. The privacy blanket of the
shufﬂe model. In CRYPTO, 2019.
[35] C. Sahin, V. Zakhary, A. El Abbadi, H. Lin, and S. Tessaro. Taostore:
Overcoming asynchronicity in oblivious data storage. In S & P, 2016.
[36] S. Sasy and O. Ohrimenko. Oblivious sampling algorithms for private
data analysis. In NeurIPS, 2019.
[37] E. Shi. Path oblivious heap: Optimal and practical oblivious priority
queue. Cryptology ePrint Archive, Report 2019/274, 2019. https://eprint.
iacr.org/2019/274.
[38] E. Stefanov and E. Shi. Oblivistore: High performance oblivious cloud
[6] K. E. Batcher. Sorting Networks and Their Applications. AFIPS ’68
storage. In S & P, 2013.
[7] E. Boyle and M. Naor.
Is there an oblivious RAM lower bound? In
(Spring), 1968.
ITCS, 2016.
[8] T. H. Chan, J. Katz, K. Nayak, A. Polychroniadou, and E. Shi. More
is less: Perfectly secure oblivious algorithms in the multi-server setting.
In ASIACRYPT, 2018.
[9] K. Chaudhuri and N. Mishra. When random sampling preserves privacy.
In C. Dwork, editor, CRYPTO, 2006.
[10] A. Cheu, A. Smith, J. Ullman, D. Zeber, and M. Zhilyaev. Distributed
differential privacy via shufﬂing, 04 2019.
[11] K.-M. Chung, Z. Liu, and R. Pass. Statistically-secure ORAM with
˜O(log2 n) overhead. In Asiacrypt, 2014.
[12] T. T. A. Dinh, P. Saxena, E.-C. Chang, B. C. Ooi, and C. Zhang.
M2r: Enabling stronger privacy in mapreduce computation. In USENIX
Security, 2015.
[13] C. Dwork, F. McSherry, K. Nissim, and A. Smith. Calibrating noise to
sensitivity in private data analysis. In TCC, 2006.
´U. Erlingsson, V. Feldman, I. Mironov, A. Raghunathan, K. Talwar,
and A. Thakurta. Ampliﬁcation by shufﬂing: From local to central
differential privacy via anonymity. In SODA, 2019.
[14]
[15] U. Erlingsson, V. Pihur, and A. Korolova.
Rappor: Randomized
aggregatable privacy-preserving ordinal response. In CCS, 2014.
[16] A. Farhadi, M. Hajiaghayi, K. G. Larsen, and E. Shi. Lower bounds for
external memory integer sorting via network coding. In STOC, 2019.
[17] J. Gehrke, M. Hay, E. Lui, and R. Pass. Crowd-blending privacy. In
CRYPTO 2012, 2012.
[18] C. Gentry, K. A. Goldman, S. Halevi, C. S. Jutla, M. Raykova, and
D. Wichs. Optimizing ORAM and using it efﬁciently for secure
computation. In PETS, 2013.
[19] O. Goldreich. Towards a theory of software protection and simulation
by oblivious RAMs. In STOC, 1987.
[20] O. Goldreich and R. Ostrovsky. Software protection and simulation on
oblivious RAMs. J. ACM, 1996.
[21] M. T. Goodrich. Zig-zag sort: A simple deterministic data-oblivious
sorting algorithm running in O(N Log N) time. In STOC, 2014.
[22] M. T. Goodrich and M. Mitzenmacher. Privacy-preserving access of
outsourced data via oblivious RAM simulation. In ICALP, 2011.
[23] S. D. Gordon, J. Katz, V. Kolesnikov, F. Krell, T. Malkin, M. Raykova,
and Y. Vahlis. Secure two-party computation in sublinear (amortized)
time. In CCS, 2012.
[24] R. Jacob, K. G. Larsen, and J. B. Nielsen. Lower bounds for oblivious
data structures. In SODA, 2019.
[25] Z. Jafargholi, K. G. Larsen, and M. Simkin. Optimal oblivious priority
queues and ofﬂine oblivious RAM. Cryptology ePrint Archive, Report
2019/237, 2019. https://eprint.iacr.org/2019/237.
[26] S. P. Kasiviswanathan, H. K. Lee, K. Nissim, S. Raskhodnikova, and
A. D. Smith. What can we learn privately? In FOCS, 2008.
[27] K. G. Larsen and J. B. Nielsen. Yes, there is an oblivious ram lower
bound! In CRYPTO, 2018.
[28] Z. Li and B. Li. Network coding : The case of multiple unicast sessions.
2004.
[29] W. Lin, E. Shi, and T. Xie. Can we overcome the n log n barrier for
oblivious sorting? In SODA, 2019.
[30] C. Liu, X. S. Wang, K. Nayak, Y. Huang, and E. Shi. ObliVM: A
programming framework for secure computation. In S & P, 2015.
[31] S. Lu and R. Ostrovsky. Distributed oblivious RAM for secure two-party
computation. In TCC, 2013.
[32] S. Mazloom and S. D. Gordon. Secure computation with differentially
private access patterns. In CCS, 2018.
[33] K. Nayak, X. S. Wang, S. Ioannidis, U. Weinsberg, N. Taft, and E. Shi.
GraphSC: Parallel Secure Computation Made Easy. In S & P, 2015.
[34] L. Ren, C. W. Fletcher, A. Kwon, E. Stefanov, E. Shi, M. van Dijk,
and S. Devadas. Constants count: Practical improvements to oblivious
RAM. In USENIX Security, 2015.
[39] E. Stefanov, M. van Dijk, E. Shi, C. Fletcher, L. Ren, X. Yu, and
S. Devadas. Path ORAM – an extremely simple oblivious ram protocol.
In CCS, 2013.
[40] T. Toft. Secure data structures based on multi-party computation.
In
[41] J. S. Vitter. Random sampling with a reservoir. ACM Trans. Math.
PODC, pages 291–292, 2011.
Softw., 11(1):37–57, Mar. 1985.
[42] X. S. Wang, T.-H. H. Chan, and E. Shi. Circuit ORAM: On Tightness
of the Goldreich-Ostrovsky Lower Bound. In CCS, 2015.
[43] X. S. Wang, Y. Huang, T.-H. H. Chan, A. Shelat, and E. Shi. SCORAM:
Oblivious RAM for Secure Computation. In CCS, 2014.
[44] X. S. Wang, K. Nayak, C. Liu, T.-H. H. Chan, E. Shi, E. Stefanov, and
Y. Huang. Oblivious Data Structures. In CCS, 2014.
[45] P. Williams, R. Sion, and A. Tomescu. Privatefs: A parallel oblivious
ﬁle system. In CCS, 2012.
[46] W. Zheng, A. Dave, J. G. Beekman, R. A. Popa, J. E. Gonzalez, and
I. Stoica. Opaque: An oblivious and encrypted distributed analytics
platform. In NSDI, 2017.
APPENDIX A
ADDITIONAL BACKGROUND ON NON-RECURSIVE PATH
ORAM AND CIRCUIT ORAM
In this
section, we review the (non-recursive) Path
ORAM [39] and the Circuit ORAM [42] algorithm. The two
algorithms are almost identical with the primary difference
being how path evictions are performed. Path ORAM’s evic-
tion algorithm requires that the CPU be able to store an entire
tree path (otherwise oblivious sorting would be required over
the path). In comparison, Circuit ORAM’s eviction can be
performed by a CPU with a single register.
Data structure. A non-recursive Path ORAM [39] or Circuit
ORAM [42], parametrized by a security parameter λ and a
capacity parameter N, is formed as a binary tree with N
leaves, where each node in the tree is called a bucket. To
achieve a security failure probability of negl(λ),
the root
bucket Broot should be large enough to store ω(log λ) blocks,
whereas every internal bucket B holds a suitable constant
number of blocks. All blocks stored in the tree are either
real or dummy:
• A real block is of the form (addr, data, pos) where addr
dentoes addr ∈ {0, 1, . . . N − 1} denotes the logical
address of the block; data denotes an arbitrary payload
string — we assume that the pair (addr, data) can ﬁt in
a single block; and pos ∈ {0, 1, . . . , N − 1} denotes the
position label for the block.
• A dummy block is of the form (⊥,⊥,⊥).
Path invariant. The data structure always respects the fol-
lowing path invariant: a real block whose position label is pos
must reside on the path from the root to the leaf numbered
pos.
Algorithms. The (non-recursive) Path ORAM or Circuit
ORAM supports the following operations:
Authorized licensed use limited to: Auckland University of Technology. Downloaded on November 03,2020 at 00:37:42 UTC from IEEE Xplore.  Restrictions apply. 
855
pos ← Insert(addr, data):
1) Pick a random position label pos ∈ {0, 1, . . . , N − 1}
and call Broot.Add(addr, data, pos); where Broot.Add
can be implemented identically as described in Sec-
tion III. Note that if the bucket B is already fully
occupied and there is no room to successfully perform
the addition, an Overﬂow exception is thrown.
2) Pick two random eviction paths P and P(cid:48) that are non-
overlapping except at the root bucket — note that the
paths may be identiﬁed by the indices of the leaf nodes.
Now, call P.Evict() and P(cid:48).Evict(). We will discuss
the path eviction algorithsm in more detail shortly in
the paragraph “Path eviction”.
3) Return pos;
data ← Read(addr, pos):
Assume: pos must be the label returned by Insert when
the block at address addr was added; moreover this block
must not have been removed since it was added.
1) For each bucket B from the root to the leaf identiﬁed
by pos: sequentially scan through the bucket B:
• when addr is encountered, remember the data ﬁeld
in the client’s local cache and and replace the block
with dummy block;
• else write the original block back for obliviousness.
2) Call P.Evict() where P is the path deﬁned by pos.
3) Return data.
Path eviction. In Path ORAM, the path eviction algorithm
(denoted Evict) works as follows: the CPU fetches the entire
path into its local registers and locally computes a new path
as follows: pack all real blocks on the path as close to the leaf
as possible while respecting the path invariant. Once the new
path has been computed, the CPU writes the entire path back
to memory.
One can now see that Path ORAM’s eviction algorithm
requires that the CPU cache the entire path including the
super-logarithmically sized root bucket (otherwise expensive
oblivious sorting must be applied over the eviction path).
Circuit ORAM [42] improves upon Path ORAM and allows
a CPU with O(1) words of private cache to perform the
eviction, making only O(1) linear scans over the path. In
this way, even with O(1) CPU registers, Circuit ORAM’s
eviction algorithm completes in in O(|Broot| + log N ) time,
i.e., proportional to the path length. We refer the reader to
Section IV and the Circuit ORAM [42] paper for the details
of its eviction algorithm. Note that Circuit ORAM’s eviction
algorithm differs slightly between a Read path where an
element has just been removed, and a non-Read path selected
for eviction.
Stochastic bounds. Consider an adversary A that interacts
with a challenger denoted C and adaptively submits a sequence
of requests either of the form (Insert, addr, data) or of the
form (Read, addr). It is guaranteed that for a Read request,
a conforming adversary A always supplies an addr that has
been added (and has not been removed since its addition).
• Whenever C receives a request of the form (Insert, addr,
data) from A, it simply calls Path ORAM’s (or Circuit
ORAM’s) pos ← Insert(addr, pos, data) algorithm and
records the pos that is returned.
• Whenever C receives a request of the form (Read, addr)
from A, it ﬁnds out the correct position label pos for addr
and calls Path ORAM’s (or Circuit ORAM’s) data ←
Read(addr, pos) algorithm and returns data to A.
• No matter which query C, at the end of the query C returns
to A the access patterns made by the Path ORAM (or
Circuit ORAM) algorithm.
The following theorem holds for both Path ORAM and
Circuit ORAM (with different constants inside the Ω-notation),