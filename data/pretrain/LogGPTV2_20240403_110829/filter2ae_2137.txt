# 【技术分享】软件安全——反补丁技术
|
##### 译文声明
本文是翻译文章，文章来源：resources.infosecinstitute.com
原文地址：
译文仅供参考，具体内容表达以及含义原文为准。
****
****
**翻译：**[ **pwn_361**
****](http://bobao.360.cn/member/contribute?uid=2798962642)
**预估稿费：100RMB（不服你也来投稿啊！）**
******投稿方式：发送邮件至**[ **linwei#360.cn**](mailto:PI:EMAIL) **，或登陆**[
**网页版**](http://bobao.360.cn/contribute/index) **在线投稿******
**概述**
在这篇文章中，我们主要讨论反补丁技术，可以用于软件保护，让我们探测到软件有没有被篡改或修改。
**工具需求**
1.目标软件(crackme.exe)
2\. Ollydbg
**目标软件**
CrackMe类似于一个简单的身份验证工具，当你输入错误的注册码时，会弹框告诉你注册码错误。如下：
**安全保护**
分析一个软件时，逆向工程师最关心的就是注册码验证过程，或身份验证过程。
下面图片显示，我们的注册码检查过程看起来只是一串硬编码( **s0me_r@nDoM_rEg_c0dE** )，和两个消息框。
如果对这个软件不进行保护，通过修改该软件，绕过身份验证是非常容易的，直接将 **0x40107A**
位置的汇编修改成NOP即可。但是，在我们运用了反补丁技术后，这种方法就不行了。
为了核验保证验证过程代码的安全性，我们需要做一些适当的工作：
1\. 确保验证过程的开始地址是安全的。
2\. 确保验证过程的结束地址是安全的。
3\. 确保整个验证过程是安全的(从开始地址到结束地址)。
4\. 保护算法(可以是HASH或加密)。
根据上面的需要，列出以下必要的素材：
1\. 开始地址：0x401052。
2\. 结束地址：0x4010A6。
3\. 需要保证安全的验证过程(从0x4010A6到0x401052，0x54[84d])。
4\. 算法：为了简单演示，这里我们只用XOR(可以用其它的)。
现在，根据我们的需要，加入我们的算法代码，看起来是这样的：
上面的图片中，我们采用了简单的异或算法，只用到了ADD和XOR，并用这个算法，计算从0x401052开始的0x54个字节的校验和（实际上是做了一个超级简的HASH计算，得到了一个值，如果验证过程被修改过，这个值也就不一样了），如果验证过程被修改，0x4010E7
地址就会被执行，并弹出CrackMe 错误通知。
当然，为了进行上面的效验工作，你需要调用效验算法(0x4010BE),最好将这个算法的代码放在CrackMe 的最开始。
现在，我们测试加入的反补丁模块是否被执行。
首先，我们在没有修改身份认证过程的情况下，运行这个软件，没有什么影响，起动正常。
现在我们修改一下身份验证过程，试图绕过验证过程，如果没有反补丁模块的话，肯定会直接弹出注册码正确的提示，但是我们已经加入了反补丁模块。
运行软件，会看到下面的信息，且软件不会被启动。
因此，这证明我们的反补丁方法完美地工作了。
**结论**
这篇文章展示了一种给逆向工程师增加困难的简单方法，当然算法比较简单，但是如果设计的更复杂一些，会让逆向更加困难。希望能让大家学到了一些新的和有用的东西。
**下载链接**
**CrackMe：**
**Ollydbg：**[ http://www.ollydbg.de/](http://www.ollydbg.de/)