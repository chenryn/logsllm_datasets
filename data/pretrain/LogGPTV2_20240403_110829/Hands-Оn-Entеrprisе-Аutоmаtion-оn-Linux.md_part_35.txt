adding another recommendation from section 5 of the CIS Benchmark, thus building up our
playbook code in a scalable, manageable fashion.
Building up security policies in Ansible
If we were to proceed precisely as we did in the previous section, then when it comes to
section 5.2.9 of the RHEL 7 CIS Benchmark version 2.2.0 (Ensure SSH
PermitEmptyPasswords is disabled), we would create a new role
called rhel7cis_recommendation529 and put the relevant tasks and handlers inside it.
I'm sure that you will be able to see that this does not scale well – the creation of a new role
means we need to specify it in our top-level playbook, which would look something like
the following:
---
- name: Test and implement CIS benchmark
hosts: all
become: yes
roles:
- rhel7cis_recommendation528
- rhel7cis_recommendation529
Having one role per line, with almost 400 roles to include, would quickly become tedious
and detract from the highly manageable nature of our Ansible code.
Exactly how you divide up your Ansible tasks into roles is up to you, and you should
utilize the method that you find most manageable. As a suggestion, though, looking at the
table of contents for our example CIS Benchmark, we can see that the recommendations are
divided into six sections. Those in section 5 relate specifically to Access, Authentication, and
Authorization, and thus it is entirely logical that we might want to group all of these
together into one role, perhaps called rhel7cis_section5.
With this decision made regarding playbook structure, we can now proceed to build both
the checks for recommendations 5.2.8 and 5.2.9 into the same role. They can share the same
handler too, as both relate to SSH daemon configuration. Thus, our new role's tasks could
look like the following:
---
- name: 5.2.8 Ensure SSH root login is disabled (Scored - L1S L1W)
lineinfile:
state: present
dest: /etc/ssh/sshd_config
[ 378 ]
CIS Hardening with Ansible Chapter 14
regexp: '^PermitRootLogin'
line: 'PermitRootLogin no'
notify: Restart sshd
- name: 5.2.9 Ensure SSH PermitEmptyPasswords is disabled (Scored - L1S
L1W)
lineinfile:
state: present
dest: /etc/ssh/sshd_config
regexp: '^PermitEmptyPasswords'
line: 'PermitEmptyPasswords no'
notify: Restart sshd
The resulting code is still highly readable and is broken down into manageable chunks, but
is now not so granular that it would be difficult to maintain the top-level playbook.
Our handler code remains the same as before, and now when we run the role on a system
that does not meet either of these recommendations, the output should look something like
the following screenshot:
[ 379 ]
CIS Hardening with Ansible Chapter 14
This is very clean and tidy, and hopefully you can see how this could scale well when it
comes to implementing all of the nearly 400 recommendations from the CIS Benchmark if
you chose to do so. However, it also raises an important consideration: in an ideal world,
all of the CIS recommendations would be applied to every machine, yet in reality, this is
not always possible. In the Applying security policy wisely section of Chapter 13, Using CIS
Benchmarks, we discussed a variety of recommendations that you would apply caution to
implementing. In addition, as much as it is desirable to never perform a remote login with
the root account over SSH, I have come across systems where this is actually required to
support some kind of legacy system until it can be updated.
In short, there will always be a requirement for exceptions in the process of policy
enforcement. The important thing is to handle this in a graceful manner. Say you have 100
Linux machines to apply our newly written mini security policy to, but that two require
remote root logins to be enabled.
In this instance, we have two choices:
Maintain a separate set of playbooks for the two servers where the exceptions are
required
Find a way to selectively run the tasks in our role without having to modify it
Of these choices, the second is clearly the better of them as it supports us in maintaining
one single playbook. But how do we achieve this?
Ansible offers us two tools to approach this problem. The first is the when clause that we
have already considered several times in this book. So far, we have only looked at this
clause to evaluate a condition programatically (for example, to run a disk cleanup on the
condition that free space on the disk falls below a certain value). In this instance, we
employ a much simpler implementation – simply evaluating whether a Boolean value is
true or not.
Suppose that we add the following code below our task to implement recommendation
5.2.8:
when:
- recommendation_528|default(true)|bool
[ 380 ]
CIS Hardening with Ansible Chapter 14
These two lines evaluate a variable called recommendation_528 and applies two Jinja2
filters to ensure it is processed correctly, even when the variable is undefined:
The default filter sets the variable to true by default as Ansible will fail the
play with an error if any variable it encounters is undefined. This removes the
need for us to define these variables up-front – our role simply defaults them to
true unless we set them otherwise.
The second filter casts them to a bool type to ensure a reliable evaluation of the
condition.
Remember that true can be both a string and a Boolean value, depending
on how you interpret it. Using the |bool filter ensures that Ansible
evaluates it in the Boolean context.
Similarly, for the second task, we would add the following immediately below the notify
clause:
when:
- recommendation_529|default(true)|bool
Now, if we run the playbook without doing anything else to it against a system that is not
compliant, it behaves exactly as it did before, as shown in the following screenshot:
[ 381 ]
CIS Hardening with Ansible Chapter 14
The magic now happens when we want to run it against a system where we wish to skip
one or both of these recommendations. Imagine that our host, legacy-testhost, is a
legacy system where remote root logins are still a requirement. To use this role on this
particular system, we know that we must set recommendation_528 to false. This can be
performed at a variety of levels, and the inventory is probably the most sensible place to
define it as it prevents someone from accidentally running the playbook in the future
without defining this and hence breaking our legacy code by denying remote root logins.
We can create a new inventory for this system that might look something like this:
[legacyservers]
legacy-testhost
[legacyservers:vars]
recommendation_528=false
Having set the variable for the recommendation we want to skip to false, we can then run
our role against this new inventory, and the results should look something like those
shown in the following screenshot:
This was exactly what we desired – recommendation 5.2.8 was skipped on our legacy
system, and all we had to do was define a variable in the inventory – the role code from all
our other servers was reused.
[ 382 ]
CIS Hardening with Ansible Chapter 14
Using the when clause with a simple Boolean variable works well for simple decisions like
this, but what about when you have multiple criteria to evaluate? Although the when clause
can evaluate both logical and and or constructs, this could become somewhat difficult to
manage as complexity increases.
Ansible tags are the second tool that will help us here, and these are a special feature that is
designed specifically to allow you to run only desired portions of a role or playbook, rather
than having to run the whole thing from start to finish. Suppose that we add the following
tags below our task for implementing recommendation 5.2.8:
tags:
- notlegacy
- allservers
Below the task for recommendation 5.2.9, we might add the following:
tags:
- allservers
The behavior of these tags is best explained by example, and as this is a hands-on book, we
will do exactly that. The first thing to note is that adding tags to a playbook (or role within a
playbook) does absolutely nothing unless you specify which tags to run, or to skip. Thus, if
we run our playbook in its current form, it behaves exactly as it always has, in spite of the
addition of the tags, as the following screenshot shows:
[ 383 ]
CIS Hardening with Ansible Chapter 14
The magic comes when we specify which tags are to be run. Let's repeat the previous
command, but this time add --skip-tags=notlegacy. The switch does exactly what it
implies – all tasks with the notlegacy tag are ignored. The following screenshot shows the
output from such a run of this playbook:
Here, we see a marked difference from the use of the when clause – where previously we
observed that our task for recommendation 5.2.8 was evaluated but subsequently skipped,
it does not even appear in the preceding playbook output – in short, the entire task has
been treated as if it didn't exist.
If we had run the playbook with the --tags=allservers option, we would have
observed both tasks running, as both were tagged with this value.
This becomes incredibly useful not only for our example here, but when considering the
wider benchmark document. For example, we have already discussed that all
recommendations are either level 1 or level 2. Equally, we know that some are scored, and
some not.
[ 384 ]
CIS Hardening with Ansible Chapter 14
Knowing that level 1 benchmarks are less likely to disrupt the day-to-day running of a
Linux server, we could implement all recommendations in a playbook with the level as one
of the tags for each, and then if we were to run the playbook with --tag=level1, then
only the level 1 recommendations would be implemented. Working with this example, the
tags for our task for recommendation 5.2.8 might be as follows:
tags:
- notlegacy
- allservers
- level1
- scored
When you are building up your roles and playbooks to implement security benchmarks,
regardless of the operating system or security standard, it is recommended that you make
use of the when clause and tags to the best of your advantage. Remember – when
automating at enterprise scale, the last thing you want is lots of fragmented pieces of code
to manage, all of which are similar but do slightly different things. The more you can
standardize, the more manageable your enterprise will be, and appropriate use of these
features will serve you well in ensuring you can maintain a single Ansible code base, and
yet tailor its actions at runtime to handle the exceptions in your server estate.
Since we have been considering appropriate playbook and role structure for our security
benchmark, we have deliberately kept our examples simple in this section. In the next
section, we will revisit some of the more complex examples we highlighted in Chapter 13,
Using CIS Benchmarks, and demonstrate how Ansible makes them far easier to code and
understand.
Implementing more complex security
benchmarks in Ansible
One of the examples we considered in detail in Chapter 13, Using CIS Benchmarks, was
recommendation 3.1.2, which is concerned with packet redirect sending being disabled.
This is considered important on any machine that is not supposed to be acting as a router
(though it should not be implemented on a router as it would stop the router from
functioning correctly).
[ 385 ]
CIS Hardening with Ansible Chapter 14
On the face of it, this recommendation looks quite straightforward – we simply need to set
these two kernel parameters, as follows:
net.ipv4.conf.all.send_redirects = 0
net.ipv4.conf.default.send_redirects = 0
In spite of this apparent simplicity, we ended up developing almost 60 lines of shell script
to implement this check because we had to check both the currently active kernel
parameters and persistent configuration file values, and then perform the appropriate
changes if the values were not set as desired.
Here, once again, Ansible comes to our rescue. The sysctl module within Ansible wraps
up many of the tests and configuration work that we constructed into our shell script.
Further, we can use a loop so that the same task code can we run twice – once against each
of the aforementioned kernel parameters.
When developing a role for this, we could define a single task that looks something like
this:
---
- name: 3.1.2 Ensure packet redirect sending is disabled (Scored - L1S L1W)
sysctl:
name: "{{ item.paramname }}"
value: "{{ item.paramvalue }}"
reload: yes
ignoreerrors: yes
sysctl_set: yes
state: present
loop:
- { paramname: net.ipv4.conf.all.send_redirects, paramvalue: 0 }
- { paramname: net.ipv4.conf.default.send_redirects, paramvalue: 0 }
notify:
- Flush IPv4 routes
The recommendation also says that if we implement these changes, we should also flush
out the IPv4 routes on the system. This is also achieved through a sysctl parameter, and
so we simply use the sysctl module again, only this time in a handler:
- name: Flush IPv4 routes
sysctl:
name: net.ipv4.route.flush
value: "1"
sysctl_set: yes
[ 386 ]
CIS Hardening with Ansible Chapter 14
Running this against a test system might yield output similar to that shown in the following
screenshot:
As we can see from the preceding screenshot, this code has run successfully and applied
the setting recommended by the benchmark, and as a direct result of the change, the
handler has fired and flushed the IPv4 routes. The overall result of this is that what took 57
lines of fairly unreadable shell script can now be achieved in 14 lines of far more readable
YAML.
So far, we have built up a clear picture of how Ansible can make the design and
implementation of CIS recommendations straightforward, especially when compared to
alternatives such as shell scripting. We have noted that native Ansible modules such as
sysctl and lineinfile can gracefully wrap up a multitude of steps that would have
have been performed by a shell script. However, there are times when you, as the playbook
author, must make some important decisions for your playbooks, and we will look at this
in more detail in the following section.
[ 387 ]
CIS Hardening with Ansible Chapter 14
Making appropriate decisions in your playbook
design
As you build up your roles and playbooks to implement security baselines, you will
discover that some of your implementation will be cut and dried (for example, you will
almost certainly know whether you want root SSH logins to be possible or not), whereas
there will be decisions to be made for other aspects. Time synchronization is one such
example, and in this section, we will explore this in more detail to demonstrate the kinds of
decisions you can expect to make when designing your roles, as well as how to address
them in a constructive manner.
If you review section 2.2.1 of the RHEL 7 CIS Benchmark (version 2.2.0), you will see that it
is entirely concerned with time synchronization. Indeed, this is an important function in
just about every Enterprise Linux infrastructure, and discrepancies between the clocks on
servers can cause issues such as with certificate validity and Kerberos tickets.
Although it is almost universally agreed that time synchronization is vitally important,
there is less agreement on the way to achieve it. For example, there are two main time
synchronization services available for most mainstream Linux distributions:
chrony
ntpd
Although chrony is now the standard on RHEL 7, this does not mean that the venerable
ntpd service will no longer work – in fact, some enterprises still choose to implement this
because they have extensive experience with it.
It is entirely possible to get Ansible to detect which of these two services a given Linux
server is using – at a high level, we could get Ansible to do the following:
1. Query the RPM package database to see whether ntpd, chrony, or both are
installed.
2. If one or both are installed, detect which one is active:
a. If neither are active, this needs rectifying as we have established the need
for time synchronization.
b. If both are active, the services will clash and one should be disabled.
[ 388 ]
CIS Hardening with Ansible Chapter 14
As I'm sure you will see, there comes a point in the preceding process where an
intervention is required – if neither service is started, we need to choose one to start. If both
are active, we need to disable one. This is where Ansible's ability to help ends – it cannot
decide for your particular enterprise which of these two perfectly valid services is best for
your use case.
Thus, it is important to make a decision up-front about which time synchronization service
you are using. With this decision made, playbooks can then be specifically coded to
perform the appropriate checks and equally perform the appropriate remediation steps as
required. In addition, we know from our discussion in Chapter 1, Building a Standard
Operating Environment on Linux, that automation at enterprise scale is supported by
commonality and standards – so we know from these principles that we should choose a
standard time synchronization service and stick with it except where there is a good
business reason to raise an exception.
To progress this example, let's look at recommendation 2.2.1.1. This states that we should
ensure that a time synchronization service is in use – though it is agnostic about which one.
If we have made our decision up-front about which service is relevant, our playbook
development is easy. Suppose we have chosen chrony (the default for RHEL 7); our role
for this recommendation might be as follows:
---
- name: 2.2.1.1 Ensure time synchronization is in use (Not Scored - L1S
L1W)
yum:
name: chrony
state: present
- name: 2.2.1.1 Ensure time synchronization is in use (Not Scored - L1S