列的表，如表SeqTbl所示。我们在使用自动分配的数值时经常会见到像
这样的表。
SeqTbl
g丨连续编号）name（名字）
迪克
安
莱露
卡
玛丽
本
虽然编号那一列叫作连续编号，但实际上编号并不是连续的，缺少了
4和7。我们要做的第一件事，就是查询这张表里是否存在数据缺失。如
果像本例这样，数据只有几行，那么我们一下子就能找出来。但是，如果
数据有100万行，应该就不会有人用肉眼去查询了吧。
如果这张表的数据存储在文件里，那么用面向过程语言查询时，步骤
应该像下面这样。
1.对“连续编号”列按升序或者降序进行排序。
2.循环比较每一行和下一行的编号。
步骤很简单，但是也体现了面向过程语言和文件系统处理问题的特
点：文件的记录是有顺序的，为了操作记录，编程语言需要对记录进行排序。
注0
而表的记录是没有顺序的，而且SQL也没有排序的运算符·。SQL会将
也奇大家会想，不是有即
BY 子句呵? 但实际上 ORIBR BY
多条记录作为一个集合来处理，因此如果将表整体看作一个集合，就可以
义的一部分。“&Y在表示
不是 SIFL的运算符。而是光标定
像下面这样解决这个间题。
查询结果时很方便，但是它本身
并不是关系运算特。( GataDese
SBLBCT存在缺失的端号A95P
-知果有查询结果，说明存在缺失的编号
do Depths Releronel Thery for
Rractfr:oners, 0′Re1lly Medfa,
2006 1
HAVING COUNT(*) <> MAX(seg) 
FROM SegTb1
---
## Page 70
1-4 HAVING子句的力量 
5/
■执行结果
gap
存在缺失的编号
如果这个查询结果有1行，说明存在缺失的编号：如果1行都没有，
说明不存在缺失的编号。这是因为，如果用cOUNT（*）统计出来的行数等
于“连续编号”列的最大值，就说明编号从开始到最后是连续递增的，中
间没有缺失。如果有缺失，COUNT(*）会小于MAX(seq），这样 HAVING子
句就变成真了。这个解法只需要3行代码，十分优雅。
如果用集合论的语言来描述，那么这个查询所做的事情就是检查自然
数集合和SeqTbl集合之间是否存在一一映射（又称双射）。换句话说，就
是像下图展示的那样，MAx（seq）计算的，是由“到seq最大值为止的没
有缺失的连续编号（即自然数）”构成的集合的元素个数，而cOUNr（*）计
算的是SeqTbl这张表里实际的元素个数（即行数）。
有多余的元素
集合A：MAX(seq)=
1 2 3 4 5 6 7 8
{自然数集合)
集合B：COUNT(*)=
1 2 3 5 6 8
(SeqTbl集合)
于是，如果像上图这样存在缺失的编号，那么集合A和集合B中的
元素个数肯定是不一样的。
也许大家注意到了，上面的 SQL语句里没有GROUP BY子句，此时
整张表会被聚合为一行。这种情况下HAVING子句也是可以使用的。在以
前的 SQL标准里，HAVING子句必须和GROOP BY子句一起使用，所以到
注0
现在也有人会有这样的误解。但是，按照现在的SQL标准来说，HAVING
也可以认为是对空字段进行了
子句是可以单独使用的·。不过这种情况下，就不能在SELBCT子句里引
 B 操作,只不过省路了
函数时不指定 PARTTTOS 3v 子
 B 子句。如果使用度口
用原来的表里的列了，要么就得像示例里一样使用常量，要么就得像
句，就是把整个表当作一个分区
SELECTCONT（·）这样使用聚合函数。
来处埋的，思脐与这里出是一样
的。 评情调参考本书2-5 节。
现在，我们已经知道这张表里存在缺失的编号了。接下来，再来查询
---
## Page 71
58
—第1章神奇的SOL
一下缺失编号的最小值。求最小值要用MIN函数，因此我们像下面这样写
SQL 语句。
查询缺失编号的最小值
SSLBCT MIN(seg + 1) AS gap
FROM SeqTb1
MHERE (seg+ 1) NOT IN ( SELECT seq FROM SeqTbl);
■执行结果
gap
4
这里也是只有3行代码。使用NOTIN进行的子查询针对某一个编号，
这几行因为找不到紧接着的下一个编号，所以子查询的结果为真。如果没
有缺失的编号，则查询到的结果是最大编号8的下一个编号9.前面已经
说过了，表和文件不一样，记录是没有顺序的（表SeqTbl里的编号按升
序显示只是为了方便查看）。因此，像这条语句一样进行行与行之间的比
较时其实是不进行排序的。
顺便说一下，如果表SeqTbl里包含NULL，那么这条SQL语句的查
询结果就不正确了。如果不明白为什么，可以参考1-3节。
上面展示了通过SQL语句查询缺失编号的最基本的思路，然而这个
查询还不够周全，并不能涵盖所有情况-例如，如果表SeqTbl里没有编
号1，那么缺失编号的最小值应该是1，但是这两条SQL语句都不能得出
正确的结果（请试着自己模拟分析一下，推测出可能的结果）。关于查询
缺失编号的更完备的做法，我们将在1-10节学习。
用HAVING子句进行子查询：求众数
托马斯·杰斐逊创立的美国名校弗吉尼亚大学曾经在1984年发表报
告称，修辞交流专业的毕业生首份工作的平均工资达到了55000美元，
按当时1美元=240日元的汇率来算，大约是1320万日元。乍一看好像
毕业生大多都能拿到很高的工资，然而这个数字背后却有一些玄机。因为
---
## Page 72
1-4 HAVING子句的力量 
这一届毕业生里包含了被称为"校史上最伟大选手“的NBA新星拉尔夫·桑
注0
普森。也就是说，大学用来统计的毕业生表中存在极端的情况，大概就
这 个 故 事取 白 L5omniok 和 N,
S=tith 的著作 (湿强统计学入门)
像表Graduates 这样。
梁杰评，辽宁教育出版社，2002
年 L
Graduates（毕业生表）
me丨名字
income [收入)
桑首森
400 000
迈克
30 000
怀特
20 000
阿诺德
20 000
史密斯
20 000
劳伦斯
15 000
哈德逊
15 000
肯特
10 000
贝克
10 000
斯科特
10 000
从这个例子可以看出，简单地求平均值有一个缺点，那就是很容易
受到离群值（outlier）的影响。这种时候就必须使用更能准确反映出群
体趋势的指标一—众数（mode）就是其中之一，它指的是在群体中出现
次数最多的值，因此在日语中也被称为流行值。就上面的表Graduates
来说，众数就是10000和20000这两个值。接下来我们思考一下如何
用SQL语句求众数。
有些DBMS已经提供了用来求众数的函数，但其实用标准SQL也很
简单。思路是将收入相同的毕业生汇总到一个集合里，然后从汇总后的各
个集合里找出元素个数最多的集合。用SQL这么操作集合正如探囊取物
一样简单，
--求众数的SQL语句（11：使用谓词
SELBCT income,  CotMrI*) AS cnt
GROUP BY income
HAVING COUNI(+) >= ALL( SELECT COUNT(+)
FROM Graduates
GROUP BY inconel ,
图灵社区会员非洲铜(PI:EMAIL）专享尊重版权
---
## Page 73
60
第1章神奇的 SQL
■执行结果
1ncone
cnt
10000
20000
E
GROUPBY子句的作用是根据最初的集合生成若干个子集（类似于1-2
节介绍过的，生成若干个递归子集以进行排序）。因此，将收入（income）
作为GROUP BY的列时，将得到S1～S5这样5个子集，如下图所示。
■将收入|income】作为GROUPBY的列时得到的5个子集
51: 400 000
S2: 30 000
桑普查
盈克
S3: 20 000
54: 15 000
55: 10 000
患要的是S3R15S
这几个子集里，元素数最多的是S3和S5，都是3个元素，因此查询
的结果也是这2个集合。
补充一点，1-3节提到过ALL谓词用于NULL或空集时会出现间题，
可以用极值函数来代替。这里要求的是元素数最多的集合，因此可以用
MAX 函数。
-求众数的SQL语句（2）：使用极值函数
SELSCT 1ncone, CouNT(*) AS cnt
FEOM Graduates
GROUP BY 1ncome
HAVING COUNT(*) >= 1 SEL&CT MAX |cnt)
FBOM( SELECT COUNT(+) AS cnt
GROUP BY Lncome) TXP ):
FROM Graduates
如果表Graduates是存储在文件里的，需要用面向过程语言的方法来
求众数时，又该怎么做呢？恐伯要先按收入进行排序，然后一行一行地循
---
## Page 74
4HAVING子句的力量 
61
环处理和中断控制，遇到某个收入值的人数超出前面一个收入值的人数时，
将新的收入值赋给另一个变量并保存，以便后续使用。我们能发现，与这
种做法相比，使用SQL既不需要循环也不需要赋值。
用HAVING子句进行自连接：求中位数
当平均值不可信时，与众数一样经常被用到的另一个指标是中位数
（median）.它指的是将集合中的元素按升序排列后恰好位于正中间的元素。
如果集合的元素个数为偶数，则取中间两个元素的平均值作为中位数。前
面的表Graduates 里有10行数据，所以我们取“史密斯，20 000”和“劳
伦斯，15000”的平均值17500作为中位数。
如果用SQL，该如何求中位数呢？像面向过程语言的处理方法那样排
完序逐行比较，显然是不合理的。所以我们来思考一下如何用面向集合的
方式，来查询位于集合正中间的元素。
做法是，将集合里的元素按照大小分为上半部分和下半部分两个子集，
同时让这2个子集共同拥有集合正中间的元素。这样，共同部分的元素的
平均值就是中位数，思路如下图所示。
■中位数求法的思路
S0:Gradu
S1:下半邮分+1个
52:上半部分+1个
000:00000 0000 020002 000 0000 91005100 0100 01L 000 01
像这样需要根据大小关系生成子集时，就轮到非等值自连接出场了。
--求中位数的SQL语句：在HAVIBN子句中使用非等值白连接
SELBCT AVG (DISTINCT income)
FROM (SELECT T1.income
FROM Graduates T1, Graduates T2
GROUP BY T1-income
---
## Page 75
●62
—第1章神奇的 SQL
-S1的条件
HAVING SUM(CASE MHE T2 -income >= T1.income THEN 1 ELSE 0 END)
/（1 =COUNT(*)/2”里的等号，
这个等号是有意地加上的。加上等号并不是为了清晰地分开子集S1和
S2，而是为了让这2个子集拥有共同部分。如果去掉等号，将条件改成“>
cOUNT（*)/2”，那么当元素个数为偶数时，S1和S2就没有共同的元素了，
也就无法求出中位数了。
如果事先知道集合的元素个数是奇数，那么因为FROM子句里的子查
询结果只有一条数据，所以外层的AVG函数可以去掉。但是，如果要写出
更通用的SQL语句（即适用于元素个数为偶数这种情况），AVG函数还是
需要的。这道例题的解法运用了CASE表达式、自连接以及HAVING子句
等SQL的各种利器，笔者觉得还是很棒的。
在发表这个有些问题的平均工资时，弗吉尼亚大学并没有公布中位数
等指标。如果在各位（或者各位的子女）选择学校时，一个学校不仅提供
了与升学率和就业情况相关的平均值，还提供了众数和中位数，那么也许
我们还是可以相信这所学校是诚实的。
查询不包含NULL的集合
COUNT函数的使用方法有 COCNT（*）和 COUNT（列名）两种，它们的区
别有两个：第一个是性能上的区别：第二个是COUNT（+）可以用于NULL，
而COUNT（列名）与其他聚合函数一样，要先排除掉NULL的行再进行统计。
第二个区别也可以这么理解：coUNr（*）查询的是所有行的数目，而
COUNT（列名）查询的则不一定是。
对一张全是NULL的表NulITbI执行SELBCT子句就能清楚地知道两
者的区别了。
---
## Page 76
14 HAVING子句的力量—
63
NulITbl
00_1 (列 1)
--在对包含NULL的列使用时，COUNT[*|和COUNT(列名）的查调结果是不同的
SELECT COUNT (*) , COUNT (co1_1)
FROM Nul1Tb1;
■执行结果
count (+)
count (co1_1)
对于这两个区别，在编写SQL语句时我们当然需要多加留意，但是
如果能好好利用，它们也可以发挥令人意想不到的作用。例如，这里有一
张存储了学生提交报告的日期的表Students，如下所示。
Students
加den_id（学号1D]
dp[学院】
sbmt_dabe （提交目期）