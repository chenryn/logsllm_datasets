sampled key ğ¾. More concretely, our timed commitment consists
of the puzzle ğ‘ from (1), prime-order group ciphertexts in (2) and
ğ¾,(cid:8)(ğ‘ğ‘–,0, ğ‘ğ‘–,1) = (ğºğ‘ ğ‘– , ğ¾ğ‘ ğ‘– Â· ğºğ‘Ÿğ‘–)(cid:9)
ğ‘–âˆˆ[ğ›¼]
where ğ‘Ÿğ‘– is the ğ‘–-th bit of ğ‘Ÿ. Our NIZK proof must now certify that
the following conditions are met:
1) The public key ğ¾ is correctly sampled from the class group.
2) The class group ciphertexts {ğ‘ğ‘–,0, ğ‘ğ‘–,1}ğ‘–âˆˆ[ğ›¼] encrypt the bit de-
3) Both ğ‘–-th ciphertexts ( Ëœğ‘ğ‘–,0, Ëœğ‘ğ‘–,1) and (ğ‘ğ‘–,0, ğ‘ğ‘–,1) either encrypt 0 or
composition of the randomness ğ‘Ÿ used in ğ‘1.
1.
Statement 1) is a standard proof of knowledge of discrete logarithm
(over the class group), whereas 2) can be reduced to a proof discrete
logarithm equality (again over the class group) by running the
linear reconstruction in the exponent. Thus the only statement that
concerns two different groups is 3). Fortunately, we can split the
Session 10C: Foundations CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea2666statement as
( Ëœğ‘ğ‘–,0, Ëœğ‘ğ‘–,1) AND (ğ‘ğ‘–,0, ğ‘ğ‘–,1) Encrypt 0
( Ëœğ‘ğ‘–,0, Ëœğ‘ğ‘–,1) AND (ğ‘ğ‘–,0, ğ‘ğ‘–,1) Encrypt 1.
OR
where each clause individually can again be reduced to a standard
proof of discrete logarithm equality (over the respective group). The
clauses are then combined via standard OR and AND composition of
sigma protocols. In some sense, the bridging across the two groups
is delegated to the AND composition of sigma protocols, which can
be implemented very efficiently (e.g. simply use the same challenge
in the sigma protocol). Finally, statements 1), 2), and 3) are again
stitched together via AND composition of sigma protocols.
2.3 Distributed Randomness Generation
We show the applicability of our CCA timed commitment by con-
structing a distributed randomness generation protocol: The proto-
col is run among ğ‘› parties (ğ‘ƒ1, . . . , ğ‘ƒğ‘›), and the objective is to com-
pute a 256-bit random string ğ‘Ÿâˆ—, that is, unbiased, and unpredictable
even in the presence of ğ‘› âˆ’ 1 corrupted parties, that cooperate to
bias the distribution of ğ‘Ÿâˆ—. Our protocol proceeds in three phases.
Commitment Phase: Each party ğ‘ƒğ‘– locally samples a random integer
ğ‘¥ğ‘– â† Zğ‘ (where Zğ‘ is the message space of the timed commitments)
and generates a timed commitment (ğ‘ğ‘–, ğœ‹ğ‘–) to such an integer. All
the timed commitments are generated with respect to a fixed time
parameter T, which conservatively bounds the duration of the
commitment phase. Parties broadcast their timed commitments to
other parties which locally verify the validity of each individual
commitment.
(Fast Termination) Opening Phase: Each party ğ‘ƒğ‘– then reveals ğ‘¥ğ‘–
along with the random coins used in generating their timed com-
mitment (ğ‘ğ‘–, ğœ‹ğ‘–). Parties can locally check if the opening is valid, by
recomputing the timed commitments of other parties themselves.
The final random value is computed as ğ‘Ÿâˆ— :=ğ‘–âˆˆ[ğ‘›] ğ‘¥ğ‘– by each party.
This optimistic case, where everyone reveals their valid openings
does not require force opening of any of the timed commitments
and the final value ğ‘Ÿâˆ— is generated without the need to perform any
sequential computation.
(Slow Termination) Force-Opening Phase: In the event that one or
more parties do not reveal a valid opening for their commitments,
the other parties need to force-open their commitments to compute
ğ‘Ÿâˆ—. To avoid a computational blowup in the number of aborting
parties, this is done by evaluating the addition homomorphically
over the commitments
âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’â†’ Ëœğ‘
where Ëœğ‘ contains the outputğ‘–âˆˆ[ğ‘›] ğ‘¥ğ‘– = ğ‘Ÿâˆ—. Thus the output of the
(ğ‘1, . . . , ğ‘ğ‘›) Eval(sum,Â·)
protocol can be obtained by simply force-opening Ëœğ‘. This phase can
be further optimized by letting a single designated party (say ğ‘ƒ ğ‘—)
compute the force-opening algorithm along with succinct proof
of correctness [62, 74]. The end result is that the revealing of com-
mitments is publicly verifiable even if one or many parties do not
reveal their valid openings.
Analysis. The resulting output ğ‘Ÿâˆ— is both unbiased and unpre-
dictable. In our analysis, we show a stronger statement: for an
adversary running in time at most T, ğ‘Ÿâˆ— is computationally indis-
tinguishable from a value sampled uniformly from Zğ‘. For this
analysis to go through, the CCA security of the timed commitment
is crucial: Intuitively, it prevents the adversary from mauling hon-
estly generated commitments and choosing its own ğ‘¥ğ‘– as a function
of the honestly committed values, which would ultimately result in
a biased distribution.
3 PRELIMINARIES
We denote by ğœ† âˆˆ N the security parameter and by ğ‘¥ â† A(in; ğ‘Ÿ)
the output of the algorithm A on input in using ğ‘Ÿ â† {0, 1}âˆ— as its
randomness. We often omit this randomness and only mention it
explicitly when required. The notation [ğ‘›] denotes a set {1, . . . , ğ‘›}
and [ğ‘–, ğ‘—] denotes the set {ğ‘–, ğ‘– + 1, . . . , ğ‘—}. We model non-uniform
probabilistic polynomial time (PPT) adversaries as families of circuits
{Ağœ†}ğœ†âˆˆN of size ğœ†ğ‘‚(1) with ğœ†ğ‘‚(1) input and output bits. We also
consider the parallel running time of (PRAM) adversaries that we
also model as circuits. The parallel time is determined by the depth
of the circuit and the total running time is determined by the total
size of the circuit.
Non-Interactive Zero-Knowledge Proofs. We make use of non-
interactive zero-knowledge (NIZK) proof [9] for a language L that
allows a prover to convince a verifier about the validity of a certain
statement stmt âˆˆ L without revealing any other information. We
require a NIZK proof to satisfy the properties of zero-knowledge,
and simulation soundness [67]. We recall the formal definitions
in Appendix A.
Homomorphic Time-Lock Puzzles. Time-lock puzzles [66] al-
low one to hide a secret for a certain amount of time T. A homomor-
phic time-lock puzzle additionally offers homomorphic evaluation
of several puzzles to generate a single puzzle. The notion was pro-
posed by Malavolta and Thyagarajan [55]. It consists of a setup
algorithm (PSetup), that takes as input a time hardness parameter
T and outputs public parameters of the system pp, a puzzle genera-
tion algorithm (PGen) that, on input the public parameter and a
message, generates the corresponding puzzle. One can then evalu-
ate homomorphically functions over encrypted messages (PEval)
and solve the resulting puzzle in time T (Solve). The security re-
quirement is that for every PRAM adversary A of running time
â‰¤ Tğœ€(ğœ†) the messages encrypted are computationally hidden. They
also propose efficient constructions for linear and multiplicative
homomorphism based on the sequential squaring assumption in
the RSA group. Below we recall the formal definitions from [55].
We recall the formal definitions in Appendix A.
Class Groups. Given a non square integer Î”  2ğœ†ğµ is a prime. The reason why we need to use a prime number
will become clear in our construction of CCA timed commitments.
We will work with a cyclic subgroup G âŠ‚ ğ¶ğ‘™(Î”ğ¾), generated by
a random square ğº of ğ¶ğ‘™(Î”ğ¾) (such an element can be efficiently
generated by generating an ideal of OÎ”ğ¾ above a random splitting
prime, cf [46, Subsection 3.1]). We denote ğ‘  the (unknown) order of
G which is a divisor of Ëœğ‘ . For large ğ‘ we can assume that gcd(ğ‘ , ğ‘) =
1.
In ğ¶ğ‘™(Î”ğ‘), we will work with a cyclic subgroup Î“ of the squares
of ğ¶ğ‘™(Î”ğ‘) generated by ğ›¾ where ğ›¾ := ğ›¾ğ‘ğ¹ with ğ›¾ğ‘ = ğœ“ğ‘(ğº). We thus
have that Î“ is of order ğ‘ğ‘  and satisfy Î“ â‰ƒ Î“ğ‘ Ã— âŸ¨ğ¹âŸ©, where Î“ğ‘ = âŸ¨ğ›¾ğ‘âŸ©
is the subgroup of ğ‘âˆ’th powers, Î“ğ‘ := {ğ‘ğ‘, ğ‘ âˆˆ Î“}. The HSMğ¶ğ¿
assumption (introduced in [28], cf Definition B.3) states that given
an element ğ›¿ of Î“ it is hard to tell if ğ›¿ âˆˆ Î“ğ‘ or not. It can be seen as
an adaptation of Paillierâ€™s DCR assumption in the CL setting.
The class group generator CGGen depicted in Fig. 1 outputs
all these parameters: G, ğº, ğ¹, ğ›¾, ğ›¾ğ‘, Ëœğ‘. Note that this is a public coin
setup: the seeds of the probabilistic prime generators to compute
ğ‘, Ëœğ‘ and ğº are published.
The fast variant of the CL encryption scheme that we consider
is described in Appendix C. As a side contribution, we prove in
Theorem C.1 that with a slight modification of the definition of
ğº, the indistinguishability of the scheme holds under the HSMğ¶ğ¿
assumption (the security of this variant was not really analysed in
[27]).
Our new homomorphic time-lock puzzle from class group is
depicted in Figure 2. The setup consists in running CGGen and
computing ğ» := ğº2T. Then the puzzle is
ğ‘ := (ğ‘1, ğ‘2) := (ğºğ‘Ÿ ,ğœ“ğ‘(ğ»ğ‘Ÿ) Â· ğ¹ğ‘š)
Note that ğ‘2 âˆˆ Î“ and ğœ“ğ‘(ğ»ğ‘Ÿ) is an element of Î“ğ‘. As a result,
retrieving ğ¹ğ‘š from ğ‘2 corresponds to solving the computational
subgroup decomposition problem Î“ â‰ƒ Î“ğ‘ Ã— âŸ¨ğ¹âŸ© associated to the
HSMğ¶ğ¿ assumption. This is done when solving the puzzle, by com-
puting ğœ“ğ‘(ğ»ğ‘Ÿ) as ğœ“ğ‘((ğºğ‘Ÿ)2T), and then retrieving ğ‘š from ğ¹ğ‘š using
the SolveDL algorithm. The homomorphic property of the scheme
follows from the Elgamal structure of the puzzle and the fact that
ğœ“ğ‘ is an homomorphism.
that ğ‘ğ‘ â‰¡ âˆ’1 (mod 4) and (ğ‘/ğ‘) = âˆ’1