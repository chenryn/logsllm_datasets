372
3,184
787
273
223
759
19
1,078
|F|
15,248
433
52,417
84
1,618
9,986
4,088
1,367
560
3,533
76
2,767
Tgr−1(s)
0.103
0.067
3.527
0.292
0.001
1.644
0.001
N/A
0.003
1.883
0.001
0.029
Tvrf(s)
6.513
0.997
136.505
5.658
0.016
43.828
0.004
N/A
0.021
50.149
0.000
0.649
1.27M/s
0.87M/s
Table 5: Real exploits diagnosed by ReCFA
Program
ffmpeg
Apache httpd
Nginx
Source
Type
Detected?
CVE-2016-10190
PoC exploit of [15]
PoC exploit of [15]
heap corruption
heap corruption
heap corruption
✓
✓
✓
the offline measurements, therefore invalid data w.r.t the attack is
detected as an abnormal runtime measurement. The prerequisite to
enumerate valid values of these data, though feasible for small IoT
programs, is difficult to be satisfied by the complicated software.
6 RELATED WORK
Control-flow attestation. Compared with the static attestation
that attests the integrity of program binaries and configurations,
runtime attestation measures the runtime states of the program
and the properties of its runtime inputs, outputs, and behaviors
[4, 5, 11–13, 16–18, 20, 21, 25, 31, 32, 35, 36, 39].
Semantic remote attestation [17] used a trusted language-based
virtual machine to attest dynamic properties of platform-independent
code running in it to the remote parties. DynIMA [11] combined
load-time measurements and dynamic taint analysis to enforce the
integrity of binaries. The architecture instrumented the program
with the tracking code that performs runtime integrity-related
checks, e.g. counting the small sequences of instructions between
consecutive returns and reporting an ROP attack when finding
several small instruction sequences executed consecutively. Several
hardware-based runtime attestations resorted to the mechanism
on the microcontroller [18] or specific off-chip hardware security
module [16] to generate the runtime attestation evidence.
Control-flow attestation [4, 5, 12, 13, 20, 21, 25, 31, 35, 36, 39]
is a kind of runtime attestation diagnosing the execution path of
remote software and ensuring the integrity of the program un-
der control-oriented exploits. C-FLAT[4] proposed to measure the
validity of the execution paths with the CFG of the program be-
ing attested. The prover aggregates the feature of executed paths
using hash operations to generate cumulative measurements. An
unexpected measurement indicates to the verifier that an illegal
path has been executed. Different from the isolated execution en-
vironment used by C-FLAT to protect the attestation, LO-FAT[13]
uses processor features and IP blocks, including branch monitor
and hash engine, to implement efficient control-flow attestation
for vanilla programs. To address the TOCTOU problem that al-
lows the attack to attest benign code while executing temporary
malicious code, ATRIUM [39] attests the executed instructions on
independent hardware. DIAT [5] adopts control-flow attestation to
verify only critical code modules of autonomous systems efficiently.
LiteHAX [12] extends the hardware-based attestation scheme to
support detecting data-only attacks. LAPE [21] is a control-flow
attestation for bare-metal systems. The instrumented firmware sep-
arates the code into attestation compartments. The calls between
functions in each compartment are captured as paths at runtime
and used to generate the attestation report during compartment
switching. MGC-FA [20] used a machine-learning model to predict
the vulnerable probability and decide the strictness-level of control-
flow attestation. Tiny-CFA [31] provides control-flow attestation
for low-end MCUs and only requires the hardware to support PoX
architecture [30]. OAT [35] leverages control-flow attestation to
enforce operation-scoped CFI. The measurement was protected by
the trusted execution environment and the control flow verifica-
tion is performed through abstract execution. Most of these works
mainly address the overhead reduction of the control flow verifi-
cation of small or moderate-size programs on resource-constraint
systems. ScaRR [36] is the first control-flow attestation designed for
complex systems. It provides a control-flow model for abstracting
execution paths. ScaRR relies on the CFG to generate the mea-
surement database. The path separation between checkpoints can
reduce the path explosion on measurements generation but also
brings in potential false negatives of the online remote verification
caused by the context missing. Besides, ScaRR requires source-code
instrumentation to detect and instrument the control-flow events
and generate the offline measurements. Contrarily, in this work,
we use binary CFG as the security policy and binary-level static
analysis for the instrumentation. ReCFA should be used when the
completeness of the measurement DB cannot be guaranteed, e.g.
320ReCFA: Resilient Control-Flow Attestation
ACSAC ’21, December 6–10, 2021, Virtual Event, USA
for complex programs whose paths and sub-paths are difficult to be
completely enumerated in advance. Several control-flow attestation
approaches also mitigate non-control-data attacks [4, 5, 13, 20, 39]
or data-only attacks [12, 32, 35].
Binary-Level Control-Flow Integrity Protections. There has been a
lot of works on binary-level control-flow integrity (CFI) defenses
[23, 27, 28, 33, 37, 38, 41, 42]. CCFIR [41] enforces coarse-grained
CFI policies that allow only a set of white-listed return targets.
binCFI [42] also proposed enforcement of coarse-grained policies
on stripped binaries without debugging or relocation information.
The constraints on the set of valid targets are relaxed for both back-
ward and forward edges to benefit the performance. O-CFI[27] uses
binary instrumentation to combine coarse-grained CFI with code
randomization, which enables the program to resist information
disclosure attacks on the targets of control transfers. The integrity
check at each indirect branch has an independent valid range of
target addresses. binCC [38] also restricts the returns using bound-
ary checking. Lockdown [33] is a DBI-based CFI protection with
a shadow stack. It creates the equivalent class per shared object
and profiles the CFG at runtime. The precision of Lockdown re-
lies on the symbol information that is absent in stripped binaries.
TypeArmor [37] enforces an arity-based forward-edge CFI policy
by checking the compatibility of the number of parameters of the
callee and the number of arguments supplied at each call-site at
the binary level, without considering the type constraints of pa-
rameters. τ-CFI [28] uses both the types and numbers of function
parameters directly extracted from binaries to enforce forward- and
backward-edge control flow transfers. BPA [23] constructs sound
and high-precision binary-level CFG based on the points-to analysis
over a new block memory model. BPA provides fine-grained CFI
policy efficiently. In general, the state-of-the-art CFI protections
focus on local enforcement. None of the above works addresses
detecting remote control-flow hijacking or diagnoses the vulnerable
trace triggering the exploitation.
7 CONCLUSION
Abstracting the runtime control-flow facts and faithfully delivering
them to the verifier is the critical issue for the control-flow attes-
tations. To overcome the limitations of the offline path measure-
ment and hash-based attestation on complicated software, we come
up with a new control-flow attestation approach to abstract the
control-flow facts efficiently and enforce control-flow integrity pol-
icy at the binary level. Our prototype implementation, ReCFA, relies
on the static binary analysis and binary instrumentation to con-
dense the runtime control-flow facts into deliverable size. ReCFA
enforces context-sensitive control-flow integrity with a remote
shadow stack and the policy mappings adapting off-the-shelf secu-
rity policies. Besides, to balance the efficiency and security, ReCFA
relies on the kernel-based trust anchor with user-level hardware-
assisted memory isolation to protect the prover-side mechanisms.
Future work includes supporting multi-thread programs and using
stronger hardware features to build a more robust trust anchor.
The source code of ReCFA has been made publicly available at
https://github.com/suncongxd/ReCFA.
ACKNOWLEDGMENTS
We thank the anonymous reviewers for the constructive comments.
We also would like to thank Dr. Xiaozhu Meng for the kind advice in
using the instrumentation tool Dyninst. Yumei Zhang, Xinzhi Liu,
Cong Sun, and Xiao Kan were supported by the National Natural
Science Foundation of China (No. 61872279) and the Key Research
and Development Program of Shaanxi (No. 2020GY-004).
REFERENCES
[1] [n.d.]. TrustZone technology for ARMv8-M Architecture, version 1.0. Available
at https://static.docs.arm.com/100690/0100/armv8_m_architecture_trustzone_
technology_100690_0100_00_en.pdf.
[2] [n.d.]. Zstandard. Available at https://facebook.github.io/zstd/.
[3] Martín Abadi, Mihai Budiu, Úlfar Erlingsson, and Jay Ligatti. 2009. Control-flow
integrity principles, implementations, and applications. ACM Trans. Inf. Syst.
Secur. 13, 1 (2009), 4:1–4:40.
[4] Tigist Abera, N. Asokan, Lucas Davi, Jan-Erik Ekberg, Thomas Nyman, Andrew
Paverd, Ahmad-Reza Sadeghi, and Gene Tsudik. 2016. C-FLAT: Control-Flow
Attestation for Embedded Systems Software. In CCS’16. 743–754.
[5] Tigist Abera, Raad Bahmani, Ferdinand Brasser, Ahmad Ibrahim, Ahmad-Reza
Sadeghi, and Matthias Schunter. 2019. DIAT: Data Integrity Attestation for
Resilient Collaboration of Autonomous Systems. In NDSS’19.
[6] Andrew R. Bernat and Barton P. Miller. 2011. Anywhere, any-time binary in-
strumentation. In Proceedings of the 10th ACM SIGPLAN-SIGSOFT workshop on
Program analysis for software tools, PASTE’11, Szeged, Hungary, September 5-9,
2011, Jeff Foster and Lori L. Pollock (Eds.). ACM, 9–16.
[7] Erik Buchanan, Ryan Roemer, Hovav Shacham, and Stefan Savage. 2008. When
good instructions go bad: generalizing return-oriented programming to RISC. In
CCS’08. 27–38.
[8] Nathan Burow, Scott A. Carr, Joseph Nash, Per Larsen, Michael Franz, Stefan
Brunthaler, and Mathias Payer. 2017. Control-Flow Integrity: Precision, Security,
and Performance. ACM Comput. Surv. 50, 1 (2017), 16:1–16:33.
[9] Shuo Chen, Jun Xu, and Emre Can Sezer. 2005. Non-Control-Data Attacks Are
Realistic Threats. In Proceedings of the 14th USENIX Security Symposium, Baltimore,
MD, USA, July 31 - August 5, 2005. USENIX Association.
[10] Victor Costan and Srinivas Devadas. 2016. Intel SGX Explained. IACR Cryptology
ePrint Archive 2016 (2016), 86.
[11] Lucas Davi, Ahmad-Reza Sadeghi, and Marcel Winandy. 2009. Dynamic in-
tegrity measurement and attestation: towards defense against return-oriented
programming attacks. In Proceedings of the 4th ACM Workshop on Scalable Trusted
Computing, STC’09. 49–54.
[12] Ghada Dessouky, Tigist Abera, Ahmad Ibrahim, and Ahmad-Reza Sadeghi. 2018.
LiteHAX: lightweight hardware-assisted attestation of program execution. In
ICCAD’18. ACM, 106.
[13] Ghada Dessouky, Shaza Zeitouni, Thomas Nyman, Andrew Paverd, Lucas Davi,
Patrick Koeberl, N. Asokan, and Ahmad-Reza Sadeghi. 2017. LO-FAT: Low-
Overhead Control Flow ATtestation in Hardware. In DAC’17. 24:1–24:6.
[14] Isaac Evans, Sam Fingeret, Julian Gonzalez, Ulziibayar Otgonbaatar, Tiffany
Tang, Howard E. Shrobe, Stelios Sidiroglou-Douskos, Martin Rinard, and Hamed
Okhravi. 2015. Missing the Point(er): On the Effectiveness of Code Pointer
Integrity. In SP’15. IEEE Computer Society, 781–796.
[15] Isaac Evans, Fan Long, Ulziibayar Otgonbaatar, Howard E. Shrobe, Martin C.
Rinard, Hamed Okhravi, and Stelios Sidiroglou-Douskos. 2015. Control Jujutsu:
On the Weaknesses of Fine-Grained Control Flow Integrity. In CCS’15. ACM,
901–913.
[16] Munir Geden and Kasper Rasmussen. 2019. Hardware-assisted Remote Runtime
Attestation for Critical Embedded Systems. In PST’19. IEEE, 1–10.
[17] Vivek Haldar, Deepak Chandra, and Michael Franz. 2004. Semantic Remote
Attestation: A Virtual Machine Directed Approach to Trusted Computing. In
Proceedings of the 3rd Conference on Virtual Machine Research And Technology
Symposium - Volume 3 (San Jose, California) (VM’04). 3–3.
[18] Stefan Hristozov, Johann Heyszl, Steffen Wagner, and Georg Sigl. 2018. Practical
runtime attestation for tiny iot devices. In NDSS Workshop on Decentralized IoT
Security and Standards (DISS)’18, Vol. 10.
[19] Hong Hu, Chenxiong Qian, Carter Yagemann, Simon Pak Ho Chung, William R.
Harris, Taesoo Kim, and Wenke Lee. 2018. Enforcing Unique Code Target Property
for Control-Flow Integrity. In CCS’18. ACM, 1470–1486.
[20] Jianxing Hu, Dongdong Huo, Meilin Wang, Yazhe Wang, Yan Zhang, and Yu Li.
2019. A Probability Prediction Based Mutable Control-Flow Attestation Scheme
on Embedded Platforms. In TrustCom/BigDataSE’19. 530–537.
[21] Dongdong Huo, Yu Wang, Chao Liu, Mingxuan Li, Yazhe Wang, and Zhen Xu.
2020. LAPE: A Lightweight Attestation of Program Execution Scheme for Bare-
Metal Systems. In 22nd IEEE International Conference on High Performance Com-
puting and Communications; 18th IEEE International Conference on Smart City; 6th
321ACSAC ’21, December 6–10, 2021, Virtual Event, USA
Yumei Zhang, Xinzhi Liu, Cong Sun, Dongrui Zeng, Gang Tan, Xiao Kan, and Siqi Ma
IEEE International Conference on Data Science and Systems, HPCC/SmartCity/DSS
2020. IEEE, 78–86.
[22] Intel Corporation. 2016. Intel(R) 64 and IA-32 Architectures Software Developer’s
Manual. (2016). https://software.intel.com/en-us/articles/intel-sdm
[23] Sun Hyoung Kim, Cong Sun, Dongrui Zeng, and Gang Tan. 2021. Refining
Indirect Call Targets at the Binary Level. In NDSS’21. The Internet Society.
[24] Patrick Koeberl, Steffen Schulz, Ahmad-Reza Sadeghi, and Vijay Varadharajan.
2014. TrustLite: a security architecture for tiny embedded devices. In EuroSys’14.
10:1–10:14.
[25] Jingbin Liu, Qin Yu, Wei Liu, Shijun Zhao, Dengguo Feng, and Weifeng Luo.
2019. Log-Based Control Flow Attestation for Embedded Devices. In Cyberspace
Safety and Security - 11th International Symposium, CSS’19, Part I (Lecture Notes
in Computer Science, Vol. 11982). Springer, 117–132.
[26] Pavel Mach and Zdenek Becvar. 2017. Mobile Edge Computing: A Survey on
Architecture and Computation Offloading. IEEE Communications Surveys and
Tutorials 19, 3 (2017), 1628–1656.
[27] Vishwath Mohan, Per Larsen, Stefan Brunthaler, Kevin W. Hamlen, and Michael
Franz. 2015. Opaque Control-Flow Integrity. In NDSS’15. The Internet Society.
[28] Paul Muntean, Matthias Fischer, Gang Tan, Zhiqiang Lin, Jens Grossklags, and
Claudia Eckert. 2018. τ CFI: Type-Assisted Control Flow Integrity for x86-64
Binaries. In RAID’18 (Lecture Notes in Computer Science, Vol. 11050). Springer,
423–444.
[29] Job Noorman, Pieter Agten, Wilfried Daniels, Raoul Strackx, Anthony Van Her-
rewege, Christophe Huygens, Bart Preneel, Ingrid Verbauwhede, and Frank
Piessens. 2013. Sancus: Low-cost Trustworthy Extensible Networked Devices
with a Zero-software Trusted Computing Base. In USENIX Security Symposium.
479–494.
[30] Ivan De Oliveira Nunes, Karim Eldefrawy, Norrathep Rattanavipanon, and Gene
Tsudik. 2020. APEX: A Verified Architecture for Proofs of Execution on Re-
mote Devices under Full Software Compromise. In USENIX Security Symposium.
USENIX Association, 771–788.
[31] Ivan De Oliveira Nunes, Sashidhar Jakkamsetti, and Gene Tsudik. 2020. Tiny-CFA:
A Minimalistic Approach for Control-Flow Attestation Using Verified Proofs of
Execution. CoRR abs/2011.07400 (2020).
[32] Ivan De Oliveira Nunes, Sashidhar Jakkamsetti, and Gene Tsudik. 2021. DIALED:
Data Integrity Attestation for Low-end Embedded Devices. CoRR abs/2103.12928
(2021).
[33] Mathias Payer, Antonio Barresi, and Thomas R. Gross. 2015. Fine-Grained Control-
Flow Integrity Through Binary Hardening. In DIMVA’15. 144–164.
[34] Hovav Shacham. 2007. The geometry of innocent flesh on the bone: return-into-
libc without function calls (on the x86). In CCS’07. 552–561.
[35] Zhichuang Sun, Bo Feng, Long Lu, and Somesh Jha. 2020. OAT: Attesting Opera-
tion Integrity of Embedded Devices. In SP’20. IEEE, 1433–1449.
[36] Flavio Toffalini, Eleonora Losiouk, Andrea Biondo, Jianying Zhou, and Mauro
Conti. 2019. ScaRR: Scalable Runtime Remote Attestation for Complex Systems.
In RAID’19. 121–134.
[37] Victor van der Veen, Enes Göktas, Moritz Contag, Andre Pawlowski, Xi Chen,
Sanjay Rawat, Herbert Bos, Thorsten Holz, Elias Athanasopoulos, and Cristiano
Giuffrida. 2016. A Tough Call: Mitigating Advanced Code-Reuse Attacks at the
Binary Level. In SP’16. 934–953.
[38] Minghua Wang, Heng Yin, Abhishek Vasisht Bhaskar, Purui Su, and Dengguo
Feng. 2015. Binary Code Continent: Finer-Grained Control Flow Integrity for
Stripped Binaries. In ACSAC’15. 331–340.
[39] Shaza Zeitouni, Ghada Dessouky, Orlando Arias, Dean Sullivan, Ahmad Ibrahim,
Yier Jin, and Ahmad-Reza Sadeghi. 2017. ATRIUM: Runtime attestation resilient
under memory attacks. In ICCAD’17. 384–391.
[40] Dongrui Zeng and Gang Tan. 2018. From Debugging-Information Based Binary-
Level Type Inference to CFG Generation. In CODASPY’18. 366–376.
[41] Chao Zhang, Tao Wei, Zhaofeng Chen, Lei Duan, Laszlo Szekeres, Stephen Mc-
Camant, Dawn Song, and Wei Zou. 2013. Practical Control Flow Integrity and
Randomization for Binary Executables. In SP’13. 559–573.
[42] Mingwei Zhang and R. Sekar. 2013. Control Flow Integrity for COTS Binaries. In
USENIX Security Symposium. 337–352.
322