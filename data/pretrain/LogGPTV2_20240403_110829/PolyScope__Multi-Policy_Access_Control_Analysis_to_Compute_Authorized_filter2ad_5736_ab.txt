may perform to launch attacks (Step 4) as test cases for vulnerability testing.
proaches suffer from key limitations on each problem.
The ﬁrst problem in using access control policy analysis
is to identify the adversaries who may beneﬁt from ex-
ploitation of each subject. Previous research often identiﬁes
untrusted apps2 as adversaries and assumes that all system
services and OEM value-added apps and services are trusted.
However, as OEMs push more functionality into their own
Android distributions, they deploy a variety of new and mod-
iﬁed apps and services whose trustworthiness may vary. A
recent study [16] reveals that some OEM pre-installed code
lacks in end-to-end quality control and might even leverage
code from third parties, resulting in backdoors and other vul-
nerabilities [37]. By ignoring OEM apps and services, we risk
missing attacks that utilize them as stepping stones to exploit
Android system services. However, we must be careful not to
overapproximate adversaries, which leads to false positives.
The second problem is to determine the permissions ad-
versaries control to create integrity violations. Recent ac-
cess control analysis methods that reason about multiple ac-
cess control policies [10, 22] do not account for how an adver-
sary may exploit ﬂexibility in those policy models to expose
new integrity violations. For example, the recent BigMAC
system computes the data ﬂows authorized by a combination
of Android policies, but we ﬁnd that Android authorizes hun-
dreds of thousands of data ﬂows when only a small fraction
(0.1 to 1.5%) cause integrity violations 3. Another problem is
that OEMs often uilitize DAC policies to protect their value-
added apps and services, but adversaries may modify DAC
policies to create new integrity violations by obtaining An-
droid permissions from unsuspecting users and by granting
permissions to objects they "own" to potential victims to
lure them into attacks. Researchers have previously identiﬁed
problems caused by DAC policy ﬂexibility [21, 29] that limit
its ability to prevent unauthorized access. While in theory
MAC policies could be conﬁgured to block changes from
creating integrity violations, MAC policies are more complex
2Includes apps assigned to the SEAndroid domains untrusted_app and
isolated_app. Information on SEAndroid domains appears in Section 5.1.
3Compare the "Authorized Data Flows" row in Table 2 to the "PolyScope
IVs with Operations" row.
to conﬁgure and are unforgiving if a needed permission is
not granted. As a result, we believe that OEMs are overly
dependent on DAC policies.
The third problem is to compute the operations that an
adversary may be authorized to employ to launch attacks,
which we call attack operations. Once we know that an adver-
sary has been authorized permissions that create an integrity
violation, a question is how an adversary may exploit those
permissions to launch attacks. While integrity violations are a
necessary precondition for attacks, adversaries must be able to
perform the operations necessary to launch attacks. Android
systems provide ﬁlesystem and program conﬁgurations that
could prevent attack operations. First, Android uses ﬁlesystem
conﬁgurations that prevent symbolic links from being created
in external storage directories, which can block link traversal
attacks like the example above. In addition, Android systems
have also introduced a specialized FileProvider class that re-
quires clients to open ﬁles for their servers, which can also
prevent link traversal attacks. However, such ad hoc conﬁgura-
tions are only employed sporadically (see also Section 8.2), so
it is important to determine which attack operations are really
possible to guide defenders without creating false positives.
3 PolyScope Overview
In this paper, we present a new Android access control analy-
sis tool, called PolyScope, that computes the set of authorized
attack operations for an Android system while overcoming
the limitations described above. Prior research that performs
multi-policy analysis only computes information ﬂows for
a current snapshot of the policies [10, 22], which neither ac-
counts for policy manipulations nor identiﬁes the speciﬁc at-
tack operations that could enable exploitation. Figure 2 shows
PolyScope’s approach. In Step 1, PolyScope identiﬁes the
adversaries for each subject using deﬁnitions of mutual trust
validated against an approach that computes worst-case, as
described in Section 5.2. In Step 2, PolyScope determines the
permissions adversaries control by modeling how adversaries
may expand permissions available to themselves and their
victims by exploiting the ﬂexibility in Android access control
policies, as described in Section 5.3. In Step 3, PolyScope uses
2582    30th USENIX Security Symposium
USENIX Association
We aim to triage systems for three classes of integrity viola-
tions on ﬁlesystem access, covering a wide variety of vulnera-
bilities including confused deputy [20] and time-of-check-to-
time-of-use (TOCTTOU) vulnerabilities [31, 5]. Related to
Figure 1, we show these integrity violation classes in Figure 3.
First, ﬁle-IVs allow adversaries to modify target ﬁles that are
authorized to victims directly 1 , possibly leading victims
to unexpected use of adversary-controlled data. We further
distinguish ﬁle-IVs by whether the victim can read (read-
IVs), write (write-IVs), and/or execute (exec-IVs) the IV ﬁle.
Second, binding-IVs enable adversaries to redirect victims
to target ﬁles during name resolution 2 , causing victims to
operate on ﬁles chosen by adversaries. Third, pathname-IVs
enable adversaries to lure victims to an adversary-controlled
part of the ﬁlesystem using an adversary-supplied pathname
3 , which is the integrity violation exploited in the example
vulnerability of Section 2.1.
For each integrity violation found, we assume that an ad-
versary may attempt any possible attack operation. In general,
attack operations enable adversaries to provide malicious in-
put to victims by getting them to use an adversary-controlled
ﬁle or binding to enable the adversary to choose the input to
the victim, whose basic approaches date to the 1970s [31].
File-IV attack operations simply modify the resource await-
ing use (read, write, or execute) by the victim. Binding-IV
attack operations direct the victim to a resource chosen by
the adversary, using link traversal or ﬁle squatting attacks. A
link traversal attack directs a victim to access a resource to
which the adversary is not authorized. A ﬁle squatting attack
plants an adversary-controlled resource at a location where
the victim expects a protected ﬁle. Pathname-IVs attack oper-
ations lure a victim who processes pathnames (e.g., URLs) to
an adversary-controlled binding to exploit a link traversal.
In developing PolyScope, we assume trust in some compo-
nents of Android systems. First, we assume that the Android
operating system operates correctly, including enforcement
of its access control policies and system conﬁgurations cor-
rectly. For example, we trust the Android operating system
to satisfy the reference monitor concept [2]. We note that
the Android operating system includes the Linux operating
system and a variety of system services. Our assumptions
about trust among such services is determined using Android
speciﬁcations, as described in Section 5.2.
5 PolyScope Design
In this section, we examine the design challenges in com-
puting attack operations for Android systems. In particular,
after providing some brief background information, we fo-
cus on four key steps outlined in the PolyScope overview in
Section 3.
5.1 Design Background
In this section, we describe the various access control tech-
niques used by Android systems that are necessary to un-
Figure 3: Integrity Violation (IV) Classes: (1) File-IVs grant
adversaries direct access to modify ﬁles that victims use; (2)
Binding-IVs grant adversaries the ability to modify name reso-
lution of ﬁle names; and (3) Pathname-IVs enable adversaries
to lure victims to the part of the ﬁlesystem they can modify.
these expanded permissions to compute integrity violations
based on integrity violation rules deﬁned in Section 5.4. In
Step 4, PolyScope uses these integrity violations to compute
the types of attack operations possible using attack operation
rules deﬁned in Section 5.5. We identify the speciﬁc types of
integrity violations and attack operations we consider in this
paper in Section 4.
PolyScope computes integrity violations and attack opera-
tions to triage Android releases for vulnerabilities authorized
by access control policies. Integrity violations computed in
Step 3 identify the ﬁlesystem resources that victims are autho-
rized to access that their adversaries are authorized to modify
(see Section 2.2). Attack operations computed in Step 4 de-
termine the types of operations that adversaries are capable
of performing in modifying ﬁlesystem resources to launch at-
tacks for each IV. As indicated in Figure 2, all the PolyScope
steps perform static access policy analysis. Using the com-
puted attack operations, an analyst can perform vulnerability
testing on victim applications either manually or preferably
using dynamic analysis. The aim is to develop dynamic testing
techniques that drive victims to scenarios where they access
a resource associated with an integrity violation, where test-
ing will apply an attack operation to determine whether the
victim prevents the attack or not. In Section 6, we describe
dynamic analysis analysis methods to detect victim use of IVs
from which we ﬁnd two new vulnerabilities from subsequent
manual testing in Section 7.6.
4 Threat Model
In this paper, adversaries may modify any part of the ﬁlesys-
tem and send requests (e.g., IPCs) to any subject to which
they are authorized by the combination of Android access
control policies. Adversaries may make arbitrary changes to
authorized ﬁlesystem resources. Also, adversaries may send
arbitrary data in requests. We assume that adversaries will
exploit such abilities to modify any resource that they are au-
thorized to modify that a victim may use. That is, adversaries
we assume that adversaries will exploit all integrity violations
(IVs) authorized by the Android policies.
USENIX Association
30th USENIX Security Symposium    2583
AdversaryTarget File1File-IVBinding(Hard or Soft Link)2Binding-IVVictim3Pathname-IVReadResolvederstand the PolyScope design. Android uses SEAndroid
mandatory access control (MAC), Unix discretionary access
control (DAC), the Android permission system, and Linux
capabilities to control access to ﬁlesystem resources directly
or indirectly. Linux capabilities have no tangible impact on
contributing attack operations on recent Android versions, so
we do not discuss them further. Using the remaining models,
we deﬁne PolyScope’s interpretation of subjects and objects
applied in policy analysis.
SEAndroid MAC: SEAndroid is a port of the SELinux
mandatory access control system [39] with additional support
for Android mechanisms, such as Binder IPC. SEAndroid sup-
ports three access control models: Type Enforcement (TE),
Role-Based Access Control (RBAC), and Multi-Level Secu-
rity (MLS). All the models are mandatory access control
models (MAC) in that they are deﬁned by the system and are
not intended to be modiﬁed by users or their programs. Out
of these three, the TE model acts as the primary enforcement
model to protect the integrity of the Android system’s trusted
computing base processes. MLS is used mainly to separate
apps from one another. On the other hand, RBAC does not
receive much use currently on Android, so we do not describe
it further.
The SEAndroid TE policy4 deﬁnes authorization rules in
terms of security labels [6], where a subject can perform an op-
eration on an object if there is a rule authorizing the subject’s
security label to perform the operation on object’s security la-
bel. The SEAndroid MLS policy enables subjects and objects
to be associated with categories [3], where subjects can only
perform operations on objects when the subject is authorized
for the object’s category.
Unix DAC: Android systems also use traditional Unix dis-
cretionary access control (DAC) as provided by the Linux
system on which Android is based. Unix DAC associates ﬁles
with a UID for the ﬁle owner and a GID for the ﬁle group.
Processes are also associated with a process UID and GID,
but a process may additionally belong to a set of supplemen-
tary groups. A process can perform an operation on a ﬁle
if: (1) the ﬁle’s UID is the same as the process’s UID and
the ﬁle owner is authorized to perform that operation; (2) the
ﬁle’s GID matches one of the process’s groups (i.e., process’s
GID or supplementary) and the ﬁle group is authorized to
perform that operation; or (3) any process UID (i.e., others) is
authorized to perform that operation for that ﬁle. Importantly,
Unix DAC allows a process to modify ﬁle permissions when
the process’s UID is the same as the ﬁle’s owner UID.
Rather than associating UID’s with individual users, as is
traditional, Android associates UIDs with individual services
and apps. Thus, services and apps "own" a set of ﬁles (i.e.,
with the app’s UID as the ﬁle owner UID) for which they may
modify permissions. Thus, malicious apps can change the
4Note that in this paper we sometimes refer to the "MAC TE" policy,
which is the same as the SEAndroid TE policy.
permissions for ﬁles they own, which is important for luring
victims to create pathname-IVs.
Android Permission System: Android permissions are used
to control access to app and service data. Android data/service
providers enforce most Android permissions, but some An-
droid permissions are mapped to DAC supplementary groups,
which are assigned to apps when the associated Android per-
mission is granted. Thus, Android permissions may add DAC
supplementary groups to app processes, granting them addi-
tional ﬁlesystem permissions.
Note that each Android permission has an associated pro-
tection level that is used to determine whether or not an ap-
plication may be granted that permission. Over time, the per-
mission granting policy has become more complex [57]. Cur-
rently, permissions with the "normal" protection level are
automatically granted to applications. However, permissions
with the "dangerous" protection level (e.g., guarding sensi-
tive personal data such as GPS) require additional runtime
authorization from the user. Permissions with the "signature"
protection level can only be granted to applications signed by
the same developer key that was used to deﬁne the permission.
The signature protection level is primarily used to restrict ac-
cess to functionality that only system applications should
access. Finally, there are several other ﬂags that provide ad
hoc restrictions, e.g., a "privileged" ﬂag allows privileged,
OEM-bundled applications to acquire associated permissions.
Mapping MAC and DAC Policies: To reason about access
control for the combined DAC and MAC policies, PolyScope
needs to determine how to map MAC policies in the form
of TE security labels and MLS categories to DAC policies
in the form of UIDs and groups. Fortunately, Android makes
such determination straightforward 5. Files and directories are
explicitly assigned both MAC and DAC information directly,
so there is no possibility of ambiguity. For processes, the
mapping between MAC and DAC information is indirect.
Android assigns the same MAC TE security label, MAC MLS
category, DAC UID, and DAC groups6 to each program when
it is run, as identiﬁed by Chen et al. [10]. Thus, we collect the
MAC-DAC mapping for processes by running programs. For
all apps and services we have run, this relationship has held,
but this implies that we can only perform policy analysis for
apps and services installed on the release (i.e., that we can
run). We use this information to deﬁne subjects and objects
for PolyScope analysis as follows.
• Subjects: Each process is associated with a subject de-
ﬁned by its MAC TE label, MLS category set, DAC
UID, and a set of DAC groups (GID and supplemental
5Extracting such policy information is straightforward when we have the
ﬁlesystem information. We root Android devices to obtain such information,
but researchers have developed techniques to extract such information from
ﬁrmware images [22], as we discuss in Section 6.
6The complete set of supplementary groups assigned to a program’s
processes depend on the Android permissions obtained for the program. We
deﬁne the assumption we use for PolyScope in Section 5.3.
2584    30th USENIX Security Symposium
USENIX Association
groups). There may be many processes associated with
one subject.
• Objects: Each resource is associated with an object de-
ﬁned by its MAC TE label, MLS category set, DAC
UID/GID, and mode bits (i.e., owner, group, others per-
missions). There may be many ﬁles/directories associ-
ated with one object.
PolyScope reasons about access control policies in terms of
subjects and objects, rather than individual processes and re-
sources, as the deﬁnitions of subjects and objects form equiv-
alence classes with respect to adversaries. All processes of
the same subject share the same adversaries, and all resource
associated with the same object are modiﬁable by the same
adversaries. Thus, we express PolyScope results in terms of
subjects and objects in Section 7.
5.2 Compute Per-Subject Adversaries
One challenge is to identify the adversaries for each sub-
ject. Researchers often identify subjects adversaries based
untrusted sources (e.g., Chen et al. [10] used third-party apps
as adversaries) or based on their role in the system (e.g., Jaeger
et al. [25] said only core system services could be trusted).
However, these approaches are one-dimensional and ad hoc.