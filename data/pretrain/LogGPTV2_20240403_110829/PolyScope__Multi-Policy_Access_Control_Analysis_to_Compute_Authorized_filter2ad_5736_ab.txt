### Challenges in Access Control Policy Analysis for Vulnerability Testing

#### Introduction
To launch attacks as test cases for vulnerability testing, it is crucial to address the key limitations in access control policy analysis. This section outlines three primary problems and their implications.

#### Problem 1: Identifying Adversaries
The first challenge is identifying the adversaries who may benefit from exploiting each subject. Previous research often labels untrusted apps as adversaries, assuming that all system services and OEM (Original Equipment Manufacturer) value-added apps and services are trusted. However, as OEMs introduce more functionality into their Android distributions, they deploy a variety of new and modified apps and services, whose trustworthiness can vary. A recent study [16] revealed that some OEM pre-installed code lacks end-to-end quality control and may even include third-party code, leading to backdoors and other vulnerabilities [37]. Ignoring OEM apps and services can result in missing attacks that use them as stepping stones to exploit Android system services. Overapproximating adversaries, however, can lead to false positives.

#### Problem 2: Determining Permissions
The second challenge is determining the permissions adversaries control to create integrity violations. Recent access control analysis methods that reason about multiple policies [10, 22] do not account for how an adversary might exploit the flexibility in these policy models to expose new integrity violations. For example, the BigMAC system computes data flows authorized by a combination of Android policies but authorizes hundreds of thousands of data flows, with only a small fraction (0.1 to 1.5%) causing integrity violations [3]. Another issue is that OEMs often use DAC (Discretionary Access Control) policies to protect their value-added apps and services. Adversaries can modify DAC policies to create new integrity violations by obtaining Android permissions from unsuspecting users and granting permissions to objects they "own" to potential victims, luring them into attacks. Researchers have identified problems caused by DAC policy flexibility [21, 29], which limit its ability to prevent unauthorized access. While MAC (Mandatory Access Control) policies could theoretically block such changes, they are more complex to configure and unforgiving if a needed permission is not granted, leading to an overreliance on DAC policies.

#### Problem 3: Computing Attack Operations
The third challenge is computing the operations that an adversary may be authorized to employ to launch attacks, referred to as attack operations. Once it is known that an adversary has been authorized permissions that create an integrity violation, the next step is to determine how the adversary can exploit those permissions to launch attacks. While integrity violations are a necessary precondition for attacks, adversaries must be able to perform the required operations. Android systems provide filesystem and program configurations that can prevent certain attack operations. For instance, Android prevents symbolic links from being created in external storage directories, blocking link traversal attacks. Additionally, the FileProvider class requires clients to open files for their servers, further preventing link traversal attacks. However, these ad hoc configurations are not consistently applied, making it essential to determine which attack operations are truly possible to guide defenders without creating false positives.

### PolyScope Overview
In this paper, we present PolyScope, a new Android access control analysis tool that computes the set of authorized attack operations while overcoming the limitations described above. Prior research [10, 22] only computes information flows for a current snapshot of policies, failing to account for policy manipulations or identify specific attack operations. PolyScope's approach, illustrated in Figure 2, involves four key steps:

1. **Identify Adversaries**: PolyScope identifies adversaries for each subject using definitions of mutual trust, validated against a worst-case approach (Section 5.2).
2. **Determine Permissions**: PolyScope determines the permissions adversaries control by modeling how they can expand available permissions through policy flexibility (Section 5.3).
3. **Compute Integrity Violations**: Using expanded permissions, PolyScope computes integrity violations based on rules defined in Section 5.4.
4. **Compute Attack Operations**: Finally, PolyScope uses these integrity violations to compute possible attack operations based on rules defined in Section 5.5.

### Threat Model
Adversaries in this model can modify any part of the filesystem and send requests (e.g., IPCs) to any subject authorized by the combination of Android access control policies. They can make arbitrary changes to authorized filesystem resources and send arbitrary data in requests. We assume that adversaries will exploit all integrity violations (IVs) authorized by the Android policies.

### Design Background
Android uses SEAndroid MAC, Unix DAC, the Android permission system, and Linux capabilities to control access to filesystem resources. Linux capabilities have minimal impact on recent Android versions, so we focus on the remaining models. SEAndroid supports Type Enforcement (TE), Role-Based Access Control (RBAC), and Multi-Level Security (MLS). The TE model is the primary enforcement model, while MLS separates apps. RBAC is not widely used on Android and is not discussed further.

Unix DAC associates files with UIDs and GIDs, and processes with UIDs and GIDs. Processes can perform operations on files if the file’s UID matches the process’s UID, the file’s GID matches one of the process’s groups, or any process UID is authorized. Android associates UIDs with individual services and apps, allowing them to modify permissions for files they own, which is crucial for creating pathname-IVs.

The Android permission system controls access to app and service data, with permissions enforced by providers and mapped to DAC supplementary groups. Permissions have different protection levels, ranging from "normal" (automatically granted) to "dangerous" (requiring runtime authorization) and "signature" (granted to applications signed by the same developer key).

### Mapping MAC and DAC Policies
PolyScope needs to map MAC policies (TE security labels and MLS categories) to DAC policies (UIDs and groups). Android assigns both MAC and DAC information directly to files and directories, and the mapping for processes is indirect but consistent. Each process is associated with a subject defined by its MAC TE label, MLS category set, DAC UID, and DAC groups. Resources are associated with objects defined by their MAC TE label, MLS category set, DAC UID/GID, and mode bits.

### Conclusion
PolyScope addresses the challenges in access control policy analysis by providing a comprehensive method to identify adversaries, determine permissions, compute integrity violations, and compute attack operations. This tool helps in triaging Android releases for vulnerabilities and guiding dynamic testing to detect and mitigate attacks.