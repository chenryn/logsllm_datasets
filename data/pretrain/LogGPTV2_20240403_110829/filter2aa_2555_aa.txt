function hooking 
for osx and linux
joe damato
@joedamato
timetobleed.com
slides are on
timetobleed.com
(free jmpesp)
i’m not a security 
researcher.
call me a script kiddie: 
@joedamato
laughinglarry.com
slayerinc.com
dbgrady.ﬁles.wordpress.com
assembly is in att syntax
WTF is an ABI ?
WTF is an Application 
Binary 
Interface ?
alignment
thomasgroup.com
calling convention
arianlim.wordpress.com
object ﬁle and 
library formats
tandemfs.org
hierarchy of specs
topatoco.com
System V ABI (271 pages)
System V ABI AMD64 Architecture Processor 
Supplement (128 pages)
System V ABI Intel386 Architecture Processor 
Supplement (377 pages)
MIPS, ARM, PPC, and IA-64 too!
mac osx x86-64 calling convention 
based on
System V ABI AMD64 Architecture 
! ! ! Processor Supplement
gregs-wines.com
alignment
thomasgroup.com
end of argument area must be 
aligned on a 16byte boundary.
and $0xfffffffffffffff0, %rsp
calling convention
arianlim.wordpress.com
• function arguments from left to right live in:
%rdi,  %rsi,  %rdx,  %rcx,  %r8,  %r9
• that’s for INTEGER class items.
• Other stuff gets passed on the stack (like 
on i386).
• registers are either caller or callee saved
object ﬁle and 
library formats
tandemfs.org
steverubel.typepad.com
ELF Objects
en.wikipedia.org
ELF Objects
• ELF objects have headers
• elf header (describes the elf object)
• program headers (describes segments)
• section headers (describes sections)
• libelf is useful for wandering the elf object extracting 
information.
• the executable and each .so has its own set of data
ELF Object sections
• .text - code lives here 
• .plt - stub code that helps to “resolve” 
absolute function addresses. 
• .got.plt - absolute function addresses; used 
by .plt entries.
• .debug_info - debugging information
• .gnu_debuglink - checksum and ﬁlename for 
debug info
ELF Object sections
• .dynsym - maps exported symbol names to 
offsets
• .dynstr - stores exported symbol name 
strings
• .symtab - maps symbol names to offsets
• .strtab - symbol name strings
• more sections for other stuff.
vanachteren.net
Mach-O Objects
developer.apple.com
Mach-O Objects
• Mach-O objects have load commands
• header (describes the mach-o object)
• load commands (describe layout and linkage info)
• segment commands (describes sections)
• dyld(3) describes some apis for touching mach-o 
objects
• the executable and each dylib/bundle has its own set 
of data
Mach-O sections
• __text - code lives here
• __symbol_stub1 - list of jmpq instructions 
for runtime dynamic linking
• __stub_helper -  stub code that helps to 
“resolve” absolute function addresses. 
• __la_symbol_ptr -  absolute function 
addresses; used by symbol stub
Mach-O sections
• symtabs do not live in a segment, they have 
their own load commands.
• LC_SYMTAB - holds offsets for symbol 
table and string table.
• LC_DYSYMTAB - a list of 32bit offsets into 
LC_SYMTAB for dynamic symbols.
blog.makezine.com
nm
000000000048ac90 t Balloc
0000000000491270 T Init_Array
0000000000497520 T Init_Bignum
000000000041dc80 T Init_Binding
000000000049d9b0 T Init_Comparable
000000000049de30 T Init_Dir
00000000004a1080 T Init_Enumerable
00000000004a3720 T Init_Enumerator
00000000004a4f30 T Init_Exception
000000000042c2d0 T Init_File
0000000000434b90 T Init_GC
% nm /usr/bin/ruby
symbol  
“value”
symbol names
objdump
% objdump -D /usr/bin/ruby
offsets
opcodes
instructions
helpful metadata
readelf
% readelf -a /usr/bin/ruby
This is a *tiny* subset of the data available
otool
% otool -l /usr/bin/ruby
This is a *tiny* subset of the data available
nerve.com
strip
• You can strip out whatever sections you 
want....
• but your binary may not run.
• you need to leave the dynamic symbol/
string tables intact or dynamic linking will 
not work.
bassﬁshin.com
Calling functions
callq *%rbx
callq 0xdeadbeef
other ways, too...
anatomy of a call
412d16:   e8 c1 36 02 00          callq  4363dc # 
412d1b:  .....
address of this instruction
call opcode
32bit displacement to the 
target function from the next 
instruction.
(objdump output)
anatomy of a call
412d16:   e8 c1 36 02 00          callq  4363dc # 
412d1b:  .....
412d1b
= 4363dc
  +   000236c1
(x86 is little endian)
(objdump output)
Hook a_function
Overwrite the displacement so that all calls 
to a_function actually call a different function 
instead.
It may look like this:
int other_function() 
{
        /* do something good/bad */
        /* be sure to call a_function! */
        return a_function();
}
codez are easy
/* CHILL, it’s fucking psuedo code */
while (are_moar_bytes()) {
  curr_ins = next_ins;
  next_ins = get_next_ins();
  if (curr_ins->type == INSN_CALL) {
    if ((hook_me - next_ins) == curr_ins->displacement) {
      /* found a call hook_me!*/
      rewrite(curr_ins->displacement, (replacement_fn - next_ins)); 
      return 0;
    }
  }
}
... right?.....
lemur.com
32bit displacement
• overwriting an existing call with another call
• stack will be aligned
• args are good to go
• can’t redirect to code that is outside of: 
• [rip + 32bit displacement]
• you can scan the address space looking for 
an available page with mmap, though...
Doesn’t work for all
calling a function that is exported by a 
dynamic library works differently.
How runtime dynamic 
linking works (elf)
0x7ffff7afd6e6
.got.plt entry
How runtime dynamic 
linking works (elf)
0x7ffff7afd6e6
.got.plt entry
Initially, the .got.plt entry contains 
the address of the instruction after 
the jmp.
How runtime dynamic 
linking works (elf)
0x7ffff7afd6e6
.got.plt entry
An ID is stored and the rtld is 
invoked.
How runtime dynamic 
linking works (elf)
0x7ffff7b34ac0
.got.plt entry
rtld writes the address of 
rb_newobj to the .got.plt entry.
How runtime dynamic 
linking works (elf)
0x7ffff7b34ac0
.got.plt entry
rtld writes the address of 
rb_newobj to the .got.plt entry.
calls to the PLT entry jump 
immediately to rb_newobj now 
that .got.plt is ﬁlled in.
rs.tacklewarehouse.com
Hook the GOT
Redirect execution by overwriting all 
the .got.plt entries for rb_newobj in each 
DSO with a handler function instead.
0xdeadbeef
.got.plt entry
VALUE other_function() 
{  
      new_obj = rb_newobj();
      /* do something with  new_obj */
      return new_obj;
}
Hook the GOT
NO, it isn’t. other_function() lives in it’s own DSO, so its 
calls to rb_newobj() use the .plt/.got.plt in its own DSO.
As long as we leave other_function()‘s DSO unmodified, we’ll 
avoid an infinite loop.
WAIT... other_function() calls rb_newobj() isn’t that an infinite loop?
vanachteren.net
tlaneve.ﬁles.wordpress.com
elf
mach-o
me
what else is left?
inline functions.
add_freelist
• Can’t hook because add_freelist is inlined:
static inline void
add_freelist(p)
    RVALUE *p;
{
    p->as.free.flags = 0;
    p->as.free.next = freelist;
    freelist = p;
}
• The compiler has the option of 
inserting the instructions of this 
function directly into the callers.
• If this happens, you won’t see any calls.
So... what now?
• Look carefully at the code:
static inline void
add_freelist(p)
    RVALUE *p;
{
    p->as.free.flags = 0;
    p->as.free.next = freelist;
    freelist = p;
}
• Notice that freelist gets updated.
• freelist has ﬁle level scope.
• hmmmm......
A (stupid) crazy idea
• freelist has ﬁle level scope and lives at some 
static address.
• add_freelist updates freelist, so...
• Why not search the binary for mov instructions 
that have freelist as the target!
• Overwrite that mov instruction with a call to 
our code!
• But... we have a problem. 
• The system isn’t ready for a call instruction.
alignment
thomasgroup.com