title:Xede: Practical Exploit Early Detection
author:Meining Nie and
Purui Su and
Qi Li and
Zhi Wang and
Lingyun Ying and
Jinlong Hu and
Dengguo Feng
Xede: Practical Exploit Early Detection
Meining Nie1, Purui Su1,2(B), Qi Li3, Zhi Wang4, Lingyun Ying1,
Jinlong Hu5, and Dengguo Feng1
1 Trusted Computing and Information Assurance Laboratory,
Institute of Software, CAS, Beijing, People’s Republic of China
PI:EMAIL
2 State Key Laboratory of Computer Science,
Institute of Software, CAS, Beijing, China
3 Tsinghua University, Beijing, China
4 Florida State University, Tallahassee, USA
5 South China University of Technology, Guangzhou, China
Abstract. Code reuse and code injection attacks have become the
popular techniques for advanced persistent threat (APT) to bypass
exploit-mitigation mechanisms deployed in modern operating systems.
Meanwhile, complex, benign programs such as Microsoft Oﬃce employ
many advanced techniques to improve the performance. Code execu-
tion patterns generated by these techniques are surprisingly similar to
exploits. This makes the practical exploit detection very challenging,
especially on the Windows platform. In this paper, we propose a practi-
cal exploit early detection system called Xede to comprehensively detect
code reuse and code injection attacks. Xede can eﬀectively reduce false
positives and false negatives in the exploit detection. We demonstrate
the eﬀectiveness of Xede by experimenting with exploit samples and
deploying Xede on the Internet. Xede can accurately detect all types of
exploits. In particular, it can capture many exploits that cannot be cap-
tured by mainstream anti-virus software and detect exploits that fail to
compromise the systems due to variations in the system conﬁgurations.
Keywords: Exploits · Code injection · Code reuse · ROP · Detection
1 Introduction
Advanced persistent threat (APT) is a stealthy, continuous, and targeted attack
against high-value targets, such as enterprises and government agencies. It is
often motivated by major ﬁnancial or political reasons. There are a stream of
recent infamous attacks that cause vast consumer data breach and other dis-
astrous consequences [4–6]. APT has since become a major security concern to
these organizations. APT often employs zero-day (or recently-disclosed) vulner-
abilities in popular programs, such as Microsoft Oﬃce, Internet Explorer, Adobe
Flash, and Adobe Acrobat [37,40], to penetrate the defenses of its target. Tra-
ditional signature-based (black-listing) malware and intrusion detection systems
c(cid:2) Springer International Publishing Switzerland 2015
H. Bos et al. (Eds.): RAID 2015, LNCS 9404, pp. 198–221, 2015.
DOI: 10.1007/978-3-319-26362-5 10
Xede: Practical Exploit Early Detection
199
have increasingly become ineﬀective against APT. Meanwhile, white-listing is
not only inconvenient for end users due to compatibility issues, but also inca-
pable of catching malicious inputs (unless there is a formal deﬁnition of all valid
and secure inputs). Instead, an eﬀective defense against APT should focus on
the early detection of exploits. Exploits often violate some code or control-ﬂow
integrity. For example, code injection attacks introduce new (malicious) code
into the system, while return-oriented programming (ROP [39], a typical code
reuse attack) manipulates the control ﬂow to execute its gadgets, short code
snippets that each ends with a return instruction. An exploit detection system
checking these integrities could detect a wide spectrum of exploits.
However, the practical exploit detection is still a challenging problem, espe-
cially for the Windows systems. Remote network exploits against common Win-
dows applications are the most prevailing attack surface [37]. Popular Windows
applications, such as Microsoft Oﬃce, often employ the following advanced tech-
niques that are surprisingly similar to exploits. If not carefully vetted, these pro-
grams could be mistakenly classiﬁed as malicious ﬁles, leading to high false pos-
itives. First, many large Windows functions generate dynamic code to improve
performance or extend the functionality. We analyze 7 common targets in Win-
dows and ﬁnd that all these applications generate a large quantity of dynamic
codes. An exploit detection system should separate the generated code from the
injected malicious code. Second, some applications may replace or adjust the
return addresses on the stack for obscure reasons. We also saw the example
code that pushes return addresses directly to the stack, instead of through the
call instructions. These irregular behaviors disrupt security mechanisms like the
shadow stack expect the call and return instructions to be matched. Exploit
detection systems need to accommodate these special but common program
tricks to reduce false positives. Third, benign windows applications may have
many short code sequences that resemble gadgets and are wrongfully detected
as such by existing schemes. For instance, we analyzed a large amount of sam-
ples collected from the Internet, and found that most of them contain many
small gadget sequences. In particular, we observed around 5,000 false positives
when simple ROP detection schemes are employed to analyze one PDF ﬁle. Fur-
thermore, commodity operating systems have incorporated exploit mitigation
techniques such as data-execution prevention (DEP [17]) and address space lay-
out randomization (ASLR [26]). These techniques signiﬁcantly raise the bar for
reliable exploits. Many exploits are tied to a speciﬁc run-time environment. If the
detector has a diﬀerent setting other than the target system, the exploits often
trigger exceptions. This can and should be leveraged for the exploit detection.
In this paper, we propose Xede, a practical exploit early detection system to
protect against APT. Xede can be deployed at the gateway to scan the incoming
traﬃc, such as emails, or deployed as a web service to scan ﬁles for exploit detec-
tion. Xede has three major detection engines: exploit exception detector, code
injection detector, and code reuse detector. The ﬁrst component detects failed
attack attempts by monitoring exceptions. Many exploits rely on the speciﬁc
system conﬁgurations. Xede uses a variant of software conﬁgurations (e.g., OS
200
M. Nie et al.
with diﬀerent patching levels) to induce the instability of exploits. Our exper-
iments reveal that around 70 % of the malware samples are unstable, causing
run-time exceptions. The second component detects (malicious) injected code
by comparing the executed instructions against a list of benign instructions.
This list is timely updated with the legitimate dynamically generated code to
reduce false positives. Code injection attacks are often combined with code reuse
attacks to bypass the DEP protection. Xede’s third component focuses on the
code reuse detection. It can detect both the more popular return-oriented pro-
gramming (ROP) attacks and jump-oriented programming (JOP) attacks. Sur-
prisingly, our experiments show that around 20 % of exploits contain a mix of
return-based and jmp-based gadgets. Xede’s code reuse detector can accommo-
date all the previously-mentioned eccentric program behaviors. With these three
components, Xede can detect many diﬀerent types of exploits, including zero-day
exploits. We have built a prototype of Xede for the Windows operating systems.
Our evaluation demonstrates that Xede is highly eﬀective in detecting exploits.
For example, we can detect all the malware samples we collected from the Inter-
net. We have also deployed Xede on the Internet as a public service [42] to scan
user-provided suspicious ﬁles.
2 Background
In order to exploit a vulnerability of a program, the following three steps need to
be performed. Firstly, attackers need to construct memory layout of the program
to host shellcode and data. Secondly, the attackers hijack the control ﬂow of the
program to injected shellcode directly or by constructing ROP gadgets. Lastly,
the shellcode is executed to exploit the vulnerability. Note that shellcode could
be injected into memory of target processes by either direct code injection, i.e.,
by code injection attacks, or constructing instruction chains through a serious
of ROP gadgets, i.e., ROP attacks. Nowadays it is not easy to directly construct
code injection attacks since the DEP defense mechanism employed in Windows
does not allow direct code injection on writable and executable memory space.
To address this issue, ROP gadgets are used to construct shellcode by leveraging
indirect branch instructions, i.e., ROP gadgets, in target processes. Besides ROP
gadgets that usually end with ret instructions, JOP gadgets ending with indirect
jmp instructions can be used to construct shellcode as well [8]. In this paper, for
simplicity, we collectively call them ROP gadgets.
To launch pure code injection attacks, the attackers can arrange memory
layout to host shellcode by using heap spray or stack overﬂow. As shown in
Fig. 1, the attackers can use the HeapAlloc function to allocate the shellcode at
the addresses of 0x06060606, 0x0A0A0A0A, and 0x0C0C0C0C, respectively. The
control ﬂow of the program can be hijacked to the shellcode by altering the
function pointer or return address, and the pointer or the address will point to
the location of the injected shellcode. For instance, the function pointer in Fig. 1
is changed to 0x0C0C0C0C that is the location of the injected shellcode. Once
the altered function pointer is invoked, the shellcode will be executed. Unlike
Xede: Practical Exploit Early Detection
201
code injection attacks, ROP attacks identify ROP gadgets and construct the
stack including the addresses of the ROP gadgets. As shown in Fig. 1, gadgets
are located at diﬀerent locations, e.g., at 0x5e861192 and 0x5e81372a. When
the ESP register points to the address of the ﬁrst gadget, i.e., 0x0x5e861192,
the control ﬂow of program will be redirected to the gadgets by leveraging a
ret instruction. The gadgets are executed one by one according to the addresses
stored on the stack. Eventually, the WriteProcessMemory function is called to
ﬁnish exploit execution.
Step 2. hijack
control flow
Code:
mov eax, FunArray
call [eax + 0x4]
Data:
01005B24 FunArray:
Function Address 1
0x0C0C0C0C
Function Address 3
Function Address 4
Function Address 5
01003EA7    ret
esp
Step 1. construct
memory layout
(
a
)
C
o
d
e
I
n
j
e
c
t
i
o
n
(
b
)
R
O
P
HeapAlloc
Stack
Growth
Direction
Heap
...
0x06060606:
nop
nop
...
shellcode
...
0x0A0A0A0A:
nop
nop
...
shellcode
...
0x0C0C0C0C:
nop
nop
...
shellcode
Stack
...
0x5E821192
0x011012AB
0x5E81372A
0x0012ff20
0x5E8013CE
0x5E8156A8
0x5E820DE0
0x5E811564
Step 3. execute
shellcode
Heap
...
nops:
0C0C0000    nop
0C0C0001    nop
...
0C0C0C0C    nop
...
0C7FFFCF    nop
---------------------------
shellcode:
0C7FFFD0    mov eax, fs:30h
...
0C7FFFF0    mov eax, 7C80220F
0C7FFFF5    jmp eax;
...
kernel32!WriteProcessMemory:
7c80220f     mov     edi,edi
...
ROP Gadget
5E821192    pop    ecx
5E821193    ret
5E81372A    pop    ebx
5E81372B    ret
5E8013CE    xchg   eax,ebx
5E8013CF    ret
5E8156A8    mov    [eax], eax
5E8156AA    ret
5E820DE0    add    eax, ecx
5E820DE2    ret
5E811564    mov    ebx, eax
5E811566    jmp    [eax]
kernel32!WriteProcessMemory:
7c80220f     mov     edi,edi
Fig. 1. Exploits examples with diﬀerent exploitation techniques.
Normally, code injection attacks are easier to construct. However, the data
execution prevention (DEP) mechanism raises the bar for code injection attacks.
Therefore, it is not easy to directly inject executable code into memory with
DEP-enabled systems. ROP attacks are immune to DEP but can be throttled
by the address space layout randomization (ASLR) mechanism. To evade these
prevention mechanisms, attackers adopt hybrid approaches to launch attacks,
i.e., they can construct ROP gadgets to bypass the prevention mechanisms and
leverage code injection attack to execute shellcode.
202
M. Nie et al.
Key Observation. Benign programs contain some attack patterns, e.g.,
dynamic code, mismatching of call and return instructions, and small gadget
sequence, which make exploit detection harder. However, exploits generated by
diﬀerent attack techniques share a common pattern that they redirect the con-
trol ﬂow to some abnormal places other than the original ones. Speciﬁcally, the
control ﬂow is redirected to the pre-constructed shellcode or the ﬁrst ROP gad-
get. Hence, we could detect diﬀerent exploits by detecting unexpected jumps
according to diﬀerent attack features.
3 System Design
In this section, we describe the design of Xede, a practical exploit early detection
system, in detail.
3.1 Overview
Xede is a comprehensive exploit detection platform. It can detect both code
injection and code reuse attacks. Code injection attacks introduce alien code into
the system. Xede accordingly builds a list of benign code and detects branches to
the injected code by comparing branch destinations to that list. Meanwhile, code
reuse attacks like return-oriented programming (ROP) have distinctive control
ﬂow patterns. For example, ROP reuses short snippets of the existing code called
gadgets. Each gadget ends with a return instruction which “returns” to the
next gadget. As such, ROP has a sequence of unbalanced returns. Xede can
thus detect code reuse attacks by looking for these control ﬂow patterns. In
addition, the ubiquitous deployment of exploit mitigation mechanisms, such as
DEP and ASLR, has signiﬁcantly raised the bar for working exploits. Many
exploits become unreliable as a result of that. This observation is leveraged by
Xede to heuristically detect exploits by monitoring “abnormal” exceptions.
Guest OS
Process
Process
Target Process
...
...
push ebp
mov ebp, esp
sub esp, 32
...
S
a
m
p
l
e
f
e
t
c
h
i
n
s
t
r
u
c
t
i
o
n
Virtualizer
instructions
instruction execution
Xede
Dynamic
Information
Extractor
Exploit Exception Detector
Exception 
Handler
Filter
Exceptions
Exploit
Related
Exception
M
o
n
i
t
o
r
A
P
I
API
inform-
ation
Module 
Loader
DGC
Generator
Code Injection Detector
Region List
instruction
address
Verify
Code Region
Code Reuse Detector
Detect
Gadgets
instruction
information
ret
jmp
call
Shadow 
Stack
Gadgets
Counter
ret/jmp/call
U
s
e
d
b
y
R
O
P