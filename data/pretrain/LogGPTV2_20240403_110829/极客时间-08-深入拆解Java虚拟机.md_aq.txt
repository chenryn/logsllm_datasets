## 2. Sea-of-nodesHotSpot 里的 C2 采用的是一种名为 Sea-of-Nodes 的 SSAIR。它的最大特点，便是去除了变量的概念，直接采用变量所指向的值，来进行运算。在上面这段 SSA 伪代码中，我们使用了多个变量名 x1、x2、y1 和 y2。这在Sea-of-Nodes 将不复存在。取而代之的则是对应的值，比如说 Phi(y1, y2) 变成 Phi(0,1)，后者本身也是一个值，被其他 IR 节点所依赖。正因如此，常量传播在Sea-of-Nodes 中变成了一个 no-op。Graal 的 IR 同样也是 Sea-of-Nodes 类型的，并且可以认为是 C2 IR的精简版本。由于 Graal 的 IR系统更加容易理解，而且工具支持相对来说也比较全、比较新，所以下面我将围绕着Graal 的 IR 系统来讲解。尽管 IR 系统不同，C2 和 Graal所实现的优化大同小异。对于那小部分不同的地方，它们也在不停地相互"借鉴"。所以你无须担心不通用的问题。]{.reference}为了方便你理解今天的内容，我将利用 IR 可视化工具[Ideal GraphVisualizer](http://ssw.jku.at/General/Staff/TW/igv.html)（IGV），来展示具体的IR 图。（这里 Ideal 是 C2 中 IR 的名字。）    public static int foo(int count) {  int sum = 0;  for (int i = 0; i  0) {        sum += a * b;    }    if (b > 0) {        sum += a * b;    }    return sum;}我们来看一个实际的案例。在上面这段代码中，如果 a 和 b 都大于0，那么我们需要做三次乘法。通过 GVN 之后，我们只会在 B0中做一次乘法，并且在接下来的代码中直接使用乘法的结果，也就是 4 号 \*节点所代表的值。![](Images/a57413eba3b3be8e96bd13de90f05fd8.png){savepage-src="https://static001.geekbang.org/resource/image/f9/e1/f965693c5b1912f28065349b171832e1.png"}我们可以将 GVN 理解为在 IR 图上的公共子表达式消除（Common SubexpressionElimination，CSE）。这两者的区别在于，GVN 直接比较值的相同与否，而 CSE则是借助词法分析器来判断两个表达式相同与否。因此，在不少情况下，CSE还需借助常量传播来达到消除的效果。
## 总结与实践今天我介绍了即时编译器的内部构造。即时编译器将所输入的 Java 字节码转换成 SSA IR，以便更好地进行优化。具体来说，C2 和 Graal 采用的是一种名为 Sea-of-Nodes 的 IR，其特点用 IR节点来代表程序中的值，并且将源程序中基于变量的计算转换为基于值的计算。此外，我还介绍了 C2 和 Graal 的 IR 的可视化工具 IGV，以及基于 IR 的优化GVN。今天的实践环节，你可以尝试使用 IGV来查看上一篇实践环节中的代码的具体编译过程。你可以通过[该页面](https://github.com/oracle/graal/releases/tag/idealgraphvisualizer-543)下载当前版本的IGV。解压后，可运行脚本位于 bin/idealgraphvisualizer 中。IGV启动完成后，你可以通过下述指令将 IR 图打印至 IGV 中。（需附带 Graal编译器的 Java 10 或以上版本。）    // java -XX:+UnlockExperimentalVMOptions -XX:+UseJVMCICompiler -XX:CompileCommand='dontinline,CompilationTest::hash' -Dgraal.Dump=:3 -Dgraal.MethodFilter='CompilationTest.hash' -Dgraal.OptDeoptimizationGrouping=false CompilationTestpublic class CompilationTest {  public static int hash(Object input) {    if (input instanceof Exception) {      return System.identityHashCode(input);    } else {      return input.hashCode();    }  }  public static void main(String[] args) throws InterruptedException {    for (int i = 0; i `{=html}      public void foo() {    Object o = new Object();  }  // 对应的字节码如下：  public void foo();    0  new java.lang.Object [3]    3  dup    4  invokespecial java.lang.Object() [8]    7  astore_1 [o]    8  return接下来，我们需要以这个引用为调用者，调用其构造器，也就是上面字节码中的invokespecial指令。要注意，该指令将消耗操作数栈上的元素，作为它的调用者以及参数（不过Object 的构造器不需要参数）。因此，我们需要利用 dup 指令复制一份 new指令的结果，并用来调用构造器。当调用返回之后，操作数栈上仍有原本由 new指令生成的引用，可用于接下来的操作（即偏移量为 7的字节码，下面会介绍到）。pop 指令则常用于舍弃调用指令的返回结果。例如在下面这段代码的 foo方法中，我将调用静态方法 bar，但是却不用其返回值。由于对应的 invokestatic 指令仍旧会将返回值压入 foo方法的操作数栈中，因此 Java 虚拟机需要额外执行 pop 指令，将返回值舍弃。      public static boolean bar() {    return false;  }   public void foo() {    bar();  }  // foo 方法对应的字节码如下：  public void foo();    0  invokestatic FooTest.bar() : boolean [24]    3  pop    4  return需要注意的是，上述两条指令只能处理非 long 或者非 double类型的值，这是因为 long 类型或者 double类型的值，需要占据两个栈单元。当遇到这些值时，我们需要同时复制栈顶两个单元的dup2 指令，以及弹出栈顶两个单元的 pop2 指令。除此之外，不算常见但也是直接作用于操作数栈的还有 swap指令，它将交换栈顶两个元素的值。在 Java 字节码中，有一部分指令可以直接将常量加载到操作数栈上。以 int类型为例，Java 虚拟机既可以通过 iconst 指令加载 -1 至 5 之间的 int值，也可以通过 bipush、sipush 加载一个字节、两个字节所能代表的 int 值。Java 虚拟机还可以通过 ldc 加载常量池中的常量值，例如 ldc #18将加载常量池中的第 18 项。这些常量包括 int 类型、long 类型、float 类型、double 类型、String类型以及 Class 类型的常量。![](Images/aaacea6b199b378c92d8b7d0c9686a0a.png){savepage-src="https://static001.geekbang.org/resource/image/0d/8f/0dfbecf954660bcdc76eac65beac1e8f.jpg"}**常数加载指令表**正常情况下，操作数栈的压入弹出都是一条条指令完成的。唯一的例外情况是在抛异常时，Java虚拟机会清除操作数栈上的所有内容，而后将异常实例压入操作数栈上。
## 局部变量区Java方法栈桢的另外一个重要组成部分则是局部变量区，字节码程序可以将计算的结果缓存在局部变量区之中。实际上，Java 虚拟机将局部变量区当成一个数组，依次存放 this指针（仅非静态方法），所传入的参数，以及字节码中的局部变量。和操作数栈一样，long 类型以及 double类型的值将占据两个单元，其余类型仅占据一个单元。    public void foo(long l, float f) {  {    int i = 0;  }  {    String s = "Hello, World";  }}以上面这段代码中的 foo方法为例，由于它是一个实例方法，因此局部变量数组的第 0 个单元存放着 this指针。第一个参数为 long 类型，于是数组的 1、2 两个单元存放着所传入的 long类型参数的值。第二个参数则是 float 类型，于是数组的第 3个单元存放着所传入的 float 类型参数的值。![](Images/4c67aca1adef5c049d4ffe2eb88c3429.png){savepage-src="https://static001.geekbang.org/resource/image/22/d9/228d0f5f2d6437e7aca87c6df2d01bd9.png"}在方法体里的两个代码块中，我分别定义了两个局部变量 i 和s。由于这两个局部变量的生命周期没有重合之处，因此，Java编译器可以将它们编排至同一单元中。也就是说，局部变量数组的第 4个单元将为 i 或者 s。存储在局部变量区的值，通常需要加载至操作数栈中，方能进行计算，得到计算结果后再存储至局部变量数组中。这些加载、存储指令是区分类型的。例如，int类型的加载指令为 iload，存储指令为 istore。![](Images/41ddd0a6ae06eda2ac636da1710f9e25.png){savepage-src="https://static001.geekbang.org/resource/image/83/f9/83ece83ecd260c2eda282747467e49f9.jpg"}\**局部变量区访问指令表**局部变量数组的加载、存储指令都需要指明所加载单元的下标。举例来说，aload0 指的是加载第 0 个单元所存储的引用，在前面示例中的 foo方法里指的便是加载 this 指针。在我印象中，Java 字节码中唯一能够直接作用于局部变量区的指令是 iinc MN（M 为非负整数，N 为整数）。该指令指的是将局部变量数组的第 M 个单元中的int 值增加 N，常用于 for 循环中自增量的更新。      public void foo() {    for (int i = 100; i>=0; i--) {}  }  // 对应的字节码如下：  public void foo();     0  bipush 100     2  istore_1 [i]     3  goto 9     6  iinc 1 -1 [i] // i--     9  iload_1 [i]    10  ifge 6    13  return
## 综合示例下面我们来看一个综合的例子：    public static int bar(int i) {  return ((i + 1) - 2) * 3 / 4;}// 对应的字节码如下：Code:  stack=2, locals=1, args_size=1     0: iload_0     1: iconst_1     2: iadd     3: iconst_2     4: isub     5: iconst_3     6: imul     7: iconst_4     8: idiv     9: ireturn这里我定义了一个 bar 方法。它将接收一个 int类型的参数，进行一系列计算之后再返回。对应的字节码中的 stack=2, locals=1 代表该方法需要的操作数栈空间为2，局部变量数组空间为 1。当调用 bar(5)时，每条指令执行前后局部变量数组空间以及操作数栈的分布如下：![](Images/a753e4fa10f1bca03fbf1398d39a3c79.png){savepage-src="https://static001.geekbang.org/resource/image/c5/32/c57cb9c2222f0f79459bf4c58e1a4c32.png"}
## Java 字节码简介前面我已经介绍了加载常量指令、操作数栈专用指令以及局部变量区访问指令。下面我们来看看其他的类别。Java 相关指令，包括各类具备高层语义的字节码，即new（后跟目标类，生成该类的未初始化的对象），instanceof（后跟目标类，判断栈顶元素是否为目标类/ 接口的实例。是则压入 1，否则压入0），checkcast（后跟目标类，判断栈顶元素是否为目标类 /接口的实例。如果不是便抛出异常），athrow（将栈顶异常抛出），以及monitorenter（为栈顶对象加锁）和 monitorexit（为栈顶对象解锁）。此外，该类型的指令还包括字段访问指令，即静态字段访问指令getstatic、putstatic，和实例字段访问指令getfield、putfield。这四条指令均附带用以定位目标字段的信息，但所消耗的操作数栈元素皆不同。![](Images/5a14695d3e4813eed14241fd158cbb76.png){savepage-src="https://static001.geekbang.org/resource/image/da/d9/da3ff3aa4aaa2531d23286fec65b08d9.png"}以 putfield 为例，在上图中，它会把值 v 存储至对象 obj 的目标字段之中。方法调用指令，包括invokestatic，invokespecial，invokevirtual，invokeinterface 以及invokedynamic。这几条字节码我们已经反反复复提及了，就不再具体介绍各自的含义了。除 invokedynamic外，其他的方法调用指令所消耗的操作数栈元素是根据调用类型以及目标方法描述符来确定的。在进行方法调用之前，程序需要依次压入调用者（invokestatic不需要），以及各个参数。      public int neg(int i) {    return -i;  }   public int foo(int i) {    return neg(neg(i));  }  // foo 方法对应的字节码如下：foo 方法对应的字节码如下：  public int foo(int i);    0  aload_0 [this]    1  aload_0 [this]    2  iload_1 [i]    3  invokevirtual FooTest.neg(int) : int [25]    6  invokevirtual FooTest.neg(int) : int [25]    9  ireturn以上面这段代码为例，当调用 foo(2)时，每条指令执行前后局部变量数组空间以及操作数栈的分布如下所示：![](Images/6228448d9ecb7bbced581d3bec6e20bc.png){savepage-src="https://static001.geekbang.org/resource/image/47/95/476fa1bcb6b36b5b651c2a4101073295.png"}数组相关指令，包括新建基本类型数组的 newarray，新建引用类型数组的anewarray，生成多维数组的 multianewarray，以及求数组长度的arraylength。另外，它还包括数组的加载指令以及存储指令。这些指令是区分类型的。例如，int数组的加载指令为 iaload，存储指令为 iastore。![](Images/69cdd72bc58c4a49c46756d40bc785d4.png){savepage-src="https://static001.geekbang.org/resource/image/5d/1f/5d935dcdd55e9f8461a6e5b0ac22001f.jpg"}**数组访问指令表**控制流指令，包括无条件跳转 goto，条件跳转指令，tableswitch 和lookupswtich（前者针对密集的 cases，后者针对稀疏的cases），返回指令，以及被废弃的 jsr，ret指令。其中返回指令是区分类型的。例如，返回 int 值的指令为 ireturn。![](Images/9e7bca7455da1120d1b867ffab3aa49a.png){savepage-src="https://static001.geekbang.org/resource/image/f5/f0/f5195b5425a9547af9ce8371aef5c4f0.jpg"}**返回指令表**除返回指令外，其他的控制流指令均附带一个或者多个字节码偏移量，代表需要跳转到的位置。例如下面的abs 方法中偏移量为 1 的条件跳转指令，当栈顶元素小于 0 时，跳转至偏移量为6 的字节码。      public int abs(int i) {    if (i >= 0) {      return i;    }    return -i;  }  // 对应的字节码如下所示：  public int abs(int i);    0  iload_1 [i]    1  iflt 6    4  iload_1 [i]    5  ireturn    6  iload_1 [i]    7  ineg    8  ireturn剩余的 Java 字节码几乎都和计算相关，这里就不再详细阐述了。
## 总结与实践今天我简单介绍了各种类型的 Java 字节码。Java方法的栈桢分为操作数栈和局部变量区。通常来说，程序需要将变量从局部变量区加载至操作数栈中，进行一番运算之后再存储回局部变量区中。Java字节码可以划分为很多种类型，如加载常量指令，操作数栈专用指令，局部变量区访问指令，Java相关指令，方法调用指令，数组相关指令，控制流指令，以及计算相关指令。今天的实践环节，你可以尝试自己分析一段较为复杂的字节码，在草稿上画出局部变量数组以及操作数栈分布图。当碰到不熟悉的指令时，你可以查阅[Java虚拟机规范第 6.5小节](https://docs.oracle.com/javase/specs/jvms/se10/html/jvms-6.html#jvms-6.5)，或者[此链接](https://cs.au.dk/~mis/dOvs/jvmspec/ref-Java.html)。![](Images/a500044f1e4938fb43719f802cba82d8.png){savepage-src="https://static001.geekbang.org/resource/image/2a/d5/2a62e58cbdf56a5dc40748567d346fd5.jpg"}