(1) Pre-processing: ğ‘ƒ1, Â· Â· Â· , ğ‘ƒğ‘› invoke the multiparty functionality RandomFğ‘›,ğ‘¡ (ğ‘šğ‘ ) to get ([ğ‘ 1], Â· Â· Â· , [ğ‘ ğ‘šğ‘ ]).
(2) For each ğ‘– âˆˆ {2, Â· Â· Â· , ğ‘›}, ğ‘— âˆˆ [ğ‘šğ‘ ], ğ‘ƒ1 and ğ‘ƒğ‘– invoke FPSM functionality as follows: ğ‘ƒ1 and ğ‘ƒğ‘– send inputs ğ‘¦ ğ‘— and ğ‘‹ğ‘–, resp., and
(3) ğ‘ƒğ‘– computes âŸ¨ğ‘”ğ‘– ğ‘—âŸ©ğµ
(4) For each ğ‘– âˆˆ {2, Â· Â· Â· , ğ‘›} and ğ‘— âˆˆ [ğ‘šğ‘ ], ğ‘ƒ1 and ğ‘ƒğ‘– invoke F Fğ‘
B2A
(5) For ğ‘— âˆˆ [ğ‘šğ‘ ],
1 and âŸ¨ğ‘”ğ‘– ğ‘—âŸ©ğµ
ğ‘– , for all ğ‘– âˆˆ {2, Â· Â· Â· , ğ‘›} and ğ‘— âˆˆ [ğ‘šğ‘ ].
resp., and receive additive shares âŸ¨ğ‘“ğ‘– ğ‘—âŸ©1 and âŸ¨ğ‘“ğ‘– ğ‘—âŸ©ğ‘–, resp., as outputs.
functionality as follows: ğ‘ƒ1 and ğ‘ƒğ‘– send inputs âŸ¨ğ‘”ğ‘– ğ‘—âŸ©ğµ
ğ‘– , resp., as outputs.
1 and âŸ¨ğ‘”ğ‘– ğ‘—âŸ©ğµ
ğ‘– ,
â€¢ ğ‘ƒ1 computes âŸ¨ğ‘ ğ‘—âŸ©1 =ğ‘›
ğ‘–=2âŸ¨ğ‘“ğ‘– ğ‘—âŸ©1 and for ğ‘– âˆˆ {2, Â· Â· Â· , ğ‘›}, ğ‘ƒğ‘– sets âŸ¨ğ‘ ğ‘—âŸ©ğ‘– = âŸ¨ğ‘“ğ‘– ğ‘—âŸ©ğ‘–.
â€¢ ğ‘ƒ1, Â· Â· Â· , ğ‘ƒğ‘› compute [ğ‘ ğ‘—] â† ConvertSharesğ‘›,ğ‘¡ (âŸ¨ğ‘ ğ‘—âŸ©).
â€¢ ğ‘ƒ1, Â· Â· Â· , ğ‘ƒğ‘› invoke the following multiparty functionalities.
â€“ [ğ‘ ğ‘—] â† MultFğ‘›,ğ‘¡ ([ğ‘ ğ‘—], [ğ‘  ğ‘—]).
â€“ ğ‘ ğ‘— â† Revealğ‘›,ğ‘¡ ([ğ‘ ğ‘—]).

ğ‘— âˆˆ[ğ‘šğ‘  ]:ğ‘ ğ‘— =0
(6) ğ‘ƒ1 computes the intersection as ğ‘Œğ‘  =
ğ‘¦ ğ‘— from elements in stash.
Figure 11: Handling Stash in mPSI Protocol
â€¢ Case 1 (ğ‘ƒ1 is honest): To simulate the output of RandomFğ‘›,ğ‘¡ in
step 1, pick random ğ‘  ğ‘—â€™s, generate their shares and give ğ‘¡ shares
to the corrupted parties. In step 2, ğ‘ƒ1 and ğ‘ƒğ‘– invoke the FPSM
functionality, for all ğ‘– âˆˆ {2, Â· Â· Â· , ğ‘›} and ğ‘— âˆˆ [ğ‘šğ‘ ]. Since ğ‘ƒ1 âˆ‰ ğ¶,
the view of corrupted parties comprises of only one of the two
boolean shares, i.e., {âŸ¨ğ‘”ğ‘– ğ‘—âŸ©ğµ
ğ‘– }ğ‘–âˆˆğ¶,ğ‘— âˆˆ[ğ‘šğ‘  ], which can be generated
as corresponding shares of some random bit (by definition of
FPSM). Step 3 is local and can be executed by the simulator. In
step 4, the corrupted parties see only one of the two additive
shares {âŸ¨ğ‘“ğ‘– ğ‘—âŸ©ğ‘–}ğ‘–âˆˆğ¶,ğ‘— âˆˆ[ğ‘šğ‘  ], which can be generated as shares of
a random bit (by definition of F Fğ‘
). In step 5, apart from the
B2A
local computations, which can all be executed by the simulator,
the parties call functionalities ConvertSharesğ‘›,ğ‘¡, MultFğ‘›,ğ‘¡ and
Revealğ‘›,ğ‘¡). The corrupted parties get ğ‘¡ shares of ğ‘ ğ‘— and ğ‘ ğ‘—, for
each ğ‘— âˆˆ [ğ‘šğ‘ ]. The simulator can generate ğ‘¡ shares of random
values (by the security of (ğ‘›, ğ‘¡)-secret sharing), and finally, send
the output ğ‘Œâˆ—
â€¢ Case 2 (ğ‘ƒ1 is corrupt): The simulation of step 1 is exactly same
as in Case 1. In step 2, ğ‘ƒ1 and ğ‘ƒğ‘– invoke FPSM functionality,
for all ğ‘– âˆˆ {2, Â· Â· Â· , ğ‘›} and ğ‘— âˆˆ [ğ‘šğ‘ ]. The corrupted parties see
both the boolean shares {âŸ¨ğ‘”ğ‘– ğ‘—âŸ©ğµ
ğ‘– }ğ‘–âˆˆğ¶\{1},ğ‘—âˆˆ[ğ‘šğ‘  ] and only
one of the boolean shares {âŸ¨ğ‘”ğ‘– ğ‘—âŸ©ğµ
1 }ğ‘–âˆˆ[ğ‘›]\ğ¶,ğ‘— âˆˆ[ğ‘šğ‘  ]. For each ğ‘– âˆˆ
ğ¶ \ {1}, simulator sets ğ‘”ğ‘– ğ‘— = 1 if ğ‘¦ ğ‘— âˆˆ ğ‘‹ğ‘– else it sets ğ‘”ğ‘– ğ‘— = 0.
The simulator then generates boolean shares of ğ‘”ğ‘– ğ‘— to simu-
late {âŸ¨ğ‘”ğ‘– ğ‘—âŸ©ğµ
ğ‘– }ğ‘–âˆˆğ¶\{1},ğ‘— âˆˆ[ğ‘šğ‘  ] (by definition of FPSM). For
ğ‘– âˆˆ [ğ‘›] \ ğ¶, the simulator generates boolean shares of random
bits to simulate {âŸ¨ğ‘”ğ‘– ğ‘—âŸ©ğµ
1 }ğ‘–âˆˆ[ğ‘›]\ğ¶,ğ‘— âˆˆ[ğ‘šğ‘  ]. Step 3 is local and can
be executed by the simulator. Corrupted parties see both the
arithmetic shares {âŸ¨ğ‘“ğ‘– ğ‘—âŸ©1, âŸ¨ğ‘“ğ‘– ğ‘—âŸ©ğ‘–}ğ‘–âˆˆğ¶\{1},ğ‘—âˆˆ[ğ‘šğ‘  ] and one of the
arithmetic shares {âŸ¨ğ‘“ğ‘– ğ‘—âŸ©1}ğ‘–âˆˆ[ğ‘›]\ğ¶,ğ‘— âˆˆ[ğ‘šğ‘  ] in step 4. For each ğ‘– âˆˆ
ğ¶ \ {1}, simulator sets ğ‘“ğ‘– ğ‘— = 0 if ğ‘¦ ğ‘— âˆˆ ğ‘‹ğ‘– else it sets ğ‘“ğ‘– ğ‘— = 1.
The simulator then generates arithmetic shares of ğ‘“ğ‘– ğ‘— to simulate
{âŸ¨ğ‘“ğ‘– ğ‘—âŸ©1, âŸ¨ğ‘“ğ‘– ğ‘—âŸ©ğ‘–}ğ‘–âˆˆğ¶\{1},ğ‘—âˆˆ[ğ‘šğ‘  ] (by definition of F Fğ‘
). To simulate
ğ‘  to the corrupted parties.
1 , âŸ¨ğ‘”ğ‘– ğ‘—âŸ©ğµ
1 , âŸ¨ğ‘”ğ‘– ğ‘—âŸ©ğµ
B2A
the view {âŸ¨ğ‘“ğ‘– ğ‘—âŸ©1}ğ‘–âˆˆ[ğ‘›]\ğ¶,ğ‘— âˆˆ[ğ‘šğ‘  ], simulator generates arithmetic
shares of random bits. In step 5, apart from the local computa-
tions, which can all be executed by the simulator, the parties call
functionalities ConvertSharesğ‘›,ğ‘¡, MultFğ‘›,ğ‘¡ and Revealğ‘›,ğ‘¡). The
corrupted parties see at most ğ‘¡ shares of ğ‘ ğ‘—, for each ğ‘— âˆˆ [ğ‘šğ‘ ],
which can be simulated by generating ğ‘¡ shares of random values
(by security of (ğ‘›, ğ‘¡)-secret sharing). Moreover, for all ğ‘— âˆˆ [ğ‘šğ‘ ],
simulator sets ğ‘ ğ‘— = 0 if ğ‘¦ ğ‘— âˆˆ ğ‘Œâˆ—
ğ‘  , else it picks ğ‘ ğ‘— uniformly at
random from Fğ‘ (since ğ‘  ğ‘— are uniformly random given at most ğ‘¡
shares of the corrupted parties). For all ğ‘— âˆˆ [ğ‘šğ‘ ], it gives ğ‘¡ shares
of ğ‘ ğ‘— as output of MultFğ‘›,ğ‘¡ and ğ‘ ğ‘— as output of Revealğ‘›,ğ‘¡.
â–¡
Complexity. ğ‘ƒ1 invokes the PSM protocol for every element ğ‘¦ ğ‘— in
stash and for every party ğ‘ƒğ‘–, ğ‘– âˆˆ {2, Â· Â· Â· , ğ‘›}. Thus, the computation
and communication complexity of this step is O(ğ‘›ğ‘š log(ğ‘š)ğœ†). No-
tice that, this cost dominates the overall cost of the sub-procedure as
the rest of the steps have a complexity of O(ğ‘› log(ğ‘š)ğœ†). Hence, we
obtain an mPSI protocol with an overall complexity of ğ‘‚(ğ‘›ğ‘š log(ğ‘š)ğœ†)
in cuckoo hashing with stash setting.
E WEAK COMPARISON PROTOCOLS
E.1 Correctness and Security of Weak
Comparison Protocol I
We give a complete proof of Theorem 5.2 by proving the correctness
and security of the weak comparison protocol I in Figure 8.
Correctness. The correctness of the evaluation of the polynomial
ğœ“(ğ‘¥) directly follows from its definition and from the correctness of
the multiparty functionalities RandomFğ‘›,ğ‘¡ and MultFğ‘›,ğ‘¡ from [21].
We need to show that, for each ğ‘, except with negligible probability
in correctness parameter (ğœ), ğ‘£ ğ‘— = 0,âˆ€ğ‘— âˆˆ [ğ½] â‡â‡’ ğœ“(ğ‘) = 0.
Lemma E.1. ğœ“(ğ‘) = 0 =â‡’ (cid:0)ğ‘£ ğ‘— = 0,âˆ€ğ‘— âˆˆ [ğ½](cid:1).
Proof. This follows directly from the definition of ğ‘£ ğ‘—.
â–¡
Session 4C: Private Set Intersection CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea1200Lemma E.2. Probability that ğœ“(ğ‘) = 0 when(cid:0)ğ‘£ ğ‘— = 0,âˆ€ğ‘— âˆˆ [ğ½](cid:1) is
atleast 1 âˆ’ 2âˆ’ğœ .
Proof. For any ğ‘— âˆˆ [ğ½], if ğ‘£ ğ‘— = 0 then either ğ‘  ğ‘— = 0 or ğœ“(ğ‘) = 0.
If ğœ“(ğ‘) = 0 then we are done. If ğœ“(ğ‘) â‰  0 and ğ‘£ ğ‘— = 0 then ğ‘  ğ‘— = 0,
which occurs with probability 2âˆ’ log |Fğ‘ |. Probability that ğ‘  ğ‘— = 0 for
every ğ‘— âˆˆ [ğ½] is 2âˆ’ log |Fğ‘ |Â·ğ½ â‰¤ 2âˆ’ğœ by the definition of ğ½. Therefore
if ğœ“(ğ‘) â‰  0 then at least one ğ‘£ ğ‘— â‰  0 with probability at least
1 âˆ’ 2âˆ’ğœ.
â–¡
Hence except with failure probability at most 2âˆ’ğœ the output of the
protocol is correct.
Security. Let ğ¶ âŠ‚ [ğ‘›] be the set of corrupted parties (|ğ¶| = ğ‘¡  2ğœ…+ğ›¾ to be a prime such that ğ‘ mod 4 = 3 and
ğ›¾ = âŒˆlog ğ‘›âŒ‰ + 1. The details of this protocol are given in Appendix
E.2.1.
The weak comparison protocol takes as input, the (ğ‘›, ğ‘¡)âˆ’ shares
[ğ‘]ğ‘– from each ğ‘ƒğ‘– (ğ‘– âˆˆ [ğ‘›]), where ğ‘ âˆˆ Fğ‘ (such that 0 â‰¤ ğ‘  ğ‘› > ğ‘˜ and ğ‘› > 2ğ‘¡. Let ğ›¾ = âŒˆlog ğ‘›âŒ‰ + 1. Addi-
tions and multiplications in the protocol are over Fğ‘, where
ğ‘ depends on the specific instantiation of F ğ‘,ğ‘›,ğ‘¡
Input: For each ğ‘– âˆˆ [ğ‘›], ğ‘ƒğ‘– inputs its (ğ‘›, ğ‘¡)âˆ’ share [ğ‘]ğ‘–.
Mod
Protocol:
(1) ğ‘ƒ1, Â· Â· Â· , ğ‘ƒğ‘› locally compute [ğ‘] = [ğ‘] âˆ’ ğ‘˜.
(2) Let ğ‘1 = ğ‘. For each ğ‘– = 1, Â· Â· Â· , ğ›¾, ğ‘ƒ1, Â· Â· Â· , ğ‘ƒğ‘› do the follow-
ing:
â€¢ Invoke the F ğ‘,ğ‘›,ğ‘¡
functionality with the input [ğ‘ğ‘–] to
get the output [ğ‘‘ğ‘–].
Mod
â€¢ For each ğ‘— âˆˆ [ğ‘›], ğ‘ƒ ğ‘— sets [ğ‘ğ‘–+1] ğ‘— = ([ğ‘ğ‘–] ğ‘— âˆ’ [ğ‘‘ğ‘–] ğ‘—) Â· 2âˆ’1.
(3) ğ‘ğ›¾+1 â† Revealğ‘›,ğ‘¡ ([ğ‘ğ›¾+1]).
Output: ğ‘ƒ1 sets comp = 1, if ğ‘ğ›¾+1 = 0 and comp = 0, other-
wise. Other parties get no output.
Figure 13: WEAK COMPARISON PROTOCOL II
Theorem E.3. The protocol given in Figure 13 securely realizes
F ğ‘,ğ‘˜,ğ‘›,ğ‘¡
w-CMP in the Fâˆ’hybrid model, where F = (F ğ‘,ğ‘›,ğ‘¡
, Revealğ‘›,ğ‘¡),
against a semi-honest adversary corrupting ğ‘¡ < ğ‘›/2 parties.
Mod
Proof. Correctness. The correctness of the protocol follows
and Revealğ‘›,ğ‘¡ and