policy aborts any outgoing communication from the malware
by sending error responses to DNS requests, resets to SYN
packets, and sinking outgoing UDP trafﬁc. This policy is
designed to trick the malware into revealing all endpoints it
knows, as it tries to ﬁnd a working endpoint. The restricted
access policy allows C&C trafﬁc to and from the Internet, but
blocks other malicious activities such sending spam, launching
attacks, or clickfraud. This policy also resets any connection
with a payload larger than 4 KB to prevent the malware to
download and install other executables.
The malware is ﬁrst run with the endpoint failure contain-
ment policy and a default conﬁguration. If it fails to send any
trafﬁc, it is rerun with different conﬁgurations. For example,
it is queued to be rerun on a different VM (e.g., on QEMU
if originally run on VMWare) and for an extended period of
time (e.g., doubling the execution timer). This helps to address
malware samples that use evasion techniques for speciﬁc VM
platforms, and to account for malware samples that may take
longer to start its network communication.
III. ADVERSARIAL FINGERPRINT GENERATION
This section explains the process of generating ﬁngerprints
for a malicious family of interest starting from a set of
network traces. Fingerprint generation comprises 4 steps. First,
it extracts from the network traces the set of request-response
pairs (RRPs) (Section III-A). Then, it replays the requests to
the live servers collecting their responses (Section III-B). Next,
it clusters RRPs with similar requests (Section III-C). Finally,
it generates signatures for each cluster (Section III-D).
Benign trafﬁc pool. Adversarial ﬁngerprint generation also
takes as input a pool of benign trafﬁc used to identify which
parts of the responses from servers in the family are distinctive,
i.e., do not appear in benign trafﬁc. This pool comprises three
traces: two of HTTP and HTTPS trafﬁc produced by visiting
the top Alexa sites [2] and a 2-day long trace comprising all
external trafﬁc from a network with 50 users, captured at the
network’s border. We scan the traces with two IDS signature
sets, verifying that they do not contain malicious trafﬁc.
A. RRP Feature Extraction
From the network traces, CyberProbe ﬁrst extracts the
RRPs, i.e., TCP connections and UDP ﬂows initiated by the
malware or honeyclient towards a remote responder, and for
which some data is sent back by the responder. Here, a UDP
ﬂow is the sequence of UDP packets with the same endpoints
and ports that times out if no communication is seen for
a minute. For each RRP, CyberProbe extracts the following
feature vector:
hproto, sport, dport, sip, dip, endpoint, request, responsei
where proto is the protocol, sport, dport, sip, dip are the ports
and IP addresses, and endpoint is the domain name used to
resolve the destination IP. The request and response features
represent the raw content of the request and response.
To extract the protocol feature CyberProbe uses protocol
signatures to identify standard protocols commonly used by
malware such as HTTP. Protocol signatures capture keywords
present in the early parts of a message (e.g., GET or POST
in HTTP) [13], [19]. They are able to identify the protocol
even if it uses a non-standard port, and can also identify
non-standard protocols on standard ports. Both situations are
common with malware. For unknown application protocols,
the protocol feature is the transport protocol.
4
RRPs for which the request endpoint is one of the top
100,000 Alexa domains [2] are discarded. This removes trafﬁc
to benign sites, used by malware to test connectivity and by
exploit servers to download vulnerable software or redirect the
user after exploitation. In addition, it removes RRPs that have
identical requests (excluding ﬁelds known to have dynamic
data such as the HTTP Host header),
to avoid replaying
the same request many times. From the remaining RRPs
CyberProbe builds an initial list of malicious endpoints. For
this, it resolves each domain in the endpoint feature to obtain
the current IP addresses the domain resolves to. It returns the
union of the destination IP addresses and the resolved IPs.
B. Replay
The next step is to replay the requests in the RRPs extracted
from the network traces to the known malicious endpoints.
The goal is to identify requests that lack replay protection, i.e.,
requests that if replayed to the same server at a later time or to
another server of the family still incite a distinctive response.
CyberProbe replays each unique request in the RRPs to every
entry in the initial list of malicious endpoints, collecting the
responses from endpoints that are alive.
The replay uses a commercial Virtual Private Network
(VPN) that offers exit points in more than 50 countries, each
with a pool of IP addresses, totaling more than 45,000 IPs.
Using a VPN is important for two reasons. First, while the
requests CyberProbe replays have a valid protocol syntax,
there is still a small chance that
they are replayed in an
incorrect order or are no longer valid. If so, the managers of
the malicious family could notice it and block the sender’s IP
address. In addition, we are interested in requests that generate
a response without requiring any prior communication with
the malicious server. Since CyberProbe replays all requests to
each endpoint, it is important that the request being replayed is
not inﬂuenced by any state that a previously replayed request
may have set in the server. To achieve independence between
replays, the replayer changes the VPN exit node (an thus
its observable IP address) for each request sent to the same
endpoint. Intuitively, a server keeps a separate state machine
for each client that connects to it. Thus, by employing a
previously unused IP address, the server will be in its initial
state when it receives the replayed request.
Filtering benign servers. A common situation when replaying
is that
the IP address of a malicious server in the input
network traces may have been reassigned to a benign server.
Responses from benign servers need to be removed before
building a signature to avoid false positives. To ﬁlter responses
from benign servers, CyberProbe leverages the intuition that a
benign server will not understand the replayed request and typ-
ically will ignore it (e.g., for a binary C&C request) or return
an error (e.g., HTTP 404). Thus, as a ﬁrst step CyberProbe
removes from the replayed RRPs those with no response or
where the response is an error (e.g., HTTP 4xx). However, a
surprisingly large number of benign HTTP servers reply with
a successful response (i.e., HTTP 200 OK) to any request,
possibly including a custom error message in the body of the
response. Thus, a technique is needed to identify custom error
messages without a priori knowledge of how they may look.
To address this challenge, CyberProbe also sends an HTTP
request for a random resource to each potentially malicious
HTTP server, leveraging the insight that if the responses from
a server to the replayed request and to the random request are
similar, most likely the server did not understand either request
and the response is an error message.
CyberProbe considers two HTTP responses similar if they
have the same result code, the same Content-Type header
value, and similar content. Two non-HTML contents are sim-
ilar if their MIME type as returned by the UNIX file tool
is the same. For HTML documents, it uses an off-the-shelf
similarity package [21], which serializes the HTML trees of
the pages as arrays and ﬁnds the longest common sequence
between the arrays. It measures similarity as:
d(a, b) =
2 ⇤ length(LCS(array(a), array(b)))
length(array(a)) + length(array(b))
.
After removing errors and responses from benign servers
the remaining RRPs are replayed twice more to the endpoints
that responded, so that variations in the responses, e.g., changes
in the HTTP Date and Cookie headers, are captured. The
output of the replay phase are the remaining replayed RRPs.
The original RRPs extracted from the network traces are not
part of the output,
i.e., only RRPs for which the request
successfully replays are used to build the ﬁngerprint. The
unique endpoints in the output RRPs are the seed servers.
C. Clustering RRPs by Request Similarity
Next, CyberProbe clusters the RRPs by request similarity
to identify instances of the same type of request across the
network traces. This step prevents generating multiple ﬁnger-
prints of the same type and enables producing more general
ﬁngerprints. We use two separate clusterings, a protocol-
aware clustering for HTTP and a transport clustering for other
protocols.
For HTTP, CyberProbe groups RRPs for which the requests
have the same method (e.g., GET or POST) and satisfy the
following conditions:
•
•
Same path. The path in both URLs is the same and
does not correspond to the root page.
Similar parameters. The Jaccard index of the sets
of URL parameters is larger than an experimentally
selected threshold of 0.7. Parameter values are not
included.
For other protocols, CyberProbe groups packets from the
same transport protocol, with the same size and content, and
sent to the same destination port. The output of the request
clustering is the union of the trafﬁc clusters output by the two
clusterings. Each cluster contains the RRP feature vectors and
the clusters do not overlap.
Probe construction function. From the requests in each
cluster, CyberProbe produces a probe construction function.
The probe construction function is basically one of the probes
in the cluster where the value of a ﬁeld may be replaced by
the special TARGET and SET macros. The TARGET macro
represents that the ﬁeld needs to be updated with the value
of the target endpoint during scanning, e.g., the HTTP Host
header. The SET macro is used for ﬁelds that have different
values in the cluster’s requests. It represents that the value of
the ﬁeld can be chosen from this set when generating a new
probe during scanning.
5
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
Algorithm 1 Signature Generation Algorithm
def
t o k e n i z e r e s p o n s e s ( c l u s t e r ) {
i n f o = [ ]
t o k e n s
# Get u ni qu e
u n i q u e f i e l d s = g e t d i s t i n c t
for
f i e l d in u n i q u e f i e l d s
f o r
f i e l d s
f o r
# Get u ni qu e v a l u e s
u n i q u e v a l u e s = g e t d i s t i n c t
# T o k e n i z e u ni qu e
t o k e n s = t o k e n i z e ( u n i q u e v a l u e s )
for t o k e n in t o k e n s
f i e l d v a l u e s
f i e l d
r e s p o n s e s
i n c l u s t e r
f i e l d s ( c l u s t e r )
f i e l d s v a l u e s ( f i e l d )
# Get
f e a t u r e
v e c t o r s = g e t
# Add t o k e n
t o k e n s
return t o k e n s
i n f o
v e c t o r s
r e s p o n s e s ( t o k e n )
f o r
r e s p o n s e s w i t h t h e t o k e n
i n f o . add ( f i e l d , token , v e c t o r s )
def
r e f i n e s i g n a t u r e ( t o k e n s
i n f o , c u r r
s i g )
t i n f o , r e m t o k e n s i n f o =
g e t
t o k e n m a x o v e r l a p ( t o k e n s
i n f o , c u r r
r s i g = add token ( c u r r
i f cov ( r s i g ) = cov ( c u r r
s i g , t i n f o )
s i g )
i f
r e f i n e s i g n a t u r e ( r e m t o k e n s i n f o , r s i g )
fp ( c u r r
return c u r r
s i g ) < thresf p
s i g
r e f i n e s i g n a t u r e ( r e m t o k e n s i n f o , r s i g )
def g e n e r a t e s i g n a t u r e s ( c l u s t e r ) {
s i g n a t u r e s = [ ]
t o k e n s
while
i n f o = t o k e n i z e r e s p o n s e s ( c l u s t e r )
t r u e
# Find t o k e n t h a t maximizes c o v e r a g e
t i n f o , r e m t o k e n s i n f o , c o v i n c r e a s e =
g e t m a x c o v e r a g e t o k e n ( s i g n a t u r e s , t o k e n s
c o v i n c r e a s e < threscov break
i n f o )
i f
e l s e
s i g = add token ( Ø , t o k e n i n f o )
i n i t i a l
r e f i n e d s i g = r e f i n e ( r e m t o k e n s i n f o , i n i t i a l
i f
r e f i n e d s i g
s i g n a t u r e s . add ( r e f i n e d s i g )
s i g )
return s i g n a t u r e s
}
D. Signature Generation
For each cluster, signature generation produces signatures
that capture parts of the responses that are unique to the
family of interest, i.e., that are uncommon in the benign trafﬁc
pool. CyberProbe builds token-set payload signatures, which
are supported by both Snort and Suricata. A token set is an
unordered set of binary strings (i.e., tokens) that matches the
content of a buffer if all tokens in the signature appear in the
buffer, in any order. The more tokens and the longer each token
the more speciﬁc the signature.
Algorithm 1 describes the signature generation. Its salient
characteristics are that when the protocol
is known (e.g,.
HTTP) the tokenization is performed on ﬁelds and that multi-
ple signatures may be generated for each cluster. For each ﬁeld
in the responses in the cluster, it identiﬁes distinctive tokens
i.e., tokens with high coverage and low false positives. We
deﬁne the false positive rate of a token in a ﬁeld to be the
fraction of responses in the benign pool that contain the token
in the ﬁeld, over the total number of responses in the benign
pool. The coverage is the fraction of responses in the cluster
with the token in that ﬁeld, over the total number of responses
in the cluster. A token is distinctive if it has a ﬁle coverage
larger than 0.4 and a false positive rate below 10 9.
Algorithm 1 can generate multiple signatures because dis-
tinctive tokens do not need to appear in all responses in the
trafﬁc cluster. This is important to handle noise in the cluster,
6
s i g )
IV. SCANNING
Full (F )
4.3B (100%)
TABLE I.
Unreserved (U) Allocated (I)
3.7B (86%)
3.7B (86%)
BGP (B)
2.6B (60%)
NUMBER OF IPV4 ADDRESSES (IN BILLIONS) FOR
DIFFERENT INTERNET-WIDE TARGET SETS.
e.g., from incorrectly labeled malware in the input traces. The
get distinct ﬁelds function returns all ﬁelds in the response
(or a single ﬁeld if the protocol is unknown), except ﬁelds
that contain dynamically generated data (e.g., the Date and
Set-Cookie HTTP headers), as those ﬁelds should not be part
of the signature. The tokenize function uses a sufﬁx array [1]
to extract tokens larger than 5 bytes that appear in the set of
unique ﬁeld values.
This section ﬁrst describes general characteristics of our
scanning such as the target ranges to scan, scan rate, scan order,
and scanner placement. Then, it details the implementation of
our horizontal, UDP, and appTCP scanners.
localized-reduced,
A. General Scanning Characteristics
Scan ranges. We perform 3 types of scans based on the
ranges to be probed:
localized-extended,
and Internet-wide. For Internet-wide scans, prior work has used
different ranges that qualify as “Internet-wide” [3], [11], [20],
[28]. These studies do not scan the full Internet IPv4 space
(F ), but rather the non-reserved IPv4 ranges (U ✓ F ) [3],
the IANA-allocated blocks (I ✓ U) [11], [20], or the set of
advertised BGP ranges (B ✓ I) [28]. These ranges differ in
their sizes, which are shown in billions of IP addresses in
Table I. The U and I ranges are nowadays the same as all
the non-reserved IPv4 space has been allocated by IANA. In
this work, for Internet-wide horizontal and UDP scans, we
ﬁrst collect the BGP ranges advertised the day of the scan
from the RouteViews site [46]. Then, we union those ranges
removing any route overlaps. The table shows that using the
BGP information to exclude non-routable ranges reduces the
scan range up to 40%.
Localized scans focus on IP ranges belonging to providers
that have been observed in the past to host a server of the
malicious family. To select the target ranges for localized scans
we use the IP addresses of the seed servers and the BGP
route information. For localized-reduced scans, we obtain the
most speciﬁc BGP route that contains each seed’s IP address,
and output the union of those routes. For localized-extended
scans, for each seed server we ﬁrst obtain the most speciﬁc
route containing the seed’s IP. From each of those routes,
we extract the route description, which typically identiﬁes the
provider that the route belongs to. Then, we query again the
BGP information for the list of all other routes with the same
description (i.e., from the same provider) and make their union