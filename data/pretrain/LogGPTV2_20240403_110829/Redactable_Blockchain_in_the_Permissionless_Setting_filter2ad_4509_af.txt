# References

1. Network Security. Springer, 2014, pp. 80–96.
2. G. Ateniese, B. Magri, D. Venturi, and E. Andrade, “Redactable blockchain—or—rewriting history in Bitcoin and friends,” in *Security and Privacy (EuroS&P), 2017 IEEE European Symposium on*. IEEE, 2017, pp. 111–126.
3. C. Badertscher, P. Gaži, A. Kiayias, A. Russell, and V. Zikas, “Ouroboros Genesis: Composable proof-of-stake blockchains with dynamic availability,” in *Proceedings of the 2018 ACM SIGSAC Conference on Computer and Communications Security*, ser. CCS '18, pp. 913–930.
4. Accenture for patent files: <https://tinyurl.com/yblq9zdp>.
5. “Downside of Bitcoin: A ledger that can’t be corrected,” 2016: <https://tinyurl.com/ydxjlf9e>.
6. I. Bentov and R. Kumaresan, “How to use Bitcoin to design fair protocols,” in *CRYPTO 2014, Part II*, ser. LNCS, J. A. Garay and R. Gennaro, Eds., vol. 8617. Springer, Heidelberg, Aug. 2014, pp. 421–439.
7. L. Breidenbach, I. Cornell Tech, P. Daian, F. Tramer, and A. Juels, “Enter the Hydra: Towards principled bug bounties and exploit-resistant smart contracts,” in *27th USENIX Security Symposium (USENIX Security 18)*. USENIX Association, 2018.
8. J. Bruce, “The mini-blockchain scheme,” White paper, 2014.
9. J. Camenisch, D. Derler, S. Krenn, H. C. Pöhl, K. Samelin, and D. Slamanig, “Chameleon-hashes with ephemeral trapdoors,” in *IACR International Workshop on Public Key Cryptography*. Springer, 2017, pp. 152–182.
10. A. Chepurnoy, M. Larangeira, and A. Ojiganov, “Rollerchain: A blockchain with safely pruneable full blocks,” arXiv preprint arXiv:1603.07926, 2016.
11. I. Eyal and E. G. Sirer, “Majority is not enough: Bitcoin mining is vulnerable,” in *FC 2014*, ser. LNCS, N. Christin and R. Safavi-Naini, Eds., vol. 8437. Springer, Heidelberg, Mar. 2014, pp. 436–454.
12. J. A. Garay, A. Kiayias, and N. Leonardos, “The Bitcoin backbone protocol: Analysis and applications,” in *EUROCRYPT 2015, Part II*, ser. LNCS, E. Oswald and M. Fischlin, Eds., vol. 9057. Springer, Heidelberg, Apr. 2015, pp. 281–310.
13. B. Gipp, J. Kosti, and C. Breitinger, “Securing video integrity using decentralized trusted timestamping on the Bitcoin blockchain,” in *MCIS*, 2016, p. 51.
14. B. Gipp, N. Meuschke, and A. Gernandt, “Decentralized trusted timestamping using the cryptocurrency Bitcoin,” arXiv preprint arXiv:1502.04015, 2015.
15. E. Heilman, A. Kendler, A. Zohar, and S. Goldberg, “Eclipse attacks on Bitcoin’s peer-to-peer network,” in *USENIX Security Symposium*, 2015, pp. 129–144.
16. H. Hu, W. Han, G.-J. Ahn, and Z. Zhao, “FlowGuard: Building robust firewalls for software-defined networks,” in *Proceedings of the Third Workshop on Hot Topics in Software-Defined Networking*. ACM, 2014, pp. 97–102.
17. L.-D. Ibáñez, K. O’Hara, and E. Simperl, “On blockchains and the General Data Protection Regulation,” 2018.
18. S. Ioannidis, A. D. Keromytis, S. M. Bellovin, and J. M. Smith, “Implementing a distributed firewall,” in *ACM CCS 00*, S. Jajodia and P. Samarati, Eds. ACM Press, Nov. 2000, pp. 190–199.
19. A. Kiayias, A. Russell, B. David, and R. Oliynykov, “Ouroboros: A provably secure proof-of-stake blockchain protocol,” in *Annual International Cryptology Conference*. Springer, 2017, pp. 357–388.
20. A. Kiayias and Q. Tang, “Traitor deterring schemes: Using Bitcoin as collateral for digital content,” in *ACM CCS 15*, I. Ray, N. Li, and C. Kruegel, Eds. ACM Press, Oct. 2015, pp. 231–242.
21. A. E. Kosba, A. Miller, E. Shi, Z. Wen, and C. Papamanthou, “Hawk: The blockchain model of cryptography and privacy-preserving smart contracts,” in *2016 IEEE Symposium on Security and Privacy*. IEEE Computer Society Press, May 2016, pp. 839–858.
22. R. Kumaresan and I. Bentov, “How to use Bitcoin to incentivize correct computations,” in *ACM CCS 14*, G.-J. Ahn, M. Yung, and N. Li, Eds. ACM Press, Nov. 2014, pp. 30–41.
23. R. Kumaresan, T. Moran, and I. Bentov, “How to use Bitcoin to play decentralized poker,” in *ACM CCS 15*, I. Ray, N. Li, and C. Kruegel, Eds. ACM Press, Oct. 2015, pp. 195–206.
24. R. Matzutt, M. Henze, J. H. Ziegeldorf, J. Hiller, and K. Wehrle, “Thwarting unwanted blockchain content insertion,” in *Cloud Engineering (IC2E), 2018 IEEE International Conference on*. IEEE, 2018, pp. 364–370.
25. R. Matzutt, J. Hiller, M. Henze, J. H. Ziegeldorf, D. Müller, O. Hohlfeld, and K. Wehrle, “A quantitative analysis of the impact of arbitrary blockchain content on Bitcoin,” in *Proceedings of the 22nd International Conference on Financial Cryptography and Data Security (FC)*. Springer, 2018.
26. R. Matzutt, O. Hohlfeld, M. Henze, R. Rawiel, J. H. Ziegeldorf, and K. Wehrle, “Poster: I don’t want that content! On the risks of exploiting Bitcoin’s blockchain as a content store,” in *Proceedings of the 2016 ACM SIGSAC Conference on Computer and Communications Security*. ACM, 2016, pp. 1769–1771.
27. E. McReynolds, A. Lerner, W. Scott, F. Roesner, and T. Kohno, “Cryptographic currencies from a tech-policy perspective: Policy issues and technical directions,” in *International Conference on Financial Cryptography and Data Security*. Springer, 2015, pp. 94–111.
28. A. Molina and H. Schoenfeld, “Pascalcoin version 2,” White paper, 2017.
29. S. Nakamoto, “Bitcoin: A peer-to-peer electronic cash system,” 2008.
30. R. Pass, L. Seeman, and A. Shelat, “Analysis of the blockchain protocol in asynchronous networks,” in *Advances in Cryptology - EUROCRYPT 2017 - 36th Annual International Conference on the Theory and Applications of Cryptographic Techniques, Paris, France, April 30 - May 4, 2017, Proceedings, Part II*, 2017, pp. 643–673.
31. R. Pass and A. Shelat, “Micropayments for decentralized currencies,” in *ACM CCS 15*, I. Ray, N. Li, and C. Kruegel, Eds. ACM Press, Oct. 2015, pp. 207–218.
32. R. Pass and E. Shi, “Fruitchains: A fair blockchain,” in *Proceedings of the ACM Symposium on Principles of Distributed Computing*. ACM, 2017, pp. 315–324.
33. I. Puddu, A. Dmitrienko, and S. Capkun, “μChain: How to forget without hard forks.” IACR Cryptology ePrint Archive, vol. 2017, p. 106, 2017.
34. I. Ray, N. Li, and C. Kruegel, Eds., *ACM CCS 15*. ACM Press, Oct. 2015.
35. M. Roesch et al., “Snort: Lightweight intrusion detection for networks,” in *LISA*, vol. 99, no. 1, 1999, pp. 229–238.
36. K. Shirriff, “Hidden surprises in the Bitcoin blockchain and how they are stored: Nelson Mandela, WikiLeaks, photos, and Python software,” Ken Shirriff’s blog (accessed July 2017): <http://www.righto.com/2014/02/ascii-bernanke-wikileaks-photographs.html>, 2014.
37. M. D. Sleiman, A. P. Lauf, and R. Yampolskiy, “Bitcoin message: Data insertion on a proof-of-work cryptocurrency system,” in *Cyberworlds (CW), 2015 International Conference on*. IEEE, 2015, pp. 332–336.
38. G. Tziakouris, “Cryptocurrencies—a forensic challenge or opportunity for law enforcement? An Interpol perspective,” *IEEE Security & Privacy*, vol. 16, no. 4, pp. 92–94, 2018.

## Appendix

### A. Protocol Extension for Multiple Redactions

In this section, we outline an extension to the protocol in Figure 2 to accommodate multiple redactions per block. The intuition behind the extension is straightforward: a block can potentially be redacted multiple times, and each approved redaction \( B_j^{(k)} \) of the block \( B_j \) must contain information about the entire history of previous redactions. In our extension, this information is stored in the \( y_j^{(k)} \) component of the candidate block \( B_j^{(k)} \). Below, we sketch the required protocol changes.

#### Proposing an Edit

To propose a redaction for block \( B_j := (s_j, x_j, \text{ctr}_j, y_j) \), the user must build a candidate block \( B_j^{(k)} \) of the following form:
\[ B_j^{(k)} := (s_j, x_j^{(k)}, \text{ctr}_j, y_j^{(k)}) \]
where
\[ y_j^{(k)} := y_j || G(s_j, x_j) \quad \text{if} \quad y_j \neq G(s_j, x_j). \]
Note that for the first redaction of \( B_j \), we have \( y_j = G(s_j, x_j) \), and therefore \( y_j^{(k)} := G(s_j, x_j) \).

#### Block Validation

To validate a block, the users run the `validateBlockExt` algorithm described in Algorithm 5. Intuitively, the algorithm performs the same operations as Algorithm 2, except that it takes into account the possibility of the block being redacted multiple times. By parsing \( y \) as \( y^{(1)} || y^{(2)} || \ldots || y^{(l)} \), we are considering a block that has been redacted a total of \( l \) times, where \( y^{(1)} \) denotes the original state information of the unredacted version of the block.

```plaintext
Algorithm 5: validateBlockExt
input : Block B := (s, x, ctr, y).
output: {0, 1}
1: Validate data x, if invalid return 0;
2: Parse y as y^{(1)} || y^{(2)} || ... || y^{(l)}, where y^{(i)}_j ∈ {0, 1}^κ ∀i ∈ [l];
3: if (H(ctr, G(s, x), y) < D) ∨ (H(ctr, y^{(1)}, y^{(1)}) < D) then return 1;
4: else return 0;
```

#### Voting for Candidate Blocks

To vote for a redaction, we define the following interface:

- \( H(\text{ctr}, G(s, x^{(k)}), y^{(k)}) \leftarrow \Gamma^{(k)}.Vt(B^{(k)}) \):
  - Takes as input a candidate block \( B^{(k)} \) and parses \( B^{(k)} \) as \( (s, x^{(k)}, \text{ctr}, y^{(k)}) \).
  - Outputs the hash value \( H(\text{ctr}, G(s, x^{(k)}), y^{(k)}) \) as a vote for the candidate block \( B^{(k)} \).

The voting interface is invoked by users who wish to endorse a candidate block by including a vote in the newly mined block (if the candidate block is still in its voting phase). Accordingly, the policy \( P \) of the chain for redactions checks if a candidate block has received at least a ratio of \( \rho \) votes (as output by \( \Gamma^{(k)}.Vt \)) in a span of \( \tau \) blocks after its proposal.

#### Candidate Block Validation

If a block \( B_j \) is being redacted more than once, then the corresponding candidate block \( B_j^{(k)} \) needs to be validated for accounting for the multiple redactions that happened before. For each redaction of \( B_j \), the votes for that redaction must exist in the chain \( C \). `validateCandExt` (described in Algorithm 6) validates such a candidate block.

```plaintext
Algorithm 6: validateCandExt
input : Chain C = (B1, · · · , Bn) of length n, and a candidate block B_j^{(k)} := (s_j, x_j^{(k)}, ctr_j, y_j) for an edit.
output: {0, 1}
1: Parse B_j^{(k)} as (s_j, x_j^{(k)}, ctr_j, y_j);
2: Parse y_j as y^{(1)}_j || y^{(2)}_j || ... || y^{(l)}_j, where y^{(i)}_j ∈ {0, 1}^κ ∀i ∈ [l];
3: Parse B_{j-1} := (s_{j-1}, x_{j-1}, ctr_{j-1}, y_{j-1});
4: Parse y_{j-1} as y^{(1)}_{j-1} || y^{(2)}_{j-1} || ... || y^{(l')}_{j-1}, where y^{(i)}_{j-1} ∈ {0, 1}^κ ∀i ∈ [l'];
5: Parse B_{j+1} := (s_{j+1}, x_{j+1}, ctr_{j+1}, y_{j+1});
6: if Γ^{(k)}.validateBlockExt(B_j^{(k)}) = 0 then return 0;
7: if s_j ≠ H(ctr_{j-1}, y^{(1)}_{j-1}, y^{(1)}_{j-1}) then return 0;
8: for i ∈ {2, . . . , n} do
9:   if s_j ≠ H(ctr_{j-1}, y^{(1)}_{j-1}, y^{(1)}_{j-1}) then
10:     if the fraction of votes for H(ctr, y^{(i)}_{j-1}, y^{(1)}_{j-1}) in the chain C is not at least ρ within its voting period of τ blocks then return 0;
11: return 1;
```

#### Chain Validation

To validate a chain, the user runs the `validateChainExt` algorithm (described in Algorithm 7). The only change compared to Algorithm 1 is that now \( y_j \) is parsed as \( y^{(1)}_j || y^{(2)}_j || \ldots || y^{(l)}_j \), where the initial unredacted state of the block is stored in \( y^{(1)}_j \).

```plaintext
Algorithm 7: validateChainExt
input : Chain C = (B1, · · · , Bn) of length n.
output: {0, 1}
1: j := n;
2: if j = 1 then return Γ^{(k)}.validateBlockExt(B1);
3: while j ≥ 2 do
4:   Bj := Head(C) when j = n
5:   Parse Bj as (s_j, x_j, ctr_j, y_j);
6:   Parse y_j as y^{(1)}_j || y^{(2)}_j || ... || y^{(l)}_j, where y^{(i)}_j ∈ {0, 1}^κ ∀i ∈ [l];
7:   Parse B_{j-1} := (s_{j-1}, x_{j-1}, ctr_{j-1}, y_{j-1});
8:   Parse y_{j-1} as y^{(1)}_{j-1} || y^{(2)}_{j-1} || ... || y^{(l')}_{j-1}, where y^{(i)}_{j-1} ∈ {0, 1}^κ ∀i ∈ [l'];
9:   if Γ^{(k)}.validateBlockExt(B_j) = 0 then return 0;
10:  if s_j = H(ctr_{j-1}, G(s_{j-1}, x_{j-1}), y_{j-1}) then j := j − 1;
11:  else if s_j = H(ctr_{j-1}, y^{(1)}_{j-1}, y^{(1)}_{j-1}) ∧ Γ^{(k)}.validateCandExt(C, B_{j-1}) = 1 ∧ P(C, B_{j-1}) = accept then j := j − 1;
12:  else return 0;
13: return 1;
```