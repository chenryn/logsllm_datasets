In other words, at each step of the path the next view satisﬁes one of
the following: it is an application entry point, is reachable through
a link, is the same as the previous view (which corresponds to the
user pressing the back button in her browser), or is the same as the
current view (which corresponds to the use of the refresh button).
Given the previous deﬁnition, we can now provide a formal char-
acterization of the two classes of vulnerabilities we introduce in this
paper. A violation of the intended workﬂow of the application oc-
curs when:
∃p ∈ N | p /∈ I,
that is, when there exists a valid navigation path that is not an in-
tended path.
A multi-module data-ﬂow vulnerability is deﬁned as:
∃p = (cid:3)V0, . . . , Vn(cid:4) ∈ N , ∃Ex ∈ Σn | ¬ san(Ex, Sn−1),
that is, there is a path in the application such that some portion of
the application’s extended state is used in a security-critical opera-
tion without being properly sanitized.
4.
INTRA-MODULE ANALYSIS
The analysis performed by MiMoSA consists of two phases: an
intra-module phase, which examines each module of the applica-
tion in isolation, followed by an inter-module phase, where the ap-
plication is considered as a whole.
The goal of the intra-module analysis is to summarize each appli-
cation module into a set of views, by determining its pre-condition,
post-conditions, and sinks. From each module, we also extract the
list of all outgoing links and we associate them with the views they
belong to. This information is then used by the inter-module anal-
ysis to reconstruct the intended workﬂow of the application.
The main steps of the intra-module phase are shown in Fig-
ure 1. Note that these steps are obviously language-dependent.
Even though in this paper we focus on applications written in the
PHP language, our approach can be easily extended to extract views
from modules written in other programming languages.
To better illustrate our technique, we will refer to a simple web
application whose code is presented in Figure 2. The application
is written in PHP and consists of three modules: index.php,
which is the application entry point, create.php, which allows
new users to create an account, and answer.php, which provides
some information that should be accessible only to registered users.
The application state is maintained using both a relational database,
which contains the users’ accounts, and a PHP session variable, i.e.,
_SESSION["loggedin"].
Even though the application is very simple, it contains repre-
sentative examples of the security problems that our approach is
able to identify.
In particular, the application contains two vul-
nerabilities. The ﬁrst vulnerability is caused by the fact that the
index.php module uses usernames retrieved from the database
as part of its output page. Usernames are strings arbitrarily cho-
sen by users during the registration process implemented by the
create.php module. Since these strings are never sanitized in
any module, the application is vulnerable to XSS attacks. The sec-
ond vulnerability is contained in the answer.php module. The
module incorrectly checks the value of the loggedin variable in-
stead of _SESSION["loggedin"] in order to verify the user
status. However, if the PHP register_globals option is acti-
vated and the _SESSION["loggedin"] variable has not been
deﬁned (i.e., the user is not logged in), an attacker can include a
loggedin parameter in her GET or POST request, effectively
shadowing the session variable with a value of her choosing. This
could be leveraged to bypass the registration mechanism and ac-
cess the restricted answer.php module without being previously
authenticated, thus violating the intended workﬂow of the applica-
tion.
As it is clear from the examples above, these vulnerabilities are
carried out in multiple steps and involve multiple modules. The
ultimate goal of our analysis is to detect these multi-module vul-
nerabilities. However, in order to analyze the interactions between
modules, it is ﬁrst necessary to analyze the properties of each mod-
ule. This analysis is the focus of the rest of this section.
4.1 Control-Flow and Data-Flow Graphs
Extraction
The ﬁrst step of the intra-module analysis is the extraction of the
control-ﬂow and data-ﬂow graphs from each module of the applica-
tion. Our implementation leverages Pixy [9], a static analysis tool
for detecting intra-module vulnerabilities in PHP applications. We
adopted Pixy’s PHP parser, control-ﬂow graph derivation compo-
nent, and alias analysis component. In addition, we extended Pixy
with a data-ﬂow component that computes the def-use chains for a
module using a standard algorithm [1]. The resulting tool provides
all the information needed for the following steps of the analysis.
The main limitation of Pixy, besides being limited to intra-module
analysis only, is the lack of support for object-oriented code. Where
needed, we manually pre-processed input modules to work around
this problem.
4.2 Database Analysis
Databases are often used by web applications to store data per-
manently. This data is usually accessible by every module of the
application. Therefore, it is important to characterize module-da-
tabase interactions as they could be leveraged to perform a multi-
module attack.
The goal of the database analysis is to translate the interaction
between an application module and the back-end database into a
set of variable assignments. By doing this, the following steps of
the analysis (e.g., the view extraction process) can handle database
operations and assignments to variables in a uniform way.
For example, consider the following SQL query that writes the
content of the variable uname to the column username in the
database table users:
UPDATE users SET username=$uname WHERE...
As a result of the database analysis, a new assignment is added after
the call to the function that executes the query. In our example,
MiMoSA generates the following assignment node:
$DB_dbname_users_username = $uname;
PHP
module
Parsing and
CFG 
construction
Data-
ﬂow
analysis
Database
analysis
Views
extraction
Links
extraction
View
set
Figure 1: The main steps of the intra-module analysis. The parts in gray are implemented by Pixy.
Note that DB_dbname_users_username is a new variable cre-
ated by our analysis to model the part of the database modiﬁed by
the UPDATE operation.
The PHP language provides a number of internal functions to
connect to different types of relational databases.
In our proto-
type implementation, we focused on the MySQL library because
of its popularity. However, if the target application uses a different
database, our technique can be easily adapted to address a different
set of primitives. In PHP, access to the MySQL database is usually
performed by ﬁrst calling the mysql_query function to execute
a query, and then by using one of the mysql_fetch functions to
access the results of the query in an iterative fashion.
The main challenge in the database analysis is to properly re-
construct the values that a query can assume at runtime, so that we
can determine the tables and columns that are modiﬁed by the op-
eration. To achieve this, we traverse the control-ﬂow graph of the
module, looking for calls to the mysql_query function. Since,
in general, static analysis cannot provide the value that the query
will assume at runtime, we apply a dynamic analysis technique
to the block of PHP code that precedes the function call to de-
rive the names and ﬁelds of the tables involved in the query. The
mysql_query call. A deterministic path is a sequence of nodes
in the control-ﬂow graph that only contains branch instructions
whose conditional expressions can be statically determined. We
analysis extracts the largest deterministic path eP that precedes the
then remove from eP any input/output related operation, and we re-
place any undeﬁned variable in eP with a placeholder.
along the path eP . If the resulting query performs an UPDATE or
The resulting code is passed to the PHP interpreter in order to
dynamically determine the value that the query string can assume
an INSERT operation, it is immediately parsed to extract the as-
signment nodes as shown before. Queries that contain a SELECT
statement are instead analyzed only when the analysis ﬁnds that the
corresponding mysql_fetch function is used to assign the result
values to one or more PHP variables.
Consider for instance the mysql_fetch_assoc call at line
16 of index.php of our sample application. Following the data-
ﬂow edges we reach the corresponding query string at line 12.
The dynamic analysis along the deterministic path reconstructs the
query "SELECT * FROM users". The database analyzer then
checks the database schema to resolve the "*" symbol to the corre-
sponding list of column names and it ﬁnally generates the resulting
assignments nodes:
$row["username"] = $DB_dbname_users_username;
$row["password"] = $DB_dbname_users_password;
Once these assignments are introduced to the module, the fol-
lowing analysis steps are able to treat the application state stored in
a back-end database and the state stored in program variables in a
uniform way.
4.3 Views Extraction
The goal of this step is to summarize a module into a set of
views. This is a key step in our intra-module analysis, because
it produces the module meta-information necessary to perform the
inter-module vulnerability analysis.
To extract a module’s views, we ﬁrst perform state analysis to
determine all statements in the control-ﬂow graph that are state-
related, i.e., that either contain state entities or are control- or data-
dependent on state-related statements. We consider state entities
of a PHP application the variables used to refer to request param-
eters (_GET, _POST, _REQUEST), cookies ( _COOKIE), ses-
sion variables (_SESSION), and the database variables generated
by the database analysis step. This allows us to exclude from fur-
ther analysis statements that do not depend on or modify the appli-
cation state. Therefore, in the rest of the analysis we consider only
the subgraph of the CFG that contains state-related nodes. The al-
gorithm we use in this step is based on the functional data-ﬂow
analysis framework of [19], as implemented in Pixy.
4.3.1
Identifying Sinks and State Entities
To identify sinks, we determine all nodes in the CFG that contain
an operation relevant to our analysis. In particular, we look for two
types of operations: state-related operations and sink-related op-
erations. State-related operations are those statements that modify
the server-side state. For example, we identify uses of the session
mechanism, that is, assignments to the _SESSION array or calls
to the session_register() function. Sink-related operations
are statements where state entities are used in sensitive sinks. Our
technique focuses on identifying inter-module XSS and SQL injec-
tion attacks, and, therefore, we keep track of state entities displayed
to the user or used in a database query. Consider, for example, the
create.php module in our example. The analysis identiﬁes two
relevant operations: at line 19, a database query is executed, and, at
line 21, the variable _SESSION["loggedin"] is modiﬁed.
After the relevant operations have been identiﬁed, we derive their
conditional guards, i.e., the conditions associated with the branches
in the CFG that must be taken in order to reach the statement as-
sociated with the operation. Note that we only keep track of state-
dependent conditions, as identiﬁed by the state analysis. In our ex-
ample, the two operations that we identiﬁed in create.php are
guarded by the conditional statement at line 9. The analysis also
recognizes that the true branch of the conditional must be taken to
trigger the operations.
Then, for each variable that occurs in a conditional guard or in
a state- or sink-related statement, we reconstruct its dependency
with respect to state entities. We currently model several types of
dependencies. In particular, propagation dependencies model the
assignment of one variable to another; call dependencies denote
the fact that a variable takes its value from the result of a func-
tion call (in particular, we currently model sanitization functions);
binary dependencies model the composition of two variables, for
The answer to Life, the
Universe, and Everything
Create a new user
Create User
index.php
The final answer is:
Homepage
answer.php
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
<?php
if (isset($_POST["user"])) {
$user = addslashes($_POST["user"]);
$pass = addslashes($_POST["pass"]);
session_start();
$sql = ’INSERT INTO users ’ .