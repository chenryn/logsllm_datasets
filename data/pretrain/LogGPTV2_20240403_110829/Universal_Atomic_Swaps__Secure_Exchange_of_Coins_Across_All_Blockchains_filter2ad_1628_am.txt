on the blockchain B.
,
for i ∈ [n] while party P1 starts computing ΠVTS.ForceOp
frz,˜n, σ(1)
tx (1)
, . . . ,
frz,˜n
frz,1
(cid:16)
(cid:16)
(cid:111)
1) Parties P0 and P1 generate swap locks by ﬁrst doing the following:
• Party P1 generates
• Party P1 generates tx (1)
swpd,i, sk (1)
swp,i := tx
pk (1)
swpd,i
pk (01)
i
for i ∈ [n] and sends it to party P0.
2) Then for each k ∈ ˜n the parties run an instance of the lock generation for a n-to-1 swap. The k-th instance is as follows.
(cid:16)
Swap Lock Phase - n-to-˜n swap
(cid:17) ← ΠDS.KGen(1λ) for i ∈ [n].
(cid:17)
(cid:17) ← ΠDS.KGen(1λ).
(cid:17)
(cid:16)
swpd,i, v(0)
, pk (1)
i
pk (0)
swpd,k, sk (0)
• Party P0 generates
• Party P0 goes on to generate tx (0)
swpd,k, v(1)
• Parties P0 and P1 run a 2PC protocol Γ3 to compute (cid:96)kk ← mLock
protocol does the following:
– Take as common input
swpd,k
swp,k := tx
(cid:18)(cid:110)
, pk (10)
, pk (0)
pk (10)
pk (01)
, c(01)
, c(10)
(cid:19)
(cid:111)
k
k
j
j∈[n]
k
k
(cid:19)
j
(cid:18)(cid:110)
(cid:16)
from party P0, and as private input
0,j , d(01)
0,j
sk (01)
party P1.
, sk (10)
0,k , d(10)
0,k
j∈[n]
– For all j ∈ [n], check whether sk (01)
– Check whether sk (10)
– For j ∈ [n], compute σ(1)
– Compute σ(0)
– Compute (cid:96)kk ← mLock
– The 2PC protocol Γ3 ﬁrst outputs (cid:96)kk to P1.
– If the above step is successful, Γ3 outputs σ(0)
(cid:17)
(cid:16)
0,j ⊕ d(01)
0,j ⊕ sk (01)
d(01)
1,j = ΠC.Open
(cid:17)
(cid:16)
0,k ⊕ d(10)
0,k ⊕ sk (10)
1,k , c(10)
d(10)
1,k = ΠC.Open
(cid:16)
(cid:17)
swp,j ← ΠDS.Sign
0,j ⊕ sk (01)
1,j , tx (1)
sk (01)
(cid:19)
(cid:18)
(cid:110)
(cid:111)
swp,k ← ΠDS.Sign
0,k ⊕ sk (10)
1,k , tx (0)
sk (10)
.
, σ(0)
n,
(cid:16)
σ(1)
swp,j
j∈[n]
(cid:17)
swp,k
swp,k
swp,j
.
k
3) In the end, party P0 obtains
σ(0)
swp,1, . . . , σ(0)
swp,˜n
swp,k to P0.
while party P1 obtains ((cid:96)k1, . . . , (cid:96)k˜n).
(cid:18)
(cid:110)
and sends it to party P1.
n,
σ(1)
swp,j
, σ(0)
swp,k
j∈[n]
(cid:19)
. More precisely, the 2PC
from the parties, and as private input
sk (01)
1,j , d(01)
1,j
, sk (10)
1,k , d(10)
1,k
j∈[n]
(cid:111)
(cid:19)
from
(cid:111)
(cid:18)(cid:110)
(cid:17)
1,j , c(01)
j
and abort otherwise.
and abort otherwise.
.
Fig. 15: Generic Atomic Swap protocol run between parties P0 and P1
29
0,j and sk (10)
as output from the freeze coin phases when we have the
adversary corrupting P0 (analogous case when P1 is corrupted).
Here sk (01)
0,j are the inputs of the adversary to the 2PC
protocol Γ3. The simulator extracts these inputs by interacting
with the ideal functionality of the 2PC protocol of Γ3. The
simulator uses S2pc,3 to simulate the 2PC of Γ3 with this new
check.
Hybrid H5: Is the same execution as H4, except now for all the
shares of the opening information that adversary receives in the
freeze coin phase are switched to random strings. Speciﬁcally,
d(01)A,i for all i ∈ [n] and d(10)A,j for all j ∈ [˜n] that the adversary
receives from the freeze coin are switched to random strings.
Hybrid H6: Is the same execution as H5, except now for all
for all j ∈ [˜n]
the commitments c(01)
that are generated by the freeze coin phase are replaced with
commitments to 0λ.
Hybrid H7: Is the same execution as H6, except now for all k ∈
[˜n] the lock (cid:96)kk is hardcoded in the simulation by hardcoding
swp,j for j ∈ [˜n] in
ﬁrst the signatures σ(1)
the simulation. Here σ(1)
swp,i under the
key pk (01)
swp,j under they key
pk (10)
Hybrid H8: Is the same execution as H7, except now for an
honest P1, if in some q8-th session, the adversary outputs σ∗
= 1 for some k ∈ [˜n],
such that ΠDS.Vf
and
S ← mRel
swp,i for i ∈ [n] and σ(0)
swp,i is a signature on tx (1)
swp,k, σ∗(cid:17)
for all i ∈ [n] and c(10)
swp,j is a signature on tx (0)
(cid:16)
(cid:110)
and σ(0)
pk (10)
, tx (0)
, tx (0)
(cid:18)
(cid:111)
(cid:111)
tx (1)
.
k
j
j
i
i
(cid:96)kk,
pk (01)
i∈[n]
swp,k,
swp,i
i∈[n]
, pk (10)
k
i∈[n]
. Parse
S :=
σ(1)
swp,1, . . . , σ(1)
swp,n
. And if there exists some j ∈ [n]
, tx (1)
pk (01)
ΠDS.Vf
j
(cid:16)
swp,j, σ(1)
swp,j
= 0
(cid:110)
(cid:111)
(cid:17)
, the simulation aborts by outputting a special symbol abort1.
This abort happens when the adversary outputs a valid signature
such that honest user P1 pays the adversary through tx (0)
swp,k but
is unable to complete the swap by computing a valid signature
on all the transactions
Hybrid H9: Is the same execution as H8 except now, if in
some q9-th session, before an honest P0 initiates the swap,
adversary A outputs a signature σ∗ such that for some i ∈ [n]
swp,1, . . . , tx (1)
(cid:111)
(cid:110)
tx (1)
swp,n
.
swp,i, σ∗(cid:17)
ΠDS.Vf
pk (01)
i
, tx (1)
= 1
the simulation aborts by outputting a special symbol abort2.
This abort happens when the adversary is able to release a lock
correctly before P0 initiates the swap process.
Hybrid H10: Is the same execution as H9 except now, if in
some session q10, the adversarial party (for example P0) posts
on chain before time T0 for any i ∈ [n], the
tx (0)
simulator aborts by outputting abort3. Analogous case when
rfnd,i, σ(0)
(cid:16)
(cid:17)
rfnd,i
30
(cid:110)
(cid:16)
(cid:17)
(cid:17)
(cid:16)
(cid:16)
tx (1)
rfnd,k, σ(1)
P1 is corrupt and it posts
time T1 for any k ∈ [˜n].
Hybrid H11: Is the same execution as H10 except now, if for
example P0 is corrupt and in some session q11 the simulator
for some i ∈ [˜n], and
obtains σ(1)
rfnd,i ← ΠVTS.ForceOp
on chain before
C (1)
(cid:16)
(cid:17)
rfnd,k
i
ΠDS.Vf
pk (10)
i
, tx (1)
rfnd,i, σ(1)
rfnd,i
= 0
functionality Fswap.
the execution in H11 while it
The
, the simulator aborts by outputting abort4. Analogous case
if P1 is corrupt.
Simulator S: The execution of the simulator is deﬁned
interacts with the
as
receives
ideal
simulator
(swap1, id, V, ˜V , PK, ˜PK, ˜SK, U1)
(swap2, id, V,
from Fswap.
˜V , PK, ˜PK, SK, U0)
It proceeds as in the
execution of H9 by simulating the view of the adversary
from the ideal
appropriately as
functionality Fswap. If the simulated view deviates from the
execution of the ideal functionality, we note that the simulation
must have already aborted (as discussed in cases of abort in
the above hybrids).
receives messages
and
it
(cid:19)
Below we discuss the indistinguishability arguments and
we use the notation ≈c,≈T to denote computational indistin-
guishability for a PPT algorithm, and indistinguishability for
depth T bounded algorithms, respectively.
H0 ≈c H1 and H1 ≈c H2 and H2 ≈c H3: the indistinguisha-
bility follow from the security of the 2PC protocols in the
freeze coin phase and in the swap lock phase. Security of the
2PC protocol for the derivation of keys guarantees the existence
of S2pc,1, the security of the 2PC protocol for the signature
generation guarantees the existence of S2pc,2, and the security
of the 2PC protocol for the lock generation algorithm, which
guarantees the existence of S2pc,3.
H3 ≡ H4: Notice that given the commitment scheme ΠC is