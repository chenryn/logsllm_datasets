# 09 \| 瞧一瞧Linux：Linux的自旋锁和信号量如何实现？你好，我是 LMOS。上节课，我们学习了解决数据同步问题的思路与方法。Linux作为成熟的操作系统内核，当然也有很多数据同步的机制，它也有原子变量、开启和关闭中断、自旋锁、信号量。那今天我们就来探讨一下这些机制在 Linux 中的实现。看看 Linux的实现和前面我们自己的实现有什么区别，以及 Linux为什么要这么实现，这么实现背后的机理是什么。Linux 的原子变量首先，我们一起来看看 Linux 下的原子变量的实现，在 Linux中，有许多共享的资源可能只是一个简单的整型数值。例如在文件描述符中，需要包含一个简单的计数器。这个计数器表示有多少个应用程序打开了文件。在文件系统的open 函数中，将这个计数器变量加 1；在 close 函数中，将这个计数器变量减1。 如果单个进程执行打开和关闭操作，那么这个计数器变量不会出现问题，但是Linux是支持多进程的系统，如果有多个进程同时打开或者关闭文件，那么就可能导致这个计数器变量多加或者少加，出现错误。为了避免这个问题，Linux提供了**一个原子类型变量atomic_t**。该变量的定义如下。    typedef struct {        int counter;    } atomic_t;//常用的32位的原子变量类型    #ifdef CONFIG_64BIT    typedef struct {        s64 counter;    } atomic64_t;//64位的原子变量类型    #endif上述代码自然不能用普通的代码去读写加减，而是要用 Linux专门提供的接口函数去操作，否则就不能保证原子性了，代码如下。    //原子读取变量中的值    static __always_inline int arch_atomic_read(const atomic_t *v)    {        return __READ_ONCE((v)->counter);    }    //原子写入一个具体的值    static __always_inline void arch_atomic_set(atomic_t *v, int i)    {        __WRITE_ONCE(v->counter, i);    }    //原子加上一个具体的值    static __always_inline void arch_atomic_add(int i, atomic_t *v)    {        asm volatile(LOCK_PREFIX "addl %1,%0"                 : "+m" (v->counter)                 : "ir" (i) : "memory");    }    //原子减去一个具体的值    static __always_inline void arch_atomic_sub(int i, atomic_t *v)    {        asm volatile(LOCK_PREFIX "subl %1,%0"                 : "+m" (v->counter)                 : "ir" (i) : "memory");    }    //原子加1    static __always_inline void arch_atomic_inc(atomic_t *v)    {        asm volatile(LOCK_PREFIX "incl %0"                 : "+m" (v->counter) :: "memory");    }    //原子减1    static __always_inline void arch_atomic_dec(atomic_t *v)    {        asm volatile(LOCK_PREFIX "decl %0"                 : "+m" (v->counter) :: "memory");    }Linux原子类型变量的操作函数有很多，这里我只是介绍了最基础的几个函数，其它的原子类型变量操作slate-object="inline"也依赖于上述几个基础的函数。你会发现，Linux 的实现也同样采用了 x86 CPU 的原子指令，LOCK_PREFIX是一个宏，根据需要展开成"lock;"或者空串。**单核心 CPU 是不需要 lock 前缀的，只要在多核心 CPU下才需要加上 lock 前缀。**剩下 \_\_READ_ONCE，\_\_WRITE_ONCE两个宏，我们来看看它们分别做了什么，如下所示。    #define __READ_ONCE(x)  \    (*(const volatile __unqual_scalar_typeof(x) *)&(x))    #define __WRITE_ONCE(x, val) \    do {*(volatile typeof(x) *)&(x) = (val);} while (0)    //__unqual_scalar_typeof表示声明一个非限定的标量类型，非标量类型保持不变。说人话就是返回x变量的类型，这是GCC的功能，typeof只是纯粹返回x的类型。    //如果 x 是int类型则返回“int”     #define __READ_ONCE(x)  \    (*(const volatile int *)&(x))    #define __WRITE_ONCE(x, val) \    do {*(volatile int *)&(x) = (val);} while (0) 结合刚才的代码，我给你做个解读。Linux 定义了\_\_READ_ONCE，\_\_WRITE_ONCE 这两个宏，是对代码封装并利用 GCC的特性对代码进行检查，把让错误显现在编译阶段。其中的"volatile int\*"是为了提醒编译器：**这是对内存地址读写，不要有优化动作，每次都必须强制写入内存或从内存读取。**Linux 控制中断Linux中有很多场景，需要在关中断下才可以安全执行一些操作。比如，多个中断处理程序需要访问一些共享数据，一个中断程序在访问数据时必须保证自身（中断嵌套）和其它中断处理程序互斥，否则就会出错。再比如，设备驱动程序在设置设备寄存器时，也必须让CPU 停止响应中断。Linux 控制 CPU响应中断的函数如下。    //实际保存eflags寄存器    extern __always_inline unsigned long native_save_fl(void){        unsigned long flags;        asm volatile("