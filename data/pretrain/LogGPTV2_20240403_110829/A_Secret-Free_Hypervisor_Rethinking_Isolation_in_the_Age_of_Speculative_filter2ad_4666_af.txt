以下是优化后的文本，使其更加清晰、连贯和专业：

---

**参考文献**

[1] 在《第14届入侵检测最新进展国际会议论文集》（RAID'11）中发表。柏林，海德堡：Springer-Verlag出版社，2011年，第121-141页。

[2] E. Zannoni, “通过Undefined-BehaviorSanitizer (UBSan) 和 GCC 改善应用程序安全”，2021年5月。

[3] H. Shacham, M. Page, B. Pfaff, E.-J. Goh, N. Modadugu, 以及 D. Boneh, “地址空间随机化的效果评估”，在《第11届ACM计算机与通信安全会议论文集》（CCS '04）中发表。纽约，美国：计算机械协会，2004年，第298-307页。[在线] 可用: https://doi.org/10.1145/1030083.1030124

[4] N. Nethercote 和 J. Seward, “Valgrind：一种重型动态二进制插桩框架”，SIGPLAN Not., 卷42, 期6, 第89-100页, 2007年6月。[在线] 可用: https://doi.org/10.1145/1273442.1250746

[5] B. Anderson, L. Bergstrom, D. Herman, J. Matthews, K. McAllister, M. Goregaokar, J. Moffitt, 以及 S. Sapin, “使用 Rust 开发 Servo Web 浏览器引擎的经验报告”，2015年。

[6] T. Anderson, “Linux 在 2020 年：内核中有 2780 万行代码，systemd 中有 130 万行代码”，2020年1月。[在线] 可用: https://www.theregister.com/2020/01/06/linux_2020_kernel_systemd_code

[7] “漏洞详情：CVE-2017-11176”，2017年7月。[在线] 可用: https://www.cvedetails.com/cve/CVE-2017-11176/

[8] “漏洞详情：CVE-2021-43267”，2021年11月。[在线] 可用: https://www.cvedetails.com/cve/CVE-2021-43267/

[9] “漏洞详情：CVE-2021-43057”，2021年10月。[在线] 可用: https://www.cvedetails.com/cve/CVE-2021-43057/

[10] “漏洞详情：CVE-2021-41073”，2021年9月。[在线] 可用: https://www.cvedetails.com/cve/CVE-2021-41073/

[11] P. Kocher, D. Genkin, D. Gruss, W. Haas, M. Hamburg, M. Lipp, S. Mangard, T. Prescher, M. Schwarz, 以及 Y. Yarom, “幽灵攻击：利用推测执行”，2018年。

[12] M. Lipp, M. Schwarz, D. Gruss, T. Prescher, W. Haas, A. Fogh, J. Horn, S. Mangard, P. Kocher, D. Genkin, Y. Yarom, 以及 M. Hamburg, “熔断：从用户空间读取内核内存”，在《第27届USENIX安全研讨会论文集》（SEC'18）中发表。美国：USENIX协会，2018年，第973-990页。

[13] “页面表隔离（PTI）”。[在线] 可用: https://www.kernel.org/doc/html/latest/x86/pti.html

[14] Intel Corporation, Intel® 64 和 IA-32 架构软件开发者手册（综合卷1, 2A, 2B, 2C, 2D, 3A, 3B, 3C, 3D, 4），2021年6月。

[15] L. Kurth, “Xen 4.13 的新特性”，2019年12月。[在线] 可用: https://xenproject.org/2019/12/18/whats-new-in-xen-4-13/

[16] N. Nethercote 和 J. Seward, “Retpoline：一种分支目标注入缓解技术”，第3期，2018年6月。

[17] M. Yan, J. Choi, D. Skarlatos, A. Morrison, C. Fletcher, 以及 J. Torrellas, “InvisiSpec：使推测执行在缓存层次结构中不可见”，在《2018年第51届IEEE/ACM国际微架构研讨会论文集》（MICRO 2018）中发表，2018年，第428-441页。

[18] K. N. Khasawneh, E. M. Koruyeh, C. Song, D. Evtyushkin, D. Ponomarev, 以及 N. Abu-Ghazaleh, “SafeSpec：通过无泄漏推测消除熔断的幽灵”，在《2019年第56届ACM/IEEE设计自动化会议论文集》（DAC 2019）中发表，2019年，第1-6页。

[19] E. M. Koruyeh, S. H. A. Shirazi, K. N. Khasawneh, C. Song, 以及 N. B. Abu-Ghazaleh, “SPECCFI：使用CFI知情推测缓解幽灵攻击”，CoRR, 卷abs/1906.01345, 2019年。[在线] 可用: http://arxiv.org/abs/1906.01345

[20] V. P. Kemerlis, G. Portokalidis, 以及 A. D. Keromytis, “kGuard：轻量级内核保护抵御返回到用户攻击”，在《第21届USENIX安全研讨会论文集》（USENIX Security 12）中发表。华盛顿州贝尔维尤：USENIX协会，2012年8月，第459-474页。[在线] 可用: https://www.usenix.org/conference/usenixsecurity12/technical-sessions/presentation/kemerlis

[21] V. P. Kemerlis, M. Polychronakis, 以及 A. D. Keromytis, “ret2dir：重新思考内核隔离”，在《第23届USENIX安全研讨会论文集》（USENIX Security 14）中发表。加利福尼亚州圣迭戈：USENIX协会，2014年8月，第957-972页。[在线] 可用: https://www.usenix.org/conference/usenixsecurity14/technical-sessions/presentation/kemerlis

[22] D. Seal, ARM 架构参考手册，第2版。美国：Addison-Wesley Longman 出版公司，2000年。

[23] J. V. Bulck, M. Minkin, O. Weisse, D. Genkin, B. Kasikci, F. Piessens, M. Silberstein, T. F. Wenisch, Y. Yarom, 以及 R. Strackx, “Foreshadow：通过瞬态乱序执行提取Intel SGX王国的密钥”，在《第27届USENIX安全研讨会论文集》（USENIX Security 18）中发表。马里兰州巴尔的摩：USENIX协会，2018年8月，第991-1008页。[在线] 可用: https://www.usenix.org/conference/usenixsecurity18/presentation/bulck

[24] S. van Schaik, A. Milburn, S. Österlund, P. Frigo, G. Maisuradze, K. Razavi, H. Bos, 以及 C. Giuffrida, “RIDL：飞行数据加载”，在《S&P》，2019年5月。

[25] H. Ragab, A. Milburn, K. Razavi, H. Bos, 以及 C. Giuffrida, “CrossTalk：跨核心的推测性数据泄露是真实的”。美国：电气和电子工程师协会，2021年6月，第1-16页。

[26] “Hyper-V 超清缓解措施针对 L1 终端故障”，2019年3月。[在线] 可用: https://techcommunity.microsoft.com/t5/virtualization/hyper-v-hyperclear-mitigation-for-l1-terminal-fault/ba-p/382429

[27] G. Marsden, “通过地址空间隔离（ASI）提高安全性”，2019年7月。[在线] 可用: https://blogs.oracle.com/linux/post/improve-security-with-address-space-isolation-asi

[28] X. J. Ren, K. Rodrigues, L. Chen, C. Vega, M. Stumm, 以及 D. Yuan, “对 Linux 核心操作性能演化的分析”，在《第27届ACM操作系统原理研讨会论文集》（SOSP '19）中发表。纽约，美国：计算机械协会，2019年，第554-569页。[在线] 可用: https://doi.org/10.1145/3341301.3359640

授权许可使用仅限于：清华大学。下载时间：2022年8月7日UTC 13:11:47 从 IEEE Xplore。适用限制。

[29] “Dom0”，2015年3月。[在线] 可用: https://wiki.xenproject.org/wiki/Dom0

[30] J. Corbet, “虚拟映射内核堆栈”，2016年6月。[在线] 可用: https://lwn.net/Articles/692208/

[31] B. Armstrong, “Windows Server 中 Hyper-V 扩展性计划”，2021年11月。[在线] 可用: https://docs.microsoft.com/en-us/windows-server/virtualization/hyper-v/plan/plan-hyper-v-scalability-in-windows-server

[32] “VMware vSphere ESX 和 vCenter 配置最大值”。[在线] 可用: https://www.virten.net/vmware/vmware-vsphere-esx-and-vcenter-configuration-maximums/

[33] “配置限制”，2020年12月。[在线] 可用: https://docs.citrix.com/en-us/xenserver/7-1/system-requirements/configuration-limits.html

[34] AMD, AMD64 架构程序员手册 第2卷：系统编程，2021年3月。

[35] S.-W. Li, J. S. Koh, 以及 J. Nieh, “保护云虚拟机免受管理程序和主机操作系统漏洞的攻击”，在《第28届USENIX安全研讨会论文集》（USENIX Security 19）中发表。加利福尼亚州圣克拉拉：USENIX协会，2019年8月，第1357-1374页。[在线] 可用: https://www.usenix.org/conference/usenixsecurity19/presentation/li-shih-wei

**附录**

我们首先列举了SF如何阻止各种类别的推测性漏洞的例子，并将其与最先进的缓解措施进行了比较。然后，我们展示了自映射技术如何允许在不手动遍历页表的情况下访问页表项（PTEs）。

**A. 客户机到管理程序的攻击**

此类别通过进入被推测性操纵的管理程序上下文来揭示秘密。

1) **幽灵攻击**：考虑以下管理程序代码片段。
   ```c
   if (x > (BITS_PER_LONG - 1)) {
       // 插入 SELF_OFFSET 到 L4 位
       ret[47:39] = L4_SELF_OFFSET;
       return ret;
   }
   ```
   该函数在索引大于12时生成一个~0掩码。`L1_PTE_from_VA()` 返回给定虚拟地址（VA to page）的L1 PTE指针（表示为VA to L1 PTE）。这通过要求硬件页表遍历两次L4表来实现，最终访问终止于页表页内的L1 PTE而不是实际物理内存。请注意，这也可以更改为访问L2 PTE，通过将给定的VA进一步右移并将SELF_OFFSET插入L3偏移位，从而有效地要求硬件遍历三次L4表，最后终止于L2 PTE。

   自映射用于启用临时映射基础设施。当新的物理地址映射请求到来时，分配一个临时虚拟地址（VA），并通过 `L1_PTE_from_VA()` 找到其L1 PTE。修改PTE以指向请求的物理地址，此时VA即可使用。在无秘密管理程序下使用此技术进行临时映射的原因不仅在于效率，还因为直接映射不再存在，无法通过正常的手动页表遍历来操作临时映射区域中的PTE。

2) **客户机到客户机的幽灵攻击和L1TF**：这一类别并未由SF地址空间缓解。来自不同域的两个vCPU可能会在同一主机CPU上调度，共享微架构结构，包括分支预测器和缓存。攻击者可能操纵微架构状态以影响推测路径，从而使秘密通过隐蔽通道传递。如果不隔离底层硬件，则无法防止这种直接的客户机到客户机攻击。因此，本工作重用了几种物理隔离技术，主要是核心调度，以禁止不同域共享物理CPU，从而缓解此类攻击。

如前所述，在无秘密设计下，物理隔离更为简单，因为其实现不再需要防范来自管理程序的泄露。

**C. 页表自映射**

管理程序和操作系统内核通常会执行手动页表遍历来定位和操作页表项以修改地址空间。当存在直接映射时，可以高效地完成此操作，因为任何任意物理地址都存在直接映射别名，允许我们在解码Ln级别的PTE所指向的物理地址后快速访问L(n-1)页表页。然而，内核代码通常采用自映射来完全避免手动页表遍历，通过保留一个顶级PTE指向顶级表本身，然后通过位变换直接访问PTE。

图12给出了一个示例。这里假设48位虚拟地址空间下的四级分页和4KiB页面。指针由四个9位页表页偏移和一个12位页偏移组成。通过在顶级保留一个PTE并指向自身，可以进行固定的变换。

```c
uintptr_t L1_PTE_from_VA(uintptr_t va) {
    // 将 SELF_OFFSET 插入 L4 位
    ret[47:39] = L4_SELF_OFFSET;
    return ret;
}
```

该函数返回给定虚拟地址（VA to page）的L1 PTE指针（表示为VA to L1 PTE）。这通过要求硬件页表遍历两次L4表来实现，最终访问终止于页表页内的L1 PTE而不是实际物理内存。请注意，这也可以更改为访问L2 PTE，通过将给定的VA进一步右移并将SELF_OFFSET插入L3偏移位，从而有效地要求硬件遍历三次L4表，最后终止于L2 PTE。

---

希望这些改进能够使您的文本更加清晰、连贯和专业。如果还有其他需要，请告诉我！