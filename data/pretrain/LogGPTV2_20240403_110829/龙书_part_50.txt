L→*·R
S→L=RIo:
白
江
以
14:
5
河河
5
I, 中的 S->R·
I中的S'→S·
出：
L →id·
L→*R
↑S
L→
=S
S'→S.
S→·R, # 
S-→·L= R,#
S'→→·S,#
中的S→L·
T
*R
L=·R
=R
I: S'→s.
Io: S'→·S 
项集
S→L=R.
7H
L→*R.
S→L=·R
L → id.
L→*R
R→L.
H=·TtS
项
图4-47向前看符号的计算
1中的R-→L·
G
R→→·L，#
中的L→id·
L→·*R，#/ =
→·id，#/ =
初始值第一趟第二趟第三趟
I
=/$
=/$
1!
向前看符号
#
#
的
=/$
A
的
175
---
## Page 192
（any，r4）。状态5、10 和 11 也可以做类似处理。状态8 的列表是
归约。因此状态2 的列表是
以用下面的列表来表示它们：
例4.65
下一个移人动作之前发现错误。
一致，我们可以把报错条目安全地替换为规约动作。对错误的检测会稍有延后，但仍可以在执行
输
我
这个列表由(终结符号，动作)对组成。一个状态的最频繁的动作可以放在列表的结尾处，并且
之后的第i个位置上找到。
始的偏移量。在---个给定的状态中，第i个终结符号对应的语法分析动作可以在该状态的指针值
号,编号范围为从零开始到终结符号总数减一。对于每个状态，这个整数编号将作为从指针值开
作的状态的指针指向相同的位置。为了从这个数组获取信息，我们给各个终结符号赋予--个编
一个指向一维数组的指针，我们就可以节省可观的空间，而付出的时间代价却很小。具有相同动
442中的状态0和3就有相同的动作条目，状态2和6 也是这样。因此,如果我们为每个状态创建
将简短地描述一些可以用于压缩 LR 语法分析表中的 ACTION 字段和 GOTO 字段的技术。
二进制位进行编码。对于小型设备，有一个比二维数组更加高效的编码方法是很重要的。我们
4.7.6LR语法分析表的压缩
$，因此两者之间不再有冲突。
虽然I中的S-→L·=R生成了在输人=上的移人动作，但是I中 R→L·的向前看符号只包括
前人，那么不管这个输人是什么，我们都选择这个动作。不仅如此，为了使得一行中的内容更加
们可以在这个对中原本放终结符号的地方放上符号“any”，表示如果没有在列表中找到当前
如果为每个状态创建一个动作列表，我们可以获得更高的空间效率，但语法分析器会变慢。
状态3只有报错和r4 条目。我们可以把前者替换为后者，因此状态3的列表只有一个对
在状态2中，我们可以把报错条目替换为r2，因此对于除＊之外的输人都按照产生式2 进行
一个可用于压缩动作字段的技术所基于的原理是动作表中通常有很多相同的行。比如，图
--个典型的具有 50～100个终结符号和100个产生式的程序设计语言文法的 LALR 语法分析
请注意,在例4-48中，使用 SLR 方法时发现的移入/归约冲突在使用LALR技术时消失了。
176
状态1有--个类似的列表：
考虑图 4-37的语法分析表。首先，请注意状态0、4、6和7的动作是相同的。我们可
any
any
any
）郎
符号
+
any
$
+
erro
动作
2
acc
error
$
第4章
---
## Page 193
出它的LALR 项集族。
4.7.74.7节的练习
节中讨论的用于有穷自动机的表压缩方法也可以用来表示 LR 语法分析表。
指针，它们需要的空间和图4-37中的矩阵实现方法相比，并没有令人印象深刻的空间节省效果。
创建的列表中的条目数量，再加上从状态到动作列表的指针以及从非终结符号到后继状态表的
们可以为E列创建如下列表
的要么是3 要么报错。我们可以用3来替换报错条目，为F列创建列表
例4.66
每一列的列表中，它被表示为一个“当前状态”字段为 any 的对。
此,我们可以把每个报错条目替换为该列中最常用的非报错条目。这个条目变成了默认选择。
此，每个状态最多只出现在GOTO表的一列中。
号 A上的 GOTO 目标状态的项集中必然存在某些项,这些项中A 紧靠在点的左边。对于任意两个
一个数对的列表。A的列表中的每个对形如（当前状态，下一状态)，表示
是对于现实中的文法，列表表示法所需要的空间通常比矩阵表示法所需空间少10%。在3.9. 
同的文法符号X、Y，没有哪个 GOTO目标项集既有点左边为X的项，又有点左边为Y的项。
语法分析
！练习4.7.3:对练习 4.7.1 的文法，使用算法4.63，根据该文法的 LR(0)项集的内核构造
这些小例子中体现出来的空间节省效果可能具有误导性。因为在这个例子和前一个例子中
对于E列，我们可以选择1或8作为默认选择。这两种选择都需要两个列表条目。比如，我
！练习4.7.4：说明下面的文法
练习4.7.2：对练习4.2.2(1）～（7)的各个(增广)文法重复练习4.7.1。
2）LALR 项集族。
练习 4.7.1：为练习 4.2.1 的文法 S→S S+丨S S＊丨α 构造
类似地，T列的列表可以是
为了进一步减少使用的空间，我们注意到 GOTO 表中的报错条目从来都不会被查询到。
1）规范 LR 项集族。
这个技术很有用，因为GOTO表的－-列中常常只有很少几个状态。原因是对于某个非终结符
我们也可以把GOTO表编码为一个列表，但这里更加高效的方法是为每个非终结符号A 构造
而状态 9 的列表是
再次考虑图4-37。F对应的列中与状态7对应的条目是10，所有其他的条目所对应
GOTO[当前状态，A]=下一状态
A-→d
Ｓ-→Aａi bＡcldclbda
当前状态 
any
7
 any
any
any
9
下一状态
2
6
3
0
177
口
在
因
因
8
口
---
## Page 194
生了这样的冲突。假设我们使用 SLR 方法
作冲突。对应于项集I, 和 Ig 的两个状态就产
项集生成一个 LR 语法分析表时会出现分析动
为文法(4.3)是二义性的，在我们试图用这
法(4.3)的 LR(0)项集显示在图4-48中。因
非终结符号的产生式)的归约上。
在对这些单产生式(即产生式体中只包含-
义性文法(4.3)的语法分析器不会把时间浪
产生式的功能就是保证结合性和优先级。
时间用于归约产生式E-→T 和 T→F。这
二，相应无二义性文法的语法分析器将把部分
这个二义性文法。第一，我们将会看到的，可
都是左结合的。出于两个原因,我们愿意使用
这个文法是二义性的，因为它没有指明运算符+和＊的优先级和结合性。无二义性的文法(4.1)(包
4.8.1用优先级和结合性解决冲突
以很容易地改变运算符＋和＊的优先级和结
文法：
出遵循这个二义性解决方法的LR 语法分析器。我们强调应该保守地使用
新的产生式来描述特殊情况的构造。
4.8使用二义性文法
合
在
性
是 LR(1)的，但不是 LALR(1)的。
是 LALR(1)的，但不是SLR(1)的。
不
需要改变相应语法分析器的状态数目。
性，既不需要修改文法(4.3)的产生式，
产生式E-→E+T和 T→T*F)生成同样的语言，但是指定+的优先级低于*，并且两个运算符
主严格控制之下使用，否则无法保证一个语法分析器识别的到底是什么样的语言。
子只有一棵语法分析树。通过这个方法，语言的规约在整体上是无二义性的，有时还可以构造
经常出现的语法构造，以对其进行特殊的优化。使用二义性文法，我们可以向文法中精心加人
主文法能提供比任何等价的无二义性文法更短、更自然的规约。二义性文法的另一个用途是隔
，某些类型的二义性文法在语言的规约和实现中很有用。对于像表达式这样的语言构造，二）
使用 E'→E 增广之后的二义性表达式文
考虑带有运算符+和＊的有二义性的表达式文法(4.3)。为方便起见，这里再次给出此
虽然使用的文法是二义性的，但我们在所有的情况下都会给出消除二义性的规则，使得每个
178
实际上,每个二义性文法都不是LR的，因此它们不在前面两节讨论的任何文法类之内。
！练习4.7.5：说明下面的文法
E-→E +EIE* El(E)丨 id
B--→d
S→AαbＡcI Bcb Bα 
A-→d
两
来