图21-26 查看变量值
这里有一个关键的地方，就是调用MainActivity的getTableFromPic方法，获取一个String字符串，从变量的值来看，貌似不是规则的字符串内容，这里先不用管了，继续往下走，如下所示。
这里又遇到一个重要的方法getPwdFromPic，如图21-27所示，从字面意义上看，应该是获取正确的密码，用于后面的密码字符串比对。
图21-27 查看密码内容
查看一下密码的内容，貌似也是一个不规则的字符串，但是可以看到和上面获取的table字符串内容格式很像，接着往下走。这里还有一个信息就是调用了系统的Log打印，log的tag就是v6保存的值lil，如下所示：
这时候看到v3是保存的输入密码，这里使用utf-8获取它的字节数组，然后传递给access$0方法：
使用F5进入这个方法：
在这个方法中，还有一个bytesToAliSmsCode方法，使用F5进入：
这个方法其实看上去还是很简单的，就是把传递进来的字节数组循环遍历，取出字节值，然后转化成int类型，再调用上面获取到的table字符串的chatAt来获取指定的字符，使用StringBuilder进行拼接，然后返回即可，如图21-28所示。
图21-28 加密之后的内容
按F7跳出，查看，返回来加密的内容是“日日日日”，如图21-29所示，也就是说gggg=>日日日日。
最后再往下走，可以看到进行代码比对的工作了。
图21-29 代码比对方法
上面就分析完了所有的代码逻辑，还不算复杂，来梳理一下流程：
1）调用MainActivity中的getTableFromPic方法，获取一个table字符串。
可以进入看看这个方法的实现：
这里可以大体了解了，它是读取asset目录下的一个logo.png图片，然后获取图片的字节码再进行操作，得到一个字符串，那么从上面的分析可以知道，其实这里的table字符串类似于一个密钥库。
2）通过MainActivity中的getPwdFromPic方法获取正确的密码内容。
3）获取输入内容的utf-8的字节码，然后调用access$0方法，获取加密之后的内容。
4）access$0方法中调用bytesToAliSmsCode方法，获取加密之后的内容。
这个方法是最核心的，通过分析知道，通过传递进来的字节数组，循环遍历数组，拿到字节转化成int类型，然后再调用密钥库字符串table的charAt得到字符，使用StringBuilder进行拼接。通过上面的分析之后，知道获取加密之后的输入内容和正确的密码内容做比较，那么现在有的资源是：密钥库字符串和正确的加密之后的密码，以及加密的逻辑。
那么破解思路就有了，相当于，知道了密钥库字符串，也知道了加密之后的字符组成的字符串，那么可以通过遍历加密之后的字符串，循环遍历，获取字符，然后再去密钥库找到指定的index，然后再转成byte，保存到字节数组，然后用utf-8获取一个字符串，那么这个字符串就是想要的密码。
下面就用代码来实现这个功能：
代码中的函数相当于上面加密函数的bytesToAliSmsCode的反向实现，运行结果如图21-30所示。
图21-30 破解结果
得到了正确的密码，下面来验证一下，如图21-31所示。
图21-31 验证结果
破解成功。
补充：刚刚在断点调试的时候，看到了代码中用了Log来打印日志，tag是lil，那么可以打印这个log看看结果，如下所示：
这里table是密钥库，pw是正确的加密之后的密码，enPassword是输入之后加密的密码。通过这个例子可以知道，在破解apk的时候，日志也是一个非常重要的信息。
提示：资料下载地址为http://download.csdn.net/detail/jiangwei0910410003/9526113。
21.3 本章小结
本章介绍了如何使用Eclipse动态调试反编译之后的smali源码，这种方式比静态方式高效很多，但是现在市场上的大部分应用没有这么简单就破解了，比如核心的加密算法放到了native层去做，那么这时候就需要去动态调试so文件，这是下一章的内容。
第22章 IDA工具调试so源码
本章继续介绍逆向apk的相关知识，主要介绍如何使用IDA来调试Android中的native源码，因为现在有一些App，为了安全或者效率问题，会把一些重要的功能放到native层，那么用Eclipse调试smali源码就显得很无力了，因为Android中native层使用的是so库文件，所以本章介绍如何调试so文件的内容，从而提高破解成功率。
22.1 IDA中的常用快捷键
前一章中使用IDA工具静态分析so文件，通过分析ARM指令，来获取破解信息，比如用打印的log信息来破解apk。那时候就已经介绍了如何使用IDA工具，如图22-1所示。
图22-1 IDA工具的窗口视图
IDA工具有多个窗口，也有多个视图，用到最多的如下所示：
·Function Window对应so函数区域：在这里可以使用ctrl+f进行函数的搜索。
·IDA View对应so中代码指令视图：在这里可以查看具体函数对应的ARM指令代码。
·Hex View对应so的十六进制数据视图：在这里可以查看ARM指令对应的数据等。
下面先介绍IDA中一些常用的快捷键。
1.ARM指令转化成C语言快捷键
强大的F5快捷键可以将ARM指令转化成可读的C语言，能帮助分析，如下所示：
首先选中需要翻译成C语言的函数，然后按下F5，如下所示：
下面还需要做一步，就是还原JNI函数方法名。一般JNI函数方法名是一个指针加上一个数字，比如v3+676。然后将这个地址作为一个方法指针进行方法调用，并且第一个参数就是指针自己，比如（v3+676）（v3…）。这实际上就是在JNI里经常用到的JNIEnv方法。因为IDA并不会自动对这些方法进行识别，所以当对so文件进行调试的时候经常会见到却搞不清楚这个函数究竟在干什么，因为这个函数实在是太抽象了。解决方法非常简单，只需要对JNIEnv指针做一个类型转换即可。比如说上面提到a1和v4指针，如下所示：
可以选中a1变量，然后按一下y键，如图22-2所示。
图22-2 选中变量
然后将类型声明为JNIEnv*，如图22-3所示。
图22-3 设置JNIEnv*指针
确定之后再来看，如下所示：
修改之后是不是瞬间清晰了很多。另外还总结了所有JNIEnv方法对应的数字、地址以及方法声明，如下所示：
2.打开字符串内容窗口快捷键
用Shirt+F12快捷键快速打开so中所有的字符串内容窗口，如图22-4所示。
图22-4 so中字符串内容窗口
有时候，字符串是一个非常重要的信息，特别是对于破解的时候，可能就是密码，或者是密码库信息。
3.定位so中段地址快捷键
Ctrl+S快捷键有两个用途，在正常打开so文件的IDA View视图的时候，可以查看so对应的段信息，如图22-5所示。
图22-5 打开so中的段信息
可以快速得到一个段的开始位置和结束位置，不过这个位置是相对位置，不是so映射到内存之后的位置，关于so中的段信息，已经在前面章节中详细介绍。
当在调试页面的时候，用Ctrl+S键可以快速定位到想要调试的so文件映射到内存的地址，如图22-6所示。
图22-6 定位调试的so文件的内存地址
一般一个程序肯定会包含多个so文件，比如系统的so文件就有好多，一般都是在/system/lib下面，当然也有自己的so，这里可看到开始位置和结束位置就是这个so文件映射到内存中，如下所示：
这里可以使用cat命令查看一个进程的内存映射信息：
看到映射信息中有多个so文件，其实这不是多个so文件，而是so文件中对应的不同Segement信息被映射到内存中的，一般是代码段、数据段等，因为需要调试代码，所以只关心代码段。代码段有一个特点就是具有执行权限x，只需要找到权限中有x的那段数据即可。
4.跳转到指定地址快捷键
在IDA调试页面的时候，可以使用G键快速跳转到指定的内存位置，如图22-7所示。
图22-7 跳转到指定内存位置
这里的跳转地址是可以算出来的。比如现在想跳转到A函数，然后下断点，那么可以使用上面说到的Ctrl+S查找到so文件的内存开始的基地址，然后再用IDA View中查看A函数对应的相对地址，相加就是绝对地址，然后跳转到即可，比如这里的：Java_cn_wjdiankong_encryptdemo_MainActivity_isEquals函数的IDA View中的相对地址是（也就是so文件的地址）E9C，如下所示：
上面看到so文件映射到内存的基地址为74FE4000，如下所示：
那么跳转地址就是74FE4000+E9C=74FE4E9C。
注意，只要程序没有退出，一般这里的基地址在运行中的值就不会变，因为程序的数据已经加载到内存中了。同时相对地址是永远不会变的，只有在修改so文件的时候，文件的大小改变了，可能相对地址会改变，其他情况下不会改变，相对地址就是数据在整个so文件中的位置。这里可以看到函数映射到内存中的绝对地址，如下所示：
有时候发现跳转到指定位置之后，看到的全是DCB数据，这时候选择函数地址，点击P键就可以看到ARM指令源码了，如下所示：
5.调试快捷键
调试快捷键包括：F8单步调试，F7单步进入调试，如下所示：
上面找到函数地址之后，可以下断点了，下断点很简单，点击签名的绿色圈点，变成红色条目即可，然后可以点击F9快捷键，或者点击运行按钮（绿色右箭头），即可运行程序，如图22-8所示。
图22-8 F9快捷键
其中还有暂停和结束按钮。运行之后再点击so的native函数，触发断点逻辑，如下所示：
这时候，看到进入调试界面，点击F8可以单步调试，看到有一个PC指示器。其实在ARM中PC是一个特殊的寄存器，用来存储当前指令的地址。
总结一下IDA在调试so文件的时候需要用到的快捷键：
·Shift+F12 快速查看so文件中的字符串信息。
·F5 可以将ARM指令转化成可读的C代码，同时可以使用Y键，修改JNIEnv的函数方法名。
·Ctrl+S 有两个用途，在IDA View页面中可以查看so文件的所有段信息，在调试页面可以查看程序所有so文件映射到内存的基地址。
·G 可以在调试界面快速跳转到指定的绝对地址，进行下断点调试。如果跳转到目的地址之后，发现是DCB数据的话，可以使用P键进行转化。
·F7 可以单步进入调试，F8键可以单步调试。
22.2 构造so案例
了解IDA工具之后，就可以开始动手操作了。为了方便开始，先自己写一个简单的Android native层代码，然后用IDA进行分析即可。这里可以使用Android Studio新建一个简单工程，然后创建JNI。如何在Android Studio中开发NDK，前面章节中已经详细介绍了。下面直接在Android Studio中新建了一个Native项目，这里关于native项目的代码不想解释太多，就是Java层传递了用户输入的密码，然后native做了校验过程，把校验结果返回到Java层。如下所示：
具体的校验过程这里不再解释了。运行项目之后得到apk文件，那么下面就开始破解旅程了。
22.3 逆向so文件
下面开始破解编译之后的apk文件。
22.3.1 获取应用的so文件
按照国际惯例，直接使用解压软件，获取应用apk中的so文件，如图22-9所示。
图22-9 解压so文件
得到libencrypt.so文件之后，使用IDA打开它，如图22-10所示。
一般so中的函数方法名都是：Java_类名_方法名。那么这里直接搜Java关键字即可，或者使用jd-gui工具找到指定的native方法，如图22-11所示。
图22-10 IDA打开so文件
图22-11 native函数名
双击即可在右边的IDA View页面中看到Java_cn_wjdiankong_encryptdemo_MainActivity_isEquals函数的指令代码，如图22-12所示。
可以简单分析一下这段指令代码：
·PUSH{r3-r7，lr}是保存r3，r4，r5，r6，r7，lr的值到内存的栈中，那么最后当执行完某操作后，想返回到lr指向的地方执行，当然要给pc了，因为pc保留下一条CPU即将执行的指令，只有给了pc，下一条指令才会执行到lr指向的地方。
·pc：程序寄存器，保留下一条CPU即将执行的指令。
·lr：连接返回寄存器，保留函数返回后，下一条应执行的指令。
图22-12 函数对应的ARM指令代码
这个和函数最后面的POP{r3-r7，pc}是相对应的。