the router’s local memory implies that the previous packet was suc-
cessfully received and acknowledged. In other words, the receiver
and the sender collaboratively acknowledge to the router that the
Random Value and the packet therein were successfully received.
This architecture addresses the minimal trust since a strawman
router is only required to trust itself. Our strawman design also ad-
dresses the asymmetry of Internet path since our strawman router
does not require upstream packets or acknowledgment packets to
traverse the same strawman router that the downstream packets tra-
versed. Our CRAFT protocol preserves these properties.
2.1 Strawman Design
2.2 CRAFT
The TCP congestion control assumes that a pair of sender and re-
ceiver would behave in a manner speciﬁed in the protocol; specif-
ically, the receiver honestly acknowledges receiving a packet and
the sender increases the rate of the ﬂow as speciﬁed by TCP upon
receiving that acknowledgement. However, in an adversarial envi-
ronment, a sender can arbitrarily increase its rate without having
received any acknowledgments. Furthermore, a receiver can send
acknowledgments without actually having received a packet [10]
since TCP acknowledgments are not cryptographically dependent
on the data in the TCP packet. Our strawman design illustrates how
we can prevent a TCP ﬂow from misbehaving.
Intuition. The main objective of our strawman design is to ensure
that a downstream packet is indeed received by the receiver and
the acknowledgment is indeed received by the sender. A strawman
router can generate a Random Value for each packet to verify that
the receiver has received a downstream packet, that the receiver has
sent the Random Value back to the sender in its acknowledgment
packet, and that the sender has received that acknowledgment.
When the strawman router sees a downstream packet, it inserts
a Random Value into the packet, routes the packet to the receiver,
and stores the Random Value and its associated ﬂow in the router’s
memory. The receiver, upon receiving the packet, sends the Ran-
Since a strawman router needs to maintain a Random Value for
each outstanding packet, the required memory space of a straw-
man router can be huge with a large number of outstanding packets.
CRAFT relaxes this limitation to efﬁciently emulate the TCP state
of each ﬂow in the real Internet environment. We do not focus on
compliance of any particular TCP variant, but instead, on providing
techniques to efﬁciently handle reordering and loss as speciﬁed by
the standard document [1]. Since we design CRAFT without any
speciﬁc TCP variants in mind, CRAFT emulates the congestion
window (cwnd) of a ﬂow using the maximum allowed cwnd based
on the standard. Usually, TCP variants differ only in the manage-
ment of cwnd in response to packet losses. Thus, by properly mod-
ifying our proposed techniques in emulating the cwnd, CRAFT can
be readily adapted for speciﬁc subsets of most TCP variants.
The overview of CRAFT operation is illustrated in Figure 2. Due
to space constraint, we focus on how we conserve the memory of
router while keeping security. We brieﬂy sketch how to calculate
the cwnd for a ﬂow and how to handle packet loss and reordering.
The inefﬁcient use of memory space in our strawman design re-
sults from the fact that a Random Value inserted into a packet cor-
responds to only a single packet and the Random Value for each
outstanding packet should be stored for veriﬁcation. We thus let a
706Lid
Lrandom
Lid
Lrandom
Packet ID Random Value
ACK ID
Capability
Key
Packet ID Random Value
For all outstanding packets
(a) Strawman design
(b) CRAFT
Figure 3: Comparison of router memory usage between straw-
man design and CRAFT for a ﬂow: Lid and Lrandom are refer-
ence length for comparison
CRAFT router insert into each packet a secret pre-capability, which
is calculated using the Packet ID. We then deﬁne the capability of a
ﬂow to be an aggregate of all the past pre-capabilities inserted into
its packets.
Since the pre-capability of a packet is calculated using its Packet
ID, a CRAFT router does not need to store all prior pre-capabilities
issued to a ﬂow, thereby conserving the limited memory space of a
router. However, CRAFT needs to provide unpredictability for pre-
capability and capability as Random Value does. CRAFT provides
unpredictability by utilizing computationally efﬁcient keyed MAC
(Message Authentication Code). A CRAFT router uses its secret
key K and a cryptographically secure hash function g to derive a
pre-capability Pf,i: Pf,i = g(K, f, i), where f is the ﬂow ID, and
i is the Packet ID. Flow ID is a large and unique value randomly
generated by the router when the ﬂow is created.
We further elaborate on the g function with a telescoping con-
struction: g(K, f, i) = EK (f ||i) ⊕ EK (f ||i + 1) where EK rep-
resents a computationally efﬁcient keyed MAC such as HMAC [8]
and || is the concatenation operator. The telescoping construction
enables the CRAFT router to calculate a capability corresponding
to a set of contiguous pre-capabilities in constant time. If EK is
a hash function in a Random Oracle Model [2], then EK (f ||i) is
indistinguishable from a random number because the pair (f, i) has
not been seen before. Since K is known only to the CRAFT router,
it is computationally inefﬁcient to guess EK (f ||i). Moreover, Pf,i
is also indistinguishable from a random number.
When the receiver receives a packet (j) with a pre-capability
(Pf,j ), the receiver constructs the capability (Cf,j ) associated with
the packet. A capability (Cf,j ) is deﬁned to be the exclusive-or of
all received pre-capabilities up to j: Cf,j = Pf,0 ⊕ . . . ⊕ Pf,j .
By using the exclusive-or function, we can take advantage of a de-
sirable property: if any input and its distribution are unknown, the
output is uniformly distributed over the domain, yielding the largest
uncertainty and secrecy in the information theoretic sense. More-
over, since Pf,j = EK (f ||j) ⊕ EK (f ||j + 1), the capability can
be calculated efﬁciently using Cf,j = EK (f ||0) ⊕ EK (f ||j + 1).
Hence, we need only a single xor operation to calculate the capa-
bility associated with a set of contiguous pre-capabilities.
In the above example, capability Cf,j proves that all packets
from Packet ID 0 to j are received by a receiver. This capability
and j are delivered to the sender and are used to prove the receipt of
packets to the CRAFT router. We call j as ACK ID. When CRAFT
router receives Cf,j and j, it veriﬁes the received capability. If the
received capability is valid, CRAFT router increases the cwnd for
the corresponding ﬂow following the TCP standard.
Our construction of pre-capability and capability eliminates the
need to store a Random Value for each outstanding packet. As
shown in Figure 3(b), the router only needs ﬁxed size of space.
When a network experiences congestion, a pre-capability may be
lost. Then, a contiguous capability Cf,j = Pf,0 ⊕. . .⊕Pf,j cannot
be constructed. To handle this loss, the receiver discloses the loss
to the sender, and the sender discloses that loss together with the
rest of non-contiguous capability to CRAFT router. For example,
if a pre-capability for packet ID k(< j) is lost, corresponding ca-
pability is Cf,j = Pf,0 ⊕ . . . ⊕ Pf,k−1 ⊕ Pf,k+1 ⊕ . . . ⊕ Pf,j .
CRAFT router veriﬁes the received non-contiguous capability tak-
ing the disclosed loss into consideration.
3. LIMITATIONS
Per-Host Fairness. CRAFT considers per-ﬂow fairness since it
emulates the state machine of a TCP ﬂow. To use CRAFT to en-
force host-fairness, a scheme to guarantee a fair share of the number
of connections among hosts is necessary. Without such a scheme,
an attacker can initiate an excessive number of ﬂows.
Per-Flow Operation. CRAFT achieves space-efﬁciency at the ex-
pense of hash calculation. If the computation overhead is signif-
icant, CRAFT may not be practical. However, a recent software
router implementation [5] achieves about 10 Gbps throughput for
forwarding 64 byte packets with IPsec operation. We believe that
an ASIC implementation can further improve the throughput.
Vulnerability of TCP. CRAFT prevents a ﬂow from deviating from
the ﬂow rate speciﬁed by the TCP standard. There can be other at-
tacks against TCP [6, 10]. Our goal is to enforce TCP behavior, not
to ﬁx all possible vulnerabilities of the TCP congestion control.
4. POSTER ORGANIZATION
Due to space constraint, we do not present our evaluation results
in this proposal. In our poster, we will present evaluation results for
the overhead and the effectiveness of CRAFT as well as motivation
and basic architecture.
5. REFERENCES
[1] M. Allman, V. Paxson, and W. Stevens. TCP congestion control. RFC 2581,
April 1999.
[2] M. Bellare and P. Rogaway. Random oracles are practical: a paradigm for
designing efﬁcient protocols. In Proceedings of CCS ’93, pages 62–73, New
York, NY, USA, 1993. ACM.
[3] A. Demers, S. Keshav, and S. Shenker. Analysis and simulation of a fair
queueing algorithm. In In Proceedings of SIGCOMM ’89, pages 1–12, New
York, NY, USA, 1989. ACM.
[4] S. Floyd and K. Fall. Promoting the use of end-to-end congestion control in the
internet. Networking, IEEE/ACM Transactions on, 7(4):458 –472, Aug 1999.
[5] S. Han, K. Jang, K. Park, and S. Moon. Packetshader: a GPU-accelerated
software router. SIGCOMM 2010.
[6] A. Herzberg and H. Shulman. Stealth dos attacks on secure channels. In
Proceedings of NDSS ’10, 2010.
[7] F. Kelly, A. Maulloo, and D. Tan. Rate control in communication networks:
shadow prices, proportional fairness and stability. In Journal of the
Operational Research Society, volume 49, 1998.
[8] H. Krawczyk, M. Bellare, and R. Canetti. HMAC: Keyed-hashing for message
authentication. RFC 2104, February 1997.
[9] S. H. Low and D. E. Lapsley. Optimization ﬂow control. i. basic algorithm and
convergence. Networking, IEEE/ACM Transactions on, 7(6):861 –874, Dec.
1999.
[10] S. Savage, N. Cardwell, D. Wetherall, and T. Anderson. TCP congestion
control with a misbehaving receiver. SIGCOMM CCR, 29(5):71–78, 1999.
[11] R. Sherwood, B. Bhattacharjee, and R. Braud. Misbehaving TCP receivers can
cause Internet-wide congestion collapse. In CCS ’05: Proceedings of the 12th
ACM conference on Computer and communications security, pages 383–392,
New York, NY, USA, 2005. ACM.
[12] I. Stoica, H. Zhang, and S. Shenker. Self-verifying CSFQ. In Proceedings of
INFOCOM ’02, volume 1, pages 21 – 30 vol.1, 2002.
707