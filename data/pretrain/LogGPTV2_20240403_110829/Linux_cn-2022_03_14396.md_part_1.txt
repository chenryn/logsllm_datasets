---
author: Evan Slatis
category: 容器与云
comments_data: []
count:
  commentnum: 0
  favtimes: 0
  likes: 0
  sharetimes: 0
  viewnum: 2454
date: '2022-03-26 11:18:00'
editorchoice: false
excerpt: 对齐部署镜像和描述符是很困难的，但是某些策略可以使整个过程更高效。
fromurl: https://opensource.com/article/21/8/impedance-mismatch-cicd
id: 14396
islctt: true
largepic: /data/attachment/album/202203/26/111748mxu3ovasrvb0iy02.jpg
permalink: /article-14396-1.html
pic: /data/attachment/album/202203/26/111748mxu3ovasrvb0iy02.jpg.thumb.jpg
related: []
reviewer: wxy
selector: lujun9972
summary: 对齐部署镜像和描述符是很困难的，但是某些策略可以使整个过程更高效。
tags:
- 部署
- CI
- CD
thumb: false
title: 解决 CI/CD 中的仓库阻抗失配
titlepic: true
translator: lxbwolf
updated: '2022-03-26 11:18:00'
---
> 
> 对齐部署镜像和描述符是很困难的，但是某些策略可以使整个过程更高效。
> 
> 
> 
![](/data/attachment/album/202203/26/111748mxu3ovasrvb0iy02.jpg "Tips and gears turning")
在软件架构中，当两个组件之间有某些概念性或技术上的差异时会出现  阻抗失配   impedance mismatch 。这个术语其实是从电子工程中借用的，表示电路中输入和输出的电子阻抗必须要匹配。
在软件开发中，存储在镜像仓库中的镜像与存储在源码控制管理系统（LCTT 译注：SCM，Source Code Management）中它的 部署描述符   deployment descriptor 之间存在阻抗失配。你如何确定存储在 SCM 中的部署描述符表示的是正确的镜像？两个仓库追踪数据的方式并不一致，因此将一个镜像（在镜像仓库中独立存储的不可修改的二进制）和它的部署描述符（Git 中以文本文件形式存储的一系列修改记录）相匹配并不那么直观。
**注意**：本文假定读者已经熟悉以下概念：
*  源码控制管理   Source Control Management （SCM）系统和分支
* Docker 或符合 OCI 标准的镜像和容器
*  容器编排系统   Container Orchestration Platforms （COP），如 Kubernetes
*  持续集成/持续交付   Continuous Integration/Continuous Delivery （CI/CD）
*  软件开发生命周期   Software development lifecycle （SDLC）环境
### 阻抗失配：SCM 与镜像仓库
为了更好地理解阻抗失配在什么场景下会成为问题，请考虑任意项目中的软件开发生命周期环境（SDLC），如开发、测试或发布环境。
测试环境不会有阻抗失配。现在使用 CI/CD 的最佳实践中开发分支的最新提交都会对应开发环境中的最新部署。因此，一个典型的、成功的 CI/CD 开发流程如下：
1. 向 SCM 的开发分支提交新的修改
2. 新提交触发一次镜像构建
3. 新生成的镜像被推送到镜像仓库，标记为开发中
4. 镜像被部署到容器编排系统（COP）中的开发环境，该镜像的部署描述符也更新为从 SCM 拉取的最新描述符。
换句话说，开发环境中最新的镜像永远与最新的部署描述符匹配。回滚到前一个构建的版本也不是问题，因为 SCM 也会跟着回滚。
最终，随着开发流程继续推进，需要进行更多正式的测试，因此某个镜像 —— 镜像对应着 SCM 中的某次提交 —— 被推到测试环境。如果是一次成功的构建，那么不会有大问题，因为从开发环境推过来的镜像应该会与开发分支的最新提交相对应。
1. 开发环境的最新部署被允许入库，触发入库过程
2. 最新部署的镜像被标记为测试中
3. 镜像在测试环境中被拉取和部署，（该镜像）对应从 SCM 拉取的最新部署描述符
到目前为止,一切都没有问题，对吗？如果出现下面的场景，会有什么问题？
**场景 A**：镜像被推到下游环境，如 用户验收测试   user acceptance testing （UAT），或者是生产环境。
**场景 B**：测试环境中发现了一个破坏性的 bug，镜像需要回滚到某个确定正常的版本。
在任一场景中，开发过程并没有停止，即开发分支上游有了一次或多次新的提交，而这意味着最新的部署描述符已经发生了变化，最新的镜像与之前部署在测试环境中的镜像不一致。对部署描述符的修改可能会也可能不会对之前版本的镜像起作用，但是它们一定是不可信任的。如果它们有了变化，那么它们就一定与目前为止你测试过的想要部署的镜像的部署描述符不一致。
问题的关键是：**如果部署的镜像不是镜像库中的最新版本，你怎么确定与部署的镜像相对应的是 SCM 中的哪个部署描述符？** 一言以蔽之，无法确定。两个库直接有阻抗失配。如果要详细阐述下，那么是有方法可以解决的，但是你需要做很多工作，这部分内容就是文章接下来的主题了。请注意，下面的方案并不是解决问题的唯一办法，但是已经投入到生产环境并已经对很多项目起了作用，而且已经被构建并部署到生产环境中运行了超过一年。
### 二进制与部署描述符
源码通常被构建成一个 Docker 镜像或符合 OCI 标准的镜像，该镜像通常被部署到一个容器编排平台（COP）上，如 Kubernetes。部署到 COP 需要部署描述符来定义镜像被如何部署以及作为容器运行，如 [Kubernetes 部署](https://kubernetes.io/docs/concepts/workloads/controllers/deployment/) 或 [CronJobs](https://kubernetes.io/docs/concepts/workloads/controllers/cron-jobs/)。这是因为在镜像和它的部署描述符之间有本质差异，在这里可以看到阻抗失配。在这次讨论中，我们认为镜像是存储在镜像仓库中不可修改的二进制。对源码的任何修改都不会修改镜像，而是用另一个新的镜像去替换它。
相比之下，部署描述符是文本文件，因而可以被认为是源码且可修改。如果遵循最佳实践，那么部署描述符是被存储在 SCM，所有修改都会提交，而这很容易回溯。
### 解决阻抗失配
建议的解决方案的第一部分，就是提供一个能匹配镜像仓库中的镜像与对保存部署描述符的 SCM 做的代码提交的方法。最直接的解决方案是用源提交的哈希值标记镜像。这个方法可以区分不同版本的镜像、容易分辨，并且提供足够的信息来查找正确的部署描述符，以便镜像更好地部署到 COP。
再回顾下上面的场景：
**场景 A** *镜像被推到下游环境*： 当镜像被从测试环境推到 UAT 环境时，我们可以从镜像的标签中知道应该从 SCM 的哪一次源码提交拉取部署描述符。
**场景 B** *当一个镜像需要在某一环节中回滚*：无论我们选择回滚到那个镜像版本，我们都可以知道从 SCM 的哪一次源码提交拉取正确的部署描述符。
在每一种情景中，无论在某个镜像被部署到测试环境后开发分支有多少次提交和构建，对于每一次升级的镜像，我们都可以找到它当初部署时对应的部署描述符。
然而，这并不是阻抗失配的完整解决方案。再考虑两个场景：
**场景 C** 在负载测试环境中，会尝试对不同的部署描述符进行多次部署，以此来验证某一次构建的表现。
**场景 D** 一个镜像被推送到下游环境，在该环境中部署描述符有一个错误。
在上面的所有场景中，我们都需要修改部署描述符，但是目前为止我们只有一个源码提交哈希。请记住，最佳实践要求我们所有对源码的修改都要先提交到 SCM。某次提交的哈希本身是无法修改的，因此我们需要一个比仅仅追踪原来的源码提交哈希更好地解决方案。