cess to the database, but a trusted compartment should
export access to the database. This privilege separation,
reminiscent of techniques explored in OKWS [5], pre-
vents a user from accessing other users’ sensitive data.
4.2 Oracle Prevention Techniques
In the previous section, we described how to implement
cryptographic protocols so as to thwart SKD and imper-
sonation attacks. Throughout the suggested implementa-
tion structure there is sensitive data accessible only by
trusted compartments, which in turn export privileged
operations to unprivileged compartments. As discussed
in Section 3.2, in all such situations, there is a risk of
granting an attacker an oracle for sensitive information.
For example, the session key negotiation stage de-
pends on conﬁdential session key sharing. An SKD at-
tacker can use a trusted compartment as a decryption or-
acle to obtain a secret component of a session key. An im-
personator may replay authentication data from another
connection as an input to an authentication oracle and
pass authentication as a legitimate user. Clearly, we need
techniques to mitigate any oracles in these stages.
Entangle Output Strongly with Per-Session Known-
Random Input Network protocols employ random-
ness generated afresh for every session to defeat authenti-
cation replay attacks, where an attacker replays messages
eavesdropped from a user session to reestablish the past
session and repeat a user’s past requests. The server gen-
erates a random nonce incorporated into the session key
(in the case of RSA key exchange) or a fresh private DH
component (for DH key exchange) to make the session
key different for every session. We can similarly employ
this session randomness as a defense to counter oracles.
The output of a trusted compartment should not com-
pletely depend on untrusted input, so that an attacker will
not be able to replay past input to the compartment and
get the same deterministic result. Entangling the output
of a privileged compartment with a trusted per-session
random nonce solves this problem.
For example, Figure 4 demonstrates an approach
to preventing a signing oracle in a privilege-separated
OpenSSH server. We restrict the trusted monitor that im-
plements signing with the private key to sign only ses-
sion IDs that incorporate per-session random bits. A se-
quence of privileged operations performed by the trusted
compartment ensures that the server’s private DH com-
ponent is indeed included in the session ID. This way,
we entangle the output of the RSA signing compart-
ment/operation with trusted, per-session, known-random
input. Numbers within trusted compartments in Figure 4
specify the order of their invocation, and this order
should be enforced by the application.
With this oracle defense mechanism, the attacker can-
not mount an impersonation attack, as every signed
session ID will incorporate different randomness con-
tributed by the server, and will thus not be valid in the
context of any other session. Similarly, in order to pre-
vent deterministic session key oracles, we make sure that
the compartment generating the keys includes random-
ness generated afresh for every session. Moreover, per-
session randomness is crucial in prevention of signature
veriﬁcation oracles; the data for signature veriﬁcation
should also incorporate it.
Principle 6: To prevent oracles, entangle output
strongly with per-session, known-random input.
In RSA key exchange in the SSL/TLS protocol, there
can be used to decrypt user information and validly en-
crypt an attacker’s exploits or requests.
Our oracle mitigation technique provides the required
privileged operations (encryption and decryption with a
session key) and avoids a session key oracle by obfuscat-
ing input data through hashing. As the ﬁnished message
is an encrypted hash, a trusted compartment can be struc-
tured in the following way: it obtains data from an un-
trusted compartment, hashes the data, and then encrypts
the resulting hash. A privileged operation that hashes
data and then encrypts is not useful for an attacker, as the
attacker’s requests and exploits for the pre-authenticated
and post-authenticated stages will be viewed as hashes.
As for the decryption oracle, we do not return the
cleartext ﬁnished message to untrusted code. Instead, our
trusted compartment takes the veriﬁcation data from an
untrusted compartment and performs veriﬁcation of the
ﬁnished message itself. The result of this veriﬁcation is
returned to the untrusted compartment. However, this
mechanism allows dictionary attacks, where an attacker
can guess the cleartext message by supplying the veriﬁ-
cation data. Again, obfuscating the untrusted validation
data by hashing before comparing it with the cleartext
ﬁnished message solves this problem. This approach ﬁts
the protocol because the ﬁnished message happens to be
a hash of all previous handshake messages. If an attacker
attempts to guess the cleartext requests, his guess will be
hashed ﬁrst, then compared with the original message.
The hashing that we apply to prevent both oracles al-
ready is present in the SSL handshake. But the hand-
shake and our oracle mitigation technique use it for dif-
ferent reasons. The handshake requires the compression
and collision-resistance of a hash function, but our tech-
nique employs the hash function because of its non-
invertibility. Happily for us, the hash function provides
all the mentioned properties and does double duty.
Principle 7: To prevent oracles, obfuscate untrusted
input by hashing.
Last Resort: More Trusted Code The previous oracle
mitigation techniques require the availability of a random
nonce or a hash function. However, for those cases in
which a cryptographic protocol does not specify these
functions at a point in the protocol where there is the risk
of an oracle, we offer a last resort technique.
For an oracle to exist, a result of a privileged oper-
ation must return to an unprivileged compartment. It is
possible to avoid the oracle by making the output privi-
leged and restricting access to it in the unprivileged code.
Although this technique helps, it is not efﬁcient, as a
new trusted compartment is required to process the re-
sult, and you may need to process the result of the new
compartment in the same way. Our last resort technique
Figure 4: Prevention of private key oracle in OpenSSH server by en-
tangling output with per-session known-random input.
is the potential for a deterministic session key oracle at-
tack, where an attacker can produce a deterministic ses-
sion key by supplying chosen inputs to a privileged com-
partment generating the key. In particular, a session key
consists of two public components, per-session server
and client randoms, and a pre-master secret transmitted
encrypted in the server’s public key [4]. When generat-
ing the session key, these components are concatenated
together and hashed. The server decrypts the pre-master
secret using its private key before hashing it together with
the other components. If an attacker controls the server
random, client random, and encrypted pre-master secret
inputs to the session key generation function, he can feed
data eavesdropped from a user session to the privileged
compartment generating the session key and produce the
key that corresponds to the eavesdropped session. We
prevent deterministic session key oracles by ensuring
that every server-computed session key includes a trusted
server nonce produced and supplied to the compartment
generating the session key by a trusted source. This way,
an attacker cannot control the generated session key, as
each time it incorporates a different random nonce.
Obfuscate Untrusted Input by Hashing The SSL
protocol alternates cleartext change cipher spec mes-
sages with authenticated and encrypted ﬁnished mes-
sages [4]. A change cipher spec message signals that the
sender is about to enable encryption and authentication
on all subsequent messages. A ﬁnished message contains
a MAC’ed and encrypted hash of all previous cleartext
messages received by a peer during the handshake pro-
tocol. The ﬁnished message ensures that these cleartext
messages were not tampered with by an attacker.
To ensure that the session key barrier is enforced,
we cannot process cleartext messages in the pre-
authenticated stage. Instead we should process the ﬁn-
ished messages within the session key negotiation stage.
However, doing so requires a trusted compartment that
performs session key encryption and decryption opera-
tions on behalf of untrusted code. This trusted compart-
ment is a session key encryption/decryption oracle which
4SKN stagenetworkcomputesess ID3DH compgenerateDH comp1computesess key2session keysession IDprivate keysignsess IDmay lead to a chain of trusted compartments, which in-
creases the trusted code base and requires more auditing
work. Moreover, to terminate this chain, there must be a
suitable condition for applying one of the previous oracle
mitigation techniques, or the last trusted compartment in
the chain must not produce any output.
Principle 8: To prevent oracles, as a last resort, add
more trusted code.
4.3 Degrees of Sensitivity
Cryptographic protocols often operate on sensitive data
of more than one class. As an example, one frequently
occurring class of sensitive data is that which must be
kept secret to ensure secrecy and integrity of data trans-
ferred within a single session, e.g., the pre-master secret
in RSA key exchange, the private DH component in DH
key exchange, the session key, the per-session ephemeral
RSA private key, &c. Disclosure of such sensitive data
results in violation of the secrecy and/or integrity of sen-
sitive data within a single session. Yet there is often an-
other class of even more sensitive data that must remain
secret in order to preserve the secrecy of user data in
many sessions. This class includes a server’s private key,
users’ private keys, and passwords that are reused on
many servers. The secrecy of such data is vital because
an attacker can use it to gain access to user data in mul-
tiple sessions by impersonating the server, or by using
users’ passwords to access many servers.
In a simple scenario like this one involving two classes
of sensitive data—that which is critical to one session’s
secrecy vs. that which is critical to ensuring many ses-
sions’ secrecy—mixing sensitive data of both classes and
code to manipulate data of both classes in the same com-
partment incurs warrantless risk. To see why, let’s devi-
ate from our threat model and assume that an attacker
can compromise trusted compartments. Now any vulner-
ability in code that manipulates sensitive data pertaining
to one session’s secrecy can disclose sensitive data that
could compromise secrecy of all sessions. Creating dis-
tinct compartments for data of differing degrees of sen-
sitivity (and the code that manipulates it) mitigates this
risk. Similarly, to prevent disclosure of one user’s data to
another, separate compartments should manage sensitive
session-related key data for each user.
Principle 9: A privilege-separated application should
manage a session with two separate privileged
compartments—one to operate with data related to se-
crecy of the current session, and one to manage data
that preserves secrecy of many sessions.
Isolating code and data in distinct compartments ac-
cording to their sensitivity often reduces trusted code
base size; the quantity of code with privilege with respect
to one piece of data decreases.
5 Hardened SSH Protocol Implementation
We now demonstrate these principles for preventing
SKD and oracle attacks by ﬁnely privilege-separating the
implementations of the client and server sides of the SSH
protocol.
Recent privilege separation and DIFC work focuses on
server applications, as they accept connections and can
thus be attacked at will. But the rise of web browser ex-
ploits demonstrates that client code is equally at risk. An
attacker can set up a public service and provide access
to it via SSH. By exploiting vulnerabilities in the SSH
client implementation, the attacker can obtain users’ pri-
vate keys, used to authenticate them to other legitimate
SSH servers. These keys allow the attacker to obtain or
tamper with the user’s sensitive information stored at
these other SSH servers. Moreover, as the SKD attack is
equally valid on both sides, server and client, protection
against it is equally needed on the two sides.
Throughout this paper, the baseline OpenSSH server
design we refer to is that of Provos et al. [9]. While this
OpenSSH server implements privilege separation, it al-
lows unprivileged code access to the session key (contra-
vening Principles 1 and 2) and to sign a session ID pro-
vided by unprivileged code (contravening Principle 6),
and thus is vulnerable to SKD and oracle attacks. We
show how to partition the server more ﬁnely to prevent
these attacks. But ﬁrst, we focus on the OpenSSH client,
which to date has only existed in monolithic form, and is
thus also vulnerable to both attacks.
5.1 Hardened OpenSSH Client
The OpenSSH client runs under the invoking user’s user
and group IDs. Because changing the user ID to nobody
and invoking the chroot system call require root
privilege, they cannot be used here. Instead, we limit
the privilege of the trusted and untrusted compartments
of the OpenSSH client with SELinux policies [7], and
the SELinux type enforcement mechanism in particular.
SELinux policies allow us to restrict untrusted processes
from issuing unwanted system calls such as ptrace,
open, connect, &c.3 Our prototype supports only
password and public key authentication, and does not yet
implement advanced SSH functionality (tunneling, X11
forwarding, or support for authentication agents).
Our hardened OpenSSH client starts in the ssh t do-
main, deﬁned as a standard policy in the SELinux pack-
age for the original monolithic SSH client. This policy
provides the union of all privileges required by all code
in the SSH client; i.e., an application in the ssh t do-
main may open SSH conﬁguration ﬁles, access ﬁles in
the /tmp directory, connect to a server using a network
session monitor cannot create or access any ﬁles apart
from known hosts, nor may it create new sockets. The
private key monitor runs in the ssh pkey t domain, a do-
main we have deﬁned with a similarly tight policy, al-
lowing it only to read the user’s private key(s), with no
access to other ﬁles, nor privilege to create any sockets.
The private key monitor shares a UNIX socket with the
session monitor and only accepts requests from the latter.
After creating these two monitor processes, the original
SSH client process drops privilege to the ssh nobody t
domain. Untrusted code runs in this unprivileged process
and domain during the rest of the SSH client’s execu-
tion. The ssh nobody t domain allows the unprivileged
process to communicate with the session monitor and re-
mote server via previously opened sockets, but prevents
it from opening any new ones. The ssh nobody t domain
further denies all access to the ﬁle system, allowing the
unprivileged process access to the terminal device only.
The session monitor compartment isolates all sensi-
tive data that can be used to compromise the current re-
mote login session, and performs all privileged opera-
tions with these data, enumerated in Figure 6, that are es-
sential for key exchange and prevention of a private-key
oracle. When a privileged operation takes non-sensitive
data as input, the non-sensitive input is supplied by the
unprivileged compartment. Symmetric keys (sym keys)
are the keys derived from the session key for the MAC
and encryption/decryption. The session monitor enforces
the order in which an untrusted compartment may invoke
its privileged operations.
The private key monitor isolates the client’s private
key and performs signing operations with the key. Only
the session monitor may invoke these signing operations
in the private key monitor (over a UNIX-domain socket),
and it provides the session ID to be signed as an argu-
ment. We give a more detailed explanation of the private
key signing operation at the end of this section.
Session Key Negotiation Stage We now consider the
ﬁrst stage of the hardened OpenSSH client, the session
key negotiation (SKN) stage, designed to thwart SKD at-
tacks (described in Section 3.1). In the SKN stage, an
unprivileged compartment—with the help of the session
monitor—performs Difﬁe-Hellman key exchange to ne-
gotiate a session key and authenticate the server. In ac-
cordance with Principle 1, we restrict the SKN stage
to run in an unprivileged compartment that cannot ac-
cess sensitive data—not the DH private key, nor the ses-
sion key, nor the symmetric keys (as shown in Figure 6).
Keeping the session key secret (and thus thwarting an
SKD attack) requires in turn keeping this data secret.
We must also prevent a veriﬁcation oracle attack
against the client at this point in the handshake. Suppose
the attacker wants to impersonate a server to the client,
Figure 5: Architecture of privilege-separated OpenSSH client. Shaded
ovals denote privileged compartments. Unshaded ovals denote unpriv-
ileged compartments. The last line in each oval denotes the SELinux
policy enforced.
Session monitor