Similarly, you can create a folder within the application's private data directory that is set with secure
permissions as follows:
File newdir = getDir("newdir", Context.MODE_PRIVATE);
Some examples on the Internet show similar code examples, but without the use of the static final integers
that represent the permissions. Such an example that actually makes a newly created file world readable is
shown here:
FileOutputStream secretFile = openFileOutput("secret", 1);
Using direct integers that represent the permissions is not advised because it is not clear when reviewing code at
a glance what the outcome will be.
When using native code to create a file, you can also explicitly specify permissions. This example shows how to
do so in the open function:
FILE * secretFile = open("/data/data/com.myapp/files/secret",
O_CREAT|O_RDWR, S_IRUSR|S_IWUSR);
This creates the file with permissions that only allow the application owner to read and write to it.
Using Encryption
Previous chapters discussed attacks that can be used to expose the contents of a private data directory. Such
attacks highlight the importance of going that extra step and encrypting any sensitive files that reside on disk.
When storing sensitive files on the SD card, you absolutely must encrypt it. This applies to data being read from
the SD card as well because the ability to manipulate input files could be an entry point into the application for
an attacker. You should view the SD card as a public area on the device and take care when using it for storage.
The field of encryption is a heavily technical one that is only lightly explored in the next section. An important
point is that creating your own encryption schemes is not an acceptable solution. Widely accepted encryption
schemes are mathematically proven and have spent many years in peer review by professional cryptographers.
Do not discount the kind of time and effort put into these endeavors; the outcome assures you that widely
known encryption algorithms will always provide you with better security than custom ones. The following are a
set of safe decisions that are in line with the recommendations from professional cryptographers:
Use at minimum 256-bit AES for symmetric key encryption. Avoid using ECB (Electronic Code Book) mode
because it will allow an attacker to discover patterns in data between different encrypted blocks.
Use 2048-bit RSA for asymmetric encryption.
Use SHA-256 or SHA-512 as a hashing algorithm.
If it is possible to salt passwords, then do so with a randomly generated string. This method is especially
useful when you need to hash a password of some sort. The salt is not a secret and can be stored alongside
the encrypted information. Salting prevents the use of pre-computed rainbow tables to recover passwords
and is not a secret in itself.
Using Random Numbers, Key Generation, and Key Storage
If at any point in your application you need to generate a random number or obtain a key that is used for
cryptographic purposes, then you must watch out for a number of things. The most important of these are as
follows:
Never seed a pseudo-random number generator (PRNG) using the current date and time. This is a
deterministic seed value that is not suitable for key generation. Versions of Android prior to 4.2 would
generate the same identical sequence of numbers from SecureRandom when given the same seed, because the
seed was not mixed in with the internal source of entropy but rather replaced. This means that on these
versions, any generated random numbers could be guessed if the attacker iteratively brute-forced a set of
probable seed values.
Never seed a PRNG with a constant number. If this seed is recovered from the decompiled code then an
attacker could also use it to recover the sequence of numbers generated by the PRNG.
Never use device values like an International Mobile Equipment Identity (IMEI) number or Android ID as
the encryption key or as input to one. An attacker can easily retrieve these values, especially if he has gained
arbitrary code execution on the device.
When making use of key derivation functions, never use constant salt values and always use iterations of
10,000 or more. This will make the use of a rainbow tables infeasible and the brute-forcing of passwords
expensive.
Now that you have read about some of the things that you should not do, it's time to look at possible solutions.
To generate a random number, you use SecureRandom, but you must take care in the way that it is seeded.
Seeding with a non-deterministic seed is important and you should use many inputs to create it to guarantee
randomness. The Android Developers Blog has excellent code for generating seed values (http://android-
developers.blogspot .co.uk/2013/08/some-securerandom-thoughts.html). The technique used mixes: the
current time, PID, UID, build fingerprint, and hardware serial number into the Linux PRNG at /dev/urandom.
To generate a 256-bit AES key that is seeded only from default system entropy, you can use the following code:
SecureRandom sr = new SecureRandom();
KeyGenerator generator = KeyGenerator.getInstance("AES");
generator.init(256, sr);
SecretKey key = generator.generateKey();
If you use this code, then the burning question is where should you store the key? This question is one of the
biggest problems faced by developers wanting to encrypt application files. It is a tricky question with many
differing opinions about the correct solution. The answer should depend on the type and sensitivity of the
application but some possible solutions are discussed here.
A solution that is not acceptable is hard-coding the password in the source code. You have seen how easily an
attacker can decompile an application and obtain such keys, which makes the measure completely ineffective.
For high-security applications the answer is simple: The user should hold the key. If the application requires
some form of password to access it then the entered password should be used to derive the encryption key via a
key derivation function such as PBKDF2. This ensures that the encryption key can be derived only from the
correct user password. If an attacker obtains an encrypted file, then he can attempt to brute-force the password
and run it through the key derivation function to decrypt the file. However, this attack is largely infeasible when
strong passwords are used. A functional implementation of using a user password or pin to generate the
encryption key is provided by Google at http://android-developers.blogspot.com/2013/02/using-
cryptography-to-store-credentials.html and is shown here:
public static SecretKey generateKey(char[] passphraseOrPin, byte[] salt)
throws NoSuchAlgorithmException, InvalidKeySpecException {
// Number of PBKDF2 hardening rounds to use. Larger values increase
// computation time. Select a value that causes
// computation to take >100ms.
final int iterations = 1000;
// Generate a 256-bit key
final int outputKeyLength = 256;
SecretKeyFactory secretKeyFactory =
SecretKeyFactory.getInstance("PBKDF2WithHmacSHA1");
KeySpec keySpec = new PBEKeySpec(passphraseOrPin, salt, iterations,
outputKeyLength);
SecretKey secretKey = secretKeyFactory.generateSecret(keySpec);
return secretKey;
}
The salt in the previous implementation can be any randomly generated value that is stored alongside the
encrypted data in the application's private data directory.
For applications where user-derived encryption keys are not possible, you must take a best effort approach. If
the encryption key is not making use of something from the user then it must be stored somewhere on the
device or retrieved from the linked application web service. Storing the encryption key in the same folder as the
encrypted file would probably be of little use because if an attacker is able to retrieve the encrypted file, he
might also be able to read other files in the same directory. A location that provides more security is the
AccountManager feature in Android. The AccountManager allows an application to store a password that can only
be accessed again by the application that added it. A check is performed when calling the getPassword() method
that the caller has the AUTHENTICATE_ACCOUNTS permission and that the UID of the caller is same as the one that
added the account. This measure is decent for protecting the password from malicious applications but will not
protect this password from attackers with privileged access such as root. It is not strictly supposed to be used for
this purpose but versions of Android prior to 4.3 did not have a suitable solution for storing symmetric keys
securely.
If your application targets Android API level 18 and later then making use of the Android Keystore System may
be a better measure. This specific type of KeyStore (see
http://developer.android.com/reference/java/security/KeyStore.html) is only available to your application
UID. Only asymmetric keys can be added, which means that the stored key would have to be used to encrypt a
symmetric key that resided somewhere else on the device.
Exposing Files Securely to Other Applications
Consider the scenario where your application generates PDF documents that the user must view in another
application. You do not want to put these documents on the SD card because that is considered a public storage
area and these documents might contain sensitive information. You also do not want to mark the document as
world readable and place it in your application's private data directory so that the document reader can reach it
because then effectively any application can reach it, too.
In this case using a content provider as an access-control mechanism for the document may be wise. Android
has this scenario covered by making use of a feature called the granting of URI permissions. Consider the
following content provider declaration in a manifest:
An application that wanted to read or write to this content provider directly would have to hold the
com.myapp.docs.READWRITE permission. However, the line that sets grantUriPermissions to false and the
 tag specifies the paths to which other applications can be granted temporary access.
This combination means that only a content URI prefixed with /document/ can be made available using the
grant URI permission functionality. This protects the rest of the content provider from being accessed by any
external application without holding the specified permission.
The following example of this application uses the grant URI permission functionality to open a generated PDF
in an external PDF reader:
Uri uri = Uri.parse("content://com.myapp.docs/document/1");
Intent intent = new Intent(Intent.ACTION_VIEW);
intent.setDataAndType(uri, "application/pdf");
intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);
startActivity(intent);
Notice that the only difference between this code and normal opening of an exposed content URI is the
FLAG_GRANT_READ_URI_PERMISSION flag added to the intent.
The previous code is certainly the easiest method of performing this action but is not the most secure. What if a
malicious application on the device registered an intent filter that specified it is able to handle PDF documents?
The document might end up being accessible to the malicious application because the intent created was an
implicit one! A more secure method is to explicitly grant the URI permission to the application that will be
retrieving the document. You can do this by providing a configuration activity or a pop-up containing the list of
applications that are suitable to open PDFs prior to launching the intent that actually opens the PDF reader. A
list of all applications that can handle PDF documents can be retrieved using the queryIntentActivities
method of the PackageManager class. After the user has selected a PDF reader then the name of the package can
be provided to the grantUriPermission method as follows:
grantUriPermission("com.thirdparty.pdfviewer", uri,
Intent.FLAG_GRANT_READ_URI_PERMISSION);
After performing this code, an explicit intent can be created to open the PDF in the chosen reader. After the
application is sure that the user does not require access to the PDF any more, the URI permission can be
revoked using the following code:
revokeUriPermission(uri, Intent.FLAG_GRANT_READ_URI_PERMISSION);
This method maintains the security of the content provider by enforcing a permission and allows the exposure
of select files to third-party applications in a flexible way.
Creating Secure Communications
The power of many mobile applications comes from being able to interface with services on the Internet.
Unfortunately, this also means that the user's data that is being communicated may be susceptible to
compromise when traversing hostile networks. This section explores some ways to ensure that information is
transported securely to and from Internet services. It also provides a brief caution against implementing custom
IPC mechanisms.
Internet Communications
An application should never use cleartext communications with Internet services because it is a risk for traffic
interception attacks. An attacker anywhere along the path between the user's device and the Internet server
would be able to intercept and modify content in both directions or simply sniff this traffic to divulge its
contents. This is especially not acceptable if an application uses Internet services that require user credentials to
be submitted by the application. An attacker may not gain direct value from accessing the service being logged
into; however, attackers also know that humans are creatures of habit. Users may make use of the same
password on an arbitrary Internet service as they do for their email account or other sensitive services.
In addition to the risk of exposing user data, cleartext channels present a multitude of dangers to the application
itself. Chapter 8 covered this topic discussing various ways to exploit a device by manipulating HTTP traffic.
Therefore, we recommend that you avoid cleartext channels at all costs.
Android comprises of APIs that you can use to create very secure communication channels. Differing opinions
exist in the security world about what constitutes a “secure connection.” However, the general consensus is that
the use of SSL with some form of additional protection is acceptable for most use cases. The problem with
general-purpose SSL is that it relies on the security of a large number of trusted certificate authorities (CAs) for
validation. The compromise of a single trusted CA affects the security of all clients that trust this CA.
Compromising the signing certificate of a widely trusted CA means that fraudulent certificates can be issued for
your website or other SSL endpoints. An attacker who uses a fraudulent certificate in a traffic interception attack
would be able to capture traffic without the user receiving any warnings because the approach of attributing
trust through the use of trusted CAs is doing exactly what it says on the tin. Compromising a trusted CA
certificate is a known weak point.
The compromise of a CA signing certificate may sound like an unlikely event, but in recent years it has occurred
a number of times. To protect against this type of compromise, having applications implement SSL certificate
pinning is recommended. This is when certain attributes of the certificate presented by the server are validated
against stored values and the connection is allowed only if these values check out. In fact, some well-known
cryptographers such as Moxie Marlinspike have recommended not using CAs at all when implementing mobile
applications. He discussed this in his blog post at http://thoughtcrime.org/blog/authenticity-is-broken-in-
ssl-but-your-app-ha/.
Implementing SSL certificate pinning can be tricky if you are not knowledgeable on the specifics of X.509
certificates and their structure. One way of creating your own SSL certificate pinning implementation is creating
a new class that extends X509TrustManager and implementing the certificate checks in the checkServerTrusted
method. The technique used by Moxie inside this method was to compare the hash of the SPKI
(SubjectPublicKeyInfo) of the certificate against a stored value. Using this technique means that only the
issuer's key information will be checked, and so you are basically providing assurance that the certificate is
signed by the correct CA. This check is relatively lightweight and does not come with the hassles of pushing
application updates every time your website's certificate expires. Moxie has also written an Android Library that
provides an easy way for developers to add SSL certificate pinning to their connections. The documentation in
his project provides an example that shows how to retrieve data from https://www.google.com using a pinned
connection:
String[] pins = new String[] {"f30012bbc18c231ac1a44b788e410ce754182513"};
URL url = new URL("https://www.google.com");
HttpsURLConnection connection =
PinningHelper.getPinnedHttpsURLConnection(context, pins, url);
You can find further examples and the source code that implements the checks at
https://github.com/moxie0/AndroidPinning. If you decide not to make use of SSL certificate pinning then at
least mandate the use of SSL. Before releasing an application, perform thorough checks on the sections of code
handling the SSL connection to ensure that no certificate-bypassing hacks have been left in use. Validation of
the certificate should be done by the system or carefully implemented by someone who fully understands SSL
using a custom HostnameVerifier and TrustManager.
Some applications may require exceptionally secure communication channels that do not rely solely on the
security of SSL. In this case, you could add an additional encryption layer that makes use of a symmetric key
that is generated upon first use of the application. This decreases the likelihood that if an attacker is able to
break the SSL layer of the encryption, that he will be able to gain access to the actual contents of the
communication. This is because he would first need to gain access to the device to extract the key.
Local Communications
Android has a rich set of APIs for communication between applications. This diminishes the need to come up
with a unique way of transferring data from one application to another using network sockets, the clipboard, or
some other arbitrary mechanism. In fact, doing so decreases the security of the application because
implementing the same level of security the built-in APIs have is hard. If an arbitrary IPC mechanism must be
implemented for some reason then it should always include checks for verifying which application is connecting
to it. You need to think through all the ways that a malicious application could spoof a legitimate application's
identity.
Securing WebViews
WebViews have a lot of functionality under the hood that an attacker can use to his advantage. Therefore,
limiting the attack surface as much as possible if you use WebViews in your application is important. If you are
only using a WebView to load a simple informational website then rather open the site in the Android browser
by sending an intent containing the link. This method is more secure than having an embedded WebView
because the Android browser loads content within the context of its own sandbox. If the browser were to get
compromised by this content, it would have no implications for the data being held by your application.
However, sometimes legitimate use cases exist for implementing an embedded WebView.
The single biggest mistake made when implementing a WebView is loading cleartext HTTP content inside it
because of the numerous attack methods that are available to an attacker who is able to load his own content
inside the WebView. For this reason, only HTTPS links should be loaded inside a WebView, and code paths that
allow another application on the same device to load arbitrary content in the WebView should be removed.
The following sections list recommendations for what you can do to limit what attackers can do if they are able
to load their own content inside the WebView. David Hartley of MWR InfoSecurity documents these
considerations at https://labs .mwrinfosecurity.com/blog/2012/04/23/adventures-with-android-webviews/.
JavaScript
If support for JavaScript is not required in the WebView, then you should disable it because it is usually the
launching point for further attacks against the WebView. Being able to load dynamic code like JavaScript inside
the WebView gives the attacker the platform needed to exfiltrate data, redirect the page, create attack payloads,
and perform any other arbitrary action required for exploitation. You can disable JavaScript by implementing
the following code:
webview.getSettings().setJavaScriptEnabled(false);
JavaScriptInterface
The effects of exploiting a vulnerable WebView with an implemented JavaScriptInterface was shown in
Chapter 8. You can completely avoid this by simply not using a JavaScriptInterface if the functionality can be
provided in another way. If no other option exists, set the following attributes in the application manifest to
ensure that gaining arbitrary code execution using the JavaScriptInterface and CVE-2012-6636 is not possible:
You can then annotate methods exposed over the bridge with @JavascriptInterface. Note that this limits the
versions of Android that can run this application.
Plug-Ins
WebView plug-ins can provide third-party application vendors the ability to provide additional functionality. For
example, Flash from Adobe is a plug-in that can be used inside a WebView. The plug-ins functionality has been
deprecated from API version 18 (Jelly Bean 4.3) and higher but you should explicitly disable it in case older
versions of Android are being used by your userbase. You do that using the following code:
webview.getSettings().setPluginState(PluginState.OFF);
Setting this value helps protect against the exploitation of vulnerable WebView plug-ins and the “Fake ID”
vulnerability that was briefly discussed in Chapter 8.
Access to Information
WebViews by default are allowed to load files from the filesystem. This poses a problem when a vulnerability