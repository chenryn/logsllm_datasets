title:T-Reqs: HTTP Request Smuggling with Differential Fuzzing
author:Bahruz Jabiyev and
Steven Sprecher and
Kaan Onarlioglu and
Engin Kirda
T-Reqs: HTTP Request Smuggling with Differential Fuzzing
Bahruz Jabiyev
Northeastern University
Boston, MA, USA
Kaan Onarlioglu
Akamai Technologies
Cambridge, MA, USA
Steven Sprecher
Northeastern University
Boston, MA, USA
Engin Kirda
Northeastern University
Boston, MA, USA
ABSTRACT
HTTP Request Smuggling (HRS) is an attack that exploits the HTTP
processing discrepancies between two servers deployed in a proxy-
origin configuration, allowing attackers to smuggle hidden requests
through the proxy. While this idea is not new, HRS is soaring in
popularity due to recently revealed novel exploitation techniques
and real-life abuse scenarios.
In this work, we step back from the highly-specific exploits hog-
ging the spotlight, and present the first work that systematically
explores HRS within a scientific framework. We design an experi-
ment infrastructure powered by a novel grammar-based differential
fuzzer, test 10 popular server/proxy/CDN technologies in combi-
nations, identify pairs that result in processing discrepancies, and
discover exploits that lead to HRS. Our experiment reveals previ-
ously unknown ways to manipulate HTTP requests for exploitation,
and for the first time documents the server pairs prone to HRS.
CCS CONCEPTS
• Security and privacy → Web application security.
KEYWORDS
HTTP Request Smuggling; HTTP Desync Attacks
ACM Reference Format:
Bahruz Jabiyev, Steven Sprecher, Kaan Onarlioglu, and Engin Kirda. 2021. T-
Reqs: HTTP Request Smuggling with Differential Fuzzing. In Proceedings of
the 2021 ACM SIGSAC Conference on Computer and Communications Security
(CCS ’21), November 15–19, 2021, Virtual Event, Republic of Korea. ACM, New
York, NY, USA, 16 pages. https://doi.org/10.1145/3460120.3485384
1 INTRODUCTION
Due to the continuing proliferation of web caches, proxies, cloud ser-
vices, and Content Delivery Networks (CDNs) that deploy massively-
distributed networks made up of these technologies, a typical HTTP
request is often processed by multiple intermediate servers before
it reaches its destination. HTTP Request Smuggling (HRS) is an
attack that exploits the discrepancies between HTTP processing
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for profit or commercial advantage and that copies bear this notice and the full citation
on the first page. Copyrights for components of this work owned by others than ACM
must be honored. Abstracting with credit is permitted. To copy otherwise, or republish,
to post on servers or to redistribute to lists, requires prior specific permission and/or a
fee. Request permissions from permissions@acm.org.
CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea
© 2021 Association for Computing Machinery.
ACM ISBN 978-1-4503-8454-4/21/11...$15.00
https://doi.org/10.1145/3460120.3485384
semantics of these different servers to confuse them about message
boundaries, and consequently smuggles unintended requests into
the connection inside the request body.
HRS was first documented by Linhart et al. in 2005 [24]. However,
the technique took off only recently when researchers proposed
novel variants and demonstrated attacks on high-profile targets
(e.g., [6, 15, 19, 23]). Ultimately, smuggling was shown to be a serious
threat leading to response queue and cache poisoning, which can
then be exploited for myriad nefarious purposes such as personal
data leakage, credential theft, session hijacking, denial of service,
and security control bypass attacks, resulting in thousands of dollars
in bug bounties (e.g., [5, 16, 17]).
While these same researchers also released tools (e.g., [7, 36])
that partially automate the detection of HRS, these are largely
intended for assisting website owners and penetration testers in
probing specific targets for vulnerabilities. These tools are also
narrowly scoped, primarily testing for exploits that involve the
manipulation of two particular HTTP headers, Content-Length
and Transfer-Encoding, which govern how servers determine
HTTP message bounds.
To date, HRS has not been studied in a systematic manner; the
disclosed vulnerabilities were instead driven by case studies target-
ing popular websites. In particular, previous work on HRS leaves
two important gaps in our understanding of HRS attacks.
First and foremost, HRS is a system interaction problem, in-
volving at least two HTTP processors on the traffic path. These
processors may not necessarily be individually buggy; but when
used together, they disagree on the parsing or semantics of a given
HTTP request, which leads to a vulnerability. This key aspect of
HRS has not been explored in previous work. Next, previous attacks
focus on malicious manipulation of the two aforementioned HTTP
headers. Whether the remaining HTTP headers, or the rest of an
HTTP request, could be tampered with to induce similar processing
discrepancies remains uncharted territory.
In this paper, we present the first study that investigates HRS in
a scientific framework, and we tackle the above research questions.
Namely, we present a novel experiment setup with 10 popular
web servers and proxies: Apache, NGINX, Tomcat, Apache Traffic
Server (ATS), HAProxy, Squid, Varnish, Akamai, Cloudflare, and
CloudFront. We study these technologies in pairs, investigating
which combinations are vulnerable to HRS. To that end, we propose
a grammar-based fuzzer called T-Reqs that incorporates string
and tree mutations targeting a large variety of HTTP headers, the
request line, and the request body. T-Reqs employs a differential
fuzzing strategy, first testing each target technology in isolation,
Session 6B: Web Vulnerabilities CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea1805and then comparing responses to identify the pairs that behave
differently, signaling a potential vulnerability.
Once we identify the combinations that exhibit discrepancies
and the payloads that trigger them, we deploy every server pair
in a proxy-to-origin formation for further experimentation and
verification of our findings. We examine the conditions which cause
the potential HRS attacks to succeed or fail in this setup, and finally
demonstrate a range of exploits we discover.
Our results show that attacks can indeed be induced by manipu-
lating every part of a request, and highlights that HRS is a complex
system interaction problem that can crop up as a result of seem-
ingly innocuous processing discrepancies between pairs of web
technologies that are otherwise shown to be secure in isolation.
We summarize our contributions as follows:
• We present the most comprehensive study of HRS to date,
and examine attacks within a scientific framework for the
first time in literature.
• We propose a novel approach and experiment setup that
identify the HTTP processing discrepancies between 10 pop-
ular web servers and proxy services often used together.
• We develop a grammar-based differential HTTP fuzzer called
T-Reqs, and make it open source.
• We discover novel HRS payloads made possible by manipu-
lating HTTP request parts beyond the Content-Length and
Transfer-Encoding headers.
• We systematically examine the practical conditions that de-
termine the success of HRS.
Availability. T-Reqs is open-source and publicly available on
the authors’ websites.
Ethical Considerations. This study was conducted within a
controlled experiment setup, and no attacks were launched against
any external entities. We followed the established coordinated-
disclosure best practices; we notified all tested technology vendors
of our findings, provided them with a copy of this paper, and made
our data and team available for further assistance.
2 BACKGROUND & RELATED WORK
In this section we explain the basic terminology we use in the rest
of this text, and summarize how HRS attacks work.
2.1 HTTP Requests & Chunked Encoding
Listing 1 illustrates the structure of a typical HTTP request, made
up of the following three components.
(1) Request Line. Line 1 is the request line for this request,
which specifies the HTTP method (POST), the requested URI (/search),
and the protocol version (HTTP/1.1).
(2) Header Block. This section follows the request line, listing
header fields and values that define various parameters of the com-
munication. On lines 2-3, the Host header specifies the endpoint
the request should be dispatched to, and Content-Length indicates
the length of the message body.
(3) Request Body. Separated from the header block by a blank
line containing a carriage return and a line feed (often indicated by
CRLF or \r\n), the request body starts on line 5 and contains the
message payload. Here, the body consists of a parameter and its
value, query=funny+cats.
Table 1: Breakdown of the chunked body.
6\r\n
query=\r\n
a;foo=bar\r\n
funny+cats\r\n
0\r\n
X-Header:value\r\n
\r\n
Chunk size
Chunk data
Chunk size & chunk extension
Chunk data
Last chunk
Trailer part
Terminating CRLF
Chunked transfer encoding is an alternative encoding scheme
available in HTTP/1.1, where the message body is split into multiple
chunks transferred independently. This mechanism is useful for
streaming applications, when the size of the data to be transferred
is not known a priori [10].
Listing 2 shows the same request as before, this time using chun-
ked encoding. Every data chunk is preceded by its size, specified
in hexadecimal. Both the size and the data are terminated by CRLF.
Optionally, a chunk extension may immediately follow the size and
contain metadata (e.g., a hash of the chunk data). The last chunk is
a regular but empty chunk with a size of zero. Again, optionally, the
last chunk can include a trailer which is treated similar to message
headers, used for sending additional information to the receiver.
Table 1 presents a breakdown of these chunk components.
Note that the Transfer-Encoding: chunked header in Listing 2
indicates to the receiver that chunked encoding is in effect. When
using chunked encoding, sending the Content-Length header is
not meaningful, and in fact, according to RFC 7230, this is prohibited:
“A sender MUST NOT send a Content-Length header field in any
message that contains a Transfer-Encoding header field.” [10]
2.2 HTTP Request Smuggling (HRS)
HRS stems from a discrepancy between the HTTP processing be-
haviors of two servers that process the same request on the traffic
path. These servers could be any technology that intercepts, parses,
interprets, or forwards the request, including CDNs, stand-alone
proxies, web caches, load balancers, or security products. In this
text, we call the first server receiving the request the entrypoint,
and the next one the exitpoint. While this abstraction is sufficient
for our discussion, note that a typical request may be processed by
more than two such entities, and a hazardous combination of any
two could lead to attacks.
HRS involves a maliciously-crafted request such that the entry
and exitpoints disagree on the bounds of the message. All docu-
mented attacks we previously discussed in Section 1 achieve this
by including both the Content-Length and Transfer-Encoding:
1 POST /search HTTP/1.1
2 Host: example.com
3 Content-Length: 16
4
5 query=funny+cats
6
7
8
9
10 .
1 POST /search HTTP/1.1
2 Host: example.com
3 Transfer-Encoding: chunked
4
5 6
6 query=
7 a;foo=bar
8 funny+cats
9 0
10 X-Header:value
Listing 1: Regular body.
Listing 2: Chunked body.
Session 6B: Web Vulnerabilities CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea18061 POST /search HTTP/1.1
2 Host: example.com
3 Content-Length: 33
4 Transfer-Encoding: ; chunked
5
6 0
7 `
8 GET /img/i.jpg HTTP/1.1
9 X:X
Listing 3: Malicious smuggler request.
 ::= 
 ::= 
 ::= "POST /search HTTP/1.1\r\n" | "PUT / HTTP/1.1\r\n"
 ::=  | 
 ::= "Host: example.com\r\n"
 ::= "Content-Length: 16\r\n"
 ::= "\r\n"
 ::= "query=funny+cats" | "query=carrots"
Listing 6: Example CFG for a simple HTTP request.
1 GET /js/j.js HTTP/1.1
2 Host: example.com
3 A
4 A
5 A
1 GET /img/i.jpg HTTP/1.1
2 X:X GET /js/j.js HTTP/1.1
3 Host: example.com
4
5 .
Listing 4: Incoming request.
Listing 5: Smuggled request.
chunked headers in the request – if the entrypoint honors one
header and the exitpoint the other, they parse the message body
differently, and an HRS attack is possible. Even when both servers
are strictly RFC compliant so that they reject or normalize messages
containing both headers, and attacker can still abuse header parsing
discrepancies (e.g., by introducing invisible characters or minor
syntax errors into headers) and prevent one of the servers from
recognizing an invalid header combination.
Let’s illustrate the attack through an example.
(1) The attacker crafts a smuggler request which includes a sec-
ond hidden request inside the message body. Listing 3 shows such a
request including Content-Length: 33 and Transfer-Encoding:
;chunked together. Note the extra semicolon in the latter, which
will serve to confuse the message parser in the next step.
(2) The entrypoint receives the request, but cannot correctly
parse Transfer-Encoding: ;chunked due to the semicolon. The
server disregards chunked encoding and instead parses the message
body according to the Content-Length: 33 header. As a result,
the entrypoint forwards all 33 bytes shown between lines 5-9 to
the next hop.