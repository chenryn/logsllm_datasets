into problems because we have to take into account
two seeds, and a total search space of 64 bits which
is infeasible. The normal action would be to follow
the same path as we did in the Gallery application
where we had a similar problem and utilize the seed
reconstruction attack which does not require an output
of the PRNGs. However, the Gazelle application uses
custom sessions (which are generated using the same
function), and thus we cannot apply that attack either.
The solution lies into slightly moﬁying the seed recov-
ery attack. Instead of asking the question “which seed
produces this mt rand() sequence”, which is shufﬂed
and thus affected by the second PRNG, we instead ask
which seed produces the unsorted set which contains
the characters of our string. This set is not affected by
the shufﬂing and thus we can effectively bruteforce
the mt rand() seed independently. After recovering
the mt rand() seed we know the initial sequence that
was produced and we can subsequently recover the
seed of rand() using the same attack.
6.2 Attacks Implementation
In addition to auditing the applications, we imple-
mented a number of our attacks targeting selected ap-
plications.
In particular, we implemented a seed re-
covery attack against Mediawiki, a state reconstruction
attack against the Phorum application and the request
twins technique against Zen-cart. In the following sec-
tions we will brieﬂy describe each vulnerability and
the results of our attacks implementation.
Mediawiki. Mediawiki is a very popular wiki appli-
cation used, among others, by Wikipedia. Mediawiki
uses mt rand() in order to generate a new password
when the user requests a password reset. In order to
predict the generated password we use the seed recov-
ery attack of section 4.3. The function f that we sam-
ple is the one used to generate a CSRF token which is
the following:
function generateToken( $salt = ’’ ) {
$token = dechex(mt_rand()).dechex(mt_rand());
return
md5( $token . $salt );
}
Our function f given a seed s ﬁrst seeds the
mt rand() generator and then uses that generator to
produce a token as the function above. To fully eval-
uate the practicality of the attack we implemented the
attack online, without any time-space tradeoff. Our im-
plementation was able to cover around 1300000 seed
evaluations of f per second in a dual-core laptop with
two 2.3 GHz processors. This allowed us to cover the
full 232 range in about 70 minutes. Of course, using
a time-space tradeoff the search time could be further
reduced to a few minutes.
Zen cart. Zen-Cart is a popular eCommerce applica-
tion. At the time of this writing, a sample database
which shops enter volunterily numbers about 2500 ac-
tive e-shops 6.
In order to reset a user’s password
6www.zen-cart.com/index.php?main_page=showcase
14
zen-cart ﬁrst seeds the mt rand() generator with the
microtime() function and then uses the mt rand()
function to produce a new password for the user. Thus,
there at most 106 possible passwords which could be
produced. Our exploit used the request twins tech-
nique to reset both our password and the target user’s
password. Afterwards, we bruteforced the generated
password for our account to recover the microtime()
value that produced it. This takes at most a few sec-
onds on any modern laptop. Then, our exploit brute-
forces the passwords generated by microtime() val-
ues close to the one that generated our own new pass-
word. We ran our exploit in a network with RTT
around 9 ms, and Zen-Cart was installed in a 4× 2.3
GHz server. The average difference of the two pass-
words was about 3600 microseconds, and the exploit
needed at most two times that requests since we don’t
know which password was produced ﬁrst. With the
rate of 2500 requests per minute that our implementa-
tion achieves, the attack is completed in a few minutes.
Phorum. Phorum is a classic bulletin board applica-
tion. It was used, among others, by the eStream com-
petition as an online discussion platform. In order for
a user to reset his password the following function is
used:
function phorum_gen_password($charpart=4, $numpart=3)
{
$vowels = ... //[char array];
$cons = ... //[char array];
$num_vowels = count($vowels);
$num_cons = count($cons);
$password="";
for($i = 0; $i < $charpart; $i++){
$password .= $cons[mt_rand(0, $num_cons - 1)]
. $vowels[mt_rand(0, $num_vowels - 1)];
}
$password = substr($password, 0, $charpart);
if($numpart){
$max=(int)str_pad("", $numpart, "9");
$min=(int)str_pad("1", $numpart, "0");
$num=(string)mt_rand($min, $max);
}
return strtolower($password.$num);
}
What makes this function interesting in the context
of state recovery is that at if called with no arguments
(as it is in the application), at least four mt rand()
leaks are discarded in each call. We implemented
the attack having the application installed in a Win-
dows server with the Apache web server and we used
our generic technique for Windows in order to recon-
nect to the same process. On average, the attack re-
quired around 1100 requests and 11 reconnections of
our client. The running time was about 30 minutes, and
the main source of overhead was the system solving.
This fact is mainly explained from the small number
of buckets and the lost leaks of each iteration. Nev-
erthless, the attack remained highly practical, as we
were able to compormise any user account (including
the administrator) within half an hour.
7 Defending against the Attacks
We believe that a major shortcoming of the PHP core
is that it does not provide a native cryptographically
secure PRNG and token generator.
In fact, a pseu-
dorandom function (PRF) would be the most suitable
cryptographic primitive for generating random tokens
based on program deﬁned labels; PRF’s can be con-
structed by PRNG’s [7]. We feel that this is a short-
coming since developers tend to prefer functions from
the core as they are compatible with every different
enviroment PHP is running in. A possible solution
would be to introduce a secure PRNG in the PHP
core (as a new function). We proposed this solu-
tion to the PHP development team which informed us
that the development overhead would be too big for
supporting such a function and the solution of using
openssl random pseudo bytes() (which requires
OpenSSL) is their recommendation.
On the other hand, administrators can take a num-
ber of precautions to defend against randomness at-
tacks using current PHP versions. The Suhosin ex-
tension provides a secure seed in the mt rand() and
rand() functions. The seed exploits the fact that the
Mersenne Twister has a large state and ﬁlls that state
using a hash function. Because rand() may have a
small state and is dependent from the operating sys-
tem, the Suhosin extension replaces rand() with a
Mersenne twister generator with a different state from
mt rand(). The hashed values of the seed used are
a concatenation of predictable values such as process
identiﬁers and timestamps, along with, potentially, un-
predictable ones such as memory addresses of vari-
ables and input from /dev/urandom. Because the
addresses in any modern operating system are ran-
domized through ASLR, as a security precaution, us-
ing them as a seed should provide enough additional
entropy to make the two seed attacks (sections 4.2,
4.3) infeasible (assuming ASLR addresses are un-
predictable).
In addition, the suhosin extension ig-
nores the calls to the seeding functions mt srand(),
srand() in order to defend against weak seeding from
the application. Although this may introduce a state re-
covery vulnerability, in the majority of our case stud-
ies, custom seeding was pretty weak and this mea-
sure (of securely seeding once and ignoring applica-
tion based reseeding) increases security. We strongly
believe that securely seeding the generators, when pos-
sible, is a very useful exploit mitigation for the attacks
we presented. Although state recovery attacks would
still be possible, these attacks are more complex than
the seed attacks which require a handful of requests
and commodity hardware to compromise the applica-
tions. Furthermore, creating a secure seed from such
sources has a negligible performance overhead. There-
fore, such measures should be employed by the PHP
system as safeguards for applications that misuse the
PHP core PRNGs.
Our session preimage attack (section 4.1) can be
mitigated by utilizing an option (disabled by default)
of PHP to add extra entropy, from a ﬁle, in the ses-
sion identiﬁer. By specifying /dev/urandom as the
entropy ﬁle, a user can increase the entropy of a
session arbitrarily thus making it infeasible for an
attacker to obtain a preimage.
In Windows, be-
cause /dev/urandom is not available this option
gathers entropy using the same algorithm as in the
openssl random pseudo bytes() function.
The
PHP developement team informed us that the above
option will be enabled by default in the upcoming ver-
sion, PHP 5.4.
The above workarounds, if employed, will kill our
seed attacks and the generic process distinguisher we
devised. However, state recovery attacks would still be
possible either through some application speciﬁc leak,
or using the generic technique described for Windows
operating systems (section 5.2). In addition, we ﬁnd
the possibility of the existence of other process distin-
guishers very probable; after all, the process identiﬁer
is not considered a cryptographic secret and could be
leaked either through the application or the web server
or even the operating system itself. Therefore, we feel
that even using these workarounds, one should con-
sider state recovery attacks practical.
With the present state of the PHP system, developers
should avoid using directly the PRNGs of the PHP core
for security purposes. Any application that requires
a security token should employ a custom generator,
that will either use the functions from the PHP exten-
sions such as the openssl random pseudo bytes(),
if available, or it will use other entropy sources. We
give an example of one such function in [1].
8 Related Work
The ﬁrst randomness attack in PHP that we are aware
of appeared in a blog post by Stefan Esser [5, 6], where
he described basic system properties such as keep-
alive connection handling by web server processes,
and described how misusing mt srand() could re-
sult in security vulnerabilities that he demonstrated in
some popular applications. Shortly after, the same
author released an update of the Suhosin extension
which included the randomness features for strong
seeding mentioned above. Our preimage attack on
PHP sessions was insipired by an attack introduced by
Samy Kamkar [10], in which he described some cases
where an adversary would be able to guess a PHP ses-
sion. However these attacks assumed a side-channel
of server information. Finally Gregor Kopf [11] de-
scribed, along other attacks, the vulnerability in the
password reset implementation of Joomla. This work
describes some type of seed recovery attacks but only
15
for the case that a fresh seeding occurs within the PHP
script executed.
9 Conclusions
We ﬁnd the fact that the most popular programming
language in a domain that has a clear need for cryp-
tographically strong randomness does not have such a
generator within its core system to be a security hazard.
Still, even if such a generator existed in the language,
the misuse of other functions would not disappear im-
mediately as API misusage is a very common security
problem in modern systems. Therefore, we believe
that research in the practical exploitation of such in-
secure functions should be continued and extended to
other environments even if they do offer better secu-
rity features in their API than PHP. In this paper we
explored the case of PHP installed in the Apache web
server along with mod php. We also showed the ap-
plicability of some of our attacks in cgi mode where
each request is handled by a new process. However,
the case of fast cgi needs further investigation as its
behavior depends highly on its conﬁguration. In addi-
tion, it would be interesting to check other languages
and web servers, such as PHP on an IIS web server, or
Python and Ruby on Rails web applications in Apache.
A problem that is also of theoretical interest is the
development of faster algorithms for recovering trun-
cated linear variables and ﬁnding an explanation for
the logarithmic barrier we encountered when experi-
menting with the H˚astad-Shamir framework. To con-
clude, despite the fact that linear generators are cryp-
tographically insecure, the fact that developers misuse
them for security critical features makes the analysis
of their practical security within a certain application
context an interesting research question which we be-
lieve needs further attention and awareness.
References
[1] George Argyros and Aggelos Kiayias.
I forgot
your password: randomness attacks against php
applications.
http://crypto.di.uoa.gr/
CRYPTO.SEC/Randomness_Attacks.html,
2012.
[2] Unknown
Author.
openssl random pseudo bytes()
painfully
slow.
https:
//bugs.php.net/bug.php?id=51636, 2010.
PHP Bug
51636,
#
[3] Scott Contini and Igor Shparlinski. On stern’s
attack against secret
truncated linear congru-
ential generators.
In Colin Boyd and Juan
Manuel Gonz´alez Nieto, editors, ACISP, vol-
ume 3574 of Lecture Notes in Computer Science,
pages 52–60. Springer, 2005.
16
[4] Stefan Esser. Joomla weak random password re-
set token vulnerability. SektionEins GmbH, Se-
curity Advisory 2008/09/11, 2008.
[5] Stefan Esser. Lesser known security problems in
php applications. In Zend Conference, 2008.
[6] Stefan
Esser.
random
numbers.
so
www.suspekt.org/2008/08/17/mt_
srand-and-not-so-random-numbers/,
2008.
mt srand
not
and
http://
[7] Oded Goldreich, Shaﬁ Goldwasser, and Silvio
Micali. How to construct random functions. J.
ACM, 33(4):792–807, 1986.
[8] Johan H˚astad and Adi Shamir. The cryptographic
security of truncated linearly related variables. In
Robert Sedgewick, editor, STOC, pages 356–362.
ACM, 1985.
[9] Robert ”Hackajar” Imhoff-Dousharm.
Eco-
nomics of password cracking in the gpu era. In
DEFCON 19, 2011.
[10] Samy Kamkar. phpwn: Attacking sessions and
In Blackhat
pseudo-random numbers in php.
USA, Las Vegas, NV 2010, 2010.
[11] Gregor Kopf. Non-obvious bugs by example.
In 27th Chaos Communication Congress CCC,
2010.
[12] Henrik Koy and Claus-Peter Schnorr. Segment
lll-reduction of lattice bases.
In Joseph H. Sil-
verman, editor, CaLC, volume 2146 of Lec-
ture Notes in Computer Science, pages 67–80.
Springer, 2001.
[13] A.K. Lenstra, H.W.jun. Lenstra, and L´aszlo
Lov´asz. Factoring polynomials with rational co-
efﬁcients. Math. Ann., 261:515–534, 1982.
[14] Arjen K. Lenstra, James P. Hughes, Maxime
Augier, Joppe W. Bos, Thorsten Kleinjung, and
Christophe Wachter.
Ron was wrong, whit
IACR Cryptology ePrint Archive,
is right.
2012:064, 2012.
[15] Makoto Matsumoto and Takuji Nishimura.
Mersenne twister: A 623-dimensionally equidis-
tributed uniform pseudo-random number genera-
tor. ACM Trans. Model. Comput. Simul., 8(1):3–
30, 1998.
[16] HD Moore and Valsmith. Tactical exploitation.
In DEFCON 15, 2007.
[17] Jacques Stern. Secret linear congruential gener-
ators are not cryptographically secure. In FOCS,
pages 421–426. IEEE Computer Society, 1987.