The performance of the proof-of-service protocol can be
further accelerated. We introduce parallelism in handling
multiple blocks concurrently. We require every acknowl-
edgment to include digests of the last m encrypted blocks,
and the server will verify whether the recipient received the
correctly encrypted blocks for last m blocks (instead of just
last one block). Meanwhile, upon the receipt of block key
i+1{bi+1}), r will
r
r
i and the encrypted block bi+1 (i.e. k
k
ﬁrst acknowledge the receipt of bi+1 before proceeding to
step 8. With this design, it can repeat this prompt acknowl-
edgment process for the next m − 1 blocks, greatly improv-
In case that block bi is discovered
ing the performance.
corrupted, the provider will still not able to have a proof
that it successfully delivered bi—since the proof must show
correct digests of all last m blocks. Here, we want to select
m such that it is small to be scalable, but large enough to
keep high level of parallelism.
Throughout the whole design, the server’s load has been
kept very light. A provider can wait until the end of serving
a recipient to present a single proof of its service toward
this client. Also, the only type of query that a recipient
can issue is to verify or retrieve the block key of a block it
receives from a provider (see discussion on step 7 above),
which happens only once per recipient-provider pair.
5 Discussion
mSSL is conﬁgurable to support different needs. In this
section, we ﬁrst discuss how different security functionali-
ties of mSSL can be combined. We then look at possible at-
tacks against mSSL and suitable countermeasures. Finally,
we look at the limits of mSSL.
5.1 Combining Security Functionalities
Using A, C, I, and P to represent the four primary se-
curity functions that mSSL provides—client authentication,
conﬁdentiality, integrity, and proof of service, below we
show their totally six meaningful combinations.
Considering a data object O at a server S, we ﬁrst look
at requiring just one of the four:
• A: Some clients are allowed to access O, some are not.
A client thus must authenticate itself.
• I: Every client can obtain O, but needs to ensure the in-
tegrity of O. Here, S offers O for everyone, so no conﬁ-
dentiality or client authentication are needed.
• C: Conﬁdentiality of O is required. If so, A must also be
utilized to make sure the encrypted O is delivered only to
authorized clients. So C implies AC.
• P : Proof of service is required. Note P must be com-
bined with A: a recipient needs a certiﬁcate for its pub-
lic key, thus it must ﬁrst authenticate itself; the server
Proceedings of the 21st Annual Computer Security Applications Conference (ACSAC 2005) 
1063-9527/05 $20.00 © 2005 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 12:14:11 UTC from IEEE Xplore.  Restrictions apply. 
must also authenticate a provider before it can verify the
provider’s proof of its service to others. P must also be
provided together with I: in the proof of service design, a
recipient needs to verify the integrity of a received block.
On the other hand, P includes its own method of encryp-
tion, thus C is not needed. Therefore, enforcing P implies
enforcing A, I, and P all together, i.e. AIP , but not C.
Now we consider possible combinations of two of the
four functions. A two-function combination cannot have P ,
since P implies AIP . C already implies AC. So the only
new combination possible is AI. Furthermore, the only new
combination with three of the four primaries is AIC. We
will not have a combination of all four, AICP , since P
implies not using C.
Therefore, we have totally six scenarios: A, I, C (i.e.
AC), P (i.e. AIP ), AI, and AIC.
Every mSSL application may have its own needs and
thus choose a speciﬁc scenario. (Note that except for the
I scenario, every scenario requires A, meaning every client
must authenticate itself to its server.) For example, the
I scenario can be useful when a server is providing criti-
cal public information and all that is needed is to guaran-
tee the integrity of the data. The AIC scenario may be
chosen when encrypted data sharing using C is not sufﬁ-
cient; sometimes even if a recipient can decrypt data from a
provider successfully, it may not trust the provider and still
want to verify the integrity to make sure the data is indeed
unaltered from the server’s original.
5.2 Preventing Attacks
The integrity solution of mSSL can be invoked to ensure
that every block of the data object is authentic, even without
authentication invoked at the server. Since every client can
obtain a signed root value of the Merkle hash tree of the
data object, and the authentication path of every block, any
modiﬁcation of the block by anyone will cause the block
to fail the integrity veriﬁcation process. Moreover, mSSL
allows a data object to be transmitted in its encrypted form
to provide conﬁdentiality. The attack against the proof-of-
service scheme is probably the most complicated; we focus
on this attack in the following.
Generally speaking, two types of proof-of-service at-
tacks may occur: individual cheating and colluded cheat-
ing. An individual client may cheat by misreporting the
amount of services it has received or provided. Or, multiple
clients may work in collusion, forging false proofs of ser-
vice together. Both types are for the purpose of obtaining
non-deserved credits from the server.
• Individual Cheating: An individual client can cheat in
the following ways: (1) A provider overstates its service
for extra credit from the server. It claims that it sent an-
other client certain data although it did not. (2) A recipient
deliberately refuses to acknowledge its receipt of speciﬁc
data blocks from another provider, so that the provider
cannot show the proof of serving those blocks.
The proof-of-service design in mSSL addresses both
methods of cheating above. For the ﬁrst type of cheat-
ing, from Section 4 we know that every proof is a signed
acknowledgment from a recipient. A provider does not
know the key other clients use to sign acknowledgments,
so it cannot forge any. For the second type of cheating,
note that if a recipient denies its reception of a data block,
it will not generate an acknowledgment for the block;
without the acknowledgment, it will not be able to receive
the secret block key to decrypt the block. So this cheating
is also not possible.
• Colluded Cheating:
In order to obtain extra non-
deserved credits, multiple clients may collude to forge
proofs of services that did not actually take place. We
list several cases here: (1) A provider forges a proof that it
provided itself certain data. (2) While a recipient r sends
acknowledgments to its real provider p1, it also sends
a copy of every acknowledgment to its accomplices a1,
a2,. . . , an. Or, r can just copy the acknowledgment that
conﬁrms the largest number of received blocks. Then a1,
a2,. . . , an can all claim that they delivered certain data
blocks to r, even though they did not at all. (3) Two clients
r and p collude to forge a proof that p provided certain
data to r.
To counteract cases (1) and (2), note the proof-of-service
design of mSSL allows a server to determine whether a
proof is indeed about the service from a speciﬁc client p
to another speciﬁc client r. A proof must be signed by
the recipient, and it contains the digest of last one or sev-
eral encrypted blocks that a provider has served (Equa-
tion 2), and the encryption uses a key that is speciﬁc to the
provider ((Equation 1). In case (1), the server will ﬁnd out
that it is a proof of self-service; in case (2), the server will
detect that only the proof from p1 is trustworthy.
Case (3) is the most difﬁcult since the server cannot tell
whether or not a service has occurred. If a recipient must
pay for every copy of data it receives, even including re-
dundant copies, an economical countermeasure can be de-
signed. This way, while the colluding provider p may gain
undeserved credit, the colluding recipient r will be penal-
ized since it will be charged for the forged service.
5.3 The limit of mSSL
When a server and a client establish a SSL channel, they
can interact with each other through the channel, includ-
ing allowing the client to provide certain information to the
Proceedings of the 21st Annual Computer Security Applications Conference (ACSAC 2005) 
1063-9527/05 $20.00 © 2005 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 12:14:11 UTC from IEEE Xplore.  Restrictions apply. 
server. Not necessarily for mSSL: mSSL is designed not for
two-way data transfer, but for securely and efﬁciently shar-
ing a server’s data among peer clients. Note that mSSL does
not conﬂict with SSL, and an mSSL application can have its
clients use SSL to interact with a server, and use mSSL to
have those clients share data.
Certain security issues that already exist in the tradi-
tional client-server model are not addressed by mSSL. For
instance, SSL does not guarantee that a client that receives
data from a SSL channel will not divulge the data to others
(this issue could be potentially addressed by various dig-
ital rights management approaches). Neither does mSSL
whereas it aims to ensure that security is not weakened com-
pared to the client-server model.
In addition to the security functionalities presented in
this paper, other functionalities may also be needed. For ex-
ample, a security function that prevents trafﬁc analysis may
be necessary if users are concerned that an attacker may
know that the same encrypted object is being transferred be-
tween clients during different sessions. mSSL is extensible
and more functionalities can be added in the future.
6 Evaluation
6.1 Overview—Goal, Metrics, and Methods
The goal of measuring mSSL is to obtain the overhead
of using mSSL in different scenarios to see whether the
overhead of mSSL is acceptable overall, and to compare
the overhead among different scenarios.
The metrics we used to evaluate mSSL include:
• Server capacity: The number of client requests a server
can successfully process per time unit.
• File downloading time: The latency from the time a client
initiates a connection with a server to the time that the
client receives the whole ﬁle.
• Storage overhead: The space a client or a server needs in
order to store mSSL-related information.
• Control trafﬁc volume: The volume of control trafﬁc
when mSSL is in place.
For every metric, we evaluate mSSL under one of the six
scenarios introduced in Section 5.1, plus a none scenario in
which no security functionalities are provided except that
the mSSL infrastructure is in place. The none scenario is
useful to measure the overhead of the mSSL framework. We
thus have a total of seven scenarios for evaluating mSSL:
none, A, I, C (i.e. AC), P (i.e. AIP ), AI, and AIC.
We have implemented mSSL in Java and tested it in our
laboratory. Furthermore, we have also implemented a ﬁle-
sharing application which can invoke mSSL for its secu-
rity needs. With this application, a client can either directly
download a ﬁle from a server, or download it from providers
that have a copy of the ﬁle. The client can ask the server for
a list of provider clients, and can become a provider after
it obtains the ﬁle. We adopted 3DES (112-bit key length)
for classical cryptography, RSA (1024-bit key length) for
public key cryptography, and MD5 for hashing algorithms.
When mSSL is in direct mode, it will essentially incur
the same cost as SSL. Our evaluation of mSSL will focus
on its indirect access mode when a client needs to down-
load data objects from provider clients. We use experiments
to collect results and perform analysis for server capacity
and ﬁle downloading time, and analyze the storage over-
head and control trafﬁc volume through calculations.
6.2 Server Capacity
We measured the server capacity as following. We con-
nected a client machine (a machine running Linux 2.4.20-
20.9smp with dual 2.4 GHz Pentium IV processors and
1 GB memory) and a server machine (an iBook running
OSX with a 700 MHz processor and 384 MB memory)
through a 100 Mbps link. Then for every one of seven sce-
narios to study, we had the client ﬂood the server with ﬁle
downloading requests (each with the same security require-
ments), and recorded how many such requests the server
was able to serve over an extended period. To make sure
the server reached full capacity, we made sure that the client
machine was lightly loaded (note that the client machine is
much more powerful than the server machine), the band-
width usage between the two was far from saturated, and
the server’s CPU usage reached 100%.
Figure 5 shows the results. We can see that introduc-
ing new security functionalities does invite extra overhead;
however, such overhead is acceptable. For example, while
under the none scenario, the server capacity averages 465
requests per minute. Adding integrity does not affect the
e
t
u
n
m
i
r
e
p
s
t
s
e
u
q
e
r
f
o
r
e
b
m
u
N
 500
 400
 300
 200
 100
 0
none
I
A
AI
AC
AIC
AIP
Scenarios
Figure 5. Server capacity
Proceedings of the 21st Annual Computer Security Applications Conference (ACSAC 2005) 
1063-9527/05 $20.00 © 2005 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 12:14:11 UTC from IEEE Xplore.  Restrictions apply. 
server capacity since no extra data-integrity-related opera-
tions are needed at the server. If requiring client authenti-
cation, the server capacity will become approximately 22%
less. Server capacity decreases another 6% if also requiring
conﬁdentiality. Finally, if proof of service is also required,
server capacity will decrease another 13%.
6.3 File Downloading Time
In measuring mSSL’s impact on downloading ﬁles from
one or multiple providers, the server is the same machine
as in Section 6.2, and every client is a Dell Latitude D810
machine running Linux 2.6.9-ck3 with a 1.73 GHz Pentium
M processor and 512 MB memory, all connected over a 100
Mbps Ethernet. We have found that increasing the number
of providers of a recipient will linearly increase the down-
loading speed. In the following, we report the measurement
results for the case with one provider, and compare the im-
pact under all different scenarios.
File downloading time includes a startup latency, which
is the time that a client spends in handshaking with the
server before sending out a request for the ﬁrst block of
a ﬁle, and data transferring time, which is the rest of ﬁle
downloading time. We report the results for each.
Our measurements show that the startup latency is not
related to the size of a ﬁle, but different scenarios will have
different startup latency. Figure 6 shows that compared
to the none scenario, further requiring client authentica-
tion, integrity, conﬁdentiality, or their combinations, will
not cause a measurable increase of the startup latency, but
requiring proof of service will lengthen the startup latency
more signiﬁcantly.
)
s
(
y
c
n
e
t
a
L
p
u
t
r
a
S
t
 1.2
 1
 0.8
 0.6
 0.4
 0.2
 0
none
I
A
AI
AC
AIC
AIP
Scenarios
Figure 6. Startup latency
Unsurprisingly, our measurements also show that data
transferring time is proportional to the size of a ﬁle. In the
following, we focus on the difference of data transferring
time between different scenarios.
Figure 7 shows how each basic scenario (which consists
of a single mSSL security function) may slow down the
downloading speed. The impact from adding client authen-
tication and/or conﬁdentiality is almost negligible; except
for a few extra operations, transferring encrypted data or
non-encrypted data does not make a difference in terms of
transferring time, and data encryption and decryption oper-
ations can be done off-line. There is a slight decrease of
downloading speed when adding integrity veriﬁcation. Re-
call that a recipient needs to request integrity path informa-
tion (Section 3). The proof of service function has a more
signiﬁcant impact; for example, with this function turned
on, downloading a 32M B ﬁle will require 63 seconds com-
pared to the 45 seconds needed in the none scenario.
none
I
A
C
P
 80