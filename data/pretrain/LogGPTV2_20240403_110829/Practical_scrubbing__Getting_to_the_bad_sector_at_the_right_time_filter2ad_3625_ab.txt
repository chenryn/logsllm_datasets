### 优化后的文本

#### 服务时间对比
下图展示了不同SCSI VERIFY大小下的服务时间。对于Hitachi UltraStar和Fujitsu MX硬盘，分别进行了顺序和交错擦除操作的性能测试。

**图4. 不同SCSI VERIFY大小的服务时间**
- (a) 请求大小（128个区域）
- (b) 区域数量（64KB请求）

从图5b中的实线可以看出，随着区域数量从两个增加到512个，交错擦除器的吞吐量持续增加。当只有一个区域时，交错擦除器的行为与顺序擦除器相同。为了回答我们的原始问题——即交错擦除器的性能如何与顺序擦除器相比——图5b中的虚线表示使用64KB请求的顺序擦除器的吞吐量。有趣的是，当区域数量超过128个时，我们发现交错擦除器的表现与顺序擦除器相当或更好。这一趋势在不同容量的驱动器上均被观察到，表明它与磁盘容量无关。为了验证该趋势在更大请求大小下的适用性，我们在图5a中绘制了交错擦除器在固定128个区域下的吞吐量随请求大小的变化情况。由于交错擦除对平均无故障时间(MLET)的影响相对较小[4]，我们建议使用相对于磁盘容量较小的区域大小。为了获得保守的结果，在后续实验中我们将区域数量固定为128个。

交错擦除器可以优于顺序擦除器的现象可能看似反直觉。然而，由于VERIFY操作避免了数据传输到控制器或磁盘缓存，当一个顺序擦除请求完成后，下一个请求将不得不从介质表面开始服务。此时，磁头已经沿着轨道移动了一段距离，而VERIFY结果则传递给了控制器。因此，当下一个VERIFY请求启动时，磁头需要等待一整个盘片旋转周期才能到达正确的扇区。对于交错擦除器来说，这只是最坏的情况。但是，当区域过大（总数少于64个）时，跳跃区域间的开销会超过旋转延迟带来的开销。我们通过实验验证了这一假设，即在连续擦除请求之间引入小于旋转延迟的间隔。正如预期的那样，只有交错擦除器受到了这种延迟的影响。

#### 擦除对合成工作负载的影响
接下来，我们评估了擦除对两种简单合成前台工作负载的性能影响。第一种是具有高度顺序性的负载：它随机选择一个扇区并使用64KB请求读取接下来的8MB数据。一旦块的最后一个请求完成，它将继续选择另一个随机扇区并重新开始。第二种是随机负载，它从磁盘中读取随机的64KB数据块。对于这两种工作负载，我们在请求之间插入了平均时间为100毫秒的指数分布思考时间，以便允许擦除器利用空闲间隔。在所有情况下，我们直接向磁盘发送请求，绕过操作系统缓存。

我们使用64KB擦除请求对交错和顺序擦除器进行实验，这些请求代表了最小化碰撞影响的最佳情况。我们以两种常见的方式调度擦除请求：一种是通过CFQ连续发出擦除请求，并使用Idle优先级来限制其对前台工作负载的影响；另一种是使用Default优先级，并通过在擦除请求之间引入0-256毫秒的延迟来限制擦除器的速率（任何更大的延迟会导致每两周擦除少于320GB的数据）。

图6a显示了顺序工作负载的结果。我们观察到，最高的综合吞吐量是在CFQ下实现的（其中擦除器连续提交请求），但这是以显著降低前台应用程序吞吐量为代价的：与前台工作负载单独运行相比，吞吐量下降了20.6%。当在擦除请求之间插入足够大的延迟（≥ 16ms）而不是使用CFQ来限制擦除器的影响时，我们发现前台工作负载的吞吐量与没有擦除器的情况相当。然而，在这些情况下，擦除器的吞吐量大大降低，从CFQ下的9MB/s降至延迟超过16ms时的不到3MB/s。作为次要结果，我们注意到在足够小的区域（这里为128个）下，交错擦除器和顺序擦除器之间没有明显差异。

图6b显示了随机工作负载的结果：为了实现与系统中没有擦除器时相当的应用程序吞吐量，需要大到足以严重降低擦除器吞吐量的延迟。注意，随机工作负载会增加额外的寻道，从而降低擦除器的吞吐量。

#### 擦除对真实工作负载的影响
为了实验更现实的工作负载，我们重放了来自HP Cello和MSR Cambridge集合的真实I/O跟踪记录。我们总共处理了77个磁盘跟踪记录，涵盖了从一周到一年的时间跨度（我们在实验中只使用了一周的数据）。这些跟踪记录涵盖了几乎所有可能的场景：家庭目录、项目目录、Web服务器、打印服务器、代理服务器、备份等。尽管我们在本文的其他部分对几乎所有磁盘进行了实验，但在展示结果时我们主要关注每个跟踪集合中的四个磁盘。这些磁盘包含每周最多的请求数量，并代表了多样化的工作负载。所选跟踪记录的特征总结在表I中。

**表I. 本文使用的SNIA块I/O跟踪**

| 跟踪 | 磁盘 | 请求描述 | 请求数 |
| --- | --- | --- | --- |
| MSR Cambridge (2008) | src11 | 源代码控制 | 45,746,222 |
| MSR Cambridge (2008) | usr1 | 家庭目录 | 45,283,980 |
| MSR Cambridge (2008) | proj2 | 项目目录 | 29,266,482 |
| MSR Cambridge (2008) | prn1 | 打印服务器 | 11,233,411 |
| HP Cello (1999) | c6t8d0 | 新闻磁盘 | 9,529,855 |
| HP Cello (1999) | c6t5d1 | 项目文件 | 4,588,778 |
| HP Cello (1999) | c6t5d0 | 家庭目录 | 3,365,078 |
| HP Cello (1999) | c3t3d0 | 根目录和交换分区 | 2,742,326 |
| TPC-C (2009) | disk66 | TPC-C运行 | 513,038 |
| TPC-C (2009) | disk88 | TPC-C运行 | 513,844 |

图7展示了擦除器对其中一个更现实的工作负载的影响，通过绘制应用程序请求响应时间的累积分布函数。为了提高可读性，我们仅包括四种不同情况的结果：无擦除器；通过CFQ的Idle优先级类连续发出擦除请求；以及在擦除请求之间有0ms和64ms延迟的情况。我们再次观察到与合成工作负载类似的结果。即使通过CFQ降低优先级，连续发出擦除请求也会严重影响前台请求的响应时间。另一方面，当擦除请求之间的延迟足够大以限制对前台工作负载的影响时（64ms），擦除器的吞吐量下降了一个数量级以上（每个实验的擦除器吞吐量包括在图7的图例中）。如前所述，交错擦除器和顺序擦除器的结果相同。这些结果促使我们寻找更复杂的擦除请求调度方法。

### 何时进行擦除
第四节的实验表明，仅仅依赖CFQ来调度擦除请求，或者以固定速率发出擦除请求，既不能最小化对前台流量的影响，也不能最大化擦除器的吞吐量。这促使我们在本节中考虑更复杂的擦除请求调度方法。通过对I/O跟踪的统计分析，我们识别出一些有助于确定最佳擦除时机的统计属性。

**图8. 四个磁盘的请求活动（来自HP Cello和MSR Cambridge跟踪）**

从图8中可以看出，四个磁盘的请求活动在一天中的不同时间段内表现出不同的模式。这些模式可以帮助我们更好地安排擦除请求，以减少对前台流量的影响。