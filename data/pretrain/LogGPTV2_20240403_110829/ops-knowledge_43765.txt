User: One difference is that "./script.py" only works if script.py is executable (as in file permissions), but "python script.py" works regardless. However, I strongly suspect there are more differences, and I want to know what they are.
I have a Django website, and "python manage.py syncdb" works just fine, but "./manage.py syncdb" creates a broken database for some reason that remains a mystery to me. Maybe it has to do with the fact that syncdb prompts for a superuser name and password from the command line, and maybe using "./manage.py syncdb" changes the way it interacts with the command line, thus mangling the password. Maybe? I am just baffled by this bug. "python manage.py syncdb" totally fixes it, so this is just curiosity.
Thanks.
Edit: Right, right, I forgot about the necessity of the shebang line #!/usr/bin/python. But I just checked, "python manage.py syncdb" and "./manage.py syncdb" are using the same Python interpreter (2.7.2, the only one installed, on Linux Mint 12). Yet the former works and the latter does not.
Could the environment variables seen by the Python code be different? My code does require $LD_LOADER_PATH and $PYTHON_PATH to be set special for each shell.
Assistant: In Linux using terminal you can execute any file -if the user has execute permission- by typing 
./fileName. When the OS sees a valid header like #! /usr/bin/python (or for perl #! /usr/bin/python), It will call the python or perl (appropriate) interpreter to execute the program. You can use the command python script.py directly because, python is a executable program located at /usr/bin (or somewhere else) which is in a environmental variable $PATH,
that corresponding to directory of executables.