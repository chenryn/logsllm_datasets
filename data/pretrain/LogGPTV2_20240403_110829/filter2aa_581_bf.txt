client can use either the SAML or JWT assertion to authenticate.
In addition to the preceding measures, we can also cryptographically bind the OAuth 
2.0 access/refresh tokens and authorization codes to a given TLS channel—so those 
cannot be exported and used elsewhere. There are few specifications developed under 
the IETF Token Binding working group to address this aspect.
The Token Binding Protocol, which we discussed in Chapter 11, allows client/server 
applications to create long-lived, uniquely identifiable TLS bindings spanning multiple 
TLS sessions and connections. Applications are then enabled to cryptographically bind 
security tokens to the TLS layer, preventing token export and replay attacks. To protect 
privacy, the Token Binding identifiers are only conveyed over TLS and can be reset by 
the user at any time.
Chapter 14  Oauth 2.0 SeCurity
298
The OAuth 2.0 Token Binding specification (which we discussed in Chapter 11) 
defines how to apply Token Binding to access tokens, authorization codes, and refresh 
tokens. This cryptographically binds OAuth tokens to a client’s Token Binding key pair, 
the possession of which is proven on the TLS connections over which the tokens are 
intended to be used. The use of Token Binding protects OAuth tokens from man-in-the-
middle, token export, and replay attacks.
 Open Redirector
An open redirector is an endpoint hosted on the resource server (or the OAuth 2.0 client 
application) end, which accepts a URL as a query parameter in a request—and then 
redirects the user to that URL. An attacker can modify the redirect_uri in the authorization 
grant request from the resource server to the authorization server to include an open 
redirector URL pointing to an endpoint owned by him. To do this, the attacker has to 
intercept the communication channel between the victim’s browser and the authorization 
server—or the victim’s browser and the resource server (see Figure 14-3).
Once the request hits the authorization server and after the authentication, the user 
will be redirected to the provided redirect_uri, which also carries the open redirector 
query parameter pointing to the attacker’s endpoint. To detect any modifications to 
the redirect_uri, the authorization server can carry out a check against a preregistered 
URL. But then again, some authorization server implementations will only worry about 
the domain part of the URL and will ignore doing an exact one-to-one match. So, any 
changes to the query parameters will be unnoticed.
Chapter 14  Oauth 2.0 SeCurity
299
Once the user got redirected to the open redirector endpoint, it will again redirect 
the user to the value (URL) defined in the open redirector query parameter—which will 
take him/her to the attacker’s endpoint. In this request to the attacker’s endpoint, the 
HTTP Referer header could carry some confidential data, including the authorization 
code (which is sent to the client application by the authorization server as a query 
parameter).
How to prevent an open redirector attack:
• 
Enforce strict validations at the authorization server against the 
redirect_uri. It can be an exact one-to-one match or regex match.
• 
Validate the redirecting URL at open redirector and make sure you 
only redirect to the domains you own.
Figure 14-3. Open Redirector attack
Chapter 14  Oauth 2.0 SeCurity
300
• 
Use JWT Secured Authorization Request (JAR) or Pushed 
Authorization Requests (PAR) as discussed in Chapter 4 to protect the 
integrity of the authorization request, so the attacker won’t be able to 
modify the request to include the open redirector query parameter to 
the redirect_uri.
 Code Interception Attack
Code interception attack could possibly happen in a native mobile app. OAuth 2.0 
authorization requests from native apps should only be made through external user 
agents, primarily the user’s browser. The OAuth 2.0 for Native Apps specification 
(which we discussed in Chapter 10) explains in detail the security and usability 
reasons why this is the case and how native apps and authorization servers can 
implement this best practice.
The way you do single sign-on in a mobile environment is by spinning up the 
system browser from your app and then initiate OAuth 2.0 flow from there. Once the 
authorization code is returned back to the redirect_uri (from the authorization server) 
on the browser, there should be a way to pass it over to the native app. This is taken care 
by the mobile OS—and each app has to register for a URL scheme with the mobile OS. 
When the request comes to that particular URL, the mobile OS will pass its control to the 
corresponding native app. But, the danger here is, there can be multiple apps that get 
registered for the same URL scheme, and there is a chance a malicious app could get hold 
of the authorization code. Since many mobile apps embed the same client id and client 
secret for all the instances of that particular app, the attacker can also find out what they 
are. By knowing the client id and client secret, and then having access to the authorization 
code, the malicious app can now get an access token on behalf of the end user.
PKCE (Proof Key for Code Exchange), which we discussed in detail in Chapter 10, 
was introduced to mitigate such attacks. Let’s see how it works:
 1. The OAuth 2.0 client app generates a random number (code_
verifier) and finds the SHA256 hash of it—which is called the 
code_challenge.
 2. The OAuth 2.0 client app sends the code_challenge along with 
the hashing method in the authorization grant request to the 
authorization server.
Chapter 14  Oauth 2.0 SeCurity
301
 3. Authorization server records the code_challenge (against the 
issued authorization code) and replies back with the code.
 4. The client sends the code_verifier along with the authorization 
code to the token endpoint.
 5. The authorization server finds the hash of the provided code_
verifier and matches it against the stored code_challenge. If it does 
not match, rejects the request.
With this approach, a malicious app just having access to the authorization code 
cannot exchange it to an access token without knowing the value of the code_verifier.
 Security Flaws in Implicit Grant Type
The OAuth 2.0 implicit grant type (see Figure 14-4) is now obsolete. This was mostly used 
by single-page applications and native mobile apps—but no more. In both the cases, 
the recommendation is to use the authorization code grant type. There are few security 
flaws, as listed in the following, identified in the implicit grant type, and the IETF OAuth 
working group officially announced that the applications should not use implicit grant 
type any more:
• 
With implicit grant type, the access token comes as a URI fragment 
and remains in the web browser location bar (step 5 in Figure 14-4). 
Since anything the web browser has in the location bar persevered 
as browser history, anyone having access to the browser history can 
steal the tokens.
• 
Since the access token remains in the web browser location bar, the 
API calls initiated from the corresponding web page will carry the 
entire URL in the location bar, along with the access token, in the 
HTTP Referer header. This will let external API endpoints to figure 
out (looking at the HTTP Referer header) what the access token is 
and possibly misuse it.
Chapter 14  Oauth 2.0 SeCurity
302
 Google Docs Phishing Attack
An attacker used a fake OAuth 2.0 app called Google Docs as a medium to launch a 
massive phishing attack targeting Google users in May 2017. The first target was the 
media companies and public relations (PR) agencies. They do have a large amount of 
contacts—and the attacker used the email addresses from their contact lists to spread 
the attack. It went viral for an hour—before the app was removed by Google.
Is this a flaw in the OAuth 2.0 protocol exploited by the attacker or a flaw in how 
Google implemented it? Is there something we could have done better to prevent such 
attacks?
Figure 14-4. OAuth 2.0 implicit grant flow.
Chapter 14  Oauth 2.0 SeCurity
303
Almost all the applications you see on the Web today use the authorization code 
grant flow in OAuth 2.0. The attacker exploited step 3 in Figure 14-5 by tricking the user 
with an application name (Google Docs) known to them. Also, the attacker used an 
email template which is close to what Google uses in sharing docs, to make the user click 
on the link. Anyone who carefully looked at the email or even the consent screen could 
have caught up something fishy happening—but unfortunately, very few do care.
It’s neither a flaw of OAuth 2.0 nor how Google implemented it. Phishing is a 
prominent threat in cybersecurity. Does that mean there is no way to prevent such 
attacks other than proper user education? There are basic things Google could do to 
prevent such attacks in the future. Looking at the consent screen, “Google Docs” is the 
key phrase used there to win user’s trust. When creating an OAuth 2.0 app in Google, 
you can pick any name you want. This helps an attacker to misguide users. Google could 
easily filter out the known names and prevent app developers from picking names to 
trick the users.
Another key issue is Google does not show the domain name of the application (but 
just the application name) on the consent page. Having domain name prominently 
displayed on the consent page will provide some hint to the user where he is heading to. 
Also the image of the application on the consent page misleads the user. The attacker 
Figure 14-5. OAuth 2.0 authorization grant flow.
Chapter 14  Oauth 2.0 SeCurity
304
has intentionally picked the Google Drive image there. If all these OAuth applications 
can go through an approval process, before launching into public, such mishaps can be 
prevented. Facebook already follows such a process. When you create a Facebook app, 
first, only the owner of the application can log in—to launch it to the public, it has to go 
through an approval process.
G Suite is widely used in the enterprise. Google can give the domain admins more 
control to whitelist, which applications the domain users can access from corporate 
credentials. This prevents users under phishing attacks, unknowingly sharing access to 
important company docs with third-party apps.
The phishing attack on Google is a good wake-up call to evaluate and think about 
how phishing resistance techniques can be occupied in different OAuth flows. For 
example, Google Chrome security team has put so much effort when they designed the 
Chrome warning page for invalid certificates. They did tons of research even to pick the 
color, the alignment of text, and what images to be displayed. Surely, Google will bring 
up more bright ideas to the table to fight against phishing.
 Summary
• 
OAuth 2.0 is the de facto standard for access delegation to cater real 
production use cases. There is a huge ecosystem building around it—
with a massive adoption rate.
• 
Whenever you use OAuth, you should make sure that you follow and 
adhere to security best practices—and always use proven libraries 
and products, which already take care of enforcing the best practices.
• 
OAuth 2.0 Threat Model and Security Considerations (RFC 6819) 
produced by OAuth IETF working group defines additional security 
considerations for OAuth 2.0, beyond those in the OAuth 2.0 
specification, based on a comprehensive threat model.
• 
The OAuth 2.0 Security Best Current Practice document, which is a 
draft proposal at the time of writing, talks about new threats related 
to OAuth 2.0, since the RFC 6819 was published.
• 
The Financial-grade API (FAPI) working group under OpenID 
Foundation has published a set of guidelines on how to use OAuth 
2.0 in a secure way to build financial-grade applications.
Chapter 14  Oauth 2.0 SeCurity
305
© Prabath Siriwardena 2020 
P. Siriwardena, Advanced API Security, https://doi.org/10.1007/978-1-4842-2050-4_15
CHAPTER 15
Patterns and Practices
Throughout the book so far over 14 chapters and 7 appendices, we discussed different 
ways of securing APIs and the theoretical background behind those. In this chapter, we 
present a set of API security patterns to address some of the most common enterprise 
security problems.
 Direct Authentication with the Trusted Subsystem
Suppose a medium-scale enterprise has a number of APIs. Company employees are 
allowed to access these APIs via a web application while they’re behind the company 
firewall. All user data are stored in Microsoft Active Directory (AD), and the web 
application is connected directly to the Active Directory to authenticate users. The web 
application passes the logged-in user’s identifier to the back-end APIs to retrieve data 
related to the user.
The problem is straightforward, and Figure 15-1 illustrates the solution. You need to 
use some kind of direct authentication pattern. User authentication happens at the front- 
end web application, and once the user is authenticated, the web application needs to 
access the back-end APIs. The catch here is that the web application passes the logged-in 
user’s identifier to the APIs. That implies the web application needs to invoke APIs in a 
user-aware manner.
Since both the web application and the APIs are in the same trust domain, we only 
authenticate the end user at the web application, and the back-end APIs trust whatever 
data passed on to those from the web application. This is called the trusted subsystem 
pattern. The web application acts as a trusted subsystem. In such case, the best way 
to secure APIs is through mutual Transport Layer Security (mTLS). All the requests 
generated from the web application are secured with mTLS, and no one but the web 
application can access the APIs (see Chapter 3).
306
Some do resist using TLS due to the overhead it adds and rely on building a 
controlled environment, where security between the web application and the container 
that hosts APIs is governed at the network level. Network-level security must provide 
the assurance that no component other than the web application server can talk to the 
container that hosts the APIs. This is called the trust-the-network pattern, and over the 
time, this has become an antipattern. The opposite of the trust-the-network pattern is 
zero-trust network. With the zero-trust network pattern, we do not trust the network. 
When we do not trust the network, we need to make sure we have enforced security 
checks as much as closer to the resource (or in our case, the APIs). The use of mTLS to 
secure the APIs is the most ideal solution here.
 Single Sign-On with the Delegated Access Control
Suppose a medium-scale enterprise has a number of APIs. Company employees are 
allowed to access these APIs via web applications while they’re behind the company 
firewall. All user data are stored in Microsoft Active Directory, and all the web 
applications are connected to an identity provider, which supports Security Assertion 
Markup Language (SAML) 2.0 to authenticate users. The web applications need to access 
back-end APIs on behalf of the logged-in user.
Figure 15-1. Direct authentication with the trusted subsystem pattern
Chapter 15  patterns and praCtiCes
307
The catch here is the last statement: “The web applications need to access back-end 
APIs on behalf of the logged-in user.” This suggests the need for an access delegation 
protocol: OAuth 2.0. However, users don’t present their credentials directly to the web 
application—they authenticate through a SAML 2.0 identity provider.
In this case, you need to find a way to exchange the SAML token a web application 
receives via the SAML 2.0 Web SSO protocol for an OAuth access token, which is defined 
in the SAML grant type for the OAuth 2.0 specification (see Chapter 12). Once the web 
application receives the SAML token, as shown in step 3 of Figure 15-2, it has to exchange 
the SAML token to an access token by talking to the OAuth 2.0 authorization server.
Figure 15-2. Single sign-on with the Delegated Access Control pattern
The authorization server must trust the SAML 2.0 identity provider. Once the web 
application gets the access token, it can use it to access back-end APIs. The SAML grant 
type for OAuth 2.0 doesn’t provide a refresh token. The lifetime of the access token 
issued by the OAuth 2.0 authorization server must match the lifetime of the SAML token 
used in the authorization grant.
After the user logs in to the web application with a valid SAML token, the web 
application creates a session for the user from then onward, and it doesn’t worry about 
the lifetime of the SAML token. This can lead to some issues. Say, for example, the 
SAML token expires, but the user still has a valid browser session in the web application. 
Because the SAML token has expired, you can expect that the corresponding OAuth 
Chapter 15  patterns and praCtiCes
308
2.0 access token obtained at the time of user login has expired as well. Now, if the web 
application tries to access a back-end API, the request will be rejected because the access 
token is expired. In such a scenario, the web application has to redirect the user back 
to the SAML 2.0 identity provider, get a new SAML token, and exchange that token for 
a new access token. If the session at the SAML 2.0 identity provider is still live, then this 
redirection can be made transparent to the end user.
 Single Sign-On with the Integrated Windows 
Authentication
Suppose a medium-scale enterprise that has a number of APIs. Company employees 
are allowed to access these APIs via multiple web applications while they’re behind the 
company firewall. All user data are stored in Microsoft Active Directory, and all the web 
applications are connected to a SAML 2.0 identity provider to authenticate users. The 
web applications need to access back-end APIs on behalf of the logged-in user. All the 
users are in a Windows domain, and once they’re logged in to their workstations, they 
shouldn’t be asked to provide credentials at any point for any other application.
The catch here is the statement, “All the users are in a Windows domain, and once 
they’re logged in to their workstations, they shouldn’t be asked to provide credentials at 
any point for any other application.”
You need to extend the solution we provided using single sign-on (SSO) with the 
Delegated Access Control pattern (the second pattern). In that case, the user logs in 
to the SAML 2.0 identity provider with their Active Directory username and password. 
Here, this isn’t acceptable. Instead, you can use Integrated Windows Authentication 
(IWA) to secure the SAML 2.0 identity provider. When you configure the SAML 2.0 
identity provider to use IWA, then once the user is redirected to the identity provider for 
authentication, the user is automatically authenticated; as in the case of SSO with the 
Delegated Access Control pattern, a SAML response is passed to the web application. 
The rest of the flow remains unchanged.
Chapter 15  patterns and praCtiCes
309
 Identity Proxy with the Delegated Access Control
Suppose a medium-scale enterprise has a number of APIs. Company employees, as 
well as employees from trusted partners, are allowed to access these APIs via web 
applications. All the internal user data are stored in Microsoft Active Directory, and 
all the web applications are connected to a SAML 2.0 identity provider to authenticate 
users. The web applications need to access back-end APIs on behalf of logged-in users.
Figure 15-3. Identity proxy with the Delegated Access Control pattern
This use case is an extension of using SSO with the Delegated Access Control pattern. 
The catch here is the statement, “company employees, as well as employees from trusted 
partners, are allowed to access these APIs via web applications.” You now have to go 
beyond the company domain. Everything in Figure 15-2 remains unchanged. The only 
thing you need to do is to change the authentication mechanism at the SAML 2.0 identity 