exploitation techniques in varying implementations of an allo-
USENIX Association
29th USENIX Security Symposium    1121
Name Bug Impact Chunks # Txn Size
FD WF AC
{8}
O1 AW,RW Small
{128}
UU
Fast
{48}
AF AC
HS
Small
{128,256,512} M-M-M-F-O1N-M-M-F-F-M
PN
O1N OC
{100,1000}
Small
HL WF AC
{120,248,376} M-M-M-F-O1-M
OC
Small
O1 OC
{400}
UB WF AW,RW Small
M-M-F-WF-M
{56,248,512} M-M-O1-F-M
HE
Small
TxnList (A list of transactions)
M-M-F-WF-M-M
M-M-O1-F
AF-M
M-M-F-M-WF-M-M
Fast
8
6
4
12
9
8
7
7
O1 AC
# Txn: The number of transactions, M: malloc, F: free
Table 8: Exploit-specific models for known techniques from
HeapHopper. It is worth noting that the results of variants (i.e.,
techniques have same prerequisites, but different root causes) are
identical for ARCHEAP with no specific model (marked with † and
‡ in Table 9 and Table 10) since ARCHEAP neglects the number of
transactions (i.e., # Txn).
cator. Because of its goal, HeapHopper emphasizes complete-
ness and verifiability, differentiating its method (i.e., symbolic
execution) from ARCHEAP’s (i.e., fuzzing). To overcome the
state explosion in symbolic execution, HeapHopper tightly
encodes the prior knowledge of exploit techniques into its
models, e.g., the number of transactions (i.e., non-write ac-
tions in ARCHEAP), allocation sizes (i.e., guiding the use of
specific bins), and even a certain order of transactions. By
relying on this model, it could incrementally perform the
symbolic execution for all permutations of transactions. Un-
fortunately, its key idea—guiding the state exploration with
detailed models— limits its capability to only its original
purpose that validates known exploitation techniques, unlike
our approach can find unknown techniques.
Despite their different purposes, their outputs are equiva-
lent to heap exploitation techniques; therefore, we need to
show the orthogonality of ARCHEAP and HeapHopper; nei-
ther of them can replace the other. To objectively compare
both approaches, we performed three experiments: 1 finding
unknown techniques with no exploit-specific model (i.e., ap-
plying HeapHopper to ARCHEAP’s task), 2 finding known
techniques with partly specified models (i.e., evaluating the
roles of specified models in each approach), and 3 finding
known techniques with exploit-specific models (i.e., applying
ARCHEAP to HeapHopper’s task). In the experiments, we
considered variants of exploit techniques1 as an equal class
since both systems cannot distinguish their subtle differences.
We ran each experiment three times with a 24-hour timeout
for proper statistical comparison [40]. We used the default
option for HeapHopper since it shows the best performance
in the following experiments (see §A.2).
1 New techniques. We first check if HeapHopper’s ap-
proach can be used to find previously unknown exploita-
tion techniques that ARCHEAP found (see, §7.1). To apply
HeapHopper, we provided models that specify all sizes for
corresponding bins but limit the number of transactions fol-
lowing our PoCs, as shown in Table 9. Note that, in theory,
such relaxation is general enough to discover new techniques
given an infinite amount of computing resources. In the ex-
1Exploit techniques often have the same prerequisite but different root
causes such as UBS and HL.
1 New techniques
Name Bug Impact Chunks
# Txn
FDO WF AC
UBS WF AC
HUE O1 AC
OCS OV OC
UDF DF OC
Found
Fast, Large
Small
Small
Small
Small
6
9
9
9
ARCHEAP
T F O
µ
—
HeapHopper
σ T F O µ σ
3† 0 0 20.2m 5m 0 0 3 ∞ -
2‡ 0 1 14.4h 8.9h 0 0 3 ∞ -
3 0 0 17.3s 1.2s 0 0 3 ∞ -
3 0 0 19.9s 5.2s 0 0 3 ∞ -
11 0 1 ⇒ #4
0 0 12 ⇒ #0
T: True positives, F: False positives, O: Timeout,
µ: Average time, σ: Standard deviation of time
Table 9: The number of experiments (at most three) that discover
new exploitation techniques, the number of found techniques — the
number after hash (#) sign, elapsed time, and corresponding models.
Briefly, ARCHEAP discovered all four techniques, but HeapHopper
failed to. We omitted FDO, which has a superset model of FD;
therefore, it becomes indistinguishable to FD (see, Table 8).
periment, FDO is excluded because its model is a superset of
FD; having FDO simply makes ARCHEAP and HeapHopper
converge to FD.
HeapHopper fails to identify all unknown exploitation prim-
itives with no exploit-specific models (see Table 9). In fact,
it encounters a few fundamental problems of symbolic ex-
ecution: 1) exponentially growing permutations of transac-
tions and 2) huge search spaces in selecting proper size and
orders to trigger exploitation. Although HeapHopper demon-
strated a successful state exploration of seven transactions
with three size parameters (§7.1 in [17]), the search space
required for discovering new techniques is much larger, ren-
dering HeapHopper’s approach computationally infeasible.
On the contrary, ARCHEAP successfully explores the search
space using the random strategies, and indeed discovers un-
known techniques.
2 Known techniques with partly specified models. We
also evaluate the role of exploit-specific models in both ap-
proaches, which are unavailable in finding new techniques.
In particular, we evaluated both systems with partial mod-
els, namely, the size parameters (+Size) and a sequence of
transactions (+TxnList), used in HeapHopper (see, Table 8).
To prevent each system from converging to easy-to-find tech-
niques, we tested each model on top of the baseline heap
model (i.e., Bug+Impact+Chunks).
This experiment (i.e., 2 in Table 10) shows that ARCHEAP
outperforms HeapHopper with no or partly specified models:
ARCHEAP found five more known techniques than HeapHop-
per in both +Size and Bug+Impact+Chunks.
Interestingly,
ARCHEAP can operate worse with additional information;
ARCHEAP found three fewer techniques in +TxnList. Un-
like ARCHEAP, exploit-specific models are beneficial to
HeapHopper, finding one more techniques when +TxnList
is given. This result shows that a precise model plays an
essential role in symbolic execution but not in fuzzing. In
short, ARCHEAP is particularly preferable when exploring
unknown search space, (i.e., finding new techniques), where
an accurate model is inaccessible.
3 Known techniques with exploit-specific models When
1122    29th USENIX Security Symposium
USENIX Association
Name
ARCHEAP
HeapHopper
ARCHEAP
HeapHopper
ARCHEAP
HeapHopper
ARCHEAP
HeapHopper
Bug+Impact+Chunks
+Size
+TxnList
+Size, TxnList
2 Known techniques with partly specified models
3 Known techniques with exploit-specific models.
µ
µ
σ
T F O
µ
σ
T F O µ
T F O
FD
3 0 0 2.7m 1.2m 3 0 0 3.8m 0.3s 3 0 0 57.1s 27.1s 3 0 0 3.8m 0.9s 3 0 0 14.2m 4.3m 3 0 0 10.7m 2.1m 3 0 0 10.2m 7.2m 3 0 0 23.5s
∞
UU
0 3 0
0 3 0 8.2h
3 0 0 57.9m 40.4m 0 0 3
0 0 3
∞
HS
3 0 0
3 0 0 2.7m 59.7s 3 0 0 31.4s 0.2s 3 0 0 9.3m 6.1m 3 0 0 31.1s 0.2s 0 0 3
3 0 0 28.6s
PN
3 0 0 16.1m 14.9m 0 0 3
26m 12.6m 3 0 0 4.3m
3 0 0
3 0 0 13.3m 24.4s 0 0 3
57m 0 0 3
3† 0 0 20.2m 5m 0 0 3
HL
3 0 0 1.2m 47.3s 0 0 3
2 0 1 13.2h 8.5h 0 0 3
21m 9.4m 2 1 0 2.2m
OC
20s
3 0 0 3.2m
0 0 3
3 0 0
3 0 0
3 0 0
0 0 3
3 0 0 19.5s
3 0 0 21.9s 0.3s 3 0 0 24.8s 14.9s 3 0 0 47.6s
UB
4.7s
3 0 0 36.8s 22.8s 3 0 0 21.8s 0.2s 3 0 0
2‡ 0 1 14.4h
∞
∞
2 0 1
HE
9.3h
0 3 0 6.8m
0 0 3
23 0 1 ⇒ #8
Found 23 0 1 ⇒ #8
17 7 0 ⇒ #6
9 0 15 ⇒ #3
12 3 9 ⇒ #4
3 0 0 22.1h 33.2m 3 0 0 26.6s
3 0 0 12.6s
∞
0 0 3
15 0 9 ⇒ #5
3.2h 26.3m 0 0 3
0 0 3
56s
∞
3 0 0
∞
3 0 0
5.3s
3.1s
10.4h 0 0 3
∞
0 0 3
14 0 10 ⇒ #5
∞
9 0 15 ⇒ #3
8.9h 0 0 3
1.1h 0 0 3
∞
∞
1.6h
T F O
3 0 0
1.6h
T F O
T F O
34s
9.5s
-
7.1s
5.9s
6s
2.4s
∞
∞
∞
∞
∞
∞
∞
∞
σ
T F O µ
σ
T F O µ
σ
-
-
-
µ
σ
0.8s
0.3s
-
-
-
µ
σ
-
-
-
-
-
-
-
-
-
-
-
-
σ
0.2s
13m
0.2s
1.6s
8.2s
2s
0.7s
6.4s
Table 10: The number of discovered known exploitation techniques and elapsed time for discovery in ARCHEAP and HeapHopper with various
models. In summary, ARCHEAP outperforms HeapHopper with no or partly specified models, e.g., ARCHEAP found five more techniques
with no specific model (Bug+Impact+Chunks). Even though HeapHopper found one more technique than ARCHEAP if exploit-specific models
are available, it suffers from false positives (marked in gray).
exploit-specific models (+Size, TxnList) are provided,
HeapHopper’s approach works better: It found one more
known technique and found four techniques more quickly
than ARCHEAP (as illustrated in 3 in Table 10). This shows
the strength of HeapHopper in validating existing techniques,
rendering orthogonality of both tools. We observed one in-
teresting behavior of HeapHopper in this experiment. With
more exploit models specified, HeapHopper tends to suffer
from false positives because of its internal complexity, as
noted in the paper [17]. Despite its small numbers – dozens
in three experiments — this shows incorrectness in HeapHop-
per, resulting in failures to find UU and UE. We confirmed
these false positives with HeapHopper’s authors. On the con-
trary, ARCHEAP’s approach does not introduce false positives
thanks to its straightforward analysis at runtime.
This experiment also highlights an interesting design deci-
sion of ARCHEAP: separating the exploration and reducing
phases. With no exploit-specific guidance, ARCHEAP can
freely explore the search space for finding heap exploitation
techniques, and so increase the probability of satisfying the
precondition of certain exploitation techniques. For exam-
ple, if the sequence of transactions of UU (M-M-O1-F) is
enforced, ARCHEAP should craft a fake chunk within a rel-
atively small period (i.e., between four actions) to trigger
the exploit; otherwise, ARCHEAP has a higher probability to
formulate a fake chunk by executing more, perhaps redun-
dant, actions. However, such redundancy is acceptable in
ARCHEAP thanks to our minimization phase that effectively
reduces inessential actions from the found exploit.
We also confirmed that ARCHEAP can find all tcache-