to
{⊥, sessionClosed}. The user’s
accordingly.
- F MA
key-use forwards messages to/from corrupted users (in
role r) between the I/O tape tr and the network tape.
It does not give the adversary access to the subroutine
Fcrypto. This models perfect forward secrecy as the adver-
sary should not gain access to any keys after the session
is closed, even if he corrupts one of the parties.
- A user (pid , lsid , r ) may at any time ask for its cor-
ruption status by sending Corrupt?. F MA
key-use answers
immediately without contacting the ad-
this request
if state(pid , lsid , r ) = ⊥, F MA
versary. However,
key-use
ﬁrst asks the adversary whether he wants to cor-
rupt
the user by sending him the restricting message
(CorruptUser?, (pid , lsid , r )), expects a response b and,
if b = true, sets state(pid , lsid , r ) := corrupted. In
any case, F MA
key-use then returns the corruption status of
(pid , lsid , r ) to the user.
The adversary can also declare two local sessions to belong
to a global session and he decides when a user has success-
fully established a key:
- The adversary may send the message (GroupSession,
(pid I , lsid I ), (pid R, lsid R))
the
∈
following
true:
∈
{started, corrupted},
{started, corrupted}, and both users are not yet part
8This models that one can usually observe whether some session is still
active by monitoring the network of a party. Keeping this information secret
is typically not a goal of secure key exchange protocols.
if
state(pid I , lsid I , I)
state(pid R, lsid R, R)
F MA
holds
key-use
to
, r
, lsid(cid:2)
- The adversary may send (FinishKE, (pid , lsid , r )) where
state(pid , lsid , r ) = inSession to complete the key
exchange for an uncorrupted user. This message is ac-
cepted only if the user (pid , lsid , r ) is in a session with
its intended partner, i.e., he is in a session with a user
(pid(cid:2)
(cid:2)) such that pid(cid:2) = partner(pid , lsid , r ).
The functionality F MA
key-use then sets state(pid , lsid , r ) :=
exchangeFinished and outputs (Established, ptr ),
where ptr is the pointer to the previously established
session key k.
key-use. The functionality F UA
The functionality F UA
is
similar but models unilateral authentication of the responder
only. That
it gives an initiator the same guarantees
as F MA
key-use, while a responder may accept any connection
without authentication. More formally, F UA
key-use differes from
F MA
key-use as follows:
- Responders no longer indicate an intended session partner
when starting a key exchange.
- The adversary may instruct F UA
to output a key
(FinishKE) for an uncorrupted instance of a responder
that has already started a key exchange even if that
instance is not yet part of a global session.
key-use
key-use
is,
of a global session. The functionality F MA
key-use then sets
the state of uncorrupted users to inSession and stores
that (pid I , lsid I , I) and (pid R, lsid R, R) are in the same
global session. It
then uses the GetPSK command of
Fcrypto to get pointers to an unknown key k of type tkey
for the two users (if the received key is corrupted, then
F MA
key-use asks for another key until its gets an uncorrupted
one). Finally, it sends OK to the adversary. We note that,
while we allow the adversary to pair an uncorrupted user
with a corrupted one, the corrupted user will not get
access to the session key in Fcrypto (as already explained
above).
- If an honest responder instance is instructed to output
a session key, no checks regarding the identity of the
session partner are performed. Furthermore, unless the
responder is in a global session with an honest initiator,
the session key may be corrupted/marked known.
- Responder instances that have already output a key may
still be mapped into a global session if i) they are not
yet part of a global session and ii) their session key is
uncorrupted/unknown. Their session partner will receive
the same session key.
Discussion. The functionality F MA
key-use assumes that respon-
ders know the identity of the initiator at the start of the key
exchange. One could easily deﬁne a variant F MA
where
the responder learns the identity of the initiator only at the
end of the key exchange. Note, however, that an environment
for F MA
key-use is free to choose the expected identities of peers
of the responder instances anyway, so it can always choose
the identities at the start of a run appropriately.
key-use and F UA
The corruption model of both F MA
key-use requires
key-use
(cid:2)
891
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:26:54 UTC from IEEE Xplore.  Restrictions apply. 
While F MA
key-use/F UA
key-use/F UA
the corruption status of instances to stay unchanged during
the key exchange. This is not strictly necessary for the
ideal functionalities themselves (we could easily deﬁne
them to model full dynamic corruption). But due to the
commitment problem realizations typically have to adopt the
same corruption model anyway. Therefore, we chose to also
restrict the corruption model of F MA
key-use as this makes
these functionalities easier to use by higher level protocols.
We note that this is not a strong restriction compared to
full adaptive corruption, as session keys from key exchange
protocols are usually very short lived, and hence, the window
for corruption is small.
key-use/F UA
key-use are inspired by a functionality pro-
posed in [11], the functionalities differ in several important
aspects: As mentioned before, unilateral authentication is
not considered in [11]. Also, F MA
key-use model per-
fect forward secrecy, unlike the functionality in [11]. The
functionality in [11] supports only symmetric encryption as
an operation for higher-level protocols, and hence, is insuf-
ﬁcient for modeling the cryptographic operations of most
higher-level protocols. Furthermore, most common ideal
functionalities for key exchange in the literature, including
the functionality of [11] but also, e.g., the one from the CK
model [30], impose overly strict security requirements. Thus,
there are some reasonable protocols that cannot realize these
functionalities. To be more precise,
those functionalities
require that the views of both parties are identical when
the ﬁrst party outputs its key. In other words, if, e.g., Alice
wants to talk to Bob and outputs a session key, then the
protocol must not only ensure that Alice’s session partner
is indeed Bob, but also that Bob believes he is talking to
Alice (even if Bob has not even ﬁnished his part of the
protocol yet). However, this is not the case in protocols such
as the SIGMA protocol family. While the initiator knows
that she is talking to her intended communication partner
when she outputs a key, the responder has not yet conﬁrmed
the identity of the initiator, and thus their views may differ.
Even though these protocols cannot realize the functionality
in [11] and the like, the SIGMA protocol family is still
reasonable as this protocol family ensures that the responder
learns the correct identity of the initiator before outputting
her own session key (as we show in Section VI-B). By
relaxing the requirements on establishing a global session
and instead performing additional checks when a session
key is output, F MA
key-use allows for the analysis of a wider
variety of protocols.
VI. CASE STUDIES
In this section, we carry out several case studies to
illustrate the usefulness of our framework. We analyze one of
the ISO 9798-3 protocols [21] and the SIGMA protocol with
identity protection [22]. Both protocols are meant to provide
mutually authenticated key exchange. We also analyze one
mode of OPTLS [23] for unilaterally authenticated key
892
A
A, gx
B
B, gy, SIGB(gx, gy, A)
SIGA(gy, gx, B)
Figure 1. The ISO 9798-3 protocol for mutual authentication. At the end
of the protocol, users share a key gxy that is then used to derive a session
key.
key-use and F UA
exchange that served as the basis for the key exchange
protocol in TLS 1.3 draft-09 [31], and point out a subtle
bug in the original game-based proof.
We show that these protocols realize F MA
key-use,
respectively. In our modeling of these protocols, we use
Fcrypto to perform all cryptographic operations. By The-
orem 2, Fcrypto can then be replaced by its realization
Pcrypto so that the protocols use the actual cryptographic
primitives. Due to the use of Fcrypto, the proofs are quite
simple as they rely on high level
information theoretic
arguments only; they do not need a single reduction, not even
any probabilistic reasoning. At the same time, we obtain
strong universal composability guarantees for the protocols.
Moreover, the use of local session IDs in our framework
allows for a faithful modeling of the protocols. As discussed
at the beginning of Section V, other universal composability
approaches impose pre-established (global) session IDs on
the protocols, and hence, modify the protocols quite severely.
A. ISO protocol
The ISO 9798-3 [21] protocol for mutual authentication
is depicted in Figure 1. It is based on Difﬁe-Hellman key
exchange and uses signatures to ensure mutual authentica-
tion.
The modeling of the ISO protocol in our framework is
straightforward. We use two machines MI and MR to model
the initiator and responder role, respectively. These machines
provide the same I/O interface as F MA
key-use and each one has
a network tape. They use Fcrypto as a subroutine to perform
all cryptographic operations. In every run of the protocol,
there is one instance of MI/MR per user (pid , lsid ), with
each instance executing the protocol according to Figure 1.
As soon as an instance receives some DH share, it uses
the BlockGroupElement command to ensure that Fcrypto
“knows” this share, and hence, fresh exponents do not
collide with it.9 At the end of the protocol, instances create
a DH key from gx and gy and use this to derive the session
key of type unauthenc-key.10 They then output a pointer to
that session key and subsequently provide the same interface
9As mentioned earlier, this operation can be omitted when Fcrypto is
replaced with its realization. The resulting protocol is a natural implemen-
tation of the ISO protocol.
by F MA
10We could also have chosen any other symmetric key type supported
key-use. The security proof is independent of this.
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:26:54 UTC from IEEE Xplore.  Restrictions apply. 
as F MA
(ideal) cryptographic operations with the session key.
key-use, i.e., they allow a user to use Fcrypto to perform
Corruption of MI /MR is modeled analogously to F MA
key-use.
That is, protocol participants might be corrupted by the
adversary (by sending a special message) before the start
of the protocol run or after a session has been closed, but
not while a key exchange/session is active. While this is
more restricted than full adaptive corruption, it is still a
reasonable and meaningful modeling, as already discussed in
Section V. Besides directly being corrupted by the adversary,
an instance of MI /MR also considers itself corrupted (even
though not directly controlled by the adversary) if its own
signing key or the signing key of its intended peer is
corrupted. This models that no security guarantees, and in
particular no guarantees about authentication, can be given
if the adversary has access to the long term secrets. Please
refer to our technical report [24] for a detailed deﬁnition of
the corruption behavior.
The following theorem states that the ISO protocol is a
secure universally composable mutually authenticated key
exchange protocol. As mentioned before, our modeling
allows one to use session keys returned by this protocol
to be used by higher level protocol in an ideal way.
Theorem 3. Let MI and MR be machines modeling the
ISO protocol as described above, let Fcrypto and F(cid:2)
crypto be
two versions of the ideal crypto functionality with the same
parameters, and let F MA
key-use be the ideal functionality for
mutually authenticated key exchanges with parameter tkey =
unauthenc-key. Then the following holds true:
MI | MR |Fcrypto ≤R F MA
key-use |F(cid:2)
crypto.
As mentioned before,
the proof of this theorem does
not require any reductions, not even probabilistic reasoning,
which greatly simpliﬁes the overall proof. We note that we
directly show this theorem in the multi session setting. While
there exists a single session theorem for local session IDs
[11], in our case the analysis is already simple in the multi
session setting.
Proof: In the following, we say that a party pid is
corrupted if the signing key of party pid is corrupted. We call
an instance (pid , lsid , r ) corrupted if it outputs true when
asked for its corruption status by the environment, and we
say that an instance (pid , lsid , r ) is explicitly corrupted if
the adversary took control of this instance by sending the
special Corrupt message.
We have to deﬁne a simulator S and show that
E | MI | MR |Fcrypto ≡ E |S |F MA
crypto for all environ-
ments E ∈ EnvR(MI | MR |Fcrypto). The simulator S inter-
nally simulates the protocol MI | MR |Fcrypto and keeps the
corruption statuses of user instances in F MA
key-use and simulated
instances of MI /MR synchronized. When S has to initialize
Fcrypto, S ﬁrst sends a message to F(cid:2)
crypto to initialize it and