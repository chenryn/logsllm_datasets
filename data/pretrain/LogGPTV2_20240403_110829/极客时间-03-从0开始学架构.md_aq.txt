## 列式数据库顾名思义，列式数据库就是按照列来存储数据的数据库，与之对应的传统关系数据库被称为"行式数据库"，因为关系数据库是按照行来存储数据的。关系数据库按照行式来存储数据，主要有以下几个优势：-   业务同时读取多个列时效率高，因为这些列都是按行存储在一起的，一次磁盘操作就能够把一行数据中的各个列都读取到内存中。-   能够一次性完成对一行中的多个列的写操作，保证了针对行数据写操作的原子性和一致性；否则如果采用列存储，可能会出现某次写操作，有的列成功了，有的列失败了，导致数据不一致。我们可以看到，行式存储的优势是在特定的业务场景下才能体现，如果不存在这样的业务场景，那么行式存储的优势也将不复存在，甚至成为劣势，典型的场景就是海量数据进行统计。例如，计算某个城市体重超重的人员数据，实际上只需要读取每个人的体重这一列并进行统计即可，而行式存储即使最终只使用一列，也会将所有行数据都读取出来。如果单行用户信息有1KB，其中体重只有 4 个字节，行式存储还是会将整行 1KB数据全部读取到内存中，这是明显的浪费。而如果采用列式存储，每个用户只需要读取4 字节的体重数据即可，I/O 将大大减少。除了节省I/O，列式存储还具备更高的存储压缩比，能够节省更多的存储空间。普通的行式数据库一般压缩率在3:1 到 5:1 左右，而列式数据库的压缩率一般在 8:1 到 30:1左右，因为单个列的数据相似度相比行来说更高，能够达到更高的压缩率。同样，如果场景发生变化，列式存储的优势又会变成劣势。典型的场景是需要频繁地更新多个列。因为列式存储将不同列存储在磁盘上不连续的空间，导致更新多个列时磁盘是随机写操作；而行式存储时同一行多个列都存储在连续的空间，一次磁盘写操作就可以完成，列式存储的随机写效率要远远低于行式存储的写效率。此外，列式存储高压缩率在更新场景下也会成为劣势，因为更新时需要将存储数据解压后更新，然后再压缩，最后写入磁盘。基于上述列式存储的优缺点，一般将列式存储应用在离线的大数据分析和统计场景中，因为这种场景主要是针对部分列单列进行操作，且数据写入后就无须再更新删除。
## 全文搜索引擎传统的关系型数据库通过索引来达到快速查询的目的，但是在全文搜索的业务场景下，索引也无能为力，主要体现在：-   全文搜索的条件可以随意排列组合，如果通过索引来满足，则索引的数量会非常多。-   全文搜索的模糊匹配方式，索引无法满足，只能用 like 查询，而 like    查询是整表扫描，效率非常低。我举一个具体的例子来看看关系型数据库为何无法满足全文搜索的要求。假设我们做一个婚恋网站，其主要目的是帮助程序员找朋友，但模式与传统婚恋网站不同，是"程序员发布自己的信息，用户来搜索程序员"。程序员的信息表设计如下：![](Images/eff4a28587b00dc67d03b75a09041a5b.png){savepage-src="https://static001.geekbang.org/resource/image/1f/42/1fe1a088d0133938a299de5728f8f742.jpg"}我们来看一下这个简单业务的搜索场景：-   美女 1：听说 PHP 是世界上最好的语言，那么 PHP    的程序员肯定是钱最多的，而且我妈一定要我找一个上海的。美女 1 的搜索条件是"性别 + PHP +上海"，其中"PHP"要用模糊匹配查询"语言"列，"上海"要查询"地点"列，如果用索引支撑，则需要建立"地点"这个索引。-   美女    2：我好崇拜这些技术哥哥啊，要是能找一个鹅厂技术哥哥陪我旅游就更好了。美女 2 的搜索条件是"性别 + 鹅厂 +旅游"，其中"旅游"要用模糊匹配查询"爱好"列，"鹅厂"需要查询"单位"列，如果要用索引支撑，则需要建立"单位"索引。-   美女 3：我是一个"女程序员"，想在北京找一个猫厂的 Java 技术专家。美女 3 的搜索条件是"性别 + 猫厂 + 北京 + Java + 技术专家"，其中"猫厂 +北京"可以通过索引来查询，但"Java""技术专家"都只能通过模糊匹配来查询。-   帅哥 4：程序员妹子有没有漂亮的呢？试试看看。帅哥 4 的搜索条件是"性别 + 美丽 +美女"，只能通过模糊匹配搜索"自我介绍"列。以上只是简单举个例子，实际上搜索条件是无法列举完全的，各种排列组合非常多，通过这个简单的样例我们就可以看出关系数据库在支撑全文搜索时的不足。1\. 全文搜索基本原理全文搜索引擎的技术原理被称为"倒排索引"（Invertedindex），也常被称为反向索引、置入档案或反向档案，是一种索引方法，其基本原理是建立单词到文档的索引。之所以被称为"倒排"索引，是和"正排"索引相对的，"正排索引"的基本原理是建立文档到单词的索引。我们通过一个简单的样例来说明这两种索引的差异。假设我们有一个技术文章的网站，里面收集了各种技术文章，用户可以在网站浏览或者搜索文章。正排索引示例：![](Images/4b71c00d859da81c5677aa8b6c8bedbe.png){savepage-src="https://static001.geekbang.org/resource/image/9d/ca/9dd5cf7b9695ee17602a9b5db5193aca.jpg"}（注：文章内容仅为示范，文章内容实际上存储的是几千字的内容。）正排索引适用于根据文档名称来查询文档内容。例如，用户在网站上单击了"面向对象葵花宝典是什么"，网站根据文章标题查询文章的内容展示给用户。倒排索引示例：![](Images/77812bd4f34d2654b65e520492b5492b.png){savepage-src="https://static001.geekbang.org/resource/image/3c/bd/3cfa4abdcc22015ade669d9a844ae1bd.jpg"}（注：表格仅为示范，不是完整的倒排索引表格，实际上的倒排索引有成千上万行，因为每个单词就是一个索引。）倒排索引适用于根据关键词来查询文档内容。例如，用户只是想看"设计"相关的文章，网站需要将文章内容中包含"设计"一词的文章都搜索出来展示给用户。2\. 全文搜索的使用方式全文搜索引擎的索引对象是单词和文档，而关系数据库的索引对象是键和行，两者的术语差异很大，不能简单地等同起来。因此，为了让全文搜索引擎支持关系型数据的全文搜索，需要做一些转换操作，即将关系型数据转换为文档数据。目前常用的转换方式是将关系型数据按照对象的形式转换为 JSON 文档，然后将JSON文档输入全文搜索引擎进行索引。我同样以程序员的基本信息表为例，看看如何转换。将前面样例中的程序员表格转换为 JSON 文档，可以得到 3个程序员信息相关的文档，我以程序员 1 为例：     {  "id": 1,  " 姓名 ": " 多隆 ",  " 性别 ": " 男 ",  " 地点 ": " 北京 ",  " 单位 ": " 猫厂 ",  " 爱好 ": " 写代码，旅游，马拉松 ",  " 语言 ": "Java、C++、PHP",  " 自我介绍 ": " 技术专家，简单，为人热情 " } 全文搜索引擎能够基于 JSON 文档建立全文索引，然后快速进行全文搜索。以Elasticsearch 为例，其索引基本原理如下：> Elastcisearch> 是分布式的文档存储方式。它能存储和检索复杂的数据结构------序列化成为> JSON 文档------以实时的方式。> 在 Elasticsearch> 中，每个字段的所有数据都是默认被索引的。即每个字段都有为了快速检索设置的专用倒排索引。而且，不像其他多数的数据库，它能在相同的查询中使用所有倒排索引，并以惊人的速度返回结果。（）
## 小结今天我为你讲了为了弥补关系型数据库缺陷而产生的 NoSQL技术，希望对你有所帮助。这就是今天的全部内容，留一道思考题给你吧，因为 NoSQL的方案功能都很强大，有人认为 NoSQL = NoSQL，架构设计的时候无需再使用关系数据库，对此你怎么看？欢迎你把答案写到留言区，和我一起讨论。相信经过深度思考的回答，也会让你对知识的理解更加深刻。（编辑乱入：精彩的留言有机会获得丰厚福利哦！）![](Images/f2eae62fce5bba3ca5ee38d11da01862.png){savepage-src="https://static001.geekbang.org/resource/image/ba/37/ba6fcd186893b8cc9977d18e1fa5ab37.jpg"}
# 17 \| 高性能缓存架构虽然我们可以通过各种手段来提升存储系统的性能，但在某些复杂的业务场景下，单纯依靠存储系统的性能提升不够的，典型的场景有：-   需要经过复杂运算后得出的数据，存储系统无能为力例如，一个论坛需要在首页展示当前有多少用户同时在线，如果使用 MySQL来存储当前用户状态，则每次获取这个总数都要"count(\*)"大量数据，这样的操作无论怎么优化MySQL，性能都不会太高。如果要实时展示用户同时在线数，则 MySQL性能无法支撑。-   读多写少的数据，存储系统有心无力绝大部分在线业务都是读多写少。例如，微博、淘宝、微信这类互联网业务，读业务占了整体业务量的90% 以上。以微博为例：一个明星发一条微博，可能几千万人来浏览。如果使用MySQL 来存储微博，用户写微博只有一条 insert 语句，但每个用户浏览时都要select 一次，即使有索引，几千万条 select 语句对 MySQL数据库的压力也会非常大。缓存就是为了弥补存储系统在这些复杂业务场景下的不足，其基本原理是将可能重复使用的数据放到内存中，一次生成、多次使用，避免每次使用都去访问存储系统。缓存能够带来性能的大幅提升，以 Memcache 为例，单台 Memcache 服务器简单的key-value 查询能够达到 TPS 50000 以上，其基本的架构是：![](Images/0eeaaa417c1d7c6a10c26be33349d680.png){savepage-src="https://static001.geekbang.org/resource/image/6b/e6/6b2f7b75ee6f0f263f0531019384a8e6.png"}（ ）缓存虽然能够大大减轻存储系统的压力，但同时也给架构引入了更多复杂性。架构设计时如果没有针对缓存的复杂性进行处理，某些场景下甚至会导致整个系统崩溃。今天，[我来逐一分析缓存的架构设计要点。]{.orange}``{=html}
## 缓存穿透 {#18.html#-}**缓存穿透**是指缓存没有发挥作用，业务系统虽然去缓存查询数据，但缓存中没有数据，业务系统需要再次去存储系统查询数据。通常情况下有两种情况：1\. 存储数据不存在第一种情况是被访问的数据确实不存在。一般情况下，如果存储系统中没有某个数据，则不会在缓存中存储相应的数据，这样就导致用户查询的时候，在缓存中找不到对应的数据，每次都要去存储系统中再查询一遍，然后返回数据不存在。缓存在这个场景中并没有起到分担存储系统访问压力的作用。通常情况下，业务上读取不存在的数据的请求量并不会太大，但如果出现一些异常情况，例如被黑客攻击，故意大量访问某些读取不存在数据的业务，有可能会将存储系统拖垮。这种情况的解决办法比较简单，如果查询存储系统的数据没有找到，则直接设置一个默认值（可以是空值，也可以是具体的值）存到缓存中，这样第二次读取缓存时就会获取到默认值，而不会继续访问存储系统。2\. 缓存数据生成耗费大量时间或者资源第二种情况是存储系统中存在数据，但生成缓存数据需要耗费较长时间或者耗费大量资源。如果刚好在业务访问的时候缓存失效了，那么也会出现缓存没有发挥作用，访问压力全部集中在存储系统上的情况。典型的就是电商的商品分页，假设我们在某个电商平台上选择"手机"这个类别查看，由于数据巨大，不能把所有数据都缓存起来，只能按照分页来进行缓存，由于难以预测用户到底会访问哪些分页，因此业务上最简单的就是每次点击分页的时候按分页计算和生成缓存。通常情况下这样实现是基本满足要求的，但是如果被竞争对手用爬虫来遍历的时候，系统性能就可能出现问题。具体的场景有：-   分页缓存的有效期设置为 1    天，因为设置太长时间的话，缓存不能反应真实的数据。-   通常情况下，用户不会从第 1 页到最后 1    页全部看完，一般用户访问集中在前 10 页，因此第 10    页以后的缓存过期失效的可能性很大。-   竞争对手每周来爬取数据，爬虫会将所有分类的所有数据全部遍历，从第 1    页到最后 1 页全部都会读取，此时很多分页缓存可能都失效了。-   由于很多分页都没有缓存数据，从数据库中生成缓存数据又非常耗费性能（order    by limit 操作），因此爬虫会将整个数据库全部拖慢。这种情况并没有太好的解决方案，因为爬虫会遍历所有的数据，而且什么时候来爬取也是不确定的，可能是每天都来，也可能是每周，也可能是一个月来一次，我们也不可能为了应对爬虫而将所有数据永久缓存。通常的应对方案要么就是识别爬虫然后禁止访问，但这可能会影响SEO和推广；要么就是做好监控，发现问题后及时处理，因为爬虫不是攻击，不会进行暴力破坏，对系统的影响是逐步的，监控发现问题后有时间进行处理。