512-bit RSA
1023-bit RSA
OpenSSL
accept
accept
PolarSSL
accept
accept
GnuTLS
accept
accept
CyaSSL MatrixSSL
accept
accept
accept
accept
NSS
accept
accept
OpenJDK
accept
accept
BouncyCastle
accept
accept
Chrome
accept
accept
Firefox WebKit
accept
accept
accept
accept
Opera
warning
accept
TABLE IX: Veriﬁcation of extra certiﬁcate ﬁelds
Library
MatrixSSL
PolarSSL
CyaSSL
GnuTLS
NSS
OpenSSL
CRL
*
Yes
*
Yes
Yes
*
subjectAltName
No
Yes
Yes
Yes
Yes
*
Host name
No
Yes
Yes
Yes
Yes
*
* not veriﬁed by default, application must explicitly enable
X. DEVELOPER RESPONSES
We notiﬁed the developers of all affected SSL/TLS imple-
mentations about the issues discovered by our testing.
GnuTLS has ﬁxed the bug involving version 1 intermediate
CA certiﬁcates (starting from version 3.2.11) and also created
a patch for older versions. A security advisory (CVE-2014-
1959) has been issued for this bug. GnuTLS used to check the
keyUsage ﬁeld in earlier versions, but removed these checks
after getting bug reports from developers who were using
certiﬁcates with incorrect keyUsage ﬁelds.2 This was necessary
for compatibility with several other SSL/TLS implementations
that do not check this ﬁeld. Delignat-Lavaud et al. [19]
2http://www.gnutls.org/faq.html
independently reported that GnuTLS does not reject certiﬁcates
with unknown critical extensions. According to GnuTLS, re-
jecting such certiﬁcates may allow certain corporations to lock
out GnuTLS by issuing certiﬁcates with custom extensions
and thus forcing developers to use the corporation’s own SSL
library instead of GnuTLS.
MatrixSSL plans to reject version 1 intermediate CAs and
check path length constraints starting from the next release.
In general, MatrixSSL only performs basic checks on the
certiﬁcate and depends on the application-provided callbacks
to check key usage, extended key usage, expiration timestamps,
etc. To facilitate these checks, MatrixSSL will parse the critical
ﬂags and the extended key usage extension. Since MatrixSSL
primarily targets embedded devices, which do not always have
the time zone information, in most cases the notBefore and
notAfter timestamps in the certiﬁcate will have to be checked
against the available local time.
CyaSSL is ﬁxing all reported issues. The ﬁxes will be part
of CyaSSL 3.0.0, expected to be released in April 2014.
PolarSSL is currently working on the ﬁxes.
cryptlib does not support certiﬁcate chain validation to
avoid validation failures for the users who run their own CA
127
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:02:03 UTC from IEEE Xplore.  Restrictions apply. 
hierarchy or do not use certiﬁcates. The cryptlib manual3 rec-
ommends other techniques for authenticating the server, such
as matching key ﬁngerprints. In addition, it strongly recom-
mends using the PSK cipher suites for mutual authentication
of both the client and server. The manual also provides an
outline for the application writers who want to use certiﬁcates
on how to perform certiﬁcate validation on their own.
NSS developers informed us that all Mozilla products use
a glue layer called Personal Security Manager (PSM) over
NSS instead of using NSS directly. The PSM certiﬁcate valida-
tion routine, CERT_VerifyCertificate, takes an argument named
CERTVerifyLog that, if not set to NULL, returns a list of all
certiﬁcate validation errors. An example usage of the function
can be found at http://mxr.mozilla.org/mozilla-central/source/
security/manager/ssl/src/SSLServerCertVeriﬁcation.cpp#622
As of this writing, we are still talking to Web-browser
developers about user warnings generated by their browsers
when certiﬁcate validation fails.
XI. CONCLUSIONS
We designed, implemented, and applied the ﬁrst automated
method for large-scale adversarial testing of certiﬁcate vali-
dation logic in SSL/TLS implementations. Our key technical
innovation is “frankencerts,” synthetic certiﬁcates randomly
mutated from parts of real certiﬁcates. Frankencerts are syn-
tactically well-formed, but may violate the X.509 speciﬁcation
and thus exercise rarely tested functionality in SSL/TLS im-
plementations. Our testing uncovered multiple ﬂaws in popular
SSL/TLS libraries and Web browsers, including security vul-
nerabilities that break server authentication guarantees and can
be exploited for stealthy man-in-the-middle attacks.
Certiﬁcate validation is only one part of the SSL/TLS hand-
shake. Bugs in other parts of the handshake—e.g., accidentally
omitting to check that the server’s messages are signed with the
key that matches the certiﬁcate [49]—and incorrect usage of
SSL/TLS implementations by higher-level software [29, 31]
can completely disable authentication and leave applications
vulnerable to man-in-the-middle attacks. Development of auto-
mated methods that can analyze the entire SSL/TLS software
stack and prove that it has been implemented securely and
correctly remains an open challenge.
Acknowledgments. We are grateful to Rui Qiu for partic-
ipating in the initial exploration of the ideas that
led to
this work, and to our Oakland shepherd Matthew Smith
for helping smooth rufﬂed feathers. This work was partially
supported by the NSF grants CNS-0746888, CCF-0845628,
and CNS-1223396, a Google research award, NIH grant R01
LM011028-01 from the National Library of Medicine, and
Google PhD Fellowship to Suman Jana.
REFERENCES
[1] D. Akhawe, B. Amann, M. Vallentin, and R. Sommer. Here’s
my cert, so trust me, maybe? Understanding TLS errors on the
Web. In WWW, 2013.
[2] D. Akhawe and A. Felt. Alice in Warningland: A large-
scale ﬁeld study of browser security warning effectiveness. In
USENIX Security, 2013.
3http://www.cryptlib.com/downloads/manual.pdf, page 118
[3] N. AlFardan and K. Paterson. Lucky thirteen: Breaking the TLS
and DTLS record protocols. In S&P, 2013.
[4] B. Amann, R. Sommer, M. Vallentin, and S. Hall. No attack
necessary: The surprising dynamics of SSL trust relationships.
In ACSAC, 2013.
[5] C. Amrutkar, K. Singh, A. Verma, and P. Traynor. Vulner-
ableMe: Measuring systemic weaknesses in mobile browser
security. In ICISS, 2012.
[6] C. Amrutkar, P. Traynor, and P. van Oorschot. An empirical
evaluation of security indicators in mobile Web browsers. IEEE
Trans. Mobile Computing, 2013.
[7] S. Anand, E. Burke, T. Chen, J. Clark, M. Cohen, W. Grieskamp,
M. Harman, M. Harrold, and P. McMinn. An orchestrated survey
of methodologies for automated software test case generation.
Journal of Systems and Software, 86(8):1978–2001, 2013.
[8] D. Bleichenbacher. Chosen ciphertext attacks against protocols
based on the RSA encryption standard PKCS #1. In CRYPTO,
1996.
[9] D. Brumley and D. Boneh. Remote timing attacks are practical.
In USENIX Security, 2003.
[10] D. Brumley, J. Caballero, Z. Liang, J. Newsome, and D. Song.
Towards automatic discovery of deviations in binary imple-
mentations with applications to error detection and ﬁngerprint
generation. In USENIX Security, 2007.
[11] C. Cadar, D. Dunbar, and D. Engler. KLEE: Unassisted and
automatic generation of high-coverage tests for complex systems
programs. In OSDI, 2008.
[12] C. Cadar and D. Engler. Execution generated test cases: How
to make systems code crash itself. In SPIN, 2005.
[13] B. Chandrasekhar, S. Khurshid, and D. Marinov. Korat: Auto-
mated testing based on Java predicates. In ISSTA, 2002.
[14] T. Chen, S. Cheung, and S. Yiu. Metamorphic testing: A
new approach for generating next test cases. Technical Re-
port HKUST-CS98-01, Department of Computer Science, Hong
Kong University of Science and Technology, 1998.
[15] Y. Cheon and G. Leavens. A simple and practical approach to
unit testing: The JML and JUnit way. In ECOOP, 2002.
[16] J. Clark and P. van Oorschot. SoK: SSL and HTTPS: Revisiting
past challenges and evaluating certiﬁcate trust model enhance-
ments. In S&P, 2013.
[17] Comodo report of incident. http://www.comodo.com/Comodo-
Fraud-Incident-2011-03-23.html, 2011.
[18] B. Daniel, D. Dig, K. Garcia, and D. Marinov. Automated
testing of refactoring engines. In FSE, 2007.
[19] A. Delignat-Lavaud, M. Abadi, A. Birrell, I. Mironov, T. Wob-
ber, and Y. Xie. Web PKI: Closing the gap between guidelines
and practices. In NDSS, 2014.
[20] W. Dickinson, D. Leon, and A. Podgurski. Finding failures by
cluster analysis of execution proﬁles. In ICSE, 2001.
[21] M. Dietz, A. Czeskis, D. Balfanz, and D. Wallach. Origin-bound
certiﬁcates: A fresh approach to strong client authentication for
the Web. In USENIX Security, 2012.
[22] Diginotar issues dodgy SSL certiﬁcates for Google services
http://www.theinquirer.net/inquirer/news/
after
2105321/diginotar-issues-dodgy-ssl-certiﬁcates-google-
services-break, 2011.
break-in.
[23] E. Dijkstra. A Discipline of Programming. 1976.
[24] T. Duong and J. Rizzo. Here come the ⊕ ninjas.
http://
nerdoholic.org/uploads/dergln/beast part2/ssl jun21.pdf, 2011.
[25] Z. Durumeric, J. Kasten, M. Bailey, and A. Halderman. Analysis
of the HTTPS certiﬁcate ecosystem. In IMC, 2013.
[26] Z. Durumeric, E. Wustrow, and A. Halderman. ZMap: Fast
Internet-wide scanning and its security applications. In USENIX
Security, 2013.
[27] P. Eckersley and J. Burns. An observatory for the SSLiverse.
[28] M. Ernst. Static and dynamic analysis: Synergy and duality. In
In DEFCON, 2010.
WODA, 2003.
128
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:02:03 UTC from IEEE Xplore.  Restrictions apply. 
[29] S. Fahl, M. Harbach, T. Muders, and M. Smith. Why Eve
and Mallory love Android: An analysis of SSl (in)security on
Android. In CCS, 2012.
[30] FIPS PUB 140-2: Security requirements for cryptographic mod-
http://csrc.nist.gov/publications/ﬁps/ﬁps140-2/ﬁps1402.
ules.
pdf, 2001.
[31] M. Georgiev, S. Iyengar, S. Jana, R. Anubhai, D. Boneh, and
V. Shmatikov. The most dangerous code in the world: Validating
SSL certiﬁcates in non-browser software. In CCS, 2012.
[32] M. Gligoric, F. Behrang, Y. Li, J. Overbey, M. Haﬁz, and
D. Marinov. Systematic testing of refactoring engines on real
software projects. In ECOOP, 2013.
[33] CVE-2014-0092. https://bugzilla.redhat.com/show bug.cgi?id=
1069865, 2014.
[34] P. Godefroid, A. Kiezun, and M. Levin. Grammar-based
whitebox fuzzing. In PLDI, 2008.
[35] P. Godefroid, N. Klarlund, and K. Sen. DART: Directed
automated random testing. In PLDI, 2005.
[36] P. Godefroid, M. Levin, and D. Molnar. Automated whitebox
fuzz testing. In NDSS, 2008.
[37] W. Halfond, S. Anand, and A. Orso. Precise interface identiﬁ-
cation to improve testing and analysis of web applications. In
ISSTA, 2009.
[38] N. Heninger, Z. Durumeric, E. Wustrow, and A. Halderman.
Mining your Ps and Qs: Detection of widespread weak keys in
network devices. In USENIX Security, 2012.
[39] J. H. Holland. Adaptation in Natural and Artiﬁcial Systems.
University of Michigan Press, 1975. Second edition, 1992.
[40] CVE-2011-0228.
http://cve.mitre.org/cgi-bin/cvename.cgi?
name=CVE-2011-0228, 2011.
[41] V. Jagannath, Y. Lee, B. Daniel, and D. Marinov. Reducing the
costs of bounded-exhaustive testing. In FASE, 2009.
[42] S. Jana and V. Shmatikov. Abusing ﬁle processing in malware
detectors for fun and proﬁt. In S&P, 2012.
[43] J. Jones, J. Bowring, and M. Harrold. Debugging in parallel. In
ISSTA, 2007.
[44] D. Kaminsky, M. Patterson, and L. Sassaman. PKI layer cake:
New collision attacks against the global X.509 infrastructure. In
FC, 2010.
[45] S. Khurshid, C. Pasareanu, and W. Visser. Generalized symbolic
execution for model checking and testing. In TACAS, 2003.
[46] A. Kiezun, P. Guo, K. Jayaraman, and M. Ernst. Automatic
In
creation of SQL injection and cross-site scripting attacks.
ICSE, 2009.
[47] J. King. Symbolic execution and program testing. Commun.
ACM, 19(7), 1976.
[48] R. Lammel and W. Schulte. Controllable combinatorial coverage
in grammar-based testing. In Testing of Communicating Systems,
Lecture Notes in Computer Science, pages 19–38. 2006.
[49] A. Langley. Apple’s SSL/TLS bug. https://www.imperialviolet.
org/2014/02/22/applebug.html, 2014.
[50] A. Lenstra, J. Hughes, M. Augier, J. Bos, T. Kleinjung, and
C. Wachter. Ron was wrong, Whit is right. http://eprint.iacr.
org/2012/064, 2012.
[51] R. Majumdar and R. Xu. Directed test generation using
symbolic grammars. In ASE, 2007.
[52] B. Malloy and J. Power. An interpretation of Purdom’s algorithm
for automatic generation of test cases. In ICIS, 2001.
[53] D. Marinov and S. Khurshid. TestEra: A novel framework for
automated testing of Java programs. In ASE, 2001.
[54] M. Marlinspike. IE SSL vulnerability. http://www.thoughtcrime.
org/ie-ssl-chain.txt, 2002.
[55] M. Marlinspike. More tricks for defeating SSL in practice.
[56] M. Marlinspike. New tricks for defeating SSL in practice. Black
DEFCON, 2009.
Hat DC, 2009.
cates.
pdf, 2009.
[57] M. Marlinspike. Null preﬁx attacks against SSL/TLS certiﬁ-
http://www.thoughtcrime.org/papers/null-preﬁx-attacks.
[58] P. Maurer. Generating test data with enhanced context-free
grammars. IEEE Software, 7(4):50–55, 1990.
[59] W. McKeeman. Differential
testing for software. Digital
Technical Journal, 10(1):100–107, 1998.
[60] A. Parsovs. Practical issues with TLS client certiﬁcate authen-
tication. In NDSS, 2014.
[61] A. Podgurski, D. Leon, P. Francis, W. Masri, M. Minch, J. Sun,
and B. Wang. Automated support for classifying software failure
reports. In ICSE, 2003.
[62] P. Purdom. A sentence generator for testing parsers. BIT
Numerical Mathematics, 12:366–375, 1972.
[63] D. Ramos and D. Engler. Practical, low-effort equivalence
veriﬁcation of real code. In CAV, 2011.
[64] The TLS protocol version 1.0. http://tools.ietf.org/html/rfc2246,
1999.
[65] Internet X.509 public key infrastructure certiﬁcate policy
and certiﬁcation practices framework. http://www.ietf.org/rfc/
rfc2527.txt, 1999.
[66] HTTP over TLS. http://www.ietf.org/rfc/rfc2818.txt, 2000.
[67] The Transport Layer Security (TLS) protocol version 1.1. http:
[68] The Transport Layer Security (TLS) protocol version 1.2. http:
//tools.ietf.org/html/rfc4346, 2006.
//tools.ietf.org/html/rfc5246, 2008.
[69] Internet X.509 public key infrastructure certiﬁcate and certiﬁcate
revocation list (CRL) proﬁle. http://tools.ietf.org/html/rfc5280,
2008.
[70] The Secure Sockets Layer (SSL) protocol version 3.0. http:
//tools.ietf.org/html/rfc6101, 2011.
[71] Representation and veriﬁcation of domain-based application
service identity within Internet public key infrastructure using
X.509 (PKIX) certiﬁcates in the context of Transport Layer
Security (TLS). http://tools.ietf.org/html/rfc6125, 2011.
[72] J. Rizzo and T. Duong. The CRIME attack. In Ekoparty, 2012.
[73] P. Saxena, D. Akhawe, S. Hanna, F. Mao, S. McCamant, and
D. Song. A symbolic execution framework for JavaScript. In
S&P, 2010.
[74] K. Sen, D. Marinov, and G. Agha. CUTE: A concolic unit
testing engine for C. In FSE, 2005.
[75] E. Sirer and B. Bershad. Using production grammars in software
testing. In Proc. 2nd Conference on Domain-speciﬁc Languages,
1999.
[76] V. Srivastava, M. Bond, K. McKinley, and V. Shmatikov. A
security policy oracle: Detecting security holes using multiple
API implementations. In PLDI, 2011.
[77] M. Stevens, A. Sotirov, J. Appelbaum, A. Lenstra, D. Molnar,
D. Osvik, and B. Weger. Short chosen-preﬁx collisions for MD5
and the creation of a rogue CA certiﬁcate. In CRYPTO, 2009.
[78] N. Vratonjic, J. Freudiger, V. Bindschaedler, and J.-P. Hubaux.
The inconvenient truth about Web certiﬁcates. In WEIS, 2011.
Finding and
[79] X. Yang, Y. Chen, E. Eide, and J. Regehr.
understanding bugs in C compilers. In PLDI, 2011.
129
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:02:03 UTC from IEEE Xplore.  Restrictions apply.