2021/1/16
从0到1：CTFer成长之路-Nu1L战队-微信读书
2.3XSS的魔力
跨站脚本（Cross-SiteScripting，XSS）是一种网站应用程序的安全漏洞攻击，是代码注入的一
种。允许恶意用户将代码注入网页，其他用户在观看网页时会受到影响。这类攻击通常包含HTML和
用户端脚本语言，
XSS攻击通常是指通过利用网页开发时留下的漏洞，巧妙注入恶意指令代码到网页，使用户加载并执
行攻击者恶意制造的网页程序，这些恶意网页程序通常是JavaScript，但实际上可以包括Java
、ActiveX、Flash或者普通的HTML，攻击成功后，攻击者可能得到更高的权限（如执行一些操
VBS
作）、私密网页内容、会话和Cookie等内容。（摘自维基百科）
如上所述，XSS攻击是代码注入的一种。时至今日，浏览器上的攻与防片刻未歇，很多网站给关键
增加了HTTPOnly属性，这意味着执行JavaScript已无法获得用户的登录凭证（即无法通过XSS
攻击窃取Cookie登录对方账号），虽然同源策略限制了JavaScript跨域执行的能力，但是XSS攻击依
然可以理解为在用户浏览器上的代码执行漏洞，可以在悄无声息的情况下实现模拟用户的操作（包括
文件上传等请求）。CTF比赛中曾数次出现这种类型的XSS题目。
2.3.1XSS漏洞类型
1.反射/存储型XSS
根据XSS漏洞点的触发特征，XSS可以粗略分为反射型XSS、存储型XSS.反射型XSS通常是指恶意代
码末被服务器存储，每次触发漏润的时候都将恶意代码通过GET/POST方式提交，然后触发漏润。存
储型XSS则相反，恶意代码被服务器存储，在访问页面时会直接被触发（如留言板留言等场景）。
这里模拟一个简单的反射型XSS（见图2-3-1），变量输入点没有任何过滤直接在HTML内容中输出
就像攻击者对HTML内容进行了“注入”，这也是XSS也称为HTML注入的原因，这样我们可以向网
页中注入恶意的标签和代码，实现我们的功能，见图2-3-2
然而这样的payload会被GoogleChrome等浏览器直接拦截，无法触发，因为这样的请求（即GET参
数中的JavaScript标签代码直接打印在HTML中）符合GoogleChrome浏览器XSS过滤器（XSS
）的规则，所以被直接拦截（这也是近年来GoogleChrome加强防护策略导致的。在很长一段时
间内，攻击者可以肆意地在页面中注入XSS恶意代码）。换用FireFox浏览器，结果见图2-3-3
hello
X
view-source:127.0.0.1:8888/xs:x
→C
①view-source:127.0.0.1:8888/xss/1.php?name={输入点
1
2
hello
hello（输入点}
9
三
日涧
去书架查看
https:/weread.q.com/web/reader/77d32500721a485577d8eeekc7432af0210c74d97b01b1c
---
## Page 98
2021/1/16
从0到1：CTFer成长之路-Nu1L战队-微信读书
图2-3-2
图2-3-3
输入的数据被拼接到HTML内容中时，有时被输出到一些特殊的位置，如标签属性、JavaScript变量
的值，此时通过闭合标签或者语句可以实现payload的逃逸
又如，下面的输入被输出到了标签属性的值中（见图2-3-4）。通过在标签属性中注入on事件，我们
可以执行恶意代码，见图2-3-5。在这两种情况下，由于特征比较明显，因此使用GoogleChrome浏
览器的时候会被Google Chrome XSSAuditor拦截。
第三种情况是我们的输入被输出到avaScript变量中（见图2-3-6），这时可以构造输入，闭合前面的
双引号，同时引入恶意代码（见图2-3-7）。
图2-3-4
图2-3-5
5
6
7
hello
8
三
去书架直看
https:/weread.qq.com/web/reader/77d32500721a485577d8eeekc7432af0210c74d97b01b1c
2/14
---
## Page 99
2021/1/16
从0到1：CTFer成长之路-Nu1L战队-微信读书
document.write("hello ".username);
13
14
15
image display
1811221314151617
function getUrlParam(name){
var reg =new
window.location.search.substr(1).match(reg);
RegExp（"（^丨6）"+name+“=（[^6]*）（6|s)）;
varr=
ff（r=nulu) return
decodeURI（r[2]）;
return nutt;
var
ingurl=getUrlParam("ingurl");
var
inagehtnl
";
document.write(imagehtml);
18
/
图2-3-9
图2-3-10
三
去书架直看
日
https:/weread.qq.com/web/reader/77d32500721a485577d8eeekc7432af0210c74d97b01b1c
3/14
---
## Page 100
2021/1/16
从0到1：CTFer成长之路-Nu1L战队-微信读书
可以看到，恶意代码最终被拼接到了img标签中并被执行。
3.其他场景
决定上传的文件能否被浏览器解析成HTML代码的关键是HTTP响应头中的元素Content-Type，所以
无论上传的文件是以什么样的后级被保存在服务器上，只要访问上传的文件时返回的Content-type是
text/html，就可以成功地被浏览器解析并执行。类似地。Flash文件的application/x-shockwave-
也可以被执行XSS.
事实上，浏览器会默认把请求响应当作HTML内容解析，如空的和畸形的Content-type，由于浏览器
之间存在差异，因此在实际环境中要多测试。比如，GoogleChrome中的空Content-type会被认为
是text/html，见图2-3-12，也是可以弹框的，见图2-3-13
Google
图2-3-11
 Response Headers
view source
Connection: Keep-Alive
Content-Length: 41
Content-Type:
Date: Thu, 30 May 2019 07:22:33 GMT
Keep-Alive: timeout=5, max=100
图2-3-12
127.0.0.18888显示
xcel
图2-3-13
2.3.2XSS的tricks
1.可以用来执行XSS的标签
基本上所有的标签都可以使用on事件来触发恶意代码，比如：
效果见图2-3-14
三
去书架直看
https:/weread.qq.com/web/reader/77d32500721a485577d8eeekc7432af0210c74d97b01b1c
4/14
---
## Page 101
2021/1/16
从0到1：CTFer成长之路-Nu1L战队-微信读书
图[2-3-14
另一个比较常用的是img标签，效果见图2-3-15。
由于页面不存在路径为/x的图片，因此直接会加载出错，触发onerror事件并执行代码。
127.0.0.1:888显示
图2-3-15
其他常见的标签如下：
2.HTML5特性的XSS
HTML5的某些特性可以参考网站http://html5sec.org/。很多标签的on时间触发是需要交互的，如鼠
标滑过点击，代码如下：
input标签的autofocus属性会自动使光标聚焦于此，不需交互就可以触发onfocus事件。两个input
元素竞争焦点，当焦点到另一个input元素时，前面的会触发blur事件。例如：
3.伪协议与XSS
通常，我们在浏览器中使用HTTP/HTTPS协议来访问网站，但是在一个页面中，鼠标悬停在一个超链
接上时，我们总会看到这样的链接：javascript：void（0）。这其实是用JavaScript伪协议实现
的。如果手动单击，或者页面中的JavaScript执行跳转到JavaScript伪协议时，浏览器并不会带领我
执行。所以，对于这样的标签
单击这个标签时并不会跳转到其他网页，而是直接在当前页面执行alert（1），除了直接用a标签单
击触发，JavaScript协议触发的方式还有很多。
比如，利用JavaScript进行页面跳转时，跳转的协议使用JavaScript伪协议也能进行触发，代码如
下:
所以如果在一些登录/退出业务中存在这样的代码：
三
去书架直看
https:/weread.qq.com/web/reader/77d32500721a485577d8eeekc7432af0210c74d97b01b1c
5/14
---
## Page 102
2021/1/16
从0到1：CTFer成长之路-Nu1L战队-微信读书
即跳转的地址是我们可控的，我们就能控制跳转的地址到JavaScript伪协议，从而实现XSS攻击，见
图2-3-16,
图2-3-16
另外，iframe标签和form标签也支持lavaScript伪协议，感兴趣的读者可以自行尝试如下。不同的
是，iframe标签不需交互即可触发，而form标签需要在提交表单时才会触发。
除了JavaScript伪协议，还有其他伪协议可以在iframe标签中实现类似的效果。比如，data伪协议：
4.二次染导致的XSS
后端语言如flask的jinja2使用不当时，可能存在模板注入，在前端也可能因为这样的原因形成XSS
例如，在AngularJS中
上面的代码会将参数t直接输出到AngularJS的模板中，在我们访问页面时，JavaScript会解析模板中
的代码，可以得到—个前端的模板注入。AngularJS引擎解析了表达式“3*3”并打印了结果，见图2
-3-17.
C①127.0.0.1:8888/xss/6.php7t=((3*3))
名字：