title:Decentralized Jini Security
author:Pasi Eronen and
Pekka Nikander
Decentralized Jini Security
Pasi Eronen and Pekka Nikander
Helsinki University of Technology
{pasi.eronen, pekka.nikander}@hut.ﬁ
Abstract
Among the different approaches to distributed computing,
the Jini technology provides a number of very promising
methods for attacking the fundamental problems involved.
Programs built according to the Jini principles will be able
to function and survive in highly dynamic network environ-
ments, allowing applications to adapt their behaviour to
the requirements of the current context. Unfortunately, the
security problems that are bound to be present in any large
scale deployment of Jini are not adequately addressed by
either the current revisions of Jini technology or the un-
derlying Java security solutions.
In particular, the solu-
tions proposed so far are either bound to a speciﬁc com-
munication protocol—thereby hampering the protocol in-
dependence of Jini—or rely on centralized security servers,
thereby losing the beneﬁts of the ad hoc nature of Jini.
In this paper, we present results of our research that act
as stepping stones towards a fully decentralized, complete
Jini security architecture.
In particular, we describe our
experimental implementation that separates the Java 2 ac-
cess permissions of Jini clients, service proxies, and ser-
vices, while allowing natural delegation of Java 2 permis-
sions between Jini enabled devices. Our solution integrates
seamlessly to the underlying Java 2 security, and allows all
of Jini’s beneﬁts to be utilized in a secure way.
1
Introduction
Distributed computing is fundamentally different from cen-
tralized computing. The usually mentioned four major dif-
ferences include latency, memory access, partial failures,
and concurrency (e.g. [35]). Security should deﬁnitely be
added to this list, since a distributed system requires cryp-
tography to be used while a centralized system may survive
without it. While many of the approaches to distributed
computing attempt to mask out some of these problems, the
Jini approach mostly does not. Instead, it aims at providing
tools and methods for effectively building software that ad-
equately addresses these differences and is able to survive
in the face of problems caused by distribution. [1]
The fundamental differences become especially appar-
ent when considering the future ad hoc networks and other
loosely coupled systems. These systems, by nature, are not
only distributed but also decentralized. That is, a genuine
ad hoc network does not have any centralized services but
all the network services are conﬁgured and created on the
ﬂy. In the security area, the underlying mechanisms stay
more or less the same to what is used in centralized sys-
tems, but the trust and infrastructure assumptions change
altogether, requiring different kinds of solutions (cf. [29]).
In this paper, we present a fully decentralized network se-
curity architecture for Jini, and describe a prototype imple-
mentation of the architecture. The architecture builds upon
our earlier work on trust management [25] and distributed
Jini security [12]. The implementation is integrated to the
Java 2 security model, augmenting and utilizing the secu-
rity services provided by the Java 2 security architecture
[15] and the Java Socket Security Extension (JSSE) [33].
In the future, we plan to look at how to integrate our exten-
sions to the Java Authentication and Authorization Service
(JAAS) [21] and to the RMI Security Extension [32]. Our
solution is fully compatible with the Jini architecture and
assumptions, and does not require any centralized security
services. It makes a clean distinction between the access
rights of client applications and service proxies, and pro-
vides a means of delegating Java 2 security permissions be-
tween Jini clients, services proxies, and services. These and
other aspects of our solution are discussed in detail later in
this paper.
The rest of this paper is organized as follows. First, in the
rest of this section, we brieﬂy describe the central concepts
of trust management and the Jini architecture. After that, in
Section 2, we provide a brief taxonomy of Jini related se-
curity requirements and a number of related design aspects.
Section 3 discusses our design choices and outlines the ar-
chitecture of our solution, and Section 4 describes the im-
plementation, including some performance measurements.
Related work is brieﬂy discussed in Section 5, and Section
6 evaluates our approach in the light of the alternative so-
lutions. We also give some ideas for future work. Finally,
Section 7 contains our conclusions from this research.
1.1 Decentralized trust management
device drivers.
Traditionally, security has been based on identity authenti-
cation and locally stored access control lists (ACLs). This
has been the case even in distributed systems. However,
that approach has a number of drawbacks, including, for
example, the problem of protecting the operations that are
needed for managing access control lists remotely. In [5]
Blaze et al. argue that “the use of identity-based public-
key systems in conjuction with ACLs are inadequate so-
lutions to distributed (and programmable) system-security
problems.”
An alternative solution, termed trust management, uses a
set of uniﬁed mechanisms for specifying both security poli-
cies and security credentials. Basically, trust management
usually involves signed statements (certiﬁcates) about what
principals (users) are allowed to do, instead of traditional
name certiﬁcates which just bind a public key to a name.
Examples of trust management systems include the Policy-
Maker, which originally introduced the term trust manage-
ment [6], its continuations KeyNote and KeyNote2 [4], and
in some respects, SPKI [11] and its applications, including
TeSSA [23].
1.2 Introduction to Jini
The Jini programming model provides a set basic build-
ing blocks for distributed applications: distributed events,
transactions,
leases, and downloadable proxies. These
don’t try to hide the fact that networks are unreliable, and
the approach, in general, encourages building more fault-
tolerant applications [26, 35].
The building blocks are used in the centerpiece of Jini,
the lookup service, which is a directory where service
providers register themselves and clients search for what
they need. For example, when a service registers itself
with a lookup service, it receives a lease on the registration,
with an expiration date.
If the service doesn’t renew the
lease before it expires—for example, the service is discon-
nected from the network— the registration is automatically
cleaned from the lookup service.
The lookup service is somewhat similar to other service
location protocols, such as Salutation [28], Service Loca-
tion Protocol [16], and Universal Plug and Play [34], except
that matching is based in Java interface types. The central
difference between Jini and the other service location proto-
cols is protocol independence: that is, Jini does not mandate
any speciﬁc communication protocol between the clients
and the services (except for bootstrapping the system), but
relies on dynamic Java class loading instead. Since the
proxies are written in Java, the system also claims oper-
ating system independence; this in contrast with the other
service location protocols which usually use non-portable
All communication goes through proxies, which are local
objects that implement some well-known interface (such as
“Printer”). Proxies can be simple Remote Method Invoca-
tion (RMI) stubs which marshall method calls over the net-
work, or they can implement part of the functionality in the
proxy itself (for example, converting the data to the correct
format for this printer). Also, some services don’t neces-
sarily require network communication at all, in which case
the proxy alone implements the service.
Protocol independence and the ability to implement part
of the intelligence on the client side give Jini tremen-
dous ﬂexibility. For example, proxies can communicate
with devices which don’t have a Java virtual machine; ei-
ther legacy devices with proprietary protocols, or resource-
stripped embedded devices. On the other hand, Jini requires
that the clients have their own Java virtual machines.
1.3 Proxies and security
Protocol independence presents also some new security
challenges. The Jini architecture doesn’t include any se-
curity in addition to the normal Java security facilities (for
protecting the client JVM from malicious proxy code), and
the security aspects of RMI in their current state are insuf-
ﬁcient for the task (see Section 4.7).
Since all communication goes through downloaded
proxy objects, security methods used in environments with
ﬁxed protocols can’t usually be used without some adap-
tation. For example, the Transport Layer Security (TLS)
protocol supports authentication of both the client and the
server using X.509 certiﬁcates [10]. This doesn’t, however,
help us in determining whether a speciﬁc proxy is trustwor-
thy. The client certainly doesn’t want to give its private key
to the proxy (since it might use it to access a completely
different service).
We feel the situation resembles the concept of delegation,
and therefore a trust management system which supports
delegation could be applied to the problem elegantly.
2 Requirements for Jini security
When talking about Jini security, we must ﬁrst decide what
security functionality is needed. This naturally depends on
what we are using Jini for, and what trust relationships are
involved. In this paper, we are focusing on the client ac-
cessing a server through a proxy, and leave the security as-
pects of distributed events, leases, and transactions for fu-
ture work.
So far, we have identiﬁed the following requirements.
• Principal authentication. The client should be able to
verify that it is actually talking to the right service and
through the right proxy. Likewise, the service should
be able to verify who is trying to access it.
It is important to notice that authentication is impossi-
ble in a number of situtations. For example, in a pure
ad hoc network there may not be any prior information
about the communicating peers.
• Secure principal attributes.
In many circumstances,
human readable and recognizable names are required
for authentication. Services might also have other at-
tributes such as security level (for example, a printer
for printing classiﬁed documents) or the “owner” of
the service (for example, “Alice’s calendar”). Users
might have other attributes such as memberships in
groups or roles.
Not all clients or services necessarily have names with
any uniqueness beyond one client or server. For ex-
ample, getting a CA-signed certiﬁcate for the doorbell
ourside your door so that it can contact a server inside
your house to play a tune doesn’t seem very sensible.
• Service access control. Based on the result of princi-
pal authentication and/or capabilities presented by the
client and/or other circumstances, the service should
allow some operations and deny others.
• Protection from applications. The client Java Virtual
Machine (JVM) might run multiple applications, some
of which are not fully trusted, such as applets and
games. Untrusted applications should not be able to
access services with the user’s privileges.
• Protection from proxies. The downloaded proxy code
needs some special permissions (for example, to make
network connections) when running inside the client
JVM. Some proxies may need more permissions than
others. These should be controlled somehow. Java, of
course, provides some facilities for this, but they are
somewhat insufﬁcient for many applications.
On a lower level, protocol-related aspects such as mes-
sage conﬁdentiality and integrity, replay prevention, perfect
forward secrecy of keying, and so forth, are also desirable.
We do not consider these further, since appropriate solu-
tions are widely known.
The actual requirements, of course, vary from case to
case. For example, if the client runs only trusted appli-
cations, protection from applications might not be needed.
Some of these, such as protection from proxies, could also
be addressed separately from the rest.
2.1 Other design aspects
The requirements outlined above still leave a lot of free-
dom for the implementor. The design choices made will
certainly affect the situations where the solution is applica-
ble. In this section we identify some of the design aspects.
In the next section we continue to set forth our choices, and
the reasons behind them.
• Centralization. Does the architecture rely on some
centralized servers or authorities? Are they required
to be on-line during service access?
Centralized security architecture probably makes ad-
ministration in large networks easier. On the other
hand, it doesn’t work well for, e.g. mobile ad hoc net-
works. Furthermore, there are several somewhat in-
dependent features which could be centralized or de-
centralized. For example, we could have decentral-
ized access control with either centralized naming (CA
type) or decentralized naming (for example, PGP-style
“web of trust”).
• Trusted components. Does the system rely on the se-
curity of the lookup service, or some other on-line se-
curity server?
• Protocol independence. Is the solution tied to some
transport protocol, such as the RMI wire protocol over
TLS or IIOP? If the protocol is ﬁxed, it can be imple-
mented using trusted code, which simpliﬁes the secu-
rity situtation.
• Service access control model. How ﬂexible and ﬁne-
grained is the access control mechanism? What kind
of policies can it support? For example, applica-
tions which access medical data probably require more
complicated policies than an ofﬁce environment.
This is inﬂuenced by other choices. For example, if the
access control is managed by a “container” of some