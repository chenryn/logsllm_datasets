[4] A. Baumann, M. Peinado, and G. Hunt, “Shielding applications from an untrusted
cloud with haven,” ACM Transactions on Computer Systems (TOCS), vol. 33, 2015.
[5] S. Checkoway and H. Shacham, “Iago Attacks: Why the System Call API is a Bad
Untrusted RPC Interface,” pp. 253–264.
[6] G. Chen, S. Chen, Y. Xiao, Y. Zhang, Z. Lin, and T. H. Lai, “Sgxpectre attacks:
[9] M. Hähnel, W. Cui, and M. Peinado, “High-resolution side channels for untrusted
[7] Y. Fu, E. Bauman, R. Quinonez, and Z. Lin, “Sgx-lapd: Thwarting controlled side
[8] D. Goltzsche, C. Wulf, D. Muthukumaran, K. Rieck, P. Pietzuch, and R. Kapitza,
Leaking enclave secrets via speculative execution,” in EuroS&P’19, year=2019.
channel attacks via enclave verifiable page faults,” in RAID’17, 2017.
“Trustjs: Trusted client-side execution of javascript,” in EuroSec, 2017.
operating systems,” in USENIX ATC 17, Santa Clara, CA, 2017.
[10] J. A. Halderman, S. D. Schoen, N. Heninger, W. Clarkson, W. Paul, J. A. Calandrino,
A. J. Feldman, J. Appelbaum, and E. W. Felten, “Lest we remember: cold-boot
attacks on encryption keys,” Communications of the ACM, vol. 52, 2009.
for untrusted computation on secret data,” TOCS’18, vol. 35, no. 4, p. 13, 2018.
329298-001US.
[12] Intel, “Intel Software Guard Extensions Programming Reference (rev1),” Sep. 2013,
[11] T. Hunt, Z. Zhu, Y. Xu, S. Peter, and E. Witchel, “Ryoan: A distributed sandbox
[13] J. Lee, J. Jang, Y. Jang, N. Kwak, Y. Choi, C. Choi, T. Kim, M. Peinado, and B. B. Kang,
“Hacking in darkness: Return-oriented programming against secure enclaves,” in
USENIX Security 17, 2017.
[14] S. Lee, M.-W. Shih, P. Gera, T. Kim, H. Kim, and M. Peinado, “Inferring fine-
grained control flow inside sgx enclaves with branch shadowing,” in USENIX
Security 17, 2017.
[15] J. Lind, C. Priebe, D. Muthukumaran, D. OâĂŹKeeffe, P.-L. Aublin, F. Kelbert,
T. Reiher, D. Goltzsche, D. Eyers, R. Kapitza et al., “Glamdring: Automatic
application partitioning for intel sgx,” in USENIX ATC 17, Santa Clara, CA, 2017.
[16] F. McKeen, I. Alexandrovich, A. Berenzon, C. V. Rozas, H. Shafi, V. Shanbhogue,
and U. R. Savagankar, “Innovative instructions and software model for isolated
execution,” in HASP’13, Tel-Aviv, Israel, 2013.
Computer, vol. 31, 1998.
attacks against enclave programs,” in NDSS’17, San Diego, CA, 2017.
telling your secrets,” in Asia CCS’16. ACM, 2016, pp. 317–328.
with sgx enclaves,” National University of Singapore, Tech. Rep, 2016.
[17] J. K. Ousterhout, “Scripting: Higher level programming for the 21st century,”
[19] S. Shinde, Z. L. Chua, V. Narayanan, and P. Saxena, “Preventing page faults from
[18] M.-W. Shih, S. Lee, T. Kim, and M. Peinado, “T-sgx: Eradicating controlled-channel
[20] S. Shinde, D. Le Tien, S. Tople, and P. Saxena, “Panoply: Low-tcb linux applications
[21] C. Tsai and D. Porter, “Graphene-sgx,” https://github.com/oscarlab/graphene.
[22] W. Wang, G. Chen, X. Pan, Y. Zhang, X. Wang, V. Bindschaedler, H. Tang, and C. A.
Gunter, “Leaky cauldron on the dark land: Understanding memory side-channel
hazards in sgx,” in ACM CCS. ACM, 2017, pp. 2421–2434.
channels for untrusted operating systems,” in S&P’15, 2015.
[23] Y. Xu, W. Cui, and M. Peinado, “Controlled-channel attacks: Deterministic side
Session 2A: SGX-based SecurityAsiaCCS ’19, July 9–12, 2019, Auckland, New Zealand119A ADDITIONAL PERFORMANCE RESULT
When a scripting language interpreter is executed inside a secure
enclave, the script execution incurs the extra cost of running
enclave boundary operations and memory access operations (due to
running inside an MEE). Enclave boundary operations are required
for communication between trusted enclave code and untrusted
code. Such operations include data transfer and control transfer
operations. Enclave boundary transfer operations are necessary
to perform system calls. Similarly, since SGX protects data using
memory encryption, read and write memory access operations
incur additional overhead. Thus, we would like to closely examine
the overhead of these operations by designing corresponding micro
benchmarks.
In particular, we designed two micro benchmarks in Lua to
evaluate ScriptShield’s performance. Our first micro benchmark
evaluates system call overhead, which is an important part of
ScriptShield’s design, while the other benchmark measures
memory access overhead with memory copy operations. Our
language choice is less important here because there is very little
script code executing; the overhead mostly comes from the system
calls or memory accesses. However, it is important to note that
these benchmarks are still taking place within an interpreter, run
natively and in ScriptShield.
System Call Overhead. System calls are used in essentially all
applications, but are not allowed inside SGX enclaves. A key
component in ScriptShield is the shim layer atop musl-libc that
redirects all system calls from the enclave to ocalls that perform
the actual system call outside the enclave. Since the system call
shim is such a significant part of our framework, we would like to
quantify the system call overhead. Clearly, we cannot test all of the
system calls we implemented due to the challenge of designing the
corresponding test cases. Therefore we would like to focus on the
most representative system calls.
Interestingly, we notice readv and writev are the two most
frequently used system calls in many of our daily applications. We
thus design two benchmarks that write to a file and read from a
file, which ultimately invoke the readv and writev system calls,
respectively. We use different input data sizes for this performance
test.
Figure 5 shows the execution time comparison of running
the readv and writev system calls 1,000 times in ScriptShield,
normalized against native execution. ScriptShield actually has no
noticeable overhead for readv, while overhead is reasonable for
writev.
Memory Access Overhead. SGX uses a memory encryption
engine (MEE) to encrypt the memory for the enclave. Any access
inside the enclave will retrieve the plaintext whereas any access
outside the enclave will only obtain the ciphertext. Naturally, this
comes with a cost. In particular, when an enclave reads data from
and writes data into enclave memory, the requested or updated
pages are accessed by or written into the page cache. For cache
misses or when a page needs to be written into memory, the
Memory Encryption Engine (MEE) has to encrypt and decrypt the
cache line because of the EPC page protection mechanism. When
enclave code memory requirements exceed the EPC size, overhead
will be very large.
l
l
a
c
m
e
t
s
y
S
readv
writev
0
20
40
80
60
Normalized Overhead (%)
100
120
140
Native
ScriptShield
160
180
200
Figure 5: Percentage overhead of running readv and writev
benchmarks in ScriptShield normalized against native exe-
cution.
Native
ScriptShield
200
150
100
)
%
(
d
a
e
h
r
e
v
O
d
e
z
i
l
a
m
r
o
N
50
s-read
r-read
s-write
r-write
Figure 6: Percentage overhead of running memory access
benchmarks in ScriptShield normalized against native ex-
ecution.
To measure the memory access overhead inside the enclave,
we leveraged our system call testing and designed another micro
benchmark to both sequentially and randomly read and write
enclave memory because sequential and random memory accesses
have different cache miss frequencies. More specifically, this bench-
mark measures the time for both sequential and random read/write
operations, normalized against a deployment without an enclave.
All operations access a 256K memory region. Figure 6 shows the
percentage overhead of running memory access benchmarks within
ScriptShield normalized against native execution. We can see
ScriptShield does not significantly impact memory read and write
performance.
B SECURITY APPLICATIONS
Once we have enabled running the legacy scripting code inside
SGX enclaves, we are now able to protect the secrecy and integrity
of this code without modifying any script code. To demonstrate
how to use ScriptShield to protect (legacy) scripting languages,
we next present a few security applications.
Session 2A: SGX-based SecurityAsiaCCS ’19, July 9–12, 2019, Auckland, New Zealand120)
s
m
(
e
m
T
i
9
7
5
3
1
Native
ScriptShield
)
s
m
(
e
m
T
i
0.9
0.7
0.5
0.3
0.1
Native
ScriptShield
)
s
m
(
e
m
T
i
0.9
0.7
0.5
0.3
0.1
Native
ScriptShield
ScriptShield
Native
)
S
/
t
s
e
u
q
e
R
(
t
u
p
h
g
u
o
r
h
T
6000
4000
2000
2
4
6
8
10
# concurrent connections
2
4
6
8
10
# concurrent connections
2
4
6
8
10
# concurrent connections
2
4
8
6
10
Data Size(MB)
12
14
16
(a)
(b)
(c)
(d)
Figure 7: Average time required to run Xavante benchmarks’ (a) loop script, (b) sample html file and (c) 10 MB text file without
(native) and with ScriptShield. (d) Average throughput measurement for Xavante without (native) and with ScriptShield.
Protecting HTTP Servers. When running applications in a cloud
environment, customers would like to protect the confidentiality
and integrity of their code and data. ScriptShield’s ability to easily
place an interpreter in an enclave is ideal for securing applications
with an embedded scripting engine. A prominent example of this
kind of application is HTTP servers, many of which offer support
for multiple scripting languages for server-side scripting. Scripts
are more flexible, dynamic, and are easier to use to build web
applications than compiled code. Because of this, many websites
use scripting languages for their web servers.
Lua has been used for server-side scripting on several popular
web sites, including Taobao, and as a templating language on
MediaWiki. Therefore, we decided to demonstrate protecting
lua scripts running on an HTTP server. Xavante is an HTTP
server written entirely in Lua that also offers support for Lua
scripting. Because of this, we chose to use Xavante to demonstrate
ScriptShield. Since Xavante is written in Lua, we can protect
more than just server-side scripts; we can place the entire web
server inside the enclave, ensuring its integrity in addition to the
confidentiality and integrity of the scripts it runs.
Xavante has a modular architecture based on URI mapped
handlers. It offers a file handler, a redirect handler and a WSAPI
handler. To use Xavante, we just need to configure it (no code
modification at all) and then execute it in the Lua interpreter we
have ported. We also used a set of benchmarks to evaluate the
overhead while running Xavante with ScriptShield.
Specifically, we have three benchmarks: (1) running loop.lp,
which is a lua script running on the Xavante server that performs
a simple loop and displays the result on a web page, (2) accessing
the default index.html hosted by Xavante, and (3) accessing a
10MB file hosted by Xavante. We use ab, the Apache HTTP
server benchmarking tool, to run these tests. Also, we measure
ScriptShield throughput overhead by running ab with varying
amounts of concurrent connections to the server. We show the
results of the three benchmarks in Figure 7. From Figure 7, the
average overhead of loop.lp is around 2 ms, the average overhead
of the sample html file is around 0.5 ms, and the average
overhead of the 10 MB text file is around 0.4 ms. The overhead
of these three benchmarks is mostly due to the short runtime of
the benchmarks. Therefore, any fixed overhead (e.g. entering and
exiting the enclave) may dominate the runtime of the benchmark
when running under ScriptShield. This leads to a higher overhead
percentage, even though the actual time it takes to execute is quite
small, both natively and in ScriptShield. Xavante scales well (as
the overhead does not increase with an increase in concurrent
connections), while the whole HTTP server remains protected
within a secure enclave.
Protecting Computer Games. Computer games can often be
reverse engineered. There is often an arms race between game
publishers and game cheaters in protecting the secrecy of certain
game logic. Also, many of today’s computer game engines use
scripting languages such as Lua and Squirrel for game logic. Since
we have enabled running the Lua interpreter in ScriptShield,
we can then offer the capability to protect the game logic against
reverse engineering.
LÖVE is a game engine used to make 2D games with Lua, and
has been used for commercial projects. We managed to execute
LÖVE inside ScriptShield so we are able to run games written in
Lua. Due to the fact that different games require different versions
of LÖVE, we just run Mr. Rescue for this proof of concept to
demonstrate how ScriptShield could protect the game logic from
malicious attacks. Mr. Rescue is written purely in Lua. Due to the
highly interactive nature of computer games, we did not attempt to
measure its performance overhead, but we did observe there is no
user experience differences when compared using ScriptShield or
not.
Since our framework is designed specifically for running scripts,
applications written purely in a scripting language are the most
straightforward to run in our framework. For applications that are
only partly written in a scripting language, extra efforts are needed,
as the interactions between the scripts and native application
components need to be handled.
Session 2A: SGX-based SecurityAsiaCCS ’19, July 9–12, 2019, Auckland, New Zealand121