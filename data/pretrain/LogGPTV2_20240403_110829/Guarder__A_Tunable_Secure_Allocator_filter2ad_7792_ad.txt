ed contains a simple invalid-free bug, caused by a call to
free() that was forgotten by the developer after mov-
ing a buffer from dynamic to static memory. GUARDER
guarantees detection of all double/invalid free problems,
and thus provides an immediate report of the error, in-
cluding the current callstack.
gzip-1.2.4. GNU compression utility
Gzip, obtained from BugBench [25], contains a stack-
based buffer overﬂow. For testing purposes,
it was
moved to the heap. This bug would normally corrupt
the adjacent metadata, however, when testing each se-
USENIX Association
27th USENIX Security Symposium    127
Application
Allocations Deallocations
(#)
(#)
blackscholes
bodytrack
canneal
dedup
facesim
ferret
ﬂuidanimate
freqmine
raytrace
streamcluster
swaptions
vips
x264
Aget
Apache
Firefox
Memcached
MySQL
Pbzip2
Pfscan
SQLite
Normalized Total
18
424519
30728189
4045531
4729653
137968
229992
456
45037352
8908
48001811
1422138
71120
49
102216
20874509
7601
491544
67
51
1458486
14
424515
30728185
1750969
4495883
137960
229918
347
45037316
8898
48000397
1421738
71111
24
101919
20290076
76
491433
61
15
1458447
Memory Usage (MB)
Linux DieHarder OpenBSD FreeGuard GUARDER
655
111
1186
1474
491
132
477
1885
1770
149
383
104
604
82
12
172
13
535
105
798
331
1.27
634
42
1153
1926
377
94
270
1344
1724
114
12
37
506
59
5
163
8
135
102
800
64
0.97
627
34
963
1684
327
66
213
1543
1162
111
6
32
491
69
4
159
6
126
97
753
41
1.00
628
32
828
1020
324
71
235
1426
1111
111
7
32
497
32
2
169
4
277
99
837
35
0.94
630
63
932
2693
374
100
237
1631
1511
117
12
820
494
51
6
163
7
158
261
803
125
1.37
Table 5: The number of allocations, deallocations, and memory usage of secure allocators.
cure allocator, this crash is avoided due to their metadata
segregation. Additionally, around 10% of GUARDER and
FreeGuard tests resulted in halting execution, caused by
accessing an adjacent random guard page.
Libtiff-4.0.1. TIFF image library
A malformed input will cause the affected version of
Libtiff’s gif2tiff converter tool to experience a buffer
overﬂow, normally resulting in a program crash. When
verifying this bug with GUARDER, this will always re-
sult in (1) an immediate halt due to illegal access on
an adjacent random guard page, or (2) a report to the
user indicating the discovery of a modiﬁed canary value.
OpenBSD aborts with a “chunk info corrupted” error,
while DieHarder produces no report and exits normally.
Heartbleed. Cryptographic library
The Heartbleed bug exploits a buffer over-read in
OpenSSL-1.0.1f. Both GUARDER and FreeGuard will
probabilistically guard against this attack, with protec-
tion in proportion to the amount of random guard pages
installed. By default, this is 10%. Neither OpenBSD nor
DieHarder can provide protection against this bug.
PHP-5.3.6. Scripting language interpreter
A variety of malicious XML data are provided as in-
put, resulting in use-after-free and double-free condi-
tions. GUARDER, FreeGuard, and OpenBSD halt and re-
port each of these bugs, while DieHarder exits normally
with no report made.
polymorph-0.4.0. File renaming utility
The affected version of polymorph suffers from a stack-
based buffer overﬂow that was adapted to the heap for
testing purposes, and results in a program crash due to
corrupted object metadata. Due to their segregated meta-
data, all of the secure allocators allow the application to
exit normally. However, both GUARDER and FreeGuard
also provide probabilistic protection in proportion to the
amount of installed random guard pages.
Squid-2.3. Caching Internet proxy server
Squid 2.3 contains a heap-based buffer overﬂow caused
by an incorrect buffer size calculation. Normally, this
bug will cause the program to crash due to corrupting
adjacent metadata. When tested with GUARDER, the
overwritten canary value at the site of the overﬂow is
detected, and the program is immediately halted. Free-
Guard exhibits similar behavior, while OpenBSD and
DieHarder do not detect the overﬂow at all.
Summary. For all evaluated bugs, GUARDER was capa-
ble of either probabilistically detecting the attack – such
as through the use of random guard pages to thwart buffer
overﬂow – or immediately provided a report to the user
when the error condition occurred (e.g., double-free).
128    27th USENIX Security Symposium
USENIX Association
Figure 4: Average randomization entropies of existing secure allocators, grouped by object size class. GUARDER
provides a consistently high entropy which other allocators cannot support.
Vulnerability
Buffer Over-write
Invalid-Free
Application
bc-1.06
ed-1.14.1
gzip-1.2.4
Heartbleed
Libtiff-4.0.1
PHP-5.3.6
polymorph-0.4.0
Squid-2.3
No crash:
Halt→report: Halts execution & reports to user
Buffer Over-write
Buffer Over-read
Buffer Over-write
Use-After-Free
Use-After-Free
Double-Free
Crash
Crash
Crash
Crash
Crash
Crash
Program completes normally
Buffer Overﬂow
Buffer Overﬂow
Original
Crash
Crash
Crash
DieHarder
No crash
No crash
No crash
Data Leak Data Leak
No crash
No crash
No crash
No crash
No crash
No crash
Data Leak:
p-protect:
Crash
FreeGuard
No crash
OpenBSD
GUARDER
No crash
No crash
Halt→report Halt→report Halt→report
p-protect
p-protect
No crash
p-protect
p-protect
Data Leak
Halt→report Halt→report
Halt→report Halt→report Halt→report
Halt→report Halt→report Halt→report
Halt→report Halt→report Halt→report
p-protect
p-protect
No crash
Halt→report Halt→report
No crash
Leakage of arbitrary heap data occurred
Probabilistic protection, p = 0.10 (default)
Table 6: Effectiveness evaluation on known vulnerabilities.
However, we also noticed that the results of GUARDER
and FreeGuard are very similar. Based on our investi-
gation, these evaluated bugs (mostly static) cannot show
the beneﬁt of the improved security of GUARDER, as de-
scribed in Section 6.2, such as higher entropy and over-
provisioning. For instance, it is not easy to evaluate
higher randomization entropy providing more resistance
to attacks, but in reality it does. Additionally, for exam-
ple, if a one-element overﬂow is already contained within
unused space, over-provisioning provides no additional
beneﬁt.
6 Discussion
6.1 Customization
(a) Why is Customization Helpful? GUARDER is the ﬁrst
allocator that supports customizable security. Based on
our evaluation (see Section 5), higher security comes at
the cost of increased performance overhead and mem-
ory consumption. Sometimes, this difference could be
sufﬁciently large that it may affect users’ choices. For
instance, GUARDER’s memory overhead using 7 bits of
entropy is around 0% (not shown due to space limita-
tions), while its memory overhead with 9 bits is around
27%. Therefore, users may choose a level of secu-
rity that reduces memory consumption when required
by resource-constrained environments, such as mobile
phones. GUARDER provides this ﬂexibility, without the
requirement of changing and recompiling applications
and the allocator.
(b) How many bits of entropy could GUARDER sup-
port? Currently, GUARDER supports up to 16 bits of
entropy on machines with 48 address bits, in theory, al-
though with the potential for higher overhead.
In the
current design, as shown in Figure 2, the number of sup-
ported threads may limit entropy choices, since there are
16 bags in each thread, and every bag has the same size.
If there are 128 threads in total, with a heap space of 128
terabytes, every bag will be 64 gigabytes, which can sup-
USENIX Association
27th USENIX Security Symposium    129
0246810121416B32B64B128B256B512B1KB2KB4KB8KB16KB32KB64KBEntropy (bits)Size ClassAverage Allocation Entropy by Size Class of Secure AllocatorsDieHarderOpenBSDFreeGuardGuarderport up to 16 bits of entropy. Since there is room for at
most 217 objects of size 512 kilobytes in such a bag, it
may only support 16 bits of entropy if over-provisioning
and guard pages are also supported.
In the future, we
plan to allocate each bag on-demand, and may use dif-
ferent bag sizes, in order to support even higher levels of
entropy.
6.2 Comparison with FreeGuard
In this section, we compare GUARDER with the cur-
rent state-of-the-art secure allocator FreeGuard. On av-
erage, GUARDER imposes around 3% performance over-
head and 27% memory overhead, while FreeGuard im-
poses around 1% performance overhead and 37% mem-
ory overhead.
However, GUARDER supports more security features
and a higher level of entropy, due to its unique and novel
design as described in Section 4: (1) GUARDER sup-