trust-dependencies between contracts,
revealing that
contracts oftentimes rely on further external contracts.
This also implies that a vulnerable contract may put
other, dependent contracts at risk.
Complementary to vulnerability detection there have
also been advances towards veriﬁcation of smart con-
tracts. The work by Bhargavan et al. [9] presents EVM*
and Solidity* that provide a direct translation of a sub-
set of EVM bytecode and Solidity into F* respectively,
which can then be used for further veriﬁcation.
ZEUS, recently presented by Kalra et al. [18], provides
a framework to check smart contracts written in Solid-
ity against a user-deﬁned policy. Both contract source
code and policy are compiled together into an LLVM-
based intermediate representation, which is then further
analysed statically, leveraging existing LLVM-IR-based
veriﬁcation tools. Based on this, they analyze 1,524
Ethereum contracts for policy violations against a list of
known bugs (including the ones considered by OYENTE).
Additionally, they also use ZEUS to check a subset of
contracts against contract-speciﬁc fairness properties.
Like OYENTE, ZEUS also requires access to a con-
tract’s source code, whereas our tool works given only
compiled EVM bytecode. Furthermore, in contrast to our
tool, ZEUS requires user-interaction to deﬁne a policy,
which is often contract speciﬁc. Finally, a policy viola-
tion found by ZEUS does not imply practical exploitabil-
ity of the contract in question, whereas our tool outputs
exploits that can be easily validated.
Finally, Breidenbach et al. [10] proposed using bug
bounties to incentivize security analyses of smart con-
tracts. Speciﬁcally, they designed a framework that en-
codes the process of identifying exploits and paying re-
wards into a smart contract itself, thereby guaranteeing
fairness between the bounty payer and the bug ﬁnder.
7.2 Automatic Exploitation
Another area that is related to our work is the research
ﬁeld of automatic exploitation. Many tools have been
proposed that can create speciﬁc classes of exploits under
certain conditions. Notable examples are: Q, presented
by Schwartz et al. [23], can transform a x86 software
exploit into another exploit that still works under harder
constraints (e.g., Address Space Layout Randomization
and WˆX). AEG by Avgerinos et al. [8] and MAYHEM
by Cha et al. [11] both provide means to create a control
ﬂow hijacking exploit using buffer overﬂows or format
string attacks from source code and compiled binaries,
respectively. Huang et al. [17] extends the considered
attack surface by including the operating system and li-
braries a compiled binary uses at runtime, and work by
Hu et al. [16] considers non-control-ﬂow hijacking ex-
ploits by modelling data-oriented exploits.
While all of these share the general idea of symbolic
execution, constraint generation, and resolution to gen-
erate an exploit—as does the work presented herein—
there are major differences. The most obvious difference
is that the execution environment of the EVM does not
provide an equivalent to buffer overﬂows or format string
exploits. As such, the considered exploits are substan-
tially different. Furthermore, all works mentioned rely
on preconditioning, i.e., providing a starting point to the
path exploration, most often in the form of a crashing in-
put. In contrast to this, our work can create an exploit
only based in the compiled contract’s code without fur-
ther input. Finally, there are also challenges speciﬁc to
the EVM that do not apply to previous work, primarily
handling and resolution of hash-values, which are an in-
tegral part of many smart contracts.
1330    27th USENIX Security Symposium
USENIX Association
8 Conclusion
We have presented a generic deﬁnition of vulnerable con-
tracts and a methodology for automatic exploit gener-
ation based on this deﬁnition.
In a large-scale analy-
sis encompassing 38,757 contracts from the Ethereum
blockchain, TEETHER identiﬁed 815 as vulnerable. Fur-
thermore, TEETHER successfully generated 1,564 work-
ing exploits against Ethereum accounts that use these
contracts. This illustrates that smart contract security
should be taken seriously, especially as these exploits
are fully anonymous and trivial to conduct—they only
require an Ethereum account. Exploit generation, as we
have shown, can be fully automated.
Over the last years, Ethereum has seen a rapid and
steady increase in value. Should this trend continue into
the future, smart contract exploitation will only become
more lucrative, and in turn, seeking protection will be-
come even more important. Our methodology and espe-
cially concrete tools such as TEETHER can help in ﬁnd-
ing, understanding, and preventing exploits before they
cause losses. Finally, our systematic analysis of the real
Ethereum blockchain has revealed that the problem of
highly-critical vulnerabilities in smart contracts is way
larger than anecdotal evidence might suggest.
Acknowledgements
We would like to thank the anonymous reviewers for
their comments. Furthermore, this project has received
funding from the European Union’s Horizon 2020 re-
search and innovation programme under grant agreement
No 700176 (“SISSDEN”).
References
[1] https://coinmarketcap.com. Accessed Feb 1st, 2018.
[2] https://soliditylang.com/documentation/language-
specifications.html. Accessed Feb 1st, 2018.
[3] https://blog.consensusx.com/dissecting-the-two-
malicious-ethereum-messages-that-cost-30m-but-
couldve-cost-100m-155e023a9500.
2018.
Accessed Feb 1st,
[4] https://www.nytimes.com/2016/06/18/business/
dealbook/hacker-may-have-removed-more-than-
50-million-from-experimental-cybercurrency-
project.html. Accessed Feb 1st, 2018.
[5] https://github.com/ethereum/go-ethereum. Accessed
Feb 1st, 2018.
[6] https://paritytech.io/the-multi-sig-hack-a-
postmortem/. Accessed Feb 1st, 2018.
[7] ATZEI, N., BARTOLETTI, M., AND CIMOLI, T. A Survey of
Attacks on Ethereum Smart Contracts (SoK). In Proceedings of
the 6th International Conference on Principles of Security and
Trust (POST’17) (2017).
[8] AVGERINOS, T., CHA, S. K., HAO, B. L. T., AND BRUMLEY,
In Proceedings of the 18th
D. Automatic exploit generation.
Network and Distributed System Security Symposium (NDSS’11).
[9] BHARGAVAN, K., DELIGNAT-LAVAUD, A., FOURNET, C.,
GOLLAMUDI, A., GONTHIER, G., KOBEISSI, N., KULATOVA,
N., RASTOGI, A., SIBUT-PINOTE, T., SWAMY, N., ET AL. For-
mal veriﬁcation of smart contracts: Short paper. In Proceedings
of the 11th ACM SIGSAC Workshop on Programming Languages
and Analysis for Security (PLAS’16) (2016).
[10] BREINDENBACH, L., DAIAN, P., TRAM `ER, F., AND JUELS, A.
Enter the hydra: Towards principled bug bounties and exploit-
In Proceedings of the 27th USENIX
resistant smart contracts.
Security Symposium (USENIX Security’18) (2018).
[11] CHA, S. K., AVGERINOS, T., REBERT, A., AND BRUMLEY, D.
Unleashing mayhem on binary code. In Proceedings of the 33rd
IEEE Symposium on Security and Privacy (S&P’12) (2012).
[12] CHEN, T., LI, X., LUO, X., AND ZHANG, X. Under-optimized
smart contracts devour your money. In Proceedings of the 24th
IEEE International Conference on Software Analysis, Evolution
and Reengineering (SANER’17) (2017).
[13] DE MOURA, L., AND BJØRNER, N. Z3: An efﬁcient smt
solver. In Proceedings of the 14th International Conference on
Tools and Algorithms for the Construction and Analysis of Sys-
tems (TACAS’08) (2008).
[14] FR ¨OWIS, M., AND B ¨OHME, R. In code we trust? In Proceed-
ings of the First International Workshop on Cryptocurrencies and
Blockchain Technology (CBT’17) (2017).
[15] HART, P. E., NILSSON, N. J., AND RAPHAEL, B. A formal ba-
sis for the heuristic determination of minimum cost paths. IEEE
Transactions on Systems Science and Cybernetics 4, 2 (1968).
[16] HU, H., CHUA, Z. L., ADRIAN, S., SAXENA, P., AND LIANG,
Z. Automatic generation of data-oriented exploits. In Proceed-
ings of the 24th USENIX Security Symposium (USENIX Secu-
rity’15) (2015).
[17] HUANG, S.-K., HUANG, M.-H., HUANG, P.-Y., LU, H.-L.,
AND LAI, C.-W. Software crash analysis for automatic exploit
generation on binary programs. IEEE Transactions on Reliability
63, 1 (2014).
[18] KALRA, S., GOEL, S., DHAWAN, M., AND SHARMA, S. Zeus:
Analyzing safety of smart contracts. In Proceedings of the 25th
Network and Distributed System Security Symposium (NDSS’18)
(2018).
[19] KEVIN DELMOLINO, MITCHELL ARNETT, A. K. A. M., AND
Step by step towards creating a safe smart con-
SHI, E.
tract: Lessons and insights from a cryptocurrency lab. Cryp-
tology ePrint Archive, Report 2015/460, 2015.
https://
eprint.iacr.org/2015/460.
[20] LUU, L., CHU, D.-H., OLICKEL, H., SAXENA, P., AND HO-
In Proceedings of
BOR, A. Making Smart Contracts Smarter.
the 23rd ACM SIGSAC Conference on Computer and Communi-
cations Security (CCS’16) (2016).
[21] MAVRIDOU, A., AND LASZKA, A. Designing secure ethereum
smart contracts: A ﬁnite state machine based approach. arXiv
preprint arXiv:1711.09327 (2017).
[22] NAKAMOTO, S. Bitcoin: A peer-to-peer electronic cash system.
http://www.bitcoin.org/bitcoin.pdf, 2009.
[23] SCHWARTZ, E. J., AVGERINOS, T., AND BRUMLEY, D. Q:
Exploit hardening made easy. In Proceedings of the 20th USENIX
Security Symposium (USENIX Security’11) (2011).
[24] SUICHE, M. Porosity: A decompiler for blockchain-based smart
contracts bytecode. DEF CON 25 (2017).
[25] WOOD, G. Ethereum: A Secure Decentralised Generalised
Transaction Ledger. http://gavwood.com/Paper.pdf, 2014.
[26] ZHOU, Y., KUMAR, D., BAKSHI, S., MASON, J., MILLER, A.,
AND BAILEY, M. Erays: Reverse engineering ethereum’s opaque
In Proceedings of the 27th USENIX Security
smart contracts.
Symposium (USENIX Security’18) (2018).
USENIX Association
27th USENIX Security Symposium    1331
uint public m numOwners;
uint public m required;
uint[256] m owners;
mapping(uint => uint) m ownerIndex;
mapping(bytes32 => PendingState) m pending;
bytes32[] m pendingIndex;
struct PendingState { uint yetNeeded; uint ownersDone; uint index; }
modifier onlymanyowners(bytes32 operation) {
}
function confirmAndCheck(bytes32 operation) internal returns (bool) {
if (confirmAndCheck( operation))
;
uint ownerIndex = m ownerIndex[uint(msg.sender)];
if (ownerIndex == 0) return;
var pending = m pending[ operation];
if (pending.yetNeeded == 0) {
pending.yetNeeded = m required;
pending.ownersDone = 0;
pending.index = m pendingIndex.length++;
m pendingIndex[pending.index] = operation;
}
uint ownerIndexBit = 2∗∗ownerIndex;
if (pending.ownersDone & ownerIndexBit == 0) {
if (pending.yetNeeded <= 1) {
delete m pendingIndex[m pending[ operation].index];
delete m pending[ operation];
return true;
pending.yetNeeded−−;
pending.ownersDone | = ownerIndexBit;
}
function initMultiowned(address[] owners, uint required) {
1 contract MultiOwned{
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
}else{
}
}
}
m numOwners = owners.length + 1;
m owners[1] = uint(msg.sender);
m ownerIndex[uint(msg.sender)] = 1;
for (uint i = 0; i < owners.length; ++i)
{
m owners[2 + i] = uint( owners[i]);
m ownerIndex[uint( owners[i])] = 2 + i;
}
m required = required;
}
function pay(address to, uint amount) onlymanyowners(sha3(msg.data)){
}
to.transfer(amount);
Figure 10: Minimal example of the Parity-Wallet Bug
1332    27th USENIX Security Symposium
USENIX Association
A Parity-Wallet Bug
Figure 10 shows a minimal working example of the
Parity-Wallet Bug in a single contract. Lines 1-44 are
taken verbatim from the original Parity wallet4.
We ran TEETHER on this contract with the goal to
produce an exploit transferring 1 Ether from the con-
tract (address 0x400...000) to the attacker (address
0x012...567). TEETHER produces the following ex-
ploit in 26.74 seconds:
-------------------------------------------------
Transaction 1
-------------------------------------------------
from: 0x0123456789abcdef0123456789abcdef01234567
to:
0x4000000000000000000000000000000000000000
data: c57c 5f60 0000 0000 0000 0000 0000 0000
0000 0000 0000 0000 0000 0000 0000 0000
0000 0000 0000 0000 0000 0000 0000 0000
0000 0000 0000 0000 0000 0000 0000 0000
0000 0000
value: 0
-------------------------------------------------
Transaction 2
-------------------------------------------------
from: 0x0123456789abcdef0123456789abcdef01234567
to:
0x4000000000000000000000000000000000000000
data: c407 6876 0000 0000 0000 0000 0000 0000
0123 4567 89ab cdef 0123 4567 89ab cdef
0123 4567 0000 0000 0000 0000 0000 0000
0000 0000 0000 0000 0000 0000 0de0 b6b3
a764 0000 0000 0000 0000 0000 0000 0000
0000 0000 0000 0000 0000 0000 0000 0000
0000 0000 0000 0000 0000 0000 0000 0000
0000 0000 0000 0000 0000 0000 0000 0000
value: 0
The ﬁrst transaction of this exploit calls function
initMultiowned (c57c5f60) with all-zeros as ar-
i.e., an empty owners-array and 0 as
guments,
required. This function will re-initialize the con-
tract’s owner information, setting m numOwners to 1 and
adding msg.sender, the attacker, to m owners[] as the
sole owner.
The second transaction then calls pay (c4076876),
with the attacker’s address (0x012...567) as to and
1018 = 0xde0b6b3a7640000 (1 Ether in Wei) as amount.
As the attacker has been set as the sole owner by the
previous transaction, the function confirmAndCheck
called by the onlymanyowners modiﬁer will return
true, allowing the function to proceed and leading to
the transfer of 1 Ether to the attacker.
4https://github.com/paritytech/parity/blob/
4d08e7b0aec46443bf26547b17d10cb302672835/js/src/
contracts/snippets/enhanced-wallet.sol#L284
USENIX Association
27th USENIX Security Symposium    1333