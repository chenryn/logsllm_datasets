t.put("newPwd", newPwd);
res = this.sendCommand("changePwd", t).resCode;
return res != ResCode.SUCCESS ? false : true;
boolean changeCameraUsernamePassword(Camera
cam, String newUsr, String newPwd) { /*...*/ }
Fig. 6. Snippet of code for the Insteon Camera app.
not able to generate input for Device ID 11, as the device does not
accept connections outside the companion app.
Overall, no bugs were found by any of these network fuzzing
tools. The reason why no network fuzzers triggered any crash is
that these fuzzers are general-purpose [83], [68], and they fail to
trigger deeper code paths in the devices’ firmware. For instance,
BED only fuzzes HTTP headers without considering the syntax
or the semantics of HTTP payloads.
G. Case Study: Insteon HD Wifi Camera
In this section, we present a case study regarding two bugs that
DIANE found in the Insteon Camera (Device ID 2). Note that,
these bugs have been fixed in the latest version of the firmware
running on the Insteon camera.
it
is
Among the functionality offered by the app, a user
can change their credentials
(username and password).
Figure 6 depicts a simplified version of the app’s code that
the code of the function
accomplishes this task (we omit
changeCameraUsernamePassword as
already
In particular, when the user wants
shown in Figure 4).
to change their password,
the companion app invokes the
function changeCameraUsernamePassword (Line 29). As
explained in Section IV-D, this function first checks that the camera
belongs to a certain camera family, and if so, the app invokes
the function changePassword (Line 21). This function
creates a TreeMap structure containing couples “key:values,”
which will be placed in the request generated by the app. Then,
changePassword invokes the sendCommand function
(Line 5), which is a helper function used to send commands
to the camera. This function prepares the request by using the
int key_strcpy(char *dst, char *URI, char *key){
int len = 0;
char* val = get_ptr_val(URI, key, &len);
strncpy(dst, val, len);
return 0 ;
1
2
3
4
5
6
}
Fig. 7. Simplified snippet of code from Insteon firmware.
TreeMap, and it eventually calls httpRequest (Line 1) to send
the request to the device.
For this particular device, we could gather the firmware running
on the camera (by sniffing the wireless network during the initial
firmware update). Figure 7 shows a simplified version of the
firmware function used to copy the values of parameters from a
given URI. This function acts as an unsafe strcpy: it takes as
input a destination buffer (allocated by the caller function) and
copies the value of a pair “key:value” present in a given URI.
This function is called 789 times within the Insteon firmware,
and, to the best of our knowledge, for 9 of them, we can trigger
a buffer overflow. In particular, when a user wants to change the
camera password, the firmware allocates two buffers on the stack,
and it uses this function to copy the username and new password
values from the URI into the allocated buffers (of 88 and 64 bytes
respectively). As a result, if we provide two values for username
and password large enough, we can trigger two buffer overflows.
By looking at the code in Figure 6 and Figure 4, we can see
that fuzzing the function encodeUrl (Lines 12,14, and 15 in
Figure 6) allows us to i) skip any app-side validation (Line 2 in
Figure 4), and ii) trigger both bugs discovered by IoTFuzzer (as
shown in Section IV-D) and two additional bugs due to a long
username and password.
DIANE identified 9 different sendMessage functions (6 true
positives), and 6 fuzzing triggers (6 true positives) for the Insteon
Camera companion app. Among these, DIANE automatically iden-
tified the function httpRequest as a sendMessage function,
and the function encodeUrl as a fuzzing trigger. When DIANE
fuzzed encodeUrl, DIANE immediately generated an alert.
Finally, note that the sendCommand represents another valid
fuzzing trigger for httpRequest, as it modifies the command
being sent. Indeed, DIANE correctly identified sendCommand
as a further fuzzing trigger.
H. Runtime Performance
We assessed the runtime performance of our tool by measuring
the execution time required by the fuzzing triggers identification
phase. In our experiments, we setup DIANE to run the fuzzing
phase for 24 hours. First, we measured the entire execution time
required, on average, for DIANE to analyze an app and identify
fuzzing triggers. DIANE analyzes a given app in slightly less than
150 minutes on average. Figure 8 shows the average and standard
deviation of the execution time required for each phase of our
analysis process. As shown in Figure 8, the execution time of
DIANE has a high standard deviation. This is due to the following
implementation detail: Frida, which we leverage to hook Android
APIs and methods at runtime, sometimes fails, causing the running
app to crash. This requires automatically restarting the hooking
procedure, randomly slowing down DIANE.
Authorized licensed use limited to: Tsinghua University. Downloaded on February 25,2022 at 12:29:05 UTC from IEEE Xplore.  Restrictions apply. 
495
)
n
i
m
(
e
m
T
i
.
c
e
x
E
200
100
0
All
S
S M
FT
Fig. 8. Average and standard deviation of the execution time of the
phases that DIANE performs (S = Setup, SM = sendMessage functions
Identification, FT = Fuzzing Trigger Identification).
I. Quantifying Required Human Effort
We evaluated the human effort required to use DIANE. In general,
DIANE scales linearly with the number of analyzed devices, as
it requires the analyst to perform the same steps for each new
analyzed device. DIANE requires human intervention to setup a
new IoT device. During this phase, an analyst has to install the IoT
device, which involves installing the companion app, configuring
the device, and, in some cases, registering an online account. In ad-
dition, during this phase, DIANE requires the analyst to run the app
and test the basic functionality of the IoT device, so that our tool can
record the generated UI interactions (see Section III). We measured
the time we spent to setup each device, as reported in Table I. On
average, we spent 6 minutes and 12 seconds to setup a new IoT
device, of which 41 seconds were spent to interact with the device.
Note that, an analyst has to take these steps only once per device.
Human effort is also required if the analyst desires to monitor the
state of the watchdog device during fuzzing (recall Section III-B).
The watchdog device is optional and useful if the analyst wants
to detect semantic issues. In this case, the analyst has to check
whether the functionality automatically exercised by the watchdog
device results in an undesired effect in the IoT device due to our
fuzzer triggering a vulnerability (e.g., unauthenticated requests
suddenly open a door lock). The frequency of these manual
checks depends on the analyst, as they might want to monitor the
watchdog device at regular intervals for the whole duration of the
fuzzing campaign, or only at the end of it. In our fuzzing campaign
we checked the watchdog device approximately every two hours.
In our experiments, we needed the watchdog device only to detect
the issue for Device ID 11, as explained in Section IV-C. The other
10 bugs were automatically detected by DIANE by monitoring the
network traffic, as explained in Section III-B.
When a bug is detected, DIANE generates an alert. In this case,
an analyst may want to manually reproduce and verify the bug
triggering the alert. DIANE allows this manual verification, since
it produces as output the input triggering the detected bug. With
this information in hand, the analyst can use DIANE to send the
crashing input to the analyzed IoT device. Then, the analyst can
manually check the device functionality to assess if it misbehaves
after receiving the crashing input (e.g., the device reboots or does
not reply to further requests). In our evaluation, we needed about
6 minutes, on average, to follow this procedure and verify each
alert produced by DIANE.
V. LIMITATIONS AND FUTURE WORK
While we addressed the major challenges for performing
black-box fuzzing of IoT devices, our overall approach and the
implementation of DIANE still have some limitations.
We currently cannot bypass app-side sanity checks when they
are implemented in native code, in a data-transforming function
or directly in a sendMessage function. Though we acknowledge
that such checks could be present in any of these classes of code,
we manually verified that none of the apps in our dataset contain
sanity checks in any of these categories. In fact, as shown by
previous work [16], native code is typically not used to implement
the main application’s logic, but it is used, instead, in library helper
functions Also, note that, differently from previous work, this
does not mean that DIANE cannot handle native code at all. In
fact, even if the sendMessage function is implemented natively,
DIANE can identify it and fuzz its fuzzing triggers. However, if
sanity checks are present in any of the aforementioned classes of
code, the fuzzing is less effective.
As any approach based on dynamic analysis, DIANE suffers
from limited code coverage, i.e., it cannot identify fuzzing triggers
that are not executed by the app. To mitigate this limitation,
we manually stimulate the apps to trigger most of the available
functionality, and we perform our analysis on real smartphones.
The current implementation of DIANE cannot fuzz nested Java
objects. We plan to address this in future work.
DIANE could be enhanced to automatically discover semantic
vulnerabilities (e.g., a smart lock unlocks a door instead of locking
it). Currently, this feature is semi-automatic as it requires the
analyst to check and interact with the watchdog device.
VI. RELATED WORK
IoT devices are plagued with vulnerabilities [59], [48], [27],
[18]. Consequently, different automated vulnerability detection
tools [31], [32], [70], [71] have been proposed, relying on static
analysis techniques. Unfortunately, the applicability of these tools
is limited since they require the device firmware.
Dynamic analysis, and in particular fuzzing [60], is a popular
alternative technique that mitigates the problems of static analysis
at the cost of missing potential bugs. American Fuzzy Lop
(AFL) [85], along with its several improved versions [19], [20],
[56], [35], [67], is the most popular coverage-guided fuzzing tool.
However, coverage-guided fuzzing is hard to perform on real
devices, as it requires to keep track of the code locations reached
while fuzzing the analyzed firmware. It is possible to perform
this tracking using hardware debugging capabilities [72], but,
unfortunately, they are usually disabled in consumer devices [55],
[61], [25]. Other approaches have proposed to fuzz IoT devices
by emulating the corresponding firmware [87], [73], [43], [24],
[42]. Unfortunately, a faithful emulation of a firmware image is
a hard problem, and these approaches have scalability issues.
Input generation is one fundamental capability underpinning
any fuzzing technique. Taint tracking [44], [36], [26], symbolic
execution [22], [38], [39], [23], [74], [62] and static analysis [57],
[69] have been commonly used to handle the problem of input
generation. Unfortunately, all of these techniques require to
instrument the analyzed firmware code.
Authorized licensed use limited to: Tsinghua University. Downloaded on February 25,2022 at 12:29:05 UTC from IEEE Xplore.  Restrictions apply. 
496
Grammar-based fuzzing techniques [66], [77] side-step the prob-
lem of input generation by requiring a model of the inputs [41], [46],
[37], [54], [33] accepted by the program under test. Consequently,
techniques based on static analysis [30] and dynamic analysis [58],
[28], [45] have been developed to create models of valid inputs ac-
cepted by the analyzed software. However, these approaches are not
suitable to fuzz IoT devices, as user requests are usually encrypted
by the companion app, and devices might rely on ad-hoc grammars.
DIANE solves the problem of input generation by using network
traffic and hybrid analysis of the app controlling the target IoT
device. Recently, Chen et al. proposed IoTFuzzer [25]. IoTFuzzer
analyzes the IoT device’s APK, and automatically finds paths
where user-generated input is handled. Then, for each of them,
it fuzzes the arguments of the first function handling such data.
While IoTFuzzer shares some similarities with our approach,
it suffers from a number of drawbacks, which we discussed in
detail in Section II. Wang et al. [79] leverage an IoT device’s
companion app to detect the characteristics of the device (e.g.,
a smart plug), and infer its vulnerabilities by relying on a set of
known vulnerabilities affecting similar devices. However, their
approach does not find unknown vulnerabilities.
RPFuzzer [81] finds vulnerabilities in router protocols. However,
its techniques are customized to find routing-related issues, and
are not applicable to generic IoT devices.
Peng et al. [67] recently proposed T-Fuzz, an approach for input
generation that first transforms the target program to skip checks on
input values, and then fuzzes the transformed program. T-Fuzz goal
is to increase code coverage by bypassing input validation – T-Fuzz
flips the if-conditions guarding those branches where the fuzzer
gets stuck. However, T-Fuzz is not suitable for our scenario, since it
requires access to the hardly available firmware of the IoT device.
T-Fuzz could be used to fuzz the companion app. However, our
goal is not to increase our coverage of the companion app, but to
identify fuzzing triggers and use them to fuzz the code running
in the analyzed IoT device. In fact, T-Fuzz flips if-conditions
without considering whether they are part of sanitization functions
or data-transforming functions. As such, T-Fuzz would inevitably
modify parts of the companion app’s code that are essential in
producing valid inputs for the IoT device. Therefore, applying
the T-Fuzz approach on a companion app will not increase the
effectiveness of the fuzzing of the controlled IoT device. For
this reason, we need an approach like DIANE, which is able to
selectively determine the checks to be bypassed.
Similarly, Wang et al. [78] proposed TaintScope, a directed
checksum-aware fuzzing approach that bypasses sanity checks to
penetrate deeper in the analyzed program. As such, TaintScope
prevents generated test cases from being prematurely dropped
by integrity checks on the targeted program. However, this tool
is applicable only when the firmware of the device is available.
When the firmware is available, other dynamic analysis tools
like AVATAR [84], SURROGATES [52], FIRM-AFL [87], and
FirmaDyne [24] could be used to improve the effectiveness of
vulnerability identification. On the other hand, we performed our
evaluation on real devices, without the need for firmware.
Data-flow tracking tools could be helpful to identify our fuzzing
triggers. Dynamic analysis tools track interactions within the
Dalvik [34] or the ART [75] runtime. However, it is not trivial to
extend these techniques to apps containing native code.
Ispoglou et al.[47] proposed FuzzGen, a tool to automatically
generate fuzzing harnesses for libraries. Unfortunately,
this
approach is not directly applicable to our usage scenario. In
particular, FuzzGen requires the code of the library it generates the
harness for. Therefore, it cannot be applied to IoT devices, since
their code is typically unavailable. FuzzGen’s approach could be
used to generate fuzzing harnesses for the libraries used by the
companion apps. However, this approach would not be effective
in generating inputs targeting the analyzed IoT device. In fact,
in companion apps, the logic to prepare and send well-structured
messages to the controlled IoT device is usually implemented in
the core of the companion app itself, rather than in its libraries.
For known protocols, network-based approaches like BED [2],
Katyusha [12], WSFuzzer [14] could be used to perform fuzzing.
However, extending them to custom data formats used by IoT
devices is non-trivial given the heterogeneity of these devices.
Furthermore,
these tools cannot handle challenge-response
sequences [21], heavily limiting their fuzzing effectiveness.
Finally, Junior et al. [50] assessed the security of the
communication channels between IoT devices and their companion
apps, identifying several flaws (e.g., lack of authentication).
VII. CONCLUSIONS
In this paper, we studied the effectiveness of IoT device fuzzers.
On the one hand, randomly fuzzing network packets sent to the
devices requires knowledge about the data format accepted by a de-
vice, which is seldom available when devices use custom firmware.
On the other hand, approaches that leverage the UI of the compan-
ion mobile app to produce syntactically correct messages are inef-
fective because of the constraints that the app-side code imposes.
Conversely, we proposed a novel approach that sits in the sweet
spot between network-level fuzzing and UI-level fuzzing. Our
approach aims at identifying fuzzing triggers, which are portions
of code in the IoT companion apps that are executed after input
validation and right before any data-transforming function, and that
maximize the fuzzing outcome. We implemented our approach in
a tool, called DIANE, and evaluated it on 11 real-world IoT devices
of different brands. DIANE outperforms the current state-of-the-art
approach, and it can successfully detect critical bugs (9 zero-days)
that cannot be triggered by existing fuzzers.
ACKNOWLEDGEMENTS
We would like to thank our reviewers for their valuable
comments and inputs to improve our paper. This material is based
upon work supported by AFRL under Award No. FA8750-19-
C-0003, and by ONR under Awards No. N00014-17-1-2011 and
N00014-17-1-2897. Research was also sponsored by DARPA
under agreement number HR001118C0060. The U.S. Government
is authorized to reproduce and distribute reprints for Governmental
purposes notwithstanding any copyright notation thereon. The
views and conclusions contained herein are those of the authors
and should not be interpreted as necessarily representing the
official policies or endorsements, either expressed or implied, of
DARPA, the U.S. Government, or the other sponsors.
Authorized licensed use limited to: Tsinghua University. Downloaded on February 25,2022 at 12:29:05 UTC from IEEE Xplore.  Restrictions apply. 
497
REFERENCES
[1] “500
internal
server
error,”
https://developer.mozilla.org/en-
US/docs/Web/HTTP/Status/500.
[2] “bed - A network protocol fuzzer,” https://tools.kali.org/vulnerability-
analysis/bed.
[3] “boofuzz: Network Protocol Fuzzing for Humans, successor to the venerable
Sulley fuzzing framework,” https://github.com/jtpereyda/boofuzz.
[4] “BSS (Bluetooth Stack Smasher) Fuzzer,” https://securiteam.com/tools/
[5] “CVE Database for Iot Vulns1,” https://cve.mitre.org/cgi-bin/cvekey.cgi?
5NP0220HPE/.
keyword=router.
keyword=belkin.
keyword=smart-home.
[6] “CVE Database for Iot Vulns2,” https://cve.mitre.org/cgi-bin/cvekey.cgi?
[7] “CVE Database for Iot Vulns3,” https://cve.mitre.org/cgi-bin/cvekey.cgi?
[8] “Frida: Dynamic instrumentation toolkit for developers, reverse-engineers,
and security researchers.” https://frida.re/docs/android/.