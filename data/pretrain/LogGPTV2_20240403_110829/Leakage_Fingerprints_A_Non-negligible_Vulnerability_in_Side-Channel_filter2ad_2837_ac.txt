Weight in Table 4.
θ[]
HW◦θ[]
θ[]
HW◦θ[]
θ[]
HW◦θ[]
0x0
0x1
0x2
0x3
0x4
0x5
0
0x6
2
0xc
2
1
0x7
3
0xd
3
1
0x8
1
0xe
3
2
0x9
2
0xf
4
1
2
0xa
0xb
2
3
Table 4: Hamming Weight of θ[].
Based on the table above, two arrays of 16 guessing
ﬁngerprints each can be extracted with the starting point
of [θ(i) + 0] and [θ(i) + 0]%16 in the form of
Gf p(θ[i]) = Seq{HW ◦ [θ(i) + r] |r ∈ [0, 10]}
Gf p(θ[i]%16) = Seq{HW ◦ [θ(i) + r]%16 |r ∈ [0, 10]}
respectively, where i ∈ [0, 15]. We only list all guessing
ﬁngerprints for Gf p(θ[i]%16) in Appendix B in the order of
longest sequence match, and obviously two longest undis-
tinguishable sequences start at [θ[4]%16] and [θ[8]%16] and
last 4 elements in both sequences.
3Unlike any other parts of this article, the “mod 16”
operation is explicitly added in this subsection when it
appears for the need of the expression
812 (1 + p)/2 ∗ δ(Y − X) + (1 − p)/2 ∗ δ(Y − X − 2)
X = 2
p ∗ δ(Y − X) + (1 − p)/2 ∗ δ(Y − X − 2) + (1 − p)/2 ∗ δ(Y − X + 2) X = 4
(1 + p)/2 ∗ δ(Y − X) + (1 − p)/2 ∗ δ(Y − X + 2)
X = 6
fp(Y |X) =
(4)
Figure 3: Deviation model for HW recovery where p = 0.65
With both the guessing ﬁngerprints and the leakage
ﬁngerprints, the recovery of [O(i) + 0] can be depicted in
two steps:
• Step one: Mapping the leakage ﬁngerprint Tf p([O(i)+0])
or Tf p([O(i)+0]%16) into Hamming Weight ﬁngerprints
Mf p([O(i)+0]) or Mf p([O(i)+0]%16) by performing tem-
plate attacks at 11 leakage positions individually.
• Step two: Comparing 16 guessing ﬁngerprints with
Mf p([O(i)+0]) or Mf p([O(i)+0]%16), and determine the
leakage source with the criteria:
O(i) = argmin
Euclid(Mf p(O(i)), Gf p(θ[j]))
θ[j]
O(i) = argmin
Euclid(Mf p([O(i)+0]%16), Gf p([θ[j]+0]%16))
θ[j]
In order to further evaluate the robustness of our oﬀset
recovery approach, we conduct three ﬁngerprint identi-
ﬁcation experiments under the scenarios of strong noise
and low success rate of HW recovery at single position.
Each experiment also evaluates the inﬂuence of diﬀerent
ﬁngerprint lengths. As in 3.2, we ﬁrst make a rough
construction of the probabilistic model fp for deviation.
More precisely, we deﬁne X ∈ {0, 1, 2, 3, 4} as the correct
HW corresponding to a certain leakage position and Y ∈
{0, 1, 2, 3, 4} the guessing result based on that leakage, thus
fp is deﬁned in Equation 5, where δ is the Dirac distribution.
It should be specially mentioned that when the HW of
the variable X happens to be 0 or 4 in oﬀset’s value range,
the possibility of no deviation guesses is designed to be the
accumulation of both p and (1-p)/2. The rationality of this
probabilistic model has been stated in 3.2 and the results
are recorded in the Table 5.
l
p
0.65
0.50
0.35
6
7
8
9
10
11
89.9% 91.6% 94.4% 96.8% 97.1% 98.2%
75.2% 84.5% 88.5% 93.7% 95% 97.7%
60.5% 72.1% 77.5% 86.2% 89.8% 93.4%
Table 5:
Identiﬁcation accuracy under diﬀerent
length of ﬁngerprint and deviation model fp(Y |X).
In general, the results show the same tendency as in the
mask’s case. That is, with more accurate HW recovery at
single position and longer ﬁngerprint length, the identiﬁca-
tion success rate of leakage source increases as well. Besides,
it’s noteworthy that, under the condition of the same length
and center probability p, the identiﬁcation of mask array(In
Table 2) is less accurate than that of the oﬀset array, which
we believe may result from the wider range of possible values
and shorter distinguishable ﬁngerprint length in oﬀset’s case.
More importantly, as recorded in the right most column
of the table, with a total length of 11, the single position
recovery deviation has little eﬀect on the ﬁnal identiﬁcation
accuracy, and even in the worst case with p = 0.35, the
identiﬁcation success rate with a length of 11 can reach as
high as 93.4%, thus validating the eﬃciency and robustness
of our recovery scheme for oﬀset array.
3.4 Shufﬂe Fingerprints4
Though not necessary to reveal the shuﬄe array as we
would later state in Sec.4, we still present it here in order to
show the generality and hazard of the leakage ﬁngerprint.
Unlike both mask and oﬀset ﬁngerprints, Shuﬄe0 and
Shuﬄe10 array are used only once in the ﬁrst and last round
respectively making it much more diﬃcult to extract the
ﬁngerprint with suﬃcient length. In spite of this, the attack
with leakage ﬁngerprint still works well.
The essence of shuﬄe ﬁngerprints lies in the usage of
the shuﬄe array to disorder the sequence of Masked S-box
execution and also the storage of the output bytes. For
convenience of expression, Sf 0[] and Sf 10[] array are uniﬁed
as Sf x[] and the basic shuﬄe ﬂow contains:
1. Load Sf x[i],i ∈ [0, 15] as the index for oﬀset selection.
2. Load O(Sf x[i]), and add it with the round index r,
where r equals to 0 or 9.
3. Mod the result above with 16, making it suitable
for the selection of the input byte of Masked S-box.
The ﬁnal form of selected oﬀset is [O(Sf x[i]) + r]%16
denoted by Oidx.
4Unlike any other parts of this article, the “mod 16”
operation is explicitly added in this subsection when it
appears for the need of the expression
813 (1 + p)/2 ∗ δ(Y − X) + (1 − p)/2 ∗ δ(Y − X − 1)
p ∗ δ(Y − X) + (1 − p)/2 ∗ δ(Y − X − 1) + (1 − p)/2 ∗ δ(Y − X + 1) when X = 1, 2, 3
(1 + p)/2 ∗ δ(Y − X) + (1 − p)/2 ∗ δ(Y − X + 1)
when X = 4
when X = 0
(5)
fp(Y |X) =
4. Load X[Sf x[i]] ⊕ K[Sf x[i]] ⊕ M [Oidx] denoted by
Sin(Sf x[i]) as the input byte of M askedSubByteOidx .
5. Execute M askedSubByteOidx operation and store the
output in the temporary register.
6. Load mctable[Sf x[i]] to ﬁnd the correct memory lo-
cation for storing the output above, where mctable
is a lookup table previously calculated to record the
position of each byte after the ShiftRows operation.
Figure 4: Shuﬄed process of ShiftRows
7. Load the output of Masked S-box into the location
speciﬁed by mctable, thus ending both the Shuﬄed
MaskedSubBytes and ShiftRows simultaneously.
On the basis of these steps, the shuﬄe ﬁngerprint of length
6 can be extracted:
Tf p(Sf x[i]) = L ◦ Seq{Sf x[i], O(Sf x[i]), [O(Sf x[i]) + r]
, [O(Sf x[i]) + r]%16, Sin(Sf x[i]), mctable[Sf x[i]]}
+ Seq{εj |j ∈ [0, 5]}
This time, the list of the guessing ﬁngerprints is no longer
straightforward and cannot even be recorded since both
the Oﬀset array O() and the input state of Masked S-box
Sin() keep changing trace by trace which would inﬂuence
the guessing ﬁngerprints in each trace. The general form
of guessing ﬁngerprint can be written as, where ψ(i) = i,
i ∈ [0, 15]:
Gf p(ψ(i)) = Seq{HW ◦ ψ(i), HW ◦ O(ψ(i))
, HW ◦ [O(ψ(i)) + r], HW ◦ [[O(ψ(i)) + r]%16]
, HW ◦ Sin(ψ(i)), HW ◦ mctable[ψ(i)]}
Luckily, with oﬀset ﬁngerprint presented in 3.3, O() can
be recovered beforehand with a high probability making
it feasible to calculate HW ◦ O(), HW ◦ [O() + r], and
HW ◦ [O() + r]%16 respectively, which are later used to
extract values of three positions in the guessing ﬁngerprints
for each single trace. What is intractable is Sin() state
p
35%
50%
65%
80%
95%
Accuracy
under
max length
44.6% 55.9% 71.3% 83.5% 94.1%
Table 6: Identiﬁcation accuracy for Shuﬄe0 with
maximum length.
p
35%
50%
65%
80%
95%
Accuracy
under
max length
58.3% 69.7% 82.5% 92.4% 98.1%
Table 7: Identiﬁcation accuracy for Shuﬄe10 with
maximum length.
which keeps secret since the round key embedded remains
unknown. However, what we expect to acquire is the
Hamming Weight state of Sin() rather than Sin() itself and
HW ◦ Sin() can be extracted by template attack aiming
at the power leakage where the round key, mask state and
input state of each round are Xored together successively
to generate the Sin(). Thus the recovery of Sf x[i] can be
depicted by the formula:
Sf x[i] = argmin
Euclid(Mf p(Sf x(i)), Gf p(ψ(j)))
ψ[j]
where j ∈ [0, 15] and Mf p(Sf x(i)) can be extracted by per-
forming template attacks at Tf p(Sf x[i]). Last but not least,
we evaluate the success rate for ﬁngerprint identiﬁcation
with deviation model as deﬁned in 3.2 and 3.3. Specially, it
needs to be mentioned that, even under the same sequence
length, diﬀerent selection methods on a short ﬁngerprint
have great eﬀects on the ﬁnal identiﬁcation and thus we
only conduct the evaluation with the maximum length but
extend the variation range of probability p. Another special
note is that the recovery of HW ◦ Sin() array for guessing
ﬁngerprints extraction should also comply with the deviation
model since it is also acquired by template attack just
as Mf p(Sf x(i)), thus simulating the actual attack to the
maximum extent. The results for shuﬄe0 and shuﬄe10
identiﬁcation are shown in Table 6 and 7.
The tables demonstrate the positive relationship between
the identiﬁcation rate and the probability p. When p
increases higher than 80%, the accuracy of ﬁngerprint
identiﬁcation for both shuﬄe0 and shuﬄe10 reaches at
least 83.5%. Another obvious fact shown in two tables is
that with the same deviation probability, the accuracy of
shuﬄe10 identiﬁcation is always higher than that of shuﬄe0.
The reason is that the guessing ﬁngerprint of shuﬄe0 is
extracted from the ﬁrst encryption round, where r equals to
0, and thus the three fragments of the ﬁngerprint, namely
HW ◦ O(ψ(i)), HW ◦ [O(ψ(i)) + r] and HW ◦ [[O(ψ(i)) +
r]%16] invariably keep the same, which virtually shortens
the eﬃcient ﬁngerprint length for shuﬄe0, making it much
more diﬃcult to identify.
8144. VULNERABILITIES TO BYPASS SHUF-
FLE COUNTERMEASURES
For an analyst aiming at practical attacks against RSM2.0,
the ﬁrst idea that comes into mind, after recovering the
changing oﬀset array in each trace, is to exploit either the
masked S-box outputs of the ﬁrst round or the masked S-
box inputs of the last round as intermediate values for key
recovery. However, in consideration for the ﬁrst and the
second order security, both of these two attacking points are
protected by shuﬄe countermeasures in RSM2.0. Thus, in
order to make use of the leakages at these positions, it’s
a must to crack the changing shuﬄe array in each trace,
which eﬃciently improves the security level of RSM2.0 as
stated in [3].
In this section, we point out that the shuﬄe countermea-
sure is far from perfect to counteract ﬁrst order attack with
oﬀset array already cracked, and bypassing shuﬄe protection
is both practical and eﬀective (though we show the feasibility
to crack shuﬄe in 3.4).
4.1 Flaws in the First Round
As a replacement for the exploitable leakage of S-box
execution in the ﬁrst round, the ﬁrst ﬂaw lies in the
MixColumns layer of RSM2.0 which completes its logical
function with the help of a look up table called Xtime. The
table contains totally 256 elements and in the ith location,
where i ∈ [0, 255], the number 2 ∗ i under GF (28) is stored
as the index result for the input i. Then the MixColumns
process of each single column can be depicted below:
• Four input bytes of a column are ﬁrstly Xored and
stored in the temporary register in the form of (W 0 ⊕
W 1 ⊕ W 2 ⊕ W 3) and it is used later to calculate each
byte of the output column (W 0(cid:48), W 1(cid:48), W 2(cid:48), W 3(cid:48))T .
• In order to derive the ith output byte W i(cid:48), W i is ﬁrst
loaded into a register and then W i + 1 is Xored in.
The combination of (W i ⊕ W i + 1) is further used as
the index to go through the Xtime table, outputting
2 ∗ (W i ⊕ W i + 1) under GF (28).
• With values computed in the ﬁrst two steps, the ith
output byte W i(cid:48) can be derived from the formula
W i(cid:48) = (W 0⊕W 1⊕W 2⊕W 3)⊕2∗(W i⊕W i+1)⊕W i,
where i ∈ [0, 3] and i+1 should be understood “modulo
16”.
The exploitable leakage lies in the second step where W i
is unprotected loaded in the register individually. Actually,
as the input of MixColumns layer, each W i contains the
output byte of the MaskedSubBytes. Thus attacking this
leakage position with the usage of cracked mask makes no
diﬀerence with the exploitation of the common attacking
point of S-box output in the ﬁrst round.
4.2 Flaws in the Tenth Round
As for the ﬂaws in the tenth round, we mainly ﬁnd two
attacking points which can be used to perform the key
recovery attack with the oﬀset array already cracked, thus
bypassing the shuﬄe countermeasures. For simplicity, only
one column transformation is taken as an example and is
shown in Figure 5. The Xi and X(cid:48)
i in the ﬁgure represent
the input bytes of the ninth and tenth round respectively.
And Ki, K(cid:48)
i are the subkey bytes of the eighth and ninth
round respectively.
The ﬁrst ﬂaw appears in the MaskCompensation layer of
the ninth round. The layer can be accomplished in two
steps. A state of 16 compensation masks is calculated ﬁrst
and then they are Xored one by one with the outputs of
the previous round function. More importantly, this layer
is placed at the end of the AddRoundKey in the ninth
round, and thus the output values of it are served as the
inputs of the tenth round S-boxes. In other words, though
the usage of the masked S-box inputs is protected by the
shuﬄe countermeasures, the generation sequence of these
values keeps constant and remains unprotected. Thus, from
the perspective of the attackers,
it’s possible to predict
the hypothetical intermediate values served as the tenth
round inputs by guessing 16 subkey bytes in the last round
individually and associate these values with some ﬁxed time
instants in the power trace to perform the classic ﬁrst order
attack.
The other hidden attacking point lies in the ninth round
AddRoundKey operation.
It operates just after the Mix-
Columns and essentially the vulnerability is a result of the
sequential order to perform AddRoundKey.
In Figure 5,
It clearly shows that the only diﬀerence between the ﬁrst
and the second attacking point is the mask value added
for protection. More precisely,
in the ﬁrst exploitable
point, each intermediate byte correlates with a unique
mask from M [] and 16 masks used here are independent
from each other.
In contrast, without going through the
MaskCompensation layer, each byte in the second position
is Xored with a derived mask which depends on four masks
from M [] jointly. This kind of dependency leads to a
noteworthy fact that the guessing error in either one of
the four relevant masks would show a characteristic of error
propagation, resulting in mistakes in calculating a column
of four intermediate values. Therefore, the attacking point
should only be exploited on the basis of oﬀset array recovery