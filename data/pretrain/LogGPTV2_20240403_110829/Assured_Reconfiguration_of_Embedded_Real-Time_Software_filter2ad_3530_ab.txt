### System Operation and Reconfiguration

The system operates continuously from the time it begins until it is shut down. This process can occur in either functional modes defined by members of set \( S \) or in reconfiguration-specific modes. We assume that the application components implementing the elements of \( S \) possess the fail-stop property [11], which can be ensured through safe programming [1] or some form of protection shell [15].

#### Reconfiguration Mechanism Control

We assign overall control of the reconfiguration process to the reconfiguration mechanism, which offers two major benefits:
1. **Reusability**: The reconfiguration mechanism can be designed to be largely independent of the specific application, increasing its potential for reuse. If reused, the costs associated with formal verification can be amortized over multiple systems.
2. **Simplified Structure**: By deferring application-dependent complexity to the application itself, the reconfiguration mechanism remains a straightforward structure that can be analyzed with high confidence. Although this does not eliminate complexity, it encapsulates it within the application's design components (Sections 5.2 and 6 present a method for doing this).

In a fault-tolerant system, the reconfiguration mechanism must be more dependable than the application itself.

### Refined Properties and Events

To refine the properties given in Section 4, we define more specific events, actions, and predicates (as shown in Figure 2):

- **App**: Action representing the continuous operation of the application.
- **RM**: Action representing the operation of the reconfiguration mechanism.
- **↑RM**: Event that App signals a fault at the top level (equivalent to ↓Trans).
- **↓RM**: Event that a reconfiguration signal is sent to \( S_i \).
- **↓Si**: Action of App causing \( S_i \) to meet Post.
- **Post**: Predicate that must be true of App for reconfiguration to begin, protecting data and ensuring fail-stop behavior.
- **Choose**: Action of RM determining the member of \( S \) for \( S_j \).
- **Pretransj**: Predicate that must be true of App before passing control back to App.
- **Prepj**: Action of App causing Pretransj to be met.
- **Trans**: Action of App effecting a functional transition.
- **↑Trans**: Event that RM instructs App to transition to \( S_j \).
- **↓Trans**: Event that App acknowledges to RM that the transition is complete.
- **Trainj**: Action of App initializing \( S_j \) or training its data.
- **↑Trainj** and **↓Trainj**: Events related to the initialization and training of \( S_j \).
- **↑Sj**: Event indicating that \( S_j \) has initialized or trained all data and is operational.

For clarity, actions associated with \( S_i \) have occurrence number (a), actions associated with \( S_j \) have occurrence number (b), and all other actions have the occurrence number of \( R \) (c). This formalizes the idea that these actions occur during a particular reconfiguration.

### Temporal Structure and Reconfiguration Signals

Our temporal structure assumes that additional reconfiguration signals are not generated during the reconfiguration process. This is reasonable because no reconfiguration signals can be generated by the application during reconfiguration. If an external reconfiguration signal is generated, it can be buffered until control is passed back to the application during the training period for \( S_j \). If time does not permit this, the reconfiguration mechanism must have a signal handler to restart it during reconfiguration. Since the application postcondition would already be met, assuring reconfiguration from the reconfiguration mechanism is simpler than from the application.

### Detailed Application Structure

The structure we use for the application to enable reconfiguration assurance properties is motivated by the temporal model and the need to assure the properties presented in Section 2. We define properties that must be provided by the application to ensure that, together with the reconfiguration mechanism, they meet the general reconfiguration properties.

The application is built from a set of modules, each with an interface designed to support reconfiguration assurance. These modules follow decomposition rules similar to those used in building non-reconfigurable systems. Application properties are decomposed into module properties, so conjoining module properties (e.g., postconditions) gives the corresponding application property.

Each interface function takes a module-specific service level parameter, which instructs the interface to provide a specific level of function, ranging from basic safe service to more elaborate calculations or operations for full function. The composition of different module service levels allows the system to operate under different specifications.

Several options exist for module reconfiguration. We choose to make the module service level independent of the operational specification and pass the service level parameter as part of an interface call. This strategy allows modules to be constructed and analyzed independently and provides flexibility in using different service levels within the same operational specification. The calling module designer will know exactly which functional capability they are calling, and the reconfiguration time for the functional aspects of the system vanishes since the functional configuration is established dynamically at the time of a call.

### Architecture Capabilities and Properties

The full formal characterization of all design-level properties required to ensure high-level reconfiguration properties is complex and lengthy. Here, we state rigorously but informally the necessary design-level properties, including their relationship to the general RTL elements defined above. A system developer can then characterize these properties in their specific formalism to show them for the formal expression of the application's function.

All capabilities and properties are predicated on a reconfiguration trigger, i.e., ∃ t: time such that t = @(↓Si, a). It is often simple to show a property without this condition, but sometimes impossible since many events will not happen without the trigger. We leave this condition implicit for clarity but use it when needed.

#### Module Capabilities

Each module interface must provide the following capabilities:
- **Interface to Functions**: Access to the set of functions within the module, representing multiple service levels.
- **Service Level Parameter Values**: Define the service sets for the module.
- **Persistent Data Structures**: Relevant to preconditions, postconditions, and invariants. If empty, preconditions, postconditions, and invariants are defined to be true.
- **Module Postcondition**: A basic coherency condition representing the minimum state requirement for the application to continue operation.
- **Reconfiguration Signal Handling**: Mechanism for internal state restoration and propagation of reconfiguration signals to calling functions.
- **Module Transition Conditions**: Predicates that must be met before the module can begin training data associated with a member of \( S \).
- **Module Preconditions**: Predicates that must be met for the module to begin operation under an associated member of \( S \).
- **Service Transition Condition Guarantee**: Mechanism to ensure the module’s service transition condition is met.
- **Timing Guarantees**: For interface functions related to reconfiguration.
- **Assured Reconfiguration Invariants**: Similar to standard application invariants but affecting externally visible module data.

#### Application Capabilities

The modules composing the system are contained within a separate top-level structure called the monitoring layer, which includes:
- **M1 to M7**: Specific functionalities and conditions for module operations and reconfiguration.

### Summary

By clearly defining and structuring the reconfiguration process, we ensure that the system can operate dependably and efficiently, even in the presence of faults. The modular approach and the separation of concerns between the application and the reconfiguration mechanism enhance the system's reliability and maintainability.