数据结构
（v=VoVuMm=v），其中（vuvu）∈E，1∈E，1，若G是无向图，还需要增添对称孤
o
DeleteArc（*G，v，w）：在图G中删除弧，若G是无向图，则还删除对称弧
DFSTraverse（G）：对图G中进行深度优先遍历，在遍历过程对每个顶点调用。
HFSTraverse（G）：对图G中进行广度优先遍历，在遍历过程对每个项点调用。
endADT
7.4图的存储结构
图的存储结构相较线性表与树来说就更加复杂了。首先，我们口头上说的“顶点
图上任何一个顶点都可被看成是第一个顶点，任一顶点的邻接点之间也不存在次序关
系。比如图7-4-1中的四张图，仔细观察发现，它们其实是同一个图，只不过顶点的
位置不同，就造成了表象上不太一样的感觉。
223
---
## Page 248
大语数据结构
B
F
E
H
G
H
D
A
D
C
B
C
图1
图2
F
E
F
A
D
B
B
G
H
G
H
C
图3
图4
图7-4-1
也正由于图的结构比较复杂，任意两个顶点之间都可能存在联系，因此无法以数
据元素在内存中的物理位置来表示元素之间的关系，也就是说，图不可能用简单的顺
序存储结构来表示。而多重链表的方式，即以一个数据域和多个指针域组成的结点表
示图中的一个顶点，尽管可以实现图结构，但其实在树中，我们也已经讨论过，这是
有问题的。如果各个顶点的度数相差很大，按度数最大的顶点设计结点结构会造成很
多存储单元的浪费，而若按每个顶点自已的度数设计不同的顶点结构，又带来操作的
不便。因此，对于图来说，如何对它实现物理存储是个难题，不过我们的前辈们已经
解决了，现在我们来看前辈们提供的五种不同的存储结构。
7.4.1邻接矩阵
考虑到图是由顶点和边或弧两部分组成。合在一起比较困难，那就很自然地考虑
到分两个结构来分别存储。顶点不分大小、主次，所以用一个一维数组来存储是很不
错的选择。而边或弧由于是顶点与顶点之间的关系，一维搞不定，那就考虑用一个二
维数组来存储。于是我们的邻接矩阵的方案就诞生了。
224
---
## Page 249
第7章图
图的邻接矩阵（AdjacencyMatrix）存储方式是用两个数组来表示图。一个一维
数组存储图中顶点信息，一个二维数组（称为邻接矩阵）存储图中的边或弧的信息。
设图G有n个顶点，则邻接矩阵是一个nXn的方阵，定义为：
[1,若（vv,）∈E或EE
arc[i]
[0,反之
我们来看一个实例，图7-4-2的左图就是一个无向图。
项点数组：
VovVV
Q111
vQ10的度为2
边数组：
010
主对角线
图7-4-2
我们可以设置两个数组，顶点数组为vertex[4]={vo,VVz,vs}，边数组arc[4][4]为
图7-4-2右图这样的一个矩阵。简单解释一下，对于矩阵的主对角线的值，即
arc[0][0]、arc[1][1]、arc[2][2]、arc[3][3]，全为0是因为不存在顶点到自身的边，比
如vo到vo。arc[0][1]=1是因为vo到v的边存在，面arc[1][3]=0是因为v到v的边
不存在。并且由于是无向图，V到vs的边不存在，意味着v到v的边也不存在。所
以无向图的边数组是一个对称矩阵。
嗯？对称矩阵是什么？忘记了不要紧，复习一下。所谓对称矩阵就是n阶矩阵的
元满足a=aj，（0<ij≤n）。即从矩阵的左上角到右下角的主对角线为轴，右上角的元
与左下角相对应的元全都是相等的。