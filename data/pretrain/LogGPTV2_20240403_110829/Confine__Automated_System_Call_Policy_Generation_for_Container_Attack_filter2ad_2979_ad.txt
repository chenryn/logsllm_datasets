the attack surface, we evaluate how removing unused system
calls can reduce the risk of privilege escalation attacks. To that
end, our starting point was the vulnerabilities used in a previous
study by Lin et al. [54]. These vulnerabilities are exploitable
despite the use of container isolation mechanisms, such as
namespaces [18], cgroups [3], and capabilities [1]. To gain
a better understanding of the impact that ﬁltering individual
system calls has in neutralizing potential kernel vulnerabilities,
we mapped each CVE to its corresponding system calls.
7.3.1 Mapping Kernel CVEs to System Calls
To perform our analysis, we crawled the CVE website [5]
for Linux kernel vulnerabilities using a custom automated
tool. The tool parses each commit in the Linux kernel’s Git
repository to ﬁnd the corresponding patch for a given CVE,
and retrieves the relevant ﬁle and function that was modiﬁed by
the patch. After mapping CVEs to their respective functions,
we built the Linux kernel call graph and analyzed which parts
of it can be exclusively accessed by a given system call.
We constructed the Linux kernel’s call graph using
KIRIN [78]. This allows us to map which functions in the
kernel are invoked from which system call, and therefore
reason about which part of the kernel’s code will never be
invoked when a set of system calls are ﬁltered.
We discovered that while there are only a few CVEs
directly associated with the code of ﬁltered system calls, many
CVEs are associated with ﬁles and functions that are invoked
452    23rd International Symposium on Research in Attacks, Intrusions and Defenses
USENIX Association
100120140160180200220Filtered System Calls0%20%40%60%80%100%Cumulative % of ContainersTable 3: CVEs mitigated by removing unneeded system calls.
System Call(s)
set_thread_area
mq_notify
sched_getattr
io_submit
rt_(tg)sigqueueinfo
clock_nanosleep
ioprio_get
waitid
inotify_init1
semctl
inotify_add_watch
shmctl
semget, msgget, shmget
splice
epoll_ctl
setsockopt
([f,l]remove,[f,l]set)xattr
ioctl
madvise
# CVEs
1
1
1
1
1
1
1
2
1
1
1
2
1
1
1
5
1
26
2
CVE Examples
CVE-2014-8133
CVE-2017-11176
CVE-2014-9903
CVE-2010-3066
CVE-2011-1182
CVE-2018-13053
CVE-2016-7911
CVE-2017-14954, CVE-2017-5123
CVE-2010-4250
CVE-2010-4083
CVE-2019-9857
CVE-2009-0859, CVE-2010-4072
CVE-2015-7613
CVE-2009-1961
CVE-2012-3375
CVE-2016-4997, CVE-2016-8655
CVE-2011-1090
CVE-2010-2478, CVE-2009-0745
CVE-2012-3511, CVE-2017-18208
CVE Type
B
D
I
D
Other
O
P,D
B,P,I
D
I
D
I,D
P
D
D
P,M,O,D
D
I,P,B,O,D
D
# Imgs.
146
146
146
142
140
140
131
114
101
97
77
71
62
57
48
22
22
1
1
Docker Image Examples
Nginx, MongoDB, Apach Httpd, MySQL
Redis, CouchDB, Apache Httpd, MySQL
Postgresql, Nginx, Memcache
Rethinkdb, Apache Httpd, Nginx, Redis
MongoDB, Nginx, Apache Httpd, MySQL
MongoDB, Nginx, Apache Httpd, MySQL
Redis, Nginx, Apache Httpd, MySQL
Nginx, MongoDB, CouchDB, MySQL
Nginx, Apache Httpd, MySQL
Nginx, CouchDB, Redis
Nginx, Apache Httpd, MySQL
Iojs, Hylang, Rethinkdb
Julia, Iojs, Clearlinux
MongoDB, Rethinkdb, Oraclelinux
Crux, IBM-db2-warehouse-cc, Adminer
Euleros, Clearlinux
Clearlinux, Fluentd
Nats
Busybox
I: Obtain Information, P: Gain Privileges, B: Bypass a Restriction, O: Overﬂow, D: Denial of Service, M: Memory Corruption
exclusively by the code of ﬁltered system calls. By matching
the CVEs to the call graph created by KIRIN, we were able
to pinpoint all the vulnerabilities that are related to the set of
system calls ﬁltered by a given container. This provides us with
a quantiﬁable property to assess the attack surface reduction
achieved by our method, i.e., the number of CVEs that would
have been neutralized for a given container, if the respective
system call policy generated by Conﬁne was applied.
7.3.2 CVEs Mitigated by Conﬁne
Our results are summarized in Table 3. Linux kernel CVEs are
assigned a category depending on how their exploitation can
affect the underlying system. While privilege escalation has
the most severe outcome, others are important to consider as
well. Using a denial-of-service attack, the attacker can disrupt
the functionality of all containers and applications running on
the same host. The “Bypass a Restriction” category includes
attacks which allow the attacker to directly or indirectly bypass
isolation mechanisms. Similarly, exploiting a vulnerability in
the “Obtain Information” category could cause the leakage of
sensitive kernel data which endangers the isolation guarantees
provided to other containers.
Based on our analysis, in addition to the 25 CVEs mitigated
by Docker’s default Seccomp policy, 51 CVEs across all stud-
ied containers are effectively removed (i.e., the respective vul-
nerabilities cannot be triggered by the attacker) by applying our
generated policies. These include CVEs that an attacker could
exploit to perform denial-of-service attacks against the kernel
(CVE-2012-3375, CVE-2016-7911, and CVE-2017-11176),
perform privilege escalation attacks (CVE-2017-5123, CVE-
2016-7911, and CVE-2015-7613), or leak sensitive kernel in-
formation (CVE-2017-14954 and CVE-2014-9903). Of these
51 CVEs, seven were removed in more than 130 containers.
8 Discussion and Limitations
As shown in Table 3, the system calls ﬁltered by our technique
are not very commonly used, but at the same time mitigate a
large number of previously disclosed kernel vulnerabilities.
We must emphasize that although system calls such as execve
and mmap are used as part of user-space exploits, any system
call associated with a kernel CVE can be used to exploit
the kernel. For an attacker seeking to escape a container,
exploiting commonly used system calls such as execve or
mmap provides no additional beneﬁt over exploiting system
calls such as waitid, which are used less frequently.
In addition to launching applications from scripts and
the command line, most programming languages give the
programmer the ability to launch applications using special
library calls, such as execve. As it is not guaranteed that such
invocations will occur within our monitoring window, our
approach may fail to analyze any executables launched in
this way. Currently, the developer is expected to provide a list
of binaries executed using such library calls. Our approach
provides an initial list of applications for the user to build
upon, which can further reduce the manual effort required.
A better alternative would be to statically analyze the source
code of all invoked applications to identify process creation
events. This can easily be done for applications written in
interpreted languages, as they are typically supported by many
static analysis tools (e.g., php-ast [62] for PHP, or the built-in
AST [21] functionality for Python). We executed php-ast on
the Wordpress Docker image and validated the correctness of
extracting paths of binaries which could be passed to any exec-
like function (e.g., php_exec, shell_exec). This could easily
be extended to applications written in different languages. We
leave the full implementation of such a capability as part of
our future work, since it only requires engineering effort.
USENIX Association
23rd International Symposium on Research in Attacks, Intrusions and Defenses    453
Although not recommended, some Docker images use cron
jobs to run periodic tasks in the container. In these cases we
expect the user to provide the list of programs which can be
executed through cron, although again such cases could be
automatically handled by parsing the crontab ﬁle.
9 Related Work
Static source code analysis for deriving system call policies
has been a widely used approach in the ﬁelds of sandboxing
and host-based intrusion detection [33–35, 43, 49, 61, 67, 74].
Our work mainly falls in the area of software debloating, and
we thus discuss related works in this context.
9.1 Container Security and Debloating
Wan et al. [75] use dynamic analysis to proﬁle the running
applications on a container and generate corresponding
Seccomp ﬁlters. DockerSlim [8] is an open source tool which
also relies on dynamic analysis to generate Seccomp proﬁles
and to remove unnecessary ﬁles from docker images. As
discussed in Section 7.2.2, all required system calls cannot be
reliably extracted through dynamic analysis alone—especially
for cases that handle exceptions and errors, which are typically
not part of the common execution paths. Therefore, dynamic
analysis cannot guarantee complete coverage of all the
system calls required by each application. Our system, on the
other hand, provides a more comprehensive static analysis
mechanism for extracting the system calls used by a container.
Speaker [52] separates the required system calls into two
main phases, booting and runtime. It dynamically extracts the
required system calls for each phase and ﬁlters them based
on the necessity of each state. Cimpliﬁer [68] splits containers
running multiple applications into multiple single-purpose
containers using dynamic analysis. Rastogi et al. [69] propose
improvements to Cimpliﬁer [68] through symbolic execution.
Previous works have also focused on container security
form the perspective of software protection mechanisms and
vulnerabilities. Lin et al. [54] provide a dataset of security
vulnerabilities and exploits which can potentially bypass the
software isolation provided by the Linux Kernel. One of their
recommendations is the use of stricter Seccomp policies for
containers. Shu et al. [71] have created a framework for per-
forming vulnerability scanning on images found on Docker
Hub. Combe et al. [31] explored the security implications of us-
ing containers, by considering adversary models which assume
complete access of an adversary to one container on a host.
9.2 Application Debloating
Most of the prior works in the area of debloating have focused
on removing unnecessary code from individual processes.
Mulliner and Neugschwandtner [58] proposed one of the
ﬁrst approaches for library specialization, which identiﬁes
and removes all non-imported library functions at load
time. Quach et al. [66] developed a modiﬁed loader and
compiler to perform shared library specialization by removing
unnecessary functions extracted through call dependency and
function boundary identiﬁcation at compile time. Agadakos et
al. [27] perform similar library specialization, but at the binary
level. BlankIt [63] only loads library functions upon request,
keeping the program and only parts of the library which are
required at that moment in the process address space. Song et
al. [72] used data dependency analysis to show the potential of
ﬁne-grained library customization of statically linked libraries.
Shredder [56] and Safﬁre [57] restrict the arguments passed
to critical system API functions to only legitimate values
extracted from each application’s code. Qian et al. [64] use
training and heuristics to identify basic blocks which can be
removed from a binary, while Ghaffarinia and Hamlen [36]
restrict the control ﬂow of the binary, instead of removing the
extra code using a similar training approach.
Sysﬁlter [32] uses binary analysis to identify the set of re-
quired system calls for a given application, and restricts access
to them through binary rewriting performed by Egalito [76].
While Conﬁne mainly relies on the libc call graph generated
through source code analysis, Sysﬁlter relies on the binary,
which could cause loss of precision and overapproximation in
identifying the set of required system calls. Temporal system
call specialization [37] disables system calls according to
the execution phase of server applications, allowing many
security-critical system calls (e.g., execve) to be disabled
after the application ﬁnishes its initialization phase.
Other works explore the potential of software debloating
based on predeﬁned features. CHISEL [41] is a framework for
shrinking software using a reinforcement learning approach
based on test cases provided by the user. The overall approach
is driven by the test cases, reducing the code size while
ensuring that none of the test cases fail. TRIMMER [39] uses
inter-procedural analysis to ﬁnd unnecessary parts of code
based on user-deﬁned conﬁguration data.
Other works in this area have also focused on different
programming languages [44, 73, 77]. Jred [77] performs static
analysis on Java code to remove unused methods and classes.
Jiang et al. [44] propose feature-based debloating for Java
programs using data ﬂow analysis.
9.3 Kernel Debloating
Several works focus on debloating the kernel and customizing
it according to user requirements. KASR [79] and FACE-
CHANGE [80] use dynamic analysis to identify unused parts
of the kernel and use virtualization mechanisms to limit each
application to its proﬁle. Kurmus et al. [50] propose a method
for tailoring the Linux kernel to special workloads through
automatic generation of kernel conﬁguration ﬁles.
454    23rd International Symposium on Research in Attacks, Intrusions and Defenses
USENIX Association
10 Conclusion
Our work was motivated by the lack of a generic solution for
the automated generation of restrictive system call policies
for container environments—one that does not rely on training
with realistic workloads, which is a cumbersome and error-
prone method. We believe that the results of our experimental
evaluation demonstrate the practicality of the proposed
approach, as Conﬁne managed to disable (without breaking