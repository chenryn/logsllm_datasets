Doxygen on itself. Avg of 5 runs
Program
Doxygen
FireFox/wlibxul Dromaeo recommended tests
Xalancbmk_r
parest_r
mysqld
Spidermonkey
Nodejs
runcpu
runcpu
Tests in the auth_sec suite
Test suite jit-test.py. Avg of 5 runs
12 benchmark tests
passes in-tree. For VT Expander and the combination of both passes
we chose an expansion factor f of between .1 and .4, which was
selected as a range large enough to prevent directional inference,
but small enough not to bloat the binary needlessly. The test set is
composed of 7 binaries 4, which were selected based on their range
of complexities and real world application. For size comparison we
elected to use Libxul.so, which is compiled as part of Firefox’s build
process as the Firefox binary itself is relatively small and has few
subVTables. Each was compiled with VTable splitting and function
expanding under -O0, -O2 and -O3 optimization levels, along with
a ground truth case, and combined splitting and expanding. The
ground truth is obtained by compiling each of the programs with
default compiler options at their respective optimization levels. This
makes a total of 12 binaries per application. Lastly, we compare
the binary sizes and performance rate of the programs compiled
with each technique against the ground truth. We use a subset of
this set for our tests against DeClassfier. This subset consists of
binaries compiled at -O0, as the goal is simply to demonstrate that
VTable splitting interferes with its ability to correctly recover the
completed object VTable layout, even in its most ideal use case.
Performance testing. For performance, we measured the average
change in execution time for varying tasks suited to each program,
listed in table 3. We ran tasks that did not include multiple sub
tasks (i.e., were not part of a test suite) five times and averaged the
results.
6.2 Binary Size
In this section we show the change in binary size of programs com-
piled with VT Splitter only, VT Expander only, and both techniques
combined. For VT Splitter 4, we record an average increase of 0.02%.
This is expected since we keep the same number of overall VTable
entries in the binary. The small overall size increase comes pri-
marily from the code required to use the VTables in constructions
being slightly larger, because they cannot be loaded from their base
VTables address via an offset.
For VT Expander 4 we record an average increase of 1.40%. This
falls within our expected results as we are increasing the overall
number of VTable entries in the binary by a range between 10% and
40%. Table 2 shows the total number of VTables that VT Expander
is acting on, and we expect an absolute size increase to any given
binary relative to the number of VTables that are expanded. For
binaries compiled with both techniques, we record an average
percentage change of 1.42%, which is consistent with our other
results.
153ABI Debiasing
ACSAC 21, December 06–10, 2021, Online, ACM, New York, NY USA
Figure 4: Binary size overheads for splitting, expanding, and a combination of the two.
Figure 5: Performance overheads for splitting, expanding, and a combination of the two.
Negative change in binary size. Several of the -O0 results indicate
a negative file size change, and in general the -O0 size increase
appears quite low across almost all of the tests. This is due to the
fact that our implementation takes advantage of LLVM’s dead global
elimination pass to safely and cleanly remove old VTables from
the IR after they have been updated. Because we force this pass to
run after VTable splitting or expanding it also removes any other
dead globals it can detect. For the baseline -O0 this pass is not run,
leaving the dead globals in the binary.
Identical baseline size. We observed an anomaly in our evalua-
tion for spidermonkey at -O2 and -O3. Despite adding the correct
optimization flags, we observe that the binary sizes for this program
remain identical across two optimization levels. However despite
the identical file sizes, the hash for each of these binaries is differ-
ent, we can only surmise that there is some part of the compilation
process which enforces this similarity.
6.3 Correctness and Performance
VT Splitter, VT Expander and both combined were evaluated for
correctness and performance (figure 5). For correctness all the tests
and benchmarks run passed and functioned as expected. This jus-
tifies our claim that both VTB and FPB are insensitive biases. For
VT Splitter, we record an average decrease in the execution time
for the selected tasks of -0.01%. This low performance overhead is
expected due to the low impact that splitting the VTables apart in
memory has on the code generated by the compiler. This code needs
to use larger instructions to load the sub-tables in a very limited
number of places. Likewise for VT Expander we observe an average
penalty of 0.48%, In this case the overhead is from locality issues
caused by the larger VTable sizes. Lastly, for binaries compiled with
both techniques, we record an average increase of 0.66%, which is
consistent with a combination of the overheads when the passes
are taken separately.
154ACSAC 21, December 06–10, 2021, Online, ACM, New York, NY USA
David Demicco, Rukayat Erinfolami, and Aravind Prakash
Negative performance overhead. Several of the programs show
negative results in overall performance overheads. Doxygen demon-
strates a fairly consistent gain of around 3% under expanding and
combined expanding and splitting. Or investigation of this phenom-
enon has shown no specific reason why this might be the case. The
layout of VTables in memory does not seem to affect performance,
and the number of references to the expanded VTables inside the
code does not seem to be affected in any significant way (i.e., the
number of times the VTable is dereferenced). No additional func-
tion inlining gets enabled by this technique, nor are there shorter
code sequences for each dereference. That is, the location of the
sub-VTable is still loaded, and then an offset is used as part of the
call instruction. Given these findings, we can only conclude that
the negative performance overhead is due to the margins of errors
for most of our tests being greater than the overall change in perfor-
mance, which leads to variance around the average case’s relatively
lower overhead.
7 SECURITY ANALYSIS
In this section, we discuss the security implications and potential
ways a reverse engineer/attacker can detect or take advantage of
the debiasing efforts of VT Splitter and VT Expander.
7.1 Impact on Reverse Engineering
By design, VT Splitter and VT Expander do not alter program
logic, as such the reversibility of program logic is unaltered by
our solution. Further, since VT-Expander inflates VTables with
unreachable function pointers, its efficacy depends on the reverse
engineer’s ability to identify newly added function pointers. If an
analyst can delineate real and inflated function pointers, they can
simply exclude the inflated pointers and apply size comparisons to
infer inheritance direction.
VT-Expander ensures that only reference to all function pointers
in all VTables are through the base of the VTables. Therefore, any
possible information leakage through code references are avoided.
Second, it is possible that an analyst can detect function pointer
offsets at virtual function callsites (e.g., vfGuard [23] or VTInt [28]).
However, these offsets will only reveal that there exists some VTable
in which the detected offset is valid. Because VT-Expander normal-
izes VTable sizes across all VTables in the binary, each inflated
offset will also be a legal offset in some VTable in the binary. There-
fore, no additional information is revealed to the analyst. Finally, by
inserting pure_virtual functions as function pointers in the inflated
VTables, VT-Expander introduces an additional dimension of un-
certainty with respect to inheritance. Although not a requirement,
it is common for pure virtual functions defined in base classes to
be overridden by concrete implementations in the derived class. By
randomly introducing pure_virtual function pointers in the VTable,
any such inference mechanisms are hindered.
7.2 DeClassifier
We demonstrate the effectiveness of VT Splitter against DeClassi-
fier by running it against the subset of binaries selected is shown
in table 4. While VT Splitter does not prevent DeClassifier from
recovering the correct number of primary VTables, it does cause it
Table 4: Table showing the number of groups DeClassfier
found in the baseline compiler, and the total groups found
after applying VT Splitter, broken up into correct and incor-
rect grouping
Programs
Doxygen
Xalancbmk
Parest
Baseline
Groups
65
17
82
VTSplitter
Groups
44
27
90
Incorrect
Groups
37
13
71
Correct
Groups
7
14
19
to misidentify the groupings that these VTables belong to. This pre-
vents DeClassifier from being able to recover the correct completed
object VTable for the incorrect groups as part of the scanning and
grouping process described in 2.4. Without these completed object
VTables you cannot match the VTable group to a single class in the
source code. The incorrect groupings may also lead to an incorrect
understanding of how the binary being examined functions.
7.3 Reachability and VT Expander
By performing a reachability analysis on a binary that has been
modified by VT Expander, an attacker may discount some – if not
all – of the added dummy entries. Consider object D in Figure 3. A
call to virtual function &B::vB1 invoked on object B-in-D would
appear in the code as follows:
. . .
load
rdi , 
/ / t h i s p o i n t e r
/ / setup args
load
c a l l
rax , 
qword p t r [ rax + 16]
/ / VT_Offset (&B : : vB1 )==16
. . .
Through static analysis, an attacker can (a) extract all virtual
function callsites [23], (b) identify invoking object and correspond-
ing vtable (through overwrite analysis [21]), and (c) identify VTable
offset that is accessed [23]. By excluding offsets that were refer-
enced at callsites for a particular object type, the dummy VTable
entries introduced by VT Expander can be identified.
We propose two approaches to make static analysis hard:
1) Use of pure virtual functions: We introduce pure_virtual entries
in the VTable. These entries are not reachable (by definition) and
are meant to be overridden in a derived class. One or more pure
virtual function pointers that follow legitimate entries in a VTable
can not be excluded as dummy entries through static analysis.
2) Dead code addition: We propose adding statically indeterminable
yet dead code into the binary that comprise of virtual function
invocation to the dummy function pointers. For example, calling
& F1 in B-in-D’s VTable would take the form of if(expr){ d->F1(); }.
The expression expr is carefully chosen such that it always resolves
to false at runtime, but can not be proven to be false through static
analysis. Ideally, the dead code would be instrumented into the
IR. To further complicate static analysis, the expression could be
modeled as a function of user input and/or indirectly referenced
memory.
155ABI Debiasing
ACSAC 21, December 06–10, 2021, Online, ACM, New York, NY USA
7.4 Impact on Exploitation
Exploits in the past have leveraged function pointers in VTables as
gadgets in order to execute code-reuse attacks [25]. Therefore, in-
flated VTables generated by VT Expander—in its current form—may
increase the overall gadgets available to such attacks. However, the
techniques incorporated by VT Expander are generic and extensible.
VT Expander can be modified to emit both functions and pointers
to those functions in the debiased VTables such that the functions
do not perform any meaningful execution (as opposed to gadgets
in code reuse attacks that must perform some useful action).
8 RELATED WORKS
Generally, binary analysis tools rely on the ability to recover se-
mantics from the binary based on the specifications of the ABI.
SmartDec [10] attempts to statically recover multiple C++ specific
language constructs including classes, inheritance tree, virtual and
non-virtual member functions, calls to virtual functions and excep-
tion handling. Most of the proposed techniques are dependent on
the ABI specification.
VTI [3] uses the new ABI VTable rules to break apart the com-
plete object VTables and re-arrange them in process memory in
order to protect against VTable hijacking. While their work splits
VTables apart, the reordering they perform does not remove in-
formation from the binary, only changes the layout in a different
predictable manner.
VCI [6] recovers class hierarchy from a binary by performing
constructor analysis. This analysis is based on the specification
which states that the constructor of a derived class calls those of its
bases. Constructor analysis simply identify such constructor calls
to recover at least a partial class hierarchy tree. Similarly, Marx [21]
performs overwrite analysis which is also based on the operations
performed in constructors/destructors. Overwrite analysis is more
robust than constructor-only analysis since it is largely unaffected
by inlining which is as a result of optimization.
DeClassifier [7] is built to recover class hierarchy from opti-
mized binaries. It combines multiple techniques to recover as much
information as is present in the binary. It performs constructor/de-
structor analysis, overwrite analysis, and object layout analysis.
Overwrite analysis allows Marx to only group related classes into
sets with no direction of inheritance, while object layout analysis
allows DeClassifier to assign direction of inheritance relationships
identified using overwrite analysis.
ROCK [18] performs both statistical and behavioral analysis to
recover class hierarchy from the binary. The behavioral analysis is
based on the ABI specifications such as constructors, VTable size,
position of virtual function pointers in the VTable.
vfGuard [23] proposed the VTable identification analysis which
it uses to enforce CFI policy at indirect callsites in the binary. The
VTable identification analysis is based on the well defined structure
of the VTable which makes identifying them robust.
OOAnalyzer [24] and OBJDigger [16] recover methods and group