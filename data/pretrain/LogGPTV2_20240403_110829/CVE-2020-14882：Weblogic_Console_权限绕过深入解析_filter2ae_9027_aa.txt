# CVE-2020-14882：Weblogic Console 权限绕过深入解析
##### 译文声明
本文是翻译文章
译文仅供参考，具体内容表达以及含义原文为准。
作者：Hu3sky@360CERT
## 0x01 漏洞简述
2020年10月29日，360CERT监测发现 `Weblogic ConSole HTTP 协议代码执行漏洞` 相关 `POC`已经公开，相关漏洞编号为
`CVE-2020-14882,CVE-2020-14883` ，漏洞等级：`严重`，漏洞评分：`9.8`。
远程攻击者可以构造特殊的`HTTP`请求，在未经身份验证的情况下接管 `WebLogic Server Console` ，并执行任意代码。
对此，360CERT建议广大用户及时将 `Weblogic` 升级到最新版本。与此同时，请做好资产自查以及预防工作，以免遭受黑客攻击。
## 0x02 风险等级
360CERT对该漏洞的评定结果如下
评定方式 | 等级  
---|---  
威胁等级 | 严重  
影响面 | 广泛  
360CERT评分 | 9.8  
## 0x03 影响版本
`Oracle:Weblogic`:
  * 10.3.6.0.0
  * 12.1.3.0.0
  * 12.2.1.3.0
  * 12.2.1.4.0
  * 14.1.1.0.0
## 0x04 漏洞详情
目前网上的分析都没有说清楚权限绕过具体是怎么访问到`console.portal`路径并且触发`handle`执行的，在与`@Lucifaer`的共同深入研究下，大概掌握了原理，于是有了此文。
`CVE-2020-14883` 是一个 `Console` 的未授权访问，而 `CVE-2020-14883` 是在利用未授权访问的前提下，在
`Console` 进行代码执行，于是远程攻击者可以构造特殊的 `HTTP` 请求，在未经身份验证的情况下接管 `WebLogic Server
Console` ，并在 `WebLogic Server Console` 执行任意代码。
通过`diff`补丁，`console.jar` 里主要修改有两个类，能够定位到漏洞触发点。
CVE-2020-14883: `com.bea.console.utils.MBeanUtilsInitSingleFileServlet`
CVE-2020-14882: `com.bea.console.handles.HandleFactory`
下面对漏洞进行逐个分析。
### CVE-2020-14882
首先要明白，漏洞的触发是在 `console`
组件，而`console`对应着`webapp`服务，路径：`wlserver/server/lib/consoleapp/webapp`。并且存在`web.xml`，于是查看与`MBeanUtilsInitSingleFileServlet`相关的`web.xml`信息：
        AppManagerServlet
        weblogic.servlet.AsyncInitServlet
          weblogic.servlet.AsyncInitServlet.servlet-class-name
          com.bea.console.utils.MBeanUtilsInitSingleFileServlet
        ...
        AppManagerServlet
        *.portal
#### Request处理
从上面的 `web.xml` 内容中可以得出：
  1. `MBeanUtilsInitSingleFileServlet`是`AppManagerServlet`的`servlet-class-name`初始化的值。
  2. 访问`*.portal`会经过`AppManagerServlet`的分派处理（通过认证后访问`console`的路径是`/console/console.portal`）。 `weblogic`所有的请求都会经过`weblogic.servlet.internal.ServletRequestImpl`的预处理。跟到`doSecuredExecute`方法。
这里会调用`WebAppSecurity#checkAccess`进行权限的校验。
第一次请求的时候`checkAllResources`为`false`，于是调用`getConstraint`方法。
传入参数为请求的`/console`下的资源的路径和请求的方法。这里以请求`/console.portal`为例。
#### 静态资源列表获取
看下前面的逻辑：
  1. 获取一个`mapping`如下
  2. 以当前请求方法作为`key`值匹配`value`，而第一行获取到的`map`的`key`是`""`，所以匹配结果为`null`。
  3. 判断当前请求的`url`是否匹配`mapping`里的路径，如果匹配不到，那么返回默认的`rcForAllMethods`（ **注意`unrestricted`为`false`，`unrestricted`是权限验证的一个关键点**），也就是：
现在的结果就是`rcForAllMethods`为默认值，而`rcForOneMethod`为`null`。所以返回`rcForAllMethods`。
执行到这里可以得出的是，如果请求的路径在`matchMap`列表里，那么`unrestricted`值就为`true`，这些是属于静态资源，没有做资源的限制和身份校验。
接着做`if`判断，`resourceConstraint`不为`null`。
接着进入`else`，调用`SecurityModule#isAuthorized`。
继续调用`ChainedSecurityModule#checkAccess`。
#### 权限校验
然后调用`hasPermission`开始判断是否有权限。
在`hasPermission`方法首先判断`unrestricted`，这里我们通过修改请求`/console/css/console.protal`访问静态资源使值为`true`。
然后 `checkAcess`方法返回 `true`。
#### 重定向登陆界面
如果`checkAcess`方法返回`false`。那么不会进入后续的分派，会结束`doSecuredExecute`方法的执行。一路`return`到执行`ServletRequestImpl#runInternal`的`finally`分支。
这里会调用`send`方法，在该方法会将没有分派的请求重定向到`login`界面。
#### 请求分派
如果`checkAcess`方法返回`true`。进入后续请求的分派，经过几个`filterchain`的分派，最终调用`ServletStubImpl`的`excute`方法。这里会根据`web.xml`的配置来获取对应的具体的`Servlet`。
注意，根据`web.xml`，请求如下路径所对应的`servlet`不一样，因为几个路径都是之前所提到的静态路径，没有身份验证，但是我们需要利用到`AsyncInitServlet`来处理，因为我们diff到的修补点在`MBeanUtilsInitSingleFileServlet`，这个类是通过`AsyncInitServlet`来设置的。
`servlet`对应关系部分如下：
    /framework/skeletons/wlsconsole/js/* -> FileDefault
    /css/* -> AsyncInitServlet
    /images/* -> AsyncInitServlet
    /common/* -> JSPCServlet
    ...
于是，请求`/css/*`会调用`AsyncInitServlet`的`service`方法，