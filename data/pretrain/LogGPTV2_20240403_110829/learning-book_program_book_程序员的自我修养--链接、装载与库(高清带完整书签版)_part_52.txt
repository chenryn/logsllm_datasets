9.3DLL优化
271
使用序号作为导入方法比函数名导入方法稍微快一点点，特别在现在的硬件条件下，这
种性能的提高极为有限，而且DLL的导入函数的查找并不是性能瓶颈，因为在现在的DLL
中，导出函数表中的函数名是经过排序的，查找的时候可以使用二分查找法。最初在16位
的Windows下，DLL的导出函数名不是排序的，所以查找过程会比较慢。所以综合来看，
一般情况下并不推荐使用序号作为导入导出的手段。
9.3.3导入函数绑定
试想一下，每一次当一个程序运行时，所有被依赖的DLL都会被装载，并且一系列的
导入导出符号依赖关系都会被重新解析。在大多数情况下，这些DLL都会以同样的顺序被
装载到同样的内存地址，所以它们的导出符号的地址都是不变的。既然它们的地址都不变，
每次程序运行时都要重新进行符号的查找、解析和重定位，是不是有些浪费呢？如果把这些
导出函数的地址保存到模块的导入表中，不就可以省去每次启动时符号解析的过程吗？这个
思路是合理的，这种DLL性能优化方式被叫做DLL绑定（DLL Binding）.DLL绑定方法很
简单，我们可以使用editbin（之前的MSVC提供一个额外的bind.exe用于DLL绑定）这个
工具对EXE或DLL进行绑定：
editbin/BINDTestHath.exe
Microsoft (R) C0PF/PE Dumper Version 9.00.21022.08
dunpbin /IMPORTs TeatMath.exe
Copyright (C) Microsoft Corporation. All rights reserved.
Dump of file TestMath.exe
File Type: EXECUTABLE IMAGE
Section contains the following import81
Math,d11
40E944 Inport Name Table
40D11C Import Address Table
FFFFFFFF Index of first forwarder reference
FFFFFFFF tine date stamp
10001010
2 Sub
KERNEL32 .d11
40E828 Inport Name Table
40D000 Inport Address Table
FFFFFFFF Index of firet forwarder reference
FFFFFFFF tine date stamp
7C8099B0
143 GetCurrentProcess1d
Header contains the following bound inport information:
Bound to Math.d11 [483A6707] Mon May 26 15:30:15 2008
程序员的自我修养——链接、装载与库
---
## Page 295
272
第9章Windows下的动态链接
Bound to KERNBL32.d11 [4802A12C] Mon Apr 14 08:11:24 2008
Contained forwarders bound to NTDLL.DLL [4802A12C1 Mon Apr 14 08:11:24
2008
DLL的绑定实现也比较简单，cditbin对被绑定的程序的导入符号进行遍历查找，找到
以后就把符号的运行时的目标地址写入到被绑定程序的导入表内，还记得前面介绍PE的导
入表中有个与IAT一样的数组叫做INT，这个数组就是用来保存绑定符号的地址的。
那么什么情况会导致DLL绑定的那些地址失效呢？一种情况是，被依赖的DLL更新导
致DLL的导出函数地址发生变化：另外一种情况是，被依赖的DLL在装载时发生重定基址，
导致DLL的装载地址与被绑定时不一致。那么如果地址失效，而被绑定的EXE或者DLL
还使用失效了的地址的话，必然会导致程序运行错误。Windows必须提供相应的机制来保证
绑定地址失效时，程序还能够正确运行。
对于第一种情况的失效，PE的做法是这样的，当对程序进行绑定时，对于每个导入的
DLL，链接器把 DLL的时间截（Timestamp）和校验和（Checksum.比如 MD5）保存到被
绑定的PE文件的导入表中。在运行时，Windows会核对将要被装载的DLL与绑定时的DLL
版本是否相同，并且确认该DLL没有发生重定基址，如果一切正常，那么Windows就不需
要再进行符号解析过程了，因为被装裁的DLL与绑定时一样，没有发生变化：否则Windows
就忽略绑定的符号地址，按照正常的符号解析过程对DLL的符号进行解析。
绑定过的可执行文件如果在执行时的环境与它在绑定时的环境一样，那么它的装载速度
将会比正常情况下快：如果是在不同的运行环境，那么它的启动速度跟没绑定的情况下没什
么两样。所以总的来说，DLL绑定至少不会有坏处。
事实上，Windows系统所附带的程序都是与它所在的Windows版本的系统DLL绑定的。
除了在编译时可以绑定程序，另外一个绑定程序的很好的机会是在程序安装的时候，这样至
少在DLL升级之前，这些“绑定”都是有效的。当然，绑定过程会改变可执行文件本身，
从面导致了可执行文件的校验和变化，这对于一些经过加密的，或者是经过数字签名的程序
来说可能会有问题。比如我们查看Windows 所附带的Notepad.exe：
dumpbin / IMPORTS C: \WINDOWS\not epad,exe
Header contains the following bound import information:
Bound to cond1g32.d11 [4802A0C9] Mon Apr 14 08:09:45 2008
Bound to mavcrt.d11 [4802A094] Mon Apr 14 08:08:52 2008
Bound to C0MCrL32.d11 [4802A094] on Apr 14 08:08:52 2008
Bound to KERNEL32.d11 [4802A12C] Mon Apr 14 08:11:24 2008
Contained Eorwarders bound to NrDLL.DLL [4802A12C] Mon Apr
Bound to GDI32.d11 [4802A08E] Mon Apr 14 08:09:34_2008
14 08:11:24 2008
Bound to US8R32,d11 [4802A118] Mon Apr 14 08:11:07 2008
程序员的自我修养一链接、装载与库
---
## Page 296
9.4C++与动态链接
273
9.4C++与动态链接
Linux 下的绝大部分共享库都是用C语言编写的，这一方面是由于历史的原因，Linux
下的程序主要都是使用C语言：另一方面是由于使用C++语言编写共享库比使用C语言要
复杂得多。在本书的第2部分，我们已经讨论了C++的ABI以及C和C++之间如何互操作
的问题（用extem"C"）.除了上面这些问题之外，使用C++编写共享库还存在一个更大的
问题是：共享库会更新。共享库可以单独更新是它的一大优势，但如果这是一个C++编写
的共享库，那又是另外一回事了，它有可能是一场事梦，这一切墨梦的根源还是由于C++
的标准只规定了语言层面的规则，而对二进制级别却没有任何规定。
《COM本质论》里面举了一个很生动的例子，假设有个程序员实现了一个复杂度为O（1）
的字符串查找算法，这个算法非常有用，于是该程序员打算把这个算法做成DLL并且卖给
各大计算机软件厂商和软件开发者，每份DLL的价格是100元。程序员是这样定义他的排
序算法头文件：
class declspec (d1lexport) StringFind {
char* p1
//字井串
public:
StringPind(char* p) :
int Find(char* p) :
-StringFind():
//壹找字好事并返回找到的位置
}1
int Length();
//返回字好事长度
FindO成员函数的作用是查找字符串并返回查找结果。当然Find算法的具体实现非常复
杂，运行时占用数十M内存，程序员把实现代码编译成StringFind.DLL，然后对该DLL的
代码进行加密后与头文件一起出售，防止用户通过反向工程对该排序算法进行破解。很快，
程序员也很受鼓舞，决定再接再厉，对算法进行改进：第一个是Lengh0函数之前是调用
strlen(this->p)实现的，时间复杂度为 O(n)，改进后的类里面增加了int length 成员变量用于
保存字符串长度，时间复杂度变成了0（1)）：第二个改进是应一些用户的要求，增加了一个
叫做SubString的函数，用于取得字符串的子串；第三个是对FindO算法实现进行了改进，使
得原先要占有数十M内存降低到只占用数M内存。改进后的头文件源代码如下：
class —_declspec(dllexport) StringFind (
char* p:
public:
int length;
StringPind(char* p) :
int Find(char* p) :
-StringFind() ;
int Length() ;
程序员的自我修养一链接、装载与库
---
## Page 297
274
第9章Windows下的动态链接
char* SubString (int pos, int len) ;
按照程序员最初的设想，类只增加了一个私有成员变量和公有成员函数，并不会对现有
的程序有任何影响，他用一些测试的代妈进行了测试，发现没有任何端译错误和运行错误。
于是他就把新版的StringFind.DLL以200元的价格卖出，而那些原先购买了旧版
StringFind.DLL的用户只需要加100元的差价就可以购买新版的DLL。由于新版的DLL诸多
性能改进和功能增加，各大厂商和用户立即购买了新版的DLL，并且他们得到程序员的保证：
新版的DLL与旧版的DLL完全囊容。掌到该排序算法的DLL后，广商们将它厂泛地用于各
种产品，并且随着他们的产品光盘、互联网下载各种手段发布给最终用户；已经发布出去的
使用旧版StringFind.DLL的程序也都收到了一个补丁升级包，号称只要安装该补丁，原先的
程序就会运行得更快更有效，于是大多数的用户不假思索地就点击了“升级”按钮。
很快厂商们接到用户铺天盖地的抱怨，说他们的程序经常莫名其妙地错误或者运行时间
一长就会占用大量的内存最终导致程序前溃，甚至影响其他程序的运行。于是这些厂商的技
术工程师们连夜对他们的程序进行排查，最终发现这些问题全都来目于StringFind.DLL。主
要发现了下面儿个问题：
·按照接口的设计，SubString 返回指向字符串子串的指针，但 StringFind.DLL并不负责
该返回指针的内存释放工作，用户在用完该指针之后需要调用delete对它进行释放。这
在有些时候是没有问题的，但是如果StringFind.DLL所使用的CRT版本与用户主程序
或者其他DLL所使用的CRT版本不一样，程序就会发生内存释放错误。由于每个CRT
都会有自己独立的堆，在一个CRT中申请内存面在另外一个CRT中释放内存将会导致
释放出错。
·各个厂商对DLL文件升级的做法往往就是简单地用新版的DLL覆盖旧版的DLL，这
也是基于程序员保证新版完全兼容旧版 DLL的基础上。但是当 StringFind类在增加
了一个length成员变量之后，新版的 StringFind对象所占用的空间是8个字节，而原
先只有一个成员变量时只占用4个字节，那么原先程序主模块在对StringFind进行实
例化时，实际上是相当于实例化了旧版的 StringFind。比如i旧版中有 new StringFind()
这样的语句，实际上它的作用相当于申请4个字节的内存，然后调用StringFindO初
始化函数。但是在新版的 StringFind 中，StringFind.DLL 里面的 StringFind 构造函数
和LengthO都认为StringFind对象有8个字节，当任何一个函数访间length变量的时
候实际上这块区域并不属于StringFind对象，很容易出现错误的数据访间，导致程序
莫名其妙地崩溃。
·很多程序在安装时就把StringFindDLL放到系统的DLL目录下\WINDOWSISystem32，
而在升级或者重新安装时采用简单覆盖的方法。于是当一个安装程序将新版的
StringFind.DLL覆盖旧版的DLL时，所有使用旧版DLL的程序都会发生程序运行错误。
程序员的自我修养一链接、装载与库
---
## Page 298
9.4C++与动态链接
275
在发生这一大堆问题之后，程序员受不了厂商的抱只好彻夜工作，并提出了一些改进
的方法，比如增加一个ReleaseString（O的成员类来释放SubStringO所返回的字符串：将新版
墨梦，他都不政再做任何深入的改进了，更别说在DLL中使用C++的其他特性诸如虚函数、
多继承、异常、重载、模板等，谁知道又会发生什么样的情况。
这只是程序员在使用C++编写DLL时遇到的问题中的冰山一角，为了解决类似的兼容
性问题，更大程度上使得程序能够有更好的重用性，微软公司很早就开始了组件对象模型
（COM，Component objectmodel）的开发工作，它的主要目的之一就是为了解决这些在
程序开发中遇到的派容性问题。
推荐图读：《本质论）
《COM本质论》是一本很好的描述COM实现机制的一本书，作者DonBox通过生
动的例子，深入浅出地格COM这个嗨涩的技术制析地非常浅显易懂。本文中的例子
也是来源于这本书中的一个例子并加以改进。
COM的实现机制对于普通开发者来说显得复杂了一些，并且COM的学习曲线也比较
陡，不太容易入门。但是我们可以把COM的一些精神提取出来，用于指导我们使用C++编
写动态链接库。在Windows平台下（有些意对Linux/ELF也有效），要尽量遵循以下几个
指导意见：
·所有的接口函数都应该是抽象的。所有的方法都应该是纯虚的。（或者inline的方法也
可以）。
·所有的全局函数都应该使用extern“C”来防止名字修饰的不兼容，并且导出函数的都
应该是_stdcall调用规范的（COM的DLL都使用这样的规范）。这样即使用户本身的
程序是默认以_cdecl方式编译的，对于DLL的调用也能够正确。
·不要使用C++标准库STL。
·不要使用异常。
·不要使用虚析构函数，可以创建一个destroyO方法并且重载delete操作符并且调用
destroyO。
·不要在DLL里面中请内存，而且在DLL外释放（或者相反），不同的DLL和可执行文
件可能使用不同的堆，在一个维里面中请内存而在另外一个堆里面释放会导致错误。
比如，对于内存分配相关的函数不应该是inline的，以防止它在编译时被展开到不同的
DLL和可执行文件。
·不要在接口中使用重载方法（Overloaded Methods，一个方法多重参数），因为不同的编
译器对于vtable的安排可能不同。
程序员的自我修养一链接、装载与库
---
## Page 299
276
第9章Windows下的动态链接
9.5DLLHELL
DLL跟ELF类似也有版本更新时发生不兼容的问题，我们在前面的关于C++和DLL的
小节中也领教了DLL不兼容问题的严重性。由于Windows中使用DLL比Linux中使用共
享库范围更大，更新也更频繁，并H早期的Windows缺乏一种很有效的DLL版本控制机制，
从面导致这个问题在Windows下非常严重，以至于被人戏称为DLL蛋梦（DLLhell）。
很多Windows的应用程序在发布时会将它们所有需要用到的DLL都一起打包发布，很
多应用程序的安装程序并不是很成熟，经常在安装时将一个旧版的DLL覆盖掉一个更新版
本的DLL，从而导致其他的应用程序运行失败。有些安装程序比较友好，如果碰到需要覆
盖新版的DLL时，它会弹出一个对话框提醒用户是否要覆盖，但是即使这样，有些应用程
序只能运行在旧版的DLL下，如果不覆盖，那么它可能无法在新版的DLL中运行，总得说
来，三种可能的原因导致了DLLHell的发生：
·一是由使用旧版本的DLL替代原来一个新版本的DLL面引起，这个原因最普遍，是
Windows 9x用户通常遇到的问题DLL错误之一。
·二是由新版DLL中的函数无意发生改变而引起。尽管在设计DLL时候应该“向下”兼
容，然面要保证DLL完全“向下”兼容却是不可能的，
·三是由新版DLL的安装引入一个新BUG。这个原因发生的概率最小，但是它仍然会
发生。
解决DLLHell的方法
DLL的作用己经在前面介绍过，下面我们介绍几种预防DLLHell的方法。
·静态链接（Static linking）
对付DLLHell的最简单方法，或者说终极方法就是，在编译产生应用程序时使用静态
链接的方法链接它所需要的运行库，从面避免使用动逐链接。这样，在运行应用程序时候就
不需要依赖DLL了。然而，它会丧失使用动态链接带来的好处。
·防止DLL覆盖（DLLStomping）
在Windows 中，DLL的覆盖问题可以使用Windows 文件保护（Windows File Protection
简称WFP）技术来缓解。该技术从Windows2000版本开始被使用。它能阻止未经授权的应
用程序覆盖系统的DLL。第三方应用程序不能覆盖操作系统DLL文件，除非它们的安装程
序拥绑了Windows更新包，或者在它们的安装程序运行时禁止了WFP服务（当然这是一
件非常危险的事情）。
程序员的自我修养一链接、装载与库
---
## Page 300
9.5 DLL HELL
277
·避免DLL冲突（Conflicting DLLs）
解决不间应用程序依赖相同DLL不同版本的问题一个方案就是，让每个应用程序拥有
一份自己依赖的DLL，并且把问题DLL的不同版本放到该应用程序的文件夹中，而不是系