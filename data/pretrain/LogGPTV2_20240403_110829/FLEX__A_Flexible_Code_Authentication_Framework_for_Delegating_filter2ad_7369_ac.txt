A constructor new C(¯e) follows rule (EE-New). This rule
requires the evaluation of the n expressions of ¯e (as for
method invocations). Then, it creates a new environment
Eo by initializing the ﬁelds of C mapping parameter names
to the values computed up to this point, and assigns a fresh
pointer o to the reserved name this. Finally, it adds a
new record (C, Eo) to the heap and evaluates the body s
of the constructor under Eo, until termination (because no
return value is allowed for constructors). The resulting con-
ﬁguration consists of the original environment E, the heap
modiﬁed by the execution of s and the pointer o. The cast
expression (C)e is deﬁned through rule (EE-New). The be-
havior on (C)e is similar to that on e, except for the side
condition requiring e to return a pointer associated to a sub-
type of C.
Rules for statements are shown in the second part of Ap-
pendix B. A skip; command does not change E and H and
reduces to the terminal symbol •. The return e; statement
results in the evaluation of e and a ﬁnal conﬁguration where
the resulting value v is returned. Conditional statements re-
quire the evaluation of the expressions in their guards. If the
comparison between the returned values succeeds (SE-Iftt),
the conditional behaves like the ﬁrst statement s1. Oth-
erwise (rule (SE-Ifﬀ)) s2 is executed. Provided that x is
deﬁned in the current environment E, an assignment (SE-
Asgn) creates a binding between x and the value obtained
by evaluating e. Also, the assignment succeeds only if the
declared type (function DT ype) of x, i.e., the type appear-
ing in the declaration of the variable, is compatible with the
actual type (function V T ype) of the value v. Details on the
types and the subtyping relation are provided in Section 5.3
as well as in Appendix A. Field assignments (rule (SE-Fld))
behave similarly, with the exception that expression e must
evaluate to a pointer which refers to a record of C declaring
a ﬁeld f. If this is the case, the record is updated with the
new values v for f. A block (rule (SE-Blk)) behaves like its
body s, with the additional side eﬀect that a new deﬁnition
for x is added to E when entering the block, and then re-
moved when leaving it.4 Sequences consist of the execution
of s1, possibly followed by s2. If s1 reduces to • (rule (SE-
Seqc)), then s2 is executed. Otherwise (rule (SE-Seqr))
the value generated by s1 is returned.
Example 2. Consider the class Message from Example 1.
We show the execution of statement s (cid:44) Message x in {
x = new Message(null); } starting from the conﬁguration
(∅,∅, s).
([x \ null], ∅, null) → ([x \ null], ∅, null)
A
([x \ null], ∅, new Message(null)) → ([x \ null], H(cid:48)
([x \ null], ∅, x = new Message(null);) → ([x \ o], H(cid:48)
o, o)
o, •)
(∅, ∅, s) → (∅, H(cid:48)
o, •)
4Operator |x must remove all the entries for x created inside
the body of the block from E.
where A stands for the execution of the body of the con-
structor of Message, that is:
([u \ null] ◦ Eo, Ho, this) → ([u \ null] ◦ Eo, Ho, o)
([u \ null] ◦ Eo, Ho, u) → ([u \ null] ◦ Eo, Ho, null)
([u \ null] ◦ Eo, Ho, this.v = u;) →
([u \ null] ◦ Eo, [o \ (Message, [v \ null] ◦ Eo)] ◦ Ho, •)
To simplify presentation, we use abbreviations Eo (cid:44) [this \
o, v\null], Ho (cid:44) [o\(Message, Eo)] and H(cid:48)
o (cid:44) [o\(Message, [v\
null] ◦ Eo)] ◦ Ho.
Following the rules of the operational semantics, a con-
ﬁguration can get stuck, i.e., it is not a ﬁnal conﬁguration,
and it admits no further reductions according to the next
deﬁnition:
Definition 4. A conﬁguration (E, H, F ) is said to be stuck
if F is not a value and (cid:54)∃ E(cid:48), H(cid:48), F (cid:48) such that (E, H, F ) →
(E(cid:48), H(cid:48), F (cid:48)). We denote a stuck conﬁguration as (E, H, F ) (cid:54)→.
5.3 AMJ Type System
In this section we present the type system of AMJ. We
begin by deﬁning the basic elements:
Definition 5. Types are deﬁned as follows.
Expression types: τ, τ(cid:48) ::= C | (cid:62)
Statement types: σ, σ(cid:48) ::= τ | void
Method types: µ, µ(cid:48) ::= τ1 × . . . × τn → τ
The type of an expression can be either C or the value
(cid:62). Apart for the expression types, statements can also be
typed to void. Methods admit arrow type from input types
τ1, . . . , τn to output type τ .
Typing judgements have the form ∆; Γ (cid:96) t : ω where
t ∈ {e, s} and ω ∈ {τ, σ}. We use Γ and ∆ to denote type
environments for variables and classes, respectively. A vari-
able environment can be either the empty environment (∅) or
the environment obtained by adding a mapping to an exist-
ing one (e.g., Γ, x : τ ). Instead, ∆ consists of an immutable
mapping between method and ﬁeld names (unambiguously
identiﬁed through their class name) and their declared type
(we use functional types · → · for methods). For instance,
∆(C)(m) = C × D → D denotes that class C declares a
method m which has two arguments of type C and D and
returns an object of type D.5
Typing rules for expressions and statements are presented
in Appendix C. Expressions are typed as follows. The type
of the null constant is the top element (cid:62) (TE-Null), while
the type of a variable x is provided by the current type
environment Γ (TE-Var). The weakening rule (TE-Wkn)
allows for typing an expression to τ(cid:48) if it can be typed to
τ , being a τ a subtype of τ(cid:48). Types of ﬁelds (TE-Fld)
and methods (TE-Mth) are given by the deﬁnition of C,
contained in ∆, as far as the base expression has type C
(and the actual parameters of a method have compatible
types). A constructor of C (TE-New) behaves similarly to
a method invocation, except for the return type which is
C itself. The cast operation (TE-Cst) types an expression
5For the sake of presentation, here we omit details on
method typing. In general, we assume that the type that ∆
associates to a method is always correct w.r.t. the method
body. For more details, we refer the reader to [4].
Table 2: Rewriting rules syntax
Table 3: Annotation typing rules.
ER ::= erew SX ; EX | erew EX
EX ::= e | EX + EX
SR ::= srew SX
SX ::= s | SX + SX
to C if it can be typed to the subclass C(cid:48). Finally, (TE-
Erew) states that if an annotated expression is typed to τ ,
then it can be typed to both its base expression and to the
annotation (annotation typing is discussed in Section 5.4).
With respect to statements, a skip; command (TS-Skip)
has type void, while a return statement (TS-Ret) has the
same type of the returned expression. A conditional state-
ment (TS-If) is typed to σ if both its branches are typed
to σ. Assignments to a ﬁeld (TS-Fld) or variable (TS-
Asgn) are typed to void as far as the assigned expression
has a type which is compatible with that of the identiﬁer,
i.e., f and x, respectively. The type of the identiﬁers is pro-
vided by the environment functions ∆ and Γ, respectively.
A block (TS-Blk) has the same type as the statement it
contains (typed under an environment which deﬁnes vari-
able x). The weakening rule (TS-Wkn) behaves similarly
to the rule for expressions, i.e., it allows to type a statement
to a more general type σ(cid:48). The rules for sequences behave as
follows. Rule (TS-Seq1) says that a sequence is typed to σ
(with σ (cid:54)= void) if so can be typed the two sub-statements.
Also, rule (TS-Seq2) states that a sequence is typed as its
second statement if the ﬁrst one is typed to void. Finally,
rule (TS-Srew) says that we can type an annotated state-
ment to σ whenever its annotation and base expression can
be typed so.
Example 3. Consider once again the class Message from
Example 1. We type the statement s of Example 2 as follows.
(TE-New)
(TS-Asgn)
(TS-Blk)
∆; x : Message (cid:96) null : (cid:62)
∆; x : Message (cid:96) new Message(null) : Message
∆; x : Message (cid:96) x = new Message(null); : void
∆; ∅ (cid:96) s : void
When applying rule (TE-New), the typing procedure also ver-
iﬁes that ∆(Message)(new) = Object → Message.
An important property of typed terms is that they do
not lead to stuck conﬁgurations. In fact, for all closed (i.e.,
containing no free variables) terms t ∈ {e, s}, if t is typed to
ω, then t does not get stuck, and the value obtained when
running t is of type ω (or a subtype of ω). In other words,
typed terms do not cause faulty computations, and always
return values of the expected type. These properties are
formalized in Appendix A under Theorem 1.
5.4 Code Annotations
In this section we extend the type system of AMJ with
rules for code annotations. The syntax of the annotations
for deﬁning rewriting rules is presented in Table 2.
Expression rewriting annotations ER can be either a state-
ment rewriting term SX followed by an expression rewriting
term EX, or simply an expression rewriting term EX. Expres-
sion rewriting terms EX can either be an expression e, or the
union/choice of two sub terms EX + EX. Statement rewrit-
ing annotations only consist of a statement rewriting term
(TER-Erew1)
∆; Γ (cid:96) EX : τ
∆; Γ (cid:96) SX : void
(TER-Erew2)
(TER-Exp)
∆; Γ (cid:46) erew SX; EX : τ
∆; Γ (cid:96) EX : τ
∆; Γ (cid:46) erew EX : τ
∆; Γ (cid:96) e : τ
∆; Γ (cid:46) e : τ
(TER-Sum)
∆; Γ (cid:96) EX1 : τ
∆; Γ (cid:96) EX2 : τ
(TSR-Srew)
(TSR-Stm)
∆; Γ (cid:46) EX1 + EX2 : τ
∆; Γ (cid:96) SX : σ
∆; Γ (cid:46) srew SX : σ
∆; Γ (cid:96) s : σ
∆; Γ (cid:46) s : σ
(TSR-Sum)
∆; Γ (cid:96) SX1 : σ
∆; Γ (cid:96) SX2 : σ
∆; Γ (cid:46) SX1 + SX2 : σ
SX. These terms can be either a simple statement s, or the
union of two terms SX + SX.
To simplify presentation, we write /*@ srew SX @*/s in-
stead of /*@ srew SX + s @*/s, and we use /*@ sins SX @*/
as an abbreviation for /*@ srew SX + skip;@*/skip;.
Example 4. We annotate class URemote from Section 2
as shown in Figure 3a. (To simplify exposition, we omitted
ﬁeld KeyPair kp in Section 2.) The annotated construc-
tor can be modiﬁed to assign new RSAPair() (which repre-
sents an RSA key pair), new DHPair() (a Diﬃe-Hellman
key pair), or new EmptyPair() (a placeholder that repre-
sents no key) to kp. The default behavior of method on is
to initialize m with a device-speciﬁc payload. The annotation
associated with this statement allows the meta-market to re-
place the payload with a message containing the user’s PIN,
obtained calling method askPIN() (not shown). Before re-
ceiving the conﬁrmation message r, the code can be extended
with a block of instructions. In the challenge-response pro-
tocol (Figure 1b) the universal remote signs a nonce received
from the device. The corresponding code is made legal by a
set of annotations that allow receiving the nonce, signing it,
and handling possible errors.
Extending the Type System. We complete the type
system presented in Appendix C with the annotation typing
rules reported in Table 3, which assign a type to each anno-
tation. Rules (TER-Erew1) and (TER-Erew2) state that
an expression rewriting annotation is typed to τ if it can be
typed to its base term EX. Rule (TER-Erew1) also requires
SX to have type void. Rule (TER-Exp) reduces to typing
expression e, while (TER-Sum) assigns type τ to SX1+SX2
if the two sub expression scan be typed τ . The rules for
statements behave similarly.
6. CODE VERIFICATION
In this section we show how a meta-market can verify the
authenticity and validity of the code from the developer, and
how the user veriﬁes the same properties on the code and
modiﬁcations received from the meta-market.
We use digital signatures to guarantee the authenticity
of the data exchanged by the parties. Our instantiation
of the auxiliary information γD corresponds to a signature
on all ﬁles that compose the application and the contract.
Similarly, γM is a signature computed over γD and over all
ﬁles that constitute the modiﬁcation implemented by the
meta-market.
A FLEX contract is a ﬁle containing all annotations from
the app’s source code. Each annotation is augmented with
an absolute reference to the speciﬁc piece of code it applies
to. mods consist of one or more AMJ source ﬁles, created by
the meta-market according to the contract. Each ﬁle extends
and overrides portions of the app’s code via late binding.
Given a tuple D, the meta-market invokes checkmm(D,
pkdev) to determine the validity of the contract. This func-
tion veriﬁes that the signature on the app and the contract
is correct. Then, it runs AMJ’s type checking to deter-
mine if the contract can be honored, as detailed in sec-
tions 5.3 and 5.4.
If the type system returns no errors
and all signatures verify correctly, tuple D is accepted and
checkmm(D, pkdev) returns 1. Otherwise, it returns 0.
A tuple M is checked by the user by invoking checkuser(M,
pkdev, pkmm). First, this function extracts γD from γM
and uses it to compute checkmm(D, pkdev) where D is con-
structed from M as D = (app, contract, γD).
If checkmm
returns 1, then the user learns that the app has not been
tampered with since it was issued by the developer. Next,
checkuser veriﬁes the signature on γD and mods. A pos-
itive veriﬁcation indicates that the modiﬁcation from the
meta-market have not been altered by an external adver-
sary. Finally, checkuser veriﬁes mods against contract as dis-
cussed next. If the veriﬁcation is successful, it compiles mods
against app. The resulting binary incorporates all modiﬁca-
tions from the meta-market, applied to the authentic app
from the developer.
The correctness of code modiﬁcations is veriﬁed as fol-
lows. Each annotation ER (or SR) corresponds to a recursion-
free ﬁnite language LER (LSR, respectively). Given an an-
notation ER = erew EX, LER = LEX where Le = {e}, and
LEX1+EX2 = LEX1 ∪ LEX2 . Similarly, if ER = erew SX; EX,
LER = LSX · LEX (being · the sequence operator). Thus, ver-
ifying the compliance of the modiﬁcations and the contract
amounts to checking whether a term, i.e., either an expres-
sion e or a statement s, belongs to the annotation language.
In other words, we say that /*@ ER @*/ e (/*@ SR @*/ s,
respectively) is legal if and only if e ∈ LER (s ∈ LSR). An
app is legal if every annotation appearing in it is legal.
Example 5. Fragments in ﬁgures 3b and 3c implement
the protocols illustrated in ﬁgures 1b and 1c respectively. The
two ﬁgures do not show annotations, presented in Figure 3a,
and highlight code changes with “ (cid:73)”. The annotation in the
constructor in Figure 3a deﬁnes the following language:
L =
 kp = new RSAPair();,
kp = new DHPair();,
kp = new EmptyPair();
Both the constructors in ﬁgures 3b and 3c are valid, because
they are obtained by replacing a statement in L with another
statement in L. A similar argument applies to method on.
To summarize, each annotation deﬁnes a ﬁnite language
that the meta-market uses to perform modiﬁcations to the
app. Given a contract (i.e., a list of annotations), the user
can verify the membership of each modiﬁcation to the lan-
guage deﬁned by the corresponding annotation. Violating
the contract is equivalent to producing one or more modiﬁ-
cations that are not in the language deﬁned by annotations.
Thus, the adversary cannot covertly provide illegal app mod-
iﬁcations to the user without either violating, or altering the