var sum =0;
var alt = false;
for (var i= digits.length -1;i >= 0;i--）{
if (alt){
digits[i] *=2;
if (digits[i]> 9){
digits[i] -= 9;
}
Sum += digits[i];
alt = !alt;
// Card number turns out tobe invalid anyway
if（sum&10==0){
}else{
document.getElementById("notice").innerHTML+=';Luhn check failed';
这个函数会接受包含信用卡号码的一个字符串作为参数。卡号应当只包含数字。在我
们的例子中，validatecardnumberO已经去掉了空格和连字符，并且确定卡号中包含了正
确的数字个数。
首先，这个函数使用正则表达式d来遍历字符中的所有数字。注意这里使用了g修饰
符。在循环中，match[o]会获取匹配的数字。由于正则表达式只能处理文本（字符串），
264第4章
www.TopSage.com
---
## Page 281
所以我们调用了parseInt(来确保变量中存储的是一个整数，而不是一个字符串。如果
我们不这样做，那么sum变量就可能会得到所有数字的字符串连接，而不是数字的整
数加法的结果。
实际的算法是在数组之上计算一个校验和。如果结果除以10余数为0，那么卡号是合
法的。否则，号码就是不合法的。
4.20欧盟增值税代码
问题描述
你接到-个任务，需要为欧盟的一家企业实现一个在线订购表单。
欧盟税收法规定，当一个欧盟国家的VAT注册企业（你的客户）从另一个欧盟国家的
卖方（你的公司）购买产品的时候，卖方不得征收VAT（增值税）。如果买家不是VAT
注册的，那么卖方就必须征收VAT，并把VAT上交给当地税务机关。卖方必须提供买
方的VAT注册代码给税务机关，以证明它并没有拖欠任何VAT。这意味着对于卖方来
说，在处理免税销售之前，就有必要对买方的VAT代码进行验证。
VAT代码最常见的错误原因可能是由于客户不小心敲错了。要使订购过程更加迅速和
友好，你就应当在客户填完在线订购表单之后，立即使用一个正则表达式来对VAT代
码进行检查。你可以使用客户端的JavaScript，或者在网站服务器之上的CGI脚本中来
做这样的检查。如果号码并不能匹配正则表达式，那么客户就可以立即对它进行修改。
解决方案
去掉空白和连字符
获取客户输入的VAT代码，并把它保存到一个变量中。在检查它是否是合法代码之前，
先执行一个查找和替换操作，把下面的正则表达式全局替换为空的替代文本：
[-.·]
正则选项：无
正则流派：.NET、Java、JavaScript、PCRE、Perl、Python、Ruby
实例3.14中讲解了如何使用这个正则式执行替换。我们假设客户并不会输人除了连字
符、点号和空格之外的其他标点。如果存在其他错误输人的字符，那么会在随后的检
查中发现。
检查代码
在从输入中去掉空格和连字符之后，下面这个正则表达式会检查这个VAT代码是否属
于任意的27个欧盟国家之一所使用的合法代码：
合法性验证和格式化265
www.TopSage.com
---
## Page 282
(8][6-0]()
#Austria
(BE)?0?[0-9]{9)1
#Belgium
(BG)?[0-9]{9,10} 1
#Bulgaria
(CY)？[0-9]{8}L1
Cyprus
(C2)?[0-9]{8,10}1
Czech Republic
1(6}[6-0]（)
Germany
(DK)？[0-9]{8}1
Denmark
(EE)？[0-9]{9}1
Estonia
(EL|GR)?[0-9]{9}1
#Greece
1[2-6-0]{[6-0][2-6-0]()
#Spain
(FI)?[0-9]{8}1
Finland
(FR)?[0-9A-Z]{2}[0-9]{9}1
France
u#1()6-0]()2]1()[6-0])(6}[6-0])()
(HU)?[0-9]{8}1
Hungary
1{}[6-0]S[6-0]()
#Ireland
Italy
(LT)？([0-9]{9}1[0-9]{12})1
# Lithuania
1{8}[6-0](T)
#Luxembourg
(LV)?[0-9]{11}1
Latvia
1(8[6-0]（)
#Malta
1(}[60]6[60]()
#Netherlands
(PL)?[0-9]{10}1
Poland
(PT)?[0-9]{9}1
#Portugal
(RO)?[0-9]{2,10}1
#Romania
(SE)?[0-9]{12}1
#Sweden
(SI)?[0-9]{8} 1
# Slovenia
(SK) ?[0-9]{10}
# Slovakia
)$
正则选项：宽松排列、不区分大小写
正则流派：.NET、Java、PCRE、Perl、Python、Ruby
这个正则表达式使用了宽松排列模式，这样可以很容易在之后对正则表达式进行修改。
新的国家还会不时地加人到欧盟中来，而且欧盟成员国也会修改VAT代码的规则。不
幸的是，JavaScript不支持宽松排列。在这种情况下，你就不得不把所有内容都放到一
行中：
((AT)?U[0-9]{8}1(BE)?0？[0-9]{9}1(BG)?[0-9]{9,10}1(CY)?[0-9]{8}L|
(CZ)？[0-9]{8,10}1(DE)?[0-9]{9}1(DK)?[0-9]{8}1(EE)?[0-9]{9}1
60]()[2-6-0])6-0]2-6-0]()166-0]()
(ER)?[0-9A-Z]{2}[09]{9}1(GB)?([0-9]{9}([0-9]{3})?1[A-Z]{2}[0-9]{3})1
(HU)?[09]{8}1(IE)?[0-9]S[0-9]{5}L1(IT)?[0-9]{11}1
(LT)?([0-9]{9}1[0-9]{12})1(LU)?[0-9]{8}1(LV)?[0-9]{11}1(MT)?[0-9]{8}1
(NL)?[0-9]{9}B[0-9]{2}1(PL)?[0-9]{10}1(PT)？[0-9]{9}1(RO)?[0-9]{2,10}1
（06-0]()16-0]（1)1(6-0]（）
正则选项：不区分大小写
正则流派：.NET、Java、JavaScript、PCRE、Perl、Python、Ruby
按照实例3.6中所给的代码示例，可以把这个正则表达式添加到你的订购表单中。
266
第4章
www.TopSage.com
---
## Page 283
讨论
去掉空格和连字符
为了使VAT代码更加易读，人们通常会在其中添加一些额外的标点符号把数字分成不
同的组。例如，一个德国客户可能会把它的VAT号码DE123456789写成DE123.456.789。
使用单个正则表达式匹配来自27个国家的VAT代码的任何可能格式是一个不可能完成
的任务。因为标点符号只是为了可读的自的，所以我们可以先去掉所有标点符号，然
后再验证得到的VAT代码，这样会更加容易。
正则表达式·.-]会匹配一个空格、点号或连字符。把这个正则表达式的所有匹配都
替换为空，就会实际上删除VAT代码中所有常用的标点符号。
VAT代码中只可以包含字母和数字。除了使用·.-]去掉常用标点之外，你也可以使
用简写字符类^A-Z0-9]来去掉所有的非法字符。
检查代码
用来检查代码的两个正则表达式是完全相同的。唯一的区别是第一个使用了宽松排列
的语法，这样可以使正则表达式更加易读，并且可以在其中添加国家说明。JavaScript
中不支持宽松排列模式，但是其他流派则会提供这样的选择。
前面给的正则式使用分组结构来匹配所有27个欧盟国家的VAT代码。它们的基本格
式如下所示：
奥地利
U99999999
比利时
999999999或0999999999
保加利亚
999999999或9999999999
塞浦路斯
166666666
捷克共和国
99999999、999999999或9999999999
德国
AH
999999999
合法性验证和格式化
267
www.TopSage.com
---
## Page 284
丹麦
99999999
爱沙尼亚
999999999
希腊
666666666
西班牙
X9999999X
芬兰
66666666
法国
XX999999999
英国
999999999、999999999999或XX999
匈牙利
66666666
爱尔兰
166666S6
意大利
99999999999
立陶宛
999999999或99999999999
卢森堡
99999999
拉脱维亚
99999999999
马耳他
99999999
268
第4章
www.TopSage.com
---
## Page 285
荷兰
999999999B99
波兰
999999999
葡萄牙
999999999
罗马尼亚
99、999、9999、99999、999999、9999999、99999999、999999999或9999999999
瑞典
99999999999
斯洛文尼亚
99999999
斯洛伐克
999999999
严格来讲，两个字母的国家代码也是属于VAT代码的一部分。然而，人们通常会把它
略去，因为通过账单地址通常已经可以分辨出是哪个国家。这个正则表达式可以接受