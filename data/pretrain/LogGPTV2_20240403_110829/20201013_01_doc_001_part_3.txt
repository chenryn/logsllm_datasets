Bitmap Index Scan(parallel,6): 3807.380 ms
• Mongo:
3808
ms
Jsonpath intra joins (joining parts of the same column)
Jsonpath version is the fastest, since it has its own executor, no overheads.
BUT it is primitive (uses only nested loop) and it wins only by chance.
• Counterexample:
create table jb_test as (select jsonb_build_object('id', i/1000, 'a',
jsonb_agg((random()*1000000)::int), 'b',
jsonb_agg((random()*1000000)::int)) jb from generate_series(0,999999) i
group by i/1000);
select jb->'id' from jb_test where jsonb_path_match(jb, '$.a[*] == $.b[*]'); – 13 sec
select jb->'id' from jb_test j where exists(
select 1 from jsonb_array_elements(j.jb->'a') a,
jsonb_array_elements(j.jb->'b') b
where a.value = b.value); – 178 sec
BUT, we have choice
– hash join — 830 ms !
– merge join – 4250 ms
Why jsonpath at all ?
• It is standard query language for json
• It is flexible and concise, arrow operators are too primitive
• Can be very useful for COPY and indexing json
• It is faster for complex processing
Roadmap (see Addendums)
• PG13: SQL/JSON functions from SQL-2016 standard
• PG13: datetime support in JSON Path (complete T832) – committed
• PG13: Planner support functions
• PG13: Parameters for opclasses - jsonpath to specify parts of jsonb to index
• PG13: Jsquery GIN opclasses to core
• PG13: Extend jsonpath syntax
• array,object,sequence construction
• object subscripting, lambda expressions
• user-defined item methods and functions
• COPY with support of jsonpath
• Make one JSON data type !
NoSQL Postgres
rulezz !
Good Roadmap !
Who need Mongo ?
Summary
•
PostgreSQL is already good NoSQL database
•
Great roadmap
•
SQL/JSON provides better flexibility and interoperability
•
JSON Path implementation (PG12) is the best !
•
Jsonpath is useful (standard, flexible, concise,
sometimes fast)
Move from NoSQL to Postgres !
References
1)This talk: http://www.sai.msu.su/~megera/postgres/talks/jsonpath-pgconfeu-2019.pdf
2)Technical Report (SQL/JSON) - available for free
http://standards.iso.org/i/PubliclyAvailableStandards/c067367_ISO_IEC_TR_19075-6_2017.zip
3)Gentle introduction to JSON Path in PostgreSQL
https://github.com/obartunov/sqljsondoc/blob/master/jsonpath.md
4)Jsquery extension: https://github.com/postgrespro/jsquery/tree/sqljson
http://www.sai.msu.su/~megera/postgres/talks/pgconfeu-2014-jsquery.pdf
5)Play online with jsonpath
http://sqlfiddle.postgrespro.ru/#!21/0/2379
6)Parameters for opclasses
http://www.sai.msu.su/~megera/postgres/talks/opclass_pgconf.ru-2018.pdf
7)IMDB tables: http://www.sai.msu.su/~megera/postgres/files/imdb/imdb/
NOSQL POSTGRES IS A COMMUNITY PROJECT
ADDENDUM I
SQL/JSON FUNCTIONS
SQL/JSON FUNCTIONS
• The SQL/JSON construction functions ( json[b]_xxx() functions):
• JSON_OBJECT - construct a JSON[b] object.
• json[b]_build_object()
• JSON_ARRAY - construct a JSON[b] array.
• json[b]_build_array()
• JSON_ARRAYAGG - aggregates values as JSON[b] array.
• json[b]_agg()
• JSON_OBJECTAGG - aggregates name/value pairs as JSON[b] object.
• json[b]_object_agg()
SQL/JSON in PostgreSQL
• The SQL/JSON retrieval functions:
• JSON_VALUE - Extract an SQL value of a predefined type from a JSON value.
• JSON_QUERY - Extract a JSON text from a JSON text using an SQL/JSON path
expression.
• JSON_TABLE - Query a JSON text and present it as a relational table.
• IS [NOT] JSON - test whether a string value is a JSON text.
• JSON_EXISTS - test whether a JSON path expression returns any SQL/JSON items
JSON_TABLE — relational view of json
• Table with rooms from json
SELECT apt.*
FROM
house,
JSON_TABLE(js, '$.floor[0, 1]' COLUMNS (
level int,
NESTED PATH '$.apt[1 to last]' COLUMNS (
no int,
level | no | area | num_rooms
area int,
—-----+----+------+---------—
rooms int
1 | 1 | 40 | 1
)
1 | 2 | 80 | 3
)) apt; 1 | 3 | 50 | 2
2 | 4 | 100 | 3
2 | 5 | 60 | 2
(5 rows)
ADDENDUM II
Parameters for Opclasses
Parameters for opclasses
Operator class is a «glue» or named collection of:
• AM (access method)
• Set of operators
• AM specific support function
Examples:
• CREATE INDEX .. USING btree (textcolumn text_pattern_ops)
• CREATE INDEX .. USING gin (jsoncolumn jsonb_ops)
• CREATE INDEX .. USING gin (jsoncolumn jsonb_path_ops)
Extending Indexing infrastructure
•
Opclasses have «hardcoded» constants (signature size)
• Let user to define these constants for specific data
•
Indexing of non-atomic data (arrays, json[b], tsvector,…)
• Specify what part of column to index — partial index only filters rows
•
Use different algorithms to index
• Specify what to use depending on data
Parameters for opclasses: syntax
• Parenthized parameters added after column's opclass. Default opclass
can be specified with DEFAULT keyword:
CREATE INDEX idx ON tab USING am (
{expr {DEFAULT | opclass} ({name=value} [,…])} [,…]
) …
CREATE INDEX ON small_arrays USING gist (
arr gist__intbig_ops(siglen=32),
arr DEFAULT (num_ranges = 100)
);
CREATE INDEX bookmarks_selective_idx ON bookmarks USING
gin(js jsonb_ops(projection='strict $.tags[*].term'));
ADDENDUM III
Planner support for jsonpath
Planner support function for jsonpath functions
• PG12+: API for planner support functions that lets them create derived
index conditions for their functions.
CREATE [OR REPLACE] FUNCTION
name ([[argmode] [argname] argtype [{DEFAULT|=} default_expr] [,…]])
{
.........
| SUPPORT support_function
.........
} ...
• jsonb_path_match() transforms to jsonb @@ jsonpath (uses
index !)
Planner support function for jsonpath functions
• PG12+: API for planner support functions that lets them create derived
index conditions for their functions.
SELECT * FROM t t1, t t2 WHERE
jsonb_path_match(t1.js, '$.a == $a', vars => t2.js, silent => true);
QUERY PLAN
----------------------------------------------------------------------
Nested Loop
-> Seq Scan on t t2
-> Bitmap Heap Scan n t t1
Filter: jsonb_path_match(js, '($."a" == $"a")'::jsonpath,
t2.js, true)
-> Bitmap Index Scan on t_js_idx
Index Cond: (js @@ jsonpath_embed_vars('($."a" ==
$"a")'::jsonpath, t2.js))
(6 rows)
Planner support function for jsonpath functions
• PG12+: API for planner support functions that lets them create derived
index conditions for their functions.
jsonb_path_match(b1.jb,
'$.title == $title && $.author != $author',
vars => b2.jb)
AND b2.jb ->> 'author' = 'ant.on'
=>
b1.jb @@ jsonpath_embed_vars('$.title == $title &&
$.author != $author', b2.jb)
AND b2.jb @@ '$.author == "ant.on"'::jsonpath
ADDENDUM IV
Jsonpath syntax extensions
Jsonpath syntax extensions
• Array construction syntax:
SELECT jsonb_path_query('[1,2,3]', '[0, $[*], 4]');
[0, 1, 2, 3, 4]
•
Object construction syntax:
SELECT jsonb_path_query('[1,2,3]','{a: $, "s": $.size()}');
{"a": [1, 2, 3], "s": 3}
• Sequence construction syntax:
SELECT jsonb_path_query('[1,2,3]', '0, $[*], 4');
0
1
2
3
4
Jsonpath syntax extensions
• Object subscripting:
SELECT jsonb_path_query('{"a": 1}', '$["a"]');
1
SELECT jsonb_path_query('{"a": 1, "b": "ccc"}', '$["a","b"])';
1
"ccc"
SELECT jsonb_path_query('{"a": 1}', 'lax $["a", "b"]');
1
SELECT jsonb_path_query('{"a": 1}', 'strict $["a", "b"]');
ERROR: JSON object does not contain key "b"
Jsonpath syntax extensions
• Array item methods with lambda expressions (ECMAScript 6 style):
SELECT jsonb_path_query('[1,2,3]', '$.map(x => x + 10)');
[11, 12, 13]
SELECT jsonb_path_query('[1,2,3]', '$.reduce((x,y) => x + y)');
6
SELECT jsonb_path_query('[1,2,3]', '$.fold((x,y) => x + y, 10)');
16
SELECT jsonb_path_query('[1,2,3]', '$.max()');
3
•
Alternative syntax for lambdas:
'$.fold($1 + $2, 10)'
Jsonpath syntax extensions
• Sequence functions with lambda expressions:
SELECT jsonb_path_query('[1,2,3]', 'map($[*], x => x + 10)');
11
12
13 -- sequence is returned, not array
SELECT jsonb_path_query('[1,2,3]', 'reduce($[*], (x,y) => x+y)');
6
SELECT jsonb_path_query('[1,2,3]', 'fold($[*], (x,y)=>x+y, 10)');
16
SELECT jsonb_path_query('[1,2,3]', 'max($[*])');
3
Jsonpath syntax extensions
•
User-defined item methods and functions ( ):
contrib/jsonpathx
CREATE FUNCTION map(jsonpath_fcxt) RETURNS int8
AS 'MODULE_PATHNAME', 'jsonpath_map' LANGUAGE C;
typedef struct JsonPathFuncContext
{
JsonPathExecContext *cxt;
JsonValueList *result;
const char *funcname;
JsonItem *jb; /* @ */
JsonItem *item; /* NULL => func, non-NULL => method */
JsonPathItem *args;
void **argscache;
int nargs;
} JsonPathFuncContext;
ADDENDUM V
Performance of Intra joins
Jsonpath intra joins (joining parts of the same column)
3808 ms
Jsonpath intra joins (joining parts of the same column)
• Query: find all the actors who were editors in the same movie (6378007 rows in names).
• Relational analogue of names table:
CREATE TABLE roles AS
SELECT
id,
r->>'role' AS "role",
r->>'title' AS "title",
r->>'character' AS "character",
r->'ranks' AS "ranks"
FROM
names,
jsonb_array_elements(jb->'roles') roles(r);
CREATE INDEX ON roles(role);
CREATE INDEX ON roles (id, title, role); -- composite btree index
\d+
public | names | table | 3750 MB
public | roles | table | 5830 MB
\di+
public | names_jb_idx | index | names | 1439 MB
public | roles_id_title_role_idx | index | roles | 4710 MB
Jsonpath intra joins (joining parts of the same column)
• Query: find all the actors who were editors in the same movie (6378007 rows in names).
• Relational analogue of names table:
SELECT DISTINCT r1.id
FROM roles r1
WHERE r1.role ='editor' AND EXISTS (
SELECT FROM roles r2 WHERE r2.id = r1.id AND r2.title = r1.title AND r2.role = 'actor'
);
Sequential Scan: 34840.434 ms
Sequential Scan (parallel,6): 4233.829 ms
Bitmap Index Scan: 13745.517 ms
Bitmap Index Scan(parallel,6): 3807.380 ms
ADDENDUM VI
Two floors house
CREATE TABLE house(js) AS SELECT jsonb '
{ "floor": [
"info": { {
"contacts": "Postgres Professional\n+7 (495) "level": 1,
150-06-91\PI:EMAIL", "apt": [
"dates": ["01-02-2015", "04-10-1957 {"no": 1, "area": 40, "rooms": 1},
19:28:34 +00", "12-04-1961 09:07:00 +03"] {"no": 2, "area": 80, "rooms": 3},
}, {"no": 3, "area": null, "rooms": 2}
"address": { ]
"country": "Russia", },
"city": "Moscow", {
"street": "117036, Dmitriya Ulyanova, 7A" "level": 2,
}, "apt": [
"lift": false, {"no": 4, "area": 100, "rooms": 3},
{"no": 5, "area": 60, "rooms": 2}
]
}
]
}
';
|---|--|--|--|--|--|--|
| 0 |  |  |  |  |  |  |
|---|--|--|--|--|--|--|
| 0 |  |  |  |  |  |  |
| 1 | Nikita Glukhov, Oleg Bartunov
Postgres Professional  |  |  |  |  |  |