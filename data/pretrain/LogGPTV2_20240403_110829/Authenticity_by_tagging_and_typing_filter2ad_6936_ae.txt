Lowe’s ﬁxed version of SPLICE/AS
Needham-Schroeder Public Key Protocol
Lowe’s ﬁxed version of Needham-Schroeder Public Key Protocol X
ISO’s Symmetric Key Three Pass Mutual Authentication Protocol X
X
Private Authentication Protocols [1]
X
Correct Flawed
X
X
X
Security Foundations Workshop (CSFW’00), pages 255–268. IEEE
Computer Society Press, July 2000.
[17] G. Lowe. Breaking and ﬁxing the Needham-Schroeder public-key
protocol using FDR. In Tools and Algorithms for the Construction
and Analysis of Systems (TACAS), volume 1055 of Lecture Notes in
Computer Science, pages 147–166. Springer-Verlag, 1996.
[18] G. Lowe. “A Hierarchy of Authentication Speciﬁcation”. In
Proceedings of the 10th Computer Security Foundation Workshop
(CSFW’97), pages 31–44. IEEE Computer Society Press, 1997.
[19] G. Lowe. “Towards a Completeness Result for Model Checking of
Security Protocols”. In Proceedings Eleventh IEEE Computer
Security Foundation Workshop, (CSFW’98). IEEE Computer Society
Press, June 1998.
[20] M.Maffei. Tags for multi-protocol authentication. In Proceedings of
the 2nd International Workshop on Security Issues in Coordination
Models, Languages, and Systems (SECCO ’04). To appear. ENTCS,
August 2004.
[21] R.Focardi and M.Maffei. ρ-spi calculus at work: Authentication case
studies. In Proceedings of Meﬁsto Project. To appear. ENTCS,
March 2004.
[22] J. Thayer, J. Herzog, and J. Guttman. Strand spaces: Proving security
protocols correct. Journal of Computer Security, 1999. 7(2/3).
[23] Thomas Y. C. Woo and Simon S. Lam. A lesson on authentication
protocol design. Operating Systems Review, 28(3):24–37, 1994.
[24] T.Y.C. Woo and S.S. Lam. “A Semantic Model for Authentication
Protocols”. In Proceedings of 1993 IEEE Symposium on Security and
Privacy, pages 178–194, 1993.
∗
APPENDIX
A. SEMANTICS OF ρ-spi
The dynamics of ρ-spi is formalized by means of a transition re-
lation between conﬁgurations, i.e., pairs (cid:8)s, P(cid:9), where s ∈ Act
is a
trace, P is a (closed) process. Each transition (cid:8)s, P(cid:9) −→ (cid:8)s :: α, P
(cid:11)(cid:9)
simulates one computation step in P and records the corresponding
action in the trace. The transitions involving a sequential process
preserve the identity identiﬁers associated with the process, as in
(cid:8)s, I (cid:2)π.S(cid:9) −→ (cid:8)s :: α, I (cid:2) S(cid:9), where α is the action corresponding to
the primitive π. The set of all possible actions, noted Act, includes
the action out(M1, . . . ,Mm) generated by output, run(I, J, M) and
commit(I, J, M) by ‘run’ and ‘commit’, in(M1, . . . ,Mm) by input,
decrypt{M1, . . . ,Mm}K and decrypt{|M1, . . . ,Mm|}Key(K) by sym-
metric and asymmetric decryption, encrypt{M1, . . . ,Mm}K and en-
crypt {M1, . . . ,Mm}Key(K) by symmetric and asymmetric encryp-
f resh(n) by restriction, sym-key(k, I1, I2) and asym-key(k, I)
tion,
by symmetric and asymmetric key assignment.
The transitions, in Table 10, are mostly standard. PAR, REPLI-
Table 9 Most General Uniﬁer
(Most General Uniﬁer)
m.g.u.(C(M1),C(M2)) = m.g.u.(M1, M2)
m.g.u.(n, n) = []
m.g.u.(n, x) = [n/x]
m.g.u.(Key(M), Key(M)) = []
m.g.u.(Key(M), x) = [Key(M)/x]
m.g.u.({M1, . . . ,Mn}
m.g.u.({|M1, . . . ,Mn|}
(cid:11)
(cid:11)
m.g.u.((M1, M2, . . . ,Mn),(M
, M
(cid:11)
1
2
)
where U = m.g.u.(M1, M
1
, . . . ,M
K
, x) = [{M1, . . . ,Mn}
/x]
Key(K), x) = [{|M1, . . . ,Mn|}
n)) = U ◦ m.g.u.(U(M2, . . . ,Mn),U(M
(cid:11)
Key(K)/x]
K
(cid:11)
2
, . . . ,M
(cid:11)
n)),
ing, to interact with the other participants by pretending to be a
trusted principal.
As an example, let us consider the following transitions :
(cid:8)s, A (cid:2) in(y).decrypt y as {|n|}Priv(kA).0(cid:9) →
(cid:8)s :: in({|n|}Pub(kA)), A (cid:2) decrypt {|n|}Pub(kA) as {|n|}Priv(kA).0(cid:9) →
(cid:8)s :: in({|n|}Pub(kA)) :: decrypt{|n|}Pub(kA),0(cid:9)
where asym − key(kA, A) ∈ s. A decrypts the ciphertext by her
own private key Priv(kA). The operation is successful if the ci-
phertext is encrypted with the corresponding public-key. The must
general uniﬁer for input is [{|n|}Pub(kA)/y].
CATION, OUTPUT, RUN and COMMIT are self-explanatory. Rule
INPUT requires messages read from the network to be computable
by the environment: the environment knowledge is deﬁned by the
message manipulation rules (see below). Moreover, input messages
can be tested by pattern-matching, a capability that is also available
upon decryption (cf. SYMMETRIC and ASYMMETRIC DECRYPT).
Notice that, in ASYMMETRIC DECRYPT, a message encrypted with
a public key can be decrypted only by the corresponding private key
and vice-versa. It is worth noting that in ρ-spi calculus signature
and encryption are the inverse function of each other. Both SYM-
METRIC and ASYMMETRIC ENCRYPT behave as expected. Finally,
restrictions of both names and keys are simply formalized as se-
mantic transitions.
Pattern-matching is formalized by the notion of most general
uniﬁer, deﬁned in Table 9. Notably, we prevent variables to be
substituted by tagged terms, since tags are crucial patterns for au-
thentication and we require them to be explicitly indicated. Also
key-pairs cannot be bound to variables as to prevent private keys to
be deduced by the corresponding public key.
We use a number of notation conventions. The restriction oper-
ator new(n).S is a binder for name n, the key declarations let k =
sym-key(I1, I2) and let k = asym-key(I) are binders for k, while the
input and decryption primitives are binders for the variables that
occur in components Mi; ﬁnally, encryption is a binder for vari-
able x.
In all cases the scope of the binders is the continuation
process. The notions of free/bound names and variables arise as
expected. As in companion transition systems, see, e.g. [8], we
identify processes up to renaming of bound variables and names,
i.e., up to α-equivalence. Moreover we assume two inﬁnite sets of
bound names and free names so that bound names are distinct from
free names and not touched by substitutions.
The message manipulation rules, in Table 11, formalize the en-
vironment actions. Rule OUT says that every message sent on the
network is known by the environment. ENV allows the environ-
ment to generate a new bound name, not occurring in the trace.
TAG and UNTAG allow the environment to tag and untag messages.
By KEY PAIR, given a term M, the environment can build the
private and public component of M. By SYMMETRIC ENCRYP-
TION and ASYMMETRIC DECRYPTION, if the environment knows
M0, M1, . . . ,Mn, then it can encrypt M1, . . . ,Mn with M0. SYM-
METRIC DECRYPTION and ASYMMETRIC DECRYPTION formal-
ize the capability of the environment to decrypt ciphertexts, whose
decryption key is known. By PUBLIC KEYS, all the public keys are
known by the environment. Moreover, by ENEMY KEYS, the en-
vironment may be provided with own key pairs and with long-term
keys shared among the other participants. This gives the possibility
to the enemy to start authentication sessions and, generally speak-
Table 10 Transition System for ρ-spi
Transition rules: bn(s) denotes the bound names in s. We omit the symmetric rule of PAR.
ciphertext. M ranges over terms: M ::= m, x,{M1, . . . ,Mn}M0
, key(M),C(M)
PAR(cid:8)s, P(cid:9) → (cid:8)s
(cid:11), P
(cid:11)(cid:9)
(cid:11)|Q(cid:9)
(cid:11), P
(cid:8)s, P|Q(cid:9)→(cid:8)s
REPLICATION
(cid:8)s, I(cid:2)!S(cid:9)→(cid:8)s, I (cid:2) S|I(cid:2)!S(cid:9)
OUTPUT
(cid:8)s, I (cid:2) out(M1, . . . ,Mn).S(cid:9) → (cid:8)s :: out(M1, . . . ,Mn), I (cid:2) S(cid:9)
RUN(cid:8)s, I (cid:2) run(I, J, M).S(cid:9) → (cid:8)s :: run(I, J, M), I (cid:2) S(cid:9)
COMMIT
(cid:8)s, I (cid:2) commit(I, J, M).S(cid:9) → (cid:8)s :: commit(I, J, M), I (cid:2) S(cid:9)
INPUT
∀i ∈ [1, n]
s (cid:15) M
(cid:11)
∃U = m.g.u.((M
1
(cid:11)
(cid:8)s, I (cid:2) in(M1, . . . ,Mn).S(cid:9) → (cid:8)s :: in(M
1
(cid:11)
i
, . . . ,M
, . . . ,M
(cid:11)
n),(M1, . . . ,Mn))
(cid:11)
n), I (cid:2)U(S)(cid:9)
SYMMETRIC DECRYPT
(cid:8)s, I (cid:2) decrypt {M
(cid:11)
1
(cid:11)
1
, . . . ,M
, . . . ,M
(cid:11)
n),(M1, . . . ,Mn))
∃U = m.g.u.((M
(cid:11)
n}K as {M1, . . . ,Mn}K.S(cid:9) → (cid:8)s :: decrypt{M
(cid:11)
∃U = m.g.u.((M
1
(cid:11)
n|}Key(K) as {|M1, . . . ,Mn|}
, . . . ,M
Key(K).S(cid:9) → (cid:8)s :: decrypt{|M
(cid:11)
n),(M1, . . . ,Mn))
ASYMMETRIC DECRYPT
(cid:8)s, I (cid:2) decrypt {|M
(cid:11)
1
, . . . ,M
(cid:11)
1
, . . . ,M
(cid:11)
n}K , I (cid:2)U(S)(cid:9)
(cid:11)
1
, . . . ,M
(cid:11)
n|}Key(K), I (cid:2)U(S)(cid:9)
SYMMETRIC ENCRYPT
(cid:8)s, I (cid:2) encrypt {M1, . . . ,Mn}K as x.S(cid:9) → (cid:8)s :: encrypt{M1, . . . ,Mn}K, I (cid:2) S[{M1, . . . ,Mn}K/x](cid:9)
ASYMMETRIC ENCRYPT
(cid:8)s, I (cid:2) encrypt {|M1, . . . ,Mn|}Key(K) as x.S(cid:9) → (cid:8)s :: encrypt{|M1, . . . ,Mn|}Key(K), I (cid:2) S[{|M1, . . . ,Mn|}Key(K)/x](cid:9)
RES
(cid:8)s, I (cid:2) new(n).S(cid:9)→(cid:8)s :: f resh(n), I (cid:2) S(cid:9)
n /∈ bn(s)
SIMMETRIC KEY
k /∈ bn(s)
(cid:8)s, let k = sym-key(I1, I2).P(cid:9)→(cid:8)s :: sym− key(k, I1, I2), P(cid:9)
ASYMMETRIC KEY
(cid:8)s, let k = asym-key(I).P(cid:9)→(cid:8)s :: asym− key(k, I), P(cid:9)
k /∈ bn(s)
Table 11 Message Manipulation Rules
AX
out(. . . ,M, . . .) ∈ s
s (cid:15) M
ENV
n /∈ bn(s)
s (cid:15) n
TAG
s (cid:15) M
s (cid:15) C(M)
UNTAG
s (cid:15) C(M)
s (cid:15) M
s (cid:15) n
KEY PAIR
s (cid:15) Pub(n), Priv(n)
SYMMETRIC ENCRYPTION
∀i ∈ [0, n]
s (cid:15) Mi
s (cid:15) {M1, . . . ,Mn}
M0
ASYMMETRIC ENCRYPTION
s (cid:15) Mi
∀i ∈ [0, n]
s (cid:15) {|M1, . . . ,Mn|}
M0
s (cid:15) {M1, . . . ,Mn}
SYMMETRIC DECRYPTION
i ∈ [1, n]
s (cid:15) Mi
M0
s (cid:15) M0
ASYMMETRIC DECRYPTION
key(M0)
s (cid:15) {|M1, . . . ,Mn|}
s (cid:15) Mi
i ∈ [1, n]
s (cid:15) key(M0)
PUBLIC KEYS
asym− key(k, I) ∈ s
s (cid:15) Pub(k)
ENEMY KEYS
asym− key(k, E) ∈ s∨ sym− key(k, E, I) ∈ s
s (cid:15) k