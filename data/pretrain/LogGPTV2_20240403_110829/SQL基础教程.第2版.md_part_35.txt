句的SET子句中也可以使用。但
因为几乎没有实际的业务示例，
原则上窗口函数只能在SELECT子句中使用。
所以开始的时候大家只要记得
“只能在SELECT子句中使用”就
可以了。
虽然我们可以把它当作一种规则死记硬背下来，但是为什么窗口函数
只能在SELECT子句中使用呢（也就是不能在WHERE子句或者GROUP
BY子句中使用） ？下面我们就来简单说明一下其中的理由。
其理由就是，在DBMS内部，窗口函数是对WHERE子句或者GROUP
BY子句处理后的“结果”进行的操作。大家仔细想一想就会明白，在得
到用户想要的结果之前，即使进行了排序处理，结果也是错误的。在得到
排序结果之后，如果通过WHERE子句中的条件除去了某些记录，或者使
用GROUP BY子句进行了汇总处理，那好不容易得到的排序结果也无法
使用了。B
注B
反之，之所以在ORDER BY子 正是由于这样的原因，在SELECT子句之外“使用窗口函数是没有
句中能够使用窗口函数，是因为
ORDER BY子句会在SELECT 意义的”，所以在语法上才会有这样的限制。
子句之后执行，并且记录保证不
会减少。
作为窗口函数使用的聚合函数
前面给大家介绍了使用专用窗口函数的示例，下面我们再来看一看把
之前学过的SUM或者AVG等聚合函数作为窗口函数使用的方法。
所有的聚合函数都能用作窗口函数，其语法和专用窗口函数完全相同。
但大家可能对所能得到的结果还没有一个直观的印象，所以我们还是通过
具体的示例来学习。下面我们先来看一个将SUM函数作为窗口函数使用
的例子（代码清单8-4）。
代码清单8-4 将SUM函数作为窗口函数使用
Oracle SQL Server DB2 PostgreSQL
SELECT product_id, product_name, sale_price,
SUM (sale_price) OVER (ORDER BY product_id) AS current_sum
FROM Product;
8-1 窗口函数 265 ●
执行结果
product_id | product_name | sale_price | current_sum
----------+-----------+-------------+------------
0001 | T恤衫 | 1000 | 1000 ←1000
0002 | 打孔器 | 500 | 1500 ←1000+500
0003 | 运动T恤 | 4000 | 5500 ←1000+500+4000
0004 | 菜刀 | 3000 | 8500 ←1000+500+4000+3000
0005 | 高压锅 | 6800 | 15300
0006 | 叉子 | 500 | 15800
0007 | 擦菜板 | 880 | 16680
0008 | 圆珠笔 | 100 | 16780
使用SUM函数时，并不像RANK或者ROW_NUMBER那样括号中
的内容为空，而是和之前我们学过的一样，需要在括号内指定作为汇总
对象的列。本例中我们计算出了销售单价（sale_price）的合计值
（current_sum）。
但是我们得到的并不仅仅是合计值，而是按照ORDER BY子句指定
的product_id的升序进行排列，计算出商品编号“小于自己”的商品
的销售单价的合计值。因此，计算该合计值的逻辑就像金字塔堆积那样，
一行一行逐渐添加计算对象。在按照时间序列的顺序，计算各个时间的销
KEYWORD 售额总额等的时候，通常都会使用这种称为累计的统计方法。
●累计
使用其他聚合函数时的操作逻辑也和本例相同。例如，使用AVG来
代替SELECT语句中的SUM（代码清单8-5）。
代码清单8-5 将AVG函数作为窗口函数使用
Oracle SQL Server DB2 PostgreSQL
SELECT product_id, product_name, sale_price,
AVG (sale_price) OVER (ORDER BY product_id) AS current_avg
FROM Product;
执行结果
product_id | product_name | sale_price | current_avg
----------+-----------+-------------+-----------------------
0001 | T恤衫 | 1000 | 1000.0000000000000000 ←(1000)/1
0002 | 打孔器 | 500 | 750.0000000000000000 ←(1000+500)/2
0003 | 运动T恤 | 4000 | 1833.3333333333333333 ←(1000+500+4000)/3
0004 | 菜刀 | 3000 | 2125.0000000000000000 ←(1000+500+4000+3000)/4
0005 | 高压锅 | 6800 | 3060.0000000000000000 ←(1000+500+4000+3000+6800)/5
0006 | 叉子 | 500 | 2633.3333333333333333
0007 | 擦菜板 | 880 | 2382.8571428571428571
0008 | 圆珠笔 | 100 | 2097.5000000000000000
● 266 第8章 SQL高级处理
从结果中我们可以看到，current_avg的计算方法确实是计算平
均值的方法，但作为统计对象的却只是“排在自己之上”的记录。像这样
以“自身记录（当前记录）”作为基准进行统计，就是将聚合函数当作窗
KEYWORD 口函数使用时的最大特征。
●当前记录
计算移动平均
窗口函数就是将表以窗口为单位进行分割，并在其中进行排序的函数。
其实其中还包含在窗口中指定更加详细的汇总范围的备选功能，该备选功
KEYWORD 能中的汇总范围称为框架。
●框架
其语法如代码清单8-6所示，需要在ORDER BY子句之后使用指定
范围的关键字。
代码清单8-6 指定“最靠近的3行”作为汇总对象
Oracle SQL Server DB2 PostgreSQL
SELECT product_id, product_name, sale_price,
AVG (sale_price) OVER (ORDER BY product_id
ROWS 2 PRECEDING) AS moving_avg
FROM Product;
执行结果（在DB2中执行）
p roduct_id product_name sale_price moving_avg
----------- ------------- ------------- ------------
0001 T恤衫 1000 1000 ←(1000)/1
0002 打孔器 500 750 ←(1000+500)/2
0003 运动T恤 4000 1833 ←(1000+500+4000)/3
0004 菜刀 3000 2500 ←(500+4000+3000)/3
0005 高压锅 6800 4600 ←(4000+3000+6800)/3
0006 叉子 500 3433
0007 擦菜板 880 2726
0008 圆珠笔 100 493
●指定框架（汇总范围）
我们将上述结果与之前的结果进行比较，可以发现商品编号为“0004”
的“菜刀”以下的记录和窗口函数的计算结果并不相同。这是因为我们指
KEYWORD 定了框架，将汇总对象限定为了“最靠近的3行”。
●ROWS关键字
这里我们使用了ROWS（“行”）和PRECEDING（“之前”）两个关键
●PRECEDING关键字
字，将框架指定为“截止到之前~行”，因此“ROWS 2 PRECEDING”
8-1 窗口函数 267 ●
就是将框架指定为“截止到之前2行”，也就是将作为汇总对象的记录限
定为如下的“最靠近的3行”。
● 自身（当前记录）
● 之前1行的记录
● 之前2行的记录
也就是说，由于框架是根据当前记录来确定的，因此和固定的窗口不
同，其范围会随着当前记录的变化而变化。
图8-2 将框架指定为截止到当前记录之前2行（最靠近的3行）
ROWS 2 PRECEDING
product_id product_name sale_price
（商品编号） （商品名称） （销售单价）
0001 T恤衫 1000
0002 打孔器 500
0003 运动T恤 4000 框架
0004 菜刀 3000 当前记录
（自身=当前行）
0005 高压锅 6800
0006 叉子 500
0007 擦菜板 880
0008 圆珠笔 100
如果将条件中的数字变为“ROWS 5 PRECEDING”，就是“截止
到之前5行”（最靠近的6行）的意思。
KEYWORD 这样的统计方法称为移动平均（moving average）。由于这种方法在希
●移动平均
望实时把握“最近状态”时非常方便，因此常常会应用在对股市趋势的实
●FOLLOWING关键字
时跟踪当中。
使用关键字FOLLOWING（“之后”）替换PRECEDING，就可以指
定“截止到之后~行”作为框架了（图8-3）。
● 268 第8章 SQL高级处理
图8-3 将框架指定为截止到当前记录之后2行（最靠近的3行）
ROWS 2 FOLLOWING
product_id product_name sale_price
（商品编号） （商品名称） （销售单价）
0001 T恤衫 1000
0002 打孔器 500
0003 运动T恤 4000
00 04 菜刀 3000 当前记录
（自身=当前行）
0005 高压锅 6800 框架
0006 叉子 500
0007 擦菜板 880
0008 圆珠笔 100
●将当前记录的前后行作为汇总对象
如果希望将当前记录的前后行作为汇总对象时，就可以像代码清单8-7
那样，同时使用PRECEDING（“之前”）和FOLLOWING（“之后”）关
键字来实现。
代码清单8-7 将当前记录的前后行作为汇总对象
Oracle SQL Server DB2 PostgreSQL
SELECT product_id, product_name, sale_price,
AVG (sale_price) OVER (ORDER BY product_id
ROWS BETWEEN 1 PRECEDING AND 
1 FOLLOWING) AS moving_avg
FROM Product;
表示下一行接续本行，只是由于版面所限而换行。
执行结果（在DB2中执行）
p roduct_id product_name sale_price moving_avg
----------- ------------- ----------- -----------
0001 T恤衫 1000 750 ←(1000+500)/2
0002 打孔器 500 1833 ←(1000+500+4000)/3
0003 运动T恤 4000 2500 ←(500+4000+3000)/3
0004 菜刀 3000 4600 ←(4000+3000+6800)/3
0005 高压锅 6800 3433
0006 叉子 500 2726
0007 擦菜板 880 493
0008 圆珠笔 100 490
在上述代码中，我们通过指定框架，将“1 PRECEDING”（之前1行）
和“1 FOLLOWING”（之后1行）的区间作为汇总对象。具体来说，就是
8-1 窗口函数 269 ●
将如下3行作为汇总对象来进行计算（图8-4）。
● 之前1行的记录
● 自身（当前记录）
● 之后1行的记录
如果能够熟练掌握框架功能，就可以称为窗口函数高手了。
图8-4 将框架指定为当前记录及其前后1行
ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING
product_id product_name sale_price
（商品编号） （商品名称） （销售单价）
0001 T恤衫 1000
0002 打孔器 500
0003 运动T恤 4000 框架
当前记录
0004 菜刀 3000
（自身=当前行）
0005 高压锅 6800
0006 叉子 500
0007 擦菜板 880
0008 圆珠笔 100
两个
ORDER BY
最后我们来介绍一下使用窗口函数时与结果形式相关的注意事项，那
就是记录的排列顺序。因为使用窗口函数时必须要在OVER子句中使用
ORDER BY，所以可能有读者乍一看会觉得结果中的记录不会按照该
ORDER BY指定的顺序进行排序。
但其实这只是一种错觉。OVER子句中的ORDER BY只是用来决定
窗口函数按照什么样的顺序进行计算的，对结果的排列顺序并没有影响。
因此也有可能像代码清单8-8那样，得到一个记录的排列顺序比较混乱的
结果。有些DBMS也可以按照窗口函数的ORDER BY子句所指定的顺序
对结果进行排序，但那也仅仅是个例而已。
● 270 第8章 SQL高级处理
代码清单8-8 无法保证如下SELECT语句的结果的排列顺序
Oracle SQL Server DB2 PostgreSQL
SELECT product_name, product_type, sale_price,
RANK () OVER (ORDER BY sale_price) AS ranking
FROM Product;
有可能会得到下面这样的结果
product_name | product_type | sale_price | ranking
-----------+--------------+-------------+--------
菜刀 | 厨房用具 | 3000 | 6
打孔器 | 办公用品 | 500 | 2
运动T恤 | 衣服 | 4000 | 7
T恤衫 | 衣服 | 1000 | 5
高压锅 | 厨房用具 | 6800 | 8
叉子 | 厨房用具 | 500 | 2
擦菜板 | 厨房用具 | 880 | 4
圆珠笔 | 办公用品 | 100 | 1
那么，如何才能让记录切实按照ranking列的升序进行排列呢？
答案非常简单。那就是在SELECT语句的最后，使用ORDER BY
子句进行指定（代码清单8-9）。这样就能保证SELECT语句的结果中记
录的排列顺序了，除此之外也没有其他办法了。
代码清单8-9 在语句末尾使用ORDER BY子句对结果进行排序
Oracle SQL Server DB2 PostgreSQL
SELECT product_name, product_type, sale_price,
RANK () OVER (ORDER BY sale_price) AS ranking
FROM Product
ORDER BY ranking;
也许大家会觉得在一条SELECT语句中使用两次ORDER BY会有
点别扭，但是尽管这两个ORDER BY看上去是相同的，但其实它们的功
能却完全不同。
法则8-5
将聚合函数作为窗口函数使用时，会以当前记录为基准来决定汇总对象的记录。
8-2 GROUPING运算符 271 ●
第8章 SQL高级处理
8-2
运算符
GROUPING
● 只使用GROUP BY子句和聚合函数是无法同时得出小计和合计的。如果想
学习重点
要同时得到，可以使用GROUPING运算符。
● 理解GROUPING运算符中CUBE的关键在于形成“积木搭建出的立方体”的印象。
● 虽然GROUPING运算符是标准SQL的功能，但还是有些DBMS尚未支持这
一功能。
同时得到合计行
我们在3-2节中学习了GROUP BY子句和聚合函数的使用方法，可
能有些读者会想，是否有办法能够通过GROUP BY子句得到表8-1那样
的结果呢？
表8-1 添加合计行