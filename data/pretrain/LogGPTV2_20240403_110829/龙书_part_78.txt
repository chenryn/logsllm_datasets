6
let
...c(1)...
fun b(f) =
end
let
...b(d)...
fun d(z) =...
第7章
在
---
## Page 305
的 guichsort(1,9）。gquicksort 的活动记录中有一个用于存放 d[2]的原值的位置，图中显示为“保
用之前的值。
这个活动记录。当p返回且它的这个活动记录从栈中清除时，我们将 d[n,]恢复到对p 的这次调
个活动记录，那么p 的活动记录就需要保存d[n,]原来的值，同时 d[n,]本身则被设定指向p 的
套深度为n,的过程p被调用，并且它的活动记录不是栈中的对应于某个深度为n,的过程的第-
长的访问链路。
代码根据 d[订和x相对于g的活动记录顶部的偏移量来访问x。因此，该代码不需要经过一段很
我们只需要查看d[订即可。其中，i是q的嵌套深度。我们沿着指针 d[订找到的活动记录，
tion，即嵌套深度为3的最高活动记录。
了指向 exchange 的活动记录的指针，该记录是嵌套深度为 2 的最高活动记录。d[3］指向 parti
例如，在图 7-14d 中，我们看到显示表d的元素 d[1]保存了一个指向 sornt 的活动记录的指针，
活
play)的辅助数组d，它为每个嵌套深度保存了一个指针。我们设法使得在任何时刻，指针 d[订指
段很长的访问链路才能找到需要的数据。一个更高效的实现方法是使用一个称为显示表（dis
7.3.8显示表
请注意，b能够正确地设置这个访问链，尽管不在c的定义的作用域内。
的访问链可以在参数f的值中找到。该访问链指向c的活动记录，因为c就在d的定义的外围。
是调用了 d。如图 7-13b 所示，d的--个活动记录出现在栈中。应该放在这个活动记录中的正确
条规则之-，因此c可以给出这个访问链。
为了正确地维护显示表，我们需要在新的活动记录中保存显示表条目的原来的值。如果嵌
居已知的偏移量就可以在这个活动记录中找到。编译器知道i的值，因此它可以产生代码，
栈中最高的对应于某个嵌套深度为i的过程的活动记录。图 7-14 给出了-个显示表的例子。
使用访问链的方法来访问非局部数据的问题之一是，如果嵌套深度变大，我们就必须沿着-
动记录是最高的(也是唯一的)对应于某个嵌套深度为1的函数的活动记录。同时，d[2]保存
运行时刻环境
使用显示表的优势在于如果过程p正在运行，且它需要访问属于某个过程g的元素α，那
现在让我们看一下函数6所做的工作。我们知道它将在某个点上使用它的参数f，其效果就
图 7-14 给出了操作显示表的若干步骤。在图7-14a 中，深度为1的 sort 调用了深度为2
访问键
访问链
图7-13带有它们自己的访问链的实在参数
a)
f : (l )
访间链
访问链
289
41
---
## Page 306
不需要检查基本情况。我们考虑从对main 的调用开始，直到(对 fibo(1)的)第一次调用即将
并计算第n个 Fibonacci 数。嵌套在 fib1 中的是 fib2，它假设n≥4。请注意，fib1 和 fib2 都
7.3.97.3节的练习
为 exchange 只访问它自己的数据和通过 d[1]访问的 sort 的数据。
相互交叉的情况。也就是说，d[3]指向的位置比d[2]所指位置更低。这是一个正常的情况，
d[2]指针，即指向 guicksort(1,3)的活动记录的指针。请注意，这里出现了多个显示表指针之间
所示。
在这个例子中，d[3]原先没有值，因此这个位置上的指针为空。此时的显示表和栈如图7-14c
置，并使它指向 partition 的活动记录。partition 的记录中有一个存放原来的 d[3］值的位置。但是
去。然后 d[2]被设置为指向 quicksort(1,3)。
2，所以我们必须首先将 d[2］中指向 quichsort(1,9）的指针保存到 guicksort(1,3）的活动记录中
存的 d[2]”，尽管在这个例子中因为之前没有深度为 2 的活动记录，这个指针为空。
然后，partitin 调用 exchange。函数 exchange 的嵌套深度为 2，因此它的活动记录保存了旧的
290
练习7.3.1：图7-15 中给出了…-个按照非标准方式计算 Fibonacci 数的 ML 语言的函数
下一-步调用 partition。这个函数的嵌套深度为3，因此我们将首次使用显示表中的 d[3］位
在图7-14b 中，quicksort(1,9)调用 quickson(1,3）。因为这两次调用的活动记录的深度都为
号
保存的d[3]
保存的 412]
保存的d[2]
P(1,3)
9(1.3)
9(1. 9)
9(1, 9)
a
图7-14维护显示表
1
保存的d121
Fa
保存的4③]
保存的 d[2]
保存的a2]
保存的d[2]
保存的 d[21]
 (1.3)
p(1.3)
q(1. 3)
9(1. 9).
9(1. 3)
9(1. 9)
第7章
口
因
---
## Page 307
存储管理器总是跟踪堆区中的空闲空间。它具有两个基本的功能：
7.4.1存储管理器
由垃圾回收器完成的。在需要进行垃圾回收时，垃圾回收器是存储管理器的一个重要子系统。
因此可以被重新分配以便存放其他数据项的空间的过程。对于 Java 这样的语言，内存的回收是
回收。
过程序中的显式语句，比如 free 或 delete，进行回收)而言，存储管理器还负责实现空间
是应用程序和操作系统之间的--个接口。对于C或C++这样需要手动回收存储块的语言（即通
语言都为程序员提供了rew语句，该语句创建的对象(或指向对象的指针)可以在过程之间进行
创建某种对象或其他数据，它们的存在与否和创建它们的过程的活动无关。例如，C++和Java
为止的数据。虽然局部变量通常在它们所属的过程结束之后就变得不可访问，但很多语言支持
7.4堆管理
传递，因此这些对象在创建它们的过程结束之后仍然可以长期存在。这样的对象被存放在堆区。
用即将返回时的显示表。同时指明那时在栈中的各个活动记录中保存的显示表条目。
返回的时段，请描述出当时的活动记录栈，并给出栈中的各个活动记录的访间链。
堆是存储空间的一部分，它被用来存储那些生命周期不确定，或者将生存到被程序显式删除
在后面的内容中，我们将把需要内存空间的事物称为“对象”，尽管它们并不是“面向对象程序设计”意义上的真
运行时刻环境
我们将在7.5节中讨论垃圾回收（garbage collection），即在堆区中找到那些不再被程序使用
在本节中，我们将讨论存储管理器（memory manager），即分配和回收堆区空间的子系统，它
●分配。当程序为一个变量或对象请求内存时，存储管理器产生一段连续的具有被请求
正对象。
大小的空间块可供分配，它试图从操作系统中获得连续的虚拟内存来增加堆区的存储空
大小的堆空间。如果有可能，它使用堆中的空闲空间来满足分配请求；如果没有被请求
end;
1n
let
fib0(4)
fun fibo(n) =
图7-15计算 Fibonacci 数的嵌套函数
end
in
let
if n >= 2 then fib1(n)
fun fibi(n) =
if n >= 4 then fib2(n)
fun fib2(n) = fibi(n-1) + fibi(n-2)
291
---
## Page 308
中的下一层是物理(主)内存，它由数百兆到儿千兆的动态RAM构成。物理内存由下一层的虚拟
速缓存，这些高速缓存通常使用静态 RAM 制造，其大小从几千字节到几兆字节不等。层次结构
大但较慢的元素则离存储器比较远。
的指令的数量,还取决于执行其中每条指令所花费的时间。不同情况下执行一条指令所花费的时
员不需要考虑内存子系统的细节就能够写出正确的程序。然而，程序的效率不仅取决于被执行
级
数
间
7.4.2一台计算机的存储层次结构
小到--个字节，大到该程序的整个地址空间。
因
储
节
我们需要
数据结构都在该元素的基础上构建。条件b在某些情况下也可能成立，最常见的情况是可以在
（比如 Lisp）而言条件 a 成立。纯的 Lisp 语言只使用--种数据元素———一-个双指针单元，所有
相同大小的存储块，(b)存储空间按照可预见的方式被释放，比如先分配先回收。对于有些语言
及访问时间的干兆容量的存储器件仍然是不可能的，而纳秒级正是高性能处理器的运行速度。
者器件或者大而慢的存储器件，但是无法制造出既大又快的存储器件。现在，制造--个具有纳
看到，这种优化可以利用程序的“局部性”现象，即一般程序的非随机行为。
据密集型程序可以从能够充分利用存储子系统的优化技术中得到很大的好处。我们将在7.4.3
可可能会有明显的不同，因为访问不同的存储区域所花费的时间从几纳秒到几毫秒不等。因此，
运行时刻栈中分配的数据。然而，对于大部分的语言而言，这两个条件一般都不成立。相反地，
内存访问时间上的巨大差异源于硬件技术的根本性局限。我们可以制造出一个小而快的存
因此，存储管理器必须准备以任何顺序来处理任何大小的空间分配和回收请求。这些请求
292
一个处理器通常具有少量寄存器，寄存器中的内容由软件控制。然后，它具有－-层或多层高
存储管理和编译器优化必须在充分了解存储行为的基础上完成。现代机器的设计使得程序
下面是我们期望存储管理器具有的特性：
如果下面的(a）、（b)两个条件都成立，内存的管理就会相对简单：（a)所有分配请求都要求
型对象的开销相对不重要，因为通常会在它上面执行大量的计算，这个开销被分摊了。
的执行时间在总运行时间中所占的比例。请注意，分配的开销由小型请求决定，管理大
高效是非常重要的。也就是说，我们希望最小化开销（overhead），即花费在分配和回收上
低开销。因为存储分配和回收在很多程序中是常用的操作，因此使得这些操作尽可能地
能相差很大。幸运的是，程序通常会表现出“局部性”，7.4.3节将讨论这种现象，它指的
到最少而得到的，该技术将在7.4.4节中讨论。
空间效率。存储管理器应该能够使一个程序所需的堆区空间的总量达到最小。这样做就
要为不同大小的数据元素分配空间，并且没有好方法可以预测所有已分配对象的生命期。
7.4.2节中看到，根据数据对象在存储中所处的不同位置，执行-一条指令所花费的时间可
程序效率。存储管理器应该充分利用存储子系统，使程序可以运行得更快。我们将在
可以在--个固定大小的虚拟地址空间中运行更大的程序。空间效率是通过使存储碎片达
不再需要那么多的堆空间时也不会归还给操作系统。
来满足其他的分配请求。存储管理器通常不会将内存返回给操作系统，即使当这个程序
回收。存储管理器把被回收的空间返还到空闲空间的缓冲池中，这样它可以复用该空间
间。如果空间已经用完，存储管理器将空间耗尽的信息传回给应用程序。
疗
法，存储管理器可以更好地利用空间，并且有希望使程序运行得更快。
通常的程序在访问内存时具有的非随机性聚集的特性。通过关注对象在存储中的放置
秒
---
## Page 309
局部性（spatial locality）。
小的一部分代码中，此时它们只涉及少部分数据。如果一个程序访问的存储位置很可能将在一-
7.4.3程序中的局部性
传输的，高速缓存线的长度通常在32～256 字节之间。在虚拟内存(硬盘)和主内存之间的数据
常使用较大的块。在主存和高速缓存之间的数据是按照被称为高速缓存线（cache line）的块进行
理的，辅以一个称为“转换旁视缓冲”的硬件结构。
的程序可以在具有不同存储配置的机器上高效工作。对于每次存储访问，机器从最低层开始
管理。存储层次结构中的所有其他层都是自动管理的。这样做不仅简化了编程任务，并且相“
层的)的存储中寻找数据，如果数据不在那里则到上一层中寻找，以此类推。
是以被称为“页”（page)的内存块进行传输的，页的大小通常在4~64 KB 之间。
是
数据以连续存储块的方式进行传输。为了分摊访问的开销，内存层次结构中较慢的层次通
运行时刻环境
大部分程序表现出高度的局部性（locality），也就是说，程序的大部分运行时间花费在相对较
通常认为程序把90%的时间用来执行10%的代码。原因如下：
寄存器个数很少，因此寄存器的使用会根据特定应用进行裁剪，并由编译器生成的代码进行