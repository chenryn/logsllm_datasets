第一条指令将 **BSR** 的值设置为0x00，这意味着选择了Bank 0。 第二条指令从内存加载一个字节到 **WREG** 。 在选择Bank
0时，加载寄存器 **PORTE** 对应的值。
          0x00000000      2002           movlb 0x2
          0x00000001      1008           movf 0x10, w
这里就用到了选用的存储区2，也就是说LATE的值会被用到。
**外设寄存器**  
外设寄存器用于和PIC的外设硬件交互，比如说，UART，SPI或者GPIO都是通过它来控制读写的。  
 **通用寄存器**  
就用来读写数据。  
 **通用RAM寄存器**  
就跟上面一样，它用于读写RAM的数据，这里的内存区域和所有的Bank是一样的。它不受BSR的影响。  
 **PCL和PCLATH寄存器**  
PCL存储程序计数器的LSB，而PCLATH存储MSB。 可以直接写入这些寄存器。 让我们来看看以下内容。
          0x00000000      8831           movlp 0x8
          0x00000001      4230           movlw 0x42
          0x00000002      8200           movwf PCL
第一条指令将PCLATH寄存器加载到0x08。 这不会改变程序的执行流程，下面的指令继续执行，WREG设置为0x42。 最后，PCL设为WREG的值。
当以这种方式改变PCL时，将根据PCL和PCLATH的值修改执行流程。 在这种情况下，PIC将跳转到位于ad 0x0842的指令。
* * *
###  PIC 缓冲区溢出漏洞利用
PIC和平常的ARM、x86、mips的二进制漏洞不太一样。因为他是Harvard架构，代码和数据在不同的地址空间里，打shellcode的方式就不行了。  
而且PIC16F1527的调用栈的方式不在数据内存中。调用栈是用硬件实现的，也就没法从内存里找到它的地址。这里exploit不能用覆盖返回地址的方式实现了。
**SPI_transmit()**
为了更好的理解程序，我们要从底层看RF4CE从SPI的CC2534收到的payload数据。如果检查之前一节讲到的SPI帧，我们需要关注的是DATA段
LENGTH | CMD0 | CMD1 | SRCINDEX | PROFILEID | VENDORID | RXLQI | RXFLAGS | LEN
| `DATA`  
---|---|---|---|---|---|---|---|---|---  
0x09 | 0x4a | 0x05 | 0x00 | 0x01 | 0x0000 | 0x94 | 0x01 | 0x02 | `0x0201`  
下表给出了相关内存空间调用的函数：
ADDRESS / REGISTER | VALUE  
---|---  
0x032 | RF4CE Frame Payload Size  
WREG | 0xAA  
PCLATH | 0x03  
BSR | 0x00  
我们一步一步来看：
  * 首先，值WREG存储在地址0x033（bank 0，偏移0x33）。该值实际上是指向数据缓冲区的指针的LSB字节，用于存储RF4CE有效载荷。
  * 接下来，进入主循环。存储在0x033的 **RF4CE帧有效负载大小** 变量减少，并且检查是否能够接收更多的数据。 RF4CE帧有效载荷大小的值是该函数的参数。它已通过接收由CC2534发送的SPI数据的第一个字节进行检索。正如所料，不对此值边界进行检查。
  * 数据字节通过使用间接寻址方法从从0x3AA开始的地址获取。接下来将该字节装入 **SSP2BUS** 外设寄存器。
  * 一旦写入该寄存器，SPI传输开始。轮询SSP2STAT以等待传输结束。
  * 传输结束后，接收到的字节从SSP2BUS中获取。该字节通过间接寻址存储到数据缓冲区。
  * 最后，0x033处的字节（指向数据缓冲区的指针的LSB）增加。
**溢出点**
下图演示 **RF4CE** payload过大时发生的情况：  
数据指针到达`0x03ff`后，溢出到`0x0300`（因为只有LSB实际增加）并且数据被写入到核心寄存器（Core
Registers）。当PCL核心寄存器被覆盖时，执行流程被重定向。就用这个原理利用漏洞！
尽管如此，我们所能操作的空间仍然相当有限。我们只能控制程序计数器的LSB。 MSB不能被更改，并且由PCLATH寄存器设置为`0x03`。
因此，我们可以跳转到的地址，从`0x300`到`0x3ff`。
* * *
###  溢出利用
**利用计划**
正如之前所写，MCU连接到了UI板上，并且能实时的响应按钮。这包含了WPS按钮。  
这很直接，如果按钮按下，连接到PIC的GPIO **RC1** 与VCC连通，产生一个高电平。只要按钮按下，引脚接地，产生低电平。  
在固件方面，处理这样的输入可能会有两种方式：中断，或者记录GPIO的状态。此处用的是第一个。
在主循环的每一次迭代中，固件都会检查 **RC1** 输入的状态。 这是通过读取外设寄存器PORTC并检查位1是否置1来完成的。
按钮未按下时，该位为’1’，按下按钮，该位置’0’。
这里， **RC1** 被配置为输入。 可以通过不设置 **TRISC** 外设寄存器的1位将其配置为输出。 如果我们设置了这个位，即使没有按下按钮，
**PORTC** 也会变为’0’。 **TRISC** 的值由启动时的固件配置，并且只做一次。
这个很有用，因为这意味着如果我们能够翻转TRISC寄存器第1位的方法，固件实际上会按照WPS按钮按下来响应！
我发现一个RF4CE的payload可以搞定。 再次说明，它只能用在这个固件版本上，但并不意味着其他固件不可被利用，因为还是可能有缓冲区溢出的。
**Payload**
从图上可以看到payload。  
我已经把它分解成了几个段：  
第一部分，索引范围从`0x00`到`0x05`包含了一些现在还没法解释的值，但你应该很快就会参透。 这些值写入预期的内存地址，从`0x3AA`开始。
接下来，范围从`0x06`到`0x45`是padding。 这里的就是用与增加数据缓冲区指针的值。
从`0x46`开始溢出。 数据现在写入公用RAM（Common RAM）。 实际上没啥用。 填充字节仍被使用。
从索引`0x56`开始，才是最重要的。 核心寄存器（Core Register）最终被覆盖。 PCL寄存器被设置为`0x37`。
由于在SPI_transmit函数的上下文中PCLATH寄存器等于`0x03`，PIC将跳转到位于`0x0337`的指令。
指令地址如下：
          0x00000336      9231           movlp 0x12
    >>>>> 0x00000337      b822           call 0x2b8        ;should call 0x12b8 when pclath=0x12
          0x00000338      8331           movlp 0x3
有个函数调用。 不过，要跳转到有效函数的开头，PCLATH寄存器应该设为0x12。 对我们来说，它仍等于0x03。
这意味着PIC将实际上跳转到另一个函数中间的完全不同的地址。
从这里起，PIC将执行数十次指令，并且几次跳转。 幸运的是，执行所有这些指令没有明显的副作用。 最后，执行下面的一段代码。
    ```
      0x000012a3      a500           movwf 0x25
      0x000012a4      a030           movlw 0xa0
      0x000012a5      4226           call 0x642       ;Read some more data from SPI bus
      0x000012a6      9231           movlp 0x12
      0x000012a7      3f08           movf 0x3f, w
      0x000012a8      b200           movwf 0x32      ;dest_low
      0x000012a9      a430           movlw 0xa4
      0x000012aa      b301           clr 0x33, f     ;dest_high
      0x000012ab      b400           movwf 0x34      ;src_low
      0x000012ac      0330           movlw 0x3
      0x000012ad      b500           movwf 0x35      ;src_high
      0x000012ae      3e08           movf 0x3e, w      ;size
      0x000012af      b600           movwf 0x36
      0x000012b0      b701           clr 0x37, f
      0x000012b1      d726           call 0x6d7       ;"memcpy"
      0x000012b2      2700           movlb 0x7
      0x000012b3      2308           movf 0x23, w
      0x000012b4      0800           return
      ```
首先调用从SPI总线读取更多字节的一段代码。固定数量的7个字节将在`0x3a3`开始的地址处被读取和写入（这个代码实际上是一开始就读取由CC2534发送的SPI数据的）。
接下来，对`memcpy`函数进行一个有意思的调用。
源地址设为`0x3a4`。如果仔细观察前面的表格，会看到可以控制的从`0x3a4`开始的大量数据。
目标地址的MSB被设置为0x00，而我发现从地址`0x32`开始的低字节等于`0x83`。
运气很好，`size`参数也可以控制。因为一个我没怎么去解释的原因，这个参数被加载了之前发送的RF4CE数据包的一个字节。例如，在发送exploit溢出的包之前发送像`0c0c0c0c0c0c0c0c0c0c0c0c0c`的数据，保证`size`参数被加载的值是`0x0c`。
下表总结了`memcpy`的功能：  
你可以看到，多个核心寄存器（Core Register）能被控制m，这些字节的payload
index从`0x00`到`0x05`、`0x5a`到`0x5f`。  
为了保证程序能继续执行，要特别注意`PCLATH`和`INTCON`的值。  
`TRISA`和`TRISB`设为和之前一样的值，相反，TRISC更改为模拟WPS按钮按下。
可以通过将TRISC的1位设置为’1’并使用类似的payload完成“按钮释放”。
* * *
**完整的攻击场景**
通过使用所有这些知识，恶意用户可以访问受保护的WiFi网络。
在修补漏洞之前，可能会出现以下情况。
  * 当受害者使用STB的遥控器时，攻击者嗅探RF4CE数据包。 尽管这些数据包的payload被加密，但足以注入特定的数据包。
  * 攻击者发送旨在模拟WPS按钮按下的有效载荷。
  * 攻击者发送一个类似的有效载荷，模拟WPS按钮释放。
  * PIC固件被欺骗，认为WPS按钮已被物理按下。 它通知该事件的系统的网关部分。 WPS开始发现WiFi。
  * 因为可以控制WPS，攻击者可以将自己的设备连接到受害者的WiFi网络。
* * *
## 总结
STB上运行的Linux系统看起来像是设计时真的考虑了安全性：使用了加固的二进制文件，隔离由LXC容器执行，…
尽管如此，因为看起来像是一个不和安全非常相关的子系统的两个漏洞，实际上可以远程触发WPS进程。
在发现设备的时候，最后一个PIC固件受到缓冲区溢出的影响，但我没有找到利用它的办法。 PoC只能在之前的修订版本中实现。
尽管如此，一个铁了心要打的攻击者可能在等另一个可能可以利用这个洞的PIC固件版本发布。 所以向厂商披露漏洞还是很重要。
如今修复已经完成，PIC固件已在数月前迅速修补并部署。 所幸，这些漏洞如今已经不能再被利用了。