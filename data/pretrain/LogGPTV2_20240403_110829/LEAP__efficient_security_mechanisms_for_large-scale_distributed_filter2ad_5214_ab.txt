### 3.2.1 Node Key Generation

For each node \( u \) (each node has a unique ID), the key \( K_m^u \) is generated using the formula:
\[ K_m^u = f_{K_m}(u) \]
where \( f \) is a pseudo-random function and \( K_m \) is a master key known only to the controller. In this scheme, the controller can store only the master key, thereby saving storage space that would otherwise be required for storing individual keys. When the controller needs to communicate with a specific node \( u \), it computes \( K_m^u \) on the fly. Due to the computational efficiency of pseudo-random functions, the computational overhead is negligible.

### 3.2.2 Establishing Pairwise Shared Keys

In this paper, unless otherwise specified, a pairwise shared key refers to a key shared only between a node and one of its direct neighbors (i.e., one-hop neighbors).

For nodes whose neighborhood relationships are predetermined (e.g., via physical installation), pairwise key establishment is achieved by preloading the sensor nodes with the corresponding keys. Here, we focus on establishing pairwise keys for sensor nodes that are unaware of their neighbors until deployment (e.g., via aerial scattering). Our approach leverages the fact that in sensor networks consisting of stationary nodes, the set of neighbors of a node is relatively static. A newly deployed sensor node will discover most of its neighbors at the time of initial deployment.

Additionally, we assume that a sensor node deployed in a security-critical environment must be designed to withstand possible break-in attacks for at least a short interval (say several seconds) when captured by an adversary. Otherwise, the adversary could easily compromise all the sensor nodes in the network. Therefore, instead of assuming that sensor nodes are tamper-resistant, which often turns out not to be true, we assume there exists a lower bound \( T_{\text{min}} \) on the time interval necessary for an adversary to compromise a sensor node. We also assume that the time \( T_{\text{est}} \) for a newly deployed sensor node to discover its immediate neighbors is smaller than \( T_{\text{min}} \). In practice, we expect \( T_{\text{est}} \) to be of the order of several seconds, making it a reasonable assumption that \( T_{\text{min}} > T_{\text{est}} \).

We now describe our scheme in detail, given this lower bound \( T_{\text{min}} \). The approach used for key establishment by nodes incrementally added to the network is identical to the approach used at the time of initial network deployment. Below, we outline the four steps for adding a new node \( u \) to the sensor network:

1. **Key Pre-distribution**: The controller generates an initial key \( K_I \) and loads each node with this key. Each sensor node \( u \) derives a master key \( K_u = f_{K_I}(u) \).

2. **Neighbor Discovery**: When node \( u \) is deployed, it initializes a timer to fire after time \( T_{\text{min}} \). It then broadcasts a HELLO message containing a nonce and waits for each neighbor \( v \) to respond with its identity. The reply from each neighbor \( v \) is authenticated using its master key \( K_v \). Since node \( u \) can compute \( K_v \) using \( K_I \), it can verify node \( v \)'s identity independently.
   - \( u \rightarrow * \): \( u, \text{Nonce}_u \)
   - \( v \rightarrow u \): \( v, \text{MAC}(K_v, \text{Nonce}_u | v) \)

3. **Pairwise Key Establishment**: Node \( u \) computes its pairwise key with \( v \), \( K_{uv} \), as \( K_{uv} = f_{K_v}(u) \). Node \( v \) can also compute \( K_{uv} \) independently. No message is exchanged between \( u \) and \( v \) in this step. Note that node \( u \) does not need to authenticate itself to node \( v \) explicitly and immediately, as any future messages authenticated with \( K_{uv} \) by node \( u \) will prove its identity. No other nodes can compute \( K_{uv} \) after the key erasure phase below.

4. **Key Erasure**: When the timer expires, node \( u \) erases \( K_I \) and all the keys \( K_v \) it computed during the neighbor discovery phase.

After these steps, node \( u \) will have established a pairwise shared key with each of its neighbors. Further, no node in the network possesses \( K_I \). An adversary may have eavesdropped on all the traffic in this phase, but without \( K_I \), it cannot inject erroneous information or decrypt any of the messages. An adversary compromising a sensor node after \( T_{\text{min}} \) has expired will only obtain the keying material of the compromised node, not that of any other node. This scheme localizes the security impact of a node compromise. When a compromised node is detected, its neighbors simply delete the keys that were shared with this node.

The above scheme can be further simplified if two neighboring nodes, say \( u \) and \( v \), are added at the same time. For example, if \( u \) receives \( v \)'s response to \( u \)'s HELLO before \( u \) responds to \( v \)'s HELLO, \( u \) will suppress its own response. However, if \( u \) and \( v \) finish their neighbor discovery step separately, they will have two different pairwise keys, \( K_{uv} \) and \( K_{vu} \). In this case, they may choose \( K_{uv} \) as their pairwise key if \( u < v \).

**Discussion**: A critical assumption made by our scheme is that the actual time \( T_{\text{est}} \) to complete the neighbor discovery phase is smaller than \( T_{\text{min}} \). We believe this is a reasonable assumption for most sensor networks and adversaries. The current generation of sensor nodes can transmit at a rate of 19.2 Kbps [24], and the size of an ID announcement message is very small (12 bytes if an ID is 4 bytes and the MAC size is 8 bytes). The probability of collision is quite small when a non-persistent CSMA protocol is used for medium access control [25]. Moreover, a node can broadcast its ID multiple times to increase the probability that it is received by all its neighbors. We expect the total time in this phase to be of the order of several seconds.

Furthermore, to increase the difficulty for an adversary to recover \( K_I \) after physically capturing a sensor node, the node can copy \( K_I \) from non-volatile memory into volatile memory as soon as it is powered on, while erasing the copy of the key in the non-volatile memory. An implicit assumption here is that a sensor node can erase a key completely. While this may not be true for keys stored on disk, we believe it is true for keys stored in memory. Another implicit assumption is that a node \( u \) will not compute and then keep the master key of another node \( v \). As long as the program loaded in a sensor node is executed correctly, this situation will not occur.

### 3.2.3 Establishing Cluster Keys

The cluster key establishment phase follows the pairwise key establishment phase and is straightforward. Consider the case where node \( u \) wants to establish a cluster key with all its immediate neighbors \( v_1, v_2, \ldots, v_m \). Node \( u \) first generates a random key \( K_c^u \), then encrypts this key with the pairwise key of each neighbor, and transmits the encrypted key to each neighbor \( v_i \).
- \( u \rightarrow v_i \): \( (K_c^u)_{K_{uv_i}} \)

Node \( v_i \) decrypts the key \( K_c^u \) and stores it in a table. When one of the neighbors is revoked, node \( u \) generates a new cluster key and transmits it to all the remaining neighbors in the same way.

### 3.2.4 Establishing Multi-hop Pairwise Shared Keys

When a node wants to send its sensor readings to an aggregation node (or its cluster head) that is multiple hops away, to achieve privacy or strong source authentication, it must use a pairwise key shared only between itself and the aggregation point. We call such keys multi-hop pairwise shared keys to distinguish them from pairwise shared keys established with immediate neighbors.

We can extend the (one-hop) pairwise shared key establishment scheme discussed above for the establishment of two-hop pairwise keys. Specifically, once a node discovers its neighbors in the neighbor discovery phase, it then broadcasts their IDs. As a result, a node discovers all the nodes that can be reached in two hops. It can then establish a pairwise shared key with all the nodes that are two hops away using the same scheme it used for one-hop pairwise key establishment. This scheme works well if (i) two-hop pairwise shared keys can be established within \( T_{\text{min}} \) and (ii) a node has memory space to store these two-hop pairwise shared keys, in addition to all the other keys it needs to store.

If these two conditions cannot be satisfied, we can use the following scheme to establish a two-hop pairwise shared key on the fly. A node \( u \) broadcasts a QUERY message containing its own ID \( u \) and the ID of the cluster head \( c \). All the nodes that are neighbors to both node \( u \) and the cluster head \( c \) send back a REPLY, authenticated with their pairwise keys shared with node \( u \). We call the intermediate nodes proxies.

Using this procedure, node \( u \) may find multiple (say \( m \)) proxies, denoted as \( v_1, v_2, \ldots, v_m \). To establish a pairwise key \( S \) with node \( c \), node \( u \) first splits \( S \) into \( m \) shares, i.e., \( sk_1, sk_2, \ldots, sk_m \) such that \( S = sk_1 \oplus sk_2 \oplus \ldots \oplus sk_m \); it then forwards each share \( sk_i \) to the cluster head \( c \) through the \( i \)-th proxy \( v_i \). Namely,
- \( u \rightarrow v_i \): \( \{sk_i\}_{K_{uv_i}}, f_{sk_i}(0) \)
- \( v_i \rightarrow c \): \( \{sk_i\}_{K_{v_i c}}, f_{sk_i}(0) \)

Here, \( f_{sk_i}(0) \) is called the verification key of key \( sk_i \) because it allows the cluster head \( c \) to verify immediately if \( sk_i \) is valid. A compromised node \( v_i \) may change \( sk_i \) to \( sk_i' \) and attach \( f_{sk_i'}(0) \), but node \( u \) will detect this attack by overhearing node \( v_i \)'s transmission. Node \( v_i \) is required to erase \( sk_i \) after it has done the forwarding for node \( u \), which is important to prevent \( sk_i \) from being disclosed if node \( v_i \) is compromised later. After the cluster head \( c \) receives all shares, it reconstructs \( S \). The cluster head can send back a DONE message authenticated with \( S \), which allows node \( u \) to detect if the established pairwise key is correct. Clearly, this scheme is secure when up to \( m-1 \) proxies are compromised.

The scheme described above can be extended for establishing a pairwise key on the fly for two nodes that are more than two hops away. Its performance overhead will depend on the desired security level \( m \). An alternative approach for establishing multi-hop pairwise keys is to use the base station as a helper [22]. However, it is unclear if this approach will outperform our multiple path scheme. Designing a more efficient scheme for this purpose without the involvement of the base station is an interesting research problem.

### 3.2.5 Establishing Group Keys

A group key is a key shared by all the nodes in the network and is necessary when the controller is distributing a secure message, such as a query on some event of interest or a confidential instruction, to all the nodes in the network. One way for the base station to distribute a message \( M \) securely to all the nodes is using hop-by-hop translation. Specifically, the base station encrypts \( M \) with its cluster key and then broadcasts the message. Each neighbor receiving the message decrypts it to obtain \( M \), re-encrypts \( M \) with its own cluster key, and then re-broadcasts the message. The process is repeated until all the nodes receive \( M \). However, this approach has a major drawback: each intermediate node needs to encrypt and decrypt the message, thus consuming a non-trivial amount of energy on computation. Therefore, using a group key for encrypting a broadcast message is preferable from the performance point of view.

A simple way to bootstrap a group key for a sensor network is to pre-load every node with the group key. An important issue that arises immediately is the need to securely update this key when a compromised node is detected. In other words, the group key must be changed and distributed to all the remaining nodes in a secure, reliable, and timely fashion. The naive approach, in which the base station encrypts the updated group key using the individual key of each node and then sends the encrypted key to each node separately, is not scalable because its communication and computational costs increase linearly with the size of the network.

Below, we propose an efficient key updating scheme based on cluster keys. We first discuss authentic node revocation, which is a prerequisite for group keying, and then describe the secure key distribution mechanism in detail.

#### 3.2.5.1 Authentic Node Revocation

In a sensor network, all the messages the base station broadcasts to the sensors should be authenticated; otherwise, an outsider adversary or a compromised node may impersonate the base station. Therefore, a node revocation announcement must be authenticated when distributed. We employ µTESLA [22], a broadcast authentication protocol proposed by Perrig et al., due to its efficiency and tolerance to packet loss. µTESLA is based on the use of a one-way key chain along with delayed key disclosure. To use µTESLA, we assume that all the sensor nodes and the key server are loosely time-synchronized, i.e., a node knows the upper bound on the time synchronization error with the key server.

To bootstrap its µTESLA key chain, the controller preloads every node with the commitment (i.e., the first key) of the key chain prior to the deployment of the network. The base station then discloses the keys in the key chain periodically in the order reverse to the generation of these keys. The use of µTESLA allows the key server to broadcast authenticated packets (including keying materials and data messages) efficiently. Since µTESLA uses delayed key disclosure, a node needs to buffer a received message until it receives the µTESLA key used for authenticating this message. Thus, there is a one µTESLA interval latency for node revocation.

Let \( u \) be the node to be revoked, and let the to-be-disclosed µTESLA key be \( k_T^i \). The controller broadcasts the following message \( M \):
- \( M: \text{Controller} \rightarrow *: u, f_{k_g'}(0), \text{MAC}(k_T^i, u | f_{k_g'}(0)) \)

Here, we refer to \( f_{k_g'}(0) \) as the verification key because it enables a node to verify the authenticity of the group key \( k_g' \) that it will receive later. The key server then distributes the MAC key \( k_T^i \) after one µTESLA interval. After a node \( v \) receives message \( M \) and the MAC key that arrives one µTESLA interval later, it verifies the authenticity of \( M \) using µTESLA. If the verification is successful, node \( v \) will store the verification key \( f_{k_g'}(0) \) temporarily. Additionally, if node \( v \) is a neighbor of node \( u \), \( v \) will remove its pairwise key with \( u \) and update its cluster key.

#### 3.2.5.2 Secure Key Distribution

The new group key \( k_g' \) is distributed to all the legitimate sensor nodes via a recursive process over the spanning tree. Secure key distribution does not require the use of a specific routing protocol. However, for concreteness, in this paper, we assume the use of a routing protocol similar to the TinyOS beaconing protocol [12, 17]. In this protocol, the nodes in the network are organized into a breadth-first spanning tree based on routing updates that are periodically broadcast by the base station and recursively propagated to the rest of the network. Each node keeps track of not only its parent and its children in the spanning tree but also other immediate neighbors. Note that in the TinyOS beaconing protocol, a node does not maintain any information regarding any non-parent nodes in the spanning tree; however, this information is necessary for secure key distribution and for defending against various attacks in Section 5.