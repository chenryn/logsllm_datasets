u for a node u (each node has a
unique id) is generated as follows: Km
u = fKm
s (u). Here f is
a pseudo-random function and Km
is a master key known
s
only to the controller. In this scheme the controller might
only keep its master key to save the storage for keeping all
the individual keys. When it needs to communicate with an
individual node u, it computes Km
u on the ﬂy. Due to the
computational eﬃciency of pseudo random functions, the
computational overhead is negligible.
3.2.2 Establishing Pairwise Shared Keys
In this paper, unless otherwise speciﬁed, a pairwise shared
key belonging to a node refers to a key shared only between
the node and one of its direct neighbors (i.e. one-hop neigh-
bors).
For nodes whose neighborhood relationships are predeter-
mined (e.g., via physical installation), pairwise key estab-
lishment is simply done by preloading the sensor nodes with
the corresponding keys. Here we are interested in establish-
ing pairwise keys for sensor nodes unaware of their neigh-
bors until their deployment (e.g., via aerial scattering). Our
approach exploits the special property of sensor networks
consisting of stationary nodes that the set of neighbors of
a node is relatively static, and that a sensor node that is
being added to the network will discover most of its neigh-
bors at the time of its initial deployment. Second, it is our
belief that a sensor node deployed in a security critical en-
vironment must be designed to sustain possible break-in at-
tacks at least for a short interval (say several seconds) when
captured by the adversary; otherwise, the adversary could
easily compromise all the sensor nodes in a sensor network
and then take over the network. Therefore, instead of as-
suming that sensor nodes are tamper resistant which often
turns out not to be true [1], we assume there exists a lower
bound on the time interval Tmin that is necessary for an ad-
versary to compromise a sensor node, and that the time Test
for a newly deployed sensor node to discover its immediate
neighbors is smaller than Tmin. In practice, we expect Test
to be of the order of several seconds, so we believe it is a
reasonable assumption that Tmin > Test.
We now describe our scheme in detail, given this lower
bound Tmin. Note that the approach used by key establish-
ment by nodes that are incrementally added to the network
is identical to the approach used at the time of initial net-
work deployment. Below, we describe the four steps for
adding a new node u to the sensor network.
Key Pre-distribution The controller generates an initial
key KI and loads each node with this key. Each sensor
node u derives a master key Ku = fKI (u).
Neighbor Discovery When it is deployed, node u ﬁrst ini-
tializes a timer to ﬁre after time Tmin. It then tries to
discover its neighbors. It broadcasts a HELLO mes-
sage which contains a nonce, and waits for each neigh-
bor v to respond with its identity. The reply from each
neighbor v is authenticated using its master key Kv.
Since node u can compute Kv using KI , it is able to
verify node v’s identity independently.
u −→ ∗ :
v −→ u :
u, N onceu.
v, M AC(Kv, N onceu|v).
Pairwise Key Establishment Node u computes its pair-
wise key with v, Kuv, as Kuv = fKv (u). Node v can
also compute Kuv independently. No message is ex-
changed between u and v in this step. Note that node
u does not have to authenticate itself to node v ex-
plicitly and immediately, because any future messages
authenticated with Kuv by node u will prove node u’s
identity. No other nodes can compute Kuv after the
key erasure phase below.
Key Erasure When its timer expires, node u erases KI
and all the keys Kv it computed in the neighbor dis-
covery phase.
After the steps above, node u will have established a pair-
wise shared key with each of its neighbors. Further, no node
in the network possesses KI . An adversary may have eaves-
dropped on all the traﬃc in this phase, but without KI it
cannot inject erroneous information or decrypt any of the
messages. An adversary compromising a sensor node after
Tmin has expired will only obtain the keying material of the
compromised node, and not that of any other node. Thus,
this scheme localizes the security impact of a node compro-
mise. When a compromised node is detected, its neighbors
simply delete the keys that were shared with this node.
The above scheme can be further simpliﬁed when two
neighboring nodes, say u and v, are added at the same time.
For example, if u receives v’s response to u’s HELLO before
u responds to v’s HELLO, u will suppress its own response.
However, if u and v ﬁnish their neighbor discovery step sep-
arately, in the pairwise key establishment step they will have
two diﬀerent pairwise keys, Kuv and Kvu. In this case, they
may choose Kuv as their pairwise key if u < v.
Discussion A critical assumption made by our scheme is
that the actual time Test to complete the neighbor discov-
ery phase is smaller than Tmin. We believe that this is a
reasonable assumption for most sensor networks and adver-
saries. The current generation of sensor nodes can transmit
at the rate of 19.2 Kbps [24] whereas the size of an id an-
nouncement message is very small (12 bytes if an id is 4
bytes and the MAC size is 8 bytes). The probability of col-
lision is quite small when a non-persistent CSMA protocol is
used for medium access control [25]. Moreover, a node can
broadcast its id multiple times to increase the probability
that it is received by all its neighbors. We expect the total
time in this phase should be of the order of several seconds.
Furthermore, to increase the diﬃculty for an adversary to
recover KI after it has physically capturing a sensor node,
the node can copy KI from non-volatile memory into volatile
memory as soon as it is powered on, while erasing the copy of
the key in the non-volatile memory. An implicit assumption
here is that a sensor node is able to erase a key completely.
While this may not be true for keys stored on disk, we believe
that this is true for keys stored in memory. Another implicit
assumption is that is a node u will not compute and then
keep the master key of another node v. We believe as long
as the program loaded in a sensor node is executed correctly,
this situation will not occur.
Node Addition
For a very dense sensor network, re-
searchers suggest that maintaining only a necessary set of
working nodes while turning oﬀ redundant ones would ex-
tend the lifetime of a network [3, 27]. To employ our scheme
in these applications, a new node u can establish pairwise
keys with the working nodes. However, node u will not
be able to establish pairwise keys with nodes that are in
sleep mode during the initial Tmin. To address this issue,
we let node u obtain neighbor lists from the working nodes
which will include most of the nodes within two hops of
node u. Node u can then proceed to compute its pairwise
keys for the sleeping nodes and then erase KI and other
intermediate keys. Alternatively, the multi-path scheme in
Section 3.2.4 can be used to establish a pairwise key on the
ﬂy for two nodes even though they have not established one
within Tmin.
3.2.3 Establishing Cluster Keys
The cluster key establishment phase follows the pairwise
key establishment phase, and the process is very straight-
forward. Consider the case that node u wants to establish
a cluster key with all its immediate neighbors v1, v2, ..., vm.
Node u ﬁrst generates a random key K c
u, then encrypts this
key with the pairwise key of each neighbor, and then trans-
mits the encrypted key to each neighbor vi.
u −→ vi : (K c
u)Kuvi
.
Node vi decrypts the key K c
u and stores it in a table. When
one of the neighbors is revoked, node u generates a new
cluster key and transmits to all the remaining neighbors in
a same way.
3.2.4 Establishing Multi-hop Pairwise Shared Keys
When a node wants to send its sensor readings to an ag-
gregation node (or its cluster head) that is multiple hops
away, to achieve privacy or strong source authentication, it
has to use a pairwise key that is shared only between itself
and the aggregation point. We call such keys multi-hop pair-
wise shared keys to distinguish them from pairwise shared
keys established with immediate neighbors.
We can simply extend the (one-hop) pairwise shared key
establishment scheme discussed above for the establishment
of two-hop pairwise keys. Speciﬁcally, once a node discovers
its neighbors in the neighbor discovery phase, it then broad-
casts their ids. As a result, a node discovers all the nodes
that can be reached in two hops.
It can then establish a
pairwise shared key with all the nodes that are two hops
away using the same scheme it used for one-hop pairwise
key establishment. This scheme works well if (i) two-hop
pairwise shared keys can be established within Tmin and (ii)
a node has memory space to store these two-hop pairwise
shared keys, in addition to all the other keys it needs to
store.
If these two conditions cannot be satisﬁed, we can use the
following scheme to establish a two-hop pairwise shared key
on the ﬂy. A node u broadcasts a QUERY message which
contains its own id u and the id of the cluster head c. All
the nodes that are a neighbor to both the node u and the
cluster head c sends back a REPLY, authenticated with their
pairwise keys shared with node u. We call the intermediate
nodes proxies.
Using this procedure, node u may ﬁnd multiple (say m)
proxies, denoted as v1, v2, ..., vm. To establish a pairwise
key S with node c, node u ﬁrst splits S into m shares, i.e.,
sk1, sk2, ..., skm such that S = sk1 ⊕ sk2... ⊕ skm; it then
forwards each share ski to the cluster head c through the
ith proxy vi. Namely,
u −→ vi : {ski}
, fski (0).
vi −→ c : {ski}Kvi c , fski (0).
Kuvi
(cid:1)
i
Here fski (0) is called the veriﬁcation key of key ski because
it allows the cluster head c to verify immediately if ski is
(cid:1)
valid. A compromised node vi may change ski to sk
i and
(0), but node u will detect this attack by over-
attach fsk
hearing node vi’s transmission. Node vi is required to erase
ski after it has done the forwarding for node u, which is
important to prevent ski from being disclosed if node vi
is compromised later. After the cluster head c receives all
shares, it re-constructs S. The cluster head can send back a
DONE message authenticated with S, which allows node u
to detect if the established pairwise key is correct. Clearly,
this scheme is secure when up to m − 1 proxies are compro-
mised.
The scheme described above can be extended for estab-
lishing a pairwise key on the ﬂy for two nodes that are more
than two hops away. Its performance overhead will depend
on the desired security level m. An alternative approach for
establishing multi-hop pairwise keys is to use the base sta-
tion as a helper [22]. However, it is unclear if this approach
will outperform our multiple path scheme. Designing a more
eﬃcient scheme for this purpose without the involvement of
the base station is an interesting research problem.
3.2.5 Establishing Group Keys
A group key is a key shared by all the nodes in the net-
work, and it is necessary when the controller is distributing
a secure message, e.g., a query on some event of interest or
a conﬁdential instruction, to all the nodes in the network.
One way for the base station to distribute a message M
securely to all the nodes is using hop-by-hop translation.
Speciﬁcally, the base station encrypts M with its cluster
key and then broadcasts the message. Each neighbor re-
ceiving the message decrypts it to obtain M , re-encrypts M
with its own cluster key, and then re-broadcasts the mes-
sage. The process is repeated until all the nodes receive
M . However, this approach has a major drawback, that is,
each intermediate node needs to encrypt and decrypt the
message, thus consuming a non-trivial amount of energy on
computation. Therefore, using a group key for encrypting a
broadcast message is preferable from the performance point
of view.
A simple way to bootstrap a group key for a sensor net-
work is to pre-load every node with the group key. An im-
portant issue that arises immediately is the need to securely
update this key when a compromised node is detected. In
other words, the group key must be changed and distributed
to all the remaining nodes in a secure, reliable and timely
fashion. The naive approach in which the base station en-
crypts the updated group key using the individual key of
each node and then sends the encrypted key to each node
separately is not scalable because its communication and
computational costs increase linearly with the size of the
network.
Below we propose an eﬃcient key updating scheme based
on cluster keys. We ﬁrst discuss authentic node revocation
that is a prerequisite for group keying, then describe the
secure key distribution mechanism in detail.
3.2.5.1 Authentic Node Revocation.
In a sensor network, all the messages the base station
broadcasts to the sensors should be authenticated; other-
wise, an outsider adversary or a compromised node may
impersonate the base station. Therefore, a node revocation
announcement must be authenticated when distributed.
We employ µTESLA [22], a broadcast authentication pro-
tocol proposed by Perrig et al, due to its eﬃciency and tol-
erance to packet loss. µTESLA is based on the use of a
one-way key chain along with delayed key disclosure. To
use µTESLA, we assume that all the sensor nodes and the
key server are loosely time synchronized, i.e., a node knows
the upper bound on the time synchronization error with the
key server.
To bootstrap its µTESLA key chain, the controller pre-
loads every node with the commitment (i.e., the ﬁrst key)
of the key chain prior to the deployment of the network.
The base station then discloses the keys in the key chain
periodically in the order reverse to the generation of these
keys. The use of µTESLA allows the key server to broad-
cast authenticated packets (including keying materials and
data messages) eﬃciently. Since µTESLA uses delayed key
disclosure, a node needs to buﬀer a received message until it
receives the µTESLA key used for authenticating this mes-
sage. Thus, there is a one µTESLA interval latency for node
revocation.
Let u be the node to be revoked, and k
Let the to-be-disclosed µTESLA key be kT
broadcasts the following message M :
(cid:1)
g the new group key.
i . The controller
M : Controller −→ ∗ : u, fk(cid:1)
g
(0), M AC(kT
i , u|fk(cid:1)
g
(0)).
g
Again, here we refer to fk(cid:1)
(0) as the veriﬁcation key because
it enables a node to verify the authenticity of the group key
(cid:1)
k
g that it will receive later. The key server then distributes
the MAC key kT
i after one µTESLA interval. After a node
v receives message M and the MAC key that arrives one
µTESLA interval later, it veriﬁes the authenticity of M us-
ing µTESLA. If the veriﬁcation is successful, node v will
store the veriﬁcation key fk(cid:1)
(0) temporarily. In addition, if
node v is a neighbor of node u, v will remove its pairwise
key with u and updates its cluster key.
g
3.2.5.2
Secure Key Distribution.
The new group key k
Secure key distribution does not require the use of a spe-
ciﬁc routing protocol. However, for concreteness, in this
paper we assume the use of a routing protocol similar to
the TinyOS beaconing protocol [12, 17]. In this protocol,
the nodes in the network are organized into a breadth ﬁrst
spanning tree on the basis of routing updates that are peri-
odically broadcast by the base station and recursively prop-
agated to the rest of the network. Each node keeps track of
not only its parent and its children in the spanning tree, and
also other immediate neighbors. Note that in the TinyOS
beaconing protocol a node does not maintain any informa-
tion regarding any non-parent nodes in the spanning tree;
however, this information is necessary for secure key distri-
bution below and for defending against various attacks in
Section 5.
(cid:1)
g by checking if fk(cid:1)
(cid:1)
g is distributed to all the legitimate
sensor nodes via a recursive process over the spanning tree