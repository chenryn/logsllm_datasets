We plan to fully assess our runtime overhead as part of
future work. However, we do not anticipate it to be pro-
hibitively high. The number of instrumentation points per
instrumented widget ranges roughly in proportion to the
size and complexity of the widget. However, it is gen-
erally difﬁcult to perform large-scale overhead measure-
ments for a number of highly interactive widgets.
Instead we have devised an experiment to approximate
the overheads. Note that we can discern the average den-
sity of checks from the numbers in Figure 19: for instance,
for Live.com, the number of instrumentation points per
ﬁle is 1.74, with an average ﬁle being 105 lines, as shown
in Figure 15. This yields about 2% of all lines being in-
strumentated, on average.
To mimic this runtime check density, we generate a test
script shown in Figure 20 with 100 ﬁelds stores, where the
ﬁrst two stores require runtime checking and the other 98
are statically known. For Sidebar and Google widgets,
we construct similar test scripts with a different density
of checks. As shown below, we use index innerHTML
for one out of two rewritten cases for Live. We use it
for 2 out of 3 cases for Sidebase, and 2 out of 4 cases
for Google. This represents a pretty high frequency of
innerHTML assignments.
We wrap this code in a loop that we run 1,000 times to
be able to measure the overheads reliably and then take
the median over several runs to account for noise. The
baseline is the same test with no index or right-hand side
checks. We observe overheads ranging between 40–73%
across the different instrumentation densities, as shown in
Figure 19. It appears that calls to toStaticHTML result in
a pretty substantial runtime penalty. This is likely because
the relatively heavy-weight HTML parser of the browser
needs to be invoked on every HTML snippet.
Note that this experiment provides an approximate
measure of overhead that real programs are likely to expe-
rience. However, these numbers are encouraging, as they
are signiﬁcantly smaller overheads on the order of 6–40x
that tools like Caja may induce [28].
console.log(new Date().getTime());
var v1 = new Array();
var v2 = "" +
"Hello";
for(var iter = 0; iter :");
} else
if(i==="innerHTML" && __IsUnsafe(v2)){
alert("Unsafe innerHTML at :");
} else {
v1[i] = v2;
}
// second store: check
i = ’onclick’;
if (i==="onclick" ||
i==="onkeypress" || ...) {
alert("Disguised eval at :");
} else
if(i==="innerHTML" && __IsUnsafe(v2)){
alert("Unsafe innerHTML at :");
} else {
v1[i] = v2;
}
// all other stores are unchecked
v1[i] = 2;
v1[i] = 3;
...
v1[i] = 100;
}
console.log(new Date().getTime());
Figure 20: Measuring the overhead of GATEKEEPER checking.
6 Related Work
Much of the work related to this paper focuses on limit-
ing various attack vectors that exist in JavaScript. They
do this through the use of type systems, language restric-
tions, and modiﬁcations to the browser or the runtime. We
describe these strategies in turn below.
6.1 Static Safety Checks
JavaScript is a highly dynamic language which makes it
difﬁcult to reason about programs written in it. However,
with certain expressiveness restrictions, desirable secu-
rity properties can be achieved. ADSafe and Facebook
both implement a form of static checking to ensure a form
of safety in JavaScript code. ADSafe [13] disallows dy-
namic content, such as eval, and performs static check-
ing to ensure the JavaScript in question is safe. Facebook
takes an approach similar to ours in rewriting statically
unresolved ﬁeld stores, however, it appears that, unlike
GATEKEEPER, they do not try to do local static analysis
of ﬁeld names. Facebook uses a JavaScript language vari-
ant called FBJS [15], that is like JavaScript in many ways,
but DOM access is restricted and all variable names are
preﬁxed with a unique identiﬁer to prevent name clashes
with other FBJS programs on the same page.
In many ways, however, designing a safe language sub-
set is a tricky business. Until recently, is was difﬁcult to
write anything but most simple applications in AdSafe be-
cause of its static restrictions, at least in our personal ex-
perience. More recently, AdSafe was updated with APIs
to lift some of initial restrictions and allow DOM access,
etc., as well as several illustrative sample widgets. Over-
all, these changes to allow compelling widgets to be writ-
ten are an encouraging sign. While quite expressive, FBJS
has been the subject of several well-publicised attacks
that circumvent the isolation of the global object offered
through Facebook sandbox rewriting [2]. This demon-
strates that while easy to implement, reasoning about what
static language restrictions accomplish is tricky.
GATEKEEPER largely sidesteps the problem of proper
language subset design, opting for whole program analy-
sis instead. We do no try to prove that JavaScriptSAFE pro-
grams cannot pollute the global namespace for all pro-
grams, for example. Instead, we take the entire program
and a representation of its environment and use our static
analysis machinery to check if this may happen for the in-
put program in question. The use of static and points-to
analysis for ﬁnding and vulnerabilities and ensuring se-
curity properties has been previously explored for other
languages such as C [6] and Java [23].
is
An interesting recent development
in JavaScript
the strict mode
language standards committees
(use strict) for JavaScript [14], page 223, which is be-
ing proposed around the time of this writing. Strict mode
accomplishes many of the goals that JavaScriptSAFE is de-
signed to accomplish: eval is largely prohibited, bad
coding practices such as assigning to the arguments ar-
ray are prevented, with is no longer allowed, etc. Since
the strict mode supports customization capabilities, going
forward we hope to be able to express JavaScriptSAFE and
JavaScriptGK restrictions in a standards-compliant way, so
that future off-the-shelf JavaScript interpreters would be
able to enforce them.
6.2 Rewriting and Instrumentation
A practical alternative to static language restrictions is
instrumentation. Caja [29] is one such attempt at limit-
ing capabilities of JavaScript programs and enforcing this
through the use of runtime checks. WebSandbox is an-
other project with similar goals that also attempts to en-
force reliability and resource restrictions in addition to se-
curity properties [25].
Yu et al. traverse the JavaScript document and rewrite
based on a security policy [35]. Unlike Caja and Web-
Sandbox, they prove the correctness of their rewriting
with operational semantics for a subset of JavaScript
called CoreScript. BrowserShield [30] similarly uses dy-
namic and recursive rewriting to ensure that JavaScript
and HTML are safe, for a chosen version of safety, and
all content generated by the JavaScript and HTML is
also safe.
Instrumentation can be used for more than
just enforcing security policies. AjaxScope [20] rewrites
JavaScript to insert instrumentation that sends runtime in-
formation, such as error reporting and memory leak de-
tection, back to the content provider.
Compared to these techniques, GATEKEEPER has two
main advantages. First, as a mostly static analysis, GATE-
KEEPER places little runtime overhead burden on the user.
While we are not aware of a comprehensive overhead
evaluation that has been published, it appears that the run-
time overhead of Caja and WebSandbox may be high, de-
pending on the level of rewriting. For instance, a Caja au-
thors’ report suggest that the overhead of various subsets
that are part of Caja are 6–40x [28]. Second, as evidenced
by the Facebook exploits mentioned above [2], it is chal-
lenging to reason about whether source-level rewriting
provides complete isolation. We feel that sound static
analysis may provide a more systematic way to reason
about what code can do, especially in the long run, as it
pertains to issues of security, reliability, and performance.
While the soundness of the native environment and ex-
haustiveness of our runtime checks might be weak points
of our approach, we feel that we can address these chal-
lenges as part of future work.
6.3 Runtime and Browser Support
Current browser infrastructure and the HTML standard re-
quire a page to fully trust foreign JavaScript if they want
the foreign JavaScript to interact with their site. The al-
ternative is to place foreign JavaScript in an isolated en-
vironment, which disallows any interaction with the host-
ing page. This leads to web sites trusting untrustworthy
JavaScript code in order to provide a richer web site. One
solution to get around this all-or-nothing trust problem is
to modify browsers and the HTML standard to include
a richer security model that allows untrusted JavaScript
controlled access to the hosting page.
MashupOS [18] proposes a new browser that is mod-
eled after an OS and modiﬁes the HTML standard to pro-
vide new tags that make use of new browser functional-
ity. They provide rich isolation between execution en-
vironments, including resource sharing and communica-
tion across instances. In a more lightweight modiﬁcation
to the browser and HTML, Felt et al.
[16] add a new
HTML tag that labels a div element as untrusted and lim-
its the actions that any JavaScript inside of it can take.
This would allow content providers to create a sand box
in which to place untrusted JavaScript. Integrating GATE-
KEEPER techniques into the browser itself, without rely-
ing on server-side analysis, and making them fast enough
for daily use, is part of future work.
6.4 Typing and Analysis of JavaScript
A more useful type system in JavaScript could prevent er-
rors or safety violations. Since JavaScript does not have a
rich type system to begin with, the work here is devising
a correct type system for JavaScript and then building on
the proposed type system. Soft typing [8] might be one of
the more logical ﬁrst steps in a type system for JavaScript.
Much like dynamic rewriters insert code that must be ex-
ecuted to ensure safety, soft typing must insert runtime
checks to ensure type safety.
Other work has been done to devise a static type system
that describes the JavaScript language [4, 5, 31]. These
works focus on a subset of JavaScript and provide sound
type systems and semantics for their restricted subests
of JavaScript. As far as we can tell, none of these ap-
proaches have been applied to realistic bodies of code.
GATEKEEPER uses a pointer analysis to reason about the
JavaScript program in contrast to the type systems and
analyses of these works. We feel that the ability to reason
about pointers and the program call graph allows us to ex-
press more interesting security policies than we would be
able otherwise.
A contemporaneous project by Chugh et al. focuses on
staged analysis of JavaScript and ﬁnding information ﬂow
violations in client-side code [10]. Chugh et al. focus
on information ﬂow properties such as reading document
cookies and changing the locations, not unlike the loca-
tion policy described in Section 4.4. A valuable feature of
that work is its support for dynamically loaded and gener-
ated JavaScript in the context of what is generally thought
of as whole-program analysis.
7 Conclusions
This paper presents GATEKEEPER, a mostly static sound
policy enforcement tool for JavaScript programs. GATE-
KEEPER is built on top of what to our knowledge is the
ﬁrst pointer analysis developed for JavaScript. To show
the practicality of our approach, we describe nine rep-
resentative security and reliability policies for JavaScript
widgets. Statically checking these policies results in 1,341
veriﬁed warnings in 684 widgets, with 113 false positives
affecting only two widgets.
We feel that static analysis of JavaScript is a key build-
ing block for enabling an environment in which code from
different parties can safely co-exist and interact. The abil-
ity to analyze a programming language using automatic
tools is a valuable one for long-term language success.
It is therefore our hope that our experience with ana-
lyzable JavaScript language subsets will inform the de-
sign of language restrictions build into future versions of
the JavaScript language, as illustrated by the JavaScript
use strict mode.
While in this paper our focus is on policy enforcement,
the techniques outlines here are generally useful for any
task that involves reasoning about code such as code op-
timization, rewriting, program understanding tools, bug
ﬁnding tools, etc. Moreover, we hope that GATEKEEPER
paves the way for centrally-hosted software repositories
such as the iPhone application store, Windows Market-
place, or Android Market to ensure the security and qual-
ity of software contributed by third parties.
Acknowledgments
We are grateful to Trishul Chilimbi, David Evans, Karthik
Pattabiraman, Nikhil Swamy, and the anonymous review-
ers for their feedback on this paper. We appreciate John
Whaley’s help with bddbddb.
References
[1] A. V. Aho, M. Lam, R. Sethi, and J. D. Ullman. Compilers: Prin-
ciples, Techniques, and Tools. Addison-Wesley, 2007.
[2] Ajaxian. Facebook JavaScript and security. http://ajaxian.com/
archives/facebook-javascript-and-security, Aug. 2007.
[3] L. O. Andersen. Program analysis and specialization for the C pro-
gramming language. Technical report, University of Copenhagen,
1994.
[4] C. Anderson and P. Giannini. Type checking for JavaScript.
In In WOOD 04, volume WOOD of ENTCS. Elsevier, 2004.
http://www.binarylord.com/ work/js0wood.pdf, 2004.
[5] C. Anderson, P. Giannini, and S. Drossopoulou. Towards type in-
In In Proceedings of the European Con-
ference for JavaScript.
ference on Object-Oriented Programming, pages 429–452, July
2005.
[6] D. Avots, M. Dalton, B. Livshits, and M. S. Lam. Improving soft-
ware security with a C pointer analysis. In Proceedings of the In-
ternational Conference on Software Engineering, pages 332–341,
May 2005.
[7] T. Ball, E. Bounimova, B. Cook, V. Levin, J. Lichtenberg, C. Mc-
Garvey, B. Ondrusek, S. K. Rajamani, and A. Ustuner. Thorough
static analysis of device drivers. In European Conference on Com-
puter Systems, pages 73–85, 2006.
[8] R. Cartwright and M. Fagan. Soft typing. ACM SIGPLAN Notices,
39(4):412–428, 2004.
[9] B. Chess, Y. T. O’Neil,
JavaScript hi-
jacking. www.fortifysoftware.com/servlet/downloads/public/
JavaScript Hijacking.pdf, Mar. 2007.
and J. West.
[10] R. Chugh, J. A. Meister, R. Jhala, and S. Lerner. Staged infor-
mation ﬂow for JavaScript. In Proceedings of the Conference on
Programming Language Design and Implementation, June 2009.
[11] D. Crockford. Globals are evil. http://yuiblog.com/blog/2006/
06/01/global-domination/, June 2006.
[12] D. Crockford. JavaScript: the good parts. 2008.
[13] D. Crockford. AdSafe: Making JavaScript safe for advertising.
http://www.adsafe.org, 2009.
[14] ECMA.
Ecma-262: Ecma/tc39/2009/025, 5th edition, ﬁ-
nal draft. http://www.ecma-international.org/publications/
files/drafts/tc39-2009-025.pdf, Apr. 2009.
[15] Facebook, Inc. Fbjs. http://wiki.developers.facebook.com/
index.php/FBJS, 2007.
[16] A. Felt, P. Hooimeijer, D. Evans, and W. Weimer. Talking to
strangers without taking their candy: isolating proxied content. In
Proceedings of the Workshop on Social Network Systems, pages
25–30, 2008.
[17] Finjan Inc. Web security trends report. http://www.finjan.com/
GetObject.aspx?ObjId=506.
[18] J. Howell, C. Jackson, H. J. Wang, and X. Fan. MashupOS: Op-
erating system abstractions for client mashups. In Proceedings of
the Workshop on Hot Topics in Operating Systems, May 2007.
[19] javascript-reference.info.
review.
tors
javascript-obfuscators-review.htm, 2008.
obfusca-
http://javascript-reference.info/
JavaScript
[20] E. Kıcıman and B. Livshits. AjaxScope: a platform for remotely
monitoring the client-side behavior of Web 2.0 applications.
In
Proceedings of Symposium on Operating Systems Principles, Oct.
2007.
[21] M. S. Lam, J. Whaley, B. Livshits, M. C. Martin, D. Avots,
M. Carbin, and C. Unkel. Context-sensitive program analysis as
database queries. In Proceedings of the Symposium on Principles
of Database Systems, June 2005.
[22] B. Livshits and S. Guarnieri. Gatekeeper: Mostly static enforce-
ment of security and reliability policies for JavaScript code. Tech-
nical Report MSR-TR-2009-43, Microsoft Research, Feb. 2009.
[23] B. Livshits and M. S. Lam. Finding security errors in Java pro-
grams with static analysis. In Proceedings of the Usenix Security
Symposium, pages 271–286, Aug. 2005.
[24] Microsoft Corporation.
Static driver veriﬁer.
http://www.
microsoft.com/whdc/devtools/tools/SDV.mspx, 2005.
Live Labs Websandbox.
http://
[27] Microsoft Security Bulletin. Vulnerabilities in Windows gadgets
http://www.
could allow remote code execution (938123).
microsoft.com/technet/security/Bulletin/MS07-048.mspx,
2007.
[28] M. S. Miller.
Is it possible to mix ExtJS and google-caja to
enhance security. http://extjs.com/forum/showthread.php?p=
268731#post268731, Jan. 2009.
[29] M. S. Miller, M. Samuel, B. Laurie, I. Awad, and M. Stay. Caja:
Safe active content in sanitized JavaScript. http://google-caja.
googlecode.com/files/caja-2007.pdf, 2007.
[30] C. Reis, J. Dunagan, H. Wang, O. Dubrovsky, and S. Esmeir.
BrowserShield: Vulnerability-driven ﬁltering of dynamic HTML.
In Proceedings of the Symposium on Operating Systems Design
and Implementation, 2006.
[31] P. Thiemann. Towards a type system for analyzing JavaScript pro-
grams. 2005.
[32] J. Whaley, D. Avots, M. Carbin, and M. S. Lam. Using Datalog
and binary decision diagrams for program analysis. In Proceedings
of the Asian Symposium on Programming Languages and Systems,
Nov. 2005.
[33] J. Whaley and M. S. Lam. Cloning-based context-sensitive pointer
alias analysis using binary decision diagrams. In Proceedings of
the Conference on Programming Language Design and Implemen-
tation, pages 131–144, June 2004.
[34] Windows Live. Windows live gadget developer checklist. http:
//dev.live.com/gadgets/sdk/docs/checklist.htm, 2008.
[35] D. Yu, A. Chander, N. Islam, and I. Serikov. JavaScript instru-
mentation for browser security. In Proceedings of Conference on
Principles of Programming Languages, Jan. 2007.
[25] Microsoft Live Labs.
websandbox.org, 2008.
[26] Microsoft Live Labs.
tions.
qos.aspx, 2008.
Quality of service (QoS) protec-
http://websandbox.livelabs.com/documentation/use