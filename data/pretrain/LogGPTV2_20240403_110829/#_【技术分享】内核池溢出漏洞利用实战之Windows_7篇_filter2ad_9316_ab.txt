，我们选择它是因为这是最优雅的方式之一，32位和64位系统均能实现利用，在此攻击中，我们必须覆盖下一个块的进程指针。
该池头的最后4个字节有一个指向 **EPROCESS** 结构的指针，当有池块被释放时，如果 **PoolType** 设置了 **Quota bit**
，该指针会减小某些与EPROCESS对象有关的值：
**a**. 该对象的 **引用计数** （一个进程是一个对象）
**b**. **QuotaBlock** 字段指向的值
减值之前会有一些检查，我们不可以直接利用对象的ReferenceCount，不过可以伪造一个 **EPROCESS**
结构，并在QuotaBlock字段设置任意指针以减随机的值（内核空间也可以哦）。
    kd> dt nt!_EPROCESS
     +0x000 Pcb : _KPROCESS
     +0x098 ProcessLock : _EX_PUSH_LOCK
     +0x0a0 CreateTime : _LARGE_INTEGER
     +0x0a8 ExitTime : _LARGE_INTEGER
     +0x0b0 RundownProtect : _EX_RUNDOWN_REF
     +0x0b4 UniqueProcessId : Ptr32 Void
     +0x0b8 ActiveProcessLinks : _LIST_ENTRY
     +0x0c0 ProcessQuotaUsage : [2] Uint4B
     +0x0c8 ProcessQuotaPeak : [2] Uint4B
     +0x0d0 CommitCharge : Uint4B
     +0x0d4 QuotaBlock : Ptr32 _EPROCESS_QUOTA_BLOCK 
     [...]
    typedef struct _EPROCESS_QUOTA_BLOCK {
       EPROCESS_QUOTA_ENTRY QuotaEntry[3];
       LIST_ENTRY QuotaList;
       ULONG ReferenceCount;
       ULONG ProcessCount;
     } EPROCESS_QUOTA_BLOCK, *PEPROCESS_QUOTA_BLOCK;
**3.2 溢出实现**
为了实现 **配额进程指针溢出** 攻击，我们需要利用我们的溢出覆盖两个东西：
a.下一个块的 **池类型** ，因为我们需要确定已经设置了 **Quota bit**
b.下一块的 **进程指针** ，用一个指向伪造的 **EPROCESS** 结构的指针替换它
因为我们必须获取到下一块的进程指针，所以无论如何必须要覆盖下一块的整个池头，然而我们不能往池头发随机的数据否则会触发BSOD。
我们必须确定如下字段是正确的：
**a**.块大小
**b**.前一个块大小
**c**.池类型
满足此条件的唯一方式是准确获取要覆盖的块，这可以通过 **池喷射技术** 来实现。
这里不会详细阐述如何实现池喷射，但基本思路就是获取这种类型的池：
看起来类似这样：
我们的溢出效果：
溢出前：
溢出后：
**3.3 Payload**
好了，我们可以在任何地址实现减任何值了，下一步做什么呢？我们搜索到了一篇很好的Cesar
Cerrudo[4]的文章，文中讲述了几种提权的技术。还有一点也很有趣，在TOKEN结构中有一个Privileges字段：
    typedef struct _TOKEN 
     {
     [...]
     /*0x040*/ typedef struct _SEP_TOKEN_PRIVILEGES
               {
                   UINT64 Present;
     /*0x048*/     UINT64 Enabled;
                   UINT64 EnabledByDefault;
               } SEP_TOKEN_PRIVILEGES, *PSEP_TOKEN_PRIVILEGES;
     [...]
     }TOKEN, *PTOKEN;
该字段是包含位掩码的结构体，位掩码 **Enabled**
定义了进程可执行的操作。该位掩码默认值为0x80000000，具有SeChangeNotifyPrivilege权限，从该位掩码中去掉一位变成了0x7fffffff，就拥有了更大的权限，MSDN文档提供了该位掩码的可用的权限列表：
但是我们没有_TOKEN结构的地址，我们也不应该有因为那是内核地址。幸运的是，我们可以利用众所周知的
**NtQuerySystemInformation**
通过其句柄获取任何对象的内核地址。还可以通过调用OpenProcessToken()函数为我们的token赋予句柄，如果你想更深入了解
**NtQuerySystemInformation()**
函数和常见的内核地址溢出你应该参考[这里](https://recon.cx/2013/slides/Recon2013-Alex%20Ionescu-I%20got%2099%20problems%20but%20a%20kernel%20pointer%20ain't%20one.pdf)。
我们决定触发这个漏洞以获取SeDebugPrivilege权限，该权限可以实现控制系统所有进程，你可以获取任何你想要的权限。
**SeDebugPrivilege** 权限可以允许我们在系统进程中启动线程并反弹一个系统shell。
**四、结论**
****
注意，这个exploit不能在windows
8及更高版本系统中使用，毕竟微软在防御内核漏洞方面做了大量工作。实际上，虽然此exploit不能用在windows
8及更高系统版本上并不意味着这些版本不能被攻破，你可以在[github](https://github.com/cbayet/Exploit-CVE-2017-6008)上看到我的exploit源代码，windows 10系统下如何利用类似的漏洞这是 **Nuit du Hack XV**
大会的主题。
**五、参考文献**
****
[1] – Simple ioctl fuzzer
[2] – Defining IOCTL code
[3] – Tarjei Mandt
paper
[4] – Easy local
Windows Kernel exploitation by Cesar Cerrudo.
[5][https://recon.cx/2013/slides/Recon2013-Alex%20Ionescu-I%20got%2099%20problems%20but%20a%20kernel%20pointer%20ain't%20one.pdf](https://recon.cx/2013/slides/Recon2013-Alex%20Ionescu-I%20got%2099%20problems%20but%20a%20kernel%20pointer%20ain%E2%80%99t%20one.pdf)—
Leaking Kernel Addresses
[6] – This extension is great for
investigating the pool state
[7] – Source code of the
exploit