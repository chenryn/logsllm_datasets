title:Lurking in the Shadows: Identifying Systemic Threats to Kernel Data
author:Arati Baliga and
Pandurang Kamat and
Liviu Iftode
Lurking in the Shadows: Identifying Systemic Threats
to Kernel Data (Short Paper)
Department of Computer Science, Rutgers University
Arati Baliga, Pandurang Kamat and Liviu Iftode
Email: {aratib, pkamat, iftode}@cs.rutgers.edu
Abstract
The integrity of kernel code and data is fundamental to
the integrity of the computer system. Tampering with the
kernel data is an attractive venue for rootkit writers since
malicious modiﬁcations in the kernel are harder to identify
compared to their user-level counterparts. So far however,
the pattern followed for tampering is limited to hiding ma-
licious objects in user-space. This involves manipulating a
subset of kernel data structures that are related to intercept-
ing user requests or affecting the user’s view of the system.
Hence, defense techniques are built around detecting such
hiding behavior. The contribution of this paper is to demon-
strate a new class of stealthy attacks that only exist in kernel
space and do not employ any hiding techniques tradition-
ally used by rootkits. These attacks are stealthy because the
damage done to the system is not apparent to the user or
intrusion detection systems installed on the system and are
symbolic of a more systemic problem present throughout the
kernel. Our goal in building these attack prototypes was
to show that such attacks are not only realistic, but worse;
they cannot be detected by the current generation of kernel
integrity monitors, without prior knowledge of the attack
signature.
1. Introduction
Integrity of the operating system kernel is critical to the
security and integrity of a computer system. Tampering
with the kernel is traditionally performed by malware called
rootkits. The attacker uses a rootkit to hide his presence on
the compromised system. Other forms of malware such as
worms, viruses and spyware successfully evade detection
from the anti-virus software running on the system when
bundled with a rootkit. Sophisticated rootkits achieve this
hiding behavior by tampering with the kernel data. This
may involve process hiding or hiding objects by tampering
with the jump tables or ﬁle system handlers.
The challenge for the user and the intrusion detection
system (IDS) is to detect the fact that the system is com-
promised as soon as the attack happens. The rootkit on the
other hand, tries to hide this fact from the user for as long
as possible. At this point, the attacker already has obtained
root control on the system. While he has the ability to per-
form visibly damaging actions such as erase all ﬁles on the
ﬁle system or reboot the system to install a new kernel im-
age, these actions conﬂict with his goals of hiding his pres-
ence to retain long term control. Radical actions taken by
the attacker are quickly detected with very high probability
and the attacker loses control of the system as a result.
Monitoring the integrity of the kernel is achieved by iso-
lating the detector from the system under surveillance. The
detector either resides on a secure co-processor [18, 7] or
uses virtual machine introspection [5]. While the mech-
anisms for kernel integrity monitoring have been success-
fully designed, the policies pertaining to the data that is to
be monitored needs to be inferred manually from known
rootkit behaviors. This is an uphill battle, similar to the one
faced by anti-virus software, where traditionally attackers
hold an edge over defenders.
Petroni et al [8] developed such a speciﬁcation archi-
tecture to manually specify constraints on kernel data and
monitor for violations. While this architecture allows the
speciﬁcation of known attack proﬁles, newer and unknown
attacks, which target data structures that are not monitored
or attack monitored data structures in a different manner,
escape detection. Besides being an external asynchronous
monitor, it often ﬁnds data structures in an inconsistent
state, which limits it’s scalability and ultimately, the fea-
sibility of such a solution. A methodology to comprehen-
sively protect the integrity of all data structures in the kernel
is still a topic of active research.
The only form of kernel data tampering performed by
rootkits pertains to hiding the malicious objects. Such ob-
ject hiding deceives the user into believing that he has a
clean system. Very early rootkits achieved this goal by in-
stalling TROJANED system binaries and shared libraries
that provided doctored responses. As ﬁle integrity tools
such as Tripwire [10] and AIDE [1] were developed, at-
tackers developed methods of intercepting user requests in
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 02:54:06 UTC from IEEE Xplore.  Restrictions apply. 
2007 IEEE Symposium on Security and Privacy(SP'07)0-7695-2848-1/07 $20.00  © 2007PRE-ROUTING
PRE-ROUTING
FORWARD
FORWARD
POST-ROUTING
POST-ROUTING
2. Attacks
INPUT
INPUT
OUTPUT
OUTPUT
To Processes
To Processes
From Processes
From Processes
Figure 1. Hooks provided by the Linux netﬁl-
ter framework
the kernel. This was achieved by hooking into the system
call table and the interrupt descriptor table (IDT). Sophis-
ticated rootkits modiﬁed machine instructions in the ker-
nel code, which could redirect control to their own system
call table without modifying the original one. As kernel
integrity monitors started to monitor these immutable data
tables, rootkits found ways of hiding by modifying the ﬁle
system operation handlers and by exploiting discrepancies
in the lists used by the scheduler and the process accounting
data structures within the kernel.
While the data structures that are tampered have changed
over the years, the intent of tampering is still the same,
namely to hide the malicious ﬁles, process and network con-
nections. Hence, the data structures tampered are all related
to intercepting user-level requests and providing doctored
responses or more generally, affecting the users view of the
system. These rootkit attacks can be full detected if all hid-
ing techniques can be completely explored. In fact, tools
such as Strider Ghostbuster [4] detect the presence of rootk-
its, merely from their attempt to hide.
In this paper, we demonstrate a new class of stealthy at-
tacks that do not try to hide but still evade detection from
current generation of integrity monitors. These attacks are
symbolic of a larger systemic problem that needs compre-
hensive analysis. We also present a classiﬁcation of kernel
data tampering methods based on techniques that we have
designed as well as those already known. To the best of
our knowledge, this is the ﬁrst paper that presents this new
class of attacks on kernel data and provides a classiﬁcation
of the techniques used, which is a step towards developing
a comprehensive solution.
Chain INPUT (policy ACCEPT)
target prot opt source
ACCEPT tcp --
ACCEPT tcp --
ACCEPT tcp --
REJECT tcp --
destination
anywhere anywhere tcp dpt:ssh
anywhere anywhere tcp dpt:telnet
anywhere anywhere tcp dpt:24
anywhere anywhere tcp dpt:http reject-with
icmp-port-unreachable
Chain FORWARD (policy ACCEPT)
target
prot opt source
destination
Chain OUTPUT (policy ACCEPT)
target
prot opt source
destination
Figure 2. Firewall rules deny admission to
web server port
In this section, we present four stealth attacks that solely
change kernel data but do not exhibit hiding behavior. None
of these attacks can be detected by the currently known in-
tegrity monitoring approaches without prior knowledge of
the attack signatures.
2.1. Disable Firewall
This attack hooks into the netﬁlter framework of the
Linux kernel and stealthily disables the ﬁrewall installed
on the system. The user cannot determine this fact by in-
specting the system using iptables. The rules still appear
to be valid and the ﬁrewall appears to be in effect. In de-
signing this attack, the goal of the attacker is to disable the
network defense mechanisms employed by the target sys-
tems, thereby making them vulnerable to other attacks over
the network.
Background: Netﬁlter is a packet ﬁltering framework
in the Linux kernel. It provides hooks at different points in
the networking stack. This was designed for kernel mod-
ules to hook into and provide different functionality such
as packet ﬁltering, packet mangling and network address
translation. These hooks are provided for each protocol sup-
ported by the system. The netﬁlter hooks for the IP proto-
col are shown in Figure 1. Each of the hooks, Pre-routing,
Input, Forward, Output and Post-routing, are hooks at dif-
ferent points in the packets traversal. Iptables is a ﬁrewall
management command line tool available on Linux. Ipta-
bles can be used to set the ﬁrewall rules for incoming and
outgoing packets. Iptables uses the netﬁlter framework to
enforce the ﬁrewall rules. Packets are ﬁltered according to
the rules provided by the ﬁrewall.
Attack Description: The pointers to the netﬁlter hooks
are stored in a global table called nf hooks. This is an ar-
ray of pointers that point to the handlers registered by ker-
nel modules to handle different protocol hooks. This data
structure is exported even by the latest 2.6 Linux kernel.
We modiﬁed the hook corresponding to the IP protocol and
redirected it to our dummy code, effectively disabling the
ﬁrewall. The ﬁrewall rules that we used during this exper-
iment are shown in Figure 2. The INPUT rules deny ad-
mission for incoming trafﬁc to the web server running on
the system. Before the attack, we were unable to access this
web server externally. After we inserted the attack module,
we could access the web content hosted by the web server
running on http port (port 80). Running iptables command
to list the ﬁrewall rules still shows that the same rules are
in effect (as shown in Figure 2). The user has no way of
knowing that the ﬁrewall is disabled as the rules appear to
be in effect.
Impact: A stealthy attack such as the one described can-
not be detected by the existing set of tools. Since our attack
module is able to ﬁlter all packets without passing it to the
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 02:54:06 UTC from IEEE Xplore.  Restrictions apply. 
2007 IEEE Symposium on Security and Privacy(SP'07)0-7695-2848-1/07 $20.00  © 2007 
s
e
g
a
p
e
e
r
f
f
o
#
222000
220000
218000
216000
214000
212000
210000
208000
kswapd woken
up
allocator frees
memory synchronously
time
pages_high
pages_low
pages_min
Figure 3. Kernel Memory Allocation: Zone
balancing logic and usage of zone water-
marks
ﬁrewall, it can run other commands upon receipt of a spe-
cially crafted packet sent by the remote attacker.
2.2. Resource wastage attack
This attack causes resource wastage and performance
degradation on applications by generating artiﬁcial memory
pressure. The goal of this attack is to show that it is possi-
ble to stealthily inﬂuence the kernel algorithms by simply
manipulating data values. This attack targets the zone bal-
ancing logic, which ensures that there are always enough
free pages available in the system memory
Background: Linux divides the total physical mem-
ory installed on a machine into nodes. Each node corre-
sponds to one memory bank. A node is further divided into
three zones: zone dma, zone normal and zone highmem.
Zone dma is the ﬁrst 16MB reserved for direct memory
access (DMA) transfers. Zone normal spans from 16MB
to 896MB. This is the zone that is used by user applica-
tions and dynamic data requests within the kernel. This
zone and zone dma are linearly mapped in the kernel virtual
address space. Zone highmem is memory beyond 896MB.
This zone is not linearly mapped and is used for allocations
that require a large amount of contiguous memory in the
virtual address space.
Each zone is always kept balanced by the kernel memory
allocator called the buddy allocator and the page swapper
kswapd. The balance is achieved using zone watermarks,
which are basically indicators for gauging memory pres-
sure in the particular zone. The zone watermarks have dif-
ferent values for all the three zones. These are initialized
on startup depending on the number of pages present in
the zones. These three watermarks are called pages min,
page low and pages high respectively as shown in Figure
3. When the number of free pages in the zones, drops be-
low pages low pages, kswapd is woken up. kswapd tries
to free pages by swapping unused pages to the swap store.
It continues this process until the number of pages reaches
pages high and then goes back to sleep. When the num-
ber of pages reaches pages min, the buddy allocator tries to
synchronously free pages. Note that sometimes the number
of free pages can go below the pages min, due to atomic
allocations requested by the kernel.
Attack Description: The zone watermarks for each
zone are stored in a global data structure called zone table.
Zone table is an array of zone t data structures that corre-
spond to each zone. Zone watermarks are stored inside this
data structure. This symbol is exported even by the 2.6 ker-
nel. The location of this table can be found by referring to
the System.map ﬁle. We wrote a simple kernel module to
corrupt the zone watermarks for the zone normal memory
zone. The original and new values for these watermarks
are shown in Table 1. We push the pages min and the
pages low watermarks very close to the pages high water-
mark. We also make the pages high watermark very close
to the total number of pages in that zone. This forces the
zone balancing logic to maintain the number of free pages
close to the total number of pages in that zone, essentially
wasting a big chunk of the physical memory. Table 1 shows
that 210065 (820.56 MB) pages are maintained in the free
pool. This attack can be similarly carried out for other zones
as well, wasting almost all memory installed on the system.
The table indicates that only about 60MB is used and the
rest is maintained in the free pool, causing applications to
constantly swap to disk. This attack also imposes a perfor-
mance overhead on applications as shown in Table 2. The
three tasks that we used to measure the performance over-
head are ﬁle copy of a large number of ﬁles, compilation of
the Linux kernel and ﬁle compression of a directory. The ta-
ble shows the time taken when these tasks were carried out
on a clean kernel and after the kernel was tampered. The
performance degradation imposed by this attack is consid-
Watermark
pages min
pages low
pages high
total free pages
Original Value Modiﬁed Value
210000
215000
220000
210065
Total number of pages in zone: 225280
255
510
765
144681
Table 1. Watermark values and free page
count before and after the resource wastage
attack for the normal zone
Application
ﬁle copy
compilation
ﬁle compression
After
Before
Attack Attack
1m, 3s
49s
2m, 56s
2m, 33s
8s
23s
Degradation (%)
28.57
15.03
187.5
Table 2. Performance degradation exhibited
by applications after the resource wastage at-
tack
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 02:54:06 UTC from IEEE Xplore.  Restrictions apply. 
2007 IEEE Symposium on Security and Privacy(SP'07)0-7695-2848-1/07 $20.00  © 2007File #
1
2
3
4
5
6
7
8
9
10
bday
0.765454
0.044118
0.079672
0.009391
0.059726
0.384023
0.002450
0.001195
0.427721
0.654884
operm
0.497607
0.180747
0.999996
0.000334
0.996908
0.975071
0.458676
0.840548
0.553566
0.106287
binrnk6x8
0.197306