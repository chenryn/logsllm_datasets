Android. A likely explanation of this phenomenon could be
because on iOS, the SS-APIs can be accessed more stealthily
compared to on Android, where applications need to list out
the types of SS-APIs they need to access during installation.
The privileges to use these SS-APIs on iOS are granted to
third-party applications as default without users’ awareness,
which gives certain freedom for advertisement and analytic
libraries to access user data and sensitive resources.
To conﬁrm our ﬁndings on the third-party iOS libraries,
we further check each library listed in Table VIII to see
whether it is an open-source library. For the open-source
libraries (e.g., AdWhirl [19]), we manually look into their
source code and conﬁrm all SS-API types that are accessed.
For the closed-source library Flurry, we also ﬁnd evidences
that this library collects the device ID in its ofﬁcial doc-
umentation [20], which mentioned “Because Apple allows
the collection of UDID for the purpose of advertising, we
continue to collect this data as the Flurry SDK includes
AppCircle, Flurry’s mobile advertising solution.”
From the data given in the last column in Table VI,
one can observe that third-party libraries only contribute a
portion of the difference of the SS-API usage for cross-
platform applications; the other part of the difference is
caused by the application’s own code. By removing the SS-
API types that are exclusively caused by third-party libraries,
our static analysis tools manage to output the lists of SS-
API types that are caused by the applications’ own code
on both platforms. The comparison result shows that 3,851
SS-API types are used by 1,300 Android applications in
their own code, while iOS applications use 6,393 – there is
still a signiﬁcant difference for the SS-API usage on the two
platforms. This difference leads us to investigate further into
applications’ code logic to ﬁnd out the underlying reasons.
C. Microanalysis on Application Code Logic
In order to perform a manual analysis on the code logic of
the cross-platform applications, it will be ideal to have full
access to the application source code. However, applications
which are open-source on both platforms are very rare,
given the fact that iOS platform has very little open-source
applications. Nevertheless, we manage to ﬁnd 8 applications
that are open-source on both platforms8. We retrieve the
source code of these applications and analyze the underlying
reasons of their SS-API usage differences. The detailed API
8These 8 open-source applications are WordPress, Mixare, MobileOrg,
andRoc/iRoc, Mp3tunes, ZXing(Barcodes), DiceShaker and MobileSynth.
information collected from closed-source applications is also
utilized to assist
the analysis. According to our manual
inspection, there are at least two factors that have strong
correlations with the SS-API usage differences between iOS
and Android applications.
1) Coding difference: The most natural reason which may
be expected is the implementation difference between the
two versions of cross-platform applications. For example,
ACCESS NETWORK INFO APIs are only used by the iOS ver-
sion of WordPress, but not by its Android version. In its iOS
version, several API calls in WPReachability class are invoked,
which are used to test the reachability to the WordPress
hosts. However, for the Android version of WordPress, there
is no code for testing any reachability. For example, when
posting a blog to the server, the code of Android WordPress
simply checks the return value of the posting function to
see whether the connection is successful or failed. But on
iOS, many Objective-C classes in the WordPress code will
actively check the reachability beforehand, and notify the
users if the network is not reachable. Such implementation
difference leads to the SS-API usage difference that Word-
Press on iOS uses the additional ACCESS NETWORK INFO
APIs compared to its Android version. Similar evidence can
be found in the source code of MobileOrg application.
Such coding difference is also the main reason causing the
difference in using the CAMERA SS-APIs. Taking the popular
applications such as eBuddyMessenger and SmackIt, in their
iOS versions, the user proﬁle photo in the setting can either
be chosen from the pictures stored on device, or by directly
taking the photo with the device’s camera. However, their
Android versions do not provide such photo taking option.
Note that such implementation difference does not only exist
in the applications’ own code, but also for the same third-
party libraries on two platforms. For example, CAMERA SS-
APIs are used by OpenFeint library on iOS, but not by
its Android version, which is caused by the same reason
mentioned above.
2) Intentional avoidance: On the other hand, we also ﬁnd
evidences that even the functionality of the two versions of
cross-platform application are the same, some SS-APIs are
intentionally avoided to be used on Android. We use open-
source application WordPress to explain this phenomenon.
Compared to its Android version, WordPress on iOS uses
the additional READ DEVICE ID APIs. In the WordPress iOS
code, runStats method of WordPressAppDelegate reads the uuid,
os version, app version, language, device model, and then sends
them to http://api.wordpress.org/iphoneapp/update-check/1.0/
to
check whether this application needs to be updated. On the
Android platform, the code of WordPress performs the same
functionality – in the wpAndroid class, uploadStats method tries
to retrieve the same set of data and sends these data back
to WordPress server to check for update. However, there is
one major difference for the WordPress code on Android
compared to the code on iOS. In its iOS code, the uuid is
retrieved by directly calling UIDevice.uniqueIdentiﬁer, which
returns the device unique ID. In contrast, for its Android
version, the uuid used is a random ID which is unique, but
not the real device ID. It is a unique ID that is randomly
generated and stored as the ﬁrst record in WordPress’s own
SQLite database on the Android device. Thus, the different
way of obtaining uuid is the reason that WordPress on iOS
uses the additional READ DEVICE ID SS-API type.
The special way of obtaining the uuid in the Android
version of WordPress makes us speculate that the program-
mers intentionally try to avoid using the READ DEVICE ID
APIs on Android. This is further conﬁrmed by consulting
one of the WordPress developers, who gives the explanation
as: “a random id is better than the device id because it
doesn’t require that permission which reads quite poorly as
‘read phone state and identity’ ”. Thus, the reason that the
developers do not try to avoid using the device ID on iOS
is because of the same reason mentioned in Section VI-B
– on Android, an application needs to show the list of SS-
API types it needs to access to the user during installation;
while on iOS, no such notiﬁcation is given to the user.
We suspect that this may also be the main reason which
causes the difference in accessing SS-API types such as
READ CONTACTS and READ CALENDAR. But unfortunately,
due to the limited access to applications’ source code, we are
not able to get the ground-truth evidence for these SS-API
types, as what has been done for the READ DEVICE ID.
D. The Usage of SS-API Types Unsupported on iOS
Previous analyses focus on the 20 SS-API types that are
both supported on Android and iOS, without taking into
account of the additional 51 SS-API types that are only
supported on Android platform. Thus, the last step of our
analysis is to ﬁnd out how frequently these SS-APIs are
used by those Android applications, and what are usage
characteristics of these SS-APIs.
Taking into account of the 51 SS-API types, our results
show that the 1,300 Android applications use 1,230 SS-API
types in total which are unsupported on iOS. As shown in
Table IX, the most frequently accessed SS-API type that is
unsupported on iOS is WRITE EXTERNAL STORAGE, which is
used by more than half of the Android applications. This can
be explained from the nature of Android devices. Different
from iOS devices which have 8GBytes to 64GBytes of
internal storage, Android devices usually have less internal
storage. Thus, all Android devices support external storage
such as microSD card. As a result, Android applications
which want
to store their application data usually need
to utilize WRITE EXTERNAL STORAGE APIs to write to the
microSD card, in order to save the internal storage space.
Except WRITE EXTERNAL STORAGE, the remaining 50 SS-
API types that are not supported on iOS are used infre-
quently (only 468 in total, which is 0.36 per application on
average). Such a result shows that the 20 SS-API types both
THE USAGE OF SS-API TYPES UNSUPPORTED ON IOS (TOP 8)
Table IX
SS-API types unsupported on iOS
WRITE EXTERNAL STORAGE
GET ACCOUNTS
RECEIVE BOOT COMPLETED
GET TASKS
CHANGE WIFI STATE
READ LOGS
RECEIVE SMS
READ HISTORY BOOKMARKS
# of Android Apps
762
133
55
45
44
15
13
11
supported on iOS and Android are the most commonly used
SS-APIs for third-party applications. Note that although the
SS-API types only supported on Android are not commonly
used in popular Android applications, they may bring serious
security breaches when utilized by malicious applications.
For example, the READ LOGS privilege, which allows a third-
party application to “read the low-level system log ﬁles” can
be utilized to read many other sensitive data such as SMS,
contacts and location information as demonstrated in [21].
On the other hand, iOS also has its own speciﬁc SS-APIs
that do not exist on Android. For example, two services,
iCloud storage and push notiﬁcation, which are controlled by
entitlements are speciﬁc to the iOS platform. However, since
the focus of this paper is on the SS-API types supported
on both platforms, investigating the SS-APIs that are only
supported on iOS is left as future work.
VII. DISCUSSION AND LIMITATIONS
We remark that our comparison analysis framework is
still in its preliminary stage. One limitation of the current
framework is the completeness of iOS SS-APIs. Although
we tried our best to search for all the related API calls on iOS
that lead to a corresponding SS-API type, it is very difﬁcult
to test the thoroughness of the obtained SS-API set. We
may still miss some API calls that belong to certain SS-API
types. However, this limitation only indicates that the list of
SS-API types for a given iOS application produced by our
static analysis tool is a lower bound on the actual list of SS-
API types this application uses. Even the number of SS-API
types used by iOS applications might be underestimated, it
is still much larger than the number of SS-API types used
by Android applications. Thus, this limitation will not affect
the conclusion drawn from our analysis.
Another limitation that has not been addressed during the
analysis is the dead code issue – though some SS-APIs exist
in the application binaries, they may not be executed during
run-time. Detecting unreachable code statically involves
performing complex control ﬂow analysis to locate the code
regions that will never be executed, which has not been
adopted in our static analysis tools. However, even some
SS-API calls in the binaries will not be executed, they may
still bring potential security risks (e.g., they can be utilized
by return-to-libc or return-oriented programming [22], [23]
to launch attacks).
An important assumption is used in our analysis when
comparing iOS version and Android version of the cross-
platform applications. We assume these two versions should
ask for similar privileges and should have similar func-
tionality. There could be cases that
the developers ﬁrst
implemented a full-functioned version on one platform and
are just in the process of integrating new functionality into
the version on the other platform. However, we believe
that this assumption holds when it is considered in a large
scale context. But as the whole analysis process is not
fully automated (the application downloading and cracking
is a half-manual process), and also due to the relatively
slow speed for iOS application analysis (which takes several
minutes to several hours for each application depending on
the complexity of the binary), we limit our current analysis
to those 2,600 applications instead of the entire set of
cross-platform applications. In addition, as a complement
to the comparisons conducted on free applications, we also
perform the analysis on 200 popular paid applications.
The results are given in Appendix C, which are consistent
with our main ﬁndings on free applications. Note that our
sampling towards popular applications (both free and paid)
may introduce bias if the results are used as an estimation on
the whole third-party applications. However, due to limited
resources, this work focuses on popular applications, which
have more impact on the privacy of end-users.
In order to examine the accuracy of our ﬁndings, ground
truth needs to be obtained for every application tested,
which is an impossible task without the application’s source
code. However, we tried our best to discover the under-
lying ground truth by investigating the visible differences
on closed-source applications and libraries; by obtaining
and examining the source code of available open-source
applications; and by consulting some application developers
on our ﬁndings. Although it is not possible to verify the
result of every cross-platform application, we believe that
the statistical difference in our ﬁndings has revealed the
tendency of iOS third-party applications which turn to access
more SS-APIs compared to applications on Android.
The immediate implication of such ﬁndings is that user-
s on iOS may have higher risks of privacy leakage in
comparison to Android. However, the occurrence of the
actual privacy leakage for a particular user depends on many
factors, including which applications this user installs, and
whether the applications or libraries send the private data out
at runtime. Thus, our ﬁndings do not necessarily imply that
Android has a better privacy protection compared to iOS,
given the fact that iOS restricts certain privileges to third-
party applications (as shown in Section IV) and also previ-
ous research works [24], [25] have shown that third-party
applications on Android could gain additional privileges by
launching privilege-escalation attacks. However, our ﬁndings
have shown a strong correlation between the SS-API usage
difference and the lack of an explicit privilege-list mech-
anism on iOS, which implies that Apple’s vetting process
may not be as effective as Android’s privilege notiﬁcation
mechanism, particularly in the aspect of restricting SS-API
usage by application developers.
VIII. RELATED WORK
Previous studies focus on either Android or iOS platform
alone. Enck et al. [26] examine Android security policies
and some of the developer pitfalls. They further investigate
the source code of a thousand Android applications [27],
which reveals a number of interesting ﬁndings for Android
application security, some of which are also conﬁrmed
by our results on Android. A large-scale evaluation for
Android applications is performed by Zhou et al. [28], which
reveals hundreds of malicious Android applications. Yan and
Yin [29] provide analysis tools to reconstruct the OS and
Dalvik semantics for malware analysis.
From the attacker’s perspective, Felt et al. [24] demon-
strate that a less privileged Android application is able
to perform a privileged task through another third-party
application with higher privilege. A similar privilege es-
calation attack which is implemented with return-oriented
programming is introduced by Davi et al. [23]. The defense
mechanism for such privilege escalation attack is proposed
by Bugiel et al. [25].
There are also a number of research works focusing on
analyzing and improving the Android permission model.
Barrera et al. [30] present a methodology for the empirical
analysis of permission-based security models, and apply
it to Android permission model. In addition, Ongtang et
al. [31] present a ﬁne-grained access control policy infras-
tructure for protecting applications on Android. Hornyack
et al. [32] also present two privacy controls to protect user
data from exﬁltration by permission-hungry applications.
Grace et al. [33] systematically analyze several Android
smartphone images and found they do not properly enforce
the Android permission model. Xu et al. [34] propose a user-
level sandbox to enforce ﬂexible permission control without
modifying the Android OS. Shekhar et al. [35] and Pearce
et al. [36] provide speciﬁc techniques to separate permission
usage of advertising libraries and hosting applications.
Felt et al. [5] study Android applications to determine
whether Android developers follow least privilege with their
permission requests. They developed a static analysis tool
Stowaway that detects overprivilege in Android applications.
They also create an Android API-to-permission mapping
using dynamic testing, and this mapping is used as one of
the inputs in our Android static analysis tool. This mapping
could also be used in the permission check tool introduced
by Vidas et al. [37], which aids developers in specifying a
minimum set of permissions required for a given Android
application with source code.
In comparison to the literature on Android,
TaintDroid developed by Enck et al. [38] provides a
system-wide dynamic taint tracking for Android, which can
be used to monitor the realtime behavior of third-party
Android applications. On the other hand, static analysis
tools such as ScanDroid [39] and ComDroid [40] are also
developed to identify Android application vulnerabilities,
with additional consideration on action-based vulnerabilities.
there are
relatively less studies on iOS platform. Seriot [41] demon-
strated that any applications downloaded from iTunes Store
can access a signiﬁcant quantity of personal data. Egele
et al. [16] study the privacy threats that third-party iOS
applications pose to users. They present a static analysis tool
that analyzes programs for possible sensitive information
leakage. Our iOS static analysis tool adopts a similar mech-
anism in resolving objc msgSend as their tool, but with a
different emphasis on resolving the API calls and parameters
that are related to SS-APIs.
To our best knowledge, there is no literature to date that
systematically compares the application security of Android
and iOS platforms. This paper is the ﬁrst work that estab-
lishes the baseline of examining the massive cross-platform
applications to compare the effect of security mechanism
utilized by Android and iOS, which reveals interesting
behavioral differences for the third-party applications on
these two platforms. We notice that a recent work by
Pearce et al. [36] also identiﬁes the overprivileging problem
caused by advertising libraries on Android platform. Our
work further discovers this problem on iOS platform and
ﬁnds that an iOS application tends to use more SS-APIs
compared to its Android counterpart even after excluding
SS-API invocations by advertising libraries, which has not
been investigated in existing works.
IX. CONCLUSION
In this paper, we made the ﬁrst attempt towards system-
atically comparing mobile application security on diverse
mobile platforms. In particular, the two most popular mobile
platforms, Android and iOS, are chosen to investigate how
the platform difference inﬂuences third-party applications in
terms of privacy protection. As a prerequisite, we investigat-
ed the security-sensitive API (SS-API) types supported on
iOS and their relations to Android application privileges,
which were previously unclear. We then built our static
analysis tools to perform massive static analysis for cross-
platform applications on their SS-API usage.
Our analysis showed that applications on iOS tend to use
more SS-APIs compared to their counterparts on Android,
and are more likely to access sensitive resources that may
cause privacy breaches or security risks without being no-
ticed. Further investigation revealed a strong correlation be-
tween such difference and the lack of application privilege-
list on the current iOS platform. Such results may imply
that Apple’s vetting process is not as effective as Android’s
explicit privilege list mechanism in restricting the privilege
usage by third-party application developers.
REFERENCES