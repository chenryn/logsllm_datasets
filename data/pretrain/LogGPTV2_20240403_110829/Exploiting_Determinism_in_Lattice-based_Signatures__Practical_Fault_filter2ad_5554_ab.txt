(cid:16)
(cid:17)
signing procedure in Algorithm 1, while we present its respective
key-generation and verification procedures in Algorithm 5 in the
Appendix A. For more information on the scheme, please refer [19].
q
Key Generation: The key generation algorithm, KeyGen(), gen-
erates the public constant a ∈ Rk×ℓ
by expanding a given seed
ρ←{0, 1}256 such that a = ExpandA(ρ). Next, the secret module
s1 ∈ S ℓ
η and the error module s2 ∈ Sk
η are sampled after which the
MLWE instance t ∈ Rk
q is computed as t = a · s1 + s2. The LWE
instance is not directly output as the public key but is decomposed
into t0, t1 such that t1 = HBq (t, 2d ) and t0 = LBq (t, 2d ). Subse-
quently, t1 is published as part of the public key while t0 is kept
secret. Subsequently, the published public key is (ρ, t1) while the
secret key sk is (ρ, K, tr , s1, s2, t0).
Signing: The signing procedure is iterative in nature with a number
of conditional checks and it exits with a valid signature only when
all the conditional checks are successfully passed. This is done to
primarily ensure that the output signatures do not leak the distri-
bution of the secret key. Moreover, these selective rejections in the
signing procedure are also performed to ensure 100% correctness
of the signature scheme.
Similar to the DSA and ECDSA signature schemes, the most
important component of the signing procedure in case of Dilithium
(apart from the secret key) is the ephemeral nonce y ∈ Rℓ
q. Knowl-
edge of a single value of y or reuse of y for different messages leads
to a trivial break of the signature scheme. Moreover, the method
of generation of the ephemeral nonce y also determines the deter-
ministic nature of the signature scheme. In Dilithium, y ∈ S ℓ
η is
deterministically generated using the ExpandMask function which
takes as input, the message µ to be signed, the secret key component
K and the iteration count (Line 6 of Sign in Algorithm 1). Further,
the product w = a · y ∈ Rk
q is computed and decomposed into w1
and w0 such that w = w1·2γ2 +w0. The signing procedure requires
the verifier to recover the value of w1 for successful signature verifi-
cation. To facilitate the same, a hint vector h ∈ Rk
q with coefficients
in {0, 1} is also generated and output as part of the signature. Fur-
thermore, a challenge polynomial c (sparse polynomial with only
60 non-zero coefficients in either ±1) is also generated by hashing
the ephemeral nonce along with the public key information and
the message. The product cs1 is computed which is subsequently
masked with the ephemeral nonce y through addition and the re-
sult is output as the primary signature component z ∈ Rℓ
q (Line
10 of Sign in Figure 1). The details of the verification procedure
of Dilithium are provided for completeness in Algorithm 5. It is
important to note that all attacks presented on the deterministic
variant of Dilithium can also be easily adopted to the deterministic
variant of qTESLA1. A detailed description of the qTESLA signa-
ture scheme along with the note on applicability of our attacks are
deferred to the Appendix B.
3 MOTIVATION
In this section, we motivate our work by reviewing existing fault at-
tacks on lattice-based signature schemes based on the “Fiat-Shamir
with Aborts” framework. We observe that the generation of the
primary signature component z has been the target of most of the
Session 5B: Fault Attacks and Side Channel AnalysisAsiaCCS ’19, July 9–12, 2019, Auckland, New Zealand429Algorithm 1: Dilithium Signature scheme
1 Procedure Sign(sk, M)
2
:= ExpandA(ρ)
q
A ∈ Rk×ℓ
µ = CRH(tr∥M )
κ = 0, (z, h) = ⊥
while (z, h) = ⊥ do
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
γ1−1 := ExpandMask(K∥µ∥κ)
y ∈ S ℓ
w = A · y
w1 = HBq (w, 2γ2)
c ∈ B60 = H (µ∥w1)
z = y + c · s1
(r1, r0) := Dq (w − c · s2, 2γ2)
if ∥z∥∞ ≥ γ1 − β or ∥r0∥∞ ≥ γ2 − β or r1 (cid:44) w1 then
else
(z, h) = ⊥
h = MHq (−c · t0, w − c · s2 + c · t0, 2γ2)
if ∥c · t0∥∞ ≥ γ2 or wt(h) > ω then
(z, h) = ⊥
end
κ = κ + 1
end
return σ = (z, h, c)
reported attacks. Generation of z is done as follows:
z = s1 · c + y
(2)
We will henceforth refer to this step as zgen. We also refer to s1
alternatively as the primary secret of Dilithium as we will show later
in this work that knowledge of s1 is enough to perform an existential
forgery attack on Dilithium. While both z and c are revealed as part
of the signature, y is the ephemeral masking polynomial used to
mask the product s1 · c. Injection of faults in any of the operations
within zgen helps the attacker derive a direct relation of the faulted
signature ˆz with the primary secret s1, thus naturally becoming a
target of most of the previously reported attacks [8, 11, 13].
3.1 Note on Skipping fault attacks
Bindel et al. [8] proposed skipping fault attacks targeting the addi-
tion operation within zgen, over a number of non-deterministic Fiat-
Shamir abort based signature schemes such as GLP [16], BLISS [12],
and Ring-TESLA [1]. They proposed to completely skip the addition
operation for all the n coefficients thereby yielding either z = s1 · c
or z = y, depending on the order of operands for addition. While
successful faults in the first case (z = s1c) directly yields the primary
secret s1, the attack does not work in the latter case (z = y) since
no information on the primary secret is revealed, also because the
attacker cannot use the same y to generate another valid signature
due to their non-deterministic nature. Thus, switching the order
of operands was proposed as a potential countermeasure against
skip-addition faults. The authors also proposed to store the result
of addition in a variable different from the operands as another po-
tential countermeasure against such skip-addition attacks. But, we
later show that our attack is able to defeat both the aforementioned
countermeasures.
Moreover, there are multiple questionable aspects with respect
to the practicality of Bindel et al.’s [8] skipping fault attack. It re-
quires to inject several hundreds of precisely targeted faults (1024
for recommended parameter sets of Dilithium) within a single run
of the signing procedure. Such a scenario is highly unrealistic in a
practical setting as it requires the attacker to achieve impeccable
precision with respect to all the injected faults, especially when
faults are not realizable with 100% repeatability. Achieving such
faults would require very precise equipments along with high at-
tacker’s expertise. Secondly, the attacker has no apriori knowledge
about the number of iterations of the signing procedure for a given
message m. This makes it impossible if not very difficult to achieve
precise synchronization with the target operation to be faulted.
Thus, these practical aspects which were overlooked make the
skipping attack of Bindel et al. very difficult, if not impossible to
implement in practice.
3.2 Note on Loop Abort fault attacks
Espitau et al. [13] proposed a generic fault attack based on loop
abort faults targeting both Fiat-Shamir Abort and Hash-and-Sign
based signature schemes and later practically validated their at-
tack in an updated work on the 8-bit Atmel XMEGA128 microcon-
troller [15]. It worked by converting the signature component z
(generated using the zgen step) into a solvable closest vector prob-
lem instance when the masking polynomial, y, is limited to low
degrees using loop-abort faults. The basic assumption was that all
the non-sampled coefficients of the masking polynomial (due to
the premature loop abort), would assume zero or a constant value
C. We tried to validate this assumption for our target device (ARM
Cortex-M4F microcontroller) but observed that the non-sampled
coefficients retained random values on the contrary, instead of zero
or a constant value, violating a critical pre-requisite of the attack.
Figure 1 shows the comparison between the observed and expected
values of coefficients of y after sampling 10 coefficients of y. Thus,
the attack proposed by Espitau et al. [15] was not directly applicable
and motivated us to explore other attack settings.
3.3 Implementation Attacks on Lattice-based
signatures
As stated earlier, the deterministic nature of ECC signature schemes,
like ECDSA and EdDSA, were heavily exploited to demonstrate
a number of fault attacks [2, 5]. Thus, one obvious question is
whether such determinism can also be exploited in case of the sim-
ilarly structured lattice-based signature schemes. The first attack
on deterministic lattice-based signatures was proposed by Bruin-
derink and Pessl [11] who developed a differential style fault attack
mainly exploiting the deterministic nature of the Dilithium and
qTESLA signature schemes. The attack only required to inject a
single random fault in the signing procedure and also showed that
injection of such faults over a large section of the execution time of
the signing procedure (∼68%) could result in successful recovery of
the primary secret. They also further propose a forgery algorithm
to forge signatures for any message with only the primary secret3.
3We note that the forgery signing algorithm proposed in this work operates in a
different manner by exploiting the properties of the rounding algorithms of Dilithium.
Session 5B: Fault Attacks and Side Channel AnalysisAsiaCCS ’19, July 9–12, 2019, Auckland, New Zealand430(a) Expected
(b) Observed
Figure 1: Comparison between expected and observed values
of the coefficients of y on our DUT after sampling 10 coeffi-
cients. The blocks colored in green denote the sampled coef-
ficients while those colored in blue denote the non-sampled
coefficients. (a) Expected values for coefficients of y to facil-
itate the loop-abort attack (C denotes a constant value) (b)
Actual values of coefficients of y with random initial values.
The implementation security of lattice-based signature schemes
have also been heavily scrutinized through a number of other side-
channel attack vectors such as power/EM analysis [25], branch-
tracing [14] and cache-timing [10, 26]. Most of these attacks demon-
strated over the predecessor lattice-based schemes such as GLP [16],
BLISS [12], and Ring-TESLA [1] were possible due to vulnerabilities
in efficient implementations of the Gaussian samplers and rejection
sampling procedures. The attacks on the Gaussian samplers and
rejection sampling techniques later prompted the designers of the
newer signature schemes like Dilithium and qTESLA, to instead
sample from uniform distributions during signing. This both sim-
plifies the rejection step in addition to simplifying the sampling
procedure, albeit with the cost of increased size of the signatures.
4 FAULT ATTACK TO RETRIEVE THE
PRIMARY SECRET
Our existential forgery attack on Dilithium consists of two parts.
The first part involves recovery of the primary component of the
secret key s1 using our skip-addition fault attack. Though the secret
key sk of Dilithium consists of multiple other components apart
from the primary secret s1, we propose a novel forgery signing
procedure that can create valid signatures with only the knowledge
of the primary secret thus completing our attack. This section
explains recovery of the primary secret s1 through our skip-addition
fault attack.
4.1 Adversary Model
We assume that the attacker has complete physical access to the
victim device during computation of the signing procedure. The
attacker should also be able to trigger the device arbitrarily many
number of times into generating valid signatures for any message
of his/her choice. The attacker should also be able to access the
generated signatures. He/She should be able to actively interfere
with the operation of the signing procedure through fault injection
and passively observe through side-channels such as power/EM.
The underlying fault model we use for our attack is the in-
struction skip fault model. It has been widely studied and prac-
tically demonstrated on a range of devices (AVR and ARM mi-
crocontrollers) with high repeatability to satisfy our attack re-
quirement [28–30]. Instructions skips over load, store, arithmetic
and logical instructions been realized through multiple fault in-
jection methodologies like laser shots [30] and electromagnetic
injection [28, 29] thus serving as a basis for multiple cryptanalytic
efforts.
4.2 Attack Methodology
Our attack mainly works by targeting the zgen operation, specif-
ically by performing skipping faults over the addition operation
within zgen. But, unlike the attack from Bindel et al. [8], which
proposes to fault multiple coefficients in a single run of the signing
procedure, our attack leverages upon the deterministic property
of Dilithium and works by injecting single targeted faults. For the
attack, we will assume that the target is creating P signatures of
the form (z[i][j], c[i]) with i ∈ {1, . . . , P}, while j ∈ {0, . . . , ℓ − 1}
denotes the individual polynomials within the module z (we ignore
the hint component h of the signature σ since it is not involved in
our target operation, zgen). The signature component z is generated
as follows:
z[i][j] = s1[j] × c[i] + y[i][j]
To simplify notations, we perform our analysis over Eqn.2 (i.e)
z = s1c + y, considering its individual components as polynomials
in Rq, since the polynomials are handled independently of each
other. The attacker faults the addition operation corresponding to
a single coefficient (z)t of z with t ∈ {0, . . . , n − 1}, using single
faults and aggregates information from multiple faulty signatures
obtained by faulting different coefficients to recover the primary
secret s1. We hereby propose two fault attacks based on the order
of the operands in the addition operation.
4.2.1 Case 1. We first consider the zgen step as is present in the
reference implementation of the Dilithium signature scheme sub-
mitted to NIST. The signature component z is generated as follows:
(3)
z = s1 · c
z = z + y
If the addition operation is performed according to Equation 3,
then skipping the addition corresponding to a single coefficient, t,
will result in a scenario where (ˆz)t = (s1c)t . The attacker with the
knowledge of a single coefficient (s1c)t can construct the following
equation:
(4)
Here, the attacker knows coefficient (ˆz)t , of z, and ϵt = Rot(c, t ),
the rotated coefficient vector of challenge c rotated by t times in
an anti-cyclic fashion. Thus, Equation 4 is nothing but a modular
linear equation with n unknowns, with the unknowns being the
coefficients (s)t of the primary secret for t ∈ {0, . . . , n − 1}.
(ˆz)t = ⟨s1, Rot(c, t )⟩