### Selective Witness Group and Gossip Communication

In contrast to gossip, which offers retroactive protection contingent on active communication within an entirely open group of participants, the witness group in our system is somewhat selective. 

### Design Variations and Tradeoffs

While the basic CoSi design described above is expected to be both usable and suitable in many contexts, as suggested by the evaluation in Section VI, there are numerous potential improvements and design variations that embody different strengths and weaknesses. In this section, we briefly explore some of these design options, focusing on signature verification predicates, reducing the size of the certificates needed for verifying collective signatures, and tolerating unreliability in the network and/or witnesses.

#### A. Collective Signature Verification Predicates

CoSi signatures explicitly document which witnesses did and did not participate in the signing process. This allows for more flexible signature verification, which can be based on arbitrary predicates rather than a simple threshold. For example, if the authority has varying levels of trust in different witnesses, it can weight their contributions such that some witnesses count more than others toward the threshold. To save space, the authority can also treat itself as a special "witness," aggregating its own signature with those of the other witnesses, but requiring its participation for the collective signature to be valid.

Witnesses can be divided into multiple groups with hierarchical relationships. For instance, a global body of witnesses might be divided into geopolitical regions (e.g., Five Eyes, Europe, etc.), each with different witness group sizes and thresholds. The collective signature would then require a threshold number of regions to meet their respective internal thresholds. This structure can protect the authority and its users from compromise or denial-of-service even if some regions contain many more witnesses than others and all witnesses in any sub-threshold set of regions collude.

Finally, collective signature verification can use different predicates depending on the context. For example, a device manufacturer concerned about government coercion to produce backdoored operating system updates [48], [57] could design its devices to demand a high cosigning threshold (e.g., half) when verifying updates downloaded automatically or installed while the device is locked. However, it could allow updates with few or no cosignatures if the user manually initiates the update with the device unlocked. This fallback mechanism deters deliberate misbehavior by witnesses, as it presents only a minor inconvenience to the manufacturer's users while likely resulting in public scandal and legal action against the misbehaving witnesses.

#### B. Reducing Authority Certificate Size with Key Trees

The basic CoSi design keeps collective signatures compact but requires the authority’s well-known certificate to include not just the authority’s public key but also a complete list of the authority’s witnesses and their public keys. This large certificate size is acceptable if it is distributed as part of a larger package, such as being embedded in a web browser’s root certificate store. However, in other contexts, such as embedding in intermediate certificates, DNSSEC [6] resource records, or frequently transmitted objects, large certificates can be problematic.

An alternative design involves the authority’s certificate including only the authority’s public key, the product of all witnesses’ public keys \( \hat{X} = \prod_i X_i \), and a hash representing the root of a key tree: a Merkle tree [91] whose leaf nodes contain the individual witnesses’ public keys. The key tree hash in the authority’s certificate represents a universally-verifiable commitment to all witnesses’ public keys without actually containing them.

During subsequent signing rounds, the CoSi leader includes in each signature a list of the public keys of all missing or present witnesses, whichever is shorter, along with Merkle inclusion proofs for each proving their presence in the authority’s key tree. To check a signature containing a list of present witnesses, the verifier simply multiplies the listed public keys (after verifying their inclusion proofs). To check a signature containing a list of missing witnesses, the verifier multiplies the aggregate \( \hat{X} \) of all witnesses’ public keys with the inverses of the missing witnesses’ public keys: \( \hat{X} \cdot \prod_{j \in L} X_j^{-1} = \hat{X} \).

In the common case where all witnesses are present during signing, the signature is at minimum size, containing only \( (c, \hat{r}_0) \) and an empty list of missing witnesses. As more witnesses go missing, the size of the signature, including witness public keys and inclusion proofs, may grow to \( O(N) \) or potentially even \( O(N \log N) \) if each missing witness’s inclusion proof is stored separately without sharing the storage of internal key tree nodes.

#### C. Gracefully Tolerating Network Unreliability

While authorities adopting CoSi are expected to choose reliable witness servers run by reputable organizations, neither the authority nor its witnesses can control the Internet connections between them. CoSi allows the authority to rebuild its communication trees at any time to route around link failures, but if network churn is too frequent or severe, a tree might become unusable before it can be used even once.

One attractive solution is to adopt the binomial swap forest technique of San Fermín [30], which is readily applicable to CoSi. We first assign all witnesses b-bit binary labels. Each of CoSi’s aggregation rounds—i.e., its Commit and Response phases—is then implemented with a single run of San Fermín’s dynamic aggregation protocol. To aggregate commits or responses, each node communicates with b other nodes in succession, building up its own aggregate while simultaneously helping other nodes build theirs, such that every participant ends up obtaining a complete aggregate.

At each swap step i from 0 to b − 1, each witness j communicates with another witness k whose label differs at bit i but is identical in all more-significant bits. At step 0, each even-numbered node swaps with its immediate odd-numbered neighbor. During subsequent steps, each witness has a choice of witnesses to swap with: e.g., in step 1, a node labeled xx00 may swap with either xx10 or xx11. In these swaps, each witness combines the other witness’s aggregate value from prior steps into its own aggregate, enabling both communication partners to double the “coverage” of their respective aggregates in each step until every witness has a complete aggregate. The authority can then pick up this complete aggregate from any witness server.

Because each witness can dynamically choose its communication partners in steps i > 0, witnesses can adapt immediately to intermittent link failures without restarting the overall aggregation process, provided the witnesses themselves do not fail. Tolerating high churn in the witnesses as well as the network requires other techniques explored below.

#### D. Avoiding Signing Restarts on Witness Unreachability

A second-order availability risk in the basic CoSi design is that multiple witnesses might become unavailable during a single signing round, possibly as part of a DoS attack by malicious witnesses, forcing the leader to restart the signing round multiple times in succession without making progress. To address this risk, we prefer that the leader can always complete each signing round and never have to restart, regardless of the witnesses’ behavior.

If during CoSi’s Commit phase, some witness i finds one of its immediate children j ∈ Ci unresponsive, i can adjust its aggregate commit \( \hat{V}_i \) to include only its own individual commit \( V_i \) and the aggregate commits of its reachable children, and pass the adjusted \( \hat{V}_i \) to i’s parent along with a list of unreachable witnesses. The signing round can thus immediately take the missing witnesses into account and continue without restarting. If a missing witness j is an interior node in the spanning tree, then its parent i (or the leader) can attempt to “bridge the gap” by contacting j’s children directly to collect their portions of the aggregate commitment (and their corresponding portions of the aggregate response later in phase 4). Thus, the loss of an interior node in the spanning tree need not entail the loss of its descendants’ cosignatures.

A more subtle challenge occurs when some witness j participates in the Commit phase but goes offline before the subsequent Response phase. In this case, the missing witness’s individual Schnorr commit \( V_j \) has been included in the aggregate commit \( \hat{V}_0 \) and used to form the collective challenge \( c = H(\hat{V}_0 \| S) \) with which all witnesses must compute their collective responses. It is now too late to change \( c \), but without witness j, the remaining witnesses will be unable to produce an aggregate response \( \hat{r}_0 \) matching the aggregate commit \( \hat{V}_0 \) that included \( V_j \). Breaking the dependency of \( c \) on \( \hat{V}_0 \)—allowing the latter to change in the Response phase without recomputing \( c \)—would make the collective signature trivially forgeable.

We can resolve this dilemma by making the collective challenge \( c \) depend not on just a single aggregate commit \( \hat{V}_0 \) of individual commits \( \hat{V}_i \) but on all possible aggregate commits \( \hat{V}_W \) representing any subset of the witnesses W that participated in the Commit phase. During the Commit phase, these witnesses no longer merely aggregate their individual Schnorr commits but also include them in a Merkle tree summarizing all individual commits. Each interior witness i obtains from each of its children j ∈ Ci both j’s aggregate commit \( \hat{V}_j \) and the hash \( H_j \) representing a partial Merkle tree summarizing all the individual commits of j’s descendants. Then i computes its aggregate as before, \( \hat{V}_i = V_i \cdot \prod_{j \in C_i} \hat{V}_j \), but also produces a larger Merkle commit tree whose hash \( H_i \) contains both \( V_i \) as a direct leaf and all of i’s childrens’ Merkle commit trees \( H_j \in C_i \) as subtrees. The leader in this way obtains a root hash \( H_0 \) summarizing all witnesses’ individual commitments, and computes the collective challenge to depend on the root of this commit tree, \( c = H(\hat{V}_0 \| H_0 \| S) \).

Now, in the common case that all witnesses present in the Commit phase remain online through the Response phase, the witnesses produce an aggregate response \( \hat{r}_0 \) as before, which matches the complete aggregate commit \( \hat{V}_0 \) appearing directly in the challenge. If witnesses disappear after the Commit phase, however, the leader includes in its signature the individual commits of the missing witnesses, together with Merkle inclusion proofs demonstrating that those individual commits were fixed before the collective challenge \( c \) was computed. The verifier then multiplies the aggregate commit \( \hat{V}_0 \) with the inverses of the individual commits of the missing witnesses, to produce an adjusted aggregate commit \( \hat{V}'_0 \) and corresponding aggregate response \( \hat{r}'_0 \).

#### E. Extreme Witness Churn and Asynchronous Networks

Schnorr signatures are well-established and compatible with current best practices for standard digital signatures, but their Σ-protocol nature (commit, challenge, response) requires two communication round-trips through a distributed structure—whether a simple tree or a binomial swap forest—to aggregate a collective signature. This requirement can be limiting in highly unstable or asynchronous situations where any distributed structure built in the first round-trip might become unusable before the second.

BLS signatures [19] may offer an appealing alternative cryptographic foundation for CoSi, requiring pairing-based elliptic curves but avoiding the need for two communication round-trips. In short, a BLS public key is \( G^x \) as usual, but a BLS signature is simply \( H(M)^x \), where \( H(M) \) is a hash function mapping the message M to a pseudorandom point on the appropriate curve. Signature verification uses the pairing operation to check that the same private key \( x \) was used in the public key and the signature. BLS extends readily to multisignatures, as an aggregate signature \( H(M)^{x_1 + ... + x_n} \) is simply the product of individual signatures \( \prod_{i=1}^n H(M)^{x_i} \) and is verifiable against an aggregate public key \( G^{x_1 + ... + x_n} \) computed in the same fashion as \( \prod_{i=1}^n G^{x_i} \).

Using BLS instead of Schnorr signatures, an authority can produce a collective signature in a single round-trip through a tree or binomial swap forest (Section IV-C), eliminating the risk of a witness participating in the commit phase but disappearing before the response phase (Section IV-D). Furthermore, BLS signatures may make CoSi usable in protocols designed for asynchronous networks [25], [26], [109] by allowing participants to aggregate signatures incrementally and make use of them as soon as an appropriate threshold is reached: e.g., typically \( f + 1 \) or \( 2f + 1 \) in asynchronous Byzantine consensus protocols tolerating up to \( f \) faulty participants.

One key challenge in fully asynchronous synchronous aggregation, where participants must dynamically adapt to arbitrary delay patterns, is that nodes must be able to combine potentially overlapping aggregates without imposing regular structures as used in San Fermín. For example, nodes A and B may communicate to form aggregate AB, nodes B and C then form aggregate BC, and finally nodes A and C must combine aggregates AB with BC. Aggregating BLS signatures as usual here will yield a collective signature \( H(M)^{x_A + 2x_B + x_C} \) in which B’s signature is effectively aggregated twice. There is no readily apparent way to avoid such duplication, apart from keeping the individual signatures separate and giving up the efficiency benefits of incremental aggregation.

Such duplication may be tracked and compensated for, however, by maintaining with each aggregate a vector of coefficients indicating the number of “copies” of each node’s signature (possibly 0) represented in a given aggregate. Thus, the aggregate AB2C from the above example would be represented by the curve point \( H(M)^{x_A + 2x_B + x_C} \) and the coefficient vector \( v = [1, 2, 1] \). The number of participants represented in a given aggregate is simply the number of nonzero elements in the coefficient vector. Signature verification uses the coefficient vector to compute the corresponding aggregate public key against which to verify the signature, as \( \prod_{i=1}^n (G^{x_i})^{v_i} \).

This approach has the downside of requiring \( O(N) \) communication cost per aggregation step due to the need to transmit the vector, and \( O(N) \) computation cost to compute the correct aggregate public key in signature verification. However, partly mitigating these costs, the vector’s elements are small (e.g., one or two bytes) compared to full elliptic curve points representing individual signatures, and group exponentiation (scalar multiplication of curve points) with small non-secret values can be made relatively inexpensive computationally.

### Prototype Implementation

We have built and evaluated a working prototype witness cosigning cothority, implementing the basic CoSi protocol described in Section III. The prototype also demonstrates CoSi’s integration into two different authority applications: a timestamp service and a backward-compatible witness cosigning extension to the Certificate Transparency log server.

The CoSi prototype is written in Go [61]; its primary implementation consists of 7600 lines of server code as measured by CLOC [41]. The server also depends on a custom 21,000-line Go library of advanced crypto primitives such as pluggable elliptic curves, zero-knowledge proofs, and verifiable secret sharing. Our CoSi prototype relies heavily on this library but does not use all its facilities. Both the CoSi prototype and the crypto library are open source and available on GitHub: https://github.com/dedis/cothority

The cothority prototype currently implements tree-based aggregation.