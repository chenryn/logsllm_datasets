6 Discussion
Given that LSM set out to satisfy the needs of a collec-
tion of other independent projects, it is understandable
that the result produced some emergent properties.
Many security models require some way to associate se-
curity attributes to system objects. Thus LSM attaches
security ﬁelds to many internal kernel objects so that
modules may attach and later reference the security at-
tributes associated with those objects.
It is also desirable to persistently bind security attributes
to ﬁles. To do so seamlessly requires extended attribute
ﬁle system support, which enables security attributes
to be bound to ﬁles on disk. However, supporting ex-
tended attributes is a complex issue, requiring both sup-
port for extended attributes in the ﬁlesystem [22], and
support for extended attributes in the Linux kernel’s VFS
layer. LSM mediates all VFS extended attribute func-
tions, such as creating, listing and deleting extended at-
tributes. However, extended attribute support is new to
the Linux kernel and is not well-supported in all ﬁlesys-
tems. Modules that need persistent extended attributes
can resort to using meta-ﬁles [44, 29] when extended at-
tribute support is missing from the ﬁlesystem.
In attempting to provide a pluggable interface for secu-
rity enhancements, it is tempting to consider completely
modularizing all security policy decisions, i.e. move all
kernel logic concerning access control out of the kernel
and into a default module. This approach has signiﬁcant
beneﬁts beyond simple modular consistency: in particu-
lar, it would make it much easier to provide authoritative
hooks instead of restrictive hooks, which in turn would
enable a broader variety of modules (see Section 3).
However, we chose not to modularize all security deci-
sions, for pragmatic reasons. Current Linux access con-
trol decisions are not well isolated in the kernel; they
are mingled with other error checking and transforma-
tion logic. Thus a patch to the Linux kernel to remove
all access control logic would be highly invasive. Im-
plementing such a change would almost certainly entail
security bugs, which would not be an auspicious way to
introduce LSM to the greater Linux community.
Therefore, we deferred the complete modularization of
all access control logic. The current LSM implements
much less invasive restrictive hooks, providing a min-
imally invasive patch for initial introduction into the
Linux community. Once LSM is well established, we
may revisit this decision, and propose a more radical
modularization architecture.
Finally, in designing the LSM interface, we were dis-
tinctly aware that LSM constitutes an API, and thus must
present a logically consistent view to the programmer.
The LSM interface constitutes not only the set of hooks
needed by the modules we intended to support, but also
the logical extension of such hooks, such that the inter-
face is regular. Where possible, special cases were gen-
eralized so that they were no longer special.
7 Related Work
Section 7.1 describes the general area of extensible ker-
nels in the LSM context, and Section 7.2 describes work
speciﬁcally related to generic access control frame-
works.
7.1 Extensible Kernel Research
There has been a lot of operating systems research in the
last 20 years on extensible systems. Following the ba-
sic idea of microkernels (which sought to componentize
most everything in the kernel) came extensive efforts to
build more monolithic kernels that could be extended in
various ways:
• Exokernel was really just a logical extension of the
microkernel concept [16]. The base kernel pro-
vided no abstraction of physical devices, leaving
that to applications that needed the devices.
• SPIN allowed modules to be loaded into the ker-
nel, while providing for a variety of safety prop-
erties [7]. Modules were to be written in Modula-
3 [35], which imposed strong type checking, thus
preventing the module from misbehaving outside of
its own data structures. SPIN “spindles” also were
subject to time constraints, so they could not seize
the CPU. Abstractly, spindles would register to “ex-
tend” or “specialize” kernel events, and would be
added to an event handling chain, rather similar to
the way interrupts are commonly handled.
• SCOUT was designed to facilitate continuous
ﬂows of information (e.g. audio or video streams),
and allowed CODEC stages to be composed
into pipelines (or graphs) of appropriate compo-
nents [34].
• Synthetix sought to allow applications to specialize
the operating system to their transient needs [38].
“Specialization” meant optimization with respect to
“quasi-invariants”: properties that hold true for a
while, but eventually become false. In some cases,
quasi-invariants were inferred from application be-
havior, such as a process opening a ﬁle, result-
ing in a specialized read() system call optimized
for the particular process and ﬁle. In other cases,
quasi-invariants were speciﬁed to the kernel using
a declarative language [11, 43].
All of these extension facilities provided some form of
safety, to limit the potential damage that an extension
could impose on the rest of the system. Such safety
properties, for example, might allow a multimedia ap-
plication to extend the kernel to support better quality of
service, while limiting the multimedia extension so that
it does not accidentally corrupt the operating system.
The need for such safety in kernel extensions is anecdo-
tally conﬁrmed by the phenomena of unstable Microsoft
Windows systems, which are allegedly made unstable in
part due to bad 3rd party device drivers, which run in
kernel space.
In contrast, LSM imposes no restrictions on modules,
which are (normally) written in C and have full, un-
typed access to the kernel’s address space. The only
“restriction” is that hooks are mostly of the “restrictive”
form, making it somewhat more difﬁcult to erroneously
grant access when it should have been denied. Rather,
LSM depends primarily on programmer skill (modules
need to be written with the diligence of kernel code) and
root authority (only root may load a module).
It should be noted that LSM can get away with this weak
module safety policy precisely because LSM modules
are intended to enforce security policy. Unlike more
generic kernel extensions such as QoS, the system is en-
tirely at the mercy of the security policy. An admin-
istrator who permits an LSM module to be loaded has
already made the decision to trust the module providers
to be both well-intentioned and skilled at programming,
as bugs in a security policy engine can have catastrophic
consequences. Further sanity checks on LSM modules
are superﬂuous.
It should also be noted that this is the traditional view of
Linux modules: that loading modules into the kernel is
privileged for a reason, and that care should be taken in
the writing and selection of kernel modules. LSM mod-
ule developers are cautioned to be especially diligent in
creating modules. Not only do LSM modules run with
the full authority of all kernel code, but they are espe-
cially trusted to enforce security policy correctly. Third
party review of LSM modules’ source code is recom-
mended.
Finally, we note that LSM is much less intrusive to the
Linux kernel than the other large modular interface: VFS
(Virtual Filesystem). The need for support for multi-
ple ﬁlesystems in Linux was recognized long ago, and
thus a rich infrastructure was built. The VFS layer of
the kernel abstracts the features of most ﬁlesystems, so
that other parts of the kernel can access the ﬁlesystem
without what knowing what kind of ﬁlesystem is in use.
Anecdotally, the VFS layer is reported to be a nest of
function pointers that was very difﬁcult to debug. This
difﬁculty may explain, in part, why the Linux commu-
nity would like the LSM interface to be as minimally
intrusive as possible.
7.2 General Access Control Frameworks
The challenge of providing a highly general access con-
trol framework has been previously explored in the Gen-
eralized Framework for Access Control (GFAC) [1] and
the Flask architecture [41]. These two architectures
have been implemented as patches for the Linux ker-
nel by the RSBAC [37] and the SELinux [29] projects.
The Medusa [32] project has developed its own general
access control framework [46] and implemented it in
Linux. Domain and Type Enforcement (DTE) [4] pro-
vides support for conﬁgurable security policies, and has
also been implemented in Linux [23].
Like these prior projects, LSM seeks to provide general
support for access control in the Linux kernel. However,
the goals for LSM differ from these projects, yielding
corresponding differences in the LSM framework.
In
particular, the emphasis on minimal impact to the base
Linux kernel, the separation of the capabilities logic, and
the need to support security functionality as kernel mod-
ules distinguish LSM from these prior projects.
Additionally, since LSM seeks to support a broad range
of existing Linux security projects, it cannot impose a
particular access control architecture such as Flask or
the GFAC or a particular model such as DTE. In order to
provide the greatest ﬂexibility, LSM simply exposes the
kernel abstractions and operations to the security mod-
ules, allowing the individual modules to implement their
desired architecture or model. Similarly, since the var-
ious projects use signiﬁcantly different approaches for
associating security attributes with ﬁles, LSM defers ﬁle
labeling support entirely to the module. For systems
like SELinux or RSBAC, this approach introduces a new
level of indirection, so that even the general access con-
trol architecture and the ﬁle labeling support would be
encapsulated within the module rather than being di-
rectly integrated into the kernel.
8 Conclusions
The Linux kernel supports the classical UNIX security
policies of mode bits, and a partial implementation of the
draft POSIX.1e “capabilities” standard, which in many
cases is not adequate. The combination of open source
code and broad popularity has made Linux a popular tar-
get for enhanced security projects. While this works, in
that many powerful security enhancements are available,
it presents a signiﬁcant barrier to entry for users who are
unable or unwilling to deploy custom kernels.
References
The Linux Security Modules (LSM) project exists to
ease this barrier to entry by providing a standard load-
able module interface for security enhancements. We
presented the motivation, design, and implementation of
the LSM interface. LSM provides an interface that is
rich enough to enable a wide variety of security mod-
ules, while imposing minimal disturbance to the Linux
source code, and minimal performance overhead on the
Linux kernel. Several robust security modules are al-
ready available for LSM.
LSM is currently implemented as a patch to the standard
Linux kernel. A patch is being maintained for the latest
versions of the 2.4 stable series and the 2.5 development
series. The goal of the LSM project is for the patch to
be adopted into the standard Linux kernel as part of the
2.5 development series, and eventually into most Linux
distributions.
9 Acknowledgements
This work has been supported in part by DARPA Con-
tract N66001-00-C-8032 (Autonomix) and NSA Con-
tract MDA904-01-C-0926 (SELinux). This work rep-
resents the view of the authors and does not necessarily
represent the views of WireX, NAI, Intercode or IBM.
Thanks to all who have supported this work.
UNIX is a registered trademark of The Open Group in
the United States and other countries.
Linux is a trademark of Linus Torvalds.
Other company, product, and service names may be
trademarks or service marks of others.
10 Availability
[1] Marshall D. Abrams, Leonard J. LaPadula, Kenneth W. Eggers,
and Ingrid M. Olson. A generalized framework for access con-
trol: An informal description.
In Proceedings of the 13th Na-
tional Computer Security Conference, pages 135–143, October
1990.
[2] J. Anderson. Computer Security Technology Planning Study.
Report Technical Report ESD-TR-73-51, Air Force Elect. Sys-
tems Div., October 1972.
[3] Argus
Systems.
PitBull LX.
http://www.
argus-systems.com/product/white_paper/lx.
[4] L. Badger, D.F. Sterne, and et al. Practical Domain and Type
Enforcement for UNIX. In Proceedings of the IEEE Symposium
on Security and Privacy, Oakland, CA, May 1995.
[5] Lee Badger, Daniel F. Sterne, David L. Sherman, Kenneth M.
Walker, and Sheila A. Haghighat. A Domain and Type Enforce-
ment UNIX Prototype. In Proceedings of the USENIX Security
Conference, 1995.
[6] D. Baker. Fortresses built upon sand. In Proceedings of the New
Security Paradigms Workshop, 1996.
[7] Brian N. Bershad, Stefan Savage, Przemysław Pardyak,
Emin G¨un Sirer, Marc Fiuczynski, David Becker, Susan Eggers,
and Craig Chambers. Extensibility, Safety and Performance in
the SPIN Operating System. In Symposium on Operating Sys-
tems Principles (SOSP), Copper Mountain, Colorado, December
1995.
[8] M. Bishop and M. Digler. Checking for Race Conditions in
File Accesses. Computing Systems, 9(2):131–152, Spring 1996.
Also available at http://olympus.cs.ucdavis.edu/
˜bishop/scriv/index.html.
[9] W.E. Boebert and R.Y. Kain. A Practical Alternative to Hier-
In Proceedings of the 8th National
archical Integrity Policies.
Computer Security Conference, Gaithersburg, MD, 1985.
[10] Crispin Cowan, Steve Beattie, Calton Pu, Perry Wagle, and Virgil
Gligor. SubDomain: Parsimonious Server Security. In USENIX
14th Systems Administration Conference (LISA), New Orleans,
LA, December 2000.
[11] Crispin Cowan, Andrew Black, Charles Krasic, Calton Pu,
Jonathan Walpole, Charles Consel, and Eugen-Nicolae Volan-
schi. Specialization Classes: An Object Framework for Special-
ization. In Proceedings of the Fifth International Workshop on
Object-Orientation in Operating Systems (IWOOOS ’96), Seat-
tle, WA, October 27-28 1996.
[12] “Solar Designer”. Non-Executable User Stack. http://www.
openwall.com/linux/.
[13] Antony Edwards, Trent R.
Jaeger,
for
and Xiaolan Zhang.
the Linux
Report RC22254,
2001.
Framework.
Verifying Authorization Hook Placement
Security Modules
IBM T.J. Watson Research Center, December
http://domino.watson.ibm.com/library/
cyberdig.nsf/1e4115aea78b6e7c85256b3600%
66f0d4/fd3bffacfd2bbd9385256b30005ec7ee?
OpenDocument.
The LSM framework is maintained as a patch to the
Linux kernel. The source code is freely available from
http://lsm.immunix.org.
[14] Antony Edwards, Xiaolan Zhang, and Trent Jaeger. Using
CQUAL for Static Analysis of Authorization Hook Placement.
In USENIX Security Symposium, San Francisco, CA, August
2002.
[15] Nigel Edwards, Joubert Berger, and Tse Houng Choo. A Secure
Linux Platform. In Proceedings of the 5th Annual Linux Show-
case and Conference, November 2001.
[16] Dawson R. Engler, M. Frans Kaashoek, and James O’Toole Jr.
Exokernel: An Operating System Architecture for Application-
level Resource Management. In Symposium on Operating Sys-
tems Principles (SOSP), Copper Mountain, Colorado, December
1995.
[34] David Mosberger and Larry L. Peterson. Making Paths Ex-
plicit in the Scout Operating System. In Symposium on Operat-
ing Systems Design and Implementation (OSDI), pages 153–168,
October 1996. http://www.cs.arizona.edu/scout/
Papers/osdi96/.
[17] M. Abrams et al. Information Security: An Integrated Collection
[35] Greg Nelson. System Programming in Modula-3. Prentice Hall,
of Essays. IEEE Comp., 1995.
1991.
[18] Tim Fraser, Lee Badger, and Mark Feldman. Hardening COTS
Software with Generic Software Wrappers. In Proceedings of the
IEEE Symposium on Security and Privacy, Oakland, CA, May
1999.
[19] Timothy Fraser. LOMAC: Low Water-Mark Integrity Protection
for COTS Environments. In Proceedings of the IEEE Symposium
on Security and Privacy, Oakland, CA, May 2000.
[20] Timothy Fraser. LOMAC: MAC You Can Live With. In Proceed-
ings of the FREENIX Track, USENIX Annual Technical Confer-
ence, Boston, MA, June 2001.
[21] Virgil D. Gligor, Serban I Gavrila, and David Ferraiolo. On the
Formal Deﬁnition of Separation-of-Duty Policies and their Com-
position. In Proceedings of the IEEE Symposium on Security and
Privacy, Oakland, CA, May 1998.
[36] Netﬁlter Core Team. The Netﬁlter Project: Packet Mangling for
Linux 2.4, 1999. http://www.netfilter.org/.
[37] Amon Ott. The Rule Set Based Access Control (RSBAC) Linux
In Proceedings of the 8th Interna-
Kernel Security Extension.
tional Linux Kongress, November 2001.
[38] Calton Pu, Tito Autrey, Andrew Black, Charles Consel, Crispin
Cowan, Jon Inouye, Lakshmi Kethana, Jonathan Walpole, and
Ke Zhang. Optimistic Incremental Specialization: Streamlin-
ing a Commercial Operating System.
In Symposium on Oper-
ating Systems Principles (SOSP), Copper Mountain, Colorado,
December 1995.
[39] Jerome H. Saltzer and Michael D. Schroeder. The Protection
of Information in Computer Systems. Proceedings of the IEEE,
63(9), November 1975.
[22] Andreas Grunbacher. Extended Attributes and Access Control
Lists for Linux. World-wide web page available at http://
acl.bestbits.at/, December 2001.
[40] Stephen Smalley, Timothy Fraser, and Chris Vance. Linux Se-
curity Modules: General Security Hooks for Linux. http:
//lsm.immunix.org/, September 2001.
[41] Ray Spencer, Stephen Smalley, Peter Loscocco, Mike Hibler,
David Andersen, and Jay Lepreau. The Flask Security Architec-
ture: System Support for Diverse Security Policies. In Proceed-
ings of the Eighth USENIX Security Symposium, pages 123–139,
August 1999.
[42] Winfried Trumper. Summary about POSIX.1e. http://wt.
xpilot.org/publications/posix.1e, July 1999.
[43] Eugen N. Volanschi, Charles Consel, Gilles Muller, and Crispin
Cowan. Declarative Specialization of Object-Oriented Programs.
In Proceedings of the Conference on Object-Oriented Program-
ming Systems, Languages, and Applications (OOPSLA’97), At-
lanta, GA, October 1997.
[44] Robert N.M. Watson. TrustedBSD: Adding Trusted Operating
System Features to FreeBSD. In Proceedings of the FREENIX
Track: 2001 USENIX Annual Technical Conference (FREENIX
’01), June 2001.
[45] WireX Communications. Linux Security Module. http://
lsm.immunix.org/, April 2001.
[46] Marek Zelem and Milan Pikula.
ZP Security Frame-
http://medusa.fornax.sk/English/
work.
medusa-paper.ps.
[23] Serge Hallyn and Phil Kearns. Domain and Type Enforcement
for Linux. In Proceedings of the 4th Annual Linux Showcase and
Conference, October 2000.
[24] Jon Inouye, Ravindranath Konuru, Jonathan Walpole, and Bart
Sears. The Effects of Virtually Addressed Caches on Virtual
Memory Design & Performance. Operating Systems Review,
24(4):896–908, October 1992. Also published as OGI technical
report CSE-92-010, ftp://cse.ogi.edu/pub/tech-reports/1992/92-
010.ps.gz.
[25] SNARE. World-wide web page available at http://
intersectalliance.com/projects/Snare/.
[26] Jay Lepreau, Bryan Ford, and Mike Hibler. The persistent rel-
evance of the local operating system to global applications. In
Proceedings of the ACM SIGOPS European Workshop, pages
133–140, September 1996.
[27] Linux Intrusion Detection System. World-wide web page avail-
able at http://www.lids.org.
[28] T. Linden. Operating System Structures to Support Security and
Reliable Software. ACM Computing Surveys, 8(4), December
1976.
[29] Peter Loscocco and Stephen Smalley. Integrating Flexible Sup-
port for Security Policies into the Linux Operating System. In
Proceedings of the FREENIX Track: 2001 USENIX Annual Tech-
nical Conference (FREENIX ’01), June 2001.
[30] Peter A. Loscocco, Stephen D. Smalley, Patrick A. Muckelbauer,
Ruth C. Taylor, S. Jeff Turner, and John F. Farrell. The Inevitabil-
ity of Failure: The Flawed Assumption of Security in Modern
Computing Environments. In Proceedings of the 21st National
Information Systems Security Conference, pages 303–314, Octo-
ber 1998.
[31] Larry W. McVoy and Carl Staelin. lmbench: Portable Tools for
In USENIX Annual Technical Confer-
Performance Analysis.
ence, 1996. http://www.bitmover.com/lmbench/.
[32] Medusa. World-wide web page available at http://medusa.
fornax.sk.
[33] Mindcraft. WebStone Standard Web Server Benchmark. http:
//www.mindcraft.com/webstone/.