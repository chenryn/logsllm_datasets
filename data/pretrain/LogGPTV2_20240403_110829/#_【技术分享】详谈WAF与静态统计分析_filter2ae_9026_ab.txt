在部署新版本的应用程序之前，应用程序由PT AI分析，并且为那些易受攻击的执行点中的每个CompFG节点计算三个公式：
**获取脆弱执行点的条件**
**获取其所有参数值的条件**
**所有参数及其相应语法的值集**
上述中的所有公式集都将按照应用程序的入口点进行分组，入口点定义于分析器的数据库中，并和PT
AI支持的每个Web框架相关联。通过提取包含的漏洞信息以及从代码（基于S-expression语法的特殊语言编写的代码，编程语言使用不依赖于目标语言的形式来描述CompFG公式）中提取相关的公式列表形成一份报告，例如上述代码示例中描述脆弱点参数值的公式如下：
    (+ (+ "Parameter value is `" (FromBase64Str (UrlDecodeStr (FromBase64Str (GetParameterData (param)))))) "`")
获取脆弱点的公式是：
    （Contains（FromBase64Str（UrlDecodeStr（FromBase64Str（GetParameterData（condition）））））“secret”）
。 然后将报告被上传到PT应用防火墙 （PT AF），在报告的基础上，PT WAF生成二进制模块，该模块可以计算报表中包含的所有公式。
例如，用于计算达到上述脆弱点的条件的反编译代码如下：
为了对公式进行计算操作，PT AF必须具有以下条件之一：
预先计算可能在报告中出现的所有函数
具有沙箱运行环境，用于运行Web应用程序或其他平台（如CLR，JVM或PHP，Python或Ruby解释器）以及应用程序中使用的库
第一种方法在一定程度上能够保证速度很快，但WAF开发人员需要大量的手动工作来描述预计算数据库，即使开发人员将范围限制为标准库函数。第二种方法允许计算报告中可能出现的所有函数，但这种方法会增加处理每个HTTP请求所需的时间，因为WAF需要访问运行时环境来对每个函数执行计算操作。这里最合适的解决方案是使用第一种方法进行最常见函数的计算，而对其余函数使用第二种方法。
公式中很可能会包含分析器无法处理的函数或者PT AF无法计算的函数，这些函数在公式中会被标记为“unknown”，并以如下所述的特殊方式进行处理。
**运行阶段**
****
在运行阶段，WAF将每个HTTP请求的处理委托给二进制模块，该模块分析请求并检测Web应用程序中的相关入口点。为此，WAF会选择所有检测到的漏洞公式，然后以特定方式执行计算操作。
首先，计算公式的两个条件为：1）到达脆弱点，2）获取其所有参数的值。 在每个公式中，变量用相关请求参数的值代替，之后计算公式值。
如果公式包含标记为“unknown”的表达式，则其处理如下：
每个“unknown”标志通过公式表达式树自下而上扩展，直到找到布尔表达式。
在公式中，这样的表达式会被布尔变量替换，以用来解决布尔可满足性问题。
假设通过上一步骤生成了关于“unknown”的n个公式，那么计算每个公式的值。 如果至少有一个公式是可满足的，那么该假设也被认为是可以满足的。
如果计算显示假设为假，那么即使所有请求参数都有危险的值，HTTP请求也无法将应用程序引导到易受攻击的点。在这种情况下，RVP只需向WAF的核心模块返回请求处理即可。如果攻击条件满足，那么WAF会计算脆弱点的参数值，使用的算法取决于分析点所属的漏洞等级。这些算法之间的相似之处是用于处理包含未知节点公式的逻辑：与假设公式不同，在计算时参数公式不会被计算，而是立即被传达给WAF。为了更好地理解这一点，我们现在将回顾一下用于检测注入攻击的最复杂的算法。
**检测注入攻击**
****
注入攻击通过将特定形成的输入数据传递给应用程序来执行恶意操作，当这些数据被“注入”到目标文本中（包括HTML, XML, JavaScript, SQL,
URLs,
以及文件路径）时，文本中包含了应用程序逻辑不想要的句法结构。如果一个脆弱点属于这个攻击类，那么它的参数值是可以通过使用污点分析语义中抽象解释的增量计算来确定的。这种方法背后的思想是：从下到上分别计算每个表达式，同时获得每个步骤的计算结果、每个函数的语义以及传统污点检查的规则。例如，对于上述代码和以下HTTP请求参数：
    condition=YzJWamNtVjA%3d&param=UEhOamNtbHdkRDVoYkdWeWRDZ3hLVHd2YzJOeWFYQjBQZyUzRCUzRA%3d%3d
，将此算法应用于弱点参数的公式的结果如下（污染参数标记为红色）：
然后根据脆弱点参数的语法对该值进行标记，如果任何污点的片段匹配多个令牌，那么就代表这是一次注入的攻击。
一旦与当前入口点相关的所有漏洞的公式计算结束，请求处理将与检测结果一起传递给WAF的核心模块。
**RVP优点和具体功能**
****
与传统VP相比，这种基于代码分析的应用程序保护方法具有很大的优势：
得益于上述公式方法以及所有中间转换的能力，传统VP的缺点得到了解决。
公式方法也完全排除了假阳性的可能性，只要公式不包含未知节点
对Web应用程序功能没有不利影响，因为保护是建立在应用程序的功能上，而不是简单地试图解决它们。
为了测试该技术并确认其有效性，我们开发了一种用于PT应用程序检查器和PT应用程序防火墙的模块原型，实验结果表明大约十五个开源内容管理系统（CMS）的性能测试显示出很好的结果：使用RVP处理HTTP请求所需的时间与使用传统（启发式）WAF方法处理此类请求所需的时间相当。
Web应用程序的平均性能如下：
对于那些非攻击的请求占比为0％
对于那些非攻击请求，但会导致脆弱点的占比为6-10％
对于那些是攻击请求的，且会导致脆弱点的占比为4-7％
尽管与传统VP相比有明显优势，但RVP仍有几个概念上的缺点：
不可能在WAF（包括文件资源，数据库和服务器环境）上计算包含来自外部源的数据公式。
公式的质量直接取决于分析期间代码片段的质量（包括循环，递归和对外部库方法的调用）。
为了描述预计算数据库中函数的语义，需要开发人员加入到其中，该描述过程很难自动化，且容易出现人为错误。
然而，我们已经设法通过将一些RVP功能从应用程序中删除并使用RASP技术来缓解上述这些缺陷，该部分内容我们将会在新的文章中进行阐述，尽请期待吧~