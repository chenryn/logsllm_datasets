96.16%
98.58%
99.63%
95.44%
87.23%
97.17%
Table 5: Embedded data regions identified by static analysis.
Name
libc.so.6
libffi.so.6
libcrypto.so.1.0.0
Invalid
Regions
40
0
0
Valid
Regions Reason
0 Alignment padding
1 ffi_call_SYSV
16
Lookup table for
crypto algorithms
the middle of functions. After analyzing 491 ELF system binaries in
Ubuntu 14.04, we have found a few cases of data embedded in code.
However, in most of these cases, the gap region indicated in the
.eh_frame section was simply the padding data in between function
or section boundaries. There were only a few cases in which data
was embedded in the code as part of jump tables. Table 5 provides
details about these cases. We found 40 locations totaling 390 bytes
of data in libc.so.6, all of them used as padding. Since the value
of the padding is zero, they can cause disassembly errors if not
handled properly. In libffi.so.6 on x86, we found a jump table in
the middle of code inside the ffi_call_SYSV function. The same
library on x86-64 has two jump tables identified by our algorithm.
Finally, libcrypto.so.1.0.0 contains 16 data regions (correspond-
ing to approximately 20KB) in the middle of code in both 32-bit and
64-bit versions. All these data regions are located after function
returns.
4.1.3 Randomization Entropy
To ensure that our shadow code leverages the full entropy of the
address space, we implemented our own code loading primitive as
part of our modified loader to hide the location of shadow code.
Although SECRET is currently limited to 32-bit systems, we wanted
to evaluate achievable entropy on 64-bit systems. We hence ported
our modified loader in the x86_64 glibc 2.19 running in Ubuntu
14.04. We then performed an experiment using Chrome 43.02 by
forcing our modified loader to load the browser code as well as
its dependent libraries. In this experiment, we used instrumented
code of the same size as the code in the original binary, i.e., when
a module is loaded, our loader immediately loads a corresponding
code piece whose size is the same as the text segment of the module.
In our experiment, all 24 processes of Chrome were tested.
Our experiments illustrate that the size of the instrumented code
used by chrome is 514 MB. The instrumented code pages allocated
are scattered in the whole user address space. The address range
is different on each process, but the overall range of the address
space that instrumented code occupies across different processes is
between 953 and 1021 TB. Since instrumented code is not targeted
Table 6: Low-level indirect control transfer instructions protected by SECRET.
Name Return
603
glibc
vDSO
1
Indirect Jump
146
0
Indirect Call
675
0
Syscall
2
1
by any code pointers, the probability of a memory leak is calculated
as the size of the code divided by the address space used, which is
about 5 × 10−7.
We note that isolation based on information hiding may not
be strong in some scenarios, especially if an attacker has the ca-
pability of probing information about the memory layout using
timing channels [30], or other side channels such as the size of
unallocated memory [47]. At the same time, it is clear that high
entropy randomization substantially increases the attacker’s work
factor.
4.1.4 Low-level Protection Coverage
To evaluate the completeness of our approach, we have evaluated
several low-level binaries that are used by most programs: ld.so,
libc.so, libgcc_s.so and vDSO. The hand-written assembly code
contained in these binaries exceeds 56K LoC.
Table 6 shows all the low-level indirect control transfer instruc-
tions that are protected by SECRET. In particular, we found 218 call
instructions in native assembly code in glibc. The rest of low-level
calls (457) were used for system calls (e.g., call %gs:0x10). In
addition to low-level calls, we have found that three quarters of
indirect jumps are low-level instructions. In particular, we found
256 indirect jumps written in assembly code, 230 of which are used
as part of jump tables. Our experiments illustrate that there are
1545 code pointers used by these low-level jump tables and 457
return addresses could be generated by low level calls. All these
low-level code pointers are fully protected by SECRET.
4.2 Runtime Performance
4.2.1 SPEC 2006 Benchmarks
We have evaluated SECRET’s runtime overhead using the SPECINT
2006 benchmarks. Since code space isolation does not introduce
any extra overhead, we include this feature on by default except
in the baseline BinCFI system. We compare between three differ-
ent modes: 1) BinCFI: baseline protection; 2) SECRET.seg: shadow
code protected using memory segmentation; and 3) SECRET.rand:
shadow code protected using base address randomization. In all
cases, SECRET transforms the main executable and all six depen-
dent libraries. The results for each benchmark are shown in Figure 7,
while Table 8 shows the average overhead for SPECINT, as well as
the total for all 21 SPEC CPU benchmarks.
In the SECRET.seg mode, the average overhead for SPECINT
is 14.41% (the total SPEC CPU overhead is 15.64%). In this mode,
both the instrumented code and its LTT are located outside of the
memory sandbox. The overhead in this mode mostly comes from
memory access through a segment register when performing ad-
dress translation. In the SECRET.rand mode, the average runtime
overhead for SPECINT is 13.54% (the total SPEC CPU overhead is
14.48%). Compared with SECRET.rand, there are two main differ-
ences in this mode: (a) the address translation trampolines perform
Fig. 7: Runtime overhead of SECRET on the SPECINT 2006 benchmarks.
Table 8: Summary of SPEC 2006 runtime overhead results.
Programs BinCFI
12.84%
SPECINT
Total
14.20%
SECRET.seg
14.41%
15.64%
SECRET.rand
13.54%
14.48%
Table 9: Completion time (sec) for real-world programs.
Test Suite
python
dd
md5sum
scp
Base
4.709
99.46
2.44
2.78
SECRET.rand Description
5.022 Run bincfi script
to transform /bin/ls
99.6 Copy a 1GB file
2.45 Checksum of file (1GB)
2.96 Copy a 100MB file
two range checks (one for the original and one for the randomized
code address space) instead of one, adding a bit more overhead,
and (b) SECRET.rand does not require intensive memory access
through our TLS. Our experiments show that the average over-
head of SECRET.rand is slightly lower than SECRET.seg. Compared
with the baseline system, the average runtime overhead added by
SECRET.seg is less than 2%, and by SECRET.rand is less than 1%.
In our experiments, the average code size increase on SPEC
programs was 3x, mostly due to LTTs, which consume a large
amount of space. Code pointer remapping also contributes to the
size increase since it duplicates many jump tables. Other than binary
size, we also measure the physical memory overhead at runtime.
In our experiment, for simplicity, we measured the peak usage
of resident memory for each SPEC program. We observed that
SECRET uses up to 4.3% extra memory over the original binary.
This is reasonable despite the larger increase of binary size, since
most of the SPEC benchmark programs allocate large chunks of
data at runtime, and hence their memory use is determined more
by data memory size rather than code size.
4.2.2 Commonly Used Applications
In addition to the SPEC benchmarks, we also evaluated SECRET
with several real-world programs. As the SECRET.rand mode in-
cludes all features and supports the recent x86-64 architecture, we
used this mode to compare with the performance of the original
programs. The results of Table 9 show that SECRET is practical
-10%-5%0%5%10%15%20%25%30%35%40%BinCFISECRET.segSECRET.randTable 10: Startup overhead for launching GUI programs.
Name
vim
lynx
evince
gcalctool
gedit
LibreOffice
Base (sec) BinCFI
60%
100%
135%
110%
120%
51%
0.6
0.02
0.34
0.62
0.6
1.4
SECRET.rand
67%
100%
168%
161%
165%
200%
for real-world usage. This experiment includes script interpreters
(python and perl), disk I/O tools (dd), as well as network related
tools (scp). In all experiments, the code of all main executables and
libraries was transformed to shadow code.
We also evaluated further the startup overhead of protected pro-
grams, as this may affect user experience. SECRET has noticeable
startup overhead due to its modified loader, which needs to perform
the following actions on each module: (a) load the instrumented
code as well as the LTT (b) initialize the corresponding entries in
the GTT, for code pointer remapping to work properly, and (c) wipe
out the original code. To better assess this overhead, we used a set
of GUI applications, since they typically depend on many more
libraries compared to the simple benchmark programs. As in the
previous experiment, we use the SECRET.rand mode to compare
with the original programs and the baseline system. Table 10 shows
the startup overhead of several well-known Linux applications, in-
cluding three GTK and two text user interface programs. The results
show that SECRET’s overhead is higher on GTK programs than
programs using a textual interface. This is because GTK programs
load many more libraries at program start up.
5 RELATED WORK
5.1 Control Flow Integrity
Control flow integrity (CFI) [3] provides a principled foundation for
enforcing low-level security policies on binary code. The main idea
of CFI is to mediate indirect control flow transfers and permit only
allowed targets. CFI can be informally classified to coarse-grained
[77, 79], fine-grained [45, 46, 50, 68], and context sensitive [44, 69],
depending on the enforced policy. Although CFI enforcement makes
code reuse exploits much harder, researchers have shown that they
are still possible [16, 25, 33, 34]. These attacks exploit the fact that
any static analysis used to infer intended control-flow must be
approximate, and hence cannot prevent attacks that exclusively
use gadgets that are determined to be legitimate by the analysis.
This factor motivates the approach developed in this paper so that
SECRET can provide stronger protection than what is achieved
using the coarse-grained CFI provided by our platform PSI. Our
approach complements CFI, including some of the recent advances
[50, 52, 70], by making it much harder to discover gadgets (by hiding
code), and to target them (by randomizing code pointer values).
Most of the CFI techniques referenced above are focused on
forward edges, which include indirect calls and indirect jumps. Re-
searchers have noted that protection of backward edges, i.e., returns,
is even more critical. Indeed, ROP attacks repeatedly violate back-
ward edge policies. Shadow stacks [18, 22, 26, 53] are a powerful
mechanism for highly accurate enforcement of backward edge poli-
cies. However, shadow stacks experience compatibility problems in
complex code due to non-standard use cases where return addresses
are generated by non-call instructions. Rui et al [55] developed a
static analysis to discover such non-standard cases, thus develop-
ing a robust shadow stack defense. SECRET provides fine-grained
protection for backward edges by randomly remapping return ad-
dresses. Non-standard use cases don’t pose a problem on our PSI
platform: code addresses generated by any non-call instruction
will be identified by PSI’s static analysis as a possible code pointer
analysis, and its use as a jump or return address will hence be
permitted.
Approaches complementary to CFI have also been developed to
defend against ROP. G-Free [48] implements an instruction transfor-
mation technique at the very last phase of compilation to eliminate
unintended gadgets. However, intended gadgets (i.e., legitimate
return targets) still pose a problem. Control-flow and code integrity
(CFCI) [80] limits the use of intended gadgets so that they cannot
be used to achieve the common attacker goal of loading injected
code, e.g., by executing an mmap call to make data executable.
5.2 Code Randomization
PaX team introduced one of the earliest implementations of ad-
dress space layout randomization (ASLR) [42] and non-executable
memory pages [67]. ASLR is an important and defense that miti-
gates code injection as well as code reuse attacks. However, it is
known that coarse-grained randomization, as used in PaX and other
early ASLR implementations [9, 40, 76] and is in wide use today,
has several weaknesses [29, 62]. Information leakage attacks are
arguably the biggest threat to ASLR today. By disclosing the base
address of a dynamically loaded module, the exploit code can dy-
namically adjust the gadget addresses used in the (pre-constructed)
ROP payload, and effectively bypass ASLR [29].
To thwart this attack, fine-grained code diversification offers an
additional layer of protection over ASLR, by randomizing not only
the location but also the internal structure of code within a code
section. Code diversification can be applied at varying granularities,
e.g., at the function [10, 36, 43], basic block [72], or instruction
granularity [27, 49].
Code randomization techniques that operate on source code
are capable of fully randomizing code locations. In contrast, tech-
niques that operate on COTS binaries can perform only a limited set
of conservative randomizations, e.g., in-place randomization [49].
This is because of the previously identified difficulties in accurate
identification of code pointers in binaries.
5.3 Code Disclosure Attacks and
Countermeasures
Code randomization is challenged by advanced attacks that leverage
memory disclosure vulnerabilities along with scripting capabilities
to dynamically construct ROP payloads [12, 64]. Such “just-in-time
ROP” (JIT-ROP) attacks [64] repeatedly use a memory disclosure
capability to read executable memory and chain discovered gadgets
to launch a ROP attack. BROP (blind ROP) [12] leverages a stack
buffer overflow in forking servers to repeatedly overwrite the stack
until the write function is located, which then is used to leak exe-
cutable process memory to the client. Under certain circumstances,
even if a memory disclosure bug is not available, gadget locations
can be inferred through side channels [60].
Recent research extends code randomization with dynamic re-
randomization to thwart JIT-ROP attacks. Bigelow et al. [11] pro-
pose TASR, a re-randomization approach that randomizes the code
upon each system call. Shuffler [75] provides a continuous code
re-randomization capability. However, TASR requires source code,
compiler, and kernel support, while Shuffler works on binaries but
relies on the compiler to provide symbolic and relocation informa-
tion. SECRET, in contrast, operates on stripped binaries without
needing any such information.