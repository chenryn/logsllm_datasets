O0(ğ‘ ) :
E
E
First, we prove that
Proof of Lemma B.1. Fix an arbitrary ğ‘  âˆˆ {0, 1}âˆ— and a ppt al-
gorithm A that makes at most ğ‘F queries to the random oracle.
Without loss of generality, we assume A never queries the random
oracle on the same input. Let the events:
ğ¸real(ğœ…) (cid:66)
ğ‘Ÿ â†Gen(1ğœ…) : AFğœ…(Â·)(cid:0)Encğ‘Ÿ (ğ‘ ), Fğœ…(ğ‘Ÿ)(cid:1) = 1
ğ¸rand(ğœ…) (cid:66) ğ‘¢ â†$ {0, 1}ğœ…; ğ‘Ÿ â†Gen(1ğœ…) : AFğœ…(Â·)(cid:0)Encğ‘Ÿ (0|ğ‘ |), ğ‘¢(cid:1) = 1 .
| Pr [ğ¸real(ğœ…)] âˆ’ Pr [ğ¸rand(ğœ…)] | â‰¤ 2(cid:0)ğ‘FAdvkey-rec
(ğœ…) + AdveavE (ğœ…)(cid:1).
(6)
To do so, we define the event ğ¸call as â€œone of the calls by A to the
random oracle Fğœ… is on input ğ‘Ÿ (the random value sampled in ğ¸real)â€.
We can rewrite Pr [ğ¸real(ğœ…)] as:
Pr [ğ¸real(ğœ…) | ğ¸call] Pr [ğ¸call] + Pr [ğ¸real(ğœ…) | Â¬ğ¸call] Pr [Â¬ğ¸call]
Also, observe that:
â€¢ Pr[ğ¸call] â‰¤ ğ‘FAdvkey-rec
(7)
â€¢ | Pr [ğ¸real(ğœ…) | Â¬ğ¸call] âˆ’ Pr [ğ¸rand(ğœ…)] | â‰¤ 2AdveavE (ğœ…).
(8)
To see (7) note that we can build an adversary B against the
key-rec security game. On input ğœ…, B sends message ğ‘  to its chal-
lenger, receiving ğ‘ (cid:66) Encğ‘Ÿ (ğ‘ ) for some unknown and freshly gener-
ated key ğ‘Ÿ. Now, B samples ğ‘¢ â†$ {0, 1}ğœ… and runs A on input (ğ‘, ğ‘¢).
On every query by A to its random oracle, say on value ğ‘£ğ‘–, B will
answer back with a uniformly sampled value from {0, 1}ğœ… and will
store ğ‘£ğ‘– in a record. When A interrupts or finishes its execution,
B will output one of the stored values ğ‘£ğ‘–, selected uniformly at
9Which states that for any random variable ğ‘‹ and any convex function ğœ‘, it holds
ğ¸[ğœ‘(ğ‘‹)] â‰¥ ğœ‘(ğ¸[ğ‘‹ ]).
(ğœ…).
E
.
Session 2E: Smart Contracts and Cryptocurrencies CCS '20, November 9â€“13, 2020, Virtual Event, USA654random. It is clear that Advkey-rec
E,B (ğœ…) â‰¥ Pr[ğ¸call]/ğ‘F. To see (8) it is
enough to consider an adversary B against the eav security game
that on input ğœ…, sends two messages ğ‘  and 0|ğ‘ | to its challenger,
receiving ğ‘ which is either Encğ‘Ÿ (ğ‘ ) or Encğ‘Ÿ (0|ğ‘ |) for some fresh
key ğ‘Ÿ. Then, B samples ğ‘¢ â†$ {0, 1}ğœ… and runs A on input (ğ‘, ğ‘¢),
simulating the random oracle by sampling values uniformly from
{0, 1}ğœ… and mimics Aâ€™s output. It is not hard to see that
1
2 |Pr [ğ¸real(ğœ…) | Â¬ğ¸call] âˆ’ Pr [ğ¸rand(ğœ…)]|
AdveavE,B(ğœ…) =
Now, to conclude the proof of (6), let us denote Pr [ğ¸call] by ğœ€ for
compactness, we have:
| Pr [ğ¸real(ğœ…)] âˆ’ Pr [ğ¸rand(ğœ…)] |
â‰¤ ğœ€ +(cid:12)(cid:12) Pr [ğ¸real(ğœ…) | Â¬ğ¸call] (1âˆ’ğœ€) âˆ’ Pr [ğ¸rand(ğœ…)](cid:12)(cid:12)
â‰¤ 2(cid:0)ğ‘FAdvkey-rec
(ğœ…) + AdveavE (ğœ…)(cid:1)
â‰¤ ğœ€ + 2AdveavE (ğœ…) + ğœ€ Pr [ğ¸real(ğœ…) | Â¬ğ¸call] â‰¤ 2ğœ€ + 2AdveavE (ğœ…)
.
.
E
Finally, to conclude the proof of the lemma, consider an auxiliary
oracle Oâ€²
ğ‘– , for every ğ‘– âˆˆ [0, ğ‘O], defined as O1 on the first ğ‘– invoca-
tions and as O0 on the rest. Clearly, Oâ€²
0 is equivalent to O0, whereas
Oâ€²
ğ‘O is equivalent to O1. We conclude the proof by a standard hybrid
argument, where we just need to show that for every ğ‘– âˆˆ [ğ‘O] and
every ppt adversary A making at most ğ‘F queries to its random
oracle, the difference
ğ‘–âˆ’1(Â·),Fğœ… (Â·)(ğœ…) = 1(cid:105) âˆ’ Pr(cid:104)AOâ€²
(cid:12)(cid:12)(cid:12)Pr(cid:104)AOâ€²
is upper-bounded by 2(cid:0)ğ‘FAdvkey-rec
ğ‘– (Â·),Fğœ… (Â·)(ğœ…) = 1(cid:105)(cid:12)(cid:12)(cid:12)
(ğœ…)+AdveavE (ğœ…)(cid:1), but this follows
easily from (6), since it holds for every ğ‘  âˆˆ {0, 1}âˆ— and given the
independence of the sampling on every oracle call.
â–¡
E
Proof of Theorem 3.3. Consider an auxiliary security game,
InfoCPâ€², which is identical to the one described in Figure 2 with
the exception that the adversary A is given access to a modified
oracle Oâ€²(ğ‘…, crs, ğ‘, ğœğ‘˜, Â·) defined as:
Oâ€²(ğ‘…, crs, ğ‘, ğœğ‘˜, ğ‘ ) :
if ğ‘“ (ğ‘ ) = 0, return âŠ¥
ğ‘Ÿ â† E.Gen(1ğœ…); ğ‘ (cid:66) Encğ‘Ÿ (ğ‘ ); ğ‘¦ (cid:66) Fğœ…(ğ‘Ÿ)
if ğ‘ = 1 : overwrite ğ‘Ÿ with H
ğœ‹ â† Î .Prove(ğ‘…, crs, (ğ‘, ğ‘¦), ğ‘Ÿ)
return (ğ‘, ğ‘¦, ğœ‹)
ğœ… (ğœğ‘˜, ğ‘¦)
-1
Let A be an adversary against the InfoCP game that makes at
most ğ‘O queries to its oracle and at most ğ‘F queries to the ran-
dom oracle. For compactness, denote by ğ‘ŠA and ğ‘Š â€²
A the events
InfoCPÎ A(ğœ…) and InfoCPâ€²Î A (ğœ…) respectively. We have,
Adv
Î ,A (ğœ…) (cid:66)
InfoCP
Now, consider the following distinguisher D with access to ora-
cle Oğ‘ of Lemma B.1 (for some ğ‘ âˆˆ {0, 1}) and the random oracle Fğœ…:
DOğ‘ (Â·),Fğœ… (Â·)(1ğœ…):
run RG(1ğœ…) to get (ğ‘…, ğœğ‘˜)
call A on input ğ‘…, getting (crs, ğœ)
call A on input ğœ
on every query (ğ‘ ) from A to its oracle:
query (ğ‘ ) to the Oğ‘ oracle to get (ğ‘, ğ‘¦)
compute ğœ‹ â† Î .Prove(ğ‘…, crs, (ğ‘, ğ‘¦), H-1
send ğœ‹ to A
D forwards the query to its own random oracle and
copies the output to A
on every call by A to the random oracle:
ğœ… (ğœğ‘˜, ğ‘¦))
when A outputs ğ‘â€²
A, return ğ‘â€²
A
-1
We therefore have,
It is clear that D performs at most ğ‘F queries to its random
oracle and at most ğ‘O queries its Oğ‘ oracle. Moreover, if ğ‘ = 0,
the distinguisher D is perfectly simulating to A the InfoCPâ€² game,
where the internal challenge bit, ğ‘InfoCPâ€², is 1. Furthermore, if ğ‘ = 1,
D is simulating to A the InfoCP game, where the internal challenge
bit, ğ‘InfoCP, is 1. This is because the following distributions are
identical, given that Hğœ…(ğ‘˜, Â·) is a permutation:
(cid:110)ğ‘¤ â†$ {0, 1}ğœ…; (cid:0)Hğœ…(ğ‘˜, ğ‘¤), ğ‘¤(cid:1)(cid:111) â‰¡(cid:110)ğ‘¢ â†$ {0, 1}ğœ…; (cid:0)ğ‘¢, H
ğœ… (ğ‘˜, ğ‘¢)(cid:1)(cid:111) .
Pr(cid:104)DO0(Â·),ğ¹ğœ… (Â·)(ğœ…) = 1(cid:105)
= Pr(cid:2)ğ‘Š â€²
A | ğ‘InfoCPâ€² = 1(cid:3) and
Pr(cid:104)DO1(Â·),ğ¹ğœ… (Â·)(ğœ…) = 1(cid:105)
= Pr(cid:2)ğ‘ŠA | ğ‘InfoCP = 1(cid:3) .
Pr(cid:2)ğ‘ŠA | ğ‘InfoCP = 0(cid:3) = Pr(cid:2)ğ‘Š â€²
A | ğ‘InfoCPâ€² = 0(cid:3) ,
(cid:12)(cid:12)Pr[ğ‘ŠA] âˆ’ Pr[ğ‘Š â€²
A](cid:12)(cid:12)
(cid:12)(cid:12)Pr(cid:2)ğ‘ŠA | ğ‘InfoCP = 1(cid:3) âˆ’ Pr(cid:2)ğ‘Š â€²
A | ğ‘InfoCPâ€² = 1(cid:3)(cid:12)(cid:12)
(cid:12)(cid:12)(cid:12)Pr(cid:104)DO1(Â·),ğ¹ğœ… (Â·)(ğœ…) = 1(cid:105) âˆ’ Pr(cid:104)DO0(Â·),ğ¹ğœ… (Â·)(ğœ…) = 1(cid:105)(cid:12)(cid:12)(cid:12)
(ğœ…) + AdveavE (ğœ…)(cid:1)
â‰¤ ğ‘O(cid:0)ğ‘FAdvkey-rec
since both experiments are identical when the challenge bit is 0.
Consequently, and in virtue of Lemma B.1,
Moreover, observe that
1
2
1
2
=
=
Combining this fact with equation (9), we can conclude the proof
E
.
of the theorem by showing that
InfoCPâ€²
Î ,A (ğœ…) â‰¤ Adv
Î ,B (ğœ…)
tS-WI
Adv
for some adversary B against the tS-WI game. We provide such
a B in Figure 6. It is clear that the distribution of Bâ€™s answers to
Aâ€™s queries is the same as the one by the oracle in Game InfoCPâ€².
Therefore, if A outputs the correct result, so does B. We actually
have Adv
â–¡
InfoCPâ€²
Î ,A (ğœ…) = Adv
Î ,B (ğœ…).
tS-WI
(cid:12)(cid:12)(cid:12)(cid:12)Pr[ğ‘ŠA] âˆ’ 1
(cid:12)(cid:12)(cid:12)(cid:12)
(cid:12)(cid:12)(cid:12)(cid:12)Pr[ğ‘Š â€²
â‰¤(cid:12)(cid:12)Pr[ğ‘ŠA] âˆ’ Pr[ğ‘Š â€²
A](cid:12)(cid:12) +
A](cid:12)(cid:12) + Adv
=(cid:12)(cid:12)Pr[ğ‘ŠA] âˆ’ Pr[ğ‘Š â€²
2
A] âˆ’ 1
2
InfoCPâ€²
Î ,A (ğœ…)
(cid:12)(cid:12)(cid:12)(cid:12)
(9)
B.2 Proof of the sigma-protocol from Figure 5
Proof. It is not hard to see that the protocol from Figure 5 is
perfectly complete. Furthermore, it satisfies 2-special soundness.
Indeed, from two different accepting transcripts with the same
Session 2E: Smart Contracts and Cryptocurrencies CCS '20, November 9â€“13, 2020, Virtual Event, USA655ğ‘¡ (cid:66) (ğ‘§ğ‘¡âˆ’Ë†ğ‘§ğ‘¡)/(ğ‘’âˆ’Ë†ğ‘’)
first message, but different challenges, say (ğ´1, ğ´2, ğ‘’, ğ‘§ğ‘ , ğ‘§ğ‘¡ , ğ‘§ğ‘¡â€²) and
(ğ´1, ğ´2, Ë†ğ‘’, Ë†ğ‘§ğ‘ , Ë†ğ‘§ğ‘¡ , Ë†ğ‘§ğ‘¡â€²), where ğ‘’ â‰ ğ‘ Ë†ğ‘’, let:
ğ‘¡â€² (cid:66) (ğ‘§ğ‘¡â€²âˆ’Ë†ğ‘§ğ‘¡â€²)/(ğ‘’âˆ’Ë†ğ‘’) .
ğ‘  (cid:66) (ğ‘§ğ‘ âˆ’Ë†ğ‘§ğ‘ )/(ğ‘’âˆ’Ë†ğ‘’)
It turns out that (ğ‘ , ğ‘¡, ğ‘¡â€²) is a valid witness. Finally, the protocol
is honest-verifier zero-knowledge by a simulator that outputs an
accepting transcript (ğ´1, ğ´2, ğ‘, ğ‘§ğ‘ , ğ‘§ğ‘¡), identically distributed to a
real one, as follows: on input ğ‘’ âˆˆ Zğ‘, sample ğ‘§ğ‘ , ğ‘§ğ‘¡ , ğ‘§ğ‘¡â€² â†$ Zğ‘ and
compute ğ´1 (cid:66) ğ‘§ğ‘  ğ´ + ğ‘§ğ‘¡ ğµ âˆ’ ğ‘’ ğ¶ and ğ´2 (cid:66) ğ‘§ğ‘  ğ´â€² + ğ‘§ğ‘¡â€² ğµâ€² âˆ’ ğ‘’ ğ¶â€². â–¡
B(ğ‘…, ğœğ‘˜) :
call A on input ğ‘…, getting (crs, ğœ) and let Ë†ğœ (cid:66) (ğœ, ğœğ‘˜)
output (crs, Ë†ğœ) to the tS-WI challenger
BO(ğ‘…,crs,ğ‘,Â·,Â·,Â·)( Ë†ğœ) :
parse Ë†ğœ as (ğœ, ğœğ‘˜) and run A on input ğœ
on every query (ğ‘ ) by A to its oracle:
if ğ‘“ (ğ‘ ) = 0, return âŠ¥
sample ğ‘Ÿ0 â†$ {0, 1}ğœ…
set ğ‘ (cid:66) Encğ‘Ÿ0(ğ‘ ); ğ‘¦ (cid:66) Fğœ…(ğ‘Ÿ0); set ğ‘Ÿ1 (cid:66) H-1
ğœ… (ğœğ‘˜, ğ‘¦)
query ((ğ‘, ğ‘¦), ğ‘Ÿ0, ğ‘Ÿ1) to the tS-WI oracle, to get ğœ‹
send (ğ‘, ğ‘¦, ğœ‹) to A
when A outputs ğ‘â€²
A, return ğ‘â€² (cid:66) ğ‘â€²
A
Figure 6: Adversary B against the tS-WI game, based on ad-
versary A against the InfoCPâ€² game.
Session 2E: Smart Contracts and Cryptocurrencies CCS '20, November 9â€“13, 2020, Virtual Event, USA656