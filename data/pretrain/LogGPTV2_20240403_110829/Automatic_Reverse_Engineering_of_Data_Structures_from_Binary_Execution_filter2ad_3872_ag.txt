For example, the char[12] buffer in bftpd denotes a
packet received from outside (the recv category). Note
that the input categories are conveniently implemented as
semantics tags in REWARDS. The 4th column offset
represents the input offsets reported by our fuzzer. They
represent the places that are mutated to generate the real
exploits. The REWARDS-based vulnerability detector also
emits vulnerability types (shown in the 5th column) based
on the vulnerability patterns matched. Consider the ﬁrst
benchmark ncompress: Its entry in the table indicates
that the char[13] buffer inside a function starting with
PC 0x08048e76 is vulnerable to stack buffer overﬂow.
The buffer receives values from the second command line
option (argv[1]). Our data lineage fuzzer mutates the
lineage of the buffer, which are the ﬁrst 12 input items
(offset 0 to 11) to generate the exploit. From the data
structure in the 2nd column, the exploit has to contain a
byte string longer than 1052 bytes to overwrite the return
address at the bottom. Other vulnerabilities can be similarly
apprehended.
6 Discussion
REWARDS has a number of limitations: (1) As a dy-
namic analysis-based approach, REWARDS cannot achieve
full coverage of data structures deﬁned in a program.
Instead, the coverage of REWARDS relies on those data
structures that are actually created and accessed during a
particular run of the binary. (2) REWARDS is not fully on-
line as our timestamp-based on-line algorithm may leave
some variables unresolved by the time they are de-allocated,
and thus the off-line companion procedure is needed to
make the system sound. A fully on-line type resolution
algorithm is our future work. (3) Based on PIN, REWARDS
does not support the reverse engineering of kernel-level data
structures. (4) REWARDS does not work with obfuscated
code. Thus it is possible that an adversary can write an
obfuscated program to dodge REWARDS – for example,
by avoiding touching the type sinks we deﬁne. (5) Besides
the general data structures, REWARDS has yet to support
the extraction of other data types, such as the format of a
speciﬁc type of ﬁles (e.g., ELF ﬁles, multimedia ﬁles), and
browser-related data types (e.g., URL, cookie). Moreover,
REWARDS does not distinguish between sign and unsigned
integers in our current implementation.
7 Related Work
Type inference. Some programming languages, such as
ML, do not explicitly declare types. Instead, types are in-
ferred from programs. Typing constraints are derived from
program statements statically and programs are typed by
solving these constraints. Notable type inference algorithms
include Hindley-Milner algorithm [29], Cartesian Product
algorithm [3], iterative type analysis [13], object oriented
type inference [33], and aggregate structure identiﬁcation
[35].
These techniques, like REWARDS, rely on type uni-
ﬁcation, namely, variables connected by operators shall
have the same type. However, these techniques assume
program source code and they are static, that is, typing
constraints are generated from source code at compile time.
For REWARDS, we only assume binaries without symbolic
information, in which high level language artifacts are all
broken down to machine level entities, such as registers,
memory addresses, and instructions. REWARDS relies
on type sinks to obtain the initial type and semantics
information. Variables are then typed through uniﬁcation
with type sinks during execution.
Lately, Balakrishnan et al.
[4, 5, 36] showed that
analyzing executables alone can largely discover syntactic
structures of variables, such as sizes, ﬁeld offsets, and
simple structures. Their technique entails points-to analysis
and abstract interpretation at binary level. They cannot han-
dle obfuscated binaries and dynamically loaded libraries.
Furthermore, the inaccuracy of binary points-to analysis
makes it hard to type heap variables. In comparison, our
technique is relatively simple, with the major hindrances
to static analysis (e.g., points-to relations and dynamically
loaded libraries) addressed via dynamic analysis.
Abstract type inference. Abstract type inference [32]
is to group typed variables according to their semantics.
For example, variables that are meant to store money, zip
codes, ages, etc., are clustered based on their intention’s,
even though they may have the same integer type. Such
an intention is called an abstract type. The technique relies
on the Hindley-Milner type inference algorithm. Recently,
dynamic abstract type inference is proposed [24] to infer
abstract types from execution. Regarding the goal of
performing semantics-aware typing, these techniques and
ours are similar. However, they work at the source code
level whereas ours works at the binary level. Our technique
further derives syntactic type structures.
Decompilation. Decompilation is a process of recon-
structing program source code from lower-level languages
(e.g., assembly or machine code) [14, 20, 6].
It usually
involves reconstructing variable types [31, 19]. By using
uniﬁcation, Mycroft [31] extends the Hindley-Milner algo-
rithm [29] and delays uniﬁcation until all constraints are
available. Recently, Dolgova and Chernov [19] present an
iterative algorithm that uses a lattice over the properties of
data types for reconstruction.
All these techniques are static and hence share the same
limitations of static type inference and they only derive
simple syntactic structures. Moreover, they aim to get
an execution-equivalent code and do not pay attention to
whether the recovered types reﬂect the original declarations
and have the same structures.
Protocol format reverse engineering. Recent efforts in
protocol reverse engineering involve using dynamic binary
analysis (in particular input data taint analysis) to reveal
the format of protocol messages, facilitated by instruction
semantics (e.g., Polyglot [9]) or execution context (e.g.,
AutoFormat [25]). Recently, it has been shown that the
BNF structure of a given protocol with multiple messages
can be derived [40, 17, 28]; and the format of out-going
messages as well as encrypted messages can be revealed
[8, 39]. In particular, REWARDS shares the same insight as
Dispatcher [8] for type inference and semantics extraction.
The difference is that Dispatcher and other protocol reverse
engineering techniques mainly focus on live input and
output messages, whereas we strive to reveal general data
structures in a program. Meanwhile, we care more about
the detailed in-memory layout of program data, motivated
by our different targeted application scenarios.
[34]
is a toolkit
Memory forensics and vulnerability discovery.
FATKit
to facilitate the extraction,
analysis, aggregation, and visualization of forensic data.
Their technique is based on pre-deﬁned data structures
extracted from program source code to type memory
dumps. This is also the case for other similar systems
(e.g., [12, 30, 2]). KOP [11] is an effective system that
can map dynamic kernel objects with nearly complete
coverage and perfect accuracy.
It also relies on program
source code and uses an inter-procedural points-to analysis
to compute all possible types for generic pointers. There
are several other efforts [37, 18] that use data structure
signatures to scan and type memory. Complementing these
efforts, REWARDS extracts data structure deﬁnitions and
reconstructs hierarchical in-memory layouts from binaries.
There is a large body of research in vulnerability dis-
covery such as Archer [41], EXE [10], Bouncer [15],
BitScope [7], DART [22], and SAGE [23, 21]. REWARDS
complements these techniques by enabling identiﬁcation of
vulnerability suspects directly from binaries.
8 Conclusion
We have presented the REWARDS reverse engineering
system that automatically reveals data structures in a bi-
nary based on dynamic execution. REWARDS involves
an algorithm that performs data ﬂow-based type attribute
forward propagation and backward resolution. Driven by
the type information derived, REWARDS is also capable
of reconstructing the structural and semantic view of in-
memory data layout. Our evaluation using a number of real-
world programs indicates that REWARDS achieves high
accuracy in revealing data structures accessed during an
execution. Furthermore, we demonstrate the beneﬁts of
REWARDS to two application scenarios: memory image
forensics and binary vulnerability discovery.
9 Acknowledgment
We would like to thank the anonymous reviewers for
their insightful comments. We are grateful to Xuxian Jiang
and Heng Yin for earlier discussions and help on this and
related problems. This research is supported, in part, by the
Ofﬁce of Naval Research (ONR) under grant N00014-09-1-
0776 and by the National Science Foundation (NSF) under
grant 0720516. Any opinions, ﬁndings, and conclusions or
recommendations in this paper are those of the authors and
do not necessarily reﬂect the views of the ONR or NSF.
References
[1] Libdwarf. http://reality.sgiweb.org/davea/dwarf.html.
[2] Mission critical
linux.
In Memory Core Dump,
http://oss.missioncriticallinux.com/projects/mcore/.
[3] O. Agesen. The cartesian product algorithm: Simple and
In
precise type inference of parametric polymorphism.
Proceedings of the 9th European Conference on Object-
Oriented Programming (ECOOP’95), pages 2–26, London,
UK, 1995. Springer-Verlag.
[4] G. Balakrishnan, , G. Balakrishnan, and T. Reps. Analyzing
memory accesses in x86 executables. In Proceedings of In-
ternational Conference on Compiler Construction (CC’04),
pages 5–23. Springer-Verlag, 2004.
[5] G. Balakrishnan and T. Reps. Divine: Discovering variables
In Proceedings of International Conf. on
in executables.
Veriﬁcation Model Checking and Abstract Interpretation
(VMCAI’07), Nice, France, 2007. ACM Press.
[6] P. T. Breuer and J. P. Bowen. Decompilation: the enumer-
ation of types and grammars. ACM Trans. Program. Lang.
Syst., 16(5):1613–1647, 1994.
[7] D. Brumley, C. Hartwig, M. G. Kang, Z. Liang, J. Newsome,
P. Poosankam, D. Song, and H. Yin. Bitscope: Automatically
dissecting malicious binaries, 2007. Technical Report CMU-
CS-07-133, Carnegie Mellon University.
[8] J. Caballero, P. Poosankam, C. Kreibich, and D. Song. Dis-
patcher: Enabling active botnet inﬁltration using automatic
protocol reverse-engineering.
In Proceedings of the 16th
ACM Conference on Computer and and Communications
Security (CCS’09), pages 621–634, Chicago, Illinois, USA,
2009.
[9] J. Caballero and D. Song. Polyglot: Automatic extraction
of protocol format using dynamic binary analysis.
In
Proceedings of the 14th ACM Conference on Computer and
and Communications Security (CCS’07), pages 317–329,
Alexandria, Virginia, USA, 2007.
[10] C. Cadar, V. Ganesh, P. M. Pawlowski, D. L. Dill, and
D. R. Engler. Exe: automatically generating inputs of death.
In Proceedings of the 13th ACM conference on Computer
and communications security (CCS’06), pages 322–335,
Alexandria, Virginia, USA, 2006. ACM.
[11] M. Carbone, W. Cui, L. Lu, W. Lee, M. Peinado, and
X. Jiang. Mapping kernel objects to enable systematic in-
tegrity checking. In The 16th ACM Conference on Computer
and Communications Security (CCS’09), pages 555–565,
Chicago, IL, USA, 2009.
[12] A. Case, A. Cristina, L. Marziale, G. G. Richard, and
V. Roussev. Face: Automated digital evidence discovery
and correlation. Digital Investigation, 5(Supplement 1):S65
– S75, 2008. The Proceedings of the Eighth Annual DFRWS
Conference.
[13] C. Chambers and D. Ungar.
Iterative type analysis and
extended message splitting: Optimizing dynamically-typed
object-oriented programs. In Proceedings of the SIGPLAN
Conference on Programming Language Design and Imple-
mentation, pages 150–164, 1990.
[14] C. Cifuentes. Reverse Compilation Techniques. PhD thesis,
Queensland University of Technology, 1994.
[15] M. Costa, M. Castro, L. Zhou, L. Zhang, and M. Peinado.
Bouncer: securing software by blocking bad input. In Pro-
ceedings of the 21st ACM SIGOPS symposium on Operating
systems principles (SOSP’07), pages 117–130, Stevenson,
Washington, USA, 2007. ACM.
[16] A. Cozzie, F. Stratton, H. Xue, and S. T. King. Digging
for data structures.
In Proceeding of 8th Symposium on
Operating System Design and Implementation (OSDI’08),
pages 231–244, San Diego, CA, December, 2008.
[17] W. Cui, M. Peinado, K. Chen, H. J. Wang, and L. Irun-
Briz. Tupni: Automatic reverse engineering of input formats.
In Proceedings of the 15th ACM Conference on Computer
and Communications Security (CCS’08), pages 391–402,
Alexandria, Virginia, USA, October 2008.
[18] B. Dolan-Gavitt, A. Srivastava, P. Traynor, and J. Gifﬁn. Ro-
bust signatures for kernel data structures. In Proceedings of
the 16th ACM conference on Computer and communications
security (CCS’09), pages 566–577, Chicago, Illinois, USA,
2009. ACM.
[19] E. N. Dolgova and A. V. Chernov. Automatic reconstruction
Program.
of data types in the decompilation problem.
Comput. Softw., 35(2):105–119, 2009.
[20] M. V. Emmerik and T. Waddington. Using a decompiler
for real-world source recovery. In Proceedings of the 11th
Working Conference on Reverse Engineering, pages 27–36,
2004.
[21] P. Godefroid, A. Kiezun, and M. Y. Levin. Grammar-based
In Proceedings of the ACM SIGPLAN
whitebox fuzzing.
[33] J. Palsberg and M. I. Schwartzbach. Object-oriented type
inference.
In OOPSLA ’91: Conference proceedings on
Object-oriented programming systems, languages, and ap-
plications, pages 146–161, Phoenix, Arizona, United States,
1991. ACM.
[34] N. L. Petroni, Jr., A. Walters, T. Fraser, and W. A. Arbaugh.
Fatkit: A framework for the extraction and analysis of
digital forensic data from volatile system memory. Digital
Investigation, 3(4):197 – 210, 2006.
[35] G. Ramalingam, J. Field, and F. Tip. Aggregate structure
In
identiﬁcation and its application to program analysis.
Proceedings of the 26th ACM SIGPLAN-SIGACT symposium
on Principles of programming languages (POPL’99), pages
119–132, San Antonio, Texas, 1999. ACM.
[36] T. W. Reps and G. Balakrishnan. Improved memory-access
analysis for x86 executables. In Proceedings of International
Conference on Compiler Construction (CC’08), pages 16–
35, 2008.
[37] A. Schuster. Searching for processes and threads in mi-
crosoft windows memory dumps. Digital Investigation,
3(Supplement-1):10–16, 2006.
[38] T. Wang, T. Wei, Z. Lin, and W. Zou.
Intscope: Au-
tomatically detecting integer overﬂow vulnerability in x86
binary using symbolic execution. In Proceedings of the 16th
Annual Network and Distributed System Security Symposium
(NDSS’09), San Diego, CA, February 2009.
[39] Z. Wang, X. Jiang, W. Cui, X. Wang, and M. Grace. Refor-
mat: Automatic reverse engineering of encrypted messages.
In Proceedings of 14th European Symposium on Research
in Computer Security (ESORICS’09), Saint Malo, France,
September 2009. LNCS.
[40] G. Wondracek, P. Milani, C. Kruegel, and E. Kirda. Auto-
matic network protocol analysis. In Proceedings of the 15th
Annual Network and Distributed System Security Symposium
(NDSS’08), San Diego, CA, February 2008.
[41] Y. Xie, A. Chou, and D. Engler. Archer: using sym-
bolic, path-sensitive analysis to detect memory access errors.
In Proceedings of the 9th European software engineering
conference held jointly with 10th ACM SIGSOFT interna-
tional symposium on Foundations of software engineering
(ESEC/FSE-10), pages 327–336, Helsinki, Finland, 2003.
Conference on Programming Language Design and Imple-
mentation (PLDI’08), pages 206–215, Tucson, AZ, USA,
2008. ACM.
[22] P. Godefroid, N. Klarlund, and K. Sen. Dart: directed
automated random testing. In Proceedings of the 2005 ACM
SIGPLAN conference on Programming language design and
implementation (PLDI’05), pages 213–223, Chicago, IL,
USA, 2005. ACM.
[23] P. Godefroid, M. Levin, and D. Molnar. Automated whitebox
fuzz testing.
In Proceedings of the 15th Annual Network
and Distributed System Security Symposium (NDSS’08), San
Diego, CA, February 2008.
[24] P. J. Guo, J. H. Perkins, S. McCamant, and M. D. Ernst.
Dynamic inference of abstract types.
In Proceedings of
the 2006 international symposium on Software testing and
analysis (ISSTA’06), pages 255–265, Portland, Maine, USA,
2006. ACM.
[25] Z. Lin, X. Jiang, D. Xu, and X. Zhang. Automatic protocol
format reverse engineering through context-aware monitored
execution.
In Proceedings of the 15th Annual Network
and Distributed System Security Symposium (NDSS’08), San
Diego, CA, February 2008.
[26] Z. Lin, X. Zhang, and D. Xu. Convicting exploitable
software vulnerabilities: An efﬁcient input provenance based
approach.
In Proceedings of the 38th Annual IEEE/IFIP
International Conference on Dependable Systems and Net-
works (DSN’08), Anchorage, Alaska, USA, June 2008.
[27] C.-K. Luk, R. Cohn, R. Muth, H. Patil, A. Klauser,
G. Lowney, S. Wallace, V. J. Reddi, and K. Hazelwood. Pin:
building customized program analysis tools with dynamic
instrumentation. In Proceedings of ACM SIGPLAN Confer-
ence on Programming Language Design and Implementation
(PLDI’05), pages 190–200, Chicago, IL, USA, 2005.
[28] P. Milani Comparetti, G. Wondracek, C. Kruegel, and
E. Kirda. Prospex: Protocol Speciﬁcation Extraction.
In
IEEE Symposium on Security & Privacy, pages 110–125,
Oakland, CA, 2009.
[29] R. Milner. A theory of type polymorphism in programming.
Journal of Computer and System Sciences, 17:348–375,
1978.
[30] P. Movall, W. Nelson, and S. Wetzstein. Linux physical
memory analysis.
In Proceedings of the USENIX Annual
Technical Conference, pages 39–39, Anaheim, CA, 2005.
USENIX Association.
[31] A. Mycroft. Type-based decompilation (or program recon-
struction via type reconstruction).
In Proceedings of the
8th European Symposium on Programming Languages and
Systems (ESOP’99), pages 208–223, London, UK, 1999.
Springer-Verlag.
[32] R. O’Callahan and D. Jackson. Lackwit: a program under-
standing tool based on type inference.
In Proceedings of
the 19th international conference on Software engineering,
pages 338–348, Boston, Massachusetts, United States, 1997.
ACM.