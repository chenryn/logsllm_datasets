# 小结今天这篇文章，我给你介绍了 MySQL 不同的自增 id达到上限以后的行为。数据库系统作为一个可能需要 7\*24小时全年无休的服务，考虑这些边界是非常有必要的。每种自增 id 有各自的应用场景，在达到上限后的表现也不同：1.  表的自增 id    达到上限后，再申请时它的值就不会改变，进而导致继续插入数据时报主键冲突的错误。2.  row_id 达到上限后，则会归 0 再重新递增，如果出现相同的    row_id，后写的数据会覆盖之前的数据。3.  Xid 只需要不在同一个 binlog    文件中出现重复值即可。虽然理论上会出现重复值，但是概率极小，可以忽略不计。4.  InnoDB 的 max_trx_id 递增值每次 MySQL    重启都会被保存起来，所以我们文章中提到的脏读的例子就是一个必现的    bug，好在留给我们的时间还很充裕。5.  thread_id 是我们使用中最常见的，而且也是处理得最好的一个自增 id    逻辑了。当然，在 MySQL 里还有别的自增 id，比如 table_id、binlog文件序号等，就留给你去验证和探索了。不同的自增 id有不同的上限值，上限值的大小取决于声明的类型长度。而我们专栏声明的上限id 就是 45，所以今天这篇文章也是我们的最后一篇技术文章了。既然没有下一个 id了，课后也就没有思考题了。今天，我们换一个轻松的话题，请你来说说，读完专栏以后有什么感想吧。这个"感想"，既可以是你读完专栏前后对某一些知识点的理解发生的变化，也可以是你积累的学习专栏文章的好方法，当然也可以是吐槽或者对未来的期望。欢迎你给我留言，我们在评论区见，也欢迎你把这篇文章分享给更多的朋友一起阅读。![](Images/48edcb93fb03e3e52d7e7099be6b5cb3.png){savepage-src="https://static001.geekbang.org/resource/image/09/77/09c1073f99cf71d2fb162a716b5fa577.jpg"}
# 15 \| 答疑文章（一）：日志和索引相关问题在今天这篇答疑文章更新前，MySQL 实战这个专栏已经更新了 14篇。在这些文章中，大家在评论区留下了很多高质量的留言。现在，每篇文章的评论区都有热心的同学帮忙总结文章知识点，也有不少同学提出了很多高质量的问题，更有一些同学帮忙解答其他同学提出的问题。在浏览这些留言并回复的过程中，我倍受鼓舞，也尽我所知地帮助你解决问题、和你讨论。可以说，你们的留言活跃了整个专栏的氛围、提升了整个专栏的质量，谢谢你们。评论区的大多数留言我都直接回复了，对于需要展开说明的问题，我都拿出小本子记了下来。这些被记下来的问题，就是我们今天这篇答疑文章的素材了。到目前为止，我已经收集了 47个问题，很难通过今天这一篇文章全部展开。所以，我就先从中找了几个联系非常紧密的问题，串了起来，希望可以帮你解决关于日志和索引的一些疑惑。而其他问题，我们就留着后面慢慢展开吧。
# 日志相关问题我在第 2 篇文章[《日志系统：一条 SQL更新语句是如何执行的？》](https://time.geekbang.org/column/article/68633)中，和你讲到binlog（归档日志）和 redolog（重做日志）配合崩溃恢复的时候，用的是反证法，说明了如果没有两阶段提交，会导致MySQL 出现主备数据不一致等问题。在这篇文章下面，很多同学在问，在两阶段提交的不同瞬间，MySQL如果发生异常重启，是怎么保证数据完整性的？``{=html}现在，我们就从这个问题开始吧。我再放一次两阶段提交的图，方便你学习下面的内容。![](Images/5c8cabdda5c82c1aa0bf04a57805e07b.png){savepage-src="https://static001.geekbang.org/resource/image/ee/2a/ee9af616e05e4b853eba27048351f62a.jpg"}```{=html}```图 1 两阶段提交示意图]{.reference}```{=html}```这里，我要先和你解释一个误会式的问题。有同学在评论区问到，这个图不是一个update 语句的执行流程吗，怎么还会调用 commit 语句？他产生这个疑问的原因，是把**两个"commit"的概念**混淆了：-   他说的"commit 语句"，是指 MySQL    语法中，用于提交一个事务的命令。一般跟 begin/start transaction    配对使用。-   而我们图中用到的这个"commit    步骤"，指的是事务提交过程中的一个小步骤，也是最后一步。当这个步骤执行完成后，这个事务就提交完成了。-   "commit 语句"执行的时候，会包含"commit 步骤"。而我们这个例子里面，没有显式地开启事务，因此这个 update语句自己就是一个事务，在执行完成后提交事务时，就会用到这个"commit步骤"。接下来，我们就一起分析一下**在两阶段提交的不同时刻，MySQL异常重启会出现什么现象。**如果在图中时刻 A 的地方，也就是写入 redo log 处于 prepare 阶段之后、写binlog 之前，发生了崩溃（crash），由于此时 binlog 还没写，redo log也还没提交，所以崩溃恢复的时候，这个事务会回滚。这时候，binlog还没写，所以也不会传到备库。到这里，大家都可以理解。大家出现问题的地方，主要集中在时刻 B，也就是 binlog 写完，redo log 还没commit 前发生 crash，那崩溃恢复的时候 MySQL 会怎么处理？我们先来看一下崩溃恢复时的判断规则。1.  如果 redo log 里面的事务是完整的，也就是已经有了 commit    标识，则直接提交；2.  如果 redo log 里面的事务只有完整的 prepare，则判断对应的事务 binlog    是否存在并完整：\    a. 如果是，则提交事务；\    b. 否则，回滚事务。这里，时刻 B 发生 crash 对应的就是 2(a)的情况，崩溃恢复过程中事务会被提交。现在，我们继续延展一下这个问题。
## 追问 1：MySQL 怎么知道 binlog 是完整的?回答：一个事务的 binlog 是有完整格式的：-   statement 格式的 binlog，最后会有 COMMIT；-   row 格式的 binlog，最后会有一个 XID event。另外，在 MySQL 5.6.2 版本以后，还引入了 binlog-checksum 参数，用来验证binlog 内容的正确性。对于 binlog日志由于磁盘原因，可能会在日志中间出错的情况，MySQL 可以通过校验checksum 的结果来发现。所以，MySQL 还是有办法验证事务 binlog的完整性的。
## 追问 2：redo log 和 binlog 是怎么关联起来的?回答：它们有一个共同的数据字段，叫 XID。崩溃恢复的时候，会按顺序扫描redo log：-   如果碰到既有 prepare、又有 commit 的 redo log，就直接提交；-   如果碰到只有 parepare、而没有 commit 的 redo log，就拿着 XID 去    binlog 找对应的事务。