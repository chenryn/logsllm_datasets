binder context manager during the loading process of Android.
After that, various service providers will register themselves
(via addService) so that other service users can look up and ask
for their services (via getService). Note that all these operations
are performed by passing IPC messages through /dev/binder.
Telephony Service
Telephony Service
Unix Domain
Socket
Internet
Socket
Telephony
Daemon
multiplexing
Telephony
Daemon
AirBag
Vendor Library
Hardware
Fig. 3. Telephony Virtualization in AirBag
To virtualize /dev/binder, we create a separate context
manager for AIR so that all subsequent services registration
or lookup will be performed independently within AirBag. In
our prototype, we have similarly created an array of context
managers indexed by respective namespace. With that, both
native runtime and AIR have their own servicemanager dae-
mons registering as the context managers that handle follow-
up addService/getService operations independently, such that
all inter-app communications (e.g., intents) are fully supported
within AirBag. Also, notice that binder is the ﬁrst system re-
source the Android runtime acquires, we can also conveniently
consider the moment when the device ﬁle /dev/binder is being
opened as the indication that a new namespace needs to be
created.
4) Telephony: The telephony support in Android largely re-
lies on a service daemon, rild, which loads vendor-proprietary
library (e.g., libhtc_ril.so) for controlling the underlying
hardware. In particular, a Java class com.android.internal
.telephony.RIL of Android runtime communicates with rild
via an Unix domain socket (created by rild) to proxy various
telephony services. To support necessary telephony functions
inside AIR, as we do not have access to vendor-speciﬁc source
code, we choose to multiplex the hardware access at the user
level rild. Speciﬁcally, in our prototype, we create a TCP
socket along with the normal Unix domain socket in rild that
runs in the native runtime. The new TCP socket is used to
accept incoming connections from the com.android.internal
.telephony.RIL inside AirBag ( Figure 3). In other words,
the rild inside AirBag is disabled (by adjusting the internal
startup script init.rc). By design, our current prototype allows
for outgoing phone calls from AirBag, but any incoming phone
calls will be automatically answered in the native runtime.3
5) Audio: For the audio device, we ﬁnd the support
on Nexus One straightforward as it exports a device ﬁle
3If the native runtime is currently not active when an incoming phone call
is received, we will automatically activate it to achieve the same level of user
experience.
6
/dev/q6dsp that allows for concurrent accesses. However, the
support on Nexus 7 and Galaxy S III is rather complicated.
Speciﬁcally, both devices adopt
the standard ALSA-based
audio driver [18] in OS kernel, which allows only one active
audio stream. In other words, if one namespace is currently
accessing the device, the other will not be able to access
it. Speciﬁcally, the process trying to access the audio device
would be put into a wait queue when the device is in use.
In our prototype, we take a similar approach with the
/dev/pmem device. Speciﬁcally, we add a separate virtual audio
stream for each namespace so that it will maintain exclusive
use within respective namespace. The virtual audio stream
from the active namespace will be bound to the hardware audio
stream at runtime. For example, in ALSA, an ioctl operation,
i.e., SNDRV_PCM_IOCTL_WRITEI_FRAMES is used to send audio
data to the device. Such an ioctl from the inactive runtime
would silently return without actually sending data to the
hardware. But for other ioctls to retrieve or update hardware
states such as SNDRV_PCM_IOCTL_SYNC_PTR, we maintain its
own latest cache of the states, which will then be applied
to hardware when its namespace becomes active. When an
inactive namespace becomes active, it is allowed to preempt
the use of the audio device.
6) Power Management: The presence of two runtimes also
complicates the power management. For example, when an
untrusted game app runs inside AirBag for a while, the native
runtime may time out and attempt to perform early suspend
on the entire phone, which includes turning off the screen. To
avoid causing inconvenience, our current prototype chooses to
disable any power-related operations from AirBag. In other
words, we only allow the native runtime to turn off or dim the
screen. In order to prevent the native runtime to sleep while
AirBag is active, it will require a wakelock [13] in the native
runtime before activating the AIR. The AIR still maintains its
own timeout for screen turn-off. But instead of actually turning
off the screen, it will release the wakelock. Also, when the app
inside AirBag terminates, it will then release the wakelock and
yield the control back to the native runtime.
C. Decoupled App Isolation Runtime
With a separate app isolation runtime, we have the op-
portunity to customize it
to better conﬁne untrusted apps
without affecting the original native runtime. As mentioned
earlier, we build the AIR by customizing Android Open Source
Project (AOSP 4.1.1) to export
the same interface while
in the meantime allowing users to choose different running
modes. In particular, the AIR’s root directory is relocated
with the pivot_root system call (so that any write operation
issued in AirBag would not corrupt the original ﬁles in the
ﬁrmware). Speciﬁcally, we build a unionfs [48] that copy-
on-writes all updates in a ﬁle-based ext4 disk image and
uses a base ﬁlesystem as a squashfs image for read-only
operations. Such an organization enables us to readily provide
the “restore to default” feature, which essentially removes
the dirty ﬁle-based ext4 disk image. Also, our system elim-
inates all potential personally-identifying information from
AIR for the “incognito” mode. For instance, the Android API
TelephonyManager.getDeviceId() has been instrumented to
return a faked IMEI number.
The layered design of AOSP also provides the opportu-
nity to proﬁle app behavior. For example, while analyzing
a malware, we usually leverage logcat,
to record various
Android API calls we are interested in. We note that the
collected log entries are pushed down from the namespace in
which the untrusted app runs, which does lead to the concern
of trustworthiness of collected log. However, from another
perspective, the actual dumped message is maintained by the
kernel-level log driver, which is assumed to be trusted (Section
II). Moreover, the proﬁling mode will turn on the systemtap
support [16] to record syscalls from AirBag (with conﬁned
apps) to external SD card for in-depth analysis.
In addition, our system also instruments the AIR to prevent
untrusted apps from performing stealthy actions (e.g., sending
SMSs to premium-rate numbers). In particular, by modify-
ing the Android API in com.android.internal.telephony
.RIL class, the untrusted app running inside AirBag mode
is prevented from performing any stealthy telephony action.
Further, thanks to the cgroup abstraction, we could white-
list the devices for AirBag access. Speciﬁcally, before starting
the AirBag namespace, we can write each allowed device ﬁle
name with the corresponding permission to the cgroups virtual
ﬁlesystem (e.g. /cgroup/airbag/devices.list). After that, all
the access to the device ﬁles not listed in the white-list would
be automatically blocked.
To maintain transparency, our scheme is seamlessly in-
tegrated with the native system without breaking user expe-
rience. Speciﬁcally, when the system boots up, the AirBag
environment is automatically initiated and then suspended.
Its suspension will be removed in two scenarios when the
user either (1) dispatches an app to it for isolation or (2)
launches a previously isolated app. In the ﬁrst case, our
customized PackageInstaller automatically guides the in-
stallation procedure by simply adding an “isolate” button
(Figure 4(a)). For each isolated app, our system will register
an “app stub” in the native Android runtime. In Figure 4(b),
we show the example app stub for an isolated game app
(com.creativemobi.DragRacing). For comparison, we also
install
the same game app inside the native runtime. The
difference in their icons is the addition of a lock sign on the
icon associated with the isolated app. When the user clicks
the app stub, AirBag is activated to execute the isolated app,
which transparently marks native runtime inactive and thus
yields underlying hardware accesses to AirBag. When the app
terminates, AirBag would make itself inactive and seamlessly
bring the native runtime up-front.
D. Lessons Learned
In the process of developing our early prototype on Nexus
7, we encounter an interesting problem that a benchmark
program running inside the AirBag always scores one fourth of
normal system, which indicates that AirBag only utilizes one
of the four available CPU cores. After further investigation,
it turns out that Nexus 7 has a CPU hotplug mechanism that
can dynamically put CPU cores online or ofﬂine based on
the workload of the whole system. However, due to a bug
[8] in Linux kernel 3.1.10, the CPU online events are not
properly delivered to AirBag, which then fails to scale up the
computation power when AirBag is fully loaded but the native
runtime is idle. We then backport the patches from mainline
7
TABLE II.
EFFECTIVENESS OF AIRBAG IN SUCCESSFULLY BLOCKING 20 REPRESENTATIVE ANDROID MALWARE
Malware Family
Retrieve IMEI
Retrieve Phone Number
Send SMS
Intercept SMS
Record Audio
Malicious Behavior
Damage Firmware
(w/ root exploits)
√
√
√
√
√
√
√
√
BeanBot
DKFBootKit
DroidKungFu
DroidLive
Fjcon
Geinimi
GingerMaster
GoldDream
HippoSMS
NickiBot
RogueLemon
RogueSPPush
RootSmart
SMSSpoof
SndApps
Spitmo
TGLoader
YZHCSMS
Zitmo
Zsone
√
√
√
√
√
√
√
√
Original App
App Stub
√
√
√
√
√
√
√
√
√
√
√
√
√
√
√
√
√
√
√
√
√
√
√
√
√
√
√
√
√
√
√
√
√
(a) Faked phone number is being accessed
(b) Faked phone number is being uploaded
Fig. 5. GoldDream Analysis
(a) Customized Package Installer
(b) App Stub
Fig. 4. Seamless Integration of AirBag
A. Effectiveness
Linux kernel [10] to have AirBag informed about the status of
available CPU cores whenever a CPU core is online or ofﬂine.
Another issue we encountered in our prototype is related
to the low-memory killer, which will be waked up to sacriﬁce
certain processes when the system is under high memory pres-
sure. As our prototype supports two concurrent namespaces,
the unknowing low-memory killer may pick up a process from
the active namespace as victim for termination, which greatly
affects user experience. Therefore, our prototype adjusts the
algorithm and makes it in favor of choosing processes from
inactive runtime as victims to maintain responsive user expe-
rience.
IV. EVALUATION
In this section, we present the evaluation results by ﬁrst
showing the effectiveness of AirBag with various mobile
malware. We then measure the impact on performance as well
as power consumption and memory usage.
8
To evaluate the effectiveness, we selected 20 Android
malware that present a good coverage of state-of-the-art mobile
malware in the wild. In Table II, we show the list and their
malicious behavior which is manually triggered. Speciﬁcally,
AirBag is able to successfully isolate these malicious apps
and prevent them from performing the malicious operations
in either Android framework level or OS kernel level. For
example, the way AirBag detects and prevents NickiBot from
recording audio is done by hooking the corresponding ioctls
(e.g., SNDRV_PCM_IOCTL_READI_FRAMES) of the ALSA-based
audio driver [18] in OS kernel while the relocation of the AIR’s
root directory and the usage of unionfs (Section III-C) enable
us to prevent ﬁrmware damages. We emphasize that AirBag
in all three supported mobile devices is able to achieve the
same results.4 In the following, we present details of three
representative experiments, to demonstrate the values from
incognito mode, proﬁling mode, and ﬂexible user conﬁrmation
for sensitive operations, respectively.
4The exceptional case is the Nexus 7 that is a tablet and does not have
necessary telephony support. However, it does not affect AirBag’s effectiveness
in isolating these apps.
a . e x e
unlink("/system/lib/libd1.so")
open("/data/buildarm/bin/a.exe", ...) = 3
open("/system/lib/libd1.so", ...) = 4
r e a d ( 3 ,   0 x b e 8 a 8 2 c c ,   4 0 9 6 )
write(4, "\177ELF\1\1\1", 4096)
...
close(3); close(4)
unlink("/system/bin/rm") = 0
open("/system/lib/libd1.so", ...) = 3
open("/system/bin/rm", ...) = 4
r e a d ( 3 ,   0 x b e 8 a 8 2 c c ,   4 0 9 6 )
write(4, "\177ELF\1\1\1", 4096)
...
r m   / s y s t e m / b i n / m o u n t  
(or other compromised files)
rm /system/bin/logcat 
(or other not compromised files)
 Try /system/xbin/rm
access("/system/xbin/rm", F_OK) 
= -2 (ENOENT)
                    exit without any 
                         unlink call
 /system/xbin/rm not found 
use /system/bin/toolbox
execve(/system/bin/toolbox rm 
/system/bin/logcat)