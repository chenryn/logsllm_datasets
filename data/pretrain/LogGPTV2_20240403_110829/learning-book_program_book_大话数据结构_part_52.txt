数，因此结果当然也是相同的。
所以说，散列技术既是一种存储方法，也是一种查找方法。然而它与线性表、
树、图等结构不同的是，前面几种结构，数据元素之间都存在某种逻辑关系，可以用
连线图示表示出来，面散列技术的记录之间不存在什么逻辑关系，它只与关键字有关
355
---
## Page 380
大语数据结构
联。因此，散列主要是面向查找的存储结构。
散列技术最适合的求解问题是查找与给定值相等的记录。对于查找来说，简化了
比较过程，效率就会大大提高。但万事有利就有弊，散列技术不具备很多常规数据结
构的能力。
比如那种同样的关键字，它能对应很多记录的情况，却不适合用散列技术。一个
班级几十个学生，他们的性别有男有女，你用关键字“男”去查找，对应的有许多学
生的记录，这显然是不合适的。只有如用班级学生的学号或者身份证号来散列存储，
此时一个号码唯一对应一个学生才比较合适。
同样散列表也不适合范围查找，比如查找一个班级18~22岁的同学，在散列表
中没法进行。想获得表中记录的排序也不可能，像最大值、最小值等结果也都无法从
散列表中计算出来。
我们说了这么多，散列函数应该如何设计？这个我们需要重点来讲解，总之设计
一个简单、均匀、存储利用率高的散列函数是散列技术中最关键的问题。
另一个问题是冲突。在理想的情况下，每一个关键字，通过散列函数计算出来的
地址都是不一样的，可现实中，这只是一个理想。我们时常会碰到两个关键字key*
key2，但是却有f（key）=f（key2），这种现象我们称为冲突（collision），并把key和
key称为这个散列函数的同义词（synonym）。出现了冲突当然非常糟糕，那将造成数
据查找错误。尽管我们可以通过精心设计的散列函数让冲突尽可能的少，但是不能
完全避免。于是如何处理冲突就成了一个很重要的课题，这在我们后面也需要详细
讲解。
8.10散列函数的构造方法
不管做什么事要达到最优都不容易，既要付出尽可能的少，又要得到最大化的
多。那么什么才算是好的散列函数呢？这里我们有两个原则可以参考。
1.计算简单
你说设计一个算法可以保证所有的关键字都不会产生冲突，但是这个算法需要很
复杂的计算，会耗费很多时间，这对于需要频繁地查找来说，就会大大降低查找的效
率了。因此散列函数的计算时间不应该超过其他查找技术与关键字比较的时间。
356
---
## Page 381
第8章查找
2.散列地址分布均匀
我们刚才也提到冲突带来的问题，最好的办法就是尽量让散列地址均匀地分布在
存储空间中，这样可以保证存储空间的有效利用，并减少为处理冲突而耗费的时间。
接下来我们就要介绍几种常用的散列函数构造方法。估计设计这些方法的前辈们
当年可能是从事间谋工作，因为这些方法都是将原来数字按某种规律变成另一个数字
而已。
8.10.1直接定址法
如果我们现在要对0~100岁的人口数字统计表，如表8-10-1所示，那么我们对
年龄这个关键字就可以直接用年龄的数字作为地址。此时f（key）=key。
表8-10-1
年龄人数
00
0
500万
01
1
600万
02
2
450万
20
20
1500万
..
如果我们现在要统计的是80后出生年份的人口数，如表8-10-2所示，那么我们
对出生年份这个关键字可以用年份减去1980来作为地址。此时f（key）=key-1980。
表8-10-2
地址
出生年份人数
00
1980
1500万
01
1981
1600万
02
1982
1300万
*
2000
2000
800万
也就是说，我们可以取关键字的某个线性函数值为散列地址，即
f（key）=axkey+b（a、b为常数）
这样的散列函数优点就是简单、均匀，也不会产生冲突，但问题是这需要事先知
道关键字的分布情况，适合查找表较小且连续的情况。由于这样的限制，在现实应用
中，此方法虽然简单，但却并不常用。
357
---
## Page 382
大调数据结构
8.10.2数字分析法
如果我们的关键字是位数较多的数字，比如我们的11位手机号
“130xxxx1234”，其中前三位是接入号，一般对应不同运营商公司的子品牌，如130
是联通如意通、136是移动神州行、153是电信等；中间四位是HLR识别号，表示用
户号的归属地；后四位才是真正的用户号，如表8-10-3所示。
表8-10-3
130xxxx1234
130xxxx2345
138xxxx4829
138xxxx2396
138xxxx8354
易重复分布太集分布均匀，可
中某几个数字
用作散列地址
若我们现在要存储某家公司员工登记表，如果用手机号作为关键字，那么极有可
能前7位都是相同的。那么我们选择后面的四位成为散列地址就是不错的选择。如果
这样的抽取工作还是容易出现冲突问题，还可以对抽取出来的数字再进行反转（如
1234改成4321）、右环位移（如1234改成4123）、左环位移、甚至前两数与后两数
叠加（如1234改成12+34=46）等方法。总的目的就是为了提供一个散列函数，能够
合理地将关键字分配到散列表的各位置。
这里我们提到了一个关键词—抽取。抽取方法是使用关键字的一部分来计算散
列存储位置的方法，这在散列函数中是常常用到的手段。
数字分析法通常适合处理关键字位数比较大的情况，如果事先知道关键字的分布
且关键字的若干位分布较均匀，就可以考虑用这个方法。
8.10.3平方取中法
这个方法计算很简单，假设关键字是1234，那么它的平方就是1522756，再抽取
中间的3位就是227，用做散列地址。再比如关键字是4321，那么它的平方就是
18671041，抽取中间的3位就可以是671，也可以是710，用做散列地址。平方取中
法比较适合于不知道关键字的分布，面位数又不是很大的情况。
---
## Page 383
第8章查找
8.10.4折叠法
折叠法是将关键字从左到右分割成位数相等的几部分（注意最后一部分位数不够
时可以短些），然后将这几部分叠加求和，并按散列表表长，取后几位作为散列地址。
比如我们的关键字是9876543210，散列表表长为三位，我们将它分为四组，
987|654|32110，然后将它们叠加求和987+654+321+0=1962，再求后3位得到散列
地址为962。
有时可能这还不能够保证分布均匀，不妨从一端向另一端来回折叠后对齐相加。
比如我们将987和321反转，再与654和0相加，变成789+654+123+0=1566，此
时散列地址为566。
折叠法事先不需要知道关键字的分布，适合关键字位数较多的情况。
8.10.5除留余数法
此方法为最常用的构造散列函数方法。对于散列表长为m的散列函数公式为：
f（key）=keymodp（p≤m)
mod是取模（求余数）的意思。事实上，这方法不仅可以对关键字直接取模，也
可在折叠、平方取中后再取模。
很显然，本方法的关键就在于选择合适的P，P如果选得不好，就可能会容易产生
同义词。
例如表8-10-4，我们对于有12个记录的关键字构造散列表时，就用了f（key）
=key-mod12的方法。比如29mod12=5，所以它存储在下标为5的位置。
表8-10-4
1101684910
关键字122538151629786756212247
不过这也是存在冲突的可能的，因为12=2×6=3×4。如果关键字中有像18（3×
6）、30（5×6）、42（7×6）等数字，它们的余数都为6，这就和78所对应的下标位
置冲突了
甚至极端一些，对于表8-10-5的关键字，如果我们让p为12的话，就可能出现
下面的情况，所有的关键字都得到了0这个地址数，这未免也太糟糕了点。
359
---
## Page 384
大据数据结构
表8-10-5
0000000000004
我们不选用p=12来做除留余数法，而选用p=11，如表8-10-6所示。
图 8-10-6
1001684921
关键字1224364860728496108120132144
此就只有12和144有冲突，相对来说，就要好很多。
因此根据前辈们的经验，若散列表表长为m，通常p为小于或等于表长（最好接
近m）的最小质数或不包含小于20质因子的合数。
8.10.6随机数法
选择一个随机数，取关键字的随机函数值为它的散列地址。也就是f（key）
=random（key）。这里random是随机函数。当关键字的长度不等时，采用这个方法
构造散列函数是比较合适的。
有同学问，那如果关键字是字符串如何处理？其实无论是英文字符，还是中文字
符，也包括各种各样的符号，它们都可以转化为某种数字来对待，比如ASCII码或者
Unicode码等，因此也就可以使用上面的这些方法。
总之，现实中，应该视不同的情况采用不同的散列函数。我们只能给出一些考虑
的因素来提供参考：
1.计算散列地址所需的时间。
2.关键字的长度。
3.散列表的大小。
4.关键字的分布情况。
5.记录查找的频率。综合这些因素，才能决策选择哪种散列函数更合适。
8.11处理散列冲突的方法
我们每个人都希望身体健康，虽然疾病能够预防，但是不可避免，没有任何成年
人生下来到现在没有生过一次病。
360
---
## Page 385
第8章查找
从刚才除留余数法的例子也可以看出，我们设计得再好的散列函数也不可能完全
避免冲突，这就像我们再健康也只能尽量预防疾病，但却无法保证永远不得病一样，
既然冲突不能避免，就要考虑如何处理它。
那么当我们在使用散列函数后发现两个关键字keyi=keyz，但是却有f（key1）=f
（keyz），即有冲突时，怎么办呢？我们可以从生活中找寻思路。
试想一下，当你观望很久很久，终于看上一套房打算要买了，正准备下订金，人
家告诉你，这房子已经被人买走了，你怎么办？
对呀，再找别的房子呗！这其实就是一种处理冲突的方法一开放定址法。
8.11.1开放定址法
所谓的开放定址法就是一旦发生了冲突，就去寻找下一个空的散列地址，只要散
列表足够大，空的散列地址总能找到，并将记录存入。
它的公式是：
f（key）=（f（key）+d）MODm（d=1,2,3.…….,m-1）
比如说，我们的关键字集合为（12,67,56,16,25,37,22,29,15,47,48,34)，表长为12。
我们用散列函数f（key）=keymod12。
当计算前5个数（12.67,56，16,25}时，都是没有冲突的散列地址，直接存入，如表
8-11-1所示。
表8-11-1
关键字1225166756
计算key=37时，发现f（37）=1，此时就与25所在的位置冲突。于是我们应用
上面的公式f（37）=（f（37）+1）mod12=2。于是将37存入下标为2的位置。这
其实就是房子被人买了于是买下一间的作法，如表8-11-2所示。
表8-11-2
110189210
关键字12253716675622
接下来22,29，15,47都没有冲突，正常的存入，如表8-11-3所示。
表8-11-3
11168910
关键字12253715162967562247
361
---
## Page 386
大适数据结构
到了key=48，我们计算得到f（48）=0，与12所在的0位置冲突了，不要紧，
我们f（48）=（f（48）+1）mod12=1，此时又与25所在的位置冲突。于是f
（48）=（f（48）+2）mod12=2，还是冲突……一直到f（48）=（f（48）+6）mod
12=6时，才有空位，机不可失，赶快存入，如表8-11-4所示。
表 8-11-4
110168910
我们把这种解决冲突的开放定址法称为线性探测法。
从这个例子我们也看到，我们在解决冲突的时候，还会碰到如48和37这种本来
都不是同义词却需要争夺一个地址的情况，我们称这种现象为维积。很显然，堆积的
出现，使得我们需要不断处理冲突，无论是存入还是查找效率都会大大降低。
考虑深一步，如果发生这样的情况，当最后一个key=34，f（key）=10，与22所
在的位置冲突，可是22后面没有空位置了，反而它的前面有一个空位置，尽管可以
不断地求余数后得到结果，但效率很差。因此我们可以改进d=13，-12，22，-22
q²，-q²，（q≤m/2），这样就等于是可以双向寻找到可能的空位置。对于34来说，我
们取d=一1即可找到空位置了。另外增加平方运算的目的是为了不让关键字都聚集在
某一块区城。我们称这种方法为二次探测法。
f（key）=（f（key）+d）MODm（d=1²,-1²，2²，-2².…，q².-q²q≤m/2）
还有一种方法是，在冲突时，对于位移量山采用随机函数计算得到，我们称之为
随机操测法。
此时一定有人问，既然是随机，那么查找的时候不也随机生成d吗？如何可以获
得相同的地址呢？这是个问题。这里的随机其实是伪随机数。伪随机数是说，如果我
们设置随机种子相同，则不断调用随机函数可以生成不会重复的数列，我们在查找
时，用同样的随机种子，它每次得到的数列是相同的，相同的d当然可以得到相同的
散列地址。
嗯？随机种子又不知道？罢了罢了，不懂的还是去查阅资料吧，我不能在课上没
完没了的介绍这些基础知识呀。
f（key）=（f（key）+d）MODm（d是一个随机数列）
总之，开放定址法只要在散列表未填满时，总是能找到不发生冲突的地址，是我
们常用的解决冲突的办法。
362
---
## Page 387
第8章查找
8.11.2再散列函数法