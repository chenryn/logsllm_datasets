harder for the attacker to catch-up. To counter static analysis,
the program is obfuscated by ﬂattening the control ﬂow
structure so that attacker analysis will show up in the power
trace. We present the method for generating the IC-program
in the following sections.
A. IC-Program Structure
The IC-Program’s purpose is compute a hash of a subset
of the state of the untrusted machine, in order to assess the
integrity of the machine. The general ﬂow of the program
is a loop that reads a new memory location and updates
the state of the hash function. We obfuscate the high-level
structure by ﬂattening the control graph of the program using
the technique in [27]. The obfuscated program makes it harder
for the attacker to locate the load instructions necessary for a
memory redirection attack. Any static or active analysis will
be observed on the power trace and thus can be detected.
Note that
is randomly generated is not
polymorphic, that is the functionality of the program changes,
not just the structure.
the program that
A new hash function is used for every run of the protocol.
We chain randomly generated LFSRs, the outputs of which are
combined using a Boolean function (such as XOR). Figure 2
shows the high-level conﬁguration of the hash function. The
outputs of the LFSRs are accumulated with the data in a k bit
vector.
The chaining strategy deﬁnes the logic for enabling the
LFSRs. The input of the enable logic is the memory address
being processed, not the data itself. By using the memory
address, the attacker will have a harder time to perform a
memory redirection attack. The logic is constructed by creating
a random binary tree of depth n. The tree deﬁnes the control
ﬂow of each loop in the IC-program. The control variable at
each level is a unique memory address bit. Each level decides
if an LFSR is enabled or not. For each node, an LFSR is
enabled/disabled, and then the program counter jumps to either
child by comparing an address bit. In case the node only has
one child, the jump instruction will be omitted for a continuous
execution.
B. LFSR generation
On the other hand, each LFSR is also randomly generating
using randomly generated irreducible polynomials in a Galois
Field. An LFSR is related to polynomials in Galois ﬁeld
GF (2). The process for generating maximal LFSRs uses irre-
ducible polynomial p(x) of degree n. A maximal LFSR has the
highest period, the period of the LFSR is the time it takes for
the register to return to its initial state. A short period makes
it easier to predict the output. A polynomial is irreducible if
x2n = x mod p(x). For a polynomial p(x), the n-bit Galois
LFSR is constructed by tapping the positions in the register
that are part of p(x). In operation, bits that are tapped get
XOR’ed with the output bit and shifted, while untapped bits
are shifted without changed. The output bit is the input to the
LFSR. We generate random polynomials and apply the Ben-
Or irreducibility test [11]. The polynomials are generated by
sampling the uniform distribution, unif (1, 2n − 1). For ex-
ample, p = 24577 (binary representation 110000000000001)
encodes an LFSR where bits 1, 14, and 15 are tapped, that is
p(x) = 1 + x14 + x15.
V. POWER ANALYSIS
We verify the execution of POWERALERT-protocol using
the current drawn by the processor. We learn the normal
Power Finite State machine (PFSM) model using training data
from the machine. Then for each round of the POWERALERT-
protocol we extract the power states and conﬁrm that they are
generated by the normal model.
In the following section we explain the method for current
measurement, the method to extract the power states from
a current signal, the high-level PFSM model, the method to
learn the normal parameters of the model, and the method
for validation. Finally, we use the learned model to aid in the
parameter selection for IC-program generation.
A. Measurement Method
The current drawn by the processor is measured using a
current measuring loop placed around the line. Our setup
works for computers with motherboards that have separate
power line for the processor. Our generation and veriﬁcation
algorithms are not limited to any sampling rate; in fact, the
algorithms can be adapted for any sampling rate depending
on the needed accuracy. We measure the current directly by
tapping the line from the power supply to the CPU socket on
the motherboard; as opposed to measuring the power usage
by using the instrumentation provided by the processor as
the data will pass through the untrusted software stack. Such
data is susceptible to manipulation and cannot be trusted as
an absolute truth. On the other hand, direct measurement
provides a trusted side channel that we use to validate that
an untampered POWERALERT-protocol is executed.
The measured current signal
is either stored for model
learning or processed in real-time for POWERALERT-protocol
execution validation.
517
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 10:32:10 UTC from IEEE Xplore.  Restrictions apply. 
B. Extracting the Power States
(a) Memory read and hash current trace
We observe that the current drawn by a processor during
an operation takes the form of multi-power states, where each
state draws a current with a unique proﬁle. Such behavior is
consistent with the way a processor work: different operations
use different parts of the processor’s circuitry. As each part
of the processor switches dynamic current passes through the
transistors. Thus different combinations of the circuitry will
draw current with different proﬁles.
We start by extract the segments in the current signal that
belong to different power states, by ﬁnding areas of change of
operation modes. First, we ﬁlter the signal i(t) using a lowpass
ﬁlter, h1(t) to remove high frequency noise from the signal,
il(t) = i(t) ∗ h1(t), leading to the orange signal in Figure 3a.
Then we compute the derivative of the ﬁltered signal, I(t) =
dil(t)/dt. The derivative will be near zero for the segments
of i(t) with near constant current level (after ﬁltering) and
mode changes will be non-zero. We ﬁlter the derived signal
I(t) with another lowpass ﬁlter, h2(t), to remove more high
frequency noise, If (t) = I(t) ∗ h2(t). Finally, we extract the
segments between non-zero changes by computing a threshold
of the signal using an indicator function I>λ(t). The indicator
function is 1 if the absolute value of a signal is greater than
λ. The transformation leads us to ﬁnding the segments of the
signal with abrupt current changes, those segments are the
power states. For each segment in is = i(t) for ta < t < tb,
we compute its average Is = 1
ta is(t)dt and frequency
spectrum, Is(w) = F{is(t)}. Both indicators describe the
current proﬁle during the operation. The duration of each state
is computed as τ = tb − ta.
C. Power Execution Model
(cid:2) tb
tb−ta
We model the operations that take place in POWERALERT-
protocol, network and hashing operations, using an extended
Power Finite State Machines (PFSM). The model and timing
of each power state are used by POWERALERT to validate that
the POWERALERT-protocol was running untampered.
The PFSM, proposed by Pathak [23], is a state machine
where each state represents a power state Sk. We extend each
power state to contain the physical characteristics of each state
as a tuple (duration, average current, and frequency spectrum).
The POWERALERT-protocol starts by a network communi-
cation (network operation) between POWERALERT and the
machine. Then the machine is supposed to load and run
the IC-program (hash operation). The overall operation state
machine is shown in Figure 4. A PFSM has an initial idle
state S0 with power proﬁle (τ0, I0, I0(w)). When an operation
starts, a network receive with a TCP socket, the PFSM moves
deterministically to power state S1. If the network operation is
long, then the states cycles between S0 and S1 until network
communication is complete; this is due to data being pushed
from the network card to memory buffers. Figure 3b shows
the current trace drawn during a network operation. After
communication is done, the hosts loads the IC-program; PFSM
moves from the idle state S0 to S2. Then the hosts runs the
IC-program; PFSM moves to the S3 state. Figure 3a shows
518
)
A
(
t
n
e
r
r
u
c
3
2.5
2
1.5
1
0.5
0
i3=2.34A
i2=1.580A
i0= 870mA
2000
4000
6000
Time step (2 s)
8000
10000
(b) Network operation current trace
)
A
(
t
n
e
r
r
u
c
1.8
1.6
1.4
1.2
1
0.8
0.6
i1=1.360 A
i0=870 mA
0
2000
4000
6000
Time step (2s)
8000
10000
Fig. 3: Current drawn during network and memory read
operations.
idle
S0
load
S2
S3
hash
S1
network
Fig. 4: Power Finite State Machine (PFSM) of POWERALERT-
protocol
the current trace drawn during a hash operation. Finally, a
network operation returns the output to POWERALERT; the
PFSM moves from S0 to S1 and back to S0. In the following,
we explain the method for learning the normal PFSM of a
machine.
D. Learning the models
For each machine, we assume that we start the from an
initial uncompromised state. We establish a power behavioral
baseline, build the PFSM and a language for each operation,
and learn an execution time model. We initiate the POW-
ERALERT-protocol multiple times and store the current signal
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 10:32:10 UTC from IEEE Xplore.  Restrictions apply. 
for every run. For each signal the power states are extracted
using the method in section V-B and the current proﬁles of
are averaged. Moreover, we establish the idle power state by
measuring power when no applications are running.
In our test machine, an AMD Athlon 64 machine running
Linux 4.1.13, the average current drawn during the idle state
is 870mA, the average current drawn during the load phase
is 2.34A, the average current drawn during the hash phase
is 1.580A, and the average current drawn during the network
operation phase is 1.360A.
The idle state current depends on many factors including
the semiconductor manufacturing process. The manufacturing
process determines static power consumption (subthreshold
conduction and tunneling current) which is the current draw
when the gates are not switching. Thus the current levels in the
generated are unique to the machine and need to be learned
for each machine. We decided not fold in semiconductor
aging into the power model. Aging causes degradation of
the transistor leading to failures; however the time scale
where aging affects performance is in the order of 5 years.
Speciﬁcally, aging has no effect on dynamic power [13] but it
does affect threshold voltage. The static power is proportional
to the threshold voltage [30]. Studies have shown that the
threshold voltage varies within 1V during thermal accelerated
aging [5] which causes a 0.4% increase in static power. We
consider this increase insigniﬁcant
to incorporate into the
model especially that it requires years to happen.
In the following, we learn a timing model using the training
data from the machine to be inspected and we propose the
method of validating the execution of the POWERALERT-
protocol using the learned PFSM and the timing model.
Retraining the models: In order to retrain the model when
needed; for example when an operating system is updated.
We opt for the following procedure: (1) backup the data in
permanent storage, (2) wipe storage, (3) install a clean OS,
(4) collect training data and learn the models, and (5) restore
permanent storage. This process, given our assumption of no
hardware attacks, ensures that the attacker cannot interfere
with the training process, as the persistent storage is removed
during the training phase.
E. Learning Power State Timing
We use timing information in our system as part of the
validation process. Speciﬁcally, we conﬁrm that an adversary
is not trying to deceive POWERALERT by extracting the timing
information (duration) for each power state and compare it to
a learned model. By extracting the timing information using
the power signal we control the accuracy of the measure as
opposed to using network RTT in remote attestation schemes
which are affected by the network conditions. Moreover, we
have conﬁdence that the timing was not manipulated as it was
extracted from an untampered source. We learn the execution
time model for the hash phase and the network phase.
All IC-programs have a a complexity O(c · N ) where
N is the input size and c is the number of instruction
2.4
2.2
2
1.8
1.6
1.4
1.2
1
0.8
0.6
0
1000
2000
3000
4000
5000
6000
7000
8000
9000
10000
Fig. 5: Timing difference in current signal due to tampering.
per loop, and use the same type of instructions as any IC-
program. We postulate that any IC-program of equal input
size N and c number of instructions will have the same
execution time. Thus to obtain the training data for learning
the timing model, we generate IC-programs for different input
size and instruction count and ﬁnd the execution duration per
program. The experiments are repeated multiple times and the
results are averaged. We use multivariate regression to learn
a model of the execution time of the IC-program. The model
uses predictor variables x = [N, c] and a response variable
y = t (execution time). For our test machine, the duration
of the hash phase has is ﬁtted into a multi variate model
y = 1.3958 + 0.081x(1)− 0.017x(2) + 0.008x(1)× x(2) with
mean error σ = 5.4542μs. The mean error of the model is
signiﬁcant because it determines the leeway the adversary. If
the error is high, then the attacker has a wide gap to employ
evasion techniques. Figure 5 shows the impact of an attacker
injecting instructions into the program. The plot shows the
current signal measured during the hash phase. The blue signal
is the normal behavior, and the orange signal is the tampered
one. Both signals have the same power states. However the
tampered signal stays longer in the second state.