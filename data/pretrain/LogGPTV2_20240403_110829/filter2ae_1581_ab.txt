org.apache.solr.servlet.SolrDispatchFilter，拦截的范围是所有请求
所以我们首先就需要去这个SolrDispatchFilter这个类去观察
此时我们有两条分析接下来漏洞走向的方式，我们通过查阅网上的资料得知
我们去目录下查看一下
果然有这两个文件
然后我们看下两个文件的部分内容，先看下solrconfig.xml
可以看到velocity.params.resource.loader.enabled参数默认是flase，也就是说是默认是不开启的。
我们在看一看configoverlay.json文件
看到这里存储着我们上传上来的参数，这里我们将params.resource.loader.enabled制为true
我们可以通过观察该文件何时被修改来判断，是否该跟进代码中。
然后我们观察poc的时候不难发现请求的API为“/config”
我们通过查阅资料发现
Solr中有很多的RequestHandler，默认配置在solrconfig.xml中，同时也有很多没有配置在solrconfig.xml，称为隐式RequestHandler。而“/config”就是其中之一，我们可以看到SolrConfigHandler便是处理提交我们提交poc的API之一
但是为了，讲的更加清晰，我们还是从SolrDispatchFilter.doFilter方法来一步一步的跟踪。
首先SolrDispatchFilter.doFilter方法执行到第 423行的时候，
会调用HttpSolrCall.call方法
我们跟进这个方法
然后代码执行到execute()方法时configoverlay.json文件更新了 所以我们跟进这个函数继续跟进
按照上面的思路，执行到handler.handleRequest()继续跟进
此时就进入到了一开始我们从资料中所看到的“/config”所对应的类SolrConfigHandler
由于此时进入这个函数是为了调用它的handleRequestBody方法，所以我们接着向下执行
这里POST用来修改数据。GET用来查询数据，所以我们执行到
command.handlePOST()方法然后跟进
执行到handleCommands()方法 此时传入的opsCopy就是我们从前端传入的配置信息，而overlay时当前的配置信息
继续跟进，当执行到SolrResourceLoader.persistConfLocally()方法时
configoverlay.json，文件更新了
此时我们看到，关键参数时overlay.toButeArray()
而overlay参数最近的一次赋值动作是在这行代码里进行的，我们先跟进updateNamedPlugin()方法看一看
updateNamedPlugin方法中将op 和overlay参数都传入了进去
当执行到这个if判断时，判断为真，返回overlay，所以关键在于
Verifyclass()这个函数。
这里op仍然为我们 post传入的配置参数 clz的值为“solr.VelocityResponseWriter”
继续跟进
跟进函数之后我们看到这样一行代码
根据执行逻辑首先执行getCore方法，返回一个SolrCore对象
然后执行op.getDataMap()方法，返回一个Map对像
然后new 一个PluginInfo对象，构造方法里的主要操作就是向一个 NameList类型的对象中存值，存入的是我们POST传入的配置参数
createInitInstance()方法
泛型变量o是根据我们传入的参数PulginInfo对象的className属性“solr.VelocityResponseWriter”然后通过createInstance()方法反射获得的VelocityResponseWriter对象
因为VelocityResponseWriter对象实现了NamedListInitializedPlugin接口
所以执行
跟进
然后我们进入了VelocityResponseWriter对象的init方法，在这里有这么几行代码
可以看到在这里我们将VelocityResponseWriter对像的两个重要属性
paramsResourceLoaderEnabled，
solrResourceLoaderEnabled
设置为了true，也就是允许我们上传自定义模板了
紧接着init方法执行结束后，就会将VelocityResponseWriter对象按原路返回到SolrConfigHandler并赋值给overly属性
紧接着执行到第504行代码时configoverlay.json文件更新了，我们跟进这个方法
在调用SolrResourceLoader.persistConfLocally()方法时，可以看到我们将
overly作为参数传递了进去
此时观察代码我们就明白了，真正将我们post传递的配置参数写入文件的操作是在这一步进行的。至此 poc的第一部分追踪完毕。
### 4.3 POC第二部分执行和构造分析
接下来是poc执行的第二阶段
老规矩先从SolrDispatchFilter类看起
执行到HttpSolrCall.call步入
紧接着执行到HttpSolrCall.writeResponse方法
观察此刻传入的三个参数，solrRsp参数是一个 SolrQueryResponse对象，我们GET传入的playload存储在该对象的value属性中
这个responseWriter对象相当重要，这里我们看到了两个参数
paramsResourceLoaderEnabled和solrResourceLoaderEnabled
这是我们poc第一步中修改的两个配置属性，只有这两个属性为true我们才可以上传自定义模板成功
responseWriter参数指向的是一个VelocityResponseWriter对象，responseWriter最近一次被赋值是在，下面这行代码中
本着刨根问底，以及锻炼我们分析代码执行逻辑能力的目的，我们深入了解一下
我们跟踪进HttpSolrCall.getResponseWriter方法
可以看到，这里将我们GET穿入的key的值为wt的属性里面的值velocity取出并作为参数传给了core.getQueryResponseWriter方法，core参数指向的是一个SolrCore对象
跟入SolrCore.getQueryResponseWriter方法
跟入responseWriters.get方法
此时我们来到了一个PluginBag对象的get方法
在执行完T result = get(name)方法后 result的结果中是一个VelocityResponseWriter对象且
paramsResourceLoaderEnabled和solrResourceLoaderEnabled属性都已被置为true，就是说给这两个属性赋值的操作就在get(name)这个方法里。继续跟进
还是继续跟进result的无参get方法
到这里，就出现问题了
这里会判断一个名字叫lazyInst的属性是否为空，如果不为空，则返回这个属性
我们来看看此时这个lazyInst属性是什么，
可以看到就是我们最终返回的VelocityResponseWriter对象。
那么问题就来了，我们这执行过程中并没有看到lazyInst对象被赋值，那么lazyInst属性指向的VelocityResponseWriter对象是哪来的呢？
我们会退一步，观察这行代码
PluginHolder result = registry.get(name);
registry是一个hashmap类型，有final标识符
观察此时registry里面的内容
又因为registry.get(name)传入的name参数的值为velocity
我们打开这里的velocity
赫然看到那个lazyInst就在里面，我们知道标示的final的属性就是常量了，在对像生成被赋值了一次以后就不会再更改了。我通过多次发送poc请求测试发现每次到这个断点时当前的对象ID都是相同的，所以每次执行调用的都是同一个对像。
我们重新发送poc的第一部分。Poc第一部分请求完成后再在此处下断点
此时lazyInst属性就为空了
我们继续执行
此时由于lazyInst为空了，所以不会直接返回，我们跟进createInst方法，
看到在createInst方法的最后lazyInst属性被赋值，我们向上寻找这个localInst变量
在下面这行代码中localInst第一次被赋值
此时localInst中的内容为
也就是说此时程序只是从solrconfig.xml中读取了默认的配置，还并没有读取
configoverlay.json中我们更新的配置。
所以这行就不跟进了。
我们清楚的看到参数被更新了，那我们就跟入这行代码
跟入((NamedListInitializedPlugin) inst).init(info.initArgs)
然后就又看到了我们执行poc第一部分时所碰到的代码了，至此获取
configoverlay.json中我们更新的配置信息的执行逻辑我们已经分析完毕
接下来继续原路返回到我们调用HttpSolrCall.getResponseWriter的位置
继续跟进writeResponse(solrRsp, responseWriter, reqMethod);
此时solrRsp中存放的是我们Get传入的poc，responseWriter中存放的是我们configoverlay.json文件中存放的更新配置。
跟入QueryResponseWriterUtil.writeQueryResponse方法
跟入responseWriter.write方法
我们执行createEngine()方法时生成了一个VelocityEngine对象
我们进入createEngine()方法后可以看到方法内的第一行代码就是new一个VelocityEngine对象
关键点在以下这几行代码，这里对
paramsResourceLoaderEnabled
solrResourceLoaderEnabled两个参数进行了判断，当
paramsResourceLoaderEnabled参数为true时执行