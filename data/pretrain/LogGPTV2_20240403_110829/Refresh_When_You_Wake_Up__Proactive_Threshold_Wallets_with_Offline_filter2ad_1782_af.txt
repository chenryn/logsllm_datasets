along with corresponding epoch, sk
seed to ofﬂine parties along with these values). If the signature
using R is used to signal a refresh, then seed is expanded by
every pair of parties to produce rand as necessary.
We give the entire protocol in the full verison of this paper
for completeness.
IX. PERFORMANCE AND IMPLEMENTATION
We discuss here the concrete overhead our refresh protocol
adds to existing state of the art threshold ECDSA schemes,
as most cryptocurrencies today (Bitcoin, Ethereum, etc.) use
ECDSA as their canonical signature scheme. As at this point
we are discussing speciﬁc protocols, we make the following
observation: In the protocols of Lindell et al. [6], Doerner et
al. [7], and Gennaro and Goldfeder [5] the extra messages
ρ-signcan be sent in parallel with the main ECDSA
added by π(2,n)
protocols. In particular, each πR
ECDSA has at least two rounds
which can be used to generate K and δ in parallel, and each
ECDSAhas at least one round before σ is released during which
πσ
z can be constructed and veriﬁed.
A. Cost Analysis
ECDSA,πσ
the costs of the (πR
In Table I we recall
ECDSA)
combined protocols of Doerner et al. [7] and Lindell et al. [6]
(OT-based) for perspective, and then give the overhead induced
by π(2,n)
ρ-sign.
Protocol
Lindell et al. [6]
Doerner et al. [7]
ρ-signoverhead
π(2,n)
Comm.
195 KiB
118 KiB
192 Bytes
239
6
6
EC Mult.s
Rounds
8
7
0
Table I: Overhead of applying π(2,n)
ρ-signto proactivize (2, n)
ECDSA protocols instantiated with 256-bit curves. Figures are
per-party and do not include cost of implementing proactive
channels to communicate 160 bytes to each ofﬂine party every
refresh.
Finally the update procedure π(2,n)
ρ-updateﬁrst requires reading
the blockchain and scanning for signatures under the common
public key since last awake– essentially the same operation
as required to update balance of funds available in a wallet.
Additionally one has to read messages received when ofﬂine
and perform two curve multiplications for each refresh missed.
B. Implementation
In order to demonstrate the compatibility and efﬁciency of
our refresh procedure, we implemented it to augment two
different recent threshold ECDSA protocols; speciﬁcally those
Authorized licensed use limited to: Tsinghua University. Downloaded on February 25,2022 at 12:17:03 UTC from IEEE Xplore.  Restrictions apply. 
619
of Doerner et al. [7] and Gennaro and Goldfeder [5]. We
present the results in this section.
We ran both sets of experiments on Amazon’s AWS EC2 us-
ing a pair of t3.small machines located in the same datacenter
for uniformity. However as the implementations of the base
threshold ECDSA protocols came from different codebases,
we stress that the important metric is the overhead added
by our protocol in each case, and that comparison of the
concrete times across the ECDSA protocols is not necessarily
meaningful.
1) Proactivizing Doerner et al. [7]: As Doerner et al. na-
tively utilize OT based multipliers, augmenting their threshold
ECDSA signing with our refresh procedure yields a fully
proactivized ECDSA wallet. We ran three experiments, during
which we measured wall-clock time, including latency costs,
collecting 100,000 samples and averaging them. We ﬁrst ran
their signing protocol unmodiﬁed, which took an average of
5.303ms to produce a signature. We then ran the same protocol
augmented with our refresh generation procedure (i.e. π(2,n)
ρ-sign)
and found it to take an average of 6.587ms, i.e. a 24.2%
increase. Finally we measured the cost of applying an update
upon waking up (i.e. π(2,n)
ρ-update) to be 0.381ms. Note that this
ﬁgure does not account for the costs of the proactive channels
or GLedger (which is done anyway to update one’s balance);
the point of this benchmark is to demonstrate the efﬁciency
of applying updates in isolation.
2) Gennaro and Goldfeder [5]:
In order to understand
the overhead added by the refresh procedure to the commu-
nication pattern of a different (2, n) ECDSA based wallet,
we implemented the protocol of Gennaro and Goldfeder [5]
and augmented it with our refresh procedure during signing.
Note their protocol makes use of a Paillier-based multiplier
which we do not proactivize (see Canetti et al. [22] for how
this can be done), and the cost of proactivizing an OT-based
multiplier is negligible (0.381ms as shown previously). This
is representative of the (2, 3) cold storage application where
the multipliers need not be ofﬂine-refreshed. We refer to the
original (πR
ρ-signas
GG’.
ECDSA) as GG and the augmented π(2,n)
ECDSA,πσ
We did not implement forward secure channels, we instead
simulated it with reads from disk. We collected twenty samples
for each conﬁguration and found the average execution time
of GG to be 1.433s and that of GG’ to be 1.635s. In particular,
ρ-signincurs a 14.09% overhead in computation. Note that this
π(2,n)
ﬁgure does not include network latency, but in the LAN setting
the measurements were within margin of error.
The code for the experiments will be released in the full
version of this manuscript.
X. GENERAL (t, n) IMPOSSIBILITY
We showed in Section IV-A that an honest majority protocol
is easy to construct, and so we assume for the rest of the
discussion that we are in a setting where there is no online
honest majority.
Many proactive secret sharing protocols in the literature
have fundamentally followed the same approach: the refresh
protocol runs roughly the same protocol that was used to share
the secret, with new randomness incorporated to create an
independent sharing of the same value. Therefore the ability
to run veriﬁable secret sharing (VSS) in a given setting has
always translated well to construct a refresh protocol for the
same setting. Non-interactive VSS where only t online parties
speak, with resiliency to t − 1 corruptions are known in the
literature [50], [51] suggesting that their translation to our
setting would yield an ofﬂine refresh protocol.
Unfortunately this intuition turns out to be false. Recall
that a central principle in ofﬂine refresh is that all (honest)
parties must be in agreement about whether or not to progress
to the next epoch, i.e. ‘unanimous erasure’. We discussed in
Section III why anything less than this is undesirable, as even
a simple network failure could induce permanent loss of the
shared secret. However even this notion turns out to require
the power of an honest majority to realize (barring the (2, n)
case) and we give intuition as to why below.
Recall that the refresh protocol πρ is run by tρ online parties,
of whom t − 1 may be corrupt, and we deﬁne h = tρ − t + 1
to denote how many are honest. Assume the weakest form of
dishonest majority, i.e. one more corrupt party than honest, so
h = t−2. The communication pattern of a single refresh phase
is as follows: the online parties run πρ, following which each
online party sends a message to each of the ofﬂine parties, who
upon waking up will be able to catch up to the same epoch.
The unanimous erasure property requires that all honest parties
stay in agreement about the epoch; i.e. no one party is falsely
convinced to prematurely erase their old state. Informally, we
call a message or set of messages ‘convincing’ if they induce
an ofﬂine party to progress to the next epoch and erase their
old state.
Relating Unanimous Erasure to πρ: It is instructive to
view πρ as an MPC protocol to produce a convincing message
for ofﬂine parties to progress. As we mandate unanimous
erasure, it must never be the case that πρ permits an adversary
to produce a convincing message while depriving online
honest parties of it. In particular if πρ produces a convincing
message then it must be visible and veriﬁable within the online
honest parties’ joint view (i.e. any subset of size h). Otherwise
an adversary could at its discretion choose to induce an ofﬂine
party to prematurely erase its state, and honest parties would
not be able to tell either way. This property strongly suggests
that πρ must achieve a form of fairness which does not bode
well given that it must tolerate a dishonest majority.
A General Attack: Now we hone in on exactly how an
adversary can exploit the above facts. Assume that Poﬀ is an
ofﬂine party. Observe that the adversary is allowed to corrupt
h + 1 parties given the dishonest majority setting, and so
it has the budget to keep h online parties corrupt as well
as corrupt Poﬀ initially, say in epoch 0. The adversary un-
corrupts Poﬀ and πρ is run successfully to move the system
to epoch 1, keeping h parties corrupt (but behaving honestly)
through the process. Now recall that the convincing message
to Poﬀ will be visible to any h online parties. Since the
adversary has both: the state of Poﬀ from epoch 0, as well as a
Authorized licensed use limited to: Tsinghua University. Downloaded on February 25,2022 at 12:17:03 UTC from IEEE Xplore.  Restrictions apply. 
620
‘convincing message’ addressed to Poﬀ by virtue of corrupting
h parties during πρ, it is able to derive Poﬀ’s refreshed state for
epoch 1 despite not corrupting Poﬀ in that epoch. Now simply
corrupting one additional party in epoch 1 completely reveals
the secret, as h + 2 = t parties’ private states are available to
the adversary for that epoch.
We delegate the formal theorem and proof to Appendix A.
This closes the question of the gap between an honest and
a dishonest majority of corruptions in the setting of ofﬂine
refresh.
XI. ACKNOWLEDGMENT
Research supported by:
the Concordium Blockhain Re-
search Center (COBRA), Aarhus University, Denmark; the
Carlsberg Foundation under the Semper Ardens Research
Project CF18-112 (BCM); the European Research Council
(ERC) under the European Unions’s Horizon 2020 research
and innovation programme under grant agreement No 803096
(SPEC);
the Danish Independent Research Council under
Grant-ID DFF-6108-00169 (FoCC); the Ofﬁce of the Director
of National Intelligence (ODNI), Intelligence Advanced Re-
search Project Activity (IARPA) under contract number 2019-
19-020700009 (ACHILLES).
REFERENCES
[1] Y. Desmedt, “Society and group oriented cryptography: A new concept,”
in CRYPTO, 1987.
[2] R. Gennaro, S. Jarecki, H. Krawczyk, and T. Rabin, “Robust threshold
DSS signatures,” Inf. Comput., vol. 164, no. 1, pp. 54–84, 2001.
[Online]. Available: https://doi.org/10.1006/inco.2000.2881
[3] J. F. Almansa, I. Damg˚ard, and J. B. Nielsen, “Simpliﬁed threshold rsa
with adaptive and proactive security,” in EUROCRYPT ’06, 2006.
[4] V. Shoup, “Practical threshold signatures,” in EUROCRYPT’00, 2000.
[5] R. Gennaro and S. Goldfeder, “Fast multiparty threshold ECDSA with
fast trustless setup,” in ACM CCS 2018, 2018.
[6] Y. Lindell, A. Nof, and S. Ranellucci, “Fast secure multiparty
ECDSA with practical distributed key generation and applications to
cryptocurrency custody,” IACR Cryptology ePrint Archive, vol. 2018,
p. 987, 2018. [Online]. Available: https://eprint.iacr.org/2018/987
[7] J. Doerner, Y. Kondi, E. Lee, and a. shelat, “Threshold ecdsa from ecdsa
assumptions: The multiparty case,” in IEEE S&P, 2019.
[8] A. Dalskov, M. Keller, C. Orlandi, K. Shrishak, and H. Shulman, “Se-
curing dnssec keys via threshold ecdsa from generic mpc,” Cryptology
ePrint Archive, Report 2019/889, 2019, https://eprint.iacr.org/2019/889.
[9] G. Castagnos, D. Catalano, F. Laguillaumie, F. Savasta, and I. Tucker,
“Bandwidth-efﬁcient threshold EC-DSA,” in Public-Key Cryptography
- PKC 2020, A. Kiayias, M. Kohlweiss, P. Wallden, and V. Zikas, Eds.,
2020.
[10] C.-P. Schnorr, “Efﬁcient identiﬁcation and signatures for smart cards,”
in CRYPTO, 1989.
[11] D. J. Bernstein, N. Duif, T. Lange, P. Schwabe, and B.-Y. Yang, “High-
speed high-security signatures,” Journal of Cryptographic Engineering,
vol. 2, no. 2, pp. 77–89, Sep 2012.
[12] R. Ostrovsky and M. Yung, “How to withstand mobile virus attacks
(extended abstract),” in PODC ’91, 1991.
[13] Y. Frankel, P. Gemmell, P. D. MacKenzie, and M. Yung, “Proactive rsa,”
in CRYPTO ’97, B. S. Kaliski, Ed., 1997.
[14] R. Canetti, “Universally composable security: A new paradigm for
cryptographic protocols,” in FOCS, 2001.
[15] D. Beaver, “Precomputing oblivious transfer,” in CRYPTO ’95, 1995,
pp. 97–109.
[16] A. Herzberg, S. Jarecki, H. Krawczyk, and M. Yung, “Proactive secret
sharing or: How to cope with perpetual leakage,” in CRYPTO ’95, 1995.
[17] A. Herzberg, M. Jakobsson, S. Jarecki, H. Krawczyk, and M. Yung,
“Proactive public key and signature systems,” in ACM CCS ’97, 1997.
[18] C. Cachin, K. Kursawe, A. Lysyanskaya, and R. Strobl, “Asynchronous
veriﬁable secret sharing and proactive cryptosystems,” in ACM CCS
2002, 2002.
[19] S. K. D. Maram, F. Zhang, L. Wang, A. Low, Y. Zhang, A. Juels, and
D. Song, “CHURP: dynamic-committee proactive secret sharing,” in
ACM CCS 2019, 2019.
[20] V. Nikov and S. Nikova, “On proactive secret sharing schemes,” in
Selected Areas in Cryptography, H. Handschuh and M. A. Hasan, Eds.
Berlin, Heidelberg: Springer Berlin Heidelberg, 2005, pp. 308–325.
[21] R. Canetti, S. Halevi, and A. Herzberg, “Maintaining authenticated
communication in the presence of break-ins,” J. Cryptology, vol. 13,
no. 1, pp. 61–105, 2000.
[22] R. Canetti, N. Makriyannis, and U. Peled, “Uc non-interactive, proactive,
threshold ecdsa,” Cryptology ePrint Archive, Report 2020/492, 2020,
https://eprint.iacr.org/2020/492.
[23] F. Benhamouda, C. Gentry, S. Gorbunov, S. Halevi, H. Krawczyk,
C. Lin, T. Rabin, and L. Reyzin, “Can a blockchain keep a secret?”
Cryptology ePrint Archive, Report 2020/464, 2020, https://eprint.iacr.
org/2020/464.
[24] V. Goyal, A. Kothapalli, E. Masserova, B. Parno, and Y. Song, “Storing
and retrieving secrets on a blockchain,” Cryptology ePrint Archive,
Report 2020/504, 2020, https://eprint.iacr.org/2020/504.
[25] K. Eldefrawy, R. Ostrovsky, S. Park, and M. Yung, “Proactive secure
multiparty computation with a dishonest majority,” in Security and
Cryptography for Networks SCN 2018, 2018.
[26] A. Kiayias, H. Zhou, and V. Zikas, “Fair and robust multi-party
computation using a global transaction ledger,” in EUROCRYPT 2016,
2016, pp. 705–734.
[27] J. A. Garay, A. Kiayias, and N. Leonardos, “The bitcoin backbone
protocol: Analysis and applications,” in EUROCRYPT 2015, 2015.
[28] S. Nakamoto, “Bitcoin: A peer-to-peer electronic cash system,” Cryp-
tography Mailing list at https://metzdowd.com, 03 2009.
[29] G. Wood, “Ethereum: A secure decentralised generalised transaction
ledger.”
[30] C. Dwork, N. A. Lynch, and L. J. Stockmeyer, “Consensus in the
presence of partial synchrony,” J. ACM, vol. 35, no. 2, 1988.
[31] S. Micali, “Algorand: The efﬁcient and democratic ledger,” 07 2016.
[32] B. David, P. Gazi, A. Kiayias, and A. Russell, “Ouroboros praos:
An adaptively-secure, semi-synchronous proof-of-stake blockchain,” in
EUROCRYPT 2018, 2018, pp. 66–98.
[33] J. Chen and S. Micali, “Algorand: A secure and efﬁcient distributed
ledger,” Theor. Comput. Sci., vol. 777, pp. 155–183, 2019.
[34] C. Badertscher, U. Maurer, D. Tschudi, and V. Zikas, “Bitcoin as a
transaction ledger: A composable treatment,” in CRYPTO 2017, 2017,
pp. 324–356.
[35] R. Cleve, “Limits on the security of coin ﬂips when half the processors
are faulty,” in STOC ’86, 1986.
[36] I. Damg˚ard, V. Pastro, N. P. Smart, and S. Zakarias, “Multiparty
computation from somewhat homomorphic encryption,” in CRYPTO
2012, ser. Lecture Notes in Computer Science, 2012.
[37] M. Keller, E. Orsini, and P. Scholl, “MASCOT: faster malicious arith-
metic secure computation with oblivious transfer,” in ACM CCS 2016,
2016.
[38] M. Fitzi, D. Gottesman, M. Hirt, T. Holenstein, and A. D. Smith,
“Detectable byzantine agreement secure against faulty majorities,” in
ACM PODC 2002, 2002.
[39] S. Goldwasser and Y. Lindell, “Secure multi-party computation without
agreement,” J. Cryptology, vol. 18, no. 3, pp. 247–287, 2005.
[40] M. Marlinspike and T. Perrin, “The double ratchet algorithm, 11 2016,”
in https://signal.org/docs/speciﬁcations/x3dh/x3dh.pdf.
[41] J. Alwen, S. Coretti, and Y. Dodis, “The double ratchet: Security notions,
proofs, and modularization for the signal protocol,” in EUROCRYPT
2019, 2019, pp. 129–158.
[42] M. C. Pease, R. E. Shostak, and L. Lamport, “Reaching agreement in