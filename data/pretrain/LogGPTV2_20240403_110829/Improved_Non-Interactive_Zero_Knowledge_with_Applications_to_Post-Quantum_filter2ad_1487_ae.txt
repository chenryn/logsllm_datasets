A and any polynomial (cid:96), the probability that A succeeds in the following experiment is negligible
in κ:
1. Keys {(pki, ski)}(cid:96)
i=1 are given to A.
2. A may query an oracle Sign(cid:48)(·,·,·), where Sign(cid:48)(R, i, M ) (with pki ∈ R) outputs Sign(R, ski, M ).
i=1 are generated by Gen(1κ). The public keys S def= {pki}(cid:96)
(Note that we do not require R ⊆ S.)
3. A may also query a corruption oracle Corrupt that on input i returns ski.
If A queries
Corrupt(i) then we say that pki is corrupted. We let C be the set of corrupted public keys at
the end of the experiment.
6Note that group signatures with full anonymity imply public-key encryption [2], and thus the group signatures
we construct will meet a slightly weaker deﬁnition.
17
4. A outputs M∗, R∗, σ∗. It succeeds if (1) Vrfy(R∗, M∗, σ∗) = 1; (2) R∗
never queried Sign(cid:48)(R∗, (cid:63), M∗).
⊆ S \ C; and (3) A
Anonymity. Intuitively, anonymity ensures that a valid signature with respect to a ring R does
not reveal which secret key (corresponding to some public key in R) was used to generate the
signature. Our deﬁnition is based on [8, Deﬁnition 5], slightly simpliﬁed for our context.
Deﬁnition 4.2. Ring signature scheme (Gen, Sign, Vrfy) is anonymous if, for any ppt adversary
A and any polynomial (cid:96), the probability that A succeeds in the following experiment is at most
1/2 + negl(κ):
1. Keys {(pki, ski)}(cid:96)
i=1 are generated by Gen(1κ) and all keys (both public and private) are given
to A.
given Sign(R(cid:48), skib, M ), where R(cid:48) = R ∪ {pki0, pki1}.
2. A outputs a message M , a ring R, and i0, i1 ∈ [(cid:96)]. A uniform b ∈ {0, 1} is chosen, and A is
3. A outputs a bit b(cid:48), and succeeds if b(cid:48) = b.
Constructing a ring signature scheme. The main idea is to generate a ring signature with
respect to a ring R by generating an NIZKPoK of the secret key corresponding to one of the public
keys in R. The main question is how to do so while reducing the size of the proof as much as
possible.
A naive solution to building a ring signature scheme, based on the signature scheme from the
previous section, is as follows. As before, key generation chooses a uniform key k ∈ {0, 1}κ; the
corresponding public key is y := PRFk(0κ). Given a ring R = {yi}(cid:96)
i=1 of public keys, let C be the
circuit that takes as input a key k and outputs 1 iﬀ PRFk(0κ) = yi for some i. (Alternately, it can
take as input k, i and output 1 iﬀ PRFk(0κ) = yi. This does not materially aﬀect the parameters.)
A signature will then be an NIZKPoK of an input ki such that C(ki) = 1. The size of C (and hence
the size of a signature) grows linearly in (cid:96) = |R|.
Eﬃciency can be improved using a Merkle tree. Given a ring R as before, we deﬁne a (public)
mechanism for computing a Merkle root h∗ starting from values y1, . . . , y(cid:96) at the leaves; assume
for simplicity that (cid:96) = 2q for some integer q. Let C be a circuit that takes as input k, i, and an
auxiliary value path; computes y := PRFk(0κ); and then outputs 1 if path is a valid Merkle proof
(with respect to root h∗) for value y at leaf i. As before, a signature is an NIZKPoK of an input
for which C evaluates to 1. Importantly, the size of C (and hence the signature length) is now only
logarithmic in (cid:96).
Anonymity of the scheme is ensured by the zero-knowledge property of the NIZKPoK. Given
an adversary who forges a signature for some ring R∗ of uncorrupted keys (and assuming the hash
function used for the Merkle tree is collision-resistant), we can use the knowledge extractor of the
NIZKPoK to extract k, i such that PRFk(0κ) = yi for some uncorrupted party i. That is, the
adversary is able to ﬁnd a private key for some uncorrupted party, which happens with negligible
probability. As in the previous section, since the scheme relies on symmetric-key primitives alone
it can be said to oﬀer post-quantum security. We refer to Section 4.3 for a performance evaluation
of the scheme.
18
Ring/group size:
27
|σ|
t
210
t
|σ|
213
t
|σ|
Derler et al. [21] 982 KB — 1.35 MB — 1.72 MB —
Here
285 KB 2.0 s
388 KB 2.8 s
492 KB 3.6 s
Boneh et al. [12] 1.37 MB — 1.85 MB —
—
—
Here
315 KB 2.3 s
418 KB 3.0 s
532 KB 3.8 s
Table 4: Performance of our ring/group signature schemes, and comparison to prior work.
|σ| is
the signature size, and t is the signing/veriﬁcation time. The top two schemes are ring signatures;
the bottom two are group signatures.
4.2 Group Signatures
A group signature scheme [17] also allows users in a group to sign messages without revealing
their identity (beyond the fact that they belong to the group). The main diﬀerences between
group signatures and ring signatures are that (1) in the context of group signatures, a group
manager determines membership in the group; and (2) the group manager has the ability to
violate anonymity by tracing the user who generated a given signature.
We focus on the case of static groups for simplicity. Formally, a group signature scheme consists
of four probabilistic polynomial-time algorithms (Gen, Sign, Vrfy, Open) with the following function-
ality:
• The key-generation algorithm Gen takes as input the security parameter κ and the number
of group members (cid:96), and generates a master public key gpk, master private key gmsk, and
signing keys gsk1, . . . , gsk(cid:96).
• The signing algorithm Sign takes as input a signing key gski and a message M , and outputs
a signature σ.
• The veriﬁcation algorithm Vrfy takes as input the master public key gpk, a message M , and
a signature σ. It outputs a bit indicating acceptance or rejection.
• The tracing algorithm Open takes as input the master private key gmsk, a message M , and
a signature σ. It outputs an index i ∈ [(cid:96)] or a failure symbol ⊥.
Correctness requires that for any gpk, gmsk, gsk1, . . . , gsk(cid:96) output by Gen, any message M , and any
i ∈ [(cid:96)], we have
Vrfy(gpk, M, Sign(gski, M )) = 1
and
Open(gmsk, M, Sign(gski, M )) = i.
Bellare et al. [6] deﬁne two security requirements for group signatures: traceability and anonymity.
We follow their deﬁnitions here with some diﬀerences described below.
Traceability. The traceability property requires that an attacker who colludes with some set C
of group members cannot output a valid signature that fails to be traced by the group manager to
some member of C.
19
Deﬁnition 4.3. Group signature scheme (Gen, Sign, Vrfy, Open) is traceable if, for any ppt ad-
versary A and any polynomial (cid:96), the probability that A succeeds in the following experiment is
negligible in κ:
1. Keys gpk, gmsk, gsk1, . . . , gsk(cid:96) are output by Gen(1κ, 1(cid:96)), and gpk, gmsk are given to A.
2. A may query an oracle Sign(cid:48)(·,·), where Sign(cid:48)(i, M, ) outputs Sign(gski, M ).
3. A may also query a corruption oracle Corrupt that on input i returns gski; in this case we
say that user i is corrupted. We let C denote the set of corrupted users at the end of the
experiment.
4. A outputs M, σ, and succeeds if: (1) Vrfy(gpk, M, σ) = 1; (2) Open(gmsk, M, σ) (cid:54)∈ C; and
(3) the adversary never made a query Sign(cid:48)((cid:63), M ).
As shown by Bellare et al. [6], traceability implies unforgeability (simply consider C = ∅ in
the above deﬁnition). One could also consider a weaker deﬁnition of traceability (that still implies
unforgeability) in which gmsk is not given to the adversary. Our scheme can be made more eﬃcient
if that weaker deﬁnition suﬃces.
Anonymity. As in the case of ring signatures, anonymity implies that a valid signature does not
reveal the user who generated that signature (except to the group manager who holds gmsk); this
should hold even if the adversary is given access to a tracing oracle to which it can submit any
other signature. The notion of full anonymity considered by Bellare et al. [6] requires signatures
produced by a user i to remain anonymous even if the secret key gski of that user is known to the
adversary. A weaker notion [14] requires anonymity only for uncorrupted users. Previous work [2]
shows that fully anonymous group signatures imply public-key encryption. Since our goal is to
construct a scheme based on symmetric-key primitives alone, we consider the weaker notion of
anonymity here.
Deﬁnition 4.4. Group signature scheme (Gen, Sign, Vrfy, Open) satisﬁes weak anonymity if, for
any ppt adversary A and any polynomial (cid:96), the probability that A succeeds in the following exper-
iment is at most 1/2 + negl(κ):
1. Keys gpk, gmsk, gsk1, . . . , gsk(cid:96) are output by Gen(1κ, 1(cid:96)), and gpk is given to A.
2. A is given access to the following oracles:
• A signing oracle that on input M, i outputs Sign(gski, M ).
• A corruption oracle that on input i outputs gski. We let C denote the set of queries made
by A to this oracle at the end of the experiment.
• A tracing oracle that outputs Open(gmsk, M, σ).
, M ) is computed, and A is given σ∗.
← Sign(gskib
3. At some point, A outputs a message M∗ and i0, i1 ∈ [(cid:96)]. Then a uniform b ∈ {0, 1} is chosen,
σ∗
on M∗, σ∗.
4. A may continue to query all the oracles above, except that it may not query its tracing oracle
5. A outputs a bit b(cid:48), and succeeds if i0, i1 (cid:54)∈ C and b(cid:48) = b.
20
Constructing a group signature scheme. Analogous to our construction of a ring signature
scheme, the basic idea here is for a user to generate a signature by generating an NIZKPoK of a
secret key corresponding to the group public key. Here, however, we must also ensure traceability,
which adds additional complications.
Assume for simplicity that (cid:96) = 2q for some integer q. In our scheme, the private key gski of a
(0κ). The master
user now includes two uniform and independent keys k0
private key gmsk consists of the {k0
i }. A Merkle root
h∗ is then computed for the Merkle tree with values (y0
(cid:96) ) at the (cid:96) leaves of the tree.
The master public key is h∗, and the private key gski of a user includes the Merkle proof (with
respect to h∗) for (y0
i := PRFkb
i } but, importantly, does not include the {k1
i ; we set yb
1), . . . , (y0
1, y1
(cid:96) , y1
i , k1
i
i , y1
i ).
Let Cx,y be a circuit that has values x, y hardcoded; takes as input k0, k1, i, and an auxiliary
value path; computes y0 := PRFk0(0κ) and y1 := PRFk1(0κ); and then outputs 1 iﬀ y = PRFk0(x)
and path is a valid Merkle proof (with respect to h∗) for the value (y0, y1) at leaf i. To sign a
message M , a user i holding k0
(H(M )) and then generates an NIZKPoK
of an input for which the circuit CH(M ),y outputs 1; the signature includes both y and the resulting
proof. Tracing is done by ﬁnding the key k0
(H(M )) = y. We refer to Section 4.3
for a performance evaluation of the scheme.
i computes y = PRFk0
i for which PRFk0
i , k1
i
i
Traceability and weak anonymity of the above construction follows using standard techniques;
we omit the details.
4.3 Implementation and Performance
We implemented the ring and group signature schemes described in the previous sections, using
our NIZKPoK from Section 3.1 with n = 64 so as to optimize the signature length. As previously,
we target 128-bit quantum security. Both of our schemes involving constructing a circuit that can
verify a Merkle path, which requires several hash-function computations. To minimize the circuit
size, we derived a ﬁxed-length hash function mapping 512-bit inputs to 256-bit outputs by applying
the Davies-Meyer construction to the LowMC cipher with 256-bit key/block size. (This matches
what was done in concurrent work [21, 12] mentioned below.) We summarize the performance of
our schemes in Table 4.
The signature length in our ring signature scheme asymptotically matches what is achieved by
the state-of-the-art, lattice-based ring signature scheme by Libert et al. [36], but the concrete eﬃ-
ciency of our scheme (both in terms of communication and computation) appears to be signiﬁcantly