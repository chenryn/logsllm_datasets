for instance, when a test requires that
two independent random nonces are equal, this test fails
with overwhelming probability.
• CryptoVerif applies the IND-CPA property of the sym-
metric encryption on the key kS = kgen(rKs). The
IND-CPA property is represented in CryptoVerif by the
equivalence (IND-CPA) of Figure 4. This equivalence
expresses that the oracle that encrypts x is indistin-
guishable from an oracle that encrypts Z(x), where Z(x)
represents a bitstring of zeroes, of the same length as x.
This property is implied by IND-CPA.
CryptoVerif will then replace terms enc(M, kgen(cid:48)(rKs),
r(cid:48)) with enc(cid:48)(Z(M ), kgen(cid:48)(rKs), r(cid:48)), provided rKs is a
random number occuring only in such terms and r(cid:48) is a
fresh random number.
The right-hand side uses enc(cid:48) instead of enc to prevent
repeated application of the game transformation.
• After applying this transformation, the game is simpli-
ﬁed.
In particular, terms of the form Z(M ) are sim-
pliﬁed to constants when the length of M is constant,
which removes the dependency on M .
CryptoVerif then applies similar steps for keys kT and kC .
After applying the INT-CTXT property for kC , it succeeds
proving the desired correspondence.
The probability P (t) that an attacker running in time t
breaks the correspondence inj-event(fullCK (T, n, x, y)) ⇒
inj-event(fullKC (C, T, n, z, y)) is bounded by CryptoVerif
by P (t) ≤ N 2
2 |nonce| + N|nonce| + PINT-CTXT(t + tC1, N, N ) +
PIND-CPA(t + tC2, N ) + PINT-CTXT(t + tC3, N, N ) +
PIND-CPA(t + tC4, N ) + PINT-CTXT(t + tC5, N, N ) where
N is the maximum number of sessions of the protocol
participants, |nonce| is the cardinal of the set of nonces,
PINT-CTXT(t, n, n(cid:48)) is the probability that an attacker
running in time t breaks the INT-CTXT equivalence with
at most n calls to the encryption oracle and n(cid:48) calls to the
decryption oracle (for one encryption key), PINT-CPA(t, n) is
the probability that an attacker running in time t breaks the
IND-CPA equivalence with at most n calls to the encryption
oracle, and tC1, tC2, tC3, tC4, and tC5 are bounds on the
running time of the part of the transformed games not
included in the INT-CTXT or IND-CPA equivalence, which
are therefore considered as part of the attacker against the
INT-CTXT or IND-CPA equivalence. The ﬁrst two terms
of P (t) come from elimination of collisions between nonces,
while the other terms come from cryptographic transfor-
mations using the INT-CTXT or IND-CPA properties of
encryption for keys kS, kT , and kC . (Only the INT-CTXT
property is used for kC .)
N 2
Note that, if CryptoVerif applied the INT-CTXT prop-
erty of encryption on key kC ﬁrst,
it would prove the
query without needing the security of encryption for kS and
kT , and with a tighter bound on the probability P (t) ≤
2 |nonce| + N|nonce| + PINT-CTXT(t + t(cid:48)
C1, N, N ). This proof
can be obtained by manually giving to CryptoVerif the in-
struction crypto dec rKc, which instructs it to apply the
INT-CTXT equivalence (the only equivalence that has the
dec symbol in its left-hand side) to the key generated from
rKc. CryptoVerif automatically guesses the few syntactic
transformations that it has to do before applying this equiv-
alence.
Public-key Kerberos case: when the client process com-
pletes its participation in PKINIT, it executes an event
fullCK (hostZ , hostT , n1, m21 , TGT , m24 ) that contains the
name hostZ of the KAS, the name hostT of the TGS and
the unsigned nonce n1 from the client’s ﬁrst message. Fur-
93
thermore, it contains the reply from hostZ in m21 , TGT ,
and m24 , where m21 is the part of the reply encrypted un-
der C’s public key and m24 is the reply component that
contains the authentication key (AK ). When the KAS pro-
cess completes its participation in PKINIT, it executes an
event fullKC (hostY , hostW , n(cid:48)
1, e21 , TGT (cid:48), e24 ) that con-
tains the name hostY of the client, the name hostW of the
TGS and the unsigned nonce n(cid:48)
1 listed in the request. Fur-
thermore, it contains the public-key encryption component
e21 of K’s reply (under hostY ’s public key), the ticket grant-
ing ticket TGT (cid:48) generated by the KAS containing the au-
thentication key (AK (cid:48)), and the reply component e24 that
contains the authentication key. CryptoVerif can then prove
the query: inj-event(fullCK (K, T, n, w, x, y)) ⇒
inj-event(fullKC (C, T, n, w, z, y)).
We note that the proof for the public-key Kerberos case
is an interactive proof which uses the following commands:
crypto sign rkCA, crypto sign rkCs, crypto penc rkC,
crypto sign rkKs,
crypto keyderivation,
simplify,
crypto keyderivation, simplify, and auto.
(The com-
mands are given in typeface and separated by commas; the
ith command is given on the ith occasion that CryptoVerif
requests user input.) The command crypto sign rkCA
instructs CryptoVerif to transform the game using the
security of the signature for the keys generated from the
random number rkCA. In this case, rkCA was used to
generate the signature key of the certiﬁcate authority
who signed the certiﬁcates of the client and the KAS.
Similarly, rkCs and rkKs generated the signature keys of
the client and the KAS, respectively. The command crypto
penc rkC instructs CryptoVerif to apply the security for
the client’s public-key encryption key generated by the
random number rkC to transform the game. The command
crypto keyderivation instructs CryptoVerif to make a
game transformation by applying the security of the key
derivation function (i.e., pseudo randomness), and the
command simplify instructs CryptoVerif to apply the
build-in simpliﬁcation algorithm to the current game. The
command auto instructs CryptoVerif to continue the proof
automatically, using its built-in proof strategy.
Theorems 2–5 below can be proved in a similar way. We
detail the proof of Theorem 4 as a second example, and omit
the other proofs because of length constraints.
We formalize Property 1(b) as the following theorem.
Theorem 2 (Authentication of request for ST)
basic and public-key Kerberos, if there is an instance of:
• an honest TGS T receiving a valid request mreq for a
In
service ticket from an honest client C
then, with overwhelming probability, there is an instance
of:
• the KAS completing an AS exchange with C,
• in which the KAS generated the ticket granting ticket for
the use between C and T , which equals the one contained
in mreq,
and an instance of:
• the client C requesting a service ticket from T ,
• in which C sent the authenticator, which equals the one
contained in mreq.
We formalize Property 1(c) as the following theorem.
Theorem 3 (Authentication of TGS to client)
basic and public-key Kerberos, for each instance of:
In
honest TGS T
• an honest client C completing a TG exchange with an
• in which the client sent the request mreq to receive a
• received what appears to be a valid reply m(cid:48)
service ticket ST for the use with honest server S,
rep
there exist, with overwhelming probability, a distinct corre-
sponding instance of:
the use between C and S,
• the TGS T completing a TG exchange with client C
• in which the TGS received the request m(cid:48)
req for a ST for
• sent reply mrep, where the message component of mrep
encrypted under the authentication key, which contains
the service key SK , is equal to the corresponding com-
ponent in m(cid:48)
rep.
We formalize Property 1(d) as the following theorem.
Theorem 4 (Authentication of request to server)
In basic and public-key Kerberos, if there is an instance
of:
• an honest server S receiving a valid request mreq from
an honest client C
then, with overwhelming probability, there is an instance
of:
• the TGS completing a TG exchange with C,
• in which the TGS generated a service ticket contained
for the use between C and S, which is equal to the one
in mreq
and an instance of:
• the client C sending an authentication requesting a ser-
• in which C sent an authenticator, which is equal to the
vice from S,
one contained in mreq.
Proof. Basic Kerberos case: when the server process
validates a received request in a CS exchange, it executes
an event partSC (hostC , m14 , m15 ) that contains the name
hostC of the client contained in the ST, the ST itself in m14 ,
and the matching authenticator in m15 . When the TGS
process completes its participation in a TG exchange, it ex-
ecutes an event fullTC (hostY , hostW , n(cid:48), m8 , m9 , ST (cid:48), e11 )
that contains the name hostY of the client, the name hostW
of the server, the nonce n(cid:48), the TGT m8 , and the authenti-
cator m9 , which were all listed in the request m(cid:48)
req. Further-
more, the event contains the service ticket ST (cid:48) generated by
the TGS containing the service key SK (cid:48), and the message
component e11 of the reply that is encrypted under the au-
thentication key. When the client process sends a request
to a server, it executes an event partCS (hostX , hostY , ST ,
e12 ) that contains the name hostX of the TGS from which
the client requested a service ticket, the name hostY of the
server, the alleged ST in ST , and the authenticator sent by
C in e12 containing C’s name and a timestamp encrypted
under the service key SK , which C received in the same TS
reply as TGT . CryptoVerif can then automatically prove
the query: event(partSC (C, z, y)) ⇒
event(partCS (S, T, x, y)) ∧ event(fullTC (C, S, n, v, v(cid:48), z, w)).
Public-key Kerberos case: As the CS exchange in public-
key Kerberos does not diﬀer from the CS exchange in
94
basic Kerberos V5, the events partSC (hostC , m14 , m15 ),
partCS (hostX , hostY , ST , e12 ), and fullTC (hostY , hostW ,
n(cid:48), m8 , m9 , ST (cid:48), e11 ) are just as the ones described above
in the basic Kerberos case. CryptoVerif can then prove the
same query as above in basic Kerberos case using the same
commands as in the public-key Kerberos case from Theo-
rem 1.
We formalize Property 1(e) as the following theorem.
In
Theorem 5 (Authentication of server to client)
basic and public-key Kerberos, if there is an instance of:
honest server S
• an honest client C completing a CS exchange with an
• in which the client sent the request mreq,
• received a valid reply mrep
then, with overwhelming probability, there is an instance
of
• the server S completing a CS exchange with client C
• in which the TGS received the request m(cid:48)
• sent the reply mrep.
req
We note that the injectivity of the correspondences in
Theorems 1 and 3 stems from their challenge-response char-
acter; i.e., a fresh nonce is sent and subsequently received.
The correspondences in Theorems 2 and 4 are non-injective
because the 3rd and 5th messages of Kerberos, respectively,
can be replayed.
In practice, however, the server should
use an anti-replay cache in order to prevent the replay of
the 5th message [34]; we do not yet include this cache in
our model, but doing so in the future may allow us to show
that each instance of the server corresponds to a distinct
instance of the client in Theorem 4. The reason for the non-
injectivity of the correspondence in Theorem 5, however, is a
little diﬀerent and has to do with how we model timestamps
in CryptoVerif.
If the client C sends two requests to the
server S with the same timestamp t(cid:48)
C , then the adversary
can prevent the second request from reaching S and replay
S’s reply to the ﬁrst request as reply for the second request.
In this case, two sessions of the client correspond to a single
session of the server, so the correspondence is non-injective.
Our model in CryptoVerif allows the timestamps of several
requests to be equal with non-negligible probability, as in the
above scenario. However, this is rather unlikely to happen
in the real world, since the timestamps have a 1 µs resolu-
tion. If we treat timestamps as nonces, which can be equal
only with negligible probability, then the correspondence of
Theorem 5 can be shown to be injective (but timestamps
are then considered as unguessable).
Remark 1 CryptoVerif can prove all correspondences for
basic Kerberos mentioned in Theorems 1–5 simultaneously,
using a single sequence of games, and likewise it can prove
the correspondences for public-key Kerberos simultaneously,
using the same interactive commands.
4.3 Key Secrecy Results
In the following we present the key secrecy results
we proved in the computational model using CryptoVerif
1.06pl3 under the assumptions from Section 4.1. First we
will discuss key indistinguishability results and then we will
discuss key secrecy results with respect to the notion of key
usability, introduced in [21] and generalized here.
95
4.3.1 Key Indistinguishability
The key secrecy results in this section are proved with re-
spect to the real-or-random deﬁnition of security, which is
a stronger notion than the standard notion from the litera-
ture [2]. We note that, as discussed in [4], the authentication
keys and the service keys in Kerberos become distinguish-
able from random as soon as they are used for encryption
during the protocol and the resulting ciphertext is broad-
casted on the network, i.e., right after the second and third
round respectively, since they are used for encryption of a
partially known message (namely, the client’s name and a
timestamp).
We formalize Property 2(a) as the following theorem. We
omit its proof and detail only the proof of the more impor-
tant result on secrecy of SK (Theorem 7 below), which is
similar.
Theorem 6 (Secrecy of AK) Let QK5 1R be the game in