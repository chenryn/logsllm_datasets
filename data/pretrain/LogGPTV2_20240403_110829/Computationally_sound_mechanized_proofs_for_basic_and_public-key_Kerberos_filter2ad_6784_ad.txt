### Text Optimization

#### Example 1: Probability of Nonce Equality
For example, when a test requires that two independent random nonces are equal, this test fails with overwhelming probability.

#### CryptoVerif and IND-CPA Property
- **IND-CPA Application**: CryptoVerif applies the IND-CPA (Indistinguishability under Chosen Plaintext Attack) property to the symmetric encryption key \( k_S = k_{\text{gen}}(r_{KS}) \). The IND-CPA property is represented in CryptoVerif by the equivalence (IND-CPA) shown in Figure 4. This equivalence states that an oracle that encrypts \( x \) is indistinguishable from an oracle that encrypts \( Z(x) \), where \( Z(x) \) is a bitstring of zeroes of the same length as \( x \).
- **Transformation**: CryptoVerif then replaces terms \( \text{enc}(M, k_{\text{gen}}'(r_{KS}), r') \) with \( \text{enc}'(Z(M), k_{\text{gen}}'(r_{KS}), r') \), provided \( r_{KS} \) is a random number occurring only in such terms and \( r' \) is a fresh random number. The use of \( \text{enc}' \) instead of \( \text{enc} \) prevents repeated application of the game transformation.
- **Simplification**: After applying this transformation, the game is simplified. Specifically, terms of the form \( Z(M) \) are simplified to constants if the length of \( M \) is constant, which removes the dependency on \( M \).

#### Similar Steps for Other Keys
- **Keys \( k_T \) and \( k_C \)**: CryptoVerif applies similar steps for keys \( k_T \) and \( k_C \). After applying the INT-CTXT (Integrity of Ciphertext) property for \( k_C \), it successfully proves the desired correspondence.

#### Bounding the Probability
- **Probability Bound**: The probability \( P(t) \) that an attacker running in time \( t \) breaks the correspondence \( \text{inj-event}(\text{fullCK}(T, n, x, y)) \Rightarrow \text{inj-event}(\text{fullKC}(C, T, n, z, y)) \) is bounded by:
  \[
  P(t) \leq \frac{N^2}{2^{|nonce|}} + N|nonce| + P_{\text{INT-CTXT}}(t + t_{C1}, N, N) + P_{\text{IND-CPA}}(t + t_{C2}, N) + P_{\text{INT-CTXT}}(t + t_{C3}, N, N) + P_{\text{IND-CPA}}(t + t_{C4}, N) + P_{\text{INT-CTXT}}(t + t_{C5}, N, N)
  \]
  where:
  - \( N \) is the maximum number of sessions of the protocol participants.
  - \( |nonce| \) is the cardinality of the set of nonces.
  - \( P_{\text{INT-CTXT}}(t, n, n') \) is the probability that an attacker running in time \( t \) breaks the INT-CTXT equivalence with at most \( n \) calls to the encryption oracle and \( n' \) calls to the decryption oracle (for one encryption key).
  - \( P_{\text{IND-CPA}}(t, n) \) is the probability that an attacker running in time \( t \) breaks the IND-CPA equivalence with at most \( n \) calls to the encryption oracle.
  - \( t_{C1}, t_{C2}, t_{C3}, t_{C4}, \) and \( t_{C5} \) are bounds on the running time of the part of the transformed games not included in the INT-CTXT or IND-CPA equivalence, which are considered as part of the attacker against the INT-CTXT or IND-CPA equivalence.
  - The first two terms of \( P(t) \) come from the elimination of collisions between nonces, while the other terms come from cryptographic transformations using the INT-CTXT or IND-CPA properties of encryption for keys \( k_S, k_T, \) and \( k_C \).

#### Tighter Bound
- **Tighter Bound**: If CryptoVerif applied the INT-CTXT property of encryption on key \( k_C \) first, it would prove the query without needing the security of encryption for \( k_S \) and \( k_T \), and with a tighter bound on the probability:
  \[
  P(t) \leq \frac{N^2}{2^{|nonce|}} + N|nonce| + P_{\text{INT-CTXT}}(t + t'_{C1}, N, N)
  \]
  This proof can be obtained by manually giving the instruction `crypto dec rKc` to CryptoVerif, which instructs it to apply the INT-CTXT equivalence to the key generated from \( rKc \). CryptoVerif automatically guesses the few syntactic transformations needed before applying this equivalence.

#### Public-Key Kerberos Case
- **Client Process**: When the client process completes its participation in PKINIT, it executes an event `fullCK(hostZ, hostT, n1, m21, TGT, m24)` that contains the name `hostZ` of the KAS, the name `hostT` of the TGS, and the unsigned nonce `n1` from the client’s first message. It also contains the reply from `hostZ` in `m21`, `TGT`, and `m24`, where `m21` is the part of the reply encrypted under the client's public key and `m24` is the reply component containing the authentication key (AK).
- **KAS Process**: When the KAS process completes its participation in PKINIT, it executes an event `fullKC(hostY, hostW, n1', e21, TGT', e24)` that contains the name `hostY` of the client, the name `hostW` of the TGS, and the unsigned nonce `n1'` listed in the request. It also contains the public-key encryption component `e21` of the KAS's reply (under `hostY`'s public key), the ticket granting ticket `TGT'` generated by the KAS containing the authentication key (AK'), and the reply component `e24` that contains the authentication key. CryptoVerif can then prove the query:
  \[
  \text{inj-event(fullCK(K, T, n, w, x, y))} \Rightarrow \text{inj-event(fullKC(C, T, n, w, z, y))}
  \]

#### Interactive Proof
- **Commands**: The proof for the public-key Kerberos case is an interactive proof that uses the following commands: `crypto sign rkCA`, `crypto sign rkCs`, `crypto penc rkC`, `crypto sign rkKs`, `crypto keyderivation`, `simplify`, `crypto keyderivation`, `simplify`, and `auto`.
  - `crypto sign rkCA`: Instructs CryptoVerif to transform the game using the security of the signature for the keys generated from the random number `rkCA`. Here, `rkCA` was used to generate the signature key of the certificate authority who signed the certificates of the client and the KAS.
  - `crypto penc rkC`: Instructs CryptoVerif to apply the security for the client’s public-key encryption key generated by the random number `rkC` to transform the game.
  - `crypto keyderivation`: Instructs CryptoVerif to make a game transformation by applying the security of the key derivation function (i.e., pseudo randomness).
  - `simplify`: Instructs CryptoVerif to apply the built-in simplification algorithm to the current game.
  - `auto`: Instructs CryptoVerif to continue the proof automatically, using its built-in proof strategy.

#### Theorems
- **Theorem 2 (Authentication of Request for ST)**: In both basic and public-key Kerberos, if there is an instance of an honest TGS \( T \) receiving a valid request `mreq` for a service ticket from an honest client \( C \), then, with overwhelming probability, there is an instance of:
  - The KAS completing an AS exchange with \( C \), in which the KAS generated the ticket granting ticket for the use between \( C \) and \( T \), which equals the one contained in `mreq`.
  - The client \( C \) requesting a service ticket from \( T \), in which \( C \) sent the authenticator, which equals the one contained in `mreq`.

- **Theorem 3 (Authentication of TGS to Client)**: In both basic and public-key Kerberos, for each instance of an honest client \( C \) completing a TG exchange with an honest TGS \( T \), in which the client sent the request `mreq` to receive a service ticket \( ST \) for the use with an honest server \( S \), and received what appears to be a valid reply `mrep`, there exist, with overwhelming probability, a distinct corresponding instance of:
  - The TGS \( T \) completing a TG exchange with client \( C \), in which the TGS received the request `mreq'` for a service ticket for the use between \( C \) and \( S \), and sent reply `mrep`, where the message component of `mrep` encrypted under the authentication key, which contains the service key \( SK \), is equal to the corresponding component in `mrep'`.

- **Theorem 4 (Authentication of Request to Server)**: In both basic and public-key Kerberos, if there is an instance of an honest server \( S \) receiving a valid request `mreq` from an honest client \( C \), then, with overwhelming probability, there is an instance of:
  - The TGS completing a TG exchange with \( C \), in which the TGS generated a service ticket contained for the use between \( C \) and \( S \), which is equal to the one in `mreq`.
  - The client \( C \) sending an authentication request for a service from \( S \), in which \( C \) sent an authenticator, which is equal to the one contained in `mreq`.

- **Proof of Theorem 4**:
  - **Basic Kerberos Case**: When the server process validates a received request in a CS exchange, it executes an event `partSC(hostC, m14, m15)` that contains the name `hostC` of the client contained in the ST, the ST itself in `m14`, and the matching authenticator in `m15`. When the TGS process completes its participation in a TG exchange, it executes an event `fullTC(hostY, hostW, n', m8, m9, ST', e11)` that contains the name `hostY` of the client, the name `hostW` of the server, the nonce `n'`, the TGT `m8`, and the authenticator `m9`, which were all listed in the request `mreq'`. Furthermore, the event contains the service ticket `ST'` generated by the TGS containing the service key \( SK' \), and the message component `e11` of the reply that is encrypted under the authentication key. When the client process sends a request to a server, it executes an event `partCS(hostX, hostY, ST, e12)` that contains the name `hostX` of the TGS from which the client requested a service ticket, the name `hostY` of the server, the alleged ST in `ST`, and the authenticator sent by \( C \) in `e12` containing \( C \)'s name and a timestamp encrypted under the service key \( SK \), which \( C \) received in the same TS reply as TGT. CryptoVerif can then automatically prove the query:
    \[
    \text{event(partSC(C, z, y))} \Rightarrow \text{event(partCS(S, T, x, y))} \land \text{event(fullTC(C, S, n, v, v', z, w))}
    \]
  - **Public-Key Kerberos Case**: As the CS exchange in public-key Kerberos does not differ from the CS exchange in basic Kerberos V5, the events `partSC(hostC, m14, m15)`, `partCS(hostX, hostY, ST, e12)`, and `fullTC(hostY, hostW, n', m8, m9, ST', e11)` are just as described above in the basic Kerberos case. CryptoVerif can then prove the same query as above in the basic Kerberos case using the same commands as in the public-key Kerberos case from Theorem 1.

- **Theorem 5 (Authentication of Server to Client)**: In both basic and public-key Kerberos, if there is an instance of an honest client \( C \) completing a CS exchange with an honest server \( S \), in which the client sent the request `mreq` and received a valid reply `mrep`, then, with overwhelming probability, there is an instance of:
  - The server \( S \) completing a CS exchange with client \( C \), in which the TGS received the request `mreq'` and sent the reply `mrep`.

- **Injectivity and Replay**: The injectivity of the correspondences in Theorems 1 and 3 stems from their challenge-response character; i.e., a fresh nonce is sent and subsequently received. The correspondences in Theorems 2 and 4 are non-injective because the 3rd and 5th messages of Kerberos, respectively, can be replayed. In practice, the server should use an anti-replay cache to prevent the replay of the 5th message. The non-injectivity of the correspondence in Theorem 5 is due to how we model timestamps in CryptoVerif. If the client \( C \) sends two requests to the server \( S \) with the same timestamp \( t_C' \), the adversary can prevent the second request from reaching \( S \) and replay \( S \)'s reply to the first request as the reply for the second request. In this case, two sessions of the client correspond to a single session of the server, so the correspondence is non-injective.

- **Remark 1**: CryptoVerif can prove all correspondences for basic Kerberos mentioned in Theorems 1–5 simultaneously, using a single sequence of games, and likewise it can prove the correspondences for public-key Kerberos simultaneously, using the same interactive commands.

### Key Secrecy Results

#### Key Indistinguishability
- **Key Secrecy Results**: The key secrecy results in this section are proved with respect to the real-or-random definition of security, which is a stronger notion than the standard notion from the literature. We note that, as discussed in [4], the authentication keys and the service keys in Kerberos become distinguishable from random as soon as they are used for encryption during the protocol and the resulting ciphertext is broadcasted on the network, i.e., right after the second and third rounds, respectively, since they are used for encryption of a partially known message (namely, the client’s name and a timestamp).

- **Theorem 6 (Secrecy of AK)**: Let \( QK5_1R \) be the game in... (details omitted, see the proof of Theorem 7 below for a similar, more important result on the secrecy of \( SK \)).