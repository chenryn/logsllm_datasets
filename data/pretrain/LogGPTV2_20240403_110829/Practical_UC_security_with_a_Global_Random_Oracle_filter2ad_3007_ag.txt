the simulator derives the input of P2 by extracting the seed seedi of the correct circuit i from the
i-th circuit-OT.
In the original NISC protocol the extraction of the
NISC in the gRO model: Our techniques
input of the sender is done by extracting the keys and the seeds from the executions of input-OT
and circuit-OT. Our idea is to extract the input of P2 by observing the queries that P2 makes to
the RO. Toward this end, we require that each seed seedi used to generate the randomness for the
computation of the circuits and other critical information, is not picked by P2 but it is computed
as the output of the RO. Namely, P2 queries the RO on some random input qi and set seedi =
gRO(sid, P2(cid:107)qi). Then, in the cut-and-choose phase, P2 plays the OT protocol using qi instead of
seedi. In order to pass the consistency checks, P2 must query the RO to compute most of the PRF
seeds. In this way the simulator, which obtains all the queries made to GgRO for a speciﬁc session
sid, gets most of the seeds and is able to recompute the keys and garbled circuits without having to
extract them from the input-OTs and circuit-OTs.
with our one-sided UC-simulatable OT protocol, and still be able to simulate a malicious P ∗
2 .
This idea allows us to replace the PVW OT protocol used in [AMPR14] which is fully simulatable,
Security of our NISC in the gRO model. We now outline the ideas behind the security
proof of our NISC protocol. Simulating Malicious P ∗
1 . Because our OT protocol is UC-simulatable
against a malicious receiver the proof in this case follows the same proof provided in [AMPR14].
Simulating Malicious P ∗
2 . Our simulator works similarly to the simulator of [AMPR14] except that
the information necessary to derive the input of P ∗
2 is obtained by looking at the queries to the RO.
Due to the cut-and-choose, P2 is forced to query the RO to compute most of the PRF seeds used
in the protocol, otherwise it will be caught whp by P1. Therefore, if P ∗
2 passes all the checks, whp
the simulator will extract the relevant information.
The crucial diﬀerence in our case is in the indistinguishability of the ﬁrst message of input-OTs
computed by the simulator. In [AMPR14], the simulator, following the UC-simulator of PVW OT,
sets the OT parameters contained in the CRS to be a DDH tuple. In this way, the ﬁrst message of
input-OTs computed using a random input is distributed identically to the one played by an honest
P1 computed with the actual input.
In our case, as we are using our one-sided simulatable OT in the gRO model, the OT parameters
are honestly generated to be a non-DDH tuple. Thus, we cannot claim that the view generated by
the simulator is identically distributed to the view generated by an honest P1. Nevertheless, due to
the indistinguishability property of our OT against malicious senders, the messages computed by
the simulator are computationally indistinguishable from the messages computed by P1, and thus
we can use a malicious P2 to break the indistinguishability of our OT.
27
6.1 The Protocol
In this section we present our modiﬁcation of the NISC protocol of [AMPR14] which is UC-secure in
the gRO model. We stress that the protocol is essentially the same as [AMPR14] with the following
two modiﬁcations: (a) the underlying OT is one-sided UC-simulatable; (b) the seed of the PRF is
computed using the RO. In the description of the protocol we will highlight the points where the
two protocols diﬀer.
t ))
0, c(cid:48)
, hr(cid:48)
1, k1
1), . . . , (k0
Notation and sub-protocols. We denote by oneside-COT1(b) and oneside-COT2((k0
t , k1
Round 1 and Round 2 of our one-sided UC-simulatable (batch) committing OT shown in Sec-
tion 5, respectively. Notation oneside stresses that we use a one-sided UC-simulatable OT in-
stead of a fully UC simulatable OT. Let G be a group of prime order q with generator g. Deﬁne
EGCom(h, b, r) = (gr, hrgb) as the “El Gamal” commitment for a bit b. This commitment has two
important properties: (1) there exists a very eﬃcient way to prove the equality of two commitments
Namely, let c0, c1 = EGCom(h, m, r)= gr, hrgm and c(cid:48)
gm, one can
0)r−r(cid:48)
verify that (c(cid:48)
= c1; (2) there exists a trapdoor that allows the extraction of
the committed value. I.e., if h = gw, and c = (c(cid:48), c(cid:48)(cid:48)) with c(cid:48) = gr and c(cid:48)(cid:48) = hrgb, one can extract
b by checking if c(cid:48)(cid:48)
c(cid:48)w is equal to 1 or g. Both properties are used crucially to guarantee correctness
against a malicious sender. Let ReHash be a collision-resistant hash function that is a suitable
randomness extractor.
Protocol 3. NISC in the gRO model(built upon [AMPR14]).
Inputs. P1 has input x ∈ {0, 1}n1 and P2 has input y ∈ {0, 1}n2. Let f : {0, 1}n1× : {0, 1}n2 →
{0, 1}m and C be a circuit computing f. The inputs wires of P1 and P2 are denote by IN(1) and
IN(2) respectively. The set of output wires is denoted by OUT.
1 = EGCom(h, m, r(cid:48)) = gr(cid:48)
= c0 and (c(cid:48)
1)r−r(cid:48)
Enc denotes an encryption scheme, Commit denotes a commitment scheme and prf a pseudo-
random function. Let t denote the number of circuits and sid the session identiﬁer.
P1’s message:
• (Choose circuits to check) Pick a random t-bit string c1, . . . , ct. Let T be the set of i such
that ci = 1.
• (Circuit-OT queries) For each index i ∈ [t], publish oneside-COT1(ci).
• (Input-OT queries) For each input j ∈ IN(1) publish oneside-COT1(xj). Diﬀerence with [AMPR14].
We use one-sided UC-simulatable OT, instead of UC-secure OT.
P2’s message:
Commit to inputs, outputs and trapdoor.
• (Trapdoor) Pick w ∈R Zq and send h = gw.
• (Input commitment) Send EGCom(h; yj, rj) for j ∈ IN(2), where yj is its input for input-wire
j and rj is randomly chosen.
• (Output commitment) Send hj,0 = gwj,0 and hj,1 = gwj,1 for each output wire j ∈ OUT, where
wj,0 ∈R Zq and wj,1 = w − wj,0.
Generate garbled circuits. For each circuit i ∈ [t].
28
• Randomly choose qi and set seedi = gRO(sid, P2(cid:107)qi). Diﬀerence with [AMPR14]. The
seed seedi is computed by invoking the random oracle gRO.
• Compute ui,j,b = EGCom(h; b, ri,j,b) for all wire j ∈ IN(2), b ∈ {0, 1} and ri,j,b = prfseedi(“EGCom”◦
j ◦ b).
• (Compute Garbled Circuit) Compute gci:
– (Labels for input wires) For j ∈ IN(2) and b ∈ {0, 1}, set label(gci, j, b) = ReHash(P2 ◦
sid, ui,j,b).
– (Labels for other wires) Any other label for wire j and bit b is constructed as usual using
randomness generated by seedi, i.e., with randomness prfseedi(“label” ◦ j ◦ b).
• (Commitments to the input labels) Send commitments {Commit(ui,j,δi,j ), Commit(ui,j,1−δi,j )}j∈IN(2)
where bit δi,g is randomly chosen. Such commitments are computed using randomness derived
from seedi. We denote by di,j,δ the decommitment of the commitment of ui,j,δ.
Prepare cheating recovery box. For j ∈ OUT send:
• Output recovery commitments: hj,0 · gKi,j,0 and hj,1 · gKi,j,1 where Ki,j,0, Ki,j,1 are randomly
chosen.
• Two encryptions to the labels of the output: Enc(label(gci, j, 0), Ki,j,0), Enc(label(gci, j, 1), Ki,j,1).
Prepare proofs of input/output consistency.
• Let inputsi be the set {ui,j,yj , di,j,yj}j∈IN(2). Let inputsEqi be the set {rj − ri,j,yj}j∈IN(2).
• Let outputsDecomi be the set {wj,0 + Ki,j,0, wj,1 + Ki,j,1}j∈OUT(2).
• Pick a random ki and send encryption Enc(ki, inputsi ◦ inputsEqi ◦ outputsDecomi).
Prepare the OT answers.
• (Input-OT) P2 prepares the messages of oneside-COT2 for the input-OT executions. These
messages are computed on input the labels: {label(gci, j, 0)} and {label(gci, j, 1)} with i ∈ [t]
and j ∈ IN(1).
The randomness ri,j used to compute the OT message for wire j and circuit i is set as ri,j =
prfseedi(“OT (cid:48)(cid:48) ◦ 1 ◦ “r(cid:48)(cid:48) ◦ i ◦ j).
• (Circuit-OT) P2 prepares the messages oneside-COT2 for the circuit-OT executions. These
messages are computed on input the pairs (qi, ki), for i ∈ [t]. Diﬀerence with [AMPR14].
P2 transfers the query qi instead of the seed seedi.
P1’s Computation:
• Check circuit consistency. For each i ∈ T , compute seedi = gRO(sid, P2(cid:107)qi) and check
that seedi correctly generated circuit gci and the answers of the i-th execution of input-OT.
If any check fails, abort.
• Check consistency of the input/output of P2. For all circuits i ∈ [t]/T .
29
– Verify that hj,0 · hj,1 = h for j ∈ OUT.
– Check that outputsDecomi are correct discrete-logs of the values in set {hj,bgKi,j,b}j∈OUT,b∈{0,1}.
– Check that inputs, inputsEq are consistent with the input-commitments: check ui,j,yj (grj−ri,j,yj ,
hrj−ri,j,yj ) = EGCom(h; yj, rj). Otherwise abort.
– Evaluate circuit gi. Say P1 learns the labels {li,j}j∈OUT. P1 uses these labels to decrypt
the corresponding encryptions Enc(label(gci, j, b), Ki,j,b) from the cheating recovery box.
Then it checks if the result is the correct “decommitment” of the output recovery com-
mitment hj,bgKi,j,b where the b are the actual output bits P1 received from gci. If all
these steps pass for all output wires, label circuit gci as semi-trusted.
• Compute the output. If the output of all semi-trusted circuits is the same, then output
such value. Otherwise,
– Let gci, gci(cid:48) be two semi-trusted circuits that have diﬀerent outputs in the j-th output
wire, and let li,j and li(cid:48),j be their output labels. P1 learns wj,0 from one of the labels and
wj,1 from the other (since it learns Ki,j,b, Ki(cid:48),j,1−b from the cheating recovery boxes, and
wj,b + Ki,j,b, wj,1−b + Ki(cid:48),j,1−b from outputsDecomi, outputsDecomi(cid:48)).
– P1 computes w = wj,0 + wj,1 and decrypts the input-commitments provided by P2. Say
y is the input so obtained. P1 outputs f (x, y).
This concludes the description of the protocol.
Eﬃciency Our protocol inherits the same complexity of the NISC protocol of [AMPR14] with the
following additional overhead. Concerning the exponentiations, the additional overhead corresponds
to the overhead of the one-sided OT protocol that we discussed in Section 5. Concerning hash
evaluations, our protocol requires t hash evaluations for P2 necessary to obtain each seed seedi for
the PRF evaluations, and t/2 hash evaluations for the receiver when checking the garbled circuits.
6.2 Proof of security of NISC protocol
In this section we prove that Protocol 3 is UC-secure in the gRO model. We prove the following
theorem:
Theorem 2 (Protocol 3 is UC-secure in the gRO model.). Assuming that the DDH problem is
hard in G, prf is a pseudo-random function, ReHash is an extractor and a collision-resistance hash
function, then Protocol 3 is GUC-secure in the gRO model.
Proof. P1 is corrupted. We describe the strategy of the simulator S1 for the case in which P ∗
1 is
malicious. We stress that this proof is very similar to the proof provided in [AMPR14], which we
rewrite for completeness.
1 invoking the UC-
simulator of the one-sided simulatable OT protocol, where T is the set of circuits that P ∗
1 wants
to check. S1 sends message input(x) to Fnisc and obtains (P2, f (x, y)) from Fnisc. Let z = f (x, y).
It then proceeds as follows. For all i ∈ T , S1 honestly computes the garbled circuits gci with the
diﬀerence that in the circuit OT it will play replacing ki with a random string. Additionally, it
replaces all the encryptions under key ki with the encryption of 0. These diﬀerences however are
High-level description. Informally, S1 ﬁrst extracts the inputs (x, T ) of P ∗
30
not detected by a malicious P ∗
1 due to the semantic security of the encryption scheme and the UC-
security of the OT. For all i ∈ T , S1 replaces circuits gci with fake circuits which outputs always z,
using fresh randomness (instead of PRF). It computes the labels ui,j,b with commitment of 0, and
plays the input-OT using random values in place of the keys corresponding to the bits of ¯x and in
the circuit-OT using a random value instead of seedi.
1 ’s input.
The indistinguishability of the messages computed in this case follows from the pseudo-randomness
Formal proof. The formal strategy of the S1 is the following.
of the PRF, the security of EGCom, the security of garbled circuits and the OT.
Extraction of P ∗
The one-side UC-simulatability of the OT protocol guarantees that when the receiver of the OT
is corrupted, the UC simulator obtains the input used by the receiver to query the Ftot functionality.
Under this assumption, we have that P ∗
1 , which is the receiver of the OT in the NISC protocol, sent
(receive, sid-ot, ci) for i ∈ [t] and (receive, sid-ot, xj) for j ∈ IN(1), where sid-ot is the session id of
the OT protocol, to the Ftot functionality, and such messages are intercepted by S1.
Therefore, S1 obtains x = x1, . . . , xn1 and the set T , it sends input(x) to Fnisc and obtains
z = f (x, y). Then it proceeds as follows.
Simulation of P2’s second message. Let T be the set of circuits that P1 chose to open.
• (Evaluation circuits) For all i ∈ [t]\T , S1 prepares the second message as an honest P2 playing
with input 0n2 with the following diﬀerences.
– Garbled circuits. S1 replaces each gci with a garbled circuit that always output z,