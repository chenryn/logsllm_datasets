title:Practical Attack Graph Generation for Network Defense
author:Kyle Ingols and
Richard Lippmann and
Keith Piwowarski
Practical Attack Graph Generation for Network Defense∗
Kyle Ingols, Richard Lippmann, Keith Piwowarski
MIT Lincoln Laboratory
244 Wood Street
Lexington, Massachusetts 02420-9108
Email: {kwi, rpl, piwowk}@ll.mit.edu
Abstract
Attack graphs are a valuable tool to network defenders,
illustrating paths an attacker can use to gain access to a
targeted network. Defenders can then focus their efforts on
patching the vulnerabilities and conﬁguration errors that
allow the attackers the greatest amount of access. We have
created a new type of attack graph, the multiple-prerequisite
graph, that scales nearly linearly as the size of a typical
network increases. We have built a prototype system us-
ing this graph type. The prototype uses readily available
source data to automatically compute network reachability,
classify vulnerabilities, build the graph, and recommend ac-
tions to improve network security. We have tested the proto-
type on an operational network with over 250 hosts, where
it helped to discover a previously unknown conﬁguration er-
ror. It has processed complex simulated networks with over
50,000 hosts in under four minutes.
1
Introduction
Defending large enterprise networks is very difﬁcult. A
defender must be able to locate all paths into the network
and prevent attackers from using them; an attacker needs to
ﬁnd only one unprotected path. A network defender has the
advantage of intimate knowledge of the network, such as
the ways trafﬁc may move through it, the services running
on it, and the vulnerabilities in those services. A defender
can use that knowledge to improve situational awareness.
Attack graphs are one way to leverage that data. There
are many different papers on attack graphs and many rep-
resentations, but the core idea remains the same: an attack
graph shows the ways an attacker can compromise a net-
work or host. Defenders can then use the attack graph to
∗
This work is sponsored by the United States Air Force under Air Force
Contract FA8721-05-C-0002. Opinions, interpretations, conclusions and
recommendations are those of the authors and are not necessarily endorsed
by the United States Government.
identify critical bottlenecks and work to secure those bot-
tleneck hosts and services ﬁrst.
Previous work on attack graphs has suffered from two
substantial problems [19]. First, a large amount of source
data must be assembled to accurately build an attack graph,
and many past papers assume the data is both preprocessed
and extensive. While this assumption is valid for a the-
oretical graph design, it is unsuitable for implementation.
Our system assumes the data is provided in common for-
mats, and performs all of the necessary preparatory work.
Second, past research has had difﬁculty scaling to large,
enterprise-size networks with tens of thousands of hosts.
We have focused heavily on scalability concerns and have
developed a system capable of handling very large networks
in reasonable amounts of time using commodity hardware.
Our system, called NetSPA, is able to import data from
common sources, including the Nessus [4] vulnerability
scanner, Sidewinder and Checkpoint ﬁrewalls, the CVE [2]
dictionary, and the NVD [20] vulnerability database. It au-
tomatically computes reachability, or the ability for a given
host to connect to open ports on all hosts in the network. It
rapidly generates an attack graph showing how an attacker
can maximally compromise the targeted network. The tool
can model an attacker able to start from any IP address,
maximally exploiting any special “holes” in the perimeter
ﬁrewalls. Our system builds multiple-prerequisite graphs,
or MP graphs, which are faster to build and have greater ex-
pressive power than our previous work’s predictive graphs
[17, 18]. MP graphs are able to model portable creden-
tials, such as passwords, which an attacker can use from
anywhere to compromise a target. MP graph construction
is substantially faster than all other published attack graph
results of which we are aware [19, 25].
We have implemented a working prototype in Perl and
C++ that is capable of automatically computing reachability
from readily available source data, generating an MP graph,
analyzing it, and producing the graph and recommended ac-
tions as output. We have explored our system’s scalability
by evaluating simulated networks with up to 50,000 hosts,
Proceedings of the 22nd Annual Computer Security Applications Conference (ACSAC'06)0-7695-2716-7/06 $20.00  © 2006achieved. Reachability and credentials serve as prerequi-
sites to exploitation of a vulnerability instance. This model
is admittedly simplistic, but we can populate it using avail-
able data and it is realistic enough for our needs.
Our use of the term “vulnerability” is somewhat uncon-
ventional. In NetSPA, a vulnerability is any way an attacker
could gain access to a system. Examples include software
ﬂaws, trust relationships, and server misconﬁgurations. A
feature, such as remote login with the use of a private key,
is a vulnerability from the point of view of an attacker.
NetSPA requires a large amount of data to populate its
model, but system administrators often collect this data as a
matter of course. The core pieces are network topology, vul-
nerability information, and credentials. NetSPA itself runs
ofﬂine using the provided data, minimizing the risk of an
attacker obtaining the source data or resultant graph.
Network topology is obtained from both the user and the
Nessus vulnerability scanner [4]. The user must provide a
“map” of the network, enumerating the links and indicating
which Nessus scans belong to which link, and which mul-
tihomed hosts’ interfaces are on which links. The map is
fairly small and static, and should remain a tractable task
as larger networks are considered. Firewall rulesets are also
a component of the network model; the user provides the
original rulesets from the ﬁrewall directly to NetSPA, which
converts the rulesets to an internal format for use. Nes-
sus provides information on individual interfaces, ports, and
vulnerability instances.
Our concept of “credential” is any information used as
access control: a password or a private key, for example.
It may be possible to automatically determine where cre-
dentials are and what they protect – [28] has done so for
SSH, for example – but any data import will be speciﬁc to
an application or platform, hampering its use. We do not
currently have any readily available, automatable sources
of credential data, nor have we written importers that could
automatically import credential-related data.
For the sample network in Figure 1, two Nessus scans
are required: one on the left side of the ﬁrewall, targeting
hosts B, C, and D, and one on the right, targeting E and F.
If scans are not carried out inside each subnet, the ﬁrewall
could prevent Nessus from ﬁnding and reporting every host,
port, and vulnerability.
Notably absent are data regarding non-cyber attacks,
such as social engineering attacks and physical attacks on
a datacenter’s perimeter. While these threats are real and
relevant, we have focused our efforts on data that can be
readily obtained in an automated fashion. Tying the genera-
tion of the attack graph to data that can be obtained quickly
ensures that any new vulnerabilities are discovered, evalu-
ated, and reported as early as possible, minimizing the time
the network is exposed to attack.
We additionally utilize non-network-speciﬁc data which
Figure 1. Simple Example Network
and veriﬁed its value by conducting a ﬁeld test on an opera-
tional network with over 250 hosts.
For the remainder of the paper,
the simple network
shown in Figure 1 will be used to explain the data required,
computations performed, and results obtained. The attacker
begins on host A, and does not use arbitrary source IP ad-
dresses. Every other host in the network has a single open
port, with a single remotely-exploitable vulnerability. The
ﬁrewall permits hosts C and D to communicate with host E
and drops all other trafﬁc.
The paper is organized as follows: Section 2 explores
the source data required for graph generation. Vulnerabil-
ity evaluation is touched upon in Section 3. Reachability
generation is discussed in Section 4. Section 5 explains
the structure of the multiple-prerequisite attack graph and
how it is built. Section 6 proposes techniques for using the
resulting graph, by simplifying it for viewing and by auto-
matically analyzing it to produce recommended defensive
actions. Tests on real and simulated networks are covered
in Section 7. Related work is reviewed in Section 8. Section
9 concludes the paper.
2 Data Used by the NetSPA tool
NetSPA’s network model supposes that an individual
host possesses one or more interfaces which have listen-
ing addresses. These interfaces have zero or more open
ports, accepting connections from other hosts. A host and
its interfaces may have rules that dictate how network traf-
ﬁc may ﬂow to, and through, the host. A port has zero or
more vulnerability instances, particular ﬂaws or conﬁgura-
tion choices which may be exploitable by an attacker. Each
interface on a host is connected to a link, representing some
combination of hubs and switches connecting a set of inter-
faces together. An attacker is able to obtain one of four ac-
cess levels on a host: “root” or administrator access, “user”
or guest access, “DoS” or denial-of-service, or “other,” a
conﬁdentiality and/or integrity loss. The combination of a
host and an access level is an attacker state. A state may
provide the attacker zero or more credentials; vulnerability
instances may require zero or more of them. An attacker
obtains a host’s reachability if “root” or “user” access is
Proceedings of the 22nd Annual Computer Security Applications Conference (ACSAC'06)0-7695-2716-7/06 $20.00  © 20064 Computing Reachability
Computing reachability is a complex, time-consuming
task, but an attack graph system applicable to real networks
must obtain and use reachability information. Reachabil-
ity computation uses available information on the network
topology, ﬁltering devices, and hosts to ﬁnd paths between
source hosts and target ports. The rulesets of all ﬁltering
devices on the network must be imported and modeled.
A straightforward method to compute reachability is to
try to reach every known target IP address and port from
every host in the network. Such an approach would gener-
ate a reachability matrix, where a row represents a source
interface on a host, a column represents a target port on a
destination interface, and each cell indicates whether or not
the source can reach the target. A reachability matrix for the
sample network of Figure 1 is shown in Figure 2a. This is
correct, but it scales poorly in terms of both space and time.
We have made three improvements to the straightforward
approach. We collapse sections of the matrix into reacha-
bility groups [18], saving large amounts of both time and
memory. Filtering rulesets are collapsed into Binary Deci-
sion Diagrams (BDDs) [10], allowing the reachability sys-
tem to traverse a set of ﬁltering rules in constant time. We
also hypothesize a “generic attacker” by selecting a link on
which the attacker will begin and allowing the attacker to
use the most advantageous source IPs.
Reachability groups identify redundancies in the reach-
ability matrix and collapse submatrices into single subrows
before computing the contents, saving both time and space.
First, intra-subnet reachability which is not inﬂuenced by
any ﬁltering devices can be collapsed into a single subrow,
because every source interface within the subnet will have
the same reachability to all ports within that same subnet.
The two intra-subnet reachability groups for the sample net-
work are shown as light grey boxes in Figure 2b.
Second, inter-subnet reachability can be collapsed by
identifying sets of interfaces within a subnet which are
treated identically by the ﬁltering devices on the network.
If the source IP addresses of a set of interfaces on the same
subnet match in the same set of ﬁltering rules, the interfaces
are grouped together and reachability is computed for only
one of them. Grouping interfaces is expensive, but far less
expensive than actually recomputing reachability. The three
inter-subnet reachability groups for the sample network are
shown as dark grey boxes in Figure 2b.
Reachability groups drastically reduce the cost of com-
puting the reachability matrix. The collapsed reachability
matrix for the sample network, shown in Figure 2c, is 60%
smaller. The reduction is often much larger in sizeable net-
works as a larger number of interfaces collapse together into
a handful of reachability groups.
Reachability groups reduce the number of cells which
Figure 2. The (a.) Reachability Matrix, (b.)
Reachability Groups, and (c.)
Collapsed
Reachability Matrix for the Simple Example
Network
needs to be imported only once. These data, discussed in
Section 3, allow NetSPA to determine the impact of the vul-
nerability instances reported by Nessus.
NetSPA must derive a few core pieces of knowledge to
build an attack graph. For a given host, the tool must know
which ports the host can reach. For each instance of a vul-
nerability, the tool must know what is required to exploit it
and what is gained by exploiting it.
3 Vulnerability Evaluation
In addition to network-speciﬁc data, the system requires
additional knowledge about vulnerabilities. Nessus can
identify the hosts, interfaces, and ports on a network, pin-
pointing where vulnerabilities are. However, Nessus does
not clearly articulate a vulnerability’s prerequisites or what
an attacker gains by exploiting it. We deﬁne a straight-
forward representation to model vulnerability prerequisites
and postconditions.
In our model, a vulnerability has locality, indicating
whether it is remotely exploitable.
It provides an effect,
which is one of the four access levels an attacker can obtain
in our model: root, user, DoS, or other. When known, any
credentials required for exploitation are also considered.
The vulnerability model is simple because available data
constrains the ﬁdelity. Vulnerability databases such as NVD
[20] and Bugtraq [1] describe vulnerabilities’ impacts in de-
tail. Unfortunately, much of the available data is intended
for human consumption and is sometimes incorrect or out
of date [9]. NetSPA uses a simple logistic regression clas-
siﬁer, trained on a hand-evaluated sample set, to automat-
ically classify vulnerabilities. Details on the classiﬁer are
available in [18].
Our attacker model is likewise simple:
the attacker
knows about all vulnerabilities and will successfully exploit
all reachable vulnerabilities to their fullest effect. A worst-
case attacker model prevents false negatives and requires no
additional assumptions about the potential threat.
Proceedings of the 22nd Annual Computer Security Applications Conference (ACSAC'06)0-7695-2716-7/06 $20.00  © 2006must be computed. BDDs reduce the cost of computing
an individual cell. Our implementation uses the ideas of
the FIREMAN ﬁrewall modeler [33] to collapse ﬁltering
rulesets into a BDD, permitting constant-time traversal of
a ruleset. Like FIREMAN, the NetSPA prototype uses the
BuDDy library [16] to manipulate BDDs.
It is important to consider an attacker coming from an
arbitrary source location. Production ﬁrewall rulesets are
often large, and may contain mistakes allowing unintended
trafﬁc [32]. NetSPA is able to exercise all of these rules
by discovering the source IP addresses of greatest advan-
tage to an attacker. The tool collects a representative IP
address from every IP singleton, subnet, and range used in
rules in the network, and uses each of those addresses in
turn to compute reachability for the attacker’s starting loca-
tion. This can uncover interesting ﬂaws and vulnerabilities
in the network conﬁguration. The sample network in Figure
1 and graphs in Figure 3 do not use this feature.
5 Attack Graphs
It is easy to determine attack paths for the sample net-
work of Figure 1 by hand. The attacker from host A can
directly compromise hosts B, C and D. From C or D, the
attacker can traverse the ﬁrewall and compromise host E.
From E, the attacker can compromise host F, completing the
process. The paths are monotonic, assuming an attacker will
never need to relinquish a state. The assumption of mono-
tonicity greatly simpliﬁes the task of modeling attacker ac-
tions and has been made in several other papers [7, 15, 25].
Part of a full graph [8] for the sample network is shown
in Figure 3a. Nodes correspond to states, and edges to vul-
nerability instances. Full graphs add a node to the graph if
no ancestor node has the same state as the new node and
was reached via the same vulnerability as the new node. To
conserve space, the children of the B and C nodes at the top
level are omitted from the ﬁgure.
Full graphs illustrate every order in which the attacker
can compromise the hosts in the network – ﬁrst B, then C,
or vice versa. However, they scale as O(n!) and quickly
become too large to compute as the network size increases.
A predictive graph [17, 18] is shown in Figure 3b. Nodes
and edges have the same meanings as in the full graph. Pre-
dictive graphs add a node to the graph if no ancestor of the
current node used the same vulnerability to obtain the same
state as the new node. They avoid much of the redundant
structure of the full graph and correctly predict the impact
of removing any of the vulnerability instances in the net-
work. Predictive graphs are much faster to build than full
graphs, and we have used them on large, real networks, but
they still include redundant structure in some cases. For