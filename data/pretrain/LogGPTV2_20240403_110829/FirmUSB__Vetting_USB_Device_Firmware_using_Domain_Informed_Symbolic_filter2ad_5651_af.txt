object according to the lower and upper bounds inferred from the
constraint. The difference comes into play when a symbolic index
into memory may suggest going out of bounds w.r.t. an existing
memory object in KLEE, which flags it as a memory out-of-bounds
error. This is indeed what happened when we were evaluating
Query 1 on EzHID in full symbolic mode.
KLEE interleaves random path selection and a strategy to select
states that are likely to cover new code as its search heuristics. A
weight is computed for each process, and then a random process
is selected according to these weights. These heuristics take into
account the call stack of the process, whether or not the process
has recently covered new code, and the minimum distance to an
uncovered instruction. This interleaving technique shields the sys-
tem from a case where one strategy would become stuck. Once a
process is selected, it is run for a “time slice," which is defined by a
maximum amount of time and a maximum amount of instructions.
Time-slicing processes helps make sure a process that is executing
frequently with expensive instructions will not dominate execution
time. angr does not have any scheduling methods built in. It is left
up to the user to decide which paths to prioritize. The individual
execution paths in a program are managed by Path objects, which
track the actions taken by paths, the path predicates, and other
path-specific information. Groups of these paths are managed by
angr’s PathGroup functionality, where an interface is provided
for managing the splitting, merging, and filtering of paths during
dynamic symbolic execution. Additionally, angr does not collect
KLEE-like metrics such as code coverage, percent time spent in the
solver, and instructions executed.
In a symbolic execution engine, constraint solving is a major
part of checking the feasibility of a path, in order to generate as-
signments to symbolic variables and verify assertions. STP and
Z3 are popular solvers that are used in symbolic execution en-
gines. KLEE uses STP, which only has support for bit vectors and
arrays, and angr uses Z3, which supports arithmetic, fixed-size
bit-vectors, floating point numbers, extensional arrays, datatypes,
uninterpreted functions, and quantifiers. Both KLEE and angr split
constraints into independent sets to reduce the load on the solver.
Symbolic execution engines for binary code usually rely on trans-
forming native instructions into an intermediate representation.
LLVM generates the IR of the source code during the first step
of compilation. KLEE uses the IR that is generated by the LLVM
compiler for C and C++. In contrast, angr performs analysis on
the Valgrind dynamic instrumentation framework (VEX) IR. VEX
is a RISC-like language that is designed for program analysis and
generates a set of instructions for expressing programs in static
single assignment (SSA). By using VEX, they were able to provide
analysis support for 32-bit and 64-bit versions of ARM, MIPS, PPC,
and x86. Beyond existing support, VEX is a binary-first IR, meaning
it does not assume a control flow graph or memory layout. With
its basic block abstraction, executing VEX IR does not require an
entire binary program to be lifted beforehand. For larger binaries,
this demand-based lifting is superior in performance and does not
require any human intervention. Overall, VEX was built for binary-
only targets and we believe it is the better choice for supporting
new architectures.
We have explored using static analysis tools SVF [52] and DG
[19] for target identification. Although both SVF and DG provides
efficient inter-procedural analysis,14 their analysis results were
not precise enough for target finding. Specifically, the computed
alias sets were very big and even store instructions that wrote to
output ports and, hence, not read in any other part of the code have
been reported to have data dependencies. A closer analysis of the
latter problem revealed that when compiling the Phison BadUSB
firmware, the SDCC compiler used a data memory address 20h like
a register to store various flags that would affect the outcome of
various branches scattered around the various parts of the firmware
and appeared in five functions. Some of the accesses to this memory
location were for individual bits and in others to the whole byte. Our
lifter for LLVM translates accesses to individual bits by first loading
the whole byte, manipulating the individual bit, and storing the
whole byte back. Because of addressing in LLVM requires defining
a pointer to a base region and then referring to the individual bit,
translating these accesses as bit accesses would not significantly
improve the precision as the pointer to the base memory region
would still contribute to the imprecision in points-to analysis and,
hence, to dependence analysis.
In summary, angr shines in the analysis of pure binaries as
it never assumed the availability of source or symbol files. KLEE
still bests angr in raw performance (C++ vs. Python) and with a
proven and well tested process execution engine, it offers a more
traditional symbolic execution experience immediately without any
14LLVM’s optimizer tool opt is mostly intra-procedural.
13
code changes. A way to close this gap would be for the angr project
to improve and push forward a more user-friendly frontend tool
to match that of KLEE’s. Overall, when it comes to writing code
to support a new embedded architecture, angr is the better choice
due to its well-engineered modularity, active community, large
amount of documentation and examples, binary-first approach, and
easy and quick development cycle (no compilation times or hard
crashes). These benefits allow a researcher to quickly make progress
in supporting a completely new architecture and to explore areas
untouched by symbolic execution.
6.3 Firmware Obfuscation
Obfuscation of code is a long standing practice to dissuade reverse
engineering and to slow down attackers. With symbolic execution,
obfuscated code may have an effect on the execution accuracy and
performance. Unless these engines are specifically crafted to ex-
pect and handle obfuscated code, they may not be able to stand
up to these code changes [5, 64]. Currently FirmUSB’s underlying
symbolic execution engines KLEE and angr are not specifically
designed with obfuscated code in mind. This limitation would re-
quire more engineering and testing in order to ensure reasonable
performance and results in the presence of adversarial firmware.
Ignoring the timer-based delay of keyboard injection, which
causes many states and delays code coverage, the two firmware
images we analyzed can be considered unobfuscated. One of the
effective ways to obfuscate for binary analysis would be to use
as much indirection as possible for memory accesses. This would
break static cross-references and prevent data flow tracking from
USB constants. As an example, consider Algorithm 1 for identifying
target instructions to find the claimed identity. If the base address
of a configuration descriptor is stored to a memory location and
the descriptor is always accessed by first loading from that memory
location, the analysis would not be able to find any targets. A similar
effect could be achieved by storing the content of the descriptors
dynamically instead of being fixed at runtime. One can always use
over-approximate (conservative) static analysis to overcome such
obfuscation scenarios. However, for static analysis to be effective
one needs strike a balance between precision and efficiency. We
anticipate that domain knowledge, (e.g., the analyzed protocol(s)
and the specific microcontroller architecture used), will be helpful
in tuning such analyses.
6.4 Ideal Framework & FirmUSB Limitations
Currently FirmUSB does not handle automatic extraction of firmware
images from the devices themselves, as this may not be possible
or vendor specific. As such, firmware images are processed offline
from public resources or extracted from a controller manually by
a human. If FirmUSB performed automatic extraction, it would
have to trust the underlying device and USB bus to provide valid
and untampered firmware images. Even if a trusted USB bus is
assumed, analysis of the firmware itself may still be hampered by
knowledgeable actors who develop adversarial firmware. For ex-
ample, if an attacker knows that FirmUSB is being used to analyze
the firmware, he can obfuscate or cause the firmware to exhaust
the resources of the analysis engine via state explosion or delay
loops. FirmUSB will make an effort to continue in the presence
of many states by using path heuristics, but these heuristics are
fundamentally unsound. Additionally, while it is not possible to
execute data as code on the 8051 architecture – as it is a Harvard
architecture – it is still possible to realize weird machines [12] via
Return Oriented Programming (ROP) or Virtual Machines (VMs)
via existing instructions operating on data. Any vulnerability in
the firmware that could lead to arbitrary read/write or control flow
hijacking could be abused through self-exploitation [20, 21] in order
to perform computations not visible in the static machine code or
even during run-time.
Beyond limitations of the USB protocol, it would be very useful
to have an IR that reveals architectural elements, such as memory
mapped or special function registers, to facilitate analysis of diverse
microcontroller firmware. VEX and LLVM were not good fits for
the 8051’s overlapping memory model.15 To enable precise analysis,
bit level operations should also be straightforward to express in the
IR, i.e., without resorting to tricks such as accessing the containing
byte and manipulating it to achieve the intended effect
Symbolic execution will remain a key analysis component for
firmware analysis. However, since most symbolic execution engines
have been initially designed for analyzing user space binaries, ex-
tensions for embedded systems such as interrupts and the memory
layouts have been implemented as addons to Fie and to angr. A
symbolic execution engine that provides a flexible interface for
both specifying and controlling architectural aspects will be easier
to engineer using domain knowledge. Also, analyzing malicious
firmware would likely involve resolving intended as well as acciden-
tal16 obfuscation. Hence, symbolic execution should have flexible
interfacing with other static as well as dynamic analysis compo-
nents and enable reuse of facts it gathers at various phases of the
analysis.
7 RELATED WORK
USB Security. Modern operating systems fundamentally trust
plugged in USB devices, as security decisions are left to users. As
a result, operating systems and users are open to a wide variety
of attacks including malware and data exfiltration on removable
storage [31, 47, 61], tampered device firmware [13, 41], and unau-
thorized devices [42]. Solutions for applying access control to USB
storage devices [30, 45, 53, 66] cannot assure that USB write re-
quests are prevented from reaching the device. Further, protections
against unauthorized or malicious device interfaces [46, 55] and
disabling device drivers are coarse and cannot distinguish between
desired and undesired usage of a particular interface. Researchers
have turned to virtualization as another means of providing security
within USB. GoodUSB [55] leverages a QEMU-KVM as a honeypot
to analyze malicious USB devices, while Cinch [2] separates the
trusted USB host controller and untrusted USB devices into two do-
mains where a gateway applies administration supplied policies to
USB packets. USBFILTER [57] acts as firewall for USB and enables
system administrators to only allow certain types of USB traffic.
USB devices themselves can also provide protection from malicious
hosts. USB fingerprinting [6] establishes the host machine identity
15Code, internal RAM, and external RAM all start at address zero.
16Even certain code patterns the compilers generate for efficiency may become a
bottleneck from static analysis perspective.
14
using USB devices, while device-based mechanisms can attest in-
tegrity [15], provide malware forensics [56], provide policy [59, 62]
or allow for protocol fuzzing [11].
Firmware Analysis. Fie [28] is an embedded firmware analysis
platform targeting MSP430 micro-controllers, as described previ-
ously. It leverages Clang’s support for MSP430, requiring memory
layout and the interrupt functions. Fie models the reactive nature
of firmware via scheduling interrupt functions at various gran-
ularities. AVATAR [67] uses the S2E symbolic execution engine
to run firmware binaries in an emulator while forwarding I/O re-
quests to the physical device and processing the responses from
the device through state migration. S2E is further used [7] to gen-
erate test-cases for System Management Mode interrupt handlers
in BIOS implementations for Intel-based platforms. Firmalice [48]
utilizes symbolic execution and program slicing to discover back-
doors and their triggers in firmware images. [27] and FIRMADYNE
[23] present light-weight static and dynamic analysis, respectively,
for a large set of firmware collected through web-crawling. By
contrast, FirmUSB leverages domain knowledge of USB and embed-
ded systems to detect BadUSB type attacks by discovering hidden
functionality and inconsistent functioning.
Symbolic execution. Symbolic execution engines that have been
designed for analyzing systems code include EXE [17], KLEE [16],
SAGE [32], CREST [14], BitBlaze [50], S2E [24], Cloud9 [25], DDT
[36], McVETO [54], and angr [49]. In the context of security, sym-
bolic execution [35] has been used for a wide number of applica-
tions; a sample of these include generating exploits for control-flow
hijacking [3], buffer overflows [43] and other memory corruption
vulnerabilities [49, 51] detecting exploitable bugs in binaries [18]
and web applications [9, 22, 38, 39] proving confidentiality and
integrity properties [26], analyzing BIOS firmware for security [7],
analysis of embedded systems’ firmware binaries [48, 67] and code
[28], input generation for obfuscated code through bit-level taint
tracking and architecture aware constraint generation [65], find-
ing trojan message vulnerabilities in client-server systems [4], and
many others. Our domain specific path constraining is similar to
preconditioned symbolic execution in [3], which constrains input
length and input prefix. [65] identifies inputs as those written by a
library routine and then immediately read in the program, which ap-
plies to user space programs. Our symbolic value finding algorithm,
on the other hand, is customized for interrupt driven firmware.
Architecture lifters. To analyze binaries, a first step is to lift the
ISA of the target device into an IR for analysis. radare2 [44] is a
reverse engineering tool that lifts ISAs for many architectures, in-
cluding 8051, into its intermediate representation, ESIL. However,
ESIL is not popular beyond radare and its main focus is emulation
to assist static analysis – not symbolic execution. REV.NG [29]
leverages QEMU’s TCG to lift various ISAs to LLVM IR. Similarly,
angr [49] leverages libVEX, the IR lifter of Valgrind. Neither QEMU
nor libVEX currently support 8051. Binary Ninja [60] is a reverse
engineering platform that implements a custom IR called Low-level
Intermediate Language (LLIL). A community plugin [1] lifts 8051
to LLIL, but there are no currently available symbolic execution en-
gines for LLIL. Precision of binary analysis depends on the accuracy
of binary disassembly, which is undecidable in the general case. It
15
can, however, benefit from static analysis, especially when assump-
tions on compilers’ behavior may not apply [29]. Lim et al. present
a specification language, TSL [37], for defining concrete operational
semantics of machine-code instruction sets, enabling automated
generation of different abstract interpreters for an instruction set
and retargeting to new instruction sets. Neither LLVM nor VEX has
been target of such parameterized analysis effort. However, LLVM
has received more attention from the program analysis community
[10, 33, 34].
8 CONCLUSION & FUTURE WORK
This paper presented a domain informed firmware analysis that
is effective in detecting BadUSB type attacks. We have formulated
two semantic queries that would help reveal characteristics of a
USB device. Our experiments confirm effectiveness of using domain
specific heuristics for finding symbolic values and for reducing the
amount of explored paths. Our lifting of 8051 instruction set to two
popular IRs enabled us to leverage a source-level firmware analysis
tool, Fie, and a binary analysis tool for user space code, angr. We
faced various challenges in customizing these two tools to binary
analysis and to an embedded domain. We believe that a binary anal-
ysis framework for firmware needs an intermediate representation
and supporting analyses engines that are architecture-aware. As
future work, we would like to automate the lifting process to enable
analysis for other less common architectures.
ACKNOWLEDGMENTS
This work is supported in part by the US National Science Founda-
tion under grant CNS-1254017.
REFERENCES
[1] amtal. 2017. Binary Ninja 8051 Architecture Plugin. https://github.com/amtal/
i8051. (2017).
[2] Sebastian Angel, Riad S Wahby, Max Howald, Joshua B Leners, Michael Spilo,
Zhen Sun, Andrew J Blumberg, and Michael Walfish. 2015. Defending against
malicious peripherals. arXiv preprint arXiv:1506.01449 (2015).
[3] Thanassis Avgerinos, Sang Kil Cha, Brent Lim Tze Hao, and David Brumley. 2011.
AEG: Automatic Exploit Generation. In Proceedings of the Network and Distributed
System Security Symposium, NDSS 2011, San Diego, California, USA, 6th February
- 9th February 2011.
[4] Radu Banabic, George Candea, and Rachid Guerraoui. 2014. Finding Trojan
Message Vulnerabilities in Distributed Systems. SIGPLAN Not. 49, 4 (Feb. 2014).
[5] Sebastian Banescu, Christian Collberg, Vijay Ganesh, Zack Newsham, and Alexan-
der Pretschner. [n. d.]. Code Obfuscation Against Symbolic Execution Attacks.
In Proceedings of the 32Nd Annual Conference on Computer Security Applications
(2016) (ACSAC ’16). ACM, 189–200. https://doi.org/10.1145/2991079.2991114
[6] Adam Bates, Ryan Leonard, Hannah Pruse, Daniel Lowd, and Kevin Butler. 2014.
Leveraging USB to Establish Host Identity Using Commodity Devices. In Pro-
ceedings of the 21st ISOC Network and Distributed System Security Symposium
(NDSS’14). San Diego, CA, USA.
[7] Oleksandr Bazhaniuk, John Loucaides, Lee Rosenbaum, Mark R. Tuttle, and
Vincent Zimmer. 2015. Symbolic Execution for BIOS Security. In Proceedings of
the 9th USENIX Conference on Offensive Technologies (WOOT’15). 8–8.
[8] Brian Benchoff. 2017. The USB Killer, Version 2.0. (2017). https://hackaday.com/
2015/10/10/the-usb-killer-version-2-0/
[9] Prithvi Bisht, Timothy Hinrichs, Nazari Skrupsky, and V. N. Venkatakrishnan.
2014. Automated Detection of Parameter Tampering Opportunities and Vulnera-
bilities in Web Applications. J. Comput. Secur. 22, 3 (May 2014), 415–465.
[10] Guillaume Brat, Jorge A. Navas, Nija Shi, and Arnaud Venet. 2014. IKOS: A Frame-
work for Static Analysis Based on Abstract Interpretation. In Software Engineering
and Formal Methods - 12th International Conference, SEFM 2014, Grenoble, France,
September 1-5, 2014. Proceedings. 271–277.
[11] Sergey Bratus, Travis Goodspeed, and Peter C Johnson. 2011. Perimeter-Crossing
Buses: a New Attack Surface for Embedded Systems. In Proceedings of the 7th
Workshop on Embedded Systems Security (WESS 2012). Tampere, Finland.
(2017).
[12] Sergey Bratus, Michael E Locasto, Meredith L Patterson, Len Sassaman, and Anna
Shubina. 2011. Exploit programming: From buffer overflows to weird machines