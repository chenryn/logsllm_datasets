### 图3：Code Red II 类蠕虫在1,280,000节点网络中的初始传播阶段

有趣的是，感染数量的指数增长在初次感染后仅35秒就开始显现。实验使用了GTNetS在128-CPU Linux集群上进行包级模拟。

### 图5：Slammer类UDP蠕虫通过307,200节点复杂网络拓扑的传播

整个模拟是在PDNS中以包级粒度在128-CPU Linux集群上完成的。

我们使用模仿Code Red II蠕虫的TCP基础蠕虫模型进行了实验，以测试大规模高保真蠕虫建模的可行性。利用类似于SQL Slammer的UDP蠕虫包级模型，我们在包含超过300,000个终端主机的大规模网络上模拟了蠕虫的传播。图5展示了在一个300,000节点网络上的样本蠕虫传播实验结果。该网络拓扑由多个“类似大学校园”的子网组成，这些子网通过网关路由器网络连接。每个校园子网大约包含30个路由器和508个终端主机。

此次实验代表了我们所知的最大规模的包级蠕虫模拟之一。它展示了当前计算平台和仿真工具可以实现的包级模型模拟规模。这种模型能够捕捉所有网络细节，如路由器处的排队和拥塞等。蠕虫的传播轨迹符合预期的流行病模型。更重要的是，包级模型的强大之处在于其能够轻松适应蠕虫行为（例如智能命中列表扫描）以及网络拓扑、背景流量强度等动态变化。

### 4. 构造性仿真

具备高保真蠕虫模型仿真能力后，我们准备迎接下一个挑战。在与军事网络建模和仿真相关的项目[20]中，我们的任务是探索如何针对大规模蠕虫攻击的模拟场景来演练实际网络安全设施。相比于使用实时测试平台，对安全系统进行模拟攻击测试具有灵活性、可控性和可重复性的优势。首个候选测试设施是一个蜜罐系统。虽然最初看起来这只是一个传统网络仿真技术的直接应用，但进一步分析显示，这种情况需要一种新的仿真能力，如下所述。

#### 4.1 仿真架构

**图6：传统仿真架构**
- **真实**：例如，蜜罐安装
- **虚拟**：路由器/链路模型在PDNS中
- **终端主机**（蠕虫）

**图7：构造性仿真架构**
- **真实**：例如，蜜罐安装
- **虚拟**：路由器/链路模型和终端主机模型在PDNS中
- **（蠕虫）在PDNS中**

现有仿真系统的缺点是它们要求终端主机必须作为真实的终端主机系统实现。如图6所示的传统仿真架构中，蠕虫感染需要从真实主机开始并结束。然而，这使得在蠕虫传播实验中难以处理大量易受攻击的终端主机。大多数现有的仿真系统，包括最具扩展性的系统（如犹他大学的Netbed[2]和UCLA的MAYA[21]），只允许仿真的部分作为传输平面，而没有网络端点。MIT的LARIAT[3]系统支持虚拟终端主机应用程序，但受限于非常低保真的网络模型。在我们的蠕虫仿真场景中（例如，蜜罐仿真，如下所述），我们需要模拟易受攻击或被感染的节点直接与实际蜜罐安装进行交互。因此，仿真系统的虚拟部分需要维护与每个可以与真实端点系统交互的交互端点相关联的所有状态。例如，每个模拟端点都需要建模和维护完整的TCP状态机。传统仿真系统既不具备维持这种状态的能力，也没有必要的转换机制来弥合建模端点和真实系统之间的语义/表示差距。在传统仿真系统中，这将需要配置和集成数千个真实主机到仿真设置中，才能进行大规模高保真的蠕虫传播实验。相反，理想情况下只需一小部分终端主机作为真实主机实现，其余终端主机则在仿真内部实例化，如图7所示。例如，只需在真实主机（如配置并在Linux上运行）上实现蜜罐安装，而蠕虫本身则从网络仿真器内的终端主机发起。这样就可以实现蠕虫传播的可扩展执行（在仿真器内），同时仍能测试蜜罐安装对大规模蠕虫攻击的有效性。

#### 4.2 示例：蜜罐仿真

蜜罐通过以下方案引入仿真中。首先，像往常一样在仿真器中配置包含终端主机和路由器的整个感兴趣网络。但是，需要插入蜜罐的终端主机被标记为“仿真节点”。在这些节点中，使用特殊的“仿真TCP”代理代替通常的TCP仿真模型。仿真TCP代理本身没有任何TCP端点行为，只是充当通往实际蜜罐中TCP堆栈的通道。例如，当一个SYN数据包事件到达仿真节点时，仿真TCP代理会执行一些简单的转换，将其格式化为合法的网络数据包，并通过代理服务器转发给蜜罐。仿真TCP代理维护最少的状态，用于将仿真事件转换为网络数据包，反之亦然（例如，序列号转换）。每个虚拟IP地址都与仿真器中的相应仿真节点关联。

由于我们的网络是并行仿真的，因此网络被划分为多个处理器。我们需要区分哪些处理器持有仿真节点，哪些不持有。如果处理器不包含任何仿真节点，则以尽可能快（AFAP）模式进行仿真（即忽略时间推进）。持有仿真节点的处理器需要进行特殊初始化，以设置通往蜜罐安装的通道。这是通过仿真处理器和代理服务器之间的基于套接字的通信来完成的。此外，仿真循环被修改以接受传入的数据包。