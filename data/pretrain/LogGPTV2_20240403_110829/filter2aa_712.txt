Apache Solr Injection 
Michael Stepankin
@artsploit
DEF CON 27
@whoami – Michael Stepankin
•
Security Researcher @ Veracode 
•
Web app breaker
•
Works on making Dynamic and Static Code Analysis smarter
•
Penetration tester in the past
•
Never reported SSL ciphers
Ones upon a time on bug bounty…
What is Solr?
•
Solr is the popular, blazing-fast, open source enterprise search 
platform built on Apache Lucene
•
Written in Java, open source
•
REST API as a main connector
•
Used by many companies (AT&T, eBay, Netflix, Adobe etc…)
https://lucene.apache.org/solr/
How does it look like?
Solr Quick Start
$ ./bin/solr start -e dih
//start solr
//add some data
//search data
Solr 101: simple query
Requested content-type
Solr 101: more complex query
Local parameter name (default field)
Parser type
Collection (‘database’) name
Request Handler (select, update, config)
Solr 101: more complex query
Requested Fields (columns)
Subquery for column ‘similar’
Requested response type
Common Solr Usage in Web App
: 
Common Solr Deployment: behind a web app
: 
Browser
Solr
/search?q=Apple
/solr/db/select?q=Apple&fl=id,name&rows=10
Solr Parameter Injection (HTTP Query Injection)
: 
Browser
Solr
/search?q=Apple%26xxx=yyy%23
/solr/db/select?q=Apple&xxx=yyy#&fl=id,name&rows=10
Solr Parameter Injection: Caveats
•
We can add arbitrary query parameters, but:
•
The request is still handled by the SearchHandler
•
We cannot rewrite collection name
•
But Solr still have some magic for us…
Solr Parameter Injection: Magic Parameters
GET /solr/db/select?q=Apple&shards=http://127.0.0.1:8984/solr/db&qt=/
config%23&stream.body={"set-property":{"xxx":"yyy"}}&isShard=true
•
shards=http://127.0.0.1:8984/solr/db - allows to forward this request to
the specified url
•
qt=/config%23 – allows to rewrite query 
•
stream.body={"set-property":{"xxx":"yyy"}} – treated by Solr as a POST
body
•
isShard=true - needed to prevent body parsing while proxying
Solr Parameter Injection: Magic Parameters
GET /solr/db/select?q=Apple&shards=http://127.0.0.1:8984/solr/db&qt=/
config%23&stream.body={"set-property":{"xxx":"yyy"}}&isShard=true
Solr Parameter Injection: collection name leak
Solr Parameter Injection: update another collection
* The error is thrown after the update is done
Solr Parameter Injection: query another collection
* We can rename columns in our query to match the original collection
Solr Parameter Injection: JSON response rewriting
* json.wrf parameter acts like a JSONp callback,
May work depending on the app’s JSON parser
Solr Parameter Injection: XML response poisoning
* ValueAugmenterFactory adds a new field to every returned document
Solr Parameter Injection: XSS via response poisoning
* Xml Transformer inserts a valid XML fragment in the document
Solr Local Parameter Injection
: 
Browser
Solr
/search?q={!dismax+xxx=yyy}Apple
/solr/db/select?q={!dismax+xxx=yyy}Apple&fl=id…
Solr Local parameter injection
•
Known since 2013, but nobody knew how to exploit
•
We can specify only the parser name and local parameters
•
‘shards’, ‘stream.body‘ are not ‘local’
•
XMLParser is the rescue!:
Solr Local parameter injection: CVE-2017-XXXX
•
XMLParser is vulnerable to XXE, allowing to perform SSRF:
•
Therefore, all ‘shards’ magic also works if we can only control the ‘q’ param!
Wait!
Are you mad telling us about HTTP injection, XXE and (even) XSS?
Where is my CALCULATOR???!!!
Ways to RCE
• Documentation does not really help
• But It’s java, so….
• For sure it has XXEs
• For sure it has Serialization
• Indeed it has ScriptEngine()
• Indeed it even has Runtime.exec()
CVE-2017-12629 RunExecutableListener RCE
Target versions: 5.5x-5.5.4, 6x-6.6.3, 7x – 7.1
Requirements: None
CVE-2017-12629 RunExecutableListener via shards
•
(step 1) Add a new query listener
•
(step 2) Perform any update operation
*Tnx Olga Barinova (@_lely___) for help with making it workJ
CVE-2017-12629 RunExecutableListener via XXE
•
(step 1) Add a new query listener
•
(step 2) Perform any update operation
CVE-2019-0192 RCE via jmx.serviceUrl
Target versions: 5x – 6x. In v7-8 JMX is ignored 
Requirements: OOB connection or direct access
CVE-2019-0192 RCE via jmx.serviceUrl
What happen inside?
Leads to un.rmi.transport.StreamRemoteCall#executeCall and 
then to ObjectInputStream.readObject()
CVE-2019-0192 RCE via jmx.serviceUrl
1st way to exploit (via deserialization)
•
Start a malicious RMI server serving ROME2 object payload on port 1617
•
Trigger a Solr connection to the malicious RMI server by setting the
jmx.serviceUrl property
•
RMI server responds with a serialized object, triggering RCE on Solr
*Note: ROME gadget chain requires Solr extraction libraries in the classpath
CVE-2019-0192 RCE via jmx.serviceUrl
CVE-2019-0192 RCE via jmx.serviceUrl
2nd way to exploit (via JMX)
•
Create an innocent rmiregistry
•
Trigger a Solr connection to the rmiregistry by setting the jmx.serviceUrl
property. It will register Solr’s JMX port on our rmiregistry.
CVE-2019-0192 RCE via jmx.serviceUrl
2nd way to exploit (via JMX)
•
Connect to the opened JMX port and create a malicious MBean
CVE-2019-0193 DataImportHandler RCE
Target version: 1.3 – 8.1.2
Requirements: DataImportHandler enabled
Example: search.maven.org
Example: search.maven.org
Example: search.maven.org
Example: search.maven.org
Example: search.maven.org
Thank you!
F u ll wh itep ap er a t:
h ttp s ://g ith u b .c o m/v e ra c o d e -
re s e a rc h /s o lr-in jectio n