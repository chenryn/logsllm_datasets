title:FlowWatcher: Defending against Data Disclosure Vulnerabilities in
Web Applications
author:Divya Muthukumaran and
Dan O'Keeffe and
Christian Priebe and
David M. Eyers and
Brian Shand and
Peter R. Pietzuch
FlowWatcher: Defending against Data Disclosure
Vulnerabilities in Web Applications
Divya Muthukumaran
Imperial College London
Dan O’Keeffe
Imperial College London
Christian Priebe
Imperial College London
David Eyers
University of Otago
Brian Shand
NCRS, Public Health England
Peter Pietzuch
Imperial College London
ABSTRACT
Bugs in the authorisation logic of web applications can expose the
data of one user to another. Such data disclosure vulnerabilities are
common—they can be caused by a single omitted access control
check in the application. We make the observation that, while the
implementation of the authorisation logic is complex and therefore
error-prone, most web applications only use simple access control
models, in which each piece of data is accessible by a user or a
group of users. This makes it possible to validate the correct op-
eration of the authorisation logic externally, based on the observed
data in HTTP trafﬁc to and from an application.
We describe FlowWatcher, an HTTP proxy that mitigates data
disclosure vulnerabilities in unmodiﬁed web applications. Flow-
Watcher monitors HTTP trafﬁc and shadows part of an applica-
tion’s access control state based on a rule-based speciﬁcation of
the user-data-access (UDA) policy. The UDA policy states the in-
tended data ownership and how it changes based on observed HTTP
requests. FlowWatcher detects violations of the UDA policy by
tracking data items that are likely to be unique across HTTP re-
quests and responses of different users. We evaluate a prototype
implementation of FlowWatcher as a plug-in for the Nginx reverse
proxy and show that, with short UDA policies, it can mitigate CVE
bugs in six popular web applications.
Categories and Subject Descriptors
D.4.6 [Security and Protection]: Access Controls
Keywords
Web application security; Data disclosure; HTTP Proxy; Policy
1.
INTRODUCTION
Web application vulnerabilities are a major source of security
incidents on the Internet. Different types of vulnerabilities have
different mitigation strategies: e.g. data injection and validation
bugs [37] can be prevented by using templates [39] or dynamic
data tracking [28].
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full citation
on the ﬁrst page. Copyrights for components of this work owned by others than the
author(s) must be honored. Abstracting with credit is permitted. To copy otherwise, or
republish, to post on servers or to redistribute to lists, requires prior speciﬁc permission
and/or a fee. Request permissions from Permissions@acm.org.
CCS’15, October 12–16, 2015, Denver, Colorado, USA.
Copyright is held by the owner/author(s). Publication rights licensed to ACM.
ACM 978-1-4503-3832-5/15/10 ...$15.00.
DOI: http://dx.doi.org/10.1145/2810103.2813639 .
Data disclosure vulnerabilities, which expose the data of one
user to another, however, are harder to protect against because they
are typically caused by semantic bugs in the authorisation logic of
web applications. In the 2013 OWASP ranking of web application
security risks [38], four out of the top ten risks are related to incor-
rectly implemented access control checks; the 2014 Website Se-
curity Statistics Report [53] states that information leakage, which
includes data disclosure, is the second most prevalent vulnerability
in web applications.
Web applications typically execute at a higher privilege level
than that of individual users, which means that they must imple-
ment their own checks for enforcing a given access control model.
Protecting against data disclosure vulnerabilities is thus difﬁcult be-
cause a single omitted check may expose user data. While the core
components of web applications receive much scrutiny by devel-
opers, missing checks often exist in third-party plug-ins and exten-
sions. In the twelve months from August 2013, 16% of security
bugs reported in CVE [9] for Drupal [16] were related to unautho-
rised data disclosure in plug-ins.
Existing proposals to mitigate data leakage vulnerabilities have
drawbacks, and, in many cases, missing access control checks are
only discovered after the vulnerability has been exploited [34]: pro-
gram analysis techniques [50] can detect missing checks but re-
quire access to the source code, are language-speciﬁc and strug-
gle with complex applications; techniques based on input valida-
tion [25] focus on injection attacks, which may cause data disclo-
sure, but they cannot detect data disclosure due to semantic bugs
in the authorisation logic; and anomaly detection approaches [26]
can prevent unauthorised data disclosure if it constitutes a deviation
from regular application behaviour, but for many applications the
“normal” behaviour cannot be captured reliably.
Instead of establishing the correctness of all access control checks
that are dispersed throughout an application’s source code, our idea
is to adopt a “defence-in-depth” approach that validates the cor-
rect operation of the access control policy outside of the applica-
tion. This is enabled by the observation that many web applica-
tions, such as Drupal [16], WordPress [54] or DokuWiki [12], only
implement relatively simple access control models: e.g. they dis-
tinguish between users (or groups of users) that have access rights
to data objects such as web pages, posts or comments. It is thus
possible to introduce an external proxy that observes the HTTP re-
quest and response trafﬁc of all users and, based on a speciﬁcation
of the intended access control policy of the application, detects and
prevents unauthorised data disclosure.
A proxy-based approach for mitigating unauthorised data disclo-
sure has several beneﬁts: it can be applied across a range of differ-
ent web applications, as long as the enforced policy can be tailored.
603The proxy does not need to implement the full policy of the appli-
cation, but can only check a subset of it. Due to its smaller code
base and single enforcement point compared to checks scattered
throughout the application, the correct enforcement of the policy
by the proxy is easier to guarantee. Finally, a proxy should have no
performance impact and does not require modiﬁcations to the ap-
plication, making it applicable to closed-source web applications
and services.
The approach raises two challenges, however, which we over-
come in this paper: (i) how does the proxy express the access con-
trol policy of an application and keep it up-to-date as new users,
groups and data objects are added? For example, when a new post
is created by a user in WordPress, the proxy must associate this new
data object with the users and groups that are permitted to access it.
Policies should be written once by application developers who un-
derstand the intended access control model of their application; and
(ii) how does the proxy efﬁciently track user data across HTTP re-
quests and responses of different users in order to detect violations
of the access control policy? Data tracking should be effective at
identifying unauthorised data disclosure, be efﬁcient to implement
and not require changes to web applications.
We describe FlowWatcher, a proxy that mitigates data disclo-
sure vulnerabilities in web applications by monitoring their HTTP
trafﬁc and prohibiting incorrect data ﬂows.
User-data-access policy. FlowWatcher relies on a speciﬁcation
of the intended access control policy, which is written once by ap-
plication developers in a domain-speciﬁc rule-based language as a
user-data-access (UDA) policy. A UDA policy encodes the dy-
namic access control model of an application:
it describes how
HTTP requests and responses change the access control state. UDA
policies are typically concise, making it easier to establish their cor-
rectness. Since FlowWatcher adds an additional layer of security,
UDA policies do not have to be complete but can capture a subset
of the application’s access control model.
Dynamic policy evolution. A UDA policy contains rules that link
HTTP requests and responses to (i) the deﬁnition of new users,
groups or data objects and to (ii) updates of the access control pol-
icy. Each rule can match an HTTP request according to its URL,
header ﬁelds or body content such as form ﬁelds. After matching,
a rule can update the current access control state, e.g. give a user
access to a data object, or add them to a group.
Data tracking. By intercepting the authentication method of the
application, FlowWatcher associates each HTTP request and re-
sponse with a user. As deﬁned by the UDA policy, FlowWatcher
selects user data objects in HTTP requests, which may be stored
in form ﬁelds, and tracks ones that are likely to be unique due to
their length or semantics, such as social security numbers or postal
addresses. When a tracked object appears as part of another user’s
HTTP response, FlowWatcher decides if the data access is autho-
rised based on its shadow access control state.1
Evaluation. We show that UDA policies for real-world web ap-
plications are simple—the policies for Drupal [16], WordPress [54]
and DokuWiki [12] have 43, 23 and 26 lines, respectively; they are
effective—FlowWatcher can mitigate 9 data disclosure vulnerabil-
ities from the CVE database reported for 6 popular web applica-
tions; and FlowWatcher is efﬁcient—its implementation as an Ng-
inx plug-in [35] does not have a measurable impact on application
throughput or latency.
1Note that FlowWatcher relates access control decisions to exter-
nally observable dataﬂows of unique data—its goal is not to pre-
vent disclosure of low-entropy ﬁelds, e.g. a hometown that may be
common to multiple users
Next we motivate the problem and position our approach with re-
spect to other techniques. §3 describes our domain-speciﬁc policy
language, giving examples of how it expresses the access control
models of web applications. We present the design and implemen-
tation of FlowWatcher in §4 and the results of our experimental
evaluation in §5. The paper ﬁnishes with a comparison of Flow-
Watcher to related work (§6) and conclusions (§7).
2. PREVENTING DATA DISCLOSURE
Next we discuss data disclosure vulnerabilities in web applica-
tions (§2.1), categorise existing approaches to mitigate web vulner-
abilities (§2.2), and explain the idea behind our approach, empha-
sising the differences to previously proposed techniques (§2.3).
2.1 Data disclosure in web applications
It is difﬁcult to implement an access control model correctly in a
web application. Due to the semantic mismatch between the access
control model of the underlying platform (e.g. UNIX access con-
trol lists) and that of the application, web applications must execute
with a superset of all privileges of their users. This requires them to
guard operations that access or update user data with access control
checks to ensure their compliance with a given security policy. Ac-
cess control checks are typically sprinkled throughout the source
code of an application.
For example, the convention for Drupal modules [16] is to guard
all database queries by tagging them with the string “node_access”,
which causes an access control check to occur. The following PHP
fragment issues a query that returns the most recently modiﬁed
pages to a user:
1 $nids = $query->fields(’n’, array(’nid’))
2
->orderBy(’n.changed’, ’DESC’)
->range(0, $number)
->addTag(’node_access’)
->execute()->fetchCol();
3
4
5
6 $nodes = node_load_multiple($nids);
The tag in line 4 ﬁlters query results based on the permissions of the
user issuing the query. Omitting the tag by accident in a complex
query would reveal private pages of other users in the result set.
More generally, a vulnerability that leads to data disclosure may
be caused by several types of bugs:
• Missing check: An attacker may access another user’s data by
exploiting the fact that no check is carried out for a particular
data object. For example, Drupal suffered from a vulnerabil-
ity in 2012 in which the Organic Groups add-on module was
missing an access check that allowed non-members to view in-
formation about private groups (CVE-2012-2081).
• Avoided check: An attacker may access data without authorisa-
tion by triggering a code path that avoids an existing check, e.g.
by inducing an error condition. For example, the phpBB [43]
application contained a bug (CVE-2010-1627) that exposed in-
formation in private forums to non-members via RSS feeds,
even if the forums were not accessible directly to the users.
• Incorrect check: An access control check may be implemented
incorrectly—a plug-in developer may misunderstand the access
control model of the application or make an incorrect assump-
tion about an API. An example of this is an execution-after-
redirect vulnerability in which a check is performed and unau-
thorised users are redirected to an error page, but the privileged
operation is executed regardless, returning sensitive information
in the HTTP response [13].
604Approach
Types of
bugs
Missing access check detection [32, 50, 51] access control
Input validation testing [2, 3, 25, 52, 4, 49] data sanitisation
Execution anomaly detection [8, 21, 30]
Trafﬁc anomaly detection [24, 26, 29, 42]
Dynamic data tracking [10, 55]
semantic
semantic
tation
tool
tool
interpreter
proxy
access control
data disclosure
interpreter
proxy
FlowWatcher
Implemen- Execution No source Unmodiﬁed No training
code required