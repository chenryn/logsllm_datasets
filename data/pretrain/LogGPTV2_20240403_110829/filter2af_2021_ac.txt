            File plaintextFile = new File(plaintextFilename);
            decryptFile(ciphertextFile, plaintextFile, keyString);
        }
        public static void decryptFile(File ciphertextFile, File plaintextFile, String keyString) {
            BufferedOutputStream v1_5;
            Throwable v8;
            int v1_1;
            FileInputStream v2;
            BufferedOutputStream v0_2;
            FileOutputStream v2_1;
            FileInputStream v3;
            FileOutputStream v1 = null;
            try {
                v3 = new FileInputStream(ciphertextFile);
                v2_1 = new FileOutputStream(plaintextFile);
                v0_2 = new BufferedOutputStream(((OutputStream)v2_1));
                v1_1 = 1024;
                byte[] v1_4 = new byte[v1_1];
                while(true) {
                    int v4 = v3.read(v1_4);
                    if(v4 == -1) {
                        break;
                    }
                    byte[] v5 = new byte[v4];
                    System.arraycopy(v1_4, 0, v5, 0, v4);
                    v0_2.write(decrypt(v5, keyString));
                }
                v3.close();
                v0_2.flush();
                v0_2.close();
                v2_1.close();
                v3.close();
                v0_2.close();
                v2_1.close();
            }
            catch(Exception v0_1) {
            }
        }
        public static void junk(int[] arg2, int arg3, int arg4) {
            int v0 = arg2[arg3];
            arg2[arg3] = arg2[arg4];
            arg2[arg4] = v0;
        }
        public static byte[] decrypt(byte[] ciphertextBytes, String keyString) {
            return decrypt(ciphertextBytes, keyString.getBytes());
        }
        public static byte[] decrypt(byte[] ciphertextBytes, byte[] keyBytes) {
            int v1 = 0;
            int[] v3 = new int[256];
            int v0;
            for(v0 = 0; v0 
此时如果受害者使用 Maxthon 浏览器访问恶意页面，那么他们的加密 JAR 文件（tdata_rqS304)将被我们制作的 JAR 文件覆盖。
—— 校验 “webapp” 已安装
我们的 Java payload 将在下次浏览器重新启动时解密并执行。执行类加载的代码会尝试使用 `IPushExtension`
接口转换对象，该操作会失败，但是我们的代码在构造函数中已经执行，并且类加载已经代码正常处理该异常，所以浏览器工作正常不会崩溃。
—— 执行远程代码完毕
### 漏洞披露流程
  * 2/12/16 – 向厂商公开任意文件写入/远程代码执行漏洞。
  * 2/14/16 – 向厂商公开登录页 UXSS 漏洞和 SQL 注入漏洞。
  * 2/15/16 – 厂商回应说所有问题已修复。提供了本地服务器上的新 APK 的链接。
  * 2/15/16 – 要求供应商直接发送修复后的 APK ，或直接在公网服务器上提供访问。
  * 2/18/16 – 厂商提供新 APK 的公网链接。
  * 2/18/16 – 通知厂商修复程序未正确解决所有问题 (仅解决部分问题)。
  * 2/19/16 – 厂商声明他们正在研究。
  * 3/8/16 – 询问厂商的状态。
  * 3/9/16 – 厂商声明所有问题已修复，但不提供新的 APK 进行审计。
  * 5/9/16 – 厂商在 Google Play 上发布了补丁（“bugs fixed”）。
  * 5/30/16 – 通知厂商补丁并未正确解决所谓问题（此时只解决了两个问题）。
  * 5/31/16 – 厂商表示我的评论正在接受审核（自动回复）。没有后续回应。
  * 7/6/16 – 向厂商查询状态，没有回应。
  * 11/5/16 – 再一次向厂商查询状态，没有回应。
这时厂商已经不再做出响应，而且只有一些问题被修复。
  * 旧设备（<4.2）上的原创代码执行漏洞 - 并未修复。厂商标记为“不再修复”。
  * 任意文件写入，可以导致任何设备远程代码执行 - 没有修复。
  * 登录页 UXSS - 看起来是修复了（一些域名验证，但是没有对输出进行编码）
  * SQL 注入 - 看起来修复了（使用参数化的 SQL 语句）。
其中一个补丁试图根据域名限制哪些网页可以使用 `installWebApp` 方法。
    @JavascriptInterface public void installWebApp(String arg4) {
        URI v0 = URI.create(arg4);
        if((v0.getHost().endsWith("maxthon.com")) || (v0.getHost().endsWith("maxthon.cn"))) {
            String v0_1 = x.a(arg4);
            p.a(arg4, "/sdcard/webapp/" + v0_1, null);
            y.b("/sdcard/webapp/" + v0_1);
            d.b().a();
            Toast.makeText(this.mContext, "webapp installed", 1).show();
        }
    }
以前的代码有多个问题，我已多次向厂商指出。
1） 从 thisisevilmaxthon.com （以 “maxthon.com”结尾）提供的 JavaScript 仍然可以直接利用任意文件写入漏洞。
2） 该 zip 文件仍然可以通过 HTTP 提供，因此内网攻击者可以强制通过 HTTP 从 maxthon.com 下载一个 zip 文件，然后
MiTM（中间人工具）劫持流量，以间接利用任意文件写入漏洞。
### 结论
  * 远程 SQL 注入对移动应用是一件事，但是鉴于 SQLite 的限制，提取数据方面可能存在一些问题。
  * 移动应用仍在通过 JavaScript 接口暴露有趣的行为，但是我们将不得不花费更多时间逆向目标应用程序以找出安全隐患
  * 通过动态类加载进行混淆使用可能会导致意想不到的安全隐患
* * *