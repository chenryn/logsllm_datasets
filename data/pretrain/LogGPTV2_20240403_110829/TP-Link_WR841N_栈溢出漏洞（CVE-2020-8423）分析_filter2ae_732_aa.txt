# TP-Link WR841N 栈溢出漏洞（CVE-2020-8423）分析
##### 译文声明
本文是翻译文章
译文仅供参考，具体内容表达以及含义原文为准。
> Tower@海特实验室 & H4lo@海特实验室
## 简介
前段时间 TP-LINK TL-WR841N
设备爆出了一个认证后的栈溢出漏洞，借机复现了一下这个栈溢出漏洞，其中有一些在漏洞利用上的小技巧在此和大家分享一下。
漏洞信息如下：
> 漏洞编号：CVE-2020-8423
>
> 漏洞设备：TP-LINK TL-WR841N V10
>
> 漏洞效果：登陆过路由器web服务admin账户之后可以获取到路由器的shell。
>
> 漏洞描述：httpd获取参数时的栈溢出导致了覆盖返回地址shellcode执行
受影响设备以及版本信息：
    cpe：2.3：o：tp-link：tl-wr841n_firmware：3.16.9：*：*：*：*：*：*：*
    cpe：2.3：h：tp-link：tl-wr841n：v10：*：*：*：*：*：*：*
## 环境搭建
  1. 下载固件：
  2. binwalk -Me xxx.bin命令对固件进行解压。
  3. 为了成功运行环境，必须hook 一些关键函数。编译hook函数，hook掉httpd文件里面的阻塞函数。
参考文章中，实际上只需要hook 掉fork和system函数：
    #include 
    #include 
    int system(const char *command){
        printf("HOOK: system(\"%s\")",command);
        return 1337;
    }
    int fork(void){
        return 1337;
    }
编译：
    mips-linux-gnu-gcc -shared -fPIC hook_mips.c -o hook_mips
运行 qemu 环境
启动 qemu 虚拟机之后，在里面运行，便成功启动调试环境。
    mount --bind /proc squashfs-root/proc
    chroot . bin/sh
    LD_PRELOAD="/hook" /usr/bin/httpd
    或者
    export LD_PRELOAD="/hook"
    ./gdbserver 0.0.0.0:2333  /usr/bin/httpd
这里可能会出现一些报错：如没有 libc.so.6 或者 没有ld.so.1，解决方法是需要创建 lib 目录下对应的软连接，ln -s ld-uClibc-0.9.30.so ld.so.1，如图
搭建成功之后访问IP地址即可
如果是远程，没有界面可以使用ssh端口转发
## 漏洞分析
得到文件系统之后，在 /usr/bin/httpd 二进制文件中，找到了这个函数：
    int stringModify(char *dest, int len, int src)
    {
        char src_index;
        char *src_index_a_1;
        int index;
        if ((dest == (char *)0x0) || (src_index_a_1 = (char *)(src + 1), src == 0))
        {
                      index = -1;
        }
        else {
             index = 0;
            while (true) {
                 src_index = src_index_a_1[-1];
                if ((src_index == '\0') || (len ') || (src_index == '\\'))
    goto LAB_0043bb48;
                        if (src_index == '，>,\
                          dest[1] = 'b';
                          dest[2] = 'r';
                          dest[3] = '>';
                          dest = dest + 4;
                    }
                }   //else结束
                  index = index + 1;//index表示已经拷贝的长度（包含转义字符\）
                  src_index_a_1 = src_index_a_1 + 1;
            }
            *dest = '\0';
        }
        return index;
    }
    int stringModify(char *dst,size_t size,char *src)
通过分析这个函数，我们可以知道这个函数是用来转义/过滤一些特殊字符，函数处理的整个过程为：
1 . 对\，/，，”这些符号进行转义  
2 . 把单独的\r或者\n（单独是指后面没有跟\r或者\n）  
3 . 差不多相当于字符串拷贝，只是拷贝的同时对一些字符进行了处理  
4 . 原本一个字节的\n会被转义成四个字节的\  
很容易dst设置大小不够造成溢出
通过函数交叉引用进行回溯，可以找到 writePageParamSet 函数，这是它的一个调用者，设置dst缓冲区太小造成溢出。
继续往前回溯，找到 0x0457574地址处的函数，这个函数获取get请求的一些参数，调用了漏洞函数：
    int UndefinedFunction_00457574(int param_1,undefined4 param_2,int *param_3,undefined4 param_4)
    {
        __s_00 = (char *)httpGetEnv(param_1,"ssid");
        if (__s_00 == (char *)0x0) {
          uStack3080 = 0;
        }
        else {
          __n = strlen(__s_00);
          strncpy((char *)&uStack3080,__s_00,__n);
        }
        __s_00 = (char *)httpGetEnv(param_1,"curRegion");
        if (__s_00 == (char *)0x0) {
          piStack3044 = (int *)0x11;
        }
        else {
          __s = (int *)atoi(__s_00);
          if (__s < (int *)0x6c) {
            piStack3044 = __s;
          }
        }
        __s_00 = (char *)httpGetEnv(param_1,"channel");
        if (__s_00 == (char *)0x0) {
          piStack3040 = (int *)0x6;
        }
        else {
          __s = (int *)atoi(__s_00);
          if ((int)__s - 1U < 0xf) {
            piStack3040 = __s;
          }
        }
        __s_00 = (char *)httpGetEnv(param_1,"chanWidth");
        if (__s_00 == (char *)0x0) {
          piStack3036 = (int *)0x2;
        }
        else {
          __s = (int *)atoi(__s_00);
          if ((int)__s - 1U < 3) {
            piStack3036 = __s;
          }
        }
        __s_00 = (char *)httpGetEnv(param_1,"mode");
        if (__s_00 == (char *)0x0) {
          piStack3032 = (int *)0x1;
        }
        else {
          __s = (int *)atoi(__s_00);
          if ((int)__s - 1U < 7) {
            piStack3032 = __s;
          }
        }
        __s_00 = (char *)httpGetEnv(param_1,"wrr");
        if (__s_00 != (char *)0x0) {
          iVar1 = strcmp(__s_00,"true");
          if ((iVar1 == 0) || (iVar1 = atoi(__s_00), iVar1 == 1)) {
            piStack3028 = (int *)0x1;
          }
          else {
            piStack3028 = (int *)0x0;
          }
        }
        __s_00 = (char *)httpGetEnv(param_1,"sb");
        if (__s_00 != (char *)0x0) {
          iVar1 = strcmp(__s_00,"true");
          if ((iVar1 == 0) || (iVar1 = atoi(__s_00), iVar1 == 1)) {
            piStack3024 = (int *)0x1;
          }
          else {
            piStack3024 = (int *)0x0;
          }
        }
        __s_00 = (char *)httpGetEnv(param_1,"select");
        if (__s_00 != (char *)0x0) {
          iVar1 = strcmp(__s_00,"true");
          if ((iVar1 == 0) || (iVar1 = atoi(__s_00), iVar1 == 1)) {
            piStack3020 = (int *)0x1;