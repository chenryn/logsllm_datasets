深入理解 Windows 字体解析引擎漏洞 
wang yu 
SyScan(+)360, 2012 
议题简介 
第一部分 
议题简介 
·关于作者  ( PI:EMAIL ) 
·议题背景 
        2011 年 12 月微软月度安全更新修复了此
前曾被Duqu 恶意软件利用的 Win32K 内核漏洞。 
        同月，在中国更受关注的一个话题是网站后
台数据库的安全性问题。 
        本议题将聚焦于 Win32K 字体解析引擎的设
计与实现，以白盒的视角审视 Duqu 0-day 的利用细
节。 
议题简介 
·议题涵盖 
-  字体解析引擎客户端接口 ( Font Scaler Client 
Interface ) 的背景、设计与实现 
-  演示如何在系统用户态实现字体引擎 ( Font 
Scaler ) 的客户端 —— 引擎的反内核化示例 
-  作为系统内核态字体引擎的客户端，Win32K 模块是
如何与之交互的 —— Win32K 的调用假设 
-  Duqu 与 MS11-087 远程可执行漏洞 
-  字体引擎的更多审计 
·责任声明 
从点阵字体到轮廓字体 
第二部分 
启动扇区里的小游戏 
演示：640*480*16 色图形模式写方式二 —— 写点 
从点阵字体到轮廓字体 
An Improved Representation for Stroke-based Fonts 
点阵位图 —— 优点与缺点  
从点阵字体到轮廓字体 
轮廓字体 —— 优点与缺点  
从点阵字体到轮廓字体 
·我们站在巨人的肩膀之上 
数字字体的混沌时期 
从复印机到 PostScript 页面描述语言，从 Xerox 到 
Adobe 
苹果公司的加入 — LaserWriter，1985 年 
从操作系统的角度考虑，苹果公司从上世纪八十年代末开始
研发自己的可缩放字体技术 — Royal，这即 TrueType 的
前身 
·两种流派，两种理念 
      -  PostScript Type 1 : cubics; "smarter" fonts, 
"dumber" interpreter 
      -  TrueType : quadratics; "dumber" 
字体解析引擎客户端接口 
第三部分 
引擎起源 
·PostScript Type 1 vs. Royal ( TrueType ) 
PostScript 早于后者六年 
·Royal ( TrueType ) vs. TrueImage 
"Apple traded the technology to Microsoft in 
exchange for the latter 's PostScript clone 
technology 'TrueImage' ... which was buggy at the 
time, and never used by Apple"...   —  Thomas W. 
Phinney 
·内核化后，TrueType 字体引擎 ( Font Scaler )  
     实现于 Win32K 模块的内部；而 Win32K 模块 
      也可被视为字体引擎的调用者或引擎客户端 
·引擎的导出接口即 Font Scaler Client Interface 
目标研究手段 
·Duqu 0-day 让我充满好奇 
"Initially, it even caused confusion among 
researchers who believed Duqu was exploiting a 
vulnerability in the MS Word format 
itself"...                                          
        —  Ivan Teblin 
·静态逆向 
·动态跟踪 
·当然，理论上我还可以... 白盒分析！ 
还具备参考价值吗？ 
白盒评估 —从宏观角度（引擎架构）从微观角度（代码笔误） 
sfac_LoadCriticalSfntMetrics – 6.2.9200.16384                                             sfntaccs.c line:953 
sfac_DoOffsetTableMap                                                            sfntaccs.c line:252 
还可以工作吗？ 
I'm Feeling Lucky! 
工欲善其事 必先利其器 
 字体格式分析工具 
 TTFDump (FontTools) 
http://www.microsoft.com/typography/tools/tools.aspx 
工欲善其事 必先利其器 
呃... TTFDump 唯一的问题就是问题太多  
工欲善其事 必先利其器 
 字体调试工具 
 TrueTypeViewer 
http://home.kabelfoon.nl/~slam/fonts/truetypeviewer.html 
工欲善其事 必先利其器 
囧... 好的 
引擎的重要接口 
Font Scaler Client 
Interface 
表 Font Scaler Client Interface 
引擎的重要接口 
续表 Font Scaler Client Interface 
表 Routine Prefix 
例程前缀功能描述 
引擎的核心数据结构 
 引擎输入、输出核心结构 
        fs_GlyphInputType 
CJ_IN 
        fs_GlyphInfoType 
CJ_OUT 
        fs_SplineKey 
CJ_0 
        fsg_WorkSpaceOffsets 
CJ_3 
         fsg_PrivateSpaceOffsets CJ_4 
图形状态核心结构 
        fnt_LocalGraphicStateType 
        fnt_ElementType 
        fnt_GlobalGraphicStateType 
因为白盒，所以不在话下 
引擎的基本执行流 
fs_OpenFonts           CJ_IN 
fs_Initialize             CJ_0 
fs_NewSfnt 
fs_NewTransformation    CJ_3 CJ_4 
fs_NewGlyph      characterCode 
fs_ContourGridFit 
fs_FindBitMapSize 
fs_ContourScan 
fs_CloseFonts 
fs_ContourNoGridFit 
Client (Fuzz / Win32K)            [interface]                Font Scaler 
Phase 1 
Phase 2 
Phase 3 
Phase 4 
Phase 5 
Phase 6 
Phase 7 
Phase 8 
Phase 9 
INITIALIZED 
INITIALIZED | NEWSFNT 
INITIALIZED | NEWSFNT | NEWTRANS 
INITIALIZED | NEWSFNT | NEWTRANS | GOTINDEX 
INITIALIZED | NEWSFNT | NEWTRANS | GOTINDEX | GOTGLYPH 
INITIALIZED | NEWSFNT | NEWTRANS | GOTINDEX | GOTGLYPH | SIZEKNOWN 
CJ_0  SIZE 
CJ_3  CJ_4  SIZE 
 glyphIndex 
BITMAP_PTR_1  2  3  SIZE 
sbit_GetBitmap  / fsc_FillGlyph 
Duqu 0-day  pBitmapPtr2 
WangYu, All Rights Reserved. 
启动引擎！ 
演示：字体引擎的反内核化示例 
指令修正过程 
引擎的设计准则与背景推测 
·引擎最初的工作模式 
·引擎对于内存的使用策略 
·“高内聚/低耦合”或是“低内聚/高耦合”？ 
·毫无疑问，这是一个时代的产物 
Win32K 的假设与 MS11-087 
第四部分 
现有议题资料 
·CVE-2011-3402 分析, venustech 
·GDI Font Fuzzing in Windows Kernel for Fun, bh12, 
PacSec12 
·Anatomy of Duqu exploit, vb100 
·The Cousins of Stuxnet: Duqu, Flame, and Gauss, CrySyS 
Lab 
·共识： 
    某处发生了越界导致某个值被改写了 
    精心构造的字体指令触发了恶意代码 
·疑问： 
    太多的细节值得深入挖掘 
CJ_3 和 CJ_4 
typedef struct fsg_WorkSpaceOffsets        aka.     CJ_3                      WORKSPACE MEMORY LAYOUT 
{ 
TrueType Glyph Element [MaxComponentDepth + 1] 
sizeof(fnt_ElementType) * (MAX_COMPONENT_DEPTH(pMaxProfile) + 1)  
[ WorkSpaceOffsets->ulGlyphElementOffset ] 
[ WorkSpaceOffsets->ulGlyphOutlineOffset ] 
[ WorkSpaceOffsets->ulGlyphDataByteSetOffset ] 
MAX_NESTED_GLYPHS(MaxProfile) * sizeof(boolean) 
TrueType Glyph Data Allocation ByteSet 
GlyphData    +0x000 acIdent 
                        +0x004 pSibling 
                        +0x008 pChild 
                        +0x00c pParent 
                        +0x010 hGlyph 
                        +0x018 GlyphType 
                        +0x01c usGlyphIndex 
                          ……… 
                       +0x080 pGlyphElement 
TrueType GlyphData [ulGlyphDataCount] 
[ WorkSpaceOffsets->ulGlyphDataOffset ] 
MAX_NESTED_GLYPHS(MaxProfile) * sizeof(GlyphData) 
TrueType Stack 
[ WorkSpaceOffsets->ulStackOffset ] 
MaxProfile->maxStackElements * sizeof(F26Dot6) 
fsg_OutlineFieldInfo    +0x000 x 
                                         +0x004 y 
                                         +0x008 ox 
                                         +0x00c oy 
                                         +0x018 onCurve 
                                         +0x01c sp 
} 
[ END ] 
fnt_ElementType    +0x000 x 
                                    +0x004 y 
                                    +0x008 ox 
                                    +0x00c oy 
                                    +0x018 onCurve 
                                    +0x028 nc 
TrueType Glyph Outline 
……… 
       WorkSpaceOffsets->ulReusableMemoryOffset  
                          ( WorkSpaceOffsets->ulReusableMemoryOffset += WorkSpaceOffsets->ulGlyphOutlineOffset ) 
plExtraWorkSpace 
WangYu, All Rights Reserved. 
CJ_3 和 CJ_4 
typedef struct fsg_PrivateSpaceOffsets     aka.     CJ_4                      PRIVATE SPACE MEMORY LAYOUT 
{ 
TrueType Storage 
sizeof(F26Dot6) * MaxProfile->maxStorage 
[ PrivateSpaceOffsets->offset_storage ] 
[ PrivateSpaceOffsets->offset_functions ] 
[ PrivateSpaceOffsets->offset_instrDefs ] 
sizeof(fnt_funcDef) * MaxProfile->maxFunctionDefs 
TrueType Function Defs 
fnt_funcDef    +0x000 start 
                          +0x004 length 
                          +0x006 pgmIndex 
fnt_instrDef    +0x000 start 
                          +0x004 length 
                          +0x006 pgmIndex 
                          +0x007 opCode 
TrueType Instruction Defs 
sizeof(fnt_instrDef) * MaxProfile->maxInstructionDefs 
[ PrivateSpaceOffsets->offset_controlValues ] 
sizeof(F26Dot6) * (SFAC_LENGTH(ClientInfo, sfnt_controlValue) / sizeof(sfnt_ControlValue)) 
TrueType Scaled CVT 
[ PrivateSpaceOffsets->offset_globalGS ] 
TrueType Global GS 
fnt_GlobalGraphicStateType 
sizeof(fnt_GlobalGraphicStateType) 
+12C cvtCount 
[ PrivateSpaceOffsets->offset_FontProgram ] 
[ PrivateSpaceOffsets->offset_PreProgram ] 
[ PrivateSpaceOffsets->offset_TwilightZone ] 
TrueType Font Program 
SFAC_LENGTH(ClientInfo, sfnt_fontProgram) 
SFAC_LENGTH(ClientInfo, sfnt_preProgram) 
TrueType Pre Program 
fnt_ElementType    +0x000 x 
                                    +0x004 y 
                                    +0x008 ox 
                                    +0x00c oy 
                                    +0x018 onCurve 
                                    +0x028 nc 
TrueType Twilight Element 
sizeof(fnt_ElementType) 
[ PrivateSpaceOffsets->offset_TwilightOutline ] 
fsg_OutlineFieldInfo    +0x000 x 
                                           +0x004 y 
                                           +0x008 ox 
                                           +0x00c oy 
                                           +0x018 onCurve 
                                           +0x01c sp 
} 
sizeof(fsg_OutlineFieldInfo) 
[ END ] 
TrueType Twilight Outline 
fsg_GetOutlineSizeAndOffsets(pMaxProfile->maxTwilightPoints, 
                                                          MAX_TWILIGHT_CONTOURS, 
                                                          &(PrivateSpaceOffsets->TwilightOutlineFieldOffsets), 
                                                          &ulOutlineSize, 
                                                          &ulReusableMarker);  
WangYu, All Rights Reserved. 
Win32K 模块的调用假设 
·堆越界问题？数组越界问题！ 
·1）ulReusableMemoryOffset  与 
          pBitmapPtr2 / pbyRead 机制 
·2）Win32K  PJ034 的假定 
·3）GetSbitComponent  usXOffset 
/usYOffset 
·4）sfac_GetSbitBitmap 缺乏越界检测 
·这是一个潜藏了二十多年的 Bug 
CJ_IN  
CJ_0  
CJ_4  
CJ_OUT  
CJ_3  
bInitInAndOut 
PJ034 
fnt_GlobalGraphicStateType 
+12C cvtCount 
OverWrite ! 
WorkSpaceOffsets + ulMemoryBase6Offset 
GetSbitComponent  
fs_GlyphInputType 
fs_GlyphInfoType 
fs_SplineKey 
WangYu, All Rights Reserved. 
叹为观止的利用技术 
CJ_IN  
CJ_0  
CJ_4  
CJ_OUT  
CJ_3  
bInitInAndOut 
PJ034 
fnt_GlobalGraphicStateType 
+12C cvtCount 
fs_GlyphInputType 
fs_GlyphInfoType 
fs_SplineKey 
[ CJ_4->offset_controlValues ] 
[ CJ_4->offset_FontProgram ] 
…………. 
[ CJ_4->offset_globalGS ] 
CJ_4  
fnt_GlobalGraphicStateType 
           +0x000 stackBase 
           +0x004 store 
           ………… 
           +0x0ac ScaleFuncCVT 
           ………… 
controlValueTable 
Kernel Shellcode 
In 
'fpgm' Table 
…………. 
Storage Area 
Shellcode Base 
Phase 1  itrp_GetCVTEntryFast 
Array Bounds Violation Read 
Phase 2  itrp_WCVT() 
OverWrite! 
Phase 3  itrp_LSW() 
Launch the Shellcode! 
pb->scaledSW = globalGS->ScaleFuncCVT (&globalGS->scaleCVT, (F26Dot6)pb->sW); 
LocalGS.globalGS->controlValueTable[ cvtIndex ] = cvtValue; 
WangYu, All Rights Reserved. 
Phase 0  Kernel Shellcode 
sfac_CopyFontAndPrePrograms() 
叹为观止的利用技术 
演示：Duqu 与 MS11-087 
字体引擎的更多审计 
第五部分 
MS11-087 的一个隐含问题 
     GetSbitComponent 例程的无限
递归 
演示：Duqu 揭示的另一个潜在问题 
MS11-087 的一个隐含问题 
 GetSbitComponent 补丁细节 —— 引入递归深度参数 a14 
只此一处？ 
     EvaluateSpline 例程的递归条件？ 
     请别忘记引擎现在工作于内核 
更多的审计 
     那么，又一个潜藏了二十多年的 Bug 喽？ 
演示 
引擎的内核化究竟意味着什么？ 
WoW！TOCTTOU！ 
PS : Rootkit, Object Hook 
尾声 
第六部分 
沉思 
·误解 
        "One popular internet assumption about the Duqu exploit was 
its 
        dependency on a new vulnerability in Microsoft Word's parsing 
of 
        the OLE2 document format and allowing activation of the CVE- 
        2011-3402 exploit in the kernel. In turn, the newer .docx 
format 
        was considered to be more secure"... 
                                                    — Anatomy of Duqu 
exploit, vb100 
沉思 
·罗生门 
        "Moving ... the GDI from user mode to kernel mode has 
provided 
        improved performance without any significant decrease in 
system 
        stability or reliability"... 
                                                         — Windows 
Internals, 4th Edition 
        "GDI represents a significant kernel attack surface, and is 
perhaps  
        the most easily accessible remotely. 
                This resulted in perhaps our most critical 
discovery, remote 
        ring0 code execution when a user visits a hostile website 
        ( even for unprivileged or protected mode users )."... 
                         — There's a Party at Ring0 and You're 
Invited, bh2010 
沉思 
·SMEP ?  Kernel Mode Shellcode 
这是一个时代的产物，也许它应该进博物馆了。 
致谢！ 
P1P1Winner    PJF    Bugvuln    RoyceLu 
YaoTong    PaulFan    MJ0011 
360-deepscan-team    360-hips-team 
SyScan Committee    Fan.Tuan 
Q&A 
PI:EMAIL