No user interaction: Our crawlers do not interact with the page.
This means that we are only able to (cid:27)nd gadgets in code that get
executed at page load by default.
No authentication: Our crawlers do not authenticate to the
pages under test. Consequently, we might have missed results in
authenticated parts of an application, signi(cid:27)cantly reducing the
potential coverage of crawled web applications.
Veri(cid:27)cation does not focus on mitigation bypasses: In the
study, we do not arti(cid:27)cially add, modify or remove any speci(cid:27)c
XSS mitigation to crawled websites. We only verify that a data (cid:30)ow
from a non-executing source is capable of executing arbitrary code
in a page via a gadget, even in the presence of a given mitigation.
The reason for this is that some mitigations cannot be easily applied
to Web sites. For example, applying a Web Application Firewall or
Content Security Policy (see 2.3) to a page requires a non-trivial
amount of con(cid:27)guration, and is likely to break the functionality
when done automatically. Furthermore, exploits need to be adopted
to the speci(cid:27)c mitigation techniques. Hence, by focusing on the
mere code execution aspect, we can verify gadgets more e(cid:28)ciently.
Our XSS simulation approach is false-negative-prone: In
a real-world mitigation setting, the initial XSS attack should be
blocked by stopping the execution of the injected code. However,
even when the original injection was stopped, a gadget can still po-
tentially execute the injected content, e(cid:29)ectively bypassing the mit-
igation. For example, while script elements are initially blocked
by CSP, they remain in the DOM and gadgets may reintroduce
them, triggering them again. While this would be a valid mitigation-
speci(cid:27)c bypass, this payload would execute directly without trig-
gering any gadget when a CSP is not present. In order to avoid
such false-positive (cid:27)ndings, we only generate exploits that do not
trigger JavaScript execution by default. For example, we did not
inject gadgets in the following form:
Listing 21: Invalid Exploit
Instead, we transform the payload into a form that cannot exe-
cute by default, by using the xmp plaintext tag, for example:
Listing 22: Non-executing Exploit
While this approach completely removes false positives from
our results, it might cause a considerable number of false negatives.
For example, often the name of a tag is part of the DOM selector
trigerring the gadget. Hence, by changing the tag name (in the
example: from div to xmp), the exploit might not be able to trigger
the gadget correctly. E(cid:29)ectively we lowered our veri(cid:27)cation rate
and in turn signi(cid:27)cantly increased the quality of our results.
Limitation Summary. All these limitations should be taken into
account when reading the following sections. Most importantly,
we want to point out that the presented results are lower bounds.
If deep crawling, user interaction and a less restrictive veri(cid:27)cation
are applied, the resulting numbers will likely be higher.
5.4 Results
This section is divided into several subsections. After reporting
on general crawling results, we present numbers and statistics
about the detected data (cid:30)ows. Then we report on the results of our
automatic gadget veri(cid:27)cation, and (cid:27)nally we discuss the results in
the context of XSS mitigation techniques.
5.4.1 Crawling Results. As mentioned above, our initial data set
consisted of the Alexa top 5000 Web sites. By following the (cid:27)rst-
level links, we crawled 647,085 Web pages on the same domains or
subdomains of this set, which (cid:27)nally contained 37,232 di(cid:29)erent sub
domains and 4,557 second-level-domains. The number of second-
level domains is lower than 5000, because some entries in the Alexa
Top Sites (cid:27)le redirect to the same domain based on geo location. For
example, google.it, google.de, google.fr all redirect to google.com.
Furthermore, some Web sites were not reachable or timed out while
crawling. In some cases, this is due to sites that only use regional
CDNs. For example, a site from Asia might be fast in Asia but very
slow when requested from the US or Europe. For all the remaining
pages, we collected data (cid:30)ows using our taint engine.
5.4.2 Taint Results. On average we measured 7.67 sink calls per
crawled URL and around 450 sink calls aggregated per second-level
domain. In total, we counted 4,352,491 sink calls with data result-
ing from 4,889,568 unique sources within the DOM. Grouped by
second-level domain, sink and source, we measured 22,379 unique
combinations.
5.4.3 Mitigation results. In the following, we want to relate
these results to the XSS mitigations, especially CSP ’unsafe-eval’,
CSP ’strict-dynamic’ and HTML sanitizers.
Session H2:  Code Reuse AttacksCCS’17, October 30-November 3, 2017, Dallas, TX, USA1719Content Security Policy - ’unsafe-eval’: As opposed to the ’unsafe-
inline’ keyword, unsafe-eval in the past seemed to be more secure
in general. While unsafe-inline almost completely removes the
protection capabilities of a CSP policy, unsafe-eval by default
does not make the policy bypass-able. In order to bypass the policy
with unsafe-eval an attacker needs to (cid:27)nd an injection into a
JavaScript execution function (eval, new Function, setTimeout,
setInterval, etc.). Finding a direct injection is often hard and time
consuming, because the use of such function is limited and can be
easily audited by the application owner. Hence ’unsafe-eval’ was
seen as an acceptable trade-o(cid:29) between security and usability of
CSP. However, the results of our study imply that this long-held
belief should be changed. Gadgets can be used as an indirect way
of reaching an execution sink. If DOM content gets evaluated by
default, the attacker can inject the code as a DOM node in order
to abuse the eval-gadget to execute arbitrary code. In our data
set 47.76% of all second-level domains contained a data (cid:30)ow that
ended within a JavaScript execution function. During our crawl, for
example, we unintentionally automatically bypassed Tumblr’s CSP
policy with a gadget bypassing its unsafe-eval source expression.
Content Security Policy - ’strict-dynamic’: The strict-dynamic
source expression was added to CSP to increase the usability of
nonce-based policies. As described in 4.1.1, strict-dynamic en-
ables automatic trust propagation to child scripts. If a nonced, and
thus legitimate, script appends a child script element to the DOM,
the child script would be blocked unless the parent script propa-
gates the nonce to the script as well. As many libraries are not aware
of CSP, these libraries do not propagate the nonce and thus CSP
would block the child script and break the library’s functionality.
When strict-dynamic is enabled trust is automatically propa-
gated to non-parser-inserted script elements. Consequently, under
strict-dynamic, child script elements are automatically executed
even if they do not carry a nonce. In this situation, attackers may
use gadgets to bypass CSP. If DOM content gets injected into a
script element, or into a library function (e.g. jQuery.html) that
creates and appends new script elements, strict-dynamic CSP
can be bypassed. In order to measure potentially a(cid:29)ected Web sites,
we counted the following data (cid:30)ows:
innerHTML of a script tag
• The data (cid:30)ows ending within text, textContent or
• The data (cid:30)ow ending within text, textContent or
innerHTML of a tag, where the tag name is DOM-controlled
(tainted)
• The data (cid:30)ow ending within script.src
• The data (cid:30)ow ending in a API which is known for creating
and appending script tags to the DOM.
In total, 73.03% of all second-level domains contained at least
one data (cid:30)ow with the described characteristics. For example, we
detected a gadget capable of bypassing strict-dynamic in Face-
book’s fbevents.js library19.
Content Security Policy - Summary. Given the numbers and
examples provided above, we believe that unsafe-eval and
strict-dynamic considerably weaken a CSP policy. Great care
should be taken when using these source expressions.
19https://developers.facebook.com/docs/ads-for-websites/pixel-events/v2.9
HTML Sanitizers: Sanitizers aim at removing potentially mali-
cious content. Most sanitizers do this by de(cid:27)ning a known-good
list of tags and attributes and removing anything else from a pro-
vided string. This list varies from sanitizer to sanitizer. The Closure
sanitizer for example, removes data- attributes, while DOMPurify
allows them in its default con(cid:27)guration. Furthermore, all sanitizers
we looked at allow id and class attributes. Hence, we investigated
whether this behavior is secure. In our data set 78.30% of all second-
level domains had at least one data (cid:30)ow from an HTML attribute
into a security-sensitive sink, whereas 59.51% of the sites exhibited
such (cid:30)ows from data- attributes. Furthermore, 15.67% executed
data from id attributes and 10% from class attributes. Based on
these numbers, we recommend to revisit at least the sanitization
approach towards blocking data- attributes.
5.4.4 Gadget Results. Based on the identi(cid:27)ed data (cid:30)ows, we gen-
erated 1,762,823 gadget-based exploit candidates, based on which
we validated 285,894 gadgets on 906 (19.88%) of all second-level
domains.
6 SUMMARY & DISCUSSION
Our study has demonstrated that data (cid:30)ows from the DOM into
security-sensitive functions are very frequent in modern applica-
tions and frameworks. In fact, 81.85% of all second-level domains
exhibited at least one relevant data (cid:30)ow. Furthermore, we have
shown that we can detect these (cid:30)ows and generate exploits that
are capable of bypassing all modern XSS mitigations. In a fully
automated fashion, we detected and veri(cid:27)ed gadgets on 19.88%
of all second-level domains. However, due to our methodology,
we believe that this is just a lower bound for the real extent of
this problem. By applying deeper crawling, authentication, user
interaction and less conservative testing approach the numbers
would doubtlessly increase considerably. We speci(cid:27)cally removed
or changed all exploits that would result in an immediate execution
at the initial injection.
Given these results, we believe that XSS mitigations in their
current form are not well aligned with modern applications, frame-
works and vulnerabilities. In general, we see three di(cid:29)erent ways
to address the issue of script gadgets:
6.1 Fix the Mitigation Techniques
Making mitigation techniques gadget-aware in general is hard. To-
day there are so many expression languages, frameworks, libraries
and instances of user-land code that it will be very di(cid:28)cult to ad-
dress all of the di(cid:29)erent types of gadgets. For example, request
(cid:27)ltering mitigations (4.2) will have a hard time in detecting all the
various forms that script gadgets can take, especially when the gad-
get chain makes use of string transformation functions. However,
we believe that a few of the vectors can be addressed by speci(cid:27)c mit-
igations. HTML sanitizers, for example, could start to (cid:27)lter data-,
id or class attributes.
6.2 Fix the Applications
Another approach to address the identi(cid:27)ed problems is to try to
(cid:27)x the applications. Popular libraries and frameworks, for example,
could aim at removing gadgets in order to safeguard their users.
Session H2:  Code Reuse AttacksCCS’17, October 30-November 3, 2017, Dallas, TX, USA1720Given the extent of the problem however, we will likely not be able
to address this problem at scale.
As some gadgets and gadget chains are part of the feature set of
a framework, it is unlikely that developers of such frameworks are
willing to remove or restrict these features for preventing XSS miti-
gation bypasses. Furthermore, we found a number of unintentional
gadgets; code paths that were triggered through gadgets that were
not intended by their developers. These unintended code paths are
hard to (cid:27)nd, sometimes even harder than a simple XSS vulnerabil-
ity. As a result, we believe that (cid:27)xing XSS mitigations and script
gadgets might be as hard and time consuming as (cid:27)xing the XSS
problem itself.
6.3 Shift from Mitigation to Isolation and
Prevention techniques
Due to the results of our study, we believe that the focus of Web
Security engineers should shift from mitigation techniques towards
isolation and prevention techniques. Sandboxed Iframes [13], Su-
borigins [36] or Isolated Scripts [22] are promising proposals for
Isolation techniques. Furthermore, the Web needs to focus on XSS
prevention techniques: The Web platform is inherently insecure.
A novice programmer without much security knowledge is hardly
able to create a secure Web application. The Web platform should
let a developer easily create a secure app by providing secure-by-
default APIs. Language-based security concepts, for example, could
be added to the Web platform, so that it is impossible to introduce
security vulnerabilities without malicious intent.
7 RELATED WORK
Client-side XSS:. While the source of the initial content injec-
tion can be caused by all classes of XSS, gadget-based attacks are
rooted in insecure client-side data (cid:30)ows caused by JavaScript. Thus,
the closest related class of vulnerabilities is client-side XSS, also
known as DOM-based XSS. The (cid:27)rst public documentation of this
vulnerability class was done by Amit Klein in 2005 [16]. In 2013
Lekies et al. [17] conducted a large scale study that demonstrated
the prevalence of this XSS type, showing that approximately 10%
of the examined web sites exposed at least one client-side XSS
problem. To address this problem, Stock et al. [32] proposed a taint
tracking-based protection mechanism to stop insecure data-(cid:30)ows
within the web browser. While taint tracking could potentially de-
tect or stop gadget-based attacks, this paper only covers client-side
data (cid:30)ows. Most of our exploits, however, have hybrid data (cid:30)ows
that span across the client and the server. Hence, in its current ver-
sion Stock et al.’s approach cannot stop our attacks. More recently,
Parameshwaran et al. [26] advanced this defense via server-side
instrumentation of the JavaScript code, thus eliminating the need
of browser modi(cid:27)cations. It is unclear to which degree these taint-
based techniques can be adapted to address script gadget attacks,
as the initial payload does not come from a untrusted source, and
thus, are not easily distinguishable from the legitimate targets of
the gadget code.
The potential security problems of insecure JavaScript trans-
forming DOM content was initially documented by Heiderich et al.
in two distinct variations. In the (cid:27)rst, they showed how JavaScript
frameworks like AngularJS create insecure injection vulnerabili-
ties which are out-of-scope for classic server-side XSS sanitization
techniques, due to custom client-side markup conventions [10].
Furthermore, they uncovered how speci(cid:27)c, non-standard browser
behavior potentially transformed initially secure DOM content into
executable code, if read and rewritten via JavaScript [12]. Athana-
sopoulos et al. [2] described return-to-JavaScript, a similar attack
scenario circumventing mitigations based on script whitelists. In
their attack, the attacker executes already whitelisted scripts in an
unwanted fashion. The basic assumption of their attack is that an
XSS exists in the application and the attacker is only able to execute
already whitelisted scripts. Under these assumptions the attacker
could try to repurpose whitelisted scripts. For example, if there is
a button with a whitelisted event handler that logs out the user,
the attacker could reuse the whitelisted event handler and attach
it to an onload event via the XSS vulnerability. In this way users
would be logged out immediately once they visit the application.
While the mitigation prevents general exploitation, the attacker
could still harm the user experience considerably by abusing the
existing scripts.
Circumventing XSS mitigations: The topic of undermining the
protective capabilities of XSS mitigations has been explored pre-
viously as well. Zalewski [37] outlined potential future direction
of mitigation combating in his in(cid:30)uential essay "Postcards from
the post-XSS world", touching many emerging techniques, such as
content in(cid:27)ltration, whitelist abuse, or potential possibilities for
Web code reuse attacks.
On the topic of browser-based XSS mitigations, Nava and Lind-
say [23] and Bates et al. [3] exposed inherent weaknesses in XSS
mitigation approaches that rely on regular expression based de-
tection mechanism. These results directly motivated the design
of the XSSAuditor [3]. In turn, Stock et al. [32] demonstrated the
weakness of all string-based XSS (cid:27)lters in non-trivial vulnerability
scenarios, such as partial or double injections.
In addition to research on client-side XSS (cid:27)lters, Content Secu-
rity Policy was subject of several research endeavors. For one, in
concurrent work Weichselbaum et al [35] and Calzavara et al. [4]
examined the quality and e(cid:29)ectiveness of currently deployed CSP
policies with sobering results. In addition, Weichselbaum et al. [35]
demonstrated how whitelist-based policies can be easily evaded
using overly permissive whitelisted script providers. In comple-
mentary work, Chen et al. [6] and Van Acker et al.[1] presented
various techniques to evade CSP’s information (cid:30)ow restrictions.
Furthermore, Pan et al [25] investigated how to automatically gen-
erate secure CSP policies (without the unsafe-inline or unsafe-eval
keywords). While these policies could resist simple gadgets, such
strong policies are still vulnerable to expression-based gadgets as
outlined in section 4.4. Finally, Heiderich et al. [11] demonstrated
how injected HTML and CSS code alone is su(cid:28)cient to conduct a
wide range of attacks, even when a comprehensive CSP for script
execution prevention is in place.
Session H2:  Code Reuse AttacksCCS’17, October 30-November 3, 2017, Dallas, TX, USA17218 CONCLUSION
In this paper, we comprehensively explored code-reuse attacks
in Web pages using script gadgets. Script gadgets come in many
variations and, as our empirical study uncovered, are omnipresent
in modern Web code.
As we have demonstrated, the current generation of XSS mitiga-
tions is unable to handle XSS attacks that leverage script gadgets
to execute their payloads. And, unfortunately, there is no linear
upgrade path to adapt the current mitigation approaches to robustly
handle the uncovered vulnerability pattern. While speci(cid:27)c mitiga-
tion techniques can be modi(cid:27)ed to handle selected gadget types,
the high variance of script gadget form and functionality, due to
the vastly growing amount of custom client-side code and the con-
stant (cid:30)ow of new client-side frameworks, prevents a comprehensive
adaption to accommodate the problem.
This leads to a conundrum for the future of client-side Web se-
curity: The last 15 years of di(cid:28)culty in addressing XSS have shown
that XSS apparently cannot be thoroughly addressed in practice
through secure coding practices alone. And the subject of this paper,
especially in combination with complementary results [9, 32], sug-
gest that the current approaches in XSS mitigation are insu(cid:28)cient
to compensate the de(cid:27)cits of code-based XSS prevention.
The question then arises: how do we handle XSS on the road
ahead? As discussed above, sophisticated isolation techniques could
o(cid:29)er a third way of dealing with the potential consequences of
attacker controlled JavaScript. Alternatively, safe code abstrac-
tions [15] and secure-by-default browser APIs [20] might also be an
option to overcome today’s inherent problems of ad-hoc, insecure
Web content generation.
However, regardless of which paradigm the next generation of
XSS countermeasures will be build upon, it is essential that they
have to be capable to handle the unexpected client-side execution-
and data-(cid:30)ows which may be caused by legitimate script gadgets.
REFERENCES
[1] Acker, S. V., Hausknecht, D., and Sabelfeld, A. Data Ex(cid:27)ltration in the Face
of CSP. In AsiaCCS (2016).
[2] Athanasopoulos, E., Pappas, V., Krithinakis, A., Ligouras, S., Markatos,
E. P., and Karagiannis, T. xjs: practical xss prevention for web application
development. In Proceedings of the 2010 USENIX conference on Web application
development (2010), USENIX Association, pp. 13–13.
[3] Bates, D., Barth, A., and Jackson, C. Regular expressions considered harmful
in client-side XSS (cid:27)lters.
In WWW ’10: Proceedings of the 19th international
conference on World wide web (New York, NY, USA, 2010), ACM, pp. 91–100.
[4] Calzavara, S., Rabitti, A., and Bugliesi, M. Content security problems?:
Evaluating the e(cid:29)ectiveness of content security policy in the wild. In Proceedings
of the 2016 ACM SIGSAC Conference on Computer and Communications Security
(New York, NY, USA, 2016), CCS ’16, ACM, pp. 1365–1375.
[5] CERT/CC. CERT Advisory CA-2000-02 Malicious HTML Tags Embedded in
Client Web Requests. [online], http://www.cert.org/advisories/CA-2000-02.html
(01/30/06), February 2000.
[6] Chen, E. Y., Gorbaty, S., Singhal, A., and Jackson, C. Self-ex(cid:27)ltration: The
dangers of browser-enforced information (cid:30)ow control. In Proceedings of the
Workshop of Web (2012), vol. 2, Citeseer.
[7] Gundy, M. V., and Chen, H. Noncespaces: Using Randomization to Enforce
Information Flow Tracking and Thwart Cross-site Scripting Attacks. In 16th
Annual Network and Distributed System Security Symposium (NDSS 2009) (2009).
[8] Heiderich, M. Towards Elimination of XSS Attacks with a Trusted and Capability
Controlled DOM. PhD thesis, Ruhr-University Bochum, 2012.
Jsmvcomfg - to sternly look at javascript mvc and tem-
[9] Heiderich, M.
plating frameworks.
[online], https://www.slideshare.net/x00mario/
jsmvcomfg-to-sternly-look-at-javascript-mvc-and-templating-frameworks,
2013.
[10] Heiderich, M. Mustache security wiki. [online], https://github.com/cure53/