ation and testing—i.e., calling the same synthesized candidate on
multiple inputs.
As scaling out involves constant overheads for process spawning
and interprocess communication, scaling out makes sense only after
constant costs are negligible relative to synthesis. This is achieved
by having Harp scale out after a few AST levels have been explored.
6.3 Partial Regeneration
Harp may only partially regenerate L, if (1) a subset of library
functions in L fail regeneration, e.g., due to side-effects, or (2) if some
developer tests—Harp’s very last stage—fail. Partial regeneration
can still be useful to developers in a variety of ways. For example,
the regenerated library can operate side-by-side with a hardened
version of the original library.
The latter fast-slow setup combines
improved security properties with ac-
ceptable overall performance. The par-
tially regenerated L′ serves the major-
ity of the calls, and it does so efficiently
and securely. At times, however, L′ re-
ceives input that falls outside its ex-
pected range of operation—but not out-
side that of L. These inputs result into a runtime exception, caught
by a Harp controller component, which then forwards the input
to L. As L now executes with additional hardening in place, it is
significantly less efficient, but still computes the correct output
securely. The exact hardening mechanism and thus its performance
overhead can vary significantly [27, 33, 39, 65, 66], and depends
directly on details related to the threat model—for example, native
memory-unsafe binaries require additional care.
6.4 Quick Aborts
Harp implements a --quick-abort option that quits searching
if Harp detects behaviors such as file-system and environment-
variable access are not observable to clients that work only with
values returned from the target library. Such behaviors signal that
the original library may be falling outside Harp’s model of compu-
tation, allowing Harp to quickly abort the ALR process.
To record li-
brary accesses to
functionality im-
plemented out-
side the library,
Harp instruments
all names that re-
main free at the
top-level scope
of the library—i.e., ones that are not bound to values in the library.
Harp starts from a few well-known root names—a static list of
names provided by default by the language and runtime environ-
ment. For example, in server-side JavaScript these names include
the global variable table, the require function for importing other
libraries, and the process object for providing access to environ-
ment variables, process arguments, and other information in the
broader environment.
Load-Time Transformations: Modern dynamic languages fea-
ture a module-import mechanism that loads code at runtime as a
string. Harp applies lightweight load-time code transformations on
the string representation of each module, as well as the context to
…………(a) Object-ping fragment(b) Custom context creation(c) Context rebindingHARPadditionsfast / incomplete'Production Inputslow / complete✔✘✔Production Outputhardened←    ←    ←    …Session 6B: Web Vulnerabilities CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea1762which it is about to be bound, to insert instrumentation wrappers
into the module before it is loaded.
Harp’s transformations first create a modified copy of a mod-
ule’s runtime context. The context is a name-value mapping for all
free name variables available to the module by default. The modifi-
cations target the values in this mapping—traversing and wrapping
each value with an interposition mechanism that records the access
in a global access table. Harp then binds the modified context to
the module, using a source-to-source transformation that redefines
names in the context as library-local ones and assigns to them the
values of the modified context.
Harp’s transformations have a common structure that traverses
objects recursively—a base transform wrap, which we review first
(and whose effects are shown in Fig. 6a). The wrap transform takes
an object O and returns a new object O′, where every field f of O
is wrapped with and replaced by a method f ′. If called, f ′ adds a
record to a global map noting that this particular field f has been
accessed and then passes arguments to f .
Context Creation: To prepare a new context to be bound to a
library being loaded, Harp first creates an auxiliary hash table
(Fig. 6b), mapping names to newly transformed values: names cor-
respond to implicit modules—globals, language built-ins, module-
locals, etc.; transformed values are created by wrapping individual
values in the context to insert instrumentation hooks.
User-defined global variables are stored in a well-known location
(e.g., a map accessible through a global variable named global).
However, traversing the global scope for built-in objects is generally
not possible. To solve this problem, Harp collects such values by
resolving well-known names hard-coded in a list. Using this list,
Harp creates a list of pointers to unmodified values upon startup.
Care must be taken with module-local names such as the mod-
ule’s absolute filename, its exported values, and whether the mod-
ule is invoked as the application’s main module. These names refer
to a different value for each module, and thus attempting to ac-
cess the values directly from within Harp’s transformation scope
will fail subtly: the names will end up resolving to module-local
values of Harp itself. Harp solves this issue by deferring these
transformations to the context-binding phase (discussed next).
Context Binding: To bind the code whose context is being trans-
formed with the freshly created context, Harp applies a source-
to-source transformation that wraps the module with a function
closure (Fig. 6c.). By enclosing and evaluating a closure, Harp lever-
ages lexical scoping to inject a non-bypassable step in the variable
name resolution mechanism.
The closure starts by redefining default-available non-local names
as module-local ones, pointing to transformed values that exist in
the newly-created context. It accepts as an argument the customized
context and assigns its entries to their respective variable names in
a preamble consisting of assignments that execute before the rest
of the module. Module-local variables (a challenge outlined earlier)
are assigned the return value of a call to wrap, which will be applied
only when the module is evaluated and the module-local value be-
comes available. Harp evaluates the resulting closure, invokes it
with the custom context as an argument, and applies further wrap
transformations to its return value.
7 IMPLEMENTATION & EVALUATION
In summary, Harp’s evaluation answers the following questions:
• Q1: Can Harp eliminate real vulnerabilities? Harp success-
fully eliminates vulnerabilities that enable 3 large-scale software
supply-chain attacks (§7.2–7.4) by learning and regenerating
the core functionality of the vulnerable library, eliminating any
dependency to dangerous code. To the best of our knowledge,
Harp is the first system that can eliminate these attacks.
• Q2: How long does ALR take? Applied to 17 JavaScript string-
processing libraries (§7.5), Harp learns 14 libraries within a
minute and all under an hour. It also aborts within 5 seconds on
11 other JavaScript libraries that fall outside the string-processing
domain. Harp’s domain-specific performance refinements (§6.2)
improve the runtime performance of ALR by 179.27×.
• Q3: What are the characteristics of regenerated libraries?
The regenerated libraries execute between 2% faster and 7%
slower than the original JavaScript libraries. The regenerated
libraries import nothing and use only basic JavaScript language
primitives. The original libraries, in contrast, have access to
the entire JavaScript ecosystem, including standard JavaScript
and Node.js libraries, the file system, the network, environment
variables, and process arguments.
• Q4: Is ALR applicable outside JavaScript? Harp successfully
regenerates JavaScript versions of 5 native string-processing li-
braries (Appendix B). The regenerated libraries incur a maximum
overhead of 1% and enjoy memory and type safety benefits not
present in the original libraries.
7.1 Methodology
Workloads: To investigate Q1, we obtained 3 widely-publicized
software supply-chain security incidents from the JavaScript ecosys-
tem: (1) event-stream [41, 61], a popular library that was modified
to steal bitcoins from specific Bitcoin wallets (§7.2), (2) left-pad [37,
69], a popular library replaced by a no-op after a package name
dispute, breaking thousands of projects including Facebook and
PayPal (§7.3); and (3) string-compare [10], where two different
versions of the same string comparison library—one benign and
one malicious—appear in the same dependency tree (§7.4).
To investigate Q2 and Q3, we obtained 14 additional JavaScript
string processing libraries from npm with the help of an experi-
enced JavaScript developer and a senior undergraduate student.
The student used the npm’s search feature to search for libraries
using a variety of string-processing terms such as “padding”, “strip,”
and “change case.” For each term, the student sorted the list of re-
turned libraries by popularity [44] to inspect the first five pages of
search results and select the library that provided the most complete
corresponding functionality. We note that this process excludes
duplicates—for example, the student found and discarded more than
10 left-pad libraries with similar or identical functionality. This
phase produced 17 unique string-processing libraries that are used
pervasively and can affect a large part of the ecosystem [72]: collec-
tively, these libraries are directly imported by several applications
and transitively imported via other dependencies by more than
100K applications. The phase also produced 11 libraries that were
misclassified as string processing libraries. We applied Harp to all
28 libraries.
Session 6B: Web Vulnerabilities CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea1763To investigate Q4, we obtained C/C++ libraries by searching
GitHub using the same search terms as for the JavaScript libraries.
Since many of these libraries did not have tests or client programs,
we opted for C/C++ libraries with JavaScript bindings to check
compatibility via tests and client programs from the JavaScript
ecosystem. This search process produced five libraries.
Evaluation metrics: We evaluate security improvements qualita-
tively and quantitatively. For known attacks (Q1), we first used the
original (compromised) library to reproduce the attack. We then
inferred and regenerated the original library and replaced the orig-
inal library with the regenerated version. We confirmed that the
regenerated version eliminated the attack. For all libraries (Q2–5),
we report the privilege reduction achieved after applying Harp.
This quantitative security metric was developed recently [66] and
corresponds to a ratio α/t, where α is the count of all APIs that are
not invocable by the library any more, due to the defense applied,
and t is the total count of APIs made available to a library by default
by the combined built-in or third-party libraries.
We evaluate the correctness of regenerated libraries (Q3, Q5) us-
ing a combination of developer tests, client libraries or applications,
and manual inspection. We ran the developer-provided test suites
for the libraries and verified that the regenerated libraries provide
correct results. We also imported the regenerated libraries into
the top 10 client libraries or applications that directly import the
original libraries and ran the test suites for these client libraries
or applications. Finally, we manually inspected the regenerated
code to confirm that it correctly implements the intended correct
behavior of the original version.
For the learning time (Q2), we report wall-clock time after the
call npm-install up to the point where Harp either (1) aborts,
reporting intractability, (2) timeouts, failing to synthesize a library,
or (3) succeeds, regenerating a library and its appropriate bindings.
We set the timeout limit to 12 hours. We measured the runtime
performance of regenerated-libraries (Q4, Q5) using a combination
of developer tests and synthetic workloads operating in tight loops.
We repeated all performance-related experiments 100 times and
report averages.
Implementation Details: Harp currently works with black-box
libraries available in JavaScript, Python (not shown here; reported
in the extended version [blind]), and binary object files developed,
for example, in C/C++ and wrapped as native add-ons. We expect
native add-ons to be wrapped by some form of language-level
interface such as Node’s NaN or N-API and Python’s ctypes or
CFFI. Harp’s ALR components, including the synthesis and DSL,
are written in JavaScript. The base set of DSL terms as well as
the resulting programs are compiled to their respective language
using a small Python compiler: the compiler currently can emit
JavaScript and Python programs, which are then executed using the
interpreter of the respective language. The regenerated programs
link against a small utility library that provides runtime support,
ported once for each target language supported by Harp.
Harp currently has a few limitations. First, it does not sup-
port libraries whose functions mutate built-in, prototype, or other
objects—such as String.prototype in JavaScript. Additionally,
Harp’s input generation algorithm does not generate non-ASCII
strings or ones with special—possibly hierarchical—structure such
as JSON, HTML, and CSS; generating the latter without any addi-
tional domain information would be impractical.
Software and Hardware Setup: All experiments were conducted
on a server with 512GB of memory and 64 physical × 2.1GHz Intel
Xeon E5-2683 cores, running Debian 4.9.144-3.1. The JavaScript
setup uses Node.js v12.19, bundled with V8 v7.8.279.23, LibUV
v1.39.0, and npm version v6.14.8; the Python setup uses CPython
3.7.5. To perform timeline-accurate supply-chain attacks, we set up
a private registry using verdaccio [64] available only to the server
running the experiments.
7.2 Use Case: Event-Stream
The event-stream incident [41, 61], discussed extensively ear-
lier (§2), introduced a malicious dependency harvesting Bitcoin
account credentials through a popular stream-processing library.
This dependency, flatmap-stream, targeted a very specific pro-
duction environment of a cryptocurrency application; other envi-
ronments were not affected.
Security: We reconstruct the malicious library and payloads from
a variety of sources [21, 45, 52]. The library applies several checks
to verify it runs on production, as part of a specific application, and
as part of a specific build. If all these conditions hold, it then writes
to the file-system. Harp’s active learning phase does not infer any
file-system accesses—because there are no such accesses during
the learning phase and because the Harp DSL does not include file
system operations. As a result, Harp regenerates an exploit-free
version of the library, confirmed by manual inspection. It makes
no use of built-in APIs, achieving a privilege-reduction of 332×.
Performance & correctness: Harp takes on average 1.4 sec-
onds to complete flatmap-stream’s active learning and regen-
eration. We manually inspected the regenerated code and found
it implements the full functionality of the original library. The
original library does not come with any test cases and the ver-
sion of event-stream that uses the malicious flatmap-stream
version has been removed permanently from npm. We therefore
manually modified event-stream commit e316336, introducing
flatmap-stream to import the regenerated flatmap-stream, and
apply event-stream’s tests. All 14 (100%) of event-stream’s tests
pass successfully: 13/14 tests are not affected by the flatmap-
-stream addition, and 1/14 that tests flatmap-stream passes suc-
cessfully. Applying the regenerated flatmap-stream to an array
of 1000 elements over 10K runs takes 48.99 seconds—an overhead
of about 107µs per run over the performance of the original library.
7.3 Use Case: Left-Pad
The left-pad incident [37, 69] was caused by unpublishing a pop-
ular JavaScript library, effectively replacing it permanently with a
No-Op. While left-pad itself was an 11-line moderately-popular
string-padding function, it was used by many popular projects such
as React and Babel. The unpublishing corrupted production envi-
ronments, denying them the ability to revert to an older version of
the library. As a result, the incident affected more than one third
of the Node.js ecosystem, and led to significant changes in the
un-publishing policies of public library registries.
Session 6B: Web Vulnerabilities CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea1764Security: We apply Harp to an identical library built by npm
as a response to the incident, replacing the original left-pad li-
brary copied to our local registry (§7.1). Harp regenerates all of
left-pad’s functionality, fully eliminating the dependency. As a
result, left-pad’s tests still succeed after we unpublish left-pad
from our local registry because they no longer depend on the origi-
nal left-pad module. The regenerated left-pad makes no use of
built-in APIs, resulting in a privilege-reduction score of 332×.
Performance & correctness: Harp completes left-pad’s ac-
tive learning and regeneration in an average of 3.6 seconds. We
manually inspect the regenerated code and confirm it implements
left-pad’s full functionality. We apply the full test suite (35 tests)
from left-pad’s repository, all of which (100%) pass successfully.
One test is particularly interesting as it supplies ill-defined input to
trigger left-pad’s default behavior, by providing a padding length