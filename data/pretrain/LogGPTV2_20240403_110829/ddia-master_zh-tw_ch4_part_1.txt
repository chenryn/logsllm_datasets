# 第四章：编码与演化
![](../img/ch4.png)
> 唯变所适
>
> —— 以弗所的赫拉克利特，为柏拉图所引（公元前 360 年）
>
-------------------
[TOC]
应用程式不可避免地随时间而变化。新产品的推出，对需求的深入理解，或者商业环境的变化，总会伴随著 **功能（feature）** 的增增改改。[第一章](ch1.md) 介绍了 **可演化性（evolvability）** 的概念：应该尽力构建能灵活适应变化的系统（请参阅 “[可演化性：拥抱变化](ch1.md#可演化性：拥抱变化)”）。
在大多数情况下，修改应用程式的功能也意味著需要更改其储存的资料：可能需要使用新的栏位或记录型别，或者以新方式展示现有资料。
我们在 [第二章](ch2.md) 讨论的资料模型有不同的方法来应对这种变化。关系资料库通常假定资料库中的所有资料都遵循一个模式：尽管可以更改该模式（透过模式迁移，即 `ALTER` 语句），但是在任何时间点都有且仅有一个正确的模式。相比之下，**读时模式**（schema-on-read，或 **无模式**，即 schemaless）资料库不会强制一个模式，因此资料库可以包含在不同时间写入的新老资料格式的混合（请参阅 “[文件模型中的模式灵活性](ch2.md#文件模型中的模式灵活性)” ）。
当资料 **格式（format）** 或 **模式（schema）** 发生变化时，通常需要对应用程式程式码进行相应的更改（例如，为记录新增新栏位，然后修改程式开始读写该栏位）。但在大型应用程式中，程式码变更通常不会立即完成：
* 对于 **服务端（server-side）** 应用程式，可能需要执行 **滚动升级 （rolling upgrade）** （也称为 **阶段释出（staged rollout）** ），一次将新版本部署到少数几个节点，检查新版本是否执行正常，然后逐渐部完所有的节点。这样无需中断服务即可部署新版本，为频繁释出提供了可行性，从而带来更好的可演化性。
* 对于 **客户端（client-side）** 应用程式，升不升级就要看使用者的心情了。使用者可能相当长一段时间里都不会去升级软体。
这意味著，新旧版本的程式码，以及新旧资料格式可能会在系统中同时共处。系统想要继续顺利执行，就需要保持 **双向相容性**：
* 向后相容 (backward compatibility)
  新的程式码可以读取由旧的程式码写入的资料。
* 向前相容 (forward compatibility)
  旧的程式码可以读取由新的程式码写入的资料。
向后相容性通常并不难实现：新程式码的作者当然知道由旧程式码使用的资料格式，因此可以显示地处理它（最简单的办法是，保留旧程式码即可读取旧资料）。
向前相容性可能会更棘手，因为旧版的程式需要忽略新版资料格式中新增的部分。
本章中将介绍几种编码资料的格式，包括 JSON、XML、Protocol Buffers、Thrift 和 Avro。尤其将关注这些格式如何应对模式变化，以及它们如何对新旧程式码资料需要共存的系统提供支援。然后将讨论如何使用这些格式进行资料储存和通讯：在 Web 服务中，**表述性状态传递（REST）** 和 **远端过程呼叫（RPC）**，以及 **讯息传递系统**（如 Actor 和讯息伫列）。
## 编码资料的格式
程式通常（至少）使用两种形式的资料：
1. 在记忆体中，资料储存在物件、结构体、列表、阵列、散列表、树等中。这些资料结构针对 CPU 的高效访问和操作进行了最佳化（通常使用指标）。
2. 如果要将资料写入档案，或透过网路传送，则必须将其 **编码（encode）** 为某种自包含的位元组序列（例如，JSON 文件）。由于每个程序都有自己独立的地址空间，一个程序中的指标对任何其他程序都没有意义，所以这个位元组序列表示会与通常在记忆体中使用的资料结构完全不同 [^i]。
[^i]: 除一些特殊情况外，例如某些记忆体对映档案或直接在压缩资料上操作（如 “[列压缩](ch3.md#列压缩)” 中所述）。
所以，需要在两种表示之间进行某种型别的翻译。从记忆体中表示到位元组序列的转换称为 **编码（Encoding）** （也称为 **序列化（serialization）** 或 **编组（marshalling）**），反过来称为 **解码（Decoding）**[^ii]（**解析（Parsing）**，**反序列化（deserialization）**，**反编组（unmarshalling）**）[^译i]。
[^ii]: 请注意，**编码（encode）**  与 **加密（encryption）** 无关。本书不讨论加密。
[^译i]: Marshal 与 Serialization 的区别：Marshal 不仅传输物件的状态，而且会一起传输物件的方法（相关程式码）。
> #### 术语冲突
> 不幸的是，在 [第七章](ch7.md)： **事务（Transaction）** 的上下文里，**序列化（Serialization）** 这个术语也出现了，而且具有完全不同的含义。尽管序列化可能是更常见的术语，为了避免术语过载，本书中坚持使用 **编码（Encoding）** 表达此含义。
这是一个常见的问题，因而有许多库和编码格式可供选择。首先让我们概览一下。
### 语言特定的格式
许多程式语言都内建了将记忆体物件编码为位元组序列的支援。例如，Java 有 `java.io.Serializable` 【1】，Ruby 有 `Marshal`【2】，Python 有 `pickle`【3】，等等。许多第三方库也存在，例如 `Kryo for Java` 【4】。
这些编码库非常方便，可以用很少的额外程式码实现记忆体物件的储存与恢复。但是它们也有一些深层次的问题：
* 这类编码通常与特定的程式语言深度系结，其他语言很难读取这种资料。如果以这类编码储存或传输资料，那你就和这门语言绑死在一起了。并且很难将系统与其他组织的系统（可能用的是不同的语言）进行整合。
* 为了恢复相同物件型别的资料，解码过程需要 **例项化任意类** 的能力，这通常是安全问题的一个来源【5】：如果攻击者可以让应用程式解码任意的位元组序列，他们就能例项化任意的类，这会允许他们做可怕的事情，如远端执行任意程式码【6,7】。
* 在这些库中，资料版本控制通常是事后才考虑的。因为它们旨在快速简便地对资料进行编码，所以往往忽略了向前和向后相容性带来的麻烦问题。
* 效率（编码或解码所花费的 CPU 时间，以及编码结构的大小）往往也是事后才考虑的。例如，Java 的内建序列化由于其糟糕的效能和臃肿的编码而臭名昭著【8】。
因此，除非临时使用，采用语言内建编码通常是一个坏主意。