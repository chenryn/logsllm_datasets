# 2020太湖杯Reverse Writeup及复盘
##### 译文声明
本文是翻译文章
译文仅供参考，具体内容表达以及含义原文为准。
## 前言
>
> 由于个人原因没有参加这次的太湖杯，赛后花时间复盘了一下，感觉还学到挺多知识的吧。写这篇文章时，网上还没有公开的Writeup，故分享一下供大家一起学习交流。
题目链接方便大家复盘：
## 0x00 easy_app
> 知识点：安卓逆向、base64、Tea算法
基础的安卓逆向，主要逻辑在native的so下。有一个check函数。
判断输入的flag格式是否为flag{}，且长度是否等于38。
check1函数进行第一次转换，去掉flag格式，将输入分成两组，一组16个字符。
将前十六位的高四位和后十六位的低四位组合存放到后十六位，将后十六位的高四位和前十六位的低四位组合存放到前十六位。举例
    31 32 33.....
    64 65 66.....
    变换后：
    61 62 63.....
    34 35 36.....
之后在分成4组进行tea加密，key这里运行时候被修改了，正确的应该是`0x42,0x37,0x2c,0x21`。
之后进行换表base64加密，这个有一个点就是，base64_encode中不止包括了base64加密，还有移位操作。将编码之后的base64，每三位循环向左移动，第四位做分隔符不变。举例
    12345678
    23146758
从文件中找base64的表为`abcdefghijklmnopqrstuvwxyz!@#$%^&*()ABCDEFGHIJKLMNOPQRSTUVWXYZ+/`。  
所有算法反推回去就是flag，由于多个运算组合，没有合到一个脚本。懒狗。
## 0x01 baby_arm
> 知识点：arm平台逆向，花指令
拿到的bin文件是arm架构下小端序的文件，arm逆向其实已经很常见了，也没有什么稀奇的，而且对于IDA已经很早之前就支持了对arm的F5，逆向起来也很容易。
用IDA加载一下，发现main函数的地方没有被解析为代码，更别说识别为函数和之后的F5了。
手动变成代码也不行。一开始在想会不会arm的某个版本，而IDA没有支持？
看了下字符串，发现一些交互的字符串，而且发现有很奇怪的一串字符，这里猜测可能是一个迷宫？
qemu模拟跑一下，发现报一个非法指令的错误？很奇怪
在放到ghidra里看一下。
发现是可以反编译成功的，不过有一个需要注意的点，也是这个题目的关键，途中圈住的这条指令，地址是标红的。想要去看下这个地址存放的是什么，发现不存在这个地址，这时候想到，会不会是类似于花指令之类的脏数据。于是切换到IDA中，把这条指令nop掉，发现就可以进行反编译了，而且qemu可以执行。wtf？
之后就比较简单了。看一下伪代码。
大致输入25位长度的flag，不包括\n，所以代码是26次循环。分成两部分，每一部分长度为0xD。
第一部分验证就是会mmap创建一块儿内存dest，之后再将init修改之后的0x21088内存拷贝到dest处。之后再进行一次SMC，修改过后的代码，`0x21088`处为`+`，`0x210c8`处为`-`，`0x21108`处为`xor`。之后会通过取余3的方式，轮流调用这三个函数进行计算再进行比较。
    >>> cip = [0x63,0xd2,0xfe,0x4f,0xb9,0xd9,0x00,0x3f,0xa0,0x80,0x43,0x50,0x55]
    >>> key = [0xFD, 0x9A, 0x9F, 0xE8, 0xC2, 0xAE, 0x9B, 0x2D, 0xC3,0x11, 0x2A, 0x35, 0xF6]
    >>> flag = ''
    >>> for i in range(len(cip)):
    ...     if i%3 == 0:
    ...             flag += chr((cip[i]-key[i])&0xff)
    ...     elif i%3 == 1:
    ...             flag += chr((cip[i]+key[i])&0xff)
    ...     else:
    ...             flag += chr(cip[i]^key[i])
接下来再看第二部分，很明显之后的v4和v5都是两个函数，用来改变刚才说的地图。做为懒狗的我直接动态，把地图从内存中dump下来。
    ******
    *   E*
    * ****
    * ****
    * ****
    *    *
大致为这个样子，是一个6*6的地图。之后进入sub_10770函数。
    signed int __fastcall sub_10770(int a1, int a2)
    {
      int v4; // [sp+Ch] [bp-20h]
      int v5; // [sp+10h] [bp-1Ch]
      int v6; // [sp+14h] [bp-18h]
      char v7; // [sp+18h] [bp-14h]
      int i; // [sp+1Ch] [bp-10h]
      int v9; // [sp+20h] [bp-Ch]
      int v10; // [sp+24h] [bp-8h]
      v10 = 4;
      v9 = 1;
      v4 = 0x41203E53;
      v5 = 0xB242C1E;
      v6 = 0x52372836;
      v7 = 0xE;
      for ( i = 0; i <= 0xC; ++i )
      {
        *(a2 + i) ^= *(&v4 + i);
        switch ( *(a2 + i) )
        {
          case 'a':
            --v10;
            break;
          case 'b':
          case 'c':
          case 'e':
          case 'f':
          case 'g':
          case 'h':
          case 'i':
          case 'j':
          case 'k':
          case 'l':
          case 'm':
          case 'n':
          case 'o':
          case 'p':
          case 'q':
          case 'r':
          case 't':
          case 'u':
          case 'v':
            break;
          case 'd':
            ++v10;
            break;
          case 's':
            ++v9;
            break;
          case 'w':
            --v9;
            break;
        }
        if ( *(a1 + 6 * v9 + v10) == '*' )
        {