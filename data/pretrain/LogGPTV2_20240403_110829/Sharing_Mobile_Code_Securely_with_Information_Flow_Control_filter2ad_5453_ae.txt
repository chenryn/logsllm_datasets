Loading
Total
Downloaded code size
Execution time (ms)
FriendMap Bidding
2
217
3
8,693
6
8,921
19 kB
1
42
6
15,514
3
15,566
58 kB
Fig. 11: Execution time for the steps required to verify and load
dynamically compiled mobile code, averaged over ﬁve runs.
that an offer may only be read by Broker; the integrity
component of this label User←;AirlineA←;AirlineB←
record that the choice of an offer may be inﬂuenced by
all three principals (the user and both airlines). Lines 3–
5 initialize the airline and user agents, and illustrate how
principal and label parameters are provided. To inform the
user of the auction result, the winning agent and offer need
to be declassiﬁed. This requires the authority of Broker; for
example, to declassify the winner, the broker performs:
1 declassify (
2
3
endorse (winner, {*auction} to {Broker→;Broker←})
to {Broker→User;Broker←})
Before declassifying winner,
to
integrity {Broker←}. Without
the de-
classiﬁcation would not be robust: a potentially untrusted
principal User could inﬂuence what conﬁdential information
he or she learns. Direct endorsement recognizes this inﬂuence.
Declassiﬁcation of the winning offer is similar.
this code endorses it
this endorsement,
8.3. Performance evaluation
Support for mobile code affects the performance of the
system in two ways. First, there is additional work required
to dynamically load and analyze new code. Second, linking
with remote classes imposes some execution overhead.
To evaluate these impacts, we have broken down the
execution time of the two examples. These measurements
were performed on an Intel Core i7-860 with 4 GiB RAM.
Figure 11 gives the execution time of each step required to
load the mobile classes from Fabric into the JVM.
As expected, almost all the time is spent invoking the
compiler to analyze the code and generate bytecode. Our
compiler has not yet been optimized for run-time compilation,
so we expect to be able to reduce that time signiﬁcantly. More
importantly, we can often avoid the analysis entirely—when
either the worker has compiled the class in the past, or the
worker trusts the provider of the code to correctly compile it.
To demonstrate this, Figure 12 shows the time required
to load the classes in our examples, in two scenarios: with
all classes dynamically compiled at load time, and with all
classes pre-compiled and locally cached. We have also back-
ported the bidding agent example to the original non-mobile
Fabric prototype, and give the load time for that as well.
203
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 11:46:49 UTC from IEEE Xplore.  Restrictions apply. 
Total load time
for all classes (ms)
FriendMap Bidding
9,188
298
20
15,600
26
—
Dynamically compiled
Locally cached
Non-mobile Fabric
Fig. 12: Total
conditions. We present the mean over ﬁve runs.
time spent
in the class loader, under different
Total execution time (ms)
OO7
—
39
36
FriendMap Bidding
14,210
5,999
4,873
17,995
4,910
—
Uncached
Cached
Non-mobile
Fig. 13: Running time of OO7 and the mobile-code examples
To evaluate the run-time overhead of our codebase mecha-
nism, we reran two traversals from the Fabric implementation
of the OO7 Object Oriented Database benchmark suite [6].
This benchmark fetches and calls methods on a large number
of objects. To focus on the run-time overhead of mobile
code, we ran the benchmarks with compiled bytecode cached
locally, and compared this with the original Fabric system.
The results of this benchmark are shown in Figure 13.
Comparing Figures 12 and 13 shows that the uncached
execution time with class loading removed is less than the
cached execution time. This shows that compiling code has
side effects, such as populating the object cache, that would
have been performed anyway.
9. Related work
The Fabric system [20, 19] supports secure programming
in a decentralized system, but it does not have mechanisms
for secure mobile code. This paper has shown how to extend
the Fabric run-time system and language to support mobile
code, and has controlled some covert channels in Fabric.
The DStar system [38] provides OS-level enforcement of
secure information ﬂow across a federated system. It uses
“exporters” to map machine-level security policies into a
distributed context, allowing hosts to deﬁne the degree of trust
between host nodes. DStar has no notion of code integrity or
secrecy, and does not support mobile code; publishing and
installation of code lies outside the system. The dynamic
enforcement in DStar and in earlier OS-level systems [37, 16]
tracks information ﬂows coarsely; to manage information of
different security levels, the application must be partitioned
accordingly. Declassiﬁcation is needed more often, and its
scope is an entire process rather than a single data item.
Information-ﬂow control for JavaScript has been explored,
in which loaded code is dynamically checked against stati-
cally identiﬁed residual information-ﬂow requirements [7].
Cross-origin resource sharing (CORS) [33] extends the
same-origin policy to allow web sites to specify domains
that may load resources from other origins. A browser im-
plementing the CORS API performs a “preﬂight request” to
determine what restrictions apply to a resource before fetching
the resource. Policies are speciﬁed by web sites and users
have no explicit control over what policies are enforced.
Various attempts have been made to strengthen isolation
guarantees for JavaScript. Conscript [21] applies aspects to
JavaScript primitives, isolating loaded scripts in useful ways.
Caja [22] uses capabilities to provide isolation in web
mashups. Caja capabilities protect access to resources at a
ﬁne granularity. Secure information ﬂow can be enforced by
checking capabilities at statically predetermined locations [4],
assuming a static analysis of information ﬂow.
System extensibility and evolution has been explored in
many contexts. To our knowledge, Mobile Fabric is the ﬁrst
system to address the information security of the assembly
and evolution of components in a general distributed setting.
SPIN [3] is an extensible operating system that allows core
kernel functionality to be dynamically specialized by modules
written in Modula-3. Like Mobile Fabric, SPIN leverages
language-level features like interfaces and type safety to pro-
vide isolation for untrusted system modules. Unlike Mobile
Fabric, SPIN uses namespace isolation to control access to
system resources: capabilities are implemented as references
to system resources, with a type capturing access privileges.
In contrast, name resolution in Mobile Fabric is mostly
orthogonal to security, and the security implications of linking
with low integrity code are captured by the type system.
Prior work on expressive module systems explored several
approaches to component reuse and evolution. Unit [10] and
Knit [28] are component deﬁnition and linking languages that
enable programmatic assembly of components. Composite
units are assembled out of smaller ones, and some architec-
tural properties are checked, such as type consistency (in [10])
or user-deﬁned constraints (in [28]). These systems provide
more ﬂexible control of namespaces, but they do not address
the security of the produced code.
Codebases have similarities to the classpath entries in
JAR ﬁles [27]. These references are neither versioned nor
immutable, so the meaning of Java classes can change over
time. JAR ﬁles allow packages to be sealed, to control who
can insert classes into them. Sealing is orthogonal to our
consistency requirements: it does not ensure that classes are
named consistently nor that the meaning of code is ﬁxed.
10. Conclusions
This paper describes a new kind of computing platform:
a decentralized platform for running mobile code securely,
subject to explicit policies for conﬁdentiality and integrity.
A prototype of this platform has been implemented and
evaluated on various distributed applications. The platform
enables applications that would be disallowed by isolation-
based security mechanisms;
the explicit policies used to
develop the applications help guide secure design.
204
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 11:46:49 UTC from IEEE Xplore.  Restrictions apply. 
The new mobile-code architecture is an interesting and
potentially useful artifact in its own right; because it addresses
a general problem, the principles and techniques that we
have described should be useful for making other distributed
systems secure, especially those employing mobile code.
Acknowledgments
We thank Danfeng Zhang, Dan Ports, David Schulze, and
Barbara Liskov for their suggestions regarding this work and
its presentation. Lucas Waye helped implement the class-
loading mechanisms of Mobile Fabric. Danfeng Zhang im-
proved declassiﬁcation and error reporting. This work was
funded by a grant from the Ofﬁce of Naval Research (ONR
N000140910652), by two grants from the NSF: 0424422 (the
TRUST center), and 0964409. This research is sponsored by
the Air Force Research Laboratory.
References
[1] Aslan Askarov, Sebastian Hunt, Andrei Sabelfeld, and David Sands.
Termination-insensitive noninterference leaks more than just a bit. In
ESORICS, pages 333–348, October 2008.
[2] Aslan Askarov and Andrew C. Myers. Attacker control and impact for
conﬁdentiality and integrity. Logical Methods in Computer Science,
7(3), September 2011.
[3] Brian Bershad, Stefan Savage, Przemyslaw Pardyak, Emin Gun Sirer,
David Becker, Marc Fiuczynski, Craig Chambers, and Susan Eggers.
Extensibility, safety and performance in the SPIN operating system. In
Proc. 15th ACM Symp. on Operating System Principles (SOSP), pages
267–284, December 1995.
[4] A. Birgisson and A. Sabelfeld. Capabilities for information ﬂow. In
Proc. 6th ACM SIGPLAN Workshop on Programming Languages and
Analysis for Security, June 2011.
[5] Andrew Birrell, Greg Nelson, Susan Owicki, and Edward Wobber.
In Proc. 14th ACM Symp. on Operating System
Network objects.
Principles (SOSP), pages 217–230, December 1993.
[6] M. J. Carey, D. J. DeWitt, and J. F. Naughton. The OO7 Benchmark.
In Proc. ACM SIGMOD International Conference on Management of
Data, pages 12–21, Washington D.C., May 1993.
[7] Ravi Chugh, Jeffrey A. Meister, Ranjit Jhala, and Sorin Lerner. Staged
information ﬂow for JavaScript. In Proc. SIGPLAN 2009 Conference
on Programming Language Design and Implementation, June 2009.
[8] Dorothy E. Denning. Cryptography and Data Security. Addison-
Wesley, Reading, Massachusetts, 1982.
[9] Dorothy E. Denning and Peter J. Denning. Certiﬁcation of programs
for secure information ﬂow. Comm. of the ACM, 20(7):504–513, July
1977.
[10] Matthew Flatt and Matthias Felleisen. Units: cool modules for HOT
In Proc. SIGPLAN 1998 Conference on Programming
languages.
Language Design and Implementation, May 1998.
[11] E. Hammer-Lahav. The OAuth 2.0 authorization protocol. Network
Working Group Internet-Draft, September 2011.
[12] Ian Hickson. HTML5: A vocabulary and associated APIs for HTML
and XHTML, version 1.5446, November 2011. W3C editor’s draft,
http://dev.w3.org/html5/spec.
[13] R. Housley, T. Polk, W. Ford, and D. Solo. Internet X.509 public key
infrastructure certiﬁcate and certiﬁcate revocation list (CRL) proﬁle.
Internet RFC-3280, April 2002.
[14] Collin Jackson and Helen J. Wang. Subspace: Secure cross-domain
communication for web mashups. In WWW ’07, May 2007.
[15] B. K¨opf and D. Basin. An information-theoretic model for adaptive
side-channel attacks. In CCS ’07, October 2007.
[16] Maxwell Krohn, Alexander Yip, Micah Brodsky, Natan Cliffer,
M. Frans Kaashoek, Eddie Kohler, and Robert Morris.
Information
ﬂow control for standard OS abstractions. In Proc. 21st ACM Symp.
on Operating System Principles (SOSP), 2007.
[17] Butler Lampson, Mart´ın Abadi, Michael Burrows, and Edward Wobber.
In Proc.
Authentication in distributed systems: Theory and practice.
13th ACM Symp. on Operating System Principles (SOSP), pages 165–
182, October 1991. Operating System Review, 253(5).
[18] Butler W. Lampson. A note on the conﬁnement problem. Comm. of
the ACM, 16(10):613–615, October 1973.
[19] Jed Liu, Michael D. George, K. Vikram, Xin Qi, Lucas Waye, Owen
Arden, Danfeng Zhang, and Andrew C. Myers. Fabric 0.1. Software re-
lease, http://www.cs.cornell.edu/projects/fabric, September
2010.
[20] Jed Liu, Michael D. George, K. Vikram, Xin Qi, Lucas Waye, and
Andrew C. Myers. Fabric: a platform for secure distributed computation
and storage. In Proc. 22nd ACM Symp. on Operating System Principles
(SOSP), pages 321–334, 2009.
[21] Leo A. Meyerovich and Benjamin Livshits. ConScript: Specifying and
enforcing ﬁne-grained security policies for JavaScript in the browser.
In Proc. IEEE Symposium on Security and Privacy, May 2010.
[22] M. Miller, M. Samuel, B. Laurie, I. Awad, and M. Stay. Caja: Safe
active content in sanitized JavaScript, 2008.
[23] Andrew C. Myers.
JFlow: Practical mostly-static information ﬂow
In Proc. 26th ACM Symp. on Principles of Programming
control.
Languages (POPL), pages 228–241, January 1999.
[24] Andrew C. Myers and Barbara Liskov. A decentralized model for
In Proc. 17th ACM Symp. on Operating
information ﬂow control.
System Principles (SOSP), pages 129–142, 1997.
[25] Andrew C. Myers and Barbara Liskov. Protecting privacy using the
decentralized label model. ACM Transactions on Software Engineering
and Methodology, 9(4):410–442, October 2000.
[26] OMG. The Common Object Request Broker: Architecture and Speciﬁca-
tion, December 1991. OMG TC Document Number 91.12.1, Revision
1.1.
[27] Oracle Corp. JAR ﬁle speciﬁcation, 1999.
http://download.oracle.com/javase/1.4.2/docs/guide/jar/jar.html.
[28] Alastair Reid, Matthew Flatt, Leigh Stoller, Jay Lepreau, and Eric
In Proc.
Eide. Knit: Component composition for systems software.
4th USENIX Symp. on Operating Systems Design and Implementation
(OSDI), pages 347–360, October 2000.
[29] Dale Rogerson. Inside COM. Microsoft Press, Redmond, WA, 1997.
[30] Indrajit Roy, Donald E. Porter, Michael D. Bond, Kathryn S. McKinley,
and Emmett Witchel. Laminar: Practical ﬁne-grained decentralized
In Proc. SIGPLAN 2009 Conference on
information ﬂow control.
Programming Language Design and Implementation, 2009.
[31] Andrei Sabelfeld and Andrew C. Myers. Language-based information-
IEEE Journal on Selected Areas in Communications,
ﬂow security.
21(1):5–19, January 2003.
[32] Andrei Sabelfeld and David Sands. Probabilistic noninterference for
In Proc. 13th IEEE Computer Security
multi-threaded programs.
Foundations Workshop, pages 200–214. IEEE Computer Society Press,
July 2000.
[33] Anne van Kesteren. Cross-origin resource sharing. W3C working draft,
W3C, March 2009. http://www.w3.org/TR/2009/WD-cors-20090317/.
[34] Robert Wahbe, Steven Lucco, Thomas E. Anderson, and Susan L.
Graham. Efﬁcient software-based fault isolation. In Proc. 14th ACM
Symp. on Operating System Principles, pages 203–216, December
1993.
[35] Michal Zalewski. Browser security handbook, part 2, 2009.
http://code.google.com/p/browsersec/wiki/Part2.
[36] Steve Zdancewic, Lantian Zheng, Nathaniel Nystrom, and Andrew C.
Myers. Secure program partitioning. ACM Transactions on Computer
Systems, 20(3):283–328, August 2002.
[37] Nickolai Zeldovich, Silas Boyd-Wickizer, Eddie Kohler, and David
In Proc.
Mazi`eres. Making information ﬂow explicit
7th USENIX Symp. on Operating Systems Design and Implementation
(OSDI), pages 263–278, 2006.
in HiStar.
[38] Nickolai Zeldovich, Silas Boyd-Wickizer, and David Mazi`eres. Se-
curing distributed systems with information ﬂow control. In Proc. 5th
USENIX Symposium on Networked Systems Design and Implementation
(NSDI), pages 293–308, 2008.
[39] Danfeng Zhang, Aslan Askarov, and Andrew C. Myers. Predictive
mitigation of timing channels in interactive systems. In Proc. 18th ACM
Conf. Computer and Communications Security (CCS), pages 563––574,
October 2011.
[40] Lantian Zheng, Stephen Chong, Andrew C. Myers, and Steve
Zdancewic. Using replication and partitioning to build secure dis-
tributed systems. In Proc. IEEE Symposium on Security and Privacy,
pages 236–250, Oakland, California, May 2003.
205
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 11:46:49 UTC from IEEE Xplore.  Restrictions apply.