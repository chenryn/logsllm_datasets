# 动态加载和执行时间

| 项目 | 加载总数 | 已下载代码大小 (kB) | 执行时间 (ms) |
| --- | --- | --- | --- |
| FriendMap Bidding | 2 | 19 | 8,693 |
| FriendMap Bidding | 6 | 58 | 15,514 |

图11：验证并加载动态编译的移动代码所需步骤的平均执行时间（五次运行的平均值）。

## 保密性和完整性

在我们的系统中，报价只能由Broker读取。此标签的完整性组件`User←;AirlineA←;AirlineB←`表明，报价的选择可能受到用户和两家航空公司的影响。第3-5行初始化了航空公司的代理和用户代理，并展示了如何提供主体和标签参数。为了通知用户拍卖结果，需要解密获胜代理和报价。这需要Broker的授权。例如，为了解密获胜者，Broker执行以下操作：

```java
declassify(
    endorse(winner, {*auction} to {Broker→;Broker←})
    to {Broker→User;Broker←}
)
```

在解密`winner`之前，该代码将其认可为具有`integrity {Broker←}`。没有这种认可，解密将不够稳健：潜在不可信的主体`User`可能会对机密信息产生影响。直接认可承认了这种影响。解密获胜报价的过程与此类似。

## 性能评估

支持移动代码对系统性能有两个方面的影响。首先，动态加载和分析新代码需要额外的工作。其次，与远程类进行链接会带来一些执行开销。

为了评估这些影响，我们分解了两个示例的执行时间。这些测量是在配备4 GiB RAM的Intel Core i7-860上进行的。图11给出了从Fabric加载移动类到JVM所需每个步骤的执行时间。

如预期的那样，几乎所有的时间都花在调用编译器来分析代码并生成字节码上。我们的编译器尚未针对运行时编译进行优化，因此我们预计可以显著减少这一时间。更重要的是，我们经常可以完全避免这种分析——当工作节点以前已经编译过该类，或者工作节点信任代码提供者能够正确编译它时。

为了演示这一点，图12显示了在两种场景下加载示例类所需的时间：所有类都在加载时动态编译，以及所有类预先编译并本地缓存。我们还将竞标代理示例回溯到了原始非移动的Fabric原型，并提供了其加载时间。

| 示例 | 动态编译 (ms) | 本地缓存 (ms) | 非移动Fabric (ms) |
| --- | --- | --- | --- |
| FriendMap Bidding | 9,188 | 298 | 20 |
| FriendMap Bidding | 15,600 | 26 | — |

图12：在不同条件下类加载器的总加载时间（五次运行的平均值）

## 运行时开销

为了评估我们代码库机制的运行时开销，我们重新运行了Fabric实现中的OO7面向对象数据库基准套件中的两个遍历[6]。这个基准测试涉及大量对象的获取和方法调用。为了专注于移动代码的运行时开销，我们在本地缓存编译后的字节码，并与原始Fabric系统进行了比较。基准测试的结果如图13所示。

| 示例 | 未缓存 (ms) | 缓存 (ms) | 非移动 (ms) |
| --- | --- | --- | --- |
| OO7 | — | 39 | 36 |
| FriendMap Bidding | 14,210 | 5,999 | 4,873 |
| FriendMap Bidding | 17,995 | 4,910 | — |

图13：OO7和移动代码示例的运行时间

通过比较图12和图13可以看出，移除类加载后的未缓存执行时间小于缓存执行时间。这表明编译代码具有副作用，例如填充对象缓存，这些操作无论如何都会执行。

## 相关工作

Fabric系统[20, 19]支持在分散系统中进行安全编程，但没有安全移动代码的机制。本文展示了如何扩展Fabric运行时系统和语言以支持移动代码，并控制了Fabric中的一些隐蔽通道。

DStar系统[38]提供了跨联邦系统的操作系统级安全信息流强制执行。它使用“导出器”将机器级安全策略映射到分布式上下文中，允许主机定义主机节点之间的信任程度。DStar没有代码完整性和保密性的概念，也不支持移动代码；代码的发布和安装不在系统范围内。DStar和早期的操作系统级系统[37, 16]中的动态强制执行粗略地跟踪信息流；要管理不同安全级别的信息，应用程序必须相应地进行分区。解密更为频繁，并且其范围是整个进程而不是单个数据项。

JavaScript的信息流控制已经得到了探索，其中加载的代码会根据静态识别的残余信息流要求进行动态检查[7]。跨源资源共享（CORS）[33]扩展了同源策略，允许网站指定可以从其他源加载资源的域。实现CORS API的浏览器会在获取资源之前执行“预检请求”，以确定对该资源的限制。策略由网站指定，用户对所实施的策略没有明确的控制权。

已经尝试了多种方法来加强JavaScript的隔离保证。Conscript[21]将方面应用于JavaScript原语，以有用的方式隔离加载的脚本。Caja[22]使用功能来在Web混搭中提供隔离。Caja功能以细粒度保护对资源的访问。可以通过在静态确定的位置检查功能来强制执行安全信息流[4]，假设对信息流进行了静态分析。

系统可扩展性和演进已在许多上下文中进行了探索。据我们所知，Mobile Fabric是第一个在一般分布式设置中解决组件组装和演进信息安全问题的系统。SPIN[3]是一个可扩展的操作系统，允许通过用Modula-3编写的模块动态专业化核心内核功能。类似于Mobile Fabric，SPIN利用接口和类型安全性等语言级特性为不受信任的系统模块提供隔离。与Mobile Fabric不同，SPIN使用命名空间隔离来控制对系统资源的访问：功能作为对系统资源的引用实现，类型捕获访问权限。相比之下，Mobile Fabric中的名称解析大多与安全性正交，通过类型系统捕获与低完整性代码链接的安全含义。

先前关于表达式模块系统的工作探讨了几种组件重用和演进的方法。Unit[10]和Knit[28]是组件定义和链接语言，使程序化组件装配成为可能。复合单元由较小的单元组装而成，并检查某些架构属性，例如类型一致性（在[10]中）或用户定义的约束（在[28]中）。这些系统提供了更灵活的命名空间控制，但不涉及生成代码的安全性。

代码库与JAR文件中的类路径条目[27]有相似之处。这些引用既不是版本化的也不是不可变的，因此Java类的意义可能会随时间变化。JAR文件允许包被密封，以控制谁可以向其中插入类。密封与我们的一致性要求正交：它不能确保类的命名一致，也不能确保代码的意义固定不变。

## 结论

本文描述了一种新的计算平台：一个用于在显式机密性和完整性政策下安全运行移动代码的分散平台。该平台的原型已实现并经过各种分布式应用的评估。该平台使那些被基于隔离的安全机制禁止的应用程序得以实现；用于开发这些应用程序的显式政策有助于指导安全设计。

新的移动代码架构本身就是一个有趣且潜在有用的工件；因为它解决了普遍存在的问题，我们所描述的原则和技术应该对使其他分布式系统（特别是那些使用移动代码的系统）更加安全有所帮助。

## 致谢

感谢Danfeng Zhang、Dan Ports、David Schulze和Barbara Liskov对这项工作及其展示提出的建议。Lucas Waye帮助实现了Mobile Fabric的类加载机制。Danfeng Zhang改进了解密和错误报告。这项工作由海军研究办公室（ONR N000140910652）、NSF的两项拨款（0424422 [TRUST中心] 和0964409）资助。这项研究由空军研究实验室赞助。

## 参考文献

[此处列出参考文献]

---

这样处理后，文本变得更加清晰、连贯和专业。希望这对你有帮助！