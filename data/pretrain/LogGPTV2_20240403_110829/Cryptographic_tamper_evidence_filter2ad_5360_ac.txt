PrSuccKESig(F )  te or she must forge the signa-
tures for the signer’s public keys for periods t > te, without
knowing the corresponding secret keys. But the former en-
ables divergence detection, while the later requires breaking
the underlying ordinary signature scheme.
Formally, let Σ be any ordinary signature scheme. Si de-
notes a speciﬁc instance of Σ with the corresponding private
and public keys Si.SK ,Si.PK generated by the Σ.Gen.
Deﬁne KESig.Gen to be Σ.Gen → (KESig.SK 0 = S0.SK ,
KESig.PK = S0.PK ).
KESig.Upd(SK t−1) runs Σ.Gen → St.(cid:3)PK , SK(cid:4), if t ≤ T .
These keys St.(cid:3)PK , SK(cid:4) are appended to the current key
KESig.SK t−1 yielding the next period’s key KESig.SK t =
(cid:3)t;S0.SK ;(cid:3)Si.PK ,Si.SK(cid:4)i=1 to t(cid:4).
For t≤ T , KESig.Sign(SK t, t, M ) runs Si.Sign(SK ,(cid:3)t, M(cid:4)) →
σi for all i = 0 to t, generating the signature bσt,M =
(cid:3)t, σ0,(cid:3)Si.PK , σi(cid:4)i=1 to t(cid:4).
KESig.Vf(PK , M,(cid:3)t, σ0, . . .(cid:4)) returns valid if for all i : 0 ≤
i ≤ t ≤ T , Si.Vf(PK ,(cid:3)t, M(cid:4)) = valid (i.e., all the ordinary
signatures are veriﬁed).6
Finally, to test for foul play, KESig.Div(bσt1,M1 , bσ(cid:1)
t2,M2 )
returns ok if for the two sequences (cid:3)Si.PK(cid:4)i=1 to t1 and
(cid:3)S(cid:1)
j.PK(cid:4)j=1 to t2 from bσt1,M2 , bσt2,M2 respectively, one is a
preﬁx of the other. Otherwise, KESig.Div returns foul.
3.1.2
Security
Let KESig and Σ be deﬁned as in the Section 3.1.1 above.
Claim 1. If Σ is secure (in the sense of [14]), then KESig
is strongly tamper-evident (0-te).
Proof sketch: The signature security proof is trivial, since
KESig signature simply contains the Σ signature, appended
with random values, which can be easily simulated.
It is also obvious that our scheme is self-consistent.
For the tamper-evidence proof, reduce forging a Σ signa-
ture to F fooling the Div test. Suppose that we are given
a Σ public key S.PK (and no corresponding secret key).
Suppose that we are also given a signature oracle access
to the S-signer. The goal is to use forger F — violating
the tamper-evidence of our scheme — to generate an non-
queried signature valid for S.PK . To achieve this, guess a
time period j(= t2) for which F will fool the Div test, and
6 It is possible to perform the veriﬁcations for i ≥ 1 in
Div instead of in Vf, but this would require changing the
functional deﬁnition to pass the message to Div.
Also, instead of signing each message with all the keys, it
is possible to form a certiﬁcation chain of the keys. This
variant is more eﬃcient: the chain needs not be regenerated
for each signature. Furthermore, the chained construction
achieves the universal indisputability discussed in Section 5.
However, the version in the main text appears slightly sim-
pler to discuss. The security proof for the chained construc-
tion will appear in the full version of the paper.
set Sj .PK ← S.PK . All the other parameters and keys are
generated by the simulator at random. Then the (adaptive)
queries of F can be satisﬁed by the simulator either directly
or with the help of the S-signer oracle.
If F chooses te d
 d, the interval containing
t1, t2 cannot contain such a te which would satisfy α-
synchronicity requirement: |te−min(t1, t2)| > α|t1−t2|.
Thus, these intervals “take care” of the signatures
separated by distances > d and ≤ d(1+β)
bσt2,M2 must use the same public key SI .PK . However,
SI .SK was not created – and thus was not known – at the
time of the latest exposure te. Thus F cannot generate the
SI -signature for SI .PK (i.e., we could reduce forging S sig-
natures to F ’ success).
The 0-, α- and ∞- te schemes of the above sections
can be viewed as such C-schemes: For the 0-te scheme
we used C0 = {{t, t + 1, . . .} for all t}. Our ∞-te scheme
used C∞ = {{t} for all t}. The tree-based schemes use
Ctree = {{i2j, . . . , (i+1)2j − 1} for all j ≥ 0, i > 0}.7
Thus, constructing α-te schemes is reduced to a combina-
torial problem of constructing α-separating collections; the
number of intervals containing t, for each t, corresponds to
the scheme’s cost.
3.3.1 Constructing α-Separating Collections
Fact 1. For any te  α(t2−t1)
and t2 − t1 ≥ d, any interval of size ≤ d(1 + α) containing
t1, t2 cannot also contain te.
Indeed, t1 − te > α(t2 − t1) ≥ αd ⇒ t2 − te > (1 + α)d.
Let β be any constant such that 0  α|t1 − t2|.
For t1, t2 such that |t1 − t2| > d(1 + β) intervals of size
In other words the interval
> d(1 + β)(1 + α) are needed.
lengths can increase by a factor of 1 + β.
def
def
def
= (1 + β)j. Then the
More formally, for level j, let dj
= dj(1+α), separating
corresponding interval length is Lj
= dj(α−
t1, t2 : dj ≤ |t1−t2| ≤ dj(1+β) from te. The shift ∆j
β). The intervals for level are shifted by ∆j , guaranteeing
that each pair t1, t2 as above belongs to some interval of
7The version of Sec. 3.2.2 actually allowed i = 0; though
using it with a balanced hierarchy also bounds t.
If t is
unbounded, then allowing i = 0 leads to each t belonging to
inﬁnite number of intervals and thus to an inﬁnite number of
keys for each time t. The Ctree above eliminates all intervals
containing 0: these cannot help separation of any t1, t2 from
te. This results in each t belonging to only 1 + lg t intervals.
t
e
t
1
t
2
t’2
Figure 2: Tree-based scheme. The common preﬁx of
the paths from root to t1 and t2 is not a preﬁx of the
path from root to te. On the other hand, t1 and t(cid:1)
2 do
not have this property. Thus, after exposure at te, Div
detects divergence for t1 and t2 but not for t1 and t(cid:1)
2.
though a similar (actually even slightly larger) number of
keys is generated by S in t time periods, each KESig signa-
ture must include only O(lg t) of these public S-keys, with a
signature for each (and the signer must store only the corre-
sponding O(lg t) secret S-keys). Moreover, all but one (leaf)
S-signatures are computed only once per period (or even less
frequently) and are simply re-used for each KESig-signature.
Intuitively, this scheme has somewhat looser synchronic-
ity restrictions than the perfectly-synchronous tamper-
evidence:
it detects divergence as long as the paths from
root to t1 and t2 diverge after they diverge from te (or in
other words, the common preﬁx of t1 and t2 is not a preﬁx
of te, see Fig. 2). But it still falls short of the α-te.
Next, we generalize the above tree construction to achieve
α-synchronous tamper-evidence for any constant α.
3.3 Separating Sets and α-TE Schemes
C-schemes. Let C be a collection of contiguous sets (in-
tervals) of integers (time period numbers). Deﬁne a C-
scheme as follows: Let a diﬀerent public/secret key pair
(SI .PK ,SI .SK ) correspond to each interval I ∈ C (the key
pair is generated randomly at the beginning of the interval,
and is destroyed at the end of it). Each C-signature for the
time period t contains (cid:3)SI .PK , σI(cid:4) for all intervals I ∈ C
such that t ∈ I, where σI is the SI -signature generated
using SI .SK . This explains why the intervals I must be
contiguous: if the signer has SI .SK during periods t1  α(t2 − t1), there exists an interval I ∈ C
such that t1, t2 ∈ I but te (cid:15)∈ I.