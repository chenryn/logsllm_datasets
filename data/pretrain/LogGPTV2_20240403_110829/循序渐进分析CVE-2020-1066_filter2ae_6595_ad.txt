### 优化后的文本

#### 代码片段
```c
*(_DWORD *)Version = versionLookUp;
wcscpy_s(&SubKey, 0xDu, &Name);

if (RegOpenKeyW(hKey, &SubKey, &phkResult) == ERROR_SUCCESS)
{
    if (phkResult == hKey)
        hKey = (HKEY)-1;

    v6 = 0;
    // 继续枚举子键
    for (i = RegEnumKeyW(phkResult, 0, &Dst, 0x10u); i == ERROR_SUCCESS; i = RegEnumKeyW(phkResult, v6, &Dst, 0x10u))
    {
        if (FIsLCID(&Dst))
        {
            if (RegOpenKeyW(phkResult, &Dst, &v22) != ERROR_SUCCESS
                || (RegOpenKeyW(v22, L"win32", &v21) != ERROR_SUCCESS && (RegEnumKeyW(v22, 0, &Dst, 6u) != ERROR_SUCCESS || RegOpenKeyW(v22, &Dst, &v21) != ERROR_SUCCESS)))
            {
                break;
            }

            cbData = 520;
            if (RegQueryValueW(v21, 0, &Data, &cbData) != ERROR_SUCCESS)
                break;

            // 找到后加载
            v8 = LoadTypeLib(&Data, &pptlib);
            if (!v8 || v8 >= 0)
            {
                // 根据GUID查找TypeInfo
                v10 = pptlib->lpVtbl->GetTypeInfoOfGuid(pptlib, v12, &v14);
                if (!v10 || v10 >= 0)
                {
                    *v13 = v14;
                    v9 = 0;
                }
            }
            goto LABEL_26;
        }
        ++v6;
    }
}
```

#### 每个TypeLib可以是嵌套的TypeLib结构
每个TypeLib可以是嵌套的TypeLib结构，而加载嵌套的TypeLib也会递归调用`LoadTypeLibEx`。具体构造方法可参考利用工具代码和[微软官方API](https://docs.microsoft.com/en-us/windows/win32/api/oaidl/nn-oaidl-itypelib2)。通过递归加载TypeLib时指定一个不存在的TypeLib文件路径，该路径会被当作一个[Moniker](https://docs.microsoft.com/en-us/windows/win32/api/objidl/nn-objidl-imoniker)来解析。这里使用的是Script Moniker，即`script:xxx.sct`脚本文件。最终，Script Moniker被解析并触发`BindToObject`，以Unmarshal反序列化调用者权限启动Shell。

#### `LoadTypeLibEx`函数
```c
HRESULT __stdcall LoadTypeLibEx(LPCOLESTR szFile, REGKIND regkind, ITypeLib **pptlib)
{
    ...
    ptlib = OLE_TYPEMGR::LookupTypeLib(g_poletmgr, szFile, syskind);
    if (ptlib)
        goto LABEL_31;

    // TypeLib文件路径不存在时
    if (FindTypeLib(szFileNameRef, (LONG*)&szFullPath, v5))
    {
        if (CreateBindCtx(1u, &ppbc) != S_OK)
            goto LABEL_67;

        v8 = SysAllocString(szFileNameRef);
        if (v8)
        {
            // 解析Script Moniker
            stat = MkParseDisplayName(ppbc, v8, &pchEaten, &ppmk);
            SysFreeString(v8);
            if (SUCCEEDED(stat))
            {
                // 启动shell
                stat = ppmk->lpVtbl->BindToObject(ppmk, ppbc, 0, &IID_ITypeLib, (void**)&ptlib);
                ppmk->lpVtbl->Release(ppmk);
            }
        }
    }
    ...
}
```

#### 调试结果
以下是Script Moniker最终创建进程的调试结果：
```
Breakpoint 0 hit
kernel32!CreateProcessW:
0033:00000000`77741bb0 4883ec68        sub     rsp,68h
// 启动的就是exp
0: kd> dc @rdx
00000000`0378b9f8  00430022 002f003a 006c0064 0074002f  ".C.:./.d.l./.t.
00000000`0378ba08  00730065 002f0074 006b006f 004d002f  e.s.t./.o.k./.M.
00000000`0378ba18  00430079 006d006f 006f0045 002e0070  y.C.o.m.E.o.p...
00000000`0378ba28  00780065 00220065 00310020 00000000  e.x.e.". .1.....
00000000`0378ba38  00000000 00000000 00000000 00000000  ................
00000000`0378ba48  00000000 00000000 00000000 00000000  ................
0: kd> kv
 # Child-SP          RetAddr           : Args to Child                                                           : Call Site
00 00000000`0288c3e8 000007fe`ec9ec0dd : 00000000`00000000 000007fe`ec8e1982 00001e9f`9ac2b3f6 00000000`00000000 : kernel32!CreateProcessW
01 00000000`0288c3f0 000007fe`ec9ec55f : 00000000`00000000 00000000`0288c5c0 00000000`0288c788 00000000`0288c5c0 : wshom!CWshShell::CreateShortcut+0x30d
02 00000000`0288c4e0 000007fe`feb616d0 : 00000000`0288c7a0 00000000`002fd46c 00000000`0378b9f8 00000000`00000000 : wshom!CWshShell::Exec+0x2b3
03 00000000`0288c5a0 000007fe`feb624d2 : 00000000`00000104 000007fe`fec008e0 00000000`00000fff 000007fe`feb623b8 : OLEAUT32!DispCallFuncAmd64+0x60
04 00000000`0288c600 000007fe`feb61de1 : 00000000`0366c2b8 00000000`037cd3f8 00000000`037806c0 00000000`0288c768 : OLEAUT32!DispCallFunc+0x268
05 00000000`0288c6b0 000007fe`ec9e12d5 : 00000000`002f60d0 000007fe`feb6150c 00000000`03796ee0 00000000`00000002 : OLEAUT32!CTypeInfo2::Invoke+0x39a
06 00000000`0288ca20 000007fe`ec9e121d : 00000000`00000bc4 000007fe`ebf5d79e 00000000`00000000 000007fe`ff8724c8 : wshom!CDispatch::Invoke+0xad
07 00000000`0288ca80 000007fe`ebf7ad24 : 00000000`00001f80 00000000`00000bc4 00000000`0288e560 00000000`002ffbc0 : wshom!CWshExec::Invoke+0x4d
08 00000000`0288cae0 000007fe`ebf79dc7 : 00000000`00000000 00000000`002ffbc0 00000000`00000000 00000000`001758b0 : jscript!CScriptRuntime::Run+0x2e1d
09 00000000`0288e4f0 000007fe`ebf79c09 : 00000000`00000000 00000000`0017c6b0 00000000`00000000 00000000`00000000 : jscript!ScrFncObj::CallWithFrameOnStack+0x187
0a 00000000`0288e700 000007fe`ebf79a25 : 00000000`001758b0 00000000`00000000 00000000`001758b0 00000000`00000000 : jscript!ScrFncObj::Call+0xb5
0b 00000000`0288e7a0 000007fe`ebf7903b : 00000000`0008001f 00000000`001758b0 00000000`00000000 00000000`002f6660 : jscript!CSession::Execute+0x1a5
0c 00000000`0288e890 000007fe`ebf79386 : 00000000`00000000 00000000`001758b0 00000000`00000000 ffffffff`ffffffff : jscript!COleScript::ExecutePendingScripts+0x223
0d 00000000`0288e960 000007fe`eca17186 : 00000000`00000000 000007fe`eca17f9d 00000000`002fc410 01d61e99`4640f6a8 : jscript!COleScript::SetScriptState+0x6e
0e 00000000`0288e990 000007fe`eca17004 : 00000000`002fc400 00000000`002fc400 00000000`002f3ce0 00000000`002f3ce0 : scrobj!ComScriptlet::Inner::StartEngines+0xcf
0f 00000000`0288e9f0 000007fe`eca16dc1 : 00000000`002c95e0 00000000`002fc400 00000000`002f3ce0 000007fe`ff687a01 : scrobj!ComScriptlet::Inner::Init+0x27a
10 00000000`0288ea90 000007fe`eca16caa : 00000000`002f3ce0 00000000`00000000 00000000`00000000 00000000`00000000 : scrobj!ComScriptlet::New+0xca
11 00000000`0288eac0 000007fe`eca220f3 : 00000000`002f62a0 00000000`00249618 00000000`002ce680 00000000`037143d8 : scrobj!ComScriptletConstructor::Create+0x68
12 00000000`0288eb10 000007fe`ff6678d6 : 00000000`03798760 00000000`03718760 00000000`037da9c0 000007fe`fee9b065 : scrobj!ComScriptletMoniker::BindToObject+0x7f
13 00000000`0288eb60 000007fe`ff5669ba : 000007fe`ff68be00 000007fe`ff6608bd 00000000`00000030 000007fe`ff68be30 : ole32!IMoniker_BindToObject_Stub+0x16 [d:w7rtmcomole32oleprx32proxycall_as.c @ 2264] 
14 00000000`0288eba0 000007fe`fee9bc86 : 00000000`00000005 00000000`03718760 000007fe`ff687a18 00000000`037da9c0 : ole32!IMoniker_RemoteBindToObject_Thunk+0x2a [o:w7rtm.obj.amd64frecomole32oleprx32proxydaytonaobjfreamd64mega_p.c @ 487] 
15 00000000`0288ebe0 000007fe`fedf48d6 : 00000000`0288f248 000007fe`ff66376f 00000000`03715700 00000000`0379a2a0 : RPCRT4!Ndr64AsyncServerCallAll+0x1806
16 00000000`0288f1a0 000007fe`ff660883 : 00000000`00000000 00000000`00000000 000007fe`ff695b80 00000000`03715ea0 : RPCRT4!NdrStubCall3+0xc6
17 00000000`0288f200 000007fe`ff660ccd : 00000000`00000001 00000000`00000000 00000000`00000000 00000000`00000000 : ole32!CStdStubBuffer_Invoke+0x5b [d:w7rtmcomrpcndrolestub.cxx @ 1586] 
18 00000000`0288f230 000007fe`ff660c43 : 00000000`037da9c0 00000000`0579cb14 00000000`036ce730 000007fe`eca36a40 : ole32!SyncStubInvoke+0x5d [d:w7rtmcomole32comdcomremchannelb.cxx @ 1187] 
19 00000000`0288f2a0 000007fe`ff51a4f0 : 00000000`037da9c0 00000000`0361e890 00000000`037da9c0 00000000`00000178 : ole32!StubInvoke+0xdb [d:w7rtmcomole32comdcomremchannelb.cxx @ 1396] 
1a 00000000`0288f350 000007fe`ff52d551 : 00000000`00000000 00000000`00000001 00000000`0376e9e0 00000000`03715ea0 : ole32!CCtxComChnl::ContextInvoke+0x190 [d:w7rtmcomole32comdcomremctxchnl.cxx @ 1262] 
1b 00000000`0288f4e0 000007fe`ff66347e : 00000000`0361e890 00000000`00000000 00000000`03718760 00000000`00000000 : ole32!STAInvoke+0x91 [d:w7rtmcomole32comdcomremcallctrl.cxx @ 1923] 
1c 00000000`0288f530 000007fe`ff66122b : 00000000`d0908070 00000000`0361e890 00000000`01d93e30 00000000`03718760 : ole32!AppInvoke+0x1aa [d:w7rtmcomole32comdcomremchannelb.cxx @ 1081] 
1d 00000000`0288f5a0 000007fe`ff663542 : 00000000`037da930 00000000`00000400 00000000`00000000 00000000`01d98a30 : ole32!ComInvokeWithLockAndIPID+0x52b [d:w7rtmcomole32comdcomremchannelb.cxx @ 1727] 
1e 00000000`0288f730 000007fe`ff52d42d : 00000000`03715ea0 00000000`00000000 00000000`0378f190 00000000`037da930 : ole32!ComInvoke+0xae [d:w7rtmcomole32comdcomremchannelb.cxx @ 1469] 
1f 00000000`0288f760 000007fe`ff52d1d6 : 00000000`0361e890 00000000`037da938 00000000`00000400 00000000`00000000 : ole32!ThreadDispatch+0x29 [d:w7rtmcomole32comdcomremchancont.cxx @ 298] 
20 00000000`0288f790 00000000`77639bd1 : 00000000`00000000 00000000`00000000 00000000`00000000 b2698378`e8b9daaa : ole32!ThreadWndProc+0xaa [d:w7rtmcomole32comdcomremchancont.cxx @ 654] 
21 00000000`0288f810 00000000`776398da : 00000000`0288f970 000007fe`ff52d12c 000007fe`ff6c5780 00000000`006c4200 : USER32!UserCallWinProcCheckWow+0x1ad
22 00000000`0288f8d0 000007fe`ff52d0ab : 00000000`000b0098 00000000`000b0098 000007fe`ff52d12c 00000000`00000000 : USER32!DispatchMessageWorker+0x3b5
23 00000000`0288f950 000007fe`ff653e57 : 00000000`0361e890 00000000`00000000 00000000`0361e890 000007fe`ff513032 : ole32!CDllHost::STAWorkerLoop+0x68 [d:w7rtmcomole32comobjactdllhost.cxx @ 957] 
24 00000000`0288f9b0 000007fe`ff500106 : 00000000`0361e890 00000000`036d6510 00000000`00000000 00000000`00000000 : ole32!CDllHost::WorkerThread+0xd7 [d:w7rtmcomole32comobjactdllhost.cxx @ 834] 
25 00000000`0288f9f0 000007fe`ff500182 : 00000000`00000000 00000000`00000000 00000000`00000000 00000000`00000000 : ole32!CRpcThread::WorkerLoop+0x1e [d:w7rtmcomole32comdcomremthreads.cxx @ 257] 
26 00000000`0288fa30 00000000`7773652d : 00000000`00000000 00000000`00000000 00000000`00000000 00000000`00000000 : ole32!CRpcThreadCache::RpcWorkerThreadEntry+0x1a [d:w7rtmcomole32comdcomremthreads.cxx @ 63] 
27 00000000`0288fa60 00000000`7786c521 : 00000000`00000000 00000000`00000000 00000000`00000000 00000000`00000000 : kernel32!BaseThreadInitThunk+0xd
28 00000000`0288fa90 00000000`00000000 : 00000000`00000000 00000000`00000000 00000000`00000000 00000000`00000000 : ntdll!RtlUserThreadStart+0x21
```

#### 我的漏洞利用工具测试方式
需要管理员权限运行：

1. 只适用于Windows 7系统直接运行，无参数，替换默认TypeLib：
   ```
   MyComEop.exe
   ```

2. 替换指定接口TypeLib文件路径的Com组件TypeLib，例如`C:\xxx.dll`：
   ```
   MyComEop.exe [u] [TypeLib_Path]
   ```

3. 替换指定接口IID的Com组件TypeLib，例如`{55e3ea25-55cb-4650-8887-18e8d30bb4bc}`：
   ```
   MyComEop.exe [u] [IID_Interface]
   ```

4. 高级模式：接口IID=[IID_Interface]，接口名称=[InterfaceName]，接口的TypeLib_GUID=[TypeLib_GUID_Interface]，接口TypeLib文件路径=[TypeLib_Path]：
   ```
   MyComEop.exe [u] [IID_Interface] [InterfaceName] [TypeLib_GUID_Interface] [TypeLib_Path]
   ```

5. 不替换文件，仅测试指定接口IID的Com组件TypeLib利用，例如`{55e3ea25-55cb-4650-8887-18e8d30bb4bc}`：
   ```
   MyComEop.exe [t] [IID_Interface]
   ```

#### 运行效果
出于安全因素考虑，笔者无法提供完整的Exp项目代码。有兴趣的读者可以通过代码片段自己尝试还原完整Exp。以下是笔者Exp运行的效果（见图）。

#### 相关项目
- [Windows CardSpace服务反编译工程](https://gitee.com/cbwang505/Windows_CardSpace_Service)
- [我的ole32逆向工程](https://gitee.com/cbwang505/MyOle32ReverseEngineering)
- [我的漏洞利用工具](https://gitee.com/cbwang505/TypeLibUnmarshaler)
- [符号链接工具](https://github.com/googleprojectzero/symboliclink-testing-tools)

#### 相关引用
- [CVE-2020-1066](https://portal.msrc.microsoft.com/en-us/security-guidance/advisory/CVE-2020-1066)

#### 参与贡献
作者来自ZheJiang Guoli Security Technology，邮箱：[PI:EMAIL](mailto:PI:EMAIL)