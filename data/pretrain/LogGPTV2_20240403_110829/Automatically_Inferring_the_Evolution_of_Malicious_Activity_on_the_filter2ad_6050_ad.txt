### Optimized Text

The runtime per IP is \(O(\log k)\). In Step 4, we compare each pair of prefixes in \(T_{\text{old},z}\) and \(T_{\text{old},z-1}\), resulting in a runtime of \(O(k)\). In Step 5, we examine potential \(\Delta\)-change prefixes along with their parents, leading to a runtime bounded by \(O(k \log k)\). For Step 6, we examine each potential \(\Delta\)-change prefix along with its children subtrees in \(T_{\text{curr}}\). Since \(T_{\text{curr}}\) is a \(k\)-IPtree, the runtime is bounded by \(O(k)\). Therefore, the total runtime of the \(\Delta\)-Change algorithm for an input sequence of length \(n\) is \(O(n \log k + k \log k)\).

**Accuracy Note:**
By design, every \(\Delta\)-change prefix discovered is guaranteed to reflect a change in the IPs between the sequences \(s_z\) and \(s_{z-1}\). If a prefix has a high classification error in \(T_{\text{old},z}\) and a low classification error in \(T_{\text{old},z-1}\), then that prefix indeed originates different types of traffic in \(s_{z-1}\) compared to \(s_z\). Thus, the \(\Delta\)-Change algorithm will have no false positives (though it may not find all \(\Delta\)-change prefixes, as \(T_{\text{curr}}\) and \(T_{\text{old}}\) are approximate).

### 3.3 The \(\Delta\)-Motion Algorithm

In this section, we address the second question posed in our problem: What regions of the Internet are prone to frequent changes? The answer helps us pinpoint structural properties of the \(\Delta\)-change prefixes.

A straightforward approach might be to use the \(\Delta\)-change prefixes output by \(\Delta\)-Change. However, as described in Section 3.2, this list may be incomplete: \(\Delta\)-Change can only ensure that every identified prefix is truly a \(\Delta\)-change prefix (i.e., no false positives), but not that every \(\Delta\)-change prefix is discovered (i.e., there may be false negatives). Nevertheless, we can exploit additional information from the structure of the learned IPtree \(T_{\text{old}}\) and the input data sequence \(s_z\).

To answer our question, we need to partition the IP address space into regions that change quickly and regions that change slowly. We observe that this problem can be modeled as another instance of learning an IPtree—specifically, a decision tree over the IP address space where the leaf labels denote "change" or "no change," rather than "malicious" or "non-malicious." We define this IPtree as a change-IPTree; Figure 10 shows an example. If we get access to IPs labeled with "change" or "no change" (rather than "malicious" or "non-malicious"), we can directly use TrackIPTree to solve this problem.

Recall that \(s_z\) denotes the part of the stream that appears in interval \(z\). \(\Delta\)-Motion uses the IPtree \(T_{z-1}\) to annotate each IP \(i\) in \(s_z\). If the label of IP \(i\) matches the prediction of \(T_{z-1}\), it pairs IP \(i\) with the label "no change"; otherwise, it pairs the IP with the label "change." This results in a new stream \(s'_z\) derived from \(s_z\), where the label of each IP is "change" or "no change." Next, we apply TrackIPTree on this new stream, and the resulting change-IPtree differentiates prefixes that change frequently from those that do not. We use \(W_z\) to denote this change-IPtree built on the stream \(s'_z\) of IPs labeled with "change" or "no change." Even though the IPtree \(T_{z-1}\) used to generate the new labels is approximate, it typically has very high accuracy, so the new stream will generally have only a little noise. The space and runtime complexity of \(\Delta\)-Motion are identical to TrackIPTree: its data structure uses only three IPTrees (a change-IPTree and two regular IPTrees); each step of \(\Delta\)-Motion applies a part of TrackIPTree, and the different parts of TrackIPTree are applied three times in \(\Delta\)-Motion.

### 4 Experimental Results

**Data:**

Our first dataset uses spam as the source of malicious activity. The data is collected from the operational mailservers of a tier-1 ISP, which handle mail for over 8 million subscribers. Data was collected in two periods: from mid-April to mid-August 2010 (120 days) and from mid-June to late July 2012 (41 days). The dataset includes the IP addresses of the senders' mail servers and the number of spam and legitimate messages sent in a 5-minute interval. We use the mailserver's spam-filtering system (Brightmail) to label IP addresses; a single IP address can be labeled as malicious at one point and non-malicious at another. In total, the IP addresses in our data have sent over 5.3 billion spam and 310 million legitimate messages. While the data may have some noise in labeling, the algorithm is adaptive and noise-tolerant, so a small fraction of inaccurate labels will not significantly impact the tree.

Our second dataset is based on botnet activity from October 2011 to January 2012. We obtain a distribution of active IP addresses across the Internet by collecting daily snapshots of flows sampled from IP backbone traffic. Our monitoring points cover 80% of the traffic carried by the IP backbone. On any given day, our data includes 24-28 million unique IP addresses. We use botnet activity to label these IP addresses as malicious or non-malicious. Specifically, we obtain a daily snapshot of IP addresses within a tier-1 ISP that are part of a botnet, as identified by the ISP's security vendors. These vendors use a combination of monitoring algorithms, sinkholes, spam traps, and malware binary analysis to identify and track bot IP addresses. The daily snapshot includes all bot IPs observed on that particular day. The botnet feed contains around 30,000-100,000 unique IP addresses daily, totaling over 2.64 million unique bot IP addresses across 94 days. An IP address is labeled as malicious on day \(i\) if it appears in the botnet feed on day \(i\). As in the spam dataset, any noise in the input data stream will be carried over to our results, but the adaptive nature of the algorithm ensures that a small amount of noise will not have a long-term impact on the tree.

Our results demonstrate that our algorithms can discover many changes in the Internet's malicious activity, outperforming alternative approaches. The exact \(\Delta\)-change prefixes detected are specific to our datasets, and for confidentiality reasons, we anonymize the owning entities of all the prefixes in the results. Our results show two examples of how our algorithm can be applied to real datasets from operational networks, discovering changes that operators were previously unaware of.

**Experiment Setup:**

Throughout our experiments, we keep the algorithm parameters fixed. We set \(\epsilon = 0.05\), following [29]. We use IPtrees of size \(k = 100,000\) for spam data and \(k = 50,000\) for botnet data, as they make accurate predictions on the input stream, and a further increase in \(k\) does not substantially increase the tree's accuracy. We measure the accuracy of our algorithms on a per-IP basis (following [29]), and the accuracy of our constructed IPtrees is similar to [29]. All our change-detection experiments are performed on day-length intervals, i.e., each of the three trees is built, tested, and compared across different days. We use three states for the prefixes, split by legitimate-ratio thresholds: \([0, 0.33)\), \([0.33, 0.75)\), and \([0.75, 1]\). We term these states "bad," "neutral," and "good," respectively. A prefix state is assigned as "good" if it sends at least 75% non-malicious traffic, "neutral" if it sends 33%-75% non-malicious traffic, and "bad" if it sends less than 33% non-malicious traffic. With these thresholds, we derive \(\gamma = 33\%\). We set allowable error \(\tau = 5\%\) and the minimum traffic needed \(\theta = 0.01\%\) and \(0.05\%\). We chose these values for \(\tau\) and \(\theta\) because in our experiments, we can obtain a list of \(\Delta\)-change prefixes that is small enough to be manually analyzed and yet large enough to discover interesting trends across our datasets. Our parameters remain stable throughout our dataset when analyzing changes across day-long intervals. As operator resources allow, these parameters can be changed to allow for the discovery of either more fine-grained changes (e.g., with smaller \(\theta\) or larger values of \(k\)) or more coarse-grained changes. Our experiments were run on a 2.4GHz Sparc64-VI core. Our current (unoptimized) implementation takes 20-22 minutes to process a day's trace (around 30-35 million IP addresses) and requires less than 2-3 MB of memory storage.

We note that the ground truth in our data provides labels for individual IP addresses but does not tell us the prefixes that have changed. Thus, our ground truth allows us to confirm that the learned IPtree has high accuracy, but we cannot directly measure the false positive rate and false negative rate of the change-detection algorithms. Our experimental results instead demonstrate that our algorithm can find small changes in prefix behavior very early on real data, outperforming competing approaches. Our operators were previously unaware of most of these \(\Delta\)-change prefixes, and our summarization makes it easy for operators to both note changes in the behavior of specific entities and observe trends in malicious activity.

### 4.1 Comparisons with Alternate Approaches

We first compare \(\Delta\)-Change with previous approaches and direct extensions to previous work. We compare two possible alternate approaches with \(\Delta\)-Change: (1) using a fixed set of network-based prefixes (i.e., network-aware clusters, see Sec. 2.2) instead of a customized IPtree, (2) directly differencing the IPtrees instead of using \(\Delta\)-Change. We focus here on only spam data for space reasons.

**Network-aware Clusters:**

As described in Section 3.2, our change-detection approach has no false positives—every change we find will indeed be a change in the input data stream. Thus, we only need to demonstrate that \(\Delta\)-Change finds substantially more \(\Delta\)-changes than network-aware clusters (i.e., has a lower false negative rate) and is therefore superior at summarizing changes in malicious activity to the appropriate prefixes for operator attention.

We follow the methodology of [29] for labeling the prefixes of the network-aware clusters optimally (i.e., we choose the labeling that minimizes errors) to test the best possible performance of network-aware clusters against \(\Delta\)-Change. We do this allowing the network-aware clusters multiple passes over the IP addresses (even though \(\Delta\)-Change is allowed only a single pass), as detailed in [29]. We then use these clusters in place of the learned IPtree in our change-detection algorithms.

We first compare \(\Delta\)-change prefixes identified by the network-aware clustering and \(\Delta\)-Change. This comparison cannot be directly on the prefixes output by the two approaches, as slightly different prefixes may reflect the same underlying change in the data stream, e.g., network-aware clusters might identify a /24 while \(\Delta\)-Change identifies a /25.

To account for such differences, we group together prefixes into distinct subtrees and match a group from the network-aware clustering to the appropriate group from \(\Delta\)-Change if at least 50% of the volume of changed IPs in network-aware clustering was accounted for in \(\Delta\)-Change. In our results, network-aware clustering identified no \(\Delta\)-change prefixes that were not identified by \(\Delta\)-Change; otherwise, we would have done the reverse matching as well. This allows us to compare the number of \(\Delta\)-changes identified by both algorithms. Figure 11(a) shows the results of our comparison for 37 days. Network-aware clustering typically finds only a small fraction of the \(\Delta\)-change prefixes discovered by \(\Delta\)-Change, ranging from 10% to 50%. On average, \(\Delta\)-Change finds over 2.5 times as many \(\Delta\)-change prefixes as network-aware clusters. Figure 11(b) compares the number of IPs in \(\Delta\)-change prefixes identified by the network-aware clustering and \(\Delta\)-Change. The \(\Delta\)-change prefixes discovered by \(\Delta\)-Change typically account for a factor of 3-5× IP addresses compared to network-aware clusters.