related to it through OpenID Connect Discovery), the OpenID Connect relying party still 
needs to have a client ID and a client secret (not under the implicit grant type) registered 
at the OpenID provider to initiate the authorization grant request or the OpenID 
Connect authentication request. The OpenID Connect Dynamic Client Registration 
specification2 facilitates a mechanism to register dynamically OpenID Connect relying 
parties at the OpenID provider. 
The response from the OpenID provider metadata endpoint includes the endpoint 
for client registration under the parameter registration_endpoint. To support dynamic 
client registrations, this endpoint should accept open registration requests, with no 
authentication requirements.
2 http://openid.net/specs/openid-connect-registration-1_0.html
CHAPTEr 6  OPEnID COnnECT (OIDC)
152
To fight against denial of service (DoS) attacks, the endpoint can be protected with 
rate limits or with a web application firewall (WAF). To initiate client registration, the 
OpenID relying party sends an HTTP POST message to the registration endpoint with its 
own metadata.
The following is a sample client registration request:
POST /connect/register HTTP/1.1
Content-Type: application/json
Accept: application/json
Host: auth.server.com
{
"application_type":"web",
"redirect_uris":["https://app.client.org/callback","https://app.client.org/
callback2"],
"client_name":"Foo",
"logo_uri":"https://app.client.org/logo.png",
"subject_type":"pairwise",
"sector_identifier_uri":"https://other.client.org /file_of_redirect_uris.
json",
"token_endpoint_auth_method":"client_secret_basic",
"jwks_uri":"https://app.client.org/public_keys.jwks",
"userinfo_encrypted_response_alg":"RSA1_5",
"userinfo_encrypted_response_enc":"A128CBC-HS256",
"contacts":["PI:EMAIL", "PI:EMAIL"],
"request_uris":["https://app.client.org/rf.txt#qpXaRLh_
n93TTR9F252ValdatUQvQiJi5BDub2BeznA"]
}
In response, the OpenID Connect provider or the authorization server sends back 
the following JSON message. It includes a client_id and a client_secret:
HTTP/1.1 201 Created
Content-Type: application/json
Cache-Control: no-store
Pragma: no-cache
{
"client_id":"Gjjhj678jhkh89789ew",
CHAPTEr 6  OPEnID COnnECT (OIDC)
153
"client_secret":"IUi989jkjo_989klkjuk89080kjkuoikjkUIl",
"client_secret_expires_at":2590858900,
"registration_access_token":"this.is.an.access.token.value.ffx83",
"registration_client_uri":"https://auth.server.com/connect/register?client_
id=Gjjhj678jhkh89789ew ",
"token_endpoint_auth_method":"client_secret_basic",
"application_type": "web",
"redirect_uris":["https://app.client.org/callback","https://app.client.org/
callback2"],
"client_name":"Foo",
"logo_uri":"https://client.example.org/logo.png",
"subject_type":"pairwise",
"sector_identifier_uri":"https://other.client.org/file_of_redirect_uris.
json",
"jwks_uri":"https://app.client.org/public_keys.jwks",
"userinfo_encrypted_response_alg":"RSA1_5",
"userinfo_encrypted_response_enc":"A128CBC-HS256",
"contacts":["PI:EMAIL", "PI:EMAIL"],
"request_uris":["https://app.client.org/rf.txt#qpXaRLh_
n93TTR9F252ValdatUQvQiJi5BDub2BeznA"]
}
Once the OpenID Connect relying party obtains a client ID and a client secret, it 
concludes the OpenID Connect Discovery phase. The relying party can now initiate the 
OpenID Connect authentication request.
Note Section 2.0 of the OpenID Connect Dynamic Client registration 
specification lists all the attributes that can be included in an OpenID Connect 
client registration request: http://openid.net/specs/openid-connect- 
registration-1_0.html.
 OpenID Connect for Securing APIs
So far, you have seen a detailed discussion about OpenID Connect. But in reality, how 
will it help you in securing APIs? The end users can use OpenID Connect to authenticate 
CHAPTEr 6  OPEnID COnnECT (OIDC)
154
into web applications, mobile applications, and much more. Nonetheless, why would 
you need OpenID Connect to secure a headless API? At the end of the day, all the APIs 
are secured with OAuth 2.0, and you need to present an access token to talk to the 
API. The API (or the policy enforcement component) validates the access token by 
talking to the authorization server. Why would you need to pass an ID token to an API?
OAuth is about delegated authorization, whereas OpenID Connect is about 
authentication. An ID token is an assertion about your identity, that is, a proof of your 
identity. It can be used to authenticate into an API. As of this writing, no HTTP binding is 
defined for JWT. 
The following example suggests passing the JWT assertion (or the ID token) to a 
protected API as an access token in the HTTP Authorization header. The ID token, or the 
signed JWT, is base64-url-encoded in three parts. Each part is separated by a dot (.). The 
first part up to the first dot is the JWT header. The second part is the JWT body. The third 
part is the signature. Once the JWT is obtained by the client application, it can place it in 
the HTTP Authorization header in the manner shown here:
POST /employee HTTP/1.1
Content-Type: application/json
Accept: application/json
Host: resource.server.com
Authorization: Bearer eyJhbGciOiljiuo98kljlk2KJl.
IUojlkoiaos298jkkdksdosiduIUiopo.oioYJ21sajds
{
   "empl_no":"109082",
   "emp_name":"Peter John",
   "emp_address":“Mountain View, CA, USA”
}
To validate the JWT, the API (or the policy enforcement component) has to extract 
the JWT assertion from the HTTP Authorization header, base64-url-decode it, and 
validate the signature to see whether it’s signed by a trusted issuer. In addition, the 
claims in the JWT can be used for authentication and authorization.
CHAPTEr 6  OPEnID COnnECT (OIDC)
155
Note When an OpenID Connect identity provider issues an ID token, it adds the 
aud parameter to the token to indicate the audience of the token. This can be an 
array of identifiers. 
When using ID tokens to access APIs, a UrI known to the API should also be added 
to the aud parameter. Currently this can’t be requested in the OpenID Connect 
authentication request, so it must be set out of band at the OpenID Connect identity 
provider.
 Summary
• 
OpenID Connect was built on top of OAuth 2.0. It introduces an 
identity layer on top of OAuth 2.0. This identity layer is abstracted 
into an ID token, which is a JSON Web Token (JWT).
• 
OpenID Connect evolved from OpenID to an OAuth 2.0 profile.
• 
The OpenID Connect Dynamic Client Registration specification 
facilitates a mechanism to register dynamically OpenID Connect 
relying parties at the OpenID provider.
• 
OpenID Connect defines two ways to request user attributes. 
The client application can either use the initial OpenID Connect 
authentication request to request attributes or else later talk to the 
UserInfo endpoint hosted by the authorization server. 
• 
OpenID Connect utilizes the WebFinger protocol in its discovery 
process along with OpenID Connect dynamic client registration and 
identity provider metadata configuration.
• 
An OpenID Connect identity provider, which supports metadata 
discovery, should host its configuration at the endpoint  /.well- 
known/openid-configuration.
CHAPTEr 6  OPEnID COnnECT (OIDC)
157
© Prabath Siriwardena 2020 
P. Siriwardena, Advanced API Security, https://doi.org/10.1007/978-1-4842-2050-4_7
CHAPTER 7
Message-Level Security 
with JSON Web Signature
JavaScript Object Notation (JSON) provides a way of exchanging data in a language- 
neutral, text-based, and lightweight manner. It was originally derived from the 
ECMAScript programming language. JSON and XML are the most commonly used data 
exchange formats for APIs. Observing the trend over the last few years, it’s quite obvious 
that JSON is replacing XML. Most of the APIs out there have support for JSON, and some 
support both JSON and XML. XML-only APIs are quite rare.
 Understanding JSON Web Token (JWT)
JSON Web Token (JWT) defines a container to transport data between interested parties 
in JSON. It became an IETF standard in May 2015 with the RFC 7519. The OpenID 
Connect specification, which we discussed in Chapter 6, uses a JWT to represent the ID 
token. Let’s examine an OpenID Connect ID token returned from the Google API, as an 
example (to understand JWT, you do not need to know about OpenID Connect):
eyJhbGciOiJSUzI1NiIsImtpZCI6Ijc4YjRjZjIzNjU2ZGMzOTUzNjRmMWI2YzAyOTA3
NjkxZjJjZGZmZTEifQ.eyJpc3MiOiJhY2NvdW50cy5nb29nbGUuY29tIiwic3ViIjoiMT
EwNTAyMjUxMTU4OTIwMTQ3NzMyIiwiYXpwIjoiODI1MjQ5ODM1NjU5LXRlOHF
nbDcwMWtnb25ub21ucDRzcXY3ZXJodTEyMTFzLmFwcHMuZ29vZ2xldXNlcmNvb
nRlbnQuY29tIiwiZW1haWwiOiJwcmFiYXRoQHdzbzIuY29tIiwiYXRfaGFzaCI6InpmO
DZ2TnVsc0xCOGdGYXFSd2R6WWciLCJlbWFpbF92ZXJpZmllZCI6dHJ1ZSwiYXVkI
joiODI1MjQ5ODM1NjU5LXRlOHFnbDcwMWtnb25ub21ucDRzcXY3ZXJodTEyMTFz
LmFwcHMuZ29vZ2xldXNlcmNvbnRlbnQuY29tIiwiaGQiOiJ3c28yLmNvbSIsImlhdCI6
MTQwMTkwODI3MSwiZXhwIjoxNDAxOTEyMTcxfQ.TVKv-pdyvk2gW8sGsCbsnkq
158
srS0T-H00xnY6ETkIfgIxfotvFn5IwKm3xyBMpy0FFe0Rb5Ht8AEJV6PdWyxz8rMgX
2HROWqSo_RfEfUpBb4iOsq4W28KftW5H0IA44VmNZ6zU4YTqPSt4TPhyFC9fP2D
_Hg7JQozpQRUfbWTJI
Note Way before JWT, in 2009, Microsoft introduced Simple Web Token (SWT).1 
It is neither JSON nor XML. It defined its own token format to carry out a set 
of HTML form–encoded name/value pairs. Both JWTs and SWTs define a way 
to carry claims between applications. In SWT, both the claim names and claim 
values are strings, while in JWT claim names are strings, but claim values can be 
any JSON type. Both of these token types offer cryptographic protection for their 
content: SWTs with HMAC SHA256 and JWTs with a choice of algorithms, including 
signature, MAC, and encryption algorithms. Even though SWT was developed as a 
proposal for IETF, it never became an IETF proposed standard. Dick Hardt was the 
editor of the SWT specification, who also played a major role later in building the 
OAuth WRAP specification, which we discuss in Appendix B.
 JOSE Header
The preceding JWT has three main elements. Each element is base64url-encoded and 
separated by a period (.). Appendix E explains how base64url encoding works in detail. 
Let’s identify each individual element in the JWT. The first element of the JWT is called 
the JavaScript Object Signing and Encryption (JOSE) header. The JOSE header lists out 
the properties related to the cryptographic operations applied on the JWT claims set 
(which we explain later in this chapter). The following is the base64url-encoded JOSE 
header of the preceding JWT:
eyJhbGciOiJSUzI1NiIsImtpZCI6Ijc4YjRjZjIzNjU2ZGMzOTUzNjRmMWI2YzAyOTA3
NjkxZjJjZGZmZTEifQ
To make the JOSE header readable, we need to base64url-decode it. The following 
shows the base64url-decoded JOSE header, which defines two attributes, the algorithm 
(alg) and key identifier (kid).
{"alg":"RS256","kid":"78b4cf23656dc395364f1b6c02907691f2cdffe1"}
1 Simple Web Token, http://msdn.microsoft.com/en-us/library/hh781551.aspx
CHAPTER 7  MESSAgE-LEvEL SECuRITy WITH JSON WEB SIgNATuRE
159
Both the alg and kid parameters are not defined in the JWT specification, but 
in the JSON Web Signature (JWS) specification. Let’s briefly identify here what these 
parameters mean and will discuss in detail when we explain JWS. The JWT specification 
is not bound to any specific algorithm. All applicable algorithms are defined under 
the JSON Web Algorithms (JWA) specification, which is the RFC 7518. Section 3.1 of 
RFC 7518 defines all possible alg parameter values for a JWS token. The value of the 
kid parameter provides an indication or a hint about the key, which is used to sign the 
message. Looking at the kid, the recipient of the message should know where to look up 
for the key and find it. The JWT specification only defines two parameters in the JOSE 
header; the following lists out those:
• 
typ (type): The typ parameter is used to define the media type of the 
complete JWT. A media type is an identifier, which defines the format 
of the content, transmitted over the Internet. There are two types of 
components that process a JWT: the JWT implementations and JWT 
applications. Nimbus2 is a JWT implementation in Java. The Nimbus 
library knows how to build and parse a JWT. A JWT application can 
be anything, which uses JWTs internally. A JWT application uses a 
JWT implementation to build or parse a JWT. The typ parameter 
is just another parameter for the JWT implementation. It will not 
try to interpret the value of it, but the JWT application would. The 
typ parameter helps JWT applications to differentiate the content 
of the JWT when the values that are not JWTs could also be present 
in an application data structure along with a JWT object. This is an 
optional parameter, and if present for a JWT, it is recommended to 
use JWT as the media type.
• 
cty (content type): The cty parameter is used to define the structural 
information about the JWT. It is only recommended to use this 
parameter in the case of a nested JWT. The nested JWTs are discussed 
in Chapter 8, and the definition of the cty parameter is further 
explained there.
2 Nimbus JWT Java implementation, http://connect2id.com/products/nimbus-jose-jwt
CHAPTER 7  MESSAgE-LEvEL SECuRITy WITH JSON WEB SIgNATuRE
160
 JWT Claims Set
The second element of the JWT is known as either the JWT payload or the JWT claims 
set. It is a JSON object, which carries the business data. The following is the base64url-
encoded JWT claims set of the preceding JWT (which is returned from the Google API); 
it includes information about the authenticated user:
eyJpc3MiOiJhY2NvdW50cy5nb29nbGUuY29tIiwic3ViIjoiMTEwNTAyMjUxMTU4OT
IwMTQ3NzMyIiwiYXpwIjoiODI1MjQ5ODM1NjU5LXRlOHFnbDcwMWtnb25ub21uc
DRzcXY3ZXJodTEyMTFzLmFwcHMuZ29vZ2xldXNlcmNvbnRlbnQuY29tIiwiZW1ha
WwiOiJwcmFiYXRoQHdzbzIuY29tIiwiYXRfaGFzaCI6InpmODZ2TnVsc0xCOGdGYX
FSd2R6WWciLCJlbWFpbF92ZXJpZmllZCI6dHJ1ZSwiYXVkIjoiODI1MjQ5ODM1NjU
5LXRlOHFnbDcwMWtnb25ub21ucDRzcXY3ZXJodTEyMTFzLmFwcHMuZ29vZ2xld
XNlcmNvbnRlbnQuY29tIiwiaGQiOiJ3c28yLmNvbSIsImlhdCI6MTQwMTkwODI3MS
wiZXhwIjoxNDAxOTEyMTcxfQ
To make the JWT claims set readable, we need to base64url-decode it. The following 
shows the base64url-decoded JWT claims set. Whitespaces can be explicitly retained 
while building the JWT claims set—no canonicalization is required before base64url-
encoding. Canonicalization is the process of converting different forms of a message 
into a single standard form. This is used mostly before signing XML messages. In XML, 
the same message can be represented in different forms to carry the same meaning. 
For example,  and  are 
equivalent in meaning, but have two different canonical forms. Before signing an XML 
message, you should follow a canonicalization algorithm to build a standard form.
{
     "iss":"accounts.google.com",
     "sub":"110502251158920147732",
      "azp":"825249835659-te8qgl701kgonnomnp4sqv7erhu1211s.apps.
googleusercontent.com",
     "email":"PI:EMAIL",
     "at_hash":"zf86vNulsLB8gFaqRwdzYg",
     "email_verified":true,
      "aud":"825249835659-te8qgl701kgonnomnp4sqv7erhu1211s.apps.
googleusercontent.com",
CHAPTER 7  MESSAgE-LEvEL SECuRITy WITH JSON WEB SIgNATuRE
161
     "hd":"wso2.com",
     "iat":1401908271,
     "exp":1401912171
}
The JWT claims set represents a JSON object whose members are the claims asserted 
by the JWT issuer. Each claim name within a JWT must be unique. If there are duplicate 
claim names, then the JWT parser could either return a parsing error or just return back 
the claims set with the very last duplicate claim. JWT specification does not explicitly 
define what claims are mandatory and what are optional. It’s up to each application of JWT 
to define mandatory and optional claims. For example, the OpenID Connect specification, 
which we discussed in detail in Chapter 6, defines the mandatory and optional claims.
The JWT specification defines three classes of claims: registered claims, public claims, 
and private claims. The registered claims are registered in the Internet Assigned Numbers 
Authority (IANA) JSON Web Token Claims registry. Even though these claims are treated 
as registered claims, the JWT specification doesn’t mandate their usage. It’s totally up to 
the other specifications which are built on top of JWT to decide which are mandatory and 
which aren’t. For example, in OpenID Connect specification, iss is a mandatory claim. 
The following lists out the registered claims set as defined by the JWT specification:
• 
iss (issuer): The issuer of the JWT. This is treated as a case-sensitive string 
value. Ideally, this represents the asserting party of the claims set. If Google 
issues the JWT, then the value of iss would be accounts.google.com. This 
is an indication to the receiving party who the issuer of the JWT is.
• 
sub (subject): The token issuer or the asserting party issues the JWT for 
a particular entity, and the claims set embedded into the JWT normally 
represents this entity, which is identified by the sub parameter. The 
value of the sub parameter is a case-sensitive string value.