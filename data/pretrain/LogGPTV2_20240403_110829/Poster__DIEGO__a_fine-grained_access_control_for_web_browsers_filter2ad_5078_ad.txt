AS Key trns.
Rolling Key trns.
250
200
150
.
c
e
s
n
e
m
T
i
i
100
10000
1000
# of transactions
100
50
0
Figure 16: performance evaluation chart 
Our experiment shows that the performance of the AS key method 
is the same or even better than the performance of a regular SQL 
statement both for select and update statements. We can explain 
this by the fact that the AS key method uses function that is stored 
in  the  database  in  a  compiled  form  so  its  performance  is  better 
than the regular statement. On the other hand the performance of 
the rolling key method is slower than the regular statement or AS 
key method. This can be explained by the fact that the rolling key 
includes  additional computation,  so  it  must  be relatively  slower. 
We can also see that for the select statement the AS key method is 
approximately twice as fast as the rolling key method, but for the 
update statement the proportion is less than twice. 
Additional  experiment  has  been  carried  out  to  evaluate  the 
performance  overhead  of  the  view-based  web  site  with  many 
concurrent sessions. The open source Book-store application (the 
source code can be found in [22]) was taken and modified to work 
with parameterized views instead of tables.  For each table of the 
original application a parameterized view was defined, the access 
to this view was given to the application and the direct access to 
the table was revoked. The from clause of each SQL statement in 
the application was modified to include the As key. No additional 
modification of the application code or the database schema was 
made.  The  stress  test  was  run  on  the  original  table-based 
application  and  on  the  modified  view-based  one.  The  results 
appear in the table 4 and compare the average time (in msec.) for 
the page response for 1, 10 and 100 concurrent users:  
# of concurrent users  / 
Application Type 
Original Table-based app 
Modified View-based app 
Table 4: stress test evaluation 
10 
users 
136.99 
135.03 
10.06 
9.27 
1 user 
100 
users 
1708.26 
1598.20 
Of course, additional tests must be accomplished, but it seems that 
there  is  no  performance  degradation  when  the  number  of 
concurrent users grows. It also seems that with comparison to the 
traditional table-based application, the parameterized view-based 
web application does not require additional definition of indexes 
or query normalizations/optimizations.  
7.  IMPLEMENTATION OF 
PARAMETERIZED VIEWS 
Despite  the  fact  that  at  the  time  of  writing  this  article  the 
parameterized views are not yet the part of the SQL standard, the 
need for it is great and one of the frequent questions in forums of 
manufacturers  of  databases  is  why  there  is  no  support  for 
parameterized  views.  Because  of  existence  of  many  users’ 
requests who ask for support for these views, we may assume that 
the manufacturers of databases will support them in a short period 
of  time.  And  this  article  can  only  emphasize  the  need  of 
parameterized  views  in  the  context  of  database  protection  and 
access control. As we have seen, parameterized views can serve as 
the natural replacement of traditional views in the web era. So we 
want  to  turn  to  the  developers  of  access  control  standards  and 
emphasize the importance of parameterized views in the context 
of access control. 
But  our  method  is  generic  enough  and  can  rely  on  any  existing 
database’s  entity  that  receives  parameters  and  returns  data 
according  to  the  received  parameters.  For  example,  we  can 
implement  our  method  with  existing  functions  stored  in  the 
database (stored DB functions). These functions are supported in 
most databases and unlike stored procedures they can be used in 
standard DML sentences. The returned value of such function can 
be the table type. For instance, the function that returns grades of 
a student will be defined as following: 
CREATE FUNCTION Student_Marks_Func 
     (pAS_key) RETURNS Table 
Begin 
  RETURN  
    SELECT   *  
    FROM  
    WHERE    Student_No IN 
( 
) 
End 
SELECT Student_No 
FROM  Users_Table 
WHERE  AS_key = :pAS_key 
Student_Marks_Table 
Figure 17: definition of table function 
similar 
to 
is  very 
This  definition 
the  definition  of 
Sudent_Marks_View from the figure 8 and its functionality is 
exactly  the  same  in  the  context  of  database  access  control.  The 
retrieval from this function will be exactly the same as from the 
parameterized view: 
SELECT * FROM Student_Marks_Func(10101…) 
Figure 18: select from table function 
Baron and Chipman in [1] show the use of these functions for the 
SQL  Server.  They  show  that  the  table  functions  can  be  more 
flexible than the views as they work with parameters. The article 
emphasizes  a  very  important  thing:  these  functions  can  be 
updatable;  namely,  not  only  that  it  is  possible  to  retrieve  from 
them,  while  the  retrieval  is  limited  by  the  parameter,  it  is  also 
possible to perform other operations of DML, including updating 
and  deleting.  And  these  operations  will  be  limited  to  the 
respective rows according to the transferred parameter. One of the 
disadvantages of regular views is the difficulty of actions such as 
addition,  deleting  and  updating.  But  as  displayed  in  [1],  the 
advantage  of  table  functions  is  their  ability  to  support  these 
actions,  while  limiting  the  activity  of  delete  and  update  to  the 
return value. 
For example, the next figure shows the update submitted by the 
customer with the key 10101... that wants to change the quantity 
of her order: 
UPDATE  
SET 
WHERE   
Orders_Func(10101…) 
Quantity = 2 
Product_Id = 1 
Figure 19: update of table function 
As SQL does not update directly the Oreders_Table, but the 
Orders_Func instead, and the function restricts the access only 
to the data of the current customer, this customer cannot submit 
any kind of attacks that updates the data of different customers. 
8.  DISCUSSSION AND FUTURE WORK 
One of the goals of organizations is to share their data and at the 
same time to enforce their policies. Heterogeneous web systems 
succeeded  in  sharing  data  to  the  Internet  consumers.  But  they 
failed  in  enforcing  the  most  important  organization  policy  - 
preventing  unauthorized  accesses  and,  especially,  preventing 
accesses of one customer to the data of another customer. The rate 
of  attacks  on  web  databases  growths  exponentially  and  this 
indicates that the existing access control mechanism of databases 
is inadequate for web applications.  
The  lack  of  fine-grained  access  control  at  the  database  level 
results in a situation when the database cannot explicitly authorize 
users accessing it. The principle of minimal privileges is violated 
and  auditing  and  monitoring  of  user’s  transactions  is  impossible 
as the only user accessing the database is the super-user of a web 
application.  Furthermore,  the  traditional  views  cannot  fulfill 
anymore their role of the access control mechanism: if databases 
cannot distinguish between different users, they are not capable of 
defining a view that is relevant to a specific user. 
Our  method  tries  to  solve  the  lack  of  authentication  and  fine-
grained authorization at the database layer of n-tier architecture of 
web  applications.  We  propose  to  supervise  the  access  to  the 
database not by the application or other external to the database 
tools as it happens with the existing web systems, but by the built-
in  database  access  control  mechanism,  that  is  enhanced  with 
parameterized views. 
From the standpoint of access control, the parameterized view is 
the  natural  substitution  of  traditional  views  in  the  web  era.  The 
use  of  parameterized  views  for  controlling  the  accesses  to  the 
database  enables  to  significantly  reduce  the  range  of  attacks  on 
databases. The proposed approach is an attempt to minimize the 
attack  surface  of  web  databases  by  means  of  native  database 
access control mechanism that is tailored to web databases and not 
by the applicative means as all other methods do. Thus we move 
the web database protection and access control mechanism from 
the application layer to the database layer! 
As  each  SQL  sentence  which  arrives  to  the  database  from  the 
application 
identification,  contains 
indication  of  the  user  who  ran  it,  the  log  of  the  database  can 
contain SQL sentences beside the users who ran them. So it is also 
easy  to  follow  the  transactions  of  the  same  user,  easy  to 
distinguish  between  the  users’  different  sessions  and  easy  to 
discover the intruder’s footprints, if needed. If the application did 
not  request  for user’s  identifier,  it  is  still  possible  to  distinguish 
between  the  sessions  of  different  users.  So  the  developers  of 
intrusion  detection  systems  to  a  web  database  can  now  analyze 
these  logs  and  use  their  algorithms  which  were  not  relevant 
before. Thus we solved the SQL session traceability problem of 
the web applications! 
As  our  method  only  requires  definitions  of  a  proper  database 
schema  and  authorization  and  it  can  be  implemented  for  any 
existing databases and enables to prevent and detect many kinds 
of attacks – it may become the preferable solution in comparison 
to any other corresponding web database access control solution 
from the view-point of cost and efficiency. 
As  we  have  seen,  the  problem  of  databases  accessible  from 
heterogeneous web applications is very important one. Nowadays 
such  databases  manage  critical  commercial  and  governmental 
information, but their access control mechanisms are inadequate. 
This problem is well known to the web application developers and 
security consultants, but it was almost not examined by academic 
researches.  We  hope  that  this  article  will  expose  the  actual 
problem  of  web  databases’  access  control  mechanism  to  the 
research community and will motivate further researches.  
that  requests 
the  user’s 
Our future research will focus on the following aspects: 
• 
• 
extension of the proposed mechanism to the RBAC systems 
use  of  the  above  techniques  as  the  basis  for  intrusion 
detection algorithms applied to web databases 
9.  REFERENCES 
[1]   Andy Baron, Mary Chipman. Creating and Optimizing Views 
in SQL Server. Article from: http://www.informit.com 
        /articles/printerfriendly.asp?p=130855&rl=1 (2000) 
[2]   Elisa Bertino, Pierangela Samarati, Sushil Jajodia. An 
Extended Authorization Model for Relational Databases, In 
Proceeding of IEEE Transactions on Knowledge and Data 
Engineering, Volume 9, Issue 1, Pages: 85-101 (1997) 
[3]   Stephen W. Boyd,  Angelos D. Keromytis.   SQLrand: 
Preventing SQL Injection Attacks, In Proceedings of the 2nd 
Applied Cryptography and Network Security Conf, Pages: 
292--302 (2004) 
[4]   Johann Eder. View Definitions with Parameters. Published 
in:  Advances in Databases and Information Systems 
(ADBIS’95), Pages: 170-184 (1995) 
[5]   Patricia P. Griffiths, Bradford W. Wade. An  
Authorization Mechanism for a Relational Database System. 
ACM, Transactions on Database Systems (1976) 
[6]   P. Gulutzan, T. Pelzer. SQL-99 Complete, Really  
        An Example-Based Reference Manual of the New  
        Standard. R&D  Books Miller Freeman, Inc. (1999) 
[7]   Michael Howard,   David LeBlanc.  Writing  Secure  Code. 
Microsoft Press, ISBN  0-7356-1722-8 (2002)  
[8]  Yi Hu, Brajendra Panda. A Data Mining Approach for 
Database Intrusion Detection. In Proceedings of the ACM 
symposium on Applied computing, Nicosia, Cyprus.  Pages: 
711 – 716 (2004)  
[9]   Hasan M. Jamil. GQL: A Reasonable Complex SQL for 
Genomic Databases. In Proceedings of International 
Symposium on Bio-Informatics and Biomedical Engineering, 
IEEE, Pages: 50-59 (2000) 
[10] Wai Lup Low, Joseph Lee, Peter Teoh. DIDAFIT: Detecting 
Intrusions in Databases Through Fingerprinting Transactions. 
In Proceedings of the 4th International Conference on 
Enterprise Information Systems, Ciudad Real, Spain, Pages: 
121-128 (2002) 
[11] Colin  Angus  Mackay.    SQL  Injection  Attacks  and   
Some Tips on How to Prevent Them. Article from:  
        http://www.codeproject.com/cs/database 
/SqlInjectionAttacks.asp (2005) 
[12] Ofer  Maor,  Amichai  Shulman.    SQL  Injection Signatures 
Evasion. Article from: 
http://imperva.com/application_defense_center/white_papers
/sql_injection_signatures_evasion.html  (2004) 
[13] K. K. Mookhey, Nilesh Burghate. Detection of SQL Injection 
and Cross-site Scripting Attacks, Article from: 
http://www.securityfocus.com/infocus/1768  (2004) 
Attacks. DIMVAn Vienna, Austria, Pages: 123-140 (2005) 
[14] Raghu Ramakrishnan, Johannes Gehrke. Database 
        Management Systems, Chapter 17.1, Introduction 
        to Database security. Second Edition (2001) 
[15] Abhinav Srivastava, Sai Rahul Reddy.  Intertransaction Data  
        Dependency for Intrusion  Detection in Database Systems,  
        part of  Information and System Security course, School of  
        Information TEchnology, IIT Kharagpur (2005) 
[16] William Stallings. Cryptography and Network  
        Security, Third Edition, Prentice Hall International (2003) 
[17] Fredrik Valeur, Darren Mutz, Giovanni Vigna. A 
        Learning-based Approach to the Detection of SQL  
[18] SecuriTeam, SQL Injection Walkthrough, Article 
        from: http://www.securiteam.com/ 
        securityreviews/5DP0N1P76E.html (2002) 
[19] Advanced Topics on SQL Injection Protection, 
        OWASP. Article from: http://www.owasp.org 
        /images/7/7d/Advanced_Topics_on_SQL_Injection_ 
        Protection.ppt(2006) 
[20] Information Security News: ISS hatches ‘virtual 
        patching’ plan. Article from:  
        http://seclists.org/isn/2003/May/0113.html  (2003) 
[21] Controlling Database Access, Oracle9i Database Concepts 
Release 2 (9.2). Article from: http://download-
west.oracle.com/docs/cd/B10501_01/server.920/ 
a96524/c23acces.htm 
[22] Online Book-Store application. The open source from the 
        site: http://www.gotocode.com/apps.asp?app_id=3&