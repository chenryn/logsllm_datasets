不要忘记execl会替换掉当前的进程；如果没有发生错误，下面这些语句是不会被执行到的。
perror(*could not exec ./uppex*);
exit13):
操作注释：
当我们运行这个程序的时候，我们可以让它把一个文件的内容全部转换为大写字母。这项
工作是由upper程序完成的，但它不参与对文件名参数的处理。注意：我们不需要upper的源代
码；我们可以利用这种方法运行任何可执行程序、
S./ussupper tile.txt
THIS IS THE FILE, FILE.TXT, I7 IS ALL LONER CASE.
useupper程序通过freopen函数先关闭标准输入，再把文件流stdin与由程序参数给定的--个文
件关联在一起。接下来，调用execl，用upper程序替换掉运行中的进程代码。因为打开的文件描
述符会在execl调用中保持下来，所以upper程序在这里的执行情况与它在shell提示符下的执行情
况是完全一样的。下面是upper做为shell命令的用法：
Supper
void (*signal (int sig, void (*func) (int1l1(1nt1,
这个看起来相当复杂的函数定义说明signal是一个带sig和func两个参数的函数，准备捕捉
或屏蔽的信号由参数sig给出，接收到指定信号时将要调用的函数由func给出。这个函数必须
有一个int类型的参数（即接收到的信号的代码），它本身的类型是void。signal函数本身将返回
一个同类型的函数一即原先用来处理这个信号的函数，或者返回下面两个特殊取值之一，见
表10-4：
表10-4
SIG_IGN
屏蔽该信号
SIG_DFL
恢复默认行为
有个例子就更容易把事情说清楚了。我们来编写一个程序ctrlc.c，它对Ctrl-C组合键的响应
是输出一条消息面不是结束运行。程序将在用户第二次按下Ctrl-C组合键时结束。
动手试试：信号处理
函数ouch对通过参数sig传递来的信号作出响应。这个函数会在信号出现时被调用执行。它
先输出一条消息，然后把SIGINT信号（在默认情况下，按下Ctrl-C组合键将产生这个信号）的
处理设暨为默认行为。
#include 
#include 
include 
void ouch(int sig)
printf(*oucH: -I got signal sd\n*,sig);
(void) signal (SIGINT, SIG_DFL):
main函数的作用是截获我们按下Ctrl-C组合键时产生的SIGINT信号。没有信号出现时，它
会在一个无限循环里每隔一秒输出一个消息。
加入jaVa编程群：524621833
---
## Page 334
316Linux程序设计
int main(1
(void] signel (S1GINr, ouch) ;
while(1)(
printf(*Hello Wor1d1\n*):
sleep (1) :
第一次按下Curl-C组合键时会引起程序作出响应，然后维续执行。当我们再次按下Ctrl-C组
合键时，程序将结束运行。这是因为SIGINT信号（译者注：此处原文误为SIG_ING）的处理动
作已经恢复为默认的行为一让程序退出执行
Hello world!
$./ctrlc
He1lo World!
Hello wor1d:
oUCR! - I got signal 2
*C
Hello Wor1d
Hello World!
Hello world:
Hello Worid:
从这个例子可以看出，信号处理函数要用一个整数值做参数，它就是引起该函数被调用的
那个信号的代码。这在同一个函数要用来处理多个信号的情况里很有用。我们打印出SIGINT的
值，在这个系统上它恰好是“2”。不要过分依赖信号代码沿用下来的数字取值，在新编程序里
应该永远使用信号的名称。
通常，当你在一个信号处理器里调用printf的时候，你需要在信号处理器里设置一-
个标志，并在调用结束后对这个标志进行检查。在这一章的末尾你会看到一个调用的清
单，其内容是能够安全地用在信号处理器里面的各种调用。
操作注释：
我们这个程序的安排是这样的：当我们通过按下Ctrl-C组合键给出SIGINT信号时，函数
ouch将被调用。程序会在中断函数ouch结束后继续执行，但信号处理动作已经被恢复为默认的
行为（不同版本的UNIX，特别是从BerkleyUNIX衍生出来的那些版本，不同的信号传统上都有
各自明确的行为。如果你想在改变了信号处理动作并处理过信号之后把它们恢复回默认的行为，
最好还是写出原来的信号处理代码）。当它接收到第二个SIGINT信号的时候，程序将采取默认的
行动，也就是结束程序的运行。
如果我们想继续使用信号处理器，还让它来负贵Ctrl-C组合键的处理，就必须通过再次调用
signal重新建立它。这会使信号在一段时间内无法得到处理，这段时间起于中断函数的开始，止
于信号处理器的重建之前。如果在这段时间里出现并接收到了第二个信号，它就会违背我们的
意愿终止掉程序的运行。
加入jaVa编程群：524621833
---
## Page 335
第10章进程和信号
317
我们不推荐大家使用signal接口。我们之所以会把它包括在这部分内容里是因为读
者可能会在许多老程序里看到它们，我们稍后将向大家介绍一个定义更清晰，执行也更
可靠的sigaction函数，在新编程序里应该坚持使用这个函数。
signal函数返回的是以前对指定信号进行处理的那个信号处理器的函数指针一一如果它有的
话：否则返同SIG_ERR并把errno设置为一个正数值。如果给出的是--个无效的信号，或者尝试
处理的信号是不可捕提或不可屏蔽的（比如SIGKILL），errno将被设置为EINVAL。
10.4.1发送信号
进程可以通过调用kill向包括它本身在内的另一个进程发送信号。如果程序没有发送该信号
的权限，对kill的调用就将失败，这类失败的常见原因是目标进程由另一位用户拥有。这个函数
是同名shell命令的对等编程接口。请看它的定义：
include 
#1nclude 
int kill (pid_t pid, int sig) ;
kill函数的作用是把参数sig给定的信号发送给由参数pid给出了标识符的进程。成功时它将返
回“0”。要想发送一个信号，发送者进程必须拥有相应的权限。这通常意味着两个进程必须拥
有同样的用户ID，也就是说，你只能向你自己的另一个进程发送信号。但超级用户可以向任何
进程发送信号。
kill调用会在失败时返回“-1”并设置errmo变量。如果失败的原因是给定的信号无效，errno
将被设置为EINVAL；如果是权限不足，errno将被设置为EPERM；如果指定的进程不存在，
errno将被设置为ESRCH。
信号为我们提供了一个有用的闹钟功能。进程可以通过alarm函数调用安排经过预定时间后
出现一个SIGALARM信号。下面是这个函数的定义：
include 
unsigned int alarm funsigned int seconds 1;
alarm调用的作用是在seconds秒之后安排发送一个SIGALARM信号。但由于处理上的延时和
意外事件的干扰，实际闹响时间会稍微错后一点点。把参数seconds设置为O将取消全部已经设置
的闹钟请求。如果在接收到SIGALARM信号之前再次调用了alarm，闻钟将重新开始计时。每个
进程只能有一个可用的闹钟。alarm函数的返回值是前一个阔钟间响之前还需经过的剩余秒数；
如果调用失败将返回“-1”。
为了让大家看到alarm的工作情况，我们用fork、sleep和signal来模仿它的效果。程序可以专
门启动一个新进程，让它在未来的某一时刻发送出一个信号。
动手试试：一个闹钟
1)alarm.c程序里的第一个函数ding的作用是模仿一个阔钟。
加入iava编程群：524621833
---
## Page 336
318
Linux程序设计
#include 
#include 
#include 
#include
static int alarm_fired = 0;
(6te uy)burp poA
slarn tired = 1;
2）在main函数里，我们告诉子进程在等待5s后发送一个SIGALARM信号给它的父进程。
int nain(1
pid t pid;
printf[*alarm application gtarting`n*);
pid - fork():
switch(pid)(
case -1:
perror(*fork failed*);
/*Failure */
exit (1) ;
case 0:
/child*/
kill(getppid(). SIGALRN) :
sleep(5) ;
exit (0) :
，
3)父进程通过一个signal调用安排好捕获SIGALARM信号的工作，然后开始等待它的到来。
/*if we get here we are the parent process */
printf(*waiting for alarm to go off\n*);
(void) signal(SIGALRK,ding);
if (alarm_fired) printf (*ding:\n*);