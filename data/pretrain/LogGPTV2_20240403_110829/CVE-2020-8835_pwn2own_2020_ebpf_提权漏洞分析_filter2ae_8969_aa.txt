# CVE-2020-8835 pwn2own 2020 ebpf 提权漏洞分析
##### 译文声明
本文是翻译文章
译文仅供参考，具体内容表达以及含义原文为准。
pwn2own 2020 上Manfred Paul (@_manfp _)_ 利用了ebpf
的一个漏洞完成了ubuntu的提权，4月16号的时候zdi公开了manfp
的[writeup](https://www.zerodayinitiative.com/blog/2020/4/8/cve-2020-8835-linux-kernel-privilege-escalation-via-improper-ebpf-program-verification)。
这篇文章中，参考zdi上的writeup, 我会分析这个漏洞的成因，然后写一下这个洞的 exp， 纯属个人笔记，理解有误的地方欢迎指正。
## 环境搭建
文章涉及到的文件都放在了[这里](https://github.com/rtfingc/cve-repo/tree/master/0x04-pwn2own-ebpf-jmp32-cve-2020-8835),
我用的是[linux-5.6](https://mirrors.edge.kernel.org/pub/linux/kernel/v5.x/linux-5.6.tar.xz)
版本的内核，在 ubuntu1804 下编译测试。
## 漏洞分析
这个漏洞是在[commit
581738a681b6](https://github.com/torvalds/linux/commit/581738a681b6faae5725c2555439189ca81c0f1f)引入的，
它添加了一个函数
    static void __reg_bound_offset32(struct bpf_reg_state *reg)
    {
        u64 mask = 0xffffFFFF;
        struct tnum range = tnum_range(reg->umin_value & mask,
                           reg->umax_value & mask);
        struct tnum lo32 = tnum_cast(reg->var_off, 4);
        struct tnum hi32 = tnum_lshift(tnum_rshift(reg->var_off, 32), 32);
        reg->var_off = tnum_or(hi32, tnum_intersect(lo32, range));
    }
漏洞发生在 `verifier` 阶段，这个阶段会模拟运行传进来的bpf指令，`bpf_reg_state` 用来保存寄存器的状态信息
    ptype struct bpf_reg_state
    type = struct bpf_reg_state {
        enum bpf_reg_type type;
        union {
            u16 range;
            struct bpf_map *map_ptr;
            u32 btf_id;
            unsigned long raw;
        };
        s32 off;
        u32 id;
        u32 ref_obj_id;
        struct tnum var_off;
        s64 smin_value;//有符号时可能的最小值
        s64 smax_value;//有符号时可能的最大值
        u64 umin_value;
        u64 umax_value;
        struct bpf_reg_state *parent;
        u32 frameno;
        s32 subreg_def;
        enum bpf_reg_liveness live;
        bool precise;
    }
`smin_value` 和 `smax_value` 保存当寄存器被当做是有符号数的时候可能的取值范围，同样`umin_value`
和`umax_value` 表示的是无符号的时候。 `var_of` 是`struct tnum` 类型
    ptype struct tnum
    type = struct tnum {
        u64 value;
        u64 mask;
    }
它只有两个成员
`value`: 某个bit为1 表示这个寄存器的这个bit 确定是1
`mask`: 某个bit 为1表示这个 bit 是未知的
举个栗子，假如`value` 是 `010`（二进制表示) ， `mask` 是`100` , 那么就是经过前面的指令的模拟执行之后，可以确定这个寄存器的
第二个bit 一定是 1, 第三个 bit 在`mask`
里面设置了，表示这里不确定，可以是1或者是0。详细的文档可以在`Documentnetworking/filter.txt` 里面找到。
对于跳转指令, 假如当前遇到了下面这样一条指令，
`BPF_JMP_IMM(BPF_JGE, BPF_REG_5, 8, 3)`
会有下面这样两行代码来更新状态，`false_reg` 和`true_reg` 分别代表两个分支的状态，
这是我们前面`__reg_bound_offset32` 的64位版本
        __reg_bound_offset(false_reg);
        __reg_bound_offset(true_reg);
这条指令 `r5 >= 8` 的时候 ， 会跳到`pc+3` 的地方执行(正确分支), 那么在错误的分支上，`r5` 肯定是 小于 8 了，
`__reg_bound_offset32` 会在使用`BPF_JMP32` 的时候调用，ebpf 的`BPF_JMP`
寄存器之间是64bit比较的，换成`BPF_JMP32` 的时候就只会比较低32bit. 我们看看他是怎么做的
首先是把之前状态转移的`umin_value` 和`umax_value` 只取低32bit , 创建一个新的 tnum， `lo32` 是取原来
`var_off` 的 低32bit
     struct tnum tnum_range(u64 min, u64 max)                            
     {                                                                   
         u64 chi = min ^ max, delta;
         // 从右往左数，第一个为1的bit 是哪一位(从1开始数)， 表示没有1
         // 如:  fls64(0100)  ==  3
         u8 bits = fls64(chi);                                          
         /* special case, needed because 1ULL  63)                                                  
             return tnum_unknown;                                        
         /* e.g. if chi = 4, bits = 3, delta = (1umin_value & mask,
                           reg->umax_value & mask);
        struct tnum lo32 = tnum_cast(reg->var_off, 4);
        struct tnum hi32 = tnum_lshift(tnum_rshift(reg->var_off, 32), 32);
对于`tnum_intersect` 如果`a`和`b` 有某一个bit 是1, 那么代表已经确定这个bit是1了， 所以这里用`|` 的方式，
两者信息整合起来最后生成一个新的`var_off`
    struct tnum tnum_intersect(struct tnum a, struct tnum b)     
    {                                                            
        u64 v, mu;                                               
        v = a.value | b.value;                                   
        mu = a.mask & b.mask;                                    
        return TNUM(v & ~mu, mu);                                
    }                                                            
    //...
    reg->var_off = tnum_or(hi32, tnum_intersect(lo32, range));
漏洞发生的原因是这里的实现方式有问题，计算`range` 的时候直接取低32bit，因为原本的`umin_value` 和 `umax_value`
都是64bit的， 假如计算之前`umin_value == 1` ， `umax_value == 1 0000 0001` ,
取低32bit之后他们都会等于1，这样range计算完之后`TNUM(min & ~delta, delta);` ， `min = 1` , `delta
= 0`
然后到`tnum_intersect` 函数， 假设`a.value = 0` ，计算后的`v == 1` ，`mu ==0` , 最后得到的
`var_off` 就是固定值`1`, 也就是说，不管寄存器真实的值是怎么样，在`verifier` 过程都会它当做是1。
####  调试分析
我们调试看看内存具体是怎么样的, 首先我们创建一个array map, ebpf指令中, 让`r9 = map[1]`, `r6`
是我们要用来测试漏洞的寄存器，从`map[1]` 中加载值到`r6` 中(具体参考后面的exp), 这样 `verifier` 就不知道 `r6`
是什么，这时候的`var_off->value = 0`
    BPF_LDX_MEM(BPF_DW,6,9,0),
因为我的调试环境没有办法运行`bpftool`,
首先在[`kernel/bpf/syscall.c:125`](https://elixir.bootlin.com/linux/v5.6/source/kernel/bpf/syscall.c#L125)
map_create 的时候获取一下 map 的地址值
    static struct bpf_map *find_and_alloc_map(union bpf_attr *attr)        
    {                                                                      
    //....                                    
        map = ops->map_alloc(attr);  //>1 == 0`, 但是实际运行的时候 `(2 & 2) >> 1 ==1`,
    BPF_ALU64_IMM(BPF_AND, 6, 2),   
    BPF_ALU64_IMM(BPF_RSH, 6, 1),
接下来我们让`r6 = r6 * 0x110` , 这样 `verifier` 过程仍然认为它是0，但是运行过程的实际值确实 `0x110`
    BPF_ALU64_IMM(BPF_MUL,6,0x110),
我们获取一个map，我们叫它`expmap` 把， `r7 = expmap[0]`
    BPF_MOV64_REG(7,0),
然后 `r7 = r7 - r6`, 因为 `r7` 是指针类型， `verifier` 会根据map的 size 来检查边界，但是`verifier`
的时候认为`r6 ==0` ，`r7 - 0 == r7`, 所以可以通过检查， 但是运行的时候 我们可以让`r7 = r7 - 0x110`, 然后在
`BPF_LDX_MEM(BPF_DW,8,7,0),` 就可以做越界读写了。
    BPF_ALU64_REG(BPF_SUB,7,6)
ebpf 用`bpf_map` 来保存map 的信息， 也是我们前面`map_create` 的时候得到的那个地址
    gef➤  kstruct bpf_map
    ptype struct bpf_map
    type = struct bpf_map {
        const struct bpf_map_ops *ops;
        struct bpf_map *inner_map_meta;
        void *security;
        enum bpf_map_type map_type;
        //....
        u64 writecnt;
    }
在 `map_lookup_elem` 的时候， 使用的是 `bpf_array` ，它的开头是`bpf_map`, 然后`value` 就是map
的每一个项的数组，也就是说 `bpf_map` 刚好在`r7` 的低地址处(`r7` 是第一个 value)， 这里查看内存可以知道 `map` 在 `r7
- 0x110` 的地方
    ptype struct bpf_array
    type = struct bpf_array {
        struct bpf_map map;
        u32 elem_size;
        u32 index_mask;
        struct bpf_array_aux *aux;
        union {
            char value[];//,//<-- 泄露内核地址