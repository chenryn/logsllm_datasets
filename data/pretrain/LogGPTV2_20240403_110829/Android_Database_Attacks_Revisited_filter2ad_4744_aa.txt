title:Android Database Attacks Revisited
author:Behnaz Hassanshahi and
Roland H. C. Yap
Android Database Attacks Revisited∗
Behnaz Hassanshahi
PI:EMAIL
School of Computing
National University of Singapore
Roland H. C. Yap
PI:EMAIL
School of Computing
National University of Singapore
ABSTRACT
Many Android apps (applications) employ databases for man-
aging sensitive data, thus, security of their databases is a
In this paper, we systematically study attacks
concern.
targeting databases in benign Android apps.
In addition
to studying database vulnerabilities accessed from content
providers, we deﬁne and study a new class of database vul-
nerabilities. We propose an analysis framework to ﬁnd such
vulnerabilities with a proof-of-concept exploit. Our anal-
ysis combines static dataﬂow analysis, symbolic execution
with models for handling complex objects such as URIs and
dynamic testing. We evaluate our analysis on popular An-
droid apps, successfully ﬁnding many database vulnerabil-
ities. Surprisingly, our analyzer ﬁnds new ways to exploit
previously reported and ﬁxed vulnerabilities. Finally, we
propose a ﬁne-grained protection mechanism extending the
manifest to protect against database attacks.
Keywords
Android Security; Program Analysis; Database; Malware
1.
INTRODUCTION
Many Android apps (applications) use data stored in data-
bases. Furthermore, an app can interact with the database(s)
of another app providing functionality to each other. A vul-
nerable app may allow malware to violate the integrity and
conﬁdentiality of data stored in its databases. We call such
vulnerabilities database vulnerabilities.
We argue that the use of databases in Android apps is
signiﬁcant thus ﬁnding and mitigating database vulnerabil-
ities is important. There has been little work on detect-
ing database vulnerabilities in Android. The most rele-
vant work, ContentScope [31], only studies public database
∗This research is supported by the National Research Foundation,
Prime Minister’s Oﬃce, Singapore under its National Cybersecu-
rity R&D Program (Award No. NRF2015NCR-NCR002-001) and
administered by the National Cybersecurity R&D Directorate.
Permission to make digital or hard copies of part or all of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full citation
on the ﬁrst page. Copyrights for third-party components of this work must be honored.
For all other uses, contact the owner/author(s).
AsiaCCS ’17, April 02-06, 2017, Abu Dhabi, United Arab Emirates.
c(cid:13) 2017 Copyright held by the owner/author(s).
ACM ISBN 978-1-4503-4944-4/17/04. . . $15.00.
DOI: http://dx.doi.org/10.1145/3052973.3052994
vulnerabilities, namely, vulnerabilities arising from content
providers. Nevertheless, database implementation in apps
is not limited to content providers. Apps can use internal
databases without content providers which can be accessed
by other means such as Intents. Such databases which we
call private databases can also have database vulnerabilities.
In this paper, we study and characterize database vulner-
abilities in benign Android apps.
In particular, we deﬁne
the new class of private database vulnerabilities. To detect
database vulnerabilities, we propose an analysis framework
which automatically generates proof-of-concept exploits. Su-
ch exploits can be used by malware on the device to exploit
the vulnerabilities. Analysis of database vulnerabilities re-
quires accurate analysis of URI objects which are heavily
utilized when using databases, e.g., apps may have buggy
validation and sanitization on incoming database access re-
quests using URI-based library methods. We handle this
with symbolic models of URI objects whose operations are
analyzed with our symbolic execution framework.
Although Android has permissions which deal with public
databases, they are not suﬃciently ﬁne-grained to prevent
public database attacks. It gets worse for private databases
as there are no speciﬁc permission mechanisms which deal
with their usage. We propose a conservative extension to
the Android manifest to help developers secure their apps
from database attacks.
We have implemented a prototype system, DBDroidScan-
ner, which ﬁnds public and private database vulnerabilities
and generates the corresponding exploits to conﬁrm them.
Using DBDroidScanner, we analyze 924 real-world apps and
ﬁnd a signiﬁcant number of them having database vulner-
abilities. DBDroidScanner automatically generates 153 ex-
ploits for those database vulnerabilities. This suggests that
database vulnerabilities in Android can be signiﬁcant. By
exploiting these vulnerabilities, unprivileged malware on the
device can cause data leaks and pollution. As we generate
the malware automatically, it suggests that it may be diﬃ-
cult for anti-virus to detect such malware [6].
We also re-analyze apps whose public database vulnerabil-
ities were studied in [31]. We ﬁnd that some of these apps
still contain vulnerabilities in their updated versions, e.g.,
Maxthon Android Web Browser. More importantly, we found
apps where the content provider reported to be vulnerable
to the public database attacks in [31] have been updated
to ﬁx the vulnerability, turn out to be still exploitable via
other components due to private database vulnerabilities.
We also ﬁnd some more complex attacks.
In apps which
were only studied for public database attacks [31], we ﬁnd
625new privilege escalation attacks which are triggered from
private database vulnerabilities but end up exploiting pro-
tected content providers (public databases) of other apps.
In summary, our contributions are: (i) a broad classiﬁ-
cation of database attacks in Android apps; (ii) accurate
models for URI-based libraries essential for analysis of apps
using databases; (iii) a detection and exploitation frame-
work for zero-day database vulnerabilities; and (iv) a new
database protection mechanism for Android apps.
2. PUBLIC & PRIVATE DATABASES
a:
Malware
CP API
Unprotected App DB
b:
Malware
c:
Malware
Intent
Intent
Unprotected App DB
Unprotected App1
CP API
Protected App2 DB
Figure 1: Database Attack Scenarios: a is public; b and c are private
attacks. CP API stands for Content Provider API.
Android developers often open up the databases imple-
mented in their apps to “other apps” on the device using
content provider components which provide APIs for pub-
lic database access from other apps. They can also imple-
ment databases without exposing them through the public
database mechanism by instead using the inter-app com-
munication mechanism, i.e., Intents. In this paper, we call
the former group of databases, public databases and the lat-
ter, private databases. The basic idea is that databases in
apps are not vulnerable if the APIs which a malware can
use are suﬃciently protected by permissions (more details
of the cases for public and private databases can be found
in Sec. 4.1). Thus, a vulnerable app is one whose (pub-
lic or private) databases are not fully protected. For our
purposes, database means what Android provides for data
storage, namely the SQLiteDatabase library and ﬁles (e.g.,
ParcelFileDescriptor).
Public Database Attacks. The ﬁrst category of attacks
targets the public databases which are accessible through
content providers. Fig. 1.a shows the public database at-
tack scenario where a malware app uses the parameters of
an unprotected content provider API to exploit the database
vulnerabilities of a victim app.
In Android, components
which are meant to be accessible by other apps need to be
exported by specifying the android:exported attribute in the
manifest ﬁle. Content provider is a special case. Line 4 in
Listing 3 shows the android:exported attribute of the content
provider tag in the manifest ﬁle. By default, this attribute
is set to false in Android SDK 17 (released Nov 2012) and
higher which means that the content provider is not avail-
able to other apps. However, content providers in apps built
for SDK 16 and lower are exported by default, hence ac-
cessible by all apps.
In this paper, we study the public
database attacks for the SDK 17 and higher.1 While the
android:exported="false" attribute isolates a database from
other apps, unfortunately, it is coarse-grained preventing all
legitimate apps from using public database functionalities.
Developers can protect content provider components us-
ing existing or their own custom permissions.2 Developers
1
2
ContentScope [31] analyzes apps for SDK 16 and lower.
A custom permission is declared by the developer and has to be
can restrict access to the data in content providers across
applications at diﬀerent granularities: (1) setting the an-
droid:exported="false" attribute is the least ﬁne-grained op-
tion to protect the component; Alternatively, they can spec-
ify the following permissions: (2) android:permission for the
whole component which is coarse-grained and prevents apps
(malware) lacking this permission from directly accessing
the content provider; (3) readPermission and writePermis-
sion which restrict access based on the request, i.e., query
or data manipulation. These permissions are more ﬁne-
grained and partially protect the content providers; (4) path-
permission for protecting particular data stored in databases
which is the ﬁnest-grained option protecting speciﬁc paths
of the content providers.3 In our attack scenarios, we con-
sider cases where the content provider is not fully protected.
In Sec. 4.1, we elaborate on what we mean by a content
provider which is not fully protected and explain how can-
didate content providers are chosen.
Private Database Attacks. The second category of at-
tacks targets the private databases which are accessible thro-
ugh inter-app communication. An unprotected app has an
unprotected component (except for content provider) which
is exported4 but not protected by any dangerous or more
restrictive permissions. Fig. 1.b and Fig. 1.c show two pri-
vate database attack scenarios.
In the ﬁrst scenario, the
malware sends malicious Intents to the victim app’s compo-
nents (e.g., activity) to exploit its database vulnerabilities.
The second scenario is a privilege escalation attack, e.g.,
(i) the malware ﬁrst sends a malicious Intent to the victim
App1; next, (ii) App1 invokes the content provider APIs of
victim App2 to exploit the vulnerabilities in App2. Note
that victim App2 might have correctly protected its content
provider with permissions and App1 which is not malware
can legitimately have those permissions. It is also possible
that victim App1 calls its own protected content provider
APIs, in which case only one victim app is involved.
Unlike public databases, Android does not provide any
explicit protection mechanism for private databases. Hence,
developers have to implement their own (possibly buggy)
access-control code to secure internal databases. If a com-
ponent (e.g., a broadcast receiver) allows an app to access
the private databases by sending Intents, there is no further
access control mechanism in Android to protect these pri-
vate databases. Furthermore, many Android apps heavily
rely on these private databases to organize various contents
such as contacts and app private information.
Intents are the main means of communication in Android.
Unfortunately, developers often fail to check its origin prop-
erly, e.g. they may use Intents for communication among
internal components, but forget that Intents can also be cre-
ated and sent by other apps. Handling an incoming Intent
which modiﬁes the internal database’s data is not diﬀerent
from handling other Intents and this might result in the
programmer’s confusion. As a result, Intents may trigger
undesired behaviors which result in private database vulner-
added to the manifest ﬁle separately.
permission is normal, all applications can get it.
3
If the protection level of a
Android allows developers to temporarily override the content
provider permissions using the grantUriPermission. This case is not
considered a vulnerability as the app which owns the content provider
should explicitly send an Intent or call grantUriPermission() method
to allow the app to temporarily access its data.
4
exported="true" is speciﬁed or alternatively, the exported attribute
is not speciﬁed explicitly but the component has an Intent ﬁlter.
626abilities. Apps may also accidentally expose access paths to
private databases by allowing portions of the input string
from an Intent to directly be passed to the SQL methods
(e.g., insert()), which allows attackers to manipulate the
database.
The question of whether the developer intends certain
functionality allowing other apps (malware) to access its
database is a tricky one. With public database attacks, one
possible view is that only protecting a speciﬁc set of paths of
the content provider in the manifest ﬁle is intentional. How-
ever, a valid counter-argument is that the developer may
have chosen a wrong path pattern, thereby creating a vul-
nerability. We found this to be the case for some of the
real app vulnerabilities. Private database attacks are even
more susceptible to unintended behavior as the protection
in Android is limited only to the permissions speciﬁed for
the entire exported component which is too coarse-grained.
Hence, developers might give up on protecting a component
since it restricts the app functionality too much without re-
alizing its exposure to attacks. In this paper, we are conser-
vative and make the reasonable assumption that a database
which is available to all apps, including malware, but is not
fully protected is a candidate to be analyzed for public and
private database vulnerabilities.
3. THREAT MODEL AND EXAMPLES
Threat Model. The adversary in our attack model is mal-
ware installed on the Android device. We do not make any
assumptions about the permissions requested by the mal-
ware, i.e., malware need not request for any permission with
dangerous or more restrictive protection level. We assume
that at least one app on the device is benign but buggy,
hence a database vulnerability exists. The malware can at-
tack either public or private databases of unprotected apps
as shown in Fig. 1. It needs to craft malicious input (which
can be string, data structures, Intent or other object types),
sending it to the relevant component of the vulnerable app.
Listing 1 and 2 show two example components of app A
(our example benign victim app) which are vulnerable to
the public and private database attacks respectively. This
example is a simpliﬁcation of real-world apps. App M in
Listing 4 is the malware app which exploits the vulnerabili-
ties in app A.
Vulnerable Public Database Example. Line 4 in List-
ing 3 shows the content provider tag of app A. The an-
droid:exported attribute in the manifest allows the content
provider to be accessed by other apps on the device. The
developer has tried to protect this provider using  at Line 5. This means that any request which
targets URIs with the "/contacts/" path (intending to mod-
ify the data managed by this provider) will be allowed if
the requesting app has the com.example.app.Write permis-
sion. However, there is a vulnerability in app A (Listing 1).
Other paths in this code allow the attacker to pollute the
database with sensitive data which will be sent out later
(e.g., via SMS).
In the lifecycle of the content providers (see Sec. 4.1),
onCreate() is the ﬁrst method called by the Android frame-
work. The two URI patterns are registered in the android.
content.UriMatcher object: Line 6 maps URIs whose paths
only consist of digits to 1 and Line 7 maps URIs whose paths
are "/contacts/" to 2. Due to the  in the
manifest ﬁle (Line 5 in Listing 3), only the second URI pat-

1 public class P u b l i c D a t a b a s e extends
C o n t e n t P r o v i d e r {
2
3
4
5
6
7
8
9
10
11
12
13
U r i M a t c h e r u r i M a t c h e r = new U r i M a t c h e r (0) ;
P u b l i c D B H e l p e r d b H e l p e r ;
public boolean o n C r e a t e () {
d b H e l p e r = new P u b l i c D B H e l p e r (...) ;
u r i M a t c h e r . addURI ( " com . example . app .
P u b l i c D a t a b a s e " , " # " , 1) ;
u r i M a t c h e r . addURI ( " com . example . app .
P u b l i c D a t a b a s e " , " c o n t a c t s / " , 2) ;
return true ; }
public Uri insert ( Uri uri , C o n t e n t V a l u e s val ) {
S Q L i t e D a t a b a s e db = d b H e l p e r .
g e t W r i t a b l e D a t a b a s e () ;
switch ( u r i M a t c h e r . match ( uri ) ) {
case 1:{
String table = g e t T a b l e N a m e ( uri .
g e t L a s t P a t h S e g m e n t () ) ;
if (! table . isEmpty () )
return db . insert ( table , null , val ) ;
return null ;
switch ( id ) {
return null ;
return db . insert ( " C o n t a c t s " , null , val ) ;
}
case 2:{
}
default :
14
15
16
17