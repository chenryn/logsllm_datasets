22
24
3.5
3.3
2011
2010
2. Multidimensional range: A range query selects rows whose
values in one or more speciﬁed columns lie in a certain range.
The dimension of such a query is the number of columns involved.
E.g., the two-dimensional query “SELECT * FROM A WHERE (age
BETWEEN 22 AND 24) AND (student_ID > 10730)” returns:
row_ID student_ID age GPA First_name
1
10747
22
3.5
Bob
3. SUM, MAX, MIN, and COUNT: These queries return the sum,
maximum, minimum, or number of the entries in a speciﬁed col-
umn. E.g., the query “SELECT SUM(age) FROM A” returns 90.
4. LIKE: This query ﬁnds rows with strings in a speciﬁed column
matching a certain pattern. E.g., the query “SELECT * FROM A
WHERE First_name LIKE ‘Ali%’ ” returns:
row_ID student_ID age GPA First_name
2
10715
24
3.3
Alice
5. Nested queries: Since the answer to any SQL query is it-
self a table, SQL queries can be nested so that queries are ap-
plied to intermediate results. For example, the query “SELECT
SUM(A.age) FROM A JOIN B ON A.student_ID = B.student_ID”
returns 46, which is the summation of the column “A.age” in the
table generated by the JOIN query earlier. As a more complicated
example, a JOIN query can be applied to the result of a multi-
dimensional range query. E.g., the query “SELECT A.student_ID,
A.age, A.GPA, B.Year_Enrolled FROM {SELECT * FROM A WHERE
(age BETWEEN 22 AND 24) AND (student_ID > 10730)} JOIN B
ON A.student_ID = B.student_ID” returns:
student_ID A.age A.GPA B.Year_Enrolled
10747
22
3.5
2011
3. BUILDING BLOCKS
In this section we describe two authenticated data structures that
we use as building blocks in INTEGRIDB: one for set operations
(that we call ASO), and one for interval trees (that we call AIT ).
3.1 ADS for Set Operations with Summation
INTEGRIDB uses an ADS for verifying set operations that we
introduce here. Our construction is based on prior work of Papa-
manthou et al. [37] and Canetti et al. [11], with the main difference
being that we additionally support summation queries over sets.
For our purposes, a data structure for set operations considers
data as a collection S1, . . . , S(cid:96) ⊂ Zp of sets over the universe1 Zp.
The class Q of supported queries consists of nestings (see below)
of the following basic queries (we discuss updates in Section 4.5):
Union: Given identiﬁers of sets S(cid:48)
Intersection: Given identiﬁers of sets S(cid:48)
k, it returns(cid:83)
k, it returns(cid:84)
Sum: Given an identiﬁer of set S(cid:48), it returns(cid:80)
a query Union(I) with I ⊆ [(cid:96)]; this would return(cid:83)
this would return(cid:80)
The identiﬁer of one of the original sets outsourced by the data
owner is simply its index. (Thus, for example, a user might make
i∈I Si.) Sets
computed as the intermediate result of various queries also have
(implicit) identiﬁers, allowing nested queries. E.g., a user could
query Sum(Intersection(Union(I), Union(J))) with I, J ⊆ [(cid:96)];
i S(cid:48)
i.
x∈S(cid:48) x mod p.2
1, . . . , S(cid:48)
1, . . . , S(cid:48)
x∈S(cid:48) x mod p where
i S(cid:48)
i.
(cid:48) def= (cid:0)(cid:83)
S
(cid:1)(cid:92)(cid:0)(cid:83)
i∈I Si
i∈J Sj
(cid:1) .
We construct an ADS supporting the above queries using the bi-
linear accumulator primitive introduced in [29]. Fix groups G1,
G2, and GT of order p, and a bilinear map e : G1×G2 → GT . For
simplicity we assume G1 = G2 = G but this is not essential. Let g
1Formally, the universe is {0, . . . , B}, with p chosen by Setup
such that p (cid:29) B.
2Note this gives the true result sum = (cid:80)
x∈S(cid:48) x if sum < p and
so there is no overﬂow.
be a generator of G. The Init algorithm begins by choosing uniform
the set trapdoor s ∈ Zp and letting sk = s be the secret key and
pk = (gs, . . . , gsq
) be the public key, where q is an upper-bound
on the cardinality of any set. For a set S = {x1, . . . , xn} ⊂ Zp,
deﬁne the accumulation value of S as:
(cid:81)n
acc(S) def= g
i=1(x
−1
i +s).
The digest δ output by Setup for a particular collection of sets
S1, . . . , S(cid:96) is simply acc(S1), . . . , acc(S(cid:96)).
Union and intersection queries can be handled as in [37, 11]. (We
use the inverse of set elements rather than the elements themselves,
but this is handled in a straightforward manner.) We now show how
to release the sum sum of the elements in a set S = {x1, . . . , xn}
in a way that can be veriﬁed by any client in possession of acc(S).
To do this, the server computes
i + s) = sn + an−1sn−1 + ··· + a1s + a0
−1
(x
j ) and a0 =(cid:81)n
−1
j(cid:54)=i x
i=1 x
−1
i
, along with
as a formal polynomial in the variable s.
It then releases a1 =
w1 = gsn−1+···+a2s+a1 and w2 = gsn−2+···+a3s+a2 .
(Note that the server can compute w1, w2 using pk.) To verify, the
client checks that sum = a1a
−1
0 mod p and that:
1. e(gs, w1) ?= e(acc(S)/ga0 , g) and
2. e(gs, w2) ?= e(w1/ga1 , g).
Security of the above relies on the q-SBDH assumption [9] in
bilinear groups. We sketch a proof. Given an adversary A vio-
lating correctness, we construct an algorithm A(cid:48) breaking the q-
SBDH assumption [9]. A(cid:48) takes (gs, . . . , gsq
) as input and, given
a set S (of size n ≤ q) output by A, computes the accumulator
value acc(S). Say A next outputs sum∗, a∗
1, w∗
1 such that
veriﬁcation succeeds yet sum∗ (cid:54)=(cid:80)
0, a∗
x∈S x. Let
0 , w∗
n(cid:89)
i=1((cid:81)
(cid:80)n
i=1
n(cid:89)
i + s) = sn + an−1sn−1 + ··· + a1s + a0.
−1
(x
i=1
If a∗
1 (cid:54)= a1.
0 (cid:54)= a0 or a∗
1 ) = e(acc(S)/ga∗
1 /(gsn−1+···+a2s+a1 ))(a0−a∗
0 (cid:54)= a0
Note that we must have a∗
then, since e(gs, w∗
0 , g), we must have g1/s =
0 )−1. As the right-hand side of this
(w∗
equation can be computed by A(cid:48), this violates the q-SBDH assump-
tion. If a∗
0 , g)
we have w∗
1 , g),
1 )−1. Since
we must have that g1/s = (w∗
the right-hand side of this equation can be computed by A(cid:48), this
violates the q-SBDH assumption.
Security of our ASO also relies on an extractability assump-
1 ) = e(acc(S)/ga∗
0 = a0 and a∗
1 = gsn−1+···+a2s+a1. Since e(gs, w2) = e(w1/ga∗
2 /(gsn−2+···+a2 ))(a1−a∗
1 (cid:54)= a1, since e(gs, w∗
tion [6], which is inherited from [11].
Support for multisets. Our ASO can be naturally generalized
to support operations on multisets, in which a given element can
have multiplicity greater than 1. The intersection (resp., union)
of multisets S, S(cid:48) yields a multiset in which each element appears
with multiplicity equal to its minimum multiplicity (resp., the sum
of the multiplicities) in S and S(cid:48). The sum of a multiset is deﬁned
in the natural way, taking multiplicity into account.
Complexity. The complexity of handling union and intersection
is as in [37, 11], and in particular proofs are constant size. A sum
query also has constant-size proofs. In a query involving d set op-
erations (e.g., d = 3 in the query S1 ∩ (S2 ∪ S3)) with result R,
the proof size is O(d) and the veriﬁcation time is O(d + |R|).
3.2 ADS for Interval Trees
Fix a function f (possibly randomized). For our purposes, an
interval tree is a binary tree T associated with a set S = {(k, v)}
of key/value pairs, where the keys lie in a totally ordered set. Each
leaf node of T stores one element of S, with the leaves sorted by
key. Each internal node u also stores a key/value pair (k, v), where
v is computed by applying f to the values stored in the left and right
children of u. The key k at internal node u is equal to the maximum
key stored at any node in the left subtree of u, and is strictly less
than the key stored at any node in the right subtree of u.3
For a node u, let Tu denote the set of leaf nodes in the subtree
rooted at u. For a set N of leaf nodes, we say a set of nodes U is a
covering set of N if ∪u∈U Tu = N. For our application, we need
support for two types of queries:
Search: Given a key k, this returns the value stored at the leaf node
(i.e., in the original set S) with key k.4
RangeCover: Given kL, kR with kL ≤ kR, let N be the set of
leaf nodes whose key k satisﬁes kL ≤ k ≤ kR. This query
returns the key/value pairs stored at all the nodes in the min-
imal covering set of N.
We also need to support two types of updates to S:
Insert: Given a key/value pair, this inserts a leaf node containing
that key/value pair into the interval tree, and updates internal
nodes of the tree accordingly.
Delete: Given a key, this deletes all leaf nodes storing that key, and
updates internal nodes of the tree accordingly.
An ADS supporting the above can be constructed generically us-
ing a Merkle tree, as in [25]. This gives a construction in which
each leaf node is augmented with a hash computed over its stored
key/value pair, and each internal node is augmented with a hash
computed over the key/value/hash tuple stored by its children. The
key, value, and hash at the root is the digest of the tree.
Inser-
tions/deletions can be performed using rotations as in standard red-
black tree algorithms [13], with hash values being updated when
rotations are performed.
Setup algorithm. We note here AITSetup algorithm is parameter-
ized by function f used to compute the values of the internal nodes
and is written as ( ˜D, δ) ← AITSetupf (D, skD)—see Figure 2.
Complexity. Let n be the number of leaves. The size of the min-
imal covering set output by RangeCover is O(log n). The size of
the proof and the complexity of veriﬁcation for Search, Range-
Cover, Insert, and Delete is O(log n).
4. OUR CONSTRUCTION
We now describe the ADS used in INTEGRIDB.
3Duplicate keys are accumulated at leaves, i.e., if there are multiple
key/value pairs (k, v1), (k, v2), . . . with the same key k, then a sin-
gle leaf is created with key k and with value computed by applying
f recursively to all the values stored at that leaf. A counter is also
stored in the leaf to indicate the number of duplicates.
4The counter is also returned in the case of duplicates.
4.1 Setup
The high-level idea is that for each table, and each pair of columns
in that table, we create an authenticated interval tree. (Although this
requires storage quadratic in the number of columns, this is ﬁne for
practical purposes since the number of columns is typically much
smaller than the number of rows.) The key/value pairs stored at the
leaves of the tree corresponding to columns i, j are the entries in
those columns that lie in each of the rows (see below). The value
stored at an internal node u will (essentially) correspond to the ac-
cumulation (cf. Section 3.1) of the values stored at the leaves in the
subtree rooted at u. Details follow.
For a table T , let xij denote the element in row i, column j of
that table. Let
Si×j
def= {(x1i, x1j), . . . , (xni, xnj)} ,
and view this as a set of key/value pairs. Construct an interval tree
for Si×j. Leaf nodes hold key/value pairs from Si×j. Each internal
node u stores a key equal to the minimum key stored at the leaves
of the left subtree rooted at u, and stores the value
fs,sk(u) = Encsk
−1 + s)
(v
(cid:107) g
v∈Tu
(v−1+s) ,
(1)
(cid:32)(cid:89)
v∈Tu
(cid:33)
(cid:81)
where Tu now denotes the values stored at the leaves in the subtree
rooted at u, and Enc is a CPA-secure encryption scheme.
c1
x11 = 24
x21 = 59
x31 = 47
x41 = 11
x51 = 13
x61 = 36
x71 = 19
x81 = 27
c2
x12
x22
x32
x42
x52
x62
x72
x82
c3
x13
x23
x33
x43
x53
x63
x73
x83
c4
x14
x24