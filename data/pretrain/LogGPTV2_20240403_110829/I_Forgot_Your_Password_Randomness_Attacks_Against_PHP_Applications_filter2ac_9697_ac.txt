random numbers, for example to sample a random en-
try from an array. To achieve that, the PHP system
maps the output of the PRNG to the given range, an
action that may break the linearity of the generators.
Second, in order to collect the necessary leaks the at-
tacker may need to reconnect to the same process many
times to collect the leaks from the same generator in-
stance. Since, there could be many PHP processes run-
ning in the system, this poses another challenge for the
attacker.
In this section we present state recovery algo-
rithms for the truncated PRNG functions rand() and
mt rand(). The algorithm for the latter function
is novel, while regarding the former we implement
and evaluate the H˚astad-Shamir cryptanalytic frame-
work [8] for truncated linearly related variables. We
begin by discussing the way truncation takes place in
the PHP system. Afterwards, we tackle the problem of
reconnecting into the same server process. Finally we
present the two algorithms against the generators.
5.1 Truncating PRNG sequences in the
PHP system
As mentioned in section 2.2 the rand() and
mt rand() functions can map their output to a user
deﬁned range. This has the effect of truncating the
functions’ output. Here we discuss the process of trun-
cating the output and its implications for the attacker.
Let n ∈ [M] = {0, . . . ,M − 1} be a random number
generated by rand() or mt rand(), where M = 231
in the PHP system. In order to map that number in the
range [a,b] where a 
0. Then the following equations hold for any k ≥ 0:
1. x0
jn+k = x0
2. x1
jn+k = x1
a1)
( j−1)n+k+m ⊕ (x31
( j−1)n+k+m ⊕ x0
( j−1)n+k+1 ∧ a0)
( j−1)n+k ⊕ (x31
( j−1)n+k+1 ∧
3. ∀i,2 ≤ i ≤ 31 : xi
xi−1
( j−1)n+k+1 ⊕ (x31
( j−1)n+k+1 ∧ ai)
jn+k = xi
( j−1)n+k+m ⊕
Proof. The equations follow directly from the basic re-
currence.
In addition since the tempering matrix is only a lin-
ear transformation of the bits of the state variable xi,
we can similarly express each bit of the ﬁnal output of
MT as a linear equation of the bits of the respective
state variable.
To recover the initial state of MT, we generate all
equations over the state bit variables x0,x1, . . . ,x19936.
To map any position in the MT sequence in an equation
over this set of variables, we apply the equations of the
lemma above recursively until all variables in the right
hand side have index below 19937.
Depending on the positions observed in the MT se-
quence the resulting linear system will be different.
The question that remains is whether that system is
solvable. Regarding the case of the 31-bit truncation,
i.e. only the MSB of the output word is revealed, we
can use known properties of the generator in order to
easily prove the following:
Lemma 5.2. Suppose we obtain the MSB of 19937
consecutive words from the MT generator. Then the
resulting linear system is uniquely solvable.
Proof. It is known that the MT sequence is 19937-
distributed to 1-bit accuracy4. The linear system is
uniquely solvable iff the rows are linearly independent.
Suppose that a set k ≤ 19937 of rows are lineary de-
pendent. Then the last row of the set k obtained is
computable from the other members of the k-set some-
thing that contradicts the order of equidistribution of
MT.
The above result is optimal in the sense that this is
the minimum number of observed outputs needed for
the system to become fully determined.
In the case
we obtain non consecutive outputs due to truncation
4Suppose that a sequence is k-distributed to u-bit accuracy. Then
knowledge of the u most signiﬁcant bits of l words does not allow
one to make any prediction for the u bits of the next word when l < k.
This is the cryptographic interpretation of the “order of equidistribu-
tion” whose exact deﬁnition can be found in [15].
9
or application behavior, linear dependencies may arise
between the resulting equations and therefore we may
need a larger number of observed outputs.
Because we cannot know in advance when the sys-
tem will become solvable or the equations that will be
included, we employ an online version of Gaussian
elimination in order to form and solve the resulting
system. In this way, the attacker can begin collecting
leaks and gradually feed them to our Gaussian solver
until he is notiﬁed that a sufﬁcient number of indepen-
dent equations have been collected. Note that regular
Gaussian elimination uses both elementary row and el-
ementary column operations. However, because we do
not have in advance the entire linear system we cannot
use elementary column operations. Instead we make
Gaussian elimination using only elementary row oper-
ations and utilize a bookkeeping system to enter equa-
tions in their place as they are produced by the leaks
supplied to the solver. Our solver employs a sparse
vector representation and is capable of solving overde-
termined sparse systems of tens of thousands of equa-
tions in a few minutes.
We ran a sequence of experiments to determine the
solvability of the system when a different number of
bits is truncated from the output. In addition we ran
experiments when the outputs of the MT generator is
passed through the PHP truncation algorithm, with dif-
ferent user deﬁned ranges. All experiments were con-
ducted in a 4× 2.3 GHz machine with 4 GB of RAM.
In Figure 5 we present the number of equations
needed when the PHP truncation algorithm is used.
In the x-axis we have the logarithm of the number
of buckets. We also show the standard deviation ap-
pearing as vertical bars. It can be seen that the num-
ber of equations needed is much higher than the the-
oretical lower bound of 19937 and ﬂuctuates between
27000 and 33000. Neverthless, the number of leaks re-
quired is decreasing linearly to the number of buckets
we have. The reason is that although we have more lin-
early dependend equations, the total number of equa-
tions we obtain due to the larger number of buckets is
bigger.
Implementation error in the PHP system. The
PHP system up to current version, 5.3.10, has an error
in the implementation of the Mersenne Twister gen-
erator (we discovered this during the testing of our
solver). Speciﬁcally the following basic recurrence is
effectively used in the PHP system due to a program-
ming error:
xk+n = xk+m ⊕ ((xk ∧ 0x80000000)|(xk+1 ∧ 0x7ffffffe)|(xk ∧ 0x1))A
As a result the PHP system uses a different generator
which, as it turns out, has slightly more linear depen-
dencies than the MT generator. This means that prob-
ably the randomness properties of the PHP generator
are poorer compared to the original MT generator.
Figure 5: Solving MT; y-axis:number of equations; x-axis: number of buckets (logarithm). Standard deviation
shown as vertical bars.
State recovery for rand()
5.4
We turn now to the problem of recovering the state
of rand() given a sequence of leaks from this gen-
erator. While mt rand() is implemented within the
PHP source code and thus is unchanged across differ-
ent enviroments, the rand() function uses the respec-
tive function deﬁned from the standard library of the
operating system. This results in different implemen-
tations across different operating systems. There are
mainly two different implementations of rand() one
from the glibc and one from the Windows library.
Windows rand(). The rand() function deﬁned in
Windows is a Linear Congruential Generator (LCG).
An LCG is deﬁned by a recurrence of the form
Xn+1 = (aXn + c) mod m
Although LCGs are fast and require a small memory
footprint there are many problems which make them
insufﬁcient for many uses, including of course cryp-
tographic purposes. The parameters used by the Win-
dows LCG are a = 214013,c = 2531011,m = 232. In
addition, the output is truncated by default and only
the top 15 bits are returned.
If PHP is running in a
threaded server in Windows then the parameters of the
LCG used are a = 1103515245,c = 12345,m = 215.
Glibc rand().
In the past, glibc also used an LCG for
the rand() function. Subsequently an LFSR-like “ad-
ditive feedback” design was adopted. The generator
has a state of 31 words (of 32 bits each), over which it
is deﬁned by the following recurrence:
ri = (ri−3 + ri−31) mod 232
In addition the LSB of each word is discarded and the
output returned to the user is oi = ri (cid:29) 1. An interest-
ing note is that the man page of rand() states that rand
is a non-linear generator. Nevertheless, the non linear-
ity introduced by the truncation of the LSB is negligi-
ble and one can easily recover the initial values given
enough outputs of the generator.
State recovery. Notice that if the generators used
have a small state such as the Windows LCGs then
state recovery is easy, by applying the attack from sec-
tion 4 to bruteforce the entire state of the generator.
However, on the Glibc generator, which has a state of
992 bits, these attacks are infeasible assuming that the
state is random. Although LCGs and the Glibc gener-
ators are different, they both fall into the same crypt-
analytic framework introduced by H˚astad and Shamir
in 1985 for recovering values of truncated linear vari-
ables. This framework allows one to uniquely solve
an underdeﬁned system of linear equations when the
values of the variables are partially known. In this sec-
tion we will discuss our experiences with applying this
technique in the two aforementioned generators: The
LCG and the additive-feedback generator of glibc. We
will brieﬂy describe the algorithm for recovering the
truncated variables in order to discuss our experiments
and results. The interested reader can ﬁnd more infor-
mation about the algorithm in the original paper [8].
Suppose we are given a system with l linear equa-
tions on k variables modulo m denoted by x1,x2, . . . ,xk,
1x1 + a1
a1
1x1 + a2
a2
2x2 +··· + a1
2x2 +··· + a2
kxk = 0 mod m
kxk = 0 mod m
. . .
2x2 +··· + al
al
1x1 + al
kxk = 0 mod m
where l < k and each variable xi is partially known.
We want to solve the system uniquely by utilizing the
partial information of the k variables xi.
We use the coefﬁcients of the l equations to create a
set of l vectors, where each vector is of the form vi =
10
(a1, . . . ,ak). In addition we add to this set the k vectors