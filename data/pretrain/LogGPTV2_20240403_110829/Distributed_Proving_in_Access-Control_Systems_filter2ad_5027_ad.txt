domly removing 216 nodes from a complete (3,5,30) tree. The perfor-
mance of the initial access with both forms of caching enabled decreased
by up to 4%, with an average decrease of 2%.
certiﬁcates and in what order to demonstrate that the
certiﬁcates imply that access should be granted (e.g.,
CMU says action(room15)). Appendix C shows how
a particular set of certiﬁcates is formalized in our logic
and provides a proof of access representative of those
generated by our prover; it also explains how we populate
our simulations with certiﬁcates.
5.2. Evaluation Criteria
The primary criteria we use to evaluate the perfor-
mance of the two proving strategies detailed in Section 4
is the number of requests made while attempting to con-
struct a proof. Since requests in our system may ulti-
mately cause an actual user to be queried to approve the
creation of a certiﬁcate, the number of requests roughly
approximates the required level of user interaction. Ad-
ditionally, since much of the communication may be be-
tween poorly connected devices (such as cell phones con-
nected via GPRS), the number of requests involved in
generating a proof will be one of the dominant factors in
determining the time necessary to generate a proof.
When running the simulations, the only principals who
access resources are those located in the lowest level in the
hierarchy. The resources they try to access are rooms on
their ﬂoor to which they are allowed access. Unless other-
wise speciﬁed, the performance results reﬂect the average
over all allowed combinations of users and resources.
5.3. First Access
Figure 5 shows the average number of requests made
by each proving strategy when ﬁrst attempting to prove
access to a resource. On average, lazy outperforms eager
by between 25% and 45%, with the performance differ-
ence growing wider on larger authorization trees. How-
ever, the number of requests made is far too large for ei-
Proceedings of the 2005 IEEE Symposium on Security and Privacy (S&P’05) 
1081-6011/05 $ 20.00 IEEE
s
s
e
c
c
A
r
e
p
s
t
s
e
u
q
e
R
f
o
r
e
b
m
u
N
e
g
a
r
e
v
A
 900
 800
 700
 600
 500
 400
 300
 200
 100
 0
Eager - 1st Access
Eager - 2nd Access
Lazy - 1st Access
Lazy - 2nd Access
(2,1,1)
(2,2,2)
(2,2,10)
(2,4,10)
(2,4,30)
Authorization Tree
Tree
(2,1,1)
(2,2,2)
(2,2,10)
(2,4,10)
(2,4,30)
Tree
(2,1,1)
(2,2,2)
(2,2,10)
(2,4,10)
(2,4,30)
Eager
Principals
First Access
Second Access
Requests
Requests
Lazy
Principals
First Access
Second Access
Requests
Requests
9
17
43
93
253
34.5
65.5
177.5
334.5
894.5
9
17
43
93
253
27.5
44.5
92.5
164
404
STDEV
14.5
29.8
94.3
184.5
507.8
STDEV
11.5
20.4
48.0
88.2
226.7
34.5
65.5
177.5
334.5
894.5
15.5
21.1
47.1
85.1
218.3
STDEV
14.5
32.0
96.5
186.6
509.9
STDEV
10.5
16.3
37.7
69.4
179.3
Figure 6. Performance of subsequent access to a different resource by a different principal
ther strategy to be used in a practical setting. Upon fur-
ther investigation, we discovered that more than half of
all requests are redundant (that is, they are repetitions of
previous requests), indicating that caching would offer a
signiﬁcant performance beneﬁt.
Our initial intuition was to cache proofs of all success-
ful subgoals found by the prover. However, as Figure 5
indicates, caching the results of successful proof requests
offers surprisingly little performance beneﬁt. We discov-
ered that most of the redundant requests will, correctly,
result in failure; that is, most of the redundant requests
explore avenues that cannot and should not lead to a suc-
cessful access. We modiﬁed the caching mechanism to
cache failed results as well as positive results (also shown
in Figure 5). This reduced the number of queries by up to
75% for both strategies.
5.4. Effects of Caching on a Second Access
Since all of the results discovered by the eager strat-
egy are cached only by the principal who accessed the re-
source, the cache is of no beneﬁt when another principal
attempts to access a resource. The lazy scheme distributes
work among multiple nodes, each of which can cache the
subproofs it computes. In the lazy scheme, access of the
same or a similar resource by a second, different principal
will likely involve nodes that have cached the results of
previous accesses. This enables the lazy strategy to take
advantage of caching in a way that the eager strategy can-
not, resulting in signiﬁcant performance gains. To com-
pute the average performance, we ran the simulation for
every possible combination of principals making the ﬁrst
and second access. Figure 6 shows that the average case
eager performance in the second access is identical to its
performance in the ﬁrst attempted, as expected. The ﬁgure
also shows that caching on interior nodes in the lazy strat-
egy decreases the number of requests made by the second
access by approximately a factor of 2. The result is that
lazy completes the second access with approximately one-
fourth the number of requests of eager.
5.5. Automatic Tactic Generation
Caching subgoals and certiﬁcates is clearly helpful
when subsequent requests are identical to those that have
already been proved. Often the second and subsequent
accesses will have different proof goals, in which case
caching will be of limited use even if there is great sim-
ilarity between the two proofs. To take advantage of the
similar shape of different proofs, we introduce automatic
tactic generation (ATG).
Automatic tactic generation aims to remember the
shape of previously computed proofs while abstracting
away from the particular certiﬁcates from which the
proofs are built. In order to leverage the knowledge of the
proof shape gained during the ﬁrst access, the prover must
cache a proof that is not fully instantiated. The proof is
stripped of references to particular resources and nonces;
these are replaced by unbound variables. The certiﬁcates
that were part of the proof, similarly abstracted, become
the subgoals of a new tactic. The stripped proof is the
algorithm for assembling the now abstracted certiﬁcates
into a similarly abstracted goal. This allows any future ac-
cess attempt to to directly search for certiﬁcates pertaining
to that resource without generating intermediate subgoals.
A common scenario in which automatic tactic gener-
ation is very useful is when attempting to access several
rooms on the same ﬂoor. The policies protecting each of
the rooms are likely to be very similar, since they belong
to the same organizational unit and share the same ad-
ministrator. Pure caching is not likely to help much be-
cause the rooms are all named differently, but automatic
tactic generation allows proofs to be computed very ef-
ﬁciently, as shown in Figure 7. ATG is an optimization
allows both the eager and the lazy strategy to complete
subsequent proofs with a minimal number of requests.
Proceedings of the 2005 IEEE Symposium on Security and Privacy (S&P’05) 
1081-6011/05 $ 20.00 IEEE
s
s
e
c
c
A
r
e
p
s
t
s
e
u
q
e
R
f
o
r
e
b
m
u
N
e
g
a
r
e
v
A
 350
 300
 250
 200
 150
 100
 50
 0
s
s
e
c
c
A
r
e
p
l
a
p
c
n
i
r
i
P
r
e
p
s
n
o
i
t
p
u
r
r
e
t
n
I
e
g
a
r
e
v
A
 9
 8
 7
 6
 5
 4
 3
 2
 1
 0
 0
Eager
Eager with ATG
Lazy
Lazy with ATG
Eager
Access
1
2
3
4
Lazy
Access
1
2
3
4
No ATG