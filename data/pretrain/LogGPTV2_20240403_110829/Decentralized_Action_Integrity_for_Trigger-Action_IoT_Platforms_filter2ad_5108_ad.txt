these supported functions. In our example rule, an external
party only needs to call OnNewItem with a String value
of “https://DTAP-cloud.com/new item.” Therefore, the client
can obtain a rule-speciﬁc token scoped to only execute
OnNewItem(‘https://DTAP-cloud.com/new item’). That is, a
scope in DTAP is equivalent to the name of a function in an
online service.
Our design relies on two principles to overcome the
challenge of an increased number of prompts while using
ﬁne-grained tokens:
8
Fig. 4: DTAP authorization has four phases: Channel signup phase, where the clients obtain scope-to-function maps for every
online service; channel connection phase, where the clients gain XTokens to online services the user wishes to use; and trigger
and action setup phases where these tokens are used to request rule-speciﬁc tokens.
will transmit the action XToken, the trigger service’s X509
certiﬁcate, the name of the trigger function (OnNewItem), the
action function name (send_email), the triggering service
user ID of the current user, and any action function parameters
to the action service. The action service will return a rule-
speciﬁc token and will associate all of this information with
that token internally, effectively tying the issued token to a
particular triggering function, a particular action function, and
a particular user.
At this point, the DTAP-Client has obtained two rule-
speciﬁc tokens needed to execute the rule. It transmits these
tokens along with a description of the rule to the DTAP-Cloud
that uses the trigger token to set up a callback to itself whenever
the trigger condition (i.e., new item added to shopping list)
occurs.
We note that rule setup involves the trusted client, and
therefore, depends on the availability of this client. Unlike
in today’s trigger-action platforms that host the rule setup
interface as a highly available cloud service, our design permits
rule programming only when a user client (such as a phone
app or desktop app) is available. We do not view this as a
signiﬁcant shortcoming considering the rarity of rule setup and
overall improvement in security. Furthermore, the most critical
function of trigger-action platforms—executing rules at large
scale—runs independent of the trusted client and therefore
retains the beneﬁts of cloud computing for high reliability and
availability.
Channel Signup. Currently, a trigger-action platform knows
which scopes to request for various trigger and action functions
because channels store that scope-to-function mapping in the
platform’s cloud infrastructure. However, in our case, this
Fig. 5: Inferring user policy via user-driven access control
in DTAP. The DTAP-Client enumerates possible triggers and
actions. When a user clicks on a speciﬁc trigger and action,
DTAP-Client automatically treats that as authorization from
the user to negotiate rule-speciﬁc tokens. There is a one-to-one
correspondence between trigger/action names and the scopes.
• The user authorizes the client to obtain an XToken when a
channel is connected. This does not change the number of
permission prompts for a user—it is the same as existing
trigger-action platforms like IFTTT. The XToken has the
property of allowing the client to obtain a rule-speciﬁc token
without creating a permission prompt, as the user has already
given the client that amount of privilege by authorizing it to
obtain an XToken.
• The client only uses the XToken upon an explicit user
interaction. This notion is inspired by User-Driven Access
Control [38].
Setting up the action part of the rule is similar to setting
up the trigger part. The user will navigate a UI and implicitly
authorize the client to obtain a rule-speciﬁc token to invoke a
particular action function. However, the token exchange process
is slightly different. As Figure 4 shows, the DTAP-Client
9
Trusted ClientTrigger ServiceRequest Trigger Token[Trigger XToken][Trigger Token, Trigger Cert]setup IFTTT Client ContractChannelSignup PhaseChannel Connection PhaseDTAPAction Servicesetup IFTTT Client ContractTrigger Token[Action Xtoken, Action Scope, Action Parameters, Trigger Scope, User ID. Trigger Cert]Action TokenTrigger SetupAction TokenOAuth TransactionScope=XTokenOAuth TransactionScope=XTokenTriggerXTokenActionXTokenAction Setup       Request Action Token  infrastructure is untrusted. DTAP-Cloud could manipulate
scope-to-function mappings to trick the clients into requesting
the wrong scopes. Our design solves this problem by requiring
the online services to create a signed scope-to-function mapping
and host those mappings at a well-known location. An online
service signs its mapping using the private key corresponding to
its X509 certiﬁcate. The clients retrieve these signed mappings
during the channel signup phase (Figure 4).
Rule Execution. At runtime, whenever a new item is added to
the shopping list, the trigger service will generate an HTTP call
to the DTAP-Cloud and pass the trigger data (in our example
rule, this will be the item that was added to the shopping list).
DTAP changes this process slightly, and instead requires the
trigger service to generate a trigger blob (see Figure 6):
T riggerBlob = [T ime, T T L, T riggerScope,
b64(T riggerData), U serID, SIG]
SIG = Sign with SHA256(T riggerServiceP rivateKey,
T ime|T T L|T riggerScope|b64(T riggerData)|U serID)
The public key of the signing trigger service private key was
transmitted to the action service as part of the setup process.
T ime is the timestamp when the blob was created, and T T L
speciﬁes the period for which the blob is valid. Once the trigger
service creates this blob, it will transmit it to the DTAP-Cloud.
At that point, the DTAP-Cloud will lookup the appropriate rule,
and then invoke the action function using the rule-speciﬁc token
it obtained earlier. During this invocation, the DTAP-Cloud
will make an HTTP request and include the trigger blob, the
rule-speciﬁc action token, and parameters.
We note that during rule execution, neither the XTokens,
nor the trusted clients are involved. Execution proceeds only
with the rule-speciﬁc tokens. Therefore, our design retains the
beneﬁts of highly-available cloud services.
End-to-End Rule Veriﬁcation. The DTAP-Cloud executes the
rule by transmitting the trigger blob and the action token to
the action service (Fig. 6). The action service will ﬁrst execute
a lightweight veriﬁcation process before invoking the target
function. The veriﬁcation steps are:
V1: Verify that the passed rule-speciﬁc token exists.
V2: Verify the signature on the trigger blob using the X509
certiﬁcate of the triggering service. b64 denotes base 64
encoding. The action service does not need to interpret the
format of the triggering data. It just needs to verify the
signature over the entire triggering blob, which contains
base 64 encoded trigger data.
V2.1: Ensure that T ime > P reviousT ime where T ime is
an extracted time stamp from the passed trigger blob,
and P reviousT ime is the previously seen value for this
triggering service. This prevents replay attacks from a
compromised DTAP-Cloud if the attack occurs inside the
TTL (see below). In practice, this requires reasonably
precise timestamps.
V2.2: Verify that T T L  P revT ime) and time-to-live value ([V2.2]:
T T L  80. However, the DTAP-Cloud might simply
ignore the result of the comparison, and invoke the action
service repeatedly. The veriﬁcation on the action end will
succeed since DTAP-Cloud will obtain a valid signed trigger
blob when it polls the trigger service.
DTAP handles such situations by allowing the client to
associate a predicate with the action token. This predicate is
expressed over ﬁelds of the trigger data part of the signed
trigger blob. The DTAP-Client simply maps the condition the
user sets up while creating the rule to a predicate and then
instructs the action service to associate the predicate with the
resulting rule-speciﬁc token. At runtime, the action service
performs the additional step of verifying that the predicate is
true.
Encoding such stateless predicates handles a signiﬁcant
fraction of the kinds of conditions that trigger-action platforms
supports. We studied the triggers, actions, and online service
APIs for 24 of the top channels in the IFTTT platform and
did not ﬁnd any predicates that required storing state. We also
studied the Zapier channel creation process but did not ﬁnd
any resources for channels to keep state [18]. Moreover, all
Zapier predicates only involve simple boolean operators. Our
prototype fully supports expressing such rules.
D. Deployability of DTAP
We stress that our intent is to provide a starting point
for the community to improve the security of trigger-action
platforms from the ground up. Therefore, DTAP is a clean
slate design. However, there are several components of DTAP
that are readily deployable, and there are a few components
that can be deployed with some effort. Below, we structure our
discussion around the software components that DTAP design
impacts.
• OAuth 2.0 Protocol: DTAP additions to OAuth are fully
backward compatible on the wire. In order to provide
Decentralized Action Integrity, no changes are required to
existing software implementing the protocol. We conclude
that the protocol additions are readily deployable.
• Online Services: DTAP does require changes to the
online services that provide trigger and action APIs.
Speciﬁcally, the online services need to understand rule-
speciﬁc tokens and XTokens. As we will discuss in §VI,
we have implemented a library that online services can
use to gain the beneﬁts of Decentralized Action Integrity.
Developers would have to make one-line additions for each
API call they want to protect using rule-speciﬁc tokens.
Furthermore, to easen this transition process, in §VII, we
11
outline a proxy-based approach to incrementally introduce
DTAP support in online services.
• Trigger-Action Platforms: DTAP does not
require
changes to the cloud component of the trigger-action
platforms. We prototyped a version of DTAP that uses