continue
c o v e r a g e
n e w s i g = True
f or sig in s i g n a t u r e s
sig request set = g e t s i g n a t u r e r e q u e s t s ( sig )
# c h e c k
i f token request set = sig request set
same r e q u e s t s we a l r e a d y have s i g n a t u r e
f o r
i f
sig . append ( token )
n e w s i g = F a l s e
break
# I f new to ken , add i t
t o s i g n a t u r e
i f n e w s i g or l e n ( s i g n a t u r e s ) == 0
s i g = n e w s i g ( t o k e n )
s i g n a t u r e s . append ( s i g )
# Add f u l l
f o r sig in s i g n a t u r e s
c o v e r a g e t o k e n s
f or f ull cov token in f u l l c o v t o k e n s
sig . append ( f ull cov token )
t o a l l
s i g n a t u r e s
return s i g n a t u r e s
}
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
5.1 Signature Generation
For each trafﬁc cluster, signature generation creates a signature cluster comprising a
set of signatures and, for each signature, a set of requests (i.e., feature vectors) used to
generate it. From the feature vectors of a signature it is straightforward to obtain the set
of ports, IPs, endpoints, and malware binaries of the signature.
Algorithm 1 describes the signature generation. Its salient characteristics are that
the tokenization is performed on ﬁelds and that multiple signatures may be generated
for each trafﬁc cluster. For each ﬁeld in the requests in the trafﬁc cluster, it identiﬁes
distinctive tokens i.e., tokens with high coverage and low false positives. We deﬁne the
false positive rate of a token in a ﬁeld to be the fraction of requests in the benign pool
that contain the token in the ﬁeld, over the total number of requests in the benign pool.
We deﬁne two coverage metrics. The request coverage is the fraction of requests in the
trafﬁc cluster with the token in that ﬁeld, over the total number of requests in the trafﬁc
cluster. The ﬁle coverage is the fraction of malware binaries that have a request in the
cluster with the token in that ﬁeld, over the total number of malware binaries with at
least one request in the cluster. A token is distinctive if it has a ﬁle coverage larger
than 0.4 and a false positive rate below 10−9. The reason to use the ﬁle coverage to
consider a token distinctive is that we are interested in signatures that match as many
binaries as possible from the same family. The request coverage is used by Algorithm 1
for identifying tokens present on the same requests.
11
Algorithm 1 can generate multiple signatures because distinctive tokens do not need
to appear in all requests in the trafﬁc cluster. For example, the requests in a trafﬁc cluster
may have been grouped because they all have the same URL path. In addition, 50% of
them could have a distinctive User-Agent value and the other 50% a different one. In
this case, the signature generation may output two signatures, each with the distinctive
URL path and one of the two User-Agent values.
The get distinct ﬁelds function returns all ﬁelds in the tree, except ﬁelds that encode
integer values, which should not be tokenized (e.g., the Content-Length HTTP header),
and ﬁelds that contain endpoints (e.g., Host HTTP header) because this information is
used in later steps. The tokenize function uses a sufﬁx array [1] to extract tokens larger
than 5 bytes that appear in the set of unique ﬁeld values.
5.2 Signature Merging
Signature merging identiﬁes signatures in different signature clusters with similar to-
kens. It detects requests with similar content in their data ﬁelds, which ended up in dif-
ferent trafﬁc clusters because they were not similar on other ﬁelds or transport features.
For each pair of signatures from different clusters, it computes the longest common
subsequence between each pair of signature tokens. If it ﬁnds a common subsequence
larger than 7 bytes, it merges the two signatures into one and combines their corre-
sponding clusters. For example, if the signature generation returns the following two
signature clusters:
SC-153 S1: "|9ad698334c|", |deadbeef5f01000001000000|"
SC-172 S1: "|deadbeef5f01000001000000|"
S2: "|98760a3d78675d|"
the signature merging identiﬁes the common token between the ﬁrst signature in cluster
153 and the ﬁrst signature in cluster 172. It merges both signatures, unions their feature
vector sets, and combines their clusters. The resulting signature cluster is:
SC-(153+172) S1: "|deadbeef5f01000001000000|"
5.3 Signature Clustering
Signature clustering identiﬁes signature clusters that correspond to different network
behaviors of the same family and merges them into family clusters. For this, it uses the
ﬁle identiﬁers and the endpoint information. The intuition for using the ﬁle identiﬁers
is that a malware binary belongs to a single family. Thus, if two signatures have been
generated from trafﬁc by the same malware binary, those signatures belong to the same
family and should be part of the same family cluster. The intuition for using the endpoint
information is that C&C servers are speciﬁc to a family. Thus, if two signatures have
been generated from trafﬁc sent to the same endpoint, they belong to the same family.
Note that benign endpoints (e.g., yahoo.com) may be contacted by multiple families
but those have been removed in previous steps. Note also that even if the C&C IPs and
domains of a family are fully polymorphic (i.e., never reused) the binaries in the family
may already have been grouped at prior steps due to other similarities in their trafﬁc.
12
Signature clustering extracts the set of endpoints and ﬁle identiﬁers for a signature
cluster from the feature vectors for each signature. For each pair of signature clusters,
if the intersection of their endpoint sets or ﬁle identiﬁer sets is not empty, both clusters
are merged by doing the union of their signature sets.
5.4 Signature Finalization
This section describes the ﬁnal steps required to output the signatures.
Signature encoding. The encoding component outputs the signatures in a format suit-
able for Snort and Suricata. While both use a similar syntax there are some differences
between them, e.g., their protocol support. For each signature, it extracts the set of ports
from the feature vectors, selects the carrier protocol, adds the family cluster and signa-
ture identiﬁers to the metadata, and for tokens in ﬁelds parsed by the IDS, it selects the
appropriate modiﬁers for the content (e.g., http method, http header).
Signature validation. The validation component removes signatures that produce false
positives or have little coverage. First, it removes signatures with no content tokens
and counts how many such signatures it removes from each family cluster as these are
highly indicative of fully polymorphic trafﬁc. Then, it runs the signatures using the ap-
propriate IDS on the benign trafﬁc pool and removes signatures that match any trafﬁc
since their false positive rate will only increase on live trafﬁc. Then, it runs the remain-
ing signatures on the input network traces, tracking which signatures match trafﬁc from
which malware binary. If the ﬁle coverage of a signature in its cluster is below 0.4%,
the signature is removed since it is too speciﬁc and unlikely to match other binaries of
the same family.
Signature minimization. The resulting signatures for a family cluster may overlap,
i.e., the ﬁle coverage of a signature in a cluster may be a superset of the ﬁle coverage
of another signature in the same cluster. Overlapping signatures provide additional ro-
bustness for online monitoring. However, for ofﬂine classiﬁcation with a ﬁxed malware
dataset, the analyst may be interested in removing those overlaps for efﬁciency. If so,
FIRMA offers an option for minimizing the signatures for each family cluster, while
guaranteeing that all malware binaries in the cluster would be matched by at least one
remaining signature. This optional feature is an instance of the optimization version of
the set-cover problem where the universe is all malware binaries in the cluster, and the
sets correspond to the ﬁle coverage of each signature in the cluster. This problem is
known to be NP-hard but a greedy algorithm can efﬁciently approximate it by choosing
at each step the set that contains the largest number of uncovered elements [8].
6 Evaluation
This section presents our evaluation of FIRMA. We ﬁrst describe our datasets (Sec-
tion 6.1), then we present a quantitative evaluation of the different steps in FIRMA
(Section 6.2), and ﬁnally we perform a qualitative comparison of the signatures pro-
duced by FIRMA with manual ones (Section 6.3).
Dataset Dates
MALICIA 03/2012 - 02/2013
MIXED 03/2012 - 04/2012
Binaries Runs Requests HTTP SMTP IRC TCP UDP
10,600 20,724 495,042 15.9% 1.1% 0% 3.0% 80.0%
97,559 94.5% 0.7% 0.02% 2.0% 2.8%
5,250 10,520
Table 1. Datasets used in the evaluation.
13
6.1 Datasets
To evaluate FIRMA we use two malware datasets [12, 24], summarized in Table 1.
Both datasets contain a variety of recent malware and their trafﬁc exhibits common
obfuscation techniques such as encryption and polymorphism (in IPs, domains, and
payloads). The MALICIA dataset is publicly available and comprises malware binaries
collected from drive-by downloads from March 2012 to February 2013 [23, 24]. The
malware binaries have been classiﬁed into families using static icon information, as well
as screenshots and network trafﬁc obtained by executing the binaries. In addition to the
public dataset, we have the network signatures manually generated in that project. We
use the given classiﬁcation as ground truth to evaluate the malware clustering produced
by FIRMA and compare the signatures automatically generated by FIRMA with the
manually generated ones.
The MIXED dataset comprises 10,520 network traces obtained by executing 5,250
binaries. These binaries are a subset of the ones analyzed in [12] and were collected
from a variety of feeds that include drive-by downloads, P2P, and spam. We do not
have access to the malware binaries themselves but only to the network traces, the
mapping from each network trace to the MD5 hash of the binary that produced it, and
the containment policy used in the run.
Table 1 shows for each dataset the malware binaries that exhibit network trafﬁc,
the malware executions, and the requests sent by the malware, as well as the split of
the requests by protocol. The average number of pcaps for each malware is close to
2 in both datasets as some malware binaries are run multiple times with different VM
software, execution duration, and containment policies. In the MIXED dataset, HTTP
trafﬁc is most common, followed by generic TCP and UDP trafﬁc and smaller amounts
of SMTP and IRC trafﬁc. The MALICIA dataset shows a surprisingly large number
of UDP requests, which are due to the highly verbose zeroaccess family that produces