but instead using an optional ephemeral Difﬁe-Hellman
key exchange authenticated by those long-term secrets.
Combining perfect forward secrecy with IBC automati-
cally avoids the key escrow facilities present in identity-
based systems.
4.2.1
IBC and Pre-shared Keys
If the domain-params of the two parties are related, we
have another option. At the limit, if the two parties be-
long to the same domain (i.e. have the same domain-
params – the same group-params and domain-public-
key), and they know each others’ identities a priori, they
can use noninteractive IBC-based key exchange proto-
cols to establish a shared secret key without sending any
messages at all [14, 25]. This approach is appealing
(e.g. [1]), but only applicable to members of the same
security domain, and results in a key that is subject to
escrow. In practice, hosts using IKE to establish secu-
rity associations already have to exchange a number of
preliminary messages, e.g. nonces for freshness, propos-
als for choices of algorithms, or keying information for
PFS. Therefore, they may not be able to take best ad-
vantage of the noninteractive nature of these protocols.
Additionally, the hosts involved, the responder in par-
ticular, may not know the other’s identity a priori un-
less it is available as the IP address in current use, or
a hostname available through reverse DNS. While these
noninteractive protocols can be slightly more computa-
tionally efﬁcient than other approaches to using IBC, the
narrow set of circumstances in which they can be used,
and the potential difﬁculty in determining whether those
circumstances actually apply, make them less appealing.
If the group-params of the two parties are the same, re-
gardless of whether their domain-public-keys are differ-
ent, then they can use a key exchange protocol similar to
(but slightly less efﬁcient than) the noninteractive proto-
cols described above [4, 5]. This would happen if they
belonged to different domains, and those domains used
the same choice from among the standard sets of group-
params. This protocol is illustrated in Figure 5. The
resulting protocol avoids the shortcomings of the nonin-
teractive protocols – it is applicable to hosts from differ-
ent domains, and does not suffer from key escrow. The
resulting protocol is effectively a pre-shared key proto-
col that uses additional elliptic curve Difﬁe-Hellman in-
formation in the computation of the session key. These
additional Difﬁe-Hellman values are directly analogous
to the Difﬁe-Hellman values used in IKE to provide PFS
(and in fact do act here to provide PFS), and can be ex-
changed in the same key exchange (KE) message that
standard Difﬁe-Hellman values would be. The resulting
protocol ﬁts neatly into IKE’s pre-shared key authenti-
cation method, and is illustrated in Figure 6.
The only limitation of the IKE pre-shared key protocol
in general is that the two peers do need to know each
other’s identities – whether they are using IBC (so they
can compute the key) or share a traditional static key (so
they know which key to use). That means that either
they must use aggressive mode so that the identities are
exchanged in the ﬁrst set of messages, or the initiator
must know the identity of the responder, either a priori
or because the responder’s identity is either its IP address
or a hostname available through reverse DNS lookup.
To use IBC in PSK mode, both peers must know that
they are using the same IBC group-params. To achieve
this, they exchange information about the group-params
in the proposal payloads they use during SA negotiation
to suggest the use of PSK. IKE provides standard mech-
anisms for exchanging group information in the pro-
posal payloads, which were designed originally to iden-
tify the Difﬁe-Hellman groups used for achieving PFS.
The same approach can be used to identify IBC group-
params, and supports both the description of arbitrary
group-params and the use of short identiﬁers that indi-
cate the use of commonly used standard sets of group-
params. Such standardized sets of parameters are used
by most hosts for Difﬁe-Hellman exchanges in IKE, and
we anticipate that such standard group-params would be
used by most domains in DNSIBC.
5 Implementation
We have built a preliminary version of this system un-
der Linux. Our implementation takes advantage of ex-
tensive DNSSEC support present in both the standard
implementation of bind, the Unix DNS server program,
and in pluto, the IKE daemon used by Free S/WAN, the
most common IPSEC implementation for Linux.
5.1
IBC Libraries
For our initial implementation we wrote a 100%-Java
implementation of the low-level ﬁeld, elliptic curve, and
Tate pairing operations necessary to perform identity-
based cryptography. This work is based on the C imple-
mentation of identity-based encryption available at [28].
Our Java library is used by our PKG server and email
224
12th USENIX Security Symposium 
USENIX Association
Responder
Initiator
HDR, SA,xiP, Ni, IDii −→
HDR*, HASHI −→
←− HDR, SA, xrP, Nr, IDir, HASHR
Keys and authentication values used in protocol are computed as follows:
SKEYID = prf(Kpsk, Ni || Nr)
HASHI = prf(SKEYID, xiP || xrP || CKY-I || CKY-R || SAi || IDii)
HASHR = prf(SKEYID, xrP || xiP || CKY-R || CKY-I || SAi || IDir)
Symbols are as in Figure 5, with additional symbols deﬁned as follows:
HDR ISAKMP header
nxiP, xrP as in Figure 5, sent in an ISAKMP KE payload
HDR* ISAKMP header, payload encrypted under xixrP (also used in computation of Kpsk)
SA SA negotiation payload with one or more proposals from initiator, one choice from responder
Ni,Nr
HASHI,HASHR
initiator and responder nonces
initiator and responder hashes
prf(key,msg) keyed pseudorandom function
CKY-I,CKY-R initiator and responder cookies, respectively
SAi
the body of the entire SA payload sent by the initiator
Figure 6: Identity-based version of IKE’s pre-shared key authentication protocol. Aggressive mode is illustrated here,
main mode is similar.
client. We are working to complete a C port of our li-
brary for use in our IKE implementation.
5.2 DNS Support
We have modiﬁed a DNSSEC-compliant version of the
Unix name server program, BIND, to support the distri-
bution of signed parameter and salt records, as shown in
Figure 4. These parameters are initially inserted in the
DNS during the setup phase of the PKG, and are updated
as necessary.
The PARAMS resource record type is implemented as a
modiﬁed KEY record, with RR type 44. The PSALT re-
source record type is implemented as a modiﬁed text
(TXT) record type, with RR type 45.
5.3 Private Key Generation Service
In a fully deployed system, there are many ways to im-
plement a PKG that provide different amounts of auto-
conﬁguration and different levels of protection on the
domain master secret. In our implementation, we have
chosen to maximize ease of use and simplicity of setup,
in order to encourage deployment.
Our PKG is a standalone program written in Java. On
ﬁrst conﬁguration of a domain (or re-keying of an ex-
isting domain), the PKG runs a setup sub-program that
allows an administrator to select one of the standard sets
of domain parameters (see Section 2.1) or to generate
her own. The administrator also indicates how the mini-
mum interval permissible before compromised keys can
be revoked; this is controlled by the salt lifetime (see
Sections 2.1,2.2). The setup program then creates a mas-
ter secret and initial salt, and stores both these and the
system parameters in two ﬁles: one appropriate for use
by the PKG service, and another suitable for incorporat-
ing into a DNS zone ﬁle. This latter step could also be
implemented using DNS dynamic update.
The PKG service then starts on a machine inside the do-
main network.
It listens for connections on a known
port (5599), and secures them using SSL/TLS, using a
self-signed certiﬁcate (obtained from Java’s keytool)
that was previously distributed to clients. Clients con-
nect to the service to obtain their keys either on ﬁrst
initialization, or on change of salt. Authentication of
clients is done using the simple “in-vs-out” determina-
tion described in Section 2.3, based on the desired iden-
tity (email address or FQDN) provided by the client. Pri-
vate keys, parameters, and the current salt are returned
to clients as XML-encoded data protected by the SSL
tunnel. Clients then store their new private keys in the
location and manner appropriate to them.
USENIX Association
12th USENIX Security Symposium 
225
To support salt updating, the current salt is passed either
on the command line or in a conﬁguration ﬁle. Updating
the PKG to issue private-keys derived from the new salt
is a simple matter of restarting the PKG.
5.4 Email Client
As a preliminary proof of concept, we have implemented
a standalone mail client in Java that can send and re-
ceive email encrypted with IBE using domain parame-
ters pulled from a DNS server modiﬁed as above.
To send encrypted email, our client uses the dnsjava
package [29], which we modiﬁed to accept and parse
the new PARAMS and PSALT DNS resource records. Our
client encrypts the message using our Java IBC libraries,
encodes it as an XML string, and sends it to the recipi-
ent’s mail server using the javax.mail package.
Upon receiving the ﬁrst encrypted email message, our
client pulls the current salt and its own private-key from
the PKG and stores them in a keystore in the local
ﬁlesystem. On subsequent encrypted email messages
received, the client queries the PKG for the latest salt
if the current salt’s TTL has expired; if the salt changes,
it requests a new private-key.
In our implementation,
the domain-params are included in the private-key, so
there is no need to perform a separate check for changed
domain-params.
We note that decryption of email is completely transpar-
ent to the user: no interaction whatsoever is required pull
keys and decrypt messages.
In future work, we would like to incorporate support
for domain-based IBC parameters into the existing IBE-
based plugins for Outlook and Eudora [28].
5.5
IKE Client
as necessary from the PKG the ﬁrst time it runs, and up-
dating them on expiration of the domain’s salt.
We use the fully-qualiﬁed domain name FQDN to iden-
tify IPsec hosts, because it allows us to easily support
IBC-based IPsec to hosts that use DHCP to obtain their
addresses, even if those hosts are currently roaming out-
side their home domains (a “road warrior” conﬁgura-
tion). For those modes of IKE where the responder does
not send the initiator their identity before it is needed to
derive their public key (e.g. both modes authenticated
with public key encryption, and main mode authenti-
cated with pre-shared keys), the initiator must already
know the responder’s identity, or be able to use reverse
DNS on their IP address to determine their identity. This
is not an extreme limitation, as you frequently know with
whom you are initiating a communication with. If it is
an unacceptable limitation, an IP address can be used as
a host’s id without change to any of the above protocols.
6 Related Work
While the value of identity-based encryption for secur-
ing email has been recognized for some time [2], only
recently have other uses for IBE, and IBC in general,
begun to be explored. Much of this work has been at the
level of cryptographic primitives, focusing on identity-
based signature schemes ([3, 16, 23]) and key exchange
protocols ([5, 25, 27]). While much of the work on
identity-based cryptography has focused on the model
where there is one global trust infrastructure, and one
trusted IBC key generator, more recent work has begun
to describe primitives that work with less restrictive trust
models. This began with work on hierarchical organiza-
tions of IBC trust centers [14, 17], and has continued
with the design of protocols which work between users
in different trust domains that share some of their math-
ematical parameters [4, 5]. We have been able to make
use of this latter work in our own (see section 4.2.1).
The basis of our initial implementation of an IBC-
enabled IKE daemon is a modiﬁed version of pluto,
the IKE daemon provided as part of FreeS/WAN [13].
This implementation was chosen because FreeS/WAN
is widely used under Linux, and already provides exten-
sive support for retrieving public keys from DNSSEC.
As pluto does not provide complete support
for
use of public-key encryption to authenticate IKE ex-
changes, we are concentrating on implementing the
IBC signature-based and preshared-key based modes de-
scribed in Section 4. Again, our modiﬁed pluto is de-
signed for autoconﬁguration, requesting its private keys
Appenzeller and Lynn [1] have suggested using the non-
interactive identity-based key exchange protocols sug-
gested by Sakai et al. and others [14, 25] to secure net-
work trafﬁc. While their work is very much in the spirit
of ours, it suffers from a number of critical limitations.
First, it will only support communication between hosts
in the same IBC trust domain. As we note in the intro-
duction, a global IBC trust system is not a realistic de-
ployment scenario. Second, it is a non-standard, special-
purpose protocol. As such, it has not been analyzed in
any detail, and has no deployment support. In contrast,
our approach is to support communicating peers who do
226
12th USENIX Security Symposium 
USENIX Association
not belong to the same trust domain, and to enable IPsec
to use IBC to secure network trafﬁc. While IPsec it-
self is not a perfect protocol, it is extremely widely de-
ployed, studied and supported, and is subject continuing
improvement. Therefore, the general approach to IBC-
enabled IPsec presented here seems the most effective
way to leverage IBC’s deployment advantages to secure
network trafﬁc.
7 Advantages Over Alternative
Approaches
We believe that our approach offers a number of ad-
vantages over existing methods for key distribution to
secure email and network trafﬁc. In particular, we be-
lieve that our scheme, with its emphasis on autoconﬁgu-
ration, makes it simple enough to deploy these technolo-
gies that they could begin to see much more widespread
use. In this section, we compare DNSIBC to alternative
approaches.
7.1 Distribution of Trust