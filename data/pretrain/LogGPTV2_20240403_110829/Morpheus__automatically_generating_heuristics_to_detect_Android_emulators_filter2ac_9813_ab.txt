|D| .
Intuitively, our heuristics should at least perform better than
a 50/50 guess. Thus, we choose Type E and Type D arti-
facts from all the artifacts in both pools according to their
values of COVE(a) and COVD(a) as follows:
• Type E artifacts: COVE > 50%, COVD  50%
3.3.2 Content-based Heuristics
However, there are plenty of artifacts that are prevalent
in both emulators and real devices. For example, Android
APIs would have both COVE and COVD larger than 50%.
Inspired by Hamsa [16], we propose a category of detec-
tion heuristics whose decisions are based on tokens, where
token is a contiguous byte subsequence in the contents of
an artifact. Similar to what we introduce for artifact-based
heuristics, we attempt to ﬁnd Type E and Type D tokens.
Speciﬁcally, for an artifact a and its retrieved contents
in E-Pool, we extract a set of tokens by computing com-
mon substrings among the contents. We then extract an-
other set of tokens for D-Pool. Combining these two sets
of tokens as a token set T , we compute COVE(a, t) and
COVD(a, t), which are the fractions of instances in E-Pool
and D-Pool whose contents of artifact a contain token t, i.e.,
COVE(a, t) = |Ea,t|
. Based on the
|E|
values of COVE(a, t) and COVD(a, t), we select two type of
tokens as our content-based heuristics as follows:
and COVD(t) = |Da,t|
|D|
• Type E tokens: COVE > 50%, COVD  50%
There are various algorithms that eﬀectively compute com-
mon substrings. We opt for a suﬃx array in our heuristic
extractor. Constructing a suﬃx array runs in O(nlogn) time
in worst case scenario and consumes 5n bytes of memory,
where n is the total size of the contents of an artifact in a
pool. Extracting tokens from the constructed suﬃx array
can be implemented using a binary search. Furthermore, as
we prefer longer tokens in the context of generating detec-
tion heuristics, we add one more step to prune tokens that
are substrings of the other tokens as long as they share the
same COVE and COVD.
The output of the heuristic extractor is a set of Type E and
Type D heuristics. Each heuristic is represented as a 3-tuple
(artif act, token, type). token can be null for artifact-based
heuristics. type implies the decision to be made once the ob-
served artifact/token matches the artifact/token speciﬁed in
the heuristic. The matched Type E heuristics indicate em-
ulators and the unmatched ones indicate real devices. Con-
versely, Type D heuristics imply the opposite decision.
3.4 Heuristic Selector
We propose the heuristic selector to rank the candidate
detection heuristics generated by the heuristic extractor. In
general, we reduce the problem of ranking the candidates
to the problem of feature selection in supervised learning.
E-Pool and D-Pool comprise a training set consisted of in-
stances that are correctly labeled with “emulator” or “real
device.” Furthermore, we have extracted a set of detection
heuristics that can be considered as binary features. Now
we need to select the relevant and non-redundant detection
heuristics that would best classify future observations.
We propose to use a random forest [14], which is an ensem-
ble learning method that leverages a multitude of decision
trees for classiﬁcation. Each individual decision tree covers a
random subset of the features and is trained with a random
subset of training samples. Afterwards, the random forest
ﬁts the training set by letting each decision tree predict its
unseen samples and evaluate the errors. During this process,
an importance score for each feature is measured based on
how signiﬁcant the error rate would change if the feature is
removed from the decision trees.
We use this importance score as a metric to rank the can-
didate heuristics. On one hand, relevant heuristics that
contribute much to classiﬁcation naturally get higher im-
portance scores. On the other hand, redundant heuristics
that exploit the same artifact/token as other heuristics are
assigned zero or lower importance scores. As such, the ﬁnal
output of the heuristic selector is a set of relevant and non-
redundant detection heuristics as sorted by their importance
scores derived from the random forest.
As the number of detection heuristics is much larger than
the number of instances in the pools, the random forest may
suﬀer from over-ﬁtting, which overestimates the importance
level of some heuristics. To suppress over-ﬁtting, we choose
to increase the number of decision trees in the random forest.
As more trees are added, its tendency to over-ﬁt generally
decreases as no single feature can aﬀect every decision tree.
4. FINDING DETECTION HEURISTICS
We ran our experiments with Morpheus against QEMU-
based Android SDK emulators [1], VirtualBox-based Geny-
motion emulators [2], and real devices. In this section, we
elaborate our experiments that lead to the ﬁndings of 10,632
detection heuristics. We then characterize the heuristics ac-
cording to the underlying discrepancies that they exploit.
4.1 Experimental Setup and Findings
To understand the observable artifacts in the reference
Android devices, we adopted an instance of the SDK emu-
lator and a Galaxy Nexus phone that both run Android 4.4.
We traversed their mounted ﬁle systems to obtain the secu-
rity attributes of objects. We then acquired a copy of the de-
fault SELinux policy from the Android Open Source Project
(AOSP). Using these as inputs, the sandbox analyzer iden-
tiﬁed 33 sources of observable artifacts. However, retrieving
all of them requires plenty of domain-speciﬁc knowledge for
tasks such as enumerating artifacts and constructing valid
inputs. In this work, we only retrieved 3 sources that could
possibly lead to discrepancies and cover a suﬃcient number
of observable artifacts.
Procfs and Sysfs: Procfs and sysfs are both pseudo
ﬁle systems that expose kernel objects to userspace pro-
grams. Speciﬁcally, procfs presents system information, such
as loaded kernel modules, mounted ﬁlesystems, and net-
work stacks. Sysfs exports hardware information such as
connected block devices, buses, and power states. Our im-
plementation of the artifact retriever traversed these two
ﬁle systems mounted at /proc and /sys. In particular, we
slightly adapted the directory walker to handle looped sym-
bolic links that are prevalent in procfs and sysfs.
Android APIs:
A large number public and hidden
APIs are exposed by Android system services. For example,
TelephonyManagerService exposes APIs that return unique
device identiﬁers to applications. Actually, the APIs are
implemented with the underlying Binder IPC framework,
which handles the IPC between applications and system ser-
vices through a Binder device node located at /dev/binder.
To probe APIs behind Binder, we implemented two ap-
proaches in the artifact retriever. We used the reﬂection-
based Java function caller to enumerate and call APIs. We
also adapted the Binder IPC caller to construct and send
IPC messages to the remote system services. The returned
Java objects and Binder IPC messages were converted into
byte sequences as the retrieved artifacts’ contents. For Java
objects that are not of Java primitive types, we leveraged
their toString method to acquire more information about
them. In this paper, we are particularly interested in An-
droid APIs that do not have any input parameters. Ac-
cording to [22], such APIs are more likely to be “sources
that return non-constant values into application code.” As
a result, we covered approximately 15% of the 1,326 APIs
exposed by Android system services.
Android System Properties:
Similar to the Win-
dows registry, Android includes a subsystem that centrally
stores system conﬁgurations and status. This subsystem,
usually dubbed as “property system,” has been extensively
used by Android system services. For example, a system
property ro.kernel.qemu is read by the Android debugging
bridge daemon (adbd) to determine the presence of emula-
tors. System properties also cover meta information about
the hardware, such as device models and manufacturers. De-
Table 1: Discovered Detection Heuristics
Pools
D-Pool + E-Pool
D-Pool + EQ-Pool
D-Pool + EV -Pool
Total
Detection Heuristics
File API Property Total
2,284
2,121
3,256
2,961
5,092
4,782
9,864
10,632
82
132
160
374
81
163
150
394
spite that SELinux in Android protects system properties,
we inspected the implementation of the property system and
found that the security check is only in the function prop-
erty_set(), meaning that SELinux does not prevent read-
ing system properties at all. Moreover, applications are al-
lowed to read /dev/__properties__, which is the interface
to system properties. Therefore, system properties are ob-
servable by every installed application. To retrieve system
properties, we adapted the artifact retriever to call a binary
executable located at /system/bin/getprop. It enumerates
system properties so that the Java function caller can read
the contents of each property. We note that this executable
is only for the artifact retriever. It is not required by the
detection heuristics that read system properties.
Afterward, we ran the adapted artifact retriever against
16 instances of QEMU-based SDK emulators, 11 instances
of VirtualBox-based Genymotion emulators, and 25 real de-
vices. The SDK emulators covered three CPU architectures,
namely ARM, x86, and MIPS. The Genymotion emulators
covered x86, which is the only architecture they support.
Both emulator types covered Android versions from 2.3 to
4.4. The real devices covered four manufacturers (Samsung,
HTC, Motorola, and LGE), three ARM SoC families (Qual-
comm Snapdragon, Texas Instruments OMAP, and Nvidia
Tegra), and Android versions from 2.1 to 4.4. In particu-
lar, the real devices were borrowed from the participants we
recruited through university mailing lists under the study
protocol reviewed by our institution’s IRB. Anecdotally, it
took approximately 5-20 minutes for the artifact retriever to
retrieve and upload the observable artifacts on each device.
The retrieved artifacts contributed to four pools for QEMU-
based emulators (EQ-Pool), VirtualBox-based emulators (EV -
Pool), all the emulators (E-Pool), and real devices (D-Pool).
We then fed these pools to the heuristic extractor and the
heuristic selector. The heuristic selector ranked the candi-
date heuristics with 10,000 decision trees and pruned the
heuristics with zero importance scores. Table 1 shows a
breakdown of the discovered 10,632 detection heuristics. In
the remainder of this paper, we will respectively refer to
these three categories of heuristics as ﬁle heuristics, API
heuristics, and property heuristics, in the interest of brevity.
4.2 Characterizing Detection Heuristics
Next, we characterize the discovered heuristics based on
the discrepancies they exploit. We ﬁrst discuss the common
detection heuristics that exploit the discrepancies shared by
both QEMU-based and VirtualBox-based emulators. We
then discuss the heuristics that leverage the QEMU-speciﬁc
or VirtualBox-speciﬁc discrepancies, respectively. Our dis-
cussion does not aim to be exhaustive, instead we attempt
to convey the scope of discrepancies in Android emulators.
Considering that an attacker can possibly use this section
as hints to craft detection heuristics, we suggest provisional
but deployable countermeasures in Section 6.
4.2.1 Common Detection Heuristics
Network.
These detection heuristics exploit the dis-
crepancies in network interfaces, Netﬁlter modules, and ker-
nel modules. For example, we found that all the emulators
exclusively use eth0, whereas the real devices use wlan0 and
rmnet. The emulators also miss several IPv6-speciﬁc inter-
faces. In addition, the network interfaces in the emulators
are not tetherable, because the emulators are missing the Re-
mote Network Driver Interface (RNDIS) drivers that enable
tethering. Netﬁlter is another source of discrepancies. The
real devices include Netﬁlter modules for several network
protocols that are rarely used in the context of mobile de-
vices. Finally, Android introduces a kernel module to track
data usage of installed applications. This module does not
exist in the emulators.
Power management. This type of heuristics focuses on
the power management subsystem. For example, the emula-
tors lack the voltage and current regulators. The emulated
CPU does not support frequency scaling. Another heuristic
lies in the prevalence of multi-core CPUs in real devices. All
the emulators only have a single core, whereas 75% of the
real devices have at least two cores.
Audio. A handy feature of Android is headset detec-
tion, which allows the audio output to automatically switch
between speakers and headsets. This feature is supported
by GPIO/I2C buses. Notably, the emulators do not em-
ulate these buses, while 95.6% of the real devices in our
experiments have them. Furthermore, the diﬀerences in the
implementation of audio subsystems between the emulators
and real devices result in disparate audio drivers.
USB. Recently, USB On-The-Go (OTG) has been widely
adopted in popular Android phones and tablets. It allows
mobile devices to act as hosts and control USB peripher-
als. Intuitively, the mobile devices have to pre-install corre-
sponding drivers of USB peripherals. As a result, we found
that the real devices in our experiments carry drivers for
Apple Magic Mouse, joysticks, and external displays. On
the contrary, the emulators do not have such drivers and do
not support USB OTG.
Radio.
The software-emulated radio can lead to de-
tection heuristics as well. For instance, the name of the
baseband in all the emulators is “unknown.” Moreover, the
emulators use a default reference implementation of the ra-
dio interface layer (RIL), while the real devices typically use
customized ones with diﬀerent names. Similarly, the phone
numbers, voicemail numbers, device serial numbers of the
emulators are also constants and can be ﬁngerprinted.
Software components and conﬁgurations. Despite
that most of the discovered detection heuristics are related
to hardware, we also identiﬁed several heuristics that exploit
certain software components and their conﬁgurations. For
example, the emulators use unique input methods and search
interfaces. Regarding conﬁgurations, a prominent example
is the key that signs the Android OS. The emulators use test
keys while the real devices use release keys.
4.2.2 QEMU Detection Heuristics
QEMU. We found various observable artifacts that are
part of QEMU. For example, we found a device node that
accelerates the virtual graphics. In addition, there are sev-
eral system properties set by QEMU and read by Android
system services. An example is a property that stores the
pixel density of virtual screens.
Goldﬁsh virtual hardware. Most existing QEMU-
based Android emulators are built upon a virtual hardware
platform called “Goldﬁsh.” This platform introduces a set
of virtual hardware for QEMU to run Android as its guest
operating system. For instance, this set of virtual hardware
includes a framebuﬀer, an audio device, and a battery. They
are a must for QEMU-based emulators but never appear in
real Android devices.
Bluetooth, NFC, and vibrator. The current QEMU-
based emulators do not support these hardware. Their cor-
responding Android APIs return null if called from within
the emulators.
In particular, the driver of the vibrator is
based on a Linux driver model called timed_output, which
is also missing from the emulators.
4.2.3 VirtualBox Detection Heuristics
VirtualBox.
Similar to QEMU-based emulators, we
also found plenty of VirtualBox-speciﬁc artifacts. For exam-
ple, we found 4 kernel modules that belong to VirtualBox
Guest Additions. As stated in VirtualBox’s documentation,
these modules “optimize the guest operating system for bet-
ter performance and usability.” However, their presence also
indicates VirtualBox.
PC hardware.
As we have discussed, QEMU-based
emulators lack support for some popular hardware, such as
Bluetooth and NFC. On the contrary, VirtualBox-based em-
ulators support many types of hardware that Android does
not need. We found hundreds of artifacts that indicate PC
hardware and obviously should not appear in mobile oper-
ating systems. For example, we found artifacts related to
ACPI, CPU fans, thermal sensors, CD-ROM drives, AC97
audio codecs, and PCI Express.
5. MEASURING DETECTION HEURISTICS
As we have demonstrated the magnitude of the detection
heuristic for Android emulators, we further measure their
accuracies. To this end, we assembled a group of the top-
ranked detection heuristics which are ranked by the heuris-
tic selector. We then tested them against emulator-based
malware analysis tools and real devices. In this section, we
describe our experiments along with an empirical study on
the average accuracies.
5.1 Experimental Setup
As the generated common detection heuristics were al-
ready ranked by the heuristic selector, we selected the top
10 heuristics out of the File, API, and Property detection
heuristics, respectively. Table 2 lists the artifacts, tokens,
and types of the 30 selected detection heuristics.
We created a synthetic application3 to simulate the An-
droid malware as we described in the threat model. Specif-
ically, this application integrated the 30 heuristics with a
heuristic matching engine based on Java’s substring search-
ing methods. It generated its decision using a majority vote
among the 30 heuristics. In other words, an Android device
is recognized as an emulator if more than half of the detec-
tion heuristics indicate so. Furthermore, it only needed four
permissions: READ_PHONE_STATE, ACCESS_NETWORK_STATE, AC-
CESS_WIFI_STATE, and INTERNET, which are also frequently
requested by benign applications in Google Play [29].
3https://play.google.com/store/apps/details?
id=edu.sefcom.devicetester and http://goo.gl/FXspKw
Table 2: Top 10 File, API, and Property Heuristics
Table 4: Evaluation Results of the 30 Heuristics
Token
Type
TP FN FP TN Sens.(%) Spec.(%) Acc.(%)
Artifact
/proc/misc
/proc/ioports
/proc/uid stat
/sys/devices/virtual/misc/
cpu dma latency/uevent
/sys/devices/virtual/ppp
/sys/devices/virtual/switch
/sys/module/alarm/parameters
/sys/devices/system/cpu/
cpu0/cpufreq
/sys/devices/virtual/misc/
android adb
/proc/sys/net/ipv4/
tcp syncookies
isTetheringSupported()
getAuthenticatorTypes()
getSystemSharedLibraryNames()
getGlobalSearchActivity()
getWebSearchActivity()
getTetherableWiﬁRegexs()
getTetherableUsbRegexs()
getEnabledInputMethodList()
getDeviceId() via Binder
getTetherableIfaces()
qemu.hw.mainkeys
ro.build.description
ro.build.ﬁngerprint
net.eth0.dns1
rild.libpath
ro.radio.use-ppp
gsm.version.baseband
ro.build.tags
ro.build.display.id
init.svc.console
F1
F2
F3
F4