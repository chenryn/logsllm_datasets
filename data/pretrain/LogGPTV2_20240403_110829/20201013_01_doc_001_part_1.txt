Jsonpath in examples
and roadmap
Nikita Glukhov, Oleg Bartunov
Postgres Professional
SQL/JSON — 2020
NOSQL POSTGRES IN SHORT
● Complete SQL/JSON
● Better indexing, syntax
JSONPATH - 2019
● SQL/JSON — 2016
● Functions & operators
● Indexing
JSONB - 2014
● Binary storage
● Nesting objects & arrays
● Indexing
JSON - 2012
● Textual storage
● JSON verification
HSTORE - 2003
● Perl-like hash storage
● No nesting, no arrays
● Indexing
Json in
PostgreSQL
(state of Art)
Two JSON data types !!!
JSONB
JSON
BINARY BETTER JSON
Jsonb vs Json
SELECT j::json AS json, j::jsonb AS jsonb FROM
(SELECT '{"cc":0, "aa": 2, "aa":1,"b":1}' AS j) AS foo;
json | jsonb
----------------------------------+----------------------------
{"cc":0, "aa": 2, "aa":1,"b":1} | {"b": 1, "aa": 1, "cc": 0}
• json: textual storage «as is»
• jsonb: binary storage, no need to parse, has index support
• jsonb: no whitespaces, no duplicated keys (last key win)
• jsonb: keys are sorted by (length, key)
• jsonb: a rich set of functions (\df jsonb*), "arrow" operators
• jsonb: great performance, thanks to indexes
• JsQuery ext. - json query language with GIN indexing support
JSONB is GREAT,
BUT ...
JSON[B] is a black box for SQL
SELECT * FROM js_test;
WITH RECURSIVE t(id, value) AS ( SELECT * FROM
js_test
id | value
UNION ALL
----+-----------------------------------------------------------------------
(
SELECT 1 | [1, "a", true, {"b": "c", "f": false}]
t.id,
2 | {"a": "blue", "t": [{"color": "red", "width": 100}]}
COALESCE(kv.value, e.value) AS value
3 | [{"color": "red", "width": 100}]
FROM
t 4 | {"color": "red", "width": 100}
LEFT JOIN LATERAL 5 | {"a": "blue", "t": [{"color": "red", "width": 100}], "color": "red"}
jsonb_each(
6 | {"a": "blue", "t": [{"color": "blue", "width": 100}],"color": "red"}
CASE WHEN jsonb_typeof(t.value) =
7 | {"a": "blue", "t": [{"color": "blue", "width": 100}],"color": "red"}
'object' THEN t.value
ELSE NULL END) kv ON true 8 | {"a": "blue", "t": [{"color": "green", "width": 100}]}
LEFT JOIN LATERAL jsonb_array_elements(
9 | {"color": "green", "value": "red", "width": 100}
CASE WHEN
(9 rows)
jsonb_typeof(t.value) = 'array' THEN t.value
ELSE NULL END) e ON true
WHERE Jsquery (2014)
kv.value IS NOT NULL OR e.value IS
NOT NULL https://github.com/postgrespro/jsquery/
)
)
SELECT * FROM js_test
SELECT
js_test.*
WHERE
FROM
(SELECT id FROM t WHERE value @> '{"color": value @@ '*.color = "red"';
"red"}' GROUP BY id) x
JOIN js_test ON js_test.id = x.id;
Postgres revolution: embracing relational databases
•
NoSQL users attracted by the NoSQL Postgres features
db-engines
JSONB
18 декабря 2014
JSONB and JsQuery are
GREAT, BUT ...
OH, REALLY ?
SQL Standard
now loves JSON !
SQL/Foundation recognized JSON after 8 years
SQL/JSON in SQL-2016
RFC 1759 SQL-2016
• SQL/JSON data model
• A sequence of SQL/JSON items, each item can be (recursively) any of:
• SQL/JSON scalar — non-null value of SQL types: Unicode character string, numeric, Boolean
or datetime
• SQL/JSON null, value that is distinct from any value of any SQL type (not the same as NULL)
• SQL/JSON arrays, ordered list of zero or more SQL/JSON items — SQL/JSON elements
• SQL/JSON objects — unordered collections of zero or more SQL/JSON members
(key, SQL/JSON item)
• JSON Path language
• Describes a  of JSON data to be used by SQL/JSON functions
• SQL/JSON functions (9)
• Construction functions: values of SQL types to JSON values
• Query functions: JSON values to SQL types
JSON Path(JSON values) → SQL/JSON types -> converted to SQL types
SQL/JSON in PostgreSQL
RFC 1759
PG 12
• SQL/JSON data model
• Jsonb is the (practical) subset of SQL/JSON data model
ORDERED and UNIQUE KEYS
• JSON Path language
• Describes a  of JSON data (to be used by SQL/JSON functions)
• Most important part of SQL/JSON - committed to PG12 !
• SQL/JSON functions
• json[b] construction functions
Constructor functions:
• Query functions: need some functions/operators with jsonpath support
• Indexes
• Use already existing indexes (built-in, jsquery)
Add support of jsonpath to the existing opclasses
JSON Path query language
• JSON Path expression specify the parts of json. It is
an optional path mode 'strict' or 'lax' (default), followed by a path or
unary/binary expression on paths. Path is a sequence of path elements,
started from path variable, path literal or expression in parentheses and
zero or more operators ( JSON accessors, filters, and item methods )
'lax $.floor[*].apt[*] ? (@.area > 40 && @.area  10)'
@ - current context in filter expression
• Item methods - '$.a.b.c.x.type()'
type(), size(), double(), ceiling(), floor(), abs(), keyvalue(),
datetime()
JSON Path examples 1/3
• JSON Path expression is an optional path mode ``strict` or `lax`
(default), followed by a path or unary/binary expression on paths. Path
is a sequence of path elements, started from path variable, path literal
or expression in parentheses and zero or more operators ( JSON
accessors, filters, and item methods ).
'$' -- the whole JSON document (context item)
'$foo' -- variable "foo"
'"bar"' -- string literal
'12.345' -- numeric literal
'true' -- boolean literal
'null' -- null
'$.floor' -- field accessor on $
'$.floor[*]' -- the same, followed by wildcard array accessor
JSON Path examples 2/3
• JSON Path expression is an optional path mode ``strict` or `lax`
(default), followed by a path or unary/binary expression on paths. Path
is a sequence of path elements, started from path variable, path literal
or expression in parentheses and zero or more operators ( JSON
accessors, filters, and item methods ).
-- complex path with filters and variables
'$.floor[*] ? (@.level  $min_area).no'
-- arithmetic expressions:
'-$.a[*]' -- unary
'$.a + 3' -- binary
'2 * $.a - (3 / $.b + $x.y)' -- complex expression with variables
JSON Path examples 3/3
• JSON Path expression is an optional path mode ``strict` or `lax`
(default), followed by a path or unary/binary expression on paths. Path
is a sequence of path elements, started from path variable, path literal
or expression in parentheses and zero or more operators ( JSON
accessors, filters, and item methods ).
-- parenthesized expression used as starting element of a path,
-- followed by two item methods ".abs()" and ".ceiling()"
jsonb '1.2' | '(($ + 1).abs() * 2).ceiling()' | 5
Syntactical errors in 'jsonpath' are reported:
SELECT '$a. >1'::jsonpath;
ERROR: syntax error, unexpected GREATER_P at or near ">" of jsonpath input
JSON Path filter
• A filter is similar to a `WHERE` clause in SQL, it is used to remove
SQL/JSON items from an SQL/JSON sequence if they do not satisfy a
predicate.
• Syntax: ? (JSON path predicate) — filter can be nested, since predicate
itself could contains JSON path with filter
• Predicate: True, False, Unknown (any errors in operands — structural,
arithmetic, incomparable items)
JSON Path filter
• A filter is similar to a `WHERE` clause in SQL, it is used to remove
SQL/JSON items from an SQL/JSON sequence if they do not satisfy a
predicate.
• Filter works as follows:
1) In lax mode, any SQL/JSON arrays in the operand are unwrapped
2)The predicate is evaluated fo each SQL/JSON item in the SQL/JSON sequence
3)The result is those SQL/JSON items for which the predicate resulted in True.
● The special variable @ in filter is a reference the current SQL/JSON item
in the SQL/JSON sequence. The value of @ is the current SQL/JSON item
of the first operand of the innermost filter with @.
JSON Path filter
• Predicates:
• Comparison predicates ==, !=, <>, , and >=
Compares all pairs from left and right operands
• Logical predicates &&, ||, !
• exists, test if a path expression has a non-empty result
'$[*] ? ( exists ( @[*] ? (@> 2)) )'
• like_regex for string pattern matching.
Optional flag can be combination of i, s (default), m, x.
'$[*] ? ( @ like_regex "as" flag "i")
• starts with to test for an initial substring (prefix)
'$[*] ? ( @ starts with "as")'
• is unknown to test for Unknown results. Its operand should be in parentheses.
'$[*] ? ((@ == 5) is unknown)'
JSON Path filters
• Errors in operands of predicates converted to unknown independent on
lax/strict mode.
jsonb '[1,"a",2]'
'$[*] ? (1/@ > 0)' | 1,2
'$[*] ? ((1/@ > 0) is unknown)' | "a" (source of error)
JSON Path methods
• Predefined methods transforms each item to sequence
jsonb '[{"a":5, "b":2},{"c": 3, "d": 4},{}]'
'$[*]' | {"a": 5, "b": 2}, {"c": 3, "d": 4},{}
'$[*].keyvalue()' | {"id": 16, "key": "a", "value": 5},
{"id": 16, "key": "b", "value": 2},
{"id": 56, "key": "c", "value": 3},
{"id": 56, "key": "d", "value": 4}
• There are could be several methods
jsonb '1.2' | '(($ + 1).abs() * 2).ceiling()' | 5
Two floors house
How path expression works (1)
'$.floor[*].apt[*] ? (@.area > 40 && @.area  40 && @.area  40 && @.area  40 && @.area  40 && @.area  40 && @.area  40 && @.area  40 && @.area  0)' | 1,2,3
'lax $[*].a ? (@ > 0)' | 1,3
'strict $[*].a ? (@ > 0)'| ERROR: object does not contain key "a"
JSON Path: [lax] vs strict
lax and strict modes used to facilitate matching of the
(sloppy) document structure and path expression
● Handling of structural error — Errors ignored in lax mode, error
status returned
● Access to SQL/JSON item of wrong type
jsonb '[{"a":1},2,{"a":3}]'
'lax $[*].* ? (@ > 0)' | 1,3
'lax $[*].a ? (@ > 0)' | 1,3
'strict $[*].a ? (@ > 0)'| ERROR: jsonpath member accessor can only
| be applied to an object
JSON Path: [lax] vs strict
lax and strict modes used to facilitate matching of the
(sloppy) document structure and path expression
● Handling of structural error — Errors ignored in lax mode, error
status returned
● Predicate returns unknown if operands report error status
jsonb '[{"a":1},{"b":2},{"a":3},4]'
'lax $[*] ? (@.a > 0)' | {"a":1},{"a":3}
'strict $[*] ? (@.a > 0)' | {"a":1},{"a":3}
'lax $[*] ? ((@.a > 0) is unknown)' |
'strict $[*] ? ((@.a > 0) is unknown)' | {"b":2},4
JSON Path: [lax] vs strict
● Lax: arrays are unwrapped
Strict: requires an exact nesting
jsonb '[1,2,[3,4,5]]'
'lax $[*] ? (@ == 5)' | 5
'lax $ ? (@ == 5)' | [3,4,5]
'strict $[*] ? (@[*] == 5)' | [3,4,5]
'strict $[*] ? (@ == 5)' |
'strict $[*] ? ((@ == 5) is unknown)' | [3,4,5]
JSON Path implementation in Postgres
Standard permits only string literals in JSON Path specification.
• JSON Path in Postgres implemented as jsonpath data type - the binary
representation of parsed SQL/JSON path expression.
• To accelerate JSON Path queries using existing indexes for jsonb we
implemented boolean operators (exists, match) for json[b] and
jsonpath.
• Implementation as a type is much easier than integration of JSON path
processing with executor (complication of grammar and executor).
• In simple cases, expressions with operators can be more concise than
with SQL/JSON functions.
• It is Postgres way to use operators with custom query types (tsquery
for FTS, lquery for ltree, jsquery for jsonb,...)
jsonpath functions
• jsonb_path_exists() => boolean
Test whether a JSON path expression returns any SQL/JSON items
(operator @?).
• jsonb_path_match() => boolean