code location in L to rewritten JavaScript code and one
or more WebAssembly modules, and
• p is a precondition for applying t, expressed as a predicate
on a code location and its surrounding context.
We present seven transformation rules that target different
language features of JavaScript. The transformation rules fall
into three categories. First, we present rules to obfuscate data
that gets defined and used by a JavaScript file. These rules
target string literals (Section IV-B1) and array initialization
code (Section IV-B2). Second, we present rules to obfuscate
function calls. These rules hide suspicious function calls (Sec-
tion IV-B3) or any function call (Section IV-B4). Finally, we
present rules to obfuscate the control flow in the given code.
These rules target if statements (Section IV-B5), for loops
(Section IV-B6), and while loops (Section IV-B7). Table I
illustrates the transformation rules.
The transformation rules use several JavaScript primitives
to interact with WebAssembly:
• instanWasm(source, impObj) instantiates a Web-
Assembly module from source and returns the module.
The optional parameter impObj is an object containing
the functions to be imported into the created WebAssem-
bly module. We use two variants of this primitive which
instantiate the module synchronously and asynchronously
(Section IV-C).
• loadStrFromBuf(buffer, startIndex) creates a
string from the buffer starting from the byte offset
startIndex and ending at the first null byte (i.e., \00)
Fig. 1. Overview of Wobfuscator.
files before they even reach the client’s machine, as an anti-
virus tool on the client machine, or as a browser extension.
Malware detection or mitigation techniques that go beyond
static analysis, e.g., based on analyzing the executing of client-
side code, are beyond the scope of this work.
The goal of the attacker is to bypass the malware detector.
To this end, the attacker may assume that the targeted browser
supports WebAssembly, which is the case for almost all of
today’s browsers. The attacker does not need to have access
to the malware detector or, in the case a machine learning-
based detector, to the data it is trained on.
IV. APPROACH
A. Overview and Challenges
Figure 1 gives an overview of Wobfuscator. The input is
a JavaScript file, which we parse into an AST. Next, the ap-
proach identifies potential translation sites, i.e., code locations
that (i) are relevant for detecting malicious code and (ii) can be
translated into WebAssembly in a semantics-preserving way.
Instead of aiming at a general JavaScript-to-WebAssembly
translation, the approach opportunistically targets only those
code locations that fulfill these two requirements.
To move behavior into WebAssembly, Wobfuscator gen-
erates WebAssembly code for each translation site and then
transforms the JavaScript AST to utilize the generated code.
The AST is transformed in three ways. First, at an instantiation
site, we add code to load the WebAssembly module into
the application. Second, at each of the selected translation
sites, we modify the code to access properties and functions
provided by the WebAssembly module(s). Third, at the root
node of the AST, we conditionally wrap the script into an
anonymous, async function, referred to as the async wrapper,
to support asynchronous keywords in the code. The remainder
of this section explains these transformations in detail. Finally,
the output of Wobfuscator is the transformed JavaScript code
along with one or more generated WebAssembly modules.
We encountered several challenges in designing transforma-
tions that move JavaScript behavior into WebAssembly mod-
ules. One key challenge is the fact that completely translating
general JavaScript code to WebAssembly is impossible due to
the limited set of features in WebAssembly. One example is
dynamically generated code, which is enabled in JavaScript
through the infamous eval function, but not supported in
WebAssembly. JavaScript supports rather complex rules, e.g.,
function scope for var-bound variables, hoisting of functions,
and closures. WebAssembly has only three storage locations:
global module variables, local variables for each function,
Authorized licensed use limited to: Tsinghua University. Downloaded on August 07,2022 at 12:59:50 UTC from IEEE Xplore.  Restrictions apply. 
31576
Input: MaliciousJavaScriptOutput: JavaScript + WebAssemblyvarfoo = "evil";eval(...);JavaScript ASTApproach•Identify & checkTranslation sites•Generate WebAssembly•Rewrite JavaScriptParsePotentialTranslationSite(module(memory...)(func...)+InstantiationSiteAsyncWrapperTranslationSiteRule
JavaScript (Before)
JavaScript (After)
WebAssembly (After)
TABLE I
TRANSFORMATION FUNCTIONS.
1 (global $d1 (export "d1") (mut i32)
(cid:44)→
(i32.const 0))
2 (memory (export "memory") 1)
3 (data $data0 (i32.const 0) "lit\00"))
1 (memory (export "memory") 1)
2 (func $f (export "f")
3
4
5
6
7
8
i32.const $i1
i32.const $num1
i32.store
i32.const $i2
i32.const $num2
i32.store)
1 (global $d1 (export "d1") (mut i32)
(i32.const 0))
2 (memory (export "memory") 1)
3 (data $data0 (i32.const 0)
"eval\00"))
1 (func $f0 (export "f0")
2
call $impFunc) ;; JS import
T1-StringLiteral
1 var s = "lit";
T2-ArrayInitialization
1 var arr = new Array();
2 arr[i1] = num1;
3 arr[i2] = num2;
T3-FunctionName
1 eval(str);
T4-CallExpression(a)
1 f(a);
T4-CallExpression(b)
1 let r = f(a);
T5-IfStatement
1 if(cond) {
2
3 } else {
4
5 }
stmt1; stmt2; ...
stmt3; stmt4; ...
T6-ForStatement
1 for(init;cond;incre) {
2
3 }
stmt1; stmt2; ...
T7-WhileStatement
1 while(cond) {
2
3 }
stmt1; stmt2; ...
1 // Instantiation Site
2 let m = instanWasm(source);
3 let buf = m.instance.exports.memory.buffer;
4 // Translation Site
5 let startInd = m.instance.exports.d1;
6 var s = loadStrFromBuf(buf, startInd);
1 // Instantiation Site
2 let m = instanWasm(source);
3 let buf = m.instance.exports.memory.buffer;
4 // Translation Site
5 m.instance.exports.f();
6 var arr = loadArrFromBuf(buf, startInd, len);
1 // Instantiation Site
2 let m = instanWasm(source);
3 let buf = m.instance.exports.memory.buffer;
4 // Translation Site
5 let startInd = m.instance.exports.d1;
6 window[loadStrFromBuf(buf, startInd)](str);
1 // Translation Site
2 let impObj = {imports: {impFunc: () => f(a)}};
3 let m = instanWasm(source, impObj);
4 m.instance.exports.f0();
1 // Translation Site
2 let impObj = {imports: {impFunc: f}};
3 let m = instanWasm(source, impObj);
4 let r = m.instance.exports.f0(a);
1 // Translation Site
2 let impObj = {imports: {
3
4
5 let m = instanWasm(source, impObj);
6 m.instance.exports.f(cond ? 1 : 0);
imp1:() => {stmt1; stmt2; ...},
imp2:() => {stmt3; stmt4; ...}}};
imports: {
1 // Translation Site
2 init;
3 let impObj = {
4
5
6
7
8
9 };
10 let m = instanWasm(source, impObj);
11 m.instance.exports.f();
cond:() => {return cond ? 1 : 0},
incre:() => {incre},
body:() => {stmt1; stmt2; ...}
}
imports: {
1 // Translation Site
2 let impObj = {
3
4
5
6
7 };
8 let m = instanWasm(source, impObj);
9 m.instance.exports.f();
cond:() => {return cond ? 1 : 0},
body:() => {stmt1; stmt2; ...}
}
(cid:44)→
(cid:44)→
(cid:44)→
1 (func $f0 (export "f0") (param
externref) (result externref)
2
3
local.get $p
call $impFunc) ;; JS import
local.get $p
if ;; label = @1
1 (func $f (export "f0") (param $p)
2
3
4
5
6
7
call $imp1 ;; JS import
call $imp2 ;; JS import
else
end)
loop $L1
block $L0
1 (func $f (export "f0")
2
3
4
5
6
7
8
9
10
11
call $cond ;; JS import
i32.eqz
br_if $L0
call $body ;; JS import
call $incre ;; JS import
br $L1
end
end)
loop $L1
block $L0
1 (func $f (export "f0") (param $p)
2
3
4
5
6
7
8
9
10
call $cond ;; JS import
i32.eqz
br_if $L0
call $body ;; JS import
br $L1
end
end)
after startIndex, where buffer is the WebAssembly
module linear memory.
• loadArrFromBuf(buffer, startIndex, length)
creates an array from buffer of size length starting
from the byte offset startIndex, where buffer is the
WebAssembly linear memory.
1) Obfuscating String Literals: JavaScript malware fre-
quently uses encoded strings to hide malicious code [66].
These encoded strings can be critical for malware detec-
tors which learn the string patterns and their encoding
schemes [24],
[54]. To evade the detection of encoded
strings, we define a transformation rule T1-StringLiteral
(LT 1, tT 1, pT 1) where:
LT 1. The code locations where transformation rule T1 may
apply are all AST nodes of Literal type with string values.
tT 1. The transformation function is defined in row T1-
StringLiteral in Table I. To obfuscate a string literal “lit”,
tT 1 generates a WebAssembly module that defines a memory
and exports it to JavaScript (line 2). The memory is used to
store the string literal “lit” at offset 0 (line 3). To reconstruct
this string in JavaScript, a variable $d1 containing the offset is
defined and exported (line 1). Each string is terminated with a
null byte (i.e., \00), so it can be reconstructed by reading the
linear memory from the starting index until the first null byte
is found. If multiple strings in the input JavaScript program are
to be transformed, they are all stored in a single WebAssembly
module. In this case, multiple variables can be defined for each
string stored (e.g., $d1, $d2, ...). The variable buf points to the
Authorized licensed use limited to: Tsinghua University. Downloaded on August 07,2022 at 12:59:50 UTC from IEEE Xplore.  Restrictions apply. 
41577
memory exported by WebAssembly (line 3). At the translation
site, a variable startInd gets the starting index of the string
literal stored in linear memory (line 5). Finally, the string
“lit” is reconstructed using the primitive loadStrFromBuf
with arguments buf and startInd (line 6).
pT 1. This transformation can be applied in locations where
JavaScript allows for replacing a string literal with a function
call. Specifically,
this excludes: (i) string literals used in
import or require statements, as such strings should be
known when bundling modules together; (ii) string literals
used as property names in object expressions as return values
from function calls cannot be used as object keys.
2) Obfuscating Arrays: Malicious files often contain arrays
of numeric literals representing character codes used to recon-
struct malicious strings. To obfuscate these arrays, we exploit
the fact that the linear memory of WebAssembly modules
is implemented through an array buffer, which can naturally
map to a JavaScript numeric array, in transformation rule T2-
ArrayInitialization (LT 2, tT 2, pT 2) where:
LT 2. T2 may apply on NewExpression AST nodes (e.g., new
Array) or ArrayExpression AST nodes representing array
literal expressions (e.g., [1,2,3]). In addition, the transfor-
mation also condenses any following AssignmentExpression
nodes used to initialize the array values into a single JavaScript
function call (e.g., arr[1] = 42; arr[2] = 97;. . . ).
tT 2. The transformation tT 2
is defined in row T2-
ArrayInitialization in Table I. The original JavaScript code
creates an array arr and initializes the elements arr[i1] and
arr[i2] with numerical values num1 and num2, respectively.
After the transformation, tT 2 produces a WebAssembly mod-
ule that creates a memory and exports it (line 1). A function
$f is defined which stores the numbers, num1 and num2, at the
specified offsets, i1 and i2, inside the linear memory (lines 2-
8). The transformed JavaScript code instantiates a WebAssem-
bly module (line 2) and creates a variable to read from the
exported memory (line 3). Similar to T1-StringLiterals, if there
are multiple array initializations to be transformed, only one
WebAssembly module is created at the instantiation site. At
the translation site, the export function f is called to write
num1 and num2 to the linear memory at offset i1 and i2 (line
5). Finally, loadArrFromBuf() returns a JavaScript Array
object containing the numerical values copied from the linear
memory buffer, and this array is assigned to arr (line 6).
This function requires the starting index of the array in linear
memory and the length of the array. Both of these values
are calculated by Wobfuscator and inserted into each call
to loadArrFromBuf(). We ensure that a JavaScript Array
object is returned as the original code using the array will need
to access the standard properties and methods of an Array.
pT 2. This transformation can be applied to arrays initialized
with numeric literals. Since WebAssembly only has numeric
data types we only store numeric literals in memory using
the operators .const and .store. Specifically, we apply the
transformation only if the array initialization is one of the
following: (i) a new Array expression followed by assignment
statements inserting only numeric literals; (ii) a new Array
Several
3) Obfuscating
expression with numeric literal arguments; (iii) an ArrayEx-
pression only containing numeric literals.
Function Names:
built-in
JavaScript functions, such as the notorious eval function, are
commonly exploited by attackers. As a result, detectors may
consider the names of these built-in functions suspicious and
use them as part of the signatures for malware detection [50],