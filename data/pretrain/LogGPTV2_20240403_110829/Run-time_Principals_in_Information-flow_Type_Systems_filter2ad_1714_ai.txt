to the hierarchy by the let (X1 (cid:22) X2) in . . . binding (corresponding to E-LetDel).
{[[i]]}
pn−1{[[pn−1 (cid:22) pn]]} ↔ K−1
pn
ACM Transactions on Programming Languages and Systems, Vol. TBD, No. TDB, Month Year.
Run-time Principals in Information-ﬂow Type Systems
·
37
We illustrate this process by example. Consider the following program that takes
in two capabilities and some data owned by Alice and attempts to declassify it.
1
2
3
4
5
λc1 : C. λc2 : C. λx: bool{Alice :!}.
if (c1 ⇒ Alice . delegateAlice(cid:22)Bob)
let (Alice (cid:22) Bob) in
if (c2 ⇒ Bob . declassify)
declassify x bool{!}
By the typing rule T-Dcls of declassiﬁcation, line 5 needs the authority p .
declassify for some p acting for Alice because Alice’s policy is being weakened:
‘ bool{Alice :!} − bool{!} = {Alice}
The PKI implementation justiﬁes the presence of Alice’s authorization. Assume
the acts-for hierarchy A at line 1 is the default hierarchy consisting of only (KX , K>)
pairs. Line 2 uses [[Alice]] = KAlice to verify the certiﬁcate A ‘ c1 ⇒ (KAlice , [[i]])
where [[i]] = [[delegateAlice(cid:22)Bob]] = (del, KAlice , KBob). Since the acts-for hierarchy
Alice{[[i]]} or K−1> {[[i]]}. The ﬁrst certiﬁ-
is otherwise empty, c1 must be of the form K−1
cate can be validated using only KAlice; the second can be validated starting from
Alice{[[Alice (cid:22) >]]} ↔ K−1> {[[i]]}. If one of
KAlice by checking the certiﬁcate chain K−1
these chains is valid, line 3 adds the delegation information into the hierarchy so
that (KAlice , KBob) ∈ [[A]].
Similarly, there are two certiﬁcates c2 that may justify the static condition
Alice (cid:22) π(declassify) = Alice (cid:22) Bob
required by rule T-Dcls in line 5. If c2 = K−1
runtime because we can ﬁnd the chain:
Bob{dcls}, the static condition holds at
Alice{[[Alice (cid:22) Bob]]} ↔ K−1
K−1
Bob{dcls}
If c2 = K−1> {dcls} we can ﬁnd the chain:
Alice{[[Alice (cid:22) Bob]]} ↔ K−1
K−1
Bob{[[Bob (cid:22) >]]} ↔ K−1> {dcls}
6.2 Application to distributed banking
Figure 11 shows a more elaborate example λRP program that implements a dis-
tributed banking scenario in which a customer interacts with their bank through
an ATM. The example uses a number of standard constructs such as integers, pairs,
let-binding, and existential types with multiple arguments that are not in λRP, but
could readily be added or encoded [Pierce 2002]. The main functions for the ATMs
and the Bank are shown, along with the types of various auxiliary functions.
The static principals are Bank and ATM1 through ATMn, and there are two
run-time principals, user and agent. The principal user is the customer at an
ATM; agent is the Bank’s name for one of the n ATMs that may connect to the
bank server. On the top of Figure 11 are the type declarations of the functions
used, in the middle is the client code for ATMj (a particular ATM), and at the
bottom is the bank server code.
At the ATMj , the customer logs in with the bank card and the password, re-
vealing his identity [user, userid] and allowing ATMj to act for him (represented
ACM Transactions on Programming Languages and Systems, Vol. TBD, No. TDB, Month Year.
·
38
Stephen Tse and Steve Zdancewic
AT Mj main : [ATMj . declassifynet]1 → 1
Bank main : [Bank . declassifynet]1 → 1
→ int{agent:agent!agent})
(Pagent, Puser, C, C, (int{agent:agent!} → 1)){Bank :Bank !Bank}
request : ∃(agent, user). ((Pagent, Puser, C, C){Bank :Bank !}
listen : 1 → ∃(agent, user).
login : 1 → (∃user. Puser, C){ATMj :ATMj !}
print : int{!} → 1
get : ∀user. Puser → int{Bank :Bank !}
set : ∀user. Puser → int → 1
AT Mj main = λx : 1.
open [user, (userid, cdel)] = login * in
case (acquire userid . withdraw100)
λcreq : C. let message = (ATMj , userid, cdel, creq) in
let data = declassifynet message (PATMj , Puser, C, C){Bank :Bank !} in
let balance = request (pack ((ATMj , user), data) in
case (acquire userid . declassifyprt)
λcprt : C. if (cprt ⇒ userid . declassifyprt)
let data = declassifyprt balance int{!} in
print data
···
// other banking options
Bank main = λx : 1.
open ((agent, user), (agentid, userid, cdel, creq, reply)) = listen * in
if (cdel ⇒ userid . delegateuser(cid:22)agent)
let (userid (cid:22) agentid) in
if (cdel ⇒ userid . withdraw100)
let old = get [user] userid in
let balance = old − 100 in
set [user] userid balance;
let data = declassifynet balance int{user:user!} in
reply data
// other banking options
···
Fig. 11. A distributed banking example
by the capability cdel). Then ATMj interacts with user to obtain his request such
as withdrawing $100. This interaction is modeled by the acquire. The ATM
client packs the identities ATMj and userid and the delegation cdel and the request
creq certiﬁcates into a message. To send the message over the channel to Bank,
ATMj gives up the ownership of the data by declassifying the message to have label
{Bank :Bank !}. As a result of the transaction with the bank server, ATMj obtains
the new account balance of the customer. Finally, ATMj prompts to determine
ACM Transactions on Programming Languages and Systems, Vol. TBD, No. TDB, Month Year.
Run-time Principals in Information-ﬂow Type Systems
·
39
whether the user wants a receipt, which requires a declassiﬁcation certiﬁcate to
print.
This example makes use of ﬁne-grained declassify privileges to distinguish be-
tween the printing (declassifyprt) and network send (declassifynet) uses of de-
classiﬁcation. these variants have the same static and dynamic semantics as the
declassify (as formulated in the last section), the subscripts are only annotations
that explicitly distinguish diﬀerent uses of declassifcation.
The bank server listens over the private channel and receives the message. The
listen function also provides a reply channel so that the balance can be returned to
the same ATM. The server determines that user has logged in to ATMj by verifying
cdel, and if so, checks that the request capability is valid. If so, the server updates
its database, and declassiﬁes the resulting balance to be sent back to the ATM. In
practice Bank will also want to log the certiﬁcates for auditing purposes.
In the functions request and listen, we assume the existence of a private network
between ATMj and Bank, which can be established using authentication and en-
cryption. Since the network is private, the outgoing data must be readable only by
the receiver; and, since the network is trusted, the incoming data has the integrity
of the receiver. The labels of their types faithfully reﬂect this policy: for example,
{Bank :Bank !} vs. {agent:agent!agent} in the type of request.
Note that the run-time authority for declassiﬁcation and delegation are provided
by the customer—they are acquired by the interaction of ATMj and user.
In
contrast, in the types of AT Mj main and Bank main, the static capability re-
quirements [ATMj . declassifynet] and [Bank . declassifynet] indicate that the
authorities to declassify to the network must be established from the caller.
Our type system does not prevent information leaks through computational ef-
fects such as printing or network input/output. Our ongoing research uses monads
to incorporate such static analysis, in the same spirit as the work by Crary et
al. [2004].
7. DISCUSSION
7.1 Related work
The work nearest to ours is the Jif project, by Myers et al. [1999]. The Jif compiler
supports run-time principals but its type system has not been shown to be safe.
Our noninterference proof for λRP is a step in that direction. Jif also supports run-
time labels [Zheng and Myers 2004], which are run-time representations of label
annotations, and a switch label construct that lets programs inspect the labels
at runtime. Although it is desirable to support both run-time labels and run-time
principals, the two features are mostly orthogonal.
While the core λRP presented here is not immediately suitable for use by pro-
grammers (more palatable syntax would be needed), λRP can serve as a typed in-
termediate representations for languages like Jif. Moreover, this approach improves
on the current implementation of the decentralized label model (DLM) because Jif
does not support declassiﬁcation of data owned by run-time principals, nor does
it provide language support for altering the acts-for hierarchy. Our separation of
static principals from their run-time representations also clariﬁes the type checking
rules.
ACM Transactions on Programming Languages and Systems, Vol. TBD, No. TDB, Month Year.
·
40
Stephen Tse and Steve Zdancewic
The ability to perform acts-for tests at runtime is closely related to intensional
type analysis, which permits programs to inspect the structure of types at runtime.
Our use of singleton types like Pp to tie run-time tests to static types follows the
work by Crary, Weirich, and Morrisett [2002]. Static capability sets π in our type
system are a form of eﬀects [Jouvelot and Giﬀord 1991], which have also been
used to regulate the read and write privileges in type systems for memory manage-
ment [Crary et al. 1999]. Simonet and Pottier [2004] have an related application
using guarded algebraic datatypes to express such run-time types and run-time tests.
The robustness condition on the set of run-time capabilities is very closely re-
lated to Java’s stack inspection model [Wallach and Felten 1998; Wallach et al. 2000;
Fournet and Gordon 2002; Pottier et al. 2001]. In particular, the enable-privilege
operation corresponds to our if (e1 ⇒ e2 . i) e3 e4 and the check-privileges oper-
ation corresponds to the constraint on π in the declassify rule. The restriction
π|l of capability sets in the type-checking rule for function application corresponds
to taking the intersection of privilege sets in these type systems. However, stack
inspection is not robust in the sense that data returned from an untrusted context
can inﬂuence the outcome of privileged operations [Fournet and Gordon 2002]. In
contrast, λRP tracks the integrity of data and restricts the capability sets according
to the principals’ trust in the data—this is why the restriction π|l appears in the
typechecking rule for case expressions.
Banerjee and Naumann [2003] have previously shown how to mix stack inspection-
style access control with information-ﬂow analysis. They prove a noninterfer-
ence result, which extends their earlier work on information-ﬂow in Java-like lan-
guages [Banerjee and Naumann 2002]. Unlike their work, this paper considers
run-time principals as well as run-time access control checks.
Incorporating the
principals used by the DLM into the privileges checked by stack inspection allows
our type system to connect the information-ﬂow policies to the access control policy,
as seen in the typechecking rule for declassify.
We have proposed the use of public key infrastructures as a natural way to imple-
ment the authority needed to regulate declassiﬁcation in the presence of run-time
principals. Although the interpretation of principals as public keys and authorized
actions as digitally signed certiﬁcates is not new, integrating these features in a
language with static guarantees brings new insights to information-ﬂow type sys-
tems. This approach should facilitate the development of software that interfaces
with existing access-control mechanisms in distributed systems [Howell and Kotz
2000; Gasser and McDermott 1990].
Making the connection between PKI and the label model more explicit may have
additional beneﬁts. Myers and Liskov observed that the DLM acts-for relation is
closely related to the speaks-for relation in the logical formulation of distributed
access control by Abadi et al. [1993]. Adopting the local names of the SDSI/SPKI
framework [Abadi 1998] may extend the analogy even further. Chothia et al. [2003]
also use PKI to model typed cryptographic operations for distributed access control.
Lastly, although capability mechanism in λRP provides facilities for programming
with static and run-time capabilities, we do not address the problem of revocation.
It would be useful to ﬁnd suitable language support for handling revocation, such as
that found in the work by Jim and Gunter [2001; 2000], but we leave such pursuits
to future work.
ACM Transactions on Programming Languages and Systems, Vol. TBD, No. TDB, Month Year.
Run-time Principals in Information-ﬂow Type Systems
·
41
7.2 Conclusions
Information-ﬂow type systems are a promising way to provide strong conﬁdential-
ity and integrity guarantees. However, their practicality depends on their ability to
interface with external security mechanisms, such as the access controls and authen-
tication features provided by an operating system. Previous work has established
noninterference only for information-ﬂow policies that are determined at compile
time, but such static approaches are not suitable for integration with run-time
security environments.
This paper addresses this problem in three ways: (1) We prove noninterference
for an information-ﬂow type system with run-time principals, which allow secu-
rity policies to depend on the run-time identity of users.
(2) We show how to
safely extend this language with a robust access-control mechanism, a generaliza-
tion of stack inspection, that can be used to control privileged operations such as
declassiﬁcation and delegation. (3) We sketch how the run-time principals and the
acts-for hierarchy of the decentralized label model can be interpreted using public
key infrastructures.
Our ongoing research attempts to use monads, in the same spirit as the depen-
dency core calculus by Abadi et al. [1999], to simplify the design of the decentral-
ized label model. In particular, we model all downgrading mechanisms uniformly
as subtyping to allow a simple formulation and proof of a conditioned version of
noninterference, even in the presence of downgrading.
ACKNOWLEDGMENT
The authors thank Steve Chong, Peng Li, Francois Pottier, Dimitrios Vytiniotis,