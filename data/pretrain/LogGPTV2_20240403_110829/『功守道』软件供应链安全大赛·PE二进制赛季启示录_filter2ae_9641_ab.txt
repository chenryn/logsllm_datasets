针对开发者本地开发资源进行源头污染，污染部分代码本身没有体现在安装包内自带 MinGW
的头文件明文之中。为实现攻击特征字符串避免被解题者直接人工察觉，使用了简单的字符串编码，这种方法在本次比赛中，由所有队伍不约而同地使用；该方案可以规避静态扫描，在动态测试方案中失效。这道题目在一定的隐藏性之余，实现了恶意行为的“从头做起”。
###  开发环境污染2：重装上阵
第二道针对Code::Blocks的题目，我们选择了一道设计完善、链路复杂且具有隐蔽性的题目，其恶意代码直接植入到了codeblocks.exe主程序文件中，CodeBlocksApp::OnAppActivate函数内容。该部分原始题目代码如下：
本道题目意图为修改cpp源文件默认打开方式为恶意程序。实现方式为：开发机器上存在大量cpp格式源文件，若修改cpp文件打开方式为指定恶意程序即可实现对cpp文件的读写删改等操作。本题在Windows“轻松访问”注册表键创建一个恶意的“轻松访问”项，使得机器启动或者桌面切换（例如触发UAC）时执行恶意“轻松访问”项指定的程序certutile.exe，certutile.exe从服务器下载恶意程序codeblocks_opencpp.exe后，将cpp文件的默认打开程序修改为codeblocks_opencpp.exe。
本题集恶意利用、持续驻留、持续更新于一体，codeblocks_opencpp.exe实现恶意利用、恶意“轻松访问”项实现持续驻留、植入位置OnAppActivate是一个会被持续执行的函数，它将与certutil.exe一起持续从服务器上下载恶意程序以保持持续更新。此外，恶意代码会判断当前进程权限以决定修改哪个用户下的注册表项。
值得一提，在整个函数中，恶意代码的代码比例、位置和结构可视化如下图，也许会给人一些想法上的启发：
本道题目的亮点在于巧妙实现了完整的攻击链路，同时因为修改特定文件关联是该IDE软件本身就有的行为，所以该部分代码从行为和字符串等静态特征上，与载体具有一定的逻辑混淆性。
###  开发环境污染3：登堂入室
第三道针对Code::Blocks的题目，我们选择了一道令人胆颤的题目。考虑前两道题目，无论是针对开发头文件资源的污染，还是针对系统和软件环境的篡改，着眼点都是在恶意程序寄存的电脑本身；而针对该电脑使用者所在的企业、电脑接入的内部网络环境、开发资源所述的企业代码本身，这些真正有价值的目标，并没有实现攻击扩散。而这里的这道题目，从思路上完成了更大的野心。
该题目存在于Code::Blocks的官方插件compiler.dll中，原始代码如下，其中选定部分为恶意行为载荷：
本题中插入恶意代码，调用主机中的Git将当前的git项目上传到指定的服务器（这里上传至github），从而完成对互联网企业最核心资产——源代码的窃取和泄漏。
观察其实施链路，为了将用户当前的git项目上传至指定的git服务器，代码一共做了如下操作：保存用户当前的ssh公私钥—>用自己的公私钥覆盖用户的公私钥—>获取当前git项目的目录—>判断当前git项目是否存在origin，添加或修改origin—>将git项目push到git服务器—>删除或恢复origin，删除临时文件，恢复用户的ssh公私钥。
整体实现细节中值得注意的地方有：
• 采用批处理（.bat）的方式来实现执行多条指令，同时为了避免执行批处理时出现的黑色弹框，采用vbs间接调用bat的方式。
•
执行git命令需要在当前项目的目录下，这里通过codeblocks源码中的m_pBuildingProject->GetBasePath()来获取当前项目的根目录，借用载体本身的接口，发生了交叉引用，可规避对于仅观察与工程其余部分完全没有交叉引用的解题思路的发现。
• 为了不让恶意代码的执行阻碍codeblocks的正常编译，使用Windos系统API
ShellExecuteA来执行.vbs脚本。这种方法本身在动态执行时特征比较容易被察觉，但是对于批量文件静态扫描，则没有太过突兀的特征。
•
删除临时文件以及恢复公私钥时，需要等git项目push完毕后才行，这里的时间无法预知，因此这部分的实现也放在bat脚本中（bat、vbs脚本均是动态生成、动态删除）。
###  本地客户端污染1：暗度陈仓
第二轮分站赛，组织方选定了两款客户端软件作为恶意行为载体，其中一款本地客户端为ConEmu终端仿真器。该软件听起来比较小众，但是实际上被作为引擎用于多种其它增强型终端的底层，如广泛使用的cmder。同时，该软件功能强大，涉及到大量的底层甚至hackish的操作去实现特定的功能，例如对所执行的控制台程序默认挂钩进行交互和渲染等。
选择这款软件的初衷，也是希望出题队能够借用载体本身的实现、机制，完成更有意思、更具有侵入性的供应链攻击行为，并更深层次地实现恶意代码的藏匿，削弱其独立性以规避检测。这里举例的这道题目比较好的体现了这样的意图。
这道题目选取了ConEmuCD模块（关于该软件的主要组件作用可参考官方说明）当中的LLKeybHook函数，添加的代码量较小，如下，
本题利用ConEmu自身SetWindowsHookEx对键盘的输入的hook，使用少量的修改将用户的操作命令记录到TEMP目录指定文件中。其中比较巧妙地规避了可能令解题队察觉的几个细节有：
• 利用程序自带的hook函数进行操作，减少不必要的API调用，以少量的代码达到攻击的目标；
• 使用char s[] = {‘a’,’b’,’c’}的形式避免字符串被直接检索；
• 使用程序本身包含的CreateFile、WriteFile以及SetFilePointerEx，避免引入其他API。
同时，考虑到有队伍考虑从函数代码中，辨别是否有功能可独立切片的代码部分，作为恶意植入的代码片段的特征；这道题目也可成功规避这样的检测，其中恶意代码部分在整个函数中的位置和比例如下图所示。
###  本地客户端污染2：得寸进尺
在选择第二轮比赛的本地客户端软件载体时，选取了ConEmu这样一款终端类软件而非一般的文档、图像等处理类软件，主要看中的是其使用场景，往往是很多登录企业测试、预发、线上服务器的客户端工具，其中也集成了这样的功能，因此以此为渠道将攻击横向移动到企业服务器上，是一个最小代价实现最大化目标攻击效果的方法。
ConEmu当中的这样一道题目是，在ConEmuCD动态库模块中，将恶意代码植入到Queue.cpp文件中，影响终端中在远程网络会话中，输入控制的环节，恶意代码存在于SendConsoleEvent函数：
这里选取的载体函数，巧妙选定在了客户端处理向网络会话中发送特殊字符的功能位置。当用户使用 SSH 连接内网其他主机时，触发后门并且自动在该内网主机上执行
downloader，以巧妙达到横向感染其他主机的目的。当然，这里仅仅是提供了一个从本地到远程、从个人PC到背后更大的企业网络环境主机的攻击升级的渠道；在ssh远端主机上可发动的下一步软件供应链攻击更加多样化，这样就可以将C源代码赛季的花招进行整合复用了。
###  本地客户端污染3：有的放矢
在本次比赛当中有一个倾向性，认为软件供应链上存在的污染和恶意行为，既然初时需要以充分的准备（无论是技术渗透还是社会工程）来达成攻击的前置条件，那么恶意行为必然不会是容易被觉察的、以破坏为主的传统攻击；在当下我们能考虑到的，应该是会以长期潜伏、获取具有资产价值的重要数据为主。但这也引入了一个问题，怎样的数据算作这样的目标数据呢？在第一个C源代码赛季，在限定了线上生产环境和服务端软件系统这个场景下，由主办方提供了一个大致的范围列表和例子，出题队恶意代码窃取数据的范围也基本没有超出这个圈定。但是在更灵活的场景下，比如PC环境，问题就不再那么容易限定。
针对ConEmu这个题目载体软件，几支出题队结合软件自身行为和意图，在如下这几个点，直接获取了软件本身所采集的具有一定价值的数据，比较具有代表性：
•
ConEmu主程序模块，Settings::HistoryLoad函数，用来导出、导入在终端中用户输入的命令历史。在此处植入了极小量的代码，直接将本地记录有命令历史的文本数据编码后传出，实现了泄漏。考虑到作为一款基础的终端软件，ConEmu集成了cmd、powershell、WSL、cygwin、ssh客户端、git
bash等多种会话，其本地记录的命令显然会暴露大量操作敏感信息，甚至会暴露用户连接到公司后台的操作数据。
•
ConEmu主程序模块，DumpImage函数，用来实现一个内建的截屏功能。屏幕信息包含的数据显然同样具有很大的数据量，例如，考虑到一般用户的使用场景，截屏功能比较可能针对屏幕上显示代码、关键配置数据、程序或远程错误信息等情况下使用，而这些都会造成本地或远程敏感信息不保。
•
ConEmuCD动态库模块，ApplyProcessSetEnvCmd函数，是终端启动时配置环境参数命令的功能函数。在此中设置代理，将代理指向攻击者控制的服务器，而后终端里的网络流量被攻击者劫持。
• ConEmu主程序模块，CConEmuUpdate::wininet::Init函数，插入恶意代码，在ConEmu进行升级的时候，模仿Xshell
Ghost信息搜集阶段的操作，搜集本级IP地址，使用gethostbyname进行DNS请求方式将信息传出。
以上的信息泄露点都比较巧妙地借用了载体模块和代码本身的正常逻辑和函数调用序列，实现自身的功能以及隐藏。当然，题目都受制于比赛本身对于出题的限制，而如果脱离比赛中对于一定需要仅改动单个函数等要求，这些恶意行为本可以更加巧妙，例如上述更改的地方仅用于做数据的上游采集，而对应的数据泄露环节，可以复用程序本身的网络相关函数，调用链路也可以进行一定隐藏。
同时，更值得引起思考的是，对于泛化的软件，应该如何定义这样需要监控的“敏感数据”。数据的敏感程度，往往应该是与具体的软件、执行环境甚至操作上下文相关才可判定的。例如，如果仅凭一个确定的、通用的知识库来进行数据外传是否涉及敏感信息泄漏，那么截屏是否触网？从数据采集到外传，如果做了数据本身的整合和遮掩，例如对数据的特定范围进行星号替换，那么如何判别敏感部分是否得到了有效脱敏？种种问题，已经无法通过确定的知识进行判别；即便是通过机器学习，也应该没有合理的解决办法，毕竟问题是发散的，不可能有足够的黑样本进行全集学习。也许面对这样的问题，类似“SDN”的概念，需要有一种“软件定义敏感数据”的新的方法论来解决。
###  网络客户端污染：举一反三
第二轮比赛另外选择了一款网络客户端软件作为题目载体，选用目标为老牌p2p客户端软件eMule。作为软件供应链攻击，多数恶意行为都需要网络行为作为其中数据传入或传出的关键一环，因此在网络客户端中既可以实现这样行为的隐藏，更方便借用软件本身的功能模块代替执行数据流转。而选取了p2p更是看中了其不同寻常客户端的网络行为模式，其中本地数据的上传下载、搜索、网络扩散的行为本身，也为恶意行为提供了可能。