For example it could be used for exﬁltrating informa-
tion from an attacked domain (on a tab executing mali-
cious Javascript). Using Workers (which are background
threads that run independently of the user interface) we
can transfer information across origins, without affect-
ing the user experience and without generating network
trafﬁc.
5 Discussion
We have shown how sharing event loops leads to timing
side-channels and presented different attacks on Chrome.
We communicated our ﬁndings to the Chromium security
team, who decided not to take action for the time being.
Nevertheless, our results point to fundamental security
issues in the event-driven architecture of browsers that
eventually need to be addressed in a fundamental man-
ner. Below, we discuss how other platforms are affected
and present possible countermeasures.
5.1 Beyond Chrome
We focus on Chrome in our analysis because it is the
most widely used browser, and because it was the ﬁrst
one to implement a multi-process architecture. However,
there are good reasons to expect similar side channels in
other browsers, as they all follow the same event-driven
paradigm and rely on similar architectures.
For instance,
recent Firefox versions with multi-
process support5 also rely on a privileged browser pro-
cess and multiple content processes that, unlike render-
ers in Chrome, act as a pool of threads for each different
origin (each with its own message queue). Despite this
difference, tests with LoopScan on Firefox version 55
show that congestion on both event loops is observable
across origins and tabs.
Speciﬁcally, we applied the monitoring technique for
the renderers described in Section 3.1.2 on a micro-
benchmark with a set of 30 pages with 15 traces each.
We achieved a recognition rate of 49%, which is be-
low the recognition rate achieved on Chrome for a set of
500 pages. A fair comparison between both architectures
will require a better understanding of Firefox’s policy for
mapping sites to threads and events to loops.
5.2 Countermeasures
The attacks presented in this paper rely on two capabili-
ties of the adversary: (1) the ability to post tasks into the
loop’s queue with high frequency, and (2) the ability to
accurately measure the corresponding time differences.
Rate Limiting. An obvious approach to counter (1)
is to impose a limit on the rate at which tasks can be
posted into an event loop. Unfortunately, rate limiting
implies penalties on performance, which is especially
problematic for asynchronous code.
At the level of the renderer, one possibility is to rely
on an accumulate and serve policy [22]. With this pol-
icy, the event loop accumulates all the incoming jobs
5Firefox’s Electrolysis (or e10s) project
USENIX Association
26th USENIX Security Symposium    861
in a buffer for a period T , and then process and serves
all the accumulated jobs from party A, followed by all
the jobs from V. This has the advantage of limiting the
amount of information leaked while retaining high amor-
tized throughput.
At the level of the host process, where resource fetch-
ing is one of the main performance concerns, setting any
bound on the processing rate is not acceptable. Here, it
seems more reasonable to monitor the IPC activity of all
renderers and penalize or ﬂag those who exhibit a bad or
anomalous behavior, e.g., along the lines of [39].
Reduce Clock Resolution. An obvious approach to
counter (2) is to limit the resolution of available clocks.
This has already been applied by browser vendors for
mitigating other kinds timing channels, but these ef-
forts are unlikely to succeed, as shown in [23]: Modern
browsers have a considerable number of methods to mea-
sure time without any explicit clock. For instance, some
recent exploits [16] use high-resolution timers build on
top of SharedArrayBuffers. The current resolution of
performance.now is limited to 5 µs, which makes mi-
croarchitectural timing attacks difﬁcult, but does not pre-
clude the detection of Javascript events.
Full Isolation. As discussed in Section 2.2, Chrome’s
multi-process architecture tries to use a different ren-
derer for different origins, except for some corner
cases. The “Site Isolation Project” is an ongoing ef-
fort to ensure a complete process-per-site-instance pol-
icy, that means: providing cross-process navigations,
cross-process Javascript interactions and out-of-process
iframes. All this without inducing too much overhead.
One open question is how to handle the system’s pro-
cess limit, namely which sites should have isolation pref-
erence, or which heuristic for process reuse should be
used. A recent proposal, “IsolateMe” [4], puts the devel-
opers in charge of requesting to be isolated from other
web content (even if it does not provide a ﬁrm guaran-
tee).
CPU Throttling. Chrome v55 introduces an API that
allows to limit how much CPU a background page is
allowed to use, and to throttle tasks when they exceed
this limit. This affects background tabs trying to spy
on the renderer’s main thread, but still allows spying
on (and from) any iframe and popup, as well as on the
I/O thread of the host process through shared Workers.
Moreover, background tabs with audio activity are not
affected, as they are always marked as foreground. Since
Chrome v57 pages (or tabs) are only subjected to throt-
tling after 10 seconds in the background, which is too
long to prevent the attacks in this paper.
6 Related Work
Timing attacks on web browsers date back to Felten and
Schneider [13], who use the browser cache to obtain in-
formation about a user’s browsing history.
More recently, so-called cross-site timing attacks [10,
35] have exploited the fact that the browser attaches
cookies to all requests, even when they are performed
across origins. The presence or absence of these cookies
can be determined by timing measurements, which re-
veals information about the user’s state on arbitrary sites.
A special case are cross-site search attacks [14], which
circumvent the same-origin policy to extract sensitive in-
formation, by measuring the time it takes for the browser
to receive responses to search queries.
Other classes of browser-based timing attacks exploit
timing differences in rendering operations [24, 33, 5], or
simply use the browser as an entry point for Javascript
that exploits timing channels of underlying hardware, for
example caches [26, 16], DRAM buffers [17], or CPU
contention [9].
Of those approaches,
[9] is related to our work in
that it identiﬁes web pages across browser tabs, based on
timing of Javascript and a classiﬁer using dynamic time
warping. However, because the attack relies on CPU
contention as a channel, it requires putting heavy load on
all cores for monitoring. In contrast, our attack exploits
the browser’s event loop as a channel, which can be mon-
itored by enqueing one event at a time. This makes our
attack stealthy and more independent of the execution
platform.
To the best of our knowledge, we are ﬁrst to mount
side-channel attacks that exploit the event-driven archi-
tecture of web browsers. Our work is inspired by a proof-
of-concept attack [36] that steals a secret from a cross-
origin web application by using the single-threadedness
of Javascript. We identify Chrome’s event-driven archi-
tecture as the root cause of this attack, and we show
how this observation generalizes, in three different at-
tacks against two different event loops in Chrome.
Finally, a central difference between classical site ﬁn-
gerprinting [28, 19, 34, 12] approaches and our page
identiﬁcation attack is the adversary model: First, our ad-
versary only requires its page to be opened in the victim’s
browser. Second, instead of trafﬁc patterns in the vic-
tim’s network, our adversary observes only time delays
in the event queues of the victim’s browser. We believe
that our preliminary results, with up to 76% of recogni-
tion rate using one single sample for training in a closed-
world with 500 pages, can be signiﬁcantly improved by
developing domain-speciﬁc classiﬁcation techniques.
862    26th USENIX Security Symposium
USENIX Association
7 Conclusions
In this paper we demonstrate that shared event loops in
Chrome are vulnerable to side-channel attacks, where a
spy process monitors the loop usage pattern of other pro-
cesses by enqueueing tasks and measuring the time it
takes for them to be dispatched. We systematically study
how this channel can be used for different purposes, such
as web page identiﬁcation, user behavior detection, and
covert communication.
Acknowledgments We thank Thorsten Holz, Andreas
Rossberg, Carmela Troncoso, and the anonymous re-
viewers for their helpful comments. We thank Javier Pri-
eto for his help with the data analysis. This work was
supported by Ram´on y Cajal grant RYC-2014-16766,
Spanish projects TIN2012-39391-C04-01 StrongSoft
and TIN2015-70713-R DEDETIS, and Madrid regional
project S2013/ICE-2731 N-GREENS.
References
[1] Covert channels in the sop. https://github.com/cgvwzq/
sop-covert-channels. Accessed: 2017-02-16.
[2] HTML Living Standard. https://html.spec.whatwg.org/.
Accessed: 2017-05-24.
[3] Understanding
about:tracing
results.
https:
//www.chromium.org/developers/how-tos/
trace-event-profiling-tool/trace-event-reading.
Accessed: 2017-02-16.
[4] Isolation explainer. https://wicg.github.io/isolation/
explainer.html, 2016. Accessed: 2017-05-24.
[5] ANDRYSCO, M., KOHLBRENNER, D., MOWERY, K., JHALA,
R., LERNER, S., AND SHACHAM, H. On subnormal ﬂoating
point and abnormal timing. In SSP (2015), IEEE.
[6] BARTH, A., JACKSON, C., REIS, C., TEAM, T., ET AL. The
security architecture of the chromium browser. http://www.
adambarth.com/papers/2008/barthjackson-reis.pdf,
2008.
[7] BERNDT, D. J., AND CLIFFORD, J. Using dynamic time warping
to ﬁnd patterns in time series. In KDD workshop (1994), AAAI
Press.
[8] BERNSTEIN, D. Cache-timing attacks on AES. https://cr.
yp.to/antiforgery/cachetiming-20050414.pdf, 2005.
[9] BOOTH, J. M. Not so incognito: Exploiting resource-based side
channels in javascript engines. http://nrs.harvard.edu/
urn-3:HUL.InstRepos:17417578, 2015.
[10] BORTZ, A., AND BONEH, D. Exposing private information by
timing web applications. In WWW (2007), ACM.
[11] BOSMAN, E., RAZAVI, K., BOS, H., AND GIUFFRIDA, C.
Dedup Est Machina: Memory Deduplication as an Advanced Ex-
ploitation Vector. In SSP (2016), IEEE.
[12] DYER, K. P., COULL, S. E., RISTENPART, T., AND SHRIMP-
TON, T. Peek-a-Boo, I Still See You: Why Efﬁcient Trafﬁc Anal-
ysis Countermeasures Fail. In SSP (2012), IEEE.
[13] FELTEN, E. W., AND SCHNEIDER, M. A. Timing attacks on
web privacy. In CCS (2000), ACM.
[14] GELERNTER, N., AND HERZBERG, A. Cross-Site Search At-
tacks. In CCS (2015), ACM.
[15] GIORGINO, T. Computing and visualizing dynamic time warping
alignments in r: The dtw package. JSS 31, 7 (2009), 1–24.
[16] GRAS, B., RAZAVI, K., BOSMAN, E., BOS, H., AND GIUF-
FRIDA, C. ASLR on the Line: Practical Cache Attacks on the
MMU. In NDSS (2017), The Internet Society.
[17] GRUSS, D., MAURICE, C., AND MANGARD, S. Rowhammer.js:
A remote software-induced fault attack in javascript. In DIMVA
(2016), Springer.
[18] GRUSS, D., SPREITZER, R., AND MANGARD, S. Cache tem-
plate attacks: Automating attacks on inclusive last-level caches.
In USENIX Security (2015), USENIX Association.
[19] HAYES, J., AND DANEZIS, G. k-ﬁngerprinting: A Robust Scal-
In USENIX Security
able Website Fingerprinting Technique.
(2016), USENIX Association.
[20] HOGYE, M. A., HUGHES, C. T., SARFATY, J. M., AND WOLF,
J. D. Analysis of the feasibility of keystroke timing attacks over
ssh connections.
http://www.cs.virginia.edu/~evans/
cs588-fall2001/projects/reports/team4.pdf, 2001.
[21] JANA, S., AND SHMATIKOV, V. Memento: Learning secrets
from process footprints. In SSP (2012), IEEE.
[22] KADLOOR, S., KIYAVASH, N., AND VENKITASUBRAMA-
NIAM, P. Mitigating timing side channel in shared schedulers.
IEEE/ACM Trans. Netw. 24, 3 (2016), 1562–1573.
[23] KOHLBRENNER, D., AND SHACHAM, H. Trusted Browsers for
Uncertain Times. In USENIX Security (2016), USENIX Associ-
ation.
[24] KOTCHER, R., PEI, Y., JUMDE, P., AND JACKSON, C. Cross-
In CCS
origin pixel stealing: timing attacks using CSS ﬁlters.
(2013), ACM.
[25] LAMPSON, B. W. A note on the conﬁnement problem. Commu-
nications of the ACM 16, 10 (1973), 613–615.
[26] OREN, Y., KEMERLIS, V. P., SETHUMADHAVAN, S., AND
KEROMYTIS, A. D. The Spy in the Sandbox: Practical Cache
In CCS (2015),
Attacks in JavaScript and Their Implications.
ACM.
[27] OSVIK, D. A., SHAMIR, A., AND TROMER, E. Cache at-
tacks and countermeasures: the case of AES. In CT-RSA (2006),
Springer.
[28] PANCHENKO, A., LANZE, F., PENNEKAMP, J., ENGEL, T.,
ZINNEN, A., HENZE, M., AND WEHRLE, K. Website ﬁnger-
printing at internet scale. In NDSS (2016), The Internet Society.
[29] PEDERSEN, M. V., AND ASKAROV, A. From Trash to Treasure:
Timing-sensitive Garbage Collection. In SSP (2017), IEEE.
[30] REIS, C., AND GRIBBLE, S. D. Isolating web programs in mod-
ern browser architectures. In EuroSys (2009), ACM.
[31] SAKURAI, Y., FALOUTSOS, C., AND YAMAMURO, M. Stream
In ICDE (2007),
monitoring under the time warping distance.
IEEE.
[32] SONG, D. X., WAGNER, D., AND TIAN, X. Timing Analysis
of Keystrokes and Timing Attacks on SSH. In USENIX Security
(2001), USENIX Association.
[33] STONE, P.
timing attacks with html5
(white paper). https://www.contextis.com/documents/
2/Browser_Timing_Attacks.pdf, 2013.
Pixel perfect
[34] SUN, Q., SIMON, D. R., WANG, Y.-M., RUSSELL, W., PAD-
MANABHAN, V. N., AND QIU, L. Statistical identiﬁcation of
encrypted web browsing trafﬁc. In SSP (2002), IEEE.
[35] VAN GOETHEM, T., JOOSEN, W., AND NIKIFORAKIS, N. The
Clock is Still Ticking: Timing Attacks in the Modern Web. In
CCS (2015), ACM.
USENIX Association
26th USENIX Security Symposium    863
[36] VELA, E. Matryoshka: Timing attacks against javascript applica-
tions in browsers. http://sirdarckcat.blogspot.com.es/
2014/05/matryoshka-web-application-timing.html,
2013.
[37] YAROM, Y., AND FALKNER, K. FLUSH+RELOAD: A high
resolution, low noise, L3 cache side-channel attack. In USENIX
Security Symposium (2014).
[38] ZHANG, K., AND WANG, X. Peeping tom in the neighborhood:
Keystroke eavesdropping on multi-user systems. In USENIX Se-
curity (2009), USENIX Association.
[39] ZHANG, T., ZHANG, Y., AND LEE, R. B. CloudRadar: A Real-
Time Side-Channel Attack Detection System in Clouds. In RAID
(2016), Springer.
864    26th USENIX Security Symposium
USENIX Association