may also not learn the ID-based private key of IDI .
4. The adversary may learn neither the secret value of IDI nor replace the secret value of IDI and
may also not learn the ID-based private key of IDJ .
5. The adversary may learn neither the ephemeral private key of IDJ nor the secret value of IDI .
6. The adversary may learn neither the ephemeral private key of IDI nor the secret value of IDJ .
7. The adversary may learn neither the ephemeral private key of IDJ nor the ID-based private key
of IDI .
8. The adversary may learn neither the ephemeral private key of IDI nor the ID-based private key
of IDJ .
9. The adversary may learn neither the ID-based private key of IDI nor of IDJ .
As there are nine strategies, the probability that B does not abort the game after B selected the strategy
. The adversary may learn the key generation
and the test session beforehand is now larger than
centre’s master secret only in Strategy 1,2,3, and 4. Furthermore, B replaces the H2 oracle by a table
which records input/output pairs.
If a query is made that matches one of the previous inputs, the
corresponding output is returned, otherwise, a value from the respective output domain is chosen at
9q0q2
1
1
12
gi ∈ G
H1(IDI ) = bP
H1(IDJ ) = cP
g1
. . .
H3(gi)
ytbdh1P − zbP
ytbdh2P − zcP
y1P
. . .
$← Zp
yi
ytbdh1
ytbdh2
y1
. . .
z $← Zp
z
z
⊥
⊥
Instead of choosing H3(gi) for gi ∈ G at random from G, B chooses yi ∈ Zp at random, records it,
and sets H3(gi) to yiP . For Strategy 5, 6, 7, 8 and 9, the oracle is patched before the game starts by
setting H3(bP ) = ytbdh1P − zbP . For Strategy 9, the oracle is additionally patched before the game
starts with H3(cP ) = ytbdh2P − zcP . bP and cP are taken from the inputs to the BDH challenge. As
the pre-patched values are completely re-randomized, this modiﬁcation is indistinguishable for any
adversary. The table above shows the H3 oracle for Strategy 9 as an example.
Table 3: Modiﬁed H3 oracle suitable for twin bilinear Diﬃe-Hellman
random, the new input/output pair is added to the list and the value is returned. The H1 and H3 oracle
operate as explained in Table 2 on the preceding page and Table 3 respectively.
5.2 Behaviour of the challenger based on the chosen strategy
To solve the computational DH problem using M, B is given the values (aP, bP ) and B’s task is to
compute abP . To solve this problem, B uses the H2 oracle. The bilinear pairing is used for consistency
checks.
To solve the computational BDH problem using M, B is given the values (aP, bP, cP ) and B’s task
is to compute e(P, P )abc. To solve this problem, B uses the H2 and the H1 oracle. The H3 oracle is used
for consistency checks and operates as in Table 3.
rixjP, rjxiP, K, K(cid:48), L, L(cid:48), N, N(cid:48)) where
The session key SK is generated by querying H2 on (IDi, IDj, riP, xiP, rjP, xjP, rirjP, xixjP,
K = e(H1(IDj), P )ris
· e(H1(IDi), P )rj s
,
(cid:123)(cid:122)
K2
(cid:125)
(cid:124)
(cid:125)
(cid:124)
(cid:123)(cid:122)
K1
(cid:123)(cid:122)
L2
(cid:125)
(cid:124)
(cid:125)
L = e(H1(IDj), P )sxi
· e(H1(IDi), P )sxj
,
N = e(H1(IDi), H1(IDj))s
(cid:124)
(cid:123)(cid:122)
L1
Depending on the chosen strategy, B embeds the challenge in the test query and answers the test
query as speciﬁed in Section 2.1 on page 3.
5.2.1 Patching the H2 oracle
B has to maintain consistency between the H2 oracle and session key reveal queries, as B will not be
able to compute all data necessary to query the H2 oracle for a valid session key in some instances
(e.g. if certiﬁcateless public keys have been replaced by the adversary). If B has been asked on the H2
oracle ﬁrst and is then later asked a matching session key reveal query, B is always able to answer these
requests correctly (it uses its decisional oracles that are explained in the proofs for respective strategies,
see Section 5.4 on the following page). However, if B is asked a session key reveal query for which no
matching H2 query exists yet, B proceeds as follows: B inserts all available data and all data that B
is able to compute (see also section 5.3 on the next page) into the H2 oracle but may have to leave
some ﬁelds (like K and K(cid:48) or L and L(cid:48) or N and N(cid:48)) empty. B chooses a random value from H2’s
output domain as the session key and records that value together with the incomplete H2 query data.
For the following H2 queries, B ﬁrst checks if one of the incomplete entries of the H2 oracle matches
M’s query data by using the respective decisional oracle(s). If that is the case, B records the complete
information submitted by M and returns the H2 entry. B additionally ﬁlls up all long term values that
it can determine (even if it is not able to ﬁll a H2 entry completely). If B ﬁnds no matching entry, B
simply generates a new H2 entry as usual.
13
5.3 Handling a session key reveal query for sessions Πt
i,j where party i and
j are not participating in the test query
Without loss of generality, we assume that i is the initiator of the session. Given party i that has
incoming message (rMj P, xMj P ) (where Mj indicates that the values may be adversarial controlled)
and that thus accepts, the challenger knows at least the identity based private keys and the ephemeral
private key of party i, i.e. the challenger knows sH1(IDi), sH3(H1(IDi)), ri. The adversary may have
replaced the certiﬁcateless public key of party i with xMiP . To obtain a session key, party i has to query
the H2 oracle with the session data (as explained in Section 3.3 on page 8) on the following elements:
SK = H2(i, j, riP, xMiP, rMj P, xMj P, rirMj P, xMixMj P, rixMj P, xMirMj P,
K, K(cid:48), L, L(cid:48), N, N(cid:48))
Besides the public values i, j, riP, xMiP, rMj P, xMj P that are part of the H2 query, the challenger acting
as party i is able to compute the following values knowing its (possibly corrupted) private information
sH1(IDi), sH3(H1(IDi)), ri:
rirMj P trivially, by computing ri(rMj P )
rixMj P by computing ri(xMJ P )
K due to the patched H1 oracle (see Table 2 on page 12), the challenger knows logP H1(IDi) = li and
logP H1(IDj) = lj. Thus K can be computed as
K = e(H1(IDj), sP )rie(lisP, rMj P )
K(cid:48) just like for K, the challenger knows logP H3(H1(IDi)) = yi and logP H3( H1(IDj)) = yj (see
Table 3 on the preceding page). Thus K(cid:48) can be computed as
K(cid:48) = e(H3(H1(IDj)), sP )ri e(yisP, rMj P )
L Knowing li and lj from the H1 oracle computing L is easy:
L(cid:48) can be computed similarly, just like K(cid:48) above.
L = e(lj(xMiP ), sP )e(lisP, xMj P )
N and N(cid:48) are easy as the ID-based private keys are known.
The only missing values are xMixMj P and xMirMj P which cannot be computed by the challenger.
However, as we point out in the proof for Strategy 1 in Section 5.4, the challenger is still able to answer
session state reveal and H2 queries consistently: If the challenger is asked a H2 query ﬁrst and then
later asked a matching session state reveal query, the challenger can identify the corresponding H2 entry
by checking for all entries if e(xiP, xjP ) = e(xixjP, P ) and if e(xMiP, rMj P ) = e(xMirMj P ). If the
challenger is asked a session state reveal query, but there is no matching H2 entry, the challenger can
create a new random value from the output domain of H2 and assign it to the incomplete entry. The
challenger checks the subsequent queries of the adversary to the H2 oracle and is able to answer the
queries correctly by using the pairing as above.
In the following, we will split the challenger’s behaviour based on the strategy chosen in Section 5.1
on page 11. Additionally, we omit the indices t
i,j with respect to key computations for speciﬁc sessions
to increase readability. Usually it is evident for which particular session the computations are needed.
For the proof we assume that the adversary M does not get an advantage in outputting its guess ˆb for
b unless M queries the H2 oracle on the session key.
5.4 Proofs for Strategy 1 to 9
5.4.1 Strategy 1
The allowed corrupt queries for the adversary are listed in Table 1 on page 12. The challenger B
wants to use the adversary M to solve the computational Diﬃe-Hellman problem. The input for B is
14
(aP, bP ) ∈ G2 and B’s goal is to compute abP . To this end, B sets the certiﬁcateless public key of IDI
to aP and the certiﬁcateless public key of IDJ to bP . B uses the pairing to check whether the queries
of the adversary to the H2 oracle are valid: by computing e(aP, bP ) = e(abP, P ), B is able to identify
valid queries. As soon as B ﬁnds such a query, B aborts the game and returns abP as solution of the
CDH challenge.
The probability that B is able to ﬁnd a solution to the CDH challenge is
AdvB(k)[CDH] ≥ AdvM(k)[Π]
9q0q2
1
B is able to compute all other elements (xI xJ P, K, K(cid:48), L, L(cid:48), N, N(cid:48)) that are necessary for H2 queries
as the respective private values are under B’s control.
If M is a Type II adversary as explained in
Section 2.1 on page 3, B gives s to M at the start of the game. We note that as B knows s, B is able
to generate ID-based private keys for any identity; thus the game does not have to be changed for Type
II adversaries. We note that M is allowed to replace the certiﬁcateless public key of IDI and/or IDJ
after the test query has been issued.
If M replaces the certiﬁcateless public keys of other identities and asks reveal queries, B ﬁrst uses the
pairing to check for matching queries to the H2 oracle. If no matching query is found, B ﬁrst generates
a random value v of the output domain of H2, inserts the available session data together with v into the
H2 table as described in Section 5.2.1 on page 13 (i.e. everything including the certiﬁcateless public keys;
except xixjP which B cannot compute) and returns v. If B is then later asked H2 queries containing
the correct xixjP and the certiﬁcateless keys xiP and xjP , B is able to tell so by using the pairing
computation and completes the entries in the H2 table wherever possible.
5.4.2 Strategy 2
The allowed corrupt queries for the adversary are listed in Table 1 on page 12. The challenger B
wants to use the adversary M to solve the computational Diﬃe-Hellman problem. The input for B is
(aP, bP ) ∈ G2 and B’s goal is to compute abP . To this end, B sets the ephemeral key of IDI to aP and
the ephemeral key of IDJ to bP in the test query. B uses the pairing to check whether the queries of
the adversary to the H2 oracle are valid: by computing e(aP, bP ) = e(abP, P ), B is able to identify valid
queries. As soon as B ﬁnd such a query, B aborts the game and returns abP as solution of the CDH
challenge.
The probability that B is able to ﬁnd a solution to the CDH challenge is
AdvB(k)[CDH] ≥ AdvM(k)[Π]
9q0q2
1
As M is allowed to replace the certiﬁcateless public keys of any identity, B uses the technique described
in Strategy 1 to decide how to answer reveal queries and H2 queries.
5.4.3 Strategy 3 and 4
The allowed corrupt queries for the adversary are listed in Table 1 on page 12. For Strategy 3, we want
to embed the CDH challenge in rI xJ P , because the input to other values used in the key derivation
function can be corrupted by the adversary. Here, B selects the master private key s $← Zp. B is able to
provide ID-based secret keys for all identities, as B is in possession of the master secret key. Furthermore,
B sets the certiﬁcateless public key of IDI to xI P = aP and the ephemeral public key of party IDJ to
rJ P = bP in session ΠT
I,J . If the adversary is a Type II adversary as described in Section 2.1 on page 3,
then B gives s to M at the start of the game.
Similar to Strategy 1 and 2, B checks the H2 queries for entries where
As soon as B ﬁnds such an entry, B aborts the game and returns rJ xI P as solution to the BDH challenge.
The probability that this happens is lower bounded by
e(P, rJ xI P ) ?= e(aP, bP )
AdvB(k)[CDH] ≥ AdvM(k)[Π]
9q0q2
1
15
B uses the techniques described in Strategy 1 to deal with replaced certiﬁcateless keys of identities other
than IDI . We note that M is allowed to replace the certiﬁcateless public key of IDI after the test query
has been issued.
We note that as Strategy 4 is symmetric to Strategy 3, its probability of success is equal to the
probability of success for Strategy 3. Only IDI and IDJ are exchanged and the computational BDH
challenge is embedded in rI xJ P instead of rJ xI P .
5.4.4 Strategy 5 and 6
The allowed corrupt queries for Strategy 5 for the adversary are listed in Table 1 on page 12. The
BDH challenge can only be embedded in L2 if Strategy 5 is chosen, because the input to all other
values used in the key derivation function can be corrupted by the adversary. To accomplish this, the
challenger B sets the master public key to aP and implements the H1 oracle as described in Table 2
on page 12, thus H1(IDI ) = bP . B patches the H3 oracle as described in Table 3 on page 13, thus
H3(H1(IDI )) = H3(bP ) = ytbdh1P − zbP . B can still generate private keys for all identities except IDI
by computing sH(IDi) = liaP and sH3(H1(IDi)) = yiaP . Additionally, B sets the certiﬁcateless public
key of IDJ to cP .
A problem for B arises when the adversary asks session key reveal queries for other sessions than the
test session that include IDI and IDJ , or for sessions that include IDI and another party for which the
adversary issued a replace public key query. Whenever B is asked a reveal query, B ﬁrst checks if the
key derivation function H2 was asked with a matching session string involving both IDI and IDJ . As
B is unable to compute L, B uses the twin bilinear Diﬃe-Hellman trapdoor (see Theorem 1 on page 9)
to check if M submitted a valid query, i.e.
if the query should be answered with a record from H2 (if
such a record exists). The challenger extracts the discrete logarithm for IDJ ’s private keys, lJ and yJ
from the H1 and H3 oracle respectively (H3(H1(IDJ )) = H3(lJ P ) = yJ P and B is able to extract both
lJ and yJ ). Then, B extracts L and L(cid:48) from each entry that matches the session for which the reveal
query is being asked, computes L1 = e(lJ aP, xI P ), L(cid:48)
(cid:18) L
L1
(cid:19)z · L(cid:48)
L(cid:48)
1
=
=
(cid:19)z
e(lJ aP, xI P )
1 = e(yJ aP, xI P ) and checks if
(cid:18) e(H1(IDJ ), P )sxI · e(H1(IDI ), P )sxJ
· e(H3(H1(IDJ )), P )sxI · e(H3(H1(IDI )), P )sxJ
(cid:18) e(lJ P, aP )xI · e(bP, P )ac