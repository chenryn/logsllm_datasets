## 程序是如何工作的？ {#03.html#-}我们可以简单地想象"你"这个程序的工作过程。![](Images/f723116cc9c809146ac0e0414f37c2a2.png){savepage-src="https://static001.geekbang.org/resource/image/06/ea/06b355394f525c54f200d8a1af63ddea.jpg"}当一个网络包从一个网口经过的时候，你看到了，首先先看看要不要请进来，处理一把。有的网口配置了混杂模式，凡是经过的，全部拿进来。拿进来以后，就要交给一段程序来处理。于是，你调用**process_layer2(buffer)**。当然，这是一个假的函数。但是你明白其中的意思，知道肯定是有这么个函数的。那这个函数是干什么的呢？从Buffer 中，摘掉二层的头，看一看，应该根据头里面的内容做什么操作。假设你发现这个包的 MAC地址和你的相符，那说明就是发给你的，于是需要调用**process_layer3(buffer)**。这个时候，Buffer里面往往就没有二层的头了，因为已经在上一个函数的处理过程中拿掉了，或者将开始的偏移量移动了一下。在这个函数里面，摘掉三层的头，看看到底是发送给自己的，还是希望自己转发出去的。如何判断呢？如果 IP 地址不是自己的，那就应该转发出去；如果 IP地址是自己的，那就是发给自己的。根据 IP头里面的标示，拿掉三层的头，进行下一层的处理，到底是调用process_tcp(buffer) 呢，还是调用 process_udp(buffer) 呢？假设这个地址是 TCP 的，则会调用**process_tcp(buffer)**。这时候，Buffer里面没有三层的头，就需要查看四层的头，看这是一个发起，还是一个应答，又或者是一个正常的数据包，然后分别由不同的逻辑进行处理。如果是发起或者应答，接下来可能要发送一个回复包；如果是一个正常的数据包，就需要交给上层了。交给谁呢？是不是有process_http(buffer) 函数呢？没有的，如果你是一个网络包处理程序，你不需要有process_http(buffer)，而是应该交给应用去处理。交给哪个应用呢？在四层的头里面有端口号，不同的应用监听不同的端口号。如果发现浏览器应用在监听这个端口，那你发给浏览器就行了。至于浏览器怎么处理，和你没有关系。浏览器自然是解析HTML，显示出页面来。电脑的主人看到页面很开心，就点了鼠标。点击鼠标的动作被浏览器捕获。浏览器知道，又要发起另一个HTTP 请求了，于是使用端口号，将请求发给了你。你应该调用**send_tcp(buffer)**。不用说，Buffer 里面就是 HTTP请求的内容。这个函数里面加一个 TCP的头，记录下源端口号。浏览器会给你目的端口号，一般为 80 端口。然后调用**send_layer3(buffer)**。Buffer 里面已经有了 HTTP的头和内容，以及 TCP 的头。在这个函数里面加一个 IP 的头，记录下源 IP的地址和目标 IP 的地址。然后调用**send_layer2(buffer)**。Buffer 里面已经有了 HTTP的头和内容、TCP 的头，以及 IP 的头。这个函数里面要加一下 MAC的头，记录下源 MAC 地址，得到的就是本机器的 MAC 地址和目标的 MAC地址。不过，这个还要看当前知道不知道，知道就直接加上；不知道的话，就要通过一定的协议处理过程，找到MAC 地址。反正要填一个，不能空着。万事俱备，只要 Buffer里面的内容完整，就可以从网口发出去了，你作为一个程序的任务就算告一段落了。
## 揭秘层与层之间的关系 {#03.html#-}知道了这个过程之后，我们再来看一下原来困惑的问题。首先是分层的比喻。**所有不能表示出层层封装含义的比喻，都是不恰当的。**总经理握手，不需要员工在吧，总经理之间谈什么，不需要员工参与吧，但是网络世界不是这样的。正确的应该是，总经理之间沟通的时候，经理将总经理放在自己兜里，然后组长把经理放自己兜里，员工把组长放自己兜里，像套娃娃一样。那员工直接沟通，不带上总经理，就不恰当了。现实生活中，往往是员工说一句，组长补充两句，然后经理补充两句，最后总经理再补充两句。但是在网络世界，应该是总经理说话，经理补充两句，组长补充两句，员工再补充两句。那 TCP 在三次握手的时候，IP 层和 MAC 层在做什么呢？当然是 TCP发送每一个消息，都会带着 IP 层和 MAC 层了。因为，TCP 每发送一个消息，IP层和 MAC 层的所有机制都要运行一遍。而你只看到 TCP 三次握手了，其实，IP层和 MAC 层为此也忙活好久了。这里要记住一点：**只要是在网络上跑的包，都是完整的。可以有下层没上层，绝对不可能有上层没下层。]{.orange}**所以，**对 TCP 协议来说，三次握手也好，重试也好，只要想发出去包，就要有IP 层和 MAC 层，不然是发不出去的。**经常有人会问这样一个问题，我都知道那台机器的 IP地址了，直接发给他消息呗，要 MAC 地址干啥？这里的关键就是，没有 MAC地址消息是发不出去的。所以如果一个 HTTP协议的包跑在网络上，它一定是完整的。无论这个包经过哪些设备，它都是完整的。所谓的二层设备、三层设备，都是这些设备上跑的程序不同而已。一个 HTTP协议的包经过一个二层设备，二层设备收进去的是整个网络包。这里面HTTP、TCP、 IP、 MAC 都有。什么叫二层设备呀，就是只把 MAC头摘下来，看看到底是丢弃、转发，还是自己留着。那什么叫三层设备呢？就是把MAC 头摘下来之后，再把 IP 头摘下来，看看到底是丢弃、转发，还是自己留着。
## 小结 {#03.html#-}总结一下今天的内容，理解网络协议的工作模式，有两个小窍门：-   始终想象自己是一个处理网络包的程序：如何拿到网络包，如何根据规则进行处理，如何发出去；-   始终牢记一个原则：只要是在网络上跑的包，都是完整的。可以有下层没上层，绝对不可能有上层没下层。最后，给你留两个思考题吧。1.  如果你也觉得总经理和员工的比喻不恰当，你有更恰当的比喻吗？2.  要想学习网络协议，IP 这个概念是最最基本的，那你知道如何查看 IP    地址吗？欢迎你留言和我讨论。趣谈网络协议，我们下期见！![](Images/55417b60e9c8040807daf07e6bd9cb4b.png){savepage-src="https://static001.geekbang.org/resource/image/b5/fb/b5bc14cb81d3630919fee94a512cc3fb.jpg"}
# 第3讲 \| ifconfig：最熟悉又陌生的命令行上一节结尾给你留的一个思考题是，你知道怎么查看 IP 地址吗？当面试听到这个问题的时候，面试者常常会觉得走错了房间。我面试的是技术岗位啊，怎么问这么简单的问题？的确，即便没有专业学过计算机的人，只要倒腾过电脑，重装过系统，大多也会知道这个问题的答案：在Windows 上是 ipconfig，在 Linux 上是 ifconfig。那你知道在 Linux 上还有什么其他命令可以查看 IP 地址吗？答案是 ipaddr。如果回答不上来这个问题，那你可能没怎么用过 Linux。那你知道 ifconfig 和 ip addr 的区别吗？这是一个有关 net-tools 和iproute2的"历史"故事，你刚来到第三节，暂时不用了解这么细，但这也是一个常考的知识点。想象一下，你登录进入一个被裁剪过的非常小的 Linux 系统中，发现既没有ifconfig 命令，也没有 ip addr命令，你是不是感觉这个系统压根儿没法用？这个时候，你可以自行安装net-tools 和 iproute2这两个工具。当然，大多数时候这两个命令是系统自带的。安装好后，我们来运行一下 ip addr。不出意外，应该会输出下面的内容。    root@test:~
# ip addr1: lo:  mtu 65536 qdisc noqueue state UNKNOWN group default     link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00    inet 127.0.0.1/8 scope host lo       valid_lft forever preferred_lft forever    inet6 ::1/128 scope host        valid_lft forever preferred_lft forever2: eth0:  mtu 1500 qdisc pfifo_fast state UP group default qlen 1000    link/ether fa:16:3e:c7:79:75 brd ff:ff:ff:ff:ff:ff    inet 10.100.122.2/24 brd 10.100.122.255 scope global eth0       valid_lft forever preferred_lft forever    inet6 fe80::f816:3eff:fec7:7975/64 scope link        valid_lft forever preferred_lft forever这个命令显示了这台机器上所有的网卡。大部分的网卡都会有一个 IP地址，当然，这不是必须的。在后面的分享中，我们会遇到没有 IP 地址的情况。IP地址是一个网卡在网络世界的通讯地址，相当于我们现实世界的门牌号码。]{.orange}既然是门牌号码，不能大家都一样，不然就会起冲突。比方说，假如大家都叫六单元1001号，那快递就找不到地方了。所以，有时候咱们的电脑弹出网络地址冲突，出现上不去网的情况，多半是IP 地址冲突了。如上输出的结果，10.100.122.2 就是一个 IP地址。这个地址被点分隔为四个部分，每个部分 8 个 bit，所以 IP 地址总共是32 位。这样产生的 IP 地址的数量很快就不够用了。因为当时设计 IP地址的时候，哪知道今天会有这么多的计算机啊！因为不够用，于是就有了IPv6，也就是上面输出结果里面 inet6 fe80::f816:3eff:fec7:7975/64。这个有128 位，现在看来是够了，但是未来的事情谁知道呢？本来 32 位的 IP 地址就不够，还被分成了 5类。现在想想，当时分配地址的时候，真是太奢侈了。![](Images/ae7a86d02a4bebd9a9fbadc140970c4e.png){savepage-src="https://static001.geekbang.org/resource/image/0b/9e/0b32d6e35ff0bbc5d46cfb87f6669d9e.jpg"}在网络地址中，至少在当时设计的时候，对于 A、B、 C类主要分两部分，前面一部分是网络号，后面一部分是主机号。这很好理解，大家都是六单元1001 号，我是小区 A 的六单元 1001 号，而你是小区 B 的六单元 1001 号。下面这个表格，详细地展示了 A、B、C三类地址所能包含的主机的数量。在后文中，我也会多次借助这个表格来讲解。``{=html}![](Images/76a3c4be34d0311e0f048370a4261f81.png){savepage-src="https://static001.geekbang.org/resource/image/e9/be/e9c59a4b2f0b804356759b10440ea7be.jpg"}这里面有个尴尬的事情，就是 C 类地址能包含的最大主机数量实在太少了，只有254 个。当时设计的时候恐怕没想到，现在估计一个网吧都不够用吧。而 B类地址能包含的最大主机数量又太多了。6万多台机器放在一个网络下面，一般的企业基本达不到这个规模，闲着的地址就是浪费。
## 无类型域间选路（CIDR）于是有了一个折中的方式叫作**无类型域间选路**，简称**CIDR**。这种方式打破了原来设计的几类地址的做法，将32 位的 IP地址一分为二，前面是**网络号**，后面是**主机号**。从哪里分呢？你如果注意观察的话可以看到，10.100.122.2/24，这个IP 地址中有一个斜杠，斜杠后面有个数字 24。这种地址表示形式，就是CIDR。后面 24 的意思是，32 位中，前 24 位是网络号，后 8 位是主机号。伴随着 CIDR存在的，一个是**广播地址**，10.100.122.255。如果发送这个地址，所有10.100.122网络里面的机器都可以收到。另一个是**子网掩码**，255.255.255.0。将子网掩码和 IP 地址进行 AND 计算。前面三个 255，转成二进制都是 1。1和任何数值取 AND，都是原来数值，因而前三个数不变，为10.100.122。后面一个 0，转换成二进制是 0，0 和任何数值取 AND，都是0，因而最后一个数变为 0，合起来就是10.100.122.0。这就是**网络号**。**将子网掩码和 IP 地址按位计算AND，就可得到网络号。**