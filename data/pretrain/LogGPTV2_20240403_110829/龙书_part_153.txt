---
## Page 608
第5行之后，6只指向j。第6行之后c只指向i。
α、b和c。显然到第3行结束的时候，α指向h，指向i，c指向j
例12:22
控制流带来的影响。
12.4.3控制流无关性
问题提供了一个快速的求解方法，而且效果通常很好。
样的对象。虽然这种表示法不能很好地估算别名问题，但它仍然为哪些变量指向同一类对象的
based)的分析，使得形如v=w的语句把变量和w转变成一个等价类。等价类中的变量指向同
可以使用其他的方法来定义指向分析。比如，我们可以定义一个基于等价关系（equivalence-
变量指向w所指向的所有对象，但是反过来不成立。虽然这个方法看起来显而易见，但我们还
我们描述的是一个基于包含（inclusion-based）的分析技术。也就是说，一个形如v=w的语句使得
称为指针指向分析(points-to analysis）。如果两个指针的指向集合相交，那么它们互为别名。这
句创建的一个或者多个对象。”
以创建一-个新的对象，因此一个形如“v可以指向 h”的断言实际上是说"可以指向标号为h的语
命名。一个惯例是使用创建对象的语句来指定对象。因为一个语句可以被执行多次，每次都可
的块以及变量名本身。因此，我们可以区分标识符相同的多个变量。
h。请注意，变量可以通过它的全名来命名。在Java 中，这个全名包括了模块、类、方法和方法中
的堆对象h，不需要指出在程序中的什么地方可能指向h，或者在什么样的上下文中可以指向
从原则上讲，任何C语言的值都可以被强制转化成为一个指针。
语言建模时这个结构的效果就不太好，因为在C语言中指针变量可以指向其他指针变量。而且，
能指向一个变量)。
(heap object)。
量可以是静态的，也可能位于运行时刻栈中。我们简单地称它们为变量。
12.4.2—个指针和引用的模型
调用图。最后我们将描述一-个处理上下文相关性的方法。
们假设程序中没有方法调用。然后，我们描述如何在计算指针指向分析结果的同时动态地构造
析所有把这个指针所指向的内容赋给其他指针的语句。
次执行--个语句循环的效果。在指针分析中，当我们发现一个新的指针目标时，我们必须重新分
如果接着分析语句4～6，会发现在第4 行之后，α只指向i。
我们首先给出一个很简单的例子，说明在指针指向分析中忽略
分析的目标是确定各个变量以及每个对象的各字段可能指向哪些对象。我们把这个分析
雄对象没有名字。因为可能动态创建出无限多个对象，所以人们经常使用近似方式给对象
因为我们进行的是上下文无关的分析，所以只需要断定一个给定的变量能够指向一个给定
 3）--个堆对象可以有多个字段(feld)，一个字段的值可以是指向一个堆对象的引用(但是不
2）有一-个对象的堆。所有变量都指向堆中的对象，不指向其他变量。这些对象称为堆对象
592
可以使用这个结构很好地对Java 建模，我们将在例子中使用 Java 的语法。请注意，在对C
为简单起见，我们将主要关注Java。我们将从控制流无关和上下文无关的分析开始。当前我
上面的分析是控制流相关的，因为我们沿着控制流计算了在每个语句之后各个变量会指向哪个对
假设我们的语言可以用下列方式来表示和操作引用：
图12-20 中创建了三个对象h、i和j，并分别赋给变量
图12-20例12.22的
Java 代码
C=I
()sa[a0 nau = e
a；
b;
new Object();
new Object()
第12章
---
## Page 609
以指向H，那么V也可以指向H。
的赋值语句，变量V就可能指向堆对象 H。规则2 说明如果存在一个复制语句V=W，并且 W可
种写出一个规则。相应的程序在图 12-21 中给出。规则1 说明如果语句 H 是把一个新对象赋给
EDB 事实，它表示在语句 H中有一个赋值使得变量V指向--个新的类型为T的对象。在实践中，我们
明--个或者多个 EDB 关系。这些关系表示程序中存在这样的语句。比如，“H:TV=new T()”是一个
简化。我们没有定义专门的 EDB关系来存放从程序中获取的信息，而是使用带引号的语句的方式来指
所以只需要在 EDB 中确定程序中是否存在某种形式的语句。在接下来的内容中，我们将做一个方便的
现在，我们把这个分析用 Datalog 规则正式表示出来。首先，只需要计算两个 IDB 断言：
假设有一个对应的EDB 关系，其中包含的基础原子和程序中这种形式的语句一一对应。
堆对象h。这个语句使得变量u指向 h。
意，变量的值没有改变。
种引用类型。令指向堆对象h，并令w指向 g。这个语句使得h中的字段f现在指向 g。请注
即被复制到中。
调用，并将关注四种可能影响指针的语句：
12.4.4在 Datalog 中的表示方法
何指针可能指向任何对象。
。这个信息又影响了第5行，接着又影响了第4行。最后，我们只得到一个没有用的结论，即任
向
例12. 23回到例12.22,第1行到第3 行仍然告诉我们α可以指向h;b可以指向i；c可以指
得算法更快地收敛。
性大大弱化了分析的结果，但是这么做通常可以降低为表示分析结果而使用的数据的大小，并使
死"任何指向关系，而是只能“生成"更多的指向关系。为了计算控制流无关分析的结果，我们不
象，我们只记录它可能指向这两个对象。换句话说，在控制流无关分析中，任何赋值都不会“杀
按照任何顾序执行。它只计算--个全局性的指向映射，这个映射指明了每个变量在程序执行的
信息。比如，语句b=c；杀死了之前的事实"b 指向 "并生成了新的关系“b 指向c所指向的东西”。
象。换句话说，除了考虑各个语句生成哪些指向信息之外，我们也考虑了每个语句“杀死了”哪些指向
j。根据第4 行和第5行，α可以指向h和i;b可以指向i和j。根据第6行，c可以指向h、i和
根据这种约定，我们在编写 Datalog 程序时要做的全部工作就是为上面的四种语句中的每-
过程间分析
4）字段读取：V=W.f；
1）对象创建：h：Tu=new T(）；这个语句创建了--个新的堆对象，并且变量u可以指向它。
现在我们基于上面的讨论把一个控制流无关的指针别名分析正式表示出来。现在忽略过程
EDB 关系根据程序本身构造得到。因为在控制流无关的分析中，程序中语句的位置和分析无关,
2）hpts( H, F，G)表示堆对象 H的字段 F 可能指向堆对象 G。
1）pts(V，H)表示变量V可能指向一个堆对象 H。
2）复制语句：V=W；
一个控制流无关分析忽略了控制流。这么做实质上就是假设被分析程序中的各个语句可
请注意，源代码中的复合字段访问，比如V=w.f.g，可以被分解为两个基本的字段读取语句:
=vig:
这里和w是两个变量。这个语句使得u指向u 当前所指的堆对象
这里w是--个指向某个具有字段f的堆对象的变量，而f指向某个
593
口
---
## Page 610
附加约束，因为所有的保存运算必须通过变量
了一个类似的附加约束。请注意，在规则3中没
象可以被赋给指向类型T的变量。规则4 中也增加
堆对象 H 的类型分别是 T 和 S，并且类型为 S 的对
标表示我们可以断定 V可以指向 H的条件是
时才可以进行推理。新的规则在图12-23 中显示。
被赋值变量被贴
预定义类的信息。assignable( T，T)总是取真值。
中子类型的声明中收集的，同时也包含了关于语言
赋值给一个类型为T的变量。这个信息通常是从程户
类型。
返
析代码中的重要类型信息。我们将使用下面的断言：
一个类型为T的对象。这样，因为类型约束的原因，我们可以静态地断
类。如果P为真，这个程序将引发一个运行时刻异常，因为α不能被赋予
型
12.4.5使用类型信息
且 G 的字段 F 可以指向 H,那么 V可以指向 H。请注意，pts 和 hpts 是相互递归的，但是这个 Data-
回的，
α只能指向h 而不能指向 g。
g程序可以用任何一个在12.3.4 节中讨论的选代算法进行求值。
字段F可以指向G。最后，规则4 说明，如果存在一个形如V=W.F 的语句，W可以指向G，并
我们首先修改规则2。新规则的最后三个子
我们可以修改图12-21中的规则，使得只有
3)
因此，我们在分析技术中引人三个EDB 断言。这些断言反映了被分
594
2）
规则3 说明，如果存在－个形如V.F=W的语句，W可以指向 G，并且 V可以指向 H，那么 H
因
）assignable(T，S)表示类型为 S 的对象可以
，那么有可能不能精确决定它的类型。此时，被创建对象的类型可以被保守地设定为所有可能的
）uType( V，T)表示变量 V被声明为类型 T。
发一个运行时刻异常。考虑图12-22中的简单例子，其中S是T的子
1为 Java 是类型安全的，变量只能指向和它的声明类型相兼容的类
赋予的堆对象的类型是可赋值类
图12-21
二
hpts(H,F,G)
控制流无关指针分析的 Datalog 程序
pts(V,H)
ps(V, H)
pts(V, H)
V和
"
进
有
序
被
"V.F = W" 8
"H: TV z new TO)"
图12-23 向控制流无关指针分析增加类型约束
3) hpts(H,F,G)
2
8
pts(V,H) :-
pts(V,H)
pts(V, H)
图12-22具有类型错
pts(W,G) &
"V = W.F" &
assignable(T, S)
hpts(G,F,H) &
"V.F = W" &
assignable(T, S)
hType(H,S) &
uType(V,T)
pts(W, H) &
"V =W"”&
"H: T V = nen T()"
g：
误
的 Java 程序
Jelse
if (p){
S
=b;
b = new S();
b = new TO);
第12章
R
---
## Page 611
this，而z所指向的对象被赋给m 中声明的第一个形式参数。
各个方法的第0 个形式参数。在×=Y. n（z）中有两个形式参数：所指向的对象被赋给变
数，也包括接收对象本身。每个方法调用把接收对象赋给 this 变量。我们把 this 变量当
为n 的例程的的超类中的那个名为n 的例程。请注意，一般情况下只能动态确定被调用的方法。
而调用图又可以用于计算精确的指针指向分析结果。然后，我们正式描述如何动态地生成调用
12.5上下文无关的过程间分析
实都会在运行时刻发生。
并不表示任何可能在运行时刻产生的事件。这个问题的源头可以追溯
变量中。考虑图12-25 的程序。
算来模拟函数调用和返回操作，就可以把本节中的分析技术扩展为过
情况的过程内数据流分析技术。
我们就能够精确地推导出α可能指向h，且和c可能指向g。请给出一个可以避免这种不精确
应用本节中的算法将可以推导出α和b都可能指向h和g。如果代码写成
赋
程
中的 Datalog 规则来推导出所有可能的 pts 和 hpts 事实。
不是代码的一部分。你可以假设类型为T的对象有一个字段f。使用本节
12.4.612.4节的练3
对象为 null 常量的情况。
行,而这些变量的类型已经被检查过了。在其中加入的任何类型约束只能多处理一-种情况，即基
请记住,变量是通过它们所属的方法进行区分的,因此有很多个名字为 this 的变量,程序中的每个方法有--个
.5.1一个方法调用的效果
，并说明如何用 Datalog 简洁地描述这个分析过程。
值。对修改后的代码再次分析，说明每个推导得到的 pts 和 hpts 的事
对变量6的多次赋值。改写图12-25 中的代码，使得没有变量被多次