中序遍历线索化的递归函数代码如下：
BiThrTreepre：/.全局变量，始终指向刚刚访问过的站点*/
1中序遍历进行中序线索化*/
void InThreading（BiThrTree p)
if(p)
1
InThreading（p->1child）;/*递归左子树线索化*/
if（!p->lchild）
1没有左孩子
、
p->LTag=Thread;
1前驱线索/
p->lchild=pre;
1左孩子指针指向前疆*/
if（!pze->rchild)
1前驱没有右孩子*/
pre->RTag=Thread;
1后继线索*/
pre->rchild=p:
1前驱右孩子指针指向后继（当前结点p）*
pre-p:
/保神pre指向p的前驱*/
InThreading（p->rchi1d）：/·归右子树线化*/又
你会发现，这代码除加粗代码以外，和二叉树中序遍历的递归代码几乎完全一
样。只不过将本是打印结点的功能改成了线索化的功能。
中间加粗部分代码是做了这样的一些事。
if（lp->khild）表示如果某结点的左指针域为空，因为其前驱结点刚刚访问过，赋
值给了pre，所以可以将pre赋值给p->khid，并修改p->LTag=Thread（也就是定义
为1）以完成前驱结点的线索化。
后继就要稍稍麻烦一些。因为此时P结点的后继还没有访问到，因此只能对它的
前驱结点pre的右指针rchid做判断，if（!pre->rchil）表示如果为空，则p就是pre
的后继，于是pre->rchid=p，并且设置pre->RTag=Thread，完成后继结点的线索化。
完成前驱和后继的判断后，别忘记将当前的结点P赋值给pre，以便于下一次
192
---
## Page 217
第6章树
使用。
有了线索二叉树后，我们对它进行遍历时发现，其实就等于是操作一个双向链表
结构。
和双向链表结构一样，在二叉树线索链表上添加一个头结点，如图6-10-6所示，
并令其khid城的指针指向二叉树的根结点（图中的①），其rchild城的指针指向中序
遍历时访问的最后一个结点（图中的②）。反之，令二叉树的中序序列中的第一个结点
中，khild城指针和最后一个结点的rchil城指针均指向头结点（图中的③和④）。这
样定义的好处就是我们既可以从第一个结点起顺后继进行遍历，也可以从最后一个结
点起顺前驱进行遍历。
头结点
F10B0
图6-10-6
遍历的代码如下：
/T指向头结点，头结点左链1chi1d指向根结点，头结点右链rchild指向中序遍历的*/
/最后一个结点。中序遍历二叉线索键表表示的二叉树T·/
Status InOrderTraverse_Thr（BithrTree T）
2
3
BiThrTree pi
P-T->1child;
P指向根结点/
while（p!-T）
7空树或遍历结束时，pmT/
6
7
while（p->LTag--Link）/*多LTag--0时德环到中序序列第一个结点/
p-p->lchi1d;
193
---
## Page 218
大据数据结构
9
printf（“ec"，p->data）：/·显示结点数据，可以更改为其他对结点操作*/
10
while（p->RTag==Thread 66p->rchild!=)
11
12
P-p->rchild;
13
printr（"sc",p->data);
14
15
P-p->rchild;
/P进至其右子树根*/
16
17
return OK;
181
1.代码中，第4行，p=T->khild意思就是图6-10-6中的①，让p指向根结点开
始遍历。
2.第5~16行，while（pl=T）其实意思就是循环直到图中的④的出现，此时意
味着p指向了头结点，于是与T相等（T是指向头结点的指针），结束循环，
否则一直循环下去进行遍历操作。
3.第7~8行，whid（p->LTag==Link）这个循环，就是由A一B→D→H，此时H
结点的LTag不是Link（就是不等于0），所以结束此循环。
4.第9行，打印H。
5.第10~14行，while（p->RTag==Thread &&p->rchid!=T），由于结点H的
RTag==Thread（就是等于1），且不是指向头结点。因此打印H的后继D，之
后因为D的RTag是Link，因此退出循环。
6.第15行，p=p->rchikb意味着p指向了结点D的右孩子1。
7.*，就这样不断循环遍历，路径参照图6-10-4，直到打印出HDIBJEAFCG，
结束退历操作。
从这段代码也可以看出，它等于是一个链表的扫描，所以时间复杂度为0（n）。
由于它充分利用了空指针域的空间（这等于节省了空间），又保证了创建时的一次
遍历就可以终生受用前驱后继的信息（这意味着节省了时间）。所以在实际问题中，如
用线索二叉链表的存储结构就是非常不错的选择。
194
---
## Page 219
第6章树
6.11树、森林与二叉树的转换
我之前在网上看到这样一个故事，不知道是真还是假，反正是有点意思。
故事是说联合利华引进了一条香皂包装生产线，结果发现这条生产线有个缺陷：
常常会有盒子里没装入香皂。总不能把空盒子卖给顾客响，他们只好请了一个学自动
化的博士设计一个方案来分拣空的香皂盒。博士组织成立了一个十几人的科研攻关小
组，综合采用了机械、微电子、自动化、X射线探测等技术，花了几十万，成功解决
了问题。每当生产线上有空香皂盒通过，两旁的探测器会检测到，并且驱动一只机械
手把空皂盒推走。
中国南方有个乡镇企业也买了同样的生产线，老板发现这个问题后大为光火，找
了个小工来说：你把这个间题搞定，不然老子炒你鱿鱼。小工很快想出了办法：他在
生产线旁边放了台风扇猛吹，空皂盒自然会被吹走。
这个故事在网上引起了很大的争议，我相信大家听完后也会有不少的想法。不过
我在这只是想说，有很多复杂的问题都是可以有简单办法去处理的，在于你肯不肯动
脑筋，在于你有没有创新。
我们前面已经讲过了树的定义和存储结构，对于树来说，在满足树的条件下可以
是任意形状，一个结点可以有任意多个孩子，显然对树的处理要复杂得多，去研究关
于树的性质和算法，真的不容易。有没有简单的办法解决对树处理的难题呢？
我们前面也讲了二叉树，尽管它也是树，但由于每个结点最多只能有左孩子和右
孩子，面对的变化就少很多了。因此很多性质和算法都被研究了出来。如果所有的树
都像二叉树一样方便就好了。你还别说，真是可以这样做。
图6-11-1
195
---
## Page 220
大调数据结构
在讲树的存储结构时，我们提到了树的孩子兄弟法可以将一棵树用二叉链表进行
存储，所以借助二叉链表，树和二叉树可以相互进行转换。从物理结构来看，它们的
二叉链表也是相同的，只是解释不太一样而已。因此，只要我们设定一定的规则，用
二叉树来表示树，甚至表示森林都是可以的，森林与二叉树也可以互相进行转换。
我们分别来看看它们之间的转换如何进行。
6.11.1树转换为二叉树
将树转换为二叉树的步骤如下
1.加线。在所有兄弟结点之间加一条连线。
2.去线。对树中每个结点，只保留它与第一个孩子结点的连线，删除它与其他孩
子结点之间的连线。
3.层次调整。以树的根结点为轴心，将整棵树顺时针旋转一定的角度，使之结构
层次分明。注意第一个孩子是二叉树结点的左孩子，兄弟转换过来的孩子是结
点的右孩子。
例如图6-11-2，一棵树经过三个步骤转换为一棵二叉树。初学者容易犯的错误就
是在层次调整时，弄错了左右孩子的关系。比如图中F、G本都是树结点B的孩子，
是结点E的兄弟，因此转换后，F就是二叉树结点E的右孩子，G是二叉树结点F的
右孩子。
A
A
C
D
G00000
树
步骤1：给兄弟加线
B
C
D
B
（D）
步骤2：给除长子外的孩子去线
步骤3：层次调整
图6-11-2
196
---
## Page 221
9
6.11.2森林转换为二叉树
森林是由若干棵树组成的，所以完全可以理解为，森林中的每一棵树都是兄弟，
可以按照兄弟的处理办法来操作。步骤如下：
1.把每个树转换为二叉树。
2.第一棵二叉树不动，从第二棵二叉树开始，依次把后一棵二叉树的根结点作为
前一棵二叉树的根结点的右孩子，用线连接起来。当所有的二叉树连接起来后
就得到了由森林转换来的二叉树。
例如图6-11-3，将森林的三棵树转化为一棵二叉树。
E
G
H
D
拥有三棵树的森林
步骤1：森林中每棵树转换为二叉树
A
D
步骤2：将所有二叉树转换为一棵二叉树
图6-11-3
6.11.3二叉树转换为树
二叉树转换为树是树转换为二叉树的逆过程，也就是反过来做而已。如图6-11-4
所示。步骤如下：
1.加线。若某结点的左孩子结点存在，则将这个左孩子的右孩子结点、右孩子的
右孩子结点、右孩子的右孩子的右孩子结点哈，反正就是左孩子的n个
197
---
## Page 222
大据数据结构
右孩子结点都作为此结点的孩子。将该结点与这些右孩子结点用线连接起来。
2.去线。删除原二叉树中所有结点与其右孩子结点的连线。
3.层次调整。使之结构层次分明。
A
B
E
?
?
D
F
D
二叉树
步骤1：加线
A
B
C
F
D
步骤2：去线
步骤3：层次调整
图6-11-4
6.11.4二叉树转换为森林
判断一棵二叉树能够转换成一棵树还是森林，标准很简单，那就是只要看这棵二
叉树的根结点有没有右孩子，有就是森林，没有就是一棵树。那么如果是转换成森
林，步骤如下：
1.从根结点开始，若右孩子存在，则把与右孩子结点的连线删除，再查看分离后
的二叉树，若右孩子存在，则连线删除…，直到所有右孩子连线都删除为
止，得到分离的二叉树。
2.再将每棵分离后的二叉树转换为树即可。
198
---
## Page 223
第6章树
C
F
F
G
D
H
D
H
J
二叉树
步骤1：寻找右孩子去线
E
G
步骤2：将分离的二叉树转换成树
图6-11-5
6.11.5树与森林的遍历
最后我们再谈一谈关于树和森林的遍历问题。
树的遍历分为两种方式。
1.一种是先根遍历树，即先访问树的根结点，然后依次先根遍历根的每棵子树。
2.另一种是后根遍历，即先依次后根遍历每棵子树，然后再访问根结点。比如图
6-11-4中最右侧的树，它的先根遍历序列为ABEFCDG，后根遍历序列为
EFBCGDA
森林的遍历也分为两种方式：
1.前序遍历：先访问森林中第一棵树的根结点，然后再依次先根遍历根的每棵子
树，再依次用同样方式遍历除去第一棵树的剩余树构成的森林。比如图6-11-5