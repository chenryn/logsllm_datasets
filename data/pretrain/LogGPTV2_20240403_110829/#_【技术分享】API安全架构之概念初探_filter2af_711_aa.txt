# 技术分享：API安全架构的概念初探

#### 译文声明
本文为翻译文章，原文来源于websec.io。译文仅供参考，具体内容及含义以原文为准。

译者：[阿诺斯基](http://bobao.360.cn/member/contribute?uid=2826612711)  
预估稿费：200 RMB  
投稿方式：发送邮件至 linwei#360.cn 或登录网页版在线投稿

## API驱动的世界
随着时间的推移，我们的世界正变得越来越紧密。新服务不断涌现，旨在让生活更加简单和愉快。在这些变化的背后，一种技术逐渐崭露头角——API驱动架构。API允许服务在程序级别上相互通信，并提供可预测的响应功能，供其他服务使用。

如果你在过去七八年内从事过任何形式的开发工作，那么你很可能已经接触过某种形式的API。无论是为公司创建API，还是将API作为创业公司的核心产品，都已成为常态。甚至有人开玩笑说，没有API的服务已经落伍了。

然而，API的开发也带来了一些挑战。开发者通常更擅长前端和面向客户的功能开发，而在深入API时可能会感到困惑。尽管基础知识（如HTTP请求/响应和输入处理）依然适用，但实现方式有所不同。表示层被完全剥离，重点放在共享的数据上，而不是其外观。你的任务是设计出既实用又具有良好演示性和用户体验的功能。

本文将重点介绍REST API，而非SOAP或RPC。REST在API领域中占据主导地位，因此如果你计划实施新的API，这应该是首选方向。

对于API新手来说，很容易倾向于仅关注“让它工作”——即在特定端点接收数据请求并返回相应的响应。虽然这是最终目标，但在创建API时，还需要做出一些选择并确保其安全性。由于API主要与其他“机器”通信，人们往往认为其安全性可以比面向客户的应用程序宽松一些。实际上，这种观点并不正确。在确保API的安全性方面，需要考虑以下概念和因素。

## 概念
首先，让我们讨论一下保护API的基础知识。这里介绍的方法并不是唯一的，而是一种说明基本安全概念的方式。建议在确定方案之前评估全球性的API保护方案。我将展示的方法适用于希望保持安全且不希望引入过多开销的API。

我们将采用“共享密钥”系统，其中API和客户端都有用于认证和发送消息的秘密信息（在这种情况下为令牌）。有些系统使用静态令牌，但如果攻击者发现该令牌，可能会导致严重问题。攻击者可以模拟用户的消息并绕过验证机制。

为了避免这种情况，我选择了多令牌、可撤销的系统，用户可以创建所需的令牌并随时撤销它们。如果你是GitHub用户，可能熟悉这种令牌系统。它的工作方式类似，只是增加了更多元数据。

如果你熟悉OAuth v2的处理过程，这个设置听起来会很熟悉。与OAuth事务类似，有一个秘密令牌和前后切换，但涉及的内容更多。需要注意的是，OAuth的主要目的是授权而非身份验证。例如，当你点击网站上的“使用Twitter登录”按钮时，应用程序会将你重定向到Twitter站点并请求授权批准。你点击“允许”按钮后，流程继续。这就是OAuth在幕后处理的事情。通过此流程，你已授权应用程序使用你的Twitter信息来识别你。

然而，当Twitter能够登录你的账户时，另一个应用程序并不知道你是否真的是你所说的——他们已经接受了风险并将决定权交给了Twitter。

### 注意事项
在使用基于令牌的系统时，请确保URL中不包含令牌。默认情况下，URL请求会被记录在Web服务器日志中。如果攻击者获取了日志中的令牌（尤其是生命周期较长的），他们只需找到日志存储位置即可访问所有令牌。

在我们即将创建的系统中，还将有另一个方面的令牌来提高安全性——限制其有效时间。我们谈论的令牌是认证后的请求中使用的令牌，而不是用于身份验证的令牌。通过限制这些令牌的存活时间，我们可以减少攻击者拦截和重新使用令牌的可能性。在我们的系统中，令牌的有效时间为1小时，这通常足以让用户成功运行API，同时仍能提供足够的保护。

当令牌过期时，客户端将收到认证失败的消息，只需请求新的令牌即可。在OAuth的世界中，他们会发送一个“刷新令牌”来专门用于令牌“refetch”请求，但由于我们在这里采用了一个更简单、更轻量级的版本，所以只需手动请求新的令牌。

## 基本流程
我已经描述了这个API的运作过程，现在让我详细介绍一下正常会话的流程，包括身份验证和后续请求。

### 1. 令牌创建
用户进入应用程序的管理部分，生成用于身份验证的新令牌。该令牌是一个随机字符串，由数字和符号组成，在认证请求期间使用。

### 2. 认证
一旦拥有令牌，用户将向API端点发出一个POST请求及其凭据：用户名和令牌。请注意，不要使用GET请求，因为这会将凭据信息暴露在服务器日志中，这是非常危险的。

系统会对令牌和提供的用户名进行查找并确保匹配。如果一切正常，响应将包含一个随机生成的、有时限的令牌，用于当前会话。该令牌用作后续请求的标识符，并确保消息未被篡改。如果用户在令牌有效期内执行另一个认证请求，每次都会获得新的令牌，以进一步降低潜在攻击者的令牌拦截和重用的风险。

### 3. 后续请求
有了这个令牌，客户端可以向API中的其余端点发出请求。目前，我们的系统不会强制执行任何权限，只有认证网关。在一个真正的API中，需要一个更复杂的系统来保护各个端点，并确保只有授权用户才能访问。

要发出请求，客户端必须执行以下任务：
1. 在名为“X-Token”的header中发送认证产生的令牌。
2. 创建要发送的消息内容的HMAC散列，并将其包含在X-Token-Hash header中。

使用PHP，第二步可以很容易地使用`hash_hmac`方法实现：

```php
$body = json_encode(['foo' => 'bar']);
$messageHash = hash_hmac('SHA512', $body, $hash . time());
```

在上面的代码中，我们正在创建`$body`内容的SHA512 HMAC散列，并使用`$hash`和当前时间（以秒为单位）作为密钥。当消息回到服务器时，系统会根据相同的信息重新创建哈希值，并与X-Token-Hash header中发送的值进行比较。如果发现不匹配，系统就知道消息内容已被更改，并可以拒绝该请求。

### 注意事项
精明的读者可能已经注意到一个小问题——需要在几秒钟内使用当前时间。在实际工作中，这确实成为了一个问题，因为用户的系统时钟可能没有正确同步。为了缓解这种情况，你可以将时间值稍微放宽一些，使用分钟级的时间而不是秒级的时间。时间的作用是为生成HMAC哈希值提供一些随机性，使每个请求都不一样。如果设置为秒级时间，可能会导致很多问题。

```php
$time = date('YmdHi'); // 使用分钟级时间
$messageHash = hash_hmac('SHA512', $body, $hash . $time);
```

通过这种方式，我们可以确保即使时钟略有偏差，请求仍然有效。