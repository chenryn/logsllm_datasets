# 【技术分享】API安全架构之概念初探
|
##### 译文声明
本文是翻译文章，文章来源：websec.io
原文地址：
译文仅供参考，具体内容表达以及含义原文为准。
****
译者：[ **阿诺斯基**](http://bobao.360.cn/member/contribute?uid=2826612711)
预估稿费：200RMB
投稿方式：发送邮件至linwei#360.cn，或登陆网页版在线投稿
**  
**
**API驱动的世界**
**毫无疑问，随着时间的推移，我们所生活的世界正在变得越来越紧密。新的服务正在出现，目的是使我们的生活更简单，更愉快。在所有这些变化的背后，这些服务的组合是一种真正进入自己的技术：API驱动架构。**
这些API允许服务在程序级别相互通信，并提供其他服务可以以自己有用的方式消费和使用的可预测的响应功能。
如果你在过去七，八年内一直在进行着任何形式的开发，那么你可能会遇到某种形式或前卫的API。也许你为你的公司创建了一个API，或者你是一个创业公司，而API
就是你的产品。这几天有个笑话是，如果你没有API，那么你的服务久已经落后于时代。
然而，伴随着API的创建也会产生一些犹豫。开发人员在前端，面向客户的开发和功能方面更加舒适，在深入了解API的过程中，可能会感觉到其构建的深度。虽然基础的知识仍然存在（如HTTP请求/响应和输入处理），但它们的实现方式存在不同的问题。表示层被完全删除，重点放在被共享的数据上，而不是它的外观。你的任务是制定一些功能和实用性，使其具有更好的演示性和用户体验。
这里有一个简短的说明 – **本文将重点介绍REST API**
，而不是SOAP（或RPC）。REST在API领域已经明显地领先，如果你计划实施新的API，那这肯定是你选择的方向。
如果一个开发人员对于API的世界来说是相对陌生的，那么很自然的倾向就是做出“只是工作”的东西 –
在特定的端点上接收数据请求，并回复所请求的匹配。虽然这是最终的目标，但是在创建API时也有个事情同样重要：做出选择并做好充分保护的工作。这很容易理解，因为它是一个API，只有其他的“机器”会说话，它的安全性可以比面向客户的应用程序更加宽松。显然，没有什么可以从真相中更进一步。但是，在确保面向客户的工具中不需要的API时，就需要考虑到这些问题。让我们先来看一下这些概念和考虑因素，
**概念**
首先，让我们来谈谈有关保护API的一些基础知识。要开始这个话题，我会在这里先说一件事 –
稍后将介绍保护API的方式并不是唯一的办法。这只是一个方法，我已经放在一起说明了一些API的基本安全概念。有一个全球性的API保护方案，他们应该在你确定之前进行评估。我将展示的方法对于一个希望安全的API来说非常棒，但是不希望其他系统可以带来很多开销。
我们将使用的方法是使用“共享密钥”系统，其中API和客户端都具有用于认证和发送消息的秘密信息（在这种情况下为令牌）。我看到一些类似系统的系统实现，并利用一个系统，每个请求使用一个静态标记。但是，如果攻击者发现了这个令牌，这可能会导致严重的问题。攻击者可以模拟用户的消息并潜在地绕过验证机制。
我这里说的不是一个单一的令牌系统，我已经选择了一个多重令牌，可撤销的系统，让用户创建他们想要的令牌，描述他们的使用，另一个主要的好处 –
随时撤销它们。如果你是GitHub用户，那么你可能熟悉它的令牌系统。它以类似的方式工作，只需要添加更多元数据。
如果你熟悉OAuth
v2的处理过程，那么这个设置听起来久很熟悉。与OAuth事务有一个类似的秘密令牌和前后切换，但这里会涉及到更多的东西。另外请记住，设计OAuth并不是主要用于身份验证。其主要目的是授权。例如，
**考虑在网站上看到的所有“使用Twitter登录”功能。当你点击该按钮时，应用程序会将你返回到Twitter站点并要求获得授权批准。你点击“允许”按钮，流程就会继续。这就是OAuth，它正在处理幕后的事情。使用该流程，你就已经授权应用程序使用你的Twitter信息来识别你。**
然而，到Twitter可以登录你的帐户时，另一个应用程序并不知道你是否真的是你所说的 – 他们已经接受了风险，并将这一决定移交给了Twitter。
在这里有一个这样的警告：在使用像这样的基于令牌的系统时，请确保所请求的URL中不是以令牌结束的。默认情况下，URL请求会记录到Web服务器日志中。如果你的URL中的令牌（特别是生命周期比较长的）被攻击者获取，所有的攻击者必须做的是找到你的日志存储的位置，并访问他们想要的所有令牌。
在我们将要创建的系统中，还将有另一个方面的令牌来帮助提高他们的安全性 –
限制他们的有效时间。我在这里谈论的令牌是认证后的请求中所使用的令牌，而不是用于身份验证的令牌。通过限制这些令牌“存活”的时间，我们能够减少攻击者被拦截和重新使用的可能性。在我们的系统中，会将token的有效时间限制为1小时。这个时间内通常足以让用户能够使用API成功运行，但仍然需要为请求提供足够的保护。
当令牌过期时，客户端将被发送一个关于认证失败的消息，他们只需要请求一个新的令牌。在OAuth的世界里，他们发送一个“刷新令牌”，它专门用于这种令牌“refetch”请求，但是由于我们在这里搞了一个更简单，更轻的版本，所以我们只需要坚持手动要求获取新的令牌就行了。
**基本流程**
我已经描述了这个API的运作过程，但是让我花一些时间来遍历正常会话的流程，包括身份验证和剩余的请求。
**1.令牌创建**
我们将会把用户进入应用程序的管理部分当做次过程的开始，并生成用于身份验证过程的新令牌。该令牌是一个随机的字符串，数字和符号，在认证请求期间（并且仅用于）使用。
**2.认证**
一旦我们拥有了令牌，用户将向API上的端点发出一个POST请求及其凭据：用户名和“密码”的令牌。如前面所述，你不希望将此请求使用GET方式，因为这会将凭据信息显示在服务器日志中…这是一件不好的事情。
对令牌和所提供的用户名进行查找，并确保匹配。如果一切都很好，那么响应将包含我们随机生成的有时间限制的令牌，用于当前会话。该令牌用作以下请求中的标识符，并确保正在发送的消息未被篡改。如果用户在该令牌仍然有效的时间内执行另一个认证请求，则每次都会给予新的令牌，以进一步降低潜在攻击者的令牌拦截和重用的风险。
**3.跟随请求**
有了这个令牌，客户端就可以向API中的其余端点发出请求。我们的系统目前不会强制执行任何权限，只有已经认证的网关。在一个真正的API中，需要有一个更复杂的系统来帮助保护各个端点，并确保只有使用它们的用户才能访问。
要发出请求，客户端必须执行几个任务：
1.在名为“X-Token”的header中发送认证产生的令牌
2.创建要发送的消息的内容的HMAC散列，并将其包括为X-Token-Hash头
使用PHP，第二步可以很容易的使用hash_hmac方法实现：
     'bar']);
    $messageHash = hash_hmac('SHA512', $body, $hash.time());
    ?>
在上面的代码中，我们正在创建$body内容的SHA512
HMAC散列，并使用$hash身份验证请求以及当前时间（以秒为单位）作为key。当消息回到服务器时，这个哈希值是根据相同的信息重新创建的，并且与X-Token-Hash header中发送的值进行比较。如果系统发现不匹配，那么系统就知道消息的内容已被更改，并可以完全拒绝。
精明的读者可能已经注意到这个请求处理的一个小问题
–需要在几秒钟内使用当前时间。在过去一段时间，我已经在工作中用到了很多API，这的确成为了一个问题，因为他们的用户遍布世界各地，有时候他们的系统上的时钟没有正确的同步。因此，无论发送什么，请求均会出现“Bad
Request”的消息。为了帮助解决这种情况，你可以将被使用的时间值修改的“稍长一点”，使用分钟级的时间而不是秒级的时间。包含时间的要点是提供一些随机性来生成HMAC哈希值，因此每个请求都不一样。如果把它设置为秒级别的时间会造成很多问题，
     'bar']);
    $time = date('ymdHi');
    $messageHash = hash_hmac('SHA512', $body, $hash.$time);
    ?>