these for membership in XSet. To enable this the client
sends, for the c-th tuple in t, an n-long array xtoken[c] de-
878EDBSetup(DB, RDK)
Key Generation. D picks key KS for PRF Fτ and keys KT , KX , KI for PRF Fp. Fτ and Fp are PRF’s which output strings
in respectively {0, 1}τ and Z ∗
p , and τ is a security parameter.
• Initialize XSet to an empty set, and initialize T to an empty array indexed by keywords from W.
• For each w ∈ W, build the tuple list t and insert elements into set XSet as follows:
– Initialize t to be an empty list.
– Set strap ← Fτ (KS , w) and (Kz , Ke) ← (Fτ (strap, 1), Fτ (strap, 2)).
– Initialize c ← 0; then for all ind in DB(w) in random order:
∗ Set rdk ← RDK(ind), e ← Enc(Ke, (ind|rdk)), xind ← Fp(KI , ind).
∗ Set c ← c + 1, zc ← Fp(Kz , c), y ← xind · z−1
∗ Set xtag ← gFp(KX ,w)·xind and add xtag to XSet.
. Append (e, y) to t.
c
– T[w] ← t.
• Create (TSet, KT ) ← TSetSetup(T), and output key K = (KS , KX , KT , KI ) and EDB = (TSet, XSet).
Search protocol
Client C on input K deﬁned as above and a conjunctive query ¯w = (w1, . . . , wn):
• Sets stag ← TSetGetTag(KT , w1); strap ← Fτ (KS , w1), (Kz , Ke) ← (Fτ (strap, 1), Fτ (strap, 2)).
• Sends to the server E the message (stag, xtoken[1], xtoken[2], . . .) where xtoken[·] are deﬁned as:
– For c = 1, 2, . . ., until E sends stop:
∗ Set zc ← Fp(Kz , c) and set xtoken[c, i] ← gFp(KX ,wi)·zc for i = 2, . . . , n.
∗ Set xtoken[c] ← (xtoken[c, 2], . . . , xtoken[c, n]).
Server E on input EDB = (TSet, XSet) responds as follows:
• Retrieve t ← TSetRetrieve(TSet, stag) from TSet.
• For c = 1, . . . , |t| do:
– Retrieve (e, y) from the c-th tuple in t
– If ∀i = 2, . . . , n : xtoken[c, i]y ∈ XSet then send e to client C.
• When last tuple in t is reached, sends stop to C and halt.
For each received e client C computes (ind|rdk) ← Dec(Ke, e) and outputs (ind, rdk).
Figure 1: OXT: Oblivious Cross-Tags SSE Scheme
c = gFp(KX ,wi)·xind, meaning that the server
ﬁned by xtoken[c, i] := gFp(KX ,wi)·zc , i = 1, . . . , n, where
zc is the precomputed blinding derived by C from w (via
a PRF) and the tuple counter c. E then performs the T-
set search to get the results for w1, and for each c it ﬁl-
ters the c-th result by testing if xtoken[c, i]yc ∈ XSet for all
i = 2, . . . , n. This protocol is correct because xtoken[c, i]yc =
gFp(KX ,wi)·zc ·xind·z−1
correctly recomputes the pseudorandom values in the XSet.
Putting these ideas together results in the OXT protocol of
Figure 1. Note that C sends the xtoken arrays (each holding
several values of the form gFp(KX ,wi)·zc ) until instructed to
stop by E . There is no other communication from server to
client (alternatively, server can send the number of elements
in TSet(w) to the client who will respond with such number
of xtoken arrays).
Note. The OXT protocol in Figure 1 derives keys Ke, Kz
slightly diﬀerently than in the OXT description of [9]. The
modiﬁed key derivation is closer to what we need for MC-OXT
and OSPIR-OXT protocols presented in the following sec-
tions, without aﬀecting the functionality or security of OXT.
3. MULTI-CLIENT SSE
We present an extension of the OXT protocol for the multi-
client SSE (MC-SSE) setting described in the introduction
and in more detail below. The extension preserves the func-
tionality of OXT, supporting any boolean query, and superb
performance, while securely serving multiple clients, all of
which can behave maliciously.
Multi-Client SSE Setting. In MC-SSE there is the owner
D of the plaintext database DB, an external server E that
holds the encrypted database EDB, and clients that receive
tokens from D in order to perform search queries at E . In
other words, D is outsourcing her search service to a third
party but requires clients to ﬁrst obtain search tokens from
her. Her goal is to ensure service to clients via E while leak-
ing as little as possible information to E about the plaintext
data and queries, and preventing clients from running any
other DB queries than those for which D issued them a to-
ken. This is a natural outsourcing setting of increasing value
in cloud-based platforms, and it was described by Chase and
Kamara [11] as an SSE with controlled disclosure.
Formally, the MC-SSE setting changes the syntax of an
SSE scheme by including an additional algorithm GenToken
879which on input the secret key K, generated by the data
owner D in the EDBSetup procedure, and a boolean query
ψ( ¯w), submitted by client C, generates a search-enabling
value token. Then, procedure Search is executed by server E
on input EDB, but instead of the client C running on input
K and query ψ( ¯w) (as in SSE), C runs on input consist-
ing only of the search token token. Correctness is deﬁned
similarly to the SSE case, namely, assuring (except for neg-
ligible error probability) that C’s output sets DB(ψ( ¯w)) and
RDK[DB(ψ( ¯w))]. Security is treated in Section 5.
3.1 The MC-OXT Protocol
We describe the changes to OXT from Figure 1 needed to
support boolean queries in the MC-SSE setting. As before,
the protocol is described for conjunctions with the adapta-
tion to boolean queries described in Section 4.2.
EDBSetup(DB, RDK). This pre-processing phase is identical
to the one in OXT except for the addition of a key KM
shared between D and E . The output from this phase is K =
(KS, KX , KT , KM ) kept by D and EDB = (KM , TSet, XSet)
stored at E .
GenToken(K, ¯w). This is the new MC-speciﬁc phase in which
D, using key K, authorizes C for a conjunction ¯w = w1, . . . , wn
and provides C with the necessary tokens to enable the search
at E . We assume w1 to be the s-term (and chosen by D who
has knowledge of term frequencies). Speciﬁcally, D performs
the following operations. She sets stag ← TSetGetTag(KT , w1)
and strap ← Fτ (KS, w1), same as C does in OXT. Then,
for i = 2, ..., n, she picks ρi ← Z ∗
p and sets bxtrapi ←
gFp(KX ,wi)·ρi . Finally, she sets
env ← AuthEnc(KM , (stag, ρ2, ..., ρn)) and outputs token =
(env, strap, bxtrap2, . . . , bxtrapn) (which C uses in the search
phase).
To see how this enables search as in OXT, ﬁrst note that
with xtrapi = gFp(KX ,wi), i = 2, . . . , n, the client can pro-
duce the values gFp(KX ,wi)·zc needed in the Search phase of
OXT. Hence, D could just provide the xtrapi values to C.
However, D needs to be able to sign (or MAC) these values
so that E can check that C is authorized to this query and,
e.g., did not truncate a conjunction or mix parts from dif-
ferent queries. Signing the plain xtrap values does not work
since these values must not be seen by E (it would allow E
to learn information from unauthorized searches). The so-
lution is to provide C with a homomorphic signature that C
can convert into individual signatures for all tokens sent to E .
This is accomplished as follows: D picks one-time blinding
factors ρ2, . . . , ρn and provides C with blinded (or MAC’ed)
xtrap values bxtrapi = xtrapρi
for j = 2, . . . , n, while pro-
viding the blinding factors (ρ2, . . . , ρn) to E in an encrypted
and authenticated envelope env. To produce gFp(KX ,wi)·zc
during Search, C will compute bxtrapzc
i and E will raise this
value to 1/ρi. Security relies on the fact that if C provides E
with values other than those given by D, then when raised
to 1/ρi by E (where ρi is random and unknown to C) the re-
sulting values will not correspond to elements of XSet except
with negligible probability.
i
Search Protocol. The Search protocol reﬂects the above changes:
On token = (env, strap, bxtrap2, ..., bxtrapn), C computes (Kz, Ke)
from strap as in OXT. Then, it sends to E the value env as
well as the sequence bxtoken[1], bxtoken[2], . . . which contains
the same values as xtoken[1], xtoken[2], . . . in OXT up to the
blinding exponents ρi. Speciﬁcally, the values bxtoken[c, i],
for i = 2, . . . , n, are computed by C as (bxtrapi)zc. On
the receiving side, E veriﬁes the authenticity of env and de-
crypts it to ﬁnd stag, which it uses to retrieve TSet(w1), and
ρ2, . . . , ρn. The only change from OXT is that the operation
xtoken[c, i]y is replaced with bxtoken[c, i]y/ρi .
Note (masking the size of TSet(w1)). MC-OXT leaks to
C the size of TSet(w1) = DB(w1) given by the number of
bxtoken vectors requested by E . Note that the exact size of
this set can easily be masked by E requesting more bxtoken
values from C than needed. We observe that some form of
leakage on the frequency of the least frequent term in the
conjunction appears to be inherent even for plaintext search
algorithms. Indeed, it is likely (though there seem to be no
proven lower bounds) that running time will be noticeably
diﬀerent for conjunctions with all terms being infrequent
from the case that all terms are very frequent, except if
short searches are artiﬁcially padded to full database size
(or if conjunctions are pre-computed). Two considerations
in masking the size of TSet(w1) are that (i) the masked
size should be chosen as a step function of |TSet(w1)| (and
not, say, a ﬁxed linear function); (ii) During search, E should
return to C all results matching a query only after E received
all the bxtoken vectors from C; indeed, sending the results
as soon as they are found to match the query would leak
information on |TSet(w)| to C (since no ind’s will be returned
after C sends |TSet(w)| tokens). In the full version [20] we
show a strategy applied by D during EDBSetup to allow E
to send results as soon as they are found while avoiding the
above leakage.
4. OUTSOURCED SYMMETRIC PIR
The OSPIR (for Outsourced Symmetric PIR) setting aug-
ments the MC-SSE setting with an additional requirement:
The database owner D should learn as little as possible about
queries performed by clients while still being able to verify
the compliance of these queries to her policy. Here we extend
MC-OXT to this setting by augmenting the token generation
component GenToken to support “blinding” by the client of
query requests sent to D, and adding a mechanism for D
to enforce policy-compliance of the query when only hav-
ing access to their blinded versions. OSPIR-OXT supports
attribute-based policies where D learns information about
query attributes but nothing about values (e.g., D may learn
that a query includes a last-name, a zipcode and two words
from a text ﬁeld but nothing about the actual queried key-
words). The security model adds D as a new adversarial
entity trying to learn C’s hidden query values. Refer to the
introduction for more discussion about the OSPIR setting
and attribute-based policies.
OSPIR SSE Syntax. An OSPIR-SSE scheme replaces
the GenToken procedure which in MC-SSE is executed by
the data owner D on the cleartext client’s query ¯w, with a
two-party protocol between C and D that allows C to com-
pute a search-enabling token without D learning ¯w. In addi-
tion, D should be able to enforce an attribute-based query-
authorization policy on these queries. For this, we assume
that keyword set W is partitioned into m attributes, and
let I(w) denote the attribute of keyword w.3 An attribute-
based policy is represented by a set of attribute-sequences
3
We assume that the string representing w has its attribute encoded
into it, i.e. w = (i, val) for i = I(w), so that Ryan as a ﬁrst name is
distinguished from Ryan as a last name.
880P s.t. a conjunctive query ¯w = (w1, ..., wn) is allowed by
policy P if and only if the sequence of attributes av( ¯w) =
(I(w1), ..., I(wn)) corresponding to this query is an element
in set P. Using this notation, the goal of the GenToken pro-
tocol is to let C compute token corresponding to its query
¯w only if av( ¯w) ∈ P. Reﬂecting these goals, an OSPIR-SSE
scheme is a tuple Σ = (EDBSetup, GenToken, Search) where
EDBSetup is an algorithm run by D on inputs (DB, RDK)
with outputs (EDB, K), GenToken is a protocol run by C on
input ¯w and by D on input (P, K), with C outputting token
or ⊥ and D outputting av, and Search is a protocol run by
C on input token and by E on input EDB, with C outputting
a set of ind’s matching his query and the corresponding set
of rdk’s.
4.1 The OSPIR-OXT Protocol
The OSPIR-OXT protocol addresses the above OSPIR set-
ting by enhancing MC-OXT with query-hiding techniques
that allow D to authorize queries without learning the queried
values. Most changes with respect to MC-OXT are in the
GenToken protocol. EDBSetup remains mostly unchanged
except for the implementation of the PRFs, and Search is
essentially unmodiﬁed.
We introduce the two main tools used in the design of
GenToken. First, instead of the use of regular PRFs for stag
and xtag computations in OXT and MC-OXT, the OSPIR-
OXT protocol uses an an “oblivious PRF” (OPRF) compu-
tation between C and D. A PRF F (K, w) is called oblivious
[26] if there is a two-party protocol in which C inputs w,
D inputs K, C learns the value of F (K, w) and D learns
nothing. A simple example is the Hashed DH OPRF which
we use in our implementation of the OSPIR-OXT protocol,
deﬁned as F (K, x) = H(x)K where H is a hash function
onto G \ {1} where G is a group of prime order p, and K
is chosen at random in Z ∗
p . In this case, the OPRF proto-
col consists of C sending a = H(x)r for random r in Z ∗
p ,
D sending back b = aK and C computing H(x)K as b1/r.
The second tool used in GenToken is needed to enforce an
attribute-based policy and guarantee that only queries on au-
thorized attributes can generate valid tokens for search at
E . To enforce such policies we have D use a diﬀerent key for
each possible attribute; for example, when a stag (or xtag)
is requested for attribute ‘zipcode’ the key that D inputs
into the OPRF computation is diﬀerent than the key used
for attribute ‘name’ or attribute ‘text’. The point is that