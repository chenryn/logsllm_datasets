mance. Hence, we expect SILVER to have better run-time performance in case of
protecting only crucial data rather than the entire program. We also believe that
our prototype can be greatly improved by optimizing Xen’s VMEXIT and page
fault exception handling to create a specialized path for SILVER’s protection
domain switch to avoid the unnecessary cost of VM switches.
Linux (Xen)
SILVER
(called by kernel) kfree
SILVER (called
by other principal) kfree average
kmalloc SLUB fast path 1.4µs
kmalloc SLUB slow path 7.7µs
0.7µs
kfree SLUB fast path
kfree SLUB slow path
6.2µs
16.2µs
kmalloc
14.4µs
56.7µs
64.1µs
kmalloc pd average
Table 1. Micro-benchmarks results for dynamic data management APIs of SILVER,
average of 1000 runs. The data object size of allocation is 192 bytes.
5 Limitations and Future Work
Our current prototype has several limitations. First, for a few functions, we found
diﬃculties in directly applying service-based communication on them, as they
move complex data structures across function calls instead of transferring a single
17
e
c
n
a
m
r
o
f
r
e
p
d
e
z
i
l
a
m
r
o
N
1.0
0.8
0.6
0.4
0.2
0.0
Dhrystone 2
Kernel build
Apache ab
Netperf TCP
Fig. 3. Application benchmark performance, normalized to native Linux/Xen.
data object. Dealing with these functions may require us to manually write data
marshalling routines. Fortunately, most of these functions are provided by the
OS kernel, which usually conﬁgures as the parent domain of the caller principal
and can directly operates on these data structures without data marshalling.
Compared with language-based and other static isolation approaches, SIL-
VER’s run-time mechanism is more accurate in resource tracking than static
inference. However, our approach also has shortcomings for not providing veri-
ﬁcation and automatic error detection to programmers. For example, program-
mers must pay extra attention for not creating dangling pointers when using
object transfer and endorsement primitives of SILVER, since these operations
will release the original object in the same way as kfree function. We plan to in-
corporate kernel reference counting to help programmers manage their references
of protection domain data objects. Moreover, adapting kernel programs to use
SILVER requires certain understanding of security properties of their data and
functions, and the entire procedure might be complex for converting very large
programs. Hence, we also would like to explore automatic ways to transform an
existing program to use SILVER given a security speciﬁcation.
6 Related Work
In practice, protection domains are widely used for addressing security problems
such as securing program extensions [11], privilege separation [29], implement-
ing secure browsers [27], safely executing native code in a browser [11, 32] and
mobile application deployment [1]. In this section, we review previous research
eﬀorts related to protection domains and OS kernel security, categorized by the
approach to achieve their goals.
One major mechanism to achieve protection is through software fault isola-
tion [7, 12, 26, 32], which rewrites binary code to restrict the control and data
access of the target program. XFI [12] leverages SFI to enable a host program to
safely execute extension modules in its address space by enforcing control ﬂow
integrity (CFI [5]) and data integrity requirements. While these approaches are
eﬃcient and eﬀective for securing program extensions, they have diﬃculties for
inferring and verifying system-wide resource and multi-principal access control
rules in a static manner.
18
LXFI [19] is probably the closest related work with SILVER. It addresses the
problem of data integrity and API integrity in SFI systems, using a completely
diﬀerent approach (compiler rewriting) than SILVER. Compared to LXFI, SIL-
VER’s run-time approach is more resilient to attacks that fully compromise an
untrusted module and execute arbitrary code. Moreover, security enforcement of
SILVER is more tamper-proof since the isolation and access control are carried
out by the hypervisor.
Run-time protection approaches are mostly achieved by access control mech-
anisms to constrain the behavior of untrusted programs. Depending on the ab-
straction and granularity levels, these approaches mediate security-sensitive ab-
stractions ranging from segmentation [10, 14, 32] and paging protection [25],
to system call interposition [11, 15]. These events are regulated by a set of
access control policies. Traditional mandatory access control systems such as
SELinux [3] are inﬂexible and diﬃcult to conﬁgure ﬁne-grained policies because
the internal state of an application is diﬃcult to infer externally. In contrast,
capability-based systems [23, 29] and DIFC systems [17, 33] delegate part of
security decisions to application developers, which eases the burden of adminis-
trators for setting up complex system policies externally and allows applications
to have its own control of data and communication security. Flume [17] provides
DIFC-based protection domain to user applications in Linux at the granularity
of system objects such as processes and ﬁles. SILVER’s security model follows a
similar spirit of these approaches, yet it enforces protection for kernel programs
at data object granularity.
Many research eﬀorts are focused on improving the reliability of operating
system kernels. Micro-kernel OSes [8, 16, 18] removes device drivers from ker-
nel space and execute them as userspace server applications. However, as dis-
cussed in Section 1, despite their elegant design, it is generally diﬃcult to retroﬁt
these approaches in commodity OSes. Mondrix [30] compartmentalizes Linux
and provides ﬁne-grained isolation, but it requires a speciﬁc designed hardware.
Nooks [25] is a comprehensive protection layer that leverages hardware protec-
tion to isolate faulty device drivers within Linux kernel and recover them after
failures. Since its primary focus is fault resistance rather than security, it does
not address attacks such as manipulating architectural state. Also, Nooks does
not provide the ﬂexibility to specify security properties of individual data.
SILVER leverages a VMM as another layer of indirection to mediate cross-
protection-domain activities. VMMs are also widely used for protection systems
to enhance the security of applications and the OS kernel. Overshadow [9] and
TrustVisor [20] protect the integrity and secrecy of an application even in case
that the OS kernel is compromised. SIM [24] uses hardware virtualization for
securely running an isolated and trusted monitor inside an untrusted guest.
Secvisor [22] and NICKLE [21] are hypervisor-based systems which guarantee
that any unauthorized code will not be executed in the operating system kernel.
Hooksafe [28] protects kernel control data (i.e., hooks) from being tampered by
kernel-level rootkits. In comparison, SILVER aims to provide a more compre-
19
hensive protection with the integrity guarantee of both code, data and control
ﬂows.
7 Conclusions
In this paper, we have described the design, implementation and evaluation of
SILVER, a framework to achieve transparent protection primitives that pro-
vide ﬁne-grained access control and secure interactions between OS kernel and
untrusted extensions. We believe that SILVER is an eﬀective approach towards
controlled privilege separation, by which developers could protect their programs
and mitigate the damage to OS kernel caused by attacks exploiting a vulnera-
bility in untrusted extensions.
Acknowledgements
We would like to thank our paper shepherd Andrea Lanzi, the anonymous re-
viewers and Trent Jaeger, for their helpful comments on earlier versions of this
paper. This work was supported by ARO W911NF-09-1-0525 (MURI), NSF
CNS-0905131, AFOSR W911NF1210055, and ARO MURI project ”Adversarial
and Uncertain Reasoning for Adaptive Cyber Defense: Building the Scientiﬁc
Foundation”.
References
1. Android: Security and Permissions. http://developer.android.com/guide/topics/security/security.html.
2. Linux kernel can slub overﬂow. http://jon.oberheide.org/blog/2010/09/10/linux-
kernel-can-slub-overﬂow/.
3. NSA. Security enhanced linux. http://www.nsa.gov/selinux/.
4. The SLUB allocator. http://lwn.net/Articles/229984/.
5. M. Abadi, M. Budiu, U. Erlingsson, and J. Ligatti. Control-ﬂow Integrity. In CCS
’05, 2005.
6. K. J. Biba.
Integrity Considerations for Secure Computer Systems. Technical
Report MTR-3153, The Mitre Corporation, 1977.
7. M. Castro, M. Costa, J.-P. Martin, M. Peinado, P. Akritidis, A. Donnelly,
In
P. Barham, and R. Black. Fast Byte-granularity Software Fault Isolation.
SOSP ’09, 2009.
8. J. S. Chase, H. M. Levy, M. J. Feeley, and E. D. Lazowska. Sharing and Protection
in a Single-Address-Space Operating System. ACM Trans. Comput. Syst., 12:271–
307, 1994.
9. X. Chen, T. Garﬁnkel, E. C. Lewis, P. Subrahmanyam, C. A. Waldspurger,
D. Boneh, J. Dwoskin, and D. R. Ports. Overshadow: a Virtualization-based Ap-
proach to Retroﬁtting Protection in Commodity Operating Systems. In ASPLOS
’08, 2008.
10. T.-c. Chiueh, G. Venkitachalam, and P. Pradhan. Integrating Segmentation and
In
Paging Protection for Safe, Eﬃcient and Transparent Software Extensions.
SOSP ’99, 1999.
20
11. J. R. Douceur, J. Elson, J. Howell, and J. R. Lorch. Leveraging Legacy Code to
Deploy Desktop Applications on the Web. In OSDI’08, 2008.
12. U. Erlingsson, M. Abadi, M. Vrable, M. Budiu, and G. C. Necula. XFI: Software
Guards for System Address Spaces. In OSDI ’06, 2006.
13. M. F¨ahndrich, M. Aiken, C. Hawblitzel, O. Hodson, G. Hunt, J. R. Larus, and
S. Levi. Language Support for Fast and Reliable Message-based Communication
in Singularity OS. In EuroSys ’06, 2006.
14. B. Ford and R. Cox. Vx32: Lightweight User-level Sandboxing on the x86.
In
USENIX ATC, 2008.
15. T. Garﬁnkel, B. Pfaﬀ, and M. Rosenblum. Ostia: A Delegating Architecture for
Secure System Call Interposition. In NDSS’04, 2004.
16. G. Klein, K. Elphinstone, G. Heiser, J. Andronick, D. Cock, P. Derrin, D. Elkaduwe,
K. Engelhardt, R. Kolanski, M. Norrish, T. Sewell, H. Tuch, and S. Winwood. seL4:
Formal Veriﬁcation of an OS Kernel. In SOSP ’09.
17. M. Krohn, A. Yip, M. Brodsky, N. Cliﬀer, M. F. Kaashoek, E. Kohler, and R. Mor-
ris. Information Flow Control for Standard OS Abstractions. In SOSP ’07, 2007.
18. J. Liedtke. On Micro-kernel Construction. In SOSP ’95, 1995.
19. Y. Mao, H. Chen, D. Zhou, X. Wang, N. Zeldovich, and M. F. Kaashoek. Software
fault isolation with API integrity and multi-principal modules. In SOSP ’11, 2011.
20. J. M. McCune, Y. Li, N. Qu, Z. Zhou, A. Datta, V. Gligor, and A. Perrig. TrustVi-
sor: Eﬃcient TCB Reduction and Attestation. In Proceedings of the 2010 IEEE
Symposium on Security and Privacy.
21. R. Riley, X. Jiang, and D. Xu. Guest-Transparent Prevention of Kernel Rootkits
with VMM-Based Memory Shadowing. In RAID ’08.
22. A. Seshadri, M. Luk, N. Qu, and A. Perrig. SecVisor: A Tiny Hypervisor to Provide
Lifetime Kernel Code Integrity for Commodity OSes. In SOSP ’07, 2007.
23. J. S. Shapiro, J. M. Smith, and D. J. Farber. EROS: a Fast Capability System. In
SOSP ’99, 1999.
24. M. I. Sharif, W. Lee, W. Cui, and A. Lanzi. Secure in-vm monitoring using hard-
ware virtualization. In CCS ’09, pages 477–487, New York, NY, USA, 2009. ACM.
25. M. M. Swift, B. N. Bershad, and H. M. Levy. Improving the Reliability of Com-
modity Operating Systems. In SOSP ’03.
26. R. Wahbe, S. Lucco, T. E. Anderson, and S. L. Graham. Eﬃcient Software-based
Fault Isolation. In SOSP ’93, 1993.
27. H. J. Wang, C. Grier, A. Moshchuk, S. T. King, P. Choudhury, and H. Venter.
The Multi-principal OS Construction of the Gazelle Web Browser. In USENIX
Security ’09, 2009.
28. Z. Wang, X. Jiang, W. Cui, and P. Ning. Countering Kernel Rootkits with
Lightweight Hook Protection. In CCS ’09.
29. R. N. M. Watson, J. Anderson, B. Laurie, and K. Kennaway. Capsicum: Practical
Capabilities for UNIX. In USENIX Security’10, 2010.
30. E. Witchel, J. Rhee, and K. Asanovi´c. Mondrix: Memory Isolation for Linux using
Mondriaan Memory Protection. In SOSP ’05, 2005.
31. X. Xiong, D. Tian, and P. Liu. Practical Protection of Kernel Integrity for Com-
modity OS from Untrusted Extensions. In NDSS’11, 2011.
32. B. Yee, D. Sehr, G. Dardyk, J. B. Chen, R. Muth, T. Ormandy, S. Okasaka,
N. Narula, and N. Fullagar. Native Client: A Sandbox for Portable, Untrusted x86
Native Code. IEEE Symposium on Security and Privacy, 2009.
33. N. Zeldovich, S. Boyd-Wickizer, E. Kohler, and D. Mazi`eres. Making Information
Flow Explicit in HiStar. In OSDI ’06, 2006.