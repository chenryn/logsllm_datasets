// file type and permission bits
u_int16_t fileMode;
union {
// indirect inode number for hard links
u_int32_t iNodeNum;
// links that refer to this indirect node
u_int32_t linkCount;
// device number for block/character devices
u_int32_t rawDevice;
} special;
};
12.8.3.1. Manipulating Volume-Level Ownership Rights
Although permissions are mandatory on a root volume, they can be deactivated on a nonroot HFS+ volume.
file://C:\Dokumente und Einstellungen\Silvia\Lokale Einstellungen\Temp\~hhC53.htm 20.08.2007
Chapter 12. The HFS Plus File System Page 46 of 81
$ hdiutil create -size 32m -fs HFSJ -volname HFSPerms /tmp/hfsperms.dmg
...
$ open /tmp/hfsperms.dmg
$ touch /Volumes/HFSPerms/file.txt
$ chmod 600 /Volumes/HFSPerms/file.txt
$ sudo chown root:wheel /Volumes/HFSPerms/file.txt
$ ls -l /Volumes/HFSPerms
total 0
-rw------- 1 root wheel 0 Oct 15 10:55 file.txt
$ mount -u -o noperm /Volumes/HFSPerms
$ ls -l /Volumes/HFSPerms
total 0
-rw------- 1 amit amit 0 Oct 11 10:55 file.txt
Disabling permissions essentially assigns the ownership of the volume's files and folders to a single user IDthe
so-called replacement user ID. The replacement user ID can be explicitly specified; otherwise, the kernel will
use UNKNOWNUID, the unknown user's ID (99). UNKNOWNUID has the special property that it matches any user ID
when IDs are being compared for ownership rights determination.
The replacement is purely behavioral. Each file system object retains its original owner ID. The hfsmount
structure holds the replacement ID in memory.
$ hfsdebug /Volumes/HFSPerms/file.txt
...
# BSD Info
ownerID = 0 (root)
groupID = 0 (wheel)
...
$ sudo hfsdebug -V /Volumes/HFSPerms -m
...
HFS+ flags = 00000000000000000000000000001110
+ HFS_UNKNOWN_PERMS
+ HFS_WRITEABLE_MEDIA
+ HFS_CLEANED_ORPHANS
default owner = { uid=99, gid=99 }
...
Note that the term permissions really means ownership in this contextthe file mode bits are still honored.
$ chmod 000 /Volumes/HFSPerms/file.txt
$ cat /Volumes/HFSPerms/file.txt
cat: /Volumes/HFSPerms/file.txt: Permission denied
Figure 1222 shows the algorithm that the Mac OS X HFS+ implementation uses to determine whether a given
process has ownership rights to a file system object.
Figure 1222. Algorithm for determining ownership rights to a file system object
[View full size image]
file://C:\Dokumente und Einstellungen\Silvia\Lokale Einstellungen\Temp\~hhC53.htm 20.08.2007
Chapter 12. The HFS Plus File System Page 47 of 81
12.8.3.2. Repairing Permissions
Applications written using older APIs may disregard (and possibly even clobber) Unix-style permissions.
Therefore, a permissions-unaware or misbehaving application can corrupt on-disk permissions if it is run with
enough privileges. Mac OS X supports the concept of repairing permissions to address this problem.
Permissions are usually repaired only on a boot volume. The Mac OS X installer uses a bill of materials for
each package it installs. A bill-of-materials (bom) file contains a listing of all files within a directory, along
with metadata for each file. In particular, it contains each file's Unix permissions. Bom files for installed
packages are located within the package metadata[20] found in /Library/Receipts/. Tools that repair
permissions use these bom files to determine the original permissions.
[20] For a given package, this metadata is also known as its package receipt.
Let us create a disk image with some files, create a bom file for the disk image, corrupt a file's permissions,
and then repair permissions on the volume. Note that we need to make the disk image look like a boot volume
to the programs we will use in this experiment.
First we create a disk image, mount it, and ensure that permissions are enabled.
$ hdiutil create -size 32m -fs HFSJ -volname HFSPR /tmp/hfspr.dmg
file://C:\Dokumente und Einstellungen\Silvia\Lokale Einstellungen\Temp\~hhC53.htm 20.08.2007
Chapter 12. The HFS Plus File System Page 48 of 81
...
$ open /tmp/hfspr.dmg
$ mount -u -o perm /Volumes/HFSPR
Next we add certain files to the volume so that the permissions repair tool will run on it.
$ mkdir -p /Volumes/HFSPR/System/Library/CoreServices
$ mkdir -p /Volumes/HFSPR/Library/Receipts/BaseSystem.pkg/Contents
$ cp /System/Library/CoreServices/SystemVersion.plist \
/Volumes/HFSPR/System/Library/CoreServices/
Then we create a file whose permissions we will repair. We also set the file's permissions to some initial value.
$ touch /Volumes/HFSPR/somefile.txt
$ chmod 400 /Volumes/HFSPR/somefile.txt
Next we create a bom file for the disk image. Note that during creation of the bom file, the existing
permissions on somefile.txt will be picked up as the correct ones.
$ cd /Volumes/HFSPR/Library/Receipts/BaseSystem.pkg/Contents/
$ sudo mkbom /Volumes/HFSPR Archive.bom
Finally we change the permissions on somefile.txt and run diskutil to repair the volume's permissions.
$ chmod 444 /Volumes/HFSPR/somefile.txt
$ sudo diskutil repairPermissions /Volumes/HFSPR
Started verify/repair permissions on disk disk10s2 HFSPR
Determining correct file permissions.
Permissions differ on ./somefile.txt, should be -r-------- , they are -r--r--r--
Owner and group corrected on ./somefile.txt
Permissions corrected on ./somefile.txt
The privileges have been verified or repaired on the selected volume
Verify/repair finished permissions on disk disk10s2 HFSPR
$ ls -l /Volumes/HFSPR/somefile.txt
-r-------- 1 amit amit 0 Oct 16 12:27 /Volumes/HFSPR/somefile.txt
12.8.4. Journaling
HFS+ supports journaling of metadata, including volume data structures, wherein metadata-related file system
changes are recorded to a log file (the journal) that is implemented as a circular on-disk buffer.[21] The primary
purpose of a journal is to ensure file system consistency in the case of failure. Certain file system operations
are semantically atomic but may result in considerable I/O internally. For example, creating a file, which
involves adding the file's thread and file records to the Catalog B-Tree, will cause one or more disk blocks to
be written. If the tree needs balancing, several more blocks will be written. If a failure occurs before all
changes have been committed to physical storage, the file system will be in an inconsistent stateperhaps even
irrecoverably so. Journaling allows related modifications to be grouped into transactions that are recorded in a
journal file. Then related modifications can be committed to their final destinations in a transactional
mannereither all of them or none at all. Journaling makes it easier and significantly faster to repair the volume
after a crash, because only a small amount of informationthat contained in the journalneeds to be examined.
Without a journal, the entire volume would typically need to be scanned by fsck_hfs for inconsistencies.
[21] Since the journaling mechanism first writes intended changes to the journal file and then to the
actual destination blocks (typically in the buffer cache), it is said to perform write-ahead
journaling.
Since writes to files occur independently of the journal, which strives only to keep the metadata consistent,
journaling cannot guarantee consistency between a file's metadata and its user data.
file://C:\Dokumente und Einstellungen\Silvia\Lokale Einstellungen\Temp\~hhC53.htm 20.08.2007
Chapter 12. The HFS Plus File System Page 49 of 81
Syncing Fully
The journal implementation uses the DKIOCSYNCHRONIZECACHE ioctl operation to flush media
state to the drive. This ioctl is also used to implement the F_FULLFSYNC fcntl(2) command,
which performs a similar flush operation. More precisely, the flush operation is attemptedit may
or may not succeed, depending on whether the underlying device supports and honors the
corresponding hardware command. Figure 1223 shows how an F_FULLFSYNC request on an HFS+
file is propagated from user space to an ATA device that supports the FLUSH CACHE command.
Figure 1223. Processing of the F_FULLFSYNC file control operation
[View full size image]
Journaling was retrofitted into HFS+ by introducing a VFS-level journaling layer in the kernel
[bsd/vfs/vfs_journal.c]. This layer exports an interface that can be used by any file system to incorporate
a journal. Figure 1224 shows an overview of the journaling interface and its use by HFS+. Note that from the
journal's standpoint, modifications are performed in units of journal block size, which must be specified when
the journal is created. HFS+ uses the physical block size (typically 512 bytes for disks) as the journal block
file://C:\Dokumente und Einstellungen\Silvia\Lokale Einstellungen\Temp\~hhC53.htm 20.08.2007
Chapter 12. The HFS Plus File System Page 50 of 81
size. When HFS+ needs to modify one or more blocks as part of an operation, it starts a journal transaction to
encapsulate related changes. Modification of each block is indicated separately to the journal. When all blocks
in the transactions have been modified, the file system ends the transaction. When the volume is cleanly
unmounted, the transactions recorded in the journal are committed by copying modified blocks from the
journal file to their actual on-disk locations, which are also recorded in the journal.
Figure 1224. The VFS-layer journaling interface in Mac OS X
[View full size image]
When a journaled volume is mounted, HFS+ checks the lastMountedVersion field of the volume header to
determine whether the last mount was performed by a journaling-aware implementation, in which case the
field would contain HFSJ, as we saw earlier. If that is the case, and the journal contains uncommitted
transactions (because of an unclean shutdown, say), HFS+ will commit transactions recorded in the journal
before the volume is availablethat is, the journal will be replayed.
The volume header on a journaled HFS+ volume contains the location of a data structure called the journal
info block, which in turn contains the location and size of the journal proper. The latter consists of a header
and a circular buffer. Both the info block and the journal are stored as files: .journal_info_block
and .journal, respectively. Both these files are contiguous (occupying exactly one extent each). They are
normally neither visible nor directly accessible through the file system APIs. The invisibility is implemented
inside the kernel, as the file system's catalog-level lookup routine returns an ENOENT error if the file's CNID
matches that of one of the journal files. The journal files may be seen, if they exist, through an EFI or Open
Firmware shell, for example:
0 > dir hd:\
...
8388608 10/ 7/ 3 2:11:34 .journal
4096 10/ 7/ 3 2:11:34 .journal_info_block
...
hfsdebug can also retrieve information about the journal files. We specify a journal file to it by providing its
name and the CNID of its parent (the root folder).
$ sudo hfsdebug -F 2:.journal
path = Macintosh HD:/.journal
file://C:\Dokumente und Einstellungen\Silvia\Lokale Einstellungen\Temp\~hhC53.htm 20.08.2007
Chapter 12. The HFS Plus File System Page 51 of 81
# Catalog File Record
type = file
file ID = 16
...
extents = startBlock blockCount % of file
0x4c7 0x1000 100.00 %
4096 allocation blocks in 1 extents total.
4096.00 allocation blocks per extent on an average.
...
Figure 1225 shows the structures of the journal files.
Figure 1225. An overview of the file-system-independent journal used by HFS+
[View full size image]
We can use hfsdebug to view the contents of the .journal_info_block file and the journal header.
$ sudo hfsdebug -j
# HFS+ Journal
# Journal Info Block
flags = 00000000000000000000000000000001
. Journal resides on local volume itself.
device_signature =
...
file://C:\Dokumente und Einstellungen\Silvia\Lokale Einstellungen\Temp\~hhC53.htm 20.08.2007
Chapter 12. The HFS Plus File System Page 52 of 81
offset = 5009408 bytes
size = 16777216 bytes
reserved =
...
# Journal Header
magic = 0x4a4e4c78
endian = 0x12345678
start = 15369216 bytes
end = 677376 bytes
size = 16777216 bytes
blhdr_size = 16384 bytes
checksum = 0x8787407e
jhdr_size = 512 bytes
With reference to Figure 1225, the structure of a transaction is as follows. Each transaction consists of one or
more block lists. Each block list begins with a block_list_header structure, followed by two or more
block_info structures, and finally followed by the actual block dataone chunk for each block_info structure
except the first.
typedef struct block_info {
off_t bnum; // sector number where data in this block is to be written
size_t bsize; // number of bytes to be copied from journal buffer to bnum
struct buf *bp; // used as "next" when on disk
} block_info;
The first block_info structure connects two consecutive block lists as part of the same transaction. If the first
structure's bp field is 0, the current block list is the last in the current transaction. If the bp field is not 0, then
the transaction continues on to the next block list.
12.8.4.1. Enabling or Disabling Journaling on a Volume
The diskutil program can be used to enable or disable journaling on a mounted HFS+ volume. The
hfs.util program (/System/Library/Filesystems/hfs.fs/hfs.util) can also be used for this purpose
and to display the size and location of the journal file.
$ /System/Library/Filesystems/hfs.fs/hfs.util -I "/Volumes/Macintosh HD"
/Volumes/Macintosh HD : journal size 16384 k at offset 0x4c7000
The following sysctl operations, defined in bsd/hfs/hfs_mount.h, allow programmatic manipulation of the
journal:
 HFS_ENABLE_JOURNALING
 HFS_DISABLE_JOURNALING
 HFS_GET_JOURNAL_INFO
12.8.4.2. Observing the Journal's Operation
Let us now use hfsdebug to view the contents of the journal buffer and relate them to specific file system
operations. We will create a fresh disk image for this purpose.
$ hdiutil create -size 32m -fs HFSJ -volname HFSJ /tmp/hfsj.dmg
...
$ open /tmp/hfsj.dmg
$ hfsdebug -V /Volumes/HFSJ -J
# HFS+ Journal
# Journal Buffer
# begin transaction
file://C:\Dokumente und Einstellungen\Silvia\Lokale Einstellungen\Temp\~hhC53.htm 20.08.2007
Chapter 12. The HFS Plus File System Page 53 of 81
# Block List Header
max_blocks = 1023
num_blocks = 5
bytes_used = 29184
checksum = 0xfdfd8386
pad = 0
binfo[0].bp = 0
block_info[ 1] { bnum 0x0000000000004218 bsize 4096 bytes bp 0x5208ed90 }
block_info[ 2] { bnum 0x0000000000004210 bsize 4096 bytes bp 0x52147860 }
block_info[ 3] { bnum 0x0000000000000002 bsize 512 bytes bp 0x5208d440 }
block_info[ 4] { bnum 0x0000000000000008 bsize 4096 bytes bp 0x520ea6e0 }
#end transaction
Summary: 5 blocks using 29184 bytes in 1 block lists.
We see that the newly mounted volume has several modified blocks recorded in the journal. Recall that the
journal is using disk sectors for blocks. block_info[3]'s target sector is 2, which is the volume header. As we
saw earlier, the disk arbitration daemon would have created the .trashes folder when we mounted the newly
created volume. The modifications to the Catalog B-Tree and the Allocation file must also be part of the
journal records. Let us verify this.
$ hfsdebug -V /Volumes/HFSJ -v
...
blockSize = 4096 bytes
...
# Allocation Bitmap File
logicalSize = 4096 bytes
totalBlocks = 1
clumpSize = 4096 bytes
extents = startBlock blockCount % of file
0x1 0x1 100.00 %
...
# Catalog File
logicalSize = 258048 bytes
totalBlocks = 63
clumpSize = 258048 bytes
extents = startBlock blockCount % of file
0x842 0x3f 100.00 %
...
The Allocation file is entirely contained within allocation block number 1that is, it starts at sector 8 and is 4096
bytes in size. Therefore, block_info[4] corresponds to the Allocation file.
block_info[1] and block_info[2] correspond to allocation block numbers 0x843 and 0x842, respectively.
(We simply divide the sector numbers by 8, since a 4KB allocation block contains 8 512-byte sectors.) Both
these allocation blocks belong to the Catalog file. Since allocation block 0x842 (sector 0x4210) is also the
beginning of the Catalog file, it is the location of the tree's header node. hfsdebug displays the sector number
where a given Catalog file record's tree node is located. Let us use it to display this information for
the .trashes folder.
$ hfsdebug -V /Volumes/HFSJ/.Trashes
path = HFSJ:/.Trashes
# Catalog Folder Record
...
Thus, all records in the journal are accounted for.
12.8.5. Quotas
HFS+ supports volume-level quotas based on user and group IDs. It theoretically supports quotas based on
other criteria, since the in-memory catalog-node structure (struct cnode [bsd/hfs/hfs_cnode.h]) contains
file://C:\Dokumente und Einstellungen\Silvia\Lokale Einstellungen\Temp\~hhC53.htm 20.08.2007
Chapter 12. The HFS Plus File System Page 54 of 81
an array of disk quota usage records (struct dquot [bsd/sys/quota.h]). The array contains two elements in
Mac OS X 10.4, one for user quotas and one for group quotas. The corresponding quota filenames
are .quota.user and .quota.group. These files reside in the file system's root directory. Each file contains a
header followed by a hash table of structures specifying various quota limits and usage values for user or group