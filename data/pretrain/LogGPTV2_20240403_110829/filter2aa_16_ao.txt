5.3 指针与数组
在 C 语言中，指针和数组之间的关系十分密切，因此，在接下来的部分中，我们将同时 讨论指针与数组。通过数组下标所能完成的任何操作都可以通过指针来实现。一般来说，用 指针编写的程序比用数组下标编写的程序执行速度快，但另一方面，用指针实现的程序理解 起来稍微困难一些。
声明
int a[10];
定义了一个长度为 10 的数组 a。换句话说，它定义了一个由 10 个对象组成的集合，这 10 个 对象存储在相邻的内存区域中，名字分别为 a[0]、a[1]、  、a[9](参见图 5•3)。
图 5•3
a[i]表示该数组的第 i 个元素。如果 pa 的声明为
int *pa;
则说明它是一个指向整型对象的指针，那么，赋值语句
pa = &a[0];
则可以将指针 pa 指向数组 a 的第 0 个元素，也就是说，pa 的值为数组元素 a[0]的地址(参 见图 5•4)。
图 5•4
这样，赋值语句
x = *pa;
将把数组元素 a[0]中的内容复制到变量 x 中。
如果 pa 指向数组中的某个特定元素，那么，根据指针运算的定义，pa+1 将指向下一个 元素，pa+i 将指向 pa 所指向数组元素之后的第 i 个元素，而 pa•i 将指向 pa 所指向数组 元素之前的第 i 个元素。因此，如果指针 pa 指向 a[0]，那么*(pa+1)引用的是数组元素 a[1]的内容，pa+i 是数组元素 a[i]的地址，*(pa+i)引用的是数组元素 a[i]的内容(参 见图 5•5)。
图 5•5
无论数组 a 中元素的类型或数组长度是什么，上面的结论都成立。"指针加 1"就意味着， pa+1 指向 pa 所指向的对象的下一个对象。相应地，pa+i 指向 pa 所指向的对象之后的第 i 个对象。
下标和指针运算之间具有密切的对应关系。根据定义，数组类型的变量或表达式的值是 该数组第 0 个元素的地址。执行赋值语句
pa = &a[0];
后，pa 和 a 具有相同的值。因为数组名所代表的就是该数组最开始的一个元素的地址，所以， 赋值语句  pa=&a[0]也可以写成下列形式:
pa = a;
对数组元素 a[i]的引用也可以写成*(a+i)这种形式。对第一次接触这种写法的人来说， 可能会觉得很奇怪。在计算数组元素 a[i]的值时，C 语言实际上先将其转换为*(a+i)的形 式，然后再进行求值，因此在程序中这两种形式是等价的。如果对这两种等价的表示形式分 别施加地址运算符&，便可以得出这样的结论:&a[i]和 a+i 的含义也是相同的。a+i 是 a
之后第 i 个元素的地址。相应地，如果 pa 是个指针，那么，在表达式中也可以在它的后面加 下标。pa[i]与*(pa+i)是等价的。简而言之，一个通过数组和下标实现的表达式可等价地 通过指针和偏移量实现。
但是，我们必须记住，数组名和指针之间有一个不同之处，指针是一个变量，因此，在 C 语言中，语句 pa=a 和 pa++都是合法的。但数组名不是变量，因此，类似于 a=pa 和 a++形 式的语句是非法的。
当把数组名传递给一个函数时，实际上传递的是该数组第一个元索的地址。在被调用函 数中，该参数是一个局部变量，因此，数组名参数必须是一个指针，也就是一个存储地址值 的变量。我们可以利用该特性编写 strlen 函数的另一个版本，该函数用于计算一个字符串 的长度。
/* strlen:              return length of string s */ int strlen(char *s)
{
int n;
for (n = 0; *s != '\0', s++) n++;
return n;
}
因为 s 是一个指针，所以对其执行自增运算是合法的。执行 s++运算不会影响到 strlen 函 数的调用者中的字符串，它仅对该指针在 strlen 函数中的私有副本进行自增运算。因此， 类似于下面这样的函数调用:
strlen("hello, world");                            /* string constant */ strlen(array);              /* char array[100]; */
strlen(ptr);              /* char *ptr; */
都可以正确地执行。 在函数定义中，形式参数
char s[];
和
char *s;
是等价的。我们通常更习惯于使用后一种形式，因为它比前者更直观地表明了该参数是一个 指针。如果将数组名传递给函数，函数可以根据情况判定是按照数组处理还是按照指针处理， 随后根据相应的方式操作该参数。为了直观且恰当地描述函数，在函数中甚至可以同时使用 数组和指针这两种表示方法。
也可以将指向子数组起始位置的指针传递给函数，这样，就将数组的一部分传递给了函 数。例如，如果 a 是一个数组，那么下面两个函数调用
f(&a[2])
与
f(a+2)
都将把起始于 a[2]的子数组的地址传递给函数 f。在函数 f 中，参数的声明形式可以为
f(int arr[]) { ... }
或
f(int *arr) { ... }
对于函数 f 来说，它并不关心所引用的是否只是一个更大数组的部分元素。 如果确信相应的元素存在，也可以通过下标访问数组第一个元素之前的元素。类似于
p[•1]、p[•2]这样的表达式在语法上都是合法的，它们分别引用位于 p[0]之前的两个元素。
当然，引用数组边界之外的对象是非法的。
5.4 地址算术运算
如果 p 是一个指向数组中某个元素的指针，那么 p++将对 p 进行自增运算并指向下一个 元素，而 p+=i 将对 p 进行加 i 的增量运算，使其指向指针 p 当前所指向的元素之后的第 i 个元素。这类运算是指针或地址算术运算中最简单的形式。
C 语言中的地址算术运算方法是一致且有规律的，将指针、数组和地址的算术运算集成在 一起是该语言的一大优点。为了说明这一点，我们来看一个不完善的存储分配程序。它由两 个函数组成。第一个函数 alloc(n)返回一个指向 n 个连续字符存储单元的指针，alloc 函 数的调用者可利用该指针存储字符序列。第二个函数 afree(p)释放已分配的存储空间，以 便以后重用。之所以说这两个函数是"不完善的"，是因为对  afree 函数的调用次序必须与 调用 alloc 函数的次序相反。换句话说，alloc 与 afree 以校的方式(即后进先出的列表) 进行存储空间的管理。标准库中提供了具有类似功能的函数 malloc 和 free，它们没有上述 限制，我们将在 8.7 节中说明如何实现这些函数。
最容易的实现方法是让 alloc 函数对一个大字符数组 allocbuf 中的空间进行分配。该 数组是 alloc 和 afree 两个函数私有的数组。由于函数 alloc 和 afree 处理的对象是指 针而不是数组下标，因此，其它函数无需知道该数组的名字，这样，可以在包含 alloc 和 afree 的源文件中将该数组声明为 static 类型，使得它对外不可见。实际实现时，该数组甚至可 以没有名字，它可以通过调用 malloc 函数或向操作系统申请一个指向无名存储块的指针获 得。
allocbuf 中的空间使用状况也是我们需要了解的信息。我们使用指针 allocp 指向 allocbuf 中的下一个空闲单元。当调用 alloc 申请 n 个字符的空间时，alloc 检查 allocbuf 数组中有没有足够的剩余空间。如果有足够的空闲空间，则 alloc 返回 allocp 的当前值(即空闲块的开始位置)，然后将 allocp 加 n 以使它指向下一个空闲区域。如果空 闲空间不够，则 alloc 返回 0。如果 p 在 allocbuf 的边界之内，则 afree(p)仅仅只是将 allocp 的值设置为 p(参见图 5•6)。
#define ALLOCSIZE 10000 /* size of available space */
static char allocbuf[ALLOCSIZE]; /* storage for alloc */ static char *allocp = allocbuf;              /* next free position */
char *alloc(int n)              /* return pointer to n characters */
{
if (allocbuf + ALLOCSIZE • allocp >= n) {              /* it fits */ allocp += n;
return allocp • n; /* old p */
} else              /* not enough room */ return 0;
}
void afree(char *p)              /* free storage pointed to by p */
{
if (p >= allocbuf && p = n) {              /* it fits */
检查是否有足够的空闲空间以满足 n 个字符的存储空间请求。如果空闲空间足够，则分配存 储空间后 allocp 的新值至多比 allocbuf 的尾端地址大 1。如果存储空间的申请可以满足， alloc 将返回一个指向所需大小的字符块首地址的指针(注意函数本身的声明)。如果申请无 法满足，alloc 必须返回某种形式的信号以说明没有足够的空闲空间可供分配。C 语言保证， 0 永远不是有效的数据地址，因此，返回值 0 可用来表示发生了异常事件。在本例中，返回值
0 表示没有足够的空闲空间可供分配。
指针与整数之间不能相互转换，但 0 是惟一的例外:常量 0 可以赋值给指针，指针也可 以和常量 0 进行比较。程序中经常用符号常量 NULL 代替常量 0，这样便于更清晰地说明常量 0 是指针的一个特殊值。符号常量 NULL 定义在标准头文件中。我们在后面部分 经常会用到 NULL。
类似于
if (allocbuf + ALLOCSIZE • allocp >= n) {              /* it fits */
以及
if (p >= allocbuf && p =的关系比较运算。如果 p 指向的数组元素的位置在 q 指向的数组元素位置 之前，那么关系表达式
p 中定义的类型 ptrdiff_t 足以表示两个指针之间的带符号差 值。但是，我们在这里使用 size_t 作为函数 strlen 的返回值类型，这样可以与标准库中 的函数版本相匹配。Size_t 是由运算符 sizeof 返回的无符号整型。)
指针的算术运算具有一致性:如果处理的数据类型是比字符型占据更多存储空间的浮点 类型，并且 p 是一个指向浮点类型的指针，那么在执行 p++后，p 将指向下一个浮点数的地 址。因此，只需要将 alloc 和 afree 函数中所有的 char 类型替换为 float 类型，就可以 得到一个适用于浮点类型而非字符型的内存分配函数。所有的指针运算都会自动考虑它所指 向的对象的长度。
有效的指针运算包括相同类型指针之间的赋值运算;指针同整数之间的加法或减法运算; 指向相同数组中元素的两个指针间的减法或比较运算;将指针赋值为 0 或指针与 0 之间的比 较运算。其它所有形式的指针运算都是非法的，例如两个指针间的加法、乘法、除法、移位 或屏蔽运算;指针同 float 或 double 类型之间的加法运算;不经强制类型转换而直接将指 向一种类型对象的指针赋值给指向另一种类型对象的指针的运算(两个指针之一是 void * 类型的情况除外)。
5.5 字符指针与函数 字符串常量是一个字符数组，例如: "I am a string"
在字符串的内部表示中，字符数组以空字符'\0'结尾，所以，程序可以通过检查空字符找到
字符数组的结尾。字符串常量占据的存储单元数也因此比双引号内的字符数大 1。
字符串常量最常见的用法也许是作为函数参数，例如:
princf("hello, world\n"};
当类似于这样的一个字符串出现在程序中时，实际上是通过字符指针访问该字符串的。在上 述语句中，printf 接受的是一个指向字符数组第一个字符的指针。也就是说，字符串常量可 通过一个指向其第一个元素的指针访问。
除了作为函数参数外，字符串常量还有其它用法。假定指针 pmessage 的声明如下:
char *pmessage;
那么，语句
pmessage ="now is the time";
将把一个指向该字符数组的指针赋值给 pmessage。该过程并没有进行字符串的复制，而只 是涉及到指针的操作。C 语言没有提供将整个字符串作为一个整体进行处理的运算符。
下面两个定义之间有很大的差别:
char amessage[] = "nw is the time";              /* 定义一个数组 */ char *pmessage = "now is the time";              /* 定义一个指针 */
上述声明中，amessage 是一个仅仅足以存放初始化字符串以及空字符'\0'的一维数组。数 组中的单个字符可以进行修改，但 amessage 始终指向同一个存储位置。另一方面，pmessage 是一个指针，其初值指向一个字符串常量，之后它可以被修改以指向其它地址，但如果试图 修改字符串的内容，结果是没有定义的(参见图   5•7)。
图 5•7
为了更进一步地讨论指针和数组其它方面的问题，下面以标准库中两个有用的函数为例 来研究它们的不同实现版本。第一个函数 strcpy(s, t)把指针 t 指向的字符串复制到指针 s 指向的位置。如果使用语句 s=t 实现该功能，其实质上只是拷贝了指针，而并没有复制字 符。为了进行字符的复制，这里使用了一个循环语句。strcpy 函数的第 1 个版本是通过数组 方法实现的，如下所示:
/* strcpy:              copy t to s; array subscript version */ void strcpy(char *s, char *t)
{
int i;
i = 0;
while ((s[i] = t[i]) != '\0') i++;
}
为了进行比较，下面是用指针方法实现的 strcpy 函数:
/* strcpy:              copy t to s; pointer version */ void strcpy(char *s, char *t)
{
int i;
i = 0;
while ((*s = *t) != '\0') { s++;
t++;
}
}
因为参数是通过值传递的，所以在 strcpy 函数中可以以任何方式使用参数 s 和 t。在此，s 和 t 是方便地进行了初始化的指针，循环每执行一次，它们就沿着相应的数组前进一个字符， 直到将 t 中的结束符'\0'复制到 s 为止。
实际上，strcpy 函数并不会按照上面的这些方式编写。经验丰富的程序员更喜欢将它编 写成下列形式:
/* strcpy:              copy t to s; pointer version 2 */ void strcpy(char *s, char *t)
{
while ((*s++ = *t++) != '\0')
;