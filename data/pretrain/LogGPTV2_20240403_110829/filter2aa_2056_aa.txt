Cookie之困
zootrope
清华大学网络与信息安全实验室NISL
走 马
Cookies	
  Lack	
  Integrity:	
Real-­‐World	
  Implications
Xiaofeng Zheng,	
  Jian Jiang,	
  Jinjin Liang,	
  Haixin Duan,	
Shuo Chen,	
  Tao	
  Wan	
  and	
  Nicholas	
  Weaver
USENIX	
  Security	
  '15
https://www.usenix.org/conference/usenixsecurity15/technical-­‐sessions/presentation/zheng
谁忽视了Cookie安全
星巴克
离开星巴克时需要做什么？
Cookie基础
•
用于保持HTTP会话状态/缓存信息
•
由服务器/脚本写入
Server:
Set-­‐Cookie:	
  user=bob;	
  domain=.bank.com;	
  path=/;
JS:
document.cookie=“user=bob;	
   domain=.bank.com;	
  path=/;”;
•
存储于浏览器/传输于HTTP头部
Cookie:	
  user=bob; cart=books;
JS:
console.log(document.cookie);
à “user=bob;	
  cart=books;”
•
三元组
[name,	
  domain,	
  path]：唯一确定Cookie
写时带属性，读时无属性
name, domain, path任一不同，则Cookie不同
Set-­‐Cookie:	
  session=secret;	
  domain=.bank.com;
path=/;
HTTP
Cookie:	
  session=secret;
http://bank.com
泄露：HTTP
②
③
Login
①
Cookie:	
  session=secret;
④
X
HTTPS
https://bank.com
Set-­‐Cookie:	
  session=secret;	
  domain=.bank.com;
path=/;
Cookie:	
  session=secret;
HTTPS
Cookie基础：同源策略(SOP)
l Web	
  SOP:	
  [protocol,	
  domain,	
  port]
http://www.bank.com
http://www.bank.com:8080
https://www.bank.com
l Cookie	
  SOP:	
  [domain,	
  path]
−
仅以domain/path作为同源限制
−
不区分端口
−
不区分HTTP / HTTPS
非同源（受SOP隔离保护）
Cookie:	
  session=secret;	
  domain=.bank.com;	
  path=/;
http://bank.com
https://bank.com
Cookie基础：Domain向上通配
l 在对Cookie读写时，以“通配”的方式判断Domain是否有效
Set-­‐Cookie:	
  user1=aaa;	
  domain=.bank.com;	
  path=/;
Set-­‐Cookie:	
  user2=bbb;	
  domain=www.bank.com;	
  path=/;
Set-­‐Cookie:	
  user3=ccc;	
  domain=.www.bank.com;	
  path=/;
Set-­‐Cookie:	
  user4=ddd;	
  domain=other.bank.com;	
   path=/;
写入：
当页面为 http://www.bank.com 时：
读取：
访问 http://www.bank.com
Cookie: user1=aaa;	
  user2=bbb;	
  user3=ccc;	
接受
接受
接受
拒绝
Cookie: user1=aaa;	
访问 http://user.bank.com
Cookie基础：Path向下通配
Set-­‐Cookie:	
  session=bob;	
  domain=.bank.com;	
  path=/;	
Set-­‐Cookie:	
  cart=books;	
  domain=.bank.com;	
   path=/buy/;	
http://bank.com/
Cookie:	
  session=bob;	
http://bank.com/buy/
Cookie:	
  session=bob;	
   cart=books;	
泄露：Cookie	
  in HTTPS
https://bank.com
HTTPS
Set-­‐Cookie:	
  session=bob;	
   domain=.bank.com;
path=/;
①
http://weibo.com
Cookie: session=bob;
②
http://non.bank.com
Secure Flag
Set-­‐Cookie:	
  session=bob; domain=.bank.com;
path=/;	
  Secure;
http://non.bank.com
Cookie: session=bob	
  ;
https://bank.com
HTTPS
X
①
②
RFC:	
  带有Secure属性的Cookie仅能在HTTPS会话中传输
Secure	
  Flag:	
  缺乏完整性保护
RFC 6265:
Although	
  seemingly	
  useful	
  for	
  protecting	
  cookies	
  from	
  active	
  network attackers,	
the	
  Secure	
  attribute	
  protects	
  only	
  the	
  cookie’s confidentiality.
An	
  active	
  network	
  attacker	
  can	
  overwrite Secure cookies	
  from	
  an	
  insecure	
  channel,	
disrupting	
  their	
  integrity.
https://good.bank.com/
http://evil.bank.com/
Cookie: session=bob;
(domain=.bank.com; path=/; Secure)
Set-­‐Cookie: session=attacker; domain=.bank.com; path=/;
Secure	
  Cookie覆盖
http://non.bank.com
HTTPS
https://bank.com
HTTP
Cookie:	
  session=bob;	
   domain=.bank.com;	
path=/;	
  Secure;
①
Set-­‐Cookie:	
  session=attacker;	
  domain=.bank.com;	
  path=/;	
  Secure;
②
Cookie:	
  session=attacker;
③
Cookie注入：Authenticated-­‐as-­‐Attacker
BARTH,	
  A.,	
  JACKSON,	
  C.,	
  Robust	
  De-­‐fenses for	
  Cross-­‐Site	
  Request	
  Forgery
Cookie注入：反射
广义的反射：
• 服务端将Cookie拼接到HTML页面
• JS将Cookie渲染到DOM/参与运算
Cookie反射：XSS
Set-­‐Cookie:	
  inject=abc”+alert(‘xss’)+”;	
domain=.amazon.cn;	
  path=/;
Amazon	
  Cloud
个案？
Cookie反射（服务端）
非常普遍！
惯性思维1：“可信”的Cookie
• 谁输入的Cookie？服务端 or 第三方
惯性：服务器
• 检测自信、过滤简陋
BOA的实例：
反射：Cookie:	
  BA_0021=OLB
boaMboxCreate("***",	
  '***','***','***','profile.BA_0021=OLB','***','***','***');
过滤：Cookie:	
  BA_0021=OLB’xss
boaMboxCreate("***",	
  '***','***','***','profile.BA_0021=OLB#xss','***','***','***');
运算：
function	
  boaMboxCreate()	
  {
var argStr =	
  process(arguments); //将参数处理为一个字符串
eval(“mboxCreate(”	
  +	
  argStr +	
  “)”);
}
绕过：Set-­‐Cookie:	
  BA_0021=OLB\x27+alert(1)+\x27;	
  domain=.bankofamerica.com;	
  path=/;
惯性思维2：“唯一”的Cookie
l 惯性：键值对
允许重名
Cookie的键是什么？name？
l Cookie由[name,	
  domain,	
  path]三元组唯一确定
[name, domain, path]才是Cookie的键
写时带属性，读时无属性
读取/发送时：
JS或Server只能看到name
domain、path由浏览器根据当前URL选择
http://non.bank.com
HTTP
https://user.bank.com
Cookie:	
  session=bob;	
   domain=.user.bank.com;	
path=/;	
  Secure;
①
Set-­‐Cookie:	
  session=attacker;	
  domain=.bank.com;	
  path=/;	
  Secure;
HTTP
②
Cookie:	
  session=bob; session=attacker;
③
重名：不唯一的Cookie
Server如何抉择？
重名：标准
重名Cookie如何处理？
RFC“标准”这样解释：
如果Cookie头中存在两个同名Cookie，服务器不应该根据
它们出现的先后顺序来决定谁有效。
——RFC6265
即，实际没有标准！！！
诡异的规范
如果Cookie头中存在两个同名Cookie，服务器不应该根据
它们出现的先后顺序来决定谁有效。
——RFC6265
潜台词：
“我也没辙，那就约定俗成，按顺序来处理吧”
Cookie:	
  session=bob; session=attacker;
写时带属性、读时无属性
除了先后顺序，没有其他区别
JS库/框架
优先级
JQuery
取前者
AngularJS
ExtJS
Dojo
YUI
取后者
额外提供取前者的接口
Server语言/框架
优先级
PHP
取前者
ASP/ASP.NET
Java/Spring
NodeJS
GoLang
Python
取后者
优先级顺序：Server	
  &	
  Browser
重名：顺序/优先级
浏览器对Cookie	
  String的排序原则
• 具有更长Path的Cookie更靠前；
• 如果Path长度相等，更早创建的Cookie更靠前；
——RFC6265
Cookie:	
  session=bob; session=attacker;
提高优先级：更长Path
目标页面：https://user.bank.com/admin/index.php?type=1
Server	
  à Set-­‐Cookie:	
  session=bob;	
  domain=.user.bank.com;	
  path=/;
Attacker à Set-­‐Cookie:	
  session=attacker;	
  domain=.bank.com;	
  path=/admin;
Server	