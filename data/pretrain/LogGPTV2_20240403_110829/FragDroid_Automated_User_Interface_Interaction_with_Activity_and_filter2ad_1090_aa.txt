title:FragDroid: Automated User Interface Interaction with Activity and
Fragment Analysis in Android Applications
author:Jia Chen and
Ge Han and
Shanqing Guo and
Wenrui Diao
2018 48th Annual IEEE/IFIP International Conference on Dependable Systems and Networks
FragDroid: Automated User Interface Interaction
with Activity and Fragment Analysis in Android
Applications
Jia Chen†, Ge Han†, Shanqing Guo*†‡ and Wenrui Diao§
†School of Computer Science and Technology, Shandong University
‡Key Laboratory of Cryptologic Technology and Information Security, Ministry of Education,
Email: PI:EMAIL, PI:EMAIL
Shandong University, Jinan 250100, China
Email: PI:EMAIL
§Jinan University
Email: PI:EMAIL
Abstract—Recent years have witnessed the enormous growth
of Android phones in the consumer market. On the other hand,
as the most popular mobile platform, Android also attracts lots
of attackers’ attention. As a result, more and more Android
malicious apps appear in the wild, which poses a serious threat
to user’s security and privacy. To such massive volume of Android
malware, automated UI testing techniques have become the
mainstream solutions because of the detection efﬁciency and
accuracy. However, all existing UI testing techniques treat the
Activity as the basic unit of UI interactions and cannot carry out a
ﬁne-grained analysis for Fragments. Due to the lack of Fragment-
level analysis, the path coverage is usually quite limited.
To ﬁll this gap,
in this paper, we propose FragDroid, a
novel automated UI testing framework supporting both Activity
and Fragment analysis. To achieve the Fragment-level testing,
we design the Activity & Fragment Transition Model (AFTM)
to simulate the internal
interactions of an app, and ATFM
could be utilized to generate test cases automatically through
UI interactions. With the assist of AFTM, FragDroid achieves
accessing most Activities and Fragments contained in the app
along with the capability of detecting arbitrary API calls. We
implemented a prototype of FragDroid and evaluated it on 15
popular apps. The results show FragDroid successfully covered
66% Fragments and the corresponding API calls of testing apps.
Also, the traditional approaches have to miss at least 9.6% of
API calls invoked in Fragments.
I. INTRODUCTION
The powerful functionalities of smartphones are primarily
supported by diverse mobile applications (apps for short). As
the most popular mobile platform, Android provides millions
of apps for users. There are over 1.5 million applications
and over 50 billion downloads on Google Play - Android’s
ofﬁcial app store. Android’s popularity also attracts attackers’
attention. More and more malicious apps appear in the wild,
which poses a serious threat to user’s security and privacy.
To such massive volume of Android malware, automated
UI testing techniques have become the mainstream solutions
because they could achieve the balance of detection efﬁciency
and accuracy. The original approach of UI testing is to inject
random test cases into a running app to explore UI states as
2158-3927/18/$31.00 Â©2018 IEEE
DOI 10.1109/DSN.2018.00049
398
many as possible. The most representative tool is Monkey [1]
which is provided by Google. After that, as an enhancement,
the record and replay (R&R) test technique was proposed [2],
[3]. Such technique could record the UI events triggered by
human testers and translate them to scripts. The scripts can
then be executed on other devices to drive the app running
through replaying the recorded UI events. The R&R test
technique could reproduce the test cases easily, but its cost
is quite expensive in the input collection and maintenance.
More recently, model-based testing (MBT) technique was
proposed, which injects test cases into an app aligning with a
speciﬁc model. MBT usually contains two phases – model
generation and dynamic testing. The challenge of MBT is
how to generate an effective model with high path coverage
rate. Automatic model generation based on the source code
is usually used in white-box tests, while dynamic slicing at
runtime techniques is usually used in black-box tests. For
dynamic slicing, the model generated by a slicer based on UI
states guides the app to trigger events, and the shortcomings
include the difﬁculty of backtrack and the lack of context.
Activities are the fundamental building blocks of Android
apps. Existing Android UI test tools based on MBT mainly
use the Activity as the basic unit to distinguish different UI
states. However, since Android 3.0, the Fragment has been
introduced into Android, and it could be treated as sub-
Activity or mini-Activity. The usage of Fragments has become
popular after Android 5.0 because of its high efﬁciency and
low consumption in the UI switching. To demonstrate its
popularity, we conducted a study on 217 top downloading
apps from Google Play, and it shows that nearly 91% of these
apps use Fragments. At the same time, none of existing MBT
techniques could handle the widespread Fragment components
properly, and the challenges derive from multiple aspects.
Challenge 1: An Activity could host Fragments, and nearly
all existing MBT techniques take Activity as a ﬁxed UI state.
The existing techniques neglect the reachable UI states caused
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 10:48:55 UTC from IEEE Xplore.  Restrictions apply. 
(a) Fragment of Cate-
gory tab
(b) Fragment of Re-
cent tab
Fig. 1: Fragment Transformation
(a) Fragment of wa-
llpapers
(b) Slide menu
(c) Fragment of live
wallpapers
Fig. 2: Fragment switching through hidden slide menu
by Fragment transformations and miss the logic functions
contained in them. Although random input
tests, such as
Monkey, can occasionally reach these Fragments, they are not
programmable and cannot be controlled accurately. To achieve
the Fragment-level analysis, the transitions between Activities
and Fragments and the functions contained in Fragments
need to be analyzed. Following this requirement, it has to
be considered that a transformation of Fragments inside an
Activity may lead a switching of UI states. As an example
shown in Figure 1, the clicking on the menu will trigger a
Fragment transformation (from Figure 1(a) to Figure 1(b)),
which further occurs the switching of UI states. In this case, we
could ﬁnd the object of the rest testing operations is changed
while the Activity is not. If the testing tools ignore Fragment
transformations, the proportion of total reachable UI states will
stay at a low level.
Challenge 2: The approaches to switching Fragment compo-
nents could be invisible or hidden in UI, so the existing MBT
techniques may fail to uncover the relationships of Fragments.
Figure 2 illustrates this situation, in which an app uses the
navigation drawer design. Figure 2(a) and Figure 2(c) show
two Fragments in the same Activity, and the slide menu in
Figure 2(b) is the only bridge between them. Also, the menu
is hidden and only can be seen by clicking the left-top icon
or sliding from left to right. Most existing techniques neglect
such kind of switching relationships and the corresponding UI
states.
Our Work. To address the challenges caused by Fragment
components, we propose FragDroid, a novel automated An-
droid UI testing technique supporting both Activity and Frag-
ment analysis. FragDroid takes the interactions of Activities
and Fragments into consideration during the test. It could
detect and invoke both Activities and Fragments to explore
all reachable UI states.
In the design of FragDroid, we deﬁne an Activity & Frag-
ment Transition Model (AFTM) which could be evolutionarily
updated to store the possible transitions between Activities
and Fragments. AFTM considers the dependencies among
UI elements including Activities, Fragments, and widgets. To
address the feature of hidden switching of Fragments, we use
the Java reﬂection mechanism to switch UI states forcedly.
Also, the design of FragDroid synthesizes the idea of ripper
techniques and automation frameworks/APIs (AF/A) [4], [5],
[6] (providing the high-level syntax for generating test cases).
Given an APK ﬁle, FragDroid extracts the dependency in-
formation ﬁrst. Then this app is installed on a customized
Android device for dynamic execution. FragDroid generates
proper test case scripts base on AF/A, and test cases will
trigger different UI events. At
the same time, FragDroid
monitors and analyzes the runtime information. Once the UI
state (on the Fragment level) changes, the AFTM and the
sequence of test cases will be updated until all possible UI
states have been explored.
Contributions. The main contributions of this paper are:
• We proposed Fragdroid, the ﬁrst Android automated UI
testing framework supporting both Activity and Fragment
analysis. We also implemented a full-feature prototype of
FragDroid.
• We analyzed 217 popular apps from different categories
and revealed that up to 91% of apps are developed with
Fragments. We evaluated FragDroid on 15 of them, and
the average coverage is 66% for Fragments and 71.94%
for Activities. It demonstrates that FragDroid achieves
a satisfactory coverage and reaches a recommendable
performance.
• We applied Fragdroid to discover the relation between the
invocations of sensitive APIs and UI elements (including
Activities and Fragments), which is helpful for detecting
malicious code, bug, etc. In the experiment, 46 sensitive
APIs, like obtaining locations and accessing storage, were
found through deploying FragDroid on 15 selected apps.
The result shows that the API invocations associated with
Fragments account for 49% of the total invocations. The
traditional approaches based on Activity have to miss at
least 9.6% of API calls invoked in Fragments.
Roadmap. The rest of this paper is organized as follows.
Section II gives the necessary background of Activity and
Fragment. In Section III, we present the high-level design of
FragDroid. Section IV provides the deﬁnition and initialization
the Activity & Fragment Transition Model. Section V and
Section VI describe the process of dependency extraction and
evolutionary test case generation respectively. The experimen-
399
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 10:48:55 UTC from IEEE Xplore.  Restrictions apply. 
tal results are presented in Section VII. Section VIII discusses
the limitation of our framework. Section IX summarizes the
related works, and Section X concludes this paper.
II. BACKGROUND
In this section, we brieﬂy introduce the Activity and Frag-
ment components in Android.
A. Activity and Fragment in Android
The Activity class is the most common component of an
Android app, and the way in which Activities are launched and
put together plays a fundamental part in application model [7].
It serves as the entry point to interact with users and provides
a window where the app draws its UI.
The Fragment was introduced in Android 3.0 to facilitate the
app development and better the user experience [8]. It supports
more dynamic and ﬂexible UI designs on large screens. A
Fragment could be treated as a modular section of an Activity
(or mini-Activity), which has its own lifecycle, receives its
own input events. By dividing the layout of an Activity into
Fragments, developers become able to modify the Activity’s
appearance at runtime [9].
B. The Relationship of Activity and Fragment
In simple terms, the Activity and Fragment are both the
fundamental building blocks of Android apps. A Fragment
could be treated as a sub-Activity or mini-Activity. It could be
added to an Activity or removed from an Activity at runtime.
Usually, a Fragment contributes a portion of UI to the host
Activity, which is embedded as a part of the Activity’s overall
view hierarchy. Developers can attach the Fragment layouts
they want to inﬂate by implementing the onCreateView()
callback method. There are two ways to add a Fragment to the
Activity layout: (1) declare the Fragment inside an Activity’s
layout ﬁle; (2) add the Fragment into an existing ViewGroup
programmatically. The FragmentTransaction class [10]
provides the APIs for performing a set of Fragment operations,
including adding, removing, and replacing a Fragment. The
code snippet listed in Figure 3 shows how to add a Fragment
to an Activity at runtime.
In addition, developers can combine multiple Fragments
in a single Activity to build a multi-pane UI and reuse one
Fragment across multiple Activities. Since a Fragment can get
Context instance from its host Activity, it can execute almost
all actions like an Activity, such as starting a new Activity,
obtaining privileges, accessing sensitive information, and so
forth.
III. SYSTEM OVERVIEW
In this paper, we propose FragDroid, an automated Android
GUI testing framework supporting Fragments. It can trigger
nearly all Fragments and Activities during dynamic analysis
to achieve a high path coverage. As illustrated in Figure 4,
FragDroid contains two main phases: Static Information Ex-
traction and Evolutionary Test Case Generation. Here we give
a brief overview.
Static Information Extraction. Based on the static code
analysis, this phase aims to collect the necessary information
to facilitate the subsequent evolutionary test case generation
phase.
• The primary information collected is the Activity &
Fragment Transition Model (AFTM) which is a ﬁnite
state model simulating the internal interactions among
Activities and Fragments. This model is extracted from
the smali code1 of the target app. The formal deﬁnition
of AFTM will be given in Section IV-A.
• Also, some meta-data used for the evolutionary testing
will be collected, like the number of Activities and Frag-
ments, dependencies among UI controls, etc. Especially,
we provide a JSON ﬁle that records all view components
and the locations they appear.
Evolutionary Test Case Generation. In this phase, dynamic
test cases are generated with the data in AFTM. Note that,
AFTM is a dynamic model, and it will be updated continu-
ously until all nodes have been visited.
In the beginning, the queue generation module traverses the
initial AFTM by breadth-ﬁrst search. Every newly discovered
node (Activity or Fragment) in the AFTM will trigger that
a new item will be pushed to the queue. This item contains
the information of the transition from the entry node to the
discovered node, like the way to reaching particular interface
and a series of UI events during the transition. After that,
the item in the queue will be put to the test case generation
module for generating a test program by Robotium. With the
meta-data collected during static analysis, the test program will
be created and installed to the phone automatically.
After running a test program, the UI driving module ana-
lyzes the current UI state on the Fragment level. Three tasks
are involved: (1) identifying the current Activity and Fragment
based on the previously extracted resource dependency; (2)
triggering all clickable widgets one by one; (3) analyzing the
new UI state after clicking operations and updating the AFTM
(if a new transition relationship appears). The above operations
will not stop until all nodes have been visited.
IV. ACTIVITY & FRAGMENT TRANSITION MODEL
To facilitate the execution of our dynamic analysis frame-
work, we propose the Activity & Fragment Transition Model
(AFTM). AFTM is a ﬁnite state model extracted from an
Android app. It contains all working Activities, Fragments, and
the event-driven transitions among them. Working Activities
and Fragments mean they are not isolated and could interact
with users. Essentially, such model simulates the internal
structure of an app and could be treated as a map for dynamic
analysis.
In this section, we give the formal deﬁnition of AFTM and
describe how to initialize this model from an app as well as
other associated tasks during static analysis.
1After reversing an APK ﬁle, we could get the corresponding smali code,
like the decompilation code from binary code.
400
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 10:48:55 UTC from IEEE Xplore.  Restrictions apply. 
1 // Get an instance of FragmentTransaction from an Activity
2 FragmentManager fragmentManager = getFragmentManager();
3 FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction();
4
5 // Use the add() method to add a Fragment
6 // ExampleFragment class extends from android.app.Fragment
7 ExampleFragment fragment = new ExampleFragment();
8 fragmentTransaction.add(R.id.fragment_container, fragment);
9
10 // If we want to replace the current Fragment with ExampleFragment, use:
11 // fragmentTransaction.replace(R.id.fragment_container, fragment);
12 fragmentTransaction.commit();
Fig. 3: Code example: Add a Fragment to an Activity
Evolutionary Test Case Generation
Queue 
Generation
Test Result
Model Extraction
AFTM
Meta-data
AFTM
Test Case
Generation
Meta-data Extration
Static Information Extration
UI Driving
Fig. 4: Overview of FragDroid
A. Deﬁnition of AFTM
E2
E2
SplashScreen
Activity
(A0)
HourlyForecast
DetailActivity
(A2)
Report
Fragment
(F4)
Setting
Activity
(A3)
Settings
Fragment
(F5)
E1
E1
E1
Deﬁnition 1. The AFTM of an app is a tuple ,
where
WeatherMain
Activity
(A1)
Location2Paging
Location1Paging
Fragment
(F2)
Fragment
(F1)
Location0Paging
Fragment
(F0)
E3
E3
XML File
(Activity)
XML File
(Fragment)
Code File
(Activity)
Code File
(Fragment)
WeatherMainActivity
(Location0Paging
Fragment)
(cid:28628)(cid:28633)(cid:28647)(cid:28640)
• A is a ﬁnite set of Activities that can switch from/to other
elements (Activities or Fragments) in the call graph of the
app. A0 is the entry Activity, and so on, for A1, A2, A3,
and . . . .
• F is a ﬁnite set of Fragments that can switch from/to