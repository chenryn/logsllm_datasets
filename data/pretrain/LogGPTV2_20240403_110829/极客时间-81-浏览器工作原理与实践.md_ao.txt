## 总结好了，今天的内容就讲到这里，下面我来简单总结下今天的内容。由于 JavaScript 的变量提升存在着变量覆盖、变量污染等设计缺陷，所以 ES6引入了块级作用域关键字来解决这些问题。之后我们还通过对变量环境和词法环境的介绍，分析了 JavaScript引擎是如何同时支持变量提升和块级作用域的。既然聊到了作用域，那最后我们再简单聊下编程语言吧。经常有人争论什么编程语言是世界上最好的语言，但如果站在语言本身来说，我觉得这种争论没有意义，因为语言是工具，而工具是用来创造价值的，至于能否创造价值或创造多大价值不完全由语言本身的特性决定。这么说吧，即便一门设计不那么好的语言，它也可能拥有非常好的生态，比如有完善的框架、非常多的落地应用，又或者能够给开发者带来更多的回报，这些都是评判因素。如果站在语言层面来谈，每种语言其实都是在相互借鉴对方的优势，协同进化，比如JavaScript 引进了作用域、迭代器和协程，其底层虚拟机的实现和 Java、Python又是非常相似，也就是说如果你理解了 JavaScript 协程和 JavaScript中的虚拟机，其实你也就理解了 Java、Python 中的协程和虚拟机的实现机制。所以说，语言本身好坏不重要，重要的是能为开发者创造价值。
## 思考时间下面给你留个思考题，看下面这样一段代码：    let myname= '极客时间'{  console.log(myname)   let myname= '极客邦'}你能通过分析词法环境，得出来最终的打印结果吗？欢迎在留言区与我分享你的想法，也欢迎你在留言区记录你的思考过程。感谢阅读，如果你觉得这篇文章对你有帮助的话，也欢迎把它分享给更多的朋友。![](Images/7e91bd5c116048de87e68468f727fc3c.png){savepage-src="https://static001.geekbang.org/resource/image/3f/cb/3f4d5bec2d5c89600b4628581144d8cb.jpg"}
# 10 \| 作用域链和闭包 ：代码中出现相同的变量，JavaScript引擎是如何选择的？在[上一篇文章](https://time.geekbang.org/column/article/126339)中我们讲到了什么是作用域，以及ES6是如何通过变量环境和词法环境来同时支持变量提升和块级作用域，在最后我们也提到了如何通过词法环境和变量环境来查找变量，这其中就涉及到**作用域链**的概念。理解作用域链是理解闭包的基础，而闭包在 JavaScript中几乎无处不在，同时作用域和作用域链还是所有编程语言的基础。所以，如果你想学透一门语言，作用域和作用域链一定是绕不开的。那今天我们就来聊聊**什么是作用域链**，并通过作用域链再来讲讲**什么是闭包**。首先我们来看下面这段代码：    function bar() {    console.log(myName)}function foo() {    var myName = " 极客邦 "    bar()}var myName = " 极客时间 "foo()你觉得这段代码中的 bar 函数和 foo函数打印出来的内容是什么？这就要分析下这两段代码的执行流程。通过前面几篇文章的学习，想必你已经知道了如何通过执行上下文来分析代码的执行流程了。那么当这段代码执行到bar 函数内部时，其调用栈的状态图如下所示：![](Images/ecfefcac18df952a85bbcbe512dfd859.png){savepage-src="https://static001.geekbang.org/resource/image/87/f7/87d8bbc2bb62b03131802fba074146f7.png"}```{=html}```执行 bar 函数时的调用栈]{.reference}```{=html}```从图中可以看出，全局执行上下文和 foo 函数的执行上下文中都包含变量myName，那 bar 函数里面 myName 的值到底该选择哪个呢？也许你的第一反应是按照调用栈的顺序来查找变量，查找方式如下：1.  先查找栈顶是否存在 myName 变量，但是这里没有，所以接着往下查找 foo    函数中的变量。2.  在 foo 函数中查找到了 myName 变量，这时候就使用 foo 函数中的    myName。``{=html}如果按照这种方式来查找变量，那么最终执行 bar函数打印出来的结果就应该是"极客邦"。但实际情况并非如此，如果你试着执行上述代码，你会发现打印出来的结果是"极客时间"。为什么会是这种情况呢？要解释清楚这个问题，那么你就需要先搞清楚作用域链了。
## 作用域链关于作用域链，很多人会感觉费解，但如果你理解了调用栈、执行上下文、词法环境、变量环境等概念，那么你理解起来作用域链也会很容易。所以很是建议你结合前几篇文章将上面那几个概念学习透彻。其实在每个执行上下文的变量环境中，都包含了一个外部引用，用来指向外部的执行上下文，我们把这个外部引用称为**outer**。当一段代码使用了一个变量时，JavaScript引擎首先会在"当前的执行上下文"中查找该变量，\比如上面那段代码在查找 myName变量时，如果在当前的变量环境中没有查找到，那么 JavaScript 引擎会继续在outer 所指向的执行上下文中查找。为了直观理解，你可以看下面这张图：![](Images/51d7a037d66ac51ef0cb90dbdd152788.png){savepage-src="https://static001.geekbang.org/resource/image/20/a7/20a832656434264db47c93e657e346a7.png"}```{=html}```带有外部引用的调用栈示意图]{.reference}```{=html}```从图中可以看出，bar 函数和 foo 函数的 outer都是指向全局上下文的，这也就意味着如果在 bar 函数或者 foo函数中使用了外部变量，那么 JavaScript引擎会去全局执行上下文中查找。我们把这个查找的链条就称为**作用域链**。现在你知道变量是通过作用域链来查找的了，不过还有一个疑问没有解开，foo函数调用的 bar 函数，那为什么 bar 函数的外部引用是全局执行上下文，而不是foo 函数的执行上下文？要回答这个问题，你还需要知道什么是**词法作用域**。这是因为在 JavaScript执行过程中，其作用域链是由词法作用域决定的。
## 词法作用域**词法作用域就是指作用域是由代码中函数声明的位置来决定的，所以词法作用域是静态的作用域，通过它就能够预测代码在执行过程中如何查找标识符。**这么讲可能不太好理解，你可以看下面这张图：![](Images/57362c8ced4418830fed45f669f767f5.png){savepage-src="https://static001.geekbang.org/resource/image/21/39/216433d2d0c64149a731d84ba1a07739.png"}```{=html}```词法作用域]{.reference}```{=html}```从图中可以看出，词法作用域就是根据代码的位置来决定的，其中 main函数包含了 bar 函数，bar 函数中包含了 foo 函数，因为 JavaScript作用域链是由词法作用域决定的，所以整个词法作用域链的顺序是：foo函数作用域---\>bar 函数作用域---\>main 函数作用域---\> 全局作用域。了解了词法作用域以及 JavaScript中的作用域链，我们再回过头来看看上面的那个问题：在开头那段代码中，foo函数调用了 bar 函数，那为什么 bar 函数的外部引用是全局执行上下文，而不是foo 函数的执行上下文?这是因为根据词法作用域，foo 和 bar 的上级作用域都是全局作用域，所以如果foo 或者 bar函数使用了一个它们没有定义的变量，那么它们会到全局作用域去查找。也就是说，**词法作用域是代码阶段就决定好的，和函数是怎么调用的没有关系**。
## 块级作用域中的变量查找前面我们通过全局作用域和函数级作用域来分析了作用域链，那接下来我们再来看看块级作用域中变量是如何查找的？在编写代码的时候，如果你使用了一个在当前作用域中不存在的变量，这时JavaScript引擎就需要按照作用域链在其他作用域中查找该变量，如果你不了解该过程，那就会有很大概率写出不稳定的代码。我们还是先看下面这段代码：    function bar() {    var myName = " 极客世界 "    let test1 = 100    if (1) {        let myName = "Chrome 浏览器 "        console.log(test)    }}function foo() {    var myName = " 极客邦 "    let test = 2    {        let test = 3        bar()    }}var myName = " 极客时间 "let myAge = 10let test = 1foo()你可以自己先分析下这段代码的执行流程，看看能否分析出来执行结果。要想得出其执行结果，那接下来我们就得站在作用域链和词法环境的角度来分析下其执行过程。在[上篇文章](https://time.geekbang.org/column/article/126339)中我们已经介绍过了，ES6是支持块级作用域的，当执行到代码块时，如果代码块中有 let 或者 const声明的变量，那么变量就会存放到该函数的词法环境中。对于上面这段代码，当执行到bar 函数内部的 if 语句块时，其调用栈的情况如下图所示：![](Images/10350a26fbb77e45d8421fb9211e01bc.png){savepage-src="https://static001.geekbang.org/resource/image/25/a7/25053af5ae30c8be991fa14631cde0a7.png"}```{=html}```块级作用域中是如何查找变量的]{.reference}```{=html}```现在是执行到 bar 函数的 if 语块之内，需要打印出来变量test，那么就需要查找到 test 变量的值，其查找过程我已经在上图中使用序号1、2、3、4、5 标记出来了。下面我就来解释下这个过程。首先是在 bar 函数的执行上下文中查找，但因为bar 函数的执行上下文中没有定义 test变量，所以根据词法作用域的规则，下一步就在 bar函数的外部作用域中查找，也就是全局作用域。至于单个执行上下文中如何查找变量，我在[上一篇文章](https://time.geekbang.org/column/article/126339)中已经做了介绍，这里就不重复了。
## 闭包了解了作用域链，接着我们就可以来聊聊闭包了。关于闭包，理解起来可能会是一道坎，特别是在你不太熟悉JavaScript这门语言的时候，接触闭包很可能会让你产生一些挫败感，因为你很难通过理解背后的原理来彻底理解闭包，从而导致学习过程中似乎总是似懂非懂。最要命的是，JavaScript代码中还总是充斥着大量的闭包代码。但理解了变量环境、词法环境和作用域链等概念，那接下来你再理解什么是JavaScript中的闭包就容易多了。这里你可以结合下面这段代码来理解什么是闭包：    function foo() {    var myName = " 极客时间 "    let test1 = 1    const test2 = 2    var innerBar = {        getName:function(){            console.log(test1)            return myName        },        setName:function(newName){            myName = newName        }    }    return innerBar}var bar = foo()bar.setName(" 极客邦 ")bar.getName()console.log(bar.getName())首先我们看看当执行到 foo函数内部的`return innerBar`这行代码时调用栈的情况，你可以参考下图：![](Images/b88777a0671ff90cc3b376b8373a3d8e.png){savepage-src="https://static001.geekbang.org/resource/image/d5/ef/d5587b76427a56c5f0b0571e4264b7ef.png"}```{=html}```执行到 return bar 时候的调用栈]{.reference}```{=html}```从上面的代码可以看出，innerBar 是一个对象，包含了 getName 和 setName的两个方法（通常我们把对象内部的函数称为方法）。你可以看到，这两个方法都是在foo 函数内部定义的，并且这两个方法内部都使用了 myName 和 test1两个变量。**根据词法作用域的规则，内部函数 getName 和 setName总是可以访问它们的外部函数 foo 中的变量**，所以当 innerBar对象返回给全局变量 bar 时，虽然 foo 函数已经执行结束，但是 getName 和setName 函数依然可以使用 foo 函数中的变量 myName 和 test1。所以当 foo函数执行完成之后，其整个调用栈的状态如下图所示：![](Images/8312f253085b604c92af0b33215d3f25.png){savepage-src="https://static001.geekbang.org/resource/image/ee/3f/ee7c1ca481875ad4bdeb4383bd1f883f.png"}```{=html}```闭包的产生过程]{.reference}```{=html}```从上图可以看出，foo函数执行完成之后，其执行上下文从栈顶弹出了，但是由于返回的 setName 和getName 方法中使用了 foo 函数内部的变量 myName 和test1，所以这两个变量依然保存在内存中。这像极了 setName 和 getName方法背的一个专属背包，无论在哪里调用了 setName 和 getName方法，它们都会背着这个 foo 函数的专属背包。之所以是**专属**背包，是因为除了 setName 和 getName函数之外，其他任何地方都是无法访问该背包的，我们就可以把这个背包称为 foo函数的**闭包**。好了，现在我们终于可以给闭包一个正式的定义了。**在 JavaScript中，根据词法作用域的规则，内部函数总是可以访问其外部函数中声明的变量，当通过调用一个外部函数返回一个内部函数后，即使该外部函数已经执行结束了，但是内部函数引用外部函数的变量依然保存在内存中，我们就把这些变量的集合称为闭包。比如外部函数是foo，那么这些变量的集合就称为 foo 函数的闭包**。那这些闭包是如何使用的呢？当执行到 bar.setName方法中的`myName = "极客邦"`这句代码时，JavaScript引擎会沿着"当前执行上下文--\>foo 函数闭包--\>全局执行上下文"的顺序来查找 myName 变量，你可以参考下面的调用栈状态图：![](Images/b4b7a0dcd19215c2d1cb81cea5dcbee5.png){savepage-src="https://static001.geekbang.org/resource/image/50/46/50e4ba60fc7e420e83b35b95e379b246.png"}```{=html}```执行 bar 时调用栈状态]{.reference}```{=html}```从图中可以看出，setName 的执行上下文中没有 myName 变量，foo函数的闭包中包含了变量 myName，所以调用 setName 时，会修改 foo 闭包中的myName 变量的值。同样的流程，当调用 bar.getName 的时候，所访问的变量 myName 也是位于 foo函数闭包中的。你也可以通过"开发者工具"来看看闭包的情况，打开 Chrome 的"开发者工具"，在bar 函数任意地方打上断点，然后刷新页面，可以看到如下内容：![](Images/747bb6677208c937877247f67b9658da.png){savepage-src="https://static001.geekbang.org/resource/image/40/a8/40b8840480a5df4f43ad5f4e7907e3a8.png"}```{=html}```开发者工具中的闭包展示]{.reference}```{=html}```从图中可以看出来，当调用 bar.getName 的时候，右边 Scope项就体现出了作用域链的情况：Local 就是当前的 getName函数的作用域，Closure(foo) 是指 foo 函数的闭包，最下面的 Global就是指全局作用域，从"Local--\>Closure(foo)--\>Global"就是一个完整的作用域链。所以说，你以后也可以通过 Scope来查看实际代码作用域链的情况，这样调试代码也会比较方便。