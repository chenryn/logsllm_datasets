    '[228483823411430971765632614756935594262 270867761665365061602695324172148308695 270682585589276777781448680945567679788 213507765198029256400141067987133373726 76037731708593018888930325428923617568 30682862786884871003242427010850491072 167298978250225467829760031606711270085 72822666625837066035637817957473696601]',
    '[195360134168787557177461554506460108718 122308058514175020254833726324781052273 225146579830375254258394356703192766275 141448314831908836605197528091870487865 150984932528304035512378115089222613654 258513501018477452331175661114007493672 280750213283721060295861114047761297997 149688812218926847069069885299483586476]',
    '[39751280632280049247741325771978681046 126855003643133686822494937986884309325 115180417419233183793165658750256344391 165938790171278140853730464165871696036 125785499316292959084455022571711272463 113018734944080600564983861961988444496 121333906833173879138713882299961654246 74854082980047960871154066988489234830]',
    '[137318192742872999161232833053514199378 77303525632818524122343716610518443942 160269374197044199668350654249626402587 115833901383881866816610270277305149900 208252536116807546101734823290785501108 217944947974996128948835835464385601397 166097670266427048341426239212284108828 6804019980433054638881349231392552603]',
    '[223303329908928292177045252540723878662 162073383009692124348835494388447606848 75684161198666039016621659050855083132 214809882035378545846738708974574594313 87881170698279792546809027489142288582 209684762911442115958995698637848828382 62250525374182677523486425819610947199 279847608325021186228379026650485946576]',
    '[67984665902369694514999957506279439994 268381222641753282423880203957876639758 246945134892118899884699312748250139309 65992451070302178885369398606163545606 116843550219931501998786016165547932075 183992253565936581165613292055256448566 263733379385279468893508349748581537056 271771128787717918335624952723447691861]',
    '[243684657592111494155573374100758277706 199888678572875313963836033529833113400 144529013312000077536517713640604480652 195346356780285790893865181659755080639 177192461902687091902497281184780912038 98619970825132499781249548734139906601 75338491010152968387510315283944125602 235096138241797869586420967960223530601]',
    '[72151893808127002595348778087435224319 81726004275189558083196981094140189988 120182868897691025353764768886735207100 202139727058084483577259545137210899092 172363102516135760004141577739481722490 47134074008080627610223569691660297614 123362836929825076302183828024021376167 223183587970484310511105130772286701816]',
    '[198229942846513253072302724550917821624 203790104834341577744516837088067561528 268462473934338408807986146010492366120 2838111217330153826487758479090332221 24168375885146064383306126685127043568 106145968666962799863332198895828734493 210842459276905023853370050105467358280 279918790313996396021668388694087973972]',
    '[279958295787638180753395460799528194681 282632555284078775050842945928105322059 236625278255622713621309747554901434361 152370360457970139981070013834891821455 279957343826025692192966948867958440827 283163488212063405065442268900136281469 13585301929645503773034214420121810733 84973170341472624058356167001596150486]']
    for i in c:
        temp=i[1:-1].split(' ')
        flag=''.join(['0' if jacobi(int(j),n)==1  else '1' for j in temp])
        print(chr(int(flag,2)),end='')
    #token=XF38YOg92IRNyugYD7go
    #flag{Oh_NO_aT_LEast_mY_AlGORithM_is_ExpanDiNg}
###  WhatTheHecc(mid):
感觉可能是非预期？
题目里提供了sign，run，show功能，但sign里支持的命令有限，而如果我们需要通过run拿到flag则需要伪造签名，因此看一下verify函数，可以得知：
但这里实现有点问题，verify的sig是能够自己控制的，因此如果
则此时同样等式成立，验证通过
    from netcat import *
    from Cryptodome.Hash import SHA3_256
    from Cryptodome.PublicKey import ECC
    from Cryptodome.Math.Numbers import Integer
    def hash(msg):
        h_obj = SHA3_256.new()
        h_obj.update(msg.encode())
        return Integer.from_bytes(h_obj.digest())
    r = remote("flu.xxx", 20085)
    print(r.recv_until(b">"))
    r.sendline(b"show")
    r.recv_until(b"point_x=")
    Rx = int(r.recv_until(b", point_y=").decode().replace(", point_y=", ""))
    Ry = int(r.recv_until(b")").decode().replace(")", ""))
    print(Rx, Ry)
    hmsg = hash("cat flag")
    ecc = ECC.generate(curve='P-256')
    tmp = hmsg * ecc._curve.G
    hx, hy = tmp.x, tmp.y
    print(hx, hy)
    print(r.recv_until(b">"))
    r.sendline(b"run")
    sig = f"{Rx}|{Ry}|{hmsg}|cat flag"
    print(r.recv_until(b">"))
    r.sendline(sig.encode())
    print(r.recv_until(b"}"))
    r.close()
###  lwsr(mid):
(当时比赛的时候没有做出来,就差了一点,本地通了,远程出了一些问题,但还是复现一下)
每次decrypt能够知道state&1，因此如结果为Success!，则state的末尾比特为1，反之则为0，而每次lfsr产生的newbit在首位，因此如果交互384次，就能拿到clear
LFSR
bits后的初始比特。然后再回推最原始的状态，每次一位，那么每次只用考虑爆破1bit，然后检查lfsr(回推值)是否等于当前值，回退384+len(ct)次即可。得到初始状态后只需要再相应密文位减去pk，判断c%q是否为0即可，为0则当前明文比特为0，反之为1。
    from Crypto.Util.number import long_to_bytes
    from netcat import *
    def lfsr(state):
        # x^384 + x^8 + x^7 + x^6 + x^4 + x^3 + x^2 + x + 1
        mask   = (1 > 1) | (newbit > i) & 1 == 1:
                tmp += "1"
                c -= pk[i][1]
        c = c % 16411
        if c == 0:
            flag += "0"
        else:
            flag += "1"
        state = lfsr(state)
    print(long_to_bytes(int(flag, 2)))
    r.close()
    #flag{your_fluxmarket_stock_may_shift_up_now}
## Misc:
###  Tenbagger(NONE):
流量文件中存在大量无法被解密的TLS流量，且多数网站通过DNS解析记录得知目标为正常网站，不在本题目范围内。  
在此过滤所有TLS、DNS流量以及其指向的地址。  
发现FIX协议的本地到本地发送的流量，而该协议为金融相关，断定题目关键位置在此。
拼接即可
flag:
    flag{t0_th3_m00n_4nd_b4ck}
###  Touchy Logger(Low):
整个触屏过程很复杂，但我们只需要提取出明显的点击操作，具体就是：TOUCH_DOWN、TOUCH_FRAME 和 TOUCH_UP 三个合成一组的指令
    import re
    import numpy as np
    import cv2
    pattern = r' event5   TOUCH_DOWN       \+[\d]{1,3}\.[\d]{1,3}s\t0 \(0\)[ ]{1,3}[\d]{1,3}\.[\d]{1,3}/[\d]{1,3}\.[\d]{1,3} \([\d]{1,3}\.[\d]{1,3}/[\d]{2,3}\.[\d]{2}mm\)\n'
    pattern += r' event5   TOUCH_FRAME      \+[\d]{1,3}\.[\d]{1,3}s\t\n'
    pattern += r' event5   TOUCH_UP         \+[\d]{1,3}\.[\d]{1,3}'
    f = open('touch.log', 'r')
    content = f.read()
    f.close()
    rows = re.findall(pattern, content)
    def cap():
        timePattern=re.compile(r'\+([0-9]+)\.([0-9]{3})s')
        coodPattern=re.compile(r'\( ?([0-9\.]+)/ ?([0-9\.]+)mm\)')
        for row in rows:
            time=timePattern.search(row)
            time=int(time.group(1))*1000+int(time.group(2))
            p=coodPattern.search(row)
            x=float(p.group(1))
            y=float(p.group(2))
            yield ('',time,x,y)
    fourcc = cv2.VideoWriter_fourcc(*'XVID')
    fps=10.0
    out = cv2.VideoWriter('touch.avi', fourcc, fps, (259, 173))
    history=[[]]
    totalTime=0
    for i in cap():
        time=i[1]
        history[-1].append((i[2],i[3]))
        frame=np.zeros((173,259,3),np.uint8)+255
        for j in history[:-1]:
            for k in j:
                cv2.circle(frame,(int(k[0]),int(k[1])),1,(0,0,0),-1)
        for k in history[-1]:
            cv2.circle(frame,(int(k[0]),int(k[1])),1,(0,255,0),-1)
        while totalTime
账号：fluxmanfred  
密码：OiVyi)=wi$?;Ezq-lZx#  
登录就是 flag 了
flag: