29 
 // user 类型的值可以用来调用 
30 
 // 使用值接收者声明的方法 
31 
 bill := user{"Bill", "PI:EMAIL"} 
32 
 bill.notify() 
代码清单 5-15 展示了如何使用 user 类型的值来调用方法。第 31 行声明了一个 user 类型
的变量 bill，并使用给定的名字和电子邮件地址做初始化。之后在第 32 行，使用变量 bill 来
调用 notify 方法，如代码清单 5-16 所示。
代码清单 5-16 使用变量来调用方法 
bill.notify() 
这个语法与调用一个包里的函数看起来很类似。但在这个例子里，bill 不是包名，而是变
量名。这段程序在调用 notify 方法时，使用 bill 的值作为接收者进行调用，方法 notify
会接收到 bill 的值的一个副本。
也可以使用指针来调用使用值接收者声明的方法，如代码清单 5-17 所示。 
代码清单 5-17 listing11.go：第 34 行到第 37 行 
34 
 // 指向 user 类型值的指针也可以用来调用 
35 
 // 使用值接收者声明的方法 
36 
 lisa := &user{"Lisa", "PI:EMAIL"} 
37 
 lisa.notify() 
代码清单 5-17 展示了如何使用指向 user 类型值的指针来调用 notify 方法。在第 36 行，
声明了一个名为 lisa 的指针变量，并使用给定的名字和电子邮件地址做初始化。之后在第 37
行，使用这个指针变量来调用 notify 方法。为了支持这种方法调用，Go 语言调整了指针的值，
来符合方法接收者的定义。可以认为 Go 语言执行了代码清单 5-18 所示的操作。 
代码清单 5-18 Go 在代码背后的执行动作 
(*lisa).notify() 
代码清单 5-18 展示了 Go 编译器为了支持这种方法调用背后做的事情。指针被解引用为值，
这样就符合了值接收者的要求。再强调一次，notify 操作的是一个副本，只不过这次操作的是
从 lisa 指针指向的值的副本。
也可以使用指针接收者声明方法，如代码清单 5-19 所示。 
代码清单 5-19 listing11.go：第 22 行到第 25 行 
22 // changeEmail 使用指针接收者实现了一个方法 
23 func (u *user) changeEmail(email string) { 
24 
 u.email = email 
25 } 
代码清单 5-19 展示了 changeEmail 方法的声明。这个方法使用指针接收者声明。这个接
收者的类型是指向 user 类型值的指针，而不是 user 类型的值。当调用使用指针接收者声明的
方法时，这个方法会共享调用方法时接收者所指向的值，如代码清单 5-20 所示。 
90 
第 5 章 Go 语言的类型系统 
代码清单 5-20 listing11.go：第 36 行和第 44 行到第 46 行 
36 
 lisa := &user{"Lisa", "PI:EMAIL"} 
44 
// 指向 user 类型值的指针可以用来调用
45 
// 使用指针接收者声明的方法
46 
 lisa.changeEmail("PI:EMAIL") 
在代码清单 5-20 中，可以看到声明了 lisa 指针变量，还有第 46 行使用这个变量调用了
changeEmail 方法。一旦 changeEmail 调用返回，这个调用对值做的修改也会反映在 lisa
指针所指向的值上。这是因为 changeEmail 方法使用了指针接收者。总结一下，值接收者使用
值的副本来调用方法，而指针接受者使用实际值来调用方法。 
也可以使用一个值来调用使用指针接收者声明的方法，如代码清单 5-21 所示。 
代码清单 5-21 listing11.go：第 31 行和第 39 行到第 41 行 
31 
 bill := user{"Bill", "PI:EMAIL"} 
39 
// user 类型的值可以用来调用
40 
// 使用指针接收者声明的方法
41 
 bill.changeEmail("PI:EMAIL") 
在代码清单 5-21 中可以看到声明的变量 bill，以及之后使用这个变量调用使用指针接收者
声明的 changeEmail 方法。Go 语言再一次对值做了调整，使之符合函数的接收者，进行调用，
如代码清单 5-22 所示。 
代码清单 5-22 Go 在代码背后的执行动作 
(&bill).changeEmail ("PI:EMAIL") 
代码清单 5-22 展示了 Go 编译器为了支持这种方法调用在背后做的事情。在这个例子里，首
先引用 bill 值得到一个指针，这样这个指针就能够匹配方法的接收者类型，再进行调用。Go
语言既允许使用值，也允许使用指针来调用方法，不必严格符合接收者的类型。这个支持非常方
便开发者编写程序。 
应该使用值接收者，还是应该使用指针接收者，这个问题有时会比较迷惑人。可以遵从标准
库里一些基本的指导方针来做决定。后面会进一步介绍这些指导方针。 
5.3  类型的本质 
在声明一个新类型之后，声明一个该类型的方法之前，需要先回答一个问题：这个类型的本
质是什么。如果给这个类型增加或者删除某个值，是要创建一个新值，还是要更改当前的值？如
果是要创建一个新值，该类型的方法就使用值接收者。如果是要修改当前值，就使用指针接收者。
这个答案也会影响程序内部传递这个类型的值的方式：是按值做传递，还是按指针做传递。保持
传递的一致性很重要。这个背后的原则是，不要只关注某个方法是如何处理这个值，而是要关注
这个值的本质是什么。 
5.3.1  内置类型 
内置类型是由语言提供的一组类型。我们已经见过这些类型，分别是数值类型、字符串类型
和布尔类型。这些类型本质上是原始的类型。因此，当对这些值进行增加或者删除的时候，会创
建一个新值。基于这个结论，当把这些类型的值传递给方法或者函数时，应该传递一个对应值的
副本。让我们看一下标准库里使用这些内置类型的值的函数，如代码清单 5-23 所示。 
代码清单 5-23 golang.org/src/strings/strings.go：第 620 行到第 625 行 
620 func Trim(s string, cutset string) string { 
621 
 if s == "" || cutset == "" { 
622 
 return s 
623 
 } 
624 
 return TrimFunc(s, makeCutsetFunc(cutset)) 
625 } 
在代码清单 5-23 中，可以看到标准库里 strings 包的 Trim 函数。Trim 函数传入一个
string 类型的值作操作，再传入一个 string 类型的值用于查找。之后函数会返回一个新的
string 值作为操作结果。这个函数对调用者原始的 string 值的一个副本做操作，并返回一个
新的 string 值的副本。字符串（string）就像整数、浮点数和布尔值一样，本质上是一种很原
始的数据值，所以在函数或方法内外传递时，要传递字符串的一份副本。 
让我们看一下体现内置类型具有的原始本质的第二个例子，如代码清单 5-24 所示。 
代码清单 5-24 golang.org/src/os/env.go：第 38 行到第 44 行 
38 func isShellSpecialVar(c uint8) bool { 
39 
 switch c { 
40 
 case '*', '#', '$', '@', '!', '?', '0', '1', '2', '3', '4', '5', 
  '6', '7', '8', '9': 
41 
    return true 
42 
 } 
43 
 return false 
44 } 
代码清单 5-24 展示了 env 包里的 isShellSpecialVar 函数。这个函数传入了一个 int8
类型的值，并返回一个 bool 类型的值。注意，这里的参数没有使用指针来共享参数的值或者返
回值。调用者传入了一个 uint8 值的副本，并接受一个返回值 true 或者 false。
5.3.2  引用类型 
Go 语言里的引用类型有如下几个：切片、映射、通道、接口和函数类型。当声明上述类型
的变量时，创建的变量被称作标头（header）值。从技术细节上说，字符串也是一种引用类型。
每个引用类型创建的标头值是包含一个指向底层数据结构的指针。每个引用类型还包含一组独特
的字段，用于管理底层数据结构。因为标头值是为复制而设计的，所以永远不需要共享一个引用
类型的值。标头值里包含一个指针，因此通过复制来传递一个引用类型的值的副本，本质上就是
在共享底层数据结构。 
让我们看一下 net 包里的类型，如代码清单 5-25 所示。
代码清单 5-25 golang.org/src/net/ip.go：第 32 行 
32 type IP []byte 
代码清单 5-25 展示了一个名为 IP 的类型，这个类型被声明为字节切片。当要围绕相关的内
置类型或者引用类型来声明用户定义的行为时，直接基于已有类型来声明用户定义的类型会很好
用。编译器只允许为命名的用户定义的类型声明方法，如代码清单 5-26 所示。 
代码清单 5-26 golang.org/src/net/ip.go：第 329 行到第 337 行 
329 func (ip IP) MarshalText() ([]byte, error) { 
330 
 if len(ip) == 0 { 
331 
 return []byte(""), nil 
332 
 } 
333 
 if len(ip) != IPv4len && len(ip) != IPv6len { 
334 
 return nil, errors.New("invalid IP address") 
335 
 } 
336 
 return []byte(ip.String()), nil 
337 } 
代码清单 5-26 里定义的 MarshalText 方法是用 IP 类型的值接收者声明的。一个值接收者，
正像预期的那样通过复制来传递引用，从而不需要通过指针来共享引用类型的值。这种传递方法
也可以应用到函数或者方法的参数传递，如代码清单 5-27 所示。 
代码清单 5-27 golang.org/src/net/ip.go：第 318 行到第 325 行 
318 // ipEmptyString 像 ip.String 一样，  
319 // 只不过在没有设置 ip 时会返回一个空字符串 
320 func ipEmptyString(ip IP) string { 
321 
 if len(ip) == 0 { 
322 
 return "" 
323 
 } 
324 
 return ip.String() 
325 } 
在代码清单 5-27 里，有一个 ipEmptyString 函数。这个函数需要传入一个 IP 类型的值。
再一次，你可以看到调用者传入的是这个引用类型的值，而不是通过引用共享给这个函数。调用
者将引用类型的值的副本传入这个函数。这种方法也适用于函数的返回值。最后要说的是，引用
类型的值在其他方面像原始的数据类型的值一样对待。 
5.3.3  结构类型 
结构类型可以用来描述一组数据值，这组值的本质即可以是原始的，也可以是非原始的。如
果决定在某些东西需要删除或者添加某个结构类型的值时该结构类型的值不应该被更改，那么需
要遵守之前提到的内置类型和引用类型的规范。让我们从标准库里的一个原始本质的类型的结构
实现开始，如代码清单 5-28 所示。 
代码清单 5-28 golang.org/src/time/time.go：第 39 行到第 55 行 
39 type Time struct { 
40 
 // sec 给出自公元 1 年 1 月 1 日 00:00:00 
41 
 // 开始的秒数 
42 
 sec int64 
43 
44 
 // nsec 指定了一秒内的纳秒偏移， 
45 
 // 这个值是非零值， 
46 
 // 必须在[0, 999999999]范围内 
47 
 nsec int32 
48 
49 
 // loc 指定了一个 Location，  
50 
 // 用于决定该时间对应的当地的分、小时、 
51 
 // 天和年的值 
52 
 // 只有 Time 的零值，其 loc 的值是 nil 
53 
 // 这种情况下，认为处于 UTC 时区 
54 
 loc *Location 
55 } 
代码清单 5-28 中的 Time 结构选自 time 包。当思考时间的值时，你应该意识到给定的一个
时间点的时间是不能修改的。所以标准库里也是这样实现 Time 类型的。让我们看一下 Now 函
数是如何创建 Time 类型的值的，如代码清单 5-29 所示。
代码清单 5-29 golang.org/src/time/time.go：第 781 行到第 784 行 
781 func Now() Time { 
782 
 sec, nsec := now() 
783 
 return Time{sec + unixToInternal, nsec, Local} 
784 } 
代码清单 5-29 中的代码展示了 Now 函数的实现。这个函数创建了一个 Time 类型的值，并
给调用者返回了 Time 值的副本。这个函数没有使用指针来共享 Time 值。之后，让我们来看一
个 Time 类型的方法，如代码清单 5-30 所示。
代码清单 5-30 golang.org/src/time/time.go：第 610 行到第 622 行 
610 func (t Time) Add(d Duration) Time { 
611 
 t.sec += int64(d / 1e9) 
612 
 nsec := int32(t.nsec) + int32(d%1e9) 
613 
 if nsec >= 1e9 { 
614 
 t.sec++ 
615 
    nsec -= 1e9 
616 
 } else if nsec < 0 { 
617 
 t.sec-- 
618 
 nsec += 1e9 
619 
 } 
620 
 t.nsec = nsec 
621 
 return t 
622 } 
代码清单 5-30 中的 Add 方法是展示标准库如何将 Time 类型作为本质是原始的类型的
绝佳例子。这个方法使用值接收者，并返回了一个新的 Time 值。该方法操作的是调用者
传入的 Time 值的副本，并且给调用者返回了一个方法内的 Time 值的副本。至于是使用返
回的值替换原来的 Time 值，还是创建一个新的 Time 变量来保存结果，是由调用者决定的
事情。 
大多数情况下，结构类型的本质并不是原始的，而是非原始的。这种情况下，对这个类型的
值做增加或者删除的操作应该更改值本身。当需要修改值本身时，在程序中其他地方，需要使用
指针来共享这个值。让我们看一个由标准库中实现的具有非原始本质的结构类型的例子，如代码
清单 5-31 所示。 
代码清单 5-31 golang.org/src/os/file_unix.go：第 15 行到第 29 行 
15 // File 表示一个打开的文件描述符 
16 type File struct { 
17 
*file
18 } 
19 
20 // file 是*File 的实际表示 
21 // 额外的一层结构保证没有哪个 os 的客户端 
22 // 能够覆盖这些数据。如果覆盖这些数据， 
23 // 可能在变量终结时关闭错误的文件描述符 
24 type file struct { 
25 
 fd int 
26 
 name string 
27 
 dirinfo *dirInfo // 除了目录结构，此字段为 nil 
28 
 nepipe int32 // Write 操作时遇到连续 EPIPE 的次数 
29 } 
可以在代码清单 5-31 里看到标准库中声明的 File 类型。这个类型的本质是非原始的。这
个类型的值实际上不能安全复制。对内部未公开的类型的注释，解释了不安全的原因。因为没有
方法阻止程序员进行复制，所以 File 类型的实现使用了一个嵌入的指针，指向一个未公开的类