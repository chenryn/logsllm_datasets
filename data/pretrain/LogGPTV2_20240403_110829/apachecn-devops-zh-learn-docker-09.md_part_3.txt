*   控制平面用于在集群的所有节点之间交换重要的状态信息。例如，这种信息用于更新集群上用于路由目的的本地 IP 表。
*   数据平面是应用服务相互通信和交换数据的地方。
通常，指挥人员主要关心管理和控制平面的安全。确保数据平面的安全是留给用户的，然而指挥者可以促进这项任务。
# 安全网络和网络策略
运行应用服务时，并非每个服务都需要与群集中的其他服务进行通信。因此，我们希望能够相互沙箱化服务，并且只在绝对需要相互通信的同一个网络沙箱中运行这些服务。所有其他服务和来自群集外部的所有网络流量都不应有可能访问沙盒服务。
这种基于网络的沙箱至少有两种方式。我们可以使用**软件定义的网络** ( **SDN** )来对应用服务进行分组，或者我们可以拥有一个平面网络，并使用网络策略来控制哪些人可以访问特定的服务或服务组，哪些人不可以。
# 基于角色的访问控制(RBAC)
除了安全之外，为了使 it 企业做好准备，协调者必须完成的最重要的任务之一是提供对集群及其资源的基于角色的访问。RBAC 定义了系统的主体、用户或用户组如何组织成团队等等，来访问和操作系统。它确保未经授权的人员不会对系统造成任何伤害，也不会看到系统中任何他们不应该知道或看到的可用资源。
A typical enterprise might have user groups such as Development, QA, and Prod, and each of those groups can have one to many users associated with it. John Doe, the developer, is a member of the Development group and, as such, can access resources dedicated to the development team, but he cannot access, for example, the resources of the Prod team, of which Ann Harbor is a member. She, in turn, cannot interfere with the Development team's resources.
实现 RBAC 的一种方式是通过**授权**的定义。授权是主体、角色和资源集合之间的关联。这里，角色由一组对资源的访问权限组成。这些权限可以是创建、停止、删除、列出或查看容器；部署新的应用服务；列出群集节点或查看群集节点的详细信息；还有更多。
资源集合是群集的一组逻辑相关的资源，如应用服务、机密、数据卷或容器。
# 机密
在日常生活中，我们有很多机密。机密是不打算公开的信息，比如你用来访问网上银行账户的用户名和密码组合，或者你手机或健身房储物柜的密码。
写软件的时候，我们也经常需要用到机密。例如，我们需要一些证书来用我们想要访问的一些外部服务来验证我们的应用服务，或者我们需要一个令牌来在访问一些其他 API 时验证和授权我们的服务。过去，为了方便起见，开发人员只是将这些值硬编码或者以明文形式放在一些外部配置文件中。在那里，这种非常敏感的信息已经被广大的观众接触到，而实际上他们根本没有机会看到这些机密。
幸运的是，如今，编排器提供了所谓的机密，以高度安全的方式处理如此敏感的信息。机密可以由授权或信任的人员创建。这些机密的值然后被加密并存储在高度可用的集群状态数据库中。这些机密，因为被加密了，现在在休息时是安全的。一旦授权的应用服务请求了一个机密，该机密只被转发给实际运行该特定服务实例的集群节点，并且该机密值从不存储在该节点上，而是装入基于`tmpfs`内存的卷中的容器中。只有在相应的容器中，机密值才以明文形式提供。
我们已经提到机密是安全的。一旦服务请求它们，集群管理器或主机就解密该机密，并通过线路将其发送到目标节点。*那么，在运输过程中保持安全的机密呢？*好的，我们之前了解到集群节点使用 MTLS 进行通信，因此虽然以明文形式传输，但该机密仍然是安全的，因为数据包将由 MTLS 加密。因此，机密在休息和运输中是安全的。只有被授权使用机密的服务才能访问这些机密值。
# 内容信任
为了增加安全性，我们希望确保只有受信任的映像才能在我们的生产集群中运行。一些编排者允许我们配置一个集群，这样它就只能运行签名映像。内容信任和映像签名都是为了确保映像的作者是我们期望的作者，即我们信任的开发人员，或者更好的是，我们信任的 CI 服务器。此外，有了内容信任，我们希望保证我们获得的映像是新鲜的，而不是旧的，可能是脆弱的映像。最后，我们希望确保映像在传输过程中不会被恶意黑客破坏。后者常被称为**中间人** ( **MITM** )攻击。
通过在源位置对映像进行签名并在目标位置验证签名，我们可以保证我们想要运行的映像不会受到损害。
# 反向正常运行时间
在安全性方面，我想讨论的最后一点是反向正常运行时间。我们这样说是什么意思？假设您已经配置并保护了一个生产集群。在这个集群上，您正在运行公司的一些关键任务应用。现在，一名黑客设法在您的一个软件栈中发现了一个安全漏洞，并获得了对您的一个集群节点的根访问权限。光是这一点就已经够糟糕的了，但更糟糕的是，这个黑客现在可以掩盖他们在这个节点上的存在，毕竟他们是机器的根，然后用它作为基地来攻击集群的其他节点。
Root access in Linux or any Unix-type operating system means that one can do anything on this system. It is the highest level of access that someone can have. In Windows, the equivalent role is that of an Administrator.
但是*如果我们利用容器短暂和集群节点快速配置的事实，如果完全自动化，通常在几分钟内完成，会怎么样？*我们只需在某个正常运行时间(比如 1 天)后杀死每个集群节点。指挥者被指示排出该节点，然后将其从集群中排除。一旦节点脱离群集，它就会被拆除，并由新调配的节点替换。
这样，黑客就失去了他们的基础，问题也就消除了。虽然这个概念还没有广泛应用，但对我来说，这似乎是朝着提高安全性迈出的一大步，就我与从事该领域工作的工程师讨论过的情况而言，实现起来并不困难。
# 反省
到目前为止，我们已经讨论了许多由指挥者负责的任务，并且它可以以完全自主的方式执行。但是也需要人工操作员能够看到和分析集群上当前运行的内容，以及各个应用的状态或运行状况。对于这一切，我们需要自省的可能性。指挥者需要以一种易于消费和理解的方式展现关键信息。
编排者应该从所有集群节点收集系统度量，并使操作员可以访问它。指标包括 CPU、内存和磁盘使用情况、网络带宽消耗等。这些信息应该很容易在每个节点的基础上获得，也可以以聚合的形式获得。
我们还希望编排者允许我们访问由服务实例或容器生成的日志。更重要的是，如果我们有正确的授权，指挥者应该为我们提供对每个容器的访问。有了`exec`对容器的访问，人们就可以调试行为不当的容器。
在高度分布式的应用中，对应用的每个请求都要经过许多服务，直到被完全处理，跟踪请求是一项非常重要的任务。理想情况下，指挥者支持我们实现跟踪策略，或者给我们一些好的指导方针。
最后，当操作人员使用所有收集的指标、日志和跟踪信息的图形表示时，他们可以最好地监控系统。这里，我们谈论的是仪表板。每一个优秀的指挥者都应该至少提供一些基本的仪表板，用图形表示最关键的系统参数。
但是人类操作员并不关心内省。我们还需要能够将外部系统与编排者连接起来，以使用这些信息。需要有一个可用的应用编程接口，外部系统可以通过该接口访问集群状态、指标和日志等数据，并使用这些信息做出自动决策，例如创建寻呼机或电话警报、发送电子邮件，或者在系统超过某些阈值时触发警报。
# 流行编排器概述
在撰写本文时，有许多编排引擎在使用。但是有几个明显的赢家。排名第一的位置显然由至高无上的 Kubernetes 斯占据。排在第二位的是 Docker 自己的 SwarmKit，其次是 Apache Mesos、AWS **弹性容器服务** ( **ECS** )或微软 **Azure 容器服务** ( **ACS** )等其他公司。
# KubernetesKubernetesKubernetesKubernetesKubernetesKubernetesKubernetesKubernetesKubernetesKubernetes
Kubernetes 最初由谷歌设计，后来捐赠给**云原生计算基金会** ( **CNCF** )。Kubernetes 是以谷歌专有的博格系统为模型的，该系统多年来一直在超大规模运行容器。Kubernetes 是谷歌试图回到画板上，完全重新开始，设计一个系统，将博格学到的所有经验都纳入其中。
与博格相反，博格是专有技术，Kubernetes 很早就开源了。这是谷歌非常明智的选择，因为它吸引了大量来自公司外部的贡献者，而且仅在几年时间里，围绕 Kubernetes 进化出了一个更庞大的生态系统。可以理直气壮地说，Kubernetes 是容器编排领域的社区宠儿。没有任何其他的编导能够制造如此多的宣传，吸引如此多的有才华的人愿意以一种有意义的方式作为贡献者或早期采用者为项目的成功做出贡献。
在这方面，容器编排空间中的 Kubernetes 在我看来非常像 Linux 在服务器操作系统空间中的样子。Linux 已经成为服务器操作系统事实上的标准。所有相关公司，如微软、IBM、亚马逊、红帽，甚至 Docker，都已经接受了 Kubernetes。
有一件事是不可否认的:Kubernetes 从一开始就是为了巨大的可扩展性而设计的。毕竟，它的设计是考虑到谷歌博格的。