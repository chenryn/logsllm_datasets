End VectorSpaceModuleSameGroup.
Authorized licensed use limited to: Tsinghua University. Downloaded on February 25,2022 at 12:14:48 UTC from IEEE Xplore.  Restrictions apply. 
1762
Module Type Mixable (Message Ciphertext : GroupSig)
(Ring: RingSig) (Field : FieldSig)
(VS : VectorSpaceSig Ciphertext Field)
(MVS: VectorSpaceModuleSameGroup Ciphertext Ring Field VS).
Import MVS.
Parameter KGR : Type.
Parameter PK : Type.
Definition M := Message.G.
Definition Mop := Message.Gdot.
Definition Mzero := Message.Gone.
Definition Minv := Message.Ginv.
Definition Mbool_eq := Message.Gbool_eq.
Parameter keygenMix : KGR -> PK. (* key generation
*)
Parameter enc : PK -> M -> Ring.F -> G. (* or commit *)
Axiom M_abgrp : AbeGroup M Mop Mzero Mbool_eq Minv.
Axiom homomorphism : forall (pk : PK)(m m’ : M)
(r r’ : Ring.F),
Ciphertext.Gdot (enc pk m’ r’)(enc pk m r) =
enc pk (Mop m m’) (Ring.Fadd r r’).
Axiom encOfOnePrec : forall (pk : PK)(a : Ring.F)(b :F),
VS.op (enc pk Mzero a) b = enc pk Mzero (op3 a b).
End Mixable.
Module Type EncryptionScheme (Group: GroupSig)
(Ring: RingSig) (Field: FieldSig)
(M: ModuleSig Group Ring) (VS: VectorSpaceSig Group Field)
(MVS: VectorSpaceModuleSameGroup Group Ring Field M VS)
 M -> bool.
: Type. (* randomness for keygen *)
: Type.
: Type.
: Set.
: M -> M -> M.
: M.
: M -> M.
(* public key space *)
(* secret key space *)
(* message space *)
Parameter keygen
Parameter enc
Parameter dec
Parameter keymatch: PK -> SK -> bool.
: KGR -> (PK*SK).
: PK -> M -> Ring.F -> G.
: SK -> G -> M.
Axiom correct: forall (kgr: KGR) (m: M) (r: Ring.F),
let (pk, sk) := keygen kgr in
dec sk (enc pk m r) = m.
Axiom M_abgrp: AbeGroup M Mop Mzero Mbool_eq Minv.
Axiom homomorphism: forall (pk : PK) (m m’ : M)
(r r’ : Ring.F),
Group.Gdot (enc pk m’ r’) (enc pk m r) =
enc pk (Mop m m’) (Ring.Fadd r r’).
Axiom encOfOnePrec: forall (pk : PK)(a : Ring.F)(b :F),
VS.op (enc pk zero a) b = enc pk zero (op3 a b).
End EncryptionScheme.
Definition reenc (pk: PK) (c: G) (r: Ring.F): G :=
Group.Gdot (enc pk Mzero r) c.
Definition IsReEnc (pk : PK)(c1 c2 : G)(r : F) : Prop :=
c2 = reenc pk c1 r.
Definition relComEPC (h: G) (hs: VG (1+N)) (c: G)
(m1 m2: VF (1+N))(r1 r2 : F) :=
m1 <> m2 /\
c = (EPC (1+N) h hs m1 r1) /\
c = (EPC (1+N) h hs m2 r2).
Definition relPi (h: G) (hs: VG (1+N)) (c: VG (1+N))
(m: MF (1+N)) (r: VF (1+N)) :=
MFisPermutation m
/\ c = (com (1+N) h hs m r).
(* Definition of shuffling *) (*e2_i = e1_p_i * r_p_i*)
Definition relReEnc(pk: enc.PK) (e e’: vector G1.G (1+N))
(m : MoC.MF (1+N)) (r: MoC_M.VF (1+N)) :=
let e’’ := MoC.PexpMatrix e’ m in
let r’’ := RF_CVmult m r in
let partial := Vmap2 (fun e e’ => IsReEnc pk e e’)
e e’’ in
let partial2 := Vmap2 (fun x y => x y) partial r’’ in
Vforall (fun x => x ) partial2.
Module BasicElGamal (Group: GroupSig) (Field: FieldSig)
(VS: VectorSpaceSig Group Field)
(DualGroup: DualGroupSig Group)
(DVS: DualVectorSpaceSig Group DualGroup Field VS)
(MVS: VectorSpaceModuleSameGroupIns DualGroup Field DVS)
 (x, VS.op x y)) kgr.1 kgr.2, kgr.2).
Definition enc (Pk: PK)(m : M) (r: MoM.VF N):
NthGroup.G :=
let mr := Vmap2 (fun x y => (x,y)) m r in
Vmap2 (fun (pk :DualGroup.G)(mr : (Group.G*F)) =>
(VS.op pk.1 mr.2, Group.Gdot (VS.op pk.2 mr.2) mr.1))
Pk mr.
Definition dec (Sk : SK)(C : NthGroup.G) : M :=
Vmap2 (fun sk c => Group.Gdot c.2 (Group.Ginv
(VS.op c.1 sk))) Sk C.
Definition keymatch (Pk : PK)(Sk : SK) : bool :=
MoM.VG_eq (Vmap2 (fun pk sk => VS.op pk.1 sk) Pk Sk)
(Vmap (fun x => x.1) Pk).
(* We have redacted the proofs *)
End ExtendedElGamal.
APPENDIX C
PRIVACY OF THE MIX NET
There are numerous way to deﬁne the privacy of a mix net.
One primary distinction is whether or not the decryption of
the ciphertexts is modeled; we ﬁrst address the case where it
is not modeled and then comment on the other case at the end.
ΣP K
For the purpose of this paper we will adopt the notion
of chosen permutation indistinguishability (IND-CPAS) from
[66] which we have recast into concrete security. This notation
is for a veriﬁable shufﬂe which a pair (Σ, S, (P,V)) where Σ is
an encryption scheme (for our purpose as deﬁned in deﬁnition
3), S is a shufﬂe, and (P,V) is a proof system which proves
(P K, e, e(cid:3) ∈ Rshuf
).
Note that due to the soundness of all mixes, we can express
the ﬁnal output vector of ciphertexts as a function of the
composition of the respective permutations and randomness
vectors of the mixers; even if we ﬁx the inputs of all but one
mixer every possible cumulative permutation and vector is still
possible (for the class of encryption schemes we consider).
Hence, it sufﬁces to show that only negligible information
about the permutation used by the honest mixer leaks and
hence we let S be the mix of the mix server who by assumption
is honest.
Deﬁnition 4. A shufﬂe (Σ, S)
is said to provide (t, )
Indistinguishability under Chosen Permutation Attack
(IND-CPAS) if for every t time adversary A the advantage of
A
(Σ, S)
ExpIND-CPAS−b
(P K, SK) ←r Σ.KeyGen
(π1, π2, e) ←r A(P K)
e(cid:2) ←r S(P K, πb, e)
b ←r A(e(cid:2))
return b = b(cid:2)
Fig. 1.
IND-CPAS experiment
ind−cpa−b
A
(1κ)
Exp
(P K, SK) ←r Σ.KeyGen
(m0, m1) ←r A(P K)
r ←r RP K
c ← Σ.EncP K (mb, r)
b ←r A(c)
return b = b(cid:2)
Fig. 2.
IND-CPA experiment
A
A in ExpIND-CPAS
(Σ, S) (Fig. 1) is at most . For simplicity
we will often drop t and  and refer to (Σ, S) as being
(IND-CPAS) secure.
Deﬁnition 5. We say an encryption scheme Σ is (t, ) IND-
CPA secure if no t-time algorithm A has advantage at least
 in Advind−cpa(A, κ) (Fig. 2). For simplicity we will often
drop t and  and refer to Σ as being IND-CPA secure.
Theorem 2. (Σ, S, (P,V)) is IND-CPAS if the encryption
scheme Σ, satisfying deﬁnition 3), is IND-CPA.
Proof sketch. For simplicity we will consider a variant of
IND-CPA where the the adversary is allowed polynomially
many challenge message pairs and receives either the en-
cryption of all the left messages or all the right messages
(called poly-IND-CPA), any IND-CPA secure scheme is also
poly-IND-CPA. We note in passing that for ElGamal, and the
other encryption schemes we use in practice, a much tighter
security proof is possible which is independent of the number
of ciphertexts being mixed.
The challenger receives (π1, π2, e) from the adversary A.
Let n be the number of ciphertexts in e, the challenger chooses
{mi ←r M}n
i=1 to the poly-IND-CPA
challenger and receives back the ciphertexts c. The challenger
then chooses b ←r {0, 1} and forms e(cid:3) as {ci ∗ eπb(i)}n
i=1,
which it then passes to A. The adversary then returns its guess
(cid:3), if the guess is correct then the simulator returns 0 otherwise
b
it returns 1.
i=1 and sends {0, mi}n
The simulation is perfect when the IND-CPA challenge is
0 but completely random when the challenge is 1, hence the
advantage of the challenger against poly-IND-CPA is at least
half of the advantage of A against IND-CPAS.
Authorized licensed use limited to: Tsinghua University. Downloaded on February 25,2022 at 12:14:48 UTC from IEEE Xplore.  Restrictions apply. 
1764
A. Considering decryption.
We do not give a formal deﬁnition of privacy for the
case considering decryption but several can be found in the
literature [26], [27]. The intuitions of the deﬁnitions is that the
adversary gets to choose the possible messages (m1, m2) of
the honest senders but is constrained that the set of messages
must be equal. In addition it is allowed to add ciphertexts of
its own.
If the mix net is IND-CPAS then any permutation is possible
in the output of the ciphertext and hence in the decryption
so it sufﬁces to know the set of messages underlying the
submitted ciphertexts. Since the set of messages is the same
irrespective of the challenge for the honest senders that part
is trivial. However, the ciphertexts submitted by the adversary
are harder to deal with. Normally, this is dealt with by proofs
of knowledge on the submitted ciphertexts or by requiring the
encryption is IND-1CCA-Poly [54] or stronger.
Authorized licensed use limited to: Tsinghua University. Downloaded on February 25,2022 at 12:14:48 UTC from IEEE Xplore.  Restrictions apply. 
1765