D
}ai∈U\{ρ(k)}, where rk and
k, {D
′
gur
′
k are randomly selected and secretly held by the TA, and
r
they are distinct for each DUs. Under this setting, if DUs try
to rebuild a valid novel outsourcing key, they would have
′
no choice but to penetrate the TA to reveal rk and r
k for each
of them. Therefore, these DUs cannot decrypt the ciphertext
CT by directly combining their outsourcing key and user
secret key.
′
1,k = (D1,k)u = guλ(cid:26)(k) (t0tρ(k))urk, D
′
3,k,i = (D3,k,i)u = turk
′
6,k,i = (D6,k,i)u = tur
′
k, D
i
′
k
i
6.5 Trapdoor privacy and unlinkability
In the LABSE scheme, the trapdoor component T0 that
involves the query q is parsed as T0 = gα(β−u) · H(q),
and the remainder components derive from the outsourcing
key, they are all masked by the user secret key U SK = u.
That is, we hide the DU’s queried keyword q with the hash
function H(·), and blind the hash value H(q) with u. In this
way, we prevent the honest-but-curious CSP from revealing
any information about the query q. Furthermore, the CSP
cannot distinguish the relationship between two trapdoors
which generated by different DUs, even if they correspond
′
to the same queried keyword, since the value of u and r
k
are vary for different DUs. Therefore, the proposed LABSE
scheme satisﬁes the requirement of trapdoor privacy and
unlinkability.
8
7 THE DEPLOYMENT OF LABSE IN IOT-ASSISTED
SMART HEALTHCARE SYSTEM
In this section, we describes a deployment model of the
proposed LABSE scheme. As illustrated in Fig. 3, this model
involves four kinds of entities, including the healthcare
administration center (HAC), the healthcare cloud service
provider (HCSP), the implantable/wearable sensor in the
patient side and the mobile terminal device in the doctor
side. The HAC is responsible for creating and monitoring
the system, it also assigns to the doctor side the access
structure, the outsourcing key and user secret key according
to its service requirement. The HCSP is used to store the
ciphertext, it also provides the service of ciphertext retrieval
and transformation. The implantable/wearable sensor acts
as a data owner, it periodically collects the health data
from the patient, then encrypts the health data and u-
ploads the ciphertext to the HCSP. The mobile terminal
device acts as the data user, it queries and decrypts the
desired ciphertext with lightweight operations under the
assisted of the HCSP. In addition, considering the ciphertext
and transformed ciphertext may suffer from the threat of
tampering and forgery during transmission, we design to
provide a lightweight and an anonymous authentication
mechanism [34, 35] based on the ECDSA signature scheme
[36] and the group signature without pairing scheme [37],
respectively. For simplicity, we denote by ECDSA.Keygen,
ECDSA.Sign and ECDSA.Verify the algorithms of ECDSA
key pair generation, ECDSA signature generation and ECDSA
signature veriﬁcation in [36], respectively.
Fig. 3: The deployment of LABSE scheme in the IoT-assisted
smart healthcare system
As illustrated in Fig. 3, this system consists of four
phases, including system initialization, key distribution,
data upload and data access. Speciﬁcally, we deﬁne the
interactions in each phases as follows.
Phase 1. system initialization: This phase is described
as Fig. 4-(a).
1-1: The HAC obtains the public parameter and master
secret key by running M P K, M SK ← Setup(1ζ), the HAC
2327-4662 (c) 2021 IEEE. Personal use is permitted, but republication/redistribution requires IEEE permission. See http://www.ieee.org/publications_standards/publications/rights/index.html for more information.
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 12:21:45 UTC from IEEE Xplore.  Restrictions apply. 
This article has been accepted for publication in a future issue of this journal, but has not been fully edited. Content may change prior to final publication. Citation information: DOI 10.1109/JIOT.2021.3063846, IEEE Internet of
Things Journal
IEEE, VOL., NO.,
9
(a) System initialization
(b) Key distribution
(c) Data upload
(d) Data access
Fig. 4: Four interactive phases in the IoT-assisted smart healthcare system
also runs the algorithm GS.System-Setup in [37] to generate
the group signature public parameter GK. Then HAC keeps
secret the master secret key M SK, and publishes the public
parameter M P K and GK.
1-2: The implantable/wearable sensor in the patient
side runs GS.Generate-Key algorithm in [37] to gen-
erate its public/private key pair (pkl, skl), then it pub-
lishes its public key pkl to the HCSP. The HAC runs
the GS.Group-Setup algorithm of [37] to generate the
group private key skg and forwards it to the HCSP via
secure channel. The HAC also generates and publishes
the group public key pkg for the HCSP and each patient
side implantable/wearable sensor.
1-3: The HCSP generates its ECDSA signing key xh
and the ECDSA corresponding veriﬁcation key Xh
by running the ECDSA.KeyGen algorithm. Then the
HCSP broadcasts the ECDSA veriﬁcation key Xh to the
doctor side.
Phase 2. key distribution: This phase is divided into
the following steps as described in Fig. 4-(b).
2-1: The HAC assigns an access structure (M, ρ) to
the mobile terminal device according to the service
requirement of doctor side.
2-2: The HAC generates the secret key SK(M,ρ) as-
sociated with the speciﬁed access structure (M, ρ) by
running SK(M,ρ) ← SKGen(M P K, M SK, (M, ρ)).
2-3: The HAC generates the outsourcing key and us-
er secret key by running OSK(M,ρ), U SK = u ←
OSKGen(M P K, M SK, SK(M,ρ)). Then the HAC for-
wards the outsourcing key OSK(M,ρ) and the user
secret key U SK to the mobile terminal device via the
secure channel.
2-4: The patient side implantable/wearble sensor runs
GS.Join-User [37] to generate the group member pri-
vate key cskl.
Phase 3. Data upload: As illustrated in Fig. 4-(c), the
wearable/implantable sensor in the patient side collects the
health data and uploads the encrypted data to the HCSP in
the following steps.
3-1: The wearable/implantable sensor in the patient
side runs the OffEnc algorithm to generate the inter-
mediate ciphertext CT
3-2: The wearable/implantable sensor in the patient
side with attribute set W in the patient side periodically
collects the real-time health data M sg from the patient.
′ ← OffEnc(M P K).
′
, M sg, W, w, M P K),
3-3: The wearable/implantable sensor with attribute
set W runs the OnEnc algorithm to generate the ci-
phertext CT ← OnEnc(CT
it
also generates the signature of ciphertext by running
σCT ← GS.Sign(cskl, CT||t1) [37], where t1 denotes
the current timestamp. Then the wearable/implantable
sensor uploads the tuple (CT, σCT , t1) to the HCSP.
3-4: Upon receiving the tuple (CT, σCT , t1) from a
wearable/implantable sensor, the HCSP ﬁrst inspects
the freshness of the tuple by checking whether the
equation |t − t1| ≥ ∆t holds. If so, HCSP aborts
the tuple (CT, σCT , t1), where |∆t| is deﬁned as the
freshness threshold. Otherwise, if the equation holds,
the HCSP checks the validity of the signature σCT by
running GS.Verify(σCT , GK) [37]. If σCT is valid, the
HCSP accepts and stores it, and aborts it for otherwise.
Phase 4. Data access: The mobile terminal device in
the doctor side interacts with the HCSP to recover the data
plaintext M sg in the following steps as illustrated in Fig.
4-(d).
its desired keyword,
4-1: The mobile terminal device in the doctor side
selects a query q of
then it
generates the trapdoor of the query q by running
T D ← TrapGen(M P K, q, OSK), generates the trans-
formation key by running T K ← TKGen(OSKM,ρ).
Subsequently, the mobile terminal device forwards the
tuple (T D, T K) to the HCSP via the secure channel.
4-2: On receiving the tuple (T D, T K), the HCSP re-
trieves the desired ciphertext CT by running CT ←
Search(T D, M P K, CT ). Then the HCSP generates the
transformed ciphertext about the ciphertext CT by
running K ← Transform(CT, T K).
4-3: The HCSP separates the ciphertext tuple and picks
the ciphertext component C1, then it performs σK ←
ECDSA.Sign(K||C1||t2, xh, t2), and returns the tuple
(K, C1, σK, t2) to the mobile terminal device in the
doctor side.
4-4: Upon receiving the tuple (K, C1, σK, t2), the mo-
bile terminal device in the doctor side ﬁrst checks
whether the equation |t − t2| ≥ ∆t holds, if so, the
mobile terminal device aborts the tuple. Otherwise, if
the equation is not satisﬁed, then the mobile termi-
nal device checks whether the signature is valid by
executing ECDSA.Verify(Xh, σK). If (K, C1, σK, t2) is
valid, the mobile terminal device accepts the tuple
2327-4662 (c) 2021 IEEE. Personal use is permitted, but republication/redistribution requires IEEE permission. See http://www.ieee.org/publications_standards/publications/rights/index.html for more information.
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 12:21:45 UTC from IEEE Xplore.  Restrictions apply. 
This article has been accepted for publication in a future issue of this journal, but has not been fully edited. Content may change prior to final publication. Citation information: DOI 10.1109/JIOT.2021.3063846, IEEE Internet of
Things Journal
IEEE, VOL., NO.,
(K, C1, σK, t2), and rejects it for otherwise.
4-5: The mobile terminal device in the doctor side
recover the data plaintext by performing M sg ←
Decrypt(C1, K, U SK).
Remark. Considering the privacy issue of the patient,
this deployment model realizes the authentication in the
Data upload phase with the group signature scheme [37],
in which way the HCSP is only convinced that the signature
is generated by a patient side sensor in the group of valid
patient side implantable/wearable sensors, but it is hard to
explore which speciﬁc patient the data and the signature
come from. Off course, the HAC reserves a trick, it runs the
GS.Trace-User [37] algorithm to trace the speciﬁc identity of
the patient who are misbehave (for example, a sensor which
is reported to be corrupted or frequently forward deceptive
data). Then the HAC would revoke the patient by running
the GS.Revoke-User [37] algorithm, or append the patient
to a blacklist.
8 PERFORMANCE ANALYSIS
We compare the proposed LABSE scheme with the
state-of-art three related schemes (including Wang et al.’s
SFGEKS scheme [40], the second scheme OO-KP-ABKS in
Cui et al.’s work [38] and Miao et al.’s SODSF scheme [41])
in terms of functionality and complexity. In addition, we
implement these schemes to evaluate and compare their
practical performance.
8.1 theoretical comparisons and analysis
TABLE 2: Comparisons on functionality
OO-KP-ABKS[38]
NM
Schemes
AS
KP/CP
HA
AND-Gate
SFGEKS[40]
OOE LE OD LT
n-DBDH (cid:2) (cid:2) (cid:2) (cid:2)
X (cid:2) X X
n-DBDH X (cid:2) X (cid:2)
n-DBDH X X X X
Notations: AS: access structure; KP/CP: KP-ABE or CP-ABE; HA:
LSSS
LSSS
LSSS
CP
KP
CP
KP
SODSF[41]
LABSE
hardness assumption; OOE: online/ofﬂine encryption; LE: lightweight
encryption; OD: outsourced decryption; LT: lightweight trapdoor
generation; X: satisﬁes; (cid:2): not satisﬁes; NM: not mentioned.
We describe the comparison on the above four schemes
in terms of the functionality in TABLE 2. As illustrated in the
table, SFGEKS [40] only realizes the access policy of AND-
Gate, while the rest three schemes can provide the expres-
sion of multiple access policies by the LSSS access structure.
Our LABSE scheme and OO-KP-ABKS [38] scheme are
constructed based on KP-ABE scheme, while SFGEKS [40]
and SODSF [41] are categorized as CP-ABE scheme. For the
hardness assumption, OO-KP-ABKS [38] does not provide
the formalized security proof, while the remainder three
schemes reduce the indistinguishability under the chosen
plaintext/keyword attack to the n-DBDH assumption. With
regard to the computational efﬁciency, OO-KP-ABKS [38].
SODSF [41] and our LABSE schemes enable the patient
side to precompute the necessary components of ciphertext
during the ofﬂine phase, it then generates the ciphertext
with a few computations during the online phase. However,
only our LABSE scheme realizes lightweight encryption for
10
the patient side. We can also observe that all schemes except
SFGEKS [40] alleviate the decryption overheads by using
the trick of outsourced decryption [42]. Furthermore, OO-
KP-ABKS [38] and LABSE [41] provide lightweight trap-
door generation, while in SFGEKS [40] and SODSF [41], it
requires heavy computational overheads for the doctor side
to generate the trapdoor.
TABLE 3 reﬂects the comparison on the complexity
among the above four schemes. Theoretically, the LAB-
SE and OO-KP-ABKS [38] schemes are unsatisfactory in
terms of the length and computational complexity of the
secret key. In particular, the length and the computational
complexity of the secret key in our LABSE scheme reach
(6n + 1)|G| + |Zp| and (7n + 1)eG respectively. However,
LABSE outperforms other schemes in terms of the ciphertext
size and encrypting complexity, they reach 2|G|+2|GT| and
P+2eG+2eGT +H respectively, that is, they are independent
of the number of attributes. By contrast, both OO-KP-ABKS
[38] and SODSF [41] are required to spend expensive com-
putational resources to generate the ciphertext components
about all possible attributes. In respect to the trapdoor, we
can see that OO-KP-ABKS [38] and LABSE occupy a large
storage space, but our LABSE scheme can generate a valid
trapdoor under the complexity of only mG + H.
8.2 Experimental results
We implement our proposed LABSE scheme along with
the above-mentioned three state-of-art related works with
the support of PBC-0.5.14 library [45] to evaluate and com-
pare their practical performance. We simulate the trusted
server and the CSP by a powerful personal computer with
Intel(R) Core(TM) i7-9700 CPU 3.00 GHz, 16GB RAM and
windows 10 64 bits OS. To evaluate the practical perfor-
mance of resource-constrained devices in these schemes,
we simulate the wearable/implantable sensor in the patient
side and the mobile terminal device in the doctor side
by the microcomputer Raspberry Pi model 3B+ equipped
with BCM2837B0 CPU 1.40GHz, 1GB RAM, Raspbian OS
and the 2.4/5 GHZ-enabled WLAN card under IEEE 802.11
standard. We implement this experiment on a 160-bit el-
liptic curve group constructed on the Type-A elliptic curve
E/Fq : y2 = x3 + x deﬁned over the 512-bit ﬁnite ﬁeld Fq,
and the bilinear pairing p is instantiated by the Tate pairing
[46]. Then we obtain |G| = |GT| = 1024 bits and |Zp| = 160
bits. In addition, in this experiment, we set the maximum
number of rows in the access structure to be P = 50, and
the number of keywords in the keyword dictionary is set as
W = 20. To evaluate the effect on the experimental results
by the number of attributes, we set the number of attributes
slides from 10 to 50 at the interval of 10.
Fig. 5 pictorially illustrates the experimental results. In
Fig. 5-(a), it can be observed that the length of secret key in
our LABSE scheme increases with the number of attributes,
and it occupies more storage space than the remainder
schemes. We can observe from Fig. 5-(b) the computational
time cost of LABSE grows with the number of attributes,
it is more expensive than that of SFGEKS [40], but low-
er than OO-KP-ABKS [38]. But fortunately, in our LABSE
scheme, the secret key is designed to generated by the
powerful server (speciﬁcally, in our experiment platform,
2327-4662 (c) 2021 IEEE. Personal use is permitted, but republication/redistribution requires IEEE permission. See http://www.ieee.org/publications_standards/publications/rights/index.html for more information.
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 12:21:45 UTC from IEEE Xplore.  Restrictions apply. 
This article has been accepted for publication in a future issue of this journal, but has not been fully edited. Content may change prior to final publication. Citation information: DOI 10.1109/JIOT.2021.3063846, IEEE Internet of
Things Journal
IEEE, VOL., NO.,
Schemes
SFGEKS[40]
TABLE 3: Comparisons on complexity
11
Cost.Trap
Len.Key
2jGj+jZpj