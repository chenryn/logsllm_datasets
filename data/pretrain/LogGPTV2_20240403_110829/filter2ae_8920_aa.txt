接上一篇   https://xz.aliyun.com/t/2841
## 找到RTF的token参数解析器
此时，我们仍然应该在“sub_431D38”之内。 虽然我们可以对照（Ctrl +
X）指向我们在此处分配的token数组的一些指针，并最终获得处理我们的令牌及其参数的函数，但这里存在一种更简单的方法。
我们可以为数据库中的每个函数标记所有开关。 在我们处理它时，让我们计算每个开关的样例数量，这样我们就可以快速查询具有最多案例的函数。
我们可以使用`function.switches（）`来枚举函数中的所有开关。 这允许我们遍历函数中定义的所有开关，并返回IDA-minsc的`switch_t`实例，我们可以使用它来计算非默认事例的总数。 为此，我们首先定义一个函数，而该函数将标记开关的数量和函数事例总数。
    Python>def tag_switches(ea):
    Python>    count, total = 0, 0
    Python>    for sw in func.switches(ea):
    Python>        count += 1
    Python>        total += len(sw.cases)
    Python>    if count > 0:
    Python>        func.tag(ea, 'switch.count', count)
    Python>        func.tag(ea, 'switch.cases', total)
    Python>    return
现在我们已经定义了一个函数。它可以标记IDA数据库中的函数，标签“switch.count”表示开关数，“switch.cases”表示案例总数，我们可以将其应用于每个函数数据库，以便我们以后可以查询。
让我们使用`database.functions（）`通过以下方法遍历所有函数：
    Python>for ea in db.functions():
    Python>    tag_switches(ea)
这可能需要一段时间，因此如果我们能够看到当前的进展，那将会对我们的工作更有帮助。 IDA-minsc在我们可以使用的“工具”模块中提供了一个工具。
该工具是是以callable作为参数的`tools.map`。 如果我们愿意使用此功能，我们可以使用以下内容：
    Python>_ = tools.map(tag_switches)
既然我们将每个函数都标记为开关，我们就可以查询整个数据库以便对它们进行排序。
虽然我们可以使用Python的`sorted`函数中的“key”关键字，但我们只是管理我们的查询结果，以便第一个条目是属于每个函数的开关总数。
之后，我们将使用`sorted`对它们进行排序，然后查看应该具有最多情况的元素。
    Python>results = []
    Python>for ea, tags in db.select('switch.cases'):
    Python>    results.append( (tags['switch.cases'], ea) )
    Python>
    Python>results = sorted(results)
    Python>len(results)
    162
现在我们已经有了具有最多开关的函数的排序列表，我们可以查看最后一个元素以便找到我们所需要的内容。 让我们从最后一个结果中提取地址，然后导航到它（图6）。
    Python>results[-1]
    (294, 5797552)
    Python>_, ea = results[-1]
    Python>go(ea)
看起来我们很幸运，发现了一些看起来像解析器的东西或者真的是一个带有许多案例开关的标记器。
让我们通过调用`function.tag（）`来仔细检查我们的开关数。
    Python>print func.tag('switch.count')
    1
这里似乎只有一个开关。 让我们分析我们的开关，这样我们就可以看到它有什么样的情况。 为此，请单击其主分支的地址0x5876d1。
现在它被选中了，我们不需要将地址传递给`database.get.switch（）`而是让它使用当前地址。 我们将它存储到“sw”变量中。
    Python>sw = db.get.switch()
    Python>sw
     default:*0x58af5c branch[456]:*0x5876d8 register:edx
让我们看看这个开关中有多少个案例和默认情况。 我们将通过获取其总长度并减去其有效案例的长度来计算默认案例的数量。
    Python>print 'number of cases:', len(sw)
    number of cases: 456
    Python>print 'number of default cases:', len(sw) - len(sw.cases)
    number of default cases: 162
为了使我们更容易识别与特定案例相关联的token，我们可以使用存储在“token”列表中的内容简单地标记每个案例。
可用案例列表位于“sw”变量的“cases”属性中。 我们可以简单地调用它的`.case（）`方法来获取处理特定情况的程序。
我们将使用这些属性来标记每个处理程序，其中包含我们在上面分配的“token”列表中的“token”标记。
    Python>for case in sw.cases:
    Python>    handler = sw.case(case)
    Python>    db.tag(handler, 'token', tokens[case])
然而，每种情况都可以处理多个令牌是一种问题。 这需要我们关注每个处理程序的案例。 为此，我们可以使用我们分配的“sw”变量的“handler”方法。
我们将使用“function.select”来选择我们已经标记过的所有处理程序，然后重新标记程序。
虽然`function.select（）`以函数地址作为参数，但由于我们要查询当前函数，因此它的地址已不在需要。
    Python>for ea, tags in func.select('token'):
    Python>    toks = []
    Python>    for case in sw.handler(ea):
    Python>        toks.append( tokens[case] )
    Python>    db.tag(ea, 'token', toks)
这导致每个案例处理的token列表被标记为“token”。
如果我们需要再次找到处理程序或每个案例处理的token，我们可以再次使用`function.select`来获取它们。
在图7中，情况66,68,69,183和427的处理程序具有多个token值。  
为了找到第一个调用指令，接下来我们要做的是遍历我们用“token”所标记过的每个地址。
我们还将寻找无条件分支。倘若我们成功找到了无条件分支，那么处理程序则被调用完成并在开关外部产生分支。 我们将使用“指令”模块去识别无条件分支或调用指令。
这个模块包含函数`instruction.is_jmp`和`instruction.is_call`。
我们将使用带有断言机制的`database.address.next`变量去找到与其中一个相匹配的“下一条”指令。
虽然这并不能产生100％准确的结果，但我们稍后会手动完成此操作。
因此在这种情况下准确性并不太重要。让我们使用`function.select`查询我们的处理程序，然后使用标记名“rtf-parameter”将处理程序的地址标记为其第一个调用指令。
    Python>for ea, tags in func.select('token'):
    Python>    next_call = db.a.next(ea, lambda ea: ins.is_jmp(ea) or ins.is_call(ea))
    Python>    if ins.is_call(next_call):
    Python>        db.tag(ea, 'rtf-parameter', ins.op(next_call, 0))
    Python>    elif ins.is_jmp(next_call):
    Python>        print "found an unconditional branch with the target: {:x}".format(ins.op(next_call, 0))
    Python>    continue
我们在这里列出了一些对我们来说并不重要的无条件分支。 因此，让我们查询那些被标记为第一个调用指令结果。
    Python>found = set()
    Python>for ea, tags in func.select('rtf-parameter'):
    Python>    found.add(tags['rtf-parameter'])
    Python>
    Python>found
    set([4397600, 6556480, 4226632, 5797484, 5797008, 4226316, 4226640, 4397688, 5797216, 4226452, 5796288, 5797400, 5767988, 6487132])
不幸的是，这些数字没有很大用处。所以为了方便我们点击它们，让我们将它们映射为名称。
    Python>map(func.name, found)
    ['sub_431A20', 'sub_640B40', 'sub_407E48', 'sub_58766C', 'sub_587490', 'sub_407D0C', 'sub_407E50', 'sub_431A78', 'sub_587560', 'sub_407D94', 'sub_5871C0', 'sub_587618', 'sub_580334', 'sub_62FC5C']
手动完成每个操作并快速查找显示的内容后，我们将结果总结如下：
    sub_431A20 — looks like it does something with numbers and a hyphen, probably a range?
    sub_640B40 — no idea what this is
    sub_407E48 — fetches some property from an object and doesn't call anything
    sub_58766C — looks too complex for me to care about
    sub_587490 — looks too complex for me to care about
    sub_407D0C — fetches some property from an array using an index
    sub_407E50 — fetches some property from an array using an index
    sub_431A78 — calls two functions, first one does something with spaces second one is the first in this list which does stuff with numbers and a hyphen
    sub_587560 — looks complex, but calls some string-related stuff
    sub_407D94 — calls a function that does some allocation, probably allocating for a list
    sub_5871C0 — references a few characters that look rtf specific like a "{", backslash "\" and a single quote
    sub_587618 — calls a couple functions that are currently in this list
    sub_580334 — calls a couple functions that are currently in this list
    sub_62FC5C — looks like it resizes some object of some kind
回过头来看一下这些注释，sub_431A20，sub_431A78，sub_5871C0和sub_587618似乎与解析相关。
我们将这个函数列表转换回地址。 这样我们就可以将它们存储在一个集合中，看看我们交换机的哪些案例正在使用它们。
首先，我们将使用`function.address（）`将函数名称转换回地址。
    Python>res = map(func.address, ['sub_431A20', 'sub_431A78', 'sub_5871c0', 'sub_587618'])
    Python>match = set(res)
现在我们有一个匹配的集合。现在让我们收集所有的实例以及其调用的“rtf-parameter”方法。 我们还将其输出，以便我们可以单独访问它们。
    Python>cases = []
    Python>for ea, tags in func.select('rtf-parameter'):