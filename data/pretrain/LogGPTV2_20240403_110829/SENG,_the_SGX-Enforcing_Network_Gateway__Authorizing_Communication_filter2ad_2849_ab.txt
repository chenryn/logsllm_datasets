, no:
Perimeter Firewalls with Host Information. Perimeter
ﬁrewalls with client-side sensors are most related to SENG.
However, they fail to provide reliable trafﬁc-to-app attribution
(Attr:
), which is our central design goal. Host sensors like
the Cisco Network Visibility Module (NVM) [11] focus on
ﬁrewall augmentation with per-ﬂow host data, including app
identiﬁers (e.g., hash of binary, process name). Unfortunately,
malware can easily bypass such loose, static identiﬁers by
injection into benign processes [4]. Furthermore, a system-
level attacker can completely subvert host sensors such as
NVM, as they fully rely on the OS. SOCKS [52] proxies and
VPN [15] services also control trafﬁc centrally, but, similarly,
they cannot reliably link trafﬁc to its applications.
Isolation-Based Trafﬁc Auditing. Assayer [43] uses a
client-side hypervisor to augment app-level data of outbound
client trafﬁc with trafﬁc statistics and signs it (C+I:
).
,TA:
USENIX Association
29th USENIX Security Symposium    755
Trusted GWExternal ClientEnterprise NetworkExternal Network (Internet)Untrusted ClientsSENGInternal ServersSENGUntrusted Client SubnetworkDMZ / Trusted Server SubnetExternal ServersMITMMITM:trusted:untrustedSENG ServerComponents at...
Client, Gateway
Client, Gateway
Client, MBox, Srv
Cli/Srv, MBox, Gw
Client, Gateway
Project
SENG
NVM et al.
Assayer
Alcatraz
EndBox
iptables MAC Client
Client
ClipOS
QubesOS
Client
Gateway, MBox
SafeBricks
LightBox
Gateway, MBox
Trust in...
OS VMM CPU
(cid:88)
no
(cid:88)
yes
(cid:88)
no
(cid:88)
no
(cid:88)
no
(cid:88)
yes
(cid:88)
yes
(cid:88)
no*
(cid:88)
yes
(cid:88)
yes
no
-
yes
no
no
-
-
yes
yes
yes
Attackers
Syscli, mitm
MWuser
Syscli, mitm
Syscli+mbox, mitm
Syscli, mitm
MWuser
MWuser, mitm
Syscli, mitm
Sysmbox, mitm
Sysmbox, mitm
Central?
(SR2/3)
C+I
(SR4)
TA
(SR5)
Attr
(SR6)
¬IL
yes
yes
yes
yes
yes
no
no
no
yes
yes
-
-
-
-
-
-
-
-
-
-
Table 1: Related work grouped into perimeter ﬁrewalls with host sensors, host-level ﬁrewalls, and secure middleboxes. Assess-
ments follow the metrics, symbols and acronyms outlined in Section 3. (*note: QubesOS trusts OS of admin dom0, though)
compatible with existing gateway ﬁrewalls.
SGX-Protected Middlebox Outsourcing. Projects such
as SafeBricks [45], LightBox [16] and ShieldBox [57] use
SGX to protect middlebox services from untrusted cloud or
middlebox providers. The approaches mostly differ w.r.t. the
focus and implementation. SafeBricks, for instance, uses
language-based methods to enforce least privilege on third
party middlebox functions and isolation across chained func-
tions, while LightBox [16] focuses on support for stateful
full-stack middlebox functions and high-performance. Gkant-
sidis et al. [21] additionally propose a middlebox-aware TLS
variant (mbTLS) for secure inspection of encrypted client
trafﬁc. In contrast to our threat model, these projects trust
the client hosts, and thus fail to provide app-to-trafﬁc attri-
bution (Attr:-) and to mitigate information leakage (¬IL:-).
The middleboxes can directly beneﬁt from our desired trafﬁc
attribution, as they integrate easily (cf. AR3 in Section 5.1).
4 Background
Intel SGX and Remote Attestation. TEEs provide an ab-
straction to run a process isolated from the remaining system.
TEEs enforce hardware-based protection of the integrity and
conﬁdentiality of the contained code and data and have means
to prove it to external entities [13, 44].
In the following, we focus on Intel SGX, which forms the
basis for our overall design. SGX’s TEE entities are enclaves,
which only rely on the security of the CPU. Enclaves pro-
vide a dedicated memory region called enclave page cache
(EPC) which is isolated and transparently encrypted and au-
thenticated. The enclave app code is limited to user space
instructions, s.t. enclaves depend on the cooperation of the
untrusted OS for system calls and interaction with hardware
devices. Therefore, SGX provides direct access to untrusted
memory and the notion of enclave calls (ECALLs) and outside
calls (OCALLs), which allow controlled transitions between
the trusted and untrusted world. Furthermore, SGX allows to
store data encrypted on the disk via a sealing key derived by
the CPU and only accessible to the respective enclave [13].
SGX enclaves can prove their identity and protection to lo-
cal and remote entities. For local attestation, the CPU creates
a cryptographic report of the enclave, which contains a mea-
surement (secure hash) of the initial enclave state. The report
is signed by the CPU with the key of the local challenger en-
clave and can then be passed to the challenger for veriﬁcation.
For remote attestation, the Intel-provided Quoting Enclave
(QE) acts as local challenger. The QE then adds the platform
state and forwards the resulting quote to a trusted remote at-
testation service, e.g., Intel Attestation Service (IAS), which
checks the platform validity and returns a signed attestation re-
port. Enclaves can bind user data (e.g., keys) to the attestation
by embedding custom data into their reports [13, 32].
Enclave Development and Graphene-SGX. There are at
least three major paradigms to develop TEE-enabled pro-
grams. First, applications can be explicitly designed for cer-
tain TEEs by using SDKs [25], which abstract the implementa-
tion details. SDKs usually provide APIs for attestation and in-
teractions with the untrusted OS, e.g., for sealing ﬁles to disk.
Second, semi-automated approaches rely on compiler support
and developer-provided source code annotations to split code
and data into sensitive and non-sensitive parts. The sensitive
parts are then moved inside the isolated enclave and connected
to the untrusted parts via shielding layers [37, 55]. Finally,
as a third approach, SGX library operating systems securely
execute unmodiﬁed applications inside enclaves [2, 5, 9, 53].
Due to the user space restriction of enclaves, these LibOSes
handle system calls on behalf of the apps and transparently
provide POSIX abstractions, e.g., multi-threading support. As
the underlying OS is untrusted, the frameworks aim to shield
system calls against so-called Iago attacks [10], in which
the untrusted operating system manipulates system calls and
their return values. However, while LibOSes typically pro-
vide shielding layers for secure disk I/O and ﬁle integrity, they
do not protect network trafﬁc and rely on the untrusted host
756    29th USENIX Security Symposium
USENIX Association
network stack. While SCONE [2] includes transparent TLS
proxy support for server apps, it fails to protect client trafﬁc
and DNS—both essential requirements of SENG.
In our design, we will follow the third approach, and use
the Graphene-SGX LibOS, which is open source and allows
us to transparently execute unmodiﬁed applications in SGX
enclaves [9]. Graphene-SGX transparently emulates some
system calls internally, while others are delegated to the un-
trusted OS. A manifest ﬁle speciﬁes the enclave size and
number of threads, as well as the application and correspond-
ing dependencies that Graphene-SGX shields. The manifest
is part of the enclave identity for attesting the shielded appli-
cation. While Graphene-SGX provides multi-threading and a
ﬁle system shield, it provides no secure network I/O for apps.
5 Design
5.1 Requirements
SENG’s high-level goals are twofold: (i) prevent attacks
against the trafﬁc of SGX-shielded clients, and (ii) allow a
central gateway to govern network access on a per-application
basis. From these, we derive six security (SR) and three auxil-
iary (AR) requirements of our system, as shown next. These
requirements hold equally for internal and external shielded
clients. Five of these requirements (SR2–SR6) heavily rely
on the new concepts introduced by our design.
SR1 Code and Data Protection During execution, the in-
tegrity and conﬁdentiality of client code (binary, libs)
and data (including ﬁles) must be protected.
SR2 Network Trafﬁc Integrity and Conﬁdentiality The
integrity and conﬁdentiality of network trafﬁc between
shielded apps and the gateway is guaranteed, which
holds true both for internal and external clients.
SR3 Redirection Prevention Trafﬁc from shielded clients
must be protected against packet header manipulation
by local system-level or on-path MITM attackers until it
passes the gateway. Furthermore, local and on-path DNS
redirection attacks must be prevented.
SR4 Protection-based Trafﬁc Authentication The
gate-
way must be able to distinguish between trafﬁc of
shielded applications and that of non-shielded ones.
This property enables network policies that restrict the
access to sensitive subnetworks to shielded apps only.
SR5 Accountability of Shielded Trafﬁc The gateway must
be able to link shielded trafﬁc back to the respective
shielded application to enforce per-app network policies.
SR6 Information Leakage and Remote Control Prevention
Whenever SENG enforces that only shielded clients
may communicate, local system-level and internal
MITM attackers must not be able to leak information
to external systems. In the opposite direction, attackers
must not be able to send information (e.g., malware
commands) from the outside to compromised clients.
AR1 No Client Code Changes. To ease adoption and to
support closed-source and legacy applications, we seek
for a solution that does not require any code changes in
the client app and its dependencies.
AR2 Scalability of Gateway Server The overhead intro-
duced to the gateway server per shielded app and per
network connection must be low to allow for scaling.
AR3 Compatibility with other Gateway Services The
protection and authentication techniques used by SENG
should not interfere with other services on the network
gateway, such as middleboxes or ﬁrewalls.
5.2 Overview
We now provide an overview of the SENG architecture and
explain how SENG shields network trafﬁc of unmodiﬁed
client applications and enables app-grained trafﬁc control.
The SENG architecture consists of two main components:
(i) a client-side shielding runtime, and (ii) a SENG server
located at the gateway. Figure 2 provides an overview of
the SENG components and communication channels. On the
client side, the SENG runtime wraps a client application in
a library OS (LibOS) and combines both in an SGX enclave.
The dedicated SENG server is located at the central network
gateway. It cooperates with the ﬁrewall and the SENG runtime
instances to attribute and protect trafﬁc of the shielded apps.
On the client, the LibOS and SENG runtime transparently
shield the client applications from local system-level attack-
ers. To this end, the LibOS loads and executes unmodiﬁed
binary applications inside a hardware-protected SGX enclave.
The LibOS transparently handles system calls of the app and
shields them against Iago attacks [10] of the untrusted OS.
For instance, the LibOS prepares its own ﬁle system to protect
against disk I/O tampering. The SENG runtime adds to this in
that it protects network I/O of shielded apps and establishes
trust with the SENG server. Technically, the SENG runtime in-
corporates a lightweight user space TCP/IP stack to cope with
the lack of trust in the host’s network stack. This user-space
network stack manages the app’s connections inside SGX and
enables secure tunneling of whole IP packets—including the
network and transport headers–to the SENG server.
The SENG server has to authenticate client apps and se-
curely forward shielded trafﬁc between SENG runtime and
gateway. The SENG runtime and server establish an attested,