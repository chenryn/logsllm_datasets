cryptographically random. The System.Random API suffices for some purposes, but should not be used to
generate security-sensitive values such as cryptography keys.
To use the System.Random class, an application first instantiates a new Random object—either with a seed, or
without specifying a seed. For instantiation, System.Random exposes the following two constructors:
Random()
Random(Int32 seed)
The default constructor, Random(), is parameterless, and hence doesn’t take a seed. When this constructor is
used, the Random object is seeded with the current system uptime—Environment.TickCount—which has
millisecond resolution. You can see this by analyzing the source code for System.Random, which is available on
Microsoft’s Reference Source website (http://referencesource .microsoft.com/#mscorlib/system/random.cs):
//
// Constructors
//
public Random()
: this(Environment.TickCount) {
}
public Random(int Seed) {
int ii;
int mj, mk;
[ ... ]
}
The other constructor, Random(Int32 seed), accepts a seed as its 32-bit integer parameter, and uses this to seed
the Random object.
The developer can then call one of the class’s member methods to retrieve pseudo-random data from the object.
System.Random exposes the following methods for pulling out random data:
Next()—Returns a non-negative pseudo-random integer
Next(Int32)—Returns a non-negative pseudo-random integer that is less than the specific maximum
Next(Int32, Int32)—Returns a non-negative pseudo-random integer that is within the specified range
NextBytes(byte[])—Fills the specified byte array with random bytes
NextDouble()—Returns a pseudo-random double
Sample()—Returns a pseudo-random floating-point number between 0.0 and 1.0
So, for example, a less-than-perfect application may generate a 32-byte cryptography key, and therefore call into
the Random API using code such as the following:
Random rnd = new Random(1234); // 1234 as the seed
byte[] encKey = new byte[32];
rnd.NextBytes(encKey);
Or, the developer may opt to use Random's default constructor and not specify a seed, such as:
Random rnd = new Random(); // uptime in milliseconds as seed
byte[] encKey = new byte[32];
rnd.NextBytes(encKey);
To the untrained eye, both of these may look fine and appear to work as expected; they both generate data that
seems to be random, at a glance, perhaps. However, each case is in reality insecure; the problem with
System.Random is that two Random object seeded with identical seed values always produce the same sequence of
“random” numbers as their output. In other words, if a Random object is seeded with 1234, the output will be
exactly the same as for another Random object seeded with 1234.
Clearly, this is particularly bad for generating security-sensitive values like cryptography keys, because if you
seed the value you can predict the output of a System.Random object.
Intuitively, this situation is at its worst if the app manually specifies a static or deterministic seed value, as in
the following example:
Random rnd = new Random(STATIC_SEED_VALUE);
This is because the seed value can be determined by all attackers who reverse-engineer the application or have
knowledge of some system values, such as the MAC or IP addresses.
However, even if the default constructor is used as shown here,
Random rnd = new Random();
the system uptime in milliseconds is used as the seed. This is insecure, because Environment.TickCount is quite
predictable.
As a matter of fact, only 86.4 million milliseconds are in a 24-hour day. Therefore, simply knowing on which day
a key (or otherwise) was generated by Random would enable you to determine the generated value by trying all
86.4 million possible values as the seed. Additionally, just because Environment.TickCount has millisecond
resolution, Environment.TickCount doesn’t change every millisecond. Changes to TickCount every 15
milliseconds may be typical, for example (see
http://blogs.msdn.com/b/pfxteam/archive/2009/02/19/9434171.aspx). This is likely to narrow down the seed
search space even further.
The point here is that for a given seed value, the output of a System.Random object will always be the same; this
predictability of output for each particular seed value is obviously insecure, and for this reason, System.Random
should never be used for generating security-related values, such as cryptography keys.
The right API to use for cryptographic and other security purposes, as it were, is RNGCryptoServiceProvider; we
cover the use of this API in detail in the next chapter’s section, “Generating Random Numbers Securely”.
Multiple Instances of System.Random
Suppose that a developer wants to generate a collection of random numbers. The unsuspecting developer may
write code like the following:
int[] randData = new int[32];
// generate random ints
for(int count = 0; count 
{
randInts[i] = rand.Next();
});
Non-thread safe characteristics present yet another reason to avoid System.Random altogether when
cryptographically secure data is required. As mentioned before, the correct API to use for security purposes is
the RNGCryptoServiceProvider class, the use of which we cover in full in the Chapter 13 section, “Generating
Random Numbers Securely.”
Insecure Cryptography and Password Use
Most people involved with security realize that sensitive data should be stored or transferred in encrypted
format, instead of in its easily accessible plaintext format. However, simply encrypting data is the tip of the
iceberg; many ways exist to implement cryptographic storage (or transfer) that falls short in terms of security,
and this can partially or completely undermine the security that cryptography could otherwise have provided.
The general category of “insecure cryptography and password use” does not represent one class of bug, but
several. For example, bad key management provides a number of ways to introduce vulnerabilities.
Proper key management is central to securely implementing cryptography in applications. The security of
encrypted data relies heavily on cryptography keys being unknown to those who would illegitimately like access
to the data. Thus, failure to generate keys securely and then protect them can result in the compromise of
encrypted data. We cover some of the common ways in which developers mismanage cryptography keys (and
passwords) and introduce security vulnerabilities when implementing cryptographic storage or transfer in their
applications.
Hard-Coded Cryptography Keys
Even with security now being a widespread concern, it’s still quite common to see apps encrypting data and
storing (or transferring) data using cryptography keys that are simply hard-coded into the app.
When reviewing an app’s code (original or reversed) you may come across code that defines a static
cryptography key used later for encrypting important and sensitive data. For example, consider the following
code fragment in which the app defines a static 32-byte key, which it uses for encryption of some sensitive data,
the resulting ciphertext for which is stored to a file in its Local directory:
char[] cryptoKey = { 0x10, 0x20, 0x30, 0x40, 0x45, 0x78, 0x65,
0x61, 0x62, 0x43, 0x69, 0x35, 0x32, 0x15, 0x20, 0x50, 0x10, 0x20,
0x30, 0x40, 0x45, 0x78, 0x65, 0x61, 0x62, 0x43, 0x69, 0x35, 0x32,
0x15, 0x20, 0x50 };
[ ... ]
retval = EncryptData(secretData, cryptoKey, out encryptedData);
retval = StoreEncryptedData(encryptedData, filePath);
Although the resulting data will indeed be encrypted, any attacker able to reverse-engineer the application
becomes privy to the key. Because the key is hard-coded into the app, all users of the app will have their data
encrypted with exactly the same key.
All the attacker needs to do after discovering the hard-coded key is to extract encrypted files from the target
devices and proceed with decryption using that static key. It goes without saying that the use of hard-coded keys
is essentially never acceptable for sensitive data.
Insecure Storage of Cryptography Keys
Another common security failure is when apps safely generate per-user cryptography keys, but then store them
in their filesystem sandbox in cleartext format. Some apps attempt to hide the key(s) or obfuscate them to deter
casual or unskilled attackers, but this rarely offers any genuine extra security.
Likewise, some apps that make use of public key cryptography to store their private key to their filesystem
sandbox—schematically:
string cryptoKey = GenerateCryptoKey();
StoreCryptoKeyToFile(cryptoKey);
In any case, any attacker able to access the device’s filesystem will be able to extract the key(s), which he can
then use to recover encrypted data that is protected by the key.
When performing a review of an app’s cryptographic practices, pay close attention to whether keys are being
stored, and keep in mind that storage of private keys and symmetric keys are security issues, assuming the
protected data is sensitive.
Of course, secure ways exist for storing cryptography keys. We discuss them in Chapter 13 in the section “Secure
Key Management.”
Storing Keys and Passwords in Immutable String Objects
Although cryptography keys themselves are rarely stored in string objects due to their binary nature, password-
based key derivation schemes (such as Password Based Key Derivation Function 2, or PBKDF2) commonly deal
with the password in the form of a string.
For example, to generate a cryptography key, an app may accept a password from the user, read it into a string
object, and then pass that object to its PBKDF2 method to go ahead and generate the key. In pseudo-code, this
could be represented as:
string password = ReadPasswordFromPasswordBox();
[ ... ]
PBKDF2_GenKey(password, iterations, out cryptoKey);
This works fine functionally but the problem from a security perspective is that after the password has been
stored in the string object, this value cannot be overwritten at will. This poses a problem if an attacker is able to
dump memory out of the process; ideally, you should clear the password from memory as soon as it is not
needed anymore.
Clearing a string, however, is not easily done. String objects are immutable, meaning that after the object’s
value is set, it cannot be changed. You would be forgiven for assuming that the following results in myStr’s value
being changed to "overwritten":
string myStr = "value1";
myStr = "overwritten";
In actual fact, it does not; the preceding code simply changes the string object that myStr references; the
"value1" string object may still exist, until garbage collection.
The Common Language Runtime (CLR) is also likely to make new copies of string objects when they are passed
into other methods, making memory disclosure and forensics attacks more likely to succeed.
Because you cannot easily wipe passwords stored in string objects, you would be vigilant to consider instances
of password storage in strings to be a vulnerability, particularly in security-critical applications. Typical attack
vectors include memory disclosure bugs and memory forensics investigation on a device.
To guard against memory disclosure and memory forensic attacks, store all passwords not in immutable string
objects (which cannot be overwritten), but in char[] or byte[] arrays that can be zeroed in a for() or while()
loop when they are no longer needed. We discuss this topic in the following section.
Failure to Clear Cryptography Keys and Passwords from Memory
When apps use cryptography, the key needs to be in memory in the app’s address space at some point. For apps
that require a high level of security, however, cryptography keys should be wiped from memory as soon as they
are no longer needed, or when they are not needed again for some time; you should also apply this same
principle for passwords. The purpose of clearing cryptography keys and passwords from the app’s address space
is to help protect against successful memory disclosure and forensics attacks, and in fact, wiping cryptography
keys is required to be compliant to certain security specifications, including some Federal Information
Processing Standards (FIPS) specifications.
Practically, this means that after a key has been used and is not needed again in the near future, the app should
overwrite it to (hopefully) erase it from the runtime’s memory.
If the app actively needs the key (that is, it’s having a conversation via a custom-encrypted protocol), then
overwriting it is obviously not going to be feasible. When an app only needs to use the key for a batch of
operations, we recommend that the key be wiped promptly afterwards.
In apps where wiping is feasible from a usability and performance standpoint, cryptography keys and passwords
should generally be stored in char[] or byte[]arrays and then wiped when no longer needed, as demonstrated
here:
for(int i = 0; i < KEYLEN; i++)
cryptoKey[i] = 0;
In sensitive apps (that is, banking), failure to implement such a key and password clearing policy may be
considered a security issue. Of course, usability and performance are also important in many applications, so if
an app needs to persist a key or password because it uses it often, then ultimately this requirement may need to
overrule security.
Insecure Key Generation
Secure key generation is another critical part of implementing an acceptably secure system of cryptographic
storage or communications within an app. Failure to securely generate keys can result in these keys being
predictable or otherwise weak, so we’ll look at ways in which apps may insecurely generate keys, and how you
can spot them in a Windows Phone app security review.
Insecure Random Key Generation
Some cryptography keys are generated using pseudo-random number generation APIs. However, you must use a
secure pseudo-random number generator (PRNG) and use it properly.
In the context of Windows Phone apps, this means that the System.Random class should never be used to
generate cryptography keys, because output data from System.Random is not cryptographically random. You
should consider the use System.Random to generate cryptography keys a security issue.
We covered this topic earlier in this chapter. (See “Insecure Random Number Generation” for more detail on the
subject of auditing for insecurely generated random cryptography keys.)
Insecure Password-Based Key Generation and Password Policy
The other main way of generating cryptography keys (in addition to via pseudo-RNG sources) methods is via a
password-based key generation scheme.
As the phrase suggests, password-based key generation schemes take a password usually provided by the user,
and generates a cryptography key from it. The implementation details of these popular schemes vary.
The simplest conceivable way of generating a cryptography key from a password is to simply convert the
password to a byte array, and use that as the cryptography key. There are, however, several problems with this
idea. First, assuming 256-bit cryptography, the password would need to be 32-bytes long, which would present
problems for most users.
The second problem relates to the resulting keyspace of keys generated in this way. In general, passwords
contain only printable characters; a–z, A–Z, 0–9, and some special characters (for example, !, #, $, and so on).
This limits the usable value for each character to around 75, out of the 256 values that a one-byte character can
take. So keys made up from passwords directly allow much less entropy than could be achieved by allowing all
possible 256 values that one-byte characters can assume.
Moving a step further in sophistication, some developers may generate a 256-bit key by hashing the user’s
password using SHA-256. The main problem with this is that SHA-256 is a very fast hashing algorithm; an
attacker with a lot of computational power at his disposal (think Graphics Processing Units— GPUs) can
potentially generate billions of hashes per seconds, which translates to billions of password brute-force guesses
per second in an attempt to find your cryptography key. SHA-256 is also unsalted.
With that being said, it’s understandable that other methods of generating cryptography keys using a user-
supplied password are sought.
Good password-based key generation APIs work using hash functions over (potentially) many iterations, or
allow the developer to specify a “cost factor,” and they also involve salts and other time-consuming
manipulation steps. In general, the more iterations that are used, or the more costly it is to generate a key from
a given password, the better (within usability constraints!).
The reason for this lies in making a password brute-force attack to find the correct cryptography key time
consuming for an attacker; if he can only generate a few thousand keys per second, he can only attempt
decryption with a few thousand keys per second. His attack will therefore take significantly longer than if the
key were generated by just SHA-256 hashing the user’s password, which could allow billions of key outputs and
therefore decryption attempts on the victim’s data per second.
Good algorithms for password-based key generation also use large random salts to ensure that the user’s
password is hashed uniquely.
A description and survey of password-based key generation APIs are beyond the scope of this chapter, but
understanding which methods of key generation from passwords are secure, and which are not, is important so
that you can spot the usage of insecure methods in code reviews.
When apps use password-based key derivation, the use of the following APIs, when used correctly as per the
guidelines below, are considered acceptably secure from a cryptographic point of view:
PBKDF2 (http://en.wikipedia.org/wiki/PBKDF2)—With SHA-256, at least 10,000 iterations
Bcrypt (http://en.wikipedia.org/wiki/Bcrypt)—With 10-byte random salt, with a cost factor of at least 10
Scrypt (http://en.wikipedia.org/wiki/Scrypt, http://www.tarsnap .com/scrypt.html)—Recommended
parameters by the author, Colin Percival, are N = 2^20, r = 8, and p = 1. These are considered sensible for key
generation for sensitive data storage
All of these algorithms are purposefully slow to make an attacker much less likely to succeed in brute-forcing
passwords to find your cryptography key.