[16] Christian Cachin, Klaus Kursawe, and Victor Shoup. 2005. Random oracles in Con-
stantinople: Practical asynchronous Byzantine agreement using cryptography.
Journal of Cryptology 18, 3 (2005), 219â€“246.
[17] Ignacio Cascudo and Bernardo David. 2017. SCRAPE: Scalable Randomness
Attested by Public Entities. In Applied Cryptography and Network Security, Dieter
Gollmann, Atsuko Miyaji, and Hiroaki Kikuchi (Eds.). Springer International
Publishing, Cham, 537â€“556.
[18] Chainlink. 2021. Generate Random Numbers for Smart Contracts using Chainlink
VRF. https://docs.chain.link/docs/chainlink-vrf
[19] T-H. Hubert Chan, Rafael Pass, and Elaine Shi. 2018. PiLi: An Extremely Simple
Synchronous Blockchain. Cryptology ePrint Archive, Report 2018/980. https:
//ia.cr/2018/980.
[20] Alisa Cherniaeva, Ilia Shirobokov, and Omer Shlomovits. 2019. Homomorphic
Encryption Random Beacon. IACR Cryptol. ePrint Arch. 2019 (2019), 1320.
[21] Information Technology Laboratory Computer Security Division. 2021. Interop-
erable Randomness Beacons: CSRC. https://csrc.nist.gov/projects/interoperable-
randomness-beacons
[22] Danny Dolev and RÃ¼diger Reischuk. 1985. Bounds on information exchange for
[23] Danny Dolev and H. Raymond Strong. 1983. Authenticated algorithms for
Byzantine agreement. Journal of the ACM (JACM) 32, 1 (1985), 191â€“204.
Byzantine agreement. SIAM J. Comput. 12, 4 (1983), 656â€“666.
[24] J Drake. 2021. Minimal VDF randomness beacon. Ethereum Research Post (2018).
https:
[25] Drand. 2021. Drand - A Distributed Randomness Beacon Daemon.
//github.com/drand/drand
[26] Pesech Feldman and Silvio Micali. 1997. An optimal probabilistic protocol for
synchronous Byzantine agreement. SIAM J. Comput. 26, 4 (1997), 873â€“933.
[27] Yossi Gilad, Rotem Hemo, Silvio Micali, Georgios Vlachos, and Nickolai Zel-
dovich. 2017. Algorand: Scaling Byzantine Agreements for Cryptocurrencies. In
Proceedings of the 26th Symposium on Operating Systems Principles (Shanghai,
China) (SOSP â€™17). ACM, New York, 51â€“68.
[28] Mads Haahr. 2021. True Random Number Service. https://www.random.org/
[29] Runchao Han, Haoyu Lin, and Jiangshan Yu. 2020. RandChain: Decentralised
Randomness Beacon from Sequential Proof-of-Work. Cryptology ePrint Archive,
Report 2020/1033. https://ia.cr/2020/1033.
[30] Timo Hanke, Mahnush Movahedi, and Dominic Williams. 2018. DFINITY Tech-
nology Overview Series, Consensus System. arXiv:1805.04548 [cs.DC]
[31] Somayeh Heidarvand and Jorge L. Villar. 2009. Public Verifiability from Pairings
in Secret Sharing Schemes. In Selected Areas in Cryptography: 15th International
Workshop, SAC 2008, Sackville, New Brunswick, Canada, August 14-15, Revised
Selected Papers. Springer-Verlag, Berlin, Heidelberg, 294â€“308.
[32] Aniket Kate, Gregory M. Zaverucha, and Ian Goldberg. 2010. Constant-Size
Commitments to Polynomials and Their Applications. In Advances in Cryptol-
ogy - ASIACRYPT 2010, Masayuki Abe (Ed.). Springer Berlin Heidelberg, Berlin,
Heidelberg, 177â€“194.
[33] Jonathan Katz and Chiu-Yuen Koo. 2006. On Expected Constant-Round Protocols
for Byzantine Agreement. In Advances in Cryptology - CRYPTO 2006, Cynthia
Dwork (Ed.). Springer Berlin Heidelberg, Berlin, Heidelberg, 445â€“462.
[34] Mary Maller, Sean Bowe, Markulf Kohlweiss, and Sarah Meiklejohn. 2019. Sonic:
Zero-Knowledge SNARKs from Linear-Size Universal and Updatable Structured
Reference Strings. In Proceedings of the 2019 ACM SIGSAC Conference on Computer
and Communications Security (London, United Kingdom) (CCS â€™19). ACM, New
York, 2111â€“2128.
[35] Atsuki Momose and Ling Ren. 2021. Optimal Communication Complexity of
Authenticated Byzantine Agreement. arXiv:2007.13175 [cs.DC]
[36] Kartik Nayak, Ling Ren, Elaine Shi, Nitin H. Vaidya, and Zhuolun Xiang.
2020. Improved Extension Protocols for Byzantine Broadcast and Agreement.
arXiv:2002.11321 [cs.CR]
[37] Lan Nguyen. 2005. Accumulators from Bilinear Pairings and Applications. In Top-
ics in Cryptology â€“ CT-RSA 2005, Alfred Menezes (Ed.). Springer Berlin Heidelberg,
Berlin, Heidelberg, 275â€“292.
[38] Torben Pryds Pedersen. 1992. Non-Interactive and Information-Theoretic Se-
cure Verifiable Secret Sharing. In Advances in Cryptology â€” CRYPTO â€™91, Joan
Feigenbaum (Ed.). Springer Berlin Heidelberg, Berlin, Heidelberg, 129â€“140.
[39] Provable. 2021. blockchain oracle service, enabling data-rich smart contracts.
https://provable.xyz/
[40] Michael O. Rabin. 1983. Randomized byzantine generals. In 24th Annual Sym-
posium on Foundations of Computer Science (sfcs 1983). IEEE, Tuscon, 403â€“409.
https://doi.org/10.1109/SFCS.1983.48
[41] Irving S Reed and Gustave Solomon. 1960. Polynomial codes over certain finite
fields. Journal of the society for industrial and applied mathematics 8, 2 (1960),
300â€“304.
[42] Philipp Schindler. 2021. HydRand. https://github.com/PhilippSchindler/hydrand
[43] Philipp Schindler, Aljosha Judmayer, Markus Hittmeir, Nicholas Stifter, and Edgar
Weippl. 2020. RandRunner: Distributed Randomness from Trapdoor VDFs with
Strong Uniqueness. Technical Report. Cryptology ePrint Archive, Report 2020/942,
https://eprint. iacr. org/2020/942.
[44] Philipp Schindler, Aljosha Judmayer, Nicholas Stifter, and Edgar Weippl. 2020.
HydRand: Efficient Continuous Distributed Randomness. In 2020 IEEE Symposium
on Security and Privacy (SP). IEEE, Oakland, 73â€“89.
[45] Fred B Schneider. 1990. Implementing fault-tolerant services using the state
machine approach: A tutorial. ACM Computing Surveys (CSUR) 22, 4 (1990),
299â€“319.
[46] Nibesh Shrestha, Ittai Abraham, Ling Ren, and Kartik Nayak. 2020. On the
Optimality of Optimistic Responsiveness. In Proceedings of the 2020 ACM SIGSAC
Conference on Computer and Communications Security (Virtual Event, USA) (CCS
â€™20). ACM, New York, 839â€“857.
[47] Ewa Syta, Philipp Jovanovic, Eleftherios Kokoris Kogias, Nicolas Gailly, Linus
Gasser, Ismail Khoffi, Michael J. Fischer, and Bryan Ford. 2017. Scalable Bias-
Resistant Distributed Randomness. In 2017 IEEE Symposium on Security and
Privacy (SP). IEEE, Oakland, 444â€“460.
[48] Tokio-Rs. 2021. tokio-rs/tokio. https://github.com/tokio-rs/tokio
[49] Maofan Yin, Dahlia Malkhi, Michael K. Reiter, Guy Golan Gueta, and Ittai Abra-
ham. 2019. HotStuff: BFT Consensus with Linearity and Responsiveness. In
Proceedings of the 2019 ACM Symposium on Principles of Distributed Computing
(Toronto ON, Canada) (PODC â€™19). ACM, New York, 347â€“356.
A RELATED WORK
A.1 Related Works in the BFT SMR Literature
There has been a long line of work in improving the latency and
communication complexity of consensus protocols [1, 4, 5, 14, 26,
33, 35, 46, 49]. The state-of-the-art BFT SMR protocols [1, 3, 5, 46]
incur quadratic communication per consensus decision while using
14
Session 12D: Decentralized Cryptographic Protocols CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea3515threshold signatures. Without threshold signatures, they incur cu-
bic communication per consensus decision. Our BFT SMR protocol
makes progress in the setting where threshold signatures are not
desirable. Our protocol incurs ğ‘‚(ğœ…ğ‘›2) communication complex-
ity under the ğ‘-SDH assumption or ğ‘‚(ğœ…ğ‘›2 log ğ‘›) without it at the
expense of increased latency.
A.2 Related Works in the Random Beacons
Literature
In this section, we explore random beacon protocols, sometimes
also referred to as coin tossing protocols, in the synchronous setting.
Some works were originally designed for the asynchronous settings,
but in this section, we evaluate them in the synchronous setting.
Cachin et al. [16] use a threshold shared secret ğ‘¥ğ‘– of the secret
ğ‘¥ âˆˆ Zğ‘, where ğ‘ is the order of a group G. To generate beacons,
they create shares ğ‘”ğ‘ğ‘¥ğ‘– of the beacon ğ‘”ğ‘ğ‘¥, for some generator ğ‘” âˆˆ
G. The beacon value ğ‘ is some agreed upon coin value , say for
instance, a counter. When > ğ‘¡ such shares are obtained, all the
honest nodes obtain the same beacon value ğ‘”ğ‘ğ‘¥. Drand [25] uses a
similar approach by replacing the threshold secret with a threshold
BLS key and using signatures on the common coin ğ‘ (say, a counter).
This incurs a communication complexity of ğ‘‚(ğœ…ğ‘›2) always, but
comes with the drawback that it does not support reconfiguration,
i.e., if a single node is replaced or joins the system, the threshold
shared keys (sharing ğ‘¥ğ‘– of ğ‘¥) must be regenerated or new keys (or
shares ğ‘¥â€²
ğ‘– ) for the old key (or secret ğ‘¥) need to be reshared between
the new participants.
Homomorphic Encryption Random Beacon (HERB) [20] uses
homomorphic threshold ElGamal encryption scheme to generate
random numbers. The system tolerates ğ‘› > 3ğ‘¡ faults. Each node in
the system encrypts a random share and posts it on the bulletin
board. The protocol uses ğ‘¡ + 1 such encryptions to produce the final
beacon output. The work requires the use of a Byzantine Agreement
protocol whose inputs are ğ‘‚(ğœ…ğ‘›) sized, and therefore trivially has
a communication complexity of ğ‘‚(ğœ…ğ‘›3) in the best and worst cases.
It also uses a variant of the threshold setup, thereby not permitting
a re-usable setup.
RandChain [29] builds a DRB - Decentralized Random Beacon
that assumes sequential Proof-of-Work (Seq-PoW), and VDFs along
with Nakamoto consensus for consistency. Constructions using
these assumptions are not energy-efficient. In PoW, an adversary
with more hash power can neglect unfavorable random numbers
by forking, and to avoid this requires the total honest hash power
to be greater than 1/2. The work uses existing Byzantine Agree-
ment techniques which makes the protocol have a communication
complexity of ğ‘‚(ğœ…ğ‘›2) in the best case, while inheriting the ğ‘‚(ğœ…ğ‘›3)
communication complexity from BA [22] in the worst case.
Drake et al. [24] proposed a minimal bias-resistant VDF-based
random beacon scheme, that assumes the existence of a VDF [12]
and that the adversary has an advantage ğ´ğ‘šğ‘ğ‘¥ in terms of speed
over the honest nodes, in computing the VDF. The VDF is used
to determine the beacon output for a round, and sufficiently old
beacon outputs are used to select leaders for the Ethereum Proof-of-
Stake protocol. The system tolerates ğ‘› > 3ğ‘¡ faults, and is designed
for partial synchrony.
RandRunner [43] builds a random beacon protocol using VDFs.
Therefore, it has a setup that can be re-used. It uses trapdoor Veri-
fiable Delay Functions - VDFs with strong uniqueness properties
that produces unique values efficiently for the node that has the
trapdoor, but takes time ğ‘‡ to produce an output for the nodes that
do not have the trapdoor. This allows the beacon to output bias-
resistant outputs in every round. It is not immediately unpredictable
as an adaptive adversary can corrupt the next ğ‘¡  3ğ‘¡ faults. Running
ğ‘› BA instances incurs a communication complexity of ğ‘‚(ğœ…ğ‘›3) in
the best case and ğ‘‚(ğœ…ğ‘›4) in the worst case. RandHerd [47] is an
improved version of RandShare, driven by a client seeking a random
beacon value. The client splits the system into groups of size ğ‘ which
internally use RandShare, leading to a communication complexity
of ğ‘‚(ğœ…ğ‘2ğ‘›), even in the worst case. However, even though ğ‘ is a
constant, it depends on ğ‘› as the randomness of the beacon output is
determined by ğ‘. RandHound [47] goes beyond RandHerd by using a
stable-leader approach and dividing the system into groups of nodes
with group leaders in a tree structure during the setup. This incurs
RandHound, a communication complexity of ğ‘‚(ğœ…ğ‘2 log ğ‘›) when
the leader and the group leaders are honest. However, when the
leader is bad, it uses a view-change protocol which is analogous to
Byzantine Agreement, and incurs a cost of ğ‘‚(ğœ…ğ‘›3) communication
complexity when ğ‘¡  3ğ‘¡, with a communication
complexity of ğ‘‚(ğœ…ğ‘›2), and ğ‘‚(ğœ…ğ‘›3) communication complexity in
the worst case. It uses PVSS schemes (in particular SCRAPE [17])
and tolerates an adversary which can predict up to ğ‘¡ + 1 epochs
into the future.
Summary of limitations. The state-of-the-art SMR protocols [1,
3, 5, 49] have a lower bound of ğ‘‚(ğœ…ğ‘›2) on the communication
complexity in the best case, which hints that we cannot do better
than ğ‘‚(ğœ…ğ‘›2) without improving SMR first. State-of-the-art random
beacon protocols [16, 20, 47] show that we cannot achieve an unpre-
dictability advantage better than 1 epoch, since a rushing adversary
can always know one epoch output before the rest of the honest
nodes. State-of-the-art Random beacon protocols [16, 20, 47] also
show that a random beacon not in lock-step cannot avoid giving a
time advantage of less than 2Î” to a rushing adversary. Our work
aims to bridge these gaps in existing random beacon protocols.
Insights from existing works. RandPiper uses some insights
from HydRand [44] and non-trivially improves upon them for op-
timal fault tolerance (ğ‘¡ < ğ‘›/2 unlike ğ‘¡ < ğ‘›/3 from HydRand) and
better communication complexity (recall that HydRand has a com-
munication complexity of ğ‘‚(ğœ…ğ‘›2) in the best case and ğ‘‚(ğœ…ğ‘›3) in
the worst case). We first observe that HydRand secret shares one
value and uses this shared value the next time the same node be-
comes a leader again. We observe that this is buffering of shares,
and that this buffering can be done for more than one share, i.e.,
every time a node becomes a leader, we can use the value from the
15