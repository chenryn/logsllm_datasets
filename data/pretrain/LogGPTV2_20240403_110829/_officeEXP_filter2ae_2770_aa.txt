# 【技术分享】手把手教你如何构造office漏洞EXP（第三期）
|
##### 译文声明
本文是翻译文章，文章来源：安全客
译文仅供参考，具体内容表达以及含义原文为准。
**作者：**[ **维一零** ****](http://bobao.360.cn/member/contribute?uid=32687245)
**稿费：700RMB（不服你也来投稿啊！）**
******投稿方式：发送邮件至**[ **linwei#360.cn**](mailto:PI:EMAIL) **，或登陆**[
**网页版**](http://bobao.360.cn/contribute/index) **在线投稿******
**传送门**
[**【技术分享】手把手教你如何构造office漏洞EXP（第一期）**
****](http://bobao.360.cn/learning/detail/3003.html)
[**【技术分享】手把手教你如何构造office漏洞EXP（第二期）**
****](http://bobao.360.cn/learning/detail/3009.html)
[**【技术分享】手把手教你如何构造office漏洞EXP（第四期）**
****](http://bobao.360.cn/learning/detail/3246.html)
在上一期的office漏洞分享中，介绍了传奇漏洞cve-2013-3906的技术框架，其中涵盖了不少溢出类漏洞的经典。这一期给大家带来的分享是CVE-2014-1761，这个漏洞严格的说来主要影响的是office套件中的word程序，不像前面两期的漏洞可以在office套件中的多种程序里利用。当然每个漏洞都有自己的特色，只要运用得当，每个漏洞终会出彩。下面本人还是遵循老套路，讲完原理谈利用，最后再给大家演示一下如何编写此漏洞的木马程序捆绑器（通过逆向一个生成器）。
**漏洞原理**
****
这次的漏洞发生在WWLIB.DLL这个动态库里面，从其版本信息也能看出它主要是服务于word程序的。事实上，这个漏洞是由于word程序在解析rtf这类文档格式的文件时发生的溢出，而word程序提供对rtf这类文档的支持正是通过WWLIB.DLL这个解析库来实现的。值得一提的是，这个解析库的代码异常庞大，文件本身就将近20MB的SIZE，通过IDA对其初步分析后保存的idb文件SIZE更是达到惊人的200多MB，从这点足可见这个解析库的强大之处了。回到漏洞本身来说，这个解析库虽然提供了对RTF文件这类比较复杂的文档格式的支持，但是百密总有一疏，虽然微软的格式文档中明确规定了listoverridecount这个rtf控制字的合法参数是0，1或9，不过在WWLIB.DLL中的实现并没有那么严格的校验，所以才导致这次的漏洞。
在word程序中，rtf文档的格式（样式）信息都存在编目表里，其中一种编目表叫“编目覆盖表”（overridetable），用来索引多个“编目覆盖项”（listoverride），而listoverridecount是在“编目覆盖项”中描述格式要被覆盖的层次（即“编目覆盖层”lfolevel）数目。正常情况下，word程序会先根据listoverridecount的参数来分配一块内存以便后面索引lfolevel，如下图：
可以看出，根据listoverridecount给每个lfolevel分配8字节的内存，一共分配了8*listoverridecount字节的内存。后面，程序会继续解析每个lfolevel，并将其索引到这块内存区域里：
只是，这里索引的时候并“没有严格”检查索引值edi是否超过listoverridecount规定的最大值，就直接不断的递增其值并拷贝新的数据到分配的内存中去。而由于这块内存是事先根据listoverridecount的值分配出来的，如果实际lfolevel的数量多于listoverridecount，则会发生内存拷贝溢出。
**构造触发漏洞的POC**
****
经过上面的分析认识到这个漏洞的成因，由于word程序对rtf文件解析的实现不严谨导致内存拷贝溢出。为了验证这个原理来触发漏洞，首先我们需要参考rtf文件格式的规范手册去了解一些相关的（参考上文提及）rtf控制字的含义，才能进一步根据需求去构造能引导程序行为的rtf文件。接着，根据漏洞的原理构造出一个最简单的rtf文件：
直接双击文件用word打开，发现并没有想象中的异常，word解析后显示如下：
上文提到索引lfolevel的时候没有进行严格的检查，实际上是有检查的，只不过检查的逻辑有种偷工减料的感觉，在调试器下原形毕露：
可以看到，在每个索引之前的检查，都是进行了两次重复的按位异或和按位与的运算，其中最后一次比较索引值和最大值之前的运算是将当前索引值与0x0F值按位与，得到的其实只是索引值的低4位值，并不能代表索引值的位置，这个所谓的检查也就不具备完整性。从这也可以看出上面构造的POC为什么lfolevel的数目（3个）明明超过listoverridecount（2），却没有溢出，正是在这里被“校验”了。换个参数再来，比如listoverridecount的值给一个大于0x0F的值17（0x11），lfolevel的数目调成大于22个，重新走一遍上面的流程就能发现，预期的崩溃果然发生了：
这样成功的原因有两个：第一就是上述的校验过程把索引0x11和0x0F进行与运算后，得到的0x1再来与最大值0x11比较判断有没有越界，当然就会陷入了死循环里，后面待索引的lfolevel数目再多，最终判定越界的条件也成立不了。第二就是之所以选取listoverridecount的值为17而不是16的原因，则和堆内存的分配策略有关，选取17分配出来的内存比较容易挨着其他对象堆块，这样后面可以节省不少用于覆盖内存对象的lfolevel数量（本人实测参数为16的话，lfolevel数量要300多个以上才能溢出崩溃）。