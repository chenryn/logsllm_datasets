title:Fault detection and localization in distributed systems using invariant
relationships
author:Abhishek B. Sharma and
Haifeng Chen and
Min Ding and
Kenji Yoshihira and
Guofei Jiang
Fault Detection and Localization in Distributed
Systems using Invariant Relationships
Abhishek B. Sharma, Haifeng Chen, Min Ding, Kenji Yoshihira and Guofei Jiang
NEC Labs America, Princeton, NJ
{absharma, haifeng, min, kenji, gfj}@nec-labs.com
Abstract—Recent advances in sensing and communication
technologies enable us to collect round-the-clock monitoring data
from a wide-array of distributed systems including data centers,
manufacturing plants, transportation networks, automobiles, etc.
Often this data is in the form of time series collected from
multiple sensors (hardware as well as software based). Previously,
we developed a time-invariant relationships based approach that
uses Auto-Regressive models with eXogenous input (ARX) to
model this data. A tool based on our approach has been effective
for fault detection and capacity planning in distributed systems.
In this paper, we ﬁrst describe our experience in applying this
tool in real-world settings. We also discuss the challenges in fault
localization that we face when using our tool, and present two
approaches – a spatial approach based on invariant graphs and a
temporal approach based on expected broken invariant patterns
– that we developed to address this problem.
I. INTRODUCTION
The state-of-the-art sensing and communication technolo-
gies allow us to collect massive amount of monitoring data
from complex, distributed systems, if needed. For instance,
we can deploy hardware and software sensors to collect mon-
itoring data at multiple vantage points in today’s data centers
including servers and network switches, power supply and
cooling equipments, operating system (OS) and application
performance metrics, etc. Similarly, physical plants deploy a
sophisticated monitoring infrastructure [1], and modern auto-
mobiles have hundreds of sensors [6]. However, mere visibility
is not enough. We need to extract information from monitoring
data to manage complex, distributed systems more effectively.
Big data analytics for system operational intelligence is an
active area of research both within academia and industry.
Innovative emerging products in this domain include solutions
for IT [2] as well as physical systems [1].
Monitoring data from a variety of systems is in the form
of time series, e.g. OS performance metrics from servers, net-
work trafﬁc measurements, environmental data on temperature,
pressure, etc. for physical plants. Historically, such data has
proved extremely useful; for instance, one can detect faults or
anomalies in a system by comparing time series measurements
from a sensor, i.e. a performance metric, against a threshold.
There are several well-known parametric (e.g. auto-regressive
models) [12] as well as non-parametric techniques (e.g. based
on clustering) for modeling time series data; several of these
have been adapted for detecting faults and anomalies [18], [5].
Over the past few years, we have built a product called SIAT
for modeling time series monitoring data [13]. It uses Auto-
Regressive models with eXogenous input (ARX) to model
dependencies between different metrics 1. We refer to depen-
dencies between two or more metrics that hold across time
as invariants. E.g. the instantaneous resource (CPU, memory,
etc.) utilization at a web server will depend on the number
of HTTP requests that it is serving and we can model such
dependencies as invariants [13]. These invariant relationships
can be used to monitor a dynamic system and detect faults and
anomalies in it. We describe this approach using an example
next.
(a)
(a) Invariant graph (b) Broken invariants (dashed lines).
(b)
Fig. 1.
Example (Part I): modeling using invariants. Figure 1(a)
shows the graph of invariant 2 relationships extracted from a
real-world time series dataset3 consisting of 20 metrics. Each
node in the graph represents a metric and a link between two
nodes denotes an invariant relationship between them. This
invariant graph has 39 edges, and 5 connected components.
The largest connected component consists of 11 nodes, and
consists of two densely connected sub-components with a
common node. There are three isolated invariants, nodes
with degree 1, and a small connected component with three
nodes. Hence, we can build a model for normal system
operation from time series measurement data using invariants,
and represent it as a graph. The structure of this invariant graph
(e.g. connected components, degree distribution, etc.) provides
global information on dependencies across metrics.
Example (Part II): fault detection using invariants. If at some
point the system measurement data does not “ﬁt” some (or all)
of the invariant relationships, i.e. invariants are broken, then
we know that something has happened (possibly a fault or
an anomaly). Figure 1(b) shows the broken invariants (dashed
1In this paper, we use the term metric to refer to both a sensor (or a resource
such CPU, memory) and the time series monitoring data associated with it.
2We deﬁne an invariant later in Section II.
3We describe this dataset in more detail later in Section VII-A.
978-1-4799-0181-4/13/$31.00 ©2013 IEEE
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 07:43:15 UTC from IEEE Xplore.  Restrictions apply. 
lines) at a certain time. We can see that all broken invariants
have metric m1 in commmon, and hence, in this case, the
component associated with m1 is likely to have a fault.
Thus, using the pairwise or multivariate invariant relationships
between metrics we can transform the task of anomaly or fault
detection in distributed systems into a problem of identifying
unusal nodes in a graph. This approach has been applied for
fault and anomaly detection in several IT systems [7], [13].
Our contributions. This paper makes two contributions. First,
we describe the key algorithmic ideas that are implemented in
SIAT, and describe our experiences with applying SIAT to
real-world problems (see Sections II-III). Dealing with real-
world datasets exposed two challenges, namely improving the
fault localization algorithm of SIAT, and reducing the false
alarm rate due to measurement noise (see Section IV). Our
second contribution is that we formulate these challenges as
metric ranking and noise suppression problems, and present
two algorithms to solve them – one of them uses a graph
deﬁned by system invariants, and the other looks at temporal
patterns in broken invariants (see Sections V-VI). We compare
the two approaches using synthetic data in Section VII and also
discuss a case study using real-world dataset.
II. SYSTEM INVARIANTS AND SIAT
In this section we ﬁrst describe a framework for discovering
pairwise relationships in a large time series dataset that we ﬁrst
proposed in [13]. We then highlight the key steps in invariants
based fault/anomaly detection that we built into the SIAT.
A. System Invariants
An invariant is a pairwise relationship between two time-
series expressed as an AutoRegressive model with eXogenous
input (ARX) [12]. An ARX model with parameters (n, m, k)
between time series y(t) and x(t) is shown in (1).
y(t) + a1y(t − 1) + a2y(t − 2) + . . . + any(t − n)
= b0x(t − k) + b1x(t − k − 1) + . . . + bmx(t − k − m)
(1)
x(t) is the exogenous input time series and the parameters
k and m determine the number of previous samples of x(t)
affecting the current value y(t). The parameter n controls
the extent of autocorrelation in y(t) – i.e. the current value
y(t) depends on n previous samples. We denote the model’s
coefﬁcients as θ where
θ = [a1, . . . , an, b0, b1, . . . , bm]T
(2)
We can rewrite (1) using vector notation as shown in (3)
where we use to notation y(t|θ) to denote the relationship
between y(t) and θ.
y(t|θ) = ψT θ
(3)
where
ψ = [−y(t − 1), . . . , −y(t − n), x(t − k), . . . , x(t − k − m)]T
For a ﬁxed (n, m, k), we can estimate θ using least squares
regression. Assume that we have measured x(t) and y(t) over
2
a time interval 1 ≤ t ≤ N. Using (3) we can deﬁne a system of
linear equations and compute an estimate for θ by minimizing
the mean squared error; (4) deﬁnes the mean squared error.
MSE(θ) =
1
N
N
∑
t=1
(y(t) − ˆy(t|θ))2
(4)
where y(t) is the measured value at t and ˆy(t|θ) is our estimate
for it using the ARX model, i.e. (3).
The ARX model cannot capture all kinds of pair-wise
relationships between two time series. For instance, if y(t) has
a non-linear dependency on x(t) then the ARX model cannot
capture this relationship. Given a pair of time series, how do
we decide whether an ARX model captures their relationship?
We use a normalized ﬁtness score F(θ) as a measure of the
“goodness of ﬁt” of an ARX model [13]. F(θ) is deﬁned as
follows:
(5)
F(θ) = 1 −s ∑N
t=1 |y(t) − ˆy(t|θ)|2
∑N
t=1 |y(t) − ¯y|2
where ¯y is the mean of the observed values y(t). F(θ) is
always less than one and a high F(θ) value indicates that the
ARX model ﬁts the observed data well. In practice, we specify
a threshold τ and if the ﬁtness score of an ARX model for
y(t) and x(t) is greater than τ, then we declare that there exists
a time-invariant linear relationship, i.e. an invariant, between
them; the ARX model captures this relationship.
B. SIAT
We built SIAT based on our idea of system invariants. It has
proved effective at two important system management tasks,
fault/anomaly detection and capacity planning [7], [13], [14].
The two main design decisions in building SIAT were (1) ARX
model identiﬁcation, i.e. what should we set n, m, and k to?
and (2) an algorithm for fault detection?
A simple approach for ARX model
identiﬁcation is to
consider all possible values for n, m, and k within a range,
and amongst the models with ﬁtness score greater than τ, pick
the one with the highest ﬁtness score. For IT systems such
as multi-tier web services, and Oracle and SQL databases,
a choice of 0 ≤ n, m, k ≤ 2 has worked well [13], [7], [14],
and for such a small range for model parameters SIAT’s brute
force search is not prohibitively expensive. A more efﬁcient
approach for invariant model identiﬁcation remains an open
problem.
SIAT uses invariants for detecting faults and anomalies in
real time as described next. At each time t, it keeps track of
the residual between the measurement y(t) and its estimate
ˆy(t|θ) deﬁned as:
Rxy(t) = |y(t) − ˆy(t|θ)|
(6)
In the absence of faults or anomalies, we would expect
Rxy(t) ≤ εxy, where εxy is a threshold determined by the
ARX modeling error. Hence, if Rxy(t) > εxy, SIAT declares
the invariant between x(t) and y(t) as broken. If the same
invariant is broken for three consecutive samples, then SIAT
raises an alarm and marks the corresponding metrics for
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 07:43:15 UTC from IEEE Xplore.  Restrictions apply. 
3
data. Recall that we estimate an ARX model’s parameter using
least-squares regression, and SIAT estimates O(n2) models for
a dataset with n metrics. For 24x7 monitoring data collected
from multi-tiered infrastructure supporting web services, en-
terprise applications, and data warehouses, SIAT’s training
phase duration is on the order of minutes. (We can test for
broken estimates in real-time since computing ˆy(t|θ), given
the ARX model parameters, only involves a small number
of multiplications and additions.) With very large datasets,
disk IO becomes the bottleneck, and we are currently working
on parallelizing SIAT’s training phase using MapReduce-style
approaches.
SIAT for physical systems. Recently, we applied SIAT to
analyze time series measurement data collected from physical
systems such as manufacturing plants and automobiles [9].
Since the monitoring data is in the form of time series, it
can be analyzed using SIAT. However, SIAT’s assumption
that 0 ≤ n, m, k ≤ 2 does not always hold for physical system
data. In particular, with high sampling frequency (we know
of one monitoring system that can collect samples every 10
ms or less), the correlation between metrics x and y can be
signiﬁcant even for a large lag, i.e. k >> 2, and we may also
need to estimate large models, i.e m, n >> 2. We are exploring
more sophisticated techniques for ARX model identiﬁcation
that will scale better than our current brute force approach.
raises additional challenges when analyz-
Quality of data
ing data from physical systems. We have had to deal with
many missing samples in the time series data, and samples
corrupted by (Gaussian) measurement noise. We are currently
augmenting SIAT with multiple modules that pre-process data
to improve its quality before it is fed to SIAT.
IV. LESSONS LEARNT: REAL-WORLD CHALLENGES
While SIAT is extremely effective at detecting faults and
anomalies, localizing these faults can be challenging. In one
of our experiments with a multi-tier web hosting infrastructure
consisting of a web, an application, and a database server, we
collected data for 111 metrics [13]. We then injected a busy
loop fault in the application server. Out of the 34 different
application server metrics,
the seven CPU related metrics
(utilization, idle time, IO wait time, etc.) are impacted the
most by this fault. Isolating these metrics is important for three
reasons: (1) it saves debugging effort – e.g. in this instance
administrators can focus on the application server ﬁrst, and
look at
the broken invariants at web and database server
after ﬁxing the application server, if needed (2) it facilitates
root cause analysis –
e.g. a high CPU load without any
signiﬁcant change in the number of HTTP requests indicates
rogue computation somewhere, and (3) it allows us to infer
signatures for faults that repeat often [8].
We refer to the problem of identifying the most abnormal
metrics as the metric ranking problem. Solving it involves
separating true SIAT alarms from false ones. It is challenging
to do this in the presence of measurement noise. When
applying SIAT to real-world data, we often observe that a
SIAT screenshot. Top: residual Rxy(t) for invariant between x(t)
Fig. 2.
(Middle) and y(t) (Bottom) measurements. Anomalous measurements marked
out by an oval in bottom plot.
further investigation by the system administrators. We made
this design choice to reduce the possibility of false alarms and
it has worked well in practice. Each invariant has a different
threshold εxy associated with it. SIAT uses the residuals from
the training data to automatically set εxy as,
εxy = 1.1 × argrxy {Prob(Rxy(t) < rxy) = 0.995}
(7)
i.e., it chooses a value rxy that is greater than 99.5% of the
residuals observed on the training data and sets εxy to be 10%
larger than rxy.
Figure 2 shows a screenshot from SIAT. SIAT extracted an
invariant ARX relationship between y(t) and x(t) from the
training data (not shown in Figure 2), and the top plot shows
the residual Rxy(t) for the x(t) and y(t) measurements shown
in the middle and botton plot, respectively. Initially Rxy(t) lies
with its bounds4 (yellow horizontal lines in top plot), but then
it starts increasing, and converges at a value higher than SIAT’s
upper bound for it. The corresponding measurements for y(t)
are marked out in the botton plot. SIAT marks the invariant
between y(t) and x(t) as broken for the duration when Rxy(t)
is outside its bound.
III. EXPERIENCES WITH SIAT
Success with IT systems. SIAT has been effective in tack-
ling a range of problems in distributed, computing systems
including fault and anomaly detection, generating signatures
for recurring failures, and capacity planning [13], [14], [7],
[8]. Figure 1 and the discussion on it in Section I outline how
SIAT can be used for fault/anomaly detection. For recurring
failures such as memory leaks, busy loops, DoS attacks on web
services, etc., we can infer a pattern for invariants that break
when a particular kind of fault occurs, and use it as a signature
in future [8]. SIAT can also perform what-if analysis, often
for capacity planning, using invariants. For example, an ARX
model between the number of HTTP requests and CPU usage
at a web server allows an administrator to estimate how much
more CPU power is needed to maintain the current system
performance if the rate of HTTP requests is doubled.
Model training time. We are constantly striving to improve
the time it takes to extract system invariants from training
4The upper and lower bounds are automatically computed using εxy (see
eq. 7).
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 07:43:15 UTC from IEEE Xplore.  Restrictions apply. 
small fraction of invariants are broken even in the absence
of any apparent faults or anomalies. Additionally,
the set
of metrics with such broken invariants changes over time.
This is not entirely surprising; it is too simplistic to expect