### Consulting with the Website’s Content Security Policy (CSP)

In standard web browsers, the Content Security Policy (CSP) would reject requests for resources that are not explicitly whitelisted. When testing proxy-based browsers, however, web server logs might indicate that certain resources, which were ultimately blocked, were still requested. This can lead to log-based analysis incorrectly marking the browser as vulnerable. To address this issue, our setup employs Optical Character Recognition (OCR) analysis of browser screenshots to detect the rendering of the resources of interest, in addition to the collected web server logs. We designed the test pages to include OCR-friendly visual cues (such as specific text and colors) for each successful test.

A secondary benefit of OCR analysis is its ability to validate the results of log-based analysis for non-proxy-based browsers. This is particularly useful for ensuring the accuracy of our framework's results, as manually verifying 138,000 tests would be impractical. In our experiments, we cross-check the OCR and log-based analysis results. Manual validation is only necessary when there is a disagreement between the two. Fortunately, such discrepancies became increasingly rare after several rounds of debugging, significantly reducing the overhead for verifying the correctness of the reported results.

### Longitudinal Analysis of Results

In this section, we present the results of evaluating 351 mobile browser versions from the top 20 Android browser families from 2011 to 2018. Each browser APK is automatically exposed to a total of 395 tests, and our experimental setup, as described in Section III-B, gauges the success or failure of each test. In this section, we use the terms "secure" and "vulnerable" to denote, respectively, the presence or absence of support for any given test.

#### A. Security Mechanism Adoption Trends

To understand how support for security mechanisms evolves over time, we aim to answer the following questions:
1. Do browser families add more support for security mechanisms as time goes by?
2. Are there differences in the rate of support for different types of security mechanisms?

**Vulnerability trends for distinct browser families:**
To obtain an overall view of the vulnerability trends, we calculate the average number of vulnerable tests (out of a total of 395 tests) for versions of a browser family released within the same year and then compare how the number of vulnerabilities changes over the years.

Figure 5 presents the general vulnerability trends of the three most popular browser families versus the three least popular ones (as listed in Table II). Given the large number of CSP tests that could skew the vulnerability trends towards one specific mechanism, we have excluded CSP support from this figure. At a high level, one can observe that most browsers improve (i.e., support more security mechanisms) over time. Two notable exceptions are the Next (com.jiubang.browser) and Boat (com.boatbrowser.free) browsers. These two browsers, among the top 20 popular browsers in the Android market with over 15 million downloads, have not been updated since 2016 and are vulnerable to more than 60 tests (excluding their support of CSP).

In terms of popular browsers, even though UC Mobile has been supporting more and more security mechanisms over the years, its latest evaluated version has five times as many vulnerabilities as Firefox, yet it was downloaded by five times as many users. Finally, both Chrome and Firefox have a non-zero number of issues in their latest versions at the time of testing (as listed in Table II). These are primarily due to a lack of support for the ALLOW-FROM value of the X-Frame-Options header in Chrome and the SameSite cookie in Firefox. More details on the support of the ALLOW-FROM value are provided later in Section VI-A.

**Vulnerability trends for different security mechanisms:**
To understand the vulnerability trend of various security mechanisms, we consider browsers released within the same year and calculate the fraction of vulnerable browser families. Figure 6 shows the vulnerability rates (the percentage of vulnerable browser families) for each of the evaluated security mechanisms. Here, a browser family is marked as vulnerable with respect to a security mechanism if at least one version released within a given year is vulnerable to tests for that security mechanism. Note that tests for Content Security Policy (CSP) are divided into two subsets according to their levels. This means that CSP directives proposed later in CSP levels 2 and 3, such as form-action and frame-ancestors, are analyzed separately from those included in CSP level 1. Additionally, since not many mobile browsers were being developed in the years 2011 and 2012, which could cause biased results, we limit the analysis to the years 2013–2018, where we collected browsers from at least 10 different browser families.

Several trends can be observed. The Same-Origin Policy (SOP), iframe sandboxing, and the X-Content-Type-Options header appear to have always been well supported in mobile browsers, although we find that, in most years, they all have a few failing tests. Contrastingly, other mechanisms—such as the Referrer-Policy, secure cookie attributes, and X-Frame-Options—are still not well supported in the majority of mobile browsers. The only mechanism that started with little support but is currently as widely supported as SOP and iframe sandboxing is the HTTP Strict Transport Security (HSTS) mechanism. We opine that this is because of the general push from browser vendors towards the HTTPS-by-default web and the gravity of SSL-stripping-like attacks, which HSTS defends against.

So far, CSP level 1 is properly supported by approximately half of the evaluated browser families, but none of the evaluated browser families properly enforce all tested directives of CSP levels 2 and 3. This demonstrates that it is not only difficult for web developers to author correct CSP policies [26, 37, 48, 49], but it is also challenging for browser vendors to account for all directives as described in the CSP specification.

#### B. Windows of Vulnerability

Except for the SOP and the iframe sandboxing, all of the security mechanisms we test in this paper need to be activated by website administrators by sending the appropriate HTTP response headers. In this section, we quantify the window of vulnerability between the time when website administrators first expected a given security mechanism to be present—thereby relying on it to increase the security of their pages—and the time when that mechanism was supported in desktop and mobile browsers.

To quantify the window of vulnerability, we crawled historical snapshots of the Alexa top 5K websites from the Internet Archive [7]. We collected the timestamps for all available snapshots of these websites and, when available, chose one snapshot per month to download. From the resulting 550K archived snapshots, we extracted the captured response headers—available and prefixed by the X-Archive-Orig-string, as described by Stock et al. [41]—and located the earliest time when any website first utilized a given security mechanism.

Table III compares the earliest time when any Alexa top 5K website requested a certain security mechanism and the earliest time when mobile and desktop browsers adopted that specific mechanism. We exclude from this analysis the SOP and iframe sandboxing since they are either assumed or activated through HTML tags. We choose 2011 as a cutoff year since that is the year when the oldest versions of our evaluated mobile browsers were released.

We found that mobile browsers are significantly slower in adopting security mechanisms compared to desktop browsers, which often start supporting mechanisms even before they are standardized. For example, the first mobile browser to support the anti-clickjacking X-Frame-Options mechanism did so in 2011, whereas both desktop Firefox and desktop Chrome supported the mechanism in 2010. At the same time, mobile browsers needed an extra three years (2014) before 75% of the evaluated browser families supported this mechanism. The results of Table III demonstrate that, for all evaluated security mechanisms, there exist multi-year vulnerability windows between the time websites make use of a given security mechanism and the time mobile browsers actually support it. Finally, we also discovered that Referrer-Policy1 is the only security mechanism that has not yet been adopted by 75% of the studied mobile browser families at the time of this writing.

Figure 7 shows the adoption rates of distinct security mechanisms in mobile browsers. For this graph, we denote a mechanism as "supported" if any of its tests succeed in a browser. The number in each bar segment represents the number of browser families that started to support a security mechanism in a given year. Among others, we observe that, except for the security-related attributes of cookies and the X-Frame-Options header, the remaining security mechanisms are not completely adopted by all of the 20 browser families we tested. One of the more recent security mechanisms, the Referrer-Policy1, is currently only adopted by less than half of the browser families, with more browsers adopting it in 2017 than they did in 2018.

#### C. Regressions in Security-Mechanism Support

Web browsers usually increase their support for different security mechanisms over time. For example, Chrome supported a subset of values of Referrer-Policy before fully supporting it. However, there are cases where mobile browsers exhibit regressions. In a regression, a later version of a given browser family supports fewer security mechanisms than a previous version of the same family.

By analyzing the number of vulnerable tests in consecutive versions of the same browser family, we identify two types of security regressions: temporary regressions and permanent regressions. In a temporary regression, a previously supported mechanism becomes unsupported only to be supported again in a later version. Contrastingly, in a permanent regression, a previously supported mechanism becomes unsupported and stays unsupported for the remainder of the evaluated versions.

According to our study, 55% of the tested browser families show signs of regressions in their support of security mechanisms. Figure 8 shows what percentage of browser families exhibit regressions with regard to different security mechanisms. Unfortunately, temporary and permanent regressions within a browser family appear in all security mechanisms except iframe sandboxing. We observe that most regressions occur when adopting CSP. This makes intuitive sense given the complexity of the CSP mechanism. Fortunately, most CSP regressions are temporary, meaning that browser vendors eventually detect the regression and correct it.

Table IV shows whether a particular top-5 popular browser family presents security regressions in terms of distinct security mechanisms. A checked cell means that a browser exhibited a regression while supporting the security mechanism. Our findings suggest that Chrome has the most consistent evolution since it does not show any security regressions as new security mechanisms were added or existing mechanisms were upgraded. UC browser shows frequent security regressions on SOP, CSP, and X-Content-Type-Options. The remaining browsers only occasionally show security regressions. For example, the Opera browser stopped supporting HSTS in version 15 and resumed its support in version 26. Given that these versions were released approximately one year apart, this means that users of the Opera browser were vulnerable to MITM attackers for that period, even for websites that correctly utilized the HSTS header.

Fortunately, all security regressions in this table, with the exception of Opera Mini’s regression in X-Frame-Options, were temporary and have been fixed in their latest browser versions.

### Analysis of Current Mobile Browsers

In the previous section, we investigated the security-mechanism support in mobile browsers from 2011 to 2018. This enabled us to quantify differences in the level of support across browser families, the mechanisms that are the most/least supported, and the delay between the first usage of a security mechanism in a popular website and the time when this mechanism is actually supported by most mobile browsers. However, this longitudinal analysis is only half of the story. Most users are likely to be utilizing a recent version of a popular browser, either because they consciously update their apps or because their smartphone is configured to automatically update apps whenever they connect to a wireless network. Therefore, in this section, we focus on the support of security mechanisms in the most recent versions of popular mobile browsers. We pay particular attention to the effects of the underlying Android version on the overall security of each mobile browser. Even though one may initially think that these two are independent, because most mobile browsers are built around WebView (Android’s component for showing web content in apps), they are, in fact, tightly dependent.

To quantify this dependency between security-mechanism support and Android version, we installed and tested the most recent version of the twenty evaluated mobile browsers on Android Lollipop (version 5.1), Marshmallow (version 6.0), and Nougat (version 7.1). These are the three most popular Android versions in the market, according to statistics from July 2018 [39]. Figure 9 shows the results of this experiment. One can observe that, for the majority of mobile browsers, there is a clear security improvement when they are installed on newer Android versions, as they benefit from more recent WebView implementations.

The corollary from this finding is that two users with the same version of the same browser installed can experience vastly different levels of security. This is counter-intuitive and significantly complicates the life of web developers who cannot assume the presence of certain security mechanisms based solely on the family and version of the browser being utilized. This is also the reason why, for a few browsers such as the Boat browser, the vulnerability rates shown in Figure 9 differ from the rates of the most recent versions analyzed in Section IV. The Hindsight framework (on which this work relies) utilizes an SDK assignment algorithm which installs a browser APK on a version that is as close as possible to the minimum required version.