code is either designed or implemented incorrectly (com-
mission), or simply omitted (omission).
In a thorough treatment of this topic, Maxion posits that
most exception handling failures in his test groups were er-
rors of omission due to simple lack of knowledge
and exposure to exceptions, exceptional condi-
tions, and exception handling [30]. Maxion pro-
vided material to the experimental groups with
information on exceptions, exception conditions,
and a mnemonic to jump-start their thinking on
the topic as well as help them to remember excep-
tion checking. He was able to show significant
improvement in the exception handling charac-
teristics of the treatment group software when
compared to a control group.
e
t
a
R
e
r
u
l
a
t
o
T
l
i
a
F
)
%
(
important issue to address, because before we can succeed
in helping developers create robust software systems, we
need a better insight into why robust systems are not being
built today.
This section examines how well experienced developers
understand the exception handling characteristics of their
code, not necessarily how robust the code was. We look at
a series of Java components written by various corporate
development groups within one of Carnegie Mellon’s large
corporate research partners that is historically known for
producing robust software. Data was collected on how the
developers thought their code would respond to exceptional
conditions, and contrasted with the robustness as measured
by Ballista.
In order to allow a development group to report on their
component’s expected response to exceptional conditions,
a taxonomy of failures was first developed. This taxonomy
borrows heavily from that developed by Maxion in [30].
Only minor changes were required, in order to better fit the
object and safety models that are inherent to Java.
Three components comprising 46 discrete methods were
rated by the development teams and tested using Ballista.
The components, labeled A, B and C were written by teams
1, 2 and 3 respectively.
Expected failure rates were calculated from the data pro-
vided by the programming teams. The method used to
compute expected failure rates was a simple correlation be-
tween which types of failures the developers expected to be
handled improperly, and the incidence rate of the failures in
the test cases. For example, let us consider hypothetical de-
veloper group X. Group X predicts that method foo() will
suffer an underflow exception(and none others) under the
right conditions. 10% of the test cases run against foo()
would put it in those conditions. Thus we would report that
Group X estimates a 10% failure rate for function foo().
Such an abstraction is necessary since the groups have no a
priori knowledge of the test cases.
Results for testing components A and B can be found in
Figure 10. Overall average failure rates were 5% and 0%
respectively. Teams 1 & 2 did fairly well in accurately clas-
sifying their code. One method suffers from an abort fail-
ure due to invalid data (memory reference), and some
Component C Robustness
Measured
Expected
60
50
40
30
20
10
0
1
C
3
C
5
C
7
C
9
C
1
1
C
5
1
C
3
1
C
Function
7
1
C
F
9
1
C
F
1
2
C
F
3
2
C
F
5
2
C
F
7
2
C
Although it clearly demonstrates that ordinary
students do not understand robustness and excep-
tion handling, the obvious question with regard to
Maxion’s work is how well professional devel-
opers understand robustness, and the exception
handling characteristics of their code. This is an
Figure 11. Measured vs. Expected robustness of component C. F
suffix indicate methods that perform data formatting operations
rather than performing calculations.
Proceedings of the International Conference on Dependable Systems and Networks (DSN’02) 
0-7695-1597-5/02 $17.00 © 2002 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 04:20:55 UTC from IEEE Xplore.  Restrictions apply. 
conditions marked as semi-robust actually could not occur
due to language constraints placed on the testing system
that made it impossible to create corrupt data for certain
base level data types (both teams anticipated divide by zero
failures that were in fact caught by the language).
Figure 11 contains the test results for component C, with
an overall average failure rate was 24.5%. The methods are
separated into two classifications, those that do calculation,
and those that merely return object data in a specific form or
data type.
Teams 1 and 2 had much better knowledge of how their
system would respond to exceptional conditions. With the
exception of a single failed pointer check instance, their ex-
pected robustness matched the measured robustness of the
systems. This excludes conditions that could not be gener-
ated due to language constraints to check the presence of
failures as a result of invalid base data types.
Team 3 seemed to have more difficulty determining how
robust their code was. As is evident from the test data, com-
ponent C suffered abort failures in roughly 60% of its meth-
ods. Team 3 indicated that the only failures would resultant
from divide by zero, and that all other exceptional condi-
tions would be handled correctly.
In fact, they suffered
from several failures common in most software, including
memory reference/data corruption issues, and failing to
handle legal, but degenerate data conditions. The most
prevalent exceptional conditions not handled correctly
were caused by values at the extreme end of their legal
ranges.
7. Conclusions
We have determined that generic robustness hardening
wrappers can be used to handle all detected robustness fail-
ures in several different software interfaces. Moreover, via
the use of a software caching technique for robustness
checks that maps well onto modern processor architectures,
the amortized cost of exception checking can be made quite
low, often only a percent or two of execution time. Thus,
the scalable exception testing approach used by the Ballista
robustness testing system has formed the basis of a scal-
able, generic, low-cost robustness hardening wrapper ap-
proach. Although in most cases we removed all the failures
detectable by our system, this is by no means a claim that
there are no residual failures. Rather it is an argument to-
ward the effectiveness of techniques used to preemptively
detect and correct conditions that would induce a failure
without suffering large performance penalties or program-
matic complexity. Based on this result, there seems to be
little reason for developers to shun building robust systems
based on performance concerns.
Further, we have measured the ability of a set of experi-
enced, professional developers to accurately classify the
exception handling abilities of their software systems. For
this particular case study, Maxion’s hypothesis that devel-
opers without specific training on the topic might not fully
grasp exceptional conditions seems to hold. This suggests
that an effective way to improve robustness is to train de-
velopers in understanding and applying known robustness
improvement techniques.
8. Acknowledgments
Support for this research was provided via an IBM Re-
search Fellowship and a grant from AT&T Shannon Re-
search Laboratory. Special thanks to P. Santhanam at IBM
T. J. Watson Research Center for the joint research partner-
ship.
9. References
[1] Austin, T.M.; Breach, S.E.; Sohi, G.S., “Efficient de-
tection of all pointer and array access errors,” Confer-
ence on Programming Language Design and
Implementation (PLDI) ACM SIGPLAN ‘94
[2] Black, Bryan; Rychlik, Bohuslav; Shen, John, “The
block-based trace cache,” Proceedings of the 26th an-
nual International Symposium on Computer Architec-
ture ISCA 1999
[3] Buhr, Peter; Mok, Russell, “Advanced Exception
Handling Mechanisms,” IEEE Transactions on Soft-
ware Engineering, vol. 26, number 9
[4] Carreira, J.; Madeira, H.; Silva, J.G., “Xception: a
technique for the experimental evaluation of depend-
ability in modern computers,” IEEE Transactions on
Software Engineering, vol.25, no.2
[5] Cristian, F., “Exception Handling and Tolerance of
Software Faults,” In: Software Fault Tolerance, Mi-
chael R. Lyu (Ed.). Chichester: Wiley, 1995.Ch. 4
[6] DeVale, J.; Koopman, P.; Guttendorf, D., “The Ballis-
ta Software Robustness Testing Service,” 16th Inter-
national Conference on Testing Computer Software,
1999. pp. 33–42
[7] DeVale, J.; Koopman, P., “Performance Analysis of
Exception Handling in IO Libraries,” Intl. Conf. on
Dependable Systems and Networks, 2001
[8] Dony, C., “Improving Exception Handling with Ob-
ject-Oriented Programming,” 14th International Con-
ference on Computer Software and Applications,
1990
[9] Fernsler, K.; Koopman, P., “Robustness Testing of a
Distributed Simulation Backplane,” 10th Interna-
tional Symposium on Software Reliability Engi-
neering, November 1-4, 1999
[10] Garcia, A.F.; Beder, D.M.; Rubira, C.M.F., “An ex-
ception handling software architecture for developing
fault-tolerant software,” 5th International Symposium
on High Assurance System Engineering, 2000
[11] Gehani, N., “Exceptional C or C with Exceptions,”
Software – Practice and Experience, 22(10): 827-48
Proceedings of the International Conference on Dependable Systems and Networks (DSN’02) 
0-7695-1597-5/02 $17.00 © 2002 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 04:20:55 UTC from IEEE Xplore.  Restrictions apply. 
[12] Ghosh, A.K.; Schmid, M., “An approach to testing
COTS software for robustness to operating system ex-
ceptions and errors,” Proceedings 10th International
Symposium on Software Reliability Engineering ISRE
1999
[13] Goodenough, J., “Exception handling: issues and a
proposed notation,” Communications of the ACM,
18(12): 683–696, December 1975
[14] Govindarajan, R., “Software Fault-Tolerance in
Functional Programming,” 16th Intl. Conference on
Computer Software and Applications, 1992
[15] Hagen, C.; Alonso, G., “Flexible Exception Handling
in the OPERA Process Support System,” 18th Inter-
national Conference on Distributer Computing Sys-
tems, 1998
[16] Hastings, R.; Joyce, B., “Purify: fast detection of
memory leaks and access errors,” Proceedings of the
Winter 1992 USENIX Conference
[25] Korn, D.; Vo, K.-P., “SFIO: safe/fast string/file IO,”
Proceedings of the Summer 1991 USENIX Confer-
ence, 10-14 June 1991
[26] Lee, P.A., “Exception Handling in C Programs,” Soft-
ware Practice and Experience. Vol 13, 1983
[27] Leveson, N.G.; Turner, C.S., “An investigation of the
Therac-25 accidents,” IEEE Computer, Vol 26, No. 7
[28] Lions, J.L. (chairman) Ariane 5 Flight 501 Failure:
report by the inquiry board, European Space Agency,
Paris, July 19, 1996
[29] Lippert, Martin; Lopes, Cristina, “A Study on Excep-
tion Detection and Handling Using Aspect-Oriented
Programming,” Proceedings of
the 2000 Interna-
tional Conference on Software Engineering, 2000
[30] Maxion, R.A.; Olszewski, R.T., “Improving software
robustness with dependability cases,” Twenty-Eighth
Annual International Symposium on Fault-Tolerant
Computing, FTCS 1998
[17] Hill,
FORTRAN,”
315–316, August 1971
I., “Faults in functions,
The Computer
in ALGOL and
Journal,
14(3):
[18] Hofstede, A.H.M., Barros, A.P., “Specifying Com-
plex Process Control Aspects in Workflows for Ex-
ception Handling,” 6th Intl.Conference on Advanced
Systems for Advanced Applications, 1999
[19] Hull, T.E.; Cohen, M.S.; Sawchuk, J.T.M; Wortman,
D.B., “Exception Handling in Scientific Computing,”
ACM Transactions on Mathematical Software, Vol.
14, No 3, September 1988
[20] IEEE Standard for Information Technology - Porta-
ble Operating System Interface (POSIX) Part 1: Sys-
tem Application Program Interface (API) Amendment
1: Realtime Extension [C Language], IEEE Std
1003.1b–1993, IEEE Computer Society, 1994
[21] Jones, E., (ed.) The Apollo Lunar Surface Journal,
102:38:30,
Apollo
102:42:22, and 102:42:41, National Aeronautics and
Space Administration, Washington, DC, 1996
landing,
entries
11
lunar
[22] Kanawati, G.; Kanawati, N.; Abraham,
J.,
“FERRARI: a tool for the validation of system de-
pendability properties,” 1992 IEEE Workshop on
Fault-Tolerant Parallel and Distributed Systems.
Amherst, MA, USA, July 1992
[23] Koopman, P.; Sung, J.; Dingman, C.; Siewiorek, D. &
Marz, T., “Comparing Operating Systems Using Ro-
bustness Benchmarks,” Proceedings Symposium on
Reliable and Distributed Systems, Durham, NC, Oct.
22–24 1997
[24] Koopman, P.; DeVale, J., “The exception handling ef-
fectiveness of POSIX operating systems,” IEEE
Transactions on Software Engineering, vol.26, no.9
[31] Pan, J.; Koopman, P.; Huang,V.; Gruber, R., “Robust-
ness Testing and Hardening of CORBA ORB Imple-
mentations,”
on
Dependable Systems and Networks, 2001
International
Conference
[32] Rakvic, Ryan; Black,Bryan; Shen, John, “Completion
time multiple branch prediction for enhancing trace
cache performance,” The 27th Annual International
Symposium on Computer architecture, ISCA 2000
[33] Alexandre Romanovsky, “An exception Handling
Framework for N-Version Programming in Ob-
ject-Oriented Systems,” 3rd International Symposium
on Object-Oriented Real-Time Distributed Com-
puting, 2000
[34] Swain, A.D.; Guttmann,H.E., “Handbook of Human
Reliability Analysis with Emphasis on Nuclear Power
Plant
Report
NUREG/CR-1278, U.S. Nuclear Regulatory Commis-
sion, 1983
Applications,”
Technical
[35] Thekkath, C., Levey, H., “Hardware and Software
Support for Efficient Exception Handling,” Sixth In-
ternational Conference on Architectural Support for
Programming Languages, October 1994
[36] Vo, K-P., Wang, Y-M., Chung, P. & Huang, Y.,
“Xept: a software instrumentation method for excep-
tion handling,” The Eighth Intl. Symposium on Soft-
ware Reliability Engineering, 1997
[37] Wilken, K.D.; Kong, T., “Concurrent detection of
software and hardware data-access faults,” IEEE
Transactions on Computers, vol.46, no.4 p. 412-24
[38] Ziles, C.B., Emer, J.S., Sohi, G.S., “The use of
multithreading for exception handling,” 32nd Annual
International Symposium on Microarchitecture, 1999
Proceedings of the International Conference on Dependable Systems and Networks (DSN’02) 
0-7695-1597-5/02 $17.00 © 2002 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 04:20:55 UTC from IEEE Xplore.  Restrictions apply.