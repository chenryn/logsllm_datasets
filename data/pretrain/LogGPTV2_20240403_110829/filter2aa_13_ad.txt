由于C/C++中分配内存开销相对小，而且Java中的String内容拷贝的开销可以忽略，更好的一点是此函数不分配内存，不会抛出OutOfMemoryError异常。
参数j_msg是一个jstring对象，start是拷贝字符串的开始位置，len是拷贝字符串的长度，jstr是目标指针字符串。
3）生成一个jstring对象：
参数：jstr是字符串指针，size是字符串长度。
这个方法可以认为是将字符串指针jstr转换成字符串对象jstring。
4）将jstring对象转换成const jchar*字符串指针。有两个方法：GetStringChars和GetStringUTFChars方法。
GetStringChars方法如下：
返回一个UTF-16编码的宽字符串（jchar*）。
参数如下：
·j_msg是字符串对象。
·copied是指传入的是一个jboolean指针，用来标识是否对Java的String对象进行了拷贝，如果传入的这个jboolean指针不是NULL，则它会给该指针所指向的内存传入JNI_TRUE或JNI_FALSE标识是否进行了拷贝，传入NULL表示不关心是否拷贝字符串，也就不会给jboolean*指向的内存赋值。
其对应的释放内存指针的方法：
参数：j_msg是jstring对象，jstr是字符串指针。
GetStringUTFChars方法如下：
这个方法是可以取得UTF-8编码的字符串（char*）。参数的含义和GetStringChars方法是一样的。这个方法也有对应的一个释放内存的方法：
参数的含义和上面的ReleaseStringChars方法的参数的含义是一样的。
提示：这两个函数分别都会有两个不同的动作：
·开辟一个新内存，然后在Java中的String拷贝到这个内存中，然后返回指向这个内存地址的指针。
·直接返回指向Java中String的内存的指针，这个时候千万不要改变这个内存的内容，这个将会破坏String在Java中始终是常量的这个原则。
5）将jstring对象转化成const jchar*字符串指针：
参数j_msg是字符串对象，copied同上面的解释，这里就不多说了。
这个方法的作用是为了增加直接传回指向Java字符串的指针的可能性（而不是拷贝），JDK 1.2出来了新的函数GetStringCritical/ReleaseStringCritical。
在GetStringCritical/ReleaseStringCritical之间是一个关键区，在这个关键区域之间不能调用JNI的其他函数，否则将造成关键区代码执行期间垃圾回收器停止运作，任何触发垃圾回收器的线程也会暂停，其他的触发垃圾回收器的线程不能前进直到当前线程结束而激活垃圾回收器。就是说在关键区域中千万不要出现中断操作，或在JVM中分配任何新对象；否则会造成JVM死锁。虽然这个函数会增加直接传回指向Java字符串的指针的可能性，不过还是会根据情况传回拷贝过的字符串。不支持GetStringUTFCritical，没有这样的函数，由于Java字符串用的是UTF-16，要转成UTF-8编码的字符串始终需要进行一次拷贝，所以没有这样的函数。
这个方法和第四个方法是一样的。其对应的释放内存指针的方法如下：
下面来看一下实例：在Java中定义一个String属性，通过控制台输入值，然后定义一个本地方法callCppFunction，在C++中这个方法的实现就是：获取到Java中这个字符串属性，将其进行倒序操作，然后再从Java中输出。
先来看一下Java代码：
再来看一下C++代码：
这里使用了三种方式实现功能。要注意的是，还有一个方法是将const jchar*转换成wstring，因为reverse方法接受的参数是wstring。在Eclipse中的运行结果如图2-28所示。
图2-28 Eclipse中的运行结果
2.6 C/C++中操作Java中的数组
在Java中数组分为两种：
·基本类型数组。
·对象类型（Object[]）的数组（数组中存放的是指向Java对象中的引用）。
一个能用于两种不同类型数组的函数是GetArrayLength（jarray array）。
2.6.1 操作基本类型数组
首先来看一下怎么处理基本类型的数组，有如下几种方法。
1.GetArrayElements方法
这类函数可以把Java基本类型的数组转换到C/C++中的数组，有两种处理方式，一种是拷贝一份传回本地代码，另一种是把指向Java数组的指针直接传回到本地代码中，处理完本地化的数组后，通过ReleaseArrayElements来释放数组。
2.ReleaseArrayElements方法
用这个函数可以选择将如何处理Java和C++的数组，是提交，还是撤销等，内存释放还是不释放等。
mode可以取下面的值：
·0：对Java的数组进行更新并释放C/C++的数组。
·JNI_COMMIT：对Java的数组进行更新但是不释放C/C++的数组。
·JNI_ABORT：对Java的数组不进行更新，释放C/C++的数组。
3.GetPrimittiveArrayCritical方法
4.ReleasePrimitiveArrayCritical方法
也是JDK1.2出来的函数，为了增加直接传回指向Java数组的指针而加入的函数，同样也会有同GetStringCritical一样死锁的问题。
5.GetArrayRegion方法
在C/C++预先开辟一段内存，然后把Java基本类型的数组拷贝到这段内存中，这个方法和之前拷贝字符串的GetStringRegion方法的原理是类似的。
6.SetArrayRegion方法
把Java基本类型数组中的指定范围的元素用C/C++数组中的元素来赋值。
7.ArrayNew方法
指定一个长度然后返回相应的Java基本类型的数组。
2.6.2 操作对象类型数组
JNI没有提供把Java对象类型数组（Object[]）直接转到C++中的Object[]数组的函数，而是通过Get/SetObjectArrayElement这样的函数来对Java的Object[]数组进行操作。由于对象数组没有进行拷贝，所以不需要释放任何资源。NewObjectArray可以通过指定长度和初始值来创建某个类的数组。
下面来看个例子：操作两种类型的数组。
Java中的代码：
C++中的代码：
在Eclipse编译运行，结果如图2-29所示。
图2-29 在Eclipse中运行的结果
2.7 C/C++中的引用类型和ID的缓存
2.7.1 引用类型
从Java虚拟机创建的对象传到本地C/C++代码时会产生引用，根据Java的垃圾回收机制，只要有引用存在就不会触发该引用所指的Java对象的垃圾回收。下面介绍C/C++中的引用类型。
1.局部引用
局部引用是最常见的引用类型，基本上通过JNI返回来的引用都是局部引用，例如使用NewObject就会返回创建出来的实例的局部引用，局部引用只在该native函数中有效，所有在该函数中产生的局部引用，都会在函数返回的时候自动释放，也可以使用DeleteLocalRef函数手动释放该引用。那么，既然局部引用能够在函数返回时自动释放，为什么还需要DeleteLocalRef函数呢。
实际上局部引用存在是防止其指向的对象被垃圾回收，尤其是当一个局部引用指向一个很庞大的对象，或是在一个循环中生成了局部引用。最好的做法就是在使用完该对象后，在该循环尾部把这个引用释放掉，以确保在触发垃圾回收器的时候能够回收。
在局部引用的有效期中，可以传递到别的本地函数中，要强调的是它的有效期仍然只在一次的Java本地函数调用中，所以千万不能用C++全局变量保存它或者把它定义为C++静态局部变量。
2.全局引用
全局引用可以跨越当前线程，在多个native函数中有效，不过需要编程人员手动来释放该引用，全局引用存在期间会防止在Java的垃圾回收器的回收。
与局部引用不同，全局引用的创建不是由JNI自动创建的，全局引用是需要调用NewGlobalRef函数，而释放它需要使用ReleaseGlobalRef函数。
3.弱全局引用
弱全局引用是Java 1.2新出来的功能，与全局引用相似，创建和删除都需要由编程人员来进行，这种引用与全局引用一样可以在多个本地代码中有效，也跨越多线程有效。不一样的是，这种引用将不会阻止垃圾回收器回收这个引用所指向的对象，使用NewWeakGlobalRef和ReleaseWeakGlobalRef来产生和解除引用。
关于引用的一个函数如下：
上述的六种方法很好理解，这里就不做解释了。
这个函数是用来比较两个引用是否相等，但是对于弱全局引用还有一个特别的功能，如果把NULL传入要比较的对象中，就能够判断弱全局引用所指向的Java对象是否被回收。
缓存jfieldID/jmethodID，取得jfieldID和jmethodID的时候会通过该属性/方法名称加上签名来查询相应的jfieldID/jmethodID。这种查询相对来说开销大，我们可以将这些FieldID/MethodID缓存起来，这样就需要查询一次，以后就是用缓存起来的FieldID/MethodID了。
2.7.2 缓存方法
1.在用的时候缓存
在native代码中使用static局部变量来保存已经查询过的id，这样就不会在每次函数调用时查询，而只要第一次查询成功后就保存起来了。不过在这种情况下就不得不考虑多线程同时调用此函数时可能会招致同时查询的危机，不过这种情况是无害的，因为查询同一个属性方法的ID通常返回的是一样的值：
static jfieldID fieldID_string=NULL；这段代码只执行一次。
2.在Java类初始化时缓存
更好的一个方式是在任何native函数调用前把ID全部存起来，可以让Java在第一次加载这个类的时候首先调用本地代码初始化所有的jfieldID/jmethodID，这样就可以省去多次确定ID是否存在的语句。当然，这些jfieldID/jmethodID是定义在C/C++的全局，使用这种方式还是有好处的，当Java类卸载或者重新加载的时候，也会调用该本地代码来重新计算ID的。
在Java中使用静态代码块进行初始化。
2.8 本章小结
本章主要介绍了Android中的NDK开发，其实Android中的NDK就是Java中的JNI，两者没有本质区别，特别是在语法和开发流程上几乎是一样的。后续章节有很多地方会用到这里的相关知识，建议读者能够自己独立编写出一个native的案例，为后面的学习做准备。
第3章 Android中开发与逆向常用命令总结
Android中开发和逆向用到的命令很多，本章介绍一些隐蔽但却非常好用的命令，可以帮助快速找到问题，这些命令都是我在开发实践中总结出来的，大家不妨了解一下。
3.1 基础命令
基础命令是用得最多的，下面介绍两个基础命令。
1.cat命令
cat命令主要用于查看文件内容，这个命令的重要性不言而喻，有时候想查看文件信息，当然可以借助软件查看，但是这个命令非常便捷，更重要的是它可以结合grep过滤内容信息：
记住一点：Linux中的过滤命令是grep，Windows中的过滤命令是findstr。
2.echo/touch命令
echo和touch命令可以方便地写文件，下面看一下这两个命令的结合使用：
这里可以看到用echo和touch命令写内容到文件中，然后用cat命令读取文件信息。这里还用到了内容重定向符号“>”和“>>”，这两个符号也是非常有用的，有时候在执行一条命令时可能输出的结果非常多，这时就需要借助重定向命令把结果输出到文本中。后面还会提到这个用途。
3.2 非shell命令
我把常用命令分为非shell命令和shell命令，当然这样分类有点不合常规。为了好理解，我把需要提前用adb shell命令运行的命令叫做shell命令，直接用adb shell运行的命令叫做非shell命令。本节介绍非shell命令，下一节介绍shell命令。
1.adb shell dumpsys activity top
说明：可以查看当前应用的activity信息。
用法：运行需要查看的应用。
案例：
延伸：如果直接运行adb shell dumpsys也是可以的，只是会把当前系统中所有应用运行的四大组件都会打印出来，而这时候会发现打印的内容非常多，就需要借助之前说到的信息重定向了，具体做法如下。
这里还借助了Windows中的start命令，可以直接利用系统默认程序打开文本内容。而且我在以往逆向应用的时候，很多时候都用到这个命令来找到突破口。
2.adb shell dumpsys package
说明：可以查看指定包名应用的详细信息（相当于应用的AndroidManifest.xml中的内容）。