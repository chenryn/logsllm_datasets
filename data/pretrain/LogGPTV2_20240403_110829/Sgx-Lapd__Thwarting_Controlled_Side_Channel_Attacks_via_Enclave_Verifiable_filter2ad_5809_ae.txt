314.7
229.8
186.2
63.2
384.7
241.9
316.1
336.2
85.7
85.7
50.9
244.1
the instrumented code information. Sgx-Lapd Linker scans that information to
ﬁnd all the direct CFTs for which the veriﬁcation code does not need to be run
and patches them with an unconditional branch. The patch number for NXD
approach is larger. Currently, Sgx-Lapd does not instrument the library code.
We cannot use call-ret pair to check page fault, and thus veriﬁcation code of
CFT to library call need to be skipped. Note that this should not be a limitation
of Sgx-Lapd since in real application, the enclave code is built in static linked
binary [1]. Sgx-Lapd can instrument all the enclave code.
Runtime Performance. Sgx-Lapd slows down the program execution time,
which is caused by the additional page fault detection code inserted before each
cross-page CFT. We evaluated the slowdown in both SPEC2006 and our own
SGX-nbench. For SPEC2006, we measured the execution time overhead for each
benchmark by running the instrumented benchmarks on their reference data sets
10 times, with a maximum variance of 2%. In Fig. 7, we present the execution
time overhead for each SPEC2006 benchmark, shown as a percent increase over
the normalized baseline performance of the non-instrumented version of each
benchmark. Similar to space overhead, the NXD approach has a larger execution
376
Y. Fu et al.
w/NPD
w/NXD
900
800
700
600
500
400
300
200
100
0
401.bzip
400.perlbench
471.om netpp
482.sphinx3
988.specrand
450.soplex
999.specrand
462.libquantum
453.povray
458.sjeng
445.gobm k
403.gcc
429.mcf
470.lbm
473.astar
464.h264ref
456.hm mer
483.xalancbm k
447.dealII
444.nam d
433.milc
Fig. 7. Percent overhead for each of the SPEC2006 benchmarks.
w/NPD
w/NXD
200
180
160
140
120
100
80
60
40
20
0
NumericSort
String Sort
Bitﬁeld
FP E m ulation
Fourier
Assignment
Idea
Huffman
Decom position
NeuralNet
L U
Fig. 8. Percent overhead for each of the SGX-nbench benchmarks.
time overhead than NPD. In general, benchmarks with a larger number of CFTs
will have higher overhead. As shown in Table 1, most of the veriﬁcation code in
483.xalancbmk cannot be skipped, which is why it has the largest overhead. On
average, NPD introduces 120% overhead on SPEC2006, while NXD introduces
183% overhead.
For SGX-nbench, we used the performance result reported by the benchmark
itself. In particular, SGX-nbench runs its benchmarks multiple times, taking the
mean and standard deviation until it reaches a conﬁdence threshold such that
the results are 95% statistically certain. In Fig. 8, we present the execution time
overhead for each SGX-nbench benchmark, shown as a percent increase over the
normalized baseline of the non-instrumented version. The average overhead of
SGX-nbench is only 60% with NPD and 42% with NXD, smaller than SPEC2006.
This is because Sgx-Lapd only instruments the code inside the enclave. The host
application code is not instrumented and has no overhead. This demonstrates
the true performance of Sgx-Lapd in real SGX programs.
SGX-LAPD: Thwarting Controlled Side Channel Attacks
377
7 Discussion
Sgx-Lapd relies on the enclave code itself to detect page faults and verify
whether an OS indeed provides large pages. All the code outside the enclave
is not trusted, which means both the user level sig handler and the kernel
level system exception handler can be malicious. According to the detailed steps
in exception handling described in Fig. 3, we can notice that an attacker can
execute the eight step exception handling instead of the three step page fault
handling to reset the GPRSGX.RIP to some other instructions. But this relies on
collaboration from the enclave code, which is trusted. Therefore, we have to note
that such an attack is impossible unless the enclave code itself is compromised.
Meanwhile, we note that there might exist a race condition for a malicious
OS to reset the EXITINFO.VECTOR right after entering the enclave as illustrated
in Fig. 4. More speciﬁcally, a malicious OS can ﬁrst launch the page fault attack,
causing EXITINFO.VECTOR to be set. When control returns to the enclave again
but before our veriﬁcation code, the malicious OS injects another interrupt (e.g.,
timer interrupt or other faults such as GP) and makes the enclave exit again (to
reset EXITINFO.VECTOR and evade our detection). Fortunately, such an attack
is challenging to launch. In particular, to launch this attack, attackers have to
execute the enclave program using single step execution; otherwise it will be very
challenging for them to control the timing. However, there is no way to execute
enclave program using single step in the deployment mode (only debugging mode
can), and attackers must rely on the extremely low probability to inject the
interrupt or exception right after entering the enclave and before our checking
code. But this time window is extremely short (just a few instructions).
In addition, there is a lot of room for further improvement of Sgx-Lapd,
particularly on where to instrument our detection code. For instance, our current
design overly inserts a lot of intra-page control ﬂow transfer page fault detection
code in the enclave binary, though we have patched the binary to skip executing
that code. While our current design can be acceptable for small enclave bina-
ries, especially considering the fact that we already ask the SGX to provide 2 MB
pages for the enclave code (such a design already wastes a large volume of space),
we certainly would like to further eliminate this unnecessary code. We believe
this would require iterative processing and instruction relocation. We leave this
to one of our future works. On the other hand, if we were able to precisely iden-
tify the input-dependent CFTs, we would not have to insert excessive amounts
of detection code. Therefore, the second avenue for future improvement is to
identify the input-dependent CFTs. However, this is also a non-trivial task for
a compiler since it would require a static input taint analysis. We leave this to
another of our future works.
Finally, Sgx-Lapd only stops code page fault attacks; attackers can still
trigger data page faults. As mentioned in Sect. 3.1, we leave the defense for data
page fault attacks to future work. We also would like to note that practical
controlled channel attacks often require two kinds of page fault patterns, as
demonstrated by Xu et al. [31]. The ﬁrst is the code page pattern which indicates
the start or end of a speciﬁc function. The second can be either a code page fault
378
Y. Fu et al.
pattern or a data page fault pattern, but it critically depends on the ﬁrst code
page fault pattern to be eﬀective. By removing only code page fault patterns,
Sgx-Lapd can still make data page fault attacks much harder.
8 Conclusion
We have presented Sgx-Lapd, a system that leverages enclave veriﬁable large
paging to defeat controlled page fault side channel attacks based on the insight
that large pages can signiﬁcantly reduce benign page fault occurrence. A key
contribution of Sgx-Lapd is a technique that explicitly veriﬁes whether an OS
has provided large pages by intentionally triggering a page fault at each cross
small page control ﬂow transfer instruction and validating with the internal SGX
data structure updated by the hardware. We have implemented Sgx-Lapd with
a modiﬁed LLVM compiler and an SGX Linux kernel module. Our evaluation
with a ported real SGX benchmark SGX-nbench shows that, while space and
runtime overhead can be somewhat high, as a ﬁrst step solution Sgx-Lapd
can still be acceptable especially considering the diﬃculties in ﬁghting for the
controlled side channel attacks. Finally, the source code of Sgx-Lapd is available
at https://github.com/utds3lab/sgx-lapd, and the source code of SGX-nbench is
available at https://github.com/utds3lab/sgx-nbench.
Acknowledgement. We thank Mona Vij from Intel for the assistance of the test with
SGX-v2. We are also grateful to the anonymous reviewers for their insightful comments.
This research was partially supported by AFOSR under grant FA9550-14-1-0119, and
NSF awards CNS-1453011, CNS-1564112, and CNS-1629951. Any opinions, ﬁndings,
conclusions, or recommendations expressed are those of the authors and not necessarily
of the AFOSR and NSF.
References
1. Intel software guard extensions (Intel SGX) SDK. https://software.intel.com/
en-us/sgx-sdk
2. The Linux kernel archives. https://www.kernel.org/doc/Documentation/vm/
hugetlbpage.txt
3. Intel
64
and IA-32
architectures
software developer’s manual
(2015).
http://www.intel.com/content/dam/www/public/us/en/documents/manuals/
64-ia-32-architectures-software-developer-manual-325462.pdf
4. Backes, M., N¨urnberger, S.: Oxymoron: making ﬁne-grained memory randomiza-
tion practical by allowing code sharing. In: USENIX Security Symposium (2014)
5. Bauman, E., Lin, Z.: A case for protecting computer games with SGX. In: Proceed-
ings of the 1st Workshop on System Software for Trusted Execution, p. 4. ACM
(2016)
6. Baumann, A., Peinado, M., Hunt, G.: Shielding applications from an untrusted
cloud with haven. In: Proceedings of the 11th Symposium on Operating Systems
Design and Implementation (OSDI), Broomﬁeld, pp. 267–283, October 2014
SGX-LAPD: Thwarting Controlled Side Channel Attacks
379
7. Chandra, S., Karande, V., Lin, Z., Khan, L., Kantarcioglu, M., Thuraisingham, B.:
Securing data analytics on SGX with randomization. In: Proceedings of the 22nd
European Symposium on Research in Computer Security, Oslo, September 2017
8. Checkoway, S., Shacham, H.: Iago attacks: why the system call API is a bad
untrusted RPC interface. In: Proceedings of the 18th International Conference on
Architectural Support for Programming Languages and Operating Systems (ASP-
LOS), Houston, pp. 253–264, March 2013
9. Chen, X., Garﬁnkel, T., Lewis, E.C., Subrahmanyam, P., Waldspurger, C.A.,
Boneh, D., Dwoskin, J., Ports, D.R.: Overshadow: a virtualization-based approach
to retroﬁtting protection in commodity operating systems. In: Proceedings of the
13th International Conference on Architectural Support for Programming Lan-
guages and Operating Systems (ASPLOS XIII), Seattle, pp. 2–13. ACM (2008)
10. Giuﬀrida, C., Kuijsten, A., Tanenbaum, A.S.: Enhanced operating system secu-
rity through eﬃcient and ﬁne-grained address space randomization. In: USENIX
Security Symposium, pp. 475–490 (2012)
11. Goldreich, O.: Towards a theory of software protection and simulation by oblivious
rams. In: Proceedings of the Nineteenth Annual ACM Symposium on Theory of
Computing, pp. 182–194. ACM (1987)
12. Hand, S.M.: Self-paging in the Nemesis operating system. In: OSDI, vol. 99, pp.
73–86 (1999)
13. Hoekstra, M., Lal, R., Pappachan, P., Phegade, V., Del Cuvillo, J.: Using innovative
instructions to create trustworthy software solutions. In: Proceedings of the 2nd
International Workshop on Hardware and Architectural Support for Security and
Privacy (HASP), Tel-Aviv, pp. 1–8 (2013)
14. Intel: Intel software guard extensions programming reference (rev2), 329298-002US,
October 2014
15. Karande, V., Bauman, E., Lin, Z., Khan, L.: Securing system logs with SGX. In:
Proceedings of the 12th ACM Symposium on Information, Computer and Com-
munications Security, Abu Dhabi, April 2017
16. Klein, G., Elphinstone, K., Heiser, G., Andronick, J., Cock, D., Derrin, P.,
Elkaduwe, D., Engelhardt, K., Kolanski, R., Norrish, M., Sewell, T., Tuch, H.,
Winwood, S.: seL4: Formal veriﬁcation of an OS kernel. In: Proceedings of the
ACM SIGOPS 22nd Symposium on Operating Systems Principles (SOSP 2009),
pp. 207–220 (2009)
17. McCune, J.M., Parno, B.J., Perrig, A., Reiter, M.K., Isozaki, H.: Flicker: an exe-
cution infrastructure for TCB minimization. In: Proceedings of the ACM EuroSys
Conference, Glasgow, pp. 315–328, March 2008
18. McKeen, F., Alexandrovich, I., Berenzon, A., Rozas, C.V., Shaﬁ, H., Shanbhogue,
V., Savagaonkar, U.R.: Innovative instructions and software model for isolated
execution. In: Proceedings of the 2nd International Workshop on Hardware and
Architectural Support for Security and Privacy (HASP), Tel-Aviv, pp. 1–8 (2013)
19. Ohrimenko, O., Schuster, F., Fournet, C., Mehta, A., Nowozin, S., Vaswani, K.,
Costa, M.: Oblivious multi-party machine learning on trusted processors. In: 25th
USENIX Security Symposium (USENIX Security 2016), Austin, pp. 619–636.
USENIX Association, August 2016
20. Perez, R., Sailer, R., van Doorn, L., et al.: vTPM: virtualizing the trusted plat-
form module. In: Proceedings of the 15th USENIX Security Symposium (Security),
Vancouver, pp. 305–320, July 2006
21. Pinkas, B., Reinman, T.: Oblivious RAM revisited. In: Rabin, T. (ed.) CRYPTO
2010. LNCS, vol. 6223, pp. 502–519. Springer, Heidelberg (2010). doi:10.1007/
978-3-642-14623-7 27
380
Y. Fu et al.
22. Porter, D.E., Boyd-Wickizer, S., Howell, J., Olinsky, R., Hunt, G.C.: Rethinking
the library OS from the top down. In Proceedings of the 16th International Confer-
ence on Architectural Support for Programming Languages and Operating Systems
(ASPLOS), Newport Beach, pp. 291–304, March 2011
23. Santos, N., Raj, H., Saroiu, S., Wolman, A.: Using ARM TrustZone to build a
trusted language runtime for mobile applications. In: ACM SIGARCH Computer
Architecture News, vol. 42, pp. 67–80. ACM (2014)
24. Schuster, F., Costa, M., Fournet, C., Gkantsidis, C., Peinado, M., Mainar-Ruiz,
G., Russinovich, M.: VC3: Trustworthy data analytics in the cloud using SGX. In:
Proceedings of the 2015 IEEE Symposium on Security and Privacy (2015)
25. Seshadri, A., Luk, M., Qu, N., Perrig, A.: SecVisor: a tiny hypervisor to provide
lifetime kernel code integrity for commodity OSes. In: Proceedings of Twenty-
First ACM SIGOPS Symposium on Operating Systems Principles (SOSP 2007),
Stevenson, Washington, DC, pp. 335–350 (2007)
26. Shih, M.-W., Lee, S., Kim, T., Peinado, M.: T-SGX: eradicating controlled-channel
attacks against enclave programs. In: Proceedings of the 2017 Annual Network and
Distributed System Security Symposium (NDSS), San Diego (2017)
27. Shinde, S., Chua, Z.L., Narayanan, V., Saxena, P.: Preventing your faults
from telling your secrets: defenses against pigeonhole attacks. arXiv preprint
arXiv:1506.04832 (2015)
28. Sun, K., Wang, J., Zhang, F., Stavrou, A.: SecureSwitch: BIOS-assisted isolation
and switch between trusted and untrusted commodity OSes. In: Proceedings of
the 19th Annual Network and Distributed System Security Symposium (NDSS),
San Diego, February 2012
29. PaX Team: Pax address space layout randomization (aslr). http://pax.grsecurity.
net/docs/aslr.txt
30. Wang, J., Stavrou, A., Ghosh, A.: HyperCheck: a hardware-assisted integrity mon-
itor. In: Jha, S., Sommer, R., Kreibich, C. (eds.) RAID 2010. LNCS, vol. 6307,
pp. 158–177. Springer, Heidelberg (2010). doi:10.1007/978-3-642-15512-3 9
31. Xu, Y., Cui, W., Peinado, M.: Controlled-channel attacks: deterministic side chan-
nels for untrusted operating systems. In: Proceedings of the 2015 IEEE Symposium
on Security and Privacy (2015)