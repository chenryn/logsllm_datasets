符串里。
如果不存在足够的正则匹配来满足你的上限，那么Split()会按照所有可用的正则匹配来
进行拆分，它返回的数组中包含的字符串数量因此会比你指定的参数要少。
regexObj.Split(subject，1)不会对字符串进行拆分，而是直接把整个目标字符串作为数组
的唯一元素返回。regexObj.Split(subject,0)会按照所有正则匹配进行拆分，它的效果和
忽略第二个参数时的SplitO是一样的。如果使用一个负数作为参数，那么就会导致SplitO
产生一个ArgumentOutOfRangeException例外。
如果你使用第二个参数指定了返回数组中的最大字符串数量，那么还可以指定一个可
选的第三个参数来说明正则表达式应当开始查找匹配的字符索引位置。实质上，你传
递给第三个参数的整数，也就是你想要正则表达式忽略的位于字符串开头的字符数量。
在你已经开始对字符串进行了一部分处理，而只想对剩余的字符串进行拆分时，就会
需要用到这样的处理。
正则表达式忽略的字符还是会被添加到返回的数组中。数组中的第一个字符串是在
你指定的起始位置之后的第一个正则匹配之前的整个子串，其中也包含了在指定起
始位置之前的所有字符。如果你指定了第三个参数，那么它必须要大于0，并且小于
目标字符串的长度。否则，SplitO会产生一个ArgumentOutOfRangeException例外。
与MatchO不一样的是，SplitO不会允许你指定一个参数来设定想要正则表达式搜索
190第3章
www.TopSage.com
---
## Page 207
的子串的长度。
如果在目标学符事的开始产生了一个匹配，那么在返回数组中的第一个字符串就是一
个空串。当在目标字符串中找到两个紧接着的正则匹配，而二者之间不存在任何文本
的话，那么也会在返回数组中添加一个空事。如果在自标字符事的结尾产生了一个匹
配，那么数组中的最后一个元素也是一个空串。
Java
如果你只需要拆分一个学符事，那么可以直接用自标字符串调用SplitO方法。把正则表
达式作为唯一的参数。这个方法会调用Pattern.compile("regex").split（subjectString)。
如果你想要拆分多个字符串，那么就应当使用Patterm.compileO厂来创建一个Pattem对
象。这样，你的正则表达式就只需要编译一次，然后就可以使用你的Patterm实例来调
用SplitO方法，把目标字符串作为它的参数。这里没必要再创建一个Matcher对象。在
Matcher类中根本不支持SplitO方法。
Patterm.splitO会接受一个可选的第二个参数，但是String.splitO却不能。你可以使用这第
二个参数来传递你最终想要得到的拆分字符串的最大个数。例如，如果你调用
Pattern.split(subject,3)，那么就会得到一个最多包含3个字符串的数组。SplitO函数会尝
试找到2个正则匹配，然后返回一个数组，其中包括第一个匹配之前的文本、两个匹
配之间的文本和第二个匹配之后的文本。在该自标学符事之后所有可能的正则匹配都
会被忽略掉，因此会被全部放到数组中的最后一个字符串里。如果不存在足够的正则
匹配来满足你的上限，那么SplitO会按照所有可用的正则匹配来进行拆分，从而它返回
的数组中包含的字符串数量因此会比你指定的参数要少。regexObj.Split(subject,1）不会
对字符串进行拆分，而是直接把整个自标字符事作为数组的唯一元素返回。
如果在目标字符串的开始产生了一个匹配，那么在返回数组中的第一个字符串就是一
那么也会在返回数组中添加一个空串。如果在目标字符串的结尾产生了一个匹配，那
么数组中的最后一个元素也是一个空串。
然而，Java会清除位于数组最后的空字符串。如果你想要包含空字符串，那么就需要
向Patterm.splitO传递-一个负数作为第二个参数。这会告诉Java尽可能多地拆分字符串，
并且保留位于数组最后的空串。但是，你不能告知Java对一个字符串拆分指定的次数，
同时还要求在数据结尾保留空串。
JavaScript
在JavaScript中，使用你想要拆分的字符串来调用split(方法。把正则表达式作为唯一
的参数就可以得到一个学符事数组，其中会对目标字符事尽可能多次进行拆分。你还
使用正则表达式编程191
www.TopSage.com
---
## Page 208
这个参数应当是一个正整数。如果你传递的是0，那么会得到一个空数组。如果没有使
用第二个参数，或者传递了一个负数，那么字符串就会被拆分尽量多次。在正则表达
式中使用/g标志（实例3.4）并不会产生任何作用。
不幸的是，所有流行的Web浏览器都没有按照JavaScript标准中的描述来实现splitO
方法的每个特性。具体来说，有些浏览器在数组中包含了捕获分组匹配的文本，有些
则不然。那些包含了捕获分组的浏览器在处理非参与分组时，也没有进行一致的处理。
为了避免这些问题，我们建议你在传递给splitO的正则表达式中只使用非捕获分组（实
例2.9)。
有些JavaScript实现会忽略在返回数组中的长度为0的字符串。当两个正则匹配完全紧
邻，或者正则匹配到字符串的开始或结尾的时候，那么数组中就必须要包含长度为0
的字符串。因为无法通过对你的正则表达式进行简单修改来解决这个问题，所以通常
来说最好还是选择使用更复杂的JavaScript解决方案。这个解答中包含了所有长度为0
的字符串，但是你可以很容易地对它进行编辑，把长度为0的学符串去掉。
这个较长的解决方案是在实例3.12之上的修改。它把正则匹配之间的文本以及正则匹
配自身都添加到了数组中。为了得到位于匹配之间的文本，我们使用了在实例3.8中讲
解的匹配详细信息。
如果你想要一个遵循标准的String.prototype.split实现，而且还希望在所有浏览器中都
可以工作，那么可以参考StevenLevithan给的解决方案：http:/blog.stevenlevithan
com/archives/cross-browser-split
PHP
调用preg_splitO就可以按照正则匹配把字符串拆分成一个字符串数组。使用正则表达式
作为第一个参数，目标字符事作为第二个参数。如果你省略了第二个参数，那么$就
会被用作目标字符事。
你可以传递一个可选的第三个参数来指定最终想要得到的拆分字符串的最大数量。例
如，如果你调用preg_split(Sregex，$subject,3)，那么就会得到--个最多包含3个字符串
的数组。preg_splitO函数会尝试找到2个正则匹配，然后返回一个数组，其中包括第一
个匹配之前的文本、两个匹配之间的文本和第二个匹配之后的文本。在该目标字符串
之后的所有可能的正则匹配都会被忽略掉，因此会被全部放到数组中的最后一个字符
串里。如果不存在足够的正则匹配来满足你的上限，那么preg_splitO会按照所有可用的
正则匹配来进行拆分，从而它返回的数组中包含的字符串数量会比你指定的参数要少。
如果没有使用第三个参数，或者把它设为-1，那么字符串就会被拆分尽量多次。
如果在目标字符串的开始产生了一个匹配，那么在返回数组中的第一个字符串就是一
个空串。当在目标字符串中找到两个紧接着的正则匹配，而二者之间不存在任何文本，
那么也会在返回数组中添加一个空串。如果在目标字符串的结尾产生了一个匹配，那
192第3章
www.TopSage.com
---
## Page 209
么数组中的最后一个元素也是一个空串。默认来说，preg_splitO会在它返回的数组中包
含所有的空串。如果你不想要数组中的空串，那么你可以使用常量PREG_SPLIT_NO
EMPTY来作为第4个参数。
Perl
调用splitO就可以按照正则匹配把字符串拆分成一个字符串数组。使用正则表达式作为
第个参数，目标字符串作为第二个参数。
你还可以传递一个可选的第三个参数来指定最终想要得到的拆分字符串的最大数量。
组。splitO函数会尝试找到2个正则匹配，然后返回一个数组，其中包括第一个匹配之
前的文本、两个匹配之间的文本和第二个匹配之后的文本。在该目标字符串之后的所
有可能的正则匹配都会被忽略掉，因此会被全部放到数组中的最后一个字符串里。如
果不存在足够的正则匹配来满足你的上限，那么splitO会按照所有可用的正则匹配来进
行拆分，从而它返回的数组中包含的字符事数量会因此比你指定的参数要少。
如果你没有使用第三个参数，那么Perl会决定最适合的长度限制。如果像这个实例中
一样，把结果赋给了一个数组变量，那么字符事就会被拆分尽量多次。如果把结果赋
给了一个标量变量的列表，那么Perl会把上限设为变量的个数加1。换句话说，Perl
会尝试填满所有的变量，但是会丢掉没有拆分的剩余部分。例如，（Sone，Stwo，Sthree)=
split（/，)会使用上限4来对$_进行拆分。
如果在目标字符串的开始产生了--个匹配，那么在返回数组中的第一个字符串就是-
个空串。当在目标字符串中找到两个紧接着的正则匹配，而二者之间不存在任何文本，
那么也会在返回数组中添加一个空串。如果在目标字符串的结尾产生了一个匹配，那
么数组中的最后一个元素也是一个空串。
Python
re模块中的splitO函数会使用正则表达式来拆分字符串。把你的正则表达式作为第一个
参数，而目标字符串作为第二个参数。全局的splitO函数不支持包含正则表达式选项的
参数。
re.splitO会调用re.compileO，然后使用编译好的正则表达式对象来调用splitO方法。这
个方法只有一个必需的参数：目标字符串。
splitO函数的两种形式都会返回一个位于所有正则匹配之间的文本列表。它们都接受一
个可选的参数，用来指定你想要把字符串进行拆分的最大次数。如果你省略了这个参
数，或者把它设置为0，那么字符串就会被拆分尽量多次。如果你传递了一个正整数，
那么它就是用来拆分字符事的正则匹配的最大个数。因此返回的结果列表中的学符串
个数是你指定的个数加1。最后一个学符事是在最后一个正则匹配之后没有被拆分的目
使用正则表达式编程193
www.TopSage.com
---
## Page 210
标字符串中的所有剩余部分。如果能找到的匹配个数比你指定的个数要少，那么字符
串就会按照所有正则匹配进行拆分，而不会产生任何错误。
Ruby
使用目标字符串来调用splitO，并且把正则表达式作为第一个参数，就可以按照正则匹
配把字符串拆分成一个字符串数组。
的最大数目。例如，如果调用subject.split(re,3)，那么你就会得到一个最多包含3个字
符串的数组。splitO函数会尝试找到2个正则匹配，然后返回一个数组，其中包括第-
个匹配之前的文本、两个匹配之间的文本和第二个匹配之后的文本。在该目标字符串
之后所有可能的正则匹配都会被忽略掉，因此会被全部放到数组中的最后一个字符申
里。如果不存在足够的正则匹配来满足你的上限，那么splitO会按照所有可用的正则四
配来进行拆分，从而它返回的数组中包含的字符串数量会比你指定的个数要少。split（re
1）则不会对字符事进行拆分，只是把原始字符事作为数组的唯一元素返回。
如果在目标字符串的开始产生了-个匹配，那么在返回数组中的第一个字符串就是一
个空串。当在目标字符串中找到两个紧接着的正则匹配，而二者之间不存在任何文本，
那么也会在返回数组中添加一个空串。如果在目标字符串的结尾产生了一个匹配，那
么数组中的最后一个元素也是一个空串。
然而，Ruby会清除位于数组最后的空字符串。如果你想要包含空字符串，那么就需要
向splitO传递一个负数作为第二个参数。这会告知Ruby尽可能多地拆分字符串，并且
保留位于数组最后的空串。但是，你不能告知Ruby对一个字符串拆分指定的次数，同
时还要求在数据结尾保留空串。
参见
实例3.20。
3.20拆分字符串，保留正则匹配
问题描述
你想要使用正则表达式来拆分一个字符串。在拆分之后，你会得到一个字符串的数组
或列表，其中会包含位于正则表达式匹配之间的文本、以及正则匹配自身。
假设你想要按照HTMLtag来拆分一个包含HTMLtag的字符串，但是还想要保留
其中的HTMLtag。例如，对I·like·bold·and·italic·fonts进行拆分后会
得到一个包含9个字符串的数组：Iolike·、、bold、、·and·、、italic、
和·fonts。
194第3章
www.TopSage.com
---
## Page 211
解决方案
C#
当你打算只使用同一个正则表达式处理少量字符事的时候，可以使用如下的静态调用：
(]>))x=[
如果你想要把同一个正则表达式用于大量的字符串之上，那么就需要构造一个Regex
对象：
（(]>)）xabay mau=aoxabaxxaba
VB.NET
当你打算只使用同一个正则表达式处理少量字符串的时候，可以使用如下的静态调用：
如果想要把同一个正则表达式用于大量的字符事之上，那么就需要构造-个Regex
对象：
（]>））xboxb
Dim SplitArray = RegexObj.Split(SubjectString)
Java
List resultList = new ArrayList();
Pattern regex = Pattern.compile("]*>");
Matcher regexMatcher = regex.matcher(subjectString);
int lastIndex = 0;
while (regexMatcher.find()）{
resultList.add(subjectString.substring (lastIndex,
regexMatcher.start()));
resultList.add(regexMatcher.group());
lastIndex = regexMatcher.end() ;
resultList.add(subjectString.substring(lastIndex));
JavaScript
var list =[];
var regex =/]*>/g;
var match = null;
var lastIndex =0;
while (match = regex.exec(subject)){
if (match.index == regex.lastIndex) regex.lastIndex++;
使用正则表达式编程
195
www.TopSage.com
---
## Page 212
//Add the text before the match, as well as the match itself
list.push(subject.substring(lastIndex, match.index), match[0]);
lastIndex = match.index + match[O].length;
上
//Add the remainder after the last match
list.push(subject.substr (lastIndex));
PHP
$resultpreg_split('/(]*>)/'，$subject，-1,
PREG_SPLIT_DELIM_CAPTURE);
Perl
@result =split(m/(]*>)/，$subject）;
Python
如果只需要处理少量字符串，你可以使用全局函数：