第2章
---
## Page 13
的未使用空间)。
（图中使用五个空格来表示五字节
间，所以它的 free 属性的值为 5
buf 数组分配了五字节未使用空
的 SDS 的区别在于，这个 SDS为
"Redis"。这个SDS 和之前展示
/printf函数，通过执行以下语句：
遵循空字符结尾这一惯例的好处是，SDS 可以直接重用一部分C字符串函数库里面的函数。
作，都是由 SDS 函数自动完成的，所以这个空字符对于 SDS 的使用者来说是完全透明的。
len 属性里面，并且为空字符分配额外的1字节空间，以及添加空字符到字符串末尾等操
2.1
Redis 要使用 SDS 而不是C字符串，并在本章的最后列出 SDS 的操作 API。
持久化和客户端状态的时候，我们会看到 SDS 在这两个模块中的应用。
的AOF 缓冲区，以及客户端状态中的输人缓冲区，都是由 SDS 实现的，在之后介绍AOF
本章接下来将对 SDS 的实现进行介绍，说明 SDS 和C字符串的不同之处，解释为什么
 举个例子，如果我们有一个指向图2-1所示 SDS 的指针s，那么我们可以直接使用
图2-2展示了另一个 SDS示例。
来打印出SDS保存的字符串值“Redis"，
printf("名s", s->buf);
SDS 遵循C字符串以空字符结尾的惯例，保存空字符的1字节空间不计算在 SDS 的
口len属性的值为5，表示这个 SDS 保存了一个五字节长的字符串。
 free 属性的值为 0，表示这个 SDS 没有分配任何未使用空间。
struct sdshdr {
每个 sds.h/sdshdr 结构表示一个 SDS 值:
 buf属性是一个char类型的数组，数组的前五个字节分别保存了‘R'、‘e'、'd"、
图 2-1展示了一个 SDS 示例：
‘i'、‘s＇五个字符，而最后一个字节则保存了空字符"\0"。
 SDS 的定义
char buf[l;
/字节数组，用于保存字符串
int free;
//记录 buf 数组中未使用字节的数量
int len;
J。这个 SDS 和之前展示的 SDS一样，都保存了字符串值
sdshdr
free
buf
'R''e'l 'd*|'i''s' Pvo"
，而无须为SDS 编写专门的打印函数。
图 2-2带有未使用空间的 SDS 示例
buf
free
sdshdr
→'r']'e''d'|'i's PVo"
图 2-1SDS示例
第2 章简单动态字符事9
---
## Page 14
10·第一部分数据结构与对象
底层使用 SDS 来实现，所以即使我们对一个非常长的字符串键反复执行 STRLEN命令，也
O(1)，这确保了获取字符串长度的工作不会成为 Redis 的性能瓶颈。例如，因为字符串键在
获取字符串长度所需的复杂度从 O(N)降低到了
何手动修改长度的工作。
API 在执行时自动完成的，使用 SDS无须进行任
SDS 的长度为 11 字节。
序只要访问 SDS 的 len 属性，
SDS 的长度为 5 字节。
序只要访问 SDS 的 len 属性，就可以立即知道
度的复杂度仅为 0(1)。
记录了 SDS 本身的长度，
符串长度的过程。
复杂度为 O(N)。
遇到代表字符串结尾的空字符为止，这个操作的
整个字符串，对遇到的每个字符进行计数，直到
以为了获取一个C字符串的长度，程序必须遍历
2.2.1
比 C字符串更适用于 Redis 的原因。
对比C字符串和 SDS 之间的区别，并说明 SDS
以及功能方面的要求，本节接下来的内容将详细
组的最后一个元素总是空字符‘\0'。
2.2
通过使用 SDS 而不是C字符串，Redis 将
举个例子，对于图2-5 所示的 SDS来说，
和C字符串不同，
举个例子，图2-4展示了程序计算一个C字
设置和更新 SDS 长度的工作是由 SDS 的
因为C字符串并不记录自身的长度信息，所
又例如，对于图 2-6 展示的 SDS 来说，程
C 语言使用的这种简单的字符串表示方式，并不能满足 Redis 对字符串在安全性、效率
例如，图2-3就展示了一个值为"Redis"的C字符串。
根据传统，C语言使用长度为 N+1 的字符数组来表示长度为N 的字符串，并且字符数
接下来的一节将详细地说明未使用空间在 SDS 中的作用。
常数复杂度获取字符串长度
SDS与C字符串的区别
因为 SDS 在 len 属性中
，所以获取一个 SDS 长
，就可以立即知道
，程
sdshdr
free
'R' 'e' 'd' e+ 's+ Po"
'R''e'
'R''e'| 'd''. 's' Po"
'R+ 'e'!'d' +I's' Po"
'r'|'e'| d'| '"!'s' P'o"
'R''e'| 'd*| '+!'s' vo"
buf
图 2-4
len=1
'r''e''d+  i+!'s' ·\o"
len=2
J-'r''e'·d·i]'s' rVo"
图2-55字节长的 SDS
计算C字符串长度的过程
图2-3C字符串
len=3
|"·s· vo
字符串的长度为5字节
停止计数
发现空字符
---
## Page 15
出问题。
操作，所以使用 SDS 既不需要手动修改 SDS 的空间大小，也不会出现前面所说的缓冲区溢
满足的话，API会自动将 SDS 的空间扩展至执行修改所需的大小，然后才执行实际的修改
API需要对 SDS 进行修改时，API会先检查SDS 的空间是否满足修改所需的要求，如果不
导致 s2 保存的内容被意外地修改，如图 2-8 所示。
s1 分配足够的空间，那么在 strcat 函数执行之后，sl的数据将溢出到 s2 所在的空间中，
符串"Redis"，而s2 则保存了字符串“MongoDB"，如图 2-7所示。
时，就会产生缓冲区溢出。
dest 分配了足够多的内存，可以容纳 src 字符串中的所有内容，而一旦这个假定不成立
字符串中的内容拼接到 dest 字符串的末尾：
易造成缓冲区溢出（buffer overfow）。举个例子，/strcat 函数可以将 src
2.2.2
不会对系统性能造成任何影响，因为 STRLEN命令的复杂度仅为 O(1)。
举个例子，假设程序里有两个在内存中紧邻着的C字符串 s1 和 s2，其中 s1 保存了字
除了获取字符串长度的复杂度高之外，C字符串不记录自身长度带来的另一个问题是容
举个例子，SDS 的 API里面也有一个用于执行拼接操作的 sdscat 函数，它可以将一
与C字符串不同，SDS 的空间分配策略完全杜绝了发生缓冲区溢出的可能性：当 SDS 
将s1 的内容修改为"RedisClustér"，但粗心的他却忘了在执行 strcat 之前为
strcat(sl, " Cluster");
如果一个程序员决定通过执行：
因为C字符串不记录自身的长度，所以 strcat 假定用户在执行这个函数时，已经为
char *strcat(char *dest, const char *src);
杜绝缓冲区溢出
'R''e' 'd' Pi"'s'] "I'c· doI'u·I's't'] 'e' ·r'*vo" …
 S1
sdshdr
S1
buf
free
图2-8S1的内容溢出到了 S2 所在的位置上
图2-7在内存中紧邻的两个C字符串
图2-611字节长的 SDS
S2
S2
I'w* l'o* *r* ·1· ·d' Pvo"
第 2章简单动态字将事◆11
---
## Page 16
12第一部分数据结构与对象
"Redis Cluster"，在执行:
次内存重分配操作：
性，所以每次增长或者缩短一个C字符串，程序都总要对保存这个C字符串的数组进行一
个字符空间用于保存空字符）。因为C字符串的长度和底层数组的长度之间存在着这种关联
字符的C字符串来说，这个C字符串的底层实现总是一个N+1个字符长的数组（额外的一
2.2.3
bug 也不是巧合，它和 SDS 的空间分配策略有关，接下来的小节将对这一策略进行说明。
配了13字节的未使用空间，并且拼接之后的字符串也正好是13字节长，这种现象既不是
行拼接＂Cluster"的操作，拼接操作完成之后的 SDS 如图 2-10所示。
之后，sdscat 就会先扩展 s 的空间，然后才执
在发现s目前的空间不足以拼接”Cluster"
将在执行拼接操作之前检查s的长度是否足够，
后才执行拼接操作。
会先检查给定 SDS 的空间是否足够，如果不够的话，sdscat就会先扩展 SDS 的空间，然
个C字符串拼接到给定 SDS 所保存的字符串的后面，但是在执行拼接操作之前，sdscat
正如前两个小节所说，因为C字符串并不记录自身的长度，所以对于一个包含了个
strcat(s, " cluster");
举个例子，如果我们持有一个值为“Redis”的C字符串s，那么为了将s的值改为
口如果程序执行的是缩短字符串的操作，比如截断操作（trim），那么在执行这个操作
口如果程序执行的是增长字符串的操作，比如拼接操作（append），那么在执行这个操
注意，图 2-10 所示的 SDS，sdscat 不仅对这个 SDS 进行了拼接操作，它还为 SDS 分
其中 SDS 值 s 如图 2-9 所示，那么 sdscat
sdscat(s, " Cluster");
例如，如果我们执行：
sdshdr
这一步就会产生内存泄漏。
buf
free
之后，程序需要通过内存重分配来释放字符串不再使用的那部分空间——如果忘了
步就会产生缓冲区溢出。
作之前，程序需要先通过内存重分配来扩展底层数组的空间大小一一如果忘了这一
减少修改字符串时带来的内存重分配次数
+r' e' 'd'*+·s.| .·|·c' |·1. u'| ·s+|'t· 'e'·r' o* .
图 2-10 sdscat 执行之后的 SDS 
nq
sdshdr
len
图 2-9 sdscat 执行之前的 SDS 
---
## Page 17
如果我们执行：
符串增长操作所需的内存重分配次数。
为 SDS 分配额外的未使用空间。
并且需要对 SDS 进行空间扩展的时候，程序不仅会为 SDS 分配修改所必须要的空间，还会
未使用的字节，而这些字节的数量就由 SDS 的 free 属性记录。
度之间的关联：在 SDS 中，buf 数组的长度不一定就是字符数量加一，数组里面可以包含
耗时的操作：
Tutorial"，那么在执行：
举个例子，对于图 2-11 所示的 SDS 值s来说,
 sdscat (s, " cluster");
通过空间预分配策略，Redis 可以减少连续执行字
如果对 SDS 进行修改之后，SDS 的长度（也即是len 属性的值）将小于1MB,
其中，额外分配的未使用空间数量由以下公式决定：
空间预分配用于优化 SDS 的字符串增长操作：当 SDS 的 API 对一个 SDS 进行修改,
通过未使用空间，SDS 实现了空间预分配和情性空间释放两种优化策略。
为了避免C字符串的这种缺陷，SDS 通过未使用空间解除了字符串长度和底层数组长
口 但是 Redis 作为数据库，经常被用于速度要求严苛、数据被频繁修改的场合，如果
口在一般程序中，如果修改字符串长度的情况不太常出现，那么每次修改都执行一次
因为内存重分配涉及复杂的算法，并且可能需要执行系统调用，所以它通常是一个比较
口
1. 空间预分配 
之前，我们需要再次使用内存重分配扩展s 的空间，诸如此类。
strcat(s, " Tutorial");
之后，如果我们又打算将s的值从"RedisCluster"改为"RedisCluster 
之前，我们需要先使用内存重分配操作，扩展s 的空间。
内存重分配是可以接受的。
际长度将为 30 MB + 1MB +1byte。
配 1MB 的未使用空间，SDS 的 buf 数组的实
使用空间。举个例子，如果进行修改之后，SDS 的1en 将变成 30MB，那么程序会分
如果对 SDS 进行修改之后，SDS 的长度将大于等于 1MB，那么程序会分配 1MB 的未
节，那么程序也会分配 13 字节的未使用空间，SDS 的 buf 数组的实际长度将变成
free 属性的值相同。举个例子，如果进行修改之后，SDS 的len 将变成13字
那么程序分配和 len 属性同样大小的未使用空间，这时 SDS len 属性的值将和
13+13+1=27字节（额外的一字节用于保存空字符）。
可能还会对性能造成影响。
的时间就会占去修改字符串所用时间的一大部分，如果这种修改频繁地发生的话
每次修改字符串的长度都需要执行一次内存重分配的话，那么光是执行内存重分配
free
sdshdr
图 2-11执行 sdscat 之前的 SDS
buf
Pr·'e'+d·+ 's'PO"
第 2章 简单动态字符串◆13
---
## Page 18
14·第一部分数据结构与对象
在C字符串中出现过的字符。
将这些字节的数量记录起来，并等待将来使用。
字符串时，程序并不立即使用内存重分配来回收缩短后多出来的字节，而是使用 free 属性
降低为最多 N次。
就会直接使用未使用空间，而无须执行内存重分配。
9字节的”Tutoria1"，执行 sdscat 之后的 SDS 如图 2-13所示。
未使用空间同样修改为13字节，如图 2-12 所示。
举个例子，sdstrim 函数接受一个 SDS 和一个C字符串作为参数，移除 SDS 中所有
通过这种预分配策略，SDS 将连续增长 N 次字符串所需的内存重分配次数从必定 N 次
sdshdr
情性空间释放用于优化 SDS 的字符串缩短操作：当 SDS 的 API 需要缩短 SDS 保存的
2.情性空间释放
在扩展 SDS 空间之前，SDS API会先检查未使用空间是否足够，如果足够的话，API
buf
Eree
那么这次 sdscat 将不需要执行内存重分配，因为未使用空间里面的 13字节足以保存
那么 sdscat 将执行一次内存重分配操作，将 SDS 的长度修改为 13字节，并将 SDS 的
比如对于图 2-14所示的 SDS 值s来说，执行:
4
sdscat(s, " Tutorial");
如果这时，我们再次对 s 执行：
sdshdr
buf
13
sdshdr
r  e ·d's|o 'c no u 's't' 'e r Iol -
buf
→x·y·| x a'y· y·b·ex··y·'y·Pvo"
图 2-13再次执行 sdscat 之后的 SDS
图 2-14 执行 sdstrim 之前的 SDS
图2-12执行 sdscat 之后 sDS 
---
## Page 19
"Redis"，而忽略之后的“Cluster"。
那么这种格式就不能使用C字符串来保存，因为C字符串所用的函数只会识别出其中的
进制数据。
制使得C字符串只能保存文本数据，而不能保存像图片、音频、视频、压缩文件这样的二
符串里面不能包含空字符，否则最先被程序读人的空字符将被误认为是字符串结尾，这些限
2.2.4
使用空间，所以不用担心性空间释放策略会造成内存浪费。
能有的增长操作提供了优化。
间已经足以拼接6个字节长的”Redis"，如图2-16所示。
空间就可能会派上用场。
间作为未使用空间保留在了SDS 里面，如果将来要对 SDS 进行增长操作的话，这些未使用
举个例子，如果有一种使用空字符来分割多个单词的特殊数据格式，如图 2-17所示，
C字符串中的字符必须符合某种编码（比如ASCII），并且除了字符串的末尾之外，字
与此同时，SDS 也提供了相应的 API，让我们可以在有需要时，真正地释放 SDS 的未
通过性空间释放策略，SDS 避免了缩短字符串时所需的内存重分配操作，并为将来可
那么完成这次 sdscat 操作将不需要执行内存重分配：因为 SDS 里面预留的 8字节空
举个例子，如果现在对s执行：
注意执行 sdstrim 之后的 SDS 并没有释放多出来的 8字节空间，而是将这 8字节空
sdscat(s, " Redis");
会将 SDS 修改成图 2-15所示的样子。
sdstrim(s，"xY")；//移除sDs字符串中的所有‘x’和‘Y"
二进制安全
sdshdr
buf
sdshdr
buf
→abe\o
图 2-15 执行 sdstrim 之后的 SDS
图 2-16 执行 sdscat 之后的 SDS 
第 2 章简单动态字符事◆15
---