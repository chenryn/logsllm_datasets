computed by applying a Derive-Secret function to this value.
This is not strictly necessary due to the assumption of perfect
cryptography, but it makes it easier to connect our model to the
specification.
3.4 Advanced features
In our model we capture a number of complicated interactions and
logic flows inherent to the TLS 1.3 handshake, greatly improving on
preceding models, adding features to the model which we consider
to be ‘advanced’.
Group negotiation. We model the client and the server as having
a limited ability to negotiate the group used in the Diffie–Hellman
key exchange.
In Tamarin, any value can be used as a group generator. Typically,
the fixed (public) constant 'g' is used, which represents all parties
agreeing to use a single group ahead of time. On receiving a key
share and storing it in the variable gx, we simulate checking that
the element resides in this group by pattern matching the value as
'g'^x = gx. Intuitively, this corresponds to checking that∃x . дx =
gx.
In Tamarin’s syntax, variables that are always instantiated with
public values are prefixed by $. In our model, the client starts with a
pair of public values $g1,$g2 that represent two supported groups,
Client
C0
client_hello
C1
recv_server_hello
C2a
client_gen_keys
C2b
recv_encrypted_extensions
recv_cert_request OR
skip_recv_cert_request
C2c
C2d
recv_server_auth
C3
client_auth OR
client_auth_cert
cert_req_ctxt = ‘0’
cert_req_ctxt (cid:44) ‘0’
C4
Server
S0
ClientHello
+Extensions
ServerHello
+Extensions
EncryptedExtensions
CertRequest
Cert CertVerify
Finished
Cert CertVerify
Finished
recv_client_hello
S1
server_hello
S2a
server_gen_keys
S2b
encrypted_extensions
S2c
S2d
cert_request OR
skip_cert_request
server_auth
S3
cert_req_ctxt = ‘0’
recv_client_auth OR
recv_client_auth_cert
cert_req_ctxt (cid:44) ‘0’
S4
Figure 4: Partial state diagram for full TLS 1.3 handshake. Tamarin rules are indicated in blue. The messages exchanged be-
tween entities are given in green. Our full model contains many more transitions. We omit these here for the sake of simplicity.
and offers these to the server along with a corresponding key share
for $g1. Similarly, the server starts with a supported group $g. The
model allows the server to return a HelloRetryRequest to the
client, enforcing that $g is not equal to $g1, and expects the client
to return instead a key share that matches $g2.
This interaction enables a much greater coverage of DH key
exchange with respect to previous models, and opens up the possi-
bility of future extensions to this work. One such extension would
be to model a weak group by permitting the attacker to reveal the
corresponding DH exponents.
Handshake flows. One of the most complex elements inherent
to modelling TLS 1.3 is the vast number of possible state machine
transitions. After a session resumption, the server can choose be-
tween using the PSK only, or using the PSK along with a DH key
share. Alternatively, the server might reject the PSK entirely, and
fall back to a regular handshake, or request that the client use a
different group for the DH exchange. Additionally, there are several
complex messages that can be sent in the post-handshake state:
client authentication requests, new session tickets, and key update
requests.
Since all of the above interactions can happen asynchronously,
the resulting model becomes very complex and requires sophis-
ticated handling logic. A number of complicated protocol flows,
involving any number of sequential handshake modes and post-
handshake extensions can, and will, transpire and we deal with this
eventuality by modelling all possible handshake modes in a very
modular fashion. Other models are, by and large, not capable of
capturing complicated protocol flows.
4 ENCODING THE THREAT MODEL AND
THE SECURITY PROPERTIES
4.1 Threat Model
We consider an extension of the Dolev-Yao (DY) attacker [23] as our
threat model. The DY attacker has complete control of the network,
and can intercept, send, replay, and delete any message. To con-
struct a new message, the attacker can combine any information
previously learnt, e.g., decrypting messages for which it knows the
key, or creating its own encrypted messages. We assume perfect
cryptography, which implies that the attacker cannot encrypt, de-
crypt or sign messages without knowledge of the appropriate keys.
In order to consider different types of compromise, we additionally
allow the attacker to do the following:
• compromise the long-term keys of protocol participants,
• compromise their pre-shared keys, whether created OOB
• compromise their DH values.
or through a NST, and
Note that TLS 1.3 is not intended to be secure under the full
combination of all these types of compromise. For example, session
key secrecy can be broken by an attacker who eavesdrops on the
communication and compromises the DH values of a single protocol
participant.
A natural approach is to weaken the attacker model by adding
realistic constraints until either the claimed security goals of the pro-
tocol are achieved, or the corresponding attackers become weaker
than the ones we expect to face in practice. This workflow requires
us to express, with high granularity, exactly what needs to be pro-
tected and when each of the claimed TLS 1.3 properties can be
expected to hold.
We now give our formal definitions of the TLS 1.3 security prop-
erties mentioned in Section 2, noting where each property is covered
in our model.
4.2 Security properties
We encode the claimed security properties of TLS 1.3 as lemmas in
the specification language of Tamarin. Here we discuss the relation-
ship between the lemmas we prove in the model, and the desired
properties in the specification.We note that there is some overlap
between the material in the stated goals expressed in Section 2.2.
For example, the requirement for PFS is effectively a modifier to the
requirement for secret session keys. Where possible, we will prove
these properties via distinct lemmas to aid in the comprehension
of the model. However, it is also possible to combine many of the
properties into a single, more complex lemma.
4.2.1 Establishing the same session keys. The definition of this
first property is taken from [19], where it is referred to as a consis-
tency property. However, there is ambiguity in the circumstances
that are necessary and sufficient for two protocol participants to
establish the same keys. An answer to this question is typically
given through the well-established practice of defining session part-
nering [8, 19, 36]. One possible way to do so is to assign session
identifiers in terms of a value (or pair of values) on which the two
parties agree. We opted for the least restrictive session identifier,
namely the pair of nonces generated by the client and the server.
Therefore, if a partnered client and server complete the handshake,
then they must agree on session keys.
We consider this property with respect to an attacker that can
compromise all session keys except for those that are identical
to that of the test session, i.e. the session in which the attacker
attempts to obtain information about the key [19, 36]. This property
is captured by our lemma session_key_agreement.
4.2.2
Secrecy of the session keys. The secret_session_keys
lemma is used to prove property (2) in Section 2.2.
The secret_session_keys lemma we prove appears in full detail
in Figure 5. The intuition for this lemma is that if an actor believes
it has established a session key with an authenticated peer, then the
attacker does not know the key. However, given the capabilities of
the attacker, this will not hold without imposing some restrictions.
This is why the additional clauses are required.
The five conditions stated in the depicted lemma are generally
repeated across all lemmas, and encapsulate the basic assumption
we make about our attacker. We describe them in more detail here:
The first imposes the restriction that the long-term signing key
of the peer is not compromised2. This restriction can additionally
be understood to signify that the actor is communicating with an
honest peer, since the attacker can effectively simulate a party when
in possession of its long-term key. Furthermore, it should be noted
that the attacker is still allowed to compromise the peer’s long-term
key (LTK) after the session key is established. Hence we show that
the session keys achieve PFS with respect to the LTK.
The second and third clauses bar the attacker from revealing any
DH exponents generated by the client or the server from before the
session key was established. The attacker may reveal exponents
that are generated after the session key is established.
The last two clauses specify that the attacker cannot compromise
a PSK associated with either the actor or the peer. Note that the at-
tacker is restricted from revealing these PSKs even after the session
key has been established, which corresponds to the proviso in the
specification that the PSK-only exchange mode does not provide
PFS. We discuss this in more detail in Section 4.2.6.
4.2.3 Peer Authentication. The specification defines this prop-
erty somewhat informally, as a form of authentication whereby
both parties should agree on the identity of their peer. Looking
at this more formally through the lens of Lowe’s hierarchy of
authentication[39], this definition corresponds to weak agreement.
In particular, we note that this does not imply recentness—the re-
quirement that the peer is currently running the protocol—nor does
it specify whether any other values should be agreed upon.
We initially model this property via our entity_authentication
lemma. Entity authentication is modelled in two parts so as to cap-
ture the distinction between the bilateral (mutual) and unilateral
authentication cases. Authentication in the unilateral case means
that if a client completes a TLS handshake, apparently with a server,
then the server previously ran a TLS handshake with the client, and
they both agree on certain data values of the handshake, including
the identity of the server and the nonces used. Note that this is
already a stronger property than is stipulated in the specification.
Here we prove non-injective agreement on the nonces, which addi-
tionally provides recentness since both parties contribute a fresh
nonce to the handshake. The unilateral entity authentication lemma
we prove appears in Figure 6.
The intuition for this lemma is that if a client believes it has
agreed on a pair of nonces with a server, then the server was,
at some point prior, running the protocol with those nonces. We
again find the necessary restrictions on the attacker to achieve this
property. The property can only hold if the attacker does not acquire
any of the secrets prior to the client agreeing on nonces. While one
might expect that only the legitimacy of the signing key is necessary
for authentication, if the attacker is able to obtain the PSK through
2We remind the reader that both the client and the server are equipped with long-
term signing keys, and the corresponding public key certificates, for the purposes of
authentication.
1 lemma secret_session_keys:
2
3
4
5
6
7
8
9
==> not Ex #j. K(read_key)@j"
"All tid actor peer write_key read_key peer_auth_status #i.
SessionKey(tid, actor, peer, , )@i &
not (Ex #r. RevLtk(peer)@r & #r )@i &
4
not (Ex #r. RevLtk(peer)@r & #r  (Ex tid2 #j. RunningNonces(tid2, peer, 'server', nonces)@j & #j < #i)"
Figure 6: entity_authentication (Section 4.2.3)
compromising cryptographic material, or the PSK directly, then the
attacker is able to resume a session and impersonate the peer.
In addition to entity authentication, we consider a transcript
agreement property, where the value agreed upon is a hash of the
session transcript. This provides us with near-full agreement. How-
ever, there are a couple of notable omissions. Firstly, the protocol
technically continues after the initial handshake, although none
of these delayed handshake messages are included in the session
transcript. Secondly, we observed that the actors do not necessar-
ily agree on the current authentication status of the handshake, a
situation we cover in more detail in Section 5.2.
Finally, we also prove an injective variant of mutual transcript
agreement, which TLS naturally achieves by agreeing on fresh
nonces. Hence, we show that TLS achieves a relatively strong au-
thentication notion: mutual agreement on a significant portion of
the state with recentness.
4.2.4 Uniqueness of the session keys. We prove in the straight-
forward way that for any two session keys generated, if they match
then they must be from the same session. This holds without any
restriction on the attacker, since it is a straightforward consequence
of the actor generating a fresh nonce for each session. We do not
prove anything about whether two session keys are related, since
this trivially follows from the assumption of perfect cryptography.
4.2.5 Downgrade protection. The specification cites the work
by Bhargavan et al. [11] for downgrade protection. This defini-
tion is not directly equivalent to any of Lowe’s classical agreement
methods; it only requires that both parties negotiate the same con-
figuration parameters that they would do without the presence of
an attacker. Specifically, we observe that agreeing on the parame-
ters (in the sense of non-injective agreement) is sufficient to achieve
this, but not necessary. Therefore, within our model we prove that
TLS achieves downgrade protection through our authentication
lemmas.
However, we note that this does not accurately capture the spirit
of downgrade protection, due to the fact that we assume all cryp-
tographic primitives are perfect and we do not model previous
versions of TLS.