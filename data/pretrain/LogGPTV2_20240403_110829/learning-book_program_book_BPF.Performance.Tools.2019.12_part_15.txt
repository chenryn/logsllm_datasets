16.05 common-auth
05:35:01 cxon
16463
R 1249
0
16.04 common-auth
06:35:01 eron
16465 R 1249
16,03 common-auth
06:35:01 cron
16465
R 4096
10,62 logln,defs
06:35:01 cron
16464R 4096
10 ,61 login,defs
[..-]
---
## Page 118
3.4 BCC Tool Checklist
81
ext4slower(8) traces common operations from the ext4 file system (reads, writes, opens, and
syncs and prints those that exceed a time threshold. This can identify or exonerate one type of
performance issue: an application waiting on slow individual disk I/O via the file system. There
are variants of ext4slower(8) for other file systems, including btfsslower(8), xfsslower(8), and
zfsslower(8). See Chapter 8 for more details.
3.4.4
biolatency
 biolatency -B
Tracing block device I/0..-
Hit Ctrl-C to end.
^C
nsecs
1coun.t
distribution
0 -> 1
: 16335
2 -> 3
: 2272
|*****
4 -> 7
: 3603
*.......
8 > 15
: 4328
[*.........
1.6 -> 31
625 :
32 -> 63
: 5815
|+**+**++*+**++
64 -> 127
: 0
128 -> 255
: 0
256 -> 511
: 0
51.2 > 1023
: 1
biolatency(8) traces disk I/O latency (that is, the time from device issue to completion) and
iostat(1). Multiple modes can be examined. Modes are values that are more frequent than others
shows this as a histogram. This better explains disk I/O performance than the averages shown by
in a distribution, and this example shows a multi-modal distribution with one mode between
0 and 1 milliseconds, and another mode centered around the 8- to 15-millisecond range.* Outliers
are also visible: this screenshot shows a single outlier in the S12- to 1023-millisecond range.
biolatency(8) is covered in more detail in Chapter 9.
3.4.5
biosnoop
+biosnoop
TIHE (s)
COMH
PID
DISK
T
SECTOR
BYTES
LAT (ns)
0, 000004001
supervi.se
1950
xvdia1
13092560
4096
0 , 74
2008LT000*0
supervl.se
1 950
xvda1
$
13092432
4096
0.61
0, 001469001
supervise
1956
xvda1
中
13092440
4096
1.24
0, 001588002
superv1.se
1956
xvda1
W
13115128
4096
1.09
1, 022346001
supervise
1 950
xvdia1
131152724096
0, 98
[..-]
4lIt looks a litte skewed because of the log2 distribution: buckets span prgessively lrger rnges If I needed to
biosnoop(8) tool to log disk I/0 and then import that log into spreadsheet softssre for custom histograms.
understand this better, I would either modily biolatency(8) to use a higherresolution linear histogram instead, or use the
---
## Page 119
82
Chapter 3 Performance Analysis
biosnoop(8) prints a line of output for each disk I/O, with details including latency. This allows
you to examine disk I/O in more detail, and look for time-ordered patterns (e.g., reads queueing
behind writes). biosnoop(8) is covered in more detail in Chapter 9.
3.4.6
cachestat
cachestat
HITS
MISSES
DIRTIES BITRATIO
BUFFERS_MB
CACHED_MB
53401
2755
20953
95.095
14
90223
49599
4098
21460
92.37
14
90230
16601
2689
61329
86.065
1. 4
90381
15197
2477
58028
85.998
14
90522
[..-]
cachestat(8) prints a one-line summary every second (or every custom interval) showing statistics
from the file system cache. Use this to identify a low cache hit ratio and a high rate of misses. This
may give you a lead for performance tuning, cachestat(8) is covered in more detail in Chapter 8.
3.4.7
tcpconnect
 tepconnect
PID
COMM
IP SADDR
DACOR
DFORT
1479
Celnet.
4127,0.0.1
127.0.0.1
23
1469
cur1
410.201.219.236
54.245.105.25
80
1469
cur1
4
54,67,101.145
BO
1991
telnet.
6::1
::1
23
2015
ssh
6fe80::2000:bff:fe82:3ac Ce80: :2000:bff:fe82:3ac 22
[. . - ]
tcpconnect(8) prints one line of output for every active TCP connection (e.g., via connect0), with
letails including source and destination addresses, Look for unexpected connections that may
point to inefficiencies in application configuration or an intruder. tcpconnect(8) is covered in
more detail in Chapter 10.
3.4.8
tcpaccept
 tepaccept
PID
COMM
IP RADDR
LADCR
LPORT
907
sshd
4192.168.56.1
192,168.56.102
22
907
Pq2s
4
127,0.0.1
127,0.0.1
22
5389
per1
6
1234 : ab12:2040 : 5020 :2299:0 :5:0 1234 :ab12 :2040 :5020:2299 :0 : 5: 0 7001
[...]
aatssed Auaaa 1og sndqno go aul auo squd 1I °(g)4xouuood3 04 poo4 uopueduroo e st (g)ndaooed34
TCP connection (e.g, via acceptO), with details including source and destination addresses.
tcpaccept(8) is covered in more detail in Chapter 10.
---
## Page 120
3.4 BCC Tool Checklist
83
3.4.9
tcpretrans
 tepzetrans
TIME
PID
IP LADDR:LPORT
T> RACOR:RPORT
STATE
01:55: 05 0
4
10.153,223,157:22
R> 69,53,245.40:34619
ESTABLISHED
01:55: 05 0
4
10.153.223,157:22
R> 69,53,245.40:34619
ESTABLISHED
01:55:17 0
10.153.223.157:22
R> 69.53,245,40:22957
ESTABLISHED
[...]
tcpretrans(8) prints one line of output for every TCP retransmit packet, with details including
source and destination addresses, and the kernel state of the TCP connection. TCP retransmissions
cause latency and throughput issues. For retransmissions where the TCP session state is
ESTABLISHED, look for problems with external networks. For the SYN_SENT state, this may point
to target kernel CPU saturation and kernel packet drops as well. tcpretrans(8) is covered in more
detail in Chapter 10.
3.4.10
runqlat
runqlat
Tracing run queue latency... Hit Ctrl-C to end.
C
u5ec5
1 count
distribution
0 -> 1
: 233
2 > 3
: 742
4 -> 7
: 203
 -> 15
: 173
[**......
16 -> 31
: 24
 | *
32 -> 63
: 0
64 -> 127
: 30
| *
128 -> 255
25 6 -> 511
: 3
51.2 > 1023
: 5
1024 -> 2047
: 27
 | *
2048 > 4095
: 30
 | *
6T8  3276T
: 809
32768 -> 65535
: 64
  × x
runqlat(8) times how long threads were waiting for their turn on CPU and prints this time as a
histogram. Longer-than-expected waits for CPU access can be identified using this tool, which
threads can suffer due to CPU saturation, misconfigurations, or scheduler issues. runqlat(8) is
covered in more detail in Chapter 6.
---
## Page 121
84
Chapter 3 Performance Analysis
3.4.11 profile
 profile
Sanpling at 49 Bertz of all threads by user + kernel stack... Bit Ctrl-C to end.
°C
[...]
copy_user_enhanced_fast_string
copy_user_enhanced_fast_stxing
_copy_from_iter_ful1
tcp_sendnsg_locked
Bsupuasdo
Inet_sendmsg
Bsapuas"xoos
sock_wzlte_lter
nev_sync_xrite
_vfs_xr1te
vfs_vrite
Sy3_yrite
9"Tes.a"op
entry_SYscALlL_s4_after_hvfxase
[unknoxn]
[unknoxn]
iperf (24092)
5 8
CPU resources. It takes samples of stack traces at timed intervals and prints a summary of unique
profile(8) is a CPU profiler, a tool you can use to understand which code paths are consuming
stack traces and a count of their occurrence. This output has been truncated and only shows
one stack trace, with an occurrence count of 58 times. profile(8) is covered in more detail in
Chapter 6.
3.5
Summary
Performance analysis is about improving end-user performance and reducing operating costs.
There are many tools and metrics to help you analyze performance; in fact, there are so many that
choosing the right ones to use in a given situation can be overwhelming. Performance method-
ologies can guide you through these choices, showing you where to start, steps for analysis, and
where to end.
This chapter summarizes performance analysis methodologies: workload characterization,
latency analysis, the USE method, and checklists. A Linux performance analysis in 60 seconds
checklist was then included and explained, which can be your starting point for any performance
issue. It may help you solve issues outright, or at least yield clues about where the performance
issue is and direct further analysis with BPF tools. In addition, this chapter includes a BPF check
list of BCC tools, which are explained in more detail in later chapters.
---
## Page 122
BCC
The BPF Compiler Collection (BCC; sometimes written as lowercase bcc after the project and
package names) is an open source project that contains a compiler framework and libraries for
building BPF software. It is the main front-end project for BPF, supported by the BPF developers,
and is usually where the latest kernel tracing BPF additions are first used. BCC also contains more
than 70 ready-to-run BPF performance analysis and troubleshooting tools, many of which are
covered in this book.
BCC was created by Brenden Blanco in April 2015. Encouraged by Alexei Starovoitov, I joined
the project in 2015 and became a major contributor of performance tools, documentation, and
testing. There are now numerous contributors, and BCC is a default server install at companies
including Netflix and Facebook.
Learning objectives:
 Gain knowledge of BCC features and components, including tools and documentation
Understand the benefits of single-purpose vs multi-purpose tools
 Learn how to use the funccount(8) multi-tool for event counting
 Learn how to use the stackcount(8) multi-tool for discovering code paths
 Learn how to use the trace(8) multi-tool for per-event custom printing
 Learn how to use the argdist(8) multi-tool for distribution summaries
 (optional) Get exposure to BCC internals
 Be aware of BCC debugging techniques
This chapter introduces BCC and its features; shows how to installit; provides an overview of
its tools, tool types, and documentation; and ends with a tour of BCC internals and debugging.
If you wish to develop your own new tools, be sure to study both this chapter and Chapter 5
(bpftrace), and you will be able to choose the front end that best suits your needs. Appendix C
summarizes BCC tool development using examples.
---
## Page 123
86
Chapter 4 BCC
4.1
BCC Components
The high-level directory structure of BCC is shown in Figure 4-1
BPF Compiler Collection (BCC)
tools
man
1
docs
src
gueu
、
、、
Y