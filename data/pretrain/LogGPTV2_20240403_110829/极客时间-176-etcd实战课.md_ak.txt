# 07 \| MVCC：如何实现多版本并发控制？你好，我是唐聪。在01课里，我和你介绍 etcd v2时，提到过它存在的若干局限，如仅保留最新版本 key-value数据、丢弃历史版本。而 etcd 核心特性 watch 又依赖历史版本，因此 etcd v2为了缓解这个问题，会在内存中维护一个较短的全局事件滑动窗口，保留最近的1000 条变更事件。但是在集群写请求较多等场景下，它依然无法提供可靠的Watch 机制。那么不可靠的 etcd v2 事件机制，在 etcd v3中是如何解决的呢？我今天要和你分享的 MVCC（Multiversion concurrencycontrol）机制，正是为解决这个问题而诞生的。MVCC 机制的核心思想是保存一个 key-value 数据的多个历史版本，etcd基于它不仅实现了可靠的 Watch 机制，避免了 client 频繁发起 List Pod 等expensive request 操作，保障 etcd 集群稳定性。而且 MVCC还能以较低的并发控制开销，实现各类隔离级别的事务，保障事务的安全性，是事务特性的基础。希望通过本节课，帮助你搞懂 MVCC 含义和 MVCC 机制下 key-value数据的更新、查询、删除原理，了解 treeIndex 索引模块、boltdb模块是如何相互协作，实现保存一个 key-value数据多个历史版本。什么是 MVCC首先和你聊聊什么是MVCC，从名字上理解，它是一个基于多版本技术实现的一种并发控制机制。那常见的并发机制有哪些？MVCC的优点在哪里呢？提到并发控制机制你可能就没那么陌生了，比如数据库中的悲观锁，也就是通过锁机制确保同一时刻只能有一个事务对数据进行修改操作，常见的实现方案有读写锁、互斥锁、两阶段锁等。悲观锁是一种事先预防机制，它悲观地认为多个并发事务可能会发生冲突，因此它要求事务必须先获得锁，才能进行修改数据操作。但是悲观锁粒度过大、高并发场景下大量事务会阻塞等，会导致服务性能较差。**MVCC机制正是基于多版本技术实现的一种乐观锁机制**，它乐观地认为数据不会发生冲突，但是当事务提交时，具备检测数据是否冲突的能力。在 MVCC 数据库中，你更新一个 key-value数据的时候，它并不会直接覆盖原数据，而是新增一个版本来存储新的数据，每个数据都有一个版本号。版本号它是一个逻辑时间，为了方便你深入理解版本号意义，在下面我给你画了一个etcd MVCC 版本号时间序列图。从图中你可以看到，随着时间增长，你每次修改操作，版本号都会递增。每修改一次，生成一条新的数据记录。**当你指定版本号读取数据时，它实际上访问的是版本号生成那个时间点的快照数据**。当你删除数据的时候，它实际也是新增一条带删除标识的数据记录。![](Images/887ad7e524b85ca94a86922b24fb08cf.png)savepage-src="https://static001.geekbang.org/resource/image/1f/2c/1fbf4aa426c8b78570ed310a8c9e2c2c.png"}MVCC 特性初体验了解完什么是 MVCC 后，我先通过几个简单命令，带你初体验下 MVCC特性，看看它是如何帮助你查询历史修改记录，以及找回不小心删除的 key的。 启动一个空集群，更新两次 key hello 后，如何获取 key hello的上一个版本值呢？ 删除 key hello后，还能读到历史版本吗?如下面的命令所示，第一次 key hello 更新完后，我们通过 get命令获取下它的 key-value 详细信息。正如你所看到的，除了 key、value信息，还有各类版本号，我后面会详细和你介绍它们的含义。这里我们重点关注mod_revision，它表示 key 最后一次修改时的 etcd版本号。 当我们再次更新 key hello 为 world2 后，然后通过查询时指定 key第一次更新后的版本号，你会发现我们查询到了第一次更新的值，甚至我们执行删除key hello 后，依然可以获得到这个值。那么 etcd是如何实现的呢?    
# 更新key hello为world1    $ etcdctl put hello world1    OK    