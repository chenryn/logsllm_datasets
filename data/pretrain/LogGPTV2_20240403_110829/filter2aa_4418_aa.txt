.\" auto-generated by docbook2man-spec $Revision: 1.1 $
.TH "COPY" "7" "2003-11-02" "SQL - Language Statements" "SQL Commands"
.SH NAME
COPY \- 在表和文件之间拷贝数据
.SH SYNOPSIS
.sp
.nf
COPY \fItablename\fR [ ( \fIcolumn\fR [, ...] ) ]
    FROM { '\fIfilename\fR' | STDIN }
    [ [ WITH ] 
          [ BINARY ] 
          [ OIDS ]
          [ DELIMITER [ AS ] '\fIdelimiter\fR' ]
          [ NULL [ AS ] '\fInull string\fR' ] ]
COPY \fItablename\fR [ ( \fIcolumn\fR [, ...] ) ]
    TO { '\fIfilename\fR' | STDOUT }
    [ [ WITH ] 
          [ BINARY ]
          [ OIDS ]
          [ DELIMITER [ AS ] '\fIdelimiter\fR' ]
          [ NULL [ AS ] '\fInull string\fR' ] ]
.sp
.fi
.SH "DESCRIPTION 描述"
.PP
\fBCOPY\fR 在 PostgreSQL表和标准文件系统文件之间交换数据。 COPY TO 把一个表的所有内容都拷贝到一个文件， 而 COPY FROM 从一个文件里拷贝数据到一个表里（把数据附加到表中已经存在的内容里）。
.PP
 如果声明了一个字段列表，COPY 将只在文件和表之间拷贝声明的字段的数据。 如果表中有任何不在字段列表里的字段，那么 COPY FROM 将为那些字段插入缺省值。
.PP
 带文件名的 COPY 指示 PostgreSQL 服务器直接从文件中读写数据。 如果声明了文件名，那么该文件必须为服务器可见，而且文件名必须从服务器的角度声明。如果声明的是 STDIN 或 STDOUT，数据通过连接在客户前端和服务器之间流动。
.SH "PARAMETERS 参数"
.TP
\fB\fItablename\fB\fR
 现存表的名字（可以有模式修饰）。
.TP
\fB\fIcolumn\fB\fR
 可选的待拷贝字段列表。如果没有声明字段列表，那么将使用所有字段。
.TP
\fB\fIfilename\fB\fR
 输入或输出文件的绝对路径名。
.TP
\fBSTDIN\fR
 声明输入是来自客户端应用。
.TP
\fBSTDOUT\fR
 声明输入前往客户端应用。
.TP
\fBBINARY\fR
 使用二进制格式存储和读取，而不是以文本的方式。 在二进制模式下，不能声明 DELIMITERS和NULL。
.TP
\fBOIDS\fR
 声明为每行拷贝内部对象标识（OID）。 （如果给那些没有 OID 的表声明了 OIDS 选项，则抛出一个错误。）
.TP
\fB\fIdelimiter\fB\fR
 用于在文件中每行中分隔各个字段的单个字符。 缺省是水平制表符。（tab）
.TP
\fB\fInull string\fB\fR
 一个代表 NULL 值的字串。缺省是 \\N （反斜杠-N）。 当然，你可以自己挑一个空字串。
.sp
.RS
.B "Note:"
注意:  对于COPY FROM，任何匹配这个字串的字串将被存储为 NULL 值， 所以你应该确保你用的字串和COPY TO相同。
.RE
.sp
.SH "NOTES 注意"
.PP
\fBCOPY\fR 只能用于表，不能用于视图。
.PP
BINARY 关键字将强制使用二进制对象而不是文本存储/读取所有数据。 这样做在一定程度上比传统的拷贝命令快，但二进制拷贝文件在不同机器体系间的植性不是很好。
.PP
 你对任何要COPY TO  出来的数据必须有选取数据的权限，对任何要 COPY FROM 入数据的表必须有插入权限。
.PP
COPY 命令里面的文件必须是由服务器直接读或写的文件，而不是由客户端应用读写。 因此，它们必须位于数据库服务器上或者可以为数据库服务器所访问，而不是由客户端做这些事情。 它们必须是PostgreSQL用户（服务器运行的用户 ID）可以访问到并且可读或者可写，而不是客户端。 COPY 到一个命名文件是只允许数据库超级用户进行的，因为它允许读写任意服务器有权限访问的文件。
.PP
 不要混淆 COPY 和 psql 指令 \fB\\copy\fR。 \fB\\copy\fR 调用 COPY FROM STDIN 或者 COPY TO STDOUT， 然后把数据抓取/存储到一个 psql 客户端可以访问的文件中。 因此，使用 \fB\\copy\fR 的时候，文件访问权限是由客户端而不是服务器端决定的。
.PP
 我们建议在 COPY 里的文件名字总是使用绝对路径。 在 COPY TO 的时候是由服务器强制进行的， 但是对于 COPY FROM，你的确有从一个声明为相对路径的文件里读取的选择。 该路径将解释为相对于服务器的工作目录（在数据目录里的什么地方），而不是客户端的工作目录。
.PP
\fBCOPY FROM\fR 会激活所有触发器和检查约束。不过，不会激活规则。
.PP
\fBCOPY\fR 在第一个错误处停下来。这些在 COPY TO中不应该导致问题， 但在 COPY FROM 时目的表会已经接收到早先的行， 这些行将不可见或不可访问，但是仍然会占据磁盘空间。 如果你碰巧是拷贝很大一块数据文件的话， 积累起来，这些东西可能会占据相当大的一部分磁盘空间。你可以调用 VACUUM 来恢复那些磁盘空间。
.SH "FILE FORMATS 文件格式"
.SS "TEXT FORMAT 文本格式"
.PP
 当不带 BINARY 选项使用 COPY 时， 读写的文件是一个文本文件，每行代表表中一个行。 行中的列（字段）用分隔符分开。 字段值本身是由与每个字段类型相关的输出函数生成的字符串， 或者是输入函数可接受的字串。 数据中使用特定的空值字串表示那些为 NULL 的字段。 如果输入文件的任意行包含比预期多或者少的字段，那么 COPY FROM 将抛出一个错误。 如果声明了 OIDS，那么 OID 将作为第一个字段读写， 放在所有用户字段前面。
.PP
 数据的结束可以用一个只包含反斜扛和句点（\\.）的行表示。 如果从文件中读取数据，那么数据结束的标记是不必要的， 因为文件结束起的作用就很好了；但是在 3.0 之前的客户端协议里，如果在客户端应用之间拷贝数据， 那么必须要有结束标记。
.PP
 反斜扛字符（\\）可以用在 COPY  里给那些会有歧义的字符进行逃逸（否则那些字符会被当做行或者字段分隔符处理）。 特别是下面的字符如果是字段值的一部分时，必须前缀一个反斜扛：反斜扛本身，换行符，回车，以及当前分隔符。
.PP
 声明的空字串被 COPY TO 不加任何反斜杠发送；与之相对，COPY FROM  在删除反斜杠之前拿它的输入与空字串比较。因此，像 \\N 这样的空字串不会和实际数据值 \\N 之间混淆（因为后者会表现成 \\\\N）。
.PP
\fBCOPY FROM\fR 识别下列特殊反斜扛序列：
.RS
\\b 退格 (ASCII 8)
.PP
\\f 进纸 (ASCII 12)
.PP
\\n 新行 (ASCII 10)
.PP
\\r 回车 (ASCII 13)
.PP
\\t 跳格 (ASCII 9)
.PP
\\v 竖直跳格 (ASCII 11)
.PP
\\\fIdigits\fR (反斜杠，后面是三个八进制数值，代表具有指定值的字符)
.RE
 目前，COPY TO 将绝不会发出一个八进制反斜扛序列， 但是它的确使用了上面列出的其它字符用于控制字符。
.PP
 绝对不要把反斜扛放在一个数据字符N或者句点（.）前面。 这样的组合将分别被误认为是空字串(\\.) 或者数据结束标记 (\\N)。 另外一个没有在上面的表中列出的反斜扛字符就是它自己。
.PP