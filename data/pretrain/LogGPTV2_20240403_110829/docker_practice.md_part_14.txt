安全
评估 Docker 的安全性时，主要考虑三个方面:
由内核的命名空间和控制组机制提供的容器内在安全
Docker 程序（特别是服务端）本身的抗攻击性
内核安全性的加强机制对容器安全性的影响
171
内核命名空间
内核命名空间
Docker 容器和 LXC 容器很相似，所提供的安全特性也差不多。当用 docker
run 启动一个容器时，在后台 Docker 为容器创建了一个独立的命名空间和控制组
集合。
命名空间提供了最基础也是最直接的隔离，在容器中运行的进程不会被运行在主机
上的进程和其它容器发现和作用。
每个容器都有自己独有的网络栈，意味着它们不能访问其他容器的 sockets 或接
口。不过，如果主机系统上做了相应的设置，容器可以像跟主机交互一样的和其他
容器交互。当指定公共端口或使用 links 来连接 2 个容器时，容器就可以相互通信
了（可以根据配置来限制通信的策略）。
从网络架构的角度来看，所有的容器通过本地主机的网桥接口相互通信，就像物理
机器通过物理交换机通信一样。
那么，内核中实现命名空间和私有网络的代码是否足够成熟？
内核命名空间从 2.6.15 版本（2008 年 7 月发布）之后被引入，数年间，这些机制
的可靠性在诸多大型生产系统中被实践验证。
实际上，命名空间的想法和设计提出的时间要更早，最初是为了在内核中引入一种
机制来实现 OpenVZ 的特性。 而 OpenVZ 项目早在 2005 年就发布了，其设计和
实现都已经十分成熟。
172
控制组
控制组
控制组是 Linux 容器机制的另外一个关键组件，负责实现资源的审计和限制。
它提供了很多有用的特性；以及确保各个容器可以公平地分享主机的内存、CPU、
磁盘 IO 等资源；当然，更重要的是，控制组确保了当容器内的资源使用产生压力
时不会连累主机系统。
尽管控制组不负责隔离容器之间相互访问、处理数据和进程，它在防止拒绝服务
（DDOS）攻击方面是必不可少的。尤其是在多用户的平台（比如公有或私有的
PaaS）上，控制组十分重要。例如，当某些应用程序表现异常的时候，可以保证
一致地正常运行和性能。
控制组机制始于 2006 年，内核从 2.6.24 版本开始被引入。
173
服务端防护
Docker服务端的防护
运行一个容器或应用程序的核心是通过 Docker 服务端。Docker 服务的运行目前需
要 root 权限，因此其安全性十分关键。
首先，确保只有可信的用户才可以访问 Docker 服务。Docker 允许用户在主机和容
器间共享文件夹，同时不需要限制容器的访问权限，这就容易让容器突破资源限
制。例如，恶意用户启动容器的时候将主机的根目录 / 映射到容器的 /host 目
录中，那么容器理论上就可以对主机的文件系统进行任意修改了。这听起来很疯
狂？但是事实上几乎所有虚拟化系统都允许类似的资源共享，而没法禁止用户共享
主机根文件系统到虚拟机系统。
这将会造成很严重的安全后果。因此，当提供容器创建服务时（例如通过一个 web
服务器），要更加注意进行参数的安全检查，防止恶意的用户用特定参数来创建一
些破坏性的容器。
为了加强对服务端的保护，Docker 的 REST API（客户端用来跟服务端通信）在
0.5.2 之后使用本地的 Unix 套接字机制替代了原先绑定在 127.0.0.1 上的 TCP 套接
字，因为后者容易遭受跨站脚本攻击。现在用户使用 Unix 权限检查来加强套接字
的访问安全。
用户仍可以利用 HTTP 提供 REST API 访问。建议使用安全机制，确保只有可信的
网络或 VPN，或证书保护机制（例如受保护的 stunnel 和 ssl 认证）下的访问可以
进行。此外，还可以使用 HTTPS 和证书来加强保护。
最近改进的 Linux 命名空间机制将可以实现使用非 root 用户来运行全功能的容器。
这将从根本上解决了容器和主机之间共享文件系统而引起的安全问题。
终极目标是改进 2 个重要的安全特性：
将容器的 root 用户映射到本地主机上的非 root 用户，减轻容器和主机之间因
权限提升而引起的安全问题；
允许 Docker 服务端在非 root 权限下运行，利用安全可靠的子进程来代理执行
需要特权权限的操作。这些子进程将只允许在限定范围内进行操作，例如仅仅
负责虚拟网络设定或文件系统管理、配置操作等。
174
服务端防护
最后，建议采用专用的服务器来运行 Docker 和相关的管理服务（例如管理服务比
如 ssh 监控和进程监控、管理工具 nrpe、collectd 等）。其它的业务服务都放到容
器中去运行。
175
内核能力机制
内核能力机制
能力机制（Capability）是 Linux 内核一个强大的特性，可以提供细粒度的权限访问
控制。 Linux 内核自 2.2 版本起就支持能力机制，它将权限划分为更加细粒度的操
作能力，既可以作用在进程上，也可以作用在文件上。
例如，一个 Web 服务进程只需要绑定一个低于 1024 的端口的权限，并不需要 root
权限。那么它只需要被授权 net_bind_service 能力即可。此外，还有很多其他
的类似能力来避免进程获取 root 权限。
默认情况下，Docker 启动的容器被严格限制只允许使用内核的一部分能力。
使用能力机制对加强 Docker 容器的安全有很多好处。通常，在服务器上会运行一
堆需要特权权限的进程，包括有 ssh、cron、syslogd、硬件管理工具模块（例如负
载模块）、网络配置工具等等。容器跟这些进程是不同的，因为几乎所有的特权进
程都由容器以外的支持系统来进行管理。
ssh 访问被主机上ssh服务来管理；
cron 通常应该作为用户进程执行，权限交给使用它服务的应用来处理；
日志系统可由 Docker 或第三方服务管理；
硬件管理无关紧要，容器中也就无需执行 udevd 以及类似服务；
网络管理也都在主机上设置，除非特殊需求，容器不需要对网络进行配置。
从上面的例子可以看出，大部分情况下，容器并不需要“真正的” root 权限，容器只
需要少数的能力即可。为了加强安全，容器可以禁用一些没必要的权限。
完全禁止任何 mount 操作；
禁止直接访问本地主机的套接字；
禁止访问一些文件系统的操作，比如创建新的设备、修改文件属性等；
禁止模块加载。
这样，就算攻击者在容器中取得了 root 权限，也不能获得本地主机的较高权限，能
进行的破坏也有限。
默认情况下，Docker采用 白名单 机制，禁用 必需功能 之外的其它权限。 当然，
用户也可以根据自身需求来为 Docker 容器启用额外的权限。
176
内核能力机制
177
其它安全特性
其它安全特性
除了能力机制之外，还可以利用一些现有的安全机制来增强使用 Docker 的安全
性，例如 TOMOYO, AppArmor, SELinux, GRSEC 等。
Docker 当前默认只启用了能力机制。用户可以采用多种方案来加强 Docker 主机的
安全，例如：
在内核中启用 GRSEC 和 PAX，这将增加很多编译和运行时的安全检查；通过
地址随机化避免恶意探测等。并且，启用该特性不需要 Docker 进行任何配
置。
使用一些有增强安全特性的容器模板，比如带 AppArmor 的模板和 Redhat 带
SELinux 策略的模板。这些模板提供了额外的安全特性。
用户可以自定义访问控制机制来定制安全策略。
跟其它添加到 Docker 容器的第三方工具一样（比如网络拓扑和文件系统共享），
有很多类似的机制，在不改变 Docker 内核情况下就可以加固现有的容器。
178
总结
总结
总体来看，Docker 容器还是十分安全的，特别是在容器内不使用 root 权限来运行
进程的话。
另外，用户可以使用现有工具，比如 Apparmor, SELinux, GRSEC 来增强安全性；
甚至自己在内核中实现更复杂的安全机制。
179
底层实现
底层实现
Docker 底层的核心技术包括 Linux 上的命名空间（Namespaces）、控制组
（Control groups）、Union 文件系统（Union file systems）和容器格式
（Container format）。
我们知道，传统的虚拟机通过在宿主主机中运行 hypervisor 来模拟一整套完整的硬
件环境提供给虚拟机的操作系统。虚拟机系统看到的环境是可限制的，也是彼此隔
离的。 这种直接的做法实现了对资源最完整的封装，但很多时候往往意味着系统资
源的浪费。 例如，以宿主机和虚拟机系统都为 Linux 系统为例，虚拟机中运行的应
用其实可以利用宿主机系统中的运行环境。
我们知道，在操作系统中，包括内核、文件系统、网络、PID、UID、IPC、内存、
硬盘、CPU 等等，所有的资源都是应用进程直接共享的。 要想实现虚拟化，除了
要实现对内存、CPU、网络IO、硬盘IO、存储空间等的限制外，还要实现文件系
统、网络、PID、UID、IPC等等的相互隔离。 前者相对容易实现一些，后者则需要
宿主机系统的深入支持。
随着 Linux 系统对于命名空间功能的完善实现，程序员已经可以实现上面的所有需
求，让某些进程在彼此隔离的命名空间中运行。大家虽然都共用一个内核和某些运
行时环境（例如一些系统命令和系统库），但是彼此却看不到，都以为系统中只有
自己的存在。这种机制就是容器（Container），利用命名空间来做权限的隔离控
制，利用 cgroups 来做资源分配。
180
基本架构
基本架构
Docker 采用了 C/S架构，包括客户端和服务端。 Docker daemon 作为服务端接受
来自客户的请求，并处理这些请求（创建、运行、分发容器）。 客户端和服务端既
可以运行在一个机器上，也可通过 socket 或者 RESTful API 来进行通信。
图 1.15.1.1 - Docker 基本架构
Docker daemon 一般在宿主主机后台运行，等待接收来自客户端的消息。 Docker
客户端则为用户提供一系列可执行命令，用户用这些命令实现跟 Docker daemon
交互。
181
基本架构
182
命名空间
命名空间
命名空间是 Linux 内核一个强大的特性。每个容器都有自己单独的命名空间，运行
在其中的应用都像是在独立的操作系统中运行一样。命名空间保证了容器之间彼此
互不影响。
pid 命名空间
不同用户的进程就是通过 pid 命名空间隔离开的，且不同命名空间中可以有相同
pid。所有的 LXC 进程在 Docker 中的父进程为Docker进程，每个 LXC 进程具有不
同的命名空间。同时由于允许嵌套，因此可以很方便的实现嵌套的 Docker 容器。
net 命名空间
有了 pid 命名空间, 每个命名空间中的 pid 能够相互隔离，但是网络端口还是共享
host 的端口。网络隔离是通过 net 命名空间实现的， 每个 net 命名空间有独立的
网络设备, IP 地址, 路由表, /proc/net 目录。这样每个容器的网络就能隔离开来。
Docker 默认采用 veth 的方式，将容器中的虚拟网卡同 host 上的一 个Docker 网桥
docker0 连接在一起。
ipc 命名空间
容器中进程交互还是采用了 Linux 常见的进程间交互方法(interprocess
communication - IPC), 包括信号量、消息队列和共享内存等。然而同 VM 不同的
是，容器的进程间交互实际上还是 host 上具有相同 pid 命名空间中的进程间交互，
因此需要在 IPC 资源申请时加入命名空间信息，每个 IPC 资源有一个唯一的 32 位
id。
mnt 命名空间
类似 chroot，将一个进程放到一个特定的目录执行。mnt 命名空间允许不同命名空
间的进程看到的文件结构不同，这样每个命名空间 中的进程所看到的文件目录就被
隔离开了。同 chroot 不同，每个命名空间中的容器在 /proc/mounts 的信息只包含
所在命名空间的 mount point。
183
命名空间
uts 命名空间
UTS("UNIX Time-sharing System") 命名空间允许每个容器拥有独立的 hostname
和 domain name, 使其在网络上可以被视作一个独立的节点而非 主机上的一个进
程。
user 命名空间
每个容器可以有不同的用户和组 id, 也就是说可以在容器内用容器内部的用户执行
程序而非主机上的用户。
*注：关于 Linux 上的命名空间，这篇文章 介绍的很好。
184
控制组
控制组
控制组（cgroups）是 Linux 内核的一个特性，主要用来对共享资源进行隔离、限
制、审计等。只有能控制分配到容器的资源，才能避免当多个容器同时运行时的对
系统资源的竞争。
控制组技术最早是由 Google 的程序员 2006 年起提出，Linux 内核自 2.6.24 开始
支持。
控制组可以提供对容器的内存、CPU、磁盘 IO 等资源的限制和审计管理。
185
联合文件系统
联合文件系统
联合文件系统（UnionFS）是一种分层、轻量级并且高性能的文件系统，它支持对
文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个
虚拟文件系统下(unite several directories into a single virtual filesystem)。
联合文件系统是 Docker 镜像的基础。镜像可以通过分层来进行继承，基于基础镜
像（没有父镜像），可以制作各种具体的应用镜像。
另外，不同 Docker 容器就可以共享一些基础的文件系统层，同时再加上自己独有
的改动层，大大提高了存储的效率。
Docker 中使用的 AUFS（AnotherUnionFS）就是一种联合文件系统。 AUFS 支持
为每一个成员目录（类似 Git 的分支）设定只读（readonly）、读写（readwrite）
和写出（whiteout-able）权限, 同时 AUFS 里有一个类似分层的概念, 对只读权限的
分支可以逻辑上进行增量地修改(不影响只读部分的)。
Docker 目前支持的联合文件系统种类包括 AUFS, btrfs, vfs 和 DeviceMapper。
186
容器格式
容器格式
最初，Docker 采用了 LXC 中的容器格式。自 1.20 版本开始，Docker 也开始支持
新的 libcontainer 格式，并作为默认选项。
对更多容器格式的支持，还在进一步的发展中。
187
网络
Docker 网络实现
Docker 的网络实现其实就是利用了 Linux 上的网络命名空间和虚拟网络设备（特别
是 veth pair）。建议先熟悉了解这两部分的基本概念再阅读本章。
基本原理
首先，要实现网络通信，机器需要至少一个网络接口（物理接口或虚拟接口）来收
发数据包；此外，如果不同子网之间要进行通信，需要路由机制。
Docker 中的网络接口默认都是虚拟的接口。虚拟接口的优势之一是转发效率较
高。 Linux 通过在内核中进行数据复制来实现虚拟接口之间的数据转发，发送接口
的发送缓存中的数据包被直接复制到接收接口的接收缓存中。对于本地系统和容器
内系统看来就像是一个正常的以太网卡，只是它不需要真正同外部网络设备通信，
速度要快很多。
Docker 容器网络就利用了这项技术。它在本地主机和容器内分别创建一个虚拟接
口，并让它们彼此连通（这样的一对接口叫做 veth pair ）。
创建网络参数
Docker 创建一个容器的时候，会执行如下操作：
创建一对虚拟接口，分别放到本地主机和新容器中；
本地主机一端桥接到默认的 docker0 或指定网桥上，并具有一个唯一的名字，
如 veth65f9；
容器一端放到新容器中，并修改名字作为 eth0，这个接口只在容器的命名空间
可见；
从网桥可用地址段中获取一个空闲地址分配给容器的 eth0，并配置默认路由到
桥接网卡 veth65f9。
完成这些之后，容器就可以使用 eth0 虚拟网卡来连接其他容器和其他网络。
可以在 docker run 的时候通过 --net 参数来指定容器的网络配置，有4个可
选值：
--net=bridge 这个是默认值，连接到默认的网桥。
188
网络
--net=host 告诉 Docker 不要将容器网络放到隔离的命名空间中，即不要
容器化容器内的网络。此时容器使用本地主机的网络，它拥有完全的本地主机
接口访问权限。容器进程可以跟主机其它 root 进程一样可以打开低范围的端
口，可以访问本地网络服务比如 D-bus，还可以让容器做一些影响整个主机系
统的事情，比如重启主机。因此使用这个选项的时候要非常小心。如果进一步
的使用 --privileged=true ，容器会被允许直接配置主机的网络堆栈。
--net=container:NAME_or_ID 让 Docker 将新建容器的进程放到一个已存
在容器的网络栈中，新容器进程有自己的文件系统、进程列表和资源限制，但
会和已存在的容器共享 IP 地址和端口等网络资源，两者进程可以直接通过