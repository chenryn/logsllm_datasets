Peer-to-
https:
PPcoin:
USENIX Association
26th USENIX Security Symposium    1441
[51] KOGIAS, E. K., JOVANOVIC, P., GAILLY, N., KHOFFI, I.,
GASSER, L., AND FORD, B. Enhancing Bitcoin security and
performance with strong consistency via collective signing.
In
25th USENIX Security Symposium (USENIX Security 16) (2016),
pp. 279–296.
[52] LEWENBERG, Y., SOMPOLINSKY, Y., AND ZOHAR, A. Inclu-
In Financial Cryptography (Puerto
sive block chain protocols.
Rico, 2015).
[53] LI, Y., MCCUNE, J., NEWSOME, J., PERRIG, A., BAKER, B.,
AND DREWRY, W. Minibox: A two-way sandbox for x86 native
In 2014 USENIX annual technical conference (USENIX
code.
ATC 14) (2014), pp. 409–420.
[54] LITECOIN PROJECT. Litecoin, open source P2P digital currency.
https://litecoin.org, retrieved Nov. 2014.
[55] LOMBROZO, E., LAU, J., AND WUILLE, P. BIP141: Segregated
witness (consensus layer). https://web.archive.org/web/
20160521104121/https://github.com/bitcoin/bips/
blob/master/bip-0141.mediawiki, 2015.
[56] MAZIERES, D. The Stellar consensus protocol: A federated
model for Internet-level consensus. https://web.archive.
org/web/20161025142145/https://www.stellar.org/
papers/stellar-consensus-protocol.pdf, 2015.
[57] MCKEEN, F., ALEXANDROVICH, I., BERENZON, A., ROZAS,
C. V., SHAFI, H., SHANBHOGUE, V., AND SAVAGAONKAR,
U. R.
Innovative instructions and software model for isolated
In Proceedings of the 2nd International Workshop
execution.
on Hardware and Architectural Support for Security and Privacy
(2013), p. 10.
[58] MILLER, A., SHI, E., JUELS, A., PARNO, B., AND KATZ, J.
Permacoin: Repurposing Bitcoin work for data preservation. In
Proceedings of the IEEE Symposium on Security and Privacy
(San Jose, CA, USA, 2014), IEEE.
[59] MILUTINOVIC, M., HE, W., WU, H., AND KANWAL, M. Proof
of luck: An efﬁcient blockchain consensus protocol. In Proceed-
ings of the 1st Workshop on System Software for Trusted Execu-
tion (New York, NY, USA, 2016), SysTEX ’16, ACM, pp. 2:1–
2:6.
[60] NAKAMOTO, S. Bitcoin: A peer-to-peer electronic cash system.
http://www.bitcoin.org/bitcoin.pdf, 2008.
[61] NAYAK, K., KUMAR, S., MILLER, A., AND SHI, E. Stub-
born mining: Generalizing selﬁsh mining and combining with
an eclipse attack. IACR Cryptology ePrint Archive 2015 (2015),
796.
[62] PASS, R., SEEMAN, L., AND SHELAT, A. Analysis of the
blockchain protocol in asynchronous networks. Tech. rep., Cryp-
tology ePrint Archive, Report 2016/454, 2016.
[63] PASS, R., AND SHI, E. Hybrid consensus: Efﬁcient consensus
in the permissionless model. Cryptology ePrint Archive, Report
2016/917, 2016. http://eprint.iacr.org/2016/917.
[64] POPPER, N. Central banks consider Bitcoin’s technology, if not
Bitcoin. New York Times, Oct. 2016.
[65] ROSS, R., AND SEWELL,
Foldingcoin white paper.
https://web.archive.org/web/20161022232226/http:
//foldingcoin.net/the-coin/white-paper/, 2015.
J.
[66] SAPIRSHTEIN, A., SOMPOLINSKY, Y., AND ZOHAR, A. Opti-
mal selﬁsh mining strategies in Bitcoin. CoRR abs/1507.06183
(2015).
[67] SIMON JOHNSON, VINNIE SCARLATA, CARLOS ROZAS,
ERNIE BRICKELL, AND FRANK MCKEEN. Intel Software Guard
Extensions: EPID Provisioning and Attestation Services, 2015.
[68] SOMPOLINSKY, Y., AND ZOHAR, A. Accelerating Bitcoin’s
transaction processing. fast money grows on trees, not chains. In
Financial Cryptography (Puerto Rico, 2015).
[69] SWIFT, AND ACCENTURE. Swift on distributed ledger tech-
nologies. Tech. rep., SWIFT and Accenture, 2016.
[70] TRAMER, F., ZHANG, F., LIN, H., HUBAUX, J.-P., JUELS, A.,
AND SHI, E. Sealed-glass proofs: Using transparent enclaves
to prove and sell knowledge. Cryptology ePrint Archive, Report
2016/635, 2016. http://eprint.iacr.org/2016/635.
[71] USER “QUANTUMMECHANIC”.
of proof of work.
20160320104715/https://bitcointalk.org/index.
php?topic=27787.0.
Proof of stake instead
https://web.archive.org/web/
[72] WOOD, G. Ethereum: A secure decentralised generalised trans-
action ledger (EIP-150 revision). https://web.archive.org/
web/20161019105532/http://gavwood.com/Paper.pdf,
2016.
[73] XU, Y., CUI, W., AND PEINADO, M. Controlled-channel at-
tacks: Deterministic side channels for untrusted operating sys-
In Proc. IEEE Symp. Security and Privacy (May 2015),
tems.
pp. 640–656.
[74] YEE, B., SEHR, D., DARDYK, G., CHEN, J. B., MUTH, R.,
ORMANDY, T., OKASAKA, S., NARULA, N., AND FULLAGAR,
N. Native Client: A Sandbox for Portable, Untrusted x86 Native
Code. In Proceedings of the 30th IEEE Symposium on Security
and Privacy (May 2009), pp. 79–93.
[75] ZHANG, F., CECCHETTI, E., CROMAN, K., JUELS, A., AND
SHI, E. Town crier: An authenticated data feed for smart con-
tracts. In Proceedings of the 2016 ACM SIGSAC Conference on
Computer and Communications Security (New York, NY, USA,
2016), CCS ’16, ACM, pp. 270–282.
[76] ZHANG, F., EYAL, I., ESCRIVA, R., JUELS, A., AND VAN RE-
NESSE, R. REM: Resource-Efﬁcient Mining for Blockchains.
Cryptology ePrint Archive, Report 2017/179, 2017. http://
eprint.iacr.org/2017/179.
A Tolerating Compromised SGX Nodes:
Details
A.1 Mining Rate Estimation
We start by discussing how to statistically infer the power
of a CPU from its blocks in the blockchain. Reading the
difﬁculty of each block in the main chain and the rate
of blocks from a speciﬁc CPU, we can estimate a lower
bound of that CPU’s power – it follows directly from the
rate of its blocks. It is a lower bound since the CPU might
not be working continuously, and the estimate’s accuracy
increases with the number of available blocks.
Recall Cmi is the blocks mined by miner mi so far. Cmi
may contain multiple blocks, perhaps with varying dif-
ﬁculties. Without loss of generality, we write the difﬁ-
culty as a function of time, d(t). The difﬁculty is the
probability for a single instruction to yield a win. De-
note the power of the miner, i.e., its mining rate, by ratei.
Therefore in a given time interval of length T , the num-
ber of blocks mined by a speciﬁc CPU obeys Poisson
distribution (since CPU rates are high and the win prob-
ability is small, it’s appropriate to approximate a Bino-
mial distribution by a Poisson distribution,) and with rate
rateiT d(t). Further, under independence assumption, the
1442    26th USENIX Security Symposium
USENIX Association
mining process of a speciﬁc CPU is speciﬁed by a Pois-
son process with rate λi(t) = rateid(t), the product of the
probability and the miner’s rate ratei.
There are many methods to estimate the mean of a
Poisson distribution. We refer readers to the full ver-
sion [76] for more details. Knowing rates for all miners,
the rate of the strongest CPU (ratebest) can be estimated.
The challenge here is to limit the inﬂuence of adversar-
ial nodes. To this end, instead of ﬁnding the strongest
CPU directly, we approximate ratebest based on rateρ
(e.g. f90%), namely the ρ−percentile fastest miner.
Bootstrapping. During the launch of a cryptocur-
rency, it could be challenging to estimate the mining
power of the population accurately, potentially leading
to poisoning attacks by an adversary. At this early stage,
it makes sense to hardwire a system estimate of the max-
imum mining power of honest miners into the system
and set conditions (e.g., a particular mining rate or tar-
get date) to estimate ratebest as we propose above. If the
cryptocurrency launches with a large number of miners,
an even simpler approach is possible before switching
to ratebest estimation: We can cap the total number of
blocks that any one node can mine, a policy we illustrate
below. (See Psimple.)
A.2 Security game deﬁnition
We model REM as an interaction among three entities: a
blockchain consensus algorithm, an adversary, and a set
of honest miners. Their behavior together deﬁnes a secu-
rity game, which we deﬁne formally below. We charac-
terize the three entities respectively as (ideal) programs
progchain, progA, and progm, which we now deﬁne.
Blockchain consensus algorithm (progchain). A con-
sensus algorithm determines which valid blocks are
added to a blockchain C. We assume that underlying
consensus and fork resolution are instantaneous; loosen-
ing this assumption does not materially affect our anal-
yses. We also assume that block timestamping is accu-
rate. Timestamps can technically be forged at block gen-
eration, but in practice miners reject blocks with large
skews [18], limiting the impact of timestamp forgery.
Informally, progchain maintains and broadcasts and au-
thoritative blockchain C.
In addition to verifying that
block contents are correct, progchain appends to C only
blocks that are valid under a policy P. We model the
blockchain consensus algorithm as the (ideal) stateful
program speciﬁed in Figure 11.
Adversary A (progA).
In our model, an adversary A
executes a strategy ΣA that coordinates the k miners MA
under her control to generate blocks. Speciﬁcally:
progchain[P]
State:
C: the chain
On receive “init”:
C := ∅
d := d0
Send (C,P,d) to all miners
On receive “submit” B from m:
if P(C,B) = accept:
C ← C∪{B}
d ← adjust(C,d)
Send (C,P,d) to all miners
Figure 11: The program for a blockchain. We omit details here
on how difﬁculty d is set, i.e., how d0 and adjust are chosen.
progA[ΣA]
On receive (C,P,d) from progchain
ˆt, ˆm ← ΣA(MA,C,P,d)
if ˆt is not ⊥:
wait until ˆt
send “submit” (ˆt, ˆm,d) to progchain
Figure 12: The program for an adversary A that controls k
nodes MA = {mA1,··· ,mAk}.
Deﬁnition 4.
(Adversarial Strategy). An adversarial
strategy is a probabilistic algorithm ΣA that takes in a
set of identities, the current blockchain and the policy,
and outputs a time-stamp and identity for block submis-
sion. Speciﬁcally, (MA,C,t,P) → (ˆt, ˆm) ∈ R+ × MA.
In principle, ΣA can have dependencies among indi-
vidual node behaviors. In our setting, this would not ben-
eﬁt A, however. As we don’t know MA a priori, though,
the only policies we consider operate on individual miner
block-generation history.
As a wrapper expressing implementation by A of ΣA,
we model A as a program progA, speciﬁed in Figure 12.
Honest miners (progm). Every honest miner m ∈ M −
MA follows an identical strategy, a probabilistic algo-
rithm denoted Σh. In REM, Σh may be modeled as a sim-
ple algorithm that samples from a probability distribution
on block mining times determined by rate(m) (speciﬁ-
cally in our setting, an exponential distribution with rate
rate(m)). We express implementation by honest miner m
of Σh as a program progm[Σh] (Figure 13).
To understand the security of REM, we consider a se-
curity game that deﬁnes how an adversary A interacts
with honest miners, a blockchain consensus protocol,
USENIX Association
26th USENIX Security Symposium    1443
progm[Σh]
On receive (C,P,d) from progchain
ˆt ← Σh(C,d)
Send “submit” (ˆt,m,d) to progchain
Figure 13: The program for an honest miner. Σh is the protocol
deﬁned by progchain(e.g. PoET or PoUW).
Psimple(C,B):
parse B → (τ,m,d)
if |Cm| > 0:
output reject
else
output accept
Figure 14: A simple policy that allows one block per CPU over
its lifetime.
and a policy given the above three ideal programs. For-
mally:
Deﬁnition 5.
(Security Game) For a given triple
of ideal programs (progchain[P], progA[ΣA], progm[Σh]),
and policy P, a security game S(P) is a tuple S(P) =
((M,MA,rate(·)); (ΣA,Σh)).
We deﬁne the execution of S(P) as an interactive exe-
cution of programs (progchain[P], progA[ΣA], progm[Σh])
using the parameters of S(P). As P, ΣA and Σh are ran-
domized algorithms, such execution is itself probabilis-
tic. Thus we may view the blockchain resulting from
execution of S for interval of time τ as a random variable
CS(τ).
A non-degenerate security game S is one in which
there exists at least one honest miner m with rate(m) > 0.
A.3 Warmup policy
As a warmup, we give a simple example of a poten-
tial block-acceptance policy. This policy just allows one
block throughout the life of a CPU, as shown in Fig-
ure 14.
Clearly, an adversary cannot do better than mining
one block. Denote this simple strategy Σsimple. For any
non-degenerate security game S, therefore, the advantage
(τ) = 1 as τ → ∞. This policy is optimal in
Adv
that an adversary cannot do better than an honest miner
unconditionally. However the asymptotic waste of this
policy is 100%.
S(Psimple)
A
Another disadvantage of this policy is that it discour-
ages miners from participating. Arguably, a miner would
stay if the revenue from mining is high enough to cover
the cost of replacing a CPU. But though a CPU is still
valuable in other contexts even if it is is blacklisted for-
ever in this particular system, repurposing it incurs op-
erational cost. Therefore chances are this policy would
cause a loss of mining power, especially when the ini-
tial miner population is small, rendering the system more
vulnerable to attacks.
A.4 Adversarial advantage
A block-acceptance policy depends only on the number
of blocks by the adversary since its ﬁrst one. There-
fore an adversary’s best strategy is simply to publish its
blocks as soon as they won’t be rejected. Denote this
strategy as Σstat.
Clearly, an adversary will submit F−1(1 − α,td ·
ratebest) blocks within [0,t]. On the other hand, the
strongest honest CPU with rate ratebest mines td · ratebest
blocks in expectation. Recall that according to our
Markov chain analysis, Pstat incurs false rejections for
honest miners with probability wh(α), which further
reduces the payoff for honest miners.
For a (non-
degenerate) security game S, in which A uses strategy
Σstat, the advantage is therefore:
Adv
S(Pα
A
stat)
= lim
t→∞
F−1(1− α,td · ratebest)
(1− wh(α)) td · ratebest
(5)
Theorem 1.
where A uses strategy Σstat,
In a (non-degenerate) security game S
Adv
stat)
S(Pα
A
=
1
1− Waste(Pα
stat)
.
Proof. Let λ = td · ratebest. It is known that as λ for a
Poisson distribution goes to inﬁnity, it converges in the
limit to a normal distribution with mean and variance λ .
Therefore,
√
λ zp
F−1(1− α,λ )
(1− wh(α))λ = lim
λ→∞
lim
λ→∞
λ +
(1− wh(α)) λ =
1
1− wh(α)
.
Early in a blockchain’s evolution, the potential advan-
tage of an adversary is relatively high. The conﬁdence in-
terval is wide at this point, allowing the adversary to per-
form frequent generation without triggering detection.
As the adversary publishes more blocks, the conﬁdence
interval tightens, forcing the adversary to reduce her min-
ing rate. This is illustrated by our numerical simulation
in Section 4.3.
1444    26th USENIX Security Symposium
USENIX Association