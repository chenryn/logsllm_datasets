### 4. 评估

我们基于Ghidra [8] 实现了FirmXRay的原型，并编写了超过5000行代码。尽管市场上存在许多微控制器（MCU）制造商，但我们的实现特别针对基于Nordic或TI软件开发工具包（SDK）开发的裸机固件。在本节中，我们将展示评估结果。首先，在§5.1中描述实验设置；然后，在§5.2中提供详细的实验结果，最后在§5.3中介绍攻击案例研究。

#### 5.1 实验设置

**裸机固件收集**

为了评估FirmXRay，我们首先需要收集裸机固件。直观上，我们可以通过爬取制造商网站上的固件或从实际设备硬件中提取固件来完成这一任务。然而，这两种方法都不具备可扩展性，原因如下：首先，开发者很少公开发布设备固件；其次，购买所有这些设备的成本非常高昂。因此，我们必须寻找一种成本效益高且可扩展的方法。如§2.1所述，裸机固件通常通过移动应用传输到设备以进行空中升级，因此这些应用至少应具有下载固件的能力。这使我们能够通过逆向工程其下载逻辑来开发一种基于移动应用的方法来收集固件。令人惊讶的是，我们注意到许多应用实际上并未实现这种逻辑，而是直接利用应用商店中的移动应用更新机制来升级固件，将固件镜像嵌入到应用包内。

因此，我们开发了一个简单的脚本来自动解包移动应用并大规模提取裸机固件。具体来说，我们在2020年2月从Google Play爬取了约200万个免费应用作为数据集。进一步筛选出使用低功耗蓝牙（BLE）的应用，通过扫描相关API（例如startScan），最终获得了135,486个应用。从这些BLE应用中，我们直接解包APK文件并提取Nordic和TI固件，因为它们具有独特的签名，可以轻松区分（例如，固件头中的魔数）。最终，我们成功获取了793个独特的裸机固件（其中768个来自Nordic，25个来自TI）。需要注意的是，一个应用可能包含多个固件，因为（1）一个设备可能有不同版本的固件（例如，从同一ShockLink应用中提取的不同版本的医疗设备固件），或者（2）一个应用可能有同一类别的多个设备（例如，Kinsa应用中的两种类型的温度计）。我们将同一设备的不同版本归为一组，发现这793个固件代表了538个独特设备。

**固件分类**

为了更好地理解不同类型固件的安全影响，我们需要对其进行分类。虽然直接从固件代码中推断类别具有挑战性，但我们注意到有两个来源可以帮助我们：（i）Nordic SDK函数`SD_BLE_GAP_APPEARANCE_SET`的参数，该参数指定了设备类型（例如，传感器、键盘等，共有50种类型）；（ii）与固件相关的移动应用描述。因此，我们采用以下方法来推断固件类别：如果固件代码中存在`SD_BLE_GAP_APPEARANCE_SET` API，我们直接获取设备类型；否则，我们根据应用描述手动推断设备类别。通过这种方法，我们最终识别出了108个固件类别（注意，超出API定义的额外类别来自于我们对应用描述的手动分析）。表2的第一列列出了至少包含两个设备的类别，我们可以看到前五个最常见的类别是（1）可穿戴设备（例如，智能手环和智能手表）、（2）传感器（例如，速度和湿度传感器）、（3）标签（例如，设备追踪器）、（4）机器人（例如，机器狗）和（5）医疗设备（例如，血压监测仪）。对于只有一个设备的类别（例如，无人机、SIM卡充电器、智能行李箱），我们将它们汇总在表2的第二行所示的“其他”类别中。

**实验环境**

我们的分析是在一台配备十二个Intel Core i7-8700 (3.20 GHz) CPU和32 GB RAM的Linux服务器上进行的，运行Ubuntu 18.04.2 LTS操作系统。

#### 5.2 实验结果

在538个独特设备（来自793个固件）中，FirmXRay已识别出528个（98.1%）配置了随机静态MAC地址，385个（71.5%）使用了Just Works配对，以及530个（98.5%）使用Legacy配对进行不安全密钥交换。表2的第6至11列详细列出了各类固件中的漏洞统计情况。接下来，我们将详细介绍FirmXRay是如何得出这些结果的。特别是，我们首先在§5.2.1中描述了固件基址识别的有效性，然后在§5.2.2、§5.2.3和§5.2.4中分别介绍了三种类型的漏洞识别结果。

##### 5.2.1 基址识别的有效性

为了验证我们的基址识别效果，我们首先需要查找基址的真实值。有趣的是，我们注意到有42个固件在其文件名中暴露了它们的SDK版本（例如S110、S130），这使得我们可以根据SDK规范来确定它们的基址。在这些固件中，FirmXRay正确恢复了所有基址而没有任何误报。我们进一步通过仅使用三组指针中的一个来推断基址，展示了结合三组指针的优势。详细的实验结果见表3，该表显示了在42个真实样本中，（不）正确恢复基址的固件数量。如表所示，仅使用一组指针会导致4.8%至66.7%的误报率。我们进一步调查了这些案例，发现失败的原因在于缺乏足够的绝对指针。例如，nrf52810_xxaa.bin固件只包含7个绝对函数指针，而其他固件通常有数十个这样的指针。因此，我们必须结合所有三组指针以减少误报。

| 指针类型 | 绝对函数指针 | 绝对字符串指针 | 向量表项 | 三组组合 |
| --- | --- | --- | --- | --- |
| 真阳性数（%） | 40 (95.2%) | 14 (33.3%) | 40 (95.2%) | 42 (100%) |
| 假阳性数（%） | 2 (4.8%) | 28 (66.7%) | 2 (4.8%) | 0 (0%) |

表3：使用一组指针的基址识别。

![](Figure_7.png)

图7：目标函数值N(x)的分布：
(a)(c)单个固件的候选基址，
(b)(d)所有固件中识别出的基址。

![](Table_2.png)

表2：不同固件类别的实验结果。（F: 固件, D: 设备, IT: 身份跟踪, AM: 主动中间人攻击, PM: 被动中间人攻击）

![](Table_4.png)

表4：一些示例固件及其对应的移动应用。