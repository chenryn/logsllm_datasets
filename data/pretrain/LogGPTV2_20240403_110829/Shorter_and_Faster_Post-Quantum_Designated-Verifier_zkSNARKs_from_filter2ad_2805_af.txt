the ring dimension, 𝑑 is the module rank, 𝑞 is the ciphertext
modulus, 𝑠 is the width parameter for the discrete Gaussian
noise distribution, ℓ is the dimension of the plaintext space,
and 𝜏 is the sparsification parameter. Parameters shown are
based on supporting an R1CS system with 220 constraints.
The final two rows correspond to the “Shorter Proofs” and
the “Shorter CRS” instantiations in Table 1, respectively.
Lattice parameter selection. Due to space limitations, we defer
our parameter selection methodology to the full version of this
paper [78]. We describe several example parameter sets and their
estimated bits of classical and post-quantum security in Table 2.
For our main experiments, we use 𝜅 = 40 for the statistical zero-
knowledge parameter; the remaining parameters are chosen to
provide 128-bits of post-quantum security (based on the analysis
from Section 3.3 and hardness estimates from the LWE Estimator
tool et al. [1]).
𝑞 is uniformly random and c ∈ 𝑅ℓ′
Reducing the CRS size. Like most Regev-based encryption schemes,
the ciphertexts in Construction 3.5 have the form ct = (a, c) where
a ∈ 𝑅𝑛
𝑞 encodes the message. A
heuristic approach to reduce the ciphertext size is to derive the
random vector a as the output of a pseudorandom function (PRF)
and include the PRF key in place of the vector a (or alternatively,
take them to be the outputs of a public hash function). Security of
these heuristics can be justified in the random oracle model [62].
We adopt this approach in our implementation. In our implementa-
tion, we use AES (in counter mode) as the underlying PRF. Simi-
lar approaches for reducing the size of the public components of
lattice-based cryptosystems has been used for both lattice-based
key-exchange [38] as well as previous lattice-based zkSNARKs [65].
Noise distribution. We take our noise distribution 𝜒 to be a dis-
crete Gaussian distribution 𝜒 = 𝜒𝑠 with mean 0 and width 𝑠
(Eq. (A.1)). We use inversion sampling to sample from ˜𝜒𝑠 given
a uniformly-random 64-bit value. We refer to the full version of this
paper [78] for more details. This is similar to the approach used in
lattice-based key-exchange [38].
Big integer support. In our implementation, the ciphertext mod-
ulus 𝑞 is around 100 bits. We implement all of the homomorphic
operations (over the ring 𝑅𝑞) using 128-bit arithmetic. Since we
choose 𝑞 to be a power-of-two, we can compute over Z2128 and defer
the modular reduction to the end of the computation.
Session 1C: Zero Knowledge I CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea221We use the compiler intrinsic type __uint128_t for 128-bit arith-
metic on a 64-bit architecture. Internally, each 128-bit value is rep-
resented by two 64-bit words. The intrinsic representation is 16×
faster than using a general multi-precision arithmetic and 8×–9×
than fixed-point arithmetic for slightly larger bitlengths (i.e., 192-bit
or 256-bit fixed-precision arithmetic from Boost). We provide more
detailed microbenchmarks in the full version of this paper [78].
4.3 Experimental Evaluation
We now describe our implementation and experimental evaluation
of our lattice-based zkSNARK from Section 3.4.
System implementation. Our implementation is written in C++.7
We use libsnark [96] and libfqfft [94] to implement the linear
PCP for R1CS satisfiability (Claim A.6). In particular, we use the lin-
ear PCP implementation from libsnark (with the minor changes
from Appendix B), and the implementation of the standard radix-2
FFT [50] (over a finite field) as well as the Bostan-Schost algorithms
for multipoint evaluation and interpolation on points from a geo-
metric sequence [39] from libfqfft. These building blocks suffice
to implement our approach described in Section 4.1 for evaluating
the linear PCP.
Metrics and evaluation methodology. Following previous works [21,
47, 99], we measure the performance of our system on R1CS sys-
tems with different number of constraints 𝑚 (ranging from 𝑚 = 210
to 𝑚 = 220). Like previous works, we keep the number of variables 𝑛
in each R1CS system to be roughly 𝑚 (i.e., 𝑛 ≈ 𝑚), and we consider
statements of a fixed length 𝑘 = 100. The statement length only has
a mild effect on the verification complexity (which is already very
fast) and we do not focus on it in our evaluation.
We run all of our experiments on an Amazon EC2 c5.4xlarge
instance running Ubuntu 20.04. The machine has 16 vCPUs (Intel
Xeon Platinum 8124M at 3.0 GHz) and 32 GB of RAM. The processor
supports the AES-NI instruction set. We compile our code using
gcc 9.3.0 for a 64-bit x86 architecture. All of our measurements
are taken with a single-threaded execution.
General benchmarks. In Fig. 1, we compare the performance
of different instantiations of our zkSNARK on R1CS instances of
varying sizes. We consider two instantiations using linear PCPs
and vector encryption over the extension field F𝑝2 (for 𝑝 = 213 − 1
and 𝑝 = 219 − 1), as well as two alternative instantiations where
we use a vector encryption over the base field F𝑝. For the latter
instantiations, we consider both the instantiation where we first
compile a linear PCP over the extension field to a linear PCP over
the base field (Construction C.1) and a second instantiation where
we directly construct a linear PCP over the base field. Across the
board, the verifier time is small so we focus our discussion on the
other metrics.
For our main instantiations (working over the extension field),
the field size provides a trade-off in CRS size vs. proof size. Using
a larger field decreases the CRS size (fewer repetitions needed for
knowledge amplification at the linear PCP level), but leads to longer
proofs (due to larger parameters). Concretely, for R1CS systems
with 220 constraints, increasing the characteristic from 𝑝 = 213 − 1
7Available
zksnark.
https://github.com/lattice-based-zkSNARKs/lattice-
here:
to 𝑝 = 219 − 1 decreases the CRS size by 2.8× (with a corresponding
decrease in setup time), but increases the proof size by 1.2×. The
prover complexity is essentially the same in the two cases.
In the case where we take a linear PCP over F𝑝2 and first apply
Construction C.1 to obtain a linear PCP over F𝑝, the proof size
still remains comparable to the case where we work exclusively
over F𝑝2. However, the CRS size is doubled since Construction C.1
increases the query length by the degree of the field extension, as
is the prover complexity. The advantage of this construction is that
it is based on standard lattices as opposed to module lattices, and
thus, plausibly has better security.
Finally, if we consider the direct compilation of a linear PCP
over the base field F𝑝, the proof size is 1.4× to 1.8× longer than the
constructions that use the extension field.
Extension field vs. base field. To quantify the concrete perfor-
mance trade-off enabled by extension fields, we also compare our
zkSNARKs over F𝑝2 with an instantiation over F𝑝 (i.e., compile the
linear PCP from Claim A.6 over F𝑝 using the linear-only vector
encryption from Construction 3.5 over F𝑝). The results are sum-
marized in Fig. 2. We first note that most of the instantiations over
F𝑝 require working over a ring 𝑅𝑞 with 𝑞 > 2128. As discussed in
Section 4.2, this will incur considerable computational overhead
for the big-integer arithmetic. Working over the extension field
allows us to consider instantiations over much larger fields without
incurring the cost of big-integer arithmetic.
Fig. 2 shows that working over a quadratic extension field in-
troduces a modest increase in the CRS size (by a factor of 1.4× to
1.6×) compared to working over a prime-order base field of similar
size. In return, working over the extension field reduces the proof
size by 1.7× to 2.4× (specifically, from nearly 70 KB to under 30 KB
when considering a 56-bit field). As discussed in Section 1.2 (see
also the formal analysis in Section 3.3), all of the lattice parameters
grow with the field characteristic. Thus, for fields of comparable
size, all of the lattice parameters will be larger if we work over
a base field than if we work over an extension field (of smaller
characteristic). This leads to longer proofs. The size of the CRS is
smaller because of the CRS compression technique from Section 4.2.
In particular, each lattice ciphertext in the CRS only consists of
the message-embedding component. In this case, an element in 𝑅𝑞
is represented by a pair of integers when 𝑅 = Z[𝑋]/(𝑥2 + 1) and
by a single integer when 𝑅 = Z. Moreover, the dimension of the
message space depends only on the field size and thus, is the same
regardless of whether we work over a base field or an extension
field.8 As a result, when comparing instantiations over a base field
vs. an extension field of similar size, the CRS in the extension field
instantiation is longer.
If we consider an alternative instantiation over F𝑝 where the
prover decomposes each F𝑝 coefficient in the linear PCP proof
into two separate coefficients, each of magnitude √𝑝, then we can
support a larger field size (i.e., up to 38 bits) without requiring
a modulus 𝑞 that exceeds 128 bits. The reduced parameter sizes
translate to slightly shorter proofs (1.1×–1.2×) compared to the
8The dimension (and size) of the full ciphertext is smaller when working over the
extension field because the lattice parameters are smaller. If we only consider the
message-embedding component of the ciphertext (which is a small fraction of the
full ciphertext), then the size is smaller when working over a base field compared to
working over the extension field.
Session 1C: Zero Knowledge I CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea222105
104
103
102
101
100
)
B
M
(
e
z
i
S
S
R
C
30
25
20
15
10
)
B
K
(
e
z
i
S
f
o
o
r
P
210 212 214 216 218 220
R1CS Instance Size
104
103
102
101
)
s
(
i
e
m
T
p
u
t
e
S
S
R
C
103
102
101
100
10−1
)
s
(
i
e
m
T
r
e
v
o
r
P
210 212 214 216 218 220
R1CS Instance Size
210 212 214 216 218 220
R1CS Instance Size
210 212 214 216 218 220
R1CS Instance Size
1.5
1
0.5
0
)
s
m
(