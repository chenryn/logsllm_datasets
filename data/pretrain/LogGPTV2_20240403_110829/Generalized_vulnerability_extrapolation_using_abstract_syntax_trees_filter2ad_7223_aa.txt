title:Generalized vulnerability extrapolation using abstract syntax trees
author:Fabian Yamaguchi and
Markus Lottmann and
Konrad Rieck
Generalized Vulnerability Extrapolation
using Abstract Syntax Trees
Fabian Yamaguchi
University of Göttingen
Göttingen, Germany
Markus Lottmann
Technische Universität Berlin
Berlin, Germany
Konrad Rieck
University of Göttingen
Göttingen, Germany
ABSTRACT
The discovery of vulnerabilities in source code is a key for
securing computer systems. While speciﬁc types of security
ﬂaws can be identiﬁed automatically, in the general case the
process of ﬁnding vulnerabilities cannot be automated and
vulnerabilities are mainly discovered by manual analysis. In
this paper, we propose a method for assisting a security an-
alyst during auditing of source code. Our method proceeds
by extracting abstract syntax trees from the code and de-
termining structural patterns in these trees, such that each
function in the code can be described as a mixture of these
patterns. This representation enables us to decompose a
known vulnerability and extrapolate it to a code base, such
that functions potentially suﬀering from the same ﬂaw can
be suggested to the analyst. We evaluate our method on the
source code of four popular open-source projects: LibTIFF,
FFmpeg, Pidgin and Asterisk. For three of these projects,
we are able to identify zero-day vulnerabilities by inspecting
only a small fraction of the code bases.
1.
INTRODUCTION
The security of computer systems critically depends on the
quality of its underlying code. Even minor ﬂaws in a code
base can severely undermine the security of a computer sys-
tem and make it an easy victim for attackers. There exist
several examples of vulnerabilities that have led to security
incidents and the proliferation of malicious code in the past
[e.g. 21, 26]. A drastic case is the malware Stuxnet [7] that
featured code for exploiting four unknown vulnerabilities in
the Windows operating system, rendering conventional de-
fense techniques ineﬀective in practice.
The discovery of vulnerabilities in source code is a cen-
tral issue of computer security. Unfortunately, the process
of ﬁnding vulnerabilities cannot be automated in the gen-
eral case. According to Rice’s theorem a computer pro-
gram is unable to generally decide whether another program
contains vulnerable code [10]. Consequently, security re-
Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proﬁt or commercial advantage and that copies
bear this notice and the full citation on the ﬁrst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciﬁc
permission and/or a fee.
ACSAC ’12 Dec. 3-7, 2012, Orlando, Florida USA
Copyright 2012 ACM 978-1-4503-1312-4/12/12 ...$15.00.
search has focused on devising methods for identifying spe-
ciﬁc types of vulnerabilities.
Several approaches have been proposed that statically iden-
tify patterns of speciﬁc vulnerabilities [e.g., 4, 18, 28, 32],
such as the use of certain insecure functions. Moreover, con-
cepts from the area of software veriﬁcation have been suc-
cessfully adapted for tracking vulnerabilities, for example,
in form of fuzz testing [27], taint analysis [22] and symbolic
execution [1, 8]. Many of these approaches, however, are
limited to speciﬁc conditions and types of vulnerabilities.
The discovery of vulnerabilities in practice still mainly rests
on tedious manual auditing that requires considerable time
and expertise.
In this paper, we propose a method for assisting a security
analyst during auditing of source code. Instead of striving
for an automated solution, we aim at rendering manual au-
diting more eﬀective by guiding the search for vulnerabili-
ties. Based on the idea of vulnerability extrapolation [33], our
method proceeds by extracting abstract syntax trees from
the source code and determining structural patterns in these
trees, such that each function in the code can be described
as a mixture of the extracted patterns. The patterns contain
subtrees with nodes corresponding to types, functions and
syntactical constructs of the code base. This representation
enables our method to decompose a known vulnerability and
to suggest code with similar properties—potentially suﬀer-
ing from the same ﬂaw—to the analyst for auditing.
We evaluate the eﬃcacy of our method using the source
code of four popular open-source projects: LibTIFF, FFm-
peg, Pidgin and Asterisk. We ﬁrst demonstrate in an quan-
titative evaluation how functions are decomposed into struc-
tural patterns and how similar code can be identiﬁed auto-
matically. In a controlled experiment we are able to narrow
the search for a given vulnerability to 8.7% of the code base
and consistently outperform non-structured approaches for
vulnerability extrapolation. We also study the discovery of
real vulnerabilities in a qualitative evaluation, where we are
able to discover 10 zero-day vulnerabilities in the source code
of the four open-source projects.
In summary, we make the following contributions:
• Generalized vulnerability extrapolation: We present a
general approach to the extrapolation of vulnerabili-
ties, allowing both the content and structure of code
to be considered for ﬁnding similar ﬂaws in a code base.
• Structural comparison of code: We present a method
for robust extraction and analysis of abstract syntax
trees that allows for automatic comparison of code
with respect to structural patterns.
359
char a(uint b) {
char a(uint b) {
char a(uint b) {
  func1((int) b);
  func1((int) b);
  func1((int) b);
  func2(); ...
  func2(); ...
  func2(); ...
char a
GET
params
GET
stmts
GET
uint b
GET
func1
GET
GET...
1
params
GET
uint b
GET
char a
GET
params
GET
stmts
GET
1
Known vulnerability
Candidates
Code base of
functions
(1) Extraction of  
ASTs
(2) Embedding in 
vector space
(3) Identiﬁcation of
structural patterns
(4) Vulnerability
extrapolation
Figure 1: Schematic overview of our method for vulnerability extrapolation.
• Evaluation and cases studies: We study the capabili-
ties of our method in diﬀerent empirical experiments,
where we identify real zero-day vulnerabilities in pop-
ular open-source projects.
The rest of this paper is structured as follows: our method
for vulnerability discovery is introduced in Section 2 and its
evaluation is presented in Section 3. Limitations and related
work are discussed in Section 4 and 5, respectively. Section 6
concludes this paper.
2. VULNERABILITY EXTRAPOLATION
The concept of vulnerability extrapolation builds on the
observation that source code often contains several vulner-
abilities linked to the same ﬂawed programming patterns,
such as missing checks before or after function calls. Given a
known vulnerability, it is thus often possible to discover pre-
viously unknown vulnerabilities by ﬁnding functions sharing
similar code structure.
In practice, such extrapolation of vulnerabilities is attrac-
tive for two reasons: First, it is a general approach that
is not limited to any speciﬁc vulnerability type. Second,
the extrapolation does not hinge on any involved analysis
machinery: a robust parser and an initial vulnerability are
suﬃcient for starting an analysis. However, assessing the
similarity of code is a challenging task, as it requires ana-
lyzing and comparing structured objects, such as subtrees
of syntax trees. Previous work has thus only considered
ﬂat representations, such as function and type names, for
extrapolating vulnerabilities [see 33].
To tackle the challenge of structured data, our method
combines concepts from static analysis, robust parsing and
machine learning. It proceeds in four steps that are illus-
trated in Figure 1 and described in the following:
1. Extraction of abstract syntax trees. In the ﬁrst step,
abstract syntax trees (AST) are extracted for all func-
tions of the code base using a robust parser. This
parser is based on the concept of island grammars [20]
and capable of extracting syntax trees from C/C++
source code even without a working build environment
(Section 2.1).
2. Embedding in a vector space. The abstract syntax trees
of the functions are then embedded in a vector space,
such that techniques from machine learning can be ap-
plied to analyze the code. The embedding is accom-
plished by disregarding irrelevant nodes in the trees
and representing each function as a vector of contained
subtrees (Section 2.2).
3. Identiﬁcation of structural patterns. Based on the vec-
torial representation, structural patterns are identiﬁed
in the code using the technique of latent semantic anal-
ysis [5]. This analysis technique determines dominant
directions (structural patterns) in the vector space cor-
responding to combinations of AST subtrees frequently
occurring in the code base (Section 2.3).
4. Vulnerability Extrapolation. Finally, the functions of
the code base are described as mixtures of the iden-
tiﬁed structural patterns. This representation enables
identifying code similar to a known vulnerability by
ﬁnding functions with a similar mixture of structural
patterns (Section 2.4).
In the following, these four steps are described in detail
and the required theoretical and technical background is pre-
sented where necessary.
2.1 Robust AST Extraction
Determining arbitrary structural patterns in code demands
a ﬁne grained representation of code, similar in precision
to the abstract syntax trees (AST) generated by compilers.
Obtaining these trees directly from a compiler is only pos-
sible if a working build environment is available. Unfortu-
nately, constructing such an environment is often non-trivial
in practice, as all dependencies of the code including correct
versions of build tools and header ﬁles need to be available.
Finally, when analyzing legacy code, parts of the code may
simply not be available anymore.
As a remedy, we employ a robust parser for C/C++ based
on the concept of island grammars [20]. This parser allows
for extracting ASTs from individual source ﬁles. In contrast
to parsers integrated with a compiler, this parser does not
aim to validate the syntax of the code it processes. Instead,
the objective is to extract as much information from the
code as possible, assuming that it is syntactically valid in
the ﬁrst place.
Our parser is based on a single grammar deﬁnition for the
ANTLR parser generator [23] and publicly available1. The
parser outputs ASTs in a serialized text format as shown in
Figure 2. This serialized format is well suited for subsequent
processing and provides generic access to the structure of the
parsed code. A graphical version of the corresponding tree
is presented in Figure 3.
For our analysis we distinguish between diﬀerent types of
nodes in the syntax tree. We refer to all nodes associated
with parameter types, declaration types and function calls
as API nodes (dashed in Figure 3), as they deﬁne how the
code interfaces with other functions and libraries. Moreover,
we denote all nodes describing syntactical elements as syntax
nodes (dotted in Figure 3).
1http://codeexploration.blogspot.de/
360
1 int foo(int y)
2 {
3
int n = bar(y);
4
5
6
7
8
9 }
if (n == 0)
return 1;
return (n + y);
(a) Exemplary C function
# type depth
func
params
param
stmts
decl
op
call
arg
if
cond
op
stmts
return
return
op
0
1
2
1
2
2
3
4
2
3
4
3
4
2
3
value1
int
value2
foo
int
y
n
int
=
bar
y
(n == 0)
n == 0
==
1
(n + y)
+
(b) Serialized AST
Figure 2: Example of a C function and a serialized AST
GETfunc
params
GET
stmts
GET
param: int
decl: int
GET
=
GETif
return
GET
call: bar
GET
GETcond
GET==
stmts
GET
return
GET+
Figure 3: Abstract syntax tree with API nodes (dashed) and
syntax nodes (dotted).
2.2 Embedding of ASTs in a Vector Space
Abstract syntax trees oﬀer a rich source of information
for extraction of code patterns. However, machine learning
techniques cannot be applied directly to this type of data,
as they usually operate on numerical vectors.
To address this problem, a suitable map is required, allow-
ing ASTs to be transformed into vectors. This map needs
to capture the structure and content of the trees, and thus
is crucial for the success of vulnerability extrapolation. To
construct this map, we describe the AST of each functions
in our code base using a set of subtrees S. In particular, we
experiment with the following three deﬁnitions of the set:
1. API nodes. We consider only ﬂat function and type
names [see 33]. The set S simply consists of all indi-
vidual API nodes found in the ASTs of the code base.
All other nodes are ignored.
2. API subtrees. The set S is deﬁned as all subtrees of
depth D in the code base that contain at least one
API node. The subtrees are generalized by replacing
all non-API nodes with placeholders (empty nodes).
3. API/S subtrees. The set S consists of all subtrees of
depth D containing at least one API or syntax node.
Again, all non-API and non-syntax nodes are replaced
by placeholders (empty nodes).
Depending on this deﬁnition of S, we obtain diﬀerent
views on the functions of the code base.
If we consider
API nodes only, our characterization is shallow and we only
capture the interfacing of the functions. If we choose API
subtrees as the set S, we describe the functions in terms
of API nodes and the structural context these nodes occur
in. Finally, if we consider API/S subtrees, we obtain a view
on our code base that reﬂects API usage as well as the oc-
currences of syntactical elements in the functions.
In the
following we ﬁx the depth of subtrees to D = 3 in all ex-
periments, as this setting provides a good balance between
a shallow representation and overly complex subtrees.
Based on the set S we can deﬁne a map φ that embeds an
AST x in a vector space, where each dimension is associated
with one element of S. Formally, this map is given by
φ : X (cid:26)−→ R
|S|
, φ(x) −→ (cid:15)
(cid:16)
#(s, x) · ws
s∈S
where X refers to all ASTs of functions in our code base
and #(s, x) returns the number of occurrences of the subtree
s ∈ S in x. For convenience and later processing, we store
the vectors of all ASTs in our code base in a matrix M , where
one cell of the matrix is deﬁned as Ms,x = #(s, x) · ws.
The term ws in the map φ corresponds to a TF-IDF
weighting. This weighting ensures that subtrees occurring
very frequently in the code base have little eﬀect when as-
sessing function similarity. Furthermore, it removes the bias
towards longer functions, which can contain similar subtrees
to a lot of diﬀerent functions but are not particularly simi-
lar to any of them. A detailed description of this weighing
scheme is given by Salton and McGill [25].
Let us, as an example, consider the AST given in Figure 3
and the set S of API nodes. The tree x contains only three