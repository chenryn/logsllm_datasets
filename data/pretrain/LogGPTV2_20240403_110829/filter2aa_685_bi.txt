client components, retrieving 
input in 60–61
reading data from standard 
input streams 66–68
retrieving command-line 
parameters supplied by 
users 63–65
using spawn to avoid block-
ing input/output
68–70
Licensed to   
293
INDEX
client module 79
Client type 80
clients
adding network functionality 
to 95–98
creating instance to hold 
data about 92
creating new Client instance 
to hold data about 92
processing messages 92–95
sending messages to 95
testing server without 91–92
client-server module 59
close procedure 93, 198
cmp procedure 116
code blocks, passing to 
templates 256–257
code statements 48
collection types 39–43
arrays 39
sequences 41–42
sets 42–43
colon character 31
comma character 36
command not found error 289
command-line applications 5
command-line arguments 100, 
122–126
command-line parameters
overview 63
supplied by users, retrieving
63–65
command-line tools, Nimble
131
comments 25
community, for Nim program-
ming language 20, 281
Comparable concept 254
comparison operators 110
compatibility, of types 231
compilation 9–11
compiler
architecture 289
building from C sources
283–286
adding Nim programming 
language to PATH 286
compiling 285
downloading archives 284
extracting archives
284–285
moving archives to safe 
location 284–285
verifying installation 
of 286
compiling 285
installing 282–286
verifying installation of 286
Compiler User Guide 14
compile-time error 31
compile-time function execu-
tion. See CTFE
Comprehensive Perl Archive 
Network. See CPAN
concatenation operator 110
concept keyword 254
concurrency, parallelism 
vs. 151–152
config macro 273
configuration DSLs, creating
267–278
generating constructor 
procedures 274–275
generating load procedures
275–277
generating object types
270–274
starting configurator 
project 268–270
testing configurators 278
connect procedure 82, 96
connected flag 81, 93
const char * type 229
const keyword 32
constraining generics 252–253
constructor procedures, 
generating 274–275
Container variable 252
contextAttributes argument
245
continue keyword 44
control flow mechanisms 250
controllers, developing
210–219
adding Follow buttons
217–218
extending / routes 214
implementing /
createMessage routes
215
implementing /follow routes
218–219
implementing /login routes
212–213
implementing user routes
216–217
could not load error 289
counter variable 174, 176
counterLock 175
CPAN (Comprehensive Perl 
Archive Network) 128
cpp command 287
crash procedure 159
createDatabase module 198
createLoadProc procedure 276
createMessage procedure 78, 
97
/createMessage routes, 
implementing 215
createRefType procedure 272
createThread procedure 153, 
155, 159
createWindowAndRenderer 
procedure 239
critbits module 111
cross-compilation 14
cstring type 229
CTFE (compile-time function 
execution) 19, 260–262
curly brackets 43, 73
currentUser parameter 204
D
D programming language, fea-
tures of 19
-d release flag 167
daemonize package 135
daemons 220
data
client 92
manipulating 122–126
overview 122–126
parsing 159–167
manually using parseutils 
module 163–164
manually using split 
procedure 162–163
processing each line of 
Wikipedia page-counts 
files 164–167
understanding Wikipedia 
page-counts format
160–161
using regular expressions
161–162
Wikipedia page-counts 
format 161–164
reading from standard input 
streams 66–68
retrieving from databases
194–198
storing in databases 189–200
setting up databases
192–194
Licensed to   
294
INDEX
data, storing in databases 
(continued)
setting up types 190–192
testing databases 198–200
transferring asynchronously
91–99
adding network functional-
ity to client 95–98
creating new Client 
instance to hold data 
about client 92
final results of 98–99
processing client messages
92–95
sending messages to other 
clients 95
testing server without 
client 91–92
using sockets to transfer
79–99
asynchronous input/
output 83–91
asynchronously 91–99
data parameter 72
data parsing 179
data structures 111–117
modules 117
sets module 114–115
tables module 112–114
data variable 153
database module 192
databases
retrieving data from
194–198
setting up 192–194
storing data in 189–200
testing 198–200
DbConn object 192, 195
db_mysql module 190, 192
db_postgres module 190, 192
db_sqlite module 190, 192
Debian-based distributions 284
decimal notation 27
declarative templates 261
declareVar template 258–259
default parameters 36
defined procedure 121
delete procedure 123
dependencies, specifying in 
Nimble 141–144
deploying web applications
219–221
configuring Jester 
microframework 219
setting up reverse 
proxy 219–221
developing
controllers 210–219
adding Follow buttons
217–218
extending/routes 214
implementing /
createMessage routes
215
implementing /follow 
routes 218–219
implementing /login 
routes 212–213
implementing user routes
216–217
front-page view 207–210
packages in Nimble package 
manager 147–148
giving meaning to version 
numbers 147
storing different versions 
of single package
147–148
user view 204–206
web application view
200–210
development environments. 
See IDEs
directory layout, of packages in 
Nimble 140–141
discard keyword 34, 230
discardable pragma 239, 248
distributed version control 
systems. See DVCSs
DLL (dynamic-link library), 
could not load 289–290
do keyword 14, 19
do notation 256
doAssert procedure 76, 100, 
111
documentation
Nimble 133
standard library 108–109
domain-specific languages. 
See DSLs
dot character 52
double-quote character 29, 66
downloading
compiler archives 284
SDL libraries 235
drawLines procedure 240–241
DSLs (domain-specific lan-
guages)
creating configuration
267–278
overview 7
dumpTree macro 263, 268
DVCSs (distributed version 
control systems) 133
dynamic linking
overview 236–237
vs. static linking 227–228
dynamic type systems 8
dynamic-link library. See DLL
dynlib pragma 237, 248
E
echo procedure 64, 93, 110
efficiency of Nim 13
elif keyword 43
else branch 121
else keyword 43
EmbedElement type 247
empty nodes 270–271
end keyword 14, 19, 24
enum types 51–52
environment variables 286
equals character 36, 125
errors, catching ahead of time
18
escape procedure 207
event loops 87–88
except branch 48
except keyword 107
exceptions
handling 47–48
in threads 159
execCmd procedure 120
execCmdEx procedure 120
execution
difference between synchro-
nous and asynchronous
85–86
external processes 120–121
of compile-time function
261–262
threads 155–156
execution time
of parallel_counts 172–173
of sequential_counts 168
existsDir procedure 119
existsFile procedure 119
expectKind procedure 273
export marker 72
exportc procedure 246
external libraries, C program-
ming language
234–242
external package 133
Licensed to   
295
INDEX
external processes, executing
120–121
extracting, compiler archives
284–285
F
F4 shortcut, Aporia 62
F5 shortcut, Aporia 288
Facebook Messenger 58
failed procedure 85
features
of C ++ programming 
language 19
of C programming 
language 19
of D programming 
language 19
of Go programming 
language 19
of Java programming 
language 19
of Lua programming 
language 19
of Nim programming 
language 6–11, 19
compilation 9–11
instability of newer 20
memory management 11
metaprogramming 6–7
powerful type system 8–9
style insensitivity 8
of Python programming 
language 19
of Rust programming 
language 19
FFIs (foreign function 
interfaces) 25, 226, 261
FIFO (first-in-first-out) 176
files
parsing each line in 165–166
using iterators to read frag-
ments of 164–165
filesystems 118–120
fill procedure 116
fillString procedure 32, 261
filter procedure 38
filters 202
findMessages procedure 196, 
200
findUser procedure 196, 200
flags argument 240
flexibility of Nim 16–18
float type 9, 26, 250
floating-point type 28
flow, controlling 43–47
FlowVar container 158
FlowVar types, retrieving return 
values from 158–159
fmReadWrite mode 89
Follow buttons, adding
217–218
follow procedure 195, 218
/follow route, implementing
218–219
foo identifier 258
for loop 18, 40, 44–45, 205
for statement 45
foreign function interface
226–234
static vs. dynamic linking
227–228
type compatibility 231
wrapping C procedures
228–234
foreign-key constraint 194
format string 230
forums 281
forward declaration 34
FP (functional programming)
17, 21
fragments
overview 160, 169
using iterators to read
164–165
free function 232
from statement 106
front-page view, developing
207–210