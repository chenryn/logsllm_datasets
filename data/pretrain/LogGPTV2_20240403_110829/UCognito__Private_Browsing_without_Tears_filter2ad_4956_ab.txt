✗
✗
✗
✗
✓
✗
✗
✗
✓
✓
-
Store
Chrome
Incognito
Guest
Opera
Safari
IE
✗
✗
✗
✗
✗
✗
✗
✓
✗
✗
✗
✓
✓
-
✗
✗
✗
✗
✗
✗
✗
✗
✗
✗
✗
✓
-
-
✗
✗
✗
✗
✗
✗
✗
✓
✗
✗
✗
✓
✓
-
✗
✗
✗
✗
✗
✗
✗
✓
-
✓
✓
✓
✓
-
✗
✗
✗
✗
✗
✗
✗
✓
-
✗
✗
-
✓
-
Table 1: A comparison of policies for private browsing modes in five major browsers in their default settings. Use means accessing persistent data generated in
previous browsing sessions. Store means storing persistent data generated in private browsing session. Interestingly, each browser has a different set of privacy
policies. For example, private browsing in Firefox enables its plugins but incognito mode in Chrome disables the use of add-ons.
...
mDefaultDBState = new DBState(); // DB for normal mode
mPrivateDBState = new DBState(); // DB for private mode
// default: normal mode
mDBState = mDefaultDBState;
...
1 // @netwerk/cookie/nsCookieService.cpp
2 DBState *mDBState;
3 nsRefPtr mDefaultDBState; // DB for normal mode
4 nsRefPtr mPrivateDBState; // DB for private mode
5
6 // invoked when initializing session
7 void nsCookieService::InitDBStates() {
8
9
10
11
12
13
14 }
15
16 // invoked when storing cookies
17 void nsCookieService::SetCookieStringInternal() {
18
19
20
21
22 }
...
// decide which cookie DB to use, depending on the mode
mDBState = aIsPrivate ? mPrivateDBState : mDefaultDBState;
...
Figure 1: Firefox maintains user’s objects for each mode, public and private
mode. For example, Firefox’s cookie service has two database instances,
namely mDefaultDBState and mPrivateDBState. This implementation prac-
tice makes the code base complex: for example, developers have to distin-
guish which user’s mode is activated whenever it updates a cookie value
(e.g., SetCookieStringInternal().)
For example, as illustrated in Figure 1, Firefox maintains a global
variable aIsPrivate that identifies if a browsing session is in pri-
vate mode or not. This variable is initialized while a browsing
session starts. Firefox checks the value of aIsPrivate whenever
it needs to access or modify browser cookie. Firefox defines a set
of different processes for private browsing and encapsulates them
in mPrivateDBState. As is shown in line 28 in Figure 1, Firefox
uses aIsPrivate to determine if executing the logic encapsulated
in mPrivateDBState when cookie storage or access is needed. The
situation is even worse for Chrome as it has two private mode im-
plementations: Incognito mode and Guest mode.
The code snippet in Figure 1 is just an example of how Chrome
and Firefox add complexity to their browser implementation in order
to support private browsing. In addition to cookie management, the
full implementation of private browsing in Chrome and Firefox also
makes many other components aware of the private browsing mode,
such as cache service, form auto-complete, history, SSL certificate
store, etc.
In short, it is a major undertaking to make changes
...
"resource://gre/modules/PrivateBrowsingUtils.jsm");
1 // 1. Detecting private browsing mode @MDN
2 Components.utils.import(
3
4 if (!PrivateBrowsingUtils.isWindowPrivate(window)) {
5
6 }
7
8 // 2. Detecting mode changes @MDN
9 function pbObserver() { /* clear private data */ }
10 var os = Components.classes["@mozilla.org/observer-service;1"]
11
12 os.addObserver(pbObserver, "last-pb-context-exited", false);
.getService(Components.interfaces.nsIObserverService);
Figure 2: Each addon has to take a special care on private mode: not only by
checking the current browsing mode, but also listening to the context changes.
This amount of complexity results in many privacy issues in popular addon
(see §6.2)
throughout the browser code base in order to make the browser
privacy-aware.
Given the huge code base of browser and the richness of user data,
it is unlikely that developers can correctly manage the exponential
growth of complexity. As shown in Table 2, this implementation
strategy increases the chances of bugs and privacy unawareness, and
makes browsers cumbersome and hard to respond to users’ privacy
needs. We systematically evaluate the privacy unawareness issue
caused by such implementation practice in §3.
2.4 Caveat Interface for Add-on
Although browser add-ons have been an indispensable part of
modern browsers, the automatic enabling of private browsing mode
to add-ons is not supported at all. Instead, similar to the “mim-
icking” approaches used in instrumenting browser engine, Firefox
and Chrome only provide add-ons with an interface to check the
mode of current browsing session and expect add-on developers to
implement different logic for different modes (as shown in Figure 2).
As add-ons running in private mode might cause unintended
privacy violations, Firefox takes the approach of manual app re-
view [35], which states that each add-on must pass at least a pre-
liminary review to be listed and a full review to be ranked. Since
browser add-ons are still small in code size, such review practices
are still effective in regulating add-on developers to respect the
private-browsing policy. However, with increasingly complicated
add-ons being developed, manual review might soon reach to its
limitation.
Category
Privacy unawareness
Implementation bug
Reluctance in responding to user needs
Bug ID
967812
37238
553773
21974
1074150
471597
Browser Description
Firefox
Chrome
Firefox
Chrome
Firefox
Chrome
Permissions Manager writes to disk in Private Browsing Mode
Cookie exception recorded while in private browsing mode
Entering private browsing aborts active downloads
Private Browsing download window shows wrong data
Second instance of incognito mode remembers the log-in session
Sessions are not "private" when open two or more private (incognito) windows
Table 2: Bug report samples related to private mode implementation in Firefox and Chrome. It is interesting to see that both Firefox and Chrome developers
introduced similar bugs, indicating they all have no effective ways to control the implementation complexity.
Chrome takes the “use-it-at-your-own-risk” approach. When
a user wants to enable an add-on in incognito mode, a message
(see Figure 3) will popup and alert user on the risks of their decision.
Such an approach essentially alleviates Chrome from the task of
ensuring that add-ons respect incognito mode.
Figure 3: An alert displayed when enabling incognito mode for an extension.
3. TESTING PRIVATE BROWSING
Knowing the security goals of private browsing and their im-
plementation in mainstream browsers, we developed an assistant
tool to examine the security of private browsing in Firefox and
Chrome. In this section, we describe our techniques and summarize
the privacy-unaware implementation that our tool identifies.
3.1 Privacy-Unaware Implementation
As we described in §2.3, developers take the “mimicking” ap-
proach in extending the browsing engine to support private mode.
Initially, we expected browser vendors to employ a systematic way
to identify and support the features/components that persist data
during a browsing session, i.e., those in need of “mimicking”. Un-
fortunately, we are unable to find any hint that Firefox or Chrome
does this. On the contrary, as evidenced in their design documents
[2, 3], most of these features are identified based on developers’
judgement.
Such an approach might be feasible with a small code base and
in a slow development cycle. However, in the case of browser, with
the constant introduction of new techniques and standards, web
applications are given increasing power in interaction with client
machines, among which many of them introduce new opportunities
to persist data on-disk, such as HTML 5 local storage [15], and
Geolocation API [29]. Browser developers might not be fully aware
of potential privacy leakage when instrumenting browser engine
for those functionalities and hence, either causing users’ browsing
activities in private mode be persisted to disk (violation of afore-
mentioned stealthiness goal) or causing previous browsing data be
carried over to private session (violation of aforementioned fresh-
ness goal). Therefore, it is not uncommon to see the pattern shown
in Table 3 in the browser’s release cycle: a new web standard is mis-
implemented by developers, causing a privacy leakage bug which
takes years to be patched.
3.2 Uverifier: Privacy Violation Detector
Motivated by the long cycle to patch a privacy violation case
(as shown in Table 3) as well as the concern that there might be
more privacy-unaware implementations, we develop UVERIFIER
to systematically check for violations of stealthiness and freshness
goals defined in §2.2 in Chrome and Firefox.
Date
Dec 2008
May 2010
Aug 2010
Apr 2013
Event
New standard proposed
Implementation and public release
Violation of incognito mode reported
Issue patched
Note
Geolocation API
Chrome 5.0
Issue id 51204
Revision id 192540
Table 3: The initial integration of a new web standard, Geolocation API,
caused permission settings saved in incognito session to be persisted and
have an effect in public session. It was reported after 3 months of official
release and was not patched for 3 years.
UVERIFIER consists of three major components:
• a script-based driver that drives a browsing session, including
creation of new profiles, starting/stopping browser, visiting
suspicious websites and initializing plug-ins.
• a system call tracer, based on strace, that captures browser
behaviors in terms of system calls.
• an analyzer that extracts privacy violation patterns from the
system call traces.
We start each test by creating a fresh browser profile and:
• To test stealthiness goal, we run one private session (A) only.
• To test freshness goal, we run one public session (A) and one
private session (B) consecutively.
For each browsing session, the web driver starts the browser in the
desired mode, performs browsing activities and finally shuts down
the browser. The logger captures all accesses and modifications
to the underlying filesystem by recording all file-related system
calls. Unlike previous study [1] that only focused on changes in
the browser profile directory, we capture any changes made to the
filesystem.
We define any file that 1) is opened/created with the write flag, 2)
has data inflow and 3) is not deleted after browsing session A as a
trace stored, denoted by ts. Any file that 1) is opened with the read
flag and 2) has data outflow in browsing session B is considered a
trace used, denoted by tu. A potential violation of the stealthiness
goal is detected if any ts is found while a potential violation of the
freshness goal is detected if any ts = tu is found. We then manually
analyze these potential violation cases and filter out those cases that
cannot be used to recover users’ browsing activities, such as changes
of timestamps.
3.3 Privacy Violations
Using UVERIFIER, we discover several previously unknown pri-
vacy violations in Chrome and Firefox and we have reported those
issues to Mozilla and Google accordingly. Here, we summarize the
components of which the browser implementation is not made aware
of private browsing mode, and highlight how they compromise the
security goals of private browsing.
OCSP cache. The Online Certificate Status Protocol (OCSP) is
an Internet protocol used for obtaining the revocation status of a
certificate. Today, OCSP has been supported by many web browsers.
Using this protocol, web browsers can ensure that their users connect
to the domains that they intend to. In the Firefox case, upon receipt
of a certificate, Firefox sends an OCSP request with the certificate
serial number to the issuing Certificate Authority (CA) to query cer-
tificate validity and by default, caches the OCSP response received
at //cache2/entries/ even in pri-
vate mode. This violates the stealthiness goal of private mode be-
cause an adversary could infer the websites that a user has visited in
private browsing mode with various information in cache, including
the certificate serial number which can be uniquely mapped to a
web domain.
PNaCl translation cache. Native Client is a sandbox for run-
ning compiled C and C++ code in Chrome browser efficiently
and securely. PNaCl is a portable version of Native Client.
It
allows developers to compile their code once to run in any web-