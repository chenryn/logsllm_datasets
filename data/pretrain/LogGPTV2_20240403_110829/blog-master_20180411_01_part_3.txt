pg_size_pretty(t.ssz) as ssz2,     -- 这个batch FREEZE 会导致多少读IO (表+TOAST+索引)    
pg_size_pretty(t.ssz*3) as ssz3,   -- 这个batch FREEZE 最多可能会导致多少写IO (通常三份 : 数据文件, WAL FULL PAGE, WAL)    
pg_size_pretty(t.ssz_sum) as ssz4, -- 所有batch 所有表的总大小  (表+TOAST+索引)    
round(100*(t.ssz/t.ssz_sum), 2)||' %' as ratio_batch,     -- 这个BATCH的容量占比，目标是让所有BATCH占比尽量一致    
round(100*(pg_total_relation_size(t.reloid)/t.ssz), 2)||' %' as ratio_table,     -- 这个表占整个batch的容量占比，大表尽量错开freeze    
t.*      
from         
(    
select a.*, b.* from       
(    
  select     
    min(least(remain_ages_xid, remain_ages_mxid)) as v_min,   -- 整个数据库中离自动FREEZE的 最小 剩余事务ID数    
    max(least(remain_ages_xid, remain_ages_mxid)) as v_max    -- 整个数据库中离自动FREEZE的 最大 剩余事务ID数    
  from v_freeze     
) as a,     
LATERAL (     -- 高级SQL    
select     
  count(*) over w as cnt,                                                -- 这个batch 有多少表      
  sum(pg_total_relation_size(reloid)) over () as ssz_sum,                -- 所有batch 所有表的总大小  (表+TOAST+索引)    
  sum(pg_total_relation_size(reloid)) over w as ssz,                     -- 这个batch 的表大小总和 (表+TOAST+索引)    
  pg_size_pretty(min(pg_total_relation_size(reloid)) over w) as min_sz,  -- 这个batch 最小的表多大    
  pg_size_pretty(max(pg_total_relation_size(reloid)) over w) as max_sz,  -- 这个batch 最大的表多大    
  pg_size_pretty(avg(pg_total_relation_size(reloid)) over w) as avg_sz,  -- 这个batch 平均表多大    
  pg_size_pretty(stddev_samp(pg_total_relation_size(reloid)) over w) as stddev_sz,  -- 这个batch 表大小的方差, 越大, 说明表大小差异化明显                                                                                                                 
  min(least(remain_ages_xid, remain_ages_mxid)) over w as min_rest_age,             -- 这个batch 距离自动FREEZE最低剩余事务数                                                                                                                             
  max(least(remain_ages_xid, remain_ages_mxid)) over w as max_rest_age,             -- 这个batch 距离自动FREEZE最高剩余事务数                                                                                                                             
  stddev_samp(least(remain_ages_xid, remain_ages_mxid)) over w as stddev_rest_age,  -- 这个batch 距离自动FREEZE剩余事务数的方差, 越小，说明这个batch触发freeze将越平缓, 越大, 说明这个batch将有可能在某些点集中触发freeze (但是可能集中触发的都是小表)    
  corr(least(remain_ages_xid, remain_ages_mxid), pg_total_relation_size(reloid)) over w as corr_rest_age_sz,  -- 表大小与距离自动freeze剩余事务数的相关性，相关性越强(值趋向1或-1) stddev_rest_age 与 stddev_sz 说明的问题越有价值    
  t1.*     
from     
  (    
  select     
    width_bucket(    
      least(tt.remain_ages_xid, tt.remain_ages_mxid),     
      a.v_min,    
      a.v_max,    
      greatest((a.v_max-a.v_min)/1000000, 1)         -- 100万个事务, 如果要更改统计例如，修改这个值即可    
    )     
    as wb,                                           -- 第几个BATCH, 每个batch代表流逝100万个事务      
    * from v_freeze tt    
  ) as t1      
  window w as     
  (    
    partition by t1.wb     
  )     
) as b    
) t    
order by     
  t.wb,      
  least(t.remain_ages_xid, t.remain_ages_mxid),       
  pg_total_relation_size(t.reloid) desc       
;      
```    
返回解释如下    
```    
-[ RECORD 1 ]----------+-------------------------------------------    
ssz2                   | 13 GB                 -- 这个batch FREEZE 会导致多少 读IO                                                       
ssz3                   | 38 GB		       -- 这个batch FREEZE 最多可能会导致多少 写IO (通常三份 : 数据文件, WAL FULL PAGE, WAL)     
ssz4                   | 18 GB		       -- 所有batch 所有表的总大小  (表+TOAST+索引)                                 
ratio_batch            | 70.96 %	       -- 这个BATCH的容量占比，目标是让所有BATCH占比尽量一致                                     
ratio_table            | 0.06 %		       -- 这个表占整个batch的容量占比，大表尽量错开freeze                                        
v_min                  | 199739844	       -- 整个数据库中离自动FREEZE的 最小 剩余事务ID数                                           
v_max                  | 200000000	       -- 整个数据库中离自动FREEZE的 最大 剩余事务ID数                                           
cnt                    | 2085		       -- 这个batch 有多少表                                                                     
ssz_sum                | 19177472000	       -- 所有batch 所有表的总大小        (表+TOAST+索引)                                        
ssz                    | 13608812544	       -- =ssz2 这个batch 的表大小总和    (表+TOAST+索引)                                        
min_sz                 | 32 kB		       -- 这个batch 最小的表多大                                                                 
max_sz                 | 6326 MB	       -- 这个batch 最大的表多大                                                                 
avg_sz                 | 6374 kB	       -- 这个batch 平均表多大                                      
stddev_sz              | 184 MB                -- 这个batch 表大小的方差, 越大, 说明表大小差异化明显                                                                                                                 
min_rest_age           | 199739844	       -- 这个batch 距离自动FREEZE最低剩余事务数                                                                                                                             
max_rest_age           | 199999998	       -- 这个batch 距离自动FREEZE最高剩余事务数                                                                                                                             
stddev_rest_age        | 19486.91462976	       -- 这个batch 距离自动FREEZE剩余事务数的方差, 越小，说明这个batch触发freeze将越平缓, 越大, 说明这个batch将有可能在某些点集中触发freeze (但是可能集中触发的都是小表)    
corr_rest_age_sz       | -0.079332345436958    -- 表大小与距离自动freeze剩余事务数的相关性，相关性越强(值趋向1或-1) stddev_rest_age 与 stddev_sz 说明的问题越有价值    
wb                     | 1                     -- 第几个BATCH, 每个batch代表流逝100万个事务     
sz                     | 8352 kB               -- 表的大小(含TOAST, 索引)                                                                                                                                                         
reloid                 | pg_attribute	       -- 表名(物化视图)                                                                                                                                
relkind                | r		       -- r=表, m=物化视图                                                                                                                                                                
remain_ages_xid        | 199739844	       -- 再产生多少个事务后, 自动垃圾回收会触发FREEZE, 起因为事务ID                                                                                                                      
remain_ages_mxid       | 		       -- 再产生多少个事务后, 自动垃圾回收会触发FREEZE, 起因为并发事务ID                                                                                                                  
xid_lower_to_minage    | 0		       -- 如果触发FREEZE, 该表的事务ID年龄会降到多少                                                                                                                                      
mxid_lower_to_minage   | 0		       -- 如果触发FREEZE, 该表的并行事务ID年龄会降到多少                                                                                                                                  
vacuum_trigger_freeze1 | YES		       -- 如果手工执行VACUUM, 是否会触发FREEZE, 触发起因(事务ID年龄达到阈值)                                                                                                              
vacuum_trigger_freeze2 | NOT		       -- 如果手工执行VACUUM, 是否会触发FREEZE, 触发起因(并行事务ID年龄达到阈值)                                                                                                          
reloptions             | 		       -- 表级参数, 优先. 例如是否开启自动垃圾回收, autovacuum_freeze_max_age, autovacuum_freeze_table_age, autovacuum_multixact_freeze_max_age, autovacuum_multixact_freeze_table_age    
v1                     | 200000000	       -- 如果表的事务ID年龄大于该值, 即使未开启autovacuum也会强制触发FREEZE, 并告警Preventing Transaction ID Wraparound Failures                                                         
v2                     | 400000000	       -- 如果表的并行事务ID年龄大于该值, 即使未开启autovacuum也会强制触发FREEZE, 并告警Preventing Transaction ID Wraparound Failures                                                     
v3                     | 0		       -- 手动或自动垃圾回收时, 如果记录的事务ID年龄大于该值, 将被FREEZE                                                                                                                  
v4                     | 0		       -- 手动或自动垃圾回收时, 如果记录的并行事务ID年龄大于该值, 将被FREEZE                                                                                                              
v5                     | 200		       -- 手动垃圾回收时, 如果表的事务ID年龄大于该值, 将触发FREEZE. 该参数的上限值为 %95 autovacuum_freeze_max_age                                                                        
v6                     | 150000000	       -- 手动垃圾回收时, 如果表的并行事务ID年龄大于该值, 将触发FREEZE. 该参数的上限值为 %95 autovacuum_multixact_freeze_max_age                                                          
v7                     | 0		       -- 自动垃圾回收时, 每轮回收周期后的一个休息时间, 主要防止垃圾回收太耗资源. -1 表示沿用vacuum_cost_delay的设置                                                                      
v8                     | -1		       -- 自动垃圾回收时, 每轮回收周期设多大限制, 限制由vacuum_cost_page_hit,vacuum_cost_page_missvacuum_cost_page_dirty参数以及周期内的操作决定. -1 表示沿用vacuum_cost_limit的设置      
v9                     | 0		       -- 手动垃圾回收时, 每轮回收周期后的一个休息时间, 主要防止垃圾回收太耗资源.                                                                                                         
v10                    | 200		       -- 手动垃圾回收时, 每轮回收周期设多大限制, 限制由vacuum_cost_page_hit,vacuum_cost_page_missvacuum_cost_page_dirty参数以及周期内的操作决定.                                         
autovacuum             | on		       -- 是否开启自动垃圾回收                                                                                                                                                            
```    
## 小结    
通过本文提供的三个视图，我们可以知道每个表，在什么时候会触发自动FREEZE，会产生多少IO。FREEZE的后台进程调度参数如何。哪些表在手动支持VACUUM时会触发FREEZE。    
本文内容涵盖GC(垃圾回收知识)，统计学，高级SQL。等知识。    
使用本文提到的SQL，你可以成为PG FREEZE风暴的先知，躲避风暴，掌握PG的垃圾回收机制，了解平滑的GC策略。    
### 视图1 (v_freeze) ：  
按风暴来临的时间顺序排序，返回每个剩余多少事务会触发自动FREEZE，详细信息如下  
```  
-- 表的大小(含TOAST, 索引)                                                                                                                                                         
-- 表名(物化视图)                                                                                                                                
-- r=表, m=物化视图                                                                                                                                                                
-- 再产生多少个事务后, 自动垃圾回收会触发FREEZE, 起因为事务ID                                                                                                                      
-- 再产生多少个事务后, 自动垃圾回收会触发FREEZE, 起因为并发事务ID                                                                                                                  
-- 如果触发FREEZE, 该表的事务ID年龄会降到多少                                                                                                                                      
-- 如果触发FREEZE, 该表的并行事务ID年龄会降到多少                                                                                                                                  
-- 如果手工执行VACUUM, 是否会触发FREEZE, 触发起因(事务ID年龄达到阈值)                                                                                                              
-- 如果手工执行VACUUM, 是否会触发FREEZE, 触发起因(并行事务ID年龄达到阈值)                                                                                                          
-- 表级参数, 优先. 例如是否开启自动垃圾回收, autovacuum_freeze_max_age, autovacuum_freeze_table_age, autovacuum_multixact_freeze_max_age, autovacuum_multixact_freeze_table_age    
-- 如果表的事务ID年龄大于该值, 即使未开启autovacuum也会强制触发FREEZE, 并告警Preventing Transaction ID Wraparound Failures                                                         
-- 如果表的并行事务ID年龄大于该值, 即使未开启autovacuum也会强制触发FREEZE, 并告警Preventing Transaction ID Wraparound Failures                                                     
-- 手动或自动垃圾回收时, 如果记录的事务ID年龄大于该值, 将被FREEZE                                                                                                                  
-- 手动或自动垃圾回收时, 如果记录的并行事务ID年龄大于该值, 将被FREEZE                                                                                                              
-- 手动垃圾回收时, 如果表的事务ID年龄大于该值, 将触发FREEZE. 该参数的上限值为 %95 autovacuum_freeze_max_age                                                                        
-- 手动垃圾回收时, 如果表的并行事务ID年龄大于该值, 将触发FREEZE. 该参数的上限值为 %95 autovacuum_multixact_freeze_max_age                                                          
-- 自动垃圾回收时, 每轮回收周期后的一个休息时间, 主要防止垃圾回收太耗资源. -1 表示沿用vacuum_cost_delay的设置                                                                      
-- 自动垃圾回收时, 每轮回收周期设多大限制, 限制由vacuum_cost_page_hit,vacuum_cost_page_missvacuum_cost_page_dirty参数以及周期内的操作决定. -1 表示沿用vacuum_cost_limit的设置      
-- 手动垃圾回收时, 每轮回收周期后的一个休息时间, 主要防止垃圾回收太耗资源.                                                                                                         
-- 手动垃圾回收时, 每轮回收周期设多大限制, 限制由vacuum_cost_page_hit,vacuum_cost_page_missvacuum_cost_page_dirty参数以及周期内的操作决定.                                         
-- 是否开启自动垃圾回收                                                                                                                                                            
```  
### 视图2 (v_freeze_stat) ：  
统计视图，返回每N个事务为间隔，每个间隔中，有多少表要被FREEZE，表的总容量多少大。  
```  
-- 第几个BATCH, 每个batch代表流逝100万个事务                                                                                                                         
-- 这个batch 有多少表                                                                                                                                                
-- 这个batch 这些 表+TOAST+索引 有多少容量                                                                                                                           
-- 这个batch FREEZE 会导致多少 读IO                                                                                                                                  
-- 这个batch FREEZE 最多可能会导致多少 写IO (通常三份 : 数据文件, WAL FULL PAGE, WAL)                                                                                
-- 这个batch 最小的表多大                                                                                                                                            
-- 这个batch 最大的表多大                                                                                                                                            
-- 这个batch 平均表多大                                                                                                                                              
-- 这个batch 表大小的方差, 越大, 说明表大小差异化明显                                                                                                                
-- 这个batch 距离自动FREEZE最低 剩余事务数                                                                                                                           
-- 这个batch 距离自动FREEZE最高 剩余事务数                                                                                                                           
-- 这个batch 距离自动FREEZE剩余事务数的方差, 越小，说明这个batch触发freeze将越平缓, 越大, 说明这个batch将有可能在某些点集中触发freeze (但是可能集中触发的都是小表)   
-- 表大小与距离自动freeze剩余事务数的相关性，相关性越强(值趋向1或-1) stddev_rest_age 与 sz7 说明的问题越有价值                                                       
-- 这个BATCH的容量占比，占比如果非常不均匀，说明有必要调整表级FREEZE参数，让占比均匀化                                                                               
```  
### 视图3 (v_freeze_stat_detail) ：  
1,2结合的明细视图，可以用于巡视哪些表的FREEZE参数需要被调整。  
```  
-- 这个batch FREEZE 会导致多少 读IO                                                                                                                                               
-- 这个batch FREEZE 最多可能会导致多少 写IO (通常三份 : 数据文件, WAL FULL PAGE, WAL)                                                                                             
-- 所有batch 所有表的总大小  (表+TOAST+索引)                                                                                                                                      
-- 这个BATCH的容量占比，目标是让所有BATCH占比尽量一致                                                                                                                             
-- 这个表占整个batch的容量占比，大表尽量错开freeze                                                                                                                                
-- 整个数据库中离自动FREEZE的 最小 剩余事务ID数                                                                                                                                   
-- 整个数据库中离自动FREEZE的 最大 剩余事务ID数                                                                                                                                   
-- 这个batch 有多少表                                                                                                                                                             
-- 所有batch 所有表的总大小        (表+TOAST+索引)                                                                                                                                
-- =ssz2 这个batch 的表大小总和    (表+TOAST+索引)                                                                                                                                
-- 这个batch 最小的表多大                                                                                                                                                         
-- 这个batch 最大的表多大                                                                                                                                                         
-- 这个batch 平均表多大                                                                                                                                                           
-- 这个batch 表大小的方差, 越大, 说明表大小差异化明显                                                                                                                             
-- 这个batch 距离自动FREEZE最低剩余事务数                                                                                                                                         
-- 这个batch 距离自动FREEZE最高剩余事务数                                                                                                                                         
-- 这个batch 距离自动FREEZE剩余事务数的方差, 越小，说明这个batch触发freeze将越平缓, 越大, 说明这个batch将有可能在某些点集中触发freeze (但是可能集中触发的都是小表)                
-- 表大小与距离自动freeze剩余事务数的相关性，相关性越强(值趋向1或-1) stddev_rest_age 与 stddev_sz 说明的问题越有价值                                                              
-- 第几个BATCH, 每个batch代表流逝100万个事务                                                                                                                                      
-- 表的大小(含TOAST, 索引)                                                                                                                                                        
-- 表名(物化视图)                                                                                                                                                                 
-- r=表, m=物化视图                                                                                                                                                               
-- 再产生多少个事务后, 自动垃圾回收会触发FREEZE, 起因为事务ID                                                                                                                     
-- 再产生多少个事务后, 自动垃圾回收会触发FREEZE, 起因为并发事务ID                                                                                                                 
-- 如果触发FREEZE, 该表的事务ID年龄会降到多少                                                                                                                                     
-- 如果触发FREEZE, 该表的并行事务ID年龄会降到多少                                                                                                                                 
-- 如果手工执行VACUUM, 是否会触发FREEZE, 触发起因(事务ID年龄达到阈值)                                                                                                             
-- 如果手工执行VACUUM, 是否会触发FREEZE, 触发起因(并行事务ID年龄达到阈值)                                                                                                         
-- 表级参数, 优先. 例如是否开启自动垃圾回收, autovacuum_freeze_max_age, autovacuum_freeze_table_age, autovacuum_multixact_freeze_max_age, autovacuum_multixact_freeze_table_age   
-- 如果表的事务ID年龄大于该值, 即使未开启autovacuum也会强制触发FREEZE, 并告警Preventing Transaction ID Wraparound Failures                                                        
-- 如果表的并行事务ID年龄大于该值, 即使未开启autovacuum也会强制触发FREEZE, 并告警Preventing Transaction ID Wraparound Failures                                                    
-- 手动或自动垃圾回收时, 如果记录的事务ID年龄大于该值, 将被FREEZE                                                                                                                 
-- 手动或自动垃圾回收时, 如果记录的并行事务ID年龄大于该值, 将被FREEZE                                                                                                             
-- 手动垃圾回收时, 如果表的事务ID年龄大于该值, 将触发FREEZE. 该参数的上限值为 %95 autovacuum_freeze_max_age                                                                       
-- 手动垃圾回收时, 如果表的并行事务ID年龄大于该值, 将触发FREEZE. 该参数的上限值为 %95 autovacuum_multixact_freeze_max_age                                                         
-- 自动垃圾回收时, 每轮回收周期后的一个休息时间, 主要防止垃圾回收太耗资源. -1 表示沿用vacuum_cost_delay的设置                                                                     
-- 自动垃圾回收时, 每轮回收周期设多大限制, 限制由vacuum_cost_page_hit,vacuum_cost_page_missvacuum_cost_page_dirty参数以及周期内的操作决定. -1 表示沿用vacuum_cost_limit的设置     