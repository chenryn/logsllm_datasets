Table 3. OLSR Routing Table Establishment 
1. Exchange 1-hop neighbor lists by Hello messages. 
2. Establish 2-hop neighbor lists by 1-hop lists. 
3. Generate MPR sets by 2-hop neighbor lists and announce them with Hello messages. 
4. MPR nodes generate TC messages advertising the nodes (MPR selectors) that can be 
reached by the MPR nodes.   
5. MPR nodes forward TC messages so that they will reach all nodes in the network.  
6. Generate topology and routing tables from MPR selector sets. 
Table 3 describes the process for establishing the routing table from the perspective 
of a node. Initially, a node exchanges its 1-hop neighbor list with its neighbors using 
Hello messages. Then the node establishes its 2-hop neighbor list based on the Hello 
messages from its neighbors. Based on the 2-hop neighbor list, the node generates the 
MPR set and announces them in Hello messages. Nodes that are chosen to be MPR 
will generate TC messages and forward TC messages originating from other nodes so 
that every node will receive all the TC messages. Finally, a node computes the routing 
table from the information in the Hello messages and TC messages.  
According to the OLSR protocol RFC [15], each node maintains a link set and a 
topology set that are used for calculation of the routing table. The link set contains the 
link information of its 1-hop neighbor, and is constructed from the Hello messages it 
receives.  The  topology  set  contains  topology  tuples  in  the  form  of  (T_dest_addr, 
T_last_addr, T_seq, T_time), which indicate that one can reach T_dest_addr through 
T_last_addr.  The topology set is constructed from the TC messages a node receives. 
A node computes the routing table from its link set and topology set. Therefore, the 
routing table of a node is correct if its link set and topology set are correct.  
Lemma 1. Under assumptions in Section 3.1, all good nodes will have a correct link 
set if constraint C1 holds.  
Proof:  First,  according  to  the  OLSR  routing  specification,  a  node  builds  and 
maintains its link set from the 1-hop neighbor field of the Hello messages it receives. 
Therefore, if the 1-hop neighbor fields of all Hello messages and the source address 
are correct, then all nodes will have a correct link set.  
Now, we show that a Hello message with an incorrect 1-hop neighbor field will be 
detected as a violation of C1. Consider a bad node which produces a Hello message 
with an incorrect 1-hop neighbor field. There are two possibilities:  
1)  It claims another node A as its 1-hop neighbor, but A is not. In this case, IDS 
will detect this  when it compares the Hello message from  the bad node with 
the Hello message from A. 
A Specification-Based Intrusion Detection Model for OLSR 
339 
2)  It omits, in its set of 1-hop neighbors, a real neighbor B. In this case, the IDS 
will detect violation of C1 when it compares the Hello message from the bad 
node with the Hello message from B. 
In  both  cases,  the  incorrect  Hello  message  will  be  detected  as  a  violation  of 
constraint C1. Given that the source address of a Hello message is correct (Assumption 
of “no spoofing”), all nodes will have a correct link set if constraint C1 holds.  
Lemma 2: The MPR selector field of a TC message generated by an MPR node must 
be correct if constraint C3 holds. 
Proof: According to OLSR specifications, a (complete) TC message contains the set 
of  MPR  selectors  of  the  originating  node.  There  are  two  cases  in  which  the  MPR 
selector field in the TC message could be wrong. 
1)  The MPR selector field contains a node X which is not an MPR selector of M. 
2)  The MPR selector field misses a node Y which is a MPR selector of M. 
In Case 1, the Hello message generated by node X will be inconsistent with the TC 
message.  Therefore,  the  IDS  will  detect  violation  of  constraint  C3.  In  Case  2,  the 
Hello  message  generated  by  node  Y  will  be  inconsistent  with  the  TC  message,  and 
thus will be detected. 
Lemma 3: The MPR selector fields of all TC messages must be correct if constraints 
C3 and C4 hold.  
For  any  TC  message  in  the  network,  it  is  either  an  original  message  sent  by  the 
originating node or a forwarded message. In the former case, Lemma 1 guarantees the 
correctness  of  the  selector  fields.  In  the  latter  case,  constraint  C4  assure  that  the 
forwarded TC message must be the same as the original TC message; thus, the MPR 
selector field must be correct.  
Lemma  4:  For a node x, which is a n-hop neighbor of a node y, x will  receive TC 
messages of y with n-1 forwarding if C2 holds.  
We use induction to prove this lemma.  
1)  For n equals to 1, all y’s one-hop neighbors will receive TC messages without 
forwarding.  For  n  equals  to  2,  all  y’s  two  hop  neighbors  will  receive  TC 
messages of y with one forwarding if C2 hold. 
2)  (Inductive step) We assume that any node A will receive TC message of a n-hop 
neighbor B with n-1 forwarding if C2 hold for all  2  0.   
Theorem 1: All nodes will have a correct routing table if constraints C1, C2, C3, and 
C4 hold. 
340 
C.H. Tseng et al. 
Since each node in the MANET computes the routing table based on the link set and 
the topology set, the routing table will be correct if the two sets are correct. Given that 
C1 holds, Lemma 1 ensures that the link set in each node is correct. Given that C3 and 
C4 hold, Lemma 3 ensures that the MPR selector field of all the TC messages that a 
node  receives  is  correct.  Given  C2,  Lemma  4  ensures  that  a  node  will  receive  TC 
messages  of  all  nodes.  According  to  the  OLSR  specification,  the  topology  set  is 
computed  from  the  TC  messages.  Therefore,  the  topology  set  will  be  correct  if,  in 
addition, every MPR sends out the TC messages. Since constraint C2 guarantees that 
all nodes in the true MPR set send out TC messages, the topology set in each node 
must be correct. Therefore, the routing table in each node must be correct. 
5   Simulation 
To measure and validate the effectiveness of our approach, we have implemented the 
detection  mechanism  for  checking  the  constraints  and  experimented  it  in  a  simulated 
OLSR  network  under  a  variety  of  mobility  scenarios.  We  have  implemented  several 
example attacks described in Section 2.2 to test the detection capability. In addition, we 
test the prototype under normal situation to measure the false positive characteristics. 
5.1   Simulation Environment 
We use the GloMoSim simulation platform to experimentally validate our approach. 
The  simulation  is  based  on  IEEE  802.11  and  Ground  Reflection  (Two-Ray)  Model 
having  both  the  direct  path  and  a  ground  reflected  propagation  path  between 
transmitter  and  receiver.  The  radio  range  is  around  376.7  meters,  calculated  by  the 
parameters shown in Table 4 [31]. 
Table 4. Radio Propagation Parameters in GloMoSim 
PROPAGATION-LIMIT (dBm) 
RADIO-TX-POWER (dBm) 
RADIO-ANTENNA-GAIN (dBm) 
RADIO-RX-SENSITIVITY (dBm) 
RADIO-RX-THRESHOLD (dBm) 
Antenna Height (m) 
-111 
15 
0 
-91 
-81 
1.5 
The network field is 1000 m x 1000 m region divided into cells where nodes are 
placed into each cell randomly. Each attack scenarios has a stable topology with 10 
nodes. Total simulation time is 600 seconds.  
In the experiments all mobile nodes follow the Random Waypoint Mobility Model 
with speed as 5,10, and 20 m/s, and the pause times, as 0, 30, and 60, … 300 seconds. 
For  background  traffic,  with  number  of  mobile  nodes,  50,  100,  200,  400,  10%  of 
mobile nodes continuously generate 1024 byte packets at a constant rate of 1 packet 
per  second,  8K  bps,  across  the  network  topology.  The  simulation  metrics  mainly 
focus on  false positives, false negatives, the distribution of temporary inconsistency 
lasting time and maximum value for each constraint.  
A Specification-Based Intrusion Detection Model for OLSR 
341 
5.2   Implementation of Detection Mechanism 
Our proof-of-concept prototype is implemented as a global detector that can monitor 
all  Hello  and  TC  messages  in  the  simulated  OLSR  network.  It  is  important  to  note 
that  although  the  current  prototype  is  a  centralized  detector,  the  proposed  intrusion 
detection model can be implemented in a decentralized fashion (See the ongoing work 
section).  As  the  goal  of  the  proof-of-concept  prototype  is  to  validate  the  detection 
model, a centralized implementation suffices for validating the false positive and false 
negative characteristics under our assumptions. 
Four data tables are maintained by the global detector to record 1-hop neighbors, 2-
hop neighbors, MPR and MPR selector sets of all nodes. Four constraints are evaluated 
according to data tables and incoming messages. An alert will be raised if a constraint is 
violated. However, topology changes will cause temporal inconsistency and lead to false 
alert. To minimize the false positive rate, we develop a mechanism to detect temporal 
inconsistency between new  message and old history data. First,  we set threshold time 
for each constraint according to intervals of Hello messages and TC message. Then we 
generate  alerts  only  when  an  inconsistency  last  beyond  the  threshold  time  of  a 
constraint. As an example, we list the pseudo code of Constraint C1 in Figure 5:  
Constraint 1 (1-hop Table, node i) 
For each 1-hop neighbor j in 1-hop Table i 
If i is not in 1-hop Table j  // if there is inconsistency between link states of node i and j 
      {Set 1-hop Table(i,j).alertTime = Current Time //set time stamp 
      Set 1-hop Table(i,j).alert = TRUE //mark the inconsistency} 
      Else {If (Current Time - 1-hop Table(i,j). alertTime) > Threshold of C1 // if inconsistecy 
          Raise Alarm of C1}}               //has lasted more than threshold, raise an alarm 
{ If 1-hop Table(i,j).alert = = FALSE  //if no inconsistency before 
Else{1-hop Table(i,j).alert = FALSE}
Fig. 5. Pseudo code of constraint C1 
5.3   Example Attack Scenario and Results 
We implemented one example of a man-in-the-middle and two examples of denial of 
service attacks using the four attack methods presented in Section 2.2. We present an 
example topology, shown in Figure 6 and Table 5, in order to illustrate the details of 
the example attacks and their impact. In each example attack, the attacker uses attack 
mechanisms slightly modifying the control messages to trigger changes in the routing 
tables of other nodes as desired by the attacker. These example attacks demonstrate 
that,  by  employing  carefully  designed  modifications,  an  attacker  can  successfully 
manipulate  routing  tables  at  other  nodes.  Note  that  we  simulate  the  attacks  with  no 
mobility to ensure the attacks are effective. 
For  each  example  attack,  the  detector  detects  the  attacks  as  violations  of  the 
constraints. In this implementation,  we assimilate a recovery model with the intrusion 
detection  model.  To  recover  the  corrupted  routing  tables  of  infected  nodes  from  the 
attack, the detector may send the correct TC message with higher ANSN and the correct 
MPR selector set to override the corrupted TC message. If the compromised node is the 
originator of the message, the detector commands the node to resend correct messages  
342 
C.H. Tseng et al. 
0 
1 
4 
8 
9
2
5
7
6
3
Fig. 6. Example Topology in OLSR 
Table 5. Relevant OLSR data for example topology in Fig 5 
0 
1 
2 
3 
4 
5 
6 
7 
1-hop 