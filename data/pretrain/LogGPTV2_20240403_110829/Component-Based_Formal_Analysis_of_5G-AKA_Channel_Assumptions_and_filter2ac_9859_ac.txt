cross-network boundaries – in many instances we believe there
is often little to no internal network encryption at all, making
this scenario materially different to the one presented in [11].
The standard allows that other channels are implemented
by session bound local instances (preventing the attack pre-
sented by [11]) while the AUSF ↔ ARPF channel could
be implemented by a long-running connection that doesn’t
provide a similar binding. As we will show later, there is a
potential attack based on underspeciﬁed assumptions on the
AUSF ↔ ARPF channel. This attack would not be prevented
by following the recommendations from [11] on the channels
that they considered in their work, since they did not model
AUSF ↔ ARPF.
D. Modelling limitations
1
2
3
4
5
We do not model the counter ‘resync’ mode of 5G-AKA:
this is addressed by Basin et al. in [11]. We do not consider the
later derivation of keys within the key hierarchy after 5G-AKA
has ﬁnished. We also do not consider distinctions between e.g.,
the User Plane, Control Plane, Radio Resource Control, Access
Stratum, and Non-Access Stratum, except where these make
a difference to the 5G-AKA protocol’s behaviour. We do not
model the EAP-AKA(cid:48) protocol (described in [5, §6.1.3.1] and
RFC 5448 [10]) as it and the very closely related EAP-AKA
protocol have been studied in depth elsewhere [8], [14], [22].
Integrating a model of EAP-AKA(cid:48) into our models of 5G-AKA
would be useful future work: analysing their composition would
be useful and non-trivial, as EAP-AKA(cid:48) also makes use of the
same long-term key K.
VI. FORMALISATION OF SECURITY PROPERTIES
Having modelled 5G-AKA in TAMARIN’s multiset rewriting
rules, we now model the range of desired security properties as
(temporal) ﬁrst-order logic formulae. These formulae are then
evaluated over runs of the protocol generated by the model.
1
2
3
4
As detailed in Section IV, and as cited in Figures 5 and 7,
TS 33.501 requires the informally described security properties
S1, S2, A1–A7. These lead us to believe that 5G-AKA should
uphold the more traditionally deﬁned properties of session
key secrecy (which here implies long-term key secrecy), non-
injective agreement on the parties involved, and injective
agreement on the session key, KSEAF.
4Joint with the USIM; we model them as part of the same entity.
6




We consider session key secrecy, long-term key secrecy,
non-injective and injective agreement on a variety of terms.
A. Secrecy properties
We consider both session key secrecy (of KSEAF and KAUSF)
and long-term key secrecy (of K) for 5G-AKA.
The session key secrecy lemmas state that for all traces
where there was not a long-term key reveal action by the
adversary for the UE/SUPI in question, the adversary never
learns (or derives) the resultant session key, KSEAF (or in the
case of the ARPF, KAUSF). As deﬁned in TS 33.501 Annex A.6,
KSEAF = KDFA(KAUSF, SNID); this is calculated at the AUSF.
If the adversary is in possession of KAUSF, they can derive
KSEAF, but not the other way round. The ARPF can clearly
derive KSEAF, but from the point of view of the ARPF we
consider the secrecy of the KAUSF to pin-point any compromise
precisely: adversarial knowledge of KAUSF implies knowledge
of KSEAF, but the reverse is not the case.
We consider session key secrecy from the point of view
of each of the four parties, as this captures a broader range
of properties than just secrecy for the UE. We do not just
consider the adversary being able to violate the secrecy of
what is ostensibly the correct session key, but also the situation
where an adversary can trick a party into accepting an incorrect
session key which the adversary knows or can derive. This
latter property also involves a violation of authentication, but
we discuss those properties in the next section.
The session key secrecy properties in the 5G-AKA models
are of the following form:
lemma secrecy_UE:
"All UE t #i. Secret(, t) @ #i
& not(Ex SUPI HN #r. RevealKforSUPI(SUPI) @ #r
& Honest() @ #i )
==> not (Ex #j. K(t) @ #j )"
Intuitively, for all traces such that a Secret action fact occurs
at the UE at time point #i for term t (the session key), and
there is no adversary key-reveal action for the same SUPI as in
use at point #i, then there does not exist a time point #j such
that the adversary learns or can derive that same term t. We
discuss use of the ‘RevealKforSUPI(...)’ action fact in
more depth in Section VII. We consider session key secrecy
properties of this form for all four of the protocol’s parties.
The long-term key secrecy lemma roughly says: for all
long-term keys (each bound to a speciﬁc SUPI), where that
key Ki (= K) was not revealed directly by the adversary, there
is no time point such that the adversary learns the long-term
key. This is modelled as follows:
lemma secrecy_Ki:
" All SUPI Ki #i. LongTermKey(SUPI,Ki) @ #i
& not(Ex #r. RevealKforSUPI(SUPI) @ #r)
==> not (Ex #j. K(Ki) @ #j)"
We believe these lemmas model the informal properties S1
and S2. We provide full results for session key secrecy and
long-term key secrecy in Section VIII.
B. Authentication properties
As 5G-AKA considers four parties (each with different
roles), it is not sufﬁcient just to consider traditional two-party




authentication properties deﬁned between the components in
possession of the long-term secret key, i.e., the UE and ARPF.
The authentication properties described below systematically
cover the range of pairwise authentication properties which we
believe the 5G-AKA protocol could be expected to provide.
For properties in the serving and home networks, we do
not expect 5G-AKA to create conﬁdentiality, integrity, or
authentication guarantees between 5G core network parties.
The standard describes properties which must be guaranteed
by the underlying network connections, and we explore this
further in Sections III-A and VII-B. To analyse authentication
properties, we place Action Facts within protocol rules. We
consider pairwise agreement properties from the points of
view of each of the UE, serving network, and home network
(‘Commit’ Action Facts). These properties are then considered
in relation to each one of the four parties (UE, SEAF, AUSF,
and ARPF), who generate the relevant ‘Running’ Action
Facts. We do not consider agreement properties from the point
of view of the ARPF on its own, because: ﬁrstly, the ARPF’s
only role is to initiate the cryptographic section of the protocol
(generating RAND, AUTN, XRES*, and KAUSF); none of the
messages before the Auth-Info Request message involve
any keys, randomness, state, or other cryptographic elements;
secondly, no messages are returned to the ARPF.
We can combine the results from these pairwise properties
(agreeing on single terms) together to achieve the more tradi-
tional properties of e.g., non-injective or injective agreement
over the identities involved in the protocol run and a term such
as the session key, as described in [20]. Performing the analysis
systematically in this manner helps us to pin-point precisely
which terms (if any) cause any violations of agreement.
For example, if all three individual properties “UE and
ARPF agree on the identity of the ARPF”, “UE and ARPF
agree on the identity of the UE”, and “UE and ARPF agree
on KSEAF” hold true, this would imply the stronger, traditional
property from the point of view of the UE of non-injective
agreement between the UE and ARPF on the term KSEAF.
UE: From the informal authentication properties deﬁned in
Section IV, we believe the properties directly concerning the
point of view of the UE are A1, A2, A4–A7. Achieving all of
these properties would be similar to achieving the traditional
property of injective agreement (as described in [20]) on the
identities of the UE, serving network, and home network, in
combination with the term KSEAF. We explore the full range
of properties from the point of view of the UE, considering
agreement with the SEAF, AUSF, and ARPF on the identities
of the parties, and the ‘data’ term, e.g., KSEAF.
Modelled formally, these properties follow the pattern
illustrated in the following example lemma:
lemma agreement_UE_SEAF_ARPF:
"All a b c d t #i.


1
2
3
4
5
6
7
(Commit(a,,t,) @ #i
& not(Ex #r.
RevealKforSUPI(a)@r & Honest()@ #i))
==>(Ex a2 b2 c2 t2 #j .
Running(b2,,t2, ) @ #j )"
This example models agreement from the UE’s point of view
with a SEAF on the identity of the ARPF.
In more detail, this says: For all traces such that there
was a ‘Commit(...)’ Action Fact at the UE, where the UE
believes the parties involved in the protocol are a, b, c,
and d (instantiating as the unique IDs of the UE, SEAF, AUSF,
and ARPF respectively), and the UE believes that the session
key KSEAF is term t, and there was not an adversary key reveal
against the UE’s long-term key K, then there must exist at
least one ‘Running(...)’ Action Fact from a SEAF which
agrees with the UE on the identity of the ARPF. Note that
this speciﬁc lemma does not require agreement on any other
terms: e.g., the UE and SEAF involved in the speciﬁc Commit
and Running Action Facts could completely disagree on
the identity of the AUSF, or even on the identities of the
two directly involved parties, the UE and SEAF. Proving this
property true demonstrates non-injective agreement on just
the named term, in this case, the ARPF.
We then also consider injectivity: achieving injective
agreement requires agreement on the same terms (and/or parties)
as before, but now also requires that there must be precisely
one Commit(...) Action Fact with the speciﬁed term. As
all of the identities of the parties involved may reasonably
be used in repeated protocols, the only terms where we can
hope to achieve injectivity are the ‘data’ terms, e.g., KSEAF
and KAUSF.
Injective agreement lemmas are modelled similarly, but
now additionally require that there must not exist another
Commit(...) Action Fact agreeing on the same term t
at a different time point #k, i.e., such that #i and #k are not
the same event.
Serving Network (SEAF): From the informal authentication
properties deﬁned in Section IV, we believe the properties
directly concerning the point of view of the serving network
are A1–A3, A6, and A7. The serving network shares privileged,
authentic, and non-replayable access to the 5G core network
through which it can communicate with the home network.
Before the protocol run, the SEAF does not share any secrets
relevant to the 5G-AKA protocol with any other parties, nor
does it generate any randomness, or maintain state beyond
each run of the protocol. We might ordinarily expect that the
strongest achievable authentication property with a conﬁdential
channel would be non-injective agreement; however, as the
secure channel between the AUSF and SEAF is explicitly non-
replayable, we can potentially leverage this fact to achieve
injective agreement on the parties involved and the session key.
Home Network (AUSF and ARPF): From the informal
authentication properties deﬁned in Section IV, we believe
the properties directly concerning the point of view of the
home network are A3–A7. Achieving all of these properties
would be similar to achieving the traditional property of
injective agreement on the identities of the UE, serving network,
and home network, in combination with the term KSEAF, as
described in [20].
While we separate the components of the home network into
the AUSF and ARPF for the sake of modelling the protocol,
we consider them to be much more closely related than e.g., the
relationship between the AUSF and SEAF. The ARPF receives
and sends only one pair of messages, and the contents of the
received Auth-Info Request message only indicate that
a party wants to start a protocol run; it does not contain any


7
cryptographically generated or signed terms, or any randomness
generated by the initiator.
As the ARPF does not participate in the protocol after
sending the Auth-Info Response message, it cannot know
whether the UE responded to its challenge correctly or not.
As the AUSF has sufﬁcient information to determine the
correctness of the response from the UE, and as the AUSF is
part of the home network, we consider the AUSF and ARPF
as a pair for the high level properties regarding authentication.
Hence, we consider the ﬁnal group of authentication properties
from the point of view of the “home network”, rather than
either one of the AUSF or ARPF.
We analyse the full range of authentication properties
for each party communicating (directly or indirectly) with
each other party, and for the terms over which they might
meaningfully agree. We provide full results in Section VIII.
VII. FORMALISATION OF THREAT MODEL
We now consider how we formalised the threat model
described in Section III. As this threat model does not allow
compromise of components apart from other UEs (i.e., no
SEAF, AUSF, or ARPF compromise is allowed), we only need
to consider adversary key reveal (of other UEs’ long term keys)
and secure channel modelling.
A. Adversary key reveal
Distinct from other adversary actions we include a rule
allowing the adversary to compromise the long-term key K of
UEs other than the ‘honest’ UE we consider directly. When the
adversary triggers it, this rule outputs a user’s long term key K
to the public network channel, allowing the adversary to learn
it. When we specify security properties, we include restrictions
on the allowed events within protocol executions, such as when
the adversary may perform key reveals. We achieve this by
clauses preventing certain actions. To prevent the adversary
from revealing an honest actor’s long term K, we require that
there are no events (recorded by ‘Action Facts’) revealing the
key to the adversary. These Action Facts are parameterised
by the ID of the party the key is for, so we can allow the
compromise of any other long-term Ks, i.e., for other UEs.
B. Secure channel modelling
Within our 5G-AKA TAMARIN models we model the secure
channels within the 5G Core Network using the standard secure
channel abstraction, as used and described in [12]. This con-
struction replaces TAMARIN’s adversary-controlled Dolev-Yao-
style channels with secure channels where desired. This takes
the adversary-controlled In(msg) and Out(msg) facts, and
replaces them with secure channels. These facts are similar to
the form SndS(A,B,msg) and RcvS(A,B,msg), sending
the term msg from A to B, who are explicitly named parties.
We augment the standard construction very simply by including
a ‘channel name’, ‘SendType’, ‘ReceiveType’, and associated