rules ∀β.M t that are intuitively subsumed by existing rules
∀βi.Mi  ti and existing constraints Xj ? xj, provided that
a new equation is added to Ψ. The last two technical condi-
tions in the premisses ensure the completeness of Discard
when it is applied eagerly.
We now make precise the control on transformation rules,
that is which sequences of rules need to be considered by the
algorithm. For simplicity, we assume that the uniﬁcation
procedure tries to match its second argument against the
ﬁrst one whenever possible. In other words, mgu(t, l) = σ
whenever var(t) ∩ var(l) = ∅ and t = lσ. The choice of the
arity am + 1 rather than am for Context and Related is
only to ensure that rule Coalesce substitutes these fresh
second-order variables in priority.
Let Σ be an intruder constraint system. A sequence of
transformations (derivation) Σ =⇒∗ Σ0 by the rules of Ta-
ble 2 is standard iﬀ it has the following structure:
• If Σ1 occurs before Σ2 in the derivation, with Σi =
Φi; Ψi;Ci; σi;Ni, and both constraint systems are pre-
solved and saturated for the last four rules, Discard,
Clean-{1,2} and Generalize, then Φ1; Ψ1;C1; σ1 6=
Φ2; Ψ2;C2; σ2.
• Rules Narrowing-{1,2}, Constrain, Context, Re-
late are always followed by a maximal sequence of
Project, Imitate, Coalesce, and then, if a pre-solved
form is reached, by maximal sequences of Discard,
Clean-1, Clean-2 and Generalize, in this order.
Finally, we state our main theorem.
Theorem 2. Standard derivations form a sound, com-
plete, eﬀective and ﬁnitely branching (up to renaming) trans-
formation system. Moreover there exists no inﬁnite standard
derivation.
We deduce the decision result of Theorem 1 using K¨onig’s
Lemma and Proposition 1. The proofs of soundness and
completeness follow the same structure as previously. For
rules Narrowing-{1,2} and Context, the fact that rσ may
be added to N is justiﬁed by the following property of sub-
term rewriting systems: if f (t1 . . . tn) = lµ for some rewrit-
ing rule l → r ∈ R, and all the t1 . . . tn are R-reduced then
rµ is reduced. This property together with the convergence
of R turns out to be suﬃcient to imply the completeness of
standard derivations.
As for the proof of termination, due to the constraints
on narrowing positions, the rules Narrowing-{1,2} ter-
minate independently from the other rules. So does rule
Constrain, as well as the last four rules of Table 2. Let
Σ0 =⇒∗ Σ be a standard derivation such that Σ is pre-
solved and saturated for Discard, Clean-{1,2} and Gen-
eralize. Let eσ be the composition of all the substitutions
prove that each deducible term t in Σ is of the form t0eσ
applied during it. Concerning Context and Relate, we
where t0 is a subterm of a term t0 intuitively the narrowed
version of a deducible term in Σ0, now in N . (More precisely
t0 is the value corresponding to an initial term in Φ0 after
it was added to N , as the system was pre-solved again for
the ﬁrst-time). Thanks to rule Discard, we obtain that the
number of rules in Φ exploitable by Context and Relate
is bounded, and deduce the termination for the whole set of
rules.
5. CONCLUSION
In this work we described a class of second-order E-uniﬁ-
cation problems and provided a terminating procedure to
decide their satisﬁability and their equivalence, in the case
where the equational theory E is presented by a convergent
subterm rewriting system. This decision result is interesting
by itself as it is not implied by previous work in the area,
e.g. [16, 21, 17].
A major application, for which these constraint systems
were intended,
is the security of cryptographic protocols
against oﬀ-line guessing attacks. No previous decision re-
sults existed for such properties, in any case, not using the
recent general deﬁnition of Corin et al. [10]. Using our main
result, we recovered the decidability of trace properties, and
proved the decidability of security against of oﬀ-line guessing
attacks for a bounded number of sessions.
As future work, we foresee to apply our notion of equiv-
alence between symbolic traces to other security properties,
such as strong secrecy and resistance to on-line guessing at-
tacks. On the long term an interesting avenue would be
to extend our result to equational theories involving alge-
braic properties such as associativity-commutativity, XOR
or homomorphism.
Acknowledgments
We are very grateful to V´eronique Cortier, Florent Jacque-
mard and St´ephanie Delaune for helpful discussions, to Jean
Goubault-Larrecq, Steve Kremer and the anonymous refer-
ees for useful comments. This work was partially supported
by the RNTL project PROUV´E and the ACI-SI Rossignol.
6. REFERENCES
[1] M. Abadi and V. Cortier. Deciding knowledge in
security protocols under equational theories. In Proc.
31st International Colloquium on Automata,
Languages and Programming (ICALP’04), volume
3142 of LNCS, pages 46–58, 2004.
[2] M. Abadi and V. Cortier. Deciding knowledge in
security protocols under (many more) equational
theories. In Proc. 18th IEEE Computer Security
Foundations Workshop (CSFW’05), pages 62–76,
2005.
[3] M. Abadi and C. Fournet. Mobile values, new names,
and secure communications. In Proc. 28th Annual
ACM Symposium on Principles of Programming
Languages (POPL’01), pages 104–115, 2001.
[4] M. Baudet. Deciding security of protocols against
oﬀ-line guessing attacks (extended version). Technical
report, LSV, 2005. Available at
http://www.lsv.ens-cachan.fr/∼baudet.
[5] B. Blanchet. Personal web page.
http://www.di.ens.fr/∼blanchet.
[6] B. Blanchet. Automatic proof of strong secrecy for
security protocols. In Proc. 25th IEEE Symposium on
Security and Privacy (SSP’04), pages 86–100, 2004.
[7] B. Blanchet, M. Abadi, and C. Fournet. Automated
veriﬁcation of selected equivalences for security
protocols. In Proc. 20th IEEE Symposium on Logic in
Computer Science (LICS’05), pages 331–340, 2005.
[8] Y. Chevalier, R. K¨usters, M. Rusinowitch, and
M. Turuani. Deciding the security of protocols with
Diﬃe-Hellman exponentiation and products in
exponents. In Proc. 23rd Conference on Foundations
of Software Technology and Theoretical Computer
Science (FST–TCS’03), volume 2914 of LNCS, pages
124–135, 2003.
[9] E. Cohen. Proving protocols safe from guessing. In
Proc. Foundations of Computer Security (FCS’02),
pages 85–92, 2002.
[10] R. Corin, J. Doumen, and S. Etalle. Analysing
password protocol security against oﬀ-line dictionary
attacks. In Proc. 2nd International Workshop on
Security Issues with Petri Nets and other
Computational Models (WISP’04), volume 121 of
ENTCS, pages 47–63, 2005.
[11] R. Corin, S. Malladi, J. Alves-Foss, and S. Etalle.
Guess what? Here is a new tool that ﬁnds some new
guessing attacks. In Proc. Workshop on Issues in the
Theory of Security (WITS’03), pages 62–71, 2003.
[12] S. Delaune and F. Jacquemard. A decision procedure
for the veriﬁcation of security protocols with explicit
destructors. In Proc. 11th ACM Conference on
Computer and Communications Security (CCS’04),
pages 278–287, 2004.
[13] S. Delaune and F. Jacquemard. A theory of dictionary
attacks and its complexity. In Proc. 17th IEEE
Computer Security Foundations Workshop
(CSFW’04), pages 2–15, 2004.
[14] D. Dolev and A. C. Yao. On the security of public key
protocols. IEEE Transactions on Information Theory,
IT-29(12):198–208, 1983.
[15] L. Gong, M. A. Lomas, R. M. Needham, and J. H.
Saltzer. Protecting poorly chosen secrets from
guessing attacks. IEEE Journal on Selected Areas in
Communications, 11(5):648–656, 1993.
[16] J.-P. Jouannaud and C. Kirchner. Solving equations in
abstract algebras: A rule-based survey of uniﬁcation.
In J.-L. Lassez and G. Plotkin, editors, Computational
Logic: Essays in Honor of Alan Robinson, pages
257–321. MIT Press, 1991.
[17] J. Levy and M. Veanes. On the undecidability of
second-order uniﬁcation. Information and
Computation, 159(1-2):125–150, 2000.
[18] G. Lowe. Analysing protocols subject to guessing
attacks. Journal of Computer Security, 12(1):83–98,
2004.
[19] J. K. Millen and V. Shmatikov. Constraint solving for
bounded-process cryptographic protocol analysis. In
Proc. 8th ACM Conference on Computer and
Communications Security (CCS’01), pages 166–175,
2001.
[20] J. K. Millen and V. Shmatikov. Symbolic protocol
analysis with products and Diﬃe-Hellman
exponentiation. In Proc. 16th IEEE Computer
Security Foundations Workshop (CSFW’03), pages
47–61, 2003.
[21] W. Snyder and J. H. Gallier. Higher-order uniﬁcation
revisited. Journal of Symbolic Computations,
8:101–140, 1989.
Project
µ = mgu(t, f (t1 . . . tn))
ρ fresh renaming s.t. dom(ρ) ⊆ var(M ) and ∀Y ∈ var(M ρ), ar(Y ) ≤ ar(X)
X 6∈ var(M )
∀wi ∈ par(M ), i ≤ ar(X)
Φ ∪ {∀β.M  t}; Ψ; C ] {X ? f (t1 . . . tn)}; σ =⇒ ( Φ ∪ {∀β.M  t}; Ψ; C; σ ){X 7→ M ρ}ρµ
Imitate
f ∈ Fpub
X1 . . . Xn fresh second-order variables with ar(Xi) = ar(X)
Φ; Ψ; C ] {X ? f (t1 . . . tn)}; σ
=⇒ ( Φ; Ψ; C ∪ {X1 ? t1, . . . , Xn ? tn}; σ ){X 7→ f (X1 . . . Xn)}
Coalesce
Φ; Ψ; C ] {X1 ? x, X2 ? x}; σ =⇒ ( Φ; Ψ; C ∪ {X1 ? x}; σ ){X2 7→ X1}
ar(X1) ≤ ar(X2)
Narrowing-1
l → r fresh rule from R
t|p 6∈ X
µ = mgu(t|p, l)
Φ ] {∀β.M  t}; Ψ; C; σ =⇒ ( Φ ∪ {∀β.M  t[p := r]}; Ψ; C; σ ) µ
Narrowing-2
l → r fresh rule from R
Φ; Ψ; C ] {t1 =?R t2}; σ =⇒ ( Φ; Ψ; C ] {(t1 =?R t2)[p := r]}; σ ) µ
(t1 =?R t2)|p 6∈ X
µ = mgu((t1 =?R t2)|p, l)
Constrain
µ = mgu(t1, t2)
Φ; Ψ; C ] {t1 =?R t2}; σ =⇒ ( Φ; Ψ; C; σ ) µ
Context
l → r fresh rule from R
Φ; Ψ; C; σ =⇒ Φ ∪ {X  r}; Ψ; C ∪ {X ? l}; σ
X fresh second-order variable of arity am
Relate
Φ ∪ {∀β.M  t}; Ψ; C; σ =⇒ Φ ∪ {∀β.M  t}; Ψ ∪ {∀β.X ./ M}; C ∪ {X ? t}; σ
X fresh second-order variable of arity am
Table 1: Transformation rules for convergent rewriting systems
Each of the last ﬁve rules additionally requires its left-hand constraint system to be pre-solved, that
is, saturated for the ﬁrst three rules.
Project
µ = mgu(t, f (t1 . . . tn))
ρ fresh renaming s.t. dom(ρ) ⊆ var(M ) and ∀Y ∈ var(M ρ), ar(Y ) ≤ ar(X)
X 6∈ var(M )
∀wi ∈ par(M ), i ≤ ar(X)
Φ ∪ {∀β.M  t}; Ψ; C ] {X ? f (t1 . . . tn)}; σ; N =⇒ ( Φ ∪ {∀β.M  t}; Ψ; C; σ; N ∪ {t} ){X 7→ M ρ}ρµ
Narrowing-1
l → r fresh rule from R
t|p 6∈ X ∪ st(N )
µ = mgu(t|p, l)
Φ ] {∀β.M  t}; Ψ; C; σ; N =⇒ ( Φ ∪ {∀β.M  t[p := r]}; Ψ; C; σ; N ∪ {r} ) µ
Narrowing-2
l → r fresh rule from R
µ = mgu((t1 =?R t2)|p, l)
Φ; Ψ; C ] {t1 =?R t2}; σ; N =⇒ ( Φ; Ψ; C ] {(t1 =?R t2)[p := r]}; σ; N ∪ {r} ) µ
Constrain
(t1 =?R t2)|p 6∈ X ∪ st(N )
µ = mgu(t1, t2)
Φ; Ψ; C ] {t1 =?R t2}; σ; N =⇒ ( Φ; Ψ; C; σ; N ∪ {t1} ) µ
Context
l → r fresh rule from R
Φ; Ψ; C; σ; N =⇒ Φ ∪ {X  r}; Ψ; C ∪ {X ? l}; σ; N ∪ {r}
X fresh second-order variable of arity am + 1
Relate
Φ ∪ {∀β.M  t}; Ψ; C; σ; N =⇒ Φ ∪ {∀β.M  t}; Ψ ∪ {∀β.X ./ M}; C ∪ {X ? t}; σ; N ∪ {t}
X fresh second-order variable of arity am + 1
Discard
t, t1 . . . tn ∈ st(N )
t = C[t1 . . . tn, x1 . . . xm]
∀β1.M1  t1, . . . ,∀βn.Mn  tn ∈ Φ
max{j | wj ∈ par(M1 . . . Mn)} ≤ max{j | wj ∈ par(M )}
∀Y ∈ var(∀β1 . . . βn.C[M1 . . . Mn, X1 . . . Xm]),
(
X1 ? x1, . . . , Xm ? xm ∈ C
either Y ∈ var(∀β.M )
or
ar(Y ) < max{j | wj ∈ par(M )}
Φ ] {∀β.M  t}; Ψ; C; σ; N =⇒ Φ; Ψ ∪ {∀β1 . . . βn, β.C[M1 . . . Mn, X1 . . . Xm] ./ M}; C; σ; N
Clean-1
x 6∈ var(Φ; C; σ)
Φ; Ψ; C ] {X ? x}; σ; N =⇒ Φ; Ψ; C; σ; N
Clean-2
v 6∈ Y
Φ; Ψ; C; σ ] {v 7→ T}; N =⇒ Φ; Ψ; C; σ; N
Generalize
Φ; Ψ; C; σ; N =⇒ {∀X.∀β.M  t}(∀β.M t)∈Φ; {∀X.∀β.M ./ N}(∀β.M ./N )∈Ψ; C; σ; N
X ∈ var(Φ) ∪ var(Ψ) − var(C) − var(σ) − Y
Table 2: Transformation rules for convergent subterm rewriting systems
The ﬁve rules from Narrowing-1 to Relate additionally require their left-hand constraint systems
to be pre-solved and saturated for the last four rules.
Each of the last four rules requires its left-hand constraint system to be pre-solved and saturated
for the higher rules in this group.