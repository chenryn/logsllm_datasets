47
28
Min.
Max.
Mean
Mode
TDO US HSU HT
28
88
98
95
71
90
89
95
25
98
52
45
11
98
49
36
SMC
26
98
53
49
Table 3: Bytecode similarity (in %) per honeypot technique.
their bytecode might still be very diverse.
Proﬁtability. Table 4 lists the proﬁtability per honeypot
technique. The proﬁtability is computed as received amount
- (spent amount + transaction fees). No values are provided
for TDO, because for the single true positive that we anal-
ysed, the transaction fees spent by the attacker were higher
than the amount that the attacker gained from the victim. The
smallest and largest proﬁt were made using a hidden state
update honeypot, with 0.00002 ether being the smallest and
11.96 ether being the largest. The most proﬁtable honeypots
are straw man contract honeypots, with an average value of
1.76 ether, whereas the least proﬁtable honeypots are unini-
tialised struct honeypots, with an average value of 0.46 ether.
A total proﬁt of 257.25 ether has been made through honey-
pots, of which 171.22 ether were solely made through hidden
state update honeypots. However, the exchange rate of cryp-
tocurrencies is very volatile and thus their value in USD may
vary greatly on a day-to-day basis. For example, although
11.96 ether is the largest proﬁt made in ether, its actual value
in USD was solely 500 at the point of withdrawal. Thus, we
found that the largest proﬁt in terms of USD, was actually a
honeypot with 3.10987 ether, as it was worth 2,609 USD at
the time of withdrawal. Applying this method across the 282
honeypots, results in a total proﬁt of 90,118 USD.
7 Discussion
In this section we summarise the key insights gained through
our analysis and we discuss the ethical considerations as well
as the challenges and limitations of our work.
Min.
0.01
0.004
0.584
-
0.009
0.00002
1.009
0.399
BD
ID
SESL
TDO
US
HSU
HT
SMC
-
1.1
11.96
1.1
4.94
-
0.46
1.44
1.05
1.76
Max. Mean Mode Median
1.13
6.41
4.24
0.5
1.06
1.59
0.11
0.33
1.23
0.11
0.1
1.0
-
0.1
0.1
1.0
2.0
-
0.38
1.02
1.05
1.99
Sum
3.5
17.02
9.57
-
6.44
171.22
2.11
47.39
Overall
0.00002
11.96
1.35
1.0
1.01
257.25
Table 4: Statistics on the proﬁtability of each honeypot tech-
nique in ether.
7.1 Honeypot Insights
Although honeypots are capable of trapping multiple users,
we have found that most honeypots managed to take the
funds of only one victim. This indicates that users poten-
tially look at the transactions of other users before they sub-
mit theirs. Moreover, the low success rate of honeypots with
comments, suggests that users also check the comments on
Etherscan before submitting any funds. We also found that
the bytecode of honeypots can be vastly different even if us-
ing the same honeypot technique. This suggests that the us-
age of signature-based detection methods would be rather
ineffective. HONEYBADGER is capable of recognising a va-
riety of implementations, as it speciﬁcally targets the func-
tional characteristics of each honeypot technique. More than
half of the honeypots were successful within the ﬁrst 24
hours. This suggests that honeypots become less effective
the older they become. This is interesting, as it means that
users seem to target rather recently deployed honeypots than
older ones. We also note that most honeypot creators with-
draw their loot within 24 hours or abort their honeypots if
they are not successful within the ﬁrst 24 hours. We there-
fore conclude that honeypots have in general a short lifespan
and only a small fraction remain active for a period longer
than one day.
7.2 Challenges and Limitations
The amount of smart contracts with source code available
is rather small. At the time of writing, there are only 50,000
contracts with source code available on Etherscan. This high-
lights the necessity of being able to detect honeypots at the
bytecode level. Unfortunately, this turns out to be extremely
challenging when detecting certain honeypot techniques. For
example, while detecting inheritance disorder at the source
code level is rather trivial, detecting it at the bytecode level
is rather difﬁcult since all information about the inheritance
is lost during compilation and not available anymore at the
bytecode level. The fact that certain information is solely
available at the source code level and not at the bytecode
level, obliges us to make use of other less precise informa-
tion that is available in the bytecode in order to detect hon-
eypot techniques such as inheritance disorder. However, as
Section 5 shows, this approach reduces the precision of our
detection and introduces some false positives. Finally, an-
other limitation of our tool is that it is currently limited to
the detection of the eight honeypot techniques described in
this paper. Thus other honeypot techniques are not detected.
Nevertheless, we designed HONEYBADGER with modular-
ity in mind, such that one can easily extend the honeypot
analysis component with new heuristics in order to detect
more honeypot techniques.
1602    28th USENIX Security Symposium
USENIX Association
7.3 Ethical Considerations
In general, honeypots have two participants, the creator of
the honeypot, and the user whose funds are trapped by the
honeypot. However, the ethical intentions of both partici-
pants are not always clear. For instance, a honeypot creator
might deploy a honeypot with the intention to scam users and
make proﬁt. In this case we clearly have a malicious inten-
tion. However, one could also argue that a honeypot creator
is just attempting to punish users that behave maliciously.
Similarly, the intentions of a honeypot user can either be ma-
licious or benign. For example, if a user tries to intention-
ally exploit a reentrancy vulnerability, then he or she needs
to be knowledgable and mischievous enough to prepare and
attempt the attack, and thus clearly showing malicious be-
haviour. However, if we take the example of an uninitialised
struct honeypot that is disguised as a simple lottery, then we
might have the case of a benign user who loses his funds
under the assumption that he or she is participating in a fair
lottery. Thus, both honeypot creators and users cannot al-
ways be clearly classiﬁed as either malicious or benign, this
depends on the case at hand. Nevertheless, we are aware that
our methodology may serve malicious attackers to protect
themselves from other malicious attackers. However, with
HONEYBADGER, we hope to raise the awareness of honey-
pots and save benign users from potential ﬁnancial losses.
8 Related Work
Honeypots are a new type of fraud that combine security is-
sues with scams. They either rely on the blockchain itself or
on related services such as Etherscan. With growing interest
within the blockchain community, they have been discussed
online [31, 32, 33] and collected within public user reposito-
ries [22, 45]. Frauds and security issues are nothing new
within the blockchain ecosystem. Blockchains have been
used for money laundering [24] and been the target of several
scams [42], including mining scams, wallet scams and Ponzi
schemes, which are further discussed in [4, 43]. In particu-
lar, smart contracts have been shown to contain security is-
sues [2]. Although not performed directly on the blockchain,
exchanges have also been the target of fraud [23].
Several different methods have been proposed to discover
fraud as well as security issues. Manual analysis is per-
formed on publicly available source code to detect Ponzi
schemes [3].
[49] introduces ERAYS, a tool that aims to
produce easy to analyse pseudocode from bytecode where
the source code is not available. However, manual analysis
is particularly laborious, especially considering the number
of contracts on the blockchain. Machine learning has been
used to detect Ponzi schemes [8] and to ﬁnd vulnerabilities
[36]. The latter relies on [27] to obtain a ground truth of
vulnerable smart contracts for training their model. Fuzzing
techniques have been employed to detect security vulnera-
bilities in smart contracts [15] and in combination with sym-
bolic execution to discover issues related to the ordering of
events or function calls [17]. However, fuzzing often fails
to create inputs to enter speciﬁc execution paths and there-
fore might ignore them [40]. Static analysis has been used
to ﬁnd security [7, 39, 37] and gas-focused [11] vulnerabili-
ties in smart contracts. [7] requires manual interaction, while
[39] requires both the deﬁnition of violation and compliance
patterns.
[37] requires Solidity code and therefore cannot
be used to analyse the large majority of the smart contracts
deployed on the Ethereum blockchain. [11] considers gas-
related issues which is not necessary for the purpose of this
work.
In order to use formal veriﬁcation, smart contracts
can, to some extent, be translated from source code or byte-
code into F* [5, 12] where the veriﬁcation can more easily be
performed. Other work operates on high-level source code
available for Ethereum or Hyperledger [16]. [13, 14] pro-
pose a formal deﬁnition of the EVM, that is extended in [1]
towards more automated smart contract veriﬁcation and the
consideration of gas. Formal veriﬁcation often requires (in-
complete) translations into other languages or manual user
interaction (e.g.: [30]). Both of these reasons make formal
veriﬁcation unsuitable to be used on a large number of con-
tracts, as it is required in this work.
Symbolic execution has been used on smart contracts to
detect common [28, 25, 21, 38] vulnerabilities. This tech-
nique also allows to ﬁnd speciﬁc kinds of misbehaving con-
tracts [27]. It can further provide values that can serve to gen-
erate automated exploits that trigger vulnerabilities [18]. The
same technique is used in this paper. Symbolic execution has
the advantage of being capable to reason about all possible
execution paths and states in a smart contract. This allows
for the implementation of precise heuristics while achieving
a low false positive rate. Another advantage is that symbolic
execution can be applied directly to bytecode, thus making it
well suited for our purpose of analysing more than 2 million
smart contracts for which source code is largely not avail-
able. The disadvantage is the large number of possible paths
that need to be analysed. However, in the case of smart
contracts this is not an issue, as most are not very complex
and very short. Moreover, smart contract bytecode cannot
grow arbitrarily large due to the gas limit enforced by the
Ethereum blockchain.
To the best of the authors’ knowledge, this paper is the ﬁrst
to consider and discuss honeypot smart contracts, a new type
of fraud, and to propose a taxonomy as well as an automated
tool using symbolic execution for their detection.
9 Conclusion
In this work, we investigated an emerging new type of fraud
in Ethereum: honeypots. We presented a taxonomy of hon-
eypot techniques and introduced a methodology that uses
symbolic execution and heuristics for the automated detec-
USENIX Association
28th USENIX Security Symposium    1603
tion of honeypots. We showed that HONEYBADGER can ef-
fectively detect honeypots in the wild with a very low false
positive rate. In a large-scale analysis of 151,935 unique
Ethereum smart contracts, HONEYBADGER identiﬁed 460
honeypots. Moreover, an analysis on the transactions per-
formed by a subset of 282 honeypots, revealed that 240 users
already became victims of honeypots and that attackers al-
ready made more than 90,000 USD proﬁt with honeypots. It
is worth noting that these numbers solely provide a lower
bound and thus might only reﬂect the tip of the iceberg.
Nonetheless, tools such as HONEYBADGER may already
help users in detecting honeypots before they can cause any
harm. In future work, we plan to further generalise our de-
tection mechanism through the use of machine learning tech-
niques. We also plan to extend our analysis with a larger sub-
set and eventually detect new honeypots by looking at other
contracts that are linked to the newly discovered honeypot
contracts.
Acknowledgments
We would like to thank Hugo Jonker and Sjouke Mauw as
well as the anonymous reviewers for their valuable feed-
back and comments. The experiments presented in this paper
were carried out using the HPC facilities of the University
of Luxembourg [41] – see https://hpc.uni.lu. This work
is partly supported by the Luxembourg National Research
Fund (FNR) under grant 13192291.
References
[1] Sidney Amani, Myriam B´egel, Maksym Bortin, and
Mark Staples. Towards verifying ethereum smart con-
tract bytecode in isabelle/hol. CPP. ACM. To appear,
2018.
[2] Nicola Atzei, Massimo Bartoletti, and Tiziana Cimoli.
A Survey of Attacks on Ethereum Smart Contracts
In Proceedings of the 6th International Con-
(SoK).
ference on Principles of Security and Trust - Volume
10204, pages 164–186. Springer-Verlag New York,
Inc., 2017.
[3] Massimo Bartoletti, Salvatore Carta, Tiziana Cimoli,
and Roberto Saia.
Dissecting ponzi schemes on
ethereum: identiﬁcation, analysis, and impact. arXiv
preprint arXiv:1703.03779, 2017.
[4] Massimo Bartoletti, Barbara Pes, and Sergio Serusi.
Data mining for detecting bitcoin ponzi schemes. arXiv
preprint arXiv:1803.00646, 2018.
[5] Karthikeyan Bhargavan, Nikhil Swamy, Santiago
Zanella-B´eguelin, Antoine Delignat-Lavaud, C´edric
Fournet, Anitha Gollamudi, Georges Gonthier, Nadim
Kobeissi, Natalia Kulatova, Aseem Rastogi, and
Thomas Sibut-Pinote. Formal Veriﬁcation of Smart
Contracts. In Proceedings of the 2016 ACM Workshop
on Programming Languages and Analysis for Security