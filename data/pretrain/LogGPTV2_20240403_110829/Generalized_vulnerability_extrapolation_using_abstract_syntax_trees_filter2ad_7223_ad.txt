### 代码片段优化

#### `receiveauthgrant` 函数
```c
int ret = 0;
aim_rxcallback_t userfunc;
guint16 tmp;
char *bn, *msg;

/* 读取好友名称 */
if ((tmp = byte_stream_get8(bs))) {
    bn = byte_stream_getstr(bs, tmp);
} else {
    bn = NULL;
}

/* 读取消息 (以 null 结尾) */
if ((tmp = byte_stream_get16(bs))) {
    msg = byte_stream_getstr(bs, tmp);
} else {
    msg = NULL;
}

/* 未知字段 */
tmp = byte_stream_get16(bs);

/* 调用回调函数 */
if ((userfunc = aim_callhandler(od, snac->family, snac->subtype))) {
    ret = userfunc(od, conn, frame, bn, msg);
}

/* 释放内存 */
g_free(bn);
g_free(msg);

return ret;
```

#### `parseicon` 函数
```c
static int parseicon(OscarData *od, FlapConnection *conn, aim_module_t *mod, FlapFrame *frame, aim_modsnac_t *snac, ByteStream *bs) {
    int ret = 0;
    aim_rxcallback_t userfunc;
    char *bn;
    guint16 flags, iconlen;
    guint8 iconcsumtype, iconcsumlen;
    guint8 *iconcsum, *icon;

    /* 读取好友名称 */
    bn = byte_stream_getstr(bs, byte_stream_get8(bs));

    /* 读取标志和其他信息 */
    flags = byte_stream_get16(bs);
    iconcsumtype = byte_stream_get8(bs);
    iconcsumlen = byte_stream_get8(bs);
    iconcsum = byte_stream_getraw(bs, iconcsumlen);
    iconlen = byte_stream_get16(bs);
    icon = byte_stream_getraw(bs, iconlen);

    /* 调用回调函数 */
    if ((userfunc = aim_callhandler(od, snac->family, snac->subtype))) {
        ret = userfunc(od, conn, frame, bn, iconcsumtype, iconcsum, iconcsumlen, icon, iconlen);
    }

    /* 释放内存 */
    g_free(bn);
    g_free(iconcsum);
    g_free(icon);

    return ret;
}
```

### 图 7: 原始漏洞 (CVE-2011-4601) 在 `receiveauthgrant` 中 (左侧)，零日漏洞在 `parseicon` 中 (右侧)

| 相似函数名 | 相似度 |
|--------------|---------|
| receiveauthgrant | 1.00 |
| receiveauthreply | 1.00 |
| parsepopup | 1.00 |
| parseicon | 1.00 |
| generror | 1.00 |
| incoming_.._buddylist | 0.99 |
| motd | 0.99 |
| receiveadded | 0.99 |
| mtn_receive | 0.99 |
| msgack | 0.99 |
| keyparse | 0.99 |
| hostversions | 0.99 |
| userlistchange | 0.98 |
| migrate | 0.98 |
| error | 0.98 |
| incomingim_ch4 | 0.98 |
| parse_flap_ch4 | 0.98 |
| infoupdate | 0.98 |
| parserights | 0.98 |
| incomingim | 0.98 |
| parseadd | 0.98 |
| userinfo | 0.97 |
| parsemod | 0.97 |
| parsedata | 0.97 |
| rights | 0.97 |
| uploadack | 0.97 |
| incomingim_ch2_sendfile | 0.96 |
| parseinfo_create | 0.96 |

表 3: Pidgin 中与已知漏洞最相似的前 30 个函数。

### 4. 限制

发现软件中的漏洞是一个难题。由于一个程序无法完全分析另一个程序的代码，因此不存在通用的方法来查找任意漏洞 [10]。因此，所有实际方法要么将搜索限制在特定类型的漏洞上，要么像漏洞外推一样，只能识别潜在的脆弱代码。

接下来我们详细讨论我们的方法的局限性。

我们的方法基于机器学习技术，如向量空间嵌入和潜在语义分析。这些技术在识别潜在脆弱代码方面是有效的，但它们并不能保证识别出的代码确实包含漏洞。这种局限性是机器学习应用的固有特性，因为它考虑的是源代码的统计特征而非真正的语义。然而，根据赖斯定理，通用的漏洞发现是不可能的，因此即使发现潜在漏洞在实践中也是有益的。

外推的前提是存在一个起始漏洞。如果没有任何已知漏洞可用，我们的方法将无法应用。但在实践中这种情况很少见。对于大型软件项目来说，发现单个漏洞并不困难，而是确保类似的缺陷不会在整个代码库中传播。外推正好解决了这一问题。此外，模糊测试、污点分析和符号执行等相关的技术可以轻松与漏洞外推结合，并自动提供起始漏洞。

最后，我们的方法仅限于在少数函数中发现漏洞。跨越整个代码库多个函数的复杂缺陷可能难以被我们的方法检测到。然而，我们在 FFmpeg 上的案例研究表明，只要两个函数与原始漏洞共享某些结构模式，仍然可以有效地识别分布在两个函数中的漏洞。

### 5. 相关工作

漏洞识别一直是安全研究的一个活跃领域。已经提出了多种不同的概念来查找和消除源代码中的安全缺陷。我们的方法与其中一些方法相关，将在本节中指出。

#### 5.1 代码克隆检测

在最简单的情况下，包含类似漏洞的函数是因为代码被复制。代码克隆检测一直是一个持续的研究课题。Kontogiannis 等人 [14] 探索了使用数值特征（如调用函数的数量）来检测代码克隆，而 Baxter 等人 [2] 提出了更细粒度的方法，比较抽象语法树 (AST)。Li 等人提出了 CP-Miner，一种基于频繁项集挖掘的代码克隆检测工具 [16]。他们展示了其方法优于 Kamiya 等人开发的 CCFinder 工具 [13]，这是一种基于标记的检测方法。Maletic 等人 [19] 提出了一种代码克隆检测方法，通过比较注释和标识符来比较函数。Jang 等人引入了一种使用 n-gram 分析来查找未修补代码副本的方法 [11]。Bellon 等人 [3] 对现有方法进行了全面评估。

代码克隆检测与漏洞外推有一些相似之处。然而，相应的方法解决了一个根本不同的问题，并且专门针对查找复制的代码。因此，它们只能发现由代码复制引入的漏洞。

#### 5.2 静态代码分析

漏洞外推的思想基于 API 使用模式通常指示脆弱代码的观察。这一对应关系早已被认识，并反映在几个静态分析工具中，如 Flawfinder [30]、RATS [24] 和 ITS4 [28]。这些工具提供了常见的 API 符号数据库，并允许自动扫描代码库中的出现情况。这些工具的有效性关键取决于数据库的质量和覆盖率。与内部 API 或未知 API 使用模式相关的漏洞无法被发现。

Engler 等人 [6] 是最早探索漏洞和编程模式之间联系的人之一。他们的方法能够在给定一组手动定义的编程模式的情况下检测漏洞。作为扩展，Li 和 Zhou [15] 提出了一种自动生成类似模式并检测代码中违反这些模式的方法。这种方法的一个内在问题是，频繁的编程错误会导致推理出有效的模式，从而无法检测到常见缺陷。Williams 等人 [31] 和 Livshits 等人 [17] 通过将软件修订历史纳入分析来解决这个问题。我们的方法与此类方法相关，但我们专注于通过分析代码结构来查找漏洞，而不是建模常见的编程模板。

#### 5.3 污点分析和符号执行

一种更通用的漏洞发现方法基于污点分析，其中漏洞通过源-汇系统来识别。如果来自源的污染数据传播到汇而不经过验证，则检测到潜在漏洞。该方法的成功已经在几种类型的漏洞中得到证明，包括 SQL 注入和跨站脚本 [12, 18] 以及整数型漏洞 [29]。

在大多数实现中，污点分析是一个动态过程，因此仅限于在程序执行过程中可观察到的漏洞发现。

污点分析的局限性已被几位作者通过符号执行解决 [例如 1, 4, 8, 22]。这些方法不是被动地监控从源到汇的数据流，而是尝试主动探索不同的执行路径。最值得注意的是 Avgerinos 等人 [1] 引入的一种用于查找甚至利用安全漏洞的框架。然而，符号执行的强大能力也带来了代价：分析经常受到大量可能执行路径的影响。在实践中，需要不同的假设和启发式方法来减少这些路径的空间，使其变得可处理。因此，符号执行在常规代码审计中的应用仍远非实用 [9]。

#### 5.4 漏洞外推

漏洞外推的概念首先在 [33] 中提出。在这项工作中，提出了一种基于函数和类型名称使用分析的漏洞外推方法。然而，该方法既不考虑语法也不考虑代码结构，因此分析仅限于特定 API 符号所反映的缺陷。我们的方法通过提取和分析 AST 中的结构模式显著扩展了这项工作。因此，我们能够发现与 API 使用和代码结构相关的漏洞。此外，我们在更大规模的代码集上展示了我们方法的有效性。

与其他相关方法相比，值得注意的是，漏洞外推并不旨在自动识别漏洞，而是使源代码的手动审计更加有效。其基本原理是，尽管手动审计耗时，但它仍然优于自动方法并在实践中不可或缺。漏洞外推的辅助方法更好地满足了安全从业人员的需求。

### 6. 结论

加强计算机系统的安全性的一个关键是彻底消除底层源代码中的漏洞。为此，我们介绍了一种通过向分析师建议潜在脆弱函数来加速手动代码审计过程的方法。我们的方法通过代码的结构模式外推已知漏洞，使高效地在大型代码库中找到类似缺陷成为可能。通过实证，我们在开源项目（包括 Pidgin 和 FFmpeg）中发现了真实的零日漏洞，展示了这一能力。

漏洞外推的概念与其他查找漏洞的方法正交，并可以直接应用于补充当前的代码审计工具。例如，如果通过模糊测试或符号执行发现了一个新的漏洞，可以将其外推到整个代码库，从而使类似的缺陷立即得到修补。这种外推提高了攻击者的门槛，因为他们需要继续寻找新的漏洞，一旦现有的漏洞被充分外推并且相关的漏洞在源代码中被修复。

### 参考文献

[1] T. Avgerinos, S. K. Cha, B. L. T. Hao, and D. Brumley. AEG: Automatic Exploit Generation. In Proc. of Network and Distributed System Security Symposium (NDSS), 2011.
[2] I. D. Baxter, A. Yahin, L. Moura, M. S. Anna, and L. Bier. Clone detection using abstract syntax trees. In Proc. of the International Conference on Software Maintenance (ICSM), 1998.
[3] S. Bellon, R. Koschke, I. C. Society, G. Antoniol, J. Krinke, I. C. Society, and E. Merlo. Comparison and evaluation of clone detection tools. IEEE Transactions on Software Engineering, 33:577–591, 2007.
[4] M. Cova, V. Felmetsger, G. Banks, and G. Vigna. Static detection of vulnerabilities in x86 executables. In Proc. of Annual Computer Security Applications Conference (ACSAC), pages 269–278, 2006.
[5] S. Deerwester, S. Dumais, G. Furnas, T. Landauer, and R. Harshman. Indexing by latent semantic analysis. Journal of the American Society for Information Science, 41(6):391–407, 1990.
[6] D. Engler, D. Y. Chen, S. Hallem, A. Chou, and B. Chelf. Bugs as deviant behavior: A general approach to inferring errors in systems code. In Proc. of ACM Symposium on Operating Systems Principles (SOSP), pages 57–72, 2001.
[7] N. Falliere, L. O. Murchu, , and E. Chien. W32.stuxnet dossier. Symantec Corporation, 2011.
[8] P. Godefroid, M. Y. Levin, and D. Molnar. SAGE: whitebox fuzzing for security testing. Communications of the ACM, 55(3):40–44, 2012.
[9] S. Heelan. Vulnerability detection systems: Think cyborg, not robot. IEEE Security & Privacy, 9(3):74–77, 2011.
[10] J. Hopcroft and J. Motwani, R. Ullmann. Introduction to Automata Theory, Languages, and Computation. Addison-Wesley, 2 edition, 2001.
[11] J. Jang, A. Agrawal, , and D. Brumley. ReDeBug: finding unpatched code clones in entire os distributions. In Proc. of IEEE Symposium on Security and Privacy, 2012.
[12] N. Jovanovic, C. Kruegel, and E. Kirda. Pixy: A static analysis tool for detecting web application vulnerabilities. In Proc. of IEEE Symposium on Security and Privacy, pages 6–263, 2006.
[13] T. Kamiya, S. Kusumoto, and K. Inoue. CCFinder: a multilinguistic token-based code clone detection system for large scale source code. IEEE Transactions on Software Engineering, pages 654–670, 2002.
[14] K. A. Kontogiannis, R. Demori, E. Merlo, M. Galler, and M. Bernstein. Pattern matching for clone and concept detection. Journal of Automated Software Engineering, 3:108, 1996.
[15] Z. Li and Y. Zhou. PR-Miner: automatically extracting implicit programming rules and detecting violations in large software code. In Proc. of European Software Engineering Conference (ESEC), pages 306–315, 2005.
[16] Z. Li, S. Lu, S. Myagmar, and Y. Zhou. Cp-miner: Finding copy-paste and related bugs in large-scale software code. IEEE Transactions on Software Engineering, 32:176–192, 2006.
[17] B. Livshits and T. Zimmermann. Dynamine: finding common error patterns by mining software revision histories. In Proc. of European Software Engineering Conference (ESEC), pages 296–305, 2005.
[18] V. B. Livshits and M. S. Lam. Finding security vulnerabilities in java applications with static analysis. In Proc. of USENIX Security Symposium, 2005.
[19] A. Marcus and J. I. Maletic. Identification of high-level concept clones in source code. In Proc. of International Conference on Automated Software Engineering (ASE), page 107, 2001.
[20] L. Moonen. Generating robust parsers using island grammars. In Proc. of Working Conference on Reverse Engineering (WCRE), pages 13–22, 2001.
[21] D. Moore, V. Paxson, S. Savage, C. Shannon, S. Staniford, and N. Weaver. Inside the Slammer worm. IEEE Security and Privacy, 1(4):33–39, 2003.
[22] J. Newsome and D. Song. Dynamic taint analysis for automatic detection, analysis, and signature generation of exploits on commodity software. In Proc. of Network and Distributed System Security Symposium (NDSS), 2005.
[23] T. Parr and R. Quong. ANTLR: A predicated-LL(k) parser generator. Software Practice and Experience, 25:789–810, 1995.
[24] rats. Rough auditing tool for security. Fortify Software Inc., https://www.fortify.com/ssa-elements/threat-intelligence/rats.html, visited April, 2012.
[25] G. Salton and M. J. McGill. Introduction to Modern Information Retrieval. McGraw-Hill, 1986.
[26] C. Shannon and D. Moore. The spread of the Witty worm. IEEE Security and Privacy, 2(4):46–50, 2004.
[27] M. Sutton, A. Greene, and P. Amini. Fuzzing: Brute Force Vulnerability Discovery. Addison-Wesley Professional, 2007.
[28] J. Viega, J. Bloch, Y. Kohno, and G. McGraw. ITS4: A static vulnerability scanner for C and C++ code. In Proc. of Annual Computer Security Applications Conference (ACSAC), pages 257–267, 2000.
[29] T. Wang, T. Wei, Z. Lin, and W. Zou. IntScope: Automatically detecting integer overflow vulnerability in x86 binary using symbolic execution. In Proc. of Network and Distributed System Security Symposium (NDSS), 2009.
[30] D. A. Wheeler. Flawfinder. http://www.dwheeler.com/flawfinder/, visited April, 2012.
[31] C. C. Williams and J. K. Hollingsworth. Automatic mining of source code repositories to improve bug finding techniques. IEEE Transactions on Software Engineering, 31:466–480, 2005.
[32] Y. Xie and A. Aiken. Static detection of security vulnerabilities in scripting languages. In Proc. of USENIX Security Symposium, 2006.
[33] F. Yamaguchi, F. Lindner, and K. Rieck. Vulnerability extrapolation: Assisted discovery of vulnerabilities using machine learning. In USENIX Workshop on Offensive Technologies (WOOT), Aug. 2011.

希望这些优化后的文本能更好地传达您的意图。如果有任何进一步的修改需求，请告诉我！