22.00 C is 71.60 F
向更实用的程序前进
TowardaMoreReal-World Example
让我们扩展这个例子，容许输入负数和可能出现的小数部分。这个问题的计算部分没问题
-Perl通常情况下不区分整数和浮点数。不过我们需要修改正则表达式，容许输入负数和
浮点数。我们添加一个-？来容许最前面的负数符号。实际上，我们可以用（-+]？来处理
开头的正负号。
要容许可能出现的小数部分，我们添加（\.[0-9]*）？1。转义的点号匹配小数点，所以
.[0-9]*用来匹配小数点和后面可能出现的数字。因为.[0-9]*被（)？所包围，整
个子表达式都不是匹配成果所必须的（请注意，它与2{0-9]*是截然不同的，对后一个
表达式中，即使.无法匹配，[0-9]*也能够匹配接下来的数字）。
把这些综合起来，就得到这样的条件判断语句：
if($celsius=~m/~[-+]？[0-9]+(\.[0-9]*)?s/）{
它能够匹配32、-3.723、+98.6这样的文字。不过还不够完善：它不能匹配以小数点开头
这并不是一个严重的问题。这个浮点数问题处理起来得靠些诀窍，我们会在第5章详细讲
解（194)。
成功匹配的副作用
Side Effects of a Successful Match
我们再进一步，让这个表达式能够匹配摄氏和华氏温度。我们让用户在温度的末尾加上C
或者F来表示。我们可以在正则表达式的末尾加上[CF]来匹配用户的输入，但还需要修
改程序的其他部分，以便识别用户输人的温度类型，并进行相应的转换。
在第1章，我们看到过某些版本的egrep支持作为元字符的1、\2、\3，用来保存前面
---
## Page 67
使用正则表达式匹配文本
41
的括号内的子表达式实际匹配的文本（21）。Perl和其他许多支持正则表达式的语言都支
持这些功能，而且匹配成功之后，在正则表达式之外的代码仍然能够引用这些匹配的文本。
我们会在下一章看到各种语言是如何做到这一点的（137），但是Perl的办法是通过变量
$1、$2、$3等等，它们指向第一组、第二组、第三组括号内的子表达式实际匹配的文本。
这未免有点奇怪，它们都是变量，而变量名则是数字。正则表达式匹配成功一次，Perl就会
设置一次。
总结一下，在尝试匹配时，正则表达式中的元字符1指向之前匹配的某些文本，匹配成
功之后，在接下来的程序中用$1来引用同样的文本。
为了保持例子的简洁，集中表现新的地方，我先不考虑小数部分，之后再来看它。所以，
我们来看$1，请比较：
$celsius=~m/~[-+]?[0-9]+[CF]S/
$ce1sius =~m/~(L-+]?[0-9]+)([CF]）S/
添加的括号改变了正则表达式的意义吗？为了回答这个问题，我们需要知道，这些括号是
否改变了星号或者其他量词的作用对象，或是1的意义。答案是，都没有改变，所以这个
表达式仍然能够匹配相同的文本。不过，他们确实围住了我们期望匹配字符串中“有价值”
文本的子表达式。如图2-1所示，$1保存那些数字，而$2保存C或者F。下一页的图2-2
是程序的流程图，我们发现，这个图让我们很容易地决定匹配之后应该干什么。
第二个括号
整个正则表达式
闭括号
$celsius=~m/~（[-+]?[0-9]+)([cF])$/
保存于$1
保存于s2
第一个括号
闭括号
图2-1：捕获型括号
---
## Page 68
42
第2章：入门示例拓展
读取
用正则
能匹配
从匹配结果获得
表达式验证
温度和类型信息
是否摄氏度
不
杏
配
摄氏温度
华氏温度
显示
错误信息
图2-2：温度转换程序的逻辑流程
示例2-1：温度转换程序
print “Enter atemperature（e.g.,32F,100c):\n";
Sinput=：#接收用户输入的一行文本
chomp($input);
#去掉文本末尾的换行符
if ($input =~ m/~([-+]?[0-9]+)([CF]）$/)
#如果程序运行到此，则已经匹配。S1保存数字，S2保存"C"或者"F”
SInputNum=Sl；#把数据保存到已命名变量中.
stype
=S2：#..保证程序清断易懂
if（Stypeeq"C"）.（#‘eq测试两个字符串是否相等
#输入为摄氏温度，则计算华氏温度
$celsius = $InputNum;
$fahrenheit=（$celsius*9/5）+32;
）else（
#如果不是"C"，则必然是"F”，计算摄氏温度
$fahrenheit = $InputNum;
$celsius =（$fahrenheit-32）*5/9;
#现在得到了两个温度值，显示结果：
printf "$.2f C is &.2f F\n",$celsius,$fahrenheit;
}else{
#如果最开始的正则表达式无法匹配，报警
print“so I don'tunderstand \"$input\".\n;
---
## Page 69
使用正则表达式匹配文本
43
如果上一页的程序名叫convert，我们可以这样使用：
perl -w convert
Enter a temperature （e.g.,32F,100c):
39F
3.89 C is 39.00 F
perl -w convert
Enter a temperature (e.g.,32F,100c):
39C
39.00 C is 102.20 F
$perl-wconvert
Enter a temperature (e.g.,32F, 100C):
sdoo
Expecting a number followed by "C" or "F",
so I don't understand "oops".
错综复杂的正则表达式
IntertwinedRegularExpressions
在Perl之类的高级语言中，正则表达式的使用与其他程序的逻辑是混合在一起的。为了说
明这一点，我们对这个程序做三点改进：像之前一样能够接收浮点数，容许f或者c是小
写，容许数字和字母之间存在空格。这三点全都完成之后，程序就能够接收‘98.6·f的
输入。
我们已经知道，添加（\.[0-9]*）？就能够处理浮点数：
if ($input =~m/~([-+]?[0-9]+{\.[0-9]*）?)([CF])$/)
请注意，它添加在第一个括号内部，因为我们用第一组括号内的子表达式来捕获温度的值，
我们当然希望它能够包含小数部分。不过，增加了这组括号之后，即使它只是用来分组问
号限定的对象，也会影响到引用捕获文本的变量。因为这组括号的开括号在整个表达式中
排在第二位（从左向右数），所以它匹配的文本存入$2（见图2-3）。
保存于s1
保存于s2
保存于s3
$input= m/^（[-+]?[0-9]+（\.[0-9]*)7）（[cF]
D$/
第1个开括号
第2个开括号
第3个开括号
图2-3：嵌套的括号
---
## Page 70
44
第2章：入门示例拓展
图2-3说明了括号的嵌套关系。在[CF]之前添加一组括号并不会直接影响整个正则表达式
的意义，但是会产生间接的影响，因为现在[CF]所在的括号排在第3位。这也意味着我
们需要把stype的赋值从s2改为$3（如果不希望这么做，可以参考下一页的补充内容）。
接下来，我们要处理数字和字每之间可能出现的空格。我们知道，正则表达式中的空格字
符正好对应匹配文本中的空格字符，所以*能够匹配任意数目的空格（但并不是必须出现
空格）：
if(Sinput =~ m/~([-+]？[0-9]+(\.[0-9]*)?)→([CF])$/)
但这样还不够灵活，而我们希望的是并发一个能够实际应用的程序，所以必须容许其他的
空白字符（whitespace）。例如常见的制表符（tabs）。但是*并不能匹配空格，所以我们
需要一个字符组来匹配两者（]*。
请把上面这个子表达式与（**）进行对比，你能发现这其中的巨大差异吗？请翻到下
-页查看答案。
本书中空格字符和制表符都很常见，因为我使用·和来表示它们。不幸的是，在屏幕上却
不是如此。如果你见到（1*，在没有实际测试过以前，只能猜测这是空格符还是制表符。
为了方便使用，Perl提供了\t这个元字符。它能够匹配制表符一一相比真正的制表符，它
的好处就在于看得更清楚，所以我会在正则表达式中采用这个元字符。于是（回]*变成
[\t]*1e
Perl还提供了一些简便的元字符，例如'\n（表示换行符），\f（ASClI的进纸符formfeed），
和b（退格符）。不过，确切地说，b在某些情况下是退格符，有些情况下又表示单词分
界符。它怎么能身兼数职呢？下一节我们会看到。
一点题外话一数量丰富的元字符
在前面的例子里我们见到了\n，但是\n都出现在字符串而不是正则表达式中。就像多数语
言一样，Perl的字将串也有自己的元字符，它们完全不同于正则表达式元字符。新程序员常
犯的错误就是混淆了这两个概念（VB.NET是个例外，因为其中字符串的元字符少得可怜）。
字符串的元字符中有一些跟正则表达式中对应的元字符一模一样。你可以在字符串中用t
加入制表符，也可以在正则表达式中用元字符t来匹配制表符。
---
## Page 71
使用正则表达式匹配文本
45
非捕获型括号（？：）
在图2-3中，我们用括号包围（\.[0-9]*）？来正确分组，所以我们能够用一个问号正
确地作用于整个\.[0-9]*，把它们作为可选项部分。这样的副作用就是这个括号内
的子表达式捕获的文本保存到S2中，而我们并不会使用S2。如果有这样一种括号，它
只能用于分组，而不会影响文本的捕获和变量的保存，问题就好办多了。
Perl以及近期出现的其他正则表达式流派提供了这个功能。（）用来分组和捕获，而
“（？：）；表示只分组不捕获。使用这个表示法，“开括号”是3个字母构成的序列（？：，
到第90页了解这个古怪的表示法的来历）。
所以，整个表达式变成：
if ($input =~m/~([-+]?[0-9]+ (?:\.[0-9]*)?)([CF])$/)
现在，即使【CF]两端的括号的确是排在第三位，它匹配的文本也会保存到S2中，因
为（？：…）不会影响捕获计数。
这样做的好处有两点。第一是避免了不必要的捕获操作，提高了匹配效率（我们会在
第6章详细讨论效率问题）。另一个好处是，总的来说，根据情况选择合适的括号能够
让程序更清晰，看代码的人不会被括号的具体细节所困扰。
另一方面，（？：）表示法确实不够美现，或者说它会增加整个表达式的阅读难度。它
带来的好处能够抵消这些问题吗？我个人喜欢根据需要选择合适的括号，但是在本例
中，或许不值得这样麻烦。如果匹配只需要进行一次（而不需要在循环中多次匹配），
效率并不重要。
在本章中，我全部采用（），即使不需要捕获文本时也是如此，因为这样看起来更清
楚。
这种相似性无疑方便了使用，但是我必须强调区分这两种元字符的重要性。对于t这样简
单的情况来说或许并不重要，但对于我们将要看到的各种不同的语言和工具来说，知道在
什么情况下应该使用什幺元字符是极其重要的。
款
---
## Page 72
46
第2章：入门示例拓展
测验答案
44页问题的答案
[]*和（*）的异同
（**）容许*或*的匹配，它能够匹配若干空格符（也可以没有）以及若干
制表符（也可以没有），不过并不容许制表符和空格符的混合体。
相反，[]*能够匹配任意多个。对于字符串国，它可以匹配3次，第一次是
制表符，后两次是空格符。
在逻辑上，（]*与（·）*是等价的，尽管因为第4章将会解释其原因，字符组的
效率通常还是会高一点。
我们已经见过不同的字符组之间的冲突。在第1章，使用egrep时，我们把正则表达式包含
在单引号中。整个egrep命令行写在command-shell提示符，shell能够认出它自己的元字符。
例如，对shell来说，空格符就是一个元字符，它用来分隔命令和参数，或者参数与参数。
在许多shell中，单引号是元字符，单引号内的字符串中的字符不需要被当作元字符处理（DOS
使用双引号）。
在shell中使用引|号容许我们在正则表达式中使用空格。否则，shell会把空格认作参数之间
的分隔符，而不是把整个正则表达式传递给egrep。许多shell能够识别的元字符包括s、*、？
之类一一我们在正则表达式中也会用到这些元字符。
目前，所有关于shell的元字符和Perl字符申的元字符的讨论都还与正则表达式本身没有任
何关联，但它们会影响到现实环境中正则表达式的使用。随着阅读的深入，我们会见到许
多（有时候还很复杂）情况，我们需要同时在不同层级上使用元字符交互（multiplelevelsof
simultaneouslyinteractingmetacharacters)。
一个单词分界符的，但是在字符组中，它匹配一个退格符。单词分界符作为字符组的一部
分则没有任何意义，所以Perl完全可以用它来匹配其他的字符。第1章曾提醒我们，字符
组“子语言”的规范不同于正则表达式主体，这条规则也适用于Perl（包括任何其他流派的
正则表达式）。
---
## Page 73
使用正则表达式匹配文本
47
用\s匹配所有“空白”
讨论空白的问题时，我们最后使用的是t]*1。这样做没问题，但许多流派的正则表达
式提供了一种方便的办法：\s。\s看起来类似'\t，\t代表制表符，而s则能表示所有
表示“空白字符（whitespacecharacter）”的字符组，其中包括空格符、制表符、换行符和回
车符。在我们的例子中，换行符和回车符并不需要特别考虑，但是\s*显然比（t]*要
简洁。而且不久你就会习惯这种表示法，在复杂的表达式中，s*更加易于理解。
现在我们的程序变成：
$input=~m/~([-+]?[0-9]+(\.[0-9]*）?)s*([CF]）S/