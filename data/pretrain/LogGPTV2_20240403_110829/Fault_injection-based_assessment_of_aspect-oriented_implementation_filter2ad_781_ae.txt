# 
Trace 
(#instr) 
% 
# 
473 
676 
2412 
1049 
425 
580 
708 
524 
0% 
79% 
347% 
106% 
0% 
33% 
71% 
25% 
3880 
6960 
17336 
8000 
3728 
4952 
6368 
4664 
Low optimization 
    No fault tolerance 
     C 
     AspectC++Ext 
     AspectC++Opt 
High optimization 
    No fault tolerance 
    C 
    AspectC++Ext 
    AspectC++Opt 
redundancy  implementation,  it  has  slightly  higher  time 
overhead  although  both  types  of  memory  consumption  are 
still lower.  
0% 
317% 
1051% 
440% 
0% 
285% 
777% 
297% 
0% 
43% 
410% 
122% 
0% 
36% 
67% 
23% 
635 
2647 
7312 
3428 
245 
943 
2149 
973 
the  high 
This would lead us to assume that AspectC++Opt would 
cause  less  overhead  than  C  for  the  pure  control  flow 
checking  mechanism  when  using 
level  of 
optimization.  As  can  be  seen  in  Table  X,  this  is  also  the 
case. However, AspectC++Ext also causes less time overhead 
than C. This was not observed in the earlier study since the 
low overhead for this  mechanism  was  masked by the  very 
large  overhead  for  the  time  redundancy  mechanism.  The 
reason  behind  the  differences  in  overhead  for  the  two 
mechanisms is the type of advices used when implementing 
them. The DS-CFC mechanism can be written with before- 
and  after-advices  which  for  both  versions  of  AspectC++ 
produce very effective code when combined with compiler 
optimization. The time redundancy mechanism, on the other 
hand,  requires  around-advices  that  cause  large  overhead 
with  AspectC++Ext.  Another  detail  in  Table  X  worth 
mentioning  is  that  the  C  and  AspectC++Opt  give  negative 
dynamic memory overhead with the high level of compiler 
optimization.  The  reason  is  that  the  fault-tolerant  variants 
have  lower  stack  usage  compared  to  the  implementation 
without fault tolerance.    
TABLE X.  
OVERHEAD FOR THE DS-CFC MECHANISM 
Low optimization 
     No fault tolerance 
     C 
     AspectC++Ext 
     AspectC++Opt 
High optimization 
     No fault tolerance 
     C 
     AspectC++Ext 
     AspectC++Opt 
Code 
(byte) 
# 
% 
Data 
(byte) 
#  % 
Trace 
(#instr) 
# 
% 
3880 
4592 
7112 
6944 
3728 
3904 
5328 
6688 
0% 
18% 
83% 
79% 
0% 
5% 
43% 
79% 
473 
520 
686 
622 
425 
416 
462 
406 
0% 
10% 
45% 
32% 
0% 
-2% 
9% 
-4% 
635 
1150 
1326 
1293 
245 
424 
391 
385 
0% 
81% 
109% 
104% 
0% 
73% 
60% 
57% 
Apart  from  our  earlier  work  few  publications  exist  on 
using aspect-oriented languages for fault tolerance purposes.  
Most related is the  work done by  Afonso et al. [17]. They 
evaluate  the  performance  impact  of  using  AspectC++  for 
implementing  fault  tolerance.  This  is  done  by  applying 
thread-level recovery blocks to a target application. A recent 
work by Hameed et al. [18] applies AOP for software fault 
tolerance. AOP has also been discussed for some time in the 
area  of  distributed  fault  tolerance.  Fabry  [19]  defines 
custom-built AOP languages and uses them for a transparent 
reusable  distributed  replication  framework.  Herrero  et  al. 
[20]  define  an  AOP  language  specifically  designed  for 
writing  object  replication  policies.  In  [21]  AOP  is  used  to 
move some functionality from the FT-CORBA middleware 
to  the  application  while  still  retaining  transparency  to  the 
application  programmer.  However,  none  of  these  studies 
include  fault  injection  experiments  for  evaluating  the 
techniques.  
VII.  CONCLUSION 
two  software-based  fault 
We  have  presented  an  experimental  study  where  the 
fault  coverage  of 
tolerance 
mechanisms  has  been  estimated  by  fault  injection.    There 
are three goals of this study.  The first one is to evaluate the 
fault  coverage  provided  by 
tolerance 
mechanisms.  The second goal is to investigate the impact of 
compiler  optimization  on  fault  coverage.  The  third  goal, 
which also is our primary goal, is to assess the feasibility of 
using  aspect-oriented  programming  for  implementation  of 
software-based fault tolerance. 
two  fault 
the 
Concerning  the  evaluation  of  the  two  mechanisms,  the 
results  show  that  both  achieved  a  substantial  improvement 
in  fault  coverage  compared  to  that  obtained  without  any 
software  mechanisms.  The  total  coverage  obtained  when 
using  the  DS-CFC  mechanism  varied  between  88%  and 
95%  for  the  evaluated  programs.  The  TTR-FR  mechanism 
achieved a total coverage of 93% to 96% for most programs. 
Concerning  the  impact  of  compiler  optimization,  our 
experiments showed that the fault coverage of the hardware 
exceptions  was  drastically  lower  for  optimized  programs 
compared to that obtained by the non-optimized programs.  
The difference in coverage was in average 8.1 %. This was 
largely  compensated  by  higher  fault  coverage  for  the 
software mechanisms, or a higher proportion of errors with 
no effect, for the optimized programs.  
However,  a  small  but  consistent  reduction  in  fault 
coverage  remained  for  the  optimized  programs  using  the 
DS-CFC  and  TTR-FR  mechanisms.  This  reduction  was  in 
average 2.4 percentage points.  
While the optimized programs using DS-CFC and TTR-
FR  showed  lower  fault  coverage  than  their  non-optimized 
counterparts,  one  should  bear  in  mind  that  the  optimized 
programs are smaller and therefore have a lower exposure to 
faults. That is, their fault rate is lower than that of the non-
Authorized licensed use limited to: Tsinghua University. Downloaded on March 18,2021 at 14:29:31 UTC from IEEE Xplore.  Restrictions apply. 
313for 
optimized  programs.  Thus,  we  cannot  draw  the  conclusion 
that  compiler  optimizations  will  lead  to  lower  system 
reliability.  
implementing 
software-based 
With  respect  to  the  feasibility  of  using  aspect-oriented 
programming 
fault 
tolerance mechanisms, the results showed that the difference 
in fault coverage is small between programs implemented in 
C  and  those  produced  by  the  AspectC++  weavers.  The 
average  difference  across  all  program  variants  is  less  than 
1%  with  a  small  advantage  for  the  AspectC++  programs. 
We  did  not  observe  any  significant  differences  in  fault 
coverage between programs produced by AspectC++Ext and 
those  produced  with  AspectC++Opt.  Concerning  execution 
time overhead, the results show that AspectC++Opt programs 
in  general  has  much  lower  time  overhead  than  programs 
produced  with  AspectC++Ext.  The  differences  in  time 
overhead  for  programs  implemented  in  C  and  those 
implemented  in  AspectC++Opt  are  in  general  small  when 
compiler optimizations are used. 
 In summary, we found no major disadvantages of using 
aspect-oriented  programming  for  the  implementation  of 
software-based  fault  tolerance.  For  our  future  work,  we 
would  like  to  improve  the  confidence  in  our  findings  by 
extending 
to  more  application  programs, 
additional  fault  tolerance  mechanisms,  and  to  other  faults 
models. 
the  study 
ACKNOWLEDGEMENTS 
We  extend  our  sincere  thanks  to  our  colleagues  Daniel 
Skarin  and  Raul  Barbosa  for  having  designed  and 
implemented the GOOFI-2 tool. This work would not have 
been  possible  to  carry  out  without  this  excellent  tool.  We 
also  thank  Volvo  Technology  and  Martin  Sanfridson  for 
providing the brake-by-wire application. 
This  research  was  conducted  within  the  CEDES  (Cost 
Efficient Dependable Electronic Systems) project, which is 
funded  by  IVSS  –  Intelligent  Vehicle  Safety  Systems  -  a 
Swedish industry and government joint research program.  
REFERENCES 
[1]  Borkar,  S.:  Designing  reliable  systems  from  unreliable  components: 
The challenges of transistor variability and degradation. IEEE Micro, 
vol.25, no.6, pp. 10-16, Nov.-Dec., 2005. 
[2]  Reick,  K.,  Sanda,  P.N.,  Swaney,  S.,  Kellington,  J.W.,  Mack,  M.J., 
Floyd,  M.S.,  Henderson,  D.:  Fault-Tolerant  Design  of  the  IBM 
Power6 Microprocessor. IEEE Micro, vol.28, no.2, pp.30-38, March-
April, 2008. 
[3]  Oh,  N.,  Shirvani,  P.,  McCluskey,  E.  J.:  Control-Flow  Checking  by 
Software Signatures, Center for Reliable Computing, Stanford Univ., 
CA, CRC-TR-00-4 (CSL TR num 00-800), 2000. 
[4]  Aidemark,  J.,  Vinter,  J.,  Folkesson,  P.,  Karlsson,  J.:  Experimental 
for  a  brake-by-wire 
time-redundant  execution 
evaluation  of 
application.  International  Conference  on  Dependable  Systems  and 
Networks (DSN 2002), 2002. 
Tolerance. Proc. 9th  Int'l Symposium on Fault‐Tolerant Computing, 
pp. 102‐105, June, 1979. 
[5]  Andrews,  D.:  Using  Executable  Assertions  for  Testing  and  Fault 
[6]  Huang,  K.-H.,  Abraham,  J.A.:  Algorithm-based  fault  tolerance  for 
matrix operations. IEEE Trans. Computers, 1984. 
[7]  Wappler,  U.,  Fetzer,  C.:  Software  encoded  processing:  Building 
dependable  systems  with  commodity  hardware.  In  The  26th 
International  Conference  on  Computer  Safety,  Reliability  and 
Security (SafeComp 2007), 2007. 
[8]  Benso,  A.,  Chiusano,  S.,  Prinetto,  P.,  Tagliaferro,  L.:  A  C/C++ 
SourcetoSource Compiler for Dependable Applications. International 
Conference on Dependable Systems and Networks (DSN 2000), June, 
2000. 
[9]  A. Li and B. Hong, “Software implemented transient fault detection 
in  space  computer”,  Aerospace  Science  and  Technology,  11  (2-3): 
245-252, 2007. 
[10]  Elrad,  T.,  Filman,  R.E.,  Bader,  A.:  Aspect-oriented  programming: 
introduction. Communications of the ACM, 44(10) (2001) 29-32 
[11]  Alexandersson, R., Öhman, P.: Implementing Fault Tolerance Using 
Aspect  Oriented  Programming.  In  proceedings  of  the  3rd  Latin-
American  Symposium  on  Dependable  Computing  (LADC  2007), 
Morelia, Mexico, 2007.  
[12]  Spinczyk,  O.,  Gal,  A.,  Schröder-Preikschat,  W.:  AspectC++:  An 
Aspect-Oriented Extension to C++. In: 40th International Conference 
on Technology of Object-Oriented Languages and Systems (TOOLS 
Pacific 2002), Sydney, Australia, pp. 18-21, 2002. 
[13]  Alexandersson, R., Öhman, P.: On Hardware Resource Consumption 
for  Aspect-Oriented  Implementation  of  Fault  Tolerance.  In:  8th 
European Dependable Computing Conference, Valencia, Spain, April 
28-30, 2010. 
[14]  Skarin,  D.,Barbosa,  R.,  Karlsson,  J.,  “GOOFI-2:  A 
tool  for 
experimental  dependability  assessment,”  in  Proceedings  of  the  40th 
Annual IEEE/IFIP International Conference on Dependable Systems 
and Networks (DSN 2010), Jun./Jul., 2010. 
[15]  Barbosa,  R.,  Vinter,  J.,  Folkesson,  P.,  Karlsson,  J.,”Assembly-level 
pre-injection  analysis  for  improving  fault  injection  efficiency,”  in 
Proc. Fifth European Dependable Computing Conference, Budapest, 
Hungary, 2005. 
[16]  Skarin,  D.,  Karlsson,  J.,  “Software  Implemented  Detection  and 
Recovery  of  Soft  Errors  in  a  Brake  by  Wire  System,”  in  Seventh 
European  Dependable  Computing  Conference  (EDCC-7),  pp.  145-
154, 2008. 
[17]  Afonso, F., Silva, C., Brito, N., Montenegro, S.,  Tavares, A.: Aspect-
Oriented  Fault  Tolerance  for  Real-Time  Embedded  Systems.  In: 
ACP4IS '08: 7th workshop on Aspects, components, and patterns for 
infrastructure software, 2008. 
[18]  Hameed, K., Williams, R., Smith. J.: Aspect Oriented Software Fault 
Tolerance. Proceedings of the World Congress on Engineering 2009 
Vol I WCE 2009, London, U.K., July 1 - 3, 2009. 
[19]  Fabry,  J.:  A  Framework  for  Replication  of  Objects  using  Aspect-
Oriented Programming. Phd Thesis, University of Brussel, 1998.  
[20]  Herrero,  J.L.,  Sanchez,  F.,  Toro,  M.:  Fault  tolerance  as  an  aspect 
using  JReplica.  In  Proceedings  of  the  Eighth  IEEE  Workshop  on 
Future  trends  of  Distributed  Computing  Systems,    pp.  201-207,  31 
Oct.-2 Nov, 2001. 
[21]  Szentivanyi,  D.,  Nadjm-Tehrani,  S.:  Aspects  for  improvement  of 
performance  in  fault-tolerant  software  In  Proceedings  of  the  10th 
IEEE  Pacific  Rim 
International  Symposium  on  Dependable 
Computing, pp. 283-291, 3-5 March, 2004. 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 18,2021 at 14:29:31 UTC from IEEE Xplore.  Restrictions apply. 
314