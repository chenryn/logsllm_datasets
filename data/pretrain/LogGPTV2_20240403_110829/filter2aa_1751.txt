#BHUSA @BlackHatEvents
ELF Section Docking
Revisiting Stageless Payload Delivery
Dimitry Snezhkov, 
X-Force, IBM Corporation
#BHUSA @BlackHatEvents
Information Classification: General
Who -m
Dimitry Snezhkov, X-Force, IBM Corporation
• Research (Offense / Defense)
• Tooling Support
#BHUSA @BlackHatEvents
Information Classification: General
Goals
• Overview of static payload bundling mechanisms in Linux.
• Evolution of static payload embedding. 
• Improving viability of static payloads in delivery.
• Binary compatibility of ELF sections as a unit of payload.
• ELF section docking: Payload attachment factory at adversarial sites.
• Detection, evasion successes and pitfalls of the docking approach
• ELFPack PoC demo
#BHUSA @BlackHatEvents
Information Classification: General
Payload Delivery 
Dynamic
Static
•
Generated at runtime
•
Fetched at runtime from external (to loader) source
+ Light(er) loader
+ Less chance of detection due to absence of embedded 
payload
+ More flexibility 
- More chance of detection with use
- More exposed loading mechanism 
- More moving parts
- More detonation dependencies (environment). 
- Long haul activation / dormancy  issues.
• Bundled with delivery mechanisms
• Time-released 
+ Less chances of detection due to close coupled 
variance
+ Less detonation dependencies (environment)
+ Less moving parts 
+ Better activation / dormancy once deployed
- Heavier close coupled loader, greater size
- More chance of detection due to embedded payload
- Less flexibility (runtime awareness and variance)
Iit’s a dial  … 
#BHUSA @BlackHatEvents
Information Classification: General
Payload Delivery
Dynamic
Static
•
Empirically, more prevalent (short and long haul):
1.
Deploy stager
2.
Fetch payload
3.
Load payload (maybe, on itself)
4.
Maybe delete stager
• Empirically, less widespread in long haul implants
• Time-released 
1.
Deploy the bundle (maybe, on itself)
Can we improve Static delivery  
Dynamic is well understood
#BHUSA @BlackHatEvents
Information Classification: General
Payload Delivery Tradeoffs
Desired Dynamic Traits
Undesired Static traits
+ Less chance of detection due to 
absence of embedded payload
+ More flexibility 
- Heavier close coupled loader, greater size
- More chance of detection due to embedded 
payload
- Less flexibility (runtime awareness and variance)
• Why is static out of favor
• Can its traits be improved 
• Can we turn downsides into an upside 
#BHUSA @BlackHatEvents
Information Classification: General
How We Embed
Hex-binary inclusion compilation and linking: Directly in default .data section via compiler
Manually or with tools like bin2c or
xxd -i payload.bin > payload.h
Easily traced at runtime debugging or static binary inspection
#BHUSA @BlackHatEvents
Information Classification: General
How We Embed
Hex-binary inclusion compilation and linking: In a separate ELF section. 
• Place payload data or certain 
variables in additional sections.
• Achieved with a compiler 
dependent mechanism. In gcc, it's 
done via __attribute__'s.
Can be traced at runtime debugging or static binary inspection. 
#BHUSA @BlackHatEvents
Information Classification: General
How We Embed
Linker-binary inclusion: Assembler and linker specific directives.
Assembler dependent .incbin-like directive 
can create a section and embed a payload. 
Tools:
• gcc -c payload.s
or
• ld -r -b payload.bin -o payload.o
Note: fully functional payload file. Path to 
create “fat” binaries for packing.
Retrieval in code can be done as follows:
#BHUSA @BlackHatEvents
Information Classification: General
How We Embed
Linker-binary inclusion: Assembler and linker specific directives (Cont.)
More ergonomic tools exist
•
INCBIN from @graphitemaster, same 
idea.
In-code solution to construct multi-sectional 
ELF payload may be as follows:
Note PROGBITS directive, will be important.
#BHUSA @BlackHatEvents
Information Classification: General
How We (Better) Embed
Compiler / linker-based payload are not ideal.
The process of embedding in code is tightly coupled to the creation of payload loader.
• Challenges with payload format changes
• By default, data carrying section have PROGBITS flags set on it, and it will be PT_LOAD’ed into memory 
by the OS loader by default. 
We do not want this (Linking è Detection)
There are tradeoffs
#BHUSA @BlackHatEvents
Information Classification: General
How We (Better) Embed
ELF sections and load flags
Type of section and flags set on the new 
section determine whether OS loader 
loads it in the memory upon executable 
launch. 
Some sections are loaded automatically 
by default, others are not.
Offense can take advantage of that!
#BHUSA @BlackHatEvents
Information Classification: General
How We (Better) Embed: Take 2
Avoiding default OS loader actions
We can:
• Avoid setting flags on sections that assume default loading in memory.
• Use a different type of section that does not load in memory.
• As an example – SHT_NOTE type, from ELF docs:
#BHUSA @BlackHatEvents
Information Classification: General
How We (Better) Embed: Take 2
=
SHT_NOTE is widely used in Linux system binaries:
Avoiding default OS loader actions
#BHUSA @BlackHatEvents
Information Classification: General
ELF Section Docking
Compiler is a problem: Decoupling payloads 
So far, we have:
• Created a dormant section in ELF image (in code)
• Avoided loading it in memory by the OS loader. 
However:
• Section çè structure of the
final ELF
• Tight relationships of memory 
addresses from the loader code 
#BHUSA @BlackHatEvents
Information Classification: General
ELF Section Docking
Compiler is a problem: Decoupling payloads 
What if we:
• Create an ELF section with embedded payload outside of the loader compilation workflow 
• Attach that section to a loader binary later
This would:
•
Break the address offset relationship of the loader code with the section. 
•
Teach the loader how to find and load its foreign data section, effectively "docking" a 
standalone payload to a loader in a loosely coupled manner.
#BHUSA @BlackHatEvents
Information Classification: General
ELF Section Docking
Compiler is a problem: Decoupling payloads, Avoiding OS loader 
• Loader should not be entangled with payload semantics
• Loading and executing binary payload without modifying loader code to tailor to new payloads via binary 
section compatibility.
• Loading without using OS loader ld.so (ELF loader) which is loading payload in memory automatically.
Achieves ABI compatible
In-field payload 
(re-)attachment.
#BHUSA @BlackHatEvents
Information Classification: General
ELF Section Docking
Binary Compatibility at Section level
• Injector/bundler which will introduce 
a payload section to the loader 
without either one operating at code 
level, only binary compatibility
• Loader is aware how to 
load a payload section but not what 
the payload is.
#BHUSA @BlackHatEvents
Information Classification: General
ELF Section Docking
Possible Wins
Static Elf loader:
• Shipped on its own
• Devoid of payloads
• Only  mechanisms to load a section on demand and 
bootstrap the payload from it.
Sectional Payload:
• Created separately
• Bundled with loader at any time as a static stage
• Better dormancy control with an injector. 
• Better packing. No overhead on detection for conventional packer processing and code. 
In memory – not tmpfs for unpacks. Fat binaries possible (multiple sections).
• Be a full ELF executable itself if needed
Injector can broker attachment of sections from several binaries (dormant stages) to construct a 
section and inject into the loader.
#BHUSA @BlackHatEvents
Information Classification: General
ELFPack
Sectional ELF Injector/Packer:
• Streamlined payload generation pipeline
• In field payload to loader attachment without compiler
Sectional ELF Loader:
• Loads full ELFs or shellcode from reading and parsing its own binary. 
Tracing does not see mprotect()’s on mapping into memory and loading
• Airgapped separation between where the payload is and how it’s loaded.
• Ability to accept and forward arguments to sectional payloads 
Binary payload in section
• Can be a fully functional ELF binary with much less constraints (3rd party tooling, linking intact).
• Can be uniquely obfuscated without regard to space (.NOTE records are variable size for example)
• Can be memory-resident or extracted to FS or run as part of a table of contents (fat payload loader).
• Does not need to be relocated when preparing for execution.
• Cross-attachment binary evasion chain: Loader A can read Loader B’s payload.
#BHUSA @BlackHatEvents
Information Classification: General
ELFPack – Loader
Option A : SYS_Memfd_create ()
- Done with libreflect but may be done with Zombieant pre-loader
- More detectable at levels:
- anonymous file in /proc/self/fd/
- uses sys_memfd_create ( syscall #319 ) 
- Does fork/exec, BPF tracing for execve() will record.
Option B: User land Exec (https://grugq.github.io/docs/ul_exec.txt)
- Done with libreflect for now. Nice interface.
- Hollows out the loader and overlays with payload.
- No sys_enter_exec /sys_exit_exec calls. BPF tracing for execve() not catching
- Downside: you cannot daemonize via loader (loader memory is gone on exec image overlay)
but the payload can daemonize itself when launches:
the beauty of shipping ELF binaries vs. shipping shellcode J
#BHUSA @BlackHatEvents
Information Classification: General
ELFPack: Detect: Binwalk
Raw Payload 
(mettle)
Sectioned Payload 
(mettle)
#BHUSA @BlackHatEvents
Information Classification: General
ELFPack: Detect: Biwalk: Entropy
Raw Payload 
(mettle)
Sectioned Payload 
(mettle)
#BHUSA @BlackHatEvents
Information Classification: General
ELFPack: Detect: BPF + YARA
Tracepoints -> syscalls:
Sys_enter_memfd_open
Sys_exit_memfd_open
Sys_enter_exec*
YARA static scan ELF
More detection and evasion
BPF filter based
#BHUSA @BlackHatEvents
Information Classification: General
ELFPack Demo
#BHUSA @BlackHatEvents
Information Classification: General
Summary
• Section docking presents desired features for payload delivery
• Static vs. dynamic payload loading is a dial not an either or.
• Overcome limitations of packers for in-memory unwrap and detection
• Detect ELF packing at runtime and static. 
• Overcome detections with packing and encryption.
#BHUSA @BlackHatEvents
Information Classification: General
Q&A?
Code: https://github.com/xforcered/elfpack
Thanks!