version code with our dataset but had a more recent last update
date. We excluded these APKs. In the end, we ended up with 103,841
APKs that had same version code and same update date.
3.2 Extracting Abandoned Internet Resource
Our next task was to check whether the 103,841 APKs contained
abandoned Internet resources that could be hijacked. To this end, we
developed a tool using the Androguard framework [4] to decompile
and extract from the APKs all hardcoded URL. We note that the
static analysis suffered from certain limitations. We will discuss
this issue in Sections 4.5 and 6.2.
In many the cases, we could infer the kind of services that run on
top of the resource by looking at the URL. For example, a URL like
http://foo.test/rssFeed is an RSS source. We also extracted
the line of code, function name, class name, and package name of
the class that contained the URL. We excluded schema URI such as
http://schemas.android.com/apk/res/android. We were also
aware that the developer in certain instances obfuscated the code
before publishing the app. We filtered those out as obfuscated code
is usually indication of a malicious app, whereas our focus was on
legitimate apps that had abandoned Internet resource.
We continued with extracting the hostname from URLs. If the
hostname part was an FQDN, then we extracted its effective 2LD
(e2LD) by using the Public Suffix List [15]. In cases where the
hostname part was an IP address we left as is. From the distinct
domain, we searched for abandoned Internet resources using the
following methods:
Expired Domain. By sending a WHOIS query, we checked whether
a domain expired or was deleted. Then, we checked whether the
domain was available for purchase through GoDaddy Domain Avail-
ability API [11].
Parked Domain. To determine whether a domain was a parked
domain, we used the same technique as in [38]. Technically, when
the owner of a domain wants to convert the domain into a parked
domain, the domain is configured in a manner defined by the do-
main parking service (e.g., the domain’s Name Server (NS) is made
to point to the domain parking service’s NS). Vissers et al. studied
15 popular domain parking services and provided known NS record
configuration for each service [38]. We followed the provided in-
formation to search for parked domain names.
Dangling Records (Dare). We used the same methodology as
Liu et al. [30] to search for IP addresses in Cloud Dare. We first
determined whether a domain pointed to an IP address in EC2 [7]
or Azure [13] and scanned the IP address. When performing a
port scanning to the IP address of the domain, we prioritized the
 Session 4: Mobile ASIACCS’18, June 4–8, 2018, Incheon, Republic of Korea150Figure 5: Categorizing Resource into Third-Party Library
Domain.
custom port numbers found in the URL. Otherwise, we assumed
that the app contacts the server by using the standard HTTP Port
80 or HTTPS Port 443. We scanned those ports to confirm whether
the host was alive. The only difference between our method and
Liu’s was performing a second scanning two weeks after the first
scanning. In our research, we only focused on dangling records
associated with EC2 or Azure.
As for any hardcoded IP address found in the URL, we check
whether it fell within the EC2 or Azure IP address range. If so, we
performed the same scanning methodology used to search dangling
records.
3.3 Classifying The Resources
In order to understand the widespread potential of hijacking re-
sources, we classified resources into one of the three categories:
private service, third-party library, and third-party service. Figure 5
illustrates how we determined whether a resource was used by a
third-party library. By leveraging LibRadar [31], we were able to
extract information on the third-party library used by a particu-
lar APK. LibRadar provided information on the package name of
the third-party even when obfuscated. We compared the package
name of the resource found by our tool with the package name
in LibRadar; if they matched, then the resource was deemed to be
used by the third-party library.
For classifying domains into private service or third-party ser-
vice, we relied on several heuristics as illustrated in Figure 6.
Step 1: If a resource was used by several APKs, then we checked
whether the APKs had the same base package name and was pub-
lished by the same developer by looking at the developer informa-
tion from the crawling Google Play page.
Step 2: We continued checking whether the resource was found
inside the base main package.
Step 3: If it matched and the resource was a domain, then we
checked whether the domain resembled the package name or de-
veloper name by using Fuzzy String Matching provided by [10].
This library employs Levenshtein Distance to calculate the distance
between two strings.
Figure 6: Categorizing Resource into Private Service Do-
main.
We are also aware of the case where the domain did not resemble
the package name. In these instances, we checked not only the do-
main but also the URL. For the most part, we were able to find parts
of the URL that resembled the domain and package name/developer
name. In one case, we found several APKs (e.g., appinventor.foo.
x, appinventor.abc.yzx, appinventor.lll.mnl ) that used the
same domain (e.g., foo.test), and were developed by the same
developer (MMDeveloper); however, only one APK had the base
package name that resembled the domain name (appinventor.foo.
x and foo.test). In this case, we categorized it as a private service.
It appears that at the beginning the developer bought this domain
to support the functionality of this one particular APK, however
after that they use this domain to support the other APKs. Once
all these criteria are fulfilled we can certain that this domain was
previously managed by the developer of the APKs.
For the remaining domains, which did not meet the prescribed
criteria, we suspected that they were third-party services. Again,
we relied on several heuristics as provided in Figure 7:
Step 1: If the domain was used by more than 1 APK, but the APKs
did not have same base package name, we searched the APKs to
determine whether they used it in the main package. Knowing that
the domain was not a private service domain (because the domain
name did not resemble a package name or developer name), then
we assumed that the domain was likely a third-party service.
Step 2: We also checked the URL to help determine what kind of
service ran on top this domain (http://www.foo.test/rssFeed,
http://example.com/service.asmx?WSDL, http://example.org/
wp-content, etc).
Step 3: If the subdomain of a domain in use is www, then most
likely it was a website for which certain information or certain
features were used by the apps crawl. We consulted archive.org
to confirm this.
For domains that could not be classified using this method, we
had to classify them manually by conducting a Google search or
doing a manual code inspection. This method also failed with
  Session 4: Mobile ASIACCS’18, June 4–8, 2018, Incheon, Republic of Korea151Table 2: Abandoned Internet Resource Category.
Type of Resource
Expired Domains
Parked Domains
Dares in EC2
Dares in Azure
Obtainable IP Address in EC2
Total
Private 3rd Party 3rd Party Unknown
Service
1,436
158
113
19
41
1,767
Service
1,271
265
56
14
29
1,635
Lib
51
15
25
2
7
100
80
20
5
21
0
126
of our results. We then describe the characteristic of the resource
with respect to the three major models. We also present the impact
of the found abandoned Internet resources as well as findings on
bogus domains. Finally, we discuss the threats to validity.
4.1 Abandoned Internet Resource in the Wild
Table 1 presents the number of abandoned Internet resources, which
were found inside our dataset of Android apps. In total, we found
3,628 hijack-able abandoned Internet resources contained in 7,104
APKs. While this number is smaller than the total number of APKs
reported in the table, there are many APKs that use more than one
type of resource in their code.
Based on the numbers, it is evident that the expired domain
types are the most prevalent abandoned Internet resource found in
mobile apps. Under the expired domain number, we included 350
domains (connected to 662 APKs) that have past the expiration date
and is now in the Redemption Grace Period (RGP), after which it is
available to the public for purchase. With respect to parked domains,
the number of APKs using these domain are 3.5 times higher than
the number of domains. It explains why these are parked domains
as they are high traffic domains used by mobile apps.
The number of Dares in EC2 and Azure with its correspond-
ing APKs are almost equal because most of Dares are used by
one APK. Given that a host in EC2 is automatically assigned a do-
main name with ec2-ip.compute-1.amazonaws.com format, we
found that there are a lot of domains in this form which was found
among Dare in EC2. Regarding Dare in Azure, number of APKs is
greater (55 APKs) than number of Dare found (56 Dares). This is
due to the existence of an APK which uses 2 Dare domains in its
code, the domains are analytics.tapcontext.com and register.
tapcontext.com.
We also found several hardcoded IP addresses in EC2. Based
on scan results, we concluded that the IP addresses were vacant,
hence obtainable. There was a huge gap between the number of
APKs using hardcoded IP addresses and the number of IP addresses
itself. This is due to the presence of 1 IP address which is found
inside push notification library and is used by more than 1,000
APKs, detailed analysis on this will be discussed on the next section.
While there were found hardcoded IP address in EC2 cloud, we did
not find any hardcoded IP address in Azure range.
Figure 7: Categorizing Resource into Third-Party Service Do-
main.
Table 1: Abandoned Internet Resource in the Wild. In total,
468 resources are used by more than one APK.
Type of Resource
Expired Domains
Parked Domains
Dares in EC2
Dares in Azure
Obtainable IP Addresses in EC2
Total
# of Resources
2,838
458
199
56
77
3,628
# of APKs
4,226
1,533
187
55
1,330
7,331
IP address and Dare domains in EC2 with ec2-ip.compute-1.
amazonaws.com format. We did a manual inspection of the source
code, URL structure, and any other breadcrumbs.
3.4 Obtaining the Abandoned Resource
After we confirmed the existence of an abandoned Internet resource
used by mobile app, we attempted to find out whether the app still
had users by obtaining the Internet resource. Before obtaining the
domain, we first checked the last query timestamp of the domain
by using Passive DNS. For expired domains we re-registered the
domains. For parked domains, we purchased the domains from the
domain parking service that owned them. For Dare, we milked the IP
address from EC2 by launching a tool similar to IPScouters [30]. All
the limitation set in [30] were also applied in our experiment. This IP
address milking activity lasted two weeks. While in [30] all acquired
IP addresses were released, even when they were associated with
dares, we kept the IP address and later launched the instance on that
IP address. We set up a web server on the resource and captured all
traffic that came to the server. We relied on user-agent string found
in the HTTP Header to distinguish whether traffic came from a
mobile user. We sent the user-agent string to service in [1]. We also
used this service to filter traffics from crawlers.
4 MEASUREMENT RESULTS
From the measurement study that we conducted from June to No-
vember 2017, we found that abandoned Internet resources used
by Android apps existed and took on several forms, which we dis-
cussed earlier. In this section, we provide a high-level overview
4.2 Characteristic of the Abandoned Internet
Resources
Categories
By using the heuristics introduced in Section 3.3, we classified the
abandoned Internet resources into the three categories presented in
 Session 4: Mobile ASIACCS’18, June 4–8, 2018, Incheon, Republic of Korea152Table 3: Distinct APK per Category.
Category of Resource
Private Service
3rd Party Library
3rd Party Service
Unknown
Total
# of Resources
1,767
100
1,635
126
3,628
# of Distinct APK
2,542
2,440
2,187
201
7,331
Section 2.3. Table 2 shows the results. We found that the majority
of the expired domains were attributed to the private service or
third-party service.
In the private service category, we found 381 apps that were de-
veloped using an app building tool called AppInventor [14]. These
apps load websites by using WebView. Most of the websites are
owned by the same developer since the domain resembles to a part
of the package name. For example: appinventor.ai_emailrobind.
PriceComparisonUSA-3.apk and pricecomparisonusa.com. An-
other example is: ch.xot.latestbash consume http://abash.
at/rss.php for one of the source of its content. Many of APKs
that use third-party service are apps that load content from RSS
feeds, load a web page from a website as a WebView, or scrape
other websites. We note that resources that could not be classified
with the heuristics were categorized as “unknown.” All APKs in this
category were obfuscated and neither the domain name nor URL
could be used to identify the developer. A search on archive.org
produced no results.
The number of distinct APKs for each category is presented in
Table 3. There were 227 apps that belong to one or more categories.
Although there were only 100 resources found in the third-party
library category, they were used by 2,440 APKs. Hence, a change of
ownership for this category of resources would have widespread
impact.
We present the top 10 of the most used abandoned Internet
resources on Table 4. The IP address used by a third-party library
that was developed by UrbanAirship is in first place. The library
provides push notification service, using the IP address and custom
port number of 8090 to access client’s configuration. Scanning result
of the IP address indicates that custom port 8090 as well as port
80 and 443 are not opened. Thus, we suspect this IP address is
obtainable, however even though we tried to obtain this IP address
by continuously milking IP address in EC2 for several days, we
were not able to obtain this IP address. There is a possibility that
the company still keeps this IP address even though they are not
using it anymore.
We consider that private service type resources are a more seri-
ous threat. In many cases, the app developer (who also manages and
owns the resource) makes use of the resource so as to provide the
app with a critical feature, such as a web service that runs on top
of the resource. An example is a domain named kryptomens.com
owned by the developer MYAPPHONE SAS. The backend service
that runs on top this domain is providing support for the app to run
a deprecated Google service called C2DM (Cloud to Device Mes-
saging) [5]. To use this service, the app had to register the device to
C2DM service and send the registration ID to the developer server
(See Listing 2). Among the dangling records that we found, there
were a number of these types of web service. We believe that the
Figure 8: APK Age.
developer would not have leased a cloud server if there were no
intention to run a critical or heavy service on it. We discuss this
case study further in Section 5.1.
Listing 2: Private Service at kryptomens.com (Owned by
MYAPPHONE SAS) is Used as Backend Service.
public static boolean registerDevice(String p8, String p9){
try {