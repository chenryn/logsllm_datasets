trigger sensitive SMS data transmission: Figure 6(a) depicts
one of the feasible inputs, and a simpli(cid:12)ed version of the
other is depicted in Figure 5. Without loss of generality, we
choose the (cid:12)rst one to illustrate here.
Our dynamic analysis platform accepts this input and cre-
ates an execution as demonstrated in the video [4]. In this
case, the controlled execution (cid:12)rst selects a record among
the list which represents all conversation records stored in
this phone. Then, by choosing a message and clicking a but-
ton that presents "forward" in Chinese (Figure 7(a)), the app
user can forward this message to someone else. This mes-
sage can be sent to anyone by typing a named receiver and
clicking a button titled "send"(Figure 7(b) and Figure 7(c)).
This execution is commonly used for forwarding a stored
message to a friend of the app user, thus it should not be
classi(cid:12)ed as malicious/unintended behavior.
Tapsnake is a malicious app that stealthily transmits user
locations to a prede(cid:12)ned third party receiver. Depicted in
Figure 6(b), the app input generated by AppIntent shows
that two components are activated when the location infor-
mation is transmitted to a third-party user in Tapsnake: the
Figure 7: Screen shots of case studies.
After that, participants were asked to (cid:12)ll a sheet in which
each case should be classi(cid:12)ed as "user-intended" or "unin-
tended". We (cid:12)nd that they can make their decision in less
than one minute after the driven execution (cid:12)nishes, which
shows that AppIntent greatly speeds up the process in vali-
dating Android apps.
The results from these three users are unambiguously the
same as our judgement in 98 cases. However, there are some
diﬀerent opinions in two cases, which are both data trans-
mission of IMEI. Two out of three expects classi(cid:12)ed them
into user-intended because they think these apps need the
IMEI number to ful(cid:12)ll their functionality, while we classi(cid:12)ed
them as unintended data transmission because there is no
direct relation between the data transmission and the user
experience. This evaluation shows that AppIntent is still a
great assistance tool with high usability in practice. And it
certainly also has some room to be improved in the future.
7. RELATED WORK
AppIntent seems to be the (cid:12)rst to systematically study
a method to separate user-intended Android data transmis-
sion from unintended ones. All other existing Android pri-
vacy leakage detection approaches only detect sensitive data
transmission. Static Taint Analysis [21, 40] focuses on iden-
tifying the possible privacy leakage path with the help of
reachability analysis and program slicing. However, these
approaches commonly introduce a lot of false positives and
cannot separate user-intended operations from unintended
ones because of lacking user intention and context infor-
mation. On the other side, Dynamic Taint Tracking tech-
niques [22, 41] track the sensitive data at runtime by in-
strumenting pro(cid:12)ling code to the original app code. They
cannot be applied to automatically detect privacy leakages
in marketplaces because they report leakage only if such
dangerous propagation happens to occur in the execution.
While not implemented, Vision [26] argues that user grant-
ing of sensitive data usage can be represented by End-user
license agreements(EULA) and explicit noti(cid:12)cation during
the execution. Similarly, BLADE [32] detects web drive-
by download malware by recognizing whether it has user
Figure 6: Feasible app inputs for sensitive data transmission
in case studies.
main activity of this app, and an embedded Service which
registers an event listener for location change event. Based
on this input, the corresponding execution, demonstrated
in the video [5], waits until the current time is greater than
0xdbba0 (which represents 15 minutes from the beginning of
the wall time) Then, the location information is sent after a
location change event is performed (Figure 7(d)). Since the
original application is a simple "snake" video game, and its
functionality does not depend on the location information,
thus this behavior is unintended.
6.6 Usability of AppIntent
To evaluate how useful the information provided by Ap-
pIntent is, we randomly selected 100 cases reported, and
used them to evaluate the user experience. Since AppIntent
mainly focuses on providing enough information for discrimi-
nating user-intended data transmission from unintended one
at app markets, we invited three Android experts in our us-
ability study. During the evaluation, we (cid:12)rst introduced
AppIntent to them with less than 15 minutes, and let them
get familiar with the given cases. Then, we ran the driven
executions generated by AppIntent in our Samsung Nexus
S mobile phone and showed them to all three participants.
ComposeMessageActivityv1==0x7f02011cv2.getText==1000000v2==7f020106OnCreate()OnResume()OnStart()onOptionsItemSelected()ConversationListOnCreate()OnResume()OnStart()onItemClick()onClick(v1)menuitem==0x15SnakeServicelocation.getTime>= 0xdbba0OnCreate()onLocationChanged()SnakeOnCreate()(a)(b)consent or not. However, mobile apps commonly do not
provide EULA or noti(cid:12)cation even if the data transmission
is user-intended (e.g. SMS forwarding). Pegasus [18] de-
tects malicious behaviors that can be characterized by the
temporal order in which an application uses APIs and per-
missions, and similar to this paper, it focuses on detecting
malicious app behaviors that are inconsistent with the GUI
events. Nevertheless, privacy leakages cannot be modeled as
app usage of permissions or APIs, thus many privacy leak-
ages cannot be detected by such approach. Besides, Pega-
sus veri(cid:12)es program behaviors based on application-speci(cid:12)c
properties, which are diﬃcult to specify without the knowl-
edge of application code. Recently, VetDroid [44] enhances
Dynamic Taint Tracking by generating speci(cid:12)cations for sen-
sitive operations. However, the speci(cid:12)cation mainly focuses
on the application logic but does not pay attention to the
trigger condition of each operation.
AppIntent needs to extract app inputs to distinguish user-
intended data transmission from unintended one. Smart-
Droid [45] proposes a hybrid static and dynamic analysis
method to reveal UI-based event trigger conditions based
on sensitive Android APIs. However, in order to generate
a reproducible driven execution, we need both event inputs
and data inputs. In this sense, AppIntent provides a more
complete and systematic approach. Besides, instead of An-
droid APIs, we need (cid:12)ner-grained analysis of app behav-
iors to detect privacy leakages. AppIntent proposes a sym-
bolic execution approach for Android GUI apps to extract
inputs. The search space explosion of symbolic execution
is a well-known issue. Earlier guided symbolic executions
direct the exploration with static analysis result [11, 33, 36,
37] or pro(cid:12)led program behavior[14, 19, 43]. All these ap-
proaches focus on the explosion caused by the data input
space, and cannot reduce the search space of runtime events
in Android. On the other hand, there is little work on lim-
iting the event space.
In order to limit the search space,
Ganov, et.al [25] set an upper bound to the number of event
sequences generated, Kudzu [38] used a random generated
event order, and Ganov, et.al [24] proposed to generate test
cases by symbolically executing each event handler sepa-
rately. Although these features can limit the exploration of
event space, they greatly sacri(cid:12)ce the code coverage. Con-
test [9] seeks to prune redundant event sequences by check-
ing subsumption conditions, and can reduce the running time
of symbolic execution to 5%-36% of the original execution
time. However, the event space is still large after the prun-
ing and the path explosion problem still exists. To the best
of our knowledge, all existing approaches either trade accu-
racy for performance or suﬀering poor scalability.
In this
paper, by using the result of static analysis as the guideline,
event-space constraint guided symbolic execution explores
event space eﬃciently without sacri(cid:12)cing the accuracy.
8. CONCLUSION AND FUTURE WORK
This paper addresses one of the major challenges faced by
smartphone markets - how to detect privacy leakage in An-
droid apps. Unlike previous approaches that simply consider
the transmission of private data as privacy leakage, we ar-
gue that such transmission may not indicate a true privacy
leakage, instead, a better indicator should be whether the
transmission is user intended or not. We present AppIntent,
a new app validation framework to help human analysts de-
termine if data transmission is intended by the user. With
the help of event-space constraint guided symbolic execu-
tion technique proposed in this paper, the search space of
symbolic execution is eﬀectively bounded so that AppIntent
can extract app inputs that represent user interactions in an
acceptable amount of time. With the help of the dynamic
analysis platform, AppIntent can also intuitively display the
context information of the sensitive data transmission.
Our current techniques have the following limitations, which
are also our future work. First, native code is currently not
supported by AppIntent. Thus, privacy leakages in native
code cannot be captured. Second, since the Android In-
strumentationTestRunner [1] does not support instrumen-
tation of network input, our dynamic analysis platform can-
not simulate network inputs generated by symbolic execu-
tion. This could be solved by instrumenting code in Android
network interface. Finally, AppIntent fails to analyze some
apps because the DEX decompilation tool, DED [23], failed
to decompile these apps. We plan to use Dexpler [12], which
can directly parse DEX (cid:12)les, in soot, so that the decompi-
lation from DEX to Java bytecode is not needed.
Acknowledgments
We thank the anonymous reviewers for their insightful com-
ments, and ChenHao Qu for his assistance in experiments.
This work is funded by China National Natural Science
Foundation under grants numbered 61103078 and 61300027,
grants from the Science and Technology Commission of Shang-
hai Municipality numbered 11DZ2281500, 11511504404, 135-
11504402 and 13JC1400800, a research grant from a joint
program between China Ministry of Education and Intel
numbered MOE-INTEL201202, Fundamental Research Funds
for the Central Universities in China and Shanghai Leading
Academic Discipline Project numbered B114. This work is
partially supported by the National Science Foundation un-
der Grant no. CNS-0954096.
9. REFERENCES
[1] Android instrumentationtestrunner. http://develop-
er.android.com/reference/android/test/Instrumenta-
tionTestRunner.html.
[2] Android intent. http://developer.android.com-
/reference/android/content/Intent.html.
[3] anzhuoduanxin. http://dx.91.com/.
[4] Appintent demo: Anzhuoduanxin.
http://www.youtube.com/watch?v=RRqWQk4ztmI.
[5] Appintent demo: Tapsnake.
http://www.youtube.com/watch?v=L4IvXzpYqzw.
[6] Choco data constraint solver.
http://www.emn.fr/z-info/choco-solver/.
[7] Google map. http://www.google.com/mobile/maps/.
[8] soot analysis framework.
http://www.sable.mcgill.ca/soot/.
[9] S. Anand, M. Naik, H. Yang, and M. J. Harrold.
Automated concolic testing of smartphone apps. In
Proc. FSE, 2012.
[10] S. Anand, C. S. Pasareanu, and W. Visser. Jpf-se: A
symbolic execution extension to java path(cid:12)nder. In
TACAS 2007, pages 134{138, 2007.
[11] D. Babic, L. Martignoni, S. McCamant, and D. Song.
Statically-directed dynamic automated test
generation. In Proc. ISSTA, pages 12{22, 2011.
[12] A. Bartel, J. Klein, Y. Le Traon, and M. Monperrus.
[30] P. Hornyack, S. Han, J. Jung, S. Schechter, and
Dexpler: converting android dalvik bytecode to jimple
for static analysis with soot. In Proc. SOAP, 2012.
[13] P. Bisht, T. Hinrichs, N. Skrupsky, and V. N.
Venkatakrishnan. Waptec: whitebox analysis of web
applications for parameter tampering exploit
construction. In CCS, pages 575{586, 2011.
[14] P. Boonstoppel, C. Cadar, and D. R. Engler. Rwset:
Attacking path explosion in constraint-based test
generation. In TACAS, 2008.
[15] D. Brumley, J. Newsome, D. Song, H. Wang, and
S. Jha. Towards automatic generation of vulnerability
signatures. In IEEE Symposium on Security and
Privacy, 2006.
D. Wetherall. These aren’t the droids you’re looking
for: retro(cid:12)tting android to protect data from
imperious applications. In CCS, pages 639{652, 2011.
[31] A. Kieyzun, P. J. Guo, K. Jayaraman, and M. D.
Ernst. Automatic creation of sql injection and
cross-site scripting attacks. In ICSE, pages 199{209,
2009.
[32] L. Lu, V. Yegneswaran, P. Porras, and W. Lee. Blade:
an attack-agnostic approach for preventing drive-by
malware infections. In Proc. CCS, pages 440{450,
2010.
[33] K.-K. Ma, K. Y. Phang, J. S. Foster, and M. Hicks.
Directed symbolic execution. In Proc. SAS, 2011.
[16] C. Cadar, D. Dunbar, and D. R. Engler. Klee:
[34] D. Molnar, X. C. Li, and D. A. Wagner. Dynamic test
Unassisted and automatic generation of high-coverage
tests for complex systems programs. In OSDI, pages
209{224, 2008.
[17] C. Cadar, V. Ganesh, P. M. Pawlowski, D. L. Dill,
and D. R. Engler. Exe: automatically generating
inputs of death. In CCS, pages 322{335, 2006.
[18] K. Z. Chen, N. Johnson, V. D’Silva, S. Dai,
K. MacNamara, T. Magrino, E. X. Wu, M. Rinard,
and D. Song. Contextual policy enforcement in
android applications with permission event graphs. In
Proc. NDSS, 2013.
generation to (cid:12)nd integer bugs in x86 binary linux
programs. In USENIX Security, pages 67{82, 2009.
[35] G. Patrice, Y. L. Michael, and A. M. David.
Automated whitebox fuzz testing. In NDSS, 2008.
[36] N. Rungta, E. G. Mercer, and W. Visser. Eﬃcient
testing of concurrent programs with
abstraction-guided symbolic execution. In Proc. SPIN,
2009.
[37] R. Santelices and M. J. Harrold. Exploiting program
dependencies for scalable multiple-path symbolic
execution. In Proc. ISSTA, 2010.
[19] C. Y. Cho, D. Babic, P. Poosankam, K. Z. Chen,
[38] P. Saxena, D. Akhawe, S. Hanna, F. Mao,
D. Song, and E. X. Wu. Mace:
Model-inference-assisted concolic exploration for
protocol and vulnerability discovery. In USENIX
Security, 2011.
[20] M. Costa, M. Castro, L. Zhou, L. Zhang, and
M. Peinado. Bouncer: securing software by blocking
bad input. In SOSP, pages 117{130, 2007.
[21] M. Egele, C. Kruegel, E. Kirda, and G. Vigna. Pios:
Detecting privacy leaks in ios applications. In NDSS,
2011.
[22] W. Enck, P. Gilbert, B.-G. Chun, L. P. Cox, J. Jung,
P. McDaniel, and A. N. Sheth. Taintdroid: an
information-(cid:13)ow tracking system for realtime privacy
monitoring on smartphones. In OSDI, pages 1{6, 2010.
[23] W. Enck, D. Octeau, P. McDaniel, and S. Chaudhuri.
A Study of Android Application Security. In USENIX
Security, 2011.
[24] S. R. Ganov, C. Killmar, S. Khurshid, and D. E. Perry.
Test generation for graphical user interfaces based on
symbolic execution. In AST, pages 33{40, 2008.
[25] S. R. Ganov, C. Killmar, S. Khurshid, and D. E.
Perry. Event listener analysis and symbolic execution
for testing gui applications. In ICFEM, 2009.
[26] P. Gilbert, B.-G. Chun, L. P. Cox, and J. Jung.
Vision: automated security validation of mobile apps
at app markets. In Proc. MCS), 2011.
[27] P. Godefroid. Compositional dynamic test generation.
In POPL, pages 47{54, 2007.
[28] P. Godefroid, N. Klarlund, and K. Sen. Dart: directed
automated random testing. In PLDI, pages 213{223,
2005.
[29] M. C. Grace, W. Zhou, X. Jiang, and A.-R. Sadeghi.
Unsafe exposure analysis of mobile in-app
advertisements. In WiSec, 2012.
S. McCamant, and D. Song. A symbolic execution
framework for javascript. Security and Privacy, IEEE
Symposium on, 0:513{528, 2010.
[39] K. Sen, D. Marinov, and G. Agha. Cute: a concolic
unit testing engine for c. In ESEC/SIGSOFT FSE,
pages 263{272, 2005.
[40] O. Tripp, M. Pistoia, S. J. Fink, M. Sridharan, and
O. Weisman. Taj: eﬀective taint analysis of web
applications. In PLDI, pages 87{97, 2009.
[41] N. Vachharajani, M. J. Bridges, J. Chang, R. Rangan,
G. Ottoni, J. A. Blome, G. A. Reis, M. Vachharajani,
and D. I. August. Ri(cid:13)e: An architectural framework
for user-centric information-(cid:13)ow security. In MICRO,
pages 243{254, 2004.
[42] T. Wang, T. Wei, Z. Lin, and W. Zou. Intscope:
Automatically detecting integer over(cid:13)ow vulnerability
in x86 binary using symbolic execution. In NDSS,
2009.
[43] T. Xie, N. Tillmann, P. de Halleux, and W. Schulte.
Fitness-guided path exploration in dynamic symbolic
execution. In Proc. DSN, 2009.
[44] Y. Zhang, M. Yang, B. Xu, Z. Yang, G. Gu, P. Ning,
X. Wang, and B. Zang. Vetting undesirable behaviors
in android apps with permission use analysis. In CCS,
2013.
[45] C. Zheng, S. Zhu, S. Dai, G. Gu, X. Gong, and
W. Zou. Smartdroid: An automatic system for
revealing ui-based trigger conditions in android
applications. In Proc. SPSM, October 2012.
[46] Y. Zhou and X. Jiang. Dissecting android malware:
Characterization and evolution. In IEEE Symposium
on Security and Privacy, 2012.