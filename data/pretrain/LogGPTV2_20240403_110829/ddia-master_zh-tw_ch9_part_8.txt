兰伯特时间戳有时会与我们在 “[检测并发写入](ch5.md#检测并发写入)” 中看到的版本向量相混淆。虽然两者有一些相似之处，但它们有著不同的目的：版本向量可以区分两个操作是并发的，还是一个因果依赖另一个；而兰伯特时间戳总是施行一个全序。从兰伯特时间戳的全序中，你无法分辨两个操作是并发的还是因果依赖的。兰伯特时间戳优于版本向量的地方是，它更加紧凑。
#### 光有时间戳排序还不够
虽然兰伯特时间戳定义了一个与因果一致的全序，但它还不足以解决分散式系统中的许多常见问题。
例如，考虑一个需要确保使用者名称能唯一标识使用者帐户的系统。如果两个使用者同时尝试使用相同的使用者名称建立帐户，则其中一个应该成功，另一个应该失败（我们之前在 “[领导者和锁](ch8.md#领导者和锁)” 中提到过这个问题）。
乍看之下，似乎操作的全序关系足以解决这一问题（例如使用兰伯特时间戳）：如果建立了两个具有相同使用者名称的帐户，选择时间戳较小的那个作为胜者（第一个抓到使用者名称的人），并让带有更大时间戳者失败。由于时间戳上有全序关系，所以这个比较总是可行的。
这种方法适用于事后确定胜利者：一旦你收集了系统中的所有使用者名称建立操作，就可以比较它们的时间戳。然而当某个节点需要实时处理使用者建立使用者名称的请求时，这样的方法就无法满足了。节点需要 **马上（right now）** 决定这个请求是成功还是失败。在那个时刻，节点并不知道是否存在其他节点正在并发执行建立同样使用者名称的操作，罔论其它节点可能分配给那个操作的时间戳。
为了确保没有其他节点正在使用相同的使用者名称和较小的时间戳并发建立同名账户，你必须检查其它每个节点，看看它在做什么【56】。如果其中一个节点由于网路问题出现故障或不可达，则整个系统可能被拖至停机。这不是我们需要的那种容错系统。
这里的问题是，只有在所有的操作都被收集之后，操作的全序才会出现。如果另一个节点已经产生了一些操作，但你还不知道那些操作是什么，那就无法构造所有操作最终的全序关系：来自另一个节点的未知操作可能需要被插入到全序中的不同位置。
总之：为了实现诸如使用者名称上的唯一约束这种东西，仅有操作的全序是不够的，你还需要知道这个全序何时会尘埃落定。如果你有一个建立使用者名称的操作，并且确定在全序中没有任何其他节点可以在你的操作之前插入对同一使用者名称的声称，那么你就可以安全地宣告操作执行成功。
如何确定全序关系已经尘埃落定，这将在 [全序广播](#全序广播) 一节中详细说明。
### 全序广播
如果你的程式只执行在单个 CPU 核上，那么定义一个操作全序是很容易的：可以简单认为就是 CPU 执行这些操作的顺序。但是在分散式系统中，让所有节点对同一个全域性操作顺序达成一致可能相当棘手。在上一节中，我们讨论了按时间戳或序列号进行排序，但发现它还不如单主复制给力（如果你使用时间戳排序来实现唯一性约束，就不能容忍任何错误，因为你必须要从每个节点都获取到最新的序列号）。
如前所述，单主复制透过选择一个节点作为主库来确定操作的全序，并在主库的单个 CPU 核上对所有操作进行排序。接下来的挑战是，如果吞吐量超出单个主库的处理能力，这种情况下如何扩充套件系统；以及，如果主库失效（“[处理节点宕机](ch5.md#处理节点宕机)”），如何处理故障切换。在分散式系统文献中，这个问题被称为 **全序广播（total order broadcast）** 或 **原子广播（atomic broadcast）**[^ix]【25,57,58】。
[^ix]: “原子广播” 是一个传统的术语，非常混乱，而且与 “原子” 一词的其他用法不一致：它与 ACID 事务中的原子性没有任何关系，只是与原子操作（在多执行绪程式设计的意义上 ）或原子暂存器（线性一致储存）有间接的联络。全序组播（total order multicast）是另一个同义词。
> #### 顺序保证的范围
>
> 每个分割槽各有一个主库的分割槽资料库，通常只在每个分割槽内维持顺序，这意味著它们不能提供跨分割槽的一致性保证（例如，一致性快照，外来键引用）。跨所有分割槽的全序是可能的，但需要额外的协调【59】。
全序广播通常被描述为在节点间交换讯息的协议。非正式地讲，它要满足两个安全属性：
* 可靠交付（reliable delivery）
  没有讯息丢失：如果讯息被传递到一个节点，它将被传递到所有节点。
* 全序交付（totally ordered delivery）
  讯息以相同的顺序传递给每个节点。
正确的全序广播演算法必须始终保证可靠性和有序性，即使节点或网路出现故障。当然在网路中断的时候，讯息是传不出去的，但是演算法可以不断重试，以便在网路最终修复时，讯息能及时透过并送达（当然它们必须仍然按照正确的顺序传递）。
#### 使用全序广播
像 ZooKeeper 和 etcd 这样的共识服务实际上实现了全序广播。这一事实暗示了全序广播与共识之间有著紧密联络，我们将在本章稍后进行探讨。
全序广播正是资料库复制所需的：如果每个讯息都代表一次资料库的写入，且每个副本都按相同的顺序处理相同的写入，那么副本间将相互保持一致（除了临时的复制延迟）。这个原理被称为 **状态机复制（state machine replication）**【60】，我们将在 [第十一章](ch11.md) 中重新回到这个概念。
与之类似，可以使用全序广播来实现可序列化的事务：如 “[真的序列执行](ch7.md#真的序列执行)” 中所述，如果每个讯息都表示一个确定性事务，以储存过程的形式来执行，且每个节点都以相同的顺序处理这些讯息，那么资料库的分割槽和副本就可以相互保持一致【61】。
全序广播的一个重要表现是，顺序在讯息送达时被固化：如果后续的讯息已经送达，节点就不允许追溯地将（先前）讯息插入顺序中的较早位置。这个事实使得全序广播比时间戳排序更强。
考量全序广播的另一种方式是，这是一种建立日志的方式（如在复制日志、事务日志或预写式日志中）：传递讯息就像追加写入日志。由于所有节点必须以相同的顺序传递相同的讯息，因此所有节点都可以读取日志，并看到相同的讯息序列。
全序广播对于实现提供防护令牌的锁服务也很有用（请参阅 “[防护令牌](ch8.md#防护令牌)”）。每个获取锁的请求都作为一条讯息追加到日志末尾，并且所有的讯息都按它们在日志中出现的顺序依次编号。序列号可以当成防护令牌用，因为它是单调递增的。在 ZooKeeper 中，这个序列号被称为 `zxid` 【15】。
#### 使用全序广播实现线性一致的储存
如 [图 9-4](../img/fig9-4.png) 所示，线性一致的系统中，存在操作的全序。这是否意味著线性一致与全序广播一样？不尽然，但两者之间有著密切的联络 [^x]。