## 传输问题但是错误、重传、丢包、性能等问题还没有解决，这些问题我们统称为**传输问题**。这个就不用Stub 操心了，而是由 ONC RPC的类库来实现。这是大牛们实现的，我们只要调用就可以了。![](Images/bfeef0081dec3f2fc1be86f575abbee7.png){savepage-src="https://static001.geekbang.org/resource/image/33/e4/33e1afe4a79e81096e09b850424930e4.jpg"}在这个类库中，为了解决传输问题，对于每一个客户端，都会创建一个传输管理层，而每一次RPC调用，都会是一个任务，在传输管理层，你可以看到熟悉的队列机制、拥塞窗口机制等。由于在网络传输的时候，经常需要等待，因而同步的方式往往效率比较低，因而也就有Socket的异步模型。为了能够异步处理，对于远程调用的处理，往往是通过状态机来实现的。只有当满足某个状态的时候，才进行下一步，如果不满足状态，不是在那里等，而是将资源留出来，用来处理其他的RPC 调用。![](Images/98a04a776401626722bfe4d0ac3c9120.png){savepage-src="https://static001.geekbang.org/resource/image/02/f5/0258775aac1126735504c9a6399745f5.jpg"}从这个图可以看出，这个状态转换图还是很复杂的。首先，进入起始状态，查看 RPC的传输层队列中有没有空闲的位置，可以处理新的 RPC任务。如果没有，说明太忙了，或直接结束或重试。如果申请成功，就可以分配内存，获取服务的端口号，然后连接服务器。连接的过程要有一段时间，因而要等待连接的结果，会有连接失败，或直接结束或重试。如果连接成功，则开始发送RPC 请求，然后等待获取 RPC结果，这个过程也需要一定的时间；如果发送出错，可以重新发送；如果连接断了，可以重新连接；如果超时，可以重新传输；如果获取到结果，就可以解码，正常结束。这里处理了连接失败、重试、发送失败、超时、重试等场景。不是大牛真写不出来，因而实现一个RPC 的框架，其实很有难度。
## 服务发现问题传输问题解决了，我们还遗留一个问题，就是问题四"如何找到 RPC服务端的那个随机端口"。这个问题我们称为服务发现问题。在 ONC RPC中，服务发现是通过 portmapper 实现的。![](Images/9944162088ee9d8d692b966a22bf3285.png){savepage-src="https://static001.geekbang.org/resource/image/2a/7c/2aff190d1f878749d2a5bd73228ca37c.jpg"}portmapper 会启动在一个众所周知的端口上，RPC程序由于是用户自己写的，会监听在一个随机端口上，但是 RPC程序启动的时候，会向 portmapper 注册。客户端要访问 RPC服务端这个程序的时候，首先查询 portmapper，获取 RPC服务端程序的随机端口，然后向这个随机端口建立连接，开始 RPC调用。从图中可以看出，mount 命令的 RPC 调用，就是这样实现的。
## 小结好了，这一节就到这里，我们来总结一下。-   远程调用看起来用 Socket    编程就可以了，其实是很复杂的，要解决协议约定问题、传输问题和服务发现问题。-   大牛 Bruce Jay Nelson 的论文、早期 ONC RPC 框架，以及 NFS    的实现，给出了解决这三大问题的示范性实现，也即协议约定要公用协议描述文件，并通过这个文件生成    Stub 程序；RPC    的传输一般需要一个状态机，需要另外一个进程专门做服务发现。最后，给你留两个思考题。1.  在这篇文章中，mount 的过程是通过系统调用，最终调用到 RPC 层。一旦    mount 完毕之后，客户端就像写入本地文件一样写入 NFS    了，这个过程是如何触发 RPC 层的呢？2.  ONC RPC 是早期的 RPC 框架，你觉得它有哪些问题呢？我们的专栏更新到第 32讲，不知你掌握得如何？每节课后我留的思考题，你都有没有认真思考，并在留言区写下答案呢？我会从**已发布的文章中选出一批认真留言的同学**，赠送**学习奖励礼券**和我整理的**独家网络协议知识图谱**。欢迎你留言和我讨论。趣谈网络协议，我们下期见！![](Images/55417b60e9c8040807daf07e6bd9cb4b.png){savepage-src="https://static001.geekbang.org/resource/image/b5/fb/b5bc14cb81d3630919fee94a512cc3fb.jpg"}
# 第33讲 \| 基于XML的SOAP协议：不要说NBA，请说美国职业篮球联赛上一节我们讲了 RPC 的经典模型和设计要点，并用最早期的 ONC RPC为例子，详述了具体的实现。
## ONC RPC 存在哪些问题？ONC RPC将客户端要发送的参数，以及服务端要发送的回复，都压缩为一个二进制串，这样固然能够解决双方的协议约定问题，但是存在一定的不方便。首先，**需要双方的压缩格式完全一致**，一点都不能差。一旦有少许的差错，多一位，少一位或者错一位，都可能造成无法解压缩。当然，我们可以用传输层的可靠性以及加入校验值等方式，来减少传输过程中的差错。其次，**协议修改不灵活**。如果不是传输过程中造成的差错，而是客户端因为业务逻辑的改变，添加或者删除了字段，或者服务端添加或者删除了字段，而双方没有及时通知，或者线上系统没有及时升级，就会造成解压缩不成功。因而，当业务发生改变，需要多传输一些参数或者少传输一些参数的时候，都需要及时通知对方，并且根据约定好的协议文件重新生成双方的Stub 程序。自然，这样灵活性比较差。如果仅仅是沟通的问题也还好解决，其实更难弄的还有**版本的问题**。比如在服务端提供一个服务，参数的格式是版本一的，已经有50个客户端在线上调用了。现在有一个客户端有个需求，要加一个字段，怎么办呢？这可是一个大工程，所有的客户端都要适配这个，需要重新写程序，加上这个字段，但是传输值是0，不需要这个字段的客户端很"冤"，本来没我啥事儿，为啥让我也忙活？``{=html}最后，**ONC RPC的设计明显是面向函数的，而非面向对象**。而当前面向对象的业务逻辑设计与实现方式已经成为主流。这一切的根源就在于压缩。这就像平时我们爱用缩略语。如果是篮球爱好者，你直接说NBA，他马上就知道什么意思，但是如果你给一个大妈说NBA，她可能就不知所云。所以，这种 RPC框架只能用于客户端和服务端全由一拨人开发的场景，或者至少客户端和服务端的开发人员要密切沟通，相互合作，有大量的共同语言，才能按照既定的协议顺畅地进行工作。
## XML 与 SOAP但是，一般情况下，我们做一个服务，都是要提供给陌生人用的，你和客户不会经常沟通，也没有什么共同语言。就像你给别人介绍NBA，你要说美国职业篮球赛，这样不管他是干啥的，都能听得懂。放到我们的场景中，对应的就是用**文本类**的方式进行传输。无论哪个客户端获得这个文本，都能够知道它的意义。一种常见的文本类格式是 XML。我们这里举个例子来看。                2018-07-01         趣谈网络协议          刘超         68    我这里不准备详细讲述 XML的语法规则，但是你相信我，看完下面的内容，即便你没有学过XML，也能一看就懂，这段 XML 描述的是什么，不像全面的二进制，你看到的都是010101，不知所云。有了这个，刚才我们说的那几个问题就都不是问题了。首先，**格式没必要完全一致**。比如如果我们把 price 和 author换个位置，并不影响客户端和服务端解析这个文本，也根本不会误会，说这个作者的名字叫68。如果有的客户端想增加一个字段，例如添加一个推荐人字段，只需要在上面的文件中加一行：     Gary  对于不需要这个字段的客户端，只要不解析这一行就是了。只要用简单的处理，就不会出现错误。另外，这种表述方式显然是描述一个订单对象的，是一种面向对象的、更加接近用户场景的表示方式。既然 XML 这么好，接下来我们来看看怎么把它用在 RPC 中。