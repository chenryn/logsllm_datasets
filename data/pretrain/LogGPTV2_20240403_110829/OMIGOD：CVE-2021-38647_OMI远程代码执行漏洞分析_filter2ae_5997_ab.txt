                trace_SockSetBlocking_Failed(ENGINE_TYPE);
                HttpAuth_Close(handler_);
                Sock_Close(s);
                return MI_TRUE;
            }
            /* Create handler */
            h = (Http_SR_SocketData*)Strand_New( STRAND_DEBUG( HttpSocket ) &_HttpSocket_FT, sizeof(Http_SR_SocketData), STRAND_FLAG_ENTERSTRAND, NULL );
            if (!h)
            {
                trace_SocketClose_Http_SR_SocketDataAllocFailed();
                HttpAuth_Close(handler_);
                Sock_Close(s);
                return MI_TRUE;
            }
            /* Primary refount -- secondary one is for posting to protocol thread safely */
            h->refcount = 1;    //初始化Http_Listener_SocketData
            h->http = self;
            h->pAuthContext  = NULL;
            h->pVerifierCred = NULL;
            h->isAuthorised = FALSE;
            h->authFailed   = FALSE;
            h->encryptedTransaction = FALSE;
            h->pSendAuthHeader = NULL;
            h->sendAuthHeaderLen = 0;
        --------        }
    }
可以发现此时初始化将isAuthorised设为FALSE，并且未初始化authInfo.uid和authInfo.gid。  
接着_ListenerCallback函数调用到_ReadData函数，该函数用于接收输入的数据并且进行处理，下面重点分析_ReadData函数的处理逻辑：
    static Http_CallbackResult _ReadData(
        Http_SR_SocketData* handler)
    {
        char* buf;
        size_t buf_size, received;
        MI_Result r;
        /* are we in the right state? */
        if (handler->recvingState != RECV_STATE_CONTENT)
            return PRT_RETURN_FALSE;
        buf = ((char*)(handler->recvPage + 1)) + handler->receivedSize;
        buf_size = handler->recvHeaders.contentLength - handler->receivedSize;
        received = 0;
        if (buf_size)
        {
            r = _Sock_Read(handler, buf, buf_size, &received);
            if ( r == MI_RESULT_OK && 0 == received )
                return PRT_RETURN_FALSE; /* conection closed */
            if ( r != MI_RESULT_OK && r != MI_RESULT_WOULD_BLOCK )
                return PRT_RETURN_FALSE;
            handler->receivedSize += received;
        }
        /* did we get all data? */
        if ( handler->receivedSize != handler->recvHeaders.contentLength )
            return PRT_RETURN_TRUE;
        /* If we are authorised, but the client is sending an auth header, then 
        * we need to tear down all of the auth state and authorise again.
        * NeedsReauthorization does the teardown
        */
        if(handler->recvHeaders.authorization)  // （1） 判断是否收到authorization
        {
            Http_CallbackResult authorized;
            handler->requestIsBeingProcessed = MI_TRUE;
            if (handler->isAuthorised)
            { 
                Deauthorize(handler);
            }
            authorized = IsClientAuthorized(handler);
            if (PRT_RETURN_FALSE == authorized)
            {
                goto Done;
            }
            else if (PRT_CONTINUE == authorized)
            {
                return PRT_CONTINUE;
            }
        }
        else 
        {
            /* Once we are unauthorised we remain unauthorised until the client
            starts the auth process again */
            if (handler->authFailed)    // （2） authFailed判断
            {
                handler->httpErrorCode = HTTP_ERROR_CODE_UNAUTHORIZED;
                return PRT_RETURN_FALSE;
            }
        }
        r = Process_Authorized_Message(handler);    // （3） Message处理
        if (MI_RESULT_OK != r)
        {
            return PRT_RETURN_FALSE;
        }
    Done:
        handler->recvPage = 0;
        handler->receivedSize = 0;
        memset(&handler->recvHeaders, 0, sizeof(handler->recvHeaders));
        handler->recvingState = RECV_STATE_HEADER;
        return PRT_CONTINUE;
    }
由上面代码可以发现，当发送数据包不带Authorization字段时，函数处理会进入else处理部分，会判断authFailed，由于authFailed为FALSE，则会跳出执行到Process_Authorized_Message函数，则就会出现未认证的情况下执行命令的情况，由于此时是在OMI进程中，因此会以root用户权限执行。
到此，我们即发现了漏洞的成因，该漏洞是在逻辑设计的过程中，对认证过程校验不严格导致的。
###  漏洞补丁
通过漏洞成因分析，我们可以发现，漏洞出现的原因主要是在http.c文件中的_ListenerCallback和_ReadData函数中，因此漏洞修复也主要是在这两个函数中进行。通过对比OMI源码发现：
_ListenerCallback函数在初始化部分进行修复，将authInfo.uid和authInfo.gid初始化为INVALID_ID，如下面代码所示：
    static MI_Boolean _ListenerCallback(
        Selector* sel,
        Handler* handler_,
        MI_Uint32 mask,
        MI_Uint64 currentTimeUsec)
    {
        --------    
            /* Primary refount -- secondary one is for posting to protocol thread safely */
            h->refcount = 1;
            h->http = self;
            h->pAuthContext  = NULL;
            h->pVerifierCred = NULL;
            h->isAuthorised = FALSE;
            h->authFailed   = FALSE;
            h->encryptedTransaction = FALSE;
            h->pSendAuthHeader = NULL;
            h->sendAuthHeaderLen = 0;
            h->authInfo.uid= INVALID_ID;    //补丁修复部分
            h->authInfo.gid= INVALID_ID;    //补丁修复部分
           --------    
        return MI_TRUE;
    }
修复前后代码对比如下图：
_ReadData函数修复主要是在函数Process_Authorized_Message执行之前，加入isAuthorised的判断，如下面代码：
    static Http_CallbackResult _ReadData(
    Http_SR_SocketData* handler)
    {
    if (handler->isAuthorised)
    {
        r = Process_Authorized_Message(handler);
        if (MI_RESULT_OK != r)
        {
            return PRT_RETURN_FALSE;
        }
    }
    ------    }
修复前后代码对比如下图：
## 总结建议
该漏洞是一个认证逻辑上存在缺陷导致的远程代码执行漏洞，漏洞影响范围较大，且利用前置条件简单，建议立即更新受此漏洞影响的Azure产品，或者手动操作以确保OMI版本升级到最新版本。
  * Debian系统（例如Ubuntu）:dpkg -l omi
  * RedHat系统（例如Fedora，CentOS, RHEL）:rpm -qa omi
## 参考资料
1.
2.
3.