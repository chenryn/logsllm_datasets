但是，散列表索引也有其局限性：
* 散列表必须能放进记忆体。如果你有非常多的键，那真是倒楣。原则上可以在硬碟上维护一个杂凑对映，不幸的是硬碟杂凑对映很难表现优秀。它需要大量的随机访问 I/O，而后者耗尽时想要再扩充是很昂贵的，并且需要很烦琐的逻辑去解决杂凑冲突【5】。
* 范围查询效率不高。例如，你无法轻松扫描 kitty00000 和 kitty99999 之间的所有键 —— 你必须在杂凑对映中单独查询每个键。
在下一节中，我们将看到一个没有这些限制的索引结构。
### SSTables和LSM树
在 [图 3-3](../img/fig3-3.png) 中，每个日志结构储存段都是一系列键值对。这些键值对按照它们写入的顺序排列，日志中稍后的值优先于日志中较早的相同键的值。除此之外，档案中键值对的顺序并不重要。
现在我们可以对段档案的格式做一个简单的改变：要求键值对的序列按键排序。乍一看，这个要求似乎打破了我们使用顺序写入的能力，我们将稍后再回到这个问题。
我们把这个格式称为 **排序字串表（Sorted String Table）**，简称 SSTable。我们还要求每个键只在每个合并的段档案中出现一次（压缩过程已经保证）。与使用杂凑索引的日志段相比，SSTable 有几个大的优势：
1. 即使档案大于可用记忆体，合并段的操作仍然是简单而高效的。这种方法就像归并排序演算法中使用的方法一样，如 [图 3-4](../img/fig3-4.png) 所示：你开始并排读取多个输入档案，检视每个档案中的第一个键，复制最低的键（根据排序顺序）到输出档案，不断重复此步骤，将产生一个新的合并段档案，而且它也是也按键排序的。
   ![](../img/fig3-4.png)
   **图 3-4 合并几个 SSTable 段，只保留每个键的最新值**
   如果在几个输入段中出现相同的键，该怎么办？请记住，每个段都包含在一段时间内写入资料库的所有值。这意味著一个输入段中的所有值一定比另一个段中的所有值都更近（假设我们总是合并相邻的段）。当多个段包含相同的键时，我们可以保留最近段的值，并丢弃旧段中的值。
2. 为了在档案中找到一个特定的键，你不再需要在记忆体中储存所有键的索引。以 [图 3-5](../img/fig3-5.png) 为例：假设你正在记忆体中寻找键 `handiwork`，但是你不知道这个键在段档案中的确切偏移量。然而，你知道 `handbag` 和 `handsome` 的偏移，而且由于排序特性，你知道 `handiwork` 必须出现在这两者之间。这意味著你可以跳到 `handbag` 的偏移位置并从那里扫描，直到你找到 `handiwork`（或没找到，如果该档案中没有该键）。
   ![](../img/fig3-5.png)
   **图 3-5 具有记忆体索引的 SSTable**
   你仍然需要一个记忆体中的索引来告诉你一些键的偏移量，但它可以是稀疏的：每几千位元组的段档案有一个键就足够了，因为几千位元组可以很快地被扫描完 [^i]。
[^i]: 如果所有的键与值都是定长的，你可以使用段档案上的二分查询并完全避免使用记忆体索引。然而实践中的键和值通常都是变长的，因此如果没有索引，就很难知道记录的分界点（前一条记录结束以及后一条记录开始的地方）。
3. 由于读取请求无论如何都需要扫描所请求范围内的多个键值对，因此可以将这些记录分组为块（block），并在将其写入硬碟之前对其进行压缩（如 [图 3-5](../img/fig3-5.png) 中的阴影区域所示）[^ 译注 i] 。稀疏记忆体索引中的每个条目都指向压缩块的开始处。除了节省硬碟空间之外，压缩还可以减少对 I/O 频宽的使用。
[^译注i]: 这里的压缩是 compression，不是前文的 compaction，请注意区分。
#### 构建和维护SSTables
到目前为止还不错，但是如何让你的资料能够预先排好序呢？毕竟我们接收到的写入请求可能以任何顺序发生。
虽然在硬碟上维护有序结构也是可能的（请参阅 “[B 树](#B树)”），但在记忆体储存则要容易得多。有许多可以使用的众所周知的树形资料结构，例如红黑树或 AVL 树【2】。使用这些资料结构，你可以按任何顺序插入键，并按排序顺序读取它们。
现在我们可以让我们的储存引擎以如下方式工作：
* 有新写入时，将其新增到记忆体中的平衡树资料结构（例如红黑树）。这个记忆体树有时被称为 **记忆体表（memtable）**。
* 当 **记忆体表** 大于某个阈值（通常为几兆位元组）时，将其作为 SSTable 档案写入硬碟。这可以高效地完成，因为树已经维护了按键排序的键值对。新的 SSTable 档案将成为资料库中最新的段。当该 SSTable 被写入硬碟时，新的写入可以在一个新的记忆体表例项上继续进行。
* 收到读取请求时，首先尝试在记忆体表中找到对应的键，如果没有就在最近的硬碟段中寻找，如果还没有就在下一个较旧的段中继续寻找，以此类推。
* 时不时地，在后台执行一个合并和压缩过程，以合并段档案并将已覆盖或已删除的值丢弃掉。
这个方案效果很好。它只会遇到一个问题：如果资料库崩溃，则最近的写入（在记忆体表中，但尚未写入硬碟）将丢失。为了避免这个问题，我们可以在硬碟上储存一个单独的日志，每个写入都会立即被追加到这个日志上，就像在前面的章节中所描述的那样。这个日志没有按排序顺序，但这并不重要，因为它的唯一目的是在崩溃后恢复记忆体表。每当记忆体表写出到 SSTable 时，相应的日志都可以被丢弃。
#### 用SSTables制作LSM树
这里描述的演算法本质上是 LevelDB【6】和 RocksDB【7】这些键值储存引擎库所使用的技术，这些储存引擎被设计嵌入到其他应用程式中。除此之外，LevelDB 可以在 Riak 中用作 Bitcask 的替代品。在 Cassandra 和 HBase 中也使用了类似的储存引擎【8】，而且他们都受到了 Google 的 Bigtable 论文【9】（引入了术语 SSTable 和 memtable ）的启发。
这种索引结构最早由 Patrick O'Neil 等人发明，且被命名为日志结构合并树（或 LSM 树）【10】，它是基于更早之前的日志结构档案系统【11】来构建的。基于这种合并和压缩排序档案原理的储存引擎通常被称为 LSM 储存引擎。
Lucene，是一种全文搜寻的索引引擎，在 Elasticsearch 和 Solr 被使用，它使用类似的方法来储存它的关键词词典【12,13】。全文索引比键值索引复杂得多，但是基于类似的想法：在搜寻查询中，由一个给定的单词，找到提及单词的所有文件（网页、产品描述等）。这也是透过键值结构实现的：其中键是 **单词（term）**，值是所有包含该单词的文件的 ID 列表（**postings list**）。在 Lucene 中，从词语到记录列表的这种对映储存在类似于 SSTable 的有序档案中，并根据需要在后台执行合并【14】。
#### 效能最佳化
与往常一样，要让储存引擎在实践中表现良好涉及到大量设计细节。例如，当查询资料库中不存在的键时，LSM 树演算法可能会很慢：你必须先检查记忆体表，然后检视从最近的到最旧的所有的段（可能还必须从硬碟读取每一个段档案），然后才能确定这个键不存在。为了最佳化这种访问，储存引擎通常使用额外的布隆过滤器（Bloom filters）【15】。（布隆过滤器是一种节省记忆体的资料结构，用于近似表达集合的内容，它可以告诉你资料库中是否存在某个键，从而为不存在的键节省掉许多不必要的硬碟读取操作。）
还有一些不同的策略来确定 SSTables 被压缩和合并的顺序和时间。最常见的选择是 size-tiered 和 leveled compaction。LevelDB 和 RocksDB 使用 leveled compaction（LevelDB 因此得名），HBase 使用 size-tiered，Cassandra 同时支援这两种【16】。对于 sized-tiered，较新和较小的 SSTables 相继被合并到较旧的和较大的 SSTable 中。对于 leveled compaction，key （按照分布范围）被拆分到较小的 SSTables，而较旧的资料被移动到单独的层级（level），这使得压缩（compaction）能够更加增量地进行，并且使用较少的硬碟空间。
即使有许多微妙的东西，LSM 树的基本思想 —— 储存一系列在后台合并的 SSTables —— 简单而有效。即使资料集比可用记忆体大得多，它仍能继续正常工作。由于资料按排序顺序储存，你可以高效地执行范围查询（扫描所有从某个最小值到某个最大值之间的所有键），并且因为硬碟写入是连续的，所以 LSM 树可以支援非常高的写入吞吐量。