coverage-guided mutation in a context-aware manner.
is considered the most successful one, which has publicly revealed
more than 60 bugs in popular browsers. It is actively maintained and
widely used by browser vendors for internal testing [12, 16, 17, 39].
Thus, we select Domato as the main state-of-the-art fuzzer for
evaluation and comparison in this paper.
3 MOTIVATION
In this section, we systematically analyze the defects of conven-
tional generation-based DOM fuzzers. Their common approach
fails to construct inputs with complex semantics and, more impor-
tantly, restricts the exploration of applying up-to-date techniques
to a DOM fuzzer, which motivates us to propose FreeDom.
3.1 On the Ineffectiveness of Static Grammars
Previous research has pointed out that one crux of fuzzing com-
plex software effectively is to avoid semantic errors [20, 55], not
excepting DOM engines. Nevertheless, recent DOM fuzzers like
Domato use various context-free grammars to describe an HTML
document. Such a static grammar largely guarantees the syntactic
correctness of a generated input, but it is unable to describe every
data dependence throughout the input. As motivating examples,
we summarize the typical context-dependent values (CDVs) in a
document that Domato’s grammar cannot correctly describe.
CDV1: CSS selectors. CSS selectors explicitly refer to one or
more elements to be styled by id, class, or tag. Domato expresses
such references as shown in Figure 2(a). Basically, Domato only
considers a fixed number of HTML and SVG elements, a fixed
number of predefined class names, and all the HTML and SVG tags
for styling. The contradicted fact is that the number of elements
and the tags or class names available for reference in a document
randomly generated by Domato are undetermined before generation.
In practice, a document output by Domato probably has more than
30 HTML elements, only five SVG elements, or simply no 
elements, which are the counterexamples to the grammar rules
listed in Figure 2(a). In such cases, reference errors may occur;
meanwhile, particular valid elements are never utilized.
CDV2: CSS property. Certain CSS property values also refer
to existing elements. Normally, an element being referred to is
required to not only be live but also have a particular type according
Session 3E: Fuzzing/Trusted Execution Environments CCS '20, November 9–13, 2020, Virtual Event, USA973CCS ’20, November 9–13, 2020, Virtual Event, USA
Wen Xu, Soyeon Park, and Taesoo Kim
Figure 2: The grammar rules used by Domato that incorrectly generate four types of context-dependent values, including (a)
CSS selectors, (b) CSS property values, (c) attribute names, and (d) attribute values.
to the DOM standard. Nevertheless, Domato incorrectly describes
this data dependence as shown in Figure 2(b). Instead of any type of
element, the standard only allows an SVG  element and
an SVG  element to be used in the value of a clip-path
CSS property and a filter CSS property, respectively. Thus, those
CSS properties generated by Domato are likely not functional.
CDV3: Attribute name values. The attributes of an element are
referenced by their names for manipulating them. The validity of
such an attribute reference depends on the owner element of the
attribute, which is not fully presented by Domato’s grammar. First,
a number of previous DOM bugs involve dynamic updates of a
particular attribute of an element [7], which cannot be achieved
by Domato due to its lack of knowledge of what attributes ev-
ery existing element in a document has. For example, Domato
changes the value of a from attribute of any SVG element through
setAttribute() in Figure 2(d). However, from is only valid for an
SVG animation element. In addition, an SVG  element
uses its attributeName attribute to indicate a particular attribute
of its parent element to be animated [52]. Being unaware of what
element the  element exactly serves, Domato randomly
sets attributeName to any animatable SVG attribute, as described
in Figure 2(c). For instance, Domato probably generates a worthless
 element that tries to change the non-existent x attribute
of a  element.
CDV4: Attribute values. First, similar to CSS selectors and prop-
erty values, the value of a particular attribute (e.g., form and usemap)
involves a reference to an element of a specific type (e.g., 
and ), which is again not correctly described by Domato, as
shown in Figure 2(d). More importantly, an attribute value can also
have implicit dependence on other attribute values. Regarding an
 element, the value of the from attribute is determined by
the value of the sibling attribute, attributeName. Without know-
ing the exact value ever generated for the attributeName, the only
option for Domato is to statelessly specify some common attribute
values for the from, as listed in Figure 2(d), which does not take
effect at most times.
Summary. The dilemma of an existing DOM fuzzer based on a
context-free grammar is that the grammar predefines a random
approach to generate every possible unit of an HTML docu-
ment but cannot anticipate the exact unit values eventually
concretized in a document. Unfortunately, avoiding semantic
errors during generation requires being aware of those concrete
values. By contrast, FreeDom always memorizes the values that
have been generated (i.e., context information) in the current
document for generating new values afterwards.
3.2 Exploring Coverage-guided DOM Fuzzing
Most emerging fuzzers adopt a coverage-driven mutation-based
approach, which is proven to be effective in practice [18, 25, 57].
Nevertheless, as of now, pure generation-based fuzzing with no
runtime feedback is still the dominant approach for finding DOM
engine bugs. Meanwhile, no public research aims to understand
whether or not coverage-guided mutation-based fuzzing outper-
forms blackbox fuzzing against DOM engines. In other words, the
optimal design of a DOM fuzzer is still an open problem. To deter-
mine the answer, we cannot directly utilize existing DOM fuzzers
but design and implement a new one (i.e., FreeDom) for two pri-
mary reasons.
Stateless testcases. First, those fuzzers output final documents
in plaintext for one-time testing. Due to the lack of the detailed
context that originates from the use of static grammars, it is difficult
to extend such fuzzers to comprehensively mutate the documents
they generate. For instance, though the author of Domato imple-
ments an extension that enables mutation [12], the only supported
type of mutation is to append new data to an existing document.
Meanwhile, all the other known mutation strategies, such as flip-
ping and splicing existing data [25, 57] and merging two or more
existing inputs [20, 21], are not feasible over plaintext. The exten-
sion is thus incapable of achieving the full potential of mutation.
By contrast, FreeDom uses an intermediate representation called
FD-IR to present a document with stateful structures. FD-IR carries
detailed context information to ensure the semantic correctness of
a document after all sorts of mutations.
Low-throughput executions. Unlike many other general applica-
tions, a browser never automatically terminates without any user in-
teraction. More importantly, particular DOM-rendering tasks such
as animations and timing events can be scheduled on-the-fly. There-
fore, managing the lifetime of a browser instance becomes chal-
lenging. The common solution adopted by existing DOM fuzzers
is to run every browser instance with a conservative time limit.
By default, ClusterFuzz tests an input for at most 10 seconds. This
setting is reasonable for generation-based fuzzing, where a gener-
ated input has certain complexity and is more likely to consume
much time to be rendered. However, always using several seconds
to execute an input largely degrades the performance of mutation-
based fuzzing. From our observation, a WebKit window becomes
completely idle after 1 second when loading more than 60% of the
documents generated by Domato, which generally have sizes of
more than 200K bytes. Most inputs processed by a mutation-based
fuzzer have a much smaller size, which do not require such a long
execution time. Therefore, FreeDom applies a workaround that
 = htmlvar0000     = svgvar0000 = class                             = a | abbr| acronym | ...   = a | altGlyph| altGlyphDef| ... = # = # = animate   / = attributeName="x" from="" = attributeName="y" from="" = attributeName="d" from=""... and many more..setAttribute("from",""); =  |  | currentColor| , |   |    | inherit | visible | none | hidden | inline(a)(b)(c)(d) = .                                                    = # =  =  =  = filter:  = url() = clip-path:  = url()… and many more. =  = #Session 3E: Fuzzing/Trusted Execution Environments CCS '20, November 9–13, 2020, Virtual Event, USA974FreeDom: Engineering a State-of-the-Art DOM Fuzzer
CCS ’20, November 9–13, 2020, Virtual Event, USA
dynamically terminates a browser instance when the processing of
an input document mostly completes.
Summary. Building a mutation-based DOM fuzzer has two
unsolved challenges: (1) describing documents in mutable struc-
tures rather than in text and (2) improving browser throughput.
As the first known fuzzer that fully supports coverage-guided
mutation-based DOM fuzzing in practice, FreeDom adopts a
stateful IR for context-aware document mutation and optimizes
browser throughput with dynamic termination.
4 DESIGN
4.1 Overview
FreeDom is a distributed DOM fuzzer that can perform either black-
box generation-based fuzzing or coverage-guided mutation-based
fuzzing. Figure 3 illustrates the overall design of FreeDom. Basically,
a number of FreeDom instances run in a cluster and communicate
with a central server that manages all the fuzzing data. The testcases
processed by FreeDom, namely, HTML documents, are described
in FD-IR, which presents document structures along with context
information. When doing generation-based fuzzing, a FreeDom in-
stance repeatedly generates new documents in FD-IR, each of which
is lowered into an HTML file and opened by a browser instance.
If the browser crashes, a crash report that includes the crashing
input is uploaded to the server. In coverage-guided fuzzing, the
central server not only collects crashes but also maintains (1) a
queue that stores the testcases that discover new code paths and
(2) a global coverage map. A fuzzer instance iteratively fetches a
document in FD-IR from the queue and generates new documents
for testing by mutating different parts of it or merging it with an-
other document. The DOM engine of the browser is instrumented
for coverage measurement. Every newly generated document that
increases overall coverage is saved by the central server for further
mutation. In addition, FreeDom targets a high-throughput browser
in coverage-guided fuzzing. To avoid waiting for a long time to be
terminated by a preset timeout, the optimized browser instance
exits with an on-demand timeout installed by itself at the time it
completes loading the entire document. In the following paragraphs,
we use FDg and FDm to notate FreeDom working with generation
and coverage-guided mutation, respectively.
4.2 Context-aware Document Representation
FreeDom uses a custom intermediate representation called FD-IR
to describe both the syntax and semantics of an HTML document.
FD-IR strictly follows the DOM specification. Hence, a document in
FD-IR can be directly lowered into a real document in plaintext for
testing. More importantly, FD-IR carries the context information
to generate documents with fewer semantic errors.
4.2.1 Document Context. FreeDom maintains two types of con-
texts in FD-IR to enable context-aware fuzzing.
Global context. FD-IR maintains a tree structure that records all
the elements and their tags and attributes contained in the initial
DOM tree for reference. FD-IR also keeps track of all the avail-
able tokens (e.g., class names, CSS counter names, CSS keyframes
Figure 3: Overview of FreeDom’s architecture and work-
flow. FD-IR is a context-aware IR for describing HTML doc-
uments, which supports random generation and mutation.
names, etc.). Note that the in-tree elements and tokens are sepa-
rately organized by FD-IR into two maps, which are indexed by
element and token type for performant queries. The global context
serves as a basis for constructing four types of context-dependent
values, summarized in §3.1, in a document.
Local contexts.
FD-IR describes a local context for every
JavaScript function, which is used to generate semantically correct
DOM API calls. The local context not only contains a reference
to the global context but also preserves every DOM object locally
defined by a particular API call in a distinct map. Different from
global elements that can be used by any API call in a function,
the local objects are only valid after being defined. Therefore,
FD-IR is also aware of the exact location where (i.e., at which line)
the object is defined in order to support various API mutations
(see §4.3.2) and function merging (see §4.3.3).
4.2.2 Document Representation. We first introduce an important
interface of FD-IR called Value. As the first-class citizen in FD-IR,
Value is implemented to represent all sorts of data values that may
appear in a document, including but not limited to, CSS selectors,
CSS properties, attributes and arguments and return values of API
calls. In particular, a concrete Value involves the definition of three
indispensable methods:
(1) generate(), which specifies how to randomly generate the data
that forms the Value given the global or local context.
(2) mutate(), which defines how to randomly mutate the Value
with the global or local context.
(3) lower(), which describes how to turn the FD-IR Value into the
corresponding text string in a document.
A Value in FD-IR can be built upon one or more sub-Values. For
example, the top code in Figure 4 presents the description of a
CSS filter property. The property itself is an FD-IR Value. And
its value is defined as CSSFilterValue, which is another Value that
can be either literal or context-dependent. Most basic Values like
CSSFilterValue that do not contain any other Values simply mutate
through regeneration. A compound Value such as CSSProperty
selectively mutates its contained Values (Line 6). However, the
FD-IR Values that serve as a part of the context to be referred to
by other Values are immutable once generated. For instance, the
bottom code in Figure 4 describes ReturnValue, which represents a
FreeDomGenerator...CSS MutatorDOMTree MutatorJS MutatorMergerFuzzing EngineBlackbox FuzzingCoverage-guided FuzzingFD-IRHTMLLoweringExecutionWeb BrowserCrashReportsCorpusCoverageMapCentral ServerFD-IR §4.2 §4.4 §4.3.1 §4.3.3 §4.3.2Session 3E: Fuzzing/Trusted Execution Environments CCS '20, November 9–13, 2020, Virtual Event, USA975CCS ’20, November 9–13, 2020, Virtual Event, USA
Wen Xu, Soyeon Park, and Taesoo Kim
def generate(ctx): self.value.generate(ctx)
def mutate(ctx): self.value.mutate(ctx)
def lower(): return "{}: {}".format(name, lower(value))
super().__init__("filter", CSSFilterValue())
def __init__(name, value):
self.name = name
self.value = value
1 class CSSProperty(Value):
2
3
4
5
6
7
8
9 class CSSFilter(CSSProperty):
10
def __init__(name, value):
11
12
13 # filter: blur(5px) / url(#id)
14 class CSSFilterValue(Value):
15
16
17
18
19
20
21
22
23
24
def generate(ctx):
self.ref = None
if Random.bool():
def mutate(ctx): generate(ctx)
def lower():
self.ref = ctx.getElement("SVGFilterElement")
if self.ref is not None: return
self.value = "blur({})".format(Random.length())
if self.ref is None: return value
else: return "url(#{})".format(self.ref.id)
if self.ref is None:
self.ref = ctx.createObject(self.type)
def generate(ctx): # Here ctx is the local context
def __init__(t):
self.type = t
self.ref = None
def mutate(ctx): pass
def lower(): return self.ref.id
1 class ReturnValue(Value):
2
3
4
5
6
7
8
9
Figure 4: Two non-trivial Value instances in FD-IR, includ-
ing a CSS filter property, whose generation and mutation
depend on the context, and a return value of a DOM API call,
which updates the context when being generated and thus
becomes immutable. Note that a filter property has many
more value choices, which are omitted here.
return value of an API call. Its mutate() method is empty because
its generation introduces a new object into the local context. If
the return value were regenerated, the uses of the object in the
subsequent API calls would become invalid. Another example is
an attributeName attribute that decides the value of its sibling
attributes such as from (see §3.1). Based on Value, FD-IR manages
to describe the three parts of a document as follows.
The DOM tree. As mentioned in §4.2.1, FD-IR intuitively uses
a multi-branch tree to describe the DOM tree, whose nodes are
DOM elements and whose root is the only  element. In each
element node, FD-IR records its type, a unique id for reference, a list
of child nodes, and a list of attributes. Each attribute is a particular
Value instance.
CSS rules. FD-IR also records a list of CSS rules in a document.
For each rule, FD-IR maintains a list of CSS selectors and a list of
CSS properties, all of which are Value instances.
Event handlers. FD-IR maintains a list of event handlers for an
HTML document. Among them, one event handler, which is the
onload event handler of the  element, is treated specially as
the main event handler. The total number of other event handlers
in a document is predefined by FreeDom, which never increases
during mutation. Each event handler is composed of a list of DOM
API calls and the local context described in §4.2.1. FD-IR supports