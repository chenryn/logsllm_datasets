API =
In the above statement, B, B1 and C are constructed adversaries. This theorem allows us to
focus on the main result proven in EasyCrypt in the rest of this section, namely that the KMS
Domain Management API satisﬁes indistinguishability-based security.
5.2 Low-level abstractions
We now describe the lower layer in the EasyCrypt development, which deﬁnes and instantiates three
reusable abstractions that are then used as black-box modules in the proof of indistinguishability-
based security. The ﬁrst abstraction is a generic signature service, which we use multiple times in
the proof and can be reused in future EasyCrypt developments. The second abstraction is speciﬁc
to AWS KMS, and it was created for managing the complexity of the proof by black-boxing the
guarantees provided by the combined actions of HSMs and human operators in domain manage-
ment. The third abstraction is the multi-recipient public-key encryption scheme, which is only used
once in the main proof of security, but is meant for reuse in future EasyCrypt developments.
The ideal signature service abstraction. A central component in our modeling of the protocol and
its proof of security (in both versions) is the signature service abstraction. We introduce a module
called RealSignatureServ with an external interface that permits creating stateless signers, each with an
independent signing key.
This service oﬀers a signature veriﬁcation procedure that works as a pure operator based on the
public key and uses the signature veriﬁcation algorithm for the underlying signature scheme. This
means that any protocol using a digital signature with multiple signers and arbitrary veriﬁers that
have access to the public keys can be described as a client to the real signature service. We then
show that the standard property of unforgeability implies that this service is indistinguishable from
an ideal one in which signature veriﬁcation is now carried out by checking a list of signed messages.
The proof of security of the protocol relies on two instances of this abstraction, one for operator
signatures and another one for HSM signatures. When using this abstraction, one ﬁrst rewrites the
description of the protocol as a function of the RealSignatureServ, which is always possible. Then we
can use the fact that no adversary can distinguish this service from its ideal counterpart to modify
the protocol into another one that uses a table-based idealized representation for signatures. From
that point on, we can write invariants that refer to these idealized tables, which contain domain
tokens/trusts (resp. identity attestations) if and only if they have been signed by genuine HSMs
(resp. operators).
18
Domain Management Abstraction. We deﬁne a general notion of a domain management policy, for
which we specify security in terms of distinguishing a real policy enforcement mechanism from an
ideal policy enforcement mechanism.
Figure 10 details the module which captures the notion of a domain management policy based on
the actions of hosts, operators and HSMs we have introduced in Section 3. This module maintains
two data structures that keep track of the trusts manipulated by the system: protectedTrusts and
parentTrust. Protected trusts are those that contain only genuine parties; this can happen because
the trust is directly checked by operators in the isGoodInitialTrust operation to be a good initial trust,
or because an HSM has checked that it is a valid descendant of a protected trust in checkTrustUpdate.
The descendant relation is maintained using the parentTrust map.
The idealized version of the abstraction, which we omit for brevity, oﬀers the same functionality
as the real one, but ensures the following invariants:
i. All protected trusts contain only genuine HSM members and they descend from a protected
trust.
ii. The descendant relation computed by HSMs behaves like an injective function—any trust has
at most one valid parent throughout the lifetime of the system. This relation can be checked by
hosts, if it has been computed by HSMs.
Intuitively this proof follows in the lines of the invariant described in Section 3. Note that this
abstraction does not require genuine hosts or HSMs to be able to tell whether a trust was previously
checked by a genuine HSM: it only speaks about trusts that have been tagged as protected. More
precisely, the ideal policy says that, if a trust was previously tagged as protected, then the honest
property is propagated and a genuine host will have the same view of the descendant relation;
otherwise no guarantee is given.
In the main proof, which we discuss in the next subsection, we strengthen the security guarantee
provided by this abstraction, relying on the authentication guarantees inherent to the signed trust
data structure: looking ahead, we will use the fact that any trust for which the honesty property
has been established must have been signed by a genuine HSM.
The following EasyCrypt theorem provides a concrete bound for any adversary distinguishing
the real policy management module from its idealized version for the KMS Domain Management
policy enforced by operators and HSMs. The bound is given by the collision resistance property of
the hash function used to compute trust ﬁngerprints, and the unforgeability advantage against the
signature scheme used by operators to certify identity keys, scaled up by the maximum number of
operators in the system q ops.24
lemma domain management:
|Pr[TrustSecInd(A,IdealTrustService(OAR)).main():res]
− Pr[TrustSecInd(A,RealTrustService(OAR)).main():res]| ≤
Pr[CR(AdvCR(A)).main():res] + q ops ∗ Pr[UF1(AdvUF1(A)).main():res].
where OAR=OA(RealSigServ)
Multi-recipient PKE Abstraction. The security proof of the main theorem relies on a tag-based
multi-recipient public-key encryption abstraction. As a contribution of independent interest, we
show that the variant of DHIES [2] used by the DMP to create domain tokes satisﬁes this notion
of security. The IND-CCA security of this construction follows from the results in [2], together
24 We note that our formalization relies on a unkeyed hash function. As we give concrete security reductions, our
results are meaningful for unkeyed cryptographic hash functions used in practice, as discussed for example in [20].
Modifying the proof to support a keyed hash function would be straightforward, but would require the assumption
that every entity in the system can be set-up with the same key.
19
module RealTrustService(OA : OperatorActions) : TrustService = {
var protectedTrusts : Trust fset
var parentTrust : (Trust,Trust) fmap
proc newOp = OpPolSrv(OA).newOp
proc addHId = OpPolSrv(OA).addHId
proc requestAuthorization = OpPolSrv(OA).requestAuthorization
proc newHst = HstPolSrv.newHst
proc installInitialTrust = HstPolSrv.installInitialTrust
proc installUpdatedTrust = HstPolSrv.installUpdatedTrust
proc isInstalledTrust = HstPolSrv.isInstalledTrust
proc isGoodInitialTrust(trust: Trust) = {
b ← OpPolSrv(OA).isGoodInitialTrust(tr data trust);
if (b) protectedTrusts ← protectedTrusts | fset1 trust;
return b; }
proc checkTrustUpdate(old:Trust, new:Trust, auth:Authorizations) : bool = {
c ← HSMPolSrv.checkTrustUpdate(old,new,auth);
protected ← old ∈ protectedTrusts;
if (c) {
if (¬new ∈ parentTrust) parentTrust[new] ← old;
if (protected) protectedTrusts ← protectedTrusts | fset1 new;
}
return c; }
proc isProtectedTrust(trust : Trust) : bool = {
return trust ∈ protectedTrusts; }
· · ·
}.
Fig. 10. Domain management policy abstraction.
∗
decrypting any pair (t, c) (cid:54)= (t∗, cph
with the general results on multi-recipient encryption in [8]. We also extend the result to the tag-
based setting of Shoup [21], in which encryption takes a tag t and the decryption oracle permits
) was returned from the left-or-right oracle.
This extension is crucial to show that a malicious HSM cannot modify an honest token to change
the trust, in a way that decrypts successfully.
∗
), where (t∗, cph
5.3 Main Theorem
The proof of indistinguishability security is carried out using the game-hopping technique. The ﬁrst
hop shows that the KMS Domain Management protocol can be re-expressed using the signature
service and policy management abstractions introduced in the previous subsection. This hop is
conservative, and introduces no additional terms in the security bound. The second and third hops
consist of replacing the signature abstraction and the policy management abstraction with their
ideal counterparts. These hops show that any adversary distinguishing the two games in the hop
can be used to break the real-ideal indistinguishability guarantee for the low level abstractions,
which we showed in the previous subsection can be, in turn, reduced to the security of standard
cryptographic primitives.
At this point we perform a conservative hop that entails the most innovative part of the entire
security proof. Here we combine two types of reasoning: 1) the inductive argument that establishes
the propagation of trust honesty as discussed above; and 2) the global invariants guaranteeing the
absence of collisions between trust ﬁngerprints, and of signature forgeries. Together, these justify a
game hop that slices the entire code of the indistinguishability game, isolating protected (honest)
trusts from the remaining ones and enforces that the Test oracle can only be called by the adversary
on protected trusts.
20
Furthermore, the game no longer relies on public-key decryption to recover domain-keys when