title:Why Is CSP Failing? Trends and Challenges in CSP Adoption
author:Michael Weissbacher and
Tobias Lauinger and
William K. Robertson
Why Is CSP Failing? Trends and Challenges
in CSP Adoption
Michael Weissbacher, Tobias Lauinger, and William Robertson
Northeastern University, Boston, USA
{mw,toby,wkr}@ccs.neu.edu
Abstract. Content Security Policy (CSP) has been proposed as a prin-
cipled and robust browser security mechanism against content injection
attacks such as XSS. When conﬁgured correctly, CSP renders malicious
code injection and data exﬁltration exceedingly diﬃcult for attackers.
However, despite the promise of these security beneﬁts and being imple-
mented in almost all major browsers, CSP adoption is minuscule—our
measurements show that CSP is deployed in enforcement mode on only
1% of the Alexa Top 100.
In this paper, we present the results of a long-term study to deter-
mine challenges in CSP deployments that can prevent wide adoption.
We performed weekly crawls of the Alexa Top 1M to measure adoption
of web security headers, and ﬁnd that CSP both signiﬁcantly lags other
security headers, and that the policies in use are often ineﬀective at
actually preventing content injection. In addition, we evaluate the fea-
sibility of deploying CSP from the perspective of a security-conscious
website operator. We used an incremental deployment approach through
CSP’s report-only mode on four websites, collecting over 10M reports.
Furthermore, we used semi-automated policy generation through web
application crawling on a set of popular websites. We found both that
automated methods do not suﬃce and that signiﬁcant barriers exist to
producing accurate results.
Finally, based on our observations, we suggest several improvements
to CSP that could help to ease its adoption by the web community.
Keywords: Content Security Policy, Cross-Site Scripting, Web Security.
1
Introduction
The web as a platform for application development and distribution has evolved
faster than it could be secured. Consequently, it has been plagued by numerous
classes of security issues, but perhaps none are as serious as content injection
attacks. Content injection, of which cross-site scripting (XSS) is the most well-
known form, allows attackers to execute malicious code that appears to belong
to trusted origins, to subvert the intended structure of documents, to exﬁltrate
sensitive user information, and to perform unauthorized actions on behalf of
victims. In response, many client- and server-side defenses against content injec-
tion have been proposed, ranging from language-based auto-sanitization [17] to
sandboxing of untrusted content [12] to whitelists of trusted content [11].
A. Stavrou et al. (Eds.): RAID 2014, LNCS 8688, pp. 212–233, 2014.
c(cid:2) Springer International Publishing Switzerland 2014
Why Is CSP Failing? Trends and Challenges in CSP Adoption
213
Content Security Policy (CSP) is an especially promising browser-based secu-
rity framework for reﬁning the same-origin policy (SOP), the basis of traditional
web security. CSP allows developers or administrators to explicitly deﬁne, using a
declarative policy language, the origins from which diﬀerent classes of content can
be included into a document. Policies are sent by the server in a special security
header, and a browser supporting the standard is then responsible for enforcing
the policy on the client. CSP provides a principled and robust mechanism for pre-
venting the inclusion of malicious content in security-sensitive web applications.
However, despite its promise and implementation in almost all major browsers,
CSP is not widely used in practice—in fact, according to our measurements, it is
deployed in enforcement mode by only 1% of the Alexa Top 100.
In this paper, we present the results of a long-term study to determine why this
is the case. In particular, we repeatedly crawled the Alexa Top 1M to measure
adoption of web security headers, and ﬁnd that CSP signiﬁcantly lags behind
other, more narrowly-focused headers in adoption. We also ﬁnd that for the small
fraction of sites that have adopted CSP, it is often deployed in a manner that
does not leverage the full defensive power of CSP.
In addition to our Internet-scale study, we also quantify the feasibility of
incrementally deploying CSP from the perspective of a security-conscious ad-
ministrator using its report-only mode at four websites. Although this is an oft-
recommended practice, we ﬁnd signiﬁcant barriers to this approach in practice
due to interactions with browser extensions and the evolution of web application
structure over time.
Finally, we evaluate the feasibility of automatically generating CSP rules for
web applications, again from the perspective of an administrator. We ﬁnd that for
websites that are well-structured and do not change signiﬁcantly over time, rules
can indeed by generated in a black-box fashion. However, for more complex sites
such as those that make use of third-party advertising libraries in their proper
site context, policy generation is signiﬁcantly more diﬃcult.
To summarize, the contributions of this paper are the following:
– We perform the ﬁrst long-term analysis of CSP adoption in the wild, per-
forming repeated crawls of the Alexa Top 1M over a 16 month period.
– We investigate challenges in adopting CSP, and why it is not deployed to its
full extent even when it has been adopted.
– We evaluate the feasibility of both report-only incremental deployment and
crawler-based rule generation, and show that each approach has fundamental
problems.
– We suggest several avenues for enhancing CSP to ease its adoption.
– We release an open source CSP parsing and manipulation library. 1
2 Content Security Policy
The goal of CSP is to mitigate content injection attacks against web applications
directly within the browser [6, 19]. In the following, we describe CSP as it is
1
https://github.com/tlauinger/csp-utils
214
M. Weissbacher, T. Lauinger, and W. Robertson
Table 1. The types of directives supported in the current W3C standard CSP 1.0
Directive
Content Sources
default-src
script-src
object-src
style-src
img-src
media-src
frame-src
font-src
connect-src
All types, if not otherwise explicitly speciﬁed
JavaScript, XSLT
Plugins, such as Flash players
Styles, such as CSS
Images
Video and audio (HTML5)
Pages displayed inside frames
Font ﬁles
Targets of XMLHttpRequest, WebSockets
currently implemented, and brieﬂy discuss both future extensions and the classes
of attacks it is intended to prevent.
2.1 Overview of CSP
Content Security Policy is fundamentally a speciﬁcation for deﬁning policies
to control where content can be loaded from, granting signiﬁcant power to de-
velopers to reﬁne the default SOP. Developers or administrators can conﬁgure
web servers to include Content-Security-Policy headers as part of the HTTP
responses issued to browsers. CSP-enabled browsers are then responsible for en-
forcing the policies associated with each resource.
A content security policy consists of a set of directives. Each directive corre-
sponds to a speciﬁc type of resource, and speciﬁes the set of origins from which
resources of that type may be loaded. Table 1 explains the directive types sup-
ported in the current W3C standard CSP 1.0.2 The scheme and port in source
expressions are optional.
CSP also supports wildcards (*) for subdomains and the port, and has ad-
ditional special keywords: ‘self’ represents the origin of the resource, while
‘none’ represents an empty resource list and prevents any resource of the re-
spective type from being loaded. The script-src and style-src directives
additionally support the ‘unsafe-inline’ keyword, which allows inline script
or CSS to be included in the HTML document rather than being loaded from an
external resource. Finally, ‘unsafe-eval’ allows JavaScript to use string evalu-
ation methods such as eval() and setTimeout(). If not explicitly whitelisted,
CSP disables these special source types because their use is considered to be par-
ticularly unsafe. However, changing websites to remove all inline scripts can be a
burden on developers, and increase page load latency by introducing additional
external resources.
2 The directive script-src http://seclab.nu:80, for instance, allows a protected
website to load scripts from the host seclab.nu via HTTP on port 80, but blocks
all scripts from other sources
Why Is CSP Failing? Trends and Challenges in CSP Adoption
215
CSP can operate in one of two modes: enforcement or report-only. In en-
forcement mode, compatible browsers block resources that violate a policy. In
report-only mode, however, browsers do not enforce policies, but rather report
violations that would be blocked on the developer console. Additionally, a special
CSP directive (report-uri) can be used to instruct browsers to send violation
reports to the given URI. This feature can be used to learn policies before en-
abling enforcement, or to monitor for unforeseen changes or attacks against a
website. In this paper, we make extensive use of the report-only mode and vio-
lation reports to explore various ways to (semi-)automatically generate policies
for websites.
CSP has been widely adopted by the browser manufacturers. It is supported
by the current versions of almost all major browsers, including some mobile
browsers. It is, however, only partially supported by Internet Explorer.
2.2 Deploying CSP
To prevent XSS attacks, disallowing inline scripts and eval is the core require-
ment to beneﬁt from CSP. Inline scripts should be disabled to prevent the
browser from inadvertently executing scripts that have been injected into the
site. Eval-constructs, often abused to parse JSON strings, can be used directly
by an attacker to execute arbitrary code if she controls the data source. While
the unsafe-inline and unsafe-eval options allow this behavior to be enabled,
their presence marginalizes the beneﬁt of CSP.
Therefore, for version 1.0 of CSP, inline scripts should be moved to ﬁles
and eval replaced with a safe equivalent for the corresponding task, such as
JSON.parse() to parse JSON. Furthermore, JavaScript should be hosted on
a domain that only serves static ﬁles instead of user content. This separation
makes it harder for attackers to execute code in the browser. Also, external
scripts should be moved to a server controlled by the website owner, reducing
trust in third-party servers. The number of whitelisted sources should be kept
to a minimum to increase the diﬃculty of data exﬁltration for attackers.
In the current draft version 1.1, additional features have been introduced to
safely support inline scripts as well as functionally replace the X-Frame-Options
header. As these features are subject to change, we do not address them in this
work.
2.3 Attacks Outside the Scope of CSP
CSP can prevent general content injection attacks, and in draft version 1.1 sub-
sumes previous mechanisms such as the X-XSS-Protection header, which serves
the narrow purpose of enabling browser XSS ﬁlters. However, it is not intended
to address other web attacks such as cross-site request forgery (CSRF). More
fundamentally, CSP describes which content can be loaded by source, but the
order of inclusion is out of scope. Hence, even with strict rules and perfect en-
forcement, out-of-order inclusion can lead to undesired side eﬀects in JavaScript
applications [8]. JSONP (JSON with padding) is a mechanism to bypass SOP
216
M. Weissbacher, T. Lauinger, and W. Robertson
restrictions by including a script tag from a remote server and specifying a func-
tion to be executed once a result becomes available. Hence, whitelisted JSONP
sources can be used for calls to arbitrary functions—or, if input for the callback
function is not ﬁltered, arbitrary code execution.
3 HTTP Security Headers
In this section, we describe our data collection of HTTP response headers. We
collected this data in an eﬀort to understand the landscape of security headers
in the wild, particularly in regards to CSP.
3.1 Methodology
To acquire a long-term overview of CSP adoption, we performed weekly crawls of
the web starting in December 2012. We crawled the front page of each site in the
Alexa Top 1M most frequently visited websites. For every site x, we connected
to http://x, https://x, http://www.x and https://www.x. We counted a site
as using a particular header if any of the four responses served that header.
However, our crawler only visited the front page of each Alexa entry. Therefore,
sites that employ CSP only on subdomains or areas other than the front page
were not detected in the crawl.3 Furthermore, if the CSP rules are generated
based on user agent discrimination, the collected data does not hold for all types
of browsers visiting the site. We used a Firefox user agent string, updating version
information over time.
Description of HTTP Security Headers
To discuss CSP in context, we provide a brief overview of the other security
relevant HTTP response headers. Details about them can be found at IETF,
W3C, or in the browser speciﬁcations.
Platform for Privacy Preferences (P3P) [2]. Websites can use this header
to describe their privacy policy. However, it is not supported by major browsers
and has not been actively developed for several years. The header is still in use
as Internet Explorer blocks third-party cookies by default if no policy is present.
P3P is legally binding and has been used in litigation in the past.
DNS Prefetch Control [1]. DNS prefetching is a technique for browsers
to reduce latency by resolving referenced hostnames before a user follows a link.
This header allows websites to override the default behavior of the browser.
XSS Protection [3]. This header can be used to enable or disable client-side
heuristic XSS ﬁltering. The reflected-xss directive of CSP 1.1 is functionally
equivalent.
Content Type Options [4]. As the Content-Type header is often not set
correctly, MIME type sniﬃng can be used to detect the actual response content
3 One example is Twitter, which uses CSP for parts of their site, but not the front
page.
Why Is CSP Failing? Trends and Challenges in CSP Adoption
217
type. The nosniff directive is the only option available for this header and
disables MIME type sniﬃng, preventing possible type confusion.
Frame Options [9]. This header allows a website to restrict iframing to
prevent UI redressing attacks. CSP draft 1.1 includes these features under the
frame-ancestors directive, and may replace this header.
HTTP Strict Transport Security (HSTS) [5]. By using HSTS, websites
can specify that in the future, the browser should only connect to them via a
secure connection, thereby preventing SSL stripping.
Cross-Origin Resource Sharing (CORS) [7]. SOP has proven to be an
obstacle for modern web applications, and has been worked around by various
methods such as JSONP. CORS allows websites to operate outside the limita-
tions of SOP by extending it, while not completely side-stepping it.
3.2 Adoption of HTTP Security Headers
To measure the popularity of CSP in contrast to other security headers, we
looked at the HTTP response headers in our weekly crawls, as well as a static
snapshot from the end of March 2014. For the static snapshot, we used the entire
Alexa Top 1M, breaking down websites by popularity. We used a snapshot of
the Top 10K to track the evolution of response headers back to December 2012.
To compare the adoption of security-related headers between diﬀerent levels
of site popularity, we split Table 2 into brackets. From the data, it is apparent
that websites that are less popular use CSP less frequently. For instance, among
the 100 most popular sites, only two used CSP (2%), while CSP was enabled for
only 775 among the 900,000 least popular sites (0.00086%).
Hence, websites that are less popular use CSP less frequently. In contrast, for
CORS, header usage was more evenly spread out, with all brackets between 0.7%
and 2.6%.
During our crawls, we noticed that Google enabled CSP headers only occa-
sionally. We performed an additional test of google.com with 1,000 requests,
ﬁnding that 0.8% of the responses included CSP headers. While Google had 18
sites in the top 100, none of them issued CSP headers in the crawl of Table 2.
In Figure 1, we track the evolution of security-related headers of the Alexa Top
10K from March 2014 backwards in time to December 2012. P3P was particularly
popular; however, the P3P policies served were often invalid, providing only an
explanation for why the website did not support it. We observe that CSP is
only slowly gaining traction over time. The main contributing factor for the
ﬂuctuation of CSP headers in the data is due to Google.
For the hosts in the Top 10K of this crawl, we identiﬁed all servers that had
sent CSP rules at any point in time during our study. We found 140 sites that
did so; 110 of those belonged to Google (79%).
3.3 Detailed Analysis of CSP Headers
In this part, we describe in detail how websites use CSP, whether they use CSP’s
reporting feature to learn policies, whether they actively enforce policies, and
how eﬀective those policies are in mitigating attacks.
218
M. Weissbacher, T. Lauinger, and W. Robertson
Table 2. Number of websites with security-related HTTP response headers, grouped
by intervals of site popularity, for the Alexa Top 1M ranking
Header / Alexa Rank [1 − 102] (102 − 103] (103 − 104] (104 − 105] (105 − 106]
P3P
DNS Prefetch Control
XSS Protection
Content Type Options
Frame Options
HSTS
CORS
CSP
43,045
42,150
21,746
2,475
7,149
775
849
3
269
172
581
83
217
15
176
0
77
27
165
16
26
2
47
1
26
10
43
5
1
2
6,315
40
2,336
1,995
2,747
476
1,228
57
79,600
461
Any security header
66