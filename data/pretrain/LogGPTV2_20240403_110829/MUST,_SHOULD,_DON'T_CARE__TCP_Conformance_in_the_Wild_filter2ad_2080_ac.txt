### Heterogeneous and Globally Distributed Targets

The dataset includes a diverse set of globally distributed targets. Each target is identified by an IPv4 address and a successfully scanned port. Additionally, many targets provide information on the host, vendor, operating system (OS), and product. Using the dataset compiled on August 8th, 2019, 10,559,985 Censys targets were identified with reachable ports 80 or 443. These targets include, but are not limited to, IoT devices, customer-premises equipment, industrial control systems, remote-control interfaces, and network infrastructure appliances. After removing duplicate IP addresses and applying blacklist filtering, we arrive at 3,237,086 unique Censys target hosts.

### Ethical Considerations

We aim to minimize the impact of our active scans as much as possible. First, we follow standard practices [26] by displaying the intent of our scans in rDNS records of our scan IPs and on a website with an opt-out mechanism accessible via each scan IP. We also honor opt-out requests from previous measurements and exclude these hosts. 

Furthermore, we evaluated the potential implications of the uIP/Contiki crash observed in Section 3.3. Embedded microcontrollers, commonly used in IoT devices, are the primary use case for uIP/Contiki. Although we could not identify hosts using this stack in the Censys device type data, we assume minimal to very little use of this software stack within our datasets. This assumption is supported by the observation that 100% of failed targets in the CDN and Alexa datasets, and 99.35% of failed targets in the Censys dataset, remain reachable after executing the UrgentPointer test case. Therefore, we argue that our scans have not caused any harm to the Internet at large.

### Results and Discussion

#### Conformance Testing Results

We now discuss the results of our conformance testing, summarized in Table 3. The table shows the relative results per test case for all reachable target hosts, excluding those that were unreachable. Given that the target data was derived from respective sources multiple days before executing the tests (see Section 4.1), some targets were expected to be unreachable. Approximately 12% of targets could not be reached in each test case and were removed from the results. While the CDN and Alexa datasets were derived from sources featuring popular websites, we expected a significant overlap of target hosts, which was confirmed by 15,387 targets present in both datasets. Alexa and Censys share only 246 target hosts, while CDN and Censys do not overlap. All datasets are publicly available [5]. The classification of conditions as PASS, UNK, FTarget, or FPath varies between test cases based on their architecture (see Section 3.2) and is discussed in detail next.

#### TCP Checksum

We start with the results of our checksum tests, which validate correct checksum handling. As shown in Table 3, CDNs have a low failure rate for both tests, and we did not find any evidence of on-path modifications. In contrast, hosts from the Alexa and Censys datasets show over 3% FTarget failures. Upon further analysis, these hosts naturally cluster into two classes based on AS ownership. On one hand, we find ASes (e.g., Amazon) where approximately 7% of all hosts fail both tests. Given the low share, these hosts could be purpose-built high-performance VMs, such as TCP-terminating proxies that do not handle checksums correctly. On the other hand, we find ASes (e.g., hosted in the QRATOR filtering AS) where nearly all hosts in that AS fail the tests. Since QRATOR offers a DDoS protection service, it is a likely candidate for operating a special-purpose stack.

**Takeaway:** We found instances of hosts that do not correctly handle checksums. While incorrect checksums may be a niche problem, these findings highlight that attackers with access to the unencrypted payload but without access to the headers could alter segments and have the modified data accepted.

#### TCP Options

Next, we study the ability to use TCP options, which is crucial for future TCP extensibility. In our four option tests (see Table 3 for an overview), we observe overall the lowest failure rates, indicating generally good support for extensibility. The Censys dataset shows the most failures, particularly in the OptionSupport and MSSMissing tests, which have the highest FPath (middlebox failures) across all tests. Both tests show a large overlap in affected hosts and likely have the same cause for the high path failure rates. These hosts are all located in ISP networks. For the MSSMissing failures, we observe that an MSS is inserted at these hosts—likely due to ISPs performing MSS clamping, e.g., due to PPPoE encapsulation by access routers. These routers need to rewrite the options header (to include the MSS option), and as the OptionSupport fails when some EOOL and NOOP are stripped, the exact number of EOOL and NOOP are likely not preserved. Inserting the MSS option alters the originally intended behavior of the sender, i.e., having an MSS of 536 bytes for IPv4. In this special case, the clamping actually increased the MSS, thereby stripping some of the EOOL and NOOP options.

Looking at the OptionUnknown test, where we send an option with an unallocated codepoint, we again see low FPath failures, but a non-negligible number of FTarget fails. There is no single AS that stands out in terms of the share of hosts that fail this test. However, we observe that among the ASes with the highest failure rates are ISPs and companies operating Cable networks.

Lastly, the MSSSupport test, which validates the correct handling of MSS values, shows comparably high conformance. As we were unable to clearly pinpoint the failures to specific ASes, the most likely cause can be traced to non-conformant operating systems, as shown by our validation (see Section 3.3), where Windows fails this test and likely others that we did not test in isolation.

**Takeaway:** Our TCP options tests show the highest level of conformance of all tests, a good sign for extensibility. However, we find cases of middlebox interference, mostly MSS injectors and option padding removers—primarily in ISP networks, hinting at home gateways. Neither is inherently harmful due to path MTU discovery and the voluntary nature of option padding.

#### TCP Flags

In addition to the previously tested options, TCP's extensibility is guaranteed by (im-)mutable control flags in its header, which toggle certain protocol behaviors. In the Reserved test, we identify the correct handling of unknown (future) flags by sending an unallocated flag and expecting no change in behavior. Instead, we surprisingly observe high failure rates across all datasets, most notably in CDNs. When inspecting the CDN dataset, we found approximately 10% of Akamai's hosts showing this behavior. We contacted Akamai, and they validated that their servers do not touch this bit. Further analysis revealed that the reserved flag on the SYN was truthfully ignored, but our test failed as the final ACK of the 3-way handshake (second part of the test, see Table 1), which also contains the reserved flag, was seemingly dropped as we received SYN/ACK retransmissions. This behavior originates from the usage of Linux's TCP DEFER ACCEPT socket option, which causes a socket to only wake up the user space process if there is data to be processed [10]. The socket will wait for the first data segment for a specified time, re-transmitting the SYN/ACK when the timer expires in the hope of stimulating a retransmission of possibly lost data. Since we were not sending any data, we eventually received a SYN/ACK retransmission, seemingly due to the dropped handshake-completing ACK with the reserved flag set. Hence, we initially credited the retransmission to the existence of the reserved flag, later uncovering that the retransmission was unrelated to the reserved flag but was actually expected behavior using the TCP DEFER ACCEPT socket option. Following up with Akamai, they were able to validate our assumption by revealing that parts of their services utilize this socket option. While it is certainly debatable if deliberately ignoring the received ACK is a violation of the TCP specification, our test fails to account for this corner case. Thus, connectivity is not impaired.

In contrast, connectivity is impaired in the cases where our reserved flag SYN fails to trigger a response at all, leaving the host unreachable (see Reserved-SYN in Table 3). The difference between both failure rates likely denotes hosts using the defer accept mechanism, as CDNs, in general, seem to comply with the standard. We also observe a significant drop in failures in the Alexa targets. While our results cannot definitively show if only defer accepts are the reason for this drop, they likely contribute significantly as TCP implementations would need to differentiate between a reserved flag on a SYN and on an ACK, which we believe is less likely. Our results motivate a more focused investigation of the use of socket options and the resulting protocol configurations and behavioral changes.

Lastly, the URG flag has been part of TCP since its inception, indicating data segments to be processed immediately. With the UrgentPointer test, we check if segments flagged as urgent are correctly received and acknowledged. To confirm our assumption that this test has minimal implications on hosts due to the uIP/Contiki crash (see Section 3.3), we checked if the FTarget instances were still reachable after test execution. Our results show that of these failed targets, 99.35% of Censys, and 100% of CDN and Alexa, responded to our subsequent connection requests, which were part of the following test case executed several hours later. While we argue that these unresponsive hosts can be explained by dynamic IP address assignment due to the fluctuating nature of targets in the Censys dataset, we recognize that the implicit check within the subsequent test case is problematic due to the time period between the tests and the possibility of devices and services being (automatically) restarted after crashing. We thus posit that future research should include explicit connectivity checks directly.