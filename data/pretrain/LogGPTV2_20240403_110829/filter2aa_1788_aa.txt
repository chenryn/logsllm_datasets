Microkernel development: 
from project to implementation 
Technical Notes 
Rodrigo Maximiano Antunes de Almeida 
PI:EMAIL 
Universidade Federal de Itajubá 
Summary 
This is the technical notes about the ESC talk: “Microkernel development: from project to 
implementation” given by Rodrigo Maximiano Antunes de Almeida, from Unifei. 
The talk consists of the design and implementation of a microkernel. The project will be developed on 
ISO-C without the standard libraries, in such a way that the code to be presented to the participants can be 
easily ported to any architecture and used as a basis for future projects. It will also be addressed the 
standardization of the procedures and hardware requisitions, encapsulated as drivers. Upon completion, the 
participants will have a better understanding about the kernel its advantages and restrictions. 
This documents presents in deeper details some of the topics that will be covered in the speech, mainly 
the theoretical ones. 
License 
This document is licensed under Creative Commons – Attribution – Non Commercial – Share Alike license. You're free to: 
to Share — to copy, distribute and transmit the work 
to Remix — to adapt the work 
Under the following conditions: 
Attribution — You must attribute the work (but not in any way that suggests that they endorse you or your use of the 
work). 
Noncommercial — You may not use this work for commercial purposes. 
Share Alike — If you alter, transform, or build upon this work, you may distribute the resulting work only under the 
same or similar license to this one.  
Index 
1 
Developing an embedded system .................................................................................................................... 1 
1.1 
System connections ........................................................................................................................................ 1 
2 
System programming ....................................................................................................................................... 3 
2.1 
Making access to the hardware ...................................................................................................................... 3 
2.2 
Accessing individual bits ................................................................................................................................. 3 
2.3 
LCD communication ........................................................................................................................................ 4 
2.4 
Analog reading ................................................................................................................................................ 6 
3 
First embedded firmware ................................................................................................................................ 8 
4 
What is a kernel? ............................................................................................................................................. 9 
5 
Kernel components ........................................................................................................................................ 10 
6 
Kernel Project ................................................................................................................................................ 11 
6.1 
Why to develop our own kernel? .................................................................................................................. 11 
6.2 
Alternatives ................................................................................................................................................... 11 
6.3 
Monolithic kernel versus microkernel ........................................................................................................... 11 
6.4 
Kernel design decisions: ................................................................................................................................ 12 
6.5 
This course decisions..................................................................................................................................... 12 
7 
Concepts ........................................................................................................................................................ 13 
7.1 
Function pointers .......................................................................................................................................... 13 
7.2 
First example ................................................................................................................................................. 14 
7.3 
Structs ........................................................................................................................................................... 15 
7.4 
Circular buffers .............................................................................................................................................. 15 
7.5 
Second Example ............................................................................................................................................ 16 
7.6 
Temporal conditions ...................................................................................................................................... 19 
7.7 
Third Example ............................................................................................................................................... 20 
8 
The Kernel ...................................................................................................................................................... 23 
9 
Building the device driver controller ............................................................................................................. 26 
9.1 
Device Driver Pattern .................................................................................................................................... 26 
9.2 
Controller engine .......................................................................................................................................... 26 
9.3 
Using the controller engine ........................................................................................................................... 27 
9.4 
Interesting situations .................................................................................................................................... 28 
9.5 
Driver callback ............................................................................................................................................... 29 
1 
 1  Developing an embedded system 
An embedded system is a system designed for a specific propose that has a microcontroller or a 
microprocessor as the central piece. The microcontroller has a software built exclusively to support the 
functionalities underlined in the embedded product. In order to build an embedded system, we must account 
for both hardware and software issues. 
The hardware part is composed by a microcontroller and other circuits that are responsible to make the 
interface between the microcontroller and the user or other microcontroller. The document that describes the 
way these components are connected is called a schematic. 
In this document we’re going to build a simple board with a microcontroller with a lcd. The way each of 
them must be connected depends on each component. In general their manufactures send an application note 
showing the default connection. 
For the system we’re going to use a pic18f4550 as the microcontroller unit, a HD77480 as LCD output 
interface and a regular potentiometer as input information. 
 1.1  System connections 
For the required system the connections will be made as in the following schematic 
This system can be connected using a protoboard as the image below. 
2 
3 
 2  System programming 
In order to correctly program the system, a dedicated programmer will be used. This programmer need 
some initial code to execute correctly. These codes are responsible to make the initial setup on the system. 
#pragma config MCLRE=ON                // Master Clear disable 
#pragma config FOSC=INTOSC_XT          // Internal oscilator 
#pragma config WDT=OFF                 // Watchdog disbled 
#pragma config LVP=OFF                 // Low voltage programming disabled 
#pragma config DEBUG=OFF 
#pragma config XINST=OFF               // Don’t use new processor instructions 
 2.1  Making access to the hardware 
All terminals are mapped in the RAM area. In order to access one terminal we need to first find the 
terminal address and than make a pointer to this address. The PORTD for example is connected in the 0xF83 
address. 
void main (void){ 
    char *ptr; 
    //pointing to the port D 
    ptr = 0xF83;  
    //changing all outputs to high 
    *ptr = 0xFF; 
} 
Another need to make the peripheral usable, the circuit direction must be defined as input or output. This 
is achieved by the TRIS register. The code below can blink all the leds connected on the PORTD. In order to 
simplify the port access a #define structure can be used to hide the pointer accesses. 
#define PORTD    (*(volatile __near unsigned char*)0xF83) 
#define TRISD    (*(volatile __near unsigned char*)0xF95) 
void main(void) { 
        TRISD = 0x00; 
        for(;;){ 
            PORTD ^= 0xFF; 
        } 
} 
 2.2  Accessing individual bits 
The address used is generally composed of eight bits, each one mapped to one terminal. In order to make 
individual accessing we need to use some binary manipulation, using bitwise operations. These operations can 
be made in a pseudo-function using the #define preprocessor 
//using define 
#define BitSet(arg,bit) ((arg) |=  (1 0; ms--) { 
        for (i = 0; i > 4; 
    pushNibble(val_upper, rs); 
    pushNibble(val_lower, rs); 
} 
The difference between a command or a data is the value on register select pin. 
5 
void lcdCommand(int value) { 
    pushByte(value, 0); 
    delayMicroseconds(40); 
} 
void lcdChar(char value) { 
    pushByte((unsigned int) value, 1); 
    delayMicroseconds(2); 
} 
The initialization requires a strict protocol of delays and different operations. 
#define PORTC 
(*(volatile __near unsigned char*)0xF82) 
#define PORTD 
(*(volatile __near unsigned char*)0xF83) 
#define TRISC 
(*(volatile __near unsigned char*)0xF94) 
#define TRISD 
(*(volatile __near unsigned char*)0xF95) 
void lcdInit() { 
    BitClr(TRISC, EN); 
    BitClr(TRISC, RS); 
    TRISD = 0x0f; 
    delayMicroseconds(50); 
    commandWriteNibble(0x03); 
    delayMicroseconds(5); 
    commandWriteNibble(0x03); 
    delayMicroseconds(100); 
    commandWriteNibble(0x03); 
    delayMicroseconds(5); 
    commandWriteNibble(0x02); 
    delayMicroseconds(10); 
    //configura o display 
    lcdCommand(0x28); //8bits, 2 linhas, 5x8 
    lcdCommand(0x06); //modo incremental 
    lcdCommand(0x0c); //display e cursor on, com blink 
    lcdCommand(0x03); //zera tudo 
    lcdCommand(0x80); //posição inicial 
    lcdCommand(0x01); //limpar display 
    delayMicroseconds(2); 
} 
To print a regular string one must just watch for the string end ‘\0’. 
void lcdString(char msg[]) { 
    unsigned char i = 0; //fancy int.  avoids compiler warning when comparing i 
with strlen()'s uint8_t 
    while (msg[i]) { 
        lcdChar(msg[i]); 
        i++; 
    } 
} 
The LCD can build customized characters. The characters must be send to a specific address to the LCD 
internal memory. 
6 
void lcdDefconLogo(void) { 
    int i; 
    unsigned char defcon[] = { 
        0x0, 0x1, 0x3, 0x3, 0x3, 0x3, 0x1, 0x4, 
        0xe, 0x1f, 0x4, 0x4, 0x1f, 0xe, 0x11, 0x1f, 
        0x0, 0x10, 0x18, 0x18, 0x18, 0x18, 0x10, 0x4, 
        0xc, 0x3, 0x0, 0x0, 0x0, 0x3, 0xc, 0x4, 
        0x0, 0x0, 0x1b, 0x4, 0x1b, 0x0, 0x0, 0x0, 
        0x6, 0x18, 0x0, 0x0, 0x0, 0x18, 0x6, 0x2 
    }; 
    lcdCommand(0x40); 
    for (i = 0; i 512){ 
            PORTD = 0xFF; 
       }else{ 
           PORTD = 0x00; 
       } 
    } 
} 
8 