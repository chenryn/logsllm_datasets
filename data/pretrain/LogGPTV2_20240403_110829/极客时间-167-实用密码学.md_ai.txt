# 10 \| 怎么防止数据重放攻击？你好，我是范学雷。上一讲，我们讨论了对称密钥分组算法的链接模式，从链接模式出发，我们还分析了ECB 模式，初始化向量和链接模式的缺失导致了 ECB模式的安全缺陷，尤其是数据重放攻击。我们说，有密码学基础知识的工程师，都应该知道 ECB模式的安全问题，并且不会在应用程序中使用它。这一讲，我们来讨论一个更广泛使用的加密模式，CBC模式。 CBC 模式，可能是 2018 年之前最常用、最常见的加密模式。和 ECB模式不同，由于初始化向量和链接模式的使用，CBC模式解决了数据重放攻击的问题。可是，从 2018年开始，由于它的安全问题，CBC模式开始退出历史舞台，尽管这一进程可能需要十数年，甚至数十年。为什么还要学习 CBC 模式？不知道你是不是已经有了一个问题：既然 CBC要退出历史舞台了，我们还学习它干什么呢？第一个原因，CBC的退出进程可能需要十数年才能完成。你现在工作的项目种，可能还存在 CBC模式的大量使用。我们学习了 CBC模式，有助于你解决现存项目的安全问题。第二个原因，学习针对 CBC 的攻击方案，是我们深入理解加密算法安全问题的最好的切入点。了解这些安全缺陷和攻击方案，有助于你更好地使用密码学的算法。因为，这些缺陷也可能换个面孔，出现在应用程序层面。如果你能够说清楚CBC模式的攻击办法，也就意味着你已经试着走入了算法的细节。第三个原因，也是最重要的原因，就是我们要进一步地理解初始化向量和链接模式对加密算法的影响。学习CBC模式会为我们将来讨论更高级的协议和更安全的算法打下基础。那么，CBC模式是什么样子的？它是怎么解决数据重放攻击的？它存在哪些安全陷阱？这是我们这一次要解决的问题。CBC 模式什么样？和其他模式不同的是，在 CBC（Cipher BlockChaining）模式中，明文分组在加密之前，要与前一组的密文分组进行异或运算，异或运算的结果会参与加密函数的运算。也就是说，上一次的密文分组要参与下一次的加密运算，每一个密文数据不仅依赖于它对应的明文分组，还依赖于上一次的密文分组。这样的话，每一个密文分组，都依赖于前面所有的明文分组，包括初始化向量。![](Images/d2d76c0c4aeea9e83f19b16369f84e77.png)savepage-src="https://static001.geekbang.org/resource/image/3b/2d/3b93c00b26a591bde63b50a1f2f1b52d.jpeg"}所以，我们能够知道，CBC模式是需要初始化向量的。最显而易见的原因，就是第一个明文分组还不存在所谓的"上一个密文分组"。所以，我们需要一个外部引入的初始化向量来替代"上一个密文分组"参与运算。不过，我们需要注意的是，在加密过程中，加密函数的输入数据是明文分组（Mi）和上一次的密文分组（Ci-1）的异或运算的结果（Mi\^ Ci-1）。 在解密过程中，解密函数的输出数据，也是明文分组和上一次的密文分组的异或运算结果（Mi\^Ci-1）。我们要是想得到解密的明文分组，就需要把明文分组和上一次的密文分组分离开来。我们现在可以确定的是，上一次的密文分组（Ci-1）是已知的。所以，只要我们把上一次的密文分组和解密函数的输出数据进行异或运算，就把明文分组分离出来了。    (Ci-1) ^ (Mi ^ Ci-1) = Mi所以，我们可以发现，对于解密过程来说，如果我们把解密函数的运算结果与上一次的密文分组进行异或运算，就可以获得对应的明文分组。![](Images/0fd96020ab11f3313940424dd66d3c01.png)savepage-src="https://static001.geekbang.org/resource/image/6e/7e/6e44f9b084b3233d0e5fb6bed0d5687e.jpeg"}不难想象，在解密过程中，我们要想获得第一个明文分组，用来替代"上一个密文分组"的初始化向量就必须要参与解密的过程。也就是说，**加密过程的初始化向量和解密过程的初始化向量必须是一样的，否则，我们就没有办法得到第一个明文分组**。**注意一点，初始化向量只影响第一个明文分组，并不影响后续的解密过程和明文分组**。**类似地，一个密文分组，只影响它的下一个明文分组，并不影响更后面的解密过程和明文分组。****而在加密过程中，每一个密文分组，都依赖于前面所有的明文分组，包括初始化向量。**所以，我们在这里要注意的就是加密过程和解密过程的区别。这是一个重要的特征，我们先在这里打个伏笔，后面我们会再讨论这个特征有什么用。总的来说，理解 CBC模式，我们要把握以下三个关键点：1.  加密和解密要使用初始化向量；        2.  加密和解密的初始化向量是等同的；        3.  上一次的密文分组参与下一次的加密和解密运算。        初始化向量需要保密吗？我们讨论过初始化向量的选择问题，就是在一个对称密钥的生命周期里，初始化向量不能重复。**如果每一次运算，初始化向量都****能****不重复，即使是相同的明文数据，它的加密结果也是不同的。但是，如果初始化向量重复使用，相同的明文就会有相同的密文。重复使用的初始化向量，****会****消解密文反馈的作用，使得 CBC 模式和 ECB模式一样脆弱**。所以，初始化向量的唯一性在加密运算的安全性中至关重要。那你会问了，既然初始化向量这么重要，那我们需要对它进行保密吗？**初始化向量并不需要保密**。如果你对这一点有疑问，不妨换个角度想一想：每一个分组加密的初始化向量都是上一次加密运算得到的密文分组，而密文分组是可以公开的信息。初始化向量不需要保密，这是我们要打的第二个伏笔。异或运算会不会有问题？我在上面的讲解中提到了异或运算，其实，它在密码算法里有广泛的应用，为什么它如此广泛？第一个原因是**异或运算是按位运算，所以在相同的计算环境下，异或运算时间只和数据的位数相关，和数据的实际数值无关**。放在密码学算法的世界里，如果运算时间和实际数值无关，那简直再好不过了。换句话说，如果运算时间和数据数值相关，而且别人还了解到这种相关性，他就可以通过统计学的方法，通过观察、测算运算时间，找到运算时间和数据数值之间的关联，来破解密码。第二个原因同样是**按位运算，在相同的计算环境下，异或运算的复杂度，也就是需要的算力，只和数据的位数相关，和数据的实际数值无关**。而且，一个运算需要的算力，在计算机环境中，可以通过占用的CPU周期数，以及消耗的内存空间来衡量。同理，如果占用的 CPU或者消耗的内存和数据数值相关，别人就可以通过统计学的办法，然后观察 CPU的占用、电力消耗或者内存的消耗，来破解密码。一般来说，这种相关性，也会影响运算时间，从而使得基于测算运算时间的攻击方式同样有效。不光如此，如果运算的复杂度和数据数值相关，密码破解的办法可就是千奇百怪的了。记录、测算计算机的噪音、温度、辐射、反应时间等等，都有可能成为有效的攻击手段。如果让一个一流的黑客，拿着手机进入数据中心，录一段服务器发出的声音，说不定你的服务器就被攻陷了。之所以没有说一定会被攻破，是因为近几年的密码学进展，已经发展出了具有防范能力的算法和实现。但是，如果你的服务器使用的是十年前的技术和软件，黑客得手的概率还是有的。我们后面会讨论这些新技术和新算法。第三个原因和异或运算的运算特点有关，也就是相同的数据归零，不同的数据归一。1.  归零律：如果两段数据完全相同，它们的异或运算结果，就是每一位都是零的数据；        2.  恒等律：如果一段数据和一段全是零的数据进行异或运算，前一段数据中是零的位运算后还是零，是一的位运算后还是一。也就是说，和零进行异或运算，不改变原数据的数值。        正是异或运算的归零律和恒等律，CBC模式才能成立，解密才能进行。这两个性质，还使得解密运算和加密运算具有相同的运算效率。然而，CBC模式的主要安全问题，也来源于异或运算的这两个性质。如果两段数据中只有一位不同，它们的异或运算结果，就是只有这一位的数据是一，其他的数据都是零。那是不是我们就可以通过构造明文分组或者密文分组，一次改变一位数据，然后把数据交给加密运算或者解密运算来处理，通过观察加密或者解密的结果展开攻击了？比如说，一个 128 位的密钥，它的强度能承受 2\^128次的运算，是一个强度的指数级别的量级。1.  如果我们一次改变一位数据的攻击方式得逞，最多需要 128    次的运算；        2.  如果我们一次只能观测一个字节，一次一位的改变需要 2\^8 = 256    次，这样的攻击方式得逞，最多需要 255 \* 16 = 4080    次的运算。        这样的运算强度，和设计的理论值 2\^128相差太远了，一次有效的破解也就是分分钟的事情。还别说，这样的攻击方式在实践中真的是可行的。这种攻击方式，把 CBC模式变成了一个充满陷阱的模式。用的好，它就是安全的；用的不好，它就会惹来麻烦。这实在不符合密码算法要皮实、耐用的要求。**阻断一个攻击的方式之一，就是破坏攻击依赖的路径或者条件**。对于上面的攻击方式，其实只要攻击者没有办法一次改变一位数据或者少量的数据，这样的攻击就可以被有效破解了。也就是要保证攻击者在展开攻击的时候，没有办法一次改变不少于一个数据分组的数据。对于AES 来说，数据分组大小是 128 位，攻击者需要运算 2\^128次，才可以攻击得逞。计算量这么大，攻击者的攻击方式就无效了。那我们怎么做才能让攻击者没办法呢？密文分组、密钥、加密算法、解密算法，这些都是固定的数据或算法，没有考量的空间。剩下的变量，就只有明文分组和初始化向量了。要想解决掉这个安全问题，该怎么控制明文分组和初始化向量？异或运算又是怎样带来麻烦的？要想深入地了解这些问题，有点烧脑。下一次，我们集中精力来讨论、分析其中的细节和办法。密钥少一位会有影响吗？不知道你有没有注意到，我们上面的讨论，提到了数据的位数。因为分组加密是按照固定的分组进行加解密运算，所以每一次的分组运算，数据的位数都是固定的。比如，AES算法的分组大小都是 128位。所以，我们不用担心分组运算的数据位数的变化。在分组运算中，初始化向量、密文分组和明文分组密钥的数据位数也都是固定的。所以，我们也不需要担心它们的位数的变化。加密算法和解密算法不涉及数据位数，所以我们也不担心算法。剩下的一个变量，就是密钥了。密钥的位数会变化吗？密钥的位数变化有影响吗？一般来说，我们也不太关心密钥的位数变化，密钥少一位似乎也不是什么无关紧要的事情。所以，出于互操作性的考虑，很多标准和协议（包括应用最广泛的TLS 1.2协议）需要把密钥的高位的零清除掉，然后再参与运算。原来 128 位的密钥，可能就被清除成了 127 位或者 126 位的密钥了。2018年发布的的 TLS 1.3版本，不再需要清除密钥高位的零。少一位密码，当然会带来计算性能的差异，以及由此引发的计算时间偏差。可是，似乎2020 年之前，没有人担心这件事。直到 2020 年 9 月 8日，当我正在写这一篇稿的时候，一个名字叫做"浣熊攻击"的安全研究成果发布了。浣熊攻击可以利用密钥高位清零造成的运算时间差，通过观察、测算运算时间，运用统计学的技术破解运算密钥。这实在是一个了不起的发现。目前来看，这种攻击方式还比较复杂，不容易执行。但是，一旦发现攻击方法，如果业界没有采取及时的措施，攻击技术的改进速度是惊人的。"浣熊攻击"出现，再一次敲了敲大门，**警告我们要尽量避免计算时间偏差和计算算力偏差，谨慎地处理不可避免的计算时间偏差和算力偏差。**Take Away（今日收获）今天，通过解构 CBC模式，我们讨论了在分组运算里，一个典型的链接模式是什么样子的，以及重申了初始化向量的唯一性要求。使用唯一的初始化向量和恰当的链接模式，可以帮助我们防范数据重放攻击。还有，通过异或运算和密钥位数的讨论，我们要小心计算时间偏差和计算算力偏差对算法安全性的影响。一般来说，这是一个特别容易忽视的问题。不仅仅是密码学算法，对所有私密数据的运算，都要小心处理计算时间偏差和计算算力偏差。否则，都有数据泄漏的危险。另外，为了后面更进一步地讨论 CBC模式的安全问题，我们还在这一次埋了不少的伏笔暗线，比如，初始化向量不需要保密，异或运算的特点等。通过今天的讨论，我们要：1.  理解 CBC    模式的三个关键点。        2.  了解计算时间偏差和算力偏差对算法安全性的影响。        思考题今天的思考题，是一个动手题，也是一个简单的密码算法漏洞扫描的思路。通过上面的讨论，我们知道密钥的位数很关键，一位也不能多，一位也不能少。找一个你熟悉的密码算法库，这个算法库可以是Java Script 的，也可以是 Java的，也可以是你熟悉的项目使用的算法库。然后，调用它的对称密钥生成接口，试着产生很多 128位的密钥。你看一看，有没有可能返回 127 位或者 129 位的密钥。如果你找到了不是 128位的密钥，这个算法库就有潜在的安全问题。如果你恰好学过统计学，还能使用统计学的软件，你可以试着多做一道思考题。我假设你知道RSA 非对称密钥算法，也了解它的调用接口。同样的，找一个你熟悉的 RSA算法实现，生成一对 1024 位 RSA 非对称密钥，用公钥加密大量的 1024位的不同数据，然后用私钥解密这些数据，统计解密消耗的时间。如果解密时间不是大致相同的，这个 RSA实现就是有问题的。破解起来可能就是分分钟的事情。这是一个让我们了解计算时间偏差和计算算力偏差的练手题，也是个常见的分析RSA 实现漏洞的攻击办法。欢迎在留言区留言，记录、讨论你的发现。好的，今天就这样，我们下次再聊。
# 11 \| 怎么利用解密端攻击？你好，我是范学雷。上一讲，我们讨论了对称密钥分组算法的 CBC链接模式，还提到了异或运算的好处，以及它的风险。但是，我们又留了一个小尾巴，异或运算是怎样带来麻烦的？它是怎么影响CBC链接模式的安全性的？我们又有什么有效的办法可以规避异或运算的风险？这两次讨论，有点烧脑，我们姑且把它当做一次打怪升级的过程。如果弄清楚这些问题，你就可以更得心应手地使用分组算法，而且毫无疑问地超越了大部分人对对称密钥分组算法的理解。鉴于这两次讨论的难度，我觉得最好的学习方式，就是拿上纸笔，跟着我的思路，自己画一画攻击的流程。学习一段内容，就画一画这一段的思路，扎扎实实把这一段理解下来。其实，这也是我们学习、理解所有密码学算法攻击的一个办法。密码学算法的攻击，大部分都超乎想象，意想不到。读一段、画一段，理解一段，是一个实用的方法，也是我自己使用的方法。好，你准备好了吗？我们开始了。怎么利用解密端攻击？还记得 CBC模式吗？攻击者既可以攻击它的解密端，也可以攻击它的加密端。针对解密端的攻击，最常见的方式，就是给定密文数据，观测解密运算是成功还是失败。那么，解密端是怎么知道解密是成功还是失败呢？到目前为止，在我们已经讨论过的密码学技术中，我们唯一能够利用的，就是数据补齐方案。我们先来看看，数据怎么补齐？数据怎么补齐？简单来说，CBC模式的补齐数据，就是一个数据分组缺失的数据的长度。比如，对于 AES来说，数据分组是 16 个字节。如果一段数据只有 15个字节，补齐的数据就是一个 1；如果有 14 个字节，补齐的数据就是两个2；以此类推，如果只有一个字节，补齐的数据就是十五个 15。 ![](Images/0a5d7030d859bd0af0e821afb11903d5.png)savepage-src="https://static001.geekbang.org/resource/image/95/fe/953c67a8a6fb6fc9aeddbcc6bf7074fe.png"}不过，这个数据补齐方案有明显的缺陷。当数据分组最后一个字节是1，解密端不太好判断这个字节到底是补齐数据，还是有效数据。所以，很多标准和协议使用最后一个数据分组的最后一个字节来标明补齐数据。如果一段数据只有 15 个字节，补齐的数据就只有这个标识字节，数值为0，表示没有额外的补齐数据；如果有 14 个字节，标识字节为1，表示还有一个字节的额外补齐数据，额外的补齐数据的数值也是 1；如果有 13个字节，标识字节为2，表示还有两个字节额外补齐数据，额外的补齐数据的数值也是2；以此类推。需要注意的是，如果一段数据有 16个字节，也就是刚好一个数据分组大小，这时候，就需要一个全是补齐数据的数据分组，它的每一个字节都是15。 ![](Images/010217fa6a4fca2b36e518c5ead3dfdc.png)savepage-src="https://static001.geekbang.org/resource/image/82/bd/82198699be86df8f3b0c23fe3aa192bd.png"}为了方便，下面的讨论中，我们都使用有标识字节的数据补齐方案，除非特别声明。补齐怎么校验？那你会不会有疑问，我们如何在解密端，判断一个数据分组中的数据是不是补齐数据？可以检查最后的几位数字是不是相同。比如说，如果最后一位是2，但是倒数第二位和倒数第三位不是2，解密就失败了。失败的原因，可能是由于篡改的密文分组，或者是篡改的初始化向量，或者是篡改的密钥。不管哪种原因，都可能导致补齐数据的校验失败。那我们怎么利用数据补齐方案展开攻击呢？攻击怎么展开？我们回顾一下 CBC模式的解密过程。一个密文分组的解密，需要如下的输入数据：1.  上一次的密文分组 Ci-1；        2.  这一次的密文分组 Ci；        3.  加密和解密共享的密钥 K。        这一次的密文分组 Ci 和密钥K，通过解密函数的运算，可以产生一个中间结果Ti，也就是解密函数运算的中间结果 Ti；然后，解密函数运算结果 Ti和上一次的密文分组进行异或运算，获得明文分组 Pi，Pi = Ci-1 \^Ti。 ![](Images/319b033dcc006289bad1882d880b4e68.png)savepage-src="https://static001.geekbang.org/resource/image/4c/6b/4c1b630e4be11354cf37e3da500b516b.jpeg"}接下来，我们利用数据补齐方案的攻击，通过修改、构造最后一个密文分组 Cn的前一个密文分组Cn-1，也就是倒数第二个密文分组，然后让解密端解密构造后的密文数据，观察修改了密文数据的解密能不能成功。![](Images/f6a2be57e6fdfdb22450dc8b67ea817f.png)savepage-src="https://static001.geekbang.org/resource/image/27/d6/27124b457a8a65f1eae06636974db6d6.jpeg"}那倒数第二个密文分组该怎么构造呢？首先，修改该密文分组的最后一个字节，该字节可以从零开始。毫无疑问，解密端并不能正确解密该密文分组，得到的明文分组也不是期望的明文数据。但是，正像我们前面讨论的，解密端并没有办法知道这一个密文分组解密失败。要判断解密是否成功，还需要判断最后一个明文分组的补齐数据是不是符合规范。如果我们修改倒数第二个密文分组的最后一个字节，那么解密后的最后一个明文分组应该只有最后一个字节受到影响。如果这个解密后的字节是零，其他的数据会被解读为有效数据，这样就会通过补齐数据的校验。如果这个解密后的字节是其他数值，补齐数据的校验通过的概率就很小。实际的攻击过程，这么一点小小的概率也可以优化过滤掉。如果解密后的这个字节不是零，那么，补齐数据的校验就会失败，解密端就会报错。观察解密端的行为，攻击者就能了解到，这个构造的字节没有通过解密过程。如果观察到失败，攻击者就会调节最后一个字节的数值，比如数值加一，然后再次让解密端尝试解密。![](Images/be23e0783c530a1cd7b63f716e174726.png)savepage-src="https://static001.geekbang.org/resource/image/85/69/85c1d2c0991b930147e5580849fbb069.png"}一个字节只有 256 种可能性，最多尝试 255次，一定会有一次尝试，补齐数据是零。![](Images/08bd327d4a3e9466d6bb2ded2e3d487c.png)savepage-src="https://static001.geekbang.org/resource/image/86/79/860a6ccfa7175c1f424acf27d3535b79.png"}当攻击者观察到解密成功时，他能够掌握哪些数据呢？他能够直接得到的数据包括：1.  未修改密文分组的最后一个字节的数值（Cn-1\[15\]）；        2.  修改后密文分组的最后一个字节的数值（Cn-1\'\[15\]）；        3.  解密端明文分组的最后一个字节的数值（Pn\'\[15\]，也就是    0x00）。        通过计算，他还可以得到解密函数的运算结果的一个字节：1.  解密函数运算结果的最后一个字节的数值（Tn\[15\]）。        由于明文字节（Pn\'\[15\]）是密文字节（Cn-1\'\[15\]）和解密函数运算中间结果字节（Tn\[15\]）的异或运算结果，那么知道了明文字节（Pn\'\[15\]）和密文字节（Cn-1\'\[15\]），使用异或运算的归零律和恒等律，计算出解密函数运算中间结果字节（Tn\[15\]）就是一件简单的事情了。    > Pn'[15] = Tn[15] ^ Cn-1'[15    > =>    > Pn'[15] ^ Cn-1'[15] = Tn[15] ^ Cn-1'[15] ^ Cn-1'[15] = Tn[15既然知道了解密函数运算中间结果字节Tn\[15\]）和原始密文分组的字节，真正的明文字节也就被破解出来了。    > Pn[15] = Tn[15] ^ Cn-1[15你看，非常简单的运算，运算次数不多于 255次，攻击者就破解了一位字节。接下来的目标，就是破解倒数第二位字节。破解倒数第二位字节，要使用的补齐数据是一（0x01）。首先，既然攻击者已经知道了最后一个字节的明文、密文以及解密函数运算的中间结果，他就可以计算、修改上一次的密文分组的最后一个字节，使得解密后的明文分组的最后一个字节是一。    > Tn[15] ^ Cn-1'[15] = 0x01    > =>    > Tn[15] ^ Cn-1'[15] ^ Tn[15] = 0x01 ^ Tn[15    > Cn-1'[15] = 0x01 ^ Tn[15这样，解密端就确认了最后一个字节是一，也就是补齐数据的标识字节是一。只要倒数第二个字节也是一，补齐数据的检验就通过了。倒数第二个字节破解方式和第一个字节的破解方式相同。每个字节的破解，运算次数都不会多于 255次。从倒数第一位开始，依次破解，直到第一个字节破解结束，总的计算量是 255乘以字节数。对于 AES 而言，一个数据分组有 16 个字节，破解计算只需要 255\* 16 = 4080 次。这么小的破解计算量，是没有什么安全性可说的。预测补齐数据的这一类破解方案，都可以叫做"补齐预言攻击"。2002年，塞尔吉·沃德奈（SergeVaudenay）公布了补齐预言攻击。有一些 2002年之前制定的安全协议，不能很好地应对这种攻击方案。相应地，也有一些成功的破解方案。那么，2002年以后的年月呢？CBC模式该怎么规避补齐预言攻击？有效的方式有两个。第一个方式，也是最有效的方式，就是和数据完整性校验的算法结合起来，而不是依赖补齐数据是否合法，来判断解密数据是不是有效。这种方式，我们讨论数据完整性校验算法的时候，还会再讨论。另外一种方式，就是在初始化向量上想办法。初始化向量就用一次吗？初始化向量，现在你应该很熟悉了，就是加密或者解密运算开始的时候使用的向量。这个变量不是就使用一次、改变一次而已吗？怎么还使用它来阻断补齐预言攻击呢？如果这个变量就使用一次、改变一次，它的确起不到作用。我们要做的，就是要改变这种一次性使用的方式，变成多次使用的方式。是不是听起来有点难度？是有难度的。如果加密端和解密端每次运算（一次运算可以包含多个数据分组）都重置初始化向量，并且使用不一样的初始化向量。只要使用了不一样的初始化向量，每一次运算的最后一个密文分组都是不同的。这样，就不能重复地使用这个密文分组反复运算，从而切断了补齐预言攻击的攻击路径。稍微有点麻烦的是，解密端怎么才能判断每一次运算都使用了不同的初始化向量。这不是一个容易的事情。所以，如果仅仅依靠一次运算一个初始化向量的办法，也很难有成熟的解决方案。一次运算一个初始化向量的办法，除了可以用来阻断补齐预言攻击之外，它还有一个很有吸引力的特点。不过，让我们下一次再接着讨论。Take Away（今日收获）今天，通过讨论怎么在 CBC模式的解密端，利用数据补齐方案，来展开补齐预言攻击，我们知道了数据补齐方案可能存在的缺陷。另外，我们还讨论了阻断补齐预言攻击的办法，那就是，每一次加密 /解密计算，都使用初始化向量，而不是仅仅就使用一次初始化向量。通过今天的讨论，我们要：1.  知道 CBC    模式存在补齐预言攻击；        2.  知道使用不同初始化向量的来阻断补齐预言攻击。        思考题今天的思考题，我们去看一看协议的设计。在 TLS 1.2 的设计中，使用 CBC模式加密的数据包是由一个明文的初始化向量和密文的加密数据组成的。明文的初始化向量和密文的加密数据，可以通过不安全的网络，传递给信息接收方。**第一个问题是：为什么****我们****可以传递明文的初始化向量？****第二个问题是，为什么要传递初始化向量？**另外，如果你仔细看下面的数据结构，就会注意到，在 TLS 1.2的设计里，待加密的数据块，已经补齐到算法要求的数据块的整数倍了。这似乎也就意味着，上一个数据包和这一个数据包，以及这一个数据包和下一个数据包，都可以无缝地衔接，而不需要使用数据补齐，也不需要每次都使用一个初始化向量。**既然已经补齐了，为什么还要每一次加密都使用一个初始化向量？这是第三个问题。**理解了这三个问题，你就算学会使用 CBC 算法了。CBC算法要被扫进垃圾箱的主要原因，就是因为这个算法太难用对了，虽然它是用途最广泛的加密模式。如果你可以用对它，在很多场景，它还是能够再延续使用一段时间，等待你升级到更皮实的算法。    struct {      opaque IV[SecurityParameters.record_iv_length];      block-ciphered struct {          opaque content[TLSCompressed.length];          opaque MAC[SecurityParameters.mac_length];          uint8 padding[GenericBlockCipher.padding_length];          uint8 padding_length;      };          } GenericBlockCipher;欢迎在留言区留言，记录、讨论你的理解和看法。好的，今天就这样，我们下次再聊。