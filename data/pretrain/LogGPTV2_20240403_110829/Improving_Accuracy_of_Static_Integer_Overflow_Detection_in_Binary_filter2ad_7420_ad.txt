2500
2000
1500
1000
500
0
0
10
Threshold of priority ranking
20
30
programs
comctl32
gdi32
jpeg2swf
libpng
libwav
png2swf
Fig. 2. The number of suspicious vulnerabilities reported by the ranking algorithm fell
down as the threshold is rising. When threshold = 35, false negatives occurred.
Improving Accuracy of Static Integer Overﬂow Detection in Binary
261
5.2 False Positive Reduction
The focus of the second set of experiments was to evaluate the eﬀectiveness
of INDIO in reducing false positives. In these experiments, we compared the
numbers of false positives reported by both INDIO and IntScope [25] for the
same set of 9 binaries. The reason why IntScope was chosen for comparison is
twofold: (1) IntScope is a renowned static analysis tool for Windows binaries;
and (2) to the best of our knowledge, IntScope achieves the lowest false positive
rate among existing static integer overﬂow detection tools, including [8,25–27].
The comparison results between INDIO and IntScope are summarized in
Fig. 3, which demonstrated that INDIO not only reported all the vulnerabilities
recorded in [25] but also found a previous unknown vulnerability in comctl32.dll.
In terms of false positives, INDIO reported fewer false positives than IntScope
for 3 out of the 9 binaries. For the rest 6 binaries, INDIO reported the same
number of false positives as IntScope.
The reason why INDIO out-performed IntScope, from the false positive rate
perspective, lies in the fact that IntScope only outputs suspicious paths that
might contain integer overﬂow for a single function in the binary, while ignores
potential vulnerabilities caused by other functions in the same binary. These
suspicious paths need to be further ﬁltered by other auxiliary testing tools to
check their validity. INDIO, on the contrary, reports overﬂow points for each
vulnerability in the entire binary, instead of targeting at a certain function in it.
y
t
i
l
i
b
a
r
e
n
u
v
l
d
e
t
r
o
p
e
r
f
o
r
e
b
m
u
N
9
6
3
0
Tools
INDIO
IntScope
22
4
3
3
1
1 1
1 1
1 1
7
4
33
22
comctl32
faad2
gdi32
goom
hamsterdb
mpd
mplayer
qemu
xine
Fig. 3. Numbers of (potential) vulnerabilities reported by INDIO and IntScope. Note
that [25] only recorded the number of false positives reported in the functions that
contained genuine vulnerabilities, while INDIO reported all false positives reported for
the 9 binaries.
5.3 New Bug Detection
INDIO succeeded in ﬁnding two vulnerabilities
In the experiments,
in
comctl32.dll and libpng.dll that have not been reported by any tools before.
The vendors of these two binaries both conﬁrmed these two vulnerabilities, and
released corresponding security patches to ﬁx them3. In addition, INDIO also
found a vulnerability that has been ﬁxed by the vendor but never been published.
3 Ref. CVE-2013-3195 and CVE-2013-7353.
262
Y. Zhang et al.
Analysis of comctl32.dll. comctl32.dll is a Windows system library, providing
a set of window control functionalities used by Windows GUI applications. The
following code shows the vulnerability we found in its function DSA InsertItem,
where it uses the product of nItemSize and nNewItems as the size of mem-
ory to be allocated, without any prior overﬂow check. Both nItemSize and
nNewItems are 32-bit signed integers, whereas the data type of the second para-
meter of ReAlloc 32-bit unsigned integer. This could cause the product to wrap
around to a relatively smaller integer than expected. Malicious attackers can
hence exploit this vulnerability by carefully crafting the nGrow and nMaxCount
ﬁelds of parameter hdsa. For brevity, we refer to this vulnerability as Vulnerabil-
ity #1. Notably, the security community has not been able to detect Vulnerability
#1 for more than a decade.
INT D S A _ I n s e r t I t e m ( HDSA hdsa , INT nIndex , LPVOID pSrc ) {
nNewItems , nSize ;
INT
...
if ( nIndex >= hdsa - > n I t e m C o u n t )
n I t e m C o u n t ;
n I n d e x = hdsa - >
...
n N e w I t e m s = hdsa - > n M a x C o u n t + hdsa - > nGrow ;
nSize = hdsa - > n I t e m S i z e * n N e w I t e m s ;
lpTemp = ReAlloc ( hdsa - > pData , nSize ) ;
... }
StaticTaint reported 16 suspicious vulnerabilities, among which Vulnerabil-
ity #1 was assigned the highest priority (51). VIOSE further determined 14 of
them as false positives and generated example inputs for the rest two suspicious
vulnerabilities. With the inputs generated by VIOSE, we were able to manu-
ally conﬁrm the genuineness of these two vulnerabilities, including Venerability
#1 and another vulnerability in function DPA GROW. For the latter vulnerability,
Microsoft has released version 5.82.2900.6028 of comctl32.dll to ﬁx it without
making it aware to the public. In contrast, Wang et al. also applied IntScope to
comctl32.dll, but was not able to detect Vulnerability #1. Additionally, we are
not aware any dynamic tools having been used to detect vulnerabilities in this
GUI library.
libpng.dll. The vulnerability we are the ﬁrst to detect in
Analysis of
libpng.dll- 1.5.13 is a typical heap buﬀer overﬂow vulnerability caused by inte-
ger overﬂow. To be more speciﬁc, its function png set unknown chunks(in libp-
ng/pngset.c) used two of its parameters, info ptr and num unknowns, to calculate
the size of a memory chunk np without any checks, as illustrated in the following
code segment. These two unsigned parameters in the multiplication can be very
close to the upper limit of unsigned integers. Thus, the size of memory allocated
to np might be smaller than expected when wraparound occurs during the size
calculation. This might result in a segmentation fault when information is copied
to np. For convenience, we refer to this vulnerability as Vulnerability #2.
Improving Accuracy of Static Integer Overﬂow Detection in Binary
263
void PNGAPI p n g _ s e t _ u n k n o w n _ c h u n k s ( p n g _ s t r u c t p png_ptr ,
p n g _ i n f o p info_ptr , p n g _ u n k n o w n _ c h u n k p unknowns , int
n u m _ u n k n o w n s ) {
...
np = ( p n g _ u n k n o w n _ c h u n k p ) p n g _ m a l l o c _ w a r n ( png_ptr ,
( p n g _ s i z e _ t ) ( info_ptr - > u n k n o w n _ c h u n k s _ n u m +
n u m _ u n k n o w n s ) *
p n g _ s i z e o f ( p n g _ u n k n o w n _ c h u n k ) ) ;
...
p n g _ m e m c p y ( np , info_ptr - > unknown_chunks ,
( p n g _ s i z e _ t ) info_ptr - > u n k n o w n _ c h u n k s _ n u m
p n g _ s i z e o f ( p n g _ u n k n o w n _ c h u n k ) ) ;
... }
For this binary StaticTaint ﬁrst identiﬁed 14 suspicious vulnerabilities, out
of which Vulnerability #2 was assigned with a priority of 45, lower than 10
other vulnerabilities. VIOSE validated 2 vulnerabilities as genuine, namely Vul-
nerability #2 and vulnerability CVE-2011-3026 listed in Table 2. As evidence of
the genuineness of Vulnerability #2, VIOSE produced an example input, which
assigned the fourth argument of png set unknown chunks as 0xffffffff. After
manual analysis, we conﬁrmed that this input did trigger Vulnerability #2.
Libpng.dll has been widely analyzed by diﬀerent approaches [10,14,29], but
none of them found Vulnerability #2. For example, IOC, a dynamic integer over-
ﬂow detection tool using source code instrumentation, asserted that libpng is
completely free of undeﬁned integer overﬂows, after analyzing it against an exist-
ing test suite [10]. The reason why IOC failed to detect Vulnerability #2 might
lie in that the test suite used to execute the binary did not trigger the size of
memory allocated to np to overﬂow. However, Vulnerability #2 presents a gen-
uine security threat. In fact, according to IOCs integer overﬂow categorization,
Vulnerability #2 falls into the harmful category of “unintentional implementa-
tion errors”.
5.4 Eﬀectiveness of Optimization
We also evaluated the eﬀectiveness of each optimization technique in INDIO
during detecting known vulnerabilities in Sect. 5.1. To do this, we turned on
one more optimization technique at one time and recorded the numbers of false
positives reported. The experimental results are summarized in Table 2.
Suppose that x and z suspicious vulnerabilities were reported before and
after optimization #n was applied to a binary respectively, and y was the num-
ber of genuine vulnerabilities in the binary. We calculated the reduction ratio of
false positives by optimization #n as 1 − (z − y)/(x − y). As demonstrated in
Table 2, the priority ranking algorithm eliminated in average 78 % of the suspi-
cious vulnerabilities; the WP calculation eliminated about 85 % of the remaining
suspicious vulnerabilities; and lastly the symbolic execution engine was able to
ﬁlter out about 76 % of the vulnerabilities.
264
Y. Zhang et al.
5.5 Eﬃciency
INDIO spent about 1 hour analyzing an average-size binary, the majority of
which was taken by the Vulnerability Filtering module (about 50 % of the cost)
and the Vulnerability Validation module (about 35 %). In comparison, IntScope
spends about 10 min to analyze an average-size executable [25]. However, their
time cost did not take into account the time and eﬀort needed for validating
suspicious vulnerabilities, which typically accounts for a signiﬁcant portion of
time cost in vulnerability detection (e.g., 35 % time cost in our experiments).
Nevertheless, we have to admit that INDIO spends more time than IntScope
in detecting vulnerabilities. Part of the reason lies in that IntScope only performs
taint analysis and symbolic execution during IR traversing. INDIO, on the other
hand, not only performs priority ranking and the WP calculation to ﬁlter false
positives, but also conducts path pruning and taint analysis to improve the eﬀec-
tiveness of VIOSE. This results in about 31 min being spent in these analyses
during the IR traversing stage. Considering the beneﬁts of much fewer false pos-
itives being reported and more accurate analysis results, we deem the relatively
higher time cost by INDIO as an acceptable tradeoﬀ.
It is worth noting that a large part of INDIO’s time cost is incurred by solving
path constraints generated during the WP calculation and symbolic execution.
Our statistics showed that constraint solving took up to 40 % of INDIO’s running
time. This suggests that the time performance of INDIO could be improved if
optimization tactics (e.g., [3,4]) are applied to the constraint solver. We leave
this to future work.
5.6 Discussion
Our experiments on a set of binaries that have been widely analyzed by a variety
of tools provide encouraging evidence on INDIOs capability of detecting known
and unknown integer overﬂow vulnerabilities. Moreover, as compared to IntScope