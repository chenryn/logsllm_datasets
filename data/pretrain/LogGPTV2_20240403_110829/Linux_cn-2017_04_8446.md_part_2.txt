> 
> 
> 
### 如果 CPU 时间是一个问题怎么办？
你可能会说，“前面说的情况真是太好了，但是我们确实有过一些问题，这些问题中 CPU 成为了我们的瓶颈，并造成了我们的 web 应用的速度十分缓慢”，或者“在服务器上 X 语言比 Y 语言需要更少的硬件资源来运行。”这些都可能是对的。关于 web 服务器有这样的美妙的事情：你可以几乎无限地负载均衡它们。换句话说，可以在 web 服务器上投入更多的硬件。当然，Python 可能会比其他语言要求更好的硬件资源，比如 c 语言。只是把硬件投入在 CPU 问题上。相比于你的时间，硬件就显得非常的便宜了。如果你在一年内节省了两周的生产力时间，那将远远多于所增加的硬件开销的回报。
### 那么，Python 更快一些吗？
这一篇文章里面，我一直在谈论最重要的是开发时间。所以问题依然存在：当就开发时间而言，Python 要比其他语言更快吗？按常规惯例来看，我、[google](https://www.codefellows.org/blog/5-reasons-why-python-is-powerful-enough-for-google/) [还有](https://www.lynda.com/Python-tutorials/Python-Programming-Efficiently/534425-2.html)[其他](https://www.linuxjournal.com/article/3882)[几个人](https://www.codeschool.com/blog/2016/01/27/why-python/)可以告诉你 Python 是多么的[高效](http://pythoncard.sourceforge.net/what_is_python.html)。它为你抽象出很多东西，帮助你关注那些你真正应该编写代码的地方，而不会被困在琐碎事情的杂草里，比如你是否应该使用一个向量或者一个数组。但你可能不喜欢只是听别人说的这些话，所以让我们来看一些更多的经验数据。
在大多数情况下，关于 python 是否是更高效语言的争论可以归结为脚本语言（或动态语言）与静态类型语言两者的争论。我认为人们普遍接受的是静态类型语言的生产力较低，但是，[这有一篇优秀的论文](http://www.tcl.tk/doc/scripting.html)解释了为什么不是这样。就 Python 而言，这里有一项[研究](http://www.connellybarnes.com/documents/language_productivity.pdf)，它调查了不同语言编写字符串处理的代码所需要花费的时间，供参考。
![](/data/attachment/album/201704/25/111608nd5zv4fldbuzp4d1.png)
在上述研究中，Python 的效率比 Java 高出 2 倍。有一些其他研究也显示相似的东西。 Rosetta Code 对编程语言的差异进行了[深入的研究](https://arxiv.org/pdf/1409.0252.pdf)。在论文中，他们把 python 与其他脚本语言/解释性语言相比较，得出结论：
> 
> Python 更简洁，即使与函数式语言相比较（平均要短 1.2 到 1.6 倍） 
> 
> 
> 
普遍的趋势似乎是 Python 中的代码行总是更少。代码行听起来可能像一个可怕的指标，但是包括上面已经提到的两项研究在内的[多项研究](http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.113.1831&rep=rep1&type=pdf)表明，每种语言中每行代码所需要花费的时间大约是一样的。因此，限制代码行数就可以提高生产效率。甚至 codinghorror（一名 C# 程序员）本人[写了一篇关于 Python 是如何更有效率的文章](https://blog.codinghorror.com/are-all-programming-languages-the-same/)。
我认为说 Python 比其他的很多语言更加的有效率是公正的。这主要是由于 Python 有大量的自带以及第三方库。[这里是一篇讨论 Python 和其他语言间的差异的简单的文章](https://www.python.org/doc/essays/comparisons/)。如果你不知道为何 Python 是如此的小巧和高效，我邀请你借此机会学习一点 python，自己多实践。这儿是你的第一个程序：
```
import __hello__ 
```
### 但是如果速度真的重要呢？
上述论点的语气可能会让人觉得优化与速度一点也不重要。但事实是，很多时候运行时性能真的很重要。一个例子是，你有一个 web 应用程序，其中有一个特定的端点需要用很长的时间来响应。你知道这个程序需要多快，并且知道程序需要改进多少。
在我们的例子中，发生了两件事：
1. 我们注意到有一个端点执行缓慢。
2. 我们承认它是缓慢，因为我们有一个可以衡量是否足够快的标准，而它没达到那个标准。
我们不必在应用程序中微调优化所有内容，只需要让其中每一个都“足够快”。如果一个端点花费了几秒钟来响应，你的用户可能会注意到，但是，他们并不会注意到你将响应时间由 35 毫秒降低到 25 毫秒。“足够好”就是你需要做到的所有事情。*免责声明: 我应该说有**一些**应用程序，如实时投标程序，**确实**需要细微优化，每一毫秒都相当重要。但那只是例外，而不是规则。*
为了明白如何对端点进行优化，你的第一步将是配置代码，并尝试找出瓶颈在哪。毕竟：
> 
>  任何除了瓶颈之外的改进都是错觉。   Any improvements made anywhere besides the bottleneck are an illusion.  -- Gene Kim
> 
> 
> 
如果你的优化没有触及到瓶颈，你只是浪费你的时间，并没有解决实际问题。在你优化瓶颈之前，你不会得到任何重要的改进。如果你在不知道瓶颈是什么前就尝试优化，那么你最终只会在部分代码中玩耍。在测量和确定瓶颈之前优化代码被称为“过早优化”。人们常提及 Donald Knuth 说的话，但他声称这句话实际上是他从别人那里听来的：
> 
>  过早优化是万恶之源   Premature optimization is the root of all evil 。
> 
> 
> 
在谈到维护代码库时，来自 Donald Knuth 的更完整的引文是：
> 
> 在 97% 的时间里，我们应该忘记微不足道的效率：**过早的优化是万恶之源**。然而在关 键的 3%，我们不应该错过优化的机会。 —— Donald Knuth
> 
> 
> 
换句话说，他所说的是，在大多数时间你应该忘记对你的代码进行优化。它几乎总是足够好。在不是足够好的情况下，我们通常只需要触及 3% 的代码路径。比如因为你使用了 if 语句而不是函数，你的端点快了几纳秒，但这并不会使你赢得任何奖项。
过早的优化包括调用某些更快的函数，或者甚至使用特定的数据结构，因为它通常更快。计算机科学认为，如果一个方法或者算法与另一个具有相同的渐近增长（或称为 Big-O），那么它们是等价的，即使在实践中要慢两倍。计算机是如此之快，算法随着数据/使用增加而造成的计算增长远远超过实际速度本身。换句话说，如果你有两个 O(log n) 的函数，但是一个要慢两倍，这实际上并不重要。随着数据规模的增大，它们都以同样的速度“慢下来”。这就是过早优化是万恶之源的原因；它浪费了我们的时间，几乎从来没有真正有助于我们的性能改进。
就 Big-O 而言，你可以认为对你的程序而言，所有的语言都是 O(n)，其中 n 是代码或者指令的行数。对于同样的指令，它们以同样的速率增长。对于渐进增长，一种语言的速度快慢并不重要，所有语言都是相同的。在这个逻辑下，你可以说，为你的应用程序选择一种语言仅仅是因为它的“快速”是过早优化的最终形式。你选择某些预期快速的东西，却没有测量，也不理解瓶颈将在哪里。
> 
> 为您的应用选择语言只是因为它的“快速”，是过早优化的最终形式。
> 
> 
> 
### 优化 Python
我最喜欢 Python 的一点是，它可以让你一次优化一点点代码。假设你有一个 Python 的方法，你发现它是你的瓶颈。你对它优化过几次，可能遵循[这里](https://wiki.python.org/moin/PythonSpeed)和[那里](https://wiki.python.org/moin/PythonSpeed/PerformanceTips)的一些指导，现在，你很肯定 Python 本身就是你的瓶颈。Python 有调用 C 代码的能力，这意味着，你可以用 C 重写这个方法来减少性能问题。你可以一次重写一个这样的方法。这个过程允许你用任何可以编译为 C 兼容汇编程序的语言，编写良好优化后的瓶颈方法。这让你能够在大多数时间使用 Python 编写，只在必要的时候都才用较低级的语言来写代码。
有一种叫做 Cython 的编程语言，它是 Python 的超集。它几乎是 Python 和 C 的合并，是一种渐进类型的语言。任何 Python 代码都是有效的 Cython 代码，Cython 代码可以编译成 C 代码。使用 Cython，你可以编写一个模块或者一个方法，并逐渐进步到越来越多的 C 类型和性能。你可以将 C 类型和 Python 的鸭子类型混在一起。使用 Cython，你可以获得混合后的完美组合，只在瓶颈处进行优化，同时在其他所有地方不失去 Python 的美丽。
![](/data/attachment/album/201704/25/111620edsf8gln5gt61fdr.jpg)
*星战前夜的一幅截图：这是用 Python 编写的 space MMO 游戏。*
当您最终遇到 Python 的性能问题阻碍时，你不需要把你的整个代码库用另一种不同的语言来编写。你只需要用 Cython 重写几个函数，几乎就能得到你所需要的性能。这就是[星战前夜](https://www.eveonline.com/)采取的策略。这是一个大型多玩家的电脑游戏，在整个架构中使用 Python 和 Cython。它们通过优化 C/Cython 中的瓶颈来实现游戏级别的性能。如果这个策略对他们有用，那么它应该对任何人都有帮助。或者，还有其他方法来优化你的 Python。例如，[PyPy](http://pypy.org/) 是一个 Python 的 JIT 实现，它通过使用 PyPy 替掉 CPython（这是 Python 的默认实现），为长时间运行的应用程序提供重要的运行时改进（如 web 服务器）。
让我们回顾一下要点：
* 优化你最贵的资源。那就是你，而不是计算机。
* 选择一种语言/框架/架构来帮助你快速开发（比如 Python）。不要仅仅因为某些技术的快而选择它们。
* 当你遇到性能问题时，请找到瓶颈所在。
* 你的瓶颈很可能不是 CPU 或者 Python 本身。
* 如果 Python 成为你的瓶颈（你已经优化过你的算法），那么可以转向热门的 Cython 或者 C。
* 尽情享受可以快速做完事情的乐趣。
我希望你喜欢阅读这篇文章，就像我喜欢写这篇文章一样。如果你想说谢谢，请为我点下赞。另外，如果某个时候你想和我讨论 Python，你可以在 twitter 上艾特我（@nhumrich），或者你可以在 [Python slack channel](http://pythondevelopers.herokuapp.com/) 找到我。
---
作者简介：
Nick Humrich -- 坚持采用持续交付的方法，并为之写了很多工具。同是还是一名 Python 黑客与技术狂热者，目前是一名 DevOps 工程师。
（题图：[Pixabay](https://pixabay.com)，CC0）
via: 
作者：[Nick Humrich](https://hackernoon.com/@nhumrich) 译者：[zhousiyu325](https://github.com/zhousiyu325) 校对：[jasminepeng](https://github.com/jasminepeng)
本文由 [LCTT](https://github.com/LCTT/TranslateProject) 原创编译，[Linux中国](https://linux.cn/) 荣誉推出