server example.com:8080 max_fails=2 fail_timeout=10s backup;
#域名的话需要解析的哦，内网记得hosts
}
18.1.5.1. proxy_pass请求转发
proxy_pass 指令属于 ngx_http_proxy_module 模块，此模块可以将请求转发到另一台服务器，
在实际的反向代理工作中，会通过 location 功能匹配指定的 URI，然后把接收到服务匹配 URI 的
请求通过proyx_pass抛给定义好的upstream节点池。
location /download/ {
proxy_pass http://download/vedio/;
}
#这是前端代理节点的设置
13/04/2018 Page 212 of 283
#交给后端upstream为download的节点
proxy模块参数 说明
proxy_next_upstream 什么情况下将请求传递到下一个upstream
proxy_limite_rate 限制从后端服务器读取响应的速率
proyx_set_header 设置http请求header传给后端服务器节点，如：可实现让代
理后端的服务器节点获取访问客户端的这是ip
client_body_buffer_size 客户端请求主体缓冲区大小
proxy_connect_timeout 代理与后端节点服务器连接的超时时间
proxy_send_timeout 后端节点数据回传的超时时间
proxy_read_timeout 设置Nginx从代理的后端服务器获取信息的时间，表示连接成
功建立后，Nginx等待后端服务器的响应时间
proxy_buffer_size 设置缓冲区大小
proxy_buffers 设置缓冲区的数量和大小
proyx_busy_buffers_size 用于设置系统很忙时可以使用的proxy_buffers大小，推荐为
proxy_buffers*2
proxy_temp_file_write_size 指定proxy缓存临时文件的大小
18.1.6. HAProxy
13/04/2018 Page 213 of 283
19. 数据库
19.1.1. 存储引擎
19.1.1.1. 概念
数据库存储引擎是数据库底层软件组织，数据库管理系统（DBMS）使用数据引擎进行创建、查询、
更新和删除数据。不同的存储引擎提供不同的存储机制、索引技巧、锁定水平等功能，使用不同
的存储引擎，还可以 获得特定的功能。现在许多不同的数据库管理系统都支持多种不同的数据引
擎。存储引擎主要有： 1. MyIsam , 2. InnoDB, 3. Memory, 4. Archive, 5. Federated 。
19.1.1.2. InnoDB（B+树）
InnoDB 底层存储结构为B+树， B树的每个节点对应innodb的一个page，page大小是固定的，
一般设为16k。其中非叶子节点只有键值，叶子节点包含完成数据。
适用场景：
1）经常更新的表，适合处理多重并发的更新请求。
2）支持事务。
3）可以从灾难中恢复（通过bin-log日志等）。
4）外键约束。只有他支持外键。
5）支持自动增加列属性auto_increment。
13/04/2018 Page 214 of 283
19.1.1.3. TokuDB（Fractal Tree-节点带数据）
TokuDB 底层存储结构为Fractal Tree,Fractal Tree的结构与B+树有些类似, 在Fractal Tree
中，每一个child指针除了需要指向一个child节点外，还会带有一个Message Buffer ，这个
Message Buffer 是一个FIFO的队列，用来缓存更新操作。
例如，一次插入操作只需要落在某节点的Message Buffer就可以马上返回了，并不需要搜索到叶
子节点。这些缓存的更新会在查询时或后台异步合并应用到对应的节点中。
TokuDB在线添加索引，不影响读写操作, 非常快的写入性能， Fractal-tree在事务实现上有优
势。 他主要适用于访问频率不高的数据或历史数据归档。
19.1.1.4. MyIASM
MyIASM是MySQL默认的引擎，但是它没有提供对数据库事务的支持，也不支持行级锁和外键，
因此当INSERT(插入)或UPDATE(更新)数据时即写操作需要锁定整个表，效率便会低一些。
ISAM 执行读取操作的速度很快，而且不占用大量的内存和存储资源。在设计之初就预想数据组织
成有固定长度的记录，按顺序存储的。---ISAM是一种静态索引结构。
缺点是它不 支持事务处理。
19.1.1.5. Memory
Memory（也叫HEAP）堆内存：使用存在内存中的内容来创建表。每个MEMORY表只实际对应
一个磁盘文件。MEMORY 类型的表访问非常得快，因为它的数据是放在内存中的，并且默认使用
HASH索引。但是一旦服务关闭，表中的数据就会丢失掉。 Memory同时支持散列索引和B树索
引，B树索引可以使用部分查询和通配查询，也可以使用和>=等操作符方便数据挖掘，散列索
引相等的比较快但是对于范围的比较慢很多。
19.1.2. 索引
索引（Index）是帮助 MySQL 高效获取数据的数据结构。常见的查询算法,顺序查找,二分查找,二
叉排序树查找,哈希散列法,分块查找,平衡多路搜索树B树（B-tree）
13/04/2018 Page 215 of 283
19.1.2.1. 常见索引原则有
1.选择唯一性索引
1． 唯一性索引的值是唯一的，可以更快速的通过该索引来确定某条记录。
2.为经常需要排序、分组和联合操作的字段建立索引：
3．为常作为查询条件的字段建立索引。
4．限制索引的数目：
越多的索引，会使更新表变得很浪费时间。
尽量使用数据量少的索引
6． 如果索引的值很长，那么查询的速度会受到影响。
尽量使用前缀来索引
7． 如果索引字段的值很长，最好使用值的前缀来索引。
7．删除不再使用或者很少使用的索引
8 . 最左前缀匹配原则，非常重要的原则。
10 . 尽量选择区分度高的列作为索引
区分度的公式是表示字段不重复的比例
11 .索引列不能参与计算，保持列“干净”：带函数的查询不参与索引。
12 .尽量的扩展索引，不要新建索引。
19.1.3. 数据库三范式
范式是具有最小冗余的表结构。3范式具体如下：
19.1.3.1. 第一范式(1st NF －列都是不可再分)
第一范式的目标是确保每列的原子性:如果每列都是不可再分的最小数据单元（也称为最小的原子
单元），则满足第一范式（1NF）
19.1.3.2. 第二范式(2nd NF－每个表只描述一件事情)
13/04/2018 Page 216 of 283
首先满足第一范式，并且表中非主键列不存在对主键的部分依赖。 第二范式要求每个表只描述一
件事情。
19.1.3.3. 第三范式(3rd NF－ 不存在对非主键列的传递依赖)
第三范式定义是，满足第二范式，并且表中的列不存在对非主键列的传递依赖。除了主键订单编
号外，顾客姓名依赖于非主键顾客编号。
19.1.4. 数据库是事务
事务(TRANSACTION)是作为单个逻辑工作单元执行的一系列操作，这些操作作为一个整体一起向
系统提交，要么都执行、要么都不执行 。事务是一个不可分割的工作逻辑单元
事务必须具备以下四个属性，简称ACID 属性：
原子性（Atomicity）
1. 事务是一个完整的操作。事务的各步操作是不可分的（原子的）；要么都执行，要么都不执
行。
一致性（Consistency）
2. 当事务完成时，数据必须处于一致状态。
13/04/2018 Page 217 of 283
隔离性（Isolation）
3. 对数据进行修改的所有并发事务是彼此隔离的，这表明事务必须是独立的，它不应以任何方
式依赖于或影响其他事务。
永久性（Durability）
4. 事务完成后，它对数据库的修改被永久保持，事务日志能够保持事务的永久性。
19.1.5. 存储过程(特定功能的 SQL 语句集)
一组为了完成特定功能的 SQL 语句集，存储在数据库中，经过第一次编译后再次调用不需要再次
编译，用户通过指定存储过程的名字并给出参数（如果该存储过程带有参数）来执行它。存储过
程是数据库中的一个重要对象。
存储过程优化思路：
1. 尽量利用一些sql语句来替代一些小循环，例如聚合函数，求平均函数等。
2. 中间结果存放于临时表，加索引。
3. 少使用游标。sql 是个集合语言，对于集合运算具有较高性能。而 cursors 是过程运算。比如
对一个 100 万行的数据进行查询。游标需要读表 100 万次，而不使用游标则只需要少量几次
读取。
4. 事务越短越好。sqlserver 支持并发操作。如果事务过多过长，或者隔离级别过高，都会造成
并发操作的阻塞，死锁。导致查询极慢，cpu占用率极地。
5. 使用try-catch处理错误异常。
6. 查找语句尽量不要放在循环内。
19.1.6. 触发器(一段能自动执行的程序)
触发器是一段能自动执行的程序，是一种特殊的存储过程，触发器和普通的存储过程的区别是：
触发器是当对某一个表进行操作时触发。诸如：update、insert、delete 这些操作的时候，系统
会自动调用执行该表上对应的触发器。SQL Server 2005 中触发器可以分为两类：DML 触发器和
DDL 触发器，其中 DDL 触发器它们会影响多种数据定义语言语句而激发，这些语句有 create、
alter、drop语句。
19.1.7. 数据库并发策略
并发控制一般采用三种方法，分别是乐观锁和悲观锁以及时间戳。
19.1.7.1. 乐观锁
乐观锁认为一个用户读数据的时候，别人不会去写自己所读的数据；悲观锁就刚好相反，觉得自
己读数据库的时候，别人可能刚好在写自己刚读的数据，其实就是持一种比较保守的态度；时间
戳就是不加锁，通过时间戳来控制并发出现的问题。
13/04/2018 Page 218 of 283
19.1.7.2. 悲观锁
悲观锁就是在读取数据的时候，为了不让别人修改自己读取的数据，就会先对自己读取的数据加
锁，只有自己把数据读完了，才允许别人修改那部分数据，或者反过来说，就是自己修改某条数
据的时候，不允许别人读取该数据，只有等自己的整个事务提交了，才释放自己加上的锁，才允
许其他用户访问那部分数据。
19.1.7.3. 时间戳
时间戳就是在数据库表中单独加一列时间戳，比如“TimeStamp”，每次读出来的时候，把该字
段也读出来，当写回去的时候，把该字段加1，提交之前 ，跟数据库的该字段比较一次，如果比数
据库的值大的话，就允许保存，否则不允许保存，这种处理方法虽然不使用数据库系统提供的锁
机制，但是这种方法可以大大提高数据库处理的并发量，
以上悲观锁所说的加“锁”，其实分为几种锁，分别是：排它锁（写锁）和共享锁（读锁）。
19.1.8. 数据库锁
19.1.8.1. 行级锁
行级锁是一种排他锁，防止其他事务修改此行；在使用以下语句时，Oracle会自动应用行级锁：
1. INSERT、UPDATE、DELETE、SELECT … FOR UPDATE [OF columns] [WAIT n | NOWAIT];
2. SELECT … FOR UPDATE语句允许用户一次锁定多条记录进行更新
3. 使用COMMIT或ROLLBACK语句释放锁。
19.1.8.2. 表级锁
表示对当前操作的整张表加锁，它实现简单，资源消耗较少，被大部分MySQL 引擎支持。最常使
用的 MYISAM 与 INNODB 都支持表级锁定。表级锁定分为表共享读锁（共享锁）与表独占写锁
（排他锁）。
19.1.8.1. 页级锁
页级锁是MySQL中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级
冲突少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录。BDB支持页级锁
19.1.9. 基于 Redis分布式锁
1. 获取锁的时候，使用setnx（SETNX key val：当且仅当key不存在时，set一个key
为 val 的字符串，返回 1；若 key 存在，则什么都不做，返回 0）加锁，锁的 value
值为一个随机生成的 UUID，在释放锁的时候进行判断。并使用 expire 命令为锁添
加一个超时时间，超过该时间则自动释放锁。
13/04/2018 Page 219 of 283
2. 获取锁的时候调用 setnx，如果返回 0，则该锁正在被别人使用，返回 1 则成功获取
锁。 还设置一个获取的超时时间，若超过这个时间则放弃获取锁。
3. 释放锁的时候，通过 UUID 判断是不是该锁，若是该锁，则执行 delete 进行锁释放。
19.1.10. 分区分表
分库分表有垂直切分和水平切分两种。
垂直切分(按照功能模块)
(cid:131) 将表按照功能模块、关系密切程度划分出来，部署到不同的库上。例如，我们会建立定义数
据库 workDB、商品数据库 payDB、用户数据库 userDB、日志数据库 logDB 等，分别用于