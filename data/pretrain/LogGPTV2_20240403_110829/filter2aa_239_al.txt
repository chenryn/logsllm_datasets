        Type ageType = age.GetType();
        Type isRabbitType = isRabbit.GetType();
        WriteLine($"name is type {nameType}");
        WriteLine($"age is type {ageType}");
        WriteLine($"isRabbit is type {isRabbitType}");
        }
      }
    }
这个程序的输出如下：
    name is type System.String
    age is type System.Int32
    isRabbit is type System.Bool
需要遵循一些规则：
● 变量必须初始化。否则，编译器就没有推断变量类型的依据。
● 初始化器不能为空。
● 初始化器必须放在表达式中。
● 不能把初始化器设置为一个对象，除非在初始化器中创建了一个新对象。
第3章在讨论匿名类型时将详细探讨这些规则。
声明了变量，推断出了类型后，就不能改变变量的类型了。变量的类型确定后，就遵
循其他变量类型遵循的强类型化规则。
2.3.3 变量的作用域
变量的作用域是可以访问该变量的代码区域。一般情况下，确定作用域遵循以下规
则：
● 只要类在某个作用域内，其字段（也称为成员变量）也在该作用域内。
● 局部变量存在于表示声明该变量的块语句或方法结束的右花括号之前的作用域内。
● 在for、while或类似语句中声明的局部变量存在于该循环体内。
1．局部变量的作用域冲突
大型程序在不同部分为不同的变量使用相同的变量名很常见。只要变量的作用域是程
序的不同部分，就不会有问题，也不会产生多义性。但要注意，同名的局部变量不能在同
一作用域内声明两次。例如，不能使用下面的代码：
    int x = 20;
    // some more code
    int x = 30;
考虑下面的代码示例（代码文件VariableScopeSample/Program.cs）：
    using static System.Console;
    namespace VariableScopeSample
    {
      class Program
      {
        static int Main()
        {
        for (int i = 0; i = 0; i -)
        {
          WriteLine(i);
        }  // i goes out of scope here.
        return 0;
        }
      }
    }
这段代码很简单，使用两个for循环打印0～9的数字，再逆序打印0～9的数字。重要
的是在同一个方法中，代码中的变量i声明了两次。可以这么做的原因是i在两个相互独立
的循环内部声明，所以每个变量i对于各自的循环来说是局部变量。
下面是另一个例子（代码文件VariableScopeSample2/Program.cs）：
    static int Main()
    {
      int j = 20;
      for (int i = 0; i < 10; i++)
      {
        int j = 30; // Can't do this - j is still in scope
        WriteLine(j + i);
      }
      return 0;
    }
如果试图编译它，就会产生如下错误：
    error CS0136: A local variable named 'j' cannot be declared in
    this scope because that name is used in an enclosing local scope
    to define a local or parameter
其原因是：变量j是在for循环开始之前定义的，在执行for循环时仍处于其作用域内，
直到Main（）方法结束执行后，变量j才超出作用域。第2个j （不合法）虽然在循环的作
用域内，但作用域嵌套在Main（）方法的作用域内。因为编译器无法区分这两个变量，
所以不允许声明第二个变量。
2．字段和局部变量的作用域冲突
某些情况下，可以区分名称相同（尽管其完全限定名不同）、作用域相同的两个标识
符。此时编译器允许声明第二个变量。原因是C#在变量之间有一个基本的区分，它把在
类型级别声明的变量看成字段，而把在方法中声明的变量看成局部变量。
考虑下面的代码片段（代码文件VariableScopeSample3/Program.cs）：
    using static System.Console;
    namespace Wrox
    {
      class Program
      {
        static int j = 20;
        static void Main()
        {
        int j = 30;
        WriteLine(j);
        return;
        }
      }
    }
虽然在Main（）方法的作用域内声明了两个变量j，这段代码也会编译：一个是在类
级别上定义的j，在类Program删除前（在本例中，是Main（）方法终止，程序结束时）是
不会超出作用域的；一个是在Main（）中定义的j。这里，在Main（）方法中声明的新变
量j隐藏了同名的类级别变量，所以在运行这段代码时，会显示数字30。
但是，如果要引用类级别变量，该怎么办？可以使用语法object.fieldname，在对象的
外部引用类或结构的字段。在上面的例子中，访问静态方法中的一个静态字段（静态字段
详见2.3.4小节），所以不能使用类的实例，只能使用类本身的名称：
    // etc.
    static void Main()
    {
      int j = 30;
      WriteLine(j);
      WriteLine(Program.j);
    }
    // etc.
如果要访问实例字段（该字段属于类的一个特定实例），就需要使用this关键字。
2.3.4 常量
顾名思义，常量是其值在使用过程（生命周期）中不会发生变化的变量。在声明和初
始化变量时，在变量的前面加上关键字const，就可以把该变量指定为一个常量：
    const int a = 100; // This value cannot be changed.
常量具有如下特点：
● 常量必须在声明时初始化。指定了其值后，就不能再改写了。
● 
常量的值必须能在编译时用于计算。因此，不能用从变量中提取的值来初始化常
量。如果需要这么做，应使用只读字段（详见第3章）。
● 常量总是隐式静态的。但注意，不必（实际上，是不允许）在常量声明中包含修饰
符static。
在程序中使用常量至少有3个好处：
● 由于使用易于读取的名称（名称的值易于理解）替代了较难读取的数字和字符串，
常量使程序变得更易于阅读。
● 
常量使程序更易于修改。例如，在C#程序中有一个SalesTax常量，该常量的值为
6%。如果以后销售税率发生变化，把新值赋给这个常量，就可以修改所有的税款
计算结果，而不必查找整个程序去修改税率为0.06的每个项。
● 常量更容易避免程序出现错误。如果在声明常量的位置以外的某个地方将另一个值
赋给常量，编译器就会标记错误。
2.4 预定义数据类型
前面介绍了如何声明变量和常量，下面要详细讨论C#中可用的数据类型。与其他语
言相比，C#对其可用的类型及其定义有更严格的描述。
2.4.1 值类型和引用类型
在开始介绍C#中的数据类型之前，理解C#把数据类型分为两种非常重要：
● 值类型
● 引用类型
下面几节将详细介绍值类型和引用类型的语法。从概念上看，其区别是值类型直接存
储其值，而引用类型存储对值的引用。
这两种类型存储在内存的不同地方：值类型存储在堆栈（stack）中，而引用类型存
储在托管堆（managed heap）上。注意区分某个类型是值类型还是引用类型，因为这会有
不同的影响。例如，int是值类型，这表示下面的语句会在内存的两个地方存储值20：
    // i and j are both of type int
    i = 20;
    j = i;
但考虑下面的代码。这段代码假定已经定义了类Vector, Vector是一个引用类型，它有
一个int类型的成员变量Value：
    Vector x, y;
    x = new Vector();
    x.Value = 30; // Value is a field defined in Vector class
    y = x;
    WriteLine(y.Value);
    y.Value = 50;
    WriteLine(x.Value);
要理解的重要一点是在执行这段代码后，只有一个Vector对象。x和y都指向包含该对
象的内存位置。因为x和y是引用类型的变量，声明这两个变量只保留了一个引用——而不
会实例化给定类型的对象。两种情况下都不会真正创建对象。要创建对象，就必须使用
new关键字，如上所示。因为x和y引用同一个对象，所以对x的修改会影响y，反之亦然。
因此上面的代码会显示30和50。
如果变量是一个引用，就可以把其值设置为null，表示它不引用任何对象：
    y = null;
如果将引用设置为null，显然就不可能对它调用任何非静态的成员函数或字段，这么
做会在运行期间抛出一个异常。
在C#中，基本数据类型（如bool和long）都是值类型。如果声明一个bool变量，并给
它赋予另一个bool变量的值，在内存中就会有两个bool值。如果以后修改第一个bool变量
的值，第二个bool变量的值也不会改变。这些类型是通过值来复制的。
相反，大多数更复杂的C#数据类型，包括我们自己声明的类，都是引用类型。它们
分配在堆中，其生存期可以跨多个函数调用，可以通过一个或几个别名来访问。CLR实现
一种精细的算法，来跟踪哪些引用变量仍是可以访问的，哪些引用变量已经不能访问了。
CLR会定期删除不能访问的对象，把它们占用的内存返回给操作系统。这是通过垃圾回收
器实现的。
把基本类型（如int和bool）规定为值类型，而把包含许多字段的较大类型（通常在有
类的情况下）规定为引用类型，C#设计这种方式是为了得到最佳性能。如果要把自己的
类型定义为值类型，就应把它声明为一个结构。
2.4.2 .NET类型
数据类型的C#关键字（如int、short和string）从编译器映射到.NET数据类型。例如，
在C#中声明一个int类型的数据时，声明的实际上是.NET结构System.Int32的一个实例。这
听起来似乎很深奥，但其意义深远：这表示在语法上，可以把所有的基本数据类型看成支
持某些方法的类。例如，要把int i转换为string类型，可以编写下面的代码：
    string s = i.ToString();
应强调的是，在这种便利语法的背后，类型实际上仍存储为基本类型。基本类型在概
念上用.NET结构表示，所以肯定没有性能损失。
下面看看C#中定义的内置类型。我们将列出每个类型，以及它们的定义和对应.NET
类型的名称。C#有15个预定义类型，其中13个是值类型，两个是引用类型（string和
object）。
2.4.3 预定义的值类型
内置的.NET值类型表示基本类型，如整型和浮点类型、字符类型和布尔类型。
1．整型
C#支持8个预定义的整数类型，如表2-1所示。
表2-1
名称
.NET类型
说明
范围（最小～最大）
sbyte
System.SByte
8位有符号的整
数
-128～127 （-27 ～27 -1）
short
System.Int16
16位有符号的
整数
-32 768～32 767 （-215 ～215 -1）
int
System.Int32
32位有符号的
整数
-2 147 483 648～2 147 483 647
（-231 ～231 -1）
long
System.Int64
64位有符号的
整数
-9 223 372 036 854 775 808～9
223 372 036 854 775 807 （-263 ～
263 -1）
byte
System.Byte
8位无符号的整
数
0～255 （0～28 -1）
ushort
System.UInt16
16位无符号的
整数
0～65 535 （0～216 -1）
uint
System.UInt32
32位无符号的
整数
0～4 294 967 295 （0～232 -1）
ulong
System.UInt64
64位无符号的
整数
0～18 446 744 073 709 551 615
（0～264 -1）
有些C#类型的名称与C++和Java类型一致，但定义不同。例如，在C#中，int总是32位
有符号的整数。而在C++中，int是有符号的整数，但其位数取决于平台（在Windows上是
32位）。在C#中，所有的数据类型都以与平台无关的方式定义，以备将来从C#和.NET迁
移到其他平台上。
byte是0～255（包括255）的标准8位类型。注意，在强调类型的安全性时，C#认为
byte类型和char类型完全不同，它们之间的编程转换必须显式请求。还要注意，与整数中
的其他类型不同，byte类型在默认状态下是无符号的，其有符号的版本有一个特殊的名称
sbyte。
在.NET中，short不再很短，现在它有16位长。int类型更长，有32位。long类型最
长，其值有64位。所有整数类型的变量都能被赋予十进制或十六进制的值，后者需要0x前
缀：
    long x = 0x12ab;
如果对一个int、uint、long还是ulong类型的整数没有任何显式的声明，则该变量默认
为int类型。为了把输入的值指定为其他整数类型，可以在数字后面加上如下字符：
    uint ui = 1234U;
    long l = 1234L;
    ulong ul = 1234UL;
也可以使用小写字母u和l，但后者会与整数1混淆。
2．浮点类型
C#提供了许多整数数据类型，也支持浮点类型，如表2-2所示。
表2-2
float数据类型用于较小的浮点值，因为它要求的精度较低。double数据类型比float数
据类型大，提供的精度也大一倍（15位）。
如果在代码中对某个非整数值（如12.3）硬编码，则编译器一般假定该变量是
double。如果想指定该值为float，可以在其后加上字符F（或f）：
    float f = 12.3F;
3. decimal类型
decimal类型表示精度更高的浮点数，如表2-3所示。
表2-3
.NET和C#数据类型一个重要的优点是提供了一种专用类型进行财务计算，这就是
decimal类型。使用decimal类型提供的28位的方式取决于用户。换言之，可以用较大的精
确度（带有美分）来表示较小的美元值，也可以在小数部分用更多的舍入来表示较大的美
元值。但应注意，decimal类型不是基本类型，所以在计算时使用该类型会有性能损失。
要把数字指定为decimal类型而不是double、float或整数类型，可以在数字的后面加上
字符M（或m），如下所示：
    decimal d = 12.30M;
4. bool类型
C#的bool类型用于包含布尔值true或false，如表2-4所示。
表2-4
bool值和整数值不能相互隐式转换。如果变量（或函数的返回类型）声明为bool类
型，就只能使用值true或false。如果试图使用0表示false，非0值表示true，就会出错。
5．字符类型
为了保存单个字符的值，C#支持char数据类型，如表2-5所示。
表2-5
名称
.NET类型
值