title:A General Approach for Efficiently Accelerating Software-based Dynamic
Data Flow Tracking on Commodity Hardware
author:Kangkook Jee and
Georgios Portokalidis and
Vasileios P. Kemerlis and
Soumyadeep Ghosh and
David I. August and
Angelos D. Keromytis
A	
  General	
  Approach	
  for	
  Eﬃciently	
Accelera3ng	
  So6ware-­‐based	
  Dynamic	
  Data	
Flow	
  Tracking	
  on	
  Commodity	
  Hardware	
Kangkook	
  Jee	
Columbia	
  University	
Joint	
  work	
  with	
Georgios	
  Portokalidis1	
  ,	
  Vasileios	
  Kemerlis1	
  ,	
Soumyadeep	
  Ghosh2,	
  David	
  August2,	
  Angelos	
  Keromy3s1	
1Columbia	
  University,	
  2Princeton	
  University	
1	
Data	
  Flow	
  Tracking	
  (DFT)	
•  A	
  great	
  security	
  tool	
  with	
  many	
  applica3ons	
– Tag	
  input	
  data	
  and	
  track	
  them	
– So6ware	
  exploits,	
  Informa3on	
  misuse	
  or	
  leakage	
malware	
  analysis	
  …	
•  Implementa3on	
  approaches	
– Hardware	
  assisted:	
  Raksha,	
  RIFLE	
  …	
– Source	
  code	
  based:	
  GIFT	
  …	
– Binary	
  only:	
  TaintCheck,	
  Dytan,	
  Minemu,	
  Libd6	
  …	
  Binary	
  only	
  DFT:	
  Most	
  promising,	
  but	
  too	
  slow!	
2	
This	
  Talk	
  Is	
  About	
•  New	
  op3miza3on	
  approach	
  for	
– Currently	
  sub-­‐op3mal	
  binary	
  only	
  DFT	
– Performance	
  gain	
  up	
  to	
  x2.23	
  (on	
  average	
  x1.77)	
– Real-­‐world	
  applica3ons:	
  Firefox,	
  Chrome	
  …	
•  Segrega3on	
  of	
  tracking	
  logic	
  from	
  execu3on	
– Taint	
  Flow	
  Algebra	
  (TFA):	
  IR	
  for	
  DFT	
– Compiler	
  op3miza3on	
  +	
  DFT	
  speciﬁc	
  op3miza3on	
3	
DFT:	
  Basic	
  Aspects	
•  DFT	
  is	
  characterized	
  by	
  three	
  aspects	
(1)  Data	
  Sources:	
  program	
  or	
  memory	
  loca3ons	
  where	
  data	
of	
  interest	
  enter	
  the	
  system	
  and	
  is	
  subsequently	
  tagged	
(2)  Data	
  tracking:	
  process	
  of	
  propaga3ng	
  data	
  tags	
(3)  Data	
  Sinks:	
  program	
  or	
  memory	
  loca3ons	
  where	
  checks	
according	
  to	
  the	
  program’s	
  seman3cs	
for	
  “tagged”	
  data	
  can	
  be	
  made	
Shadow Memory
(1)
Input
File
Network
Keyboard
Source
mov eax,   [ebx]
(2)
mov [esi],   eax
Data Tracking
(3)
Output
File
Network
(cid:1)(cid:2)(cid:4)(cid:3)
4	
DFT	
  Opera3on	
Real Memory
•  Real	
  Memory	
  =	
  Address	
  space	
  +	
  register	
  context	
5	
DFT	
  Opera3on	
Real Memory
Shadow Memory
•  Real	
  Memory	
  =	
  Address	
  space	
  +	
  register	
  context	
•  Shadow	
  memory	
  to	
  track	
  metadata	
  update	
6	
DFT	
  Opera3on	
 dst[idx1] = src[idx0];
Real Memory
Shadow Memory
•  Memory	
  copy	
  statement	
  from	
  the	
  original	
  execu3on	
7	
DFT	
  Opera3on	
 dst[idx1] = src[idx0];
Real Memory
 t(dst[idx1]) = t(src[idx0]);
Shadow Memory
•  Memory	
  copy	
  statement	
  from	
  the	
  original	
  execu3on	
•  Corresponding	
  shadow	
  memory	
  update	
8	
DFT	
  Opera3on	
 dst[idx1] = src[idx0];
mov reg0  ! [src+idx0]
 t(dst[idx1]) = t(src[idx0]);
   mov [dst+idx1] ! reg0
Real Memory
Shadow Memory
•  Original	
  opera3on	
  translated	
  into	
  machine	
  code	
•  It	
  requires	
  intermediate	
  register	
  repository	
  (reg0)	
9	
DFT	
  Opera3on	
 dst[idx1] = src[idx0];
mov reg0  ! [src+idx0]
   mov reg0  ! [t(src+idx0)]
   mov [t(reg0)] ! reg0
 t(dst[idx1]) = t(src[idx0]);
   mov [dst+idx1] ! reg0
Real Memory
Shadow Memory
•  Instruc3on	
  level	
  instrumenta3on	
  to	
  implement	
shadow	
  update	
10	
DFT	
  Opera3on	
 dst[idx1] = src[idx0];
Real Memory
 t(dst[idx1]) = t(src[idx0]);
Shadow Memory
mov reg0  ! [src+idx0]
   mov reg0  ! [t(src+idx0)]
   mov [t(reg0)] ! reg0
   mov [dst+idx1] ! reg0
   mov reg0  ! [t(reg0)]
   mov [t(dst+idx1)] ! mov reg0
•  2	
  original	
  instruc3ons	
  +	
  4	
  tracking	
  instruc3ons	
•  2	
  instrumenta3on	
  units	
11	
Why	
  So	
  Slow?	
•  Framework	
  cost	
– DBI,	
  Hypervisor	
  instrumenta3on	
•  DFT	
  cost	
– Accesses	
  to	
  shadow	
  storage	
•  Naïve	
  Implementa3on	
– No	
  understanding	
  of	
  global	
  context	
– No	
  understanding	
  of	
  DFT	
  seman3cs	
12	
Our	
  Approach	
•  Applica3on	
  speciﬁc	
  analysis	
•  DFT	
  speciﬁc	
  analysis	
•  Integrated	
  with	
  libd)	
– High	
  performance	
  DFT	
  tool	
  [VEE	
  2012]	
•  1.46x	
  ~	
  8x	
  slowdown	
  (over	
  na3ve	
  execu3on)	
– Designed	
  for	
  use	
  with	
  Pin	
  DBI	
  framework	
– Open	
  source	
•  hqp://www.cs.columbia.edu/~vpk/research/libd6	
13	
Op3mizing	
  DFT	
mov reg0  ! [src+idx0]
   mov reg0  ! [t(src+idx0)]
   mov [t(reg0)] ! reg0
   mov [dst+idx1] ! reg0
   mov reg0  ! [t(reg0)]
   mov [t(dst+idx1)] ! mov reg0
•  Each	
  Instrumenta3on	
  unit	
  requires	
  head/tail	
  instruc3ons	
•  t(	
  )	
  :	
  shadow	
  memory	
  access	
  cost	
14	
Op3mizing	
  DFT	
mov reg0  ! [src+idx0]
   mov reg0  ! [t(src+idx0)]
   mov [t(reg0)] ! reg0
   mov [dst+idx1] ! reg0
   mov reg0  ! [t(reg0)]
   mov [t(dst+idx1)] ! mov reg0
•  Re-­‐locatable	
15	
Op3mizing	
  DFT	
mov reg0  ! [src+idx0]
mov [dst+idx1] ! reg0
   mov reg0  ! [t(src+idx0)]
   mov [t(reg0)] ! reg0
   mov reg0  ! [t(reg0)]
   mov [t(dst+idx1)] ! mov reg0
•  Less	
  instrumenta3on	
  units	
  (21)	
16	
Op3mizing	
  DFT	
mov reg0  ! [src+idx0]
mov [dst+idx1] ! reg0
   mov reg0  ! [t(src+idx0)]
   mov [t(reg0)] ! reg0
   mov reg0  ! [t(reg0)]
   mov [t(dst+idx1)] ! mov reg0
•  Less	
  instrumenta3on	
  units	
  (21)	
•  Less	
  tracking	
  instruc3ons	
  (42)	
17	
Execu3on	
  Model	
•  3	
  Components	
–  Feedback	
  loop	
–  	
  Proﬁler,	
  Analyzer,	
  DFT	
  Run3me	
•  Sta3c/oﬄine	
  analysis	
  +	
  Dynamic	
  run3me	
Optimized data 
tracking
DFT 
Runtime
Analyzer
Unprocessed 
basic blocks
Control ﬂow
information
Basic blocks
Dynamic 
proﬁler
Static 
Proﬁler
18	
Analyzer	
•  Taint	
  Flow	
  Algebra	
–  Represent	
  binary	
  analysis	
  result	
–  IR	
  tailored	
  to	
  capture	
  DFT	
  seman3cs	
•  Compiler	
  op3miza3on	
  to	
  TFA	
–  Inner	
  (intra)	
  basic	
  block:	
–  Outer	
  (inter)	
  basic	
  block:	
  Dead	
  code	
  elimina3on,	
  Algebraic	
  simpliﬁca3on,	
  …	
  Data	
  ﬂow	
  analysis	
•  DFT	
  speciﬁc	
  considera3ons	
–  Valid	
  loca3on	
  for	
  each	
  instrumenta3on	
  unit	
–  Number	
  of	
  instrumenta3on	
  units	
19	
TFA	
  Op3miza3on	
!"#$%&#'()*#'+,
-"#$%&.)/#'0)*#01
2"#+31#'()*#4)5
6"#077#'7)*4)!
5"#1'0#'+,*#89:#;'()"#1'0#'+,*#89:#;'0)"#1'0#'+,*#89:#;'0)"#1'0#'+,*#89:#;'0)"#1'0#'+,*#89:#;'0)<'+,=
?"#$%&.)/#'0)*#89:#;'7)<'+,=######
@"#9'+9/#01*#01
A"#BC./#4)/?@A4-44
(a) x86 instruction
|
esi2
&
eax2
&
eax1
&
esi1
[edx0+esi2]
0x1
eax0
0x1
esi0
ecx1
•  DAG	
  Representa3on	
•  Express	
  root	
  nodes	