www.TopSage.com
16.5方法组合
171
---
## Page 189
而同时保存它的一部分老的行为。
该:before方法，从而使得checking-account子类的作者可以更容易地扩展withdraw的行为
整体行为的方式变得非常直观，但它并不打算影响主要的行为或是改变返回的结果。
下面这样来实现对现金账户的透支保护：
主方法可以运行的准备工作。例如，你可以使用特化在checking-account上的:before方法像
最相关的主方法之前以最相关者优先的顺序来运行。这样，：before方法可用来做任何需要确保
是最相关的）都将作为有效方法的一部分来运行。如同其名字所显示的，这些:before方法将在
的:before方法以下面的定义开始：
于方法名和形参列表之间。例如，一个在类bank-account上特化了account形参的withdraw
个主方法那样写成的，但是它带有一个方法限定符（method qualifier），其命名了方法的类型，介
支持三种类型的辅助方法：:before、:after和:around。附加方法定义是用DEFMETHoD像一
method)。如同其名字所显示的，主方法被用于提供一个广义函数的主要实现。标准方法组合也
CALL-NEXT-METHOD将控制传递给下一个最相关的方法。
CALL-NEXT-METHOD像你看到的那样工作—最相关的方法首先运行，然后每个方法可以通过
准方法组合（standard method combination）的机制。标准方法组合将方法组合在一起，从而使
步—排序的方法列表是如何被组合成单一有效方法的。默认情况下，广义函数使用一种称为标
16.6标准方法组合
这样对这些方法的比较将取决于其他参数。
对于一个特定形参有多于一个方法带有EQL特化符，那么它们定全部带有相同的EQL特化符。
继承。目前我要说明的只是存在一个确定的算法来决定类特化符的顺序。
相关这一规则来决定它们的顺序。在下一章里，我将讨论特化性的概念如何被扩展用于处理多重
方的子类。如果这样的类被用于参数特化符，那么广义函数就无法只通过子类比它们的基类更加
不过，这里面还有更多的细节。到目前为止，我所讨论过的所有方法都称为主方法（primary
最后，EQL特化符总是比任何类特化符更加相关，并且由于只有可应用的方法被考虑，如果
172
下一个优点在于，一个特化在比checking-account更相关类上的主方法将不会影响
这个:before方法相比于一个主方法有三个优点。其中之一是它使得该方法改变withdraw
每种类型的附加方法以不同的方式组合到有效方法之中。所有可应用的:before方法（不只
现在，你理解了找出可应用的方法并对它们进行排序的方式，你可以更进一步来观察最后一
多重继承稍微复杂化了特化性的概念，因为实际参数可能是两个类的实例，而两者都不是对
(defmethod withdraw :before ((account checking-account) amount)
(let ((overdraft (- amount (balance account))))
fwhe
第16章重新审视面向对象：广义函数
(incf (balance account) overdraft))))
www.TopSage.com
account account) overdraft)
---
## Page 190
和标准方法组合中的：around方法具有相似的工作方式。
另外简单组合只支持两种方法：按照刚刚描述的方式进行组合的主方法，以及：around方法，它
种组合分别以下列操作符来命名：+、AND、OR、LIST、APPEND、NCONC、MIN、MAX和PROGN。
包装在一个由方法组合的名字所给出的函数、宏或特殊操作符的调用中来产生一个有效方法。9
来调用次相关主方法的方式有所不同，简单方法组合通过将所有主方法的代码一个接一个地全部
简单内置组合的功能。
你还可以自定义方法组合，尽管这是一个相对难懂的特性并且超出了本书的范围。我将简要介绍
16.7
的主方法，然后允许该库的用户通过定义适当的附加方法来定制它的行为。
大的好处在于它们提供了一个扩展广义函数的统一框架。通常库将定义一个广义函数并提供默认
通过将带有额外努力的主方法与一些代码约定和额外输入相组合所不能做到的事情。也许它们最
参数下的语义，包括未来定义的子类。
CALL-NExT-METHOD的：around的方法有责任正确实现广义函数在方法可能应用到的所有类型
一个缓存自之前对CALL-NEXT-METHOD的调用时。不管怎么说，一个没有调用
讨论这一点）。差不多一个：around方法不去调用cALL-NEXT-METHOD的唯一场合就是当它返回
法得以运行的动态上下文。例如绑定一个动态变量，或是建立一个错误处理器（我将在第19章里
的方法就会完全劫持广义函数中除了最相关：around方法之外的所有方法的实现。
的：around方法都会含有一个对cALL-NExT-METHOD的调用，因为如果不这样做的话，：around
的：arouna的方法中指向由：before方法、主方法和：after方法组成的复合体。几乎所有
中，CALL-NEXT-METHOD将指向下一个最相关的：around方法的代码，或是在最不相关
这就是说，来自最相关：around方法的代码将在其他任何代码之前运行。在：around方法的主体
工作。
运行，而每一个更相关的：after方法将有机会在所有主方法和更不相关的：after之后进行清理
一个更相关的：before方法将有机会设置环境以便不太相关的：before方法和主方法得以成功
和：after方法组合在一起创建了一系列嵌套包装在由主方法所提供的核心功能周边的环境。每
主方法之后以最相关者最不优先的顺序运行，也就是说与：before方法相反。这样，：before
就不可能因为忘记这点而引人bug。
最后，除了它们运行在所有其他方法的外围，：around将以非常类似主方法的方式被组合
所有的简单组合都遵循了相同的模式：和调用最相关主方法并让它通过CALL-NEXT-METHOD
在标准方法组合之外，该语言还指定了九种其他的内置方法组合，也称为简单内置方法组合。
附加方法只是一种更简洁和具体地表达特定常用模式的便利方式。它们并不能让你做到任何
这种类型的方法劫持偶尔也会被用到，但是典型的：arouna方法通常被用于建立一些其他方
其他的附加方法同样以它们的名字所建议的方式融合进有效方法。所有的：after方法都在
其他方法组合
www.TopSage.com
16.7
C.com
16
---
## Page 191
息传递真正有区别的地方。多重方法无法存在于消息传递语言之中是因为它们不属于一个特定的
可能99%的情况将被一个简单内置方法组合处理。如果你遇到了1%中的1%的情况，其中没有内置组
更加简洁且更富有表达性。
实可以允许你表达你所想要的事情，并且让语言来帮助你将所有东西组织在一起从而使你的代码
影响:around方法的顺序。并且如同我前面提到的,内置方法组合不支持:before或:after方法，
递给越来越不相关的:around方法，直到到达组合的主方法。:most-specific-last选项并不
类似：最相关的：arOund方法在任何其他方法之前运行，而CALL-NEXT-METHOD被用于将控制传
一个特定于priority的主方法可能看起来像这样：
你可以像下面这样使用最相关者最不优先的顺序来改变priority：
该顺序在你使用“+”组合的时候可能无关紧要，除非方法带有副作用，但是出于演示的目的，
在DEFGENERIC形式中的方法组合名之后包含关键字:most-Specific-last来逆转这一顺序。
以写成下面这样：
为了定义一个广义函数priority，其使用“+”方法组合返回所有单独方法的返回值之和，你可
个:method-combination选项。连同该选项所提供的值是你想要使用的方法组合的名字。例如，
由任何方法返回的非NIL的值。
在一个方法返回NIL时立即返回，否则将返回最后一个方法的值。类似地，OR组合将返回第一个
这些宏的短路行为，AND和OR方法组合不一定会运行所有主方法——使用AND组合的广义函数将
16.8
和标准方法组合一样，这些方法组合不允许你做到任何你不能手工做到的事情。但是它们确
为了定义一个使用特定方法组合的广义函数，你可以在DEFGENERIC形式中包含-
这就是说,很可能在99%的时间里标准方法组合是你需要的东西。在其中剩下的1%的事件里,
例如，一个使用“+”方法组合的广义函数将返回其有主方法返回的结果之和。注意到由于
174
显式地特化了超过一个广义函数的必要形参的方法称为多重方法。多重方法是广义函数和消
所有简单内置方法组合也支持：around方法，其工作方式与标准方法组合中的：around方法
这可以使你清楚地看到一个属于特定类型广义函数的方法定义。
定义在使用这些组合之一的广义函数上的主方法必须被限定在该方法组合的名字上。这样，
默认情况下，所有这些方法组合以最相关者优先的顺序组合主方法。尽管如此，你可以通过
(defgeneric priority (job)
(defgeneric priority (job)
(:method-combination +))
多重方法
第16章重新审视面向对象：广义函数
the priority
 the priority at which the job should be run.")
www.TopSage.com
at which the job should be run.")
---
## Page 192
参数的广义函数beat。
的？当然，两者都是。为了在Common Lisp中对这种情况建模，你可以简单地定义一个接受两个
应该属于哪个类。一个鼓在用鼓棒敲它的时候产生的声音究竟是由鼓的类型还是棒的类型决定
该方法的特化参数被调用时采用。
类；相反，每一个多重方法都定义了一个给定广义函数的部分实现，并且当广义函数以匹配所有
中的代码并不属于任何一个类。
传递语言里有可能手工实现多重分发，但这将与消息传递模型背道而驰，因为多重分发的方法
是运行期。为了观察方法重载的工作方式，考虑下面的两个Java类：
言特性相当不同，因为重载的方法是在编译期被选择的，其所基于的是编译期的参数类型而不
起来类似于这些语言中一种称为方法重载（methodoverloading）的特性。不过事实上这两种语
曾经使用过诸如Java和C++这些静态类型消息传递语言的程序员们可能认为，多重方法听
(defgeneric beat (drum stick)
多重方法对于所有这些情形都很完美，而在一个消息传递语言里你将很难决定一个特定行为
如果重载的方法像CommonLisp的多重方法那样工作，那么上面将打印出“B/B”。在消息
B/A
bashs java com.gigamonkeys.Main B
不过，如果你告诉Main来实例化B，那么obj的真正类型将只有一半被实际分发。
当你告诉Main来实例化A时，它像你可能期待的那样打印出“A/A”。
public class Main {
现在考虑当你从下面的类中运行main方法时将会发生什么。
A/A
bashs java com.gigamonkeys.Main A.
( :documentation 
public static void main(String[] argv) (
"Produce a sound by hitting the given drum with the given stick."))
public void foo(B b) ( System.out.println("A/B"); )
obj.foo(obj) ;
 A obj = argv[o].equals("A") ? new A() : new B();
：
 System.out.println("B/A") ;
www.TopSage.com
16.8多重方法
175
---
## Page 193
统中的动词。在下一章里，我将向你展示如何定义你自己的类。
16.9
将完全无关的类联系在一起来描述它们的组合行为，而不要求这些类彼此之间的任何互操作。
道任何关于不同类型鼓棒的信息，而鼓棒类也不需要知道任何关于不同类型鼓的信息。多重方法
理特化在单一参数上的方法相同的内置多态分发技术。
同的方法来实现所有的组合。多重方法使你免于手工编写大量用于分发的代码，而让你使用与处
一种组合都产生不同的声音，那么不存在更好的办法。无论是否使用多重方法你都需要三十种不
我已经介绍了广义函数的基础，并且还介绍了超出范围之外的内容，即Common Lisp对象系
多重方法还可以使你免于将一组类互相关联在一起。在鼓/棒示例中，鼓类的实现不需要知
176
① 在没有多重方法的语言里，你必须手工编写分发代码来实现依赖于超过一个对象的类的行为。流行的Visitor的设
多重方法不能帮助处理组合爆炸。如果你需要建模五种类型的鼓和六种类型的鼓棒，并且每
然后，你可以定义不同的多重方法来实现用于你所关心的不同组合的beat。例如：
(defmethod
defmethodbeat
(defmethod beat ((drum snare-drum) (stick wooden-drumstick)) ...)
Visitor模式在被用作分发超过两个对象时还会快速地陷入组合爆炸。
计模式的目的就是结构化一-系列单一分发的方法调用从而提供多重分发。尽管如此，它要求有一种彼此知道的类。
defmethod
defmethod
未完待续···
第16章重新审视面向对象：广义函数
beat
1 beat
beat
((drum
((drum snare-drum)
(drl
(drum
n snare-drum)
tom-tom)
www.TopSage.com
(stick
(stick soft-mallet))
(stick brush))
brush)
---
## Page 194
和特化在该类上的方法决定的，DEFCLASS的责任仅仅是将类定义为一种数据类型。
17.1
自己的类。这就是本章的主题。
你可以定义特化在它们之上的方法，从而有效地扩展那些类的行为。
中到目前为止讨论过的函数所管理。你不能创建这些类的子类，但是正如你在前一章里看到的，
类层次体系中它们自己的区域里，按照适当的子类和基类关系组织在一起，并且由那些我在本书
学过的代表数据类型的类，诸如INTEGER、STRING和LIST这样的类，都是内置的。它们生活在
T为根的单一层次体系。
的类。但由于我不打算谈论你可以定义不是STANDARD-OBJECT的子类并且其元类不是
时，我指的是那些属于sTANDARD-OBJECT的子类并且其元类（metaclass）是STANDARD-CLASS
一个类作为数据类型的三个方面是它的名字、它与其他类的关系以及构成该类实例的那些槽
②在其他面向对象语言里，“槽”可能被称为字段（feld）、成员变量（member variable）或属性（atribute)。
①为一个已有的类定义新的方法,对于那些曾经使用诸如C++和Java这样的静态类型语言的人们来说可能听起来有些
你可以使用DEFCLASS宏来创建用户定义的类。由于一个类关联的行为是通过定义广义函数
但是当你想要创建新的名词时，例如前一章里用来表示银行帐户的那些类，你就需要定义你