nou
edi, offset s
: "Hacked”
cal1
_puts
.text:00000000004005D9
.text:00000000004005D4
noU
edi,0
;status
call
.text:oeeeeoeoaoaeosp9 target_func
endp
_exit
.text:0000000000400509
.text:0e00000000400SDE
.text:00000000004005DE
.text:0e00000000400SDE
SUBROUTINE
.text:0e00000000400SDE
：Attributes:
.text:0e000000004e0SDE
text:00000000004e05DE
；int _cdecl nain(int argc,const char *argu, const char enup)
.text:0e0ee0e0004e05DE
main
public nain
text:00000000004005DE
proc near
: DATA XREF: _Start+10fo
.text:0e000000a0400SDE
.text:0000000000400SDE
var_18
= byte ptr
18h
.text:0e000000004005DE
.text:00000000004005DE
push
rbp
.text:0e00000004005DF
sub
nou
rsp,10h
rbp,rsp
.text:0e000000004005E2
.text:0e000000a04005E6
lea
rax,[rbp+uar_10]
text:0ee00a00004005EA
noy
rdi, rax
.text:0000000000400SED
leave
cal1
.text:00000000004005F2
gets
.text:00000000004005F3 nain
.text:00000000004005F3
retn
endp
图12-15
测试样例的反汇编代码
可以看到，targetfunc的地址为0x4005C6，栈buff的大小是0x10
的大小，运行到gets函数调用处，内存状态如图12-16所示。
---
## Page 401
CTF特训营：技术详解、解题方法与
12.2.2要盖找缓冲区的具体用途
401/1144
x4905e2
atn+4>:
sub
rsp,0x10
0x4005e6
natn+12>:
in+8>:
Lea
rax,[rbp-0x10]
novt
0x4004b0 
8x4005f3
x4005f2
natn+28>:
Leave
x400514
ORDPTRcs:[rax+rax*1+0xe]
Bx4005fe:
ax,ax
rg[o]:
rdi rsp rax
0x8
0x1
3:0024
rbp
edi,ee
4:80321
图12-16调试时的内存状态
输入命令ni
单
步
跳
过，
然
后
输
入
AAAAAAAABBBBBBBBCCCCCCCCDDDDDDDD
其
中
AAAAAAAABBBBBBBB占据了buff的空间，CCCCCCCCDDDDDDDD
则用于填充rbp和rip的位置，内存状态如图12-17所示。
0x4005e6
in+8>:
Lea
0x4005ed
x4005ea
natn+12>:
leave
getseplt>
:
x4005f3
0sf4
WORD PTR cs:[rax+rax*1+8x0]
intt>:
push
r15
rax
("AAAAAA
bp
CCCCCCCC
图12-17执行到leave指令时的内存状态
单步执行si，运行到ret指令，可以看到返回地址为
DDDDDDDD，即0x4444444444444444，而rbp为CCCCCCCC，即
---
## Page 402
CTF特训营：技术详解、解题方法与
12.2.2要盖找缓冲区的具体用途
402/1144
0x4343434343434343，如图12-18所示
->0x0
ret)
11:
0x24
（b
(:
ebp,ebp)
rdt,rax
nsf2
nafn+20
Leay
eEseoLE:
WORD PTR cs:[rax+rax*1+6x8]
push
r15
图12-18执行到ret指令时的内存状态
将输入中的DDDDDDDD用targetfunc的地址0x4005C6来替代
就能执行到targtet_func，如图12-19所示。
图12-19劫持成功的程序输出
由于能够劫持控制流，在这种情况下，较为复杂的情况就是编写
rop代码。可以根据前面函数栈的调用方式来理解rop代码。
对于x86程序来说，参数传递是通过栈来实现的，在调用完以后
需要清除栈中的参数，所以一般函数调用完之后需要用形如“pop*；
---
## Page 403
CTF特训营：技术详解、解题方法与
12.2.2要盖找缓冲区的具体用途
403/1144
pop*；..ret:"的gadget来调整栈。因为函数调用时返回地址会压
入栈中，即汇编中的“callfunc”指令等同于“pushret_addr:jmp
func”，所以执行jmpfunc的时候，retaddr已经压到栈里面去了，进
入函数时栈的状态如图12-20所示。
通过ret指令将返回到sp所指向的地址，弹出该地址，并调整
sp，因此如果当前指令是ret，那么此时的栈状态应如图12-21所示。
esp/rsp-
ret_addr
argo
arg1
......
argn
局部变量
图12-20函数调用时的栈布局
---
## Page 404
CTF特训营：技术详解、解题方法与
12.2.2要盖找缓冲区的具体用途
404/1144
esp/rsp
func_addr
ret_addr
argo
arg1
......
argn
图12-21执行到ret指令时的栈布局
这也是rop的构造原理。将ret_addr改成“pop*；ret”指令的
gadget，用来弹出后续的args，即成为rop的形式，如图12-22所示。
---
## Page 405
CTF特训营：技术详解、解题方法与
12.2.2要盖找缓冲区的具体用途
405/1144
esp/rsp-
func_addr
pop ret
→popregl......popregn;ret
argo
arg1
argn
图12-22rop构造形式
对于x64程序来说，一般情况下，函数的参数较少，通常主要是
利用寄存器来传递参数的，所以在进入函数之前，应先将寄存器设置
好，对于其rop的理解也比较容易，如图12-23所示。
---
## Page 406
CTF特训营：技术详解、解题方法与
12.2.2要盖找缓冲区的具体用途
406/1144
rsp
gadget1
-->poprdi;ret
低地址
argo
gadget2
-->poprsi;ret
arg1
target_func
->target_fun(rdi,rsi,...)
高地址
**.***
图12-23ropgadget示意图
3）覆盖栈中所存储的临时变量的情况比较简单且常见，主要是
被覆盖的临时变量很有可能在后续的代码中起到很大的作用。
示例代码如下：
#include 
int main()
int info;
charbuff[0x1c];
info=0;
gets(buff);
---
## Page 407
CTF特训营：技术详解、解题方法与
12.2.2要盖找缓冲区的具体用途
407/1144
if (info)
printf("Hacked\n");
printf(%xin",buff);
printf(%xin", &info);
编译命令：
gcc-ooverwirte_varoverwirte_var.c-fno-stack-protector
通过打印的地址可以知道，buff与info的地址相差Ox1c，因此输
入ox1d个字符就能够覆盖到info的值，从而改变info，并影响控制
流，执行结果如图12-24所示。
1111
Hacked
ecbcfc90
ecbcfcac
图12-24rop执行结果
更多示例请参见真题解析。
4）覆盖栈底寄存器bp，使得与bp相关的信息发生改变。这主要
---
## Page 408
CTF特训营：技术详解、解题方法与
12.2.2要盖找缓冲区的具体用途
408/1144
是针对汇编代码，栈底寄存器bp的主要作用是确定函数栈的栈底是
否发生改变，一旦发生改变，函数中所引用的信息都会发生变化。栈
底寄存器bp的主要用途包含如下几个方面。
a）覆盖bp，实现栈转移
这种情况一般主要是针对“leave;ret”指令；该指令等价于
"movsp,bp:popbp:ret”，可以看到，指令执行完毕，栈顶指针被设置
为bp所指向的值。改变bp的值，能起到很多作用，如执行rop、扩展
栈空间等，具体需要根据实际情况来看。如执行rop的情况，若后续
遇到“leave：ret”指令，就会跳转到目的栈上去，如果该栈上布置了
rop，就能达到目的，如图12-25所示。
局部变量
changed
函数栈
ropgadget
ebp/rbp
rip/eip
origin
局部变量
函数栈
dqu/dqa
rip/eip
图12-25栈上rop示意图
---
## Page 409
CTF特训营：技术详解、解题方法与
12.2.2覆盖找缓冲区的具体用途
409/1144
更多示例请参见真题解析。
b）覆盖bp，实现参数索引l改变
一般来说，很多临时变量的索引l，都是根据相对于bp的偏移来
进行的，这一点需要根据汇编指令来进行查看，如图12-26所示。
传进gets的变量，就是根据rbp的偏移来计算的，因此如果rbp发
生了变换，那么后续的很多参数也会发生改变，尤其是输入参数之类
若作为条件判断或者危险函数的传值等，就可能实现更强大的功能。
text:00000000004005E6
lea
rax,[rbp+uar_10]
noU
rdi,rax
text : 00000000004005ED
cal1
_gets
图12-26rbp参数示意图
更多示例请参见真题解析
5）关注敏感函数。
通常，发生栈覆盖时，可以关注能够产生缓存区溢出的函数、循
环赋值逻辑等，但此时需要留意其能够读取与覆盖的范围的大小，看
是否超过申请的值，包括：
常见的栈覆盖危险函数形式有gets(buff)、scanf("%s"，buff）等；
---
## Page 410
CTF特训营：技术详解、解题方法与
12.2.2覆盖找缓冲区的具体用途
410/1144
潜在的覆盖函数有read、strcpy、memcpy等。
其他更多函数或者逻辑需要在实际操作中慢慢总结
---
## Page 411
CTF特训营：技术详解、解题方法与
12.3找的特殊利用
411/1144
12.3栈的特殊利用
关于栈的用法，有很多有用的技巧，下面总结几种比较常见的方
式。
1）libc信息泄露。
由图12-1可以知道，main函数的栈底存放的是
_libc_start_main_ret，因此一旦能够使其返回地址泄露，就可以利
用libc.so文件或使用libc_database来计算libc的基址以及system地址
等。
2）多级指针：path指针，多用于格式化字符串。
由于函数栈的下面存放有环境变量、argv等指针，该指针通常可
以用来泄露信息，具体见12.6.1节。另外，这个地址通常用于格式化
字符串的漏洞，具体可结合第14章来理解。
3）环境变量修改：环境变量指针参数会压在栈上，修改可以达
到特定目的。
在进入程序主逻辑之前，环境变量已经压入了栈底，而这些环境
---
## Page 412
CTF特训营：技术详解、解题方法与
12.3找的特殊利用
412/1144
变量可能会影响程序的行为，如LD_PRELOAD
LIBC_FATAL_STDERR_等。
4）通过libc泄露栈地址。
栈地址通常都比较关键，很多时候都需要泄露出该地址，如果出
现知道libc地址但不知道栈地址的情况，可以根据libc中的Environ偏
移来计算栈的偏移。
5）往栈上写rop的小技巧。