让我们考虑最简单的情况，假设我们的ELF可执行文件只有一个代码段“IexI“，它
的虚拟地址为0x08048000，它在文件中的大小为0x000e1，对齐为0x1000。由于虚拟存储
的页映射都是以页为单位的，在32位的IntelIA32下一般为4096字节，所以32位ELF
的对齐粒度为0x1000。由于该text段大小不到一个页，考虑到对齐该段占用一个段。所
以一-且该可执行文件被装载，可执行文件与执行该可执行文件进程的虚拟空间的映射关系
如图6-5所示。
Operating
System
1 GB
0xC0000000
Process
User
3 GB
0x08049000
tex
0x08048000
1gxt
ELF Hate
Executable
0x00000000
Process Virtual
Space
图6-5可执行文件与进程虚拟空间
很明显，这种映射关系只是保存在操作系统内部的一个数据结构。Linux中将进程虚拟
程序员的自我修养——链接、装载与库
---
## Page 182
6.3从操作系统角度看可执行文件的装载
159
空间中的一个段叫微虚拟内存区域（VMA,Virtual Memory Area）：在Windows 中将这个叫
做虚拟段（VirtualSection），其实它们都是同一个概念。比如上例中，操作系统创建进程后，
会在进程相应的数据结构中设置有一个.text段的VMA：它在虚拟空间中的地址为
0x08048000~0x08049000，它对应ELF文件中偏移为0的.texl，它的属性为只读（一般代码
段都是只读的），还有一些其他的属性。
VMA是一个很重要的概念，它对于我们理解程序的装载执行和操作系统如何管理进程
的虚拟空间有非常重要的帮助。
上面的例子中，我们描述的是最简单的只有一个段的可执行文件映射的情况。操作系统
在内部保存这种结构，很明显是因为当程序执行发生段错误时，它可以通过查找这样的一个
数据结构来定位错误页在可执行文件中的位置，此内容后面会详细介绍。
将CPU指令寄存器设置成可执行文件入口，启动运行。第三步其实也是最简单的一部，
操作系统通过设置CPU的指令寄存器将控制权转交给进程，由此进程开始执行。这一步看
似简单，实际上在操作系统层面上比较复杂，它涉及内核堆栈和用户堆栈的切换、CPU运
行权限的切换。不过从进程的角度看这一步可以简单地认为操作系统执行了一条跳转指令，
直接跳转到可执行文件的入口地址，还记得ELF文件头中保存有入口地址吗？没错，就是
这个地址。
6.3.2页错误
上面的步骤执行完以后，其实可执行文件的真正指令和数据都没有被装入到内存中，操
作系统只是通过可执行文件头部的信息建立起可执行文件和进程虚存之间的映射关系面已。
假设在上面的例子中，程序的入口地址为0x08048000，即别好是.text段的起始地址。当CPU
开始打算执行这个地址的指令时，发现页面0x08048000~0x08049000是个空页面，于是它
就认为这是一个页错误（PageFault）.CPU将控制权交给操作系统，操作系统有专门的页
错误处理例程来处理这种情况。这时候我们前面提到的装载过程的第二步建立的数据结构起
到了很关键的作用，操作系统将查询这个数据结构，然后找到空页面所在的VMA，计算出
相应的页面在可执行文件中的偏移，然后在物理内存中分配一个物理页面，将进程中该虚拟
页与分配的物理页之间建立映射关系，然后把控制权再还回给进程，进程从刚才页错误的位
置重新开始执行。
随着进程的执行，页错误也会不断地产生，操作系统也会为进程分配相应的物理页面来
满足进程执行的需求，如图6-6所示。当然有可能进程所需要的内存会超过可用的内存数量，
特别是在有多个进程同时执行的时候，这时候操作系统就需要精心组织和分配物理内存，甚
程序员的自我修养一链接、装载与库
---
## Page 183
160
第6章可执行文件的装载与进程
至有时候应将分配给进程的物理内存暂时收回等，这就涉及了操作系统的虚拟存储管理。这
里不再展开，有兴趣的读者可以参考相应的操作系统方面的资料。
Bugeuado
System
1 G8
OxC0000000
User
Process
0x08049000
Jert
Page
0x08048000
ELF 
Executable
0x00000000
Process Virtual
Space
Physical Menory
图6-6页错误
6.4
进程虚存空间分布
6.4.1
ELF文件链接视图和执行视图
前面例子的可执行文件中只有一个代码段，所以它被操作系统装载至进程地址空间之
后，相对应的只有一个VMA。不过实际情况会比这复杂得多，在一个正常的进程中，可执
行文件中包含的往往不止代码段，还有数据段、BSS等，所以映射到进程虚拟空间的往往不
止一个段。
当段的数量增多时，就会产生空间浪费的问题。因为我们知道，ELF文件被映射时，是
以系统的页长度作为单位的，那么每个段在映射时的长度应该都是系统页长度的整数倍：如
果不是，那么多余部分也将占用一个页。一个ELF文件中往往有十几个段，那么内存空间
的浪费是可想而知的。有没有办法尽量减少这种内存浪费呢？
当我们站在操作系统装裁可执行文件的角度看问题时，可以发现它实际上并不关心可执
行文件各个段所包含的实际内容，操作系统只关心一些跟装载相关的问题，最主要的是段的
权限（可读、可写、可执行）。ELF文件中，段的权限往往只有为数不多的几种组合，基本
程序员的自我修养一链接、装载与库
---
## Page 184
6.4进程虚存空间分布
161
上是三种：
·以代码段为代表的权限为可读可执行的段。
·以数据段和BSS段为代表的权限为可读可写的段。
以只读数据段为代表的权限为只读的段。
那么我们可以找到一个很简单的方案就是：对于相同权限的段，把它们合并到一起当作
代码和初始化代码，并且它们的权限相同，都是可读并且可执行的。假设.ext为4097字
节，init为512字节，这两个段分别映射的话就要占用三个页面，但是，如果将它们合并成
一起映射的话只须占用两个页面，如图6-7所示。
init page
text page
512
page
.text page
40974
tet
4-
4097
page
ELF Header
Process Virtual Space
Executable
Process Virtual Space
(No Segment)
(Segment)
图 6-7ELF Segment
一起看作是一个“Segment”，那么装载的时候就可以将它们看作一个整体一起映射，也就是
说映射以后在进程虚存空间中只有一个相对应的VMA，而不是两个，这样做的好处是可以
很明显地减少页面内部碎片，从而节省了内存空间。
我们很难将“Segment”和“Section”这两个词从中文的翻译上加以区分，因为很多
时候Section也被翻译成“段”，图顾第2章，我们也没有很严格区分这两个英文词汇
和两个中文词汇“段”和“节”之间的相互翻泽。很明显，从链接的角度看，ELF文
件是接“Section”存储的，事实也的确如此：从装载的角度看，ELF文件又可以按雁
“Segment”划分。我们在这里就对“Segment”不作翻译，一律按照原词。
“Segment”的概念实际上是从装载的角度重新划分了ELF的各个段。在将目标文件链
接成可执行文件的时候，链接器会尽最把相同权限属性的段分配在同一空间，比如可读可执
程序员的自我修养一链接、装载与库
---
## Page 185
162
第6章可执行文件的装载与进程
行的段都放在一起，这种段的典型是代码段：可读可写的段都放在一起，这种段的典型是数
据段。在ELF 中把这些属性相似的、又连在一起的段叫做一个“Segmem”，而系统正是按
照“Segment”而不是“Section”来映射可执行文件的。
下面的例子是一个很小的程序，程序本身是不停地循环执行“sleep”操作，除非用户发
信号给它，否则就一直运行。它的源代码如下：
#include 
int main()
while (1){
sleep(1000) ;
return 0;
我们使用静态连接的方式将其编译连接成可执行文件，然后得到的可执行文件
“SectionMapping.elr”是一个Linux下很典型的可执行文件：
Sgcc -static SectionMapping.c -o SectionMapping.elf
使用readelf可以看到，这个可执行文件中总共有33个段（Section）：
Sreadelf -S SectionMapping.elf
There are 33 section headers, starting at offeet 0x74594:
Section Headers:
[Nr] Name
Type
Addr
off
Size
ES Flg Lk Inf A1
[0]
NULL
080480d40000d400002000
00000000000000000000 00
NOTE
A
0
0
0
0
[ 2]
[1]
.note.ABI-tag
PROGBITS
080480f4
0000f4 000017
00
AX
4
.1ni t
08048110 000110 055948 00
AX
0 16
4
[E]
.text
PROGBITS
AX
0
[  4]
_1ibc_freeres_fn
PROGBITS
0809da60
055a60
q8e000
00
0 16
[ 5]
.fini
PROGBITS
0809e4ec
0564ec
310000
056520
0169e8 00
00
AX
0
2E 0
4
[6]
.rodata
_1ibc_subfreeres
PROGBITS
PROGBITS
0809e520
080b4f08
06cf08
00002c 00
A
[7]
A
080b4f34
06cf34 000004 00
0
_libc_atexit
PROGBITS
A
0
4
[8]
[9]
.eh_frame
PROGBITS
080b4f38
06cf38
003a0e 00
080b8944
070944
0000a1