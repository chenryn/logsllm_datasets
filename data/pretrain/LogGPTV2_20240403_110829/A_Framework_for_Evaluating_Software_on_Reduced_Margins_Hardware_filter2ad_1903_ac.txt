circuits start to exhibit massive errors.
B. Error Resiliency of Source Code and Algorithm Transfor-
mations
In this case study, we demonstrate how XM2 is used to
identify source code transformations with a large effect on
application resiliency. We focus on transformation which affect
branch prediction mechanisms and the cache hierarchy.
To evaluate the vulnerability of the branch prediction mech-
anism we employ two simple kernels. The Sorted kernel
traverses an array that contains sorted values and compares
each value with the mean of the array. Depending on the
outcome of each comparison a variable is increased or de-
creased. The branch predictor is able to predict correctly the
behavior of the branches in the Sorted version. The second
kernel, called Random, traverses the same array, however,
as the name implies, the values are stored randomly within
the array resulting to a very high misprediction rate (and
subsequent pipeline ﬂushes).
Figure 7 shows that the Random microkernel has higher
percentages of SDCs across all frequencies. The two ker-
nels have similar behavior only for extreme overclocking
335
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 10:25:41 UTC from IEEE Xplore.  Restrictions apply. 
100%
80%
60%
40%
20%
0%
)
%
(
s
t
n
e
m
i
r
e
p
x
e
f
o
n
o
i
t
a
c
i
f
i
s
s
a
l
C
R
o
w
C
o
l
S
t
r
i
d
e
L
2
S
t
r
i
d
e
R
o
w
C
o
l
S
t
r
i
d
e
R
o
w
C
o
l
S
t
r
i
d
e
L
2
S
t
r
i
d
e
L
2
S
t
r
i
d
e
Read
Write
Copy
100%
80%
60%
40%
20%
0%
)
%
(
s
t
n
e
m
i
r
e
p
x
e
f
o
n
o
i
t
a
c
i
f
i
s
s
a
l
C
R
o
w
C
o
l
S
t
r
i
d
e
L
2
S
t
r
i
d
e
R
o
w
C
o
l
S
t
r
i
d
e
R
o
w
C
o
l
S
t
r
i
d
e
L
2
S
t
r
i
d
e
L
2
S
t
r
i
d
e
Read
Write
Copy
Fig. 8. Experimental results of the Cache microkernels of Table III for unRel = (1.2V, 1430M Hz), when the hardware prefetcher is enabled (left) and
disabled (right). The Y axis presents the classiﬁcation of the experiments according to the effects of overclocked execution.
Exact
SDC Data Abort
Illegal Instruction CPU Crash
fh = 1450M Hz, leading to an increased percentage of Illegal
instructions. We believe that this is due to the high branch
misprediction rate which set the Program Counter to memory
addresses without valid code or to a memory wrong segment.
For the cache we create kernels which perform read, write
or memcopy using different memory access patterns (Table III).
Figure 8 presents results of the cache evaluation. Note that
the write operation shows a higher degree of robustness in
comparison with the rest of the operations. As the CPU
automatically enables the read allocate mode during the exe-
cution of write microkernels, the cache is barely utilized. The
read operations are slightly more robust than the memcopy
operations. Actually, the memcopy operations usually result
in CPU Crash, whereas the read operations result in Illegal
instructions. When comparing the different access patterns,
the more complex the pattern,
the higher the number of
experiments which terminate abnormally. In the case of the
L2 Stride, all experiments result in CPU Crash.
We observe that the Strided patterns have high CPU Crash
probabilities. We assume that
the prefetcher may have a
negative impact on reliability. To validate our assumption we
programmatically disable the prefetcher and recompile the
DIFFERENT MEMORY ACCESS PATTERNS USED BY THE SOURCE CODE
TRANSFORMATION CASE STUDY.
TABLE III
Row
Col
Stride
L2Stride
This pattern accesses bytes in the same order as they are
stored in main memory. This is the optimal way to access the
memory resulting in lowest L1,L2 cache and TLB miss rate.
This pattern accesses the ﬁrst byte of each memory page,
leading to the worst performance of the memory access. Each
memory access causes a L1 and L2 cache miss.
This pattern iterates through the 2D array using a stride equal
to the cache line (64 bytes). We disable the hardware
prefetcher, so that every memory access leads to a L1 and L2
cache miss. The prefetcher would have been able to detect
this strided pattern.
This pattern is similar to Stride. We disable the hardware
prefetcher, so that every memory access leads to a L1 and an
L2 cache hit. Similarly to Stride, the prefetcher would be
have been able to detect this strided memory access pattern.
336
cache microkernels. Executing these binaries is trivial since the
expConf ﬁles are the same and only the attribute describing the
binary paths should change. The results of the fault injection
campaign without the prefetcher are presented on the right
side of Figure 8. In general, deactivating the prefetecher
increases slightly the application resiliency, however in the
strided patterns the results remain the same.
C. System voltage Margins characterization
This case study uses XM2 to identify the voltage margins
of four x86-64 systems that feature the Skylake Xeon E3
v5 1220 processor and run Linux Ubuntu OS 16.04LTS. We
evaluate and study eight applications (from the PARSEC and
SPLASH benchmark suites) and taking full advantage of the
customization capabilities of our framework, we provide the
appropriate custom classiﬁers via the expConf ﬁle. Our goal is
to identify the maximum voltage reduction for each application
without compromising the correctness of the application.
We employ a python script which sets the unRel value
of the expConf ﬁle and searches for the maximum undervolt
degree. For each expConf we set the maximum number of
experiments to be equal to 10. Using a custom termination
criteria we terminate the campaign if an experiment does not
produce exact output. In such a case the search algorithm
moves to lower undervolting values, otherwise it continues
to higher undervolting values.
When the execution campaign concludes, we compute the
cumulative distribution function (CDF) of the average fault
probability for each target system. The results are presented
in Figure 9. They show that the four CPUs exhibit a different
behavior when it comes to exploiting voltage margins. Note
that a more gradual CDF indicates a broader range of margin
opportunities depending on the workload characteristics.
VII. RELATED WORK
In CLKSCREW[12],
the voltage and frequency scaling
capabilities of modern processors are exploited in order to
compromise system security, by injecting faults during code
execution and extracting cryptographic keys from the ARM
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 10:25:41 UTC from IEEE Xplore.  Restrictions apply. 
100%
)
%
(
y
t
i
l
i
b
a
p
o
r
p
e
r
u
l
i
a
F
80%
60%
40%
20%
0%
200
210
Skylake PC1
220
230
240
Undervolt level (mV)
Skylake PC3
Skylake PC2
250
260
270
Skylake PC4
Fig. 9. Voltage margins of the four Skylake CPUs. The X axis represents
the amount of undervolting with respect to nominal Vdd. The Y axis is the
average fault probability CDF for each CPU with respect to undervolting.
injection technique at
TrustZone. This work focuses on the security risks raised
by modern energy management techniques. RIFLE [13] and
MESSALINE [14] introduce a deterministic and reproducible
fault
the pin-level of a processor.
FIAT [15] and FERRARI [16] implement a software-level fault
injection which models complex systems with great accuracy
however, ensuring that the simulated models are realistic and
restraining simulation time are signiﬁcant challenges. VER-
IFY [17], MEFISTO [18] and GemFI [19] are fault injection
simulators that provide high accuracy in both the location and
the timing of the fault, but they introduce signiﬁcant overhead.
Finally, REFINE [20] allows fault injection in the back-end of
the LLVM compiler. In contrast to these works, XM2 performs
fault injection natively on the targeted system, therefore it
provides native execution time and does not rely on any fault
models as they manifest due to real hardware errors.
VIII. CONCLUSIONS
This paper introduces XM2, a software framework which
facilitates the experimental evaluation of the effects of volt-
age/frequency margins on the operation of CPU platforms.
XM2 can be used to study the behavior of software running
on platforms operating – potentially unreliably – outside their
nominal operational envelope. The results obtained by our tool
are accurate and allow evaluation with realistic workloads and
working sets. Our framework enables the setup, automatic
execution and statistical processing of the results of large
experimental campaigns, with minimal conﬁguration effort,
limited modiﬁcations to applications (on average 5.6% extra
LOCs) and limited overhead (on average 2.5%) compared
to native, reliable executions. For example, using XM2, we
studied the effects of extended margins on two widely different
ISAs. We showed that on an x86-64 Skylake CPU the voltage
margins are equal to 220mV, whereas on the ARM cortex A53
the frequency margins are equal to 200M hz.
ACKNOWLEDGMENT
This research has been funded from the European Commu-
nity Horizon 2020 programme under grant no. 688540.
REFERENCES
[1] G. Papadimitriou, M. Kaliorakis, A. Chatzidimitriou, D. Gizopoulos,
P. Lawthers, and S. Das, “Harnessing voltage margins for energy
efﬁciency in multicore CPUs,” in Proc. of the Annual IEEE/ACM Int.
Symposium on Microarchitecture, MICRO 2017, 2017.
[2] S. Achour and M. C. Rinard, “Approximate computation with outlier
detection in topaz,” in Proc. of the 2015 International Conference on
Object-Oriented Programming, Systems, Languages, and Applications.
New York, NY, USA: ACM, 2015.
[3] D. Blaauw, S. Kalaiselvan, K. Lai, W. Ma, S. Pant, C. Tokunaga, S. Das,
and D. M. Bull, “Razor II: in situ error detection and correction for PVT
and SER tolerance,” in IEEE Int. Solid-State Circuits Conference, ISSCC
, Digest of Technical Papers, 2008.
[4] K. Parasyris, V. Vassiliadis, C. D. Antonopoulos, S. Lalis, and N. Bellas,
“Signiﬁcance-Aware Program Execution on Unreliable Hardware,” ACM
Trans. Archit. Code Optim., 2017.
[5] S. Das, D. Roberts, S. Lee, S. Pant, D. Blaauw, T. Austin, K. Flautner,
and T. Mudge, “A self-tuning dvs processor using delay-error detection
and correction,” Solid-State Circuits, IEEE Journal of, vol. 41, no. 4,
2006.
[6] A. Bacha and R. Teodorescu, “Using ECC Feedback to Guide Volt-
age Speculation in Low-Voltage Processors,” in 2014 47th Annual
IEEE/ACM International Symposium on Microarchitecture, 2014.
[7] J. Leng, A. Buyuktosunoglu, R. Bertran, P. Bose, and V. J. Reddi, “Safe
limits on Voltage Reduction Efﬁciency in GPUs: A Direct Measurement
Approach,” in 2015 48th Annual International Symposium on Microar-
chitecture (MICRO), 2015.
[8] G. Papadimitriou, M. Kaliorakis, A. Chatzidimitriou, C. Magdalinos, and
D. Gizopoulos, “Voltage Margins Identiﬁcation on Commercial x86-64
Multicore Microprocessors,” in 2017 IEEE 23rd Int, Symposium on On-
Line Testing and Robust System Design (IOLTS), 2017.
[9] D. Gizopoulos, M. Psarakis, S. V. Adve, P. Ramachandran, S. K. S.
Hari, D. J. Sorin, A. Meixner, A. Biswas, and X. Vera, “Architectures for
online error detection and recovery in multicore processors,” in Design,
Automation and Test in Europe, DATE 2011, 2011.
[10] E. A. Burton, G. Schrom, F. Paillet, J. Douglas, W. J. Lambert, K. Rad-
hakrishnan, and M. J. Hill, “FIVR—Fully Integrated Voltage Regulators
on 4th Generation Intel R(cid:3) Core TM SoCs,” in Applied Power Electronics
Conference and Exposition (APEC), 2014 Twenty-Ninth Annual IEEE.
IEEE, 2014, pp. 432–439.
[11] C. Bienia, S. Kumar, J. P. Singh, and K. Li, “The parsec benchmark suite:
Characterization and architectural implications,” in Proc. of the 17th Int.
Conference on Parallel Architectures and Compilation Techniques, 2008.
[12] A. Tang, S. Sethumadhavan, and S. Stolfo, “CLKSCREW: Exposing
the perils of security-oblivious energy management,” in 26th USENIX
Security Symposium (USENIX Security 17), 2017.
[13] H. Madeira, M. Rela, F. Moreira, and J. G. Silva, “RIFLE: A general
purpose pin-level fault injector,” in Proc. of the European Dependable
Computing Conference (EDCC), 1994.
[14] J. Arlat, M. Aguera, L. Amat, Y. Crouzet, J.-C. Fabre, J.-C. Laprie,
E. Martins, and D. Powell, “Fault Injection for Dependability Validation:
A Methodology and Some Applications,” IEEE Trans. on Software
Engineering, 1990.
[15] J. H. Barton, E. W. Czeck, Z. Z. Segall, and D. P. Siewiorek, “Fault
Injection Experiments Using FIAT,” IEEE Trans. on Computers, 1990.
[16] G. A. Kanawati, N. A. Kanawati, and J. A. Abraham, “Ferrari: A ﬂexible
software-based fault and error injection system,” IEEE Trans. Comput.,
vol. 44, 1995.
[17] V. Sieh, O. Tschche, and F. Balbach, “VERIFY: Evaluation of Reliability
Using VHDL-Models with Embedded Fault Descriptions,” in Proc. of
the Symposium on Fault-Tolerant Computing (FTCS), 1997.
[18] E. Jenn, J. Arlat, M. Rimn, J. Ohlsson, and J. Karlsson, “Fault Injection
into VHDL Models: The MEFISTO Tool,” in Proc. of the Symposium
on Fault-Tolerant Computing (FTCS), 1994.
[19] K. Parasyris, G. Tziantzoulis, C. Antonopoulos, and N. Bellas, “Gemﬁ:
A fault
injection tool for studying the behavior of applications on
unreliable substrates,” in Dependable Systems and Networks (DSN),
2014 44th Annual IEEE/IFIP Int. Conference on, 2014.
[20] G. Georgakoudis, I. Laguna, D. S. Nikolopoulos, and M. Schulz,
“Reﬁne: Realistic fault injection via compiler-based instrumentation for
accuracy, portability and speed,” in Proc. of the Int. Conference for High
Performance Computing, Networking, Storage and Analysis, 2017.
337
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 10:25:41 UTC from IEEE Xplore.  Restrictions apply.