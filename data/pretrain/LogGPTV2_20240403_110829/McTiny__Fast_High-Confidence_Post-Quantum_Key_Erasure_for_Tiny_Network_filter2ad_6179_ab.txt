Server (blue values shared accross connections)
(sk, pk) ←$ KGen
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Phase 0 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
(k,K) ←$ KGen
( ¯c, ¯C,S) ← ENC(pk)
R ←${0,1}176
AE(0 : R,0,0 : S)
hash(pk), ( ¯c, ¯C), (R,0,0)
S ← DEC( ¯c, ¯C, sk)
N ←${0,1}176
E ←$ SeedGen
sm ← current cookie key
C0 ← (AE(S,E : N,1,0 : hash(sm)),m mod 8)
AE(C0 : N,1,0 : S)
(N,1,0)
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Phase 1
Run for all i = 1 . . .r, j = 1 . . . (cid:96) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
AE(Ki, j : N,2(i− 1),64 + j− 1 : S)
C0, (N,2(i− 1),64 + j− 1)
AE(C0,Ci, j : M,2i− 1,64 + j− 1 : S)
(M,2i− 1,64 + j− 1)
handle C0,M,sm . . .
Recover S,E from C0
sm ← current cookie key
C0 ← (AE(S,E : N,1,0 : hash(sm)),m mod 8)
s ← hash(sm,S)
M ←${0,1}176
ci, j ← Ki, je j
Ci, j ← (AE(ci, j : N,2i− 1,64 + j− 1 : s),m mod 8)
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Phase 2
Run for all i = 1,2, . . . ,(cid:100)r/v(cid:101) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
AE(Civ−v+1,1, . . . ,Civ,(cid:96) : N,2(i− 1),64 + 32 : S)
C0, (N,2(i− 1),64 + 32)
AE(C0,civ−v+1, . . . ,civ : M,2i− 1,64 + 32 : S)
(M,2i− 1,64 + 32)
handle C0,M,sm . . .
c j ← e j,0 + c j,1 +··· + c j,(cid:96)
for j = iv− v + 1, . . . ,iv
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Phase 3 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
AE((c1,c2, . . . ,cr) : N,254,255 : S)
C0, (N,254,255)
AE(CZ, (c1,c2, . . . ,cr),C : M,255,255 : S)
(M,255,255)
handle C0,M,sm . . .
C ← hash(2,e)
Z ← hash(1,e, (c1,c2, . . . ,cr),C)
CZ ← (AE(Z : M,255,255 : hash(sm)),m mod 8)
Z ← DEC((c1,c2, . . . ,cr),C,k)
Figure 1: The McTiny Protocol. All AE ciphertexts are decrypted and validated. The offsets are chosen for (cid:96) ≤ 32.
1738    29th USENIX Security Symposium
USENIX Association
phase
0
1
2
3
query
reply
query
reply
query
reply
query
reply
queries
replies
bytes/packet
810
121
1226
140
1185
133
315
315
packets
1
1
952
952
17
17
1
1
971
971
bytes
810
121
1 167 152
133 280
20 145
2 261
315
315
1 188 422
135 977
Table 1: Packet sizes in each phase of mctiny6960119,
counting only application-layer data and not counting
UDP/IP/Ethernet overhead. A public key is 1 047 319 bytes.
Classic McEliece KEM. The client sends the KEM ciphertext,
a hash of the server’s public key, and AE(0 : R,0,0 : S). The
plaintext 0 is a 512-byte extension ﬁeld, currently unused.
The server uses sk to decapsulate the KEM ciphertext and
retrieve S. It veriﬁes and decrypts AE(0 : R,0,0 : S). It then
picks a random seed E of 32 bytes, computes C0 = (AE(S,E :
N,1,0 : hash(sm)),b), using the current cookie key sm and
b = m mod 8. The seed E determines the low-weight vector
e through a deterministic function, see [6] for details. The
server then picks a 22-byte nonce N, and computes and sends
AE(C0 : N,1,0 : S), (N,1,0) to the client. At this point the
server forgets all data related to this client.
The client veriﬁes the authenticity and stores (C0,N).
For mctiny6960119, S and E have 32 bytes, nonces have
24 bytes, and AE(T : N : S) has the same length as T plus a 16-
byte authentication tag. In total, C0 has 32 +32 +16 +1 = 81
bytes and the message to the client has 40 bytes more for the
nonce N,1,0 and the authenticator under S.
6.5 Phase 1: Partial Public-Key Encryption
Phase 1 sends the matrix pieces Ki, j to the server which then
computes the partial matrix-vector products as described in
Section 5. Here we detail the cryptographic protections for
this computation.
For every partial matrix Ki, j the client sends AE(Ki, j :
N,2(i− 1),64 + j− 1 : S),C0, (N,2(i− 1),64 + j− 1) to the
server, where 1 ≤ i ≤ r is the row position and 1 ≤ j ≤ (cid:96) is the
column position. The offset 64 works for (cid:96) ≤ 32. This nonce
is deterministic within one run and will repeat, but only to
resend the same message. The related nonces save bandwidth.
If the server obtained this message before the expiry of
cookie key decrypting C0, the server obtains (S,E) and uses
S and N to verify and decrypt the payload to obtain Ki, j.
The server recovers e from E and computes the partial
matrix-vector multiplication ci, j = Ki, je j. The position of
this matrix is computed from the nonce. The server then re-
computes C0 = (AE(S,E : N,1,0 : hash(sm)),b), using the
current cookie key sm and the same nonce N,1,0 as be-
fore. Finally, it computes a client-speciﬁc cookie key s =
hash(sm,S) and the cookie matching the partial encryption
Ci, j = (AE(ci, j : N,2i− 1,64 + j− 1 : s),b). It picks a fresh
22-byte random nonce M, sends AE(C0,Ci, j : M,2i− 1,64 +
j− 1 : S), (M,2i− 1,64 + j− 1) to the client, and forgets all
data related to the client.
The client veriﬁes, decrypts, updates C0, and stores Ci, j
for future use. If partial encryptions are missing, the client
re-requests by sending the same packet with the latest C0.
For mctiny6960119 the public key is split into 119× 8
blocks so that 119· 8 = 952 packets need to be sent. Each
packet from client to server has 1226 bytes and each reply
from the server has 140 bytes (81 in C0, 2 + 16 + 1 in the Ci j,
16 in the authenticator, and 24 in the nonce).
6.6 Phase 2: Row-wise Combination
This phase combines the partial encryptions row-wise. The
protocol speciﬁes a split of the r × (cid:96) blocks from phase
1 into batches of w blocks. Once the client has obtained
all blocks in one batch—this may be part of a row as
Ci,wJ+1,Ci,wJ+2, . . . ,Ci,wJ+w or cover one or several rows as
Civ−v+1,1,Civ−v+1,2, . . . ,Civ−v+1,(cid:96), . . . ,Civ,1,Civ,2, . . . ,Civ,(cid:96) for
v = w/(cid:96)—it sends them for partial combination. For simplic-
ity and because it matches the sizes of mctiny6960119 we
describe the case where several complete rows of blocks can
be handled in one step. For rows iv−v+1 through iv the client
sends AE(Civ−v+1,1,Civ−v+1,2, . . . ,Civ,(cid:96) : N,2(i− 1),64 + 32 :
S),C0, (N,2(i− 1),64 + 32). The nonce is separated from the
other nonces as (cid:96) ≤ 32.
The server checks the authenticator and, for each j
from iv − v + 1 through iv, decrypts Cj,1, . . . ,Cj,(cid:96) to ob-
tain the pieces c j,1, . . . ,c j,(cid:96) of c j. As described in Sec-
tion 5, the server computes c j = e j,0 + c j,1 + c j,2 + ··· +
c j,(cid:96), with e j,0 the matching y positions of e. Finally it
sends AE(C0,civ−v+1,civ−v+2, . . . ,civ : M,2i − 1,64 + 32 :
S), (M,2i− 1,64 + 32).
The client veriﬁes, decrypts, updates C0, and stores
civ−v+1,civ−v+2, . . . ,civ for future use. As before, missing
pieces are re-requested.
In mctiny6960119 v = 7 rows of blocks (i.e., 91 rows from
the original matrix) are handled together. Thus, nonces from
the client to the server have N0 ∈ {0,2,4, . . . ,32}. Messages
from client to server have 1185 bytes, messages from server
to client have 133 bytes.
6.7 Phase 3: Decapsulation
Eventually all ci,1 ≤ i ≤ r, are known to the client. To match
the Classic McEliece key derivation, McTiny has the client
send c to the server. The server computes the plaintext conﬁr-
mation C = hash(2,e), shared secret Z = hash(1,e,c,C) and
shared-key cookie CZ = AE(Z : M,255,255 : hash(sm)) for a
USENIX Association
29th USENIX Security Symposium    1739
fresh nonce M. The server sends (AE(CZ,c,C : M,255,255 :
S), (M,255,255)) to the client which then computes Z =
DEC(c,C,k) and stores Z and cookie (CZ,M) for future use.
The client erases all other data including S and (k,K).
In mctiny6960119 client and server each send 315 bytes
in this phase. In total, 971 packets are sent by the client to
the server, each prompting a reply ﬁtting into one packet and
never amplifying the size.
The McTiny key exchange ends at this point, and the client
communicates securely with the server using session key Z.
Details of a session protocol are outside the scope of this
paper, but the main point is that the client can include (CZ,M)
in subsequent packets so that the server can reconstruct Z.
Any packet back includes an updated cookie (CZ,M) using
a fresh nonce; the session protocol can update Z here for
prompt key erasure within a session. When the session ends
(explicitly or by a timeout), the client erases all data.
7 Key Erasure
Key erasure should prevent an attacker learning secrets from
past connections if he steals the server or client or both.
7.1 Key Erasure On the Server Side
An attacker who steals a server obtains the server’s long-term
secret key sk. If the attacker keeps the server online it can
decrypt all future trafﬁc to the server, and can pose as the
server. The question is whether the attacker can also decrypt
past trafﬁc. Trafﬁc is encrypted under the key Z exchanged by
the McTiny protocol, so the question is whether the attacker
learns Z for past connections.
The secret key sk allows the attacker to decapsulate all
KEM messages ever sent to the server (phase 0) and obtain
all shared keys S. These decrypt all messages sent between
client and server in subsequent phases under the respective
S. In particular, the attacker sees a McEliece ciphertext (c,C)
sent by the server to the client. However, unless there is a se-
curity problem with the McEliece system, the attacker cannot
determine Z from this ciphertext.
By stealing the server, the attacker also learns the server’s
recent cookie keys sm, . . . ,sm−z+1. In mctiny6960119 the
attacker obtains the cookie keys used for the last 8 minutes.
The cookie keys allow the attacker to decrypt cookies under
the last z keys from the server to itself; in particular, the
attacker can obtain Z for any recent connection by decrypting
the cookie CZ. However, the attacker cannot decrypt older
cookies. Cookies are often repeated across packets, but this
linking of packets is already clear from simple trafﬁc analysis.
Here is what the attacker sees for an older McTiny con-
nection, a connection that completed more than z intervals
before the theft: the client’s short-term McEliece public key
K (in blocks Ki, j); a random ciphertext (c,C) sent to this key,
communicating a secret key Z to the client; and the cookies
C0 and Ci, j for 1 ≤ j ≤ (cid:96),1 ≤ i ≤ r.
The shared secret Z could be computed from E included in
C0, but the keys to all the C0 cookies are erased.
Each ci j includes information on e as a much simpler de-
coding problem, but the ci j are encrypted in the Ci j under
erased cookie keys.
7.2 Keep Alive
An attacker planning to steal a server in the future has an
interest in keeping a connection alive by replaying messages
from the client. The client messages include C0 or CZ in plain
and a replay will prompt the server to reply as long as these
outer cookies can be decrypted. Each reply includes a fresh
C0 or CZ but these cookies are superencrypted under S or Z
which the attacker does not know, yet.
The client is assumed to maintain state, so will no longer
reply (and provide fresh versions of C0 or CZ) after the con-
nection was closed. The attacker loses the ability to cause
replies after the last cookie expired. Thus an active attacker
can extend the lifetime by z− 1 time intervals.
In mctiny6960119 this means that 15 minutes after the
end of a connection even an active attacker cannot recover
any short-term keys by stealing the server.
7.3 Key Erasure On the Client Side
Similarly, an attacker who steals a client obtains the secret
keys that decrypt current connections, but the McTiny client
software does not retain the keys for a connection once the
connection is over. Of course, other parts of the client system
might retain data for longer.
Since the client has state it will not keep a connection open
longer than speciﬁed by its local timeouts. An active attacker
cannot override the client’s timeout policy.
8 Conﬁdentiality and Integrity
In the absence of server theft, there is an extra layer of pro-
tection for conﬁdentiality: all packets from the client are en-
crypted to the server’s long-term McEliece key (phase 0) or
use authenticated encryption. The choice of cryptographic
primitives follows best practices, so we look for weaknesses
introduced by the protocol. We ﬁrst analyze what an external
attacker is faced with and then what a malicious client can do.
8.1 Passive External Attacker
Authenticated encryption guarantees conﬁdentiality and in-
tegrity, but only if different messages never share nonces. If
AE is AES-GCM, and an attacker sees AE(T1 : N : S) and
AE(T2 : N : S) for T1 (cid:54)= T2, then the attacker can also pro-
duce authenticators for arbitrary ciphertexts under (N(cid:48) : S) for
1740    29th USENIX Security Symposium
USENIX Association
any N(cid:48). Our choice of XSalsa20-Poly1305 for AE limits the
impact, but the attacker can still produce authenticators for
arbitrary ciphertexts under (N : S). Either way, we need to
analyze the potential for nonce reuse.
All packets from the server to the client use authenticated
encryption with a fresh nonce under shared key S. The random
part of the nonce has 22 bytes (176 bits) and thus the choice
will not repeat while S is in use. Additionally, the domains for
the nonces are separated by step and direction using the last
two bytes. If a step is repeated due to packet loss, the server
will make a fresh choice of M. Hence, the attacker will not
observe nonce reuse for different plaintexts.
The subsequent messages from the client to the server
are encrypted and authenticated using S and a nonce which
depends on the ﬁrst random nonce N chosen by the server.
Again the last two bytes provide domain separation. This
makes the choice of nonce deterministic for each encryption
and the same nonce and key are used when retransmitting in
the same phase, but only to encrypt the same plaintext.
The
attacker also sees C0 = (AE(S,E : N,1,0 :
hash(sm)),m mod 8) using several cookie keys sm un-
der the same nonce N,1,0. All cookies encrypt the same
message, hence nonce-reuse under the same sm is no problem.
There is no weakness in AE for using the same nonce and
plaintext under different keys.
The connection for a different client served by the same
server uses a different S(cid:48) and N(cid:48). Figure 1 highlights values
shared across clients in blue. Messages with the same key
either have different nonces or are identical.
8.2 Active External Attacker
The Classic McEliece KEM is secure against active attacks,
hence the shared secret S is not known to the attacker. Authen-
ticated encryption protects the other packets against active
attackers attempting to forge or modify packets. Every cipher-
text is veriﬁed upon receipt.
Clients and external attackers cannot inﬂuence the choice
of nonce and any modiﬁcation of N leads to invalid authenti-
cators and thus to no reply from the server. The client accepts
messages under key S. Replays of server messages will not
cause a reaction from the client as it has state.
Mixing cookies and messages from different clients does
not work. The server accepts cookies under its most recent
cookie keys sm,sm−1, . . . ,sm−z+1 and uses the symmetric key
S provided in C0 to decrypt and check the rest of the message.
The attacker can replay a valid client message and cause
the stateless server to handle it again. If the cookie key has
changed this leads to a different C(cid:48)
0 in the reply. For the outer
encryption a random M (or N in phase 0) is chosen, hence
only the last two bytes of the nonce repeat, the rest of the
nonce differs, meaning no loss in security.
8.3 Malicious client
A malicious client knows S and Z anyway, so its targets are the
cookie keys. The following assumes that the client manages
to send the attack packets in the same cookie interval. Else
more retries are needed.
11. This produces C11 (cid:54)= C(cid:48)
The malicious client can send K11 and K(cid:48)
The encryption of Z uses fresh 22 bytes for the nonce.
The computation of C0 is deterministic depending on veriﬁed
values. Initiating a new connection and thus changing E leads
to a fresh choice of N.
11, likely causing
c11 (cid:54)= c(cid:48)
11 which use the same nonce
and key. The client (as opposed to an external attacker) obtains
these cookies. However, the key s = hash(sm,S) is used only
for this client, limiting the use to forging server cookies for
this one step in its own connection. Furthermore, if K11 and
K(cid:48)
11 differ only in the ﬁrst column, the client learns that the
ﬁrst bit in e is set if C11 (cid:54)= C(cid:48)
11 and else that it is not set.
However, the target of the McTiny protocol is for the server
to send e to exactly this client.4
Note that both of these attempts come at the expense of
sending two messages under the same nonce with S, giving
away the authenticator under that key and nonce. This is not
an attack as the client could choose to leak S in its entirety.
9 Security Against Quantum Computers
The McTiny protocol is designed to make the well-studied
McEliece cryptosystem practical for tiny network servers. All
public-key cryptography in the protocol uses this system for
its resistance to attacks using quantum computers.
The McTiny protocol is ﬂexible in the parameter choices for
the code-based part with minimal adjustments on the number
of steps per phase. mctiny6960119 uses very conservative
parameters. This means that even an active attacker with a
quantum computer cannot break the public-key encryption.
All of the keys for symmetric cryptography are 32 bytes,
providing ample protection against Grover’s algorithm and
the choice of XSalsa20-Poly1305 for AE follows recommen-
dations for post-quantum security.
10
Implementation and Evaluation
section
describes our
implementation
the
This
of
mctiny6960119 protocol, and evaluates whether
the
protocol lives up to its promise to run safely on tiny
network servers. The implementation is now available at
https://mctiny.org.
Interface
10.1
Our software provides four main tools:
4The malicious client learns this bit prematurely, but to learn e it needs
about 6960 steps, much more than a regular run of 971 steps would take.
USENIX Association
29th USENIX Security Symposium    1741
• master creates a new mctiny6960119 server identity:
a long-term public key and a long-term secret key.
• rotate is run every minute to update the pool of 8 server
cookie keys, creating a new cookie key and erasing the
oldest cookie key.
• server handles the server side of the mctiny6960119
protocol: it binds to a speciﬁed UDP port on a speciﬁed
local IP address and handles incoming request packets
from any number of clients.
• client performs one run of the client side of the
mctiny6960119 protocol, communicating to a server
at a speciﬁed address and port, using a speciﬁed server
public key.
The decomposition of server-side tools is meant to easily
support replicated server deployments as follows. The server
administrator runs the master tool on a master device, and
pushes the results to each server through standard tools such
as rsync. Each server runs the server and rotate tools. The
master device needs enough resources to generate and store
the public key, but each server can be much smaller.
The master, rotate, and server tools manage data
in a state directory speciﬁed by the caller. The public
key is stored in a ﬁle state/public/d53... where
d53... is a 256-bit key hash in hex. The secret key is
stored in state/secret/long-term-keys/d53.... The
server tool transparently supports multiple secret keys
for multiple identities on the same host. Cookie keys are
stored
state/secret/temporary-cookie-keys/0
through
state/secret/temporary-cookie-keys/7,
with
state/secret/temporary-cookie-keys/latest
symlinked to the current key.
in
Our API for each of these tools is the standard UNIX com-
mand line, making the tools directly usable from a wide range
of languages. The command line involves some overhead to
spawn a new process, and obviously the same functions could
also be provided through APIs with less overhead, but we have
not found evidence that the command line is a performance
problem here.
Internals
10.2
We reused existing Classic McEliece software [6] for key
generation (in master for long-term keys, and in client for
short-term keys), encryption (in client for long-term keys),
and decryption (in server for long-term keys, and in client
for short-term keys). We also reused existing software for
symmetric encryption (XSalsa20), symmetric authentication
(Poly1305), and hashing (SHAKE256).
We obtained all of this software from the SUPERCOP
cryptographic benchmarking framework. The tests described
below use version 20191017 of SUPERCOP, the latest version
at the time of this writing.
For our new McTiny software components, we selected the
C programming language, with the goal of eliminating unnec-
essary performance overheads. C is, however, notorious for
encouraging devastating bugs, such as memory-safety bugs.
We do not have evidence that a Rust rewrite would make the
software noticeably slower; it could even be faster. We are
also not claiming that achieving any particular performance
level is more important than reducing risks of bugs.5
software
encryption
new cryptographic
for
mctiny6960119’s matrix-partitioning
(in
server), ensuring compatibility of the ﬁnal result with
Classic McEliece. We also wrote new software for the
higher-level aspects of mctiny6960119, such as packet
construction, packet parsing, and the general packet ﬂow.
Overall we wrote about 2500 lines of new code; see Table 2.
The ﬁle mctiny.h is output by a 160-line mctiny.py that
supports variations in McTiny parameters.
wrote
We
10.3 RAM Consumption
Running size on the compiled server binary shows 206586
bytes of code, 792 bytes of initialized data, and 23824 bytes
of bss (further RAM initialized to 0 at program startup). See
Table 2. The code size includes all of the cryptographic soft-
ware that we imported from SUPERCOP, such as the Classic
McEliece software and the SHAKE256 software. Our code
uses only a small amount of stack space, and it avoids all heap
allocation and mmap-based allocation.
We do not claim that the entire program would work in such
a small amount of RAM without modiﬁcation. The problem
is that we also use some OS libraries that were not designed
to be small: we use stdio for ﬁle management and printing
error messages, we call getaddrinfo to determine the local
IPv4 or IPv6 address to use, etc. We found that the server
works with stack size limited to 92KB (ulimit -s 92) but
not with a smaller stack size. Also, monitoring system calls
with strace shows various memory allocations from stan-
dard libraries at program startup.
The rotate program uses 920 bytes of initialized data and
944 bytes of bss. The master program needs more RAM to
create a public key: it uses 752 bytes of initialized data and
1062560 bytes of bss. The client program uses 800 bytes of
initialized data and 1154648 bytes of bss.
10.4 Network Usage
On an unloaded network we saw (as expected—see Table 1)
971 packets from the client to server, plus 971 packets from
the server to the client, for a complete mctiny6960119 key
exchange. The packets from client to server occupied a total
of 1 188 422 bytes of application-layer data (not counting
per-packet bandwidth overhead, which is normally 8 bytes
5We did take some steps to reduce these risks, such as running tests under
Address Sanitizer.
1742    29th USENIX Security Symposium
USENIX Association
text
155
5406
8377
2589
3063
6538
989
5313
1158
0
0
209 526
184 487
22 944
206 586
196 599
0
0
data
0
0
0
0
104
24
0
0
8
0
0
800
752
920
792
656
0
0
bss
0
24
0
0
0
32
0
0
1284
0
0
1 154 648
1 062 560
944
23 824
1 064 952
0
0
c
13
216
530
149
199
546
63
612
111
h
8
72
0
0
0
0
0
24
20
file
hash
mctiny
mctiny-client
mctiny-master
mctiny-rotate
mctiny-server
mctiny-test
pacing
packet
purpose
SHAKE256 wrapper (copied)
library for McTiny computations
connect to a server
create a server key
rotate cookie keys once
serve any number of clients
local keypair/enc/dec test
client-side congestion control
build and parse packets
Table 2: Source and object sizes. The “c” and “h” columns are the number of lines in file.c and file.h. The “text”, “data”, and
“bss” columns are the sizes reported by the standard size tool for the object ﬁle file.o, and for the linked binary file when a
second number is reported. Sizes of binaries listed here include sizes for cryptographic software imported from SUPERCOP
(e.g., the Classic McEliece software), but do not include sizes for standard shared libraries from the OS (e.g., getaddrinfo).
Code is compiled for Intel Haswell using gcc with optimizations -O3 -march=native -mtune=native. Compiler verson is
7.4.0, as shipped with the current long-term-support version of Ubuntu (Ubuntu 18.04).
for UDP, plus 20/40 bytes for IPv4/IPv6, plus 38 bytes for
Ethernet). The packets from server to client occupied a total
of 135 977 bytes of application-layer data. For comparison, a
mceliece6960119 public key by itself is 1 047 319 bytes.
10.5 CPU Usage
Haswell, introduced 2013, is not the newest Intel microarchi-
tecture, but it is one of the most common optimization targets
in recent papers on cryptographic primitives and in the NIST
post-quantum project. SUPERCOP’s latest benchmarks report
the following speeds for mceliece6960119 on one Haswell
core: 0.71· 109 cycles median for keygen (with high variance:
the quartiles are 0.50· 109 and 1.31· 109), 153944 cycles for
enc (much less variance: quartiles 148612 and 169396), and
305880 cycles for dec (quartiles 304616 and 306232).
We collected mctiny6960119 timings on a Haswell, specif-
ically a quad-core 3.1GHz Intel Xeon E3-1220 v3, for compa-
rability to these microbenchmarks. To estimate the total server
time, we ran a series of 1000 key exchanges and observed in
ps that the server process had accumulated 17 seconds of
CPU time, i.e., 17 milliseconds (53 million cycles on one CPU
core) per key exchange. Generic packet processing can incur
signiﬁcant costs that the OS does not attribute to the process,
but this measurement shows that the mctiny6960119 server
computations consumed only about 40 CPU cycles per byte
communicated. (The client computations are more expensive
since the client generates a short-term public key.)
We also instrumented the server with calls to a cycle
counter, printing and resetting the counter whenever the server
computed a session key. These ﬁgures showed that the server
took 44.4 million cycles per key exchange (standard deviation
1.1 million cycles) for all activities outside recvfrom and
sendto. Within the 44.4 million cycles, 20.8 million cycles
(standard deviation 0.4 million cycles) were spent on the core
cryptographic computations in phase 1: regenerating the low-
weight vector from a seed and computing the corresponding
partial encryption.
10.6 Security Against Server CPU Overload
An attacker trying to overload a quad-core 3.1GHz CPU with
10Mbps of network trafﬁc needs to consume 10000 cycles
per byte. (A site paying for a larger Internet connection can,
presumably, afford more than one CPU to handle the load.) In
our server software, the maximum cycles per byte are spent in
McEliece decapsulation for the ﬁrst packet, about 400 cycles
per byte to handle 810 bytes of application-layer data (and
slightly fewer cycles per byte when bandwidth overhead is
taken into account).
Note that adding the encrypted 512-byte extension ﬁeld to
the ﬁrst packet has the side effect of reducing the load per byte.
For comparison, unencrypted zero-padding of query packets
is well known to reduce query ampliﬁcation and other per-
query-byte costs, but this protection could be compromised
by network links that try to compress packets.
10.7 Security Against Memory Flooding
At no time does the server allocate any per-client storage.
Each client packet is handled immediately and then forgotten.
We built the server software to avoid allocating memory in
response to client packets; we audited the source code for
this property; and we checked with strace that, once the
program entered its packet-handling loop, its system calls
consisted entirely of recvfrom, sendto, and an occasional6
key-ﬁle access. In short, this is a tiny network server, making
it immune to server-memory denial of service.
6The server automatically caches each key for 1 second, or 10000 uses,
whichever comes ﬁrst.
USENIX Association
29th USENIX Security Symposium    1743
11 Conclusions and Further Considerations
The previous sections have shown that at very little overhead
in the number of packets and a few extra round trips, the con-
servative McEliece system can be ﬁt into tiny network servers
for forward secrecy without using any per-client memory.
Server operators might be concerned about the generous
usage of randomness on the server side. We point out that
the random nonces can be generated by advancing a stream
cipher. Server operators might also be concerned about the
cost of hashing. We used hash to simplify the description.
Any way of deterministically deriving subkeys from a master
key works and is often cheaper.
The analysis of nonce reuse attacks took up a signiﬁcant
portion of the security analysis. Our choice of XSalsa20-
Poly1305 already limits the potential for damage but designers
could replace AE with a wide-block cipher to further limit
this potential. Such ciphers are currently less common and
we managed to achieve protection without this choice, but the
analysis would be simpler.
We encourage further analysis, including proofs if possible,
of McTiny and variants of McTiny.
Acknowledgments
This work was supported by the U.S. National Science
Foundation under grant 1913167, by the European Commis-
sion under Contract ICT-645622 PQCRYPTO, and CHIST-
ERA USEIT (NWO project 651.002.004), by the Deutsche
Forschungsgemeinschaft (DFG, German Research Founda-
tion) under Germany’s Excellence Strategy – EXC 2092
CASA-390781972, by the Netherlands Organisation for Sci-
entiﬁc Research (NWO) under grant 628.001.028 (FASOR),
and by the Cisco University Research Program.
References
[1] Martin R. Albrecht, Léo Ducas, Gottfried Herold,
Elena Kirshanova, Eamonn W. Postlethwaite, and Marc
Stevens. The general sieve kernel and new records in
lattice reduction. In EUROCRYPT (2), volume 11477
of Lecture Notes in Computer Science, pages 717–746.
Springer, 2019. https://eprint.iacr.org/2019/
089.
[2] Daniel Augot, Lejla Batina, Daniel J. Bernstein, Joppe
Bos, Johannes Buchmann, Wouter Castryck, Orr Dunkel-
man, Tim Güneysu, Shay Gueron, Andreas Hülsing,
Tanja Lange, Mohamed Saied Emam Mohamed, Chris-
tian Rechberger, Peter Schwabe, Nicolas Sendrier, Fred-
erik Vercauteren, and Bo-Yin Yang.
Initial recom-
mendations of long-term secure post-quantum systems,
2015. PQCRYPTO project https://pqcrypto.eu.
org/docs/initial-recommendations.pdf.
[3] Tuomas Aura and Pekka Nikander. Stateless connec-
tions. In Yongfei Han, Tatsuaki Okamoto, and Sihan
Qing, editors, Information and Communication Secu-
rity, First International Conference, ICICS’97, Beijing,
China, November 11–14, 1997, Proceedings, volume
1334 of Lecture Notes in Computer Science, pages
87–97. Springer, 1997. http://citeseerx.ist.psu.
edu/viewdoc/summary?doi=10.1.1.30.4436.
[4] Daniel J. Bernstein. SYN cookies, 1996. https://cr.
yp.to/syncookies.html.
[5] Daniel J. Bernstein. DNSCurve: Usable security for
DNS, 2009. https://dnscurve.org.
[6] Daniel J. Bernstein, Tung Chou, Tanja Lange, Ingo
von Maurich, Rafael Misoczki, Ruben Niederhagen,
Edoardo Persichetti, Christiane Peters, Peter Schwabe,