Module 1
A journey from high level languages, through 
assembly, to the running process
https://github.com/hasherezade/malware_training_vol1
Basics of PE (Portable 
Executable)
Basics of a PE file
• PE (Portable Executable) is a native executable format on Windows
• PE files: 
• user mode: EXE, DLL
• kernel mode: driver (.sys), kernel image (ntoskrnl.exe)
• UEFI (run in SMM – System Managemant Mode)
• Also OBJ files have structures similar to PE
Basics of a PE file
•PE (Portable Executable) contains information:
• What to execute: the compiled code
• How to execute: headers with data necessary for loading it
remcos.exe
Basics of a PE file
• PE format is based on a Unix format COFF – that was used in VAX/VMS
• It was introduced as a part of specification Win32
• Throughout many years, the core of the format didn’t change, only some new fields of 
some structures have been added
• Since introduction of 64 bit environment, PE needed to be adjusted to it: 64 bit PE was 
introduced
• Also, new variants have been introduced, like .NET PE – containing additional structures 
with intermediate code and metadata
Basics of a PE file
•PE file structure: the DOS part (legacy) and the Windows Part
https://github.com/hasherezade/malware_training_vol1/blob/main/exercises/module1/lesson2_pe/pe_snippets/pe_hdr.h
Basics of a PE file
•DOS Header: only e_magic, and e_lfnew must be filled:
typedef struct _IMAGE_DOS_HEADER {      // DOS .EXE header
WORD   e_magic;                     // Magic number -------------------------------------------> ‚MZ”
WORD   e_cblp;                      // Bytes on last page of file
WORD   e_cp;                        // Pages in file
WORD   e_crlc;                      // Relocations
WORD   e_cparhdr;                   // Size of header in paragraphs
WORD   e_minalloc;                  // Minimum extra paragraphs needed
WORD   e_maxalloc;                  // Maximum extra paragraphs needed
WORD   e_ss;                        // Initial (relative) SS value
WORD   e_sp;                        // Initial SP value
WORD   e_csum;                      // Checksum
WORD   e_ip;                        // Initial IP value
WORD   e_cs;                        // Initial (relative) CS value
WORD   e_lfarlc;                    // File address of relocation table
WORD   e_ovno;                      // Overlay number
WORD   e_res[4];                    // Reserved words
WORD   e_oemid;                     // OEM identifier (for e_oeminfo)
WORD   e_oeminfo;                   // OEM information; e_oemid specific
WORD   e_res2[10];                  // Reserved words
LONG   e_lfanew;                    // File address of new exe header --------> Points to the NT header
} IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;
https://github.com/hasherezade/malware_training_vol1/blob/main/exercises/module1/lesson2_pe/pe_snippets/pe_hdr.h
Basics of a PE file
• DOS Header: fields to remember
typedef struct _IMAGE_DOS_HEADER {
WORD   e_magic; // Magic number  „MZ”
...
LONG   e_lfanew; // points to NT header
} IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;
https://github.com/hasherezade/malware_training_vol1/blob/main/exercises/module1/lesson2_pe/pe_snippets/pe_hdr.h
typedef struct _IMAGE_NT_HEADERS32/64 {
DWORD Signature;
 Magic number „PE\0\0”
IMAGE_FILE_HEADER FileHeader;
IMAGE_OPTIONAL_HEADER32/64 OptionalHeader;
} IMAGE_NT_HEADERS64;
Let’s have a look in PE-bear...
Basics of a PE file
• FileHeader: fields to remember
typedef struct _IMAGE_FILE_HEADER {
WORD    Machine; // Specifies the architecture
WORD    NumberOfSections; // How many sections?
DWORD   TimeDateStamp;
DWORD   PointerToSymbolTable;
DWORD   NumberOfSymbols;
WORD    SizeOfOptionalHeader;
WORD    Characteristics;
} IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER; 
https://github.com/hasherezade/malware_training_vol1/blob/main/exercises/module1/lesson2_pe/pe_snippets/pe_hdr.h
typedef struct _IMAGE_NT_HEADERS32/64 {
DWORD Signature;
 „PE\0\0”
IMAGE_FILE_HEADER FileHeader;
IMAGE_OPTIONAL_HEADER32/64 OptionalHeader;
} IMAGE_NT_HEADERS64;
Let’s have a look in PE-bear...
Basics of a PE file
• OptionalHeader: fields to remember
typedef struct _IMAGE_OPTIONAL_HEADER64 {
WORD        Magic;            // type: NT32 ? NT64?
BYTE        MajorLinkerVersion;
BYTE        MinorLinkerVersion;
DWORD       SizeOfCode;
DWORD       SizeOfInitializedData;
DWORD       SizeOfUninitializedData;
DWORD       AddressOfEntryPoint; // where the execution starts?
DWORD       BaseOfCode;
ULONGLONG   ImageBase;          //default load base
DWORD       SectionAlignment; //unit in memory
DWORD       FileAlignment; //unit on disk
WORD        MajorOperatingSystemVersion;
WORD        MinorOperatingSystemVersion;
WORD        MajorImageVersion;
WORD        MinorImageVersion;
WORD        MajorSubsystemVersion;
WORD        MinorSubsystemVersion;
DWORD       Win32VersionValue;
DWORD       SizeOfImage; //size of the loaded PE
DWORD       SizeOfHeaders; //size of all the headers to map
DWORD       CheckSum;
WORD        Subsystem; // is it a console app? a driver? etc.
WORD        DllCharacteristics; // features enabled
ULONGLONG   SizeOfStackReserve;
ULONGLONG   SizeOfStackCommit;
ULONGLONG   SizeOfHeapReserve;
ULONGLONG   SizeOfHeapCommit;
DWORD       LoaderFlags;
DWORD       NumberOfRvaAndSizes;
IMAGE_DATA_DIRECTORY DataDirectory[DIRECTORY_ENTRIES_NUM];
} IMAGE_OPTIONAL_HEADER64;
https://github.com/hasherezade/malware_training_vol1/blob/main/exercises/module1/lesson2_pe/pe_snippets/pe_hdr.h
typedef struct _IMAGE_NT_HEADERS32/64 {
DWORD Signature;
 „PE\0\0”
IMAGE_FILE_HEADER FileHeader;
IMAGE_OPTIONAL_HEADER32/64 OptionalHeader;
} IMAGE_NT_HEADERS64;
Let’s have a look in PE-bear...
Basics of a PE file: sections
• PE is divided into sections with different permissions
• Sections introduce a logical layout of the binary, that compilers/linkers can 
follow
• Dividing PE on section improves security: the code is isolated from the data
• HOWEVER:
• if DEP (Data Execution Prevention) is disabled, a page without execution 
permission can still be executed
Basics of a PE file: sections
•PE sections are defined by sections header
https://github.com/hasherezade/malware_training_vol1/blob/main/exercises/module1/lesson2_pe/pe_snippets/remap.h
#define IMAGE_FIRST_SECTION( ntheader ) ((PIMAGE_SECTION_HEADER)  \
((ULONG_PTR)(ntheader) +                                      \
FIELD_OFFSET( IMAGE_NT_HEADERS, OptionalHeader ) +           \
((ntheader))->FileHeader.SizeOfOptionalHeader   \
))
A macro in 
winnt.h
pointing the first 
section
Basics of a PE file: sections
• on the disk PE is stored in a raw format (the unit is defined by File Alignment)
• In memory PE is mapped to its virtual format (the unit is defined by Section Alignment) –
usually of the granularity of one page (0x1000)
Basics of a PE file: sections
https://github.com/hasherezade/malware_training_vol1/blob/main/exercises/module1/lesson2_pe/pe_snippets/remap.h
Raw 
(file on the disk)
Virtual
(mapped in the process 
memory)
Basics of a PE file: caves
• The space reserved for a section is always rounded up to some unit (FileAlignment in a 
raw format, SectionAlignment in virtual)
• The size of the actual section content may be smaller
• The additional space is unused, and filled with padding. It is called a section cave. A cave 
in an executable section is often referenced as code cave.
• Caves may be virtual or raw
• Sometimes they may be used for installing code implants
Basics of a PE file: addresses
• Raw addresses (in file) usually correspond to virtual addresses (in memory) and vice versa
Raw 0x400 = RVA 0x1000
RVA 0x2000 = raw 0x600
RVA 0x5015 = raw 0xC15
•
RVA : Relative 
Virtual Address  
(without Image 
Base)
•
VA: absolute 
Virtual Address 
(with Image 
Base)
Basics of a PE file: addresses
• Raw addresses (in file) usually correspond to virtual addresses (in memory) and vice versa
Raw 0x700 = RVA 0x2100
RVA 0x2400 -> invalid raw
•
RVA : Relative 
Virtual Address  
(without Image 
Base)
•
VA: absolute 
Virtual Address 
(with Image 
Base)
Basics of a PE file: addresses
• Raw addresses (in file) usually correspond to virtual addresses (in memory) and vice versa
• However:
• Some sections can be unpacked in memory and not filled in the file
• Some addresses may not be mapped (present in the file, but not in the memory image)
Basics of a PE file: addresses
• Let’s open one of our sample PEs in PE-bear and see the section table
• Try converting various addresses from Raw format to Virtual, follow and 
observe
Exercise time...
Basics of a PE file
•The most information lies in data directories
Basics of a PE file: Relocation
•Relocation Table
https://github.com/hasherezade/malware_training_vol1/blob/main/exercises/module1/lesson2_pe/pe_snippets/relocate.h
Basics of a PE file: Relocation
1.
PE comes with some default base address in the header
2.
All the absolute addresses inside the PE assume that it was loaded 
at this base
https://github.com/hasherezade/malware_training_vol1/blob/main/exercises/module1/lesson2_pe/pe_snippets/relocate.h
Base Address = 400000
46E040 = 400000 + 6E040
Basics of a PE file: Relocation
• In the past EXEs were usually loaded at their default base (only DLLs didn’t 
have to)
• Nowadays most PEs load at a dynamic base (due to ASLR)
• A flag in the header determines if a dynamic base will be used
https://github.com/hasherezade/malware_training_vol1/blob/main/exercises/module1/lesson2_pe/pe_snippets/relocate.h
DLL Characteristics: DLL can move
Basics of a PE file: Relocation
• If the PE was loaded at a different base than the one defined in the header, all 
its fields using absolute addresses must be recalculated (rebased)
https://github.com/hasherezade/malware_training_vol1/blob/main/exercises/module1/lesson2_pe/pe_snippets/relocate.h
46E040 = 400000 + 6E040
32E040 = 2C0000 + 6E040
Load base = 2C0000
Basics of a PE file: Relocation
•How does PE know where are the fields that needs to be 
rebased?
https://github.com/hasherezade/malware_training_vol1/blob/main/exercises/module1/lesson2_pe/pe_snippets/relocate.h
Basics of a PE file: Relocation
•How does PE know where are the fields that needs to be 
rebased?
•They are listed in the Relocation Table!
https://github.com/hasherezade/malware_training_vol1/blob/main/exercises/module1/lesson2_pe/pe_snippets/relocate.h
Basics of a PE file: Relocation
•Let’s open one of our sample PEs in PE-bear and see the 
relocation table
•Check the code snippet to see how the relocation table is 
processed
https://github.com/hasherezade/malware_training_vol1/blob/main/exercises/module1/lesson2_pe/pe_snippets/relocate.h
Exercise time...
Basics of a PE file:
Imports & Exports
Most executables use some functions exported by other modules (external 
libraries)
1.
If we use a static library, the linker will automatically add the external 
code into our PE
2.
If we use a dynamic library (DLL), the used functions will be listed in the 
Import Table of our PE, and dynamic linking will be done when the PE is 
loaded
3.
Alternatively, we can load a DLL by ourselves using LoadLibrary and 
fetch the exported function via GetProcessAddress
Basics of a PE file: Exports
•Export Table
https://github.com/hasherezade/malware_training_vol1/blob/main/exercises/module1/lesson2_pe/pe_snippets
/export_lookup.h
Basics of a PE file: Exports
1.
DLLs are libraries of functions for other PEs to use
2.
An Export Table is a catalogue allowing to find and use a particular 
function
Basics of a PE file: Exports
...and the execution is redirected to 
the exported function
We call a function from a DLL...
Basics of a PE file: Exports
1.
Functions can be exported by a name or by ordinal (a number)
2.
Some exports can be forwarded (pointing to other functions, in 
other DLLs)
Basics of a PE file: Exports
• Forwarded functions
Basics of a PE file: Imports
•Import Table
https://github.com/hasherezade/malware_training_vol1/blob/main/exercises/module1/lesson2_pe/pe_snippets
/imports_load.h
Basics of a PE file: Imports
• Dynamic linking is done when a PE is loaded
• The loader walks through the Import Table of the PE
• loads needed DLLs
• searches the imported functions in the export table of the DLL
• fills the thunks via which the PE is going to make calls to the exported
functions with appropriate addresses 
Basics of a PE file: Imports
We call a function from a DLL...
...via thunk that was filled with the 
address of the exported function
Basics of a PE file: Imports
...and the execution is redirected to 
the exported function
We call a function from a DLL...
Basics of a PE file: Imports
• Raw: before filling imports
https://github.com/hasherezade/malware_training_vol1/blob/main/exercises/module1/lesson2_pe/pe_snippets
/imports_load.h
Basics of a PE file: Imports
• Loaded: after filling imports – thunks are filled with addresses of exported functions
https://github.com/hasherezade/malware_training_vol1/blob/main/exercises/module1/lesson2_pe/pe_snippets
/imports_load.h
Basics of a PE file: Imports
DLL Base + Function RVA
Example: 
768A0000 + 496FB =
768E96FB
Basics of a PE file: Imports
•Import Table: structure
https://github.com/hasherezade/malware_training_vol1/blob/main/exercises/module1/lesson2_pe/pe_snippets
/imports_load.h
Basics of a PE file: Imports
•Let’s open one of our sample PEs in PE-bear and see the 
import table. Find the corresponding DLLs and their exports.
•Check the code snippets to see how the import and export 
tables are processed
Exercise time...
Exercise
•Compile the given code of a custom PE loader and get familiar 
with it
•https://github.com/hasherezade/malware_training_vol1/tree/ma
in/exercises/module1/lesson2_pe
Further readings...
• MSDN documentation:
• https://docs.microsoft.com/en-us/windows/win32/debug/pe-format
• Classic articles about PE by Matt Pietrek:
• https://bytepointer.com/resources/pietrek_in_depth_look_into_pe_format_pt1.htm -
• https://bytepointer.com/resources/pietrek_in_depth_look_into_pe_format_pt2.htm
• https://docs.microsoft.com/en-us/previous-
versions/ms809762(v=msdn.10)?redirectedfrom=MSDN