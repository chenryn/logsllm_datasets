n
E
d
e
t
s
u
r
T
checks add-region performs. This variability is acceptable
since overlap checks are cheap. Also, overlap checks are only
performed at enclave initialization but not during runtime. For
add-data and add-entries runtime increases with the
size of the added data blob or the number of added entries,
respectively. This is because changing memory tags as well as
computing the hash measurement depends on the amount of
data. Also, performance slightly depends on the position of the
associated enclave region in the ECB. The base costs are shown
in Table VI when adding one data word or one entry to the ﬁrst
enclave region. init-enclave has constant overhead. In
contrast, destroy-enclave unclaims all enclave memory
with a linear sweep over the enclave. We show the runtime of
destroying an empty enclave. load-enclave validates the
MPU conﬁguration against the loaded enclave’s ECB, hence
the moderate overhead. Once an enclave is loaded, horizontal
transitions between U-mode (app) and TU-mode (enclave)
experience no principled overhead, as discussed later.
Trusted enclave services. Trusted enclave services are imple-
mented as TSyscalls, which experience slight overhead due to
M-mode trap delegation. TSyscall dispatching includes valida-
tion of the MPU conﬁguration for vertical stack interleaving
and jumping to the correct service routine. A return from a
TSyscall unwinds the dispatcher context, clears all caller-saved
registers and returns back to TU-mode using the RISC-V sret
instruction. In the following we exclude TSyscall, dispatch
and return overhead. get-key computes an HMAC using
two SHA256 computations, hence the overhead. shm-offer
needs to check validity of the arguments—not only their
memory tags but also whether the arguments belong to the
calling enclave. Apart from that, the performance is constant
and independent of other enclaves. shm-accept traverses
the linked list of ECB’s to ﬁnd a matching SHM offer. For
our benchmarks,
the ﬁrst enclave in the linked list has a
corresponding SHM offer. shm-release only erases the
accepted SHM region from the enclave’s ECB, in our case, the
ﬁfth enclave region. Interruption and resumption of enclaves
(and TagRoot) is quite fast and mainly consists of saving
and restoring the execution context in the interrupt frame. As
before, the performance numbers of interrupt-enclave
12
and resume exclude TSyscall latency due to trap delegation,
while TSyscall dispatch and return overhead do not apply here.
TUenter and TUleave. As shown in the last rows of Table VI,
TUenter has no overhead, showing only one jump instruction
into the enclave. TUleave only takes longer because of an
assumed pipeline stall of the ret instruction. When enclaves
call untrusted functions on the outside, these ocalls need to
securely store and verify the stack pointer, as discussed in
Section VI-B. Moreover, an enclave must clear sensitive CPU
registers on TUleave as well as ocalls, which can be automated,
e.g., via so-called edge routines in the SGX SDK [30].
D. Memory Overhead
TIMBER-V adds two tag bits to each 32-bit memory
word, thus introducing 6,25% hardware memory overhead. Our
TIMBER-V architecture directly runs unmodiﬁed code and,
thus, does not introduce software memory overhead. Like-
wise, our code hardening transformation does not introduce
memory overhead, since memory instructions are replaced
1:1 with checked instructions. Slight overhead only occurs if
additional instructions are inserted for ﬁxing offset overﬂows,
as discussed in Section IX-B. Heap interleaving needs small
constant-sized code memory for the allocation hooks but in
turn voids the need for secure heap implementations, which in
total reduces code size. We do not give actual numbers since
this strongly depends on the heap implementation. Stack inter-
leaving needs additional code for stack frame allocation and
deallocation. Currently, we insert checked store instructions for
each allocated word, thus showing 43% overhead in assembler
code lines for the expensive minver benchmark. However,
when optimizing for code size, one could easily achieve con-
stant overhead per stack (de)allocation by embedding checked
stores in a loop. We manually optimized stack interleaving for
minver and reduced the code overhead to 1%.
TagRoot Code Size. We used sloccount to count
the
number of source code lines as an estimate of TagRoot’s
complexity. TagRoot consists of 369 lines of assembler code
and 1686 lines of C-code, from which 313 lines are used by
HMAC and SHA256. This code base is fairly small, which is
desirable for a trusted computing base as it reduces the risk of
programming bugs. Also, the small size is beneﬁcial for formal
veriﬁcation techniques that could help certify our TagRoot
implementation [33]. As a comparison, the used FreeRTOS
operating system has approximately 12 500 lines of code.
X. RELATED WORK
In this section, we compare TIMBER-V against related
work on isolated execution as well as tagged memory.
A. Isolated Execution
Hardware-based isolated execution can be classiﬁed
into virtual and physical address-based systems, of which
Maene et al. [36] give an extensive overview. Many schemes
target mid and upper-class processors with virtual memory
support, among which are AEGIS [47], Intel TXT [28], ARM
TrustZone [2], Bastion [10], IBM SecureBlue++ [7], Intel
SGX [37], ISO-X [22]. Sanctum [13] implements the SGX
enclave model on RISC-V with virtual memory, adding addi-
tional side-channel protection. In contrast, we bring enclaves
to smaller RISC-V featuring only limited physical memory.
Physical Address-based Systems. SMART [21], Sancus [40],
Soteria [25], TyTAN [9], and TrustLite [34] implement pro-
gram counter-based memory access control for isolating secure
tasks. Secure task’s memory regions are only accessible when
the program counter is in its code region. Sancus has a
hardware-only TCB and isolates a ﬁxed number of small unin-
terruptible secure tasks stored in pre-deﬁned memory locations.
TyTAN and TrustLite use an execution aware MPU (EA-
MPU) with multiple code and/or data regions per secure task.
TrustLite loads all secure tasks at boot time, while TyTAN
allows dynamic loading and unloading of secure tasks at
runtime. The EA-MPU makes context switches faster but limits
the number of concurrently loaded secure tasks. In contrast,
TIMBER-V supports an arbitrary number of enclaves with
ﬁne-grained, dynamic isolation and multiple entry points.
Secure communication in TrustLite is done via a simple
handshake protocol, where two secure tasks ﬁrst attest each
other and then use cryptographic session tokens to authen-
ticate messages. In TIMBER-V local enclave attestation and
communication is done implicitly via shared memory, without
using any cryptographic secrets. TyTAN uses a dedicated IPC
proxy task which forwards messages between secure tasks,
introducing copying overhead (1324 CPU cycles). In contrast,
our secure shared memory is a fast alternative for exchanging
bulk data between enclaves.
TrustZone-M [3] supports four security domains like
TIMBER-V. Horizontal and vertical domain transitions require
special
instructions, while in TIMBER-V domain switches
are direct, thus imposing zero runtime overhead. TrustZone-
M only supports secure and non-secure tasks, while our
architecture supports mixed processes, where enclaves are
directly embedded in untrusted processes via tagged memory,
thus achieving ﬁne-grained isolation. TrustZone-M optionally
supports two separate MPUs, one for the secure and one for
the non-secure world. We reuse the same MPU across secu-
rity domains, thus saving hardware costs. Also, our dynamic
memory interleaving allows for stack (and heap) reuse, while
TrustZone-M requires separate stacks for each domain.
B. Tagged Memory Architectures
The availability of metadata is the foundation for a mul-
titude of run-time monitoring techniques like various sani-
tizers [44,46], as well as dynamic information ﬂow track-
ing (DIFT) (a.k.a. taint tracking) [43]. Subsequently, many
hardware-based tagged memory architectures have been de-
veloped. In particular, for DIFT, implementations range from
single tag bit schemes with ﬁxed policy (e.g., Minos [14] and
CHERI [52]), over multi-bit schemes with partially conﬁg-
urable policy (e.g., Raksha [15], DIFT [48], DIFT with copro-
cessor [32]), to schemes with conﬁgurable bit width and fully
programmable policy and enforcement (e.g., FlexiTaint [49],
instruction-grain lifeguards [11], Harmoni [17], PUMP [19]).
Compared to DIFT architectures, TIMBER-V has notably
different characteristics. Firstly, DIFT schemes have a strong
focus on performing tag/taint propagation during ALU opera-
tions. TIMBER-V, on the other hand, does not perform any tag
13
propagation but utilizes tags for isolation purposes. Abusing
a DIFT architecture solely for isolation, while possible in
some schemes like Raksha [15] and PUMP [19], is needlessly
wasteful. Secondly, TIMBER-V introduces a new trusted se-
curity domain, and the isolation and update policies depend
on the currently active domain. Partially conﬁgurable DIFT
architectures typically do not support such a domain switch.
Finally, even fully programmable DIFT architectures are not
necessarily suited for implementing TIMBER-V. Namely, ar-
chitectures that perform tag operations asynchronously to the
main processor [11,17,32] introduce a TOCTOU gap that can
potentially be used to exﬁltrate data from the trusted domain.
Besides DIFT-based architectures, other architectures use
tagged-memory for enforcing various kinds of memory pro-
tection. HardBound [18] implements fat pointers to prevent
spatial memory safety violations. HDFI [45] uses a single tag
bit to protect sensitive data words. However, in HDFI, tag
checks are only performed when reading the data which means
that destructive write operations on sensitive data can not be
prevented but only detected. This property corresponds to the
weak low-watermark policy for objects of the Biba integrity
model [6]. In contrast, TIMBER-V follows the stronger strict
integrity policy of the Biba model by refusing untrusted modi-
ﬁcations of trusted data. Compared to that, Mondrian Memory
Protection [53], which uses two tag bits, and Loki [54], using
up to 32 tag bits per word, are more similar to TIMBER-V.
However, both concepts solely use tagged memory to imple-
ment word-wise access permissions which is not sufﬁcient
to implement efﬁcient isolated execution. Additionally, when
different permissions are tightly interleaved, Loki’s tag size is
simply too large for low-end devices that we target.
XI. POSSIBLE EXTENSIONS
The concept of TIMBER-V can be directly applied to other
system components. Together with secure interrupts, ﬂexible
safety-critical systems can be implemented.
Secure Components and Peripherals. One can easily extend
CPU caches with our two tag bits and propagate them to
main memory on cache eviction. Also, memory-mapped I/O
peripherals can beneﬁt from TIMBER-V’s tag isolation policy
by pinning their tag bits in a tag cache. That way, TIMBER-V
can facilitate secure I/O, that is, secure interaction with end
users, sensors, actuators or other networked devices.
Secure Interrupts. Most embedded systems react upon regular
timer or irregular I/O interrupts. TIMBER-V supports secure
interrupts by modifying the M-mode trap delegation mecha-
nism to route interrupts directly to the trusted trap handler,
which is not callable to prevent fake interrupts from S-mode.
Safety-critical Systems. TagRoot is a compact implementation
of isolated execution on top of TIMBER-V. Extending Tag-
Root for safety-critical systems with availability guarantees is
an interesting ﬁeld of research and should be straight forward.
We denote safety-critical enclaves as safeclaves. To guaran-
tee real-time behavior, safeclaves must be protected against
denial-of-service attacks (DoS). Safeclaves are not triggered
by untrusted code but by external I/O events or recurring
timer periods. TagRoot can intercept safeclave interrupts as
discussed before in order to assuredly trigger safeclave execu-
tion. Obviously, one cannot use dynamic memory interleaving
for safeclaves. Normal enclaves, however, can still beneﬁt
from interleaving. Also, by slightly adapting our shared MPU
design, one can exclude safeclave MPU slots from being
shared, making safeclaves safe against DoS from the OS.
XII. CONCLUSION
We presented TIMBER-V, the ﬁrst efﬁcient tagged mem-
ory architecture for isolated execution of enclaves. TIMBER-V
minimizes memory overhead of tagged memory by augmenting
tag isolation with MPU isolation. The ﬂexibility of TIMBER-V
enables ﬁne-grained and dynamic management of trusted
memory, enabling novel schemes like stack interleaving. This
reduces memory fragmentation, which is particularly relevant
for low-end devices. A small trust manager provides trusted
services, including secure shared memory. We implemented
and evaluated TIMBER-V to demonstrate its practicality.
ACKNOWLEDGMENTS
This work was partially supported by the TU Graz LEAD
project “Dependable Internet of Things in Adverse Environ-
ments” and by the Austrian Research Promotion Agency (FFG)
via the K-project DeSSnet, which is funded in the context of
COMET – Competence Centers for Excellent Technologies
by BMVIT, BMWFW, Styria and Carinthia. Furthermore, this
research was co-funded by the German Science Foundation,
as part of project S2 and P3 within CRC 1119 CROSSING,
and Intel Collaborative Research Institute for Collaborative
Autonomous & Resilient Systems (ICRI-CARS).
REFERENCES
[1]
I. Anati, S. Gueron, S. Johnson, and V. Scarlata. Innovative technology
for CPU based attestation and sealing, 2013. White Paper.
[2] ARM Security Technology: Building a Secure System using TrustZone
Technology, 2009. Ref. no. PRD29-GENC-009492C.
[3] TrustZone technology for ARMv8-M Architecture, 2017. Ref. no.
[4]
100690 0200 00 en.
J. Bennett, A. Burgess, S. Cook, K. Eder, S. Hollis, and J. Pallister. Bris-
tol/embecosm embedded benchmark suite. http://beebs.eu/ (Accessed
2018/06/18).
[5] D. J. Bernstein. Cache-Timing Attacks on AES, 2005. https://cr.yp.to/
antiforgery/cachetiming-20050414.pdf. (Accessed 2018/05/29).
[6] K. J. Biba.
Integrity Considerations for Secure Computer Systems,
1977. The MITRE Corporation. Tech. Report ESD-TR-76-372.
[7] R. Boivie and P. Williams. SecureBlue++: CPU Support for Secure
Executables, 2012. IBM research report no. RC25369.
[8] A. Bradbury, G. Ferris, and R. Mullins. Tagged memory and minion
cores in the lowRISC SoC, 2014. lowRISC-MEMO 2014-001.
[9] F. F. Brasser, B. E. Mahjoub, A. Sadeghi, C. Wachsmann, and P. Koe-
berl. TyTAN: tiny trust anchor for tiny devices. In Design Automation
Conference – DAC’15, pages 34:1–34:6. ACM, 2015.
[10] D. Champagne and R. B. Lee. Scalable architectural support for trusted
In High Performance Computer Architecture – HPCA’10,
software.
pages 1–12. IEEE Computer Society, 2010.
[11] S. Chen, M. Kozuch, P. B. Gibbons, M. P. Ryan, T. Strigkos, T. C.
Mowry, O. Ruwase, E. Vlachos, B. Falsaﬁ, and V. Ramachandran.
Flexible Hardware Acceleration for Instruction-Grain Lifeguards. IEEE
Micro, 29:62–72, 2009.
[12] B. Coppens, I. Verbauwhede, K. D. Bosschere, and B. D. Sutter. Prac-
tical Mitigations for Timing-Based Side-Channel Attacks on Modern
x86 Processors. In Security and Privacy – S&P’09, pages 45–60. IEEE
Computer Society, 2009.
[13] V. Costan, I. A. Lebedev, and S. Devadas. Sanctum: Minimal Hardware
Extensions for Strong Software Isolation. In USENIX Security’16, pages
857–874. USENIX Association, 2016.
14
[14]
J. R. Crandall, S. F. Wu, and F. T. Chong. Minos: Architectural support
for protecting control data. TACO, 3:359–389, 2006.
[15] M. Dalton, H. Kannan, and C. Kozyrakis. Raksha: a ﬂexible information
ﬂow architecture for software security. In International Symposium on
Computer Architecture – ISCA’07, pages 482–493. ACM, 2007.
[16] A. A. de Amorim, C. Hritcu, and B. C. Pierce. The Meaning of Memory
Safety. In Principles of Security and Trust – POST’18, volume 10804
of LNCS, pages 79–105. Springer, 2018.
[17] D. Y. Deng and G. E. Suh. High-performance parallel accelerator for
ﬂexible and efﬁcient run-time monitoring. In Dependable Systems and
Networks – DSN’12, pages 1–12. IEEE Computer Society, 2012.
J. Devietti, C. Blundell, M. M. K. Martin, and S. Zdancewic. Hard-
bound: architectural support for spatial safety of the C programming
In Architectural Support for Programming Languages and
language.
Operating Systems – ASPLOS’08, pages 103–114. ACM, 2008.
[18]
[19] U. Dhawan, C. Hritcu, R. Rubin, N. Vasilakis, S. Chiricescu, J. M.
Smith, T. F. K. Jr., B. C. Pierce, and A. DeHon. Architectural Support
for Software-Deﬁned Metadata Processing. In Architectural Support for
Programming Languages and Operating Systems – ASPLOS’15, pages
487–502. ACM, 2015.
[20] EEMBC. CoreMark.
https://www.eembc.org/coremark/ (Accessed
2018/06/18).
[21] K. Eldefrawy, G. Tsudik, A. Francillon, and D. Perito. SMART: Secure
and Minimal Architecture for (Establishing Dynamic) Root of Trust. In
Network and Distributed System Security Symposium – NDSS’12. The
Internet Society, 2012.
[22] D. Evtyushkin, J. Elwell, M. Ozsoy, D. V. Ponomarev, N. B. Abu-
Ghazaleh, and R. Riley. Iso-X: A Flexible Architecture for Hardware-
In Symposium on Microarchitecture –
Managed Isolated Execution.
MICRO’14, pages 190–202. IEEE Computer Society, 2014.
[23] E. A. Feustel. The Rice research computer: a tagged architecture.
In American Federation of Information Processing Societies – AFIPS,
volume 40 of AFIPS Conference Proceedings, pages 369–377. AFIPS,
1972.
[24] The GNU Awk User’s Guide.
Edition 4.2. https://www.gnu.org/
software/gawk/manual/gawk.html,(Accessed 2018/08/06).
J. G¨otzfried, T. M¨uller, R. de Clercq, P. Maene, F. C. Freiling, and
I. Verbauwhede. Soteria: Ofﬂine Software Protection within Low-
In Annual Computer Security Applications
cost Embedded Devices.
Conference – ACSAC’15, pages 241–250. ACM, 2015.
[25]
[26] Helpnetsecurity. The cost of IoT hacks: Up to 13% of revenue for
smaller ﬁrms, 2017. https://www.helpnetsecurity.com/2017/06/05/iot-
hacks-cost/ (Accessed 2018/07/27).
[27] B. Igal. Bits, please! exploring Qualcomm’s TrustZone implementation,
http://bits-please.blogspot.com/2015/08/exploring-qualcomms-
2015.
trustzone.html (Accessed 2018/08/01).
Intel Trusted Execution Technology (Intel TXT), Software Development
Guide. Reference no. 315168-012.
Intel 64 and IA-32 Architectures Software Developer’s Manual, 2016.
Reference no. 325462-061US.
Intel Software Guard Extensions SDK for Linux OS. Developer Refer-
ence, 2016. Rev. 1.5.
[28]
[29]
[30]
[31] A. Joannou, J. Woodruff, R. Kovacsics, S. W. Moore, A. Bradbury,
H. Xia, R. N. M. Watson, D. Chisnall, M. Roe, B. Davis, E. Napierala,
J. Baldwin, K. Gudka, P. G. Neumann, A. Mazzinghi, A. Richardson,
S. D. Son, and A. T. Markettos. Efﬁcient Tagged Memory.
In
International Conference on Computer Design – ICCD’17, pages 641–
648. IEEE Computer Society, 2017.
[32] H. Kannan, M. Dalton, and C. Kozyrakis. Decoupling Dynamic
Information Flow Tracking with a dedicated coprocessor. In Dependable
Systems and Networks – DSN’09, pages 105–114. IEEE Computer
Society, 2009.
[33] G. Klein, J. Andronick, K. Elphinstone, G. Heiser, D. Cock, P. Derrin,
D. Elkaduwe, K. Engelhardt, R. Kolanski, M. Norrish, T. Sewell,
H. Tuch, and S. Winwood. seL4: formal veriﬁcation of an operating-
system kernel. Commun. ACM, 53:107–115, 2010.
[34] P. Koeberl, S. Schulz, A. Sadeghi, and V. Varadharajan. TrustLite:
In European
a security architecture for tiny embedded devices.
Conference on Computer Systems – EUROSYS’14, pages 10:1–10:14.
ACM, 2014.
15
[35] S. Larson.
FDA conﬁrms that St. Jude’s cardiac devices can
be hacked. https://money.cnn.com/2017/01/09/technology/fda-st-jude-
cardiac-hack/ (Accessed 2018/07/18).
[36] P. Maene, J. G¨otzfried, R. de Clercq, T. M¨uller, F. C. Freiling, and
I. Verbauwhede. Hardware-Based Trusted Computing Architectures for
Isolation and Attestation. IEEE Trans. Computers, 67:361–374, 2018.
[37] F. McKeen, I. Alexandrovich, A. Berenzon, C. V. Rozas, H. Shaﬁ,
Innovative instructions and
V. Shanbhogue, and U. R. Savagaonkar.
software model for isolated execution. In Hardware and Architectural
Support for Security and Privacy – HASP, page 10. ACM, 2013.
[38] C. Miller and C. Valasek. Remote exploitation of an unaltered passen-
ger vehicle, 2015. http://illmatics.com/Remote%20Car%20Hacking.pdf
(Accessed 2018/07/18).
[39] NJCCIC. Mirai Botnet.
https://www.cyber.nj.gov/threat-proﬁles/
botnet-variants/mirai-botnet (Accessed 2018/07/18).
J. Noorman, J. V. Bulck, J. T. M¨uhlberg, F. Piessens, P. Maene,
B. Preneel, I. Verbauwhede, J. G¨otzfried, T. M¨uller, and F. C. Freiling.
Sancus 2.0: A Low-Cost Security Architecture for IoT Devices. ACM
Trans. Priv. Secur., 20:7:1–7:33, 2017.
[40]
[41] E. Ronen, A. Shamir, A. Weingarten, and C. O’Flynn.
IoT Goes
Nuclear: Creating a ZigBee Chain Reaction. In Security and Privacy –
S&P’17, pages 195–212. IEEE Computer Society, 2017.
[42] X. Ruan. Boot with Integrity, or Don’t Boot, pages 143–163. Apress,
Berkeley, CA, 2014.
[43] E. J. Schwartz, T. Avgerinos, and D. Brumley. All You Ever Wanted to
Know about Dynamic Taint Analysis and Forward Symbolic Execution
In Security and Privacy –
(but Might Have Been Afraid to Ask).
S&P’10, pages 317–331. IEEE Computer Society, 2010.
[44] K. Serebryany, D. Bruening, A. Potapenko, and D. Vyukov. Address-
Sanitizer: A Fast Address Sanity Checker. In USENIX Annual Technical
Conference – USENIX ATC’12, pages 309–318. USENIX Association,
2012.
[45] C. Song, H. Moon, M. Alam, I. Yun, B. Lee, T. Kim, W. Lee, and
In Security
Y. Paek. HDFI: Hardware-Assisted Data-Flow Isolation.
and Privacy – S&P’16, pages 1–17. IEEE Computer Society, 2016.
[46] E. Stepanov and K. Serebryany. MemorySanitizer: fast detector of
uninitialized memory use in C++. In Symposium on Code Generation
and Optimization – CGO’15, pages 46–55. IEEE Computer Society,
2015.
[47] G. E. Suh, D. E. Clarke, B. Gassend, M. van Dijk, and S. Devadas.
AEGIS: architecture for tamper-evident and tamper-resistant processing.
In International Conference on Supercomputing – ICS’03, pages 160–
171. ACM, 2003.
[48] G. E. Suh, J. W. Lee, D. Zhang, and S. Devadas. Secure program execu-
tion via dynamic information ﬂow tracking. In Architectural Support for
Programming Languages and Operating Systems – ASPLOS’04, pages
85–96. ACM, 2004.
[49] G. Venkataramani, I. Doudalis, Y. Solihin, and M. Prvulovic. FlexiTaint:
In High
A programmable accelerator for dynamic taint propagation.
Performance Computer Architecture – HPCA’08, pages 173–184. IEEE
Computer Society, 2008.
[50] A. Waterman and K. Asanovi´c. The risc-v instruction set manual,
volume i: User-level isa, version 2.2. Technical report, SiFive Inc.,
EECS Department, University of California, Berkeley, 2017.
[51] A. Waterman and K. Asanovi´c. The risc-v instruction set manual,
volume ii: Privileged architecture, version 1.10. Technical report, SiFive
Inc., EECS Department, University of California, Berkeley, 2017.
[52] R. N. M. Watson, J. Woodruff, P. G. Neumann, S. W. Moore, J. An-
derson, D. Chisnall, N. H. Dave, B. Davis, K. Gudka, B. Laurie, S. J.
Murdoch, R. Norton, M. Roe, S. D. Son, and M. Vadera. CHERI: A
Hybrid Capability-System Architecture for Scalable Software Compart-
mentalization. In Security and Privacy – S&P’15, pages 20–37. IEEE
Computer Society, 2015.
[53] E. Witchel, J. Cates, and K. Asanovic. Mondrian memory protection.
In Architectural Support for Programming Languages and Operating
Systems – ASPLOS’02, pages 304–316. ACM Press, 2002.
[54] N. Zeldovich, H. Kannan, M. Dalton, and C. Kozyrakis. Hardware
Enforcement of Application Security Policies Using Tagged Memory.
In Operating Systems Design and Implementation – OSDI’08, pages
225–240. USENIX Association, 2008.