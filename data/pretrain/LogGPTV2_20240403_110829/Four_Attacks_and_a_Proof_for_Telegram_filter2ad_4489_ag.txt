related-key-deriving function ğœ™MAC), and requires it to produce
two payloads ğ‘0, ğ‘1 (for either user u) such that there is a
collision in the corresponding outputs msg_key0, msg_key1
of the function family MAC. The advantage of F in break-
ing the RKCR-security of MAC with respect
to ğœ™MAC is
MAC, ğœ™MAC,F]. It is clear by
deï¬ned as Advrkcr
inspection that the RKCR-security of MTP-MAC.Ev(mku, ğ‘) =
SHA-256(mku (cid:107) ğ‘)[64 : 192]
to ğœ™MAC from
Fig. 15) reduces to the collision resistance of truncated-output
SHA-256.
MAC, ğœ™MAC(F) = Pr[Grkcr
(with respect
MAC, ğœ™MAC,F
Game Grkcr
mk â†$ {0, 1}320 ; (mkI , mkR) â† ğœ™MAC(mk)
(u, ğ‘0, ğ‘1) â†$ F (mkI , mkR) ; msg_key0 â† MAC.Ev(mku, ğ‘0)
msg_key1 â† MAC.Ev(mku, ğ‘1) ; dist_inp â† ( ğ‘0 â‰  ğ‘1)
eq_out â† (msg_key0 = msg_key1) ; Return dist_inp âˆ§ eq_out
Figure 18: Related-key collision resistance of function family
MAC with respect to related-key-deriving function ğœ™MAC.
4) MTP-MAC is a PRF under RKA for unique-preï¬x inputs:
We require that MTP-MAC behaves like a pseudorandom
function in the RKA setting when it is evaluated on a set of
inputs that have unique 256-bit preï¬xes (UPRKPRF), as deï¬ned
in Fig. 19. The security game Guprkprf
MAC, ğœ™MAC,D in Fig. 19 extends the
standard PRF notion to use two related ğœ™MAC-derived function
keys mkI, mkR for the function family MAC (similar to the
RKPRF-security notion we deï¬ned above); but it also enforces
that the adversary D cannot query its oracle RoR on two
inputs (u, ğ‘0) and (u, ğ‘1) for any u âˆˆ {I, R} such that ğ‘0, ğ‘1
share the same 256-bit preï¬x. The unique-preï¬x condition
means that the game does not need to maintain a PRF table to
achieve output consistency. Note that this security game only
allows to call the oracle RoR with inputs of length | ğ‘| â‰¥ 256;
this is sufï¬cient for our purposes, because in MTP-CH the
function family MTP-MAC is only used with payloads that are
longer than 256 bits. The advantage of D in breaking the
UPRKPRF-security of MAC with respect to ğœ™MAC is deï¬ned as
Advuprkprf
MAC, ğœ™MAC
In Section V-B2 we deï¬ne a novel security notion that
requires SHACAL-2 to be a leakage-resilient, related-key PRF
when evaluated on a ï¬xed input; in the full version of this work
we show that the UPRKPRF-security of MTP-MAC reduces to
this security notion and to the one-time PRF-security (OTPRF)
of the SHA-256 compression function â„256. The new security
notion is similar to the notion discussed in Section V-A2 and
deï¬ned in Section V-B1, in that it only allows the adversary
to evaluate SHACAL-2 on the ï¬xed input IV256. However, the
underlying security game derives the related SHACAL-2 keys
(D) = 2 Â· Pr[Guprkprf
MAC, ğœ™MAC,D] âˆ’ 1.
MAC, ğœ™MAC,D
Game Guprkprf
ğ‘ â†$ {0, 1}
mk â†$ {0, 1}320
(mkI , mkR) â† ğœ™MAC(mk)
ğ‘‹I â† ğ‘‹R â† âˆ…
ğ‘(cid:48) â†$ DRoR
Return ğ‘(cid:48) = ğ‘
// ğ‘ âˆˆ {0, 1}âˆ—
RoR(u, ğ‘)
If | ğ‘| < 256 then return âŠ¥
ğ‘0 â† ğ‘[0 : 256]
If ğ‘0 âˆˆ ğ‘‹u then return âŠ¥
ğ‘‹u â† ğ‘‹u âˆª {ğ‘0}
msg_key1 â† MAC.Ev(mku, ğ‘)
msg_key0 â†$ {0, 1}MAC.ol
Return msg_keyğ‘
Figure 19: Related-key PRF-security of function family MAC
for inputs with unique 256-bit preï¬xes, with respect to key
derivation function ğœ™MAC.
differently, partially based on the function ğœ™MAC deï¬ned in
Fig. 15 (as opposed to ğœ™KDF). The new notion is formalised as
the HRKPRF-security of SHACAL-2 with respect to ğœ™MAC.
5) MTP-SE is a one-time indistinguishable SE scheme:
For any block cipher E, the full version of this work shows
that IGE[E] as used in MTProto is OTIND$-secure (deï¬ned in
Fig. 3) if CBC[E] is OTIND$-secure. This enables us to use
standard results [37], [38] on CBC in our analysis of MTProto.
B. Novel assumptions about SHACAL-2
In this section we deï¬ne two novel assumptions about
SHACAL-2. Both assumptions require SHACAL-2 to be a related-
key PRF when evaluated on the ï¬xed input IV256 (i.e. on the
initial state of SHA-256), meaning that the adversary can obtain
the values of SHACAL-2.Ev(Â·, IV256) for a number of different
but related keys. We formalise the two assumptions as security
notions, called LRKPRF and HRKPRF, each deï¬ned with
respect to different related-key-deriving functions; this reï¬‚ects
the fact that these security notions allow the adversary to
choose the keys in substantially different ways. The notion of
LRKPRF-security derives the SHACAL-2 keys partially based
on the function ğœ™KDF, whereas the notion of HRKPRF-security
derives SHACAL-2 keys partially based on the function ğœ™MAC
(both functions are deï¬ned in Fig. 15). Both security notions
also have different ï¬‚avours of leakage resilience: (1) the security
game deï¬ning LRKPRF allows the adversary to directly choose
128 bits of the 512-bit long SHACAL-2 key, with another 96
bits of this key ï¬xed and known (due to being chosen by the
SHA padding function SHA-pad), and (2) the security game
deï¬ning HRKPRF allows the adversary to directly choose 256
bits of the 512-bit long SHACAL-2 key.
We use the notion of LRKPRF-security to justify the RKPRF-
security of MTP-KDF with respect to ğœ™KDF (as explained in
Section V-A2), which is needed in both the IND-security
and the INT-security proofs of MTP-CH. We use the notion
of HRKPRF-security to justify the UPRKPRF-security of
MTP-MAC with respect to ğœ™MAC (as explained in Section V-A4),
which is needed in the IND-security proof of MTP-CH.
We stress that we have to assume properties of SHACAL-2 that
have not been studied in the literature. Related-key attacks on
reduced-round SHACAL-2 have been considered [39], [40], but
they ordinarily work with a known difference relation between
unknown keys. In contrast, our LRKPRF-security notion uses
Authorized licensed use limited to: Tsinghua University. Downloaded on August 07,2022 at 12:21:42 UTC from IEEE Xplore.  Restrictions apply. 
99
keys that differ by random, unknown parts. Both of our security
notions consider keys that are partially chosen or known by the
adversary. It is straightforward to show that both the LRKPRF-
security and the HRKPRF-security of SHACAL-2 hold in the
ideal cipher model (i.e. when SHACAL-2 is modelled as the
ideal cipher). However, we cannot rule out the possibility of
attacks on SHACAL-2 due to its internal structure in the setting
of related-key attacks combined with key leakage. We leave
this as an open question.
1) SHACAL-2 is a PRF with ğœ™KDF-based related keys:
Our LRKPRF-security notion for SHACAL-2 is deï¬ned with
respect to related-key-deriving functions ğœ™KDF (from Fig. 15)
and ğœ™SHACAL-2 from Fig. 20. The latter mirrors the design
of MTP-KDF that (in Deï¬nition 9) is deï¬ned to return
SHA-256(msg_key (cid:107) kk0) (cid:107) SHA-256(kk1 (cid:107) msg_key) for the
target key kku = (kk0, kk1), except ğœ™SHACAL-2 only needs to
produce the corresponding SHA-padded inputs.
// |msg_key| = 128
ğœ™SHACAL-2(kku, msg_key)
(kk0, kk1) â† kku ; sk0 â† SHA-pad(msg_key (cid:107) kk0)
sk1 â† SHA-pad(kk1 (cid:107) msg_key) ; Return (sk0, sk1)
ğœ™SHACAL-2 :
Figure
function
(MTP-KDF.Keys Ã— MTP-KDF.Keys) Ã— {0, 1}128 â†’ {0, 1}512.
20: Related-key-deriving
Consider the game Glrkprf
SHACAL-2, ğœ™KDF, ğœ™SHACAL-2,D in Fig. 21. Ad-
versary D is given access to the RoR oracle that takes
u, ğ‘–, msg_key as input; all
inputs to the oracle serve as
parameters for the SHACAL-2 key derivation, used to determine
the challenge key skğ‘–. The adversary gets back either the output
of SHACAL-2.Ev(skğ‘–, IV256) (if ğ‘ = 1), or a uniformly random
value (if ğ‘ = 0), and is required to guess the challenge bit.
The PRF table T is used to ensure consistency, so that a single
random value is sampled and remembered for each set of used
key derivation parameters u, ğ‘–, msg_key. The advantage of D
in breaking the LRKPRF-security of SHACAL-2 with respect to
(D) =
ğœ™KDF and ğœ™SHACAL-2 is deï¬ned as Advlrkprf
2 Â· Pr[Glrkprf
SHACAL-2, ğœ™KDF, ğœ™SHACAL-2,D] âˆ’ 1.
SHACAL-2, ğœ™KDF, ğœ™SHACAL-2
SHACAL-2, ğœ™KDF, ğœ™SHACAL-2,D
// u âˆˆ {I, R}, ğ‘– âˆˆ {0, 1}, |msg_key| = 128
Game Glrkprf
ğ‘ â†$ {0, 1} ; kk â†$ {0, 1}672 ; (kkI , kkR) â† ğœ™KDF(kk)
ğ‘(cid:48) â†$ DRoR ; Return ğ‘(cid:48) = ğ‘
RoR(u, ğ‘–, msg_key)
(sk0, sk1) â† ğœ™SHACAL-2(kku, msg_key)
ğ‘¦1 â† SHACAL-2.Ev(skğ‘–, IV256)
If T[u, ğ‘–, msg_key] =âŠ¥ then
ğ‘¦0 â† T[u, ğ‘–, msg_key] ; Return ğ‘¦ğ‘
Figure 21: Leakage-resilient, related-key PRF-security of
function family SHACAL-2 on ï¬xed input IV256 with respect to
related-key-deriving functions ğœ™KDF and ğœ™SHACAL-2.
T[u, ğ‘–, msg_key] â†$ {0, 1}SHACAL-2.ol
2) SHACAL-2 is a PRF with ğœ™MAC-based related keys:
SHACAL-2, ğœ™MAC,D in Fig. 22. Adversary D
Consider the game Ghrkprf
is given access to RoR oracle, and is required to choose
SHACAL-2, ğœ™MAC,D
// u âˆˆ {I, R}, | ğ‘| = 256
RoR(u, ğ‘)
ğ‘¦1 â† SHACAL-2.Ev(mku (cid:107) ğ‘, IV256)
If T[u, ğ‘] = âŠ¥ then
ğ‘¦0 â† T[u, ğ‘]
Return ğ‘¦ğ‘
Game Ghrkprf
ğ‘ â†$ {0, 1}
mk â†$ {0, 1}320
(mkI , mkR) â† ğœ™MAC(mk)
ğ‘(cid:48) â†$ DRoR
Return ğ‘(cid:48) = ğ‘
Figure 22: Leakage-resilient, related-key PRF-security of
function family SHACAL-2 on ï¬xed input IV256 with respect to
related-key-deriving function ğœ™MAC.
T[u, ğ‘] â†$ {0, 1}SHACAL-2.ol
SHACAL-2, ğœ™MAC
(D) = 2 Â· Pr[Ghrkprf
the 256-bit sufï¬x ğ‘ of each challenge key used for evaluating
SHACAL-2.Ev(Â·, IV256). The value of mku is then used to set the
256-bit preï¬x of the challenge key, where u is also chosen by
the adversary, but the mkI, mkR values themselves are related
secrets that are not known to D. The advantage of D in break-
ing the HRKPRF-security of SHACAL-2 with respect to ğœ™MAC is
SHACAL-2, ğœ™MAC,D] âˆ’ 1.
deï¬ned as Advhrkprf
C. Security requirements on message encoding
1) MTP-ME ensures in-order delivery: We require that
MTP-ME is EINT-secure (Fig. 8) with respect to the support
function SUPP deï¬ned in Fig. 23. SUPP enforces in-order
delivery for each userâ€™s sent messages, thus preventing uni-
directional reordering attacks, replays and message deletion. It
is formalised using a function ï¬nd(op, tr, label) that searches
a given transcript for a sent or recv entry that corresponds to
label, and also counts the number of valid entries encountered
prior to ï¬nding the target. For any label that corresponds to the
ğ‘sent-th valid sent-type entry in tru, the support function SUPP
checks that tru contains ğ‘recv = ğ‘sentâˆ’1 valid recv-type entries,
and that none of them contains the label itself. Here we rely
on each label being unique, which is true for MTP-ME as long
as it encodes at most 296 messages.20 Replays are prevented
by the search of entries received by u. The count from both
searches is used to ensure that there are no gaps between
the number of sent and received ciphertexts, thus preventing
deletion and reordering.21 As outlined in Section IV-B1, the
MTProto implementation of ME we studied allowed reordering
so it was not EINT-secure with respect to SUPP. The full
MTP-ME,SUPP(F) = 0 for any
version of this work shows that Adveint
F making at most 296 queries to Send.
2) Preï¬x uniqueness of MTP-ME: We require that payloads
produced by MTP-ME have distinct preï¬xes of size 256 bits
(independently for each user u âˆˆ {I, R}), as deï¬ned by the
security game in Fig. 24. The advantage of an adversary F in
breaking the UPREF-security of a message encoding scheme
ME,F]. Given the ï¬xed
ME is deï¬ned as Advupref
ME
preï¬x size, this notion cannot be satisï¬ed against unbounded
adversaries. Our MTP-ME scheme ensures unique preï¬xes using
the 96-bit counter seq_no that contains the number of messages
(F) = Pr[Gupref
20A limitation on number of queries is inherent as long as ï¬xed-length
sequence numbers are used.
21Note that aux is not used in SUPP or MTP-ME. It would be possible to
add time synchronisation using the timestamp captured in the msg_id ï¬eld
just as the current MTProto ME implementation does.
Authorized licensed use limited to: Tsinghua University. Downloaded on August 07,2022 at 12:21:42 UTC from IEEE Xplore.  Restrictions apply. 
100
ï¬nd(recv, tru, label)
ï¬nd(op, tr, label)
ğ‘op â† 0
For (op, ğ‘š, label(cid:48), aux) âˆˆ tr do
SUPP(u, tru, tru, label, aux)
(ğ‘recv, ğ‘šrecv) â†
If ğ‘šrecv â‰ âŠ¥ then return âŠ¥
(ğ‘sent, ğ‘šsent) â†
ï¬nd(sent, tru, label)