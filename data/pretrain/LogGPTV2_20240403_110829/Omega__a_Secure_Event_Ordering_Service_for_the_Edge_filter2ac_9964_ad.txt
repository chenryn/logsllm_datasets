6:
7:
END ATOMIC
8:
9: function GET(k)
(v, e) ← local kv.get (k)
10:
event id ← getId (omega.lastEventWithTag (k))
11:
hash val ← hash(k ⊕ v).
12:
if event id = hash val then
13:
14:
15:
16:
return error;
return v
else
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 11:36:47 UTC from IEEE Xplore.  Restrictions apply. 
496
of the OmegaKV is summarized in Algorithm 1.
To put a value on the OmegaKV, the client starts by creating
an identiﬁer for the put operation by hashing the concatenation
of the key and the value. Then it contacts Omega to serialize
the update operation with regard to other update operations
(in a serialization that respects causality). Finally, the server
replaces the old value of the key with the new one. The
event generated by Omega is stored locally with the update
value. This can be used subsequently to ensure that clients see
updates in the right order.
To perform the get operation, the server reads the value
and the associated event from the local key-value store and
queries Omega for the last event to be associated with the
target key. Then it uses the hash of the value that has been
safely stored by Omega and compares it with the hash of the
value returned by the untrusted code running on the fog node.
This allows the client to check that the untrusted zone has not
been compromised and that the value returned is, in fact, the
last value written on that key.
Finally, when the fog node ships the updates to the cloud,
these are shipped together with events generated by Omega.
This allows the cloud to apply the updates in the correct order
in the master replica (and in other fog nodes, if needed).
VII. EVALUATION
This Section is divided in two parts. First, we evaluate
Omega in isolation. The goal is to offer a better understanding
of the relative cost of the different components of the Omega
implementation. Second, we show the impact of using Omega
to secure a concrete service, namely OmegaKV. The goal is
to provide insights on the tradeoffs involved when executing
services securely on the cloud, insecurely on fog nodes, or
securely on fog nodes leveraging the services of Omega.
A. Experimental Setup
In our experiments, the fog node is a dedicated computer
with a 3.6GHz Intel i9-9900K CPU which has 16GB RAM
(this processor supports SGX). The fog node OS is Ubuntu
18.04.2 LTS 64bit with Linux kernel 5.0.8. We run the Intel
SGX SDK Linux 2.4 Release. The client machines are comput-
ers with 2.5GHz Intel i7-4710HQ CPU and 16GB RAM. Both
the clients and the fog node are deployed in our laboratory, in
the same network, emulating a 5G station communicating with
a terminal (i.e., a 1-hop communication1). Cloud services are
executed on a data center in London2, using Amazon Elastic
Compute Cloud (Amazon EC2) in t2.micro virtual machines
The Intel SGX SDK and the code for the enclave are in
C/C++. Omega was implemented in Java 11 and the Java
Native Interface (JNI) was used as a bridge between Java
and C++. For persistent storage we use the key-value store
1This has been tuned to be aligned with the expected latency of 5G networks
and future MEC networks [75].
2The datacenter was selected as the closest (in Round Trip Time (RTT))
to our lab. Our lab is located in Europe but not in the United Kingdom.
This setting captures many realistic scenarios where clients are diverted to
the closest datacenter in their region. The observed experimental latency is
consistent with latency values collected by others [76].
Fig. 5. Estimated optimal leaf size of the Merkle tree (vault of size 512).
Redis [65]. In the experiments we executed 5000 operations
and discarded the ﬁrst and the last 500 to avoid outliers.
B. Omega Conﬁguration and Performance
We ﬁrst discuss how to conﬁgure the Merkle tree used
by Omega since the performance of the service is highly
dependent on this conﬁguration. Then we provide an overview
for the performance of Omega using the selected conﬁguration.
1) Merkle Tree Conﬁguration: The Merkle tree used to
store events is used on most of the Omega operations. There-
fore, its proper tuning is key to the performance of the service.
To understand how to conﬁgure the Merkle tree it is important
to notice that any operation that involves checking/changing
the content of the Omega vault requires to perform a number
of computations that is a function of the size of the vault
but also on the size selected for the Merkle tree leafs. More
precisely, let x be the size of each tree leaf and VaultSize
be the maximum number of entries that the vault can store.
Any operation on the vault must compute the hash of the
affected leaf node and then the hashes of all inner nodes of
the tree. Computing the hash of the leaf node has a cost that
is linear with the leaf size. We denote this cost leafHash(x).
Since we have implemented the Merkle tree as a binary
tree, updating/checking an inner node involves hashing two
values. We denote the cost of computing the hash of an inner
node innerHash. The number of inner nodes that need to be
computed grows logarithmically with the size of the vault
and its exact value is log2( VaultSize
). Therefore, the formula
that captures the cost of performing operation on the vault is
leafHash(x) +innerHash ∗ log2( VaultSize
).
x
The formula above suggests that the optimal size of the leaf
nodes of the Merkle should be very close to 1, given that the
cost of hashing the leaf node grows linearly, while the cost
of hashing the inner nodes grows logarithmically. Figure 5
depicts the estimated cost of vault operation, on a vault of
size 512 when the size of leaf nodes is varied from 1 to 512
entries. Note that when the leaf size is 1, the height of the
Merkle tree is 9 and when the size of the leaf is 512 the entire
vault is stored in a single leaf. The values in this ﬁgure were
obtained using the formula above, that was fed with results
obtained experimentally for the parameters leafHash(x) and
innerHash. The values suggest that leaves should not be large;
in this case, for a vault size of 512, the formula suggests that
8 is the best leaf size.
Based on this observation, we decided to run multiple
experiments on the real system, where we measured the
x
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 11:36:47 UTC from IEEE Xplore.  Restrictions apply. 
497
updates to different shards can also be executed concurrently,
without blocking each other. Note also that the derivative
of the line is below 1; this is due to the overhead induced
by the synchronization required to enforce the serialization
guarantees offered by Omega.
In the second experiment, we measure the relative impact
of the latency introduced by the Omega’s implementation
in the client operation. Figure 8 shows how each individual
software component that is executed in the client critical path
contributes to the latency. This breakdown can be used to
estimate the performance of Omega in other networks. Since
the fog node is located one-hop away from the clients, the time
spent in the network is not the main contributor to the latency
observed by clients. The time lost from the Java layer to
enclave is also small (from 1ms to 2ms). The time lost doing
context switch is also considerably short, mainly because the
enclave keeps very little state (taking advantage of the Omega
Vault) and there is a small number of parameters passing in
and out of the enclave (as describe in Section V-F). Thus, the
main contributor to the latency are the cryptographic functions
executed in the client and in the enclave. In the client, 2ms–
2.5ms are required to compute and verify digital signatures.
On the server side, most of the time is also spent in the
processing digital signatures.
The observed latencies match the requirements of edge
applications. For instance, in vehicular applications, safety
application require warnings to be generated in less than
100ms [77], [78]; as depicted in Figure 8, creating an event
with Omega has a latency close to 5ms, which is considerably
below the 100ms threshold, allowing to create and deliver
multiple events to vehicles using Omega on an RSU/fog node
and still meet the deadline. Also, the overall connection time
of a vehicle with an RSU is tipically around 18-21s for a
vehicle moving at 120 km/h [79], [80], which allows a vehicle
to access other types of events such as congestion control,
driving conditions, curve speed, and others. The 5ms Omega
latency also matches the maximum tolerable delay for many
other edge applications, such as the value of ∼7ms required
for Virtual Reality gaming [81], [82] and the ∼10ms needed
for Augmented Reality apps [83].
C. Performance of the OmegaKV
We now measure the impact of using Omega to make other
services secure. For this purpose we compare the performance
of OmegaKV, our Omega-based key-value store for the fog,
with a similar non-secured service also running in the fog
node (denoted OmegaKV NoSGX), and with a version where
security is achieved by running the service on the cloud
(denoted CloudKV). All
implementations of the key-value
store have been developed in Java and use Redis [65] to
keep their state persistent. Also, all system use messages that
are cryptographically signed using our protocol described in
Section V-F. The major difference among the implementations
are that CloudKV and OmegaKV NoSGX do not use the
enclave (nor the Merkle tree used to implement the Omega
Fig. 6. Performance of the Merkle tree.
Fig. 7. Scalability of Omega’s createEvent implementation (1 to 16 threads).
performance of the Omega vault implementation with different
leaf sizes and different vault sizes. The results are depicted in
Figure 6. As it can be observed, the best results are obtained
for leaf sizes of 2 and 4 (in fact, the differences in performance
for these two values is not signiﬁcant) but quickly drops if
larger leaves are used. Therefore, in all other experiments, we
have used a leaf size of 2.
2) Executing Omega Operations: We now present
the
results from two experiments that aim at assessing the per-
formance of the Omega implementation, in particular of the
operations that are mainly executed in the enclave. We have
measured the performance of the createEvent operation, as this
is the most expensive of all operations provided by Omega and
involves updating the Omega vault.
In the ﬁrst experiment, we show that the performance of
Omega can scale as more threads are allocated to the service.
Figure 7 depicts the maximum number of operations per
second that our implementation can execute as the number
of threads increase. It can be seen that the throughput of the
system increases almost linearly up the 16 threads (the number
of available cores in the machine that we have used). This
is possible because cryptographic operations are performed in
parallel within the enclave and the Omega vault is sharded and
Fig. 8. Operation latency for createEvent.
498
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 11:36:47 UTC from IEEE Xplore.  Restrictions apply. 
Fig. 9. Access pattern throughput (writes/reads).
Fig. 11. Write operation latencies w/ and w/o SGX.
OmegaKV to offer latency values in the 5ms–30ms range
required by time-sensitive edge applications [4].
We also tested the performance of OmegaKV with different
data sizes up to 512 MB (this is the maximum object size
supported by Redis, our underlying persistent store). Results
are shown in Figure 11. For this experiment we compared
OmegaKV against OmegaKV NoSGX. It is visible that our
system follows the same latency as the traditional key-value
store. This happens because, with large ﬁles, the overhead of
the enclave and cryptographic operations becomes negligible
when compared with the data transfer costs. It should be noted
that OmegaKV transfers only one hash of the object to Omega;
the object with tens of megabytes is stored in Redis.
VIII. CONCLUSIONS
Fog computing can pave the way for the deployment of
novel
latency-sensitive applications for the edge, such as
augmented reality. However, in order to fulﬁll its potential, we
need to address the vulnerabilities that emerge when deploying
a large set of servers on many different locations that cannot
be physically secured with the same level of trust than cloud
premises. This paper makes a step in this direction by describ-
ing the design and implementation of a secure service that
can be executed on fog nodes in a secure manner leveraging
on the properties of trusted executions environments such as
Intel SGX. In particular, we have proposed Omega, an event
ordering service that can be used as a building block to build
higher level abstractions. With the dual purpose of illustrating
the use of Omega and of assessing its performance when
used in practice, we have also designed and implemented
OmegaKV, a causally consistent key-value store for the edge.
Our evaluation shows that, despite the costs incurred with the
use of the enclave, the use of Omega based applications can
still provide much smaller latency and higher throughput than
current cloud based solutions.
ACKNOWLEDGMENTS
This work was partially supported by the Fundac¸˜ao para a Ciˆencia e
Tecnologia (FCT) via project COSMOS (via the OE with ref. PTDC/EEI-
COM/29271/2017 and via the “Programa Operacional Regional de Lisboa na
sua componente FEDER” with ref. Lisboa-01-0145-FEDER-029271), Project
NG-STORAGE (PTDC/CCI-INF/32038/2017), project UIDB/ 50021/ 2020,
and by the European Commission under grant agreement number 830892
(SPARTA).
Fig. 10. Write operation latency of a fog node and cloud.
Vault), they make no effort to verify the integrity of stored
data, and they do not need to use JNI interface.
Figure 9 presents the maximum throughput that a client
can achieve using the three systems. In the CloudKV imple-
mentation, the latency to the data center severely affects the
throughput of the client; in our experiments the throughput of
a cloud-based implementation is roughly 25% of the fog-based
implementations. This was expected as one of the main moti-
vations for using fog-nodes is to reduce the latency observed
by clients. Interestingly, although the security mechanisms
that are used in the Omega implementation introduced some
amount of overhead (see the discussion in Section VII-B),
this overhead is partially diluted when Omega is just a part
of a larger system, that has many other sources of latency.
In our experiments, OmegaKV offers a throughput that is
approximately 18% smaller than the non-secured version of
the same service but that is, nevertheless, much higher than
the throughput supported by CloudKV.
Figure 10 compares the latency that a client experiences
when using the services OmegaKV, OmegaKV NoSGX, and
CloudKV. For a better understanding of the graph, we measure
the ping operation to calculate the round-trip time from the
client to the fog node and to the cloud, this is shown as
HealthTest line for the fog node and CloudHealthTest for the
cloud. As expected the client can perform operations with
much lower latency by using the fog node rather than using the
CloudKV services that are in a data center, a reduction from
36ms to 12ms, close to 67%. OmegaKV has higher latency
than OmegaKV NoSGX, due to the use of the enclave. In
absolute value we observe an increase in latency in the order
of 4ms, which is non-negligible but still signiﬁcantly smaller
than the latency introduced by wide-area links. This allows
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 11:36:47 UTC from IEEE Xplore.  Restrictions apply. 
499
REFERENCES
[1] M. Armbrust, A. Fox, R. Grifﬁth, A. D. Joseph, R. Katz, A. Konwinski,