Time
6h 15m
24h 45m
49h 30m
Table 2: Exhaustive search timing for is different sizes for
𝑀𝑄(𝑛, 𝑛) taken on Nvidia GTX 1080Ti GPU.
operations. Using bit-tracing attack, we recover 4,116 bits with 3
hours and 49 minutes of online observation. The faulty signatures
are processed offline on a separate machine to recover the key bits
2.
Note that the attack recovers up to 140 bits in any column of T
which is enough for a successful QuantumHammer attack. The
distribution of the bits in the 57 columns of T is given in Figure 9.
Some columns of T have been located in DRAM buffers that are
more flippy than others.
2The source code for QuantumHammer is made available at http://github.com/
VernamLab/QuantumHammer.
Figure 9: Bit-tracing attack recovers up to 140 key bits per
column of T in less than 4 hours of Rowhammer on a 2
GBytes DDR3 Samsung DRAM (M378B5773DH0-CH9).
𝑚
57
1 and 𝑃𝑘
(cid:7) = 4
(cid:7) =(cid:6) 197
Quadratic Steps:
In preparation for QuantumHammer, 𝑝𝑘
the Equation 3 using the coefficients from 𝑃𝑘
are generated by Equation 4 using 𝑝𝑘
generated system of equations, we focused on(cid:6) 𝑣
3 (𝑖, 𝑗) were generated by
2 . MQ systems
3 (𝑖, 𝑗) equations. To solve the
columns with the highest number of recovered bits: columns 5, 23,
7 and 21 with 140, 135, 133 and 131 recovered bits, respectively. In
every step of quadratic and linear steps, we recover a column of T .
Experimental results of quadratic steps are given in Table 3.
It is important to note that, in the first step, we recover the 5𝑡ℎ
column of T , by solving a 𝑀𝑄(57, 57) system reduced from the un-
derdetermined 𝑀𝑄(197, 57) thanks to 140 recovered bits obtained
by the bit-tracing attack. Without it, it would not be possible to
recover the rest of the 5𝑡ℎ column. The system is solved by ex-
haustive search in roughly 49 hours on i7 Intel CPU with Nvidia
GTX 1080 Ti GPU. In Table 2 exhaustive search timing for different
sizes of 𝑀𝑄(𝑛, 𝑛) is given. We used the GPU implementation of
[7] compiled using the Nvidia CUDA 10.0 framework. The offline
exhaustive search can be trivially sped up by employing multiple
GPUs since the search is fully parallelizable.
In the second step, we targeted 23𝑟𝑑 column with the 135 bits
recovered bits from bit-tracing. With these 135 bits, the system
starts out as 𝑀𝑄(62, 57). Next, we insert the values obtained from
the 5𝑡ℎ column to reduce the complexity to 𝑀𝑄(5, 57). We can
instantly solve this system via exhaustive search. At this point, by
inserting the recovered bits in the first two steps, we reduced the
remaining equations into (over-defined) linear systems only.
Linear Steps:
In the quadratic steps, we recovered 4 columns of T . Inserting these
values into remaining equations will give us an under determined
𝑀𝐿(197, 57) system. We end up with 228 linear equations with 197
unknowns which can be solved via Gaussian elimination. Even
though we can generate more linear equations by using more bits
of T previously recovered by bit-tracing, we do not need any extra
equations to solve the system. In 53 steps, all the remaining columns
of T are recovered as summarized in Table 4.
140135133131510152025303540455055Column number of T1975750100150Bits recovered per col of T19757Attack Instance - 3h 49mHighest - Col 52nd Highest - Col 233rd Highest - Col 74th Highest - Col 21Step Target
Col
1
2
3
4
5
23
7
21
Num.
of
Rec.
bits
140
135
133
131
Insrtd
Col
Equation
System
Linear Part
Complexity
-
5
5
23
5
23
7
-
-
B5,23(197, 135) 𝑀𝐿(62, 57)
B5,7(197, 133)
𝑀𝐿(64, 57)
B23,7(197, 133) 𝑀𝐿(64, 57)
B5,21(197, 131) 𝑀𝐿(66, 57)
B23,21(197, 131) 𝑀𝐿(66, 57)
B7,21(197, 131) 𝑀𝐿(66, 57)
Quadratic Part
ML System
Linear
Unk
Eqns
-
57
114
Equation
Complexity
System
A5(140) 𝑀𝑄(57, 57)
-
62 A23(135) 𝑀𝑄(62, 57)
64 A7(133) 𝑀𝑄(64, 57)
MQ System
Unk
Quad
Eqns
57
5
57
Overall
Complexity
57 𝑀𝑄(57, 57)
62 𝑀𝑄(5, 57)
64 𝑀𝐿(64, 114)
171
66 A21(131) 𝑀𝑄(66, 57)
57
66 𝑀𝐿(66, 171)
Table 3: Quadratic steps in our experimental QuantumHammer on LUOV-7-57-197. In every step, table lists the targeted
column of T , number of recovered bits during bit-tracing, size of ML system obtained after inserting previously recovered
columns, complexity of the solution for the linear part, number of linear equations and unknowns, parameters for the qua-
dratic part, and the complexity of the overall system after using ML to reduce the unknowns in quadratic part.
Step
Nmbr
Target
Col
5
6
...
1
2
...
57
57
Inserted
Col
5
23
7
21
5
23
7
21
5
23
7
21
Linear Part
Equation
Equivalent
System
System
B5,1(197, 0)
𝑀𝐿(197, 57)
B23,1(197, 0) 𝑀𝐿(197, 57)
B7,1(197, 0)
𝑀𝐿(197, 57)
B21,1(197, 0) 𝑀𝐿(197, 57)
B5,2(197, 0)
𝑀𝐿(197, 57)
B23,2(197, 0) 𝑀𝐿(197, 57)
B7,2(197, 0)
𝑀𝐿(197, 57)
B21,2(197, 0) 𝑀𝐿(197, 57)
B5,57(197, 0) 𝑀𝐿(197, 57)
B23,57(197, 0) 𝑀𝐿(197, 57)
B7,57(197, 0) 𝑀𝐿(197, 57)
B21,57(197, 0) 𝑀𝐿(197, 57)
ML System
Linear Equations Unknowns
228
228
...
228
197
197
...
197
Overall
Complexity
𝑀𝐿(197, 228)
𝑀𝐿(197, 228)
...
𝑀𝐿(197, 228)
Table 4: Linear steps in our experimental QuantumHammer on LUOV-7-57-197. In every step, table lists the targeted column
of T , inserted columns used to generate ML system, and resultant equation systems, the size of the generated ML systems, and
the number of equations and unknowns in the overall linear system and overall complexity are given.
6 COUNTERMEASURES
The effectiveness of QuantumHammer requires us to consider
practical countermeasures at various levels:
Preventing Rowhammer: The most effective solution to prevent
any Rowhammer fault-injection attack is to implement stronger
isolation, such as using dedicated instances for any sensitive pro-
cesses. If isolation is not possible, an effective alternative approach
to reduce the impact of Rowhammer is increasing the DRAM row
refresh rate. DDR3 and DDR4 refresh each row at least every 64 ms.
That said many systems permit the refresh rates at 32 or 16 ms for
better memory stability.
Online Detection of Rowhammer: One may also seek to employ
active countermeasures for online detection of Rowhammer. For
this, Hardware Performance Counters (HPCs) can be used to moni-
tor counters like cache hits and cache misses to detect Rowhammer.
Suppressing Faulty Signatures: Another way to counter faults
in the signature schemes is to verify the signatures at sender side
before sending it but that will involve additional processing. A
faster approach can be to repeat the final linear transformation
stage of the signing operation with an independently generated T
and check if the signatures are identical. Clearly, in this case one
must ensure that the checking mechanism itself does not become a
target itself.
7 DISCUSSION
The first algebraic attack targeting UOV type schemes which does
not require any physical access is Reconciliation attack introduced
by Ding et al. [14]. The attack aims to invert the public map. De-
composing the public map P into the multiplication of a series
of specific linear transformations allows the attacker to recover
every transformation one-by-one by exhaustive search algorithms
such as F4/F5 or FXL. The result is a purely algebraic attack that
significantly reduces the assumed security margin of LUOV.
In the Divide-and-Conquer Attack, we follow a similar approach
in the sense that we exploit one of the innovations of LUOV, i.e. the