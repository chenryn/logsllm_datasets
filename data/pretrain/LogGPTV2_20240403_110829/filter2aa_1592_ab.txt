Manifest
.NET Assembly
(.exe or .dll)
ALEXANDRE BORGES – MALWARE AND SECURITY RESEARCHER
DEF CON USA 2019
23
PE Header
Native Code / 
Data
CLR Header
CLR Data
(ILcode, metadata, 
managed resources)
DOS Header
PE Header
Data Directories
(size and location of CLR header)
Section Headers
.text
(includes MSIL and metadata)
.idata
.data
Remaining sections
DEF CON USA 2019
24
 CLR Header is represented by a structure named IMAGE_COR20_HEADER (defined 
in CorHdr.h). 
 The CLR header + data holds information such as: 
 Metadata information (size and RVA).
 Token of the entry point of the image file (EntryPointTokenField).
 Array of v-table fixup Table (used when a managed method is called from an 
unmanaged code). Each entry of a v-table holds a token of the target method.
 Resource information (size and RVA)
 Flags indicating:
 32 bits only. 
 strong assembly
 entrypoint of a native code.
 Managed resources in contained into .text section (and not .rsrc section). 
ALEXANDRE BORGES – MALWARE AND SECURITY RESEARCHER
DEF CON USA 2019
25
 Metadata is composed by tables such as:
 Definition tables: ModuleDef, TypeDef, MethodDef, FieldDef, ParamDef, 
PropertyDef and EventDef
 Reference tables: AssemblyRef, ModuleRef, TypeRef and MemberRef. 
 Manifest tables: AssemblyDef, FileDef, ManifestResourceDef and 
ExportedTypesDef.
 Most malicious .NET malware samples have: 
 Used code manipulation (encryption/decryption) in .ctor( )/.cctor( )/Finalize( )
 Called unmanaged functions from DLLs using P/Invoke. 
 Used COM components (very usual).
 Even a trivial .NET malware, the managed code can be small.  (ILDasm.exe 
View  Statistics)
ALEXANDRE BORGES – MALWARE AND SECURITY RESEARCHER
DEF CON USA 2019
26
 ILDasm  View  MetaInfo  Show! menu: 
ALEXANDRE BORGES – MALWARE AND SECURITY RESEARCHER
DEF CON USA 2019
27
 ILDasm.exe  View  Statistics
ALEXANDRE BORGES – MALWARE AND SECURITY RESEARCHER
DEF CON USA 2019
28
 Metadata describes all declared or referenced data in a module such as classes, 
members, attributes, properties and relationships. 
 Metadata is organized as a relational database using cross-references and making 
possible to find what class each method comes from. 
 Metadata are represented by named streams, which are classified as metadata 
heaps and metadata tables.
slot 1: Class A -- methods at slot 1
slot 2: Class B -- methods at slot 3
slot 3: Class C -- methods at slot 5
slot 4: Class D -- methods at slot 6
slot 5: Class E -- methods at slot 8
slot 1: Method 1 - Classe A 
slot 2: Method 2 - Classe A 
slot 3: Method 1 - Classe B 
slot 4: Method 2 - Classe B 
slot 5: Method 1 - Classe C 
slot 6: Method 1 - Classe D 
slot 7: Method 2 - Classe D 
slot 8: Method 1 - Classe E
ALEXANDRE BORGES – MALWARE AND SECURITY RESEARCHER
DEF CON USA 2019
29
 Metadata heaps: 
 GUID heap: contains objects of size equal to 16 bytes.
 String heap: contains strings. 
 Blog heap: contains arbitrary binary objects aligned on 4-byte boundary. 
 There can be 6 named streams: 
 #GUID: contains global unique identifiers. 
 #Strings: contains names of classes, methods, and so on. 
 #US: contains user defined strings. 
 #~: contains compressed metadata stream. 
 #-: contains uncompressed metadata stream. 
 Blob: contains metadata from binary objects. 
 An important note: compressed and uncompressed named streams are 
mutually exclusive. 
 Metadata heaps:
 The schema defines the metadata tables by usings a descriptor. 
 There are more than 40 metadata tables.
ALEXANDRE BORGES – MALWARE AND SECURITY RESEARCHER
DEF CON USA 2019
30
 RID (record identifiers) are used as row indexes in metadata tables.
 Tokens determines which metadata tables are been referred.
 Tokens have 4 bytes, which the first byte determines the metadata table and the 
three remaining bytes are the RID. 
 Unfortunately, tokens don’t cover all table (auxiliary tables, which are hardcoded). 
0(0x0): Module
1(0x1): TypeRef
2(0x2): TypeDef
3(0x3): FieldPtr
4(0x4): Field
5(0x5): MethodPtr
6(0x6): Method
7(0x7): ParamPtr
8(0x8): Param
9(0x9): InterfaceImpl
10(0xa): MemberRef
11(0xb): Constant
12(0xc): CustomAttribute
13(0xd): FieldMarshal
14(0xe): DeclSecurity
15(0xf): ClassLayout
16(0x10): FieldLayout
17(0x11): StandAloneSig
18(0x12): EventMap
19(0x13): EventPtr
20(0x14): Event
21(0x15): PropertyMap
22(0x16): PropertyPtr
23(0x17): Property
24(0x18): MethodSemantics
25(0x19): MethodImpl
26(0x1a): ModuleRef
27(0x1b): TypeSpec
28(0x1c): ImplMap
29(0x1d): FieldRVA
30(0x1e): ENCLog
31(0x1f): ENCMap
32(0x20): Assembly
33(0x21): AssemblyProcessor
34(0x22): AssemblyOS
35(0x23): AssemblyRef
36(0x24): AssemblyRefProcessor
37(0x25): AssemblyRefOS
38(0x26): File
39(0x27): ExportedType
40(0x28): ManifestResource
41(0x29): NestedClass
42(0x2a): GenericParam
43(0x2b): MethodSpec
44(0x2c): GenericParamConstraint
ALEXANDRE BORGES – MALWARE AND SECURITY RESEARCHER
DEF CON USA 2019
31
 ILDasm.exe  View  Statistics
ALEXANDRE BORGES – MALWARE AND SECURITY RESEARCHER
DEF CON USA 2019
32
 IDAasm  View  MetaInfo  RawHeap
 ILDasm  View  MetaInfo  Show! 
ALEXANDRE BORGES – MALWARE AND SECURITY RESEARCHER
DEF CON USA 2019
33
 The JIT compiler stores the native instructions in the memory, which it is 
discarded after the application terminates. Eventually, we can perform a 
memory dump to examine this code. 
 Check the installed .NET version: 
 Subdirectories under C:\Windows\Microsoft.NET
 clrver.exe
 clrver.exe -all
 Programming directly in IL (Intermediate Language) can be interesting because: 
 IL is stack based, so we don’t find any instruction related to register 
manipulation. 
 It is too easy to check, reverse it (ILDasm.exe) and make “customizations”.
 Ngen.exe can be used to compile IL instructions to native code.
 Of course, CLR checks some details (CLR version, CPU type, Windows 
version, and so on) before executing it.
 The compiled application can be slower. 
 Eventually, malware threats have attacked the .NET runtime to subvert the 
system. 
ALEXANDRE BORGES – MALWARE AND SECURITY RESEARCHER
DEF CON USA 2019
34
 In .NET applications:
 .NET Assembly
 managed .NET application  (modules) + class libraries + resources files 
 In malware samples,  we usually find that resources are encrypted 
binaries and DLLs. 
 contains information such as version, publisher, culture and exported 
files. 
 Remember that the application can download assembly files from a URL 
(codeBase element). 
 .NET malware have used multi-file assemblies, partitioning types over 
different files. Unfortunately, it is only possible to create multfile 
assembly in the command line. 
 Few malware authors have create .NET malware containing different 
types: such as C# and VB in the same assembly.
 The manifest also holds metadata tables containing the names of files that are 
part of the assembly: AssemblyDef, FileDef, ManifestResourceDef and 
ExportedTypesDef. 
ALEXANDRE BORGES – MALWARE AND SECURITY RESEARCHER
DEF CON USA 2019
35
 Assemblies can be classified as:
 private: it is specific of an application and deployed at same directory. 
 shared: it is shared and used by other applications. 
 All memory requested by the assembly is really “managed” by CLR, which 
“interfaces” this request to the operating system. 
 Therefore, the CLR is able to control the access to different objects in the 
memory between the application domains (like processes), which are 
representing the code of assemblies. 
 Of course, there are permited methods to cross-access requests between 
application domains through proxy objects by marshalling objects either by value 
or by reference. 
 As we’ve mentioned previously, manifest is a kind of file to “wrap up everything”, 
describing modules, resources and other details of the assembly. 
ALEXANDRE BORGES – MALWARE AND SECURITY RESEARCHER
DEF CON USA 2019
36
 Compile multi-file .NET malware is pretty easy:
 csc.exe /t:module hooking.cs
 csc.exe /t:module injection.cs
 csc.exe /out:malwarelib.dll /t:library /addmodule:hooking.netmodule 
/addmodule:injection.netmodule  Defcon.cs
 In this case, we have a multi-file assembly:
 includes a managed module named hooking.netmodule and 
injection.netmodule. The output file is a DLL named malwarelib.dll
 a manifest file wrapping everything. 
 This compiling command add the hooking.mod file to the FileDef manifest 
metadata table and the its exported types to the ExportedTypeDef manifest 
metadata table. 
 To check: ILDasm  View  MetaInfo  Show! and look for the FileDef and 
ExportedTypeDef tables.
ALEXANDRE BORGES – MALWARE AND SECURITY RESEARCHER
DEF CON USA 2019
37
Native modules referred by the 
assembly. The module name is 
in the ModuleRef.
External assemblies that 
referred by the assembly
(AssemblyRef table).
Manifest
Used when a strong 
assembly is specified.
ALEXANDRE BORGES – MALWARE AND SECURITY RESEARCHER
DEF CON USA 2019
38
Assembly name
Custom attributes used by the compiler 
(or tools) and defined in the 
CustomAttribute metadata table (0x0C).
CALG_SHA1
ALEXANDRE BORGES – MALWARE AND SECURITY RESEARCHER
DEF CON USA 2019
39
Managed Resources 
(ManifestResource 
metadata table)
other 
attributes
Globally unique 
identifier.
ALEXANDRE BORGES – MALWARE AND SECURITY RESEARCHER
DEF CON USA 2019
40
 Of course, we could have a “big malware module” to use in projects:  
 al.exe /out: BigMalwareLib.dll /t:library hooking. netmodule injection.
netmodule
 csc.exe /t:module /r:BigMalwareLib.dll Defcon.cs
 al /out:Defcon.exe /t:exe /main:Defcon.Main Defcon.netmodule
 In this case, the __EntryPoint() global function will contain the Defcon::Main( ) 
function call (check the IL code to confirm it). 
 Finally, using csc.exe /resource makes simple to add resources (generated by 
resgen.exe , for example). It updates the the ManifestResourceDef table. 
 It is not necessary to mention that malware’s authors usually don’t write strong 
assemblies, which as signed with the private/public key pair from the publisher. 
Unless that this key pair has been stolen... 
 csc.exe /out:TestProgram.exe /t:exe Program.cs
 sn.exe -k AlexandreBorges.snk
 sn.exe -p AlexandreBorges.snk AlexandreBorges.PublicKey sha256
 Sn.exe -tp AlexandreBorges.PublicKey
 csc.exe /out:TestProgram.exe /t:exe /keyfile:AlexandreBorges.snk Program.cs
ALEXANDRE BORGES – MALWARE AND SECURITY RESEARCHER
DEF CON USA 2019
41
Public key generated by: 
sn.exe -p AlexandreBorges.snk 
AlexandreBorges.PublicKey 
sha256
ALEXANDRE BORGES – MALWARE AND SECURITY RESEARCHER
DEF CON USA 2019
42
 Once the system is compromised through a native malware and we have access to 
the system as administrator, so it is possible to copy our .NET assembly to the 
Global Assembly Cache (GAC). The Registry is not changed. 
 Once a malicious .NET assembly (first stage, as a resource library) is copied to GAC, 
so it can be accessed by other assemblies. 
 Thus, other malicious .NET malware samples (second stage) can access methods 
and types from the first stage.   
 Only strong assemblies (signed) can be copied to the GAC (located at 
C:\Windows\Microsoft.NET\assembly) by using GACUtil.exe /i command.  
 Futhermore, including /r option integrates the assembly with the Windows install 
engine. 
 Unfortunately, the GACUtil.exe is not available in home-user systems, but it is 
possible to use the MSI to install the malware threat into the GAC. 
 At end, it is still feasible to using delay signing, which is a partial signing only using 
the public key. Therefore, private key is not used (and there isn’t real protection).
ALEXANDRE BORGES – MALWARE AND SECURITY RESEARCHER
DEF CON USA 2019
43
 The delay signing allows that the malicious assembly to be installed into the GAC 
and, worse, other assemblies can make reference to it. 
 csc.exe /out:malware.dll /t:exe Program.cs