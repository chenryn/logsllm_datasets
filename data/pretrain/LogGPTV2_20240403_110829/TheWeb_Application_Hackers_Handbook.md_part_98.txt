map with all requests passing through the proxy. It also adds items that have
cc2200..iinndddd 776699 88//1199//22001111 1122::2211::0088 PPMM
Stuttard c20.indd V3 - 08/16/2011 Page 770
770 Chapter 20 n A Web Application Hacker’s Toolkit
been identifi ed based on the contents of responses passing through the proxy
(by parsing links, forms, scripts, and so on). After you have manually mapped
the application’s visible content using your browser, you may additionally use
the Spider and Content Discovery functions to actively probe the application for
additional content. The outputs from these tools are also added to the site map.
Recon and analysis
Web
browser
Intercepting
proxy
passive
spidering active
Spider
spidering
Proxy history Site map
active Content
discovery discovery
attack surface
passive Vulnerability detection
scanning and exploitation
confirm some
vulnerabilities
in browser
Token
Scanner Repeater Fuzzer
analyzer
Vulnerabilities
Figure 20-14: A typical work flow for using an integrated testing suite
When you have mapped the application’s content and functionality, you can
assess its attack surface. This is the set of functionality and requests that war-
rants closer inspection in an attempt to fi nd and exploit vulnerabilities.
When testing for vulnerabilities, you typically select items from the proxy
interception window, proxy history, or site map, and send these to other tools
within the suite to perform specifi c tasks. As we have described, you can use the
fuzzing tool to probe for input-based vulnerabilities and deliver other attacks
such as harvesting sensitive information. You can use the vulnerability scan-
ner to automatically check for common vulnerabilities, using both passive and
cc2200..iinndddd 777700 88//1199//22001111 1122::2211::0099 PPMM
Stuttard c20.indd V3 - 08/16/2011 Page 771
Chapter 20 n A Web Application Hacker’s Toolkit 771
active techniques. You can use the token analyzer tool to test the randomness
properties of session cookies and other tokens. And you can use the request
repeater to modify and reissue an individual request repeatedly to probe for
vulnerabilities or exploit bugs you have already discovered. Often you will pass
individual items back and forth between these different tools. For example,
you may select an interesting item from a fuzzing attack, or an issue reported
by the vulnerability scanner, and pass this to the request repeater to verify the
vulnerability or refi ne an exploit.
For many types of vulnerabilities, you will typically need to go back to your
browser to investigate an issue further, confi rm whether an apparent vulnerabil-
ity is genuine, or test a working exploit. For example, having found a cross-site
scripting fl aw using the vulnerability scanner or request repeater, you may paste
the resulting URL back into your browser to confi rm that your proof-of-concept
exploit is executed. When testing possible access control bugs, you may view
the results of particular requests in your current browser session to confi rm the
results within a specifi c user context. If you discover a SQL injection fl aw that
can be used to extract large amounts of information, you might revert to your
browser as the most useful location to display the results.
You should not regard the work fl ow described here as in any way rigid or
restrictive. In many situations, you may test for bugs by entering unexpected
input directly into your browser or into the proxy interception window. Some
bugs may be immediately evident in requests and responses without the need to
involve any more attack-focused tools. You may bring in other tools for particular
purposes. You also may combine the components of the testing suite in innova-
tive ways that are not described here and maybe were not even envisioned by
the tool’s author. Integrated testing suites are hugely powerful creations, with
numerous interrelated features. The more creative you can be when using them,
the more likely you are to discover the most obscure vulnerabilities!
Alternatives to the Intercepting Proxy
One item that you should always have available in your toolkit is an alternative
to the usual proxy-based tools for the rare situations in which they cannot be
used. Such situations typically arise when you need to use some nonstandard
authentication method to access the application, either directly or via a corporate
proxy, or where the application uses an unusual client SSL certifi cate or browser
extension. In these cases, because an intercepting proxy interrupts the HTTP
connection between client and server, you may fi nd that the tool prevents you
from using some or all of the application’s functionality.
The standard alternative approach in these situations is to use an in-browser
tool to monitor and manipulate the HTTP requests generated by your browser.
It remains the case that everything that occurs on the client, and all data sub-
mitted to the server, is in principle under your full control. If you so desired,
you could write your own fully customized browser to perform any task you
cc2200..iinndddd 777711 88//1199//22001111 1122::2211::0099 PPMM
Stuttard c20.indd V3 - 08/16/2011 Page 772
772 Chapter 20 n A Web Application Hacker’s Toolkit
required. What these browser extensions do is provide a quick and easy way to
instrument the functionality of a standard browser without interfering with the
network-layer communications between the browser and server. This approach
therefore enables you to submit arbitrary requests to the application while
allowing the browser to use its normal means of communicating with the
problematic application.
Numerous extensions are available for both Internet Explorer and Firefox
that implement broadly similar functionality. We will illustrate one example
of each. We recommend that you experiment with various options to fi nd the
one that best suits you.
You should note that the functionality of the existing browser extensions is
very limited in comparison to the main tool suites. They do not perform any
spidering, fuzzing, or vulnerability scanning, and you are restricted to working
completely manually. Nevertheless, in situations where you are forced to use
them, they will enable you to perform a comprehensive attack on your target
that would not be possible using only a standard browser.
Tamper Data
Tamper Data, shown in Figure 20-15, is an extension to the Firefox browser.
Anytime you submit a form, Tamper Data displays a pop-up showing all the
request details, including HTTP headers and parameters, which you can view
and modify.
Figure 20-15: Tamper Data lets you modify HTTP request details within Firefox
TamperIE
TamperIE, shown in Figure 20-16, implements essentially the same functionality
within the Internet Explorer browser as Tamper Data does on Firefox.
cc2200..iinndddd 777722 88//1199//22001111 1122::2211::0099 PPMM
Stuttard c20.indd V3 - 08/16/2011 Page 773
Chapter 20 n A Web Application Hacker’s Toolkit 773
Figure 20-16: TamperIE lets you modify HTTP request details
within Internet Explorer
Standalone Vulnerability Scanners
A number of different tools exist for performing completely automated vulner-
ability scans of web applications. These scanners have the benefi t of being able
to test a large amount of functionality in a relatively short time. In a typical
application they often can identify a variety of important vulnerabilities.
Standalone web application vulnerability scanners automate several of the
techniques we have described in this book, including application spidering,
discovery of default and common content, and probing for common vulner-
abilities. Having mapped the application’s content, the scanner works through
its functionality, submitting a range of test strings within each parameter
of each request, and analyzes the application’s responses for signatures of
common vulnerabilities. The scanner produces a report describing each of
the vulnerabilities it has discovered. This report usually includes the specifi c
request and response that the application used to diagnose each reported
vulnerability, enabling a knowledgeable user to manually investigate and
confi rm the bug’s existence.
A key requirement when you are deciding whether and when to use a
vulnerability scanner is to understand the inherent strengths and weak-
nesses of these types of tools and the challenges that need to be addressed
in the course of developing them. These considerations also affect how you
can effectively make use of an automated scanner and how to interpret and
rely on its results.
cc2200..iinndddd 777733 88//1199//22001111 1122::2211::0099 PPMM
Stuttard c20.indd V3 - 08/16/2011 Page 774
774 Chapter 20 n A Web Application Hacker’s Toolkit
Vulnerabilities Detected by Scanners
Several categories of common vulnerabilities can be detected by scanners with
a degree of reliability. These are vulnerabilities with a fairly standard signature.
In some cases, the signature exists within the application’s normal requests and
responses. In other cases, the scanner sends a crafted request designed to trig-
ger the signature if the vulnerability is present. If the signature appears in the
application’s response to the request, the scanner infers that the vulnerability
is present.
Here are some examples of vulnerabilities that can be detected in this way:
n Refl ected cross-site scripting vulnerabilities arise when user-supplied input
is echoed in the application’s responses without appropriate sanitization.
Automated scanners typically send test strings containing HTML markup
and search the responses for these strings, enabling them to detect many
of these fl aws.
n Some SQL injection vulnerabilities can be detected via a signature. For
example, submitting a single quotation mark may result in an ODBC error
message, or submitting the string ‘; waitfor delay ‘0:0:30’-- may
result in a time delay.
n Some path traversal vulnerabilities can be detected by submitting a tra-
versal sequence targeting a known fi le such as win.ini or /etc/passwd
and searching the response for the appearance of this fi le.
n Some command injection vulnerabilities can be detected by injecting a
command that causes a time delay or echoes a specifi c string into the
application’s response.
n Straightforward directory listings can be identifi ed by requesting the
directory path and looking for a response containing text that looks like
a directory listing.
n Vulnerabilities such as cleartext password submission, liberally scoped
cookies, and forms with autocomplete enabled can be reliably detected
by reviewing the normal requests and responses the application makes.
n Items not linked from the main published content, such as backup fi les
and source fi les, can often be discovered by requesting each enumerated
resource with a different fi le extension.
In many of these cases, some instances of the same category of vulnerability
cannot be reliably detected using a standard attack string and signature. For
example, with many input-based vulnerabilities, the application implements some
rudimentary input validation that can be circumvented using crafted input. The
usual attack strings may be blocked or sanitized; however, a skilled attacker can
probe the input validation in place and discover a bypass to it. In other cases,
cc2200..iinndddd 777744 88//1199//22001111 1122::2211::0099 PPMM
Stuttard c20.indd V3 - 08/16/2011 Page 775
Chapter 20 n A Web Application Hacker’s Toolkit 775
a vulnerability may be triggered by standard strings but may not result in the
expected signature. For example, many SQL injection attacks do not result in any
data or error messages being returned to the user, and a path traversal vulner-
ability may not result in the contents of the targeted fi le being directly returned
in the application’s response. In some of these cases, a sophisticated scanner may
still be able to identify the vulnerability, or at least note some anomalous behavior
for manual investigation, but this is not feasible in all cases.
Furthermore, several important categories of vulnerabilities do not have a stan-
dard signature and cannot be probed for using a standard set of attack strings.
In general, automated scanners are ineffective at discovering defects of this kind.
Here are some examples of vulnerabilities that scanners cannot reliably detect:
n Broken access controls, which enable a user to access other users’ data,
or a low-privileged user to access administrative functionality. A scan-
ner does not understand the access control requirements relevant to the
application, nor can it assess the signifi cance of the different functions
and data it discovers using a particular user account.
n Attacks that involve modifying a parameter’s value in a way that has
meaning within the application — for example, a hidden fi eld representing
the price of a purchased item or the status of an order. A scanner does not
understand the meaning that any parameter has within the application’s
functionality.
n Other logic fl aws, such as beating a transaction limit using a negative
value, or bypassing a stage of an account recovery process by omitting a
key request parameter.
n Vulnerabilities in the design of application functionality, such as weak
password quality rules, the ability to enumerate usernames from login
failure messages, and easily guessable forgotten-password hints.
n Session hijacking attacks in which a sequence can be detected in the appli-
cation’s session tokens, enabling an attacker to masquerade as other users.
Even if a scanner can recognize that a particular parameter has a predict-
able value across successive logins, it will not understand the signifi cance
of the different content that results from modifying that parameter.
n Leakage of sensitive information such as listings of usernames and logs
containing session tokens.
Some vulnerability scanners attempt to check for some of these vulnerabilities.
For example, some scanners attempt to locate access control bugs by logging
into an application in two different user contexts and trying to identify data
and functions that one user can access without proper authorization. In the
authors’ experience, checks such as these typically generate a huge number of
false positive and false negative results.
cc2200..iinndddd 777755 88//1199//22001111 1122::2211::1100 PPMM
Stuttard c20.indd V3 - 08/16/2011 Page 776
776 Chapter 20 n A Web Application Hacker’s Toolkit
Within the previous two listings of vulnerabilities, each list contains defects
that may be classifi ed as low-hanging fruit — those that can be easily detected
and exploited by an attacker with modest skills. Hence, although an automated
scanner will often detect a decent proportion of the low-hanging fruit within
an application, it will also typically miss a signifi cant number of these prob-
lems — including some low-hanging fruit that any manual attack would detect!
Getting a clean bill of health from an automated scanner never provides any
solid assurance that the application does not contain some serious vulnerabilities
that can be easily found and exploited.
It is also fair to say that in the more security-critical applications that cur-
rently exist, which have been subjected to more stringent security requirements
and testing, the vulnerabilities that remain tend to be those appearing on the
second list, rather than the fi rst.
Inherent Limitations of Scanners
The best vulnerability scanners on the market were designed and implemented
by experts who have given serious thought to the possible ways in which all
kinds of web application vulnerabilities can be detected. It is no accident that
the resulting scanners remain unable to reliably detect many categories of vul-
nerabilities. A fully automated approach to web application testing presents
various inherent barriers. These barriers can be effectively addressed only by
systems with full-blown artifi cial intelligence engines, going far beyond the
capabilities of today’s scanners.
Every Web Application Is Different
Web applications differ starkly from the domain of networks and infrastruc-
tures, in which a typical installation employs off-the-shelf products in more
or less standard confi gurations. In the case of network infrastructure, it is
possible in principle to construct in advance a database of all possible targets
and create a tool to probe for every associated defect. This is not possible
with customized web applications, so any effective scanner must expect the
unexpected.
Scanners Operate on Syntax
Computers can easily analyze the syntactic content of application responses
and can recognize common error messages, HTTP status codes, and user-
supplied data being copied into web pages. However, today’s scanners cannot
understand the semantic meaning of this content, nor can they make norma-
tive judgments on the basis of this meaning. For example, in a function that
updates a shopping cart, a scanner simply sees numerous parameters being
cc2200..iinndddd 777766 88//1199//22001111 1122::2211::1100 PPMM
Stuttard c20.indd V3 - 08/16/2011 Page 777
Chapter 20 n A Web Application Hacker’s Toolkit 777
submitted. It doesn’t know that one of these parameters signifi es a quantity
and another signifi es a price. Furthermore, it doesn’t know that being able to
modify an order’s quantity is inconsequential, whereas being able to modify
its price represents a security fl aw.
Scanners Do Not Improvise
Many web applications use nonstandard mechanisms to handle sessions and
navigation and to transmit and handle data, such as in the structure of the
query string, cookies, or other parameters. A human being may quickly notice
and deconstruct the unusual mechanism, but a computer will continue follow-
ing the standard rules it has been given. Furthermore, many attacks against
web applications require some improvisation, such as to circumvent partially
effective input fi lters or to exploit several different aspects of the application’s
behavior that collectively leave it open to attack. Scanners typically miss these
kinds of attacks.
Scanners Are Not Intuitive
Computers do not have intuition about how best to proceed. The approach of
today’s scanners is largely to attempt every attack against every function. This
imposes a practical limit on the variety of checks that can be performed and the
ways in which these can be combined. This approach overlooks vulnerabilities
in many cases:
n Some attacks involve submitting crafted input at one or more steps of a
multistage process and walking through the rest of the process to observe
the results.
n Some attacks involve changing the sequence of steps in which the applica-
tion expects a process to be performed.
n Some attacks involve changing the value of multiple parameters in crafted
ways. For example, an XSS attack may require a specifi c value to be placed
into one parameter to cause an error message, and an XSS payload to be