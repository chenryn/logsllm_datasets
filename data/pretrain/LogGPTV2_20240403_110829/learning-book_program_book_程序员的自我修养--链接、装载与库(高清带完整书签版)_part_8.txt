·线程主动放弃时间片。
因此，在不可抢占线程执行的时候，有一个显著的特点，那就是线程调度的时机是确定
的，线程调度只会发生在线程主动放弃执行或线程等待某事件的时候，这样可以避免一些因
为抢占式线程里调度时机不确定面产生的间题（见下一节：线程安全），但即使如此，非抢
占式线程在今日已经十分少见。
程序员的自我修养一链接、装载与库
---
## Page 46
1.6众人拾柴火始高
23
新6xnun
Windows 对进程和线程的实现如同教科书一般标准，Windows内核有明确的线程和进
程的概念。在Windows API 中，可以使用明确的 APl：CreateProcess 和 CreateThread来创建
进程和线程，并且有一系列的API来操纵它们。但对于Linux来说，线程并不是一个通用的
概念。
Linux对多线程的支持颜为贫乏，事实上，在Linux内核中并不存在真正意义上的线程
概念。Linux将所有的执行实体（无论是线程还是进程）都称为任务（Task），每一个任务
概念上都类似于一个单线程的进程，具有内存空间、执行实体、文件资源等。不过，Limux
下不同的任务之间可以选择共享内存空间，因面在实际意义上，共享了同一个内存空间的多
个任务构成了一个进程，这些任务也就成了这个进程里的线程。在Linux下，用以下方法可
以创建一个新的任务，如表1-2所示。
表1·2
系统调用
作用
fork
复制出前进程
exec
使用新的可执行映像覆盖当前可执行映像
clone
创建子进程并从指定位置开始执行
fork函数产生一个和当前进程完全一样的新进程，并和当前进程一样从fork函数里返
回。例如如下代码：
pid_t pid;
if (pid = fork(1)
在fork函数调用之后，新的任务将启动并和本任务一起从fork函数返回。但不同的是
本任务的fork将返回新任务pid。面新任务的fork将返回0。
fork产生新任务的速度非常快，因为fork并不复制原任务的内存空间，而是和原任务
一起共享一个写时复制（CopyonWrite，COW）的内存空间（见图1-10）。所谓写时复制，
指的是两个任务可以同时自由地读取内存，但任意一个任务试图对内存进行修改时，内存就
会复制一份提供给修改方单独使用，以免影响到其他的任务使用。
fork只能够产生本任务的镜像，因此须要使用exec配合才能够启动别的新任务。cxcc
可以用新的可执行映像替换当前的可执行映像，因此在fork产生了一个新任务之后，新任
务可以调用exec来执行新的可执行文件。fork和exec通常用于产生新任务，面如果要产生
新线程，则可以使用clone。clone函数的原型如下：
程序员的自我修养一链接、装载与库
---
## Page 47
24
第1章温故而知新
int clone(int (*fn) (void*), void* child_stack, int flags, void* arg);
廉任务
新任务1
Fork
任务1写内
使用
使用
新任务1的内存空
新任务2
用
源任务的内存空间
使用
原任务
复制
新任务
Fork
使用
新任务2
使用
预任务的内存空间
图1-10写时复制（Copy-On-Write）
使用clone可以产生一个新的任务，从指定的位置开始执行，并且（可选的）共享当前
进程的内存空间和文件等，如此就可以在实际效果上产生一个线程，
1.6.2
线程安全
多线程程序处于一个多变的环境当中，可访问的全局变量和堆数据随时都可能被其他的
线程改变。因此多线程程序在并发时数据的一致性变得非常重要。
竞争与原子操作
多个线程同时访问一个共享数据，可能造成很恶劣的后果。下面是一个著名的例子，假
设有两个线程分别要执行如表1-3所示的C代码。
表1-3
线程1
线程2
j=1;
--i;
++i;
在许多体系结构上，++i的实现方法会如下：
程序员的自我修养——链接、装载与库
---
## Page 48
1.6众人拾柴火焰高
25
（1）读取i到某个寄存器X。
(2)X++*
（3）将X的内容存储回i。
由于线程1和线程2并发执行，因此两个线程的执行序列很可能如下（注意，寄存器X
的内容在不同的线程中是不一样的，这里用x和X分别表示线程1和线程2中的X），如
表1-4所示。
表 1-4
执行序号执行指令
语句执行后变量值线程
1
i=1
i=1,X=未知
2
x"=i
i=1, x"=1
1
3
xi
j=1, x=1
2
4
X
j=1, x"=2
1
5
x2..
i=1, xl2=0
2
6
i=xl11
i=2, x"=2
1
7
i=x(21
i=0, x²=0
2
从程序逻辑来看，两个线程都执行完毕之后，i的值应该为1，但从之前的执行序列可
以看到，i得到的值是0.实际上这两个线程如果同时执行的话，i的结果有可能是0或1或
2.可见，两个程序同时读写同一个共享数据会导致意想不到的后果。
很明显，白增（++）操作在多线程环境下会出现错误是因为这个操作被编译为汇编代
码之后不止一条指令，因此在执行的时候可能执行了一半就被调度系统打断，去执行别的代
码。我们把单指令的操作称为原子的（Atomic），因为无论如何，单条指令的执行是不会被
打断的。为了避免出错，很多体系结构都提供了一些常用操作的原子指令，例如i386就有
一条inc指令可以直接增加一个内存单元值，可以避免出现上例中的错误情况，在Windows
里，有一套API专门进行一些原子操作（见表1-5），这些API称为Interlocked API。
作用
表1-5
InterlockedExchange
原子地交换两个值
InterlockedDecrement
原子地减少一个值
Interlockedlncrement
原于地增加一个值
InterlockedXor
原子地进行异或操作
使用这些函数时，Windows将保证是原子操作的，因此可以不用担心出现问题。遗憾的
是，尽管原子操作指令非常方便，但是它们仅适用于比较简单特定的场合。在复杂的场合下，
程序员的自我修养—链接、装载与库
---
## Page 49
26
第1章温故而知新
比如我们要保证一个复杂的数据结构更改的原子性，原子操作指令就力不从心了，这里我们
需要更加通用的手段：锁
同步与锁
为了避免多个线程同时读写同一个数据而产生不可预料的后果，我们需要将各个线程对
同一个数据的访问同步（Synchronization）。所谓同步，既是指在一个线程访问数据未结束
的时候，其他线程不得对同一个数据进行访问，如此，对数据的访问被原子化了，
同步的最常见方法是使用锁（Lock）。锁是一种非强制机制，每一个线程在访同数据或
资源之前首先试图获取（Acquire）锁，并在访间结束之后释放（Release）锁。在锁已经被
占用的时候试图获取锁时，线程会等待，直到锁重新可用。
二元信号量（BinarySemaphore）是最简单的一种锁，它只有两种状态：占用与非占
用。它适合只能被唯一一个线程独占访间的资源。当二元信号量处于非占用状态时，第一个
试图获取该二元信号量的线程会获得该锁，并将二元信号量置为占用状态，此后其他的所有
试图获取该二元信号量的线程将会等待，直到该锁被释放。
对于允许多个线程并发访问的资源，多元信号量简称信号量（Semaphore），它是一个
很好的选择。一个初始值为N的信号量允许N个线程并发访间。线程访间资源的时候首先
获取信号量，进行如下操作：
·将信号量的值减1。
·如果信号量的值小于0.则进入等待状态，否则继续执行。
访问完资源之后，线程释放信号量，进行如下操作：
·将信号量的值加1。
·如果信号量的值小于1，唤醒一个等待中的线程。
互斥量（Mutex）和二元信号量很类似，资源仅同时允许一个线程访问，但和信号量不
同的是，信号量在整个系统可以被任意线程获取并释放，也就是说，同一个信号量可以被系
统中的一个线程获取之后由另一个线程释放。而互斥量则要求哪个线程获取了互斥量，哪个
线程就要负责释放这个锁，其他线程越组代应去释放互斥量是无效的。
临界区（CriticalSection）是比互斥量更加严格的同步手段。在术语中，把临界区的锁
的获取称为进入临界区，而把锁的释放称为离开临界区。临界区和互斥量与信号量的区别在
于，互斥量和信号量在系统的任何进程里都是可见的，也就是说，一个进程创建了一个互序
量或信号量，另一个进程试图去获取该锁是合法的。然而，临界区的作用范围仪限于本进程，
其他的进程无法获取该锁。除此之外，临界区具有和互斥量相同的性质。
程序员的自我修养一链接、装载与库
---
## Page 50
1.6众人拾荣火焰高
27
读写锁（Read-WriteLock）致力于一种更加特定的场合的间步，对于一段数据，多个
线程同时读取总是没有问题的，但假设操作都不是原子型，只要有任何一个线程试图对这个
数据进行修改，就必须使用同步手段来避免出错。如果我们使用上述信号量、互斥量或临界
区中的任何一种来进行同步，尽管可以保证程序正确，但对于读取频繁，面仅仅偶尔写入的
情况，会显得非常低效，读写锁可以避免这个问题，对于同一个锁，读写锁有两种获取方式，
共享的（Shared）或独占的（Exclusive）。当锁处于自由的状态时，试图以任何一种方式获
取锁都能成功，并将锁置于对应的状态。如果锁处于共享状态，其他线程以共享的方式获取
锁仍然会成功，此时这个锁分配给了多个线程。然面，如果其他线程试图以独占的方式获取
已经处于共享状态的锁，那么它将必须等待锁被所有的线程释放。相应地，处于独占状态的
领将阻止任何其他线程获取该锁，不论它们试图以哪种方式获取。读写锁的行为可以总结如
表1-6所示。
表1-6
读写锁状态
以共享方式获取
以独占方式获取
自由
成功
成功
共享
成功
等待
独吉
等待
等待
条件变量（ConditionVariable）作为一种同步手段，作用类似于一个栅栏，对于条件
变量，线程可以有两种操作，首先线程可以等待条件变量，一个条件变量可以被多个线程等
待。其次，线程可以唤醒条件变量，此时某个或所有等待此条件变量的线程都会被唤醒并继
续支持。也就是说，使用条件变量可以让许多线程一起等待某个事件的发生，当事件发生时
（条件变量被唤醒），所有的线程可以一起恢复执行。
可重入（Reentrant）与线程安全
一个函数被重入，表示这个函数没有执行完成，由于外部因素或内部调用，又一次进入
该函数执行。一个函数要被重入，只有两种情况：
（1）多个线程同时执行这个函数。
（2）函数自身（可能是经过多层调用之后）调用自身。
一个函数被称为可重入的，表明该函数被重入之后不会产生任何不良后果。举个例子，
如下面这个sqr函数就是可重入的：
int sqr (int ×)
return x * x1
一个函数要成为可重入的，必须具有如下几个特点：
程序员的自我修养一链接、装载与库
---
## Page 51
28
第1章温故而知新
·不使用任何（局部）静态或全局的非const变量。
·不返回任何（局部）静态或全局的非const变量的指针。
·仅依赖于调用方提供的参数。
·不依赖任何单个资源的锁（mutex等）。
·不调用任何不可重入的函数。
可重入是并发安全的强力保障，一个可重入的函数可以在多线程环境下放心使用。
过度优化
线程安全是一个非常烫手的山芦，因为即使合理地使用了锁，也不一定能保证线程安全，