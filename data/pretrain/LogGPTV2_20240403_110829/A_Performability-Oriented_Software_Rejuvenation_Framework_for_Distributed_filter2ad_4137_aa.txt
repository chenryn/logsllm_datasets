title:A Performability-Oriented Software Rejuvenation Framework for Distributed
Applications
author:Ann T. Tai and
Kam S. Tso and
William H. Sanders and
Savio N. Chau
A Performability-Oriented Software Rejuvenation Framework for Distributed
Applications∗
Ann T. Tai Kam S. Tso
IA Tech, Inc.
Los Angeles, CA 90024
William H. Sanders
University of Illinois
Urbana, IL 61801
Savio N. Chau
Jet Propulsion Laboratory
Pasadena, CA 91109
Abstract
While inherent resource redundancies in distributed ap-
plications facilitate gracefully degradable services, meth-
ods to enhance their dependability may have subtle, yet
signiﬁcant, performance implications, especially when such
applications are stateful in nature. In this paper, we present
a performability-oriented framework that enables the real-
ization of software rejuvenation in stateful distributed ap-
plications. The framework is constructed based on three
building blocks, namely, a rejuvenation algorithm, a set of
performability metrics, and a performability model. We
demonstrate via model-based evaluation that this frame-
work enables error-accumulation-prone distributed appli-
cations to deliver services at the best possible performance
level, even in environments in which a system is highly vul-
nerable to failures.
1
Introduction
Software rejuvenation has been recognized as a simple
yet effective means for avoiding computer system failures
that are caused by accumulative internal errors or error-
caused system capacity deterioration. When a software sys-
tem is voluntarily rebooted, with high probability, errors ac-
cumulated at runtime will be eliminated and the system will
regain its full capacity. The subject of software rejuvena-
tion has been investigated extensively by researchers (see
[1, 2, 3, 4, 5, 6], for example). More recently, research
efforts have suggested the use of software rejuvenation to
protect critical systems against “incremental intrusions” [7],
which are difﬁcult to detect and isolate before damage ac-
cumulates to the point that catastrophic failures expected by
attackers become inevitable.
Inspired by the prior work and motivated by the fact that
rapidly advancing network technologies have resulted in the
reliance of an ever-increasing fraction of the world’s infras-
tructure upon distributed software systems, we develop a
software rejuvenation framework for stateful distributed ap-
plications that comprise server replicas. Such applications
∗
The work reported in this paper was supported in part by Small
Business Innovation Research (SBIR) Contract NAS3-99125 from the Jet
Propulsion Laboratory, National Aeronautics and Space Administration.
represent an important area, but one in which software re-
juvenation has not yet been considered. Our goal is to in-
vestigate the feasibility of software rejuvenation in stateful
distributed applications and to address the design consider-
ations that are necessary for and unique to this important
class of distributed systems.
While inherent resource redundancies in distributed ap-
plications have the potential to support novel architectures
or algorithms and facilitate gracefully degradable perfor-
mance, methods to enhance their dependability may have
subtle, yet signiﬁcant, performance implications, especially
when such applications are stateful in nature.
In par-
ticular, software rejuvenation which needs to temporarily
stop a long-running replica server R may lead to post-
rejuvenation performance degradation, since an operation
disruption may cause the state of R to become inconsistent
with that of other replicas and may imply that R would be
unable to provide services at its full capacity until after it re-
stores consistency. Accordingly, we take a performability-
oriented approach to developing a framework for the real-
ization of software rejuvenation in stateful distributed ap-
plications. By “performability-oriented,” we mean that the
design, evaluation, and enhancement of the framework are
guided by the analysis of a system’s ability to deliver ser-
vices with gracefully degradable performance. The frame-
work is constructed based on three building blocks, namely,
a rejuvenation algorithm, a set of performability metrics,
and a performability model. The performability metrics and
model both take into account the post-rejuvenation perfor-
mance degradation resulting from consistency restoration.
Moreover, our performability model accommodates the fact
that the post-rejuvenation consistency restoration processes
themselves are not immune to failures, due to the potential
performance stress caused by the service requests accumu-
lated during rejuvenation.
The basic version of our rejuvenation algorithm is a
precursor-detection-triggered rejuvenation scheme that uses
pattern-matching mechanisms to detect pre-failure condi-
tions. To compensate for the inherent limitation of pattern-
matching mechanisms, namely,
their inability to detect
pre-failure condition patterns that are not known a pri-
ori, the enhanced version of the algorithm accommodates
a random timer and allows detection-triggered rejuvena-
tion and timer-triggered rejuvenation to coordinate in a syn-
ergistic manner. We demonstrate via model-based evalu-
ation that our performability-oriented framework enables
error-accumulation-prone distributed applications to con-
tinuously deliver gracefully degradable services at the best
possible performance level, even in environments in which
a system is highly vulnerable to failures. Further, our ef-
fort shows that software rejuvenation can be realized as an
integral part of the infrastructure in stateful distributed ap-
plications that guarantee eventual consistency.
The remainder of the paper is organized as follows. Sec-
tion 2 describes the system model. Section 3 discusses the
fundamental concepts and methods that enable the frame-
work development. Sections 4 and 5 describe and analyze
the basic and enhanced versions of our rejuvenation algo-
rithm, respectively. We conclude in Section 6.
2 System Model and Assumptions
We focus on an important class of highly available state-
ful distributed applications in which servers are replicated at
multiple sites that are connected through LANs or WANs.
Clients interact with the replicated servers by issuing ser-
vice requests. A requested service will be a “read,” “write,”
or “read and write” access to a logical entity of data.
Distributed replicated services enable a server to be ac-
cessed by multiple clients concurrently and provide signiﬁ-
cantly better response time than a centralized system would.
On the other hand, concurrent access has the potential to
cause inconsistency among replicas when the application is
stateful. Traditional concurrency control protocols, such as
two-phase locking, guarantee strong consistency for those
applications. However, those protocols often incur high per-
formance overhead when servicing update requests. Hence,
over the past ﬁfteen years, the distributed computing com-
munity has gradually shifted its research focus from the tra-
ditional, expensive concurrency control protocols to their
variants that use more ﬂexible algorithms to guarantee even-
tual rather than immediate consistency when such guaran-
tees comply with clients’ requirements.
Our system model presumes a protocol that guarantees
eventual consistency by employing a sequencer to ensure
that update requests from clients are executed in the same
order in all the replicas [8]. Based on the system model, we
make two assumptions for the framework design and eval-
uation as follows. First, we assume that the sequencer also
takes responsibility for scheduling time-based rejuvenation.
Moreover, the sequencer (which resides on a replica server
R) has passive replications at other replica servers; thus, the
scheduling function, which we call a scheduler for simplic-
ity in the remainder of the paper, can migrate to another
replica server site in case of site failure.
Second, we assume that when error accumulation be-
comes excessive before a replica undergoes rejuvenation,
the replica will crash. A local recovery is possible, but is
not guaranteed to be successful. If a crashed replica fails
to recover locally, the subsequent attempt at recovery must
rely on another replica that is operational to transfer neces-
sary state information through the network. Consequently,
a crashed replica that does not succeed in the ﬁrst recovery
attempt will not have another chance to recover, unless the
system has at least one operational replica. In turn, this im-
plies that when all the replicas become non-operational and
none of them succeeds in local recovery, the system opera-
tion will cease and must wait for major corrective mainte-
nance involving human intervention.
3 Foundation of the Framework
3.1 Basic Approach
From a strict availability point of view, software rejuve-
nation could be easily implemented in a distributed system
with replicas, because system-level availability would not
be affected when a single replica or a proper subset of the
replicas undergoes rejuvenation. However, this assumption
is feasible only for stateless distributed applications. More
speciﬁcally, software rejuvenation requires a replica R to be
periodically or occasionally taken ofﬂine for a brief dura-
tion, implying that R’s state may become obsolete and thus
be inconsistent with the rest of the replicas in the system
when R is back from rejuvenation.
On the other hand, the notion of eventual consistency can
be exploited to enable the realization of software rejuvena-
tion in stateful distributed applications. In particular, for a
system in which a protocol that guarantees eventual consis-
tency is employed, the state of a replica will be permitted
to be temporally inconsistent with that of other replicas, fa-
cilitating the utility of software rejuvenation. Based on that
observation, we derive a simple yet cohesive solution that
permits a replica to undergo rejuvenation without violating
the eventual consistency property.
More speciﬁcally, when a replica R undergoes rejuve-
nation, read requests issued at the local site to R will be
diverted to and processed by an in-service replica, while all
the update requests will be received/processed by all the in-
service replicas. In the meantime, those update requests and
the global sequence number (which is abbreviated as GSN
and enables the updates to be executed in the same order by
all the replicas [8]) assignments broadcast by the sequencer
will be saved in a buffer at R and will be processed by R
according to the global order after R completes its rejuve-
nation procedure.
Consequently, a replica R that is engaged in rejuvenation
can be regarded as one that is temporarily very slow in exe-
cuting updates, and its state and the states of all other repli-
cas in the system will converge at a point after R’s rejuve-
Table 1: Relationships between Coarse- and Fine-Grained Performance Levels
Coarse-Grained
Fine-Grained
Deﬁnition
Interpretation
level-0
level-1
level-2
level-3
level-n.n
i = n, j = n
level-0.0
level-i.j
level-n.j
i = 0, j = 0
i ∈ {1, . . . , n − 1}, j ∈ {0, . . . , i} A non-empty proper subset of the n replicas
i = n, j ∈ {0, . . . , n − 1}
None of the n replicas are operational.
are operational.
All the n replicas are operational and a
proper subset of them are in-service replicas.
All the n replicas are operational and are in-
service replicas.
nation. Coupled with inherent resource redundancy, this en-
ables stateful distributed applications to deliver gracefully
degradable services without eventual-consistency property
violation or rejuvenation-caused unavailability.
Finally, the basic approach illustrated above enables us
to develop algorithms for software rejuvenation in stateful
distributed systems, as described in Sections 4 and 5.
3.2 Performance-Level Deﬁnition
According to the discussion in Section 3.1, a client who
issues a request to a replica R that is under rejuvenation will
perceive a response time that is slower but likely acceptable.
Further, since all update requests accumulated in R’s buffer
will be processed after R completes rejuvenation, and since
in the meantime additional service requests may arrive at R,
R may have a stressful period with a duration τ following its
rejuvenation (see Section 4.2.3 for an analytical discussion).
As the state of R is expected to become consistent (to the
degree that it would have been if the rejuvenation had not
happened) with that of other replicas by the end of τ , we use
the term consistency restoration to refer to R’s services to
the accumulated update requests during τ . Moreover, even
with the preventive measure, replicas may still crash, and
a crashed replica R(cid:1)
will undergo a recovery process dur-
ing which it will remain non-operational until the recovery
completes. Consequently, R(cid:1)
may also experience a stress-
ful period following its recovery for consistency restoration.
The above analysis suggests a pair of index (random)
variables whose values will determine the possible perfor-
mance levels of a system, namely,
I: The number of operational replicas.
J: The number of operational replicas that are not engaged
in either rejuvenation or consistency restoration1.
Then, the performance levels of a system with n replica
servers can be expressed in terms of I and J as follows:
{level-i.j | i ∈ {0, . . . , n}, j ∈ {0, . . . , i}}
(1)
Accordingly, when we say that a system is performing at
level-i.j, we mean that the system is in a state in which i
1For brevity, in this paper we sometimes use the term “in-service repli-
cas” to refer to those replicas.
replicas are operational and among them j are not engaged
in either rejuvenation or consistency restoration. Further,
if we consider the performance impact from a replica fail-
ure to be far more severe than the impact found when one
or more operational replicas are undergoing rejuvenation
or consistency restoration, then the above mathematical ex-
pression not only generates a sequence of performance lev-
els for a given value of n, but also ranks them systematically
in an increasing order based on the values of I and J.
In addition, the above expression allows us to choose the
“granularity” for deﬁning performance levels. More specif-
ically, we can group the ﬁne-grained performance levels de-
rived from the above expression based on the value ranges
of I and J to obtain a set of coarse-grained performance
levels for the same system. Table 1 provides an instance
of such grouping and shows the relationships between the
coarse- and ﬁne-grained performance levels.
In turn, the performance levels so obtained enable us to
deﬁne a set of performability metrics, a building block that
allows us to quantify a system’s ability to provide gracefully
degradable services.
In Sections 4 and 5, we deﬁne per-
formability metrics directly in terms of those performance
levels, in the context of an instance of our system model that
is used to illustrate the basic and enhanced versions of our
rejuvenation algorithm.
4 PD Scheme
4.1 Precursor-Detection Approach
Researchers have proposed several software rejuvenation
schemes that are based on prediction, observation, and mon-
itoring (see [5, 6], for example). Since those schemes allow
rejuvenation to take place only when failures are likely to
happen, they reduce the system unavailability caused by re-
juvenation activities that are unnecessary.
Accordingly, we begin by proposing a precursor-
detection-triggered rejuvenation scheme (PD scheme). The
scheme uses patterns of pre-failure conditions that are iden-
tiﬁed based on earlier data from the system logs that offer
clues on the relationships between failures and their pre-
conditions. For example, a rapid, monotonic, or accelerated
increase of memory utilization may be identiﬁed as a pre-
Table 2: Deﬁnition and Interpretation of Performance Levels
Level
0
1
2
3
Deﬁnition
i = 0, j = 0
i = 1, j ∈ {0, 1} One replica is operational and the other is not.
i = 2, j ∈ {0, 1} Both replicas are operational and at least one of them is engaged in
Neither of the replicas is operational.
Interpretation
i = 2, j = 2
rejuvenation or consistency restoration.
Both replicas are operational and neither of them is engaged in rejuve-
nation or consistency restoration.
failure condition if data show that it is strongly correlated
with system failures (due to memory leakage, for example).
When an observed system event or a combination of ob-
served events matches a pre-deﬁned pattern, an exception
will be raised to activate a rejuvenation procedure.
The main advantage of pattern-matching detection
mechanisms (which sometimes are called “misuse detec-
tion” in the context of intrusion detection systems) is their
ability to accurately detect instances of known pre-failure
condition patterns with only very limited false alarms. Their
disadvantage is the lack of an ability to detect the pre-failure
conditions that are not known a priori. There are alterna-
tive types of detection mechanism that offer better detec-
tion coverage, such as “anomaly detection,” which treats
observed system behaviors that deviate from the established
normal system proﬁles as “anomalies.” Nonetheless, a se-
vere drawback of that mechanism is its detection accuracy
problem (i.e., a high rate of false alarm). For software
rejuvenation purposes, we choose a high-accuracy detec-
tion mechanism, namely pattern matching, over those high-
coverage high-false-alarm-rate ones, as they would defeat
the purpose of using detection to minimize system unavail-
ability caused by unnecessary rejuvenation activities.
To assess the PD scheme, we conduct a performability
evaluation in the following subsection. For simplicity and
clarity, we choose to analyze a distributed application that
is an instance of our system model with n = 2.
4.2 Performability Model for the PD Scheme
4.2.1 Performability Metrics
From the performance-level deﬁnition described in Section
3.2, it follows that a system with two replicas can have four
coarse-grained performance levels, as shown in Table 2.
The performance-level deﬁnition then enables us to de-
ﬁne a set of performability metrics as follows:
{P (Y = k) | k ∈ {0, 1, 2, 3}}.
Since we are also interested in evaluating the probability
that the system will perform at or above a level k, we deﬁne
a pair of additional metrics {P (Y ≥ k) | k ∈ {1, 2}}.
Note that values 0 and 3 are excluded from the range of k.
The reason is that they correspond to two degenerate cases,
namely, P (Y ≥ 0) and P (Y ≥ 3), which are equal to 1 and
P (Y = 3), respectively.
4.2.2 SAN Model
To evaluate the performability metrics, we build a performa-
bility model with stochastic activity networks (SANs) using
UltraSAN [9]. The SAN model for the PD scheme execut-
ing on a 2-replica application is depicted in Figure 1. The
replicas are both in a robust state initially (represented by
tokens in the places n1 robust and n2 robust). As time
passes and error conditions accumulate, a replica will even-
tually enter a vulnerable state, which is represented by a
token in place n1 vuln or n2 vuln.
n1_inrj
n1_torj
n1_rejuv
n1_robust
n1_vuln
n1_age
n1_det
n1_nrf
n1_crash
n1_fail
n1_down
n1_rpr
n1_repair
n1_rpf
n1_update
n1_rec
n1_restore
n1_rpok
n2_inrj
n2_torj
n2_rejuv
n2_robust
n2_vuln
n2_age
n2_det
n2_nrf
n2_crash
n2_fail
n2_down
n2_rpr
n2_rpok
n2_repair
n2_rpf
n2_update
n2_rec
n2_restore