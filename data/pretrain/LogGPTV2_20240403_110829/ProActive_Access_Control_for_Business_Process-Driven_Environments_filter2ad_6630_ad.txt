A  cache  entry  is  a  stored  response  from  a  fake 
request:  it  contains  the  final  decision  of  a  PDP's 
request evaluation. The result of a cache entry assumes 
that all open constraints evaluate to true (no matter of 
the  values  the  actual  dynamic  context  information 
during  evaluation  holds).  Hence,  given  the  above 
example,  the  permission  P  stored  as  response  in  the 
cache entry assumes that the current time lies between 
6 a.m. and 8 p.m. independent of the actual time during 
the evaluation.   
If  the  cache  entry  is  eventually  used  to  answer  an 
access  request,  then  the  open  constraint  is  checked 
against the real values of the dynamic context given the 
current status of the system. If all OCs evaluate to true, 
the stored permission holds (as during the permission's 
to 
150160
PEP
Cache
Open Constraint
Evaluator
R
PDP
read
Policies
Policy 
Storage
Dependency
Storage
read
Policies
Event Listener
Cache Management
Component
Figure 4: Caching Architecture 
We  suggest  that  the  policy  decision  point  will  be 
used to evaluate fake requests and return the decision 
which  will  be  used  within  the  cache  entry.  As 
described above, we have different types of constraints. 
For our cache creation, role-based permissions as well 
as  SoD,  BoD,  and  cardinality  constraints  can  be 
evaluated  as  for  any  regular  decision  request  as  well. 
Constraints of type date, time, and attribute-based must 
considered true for the evaluation of the fake request. 
Hence, if the PDP recognizes a request from the cache 
management  component 
the  additional 
functionality to react accordingly.  
it  needs 
Furthermore,  the  cache  needs  the  functionality  to 
evaluate open constraints. In Figure 4 we depicted this 
by  applying  an  Open  Constraint  Evaluator  to  the 
Cache.  
5. Benchmarking the Architecture 
Regarding  the  actual  efficiency  of  our  suggested 
approach the following criteria now require evaluation: 
•  Comparison  of  decision  request  evaluation 
performance regarding the general absence or 
presence of our proposed caching component. 
•  Comparison of proposed caching strategy wrt 
to different constraint types 
We  implemented  the  proposed  architecture  and 
benchmarked  the  two  mentioned  goals  to  analyze  the 
proposed strategy.  
Our implementation includes a PDP component for 
which  we  used  a  rule  engine.  In  particular,  we  used 
JBoss  DROOLS  [10]  with  which  we  developed  a 
declarative  approach  to  implement  an  access  decision 
evaluation  engine.  For  the  benchmark  we  generated 
role-based permissions, policies with SoD constraints, 
as well as policies with attribute-based constraints. Our 
test  policy  contains  1500  users,  assigned  to  15  roles 
(100  users  each),  and  an  overall  number  of  1700 
permissions.  
instances;  every 
This was tested against a filled cache. The amount 
of entries is based on the assumption of 1000 parallel 
running  process 
instance  has 
approximately  60  cache  entries  (10  pre-computed 
entries for the actions cancelProcess and restartProcess, 
40 entries for concurrent active task instances, and 10 
pre-computed  entries  for  BO  Calls).  We  assumed 
according to our strategy, that for each access request, 
a cache entry is available if the cache is used. 
The  context  information  retrieval  needed  for  the 
access evaluation (e.g., the list of executed tasks by a 
user) is realized by querying a local database. The PEP 
Cache is implemented as hash table where the target of 
a decision response functions as key. The values stored 
in  the  table  are  the  pre-computed  permission  (i.e., 
the  open 
PERMIT  or  DENY)  and  optionally 
constraints. 
The tests were performed with JAPEX [9], a micro-
benchmarking framework run on an Intel Pentium Dual 
Core system with 2.0 GHz and 1.5 GB RAM.  
The results are as follows. We conducted three test 
cases where each of them has been performed with and 
without the cache being used. All test cases performed 
50 access control request in row against the PDP. This 
reflects the scenario if a user enters her worklist and all 
active tasks for which she is potentially responsible are 
checked  whether  she  is  currently  allowed  to  perform 
them. On the PDP's side the policies are implemented. 
Test Case 1 uses 50 requests which on the PDP's side 
purely  needs  role-based  evaluation.  This  means,  the 
response  times  shown  in  the  first  column  of  Figure  5 
are based on RBAC evaluations. The second test case 
151161
uses a mixture of requests. 80% RBAC of them  were 
purely evaluated using RBAC, for the remaining 20% 
SoD  evaluation  was  necessary  (incl.  the  history 
selection from the database). The results are shown in 
the second column of Figure 5. The third test case uses 
a mixture of requests where 60% of the requests were 
evaluated based on RBAC policies, 20% based on SoD 
policies  and  the  remaining  20%  based  on  attribute-
based policy evaluation.  
1500
1000
500
]
s
m
[
e
m
i
t
e
s
n
o
p
s
e
R
50 Access Requests with Cache
50 Access Requests without Cache
130
51
18
100% RBAC
70
45
0
18
0
80% RBAC, 
20% SoD
60% RBAC, 20% SoD,
20% Attribute-based
Types of Policies considered in Request Calls
Figure 5: Benchmark results 
In 
this 
The results show the overall response times for 50 
access requests in row. The more external context data 
is required (e.g., history data of a user) the longer takes 
the response. This also holds for cache entries. Those 
with open constraints (i.e., attribute-based constraints) 
require additional context retrieval (cf. Section 3.2.5); 
the context request clearly increases the response time 
(see  case  three).  Obvious  is  the  significant  overall 
difference  between  response  times  with  and  without 
cache. 
remote  and 
distributed communication was simulated.  
6. Concept Evaluation 
implementation  no 
The  presented  concept  relies  on  the  fact  that 
business process executions have predefined states and 
every state has a limited set of actions which might be 
performed  next.  This  also  means 
the  developed 
dependency relations for a particular system rely on the 
fact that the given information about process and task 
management as well as process definitions is valid. As 
this  most  certainly  remains  true  for  the  process  and 
task management, process definitions may change. It is 
clear that in such a case the dependency relations have 
to  be  adopted.  The  same  holds  for  changes  in  the 
policy  definition,  especially  regarding,  for  instance, 
newly added or changed open constraints. Also, if the 
policy  changes  the  cache  entries  have  to  be  updated. 
Typical approaches are to flush the cache whenever the 
policy changes. 
We  propose  the  pre-evaluation  of  access  decisions 
only for subsequent upcoming events, rather than pre-
computing entries for the complete process. The reason 
is  twofold.  First,  making  a  complete  pre-evaluation 
would pollute the cache with entries not needed at the 
current  point  in  time  as  most  cache  entries  would  be 
created for tasks which are not active, yet. This would 
increase the response time for the cache without further 
benefit.  Second,  some  cache  entries  which,  for 
the  evaluation  of  SoD 
instance,  are  based  on 
constraints,  need  a  user's  history 
to 
compute  a  respective  result.  Obviously,  this  type  of 
information  is  only  available  if  the  user  already 
claimed  or  completed  the  related  tasks.  Hence,  the 
assignment of a user to a task (which also is part to the 
SoD constraint) is the earliest event where such types 
of entries can be reliably generated. 
information 
However, there is still flexibility when cache entries 
can be pre-computed. The period of time lies between 
the  occurrence  of  the  trigger  event  and  the  event  for 
which  the  cache  entry  is  generated. Therefore,  within 
this  boundary  entries  can  be  generated  whenever  the 
system responsible for creating cache entries has spare-
time. 
Still open for a complete evaluation is the analysis 
of  vulnerabilities  of  our  caching  solution.  We  are 
aware that caching solutions as presented in the context 
of  this  paper  have  to  be  secured  against  attacks. 
Possible target points for our system may be the cache 
entries  themselves  (manipulation,  deletion,  etc.),  the 
communication channels between the cache, the PEP, 
the  PDP,  the  context  providers  as  well  as  the  cache 
manager.  Targets  may  also  be  the  open  constraints 
when evaluated on the cache side as well as potentially 
manipulated  received  information  from  the  context 
provider(s). This will be further analysed in the future 
and aligned with a proposal of respective measures. 
7. Conclusion 
In  this  work  we  presented  a  caching  solution  of 
access  control  decisions  for  business  process-driven 
environments. The proposed caching strategy relies on 
the fact that the execution of business processes takes 
place  within  a  small  margin  of  actions  which  always 
happen subsequently in predefined order. This makes it 
possible  to  pre-compute  cache  entries  in  such  a  way 
that  decision  responses  are  available  exactly  when 
needed.  
Our approach relies on dependency relations which 
state exactly at which points during the execution of a 
152162
business  process  it  is  optimal  to  pre-compute  a  cache 
entry as well as for which potentially upcoming event 
an  entry  should  be  created  and  at  which  point  during 
execution the entry  will  no longer be needed and can 
be removed.  
We  presented  an  accompanying  architecture.  We 
implemented and benchmarked our proposed solution. 
The  results  show  that  a  significant  performance  gain 
can be expected if our caching strategy is implemented. 
8. References 
[1]  Wei,  Q.,  et  al.,  "Authorization  recycling  in  RBAC 
systems", Proc. of the ACM Symposium on Access Control 
Models and Technologies, 2008. 
[2]  Crampton,  J.,  et  al.,  "The  secondary  and  approximate 
authorization  model  and  its  application  to  Bell-LaPadula 
policies",  Proc.  of  the  ACM  Symposium  on  Access  Control 
Models and Technologies, 2006. 
[3]  Nielsen,  J.,  "Usability  Engineering",  Morgan  Kaufmann, 
1993. 
[4]  Kohler,  M.,  et  al.,  "Classification  Model  for  Access 
Control  Constraints",  Proc.  of  Performance,  Computing,  and 
Communications Conference, 2007. 
[5]  Aalst,  W.v.d.,  Hee,  K.v.,  "Workflow  Management: 
Models, Methods, and Systems", MIT Press, 2004. 
[6]  WfMC  (Workflow  Management  Coalition),  "Workflow 
Reference  Model", 
in  http://www.wfmc.org/standards/ 
referencemodel.htm. 
[7]  Miller,  R.  B.,  "Response 
in  man-computer 
conversational  transactions",  Proc.  of  the  Spring  Joint 
Computer Conference, 1968. 
time 
[8]  Miseldine,  P.  L.:  "Automated  XACML  Policy 
Reconfiguration  for  Evaluation  Optimisation",  International 
Conference on Software Engineering, ACM, 2008. 
[9] 
https://japex.dev.java.net. 
JAPEX, 
"Micro-benchmarking  Framework", 
in 
in 
[10]  JBoss,  a  division  of  Red  Hat,  "DROOLS", 
http://www.jboss.org/drools.  
[11]  Wimmer,  M.,  and  Kemper,  A.,  "An  authorization 
framework for sharing data in web service federations", Proc. 
of VLDB Workshop on Secure Data Management, 2005.  
[12] Beznosov, K., "Flooding and Recycling Authorizations", 
Proc. of New Security Paradigm Workshop, 2005. 
[13]  Sandhu,  R. S.,  et  al.,  "The  NIST  model  for  role-based 
access  control:  towards  a  uniﬁed  standard",  In  ACM 
Workshop on Role-Based Access Control, ACM Press, 2000.