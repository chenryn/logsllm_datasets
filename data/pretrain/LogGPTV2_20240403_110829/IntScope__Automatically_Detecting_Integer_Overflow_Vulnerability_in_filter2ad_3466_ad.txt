251
252
253
254
255
256
257
!= sizeof(header))
goto fail;
......
s->l1_size = header.l1_size;
if (s->l1_size l1_vm_state_index)
goto fail;
s->l1_table=qemu_malloc(s->l1_size*sizeof(uint64_t));
if (!s->l1_table)
goto fail;
if (bdrv_pread(s->hd, s->l1_table_offset,
s->l1_table,s->l1_size * sizeof(uint64_t)) !=
s->l1_size * sizeof(uint64_t))
goto fail;
for(i = 0;i l1_size; i++) {
be64_to_cpus(&s->l1_table[i]);
}
Figure 10. Code snippet of function qcow open
(qemu-0.9.1/block-qcow2.c).
Function qcow open in block-qcow2.c is used
to open a qcow2 [17] format disk image.
Figure 10
shows the source code snippet of qcow_open.
Func-
tion bdrv_pread in line 194 reads tainted data from a
qcow2 format image ﬁle to a structure header. All con-
tents in header originate from the image ﬁle. After com-
plex taint propagation, s->l1 size is tainted. Function
qemu_malloc in line 134 directly calls function malloc
to allocate s->l1 size∗sizeof(uint64 t) bytes of
memory. Although s->l1 size is checked in line 249,
s->l1 size ∗ sizeof(uint64 t) could still over-
ﬂow, resulting in an array access out-of-bound in line 256.
Block drivers for other disk image formats: raw, vmdk,
vpc, cloop and the format used by Bochs have similar
problems.
We detected the same integer overﬂow vulnerabilities in
Xen. After a closer analysis, we found that Xen actually
reuses QEMU’s code, and hence all the integer overﬂow vul-
nerabilities in QEMU exist in Xen as well.
Media Players – We also applied IntScope to several mul-
timedia players, including Xine [25], MPlayer [15], VLC
[23] and Mpd [14].
Xine – Xine, a free multimedia player, has been down-
loaded nearly four million times from sourceforge. We
detected three integer overﬂow vulnerabilities in Xine-lib
1.1.15 (the xine core engine), and an integer overﬂow
vulnerability in Xine-ui 0.99.5 (an xlib-based GUI fron-
tend). The two integer overﬂow vulnerabilities in func-
tion process_commands in Xine-lib allow remote at-
tackers to compromise a server if the server uses the
cdda_server routine (a component of xine) to play au-
dio CDs over the network. Another integer overﬂow in func-
tion ff_audio_decode_data in Xine-lib could bypass
a bounds check, resulting in a heap overﬂow. The three bugs
were promptly conﬁrmed by the developers.
A crafted PNG format picture could trigger an inte-
ger overﬂow vulnerability in function _LoadPNG in Xine-
ui 0.99.5. _LoadPNG performs memory allocation simi-
lar to malloc(width* height*3), where width and
height are speciﬁed by the input PNG ﬁle. A crafted PNG
ﬁle with very large width and height will cause integer
overﬂow in width*height*3, resulting in a heap over-
ﬂow when _LoadPNG tries to read data from the PNG ﬁle
to the allocated memory.
Mplayer and VLC – Mplayer and VLC are two widely
distributed media players. Both Mplayer and VLC can im-
port Win32 codecs on ELF i386 platforms by building a DLL
loader and emulating responses from necessary Win32 API
calls, such as registry operations. However, we detected a
malformed fake registry ﬁle could trigger an integer over-
ﬂow in function open_registry in Mplayer and VLC,
eventually causing a heap overﬂow.
We also detected another integer overﬂow vulnerability
in avisubdump, an independent tool in the Mplayer pack-
age. Avisubdump dumps subtitle streams embedded in
AVI ﬁles to stdout. The integer overﬂow in function
dumpsub gab2 in avisubdump causes a bounds check
to be bypassed, resulting in an unexpected execution.
MPD – Music Player Daemon (MPD) allows remote ac-
cess for playing music and managing playlists. We de-
tected that a crafted MPEG-4 format ﬁle can cause an in-
teger overﬂow in function mp4_decode in MPD. Function
mp4_decode does not correctly check data from the crafted
input ﬁle, which causes a multiplication overﬂow, and the er-
roneous result is used in function malloc. The bug was
ﬁxed by the developers after we reported it.
Others – Besides examining those applications discussed
above, we also checked Faad2 [7] (a portable MPEG-4
and MPEG-2 AAC decoder), hamsterdb [11] (a lightweight
embedded database engine), Goom [10] (a visual effects
generator for mp3 players), and Cximage [6] (an im-
age processing and conversion library).
IntScope detected
two integer overﬂows in functions mp4ff read stts
and decodeMP4file in Faad2, which could cause a
heap overﬂow (CVE-2008-4201). The integer overﬂow in
function ConvertWmfFiletoEmf in Cximage results in
malloc(0); a malformed local conﬁgure ﬁle could cause
an integer overﬂow in function gsl_read_file in Goom,
which could further lead to a heap overﬂow. An integer
overﬂow vulnerability in function btree find cursor
in hamsterdb, which could cause potential buffer overﬂows,
has aleady been ﬁxed by the developers in their latest version.
We summarize the experimental results in Table 2. The
column “Paths” shows the number of suspicious paths gener-
ated by IntScope. Since IntScope performs a path-sensitive
analysis, a vulnerable point in a program may cause many
suspicious paths. The column “Total” indicates the number
of vulnerable points. Note that Xen and QEMU have the
same vulnerabilities. Totally, we detected 26 integer over-
ﬂow vulnerabilities, and 20 of them have been conﬁrmed by
our dynamic testing tool [46] and/or by the developers. For
the remaining 6 suspicious integer overﬂows, we cannot gen-
erate test cases to show their real existence yet.
4.2 Efﬁciency
In this section, we measure the performance and space
overhead of our system. The evaluation is performed on an
AMD Opteron Server (2.6 GHz) with 8GB memory running
Linux Kernel 2.6.18. Table 3 shows the result of efﬁciency
evaluation. We measured the time that IntScope spent trans-
lating x86 assembly into our PANDA representation (the col-
umn “Binary-to-IR time”) and the time IntScope spent sym-
bolically executing PANDA (the last column). We can see
that translating the x86 binary into our PANDA IR is time-
consuming part (varying from 1 seconds to nearly 1131 sec-
onds). The “IR Size” shows the size of the target PANDA
representation generated by our Decompiler, and it looks
much bigger than the original binary mainly because for a
single instruction, we may introduce many PANDA state-
ments. For example, a simple push ebp will be translated
into the statement sequence shown in Figure 11.
To summarize,
the average size for these binaries is
320.3K bytes, and we ﬁnd that IntScope takes 288.2s to
translate them into the PANDA code, with a size of 5.46M
1.
2.
3.
4.
5.
esp0 := esp
loc1 :: dword [-4+esp0]
esp
ebp0 := ebp
loc1 = ebp0
= -4+esp0
Figure 11. PANDA IR for “push ebp"
bytes, and then takes 293.6 seconds to symbolically execute
the interesting paths.
5 Discussion
Theoretically, IntScope may generate a test case for each
identiﬁed vulnerable path by solving the path conditions with
concrete values. In practice, however, the suspicious paths
sometimes are not complete execution traces since IntScope
only scans certain parts of a program, that is, the suspicious
paths do not start from function main. This is why we use
our dynamic vulnerability test case generation tool [46] to
show the true existence for a particular vulnerability.
For those suspicious integer overﬂow vulnerabilities that
we cannot generate test cases to conﬁrm, we have to man-
ually determine whether they are false positives or not. We
examined the reasons and we sum up why IntScope may gen-
erate false positives as follows:
Missing of the constraints between inputs. IntScope as-
sumes the input data could be “anything” and ignores the
innate constraints between inputs. For example, when ap-
plying IntScope to function DSA_SetItem (see Section
4.1.1), IntScope reports the paths (L1, L2, L5) and (L1,
L2, L4, L5) in Figure 7. The parameter hdsa in function
DSA_SetItem is a dynamic structure array. The product
of the number of items (hdsa->nItemCount) and the size
of an item (hdsa->nItemSize) in hdsa should not over-
ﬂow (i.e., hdsa->nItemCount ∗ hdsa->nItemSize
< 232). Without this precondition, IntScope reports the two
paths as suspicious paths.
Lack of global information. For example, besides the
known integer overﬂow in gdi32.dll, IntScope reports
the other two vulnerable points (see Section 4.1.1). We ﬁnd
the two vulnerable points are caused by the use of some
global data. Actually, the use of this global data is safe. We
need prior knowledge about the target program to identify
such false positives.
Imprecise symbolic execution. Our symbolic execu-
tion is not perfect.
IntScope does not accurately simulate
block memory functions (memmove, memcpy, etc.) and
some string functions (strncmp, strchr, etc.). However,
IntScope is still able to ﬁnd many integer overﬂow bugs in
real applications, showing that our system is tolerant of such
imprecise symbolic simulation.
Name
GDI32.dll
comctl32.dll
Version
5.1.2600.2180
5.82.2900.2180
QEMU
Xen
0.9.1
3.2.1
Xine
Xine-ui
MPlayer
Mpd
Goom
Cximage
faad2
Hamstedb
1.1.15
0.99.5
1.0rc2
0.13.2
2k4
600 full
2.6.1
1.0.4
Entry Function
CopyMetaFile
DSA SetItem
bochs open
cloop open
parallels open
qcow open(for qcow2 format)
vmdk open
vpc open
ff audio decode data
process commands
LoadPNG
dumpsub gab2
init registry
mp4 decode
gsl read ﬁle
ConvertWmfFiletoEmf
decodeMP4ﬁle
mp4ff read stts
btree ﬁnd cursor
Paths#
452
3
3
1
2
3
20
1
10
2
4
1
3
2
1
1
36
1
3
Total#
3
2
1
1
1
1
2
1
1
2
1
1
1
1
1
1
3
1
1
Conﬁrmed #
1
1
1
1
1
1
1
1
1
2
1
1
1
1
1
1
2
1
1
Suspicious#
2
1
0
0
0
0
1
0
0
0
0
0
0
0
0
0
1
0
0
Table 2. Evaluation Result on Effectiveness
Executable
GDI32.dll
comctl32.dll
Qemu-img
cdda server
avisubdump
libgoom2.so
xine
mpd
faad
libhamsterdb.so
File Size
271KB
597 KB
341 KB
14.5 KB
966 KB
14.2 KB
243 KB
439KB
57.6 KB
260 KB
320.3KB
Binary-to-IR time (seconds)
614
1131
124
4
590
1
131
94
29
164