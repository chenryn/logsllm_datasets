//1.得到数列的最大值和最小值，并算出差值d
3.
int max = array[o];
4.
int min = array[o];
5.
for(int i=1; i max){
7.
max = array[i];
8.
}
9.
if(array[i]=0;i--){
28.
sortedArray[countArray[array[i]-
min]-1]=array[i];
29.
countArray[array[i]-min]--;
30.
31.
return sortedArray;
32.}
34. public static void main(String[] args） {
35.
int[] array = new int[] {95,94,91,98,99, 90, 99, 93, 91, 92}
36.
int[] sortedArray = countSort(array);
37.
System.out.println(Arrays.toString(sortedArray));
38.}
---
## Page 258
小灰，如果原始数列的规模是n，最
大和最小整数的差值是m，你说说计数排序的时间复杂度和空间复
杂度是多少？
代码第1、2、4步都涉及遍历原
始数列，运算量都是n，第3步遍历统计数列，运算量是m，所以总
体运算量是3n+m，去掉系数，时间复杂度是O(n+m)。
至于空间复杂度，如果不考虑结
果数组，只考虑统计数组大小的话，空间复杂度是0(m)。
---
## Page 259
不错哦，回答得很赞！
不过我有一点不太明白，既然计
数排序这么强大，为什么很少被大家使用呢？
因为计数排序有它的局限性，主要表
现为如下两点。
1.当数列最大和最小值差距过大时，并不适合用计数排序。
例如给出20个随机整数，范围在0到1亿之间，这时如果使用计数排序，
需要创建长度为1亿的数组。不但严重浪费空间，而且时间复杂度也会
随之升高。
2.当数列元素不是整数时，也不适合用计数排序。
---
## Page 260
如果数列中的元素都是小数，如25.213，或0.00000001这样的数字，则
无法创建对应的统计数组。这样显然无法进行计数排序。
对于这些局限性，另一种线性时间排
序算法做出了弥补，这种排序算法叫作桶排序。
4.5.4
什么是桶排序
桶排序？那又是什么鬼？
桶排序同样是一种线性时间的排序算
法。类似于计数排序所创建的统计数组，桶排序需要创建若干个桶
来协助排序。
那么，桶排序中所谓的“桶”，又是什么呢？
---
## Page 261
每一个桶（bucket）代表一个区间范围，里面可以承载一个或多个元
素。
假设有一个非整数数列如下：
4.5,0.84， 3.25， 2.18, 0.5
让我们来看看桶排序的工作原理。
桶排序的第1步，就是创建这些桶，并确定每一个桶的区间范围。
4.5, 0.84,3.25,2.18, 0.5
[0.5,1.5)
[1.5,2.5)
[2.5,3.5)[3.5,4.5)[4.5,4.5]
具体需要建立多少个桶，如何确定桶的区间范围，有很多种不同的方
式。我们这里创建的桶数量等于原始数列的元素数量，除最后一个桶只
包含数列最大值外，前面各个桶的区间按照比例来确定。
区间跨度=（最大值-最小值）／（桶的数量-1）
第2步，遍历原始数列，把元素对号入座放入各个桶中。
0.84
0.5
2.18
3.25
4.5
[0.5,1.5)[1.5,2.5)[2.5,3.5)[3.5,4.5)[4.5,4.5]
第3步，对每个桶内部的元素分别进行排序（显然，只有第1个桶需要排
序）。
---
## Page 262
0.5
0.84
2.18
3.25
4.5
[0.5,1.5)
[1.5,2.5)
[2.5,3.5)
[3.5,4.5)
[‘]
第4步，遍历所有的桶，输出所有元素。
0.5，0.84，2.18，3.25，4.5
到此为止，排序结束。
大体明白了，那么，代码怎么写
呢？
我们来看一看桶排序的代码实现。
1. public static double[] bucketSort(double[] array){
2.
3.
//1.得到数列的最大值和最小值，并算出差值d
4.
double max = array[0];
5.
double min = array[0];
---
## Page 263
6.
for（int i=1; i max){
8.
max = array[i];
9.
10.
if(array[i]> bucketList = new
ArrayList>
(bucketNum);
19.
for(int i=0;i ());
21.
22.
23.
//3.遍历原始数组，将每个元素放入桶中
24.
for(int i = 0; i list : bucketList){
39.
for(double element :list){
40.
sortedArray[index]= element;
41.
index++;
42.
43.
44.
return sortedArray;
45.}
46.
47. public static void main(String[] args) {
48.
double[]array = new double[]
{4.12, 6.421, 0.0023, 3.0,2.123, 8.122,4.12, 1
49.
double[] sortedArray = bucketSort(array);
50.
System.out.println(Arrays.toString(sortedArray)) ;
---
## Page 265
51.}
在上述代码中，所有的桶都保存在ArrayList集合中，每一个桶都被定义
成一个链表（LinkedList），这样便于在尾部插入元素。
同时，上述代码使用了JDK的集合工具类Collections.sort来为桶内部的元
素进行排序。Collections.sort底层采用的是归并排序或Timsort，各位读
者可以简单地把它们当作一种时间复杂度为O(nlogn)的排序。
那么，桶排序的时间复杂度是多
少呢？
桶排序的时间复杂度有些复杂，让我
们来计算一下。
假设原始数列有n个元素，分成n个桶。
下面逐步来分析一下算法复杂度。
第1步，求数列最大、最小值，运算量为n。
第2步，创建空桶，运算量为n。
---
## Page 266
第3步，把原始数列的元素分配到各个桶中，运算量为n。
第4步，在每个桶内部做排序，在元素分布相对均匀的情况下，所有桶
的运算量之和为n。
第5步，输出排序数列，运算量为n。
因此，桶排序的总体时间复杂度为O(n)。
至于空间复杂度就很容易得到了，同样是0(n)。
桶排序的性能并非绝对稳定。如果元
素的分布极不均衡，在极端情况下，第一个桶中有n-1个元素，最
后一个桶中有1个元素。此时的时间复杂度将退化为O(nlogn)，而且
还白白创建了许多空桶。
4.5,0.84,3.25,10000000.0,0.5
0.84
3.25
10000000.0
0.5
由此可见，并没有绝对好的算法，也
---
## Page 267
没有绝对不好的算法，关键要看具体的场景。
关于计数排序和桶排序的知识，我们
就介绍到这里，下一章再见！
4.6小结
本章我们学习了一些具有代表性的排序算法。下面根据算法的时间复杂
度、空间复杂度、是否稳定等维度来做一个归纳。
排序算法
平均时间复杂度
最坏时间复杂度
空间复杂度
是否稳定排序
冒泡排序
O()
O(m)
(1)
稳定
鸡尾酒排序
O(7)
o(r)
O(1)
稳定
快速排序
o(piogr)
0(m)
Ofogri)
不稳定
堆排序
O(rlogr)
O(rlogn)
0(1)
不稳定
计数排序
Ojn+m)
O(n+m)
O(m)
稳定
桶排序
On)
O(rlogr)
 O(n)
稳定
第5章
面试中的算法
5.1
曙满志的小灰
---
## Page 268
大黄，我已经学到了很多
算法基础知识。应该可以
去面试了吧？
面试遇到的算法题目千变万
化，不但要依靠扎实的算法
基础，还需要随机应变。
去试试吧，小灰，即使面试
“挂”掉也不必泪丧，就当
是对白己的历练了。
别说这种不吉利的话
我
一定会把面试官说得心服
口服的！
这一章，我们开始讲解形形色色的算法面试题，其中有许多是面试过程
---
## Page 269
中常常遇到的经典题目。小灰究竞能不能面试成功呢？让我们为他加油
吧！
5.2
如何判断链表有环
5.2.1
一场与链表相关的面试
小灰。你好，我是公
司的面试官，请简单
介绍一下你自己，
好的
blah blah blah
下面我来考查你一道算法题。
题目
---
## Page 270
有一个单向链表，链表中有可能出现“环”，就像下图这样。
那么，如何用程序来判断该链表是否为有环链表呢？
5→3→7→2
哦，让我想想啊.....
有了！我可以从头节点开始遍历
整个单链表....
方法1：
首先从头节点开始，依次遍历单链表中的每一个节点。每遍历一个新节
点，就从头检查新节点之前的所有节点，用新节点和此节点之前所有节
点依次做比较。如果发现新节点和之前的某个节点相同，则说明该节点
被遍历过两次，链表有环；如果之前的所有节点中不存在与新节点相同
的节点，就继续遍历下一个新节点，继续重复刚才的操作。
---
## Page 271
5
3
就像图中这样，当遍历链表节点7时，从头访问节点5和节点3，发现已
遍历的节点中并不存在节点7，则继续往下遍历。
当第2次遍历到节点2时，从头访问曾经遍历过的节点，发现已经遍历过
节点2，说明链表有环。
假设链表的节点数量为n，则该解法的时间复杂度为O(n²）。由于并没
有创建额外的存储空间，所以空间复杂度为0(1)。
OK，这姑且算是一种方法，有没有效率
更高的解法？
哦，让我想想啊.....
---
## Page 272
或者，我创建一个哈希表，然
后..
方法2：
首先创建一个以节点ID为Key的HashSet集合，用来存储曾经遍历过的节
点。然后同样从头节点开始，依次遍历单链表中的每一个节点。每遍历
一个新节点，都用新节点和HashSet集合中存储的节点进行比较，如果
发现HashSet中存在与之相同的节点ID，则说明链表有环，如果HashSet
中不存在与新节点相同的节点ID，就把这个新节点ID存入HashSet中，
之后进入下一节点，继续重复刚才的操作。
遍历过5、3。
5
3
2
工
6
HashSet
53
遍历过5、3、7、2、6、8、1。
---
## Page 273
HashSet
5372681
当再一次遍历节点2时，查找HashSet，发现节点已存在。
8
C
HashSet
5372
681
由此可知，链表有环。
这个方法在流程上和方法1类似，本质的区别是使用了HashSet作为额外