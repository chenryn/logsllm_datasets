3.77
14.88
5.27
Table 3: Timings for number theoretic puzzles and hash based puzzles.
8. REFERENCES
[1] T. Aura and P. Nikander. Stateless connections. In
Y. Han, T. Okamoto, and S. Qing, editors, Proceedings
of the First International Conference on Information
and Communication Security, ICICS’97, Beijing,
China, November 11-14, 1997, volume 1334 of Lecture
Notes in Computer Science, pages 87–97. Springer,
1997.
[2] S. Babbage, D. Catalano, C. Cid, O. Dunkelman,
C. Gehrmann, L. Granboulan, T. Lange, A. Lenstra,
P. Q. Nguyen, C. Paar, J. Pelzl, T. Pornin, B. Preneel,
C. Rechberger, V. Rijmen, M. Robshaw, A. Rupp,
N. Smart, and M. Ward. ECRYPT yearly report on
algorithms and keysizes (2007–2008), July 2008.
[3] A. Back. Hashcash-a denial of service
counter-measure. URL: http://www. hashcash.
org/papers/hashcash. pdf, 2002.
[4] V. Boyko. A pre-computation scheme for speeding up
public-key cryptosystems. Master’s thesis,
Massachusetts Institute of Technology, 1998. Available
as http://hdl.handle.net/1721.1/47493.
[5] V. Boyko, M. Peinado, and R. Venkatesan. Speeding
up discrete log and factoring based schemes via
precomputations. In K. Nyberg, editor, Advances in
Cryptology - EUROCRYPT ’98, Proceedings of the
International Conference on the Theory and
Application of Cryptographic Techniques, Espoo,
Finland, May 31 - June 4, 1998, volume 1403 of
LNCS, pages 221–235. Springer, 1998.
[6] L. Chen, P. Morrissey, N. Smart, and B. Warinschi.
Security notions and generic constructions for client
puzzles. In M. Matsui, editor, Advances in Cryptology
- ASIACRYPT 2009, Proceedings of the 15th
International Conference on the Theory and
Application of Cryptology and Information Security,
Tokyo, Japan, December 6-10, 2009, volume 5912 of
Lecture Notes in Computer Science, pages 505–523.
Springer, 2009.
[7] C. Dwork and M. Naor. Pricing via processing or
combatting junk mail. In E. F. Brickell, editor,
Advances in Cryptology - CRYPTO ’92, Proceedings
of the 12th Annual International Cryptology
Conference, Santa Barbara, California, USA, August
16-20, 1992, volume 740 of Lecture Notes in Computer
Science, pages 139–147. Springer, 1992.
[8] S. D. Galbraith, J. M. Pollard, and R. S. Ruprai.
Computing discrete logarithms in an interval.
Cryptology ePrint Archive, Report 2010/617,
Accepted to Mathematics of Computation, 2010.
http://eprint.iacr.org/2010/617.
[9] R. Gennaro. An improved pseudo-random generator
based on discrete log. In M. Bellare, editor, Advances
in Cryptology - CRYPTO 2000, Proceedings of the
20th Annual International Cryptology Conference,
Santa Barbara, California, USA, August 20-24, 2000,
volume 1880 of Lecture Notes in Computer Science,
pages 469–481. Springer, 2000.
[10] M. Jakobsson and A. Juels. Proofs of work and bread
pudding protocols. In B. Preneel, editor, Secure
Information Networks: Communications and
Multimedia Security, IFIP TC6/TC11 Joint Working
Conference on Communications and Multimedia
Security (CMS ’99), September 20-21, 1999, Leuven,
Belgium, volume 152 of IFIP Conference Proceedings,
pages 258–272. Kluwer, 1999.
[11] A. Juels and J. G. Brainard. Client puzzles: A
cryptographic countermeasure against connection
depletion attacks. In Proceedings of the Network and
Distributed System Security Symposium, NDSS 1999,
San Diego, California, USA, pages 151–165. The
Internet Society, 1999. URL:
http://www.rsa.com/rsalabs/node.asp?id=2050.
[12] G. Karame and S. Capkun. Low-cost client puzzles
based on modular exponentiation. In D. Gritzalis,
B. Preneel, and M. Theoharidou, editors, Computer
Security - ESORICS 2010, Proceedings of the 15th
European Symposium on Research in Computer
Security, Athens, Greece, September 20-22, 2010,
volume 6345 of Lecture Notes in Computer Science,
pages 679–697. Springer, 2010.
[13] P. Nguyen, I. Shparlinski, and J. Stern. Distribution of
modular sums and the security of the server aided
exponentiation. In Proc. Workshop on Cryptography
and Computational Number Theory (CCNT’99),
Singapore, pages 257–268. Birkh”auser, 2001.
[14] P. Q. Nguyen and J. Stern. The hardness of the
hidden subset sum problem and its cryptographic
implications. In M. J. Wiener, editor, Advances in
Cryptology - CRYPTO ’99, Proceedings of the 19th
Annual International Cryptology Conference, Santa
Barbara, California, USA, August 15-19, 1999,
volume 1666 of Lecture Notes in Computer Science,
pages 31–46. Springer, 1999.
[15] S. Patel and G. S. Sundaram. An eﬃcient discrete log
pseudo random generator. In H. Krawczyk, editor,
Advances in Cryptology - CRYPTO ’98, Proceedings
of the 18th Annual International Cryptology
Conference, Santa Barbara, California, USA, August
23-27, 1998, volume 1462 of Lecture Notes in
Computer Science, pages 304–317. Springer, 1998.
[16] J. Rangasamy, D. Stebila, L. Kuppusamy, C. Boyd,
and J. M. G. Nieto. Eﬃcient modular
exponentiation-based puzzles for denial-of-service
protection. In International Conference on
Information Security and Cryptology (ICISC) 2011,
LNCS. Springer, 2012, To appear.
[17] R. L. Rivest, A. Shamir, and D. A. Wagner. Time-lock
puzzles and timed-release crypto. Technical report,
Cambridge, MA, USA, 1996.
[18] V. Shoup. Sequences of games: a tool for taming
complexity in security proofs. Cryptology ePrint
Archive, Report 2004/332, 2004.
http://eprint.iacr.org/.
[19] D. Stebila, L. Kuppusamy, J. Rangasamy, C. Boyd,
and J. M. G. Nieto. Stronger diﬃculty notions for
client puzzles and denial-of-service-resistant protocols.
In A. Kiayias, editor, Topics in Cryptology - CT-RSA
2011 - Proceedins of The Cryptographers’ Track at the
RSA Conference 2011, San Francisco, CA, USA,
February 14-18, 2011, volume 6558 of Lecture Notes in
Computer Science, pages 284–301. Springer, 2011.
[20] P. C. van Oorschot and M. J. Wiener. On
diﬃe-hellman key agreement with short exponents. In
U. M. Maurer, editor, Advances in Cryptology -
EUROCRYPT ’96, Proceeding of the International
Conference on the Theory and Application of
Cryptographic Techniques, Saragossa, Spain, May
12-16, 1996, volume 1070 of Lecture Notes in
Computer Science, pages 332–343. Springer, 1996.
[21] B. Waters, A. Juels, J. A. Halderman, and E. W.
Felten. New client puzzle outsourcing techniques for
DoS resistance. In V. Atluri, B. Pﬁtzmann, and P. D.
McDaniel, editors, Proceedings of the 11th ACM
Conference on Computer and Communications
Security, CCS 2004, Washington, DC, USA, October
25-29, 2004, pages 246–256. ACM, 2004.
APPENDIX
A. STATISTICAL DISTANCE FOR SOME
PARAMETER VALUES.
As the number of operations required to solve a puzzle
ranges from 0 to 225, it is enough for the server to choose N
and (cid:96) such that the indistinguishability bound is less than
or equal to , the bound for diﬃculty. Suppose the server
wants to ﬁx the diﬃculty Q of a puzzle to be 220 and the
40-bit security level k with a 512-bit modulus n. Let order
of g be M , where M is of length 80-bits. Then, from the
above table, it is clear that with 216 (xi, Xi) pre-computed
pairs, the server requires to perform only 7 ((cid:96) − 1) modular
multiplications to compute a pair (a, ga) on-line. Then it
can set the interval length to be 240 so that the best known
Q = 220 operations and the
solving algorithm requires
distinguishability is bounded by 2−20.
√
B. EXISTING ASSUMPTIONS
We begin by deﬁning the factorisation problem and inter-
val discrete log problem speciﬁcally for the RSA composite
modulus n.
Given a composite integer n such that n is a product of
two k-bit primes p and q, the factorisation problem is to
compute either p or q. The formal deﬁnition is as follows.
Definition 6. (Factorisation Problem) Let k be a secu-
rity parameter, let GenRSA be modulus generation algorithm,
and let A be a probabilistic algorithm. The experiment is as
follows. Run GenRSA(1k) to obtain (n, p, q), and then run A
on input n. The adversary wins the experiment if it outputs
either p or q (one of the non-trivial factors of n). We deﬁne
the advantage of A in violating the factorisation assumption
as AdvFactA,GenRSA(k) which is equal to
x = p or q : (n, p, q) ← GenRSA(1k), x ← A(n)
Pr
(cid:16)
(cid:17)
Recent recommendations on RSA key sizes [2] indicate
that the time required to factor an m-bit RSA modulus is
2s(m), where
s(m) =
log2(e)(m ln 2)
1
3 (ln(m ln 2))
2
3 − 14 .
(cid:19) 1
3
(cid:18) 64
9
The composite interval discrete logarithm problem IDL is
to compute x given an RSA modulus n = pq, an element y =
gx mod n for a random x where g is a random element in
n and an interval I of length Q such that x ∈ I. Formally:
Z∗
Definition 7. (Composite Interval Discrete Logarithm
Problem IDL) Let k be a security parameter, Q be a diﬃculty
parameter, and GenRSA be a modulus generation algorithm.
Let A be a probabilistic algorithm. Deﬁne the experiment
ExpIDLA,GenRSA,q(k) as follows:
1. n ← GenRSA(1k).
2. g ←R Z∗
3. r ←R [0, q − 1], I ← [x − r, x − r + Q].
4. x(cid:48) ← A(g, y, n,I).
n, x ←R [1, φ(n)], y ← gx mod n.
where B is an algorithm running in time O(t), and the second
inequality follows whenever Hρ is a pseudo-random function.
Since the function H in game G1 is truly random, the
probability that an adversary without access to H can guess
an output is negligible:
Pr(S1) ≤ 1
2k .
(14)
Combining equations (12)–(14), we obtain the ﬁnal result,
that the adversary’s success in forging a puzzle is negligi-
ble.
5. Output 1 if x(cid:48) = x and 0 otherwise.
The advantage of A in violating the IDL assumption is
AdvIDLA,GenRSA,Q(k) = Pr
ExpIDLA,GenRSA,Q(k) = 1
.
(cid:16)
(cid:17)
Galbraith et al. [8] have given the best algorithms to date for
solving the Interval Discrete Logarithm problem in a group-
√
agnostic manner, which have an average case expected run-
q. In groups over a composite
ning time of (1.660 + o(1))
modulus n where factoring n is hard, this remains the ex-
pected running time.
C. UNFORGEABILITY OF DLPuz
Definition 8. (Puzzle Unforgeability [6]) Let k be a se-
curity parameter, A be a probabilistic algorithm, and Puz be
a client puzzle. Deﬁne the experiment ExpUFA,Puz(k) as fol-
lows:
1. (params, s) ← Setup(1k).
2. Run A(params) with oracle access to CreatePuz(·) and
turn puz to A.
CheckPuz(·), which are answered as follows:
• CreatePuz(str, Q): puz ← GenPuz(s, Q, str). Re-
• CheckPuz(puz): If puz was not an output for any
of the CreatePuz(str) query made previously and
VerAuth(s, puz) = true then stop the experiment
and output 1. Otherwise, return false to A.
3. Output 0.
We say that A wins the game if ExpUFA,Puz(k) = 1 and loses
otherwise. The advantage of A is deﬁned as:
ExpUFA,Puz(k) = 1
AdvUFA,Puz(k) = Pr
(cid:16)
(cid:17)
.
A puzzle Puz is said to be unforgeable if this advantage is
negligible in k for all probabilistic algorithms A running in
time polynomial in k.
In this unforgeability experiment, the adversary is allowed
to query the CreatePuz oracle by choosing a str and a puzzle
diﬃculty level Q at will. This is to ensure that even after
seeing puzzles with diﬀerent diﬃculty levels, the adversary
cannot create a valid looking puzzle.
Theorem 4
(Unforgeability of DLPuz). The client
puzzle DLPuz is unforgeable.
Proof. We prove the theorem using a sequence of games.
Let A be a probabilistic algorithm with running time t. Let
Si be the event that A wins in game Gi.
Let G0 be the original unforgeability game ExpUFA,DLPuz(k).
ExpUFA,DLPuz(k
(cid:48)
) = 1
= Pr(S0) .
(12)
(cid:16)
Game G0.
Then
Pr
Game G1.
(cid:17)
In this game, we modify game G0 by replacing the HMAC
Hρ with a truly random function H to compute z. This
change has a negligible eﬀect on adversary A because of the
pseudo-randomness of HMAC Hρ. Hence,
| Pr(S0) − Pr(S1)| ≤ AdvHM AC
B
(k) ≤ negl(k)
(13)