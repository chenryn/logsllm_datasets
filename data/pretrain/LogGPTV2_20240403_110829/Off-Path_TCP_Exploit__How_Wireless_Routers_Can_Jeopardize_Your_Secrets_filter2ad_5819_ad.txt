versus zero cannot create signiﬁcant enough of a timing
channel. In addition, if a packet with in-window ACK
number has no payload, Linux also ignores the packet
with no response (row no. 6), which leaves no oppor-
tunity to differentiate the in-window and out-of-window
cases (result similar to row no. 2 and 3). However, it
does correctly handle packets with payload; a response
is triggered only when the ACK number is in window
(row no. 5). The issue is that when an ACK number is
inferred, the client buffers the payload in its receive win-
dow, which is undesirable for two reasons: (1) it may
cause future server’s responses to be corrupted; (2) if
selective ACK (SACK) is enabled, the client selectively
acknowledges the data which has not actually been sent
by the server, causing the server to ignore future packets
from the client, effectively de-synchronizing the client
and server. Interestingly, Linux has a special edge case
that allows us to infer ACK number without the hassle.
According to the speciﬁcation, if the sequence number of
an incoming packet is equal to RCV.NXT-1 (indicating a
keep-alive message), it should trigger an ACK. Interest-
USENIX Association
27th USENIX Security Symposium    1589
ingly, the speciﬁcation has an ambiguity. RFC 1122 [43]
speciﬁes only the valid sequence number of a keep-alive
packet, but not the ACK number. Based on the source
code, Linux does not actually handle keep-alive explic-
itly. Instead, it simply treats such a packet (with one-byte
payload and end seq = RCV.NXT) as in-window, and
decides how to respond based on its standard ACK num-
ber check. Therefore, in-window ACK numbers with the
speciﬁc sequence number (i.e., RCV.NXT-1) still trigger
responses (row no. 9) and yet no actual data are buffered
at the client, while out-of-window ACK numbers can
trigger at most one reply (line 7 and 8 in Table 2).
MacOS. Based on the source code and experiments, ma-
cOS explicitly handles keep-alive packets and always
responds with an ACK regardless of the ACK number
so the strategy against Linux does not apply to macOS.
On the other hand, macOS has its own implementation
of ACK number validation which correctly responds to
packets with ACK numbers that are too new (row no.
13). Interestingly, it chooses not to reply to packets with
ACK numbers that are too old when there is no payload
(row no. 12). The implementation of macOS is likely
to be misled by the old statement in RFC 793 that states
packets with ACK numbers smaller than SND.UNA can
be ignored, which is reinterpreted in RFC 5961 (quote):
“All incoming segments whose ACK value doesn’t sat-
isfy the above condition MUST be discarded and an ACK
sent back”, where the “above condition” is the acceptable
window of [SND.UNA - MAX.SND.WND, SND.NXT]. In
summary, this non-compliant behavior of macOS allows
an attacker to infer if a guessed ACK number is too large
or too small, resulting in a binary search.
Windows. Windows is for the most part similar to Linux
on the ACK number validation, except that it has made
one subtle customization.
Initially, we were surprised
to ﬁnd that an incoming data packet with an in-window
sequence number is always silently dropped unless the
ACK number is equal to SND.UNA or SND.NXT (the con-
nection is idle during our initial experiments so the two
numbers are equal). This implementation is not con-
formant to the standard at all. Recall the standard says
that the acceptable ACK number range is deﬁned to be
[SND.UNA - MAX.SND.WND, SND.NXT] in RFC 5961
and both Linux and macOS follow the standard. In fact,
we thought the implementation was completely wrong
because it may drop legitimate data packets in cases like
out-of-order packet arrivals. We then realize that it ap-
pears to be a reasonable decision, especially when the
connection is idle.
Indeed, if there are no outstanding
data to send, it is safe to require the peer to acknowledge
one and only one ACK number. However, as soon as
there are outstanding data, it should enlarge the accept-
able ACK number range. We experimentally conﬁrmed
that this is exactly what Windows does. In summary, the
behavior of Windows still allows ACK number inference
when it has outstanding data during the inference. This
makes our attack in §5.3 more complicated but still pos-
sible by taking advantage of the behaviors in row no. 18
and 24.
5
Implementation
Now that we know the Wi-Fi timing side channel applies
universally to all operating systems, we want to test them
in real-world attack scenarios.
5.1 Connection (Four-tuple) Inference
General method. The general probing strategy is al-
ready discussed in §4. In our implementation, we con-
servatively test one port every round with 30 repeated
packets, followed by a post-probe query to measure RTT.
When a guessed port number is correct, we see a sub-
stantial increase in the measured RTT. If the goal is to
infer the presence of any arbitrary connection initiated
by the client, then a bruteforce strategy is all that can be
done. However, if the attacker is attempting to conduct
web cache poisoning attack later on, it is possible to tar-
get a connection initiated by the puppet itself [25], which
opens up an additional optimization below taking advan-
tage of the ephemeral port selection algorithm employed
by different OSes.
Windows and macOS. They use a global and sequential
port allocation strategy to select ephemeral port number
for their TCP connections. This means that the attacker
can deduce the next port number to be used once it ob-
serves the initial connection to the malicious web server.
This eliminates the need of port number inference com-
pletely.
Linux.
It uses the Simple Hash-Based Port Selection
(SHPS) [27] where there is an independent local port
number space for each remote IP and port pair. This
means that the local port number observed from the con-
nection to the malicious web server can no longer predict
the next local port number for the connection to a differ-
ent target server which the attacker does not control. To
avoid bruteforcing all possible port numbers, we develop
an optimized strategy based on the observation that local
port numbers allocated for the same remote server and
port pair are sequential; therefore, the puppet can poten-
tially create n connections to the target server and only
needs to test the port number every n increments.
At this point, we can conduct the side channel attack
on the connection of which we guessed the correct port
number. Also, by carefully scheduling those n requests
we are guaranteed that a future request will use the con-
nection with the smallest port number as opposed to the
1590    27th USENIX Security Symposium
USENIX Association
others closed later.
NAT. In our experience with Wi-Fi routers, we ﬁnd that
they typically are port preserving. So we do not have
to worry about the external port being translated and be-
come unpredictable. This is based on our testing of 4
different home routers and the university network. How-
ever, if non-port-preserving NAT are indeed used for Wi-
Fi, then the attacker can either fall back to the brute-
force approach, or apply the optimized solutions pro-
posed in [27] (which has its own beneﬁts and caveats).
Multiple IP addresses from a domain. This essentially
requires the attacker to double or triple the effort of port
number inference. For Windows and macOS, this is not
much more effort. However, for Linux it does require
some more time.
5.2 Sequence Number Inference
General method As shown in table 2, we’re able to
distinguish in-window sequence number from out-of-
window one by leveraging timing side channel to tell
whether there are corresponding responses. As soon as
we get an in-window sequence number, we further nar-
row down the sequence number space to a single value
RCV.NXT by conducting a binary search. This is similar
to prior work [39, 18]. Similar to connection inference, if
the attacker is attempting to conduct web cache poison-
ing attack against a connection initiated by the puppet
itself [25], an additional optimization is possible.
Optimization:
Increase window size. To substan-
tially decrease the number of iterations of guesses, one
straightforward approach is to drastically enlarge the
client’s receive window. To this end, the puppet can re-
quest excessive amounts of large objects. Upon the re-
ceipt of enough full segments, the receiver would sig-
niﬁcantly increase its receive window size according to
TCP ﬂow control.
In our experiments, we found that
the window size could be typically scaled up to around
x = 500,000, in striking contrast to the original size (e.g.,
65,535). It’s worth noting that the window size can never
be shrunk once it is enlarged, according to RFC793 [4].
Similarly, by uploading data, the ACK window (i.e., the
peer’s sequence window) can be extended, though it’s
usually much smaller than the maximum sequence win-
dow size that we can achieve.
5.3 TCP Hijacking
We assume in this section that the attacker is attempting
to poison the web cache through hijacking the puppet-
initiated connection, which enables the attack to be more
efﬁcient. In principle, the attacker can hijack any con-
nection initiated by the client; it is simply more difﬁcult
to control the timing and predict what fake response to
inject.
Since all three systems do not comply with the speciﬁ-
cations in terms of ACK validation, we have to cope with
each variant differently:
MacOS incorrectly interpreted the standard, allowing us
to perform a binary search (see §4). Once the expected
ACK number is inferred, we perform a desynchroniza-
tion attack [18] to avoid a race condition where the re-
sponse is sent back by the server ﬁrst. Then, as soon as
the puppet requests for the target object, it informs the
attacker to send a spoofed response, which is accepted.
Linux It’s feasible to exploit the timing side channel to
infer ACK number, though the valid ACK window size
is much smaller compared to the receive window size,
resulting in longer inference time. One alternative ap-
proach is to conduct blind data injection without know-
ing the exact value of the expected ACK number. Our
observation is that by now we’ve known the exact se-
quence number and the size of any object that the client
retrieves (see §5.4), we are capable of predicting a fu-
ture expected sequence number after N objects are re-
trieved. The attack then goes as follows: (1) Desynchro-
nization. The puppet keeps requesting an object, while
the attacker sends a number of spoofed packets with the
same in-window sequence number that matches a fu-
ture RCV.NXT, bruteforcing the ACK numbers (which is
much faster than side channel attack as there is no wait
for any feedback). When the last valid response comes
back advancing the sequence number to the value we an-
ticipate, suddenly the attacker-injected response will be
appended and forwarded together to the browser (and
yet the browser always has only one pending request).
Chrome will close the connection, stopping the attack;
in contrast, Firefox will simply accept the ﬁrst response,
ignoring the second one, resulting in desynchronization
between the client and server (i.e., the client believes it
has received more data than the server has actually sent).
(2) Blind data injection. Now the puppet will switch
the target web object to the one we want to attack (i.e.,
homepage of a banking website). The attacker now has
enough time to send a valid response. Since the attacker
knows the next expected sequence number, it only needs
to again bruteforce all possible ACK numbers. Note that
this strategy requires two rounds of bruteforcing of ev-
ery possible ACK number, and each round takes only a
couple of seconds as there is no waiting. In contrast, a
side channel attack would take much longer (minutes)
because every guessed ACK number takes 30 packets,
and the timing measurement needs to be collected before
the next guess can be made.
Windows As we mentioned in §4, to prevent the valid
ACK window size being one-byte only, the client has to
USENIX Association
27th USENIX Security Symposium    1591
keep sending requests to make sure there are always out-
standing data, which complicates our attacks because the
attacker has to synchronize the next expected sequence
number. Besides, a large amount of trafﬁc also intro-
duces noise to the timing side channel. Moreover, the
blind data injection we utilize on Linux does not apply
to the same version of Firefox on Windows according
to our tests; it immediately drops the connection when
it receives two responses for only one pending request.
We therefore devise a new strategy that exploits the TCP
behavior of handling overlapping data and the browser
behavior of handling corrupted HTTP responses.
If a
new incoming TCP data packet has an overlapping se-
quence number range with some previously buffered
data, we ﬁnd that old data are always preferred in Win-
dows whereas new data are preferred in Linux (this ob-
servation is consistent with prior studies [38]). In other
words, attacker-injected data buffered on a Windows host
can corrupt a real HTTP response from the server. Given
the insight, we present the exploit in two steps which
are illustrated in Fig. 8: (1) Inject. The puppet continu-
ously requests scripts from the server, while the attacker
sends 232
spoofed packets with a deliberate in-window
|wnd|
sequence number that matches a future RCV.NXT plus a
small offset, where wnd denotes the size of the accept-
able ACK window. The ith packet has a guessed ACK
number i·|wnd|, and contains payload as:
websocket.send(i·|wnd|)
Hence, exactly one of these packets contains a valid
ACK number and will be buffered. We intentionally
construct the overlap such that the HTTP header of the
real response will become corrupted. Interestingly, the
browser would still try to interpret the corrupted response
where it simply ignores corrupted header and accepts the
next header (injected by the attacker) along with the re-
maining attack payload. When the browser executes the
injected script, it will send the guessed ACK number
via websocket, providing a valid in-window ACK num-
ber. (2) Exploit. Since the client has accepted the extra
spoofed payload, advancing its expected sequence num-
ber, the client and server are effectively already desyn-
chronized. The attacker can now simply send a spoofed
response (knowing both the expected sequence number
and a valid ACK number). Alternatively, if we only
want to perform a one-time injection, simply replacing
the payload in the ﬁrst step with a malicious script is suf-
ﬁcient. Note that the attack strategy against Windows is
even more efﬁcient than the one for Linux because only
one round of bruteforcing of ACK numbers is needed.
Furthermore, there exists an even more general alter-
native strategy to the inject step against Windows that
does not depend on browser behaviors at all. Speciﬁ-
cally, as the ﬁrst few bytes of HTTP responses are pre-
Initial
Sequence
Number 
(Known)
Predicted 
Sequence 
Number + 
Offset
offset
.
.
.
…
X Responses
Overwritten 
Response
Spoofed responses 
(sent in advance)
 with all guessed
 ACK numbers
Packet with acceptable 
ACK number
Old data overruns 
new data
Figure 8: HTTP injection by exploit tolerant browsers
dictable (i.e., HTTP), instead of corrupting the real re-
sponse, one overwrite the header and the body to form
a legitimate but malicious response. A browser in this
case will be completely oblivious to the existence of in-
jection. This demonstrates that once sequence number
is leaked, there exist various ways to inject data into
browsers efﬁciently, without conducting the much slower
timing-channel-based ACK number inference.
5.4 Other Challenges
Dealing with noise by setting a proper threshold. La-
tency may vary under different network conditions, thus
it is a bad idea to manually set a threshold to differenti-
ate a quiet probe round (without triggering ACKs) ver-
sus a responsive probe round (triggering ACKs). In our
implementation, we devise a simple procedure that auto-
matically sets a threshold based on a preliminary round
of test probes prior to launching the actual attack. Since
we have full control of the connection established be-
tween the client and attacker, we can send non-spoofed
packets to measure RTTs for quiet probe rounds and re-
sponsive probe rounds. After we collect data for both
cases, we sort the data and set a threshold such that 80%
of the responsive round measurements will be above the
threshold. The threshold is a trade-off between efﬁciency
and effectiveness. Since most of the rounds we’re testing
do trigger ACKs (so larger RTTs should be observed),
setting a lower threshold will ensure that we correctly
classify such cases to avoid double checking the results.
However, a threshold too low runs the risk of misclas-
sifying a quiet round into a responsive round, missing
the correct guess altogether; this forces us to repeat the
whole search process. Finally, we ignore cases where
abnormally large RTT values are perceived (e.g., from
network noise), if it is out of the range of three times the
standard deviations.
Dealing with noise by error recovery. Even with a
properly selected threshold, we may still end up with in-
correct inferences. We cope with this challenge by em-
bedding extensive error recovery mechanisms into the in-
1592    27th USENIX Security Symposium
USENIX Association
ference process, such as relative comparisons and double
checking. We assume that network jitter/noise does not