ViewOfSection” in ntdll.dll. Note that “LdrpMapDll” calls “NtMap-
ViewOfSection” twice at most. The first time happens at line 6. If
the return value of this call is “STATUS_IMAGE_NOT_AT_BASE”,
it indicates the DLL has to be relocated to new memory space, and
“NtMapViewOfSection” will be invoked again at line 16. The key of
our method is to intercept the “NtMapViewOfSection” at line 6. And
then, we redirect “*BaseAddress” to the memory loading address
of our custom-made DLL. Also, we enforce “NtMapViewOfSection”
returning “STATUS_IMAGE_NOT_AT_BASE” (line 7). In this way,
the code from line 8 to 17 are activated, and our custom-made DLL
will be loaded eventually. Appendix Algorithm 2 shows the detailed
algorithm of loading custom-made DLL.
Figure 4 illustrates how we hijack standard DLL loading. We use
the kernel-level hooking to intercept the original DLL loading flow
and hijack the target DLL (including core DLL) with our custom-
made DLL. “MyNtMapViewOfSection” intercepts the original con-
trol flow and maps custom-made DLL to memory. The monitor
code in custom-made DLL conducts rebuilt IAT identification, OEP
search, and process dump if necessary. If the IAT is not rebuilt at
run time, the monitor code will forward the control flow to the real
API in target DLL. Compared to other API hooking methods, our
approach has many advantages such as being compatible with the
target process and aware of user-level API semantics. These bene-
fits enable BinUnpack to reveal better resilience to the common
hook evasions adopted by packers (see Table 1).
4.4 Non-Standard Explicit Linking
We have to consider the non-standard implementations of expli-
cit linking, because malware authors have already adopted them
to evade the hooking of “LoadLibrary”. The first way is to re-
implement the functionality of “LoadLibrary” by calling “Crea-
teFileMapping” and “MapViewOfFile” [57]. However, this custom
loader still eventually invokes “NtMapViewOfSection” to load DLL.
Our kernel-level hooking of “NtMapViewOfSection” is capable of
Map target DLL to memoryTarget DLLMyNTMapViewOfSectionNTMapViewOfSectionUser SpaceKernel SpaceWalking Call ChainKernel-levelHookingMap custom-made DLL to memoryOriginal Execution FlowKernel-level DLL Hijacking Execution FlowCustom-made API1Custom-made APIn………Orignal API1Orignal APIn………Custom-made DLLCustom-made API2Orignal API2 Monitor CodeForward Monitor CodeForward Monitor CodeForwardLoadLibraryCustom LoaderorSession 3A: Binary Analysis CCS’18, October 15-19, 2018, Toronto, ON, Canada401dealing with this case. Another recent work, Stealth Loader [39],
avoids the use of file-map APIs such as “CreateFileMapping” via
reflective DLL injection technique [22]. It calls “CreateFile”, “Re-
adFile”, and “VirtualAlloc” to map a DLL into non-file-mapped
memory at the expense of large memory footprint. This means
Stealth Loader does not go through “NtMapViewOfSection” at all.
However, Stealth Loader’s trace is not invisible. For example, it
calls “CreateFile (“kernel32.dll”)” to open a DLL before it allocates
virtual memory for the DLL. We captures this characteristic feature
by kernel-level hooking of “NtCreateFile” to open our home-made
DLL. In this way, we can monitor the APIs loaded by Stealth Loader.
5 IAT COMPARISON
As shown in Figure 4, the custom-made DLL in BinUnpack is used to
mimic the target DLL we want to hijack. We automatically generate
the custom-made DLL from the target one and attach the monitor
code to each custom API. Algorithm 1 uses the “DeleteFile” in
kernel32.dll as an example to show how the custom-made DLL
works. We follow the similar approach with QuietRIATT [78] to
get current IAT using hooked DLL calls (line 6). The key idea is to
find indirect call pattern via stack backtrace [24]. Line 7 compares
two IATs in terms of different memory locations or contents.
One complicated case to IAT comparison is that an attacker
could apply multiple packer combinations. That is, the innermost
packed code and unpacking routine are further packed by another
packer. Similarly, the IAT of inner unpacking routine has to be
first erased and rebuilt later. In this case, we will see the behaviors
of multiple phases “rebuilt-then-called”. Therefore, we add a new
global variable “lastIAT” in Algorithm 1 to represent the last rebuilt
IAT. The initial value of “lastIAT” is the unpacking routine IAT of
the outermost packer (line 2–4). If “currentIAT” is different from
“lastIAT”, it indicates there is a new phase of “rebuilt-then-called”.
Otherwise we forward the execution flow to the original API to
continue the execution of unpacking routine (line 14). Following
line 7, we perform backtrack search for OEP (line 8). If we find
OEP (line 9), we will first restore the unpacked code protected by
this packer (line 10) and then update “lastIAT” (line 11) for the
next round comparison. Following this style, Algorithm 1 is able to
recover the packed code protected by each packer and finally get
the original malware payload. In our evaluation, handling multiple
packer combinations only leaves little impact on BinUnpack’s per-
formance, but it imposes significant performance degradations on
traditional generic unpacking tools (see Table 3).
6 OEP SEARCH & PROCESS DUMP
The original entry point (OEP) is the first instruction of the resto-
red code. A wrong OEP will mislead a disassembler to produce
incorrect instruction. Although the previous work has proposed
many effective heuristics to find the existence of OEP such as stan-
dard compiler signature [36], dangerous API call [28], cross-section
jump [76], and yara rules [55], they still suffer from very large OEP
search space. Recall that the reconstruction of payload IAT comple-
tes before the recovered payload resumes execution. We can utilize
the API calls respectively from unpacking routine and payload to
narrow down the OEP search space. As shown in Figure 6, we
Algorithm 1 Custom-made API (MyDeleteFile)
lpFileN ame: The name of the file to be deleted.
lastIAT : A global variable representing the last rebuilt IAT.
if lastIAT = ∅ then
routineIAT ← GetUnpackingRoutineIAT()
lastIAT ← routineIAT
end if
currentIAT ← GetCurrentIAT()
if currentIAT (cid:44) lastIAT then // IAT Comparison
1: function MyDeleteFile(lpFileN ame)
2:
3:
4:
5:
6:
7:
8:
9:
10:
11:
12:
13:
14:
15: end function
OEP ← BacktrackOEP()
if OEP (cid:44) ∅ then
ProcessDump()
lastIAT ← currentIAT
end if
return DeleteFile(lpFileName)
end if
Figure 6: API monitoring limits the search scope of OEP.
Kernel-level hooking alone will miss the checkpoint “T1”.
first find the checkpoint for the last “GetProcAddress” used to re-
build the payload’s IAT (“T1” in Figure 6), and then we identify the
checkpoint for the first API call from the payload (“T2”). Obviously,
the memory search scope of OEP is limited by the upper bound
“T1” and the lower bound “T2”. Next BinUnpack backtracks from
“T2” to ‘T1” to search OEP using the same heuristics as Arancino
unpacker [76]. Our approach can reduce the possible OEP search
scope remarkably. For example, when unpacking the hupigon.eyf
protected by Armadillo, PinDemonium [55] has to search as much
as 21, 548 instructions before locating OEP. By contrast, BinUnpack
only goes through 19 instructions. In our large-scale evaluation,
the maximum number of instructions from “T2” to OEP is 168, and
the average value is 32.
Home-Made API Implementation Like the custom loader we
have discussed in Section 4.4, malware authors can also implement
the functionality of “GetProcAddress” by searching DLL module’s
export directory [57]. In this way, hooking “GetProcAddress” will
miss the checkpoint “T1”. As “GetProcAddress” does not invoke
any native API, kernel-level hooking does not work either. We
adopt existing work in scalable and obfuscation-resilient binary li-
brary function matching, BinShape [87], to fast identify the specific
memory patters of API custom implementation. BinShape deri-
ves heterogeneous features to represent library function, covering
control flow graph, instruction-level, and statistical features. The
detailed evaluation data is shown in Table 7.
Rebuild Payload IAT: hModule=Loadlibrary (“kernel32.dll” );   GetProcAddress (hModule,API1  );     GetProcAddress (hModule,API2  );       ……         GetProcAddress (hModule,APIn  );T1: The last “GetProcAddress” callT2: The first  API call OEPJump to OEPTimelinePayload ExecutionMulti-layer UnpackingSession 3A: Binary Analysis CCS’18, October 15-19, 2018, Toronto, ON, Canada402of an impact on BinUnpack’s performance. However, a determi-
ned attacker can perform a Denial-of-Service (DoS) attack; that is,
performing many iterations of Evasion II & Evasion III.
We do not treat this extreme case as a hard limit. Compared to
multiple “written-then-executed” layers, multiple phases of “rebuilt-
then-called” will impose dramatically large overhead to packed
malware itself, because API calls are much more expensive than the
read and write instructions. To evaluate the impact of DoS attacks to
BinUnpack, we have simulated Evasion II & Evasion III in the open-
source UPX packer. As shown in Table 2, the BinUnpack’s overall
running time is pretty small when the iterations of Evasion II & III
are less than 106. When the iteration number reaches 109 times, the
DoS-UPX will introduce as much as 106 X additional slowdown, and
BinUnpack will be occupied by OEP search. To proactively mitigate
this possible attack, we have applied an advanced bioinformatics-
inspired system call sequence alignment, MalGene [42] to bypassing
fake API calls in two runs. Particulary, in the first run, we only
enable BinUnpack’s API monitor function and MalGene so that
MalGene can identify the scope of Evasion II and Evasion III. In
the second run, we only enable BinUnpack’s unpacking function
when the current API is not in the scope of Evasion II or Evasion III.
In this way, for the extreme case of 109 iterations, we can reduce
BinUnpack’s running time to less than 158 minutes.
7.2 Attacks to Kernel-level DLL Hijacking
As the core of BinUnpack’s API monitor is kernel-level dll hijacking,
this section discusses possible attacks to this component.
Kernel-level Hooking Detection It has become much harder for
malware to be loaded into the kernel space and defeat BinUnpack’s
API monitoring. Since Windows 64-bit Vista released in 2007, Mi-
crosoft has employed a new security mechanism, called “Mandatory
Driver Signing”, to prevent the OS kernel hacked by malware [75].
“Mandatory Driver Signing” requires that all kernel-mode drivers
to be digitally signed to verify code integrity.
DLL Integrity Check Another possible evasion is to check the
integrity of a DLL. As Microsoft’s DLLs such as kernel32.dll are
publicly available, the packer could calculate kernel32.dll’s hash
value offline and compare with the hash value of the dll in memory
at run time. Since BinUnpack has substituted the kernel32.dll at
load-time with our custom-made DLL, whose hash value is different
from the original one. However, the released Windows OS has too
many different versions, and verifying all possible hashes is not
a trivial task for attackers either. Nevertheless, we have extended
BinUnpack with a memory subversion technique [25], Shadow
Walker rootkit [90], to bypass DLL integrity checking. The basic
idea is to forward the data access of the custom-made DLL to the
target DLL and the code access of the custom-made DLL to itself.
Therefore, the hash value used in integrity check is calculated from
the target DLL instead of the custom-made DLL.
8 EVALUATION
We collect total 271, 095 malware samples from three different
malware repositories: VX Heaven12, VirusShare13, and VirusTotal.
These malware samples cover major malware categories such as
12http://vxheaven.org/
13http://virusshare.com/
Figure 7: The possible evasions against “rebuilt-then-called”
behavior.
Many packers also adopt anti-dumping tricks to prevent obtai-
ning unpacked code from memory. One common way is to modify
the access attribute of PE head in memory to “NO_ACCESS”. As a
result, the dumping tools will crash when access the PE head. Bin-
Unpack relies on the state-of-the-art process dump tool, Scylla [1].
In our evaluation, Scylla achieves the optimal results when hand-
ling anti-dumping techniques. With the original payload produced
by process dump, applying further malware code analysis such as
binary code disassembly [9, 45], binary diffing [23, 63], and large-
scale malware clustering/lineage [29, 32] becomes straightforward.
7 POSSIBLE ATTACKS AND
COUNTERMEASURES
Although BinUnpack is conceptually simple, we show in Section 8
that it is able to recover the original code with very high accuracy
and efficiency. Even so, we have to consider how a skilled attacker
could circumvent BinUnpack once our approach is known. This
section discusses possible attacks and our countermeasures.
7.1 Attacks to “Rebuilt-then-Called”
The key idea of our approach is to quickly determine the end of
unpacking by capturing “rebuilt-then-called” behavior. Figure 7
shows three possible ways to evade/attack this key feature.
Malware with no IAT (Evasion I in Figure 7) In Section 2.2, we
have discussed two exceptions that malware can have no IAT and
their practical constraints. Developing malware samples with hard-
coded API addresses or shellcode can hinder their executions and
propagations on diverse victim machines. Therefore, we consider
these two corner cases too unreliable to be a real threat.
Fake Rebuilt IAT and Fake API Call Like the multiple “written-
then-executed” layers in a single packer, an intuitive attack to Bin-
Unpack is also generating multiple phases of “rebuilt-then-called”.
For example, a single packer can rebuilt a fake IAT and call APIs
from it (Evasion II in Figure 7). Similarly, after rebuilding the origi-
nal IAT, the packer can invoke a fake API call before control flow
jumps back to OEP (Evasion III in Figure 7). Note that both Evasion
II and Evasion III can only trigger BinUnpack searching OEP but
no process dump, because no OEP will be detected in these two
evasions (see Algorithm 1). As BinUnpack’s OEP search is efficient
(see Section 6), limited times of Evasion II and III do not have much
Jump to OEPTimelinePayload ExecutionT1:Rebuild Original IATEvasion Ⅰ: Malware with no IATMulti-layer Unpacking Evasion Ⅱ : Multiple phases of rebuilt-then-called Evasion Ⅲ : Fake API call  from the rebuilt original IATUnpacking routineOriginal CodeSession 3A: Binary Analysis CCS’18, October 15-19, 2018, Toronto, ON, Canada403Table 2: Running time (seconds) of Evasion II & Evasion III DoS attacks. They have relatively small impact on BinUnpack.
Sample
UPX
UPX+(Evasion II & III)×103
UPX+(Evasion II & III)×106
UPX+(Evasion II & III)×109
No BinUnpack (s)
0.12
0.24
122
122,472
BinUnpack (s)
IATComparison OEPSearch
3.5×10−6
7.4×10−3
2.1×10−5
2.3×10−3
Dump
3.1×10−2
3.1×10−2
3.1×10−2
3.1×10−2
Total
3.1×10−2
4.1×10−2
9.5
9,495
Relative Slowdown
25.8%
17.1%
7.9%
7.8%
2.2
2,231
7.3
7,264
backdoor, worm, trojan, and virus, including now-infamous ran-
somware families. The active time of these samples ranges from
2008 to 2018. As far as we know, our work is the first one to evaluate
generic binary unpacking on such a scale. Our testbed is a consu-
mer grade laptop with an Intel Core i3-36100 processor (Quad Core,
3.70GHz) and 8GB memory, running Windows 7. We have used pac-
ker signature matching tool Exeinfo PE14 and PEiD15 to rule out the
non-packed samples and the ones that are only protected by code
virtualization, which is out of BinUnpack’s coverage. Eventually,
we obtained 238, 835 packed malware binaries. 75.8% of them are
from known packers, and the left (24.2%) are protected by unknown
packers. We also find that custom packers have been quite common
among new-generation malware such as ransomware.
8.1 Comparative Evaluation
We perform comparative evaluation to accurately evaluate Bin-
Unpack’s effectiveness and performance with the malware samples
that we have ground truth. That is, we either have their source
code or we are able to manually verify the unpacking result. Table 3
shows the results on a set of packed versions of our motivating
example—hupigon.eyf. This experiment represents a typical sce-
nario that malware authors generate new variants by applying
different packers. They may select the optimal one that achieves
the best evasion effect to propagate.
The first column of Table 3 lists all of the packers we have tested,
including known packers and packer combinations. The second
column shows “the number of layers/original code layer” for these
packers. We can see that most of the packers are multi-layer packers,
and some packers do not reveal the original code in the deepest
layer (the number in bold). For example, ACProtect packer has the
most 216 layers, but the original code locates at the second layer.
The numbers in the third column represent API numbers in the
unpacking routine IAT, which confirms that erasing the payload
IAT is very common for packers. All of these numbers are less than
the number of hupigon.eyf’s imported APIs (575), and many packer