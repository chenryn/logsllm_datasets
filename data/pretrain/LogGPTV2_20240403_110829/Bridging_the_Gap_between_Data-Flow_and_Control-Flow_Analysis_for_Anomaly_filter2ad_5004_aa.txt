title:Bridging the Gap between Data-Flow and Control-Flow Analysis for Anomaly
Detection
author:Peng Li and
Hyundo Park and
Debin Gao and
Jianming Fu
2008 Annual Computer Security Applications Conference
2008 Annual Computer Security Applications Conference
Bridging the Gap between Data-ﬂow and Control-ﬂow Analysis
for Anomaly Detection∗
Peng Li
Hyundo Park
University of North Carolina at Chapel Hill
Korea University, Seoul, Korea
PI:EMAIL
PI:EMAIL
Debin Gao
Jianming Fu
Singapore Management University, Singapore
Wuhan University, Wuhan, China
PI:EMAIL
PI:EMAIL
Abstract
Host-based anomaly detectors monitor the control-ﬂow
and data-ﬂow behavior of system calls to detect intrusions.
Control-ﬂow-based detectors monitor the sequence of sys-
tem calls, while data-ﬂow-based detectors monitor the data
propagation among arguments of system calls. Besides
pointing out that data-ﬂow-based detectors can be layered
on top of control-ﬂow-based ones (or vice versa) to improve
accuracy, there is a large gap between the two research di-
rections in that research along one direction had been fairly
isolated and had not made good use of results from the other
direction.
In this paper, we show how data-ﬂow analysis can lever-
age results from control-ﬂow analysis to learn more accu-
rate and useful rules for anomaly detection. Our results
show that the proposed control-ﬂow-analysis-aided data-
ﬂow analysis reveals some accurate and useful rules that
cannot be learned in prior data-ﬂow analysis techniques.
These relations among system call arguments and return
values are useful in detecting many real attacks. A trace-
driven evaluation shows that the proposed technique enjoys
low false-alarm rates and overhead when implemented on
a production server.
1
Introduction
Many host-based anomaly detectors have been proposed
to monitor system calls. Some of these detectors [5–8, 13,
∗
This research was mostly done when the ﬁrst two authors, Peng Li
and Hyundo Park, were researchers working in Singapore Management
University. The project was partially supported by NSF China under the
agreement 90718005, and by MIC Korea under the ITRC support program
supervised by IITA (IITA-2008-(C1090-0801-0016)) and the IT R&D pro-
gram of MKE/IITA (2008-S-026-01).
17, 19, 20] monitor the sequence of system calls emitted by
the application and utilize control-ﬂow information of the
system calls for intrusion detection. Control-ﬂow-based de-
tectors have been shown to be effective in detecting intru-
sions, e.g., code-injection attacks, because many such in-
trusions change the control ﬂow of the program to make
additional system calls.
Some detectors [2, 11, 15, 16], on the other hand, moni-
tor the arguments of system calls and use the data-ﬂow in-
formation for intrusion detection. Monitoring system call
arguments has the advantage of detecting more stealthy at-
tacks that do not change the control ﬂow of the program
but merely change system call arguments. Despite the suc-
cess of many data-ﬂow techniques, research has not been
done on how data-ﬂow analysis can leverage the results
from control-ﬂow analysis to detect intrusion. Bhatkar [2]
pointed out that making use of control-ﬂow context can help
learning data-ﬂow properties, but all it does was to make
use of the program counter information to differentiate in-
structions at different locations in a program. To show how
control-ﬂow information could give further help in data-
ﬂow analysis, please refer to a simple example in Figure 1.
fd = open(dir, "r");
read(fd, buf, size);
Block A
fd1 = open(dir1, "r");
fd2 = open(dir2, "w");
read(fd1, buf, size);
write(fd2, buf, size);
Block B
fd1 = open(dir1, "r");
if (need_to_write)
fd2 = open(dir2, "w");
read(fd1, buf, size);
if (need_to_write)
write(fd2, buf, size);
Block C
Figure 1. Control-ﬂow information helps data-
ﬂow analysis
1063-9527/08 $25.00 © 2008 IEEE
1063-9527/08 $25.00 © 2008 IEEE
DOI 10.1109/ACSAC.2008.17
DOI 10.1109/ACSAC.2008.17
392
392
Figure 1 shows a simple example with three blocks of
source code. When executing Block A, the ﬁrst argument
of system call read always equals to the return value of
its immediate preceding system call open. This is a very
nice and useful rule that most of the existing techniques can
learn. However, when Block B executes, the same rule does
not apply, as the ﬁrst argument of read now equals to its
second preceding open. If both Block A and Block B are
in the program to be monitored, training will be confused as
the rules are valid with low probabilities.
A simple solution is to combine the two rules to be a
single one, i.e., the ﬁrst argument of read equals to either
the ﬁrst or the second preceding open. However, this re-
sults in a less precise rule and gives attackers more room to
get evaded. Another solution is to use the different program
counter values for the instructions in Block A and Block B
to differentiate the two read system calls, so that a differ-
ent rule can be used for each block. However, this simple
solution will not work in cases where program counter val-
ues cannot differentiate the two cases, e.g., in Block C.
The example shown in Figure 1 motivates the idea that
control-ﬂow information is very important in learning data-
ﬂow relations in system call arguments and return values. In
general, the same system call may have very different data-
ﬂow properties when used in different context, and this con-
text information may not be available by simply examining
the program counter values. Therefore, we need a better
way of making use of control-ﬂow information in order to
perform data-ﬂow analysis with improved accuracy.
In this paper, we introduce the ﬁrst technique in lever-
aging results from control-ﬂow analysis for the purpose of
data-ﬂow analysis for intrusion detection. In short, control-
ﬂow analysis helps putting each system call into the context
of performing some individual task. We then learn data-
ﬂow relations among the arguments and return values of the
system calls based on the different context in which the sys-
tem calls are made. We design three Rule Sets to capture
these relations: Rule Set A contains rules that reveal the
argument and return value relations when the process be-
ing monitored is performing a particular task; Rule Set B
exploits rules that govern the system calls when the pro-
cess is performing the same task repeatedly; and Rule Set
C reﬂects the argument and return value behavior when the
process being monitored is performing different tasks.
In our trace-driven evaluation using logs from a produc-
tion web server, we show that the proposed technique can
not only detect real attacks, but learn useful rules for intru-
sion detection that cannot be learned in prior approaches.
False-alarm rates of our system are shown to be low in our
trace-driven evaluation. We further perform evaluations on
the convergence of the training process and the overhead ex-
perienced when using our system in real-time monitoring.
The organization of the rest of the paper is as follows.
In Section 2, we present the motivations of our technique.
The details of the design of our system are presented in Sec-
tion 3. Section 4 shows the evaluation results. Finally, we
show some related work in Section 5 and conclude with fu-
ture work in Section 6.
2 Motivations of our technique
Figure 1 shows that context information from control-
ﬂow analysis is needed in learning the data-ﬂow relations
among system call arguments and return values. Such con-
text information can be obtained via static analysis of the
source or binary, or from dynamic analysis of executions of
the program. In this paper, we restrict ourselves to dynamic
analysis, because of not only its wide applicability in most
environments and its simplicity in the analysis, but also its
accuracy in learning relations governing normal executions
(instead of all possible executions in static analysis) of the
program. We leave using static analysis as future work.
Control-ﬂow-based detectors using dynamic analysis
have proposed using real-time information, e.g., program
counters, call stack, to learn the context of a system call [5,
7,8,13]. However, as pointed out in Section 1 using the code
segment in Block C in Figure 1, the context information we
need in learning data-ﬂow relations is not readily available
from this information. Intuitively, the context information
needed is about program behavior before and after the sys-
tem call is made. In other words, it is about the sub-task the
program is performing when the system call is made.
Sliding window [6] of system calls is a relatively close
It provides the context information
ﬁt to what we need.
about system calls made before and after the system call
under analysis, and could be used to differentiate the two
cases in Block C of Figure 1. However, variable-length
patterns extracted from system call sequences more natu-
rally reﬂect the behavior of an application than ﬁxed-length
patterns [8, 19, 20].
Intuitively, each such variable-length
pattern corresponds to a task performed by the application.
For example, the system call read in the two cases shown
in Block C of Figure 1 will fall into two different variable-
length patterns. Another advantage of using variable-length
patterns is that these patterns can be extracted without
knowing the actual task each pattern is performing. Tech-
niques for extracting these patterns are based on dynamic
learning and have been used successfully in a number of
host-based intrusion detection systems [8–10, 19, 20].
Since each system call pattern corresponds to a task per-
formed by the application, there will be strong relations
among arguments of system calls within a single pattern.
E.g., system calls may be made within a single pattern to
open a ﬁle and read from it. File descriptors used in the
open and read system calls may have to be equal. Sys-
tem calls from two patterns may be related as well, where
393393
the two patterns could be repetitions of the same pattern, or
they could be different patterns. An example of the former
case could be that a system call pattern is used to read one
block of data, and this pattern needs to be performed re-
peatedly in order to read a large portion of the data. The ﬁle
descriptors used in the repeating system call patterns may
have to be the same. An example of the latter case could be
that one system call pattern of reading a ﬁle is followed by
another pattern to close the ﬁle, in which the ﬁle descriptors
must be the same, too. Although we have been using the ﬁle
descriptor example so far, there are many other examples:
directories may share the same preﬁx in their paths within
one system call pattern, the return value of a system call in
a pattern may be used as an argument of a system call in
another pattern, etc.
Motivated by the above observations, we deﬁne three
Rule Sets to capture the relations among system call argu-
ments and return values using the context information from
variable-length patterns:
1. Rule Set A contains rules that reveal the argument and
return value relations among system calls within one
system call pattern, i.e., rules governing the system
call behavior when the process being monitored is per-
forming an individual task. An example of these rules
could be: the return value of the ﬁrst system call of a
pattern must be the same as the second argument of the
second system call.
2. Rule Set B exploits rules that govern the system calls
from repeating system call patterns, i.e., when the pro-
cess is performing the same task repeatedly.
It may
contain rules such as: for each repeated appearance of
a pattern , the value of the ﬁrst argument of the third
system call must be greater than its value in the previ-
ous appearance by 1.
3. Rule Set C reﬂects the behavior of system calls from
different patterns, i.e., when the process being moni-
tored is performing different tasks. An example of the
rules might be: the return value of the second system
call in one pattern and the ﬁrst argument of the third
system call in another pattern must have the same value
when these two patterns appear consecutively.
Rules in each of these three Rule Sets are learned using
techniques inspired by association rule mining [1, 21]. We
present the details of learning rules in the next Section.
3 Relations mining
In this section, we describe in detail the relations min-
ing in system call arguments and return values by using the
context information obtained from the variable-length sys-
tem call patterns. We ﬁrst give an overview in Section 3.1,
followed by the extraction of system call patterns using
control-ﬂow analysis (Section 3.2). We then describe the
relations our system is capable of learning and how they are
learned (Section 3.3). Finally we show the on-line monitor-
ing using our system in Section 3.4.
3.1 Overview
The input
training data, which contains the system
call sequences (along with arguments and return values)
recorded when the application is running in a benign envi-
ronment, is ﬁrst passed to a pattern extraction engine to do
control-ﬂow analysis. The engine analyzes the sequences
and outputs a set of patterns (system call subsequences) and
a representation of the training data using these patterns.
After that, three types of rules are learned by applying rela-
tions mining techniques. Finally, rules learned are used for
online monitoring of the application.
3.2 System call patterns via control-ﬂow
analysis
The control-ﬂow analysis techniques we use consists of
the Teiresias algorithm [12] and a pattern reduction algo-
rithm [20]. These algorithms have been used successfully
in many projects for improving the intrusion detection sys-
tems [8–10, 19, 20]. Note that other techniques for extract-
ing patterns can be used as well. Intuitively, each pattern
extracted corresponds to a task performed by the program.
Table 1 shows an pattern example which is composed of
three system calls. Note that although the training data con-
tains information of the system call arguments and return
values, the control-ﬂow analysis we perform here makes use
of only the system call numbers to extract patterns.
syscall No.
syscall name
168
poll
003
read
078
gettimeofday
Table 1. Systems calls in a pattern
With the system call patterns found, the system call se-
quences in the training data can be represented in terms of
the patterns and the corresponding system calls, as well as
the arguments and return values of the system calls in the
patterns. For simplicity, we call arguments and return value
of a system call attributes in the rest of this paper.
3.3 Relations and relations mining
With pattern extraction, each system call in the training
data falls in a particular pattern, which provides the context
information for us to do more accurate relations mining. In
this subsection, we show how the relations among system
call arguments and return values are learned by using this
394394
information. We ﬁrst group system call arguments and re-
turn values based on their data types. We then present our
generalized form for the rules and the three Rule Sets. In-
spired by association rule mining techniques [1,21], we im-
plement two evaluations on each rule learned to ﬁlter out
rules that may cause too many false positives or negatives.
3.3.1 Macro-Types
Intuitively, only relations between two attributes of the same
data type are useful. E.g., the relation between the value of
an int and a char is not very meaningful. However, after
checking the 111 distinct data types from the 324 system
calls deﬁned in Linux kernel 2.6.22, we realized that sys-
tem call arguments of two different data types might be re-
lated as well. For example, the data type of the return value