is thrown, no value is returned.
Examples
The following stored procedure uses the EXECUTE_AND_FETCH function to retrieve one
employee using the employee’s name. An exception will be thrown if the employee is not
found, or there is more than one employee with the same name.
CREATE OR REPLACE PROCEDURE select_by_name(
p_ename emp.ename%TYPE
)
IS
curid INTEGER;
v_empno emp.empno%TYPE;
v_hiredate emp.hiredate%TYPE;
v_sal emp.sal%TYPE;
v_comm emp.comm%TYPE;
v_dname dept.dname%TYPE;
v_disp_date VARCHAR2(10);
v_sql VARCHAR2(120) := 'SELECT empno, hiredate, sal, ' ||
'NVL(comm, 0), dname ' ||
'FROM emp e, dept d ' ||
'WHERE ename = :p_ename ' ||
Copyright © 2007 - 2019 EnterpriseDB Corporation. All rights reserved. 225
Database Compatibility for Oracle® Developers
Built-in Package Guide
'AND e.deptno = d.deptno';
v_status INTEGER;
BEGIN
curid := DBMS_SQL.OPEN_CURSOR;
DBMS_SQL.PARSE(curid,v_sql,DBMS_SQL.native);
DBMS_SQL.BIND_VARIABLE(curid,':p_ename',UPPER(p_ename));
DBMS_SQL.DEFINE_COLUMN(curid,1,v_empno);
DBMS_SQL.DEFINE_COLUMN(curid,2,v_hiredate);
DBMS_SQL.DEFINE_COLUMN(curid,3,v_sal);
DBMS_SQL.DEFINE_COLUMN(curid,4,v_comm);
DBMS_SQL.DEFINE_COLUMN(curid,5,v_dname,14);
v_status := DBMS_SQL.EXECUTE_AND_FETCH(curid,TRUE);
DBMS_SQL.COLUMN_VALUE(curid,1,v_empno);
DBMS_SQL.COLUMN_VALUE(curid,2,v_hiredate);
DBMS_SQL.COLUMN_VALUE(curid,3,v_sal);
DBMS_SQL.COLUMN_VALUE(curid,4,v_comm);
DBMS_SQL.COLUMN_VALUE(curid,5,v_dname);
v_disp_date := TO_CHAR(v_hiredate, 'MM/DD/YYYY');
DBMS_OUTPUT.PUT_LINE('Number : ' || v_empno);
DBMS_OUTPUT.PUT_LINE('Name : ' || UPPER(p_ename));
DBMS_OUTPUT.PUT_LINE('Hire Date : ' || v_disp_date);
DBMS_OUTPUT.PUT_LINE('Salary : ' || v_sal);
DBMS_OUTPUT.PUT_LINE('Commission: ' || v_comm);
DBMS_OUTPUT.PUT_LINE('Department: ' || v_dname);
DBMS_SQL.CLOSE_CURSOR(curid);
EXCEPTION
WHEN NO_DATA_FOUND THEN
DBMS_OUTPUT.PUT_LINE('Employee ' || p_ename || ' not found');
DBMS_SQL.CLOSE_CURSOR(curid);
WHEN TOO_MANY_ROWS THEN
DBMS_OUTPUT.PUT_LINE('Too many employees named, ' ||
p_ename || ', found');
DBMS_SQL.CLOSE_CURSOR(curid);
WHEN OTHERS THEN
DBMS_OUTPUT.PUT_LINE('The following is SQLERRM:');
DBMS_OUTPUT.PUT_LINE(SQLERRM);
DBMS_OUTPUT.PUT_LINE('The following is SQLCODE:');
DBMS_OUTPUT.PUT_LINE(SQLCODE);
DBMS_SQL.CLOSE_CURSOR(curid);
END;
EXEC select_by_name('MARTIN')
Number : 7654
Name : MARTIN
Hire Date : 09/28/1981
Salary : 1250
Commission: 1400
Department: SALES
Copyright © 2007 - 2019 EnterpriseDB Corporation. All rights reserved. 226
Database Compatibility for Oracle® Developers
Built-in Package Guide
3.17.14 FETCH_ROWS
The FETCH_ROWS function retrieves a row from a cursor.
status INTEGER FETCH_ROWS(c INTEGER)
Parameters
c
Cursor ID of the cursor from which to fetch a row.
status
Returns 1 if a row was successfully fetched, 0 if no more rows to fetch.
Examples
The following examples fetches the rows from the emp table and displays the results.
DECLARE
curid INTEGER;
v_empno NUMBER(4);
v_ename VARCHAR2(10);
v_hiredate DATE;
v_sal NUMBER(7,2);
v_comm NUMBER(7,2);
v_sql VARCHAR2(50) := 'SELECT empno, ename, hiredate, sal, ' ||
'comm FROM emp';
v_status INTEGER;
BEGIN
curid := DBMS_SQL.OPEN_CURSOR;
DBMS_SQL.PARSE(curid,v_sql,DBMS_SQL.native);
DBMS_SQL.DEFINE_COLUMN(curid,1,v_empno);
DBMS_SQL.DEFINE_COLUMN(curid,2,v_ename,10);
DBMS_SQL.DEFINE_COLUMN(curid,3,v_hiredate);
DBMS_SQL.DEFINE_COLUMN(curid,4,v_sal);
DBMS_SQL.DEFINE_COLUMN(curid,5,v_comm);
v_status := DBMS_SQL.EXECUTE(curid);
DBMS_OUTPUT.PUT_LINE('EMPNO ENAME HIREDATE SAL COMM');
DBMS_OUTPUT.PUT_LINE('----- ---------- ---------- -------- ' ||
'--------');
LOOP
v_status := DBMS_SQL.FETCH_ROWS(curid);
EXIT WHEN v_status = 0;
DBMS_SQL.COLUMN_VALUE(curid,1,v_empno);
DBMS_SQL.COLUMN_VALUE(curid,2,v_ename);
DBMS_SQL.COLUMN_VALUE(curid,3,v_hiredate);
DBMS_SQL.COLUMN_VALUE(curid,4,v_sal);
DBMS_SQL.COLUMN_VALUE(curid,4,v_sal);
DBMS_SQL.COLUMN_VALUE(curid,5,v_comm);
DBMS_OUTPUT.PUT_LINE(v_empno || ' ' || RPAD(v_ename,10) || ' ' ||
Copyright © 2007 - 2019 EnterpriseDB Corporation. All rights reserved. 227
Database Compatibility for Oracle® Developers
Built-in Package Guide
TO_CHAR(v_hiredate,'yyyy-mm-dd') || ' ' ||
TO_CHAR(v_sal,'9,999.99') || ' ' ||
TO_CHAR(NVL(v_comm,0),'9,999.99'));
END LOOP;
DBMS_SQL.CLOSE_CURSOR(curid);
END;
EMPNO ENAME HIREDATE SAL COMM
----- ---------- ---------- -------- --------
7369 SMITH 1980-12-17 800.00 .00
7499 ALLEN 1981-02-20 1,600.00 300.00
7521 WARD 1981-02-22 1,250.00 500.00
7566 JONES 1981-04-02 2,975.00 .00
7654 MARTIN 1981-09-28 1,250.00 1,400.00
7698 BLAKE 1981-05-01 2,850.00 .00
7782 CLARK 1981-06-09 2,450.00 .00
7788 SCOTT 1987-04-19 3,000.00 .00
7839 KING 1981-11-17 5,000.00 .00
7844 TURNER 1981-09-08 1,500.00 .00
7876 ADAMS 1987-05-23 1,100.00 .00
7900 JAMES 1981-12-03 950.00 .00
7902 FORD 1981-12-03 3,000.00 .00
7934 MILLER 1982-01-23 1,300.00 .00
Copyright © 2007 - 2019 EnterpriseDB Corporation. All rights reserved. 228
Database Compatibility for Oracle® Developers
Built-in Package Guide
3.17.15 IS_OPEN
The IS_OPEN function provides the capability to test if the given cursor is open.
status BOOLEAN IS_OPEN(c INTEGER)
Parameters
c
Cursor ID of the cursor to be tested.
status
Set to TRUE if the cursor is open, set to FALSE if the cursor is not open.
Copyright © 2007 - 2019 EnterpriseDB Corporation. All rights reserved. 229
Database Compatibility for Oracle® Developers
Built-in Package Guide
3.17.16 LAST_ROW_COUNT
The LAST_ROW_COUNT function returns the number of rows that have been currently
fetched.
rowcnt INTEGER LAST_ROW_COUNT
Parameters
rowcnt
Number of row fetched thus far.
Examples
The following example uses the LAST_ROW_COUNT function to display the total number
of rows fetched in the query.
DECLARE
curid INTEGER;
v_empno NUMBER(4);
v_ename VARCHAR2(10);
v_hiredate DATE;
v_sal NUMBER(7,2);
v_comm NUMBER(7,2);
v_sql VARCHAR2(50) := 'SELECT empno, ename, hiredate, sal, ' ||
'comm FROM emp';
v_status INTEGER;
BEGIN
curid := DBMS_SQL.OPEN_CURSOR;
DBMS_SQL.PARSE(curid,v_sql,DBMS_SQL.native);
DBMS_SQL.DEFINE_COLUMN(curid,1,v_empno);
DBMS_SQL.DEFINE_COLUMN(curid,2,v_ename,10);
DBMS_SQL.DEFINE_COLUMN(curid,3,v_hiredate);
DBMS_SQL.DEFINE_COLUMN(curid,4,v_sal);
DBMS_SQL.DEFINE_COLUMN(curid,5,v_comm);
v_status := DBMS_SQL.EXECUTE(curid);
DBMS_OUTPUT.PUT_LINE('EMPNO ENAME HIREDATE SAL COMM');
DBMS_OUTPUT.PUT_LINE('----- ---------- ---------- -------- ' ||
'--------');
LOOP
v_status := DBMS_SQL.FETCH_ROWS(curid);
EXIT WHEN v_status = 0;
DBMS_SQL.COLUMN_VALUE(curid,1,v_empno);
DBMS_SQL.COLUMN_VALUE(curid,2,v_ename);
DBMS_SQL.COLUMN_VALUE(curid,3,v_hiredate);
DBMS_SQL.COLUMN_VALUE(curid,4,v_sal);
DBMS_SQL.COLUMN_VALUE(curid,4,v_sal);
DBMS_SQL.COLUMN_VALUE(curid,5,v_comm);
DBMS_OUTPUT.PUT_LINE(v_empno || ' ' || RPAD(v_ename,10) || ' ' ||
TO_CHAR(v_hiredate,'yyyy-mm-dd') || ' ' ||
TO_CHAR(v_sal,'9,999.99') || ' ' ||
TO_CHAR(NVL(v_comm,0),'9,999.99'));
Copyright © 2007 - 2019 EnterpriseDB Corporation. All rights reserved. 230
Database Compatibility for Oracle® Developers
Built-in Package Guide
END LOOP;
DBMS_OUTPUT.PUT_LINE('Number of rows: ' || DBMS_SQL.LAST_ROW_COUNT);
DBMS_SQL.CLOSE_CURSOR(curid);
END;
EMPNO ENAME HIREDATE SAL COMM
----- ---------- ---------- -------- --------
7369 SMITH 1980-12-17 800.00 .00
7499 ALLEN 1981-02-20 1,600.00 300.00
7521 WARD 1981-02-22 1,250.00 500.00
7566 JONES 1981-04-02 2,975.00 .00
7654 MARTIN 1981-09-28 1,250.00 1,400.00
7698 BLAKE 1981-05-01 2,850.00 .00
7782 CLARK 1981-06-09 2,450.00 .00
7788 SCOTT 1987-04-19 3,000.00 .00
7839 KING 1981-11-17 5,000.00 .00
7844 TURNER 1981-09-08 1,500.00 .00
7876 ADAMS 1987-05-23 1,100.00 .00
7900 JAMES 1981-12-03 950.00 .00
7902 FORD 1981-12-03 3,000.00 .00
7934 MILLER 1982-01-23 1,300.00 .00
Number of rows: 14
Copyright © 2007 - 2019 EnterpriseDB Corporation. All rights reserved. 231
Database Compatibility for Oracle® Developers
Built-in Package Guide
3.17.17 OPEN_CURSOR
The OPEN_CURSOR function creates a new cursor. A cursor must be used to parse and
execute any dynamic SQL statement. Once a cursor has been opened, it can be re-used
with the same or different SQL statements. The cursor does not have to be closed and re-
opened in order to be re-used.
c INTEGER OPEN_CURSOR
Parameters
c
Cursor ID number associated with the newly created cursor.
Examples
The following example creates a new cursor:
DECLARE
curid INTEGER;
BEGIN
curid := DBMS_SQL.OPEN_CURSOR;
.
.
.
END;
Copyright © 2007 - 2019 EnterpriseDB Corporation. All rights reserved. 232
Database Compatibility for Oracle® Developers
Built-in Package Guide
3.17.18 PARSE
The PARSE procedure parses a SQL command or SPL block. If the SQL command is a
DDL command, it is immediately executed and does not require running the EXECUTE
function.
PARSE(c INTEGER, statement VARCHAR2, language_flag INTEGER)
Parameters
c
Cursor ID of an open cursor.
statement
SQL command or SPL block to be parsed. A SQL command must not end with
the semi-colon terminator, however an SPL block does require the semi-colon
terminator.
language_flag
Language flag provided for compatibility with Oracle syntax. Use
DBMS_SQL.V6, DBMS_SQL.V7 or DBMS_SQL.native. This flag is ignored, and
all syntax is assumed to be in EnterpriseDB Advanced Server form.
Examples
The following anonymous block creates a table named, job. Note that DDL statements
are executed immediately by the PARSE procedure and do not require a separate
EXECUTE step.
DECLARE
curid INTEGER;
BEGIN
curid := DBMS_SQL.OPEN_CURSOR;
DBMS_SQL.PARSE(curid, 'CREATE TABLE job (jobno NUMBER(3), ' ||
'jname VARCHAR2(9))',DBMS_SQL.native);
DBMS_SQL.CLOSE_CURSOR(curid);
END;
The following inserts two rows into the job table.
DECLARE
curid INTEGER;
v_sql VARCHAR2(50);
v_status INTEGER;
BEGIN
Copyright © 2007 - 2019 EnterpriseDB Corporation. All rights reserved. 233
Database Compatibility for Oracle® Developers
Built-in Package Guide
curid := DBMS_SQL.OPEN_CURSOR;
v_sql := 'INSERT INTO job VALUES (100, ''ANALYST'')';
DBMS_SQL.PARSE(curid, v_sql, DBMS_SQL.native);
v_status := DBMS_SQL.EXECUTE(curid);
DBMS_OUTPUT.PUT_LINE('Number of rows processed: ' || v_status);
v_sql := 'INSERT INTO job VALUES (200, ''CLERK'')';
DBMS_SQL.PARSE(curid, v_sql, DBMS_SQL.native);
v_status := DBMS_SQL.EXECUTE(curid);
DBMS_OUTPUT.PUT_LINE('Number of rows processed: ' || v_status);
DBMS_SQL.CLOSE_CURSOR(curid);
END;
Number of rows processed: 1
Number of rows processed: 1
The following anonymous block uses the DBMS_SQL package to execute a block
containing two INSERT statements. Note that the end of the block contains a terminating
semi-colon, while in the prior example, each individual INSERT statement does not have
a terminating semi-colon.
DECLARE
curid INTEGER;
v_sql VARCHAR2(100);
v_status INTEGER;
BEGIN
curid := DBMS_SQL.OPEN_CURSOR;
v_sql := 'BEGIN ' ||
'INSERT INTO job VALUES (300, ''MANAGER''); ' ||
'INSERT INTO job VALUES (400, ''SALESMAN''); ' ||
'END;';
DBMS_SQL.PARSE(curid, v_sql, DBMS_SQL.native);
v_status := DBMS_SQL.EXECUTE(curid);
DBMS_SQL.CLOSE_CURSOR(curid);
END;
Copyright © 2007 - 2019 EnterpriseDB Corporation. All rights reserved. 234
Database Compatibility for Oracle® Developers
Built-in Package Guide
3.18 DBMS_UTILITY
The DBMS_UTILITY package provides support for the following various utility
programs:
Function/Procedure Function or Return Description
Procedure Type
ANALYZE_DATABASE(method [, Procedure n/a Analyze database tables.
estimate_rows [, estimate_percent
[, method_opt ]]])
ANALYZE_PART_OBJECT(schema, Procedure n/a Analyze a partitioned table.
object_name [, object_type [,
command_type [, command_opt [,
sample_clause ]]]])
ANALYZE_SCHEMA(schema, method [, Procedure n/a Analyze schema tables.
estimate_rows [, estimate_percent
[, method_opt ]]])
CANONICALIZE(name, canon_name Procedure n/a Canonicalizes a string – e.g., strips off white
OUT, canon_len)
space.
COMMA_TO_TABLE(list, tablen OUT, Procedure n/a Convert a comma-delimited list of names to
tab OUT) a table of names.
DB_VERSION(version OUT, Procedure n/a Get the database version.
compatibility OUT)
EXEC_DDL_STATEMENT(parse_string) Procedure n/a Execute a DDL statement.
FORMAT_CALL_STACK Function TEXT Formats the current call stack.
GET_CPU_TIME Function NUMBER Get the current CPU time.
GET_DEPENDENCY(type, schema, Procedure n/a Get objects that are dependent upon the
name) given object..
GET_HASH_VALUE(name, base, Function NUMBER Compute a hash value.
hash_size)
GET_PARAMETER_VALUE(parnam, Procedure BINARY_IN Get database initialization parameter
intval OUT, strval OUT) TEGER
settings.
GET_TIME Function NUMBER Get the current time.
NAME_TOKENIZE(name, a OUT, b OUT, Procedure n/a Parse the given name into its component
c OUT, dblink OUT, nextpos OUT) parts.
TABLE_TO_COMMA(tab, tablen OUT, Procedure n/a Convert a table of names to a comma-
list OUT)
delimited list.
Advanced Server's implementation of DBMS_UTILITY is a partial implementation when
compared to Oracle's version. Only those functions and procedures listed in the table
above are supported.
The following table lists the public variables available in the DBMS_UTILITY package.
Public Variables Data Type Value Description
inv_error_on_restrictions PLS_INTEGER 1 Used by the INVALIDATE procedure.
lname_array TABLE For lists of long names.
uncl_array TABLE For lists of users and names.
Copyright © 2007 - 2019 EnterpriseDB Corporation. All rights reserved. 235
Database Compatibility for Oracle® Developers
Built-in Package Guide
3.18.1 LNAME_ARRAY
The LNAME_ARRAY is for storing lists of long names including fully-qualified names.
TYPE lname_array IS TABLE OF VARCHAR2(4000) INDEX BY BINARY_INTEGER;
3.18.2 UNCL_ARRAY
The UNCL_ARRAY is for storing lists of users and names.
TYPE uncl_array IS TABLE OF VARCHAR2(227) INDEX BY BINARY_INTEGER;
Copyright © 2007 - 2019 EnterpriseDB Corporation. All rights reserved. 236
Database Compatibility for Oracle® Developers
Built-in Package Guide
3.18.3 ANALYZE_DATABASE, ANALYZE SCHEMA and
ANALYZE PART_OBJECT
The ANALYZE_DATABASE(), ANALYZE_SCHEMA() and ANALYZE_PART_OBJECT()
procedures provide the capability to gather statistics on tables in the database. When you
execute the ANALYZE statement, Postgres samples the data in a table and records
distribution statistics in the pg_statistics system table.
ANALYZE_DATABASE, ANALYZE_SCHEMA, and ANALYZE_PART_OBJECT differ
primarily in the number of tables that are processed:
 ANALYZE_DATABASE analyzes all tables in all schemas within the current
database.
 ANALYZE_SCHEMA analyzes all tables in a given schema (within the current
database).
 ANALYZE_PART_OBJECT analyzes a single table.
The syntax for the ANALYZE commands are:
ANALYZE_DATABASE(method VARCHAR2 [, estimate_rows NUMBER
[, estimate_percent NUMBER [, method_opt VARCHAR2 ]]])
ANALYZE_SCHEMA(schema VARCHAR2, method VARCHAR2
[, estimate_rows NUMBER [, estimate_percent NUMBER
[, method_opt VARCHAR2 ]]])
ANALYZE_PART_OBJECT(schema VARCHAR2, object_name VARCHAR2
[, object_type CHAR [, command_type CHAR
[, command_opt VARCHAR2 [, sample_clause ]]]])
Parameters - ANALYZE_DATABASE and ANALYZE_SCHEMA
method
method determines whether the ANALYZE procedure populates the