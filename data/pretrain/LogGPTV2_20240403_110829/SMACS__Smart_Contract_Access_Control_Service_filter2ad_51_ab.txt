access permissions of a particular client with respect to a
SMACS-enabled smart contract.
• Clients are users who want to access the resources (e.g.,
data, methods) of SMACS-enabled smart contracts. A client
must obtain a token granting appropriate permissions from the
TS before she can access the smart contracts.
B. Goals
We design SMACS with the following goals in mind.
a) Security: We assume that an adversary cannot com-
promise the underlying cryptographic primitives (e.g., signa-
tures, hash functions, etc.) and cannot compromise the runtime
environment of the deployed smart contract platform However,
we discuss an adversary able to reverse the blockchain history
(i.e., launch a 51% attack). Under these assumptions SMACS
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 11:34:17 UTC from IEEE Xplore.  Restrictions apply. 
223
Blockchain
Public key
verify()
Smart 
Contract
C
r
e
a
t
e
Manage
Return 
Token
 Call data 
 +Token
Owner
Token Request
Client
Return Token
Pass 
Request
Front End
web interface
Token Service
Access Granting
Validation
ACRs
Veriﬁcation  
Tools
ACRs
Compliance
Sign 
Token
Private
key
Fig. 1: Details of the SMACS framework.
should prevent unauthorized entities from accessing SMACS-
enabled smart contracts. When an entity is allowed to access
a SMACS-enabled smart contract, its behavior cannot deviate
from the permission it has been granted. Moreover, apart
from enabling access control in the traditional sense, SMACS
should be able to counter certain runtime attacks even if the
underlying smart contracts are vulnerable to these attacks.
b) Flexibility and Extensibility: The SMACS framework
should be able to deﬁne complex and ﬁne-grained ACRs for
smart contracts while keeping smart contracts simple. SMACS
should allow to manage these rules by removing, adding, or
modifying them dynamically, but without updating contracts.
Also, it should be easy to extend SMACS by integrating smart
contract protection techniques of various classes.
c) Efﬁciency and Low cost: SMACS should operate as
efﬁciently as possible. There should be no efﬁciency bottle-
necks with respect to throughput, storage, latency, etc. which
could hinder its applicability in real-world scenarios. The cost
of applying SMACS in terms of storage, computation, and
blockchain-related fees should be minimized. Meanwhile, the
process of integrating and deploying SMACS-enabled smart
contracts should be easy and intuitive, not incurring a high
development effort and cost.
C. Overview
In SMACS, the owner ﬁrst generates a public and private
key pair (pkT S, skT S), and preloads the Token Service (TS)
with skT S and an initial set of ACRs (or token issuing rules).
The private key skT S will be used by the TS to sign tokens
it issues, while the ACRs specify the condition under which a
token can be issued. The owner is also responsible for creating
the SMACS-enabled smart contract with the public key pkT S
preloaded. The SMACS-enabled smart contract veriﬁes the
validity of the access credentials (tokens) of the incoming
calls with the public key pkT S before continuing an actual
execution. We use Signsk(·) and SigV erif ypk(·) to denote
the signing with sk and verifying with pk in later sections.
Although tokens in SMACS can have different types and can
be issued basing on arbitrary validation logic, SMACS-enabled
smart contracts stay simple and implement only an easy access
control veriﬁcation. In most cases, the only overheads that
SMACS introduce are a) storing a public key, b) parsing a
token, and c) a signature veriﬁcation per call. In our design, the
burden of all memory consuming and computationally heavy
operations are shifted to an off-chain TS. All intended ACRs
are initialized into TS. These rules can be updated dynamically
by the owner. Before accessing the SMACS-enabled smart
contract, a client must apply for a token with compatible
permissions from TS. Upon receiving the request from a client,
the TS checks the request against the ACRs. If the request
does not violate the rules, the TS issues a token to the client by
signing the datagram formed by relevant information extracted
from the request and metadata. The client then constructs
a transaction with the token encoded into it to access the
smart contract. The transaction constructed by the client has
to be compatible with her previous request, since the signature
creates a cryptographic binding and any attempt to modify the
actual transaction will make the signature veriﬁcation fail. In
practice, the situation may be more complex. A client may
issue a transaction that triggers the execution of a chain of
smart contracts. How to handle these situations will be clear
in the following sections.
IV. SMACS DETAILS
The detailed architecture of SMACS is shown in Fig. 1. The
owner and clients are external owned accounts operated via the
client-side software (usually called a wallet) to interact with
SMACS-enabled contracts. The TS consists of a) the front end
interface, b) the access granting module that checks the rules
compliance and issues tokens, and c) the validation module
that contains all veriﬁcation tools (if any) and respective rules.
These rules determine who can get a token with particular
permissions. The owner and clients interact with the TS
through an HTTPS-enabled web interface provided by the TS.
The realization of the access control of the smart contract is
ultimately due to the control of the issuance of tokens.
A. Token Types
SMACS supports three different types of tokens with differ-
ent permission semantics. These types are designed to facilitate
a ﬂexible and ﬁne-grained access control over the SMACS-
enabled smart contracts.
• Super token is of the highest permission level. A client with
a super token can freely call all public methods of the smart
contract with arbitrary arguments before the token expires.
• Method token limits the access to a speciﬁc method. A
client with a method token can call the speciﬁc contract’s
method associated with the token with arbitrary arguments be-
fore the token expires. A method token issued for a particular
method cannot be used to access other methods.
• Argument token is similar to a method token with the
additional restriction that the associated method can only be
called with speciﬁc arguments.
All tokens are issued with an expiration time set by the TS.
The expiration time determines the token lifetime, i.e., until
when the token can be used to authorize the corresponding
calls. Any token can have the one-time property set. A one-
time token gets invalidated once it is used to successfully
access the smart contract, which ensures that the token holder
can only access the smart contract once with issued token.
Before a client can get a token from the TS, she has to
submit a well-formed token request to the TS. As depicted
in Fig. 2, the token request varies according to the requested
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 11:34:17 UTC from IEEE Xplore.  Restrictions apply. 
224
Tab. I: Elements of a token request payload.
reqPayload
cAddr sAddr methodId argName argValue















Type
Super
Method
Argument
token type, where type is a token type, cAddr is the address
of a targeted contract, sAddr is the address of a client’s
account, methodId is the method identiﬁer that is going
to be accessed with a method or argument token, argName
and argValue are the argument and argument value used
when an argument token is requested (there can be multiple
argument-value pairs passed in a token request).
In SMACS, a token is implemented as an 86-byte object
shown in Fig. 3, where type indicates the type of a token,
expire encodes the expiration time, index is used for
tokens with their one-time property set (if the value of index
is a non-negative integer, then the one-time property is set),
and the signature ﬁeld is computed as:
SignskT S
(type (cid:2) expire (cid:2) index (cid:2) reqPayload),
where type and reqPayload are extracted from the token
request sent by the client (see Fig. 2). The reqPayload is an
optional ﬁeld of the token request with variable size according
to type. Its exact formulation is shown in Tab. I.
B. Token Issuance and Veriﬁcation
There are two veriﬁcation processes in SMACS: a TS veri-
ﬁes incoming token requests against its rules, and a SMACS-
enabled contract veriﬁes tokens extracted from incoming trans-
actions. Any failed attempt to access the contract is ultimately
due to the failure of one of these two veriﬁcation processes.
a) Token Issuance: To apply for a token, a client sends
a token request specifying the intended type together with
a compatible reqPayload, which describes who (sAddr)
will access which (cAddr) smart contract and how it will
be accessed. The request payload (reqPayload) depends
on the intended type (see Tab. I). When receiving the token
request, the TS parses and checks it against the rules. Once
veriﬁed, a token is issued according to the request. This step
can be easily integrated into mainstream wallets, such that
it is executed seamlessly for users prior to actual transaction
sending.
b) Contract-side Veriﬁcation: Once getting a token from
the TS, the client can construct a transaction whose calldata is
ﬁlled with the token together with other necessary information
that is compatible with the token (i.e., the token will be passed
as an argument). Upon receiving the transaction, the token
veriﬁcation process shown in Alg. 1 is triggered, and only
1B
20B
20B
string
string
string
type
cAddr
sAddr
methodId
argName
argValue
...
reqPayload
Fig. 2: The layout of a token request.
1B
4B
type
expire
16B
index
86 bytes
65B
signature
Fig. 3: The layout of a token.
after the process succeeds the smart contract can continue to
execute the transaction accordingly.
The SMACS-enabled smart contract ﬁrst extracts the token
from the transaction, checks whether it expires, and whether
it has been used if the one-time property is set. We discuss
the one-time property validity checking (i.e., the details of
reused() check) in § IV-C. Then the SMACS-enabled smart
contract reconstructs the data required to verify the token
signature according to the type of the token. In this step, the
smart contract uses the EVM’s transaction context objects (
see § II-C) to make sure that the passed ticket matches the
current transaction.
We emphasize that this veriﬁcation process is generic and
the implementation of SMACS-enabled smart contracts re-
spects the common development ﬂows. Basically, the code of
legacy smart contracts can be made deployment-ready in the
SMACS framework by ensuring that every method callable
from outside (i.e., public or external) veriﬁes a token prior
to its actual body execution. To achieve it, for each public
and external method the tokens argument is added to the
original argument list and the verify call performing Alg. 1
is asserted prior to the actual method body.
To facilitate easy adoption we develop a tool that allows
to transform any legacy smart contract
into an equivalent
SMACS-enabled smart contract. An example of such a trans-
formation is presented in Fig. 4 (note that internal methods
do not have to verify tokens and in the case of public/external
methods called internally they are split into separate methods).
C. One-time Tokens
The one-time property ensures that a given token can be
used only once. One-time tokens may be especially useful
return False
Alg. 1: Contract-side token veriﬁcation.
Input: A transaction T
Output: The veriﬁcation result
tk ← extractToken(T )
if now() > tk.expire then
if tk.index > −1 and not reused(tk.index) then
tkData ← tk.expire (cid:3) tk.index
addrData ← T .origin (cid:3) address(this)
data ← tk.type (cid:3) tkData (cid:3) addrData
if tk.type = Super then
return False
else if tk.type = Method then
data ← data
data ← data (cid:3) msg.sig
data ← data (cid:3) msg.sig (cid:3) msg.data
else if tk.type = Argument then
return SigVerifypkT S (data, tk.signature)
225
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 11:34:17 UTC from IEEE Xplore.  Restrictions apply. 
Legacy
Contract Legacy { 
  func f() external { 
    call h(); 
    call g(); 
  } 
  func h() public { 
    call g(); 
     ... 
  } 
  func g() private { 
     ... 
  } 
} 
SMACS
Contract SMACS { 
   func f(token) external { 
    assert(verify(token)); 
    call _h(); 
    call g(); 
  } 
  func h(token) public { 
    assert(verify(token)); 
    call _h(); 
  } 
  func _h() private { 
    call g(); 
     ... 