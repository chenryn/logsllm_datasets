title:Chainsaw: Chained Automated Workflow-based Exploit Generation
author:Abeer Alhuzali and
Birhanu Eshete and
Rigel Gjomemo and
V. N. Venkatakrishnan
Chainsaw: Chained Automated Workﬂow-based Exploit
Generation
Abeer Alhuzali
∗
, Birhanu Eshete, Rigel Gjomemo, and V.N. Venkatakrishnan
University of Illinois at Chicago
Chicago, IL
{aalhuz2, eshete5, rgjome1, venkat}@uic.edu
ABSTRACT
We tackle the problem of automated exploit generation for
web applications. In this regard, we present an approach
that signiﬁcantly improves the state-of-art in web injection
vulnerability identiﬁcation and exploit generation. Our ap-
proach for exploit generation tackles various challenges as-
sociated with typical web application characteristics: their
multi-module nature, interposed user input, and multi-tier
architectures using a database backend. Our approach de-
velops precise models of application workﬂows, database
schemas, and native functions to achieve high quality exploit
generation. We implemented our approach in a tool called
Chainsaw. Chainsaw was used to analyze 9 open source
applications and generated over 199 ﬁrst- and second-order
injection exploits combined, signiﬁcantly outperforming sev-
eral related approaches.
Keywords
Exploit generation; Web security; Injection vulnerabilities
1.
INTRODUCTION
Web applications are the engines that drive modern
electronic commerce and banking applications. Therefore,
security of these applications is an important concern. Any
vulnerability that can be exploited in these applications
can be catastrophic in terms of ﬁnancial losses to the on-
line enterprise as well as privacy losses to the consumer.
Vulnerability analysis research eﬀorts try to proactively ex-
pose the ﬂaws in these applications before attackers can
leverage them, and therefore are crucial from a defense stand-
point.
Injection vulnerability analysis eﬀorts fall broadly into
two categories: penetration-testing approaches and program
analysis based approaches. Of these, penetration testing
tools work by injecting inputs (which resemble common ex-
ploit strings) in the application to check for the presence
∗Also aﬃliated with King Abdulaziz University, Saudi Arabia
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full citation
on the ﬁrst page. Copyrights for components of this work owned by others than ACM
must be honored. Abstracting with credit is permitted. To copy otherwise, or republish,
to post on servers or to redistribute to lists, requires prior speciﬁc permission and/or a
fee. Request permissions from permissions@acm.org.
CCS’16, October 24-28, 2016, Vienna, Austria
© 2016 ACM. ISBN 978-1-4503-4139-4/16/10. . . $15.00
DOI: http://dx.doi.org/10.1145/2976749.2978380
of vulnerabilities. While they are easy to deploy, they lack
broad-coverage of the application and therefore miss vul-
nerabilities. In fact, recent studies [4] have shown that the
coverage of these tools is low.
[9])
for
[26],
[28],
Static analysis approaches do not suﬀer from the cover-
age problem, and are based on more directed exploration
of an application’s code.
In particular, they are focused
on identifying properties of certain sensitive sinks in the
application. There has been a large body of work (e.g., [17],
[20],
identifying web application
vulnerabilities such as SQL injection (SQLI) and Cross-site
scripting (XSS). However, due to technical and engineer-
ing considerations that go into modeling complex language
features, static analysis tools often suﬀer from false positives.
A direction that has received interest in the recent years
is automated exploit generation: approaches that convert
potential vulnerabilities resulting from a static analysis tool
into concrete exploits. Because an exploit is an actual input
to an application that can be veriﬁed, and in most cases
automatically, exploit ﬁnding has the potential to eliminate
false alarms from static tools.
We pursue an automated exploit generation approach in
the web application setting in this paper. That is, given an
application, the goal is to automatically construct a sequence
of malicious HTTP request inputs that direct an application’s
execution to a vulnerable sink. Given a web application’s
multi-module and multi-tier nature, the issues for automated
exploit generation are quite diﬀerent from those for binary
applications that are studied in [1, 15].
Our main contribution in this paper is an exploit gener-
ation technique that is able to ‘chain’ a sequence of HTTP
requests that, when issued in order, direct the execution of
the application to a vulnerable sink. Note that the sink may
be deeply nested in the module structure of an application
that could only be reached by supplying input sequences
starting from a publicly accessible module, and such paths
may frequently consult data stored in persistent storage.
The starting point for our approach is static analysis:
creation of models of the web application behavior along
its paths that is based on symbolic execution. From here,
there are two scalability challenges that must be overcome to
make exploit ﬁnding successful. The ﬁrst one involves path
selection: what are the paths that we must explore to make
opportunistic exploit generation successful? Our approach
makes the observation that it is possible to prioritize the
traversal of the paths by using their constraint solving costs,
such that we eﬃciently identify paths that lead to a successful
exploit.
641The second issue is about persistent database state: how
to deal with database queries that may be present along the
paths that are explored. This issue becomes particularly
important in the context of second-order attack creation,
where a vulnerable query, say, is exploited to store some
data that is subsequently read from a (second) exploit sink.
Our approach develops the use of both static and dynamic
techniques for dealing with persistent database state.
Our approach is implemented in a tool called Chainsaw,
and to the best of our knowledge it is the ﬁrst tool that
generates injection exploits that span several HTTP requests.
Chainsaw is built for the PHP language, but the concepts
behind it are general and are applicable to other web plat-
forms. Chainsaw leverages application workﬂow structures,
database schemas and precise modeling of PHP native func-
tions to achieve successful exploit detection, and is capable
of detecting second order exploits. Chainsaw was tested on
9 PHP web applications of diﬀerent complexities, generating
199 exploits, including 30 second-order exploits, and has
no false positives by design. A detailed comparison of re-
sults from related tools shows that Chainsaw is comparable
to, and in the most cases signiﬁcantly outperforms, other
state-of-art approaches.
This paper is organized as follows: Section 2 provides the
background, running example and the associated challenges
for exploit detection. We present a high-level overview of our
approach in Section 3, and a discussion of its implementation
in Section 4. We discuss our experiments and results in
Section 5. Related work is presented in Section 6 and we
conclude in Section 7.
2. BACKGROUND AND CHALLENGES
Assumptions and Goal. We assume the analysis sys-
tem has complete access to a web application’s source code.
In order to test exploits, we assume that the analysis system
also has a working installation of it, with appropriate login
credentials. It can test any generated inputs on the applica-
tion by sending requests to it and observing the results. The
goal is to construct a sequence of malicious HTTP requests
that navigate an application to a vulnerable sink in order to
perform SQLI or XSS attacks. These attacks are constructed
with the goal of exﬁltrating information from database, inject
malicious content in the database or obtain capability for
stealing client side content (e.g., cookies).
Problem Deﬁnition. An exploit is successful when a mali-
cious content is injected via a query to a database (SQLI)
or when it reaches echo-like statements that send content
(i.e. code) to a client (XSS). To trigger such behavior, the
malicious content must reach or inﬂuence execution at one
or more sensitive sinks along some path starting from the
input. In web applications, such paths to the sinks may span
several modules (sever-side scripts in PHP, similar to servlets
in Java) and the attacker may need to send malicious input
to all those modules.
The exploit generation problem can be formally stated as
follows: Given a web application, ﬁnd a sequence of pairs
((M1, IE1), (M2, IE2),..., (MN , IEN )), where each IEi is the
input that must be sent to the corresponding module Mi via
an HTTP request to exploit the vulnerable sink in MN .
2.1 Running example
We introduce an example of a chatroom application, which
will be used throughout the paper to illustrate our approach
15
16
17
18
4
5
6
7
(Listings 1-4). The example contains code snippets from
diﬀerent modules of the application, including several SQLI
and XSS vulnerabilities to illustrate the approach.
In particular, room.php starts by including a ﬁle with func-
tion deﬁnitions (line 1). Next, it retrieves user input (lines
4-11) and it sanitizes those inputs using two built-in func-
tions (lines 5, 12). Next, it builds a SQL query with the
sanitized version of the user input (line 15). Based on the
query results, the superglobal $_SESSION[‘room_name’] is set
(line 17) and the execution proceeds to dashboard.php via
the call to the header function (line 18). Superglobals are
built-in constructs in PHP that can be accessed from all the
modules. The module contains also a self redirection via the
HTML form (lines 21-22).
$room_name = $_POST[’room_name’];
header( "Location: ./login.php" );
$mode = htmlspecialchars($_GET[’mode’]) ;
1 include_once(’includes/function.php’);
2 if(!isset($_SESSION[’username’]))
3
4 if (isset($_GET[’mode’]))
5
6 if (isset($_POST[’room_name’]))
7
8 else $room_name = "";
9 if (isset($_POST[’category’]))
10
11 else $category = "";
12 $room_name = mysql_real_escape_string ($room_name);
13 if( isset( $mode ) ) {
14
$category = $_POST[’category’];
if( $mode == "enter" ) {
$result = mysql_query( "SELECT room_name FROM ROOM_TABLE WHERE
room_name=’$room_name’");
if (mysql_num_rows( $result ) == 1 ){
$_SESSION[’room_name’] = $room_name;
header( "Location: ./dashboard.php?mode=addcat&cat_desc=
$category");} ....}}
19
20 else{...
21 
22 ......
23 }
Listing 1: room.php (entry module): select the chatroom
header( "Location: ./login.php" );
1 if(!isset($_SESSION[’username’]))
2
3 if (isset($_GET[’mode’]))
4 $mode=$_GET[’mode’];
5 else $mode="";
6 if (isset($_GET[’cat_desc’]))
7 $cat_desc=$_GET[’cat_desc’];
8 else $cat_desc="";
9 if (isset($mode) && isset($_SESSION[’room_name’])) {
10 switch ($mode) {
11 case "addcat": header("Location: ./addcat.php?cat_desc=$cat_desc");
12 case "delcat": header("Location: ./delcat.php");
13 ...}}
Listing 2: module dashboard.php, dispatch execution to
diﬀerent functionalities (add category, delete category, etc)
1 if(!isset($_SESSION[’username’]))
2
3 else if (isset($_SESSION[’username’]) &&
header( "Location: ./login.php" );
isset($_SESSION[’room_name’])){
$room_name = $_SESSION[’room_name’]; // sanitized in room.php
$sql = "SELECT room_name, level FROM ROOM_TABLE WHERE
room_name=’$room_name’" ;
$result = mysql_query($sql);
$room_row = $db->sql_fetchrow($result);
$accesslevel = $room_row[’level’];
8
9 }
10 if ($accesslevel==1){
11
if (isset($_GET[’cat_desc’])) {
12
13
14
15
16
$cat_desc = htmlspecialchars($_GET[’cat_desc’]);
$sql = "SELECT cat_desc FROM CAT_TABLE WHERE
cat_desc=’$cat_desc’";
$result = mysql_query($sql);
} }......
//check if the category description exists.
642Listing 3: module addcat.php, retrieve a category description
header( "Location: ./login.php" );
1 if (!isset($_SESSION[’username’]))
2
3 else {
4
if (isset($_POST[’room_name’]))
$room_name = htmlspecialchars($_POST[’room_name’]);
else $room_name = "";
if (isset($_POST[’level’]))
$level = intval($_POST[’level’]);
if ($level==1 or $level==2) {
$sql = "INSERT INTO ROOM_TABLE (room_name, level) VALUES
(’$room_name’, ’$level’)";
$result = $db->sql_query($sql);
} ... }
5
6
7
8
9
10
11
12
sanitizations along paths to sensitive sinks and generate
exploits that are not prevented by those sanitizations.
Persistent Storage Eﬀect. The database state is another
important aspect that must be considered to automatically
build a working exploit. In fact, the values stored in the
database are additional inputs to the application that in-
ﬂuence its control and data paths during execution. For
instance, in the running example, the execution of the vul-
nerable query in line 13 in Listing 3 is dependent on the
value of $accesslevel, which is retrieved from the database
by a previous query. Therefore, we must be able to take
into account the control and data ﬂows that cross from the
application to the database and vice versa.
In the next section, we provide details of our approach,
Listing 4: module create.php, create a new chatroom
which addresses these challenges.
The code inside dashboard.php serves as a dispatcher to
several functionalities of the web application, such as adding
or deleting categories, creating chatrooms, and so on. Listing
3 shows a snippet from addcat.php, which checks if a category
exists before adding it. The code executes a ﬁrst query to
retrieve the room name and access level (lines 5-6), and next
a second query in line 13 if the $accesslevel value retrieved
by the ﬁrst query is equal to 1.
Note that the SQL query at line 13 in Listing 3 has a SQLI
vulnerability because htmlspecialchars does not escape the
single quote which leaves the query vulnerable to any attack
pattern that has a single quote such as 1’ OR ‘1’=‘1. The
other select queries (line 15 in Listing 1, line 5 in Listing 3)
contain no such vulnerabilities since their input is sanitized
by a stronger sanitization function (line 12 in Listing 1). The
last code snippet contains an insert query, which inserts
values of diﬀerent chatrooms in ROOM_TABLE. Note that this
query’s input is also insuﬃciently sanitized.
2.2 Exploit Generation Challenges
Complex Workﬂow. In general, the execution of vulner-
able queries depends on the application workﬂow, that is
on the sequence of visited modules and on the shared state
among those modules. In general, there can be several navi-
gation sequences in a web application. Some of them may
represent intended workﬂows where the sequence of module
execution follows the developers envisioned workﬂow, while
others may be unintended workﬂows where an attacker may
issue arbitrary requests and skip the execution of certain
modules from the intended sequence. Note that the intended