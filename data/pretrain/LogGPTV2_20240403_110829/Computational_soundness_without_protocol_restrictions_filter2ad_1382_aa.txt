title:Computational soundness without protocol restrictions
author:Michael Backes and
Ankit Malik and
Dominique Unruh
Computational Soundness
without Protocol Restrictions
Michael Backes1, Ankit Malik2 and Dominique Unruh3
1 Saarland University, Germany and MPI-SWS
2 Dept. of Math., IIT Delhi
3 University of Tartu, Estonia
ABSTRACT
The abstraction of cryptographic operations by term al-
gebras, called Dolev-Yao models, is essential in almost all
tool-supported methods for verifying security protocols. Re-
cently signiﬁcant progress was made in establishing compu-
tational soundness results: these results prove that Dolev-
Yao style models can be sound with respect to actual crypto-
graphic realizations and security deﬁnitions. However, these
results came at the cost of imposing various constraints on
the set of permitted security protocols: e.g., dishonestly gen-
erated keys must not be used, key cycles need to be avoided,
and many more. In a nutshell, the cryptographic security
deﬁnitions did not adequately capture these cases, but were
considered carved in stone;
in contrast, the symbolic ab-
stractions were bent to reﬂect cryptographic features and
idiosyncrasies, thereby requiring adaptations of existing ver-
iﬁcation tools.
In this paper, we pursue the opposite direction: we con-
sider a symbolic abstraction for public-key encryption and
identify two cryptographic deﬁnitions called PROG-KDM
(programmable key-dependent message) security and MKE
(malicious-key extractable) security that we jointly prove to
be suﬃcient for obtaining computational soundness with-
out imposing assumptions on the protocols using this ab-
straction. In particular, dishonestly generated keys obtained
from the adversary can be sent, received, and used. The deﬁ-
nitions can be met by existing cryptographic schemes in the
random oracle model. This yields the ﬁrst computational
soundness result for trace-properties that holds for arbitrary
protocols using this abstraction (in particular permitting to
send and receive dishonestly generated keys), and that is ac-
cessible to all existing tools for reasoning about Dolev-Yao
models without further adaptations.
Categories and Subject Descriptors
C.2.2 [Computer-Communication Networks]: Network
Protocols—Protocol Veriﬁcation
Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proﬁt or commercial advantage and that copies
bear this notice and the full citation on the ﬁrst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciﬁc
permission and/or a fee.
CCS’12, October 16–18, 2012, Raleigh, North Carolina, USA.
Copyright 2012 ACM 978-1-4503-1651-4/12/10 ...$15.00.
General Terms
Security, theory, veriﬁcation
Keywords
Computational soundness, sending keys, key dependent mes-
sages
1.
INTRODUCTION
Proofs of security protocols are known to be error-prone
and, owing to the distributed-system aspects of multiple
interleaved protocol runs, awkward for humans to make.
Hence work towards the automation of such proofs started
soon after the ﬁrst protocols were developed. From the start,
the actual cryptographic operations in such proofs were ide-
alized into so-called Dolev-Yao models, following [23, 24, 30],
e.g., see [25, 34, 1, 28, 33, 13]. This idealization simpliﬁes
proof construction by freeing proofs from cryptographic de-
tails such as computational restrictions, probabilistic behav-
ior, and error probabilities. The success of these Dolev-Yao
models for the tool-supported security analysis stems from
their conceptual simplicity: they only consist of a small set
of explicitly permitted rules that can be combined in an arbi-
trary manner, without any further constraints on the usage
and combination of these rules. Recently signiﬁcant progress
was made in establishing so-called computational soundness
results: these results prove that Dolev-Yao style models can
be sound with respect to actual cryptographic realizations
and security deﬁnitions, e.g., see [2, 26, 10, 8, 27, 31, 22, 19,
11, 21].
However, prior computational soundness results came at
the price of imposing various constraints on the set of per-
mitted protocols. In addition to minor extensions of sym-
bolic models, such as reﬂecting length information or ran-
domization, core limitations were to assume that the sur-
rounding protocol does not cause any key cycles, or – more
importantly – that all keys that are used within the pro-
tocol have been generated using the correct key generation
algorithm. The latter assumption is particularly problem-
atic since keys exchanged over the network might have been
generated by the adversary, and assuming that the adversary
is forced to honestly generate keys can hardly be justiﬁed in
practice.
In a nutshell, these constraints arose because the respec-
tive cryptographic security deﬁnitions did not adequately
capture these cases, but were considered carved in stone; in
contrast, the symbolic abstractions were bent to reﬂect cryp-
tographic features and idiosyncrasies. As a result, existing
699tools needed to be adapted to incorporate extensions in the
symbolic abstractions, and the explicitly imposed protocol
constraints rendered large classes of protocols out-of-scope of
prior soundness results. Moreover, if one intended to analyze
a protocol that is comprised by such prior results, one addi-
tionally had to formally check that the protocol meets the
respective protocol constraints for computational soundness,
which is not necessarily doable in an automated manner.
Our Contribution. In this paper, we are ﬁrst to pursue
the opposite direction: we consider an unconstrained sym-
bolic abstraction for public-key encryption and we strive for
avoiding assumptions on the protocols using this abstrac-
tion. We in particular permit sending and receiving of po-
tentially dishonestly generated secret keys. Being based on
the CoSP framework, our result is limited to trace prop-
erties. We do not, however, see a principal reason why it
should not be possible to extend it to equivalence proper-
ties.
To this end, we ﬁrst identify which standard and which
more sophisticated properties a cryptographic scheme for
public-key encryption needs to fulﬁll in order to serve as
a computationally sound implementation of an unrestricted
Dolev-Yao model, i.e., eliminating constraints on the set of
permitted cryptographic protocols. This process culminates
in the novel deﬁnitions of an PROG-KDM (programmable
key-dependent message) secure and an MKE (malicious-key
extractable) secure encryption scheme. Our main result will
then show that public-key encryption schemes that satisfy
PROG-KDM and MKE security constitute computationally
sound implementations of unrestricted Dolev-Yao models for
public-key encryption. The deﬁnitions can be met by exist-
ing public-key encryption schemes. (A number of additional
conditions are needed, e.g., that a public key can be ex-
tracted from a ciphertext. But these can be easily enforced
by suitable tagging. See Appendix A for the full list.)
Our computational soundness result in particular encom-
passes protocols that allow honest users to send, receive
and use dishonestly generated keys that they received from
the adversary, without imposing further assumptions on the
symbolic abstraction. This solves a thus far open problem
in the cryptographic soundness literature.1
In a nutshell, we obtain the ﬁrst computational sound-
ness result that avoids to impose constraints on the proto-
cols using this abstraction (in particular, it permits to send,
receive, and use dishonestly generated keys), and that is ac-
cessible to all existing tools for reasoning about Dolev-Yao
models without further adaptations.
Related work. Backes, Pﬁtzmann, and Scedrov [9] give
a computational soundness result allowing key-dependent
messages and sending of secret keys. But they impose the
protocol condition that no key that is revealed to the ad-
versary is every used for encrypting. Ad˜ao, Bana, Herzog,
and Scedrov [3] give a computational soundness result al-
lowing key-dependent messages, but only for passive adver-
saries. No adaptive revealing of secret keys is supported.
1In an interesting recent work, Comon-Lundh et al. [20]
also achieved a computational soundness result for dishon-
est keys. Their work is orthogonal to our work in that they
proposed an extension of the symbolic model while keeping
the standard security assumptions IND-CPA and IND-CTXT
for the encryption scheme. As explained before, we avoid
symbolic extensions at the cost of novel cryptographic deﬁ-
nitions.
Mazar´e and Warinschi [29] give a computational soundness
that allows for adaptive revealing of secret keys (in the case
of symmetric encryption). But they disallow key-dependent
messages, encrypting of keys, key-dependent messages, en-
cryptions of ciphertexts, or forwarding of ciphertexts. They
show that under these conditions, IND-CCA2 security is suf-
ﬁcient. Bana and Comon-Lundh [12] have a computational
soundness result not imposing any restrictions on the proto-
col. Their symbolic modeling, however, is weakened so that
no secrecy (even symbolically) is guaranteed when key de-
pendent messages or adaptive revealing of secret keys occur.
Outline of the Paper. First, we introduce our symbolic
abstraction of unconstrained public-key encryption within
the CoSP framework in Section 2. We give the notion of
computation soundness in Section 3 and review how prior
computational soundness proofs were conducted in CoSP in
Section 4 for the sake of illustration. We identify where the
aforementioned restrictions arise in these proofs and explain
how to overcome these limitations in Section 5. The cor-
responding formal result is established in Section 6. Full
proofs are deferred to the full version [7]
2. THE SYMBOLIC MODEL
We ﬁrst describe our symbolic modeling here. The model
is fairly standard and follows that of [4], except that we
added some additional operations on secret keys.
Let C := {enc/3,
Constructors and nonces.
ek /1, dk /1, sig/3, vk /1, sk /1, pair /2, string0 /1, string1 /1,
and
empty /0, garbageSig /2, garbage /1, garbageEnc/2}
N := NP ∪ NE. Here NP and NE are countably inﬁnite
sets representing protocol and adversary nonces, respec-
tively. (f /n means f has arity n.) Intuitively, encryption,
decryption, veriﬁcation, and signing keys are represented
as ek (r), dk (r), vk (r), sk (r) with a nonce r (the randomness
used when generating the keys). enc(ek (r′), m, r) encrypts
m using the encryption key ek (r′) and randomness r.
sig(sk (r′), m, r) is a signature of m using the signing
key sk (r′) and randomness r. The constructors string0 ,
string1 , and empty are used to model arbitrary strings
used as payload in a protocol (e.g., a bitstring 010 would
be encoded as string0 (string1 (string0 (empty )))). garbage,
garbageEnc, and garbageSig are constructors necessary to
express certain invalid terms the adversary may send, these
constructors are not used by the protocol.
Message type.2 We deﬁne T as the set of all terms T
2In the CoSP framework, the message type represents the
set of all well-formed terms. Having such a restriction (and
excluding, e.g., enc(dk (N ), . . . ) or similar) makes life easier.
However, when applying the computational soundness result
to a calculus that does not support message types, one needs
to remove the restriction that only terms in the message type
are considered. [4] give a theorem that guarantees that this
can be done without losing computational soundness.
700matching the following grammar:
T ::= enc(ek (N ), T, N ) | ek (N ) | dk (N ) |
sig(sk (N ), T, N ) | vk (N ) | sk (N ) |
pair (T, T ) | S | N |
garbage(N ) | garbageEnc(T, N ) |
garbageSig (T, N )
S ::= empty | string 0(S) | string 1(S)
where the nonterminal N stands for nonces.
Destructors. D := {dec/2, isenc/1, isek /1, isdk /1, ekof /1,
ekofdk /1, verify/2, issig/1, isvk /1, issk /1, vkof /2, vkofsk /1,
fst /1, snd /1, unstring 0/1, unstring 1/1, equals/2}.
The
destructors isek , isdk , isvk , issk , isenc, and issig realize
predicates to test whether a term is an encryption key,
decryption key, veriﬁcation key, signing key, ciphertext,
or signature, respectively.
ekof extracts the encryption
key from a ciphertext, vkof extracts the veriﬁcation key
from a signature.
dec(dk (r), c) decrypts the ciphertext
c. verify(vk (r), s) veriﬁes the signature s with respect to
the veriﬁcation key vk (r) and returns the signed message
if successful.
ekofdk and vkofsk compute the encryp-
tion/veriﬁcation key corresponding to a decryption/signing
key. The destructors fst and snd are used to destruct pairs,
and the destructors unstring0 and unstring1 allow to parse
payload-strings.
(Destructors ispair and isstring are not
necessary, they can be emulated using fst, unstring i, and
equals(·, empty).)
The destructors are deﬁned by the rules in Figure 1; an
application matching none of these rules evaluates to ⊥:
Deduction relation. ⊢ is the smallest relation satisfy-
ing the rules in Figure 2. This deduction relation spec-
iﬁes which terms the adversary can deduce given already
known messages S. We use the shorthand evalf for the ap-
plication of a constructor or destructor. evalf (t1, . . . , tn) =
f (t1, . . . , tn) if f (t1, . . . , tn) 6= ⊥ and f (t1, . . . , tn) ∈ T and
evalf (t1, . . . , tn) = ⊥ otherwise.
Protocols. We use the protocol model from the CoSP
framework [4]. There, a protocol is modeled as a (possibly
inﬁnite) tree of nodes. Each node corresponds to a particular
protocol action such as receiving a term from the adversary,
sending a previously computed term to the adversary, ap-
plying a constructor or destructor to previously computed
terms (and branching depending on whether the applica-
tion is successful), or picking a nonce. We do not describe
the protocol model in detail here, but it suﬃces to know
that a protocol can freely apply constructors and destruc-
tors (computation nodes), branch depending on destructor
success, and communicate with the adversary. Despite the
simplicity of the model, it is expressive enough to embed
powerful calculi such as the applied π-calculus (shown in