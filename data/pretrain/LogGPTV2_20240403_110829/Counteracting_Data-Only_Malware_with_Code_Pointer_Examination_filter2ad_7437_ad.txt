### Apache Benchmark Results
- **Requests/s**: 9504.78
- **Comparison with Previous Result (9156.01)**: 3.81% increase
- **Comparison with Another Result (9383.66)**: 1.29% increase

### False Positives
We perform a more detailed discussion about the possibility of encountering false positives in Section 7.2.

### Malware Detection
Having evaluated the performance of our system and discussed its susceptibility to false positives, we continued to evaluate the effectiveness of our framework against data-only malware. For this purpose, we infected our test VMs with the persistent data-only rootkit presented by Vogl et al. [30]. We chose this rootkit because, to the best of our knowledge, it is the only persistent data-only malware available to date.

While our framework did not detect any malicious code pointers during the performance experiments, our system immediately identified the various malicious control structures used by the rootkit. Specifically, our system identified the modified `sysenter` MSR and the modified system call table entries for the `read` and `getdents` system calls during the prevalidation step and thus classified the system as malicious. Since these hooks are also found by other systems, we manually removed these obvious manipulations and revalidated the system state. In this case, the prevalidation step yielded no results, but the pointer validation found all of the malicious code pointers in memory. This demonstrates that our framework can be very effective against data-only malware, even if the malware avoids manipulating key data structures such as the system call table.

### Forensic Applications
To evaluate the usefulness of our framework in forensic applications, we conducted an experiment where we randomly installed the rootkit on the test VMs while periodically taking snapshots of the guest systems. Our system reliably detected all of the infected snapshots.

## 7.2 Discussion
In this section, we provide a detailed discussion of the security of our system.

### False Positives
Although we did not encounter false positives throughout our experiments, we cannot rule out false positives entirely, as our system relies on heuristics to identify code pointers. However, we consider the likelihood of encountering false positives in our system to be quite small on a 64-bit architecture. To encounter a false positive, we would need to find a value in kernel space that contains the address of a kernel code section, even though it is not a pointer. Given the size of the virtual address space on a 64-bit system (1.8 * 10^19 bytes) and the typical size of the kernel code section (at most 15 megabytes), the chance of encountering such a rare case, assuming uniform distribution, would be approximately 8.5 * 10^-11%. This probability decreases further if the kernel is optimized, as the kernel code section becomes smaller. Additionally, this calculation assumes that the kernel is mapped to a random location within the address space, not directly to the beginning or the end. Therefore, we consider a 64-bit address space sufficiently large to minimize the chance of arbitrary data looking like a pointer by chance. Consequently, we assume that false positives are not a significant issue in most scenarios. In the event of false positives, one could further analyze the detected pointers using speculative code execution as proposed by Polychronakis [23]. Note that an attacker could introduce benign data into the system that will be identified as code pointers by our system. We argue that this kind of tampering should still be identified as malicious.

### ret2libc
When searching for malicious pointers in memory, we currently do not penalize pointers that point to function entry points. As a result, our system is currently unable to detect data-only malware that solely uses entire kernel functions to perform its malicious computations. While this is a weakness of our approach, it is important to note that this is a common limitation faced by almost all existing defense mechanisms against code reuse attacks [8, 26]. In fact, to the best of our knowledge, the detection of ret2libc attacks remains an open research problem.

Additionally, while ret2libc is a powerful technique that is difficult to detect, we argue that it is challenging to design pure data-only malware that solely relies on entire functions to run on a 64-bit architecture. The main reason is that, unlike 32-bit systems, function arguments in Linux and Windows are no longer passed on the stack in a 64-bit architecture but are provided in registers instead. Consequently, to create 64-bit ret2libc data-only malware, an attacker must have access to "loader" functions that allow them to load arbitrary function arguments into the registers dictated by calling conventions. Without access to such loader functions, the attacker cannot pass arguments to any of the functions they want to invoke, significantly restricting their capability to perform attacks.

It is worth noting that such loader functions are probably rare, if they exist at all. A possible approach to further reduce the attack surface could be to analyze the kernel code for such loader functions. If they exist, one can then monitor the identified functions during execution to detect their use in ret2libc attacks. We plan to investigate this idea in more depth in future work.

### Return Addresses
If an attacker requires gadgets in addition to entire functions to execute their persistent data-only malware (e.g., to load function arguments into registers), they can only use a gadget that is directly following a call instruction. The only location where they can place the required control structure without being detected is the kernel stack of a process. Any code pointer pointing inside a function that appears elsewhere within the kernel memory will be classified and identified as malicious by our system. Additionally, since our system enforces SMAP from the hypervisor, the control structure cannot be placed in userspace if it needs to be executable from kernelspace. This leaves only the kernel stack for kernel data-only malware. However, the attacker faces several constraints. First, they can only use gadgets that appear legitimately in the code and are preceded by a call instruction, as all other pointers into a function would be classified as malicious. Second, the kernel stack where the control structure resides may also be used by the process it belongs to, so the attacker must ensure that their persistent control structure is not overwritten by accident. While this is not necessarily an issue for data-only exploits, it is crucial for persistent data-only malware, as the persistent control structure must never be changed uncontrollably. Otherwise, if the control structure is modified in an unforeseen way, the malware is likely to fail to execute the next time it is invoked. This is comparable to changing the code region of traditional malware. This is why our system zeroes all data that belongs to a memory page that is part of the kernel stack but currently resides at a lower address than the stack pointer points to, as a final defense layer. Since this data should be unused in a legitimate scenario, zeroing it will not affect normal system behavior. However, in the case of persistent data-only malware, this approach may destroy the persistent control structure, thwarting any future execution. This will occur if the malware is currently executing while our system performs the validation. Since an attacker cannot predict when validations occur, as our system resides on the hypervisor level, this makes it difficult for them to remain unnoticed in the long run.

As a further enhancement, one could set the kernel stacks of processes that are currently not executing to be non-readable within the page tables. This could be done during the process switch. As a result, the attacker would only be able to use their control structure when the process on whose kernel stack the structure resides is currently executing. This raises the bar if the attacker wants to hook the execution of all processes instead of just one, which is generally the case.

Taking all this into account, we argue that while our system cannot eliminate persistent data-only malware entirely, it significantly reduces the attack surface. In future work, we plan to further enhance our detection by developing novel techniques to validate the legitimacy of a kernel stack, which are also applicable in forensic scenarios. Additionally, we plan to investigate the applicability of our approach to userspace applications or an Android environment.

## 8 Conclusion
In this paper, we have proposed Code Pointer Examination, an approach that aims to detect data-only malware by identifying and classifying pointers to executable memory. To prove the validity and practicability of our approach, we employed it to examine all pointers to executable kernel memory in recent Linux kernels. In the process, we discussed important control flow-relevant data structures and mechanisms within the Linux kernel and highlighted the problems that must be solved to validate kernel control data reliably. Our experiments show that the prototype, which we implemented based on the discussed ideas, is effective in detecting data-only malware while incurring a very small performance overhead (less than 1% in most benchmarks). In combination with code integrity validation, we provide the first comprehensive approach to kernel integrity validation. While our framework still exhibits a small attack surface, we argue that it considerably raises the bar for attackers and thus provides a new pillar in the defense against data-only malware.

### Acknowledgments
We thank the anonymous reviewers for their insightful comments. This work was supported by the Bavarian State Ministry of Education, Science, and the Arts as part of the FORSEC research association.

### References
[References listed here as per the original text]

This revised version is more structured, clear, and professional, making it easier to read and understand.