Apache Benchmark (Requests/s) 9504.78 9156.01 (3.81%) 9383.66 (1.29%)
out false positives entirely. We perform a more detailed discussion about the
possibility of encountering false positives in Sect. 7.2.
Malware Detection. Having evaluated the performance of our system and
touched upon its susceptibility to false positives, we continued to evaluate the
eﬀectiveness of our framework against data-only malware. For this purpose,
we infected our test VMs with the persistent data-only rootkit presented by
Vogl et al. [30]. We chose this rootkit, since it is, to the best of our knowledge,
the only persistent data-only malware available to date.
While our framework did not detect any malicious code pointers during the
performance experiments, our system immediately identiﬁed the various mali-
cious control structures used by the rootkit. In particular, our system identiﬁed
the modiﬁed sysenter MSR and the modiﬁed system call table entries for the
read and the getdents system call during the prevalidation step and thus clas-
siﬁed the system as malicious. As these hooks are also found by other systems,
we then removed these obvious manipulations manually and once more validated
the system state. While the prevalidation step yielded no results in this case,
the pointer validation found all of the malicious code pointers in memory. This
proves that our framework can be very eﬀective against data-only malware even
if the malware avoids the manipulation of key data structures such as the system
call table.
Counteracting Data-Only Malware with Code Pointer Examination
193
Finally, to evaluate the usefulness of our framework in forensic applications,
we conducted an experiment where we randomly installed the rootkit on the
test VMs while we periodically took snapshots of the guest systems. Our system
detected all of the infected snapshots reliably.
7.2 Discussion
In this section, we provide a detailed discussion of the security of our system.
False Positives. Although we did not encounter false positives throughout our
experiments, we cannot rule out false positives entirely, since our system relies on
heuristics to identify code pointers. However, we like to stress that we consider
the likelihood of encountering false positives in our system to be quite small on a
64-bit architecture. To encounter a false positive with our system, we essentially
would need to ﬁnd a value in kernel space that contains the address of a kernel
code section even though it is not a pointer. Since the virtual address space on a
64-bit system has a size of 1.8 ∗ 1019 bytes and the kernel code section typically
only has a size of 15 megabytes at maximum, the chance of encountering such
a rare case, if all values in memory were uniformly distributed would be merely
8.5∗10−11%. And that is only the case if the kernel is not optimized as the kernel
code section even becomes smaller in this case. However, we admit that this is
only the case if the kernel is mapped to a random location within the address
space and not directly to the beginning or the end of the address space. In other
words, we consider a 64-bit address space to be suﬃciently large that the chance
of arbitrary data looking like a pointer by chance are small at best. Consequently,
we assume that false positives are not a big issue in most scenarios. In case of
false positives, one could further analyze the detected pointers using speculative
code execution as proposed by Polychronakis [23]. Note that an attacker could
also introduce benign data into the system that will be identiﬁed as code pointers
by our system. We argue that this kind of tampering with our system should
still be identiﬁed as malicious.
ret2libc. When searching for malicious pointers in memory, we currently do
not penalize pointers that point to function entry points. As a consequence, our
system is at the moment unable to detect data-only malware that solely makes
use of entire kernel functions to perform its malicious computations. While this
is certainly a weakness of our approach, it is important to note that this is
a very common limitation that almost all existing defense mechanisms against
code reuse attacks face [8,26]. In fact, to the best of our knowledge, the detection
of ret2libc attacks still remains an open research problem.
In addition, while ret2libc is a powerful technique that is very diﬃcult to
detect, we argue that it is actually quite diﬃcult to design pure data-only mal-
ware that solely relies on entire functions to run on a 64-bit architecture. The
main reason for this is that in contrast to 32-bit systems, function arguments in
Linux and Windows are no longer passed on the stack on a 64-bit architecture,
but are provided in registers instead. As a consequence, to create 64-bit ret2libc
data-only malware, an attacker must actually have access to “loader” functions
194
T. Kittel et al.
that allow her to load arbitrary function arguments into the registers that the
calling conventions dictate. Otherwise, without access to loader functions, the
attacker is unable to pass arguments to any of the functions she wants to invoke,
which signiﬁcantly restricts her capability to perform attacks.
It goes without saying that such loader functions are probably rare if they
exist at all. A possible approach to further reduce the attack surface could thus
be to analyze the kernel code for such loader functions. If they should exist, one
can then monitor the identiﬁed functions during execution to detect their use in
ret2libc attacks. We plan to investigate this idea in more depth in future work.
Return Addresses. If an attacker requires gadgets in addition to entire func-
tions to execute her persistent data-only malware (e.g. to load function arguments
into registers), she can only use a gadget that is directly following a call instruc-
tion. The only location that she can place the required control structure to without
being detected is the kernel stack of a process. Should a code pointer that points
inside a function appear anywhere else within the kernel memory, it will be clas-
siﬁed and identiﬁed as malicious by our system. In addition, due to the fact that
our system enforces SMAP from the hypervisor, the control structure cannot be
placed in userspace if it should be executable from kernelspace. This only leaves a
kernel stack for kernel data-only malware. But even here the attacker faces various
constraints. First of all, she can only make use of gadgets that appear legitimately
in the code and that are preceded by a call instruction, since all other pointers into
a function would be classiﬁed as malicious. Secondly, as the kernel stack where the
control structure resides may also be used by the process it belongs to, the attacker
must ensure that her persistent control structure is not overwritten by accident.
While this is not necessarily an issue for data-only exploits, this is crucial in the case
of persistent data-only malware as the persistent control structure of the malware
must never be changed uncontrollably. Otherwise, if the control structure would
be modiﬁed in an unforeseen way, it is very likely that the malware will fail to exe-
cute the next time it is invoked. This is comparable to changing the code region
of traditional malware. This is also why our system zeroes all data that belongs
to a memory page that is part of the kernel stack, but currently resides at a lower
address than the stack pointer points to as a ﬁnal defense layer. Since this data
should be unused in a legitimate scenario, zeroing it will not aﬀect the normal sys-
tem behavior. However, in the case of persistent data-only malware, this approach
may destroy the persistent control structure of the malware, which will thwart any
future execution. This will be case if the malware is currently executing while our
system performs the validation. Since an attacker cannot predict when validations
occur as our system resides on the hypervisor-level, this makes it diﬃcult for her
to stay unnoticed in the long run.
As a further enhancement one could set the kernel stacks of processes that
are currently not executing to not readable within the page tables. This could for
example be done during the process switch. As a result, the attacker would only
be able to use her control structure when the process on whose kernel stack the
structure resides is currently executing. This raises the bar if the attacker wants to
hook the execution of all processes instead of just one, which is generally the case.
Counteracting Data-Only Malware with Code Pointer Examination
195
Taking all this into account we argue that while our system cannot eliminate
persistent data-only malware entirely, it signiﬁcantly reduces the attack surface.
In future work, we plan to further enhance our detection by developing novel
techniques to validate the legitimacy of a kernel stack that are also applicable
in forensic scenarios. In addition we plan to investigate the applicability of our
approach to userspace applications or an Android environment.
8 Conclusion
In this paper, we have proposed Code Pointer Examination, an approach that
aims to detect data-only malware by identifying and classifying pointers to exe-
cutable memory. To prove the validity and practicability of our approach, we
employed it to examine all pointers to executable kernel memory in recent Linux
kernels. In the process, we discussed important control ﬂow relevant data struc-
tures and mechanisms within the Linux kernel and highlighted the problems that
must be solved to be able to validate kernel control data reliably. Our experi-
ments show that the prototype, which we implemented based on the discussed
ideas, is eﬀective in detecting data-only malware, while only incurring a very
small performance overhead (less than 1 % in most of the benchmarks). In com-
bination, with code integrity validation, we thus provide the ﬁrst comprehensive
approach to kernel integrity validation. While our framework still exhibits a
small attack surface, we argue that it considerably raises the bar for attackers
and thus provides a new pillar in the defense against data-only malware.
Acknowledgments. We thank the anonymous reviewers for their insightful com-
ments. This work was supported by the Bavarian State Ministry of Education, Science
and the Arts as part of the FORSEC research association.
References
1. Abadi, M., Budiu, M., Erlingsson, U., Ligatti, J.: Control-ﬂow integrity. In: Pro-
ceedings of the 12th ACM conference on Computer and Communications Security,
CCS 2005, pp. 340–353. ACM, New York (2005)
2. Bahram, S., Jiang, X., Wang, Z., Grace, M., Li, J., Srinivasan, D., Rhee, J., Xu, D.:
DKSM: subverting virtual machine introspection for fun and proﬁt. In: Proceedings
of the 29th IEEE International Symposium on Reliable Distributed Systems (SRDS
2010), New Delhi, October 2010
3. Bletsch, T., Jiang, X., Freeh, V.W., Liang, Z.: Jump-oriented programming: a
new class of code-reuse attack. In: Proceedings of the 6th ACM Symposium on
Information, Computer and Communications Security, ASIACCS 2011, pp. 30–40.
ACM, New York (2011)
4. C0ntex. Bypassing non-executable-stack during exploitation using return-to-libc
5. Carbone, M., Cui, W., Lu, L., Lee, W., Peinado, M., Jiang, X.: Mapping kernel
objects to enable systematic integrity checking. In: Proceedings of the 16th ACM
conference on Computer and Communications Security (CCS 2009), pp. 555–565.
ACM (2009)
196
T. Kittel et al.
6. Carlini, N., Wagner, D.: ROP is still dangerous: breaking modern defenses. In: 23rd
USENIX Security Symposium (USENIX Security 2014), pp. 385–399. USENIX
Association, San Diego, August 2014
7. Cheng, Y., Zhou, Z., Yu, M., Ding, X., Deng, R.H.: ROPecker: a generic and
practical approach for defending against ROP attacks. In: 21st Annual Network
and Distributed System Security Symposium, NDSS 2014, February 23–26, 2014,
San Diego (2014)
8. Davi, L., Liebchen, C., Sadeghi, A.-R., Snow, K. Z., Monrose, F.: Isomeron:
Code randomization resilient to (just-in-time) return-oriented programming. In:
Proceeding 22nd Network and Distributed Systems Security symposium (NDSS)
(2015)
9. Davi, L., Sadeghi, A.-R., Lehmann, D., Monrose, F.: Stitching the gadgets: on the
ineﬀectiveness of coarse-grained control-ﬂow integrity protection. In: 23rd USENIX
Security Symposium (USENIX Security 2014), pp. 401–416. USENIX Association,
San Diego, August 2014
10. Evans, I., Fingeret, S., Gonz´alez, J., Otgonbaatar, U., Tang, T., Shrobe, H.,
Sidiroglou-Douskos, S., Rinard, M., Okhravi, H.: Missing the point (er): on the
eﬀectiveness of code pointer integrity (2015)
11. Feng, Q., Prakash, A., Yin, H., Lin, Z.: MACE: high-coverage and robust memory
analysis for commodity operating systems. In: Proceedings of the 30th Annual
Computer Security Applications Conference, ACSAC 2014, pp. 196–205. ACM,
New York (2014)
12. Gilbert, B., Kemmerer, R., Kruegel, C., Vigna, G.: Dymo: tracking dynamic code
identity. In: Sommer, R., Balzarotti, D., Maier, G. (eds.) RAID 2011. LNCS, vol.
6961, pp. 21–40. Springer, Heidelberg (2011)
13. G¨okta¸s, E., Athanasopoulos, E., Polychronakis, M., Bos, H., Portokalidis, G.: Size
does matter: why using gadget-chain length to prevent code-reuse attacks is hard.
In: 23rd USENIX Security Symposium (USENIX Security 2014), pp. 417–432.
USENIX Association, San Diego, August 2014
14. Hund, R., Holz, T., Freiling, F.C.: Return-oriented rootkits: bypassing kernel code
integrity protection mechanisms. In: Proceedings of 18th USENIX Security Sym-
posium (2009)
15. Kemerlis, V.P., Polychronakis, M., Keromytis, A.D.: Ret2dir: rethinking kernel
isolation. In: 23rd USENIX Security Symposium. USENIX Association, August
2014
16. Kemerlis, V.P., Portokalidis, G., Keromytis, A.D.: kGuard: lightweight kernel pro-
tection against return-to-user attacks. In: Proceedings of the 21st USENIX Confer-
ence on Security Symposium, Security 2012. USENIX Association, Berkeley (2012)
17. Kittel, T., Vogl, S., Lengyel, T.K., Pfoh, J., Eckert, C.: Code validation for modern
OS kernels. In: Workshop on Malware Memory Forensics (MMF), December 2014
18. Kuznetsov, V., Szekeres, L., Payer, M., Candea, G., Sekar, R., Song, D.: Code-
pointer integrity. In: 11th USENIX Symposium on Operating Systems Design
and Implementation (OSDI 2014), pp. 147–163. USENIX Association, Broomﬁeld,
October 2014
19. Lin, Z., Rhee, J., Zhang, X., Xu, D., Jiang, X.: SigGraph: Brute force scanning
of kernel data structure instances using graph-based signatures. In: Proceedings of
the Network and Distributed System Security Symposium (NDSS). IEEE (2011)
20. Litty, L., Lagar-Cavilla, H.A., Lie, D.: Hypervisor support for identifying covertly
executing binaries. In: Proceedings of the 17th Usenix Security Symposium, pp.
243–258. USENIX Association, Berkeley (2008)
Counteracting Data-Only Malware with Code Pointer Examination
197
21. Pappas, V., Polychronakis, M., Keromytis, A.D.: Transparent rop exploit miti-
gation using indirect branch tracing. In: Presented as part of the 22nd USENIX
Security Symposium (USENIX Security 2013), pp. 447–462. USENIX, Washington,
D.C. (2013)
22. Petroni, Jr., N.L., Hicks, M.: Automated detection of persistent kernel control-ﬂow
attacks. In: Proceedings of the 14th ACM conference on Computer and communi-
cations security, CCS 2007. ACM, New York (2007)
23. Polychronakis, M., Keromytis, A.D.: ROP payload detection using speculative code
execution. In: 6th International Conference on Malicious and Unwanted Software
(MALWARE), pp. 58–65. IEEE (2011)
24. Sadeghi, A.-R., Davi, L., Larsen, P.: Securing legacy software against real-world
code-reuse exploits: utopia, alchemy, or possible future? - keynote -. In: 10th ACM
Symposium on Information, Computer and Communications Security (ASIACCS
2015), April 2015
25. Schneider, C., Pfoh, J., Eckert, C.: Bridging the semantic gap through static code
analysis. In: Proceedings of EuroSec 2012, 5th European Workshop on System
Security. ACM Press, April 2012
26. Schuster, F., Tendyck, T., Liebchen, C., Davi, L., Sadeghi, A.-R., Holz, T.: Coun-
terfeit object-oriented programming: On the diﬃculty of preventing code reuse
attacks in C++ applications. In: 36th IEEE Symposium on Security and Privacy,
Oakland, May 2015
27. Shacham, H.: The geometry of innocent ﬂesh on the bone: return-into-libc with-
out function calls (on the x86). In: Proceedings of the 14th ACM conference on
Computer and Communications Security, CCS 2007, pp. 552–561. ACM, New York
(2007)
28. Stancill, B., Snow, K.Z., Otterness, N., Monrose, F., Davi, L., Sadeghi, A.-R.:
Check my proﬁle: leveraging static analysis for fast and accurate detection of ROP
gadgets. In: 16th Research in Attacks, Intrusions and Defenses (RAID) Symposium,
October 2013
29. Szekeres, L., Payer, M., Wei, T., Song, D.: SoK: eternal war in memory. In: Pro-
ceedings of the 2013 IEEE Symposium on Security and Privacy, SP 2013, pp. 48–62.
IEEE Computer Society, Washington, DC (2013)
30. Vogl, S., Pfoh, J., Kittel, T., Eckert, C.: Persistent data-only malware: function
hooks without code. In: Proceedings of the 21th Annual Network & Distributed
System Security Symposium (NDSS), February 2014
31. Wang, Z., Jiang, X., Cui, W., Ning, P.: Countering kernel rootkits with lightweight
hook protection. In: Proceedings of the 16th ACM conference on Computer and
Communications Security, CCS 2009, pp. 545–554. ACM, New York (2009)
32. Wang, Z., Jiang, X., Cui, W., Wang, X.: Countering persistent kernel Rootkits
through systematic hook discovery. In: Lippmann, R., Kirda, E., Trachtenberg, A.
(eds.) RAID 2008. LNCS, vol. 5230, pp. 21–38. Springer, Heidelberg (2008)
33. Xia, Y., Liu, Y., Chen, H., Zang, B.: CFIMon: detecting violation of control
ﬂow integrity using performance counters. In: Proceedings of the 2012 42nd
Annual IEEE/IFIP International Conference on Dependable Systems and Net-
works (DSN), DSN 2012, pp. 1–12. IEEE Computer Society, Washington, DC
(2012)
34. Zhang, C., Wei, T., Chen, Z., Duan, L., Szekeres, L., McCamant, S., Song, D., Zou,
W.: Practical control ﬂow integrity and randomization for binary executables. In:
IEEE Symposium on Security and Privacy (SP), pp. 559–573. IEEE (2013)