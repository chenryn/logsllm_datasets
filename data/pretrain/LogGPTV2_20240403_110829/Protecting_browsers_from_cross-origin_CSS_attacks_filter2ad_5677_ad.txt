entities for punctuation within the attacker’s injected strings.
Existing XSS ﬁlters often do this for quote marks, but quotes
are not necessary for the attack; the attacker could use an
unquoted url() instead. Curly braces are necessary, so we
recommend entity-encoding all curly braces in user-submitted
content, using &#123; and &#125;. This will block all known
forms of the attack, as long as the attacker cannot force
UTF-7 encoding. Unfortunately, the library routines for
entity encoding in most popular scripting languages do not
substitute curly braces at present.
As we mentioned in Section 3.3.4, it is also important to
ensure that the Content-Type header includes a character set
declaration. Otherwise, the attacker may be able to defeat
HTML entity encoding of quotes and curly braces by forcing
the target page to be interpreted as UTF-7. Declaring the
character set in a meta tag inside the document is not good
enough, because the CSS parser will not recognize that tag.
4.6.3 Avoid Ambient Authentication
Cross-site attacks rely on the browser transmitting “ambi-
ent” authentication information, such as HTTP credentials
626or session cookies, with any request to the target site. The
web-key authentication scheme [7] avoids the use of ambient
authentication information by embedding credentials in site
URLs instead. This defense blocks cross-origin CSS attacks
as well as cross-site request forgery [4]. However, if a URL
with a credential becomes visible to the victim user (e.g. via
the location bar), they might be tricked into revealing it;
sites must assess whether this is an acceptable trade-oﬀ.
5. RELATED WORK
In this section, we review defenses against similar attacks:
content-sniﬃng XSS, cross-site script inclusion, and cross
channel scripting. We also look at a few recent research
proposals for secure web browsers in the light of the cross-
origin CSS attack.
5.1 Content-Snifﬁng XSS
Browsers use content-sniﬃng algorithms to detect HTML
documents that were not properly labeled by the server. Web
sites that allow their users to upload ﬁles also use content-
sniﬃng, to ensure that only ﬁles in benign formats (e.g.
images) are accepted. When the site’s sniﬃng algorithm is
not the same as the browser’s, an attacker may be able to
construct a “chameleon” document that a website believes is
benign, but that a browser will recognize as HTML [3]. For
example, a ﬁle beginning with GIF<HTML will be treated as
an image by some versions of MediaWiki, but as HTML by
some versions of Internet Explorer.
To deal with this attack, Barth et al [3] proposed a single,
trusted sniﬃng algorithm that can be adopted universally.
The signatures it looks for are preﬁx-disjoint, which excludes
the possibility of chameleon documents.
It also pays at-
tention to the Content-Type header and will not escalate a
document’s capabilities—for instance, it will never treat a
text/plain document as HTML, because HTML can contain
scripts and plain text can’t. Microsoft proposed an alterna-
tive solution, a new HTTP header X-Content-Type-Options
to allow sites to opt out of content sniﬃng [19].
Both of these proposals aim to ensure that if the server
believes a particular document not to be HTML, the brow-
ser will not process it as HTML. They do nothing against
the cross-origin CSS attack, which tricks the browser into
processing an HTML document as CSS.
5.2 Cross-Site Script Inclusion
Subsets of JavaScript syntax are commonly used as a data
transport format; the most popular of these is JavaScript
Object Notation (JSON) [8]. Since the browser security
model allows scripts to be imported from a diﬀerent domain,
an attacker can steal data in this format by mentioning its
URL in a script tag [9]; as with a cross-domain CSS load,
this sends HTTP credentials for the target site. Servers
can block this attack by preﬁxing their JSON responses
with a JavaScript statement that causes a syntax error or
inﬁnite loop. Legitimate clients of the service can be coded to
strip this preﬁx before parsing the JSON, but the malicious
page’s script tag evaluates the entire response, and will not
get past the preﬁx. Servers may also be able to mitigate
the attack by using JSON responses only for HTTP POST
requests; the script tag always generates GET requests.
However, this may require signiﬁcant redesign of the web
application. Finally, avoiding ambient authentication is also
eﬀective against this attack.
5.3 Cross Channel Scripting
Many consumer electronic devices provide a variety of
services, such as FTP or SNMP, along with a web interface.
Cross channel scripting (XCS) [6] is a type of XSS attack
that injects arbitrary strings into web content via non-web
channels (e.g. uploading crafted ﬁlenames), bypassing com-
mon sanitizations for web exploits. This attack illustrates a
vulnerability where a content intended for one service gets
mis-interpreted by another. SiteFirewall [6] is a client-side
defense that blocks XCS attacks at the payload execution
stage, which requires sites to provide a site-wide policy in a
cookie to specify the permitted external resources the site
may request. However, this defense is ineﬀective against
cross-origin CSS attacks because the attacker will white list
the target site in its policy.
5.4 Content Security Policy
Content Security Policy (CSP) is a Mozilla initiative [24]
to provide to web developers with a way to specify how
content interacts on their web sites. The policy is delivered
via an HTTP response header. In Firefox 4.0, CSP includes a
frame-ancestors directive that aﬀects whether a document
can be included by other sites via object, frame, and iframe
tags. However, this directive does not prevent a document
from being included across origins as a stylesheet, image,
or script. Thus, CSP by itself does not currently provide
any protection against cross-origin CSS import attacks. We
expect to see additional directives added to CSP in the future.
5.5 Same Origin Mutual Approval
The Same Origin Mutual Approval (SOMA) proposal [21]
restricts communication between origins by requiring mutual
approval between a web page’s server and the servers of its
cross-origin resources. Each server provides two well-known
URLs declaring its cross-origin policy. One lists all sites
to which its operators expect to make cross-origin requests,
and the other dynamically reveals whether a cross-origin re-
quest from another site is acceptable. Browsers are modiﬁed
to check both policy URLs before making any cross-origin
request. This design prevents leaking conﬁdential data to un-
approved sites, and so mitigates the cross-origin CSS attack.
However, the negotiation scheme costs additional network
round-trips and requires modiﬁcations to all participating
web sites and browsers.
5.6 Cross-Origin Resource Sharing
The Cross-Origin Resource Sharing (CORS) proposal [25]
is similar to SOMA, but it uses HTTP headers rather than
well-known URLs, and is strictly for expanding the set of sites
allowed to retrieve a resource that would normally be same-
origin only. Initially designed to allow sites to cooperate with
XMLHttpRequest, browser vendors are also considering it for
video, downloadable fonts, and other novel resource types.
These can be restricted to same-origin by default, and then
opened up to cross-origin requests only when this does not
reveal conﬁdential information. Thus, CORS reduces the
risk of future cross-origin attacks using novel resource types.
Unfortunately, applying it to “traditional” resource types
such as CSS or JavaScript would break too many websites
to be feasible.
6275.7 Gazelle Browser
The Gazelle browser [29] includes strict architectural con-
trol over resource protection and sharing across websites.
Sites are security principals; all cross-principal communica-
tion is mediated by the browser kernel to prevent cross-origin
attacks. Cross-origin resources are only retrieved if the con-
tent has the proper content type in the HTTP response; thus
Gazelle implements what we described in Section 4.1.1 as
“strict enforcement” of cross-origin CSS labeling, as a natu-
ral consequence of their architecture. Users of Gazelle are
protected against cross-origin CSS attacks, at some cost in
site incompatibility (62 out of 100,000 sites in our survey).
5.8 OP Browser
The OP web browser [14] sandboxes browser components,
to isolate and contain failures. OP’s architecture does not
provide any automatic protection against cross-origin CSS
attacks, which depend only on the high-level behaviors de-
scribed in Section 3.1. However, OP does maintain a detailed
security audit log that could be used by forensics experts to
identify the site where the attack originated.
6. CONCLUSION
In this paper, we argued that it is dangerous for browsers
to allow a page to determine the content type of an included
cross-origin resource. Cross-origin CSS attacks have been
known for some time, but existing defenses for JavaScript-
based CSS attacks are ineﬀective against the new variants we
have discovered. We propose two variants on stricter content
type handling: a strict defense, based solely on content types,
and a minimal defense that uses a content-sniﬃng rule to
improve site compatibility. We surveyed 100,000 web sites
to assess the site compatibility of our proposals. Common
server misconﬁgurations trigger false positives in the strict
variant, and would break 62 (0.06%) of the 100,000 sites; the
minimal variant does not break any sites. Our defense has
been adopted in major browsers, including Firefox, Google
Chrome, Safari and Opera. We also described some server-
side mitigations for the attack.
Error-tolerant parsing has extensibility beneﬁts that have
allowed CSS to become the dominant presentation format
for the Web and will allow it to continue to evolve in the
future. As more new features are introduced into browsers,
we expect that many of them will consider adopting error-
tolerant parsing as well. We hope that the designers of
these features will take into consideration the importance
of correctly determining the content type of cross-origin
resources to avoid similar attacks.
Acknowledgements
We thank Dave Hyatt, Sam Weinig, Maciej Stachowiak, and
Adam Barth of the WebKit project, and David Baron and
Boris Zbarsky of Mozilla, for reviewing our implementations
of cross-origin CSS defenses. We also thank Helen Wang, our
shepherd, and Eric Lawrence of Microsoft for their guidance
and feedback.
7. REFERENCES
[1] Alexa. Top Sites. http://www.alexa.com/topsites.
[2] A. Barth. HTTP state management mechanism, 2010.
https://datatracker.ietf.org/doc/
draft-ietf-httpstate-cookie/.
[3] A. Barth, J. Caballero, and D. Song. Secure content
sniﬃng for web browsers, or how to stop papers from
reviewing themselves. In Proceedings of the 30th IEEE
Symposium on Security and Privacy, 2009.
[4] A. Barth, C. Jackson, and J. C. Mitchell. Robust
defenses for cross-site request forgery. In Proceedings of
the 15th ACM Conference on Computer and
Communications Security, 2008.
[5] T. Berners-Lee. WorldWideWeb: Proposal for a
HyperText Project, 1990.
http://www.w3.org/Proposal.html.
[6] H. Bojinov, E. Bursztein, and D. Boneh. XCS: cross
channel scripting and its impact on web applications.
In CCS ’09: Proceedings of the 16th ACM conference
on Computer and communications security, 2009.
[7] T. Close. Web-key: Mashing with permission. In Web
2.0 Security and Privacy, 2008.
[8] D. Crockford. The application/json media type for
JavaScript Object Notation (JSON), 2006.
http://tools.ietf.org/html/rfc4627.
[9] Fortify. JavaScript Hijacking Vulnerability Detected.
http://www.fortify.com/advisory.jsp.
[10] J. Franks, P. M. Hallam-Baker, J. L. Hostetler, S. D.
Lawrence, and P. J. Leach. HTTP authentication, 1999.
http://www.ietf.org/rfc/rfc2617.txt.
[11] M. Gillon. Google Desktop Exposed: Exploiting an
Internet Explorer vulnerability to phish user
information, 2005. http:
//www.hacker.co.il/security/ie/css_import.html.
[12] D. Goldsmith and M. Davis. UTF-7: A Mail-Safe
Transformation Format of Unicode, 1997.
http://tools.ietf.org/html/rfc2152.
[13] GreyMagic Software. GreyMagic Security Advisory
GM#004-IE, 2002. http://www.greymagic.com/
security/advisories/gm004-ie/.
[14] C. Grier, S. Tang, and S. T. King. Secure web browsing
with the OP web browser. In IEEE Symposium on
Security and Privacy, 2008.
[15] D. Hyatt, W. Bastian, et al. WebKit, an open source
web browser engine, 2005–2010. http://webkit.org/.
[16] C. Jackson. Improving Browser Security Policies. PhD
thesis, Stanford University, Stanford, CA, USA, 2009.
[17] C. Jackson, A. Bortz, D. Boneh, and J. C. Mitchell.
Protecting browser state from web privacy attacks. In
Proceedings of the 15th International World Wide Web
Conference. (WWW 2006), 2006.
[18] D. M. Kristol and L. Montulli. HTTP state
management mechanism, 1997.
http://www.ietf.org/rfc/rfc2109.txt.
[19] E. Lawrence. IE8 Security Part V: Comprehensive
Protection.
http://blogs.msdn.com/ie/archive/2008/07/02/
ie8-security-part-v-comprehensive-protection.
aspx.
[20] H. W. Lie. Cascading Style Sheets. PhD thesis,
University of Oslo, Norway, 2005.
http://people.opera.com/howcome/2006/phd/.
[21] T. Oda, G. Wurster, P. C. van Oorschot, and
A. Somayaji. SOMA: mutual approval for included
content in web pages. In Proceedings of the 15th ACM
628conference on Computer and communications security,
2008.
[22] ofk. CSSXSS attack on mixi post key, 2008.
[26] W3C. CSS syntax and basic data types.
http://www.w3.org/TR/CSS2/syndata.html.
[27] W3C. Document Object Model CSS. http:
http://d.hatena.ne.jp/ofk/20081111/1226407593.
//www.w3.org/TR/DOM-Level-2-Style/css.html.
[23] J. Ruderman. JavaScript Security: Same Origin.
http://www.mozilla.org/projects/security/
components/same-origin.html.
[24] S. Stamm, B. Sterne, and G. Markham. Reining in the
web with content security policy. In WWW ’10:
Proceedings of the 19th international conference on
World wide web, 2010.
[28] W3C. HTML 4.01 Speciﬁcation.
http://www.w3.org/TR/html4/.
[29] H. J. Wang, C. Grier, A. Moshchuk, S. T. King,
P. Choudhury, and H. Venter. The Multi-Principal OS
Construction of the Gazelle Web Browser. In
Proceedings of the 18th USENIX Security Symposium,
2009.
[25] A. van Kesteren et al. Cross-origin resource sharing
[30] E. Z. Yang. HTML Puriﬁer, 2006–2010.
(editor’s draft), 2010.
http://dev.w3.org/2006/waf/access-control/.
http://htmlpurifier.org.
629