atomic event, we can say that to provide a side eﬀect needed
by the exploit there is something required of the inputs. A
side eﬀect the attacker would like to provide could be a write
to memory, a write to a register, a write to a control ﬂag, or
a branch predicated on a control ﬂag. It could be required
that an input to the instruction be a certain value from the
range of , that the address used to load an input be from
the range of , or that a control ﬂag have been predicated
on a comparison of data from the range of  (providing a
write to the program counter EIP).
5.3.2 Slammer Example
Suppose we want to exploit the vulnerability used by
Slammer to write the value 0 to the virtual address
0x0102aabb in the SQL server process. It is required that
we get the value 0x0102aabb into the EAX register before
the instruction “MOV [EAX],0” is executed. This requires
that we send a long UDP packet to port 1434. Speciﬁcally,
when the Ethernet packet is received it is required that the
“IN DX” instructions that read the packet read a carefully
crafted UDP packet two bytes at a time to provide that the
packet be stored in a buﬀer and interpreted by the Windows
kernel in a certain way. When the Windows kernel checks
the 24th byte of the packet it is required that this memory
location hold the value 0x11 so that when it is loaded into
a register and compared to 0x11 the branch will be taken
where the kernel interprets it as a UDP packet. Similar
requirements on the port number and destination address
will provide the state transitions of the kernel recognizing a
packet for the SQL server process and then context switch-
ing into that process providing us with the ability to read
and write the physical memory of that process.
The SQL thread chosen to handle the request will then
context switch to the kernel and back twice to obtain the
source address and port number information and then to
read the packet into its own memory space. Then it is
required of each byte that it not be equal to “0x00” or
“0xFF” in order to reach the buﬀer overﬂow condition. It
is also required of the ﬁrst data byte of the UDP packet
to be equal to “0x04” so that the vulnerable function is
reached through the sequence “MOV EDX,[EBP+fffffbf4];
JMP [42cfa23b+EDX<<2]”. Then before “MOV [EAX],0”
the EAX register must hold the attacker’s desired arbitrary
address (0x0102aabb), provided by the instruction, “MOV
EAX, [EBP+10]” which requires the value 0x0102aabb to be
at “[EBP+10]”. Finally, all of this will provide the primitive
that the value 0 is written to the virtual address 0x0102aabb
of the SQL server process which may be required for some
exploit such as the one suggested in Subsection 4.3.3.
5.3.3 Should Focus on Primitives, not Vulnerabilities
The goal of a signature generation algorithm based on
DACODA, then, should be to, given the partial ordering
constructed for a single exploit as analyzed by DACODA,
identify the primitive most valuable to the attacker in gen-
erating new exploits and generate a signature that prevents
that primitive. This will most likely have to be done with
heuristics. A good heuristic is that arbitrary write primi-
tives are valuable to an attacker, which will be revealed by
a write provided by a requirement that the address used for
the write was data from the range of . That requirement
was provided by some other requirement, which in turn was
provided by another requirement, giving us a way to work
backwards and generate a primitive-speciﬁc signature from
the partial ordering. Another good heuristic is that saved
base pointers and return pointers on the stack should not be
overwritten by long ﬁelds, but this requires knowing which
ﬁeld is too long which in turn requires knowing what the de-
limiters between ﬁelds are for that particular protocol (in-
formation that will have to be extracted from the partial
ordering). Similar heuristics could be made for any sort of
primitive that an attacker might ﬁnd valuable in building
exploits. The point is that an attacker who searches for a
zero-day vulnerability is not so much searching for a vulner-
ability as for a useful primitive for generating exploits.
6. FUTURE WORK
DACODA can be useful toward a variety of objectives,
several of which we will now discuss. In this paper we have
used DACODA to analyze known exploits as a quantitative,
empirical analysis of the amount of polymorphism available
to an attacker within the exploit vector. DACODA may also
be used as a honeypot technology to perform the same analy-
sis on zero-day worms exploiting unknown vulnerabilities for
signature generation. This same idea was employed in Vig-
ilante [10] and suggested as future work for Polygraph [28]
and TaintCheck [29].
Other possible future work for DACODA is to use pred-
icates discovered by DACODA and heuristics about diﬀer-
ent memory corruption errors to narrow the search space
of a random “fuzz tester” [26, 27]. It would be possible to
ﬁnd buﬀer overﬂows and other remote vulnerabilities in both
user-space and the kernel this way. This system would be
similar to two recent papers on automatically generating test
cases [4, 18] but would operate on a full system without the
source code and ﬁnd remote vulnerabilities.
Full system symbolic execution has many other security
applications, but it was pointed out in Cohen’s seminal pa-
per on computer viruses [9] that the general problem of pre-
cisely marking information ﬂow within a system was shown
to be NP-complete by Fenton [17]. DACODA is able to an-
alyze the exploit vector part of an attack because the code
being executed is code chosen by the owner of the host such
as the operating system and software she chooses to install.
After control ﬂow is hijacked the computational complexity
of information ﬂow tracking is more than a theoretic problem
because the attacker can use techniques such as phi-hiding
to obfuscate information ﬂow in a cryptographically strong
manner [45].
7. CONCLUSION
This paper presented DACODA and provided a quanti-
tative look at the exploit vectors mapped by  for 14 real
exploits. These results and our experiences with DACODA
discussed in this paper oﬀer practical experience and sound
theory towards reliable, automatic, host-based worm signa-
ture generation. We have shown that 1) single contiguous
byte string signatures are not eﬀective for content ﬁltering,
and token-based byte string signatures composed of smaller
substrings are only semantically rich enough to be eﬀective
for content ﬁltering if the vulnerability lies in a part of a pro-
tocol that is not commonly used, and that 2) whole-system
analysis is critical in understanding exploits. As a conse-
quence we conclude that the focus of a signature generation
algorithm based on DACODA should be on primitives rather
than vulnerabilities.
8. ACKNOWLEDGMENTS
This work was supported by NSF ITR grants CCR-
0113418 and ACI-0220147. We are also very grateful to
our shepherd, Dan Boneh, and many people who discussed
the Minos and DACODA projects with us or read earlier
versions of this paper, including Daniela Alvim Seabra de
Oliveira, Timothy Sherwood, Helen Wang, and everyone in
the U.C. Davis malware reading group and security lab sem-
inar. The anonymous reviewers also provided very insightful
comments. We would also like to thank the Bochs develop-
ers.
9. REFERENCES
[1] P. Akritidis, E. P. Markatos, M. Polychronakis, and
K. Anagnostakis. Stride: Polymorphic sled detection through
instruction sequence analysis. In 20th IFIP International
Information Security Conference.
[2] Barnaby Jack. Remote Windows Kernel Exploitation-Step Into
the Ring 0.
[3] E. G. Barrantes, D. H. Ackley, T. S. Palmer, D. Stefanovic, and
D. D. Zovi. Randomized instruction set emulation to disrupt
binary code injection attacks. In Proceedings of the 10th ACM
conference on Computer and communication security, pages
281–289. ACM Press, 2003.
[4] C. Cadar and D. Engler. Execution generated test cases: how
to make systems code crash itself. In SPIN, 2005.
[5] S. Chen, J. Xu, and E. C. Sezer. Non-control-hijacking attacks
are realistic threats. In USENIX Security Symposium 2005,
2005.
[6] R. Chinchani and E. van den Berg. A fast static analysis
approach to detect exploit code inside network ﬂows. In RAID,
2005.
K. Fan. Buttercup: On network-based detection of polymorphic
buﬀer overﬂow vulnerabilities. In 9th IEEE/IFIP Network
Operation and Management Symposium (NOMS’2004), 2004.
[7] M. Christodorescu and S. Jha. Static analysis of executables to
[31] U. Payer, P. Teuﬂ, and M. Lamberger. Hybrid engine for
detect malicious patterns, 2003.
[8] M. Christodorescu, S. Jha, S. A. Seshia, D. Song, and R. E.
Bryant. Semantics-aware malware detection. In Proceedings of
the 2005 IEEE Symposium on Security and Privacy (Oakland
2005), Oakland, CA, USA, May 2005.
[9] F. Cohen. Computer viruses: theory and experiments. In 7th
DoD/NBS Computer Security Conference Proceedings, pages
240–263, September 1984.
[10] M. Costa, J. Crowcroft, M. Castro, and A. Rowstron. Can we
contain internet worms? In HotNets III.
[11] M. Costa, J. Crowcroft, M. Castro, A. Rowstron, L. Zhou,
L. Zhang, and P. Barham. Vigilante: End-to-end containment
of Internet worms. In SOSP ’05: Proceedings of the twentieth
ACM Symposium on Operating Systems Principles, New
York, NY, USA, 2005. ACM Press.
polymorphic shellcode detection. In Proceedings of GI SIG
SIDAR Conference on Detection of Intrusions and Malware
and Vulnerability Assessment (DIMVA), 2005.
[32] T. H. Ptacek and T. N. Newsham. Insertion, evasion, and
denial of service: Eluding network intrusion detection.
Technical report, Secure Networks, Inc., Suite 330, 1201 5th
Street S.W, Calgary, Alberta, Canada, T2R-0Y6, 1998.
[33] C. Raiu. Holding the Bady. In Virus Bulletin, 2001.
[34] S. Rubin, S. Jha, and B. P. Miller. Automatic generation and
analysis of NIDS attacks. In 20th Annual Computer Security
Applications Conference (ACSAC).
[35] S. Rubin, S. Jha, and B. P. Miller. Language-based generation
and evaluation of NIDS signatures. In IEEE Symposium on
Security and Privacy, Oakland, California, May, 2005.
[36] M. E. Russinovich and D. A. Solomon. Microsoft Windows
[12] J. R. Crandall and F. T. Chong. A Security Assessment of the
Internals, Fourth Edition. 2004.
Minos Architecture. In Workshop on Architectural Support for
Security and Anti-Virus, Oct. 2004.
[13] J. R. Crandall and F. T. Chong. Minos: Control data attack
prevention orthogonal to memory model. In Proceedings of the
37th International Symposium on Microarchitecture
(MICRO), December 2004.
[14] J. R. Crandall, S. F. Wu, and F. T. Chong. Experiences using
Minos as a tool for capturing and analyzing novel worms for
unknown vulnerabilities. In Proceedings of GI SIG SIDAR
Conference on Detection of Intrusions and Malware and
Vulnerability Assessment (DIMVA), 2005.
[15] H. Dreger, C. Kreibich, V. Paxson, and R. Sommer. Enhancing
the accuracy of network-based intrusion detection with
host-based context. In Proceedings of GI SIG SIDAR
Conference on Detection of Intrusions and Malware and
Vulnerability Assessment (DIMVA), 2005.
[16] G. W. Dunlap, S. T. King, S. Cinar, M. A. Basrai, and P. M.
Chen. Revirt: enabling intrusion analysis through
virtual-machine logging and replay. SIGOPS Oper. Syst. Rev.,
36(SI):211–224, 2002.
[17] J. Fenton. Information protection systems. In Ph.D. Thesis,
University of Cambridge, 1973.
[18] P. Godefroid, N. Klarlund, and K. Sen. DART: Directed
Automated Random Testing. In PLDI, 2005.
[19] S.-S. Hong, F. Wong, S. F. Wu, B. Lilja, T. Y. Jansson,
H. Johnson, and A. Nelsson. TCPtransform: Property-oriented
TCP traﬃc transformation. In Proceedings of GI SIG SIDAR
Conference on Detection of Intrusions and Malware and
Vulnerability Assessment (DIMVA), 2005.
[20] S.-S. Hong and S. F. Wu. On interactive Internet traﬃc replay.
In RAID, 2005.
[37] S. Singh, C. Estan, G. Varghese, and S. Savage. Automated
worm ﬁngerprinting. In OSDI, 2004.
[38] P. Szor. The Art of Computer Virus Research and Defense.
2005.
[39] S. J. Templeton and K. Levitt. A requires/provides model for
computer attacks. In NSPW ’00: Proceedings of the 2000
workshop on New security paradigms, pages 31–38, New York,
NY, USA, 2000. ACM Press.
[40] T. Toth and C. Kr¨ugel. Accurate buﬀer overﬂow detection via
abstract payload execution. In RAID, pages 274–291, 2002.
[41] N. Vachharajani, M. J. Bridges, J. Chang, R. Rangan,
G. Ottoni, J. A. Blome, G. A. Reis, M. Vachharajani, and D. I.
August. Riﬂe: An architectural framework for user-centric
information-ﬂow security. In Proceedings of the 37th
International Symposium on Microarchitecture (MICRO),
December 2004.
[42] G. Vigna, W. Robertson, and D. Balzarotti. Testing
Network-based Intrusion Detection Signatures Using Mutant
Exploits. In Proceedings of the ACM Conference on Computer
and Communication Security (ACM CCS), pages 21–30,
Washington, DC, October 2004.
[43] H. J. Wang, C. Guo, D. R. Simon, and A. Zugenmaier. Shield:
vulnerability-driven network ﬁlters for preventing known
vulnerability exploits. In SIGCOMM ’04: Proceedings of the
2004 conference on Applications, technologies, architectures,
and protocols for computer communications, pages 193–204.
ACM Press, 2004.
[44] V. Yegneswaran, J. T. Giﬃn, P. Barford, and S. Jha. An
architecture for generating semantics-aware signatures. In
USENIX Security Symposium, 2005.
[45] A. Young and M. Yung. Malicious Cryptography: Exposing
[21] H.-A. Kim and B. Karp. Autograph: Toward automated,
Cryptovirology. 2004.
distributed worm signature detection. In USENIX Security
Symposium, pages 271–286, 2004.
[22] J. C. King. Symbolic execution and program testing. Commun.
ACM, 19(7):385–394, 1976.
[23] O. Kolesnikov and W. Lee. Advanced polymorphic worms:
Evading IDS by blending in with normal traﬃc.
[24] C. Kreibich and J. Crowcroft. Honeycomb: creating intrusion
detection signatures using honeypots. SIGCOMM Comput.
Commun. Rev., 34(1):51–56, 2004.
[25] C. Kr¨ugel, E. Kirda, D. Mutz, W. Robertson, and G. Vigna.
Polymorphic worm detection using structural information of
executables. In RAID, 2005.
[26] B. Miller, D. Koski, C. P. Lee, V. Maganty, R. Murthy,
A. Natarajan, and J. Steidl. Fuzz revisited: A re-examination
of the reliability of UNIX utilities and services. Technical
report, 1995.
[27] B. P. Miller, L. Fredriksen, and B. So. An empirical study of
the reliability of UNIX utilities. Communications of the
Association for Computing Machinery, 33(12):32–44, 1990.
[28] J. Newsome, B. Karp, and D. Song. Polygraph: Automatically
generating signatures for polymorphic worms. In Proceedings of
the IEEE Symposium on Security and Privacy, May, 2005.
[29] J. Newsome and D. Song. Dynamic taint analysis for automatic
detection, analysis, and signature generation of exploits on
commodity software. In Proceedings of the 12th Annual
Network and Distributed System Security Symposium (NDSS
05), Feb. 2005.
[30] A. Pasupulati, J. Coit, K. Levitt, S. Wu, S. Li, R. Kuo, and
[46] bochs: the Open Source IA-32 Emulation Project (Home Page),
http://bochs.sourceforge.net.
[47] eEye advisory for the DCOM RPC Race Condition
(http://www.eeye.com/html/research/advisories/
AD20040413B.html).
[48] eEye advisory for the LSASS buﬀer overﬂow
(http://www.eeye.com/html/research/advisories/
AD20040413C.html).
[49] General William T. Sherman, as quoted in B. H. Liddell Hart,
Strategy, second revised edition.
[50] Microsoft advisory MSXX-YYY
(http://www.microsoft.com/technet/security/bulletin/
MSXX-YYY.mspx).
[51] QEMU (Home Page), http://fabrice.bellard.free.fr/qemu/.
[52] Security Focus Vulnerability Notes,
(http://www.securityfocus.com), bid == Bugtraq ID.
[53] SNORT: The open source network intrusion detection system
(http://www.snort.org). 2002.