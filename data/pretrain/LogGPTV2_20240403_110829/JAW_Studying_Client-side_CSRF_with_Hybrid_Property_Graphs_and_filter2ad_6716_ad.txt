snapshot. We repeated our evaluation using JAW-static, and
determined the lower bound of false negative and false pos-
itive vulnerabilities in JAW-static by comparing it to JAW’s
evaluation results. Also, we compare the differences in HPG
nodes, edges and properties.
Then, we logged all the ﬁred events that are not auto-
triggered and that JAW failed to ﬁnd their line of code for
HPG construction. Such cases are an indication of false neg-
ative edges in HPGs generated by JAW. Accordingly, we
manually review all cases to uncover the reasons for false
negative edges. Finally, we conducted another experiment to
assess the false positive and false negative edges as a result of
using the DOM tree snapshots for points-to analysis of DOM
queries. For all web pages, we instrumented the JavaScript
code to log the actual element a DOM query is referring to,
and compared it against the value that JAW resolved. JAW
uses these resolutions to create ERDDG edges, opening the
possibility for both false positive and false negative edges.
5.2 Analysis of Collected Data
Size of the Analysis. Starting from 113 seed URLs, JAW
extracted 4,836 web pages, ranging from 1 to 456 web pages
per web application, and about 46 web pages per application.
The structural analysis of these URLs reveals that 865 of them
have a hash fragment, an indication that these URLs carry
state information for the client-side JavaScript program—a
characteristic of single-page web applications. In total, 39
web applications use URLs with hash fragments.
From the 4,836 pages, JAW extracted 228,763,028 LoC,
which amounts to generating 4,836 HPGs by processing about
47,304 LoC per page. When looking at the origin of the code,
we observed that the majority of it, i.e., 60.55%, is from shared
libraries, e.g., jQuery (28,645 LoC per page and 138,525,092
LoC in total), whereas the remaining is application code in
script tags (39.42% or 18,649 LoC per page, over 90,188,256
LoC in total) and a negligible amount is inline code (0.02%
or 10 LoC per page, over 49,680 LoC in total).
Finally, at run-time, we observe that about 2.63% of the
script tags are loaded dynamically (i.e., by inserting a script
tag programmatically), over a total of 104,720 script tags.
Also, JAW observed 51,974 events that are ﬁred when loading
the page (about 11 events per page) distributed across 46
event types, of which 38 are HTML5 types (e.g., animation
and DOM mutation events) and 8 are custom. As we will
show next, even if the number of run-time monitored events
is negligible, their role in the analysis is fundamental.
Importance of Symbolic Modeling. The analysis of client-
side programs requires to process 228,763,028 LoC of which
138,525,092 of them are for the libraries alone, about 60% of
the total. Our analysis reveals that libraries are largely reused
both across web applications and across pages. First, the 106
web applications in our testbed use in total 31 distinct libraries.
Second, each page contains from zero to seven script libraries,
with an average number of two libraries per page. Third, the
total amount of code of the 31 libraries is 412,575 LoC, which
is 335 times smaller than the total 138,525,092 LoC across all
pages. Accordingly, pre-processing the library code to extract
a symbolic model reduces by more than half (-60.37%) the
effort required to generate HPGs, moving from 228,763,028
LoC to 90,650,511 (i.e., the sum of LoCs of the application,
inline JavaScript, and the 31 libraries).
For each of the 31 libraries, JAW generates one HPG and
extract a symbolic model. Table 1 shows an overview of the
results of the symbolic modeling step. In total, JAW mod-
eled 11,977 functions in around half an hour, half of which
have the input-output relationship semantic types (i.e., 5,923
functions)—a relevant function behavior to correctly recon-
struct the data ﬂows of a program.
Role of ERDDG.
In total, JAW generated 4,836 HPGs,
one for each page, for a total of 508,810,412 nodes and
652,662,573 edges. Of these edges, the ones that are cru-
cial to analyze JavaScript programs are those modeling the
transfer of control via event handlers. In total, JAW identiﬁed
64,854,097 event edges (i.e., registration, dependence and
dispatch) of which 6,451,582 are dispatch edges, i.e., edges
modeling the intention to execute the event handlers. For com-
parison, the number of call edges that also transfer the control
2534    30th USENIX Security Symposium
USENIX Association
Library
Usage %
LoC
Funcs.
I/O
Time (s)
Sources
Forgeable
Apps
JQuery
Bootstrap
JQuery UI
ReactJS
ReactDOM
RequireJS
AngularJS
Analytics
Backbone
Modernizer
Prototype
YUI
JIT
ChartJS
Dojo
LeaﬂetJS
Scriptaculous
HammerJS
MomentJS
ExtJS
Vue
YUI History
Bootstrap Growl
Bpmn-Modeler
CookiesJS
FlotChartsJS
GWT WebStarterKit
Gzip-JS
Handlebars
SpinJS
SWFObject
Total
81.13%
38.67%
27.35%
9.43%
9.43%
8.49%
5.66%
5.66%
5.66%
5.66%
5.66%
4.71%
3.77%
2.83%
2.83%
2.83%
2.83%
1.88%
1.88%
1.88%
1.88%
1.88%
0.94%
0.94%
0.94%
0.94%
0.94%
0.94%
0.94%
0.94%
0.94%
10,872
2,377
18,706
3,318
25,148
1,232
36,431
20,345
2,096
834
7,764
29,168
17,163
16,152
18,937
14,080
3,588
2,643
4,602
135,630
11,965
789
215
19,139
79
1,267
110
280
6,726
190
729
428
55
320
130
688
50
852
244
148
292
266
2,414
430
263
696
650
97
67
138
2,701
638
20
7
231
3
15
3
4
103
4
20
412,575
11,977
238
55
320
40
368
50
558
233
50
21
243
637
255
253
313
208
84
47
138
1,135
288
10
7
228
0
15
2
4
103
4
16
5,923
57.54
41.07
82.33
39.59
81.98
35.72
82.92
69.21
38.26
34.50
54.10
149.34
69.11
76,75
63.32
62.65
46.11
37.01
45.44
231.86
62.77
18.41
32.21
65.84
31.29
42.38
31.15
31.87
50.83
31.99
33.61
1919.84
Table 1: Symbolic modeling of shared JavaScript libraries.
to other sites of a program, are 7,179,021, meaning that the
ERDDG representation enables the identiﬁcation of +89.87%
edges transferring the program control.
5.3 Forgeable Requests
The ﬁrst step to detect client-side CSRF is the identiﬁcation
of lines of code that can generate attacker-controlled requests.
For that, we prepared a set of queries as discussed in §3.3.
Based on our threat model (§2.1), we considered different
attacker-controlled inputs for JavaScript programs (see [60])
that can be forged by different attackers.
JAW identiﬁed 49,366 lines of code across 106 applications
that can send an HTTP request, and marked 36,665 of them
as unreachable during the page load or not using attacker-
controlled inputs. The remaining 12,701 requests could be
controlled by an attacker. We grouped these requests by the
semantic types of the input source corresponding to different
attackers (see §2.1), as shown in Table 2. We observe that the
majority of applications, i.e., 87, sends at least one forgeable
request at page load.
False Positives. Considering the high number of forgeable
requests, we could not verify all of them via manual inspec-
tion. Instead, we ﬁrst selected all requests across all groups,
except for DOM.READ. Then, for DOM.READ, we focused on one
request (randomly selected) for each web application, i.e., 83
requests. In total, we inspected 516 forgeable requests. For the
inspection, we loaded the vulnerable page in an instrumented
browser to inject manipulated strings and observe whether
the outgoing requests include manipulated strings. We con-
ﬁrmed that all requests, except for one of the 83 DOM.READ
DOM.COOKIES
DOM.READ
*-STORAGE
DOC.REFERRER
POST-MESSAGE
WIN.NAME
WIN.LOC
Total forgeable
Non-reachable code
Total
67
12,268
76
1