文本行是UNIX的通用格式，当你在编写自已的工具程序时便会发现，内含文本行
的数据文件很好处理，你可以用任何睡手可得的文本编辑器来编辑它，也可以让这
图4：
www.TopSage.com
---
## Page 31
背景知识
Z19
些数据在网络与各种机器架构之间传输，使用文本文件更有助于任何自定义工具与（m
现存的UNIX程序之间的结合。
使用正则表达式
正则表达式（regularexpression）是很强的文本处理机制。了解它的运作模式井加
以使用，可适度简化编写命令脚本（script）的工作。
此外，虽然正则表达式多年来在工具与UNIX版本上不断在变化，但POSIX标准
仅提供两种正则表达式，你可以利用标准的库程序进行模式匹配的工作，这样就可
以编写出专用的工具程序，用于与grep一致的正则表达式（POSIX称之为基本型
正则表达式，Basic Regular Expressions，BRE），或是用于与egrep一致的正则
表达式（POSIX称之为扩展型正则表达式，ExtendedRegularExpressions，ERE）。
默认使用标准输入/输出
在未明确指定文件名的情况下，程序默认会从它的标准输人读取数据，将数据写到
它的标准输出，至于错误信息则会传送到标准错误输出（这部分将于第2章讨论）。
以这样的方式来编写程序，可以轻松地让它们成为数据过滤器（filter），例如，组
成部分的规模越大，越需要复杂的管道（pipeline）或脚本来处理。
道免噪噪不休
当你有意将一些工具串成一条管道时，例如：
too1_1  resultfi1e
么别指望执行结果会像预期的一样。此外，若每个工具都将自己的信息传送至标准
错误输出，那么整个屏幕画面就会布满一堆无用的过程信息。在工具程序的世界
里，没有消息就是好消息。
这个原则其实还有另外一个含义。一般来说，UNIX工具程序一向遵循“你叫它败
什么，你就会得到什么”的设计哲学，它们不会间“你确定吗？”（areyou sure？）
这种问题，当用户键入rmsomefile，UNIX的设计人员会认为用户知道自己在
做什么，然后毫无疑问地rm删除掉要删除的文件（注5）。
 5 :
如果你真觉得这样不好，rm的-i选项可强制rm给你提示以做确认，这么一来，当你要
求则除可疑文件时，rm便会提示确认它。一直以来，应该“永选不要提示”还是应该“永
选得到提示”是个争议的话题，值得用户深思。
www.TopSage.com
---
## Page 32
20
第1章
输出格式必须与可接受的输人格式一致
专业的工具程序认为遵循某种格式的输入数据，例如标题行之后接着数据行，或在
行上使用某种字段分隔符等，所产生的输出也应遵循与输入一致的规则。这么做的
好处是，容易将一个程序的执行结果交给另一个程序处理。
举例来说，netpbm程序集（注5）是用来处理以PortableBitMap（PBM）格式保
存的图像文件（注6），这些文件内含bitmapped图像，并使用定义明确的格式加以
绘制。每个读取PBM文件的工具程序，都会先以某种格式来处理文件内的图像，然
后再以PBM的格式写国文件。这么一来，便可以组合简单的管道来执行复杂的图
像处理，例如先缩放影像后，再旋转方向，最后再把颜色调淡。
让工具去做困难的部分
虽然UNIX程序并非完全符合你的需求，但是现有的工具或许已经可以为你完成
90%的工作，接下来，若有需要，你可以编写一个功能特定的小型程序来完成剩下
的工作。与每次都从头开始来解决各个间题相比，这已经让你省去许多工作了。
构建特定工具前，先想想
如前所述，若现存系统里就是没有需要的程序，可以花点时间构建满足所需的工
其。然而，动手编写一个能够解决问题的程序前，请先停下来想儿分钟。你所要做
的事，是否有其他人也需要做？这个特殊的工作是否有可能是某个一般问题的一个
特例？如果是的话，请针对一般问题来编写程序。当然，这么微的时候，无论是在
程序的设计或编写上，都应该遵循前面所提到的几项原则。
1.3小结
UNIX原为贝尔实验室的计算机科学家所开发的产品，由于没有盈利上的压力，再加上
PDP-11小型计算机的能力有限，因而程序都以小型、优雅为圭泉。也因为没有盈利上的
压力，系统之间井非完全一致，学习上也不太容易。
随着UNIX持续地流行，各种版本陆续开发出来（尤其是衍生白SystemV和BSD的版
本），Shel1期本层次的可移植性也日益固难。幸好，POSIX标准成熟后，几乎所有商用
UNIX系统与免费的UNIX版本都兼容POSIX。
注 6 ;
这秦程序并非UNIX 工其集的标准配备，不过 GNU/Linux 与 BSD系统上通常都会安
装。其网站位于hrrp://netpbm.sourceforge.net/。可接照Sourceforge项目网页的指示，
下载源代码。
注7；
有三种格式，若你的系统里有安策netpbm，可参阅pnm（5）手册页，
www.TopSage.com
---
## Page 33
背景知识
21
之所以会在这里指出软件工具的设计原则，主要是为了提供开发与使用UNIX工具集的
指导方针。让软件工具的设计原则成为思考习惯，将有助于编写简浩的Shell程序和正
确使用UNIX工具。
www.TopSage.com
---
## Page 34
第2章
Sage.com
入门
当需要计算机帮你做些什么时，最好用对工具。你不会用文字编辑器来做支票簿的核对，
也不会用计算器来写策划方案。同理，当你需要程序语言协助完成工作时，不同的程序
语言用于不同的需求。
Shell脚本最常用于系统管理工作，或是用于结合现有的程序以完成小型的、特定的工
作。一且你找出完成工作的方法，可以把用到的命令串在一起，放进一个独立的程序或
脚本（script）里，此后只要直接执行该程序便能完成工作。此外，如果你写的程序很有
用，其他人可以利用该程序当作一个黑盒（blackbox）来使用，它是一个可以完成工作
的程序，但我们不必知道它是如何完成的。
本章中，我们会先对脚本编程（scripting）语言和编译型（compiled）语言微个简单的
比较，再从如何编写简单的Shell脚本开始介绍起。
2.1脚本编程语言与编译型语言的差异
许多中型、大型的程序都是用编译型语言写成，例如Fortran、Ada、Pascal、C、C++或
Java。这类程序只要从源代码（sourcecode）转换成目标代码（objcctcode），便能直
接通过计算机来执行（注1）。
编译型语言的好处是高效，缺点则是：它们多半运作于底层，所处理的是字节、整数
浮点数或是其他机器层级的对象。例如，在C++里，就很难进行“将一个目录里所有的
文件复制到另一个目录中”之类的简单操作。
泌 1:
这种说法在Java上并不完全正确，不过已相当接近我们所说的情况了。
22
www.TopSage.com
---
## Page 35
入门
23
脚本编程语言通常是解释型（interpreted）的，这类程序的执行，是由解释器（interpreter）
读入程序代码，并将其转换成内部的形式，再执行（注2）。请注意，解释器本身是一般
的编译型程序，
2.2
为什么要使用Shell脚本
使用脚本编程语言的好处是，它们多半运行在比编译型语言还高的层级，能够轻易处理
文件与目录之类的对象。缺点是：它们的效率通常不如编译型语言。不过权衡之下，通
需使用脚本编程还是值得的：花一个小时写成的简单脚本，同样的功能用C或C++来编
写实现，可能需要两天，而且一般来说，脚本执行的速度已经够快了，快到足以让人忽
路它性能上的问题。脚本编程语言的例子有awk、Perl、Python、Ruby与Shell。
因为ShelI似乎是各UNIX系统之间通用的功能，并且经过了POSIX的标准化。因此，
Shell脚本只要“用心写”一次，即可应用到很多系统上，因此，之所以要使用Shell脚
本是基于：
简单性
Shell是一个高级语言，通过它，你可以简洁地表达复杂的操作。
可移植性
使用POSIX所定义的功能，可以做到脚本无须修改就可在不同的系统上执行。
开发容易
可以在短时间内完成一个功能强大又好用的脚本。
2.3
一个简单的脚本
让我们从简单的脚本开始。假设你想知道，现在系统上有多少人登录。who命令可以告
诉你现在系统有谁登录：
$ wbo
951085
pt8/2
Dec 31 16:39
(va1ley -forge,example,com)
betsy
Pts/3
Dec 27 11:07
(kites.example,com)
(fLags-zu8,example,com)
benjamin
Jhancock
dt1ocal
55+2t .2 390
pts/5
Dee 27 17:55
camus
P8/6
Dec 31 16:22
(:32)
tolstoy
pts/14
Jan 2 06:42
注2:
尽管hrrp://foidoc.doc.ic.ac.uk/foldoc/foldoc.cgi?Ousterhout’s+dichotomy议图为编译型
与脚本编程语言的差异下定叉，但是人们对此一直接难达成共识。
www.TopSage.com
---
## Page 36
24
第2章
在大型的、多用户的系统上，所列出来的列表可能很长，在你能够计算用户个数之前，
列表早已滚动出屏幕画面，因此每次做这件事的时候，都会让你觉得很麻烦：这正是进
行自动化的好时机。计算用户总数的方法尚未提到。对此，我们可以利用wc（字数计
算）程序，它可以算出行数（line）、字数（word）与字符数（character）。在此例中，我
们用的是wc-1，也就是只算出行数：
$ who 1 wc -1
计算用户个数
6
1（管道）符号可以在两程序之间建立管道（pipeline）：who的输出，成了wc的输人，
wc所列出的结果就是已登录用户的个数。
' *
下一步则是将此管道转变成一个独立的命令，方法是把这条命令输人一个一般的文件中，
然后使用chmod为该文件设置执行的权限，如下所示：
S cat > nusers
建立文件，使用car复制终端的输入
vbo 1 wc -1
Crrl-D 表示end-of-file
程序的内容
G
S chnod +x musers
让文件拥有执行的权限
S./nusers
执行制试
输出我们要的结果
这展现了小型Shell脚本的典型开发周期：首先，直接在命令行（commandline）上测
试。然后，一且找到能够完成工作的适当语法，再将它们放进一个独立的脚本里，并为
该脚本设置执行的权限。之后，就能直接使用该脚本，
2.4自给自足的脚本：位于第一行的#！
当Shell执行一个程序时，会要求UNIX内核启动一个新的进程（process），以便在该进
程里执行所指定的程序。内核知道如何为编译型程序做这件事。我们的nusersShell脚
本并非编译型程序：当Shell要求内核执行它时，内核将无法微这件事，并回应“not
executableformatfile”（不是可执行的格式文件）错误信息。Shell收到此错误信息时，
就会说“啊哈，这不是编译型程序，那么一定是Shell脚本”，接着会启动一个新的/bin/
sh（标准Shell）副本来执行该程序。
当系统只有一个Shell时，“退闻到/bin/sh”的机制非常方便。但现行的UNIX系统都
会拥有好几个Shell，因此需要通过一种方式，告知UNIX内核应该以哪个Shell来执行
所指定的Shell脚本。事实上，这么做有助于执行机制的通用化，让用户得以直接引用
任何的程序语言解释器，而非只是一个命令Shell，方法是，通过脚本文件中特殊的第一
行来设置：在第一行的开头处使用#1这两个字符。
www.TopSage.com
---
## Page 37
入门
当一个文件中开头的两个字符是1时，内核会扫描该行其余的部分，看是否存在可用OIm
来执行程序的解释器的完整路径。（中间如果出现任何空白符号都会略过。）此外，内核
还会扫描是否有一个选项要传递给解释器。内核会以被指定的选项来引用解释器，再搭
配命令行的其他部分。举例来说，假设有一个csh脚本（注3），名为/usr/ucb/
whizprog，它的第一行如下所示：
1/bin/csh -f
再者，如果Shell的查找路径（后面会介绍）里有/usr/ucb，当用户键人whizprog
-q/dev/tty01这条命令，内核解释#1这行后，便会以如下的方式来引i用csh：
/p/b-5odz/q/x/-q/u/
这样的机制让我们得以轻松地引用任何的解释器。例如我们可以这样引用独立的awk程
序：
此处是at程序
1/bin/awk -f
Shell脚本通常一开始都是#！/bin/sh，如果你的/bin/sh并不符合POSIX标准，请
将这个路径改为符合POSIX标准的Shell。下面是几个初级的陷阱（gotchas），请特别
留意：
当今的系统，对#！这一行的长度限制从63到1024个字符（character）都有。请
尽量不要超过64个字符。（表2-1列出了各系统的长度限制。）
在某些系统上，命令行部分（也就是要传递给解释器执行的命令）包含了命令的完
整路径名称。不过有些系统却不是这样：命令行的部分会原封不动地传给程序。因
此，脚本是否具可移植性取决于是否有完整的路径名称。
别在选项（option）之后放置任何空白，因为空白也会跟着选项一起传递给被引用
的程序。
你需要知道解释器的完整路径名称。这可以用来规避可移植性问题，因为不同的厂
商可能将同样的东西放在不同的地方（例如/bin/awk和/usr/bin/awk）。
一些较旧的系统上，内核不具备解释#！的能力，有些Shell会自行处理，这些Shell
对于#！与紧随其后的解释器名称之间是否可以有空白，可能有不同的解释。
注 3 :
/bin/csh是CShell的命令新释器，由加例大学值免利分校所开发，本书不讨论CShell
程序设计的原因源多，其中最重费一的点是：就脚本的编写来说，大多数人认为它不是
个好用的Shel1，另一个原因则是它并未放POSIX标准化。
www.TopSage.com
---
## Page 38