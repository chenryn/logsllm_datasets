The trust management engine does not necessarily need to compute the entire fixpoint as defined by M, n, m, o. To prove that a request is justified, the engine must only find an authmap \(m\) such that \(U \subseteq m \subseteq M\),\(A\)(p)\). Identifying such an \(m\) may be more straightforward than computing the full fixpoint for two reasons. Firstly, the trust engine can operate in a lattice where elements are more compactly represented and licenses are computed more efficiently. Secondly, the engine can terminate the fixpoint computation early once a sufficiently large \(m\) has been found. The sections on KeyNote and SPKI will leverage this fact.

Figure 2 illustrates example least fixpoint computations of \(M_{\text{Auth}}, n, m, o\). Figure 3 summarizes the entire framework. An instantiation of the framework defines a trust management system by providing an authorization lattice, a language for expressing licenses, and a method for computing \(M_{\text{Auth}}, n, m, o\). The design of a trust management system involves selecting an authorization lattice and a subset of monotone functions to use as licenses, which controls the system's expressiveness. The engineering challenge lies in choosing representations for authorizations and a license language that allow the desired monotone functions to be expressed concisely and \(M_{\text{Auth}}, n, m, o\) to be computed efficiently. The rest of this section introduces a simple language for expressing licenses in the example lattice, while subsequent sections will demonstrate how to express more realistic trust management systems.

### 2.1 A Simple Trust Management Language

Using all of mathematics to write licenses is suitable for expository purposes, but for a practical trust management engine, one must define a language for expressing licenses and provide a method for the engine to compute the authorization expressed by a license. Here is an example language for the authorization set \(\text{Auth} = \{N, R, W, RW\}\):

- \(e ::= N \mid R \mid W \mid RW \mid P \mid \text{glb}(e_1, e_2, \ldots) \mid \text{lub}(e_1, e_2, \ldots)\)

A license expression can be a constant representing a lattice element, a principal (in unspecified format) denoting delegation to a principal, or the greatest lower bound (glb) or least upper bound (lub) of a sequence of other expressions. Let \(\text{ExampleLicense}\) be the set of expressions generated by the above grammar. We can define a semantics for these expressions by defining a function \(M_e\) inductively on the structure of the expressions:

- \(M_e: \text{ExampleLicense} \to \text{License}\)

It is important to note that \(M_e\) always produces a monotone function. Given a representation of \(\text{AuthMap}\) where the authorization of a principal can be found in constant time, it is clear that for any expression \(e\), we can compute \(M_e(e)(m)\) in time linear to the size of the expression. Therefore, we can compute \(M_{\text{Auth}}, n, m, o(A)\) and \(M_{\text{Auth}}, n, m, o\) in time proportional to the sum of the sizes of the licenses in \(A\).

Using \(\text{ExampleLicense}\), we can write expressions for the first six examples in Figure 1:

1. \(W\)
2. \(Bob\)
3. \(\text{lub}(W, Bob)\)
4. \(\text{glb}(W, Bob)\)
5. \(\text{glb}(R, \text{lub}(\text{glb}(Bob, Carl), \text{glb}(Carl, Dave), \text{glb}(Bob, Dave)), \text{glb}(W, Bob, Carl))\)

The last expression demonstrates that this language can be verbose for some monotone functions. Moreover, the last two examples in Figure 1 cannot be expressed at all in this language. Adding more constructs could address this, but at the cost of increased complexity in the trust management engine and potentially longer computation times. The final example would require an existential quantification operator, similar to those in [17, 18].

### 3 Simple Public Key Infrastructure (SPKI)

Figure 4 shows how to express SPKI [12, 13, 14], including SDSI [19] local names, within the framework of Section 2. The top part of the figure defines the SPKI authorization lattice and the representation of SPKI assertions. The bottom part provides the semantics of SPKI assertions by mapping them to assertions in the sense of Section 2. This figure should be read in conjunction with Figure 3, which defines the supporting infrastructure of the framework.

The SPKIAuth lattice is a powerset lattice with two types of authorizations: name and action. For an authmap \(m\), if a name authorization \((p', n, t)\) is in \(m(p)\), then principal \(p\) authorizes principal \(p'\) to act as name \(n\) at time \(t\). Similarly, if an action authorization \((p', y, t)\) is in \(m(p)\), then principal \(p\) authorizes principal \(p'\) to perform operation \(y\) at time \(t\). Elements of \(\text{Name}\) are arbitrary byte strings, and elements of \(\text{Sexp}\) are s-expressions, denoting operations. For this paper, \(\text{Time}\) is left unspecified, except that it is totally ordered by \(\leq\).

The meaning of a name is always relative to a given principal. A full name is a principal and a sequence of names, where \((p, t) \in \text{btF}_{\text{Auth}, n, m, o, p}(f, m)\) means that principal \(p\) can act on behalf of full name \(f\) at time \(t\). \(M_{\text{Auth}, n, m, o}\) is extended to subjects by \(M_{\text{Auth}, n, m, o, \text{sub}}\) and to name assertions by \(M_{\text{Auth}, n, m, o, \text{name}}\). A name assertion is represented by a 4-tuple \((p, n, s, (t_1, t_2))\), which means that principal \(p\) authorizes subject \(s\) to act on behalf of name \(n\) at any time between \(t_1\) and \(t_2\). The subject field can either directly identify a full name or specify a threshold subject of the form \((k, \{f_1, f_2, \ldots\})\). A principal can only act for a threshold subject if at least \(k\) of the names \(f_1, f_2, \ldots\) denote that principal.

An authorization assertion is represented by a 5-tuple \((p, s, d, y, (t_1, t_2))\), which means that principal \(p\) authorizes subject \(s\) to perform (and delegate, if \(d = \text{true}\)) the operations allowed by action \(y\) at any time between \(t_1\) and \(t_2\). We will not specify actions in more detail; abstractly, they denote sets of s-expressions, so we can assume a function.