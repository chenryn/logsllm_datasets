The trust management engine does not necessarily  need 
to compute the  entire fixpoint as defined by  M,nm,on,. 
'To 
prove that  a request is justified, all the engine must find is 
an authmap m such that U  5 m 5 M,,,,,,,,,,,(A)(p). Finding 
such an  m may  be easier  than  computing the  fixpoint for 
two reasons. First, the trust engine may be able to work in 
a lattice in which elements are more compactly represented 
and  licenses are  more  efficiently  computed.  Second,  the 
96 
A  E P(Assertion) 
(Bob, Am. W) 
(Bob, Am. W) 
(Bob, Am. R j  
(Bob, Am. W) 
(Carl, Am. m(Bob)) 
Ifp(A) computation 
Bob  Carl  Dave 
N
W
N
RW 
N
W
W
N
N
N
N
N 
N
 N 
N
N
N
N
N
N 
N
N
W
N
(Bob, Am. m(Car1)) 
(Carl, Ani. m(Bob)) 
(Bob, Am. W) 
(Carl, Am. n{R, m(Bob))) 
(Bob, Am. RW) 
(Carl, Am. n{R, m(Bob)}) 
(Bob, Am. W) 
(Carl, Am. m(Bob)) 
(Dave, Am. m(Car1)) 
N
N
N
W
N
N
RW 
N 
N 
RW 
N
N
  N 
W
N
W
w
w
(Bob, Am. W) 
N
N
(Carl. Am. RW) 
N 
W 
w  RW  w 
(Dave, Am. n{m(Bob), m(Car1))) 
(Bob, Am. W) 
N
 N 
(Bob, Am. mfCar1)) 
N
W
(Carl, Am. if W  m(Bob) then R else N)  W 
N 
RW 
N 
N
N
N
N 
R 
N
N
W
w
N
RW 
N
N
R 
R 
Comment 
  A direct authorization. 
  Auths combined using U. 
  Unconstrained delegation. 
Least fixpoint. 
  Constrained delegation. 
  Constrained delegation. 
Chained delegation. 
  Multiway delegation. 
Inter-assertion communication. 
Figure 2. Example least fixpoint computations of  MA$)L.,,,on, 
- 
p  E  Principal 
U  E  Auth 
m  E  AuthMup  =  Principal 
1  E  License  =  AuthMup 
Auth 
a  E  Assertion  =  Principal  x  License 
Auth 
Figure 3. Framework 
97 
engine may  terminate the  fixpoint computation early, once 
a large enough m has been found. The sections on KeyNote 
and SPKI will take advantage of this fact. 
Figure 3 summarizes the entire framework. An instantia- 
tion of the framework defines a trust management system by 
providing Auth  lattice, a language for expressing licenses, 
and a means of  computing M,,,,,,.  The art  in  designing a 
trust management system lies in choosing a lattice of autho- 
rizations and a subset of the monotone functions to be used 
as licenses.  This controls the expressiveness of the system. 
The engineering comes in choosing a representation for au- 
thorizations and a language for licenses so that the desired 
monotone functions can be expressed concisely and so that 
M,,,,,  can  be  computed efficiently.  The rest  of  this sec- 
tion is devoted to a toy language for expressing licenses in 
the example lattice  of  this section.  The following sections 
will  show how  to express more realistic  trust management 
systems. 
2.1  A toy trust management language 
Using  all  of  mathematics  to  write  licenses  is  fine  for 
expository purposes, but  in  order to build  a practical  trust 
management  engine,  one  must  define  a  language  for ex- 
pressing  licenses  and  give  a  way  for  the  trust  manage- 
ment engine to compute the  authorization expressed  by  a 
license.  Here  is  an  example language of  expressions for 
Auth = {N, R, W, RW}. 
e 
::=  N I R I W I R W  
I
I 
I 
P
(glb e  . . .  ) 
( l u b e  . . .  ) 
A license expression is either a constant denoting the corre- 
sponding lattice element, or a principal (in unspecified  for- 
mat) denoting delegation to a principal, or the greatest lower 
bound (glb), or the least upper bound (lub) of a sequence 
of other expressions. Let ExampleLicense  be the set of ex- 
pressions generated by the above grammar. We can give a 
semantics to expressions by defining a function M ,  induc- 
tively on the structure of expressions. 
M, : ExampleLicense  -+  License 
Observe that  M E ,  always produces  a  monotone function. 
Given a representation of AuthMap in which the authoriza- 
tion of a principal can be found in constant time, it is clear 
98 
that for any expression e, we  can compute M , ,  (e)(m) in 
time  linear  in  the  size of  the  expression.  Hence,  we  can 
compute M ,,,,,,,,,,,(A) and M,,,,,, in time proportional to the 
sum of the sizes of the licenses in A. 
Using ExampleLicense, we can write expressions denot- 
ing the first six examples in Figure  1. 
1)  w 
2)  Bob 
3)  (lub WBob) 
4)  (glb WBob) 
5) 
6)  (glb R  (lub (glb Bob  Carl) 
(glb Carl  Dave) 
(gib Bob  Dave)  ) 
(gib w Bob Carl) 
The last  expression shows that this language may  be  ver- 
bose in expressing some monotone functions. Even worse, 
the  last  two examples in  Figure  1  can not  be expressed at 
all in this language. Of  course, by  adding more constructs, 
one could express those examples as well, but at the cost of 
additional complexity in  the  trust management engine and 
possibly  additional time taken  in computing MF,,. The last 
example would  require an existential quantification  opera- 
tor, similar to that of [ 17, 181. 
3  Simple Public Key Infrastructure (SPKI) 
Figure 4 shows how to express SPKI [ 12, 13, 141, includ- 
ing SDSI [ 191 local names, in  the framework of Section 2. 
The upper part of the figure defines the lattice of  SPKI au- 
thorizations and the representation of SPKI assertions. The 
lower part gives the semantics of SPKI assertions, by show- 
ing how to map them to assertions in the sense of Section 2. 
The figure  should be read  along with  Figure 3 ,  which de- 
fines the supporting infrastructure of the framework. 
The SPKIAuth lattice is a powerset lattice with two kinds 
of authorizations, name and action. For authmap m, if name 
authorization  (p’, n, t )  is  in  m ( p ) ,  then  principal  p  autho- 
rizes principal p’  to act as  name n at time t.  Similarly, if 
action authorization (p’, y, t) is in m(p) then principal p  au- 
thorizes principal p’  to perform operation y  at time t. Ele- 
ments of Name are arbitrary  byte strings. Elements of Sexp 
are s-expressions, and denote operations. For this paper, we 
will  leave  Time unspecified,  other than  to note  that it is to- 
tally ordered by <. 
The meaning  of  a  name  is  always  taken  relative  to  a 
given principal. A full nanze is a principal and a sequence of 
names, where  ( p ,  t )  E  btF,,,,p(f: ,m) means that principal  p 
can act on behalf of full name f at time t. M,,,,,, is extended 
to  subjects by  M,,,,, and  to name assertions by  M,” ,,,,, *.  ,4 
name assertion is represented by a 4-tuple ( p ,  n, s, (ti, t 2 ) ) ,  
which  means that principal p  authorizes subject s to act on 
E
€
E
n e  
Name 
Sexp 
Y E  
Time 
t
Auth 
U
FullName 
f
S E  
Subject 
Delegate 
d E  
Action 
X
TimePeriod 
NameAssertion 
AuthAssertion 
SP KIAsse rtion 
E
- 
M,,,,,  : Action 
P(Sexp) 
P(Principa1 x  (Name + Sexp) x  Time) 
Principal x  Name* 
FullName + (Int x P(Ful1Name)) 
Boo1 
Time x  Time 
Principal x Name x Subject x  TimePeriod 
Principal x  Subject x Delegate x Action  x  TimePeriod 
NameAssertion + AuthAssertion 
- 
(omitted) 
M,,,,  : FullName  x AuthMap 
P(Principa1 x  Time) 
Figure 4. SPKl instantiation 
99 
behalf  of  name n at any time between tl and t 2 .   The sub- 
ject field can either directly  identify a full name, or specify 
a threshold subject of the form (k, {fl,  f 2 , .  . .}). A princi- 
pal  can only act for a threshold subject lf  at  least IC  of  the 
names f l  , f 2 ,  . . . denote that principal. 
An  authorization  assertion  is  represented  by  a  5-tuple 
( p ,  s ,  d ,  J:, ( t l ,  t z ) ) ,  which means that principal p  authorizes 
subject s to perform  (and delegate, if  d  = true)  the  oper- 
ations allowed  by  action  J: at any  time between  tl  and  t 2 .  
We will not specify actions in more detail - abstractly, they 
denote sets of  s-expressions, so we can assume a function 