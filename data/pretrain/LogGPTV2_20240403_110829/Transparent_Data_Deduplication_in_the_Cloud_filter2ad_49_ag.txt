Billion.
http://www.msptoday.com/topics/msp-
today/articles/364312-cloud-market-will-more-
than-triple-2014-reaching.htm, 2013.
[7] JPBC:Java Pairing-Based Cryptography Library. http://gas.
dia.unisa.it/projects/jpbc/#.U3HBFfna5cY, 2013.
[8] Bitcoin
as
a
public
source
of
randomness.
https:
//docs.google.com/presentation/d/
1VWHm4Moza2znhXSOJ8FacfNK2B_vxnfbdZgC5EpeXFE/
view?pli=1#slide=id.g3934beb89_034, 2014.
[9] These are the cheapest cloud storage providers
right now.
http://qz.com/256824/these-are-the-cheapest-
cloud-storage-providers-right-now/, 2014.
[10] F. Armknecht, J. Bohli, G. O. Karame, Z. Liu, and C. A. Reuter.
In Proceedings of the 2014
Outsourced proofs of retrievability.
ACM SIGSAC Conference on Computer and Communications Secu-
rity, Scottsdale, AZ, USA, November 3-7, 2014, pages 831–843, 2014.
[11] G. Ateniese, R. C. Burns, R. Curtmola, J. Herring, L. Kissner, Z. N. J.
Peterson, and D. X. Song. Provable data possession at untrusted
In ACM Conference on Computer and Communications Se-
stores.
curity, pages 598–609, 2007.
[12] N. Baric and B. Pﬁtzmann. Collision-free accumulators and fail-stop
signature schemes without trees. In W. Fumy, editor, EUROCRYPT,
volume 1233 of Lecture Notes in Computer Science, pages 480–494.
Springer, 1997.
[13] M. Bellare and S. Keelveedhi. Interactive message-locked encryption
and secure deduplication. In J. Katz, editor, Public-Key Cryptography
- PKC 2015 - 18th IACR International Conference on Practice and
Theory in Public-Key Cryptography, Gaithersburg, MD, USA, March
30 - April 1, 2015, Proceedings, volume 9020 of Lecture Notes in
Computer Science, pages 516–538. Springer, 2015.
[14] M. Bellare, S. Keelveedhi, and T. Ristenpart. DupLESS: Server-
aided encryption for deduplicated storage. In Proceedings of the 22Nd
USENIX Conference on Security, SEC’13, pages 179–194, Berkeley,
CA, USA, 2013. USENIX Association.
[15] M. Bellare, S. Keelveedhi, and T. Ristenpart. Message-locked en-
cryption and secure deduplication. In T. Johansson and P. Q. Nguyen,
editors, Advances in Cryptology - EUROCRYPT 2013, 32nd Annual
International Conference on the Theory and Applications of Crypto-
graphic Techniques, Athens, Greece, May 26-30, 2013. Proceedings,
volume 7881 of Lecture Notes in Computer Science, pages 296–312.
Springer, 2013.
[16] J. Blasco, R. Di Pietro, A. Orﬁla, and A. Sorniotti. A tunable proof
of ownership scheme for deduplication using bloom ﬁlters. In Com-
munications and Network Security (CNS), 2014 IEEE Conference on,
pages 481–489, Oct 2014.
[17] A. Boldyreva. Efﬁcient threshold signature, multisignature and blind
signature schemes based on the gap-difﬁe-hellman-group signature
scheme. 2002.
[18] D. Boneh, B. Lynn, and H. Shacham. Short signatures from the weil
pairing. J. Cryptology, 17(4):297–319, 2004.
[19] Brent Boyer. Robust Java benchmarking. http://www.ibm.
com/developerworks/library/j-benchmark2/j\-
benchmark2\-pdf.pdf.
[20] A. Buldas, P. Laud, and H. Lipmaa. Eliminating counterevidence with
applications to accountable certiﬁcate management. Journal of Com-
puter Security, 10(3):273–296, 2002.
[21] J. Camenisch and A. Lysyanskaya. Dynamic accumulators and appli-
cation to efﬁcient revocation of anonymous credentials. In Advances
in Cryptology - CRYPTO 2002, pages 61–76. Springer, 2002.
[22] I. Damgård and N. Triandopoulos.
proofs with bilinear-map accumulators.
Archive, 2008:538, 2008.
Supporting non-membership
IACR Cryptology ePrint
[23] R. Di Pietro and A. Sorniotti. Boosting efﬁciency and security in
proof of ownership for deduplication. In Proceedings of the 7th ACM
Symposium on Information, Computer and Communications Security,
ASIACCS ’12, pages 81–82, New York, NY, USA, 2012. ACM.
[24] D. Dobre, G. Karame, W. Li, M. Majuntke, N. Suri, and M. Vukoli´c.
Powerstore: Proofs of writing for efﬁcient and robust storage. In Pro-
ceedings of the 2013 ACM SIGSAC Conference on Computer &#38;
Communications Security, CCS ’13, pages 285–298, New York, NY,
USA, 2013. ACM.
[25] J. R. Douceur, A. Adya, W. J. Bolosky, D. Simon, and M. Theimer.
Reclaiming space from duplicate ﬁles in a serverless distributed ﬁle
system. In ICDCS, pages 617–624, 2002.
[26] A. Fiat and A. Shamir. How to prove yourself: Practical solutions to
identiﬁcation and signature problems. In Proceedings on Advances in
cryptology—CRYPTO ’86, pages 186–194, London, UK, UK, 1987.
Springer-Verlag.
[27] S. Halevi, D. Harnik, B. Pinkas, and A. Shulman-Peleg. Proofs of
In Proceedings of the 18th
ownership in remote storage systems.
ACM Conference on Computer and Communications Security, CCS
’11, pages 491–500, New York, NY, USA, 2011. ACM.
[28] D. Harnik, B. Pinkas, and A. Shulman-Peleg. Side channels in cloud
services: Deduplication in cloud storage. IEEE Security & Privacy,
8(6):40–47, 2010.
[29] G. O. Karame, E. Androulaki, and S. Capkun. Double-spending fast
In Proceedings of the 2012 ACM conference
payments in bitcoin.
on Computer and communications security, CCS ’12, pages 906–917,
New York, NY, USA, 2012. ACM.
[30] A. Kate, G. M. Zaverucha, and I. Goldberg. Constant-size com-
In Advances in
mitments to polynomials and their applications.
Cryptology-ASIACRYPT 2010, pages 177–194. Springer, 2010.
[31] S. Keelveedhi, M. Bellare, and T. Ristenpart. DupLESS: Server-aided
encryption for deduplicated storage. In Presented as part of the 22nd
USENIX Security Symposium (USENIX Security 13), pages 179–194,
Washington, D.C., 2013. USENIX.
[32] J. Li, N. Li, and R. Xue. Universal accumulators with efﬁcient non-
membership proofs. In Applied Cryptography and Network Security,
5th International Conference, ACNS 2007, Zhuhai, China, June 5-8,
2007, Proceedings, pages 253–269, 2007.
[33] H. Lipmaa. Secure accumulators from euclidean rings without trusted
setup. In Applied Cryptography and Network Security - 10th Inter-
national Conference, ACNS 2012, Singapore, June 26-29, 2012. Pro-
ceedings, pages 224–240, 2012.
[34] S. Liu, X. Huang, H. Fu, and G. Yang. Understanding data characteris-
tics and access patterns in a cloud storage system. In 13th IEEE/ACM
International Symposium on Cluster, Cloud, and Grid Computing,
CCGrid 2013, Delft, Netherlands, May 13-16, 2013, pages 327–334,
2013.
[35] D. T. Meyer and W. J. Bolosky. A study of practical deduplication. In
Proceedings of the 9th USENIX Conference on File and Stroage Tech-
nologies, FAST’11, pages 1–1, Berkeley, CA, USA, 2011. USENIX
Association.
[36] D. T. Meyer and W. J. Bolosky. A study of practical deduplication.
Trans. Storage, 7(4):14:1–14:20, Feb. 2012.
[37] S. Micali, M. Rabin, and J. Kilian. Zero-knowledge sets. In Foun-
dations of Computer Science, 2003. Proceedings. 44th Annual IEEE
Symposium on, pages 80–91. IEEE, 2003.
[38] NetEm.
NetEm,
Website, 2009.
Available online at http://www.linuxfoundation.org/
collaborate/workgroups/networking/netem.
the Linux Foundation.
[39] L. Nguyen. Accumulators from bilinear pairings and applications. In
Topics in Cryptology - CT-RSA 2005, The Cryptographers’ Track at
the RSA Conference 2005, San Francisco, CA, USA, February 14-18,
2005, Proceedings, pages 275–292, 2005.
[40] H. Shacham and B. Waters. Compact Proofs of Retrievability.
ASIACRYPT, pages 90–107, 2008.
In
[41] C. Soriente, G. O. Karame, H. Ritzdorf, S. Marinovic, and S. Capkun.
Commune: Shared ownership in an agnostic cloud. In Proceedings of
the 20th ACM Symposium on Access Control Models and Technolo-
gies, Vienna, Austria, June 1-3, 2015, pages 39–50, 2015.
[42] J. Stanek, A. Sorniotti, E. Androulaki, and L. Kencl. A secure data
deduplication scheme for cloud storage. In Financial Cryptography
and Data Security - 18th International Conference, FC 2014, Christ
Church, Barbados, March 3-7, 2014, Revised Selected Papers, pages
99–118, 2014.
[43] M. van Dijk, A. Juels, A. Oprea, R. L. Rivest, E. Stefanov, and
N. Triandopoulos. Hourglass schemes: How to prove that cloud ﬁles
are encrypted. In Proceedings of the 2012 ACM Conference on Com-
puter and Communications Security, CCS ’12, pages 265–280, New
York, NY, USA, 2012. ACM.
[44] J. Xu, E.-C. Chang, and J. Zhou. Weak leakage-resilient client-side
deduplication of encrypted data in cloud storage. In Proceedings of the
8th ACM SIGSAC Symposium on Information, Computer and Commu-
nications Security, ASIA CCS ’13, pages 195–206, New York, NY,
USA, 2013. ACM.
APPENDIX
A. SECURITY ANALYSIS OF CARDIAC
In what follows, we analyze the security of CARDIAC. Let a set
X be given and the accumulated digest for the set is δ ← Acc(X).
Recall that δ = H(a(cid:96),0, (cid:96)) (with H being a cryptographically se-
cure hash function) acts as a commitment to the root a(cid:96),0 and the
height (cid:96) of a Merkle tree. For the purpose of our analysis, we dis-
tinguish between two security goals: (i) proving membership using
ProveM and VerifyM and (ii) proving an upper bound on |X| us-
ing ProveC and VerifyC. As the security of Merkle trees is well
understood with respect to the ﬁrst goal [20], we focus in the sequel
on analyzing the second goal.
Since (cid:96) is veriﬁed (indirectly) using the length of the sibling path
and assuming that the hash function is secure, CARDIAC ensures
that the Merkle tree can encode at most 2(cid:96) elements. ProveC out-
puts the sibling path of the last set element a0,|X|−1. The veriﬁ-
cation algorithm VerifyC requires to check the values of all open
nodes in the sibling path. Recall that the open nodes are those nodes
that depend only on the zero leaves and hence represent publicly
known values. In fact, this veriﬁcation step constitutes member-
ship proofs for every single zero leaf a0,j for j = |X|, . . . , 2(cid:96) − 1.
In turn, this ensures that at least 2(cid:96)−|X| leaves of the tree are zero.
A direct consequence is that at most |X| leaves can be non-zero,
giving an upper bound on X. Observe that the proof assumes that
further leaves located on the left of the last non-zero element are
not set to zero. This assumption can be safely made since G has
no incentives to place more zero-leaves (since this means that less
users are registered than claimed and would pay too little to G).
B. POW BASED ON [24]
In Figure 6, we detail the Proof of Ownership (PoW) due to
Halevi et al. [27]. The protocol is divided into three phases: in
the ﬁrst phase, the ﬁle f is reduced into a buffer with maximum 64
MB in size. Then, the contents of the buffer are pseudo-randomly
mixed and ﬁnally, the Merkle tree of the buffer is computed. The
ﬁrst two phases can be seen as applying a linear code to the ﬁle, and
outputting a buffer Buf(f ). Subsequently, to verify a PoW, the ver-
iﬁer asks for the sibling paths of a random number of leaves from
Buf(f ) and checks that the authentication path matches the root of
the Merkle tree.
The buffer is an encoding of the ﬁle with a random linear code.
The code is generated using SHA-256 to generate an array of pointer
ptr. Due to the collision resistance of the hash function, any modi-
ﬁcation of the ﬁle will therefore lead to a different code. Under the
assumption that the code has a minimum distance of L/3, where L
is the number of blocks in the buffer, any two valid buffers will be
different in at least L/3 positions. Thus, the prover will only suc-
ceed with a probability of (2/3)t in answering t challenges without
knowing the correct buffer. For example, when t = 20 challenges
are made, the probability of success is at most 2−12. Note that with-
out knowing the ﬁle in its entirety, two different random codes are
derived in the ﬁrst two steps due to the collision-resistance of the
deployed hash function. In particular, it is highly unlikely that any
block in the buffer can be predicted. We refer the readers to [27]
for more details on the security of this construct.
Input: A ﬁle f of length M bit, broken into m = (cid:100) M
length 512 bit.
512(cid:101) blocks of
Initialize positions:
• Compute bit-length (cid:96) = min{20,(cid:100)log2 m(cid:101)}, being close to
M, but at most 64 MB, i.e. 220 blocks with 512 bits.
• Initialize the buffer Buf with 2(cid:96) blocks of 512 bits.
• Initialize a table ptr of m rows and 4 columns of (cid:96) bits
which holds pointers into the buffer Buf. A temporary value
IV will be initialized with SHA-256’ IV .
Reduction phase:
For each i ∈ [m]:
Mixing phase:
Repeat 5 times:
1. Update IV := SHA-256 (IV ; File[i]), where File[i] de-
notes the i-th block of the ﬁle.
Initialize ptr [i] = trunc4(cid:96)(IV ) with IV truncated to 4(cid:96) bits..
2. For j = 0 : 3, do
3.
4.
Block = Cyclic Shift of F ile[i] by j ∗ 128 bits
XOR Block into location ptr [i][j] in Buf
1. For each block i ∈ [(cid:96)], For j = 0 : 3, do
2.
3.
Block = Cyclic Shift of Buf[i] by j ∗ 128 bits
If i (cid:54)= ptr [i mod 2(cid:96)][j] then XOR Block into location
ptr [i mod 2(cid:96)][j] in Buf
Tree construction: The ﬁnal buffer content is denoted by Buf(f ).
Construct a Merkle tree using the blocks of Buf(f ) as the leaves.
Figure 6: Detailed PoW Protocol of [27].