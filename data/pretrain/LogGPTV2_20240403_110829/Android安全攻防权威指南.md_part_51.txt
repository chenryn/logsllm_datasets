---
## Page 227
8.1内存破坏漏洞基础211
认为基于WebKit的浏览器在所有架构上都使用TCmalloc分配器是一种常见的错误。Android
浏览器就是一个反例：虽然基于WebKit，但是它使用的是 Bionic C库中的 dmalloc 分配器。
3.Android系统中的dlmalloc分配器
Android系统中的 Bionic libc库内置了著名的 dlmalloc 分配器，该分配器由Doug Lea于1987
年编写的。许多开源的libc库都使用了dlmalloc，包括使用广泛的老版本GNUlibc。新版GNUlibc
使用了一个dlmalloc的修改版。
在Android 4.1.2以及之前版本的 Android系统中，Bionic 均使用了 2005年的 dlmalloc 2.8.3
版本。Android4.2将dlmalloc升级到了2.8.6版本。下面介绍的特性在这两个版本中均适用。
分配器的作用是将操作系统分配出来的内存页划分成内存块，其中包含与分配相关的控制信
息头以及请求的程序内存。虽然请求的内存可以达到字节的粒度，但是内存块的默认大小是请求
字节数向上取整得到的8的倍数。有时为了提高性能，内存块的大小可能是更多字节的倍数。例
如在某些英特尔的主板上，内存块的大小就是16字节的倍数。由于要向上取整，申请不同大小
的内存时，分配器实际分配的内存块可能是相同的。因此，释放后重用漏润的利用中就可以利用
这一特性向已释放的内存块填充数据。
为了提高内存分配与释放的性能，dlmalloc在内存块中存储了控制数据。内存块最开头的两
个字节存放了两个指针大小，然后紧接着存放的就是实际数据。开头的两个字节存放了前一个内
存块和当前内存块的大小，这样分配器就可以从两个方向高效地遍历内存块。在释放的内存块中，
实际数据部分的开头也包含一些额外的信息。对于小于256字节的内存块，这些额外信息是两个
向前和向后的指针，用来把这些相同大小的已释放内存块组成一个双向链表。对于大于256字节
的内存块，这些释放的内存块组成一个特里结构（trie）.需要存储更多的指针。更多细节请参考
dlmalloc源代码，其中包含大量注释。小于256字节的内存块结构如图8-4所示。
dlmalloc空闲内存块
dlmalloc已分配内存块
前一个内存换大小
前一个内存块大小
当前内存块大小
表前向指针
pointer
随表后向指针
用户数据
图8-4dlmalloc内存块的控制头和链表结构
为了优化分配性能，释放过的小内存块会按照大小分类。由这些不同大小的内存块组成双向
链表，链表头被存放在一个数组bin中。这使得分配内存时的查询时间是常量。使用free函数
释放一个内存块时，dlmalloc会检查它相邻的内存块是否也已经被释放，如果是，那么相邻的内
存块会合并成一个内存块，这个过程叫作coalescing。coalescing发生于把合并后的内存块放入bin
---
## Page 228
212第8章用户态软件的漏洞利用
之前，所以bin并不会影响coalescing的行为（不同于TCmalloc分配器，后者只会合并那些适合
成为分配缓存的内存块）攻击者如果想要把堆分配变成可控的状态，这一特性具有较大的意义。
口要利用释放后重用漏洞，攻击者必须保证与被释放内存块相邻的内存块依然正在被使用。
否则新的分配就不会按照预想从被释放的地方分配，面是会从其他地方产生。这是因为
释放处的内存块已经被合并成更大的内存块。即便新的分配产生自释放的同一内存块，
如果被释放的内存块与前面的内存块合并、新分配内存的起始也有可能向前移动。
口对于堆溢出或是其他破坏内存块控制数据的攻击，内存块的合并会导致控制数据移动至
前面的内存块中，从面无法控制。
无论是哪种情况，都可以事先在堆上分配很多占用的小内存块来避免发生合并。
很多现代的堆分配器在分配和释放内存时有额外的安全检查，以防止一些堆的攻击。dmalloc
中的检查只涉及控制数据。free函数检查了以下不变量。
口下一个相邻的内存块地址必须在当前内存块地址的后面，这能避免当前块地址加上内存
块大小时发生整数溢出。
口前一个相邻内存块必须在堆上，这可以通过与堆初始化时的全局最小地址进行比较来判
断。这个检查可以避免前一个内存块大小字段数值过大。
口发生内存块合并或者产生一个新的分配时，就会发生空闲块链表的元素制除（unlink）操
作，这会触发unlink检查。首先，它会检查待删除内存块向前指针指向的内存块，保证
其向后指针指向当前块。其次，验证向后指针指向的内存块，保证其向前指针指向当前
块。这样，通过覆盖链表指针来修改任意值的攻击就会得到缓解。但是，对于那些已经
有指向内存块指针的内存（例如bin列表的头）.依然可以用这种攻击来覆盖。
malloc中的安全检查基本就是上面提到的unlink检查。尽管这些检查还不能完全应对一些
特殊场景，但是攻击堆上应用相关的指针会更加容易。可以参考Phrack杂志第66期（文章6和
10）“Yetanother free （)exploitation technique”以及“MALLOC DES-MALEFICARUM”来了解
其他通用的技术。下一节介绍如何攻击内存块中特定于应用的指针。
4.C++虚函数表指针
C++之所以拥有多态特性，根本上是因为引人了虚函数（virtual functions）。子类的这些虚函
数可以与基类不同，进行专门定制。即便运行时代码只知道它的基类，也能调用正确的函数。面
向对象编程中虚函数的具体细节超出了本书讨论的范围，B.Stroustrup于1997年所著的《C++编
程语言（第3版）当中有很好的介绍。
攻击者并不会关注C++的面向对象编程思想有多么美妙，只关心编译器如何实现虚函数的调
用。由于虚函数的解析发生在运行时，所以在类的内存表示中一定存储着虚函数的信息。事实上，
GCC会把一个虚品数表的指针（virtual function table pointer，简称vftable）放在对象的开始位置。
这个指针指向的是由所有函数的指针组成的表，编译器并没有把所有函数的指针都放在每个对象
内存中，这样可以直接缩小对象，因为特定对象一定属于一个类，并且拥有确定数量的虚函数。
二进制文件包含了每个基类的虚函数表。对象的虚函数表由构造函数进行初始化。更多实现细节
请参考 S.Lippman 著的 Inside the C++ Object Model（Addison-Wesley，1996）。类对象在内存中的
---
## Page 229
8.1内存破坏漏洞基础
213
基本布局如图8-5所示。
维
代码段 texl
类实例AB
虚函数表指针A
函数指针1
虚函数表指针B
函数指2
member 1
函数指针3
图8-5C++类中的虚函数表
虚函数调用暗含了类实例内存的间接访问：类实例往往分配在堆中。在ARM体系结构下。
GCC虚函数调用大致如下所示：
·WebKit虚函数调用示例
↓从类实例的起始内存中取出虚函数表，存在r0中
1dx r0, [x4, #0)
subs r5, r6, r5
↓在虚函数表偏移722处取得想要调用的函数指针
1dr,w r3, [r0, #772]
1为函数调用设置参数r0
nov r0, r4
调用这个函数指针
blx r3
当堆上发生内存破坏漏洞时，攻击者可以通过控制虚函数表指针让它指向任何地方。尽管
vfable通常在二进制的text段当中，攻击者也可以把它指向堆上伪造的虚函数表。然后，当对
这种技术的一个缺点在于，攻击者想调用的函数不能直接通过覆盖C++对象来写入内存：首
---
## Page 230
214第8章用户态软件的漏洞利用
先，攻击者需要往能够泄露地址的堆中填充数据，作为伪造的虚函数表；其次，利用应用逻辑来
覆盖虚函数表指针，将指向攻击者能控制的地方。下一节会展示相关例子。
5.WebKit 分配器：RenderArena
正如之前所说，程序可能会定制为自身进行优化的堆分配器。WebKit谊染引肇就带有一个
堆分配器来优化谊染树（RenderTree）的生成速度。每个DOM树都对应着一个谊染树结构，包
含页面中的所有元素及其各自位置、样式等需要渲染的属性。每次页面布局发生变化，就需要重
构谊染树（如改变窗口大小，修改DOM树等），所以谊染树需要一个快速的分配器。谊染树的
每个节点（即C++对象）都使用特殊的分配器RenderArena来分配。
RenderArena分配器并不是基于操作系统的页分配，面是基于堆上大内存块的分配来实现的。
这些较大内存块的分配使用了我们熟悉的dlmalloc。dlmalloc分配的大内存块会进一步为
RenderArena的分配所用，因而可以将RenderArena 称为“堆上的堆”。在ARM架构下，RenderArena
的分配都是0x1000字节，加上arena头后共0x1018字节。
RenderArena的分配策略非常简单，容易解释。内存块从不合并：同样大小的空闲内存块组
成单向链接的FILO（First-In-Last-Out）结构，等待新的分配。如果在空闲内存块中无法找到新
分配的大小，则在当前RenderArena的最后创建一个新的内存块。如果当前的 arena大小不够，无
法满足新的分配，则使用dlmalloc创建一个新的Arena。这个分配策略虽然很简单，但是很有效。
这是因为在这个特殊的堆上只有固定大小的C+类会被分配，整体来说，分配大小的变化不大。
由于分配策略足够简单，所以内存块中并不用存储元数据。空闲内存块的第一个机器字存储
指向下一个相同大小的空闲块指针，组成了前面提到的单向FILO链表。
在空闲内存块的开头存放指向下一个相同大小空闲块的指针为攻击者提供了便利。因为在
RenderArena上分配的所有对象都是C++类的对象，都继承于相同的基类，并且在最开头都有虚
函数表指针，这个指针与链表指针重合。这样，RenderArena分配器会使虚函数表指针指向相同
尺寸的前一个空闲块，如图8-6所示。
虚函数表指针
成员变量1
成员变量2
函数指针1
下一个空闲块
成员变量1
图8-6vftptr指向下—个空闲块
在释放后重用之前，如果相同大小的内存块分配可以被控制然后释放，那么执行流就可以被
劫持，并且无需进行额外构造。8.3节讨论了这种场景，即便堆内存分配无法控制，也能成功利用。
这个利用技术在HackitoEroSum2012会议上公开，之后谷歌在最新的WebKit更新中给出
了缓解措施。链表指针被运行时生成的幻数所遮单，这样该数就不再是有效的虚函数表指针。幻
数基于ASLR的生成，最高有效位置为1。这种方案保证生成的数无法预测，并且很有可能不
是一个有效的指针。
---
## Page 231
8.2公开的漏洞利用215
8.2公开的漏洞利用
第3章简要介绍了许多本地提权的利用。本章会详细介绍三个漏润及其利用，尽可能让大家
了解Android生态系统中用户态程序的漏润利用技术。
前两个漏洞与Android自定义的自动挂载守护进程vold有关。这个软件是专门为Android开
发的。曾经在两个不同的攻击面上曝出漏洞。第一个漏洞与NETLINK套接字相关。这是一个特
殊的本地包套接字，内核空间与用户空间用它来交换数据。第二个漏润则出在UNIX域套接字
（UNIXdomainsocket）上。UNIX城套接字都与文件系统的特定路径绑定，而且拥有自己的用户
和组，类似于普通文件的属性。由于UNIX域套接字并没有对所有用户开放访问，因此即便攻破
了浏览器进程，也不能以此来进一步对UNIX城套接字发起攻击。
第三个利用是mempodroid，它利用了Linux内核中的一个漏洞，可以在更高权限的进程内
存中写人数据。一种巧妙利用这个漏洞的方法是，让一个set-uid程序执行一个自定义的载荷，
从而提权。尽管这个利用依赖于内核的漏洞，但是基本的漏洞利用发生在用户空间。
8.2.1GingerBreak
vold守护进程不断监听NETLINK套接字，等待新磁盘相关事件的通知消息，来实现磁盘
的自动挂载。这些消息一般由内核发送给所有注册了特定类型消息的用户态程序，但是用户态
进程也有可能发送NETLINK消息。这就导致攻击者可以伪造用户程序原本预期从内核发送出
来的消息，暴露出了一种攻击面。还需要注意的是，目前Android权限系统并没有对NETLINK
套接字进行限制，任何程序都可以使用它来通讯，因此所有接收NETLINK消息的程序都被极
大地拓宽了攻击面。
vold进程使用了Android开源项目（AOSP）库中的代码来解析和处理NETLINK消息。传递
一个块设备事件相关的消息时，分发器类VolumeManager会调用所有注册了Volume类的虚函
数handleBlockEvent。每一个注册了的类会判断这个消息是否跟自身相关。下面的代码片段
摘自 AOSP中的 system/vold/VolumeManager.cpp，从中可以看到handleBlockEvent 的实现。
●vold中handleBlockEvent 的实现
void VolumeManager: :handleBlockEvent (Net1inkEvent *evt) (
const char *Gevpath = evt->findParam(*DEVPATH*) :
/* Lookup a volume to handle this device */
VoluneCollectioni:iterator it:
bool hit = false;
for (it = mVolumeg->begin(); it 1= mVolumes->end(): ++it) (
if (1 (*it) ->handleBlockEvent (evt))(
ifdef NETLINK_DBBUG
SLOGD(*Device '&s* event handled by volume %a\n*, devpath
#endi f
(*It) >getLabel ()1 ;
hit = true;
break;
---
## Page 232