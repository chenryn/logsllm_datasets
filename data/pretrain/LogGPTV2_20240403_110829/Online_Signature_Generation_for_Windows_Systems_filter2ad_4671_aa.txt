title:Online Signature Generation for Windows Systems
author:Lixin Li and
James E. Just and
R. Sekar
2009 Annual Computer Security Applications Conference
Online Signature Generation for Windows Systems
Lixin Li and James E. Just
Global InfoTek, Inc.
Reston, VA, USA.
R. Sekar
Stony Brook University
Stony Brook, NY, USA.
Abstract—In this paper, we present a new,
light-weight
approach for generating ﬁlters for blocking buffer overﬂow
attacks on Microsoft Windows systems. It
is designed to
be deployable as an “always on” component on production
systems. To achieve this goal, it avoids expensive and intrusive
techniques such as taint-tracking. The online nature of our
system enables it to provide protection from a range of memory
corruption exploits, including those involving unknown vul-
nerabilities, or known vulnerabilities but unknown exploits. In
contrast, most previous signature generation techniques need to
be run in sandboxed environments, and need working exploits
to generate signatures. Moreover, our technique overcomes the
“gap” problem faced by previous signature generation mech-
anisms, i.e., when the vulnerable memory region is corrupted
between the overﬂow and the time an attack is detected.
Another novel feature of our approach is that it is able to
reason about likely lengths of vulnerable buffers, which can
lead to more accurate signatures. Our experimental results
are very promising, and demonstrate that the approach can
generate effective signatures for many synthetic and real-world
vulnerabilities.
Keywords-signature generation; buffer overﬂow; self-healing
I. INTRODUCTION
Buffer overﬂows continue to be one of the most common
vulnerabilities prevalent today, especially dominating among
“critical updates” from vendors such as Microsoft. This
factor has motivated the deployment of defenses such as
address space randomization (ASR). Unfortunately, these
defenses simply convert a working exploit into a crash.
Since server restarts typically take signiﬁcant time (of the
order of a second or more), an attacker can bring down
a server by repeatedly attacking a server with just a few
packets every second. Indeed, with the advent of botnets and
widespread prevalence of cyber extortion based on DDoS
threats, such attacks become very easy to carry out, yet
very hard to defend against. Moreover, repeated attacks can
compromise randomization defenses, especially when the
range of randomization is small (e.g., 256 in the case of
Windows Vista).
The drawbacks of existing buffer overﬂow defenses have
motivated the development of automated signature gen-
eration techniques that generate ﬁlters to block attack-
This work was funded in part by Defense Advanced Research Project
Agency (DARPA) under contract N00178-07-C-2005. Sekar’s work was
also supported by ONR grant N000140710928 and NSF grants CNS-
0627687 and CNS-0831298. The views and conclusions contained in
this document are those of the authors and should not be interpreted as
representing the ofﬁcial policies, either expressed or implied, of DARPA,
the Naval Surface Weapons Center, ONR, NSF, or the U.S. Government.
bearing inputs from being delivered to a vulnerable server.
Initially, this line of research targeted network worms, and
relied on “content-based signatures,” where the signature
captured characteristics of the attack payload. Unfortunately,
polymorphic attacks can evade these signatures, and hence
subsequent research focused on “vulnerability-oriented sig-
natures” [10], [5], [2], [7], [21]. These signatures capture
the characteristics of the underlying vulnerability (e.g., max-
imum length of input) rather than those of the attack payload.
Recent trends in this area has tended to emphasize signature
generality: i.e., its ability to block a wide a range of exploit.
This trend has favored the development of heavy-weight
signature generation techniques [5], [4], [2], [7], [21] that
were best suited for ofﬂine operation on honeypots or a
sandbox. However, ofﬂine techniques have some drawbacks:
• Defenses for zero-day exploits. The protection offered
by techniques deployed on honeypot or sandboxed sys-
tems will be unavailable to a production server until the
vulnerability is attacked on one of the honeypot systems
on which the signature generator is deployed, and the
resulting signature distributed. This leads to unneces-
sary delays in signature deployment, leaving critical
servers exposed to attacks. Worse, many of the previous
techniques rely on generating variants of attacks and
replaying them, and this would typically require the
availability of working exploits. Unfortunately, working
exploits won’t be available for unknown vulnerabilities,
as well as for many known vulnerabilities.
• Defense against guessing attacks. Since guessing at-
tacks on ASR can be completed within a short period
— say, several seconds — a production server may
be compromised before a signature is generated by
a heavy-weight technique; or between the time it is
generated and widely distributed.
technique that
In contrast, we present a light-weight
is
suitable for on-line operation on production systems. Our
technique differs from COVERS [10], another online signa-
ture generation technique, in many important ways. First,
the focus of this paper is on Microsoft Windows, while
COVERS is based on Linux. Second, our work makes
innovative use of modern memory error defenses (such as
return address cookies, heap metadata cookies, SafeSEH
protection, data execution prevention) to improve signature
generation. Finally, our work develops better analysis and
correlation techniques that enable robust signatures to be
generated in scenarios where COVERS may fail.
1063-9527/09 $26.00 © 2009 IEEE
DOI 10.1109/ACSAC.2009.34
289
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 13:11:07 UTC from IEEE Xplore.  Restrictions apply. 
A. Approach Overview and Contributions
Our primary goal is to defend against zero day attacks
in production environments. Our focus is on light-weight
analysis techniques that can be invoked on-demand, so
that zero-day attacks can be detected and quickly analyzed
as they happen, while avoiding any signiﬁcant overheads
during normal operation. Our approach leverages (fail-crash)
memory corruption defenses built into modern operating
systems for detecting memory corruption attacks. It then
uses an analysis of victim process memory to identify
possible memory corruption targets, and correlates the data
surrounding the target with recent inputs to identify the
input(s) responsible for the attack. It
then generates a
signature (also called a blocking ﬁlter or simply a ﬁlter)
that characterizes this attack-bearing input. This signature
is then deployed to ﬁlter out repetitions of the exploit and
(hopefully) its variants.
Our approach is based on the observation that most mem-
ory corruption attacks involve copying data that overﬂows
a buffer and overwrites an adjacent pointer. If this pointer
value is incorrect (as is typically the case in the presence
of ASR), a memory exception is triggered at the time this
pointer value is dereferenced. This exception initiates an
analysis phase that involves correlating the crash-causing
data, namely, the data in the destination buffer that over-
ﬂowed, to an input. Previous work has typically relied on
taint tracking [13] to identify this input, but unfortunately,
taint-tracking on C/C++ programs introduces high runtime
overheads, slowing down programs by a factor of two to ten.
We observe that most memory corruption attacks involve
simple copying of data. This raises the possibility that
correlation can be made by simply comparing the crash-
causing buffer to inputs, as done in the COVERS [10]
work. However, this approach runs into problems if the
copied contents get corrupted after the copy operation. For
instance, consider a stack-resident buffer. A buffer overﬂow
will typically corrupt a few local variables on the stack and
then the return address. If these local variables change before
the return (i.e., the time of crash), the buffer contents may
not exactly match the input. On our experimental platform,
namely, Windows, we found that such changes to inputs are
common, and hence an exact matching algorithm can fail to
correlate corrupted buffer with recent input.
We made the key observation that
the sort of input
changes that occur due to program execution can be ac-
commodated using an approximate rather than an exact
matching algorithm. Based on this observation, we made
use of an approximate substring searching algorithm for
performing input correlation. After performing correlation,
our technique generates a blocking ﬁlter that characterizes
the attack input without matching any benign inputs. Like
previous techniques, the signature generation phase is guided
by input format speciﬁcations.
Although a sophisticated classiﬁcation technique could be
used for generating signatures from a list of benign and
attack-bearing inputs, our current focus is on demonstrating
the feasibility of our approach, and hence we have focused
on simple techniques that reason about input lengths and
other characteristics that
typically differ between benign
inputs and inputs responsible for crash.1
• Instead of tracking every move of input at machine
instruction level, as is done with many previous ap-
proaches that relied on taint-tracking, we are able to
infer ﬂow of data from input to a vulnerable buffer by
using an efﬁcient post-crash analysis of victim memory.
• Our techniques take advantage of modern (fail-crash)
memory exploit defenses built into Windows. Many
of these defenses (e.g., return address cookies) detect
memory corruptions at an earlier stage than more
generic defenses such as ASR. Our techniques leverage
this factor to develop simpler and more robust mecha-
nisms for identifying key details of the exploit.
• A key insight in our approach is that the use of an
approximate (rather than an exact) string matching
algorithm can lead to a technique that can be robust in
the face of “gaps” that occur due to memory updates
(or corruptions) that may occur between the time of
buffer overﬂow and the time of crash. Such gaps were
the norm rather than the exception on our experimental
platform.
• Unlike previous light-weight
techniques that relied
purely on learning to develop length-based signatures,
we develop a new technique that can infer the likely
lengths of vulnerable buffers using a runtime memory
analysis and string matching. This enables our approach
to generate more accurate signatures.
• Our system can mitigate Denial-Of-Service attacks as
well as zero-day working exploits on memory error
vulnerabilities. This contrasts with other light-weight
signature generation techniques that generate blocking
ﬁlters based on checking if the “jump addresses” incor-
porated in the attack has a certain value (or range of
values), and hence can be fooled by DoS attacks that
need not contain a valid jump address.
• We have implemented the technique and evaluated it
on a synthetic server seeded with a variety of vulnera-
bilities, as well as a number of real world applications.
Our experiments show that our technique is effective
and has low performance overheads that is acceptable
for production use.
1Naturally, this focus implies that certain types of overﬂow vulnerabilities
won’t be handled, such as those where the overﬂow involves inconsistencies
between multiple message ﬁelds (e.g., a ﬁeld that speciﬁes the length of
a string in another message ﬁeld, but the string happens to be longer than
the value speciﬁed in the ﬁrst ﬁeld) or concatenation of multiple message
ﬁelds. Nevertheless, our techniques were able to successfully generate
signatures for most real-world and synthetic vulnerabilities considered in
our experimental evaluation.
290
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 13:11:07 UTC from IEEE Xplore.  Restrictions apply. 
II. IMPACT OF WINDOWS EXPLOIT DEFENSES
Windows Vista provides the following defense mecha-
nisms against memory corruption exploits:
• /GS option (“return cookies”): This is a compiler
option that generates additional code to detect return
address (and saved base pointer) corruption. Similar
in style to StackGuard [6], the runtime check involves
verifying the integrity of a cookie that resides before
the protected items on the stack.
• /SafeSEH option: This is another compile-time option
that produces a table of safe Structured Exception
Handlers (SEH). Before control is transferred to any
exception handler code at runtime, the target address
must be present in this table. A runtime SEH link list
validation is built in Windows Server 2008.
• Heap overﬂow protection: Traditional heap overﬂows
involve corruption of heap metadata. Modern versions
of Windows incorporate cookies and other mechanisms
to detect metadata overwrites and abort the program.
• Address-space randomization: Windows Vista incorpo-
rates ASR, but the range of randomization is just 256.
This means that individual exploits will be blocked with
a probability of 99.6%, but brute force attacks have a
50% chance of succeeding in 128 attempts.
• Data Execution Prevention (DEP): DEP prevents in-
jected malicious code from executing in non-executable
(NX) memory regions such as the stack or heap.
These protections, collectively referred to as modern protec-
tions, seem to provide a formidable defense at ﬁrst glance.
However,
there are a number of reasons why memory
corruption attacks continue to be a serious threat:
• There still exist a vast number of systems that are
running older versions of Windows (e.g., XP) on which
some of these protections are unavailable.
• Some of these defenses (in particular, /GS, /SafeSEH,
NX, and some aspects of ASR) require a software
vendor to opt-in. Some vendors, due to compatibility or
performance concerns, don’t enable these protections.
• Most of these protection mechanisms can be circum-
vented using specially crafted attacks. For instance,
return address cookies can be bypassed by corrupting
data or function pointers on the stack; derandomization
attacks [16] are easy to mount on Windows ASR due to
its small range of randomization; return-to-libc attacks,
and the more general technique of return-oriented pro-
gramming [15], overcome NX. Finally, non-control data
attacks [3] can defeat almost all of these defenses.
• Finally, even when effective, these defenses convert
working exploits into crashes, which are seldom ac-
ceptable on a production server. Worse, attackers can
utilize these crashes to mount targeted DoS attacks.
As a result of these factors, memory corruption exploits
remain popular on Windows. But the defense mechanisms
291
have certainly skewed the distribution of exploits to some
extent. For instance, traditional heap overﬂows are rare on
modern Windows systems due to the effectiveness of heap
overﬂow protections. Traditional stack-smashing remains
possible on systems unprotected by /GS, but attacks that
corrupt exception handler pointers tend to be more popular,
as they work more reliably. We leverage these facts in this