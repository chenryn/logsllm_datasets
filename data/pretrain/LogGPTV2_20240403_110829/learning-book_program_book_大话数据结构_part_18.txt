大话
数据结构
1月
2月
3月
2
4月
5月
6月
图4-8-2
可以发现，编号①的一对兔子经过六个月就变成8对免子了。如果我们用数学函
数来定义就是：
0.当n=0
F(n)=
1当n=1
F(n-1）+F(n-2)，当n>1
先考虑一下，如果我们要实现这样的数列用常规的选代的办法如何实现？假设我
们需要打印出前40位的斐波那契数列数。代码如下：
int main（)
int i;
int a[40]:
a[0]-0;
a[1]-1;
printf（"ed",a[o]）;
printt（"sd"，a[1]）;
for（i=2:i<40:i++）
a[i]-a[i-1]+a[1-2];
printf（"d",a[i]）;
return O;
102
---
## Page 127
第4章栈与队列
代码很简单，几乎不用做什么解释。但其实我们的代码，如果用递归来实现，还
可以更简单。
斐波那契的递归函数·/
int Fbi（int i）
if（i<2）
return1--0？0:1;
returnFbi（i-1）+Fbi（i-2）;/*这里Fbi就是函数自己，它在调用自己*/
int main（）
inti;
for（inti=0;i<40:i++）
printf（=d",Fbi（i））;
return 0;
怎么样，相比较选代的代码，是不是干净很多。嘿嘿，不过要弄懂它得费点脑
子。
函数怎么可以自已调用自己？听起来有些难以理解，不过你可以不要把一个递归
函数中调用自己的函数看作是在调用自己，而就当它是在调另一个函数。只不过，这
个函数和自已长得一样而已
我们来模拟代码中的Fbi（1）函数当i=5的执行过程，如图4-8-3所示。
FIxS]
Fib(5)=
Filt(4)
Fib(4)+Fib(3)
FN2）
Fi
Fib(3)+Fibx(2)+Fib(2)+Fib(1)=
Fa2FIKIFxFINOFI(）FO]
1+1+++(Z
1+1+1+1+1=5
图 48-3
4.8.2递归定义
在高级语言中，调用自己和其他函数并没有本质的不同。我们把一个直接调用自
已或通过一系列的调用语句间接地调用自已的函数，称做递归函数。
103
---
## Page 128
大据数据结构
当然，写递归程序最怕的就是陷入永不结束的无穷递归中，所以，每个递归定义
必须至少有一个条件，满足时递归不再进行，即不再引用自身而是返回值退出。比如
刚才的例子，总有一次递归会使得i2的，这样就可以执行return1的语句而不用继
续递归了。
对比了两种实现斐波那契的代码。选代和递归的区别是：选代使用的是循环结
构，递归使用的是选择结构。递归能使程序的结构更清晰、更简洁、更容易让人理
解，从而藏少读懂代码的时间。但是大量的递归调用会建立函数的副本，会耗费大量
的时间和内存。选代则不需要反复调用函数和占用额外的内存。因此我们应该视不同
情况选择不间的代码实现方式。
那么我们讲了这么多递归的内容，和栈有什么关系呢？这得从计算机系统的内部
说起。
前面我们已经看到递归是如何执行它的前行和退回阶段的。递归过程退回的顺序
是它前行顺序的逆序。在退回过程中，可能要执行某些动作，包括恢复在前行过程中
存储起来的某些数据。
这种存储某些数据，并在后面又以存储的逆序恢复这些数据，以提供之后使用的
需求，显然很符合栈这样的数据结构，因此，编译器使用栈实现递归就没什么好惊讶
的了。
简单的说，就是在前行阶段，对于每一层递归，函数的局部变量、参数值以及返
回地址都被压入栈中，在退回阶段，位于栈顶的局部变量、参数值和返回地址被弹
出，用于返回调用层次中执行代码的其余部分，也就是恢复了调用的状态。
当然，对于现在的高级语言，这样的递归问题是不需要用户来管理这个栈的，一
切都由系统代劳了。3
4.9栈的应用一四则运算表达式求值
4.9.1后缀（逆波兰）表示法定义
栈的现实应用也很多，我们再来重点讲一个比较常见的应用：数学表达式的求
值。
注”：关于通归的更详细的说明，请参用（数据给构—从应用到实现（Ina版））第8章“通归”
104
---
## Page 129
第4章栈与队列
我们小学学数学的时候，有一句话是老师反复强调的，“先乘除，后加减，从左算
到右，先括号内后括号外”。这个大家都不陌生。我记得我小时候，天天做这种加减乘
除的数学作业，很烦，于是就偷偷拿了老爸的计算器来帮着算答案，对于单纯的两个
数的加减乘除，的确是省心不少，我也因此潇洒了一两年。可后来要求要加减乘除，
甚至还有带有大中小括号的四则运算，我发现老爸那个简陋的计算器不好使了。比如
9+（3-1）×3+10+2，这是一个非常简单的题目，心算也可以很快算出是20。可就
这么简单的题目，计算器却不能在一次输入后马上得出结果，很是不方便。
当然，后来出的计算器就高级多了，它引入了四则运算表达式的概念，也可以输
入括号了，所以现在的00后的小朋友们，更加可以偷懒、抄近路做数学作业了。
那么在新式计算器中或者计算机中，它是如何实现的呢？如果让你用C语言或其
他高级语言实现对数学表达式的求值，你打算如何做？
这里面的困难就在于乘除在加减的后面，却要先运算，面加入了括号后，就变得
更加复杂。不知道该如何处理。
但仔细观察后发现，括号都是成对出现的，有左括号就一定会有右括号，对于多
重括号，最终也是完全嵌套匹配的。这用栈结构正好合适，只有碰到左括号，就将此
左括号进栈，不管表达式有多少重括号，反正遇到左括号就进栈，而后面出现右括号
时，就让栈顶的左括号出栈，期间让数字运算，这样，最终有括号的表达式从左到右
巡查一遍，栈应该是由空到有元素，最终再因全部匹配成功后成为空栈的结果。
但对于四则运算，括号也只是当中的一部分，先乘除后加减使得问题依然复杂，
如何有效地处理它们呢？我们伟大的科学家想到了好办法。
20世纪50年代，波兰逻辑学家Jantukasiewicz，当时也和我们现在的同学们一
样，困惑于如何才可以搞定这个四则运算，不知道他是否也像牛顿被草果磁到头而想
到万有引力的原理，或者还是阿基米德在浴缸中洗澡时想到判断皇冠是否纯金的办
法，总之他也是灵感突现，想到了一种不需要括号的后缀表达法，我们也把它称为逆
波兰（ReversePolishNotation，RPN）表示。我想可能是他的名字太复杂了，所以
后人只用他的国籍而不是姓名来命名，实在可惜。这也告诉我们，想要流芳百世，名
字还要起得朗朗上口才行。这种后级表示法，是表达式的一种新的显示方式，非常巧
妙地解决了程序实现四则运算的难题。
我们先来看看，对于“9+（3-1）×3+10÷2”，如果要用后级表示法应该是什么
样子：“931一3*+102/+”，这样的表达式称为后级表达式*，叫后级的原因在于所
注”：在数学中的“x”与“”在计算机中分别用“”为“/代替。
105
---
## Page 130
大语数据结构
有的符号都是在要运算数字的后面出现。显然，这里没有了括号。对于从来没有接触
过后缓表达式的同学来讲，这样的表述是很难受的。不过你不喜欢，有机器喜欢，比
如我们聪明的计算机。
4.9.2后缀表达式计算结果
为了解释后级表达式的好处，我们先来看看，计算机如何应用后缀表达式计算出
最终的结果20的。
后级表达式：931-3*+102/+
规则：从左到右遍历表达式的每个数字和符号，遇到是数字就进栈，遇到是符
号，就将处于栈顶两个数字出栈，进行运算，运算结果进栈，一直到最终获得结果。
1.初始化一个空栈。此栈用来对要运算的数字进出使用。如图4-9-1的左图所
示。
2.后缀表达式中前三个都是数字，所以9、3、1进栈，如图4-9-1的右图所示。
lop
1op
图4-9-1
3.接下来是“-”，所以将栈中的1出栈作为减数，3出栈作为被减数，并运算3-1
得到2，再将2进栈，如图4-9-2的左图所示。
4.接着是数字3进栈，如图4-9-2的右图所示。
top
3
top
2
2
9
图4-9-2
106
---
## Page 131
第4章栈与队列
5.后面是“”，也就意味着栈中3和2出栈，2与3相乘，得到6，并将6进
栈，如图4-9-3的左图所示。
6.下面是“+”，所以栈中6和9出栈，9与6相加，得到15，将15进栈，如图
4-9-3的右图所示。
top
6
9
top
15
图4-9-3
7.接着是10与2两数字进栈，如图4-9-4的左图所示。
8.接下来是符号“/”，因此，栈顶的2与10出栈，10与2相除，得到5，将5
进栈，如图4-9-4的右图所示。
lop
2
10
top
5
15
15
图 4-9-4
9.最后一个是符号“+”，所以15与5出栈并相加，得到20，将20进栈，如图
4-9-5的左图所示。
10.结果是20出栈，栈变为空，如图4-9-5的右图所示。
107
---
## Page 132
大适数据结构
20
top
图 4-9-5
果然，后缓表达法可以很顺利解决计算的问题。现在除了睡觉的同学，应该都有
不搞清楚，等于没有解决。所以下面，我们就来推导如何让“9+（3一1）×3+10÷
2”转化为“931-3*+102/+”。
4.9.3中缀表达式转后缀表达式
我们把平时所用的标准四则运算表达式，即“9+（3-1）×3+10÷2”叫做中缀
表达式。因为所有的运算符号都在两数字的中间，现在我们的问题就是中级到后缀的
转化。
规则：从左到右遍历中缓表达式的每个数字和符号，若是数字就输出，即成为后
缓表达式的一部分；若是符号，则判断其与栈顶符号的优先级，是右括号或优先级低
于栈顶符号（乘除优先加减）则栈顶元素依次出栈并输出，并将当前符号进栈，一直
到最终输出后级表达式为止。
1.初始化一空栈，用来对符号进出栈使用。如图4-9-6的左图所示。
好
top
+
输出：无
输出：9
H
图4-9-6
108
---
## Page 133
第4章栈与队列
2.第一个字符是数字9，输出9，后面是符号“+”，进栈。如图4-9-6的右图所
示。
3.第三个字符是“（”，依然是符号，因其只是左括号，还未配对，故进栈。如图
4-9-7的左图所示。
4.第四个字符是数字3，输出，总表达式为93，接着是“-”，进栈。如图4-9-7
的右图所示。
top
top
（
+
6
输出：931
图4-9-7
5.接下来是数字1，输出，总表达式为931，后面是符号“）”，此时，我们需要
去匹配此前的“（”，所以栈顶依次出栈，并输出，直到“（”出栈为止。此时左
括号上方只有“-”，因此输出“-”。总的输出表达式为931-。如图4-9-8
的左图所示。
6.接着是数字3，输出，总的表达式为931-3。紧接着是符号“×”，因为此时
的栈顶符号为“+”号，优先级低于“×”，因此不输出，“进栈。如图4-9-8
的右图所示。
top
+
输出：931-
输出：931-3
图4-9-8
7.之后是符号“+”，此时当前栈顶元素“”比这个“+”的优先级高，因此栈中
109
---
## Page 134
大语数据结构
元素出栈并输出（没有比“+”号更低的优先级，所以全部出栈），总输出表达