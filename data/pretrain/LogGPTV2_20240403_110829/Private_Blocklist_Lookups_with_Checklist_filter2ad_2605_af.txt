Checklist with oï¬„ine-online PIR (Â§4)
Checklist with DPF PIR [15]
143
1348
9047
(ms)
91
Initial
(sec)
3.1
Very small â€“ not measured
13.3
2.6
90
122
Running
Initial
(MB) (MB/month)
5.0
91.8
10.3
5.0
3.0
13.2
9.8
3.6
0.5
8.0
0.8
4.3
91.8
24.5
4.3
0.2
4.5
1.6
0.2
USENIX Association
30th USENIX Security Symposium    887
0306090120150180Time(days)050100150200ServerCPUtime(sec,cumulative)0306090120150180Time(days)0204060ClientCPUtime(sec,cumulative)0306090120150180Time(days)0204060Communication(MB)by 30ms, though it would use 10Ã— less client computation and
2.7Ã— less bandwidth on a running basis.
8 Discussion
8.1 Deployment considerations
When is Checklist cost eï¬€ective for Safe Browsing? Table 7
shows three diï¬€erent ways to achieve full privacy for Safe
Browsing queries: having the client maintain a full client-
side blocklist (â€œFull listâ€), using Checklist with a standard
PIR scheme (â€œDPFâ€), and using Checklist with our new
oï¬„ine/online PIR scheme (â€œOï¬„ine-Onlineâ€). Which of these
three schemes will be best in practice depends on the relative
costs of server-side computation, client-side computation,
communication, and client storage.
Download full list. When communication and client storage
are relatively inexpensive, as on a powerful workstation with
a hard-wired network connection, the best Safe Browsing
solution may be to have the client keep a local copy of the entire
blocklist. Downloading the full list would require roughly
9Ã— more communication initially and 3.7Ã— more storage
than Checklist with oï¬„ine-online PIR, but the reduction in
server-side computational cost would be signiï¬cant.
Checklist with oï¬„ine-online PIR. When trying to jointly mini-
mize communication and server-side computation, Checklist
with our new oï¬„ine-online PIR scheme is the most appealing
approach. This point in the trade-oï¬€ space may be useful for
general devices (laptops, etc.) in which it is reasonable to shift
some work to the client for the beneï¬t of decreased server
cost. The total communication is lower than downloading the
full blocklist and the server-side computation is roughly 7Ã—
less than would be required when using standard PIR.
Checklist with DPF PIR. Finally, when trying to minimize
client computation and storage, Checklist with DPF-based PIR
may be the best option. This conï¬guration may be useful on
mobile devices, where client resources are especially scarce.
This approach requires the least storage (22Ã— less than storing
the full blocklist and 5.7Ã— less than Checklist with oï¬„ine-
online PIR), at the cost of increased server-side computation.
As Table 7 shows, there is not yet one private-blocklisting
scheme that dominates the others in all dimensions. Identifying
the optimal point in this trade-oï¬€ space requires measuring
the relative costs of the various computational resources.
Denial-of-service attacks. The initial hint-generation phase of
our scheme is relatively expensiveâ€”it requires 7.3 seconds of
server-side computation per client. If a single client could ask
the Safe Browsing servers to rerun the oï¬„ine hint-generation
phase as frequently as the client wanted, a single client could
easily exhaust server resources, denying service to honest
clients. We envision at least two approaches to preventing this
type of denial-of-service attack: First, in some settings, clients
have long-term identities, such as when Google Chrome users
are logged into the browser with their Google accounts. In
this case, the Safe Browsing server can limit the number of
oï¬„ine requests each client makes. (If the client exceeds this
limit, the servers could force it back to making non-private
queries.) Alternatively, the servers could use a proof-of-work
puzzle [6, 33] to force the clients to do at least as much
work as the servers do. This approach is wasteful, both in
energy and in that it doubles the total time of the oï¬„ine phase.
Nevertheless, since an honest client only requests a new full
hint very infrequentlyâ€”whenever it installs the browser for
the ï¬rst timeâ€”requiring several seconds of client CPU time
on initial hint generation seems feasible.
Synchronizing state. A Checklist deployment requires two
non-colluding entities to run the two Checklist servers. For
an Internet-scale deployment, we would implement each
logical Checklist server on hundreds or thousands of physical
replica servers, distributed around the world. As the blocklist
database changes, the replicas will need to download the
database updates from the main server.
When the Checklist client fetches its hint in the oï¬„ine
phase, the server includes a timestamp ğœ (as in Section 5.2)
indicating the database version that this hint is for. When the
client makes an online query later on, it sends this timestamp ğœ
along with its query. If the serverâ€™s database is newer than ğœ,
the client and the server run the update process described
in Section 5.2. If the serverâ€™s database is older than ğœ, then
the server is out of date and the client must retry its query at
another replica.
Clients only update their Safe Browsing data a few times
an hour (at most), so the main Safe Browsing server needs
to push updates to the replica servers only a few times per
hour as well. Since each update involves exchanging at most a
few megabytes of data with each replica, we expect it to be
relatively easy to keep a distributed ï¬‚eet of replicas up to date.
8.2 Extensions
Privacy for the server. We focus on protecting the privacy
of the clientâ€™s blocklist query but we do not attempt to hide
the full blocklist from the client. In many applications, such
as password-breach notiï¬cation services [51,62,63,82,84],
hiding the blocklist from the client is important. That is, at
each interaction with the server the client should only learn
whether its string appears on the blocklist.
Freedman, Ishai, Pinkas, and Reingold [36] show that
it is possible to lift a PIR scheme like ours, with privacy
for the client only, into a PIR scheme with privacy for the
client and servers using oblivious pseudorandom functions.
Their transformation is elegant and concretely eï¬ƒcient. It
makes black-box use of the underlying PIR and just requires
minimal extra server-side work and no additional rounds of
communication between the client and the server. While we
have not yet implemented this extension, since server-side
privacy is not crucial for us, we expect it to be a simple and
useful extension for other applications of Checklist.
888    30th USENIX Security Symposium
USENIX Association
âˆš
âˆš
âˆš
ğ‘¡ğ‘›, instead of the ğ‘¡
time is ğ‘¡âˆšï¸ğ‘›/ğ‘¡ =
Batching. In some applications of Checklist, a client may
want to query the blocklist on many strings at once. In this
case, the client and servers can use batch PIR schemes to
improve performance [4,48,53]. These schemes can reduce
the problem of making ğ‘¡ (cid:29) 1 PIR queries to a database of
size ğ‘› to the problem of making roughly ğ‘¡ queries (ignoring
log factors) to a database of size ğ‘›/ğ‘¡. When applied to our
oï¬„ine/online PIR schemes with online time
ğ‘›, the online
ğ‘› cost of ğ‘¡-fold repetition.
Since the Safe Browsing client only rarely makes multiple
PIR queries at once, we have not implemented this extension.
8.3 Future work
Single-server setting. Checklist requires two servers to main-
tain replicas of the blocklist, and client privacy holds against
adversaries that control at most one server. In practice, it can
be diï¬ƒcult to deploy multi-party protocols at scale, since it
requires coordination between multiple (possibly competing)
companies or organizations. An important direction for future
work would be to extend our oï¬„ine/online PIR scheme to
work in the single-server setting [59], taking advantage of
recent advances in lattice-based PIR schemes [2,3,4,5].
Prior work [27] shows that it is possible in theory to con-
struct single-server oï¬„ine/online PIR schemes with sublinear
online server time. Those schemes have two limitations that
would make them unsuitable in practice: they make extensive
use of expensive homomorphic-encryption schemes and they
do not allow the client to reuse its hint over multiple queries.
The latter property means that the total amortized server cost
per query is at least ğ‘› on a database of size ğ‘›, whereas the
amortized server-side cost of our scheme is roughly
ğ‘›. An
important task for future work would be to design single-server
oï¬„ine/online PIR schemes with modest concrete costs that
allow a client to reuse a single hint for multiple online queries.
Weakening the trust requirements. We present a two-server
oï¬„ine/online PIR scheme that protects client privacy against
a single malicious server. It would be much better if, for
any ğ‘˜ > 1, we could construct a ğ‘˜-server oï¬„ine/online PIR
scheme with sublinear online time that protects client privacy
against a coalition of ğ‘˜ âˆ’ 1 malicious servers.
While no such PIR scheme exists, to our knowledge, we
sketch one possible approach to constructing one here. Prior
work [27] constructs a single-server oï¬„ine/online PIR scheme
with sublinear online time. In the oï¬„ine phase of that scheme,
the client sends an encryption of a vector to the server, using
an additively homomorphic encryption scheme, and the server
applies a linear operation to the clientâ€™s query. We can execute
the same protocol in the ğ‘˜-server setting, by replacing the
additively homomorphic encryption with a ğ‘˜-out-of-ğ‘˜ linear
secret-sharing scheme. That is, the client would split its query
into ğ‘˜ pieces, send one share to each server, each server would
apply the same linear function to the clientâ€™s query, and the
client would reconstruct the response. The rest of the protocol
proceeds as in the scheme of prior work.
âˆš
This gives a ğ‘˜-server protocol with oï¬„ine communication
ğ‘›2/3 bits per server and online time ğ‘›2/3, with security against
adversarial coalitions of up to ğ‘˜ âˆ’ 1 servers. Unfortunately,
in this scheme, the client must rerun the oï¬„ine phase after
each online query. An intriguing open question is whether we
can construct more eï¬ƒcient oï¬„ine/online PIR schemes in the
ğ‘˜-server model and whether we can extend such schemes to
allow the client to reuse its hint over multiple queries.
9 Related work
Checklist follows recent work on improving the eï¬ƒciency
and privacy of blocklisting systems. CRLite [61], used in
the Firefox browser today, gives a sophisticated technique
for compressing a certiï¬cate-revocation blocklist using a hi-
erarchy of Bloom ï¬lters [11]. A browser can download and
store this compressed blocklist, and can thus make fast and
private local blocklist queries to it. CRLite relies on the fact
that the servers can enumerate over the set of valid certiï¬cates
by inspecting Certiï¬cate Transparency logs. Unfortunately,
CRLiteâ€™s optimizations do not apply to our settingâ€”in which
the set of all possible URLs is far too large to enumerate.
In addition, CRLite inherently requires total communication
linear in the size of the blocklist, whereas Checklist can have
total communication sublinear in the blocklist size. (In the
application of Checklist to Safe Browsing, the total commu-
nication is linear in the blocklist size, since the client must
download a list of partial hashes, as in Section 6.1.)
Other work has proposed ambitious, if more challenging
to deploy, approaches to certiï¬cate revocation. Revcast pro-
poses broadcasting certiï¬cate-revocation information over
FM radio [75]. Letâ€™s Revoke [79] proposes modifying the
public-key infrastructure to facilitate revocation. Solis and
Tsudik [80] identify privacy issues with OCSP certiï¬cate
revocation checks and propose heuristic privacy protections.
A number of tech companies today maintain blocklists
of passwords that have appeared in data breaches. Users
can check their passwords against these blocklists to learn
whether they should change passwords. Recent work [51,62,
63, 82, 84] develops protocols with which users can check
their passwords against these blocklists while (1) hiding
their password from the server and (2) without the server
revealing the entire blocklist to the client. Some of these
breach-notiï¬cation services [82] leak a partial hash of the
userâ€™s password to the server [63]. Schemes using private-set-
intersection protocols [21,22,71,73] avoid this leakage, but
require the server to do online work that is linear in the database
size. Using Checklist in this setting would eliminate leakage of
the hashed password to the server and would reduce the server-
side computational cost, since our amortized lookup cost is
sublinear in the blocklist size. The downside of Checklist is
that it requires two non-colluding servers to hold replicas of
the database, whereas these existing schemes do not.
Our focus application of Checklist is to the Safe Browsing
USENIX Association
30th USENIX Security Symposium    889
API. Prior work has demonstrated the privacy weaknesses of
the Safe Browsing API [9,38], arising from the fact that the
client leaks 32-bit hashes of the URLs it visits to the server.
Apple recently started to proxy Safe Browsing requests on iOS
via Apple servers to hide the requestorsâ€™ IP addresses from
Safe Browsing service providers such Google or Tencent [17].
The private Safe Browsing system of Cui et al. [28] pro-
vides privacy to both the client and the server by having
the client store a local encrypted copy of the blocklist. The
client decrypts individual entries by running an oblivious-
pseudorandom-function evaluation protocol with the server.
We can view their approach as applying the transformation
of Freedman et al. [36], which we mention in Section 8.2, to
the simplest possible PIR schemeâ€”storing the full blocklist
at the client. In contrast, one of the design goals of Checklist
is to avoid the cost of storing the full blocklist.
Piotrowska et al. describe a private notiï¬cation service
called AnNotify [72] and discuss its application to blocklist
lookups. Unlike Checklist, AnNotify tolerates some amount of
leakage about the queries. To mitigate the remaining leakage,
AnNotify runs on top of an anonymity network such as Tor.
The core of Checklist is a new two-server oï¬„ine/online
private-information-retrieval (PIR) scheme in which the
servers run in sublinear online time. While one oï¬„ine/online
PIR scheme with sublinear online time appears in prior
work [27], ours reduces the online time by a factor of ğœ† â‰ˆ 128
and gives the ï¬rst implementation of such a scheme.
Our PIR scheme builds on a long and beautiful body of work
on privacy-protecting database lookups. The literature on PIR
is vast and we will only be able to scratch the surface here.
Chor et al. [24,25] initiated the study of PIR in which the client
communicates with multiple non-colluding servers. Our PIR
scheme works in this multi-server model. Gasarch [37] gives
an excellent survey on the state of multi-server PIR as of 2004.
Recent work improves the communication cost of two-server
PIR using sophisticated coding ideas [32,35,85]. Under mild
assumptions, there exist two-server PIR schemes with almost
optimal communication cost [14,15,39,47]. An orthogonal
goal is to protect against PIR server misbehavior [29,40].
Given that modern multi-server PIR schemes have very
low communication costs, the remaining task is to reduce
the server-side computational cost of multi-server PIR. On
a database of ğ‘› rows, the above PIR schemes have server-
side cost Î©(ğ‘›). Beimel et al. [8] show that if the servers
preprocess the database, they can respond to client queries
in ğ‘œ(ğ‘›) time. Unfortunately, the schemes of Beimel et al. [8]
are relatively expensive in terms of communication cost and
require very large amounts of server storage. Alternatively,
â€œbatch PIRâ€ [48, 53] allows the client to fetch many records
at roughly the server-side cost of fetching a single record.
Lueks and Goldberg extend this approach to allow the servers
to answer queries from many mutually distrusting clients at
less than the cost of answering each clientâ€™s request indepen-
dently [64]. Other work relaxes the privacy guarantees of PIR