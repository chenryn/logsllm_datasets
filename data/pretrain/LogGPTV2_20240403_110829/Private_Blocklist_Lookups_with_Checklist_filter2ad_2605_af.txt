Checklist with oﬄine-online PIR (§4)
Checklist with DPF PIR [15]
143
1348
9047
(ms)
91
Initial
(sec)
3.1
Very small – not measured
13.3
2.6
90
122
Running
Initial
(MB) (MB/month)
5.0
91.8
10.3
5.0
3.0
13.2
9.8
3.6
0.5
8.0
0.8
4.3
91.8
24.5
4.3
0.2
4.5
1.6
0.2
USENIX Association
30th USENIX Security Symposium    887
0306090120150180Time(days)050100150200ServerCPUtime(sec,cumulative)0306090120150180Time(days)0204060ClientCPUtime(sec,cumulative)0306090120150180Time(days)0204060Communication(MB)by 30ms, though it would use 10× less client computation and
2.7× less bandwidth on a running basis.
8 Discussion
8.1 Deployment considerations
When is Checklist cost eﬀective for Safe Browsing? Table 7
shows three diﬀerent ways to achieve full privacy for Safe
Browsing queries: having the client maintain a full client-
side blocklist (“Full list”), using Checklist with a standard
PIR scheme (“DPF”), and using Checklist with our new
oﬄine/online PIR scheme (“Oﬄine-Online”). Which of these
three schemes will be best in practice depends on the relative
costs of server-side computation, client-side computation,
communication, and client storage.
Download full list. When communication and client storage
are relatively inexpensive, as on a powerful workstation with
a hard-wired network connection, the best Safe Browsing
solution may be to have the client keep a local copy of the entire
blocklist. Downloading the full list would require roughly
9× more communication initially and 3.7× more storage
than Checklist with oﬄine-online PIR, but the reduction in
server-side computational cost would be signiﬁcant.
Checklist with oﬄine-online PIR. When trying to jointly mini-
mize communication and server-side computation, Checklist
with our new oﬄine-online PIR scheme is the most appealing
approach. This point in the trade-oﬀ space may be useful for
general devices (laptops, etc.) in which it is reasonable to shift
some work to the client for the beneﬁt of decreased server
cost. The total communication is lower than downloading the
full blocklist and the server-side computation is roughly 7×
less than would be required when using standard PIR.
Checklist with DPF PIR. Finally, when trying to minimize
client computation and storage, Checklist with DPF-based PIR
may be the best option. This conﬁguration may be useful on
mobile devices, where client resources are especially scarce.
This approach requires the least storage (22× less than storing
the full blocklist and 5.7× less than Checklist with oﬄine-
online PIR), at the cost of increased server-side computation.
As Table 7 shows, there is not yet one private-blocklisting
scheme that dominates the others in all dimensions. Identifying
the optimal point in this trade-oﬀ space requires measuring
the relative costs of the various computational resources.
Denial-of-service attacks. The initial hint-generation phase of
our scheme is relatively expensive—it requires 7.3 seconds of
server-side computation per client. If a single client could ask
the Safe Browsing servers to rerun the oﬄine hint-generation
phase as frequently as the client wanted, a single client could
easily exhaust server resources, denying service to honest
clients. We envision at least two approaches to preventing this
type of denial-of-service attack: First, in some settings, clients
have long-term identities, such as when Google Chrome users
are logged into the browser with their Google accounts. In
this case, the Safe Browsing server can limit the number of
oﬄine requests each client makes. (If the client exceeds this
limit, the servers could force it back to making non-private
queries.) Alternatively, the servers could use a proof-of-work
puzzle [6, 33] to force the clients to do at least as much
work as the servers do. This approach is wasteful, both in
energy and in that it doubles the total time of the oﬄine phase.
Nevertheless, since an honest client only requests a new full
hint very infrequently—whenever it installs the browser for
the ﬁrst time—requiring several seconds of client CPU time
on initial hint generation seems feasible.
Synchronizing state. A Checklist deployment requires two
non-colluding entities to run the two Checklist servers. For
an Internet-scale deployment, we would implement each
logical Checklist server on hundreds or thousands of physical
replica servers, distributed around the world. As the blocklist
database changes, the replicas will need to download the
database updates from the main server.
When the Checklist client fetches its hint in the oﬄine
phase, the server includes a timestamp 𝜏 (as in Section 5.2)
indicating the database version that this hint is for. When the
client makes an online query later on, it sends this timestamp 𝜏
along with its query. If the server’s database is newer than 𝜏,
the client and the server run the update process described
in Section 5.2. If the server’s database is older than 𝜏, then
the server is out of date and the client must retry its query at
another replica.
Clients only update their Safe Browsing data a few times
an hour (at most), so the main Safe Browsing server needs
to push updates to the replica servers only a few times per
hour as well. Since each update involves exchanging at most a
few megabytes of data with each replica, we expect it to be
relatively easy to keep a distributed ﬂeet of replicas up to date.
8.2 Extensions
Privacy for the server. We focus on protecting the privacy
of the client’s blocklist query but we do not attempt to hide
the full blocklist from the client. In many applications, such
as password-breach notiﬁcation services [51,62,63,82,84],
hiding the blocklist from the client is important. That is, at
each interaction with the server the client should only learn
whether its string appears on the blocklist.
Freedman, Ishai, Pinkas, and Reingold [36] show that
it is possible to lift a PIR scheme like ours, with privacy
for the client only, into a PIR scheme with privacy for the
client and servers using oblivious pseudorandom functions.
Their transformation is elegant and concretely eﬃcient. It
makes black-box use of the underlying PIR and just requires
minimal extra server-side work and no additional rounds of
communication between the client and the server. While we
have not yet implemented this extension, since server-side
privacy is not crucial for us, we expect it to be a simple and
useful extension for other applications of Checklist.
888    30th USENIX Security Symposium
USENIX Association
√
√
√
𝑡𝑛, instead of the 𝑡
time is 𝑡√︁𝑛/𝑡 =
Batching. In some applications of Checklist, a client may
want to query the blocklist on many strings at once. In this
case, the client and servers can use batch PIR schemes to
improve performance [4,48,53]. These schemes can reduce
the problem of making 𝑡 (cid:29) 1 PIR queries to a database of
size 𝑛 to the problem of making roughly 𝑡 queries (ignoring
log factors) to a database of size 𝑛/𝑡. When applied to our
oﬄine/online PIR schemes with online time
𝑛, the online
𝑛 cost of 𝑡-fold repetition.
Since the Safe Browsing client only rarely makes multiple
PIR queries at once, we have not implemented this extension.
8.3 Future work
Single-server setting. Checklist requires two servers to main-
tain replicas of the blocklist, and client privacy holds against
adversaries that control at most one server. In practice, it can
be diﬃcult to deploy multi-party protocols at scale, since it
requires coordination between multiple (possibly competing)
companies or organizations. An important direction for future
work would be to extend our oﬄine/online PIR scheme to
work in the single-server setting [59], taking advantage of
recent advances in lattice-based PIR schemes [2,3,4,5].
Prior work [27] shows that it is possible in theory to con-
struct single-server oﬄine/online PIR schemes with sublinear
online server time. Those schemes have two limitations that
would make them unsuitable in practice: they make extensive
use of expensive homomorphic-encryption schemes and they
do not allow the client to reuse its hint over multiple queries.
The latter property means that the total amortized server cost
per query is at least 𝑛 on a database of size 𝑛, whereas the
amortized server-side cost of our scheme is roughly
𝑛. An
important task for future work would be to design single-server
oﬄine/online PIR schemes with modest concrete costs that
allow a client to reuse a single hint for multiple online queries.
Weakening the trust requirements. We present a two-server
oﬄine/online PIR scheme that protects client privacy against
a single malicious server. It would be much better if, for
any 𝑘 > 1, we could construct a 𝑘-server oﬄine/online PIR
scheme with sublinear online time that protects client privacy
against a coalition of 𝑘 − 1 malicious servers.
While no such PIR scheme exists, to our knowledge, we
sketch one possible approach to constructing one here. Prior
work [27] constructs a single-server oﬄine/online PIR scheme
with sublinear online time. In the oﬄine phase of that scheme,
the client sends an encryption of a vector to the server, using
an additively homomorphic encryption scheme, and the server
applies a linear operation to the client’s query. We can execute
the same protocol in the 𝑘-server setting, by replacing the
additively homomorphic encryption with a 𝑘-out-of-𝑘 linear
secret-sharing scheme. That is, the client would split its query
into 𝑘 pieces, send one share to each server, each server would
apply the same linear function to the client’s query, and the
client would reconstruct the response. The rest of the protocol
proceeds as in the scheme of prior work.
√
This gives a 𝑘-server protocol with oﬄine communication
𝑛2/3 bits per server and online time 𝑛2/3, with security against
adversarial coalitions of up to 𝑘 − 1 servers. Unfortunately,
in this scheme, the client must rerun the oﬄine phase after
each online query. An intriguing open question is whether we
can construct more eﬃcient oﬄine/online PIR schemes in the
𝑘-server model and whether we can extend such schemes to
allow the client to reuse its hint over multiple queries.
9 Related work
Checklist follows recent work on improving the eﬃciency
and privacy of blocklisting systems. CRLite [61], used in
the Firefox browser today, gives a sophisticated technique
for compressing a certiﬁcate-revocation blocklist using a hi-
erarchy of Bloom ﬁlters [11]. A browser can download and
store this compressed blocklist, and can thus make fast and
private local blocklist queries to it. CRLite relies on the fact
that the servers can enumerate over the set of valid certiﬁcates
by inspecting Certiﬁcate Transparency logs. Unfortunately,
CRLite’s optimizations do not apply to our setting—in which
the set of all possible URLs is far too large to enumerate.
In addition, CRLite inherently requires total communication
linear in the size of the blocklist, whereas Checklist can have
total communication sublinear in the blocklist size. (In the
application of Checklist to Safe Browsing, the total commu-
nication is linear in the blocklist size, since the client must
download a list of partial hashes, as in Section 6.1.)
Other work has proposed ambitious, if more challenging
to deploy, approaches to certiﬁcate revocation. Revcast pro-
poses broadcasting certiﬁcate-revocation information over
FM radio [75]. Let’s Revoke [79] proposes modifying the
public-key infrastructure to facilitate revocation. Solis and
Tsudik [80] identify privacy issues with OCSP certiﬁcate
revocation checks and propose heuristic privacy protections.
A number of tech companies today maintain blocklists
of passwords that have appeared in data breaches. Users
can check their passwords against these blocklists to learn
whether they should change passwords. Recent work [51,62,
63, 82, 84] develops protocols with which users can check
their passwords against these blocklists while (1) hiding
their password from the server and (2) without the server
revealing the entire blocklist to the client. Some of these
breach-notiﬁcation services [82] leak a partial hash of the
user’s password to the server [63]. Schemes using private-set-
intersection protocols [21,22,71,73] avoid this leakage, but
require the server to do online work that is linear in the database
size. Using Checklist in this setting would eliminate leakage of
the hashed password to the server and would reduce the server-
side computational cost, since our amortized lookup cost is
sublinear in the blocklist size. The downside of Checklist is
that it requires two non-colluding servers to hold replicas of
the database, whereas these existing schemes do not.
Our focus application of Checklist is to the Safe Browsing
USENIX Association
30th USENIX Security Symposium    889
API. Prior work has demonstrated the privacy weaknesses of
the Safe Browsing API [9,38], arising from the fact that the
client leaks 32-bit hashes of the URLs it visits to the server.
Apple recently started to proxy Safe Browsing requests on iOS
via Apple servers to hide the requestors’ IP addresses from
Safe Browsing service providers such Google or Tencent [17].
The private Safe Browsing system of Cui et al. [28] pro-
vides privacy to both the client and the server by having
the client store a local encrypted copy of the blocklist. The
client decrypts individual entries by running an oblivious-
pseudorandom-function evaluation protocol with the server.
We can view their approach as applying the transformation
of Freedman et al. [36], which we mention in Section 8.2, to
the simplest possible PIR scheme—storing the full blocklist
at the client. In contrast, one of the design goals of Checklist
is to avoid the cost of storing the full blocklist.
Piotrowska et al. describe a private notiﬁcation service
called AnNotify [72] and discuss its application to blocklist
lookups. Unlike Checklist, AnNotify tolerates some amount of
leakage about the queries. To mitigate the remaining leakage,
AnNotify runs on top of an anonymity network such as Tor.
The core of Checklist is a new two-server oﬄine/online
private-information-retrieval (PIR) scheme in which the
servers run in sublinear online time. While one oﬄine/online
PIR scheme with sublinear online time appears in prior
work [27], ours reduces the online time by a factor of 𝜆 ≈ 128
and gives the ﬁrst implementation of such a scheme.
Our PIR scheme builds on a long and beautiful body of work
on privacy-protecting database lookups. The literature on PIR
is vast and we will only be able to scratch the surface here.
Chor et al. [24,25] initiated the study of PIR in which the client
communicates with multiple non-colluding servers. Our PIR
scheme works in this multi-server model. Gasarch [37] gives
an excellent survey on the state of multi-server PIR as of 2004.
Recent work improves the communication cost of two-server
PIR using sophisticated coding ideas [32,35,85]. Under mild
assumptions, there exist two-server PIR schemes with almost
optimal communication cost [14,15,39,47]. An orthogonal
goal is to protect against PIR server misbehavior [29,40].
Given that modern multi-server PIR schemes have very
low communication costs, the remaining task is to reduce
the server-side computational cost of multi-server PIR. On
a database of 𝑛 rows, the above PIR schemes have server-
side cost Ω(𝑛). Beimel et al. [8] show that if the servers
preprocess the database, they can respond to client queries
in 𝑜(𝑛) time. Unfortunately, the schemes of Beimel et al. [8]
are relatively expensive in terms of communication cost and
require very large amounts of server storage. Alternatively,
“batch PIR” [48, 53] allows the client to fetch many records
at roughly the server-side cost of fetching a single record.
Lueks and Goldberg extend this approach to allow the servers
to answer queries from many mutually distrusting clients at
less than the cost of answering each client’s request indepen-
dently [64]. Other work relaxes the privacy guarantees of PIR