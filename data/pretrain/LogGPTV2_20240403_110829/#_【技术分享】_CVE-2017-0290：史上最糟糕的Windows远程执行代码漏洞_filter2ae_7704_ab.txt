0x12046f，并将其放在IDA中。正如预期的那样，它位于发生崩溃的函数调用之后。然后我考察了包含该地址的函数的地址，并考察了它与修补版本的区别。
这看起来添加了相应的检查，如果某些东西不正确，它将退出函数。
（修补版本位于左边。）上面的红色区域是添加的代码，它接收rdi（对象）为参数并将其传递给某个函数的调用，如果该函数的结果为4，则执行情况如前所述，否则将返回值（a1）设置为0（见下部红色区域代码），并且退出该函数。从上面的红色区域中调用的函数似乎决定了对象的类型并返回其类型代码。通过查看对这个函数的其他调用，我找到了JavaScript的typeof运算符的实现，明确了字符串的类型代码实际上就是4。
这显然就是我正在寻找的补丁。确认这一点并非难事，它所做的正好是我们所预期的，同时它还位于崩溃代码路径中。
**针对CVE-2017-0290的微补丁**
现在，我的目标是创建一个微补丁，将相同的补丁逻辑注入到易受攻击的mpengine.dll版本中。
在理想的情况下，我可以原封不动的套用打补丁后的版本中的相关代码，并将其注入到同一个位置——但现实情况是，编译器喜欢使用不同的寄存器和不同的实现代码来实现相同的逻辑。所以，我不得不根据原来的补丁重新实现补丁逻辑。
我们来看看IDA中的含有漏洞的函数。
上图显示了易受攻击的函数，以及注入我们的代码的理想位置。之所以选择该位置，是因为其允许我们从自己的补丁代码直接跳转到函数结尾（地址最低的代码块）。
以下是版本为1.1.13701.0的64位mpengine.dll的补丁代码：
    ;0patch for CVE-2017-0290 in 64-bit mpengine.dll version 1.1.13701.0
    MODULE_PATH "C:AnalysisCVE-2017-0290mpengine.dll_64bit_1.1.13701.0mpengine.dll"
    PATCH_ID 271
    PATCH_FORMAT_VER 2
    VULN_ID 2436
    PLATFORM win64
    patchlet_start
     PATCHLET_ID 1
     PATCHLET_TYPE 2
     PATCHLET_OFFSET 0x218E10
     ; We'll need the GetTypeOf function and the location of function epilogue
     PIT mpengine.dll!0x218940,mpengine.dll!0x218E9A
     ; Note that GetTypeOf taints the following registers:
     ; rdx - always
     ; rcx - only in case of an exception
     ; rax - expected, this is the return value
     code_start
      push rcx          ; We need to preserve rcx, as it's still used after our patchlet code
                        ; while GetTypeOf taints rdx, we don't need to preserve it
      mov rcx, r9       ; r9 points to the object
      call PIT_0x218940 ; GetTypeOf object
      pop rcx           ; restore rcx
      cmp eax, 4        ; is the object of type string?
      jz OK             ; It is? Very well, continue...
      xor al, al        ; It isn't? Exit this function without doing anything, return 0
      call PIT_ExploitBlocked ; Show "Exploit attempt blocked"
      jmp PIT_0x218E9A  ; Jump to function epilogue
      OK:
     code_end
    patchlet_end
这个补丁程序将被放到上面代码中显示的位置，其作用像原始的补丁一样，针对该对象（其地址在寄存器r9中）调用GetTypeOf，并查看其类型代码是否为4（字符串）。如果是的话，它将继续执行原始代码注入。否则，它将返回码（寄存器al）设置为0，并跳转到函数结尾。
请注意，为了避免任何副作用，我必须（1）审查GetTypeOf函数，看看哪些寄存器可能会被污染，以及这是否会影响我们注入的补丁后面的代码（它会影响rdx和rcx，但是rdx存放的值不会对我们的注入点有影响），然后（2）在调用GetTypeOf函数之前，将rcx的值存储到堆栈上，因为rcx保留了一些在我们注入的补丁后面的代码仍然要用到的值。
此外，我也为易受攻击的32位版本的mpengine.dll写了相同的补丁。如果您安装了0patch
Agent，补丁ZP-271和ZP-272应该已经下载到您的计算机，静候导致加载mpengine.dll的事件的到来。
**受保护服务的讽刺性**
要恢复原始系统配置，我将Windows Defender恢复为受保护的服务，并且补丁也停止应用。很明显，我们无法将我们的加载程序注入受保护的Windows
Defender中，因为只允许加载Microsoft签名的二进制文件。之所以这样，是因为Windows
Defender想保护自身免受本地恶意软件（即使有管理员权限的代码）的侵害。
具有讽刺意味的是，Windows的防恶意软件，竟然会阻止我们的安全产品在Windows Defender中修复漏洞，而该漏洞的利用代码却可以在Windows
Defender中自由执行任意代码。 （嗯，也许我们应该利用这个漏洞利用代码，使我们的代码得以在Windows Defender中运行，从而修复它的漏洞。）
需要注意的是，给Malware Protection Engine的ZP-271和ZP-272打补丁只适用于没有提供受保护服务的Windows
7和Windows Vista。
**试用CVE-2017-0290微补丁**
如果您想对这些微补丁进行试验的话，需要用到：
1\. 运行Windows Defender软件的32位或64位Windows
7电脑。虽然您也可以在较新的Windows版本上进行测试，但您必须取消Windows Defender的服务保护功能才能继续。
2\. 含有漏洞的mpengine.dll。如果您的Windows Defender不是这个版本（这倒不太可能，由于它会自动更新），您可以在这里下载：
1\. 用于32位Windows的32位mpengine.dll，版本1.1.13701.0
3\. 用于64位Windows的64位mpengine.dll，版本1.1.13701.0
首先，通过提权后的服务控制台停止Windows Defender服务。
然后导航至C： ProgramData Microsoft Windows
Defender（文件夹权限最初不允许你打开它，所以Windows会要求提高权限，之后它会添加你的帐户到文件夹ACL）。打开Definition
Updates文件夹，这时会看到一个或多个具有类似GUID的名称的子文件夹，它们以大括号开头。打开这些文件夹，找到包含mpengine.dll的文件夹。将现有的mpengine.dll重命名为其他名称，然后在其中放入含有漏洞的mpengine.dll。
启动Windows Defender服务。
下载概念验证文件并将其存储到一个空的临时文件夹中。
通过控制面板启动Windows Defender控制台，并通过自定义扫描上述文件夹。请注意，Windows Defender服务将会崩溃。
现在在计算机上安装0patch Agent。如果您还没有安装的话，请下载免费的副本，并使用您的免费的0patch帐户注册。
最后，重新启动Windows Defender服务并重新扫描临时文件夹。这一次，你会看到一个“Exploit Attempt
Blocked”弹出窗口，而不是Windows Defender崩溃。
如果您想自己编译我们的补丁，您可以下载其源代码，并通过0patch Agent for Developers编译它们。
虽然这个漏洞已经在大多数计算机上自动修复，但事实证明，对于打微补丁来说，这是一个有趣的学习机会。我希望这篇文章可以对未来的微补丁开发和使用者有所帮助。
**后记**
当我在写这篇文章的时候，世界正在被WannaCry
ransomware蠕虫狂虐，实际上，该蠕虫利用的是一个已知的漏洞，该漏洞的官方补丁也及时发布了。不幸的是，许多医院和其他重要的基础设施都是脱机的，部分原因还是因为他们仍在使用Windows
XP等不再提供支持的操作系统。在2017年，由于某些合理和复杂的原因，这些过时的系统仍会被继续使用，毫无疑问，在明年和后年，还是有些机构仍然会继续使用它们。
0patch的目标之一，就是为用户提供相应的更新，来保护这些终端系统。防御现代攻击者需要人们快速的反应，尽管CVE-2017-0290的这项练习对用户的价值可能很低，但却是磨练技能和提高速度的一个机会。当今世界将需要越来越多的第三方补丁程序开发人员，因此，热烈欢迎所有现有和潜在的安全研究人员都加入到我们的队伍中来。