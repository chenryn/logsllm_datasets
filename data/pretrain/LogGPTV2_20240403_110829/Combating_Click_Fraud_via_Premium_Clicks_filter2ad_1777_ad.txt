### Attestor
The prototype attestor is a straightforward service that provides a login box. When a user enters a valid ID and password, they are directed to an internal page that serves a cache cookie to the visitor’s browser. This simple HTML file is transmitted from the attestor to the visitor only once after the initial login. Any subsequent requests for the cache-cookie URL are responded to with an HTTP 304 "Not Modified" response. This forces the browser to use a cached version of the cookie if it exists, and does not provide one to browsers lacking a cached version.

The cache cookie served by the attestor references an image hosted on the syndicator. The URL used to request the image is generated by JavaScript when the cookie's HTML is rendered, and it includes a secret value (γ, which is generated when the cache cookie is set) as well as the referrer page, i.e., the page that caused the cache cookie to load. Later, when the cookie is loaded in conjunction with a click, the URL of the referrer will reveal the ID of the publisher and the ID of the advertisement that was clicked.

The attestor must create and serve these cache cookies when the user logs in, requiring additional processing. However, generating a secret value takes very little time, and the cookie can be served in a hidden iframe. This results in no difference in the user experience and only a minimal amount of work for the attestor's servers.

### Syndicator
Among all the entities, the syndicator performs the most tasks. It receives coupons released by the cache cookies (in the form of requested images), verifies the secrets in the coupons, and records clicks. Additionally, each ad click must be directed through the syndicator, so it must also serve a transfer page to direct the client’s web browser to the advertiser’s site. This is a standard flow of traffic in ad-serving systems, where the syndicator briefly delegates control to record clicks.

#### Database
The syndicator hosts a MySQL database to store the following:
- Advertisement data (content, advertiser’s ID, URL)
- Click-through log (each click as it occurs, including advertisement ID and publisher ID)
- Log of received coupons

Since the released coupon history needs to be saved and searched, a database is used to simplify development.

#### Processing Clicks
When an advertisement is clicked, the client’s browser navigates to the syndicator’s site, bringing along the advertisement ID and the publisher ID. For example:
```
http://syndicator/click.php?ad=x&pub=y
```
The syndicator then records the click and responds with a web page that causes cache cookies from all attestors to load. (In our implementation, only one attestor was used, so one iframe is rendered with its content being the attestor’s cache cookie. If there were N possible attestors, N iframes would be used.) Cache cookies not available in the browser’s cache are simply not loaded. Coupons are released by the client’s browser from any attestor’s cache cookies.

#### Receiving Coupons
Coupons are received by the syndicator in the form of requests for an image called "coupon.gif". When this is requested, it is accompanied by a query string. For example:
```
http://syndicator/coupon.gif?secret=γ&ref=x
```
The `ref` variable in the query string reflects both the publisher ID (`IDpub`) and the advertisement ID (`IDad`) that was clicked. Upon receiving this request, the syndicator records the time, secret (γ), and referrer (x) in the database, and then serves a tiny image back to the client. HTTP headers are provided to force the client’s browser to always request this image and not load it from the cache. This ensures that the coupons are always freshly delivered and not loaded from the browser cache.

#### Analyzing Clicks
On the syndicator’s click-through page where the attestors’ cache-cookie iframes are present, a small delay is forced by JavaScript to allow the coupons transit time, as they load asynchronously in iframes. Immediately following that, the server decides if a click should be classified as "premium." This is done by looking through the coupon database for recently released coupons corresponding to the advertisement that was clicked. The time between when the click was recorded and when the coupons arrived is noted, and only coupons within a pre-set window (τreplay, sixty seconds in our prototype) are considered in determining the premium status. If coupons are present and the secrets are valid, the click is recorded as "premium." Otherwise, it is recorded as a general-class click.

In a production system, click analysis would be done after redirecting the client by adding it to a processing queue.

### Privacy
In deploying our premium-click scheme with multiple attestors (A1, ..., Aq), it would be natural for a syndicator to share a unique key (ki) with each attestor (Ai). Given such independent attestor keys, a coupon created by Ai reveals that a user has visited the Web site of Ai. However, in our scheme, a publisher triggers the release of a coupon from the browser of a visiting user but does not see the coupon. The syndicator receives the coupon but does not directly interact with the user, effectively receiving the coupon blindly. While the syndicator learns the IP address of the user, this is information typically already available. The only additional information the syndicator learns is whether or not the user has received an attestation. Thus, coupons naturally decouple information about the browsing patterns of users from their identities and browsing sessions, preserving privacy.

This decoupling occurs when ads are outsourced, i.e., when the syndicator and publisher are separate. When the syndicator and publisher are identical, such as when a search engine displays its own advertisements, coupons may be linked to users, potentially leaking sensitive information. To mitigate this, we propose a multiple-coupon technique discussed in Appendix A, or attestors may share a single key (k) or have overlapping sets of keys. In this case, a MAC does not reveal the identity of the attestor that created it.

### Security Analysis
Without possession of an attestor key, an adversary cannot feasibly forge new coupons, thanks to the use of MACs. However, an adversary could still bypass our scheme in several ways:
- **Direct Publisher Fraud:** Using a slight modification of the proposed solution, the publisher could cause the release of coupons even when users do not click on ads.
- **Indirect Publisher Fraud:** A dishonest website could redirect users to the publisher’s site.
- **Malware-Driven Clicks:** A virus or widely spread Trojan could either surreptitiously direct a user’s browser to a website and simulate a click or steal a coupon from the browser for use on another platform.

These attacks are possible in existing click-fraud schemes, and the techniques used to address them today are equally applicable to premium clicks. For example, a syndicator can direct its own client machines to a publisher’s site to determine if the publisher is generating fraudulent clicks. Our premium-click scheme makes detection of misbehavior easier, as it permits a syndicator to "mark" a client coupon and directly monitor the traffic generated by the client, even detecting the emergence of stolen coupons.

An adversary can also try to exploit the special characteristics of our scheme:
- **Posing as an Attestor:** An adversary might establish itself as an attestor or compromise the key of an existing attestor. If the syndicator sets appropriate policies for creating attestors, it should be difficult for an adversary to pose as one. Attestors are likely to be a more exclusive class of websites than publishers or advertisers.
- **Compromise of an Attestor Key:** An adversary can attempt to learn the MAC key of an existing attestor. The difficulty of this attack depends on the security of the attestor’s website. MAC keys for premium clicks may be protected using many of the same measures employed to secure SSL keys and other cryptographic secrets.
- **Coupon Harvesting:** An adversary could harvest coupons from attestors by creating accounts or clients that meet their validation criteria. By establishing appropriate policies for validation by its attestors, the syndicator can attach a financial cost to this form of fraud in excess of the gains a fraudster might reap from it.

### Auditing
Since the syndicator ultimately decides which clicks should be considered "premium" (and earns more when clicks are premium), publishers and advertisers may accuse the syndicator of improperly inflating the percentage of clicks considered premium. To solve this problem, an additional entity called an auditor can be contracted to watch the coupons that are released and verify the premium-status judgment of the syndicator. The auditor would not be rewarded based on click traffic, so it would have no incentive to inflate or deflate the number of premium clicks from those that are legitimate.

The cache cookies set by attestors can be crafted so that, when an advertisement’s URL is clicked, the coupon C = (γ, IDpub, IDad) is released both to the syndicator and to the auditor who maintains an independent database. When the syndicator’s numbers are contested, the coupons recorded by the auditor can be used to recompute the number of premium clicks for a given advertisement or publisher and compared to the syndicator’s calculation.

### Conclusion
In contrast to today’s heuristic filtering methods for eliminating “bad” clicks, our premium-click scheme relies on a foundation of cryptographic authentication to validate “good” clicks. Premium clicks are not a cure-all for fraud and are themselves subject to attack. The value of premium clicks lies in the way they provide new, cryptographically authenticated visibility into click traffic, thus offering a stronger platform for combating click fraud.

While premium clicks could in principle supplant current filtering schemes entirely, they are attractive because they can be deployed in a complementary fashion alongside existing systems. We have proposed a new advertising model in which advertisers pay a higher charge for premium clicks. We believe that such a scheme might be launched experimentally by a syndicator with minimal impact on existing business and then expanded as its success warrants. Thus, premium clicks promise not only a new approach to click fraud but one with a practical path to fruition.

### References
[1] ATENIESE, G., CAMENISCH, J., JOYE, M., AND TSUDIK, G. A practical and provably secure coalition-resistant group signature scheme. In Advances in Cryptology-Crypto ’00 (2000), M. Bellare, Ed., Springer. LNCS vol. 1880.
[2] BELLARE, M., CANETTI, R., AND KRAWCZYK, H. Keying hash functions for message authentication. In CRYPTO ’96: Proceedings of the 16th Annual International Cryptology Conference on Advances in Cryptology (London, UK, 1996), Springer-Verlag, pp. 1–15.
[3] EBAY. www.ebay.com, Accessed 31 January 2007.
[4] GANDHI, M., JAKOBSSON, M., AND RATKIEWICZ, J. Badvertisements: Stealthy click-fraud with unwitting accessories. In Anti-Phishing and Online Fraud, Part I Journal of Digital Forensic Practice, Volume 1, Special Issue 2 (November 2006).
[5] JUELS, A., JAKOBSSON, M., AND JAGATIC, T. Cache cookies for browser authentication (extended abstract). In IEEE Symposium on Privacy and Security (2006), pp. 301–305.
[6] RSNAKE. Stealing mouse clicks for banner fraud. http://ha.ckers.org/blog/20070116/stealing-mouse-clicks-for-banner-fraud/, January 2007.
[7] STAMM, S., RAMZAN, Z., AND JAKOBSSON, M. Drive-by pharming. Technical Report, 2006. http://www.cs.indiana.edu/pub/techreports/TR641.pdf.
[8] TSOW, A. Phishing with consumer electronics – malicious home routers. In In Models of Trust for the Web, a workshop at the 15th International World Wide Web Conference (WWW2006) (2006).
[9] TSOW, A., JAKOBSSON, M., YANG, L., AND WETZEL, S. Warkitting: the drive-by subversion of wireless home routers. In Anti-Phishing and Online Fraud, Part II Journal of Digital Forensic Practice, Volume 1, Special Issue 3 (November 2006).
[10] TUZHILIN, A. The Lanes gifts v. Google report, 2006. Independent evaluators assessment of quality of Google’s click-fraud filtering methods. Accessed 31 January 2007 at http://googleblog.blogspot.com/pdf/Tuzhilin_Report.pdf.

### Notes
1. This research was performed by the author at RavenWhite Inc.
2. The reason for having the syndicator trigger coupon-release is twofold: (1) To prevent JavaScript-based click automation, ads today are often rendered inside an iframe whose source is loaded from the syndicator’s site, and (2) To eliminate the need for JavaScript on the publisher’s site.
3. An authenticator could create a list X of random codes and transfer it to the syndicator via a backchannel, but this would not be efficient (and would also eliminate some of the privacy properties we would like to achieve).
4. In a multi-attestor environment, where clients may carry and release multiple coupons, the syndicator needs some mechanism to determine which coupons correspond to a given client. A simple option is to attach a fresh, random number (nonce) to the links in each rendered advertisement. The nonce will attach itself to all of the coupons that a client releases in a given click.
5. Inclusion of an IP address in a coupon also has some security benefits. In the case where the syndicator publishes its own ads, it can check that a client’s presented IP address is consistent with the IP address in the coupon, e.g., it originates with the same service provider.
6. A counter might still embed a covert channel, but, if the size of the channel might be made small enough to alleviate the problem of privacy infringement significantly.

### Appendix A: Multiple Attestors
User privacy in our premium-click scheme depends on how the value γ is formed and the number and content of the coupons cached in a user’s browser. Let us consider a system with multiple attestors (A1, ..., Aq). Each attestor (authi) shares a key (ki) with the syndicator. We now describe the technical challenges that arise with multiple attestors.

#### Multiple Coupons
The first problem in a system with multiple attestors is managing multiple cache cookies across different domains. A cache-cookie system can involve caching a set of j different webpages (X1, X2, ..., Xj) in a given user’s browser, each webpage serving as a slot for a distinct cache cookie. Two difficulties arise:
1. A site seeking to release a set of cache cookies (i.e., the publisher) cannot determine what slots in a user’s browser actually contain cache cookies. The only way for the publisher to release all cache cookies is to call all j webpages.
2. A site seeking to set a cache cookie, i.e., an attestor, cannot determine if a given slot has been filled. If the attestor plants a cache cookie in a slot that already contains one, the previously planted cache cookie will be effaced.

The simplest way to circumvent these difficulties in our premium-clicks scheme is to manage only a single slot, maintaining only a single cache cookie in a given user’s browser. Only the cache cookie planted most recently by an attestor will persist. Provided that the syndicator regards all attestors as having equal authority in validating users, this approach does not result in any service degradation.

If the syndicator desires the ability to harvest multiple coupons, then attestors must use multiple slots. One possible approach is to maintain an individual slot for each attestor, i.e., let j = q. If the number of attestors is small, this may be workable. Alternatively, attestors may plant coupons in random slots, sometimes supplanting previous coupons, or subsets of attestors may share slots. The syndicator might, for example, assign different weights to attestors according to the anticipated reliability of their attestations; attestors with the same rating might share a slot.

#### Keying
One approach to managing attestor keys is to assign an identical key (k) to all attestors, i.e., let k1 = k2 ... = k. While this approach is simple, it has the disadvantage of rendering tracing and key-revocation difficult.

It is preferable to create attestor keys {ki} independently. In this case, a coupon γ = m || k || M ACki(m) is cryptographically bound to the attestor that created it. That is, only attestor Ai, with its knowledge of ki, can feasibly create γ of this form. To enable the syndicator to determine the correct key for verification of the MAC, the coupon must be supplemented with i, the identity of the authenticator. For example, we might let m = i || k || r, where r is a random nonce.