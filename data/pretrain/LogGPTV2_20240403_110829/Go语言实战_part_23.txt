35
6.5 通道 145
36 // 等待接力棒
37 runner := <-baton
38
39 // 开始绕着跑道跑步
40 fmt.Printf("Runner %d Running With Baton\n", runner)
41
42 // 创建下一位跑步者
43 if runner != 4 {
44 newRunner = runner + 1
45 fmt.Printf("Runner %d To The Line\n", newRunner)
46 go Runner(baton)
47 }
48
49 // 围绕跑道跑
50 time.Sleep(100 * time.Millisecond)
51
52 // 比赛结束了吗？
53 if runner == 4 {
54 fmt.Printf("Runner %d Finished, Race Over\n", runner)
55 wg.Done()
56 return
57 }
58
59 // 将接力棒交给下一位跑步者
60 fmt.Printf("Runner %d Exchange With Runner %d\n",
61 runner,
62 newRunner)
63
64 baton <- newRunner
65 }
运行这个程序会得到代码清单6-23所示的输出。
代码清单6-23 listing22.go 的输出
Runner 1 Running With Baton
Runner 1 To The Line
Runner 1 Exchange With Runner 2
Runner 2 Running With Baton
Runner 2 To The Line
Runner 2 Exchange With Runner 3
Runner 3 Running With Baton
Runner 3 To The Line
Runner 3 Exchange With Runner 4
Runner 4 Running With Baton
Runner 4 Finished, Race Over
在main函数的第17行，创建了一个无缓冲的int类型的通道baton，用来同步传递接力棒。
在第20行，我们给WaitGroup加1，这样main函数就会等最后一位跑步者跑步结束。在第23行
创建了一个goroutine，用来表示第一位跑步者来到跑道。之后在第26行，将接力棒交给这个跑步者，
比赛开始。最终，在第29行，main函数阻塞在WaitGroup，等候最后一位跑步者完成比赛。
在Runner goroutine里，可以看到接力棒baton是如何在跑步者之间传递的。在第37行，
goroutine对baton通道执行接收操作，表示等候接力棒。一旦接力棒传了进来，在第46行就会
创建一位新跑步者，准备接力下一棒，直到goroutine是第四个跑步者。在第50行，跑步者围绕
跑道跑100 ms。在第 55行，如果第四个跑步者完成了比赛，就调用Done，将WaitGroup减1，
之后goroutine返回。如果这个goroutine不是第四个跑步者，那么在第64行，接力棒会交到下一
个已经在等待的跑步者手上。在这个时候，goroutine会被锁住，直到交接完成。
在这两个例子里，我们使用无缓冲的通道同步goroutine，模拟了网球和接力赛。代码的流程
与这两个活动在真实世界中的流程完全一样，这样的代码很容易读懂。现在知道了无缓冲的通道
是如何工作的，接下来我们会学习有缓冲的通道的工作方法。
6.5.2 有缓冲的通道
有缓冲的通道（buffered channel）是一种在被接收前能存储一个或者多个值的通道。这种类
型的通道并不强制要求 goroutine 之间必须同时完成发送和接收。通道会阻塞发送和接收动作的
条件也会不同。只有在通道中没有要接收的值时，接收动作才会阻塞。只有在通道没有可用缓冲
区容纳被发送的值时，发送动作才会阻塞。这导致有缓冲的通道和无缓冲的通道之间的一个很大
的不同：无缓冲的通道保证进行发送和接收的 goroutine 会在同一时间进行数据交换；有缓冲的
通道没有这种保证。
在图6-7中可以看到两个goroutine分别向有缓冲的通道里增加一个值和从有缓冲的通道里移
除一个值。在第1步，右侧的goroutine正在从通道接收一个值。在第2步，右侧的这个goroutine
独立完成了接收值的动作，而左侧的 goroutine 正在发送一个新值到通道里。在第 3 步，左侧的
goroutine 还在向通道发送新值，而右侧的 goroutine 正在从通道接收另外一个值。这个步骤里的
两个操作既不是同步的，也不会互相阻塞。最后，在第4步，所有的发送和接收都完成，而通道
里还有几个值，也有一些空间可以存更多的值。
图6-7 使用有缓冲的通道在goroutine之间同步数据
让我们看一个使用有缓冲的通道的例子，这个例子管理一组 goroutine 来接收并完成工作。
有缓冲的通道提供了一种清晰而直观的方式来实现这个功能，如代码清单6-24所示。
代码清单6-24 listing24.go
01 // 这个示例程序展示如何使用
02 // 有缓冲的通道和固定数目的
03 // goroutine来处理一堆工作
04 package main
05
06 import (
07 "fmt"
08 "math/rand"
09 "sync"
10 "time"
11 )
12
13 const (
14 numberGoroutines = 4 // 要使用的goroutine的数量
15 taskLoad = 10 // 要处理的工作的数量
16 )
17
18 // wg用来等待程序完成
19 var wg sync.WaitGroup
20
21 // init初始化包，Go语言运行时会在其他代码执行之前
22 // 优先执行这个函数
23 func init() {
24 // 初始化随机数种子
25 rand.Seed(time.Now().Unix())
26 }
27
28 // main是所有Go程序的入口
29 func main() {
30 // 创建一个有缓冲的通道来管理工作
31 tasks := make(chan string, taskLoad)
32
33 // 启动goroutine来处理工作
34 wg.Add(numberGoroutines)
35 for gr := 1; gr <= numberGoroutines; gr++ {
36 go worker(tasks, gr)
37 }
38
39 // 增加一组要完成的工作
40 for post := 1; post <= taskLoad; post++ {
41 tasks <- fmt.Sprintf("Task : %d", post)
42 }
43
44 // 当所有工作都处理完时关闭通道
45 // 以便所有goroutine退出
46 close(tasks)
47
48 // 等待所有工作完成
49 wg.Wait()
50 }
51
52 // worker作为goroutine启动来处理
53 // 从有缓冲的通道传入的工作
54 func worker(tasks chan string, worker int) {
55 // 通知函数已经返回
56 defer wg.Done()
57
58 for {
59 // 等待分配工作
60 task, ok := <-tasks
61 if !ok {
62 // 这意味着通道已经空了，并且已被关闭
63 fmt.Printf("Worker: %d : Shutting Down\n", worker)
64 return
65 }
66
67 // 显示我们开始工作了
68 fmt.Printf("Worker: %d : Started %s\n", worker, task)
69
70 // 随机等一段时间来模拟工作
71 sleep := rand.Int63n(100)
72 time.Sleep(time.Duration(sleep) * time.Millisecond)
73
74 // 显示我们完成了工作
75 fmt.Printf("Worker: %d : Completed %s\n", worker, task)
76 }
77 }
运行这个程序会得到代码清单6-25所示的输出。
代码清单6-25 listing24.go的输出
Worker: 1 : Started Task : 1
Worker: 2 : Started Task : 2
Worker: 3 : Started Task : 3
Worker: 4 : Started Task : 4
Worker: 1 : Completed Task : 1
Worker: 1 : Started Task : 5
Worker: 4 : Completed Task : 4
Worker: 4 : Started Task : 6
Worker: 1 : Completed Task : 5
Worker: 1 : Started Task : 7
Worker: 2 : Completed Task : 2
Worker: 2 : Started Task : 8
Worker: 3 : Completed Task : 3
Worker: 3 : Started Task : 9
Worker: 1 : Completed Task : 7
Worker: 1 : Started Task : 10
Worker: 4 : Completed Task : 6
Worker: 4 : Shutting Down
Worker: 3 : Completed Task : 9
Worker: 3 : Shutting Down
Worker: 2 : Completed Task : 8
Worker: 2 : Shutting Down
Worker: 1 : Completed Task : 10
Worker: 1 : Shutting Down
由于程序和Go语言的调度器带有随机成分，这个程序每次执行得到的输出会不一样。不过，
通过有缓冲的通道，使用所有 4 个 goroutine 来完成工作，这个流程不会变。从输出可以看到每
个goroutine是如何接收从通道里分发的工作。
在main函数的第31行，创建了一个string类型的有缓冲的通道，缓冲的容量是10。在
第34行，给WaitGroup赋值为4，代表创建了4个工作goroutine。之后在第35行到第37行，
创建了4个goroutine，并传入用来接收工作的通道。在第40行到第42行，将10个字符串发送
到通道，模拟发给goroutine的工作。一旦最后一个字符串发送到通道，通道就会在第46行关闭，
而main函数就会在第49行等待所有工作的完成。
第46行中关闭通道的代码非常重要。当通道关闭后，goroutine依旧可以从通道接收数据，
但是不能再向通道里发送数据。能够从已经关闭的通道接收数据这一点非常重要，因为这允许通
道关闭后依旧能取出其中缓冲的全部值，而不会有数据丢失。从一个已经关闭且没有数据的通道
里获取数据，总会立刻返回，并返回一个通道类型的零值。如果在获取通道时还加入了可选的标
志，就能得到通道的状态信息。
在worker函数里，可以在第58行看到一个无限的for循环。在这个循环里，会处理所有
接收到的工作。每个goroutine都会在第60行阻塞，等待从通道里接收新的工作。一旦接收到返
回，就会检查ok标志，看通道是否已经清空而且关闭。如果ok的值是false，goroutine就会
终止，并调用第56行通过defer声明的Done函数，通知main有工作结束。
如果ok 标志是true，表示接收到的值是有效的。第71 行和第72 行模拟了处理的工作。
一旦工作完成，goroutine会再次阻塞在第60行从通道获取数据的语句。一旦通道被关闭，这个
从通道获取数据的语句会立刻返回，goroutine也会终止自己。
有缓冲的通道和无缓冲的通道的例子很好地展示了如何编写使用通道的代码。在下一章，我
们会介绍真实世界里的一些可能会在工程里用到的并发模式。
6.6 小结
并发是指goroutine运行的时候是相互独立的。
使用关键字go创建goroutine来运行函数。
goroutine在逻辑处理器上执行，而逻辑处理器具有独立的系统线程和运行队列。
竞争状态是指两个或者多个goroutine试图访问同一个资源。
原子函数和互斥锁提供了一种防止出现竞争状态的办法。
通道提供了一种在两个goroutine之间共享数据的简单方法。
无缓冲的通道保证同时交换数据，而有缓冲的通道不做这种保证。
7
第 7 章 并发模式
第7章 并发模式
本章主要内容
 控制程序的生命周期
 管理可复用的资源池
 创建可以处理任务的goroutine池
在第6章中，我们学习了什么是并发，通道是如何工作的，并学习了可以实际工作的并发代
码。本章将通过学习更多代码来扩展这些知识。我们会学习3个可以在实际工程里使用的包，这
3个包分别实现了不同的并发模式。每个包从一个实用的视角来讲解如何使用并发和通道。我们
会学习如何用这个包简化并发程序的编写，以及为什么能简化的原因。
7.1 runner
runner包用于展示如何使用通道来监视程序的执行时间，如果程序运行时间太长，也可以
用runner包来终止程序。当开发需要调度后台处理任务的程序的时候，这种模式会很有用。这
个程序可能会作为cron作业执行，或者在基于定时任务的云环境（如iron.io）里执行。
让我们来看一下runner包里的runner.go代码文件，如代码清单7-1所示。
代码清单7-1 runner/runner.go
01 // Gabriel Aszalos协助完成了这个示例
02 // runner包管理处理任务的运行和生命周期
03 package runner
04
05 import (
06 "errors"
07 "os"
08 "os/signal"
09 "time"
10 )
11
12 // Runner在给定的超时时间内执行一组任务，
13 // 并且在操作系统发送中断信号时结束这些任务
14 type Runner struct {