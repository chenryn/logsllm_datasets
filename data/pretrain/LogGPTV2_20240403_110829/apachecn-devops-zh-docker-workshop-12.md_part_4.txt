6     environment:
7       var: "--cpu 2 --vm 6 --timeout 20"
8     deploy:
9       resources:
10         limits:
11           cpus: '2'
12           memory: 256M
```
尽管我们只是触及了这个主题，但是前面介绍资源使用的部分应该会指导您如何在`docker-compose.yml`文件中分配资源。关于 Docker 容器的资源使用，这一节到此结束。从这里开始，我们将继续关注创建我们的`Dockerfiles`的最佳实践，以及我们如何开始使用不同的应用来确保我们遵守这些最佳实践。
# Docker 的最佳实践
随着我们的容器和服务的规模和复杂性的增长，确保我们在创建 Docker 映像时遵循最佳实践是非常重要的。我们在 Docker 映像上运行的应用也是如此。在本章的后面，我们将查看 lint 我们的`Dockerfiles`和`docker-compose.yml`文件，它们将分析我们的文件中的错误和最佳实践，这将让您有更清晰的理解。与此同时，让我们来看看在创建 Docker 映像时需要记住的一些更重要的最佳实践，以及应用应该如何使用它们。
注意
本章可能会涵盖前几章中的一些要点，但我们将能够为您提供更多的信息，并明确我们为什么要使用这些实践。
在下一节中，我们将介绍一些在创建服务和容器时应该遵循的更常见的最佳实践。
## 每个容器运行一项服务
在现代微服务架构中，我们需要记住每个容器中只应该安装一个服务。容器的主要过程由`Dockerfile`末尾的`ENTRYPOINT`或`CMD`指令设定。
您在容器中安装的服务可以非常容易地运行多个进程，但是为了获得 Docker 和微服务的全部好处，您应该只在每个容器中运行一个服务。为了进一步细分这一点，您的容器应该只有一个单一的职责，如果它负责做一件以上的事情，那么它应该被分解成不同的服务。
通过限制每个容器可以做什么，我们有效地减少了映像使用的资源，并潜在地减少了映像的大小。正如我们在上一章中所看到的，这也将减少攻击者在访问运行中的容器时执行任何不该执行的操作的机会。这也意味着，如果容器由于某种原因停止工作，对环境中运行的其他应用的影响有限，服务将更容易恢复。
## 基础映像
当我们从容器的基础映像开始时，我们需要做的第一件事就是确保我们从最新的映像开始。也做一点调查，以确保您没有使用安装了大量不需要的额外应用的映像。您可能会发现，应用使用的特定语言或特定焦点支持的基本映像会限制所需映像的大小，从而限制您在创建映像时需要安装的内容。
这就是为什么我们使用 PostgreSQL 支持的 Docker 映像，而不是在构建时在映像上安装应用。PostgreSQL 支持的映像确保了它的安全性和在最新版本下的运行，并确保我们没有在不需要的映像上运行应用。
当为我们的`Dockerfile`指定我们的基础映像时，我们需要确保我们也指定了一个特定的版本，而不是让 Docker 简单地使用`latest`映像。此外，请确保您不是从信誉良好或受信任的提供商的存储库或注册表中提取映像。
如果您使用 Docker 已经有一段时间了，您可能会遇到`MAINTAINER`指令，在该指令中您指定生成映像的作者。这已经被否决了，但是您仍然可以使用`LABEL`指令来提供这些细节，正如我们在下面的语法中所做的那样:
```
LABEL maintainer="PI:EMAIL"
```
## 安装应用和语言
当您在映像上安装应用时，请始终记住不需要执行`apt-get update`或`dist-upgrade`。如果需要以这种方式升级映像版本，您应该查看不同的映像。如果您使用`apt-get`或`apk`安装应用，请确保指定您需要的特定版本，因为您不想安装新的或未经测试的版本。
安装软件包时，确保使用`-y`开关确保构建不会停止并要求用户提示。或者，您也应该使用`--no-install-recommends`，因为您不想安装软件包管理器推荐的大量不需要的应用。此外，如果您使用基于 Debian 的容器，请确保您使用的是`apt-get`或`apt-cache`，因为`apt`命令是专门为用户交互而不是脚本安装而设计的。
如果您从其他表单安装应用，例如从代码构建应用，请确保您正在清理安装文件，以再次减小您正在创建的映像的大小。同样，如果您正在使用`apt-get`，您也应该删除`/var/lib/apt/lists/`中的列表，以清理安装文件并减小容器映像的大小。
## 运行命令和执行任务
在创建我们的映像时，我们通常需要在`Dockerfile`内执行一些任务，以便为我们的服务运行准备好环境。务必确保您没有使用`sudo`命令，因为这可能会导致一些意想不到的结果。如果您需要以 root 用户身份运行命令，那么您的基本映像很可能以 root 用户身份运行；只需确保您创建了一个单独的用户来运行您的应用和服务，并且容器在完成构建之前已经更改为所需的用户。
确保您正在使用`WORKDIR`移动到不同的目录，而不是运行指定长路径的指令，因为这对用户来说可能很难阅读。对`CMD`和`ENTRYPOINT`参数使用`JSON`符号，并始终确保您只有一个`CMD`或`ENTRYPOINT`指令。
## 容器需要是不可变和无状态的
我们需要确保我们的容器和运行在容器上的服务是不可变的。我们不能像对待传统的服务器一样对待容器，尤其是一个在运行的容器上更新应用的服务器。您应该能够从代码中更新您的容器并部署它，而完全不需要访问它。
当我们说不可变时，我们指的是容器在其生命周期内根本不会被修改，没有更新、补丁或配置更改。对代码或更新的任何更改都应该通过构建新的映像，然后将其部署到您的环境中来实现。这使得部署更加安全，就好像升级有任何问题，只需重新部署旧版本的映像。这也意味着您在所有环境中运行相同的映像，确保您的环境尽可能相同。
当我们谈论需要无状态的容器时，这意味着运行容器所需的任何数据都应该在容器之外运行。文件存储也应该在容器之外，可能在云存储上或使用装载的卷。从容器中移除数据意味着容器可以随时干净地关闭和销毁，而不用担心数据丢失。当创建一个新容器来替换旧容器时，它只需连接到原始数据存储。
## 将应用设计为高度可用和可扩展
在微服务架构中使用容器旨在允许您的应用扩展到多个实例。因此，当在 Docker 容器上开发应用时，您应该预料到可能会出现应用的许多实例可以同时部署的情况，需要时可以上下扩展。当容器上的负载超过正常水平时，您的服务运行和完成应该也没有问题。
当您的服务因请求增加而需要扩展时，您的应用需要启动多长时间就成了一个重要问题。在将您的服务部署到生产环境中之前，您需要确保启动时间很快，以确保系统能够更高效地扩展，而不会给您的用户带来任何服务延迟。为了确保您的服务符合行业最佳实践，您的服务应该在 10 秒内启动，但少于 20 秒也是可以接受的。
正如我们在上一节中看到的，改善应用启动时间不仅仅是提供更多的 CPU 和内存资源。我们需要确保容器上的应用高效运行，同样，如果它们启动和运行特定进程的时间太长，您可能会在一个应用中执行太多任务。
## 映像和容器需要适当标记
我们在*第 3 章*、*管理您的 Docker Images* 中详细介绍了这个主题，并明确表示我们需要考虑如何命名和标记映像，尤其是当我们开始与更大的开发团队合作时。为了让所有用户都能够理解映像的作用，并了解环境中部署了什么版本，在团队开始大部分工作之前，需要决定并商定相关的标记和命名策略。
映像和容器名称需要与它们运行的应用相关，因为不明确的名称会导致混淆。还必须为版本控制制定一个一致的标准，以确保任何用户都可以识别在特定环境中运行的版本以及最新和稳定的版本。正如我们在*第 3 章*、*管理您的 Docker 映像*中提到的，尽量不要使用`latest`，而是选择语义版本系统或 Git 存储库`commit`哈希，用户可以在其中参考文档或构建环境，以确保他们拥有映像的最新版本。
## 配置和机密
环境变量和机密永远不应该被构建到你的 Docker 映像中。这样做，你就违反了可重用映像的规则。使用您的机密凭据构建映像也是一个安全风险，因为它们将存储在其中一个映像层中，因此任何能够提取映像的人都将能够看到凭据。
为您的应用设置配置时，可能需要根据不同的环境进行更改，因此一定要记住，您需要能够在需要时动态更改这些配置。这可能包括应用所用语言的特定配置，甚至包括应用需要连接的数据库。我们之前提到，如果您将应用配置为`Dockerfile`的一部分，那么这将很难更改，您可能需要为您希望将映像部署到的每个环境创建一个特定的`Dockerfile`。
配置您的映像的一种方法，正如我们在`docker-stress`映像中看到的，是在运行映像时使用命令行上设置的环境变量。如果没有提供变量，入口点或命令应该包含默认值。这将意味着即使没有提供额外的变量，容器仍将启动并运行:
```
docker run -e var="" 
```
通过这样做，我们使我们的配置更加动态，但是当您有更大或更复杂的配置时，这可能会限制您的配置。环境变量可以很容易地从`docker run`命令转移到`docker-compose`命令，然后在 Swarm 或 Kubernetes 中使用。
对于较大的配置，您可能希望通过 Docker 卷装载配置文件。这意味着您将能够设置一个配置文件，并在您的系统上运行它来轻松测试，然后如果您需要转移到一个编排系统，如 Kubernetes 或 Swarm，或者外部配置管理解决方案，您将能够轻松地将其转换为配置图。
如果我们想用我们在本章中使用的`docker-stress`映像来实现这一点，可以修改它以使用配置文件来装载我们想要运行的值。在下面的例子中，我们修改了`Dockerfile`来设置*第 3 行*来运行一个脚本，该脚本将为我们运行`stress`命令:
```
1 FROM ubuntu
2 RUN apt-get update && apt-get install stress
3 CMD ["sh","/tmp/stress_test.sh"]
```
这意味着我们可以构建 Docker 映像，并随时准备好供我们使用。我们只需要一个安装在`/tmp`目录下运行的脚本。我们可以使用以下示例:
```
1 #!/bin/bash
2 
3 /usr/bin/stress --cpu 8 --timeout 20 --vm 6 --timeout 60
```
这说明了将我们的值从环境变量移动到文件的想法。为了同时运行容器和压力应用，我们将执行以下操作，要知道如果我们想要更改`stress`命令所使用的变量，我们只需要对正在装载的文件进行一个小的更改:
```
docker run --rm -it -v ${PWD}/stress_test.sh:/tmp/stress_test.sh docker-stress
```
注意
当您通读这份最佳实践清单时，您会想到的第一件事是，我们在很多方面都与此背道而驰，但请记住，我们在很多情况下都是这样做的，以展示一个过程或想法。
## 使您的映像最小化和小型化
*第 3 章*、*管理你的 Docker 映像*，也看到我们做了一些工作，使我们的映像尽可能小。我们看到，通过缩小映像的大小，可以更快地构建映像。然后，它们也可以被拉得更快，并在我们的系统上运行。安装在容器上的任何不必要的软件或应用都可能占用主机系统上的额外空间和资源，并可能因此降低我们的服务速度。
使用像我们在*第 11 章*、 *Docker Security* 中使用的 Anchore Engine 这样的应用表明，我们可以审核映像以查看其内容，以及安装在其上的应用。这是一个简单的方法来确保我们正在减少我们的映像尺寸，并使它们尽可能最小。
现在，您已经了解了应该在容器映像和服务中使用的最佳实践。本章的下一节将帮助您通过使用应用来验证您的`Dockerfiles`和`docker-compose.yml`是按其应有的方式创建的，从而实现其中的一些最佳实践。
# 在代码中实现 Docker 最佳实践
正如我们在开发应用时希望让我们的编码更容易一样，我们可以使用外部服务和测试来确保我们的 Docker 映像符合最佳实践。在本章的以下部分中，我们将使用三种工具来确保我们的`Dockerfiles`和`docker-compose.yml`文件符合最佳实践，并确保我们在构建 Docker 映像时不会引入潜在的问题。
包含的工具将会简单易用并提供强大的功能。我们将从使用`hadolint`直接在我们的系统上清理`Dockerfiles`开始，该系统将作为一个单独的 Docker 映像运行，我们将`Dockerfiles`输入其中。然后我们来看看`FROM:latest`，这是一个在线服务，提供一些基本的功能来帮助我们找出`Dockerfiles`的问题。最后，我们看一下**Docker Compose Validator**(**DCValidator**)，它将执行类似的功能，但是在这种情况下，我们将整理我们的`docker-compose.yml`文件来帮助查明潜在的问题。
通过在构建和部署映像之前使用这些工具，我们希望减少 Docker 映像的构建时间，减少引入的错误数量，潜在地减少 Docker 映像的大小，并帮助我们了解和实现 Docker 最佳实践。
## 为您的映像使用 Docker Linter
包含本书所有代码的 GitHub 存储库还包括将与构建的 Docker 映像进行比较的测试。另一方面，在构建映像之前，linter 会分析您的代码并寻找潜在的错误。在本章的这一部分，我们将寻找`Dockerfiles`的潜在问题，特别是使用名为`hadolint`的应用。
名称`hadolint`是 **Haskell Dockerfile Linter** 的缩写，自带 Docker 镜像，可以拉取镜像后将`Dockerfile`发送到运行镜像进行测试。即使你的`Dockerfile`相对较小，构建和运行没有任何问题，`hadolint`通常会提供很多建议，指出你的`Dockerfile`中的缺陷，以及未来可能出现的问题。
要在您的`Dockerfiles`上运行`hadolint`，您需要在系统上有`hadolint` Docker 映像。如您现在所知，这只是运行带有所需映像的名称和存储库的`docker pull`命令的问题。在这种情况下，存储库和映像都被称为`hadolint`:
```
docker pull hadolint/hadolint
```
要使用该应用，您只需运行`hadolint`映像，并使用小于(` - < Dockerfile
```
如果您需要忽略一些警告，那么在命令行中尝试实现这一点可能会有点复杂，因此`hadolint`也可以选择设置一个配置文件。`hadolint`配置文件仅限于忽略警告和提供可信存储库列表。您还可以设置一个配置文件，其中以 YAML 格式列出您忽略的警告列表。`hadolint`然后需要将此文件装载到运行的映像上，以便应用使用，因为它将在应用的主目录中查找`.hadolint.yml`配置文件位置: