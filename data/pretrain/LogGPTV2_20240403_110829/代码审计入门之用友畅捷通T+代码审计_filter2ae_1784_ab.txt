我们假设攻击者上传了一个用来生成恶意shell的文件，在上传完成并删除它的间隙，攻击者通过不断地发起访问请求的方法访问了该文件，该文件就会被执行，并且在服务器上生成一个恶意shell的文件。至此，该文件的任务就已全部完成，至于后面把它删除的问题都已经不重要了，因为攻击者已经成功的在服务器中植入了一个shell文件，后续的一切就都不是问题了。
实际利用过程：
先构造一个上传，然后通过burp重复发包，线程调高一点。
构造页面如下：
    Filename:
上传包如下：
请求包如下，X参数为我们写入的内容。
只要速度够快，就能赶在删除文件之前生成shell
因为整套源码都是已经预编译好的，无法使用ASPX脚本来生成shell（这里踩了很多坑），所以我们这里用的是ASP代码来生成的一句话。代码如下：
由上述过程我们可以看到这种“关门打狗”的处理逻辑在并发的情况下是十分危险的，极易导致条件竞争漏洞的发生。
## 0x03:管理员密码任意重置漏洞
继续观察名单，我发现存在一个recoverpassword.aspx页面，根据命名可以看出这是一个重置密码的页面。我们跟进看看是否存在漏洞。先看Page_Load怎么写的。这里只有一行代码，通过RegisterTypeForAjax注册类信息到前台页面。RecoverPassword就是要调用的类名，一般都是指页面地址。相当于通过前台JS调用后台方法。那么继续往下看
在135行-149之间的SetNewPwd函数，我们可以很明显的看出这是一个重置密码的操作请求。从逻辑上看pwdNew经过encode之后进入到RecoverSystemPassword
我们继续跟进看看。
这里直接就执行sql语句更新管理员密码了，并没有做其他的校验。很明显我们可以通过ajax调用SetNewPwd函数来修改管理员密码。
找到调用地址，查看构造方法
通过burp直接POST数据即可重置管理员密码
## 0x04:SQL注入漏洞
从上一个漏洞我们可以看出开发者貌似很喜欢拼接SQL语句，那么这种随意的拼接行为必然会在某处导致SQL注入。我们全局搜索一下（说是全局搜索，其实也就是在业务系统寻找一些请求，然后跟进查看代码是怎么处理的，即黑盒测试）。这里我们在某个类库找到了一个函数，我们来看看开发人员是怎么写的。
第一行没啥说的，我们看第二行，这里scheduleName交给了GetScheduleLog处理，我们继续跟踪GetScheduleLog，可以看到serviceName通过Format()方法直接拼接到SQL语句当中去了。然后后面直接就query了。很明显这里存在注入，我们回过头来看看GetScheduleLogList这个函数是怎
么调用，scheduleName是否可控。
如图所示，从18行开始，我们看代码，这里定义好命名空间以后，通过AjaxNamespace修改命名空间名称，然后在函数前面添加AjaxMethod
关键字，通过查阅资料可以得知。使用AjaxMethod可以在客户端异步调用服务端方法，简单地说就是在JS里调用后台文件里的方法，做一些JS
无法做到的操作，如查询数据库等。那么上面的问题就迎刃而解了，我们通过构造http请求直接调用GetScheduleLogList传入内容即可注入。
构造地址：
POST:
{“scheduleName”:”DatabaseConsolidationTask”}
同理，我发现多处存在原理相同的漏洞，这里我列举几点，就不赘述了。
在这里除了SQL注入以外还存在一个问题，那就是未授权访问，我们放在下面单独讲。
## 0x05:接口未授权访问
这里本来是想接着SQL注入继续写的，但是想想似乎可以单独列举出来，于是我们就来单独分析一下。回到0x02，我们继续分析global中的Application.PreRequestHandlerExecute
事件。
通过分析149-186行代码，我们可以很明显的看出这段代码是用来鉴权的，判断用户是否登录。逻辑上并没有什么问题。之前我们说到global是作用全局的，但是凡事都有例外，这里的例外指的就是我们从0x04发现的类库，类库是不收到
global的影响的，这是由类库本身的性质决定的。因为类库为方法的集合。方法只能被调用，并不能通过其他方式直接访问，性质是不可访问响应，而Global的作用就是控制全局响应，这里自然无法产生影响。
这里我抽出一个具体案例分析。还是和0x04一样，我们以GetDefaultBackPath()方法为例，可以看出该方法前面添加了ajaxmethod，这里就代表了这是一个ajax的方法接口，变成可访问的控制器。
我们刚刚说到global是作用全局的。当类库里的方法变成接口以后，性质从不可访问响应变成可访问响应时，就会受到其影响，但这里开发者在使用ajaxmethod却忘记使用session。常规的做法应该是使用
[Ajax.AjaxMethod(HttpSessionStateRequirement.Read)]
。然后在方法内部进行权限的判断。所以总得来看还是开发者没有正确的使用ajaxmethod有关。
如图，直接构造方法即可调用接口，前面的注入漏洞也是如此。
## 0x06:任意文件下载
我们继续看代码，发现一个疑似提供下载功能的页面。打开来看看
打开命名空间，我们来看看实现代码
我们来看Page_Load函数，首先接收path参数，对内容进行URL解码。然后截取字符串。判断text中是否存在“_”。然后设置HttpResponseBase
类的一些属性值。最后将将指定文件的内容作为文件块写入 HTTP 响应输出流。整个流程没有对Path进行任何的过滤和检查，最后导致任意文件下载。
直接构造路径下载web.config:
注：该请求需要登录，原因上面已经讲到。
## 0x07:总结
纵观整套源码，我们可以发现，常规的用户交互操作都是存在登录校验的。但是开发者却忽略了Ajaxpro这种程序调用接口的安全校验。其实在大多数系统中也存在类似的问题，整套系统存在问题的点还是非常之多的。本文只选取了部分较为明显的点进行分析撰述，并未对该套源码进行全面分析。各位小伙伴感兴趣可以深入研究一下。个人感觉ASP.NET的语法思想和JAVA其实是很相似的。在审计过程中也学习到了很多知识和一些有趣的开发思想，受益匪浅。本文拙劣，行文不当之处希望各位大佬指正谅解。