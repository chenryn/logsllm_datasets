# 第一章：可靠性、可伸缩性和可维护性
![](../img/ch1.png)
> 网际网路做得太棒了，以至于大多数人将它看作像太平洋这样的自然资源，而不是什么人工产物。上一次出现这种大规模且无差错的技术，你还记得是什么时候吗？
>
> —— [艾伦・凯](http://www.drdobbs.com/architecture-and-design/interview-with-alan-kay/240003442) 在接受 Dobb 博士杂志采访时说（2012 年）
-----------------------
[TOC]
现今很多应用程式都是 **资料密集型（data-intensive）** 的，而非 **计算密集型（compute-intensive）** 的。因此 CPU 很少成为这类应用的瓶颈，更大的问题通常来自资料量、资料复杂性、以及资料的变更速度。
资料密集型应用通常由标准组件构建而成，标准组件提供了很多通用的功能；例如，许多应用程式都需要：
 - 储存资料，以便自己或其他应用程式之后能再次找到 （*资料库，即 databases*）
 - 记住开销昂贵操作的结果，加快读取速度（*快取，即 caches*）
 - 允许使用者按关键字搜寻资料，或以各种方式对资料进行过滤（*搜寻索引，即 search indexes*）
 - 向其他程序传送讯息，进行非同步处理（*流处理，即 stream processing*）
 - 定期处理累积的大批次资料（*批处理，即 batch processing*）
如果这些功能听上去平淡无奇，那是因为这些 **资料系统（data system）** 是非常成功的抽象：我们一直不假思索地使用它们并习以为常。绝大多数工程师不会幻想从零开始编写储存引擎，因为在开发应用时，资料库已经是足够完美的工具了。
但现实没有这么简单。不同的应用有著不同的需求，因而资料库系统也是百花齐放，有著各式各样的特性。实现快取有很多种手段，建立搜寻索引也有好几种方法，诸如此类。因此在开发应用前，我们依然有必要先弄清楚最适合手头工作的工具和方法。而且当单个工具解决不了你的问题时，组合使用这些工具可能还是有些难度的。
本书将是一趟关于资料系统原理、实践与应用的旅程，并讲述了设计资料密集型应用的方法。我们将探索不同工具之间的共性与特性，以及各自的实现原理。
本章将从我们所要实现的基础目标开始：可靠、可伸缩、可维护的资料系统。我们将澄清这些词语的含义，概述考量这些目标的方法。并回顾一些后续章节所需的基础知识。在接下来的章节中我们将抽丝剥茧，研究设计资料密集型应用时可能遇到的设计决策。
## 关于资料系统的思考
我们通常认为，资料库、讯息伫列、快取等工具分属于几个差异显著的类别。虽然资料库和讯息队列表面上有一些相似性 —— 它们都会储存一段时间的资料 —— 但它们有迥然不同的访问模式，这意味著迥异的效能特征和实现手段。
那我们为什么要把这些东西放在 **资料系统（data system）** 的总称之下混为一谈呢？
近些年来，出现了许多新的资料储存工具与资料处理工具。它们针对不同应用场景进行最佳化，因此不再适合生硬地归入传统类别【1】。类别之间的界限变得越来越模糊，例如：资料储存可以被当成讯息伫列用（Redis），讯息伫列则带有类似资料库的持久保证（Apache Kafka）。
其次，越来越多的应用程式有著各种严格而广泛的要求，单个工具不足以满足所有的资料处理和储存需求。取而代之的是，总体工作被拆分成一系列能被单个工具高效完成的任务，并透过应用程式码将它们缝合起来。
例如，如果将快取（应用管理的快取层，Memcached 或同类产品）和全文搜寻（全文搜寻伺服器，例如 Elasticsearch 或 Solr）功能从主资料库剥离出来，那么使快取 / 索引与主资料库保持同步通常是应用程式码的责任。[图 1-1](../img/fig1-1.png) 给出了这种架构可能的样子（细节将在后面的章节中详细介绍）。
![](../img/fig1-1.png)
**图 1-1 一个可能的组合使用多个元件的资料系统架构**
当你将多个工具组合在一起提供服务时，服务的介面或 **应用程式程式设计介面（API, Application Programming Interface）** 通常向客户端隐藏这些实现细节。现在，你基本上已经使用较小的通用元件建立了一个全新的、专用的资料系统。这个新的复合资料系统可能会提供特定的保证，例如：快取在写入时会作废或更新，以便外部客户端获取一致的结果。现在你不仅是应用程式开发人员，还是资料系统设计人员了。
设计资料系统或服务时可能会遇到很多棘手的问题，例如：当系统出问题时，如何确保资料的正确性和完整性？当部分系统退化降级时，如何为客户提供始终如一的良好效能？当负载增加时，如何扩容应对？什么样的 API 才是好的 API？
影响资料系统设计的因素很多，包括参与人员的技能和经验、历史遗留问题、系统路径依赖、交付时限、公司的风险容忍度、监管约束等，这些因素都需要具体问题具体分析。
本书著重讨论三个在大多数软体系统中都很重要的问题：
* 可靠性（Reliability）
  系统在 **困境**（adversity，比如硬体故障、软体故障、人为错误）中仍可正常工作（正确完成功能，并能达到期望的效能水准）。请参阅 “[可靠性](#可靠性)”。
* 可伸缩性（Scalability）
  有合理的办法应对系统的增长（资料量、流量、复杂性）。请参阅 “[可伸缩性](#可伸缩性)”。
* 可维护性（Maintainability）
  许多不同的人（工程师、运维）在不同的生命周期，都能高效地在系统上工作（使系统保持现有行为，并适应新的应用场景）。请参阅 “[可维护性](#可维护性)”。
人们经常追求这些词汇，却没有清楚理解它们到底意味著什么。为了工程的严谨性，本章的剩余部分将探讨可靠性、可伸缩性和可维护性的含义。为实现这些目标而使用的各种技术，架构和演算法将在后续的章节中研究。