securely realize Frand, as malicious parties may cheat and cause
the resulting sharing to be incorrect. However, by adding a step
at the (cid:27)nal stage of the protocol, where the shares are checked for
correctness using Protocol 3.1, we obtain a protocol that securely
computes Frand (note that since Frand itself is called in Protocol 3.1
to generate a random sharing [r], we cannot use the protocol as
is. However, by Lemma 2.4, we have that the cheating probability
|F|−1 even if [r] is not a correct
1
in Protocol 3.1 is still at most
sharing. Thus, for the use of Protocol 3.1 here, we can remove the
calls to Frand by taking one of the random shares generated by the
vandermonde protocol as the “masking" share). This can be easily
proven via straight-forward simulation where the simulator plays
the honest parties by following the protocol instructions. Since no
private inputs are involved, the view of the adversary in the real
execution is identically distributed to its view in the simulation. At
the end of the simulation, if the correctness check of shares was
successful, the simulator can use the shares it holds to compute
the corrupted parties’ shares (since an honest majority is assumed)
and sends them to the trusted party as required by the de(cid:27)nition of
Frand.
πmult – semi-honest multiplication that is private and secure up
to additive attack. The (cid:27)rst instantiation for πmult is the GRR mul-
tiplication improvement [25] of the BGW protocol [7]. This pro-
tocol enables n parties with t  2−σ we can set δ = 1. In this case,
referring to Eq. (9), we obtain that the overall communication cost
is 5(n − 1) (cid:27)eld elements sent by each party for each multiplication
gate (due to 2 semi-honest multiplications and 3 openings). This
therefore proves Theorem 1.2 from the Introduction.
A protocol for a large number of parties. When considering a
large number of parties, the PRSS protocol cannot be used (since
the computational cost of the PRSS protocol blows up exponen-
tially). We therefore use the “Vandermonde” protocol for generating
random shares. Likewise, we use the optimized DN [17] protocol for
semi-honest multiplication and the second version of our protocol
(which is based on semi-honest multiplications). For large (cid:27)elds,
where we can set δ = 1, we obtain that by Eq. (10), each party needs
to send 42 elements per multiplication gate (due to 6 semi-honest
multiplications at a cost of 6 elements each, and 3 random share
generations at a cost of 2 elements each). This therefore proves
Theorem 1.1 from the Introduction.
The threshold. Based on the above, when 5(n − 1)  9. This theoretical analysis is validated
experimentally in Section 7 and con(cid:27)rms this exactly. In Table 1,
the protocol labeled PRSS_GRR_open is the (cid:27)rst protocol, whereas
van_DN_mult is the last protocol. As can be seen, PRSS_GRR_open
is better than van_DN_mult for up to 9 parties. As shown in Sec-
tion 7, other protocol variants are however better between 9 and
70 parties.
6.2 Three-Party Computation Based on
Replicated Secret Sharing
In [3], a three-party protocol based on a type of replicated secret
sharing was presented, in which each party sends a single (cid:27)eld
element per multiplication gate. In this section, we instantiate our
protocol compiler with the semi-honest protocol of [3] (for arith-
metic circuits) to obtain a highly e(cid:28)cient protocol with security in
the presence of a malicious adversary corrupting at most 1 party.
We stress that protocols that require that less than 1/3 of the parties
are corrupted cannot be used at all for the case of 3 parties.
We begin by presenting the replicated secret-sharing scheme,
prove some properties of it, and characterize correctness. Our repli-
cated secret-sharing is a simpli(cid:27)ed version of that presented in [3],
and the multiplication protocol has the same complexity as theirs.
We also show how to optimize Protocol 4.2 even further in this
speci(cid:27)c case.
We stress that for Boolean circuits (i.e., the (cid:27)eld F2), a malicious
version for the semi-honest protocol of [3], was already presented
in [19]. However, our construction for large (cid:27)elds is fundamentally
di(cid:29)erent from theirs, as it is tailored for large (cid:27)elds.
6.2.1 The Secret Sharing Scheme and Its Properties.
Replicated secret-sharing. In order to share an element v ∈ F,
the dealer chooses three random elements r1, r2, r3 ∈ F under the
constraint that r1 + r2 + r3 = v. Then, the dealer shares the secret
so that P1’s share is (r1, r3), P2’s share is (r2, r1) and P3’s share
is (r3, r2). We abuse notation and denote Pi’s share by (ri , ri−1),
even for i = 1. It is easy to see that this is a valid secret sharing
scheme that preserves privacy. In addition, the secret together with
the share of any one party fully determines the shares of the other
parties. We use [v] to denote a sharing of v according to this scheme.
1
i
+ r
2
i , r
1
i , r
1
i−1 + r
• Addition [v1] + [v2]: Given a share (r
i−1).
2
Linearity. We de(cid:27)ne the following local operations on shares:
i−1) of v1 and a share
1
(r
i−1) of v2, the sum of the shares is obtained by each party
2
2
i , r
Pi computing: (r
i−1) of v and
• Multiplication by a scalar σ ·[v]: Given a share (r
1
a value σ ∈ F, each party Pi computes (σ · ri , σ · ri−1).
• Addition of a scalar [v] + σ: Given a share (ri , ri−1) of v and a
value σ ∈ F, party P1 computes (r1 + σ, r3), party P2 computes
(r2, r1 + σ), and party P3 leaves its share as is.
Note that when writing [v1] +[v2] the symbol ‘’+” is an operator
on shares and not addition of two numbers, whereas when we
write v1 +v2 the symbol ‘’+” is addition in the (cid:27)eld; likewise for the
product notation. The following claim states that these operators
are correct, and is straightforward to prove.
1
i , r
Claim 6.1. Let [v1],[v2] be shares and let σ ∈ F be a scalar. Then:
(1) [v1] + [v2] = [v1 + v2],
(2) σ · [v1] = [σ · v1], and
(3) [v1] + σ = [v1 + σ].
Correctness. In the three parties setting, it is not possible to have
shares that are value-inconsistent, since there is only one ever
subset of t +1 honest parties. However, the sharing might be invalid.
This is the exact opposite situation to Shamir shares which are
always valid but may be value-inconsistent when n > 3.
It will be useful to characterize the correctness of shares in this
case. Consider the case that P1 is corrupted. Then, P2 is supposed
to hold (r2, r1) and P3 is supposed to hold (r3, r2). Thus, the sharing
is valid (and thus correct) if and only if the (cid:27)rst element held by P2
equals the second element held by P3. In general:
Claim 6.2. Let (r1, s1),(r2, s2) and (r3, s3) be the shares held by
parties P1, P2 and P3, respectively, and let Pi be the corrupted party.
Then, the shares are correct if and only if ri +1 = si +2.
6.2.2 Basic Building Blocks and Sub-Protocols.
Frand - Generating shares of random values. The parties can gen-
erate shares of random values non-interactively in the following
way. Let Fk(·) be a pseudorandom function. Then:
• Initialization: Each party Pi chooses a random key ki and sends
it to Pi +1. Each party initializes a counter id = 0.
• Share generation: Upon each request to generate a sharing, each
party Pi holding two keys ki and ki−1 sets id = id + 1 and
computes ri−1 = Fki−1(id) and ri = Fki(id). Then, Pi outputs the
share (ri , ri−1).
Note that the random sharing output from the protocol is guar-
anteed to be correct, since the protocol requires no communication.
It is not di(cid:28)cult to show that this protocol securely realizes Frand.
πmult – Semi-Honest Multiplication Protocol. We describe the
multiplication protocol in which each party sends only one (cid:27)eld
element. Let (r1, r3), (r2, r1), (r3, r2) be a secret sharing of v1, and let
(s1, s3), (s2, s1),(s3, s2) be a secret sharing of v2. We assume that the
parties P1, P2, P3 hold correlated randomness α1, α2, α3, respectively,
where α1 + α2 + α3 = 0. The parties compute shares of v1 · v2 as
follows:
(1) Step 1 – compute(cid:0)3
(2) Step 2 – compute(cid:0)3
Observe that t1 +t2 +t3 =i =3
v1 · v2, where the equality follows since3
3(cid:1)-sharing: Each party Pi computes ti =
2(cid:1)-sharing: Party Pi computed ti and re-
i =1(risi +risi−1 +ri−1si)+i =3
risi + risi−1 + ri−1si + αi and sends it to Pi +1. These messages
are computed and sent in parallel.
ceived ti−1 from Pi−1; party Pi outputs (ti , ti−1) as its share on
the output wire. (If Pi received ti−1 (cid:60) F then it sets ti−1 to a
default element in F.)
i =1 αi =
i =1 αi = 0 and v1 · v2 =
(r1 + r2 + r3)(s1 + s2 + s3). Thus, when the parties are honest, the
obtained sharing is a correct sharing of v1 · v2. In addition, the
protocol achieves privacy in the presence of a malicious adversary
according to De(cid:27)nition 2.5, as the adversary’s view consists of one
element that looks random, due to the fact that it is masked using
a random element αi. We now show that the above multiplication