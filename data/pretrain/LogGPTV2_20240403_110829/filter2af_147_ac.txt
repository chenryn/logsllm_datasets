           q.sendline(msg)
           y = q.recv(1024).decode('hex')
           q.close()
           if y[80:96] == enc_msg[128:144]:
               flag += chr(i)
               break
    print(flag)
flag:`picoCTF{@g3nt6_1$_th3_c00l3$t_2432504}`
# Super Safe RSA
## Question
> Dr. Xernon made the mistake of rolling his own crypto.. Can you find the bug
> and decrypt the message? Connect with `nc 2018shell1.picoctf.com 6262`.
### Hint
> Just try the first thing that comes to mind.
## Solution
看一下信息：
    c: 6075087024476414532659138701716437603217113412924927299863787548188620337158625
    n: 16995743251555690273217604748218275023627813110906708466533535245776011465591891
    e: 65537
`n`很小，总共才80位，可以使用爆破的方式解出`p`和`q`  
。[在线工具](https://www.alpertron.com.ar/ECM.HTM)  
。
得到结果：
    p = 166402962209062256362900394698423820317
    q = 102136061918194068640310910627905419563823
然后就是很简单的rsa解密了。
    from Crypto.Util.number import inverse
    p = 166402962209062256362900394698423820317
    q = 102136061918194068640310910627905419563823
    c = 6075087024476414532659138701716437603217113412924927299863787548188620337158625
    n = 16995743251555690273217604748218275023627813110906708466533535245776011465591891
    e = 65537
    phi = (q-1)*(p-1)
    d = inverse(e, phi)
    print (hex(pow(c,d,n))[2:-1]).decode('hex')
得到flag。
flag:`picoCTF{us3_l@rg3r_pr1m3$_2461}`
# Super Safe RSA 2
## Question
> Wow, he made the exponent really large so the encryption MUST be safe,
> right?! Connect with `nc 2018shell1.picoctf.com 56543`.
### Hint
> What is the usual value for e?
## Solution
nc连接服务器，发现这回`e`的值不小了，但是又变得和`N`差不多大了，还是参考[CTF中RSA的常见攻击方法](https://www.anquanke.com/post/id/84632)，这里存在
**低解密指数攻击** 。
Wiener表示如果满足：
那么一种基于连分数(一个数论当中的问题)的特殊攻击类型就可以危害RSA的安全。此时需要满足：
如果满足上述条件，通过Wiener Attack可以在多项式时间中分解n。
使用开源工具
    '''
    Created on Dec 14, 2011
    @author: pablocelayes
    '''
    import ContinuedFractions, Arithmetic, RSAvulnerableKeyGenerator
    def hack_RSA(e,n):
        '''
        Finds d knowing (e,n)
        applying the Wiener continued fraction attack
        '''
        frac = ContinuedFractions.rational_to_contfrac(e, n)
        convergents = ContinuedFractions.convergents_from_contfrac(frac)
        for (k,d) in convergents:
            #check if d is actually the key
            if k!=0 and (e*d-1)%k == 0:
                phi = (e*d-1)//k
                s = n - phi + 1
                # check if the equation x^2 - s*x + n = 0
                # has integer roots
                discr = s*s - 4*n
                if(discr>=0):
                    t = Arithmetic.is_perfect_square(discr)
                    if t!=-1 and (s+t)%2==0:
                        print("Hacked!")
                        return d
    if __name__ == "__main__":
        print hack_RSA(40276660093351912353325027146420685937733052504816262053896184883506171821807404583368346339215117527771791856465371395445756580309600483928576564180890942975279324690215478497697070066763075254913358736488880708349691537688815542401252154948245178131989398664206152846321309331764046013649756619261071229089, 111583170127578807909192691245137491304582814592836631984536450317481568426014198265987965591526088832329215543505708705754504100598169044438075849117477605468201110960653836265368253728288600909205172996903271308132928634087380939250941030896277683335203499540010766665619316042268962892586456274440478367001)
解得私钥`d`：65537，然后解密：
    from Crypto.Util.number import inverse
    c = 85669272593914592964238296252223602553240367010559050180727431963691933620008524312226679252731896404760784512941433411361850153756503392392692524466402024374178583928667263379044625258718935929469661451158056304059057475244237032774703099421851155804449755624009586256845110664849184621665767806044750594973
    n = 111583170127578807909192691245137491304582814592836631984536450317481568426014198265987965591526088832329215543505708705754504100598169044438075849117477605468201110960653836265368253728288600909205172996903271308132928634087380939250941030896277683335203499540010766665619316042268962892586456274440478367001
    e = 40276660093351912353325027146420685937733052504816262053896184883506171821807404583368346339215117527771791856465371395445756580309600483928576564180890942975279324690215478497697070066763075254913358736488880708349691537688815542401252154948245178131989398664206152846321309331764046013649756619261071229089
    d = 65537
    m = pow(c, d, n)
    print hex(m)[2:-1].decode('hex')
flag:`picoCTF{w@tch_y0ur_Xp0n3nt$_c@r3fu11y_5261983}`
# Super Safe RSA 3
## Question
> The more primes, the safer.. right.?.? Connect with `nc
> 2018shell1.picoctf.com 11423`.
### Hint
> How would you find d if there are more than 2 prime factors of n?
## Solution
这题给我们的数据如下：
    c: 2214959746368961374343866619773680463913808855252144119575578619282028038148568609891198127966225495311682540323131579203618894145626046974546075970616339033486317429461235324910794466410074881752239541146624247745072518241741204968025293372054661473208051944193745386532992238774551013797836031291096741
    n: 5564465787507426784189854287795264081761345977763964262369153883931335062166838686916377911069328789715623668583315372050520387414170383621534793892389463905512682152442890656361180400315699526374103389751180954335677791471685242043876553878553597343813515063304714971565013966010693181624796612216036537
    e: 65537
使用[Alpertron](https://www.alpertron.com.ar/ECM.HTM)分解，`n`可以分解为多个质因子。
解密过程可以参考
脚本如下：
    c = 2214959746368961374343866619773680463913808855252144119575578619282028038148568609891198127966225495311682540323131579203618894145626046974546075970616339033486317429461235324910794466410074881752239541146624247745072518241741204968025293372054661473208051944193745386532992238774551013797836031291096741
    n = 5564465787507426784189854287795264081761345977763964262369153883931335062166838686916377911069328789715623668583315372050520387414170383621534793892389463905512682152442890656361180400315699526374103389751180954335677791471685242043876553878553597343813515063304714971565013966010693181624796612216036537
    e = 65537
    p1 = 2175350609
    p2 = 2182560491
    p3 = 2196605027
    p4 = 2209029391
    p5 = 2466547367
    p6 = 2510616961
    p7 = 2588079563
    p8 = 2704140821
    p9 = 2736762829
    p10 = 2796597043
    p11 = 2809479437
    p12 = 2829659713
    p13 = 2837556643
    p14 = 2858051057
    p15 = 3032087491
    p16 = 3042267581
    p17 = 3063304267
    p18 = 3102491383
    p19 = 3219243151
    p20 = 3284737447
    p21 = 3392021827
    p22 = 3789952469
    p23 = 3812358577
    p24 = 3858988619
    p25 = 3864352469
    p26 = 3877179469
    p27 = 3910354507
    p28 = 3985847791
    p29 = 3990903569
    p30 = 4041031661
    p31 = 4069378073
    p32 = 4203209281
    primes = [p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, \
              p14, p15, p16, p17, p18, p19, p20, p21, p22, p23, p24, p25, \
              p26, p27, p28, p29, p30, p31, p32]
    def egcd(a, b):
        if a == 0:
            return (b, 0, 1)
        else:
            g, y, x = egcd(b % a, a)
            return (g, x - (b // a) * y, y)
    def modinv(a, m):
        g, x, y = egcd(a, m)
        if g != 1:
            raise Exception('modular inverse does not exist')
        else:
            return x % m
    # From https://crypto.stackexchange.com/questions/31109/rsa-enc-decryption-with-multiple-prime-modulus-using-crt
    ts = []
    xs = []
    ds = []
    for i in range(len(primes)):
        ds.append(modinv(e, primes[i]-1))
    m = primes[0]
    for i in range(1, len(primes)):
        ts.append(modinv(m, primes[i]))
        m = m * primes[i]
    for i in range(len(primes)):
        xs.append(pow((c%primes[i]), ds[i], primes[i]))
    x = xs[0]
    m = primes[0]
    for i in range(1, len(primes)):
        x = x + m * ((xs[i] - x % primes[i]) * (ts[i-1] % primes[i]))
        m = m * primes[i]
    print hex(x%n)[2:-1].decode("hex")
flag:`picoCTF{p_&*q_n0_r*$_t!!_6725536}`