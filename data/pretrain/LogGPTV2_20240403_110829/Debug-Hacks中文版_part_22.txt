总结
160】第4章应用程序调试实践
$10 = -7 
(gdb) p idx
6
15
3
0x80483b3 is in main (bufov2.c:18).
(gdb) list *0x080483b3
int main(void)
本hack介绍内存双重释放导致的bug和解决方法。
malloc()和 free()发生故障
文件：行号及那一行包含的函数。
如上所示，在list命令的参数中直接指定地址，就能显示该地址对应的源代码
return EXIT_SUCCESS;
printf("This is a message\n");
my_data[idx+l] = 0x08;
my_data[idx] = 0x0a; 
int idx = calc_index();
www.TopSage.com
一大和一洋
---
## Page 179
来看看效果。
可以查看详细信息。
现在的 glibc 中有个方便的调试标志，可以利用环境变量进行调试。
利用 MALLOC_CHECK_进行调试
否有问题，特别是要仔细确认是否进行了双重释放。
生以下结果。
最危险的情况是：程序可能不会受到内存破坏的影响而继续运行。此时可能会产
另外，这种 malloc()、free()导致 SIGSEGV 的情况其实是运气很好的情况。
不是库函数free()的问题。
部使用的函数_int_free()中，但实际上是使用 free()函数的应用程序的问题，而
从这段backtrace 信息中可见，问题似乎出在执行内存释放的库函数free()及其内
发生SIGSEGV。
误使用引发的 bug，如内存的双重释放、访问分配空间之外内存等 bug。
$ man malloc
#0 ox0000003b4867217c in _int_free () from /lib64/libc.s0.6
# 0x000003b4867217c in _int_free () from /Lib64/Libc.s50.6
Program terminated with signal ll, Segmentation fault.
Core was generated by `./membug'
 $ gdb ./membug -c core
#3
#1
(gdb)bt
使用被破坏的数据进行计算，产生错误的结果。
会在完全没关系的地方产生 SIGSEGV。
 argv=) at membug.c:39
0x000000000400588 in main (argc=;
0x0000000000400534 in do_free () at membug.c:30
0x0000003b48675f2c in free () from /lib64/libc.so.6
www.TopSage.com
HACK#30 malloc()和 free()发生故障] 161
168
---
## Page 180
170
169
但也要知道，该方法并不适用所有情况。用MALLOC_CHECK_没有检测出问题，并不
像这样，利用环境变量MALLOC_CHECK_即可容易地发现应用程序中的双重释放bug。
下面的例子中检查了doublefree，即双重释放。
162|第4章应用程序调试实践
Aborted(core dumped)
ffffff600000-fffffff601000 r-xp000000000:000
7fff4f3ff000-7fff4f400000r-xp7fff4f3ff00000:000
7f854738c000-7f854738e000
3b53a00000-3b53a0d000
3b48952000-3b48957000
3b48951000-3b48952000
3b4894d000-3b48951000
3b48600000-3b4874d000
3b4841b000-3b4841cooo
3b4841a000-3b4841b000
3b48200000-3b4821b000
020b2000-020d3000rw-p
00600000-00601000
00400000-00401000
=Memorymap:
/Lib64/Libc.so.6(cfree+0x8c)[0x3b48675f2c]
/Lib64/libc.so.6[0x3b48672832]
$envMALLOC_CHECK=1./membug
7fff4f39b000-7fff4f3b0000r
7f85473ae000-7f85473b0000
7f8540021000-7f8544000000
3b53c0d000-3b53c0e000
3b53a0d000-3b53c0d000
3b4874d000-3b4894d000
./membug[0x400449]
ib64/libc.so.6(
/membug[0x400588]
/membug[0x400534]
rw-p
r-xp
_libc_start_main+0xf4)[0x3b4861e074]
rw-p
---p 0000d000 08:027057488
r-xp0000000008:027057200
r-xp
rw-p 3b4895200000:000
w-p
--P
-xp
rw-p
r--P
020b200000:000
00000000 08:06 42927111
00000000
rw-p7ffffffea000 00:00
rw-p7f85473ae000
rw-p7f854738c00000:00
.--p 7f8540021000 00:00
0001b000 08:027057200
0001a00008:027057200
www.TopSage.com
0000d000 08:027057488
0000000008:027057488
0015100008:027057202
0014d000 08:02 7057202
0014d000 08:027057202
00000000 08:02 7057202
08:06
42927111
00:00
/lib64/libgcc_s-4.1.2-20070925.so.
/lib64/Libgcc_s-4.1.2-20070925.so.
/ib64/Libgcc_s-4.1.2-20070925.so.1
/lib64/libc-2.7.so
/lib64/libc-2.7.so
/lib64/libc-2.7.so
/lib64/libc-2.7.so
/lib64/ld-2.7.so
/lib64/ld-2.7.so
/lib64/ld-2.7.so
[heap]
/data/mywork/mines/0002/membug
/data/mywork/mines/0002/membug
[vsyscall]
[vdso]
[stack]
---
## Page 181
图获得同一个锁，导致了死锁。这种 bug 经常出现在设计不完善的程序中。
该程序在获得了锁（mutex）的状态下调用函数cnt_reset()，在该函数中再次试
死锁的例子
参考文献
内存双重释放导致的 bug 与内存泄漏并列，是很难发现真正原因的 bug 之一。
MALLOC_CHECK_进行调试会收到不错的效果。
用程序是否发生了双重释放等 bug。此外，如果使用最新的 glibc，用环境变量
malloc()、free()等标准 C 库函数的内存操作函数上发生问题时，首先要怀疑应
释放、非法区域释放等。
本 hack 说明了malloc()、free()等内存操作库函数表现出的问题，即内存的双重
能说明应用程序没有 bug。
下面用示例代码（astall.c）讲解一下停止响应的典型情况一
总结
int cnt = θ; 
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;
#include 
#include 
#include 
[astall.c]
Manpage of MALLOC
http:/linux.die.net/man/3/malloc
 本 hack 介绍 pthread_mutex_lock 死锁导致的程序停止响应的调试方法。
应用程序停止响应
www.TopSage.com
HACK#31应用程序停止响应（死锁篇）
（死锁篇
—死锁的调试步骤，
一岛本裕志
1163
---
## Page 182
结果如下，显示到3之后停止响应。
该程序在运行中会突然停止工作，也就是陷入停止响应的状态。执行上述程序的
164】第4章应用程序调试实践
$ ./astall
int main(void)
void* thr(void *arg)
void cnt_reset(void)
return EXIT_SUCCESS;
pthread_join(tid, NULL);
pthread_create(&tid, NULL, thr, NULL);
while(1) {
pthread_mutex_unlock(&mutex);
cnt = 0; 
 pthread_mutex_lock(&mutex);
pthread_t tid;
sleep(1);
printf("%d\n", cnt);
pthread_mutex_unlock(&mutex);
else
if (cnt >2)
pthread_mutex_lock(&mutex);
cnt++;
cnt_reset();
www.TopSage.com
---
## Page 183
另一个线程执行 bt命令。
程的 backtrace。该线程在 pthread_join()处睡眠，是期待的结果，所以我们切到
启动之后只输入bt命令，显示的并不是运行停止的那个线程，而是最初启动的线
接下来用 GDB alttach 到这个进程上，调查哪里在睡眠（slep）。
运行状态如何呢？ps 命令的确认结果如下，状态为 S，可以怀疑是陷入了死锁。
期之外的睡眠持续很长时间，大多数情况是陷入了死锁。那么，上例的 astall的
在执行。也就是说，失控的可能性很大。如果是 S，说明在睡眠（sleep)。如果预
认。ps命令的输出结果中，左起第3列为进程状态，如果这里为 R，表示进程仍
一般情况下，程序停止响应时要先确认是失去控制还是在等待，用 ps 命令可以确
停止响应时的解决方法
#2 oxb7flal14 in L_lock_89 () from /lib/tls/i686/cmov/libpthread.so.0
#1 oxb7fled09 in _lll_lock_wait () from /lib/tls/i686/cmov/libpthread.so.0
#0 0xb7f47430 in -
[Switching to thread 2 (Thread θxb7db1b90 (LWP 29894))]#0 0xb7f47430 in _kermel_vsyscall () 
#2 0x08048634 in main () at astall.c:35
0o9 () ud  #
1 Thread oxb7db26be (LlwP 29893) 0oxb7f47430 in _kernel_vsyscall ()
(gdb) i thr
#0 oxb7f47430 in __kernel_vsyscall ()
lnezse oprd、 d- qp6 $
2 Thread 0xb7db1b0 (LWP 29894) 0xbf47430 in --
(gdb)bt
2365 2366 pts/4
2365 2365 pts/4 Sl+
$ ps ax -L I grep astall
>
qdb} bt
(gdb)thr 2
选项-L可以显示所有线程
Sl+
kernel_vsyscall ()
0:00 ./astall
0:00 ./astall
www.TopSage.com
HACK#31应用程序停止响应（死锁篇）
_kernel_vsyscall ()
1165
122
---
## Page 184
174
set logging overwrite 表示覆盖同名文件。③在pthread mutex_Lock(）和
不要暂停显示，而是继续显示下去。②的意思是将屏幕显示的内容记录到文件中，
上述命令文件中的①的设置表示，即使显示的信息的行数超过了终端的行数，也
和 pthread_mutex_unlock()被调用时显示backtrace,并将其内容记录到 debug.log 中。
令文件，自动记录死锁发生之前的所有操作。该命令文件会在 pthread_mutex_Lock()
要想手动确认死锁发生之前的操作也是很困难的。所以我们采用下面的 GDB 命
般而言，死锁都发生在多次调用加锁、解锁操作后发生。因此，即使设置了断点
致了死锁，但是这种问题还要确定之前在哪里调用了pthread_mutex_lock()。
从上述 backtrace 可见，该线程在 astall.c:10行调用的 pthread_mutex_lock()导
mutex_lock()的可能性很大。
线程在别的地方用 pthread_mutex_lock()获取了锁的情况下再次调用 pthread
可以看出，#3 的 pthread_mutex_Llock()处进入内核模式并睡眠。也就是说，其他
166 1
end
while 1
b *$addr2
b *$addr1
set $addr2 = pthread_mutex_unlock
set $addrl = pthread_mutex_lock 
set logging on
set logging overwrite
set pagination off
 #3 oxb7f19a42 in pthread_mutex_lock () from /Lib/tls/i686/cmov/libpthread.so.0
start
set logging file debug.log "
end
if $pc != $addr1 && $pc != $addr27
quit
C
第 4 章应用程序调试实践
 in start_thread () from /lib/tls/i686/cmov/libpthread.so.0
www.TopSage.com
?
?
?
一
---
## Page 185
令整理一下。
含大量的无用信息，看起来不太方便，可以像下面这样用 grep、sed或Ruby等命
查看上述处理生成的日志debug.log，就能确认怎样导致的死锁。但是，日志中包
将上述命令文件保存为debug.cmd，并用以下方式执行。
的处理。
因此结束该程序要在键盘上输入Ctrl-C组合键。④就是中断程序运行时退出GDB
以保存到了变量$addr1和$addr2中，以方便使用。调试对象程序执行后会死锁，
thr(arg=0x0)at astall.c:18
thr(arg=0x0)at astall.c:23
thr (arg=0x0)at astall.c:18
pthread_mutex_lock()
pthread_mutex_unlock()
pthread_mutex_lock()
$cat debug.log|grep -A1"#0.*pthread_mutex_|sed s/from\*$//| sed s/.*\in\//
>
#40xb7f3f7eein clone()from/Lib/tls/i686/cmov/libc.so.6
#1 0x08048576 in cnt_reset () at astall.c:10
Breakpoint2,0xb7fc39doinpthread_mutex_lock()from/lib/tls/i686/cmov/Libpthread.so.0
>
$gdb astall -x debug.cmd
pthread_mutex_lock()
pthread_mutex_unlock()
dl_addr()
dl_addr()
：
0xb7fc250fin start_thread()from/lib/tls/i686/cmov/libpthread.so.0
0x080485afi
in thr（arg=0x0)atastall.c:20
www.TopSage.com
HACK#31应用程序停止响应（死锁篇）
1167
---
## Page 186
176
与 TCP 同属传输层协议。
SCTP是 SIGTRAN工作组定义的、在IP上传输电话网控制信号（SS7）的协议,
#32
本 hack 介绍了 pthread_mutex_lock死锁引发的程序停止响应的调试方法。