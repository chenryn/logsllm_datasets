completeness theorem for protocols with honest majority. In Proceedings of the 19th Annual
ACM Symposium on Theory of Computing (1987), pp. 218–229.
[23] Impagliazzo, R., Levin, L. A., and Luby, M. Pseudo-random generation from one-way
functions (extended abstracts). In Proceedings of the 21st Annual ACM Symposium on Theory
of Computing, May 14-17, 1989, Seattle, Washigton, USA (1989), pp. 12–24.
[24] Intel.
Intel
intrinsics guide.
https://software.intel.com/sites/landingpage/
IntrinsicsGuide, 2016. Online; accessed February 2016.
27
[25] Ishai, Y., Kilian, J., Nissim, K., and Petrank, E. Extending oblivious transfers eﬃ-
ciently. In Advances in Cryptology - CRYPTO (2003), pp. 145–161.
[26] Ishai, Y., Prabhakaran, M., and Sahai, A. Secure arithmetic computation with no
honest majority. In Reingold [41], pp. 294–314.
[27] Kamm, L., and Willemson, J. Secure ﬂoating point arithmetic and private satellite collision
analysis. International Journal of Information Security 14, 6 (2015), 531–548.
[28] Keller, M., Orsini, E., and Scholl, P. Actively secure OT extension with optimal
overhead. In Advances in Cryptology - CRYPTO 2015, Part I (2015), pp. 724–741.
[29] Keller, M., Rotaru, D., Scholl, P., and Smart, N. P. Multiparty computation with
SPDZ online phase and MASCOT oﬄine phase, 2016. https://github.com/bristolcrypto/
SPDZ-2.
[30] Keller, M., Scholl, P., and Smart, N. P. An architecture for practical actively secure
MPC with dishonest majority. In ACM Conference on Computer and Communications Security
(2013), pp. 549–560.
[31] Kreuter, B., Shelat, A., and Shen, C. Billion-gate secure computation with malicious
In Proceedings of the 21st USENIX conference on Security symposium (2012),
adversaries.
USENIX Association, pp. 14–14.
[32] Larraia, E., Orsini, E., and Smart, N. P. Dishonest majority multi-party computation
for binary circuits. In Advances in Cryptology - CRYPTO 2014, Part II (2014), pp. 495–512.
[33] Lindell, Y., and Riva, B. Blazing fast 2PC in the oﬄine/online setting with security for
malicious adversaries. In Proceedings of the 22nd ACM SIGSAC Conference on Computer and
Communications Security (2015), pp. 579–590.
[34] Matyas, S. M., Meyer, C. H., and Oseas, J. Generating strong one-way functions with
cryptographic algorithm. IBM Technical Disclosure Bulletin 27, 10A (1985), 5658–5659.
[35] mischasan. What is SSE !@# good for? Transposing a bit matrix. https://mischasan.
2011.
wordpress.com/2011/07/24/what-is-sse-good-for-transposing-a-bit-matrix,
Online; accessed February 2016.
[36] Nielsen, J. B., Nordholt, P. S., Orlandi, C., and Burra, S. S. A new approach
to practical active-secure two-party computation. In Advances in Cryptology–CRYPTO 2012.
Springer, 2012, pp. 681–700.
[37] Nielsen, J. B., and Orlandi, C. LEGO for two-party secure computation. In Reingold
[41], pp. 368–386.
[38] Peikert, C., Vaikuntanathan, V., and Waters, B. A framework for eﬃcient and com-
posable oblivious transfer. In Advances in Cryptology - CRYPTO (2008), pp. 554–571.
[39] Pinkas, B., Schneider, T., Segev, G., and Zohner, M. Phasing: Private set intersection
using permutation-based hashing. In 24th USENIX Security Symposium, USENIX Security
15 (2015), pp. 515–530.
28
[40] Pinkas, B., Schneider, T., and Zohner, M. Faster private set intersection based on OT
extension. In Proceedings of the 23rd USENIX Security Symposium (2014), pp. 797–812.
[41] Reingold, O., Ed. Theory of Cryptography, 6th Theory of Cryptography Conference, TCC
(2009), vol. 5444 of Lecture Notes in Computer Science, Springer.
[42] The MPIR team. Multiple precision integers and rationals. https://www.mpir.org, 2016.
Online; accessed February 2016.
[43] Yao, A. C. How to generate and exchange secrets (extended abstract).
In 27th Annual
Symposium on Foundations of Computer Science (1986).
A Security of the ΠCOPEe Protocol
Lemma 1. The protocol ΠCOPEe securely implements FCOPEe in the OT-hybrid model, with com-
putational security λ.
Proof. We construct a simulator S such that for any adversary A who corrupts one party, and
any environment Z who chooses both parties’ inputs and sees all outputs, Z cannot distinguish
between a real execution of the protocol between A and an honest party, or a simulated execution
of the protocol between S and the ideal functionality FCOPEe.
We consider two cases, depending on whether party PA or PB is corrupted (if A corrupts no
parties or both parties then simulation is trivial). S begins by receiving the corrupted party’s input
from Z, copying this onto the input tape of A and invoking A. All communication with A is then
passed back to Z.
Corrupt PB. The simulator receives ∆ ∈ {0, 1}λ from A, and sends this to FCOPEe for the
to A, for i = 1, . . . , λ.
Initialize stage. S samples random seeds {(ki
During the Extend stage, S simulates the honest PA’s messages ui with uniformly random values
˜ui ∈ F. S then computes q as an honest PB would in the protocol and sends q to FCOPEe.
i=1, and sends ki
∆i
1)}λ
0, ki
Indistinguishability. We now argue indistinguishability of the real and ideal executions to an
environment, Z. Recall that Z can choose the inputs of both parties (the values ∆, x). The view of
Z in the real world then consists of these inputs, the messages received by the adversary (namely
and a set of ˜ui for each call to Extend), and both parties’ outputs t, q. In the ideal world,
ki
∆i
the values ki
and ui are randomly generated by the simulator, while each receiver’s output t is
computed by the functionality, according to the input q provided by S and the honest input x.
∆i
In the real world, since PA is honest, the seeds are also uniformly random, so these values
are identically distributed in both worlds. Note also that in both worlds, t and q are entirely
determined by the remainder of the transcript, so we only need to show that the real world values
ui = F (ki
1, j) + xi are indistinguishable from the uniformly random ˜ui values in the ideal
world.
To do this, we deﬁne a sequence of hybrid experiments, H1, . . . , Hk+1, with the environment Z,
0, j)− F (ki
as follows.
29
0, ki
0, ti
0 − ti
1 + x, where ti
Hybrid H1: This models an interaction of Z with the real world protocol. Here, in each invocation
of Extend, Z provides PA’s input x and receives the messages ui = ti
1 are
1. Z also receives the outputs t, q,
computed from the PRF F using uniformly random keys ki
which are computed as in the protocol.
Hybrid Hh (2 ≤ h ≤ k):
In the h-th experiment, values u1, . . . , uh−1 are sampled uniformly at
random, whilst for i ≥ h, ui is computed as in H1. The q outputs are computed as an honest PB
would, and t computed to satisfy q + t = x · ∆.
Hybrid Hk+1: The ﬁnal experiment models the ideal world, where all of the ui values sent to Z
during Extend are uniformly random.
Claim 1. Hybrids Hh and Hh+1 are indistinguishable, for every 1 ≤ h ≤ k.
Proof. Suppose Z distinguishes between Hh and Hh+1 with advantage . We construct an algorithm,
D, that breaks the security of the PRF. D has access to an oracle OPRF, which either returns
uniformly random values in F, or outputs from F . D runs Z, and samples random seeds {ki
1}k
i=1
for the Initialize stage. D receives the inputs {∆i}i from Z, and sends back ki
. For the j-th
Extend invocation by Z on input x, D computes u1, . . . , uh−1 uniformly at random. The values
1), as in the protocol. For the
uh+1, . . . , uk are computed using the keys (kh+1
h-th value, D obtains th
is computed as
1 + x, where th
∆h
F (kh
Notice that, if OPRF gives outputs from the PRF then the view of Z is identically distributed
∆h
to a run of the experiment Hh. If the outputs of OPRF are uniformly random then uh is uniformly
random, so the view of Z is identical to that of experiment Hh+1. Therefore, the distinguishing
advantage of D with OPRF is , the same as Z.
), . . . , (kk
← OPRF(j) and computes uh = th
0, kk
0 − th
, kh+1
1−∆h
0, ki
0
1
, j).
∆i
It follows that any Z who distinguishes between H1 and Hk+1 with advantage  can be used to
distinguish the outputs of the PRF with advantage at least 
k .
In the Initialize stage, S receives and stores the seeds {(ki
i=1 from the
Corrupt PA.
corrupt PA, as input to the functionality κ × OTκ. Whenever Extend is called, S computes
1 using these seeds and the PRF, as in the protocol. The corrupt PA sends the vectors ui for
ti
0, ti
i = 1, . . . , k, and S extracts the inputs by computing xi = ui−ti
0)(cid:105)
0, . . . , tk
as in the protocol and sends t, x to the FCOPEe functionality.
1, and then t = −(cid:104)g, (t1
1)}k
0+ti
0, ki
Since no messages are sent to the adversary, and all outputs are computed identically in both
worlds, it is clear that the real and ideal worlds are perfectly indistinguishable.
B Authentication and MAC checking security proof
We now prove security of the authentication and MAC checking protocol.
Theorem 6 (Theorem 2, restated). The protocol Π(cid:74)·(cid:75) securely implements F(cid:74)·(cid:75) in the (FCOPEe,FComm,FRand)-
hybrid model, with statistical security parameter log |F| − 2 log log|F|.
30
Proof. We describe a simulator, S, that interacts with F(cid:74)·(cid:75), such that no environment Z can
distinguish between an interaction with S and F(cid:74)·(cid:75) and an interaction with the real adversary A
and Π(cid:74)·(cid:75). After describing the simulator we then argue indistinguishability of the real and ideal
S maintains several databases, LC for linear combinations, HS for simulated shares of honest
worlds.
parties in the open and check phases, and CS for the sums of shares of corrupted parties.
Simulating the Initialize phase. Emulating FCOPEe instances between every pair of corrupt
party Pi and honest party Pj, receive ∆(i,j) input by Pi to the respective instance. Furthermore,
sample ∆(i) $← F for all i /∈ A.
Simulating the Input phase.
- If Pj is corrupted, emulate the communication channels and instances of FCOPEe with honest
parties Pi, i /∈ A. For the FCOPEe instance with Pi, receive x(i,j)
h from the adversary and
set it to the input of Pj, for i = 1, . . . , n and h = 0, . . . , l. For the checking, sample r $← Fl+1
to emulate FRand, receive y from Pj, and receive {σ(i)}i∈A emulating FComm. Compute σ(i) =
, tj,i
h
(cid:80)l
h=0 rh · ((cid:104)g ∗ x(i,j)
h
, ∆(i)
i=1 σi (cid:54)= 0, abort. Otherwise, solve
B (cid:105) − t(i,j)) for all i /∈ A. If(cid:80)n
rh ·(cid:88)
(cid:88)
g · y − g ∗ l(cid:88)
(cid:68)
i /∈A
h=0
j∈A
(cid:69)
x(i,j)
h
, ˜∆(i)
B
= 0
(3)
(cid:80)
˜∆(i) = 0 for all solutions, abort. Otherwise, for some { ˜∆(i)}i /∈A such that(cid:80)
B }i /∈A in F. The solutions represent the set of all possible MAC keys of honest parties
for { ˜∆(i)
that let the MAC check pass, not just the concrete MAC keys chosen by the simulator. If
˜∆(i) (cid:54)= 0
and for each h ∈ [l], compute
i /∈A
i /∈A
(cid:16)(cid:88)
i /∈A
B (cid:105)(cid:17)−1 ·(cid:88)
(cid:88)
i /∈A
j∈A
xh =
(cid:104)g, ˜∆(i)
(cid:104)g ∗ x(i,j)
h
B (cid:105),
, ˜∆(i)
(4)
and input {xh}h∈[l] to F(cid:74)·(cid:75) on behalf of Pj. We will show that, with overwhelming probability,
xh is unique over all possible ˜∆(i).
- Otherwise, emulate communication channels and instances of FCOPEe with corrupted parties
receive q(i,j) from A, for h = 0, . . . , l. Store(cid:80)
Pi, i ∈ A. For the channel with Pi, send a random share x(i), and for the FCOPEe instance,
i∈A x(i) · ∆(i) + q(i,j)
parties. Compute(cid:80)
j=0 rh·(cid:80)
in CS. Sample r $← Ft to emulate FRand, sample y $← F, and send both to the corrupted
that(cid:80)n
h − y·∆(i). Then sample {σ(i)}i /∈A in F such
i=1 σ(i) = 0 and use {σ(i)}i /∈A to emulate FComm just as in the Check phase below.
i∈A σ(i) =(cid:80)l
h and(cid:80)
h =(cid:80)
i∈A m(i)
i∈A m(i)
i∈A x(i)
Simulating the Linear comb. phase. Store the linear combination in LC under id.
31
Simulating the Open phase. Receive the constraints on x from F(cid:74)·(cid:75) and check if the value
Otherwise, sample random shares {x(i)}i /∈A and MAC shares {m(i)}i /∈A such that (cid:80)
and(cid:80)
x =(cid:80)
to be opened and the previously opened values form a linearly dependent set in the input values
If so, compute the shares of the honest parties accordingly from the entries in HS.
w.r.t. LC.
i x(i) = x
i∈A m(i) taken from the relevant linear combination of
values from CS. Emulating the broadcast channel send {x(i)}i /∈A and receive {x(j)}j∈A. Compute