SIGSEGV, bus error) into the legacy guest so that it can re-
claim resources from the misbehaving process.
Unregistration is initiated via a hypercall from the un-
trusted portion of an application. During unregistration,
TrustVisor ﬁrst veriﬁes that the physical page numbers in-
side the PAL and the current CR3 in the guest have already
been registered. If so, sensitive data pertaining to the PAL
is zeroed, including the data region of the PAL and the cor-
responding µTPM inside TrustVisor. Finally, protections are
removed from the NPT and DEV for all the physical pages
corresponding to this PAL. All registration information for
this PAL is removed from TrustVisor’s state.
5.1.3 Sensitive Environment Switching
TrustVisor needs to transparently get control of the system
when any sensitive function is called by the application, and
when the sensitive function returns to the calling application.
TrustVisor switches between legacy mode and secure mode at
those points and marshals the relevant parameters. TrustVi-
sor’s memory virtualization implementation based on NPTs
makes this interposition straightforward. In legacy mode, the
pages that belong to the registered PAL are marked as inac-
cessible. This guarantees that when the application running in
legacy mode attempts to execute the sensitive code or touch
the data inside the PAL, the CPU will generate a nested page
fault and trap into TrustVisor. TrustVisor uses the page per-
missions of the page(s) containing PAL entry points to guar-
antee a trap to TrustVisor whenever a sensitive function is
called. Note that the valid entry points for a PAL must not be
on a shared page.
Analogously, in secure mode, all the pages that are not part
of the current PAL are inaccessible to it, and the PAL will
cause a nested page fault (that will be caught by TrustVi-
sor) whenever they are touched (read, written, or executed).
Therefore, TrustVisor will always get control during transi-
tions between legacy mode and secure mode. The input data
available to a PAL is marshaled by TrustVisor, and is veriﬁed
by TrustVisor’s parameter checking. (Recall that TrustVisor
will return a failure code from the registration hypercall if
parameter checking fails.)
We now describe the operations that TrustVisor performs
to switch from legacy mode to secure mode to guarantee the
execution integrity of the PAL (in response to a trap as de-
scribed above). First, TrustVisor conﬁgures the PAL code in
secure mode to run in ring 3 with interrupts disabled. Any ex-
ceptions generated by the PAL code will be caught by Trust-
Visor and interpreted as an illegal action performed by the
PAL (e.g., a null-pointer dereference or divide-by-zero).
Second, TrustVisor conﬁgures the NPTs such that only the
physical pages belonging to this PAL are accessible from the
guest. However, since we run PALs within a subset of the
current application’s execution environment, we also need to
let the guest have access to some critical system resources,
such as the GDT, the LDT, and guest page tables that are used
to translate addresses for the GDT, LDT and PAL. Thus, in
the third step, TrustVisor conﬁgures the NPTs so that pages
containing these critical system resources are accessible from
the guest with read-only permission.
In the fourth step, TrustVisor veriﬁes that the system bit in
each of the guest page table entries corresponding to TrustVi-
sor and the critical system resources is correctly set, so that
the PAL running in ring 3 cannot write any information to the
pages containing the critical system resources, or read any in-
formation from the pages for which the PAL does not have
read permission. Note that well-behaved Linux will already
have the system bit set for these pages, but with our attacker
model a rootkit may have modiﬁed them arbitrarily.
Finally, TrustVisor must ensure that the PAL page map-
pings conﬁgured during registration cannot be subsequently
changed (e.g., re-ordered) by the legacy OS. Each PAL’s
guest physical pages are inaccessible to the legacy guest due
to the NPT conﬁguration during PAL registration, so the con-
tents of the pages themselves are protected from illegal mod-
iﬁcation. However, we must still ensure that the virtual-to-
physical address translation of registered PAL pages has not
been changed since registration. This veriﬁcation will pre-
vent a malicious OS from compromising PAL code integrity
by making clever changes to PAL page tables, e.g., changing
the virtual address of an entry point code page to point to the
physical address of a PAL-private code page.
The steps described above show that TrustVisor sets up
a highly restricted, secure environment for executing PALs.
TrustVisor also marshals input and output parameters, copies
the memory regions corresponding to these parameters into
the PAL’s parameter marshaling pages, saves the legacy OS
stack pointer, and initializes the stack pointer within the PAL.
The pages allocated for use as the secure mode stack and pa-
rameter storage are identiﬁed during registration and need to
have been allocated by the untrusted code prior to PAL regis-
tration. However, before copying the memory regions cor-
responding to input parameters, TrustVisor needs to check
that those memory regions are readable by the guest.
If
the parameter is a reference, TrustVisor also needs to check
that the memory region of that parameter is writable by the
guest. These operations will prevent a malicious application
from passing incorrect parameters to TrustVisor and tamper-
ing with the memory permissions set by the OS. Note that de-
spite TrustVisor’s protections, semantic security for PALs de-
pends on PALs performing responsible input parameter han-
dling, the details of which are beyond the scope of this paper.
Finally, TrustVisor transfers control to whichever sensitive
function is called by the application. The return point in the
application is saved in TrustVisor so that it cannot be modiﬁed
by a malicious PAL. This prevents a malicious application
from using a PAL to attempt control-ﬂow attacks.
After the sensitive function returns to the untrusted applica-
tion, TrustVisor needs to perform the opposite steps to switch
from secure mode back to legacy mode. First, TrustVisor
marshals the output parameters back into the untrusted por-
tion of the application and recovers the stack pointer in the
guest. Note that a PAL cannot return heap data in our current
implementation – a buffer for such outputs needs to have been
allocated by the untrusted application and passed as an input
parameter to the PAL. Then, TrustVisor updates the NPTs to
mark all the pages that are not part of the PAL as accessi-
ble from the guest, and sets the PAL pages as inaccessible
from the guest. Finally, TrustVisor transfers control back to
the legacy application, so that the application can process the
results returned by the PAL and continue to run. Note that
a PAL that makes an explicit call (as opposed to a return) to
untrusted code will be terminated as described in §4.2.2.
5.2 Trusted Computing Implementation
We describe how TrustVisor initializes itself using dynamic
root of trust to achieve a trusted boot process. We then de-
scribe how µTPM instances are implemented in TrustVisor.
5.2.1 Trusted Boot
We use AMD’s SKINIT instruction to create a dynamic root
of trust to bootstrap TrustVisor starting from an initially un-
trusted system state (§3.1). We note that bootstrapping a hy-
pervisor with DRTM is its intended function. Contemporary
projects for booting with DRTM include Kauer’s Open Se-
cure Loader [19] and Intel’s “tboot”.4
We now explain how we create an unbroken chain of
trust from TrustVisor’s launch to the execution of PALs from
within Linux applications (currently we have tested v2.6.21
of the Linux kernel with the Fedora Core 6 patchset, and
v2.6.27 with the Ubuntu 8.10 patchset).
4http://tboot.sourceforge.net/
TrustVisor is invoked in a three-step process by the boot-
loader (e.g., grub). First, an untrusted loader we have de-
veloped called TLoader relocates the Linux kernel and initial
ramdisk so that they will be able to execute when invoked
as a guest by TrustVisor. TLoader also relocates the trusted
initialization portion of TrustVisor so that it is aligned on a
64 KB boundary – a requirement for SKINIT.
TLoader’s ﬁnal operation is to launch TrustVisor by invok-
ing the SKINIT instruction, which reinitializes the system’s
bootstrap processor (BSP) to a trusted state, enables DEV
protection for the TrustVisor image, measures it, and trans-
fers control to the TrustVisor entry point. Since the maximum
length of the memory region that SKINIT can measure atom-
ically is 64 KB, we split TrustVisor into two parts: initializa-
tion and runtime portions. The initialization portion is less
than 64 KB and meets the requirements for measurement by
SKINIT. After the start address and size of the initialization
portion are passed to SKINIT for measurement, the initializa-
tion portion takes control of the system and further initializes
a protected environment for the runtime portion.
Speciﬁcally, the initialization portion relocates the runtime
portion to the top of physical memory, so that TrustVisor can
present the illusion to the untrusted guest OS (e.g., Linux)
that the system is equipped with slightly less (see §6) phys-
ical memory (RAM). Note that this design signiﬁcantly re-
duces hypervisor complexity since guest physical addresses
are also machine physical addresses. Before invoking the run-
time portion, the initialization portion sets up AMD’s Device
Exclusion Vector to provide DMA protection for the runtime
memory region. Then, the initialization portion hashes the
memory region of the runtime portion and compares it with
a built-in hash value. If the runtime portion passes the veri-
ﬁcation, then the initialization portion transfers control to the
runtime portion. At this point, the initialization portion can
be cleared and freed.
The runtime portion of TrustVisor sets up a Virtual Ma-
chine Control Block (VMCB) for the legacy guest OS and
prepares access to the necessary resources for the correspond-
ing VM. It then boots Linux inside the VM. Thus, the runtime
TCB comprises only the runtime portion of TrustVisor, which
is veriﬁed by a chain of trusted software since SKINIT.
5.2.2
µTPM Implementation
Our µTPM implementation is part of TrustVisor. TrustVi-
sor maintains three long-term secrets using TPM sealed stor-
age. These are the encryption and MAC keys used to pro-
tect the secrecy and integrity of data sealed (using HV Seal)
by a µTPM instance, and the PRNG seed used to derive the
µTPM’s µAIK keypair. For the µTPM seal and unseal opera-
tions, we use AES-CBC with 128-bit keys and HMAC-SHA-
1 with 160-bit keys for secrecy and integrity protection, re-
spectively. We use a 160-bit TPM-generated random PRNG
seed. The µAIK keypair is a 2048-bit RSA signing keypair,
and is used when a PAL invokes HV Quote. A unique array
of 8 µPCRs is allocated for each PAL, and used in the HV *
Dbg
Init.
C + ASM Core
1943
773 + 128
507
Runtime
µTPM RSA
2339
619
Lib
1580
Total
6481
.h
2790
Table 1: Lines of code in C, assembly, and header ﬁles.
family of operations from §4.3.2. The data structures used
to enforce the required µPCR values during HV Unseal are
identical to those employed by the physical TPM [33].
6 Evaluation
We present the TCB size of our TrustVisor implementation
(§6.1). We then present the performance impact on a legacy
system running on TrustVisor (§6.2), since these results ex-
plain the basic hardware virtualization overhead intrinsic to
the design of TrustVisor. We also evaluate the performance
for PALs on TrustVisor and compare it with Flicker (§6.3).
Our experimental platform is a Dell PowerEdge T105 with
a Quad-Core AMD Opteron running at 2.3 GHz. Our cur-
rent implementation of TrustVisor allocates 2 GB of RAM
to the Linux kernel and supports only a uniprocessor guest.
Additional cores and RAM are unused. Our server runs the
32-bit version of the Fedora Core 6 Linux distribution for
the experiments that follow, although no kernel modiﬁcations
were made other than including “nosmp” on the kernel com-
mand line. We have successfully booted other kernels, e.g.,
v2.6.27 with Ubuntu’s patchset. Since TrustVisor is binary-
compatible with the legacy OS, experiments with and with-
out TrustVisor are run on the identical nosmp kernel image.
For network benchmarks, we connect another machine via a
1 Gbps Ethernet crossover link and run the T105 as a server.
6.1 Trusted Computing Base
We evaluate how our implementation maintains a small TCB
and compatibility with unmodiﬁed legacy software.
Reduced TCB. We use the sloccount5 program to count the
number of lines of source code in TrustVisor (see Table 1).
We divide TrustVisor’s code into four parts. The debug code
provides printf and serial console functions which are not re-
quired on a production system. The initialization code is the
initialization portion described in §5.2.1, which is measured
by SKINIT and initializes the protected environment. Fi-
nally, the runtime code is responsible for providing the guar-
antees for PALs as described in §4. We further divide the
runtime code into core functionality (including TrustVisor’s
basic NPT-based protection framework, PAL management,
and parameter marshaling), µTPM, RSA libraries, and other
libraries (such as SHA-1 and string functions).
As shown in Table 1, the total size of TrustVisor implemen-
tation is 7889 lines of C and assembly code (the sum of the
debug, initialization, and runtime code). The runtime TCB is
about 6481 lines, which includes 3919 lines of RSA and other
libraries. This is the full extent of the software TCB for Trust-
Visor, which places it within the reach of formal veriﬁcation
and manual audit techniques.
5http://www.dwheeler.com/sloccount/
Compatibility. As a security hypervisor, TrustVisor vir-
tualizes physical memory using NPTs, conﬁgures the DEV
to provide DMA protection for security-sensitive pages, and
intercepts a small set of infrequently-used hardware I/O op-
erations to prevent malicious code from modifying the NPT
and DEV protection mechanisms. TrustVisor can support any
32-bit legacy x86 OS image without any modiﬁcations. The
legacy OS and its applications need not be aware of Trust-
Visor unless they would like to take advantage of registering
and executing PALs with TrustVisor’s protections.
6.2 Performance of Legacy Software
TrustVisor only receives control as a result of a hypercall
or trap (recall §5). Thus, when well-behaved legacy code
runs, the performance overhead is exclusively the result of the
hardware virtualization mechanisms, particularly the nested
paging. To evaluate this overhead, we run all the experiments
in Linux on top of TrustVisor without registering any PALs.
OS Microbenchmarks. We use the lmbench suite to mea-
sure the overhead of different OS operations when running
on top of TrustVisor. Figure 6(a) shows the results of 9
important operations in our experiments: null (null system
call), fork, exec, ctxsw (context switch among 16 processes,
each 64 KB in size), mmap, page fault, bcopy (block mem-
ory copy), mmap read (read from a ﬁle mapped into a pro-
cess), and socket (local communication by socket). Most of
these benchmarks show less than 6% overhead as a result of
TrustVisor. However, fork, exec and ctxsw do incur higher
performance penalties of 34%, 27% and 15%. This is not
surprising as those operations stress the system’s MMU and
TLB functionality – components which are highly sensitive to
the hardware performance of NPT. We note that these over-
heads are likely to decrease on future platforms as hardware
virtualization support matures.
Application Benchmarks. We execute both compute-bound
and I/O-bound applications with TrustVisor. For compute-
bound applications, we use the SPECint 2006 suite. For I/O-
bound applications, we select a range of benchmarks, includ-
ing building the Linux kernel, Bonnie,6 Postmark [17], net-
perf,7 and unmodiﬁed Apache web server performance.
For the kernel build, we compile the Linux kernel 2.6.21
by executing ”make”. For Bonnie, we choose a 1 GB ﬁle and
perform sequential read (fread), sequential write (fwrite), and
random access (frandom). For Postmark, we choose 20,000
ﬁles, 100,000 transactions, 100 subdirectories, with all other
parameters set to their default values. For netperf, we use
the TrustVisor system as the netperf server, and run both
TCP STREAM and UDP STREAM benchmarks to evaluate
basic network performance. We run the Apache web server
on the TrustVisor system, and use the Apache Benchmark
(ab) included in the Apache distribution to perform 50,000
transactions with 5 concurrent connections.
Our results are presented in Figures 6(b) and 6(c). Most of
the SPEC benchmarks show less than 3% performance over-
6http://www.textuality.com/bonnie/
7http://netperf.org/
(a) Registration hypercall overhead with varying PAL sizes.
Registration
32K
16K
112
220
4K
31
64K
435
4K
1.09
Unregistration
32K
16K
1.17
1.44
64K