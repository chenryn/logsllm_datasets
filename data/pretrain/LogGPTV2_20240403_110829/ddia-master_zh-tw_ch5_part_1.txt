# 第五章：复制
![](../img/ch5.png)
> 与可能出错的东西比，“不可能”出错的东西最显著的特点就是：一旦真的出错，通常就彻底玩完了。
>
> —— 道格拉斯・亚当斯（1992）
------
[TOC]
复制意味著在透过网路连线的多台机器上保留相同资料的副本。正如在 [第二部分](part-ii.md) 的介绍中所讨论的那样，我们希望能复制资料，可能出于各种各样的原因：
* 使得资料与使用者在地理上接近（从而减少延迟）
* 即使系统的一部分出现故障，系统也能继续工作（从而提高可用性）
* 伸缩可以接受读请求的机器数量（从而提高读取吞吐量）
本章将假设你的资料集非常小，每台机器都可以储存整个资料集的副本。在 [第六章](ch6.md) 中将放宽这个假设，讨论对单个机器来说太大的资料集的分割（分片）。在后面的章节中，我们将讨论复制资料系统中可能发生的各种故障，以及如何处理这些故障。
如果复制中的资料不会随时间而改变，那复制就很简单：将资料复制到每个节点一次就万事大吉。复制的困难之处在于处理复制资料的 **变更（change）**，这就是本章所要讲的。我们将讨论三种流行的变更复制演算法：**单领导者（single leader，单主）**，**多领导者（multi leader，多主）** 和 **无领导者（leaderless，无主）**。几乎所有分散式资料库都使用这三种方法之一。
在复制时需要进行许多权衡：例如，使用同步复制还是非同步复制？如何处理失败的副本？这些通常是资料库中的配置选项，细节因资料库而异，但原理在许多不同的实现中都类似。本章会讨论这些决策的后果。
资料库的复制算得上是老生常谈了 ——70 年代研究得出的基本原则至今没有太大变化【1】，因为网路的基本约束仍保持不变。然而在研究之外，许多开发人员仍然假设一个数据库只有一个节点。分散式资料库变为主流只是最近发生的事。许多程式设计师都是这一领域的新手，因此对于诸如 **最终一致性（eventual consistency）** 等问题存在许多误解。在 “[复制延迟问题](#复制延迟问题)” 一节，我们将更加精确地了解最终一致性，并讨论诸如 **读己之写（read-your-writes）** 和 **单调读（monotonic read）** 等内容。
## 领导者与追随者
储存了资料库复制的每个节点被称为 **副本（replica）** 。当存在多个副本时，会不可避免的出现一个问题：如何确保所有资料都落在了所有的副本上？
每一次向资料库的写入操作都需要传播到所有副本上，否则副本就会包含不一样的资料。最常见的解决方案被称为 **基于领导者的复制（leader-based replication）** （也称 **主动/被动（active/passive）** 复制或 **主/从（master/slave）** 复制），如 [图 5-1](#fig5-1.png) 所示。它的工作原理如下：
1. 其中一个副本被指定为 **领导者（leader）**，也称为 **主库（master|primary）** 。当客户端要向资料库写入时，它必须将请求传送给该 **领导者**，其会将新资料写入其本地储存。
2. 其他副本被称为 **追随者（followers）**，亦称为 **只读副本（read replicas）**、**从库（slaves）**、**备库（ secondaries）** 或 **热备（hot-standby）**[^i]。每当领导者将新资料写入本地储存时，它也会将资料变更传送给所有的追随者，称之为 **复制日志（replication log）** 或 **变更流（change stream）**。每个跟随者从领导者拉取日志，并相应更新其本地资料库副本，方法是按照与领导者相同的处理顺序来进行所有写入。
3. 当客户想要从资料库中读取资料时，它可以向领导者或任一追随者进行查询。但只有领导者才能接受写入操作（从客户端的角度来看从库都是只读的）。
[^i]: 不同的人对 **热（hot）**、**温（warm）** 和 **冷（cold）** 备份伺服器有不同的定义。例如在 PostgreSQL 中，**热备（hot standby）** 指的是能接受客户端读请求的副本。而 **温备（warm standby）** 只是追随领导者，但不处理客户端的任何查询。就本书而言，这些差异并不重要。
![](../img/fig5-1.png)
**图 5-1 基于领导者的（主/从）复制**
这种复制模式是许多关系资料库的内建功能，如 PostgreSQL（从 9.0 版本开始）、MySQL、Oracle Data Guard【2】和 SQL Server 的 AlwaysOn 可用性组【3】。它也被用于一些非关系资料库，包括 MongoDB、RethinkDB 和 Espresso【4】。最后，基于领导者的复制并不仅限于资料库：像 Kafka【5】和 RabbitMQ 高可用伫列【6】这样的分散式讯息代理也使用它。某些网路档案系统，例如 DRBD 这样的块复制装置也与之类似。
### 同步复制与非同步复制
复制系统的一个重要细节是：复制是 **同步（synchronously）** 发生的还是 **非同步（asynchronously）** 发生的。（在关系型资料库中这通常是一个配置项，其他系统则通常硬编码为其中一个）。
想象一下 [图 5-1](fig5-1.png) 中发生的场景，即网站的使用者更新他们的个人头像。在某个时间点，客户向主库传送更新请求；不久之后主库就收到了请求。在某个时间点，主库又会将资料变更转发给自己的从库。最终，主库通知客户更新成功。
[图 5-2](../img/fig5-2.png) 显示了系统各个元件之间的通讯：使用者客户端、主库和两个从库。时间从左向右流动。请求或响应讯息用粗箭头表示。
![](../img/fig5-2.png)
**图 5-2 基于领导者的复制：一个同步从库和一个非同步从库**
在 [图 5-2](../img/fig5-2.png) 的示例中，从库 1 的复制是同步的：在向用户报告写入成功并使结果对其他使用者可见之前，主库需要等待从库 1 的确认，确保从库 1 已经收到写入操作。而从库 2 的复制是非同步的：主库传送讯息，但不等待该从库的响应。
在这幅图中，从库 2 处理讯息前存在一个显著的延迟。通常情况下，复制的速度相当快：大多数资料库系统能在不到一秒内完成从库的同步，但它们不能提供复制用时的保证。有些情况下，从库可能落后主库几分钟或更久，例如：从库正在从故障中恢复，系统正在最大容量附近执行，或者当节点间存在网路问题时。
同步复制的优点是，从库能保证有与主库一致的最新资料副本。如果主库突然失效，我们可以确信这些资料仍然能在从库上找到。缺点是，如果同步从库没有响应（比如它已经崩溃，或者出现网路故障，或其它任何原因），主库就无法处理写入操作。主库必须阻止所有写入，并等待同步副本再次可用。
因此，将所有从库都设定为同步的是不切实际的：任何一个节点的中断都会导致整个系统停滞不前。实际上，如果在资料库上启用同步复制，通常意味著其中 **一个** 从库是同步的，而其他的从库则是非同步的。如果该同步从库变得不可用或缓慢，则将一个非同步从库改为同步执行。这保证你至少在两个节点上拥有最新的资料副本：主库和同步从库。这种配置有时也被称为 **半同步（semi-synchronous）**【7】。
通常情况下，基于领导者的复制都配置为完全非同步。在这种情况下，如果主库失效且不可恢复，则任何尚未复制给从库的写入都会丢失。这意味著即使已经向客户端确认成功，写入也不能保证是 **持久（Durable）** 的。然而，一个完全非同步的配置也有优点：即使所有的从库都落后了，主库也可以继续处理写入。
弱化的永续性可能听起来像是一个坏的折衷，但非同步复制其实已经被广泛使用了，特别是在有很多从库的场景下，或者当从库在地理上分布很广的时候。我们将在讨论 “[复制延迟问题](#复制延迟问题)” 时回到这个问题。
> ### 关于复制的研究
>
> 对于非同步复制系统而言，主库故障时会丢失资料可能是一个严重的问题，因此研究人员仍在研究不丢资料但仍能提供良好效能和可用性的复制方法。例如，**链式复制（chain replication）**【8,9】是同步复制的一种变体，已经在一些系统（如 Microsoft Azure Storage【10,11】）中成功实现。
>
> 复制的一致性与 **共识**（consensus，使几个节点就某个值达成一致）之间有著密切的联络，[第九章](ch9.md) 将详细地探讨这一领域的理论。本章主要讨论实践中的资料库常用的简单复制形式。
>
### 设定新从库