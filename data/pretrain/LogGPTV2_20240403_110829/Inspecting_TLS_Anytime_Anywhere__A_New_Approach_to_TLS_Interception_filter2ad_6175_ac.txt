ğ‘† â†$ {0, 1}ğœ†
(CTâˆ—, MSâˆ—) â† EIA2-TLS-KEM(ğ‘ğ‘˜ğ‘† , Ëœğ‘˜, ğœ‡âˆ—
ğ¾0 = MSâˆ—; ğ¾1 â†$ {0, 1}ğœ†â€²; ğ›½ â†$ {0, 1}
ğ›½â€² â† AEncap(ğ‘ğ‘˜ğ‘† , Ëœğ‘˜,ğœ‡âˆ—
return (ğ›½â€² = ğ›½)
Encap(ğ‘ğ‘˜ğ‘†, Ëœğ‘˜, ğœ‡âˆ—
(CT, MS) â† EIA2-TLS-KEM(ğ‘ğ‘˜ğ‘† , Ëœğ‘˜, ğœ‡ğ¶ ||ğœ‡âˆ—
ğ‘†)
return (CT, MS)
Decap(ğ‘ ğ‘˜ğ‘†, CT, ğœ‡ğ¶||ğœ‡ğ‘†)
MS â† DIA2-TLS-KEM(ğ‘ ğ‘˜ğ‘† , ğœ‡ğ¶ ||ğœ‡ğ‘†)
return MS
ğ‘†, ğœ‡ğ¶)
owâˆ’pca
A,KEM(ğ‘›) = Pr[OW-PCAA,KEM(ğ‘›) = 1].
Adv
The KEM scheme is OW-PCA secure if there exists a negligible
function ğœ–(ğ‘›) such that Adv
owâˆ’pca
A,KEM(ğ‘›) â‰¤ ğœ–(ğ‘›).
We are ready to analyze the security of IA2-TLS-KEM. Note that
it is essential to assume that the hash function H and KDF are
random oracles [2]: By choosing a static (not freshly random) value
for ğœ‡ğ¶, the adversary may be able to get some information about
PMS. However, this is alleviated by assuming the uniformity of
ğœ‡ğ‘† and the output of the random oracle H. Also, KDF should be
a random oracle to hide all the information about PMS. We now
prove the following theorem.
We define Aâ€™s advantage as
Adv
indâˆ’cca
A,IA2-TLS-KEM(ğ‘›) = Pr[CCAA,IA2-TLS-KEM(ğ‘›) = 1].
negligible function ğœ–(ğ‘›) such that Adv
The IA2-TLS-KEM scheme is IND-CCA secure if there exists a
indâˆ’cca
A,IA2-TLS-KEM(ğ‘›) â‰¤ ğœ–(ğ‘›).
Note that the adversary presented in the above definition is very
powerful in the sense that we allow it to adaptively launch chosen
ciphertext attack as well as chosen plaintext attack by choosing
its own ğœ‡ğ¶. Differently from the usual KEM, the adversary in our
notion has to have access to encapsulation oracle, as we assume (in
the threat model) that it does not know the inspection key Ëœğ‘˜ and
hence cannot compute CT alone.
We need the following definition of the OW-PCA (One-way
against Plaintext Checking Attack) [17] for the randomized KEM
to analyze the security of our IA2-TLS-KEM:
Definition 4.2 (OW-PCA for KEM). Let A be an adversary. Con-
sider the following game:
OW-PCAA,KEM(ğ‘›)
(ğ‘ ğ‘˜ğ‘† , ğ‘ğ‘˜ğ‘†) â†$ GKEM(1ğ‘›)
(CTâˆ—, PMSâˆ—) â†$ EKEM(ğ‘ğ‘˜; ğ‘Ÿ)
PMSâ€² â† APCA(ğ‘ ğ‘˜ğ‘† ,Â·,Â·) (ğ‘ğ‘˜, CTâˆ—)
return (PMSâˆ— = PMSâ€²)
We define Aâ€™s advantage as follows:
else
return 1
return 0
PCA(ğ‘ ğ‘˜ğ‘†, CT, PMS)
if PMS = DKEM(ğ‘ ğ‘˜ğ‘† , CT) then
Session 3: Network Security ASIA CCS '20, October 5â€“9, 2020, Taipei, Taiwan120Theorem 4.3. The IA2-TLS-KEM scheme is IND-CCA secure if the
underlying randomized KEM scheme is OW-PCA secure, and H and
KDF are random oracles.
Proof. The proof proceeds with the sequence of games. We
denote the event that the IND-CCA adversary A for IA2-TLS-KEM.
succeeds in each game by ğ‘†ğ‘– for ğ‘– = 0, 1, . . . .
Game 0. This is the real attack game. For the sake of presenting
notations that will be used throughout the proof, we describe the
generation of the challenge ciphertext and pre-master secret of the
IA2-TLS-KEM scheme as follows.
EIA2-TLS-KEM(ğ‘ğ‘˜ğ‘†, Ëœğ‘˜âˆ—, ğœ‡âˆ—
ğ¶||ğœ‡âˆ—
ğ‘†)
ğ¶ ||ğœ‡âˆ—
ğ‘†)
1 :
2 :
3 :
Note that the master secret is computed as follows: MSâˆ— â†
ğ‘†). As this is the same as the real attack, we have
KDF(PMSâˆ—, ğœ‡âˆ—
Pr[ğ‘†0] = Adv
Game 1. We modify the operation of the random oracle H so that
if A queries Ëœğ‘˜âˆ— is queried to H, we abort the execution of game. Let
ğ¸ be an event that ğ‘  is queried to H, respectively. We then have
ğ‘Ÿâˆ— â† H( Ëœğ‘˜âˆ—, ğœ‡âˆ—
(CTâˆ—, PMSâˆ—) â† EKEM(ğ‘ğ‘˜ğ‘†; ğ‘Ÿâˆ—)
return (CTâˆ—, PMSâˆ—)
ğ¶||ğœ‡âˆ—
indâˆ’cca
A,-KEM(ğ‘›).
| Pr[ğ‘†1] âˆ’ Pr[ğ‘†0]| â‰¤ Pr[ğ¸]
(1)
Game 2. In this game, we modify the previous game so that KDF,
which is assumed to be a random oracle, answers queries by main-
taining a query-answer list LKDF as follows.
When A makes a query (PMS, ğœ‡ğ¶||ğœ‡ğ‘†) to the random oracle
KDF, do the following.
â€¢ If [(PMS, ğœ‡ğ¶||ğœ‡ğ‘†), MS] exists in LKDF, return MS.
â€¢ Otherwise:
â€“ if [(CT, ğœ‡ğ¶||ğœ‡ğ‘†, PMS), MS] exists in LDecap, return MS and
save [(PMS, ğœ‡ğ¶||ğœ‡ğ‘†), MS] in LKDF.
â€“ Otherwise, pick a uniform MS âˆˆ {0, 1}ğœ‡ and return MS,
and save [(PMS, ğœ‡ğ¶||ğœ‡ğ‘†), MS] in LKDF.
Note that the above modification does not change the view of A
from the previous game as the modification is simply a conceptual
change that makes use of the list LKDF. Hence, we get
Pr[ğ‘†2] = Pr[ğ‘†1].
(2)
Game 3. In this game, we modify the previous game so that the
decapsulation oracle Decap responds to decapsulation queries using
a query-answer list LDecap and LKDF (defined in the previous game)
as follows.
When A makes a query (CT, ğœ‡ğ¶||ğœ‡ğ‘†) to the decapsulation oracle,
â€¢ If [(PMS, ğœ‡ğ¶||ğœ‡ğ‘†), MS] exists in LDecap, return MS.
â€¢ Otherwise:
â€“ if [(CT, ğœ‡ğ¶||ğœ‡ğ‘†, PMS), MS] exists in LDecap, return MS.
â€“ Otherwise, for each entry in [(PMS, ğœ‡ğ¶||ğœ‡ğ‘†), MS] in LKDF,
check if
do the following.
PMS = DKEM(ğ‘ ğ‘˜ğ‘†, CT).
(3)
If the equality holds, return MS. Otherwise, pick a uniform
MS âˆˆ {0, 1}ğœ‡ and return MS, and save [(CT, ğœ‡ğ¶||ğœ‡ğ‘†, PMS),
MS] in LDecap.
Note that the changes made in this game are for checking the
consistency of MSâ€™s returned by the random oracle KDF and the
decapsulation oracle. Due to uniform randomness of the output of
KDF, this modification does not change the view of A from the
previous game. Hence, we get
Pr[ğ‘†3] = Pr[ğ‘†2].
(4)
Game 4. When A queries ğœ‡ğ¶ to the Encap oracle, we pick a uniform
ğ‘Ÿ from the randomness space of KEM and a uniform ğœ‡ğ‘† âˆˆ {0, 1}ğœ† to
compute (CT, PMS) â† EKEM(ğ‘ğ‘˜ğ‘†; ğ‘Ÿ) and MS â† KDF(PMS, ğœ‡ğ¶||ğœ‡ğ‘†),
and return (CT, MS) to A. Note that because of uniform random-
ness of the output of random oracle H, (CT, MS) created in this
game is distributed identical to the one in the previous game. Thus,
we have
Pr[ğ‘†4] = Pr[ğ‘†3].
(5)
Game 5. In this game, we do not compute ğ‘Ÿâˆ— â† H( Ëœğ‘˜âˆ—, ğœ‡âˆ—
ğ¶||ğœ‡âˆ—
ğ‘†)
but pick ğ‘Ÿâˆ— uniformly at random and compute (CTâˆ—, PMSâˆ—) â†
EKEM(ğ‘ğ‘˜ğ‘†; ğ‘Ÿâˆ—) and MSâˆ— â† KDF(PMSâˆ—, ğœ‡âˆ—
where ğ¾ğ›½ is either MSâˆ— or the uniform random string of the same
length depending on ğ›½ âˆˆ {0, 1}. As A does not have access to Ëœğ‘˜âˆ—
nor have control over ğœ‡âˆ—
ğ‘†, which is chosen uniformly at random
by this game, A cannot distinguish (CTâˆ—, PMSâˆ—) from that in the
previous game. Thus, we have
ğ‘†), and return (CTâˆ—, ğ¾ğ›½),
ğ¶||ğœ‡âˆ—
Pr[ğ‘†5] = Pr[ğ‘†4]
(6)
Now, we construct an OW-PCA adversary B for KEM. B plays
the role of challenger of this game which interacts with A. In par-
ticular, B gives A the public key of KEM if B receives an encapsula-
tion query and a decapsulation quuery from A, B responds to it in
the same way this game does (as described in Games 2 and 3). Only
one difference is that when the checking PMS = DKEM(ğ‘ ğ‘˜ğ‘†, CT)
(3) is done, B does not use ğ‘ ğ‘˜ğ‘† but queries (CT, PMS) to its PCA
oracle to get the answer. Upon receiving a challenge encapsulation
request from A, B simply returns the challenge ciphertext and key
(CTâˆ—, ğ¾ğ›½) it received from its challenger. When A outputs ğ›½â€², B
simply returns the PMSâ€² which satisfies PCA(ğ‘ ğ‘˜ğ‘†, CT, PMSâ€²) = 1.
Hence, we get
ow-pca
B,KEM(ğ‘›).
Pr[ğ‘†5] = Adv
(7)
Note that as H is a random oracle, Pr[ğ¸] â‰¤ ğ‘H2â„“ , where ğ‘H denotes
the number of queries to H. Therefore, by combining (1), (2),(4), (5),
(6) and (7), we obtain
ind-cca
A,IA2-TLS-KEM(ğ‘›) â‰¤ Adv
ow-pca
B,KEM(ğ‘›) + ğ‘H
2â„“
.
(8)
Adv
â–¡
It is well known that the Diffie-Hellman is OW-PCA secure if
the The Strong Diffie-Hellman (SDH) problem [1] is hard. (The
SDH problem is a computational problem, where an adversary A,
given (ğ‘”, ğ‘”ğ‘, ğ‘”ğ‘) for the group G and access to a SDH verification
oracle (ğ‘”, ğ‘”ğ‘, Â·, Â·), is to compute ğ‘”ğ‘ğ‘.) Then we obtain the following
corollary from Theorem 4.3.
Corollary 4.4. The IA2-TLS-KEM scheme based on the Diffie-
Hellman KEM is IND-CCA secure if the SDH problem is hard, and H
and KDF are random oracles.
Session 3: Network Security ASIA CCS '20, October 5â€“9, 2020, Taipei, Taiwan121Figure 5: The Network and System Architecture
Despite of Bleichenbacherâ€™s attack, the heuristically-fixed ver-
sion of RSA PKCS #1v1.5 encryption, which addressed the attack
has been used in TLS. It is conjectured to be OW-CPA secure. Based
on this assumption and Theorem 4.3, we get the following corollary.
Corollary 4.5. The IA2-TLS-KEM scheme based on the RSA KEM
is IND-CCA secure if the RSA problem is hard, and H and KDF are
random oracles.
Extension to DHE-KEM. In the ephemeral DH-KEM (DHE-KEM),
which is mandated in TLS v1.3 [20], the (certified) serverâ€™s pub-
lic key is equivalent to the ephemeral DH value signed by the
server itself. Then by substituting CERTğ‘† = {IDğ‘†, ğ‘”ğ‘¥}CA with
{{IDğ‘†, ğ‘ğ‘˜ğ‘†ğ‘–ğ‘”ğ‘†}CA, {ğ‘”ğ‘¡}ğ‘†}, where {IDğ‘†, ğ‘ğ‘˜ğ‘†ğ‘–ğ‘”ğ‘†}CA is a certificate
for the serverâ€™s signature verification key ğ‘ğ‘˜ğ‘†ğ‘–ğ‘”ğ‘†, issued by CA,
and {ğ‘”ğ‘¡}ğ‘† is a signature on the ephemeral DH value ğ‘”ğ‘¡, the proof of
Theorem 4.3 can be extended. In this case, the PCA oracle that the
attacker has access to becomes the DDH verification oracle (ğ‘”, Â·, Â·, Â·)
which does not fix a DH value. Note that this problem is referred
to as GDH (Gap-DH) problem [17].
5 IMPLEMENTATION
5.1 System Overview
Our IA2-TLS system consists of three components, â€œIA2-TLS Clientâ€,
â€œIA2-TLS Inspectorâ€ and â€TLS Serverâ€ as illustrated in Figure 5.
â€¢ IA2-TLS Client should be realized using a customized browser.
We implemented IA2-TLS Client on the Google Chromium
browser (Version 76.0.3782.0, Developer Build, 64-bit) [26],
which is the base of the popular Chrome browser. For SS-
L/TLS communication, the Chromium browser uses Bor-
ingSSL [24], a third party cryptographic library. BoringSSL
is an abstract version of OpenSSL [25]. Although it shares
many codes and properties with OpenSSL, it supports only
limited cryptographic algorithms and functions for SSL/TLS
communication. The library offers only 18 cipher suites, in-