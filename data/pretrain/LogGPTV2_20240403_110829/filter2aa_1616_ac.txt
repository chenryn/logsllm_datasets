程序感染完毕退出为止
程序感染完毕退出为止。
•
3 对于虚拟机启发式检测来说，连续的病毒代码操作，是容易被当作可疑行
为的
如连续的内存地址解密
查找kernel32基址
等等
为的，如连续的内存地址解密，查找kernel32基址，等等...
•
4 像Nexiv_der 病毒那样，病毒代码的执行与具体环境有关，增加分析的难
度。
•
5  所以将病毒的DNA函数分段的与宿主程序混合，在很大程度上起到对抗虚
拟机检测的的功能
要做到的是尽量和宿主程序同步结束
而不是上来就获
拟机检测的的功能。要做到的是尽量和宿主程序同步结束，而不是上来就获
得控制权，也不是最后获得控制权
构造宿主/病毒的双执行环境
构造宿主/病毒的双执行环境
• 双执行环境下控制流关系：
h
t1
h
t2
h
t3
h
t4
END
host1
host2
host3
host4
END
virus1
virus2
virus3
virus4
virus1
virus2
virus3
virus4
怎样构造宿主/病毒的双执行环境？
怎样构造宿主/病毒的双执行环境？
首要任务是保存宿主程序的当前运行时寄存器的值host rgs ctx，及病毒程序运行
首要任务是保存宿主程序的当前运行时寄存器的值host_rgs_ctx，及病毒程序运行
时的寄存器值virus_rgs_ctx.
方案1） 宿主，病毒共用esp滑动，把宿主/病毒的数据保存在堆栈的低端地址处，每次
方案 ） 宿主，病毒共用
p滑动，把宿主/病毒的数据保存在堆栈的低端地址处，每次
执行时读取和恢复。存在的问题是，可能宿主程序本身的操作会覆盖掉这些值，导致
意想不到的崩溃。
•
方案2）
alloc 一段空间，分别给host ，virus 用， 但在执行stub 区域时，运行
DNA(1),DNA(2)时并没有获得具体病毒使用的API地址，不能使用alloc 函数，无法分
配，如果这些操作写入DNA(1)中，可能会引起启发式扫描器的怀疑。
•
•
方案3）
宿主程序的寄存器组在stub区域用pusha/fd ，popa/fd 保存及恢复，病毒
DAN执行后保存寄存器值到病毒变量环境中，本文采用方案3）方式。
•
•
在执行病毒DNA(1) 时，保存ebp的值到某处，因为执行过程中ebp值可能会变，而此时
还不知道病毒的具体变量地址，故只能写入代码中间的空间处保存。
宿主/病毒的双执行环境实现
宿主/病毒的双执行环境实现
• 除病毒DNA(1)外，每一个病毒DNA函数的开头和结尾都需
要调用保存病毒寄存器的函数，例如：
• my_DNA proc
• ...
• call my_restore_ctx_to_rgs ; 恢复上次执行病毒DNA函
数时的寄存器环境到当前的真实cpu寄存器中
• ...                                        
• call my_save_rgs_to_ctx     ; 保存本次操作的后的真
实cpu寄存器环境到病毒自身的寄存器环境。
实cpu寄存器环境到病毒自身的寄存器环境。
• ret                                       
• my DNA endp
y_
p
宿主/病毒的双执行环境实现
宿主/病毒的双执行环境实现
• 注意事项：
• 因为选择的交叉点可能存在于宿主程序不同分支中，所以
因为选择的交叉点可能存在于宿主程序不同分支中，所以
可能存在同一病毒DNA函数多次调用的可能，故需要为每
一个DNA函数设定一个序号（0 ～ n），判断符合当前序
号后，才能继续执行，例如：
号后，才能继续执行，例如：
•
my_get_k32_base_addr proc
ll
•
call my_restore_ctx_to_rgs     ;首先恢复病毒寄存器环境
•
cmp [ebp].vir_cur_exec_dna,1   ;检测是否是执行序号1
•
jnz  k_exit
•
mov [ebp].vir_cur_exec_dna,2   ;执行序号加1为下一个DNA做函数判断依据。
•
my_get_k32_base_addr proc         
宿主/病毒及感染后的重定位
宿主/病毒及感染后的重定位
•
重定位的方式有两种：
1
种是在分析完
个交叉点后就进行重定位
但这要有
个固定值
•
1一种是在分析完一个交叉点后就进行重定位，但这要有一个固定值
的边界值，也就是stub的大小要固定，用此作为重定位的相对开始位
置，病毒的其它代码以此位置为开始位置。(本文使用了该方式)
•
优点：编写容易
•
缺点：容易被静态启发检测跟踪
•
2一种是在病毒的stub区域生成后，对所有的交叉点统一进行重定位，
但这要记得下每一个要重定位的位置偏移，比较麻烦。
•
优点：可生成大小自由可控制stub区域，有效对抗静态启发分析。
•
缺点：重定位的过程比较麻烦
涉及到的重定位类型
涉及到的重定位类型
• 1  对于宿主程序交叉点的重定位修正
• 2  病毒自身DNA函数的重定位
• 3
Safe-API 的重定位
• 3  Safe API 的重定位
• 4  跳回宿主程序的重定位
•
对于宿主程序交叉点的重定位修正
对于宿主程序交叉点的重定位修正
•
原始宿主程序/修改后的宿主程序/病毒stub :
对于宿主程序交叉点的重定位修正
对于宿主程序交叉点的重定位修正
• 1  获得宿主程序的虚拟地址va_host_addr
• 2  获得病毒stub部分的虚拟地址va_vir_stub_start
3
获得当前要写入的地址相对 t b部分的偏移值
• 3  获得当前要写入的地址相对stub部分的偏移值
• vir_off = raw_edi - raw_stub
• 4  要跳向的目的地址
• va_vir_cross = va_vir_stub_start + vir_off
• 5  修改宿主程序的重定位值
• dif
i
h
t
dd
5
• dif =  va_vir_cross -
va_host_addr - 5
病毒自身DNA函数的重定位
病毒自身DNA函数的重定位
• 1  计算病毒DNA函数相对v_code的偏移off1
• 2
计算当前要写入的位置距离stub开头的偏移off2
2  计算当前要写入的位置距离stub开头的偏移off2
• 3  自身重定位的值dif = off1+off2 -5  
.code                             
Start: 
call my_DAN1
ll
DNA2
call my_DNA2
...
v_code:                          
i
l d
" i
1 i
include vir_xx1.inc"
include "vir_xx2.inc"
...
vEnd:
vEnd:                            
END Start 
Safe API 的重定位
Safe-API 的重定位
•
1 获得Safe-API虚拟地址va_sf_off
•
2 获得病毒 t b部分的虚拟地址
i
t b
t
t
•
2 获得病毒stub部分的虚拟地址va_vir_stub_start
•
3 获得当前要写入的地址相对stub部分的偏移值
•
vir_off = raw_edi - raw_stub
•
4 获得当前要写入Safe-API的虚拟地址
•
va_vir_cur  = va_vir_stub_start + vir_off 
•
5 要跳向Safe-API的数值
要跳向
的数值
•
dif  = va_off - va_sf_off - 5
•
跳回宿主程序的重定位方式同上面方式类似，不在赘述
跳回宿主程序的重定位方式同上面方式类似，不在赘述。
完整的遗传感染变形方式
完整的遗传感染变形方式
•
1 stub 部分已经可随机的产生和宿主混合的代码，同时具备对抗动态虚拟
机，静态启分析的功能。
后面的病毒代码以变形的形式生产
分为两部分
•
2 后面的病毒代码以变形的形式生产，分为两部分，
•
1)加密的指令模板
•
2)生产的变形代码空间
•
3 辅助引擎:
•
1)微型的变形引擎 2)指令生成器（MIG） 3)无效指令生成器。
•
•
感染后扩展为
(1)stub 
(1)宿主/病毒/Safe-API/混淆指令/垃圾数据
(2)生产新的混淆代码
(2)变形代码空间
(3)指令模板
(3)加密的指令模板
(4)随机产生垃圾数据
( )随机产
圾数据
完整的遗传感染变形方式
完整的遗传感染变形方式
微型的变形引擎
•
微型的变形引擎：
•
MICRO_META_DATA  STRUC
•
MMD ROUTINE      DD   ; 指令处理例程
_
; 指令处
例程
•
MMD_SIGNED       DB   ; 可否扩展
•
MMD_OPCODE       DB   ; 指令的识别码
•
MICRO_META_DATA  ENDS 
•
dd
offset mmd_stosw       ==>   66:AB     stos word ptr es:[edi]               
•
db
1,66h,2,0ABh,0        (*)-->66:8907    mov  word ptr ds:[edi],ax
•
(*)--> 83C7 02   add  edi, 2
,
•
dd
offset mmd_push_exx    ==>   52        push edx
•
db
-1,50h,0              (*)--> ff f2     push edx
•
(*)
> 50
pu h
•
(*)--> 50        push eax
•
8b c3     mov  eax,ebx
•
50        push eax
•
58        pop  eax
遗传感染思路的扩展
遗传感染思路的扩展
•
发挥想象力，构造出更多可利用的病毒基因？
•
因为普通的病毒程序基因我们分别是提取了执行过程中的几个部分，如果是加密病毒
呢？假设一个普通的加密病毒使用如下方式加密。
•
algo1 (add/xor/sub)   --
key1
•
algo2 (rol/ror)       --
key2
•
要加密的数据x，加密后的数据y
•
x = algo1 （key1 ，x）
•
y = algo2 （key2，x ）
•
我们可以把解密的汇编代码拆解为若干个部分
•
mov ecx，VIRUS_SIZE             --------------------- (1)
•
mov edi, offset ENCRYPT_DATA    --------------------- (2)
•
de code:
_
•
add/xor/sub dword ptr[edi],key1 --------------------- (3)
•
rol/ror   key2                  --------------------- (4)
•
add edi,
4
add edi,  4                     --------------------- (5)
(5)
•
loop  de_code                      --------------------- (6)
遗传感染思路的扩展
遗传感染思路的扩展
• 1拆解的每一条指令都是当作病毒的DNA函数，混杂在无
效指令当中，当作一个DNA执行函数。
• 2在这个解密算法当中，还可以加入一些不影响解密的指
令进来，每次调整这些指令顺序，这样DNA函数本身就具
有了可变的顺序 可以生产多种组合方式
有了可变的顺序,可以生产多种组合方式。
• 3对于(3)，(4)，(5)，(6)包含loop的结构，需要靠执行
3对于(3)，(4)，(5)，(6)包含loop的结构，需要靠执行
序号判断是否执行到了DNA(6),对于执行到DNA(6)后，3，
4，5自动跳向下一个DNA函数，而不是ret。当然这样的
做法会导致产生的DNA函数比较空间占用较大，因为填充
做法会导致产生的DNA函数比较空间占用较大，因为填充
过程的指令数量是随机产生的。
解密完成后
跳向病毒代码空间执行
• 4解密完成后，跳向病毒代码空间执行。
遗传感染思路的扩展
遗传感染思路的扩展
•
解密代码做病毒DNA的情况：
遗传感染思路的扩展
遗传感染思路的扩展
• 如果加/解密的方式更加复杂？
• 如果可以对变形病毒提取基因？
如果可以对变形病毒提取基因？
• 如果利用遗传感染做“外壳”，解密后的是木马
程序？
• 如果不使用Safe-API,改从
MSVBVM60.dll ,MFC*.dll中寻找一些”东西“来
做变异？
做变异？
• ...
这种遗传感染的思路足可以对抗反病毒程序的检
• 这种遗传感染的思路足可以对抗反病毒程序的检