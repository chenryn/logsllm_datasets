### 程序感染完毕退出为止

程序在感染完毕后退出。

### 虚拟机启发式检测中的可疑行为

对于虚拟机启发式检测，连续的病毒代码操作很容易被标记为可疑行为。例如，连续的内存地址解密和查找 `kernel32` 基址等操作都会引起怀疑。

### 病毒代码执行与环境的关系

类似 `Nexiv_der` 病毒，病毒代码的执行依赖于具体的环境，这增加了分析的难度。

### 对抗虚拟机检测的方法

将病毒的 DNA 函数分段并与宿主程序混合，在很大程度上可以对抗虚拟机检测。关键在于尽量与宿主程序同步结束，而不是立即或最后获得控制权。通过构造宿主/病毒的双执行环境，可以实现这一目标。

#### 双执行环境下的控制流关系
```
t1 (h) -> t2 (h) -> t3 (h) -> t4 (h) -> END
host1 -> host2 -> host3 -> host4 -> END
virus1 -> virus2 -> virus3 -> virus4 -> virus1 -> virus2 -> virus3 -> virus4
```

### 如何构造宿主/病毒的双执行环境？

首要任务是保存宿主程序的当前运行时寄存器值 `host_rgs_ctx` 以及病毒程序运行时的寄存器值 `virus_rgs_ctx`。

**方案 1: 共用 ESP 滑动**
- 宿主和病毒共用 ESP 滑动，将数据保存在堆栈的低端地址处，每次执行时读取和恢复。
- 存在的问题：宿主程序的操作可能会覆盖这些值，导致意外崩溃。

**方案 2: 分配独立空间**
- 为宿主和病毒分配独立的空间，但在执行 stub 区域时，无法使用 `alloc` 函数分配空间，因为此时尚未获得具体病毒使用的 API 地址。如果将这些操作写入 DNA(1)，可能会引起启发式扫描器的怀疑。

**方案 3: 使用 pusha/fd 和 popa/fd**
- 在 stub 区域使用 `pusha/fd` 和 `popa/fd` 保存和恢复宿主程序的寄存器组。病毒执行后，将寄存器值保存到病毒变量环境中。本文采用此方案。

在执行病毒 DNA(1) 时，保存 EBP 的值到某处，因为执行过程中 EBP 值可能会变，而此时还不知道病毒的具体变量地址，故只能写入代码中间的空间处保存。

### 宿主/病毒的双执行环境实现

除了病毒 DNA(1) 外，每个病毒 DNA 函数的开头和结尾都需要调用保存病毒寄存器的函数，例如：
```assembly
my_DNA proc
...
call my_restore_ctx_to_rgs ; 恢复上次执行病毒 DNA 函数时的寄存器环境
...
call my_save_rgs_to_ctx   ; 保存本次操作后的 CPU 寄存器环境
ret
my_DNA endp
```

### 注意事项

由于选择的交叉点可能存在于宿主程序的不同分支中，可能存在同一病毒 DNA 函数多次调用的情况。因此，需要为每个 DNA 函数设定一个序号（0 到 n），判断符合当前序号后才能继续执行。例如：
```assembly
my_get_k32_base_addr proc
call my_restore_ctx_to_rgs     ; 首先恢复病毒寄存器环境
cmp [ebp].vir_cur_exec_dna, 1  ; 检测是否是执行序号 1
jnz k_exit
mov [ebp].vir_cur_exec_dna, 2 ; 执行序号加 1 为下一个 DNA 函数判断依据
...
my_get_k32_base_addr endp
```

### 宿主/病毒及感染后的重定位

重定位方式有两种：
1. **固定边界值重定位**：在分析完一个交叉点后进行重定位，但需要一个固定的边界值，即 stub 的大小固定。
   - 优点：编写容易。
   - 缺点：容易被静态启发检测跟踪。
2. **统一重定位**：在病毒的 stub 区域生成后，对所有交叉点统一进行重定位。
   - 优点：可生成大小自由可控的 stub 区域，有效对抗静态启发分析。
   - 缺点：重定位过程比较麻烦。

#### 涉及的重定位类型
1. 宿主程序交叉点的重定位修正。
2. 病毒自身 DNA 函数的重定位。
3. Safe API 的重定位。
4. 跳回宿主程序的重定位。

### 宿主程序交叉点的重定位修正

1. 获得宿主程序的虚拟地址 `va_host_addr`。
2. 获得病毒 stub 部分的虚拟地址 `va_vir_stub_start`。
3. 获得当前要写入的地址相对 stub 部分的偏移值 `vir_off = raw_edi - raw_stub`。
4. 计算要跳向的目的地址 `va_vir_cross = va_vir_stub_start + vir_off`。
5. 修改宿主程序的重定位值 `dif = va_vir_cross - va_host_addr - 5`。

### 病毒自身 DNA 函数的重定位

1. 计算病毒 DNA 函数相对 `v_code` 的偏移 `off1`。
2. 计算当前要写入的位置距离 stub 开头的偏移 `off2`。
3. 自身重定位的值 `dif = off1 + off2 - 5`。

### Safe API 的重定位

1. 获得 Safe-API 虚拟地址 `va_sf_off`。
2. 获得病毒 stub 部分的虚拟地址 `va_vir_stub_start`。
3. 获得当前要写入的地址相对 stub 部分的偏移值 `vir_off = raw_edi - raw_stub`。
4. 获得当前要写入 Safe-API 的虚拟地址 `va_vir_cur = va_vir_stub_start + vir_off`。
5. 计算要跳向 Safe-API 的数值 `dif = va_off - va_sf_off - 5`。

### 完整的遗传感染变形方式

1. **随机生成 stub 部分**：已经可以随机生成与宿主混合的代码，同时具备对抗动态虚拟机和静态启发分析的功能。
2. **病毒代码变形生产**：分为两部分：
   - 加密的指令模板
   - 生产的变形代码空间
3. **辅助引擎**：
   - 微型变形引擎
   - 指令生成器（MIG）
   - 无效指令生成器

感染后扩展为：
- stub 部分
- 宿主/病毒/Safe-API/混淆指令/垃圾数据
- 生产新的混淆代码
- 变形代码空间
- 加密的指令模板
- 随机产生的垃圾数据

### 微型变形引擎

微型变形引擎结构：
```assembly
MICRO_META_DATA  STRUC
MMD_ROUTINE      DD   ; 指令处理例程
MMD_SIGNED       DB   ; 可否扩展
MMD_OPCODE       DB   ; 指令的识别码
MICRO_META_DATA  ENDS 
```

示例：
```assembly
dd offset mmd_stosw       ==> 66:AB stos word ptr es:[edi]               
db 1,66h,2,0ABh,0        (*)--> 66:8907 mov  word ptr ds:[edi],ax
(*)--> 83C7 02 add  edi, 2
dd offset mmd_push_exx    ==> 52 push edx
db -1,50h,0              (*)--> ff f2 push edx
(*)--> 50 push eax
8b c3 mov  eax,ebx
50 push eax
58 pop  eax
```

### 遗传感染思路的扩展

1. **拆解每条指令作为 DNA 函数**：混杂在无效指令中，当作一个 DNA 执行函数。
2. **加入不影响解密的指令**：每次调整这些指令顺序，使 DNA 函数具有可变的顺序，可以生产多种组合方式。
3. **包含 loop 的结构**：需要靠执行序号判断是否执行到了 DNA(6)，对于执行到 DNA(6) 后，3、4、5 自动跳向下一个 DNA 函数，而不是 ret。这种做法会导致 DNA 函数占用较大空间，因为填充过程的指令数量是随机产生的。
4. **解密完成后**：跳向病毒代码空间执行。

### 进一步扩展

- **复杂加密/解密方式**：如何处理更复杂的加/解密？
- **提取变形病毒基因**：如何从变形病毒中提取基因？
- **利用遗传感染做外壳**：解密后执行木马程序？
- **不使用 Safe-API**：从 `MSVBVM60.dll` 或 `MFC*.dll` 中寻找替代方法？

这种遗传感染的思路足以对抗反病毒程序的检测。