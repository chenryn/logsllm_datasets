systems based on the discrete logarithm problem,” Ph.D.
dissertation, ETH Zürich, 1998.
[21] M. Chase and A. Lysyanskaya, “On signatures of knowledge,”
in CRYPTO, vol. 4117 of LNCS, 2006, pp. 78–96.
[22] D. Chaum, “Security without identiﬁcation: transaction systems
to make big brother obsolete,” Communications of the ACM,
1985. [Online]. Available: http://doi.acm.org/10.1145/4372.4373
J. Clark and A. Essex, “Commitcoin: Carbon dating com-
mitments with bitcoin,” in Financial Cryptography and Data
Security. Springer, 2012, pp. 390–398.
[23]
[24] S. Coull, M. Green, and S. Hohenberger, “Access controls for
oblivious and anonymous systems,” in TISSEC, 2011.
[25] R. Cramer, I. Damgård, and B. Schoenmakers, “Proofs of partial
knowledge and simpliﬁed design of witness hiding protocols,”
in CRYPTO, 1994.
I. Damgård, K. Dupont, and M. Ø. Pedersen, “Unclonable
group identiﬁcation,” ser. EUROCRYPT, 2006.
[Online].
Available: http://dx.doi.org/10.1007/11761679_33
[26]
[27] W. Difﬁe and M. Hellman, “New directions in cryptography,”
IEEE Transactions on Information Theory, 1976.
[28] Y. Dodis and A. Yampolskiy, “A veriﬁable random function
[29]
[30]
with short proofs and keys,” ser. PKC, 2005.
“Dot-bit,” Available at http://dot-bit.org/. [Online]. Available:
http://dot-bit.org/
J. R. Douceur, “The sybil attack,” in Peer-to-Peer Systems, 2002.
[Online]. Available: http://link.springer.com/chapter/10.1007/3-
540-45748-8_24
[31] A. Fiat and A. Shamir, “How to prove yourself: Practical
solutions to identiﬁcation and signature problems,” in CRYPTO,
1986.
[32] E. Fujisaki and T. Okamoto, “Statistical zero knowledge
protocols to prove modular polynomial relations,” in CRYPTO,
1997.
[33] O. Goldreich, S. Goldwasser, and S. Micali, “How to construct
random functions,” Journal of the ACM, 1986.
[34] O. Goldreich, S. Micali, and A. Wigderson, “Proofs that yield
nothing but their validity and a methodology of cryptographic
protocol design,” in FOCS, 1986.
J. Groth, “Non-interactive zero-knowledge arguments for voting,”
in Applied Cryptography and Network Security. Springer, 2005,
pp. 467–482.
[35]
[36] M. Z. Lee, A. M. Dunn, B. Waters, E. Witchel, and J. Katz,
“Anon-pass: Practical anonymous subscriptions,” in IEEE Secu-
rity and Privacy, 2013.
[37] H. Lipmaa, “On diophantine complexity and statistical zero-
knowledge arguments,” in Advances in Cryptology-ASIACRYPT
2003. Springer, 2003, pp. 398–415.
I. Miers, C. Garman, M. Green, and A. Rubin, “Zerocoin:
Anonymous distributed e-cash from bitcoin,” in IEEE Security
and Privacy, 2013.
[38]
[39] S. Nakamoto, “Bitcoin: A peer-to-peer electronic cash system,”
[40]
2008.
“Namecoin,” Available at http://namecoin.info/.
Available: http://namecoin.info/
[Online].
[41] M. Naor and O. Reingold, “Number-theoretic constructions
of efﬁcient pseudo-random functions,” Journal of the ACM
(JACM), 2004.
[42] T.-W. J. Ngan, D. S. Wallach, and P. Druschel, “Enforcing fair
sharing of peer-to-peer resources,” in Peer-to-Peer Systems II,
2003. [Online]. Available: http://link.springer.com/chapter/10.
1007/978-3-540-45172-3_14
13
[43] D. Obenshain, T. Tantillo, A. Newell, C. Nita-Rotaru, and
Y. Amir, “Intrusion-tolerant cloud monitoring and control,” in
LADIS, 2012.
[44] B. Parno, C. Gentry, J. Howell, and M. Raykova, “Pinocchio:
Nearly practical veriﬁable computation,” in Proceedings of the
34th IEEE Symposium on Security and Privacy, ser. Oakland ’13,
2013, pp. 238–252.
[45] T. Pedersen, “Non-interactive and information-theoretic secure
veriﬁable secret sharing,” in CRYPTO, 1991.
[46] R. L. Rivest, A. Shamir, and Y. Tauman, “How to leak a secret,”
in ASIACRYPT, 2001.
[47] T. Sander and A. Ta-Shma, “Auditable, anonymous electronic
cash (extended abstract),” in CRYPTO, 1999.
[48] C.-P. Schnorr, “Efﬁcient signature generation for smart cards,”
Journal of Cryptology, vol. 4, no. 3, pp. 239–252, 1991.
[49] H. Shacham and B. Waters, “Compact proofs of retrievability,”
in Advances in Cryptology-ASIACRYPT 2008. Springer, 2008,
pp. 90–107.
[50] R. Snader and N. Borisov, “Eigenspeed: secure peer-to-peer
bandwidth evaluation.” in IPTPS, 2009, p. 9.
APPENDIX A
PROOF SKETCH OF SECURITY FOR OUR BASIC SYSTEM
We now provide a sketch of the proof of security for our
basic distributed anonymous credentials system.
Our basic approach is to show that for every real-world
adversary A against the credential system, we can construct an
ideal-world adversary S against the ideal-world system such
that the transcript of A interacting with the real system is
computationally indistinguishable from the transcript produced
by A interacting with S. We assume a static corruption model
in which the adversary controls some set of users and leave a
proof in the adaptive corruption model for future work. For this
sketch we also assume that our zero-knowledge signatures of
knowledge include an efﬁcient extractor and simulator and that
the params are created using a trusted setup process. Note
that in the random oracle model this assumption holds for the
Fiat-Shamir proofs we employ, provided we conduct the proofs
sequentially.
Our proof assumes the existence of a global,
trusted
transaction ledger, which we use as a black box. We leave
a complete proof that considers this construction and models
it to future work.
We begin by sketching the simulator S for our system.
A. Description of the Simulator
Minting a credential. When a user controlled by the adversary
with nym Nym O
U wants a credential, the user ﬁrst generates
(c, ⇡M , attrs). When the simulator receives notiﬁcation of this,
it ﬁrst veriﬁes that the credential and proof are valid and
meet the organization’s policy. If so it employs the knowledge
extractor for the signature of knowledge on ⇡M to obtain
(sk , aux).
The simulator
(U, sk , Nym O
and nym Nym O
then checks
it has a record of
U ) on its list of users. If the user with key sk
U exists, then S retrieves sk U associated with
if
is not on the list,
U ) and proceeds. If it
(U, sk , Nym O
the
simulator checks if it has previously seen a user with key
sk. If the user with key sk is not present, then the simulator
creates a user U and runs RegN ym(Nym O
U , U, O) to register
Nym O
U and obtain sk U for further interactions with TP . S
then stores (U, sk , sk U , Nym O
U ) in its list of users controlled
by the adversary. If a user U with key sk exists, then it runs
RegN ym(Nym O
U and adds Nym O
U
to U’s record.
U , U, O) to register Nym O
Once the simulator has registered the nym or veriﬁed it
already exists, it runs M intCred(Nym O
U , O, attrs, aux). The
simulator then transmits the credential information to the trusted
store and acknowledges the credential’s issuance. S stores
(sk , Nym O
U , attrs, aux, c,⇡ M ) in its list of granted credentials.
When an honest user, through TP , wants to establish a
credential, the simulator creates a credential c (using the
publicly available attrs) and uses the simulator for the signature
of knowledge ⇡M to simulate the associated proof. It then
transmits the credential information (c, ⇡M , attrs) to the trusted
store.
Showing a credential. When a user controlled by the adversary
wants to show a credential from organization O to veriﬁer V
with which it has nyms Nym O
U respectively, the
user ﬁrst generates ⇡S. When the simulator receives notiﬁcation
of this, it veriﬁes the proof as in the real protocol (rejecting
if it is invalid). If the show veriﬁes, it runs the knowledge
extractor for the proof of knowledge on ⇡S to get sk.
U and Nym V
The simulator then checks if it has a record of (U, sk ,
Nym O
U , Nym V
U ) on its list of users. If the user with key sk
and nyms Nym O
U and Nym V
U exists, then S retrieves sk U
associated with (U, sk , Nym O
U ) and proceeds. If the record
does not exist, either in part or in full, the simulator checks
if it has previously seen a user with key sk. If the user with
key sk is not present, then the simulator creates a user U and
runs RegN ym(Nym O
U , U, O) and RegN ym(Nym V
U , U, V ) to
register Nym O
U and obtain sk U for further inter-
U , Nym V
actions with TP . S then stores (U, sk , sk U , Nym O
U )
in its list of users controlled by the adversary. If a user U
with key sk exists, then it runs RegN ym(Nym O
U , U, O) (resp.
RegN ym(Nym V
U ) and
adds Nym O
U , U, V )) to register Nym O
U ) to U’s record.
U (resp. Nym V
U (resp. Nym V
U and Nym V
Now, the simulator S runs ShowOnN ym(Nym O
U , Nym V
U ,
O, V, C) where C is obtained by the simulator through a call
to GetCredList(O).
When an honest user (through TP ) wants to show a
credential to a veriﬁer V controlled by the adversary, the
simulator generates a random prime commitment and runs
the zero-knowledge simulator for ⇡S to simulate a proof that
it then sends to V .
1) Proof (sketch) of a Successful Simulation: Our simulation
is computationally indistinguishable from the real protocol if
the Strong RSA and the Discrete Logarithm assumptions hold.
While we do not provide a full proof here due to space reasons,
we provide an overview of the argument for security.
14
We ﬁrst begin by discussing the signatures/proofs ⇡M
and ⇡S. Under the Discrete Logarithm assumption, ⇡M is
a computational zero-knowledge signature of knowledge on
aux of the values sk, r, and r0 such that the nym Nym O
U
and the credential c both belong to the same master secret
sk. The proof is constructed using standard techniques in
the random oracle model [48], and the resulting proofs are
(at least) computationally zero knowledge. An attacker who
forges this proof to spend a new coin would violate the
soundness guarantee of the proof system. Alternatively, an
attacker might forge this message by identifying a collision
on the commitments, which occurs with negligible probability
under the Discrete Logarithm assumption [45]. In the event that
this occurs, we can use the extractor for the zero knowledge
proof to obtain the collision with all but negligible probability.
Under the Strong RSA and Discrete Logarithm assumptions,
⇡S is a statistical non-interactive zero-knowledge proof of
knowledge of the values sk, !, c, Nym V
U , r, and r0 such that !
is a witness that c is in the accumulator A and nym Nym V
U and
the credential c both belong to the same master secret sk. This
proof is again constructed using standard techniques [15, 48]
similar to the proofs used by Miers et al. in [38]. In order
to forge such a proof, the adversary would need to either
ﬁnd a collision on the commitments or forge an accumulator
membership proof. We previously discussed how the ﬁrst case
occurs with negligible probability. The second case occurs
with negligible probability under the Strong RSA assumption
due to [15]. See the full version of the paper for a formal
treatment/reduction of these statements.
Intuitively, we can now see that the simulator will fail with
at most negligible probability because it deals solely with zero-
knowledge signatures of knowledge and zero-knowledge proofs
of knowledge, which have efﬁcient extractors and simulators.
Our proofs ⇡M and ⇡S have knowledge extractors that succeed
with probability 1   ⌫( ) for some negligible function ⌫(·).
Since signatures and proofs are the sole point of failure for our
simulator described above, it fails with negligible probability.
Because the adversary only sees the simulated zero-knowledge
proofs and signatures, and the simulated signatures and proofs
are computationally indistinguishable from legitimate ones, the
adversary cannot distinguish a simulated transcript from the real
protocol except with negligible advantage. Hence the adversary
cannot distinguish between an interaction with the simulator
and the real protocol.
We note that the Pedersen commitments we use are non-
standard in that we output only commitments that are prime. We
stress that these commitments remain information theoretically
hiding and computationally binding under the assumption that
the Discrete Logarithm assumption holds in hgi.
15