# Proactive Recovery in Distributed CORBA Applications

**Authors:**
Soila M. Pertet and Priya Narasimhan  
Electrical & Computer Engineering Department  
Carnegie Mellon University  
5000 Forbes Avenue, Pittsburgh, PA 15213-3890  
Email: [PI:EMAIL], [PI:EMAIL]

## Abstract
Unanticipated runtime events, such as faults, can lead to missed deadlines in real-time systems. While it is not always possible to predict when a fault will occur, we can sometimes exploit pre-fault "symptoms" to initiate proactive (rather than reactive) fault recovery. In this paper, we describe the design and implementation of a proactive recovery strategy for distributed CORBA applications in the presence of resource-exhaustion faults. We analyze the effect of different proactive recovery schemes on client/server response times and demonstrate a significant reduction in both jitter and the number of client-side failures.

## 1. Introduction
Middleware platforms, such as CORBA and Java, are increasingly being adopted because they simplify application programming by abstracting low-level details of networking, distribution, physical location, hardware, operating systems, and byte order. As CORBA and Java have come to support various "ilities" (e.g., reliability, real-time, security), these middleware platforms have become even more attractive for applications requiring high quality of service. The push for Commercial-Off-The-Shelf (COTS) products, along with recent support for "ilities" within middleware, has furthered their adoption in mission-critical applications.

Mission-critical systems, such as avionics and drive-by-wire systems, have stringent reliability and availability requirements and need to exhibit both real-time and fault-tolerance properties. The Object Management Group (OMG) CORBA standard has attempted to address these needs by developing separate Real-Time and Fault-Tolerance specifications. However, due to inherent conflicts in providing simultaneous real-time and fault-tolerance support, it is not possible for today's CORBA applications to obtain both guarantees through straightforward adoption of the CORBA standards. The difficulty arises because real-time systems require predictable end-to-end schedules and bounded temporal behavior to meet task deadlines, while faults are unanticipated system events that can disrupt predefined real-time schedules and result in missed task deadlines. Our preliminary measurements show that faults can disrupt a Real-Time CORBA application, leading to unbounded and variable fault-detection and fault-recovery times.

The MEAD (Middleware for Embedded Adaptive Dependability) system, which we are developing at Carnegie Mellon University, aims to reconcile the conflicts between real-time and fault-tolerance properties in a resource-aware manner. One novel aspect of the MEAD system is its use of a proactive dependability framework to lower the impact of faults on a distributed application's real-time schedule. Proactive dependability involves designing and implementing mechanisms that can predict, with some confidence, when a failure might occur and compensating for the failure before it happens. For example, if we knew that a node had an 80% chance of failing within the next 5 minutes, we could migrate all of its hosted processes to another working node in the system, aiming to meet the application's real-time deadlines. This proactive process-migration would incur a lower penalty than waiting for the process to crash before taking action. This proactive approach contrasts with the reactive fault-tolerance strategy adopted by the Fault-Tolerant CORBA standard, which first waits to detect a fault and then initiates fault-recovery mechanisms. In this paper, we show that by developing such a proactive strategy, we can not only mask the occurrence of faults from the clients of our application but also reduce jitter and latency spikes that manifest when faults occur during real-time operations.

There are two aspects to proactive dependability: the ability to predict failures and the mechanisms to compensate for them, ideally before they occur. We recognize that some failures may be so abrupt that prediction is impossible, such as someone accidentally unplugging a power supply. However, many computer-related faults are often preceded by visible patterns of abnormal behavior, making prediction feasible. These failures typically result from gradual degradation, like resource exhaustion, or from transient and intermittent hardware faults, such as disk crashes or telecommunication equipment failures. Because it is not always possible to predict every type of fault, proactive dependability complements, and in some cases outperforms, traditional reactive fault-tolerance schemes.

Our goal is to provide bounded fault-recovery times for distributed real-time applications, allowing the support of both fault-tolerance and real-time properties for predictable classes of faults. In this paper, we focus on the mechanisms needed to implement proactive recovery in a distributed CORBA-based system. We do not develop new failure-prediction techniques; instead, we use relatively simple failure-prediction mechanisms within the MEAD system and show how to use these predictions to develop a proactive recovery strategy that minimizes jitter and latency spikes experienced by distributed applications in the presence of faults. This paper makes the following contributions:

- Describes the development of a transparent, proactive recovery infrastructure for distributed CORBA applications.
- Discusses the design choices in implementing a proactive strategy and their impact on client-to-server response times and client-side fail-over times.
- Presents empirical evaluation and measurements to quantify the overhead and performance of our proactive strategy compared to the classical reactive fault-tolerance approach.

While we use CORBA as the vehicle for our investigations, our techniques are largely independent of CORBA. In cases where we leverage CORBA-specific mechanisms, we highlight these to ensure our proactive strategy can be extended to non-CORBA-based distributed applications.

## 2. Related Work
Huang et al. [5] proposed a proactive approach called software rejuvenation for handling transient software failures. Software rejuvenation involves gracefully halting an application once errors accumulate beyond a specified threshold and then restarting the application in a clean internal state. Subsequent work in software rejuvenation has focused on constructing policies that increase system availability and reduce the cost of rejuvenation [2, 4, 20]. We found that simply restarting a faulty server with ongoing client transactions can lead to unacceptable jitter and missed real-time deadlines at the client. Our work focuses on the mechanisms needed to gracefully hand off existing clients on faulty CORBA servers at the onset of the rejuvenation threshold.

Castro and Liskov [3] describe a proactive recovery scheme for Byzantine fault-tolerant systems. In their system, clients detect a faulty primary by timing out and retransmitting their requests to all replicas in the group, potentially increasing jitter at the client. Our system uses proactive notifications to lower fail-over times in systems with trusted clients.

Ruggaber and Seitz [14] consider the hand-off problem in wireless CORBA systems. They develop a proxy platform that uses a modified CORBA Object Request Broker (ORB) to transparently hand off mobile CORBA clients to wired CORBA servers. Instead, our approach implements transparent fail-over in wired environments using interception mechanisms [6] that do not require modifying the ORB.

There are also various statistical fault-prediction techniques. Lin and Siewiorek [7] developed a failure prediction heuristic that achieved a 93.7% success rate in predicting faults in the campus-wide Andrew File System at Carnegie Mellon University. Rubino [13] proposed a model that refines predictions based on observations of system behavior during the operational phase. Xu et al. [19] studied failure behavior in a networked Windows NT system by analyzing system-reboot information in event logs, showing a strong likelihood of error propagation between servers within the same domain.

We reiterate that our research does not focus on fault-prediction techniques but rather on how to exploit fault prediction in systems with real-time deadlines. While more accurate, statistical fault-prediction techniques could improve our system's performance, this is outside the scope of this paper and forms part of our future directions. This paper establishes that proactive recovery is effective and can provide bounded temporal behavior, enabling the support of both fault-tolerance and real-time properties in distributed applications.

## 3. MEAD’s Proactive Recovery Framework
MEAD’s proactive recovery framework helps lower the impact of faults on real-time schedules. Our main objective in designing this framework was to build a transparent fault-tolerant infrastructure that masks failures at the application level, lowers the average fail-over time, and incurs reasonable overhead. Our framework uses replication and proactive fault notifications to protect applications against faults. Although we use CORBA to develop our system, the concept of proactive notifications can be extended to other types of middleware.

The CORBA standard specifies an Object Request Broker (ORB) that enables clients to request object implementations from servers seamlessly without worrying about network-specific details. Our architecture leverages the transparency provided by CORBA and uses some of the notification messages already supported by the CORBA standard. In developing the MEAD system, we make the following assumptions:
- Operation in an asynchronous distributed system.
- Deterministic, reproducible behavior of the application.
- Independent failures across server replicas and nodes.
- A fault model that covers process crash-faults, node crash-faults, message-loss faults, and resource-exhaustion faults.

### 3.1. The MEAD Interceptor
Interceptors are software components that can transparently modify the behavior of function calls invoked by an application. CORBA provides standardized support for interception through its Portable Interceptors mechanism [11], which requires modification of the application code to insert hooks for intercepting the application’s request and reply messages. Due to the lack of transparency in Portable Interceptors and limitations in their usage, such as the inability to block server replies without raising an exception at the application, we favored a transparent library interpositioning approach [6] instead. Library interpositioning provides greater flexibility and allows us to implement proactive recovery transparently underneath an unmodified CORBA application running over an unmodified Linux kernel.

Library interpositioning is based on the runtime dynamic linking/loading facilities supported by most operating systems. At runtime, we can "preload" a custom library (the MEAD Interceptor) ahead of all other dynamically linked libraries in a process' address space. Runtime symbol resolution will first "discover" and use the symbols inside the custom Interceptor library, rather than the default ones provided by the operating system. Thus, if our custom Interceptor library provides an overridden definition of a system call, say `socket()`, the intercepted process will use our redefinition of the `socket()` call, rather than the default one.

Clearly, we might also need to access the default system definitions (for instance, our overridden `socket()` call might wish to do some additional processing before ultimately invoking the default `socket()` call). Through calls such as `dlopen` and `dlsym`, our Interceptor can access the default system libraries and retrieve the default symbol definitions.

Of direct relevance to fault-tolerance and fail-over are the system calls related to a CORBA application's communication over the network. CORBA uses a connection-oriented communication protocol known as General-Inter-ORB-Protocol (GIOP) to facilitate interoperability between ORBs developed by different vendors. MEAD’s proactive recovery framework tracks GIOP messages communicated over TCP/IP sockets by intercepting the following eight UNIX system calls: `socket()`, `accept()`, `connect()`, `listen()`, `close()`, `read()`, `writev()`, and `select()`. We keep track of each socket that either the CORBA client or server opens and identify the client-server communication sockets based on the sequence of system calls executed. For instance, if a specific socket file descriptor appears within the `accept()` call, we associate the descriptor with a server-side socket because only the server-side logic of a CORBA application would invoke the `accept()` call.

Most of our proactive-recovery logic is implemented within the intercepted `read()`, `writev()`, and `select()` calls because all communication in CORBA is connection-oriented, and these calls capture the message-exchange interface between the CORBA client and server. The Interceptor uses the information from the remaining socket-related calls to differentiate between client and server sockets. Based on whether the invoking process is a client or a server, the intercepted `read()` and `writev()` calls have different overridden implementations.

For server sockets, we use `read()` to keep track of incoming client requests and `writev()` to trigger our proactive recovery mechanisms. While we could use a separate thread within the Interceptor to implement our proactive-recovery mechanisms instead of embedding our logic in the `writev()` call, multithreading poses its own problems:
- Multithreading introduced a great deal of overhead in some of our earlier implementations and sometimes led to nondeterministic behavior at the client based on the order in which the Interceptor's proactive-recovery thread executed at the server.
- Multithreading is a timer-driven (rather than event-driven) mechanism, involving continuous periodic checking of resources. We do not require constant resource monitoring because proactive recovery complements, and does not replace, the reactive fault-tolerance mechanisms that handle periodic state transfer and fail-over. Therefore, proactive recovery needs to be triggered only when there are active client connections at the server.

For client sockets, we use the `read()` call to filter and interpret the custom MEAD messages that we piggyback onto regular GIOP messages. We use the `writev()` call to redirect client requests to non-faulty server replicas in the event of proactive fail-over. We also intercept the `select()` call in both the client and server, adding the group-communication socket (which allows our intercepted process to communicate over Spread) into the list of read-sockets examined by `select()`. This enables us to receive group communication messages without resorting to multithreading.

### 3.2. The MEAD Proactive Fault-Tolerance Manager
The Proactive Fault-Tolerance Manager is embedded within the server-side and client-side Interceptors. Focusing on resource-exhaustion faults, the Proactive Fault-Tolerance Manager monitors resource usage at the server and triggers proactive recovery mechanisms when it senses that resource usage has exceeded a predefined threshold. Here, "resource" refers loosely to any resource of interest (e.g., memory, file descriptors, threads) that could lead to a process-crash fault if exhausted.

We implemented proactive recovery using a two-step threshold-based scheme similar to the soft hand-off process employed in cellular systems [18]. When a replica's resource usage exceeds our first threshold, e.g., when the memory usage reaches 80%, we initiate a soft hand-off process. If the resource usage continues to rise and exceeds the second threshold, e.g., 90%, we trigger a hard hand-off, migrating the processes to another node. This two-step approach ensures that we only take more drastic actions when necessary, minimizing the impact on the system.

## 4. Conclusion
In this paper, we presented the design and implementation of a proactive recovery strategy for distributed CORBA applications, focusing on resource-exhaustion faults. Our approach leverages the MEAD system, which uses a transparent, proactive dependability framework to lower the impact of faults on real-time schedules. We demonstrated that our proactive strategy can significantly reduce jitter and latency spikes, thereby improving the overall performance and reliability of distributed applications. Future work will explore more advanced fault-prediction techniques and extend our proactive recovery framework to other types of middleware and fault models.