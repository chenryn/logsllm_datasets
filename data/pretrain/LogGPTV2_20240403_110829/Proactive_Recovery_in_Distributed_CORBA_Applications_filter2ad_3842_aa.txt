title:Proactive Recovery in Distributed CORBA Applications
author:Soila M. Pertet and
Priya Narasimhan
Proactive Recovery in Distributed CORBA Applications ∗
Soila Pertet and Priya Narasimhan
Electrical & Computer Engineering Department
Carnegie Mellon University
5000 Forbes Avenue, Pittsburgh, PA 15213-3890
PI:EMAIL, PI:EMAIL
Abstract
Unanticipated runtime events, such as faults, can lead
to missed deadlines in real-time systems. While it is not
always possible to know when a fault will occur, we can
sometimes exploit pre-fault “symptoms” to initiate proac-
tive (rather than reactive) fault-recovery. In this paper, we
describe the design and implementation of a proactive re-
covery strategy for distributed CORBA applications in the
presence of resource-exhaustion faults. We analyze the ef-
fect of different proactive recovery schemes on client/server
response times, and we demonstrate a signiﬁcant reduction,
both in jitter and in the number of client-side failures.
1. Introduction
Middleware platforms, such as CORBA [11] and Java, are
increasingly being adopted because they simplify applica-
tion programming by rendering transparent the low-level
details of networking, distribution, physical location, hard-
ware, operating systems, and byte order. Since CORBA and
Java have come to support many “-ilities” (e.g., reliabil-
ity, real-time, security), these middleware platforms have
become even more attractive to applications that require a
higher quality of service. The push for Commercial-Off-
The-Shelf (COTS) products, along with the recent support
for “-ilities” within middleware, have furthered the adop-
tion of middleware within mission-critical applications.
Mission-critical systems, like avionics applications and
drive-by-wire systems, have stringent reliability and avail-
ability requirements, and need to exhibit both real-time and
fault-tolerance properties. The Object Management Group
(OMG) CORBA standard has attempted to address the
∗
This work is partially supported by the NSF CAREER Award CCR-
0238381, the DARPA PCES contract F33615-03-C-4110, and the
General Motors Collaborative Laboratory at CMU.
needs of such applications by developing separate Real-
Time [12] and Fault-Tolerance [11] speciﬁcations. How-
ever, due to some inherent conﬂicts in providing simulta-
neous real-time and fault-tolerance support [9], it is simply
not possible for today’s CORBA applications to obtain both
real-time and fault-tolerance guarantees through a straight-
forward adoption of the CORBA standards. The difﬁculty in
supporting both real-time and fault tolerance arises because
real-time systems require predictable end-to-end schedules
and bounded temporal behavior in order to meet task dead-
lines; however, faults are unanticipated system events that
can disrupt the predeﬁned real-time schedule and result in
missed task deadlines. Our preliminary measurements in
this paper demonstrate that faults can disrupt a Real-Time
CORBA application, and do lead to unbounded and vari-
able fault-detection and fault-recovery times.
The MEAD (Middleware for Embedded Adaptive De-
pendability) system [10] that we are developing at Carnegie
Mellon University attempts to reconcile the conﬂicts be-
tween real-time and fault-tolerance properties in a resource-
aware manner. One novel aspect of the MEAD system is its
use of a proactive dependability framework to lower the im-
pact of faults on a distributed application’s real-time sched-
ule. Proactive dependability involves designing and imple-
menting mechanisms that can predict, with some conﬁ-
dence, when a failure might occur, and compensating for the
failure even before it occurs. For instance, if we knew that
a node had an 80% chance of failing within the next 5 min-
utes, we could migrate all of its hosted processes to another
working node in the system, with the aim of meeting the
application’s real-time deadlines. This proactive process-
migration would incur a lower penalty than if we had ﬁrst
waited for the process to crash before taking any action. The
proactive approach is in sharp contrast to the reactive fault-
tolerance strategy adopted by the Fault-Tolerant CORBA
standard, which ﬁrst waits to detect a fault, and then initiates
fault-recovery mechanisms. In this paper, we show that, by
developing such a proactive strategy, we can not only mask
the occurrence of faults altogether from the clients of our
Proceedings of the 2004 International Conference on Dependable Systems and Networks (DSN’04) 
0-7695-2052-9/04 $ 20.00 © 2004 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 11:52:12 UTC from IEEE Xplore.  Restrictions apply. 
application, but that we can also reduce the jitter and the la-
tency “spikes” which manifest themselves when faults oc-
cur in the middle of a real-time operation.
There are two aspects to proactive dependability: ﬁrst,
the ability to predict failures and, second, the mechanisms
to compensate for the failures, hopefully before the failures
can actually occur. Of course, we recognize that some fail-
ures might occur so abruptly that we cannot possibly hope
to predict them; for example, if someone accidentally un-
plugs the power supply of a node! However, a number of
interesting computer-related faults are often preceded by
a visible pattern of abnormal behavior that favors the use
of some form of prediction. Typically, these failures result
from gradual degradation faults, like resource exhaustion
[5], or from transient and intermittent hardware faults, like
disk crashes [7] or telecommunication equipment failures
[16]. Because it is not always possible to predict failures for
every kind of fault, proactive dependability complements
(and for certain kinds of faults, out-performs), but does not
replace, the traditional reactive fault-tolerance schemes.
Our hope is that we can provide bounded fault-recovery
times for distributed real-time applications, in the face of
a predictable class of faults, thereby allowing the support
of both fault-tolerance and real-time properties, for at least
these kinds of faults. In this paper, we focus on the mech-
anisms needed to implement proactive recovery in a dis-
tributed CORBA-based system. We do not attempt to de-
velop a new failure-prediction technique; rather, we exploit
relatively simple failure-prediction mechanisms within the
MEAD system, and we show how to use these resulting pre-
dictions to develop a proactive recovery strategy that min-
imizes both the jitter and the “latency” spikes experienced
by distributed applications in the presence of faults. This pa-
per makes the following concrete contributions:
• Describes our development of a transparent, proactive
recovery infrastructure for distributed CORBA appli-
cations,
• Discusses the design choices that we faced in imple-
menting a proactive strategy, along with the impact of
these choices on client-to-server response times and on
client-side fail-over times, and
• Presents our empirical evaluation and measurements
to quantify the overhead and performance of our proac-
tive strategy, as compared with the classical reactive
fault-tolerance approach.
We emphasize here that, while we employ CORBA
as the vehicle for our investigations of proactive fault-
tolerance, our techniques are, for the most part,
inde-
pendent of CORBA. In those cases where we exploit
CORBA-speciﬁc mechanisms to accomplish our goals, we
highlight our use of these mechanisms so that our proac-
tive strategy can be readily extended to non-CORBA-based
distributed applications.
2. Related Work
Huang et al [5] proposed a proactive approach, called soft-
ware rejuvenation, for handling transient software failures.
Software rejuvenation involves gracefully halting an appli-
cation once errors accumulate beyond a speciﬁed thresh-
old, and then restarting the application in a clean internal
state. One example of this is killing and relaunching a pro-
cess periodically in order to eliminate memory leaks. Sub-
sequent work in software rejuvenation has focused on con-
structing rejuvenation policies that increase system avail-
ability and reduce the cost of rejuvenation [2, 4, 20]. We
found that simply restarting a faulty server that has ongo-
ing client transactions can lead to unacceptable jitter and
missed real-time deadlines at the client. Our work focuses
on the mechanisms needed to gracefully hand-off existing
clients on faulty CORBA servers, at the onset of the rejuve-
nation threshold.
Castro and Liskov [3] describe a proactive recovery
scheme for Byzantine fault-tolerant systems. In their sys-
tem, clients detect a faulty primary by timing out and re-
transmitting their requests to all the replicas in the group.
Again, this fail-over process may result in increased jitter at
the client. Our system uses proactive notiﬁcations to lower
fail-over times in systems with trusted clients.
Ruggaber and Seitz [14] consider the hand-off (similar to
fail-over) problem in wireless CORBA systems. They de-
velop a proxy platform that uses a modiﬁed CORBA Ob-
ject Request Broker (ORB) to transparently hand-off mobile
CORBA clients to wired CORBA servers. Instead, our ap-
proach implements transparent fail-over in wired environ-
ments using interception mechanisms [6] that do not require
us to modify the ORB.
There is also a whole array of statistical fault-prediction
techniques. Lin and Siewiorek [7] developed a failure pre-
diction heuristic that achieved a 93.7% success rate in pre-
dicting faults in the campus-wide Andrew File System at
Carnegie Mellon University. Rubino [13] proposed a model
that employs observations of the system behavior made
during the operational phase in order to reﬁne the predic-
tions that system designers made concerning the system’s
dependability. Xu et al. [19] studied failure behavior in a
networked Windows NT system by analyzing the system-
reboot information contained in the event logs. Their re-
sults showed a strong likelihood of error propagation be-
tween servers within the same domain.
We reiterate that our research in this paper does not fo-
cus on fault-prediction techniques, but rather on how to ex-
ploit fault prediction in systems that have real-time dead-
lines; thus, while it might be possible for us to improve
the performance of our system using more accurate, statisti-
cal (rather than heuristic) fault-prediction techniques, this is
outside the scope of this paper, and forms a part of our future
Proceedings of the 2004 International Conference on Dependable Systems and Networks (DSN’04) 
0-7695-2052-9/04 $ 20.00 © 2004 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 11:52:12 UTC from IEEE Xplore.  Restrictions apply. 
Warm passively
replicated server
{
NODE
Server
Replica
NODE
Client
Interceptor
NODE
Server
Replica
Interceptor
Interceptor
Interceptor
Proactive Fault-Tolerance
Manager
Proactive Fault-Tolerance
Manager
Factory
Recovery
Handler
Fault
Detector
System State
MEAD
Group Communication
Operating System
Proactive Fault-Tolerance
Manager
System State
Recovery
Handler
Factory
Recovery
Handler
Fault
Detector
System State
Group Communication
MEAD
Operating System
Group Communication
Operating System
Factory
Fault
Detector
MEAD
Network
MEAD
Recovery Manager
Network
Figure 1. MEAD’s proactive recovery framework.
directions. Instead, this paper serves to establish concretely
that proactive recovery is effective and that it can provide
bounded temporal behavior, in the presence of certain kinds
of faults, thereby enabling us to support both fault-tolerance
and real-time properties in distributed applications.
3. MEAD’s Proactive Recovery Framework
MEAD’s proactive recovery framework helps lower the im-
pact of faults on real-time schedules. Our main objective
when designing this framework was to build a transparent
fault-tolerant infrastructure that masked failures at the ap-
plication, lowered the average fail-over time, and incurred
a reasonable overhead. Our framework uses replication and
proactive fault-notiﬁcations to protect applications against
faults. Although we use CORBA to develop our system, the
concept of proactive notiﬁcations can be extended to other
types of middleware.
The CORBA stardard speciﬁes an Object Request Bro-
ker (ORB) that enables clients to request object implemen-
tations from servers seamlessly without having to worry
about network-speciﬁc details. Our architecture leverages
on the transparency provided by CORBA and makes use of
some of the notiﬁcation messages already supported by the
CORBA standard. In our development of the MEAD sys-
tem, we make the following assumptions:
• Operation in an asynchronous distributed system;
and the ORB;
nodes;
• Deterministic, reproducible behavior of the application
• Independent failures across the server replicas and the
• A fault model
that covers process crash-faults,
node crash-faults, message-loss faults and resource-
exhaustion faults.
Our proactive framework has three main components:
the MEAD Interceptor, the MEAD Recovery Manager and
the MEAD Proactive Fault-Tolerance Manager, as shown in
Figure 1. MEAD exploits an underlying totally-ordered reli-
able group communication system, speciﬁcally, the Spread
system [1], to obtain the reliable delivery and ordering guar-
antees required for consistent node-level and process-level
membership.
3.1. The MEAD Interceptor
Interceptors are software components that can transparently
modify the behavior of the function calls invoked by an ap-
plication. CORBA provides standardized support for inter-
ception through its Portable Interceptors mechanism [11],
which requires modiﬁcation of the application code to in-
sert hooks for intercepting the application’s request and re-
ply messages. Due to the lack of transparency in Portable
Interceptors, and also due to some limitations [8] in their
usage, such as the inability to block server replies without
Proceedings of the 2004 International Conference on Dependable Systems and Networks (DSN’04) 
0-7695-2052-9/04 $ 20.00 © 2004 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 11:52:12 UTC from IEEE Xplore.  Restrictions apply. 
raising an exception at the application, we favored a trans-
parent library interpositioning approach [6] instead. Library
interpositioning provides us with greater ﬂexibility, and al-
lows us to implement proactive recovery transparently un-
derneath an unmodiﬁed CORBA application running over
an unmodiﬁed Linux kernel.
Library interpositioning is based on the runtime dynamic
linking/loading facilities supported by most operating sys-
tems. At runtime, we can “preload” a custom library (the
MEAD Interceptor) ahead of all of the other dynamically
linked libraries in a process’ address space. The idea is that
runtime symbol resolution will ﬁrst “discover” and use the
symbols inside the custom Interceptor library, rather than
the default ones provided by the operating system. Thus, if
our custom Interceptor library provides an overridden def-
inition of a system call, say socket(), then, the inter-
cepted process will end up using our redeﬁnition of the
socket() call, rather than the default one.
Clearly, we might also need to access the default system
deﬁnitions (for instance, our overridden socket() call
might wish to do some additional processing before ulti-
mately invoking the default socket() call); through calls
such as dlopen and dlsym, our Interceptor can access the
default system libraries, and retrieve the default symbol def-
initions.
Of direct relevance to fault-tolerance and fail-over
are the system calls related to a CORBA applica-
tion’s communication over the network. CORBA uses
a connection-oriented communication protocol known
as General-Inter-ORB-Protocol (GIOP) to facillitate in-
teroperability between ORBs developed by different
ORB vendors. MEAD’s proactive recovery framework
tracks GIOP messages communicated over TCP/IP sock-
ets by intercepting the following eight UNIX system calls:
socket(), accept(), connect(), listen(),
close(), read(), writev() and select(). We
keep track of each socket that either the CORBA client
or server opens, and identify the client-server com-
munication sockets based on the sequence of system
calls executed. For instance, if a speciﬁc socket ﬁle de-
scriptor appears within the accept() call, we asso-
ciate the descriptor with a server-side socket because only
the server-side logic of a CORBA application would in-
voke the accept() call.
is
Most of our proactive-recovery logic
imple-
mented within the intercepted read(), writev()
and select() calls because all of the communica-
tion in CORBA is connection-oriented and these calls cap-
ture the message-exchange interface between the CORBA
client and server. The Interceptor uses the information from
the remainder of the socket-related calls simply for dif-
ferentiating between client and server sockets. Based on
whether the invoking process is a client or a server, the in-
tercepted read() and writev() calls have different
overridden implementations.
For server sockets, we use read() to keep track
of incoming client requests, and writev() to trig-
ger our proactive recovery mechanisms. While we could
use a separate thread within the Interceptor to imple-
ment our proactive-recovery mechanisms instead of em-
bedding our logic in the writev() call, multithreading
poses its own problems:
• Multithreading introduced a great deal of overhead in
some of our earlier implementations, and sometimes
led to nondeterministic behavior at the client based on
the order in which the Interceptor’s proactive-recovery
thread executed at the server.
• Multithreading is a timer-driven (rather than event-
driven) mechanism, and involved continuous periodic
checking of resources. We do not really require this
constant resource monitoring because proactive recov-
ery complements, and does not replace, the reactive
fault-tolerance mechanisms that handle periodic state
transfer and fail-over. Therefore, proactive recovery
needs to be triggered only when there are active client
connections at the server.
For client sockets, we use the read() call to ﬁlter
and interpret the custom MEAD messages that we piggy-
back onto regular GIOP messages. We use the writev()
call to redirect client requests to non-faulty server replicas
in the event of proactive fail-over. We also intercept the
select() call in both the client and server, and add the
group-communication socket (which allows our intercepted
process to communicate over Spread) into the list of read-
sockets examined by select(). This enables us to receive
group communication messages without resorting to multi-
threading.
3.2. The MEAD Proactive Fault-Tolerance
Manager
The Proactive Fault-Tolerance Manager
is embedded
within the server-side and client-side Interceptors. Be-
cause our focus is on resource-exhaustion faults,
the
Proactive Fault-Tolerance Manager monitors
the re-
source usage at the server, and triggers proactive recovery
mechanisms when it senses that resource usage has ex-
ceeded a predeﬁned threshold. Here, “resource” refers
loosely to any resource of interest (e.g., memory, ﬁle de-
scriptors, threads) to us that could lead to a process-crash
fault if it was exhausted.
We implemented proactive recovery using a two-step
threshold-based scheme similar to the soft hand-off pro-
cess employed in cellular systems [18]. When a replica’s
resource usage exceeds our ﬁrst threshold, e.g., when the
Proceedings of the 2004 International Conference on Dependable Systems and Networks (DSN’04) 
0-7695-2052-9/04 $ 20.00 © 2004 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 11:52:12 UTC from IEEE Xplore.  Restrictions apply. 