title:\(μ\)SCOPE: A Methodology for Analyzing Least-Privilege Compartmentalization
in Large Software Artifacts
author:Nick Roessler and
Lucas Atayde and
Imani Palmer and
Derrick Paul McKee and
Jai Pandey and
Vasileios P. Kemerlis and
Mathias Payer and
Adam Bates and
Jonathan M. Smith and
Andr&apos;e DeHon and
Nathan Dautenhahn
µSCOPE: A Methodology for Analyzing Least-Privilege
Compartmentalization in Large Software Artifacts
Nick Roessler
University of Pennsylvania
PI:EMAIL
Lucas Atayde
Rice University
PI:EMAIL
Imani Palmer
Null Hat Security
PI:EMAIL
Derrick McKee
Purdue University
PI:EMAIL
Jai Pandey
Nvidia
PI:EMAIL
Vasileios P. Kemerlis
Brown University
PI:EMAIL
Mathias Payer
EPFL
PI:EMAIL
Adam Bates
University of Illinois
PI:EMAIL
André DeHon
University of Pennsylvania
PI:EMAIL
Jonathan M. Smith
University of Pennsylvania
PI:EMAIL
Nathan Dautenhahn
Rice University
PI:EMAIL
ABSTRACT
By prioritizing simplicity and portability, least-privilege engineer-
ing has been an afterthought in OS design, resulting in monolithic
kernels where any exploit leads to total compromise. µSCOPE (“mi-
croscope”) addresses this problem by automatically identifying op-
portunities for least-privilege separation. µSCOPE replaces expert-
driven, semi-automated analysis with a general methodology for
exploring a continuum of security vs. performance design points
by adopting a quantitative and systematic approach to privilege
analysis. We apply the µSCOPE methodology to the Linux ker-
nel by (1) instrumenting the entire kernel to gain comprehensive,
fine-grained memory access and call activity; (2) mapping these
accesses to semantic information; and (3) conducting separability
analysis on the kernel using both quantitative privilege and over-
head metrics. We discover opportunities for orders of magnitude
privilege reduction while predicting relatively low overheads—at
15% mediation overhead, overprivilege in Linux can be reduced up to
99.8%—suggesting fine-grained privilege separation is feasible and
laying the groundwork for accelerating real privilege separation.
ACM Reference Format:
Nick Roessler, Lucas Atayde, Imani Palmer, Derrick McKee, Jai Pandey,
Vasileios P. Kemerlis, Mathias Payer, Adam Bates, André DeHon, Jonathan
M. Smith, and Nathan Dautenhahn. 2021. µSCOPE: A Methodology for Ana-
lyzing Least-Privilege Compartmentalization in Large Software Artifacts. In
24th International Symposium on Research in Attacks, Intrusions and Defenses
(RAID ’21), October 6–8, 2021, San Sebastian, Spain. ACM, New York, NY,
USA, 16 pages. https://doi.org/10.1145/3471621.3471839
1 INTRODUCTION
The Principle of Least Privilege is a key aspiration for secure sys-
tem design [41, 62]. However, despite decades of work, we still
use over-privileged software at every layer of the software stack.
This work is licensed under a Creative Commons
Attribution-NonCommercial-NoDerivs International 4.0 License.
RAID ’21, October 6–8, 2021, San Sebastian, Spain
© 2021 Copyright held by the owner/author(s).
ACM ISBN 978-1-4503-9058-3/21/10.
https://doi.org/10.1145/3471621.3471839
Figure 1: The interaction of code and objects in Linux kernel v4.10 at the direc-
tory level. Directories are in alphabetical order with labels shown on top-level
directories; blank entries are nested in the preceding labeled directory. Color
intensity indicates the logscale number of unique interaction edges from a
directory (X axis) to code or data objects owned by another directory (Y axis).
µSCOPE collects data at the instruction level; we aggregate to directories to
produce a viewable figure.
Fundamentally, composing systems while minimizing privilege is
hard due to the complexity of defining privilege compartments and
the performance challenges they impose [50], leading developers to
simplify by building software with large, single trust domains. This
is problematic because these “monolithic” software artifacts (e.g.,
commodity operating systems) create an environment in which a
single vulnerability could lead to full compromise of the system—for
example, Project Zero’s recent iOS exploit [10] was built from a sin-
gle memory error in the kernel and led to a devastating zero-click,
radio-transmitted and wormable complete device compromise. Fac-
ing a range of both external [65, 69] and insider threats [11, 36], the
/arch/block/drivers/fs/include/init/ipc/kernel/lib/mm/net/security/sound/crypto/arch/block/drivers/fs/include/init/ipc/kernel/lib/mm/net/security/sound/crypto296RAID ’21, October 6–8, 2021, San Sebastian, Spain
Roessler and Dautenhahn, et al.
risks posed by monolithic software are not theoretical in nature,
but a daily reality.
Addressing overprivilege in operating system design is a matter
of both mechanism and policy. Privilege separation requires a self-
protecting mechanism to enforce privilege boundaries and mediate
any necessary boundary crossings (i.e., a reference monitor [8]).
Perhaps surprisingly, achieving this goal does not require abandon-
ing today’s operating systems (and all their source code) in favor
of microkernel architectures (e.g., L4 [25]); in fact, mechanisms for
retrofitting privilege compartmentalization into monolithic ker-
nels [18, 19, 52, 56, 72] and userspace applications [14, 22, 33, 34,
42, 46, 68, 71] have already been demonstrated. For example, Daut-
enhahn et al. [19] demonstrate that, by trapping on all updates to
virtual memory, it is possible to embed an intra-kernel reference
monitor (or “Nested Kernel”) within an existing monolithic OS that
can mediate accesses to physical memory or other system resources.
They leverage the Nested Kernel to define a coarse-grained com-
partmentalization that assures the integrity of the core kernel in
the presence of untrusted dynamically loaded modules.
These works demonstrate feasible mechanisms for retrofitting
privilege separation, but their focus on coarse-grained compart-
mentalizations only scratches the surface of the Principle of Least
Privilege. Why should a bug in one kernel subsystem have any
bearing at all on the integrity of another completely independent
subsystem? For that matter, why should a bug in one kernel function
undermine the integrity of other unrelated lines of code?
These questions are a matter of policy. Privilege separation re-
quires us to (retroactively) identify privilege compartments that pro-
vide a reasonable tradeoff between security and cost. With upwards
of tens of millions of lines of code to consider, manually defining
policies and privilege boundaries is infeasible. Unfortunately, while
recent attempts at privilege reduction [6, 12, 23, 29, 35, 45, 47] have
improved upon influential, but labor-intensive, early work [13, 37,
58, 72], they still fall short in terms of both least-privilege identifi-
cation and automation. In these approaches, an expert either labels
sensitive data (e.g., private keys) or low-integrity components (e.g.,
input parsing), and then performs a semi-automated compartmen-
talization routine that minimizes access to the sensitive data and/or
the reach of the low-integrity code. However, even for state-of-
the-art metric-based techniques [47], these approaches fall short of
whole-system privilege reduction, instead protecting a few coarse-
grained critical compartments. This is because they depend on the
availability and omniscience of experts to label security-relevant
data, code, or components—where, for massive systems like an op-
erating system, there may be no such single expert. At present, we
have no systematic approach to identifying and evaluating privilege
separation opportunities in monolithic software artifacts whose scale
exceeds the knowledge of a single developer.
With this in mind, we present µSCOPE (“Systematizing Com-
partmentalization Opportunities for Privilege Encapsulation”), a
methodology that enables the identification of whole-system priv-
ilege reduction opportunities without requiring manual analysis
by experts. µSCOPE instruments and profiles software activity at
the granularity of instructions and objects, encoding each refer-
ence (i.e., privilege requirement) in a novel low-level access control
matrix, the CAPMAP (Context-Aware Privilege Memory Access
Pattern). µSCOPE then uses the CAPMAP as the ground truth
with which it compares competing software compartmentalization
hypotheses that are either drawn from syntactic code structure
(e.g., functions, files, directories) or procedurally-identified through
data-driven clustering algorithms that combine frequently inter-
acting code and data. µSCOPE introduces a metric that allows it to
evaluate the level of privilege separation that is possible for a given
compartmentalization strategy compared to both monolithic (fully
overprivileged) and the minimum-required-to-run (least privilege)
baselines, then uses a performance model that estimates the cost of
enforcement for a range of potential isolation mechanisms.
To demonstrate the power of µSCOPE and evaluate whether
privilege separation is generically feasible, we apply µSCOPE to
analyze the notoriously overprivileged Linux kernel. We identify
the privilege separability of kernel objects, show the range of com-
partmentalizations that can be achieved in terms of aggregate levels
of privilege separation and overhead, and automatically identify the
data structures and design patterns that are important candidates
for refactoring. These results demonstrate the utility of µSCOPE’s
automated privilege analysis. Figure 1 previews our results under
a directory-based compartmentalization process. Here, individual
instructions (references) are clustered by the directory in which
the code resides. Even under this relatively coarse compartmental-
ization, the large amount of whitespace indicates massive privilege
separation opportunities for Linux. Even more surprising, our per-
formance analysis suggests that enforcing such privilege separation
opportunities might be practical and eliminates costly manual sep-
aration efforts from exploring impractical compartmentalizations.
In summary, our primary contributions include:
• µSCOPE, a framework for comprehensive, automated privi-
lege analysis (Sec. 5). It consists of four main components: (1)
A novel low-level privilege representation, the CAPMAP; (2) A
compartmentalization model that relaxes the standard object
ownership model; (3) Quantitative Metrics for characterizing
both privilege (the novel privilege set), and performance; (4)
Separability analysis, a novel systematic exploration of entire
compartmentalization spaces.
• An implementation of µSCOPE for the Linux kernel, binding
the C language abstractions to the CAPMAP model (Sec. 6).
µSCOPE’s analysis code and data sets are available from
https://fierce-lab.gitlab.io/uscope.
• A characterization of the degree to which Linux is privilege
separable, including automated identification of potential
refactorings (Sec. 8). We uncover opportunities for orders
of magnitude in privilege separation, up to a 500x reduction
(99.8%) in overprivilege, at predicted overhead of approx.
15%, suggesting that fine-grained privilege separation may
be possible with low overhead in monolithic kernels. Further,
we have released a browsable explorer1 to allow researchers
to better understand the interactions between Linux objects
observed by µSCOPE.
2 MOTIVATION
As a concrete example to illustrate our concerns and motivate our
approach, let us consider the credential structure (struct cred)
from the Linux kernel (Fig. 2). This data structure controls the
1https://uscope-linux.github.io/object_explorer/
297µSCOPE: A Methodology for Analyzing Least-Privilege Compartmentalization in Large Software Artifacts
RAID ’21, October 6–8, 2021, San Sebastian, Spain
A true least-privilege policy would remove that unnecessary privi-
lege, further reducing struct cred’s attack surface.
However, struct cred isn’t the only object in a program that
carries security implications. For example, page table entries and
secret keys are also clearly security-critical. We can perform simi-
lar analyses on each of these to quantify the minimum privileges
necessary to run, the overprivilege of the monolithic design, and
the privilege implications of a particular compartmentalization. We
include a web-based object explorer generated from our tool to
show the usage patterns of other kernel objects: µSCOPE object
explorer.1
3 SECURITY MODEL
Threat Model. This work considers a realistic and powerful at-
tacker that has discovered an exploitable software vulnerability
(e.g., memory corruption, disclosure, or code execution) in a mono-
lithic software artifact, e.g., an OS kernel.2 It is possible for the
attacker to trigger this exploit through the target system’s interac-
tions with low-integrity components such as user-space processes,
network communications, or peripheral devices. Leveraging this
exploit, the attacker seeks to take control of the system or gain
access to confidential data – under normal circumstances, the above
exploit alone would be sufficient to take full control of the system.
We conservatively make no assumption about the specific system
objects that the adversary seeks to access or corrupt; it is possible
that any object is relevant to the attacker’s objectives.
System Model. The target system is not without its own de-
fenses. We assume it is equipped with a state-of-the-art reference
monitor [8], the likes of which have been concretely instantiated in
recent work [14, 18, 19, 22, 27, 33, 34, 42, 46, 52, 56, 68, 71, 72]. This