# 【缺陷周话】第28期：被污染的内存分配
##### 译文声明
本文是翻译文章
译文仅供参考，具体内容表达以及含义原文为准。
## 2、 被污染的内存分配的危害
直接将被污染的数据作为内存分配函数长度参数，如传入了一个极大的整数值，程序就会相应的分配一块极大的内存，从而导致系统极大的内存开销，甚至导致拒绝服务攻击。
CVE中也有一些与之相关的漏洞信息，从2018年1月至2019年3月，CVE中就有4条相关漏洞信息。漏洞信息如下：
CVE | 概述  
---|---  
CVE-2018-6869 | ZZIPlib 0.13.68 版本中的 zzip/zip.c
文件的‘__zzip_parse_root_directory’函数存在安全漏洞。远程攻击者可借助特制的zip文件利用该漏洞造成拒绝服务（不可控的内存分配和崩溃）。  
CVE-2018-5783 | PoDoFo 0.9.5 版本中的
base/PdfVecObjects.h文件的‘PoDoFo::PdfVecObjects::Reserve’函数存在安全漏洞。远程攻击者可借助特制的pdf文件利用该漏洞造成拒绝服务（不受控的内存分配）。  
CVE-2018-5296 | PoDoFo 0.9.5 版本中的 base/PdfParser.cpp
文件的‘PdfParser::ReadXRefSubsection’函数存在安全漏洞，该漏洞源于程序没有控制内存的分配。远程攻击者可借助特制的pdf文件利用该漏洞造成拒绝服务。  
##  3、示例代码
本节所用示例参考CWE-789: Uncontrolled Memory Allocation
(http://cwe.mitre.org/data/definitions/789.html) 提供的代码示例，并对示例中的
GetUntrustedInt() 函数进行了定义。
### 3.1缺陷代码
在上述示例代码中，在第9行使用 malloc() 函数进行长度为 totBytes 字节的内存分配，通过跟踪路径可以看出， totBytes 在第6行通过
size*sizeof(char); 计算结果进行赋值，而 size 的值是第7行使用 scanf()
函数获取的用户键盘输入，为被污染的数据源，从而导致内存分配长度 totBytes 被污染，存在“被污染的内存分配”问题。
使用360代码卫士对上述示例代码进行检测，可以检出“被污染的内存分配”缺陷，显示等级为高。如图1所示：
图1：被污染的内存分配的检测示例
### 3.2 修复代码
在上述修复代码中，虽然 totBytes 的来源为被污染的数据，但在第10行对 totBytes 的长度进行了有效限制，从而避免了被污染的内存分配。
使用360代码卫士对修复后的代码进行检测，可以看到已不存在“被污染的内存分配”缺陷。如图2：
图2：修复后检测结果
## 4、如何避免被污染的内存分配
（1）避免使用被污染的数据直接作为内存分配函数的长度参数，如无法避免，则应对被污染的数据进行有效限制。
（2）使用源代码静态分析工具，可以有效发现这类问题。