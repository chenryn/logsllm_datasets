112 } 
我们从第 71 行 results 变量的声明开始分析，如代码清单 2-55 所示。这个变量用于保存
并返回找到的结果。 
代码清单 2-55 matchers/rss.go：第 71 行 
71 
 var results []*search.Result 
我们使用关键字 var 声明了一个值为 nil 的切片，切片每一项都是指向 Result 类型值的指
针。Result 类型的声明在之前 match.go 代码文件的第 08 行中可以找到。之后在第 76 行，我们
使用刚刚看过的 retrieve 方法进行网络调用，如代码清单 2-56 所示。
代码清单 2-56 matchers/rss.go：第 75 行到第 79 行 
75 
 // 获取要搜索的数据 
76 
 document, err := m.retrieve(feed) 
77 
 if err != nil { 
78 
 return nil, err 
79 
 } 
调用 retrieve 方法返回了一个指向 rssDocument 类型值的指针以及一个错误值。之后，
像已经多次看过的代码一样，检查错误值，如果真的是一个错误，直接返回。如果没有错误发生，
之后会依次检查得到的 RSS 文档的每一项的标题和描述，如果与搜索项匹配，就将其作为结果
保存，如代码清单 2-57 所示。 
代码清单 2-57 matchers/rss.go：第 81 行到第 86 行 
81 
 for _, channelItem := range document.Channel.Item { 
82 
 // 检查标题部分是否包含搜索项 
83 
 matched, err := regexp.MatchString(searchTerm, channelItem.Title) 
84 
 if err != nil { 
85 
 return nil, err 
86 
 } 
既然 document.Channel.Item 是一个 item 类型值的切片，我们在第 81 行对其使用 for 
range 循环，依次访问其内部的每一项。在第 83 行，我们使用 regexp 包里的 MatchString
函数，对 channelItem 值里的 Title 字段进行搜索，查找是否有匹配的搜索项。之后在第 84
行检查错误。如果没有错误，就会在第 89 行到第 94 行检查匹配的结果，如代码清单 2-58 所示。 
代码清单 2-58 matchers/rss.go：第 88 行到第 94 行 
88 
 // 如果找到匹配的项，将其作为结果保存 
89 
 if matched { 
90 
 results = append(results, &search.Result{ 
91 
 Field:   "Title", 
92 
 Content: channelItem.Title, 
93 
 }) 
94 
 } 
如果调用 MatchString 方法返回的 matched 的值为真，我们使用内置的 append 函
数，将搜索结果加入到 results 切片里。append 这个内置函数会根据切片需要，决定是否
要增加切片的长度和容量。我们会在第 4 章了解关于内置函数 append 的更多知识。这个函
数的第一个参数是希望追加到的切片，第二个参数是要追加的值。在这个例子里，追加到切
片的值是一个指向 Result 类型值的指针。这个值直接使用字面声明的方式，初始化为
Result 类型的值。之后使用取地址运算符（&），获得这个新值的地址。最终将这个指针存
入了切片。 
在检查标题是否匹配后，第 97 行到第 108 行使用同样的逻辑检查 Description 字段。最
后，在第 111 行，Search 方法返回了 results 作为函数调用的结果。
2.5  小结 
每个代码文件都属于一个包，而包名应该与代码文件所在的文件夹同名。
Go 语言提供了多种声明和初始化变量的方式。如果变量的值没有显式初始化，编译器会
将变量初始化为零值。 
使用指针可以在函数间或者 goroutine 间共享数据。
通过启动 goroutine 和使用通道完成并发和同步。
Go 语言提供了内置函数来支持 Go 语言内部的数据结构。
标准库包含很多包，能做很多很有用的事情。
使用 Go 接口可以编写通用的代码和框架。
第 3 章 打包和工具链 
本章主要内容 
如何组织 Go 代码
使用 Go 语言自带的相关命令
使用其他开发者提供的工具
与其他开发者合作
我们在第 2 章概览了 Go 语言的语法和语言结构。本章会进一步介绍如何把代码组织成包，
以及如何操作这些包。在 Go 语言里，包是个非常重要的概念。其设计理念是使用包来封装不同
语义单元的功能。这样做，能够更好地复用代码，并对每个包内的数据的使用有更好的控制。 
在进入具体细节之前，假设读者已经熟悉命令行提示符，或者操作系统的 shell，而且应 该已
经在本书前言的帮助下，安装了 Go。如果上面这些都准备好了，就让我们开始进入细节，了解
什么是包，以及包为什么对 Go 语言的生态非常重要。 
3.1  包 
所有 Go 语言的程序都会组织成若干组文件，每组文件被称为一个包。这样每个包的代码都
可以作为很小的复用单元，被其他项目引用。让我们看看标准库中的 http 包是怎么利用包的特
性组织功能的： 
net/http/ 
 cgi/ 
 cookiejar/ 
    testdata/ 
 fcgi/ 
 httptest/ 
 httputil/ 
 pprof/ 
 testdata/ 
这些目录包括一系列以.go 为扩展名的相关文件。这些目录将实现 HTTP 服务器、客户端、
3
第 3 章 打包和工具链 
fmt 包提供了完成
格式化输出的功能。 
测试工具和性能调试工具的相关代码拆分成功能清晰的、小的代码单元。以 cookiejar 包为例，
这个包里包含与存储和获取网页会话上的 cookie 相关的代码。每个包都可以单独导入和使用，以
便开发者可以根据自己的需要导入特定功能。例如，如果要实现 HTTP 客户端，只需要导入 http
包就可以。 
所有的.go 文件，除了空行和注释，都应该在第一行声明自己所属的包。每个包都在一个单
独的目录里。不能把多个包放到同一个目录中，也不能把同一个包的文件分拆到多个不同目录中。
这意味着，同一个目录下的所有.go 文件必须声明同一个包名。 
3.1.1  包名惯例 
给包命名的惯例是使用包所在目录的名字。这让用户在导入包的时候，就能清晰地知道包名。
我们继续以 net/http 包为例，在 http 目录下的所有文件都属于 http 包。给包及其目录命名
时，应该使用简洁、清晰且全小写的名字，这有利于开发时频繁输入包名。例如，net/http 包
下面的包，如 cgi、httputil 和 pprof，名字都很简洁。
记住，并不需要所有包的名字都与别的包不同，因为导入包时是使用全路径的，所以可以区分
同名的不同包。一般情况下，包被导入后会使用你的包名作为默认的名字，不过这个导入后的名字
可以修改。这个特性在需要导入不同目录的同名包时很有用。3.2 节会展示如何修改导入的包名。 
3.1.2  main 包
在 Go 语言里，命名为 main 的包具有特殊的含义。Go 语言的编译程序会试图把这种名字的
包编译为二进制可执行文件。所有用 Go 语言编译的可执行程序都必须有一个名叫 main 的包。
当编译器发现某个包的名字为 main 时，它一定也会发现名为 main()的函数，否则不会创建
可执行文件。main()函数是程序的入口，所以，如果没有这个函数，程序就没有办法开始执行。
程序编译时，会使用声明 main 包的代码所在的目录的目录名作为二进制可执行文件的文件名。
命令和包  Go 文档里经常使用命令（command）这个词来指代可执行程序，如命令行应用程序。
这会让新手在阅读文档时产生困惑。记住，在 Go 语言里，命令是指任何可执行程序。作为对比，
包更常用来指语义上可导入的功能单元。
让我们来实际体验一下。首先，在$GOPATH/src/hello/目录里创建一个叫 hello.go 的文件，并
输入代码清单 3-1 里的内容。这是个经典的“Hello World!”程序，不过，注意一下包的声明以及
import 语句。
代码清单 3-1 经典的“Hello World!”程序 
01 package main 
02 
03 import "fmt" 
strings 包提供了很多关于字符串的操作，如查找、替换或
者变换。可以通过访问 http://golang.org/pkg/strings/或者在终端
运行 godoc strings 来了解更多关于 strings 包的细节。 
04 
05 func main() { 
06 
 fmt.Println("Hello World!") 
07 } 
获取包的文档  别忘了，可以访问 http://golang.org/pkg/fmt/或者在终端输入 godoc fmt 来了解更
多关于 fmt 包的细节。
保存了文件后，可以在$GOPATH/src/hello/目录里执行命令 go build。这条命令执行完
后，会生成一个二进制文件。在 UNIX、Linux 和 Mac OS X 系统上，这个文件会命名为 hello，
而在 Windows 系统上会命名为 hello.exe。可以执行这个程序，并在控制台上显示“Hello 
World!”。 
如果把这个包名改为 main 之外的某个名字，如 hello，编译器就认为这只是一个包，而不
是命令，如代码清单 3-2 所示。 
代码清单 3-2 包含 main 函数的无效的 Go 程序
01 package hello 
02 
03 import "fmt" 
04 
05 func main(){ 
06 
 fmt.Println("Hello, World!") 
07 } 
3.2  导入 
我们已经了解如何把代码组织到包里，现在让我们来看看如何导入这些包，以便可以访问包
内的代码。import 语句告诉编译器到磁盘的哪里去找想要导入的包。导入包需要使用关键字
import，它会告诉编译器你想引用该位置的包内的代码。如果需要导入多个包，习惯上是将
import 语句包装在一个导入块中，代码清单 3-3 展示了一个例子。
代码清单 3-3 import 声明块
import ( 
 "fmt" 
 "strings" 
) 
编译器会使用 Go 环境变量设置的路径，通过引入的相对路径来查找磁盘上的包。标准库中
的包会在安装 Go 的位置找到。Go 开发者创建的包会在 GOPATH 环境变量指定的目录里查找。
GOPATH 指定的这些目录就是开发者的个人工作空间。
举个例子。如果 Go 安装在/usr/local/go，并且环境变量 GOPATH 设置为/home/myproject:/home/
mylibraries，编译器就会按照下面的顺序查找 net/http 包：
/usr/local/go/src/pkg/net/http 
/home/myproject/src/net/http 
/home/mylibraries/src/net/http 
一旦编译器找到一个满足 import 语句的包，就停止进一步查找。有一件重要的事需要记
住，编译器会首先查找 Go 的安装目录，然后才会按顺序查找 GOPATH 变量里列出的目录。
如果编译器查遍 GOPATH 也没有找到要导入的包，那么在试图对程序执行 run 或者 build
的时候就会出错。本章后面会介绍如何通过 go get 命令来修正这种错误。
3.2.1  远程导入 
目前的大势所趋是，使用分布式版本控制系统（Distributed Version Control Systems，DVCS）
来分享代码，如 GitHub、Launchpad 还有 Bitbucket。Go 语言的工具链本身就支持从这些网站及
类似网站获取源代码。Go 工具链会使用导入路径确定需要获取的代码在网络的什么地方。 
例如： 
import "github.com/spf13/viper" 
用导入路径编译程序时，go build 命令会使用 GOPATH 的设置，在磁盘上搜索这个包。事实上，
这个导入路径代表一个 URL，指向 GitHub 上的代码库。如果路径包含 URL，可以使用 Go 工具链从
DVCS 获取包，并把包的源代码保存在 GOPATH 指向的路径里与 URL 匹配的目录里。这个获取过程
使用 go get 命令完成。go get 将获取任意指定的 URL 的包，或者一个已经导入的包所依赖的其
他包。由于 go get 的这种递归特性，这个命令会扫描某个包的源码树，获取能找到的所有依赖包。 
3.2.2  命名导入 
如果要导入的多个包具有相同的名字，会发生什么？例如，既需要 network/convert 包
来转换从网络读取的数据，又需要 file/convert 包来转换从文本文件读取的数据时，就会同
时导入两个名叫 convert 的包。这种情况下，重名的包可以通过命名导入来导入。命名导入是
指，在 import 语句给出的包路径的左侧定义一个名字，将导入的包命名为新名字。
例如，若用户已经使用了标准库里的 fmt 包，现在要导入自己项目里名叫 fmt 的包，就可
以通过代码清单 3-4 所示的命名导入方式，在导入时重新命名自己的包。 
代码清单 3-4 重命名导入 
01 package main 
02 
03 import ( 
04 
 "fmt" 
05 
 myfmt "mylib/fmt" 
06 ) 
07 
08 func main() { 
这就是标准库源 
代码所在的位置。 
3.3  函数 init
41 
09 
 fmt.Println("Standard Library") 
10 
 myfmt.Println("mylib/fmt") 
11 } 
当你导入了一个不在代码里使用的包时，Go 编译器会编译失败，并输出一个错误。Go 开发
团队认为，这个特性可以防止导入了未被使用的包，避免代码变得臃肿。虽然这个特性会让人觉
得很烦，但 Go 开发团队仍然花了很大的力气说服自己，决定加入这个特性，用来避免其他编程
语言里常常遇到的一些问题，如得到一个塞满未使用库的超大可执行文件。很多语言在这种情况
会使用警告做提示，而 Go 开发团队认为，与其让编译器告警，不如直接失败更有意义。每个编
译过大型 C 程序的人都知道，在浩如烟海的编译器警告里找到一条有用的信息是多么困难的一件
事。这种情况下编译失败会更加明确。 
有时，用户可能需要导入一个包，但是不需要引用这个包的标识符。在这种情况，可以使用
空白标识符_来重命名这个导入。我们下节会讲到这个特性的用法。 
空白标识符  下划线字符（_）在 Go 语言里称为空白标识符，有很多用法。这个标识符用来抛弃不
想继续使用的值，如给导入的包赋予一个空名字，或者忽略函数返回的你不感兴趣的值。 
3.3  函数 init 
每个包可以包含任意多个 init 函数，这些函数都会在程序执行开始的时候被调用。所有被
编译器发现的 init 函数都会安排在 main 函数之前执行。init 函数用在设置包、初始化变量
或者其他要在程序运行前优先完成的引导工作。 
以数据库驱动为例，database 下的驱动在启动时执行 init 函数会将自身注册到 sql 包
里，因为 sql 包在编译时并不知道这些驱动的存在，等启动之后 sql 才能调用这些驱动。让我
们看看这个过程中 init 函数做了什么，如代码清单 3-5 所示。 
代码清单 3-5 init 函数的用法 
01 package postgres 
02 
03 import ( 
04 
 "database/sql" 
05 ) 
06 
07 func init() { 
08 
 sql.Register("postgres", new(PostgresDriver)) 
09 } 
这段示例代码包含在 PostgreSQL 数据库的驱动里。如果程序导入了这个包，就会调用 init
函数，促使 PostgreSQL 的驱动最终注册到 Go 的 sql 包里，成为一个可用的驱动。 
在使用这个新的数据库驱动写程序时，我们使用空白标识符来导入包，以便新的驱动会包含
到 sql 包。如前所述，不能导入不使用的包，为此使用空白标识符重命名这个导入可以让 init
函数发现并被调度运行，让编译器不会因为包未被使用而产生错误。 
创建一个 postgres 驱动的
实例。这里为了展现 init 的
作用，没有展现其定义细节。 
现在我们可以调用 sql.Open 方法来使用这个驱动，如代码清单 3-6 所示。
代码清单 3-6 导入时使用空白标识符作为包的别名 
01 package main 
02 
03 import ( 
04 
 "database/sql" 
05 
06 
 _ "github.com/goinaction/code/chapter3/dbdriver/postgres"  
07 ) 
08 
09 func main() { 
10 
 sql.Open("postgres", "mydb") 
11 } 
3.4  使用 Go 的工具 
在前几章里，我们已经使用过了 go 这个工具，但我们还没有探讨这个工具都能做哪些事情。
让我们进一步深入了解这个短小的命令，看看都有哪些强大的能力。在命令行提示符下，不带参
数直接键入 go 这个命令：
$ go 
go 这个工具提供了很多功能，如图 3-1 所示。