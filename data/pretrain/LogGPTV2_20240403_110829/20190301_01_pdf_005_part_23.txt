SELECT CURRENT_DATE FROM DUAL;
date
-----------
06-AUG-07
CURRENT_TIMESTAMP returns the current date and time. When called from a single SQL
statement, it will return the same value for each occurrence within the statement. If
called from multiple statements within a transaction, may return different values for each
occurrence. If called from a function, may return a different value than the value
returned by current_timestamp in the caller.
SELECT CURRENT_TIMESTAMP, CURRENT_TIMESTAMP FROM DUAL;
current_timestamp | current_timestamp
----------------------------------+----------------------------------
02-SEP-13 17:52:29.261473 +05:00 | 02-SEP-13 17:52:29.261474 +05:00
LOCALTIMESTAMP can optionally be given a precision parameter which causes the result
to be rounded to that many fractional digits in the seconds field. Without a precision
parameter, the result is given to the full available precision.
SELECT LOCALTIMESTAMP FROM DUAL;
timestamp
------------------------
06-AUG-07 16:11:35.973
(1 row)
SELECT LOCALTIMESTAMP(2) FROM DUAL;
timestamp
-----------------------
06-AUG-07 16:11:44.58
(1 row)
Copyright © 2007 - 2018 EnterpriseDB Corporation. All rights reserved. 268
Database Compatibility for Oracle® Developers
Reference Guide
Since these functions return the start time of the current transaction, their values do not
change during the transaction. This is considered a feature: the intent is to allow a single
transaction to have a consistent notion of the “current” time, so that multiple
modifications within the same transaction bear the same time stamp. Other database
systems may advance these values more frequently.
2.4.8.9 NUMTODSINTERVAL
The NUMTODSINTERVAL function converts a numeric value to a time interval that
includes day through second interval units. When calling the function, specify the
smallest fractional interval type to be included in the result set. The valid interval types
are DAY, HOUR, MINUTE, and SECOND.
The following example converts a numeric value to a time interval that includes days and
hours:
SELECT numtodsinterval(100, „hour‟);
numtodsinterval
---------------
4 days 04:00:00
(1 row)
The following example converts a numeric value to a time interval that includes minutes
and seconds:
SELECT numtodsinterval(100, „second‟);
numtodsinterval
---------------
1 min 40 secs
(1 row)
2.4.8.10 NUMTOYMINTERVAL
The NUMTOYMINTERVAL function converts a numeric value to a time interval that
includes year through month interval units. When calling the function, specify the
smallest fractional interval type to be included in the result set. The valid interval types
are YEAR and MONTH.
The following example converts a numeric value to a time interval that includes years
and months:
SELECT numtoyminterval(100, „month‟);
numtoyminterval
---------------
8 years 4 mons
(1 row)
Copyright © 2007 - 2018 EnterpriseDB Corporation. All rights reserved. 269
Database Compatibility for Oracle® Developers
Reference Guide
The following example converts a numeric value to a time interval that includes years
only:
SELECT numtoyminterval(100, „year‟);
numtoyminterval
---------------
100 years
(1 row)
Copyright © 2007 - 2018 EnterpriseDB Corporation. All rights reserved. 270
Database Compatibility for Oracle® Developers
Reference Guide
2.4.9 Sequence Manipulation Functions
This section describes Advanced Server‟s functions for operating on sequence objects.
Sequence objects (also called sequence generators or just sequences) are special single-
row tables created with the CREATE SEQUENCE command. A sequence object is usually
used to generate unique identifiers for rows of a table. The sequence functions, listed
below, provide simple, multiuser-safe methods for obtaining successive sequence values
from sequence objects.
sequence.NEXTVAL
sequence.CURRVAL
sequence is the identifier assigned to the sequence in the CREATE SEQUENCE
command. The following describes the usage of these functions.
NEXTVAL
Advance the sequence object to its next value and return that value. This is done
atomically: even if multiple sessions execute NEXTVAL concurrently, each will
safely receive a distinct sequence value.
CURRVAL
Return the value most recently obtained by NEXTVAL for this sequence in the
current session. (An error is reported if NEXTVAL has never been called for this
sequence in this session.) Notice that because this is returning a session-local
value, it gives a predictable answer whether or not other sessions have executed
NEXTVAL since the current session did.
If a sequence object has been created with default parameters, NEXTVAL calls on it will
return successive values beginning with 1. Other behaviors can be obtained by using
special parameters in the CREATE SEQUENCE command.
Important: To avoid blocking of concurrent transactions that obtain numbers from the
same sequence, a NEXTVAL operation is never rolled back; that is, once a value has been
fetched it is considered used, even if the transaction that did the NEXTVAL later aborts.
This means that aborted transactions may leave unused "holes" in the sequence of
assigned values.
Copyright © 2007 - 2018 EnterpriseDB Corporation. All rights reserved. 271
Database Compatibility for Oracle® Developers
Reference Guide
2.4.10 Conditional Expressions
The following section describes the SQL-compliant conditional expressions available in
Advanced Server.
2.4.10.1 CASE
The SQL CASE expression is a generic conditional expression, similar to if/else
statements in other languages:
CASE WHEN condition THEN result
[ WHEN ... ]
[ ELSE result ]
END
CASE clauses can be used wherever an expression is valid. condition is an expression
that returns a BOOLEAN result. If the result is TRUE then the value of the CASE expression
is the result that follows the condition. If the result is FALSE any subsequent WHEN
clauses are searched in the same manner. If no WHEN condition is TRUE then the value
of the CASE expression is the result in the ELSE clause. If the ELSE clause is omitted
and no condition matches, the result is NULL.
An example:
SELECT * FROM test;
a
---
1
2
3
(3 rows)
SELECT a,
CASE WHEN a=1 THEN 'one'
WHEN a=2 THEN 'two'
ELSE 'other'
END
FROM test;
a | case
---+-------
1 | one
2 | two
3 | other
(3 rows)
The data types of all the result expressions must be convertible to a single output type.
Copyright © 2007 - 2018 EnterpriseDB Corporation. All rights reserved. 272
Database Compatibility for Oracle® Developers
Reference Guide
The following “simple” CASE expression is a specialized variant of the general form
above:
CASE expression
WHEN value THEN result
[ WHEN ... ]
[ ELSE result ]
END
The expression is computed and compared to all the value specifications in the WHEN
clauses until one is found that is equal. If no match is found, the result in the ELSE
clause (or a null value) is returned.
The example above can be written using the simple CASE syntax:
SELECT a,
CASE a WHEN 1 THEN 'one'
WHEN 2 THEN 'two'
ELSE 'other'
END
FROM test;
a | case
---+-------
1 | one
2 | two
3 | other
(3 rows)
A CASE expression does not evaluate any subexpressions that are not needed to determine
the result. For example, this is a possible way of avoiding a division-by-zero failure:
SELECT ... WHERE CASE WHEN x <> 0 THEN y/x > 1.5 ELSE false END;
2.4.10.2 COALESCE
The COALESCE function returns the first of its arguments that is not null. Null is returned
only if all arguments are null.
COALESCE(value [, value2 ] ... )
It is often used to substitute a default value for null values when data is retrieved for
display or further computation. For example:
SELECT COALESCE(description, short_description, '(none)') ...
Like a CASE expression, COALESCE will not evaluate arguments that are not needed to
determine the result; that is, arguments to the right of the first non-null argument are not
evaluated. This SQL-standard function provides capabilities similar to NVL and IFNULL,
which are used in some other database systems.
Copyright © 2007 - 2018 EnterpriseDB Corporation. All rights reserved. 273
Database Compatibility for Oracle® Developers
Reference Guide
2.4.10.3 NULLIF
The NULLIF function returns a null value if value1 and value2 are equal; otherwise it
returns value1.
NULLIF(value1, value2)
This can be used to perform the inverse operation of the COALESCE example given
above:
SELECT NULLIF(value1, '(none)') ...
If value1 is (none), return a null, otherwise return value1.
2.4.10.4 NVL
The NVL function returns the first of its arguments that is not null. NVL evaluates the first
expression; if that expression evaluates to NULL, NVL returns the second expression.
NVL(expr1, expr2)
The return type is the same as the argument types; all arguments must have the same data
type (or be coercible to a common type). NVL returns NULL if all arguments are NULL.
The following example computes a bonus for non-commissioned employees, If an
employee is a commissioned employee, this expression returns the employees
commission; if the employee is not a commissioned employee (that is, his commission is
NULL), this expression returns a bonus that is 10% of his salary.
bonus = NVL(emp.commission, emp.salary * .10)
2.4.10.5 NVL2
NVL2 evaluates an expression, and returns either the second or third expression,
depending on the value of the first expression. If the first expression is not NULL, NVL2
returns the value in expr2; if the first expression is NULL, NVL2 returns the value in
expr3.
NVL2(expr1, expr2, expr3)
The return type is the same as the argument types; all arguments must have the same data
type (or be coercible to a common type).
The following example computes a bonus for commissioned employees - if a given
employee is a commissioned employee, this expression returns an amount equal to 110%
Copyright © 2007 - 2018 EnterpriseDB Corporation. All rights reserved. 274
Database Compatibility for Oracle® Developers
Reference Guide
of his commission; if the employee is not a commissioned employee (that is, his
commission is NULL), this expression returns 0.
bonus = NVL2(emp.commission, emp.commission * 1.1, 0)
2.4.10.6 GREATEST and LEAST
The GREATEST and LEAST functions select the largest or smallest value from a list of any
number of expressions.
GREATEST(value [, value2 ] ... )
LEAST(value [, value2 ] ... )
The expressions must all be convertible to a common data type, which will be the type of
the result. Null values in the list are ignored. The result will be null only if all the
expressions evaluate to null.
Note that GREATEST and LEAST are not in the SQL standard, but are a common
extension.
Copyright © 2007 - 2018 EnterpriseDB Corporation. All rights reserved. 275
Database Compatibility for Oracle® Developers
Reference Guide
2.4.11 Aggregate Functions
Aggregate functions compute a single result value from a set of input values. The built-in
aggregate functions are listed in the following tables.
Table 2-30 General-Purpose Aggregate Functions
Function Argument Type Return Type Description
INTEGER, REAL, NUMBER for any integer
DOUBLE PRECISION,
type, DOUBLE PRECISION
NUMBER
for a floating-point The average (arithmetic mean) of
AVG(expression)
argument, otherwise the all input values
same as the argument data
type
COUNT(*) BIGINT Number of input rows
Any Number of input rows for which
COUNT(expression) BIGINT
the value of expression is not null
Any numeric, string, Maximum value of expression
MAX(expression) Same as argument type
date/time, or bytea type across all input values
Any numeric, string, Minimum value of expression
MIN(expression) Same as argument type
date/time, or bytea type across all input values
INTEGER, REAL, BIGINT for SMALLINT or
DOUBLE PRECISION,
INTEGER arguments,
NUMBER
NUMBER for BIGINT
arguments, DOUBLE Sum of expression across all input
SUM(expression)
PRECISION for floating- values
point arguments, otherwise
the same as the argument
data type
It should be noted that except for COUNT, these functions return a null value when no
rows are selected. In particular, SUM of no rows returns null, not zero as one might
expect. The COALESCE function may be used to substitute zero for null when necessary.
The following table shows the aggregate functions typically used in statistical analysis.
(These are separated out merely to avoid cluttering the listing of more-commonly-used
aggregates.) Where the description mentions N, it means the number of input rows for
which all the input expressions are non-null. In all cases, null is returned if the
computation is meaningless, for example when N is zero.
Table 2-31 Aggregate Functions for Statistics
Function Argument Type Return Type Description
CORR(Y, X) DOUBLE PRECISION DOUBLE PRECISION Correlation coefficient
COVAR_POP(Y, X) DOUBLE PRECISION DOUBLE PRECISION Population covariance
COVAR_SAMP(Y, X) DOUBLE PRECISION DOUBLE PRECISION Sample covariance
Average of the independent
REGR_AVGX(Y, X) DOUBLE PRECISION DOUBLE PRECISION
variable (sum(X) / N)
Copyright © 2007 - 2018 EnterpriseDB Corporation. All rights reserved. 276
Database Compatibility for Oracle® Developers
Reference Guide
Function Argument Type Return Type Description
Average of the dependent
REGR_AVGY(Y, X) DOUBLE PRECISION DOUBLE PRECISION
variable (sum(Y) / N)
Number of input rows in
REGR_COUNT(Y, X) DOUBLE PRECISION DOUBLE PRECISION which both expressions are
nonnull
y-intercept of the least-
squares-fit linear equation
REGR_INTERCEPT(Y, X) DOUBLE PRECISION DOUBLE PRECISION
determined by the (X, Y)
pairs
Square of the correlation
REGR_R2(Y, X) DOUBLE PRECISION DOUBLE PRECISION
coefficient
Slope of the least-squares-
fit linear equation
REGR_SLOPE(Y, X) DOUBLE PRECISION DOUBLE PRECISION
determined by the (X, Y)
pairs
Sum (X2) – sum (X)2 / N
REGR_SXX(Y, X) DOUBLE PRECISION DOUBLE PRECISION (“sum of squares” of the
independent variable)
Sum (X*Y) – sum (X) * sum
(Y) / N (“sum of products”
REGR_SXY(Y, X) DOUBLE PRECISION DOUBLE PRECISION
of independent times
dependent variable)
Sum (Y2) – sum (Y)2 / N
REGR_SYY(Y, X) DOUBLE PRECISION DOUBLE PRECISION (“sum of squares” of the
dependent variable)
INTEGER, REAL, DOUBLE PRECISION for
Historic alias for
STDDEV(expression) DOUBLE PRECISION, floating-point arguments,
STDDEV_SAMP
NUMBER otherwise NUMBER
INTEGER, REAL, DOUBLE PRECISION for Population standard
STDDEV_POP(expression) DOUBLE PRECISION, floating-point arguments, deviation of the input
NUMBER otherwise NUMBER values
INTEGER, REAL, DOUBLE PRECISION for
Sample standard deviation
STDDEV_SAMP(expression) DOUBLE PRECISION, floating-point arguments,
of the input values
NUMBER otherwise NUMBER
INTEGER, REAL, DOUBLE PRECISION for
Historical alias for
VARIANCE(expression) DOUBLE PRECISION, floating-point arguments,
VAR_SAMP
NUMBER otherwise NUMBER
Population variance of the
INTEGER, REAL, DOUBLE PRECISION for
input values (square of the
VAR_POP(expression) DOUBLE PRECISION, floating-point arguments,
population standard
NUMBER otherwise NUMBER
deviation)
INTEGER, REAL, DOUBLE PRECISION for Sample variance of the
VAR_SAMP(expression) DOUBLE PRECISION, floating-point arguments, input values (square of the
NUMBER otherwise NUMBER sample standard deviation)
Copyright © 2007 - 2018 EnterpriseDB Corporation. All rights reserved. 277
Database Compatibility for Oracle® Developers
Reference Guide
2.4.12 Subquery Expressions
This section describes the SQL-compliant subquery expressions available in Advanced
Server. All of the expression forms documented in this section return Boolean
(TRUE/FALSE) results.
2.4.12.1 EXISTS
The argument of EXISTS is an arbitrary SELECT statement, or subquery. The subquery is
evaluated to determine whether it returns any rows. If it returns at least one row, the
result of EXISTS is TRUE; if the subquery returns no rows, the result of EXISTS is
FALSE.
EXISTS(subquery)
The subquery can refer to variables from the surrounding query, which will act as
constants during any one evaluation of the subquery.
The subquery will generally only be executed far enough to determine whether at least
one row is returned, not all the way to completion. It is unwise to write a subquery that
has any side effects (such as calling sequence functions); whether the side effects occur
or not may be difficult to predict.
Since the result depends only on whether any rows are returned, and not on the contents
of those rows, the output list of the subquery is normally uninteresting. A common
coding convention is to write all EXISTS tests in the form EXISTS(SELECT 1 WHERE
...). There are exceptions to this rule however, such as subqueries that use INTERSECT.
This simple example is like an inner join on deptno, but it produces at most one output
row for each dept row, even though there are multiple matching emp rows:
SELECT dname FROM dept WHERE EXISTS (SELECT 1 FROM emp WHERE emp.deptno =
dept.deptno);
dname
------------
ACCOUNTING
RESEARCH
SALES
(3 rows)
2.4.12.2 IN
The right-hand side is a parenthesized subquery, which must return exactly one column.
The left-hand expression is evaluated and compared to each row of the subquery result.
Copyright © 2007 - 2018 EnterpriseDB Corporation. All rights reserved. 278