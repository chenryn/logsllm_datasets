普通的写法吧。
本次的HariMain节选 9
struct BOOTINFO {
char cyls, leds, vmode, reserve;
10
short scrnx, scrny;
char *vram;
};
11
void HariMain(void)
{
char *vram;
int xsize, ysize; 12
struct BOOTINFO *binfo;
init_palette();
13
binfo = (struct BOOTINFO *) 0x0ff0;
xsize = (*binfo).scrnx;
ysize = (*binfo).scrny;
vram = (*binfo).vram; 14
我们写成了上面这种形式。struct是新语句。这里第一次出现结构体，或许有人不太理解，
15
如果不明白的话请一定看看后面的专栏。
最开始的struct命令只是把一串变量声明集中起来，统一叫做“struct BOOTINFO”。最初是1
16
字节的变量cyls，接着是1字节的变量leds，照此下去，最后是vram。这一串变量一共是12字节。
图灵社区会员 metorm 专享 尊重版权
90 …… 第5天：结构体、文字显示与GDT/IDT初始化
有了这样的声明，以后“struct BOOTINFO”就可以作为一个新的变量类型，用于各种场合，可
以像int、char那样的变量类型一样使用。
这里的*binfo就是这种类型的变量，为了表示其中的scrnx，使用了（*binfo）.scrnx这种写法。
如果不加括号直接写成*binfo.scrnx，虽然更容易懂，但编译器会误解成*（binfo.scrnx），出现错
误。所以，括号虽然不太好看，但不能省略。
COLUMN-5 结构体的简单说明
5.2节①里的这种结构体的使用方法，比较特殊。我们先看一个普通的例子。
普通的结构体使用方法
void HariMain(void)
{
struct BOOTINFO abc;
abc.scrnx = 320;
abc.scrny = 200;
abc.vram = 0xa0000;
（以下略）
}
先定义一个新结构体变量 abc，然后再给这个结构体变量的各个元素赋值。结构体的
好处是，可以像下面这样将各种东西都一股脑儿地传递过来。
func(abc);
如果没有结构体，就只能将各个参数一个一个地传递过来了。
func(scrnx, scrny, vram, ...);
所以很多时候会将有某种意义的数据都归纳到一个结构体里，这样就方便多了。但如
果归纳方法搞错了，反而带来更多麻烦。
为了让程序能一看就懂，要这样写结构体的内部变量：在结构体变量名的后面加一个
点（.），然后再写内部变量名，这是规则。
■■■■■
下一步是使用指针。这是5.2节中的使用方法。声明方法如下：
变量类型名 *指针变量名;(回想一下char *p;)
而这次的变量类型是struct BOOTINFO，变量名是binfo，所以写成如下形式：
struct BOOTINFO *binfo;
——————————
① 第5天的第2小节。——译者注
图灵社区会员 metorm 专享 尊重版权
4 显示字符（harib02d） …… 91
这里的binfo表示指针变量。地址用4个字节来表示，所以binfo是4字节变量。 1
因为是指针变量，所以应该首先给指针赋值，否则就不知道要往哪里读写了。可以写
成下面这样：
2
binfo = (struct BOOTINFO *)0x0ff0;
本来想写“binfo =0x0ff0;”的，但由于总出警告，很讨厌，所以我们就进行了类型转换。
3
设定了指针地址以后，这12个字节的结构体用起来就没问题了。这样我们可以不再直
接使用内存地址，而是使用*binfo来表示这个内存地址上12字节的结构体。这与“char *p;”
中的*p表示p地址的1字节是同样道理。 4
前面说过，想要表示结构体 abc 中的 scrnx 时，就用 abc.scrnx。与此类似，这里用
(*binfo).scrnx来表示。需要括号的理由在5.2节中已经写了。因此语句写作： 5
xsize = (*binfo).scrnx;
5
33 试用箭头记号（harib02c）
事实上，在C语言里常常会用到类似于（*binfo）.scrnx的表现手法，因此出现了一种不使用 7
括号的省略表现方式，即binfo→scrnx，我们称之为箭头标记方式。前面也讲到过，a[i]是*（a + i）
的省略表现形式所以可以说C语言中关于指针的省略表现形式很充实，很丰富。
8
使用箭头，可以将“xsize = (*binfo).scrnx;”写成“xsize = binfo>scrnx；”，简单又方便。不
过我们还想更简洁些，即连变量xsize都不用，而是直接以binfo>scrnx来代替xsize。
9
本次的HariMain节选
10
void HariMain(void)
{
struct BOOTINFO *binfo = (struct BOOTINFO *) 0x0ff0;
11
init_palette();
init_screen(binfo->vram, binfo->scrnx, binfo->scrny);
12
哦，看上去真清爽。我们运行一下“make run”，运行正常。
这次我们想了很多方法，但这些都只是C语言写法的问题，编译成机器语言以后，几乎没有
13
差别。既然没有差别，笔者认为写得清晰一些没什么坏处，所以决定今后积极使用这种写法。讨
厌在写法上花工夫的人不使用结构体也没关系，再退一步，还可以不用指针，继续使用write_mem8
14
什么的也没问题。可以根据自己的理解程度和习惯，选择自己喜欢的方式。
44 显示字符（harib02d） 15
内部的处理差不多了，我们还是将重点放回到外部显示上来吧。到昨天为止，我们算是画出 16
图灵社区会员 metorm 专享 尊重版权
92 …… 第5天：结构体、文字显示与GDT/IDT初始化
了一幅稍微像样的画，今天就来在画面上写字。以前我们显示字符主要靠调用BIOS函数，但这
次是32位模式，不能再依赖BIOS了，只能自力更生。
那么怎么显示字符呢？字符可以用8×16的长方形像素点阵来表示。想象一个下图左边的数
据，然后按下图右边所示的方法置换成0和1，这个方法好像不错。然后根据这些数据在画面上打
上点就肯定能显示出字符了。8“位”是一个字节，而1个字符是16个字节。
大家可能会有各种想法，比如“我觉得8×16的字太小了，想显示得更大一些”、“还是小点儿
的字好”等。不过刚开始我们就先这样吧，一上来要求太多的话，就没有办法往前进展了。
■■■■■
像这种描画文字形状的数据称为字体（font）数据，那这种字体数据是怎样写到程序里的呢？
有一种临时方案：
static char font_A[16] = {
0x00, 0x18, 0x18, 0x18, 0x18, 0x24, 0x24, 0x24,
0x24, 0x7e, 0x42, 0x42, 0x42, 0xe7, 0x00, 0x00
};
其实这仅仅是将刚才的0和1的排列，重写成十六进制数而已。C语言无法用二进制数记录数
据，只能写成十六进制或八进制。嗯，读起来真费劲呀。嫌字体不好看，想手动修正一下，都不
知道到底需要修改哪儿。但是暂时就先这样吧，以后再考虑这个问题。
数据齐备之后，只要描画到画面上就可以了。用for语句将画8个像素的程序循环16遍，就可
图灵社区会员 metorm 专享 尊重版权
4 显示字符（harib02d） …… 93
以显示出一个字符了。于是我们制作了下面这个函数。 1
void putfont8(char *vram, int xsize, int x, int y, char c, char *font)
{ 2
int i;
char d; /* data */
for (i = 0; i ”。
9
■■■■■
虽然这样也能显示出“A”来，但还是把程序稍微整理一下比较好，因为现在的程序又长运 10
行速度又慢。
11
void putfont8(char *vram, int xsize, int x, int y, char c, char *font)
{
int i;
char *p, d /* data */; 12
for (i = 0; i < 16; i++) {
p = vram + (y + i) * xsize + x;
d = font[i]; 13
if ((d & 0x80) != 0) { p[0] = c; }
if ((d & 0x40) != 0) { p[1] = c; }
if ((d & 0x20) != 0) { p[2] = c; }
if ((d & 0x10) != 0) { p[3] = c; } 14
if ((d & 0x08) != 0) { p[4] = c; }
if ((d & 0x04) != 0) { p[5] = c; }
if ((d & 0x02) != 0) { p[6] = c; } 15
if ((d & 0x01) != 0) { p[7] = c; }
}
return;
} 16
图灵社区会员 metorm 专享 尊重版权
94 …… 第5天：结构体、文字显示与GDT/IDT初始化
这样就好多了，我们就用这段程序吧。
下面将这段程序嵌入到bootpack.c中进行整理。大家仔细看看，如果顺利的话，能显示出字
符“A”。紧张激动的时刻到了，运行“make run”。哦，“A”显示出来了！
55 增加字体（harib02e）
虽然字符“A”显示出来了，但这段程序只能显示“A”而不能显示别的字符。所以我们需
要很多别的字体来显示其他字符。英文字母就有26个，分别有大写和小写，还有10个数字，再加
上各种符号肯定超过30个了。啊，还有很多，太麻烦了，所以我们决定沿用OSASK的字体数据。
当然，我们暂时还不考虑显示汉字什么的。这些复杂的东西，留待以后再做。现在我们集中精力
解决字母显示的问题。
另外，这里沿用的OSASK的字体，其作者不是笔者，而是平木敬太郎先生和圣人（Kiyoto）
先生。事先已经从他们那里得到了使用许可权，所以可以自由使用这种字体。
我们这次就将hankaku.txt这个文本文件加入到我们的源程序大家庭中来。这个文件的内容如下：
hankaku.txt的内容
char 0x41
........
...**...
...**...
...**...
...**...
..*..*..
..*..*..
..*..*..
..*..*..
.******.
.*....*.
.*....*.
.*....*.
***..***
........
........
图灵社区会员 metorm 专享 尊重版权
5 增加字体（harib02e） …… 95
这比十六进制数和只有0和1的二进制数都容易看一些。
1
■■■■■
2
当然，这既不是C语言，也不是汇编语言，所以需要专用的编译器。新做一个编译器很麻烦，
所以我们还是使用在制作OSASK时曾经用过的工具（makefont.exe）。说是编译器，其实有点言
过其实了，只不过是将上面这样的文本文件（256个字符的字体文件）读进来，然后输出成 3
16×256=4096字节的文件而已。
4
编译后生成hankaku.bin文件，但仅有这个文件还不能与bootpack.obj连接，因为它不是目标
（obj）文件。所以，还要加上连接所必需的接口信息，将它变成目标文件。这项工作由bin2obj.exe
来完成。它的功能是将所给的文件自动转换成目标程序，就像将源程序转换成汇编那样。也就是 5
说，好像将下面这两行程序编译成了汇编：
_hankanku: 5
DB 各种数据（共4096字节）
当然，如果大家不喜欢现在这种字体的话，可以随便修改hankaku.txt。本书的中心任务是自 7
制操作系统，所以字体就由大家自己制作了。
各种工具的使用方法，请参阅Makefile的内容。因为不是很难，这里就不再说明了。 8
如果在C语言中使用这种字体数据，只需要写上以下语句就可以了。
9
extern char hankaku[4096];
像这种在源程序以外准备的数据，都需要加上extern属性。这样，C编译器就能够知道它是外
10
部数据，并在编译时做出相应调整。
■■■■■ 11
OSASK的字体数据，依照一般的ASCII字符编码，含有256个字符。A的字符编码是0x41，所
以A的字体数据，放在自“hankaku + 0x41 * 16”开始的16字节里。C语言中A的字符编码可以用’A’ 12
来表示，正好可以用它来代替0x41，所以也可以写成“hankaku + ‘A’ * 16”。
我们使用以上字体数据，向bootpack.c里添加了很多内容，请大家浏览一下。如果顺利的话， 13
会显示出“ABC 123”。下面就来“make run”一下吧。很好，运行正常。
14
本次的HariMain的内容
void HariMain(void)
{ 15
struct BOOTINFO *binfo = (struct BOOTINFO *) 0x0ff0;
extern char hankaku[4096];
16
init_palette();
图灵社区会员 metorm 专享 尊重版权
96 …… 第5天：结构体、文字显示与GDT/IDT初始化