# The Secure Socket API: TLS as an Operating System Service

**Authors:** Mark O’Neill, Scott Heidbrink, Jordan Whitehead, Tanner Perdue, Luke Dickinson, Torstein Collett, Nick Bonner, Kent Seamons, and Daniel Zappala  
**Affiliation:** Brigham Young University  
**Conference:** 27th USENIX Security Symposium, August 15–17, 2018, Baltimore, MD, USA  
**Proceedings ISBN:** 978-1-939133-04-5  
**Open Access Sponsored by:** USENIX  
**Link:** [https://www.usenix.org/conference/usenixsecurity18/presentation/oneill](https://www.usenix.org/conference/usenixsecurity18/presentation/oneill)

## Abstract
SSL/TLS libraries are notoriously difficult for developers to use, leading to buggy and vulnerable applications. This paper explores the use of the standard POSIX socket API as a vehicle for a simplified TLS API, while also providing administrators with the ability to control and tailor TLS configurations. We first assess OpenSSL and its usage in open-source software, recommending how this functionality should be integrated into the POSIX API. We then propose the Secure Socket API (SSA), a minimalist TLS API built using existing network functions, which can be employed by existing network applications with minimal code modifications. We describe a prototype SSA implementation that leverages network system calls to provide privilege separation and support for other programming languages. Finally, we discuss the benefits and limitations of the SSA and our accompanying implementation, noting avenues for future work.

## 1. Introduction
Transport Layer Security (TLS) is the most widely used security protocol on the Internet, enabling secure communication between network applications. However, improper use of TLS can result in vulnerabilities to various attacks. Popular security libraries like OpenSSL and GnuTLS, while feature-rich and widely used, have long been plagued by programmer misuse. The complexity and design of these libraries make them challenging to use correctly, even for experienced developers and security experts. For example, Georgiev et al. found that the "terrible design of [security library] APIs" is the root cause of many authentication vulnerabilities [11].

Recent efforts have cataloged developer mistakes and the complexities of modern security APIs [8, 12, 23, 4, 19]. Projects have emerged to reduce the size of security APIs [20], enhance library security [1], and perform certificate validation checks on behalf of vulnerable applications [3, 18, 9, 5]. A common conclusion from these works is that TLS libraries need to be redesigned to be simpler for developers to use securely.

In this work, we present the Secure Socket API (SSA), a TLS API designed to work within the existing standard POSIX socket API familiar to network programmers. We extend the POSIX socket API in a natural way, providing backward compatibility with the existing interface. Our analysis of current security library usage and careful interaction with kernel network code ensures that our implementation does not introduce significant performance overhead. The SSA enables developers to quickly add TLS support to their applications and allows administrators to easily control how applications use TLS on their machines. We demonstrate our prototype SSA implementation across various use cases and show how it can be trivially integrated into existing programming languages.

Our contributions are as follows:
- **Analysis of Contemporary TLS Use:** An analysis of TLS usage by 410 Linux packages and a qualitative breakdown of OpenSSL's 504 API endpoints. This analysis provides design recommendations for the Secure Socket API and may serve as a guide for improving security library APIs.
- **Secure Socket API Description:** A detailed description of the Secure Socket API, its integration with the existing POSIX socket API, and examples of its usage. We also share experiences in creating new TLS applications using the SSA, which require as little as one line of code.
- **Prototype Implementation:** A description and source code for a prototype implementation of the Secure Socket API. We discuss the benefits and features of this implementation and demonstrate the ease of adding SSA support to other languages.
- **Dynamic Porting Tool:** A description and source code for a tool that dynamically ports existing OpenSSL-using applications to use the SSA without requiring modification.

Previous findings have motivated the need for simpler TLS APIs and better administrator controls. This work explores the utilization of the POSIX socket API as a possible solution to these needs. We also discuss the finer points of implementing and using the SSA, outlining the benefits and drawbacks of our chosen approach and suggesting alternative implementations. For users of the SSA, we discuss configuration options and deployment considerations for different platforms and user skill levels.

## 2. Motivation
The use of TLS in applications is complicated by intricate APIs and frequent developer mistakes, a problem well-documented in the literature. The libssl component of OpenSSL 1.0 alone exports 504 functions and macros for TLS implementation. This complexity is likely to persist, as the unreleased OpenSSL 1.1.1 has increased this number substantially. These and other TLS APIs have been criticized for their complexity [11, 12], and our explorations reveal many functions with non-intuitive semantics, confusing names, or little practical use. A body of work has cataloged developer mistakes in certificate validation, leading to man-in-the-middle vulnerabilities [4, 11, 8].

Another issue is the reliance on application developers to implement security, which limits the control administrators have over their systems. Administrators cannot dictate the TLS version, cipher suites, key sizes, or even whether TLS is used at all. This coupling of application functionality with security policy can make otherwise desirable applications unadoptable due to incompatible security requirements. When security flaws are discovered, administrators must wait for patches from developers, which may never come due to project shutdowns, financial constraints, or other reasons. Thus, TLS connection security is often at the mercy of developers who may not be well-versed in security APIs or the specific needs of system administrators.

One illustration of the demand for administrator control is the Redhat-led effort to create a system-wide "CryptoPolicy" configuration file [15]. Through custom changes in OpenSSL and GNUTLS, this file allows developers to defer some security settings to administrators.

The synthesis of these problems is that developers lack a common, usable security API, and administrators lack control over secure connections. In this paper, we explore a solution through the POSIX socket API and operating system control. We aim to improve on prior efforts by reducing the TLS API to a handful of functions already familiar to network programmers, making the TLS API nearly transparent. This drastically reduces the code required to use TLS and supports programming languages beyond C/C++ with a single API implementation. Developers can select TLS as if it were a built-in protocol like TCP or UDP, and administrators can configure TLS policies system-wide, allowing developers to request stricter security policies.

Shifting control of TLS to the operating system and administrators may be seen as controversial. However, most operating systems already offer critical services to applications to reduce code redundancy and ensure system stability and security. For example, application developers on Linux and Windows are not expected to write their own TCP implementation or file system functionality. Moreover, operating systems and system administrators tend to focus more on security matters [17]. Therefore, we believe that establishing operating system and administrator control over TLS and related security policies aligns with best practices.

## 3. SSA Design Goals
Our primary goal in developing the SSA is to create a solution that is both easy to use for developers and grants a high degree of control to system administrators. Since C/C++ developers on Linux and other Unix-like systems already use the POSIX socket API for network applications, this API represents a compelling path for simplifying TLS APIs. Other languages use this API directly or indirectly, either through implementation of socket system calls or by wrapping another implementation. If TLS usage can be mapped to existing POSIX API syntax and semantics, this mapping represents the simplest possible TLS API.

Under the POSIX socket API, developers specify their desired protocol using the last two parameters of the `socket` function, which specify the type of protocol (e.g., `SOCK_DGRAM`, `SOCK_STREAM`) and optionally the protocol itself (e.g., `IPPROTO_TCP`). Corresponding network operations such as `connect`, `send`, and `recv` then use the selected protocol in a manner transparent to the developer. We explore the possibility of fitting TLS within this paradigm. Ideally, a simplified TLS API designed around the POSIX socket API would merely add TLS as a new parameter value for the protocol (e.g., `IPPROTO_TLS`). Subsequent calls to POSIX socket functions would then perform the TLS handshake, encrypt and transmit data, and receive and decrypt data, respectively, based on the TLS protocol. Our design goals are as follows:

1. **Ease of Use for Developers:** Enable developers to use TLS through the existing set of functions provided by the POSIX socket API, without adding new functions or changing function signatures. Modifications to the API are acceptable only in the form of new values for existing parameters. This allows us to provide an API already familiar to network programmers and implemented by many existing programming languages, simplifying both automatic and manual porting to the SSA.
2. **Administrator Control:** Support direct administrator control over the parameters and settings for TLS connections made by the SSA. Applications should be able to increase, but not decrease, the security preferred by the administrator.
3. **Minimal Set of TLS Options:** Export a minimal set of TLS options to applications that allow general TLS use and drastically reduce the amount of TLS functions in contemporary TLS APIs.
4. **Language Support:** Facilitate the adoption of the SSA by other programming languages, easing the security burden on language implementations and providing broader security control to administrators.

## 4. OpenSSL Analysis
To achieve our goals, we first gather design recommendations and assess the feasibility of our approach by analyzing the OpenSSL API and its usage in popular software packages. We explore what functionality should be present in the SSA and how to distill the 504 TLS-related OpenSSL symbols (e.g., functions, macros) to the handful provided by the POSIX socket interface.

We limit our analysis to the features exported by `libssl`, the component of OpenSSL responsible for TLS functionality. With few exceptions, `libcrypto`, which supports generic cryptographic activities, is out of the scope of our study. GnuTLS and other libraries could also have been explored, but we chose OpenSSL due to its popularity and expansive feature set, leaving the assessment of other libraries to future work. For the results outlined, we analyzed OpenSSL 1.0.2 and software packages from Ubuntu 16.04. A full listing of our methods and results for our analysis of `libssl` is located at [owntrust.org](http://owntrust.org).

We collected the source code for all standard Ubuntu repository software packages that directly depend on `libssl`. We then filtered the resulting 882 packages for those using C/C++, leaving 410 packages for our analysis of direct use of `libssl`. Of these, 276 have TLS server functionality and 340 have TLS client functionality (248 have both). Note that packages using other languages may depend on OpenSSL by utilizing one of the packages in our analysis. We analyzed the source code of each package in our derived set in the context of its use of the symbols exported by `libssl`.

To obtain a comprehensive list of functionality offered by `libssl`, we extracted the symbols (e.g., functions, constants) it exports to applications. We also augmented this list of 323 symbols by recursively adding preprocessor macros that use already-identified symbols. This resulted in a cumulative list of 504 unique API symbols that developers can use when interfacing with OpenSSL’s `libssl`. We then cataloged the behavior and uses of each of these symbols using descriptions in the official API documentation, where such entries existed. Manual inspection of source code and unofficial third-party documentations were used to catalog symbols not present in the official documentation. We categorized each of the symbols into the groups shown in Table 1. Our selection of packages made a total of 24,124 calls to the `libssl` API.

The resulting categories are of two types: those that are used for specifying the behavior of the TLS protocol itself (e.g., symbols that indicate which TLS version to use, or how to validate a certificate), and those that relate specifically to OpenSSL’s implementation (e.g., symbols used to allocate and free OpenSSL structures, options to turn on bug workarounds). For each category, we employed both automated static code analysis techniques, using Joern [26], and manual inspection to understand the usage and behavior of the symbols.