title:The Secure Socket API: TLS as an Operating System Service
author:Mark O'Neill and
Scott Heidbrink and
Jordan Whitehead and
Tanner Perdue and
Luke Dickinson and
Torstein Collett and
Nick Bonner and
Kent E. Seamons and
Daniel Zappala
The Secure Socket API: TLS as an  
Operating System Service
Mark O’Neill, Scott Heidbrink, Jordan Whitehead, Tanner Perdue, Luke Dickinson,  
Torstein Collett, Nick Bonner, Kent Seamons, and Daniel Zappala, Brigham Young University
https://www.usenix.org/conference/usenixsecurity18/presentation/oneill
This paper is included in the Proceedings of the 
27th USENIX Security Symposium.
August 15–17, 2018 • Baltimore, MD, USA
ISBN 978-1-939133-04-5
Open access to the Proceedings of the 27th USENIX Security Symposium is sponsored by USENIX.The Secure Socket API: TLS as an Operating System Service
Mark O’Neill Scott Heidbrink
Jordan Whitehead Tanner Perdue
Luke Dickinson Torstein Collett Nick Bonner
Kent Seamons Daniel Zappala
Brigham Young University
PI:EMAIL, PI:EMAIL, PI:EMAIL, tanner PI:EMAIL
PI:EMAIL, PI:EMAIL, PI:EMAIL
PI:EMAIL, PI:EMAIL
Abstract
SSL/TLS libraries are notoriously hard for developers to
use, leaving system administrators at the mercy of buggy
and vulnerable applications. We explore the use of the
standard POSIX socket API as a vehicle for a simpli-
ﬁed TLS API, while also giving administrators the abil-
ity to control applications and tailor TLS conﬁguration
to their needs. We ﬁrst assess OpenSSL and its uses in
open source software, recommending how this function-
ality should be accommodated within the POSIX API.
We then propose the Secure Socket API (SSA), a min-
imalist TLS API built using existing network functions
and ﬁnd that it can be employed by existing network
applications by modiﬁcations requiring as little as one
line of code. We next describe a prototype SSA imple-
mentation that leverages network system calls to provide
privilege separation and support for other programming
languages. We end with a discussion of the beneﬁts and
limitations of the SSA and our accompanying implemen-
tation, noting avenues for future work.
1
Introduction
Transport Layer Security (TLS1) is the most popular
security protocol used on the Internet. Proper use of
TLS allows two network applications to establish a se-
cure communication channel between them. However,
improper use can result in vulnerabilities to various at-
tacks. Unfortunately, popular security libraries, such as
OpenSSL and GnuTLS, while feature-rich and widely-
used, have long been plagued by programmer misuse.
The complexity and design of these libraries can make
them hard to use correctly for application developers and
even security experts. For example, Georgiev et al. ﬁnd
that the “terrible design of [security library] APIs” is the
root cause of authentication vulnerabilities [11].
1Unless otherwise speciﬁed, we use TLS to indicate TLS and SSL
Signiﬁcant efforts to catalog developer mistakes and
the complexities of modern security APIs have been pub-
lished in recent years [8, 12, 23, 4, 19]. As a result,
projects have emerged that reduce the size of security
APIs [20], enhance library security [1], and perform cer-
tiﬁcate validation checks on behalf of vulnerable applica-
tions [3, 18, 9, 5]. A common conclusion of these works
is that TLS libraries need to be redesigned to be simpler
for developers to use securely.
In this work we present the Secure Socket API (SSA),
a TLS API for applications designed to work within the
conﬁnes of the existing standard POSIX socket API al-
ready familiar to network programmers. We extend the
POSIX socket API in a natural way, providing backwards
compatibility with the existing POSIX socket interface.
This effort required an analysis of current security library
use to guide our efforts, and careful interaction with ker-
nel network code to not introduce undue performance
overhead in our implementation. The SSA enables devel-
opers to quickly build TLS support into their applications
and administrators to easily control how applications use
TLS on their machines. We demonstrate our prototype
SSA implementation across a variety of use cases and
also show how it can be trivially integrated into existing
programming languages.
Our contributions are as follows:
• An analysis of contemporary use of TLS by 410
Linux packages and a qualitative breakdown of
OpenSSL’s 504 API endpoints for TLS functional-
ity. These analyses are accompanied by design rec-
ommendations for the Secure Socket API, and may
also serve as a guide for developers of security li-
braries to improve their own APIs.
• A description of the Secure Socket API and how it
ﬁts within the existing POSIX socket API, with de-
scriptions of the relevant functions, constants, and
administrator controls. We also provide example
usages and experiences creating new TLS applica-
USENIX Association
27th USENIX Security Symposium    799
tions using the SSA that require less than ten lines
of code and as little as one. We modify existing ap-
plications to use the SSA, resulting in the removal
of thousands of lines of existing code.
• A description of and source code for a prototype
implementation of the Secure Socket API. We also
provide a discussion of beneﬁts and features of this
implementation, and demonstrate the ease of adding
SSA support to other languages.
• A description of and source code for a tool that
dynamically ports existing OpenSSL-using applica-
tions to use the SSA without requiring modiﬁcation.
Previous ﬁndings have motivated the work for simpler
TLS APIs and better administrator controls. This work
explores utilization of the POSIX socket API as a possi-
ble avenue to address these needs.
We also discuss some ﬁner points regarding the im-
plementation and use of the SSA. We outline the ben-
eﬁts and drawbacks of our chosen implementation, and
do the same for some suggested alternative implemen-
tations. For users of the SSA, we discuss the avenues
for SSA conﬁguration and its deployment with respect to
different platforms and skill levels of users.
2 Motivation
TLS use by applications is mired by complicated APIs
and developer mistakes, a problem that has been well
documented. The libssl component of the OpenSSL
1.0 library alone exports 504 functions and macros for
use by TLS-implementing applications. This problem is
likely to persist, as the unreleased OpenSSL 1.1.1 has in-
creased this number substantially. This and other TLS
APIs have been criticized for their complexity [11, 12]
and, anecdotally, our own explorations ﬁnd many func-
tions within libssl that have non-intuitive semantics,
confusing names, or little-to-no use in applications. A
body of work has cataloged developer mistakes when
using these libraries to validate certiﬁcates, resulting in
man-in-the-middle vulnerabilities [4, 11, 8].
A related problem is that the reliance on application
developers to implement security inhibits the control ad-
ministrators have over their own machines. For exam-
ple, an administrator cannot currently dictate what ver-
sion of TLS is used by applications she installs, what
cipher suites and key sizes are used, or even whether ap-
plications use TLS at all. This coupling of application
functionality with security policy can make otherwise de-
sirable applications unadoptable by administrators with
incompatible security requirements. This problem is ex-
acerbated when security ﬂaws are discovered in applica-
tions and administrators must wait for security patches
from developers, which may not ever be provided due to
project shutdown, ﬁnancial incentive, or other reasons.
Thus TLS connection security is at the mercy of appli-
cation developers, despite their inability to properly use
security APIs and unfamiliarity with the speciﬁc secu-
rity needs of system administrators. One illustration of
the demand for administrator control is the Redhat-led
effort to create a system-wide “CryptoPolicy” conﬁgu-
ration ﬁle [15]. Through custom changes in OpenSSL
and GNUTLS, this conﬁguration ﬁle allows developers
to defer some security settings to administrators.
The synthesis of these two problem spaces is that de-
velopers lack a common, usable security API and admin-
istrators lack control over secure connections. In this pa-
per we explore a solution space to this problem through
the POSIX socket API and operating system control. We
seek to improve on prior endeavors by reducing the TLS
API to a handful of functions that are already offered to
and used by network programmers, effectively making
the TLS API itself nearly transparent. This drastically
reduces the code required to use TLS. We also explore
supporting programming languages beyond C/C++ with
a singular API implementation. Developers merely se-
lect TLS as if it were a built-in protocol such as TCP or
UDP. Moreover, this enables administrators to conﬁgure
TLS policies system-wide, while allowing developers to
use options to add conﬁguration and request stricter se-
curity policies.
Shifting control of TLS to the operating system and
administrators may be seen as controversial. However,
most operating systems already offer critical services
to applications to reduce code redundancy and to en-
sure that the services are run in a manner that does not
threaten system stability or security. For example, ap-
plication developers on Linux and Windows are not ex-
pected to write their own TCP implementation for net-
working applications or to implement their own ﬁle sys-
tem functionality when writing to a ﬁle. Moreover, oper-
ating systems and system administrators have been found
to focus more attention on security matters [17]. Thus
we believe establishing operating system and adminis-
trator control of TLS and related security policies is in
line with precedent and best practice.
3 SSA Design Goals
Our primary goal in developing the SSA is to ﬁnd a so-
lution that is both easy to use for developers and grants
a high degree of control to system administrators. Since
C/C++ developers on Linux and other Unix-like systems
already use the POSIX socket API to create applications
that access the network, this API represents a compelling
path for simpliﬁcation of TLS APIs. Other languages
use this API directly or indirectly, either through imple-
800    27th USENIX Security Symposium
USENIX Association
mentation of socket system calls or by wrapping another
implementation. If TLS usage can be mapped to exist-
ing POSIX API syntax and semantics, then that map-
ping represents the most simple TLS API possible, in the
sense that other approaches would either need to wrap or
redeﬁne the standard networking API.
Under the POSIX socket API, developers specify their
desired protocol using the last two parameters of the
socket function, which specify the type of protocol
(e.g., SOCK DGRAM, SOCK STREAM), and optionally the
protocol itself (e.g., IPPROTO TCP), respectively. Cor-
responding network operations such as connect, send,
and recv then use the selected protocol in a manner
transparent to the developer. We explore the possibility
of ﬁtting TLS within this paradigm. Ideally, a simpliﬁed
TLS API designed around the POSIX socket API would
merely add TLS as a new parameter value for the pro-
tocol (IPPROTO TLS). Subsequent calls to POSIX socket
functions such as connect, send, and recv would then
perform the TLS handshake, encrypt and transmit data,
and receive and decrypt data respectively, based on the
TLS protocol. Our design goals are as follows:
1. Enable developers to use TLS through the existing
set of functions provided by the POSIX socket API,
without adding any new functions or changing of
function signatures. Modiﬁcations to the API are
acceptable only in the form of new values for ex-
isting parameters. This enables us to provide an
API that is already well-known to network program-
mers and implemented by many existing program-
ming languages, which simpliﬁes both automatic and
manual porting to the SSA.
2. Support direct administrator control over the param-
eters and settings for TLS connections made by the
SSA. Applications should be able to increase, but not
decrease, the security preferred by the administrator.
3. Export a minimal set of TLS options to applications
that allow general TLS use and drastically reduce the
amount of TLS functions in contemporary TLS APIs.
4. Facilitate the adoption of the SSA by other program-
ming languages, easing the security burden on lan-
guage implementations and providing broader secu-
rity control to administrators.
4 OpenSSL Analysis
In the pursuit of our goals, we ﬁrst gather design recom-
mendations and assess the feasibility of our approach by
analyzing the OpenSSL API and how it is used by pop-
ular software packages. We explore what functionality
should be present in the SSA and how to distill the 504
TLS-related OpenSSL symbols (e.g., functions, macros)
to the handful provided by the POSIX socket interface.
We limit our analysis to the features exported by libssl,
the component of OpenSSL responsible for TLS func-
tionality. With few exceptions, libcrypto, which sup-
ports generic cryptographic activities, is out of the scope
of our study. GnuTLS and other libraries could also have
been explored, but we choose OpenSSL due to its pop-
ularity and expansive feature set, leaving the assessment
of other libraries to future work. For the results outlined,
we analyzed OpenSSL 1.0.2 and software packages from
Ubuntu 16.04. A full listing of our methods and results
for our analysis of libssl is located at owntrust.org.
We collected the source code for all standard Ubuntu
repository software packages that directly depend on
libssl. We then ﬁltered the resulting 882 packages for
those using C/C++, leaving 410 packages for our anal-
ysis of direct use of libssl. Of these, 276 have TLS
server functionality and 340 have TLS client functional-
ity (248 have both). Note that packages using other lan-
guages may depend on OpenSSL by utilizing one of the
packages in our analysis. We analyzed the source code
of each package in our derived set in the context of its
use of the symbols exported by libssl.
To obtain a comprehensive list of functionality offered
by libssl, we extracted the symbols (e.g., functions,
constants) it exports to applications. We also augmented
this list of 323 symbols by recursively adding prepro-
cessor macros that use already-identiﬁed symbols. This
resulted in a cumulative list of 504 unique API symbols
that developers can use when interfacing with OpenSSL’s
libssl. We then cataloged the behavior and uses of
each of these symbols using descriptions in the ofﬁcial
API documentation, in cases where such entries existed.
Manual inspection of source code and unofﬁcial third-
party documentations were used to catalog symbols not
present in the ofﬁcial documentation. We categorized
each of the symbols into the groups shown in Table 1.
Our selection of packages made a total of 24,124 calls to
the libssl API.
The resulting categories are of two types: those that
are used for specifying behavior of the TLS protocol it-
self (e.g., symbols that indicate which TLS version to
use, or how to validate a certiﬁcate), and those that relate
speciﬁcally to OpenSSL’s implementation (e.g., symbols
used to allocate and free OpenSSL structures, options to
turn on bug workarounds). For each category, we em-
ployed both automated static code analysis techniques,
using Joern [26], and manual inspection to understand