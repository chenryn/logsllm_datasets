curity of the group as a whole is weakened. Worse yet,
members of Subgroup
may be unaware of the use of the
weak algorithm.
Session rekeying in peer communication is well de-
ﬁned. The peer end-points actively participate in an ex-
change resulting in acceptance of the new key. Because
both participants assert acceptance, subsequent use of the
key can be unambiguous. The issues, design, and vul-
nerabilities of peer key exchanges have been thoroughly
researched and are well understood.
Session rekeying in group communication is inherently
more difﬁcult. As deﬁned by the group threat model,
rekeying is triggered by security relevant events. Rekey-
ing is often initiated, for example, when a session key life-
time is reached, following member joins and leaves, and to
complete recovery from the compromise of a group mem-
ber [19]. However, knowledge of these events is not often
universally available.
Rekeying of the group is required to be synchronized.
An arbitrary number of end-points must reach agreement
not only on the new secret key, but synchronize its sub-
sequent use. For example, consider a group which has
recently distributed a new session key. A member receiv-
ing a message encrypted under an old session key is faced
with a dilemma; in the absence of synchronized delivery,
the message may represent
delayed delivery of a cor-
message encrypted under the old session key, or
rect
a
message generated by an adversary who has gained access
to the previous key.
Rekeying, and the synchronization of policy in gen-
eral, are instances of distributed consensus. Agreement
on the new session key or policy is reached through via
group protocols. However, in the general case, distributed
consensus algorithms are both complex and expensive
[12, 23]. Many existing group systems attempt to avoid
these costs by relaxing synchronization requirements.
One way to relax key synchronization requirements is to
allow several session keys to be simultaneously valid. For
example, suspending transmission of data during rekeying
in a video-conference is highly undesirable. Thus, a group
may wish to continue to use (accept packets encrypted un-
der an old session key) previous keys until consensus on
the new key has been reached. A policy supporting this
environment should dictate the amount of time an old ses-
sion key may be used (and by direct corollary the minimal
freshness of received messages). This approach and other
relaxations to the general case of this key transition prob-
lem are considered in [21].
Policy is also required to be synchronized. At any point
during the session, the policy a group member enforces
must be identical to the one intended by the controller. If
the enforced policy is not both fresh and correct, then the
member may diverge from the session speciﬁcation arbi-
trarily. Obviously, the divergent member may introduce
any number of vulnerabilities.
Synchronization directly requires all received policies
be fresh, authentic, and unmodiﬁed. The means by which
policy freshness is assessed must conform to some a pri-
ori policy. For example, group members could verify that
a policy revision number increases monotonically. The
group member would never accept a policy update with
an unexpected revision number.
The group members must be able to verify that the pol-
icy has not been modiﬁed during dissemination (e.g., in-
tegrity of received policies is preserved). This reduces to
a requirement stating each member must be able to verify
that a policy originated from the group controller.
Of course, any policy must contain some evidence of
its authenticity (i.e., policy veriﬁcation). For example, a
keyed message authentication code (HMAC) [18] or digi-
tal signature [9] can be used to assert the authenticity of a
policy.
Principle 2: Only authorized entities can affect the se-
curity posture of the group
Authorization in peer communication can easily be in-
ferred from knowledge of the session key. Because there
are only two entities participating in the communication,
the correctness of any action can be directly assessed.
Conversely, because of the many roles which members
may perform, group communication requires a more com-
plex authorization model.
Groups commonly designate one or more entities to act
as authorities within the group. For example, an entity
wishing to join the group will communicate with an en-
tity authorized to admit members. Once the admittance
authority veriﬁes that the potential group member pos-
sesses the appropriate credentials, it allows the member
into group. However, unless otherwise speciﬁed by pol-
icy, the admitted member should not have the authority to
admit other members. The new group resulting from the
admittance of the member represents a new security con-
text; there is a new group member trusted with the group
key.
As identiﬁed in Table 1, there are many actions that af-
fect the group security context. Because each of these ac-
tions can affect the security of all group members, they
must be associated with the set of entities that are autho-
rized to perform them. A group allowing an adversary to
perform security relevant actions would be, among others,
vulnerable in:
 Policy creation: The unauthorized entity can modify
policy in arbitrary ways. Thus, the group may be
manipulated into operating in an insecure way.
 Key dissemination: An unauthorized group con-
troller can create a false group.
Initiate rekey: An unauthorized entity performs a de-
nial of service attack in which the group would con-
tinually rekey. The group would expend considerable
resources performing key management functions.
 Group destruction: If an unauthorized group destruc-
tion command is accepted, the group will disband
prematurely. Clearly, this represents a serious denial
of service attack.
Principle 3: Group content must be protected
Generally, data security mechanisms provide a means by
which content conﬁdentiality, authenticity, and integrity
can be protected. These mechanisms implement protec-
tion through the application of cryptographic algorithms
on session keys. Thus, the security of the group is predi-
cated on the security of the processes restricting access to
session keys.
As stated indirectly by principle
, access to session
keys must be restricted to entities with authority to receive
them. The access control policy must be deﬁned as part of
the larger group policy. Similarly, the means by which the
potential member meets the criteria must be speciﬁed.
Consider an example group policy stating that a mem-
credentials (in
ber must prove possession of company




the
form of a certiﬁcate) before being admitted to the
group. Thus, an example access control policy states

the entity must possess the private key of a certiﬁcate,

the certiﬁcate must state that the organization of the en-
tity is the desired company, and
the certiﬁcate must be
issued from the company’s certiﬁcate authority.

An admittance authority enforces the access control
policy (on a signed join request containing the certiﬁcate)
by verifying the certiﬁcate organization and issuer ﬁelds,
validating the signature, and checking the certiﬁcate has
not been revoked (e.g., through an appropriate certiﬁcate
revocation list). If this process is successful, the member
receives and subsequently uses the session key to commu-
nicate with the group.
Because the group policy is enforced correctly, and the
underlying cryptographic algorithms are secure2, group
content protection is ensured. However, if any of these
authorization, access control, or data security policies is
incorrectly enforced, then the security of the group as a
whole may be lost. This demonstrates the fragility of se-
curity; incorrect implementation of any one function can
invalidate guarantees provided by others.
Principle 4: Groups must be capable of recovery from
security relevant failures to a secure state
It is necessary for groups to recover to a secure operat-
ing state when a subset of its membership is found to be
untrustworthy. Thus, a policy must state the way in which
compromise is to be detected and, if available, the mech-
anisms used for recovery.
There are a myriad of ways groups may recover from
member compromise. Early systems,
in an effort to
restrict insecure access to content, disbanded immedi-
ately following compromise [17, 16]. More recently,
group systems employ sophisticated rekeying approaches
[31, 32, 21] to recover from member compromise. In these
latter systems, compromised members are ejected by their
exclusion from the subsequent rekey process.
A group may also require recovery from non-
compromise failures. The effect of network partitions
[11], process crashes [20], and other failures on the group
security context is an open area of research. We note that
the mechanisms used for failure detection and recovery
will have unique security requirements. For example, the
heartbeat-based failure detection mechanism in [20] re-
quires heartbeats be authentic. In the absence of authentic
failure detection, an adversary may be able to mask the
failure of group members through forged heartbeats.
2There is signiﬁcant debate on the correct design of secure group
data transforms. For the purposes of this discussion, we assume that all
mechanisms are fundamentally secure; the cryptographic algorithms and
data transforms are sound.
3. Policy Speciﬁcation and Enforcement in
GSAKMP
This section describes the Group Secure Association
Key Management Protocol and presents arguments illus-
trating its compliance with the principles presented in the
preceding section.
3.1. Description
The Group Secure Association Key Management Pro-
tocol (GSAKMP) dictates and manages the security of a
communications group. GSAKMP manages group secu-
rity throughout the life-cycle of the group: group initi-
ation, maintenance, compromise recovery, and deletion.
Policy is deﬁned in the policy token data structure, which
is distributed and enforced over speciﬁed protocol ex-
changes. Group content is protected by appropriate se-
curity mechanisms and their associated session keys that
are known only the current membership.
In GSAKMP, group responsibilities are decomposed
into authorized roles. Roles are deﬁned for Group Owner,
Group Controller, Subgroup Controller, and Member. The
rights attributed to these roles are presented in Table 2.
The authorization criteria, as well as the mechanisms used
to verify authorizations, are deﬁned in the policy token. In
one instantiation of GSAKMP, security relevant messages
must be signed by the authorized entity.
Signed by the Group Owner, the policy token contains
authorization, key management, and data protection rules
for the group, and deﬁnes the mechanisms used for veri-
ﬁcation. Using the deﬁned mechanisms, potential group
members receiving a token verify the token is authentic,
fresh, and unmodiﬁed. Once veriﬁed, the token is used to
direct the behavior of the member.
Groups are formed by multiple individual (peer) admit-
tances. In the GSAKMP join exchange, the Group Con-
troller presents the group’s token and veriﬁes the potential
member’s credentials. If the member credentials are ac-
cepted, the current group keys are securely downloaded
to the newly accepted member. The member, in turn, in-
spects the token to determine if the group policy is appro-
priate for the information that they wish to share.
Compromise recovery methods such as the Logical Key
Hierarchy (LKH)
[31, 32] allow GSAKMP to securely
and rapidly eject compromised members. Because of the
properties of these keying techniques, any keys possessed
by compromised members will not be valid after ejection.
The GSAKMP speciﬁcations are quickly reaching ma-
turity. Two IETF drafts have been submitted [15, 14] and
a license free reference architecture and associated docu-
mentation are available at:
ftp://ftp.sparta.com/pub/columbia/gsakmp
Action
policy creation
policy modiﬁcation
grant rights
key creation
group destruction
key dissemination
rekey action initiation
authorize member
admit member
eject member
audit group
key access
Rights
GO
GO
GO
GC
GC
GC,SGC
GC,SGC
GC,SGC
GC,SGC
GC,SGC
GC,SGC
GC,SCG,M
Table 2. GSAKMP rights assignment - assign-
ment of rights to group owners (GO), group
controllers (GC), subgroup-controllers (SGC),
and members (M) within a GSAKMP group. A
deﬁnition of these rights is presented in Table 1.
3.2. Analysis
In this section, we informally argue that the framework
provided by GSAKMP adheres to the group policy princi-
ples discussed in the previous section.
GSAKMP speciﬁes a group security policy through the
policy token. The token is passed to each group member
as part of the join exchange. Each group member veriﬁes
the policy token and enforces the stated policy. As events
dictate, the group policy token can be updated over the life
of the group. Each received update is veriﬁed in the same
way as the initial token.
To ensure the current policy token is correctly dissemi-
nated across the group, GSAKMP sends the current token
along with each security relevant action. Each member
checks the token’s freshness indicators and veriﬁes its ori-
gin and integrity.
Principle 1: Enforcement of group policy must be con-
sistent across a group
a) GSAKMP enforces the use of equivalent mechanisms
Allowable cryptographic and key management tech-
niques are speciﬁed in the policy token.
b) GSAKMP provides methods for key and policy syn-
chronization.
Based on the authorizations deﬁned in the policy token,
each joining member is given the keys needed to fulﬁll
their assigned roles. Because the group is formed by mul-
tiple individual joins, each member will initially have the
keys needed for authorized participation. Via LKH, key-
ing due to stale session keys or compromise recovery are
accomplished using a single rekey message. Similarly, if
the policy changes such that a current member is no longer
allowed to participate, the group must be rekeyed. In this
case, rekeying must be handled in the same way as in com-
promise recovery.
Similarly, any member joining the group receives the
most current policy token. Subordinate group controllers
not providing the correct (fresh) policy token are ejected
from the group forcing a rekey. The ejected subordinate
group controller would be incapable of providing a valid
key to the new member. Hence, freshness of the initial to-
ken may be veriﬁed by the ability to access the group by
the new member. The GSAKMP Policy Token contains
freshness dates and sequence numbers. Any subsequent
token will only be accepted if it contains later freshness
indicators. Thus, stale policies are detectable. As rea-
soned before, as the group consists of individual member
joins, the group only will accept the most current token.
Thus, the group policy is synchronized.
c) From 1 and 2, enforcement of group policy is consis-
tent across the group.
The GSAKMP policy token is issued and signed by an
entity responsible for the group security policy. It further
deﬁnes who may perform security relevant actions. Both
the rules for determining permissions and the mechanism
used to verify the rules themselves are deﬁned in the pol-
icy token.
Upon receipt of a security relevant message, group
members review the current policy token. The message
is initially veriﬁed using a mechanism deﬁned in the to-
ken. Using the roles and authorizations deﬁned in the to-
ken, the member checks the permissions of the sending
party. If the veriﬁcation succeeds and the sender can as-
sume a role allowed to perform the action implied by the
message, then the message is accepted.
Principle 2: Only authorized entities can affect the se-
curity posture of the group
a) The policy token is veriﬁed as coming from a trusted
source and as being authentic. (1-1)
The signature payload contains the identity of the signer
of the token. This signature is veriﬁed according to the pa-
rameters for veriﬁcation of the token and the stated iden-
tity.
b) Authorized entities are identiﬁed in the policy token.
(GSAKMP speciﬁcation)
c) Messages affecting the security posture of the group
must be issued by an authorized entity. (GSAKMP
speciﬁcation)
d) Each member can verify that the message affecting
the security posture was issued by a trusted source
indicated by the veriﬁed policy token.
The veriﬁcation mechanism and parameters are indi-
cated in the policy,
e) Each member can verify that the message was freshly
signed.
GSAKMP join exchange messages contain nonces. The
rekey message contains a timestamp. The group delete
message is only generated once, so no replay potential ex-
ists.
f) Each member can verify that they are intended recip-
ients of the message.
GSAKMP message header’s contain group identiﬁers.
Security relevant messages to individuals (e.g., Key
Download) contain individual identiﬁers.
g) Therefore, each member will only act on fresh mes-
sages intended for them from an authorized source.
h) Groups are comprised of individual members.
i) The group will only act on fresh messages intended
for them from an authorized source.
j) Only authorized entities can affect the security pos-