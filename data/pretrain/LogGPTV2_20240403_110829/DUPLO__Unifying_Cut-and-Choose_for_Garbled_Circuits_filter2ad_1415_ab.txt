putation), but it is not necessarily intended as a user friendly
method to specify computations. But alternative syntax to
describe circuit/arrow computations in a programmer friendly
way exist [21], [22], it can be automatically translated into
the mathematical (inductive) arrows notation, and it is readily
found implemented in mainstream programming languages
like Haskell to structure complex software libraries, like graph-
ical user interfaces, robotics applications, hardware description
languages, and more. So, we will not be concerned on the
usability of the arrow notation to directly specify application
circuits, and refer the interested reader to the programming
language literature for more information.
What is more relevant, in the context of this paper, is that we
are able to use our extended language for symbolic cryptog-
raphy, and the structural arrow-like formalization of circuits,
to give a formal, yet conceptually simple description of
âˆ™ Yaoâ€™s circuit garbling procedure,
âˆ™ a symbolic simulator, used to prove the security of Yaoâ€™s
construction, and
âˆ™ a detailed, formal proof showing that the output of Yaoâ€™s
garbling and the output of the simulator, are symbolically
equivalent, i.e., they map to equivalent symbolic patterns.
We remark that all these deï¬nitions and proofs are purely
symbolic, and they work by induction on the structure of
the circuits, reducing the security analysis to the veriï¬ca-
tion of a small number of base cases and inductive steps.
148
It follows from our computational soundness theorem that,
when implemented using standard cryptographic primitives,
the resulting construction achieves the standard security notion
of computational indistinguishability used in cryptography.
It is important to note that the connection between symbolic
security, and computational security is not established at the
level of garbled circuits, but it is proved in the context of
a general soundness theorem for a generic, simple language
of cryptographic expressions. The language is designed to be
powerful enough to express garbled circuits and the associated
simulation procedure, but it is otherwise independent of the
speciï¬c circuit garbling problem. We believe that this greatly
simpliï¬es and elucidates both the computational soundness
result (which is proved for a simple, application independent
language,) and the application to garbled circuits (which is
described and analyzed in a purely symbolic manner.)
b) Other related work: Since the detailed security proof
of garbled circuits in [9], there have been many studies on
various security properties of garbled circuits. For a recent
summary see for example [23]. The security notion used in [9]
is sometimes called selective security, in which an adversary
must choose an input before the circuit is provided to the
simulator. A more useful notion in practice is adaptive secu-
rity, in which a simulator must be able to return a simulated
garbled circuit back to the adversary given only the circuit,
and the adversary can adaptively choose an input value after
seeing the garbled circuit. There is a number of works that
explore adaptive security of garbled circuits, for example [24]â€“
[26]. Jafargholi and Wichs [27] showed that Yaoâ€™s original
construction of garbled circuits is already adaptively secure
with a security loss of 2ğ‘‚(ğ‘‘), where ğ‘‘ is the circuit depth, and
this result has been further generalized in [28]. As a ï¬rst step
toward the symbolic modeling of garbling schemes, in this
paper, we focus on selective security.
Adaptive security in general can be solved by using the
â€œerasureâ€ approach [29] or by assuming non-standard primi-
tives such as non-committing encryption [30]. In the symbolic
setting, adaptive security with standard assumptions was con-
sidered in the past in the context of symmetric-key encryption
protocols [14]. That approach can be adapted to our symbolic
model to deal with adaptive security of garbled circuits. But
such extension may require a non-trivial amount of work and
is beyond the scope of the current paper, so we leave it for
future study.
Machine-checked proofs have been developed for cryp-
tographic systems through several computer-aided veriï¬ca-
tion tools such as CryptoVerif [31], CertiCrypt [32], Easy-
Crypt [33], and so on. These tools apply formal methods in
conjunction with cryptography-speciï¬c constructions, and they
impose rigorous proof styles. In a recent work [34], Almeida
et. al. formalized Yaoâ€™s secure function evaluation protocol
in which the circuit garbling scheme is a central compo-
nent, and, among many things, it then devised a machine-
checked selective security proof of the garbling scheme using
EasyCrypt (with customized extensions to allow using hybrid
arguments and simulation-based proofs). Comparing to our
work, the construction and the security goal of the garbling
scheme in their work is similar, but their mechanized proofs
argue computational security directly in the logic system of
EasyCrypt, which are diï¬€erent from the symbolic style proofs
in our work.
c) Paper organization: The rest of the paper is organized
as follows. In Section II we provide formal deï¬nitions for
symbolic cryptography, background on computational sound-
ness, and our extended symbolic language (and computational
soundness theorem) to describe garbled circuits. Our inductive
method to deï¬ne circuits is presented in Section III. In Sec-
tion IV, we use our language of symbolic cryptography and the
structural deï¬nition of circuits, to give a formal description of
Yaoâ€™s circuit garbling procedure. Section V contains the main
results of the paper, with the description of a symbolic sim-
ulator, and a formal proof that it is (symbolically) equivalent
to real garbled circuit computations. Computational security
of garbled circuits, as described in this paper, automatically
follows from the general soundness results given in Section II.
In Section VI, we report our implementation of the symbolic
garbling procedure and the simulator, and we provide some
experimental results on automated testings performed against
our implementation. We conclude our paper in Section VII.
All the omitted proofs can be found in the full version [35].
II. PRELIMINARIES
In this section we introduce basic notation used by symbolic
and computational cryptography. For a positive integer ğ‘›, we
write [ğ‘›] = {1, â€¦ , ğ‘›}. We use the bit 0 for the Boolean value
false, and 1 for true. For ğ‘› â‰¥ 1, {0, 1}ğ‘›
is the set of all Boolean
vectors of length ğ‘›. We can concatenate two Boolean vectors
ğ‘¥ âˆˆ {0, 1}ğ‘›
. For
any ğ‘¥ âˆˆ {0, 1}ğ‘›
, we can think ğ‘¥ as a concatenation of ğ‘› bits,
written as ğ‘¥ = ğ‘¥1 â‹¯ ğ‘¥ğ‘›, where ğ‘¥1, â€¦ , ğ‘¥ğ‘› âˆˆ {0, 1}. For any
ğ‘¥, ğ‘¦ âˆˆ {0, 1}, the NAND function ğ‘¥ â†‘ ğ‘¦ = Â¬(ğ‘¥âˆ§ ğ‘¦) maps ğ‘¥ and
ğ‘¦ to 0 if and only if both ğ‘¥ and ğ‘¦ are 1.
A. Symbolic cryptography
to obtain ğ‘¥ğ‘¦ âˆˆ {0, 1}ğ‘›+ğ‘š
and ğ‘¦ âˆˆ {0, 1}ğ‘š
Our symbolic cryptographic expressions extend those de-
ï¬ned in [18] with random bits and a swap operation, which
we need to model garbled circuits. Informally, symbolic
expressions are built from random keys and (possibly ran-
dom) bits, using a symmetric encryption scheme, a (length
doubling) pseudorandom generator, a pairing (concatenation)
operation, and the (random) permutation of pairs. Just as
in computational cryptography it is convenient to group bit-
strings according to their length, in symbolic cryptography
it
is customary to classify expressions according to their
shape, which captures the expression size in a representation
independent way. The set of possible shapes for a symbolic
expression is deï¬ned by the grammar:
ğ’ğ¡ğšğ©ğ â†’ ğ”¹ âˆ£ ğ•‚ âˆ£ â¦‡ğ’ğ¡ğšğ©ğ, ğ’ğ¡ğšğ©ğâ¦ˆ âˆ£â¦ƒğ’ğ¡ğšğ©ğâ¦„
representing the shapes of bits, keys, pairs (of two sub-
expressions of arbitrary shape), and encryptions (of messages
of arbitrary shape), respectively. For example â¦‡ğ•‚,â¦ƒğ”¹â¦„â¦ˆ is the
149
shape of a pair consisting of a key and the encryption of a
single bit message. Let ğ = {ğ–¡ğ‘– âˆ£ ğ‘– = 1, 2, â€¦} be a set of
atomic bit symbols, and ğŠ = {ğ–ªğ‘– âˆ£ ğ‘– = 1, 2, â€¦} a set of atomic
key symbols, representing independent uniformly random bits
and independent uniformly random keys, respectively. For any
shape ğ‘  âˆˆ ğ’ğ¡ğšğ©ğ, we deï¬ne a corresponding set of expressions
of shape ğ‘  (denoted ğ„ğ±ğ©(ğ‘ )) according to the grammar rules:
ğ„ğ±ğ©(ğ”¹) â†’ 0 âˆ£ 1 âˆ£ ğ–¡ğ‘– âˆ£ Â¬ğ„ğ±ğ©(ğ”¹)
ğ„ğ±ğ©(â¦ƒğ‘ â¦„) â†’ â¦ƒğ„ğ±ğ©(ğ‘ )â¦„ğ„ğ±ğ©(ğ•‚)
ğ„ğ±ğ©(ğ•‚) â†’ ğ–ªğ‘– âˆ£ ğ–¦0(ğ„ğ±ğ©(ğ•‚)) âˆ£ ğ–¦1(ğ„ğ±ğ©(ğ•‚))
ğ„ğ±ğ©(â¦‡ğ‘ , ğ‘¡â¦ˆ) â†’ (ğ„ğ±ğ©(ğ‘ ), ğ„ğ±ğ©(ğ‘¡))
ğ„ğ±ğ©(â¦‡ğ‘ , ğ‘ â¦ˆ) â†’ ğœ‹[ğ„ğ±ğ©(ğ”¹)](ğ„ğ±ğ©(ğ‘ ), ğ„ğ±ğ©(ğ‘ )).
where ğ‘ , ğ‘¡ range over ğ’ğ¡ğšğ©ğ, ğ–¡ğ‘– ranges over ğ, and ğ–ªğ‘– ranges
over ğŠ. Most symbols are self explanatory: Â¬ğ‘ represents
the logical negation of bit ğ‘, (ğ–¦0(ğ‘˜), ğ–¦1(ğ‘˜)) represents the
output of a length doubling pseudorandom generator on seed
ğ‘˜ (with ğ–¦0(ğ‘˜) the ï¬rst half of the output, and ğ–¦1(ğ‘˜) the second
half,) â¦ƒğ‘’â¦„ğ‘˜ is the encryption of ğ‘’ under key ğ‘˜, (ğ‘’0, ğ‘’1) is
ğ‘ = 1. For example, â¦ƒğ–¦0(ğ–ª1)â¦„ğ–¦1(ğ–ª1) represents the encryption
the ordered pair with sub-expressions ğ‘’0 and ğ‘’1, and for any
bit ğ‘ and expressions ğ‘’0, ğ‘’1 of the same shape, ğœ‹[ğ‘](ğ‘’0, ğ‘’1)
represents the pair (ğ‘’0, ğ‘’1) with the two components swapped if
of the ï¬rst half ğ–¦0(ğ–ª1) of a pseudorandom string (obtained
by applying the pseudorandom generator on seed ğ–ª1,) en-
crypted under the second half of the pseudorandom string,
while ğœ‹[ğ–¡1](ğ–¦0(ğ–ª1), ğ–¦1(ğ–ª1)) represents a pseudorandom string
(output by the pseudorandom generator on seed ğ–ª1), with
the ï¬rst and second half of the string permuted (swapped)
at random depending on the value of the (random) bit ğ–¡1.
Note that we can iteratively apply the pseudorandom gen-
erator on a key expression ğ‘˜ to obtain expressions such as
ğ–¦ğ‘1(ğ–¦ğ‘2(â‹¯ (ğ–¦ğ‘ğ‘›(ğ‘˜)))) for ğ‘› â‰¥ 0 and ğ‘1, ğ‘2, â€¦ , ğ‘ğ‘› âˆˆ {0, 1}.
Such expressions are abbreviated as ğ–¦ğ‘1ğ‘2â€¦ğ‘ğ‘›(ğ‘˜). Let ğœ€ denote
the empty bit-string, and let {0, 1}âˆ— denote the set of all bit-
strings. For any set ğ‘† âŠ† ğ„ğ±ğ©(ğ•‚), we deï¬ne the sets
ğ–¦âˆ—(ğ‘†) = {ğ–¦ğ‘¤(ğ‘˜) âˆ£ ğ‘˜ âˆˆ ğ‘†, ğ‘¤ âˆˆ {0, 1}âˆ—}
ğ–¦+(ğ‘†) = {ğ–¦ğ‘¤(ğ‘˜) âˆ£ ğ‘˜ âˆˆ ğ‘†, ğ‘¤ âˆˆ {0, 1}âˆ—, ğ‘¤ â‰  ğœ€}
obtained by applying the (ï¬rst or second half of the) pseudo-
random generator zero (resp. one) or more times to a key in ğ‘†.
So, for example, ğ–¦âˆ—(ğŠ) = ğ„ğ±ğ©(ğ•‚) is the set of all (random or
pseudorandom) keys. For convenience, we write ğŠâˆ— for ğ–¦âˆ—(ğŠ)
and ğŠ+ for ğ–¦+(ğŠ). If ğ‘† = {ğ‘˜} is a singleton set, we usually
write ğ–¦+(ğ‘˜) and ğ–¦âˆ—(ğ‘˜) instead of ğ–¦+({ğ‘˜}) and ğ–¦âˆ—({ğ‘˜}).
constructâ¦ƒğ‘ â¦„ğ„ğ±ğ©(ğ•‚) to represent the encryption of an unknown
expression of shape ğ‘ . The pattern â¦ƒğ‘ â¦„ğ„ğ±ğ©(ğ•‚) has shape â¦ƒğ‘ â¦„.
Patterns are extensions of expressions that
include the
Formally, patterns are deï¬ned by a grammar with variables
ğğšğ­(ğ‘ ) indexed by ğ‘  âˆˆ ğ’ğ¡ğšğ©ğ, and the same set of rules as
those given for ğ„ğ±ğ©(ğ‘ ), with the addition of one more rule
ğğšğ­(â¦ƒğ‘ â¦„) â†’â¦ƒğ‘ â¦„ğ„ğ±ğ©(ğ•‚).
ğğšğ­(ğ‘ ) is the set of all patterns of shape ğ‘ , and ğğšğ­ is the set
of all patterns (of any shape). Notice that ğğšğ­(ğ”¹) = ğ„ğ±ğ©(ğ”¹)
where ğ‘˜ âˆˆ ğ„ğ±ğ©(ğ•‚), and ğ‘ âˆˆ ğ„ğ±ğ©(ğ”¹). The computational
evaluation (cid:2)ğ‘’(cid:3) of an expression ğ‘’ is deï¬ned as the probability
150