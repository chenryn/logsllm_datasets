# 【技术分享】绕过三星的实时内核保护

## 译文声明
本文是翻译文章，原文来源：[googleprojectzero.blogspot.tw](http://googleprojectzero.blogspot.tw)。译文仅供参考，具体内容表达以及含义以原文为准。

**翻译者**: [牧野之鹰](http://bobao.360.cn/member/contribute?uid=877906634)  
**预估稿费**: 200RMB  
**投稿方式**: 发送邮件至 [linwei#360.cn](mailto:linwei#360.cn)，或登录[网页版](http://bobao.360.cn/contribute/index) 在线投稿

---

### 前言
在传统操作系统中，内核是抵御攻击者实现对系统完全控制的最后一道防线。因此，确保内核的完整性至关重要。当系统启动时，必须验证其关键组件（包括内核）的完整性。这一过程通过Android上的验证启动链实现。然而，仅引导经过验证的内核是不够的；还需考虑在系统运行时如何维护内核的完整性。

假设攻击者能够找到并利用内核中的漏洞，他们可能会修改内核代码或引入新的、受控于攻击者的代码，并在操作系统的上下文中执行。更进一步，攻击者可以修改操作系统使用的数据结构，从而改变其行为（例如，授予进程过多权限）。由于内核负责管理所有内存转换，包括自身，因此没有机制阻止同一上下文中的攻击者这样做。

为了符合“深度防御”的概念，可以添加额外的保护层来抵御此类攻击。如果这些层设计得当，可以显著限制甚至防止攻击者破坏内核的完整性。在Android生态系统中，三星提供了一种称为“实时内核保护”（RKP）的安全管理程序，作为三星KNOX的一部分。在这篇博文中，我们将深入探讨RKP的工作原理，并提出多个漏洞，允许攻击者绕过RKP的每个安全机制。我们还将讨论如何加强RKP的设计，以防止未来的类似攻击。

需要注意的是，本文中提到的所有漏洞均已向三星披露，并已在1月的安全维护更新（SMR）中修复。此外，三星KNOX团队非常积极地参与了讨论，确保问题得到正确诊断和根本原因确定。特别感谢三星KNOX团队的Tomislav Suchan，他提供了深刻的见解并帮助解决了所有查询。

### HYP 101
在探索RKP架构之前，我们需要了解ARMv8上的虚拟化扩展。ARMv8引入了新的异常级别（EL）概念。通常，离散组件在不同的异常级别上运行——组件的特权级别越高，其异常级别也越高。本文将重点关注“正常世界”中的异常级别。

- **EL0**: 表示在Android上运行的用户模式进程。
- **EL1**: 表示Android的Linux内核。
- **EL2 (HYP模式)**: 表示RKP管理程序。

当用户模式进程（EL0）需要与内核（EL1）交互时，它们通过发出“管理程序调用”（SVC）触发异常，然后由内核处理。同样，通过发出“管理程序调用”（HVC）来与管理程序（EL2）交互。管理程序可以通过使用“管理程序配置寄存器”（HCR）来控制内核内的关键操作。此寄存器管理虚拟化功能，使EL2能够与EL1中运行的代码交互。例如，设置HCR中的某些位会导致管理程序捕获原本由EL1处理的操作，从而使管理程序能够决定是否允许该操作。

此外，管理程序能够实现额外的存储器转换层，称为“阶段2转换”。传统的存储器转换模型使用操作系统的转换表将虚拟地址（VA）映射到物理地址（PA）。而在两阶段转换机制中，首先使用EL1转换表将VA映射到中间物理地址（IPA），称为“第1阶段转换”。在此过程中，还应用了访问控制，如访问许可（AP）位、从不执行（XN）和从不执行特权执行（PXN）。然后，通过执行“阶段2转换”将IPA转换为PA。这种转换通过使用EL2可访问的转换表完成，并且对EL1中运行的代码不可见。通过这种方式，管理程序可以防止对某些关键物理内存区域的访问，这些区域可能包含敏感数据。

### 创建研究平台
正如我们在“HYP 101”部分所见，与EL2的通信通过发出HVC完成。与可以在EL0中自由发出的SVC不同，HVC只能由在EL1中运行的代码触发。由于RKP在EL2中运行并通过HVC暴露其大部分功能，我们需要一个平台来发送任意的HVC。幸运的是，在最近的一篇博客中，我们已经介绍了一个漏洞，允许我们将权限提升到system_server的上下文中。这意味着在开始调查RKP和与EL2交互之前，只需找到另一个漏洞，允许从system_server等特权上下文升级到内核上下文。

通过对暴露在特权上下文中的攻击面进行简单测量，我们发现了大量相对简单的漏洞，其中任何一个都可以用于在EL1中获得立足点。为了本研究的目的，我选择了一个方便的漏洞：sysfs条目中的简单堆栈溢出，可以用来获得对内核线程堆栈内容的任意控制。一旦我们控制了堆栈的内容，就可以构造一个ROP有效载荷，准备内核函数的参数，调用该函数，并将结果返回给用户空间。为了便于使用，我们可以将创建ROP堆栈的过程封装在一个函数中，该函数调用内核函数并将结果返回给用户空间，我们称之为“execute_in_kernel”。

结合我们的shellcode包装器，它可以将普通的C代码转换为可以注入到system_server中的shellcode，我们现在可以自由构建和运行能够按需调用内核函数的代码。综上所述，我们可以使用这个强大的研究平台开始调查和与RKP交互。本文详细介绍的研究是在完全更新的Galaxy S7 Edge（SM-G935F，XXS1APG3，Exynos芯片组）上进行的，使用这个框架，通过第一个exploit将代码注入到system_server中，然后使用第二个exploit在内核中运行代码。

现在我们已经准备好所有必要的基础，让我们开始吧！

### 缓解措施 #1 – KASLR
随着KNOX v2.6的推出，三星设备实现了内核地址空间布局随机化（KASLR）。这个安全特性引入了每次设备启动时生成的随机偏移量，通过该偏移量，内核的基地址被移动。通常，内核被加载到固定的物理地址，对应于内核VAS中的固定虚拟地址。通过引入KASLR，所有内核内存，包括其代码，都被这个随机偏移量（也称为“滑动”）移动。

虽然KASLR可能是针对远程攻击者的有效缓解措施，但对于本地攻击者来说，鲁棒地实现它是非常困难的。事实上，有一些有趣的研究设法通过观察时间差异来击败KASLR，而不需要任何软件缺陷。尽管这些攻击本身非常有趣，但应该注意，绕过KASLR通常可以更容易地实现。回想一下，整个内核被一个“滑动”值移动——这意味着泄露内核中与内核基址有一个已知偏移量的任何指针将允许我们轻松计算出滑动值。

Linux内核确实包括旨在防止这种指针泄漏到用户空间的机制。一种这样的缓解措施是通过确保每次指针的值由内核写入时，使用特殊格式说明符“%pK”打印。然后，根据kptr_restrict的值，内核可以匿名打印指针。在我遇到的所有Android设备中，kptr_restrict配置正确，确保“%pK”指针是匿名的。

然而，我们只需要找到一个内核开发人员忽略匿名化的单一指针。在三星的情况下，这变得很有趣……pm_qos debugfs条目，它是system_server可读的，包括以下代码片段，负责输出条目的内容：

```c
static int pm_qos_power_save_show(struct seq_file *m, void *v)
{
    struct pm_qos_object *qos = m->private;
    unsigned long val;

    mutex_lock(&qos->lock);
    val = qos->default_value;
    mutex_unlock(&qos->lock);

    seq_printf(m, "%lu\n", val);
    return 0;
}
```

不幸的是，匿名化格式说明符区分大小写……使用小写的“k”，如上面的代码所示，导致上述代码输出指针而不应用“%pK”提供的匿名化（也许这是一个很好的脆弱KASLR的例子）。无论如何，这允许我们简单地读取pm_qos的内容，并从指针的值与内核基地址的已知偏移量相减，从而给出KASLR滑动值。

### 缓解措施 #2 – 加载任意内核代码
防止新内核代码的分配是RKP强制执行的主要缓解措施之一。此外，RKP旨在保护所有现有的内核代码不被修改。这些缓解措施通过强制执行以下规则集来实现：

1. 除了内核代码之外，所有页面都被标记为“Privileged Execute Never”（PXN）。
2. 内核数据页从不标记为可执行。
3. 内核代码页从不标记为可写。
4. 所有内核代码页在阶段2转换表中被标记为只读。
5. 所有存储器翻译条目（PGD、PMD和PTE）对于EL1被标记为只读。

尽管这些规则看起来相当健壮，但我们如何确保它们被正确执行？不可否认，规则在RKP文档中很好地描述了，但这不是一个强大的保证。让我们开始挑战第一个断言；即，除了内核代码外，所有其他页面都标记为PXN。我们可以通过查看EL1中的阶段1翻译表来检查这个断言。

ARMv8支持在EL1中使用两个转换表：TTBR0_EL1和TTBR1_EL1。TTBR0_EL1用于保存用户空间VAS的映射，而TTBR1_EL1保存内核的全局映射。