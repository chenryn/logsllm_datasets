# 【技术分享】绕过三星的实时内核保护
|
##### 译文声明
本文是翻译文章，文章来源：googleprojectzero.blogspot.tw
原文地址：
译文仅供参考，具体内容表达以及含义原文为准。
****
****
翻译：[牧野之鹰](http://bobao.360.cn/member/contribute?uid=877906634)
预估稿费：200RMB
投稿方式：发送邮件至[linwei#360.cn](mailto:PI:EMAIL)，或登陆[网页版](http://bobao.360.cn/contribute/index)在线投稿
**  
**
**前言**
传统上，操作系统的内核是位于攻击者和对目标系统的完全控制之间的最后一个安全边界。 因此，必须额外注意以确保内核的完整性。
首先，当系统引导时，必须验证其关键组件（包括操作系统内核的关键组件）的完整性。 这是通过验证的启动链在Android上实现的。
然而，简单地引导已验证的内核是不够的 – 在系统执行时如何维护内核的完整性？
想象一下，攻击者能够在操作系统的内核中找到并利用漏洞的情况。
使用这种漏洞，攻击者可能通过修改其代码的内容，或通过引入新的，受攻击者控制的代码，并在操作系统的上下文中运行，来试图破坏内核本身的完整性。
甚至更巧妙的是，攻击者可以选择修改操作系统使用的数据结构，以便改变其行为（例如，通过授予过多的权限来选择进程）。
由于内核负责管理所有内存转换，包括其自身，因此没有机制阻止同一上下文中的攻击者这样做。
然而，为了符合“深度防御”的概念，可以添加附加层以便保护内核不受这种将要攻击者的攻击。
如果正确堆叠，这些层可以以严重限制或者简单地防止攻击者破坏内核完整性的方式来设计。
在Android生态系统中，三星提供了一个安全管理程序，旨在解决在运行时确保内核完整性的问题。
管理程序被称为“实时内核保护”（RKP），作为三星KNOX的一部分。
在这篇博文中，我们将深入研究RKP的内部工作，并提出多个漏洞，允许攻击者颠覆RKP的每个安全机制。
我们还将看到如何加强RKP的设计，以防止未来的这种性质的攻击，使利用RKP更困难。
和往常一样，本文中的所有漏洞已被披露给三星，修复已在1月SMR提供。
我想指出，除了解决报告的问题，三星KNOX团队十分积极并开放讨论。 这种对话有助于确保问题得到正确诊断和确定根本原因。
此外，KNOX团队已经提前审查了本文，并提供了关于RKP的未来改进计划基于这项研究的关键见解。
我要特别感谢三星KNOX团队的Tomislav Suchan帮助解决我所有的每一个查询，并提供深刻的见解。
Tomislav的辛勤工作确保所有的问题都得到正确和完整的解决，不留下任何东西。
**HYP 101**
在我们开始探索RKP的架构之前，我们首先需要了解ARMv8上的虚拟化扩展。 在ARMv8架构中，引入了一个新的异常级别概念。
通常，离散组件在不同的异常级别运行 – 组件的特权级别越高，其异常级别越高。
在这篇博文中，我们将只关注“正常世界”中的异常级别。
在此上下文中，EL0表示在Android上运行的用户模式进程，EL1表示Android的Linux内核，EL2（也称为“HYP”模式）表示RKP管理程序。
然后，当用户模式进程（EL0）希望与操作系统的内核（EL1）交互时，它们必须通过发出“管理程序调用”（SVC）来触发，然后触发由内核处理的异常。
以相同的方式，通过发出“管理程序调用”（HVC）来执行与管理程序（EL2）的交互。
另外，管理程序可以通过使用“管理程序配置寄存器”（HCR）来控制在内核内执行的关键操作。 此寄存器管理虚拟化功能，使EL2能够与EL1中运行的代码交互。
例如，设置HCR中的某些位将导致管理程序捕获通常由EL1处理的特定操作，使得管理程序能够选择是允许还是不允许所请求的操作。
最后，管理程序能够实现额外的存储器转换层，称为“阶段2转换”。
代替使用操作系统的转换表在虚拟地址（VA）和物理地址（PA）之间映射的常规模型，翻译过程被分成两部分。
首先，使用EL1转换表以便将给定的VA映射到中间物理地址（IPA） – 这被称为“第1阶段转换”。
在该过程中，还应用在翻译中存在的访问控制，包括访问许可（AP）位，从不执行（XN）和从不执行特权执行（PXN）。
然后，通过执行“阶段2转换”将所得到的IPA转换为PA。 该映射通过使用EL2可访问的转换表来执行，并且对于在EL1中运行的代码是不可访问的。
通过使用这种两级转换机制，管理程序能够防止对物理存储器的某些关键区域的访问，其可能包含应该对EL1保密的敏感数据。
**创建研究平台**
正如我们在我们的“HYP 101”课程中看到的，与EL2的沟通明确地通过发出HVC来完成。
与可以由在EL0中运行的代码自由地发出的SVC不同，HVC只能由在EL1中运行的代码触发。
由于RKP在EL2中运行，并通过可以从HVC触发的命令暴露其绝大部分功能，我们首先需要一个平台，我们可以从中发送任意的HVC。
幸运的是，在最近的一篇博客中，我们已经涵盖了一个漏洞，允许我们将权限提升到system_server的上下文中。
这意味着在我们开始调查RKP和与EL2交互之前剩下的所有工作都是找到一个额外的漏洞，允许从已经特权的上下文（如system_server）升级到内核的上下文。
幸运的是，简单地测量暴露于这种特权上下文的攻击面暴露了大量相对简单的漏洞，其中任何一个可以用于在EL1中获得一些立足点。
为了这个研究的目的，我决定利用这些中最方便的：在sysfs条目中的简单堆栈溢出，可以用于获得对内核线程的堆栈内容的任意控制。
一旦我们控制了栈的内容，我们可以构造一个ROP有效载荷，为内核中的函数调用准备参数，调用该函数，并将结果返回给用户空间。
为了便于使用，我们可以将创建一个ROP堆栈的整个过程包装到一个函数中，这个函数调用一个内核函数并将结果返回给用户空间，我们称之为“execute_in_kernel”。
结合我们的shellcode包装器，它将正常的C代码转换为可以注入到system_server中的shellcode，我们现在可以自由构建和运行能够根据需要调用内核函数的代码。
综上所述，我们可以使用这个强大的研究平台开始调查和与RKP交互。 本博客中详细介绍的其余研究在完全更新的Galaxy S7
Edge（SM-G935F，XXS1APG3，Exynos芯片组）上进行，使用这个确切的框架，以便使用第一个exploit将代码注入到system_server中，然后运行代码
在内核中使用第二个exploit。
最后，现在我们已经搞定了所有需要的基础，让我们开始吧！
**Mitigation #1 – KASLR**
随着KNOX v2.6的推出，三星设备实现内核地址空间布局随机化（KASLR）。
这个安全特性引入了每次设备引导时产生的随机“偏移”，通过该偏移，内核的基地址被移位。
通常，内核被加载到固定的物理地址，其对应于内核的VAS中的固定虚拟地址。
通过引入KASLR，所有内核的内存，包括其代码，被这个随机偏移量（也称为“幻灯片”）移动。
虽然KASLR可能是针对旨在利用内核的远程攻击者的有效缓解，但是对于本地攻击者以鲁棒的方式实现是非常困难的。
事实上，已经有一些非常有趣的最近对该主题的研究，其设法击败KASLR，而不需要任何软件缺陷（例如，通过观察定时差异）。
虽然这些攻击本身是非常有趣的，但应该注意，绕过KASLR通常可以更容易地实现。 回想一下，整个内核被一个“滑动”值移动 –
这意味着泄露内核中与内核基址地址有一个已知偏移量的任何指针将允许我们很容易地计算出滑块的值。
Linux内核确实包括旨在防止这种指针泄漏到用户空间的机制。 一种这样的缓解是通过确保每次指针的值由内核写入时，使用特殊格式说明符“％pK”来打印。
然后，根据kptr_restrict的值，内核可以匿名打印的指针。
在我遇到的所有Android设备中，kptr_restrict配置正确，确保“％pK”指针是匿名的。
是的，因为它可能，我们所需要的是找到一个内核开发人员忽略匿名的单一指针。 在三星的情况下，这变得很有趣… pm_qos
debugfs条目，它是可读的system_server，包括以下代码片段负责输出条目的内容：
不幸的是，匿名化格式说明符区分大小写…使用小写“k”，如上面的代码，导致上面的代码输出指针，而不应用“％pK”提供的匿名化（也许这是一个很好的例子
脆弱的KASLR）。 无论如何，这允许我们简单地读取pm_qos的内容，并从指针的值与内核基地址的已知偏移量相减，从而给出KASLR幻灯片的值。
**Mitigation #2 – 加载任意内核代码**
防止新内核代码的分配是RKP强制执行的主要缓解之一。 此外，RKP旨在保护所有现有的内核代码不被修改。 这些缓解是通过强制执行以下规则集来实现的：
1.除了内核代码之外，所有页面都被标记为“Privileged Execute Never” （PXN）
2.内核数据页从不标记为可执行
3.内核代码页从不标记为可写
4.所有内核代码页在阶段2转换表中被标记为只读
5.所有存储器翻译条目（PGD，PMD和PTE）对于EL1被标记为只读
虽然这些规则看起来相当健壮，但我们如何确保它们被正确执行？ 不可否认，规则在RKP文档中很好地布局，但这不是一个强大的保证…
让我们开始挑战第一个断言; 即，除了内核的代码，所有其他页面被标记为PXN。 我们可以通过查看EL1中的阶段1翻译表来检查这个断言。
ARMv8支持在EL1，TTBR0_EL1和TTBR1_EL1中使用两个转换表。
TTBR0_EL1用于保存用户空间VAS的映射，而TTBR1_EL1保存内核的全局映射。