代码 3.
Python 的特殊值None 将在节点类和之后的链表类中发挥重要的作用。引用None 意味着没有
下一个节点。在构造器中，一个节点的对下一节点引用的初始赋值是None。因为这有时被称为把节
点“接地”（grounding），我们在图中将使用标准化的“接地”标志来表示一个值为None 的引
用。用None 来作为你在初始化时对下一个节点的引用是一个极妙的主意。
图3.11 节点类对象包含本身的项目数据和对下一个节点的引用
图3.12 一个典型的节点类对象的实现
3.6.2.2. 类：无序列表 UNORDERED LIST
正如我们之前提到的，无序列表将由一个节点集合组成，每一个节点采用显式引用链接到下一
个节点。只要我们知道第一个节点的位置（包含第一项），在这之后的每个元素都可以通过以下链
接找到下一个节点。为实现这个想法，UnorderedList 类必须保持一个对第一节点的引用。代码2显
示了这种构造结构。注意每个UnorderedList对象将保持列表的头一个节点的引用。
class UnorderedList:
def __init__(self):
self.head = None
代码3.
>>> mylist = UnorderedList()
在最初当我们建立一个列表时，其中没有任何元素。如图3.13所示，这些赋值语句建立了一个
连接好的链表。正如我们在定义节点类时讨论到的，特殊引用——None 会再被用来说明列表的头不
指向任何东西。最终，如图3.14所示，之前给出的示例列表将由一个链表来表示。列表的头指向包
含列表的第一项的第一节点。以此类推，该节点有一个指针指向到下一个节点（的内容）。需要注
意的一点是，列表类本身不包含任何节点。取而代之的是，它包含对链式存储结构的第一个节点的
引用。
图3.13 一个空列表
图
3.14 一个由整数组成的链表
is_empty（判断链表是否为空）方法仅仅只是检查了列表的头是否指向None。其结果以布尔值
表示，如果链表中没有节点，self.head==None的结果只能是True。因为新链表为空，所以构造器和
是否为空的检验必须与另一个保持一致。这个显示了使用指向None来指示链表结构的结束。在
Python中，None可以与任何指向相提并论。如果两个指向同一个物体，那么他们是平等的。我们在
后续的方法中经常用到这一点。
def isEmpty(self):
return self.head == None
代码
3.
那么，我们如何把元素放入链表？我们需要实现添加（add）的方法。在此之前，我们需要解决
的重要问题是我们应该将新的元素放在链表的哪一部分。因为这个列表是无序的，新元素在列表中
相对于其他元素的具体位置是不重要的。新的元素可以放置在任何地方。鉴于此，把新的元素放置
在最简单的位置最好。
考虑到链表结构只为我们提供了一个入口，即该列表的头，所有其他节点只能通过访问第一个
节点，然后通过下一个引用链接到那里。这意味着最容易增加新节点的地方是在头部，或者说在列
表的开始。换句话说，我们将把新项目作为列表的第一个项目，而现有的项目将需要连接到这个新
第一个项目，这样它们就会跟随过来。
在图6 中展示的列表是通过多次添加数字这个方法来建构的。
>>> mylist.add(31)
>>> mylist.add(77)
>>> mylist.add(17)
>>> mylist.add(93)
>>> mylist.add(26)
>>> mylist.add(54)
请注意，由于31是添加到列表中的第一项，那么它最终将在链表的最后一个节点，因为之后的
每一项被添加在它前面。同时，由于54是最后加入的元素，它将成为链表中的第一个节点的数据
值。
add 方法如代码4所示。列表中的每个元素必定属于一个节点。第二行创建了一个新的节点并
将插入的元素作为节点的数据。现在我们必须通过链接这个新的节点与原有的结构来完成插入元素
的工作。这需要图3.15所示的两个步骤。第一个步骤（代码4第3行）是把新插入节点的引用设为
原来列表的头节点。由于列表中的其他部分已经和这个新节点正确地连接了，我们可以把列表头部
head 指向这个新的节点。代码第4行就是这一步骤，它确定了列表的头部。
上述两个步骤的顺序是十分重要的。如果将第3行和第4行的顺序颠倒过来会如何呢？如果我
们先更改这个列表的头部，那么结果将如图3.16所示。由于头部是外部对链表内部节点的唯一引
用，所有原有的节点将会丢失并且无法被再度访问。
def add(self,item):
temp = Node(item)
temp.setNext(self.head)
self.head = temp
代码 3.
图3.15：向一个两步的进程中添加一个新节点
图3.16：改变两个步骤顺序的后果
接下来我们所要实现的方法——求元素个数（size）、查找（search）和移除（remove），全部
是基于一个叫做链表的遍历（traversal）的操作的。遍历指的是有序地访问每一个节点的过程。为了
做到这一点，我们可以使用一个外部引用，它最开始指向列表的第一个节点。每当我们访问一个节
点时，我们通过“侧向移动”（traversing）到下一个引用的方式，将外部引用移动到下一个节点。
为了实现“size求元素个数”的方法，我们需要遍历链表，并且记录出现过的节点个数。代码5
是计算列表中节点个数的Python 代码。我们把这个外部引用称为“当前”（current），在第二行中
它被初始化，指向列表的头部。最初我们并没有发现任何节点，所以计数的初值被设定为0。第四到
第六行实际上实现了这次遍历。只要这个外部引用没有遇到列表的尾端（None），我们就将current
移动到下一个节点，正如第6行所示。和前文相同，把引用和None 进行比较的操作非常有用。每
当current 移动到了一个新的节点，我们就把计数器加1(count)。最终，我们在循环结束后返回了计
数值。图3.17展示了这样一个进程。
def size(self):
current = self.head
count = 0
while current != None:
count = count + 1
current = current.getNext()
return count
代码 3.
图 3.17 将列表从头遍历到尾
在一个无序表中查询一个数值这一方法的实现同样需要用到遍历。每当我们访问一个链表中的
节点时，我们会判断储存在此的数据是否就是我们所要找的元素。然而在这个例子中，我们并没有
必要遍历整个列表。事实上，如果我们的工作进行到了列表的底端，这意味着我们所要寻找的元素
在列表中并不存在。同样，如果我们找到了那个元素，那么就没有必要继续寻找了。
代码6实现了查询(search)这一方法。同size方法一样，遍历在列表的头部被初始化（第2
行）。我们同样使用一个叫做found的布尔变量来表示我们是否找到了我们所要找寻的元素。考虑到
我们在遍历开始时并没有找到那个元素，found被设为假(False)（第3行）。第4行中的循环同时考
虑了上述的两种情况。只要还有余下的未访问节点并且我们还没有找到元素，我们便继续检查下一
个节点。第5行中的条件语句判断所寻的数据项是否在节点current之中。如果是，那么found被设
为真(True)。
def search(self,item):
current = self.head
found = False
while current != None and not found:
if current.getData() == item:
found = True
else:
current = current.getNext()
return found
代码 3.
以调用查询(search)过程来查找“17”为例。
>>> mylist.search(17)
True
由于17在列表中，遍历进程只需要进行到那个含有17的节点。此时变量found将会被设为真
(True)，并在条件失效时返回True，如上图所示。这个过程如图3.18。
图3.18：成功找到数值“17”
“移除(remove)”这个方法需要两个步骤。首先我们需要遍历这个列表，来找寻我们想要移除的
元素。只要找到了这个元素（假设它存在），就必须移除它。第一步同查询(search)十分接近。我们
使用一个外部引用，让它开始时指向链表的头部，顺着链表遍历，直到找到要移除的元素为止。由
于我们假设待移除的元素一定存在，那么循环将会在遍历到列表底部前终止。所以，我们这时只需
要再使用一个布尔变量found。
当found为真(True)时，current将会是对包含了要移除元素的一个引用。但我们要如何移除它？
一个可行的方案是，用一些标记来替代要移除的元素，从而表明原先的元素已经不在列表中了。这
个方案的问题是，节点的数目将与数据项的数目不相同。通过移除整个节点来移除元素会是更可行
的方式。
为了移除含有待移除元素的节点，我们需要修改前一个节点的链接方式，使它引用current 紧跟
着的节点。不幸的是，在链表中没有办法从后往前移动。因为current 引用的节点处于一个我们需要
作修改的节点的后方，当我们移除current 所指节点后，已经无法对前一个节点进行必要的修改操
作。
解决这个难题的方法是，在遍历链表时使用两个外部引用。current不变，仍然标记当前遍历到
的位置。新加入的引用——我们叫“前一个”（previous）——在遍历过程中总是落后于current一
个节点。这样，当current停在待删除节点时，previous即停在链表中需要修改的节点处。
代码7展示了完整的移除(remove)过程。第二第三行给两个外部引用赋了初始值。注意到
current如同其他的“遍历”实例一样，从列表的头部开始。然而，我们设定previous总是访问
current的前一个节点。因此，previous的初值设为None，因为头部之前没有节点（如图3.19）。布
尔变量found将会再次被用于控制这次循环。
在第六到第七行我们区分了储存在节点中的单元是否是我们想要移除的元素。如果是，found将
会变成真(True)。如果我们没有找到元素，previous和current必须同时向后移动一个节点。同样，这
两个操作的顺序至关重要，首先previous要向后移动一个节点，到current的位置，然后current才
能移动。这一过程常常被称为“一寸寸蠕动”（inch-worming），因为previous先要跟上current，
current才能向前移动。图3.20展示了previous和current在顺着列表而下寻找含有17的节点时的移
动方式。
def remove(self,item):
current = self.head
previous = None
found = False
while not found:
if current.getData() == item:
found = True
else:
previous = current
current = current.getNext()
if previous == None:
self.head = current.getNext()
else:
previous.setNext(current.getNext())
代码 3.
图3.19：两次引用previous和current的初值
图3.20：previous和current沿列表移动
移除(remove)工作中的查询步骤一旦完成，我们需要从链表中移除那个节点。图3.21显示了一
个必须进行改动的连接。然而这里又有一点需要特别说明。如果要移除的那个元素恰好是列表中的
第一个，那么current会引用链表第一个节点。这也就意味着previous的引用会是None。我们之前提
到，previous要指向那个引用要发生变化的节点。在这种情况下，需要改动的不是previous，而是链
表的头节点（如图3.22）。
图3.21：移除列表中间的一个节点
图3.22：移除列表第一个节点
代码7的第12行让我们可以检查我们所要处理的情况是否是上述的特殊情况。如果previous没
有移动，那么当布尔变量found已经为真时，previous仍然是None。这种情况下（第13行），链表
头部head要发生变化，引用紧跟current的那个节点，实际效果就等于从列表中移除第一个节点。
而当previous不是None时，要移除的节点一定在链表中表头后方的某处。这时previous将会让我们
找到所要移除的节点的前一个节点。第15行调用了previous的setNext方法来完成这次移除。注意
到在两种情况中，需要改动的节点或表头最终都指向了current的后一个节点。读到这里，人们常常
产生的疑问是，上述的两种情况是否同样适用于被移除的节点是最后一个的情形。这个问题读者可
以自己思考。
你可以用代码1中的无序列表来进行测试。
剩下的方法——追加（append），插入（insert），索引（index），弹出（pop）,都将作为你的
练习。记住任何一个操作中都要同时考虑对象在列表头部和其他位置这两种情况。同样，插入、索
引、弹出需要我们给列表中的位置命名。我们假定列表中位置的名称是从0开始的整数。
牛刀小试
1.实现无序列表的append方法。并给出你的程序的时间复杂度。
2.在上一个问题中，你很有可能给出一个时间复杂度为O（n）的算法。但如果你给“无序表”类添
加一个变量，你可以写出时间复杂度为O（1）的算法。将你的算法的时间复杂度简化为O（1）。注
意！这时你需要考虑非常多的特殊情况，同时要修改add方法。
3.6.3 抽象数据类型：有序列表
现在，我们考虑一类被称为有序列表的列表。例如，如果前文所示的整数列表是一个有序列表
(升序)，那么它可以写成17，26，31，54，77和93。因为17是最小的，所以它是列表中的第一个
元素。同样，因为93是最大的元素，它在列表中的位置是最后的。
有序列表的结构是一个数据的集合体，在集合体中，每个元素相对其他元素有一个基于元素的
某些基本性质的位置。假设我们已经在列表元素中定义了一个有意义的比较大小的操作，则排序通
常是升序或降序。有序列表的许多方法和无序表是一样的。