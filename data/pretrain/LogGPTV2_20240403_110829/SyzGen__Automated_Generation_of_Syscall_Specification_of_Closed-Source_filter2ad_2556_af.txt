A&B
A&B
A&B
A&B
A&B
A&B
A&B
A&B
A&B
A&B
A&B
A&B
A&B
A&B
A&B
A&B
A&B
A&B
A&B
A&B
A&B
Table 5: Vulnerabilities found by SyzGen
Session 3B: Operating Systems CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea760be exploited to achieve privilege escalation and has been assigned
CVE-2020-9928.
7 DISCUSSION AND LIMITATION
Even though we have shown SyzGen as a promising direction to
generate templates for closed-source kernel modules, there are still
improvements that can make the solution even better. One premise
of fuzzing and any dynamic analysis is that the target driver must
be loaded so that we could invoke its interfaces. However, we find
that the majority of drivers are not running on our tested machines.
Nonetheless, it is arguable that only those loaded-by-default drivers
are more meaningful attack surfaces. Also, since SyzGen begins
with logs to infer explicit dependencies and then generalizes them
beyond the logs, it would degrade to the mode where only interface
recovery is performed if no log is available.
Modern fuzzing is typically not only coverage-guided but also
usually accompanied by various sanitizers (e.g., Kernel Address
Sanitizer or KASAN) that could catch various types of bugs even
when they do not cause an immediate kernel crash. Unfortunately,
retrofitting sanitizers into closed-source binaries (especially kernel
drivers) remains to be a challenge. Static rewriting of binaries is
a possible direction to address this problem but at the moment
only ELFs binaries can be rewritten with a high accuracy [12].
QASan [13] is an alternative that utilizes QEMU to dynamically
instrument the binary, though it only supports user-mode programs.
Apple occasionally releases a few driver binaries with KASAN
enabled, but we found that only three drivers we tested had this
feature. Windows is equipped with an in-house driver verifier to
monitor drivers by manipulating memory allocation and resource
management, which can be integrated into our system if we port
SyzGen to Windows.
8 CONCLUSION
In this paper, we proposed SyzGen, a first attempt to automatically
generate specifications to fuzz drivers without source code. SyzGen
could infer explicit dependencies for interfaces by analyzing a small
number of execution traces collected from exiting applications, and
then generalize the knowledge to other interfaces without traces.
Instead of producing syscall specifications in one shot, SyzGen
yields coarse-grained specifications at the beginning and iteratively
refines them, allowing us to combine knowledge learned from mul-
tiples runs under different calling contexts. We also proposed a
lightweight coverage collection technique to guide fuzzing without
requiring any specific hardware, virtual machine or kernel source
code. Our empirical evaluation shows that SyzGen is effective in
recovering driver interfaces, including input structure, constraints
upon inputs, and explicit dependencies between syscalls. Our eval-
uation shows that SyzGen is effective in producing high-quality
syscall specifications, leading to 34 unique bugs, including one that
attackers can exploit to escalate privilege, and 2 CVEs to date.
9 ACKNOWLEDGMENTS
We would like to thank the anonymous reviewers for providing
insightful feedback on our work. This work was supported by the
National Science Foundation under Grant No. 1652954.
Figure 8: Syscall specification where resource is the keyword
for dependencies.
that could trigger an arbitrary read bug in the Bluetooth driver,
which has been assigned CVE-2020-9929. In this example, resources
‘connection_0’ and ‘connection_1’ are two types of dependencies
that are inferred through our proposed signature-based depen-
dence inference approach. As we can see, the fifth argument (i.e.,
inputStruct) is a nested structure that consists of multiple fields of
different types, including pointer, array, constant, and so on. Ad-
ditionally, the specification specifies inter-fields relationship, e.g.,
the length field ‘Group199_3_const39’ represents the size of an-
other structure ‘Group199_3_struct_48’. The vulnerability results
from a memory read whose address is directly provided by user
(i.e., Group199_3_buffer11) without any sanitization. That said, to
trigger the bug, we must properly construct the input and set up
the correct sequence of syscalls to obtain valid dependence values
for connection_0 and connection_1. Thus, without dependence
inference and interface recovery, it would be difficult for fuzzing
to properly instantiate the arguments to the syscall, likely missing
this bug.
Design issue in Bluetooth. A common practice for macOS dri-
vers to deal with race conditions is to enforce a single-threaded
work loop which ensures sequential execution of requests. How-
ever, the problem with this design is that some requests need to
communicate with the underlying firmware which in turn may
communicate with other devices, and thus occupying the working
thread while waiting for the response can block the entire execution
and is not desired. To cope with it, the driver must put the awaiting
thread to sleep until any response arrives, which unfortunately
leaves a loophole for race conditions. For a waiting request that has
not been completed, any associated global data are susceptible to
the modification of following requests. We found that this issue is
prevalent in the Bluetooth driver and cannot be fixed without sub-
stantial changes to the design of the system. This vulnerability can
resource port[io_connect_t]resource connection_0[int32]resource connection_1[int16]Group199_3_struct_48 {    … …    Group199_3_buﬀer_11  int64    … …} [packed]Group199_3_struct_46 {    Group199_3_ptr_6  ptr[in, connection_0]    Group199_3_ptr_8  ptr[in, connection_1]    Group199_3_ptr_35  ptr[in, Group199_3_struct_48]    Group199_3_buﬀer_36  array[const[0, int8], 32]    Group199_3_const_37  len[Group199_3_ptr_6, int64]    Group199_3_const_38  len[Group199_3_ptr_8, int64]    Group199_3_const_39  len[Group199_3_ptr_35, int64]    Group199_3_buﬀer_40  array[const[0, int8], 32]    Group199_3_const_41  const[199, int32]} [packed]syz_IOConnectCallMethod$Group199_3(connection port, selector const[0], input ptr[in, const[0, int8]], inputCnt const[0], inputStruct ptr[in, Group199_3_struct_46], inputStructCnt const[116], output ptr[out, const[0, int8]], outputCnt ptr[in, const[0, int32]], outputStruct ptr[out, const[0, int8]], outputStructCnt ptr[in, const[0, int32]])Session 3B: Operating Systems CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea761REFERENCES
[1] 2021. Apple Open Source. https://opensource.apple.com/source.
[2] 2021. IDA Pro. https://www.hex-rays.com/ida-pro/.
[3] 2021. p-joker. https://github.com/lilang-wu/p-joker.
[4] 2021. Symbolic lengths. https://docs.angr.io/advanced-topics/gotchas.
[5] 2021. Syzbot. https://syzkaller.appspot.com/upstream.
[6] 2021. Syzkaller. https://github.com/google/syzkaller.
[7] Xiaolong Bai, Luyi Xing, Min Zheng, and Fuping Qu. 2020. iDEA: Static Analysis
on the Security of Apple Kernel Drivers. In Proceedings of the 2020 ACM SIGSAC
Conference on Computer and Communications Security. 1185–1202.
[8] Vitaly Chipounov, Volodymyr Kuznetsov, and George Candea. 2011. S2E: A
platform for in-vivo multi-path analysis of software systems. Acm Sigplan Notices
46, 3 (2011), 265–278.
[9] Jake Corina, Aravind Machiry, Christopher Salls, Yan Shoshitaishvili, Shuang
Hao, Christopher Kruegel, and Giovanni Vigna. 2017. Difuze: Interface aware
fuzzing for kernel drivers. In Proceedings of the 2017 ACM SIGSAC Conference on
Computer and Communications Security. 2123–2138.
[10] Weidong Cui, Marcus Peinado, Karl Chen, Helen J Wang, and Luis Irun-Briz.
2008. Tupni: Automatic reverse engineering of input formats. In Proceedings of
the 15th ACM conference on Computer and communications security. 391–402.
[11] William HE Day and Herbert Edelsbrunner. 1984. Efficient algorithms for ag-
glomerative hierarchical clustering methods. Journal of classification 1, 1 (1984),
7–24.
[12] Gregory J Duck, Xiang Gao, and Abhik Roychoudhury. 2020. Binary rewriting
without control flow recovery. In Proceedings of the 41st ACM SIGPLAN Conference
on Programming Language Design and Implementation. 151–163.
[13] Andrea Fioraldi, Daniele Cono D’Elia, and Leonardo Querzoni. 2020. Fuzzing
binaries for memory safety errors with QASan. In 2020 IEEE Secure Development
(SecDev). IEEE, 23–30.
[14] HyungSeok Han and Sang Kil Cha. 2017. Imf: Inferred model-based fuzzer. In
Proceedings of the 2017 ACM SIGSAC Conference on Computer and Communications
Security. 2345–2358.
[15] Dae R Jeong, Kyungtae Kim, Basavesh Shivakumar, Byoungyoung Lee, and Insik
Shin. 2019. Razzer: Finding kernel race bugs through fuzzing. In 2019 IEEE
Symposium on Security and Privacy (SP). IEEE, 754–768.
[16] Kyungtae Kim, Dae R Jeong, Chung Hwan Kim, Yeongjin Jang, Insik Shin, and
Byoungyoung Lee. 2020. HFL: Hybrid fuzzing on the linux kernel. In Proceedings
of the 2020 Annual Network and Distributed System Security Symposium (NDSS),
San Diego, CA.
[17] JongHyup Lee, Thanassis Avgerinos, and David Brumley. 2011. TIE: Principled
reverse engineering of types in binary programs. (2011).
[18] Juwei Lin and Junzhi Lu. 2019. Panic on the Streets of Amsterdam: PanicXNU
3.0. 2019 HITB Security Conference.
[19] Zhiqiang Lin, Xiangyu Zhang, and Dongyan Xu. 2010. Automatic reverse en-
gineering of data structures from binary execution. In Proceedings of the 11th
Annual Information Security Symposium. 1–1.
[20] Stefan Nagy and Matthew Hicks. 2019. Full-speed fuzzing: Reducing fuzzing
overhead through coverage-guided tracing. In 2019 IEEE Symposium on Security
and Privacy (SP). IEEE, 787–802.
[21] Shankara Pailoor, Andrew Aday, and Suman Jana. 2018. Moonshine: Optimiz-
ing OS fuzzer seed selection with trace distillation. In 27th USENIX Security
Symposium (USENIX Security 18). 729–743.
[22] Sergej Schumilo, Cornelius Aschermann, Robert Gawlik, Sebastian Schinzel, and
Thorsten Holz. 2017. kafl: Hardware-assisted feedback fuzzing for OS kernels. In
26th USENIX Security Symposium (USENIX Security 17). 167–182.
[23] Dokyung Song, Felicitas Hetzelt, Dipanjan Das, Chad Spensky, Yeoul Na, Stijn
Volckaert, Giovanni Vigna, Christopher Kruegel, Jean-Pierre Seifert, and Michael
Franz. 2019. Periscope: An effective probing and fuzzing framework for the
hardware-os boundary. In NDSS.
[24] JV Stoep. 2016. Android: protecting the kernel. Linux Securit Summit (August
2016) (2016).
[25] Dmitry Vyukov. 2019. Syzkaller: an unsupervised, coverage-guided kernel fuzzer.
[26] Dmitry Vyukov. 2020. Syzkaller: adventures in continuous coverage-guided
kernel fuzzing. Bluehat IL.
[27] Fish Wang and Yan Shoshitaishvili. 2017. Angr-the next generation of binary
analysis. In 2017 IEEE Cybersecurity Development (SecDev). IEEE, 8–9.
[28] Lilang Wu and moony Li. 2019. Fresh Apples: Researching new attack interfaces
on iOS and OSX. In HITB Security Conference.
[29] Meng Xu, Sanidhya Kashyap, Hanqing Zhao, and Taesoo Kim. 2020. Krace: Data
Race Fuzzing for Kernel File Systems. In 2020 IEEE Symposium on Security and
Privacy (SP). IEEE, 1643–1660.
[30] Meng Xu, Chenxiong Qian, Kangjie Lu, Michael Backes, and Taesoo Kim. 2018.
Precise and scalable detection of double-fetch bugs in OS kernels. In 2018 IEEE
Symposium on Security and Privacy (SP). IEEE, 661–678.
[31] Wen Xu, Hyungon Moon, Sanidhya Kashyap, Po-Ning Tseng, and Taesoo Kim.
2019. Fuzzing file systems via two-dimensional input space exploration. In 2019
IEEE Symposium on Security and Privacy (SP). IEEE, 818–834.
[32] Michal Zalewski. 2015. American fuzzy lop. URL http://lcamtuf. coredump. cx/afl
(2015).
Algorithm 1: Locate command identifier and collect its
valid values
1 Function AnalyzeCtrlID(𝛼:init state, 𝜏 : all class member
functions):
Symbolize all inputs for 𝛼
𝑎𝑐𝑡𝑖𝑣𝑒𝑠, 𝑑𝑒 𝑓 𝑒𝑟𝑟𝑒𝑑 ← [𝛼], []
while actives is not empty do
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
𝑎𝑐𝑡𝑖𝑣𝑒𝑠 ← SymbolicExecution(𝑎𝑐𝑡𝑖𝑣𝑒𝑠)
forward all states by one basic block
foreach s in actives do
if s.addr in 𝜏 then
move 𝑠 from 𝑎𝑐𝑡𝑖𝑣𝑒𝑠 to 𝑑𝑒 𝑓 𝑒𝑟𝑟𝑒𝑑
⊲ Step
if actives is empty then
if all states in deferred have the same address
then
swap(actives, deferred)
continue
𝑐𝑚𝑑𝑠 ←find common symbolic variables from
states in deferred
foreach cmd in cmds do
if cmd can have different values in different
states from deferred then
foreach s in deferred do
if cmd can have multiples values in s
then
move 𝑠 from 𝑑𝑒 𝑓 𝑒𝑟𝑟𝑒𝑑 to 𝑎𝑐𝑡𝑖𝑣𝑒𝑠
if actives is empty then
return cmd, values for cmd
break
if actives is empty then
Randomly move one state from 𝑑𝑒 𝑓 𝑒𝑟𝑟𝑒𝑑 to
𝑎𝑐𝑡𝑖𝑣𝑒𝑠
A COMMAND IDENTIFIER DETERMINATION
Algorithm 1 describes the procedure to identify the command
identifier, as well as its valid values and corresponding function-
alities (i.e., function address). We observed that the entry func-
tion IOConnectCallMethod is simply a dispatch function that calls
other functions depending on the command identifier. Based on
which, SyzGen considers all functions inside the target driver as
candidates for functionalities, and performs symbolic execution to
locate the key variable for dispatching. Essentially, SyzGen sym-
bolizes the inputs and employs a breadth-first search strategy to
explore all paths, during which it suspends any state that runs into
a function that could potentially be the entry of one functionality.
If no states are active, SyzGen extracts common symbolic variables
from constraint sets of those stopped states and check whether
Session 3B: Operating Systems CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea762Type
const[i]
const[j]
flags[𝑗0, ..., 𝑗𝑚]
ptr
flags[i, j]
flags[i, 𝑗0, ..., 𝑗𝑚]
ptr if i == 0
flags[𝑖0, .. 𝑖𝑛, 𝑗0, ... 𝑗𝑚]
flags[𝑖0, ..., 𝑖𝑛]
ptr
int[𝑖𝑚𝑖𝑛, 𝑖𝑚𝑎𝑥 ]
struct A
Table 6: Rules for merging two specifications if they only differ in one field. We simply take the union of two fields whenever
possible.
B if B.fields[0] == flags[𝑖0, ..., 𝑖𝑛]
B if B.fields[0] == ptr
B if B.fields[0] == int[𝑖𝑚𝑖𝑛, 𝑖𝑚𝑎𝑥 ]
B if 𝐴 ⊂ 𝐵
int[𝑗𝑚𝑖𝑛, 𝑗𝑚𝑎𝑥 ]
int[𝑗𝑚𝑖𝑛, 𝑗𝑚𝑎𝑥 ] if 𝑗𝑚𝑖𝑛 <= i <= 𝑗𝑚𝑎𝑥
int[𝑗𝑚𝑖𝑛-1, 𝑗𝑚𝑎𝑥 ] if 𝑗𝑚𝑖𝑛-1 == i
int[𝑗𝑚𝑖𝑛, 𝑗𝑚𝑎𝑥 +1] if 𝑗𝑚𝑎𝑥 +1 == i
int[min, max] if ∀𝑥 ∈ [𝑚𝑖𝑛, 𝑚𝑎𝑥], 𝑥 ∈ [ 𝑗𝑚𝑖𝑛, 𝑗𝑚𝑎𝑥 ] ∪ [𝑖0, ..., 𝑖𝑛]
int[min, max] if ∀𝑥 ∈ [𝑚𝑖𝑛, 𝑚𝑎𝑥], 𝑥 ∈ [ 𝑗𝑚𝑖𝑛, 𝑗𝑚𝑎𝑥 ] ∪ [𝑖𝑚𝑖𝑛, 𝑖𝑚𝑎𝑥 ]
struct B
B if B.fields[0] == const[i]
(a) IOBluetoothHCIUserClient
(b) AppleUpstreamUserClient
(c) AudioAUUCDriver
(d) AppleAPFSUserClient
(e) IONetworkUserClient
Figure 9: Coverage for SyzGen-IMF, SyzGen-IMF and SyzGen.
there is one that could have unique values in different states. If so,
SyzGen believes that symbolic variable is the command identifier,
and it not only tells which parameter command identifier comes
from (e.g., inputStruct which is the fifth parameter to “IOConnect-
CallMethod”) but also precisely locates where it is (e.g., first 8 bytes
of inputStruct) since it can be embedded in a nested structure. Oth-
erwise, SyzGen resumes some states and repeats the process until
all states terminate.
0510152025Time(hour)0100020003000400050006000Block CoverageSyzgenSyzgen-IMFSyzgen-Base0510152025Time(hour)100120140160180200220240Block CoverageSyzgenSyzgen-IMFSyzgen-Base0510152025Time(hour)120140160180200220240260Block CoverageSyzgenSyzgen-IMFSyzgen-Base010203040506070Time(hour)01000200030004000500060007000Block CoverageSyzgenSyzgen-IMFSyzgen-Base0510152025Time(hour)100110120130140150160Block CoverageSyzgenSyzgen-IMFSyzgen-BaseSession 3B: Operating Systems CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea763