# Report

For each function, IPPO records one potential bug for each security operation type.

## 6. Evaluation

We evaluated the scalability and effectiveness of IPPO using the Linux kernel and OpenSSL library. The experiments were conducted on a MacBook Pro laptop with 16GB RAM and an Intel(R) Core(TM) i7 CPU with six cores (i7-8850H, 2.60GHz). We tested the bug detection efficiency on the Linux kernel version 5.8, OpenSSL library version 3.0.0-alpha6, FreeBSD 12, and PHP 8.0.8 using LLVM version 9.0. For the Linux kernel, we used `allyesconfig` to compile as many kernel modules as possible, generating 19,492 LLVM bitcode files. For the OpenSSL library, FreeBSD, and PHP, we used default compile options and generated 2,294, 1,483, and 371 LLVM bitcode files, respectively.

### 6.1 Overall Analysis Performance

Due to the limited RAM size of our machine, we batched the Linux kernel bitcode files for analysis. Each batch contained 3,000 bitcode files. IPPO completed the analysis of the four systems in two hours and reported a total of 754 bugs. The detailed bug detection results are shown in Table 2.

**Table 2: Bug detection results of IPPO in the four systems. The R and T in the table indicate the reported bugs and true bugs, respectively.**

| Bug Type          | Missing Check | Missing Release | Refcount Leak | Missing Unlock | Total |
|-------------------|---------------|-----------------|---------------|----------------|-------|
| **Linux**         |               |                 |               |                |       |
| T                 | 101           | 68              | 244           | 181            | 604   |
| R                 | 345           | 6               | 29            | 719            | 1099  |
| **OpenSSL**       |               |                 |               |                |       |
| R                 | 2             | 13              | 0             | 0              | 15    |
| T                 | 1             | 6               | 0             | 0              | 7     |
| **FreeBSD**       |               |                 |               |                |       |
| R                 | 1             | 1               | 0             | 2              | 3     |
| T                 | 0             | 0               | 0             | 1              | 1     |
| **PHP**           |               |                 |               |                |       |
| R                 | 4             | 11              | 0             | 2              | 17    |
| T                 | 0             | 1               | 0             | 0              | 1     |

### 6.2 Bug Findings

We manually checked all 754 reports generated by IPPO, which took approximately 20 man-hours. We confirmed 266, 7, 1, and 1 valid bugs from the Linux kernel, OpenSSL library, FreeBSD kernel, and PHP, respectively. These include 181 refcount leaks, 68 memory leaks, 12 missing check bugs, 7 double-free/use-after-free bugs, and 7 missing unlock bugs. Among these, 2 missing check bugs, 11 memory leak bugs, 99 refcount leak bugs, and 2 missing unlock bugs have been fixed in the latest systems. We submitted patches to fix the remaining 161 bugs, and 136 of them have been accepted by the corresponding maintainers. The detailed list of all bugs is available in Tables 5–11 in the Appendix.

One interesting finding is that the refcount API `pm_runtime_get_sync()` is commonly misused, causing hundreds of bugs. This not only highlights the limitations of cross-checking but also reinforces previous research on the same set of APIs ([26]). These refcount APIs change the refcount even if they return errors, which is counter-intuitive. In practice, developers often assume that the target task of a function call does not complete on failure, leading to the PM runtime counter not being decreased. Our patchwork sparked a discussion in the Linux community about the design of these APIs. Some maintainers suggest fixing the misleading APIs to prevent future misuse rather than patching them individually. A new alternative refcount API, `pm_runtime_resume_and_get()`, has been released, which does not modify the reference counter on failure. This API will make future refcount development more stable and secure.

We also investigated the size of all bug functions, excluding those caused by API misunderstandings (116 functions in total). 56 of them (48.3%) contain more than 100 lines of source code, and 18 (15.5%) contain more than 200 lines. The longest bug function caught by IPPO has 613 lines of source code, demonstrating IPPO's ability to detect bugs in complex functions. 17 of these long functions introduced bugs more than five years ago, and four bugs have existed for over ten years.

### 6.3 Comparison with Other Tools

#### 6.3.1 Comparison with Cross-checking Tools

In this subsection, we compare IPPO with three state-of-the-art bug detection tools: APISan [48], Crix [24], and FICS [9]. APISan and Crix are based on cross-checking, while FICS uses machine learning. All these tools find bugs by differentially checking similar code slices. HERO can detect incorrect error handling through precise function pairing. Our modifications on security check detection have been synchronized in Crix before this experiment. We focus on how many bugs found by IPPO could be caught by cross-checking methods, using the confirmed bugs found by IPPO as a benchmark.

**Table 3: Bug detection results of state-of-the-art tools.**

| Bug Type          | Missing Check | Missing Release | Refcount Leak | Missing Unlock | Total |
|-------------------|---------------|-----------------|---------------|----------------|-------|
| **IPPO**          | 12            | 75              | 181           | 7              | 275   |
| **FICS**          | 0             | 0               | 0             | 0              | 0     |
| **Crix**          | 1             | 0               | 0             | 0              | 1     |
| **APISan**        | 0             | 0               | 0             | 0              | 0     |

As shown in Table 3, almost all the bugs found by IPPO cannot be detected by the other three tools. FICS fails to analyze the Linux kernel due to extremely high RAM requirements (over 200GB). Although FICS claims to identify one-to-one inconsistencies, its code representation (data dependence graph) and filter strategies are too coarse-grained for path-level differences. Crix is designed to detect missing check bugs but cannot find other types. For missing check bugs, most bugs found by IPPO lack enough similar code pieces, making them undetectable by Crix. APISan considers all conditions in a path to construct semantic beliefs, but many intermediate conditions and operations do not impact the usage of security operations, leading to poor robustness in similarity analysis. The comparison results highlight the limitations of cross-checking methods and the effectiveness of IPPO.

#### 6.3.2 Comparison with Pairing Analyses Tool

HERO [10] is a state-of-the-art pairing analysis tool that can precisely detect functions used in pairs and bugs caused by disordered error handling (missing, redundant, and incorrect order of error handling). The bug types covered by HERO include refcount leak, memory leak, use-after-free/double-free, and incorrect lock/unlock, which are similar to the bug types supported by IPPO. Since HERO is not open-sourced, we manually checked the bugs found by IPPO and filtered out those not present in the Linux kernel version 5.3 (on which HERO was evaluated).

**Table 4: Comparison with HERO.**

| Bug Types         | Memory Leak | Refcount Leak | Missing Unlock | UAF/DF | Total | Bugs in v5.3 | HERO Results | Recall |
|-------------------|-------------|---------------|----------------|--------|-------|--------------|--------------|--------|
| **Bugs in v5.3**  | 55          | 112           | 3              | 6      | 176   | 176          | 84           | 47.7%  |
| **HERO Results**  | 2           | 82            | 0              | 0      | 84    | 84           | 84           | 47.7%  |

As shown in Table 4, we identified 176 valid bugs in the Linux kernel version 5.3. HERO successfully detected 84 of them (47.7%). HERO found most of the refcount bugs caused by the misunderstanding of the `pm_runtime_get_sync()` API, consistent with the HERO paper. However, HERO missed almost half of the bugs found by IPPO due to (1) many custom function pairs being missed, and (2) HERO's inability to resolve bugs without leader functions.

#### 6.3.3 Complementarity Analysis

We further analyzed whether the bugs found by other tools could be detected by IPPO. We collected 560 bugs found by APISan, Crix, and HERO in the Linux kernel, and IPPO could detect 119 of them (the bug list of FICS is not released, thus ignored). These experiments show that IPPO shares very limited overlap with existing bug detection tools, indicating that IPPO is a promising complement to them.

### 6.4 False Positives

The overall false positive rate of IPPO is 63.5%. The main causes are summarized below:

- **Unexpected pre-condition**: Although IPPO considers this case, it cannot pick out all eligible cases. Developers often use temporary variables to adjust the timing of security operations, especially refcount operations. These temporary variables may cause a missing case in a small part of the code or a function but balance out in the global context. Sometimes, developers set callback functions to auto-manage resources, which is hard to detect. IPPO needs a more powerful inter-procedure analysis flow to model and check against pre-conditions. Such cases account for 27% of the false positives.
- **Imprecise data-flow analysis**: The value escape methods while checking Rule 4 are diverse in practice. Some values escape through function calls, requiring expensive inter-procedure alias analysis, which IPPO cannot handle. Complex value propagation also decreases the analysis precision. These cases lead to about 30% of the false positives.
- **Imperfect error path analysis**: Our error path analysis heavily relies on return values, which is unreliable for void functions. Many error handling paths in void functions also lack error handling functions (e.g., print error messages), making them indistinguishable for IPPO. This contributes 14% of the false positives.
- **Imperfect security operation detection**: The current implementation of security operation detection cannot handle complex scenes. For example, some resources are released through refcount operations or other wrapper functions, which IPPO misses. This reason accounts for 6% of the false positives.
- **Other causes**: Special function logic and other cases can also cause false positives. Some missed security operations have no obvious security impact and are not counted as bugs. These cases contribute the remaining 23% of false positives.

False positives are a key challenge in program static analysis, especially for complex targets like OS kernels. We believe that the 63.5% false positive rate of IPPO is acceptable. Additionally, the three state-of-the-art similar static analysis tools also suffer from this issue (65.4%, 99.8%, and 88.0% false positive rates for Crix [24], APISan [48], and FICS [9], respectively). Manually analyzing bugs suggested by IPPO is relatively easy, taking a non-expert researcher less than two minutes on average to check a bug report after analyzing several examples.

### 6.5 False Negatives

To evaluate the false negatives of IPPO, we constructed a testset by manually removing security operations in normal functions. We randomly selected 40 functions in the Linux kernel where security operations are shown in multiple paths. We then deleted 10 resource release calls, 10 return value checks, 10 refcount decrements, and 10 unlocks, resulting in 10 memory leak bugs, 10 missing check bugs, 10 refcount leak bugs, and 10 missing unlock bugs, respectively. IPPO successfully detected 31 missed security operations (77.5% recall rate). Among the false negatives, two memory leak bugs, three missing check bugs, and four missing unlock bugs were missed by IPPO. Two of these were filtered due to pre-conditions containing function arguments, breaking Rule 4 of OSPP. One security check in a function was not identified, leading to a false negative. One checked function was defined inline, and removing security checks made the function call instruction disappear in LLVM IRs. Four unlock calls did not share the same parameters with the lock calls, thus were filtered. The last missed memory leak was caused by complex variable definitions, where the resource variable had multiple definitions, and the path where the resource release was removed had a wrapper function of release. However, this release wrapper should be paired with a previous definition, which is beyond the capability of IPPO.

### 6.6 Security Impacts of the Found Bugs

#### 6.6.1 Reachability Analysis

Understanding the reachability of bugs in complex programs is an open problem. In this evaluation, we used the existence of shorter call-stacks from system entry points to vulnerable functions to measure the reachability of bugs. Similar to previous works such as PeriScope [37] and SID [44], we chose system calls, ioctl handlers, and IRQ handlers as user-controllable system entry points to evaluate the reachability of the bugs identified by IPPO. Our evaluation result shows that 71.9% of the bugs identified by IPPO are reachable from at least one of these entry points, indicating that these bugs can be triggered by users.

#### 6.6.2 Impact Analysis

As discussed in §1, most bugs caused by missing security operations can lead to security impacts such as memory corruption, DoS, and memory leaks when triggered. Considering the reachability evaluation, 71.9% of the bugs identified by IPPO would lead to at least one security impact. Specifically, 24.6% and 70% of the bugs would cause memory leaks and refcount leaks, respectively, which could lead to denial-of-service if triggered repeatedly. Additionally, 5% of the bugs identified by IPPO would cause null-pointer-dereference, potentially leading to memory corruption when triggered. For example, Figure 5 shows a potential use-after-free/double-free bug in the Linux kernel identified by IPPO. The function `snd_echo_resume()` in Figure 5 can be reached from the system call `sys_ioctl()`, meaning attackers could trigger it and cause security impacts to the kernel.

### 6.7 Scalability and Portability

The bug detection results on both the Linux kernel and OpenSSL library demonstrate the scalability and portability of IPPO. The idea of OSPP and missed security operations is applicable to various programs, regardless of whether they run in kernel mode or user mode. Different programs may have their own preferences for security operations, but this is a pluggable analysis pass in IPPO, supporting further expansion on security operation types. IPPO can detect various missed security operations and infer their security impacts based on similar path pairs analysis in various programs that can be compiled into LLVM IRs.

## 7. Discussion

### Security Operation Detection

IPPO detects security operations with a direct and simple analysis pass, as mentioned in §5.1. Since detecting security operations is not the main goal of IPPO, we implemented three kinds of security operations in this paper to estimate the bug detection of IPPO. However, this part is pluggable and supports further extension. Three common types of security operations are sufficient to demonstrate the effectiveness of our approach. In the future, we plan to add more security operations (e.g., variable initialization) to further improve the bug detection ability of IPPO. We will also open-source IPPO to enable interested readers to extend it and detect bugs according to their practical needs.

### Inter-procedural Analysis

IPPO is primarily designed based on static intra-procedural analysis. However, considering only the information within a single function can result in both false positives and false negatives. Some missed security operations (e.g., security checks) are more likely to show differences in inter-procedural context. We believe the inter-procedural feature could be implemented by considering function calls, which is an interesting future work.

### Precise Data-flow Analysis

Currently, we track all variables' sources and use flows directly through a data-flow analysis implemented by us, which may not be accurate enough and can cause false positives. To address this, it would be interesting to introduce professional pointer analysis technology (e.g., Andersen pointer analysis [15] or batch analysis [40]) to improve our analysis flows and overall accuracy.

### Exploitability Analysis

We have analyzed the reachability of bugs found by IPPO in §6.6. To obtain the complete exploitability of a bug, we also need to analyze the accurate trigger condition, which can be accomplished through symbolic execution [35]. Automatically determining the exploitability of a bug is a challenging topic that deserves independent research (e.g., AEG [11], EvilCoder [32], MAZE [43], and Coppelia [38]). In this paper, we mainly focus on detecting the existence of potential security bugs. We may adopt exploitability analysis in the future to reduce the false-positive rate of IPPO.

## 8. Related Work

### Differential Analysis in Bug Detection

Differential analysis against similar code snippets is a common practice to detect semantic bugs. FICS [9] uses machine learning to measure the similarity and difference among code pieces. Similarly, some research uses machine learning to detect bugs in smart contracts [23, 51]. PISan [49] automatically infers the correct API usage patterns and further detects API misuse bugs through cross-checking. Juxta [27] can infer high-level semantics from source code and pick out implementations inconsistent with implicit semantics. CRADLE [33] leverages inconsistency checking to detect bugs in deep learning libraries. Hector [36] and RID [26] detect inconsistent release and refcount operations through intra-procedural path analysis, while Pex [50]