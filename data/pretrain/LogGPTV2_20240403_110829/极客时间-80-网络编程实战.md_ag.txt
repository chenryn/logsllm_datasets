## UDP 客户端例子接下来我们再来构建一个对应的 UDP客户端。在这个例子中，从标准输入中读取输入的字符串后，发送给服务端，并且把服务端经过处理的报文打印到标准输出上。    #include "lib/common.h" 
# define    MAXLINE     4096 int main(int argc, char **argv) {    if (argc != 2) {        error(1, 0, "usage: udpclient ");    }        int socket_fd;    socket_fd = socket(AF_INET, SOCK_DGRAM, 0);     struct sockaddr_in server_addr;    bzero(&server_addr, sizeof(server_addr));    server_addr.sin_family = AF_INET;    server_addr.sin_port = htons(SERV_PORT);    inet_pton(AF_INET, argv[1], &server_addr.sin_addr);     socklen_t server_len = sizeof(server_addr);     struct sockaddr *reply_addr;    reply_addr = malloc(server_len);     char send_line[MAXLINE], recv_line[MAXLINE + 1];    socklen_t len;    int n;     while (fgets(send_line, MAXLINE, stdin) != NULL) {        int i = strlen(send_line);        if (send_line[i - 1] == '\n') {            send_line[i - 1] = 0;        }         printf("now sending %s\n", send_line);        size_t rt = sendto(socket_fd, send_line, strlen(send_line), 0, (struct sockaddr *) &server_addr, server_len);        if (rt 还记得 TCP 程序吗？如果不开启服务端，TCP 客户端的 connect函数会直接返回"Connection refused"报错信息。而在 UDP程序里，则会一直阻塞在这里。
## 场景二：先开启服务端，再开启客户端在这个场景里，我们先开启服务端在端口侦听，然后再开启客户端：    $./udpserverreceived 2 bytes: g1received 2 bytes: g2    $./udpclient 127.0.0.1g1now sending g1send bytes: 2Hi, g1g2now sending g2send bytes: 2Hi, g2我们在客户端一次输入g1、g2，服务器端在屏幕上打印出收到的字符，并且可以看到，我们的客户端也收到了服务端的回应："Hi,g1"和"Hi,g2"。
## 场景三: 开启服务端，再一次开启两个客户端这个实验中，在服务端开启之后，依次开启两个客户端，并发送报文。服务端：    $./udpserverreceived 2 bytes: g1received 2 bytes: g2received 2 bytes: g3received 2 bytes: g4第一个客户端：    $./udpclient 127.0.0.1now sending g1send bytes: 2Hi, g1g3now sending g3send bytes: 2Hi, g3第二个客户端：    $./udpclient 127.0.0.1now sending g2send bytes: 2Hi, g2g4now sending g4send bytes: 2Hi, g4我们看到，两个客户端发送的报文，依次都被服务端收到，并且客户端也可以收到服务端处理之后的报文。如果我们此时把服务器端进程杀死，就可以看到信号函数在进程退出之前，打印出服务器端接收到的报文个数。    $ ./udpserverreceived 2 bytes: g1received 2 bytes: g2received 2 bytes: g3received 2 bytes: g4^Creceived 4 datagrams之后，我们再重启服务器端进程，并使用客户端 1 和客户端 2继续发送新的报文，我们可以看到和 TCP 非常不同的结果。以下就是服务器端的输出，服务器端重启后可以继续收到客户端的报文，这在 TCP里是不可以的，TCP 断联之后必须重新连接才可以发送报文信息。但是 UDP报文的"无连接"的特点，可以在 UDP服务器重启之后，继续进行报文的发送，这就是 UDP报文"无上下文"的最好说明。    $ ./udpserverreceived 2 bytes: g1received 2 bytes: g2received 2 bytes: g3received 2 bytes: g4^Creceived 4 datagrams$ ./udpserverreceived 2 bytes: g5received 2 bytes: g6第一个客户端：    $./udpclient 127.0.0.1now sending g1send bytes: 2Hi, g1g3now sending g3send bytes: 2Hi, g3g5now sending g5send bytes: 2Hi, g5第二个客户端：    $./udpclient 127.0.0.1now sending g2send bytes: 2Hi, g2g4now sending g4send bytes: 2Hi, g4g6now sending g6send bytes: 2Hi, g6
## 总结在这一讲里，我介绍了 UDP 程序的例子，我们需要重点关注以下两点：-   UDP 是无连接的数据报程序，和 TCP 不同，不需要三次握手建立一条连接。-   UDP 程序通过 recvfrom 和 sendto 函数直接收发数据报报文。
## 思考题最后我给大家留两个思考题吧。在第一个场景中，recvfrom一直处于阻塞状态中，这是非常不合理的，你觉得这种情形应该怎么处理呢？另外，既然UDP 是请求 - 应答模式的，那么请求中的 UDP 报文最大可以是多大呢？欢迎你在评论区写下你的思考，我会和你一起讨论。也欢迎把这篇文章分享给你的朋友或者同事，一起讨论一下UDP 这个协议。![](Images/5a282807b2a1ff091b7f803e8cef3429.png){savepage-src="https://static001.geekbang.org/resource/image/bf/25/bfc96ae0d8f839919b9d9866cfb8b025.jpg"}
# 07 \| What? 还有本地套接字？你好，我是盛延敏，这里是网络编程实战第 7 讲，欢迎回来。上一篇文章中，我们讲了 UDP。很多同学都知道 TCP 和UDP，但是对本地套接字却不甚了解。实际上，本地套接字是IPC，也就是本地进程间通信的一种实现方式。除了本地套接字以外，其它技术，诸如管道、共享消息队列等也是进程间通信的常用方法，但因为本地套接字开发便捷，接受度高，所以普遍适用于在同一台主机上进程间通信的各种场景。那么今天我们就来学习下本地套接字方面的知识，并且利用本地套接字完成可靠字节流和数据报两种协议。
## 从例子开始现在最火的云计算技术是什么？无疑是 Kubernetes 和 Docker。在 Kubernetes和 Docker 的技术体系中，有很多优秀的设计，比如 Kubernetes 的CRI（Container Runtime Interface），其思想是将 Kubernetes 的主要逻辑和Container Runtime 的实现解耦。我们可以通过 netstat 命令查看 Linux系统内的本地套接字状况，下面这张图列出了路径为/var/run/dockershim.socket 的 stream类型的本地套接字，可以清楚地看到开启这个套接字的进程为 kubelet。kubelet是 Kubernetes的一个组件，这个组件负责将控制器和调度器的命令转化为单机上的容器实例。为了实现和容器运行时的解耦，kubelet设计了基于本地套接字的客户端 - 服务器 GRPC 调用。``{=html}![](Images/d39939fb8971dcf3f18a6a1e06bc9856.png){savepage-src="https://static001.geekbang.org/resource/image/c7/6b/c75a8467a84f30e523917f28f2f4266b.jpg"}\眼尖的同学可能发现列表里还有 docker-containerd.sock等其他本地套接字，是的，Docker其实也是大量使用了本地套接字技术来构建的。如果我们在 /var/run 目录下将会看到 docker 使用的本地套接字描述符:![](Images/164c9d9867dc8a247f089ef1b7e2e0d3.png){savepage-src="https://static001.geekbang.org/resource/image/a0/4d/a0e6f8ca0f9c5727f554323a26a9c14d.jpg"}
## 本地套接字概述本地套接字一般也叫做 UNIX域套接字，最新的规范已经改叫本地套接字。在前面的 TCP/UDP例子中，我们经常使用 127.0.0.1完成客户端进程和服务器端进程同时在本机上的通信，那么，这里的本地套接字又是什么呢？本地套接字是一种特殊类型的套接字，和 TCP/UDP 套接字不同。TCP/UDP即使在本地地址通信，也要走系统网络协议栈，而本地套接字，严格意义上说提供了一种单主机跨进程间调用的手段，减少了协议栈实现的复杂度，效率比TCP/UDP 套接字都要高许多。类似的 IPC 机制还有 UNIX 管道、共享内存和 RPC调用等。比如 X Window实现，如果发现是本地连接，就会走本地套接字，工作效率非常高。现在你可以回忆一下，在前面介绍套接字地址时，我们讲到了本地地址，这个本地地址就是本地套接字专属的。![](Images/ff91d129b4dfb418a981d12f2aa39aca.png){savepage-src="https://static001.geekbang.org/resource/image/ed/58/ed49b0f1b658e82cb07a6e1e81f36b58.png"}