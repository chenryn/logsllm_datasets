eHCI (Enhanced Host Controller Interface) 
uHCI (Universal Host Controller Interface) 
xHCI (Extensible Host Controller Interface) 
Host controller driver: This provides a hardware abstraction layer so that the host can 
communicate via the controller interface to the hardware. 
USB core: The component that performs core functionality such as device enumeration 
Class drivers: Once enumeration is complete and control has been passed to a USB class driver, 
communication specific to the connected device is processed by the class driver 
Application software: When a USB device is inserted a host may start an application specific to the 
class of that device (e.g. an application that displays photos when a camera device is connected). 
NCC Group | Page 10 
© Copyright 2013 NCC Group 
6 Identifying Supported Devices 
For USB host vulnerability assessment via fuzzing it is important to establish what device classes are 
supported. This is because USB fuzzing is a relatively slow process – each test case requires the 
virtual device to be “inserted” and “removed” via software, resulting in enumeration being performed 
each time. The USB protocol is designed to expect a human, rather than a computer, to insert a 
device, and so timing delays result in each test case taking several seconds to complete. If 
functionality that is not supported by the target host is fuzzed then this can waste large amounts of 
testing time.   
6.1 USB Device Classes 
There are a number of high level USB device classes; these are shown in Table 9. 
Table 9: USB Device classes 
USB device class information can be stored in a number of different places within the descriptors 
provided during enumeration. The information is provided in three-byte entries: 
bDeviceClass – the high level device class (e.g. mass storage) 
bDeviceSubClass – specific information about this device (e.g. SCSI command set) 
bDeviceProtocol – the protocol used (e.g. bulk transport (BBB)) 
Taking the mass storage class as an example, the following are the available sub-classes: 
De facto use 
RPC 
MMC-5 (ATAPI) 
Base Class  
Descriptor Usage  
Description  
0x00  
Device  
Use class information in the Interface Descriptors  
0x01  
Interface  
Audio    
0x02  
Both  
CDC (Communication and Device Control)  
0x03  
Interface  
HID (Human Interface Device)  
0x05  
Interface  
Physical  
0x06  
Interface  
Image  
0x07  
Interface  
Printer  
0x08  
Interface  
Mass Storage  
0x09  
Device  
Hub  
0x0a  
Interface  
CDC-Data  
0x0b  
Interface  
Smart Card  
0x0d  
Interface  
Content Security  
0x0e  
Interface  
Video  
0x0f  
Interface  
Personal Healthcare  
0x10  
Interface  
Audio/Video Devices  
0xdc  
Both  
Diagnostic Device  
0xe0  
Interface  
Wireless Controller  
0xef  
Both  
Miscellaneous  
0xfe  
Interface  
Application Specific 
NCC Group | Page 11 
© Copyright 2013 NCC Group 
QIC-157 
UFI 
SFF-8070i 
SCSI 
LSD FS 
IEE 1667 
Vendor specific 
For each of these mass storage sub-classes there are also a number of possible protocols: 
CBI with command completion interrupt 
CBI without command completion interrupt 
BBB 
UAS 
Vendor specific 
So, as you can see, the potential attack surface of a USB host is enormous; but it is important to 
establish which functionality is supported prior to any active fuzz testing.  
Some devices, such as the hub in Table 10, store their class information in the device descriptor. 
Table 10: Hub class information in a Device descriptor 
However, more commonly, the class information is interface specific and is therefore stored in the 
interface descriptor (within a configuration descriptor), as with the image class device in Table 11. 
Table 11: Image class information in an Interface descriptor 
Field 
Value 
Meaning 
bLength 
18 
Descriptor length (including the bLength field) 
bDescriptorType 
1 
Device descriptor 
bcdUSB 
0x0200 
Spec version 
bDeviceClass 
0x09 
Hub 
bDeviceSubClass 
0x00 
Full Speed Hub 
bDeviceProtocol 
0x01 
Default 
… 
Field 
Value 
Meaning 
bLength 
9 
Descriptor length (including the bLength field) 
bDescriptorType 
4 
Interface descriptor 
bInterfaceNumber 
0 
Number of this interface 
bAlternateSetting 
0 
Value used to select this alternative setting for the 
interface identified in the prior field 
bNumberEndpoints 
3 
Number of endpoints used by this interface 
bDeviceClass 
0x06 
Image 
bDeviceSubClass 
0x01 
Default 
bDeviceProtocol 
0x01 
Default 
… 
NCC Group | Page 12 
© Copyright 2013 NCC Group 
When emulating specific device types, whether the class information is provided to the host in the 
device descriptor or in an interface descriptor depends on the device.  
6.2 Enumerating Installed Class Drivers 
To identify which device classes are supported by a USB host, emulated (class-specific) virtual 
devices need to be presented to the host iterating through each device class, sub-class, and protocol 
whilst monitoring the enumeration process. If a device is not supported then the enumeration phase 
will stop at the “Set Configuration” command, as shown in Figure 2. 
Figure 2: Enumeration stops at “Set Configuration” when a device class is not supported 
However, if the device is supported then class-specific communication starts after the “Set 
Configuration” command, as can be seen in the example of a HID device in Figure 3 (the class-
specific communication is highlighted by the green box). 
Figure 3: Enumeration continues past “Set Configuration” when a device class is supported 
Device class drivers are also referenced by their vendor ID (VID) and product ID (PID). If a specific 
device driver has been installed for a USB device then the host can reference this driver by using a 
combination of the class information, the VID and the PID, which are located in the device descriptor, 
as shown in Table 12. 
NCC Group | Page 13 
© Copyright 2013 NCC Group 
Table 12: VID and PID information in a Device descriptor 
New VID and PID values must be registered with the USB Implementers Forum [USBIF] and are 
maintained in a number of public repositories. This information can be used to perform a brute-force 
attack against the host to identify any specific drivers that have been installed; however, this can be 
a very slow process. 
6.3 Other Devices Already Connected 
When testing a host that may have other devices, such as an HSPA modem, connected internally to 
the USB bus, these can be detected by sniffing the USB bus and looking for devices that are 
communicating using different addresses than that of the attached device, as shown in Figure 4. 
Figure 4: A Packet-master capture showing multiple USB devices connected to the same bus 
One area of future research is to investigate if, using the Facedancer board to emulate the host to 
which it is connected, descriptor requests could be sent to these other devices to identify more 
information about them. Also, what happens if the Facedancer is configured to impersonate an 
already-connected device? 
Field 
Value 
Meaning 
bLength 
18 
Descriptor length (including the bLength field) 
bDescriptorType 
1 
Device descriptor 
bcdUSB 
0x0110 
Spec version 
bDeviceClass 
0x00 
Class information stored in Interface descriptor 
bDeviceSubClass 
0x00 
Class information stored in Interface descriptor 
bDeviceProtocol 
0x00 
Class information stored in Interface descriptor 
bMaxPacketSize0 
8 
Max EP0 packet size 
idVendor 
0x04DA 
Panasonic Corporation 
idProduct 
0x2372 
Lumix DMC-FZ10 Camera 
NCC Group | Page 14 
© Copyright 2013 NCC Group 
7 Fingerprinting Techniques 
One of the targets of this research was to identify operating system and application information by 
observing USB stack interactions and sometimes using active techniques to prompt the host to 
perform different actions that may reveal useful information. This section will detail some of the 
techniques that were developed to do this. 
7.1 Operating System Identification 
Figures 5 and 6 show the start of class-specific communication once the enumeration phase has 
been completed for two different hosts. As you can clearly see, the class-specific commands used 
and the order in which the commands are issued are completely different for the two hosts and this 
technique can therefore be used to differentiate between different operating systems. 
Note: The commands and the order of commands are the same each time a device is presented to 
the hosts  
     Figure 5: Linux-based TV Set-Top-Box                                   Figure 6: Windows 8 
Other examples of unique behaviour of different operating systems: 
Windows 8 (HID) – Three “Get Configuration descriptor” requests (others have two) 
Apple OS X Lion (HID) – “Set Feature” request right after “Set Configuration” 
FreeBSD 5.3 (HID) – “Get Status” request right before “Set Configuration” 
Further research in this area is expected to reveal techniques that will allow for more granular 
identification to be performed. 
7.2 Application Identification 
Applications that use USB devices to provide input (e.g. photo management applications) can also 
reveal useful information, as shown in Figures 7 and 8. 
NCC Group | Page 15 
© Copyright 2013 NCC Group 
   Figure 7: gphoto2 (Linux)                                                            Figure 8: “Photos” Metro app (Windows 8) 
Figures 7 and 8 not only show that these two applications use different class-specific commands but 
the “Device Property” command sent by the host in Figure 8 contains the following data: 
/Windows/6.2.9200 MTPClassDriver/6.2.9200.16384 
This is specific information about the version of the operating system running on the host (Version 
6.2 is the Microsoft internal representation for Windows 8 and 9200.16384 is the exact build revision). 
7.3 Timing Information 
The Packet-master analyser can differentiate between events occurring on the USB bus down to the 
microsecond. Figure 9 shows the capture information for five enumerations with the same device 
and same host. 
NCC Group | Page 16 
© Copyright 2013 NCC Group 
Figure 9: USB timing information during enumeration 
Across the entire enumeration phase there is a large amount of variance between the times to 
enumerate the device. However, if the time is measured between specific requests e.g. between the 
requests for String descriptor 0 and String descriptor 2, something more interesting can be seen: 
5002us, 5003us, 5003us, 4999us, 5001us 
There is a maximum variance of 4 microseconds. Therefore, if the operating system is known can 
information be gleaned about the speed of the host? This hypothesis is still under investigation. 
7.4 Descriptor Types Requested 
Some operating systems have implemented their own USB descriptors —for example Microsoft has 
Microsoft OS descriptors (MODs). These were apparently developed for use with unusual device 
classes. Devices that support Microsoft OS descriptors must store a special string descriptor in 
firmware at the fixed string index of 0xee. The request is shown in Table 13. 
Table 13: Microsoft OS descriptor request 
bmRequestType 
bRequest 
wValue 
wIndex 
wLength 
Data 
10000000B 
GET_DESCRIPTOR 
0x03ee 
0x0000 
0x12 
Returned 
String 
NCC Group | Page 17 
© Copyright 2013 NCC Group 
If a device does not contain a valid string descriptor at index 0xee, it must respond with a stall packet. 
If the device does not respond with a stall packet, the system will issue a single-ended zero reset 
packet to the device, to help it recover from its stalled state (this is for Windows XP only). 
7.5 Responses to Invalid Data 
Earlier in the paper we mentioned that the ability to send completely arbitrary USB packets to the 
host was required to determine how each host responds when a reply to one of its requests contains 
invalid data. Examples of invalid data include: 
• 
Maximum and minimum values 
• 
Logically incorrect values 
• 
Missing data 
During the research, various behaviours were observed as a result of sending this data. In some 
cases different “handled” error conditions occurred; however in many other situations unhandled 
errors were observed in the form of application errors, kernel panics and bug checks. The 
conclusions drawn from this area of the research were that invalid data was most useful in fuzzer 
test-cases for identifying bugs and potential security vulnerabilities.  
8 Umap 
A tool was developed to demonstrate many of the techniques described in this paper and forms the 
basis for a comprehensive USB security testing tool. Umap is written in Python and builds on the 
sample code provided with the Facedancer board. Figure 10 shows the basic help information. 
 Figure 10: Umap basic help 
Figure 11 shows the various USB device class types that umap currently understands. 
NCC Group | Page 18 
© Copyright 2013 NCC Group 
Figure 11: The USB device classes that umap currently understands 
Figure 12 shows umap identifying supported classes, sub-classes, and protocols  
Figure 12: Umap identifying supported classes, sub-classes and protocols 
NCC Group | Page 19 
© Copyright 2013 NCC Group 
Figure 13 shows the umap VID/PID lookup capability. 
Figure 13: The umap VID/PID lookup facility 
Figure 14 shows umap performing operating system identification using some of the techniques 
described earlier in this paper. 
Figure 14: The umap operating system identification capability 
NCC Group | Page 20 
© Copyright 2013 NCC Group 
Figure 15 shows umap emulating an image class device (a digital stills camera). 
Figure 15: Umap emulating a USB camera 
Umap includes a large database of both generic and class-specific fuzzer test-cases, samples of 
which are shown in Figures 16 and 17. 
NCC Group | Page 21 
© Copyright 2013 NCC Group 
Figure 16: Generic USB fuzz test cases 
Figure 17: Class-specific USB fuzz test cases 
NCC Group | Page 22 
© Copyright 2013 NCC Group 
Figure 18 shows umap fuzzing a USB host. 
Figure 18: Umap fuzzing a USB host 
NCC Group | Page 23 
© Copyright 2013 NCC Group 
9 Conclusions 
The goal of this research was to identify ways of revealing configuration information about a 
connected USB host. This is useful because it allows us to streamline any subsequent fuzzing 
process by identifying supported USB functionality, and to enumerate operating system and 
application information that may be useful for other security testing. The major problem with trying to 
identify information about the configuration of the host is that USB is a master–slave relationship and 
the device is the slave, so a device cannot query a host. 
By emulating specific USB device classes such as mass storage and printer, it was possible to 
identify which generic class drivers were supported by the connected host. This process was refined 
to also emulate (and therefore identify) supported sub-classes and protocols. In order to identify non-
generic class drivers, which are referenced by their vendor and product IDs, a brute force approach 
was demonstrated which uses the public VID/PID database.  
Due to the complexity of the USB protocol there are many different implementations of USB host 
functionality. A number of different techniques were developed to identify a host; these included 
analysing: 
The order of descriptor requests 
The number of times different descriptors were requested 
The use of specific USB commands 
Class-specific communication 
These techniques demonstrated that the host operating system, and in some cases applications 
running on the host, could be identified.  
A tool called umap was developed during the research to demonstrate these different techniques 
and also to perform targeted fuzzing once the information-gathering phase was complete. Possible 
uses for umap include Endpoint Protection System configuration assessment, USB host fuzzing and 
general host security audit (for USB). 
NCC Group | Page 24 
© Copyright 2013 NCC Group 
10 References and Further Reading 
Davis, Undermining Security Barriers, media.blackhat.com, , accessed 6 August 2013  
Dominguez Vega, USB Attacks: Fun with Plug and 0wn, labs.mwrinfosecurity.com, 
, 
accessed 6 August 2013  
GoodFET, GoodFET – Facedancer21, goodfet.sourceforge.net, 
, accessed 6 August 2013  
Goodspeed, Writing a thumbdrive from scratch: Prototyping active disk antiforensics, 
www.youtube.com, , accessed 6 August 2013  
Larimer, Beyond Autorun: Exploiting vulnerabilities with removable storage, media.blackhat.com, 
, accessed 6 August 2013  
MOD, Microsoft OS Descriptors, msdn.microsoft.com, , accessed 6 August 2013  
MQP, Packet-Master USB500 AG, www.mqp.com, , accessed 6 
August 2013  
USBIF, USB Implementers Forum, www.usb.org, , accessed 6 August 
2013  
11 Glossary 
ATAPI - AT Attachment Packet Interface 
BBB - Bulk-only transport (also called BOT) 
CBI - Control/Bulk/Interrupt 
CDC - Communication and Device Control 
eHCI - Enhanced Host Controller Interface 
HID - Human Interface Device 
HSPA - High Speed Packet Access 
IEE 1667 .Protocol for Authentication in Host Attachments of Transient Storage Devices 
LSD FS - Lockable Storage Devices Feature Specification 
MOD - Microsoft OS descriptor 
oHCI - Open Host Controller Interface 
PID - Product ID 
QIC-157 Quarter Inch Cartridge (standard for streaming tape) 
RPC - Remote Procedure Call 
SCSI - Small Computer System Interface 
SFF-8070i  - ATAPI specification for floppy disks 
UAS - USB Attached SCSI 
UFI  - USB Floppy Interface 
uHCI  - Universal Host Controller Interface 
USBIF - Universal Serial Bus Implementers Forum 
USB . Universal Serial Bus 
VID . Vendor ID 
xHCI - Extensible Host Controller Interface