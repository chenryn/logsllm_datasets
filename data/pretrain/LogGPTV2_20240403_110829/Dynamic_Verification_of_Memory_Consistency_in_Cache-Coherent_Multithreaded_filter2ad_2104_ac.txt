### 优化后的文本

这些优化在TSO（Total Store Order）中是不合法的。在我们的实验中，TSO隐式采用的“最老存储优先”策略与更复杂的策略相比表现良好。非推测性负载重排序的价值也相对较小，因为负载顺序误预测非常罕见，影响不到0.1%的负载。尽管优化带来的好处有限，但放宽一致性模型需要遵守内存屏障，即使高效实现，也可能导致性能低于TSO。

虽然大多数基准测试显示了写缓冲区的预期收益和验证机制的预期开销，但某些slash结果却出乎意料。高度竞争的锁使slash对写访问时间的变化非常敏感，如运行时间的高方差所示，而SC [22]中的额外停顿减少了竞争，从而带来了性能提升。

#### 7.2.2 DVMC 性能开销
DVMC 可能通过多种方式降低性能。单处理器顺序检查器需要一个额外的流水线阶段，从而延长指令在飞行中的时间，并增加ROB（Reorder Buffer）和物理寄存器的占用率。负载重放增加了缓存的需求，可能导致更多的缓存未命中。一致性验证由于用于信息消息的互连带宽使用，可能会降低系统性能。SafetyNet（我们在测试中使用的BER机制）也会增加互连流量。只有允许的重排序检查器不会对程序执行产生任何影响，因为它不在关键路径上工作。

首先，我们研究所有这些因素的总影响。我们在一个未受保护的基础系统和一个实现了完整DVMC及SafetyNet BER的系统上运行基准测试。基准测试涵盖了四种支持的一致性模型和两种一致性系统（目录和窥探）。图3和图4显示了所有基准测试的运行时间，以一个未受保护的SC系统为基准。尽管存在上述各种性能风险，我们观察到的最大减速不超过11%。最严重的减速发生在SC中，这在现代系统中很少见。在40种DVMC配置中，只有4种配置的开销超过6%。由于目录系统的性能开销更大，且TSO、PSO和RMO的性能开销相似，本节余下部分将重点讨论基于目录系统的TSO。

为了研究不同DVMC组件的影响，我们使用只实现SafetyNet BER的系统（SN）、实现SafetyNet和一致性验证的系统（SN+DVCC）、实现SafetyNet和单处理器顺序验证的系统（SN+DVUO），以及实现完整DVMC和SafetyNet的系统（DVTSO）进行了相同的实验。对于实现TSO和目录一致性的系统，实验结果如图5所示。这些实验表明，单处理器顺序验证是减速的主要原因，尽管每种机制（SafetyNet、单处理器顺序验证和一致性验证）在大多数情况下都会增加少量开销，但完整的DVTSO并不比SN+DVUO慢。

图5还显示，在添加SafetyNet时，slash出现了意外的速度提升。对于slash，SafetyNet稍微延迟了一些写操作，这可以减少锁竞争并提高性能。

图6显示了重放期间L1缓存未命中的数量，相对于正常执行期间L1缓存未命中的数量进行了归一化。重放未命中很少发生，因为从负载执行到验证的时间通常很短。大多数重放缓存未命中发生在处理器未能成功获取锁并返回自旋循环时。因此，这种未命中对实际性能影响很小。

DVMC可以通过两种方式增加互连网络利用率：Cache Coherence检查器消耗信息消息的带宽，负载重放可能引发额外的一致性事务。对于具有TSO的目录系统，图7显示了不同工作负载和机制下最高负载链路的平均带宽。DVCC始终增加了约20-30%的流量开销，而负载重放没有显著影响。

#### 7.3 硬件成本
DVMC的硬件成本由实现三个检查器所需的存储结构和逻辑组件决定，但不包括BER机制，后者是正交的。关于SafetyNet [26]、ReVive [21]和其他BER方案的实现成本的信息可以在文献中找到。单处理器顺序检查器是最复杂的检查器，因为它需要添加VC并在处理器流水线中添加一个新阶段。这些更改是非平凡的，但所需的所有逻辑组件都很简单，存储结构也很小（32-256字节）。允许的重排序检查器是最简单和最小的检查器。它需要一个LSQ大小的FIFO、一组序列号寄存器、写缓冲区中的序列号、排序表和用于检查器逻辑的比较器。Cache Coherence检查器也不需要复杂的逻辑，但它会带来更大的存储成本。我们的CET条目是34位，每个节点的总CET大小约为70 KB。MET每个内存控制器需要102 KB，条目大小为48位，但它对延迟不敏感，可以用廉价的长延迟DRAM构建。MET包含当前至少在一个处理器缓存中存在的块的条目。仅存在于内存中的块的条目在缓存请求时根据当前逻辑时间和内存值构造。为了检测这些块上的数据错误，DVMC要求所有主存DRAM都使用ECC。

### 相关工作
在本节中，我们讨论了动态验证领域的先前研究。对于单线程执行的验证，有两种不同的方法。首先，DIVA [3]添加了一个小型简单的检查核心，用于验证微处理器提交的指令。通过利用微处理器作为预言性预取器和分支预测器，简单的检查器可以跟上微处理器的性能。其次，有多线程单处理器的几种方案，从AR-SMT [23]开始，使用冗余线程来检测错误。这些方案利用现有的多个线程上下文来实现错误检测。与DVMC不同，这些方案都不扩展到内存系统或多个线程。

对于共享内存的多线程系统，有四项相关工作。Sorin等人 [25] 为窥探多处理器开发了一种动态验证部分缓存一致性的方案。尽管动态验证这些不变量是有帮助的，但它不是一个端到端的机制，因为一致性不足以实现一致性。Cantin等人 [6] 提议通过简化的一致性协议重放事务来验证缓存一致性。Cain等人 [4] 描述了一种验证顺序一致性的算法，但没有提供实现。最后，我们之前 [16] 设计了一种用于动态验证顺序一致性的临时方案，该方案不能扩展到其他一致性模型。

### 结论
本文提出了一种可以动态验证广泛一致性模型并全面检测内存系统错误的框架。我们的验证框架是模块化的，因为它检查三个独立的不变量，这些不变量共同保证了内存一致性。模块化设计使得可以用不同的方案替换任何检查机制，以适应特定系统的设计。例如，[16] 中的DVSC一致性检查器可以被Cantin等人 [6] 提出的设计所取代。尽管我们使用常规多处理器系统作为示例实现，但该框架并不限于这些类型的架构。所提出的机制的简单性表明，它们可以通过对现有多线程系统的少量修改来实现。

尽管DVMC实现的模拟显示出一些性能下降，但我们预计这种负面影响会被端到端检测内存系统错误的好处所抵消。

### 致谢
本研究得到了美国国家科学基金会（CCF-0444516和CCR-0309164）、美国国家航空航天局（NNG04GQ06G）、英特尔公司和沃伦教员奖学金的部分支持。感谢Jeff Chase、Carla Ellis、Mark Hill、Alvin Lebeck、Anita Lungu、Milo Martin、Jaidev Patwardhan和杜克大学架构组对本工作的评论。

### 参考文献
[此处省略具体参考文献列表，保持原格式]

---

希望这段优化后的文本更加清晰、连贯和专业。如果有进一步的修改需求，请告诉我！