they allow additional optimizations that are not legal for
TSO. In our experiments, the oldest store ﬁrst strategy
Proceedings of the 2006 International Conference on Dependable Systems and Networks (DSN’06) 
0-7695-2607-1/06 $20.00 © 2006 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 12:31:09 UTC from IEEE Xplore.  Restrictions apply. 
e
m
i
t
n
u
R
d
e
z
i
l
a
m
r
o
N
1.0
0.5
0.0
Base TSO  
SafetyNet 
SN+DVUO   
SN+DVCC   
DVTSO
s
s
i
M
e
h
c
a
C
1
L
r
e
p
s
e
s
s
i
M
y
a
l
p
e
R
f
o
r
e
b
m
u
N
0.06
0.04
0.02
0.00
DVSC   
DVTSO  
DVPSO  
DVRMO 
apache
oltp
jbb
slash
barnes
Figure 5. Veriﬁcation mechanism runtimes
implicitly used by TSO performs well compared to
more complicated policies. Non-speculative reordering
of loads also turns out to be of little value, because load-
order mis-speculation is exceedingly rare, affecting less
than 0.1% of loads. Whereas the beneﬁts from optimiza-
tions are limited, relaxed consistency models need to
obey memory barriers which, even when implemented
efﬁciently, can make performance worse than TSO.
Although most benchmarks show the expected bene-
ﬁts of a write buffer and the expected overhead incurred
by veriﬁcation, some of the slash results are counter-
intuitive. Highly contended locks make slash sensitive
to changes in write access timing, as indicated by high
variance in run time, and it beneﬁts from reduced con-
tention caused by additional stalls present in SC [22].
7.2.2.  DVMC Performance Overhead. DVMC
can
potentially degrade performance in several ways. The
Uniprocessor Ordering checker requires an additional
pipeline stage, thus extending the time during which
instructions are in-ﬂight and increasing the occupancy
of the ROB and the physical registers. Load replay
increases the demand on the cache and can cause addi-
tional cache misses. Coherence veriﬁcation can degrade
system performance due to interconnect bandwidth
usage for inform messages. SafetyNet, the BER mecha-
nism used during our tests, also causes additional inter-
connect trafﬁc. Only the Allowable Reordering checker
does not have any inﬂuence on program execution, since
it operates off the critical path.
First we examine the total impact of all these factors.
We run the benchmarks on an unprotected baseline sys-
tem and a system implementing full DVMC as well as
SafetyNet BER. The benchmarks are run for all four
supported consistency models and both the directory
and snooping coherence systems. Figure 3 and Figure 4
show the running times of all benchmarks normalized to
an unprotected system implementing SC. Despite the
numerous performance hazards described, we observed
no slowdown exceeding 11%. The worst slowdowns
occur with SC, which is rarely implemented in modern
apache
barnes
Figure 6. Cache misses during replay
slash
oltp
jbb
systems. In all but 4 out of 40 DVMC conﬁgurations,
the overhead is limited to 6%. Because the performance
overheads are greater with the directory system and sim-
ilar for TSO, PSO, and RMO, the rest of this section
focuses on a directory-based system with TSO.
only
cache
veriﬁes
To study the impact of the different DVMC compo-
nents, we run the same experiments with a system that
only implements BER using SafetyNet (SN), a system
with BER that
coherence
(SN+DVCC), a system with BER and uniprocessor
ordering veriﬁcation (SN+DVUO), and full DVMC with
BER (DVTSO). The results of these experiments for a
system implementing TSO and directory coherence are
shown in Figure 5. These experiments show that Uni-
processor Ordering Veriﬁcation is the dominant cause of
slow-down and, although each mechanism—SafetyNet,
Uniprocessor Ordering Veriﬁcation, and Coherence Ver-
iﬁcation—adds a small amount of overhead in most
cases, full DVTSO is no slower than SN+DVUO.
Figure 5 also shows some unexpected speedups on slash
when SafetyNet is added. With slash, SafetyNet slightly
delays some writes, which can reduce lock contention
and lead to a performance increase.
Figure 6 shows the number of L1 cache misses dur-
ing replay normalized to the number of L1 cache misses
during regular execution. Replay misses are rare,
because the time between a load’s execution and veriﬁ-
cation is typically small. Most replay cache misses
occur when a processor unsuccessfully tries to acquire a
lock and returns to the spin loop. Thus, the miss has lit-
tle impact on actual performance.
DVMC can increase interconnection network utili-
zation in two ways: the Cache Coherence checker con-
sumes bandwidth for inform messages, and load replays
can initiate additional coherence transactions. For the
directory system with TSO, Figure 7 shows the mean
bandwidth on the highest loaded link for different work-
loads and mechanisms. DVCC imposes a consistent
trafﬁc overhead of about 20-30%, and load replay does
not have any measurable impact.
Proceedings of the 2006 International Conference on Dependable Systems and Networks (DSN’06) 
0-7695-2607-1/06 $20.00 © 2006 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 12:31:09 UTC from IEEE Xplore.  Restrictions apply. 
s
/
B
G
h
t
d
i
w
d
n
a
B
k
n
i
L
m
u
m
i
x
a
M
1.5
1.0
0.5
0.0
Base TSO  
SafetyNet 
SN+DVUO  
SN+DVCC  
DVTSO     
apache
oltp
jbb
slash
barnes
Figure 7. Interconnect trafﬁc
7.3.  Hardware Cost
The hardware costs of DVMC are determined by the
storage structures and logic components required to
implement the three checkers, but not the BER mecha-
nism, which is orthogonal. Information on the imple-
mentation cost of SafetyNet [26], ReVive [21] and other
BER schemes can be found in the literature. The Uni-
processor Ordering checker
is the most complex
checker, since it requires the addition of the VC and a
new stage in the processor pipeline. These changes are
non-trivial, but all required logic components are simple
and storage structures are small (32-256 byte). The
Allowable Reordering checker is the simplest and small-
est checker. It requires a LSQ-sized FIFO, a set of
sequence number registers, sequence numbers in the
write buffer, the ordering tables, and comparators for the
checker logic. The Cache Coherence checker also does
not require complex logic, but it incurs greater storage
costs. Our CET entries are 34 bits, leading to a total
CET size of about 70 KB per node. The MET requires
102 KB per memory controller, with an entry size of 48
bits, but it is not latency sensitive and can be built out of
cheap, long-latency DRAMs. The MET contains entries
for blocks that are currently present in at least one pro-
cessor cache. Entries for blocks only present at memory
are constructed from the current logical time and mem-
ory value upon a cache request. To detect data errors on
these blocks, DVMC requires ECC on all main memory
DRAMs.
8.  Related Work
In this section, we discuss prior research in dynamic
veriﬁcation. For verifying the execution of a single
thread, there have been two different approaches. First,
DIVA adds a small, simple checker core that veriﬁes the
execution of the instructions committed by the micro-
processor [3]. By leveraging the microprocessor as an
oracular prefetcher and branch predictor, the simple
checker can keep up with the performance of the micro-
processor. Second, there have been several schemes for
multithreaded uniprocessors, starting with AR-SMT
[23], that use redundant threads to detect errors. These
schemes leverage the multiple existing thread contexts
to achieve error detection. Unlike DVMC, none of these
schemes extend to the memory system or to multiple
threads.
For multithreaded systems with shared memory,
there are four related pieces of work. Sorin et al. [25]
developed a scheme for dynamic veriﬁcation of a subset
of cache coherence in snooping multiprocessors.
Although dynamically verifying these invariants is help-
ful, it is not an end-to-end mechanism, since coherence
is not sufﬁcient for implementing consistency. Cantin et
al. [6] propose to verify cache coherence by replaying
transactions with a simpliﬁed coherence protocol. Cain
et al. [4] describe an algorithm to verify sequential con-
sistency, but do not provide an implementation. Finally,
we previously [16] designed an ad-hoc scheme for
dynamic veriﬁcation of sequential consistency, which
does not extend to any other consistency models.
9.  Conclusions
This paper presents a framework that can dynami-
cally verify a wide range of consistency models and
comprehensively detect memory system errors. Our ver-
iﬁcation framework is modular, because it checks three
independent invariants that together are sufﬁcient to
guarantee memory consistency. The modular design
makes it possible to replace any of our checking mecha-
nisms with a different scheme to adapt to a speciﬁc sys-
tem’s design. For example,
the coherence checker
adapted from DVSC [16] can be replaced by the design
proposed by Cantin et al. [6]. Although we used conven-
tional multiprocessor systems as example implementa-
tions, the framework is in no way limited to these types
of architectures. The simplicity of the proposed mecha-
nisms suggests that they can be implemented with small
modiﬁcations
systems.
Although simulation of a DVMC implementation shows
some decrease in performance, we expect the negative
impact to be outweighed by the beneﬁt of an end-to-end
scheme for detecting memory system errors.
existing multithreaded
to
Proceedings of the 2006 International Conference on Dependable Systems and Networks (DSN’06) 
0-7695-2607-1/06 $20.00 © 2006 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 12:31:09 UTC from IEEE Xplore.  Restrictions apply. 
Acknowledgments
This work is supported in part by the National Sci-
ence Foundation under grants CCF-0444516 and CCR-
0309164, the National Aeronautics and Space Adminis-
tration under grant NNG04GQ06G, Intel Corporation,
and a Warren Faculty Scholarship. We thank Jeff Chase,
Carla Ellis, Mark Hill, Alvin Lebeck, Anita Lungu,
Milo Martin, Jaidev Patwardhan, and the Duke Archi-
tecture Group for their comments on this work.
References
[1] S. V. Adve and K. Gharachorloo. Shared Memory
IEEE Computer,
Consistency Models: A Tutorial.
29(12):66–76, Dec. 1996.
[2] A. R. Alameldeen et al. Simulating a $2M Commercial
Server on a $2K PC. IEEE Computer, 36(2):50–57, Feb.
2003.
[3] T. M. Austin. DIVA: A Reliable Substrate for Deep
Submicron Microarchitecture Design. In Proc. of the
32nd
Symposium on
Microarchitecture, pages 196–207, Nov. 1999.
IEEE/ACM Int’l
Annual
[4] H. W. Cain and M. H. Lipasti. Verifying Sequential
Consistency Using Vector Clocks.
in
conjunction with Symposium on Parallel Algorithms and
Architectures, Aug. 2002.
In Revue
[5] H. W. Cain and M. H. Lipasti. Memory Ordering: A
Value-Based Approach. In Proc. of the 31st Annual Int’l
Symposium on Computer Architecture, June 2004.
J. F. Cantin, M. H. Lipasti, and J. E. Smith. Dynamic
Verification of Cache Coherence Protocols. In Workshop
on Memory Performance Issues, June 2001.
[6]
[7] S. Chatterjee, C. Weaver,
and T. Austin. Efficient
Checker Processor Design. In Proc. of the 33rd Annual
IEEE/ACM Int’l Symposium on Microarchitecture, pages
87–97, Dec. 2000.
[8] K. Gharachorloo, A. Gupta,
and J. Hennessy. Two
Techniques to Enhance the Performance of Memory
Consistency Models. In Proc. of
the Int’l Conf. on
Parallel Processing, vol. I, pages 355–364, Aug. 1991.
[9] K. Gharachorloo et al. Memory Consistency and Event
Ordering in Scalable Shared-Memory. In Proc. of the
17th Annual Int’l Symposium on Computer Architecture,
pages 15–26, May 1990.
[10] P. B. Gibbons and E. Korach. Testing Shared Memories.
SIAM Journal on Computing, 26(4):1208–1244, Aug.
1997.
[11] M. D. Hill
et
al. A System-Level Specification
Framework for I/O Architectures. In Proc. of the Eleventh
ACM Symposium on Parallel Algorithms
and
Architectures, pages 138–147, June 1999.
[12] L. Lamport. How to Make a Multiprocessor Computer
that Correctly Executes Multiprocess Programs. IEEE
Trans. on Computers, C-28(9):690–691, Sept. 1979.
[13] P. S. Magnusson et al. Simics: A Full System Simulation
Platform. IEEE Computer, 35(2):50–58, Feb. 2002.
[14] M. M. Martin et al. Multifacet’s General Execution-
(GEMS) Toolset.
driven Multiprocessor Simulator
Computer Architecture News, 33(4):92–99, Sept. 2005.
[15] C. J. Mauer, M. D. Hill, and D. A. Wood. Full System
Timing-First Simulation. In Proc. of
the 2002 ACM
Sigmetrics Conference on Measurement and Modeling of
Computer Systems, pages 108–116, June 2002.
[16] A. Meixner and D. J. Sorin. Dynamic Verification of
Sequential Consistency. In Proc. of the 32nd Annual Int’l
Symposium on Computer Architecture, pages 482–493,
June 2005.
[17] A. Meixner and D. J. Sorin. Dynamic Verification of
Memory Consistency in Cache-Coherent Multithreaded
Computer Architectures. Tech. Report 2006-1, Dept. of
Elec. and Comp. Engr., Duke Univ., Mar. 2006.
[18] M. Plakal et al. Lamport Clocks: Verifying a Directory
Cache-Coherence Protocol. In Proc. of the Tenth ACM
Symposium on Parallel Algorithms and Architectures,
pages 67–76, June 1998.
[19] F. Pong and M. Dubois. Verification Techniques for
Cache Coherence Protocols. ACM Computing Surveys,
29(1):82–126, Mar. 1997.
[20] F. Pong and M. Dubois. Formal Automatic Verification
of Cache Coherence in Multiprocessors with Relaxed
Memory Models.
IEEE Trans. on Parallel and
Distributed Systems, 11(9):989–1006, Sept. 2000.
[21] M. Prvulovic, Z. Zhang, and J. Torrellas. ReVive: Cost-
Effective Architectural Support for Rollback Recovery in
Shared-Memory Multiprocessors. In Proc. of the 29th
Annual Int’l Symposium on Computer Architecture, pages
111–122, May 2002.
[22] R. Rajwar, A. Kägi, and J. R. Goodman. Improving the
Throughput of Synchronization by Insertion of Delays. In
Proc. of the Sixth IEEE Symposium on High-Performance
Computer Architecture, pages 168–179, Jan. 2000.
[23] E. Rotenberg. AR-SMT: A Microarchitectural Approach
to Fault Tolerance in Microprocessors. In Proc. of the
29th Int’l Symposium on Fault-Tolerant Computing
Systems, pages 84–91, June 1999.
[24] J. H. Saltzer, D. P. Reed, and D. D. Clark. End-to-End
Arguments in Systems Design. ACM Trans. on Computer
Systems, 2(4):277–288, Nov. 1984.
[25] D. J. Sorin, M. D. Hill, and D. A. Wood. Dynamic
Verification of System-Wide Multiprocessor Invariants.
In Proc. of the Int’l Conference on Dependable Systems
and Networks, pages 281–290, June 2003.
[26] D. J. Sorin et al. SafetyNet: Improving the Availability of
Shared Memory Multiprocessors with Global
Checkpoint/Recovery. In Proc. of the 29th Annual Int’l
Symposium on Computer Architecture, pages 123–134,
May 2002.
Issue
on
an
Implementable
[27] D. M. Tullsen et al. Exploiting Choice: Instruction Fetch
and
Simultaneous
Multithreading Processor. In Proc. of the 23rd Annual
Int’l Symposium on Computer Architecture, pages 191–
202, May 1996.
[28] D. L. Weaver
SPARC
Architecture Manual (Version 9). PTR Prentice Hall,
1994.
and T. Germond,
editors.
Proceedings of the 2006 International Conference on Dependable Systems and Networks (DSN’06) 
0-7695-2607-1/06 $20.00 © 2006 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 12:31:09 UTC from IEEE Xplore.  Restrictions apply.