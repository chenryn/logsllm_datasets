j is a tree, with element nodes
as intermediary nodes, and content and attribute nodes as
leaves. The corresponding ciphertext document is created
by replacing a subtree (i. e. an element together with its
contents) with a ciphertext element.
3.2 Security Model
The goal of an adversary is to learn the plaintext content
of a ciphertext element of some ct
j. Several security models
can be used to deﬁne the security of SECRET. We analyze
SECRET in all three models in Section 9.
Honest-But-Curious Cloud Server. In this model, the
cloud provider is honestly providing storage services (it does
not forge it), but it is passively reading the stored data and
can forward this data (voluntarily or on court request) to
third parties. This is the standard security model for cloud
storage and for encrypted document editing and also con-
sidered in previous work (e. g., [37]).
Passive Man-In-The-Middle. In this model, the attacker
passively reads all network traﬃc, but does not perform any
active attacks like deleting or altering network packets. This
model could also be called “honest-but-curious network”.
Web Attacker Model. This model is the standard model
for proving security of web applications [3]. An adversary
in this model can access any open web application, learn
its client-side code, send emails and other messages, and
can set up their own (malicious) web application. The web
attacker is unable to forge web origins [2], because this would
undermine the security of any web application.
3.3 Obliviousness Model
In the obliviousness game, the adversary A can act as a
user and join a session σj. When he is added to this session,
he gets access to the key kj and the actual snapshot mt
j of the
document. The adversary breaks the obliviousness property
if he is able to compute a previous snapshot mt(cid:48)
j , t(cid:48)  element will be inserted as a replacement
of the plaintext at the exact same position in the document
tree. An alternative to XML Encryption is JSON Web En-
cryption (JWE) [20], where an encrypted JSON object is
again a JSON object using JWE JSON Serialization.
The advantage of using structured encryption in collabo-
rative editing is that encrypted parts of a document blend in
with the rest of the structure. This way, major portions of
the software do not have to take care whether an encrypted
or plain part is processed.
4.2 Tree-based Operational Transforms
The na¨ıve approach to implement OT on tree-structured
documents (e. g., JSON or XML based) is to serialize these
documents into a string and to synchronize this string among
all clients. Any time a modiﬁcation occurs, the modiﬁed tree
is serialized, and the resulting string is compared with the
serialization of the most recent snapshot of the document
tree. Any diﬀerences detected will be encoded as operations
and transmitted to the OT server.
Since the server does not know about the semantics of
the string, situations occur where the application of OT
would create unusable documents. Consider the JSON ob-
ject {"1":1}. Alice adds a property named "2" with the
value 2 and locally gets {"1":1,"2":2}. This is translated
to the edit operation INS(’,"2":2’, 6). At the same time,
Bob deletes the property 1 to get {}. This is translated to
the edit operation DEL(1, 5).
The server receives both edits and detects that the DEL-
command does not need to be transformed. The INS-com-
mand however has to be transformed to INS(’,"2":2’, 1)
before it is forwarded to Bob. In the end, both Alice and Bob
reach a consistent state, but the resulting string is {,"2":2}
which is no valid JSON document.
In consequence, OT for tree-structured data requires a
server implementation that is aware of the structure so that
it can keep it intact. With ShareJS 0.6 [14], a web applica-
tion library supporting OT on JSON documents is available.
4.3 Combining both primitives
For the purpose of implementing collaborative editing a
disadvantage of JWE becomes visible: JWE requires key,
metadata, and ciphertext to be part of the same data struc-
ture. This way, JSON documents containing multiple en-
crypted objects quickly grow in size which is what we would
like to avoid. With XML Encryption in contrast, most of
the metadata is optional and keys may be referenced and
reused. Therefore, we use XML Encryption to implement
SECRET.
Modern browsers provide rich support for XML, but do
not support XML Security out of the box. Especially, they
do not support XML Encryption. Therefore, we imple-
mented a JavaScript library that supplies the necessary logic
to create and process encrypted XML trees or parts thereof.
Even though the feature sets of XML and JSON are fun-
damentally diﬀerent, there is a conceptual layer at which
there are similarities between these two standards. Seen
from the perspective of an XML element, its children are an
ordered list of elements, like an array of objects in a JSON
object.
Its attributes in contrast are an unordered list of
key-value-pairs, much like named properties in a JSON ob-
ject. Text content is simply a string which is not diﬀerent
from the classic OT approach. The nesting of elements in
XML is not as ﬂexible as with JSON (e. g., attributes can-
not be nested) and using certain data types (e. g., numerical
literals) is not as intuitive as in the JSON case.
Our OT-compliant library for XML documents is an ex-
tension of those parts of ShareJS that were originally written
to support JSON objects. This way, we can reuse the com-
munication subsystem of ShareJS that uses WebSockets to
realize asynchronous messaging. Our extension takes advan-
tage of the common semantic layer outlined above to support
the following 7 basic operations on XML documents:
(1.) Insert a new element based on an XML string.
(2.) Delete an existing element.
(3.) Move an element among its siblings.
(4.) Insert text into a text node.
(5.) Delete text from a text node.
(6.) Set or overwrite an attribute.
(7.) Delete an attribute.
More problematic are XML features that JSON does not
provide like namespaces, comment nodes, and CDATA sec-
tions. From the perspective of the OT algorithm, we model
namespaces as special case of an element’s name. Comments
and CDATA sections are modeled as special elements that
have a diﬀerent string representation and no attributes, but
apart from that they can be manipulated like normal ele-
ments.
This design then allows us to apply XML Encryption
to an OT-synchronized XML document. Because of using
the structure-preserving property, the OT algorithm does
not need to care about whether an element is encrypted or
not – XML Encryption can be applied transparently. We
thus achieve our goal and have an approach that enables
OTs on (partly) encrypted documents.
5. RELATED WORK
The idea of Operational Transforms was originally in-
vented by Ellis and Gibbs in 1989 [11]. Based upon this
work, other publications reﬁned the idea to enable concur-
rent editing of plain text (cf. e. g. [28, 31, 33]). Real-time col-
laborative working has become famous with Google Wave,
which has been renamed to Apache Wave. It was announced
in 2009 by Google and allows multiple users to edit the same
document simultaneously. Although the Wave project was
stopped by Google, its idea and concept was integrated into
Google Docs. There are other real-time collaborative editing
web applications, like Microsoft Oﬃce Online and Etherpad.
In 2002, Davis et al. described OT on Standard General
Markup Language (SGML) documents [10], a predecessor of
XML. This work was later extended to support collaborative
editing of XML documents in centralized architectures with
manual conﬂict resolution [19, 29] as well as in peer-to-peer
environments [18].
The security property obliviousness was ﬁrst introduced
Its deﬁnition was later modiﬁed by
by Micciancio [26].
838Author
Feldman et al.
Clear et al.
[12]
[8]
Journal Yes
Journal Yes
D’Angelo et al.
[9] Document No
Adkinson-Orellana et al.
[1] Document No
Huang and Evans
[17] Document Yes
Zhang et al.
[37] Document Yes
Michalas and Bakopoulos [27] Document No
No
No
No
No
No
No
No
No
No
No1
No1
No1
No2
No1
Yes
Yes
Yes
No
No
No
No
No
Yes
Yes
No
Yes
Yes
No
No
Yes
Yes
No (Java-PlugIn)
Custom
No (Firefox Ext.+Java) Google
No (Firefox Ext.)
No (Firefox Ext.)
No (Firefox Ext.)
Google
Google
Google
No (Java Program)
Dropbox
No (Greasemonkey Ext.) Google
Yes
Custom
Src Approach OT Struct. OT Obliv RT Coll. Key Mgmt.
Vanilla Browser
Server
SECRET
Document Yes
Yes
Table 1: Comparison of related work on cloud based encrypted editing. SECRET fulﬁlls all requirements.
Buonanno et al. to apply it to incremental encryption
schemes [7, Sect. 2.5].
There are two approaches to realize collaborative editing
on encrypted documents in the literature (see Table 1):
Journaling Approach to Encrypted Collaboration.
The ﬁrst approach is to let each client encrypt every single
edit operation before it is sent to the server. The server then
only stores a long list of encrypted edit operations and pro-
vides it to the clients. We call this the journaling approach.
A client has to download this list before the document can be
displayed and used, which requires large storage and network
overhead [8, Section 4.2]. This problem can be alleviated by
coalescing edit operations on the list or by introducing snap-
shots of the document that can be used as starting point for
a new client. However, such computationally heavy cleanup
work has to be done by one of the clients since the server
cannot decrypt the operations. Furthermore, if edit opera-
tions conﬂict with each other, the server cannot resolve these
conﬂicts. Instead, the clients have to compute the conﬂict
resolving OT algorithms themselves. By deﬁnition, journal-
ing based approaches are not oblivious. Even if snapshots
are used, the revision history can be gathered up to the point
where the last snapshot was created.
In 2010, Feldman et al. proposed a collaboration tool [12]
that invented the journaling approach. To the best of our
knowledge, this work was the ﬁrst one to combine encryp-
tion, integrity protection, and OT in a single application.
However, their solution requires a custom server implemen-
tation. This disadvantage was compensated by a proposal
by Clear et al. in 2012 [8]. In their tool, the custom server
implementation is replaced by Google Docs. The client is
built using a combination of a Mozilla Firefox extension and
a standalone Java module for cryptographic operations.
Document Approach to Encrypted Collaboration.
The second approach does not protect the edit operations,
but the document itself. We call this the document approach.
With this approach, a client does not need to download the
document’s history; the server can provide a client with
the most recent snapshot directly. This approach also of-
ﬂoads the computationally expensive conﬂict resolution to
the server. Since this approach does not require retaining
the history of a document, it allows to gain obliviousness.
However, this approach has other problematic sides. Mod-
ern cryptographic modes of operation are not incremental,
see e. g.
to access
1Google Docs allows a user
of a document,
how-i-reverse-engineered-google-docs/
2DropBox allows reverting to previous snapshots of ﬁles, see
e. g. https://www.dropbox.com/en/help/11
the history
http://features.jsomers.net/
for instance. Therefore, small changes in the plaintext lead
to huge changes in the corresponding ciphertext. This re-
sults in an increase in network traﬃc and a certain ﬂurry in
the document if they are used for collaborative editing.
In 2010, D’Angelo et al. as well as Adkinson-Orellana
et al. created Mozilla Firefox extensions to create an encryp-
tion wrapper for documents stored within Google Docs [1,
9]. But these publications focused neither collaboration nor
real-time usability.
The ﬁrst collaborative solution with a document based
approach was presented by Huang and Evans in 2011 [17].
For this, they made use of the OT algorithms already im-
plemented in Google Docs and therefore did not need to
implement OT within their client, also a Mozilla Firefox
extension. The problem with ineﬃcient re-encryption us-
ing well-known modes of operation was solved using In-
cremental Encryption (cf. [4]) and specially crafted data
structures. However, the tool by Huang and Evans does
not work if multiple users edit a document simultaneously