### Document Structure and Ciphertext Generation

A document \( j \) is structured as a tree, where element nodes serve as intermediary nodes, and content and attribute nodes are the leaves. The corresponding ciphertext document is generated by replacing a subtree (i.e., an element along with its contents) with a ciphertext element.

### 3.2 Security Model

The primary objective of an adversary is to decipher the plaintext content of a ciphertext element in \( ct_j \). Various security models can be employed to define the security of SECRET. We will analyze SECRET under all three models in Section 9.

- **Honest-But-Curious Cloud Server**: In this model, the cloud provider offers storage services honestly (without forging data), but passively reads the stored data and may forward it to third parties, either voluntarily or upon court request. This is the standard security model for cloud storage and encrypted document editing, as seen in previous work (e.g., [37]).

- **Passive Man-In-The-Middle**: In this model, the attacker passively intercepts all network traffic without performing active attacks such as deleting or altering network packets. This model can also be referred to as the "honest-but-curious network."

- **Web Attacker Model**: This is the standard model for proving the security of web applications [3]. An adversary in this model can access any open web application, study its client-side code, send emails and other messages, and set up their own (malicious) web application. The web attacker cannot forge web origins [2], as this would compromise the security of any web application.

### 3.3 Obliviousness Model

In the obliviousness game, the adversary \( A \) can act as a user and join a session \( \sigma_j \). Upon being added to the session, the adversary gains access to the key \( k_j \) and the current snapshot \( m_t^j \) of the document. The adversary breaches the obliviousness property if they can compute a previous snapshot \( m_{t'}^j \), where \( t' < t \).

### 4.1 Structured Encryption

Structured encryption allows encrypted parts of a document to blend seamlessly with the rest of the structure. This approach ensures that major portions of the software do not need to differentiate between encrypted and plain parts. An alternative to XML Encryption is JSON Web Encryption (JWE) [20], where an encrypted JSON object remains a JSON object using JWE JSON Serialization.

### 4.2 Tree-based Operational Transforms

A naive approach to implementing OT on tree-structured documents (e.g., JSON or XML) is to serialize these documents into a string and synchronize this string among all clients. Whenever a modification occurs, the modified tree is serialized, and the resulting string is compared with the serialization of the most recent snapshot of the document tree. Any detected differences are encoded as operations and transmitted to the OT server.

However, since the server does not understand the semantics of the string, applying OT can result in unusable documents. For example, consider the JSON object `{"1":1}`. Alice adds a property named "2" with the value 2, resulting in `{"1":1,"2":2}`, which is translated to the edit operation `INS(',"2":2', 6)`. Simultaneously, Bob deletes the property "1" to get `{}`, translated to the edit operation `DEL(1, 5)`.

The server receives both edits and detects that the `DEL` command does not need transformation. The `INS` command, however, must be transformed to `INS(',"2":2', 1)` before being forwarded to Bob. In the end, both Alice and Bob reach a consistent state, but the resulting string is `{,"2":2}`, which is not valid JSON.

Therefore, OT for tree-structured data requires a server implementation that maintains the structure's integrity. ShareJS 0.6 [14] is a web application library that supports OT on JSON documents.

### 4.3 Combining Both Primitives

For collaborative editing, a disadvantage of JWE is that it requires the key, metadata, and ciphertext to be part of the same data structure, leading to increased document size. In contrast, XML Encryption allows optional metadata and reusable keys. Thus, we use XML Encryption to implement SECRET.

Modern browsers support XML but do not natively support XML Security, especially XML Encryption. Therefore, we developed a JavaScript library to create and process encrypted XML trees or parts thereof. Despite fundamental differences between XML and JSON, there are conceptual similarities. From an XML element's perspective, its children are an ordered list of elements, similar to an array of objects in a JSON object. Attributes are an unordered list of key-value pairs, much like named properties in a JSON object. Text content is simply a string, similar to the classic OT approach.

Our OT-compliant library for XML documents extends parts of ShareJS originally written for JSON objects. This allows us to reuse ShareJS's communication subsystem, which uses WebSockets for asynchronous messaging. Our extension supports the following seven basic operations on XML documents:

1. Insert a new element based on an XML string.
2. Delete an existing element.
3. Move an element among its siblings.
4. Insert text into a text node.
5. Delete text from a text node.
6. Set or overwrite an attribute.
7. Delete an attribute.

More complex XML features, such as namespaces, comment nodes, and CDATA sections, are modeled as special cases. Namespaces are treated as a special case of an elementâ€™s name, while comments and CDATA sections are modeled as special elements with different string representations and no attributes.

This design enables the application of XML Encryption to an OT-synchronized XML document. The structure-preserving property ensures that the OT algorithm does not need to distinguish between encrypted and plain elements, allowing transparent application of XML Encryption. This achieves our goal of enabling OTs on (partially) encrypted documents.

### 5. Related Work

Operational Transforms (OT) were first introduced by Ellis and Gibbs in 1989 [11]. Subsequent works refined OT for concurrent editing of plain text (e.g., [28, 31, 33]). Real-time collaborative working gained prominence with Google Wave, renamed to Apache Wave, which allowed multiple users to edit the same document simultaneously. Although Google discontinued the Wave project, its concepts were integrated into Google Docs. Other real-time collaborative editing web applications include Microsoft Office Online and Etherpad.

In 2002, Davis et al. described OT on Standard General Markup Language (SGML) documents [10], a predecessor of XML. This work was later extended to support collaborative editing of XML documents in centralized architectures with manual conflict resolution [19, 29] and in peer-to-peer environments [18].

The security property of obliviousness was first introduced by Buonanno et al. for incremental encryption schemes [7, Sect. 2.5]. There are two main approaches to collaborative editing on encrypted documents (see Table 1):

- **Journaling Approach**: Each client encrypts every single edit operation before sending it to the server. The server stores a long list of encrypted edit operations and provides it to the clients. This approach requires significant storage and network overhead [8, Section 4.2]. Cleanup work, such as coalescing edit operations or introducing snapshots, can mitigate this, but the server cannot decrypt the operations, making conflict resolution difficult.

- **Document Approach**: This approach protects the document itself rather than the edit operations. Clients do not need to download the document's history; the server can provide the most recent snapshot directly. This offloads computationally expensive conflict resolution to the server and allows for obliviousness. However, modern cryptographic modes of operation are not incremental, leading to large changes in the ciphertext for small changes in the plaintext, increasing network traffic and document instability.

In 2010, Feldman et al. proposed a collaboration tool [12] that used the journaling approach, combining encryption, integrity protection, and OT. Clear et al. [8] replaced the custom server with Google Docs, using a Mozilla Firefox extension and a standalone Java module for cryptographic operations.

The first collaborative solution with a document-based approach was presented by Huang and Evans in 2011 [17], using OT algorithms in Google Docs. They solved the re-encryption problem using Incremental Encryption and specially crafted data structures. However, their tool did not support simultaneous editing by multiple users.