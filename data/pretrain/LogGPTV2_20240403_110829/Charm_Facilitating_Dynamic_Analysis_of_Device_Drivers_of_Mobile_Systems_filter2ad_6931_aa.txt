title:Charm: Facilitating Dynamic Analysis of Device Drivers of Mobile Systems
author:Seyed Mohammadjavad Seyed Talebi and
Hamid Tavakoli and
Hang Zhang and
Zheng Zhang and
Ardalan Amiri Sani and
Zhiyun Qian
Charm: Facilitating Dynamic Analysis 
of Device Drivers of Mobile Systems
Seyed Mohammadjavad Seyed Talebi and Hamid Tavakoli, UC Irvine;  
Hang Zhang and Zheng Zhang, UC Riverside;  
Ardalan Amiri Sani, UC Irvine; Zhiyun Qian, UC Riverside
https://www.usenix.org/conference/usenixsecurity18/presentation/talebi
This paper is included in the Proceedings of the 
27th USENIX Security Symposium.
August 15–17, 2018 • Baltimore, MD, USA
ISBN 978-1-939133-04-5
Open access to the Proceedings of the 27th USENIX Security Symposium is sponsored by USENIX.Charm: Facilitating Dynamic Analysis of Device Drivers of Mobile Systems
Seyed Mohammadjavad Seyed Talebi(cid:63), Hamid Tavakoli(cid:63), Hang Zhang†, Zheng Zhang†,
Ardalan Amiri Sani(cid:63), Zhiyun Qian†
(cid:63)UC Irvine, †UC Riverside
Abstract
1
Introduction
Mobile systems, such as smartphones and tablets, incor-
porate a diverse set of I/O devices, such as camera, audio
devices, GPU, and sensors. This in turn results in a large
number of diverse and customized device drivers running
in the operating system kernel of mobile systems. These
device drivers contain various bugs and vulnerabilities,
making them a top target for kernel exploits [78]. Un-
fortunately, security analysts face important challenges
in analyzing these device drivers in order to ﬁnd, under-
stand, and patch vulnerabilities. More speciﬁcally, us-
ing the state-of-the-art dynamic analysis techniques such
as interactive debugging, fuzzing, and record-and-replay
for analysis of these drivers is difﬁcult, inefﬁcient, or
even completely inaccessible depending on the analysis.
In this paper, we present Charm1, a system solution
that facilitates dynamic analysis of device drivers of mo-
bile systems. Charm’s key technique is remote device
driver execution, which enables the device driver to ex-
ecute in a virtual machine on a workstation. Charm
makes this possible by using the actual mobile system
only for servicing the low-level and infrequent I/O oper-
ations through a low-latency and customized USB chan-
nel. Charm does not require any specialized hardware
and is immediately available to analysts. We show that it
is feasible to apply Charm to various device drivers, in-
cluding camera, audio, GPU, and IMU sensor drivers,
in different mobile systems, including LG Nexus 5X,
Huawei Nexus 6P, and Samsung Galaxy S7. In an ex-
tensive evaluation, we show that Charm enhances the us-
ability of fuzzing of device drivers, enables record-and-
replay of driver’s execution, and facilitates detailed vul-
nerability analysis. Altogether, these capabilities have
enabled us to ﬁnd 25 bugs in device drivers, analyze 3
existing ones, and even build an arbitrary-code-execution
kernel exploit using one of them.
1Charm is open sourced: https://trusslab.github.io/charm/
Today, mobile systems, such as smartphones and tablets,
incorporate a diverse set of I/O devices, e.g., camera, dis-
play, sensors, accelerators such as GPU, and various net-
work devices. These I/O devices are the main driving
force for product differentiation in a competitive market.
It is reported that there are more than a thousand Android
device manufacturers and more than 24,000 distinct An-
droid devices seen just in 2015 [1]. Therefore, one smart-
phone vendor might use a powerful camera so that its
smartphone would stand out in this market, while another
might be the ﬁrst to incorporate a ﬁngerprint scanner.
Such diversity has an important implication for the
operating system of mobile systems: a large number
of highly diverse and customized device drivers are re-
quired to power the corresponding set of distinct I/O de-
vices. Device drivers run in the kernel of the operating
system and are known to be the source of many serious
vulnerabilities such as root vulnerabilities [78]. There-
fore, security analysts invest signiﬁcant effort to ﬁnd,
analyze, and patch the vulnerabilities in them. Unfor-
tunately, they face important deﬁciencies in doing so.
More speciﬁcally, performing dynamic analysis on de-
vice drivers in mobile systems is difﬁcult, inefﬁcient,
or even impossible depending on the analysis. For ex-
ample, some dynamic analyses,
including introspect-
ing the driver and kernel state with a debugger (such
as GDB) and record-and-replay, requires the driver to
run within a controlled environment, e.g., a virtual ma-
chine. Unfortunately, doing so for device drivers run-
ning in the kernel of mobile systems is impossible. As
another example, a kernel fuzzer, such as kAFL [65] or
Google Syzkaller [7], can be used to ﬁnd various types
of bugs in the operating system kernel including device
drivers. Unfortunately, fuzzing the device drivers in mo-
bile systems encounters various disadvantages. First, us-
ing kAFL requires running the driver in an x86-based vir-
tual machine, which is not possible for mobile drivers.
USENIX Association
27th USENIX Security Symposium    291
leverages the commonly available USB interface and
hence makes our solution immediately available to se-
curity analysts.
Second, in addition to interacting with the I/O de-
vice’s hardware, a device driver interacts with several
other modules in the operating system kernel including a
bus driver, the power management module, and the clock
management module. These modules, which we refer to
as “resident modules”, cannot be moved to the virtual
machine since they are needed in the mobile system for
the usage of the USB channel. We address this challenge
with a Remote Procedure Call (RPC) interface for the re-
mote driver to interact with these modules in the mobile
system. We build our RPC solution at the boundary of
common Linux APIs. Therefore, different device drivers
of different mobile systems can use the same RPC inter-
face, reducing the engineering effort to apply Charm to
new device drivers.
We implement Charm’s prototype using an Intel Xeon-
based workstation and three smartphones: LG Nexus
5X, Huawei Nexus 6P, and Samsung Galaxy S7. We
implement remote device driver execution for two de-
vice drivers in Nexus 5X, namely the camera and audio
drivers, for the GPU device driver in Nexus 6P, and for
Inertial Measurement Unit (IMU) sensor driver in Sam-
sung Galaxy S7. Altogether, these drivers encompass
129,000 LoC. We choose four distinct device driver from
three vendors to demonstrate the ability of Charm to sup-
port a diverse set of device drivers in various mobile sys-
tems. We have released the source code of Charm as well
as the kernel images conﬁgured for the supported drivers.
The former enables security analysts to support new de-
vice drivers, while the latter enables them to immediately
apply different dynamic analysis techniques to the set of
device drivers that Charm already supports.
Our current prototype of Charm only supports open
source device drivers. Fortunately, kernel source code
(including drivers) is often available for Android devices.
In practice, the kernel is often released by vendors soon
after launch, e.g., in the case of Samsung Galaxy S9
and S9+ [19]. Moreover, kernels released by the ven-
dors are integrated into custom Android projects (such
as LineageOS, which supports 200 devices at the time
of this writing [18]), providing bootable Android im-
ages. These projects also provide instructions to unlock
the bootloader on supported devices in order to deploy
these images. Therefore, we believe that Charm is useful
for many (if not most) Android devices. However, there
are still a large number of closed source device drivers,
which Charm cannot currently support. Therefore, as
part of our future work, we plan to support closed source
drivers in Charm too (§8).
Using extensive evaluation, we demonstrate the fol-
lowing. First, we show that it is feasible to add support
Figure 1: Charm enables a security analyst to run a mo-
bile I/O device driver in a virtual machine and inspect it
using various dynamic analysis techniques.
Second, using Syzkaller directly on mobile systems is
challenging due to (i) lack of support for latest fuzzing
features, such as new kernel sanitizers [9–12] and (ii)
lack of access to the system’s console without using a
specialized adapter [8].
In this paper, we present Charm, a system designed
to facilitate dynamic analysis of device drivers of mobile
systems in order to ﬁnd and investigate the vulnerabili-
ties in them. Our key contribution in Charm that makes
this possible is a system solution for the execution of
mobile I/O device drivers within a virtual machine on
a different physical machine, e.g., a workstation. Such
a capability overcomes the aforementioned deﬁciencies.
That is, since the device driver executes within a vir-
tual machine, it enables the analyst to use various dy-
namic analyses including manual interactive debugging,
record-and-replay, and enhanced fuzzing.
Executing a mobile system’s device driver within a
workstation virtual machine is normally impossible since
the driver requires access to the exact hardware of the
I/O device in the mobile system. We solve this prob-
lem using a technique called remote device driver exe-
cution. With this technique, the device driver’s attempts
to interact with its I/O device are intercepted in the vir-
tual machine by the hypervisor and routed to the actual
mobile system over a customized low-latency USB chan-
nel. In this technique, while the actual mobile system is
needed for the execution of the infrequent low-level I/O
operations, the device driver runs fully within a virtual
machine and hence can be analyzed. Figure 1 shows the
high-level idea behind Charm.
Remote device driver execution raises two important
challenges, which we address in this paper. First, inter-
actions of a device driver with its corresponding I/O de-
vice are time-sensitive. Hence the added latency of com-
munications between the workstation and mobile system
can easily result in various time-out problems in the I/O
device or driver, as our own experience with our ear-
lier Charm prototypes demonstrated. We address this
challenge with a customized USB channel. Quite im-
portantly, our solution does not require any customized
hardware for the connection to the mobile system.
It
292    27th USENIX Security Symposium
USENIX Association
Virtual machineDevice driver(s) of mobile systemLow-level I/O operationsfor new device drivers in Charm in a reasonable amount
of time. Second, we show that despite the overhead of
remote device driver execution, Charm’s performance is
on par with actual mobile systems. More speciﬁcally, we
show that a fuzzer can execute about the same number
of fuzzing programs in Charm and hence achieve similar
code coverage in the driver. Third, we show that Charm
enables us to ﬁnd 25 bugs in drivers including 14 previ-
ously unknown bugs (several of which we have already
reported) and two bugs detected by a kernel sanitizer not
available on the corresponding mobile system’s kernel.
Fourth, we show that we can record and replay the ex-
ecution of the device driver, which, among others, can
help easily recreate a bug without needing the mobile
system’s hardware. Finally, we show that it is feasible
to use a debugger, i.e., GDB, to analyze various vulner-
abilities in these drivers. Using this ability, we have an-
alyzed three publicly reported vulnerabilities and man-
aged to build an arbitrary-code-execution kernel exploit
using one of them.
2 Motivation
Our efforts to build Charm is motivated by our previous
struggles to analyze the device drivers of mobile systems
in order to ﬁnd and understand vulnerabilities in them. In
this section, we discuss three important dynamic analysis
techniques: manual interactive debugging, record-and-
replay, and fuzzing. We discuss the current challenges in
applying them to device drivers of mobile systems and
brieﬂy mention how Charm overcomes these challenges.
2.1 Manual Interactive Debugging
Security analysts often use a debugger, such as the infa-
mous GDB, to analyze a vulnerability or a reported ex-
ploit. A debugger enables the analyst to put breakpoints
in the code, investigate the content of memory when and
where needed, and put watchpoints on important data
structures to detect attempts to modify them. Unfor-
tunately, performing these debugging actions on device
drivers is typically infeasible as they run in the kernel of
the mobile system’s operating system. Kernel debugger,
KGDB, tries to address this challenge by providing sup-
port for interactive debugging for the operating system
kernel. However, using KGDB for the kernel of mobile
systems is either infeasible, is difﬁcult to use, or requires
a specialized adapter. More speciﬁcally, KGDB requires
console access, which can be made available through the
UART hardware. Unfortunately, some mobile systems
do not have the UART hardware, and hence do not sup-
port KGDB. Moreover, some other systems, e.g., some
Xperia smartphones, have the UART hardware, but ac-
cessing it requires opening up the system, ﬁnding the
UART pins, and soldering connections [14], which is a
difﬁcult and error-prone task. Finally, some systems have
the UART hardware and connect it to the audio jack for
easy access, e.g., Nexus devices [20]. Console access in
this case is relatively easier but still requires a specialized
adapter cable [15].
Charm solves this problem. It enables the security an-
alysts to analyze the device driver since the driver runs
within a virtual machine. To demonstrate this point, we
have used GDB to analyze 3 vulnerabilities in Nexus
5X camera driver (reported on Android Security Bul-
letins [2]). Moreover, we have also used GDB to help
construct an exploit that can gain arbitrary code execu-
tion in the kernel using one of these vulnerabilities.
2.2 Record-and-Replay
Record-and-replay is an invaluable tool for analyzing the
behavior of a program, including device drivers. It en-
ables an analyst to record the execution of the device
driver and replay it when needed.
Imagine that a cer-
tain run of a device driver results in a crash (e.g., when
being fuzzed). Recreating the crash might not be trivial
since it might depend on a race condition that is trig-
gered in a certain interleaving of driver execution and
incoming interrupts from the I/O device. However, if the
execution is recorded, it can be simply replayed and an-
alyzed (e.g., with GDB). What is extremely useful about
this technique is that the replay of the driver does not
even require having access to the actual mobile system.
Therefore, anyone with access to a virtual machine can
replay the device driver execution and analyze it.
While any virtual machine record-and-replay can be
used in Charm, we have implemented our own solution.
It records all the interactions of the driver with the remote
I/O device in the hypervisor and then replays them when
needed.
2.3 Fuzzing
Fuzzing is a dynamic analysis technique that attempts to
ﬁnd bugs in a software module under test by providing
various inputs to the module. In case of device drivers,
the input to the driver is through system calls, such as
ioctl and read system calls. While fuzzing is an ef-
fective technique to ﬁnd bugs in software, it often suffers
from low code coverage when inputs are randomly se-
lected. Therefore, to increase coverage, feedback-guided
fuzzing techniques collect execution information and use
that to guide the input generation process. One such
fuzzing tool is kAFL [65], which uses the hypervisor to
collect execution information of the virtual machine by
leveraging the Intel Processor Tracer (PT) hardware. Us-
ing kAFL to fuzz the device drivers of mobile systems
USENIX Association
27th USENIX Security Symposium    293
is currently impossible because most of the commodity
mobile devices use ARM processors, which do not have
the Intel PT hardware. Moreover, hypervisor support is
not enabled on these systems. However, by running the
driver in a virtual machine in an x86 machine, Charm
enables the use of kAFL.
Another such fuzzing tool, which is capable of fuzzing
kernel-based device drivers, is Syzkaller [7], recently re-
leased by Google. Syzkaller uses a compiler-based cov-
erage information collector, i.e., KCOV [4], and use that
to guide its input generation. Since the coverage infor-
mation collector is inserted into the kernel using the com-
piler, it is possible to use Syzkaller to directly fuzz the
device driver running inside a mobile system. Yet, using
Syzkaller with Charm provides three important advan-