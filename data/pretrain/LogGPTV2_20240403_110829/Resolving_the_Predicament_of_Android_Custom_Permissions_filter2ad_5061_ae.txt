permissions requested by the app will be granted to the app
without affecting the permissions granted to other apps, that
is “stateful” permission objects should not change.
Uninstallation. The uninstall operation removes an ex-
isting app and its custom permissions from the device and it
readjusts the permissions granted to other apps in case there is
a change in the set of custom permissions. In order to achieve
this, grantPermissions is executed for all the apps on
the device to reassign permissions and make sure that apps
Listing 6: Uninstall operation in the Alloy model
pred uninstall[t, t’ : Time, app : Application] {
app in Device.apps.t // precondition
// remove app from list
Device.apps.t’ = Device.apps.t - app
// remove custom perms defined by app
Device.customPerms.t’ = Device.customPerms.t -
app.declaredPerms.t
all a : Application - app | grantPermissions[a, t, t’]
// remove permissions from permission groups
all pg : Device.builtinPermGroups, p : Permission |
p in pg.perms.t and p not in app.declaredPerms.t’
=⇒ p in pg.perms.t’ else p not in pg.perms.t’
}
Listing 7: Update operation in the Alloy model
pred update[t, t’ : Time, app : Application] {
app in Device.apps.t // precondition
Device.apps.t’ = Device.apps.t
// 1. Fix custom permissions on the device
Device.customPerms.t’ =
Device.customPerms.t - app.declaredPerms.t +
app.declaredPerms.t’
// 2. Update all other apps if a perm is removed
anyPermissionRemoved[t, t’, app] =⇒
updatePermissions[Application - app, t, t’]
else
all a : Application - app | a.permissionsState.t’
= a.permissionsState.t
// 3. Regrant permissions for the current app
grantPermissions[app, t, t’]
// 4. Adjust permission groups
adjustPermissionGroups[app, t, t’]
}
pred updatePermissions[apps : set Application, t,t’ :
Time] {
all app : apps | grantPermissions[app, t, t’]
}
1
2
3
4
5
6
7
8
9
10
11
12
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
will be revoked the custom permissions of the removed app.
This is a new behavior introduced by Google as a response
to the previous bug reports regarding the issues with custom
permissions. Listing 6 demonstrates uninstallation in Alloy.
Update. We introduce the update operation in our model
since this operation is necessary to demonstrate the Custom
Permission Upgrade vulnerability. Similar to uninstall,
if a custom permission deﬁned by this app is being re-
moved from the manifest ﬁle with the update, we in-
voke grantPermissions for all other apps on the
device in order
to revoke this permission. Additionally,
grantPermissions is executed for the app being updated
to readjust its granted permissions, regardless of any change on
the set of permissions. Permission groups are also readjusted
such that
the permissions removed from the app are also
removed from their respective permission groups and the
newly-added permissions are added to their respective groups.
Listing 7 demonstrates the update operation in Alloy.
C. Correctness of Cusper
In order to verify the correctness of a proposed model, one
needs to ﬁrst compile a set of fundamental properties that need
to be satisﬁed by the model under all conditions. Then, we
need Alloy assertions, which are sanity checks to verify that
this model behaves as expected with respect to these properties.
11
All security properties that had to be satisﬁed by the
original Android permission model should also be satisﬁed by
Cusper. Here, we focus on the properties that were violated by
the original model. Our observation is that the new classes of
vulnerabilities we discussed in Section IV are made possible
because of the violation of two fundamental security properties
that should always hold on the Android runtime permission
model: 1) dangerous runtime permissions should never be
granted without user interaction, 2) there should never be an
unauthorized application component access. The ﬁrst property
means that a dangerous permission should only be granted
with the user’s approval for when the app’s target API level
is equal to or more than 23. The second one suggests that an
app cannot access another app’s components if it does not have
the right permission for it. For example, if an app component
is being protected by a signature custom permission, only the
applications that possess the same signature as this app should
be able to access the component.
In order to verify our observation, we built Alloy assertions
of fundamental security properties and showed that the original
model indeed does not satisfy the two aforementioned proper-
ties as the Alloy analyzer is able to produce counterexamples
for both assertions indicating the violation of these properties.
These correspond to the attack instances we have previously
described. However, when the permission model is augmented
to describe Cusper, we show that all the security properties
are always satisﬁed, formally verifying the correctness of our
design.
VII. SYSTEM EVALUATION
In the previous section, we verify the correctness of the for-
mal model of Cusper which provides conﬁdence regarding our
design decisions. Next, we want to generate evidence regarding
the practicality of Cusper’s respective system implementation.
Toward this end, we empirically evaluate our implementation
of Cusper on Android, with respect to (a) its ability to thwart
the speciﬁc attacks we presented and (b) its performance
overhead incurred in the affected Android operations.
Effectiveness. To evaluate the effectiveness of Cusper, we
carried out the two attacks we mentioned in Section IV on
Cusper-augmented Android and showed that both attacks fail.
First, we attempted the Custom Permission Upgrade attack
on Cusper-augmented Android and veriﬁed that the attack
could no longer succeed. The user is correctly being consulted
to grant the pemission by the system once a permission dec-
laration changes from a normal protection level to dangerous.
Moreover, we veriﬁed that a third-party app can neither assign
a custom permission in a system permission group, nor declare
a custom permission group using the system permission group
naming convention. At the same time, normal operations of
benign third-party and system apps are preserved.
With respect to the Confused Deputy attack, using the the
apps mentioned in Section III (i.e., Skype, CareZone) as well
as other real-world apps, we veriﬁed that the attack can no
longer succeed while again utility is preserved with Cusper.
We further tested that permission revocation happens correctly
when the declarer app is uninstalled. We also veriﬁed that
declared custom permissions are preﬁxed by a hash of the app
developer’s signature, and the same happens for the custom
permissions used to protect app components. Finally, we tested
that granting normal and signature permissions at installation
time, granting dangerous permissions at runtime, and using the
permissions to access protected app or system components,
happen correctly; hence, we do not break any utility.
Efﬁciency. In evaluating the performance of our system, we
focused on the operations affected by our modiﬁcations. These
include the app install operation, the app uninstall operation,
runtime (dangerous) permission granting, and permission en-
forcement. We did not include our evaluation for the app
update operation as its performance is similar to that of app
install. We use a Nexus 5 phone running Android 6.0 (android-
6.0.1 r77) for all our experiments. According to a previous
study, Android users have on average 95 apps [6] installed on
their devices. In addition, according to our prevalence study in
Section III, apps create one custom permission on average. In
order to evaluate Cusper under realistic conditions, we mimic
this average case in our experiments and make sure the device
contains 100 custom permissions along with all of the system
permissions.
the permission,
and declares
a
In our app install and app uninstall experiments, we
used the Android Debug Bridge (adb) to install and unin-
stall an app of size 1.2 MB 100 times. The app de-
clares a custom permission, with protection-level
dangerous, uses
ser-
vice which is protected by that permission. We instru-
mented the installPackageAsUser() method in the
PackageManagerService class to get
time
of app installation. We got the end time at the point be-
fore the system broadcasts the ACTION PACKAGE ADDED
intent
the package installa-
tion. For app uninstallation, we instrumented the methods
deletePackage() and deletePackageX() to get the
start time and end time respectively. Figure 1a and Figure 1b
illustrate our results.
indicating the completion of
the start
We compared our system with the unmodiﬁed Android
version (Android). During installation, our system performs
checks during parsing, performs the permission translation, and
handles the permission revocation. While parsing, it checks
and stores whether a permission deﬁnition is for a custom
permission and it enforces the permission group checks. Then,
it parses the in-memory meta-data of an app to perform a
custom permission translation. Nonetheless, as shown in our
evaluation, the performance overheads are indeed negligible:
there is no statistically signiﬁcant deviation between Cusper
and the original version.
In addition, we evaluated the operation of granting a
dangerous permission at runtime. We used an app which
requests a custom permission previously deﬁned in the system.
Note that this is a process which involves user interaction:
the system pops up a dialog box asking the user to grant
or deny the permission request. We automated this process
and ran this experiment 100 times. However, to avoid the
unpredictable temporal variable of user interaction, we do not
count the time between the display of the dialog box and the
time the dialog box is removed. Our evaluation instrumentation
is deployed in the GrantPermissionsActivity class.
Figure 1c summarizes our results. Evidently, Cusper does not
12
(a) App Install
(b) App Uninstall
(c) Grant Dangerous Permission
Fig. 1: Performance evaluation of Cusper for installation, uninstallation and runtime (dangerous) permission granting.
(a) Activity
(b) Service
(c) Broadcast Receiver
(d) Content Provider
Fig. 2: Performance evaluation of Cusper for component access.
incur any distinctive overhead.
Finally, we evaluated the performance of permission en-
forcement for custom permissions. For this case, we show per-
formance results for accessing permission-protected app com-
ponents of all kinds (i.e., activity, service, broadcast receiver,
and content provider) in Figure 2. As can be seen, Cusper
indeed incurs negligible overhead for all types of component
invocation operations that require permission checks.
In summary, our modiﬁcations to the Android system are
shown to have no perceivable performance overhead while they
greatly strengthen the security of the Android OS.
VIII. RELATED WORK
Previous work investigated Android Permissions and IPC
security from many different perspectives.
IPC security on Android. Previous work has shown ways
of exploiting IPC on Android to acquire unauthorized access
to resources. In [26], the authors discuss the permission re-
delegation problem where an unprivileged app can access sys-
tem resources through a privileged app via IPC. Additionally,
[23] shows ways of exploiting the Intent mechanism to send
or receive Intents in an unauthorized manner and get access
to other app’s private resources.
Analysis of Android Permissions. Wei et al studied the
evolution of permissions across Android versions and showed
that the set of permissions on Android tends to grow with every
release [31]. Stowaway tool aims to detect if apps follow the
least privilege for permission requests [25]. Additionally, [20]
presents a formal analysis of Android permissions for older
Android versions (<6.0) in Alloy; whereas [21], [29] introduce
similar models in Coq.
Android Runtime Permissions. One of the early works on
runtime permissions shows the necessity of having revocable,
ask-on-ﬁrst-use type permissions on Android, supported by
user studies [25]. [33] provides an initial analysis on the
runtime permission model and identiﬁes several problems in
this model that might open up ways for exploits. In [24], the
authors analyze the undesirable side effects of switching to
runtime permissions and introduce a tool called RevDroid that
aims to identify these problems in apps. DP-transform provides
a tool which helps developers adapt to the runtime model by
automatically introducing the permission requests required by
the model into the application code [22].
Android Custom Permissions. Although previous work has
studied Android permissions, there is little work done speciﬁ-
cally regarding Android custom permissions.The blog post in
[9] discusses how the ”ﬁrst one wins” approach for custom
permission deﬁnitions can create problems. Shin et al presents
a viable attack on custom permissions by exploiting the naming
convention problem of custom permissions [30],
to which
Google responded with bug ﬁxes. In [28], the authors discuss
how permissions can stay dormant on the Android platform,
later to be revived by the installation of a permission deﬁner
app, and demonstrate attacks on custom permissions via the
exploitation of this undesirable property.
IX. CONCLUSION
In this work, we investigate the Android runtime per-
mission model and identify design ﬂaws in custom permis-
sions that can open up ways for adversaries to escalate their
privileges to obtain unauthorized access to app components
and platform resources. In order to systematically ﬁx these
ﬂaws, we propose a defense mechanism, Cusper, that provides
separation of trust between system and custom permissions and
introduces an internal naming convention for custom permis-
sions to effectively track their origins. To show the correctness
of our approach, we ﬁrst construct a formal model of the
Android runtime permission model using Alloy speciﬁcation
13
AndroidCusper1600170018001900200021002200Runtime (ms)AndroidCusper90100110120130Runtime (ms)AndroidCusper468101214Runtime (ms)AndroidCusper20406080100120Runtime (ms)start Servicestop Service05101520Runtime (ms)AndroidCusperAndroidCusper354045505560Runtime (ms)AndroidCusper354045505560Runtime (ms)Listing 8: New permission representation according to Cusper
Listing 9: Component invocation with Cusper
1
2
3
4
5
6
7
8
sig Permission {
name : PermName,
protectionLevel : ProtectionLevel,
sourcePackage : PackageName,
isCustomPermission : Bool, // new field
permGroup : lone PermGroupName,
sourceId : AppSignature // new field for Cusper
for Cusper
}
language and formally prove the existence of the vulnerabil-
ities in this model. Then, we leverage this formal model to
show that Cusper satisﬁes the fundamental security properties
that were previously violated due to the custom permission
vulnerabilities. Our evaluation of Cusper on Android shows
that Cusper effectively ﬁxes the existing vulnerabilities while
inducing minimal overhead.
Acknowledgments. This work was supported in part by NSF
CNS grants 15-13939, and 13-30491. The views expressed are
those of the authors only.
A. Implementation of Cusper in Alloy