354578
9398
6066
1376
3035
354236
10036
5262
1853
353054
8344
5073
Falcon and Dilithium were identified as most efficient for the use
in TLS 1.3 in [100]. We contrast these against pre-quantum TLS 1.3
using X25519 [9] key exchange with RSA-2048 [97] signatures.
For all primitives we considered the parameter set at NIST se-
curity level 1, i.e., targeting security equivalent to AES-128 [43,
Sec. 4.A.5]. All primitives we chose are NIST PQC round-3 finalists
or alternate candidates, except for an instantiation of the stateful
signature algorithm XMSS at NIST level 1 for signatures generated
by CAs. XMSS is already defined in an RFC [56] and is being consid-
ered by NIST for a fast track to standardization [31]. The XMSS RFC
only describes parameters matching NIST level 5 and higher, but
the adaptation to a level-1 parameter set is rather straight-forward.
We call the level-1 parameter set of XMSS that we use in our exper-
iments XMSSMT
; details are given in Appendix D. In our scenarios
we do not take XMSS as an option for signatures generated by TLS
servers, because we do not trust typical TLS servers to securely
manage the state; but CAs might be able to do so safely.
Table 1 shows the scenarios and primitives we consider (and
the abbreviations we use in the rest of the text to refer to each
combination), as well as the resulting communication sizes.8
s
The post-quantum KEMs we use are:
• SIKEp434-compressed [61] as the KEM with the smallest
• Kyber-512 [99] as an efficient Module-LWE-based KEM; and
• NTRU-HPS-2048509 [110] as an efficient NTRU-based KEM.
sum of ciphertext and public key;
The signature schemes we use are:
the smallest sum of signature and public key;
• GeMSS-128 [27] as the scheme with the smallest signature;
• XMSSMT
[56], specified in Appendix D, as the scheme with
s
• Falcon-512 [91] as an efficient scheme based on the NTRU
assumption and the stateless scheme with the smallest sum
of signature and public key; and
8For comparison purposes, we also show the sum of the total TCP payload data for
the TLS handshake, although this is partially implementation-dependent. The number
of algorithms for which support is advertised for example affects this size.
• Dilithium II [79] as an efficient scheme based on Module-
LWE and Module-SIS.
Caching of intermediate CA certificates. For a client to authen-
ticate a server it typically uses a chain of certificates starting with
a root CA’s certificate, followed by at least one intermediate CA
certificate, and finally the leaf certificate of the actual server. If
clients cache the intermediate CA certificates, those do not need
to be transmitted. Although not yet widely adopted, this option is
available in TLS via the Cached Information Extension [98].
The obvious consequences of such caching are that less data is
transmitted and that fewer signatures need to be verified. A less
obvious consequence is the significant impact on the optimal choice
of (post-quantum) signature scheme for intermediate CAs. If the
signed public keys of intermediate CAs are transmitted only once
and then cached, what matters most is the size of the signature.
This makes MQ-based schemes like Rainbow [35] or GeMSS [27]
with their small signatures but large public keys optimal for use in
intermediate CA certificates. The same applies in any case to root
CAs, as their public keys are assumed to be pre-installed.
We investigate both scenarios: including transmission and verifi-
cation of intermediate CA certificates (i.e., without caching), and
excluding transmission and verification of intermediate CA certifi-
cates (i.e., with caching). For the “including” scenario, we have a
single intermediate CA certificate in the chain.
5.2 Implementation
To experimentally evaluate KEMTLS, we implemented it by mod-
ifying Rustls [16], a modern TLS library written in Rust. Rustls
provides a clean implementation of TLS 1.3 that was easier to mod-
ify than OpenSSL, and provides comparable performance [17]. It
uses the Ring [102] library for cryptography and WebPKI [103]
for certificate validation. Both of these are also written in Rust,
although Ring links to C implementations from BoringSSL [49].
Post-Quantum TLS Without Handshake Signatures
CCS ’20, November 9–13, 2020, Virtual Event, USA
Table 2: Average time in ms for asymmetric crypto operations and handshake establishment
Handshake time (31.1 ms latency, 1000 Mbps bandwidth)
Excl. int. CA cert.
Incl. int. CA cert.
Handshake time (195.6 ms latency, 10 Mbps bandwidth)
Excl. int. CA cert.
Incl. int. CA cert.
Computation time for asymmetric crypto
Incl. int. CA cert.
Excl. int. CA cert.
Client
Server
Client
Server
3
1
.
S
L
T
0.134
ERRR
40.058
SFXG
SFGG 34.104
0.080
KDDD
0.141
NFFF
61.456
S SSXG
55.503
SSGG
0.060
KKDD
0.118
NNFF
L
T
M
E
K
0.629
21.676
21.676
0.087
0.254
41.712
41.712
0.021
0.027
0.150
40.094
34.141
0.111
0.181
61.493
55.540
0.091
0.158
0.629
21.676
21.676
0.087
0.254
41.712
41.712
0.021
0.027
Client
sent req.
66.4
165.8
154.9
64.3
65.1
202.1
190.4
63.4
63.6
Client
Server
recv. resp. HS done
35.4
134.0
123.1
33.3
34.1
205.6
193.4
32.7
32.9
97.6
196.9
186.0
95.5
96.3
268.8
256.6
95.0
95.2
Client
sent req.
66.6
166.2
259.0
64.8
65.6
202.3
293.3
63.9
64.2
Client
Server
recv. resp. HS done
35.6
134.4
227.1
33.8
34.7
205.9
296.3
33.2
33.5
97.8
197.3
290.2
96.0
96.9
269.1
359.5
95.5
95.8
Client
sent req.
397.1
482.1
473.7
411.6
398.1
505.8
496.8
399.2
396.2
Client
Server
recv. resp. HS done
201.3
285.8
277.5
446.1
269.2
339.7
330.8
439.9
200.6
593.3
678.4
669.8
852.4
662.2
732.0
723.0
835.1
593.4
Client
sent req.
398.2
482.5
10936.3
415.9
406.7
506.1
10859.5
418.9
400.0
Client
Server
recv. resp. HS done
202.3
286.2
10384.1
448.0
443.5
340.1
10331.7
447.6
440.2
594.3
678.8
11902.5
854.7
842.8
732.4
11861.0
864.2
835.6
Label syntax: ABCD: A = ephemeral key exchange, B = leaf certificate, C = intermediate CA certificate, D = root certificate.
Label values: Dilithium, ECDH X25519, Falcon, GeMSS, Kyber, NTRU, RSA-2048, SIKE, XMSSMT
; all level-1 schemes.
s
We first added support for KEM-based key agreement to Ring
by changing its ephemeral key-agreement API, designed for Diffie–
Hellman key agreement, to a KEM-style API. We updated Rustls to
use this new API. Then, we integrated KEMs from PQClean [63],
a project that collects cleaned-up implementations of the NIST
PQC candidate schemes. Because PQClean provides a standardized,