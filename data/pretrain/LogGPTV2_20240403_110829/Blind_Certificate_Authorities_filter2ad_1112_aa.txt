# Blind Certificate Authorities

**Authors:**
- Liang Wang, UW–Madison
- Gilad Asharov
- Rafael Pass, Cornell Tech
- Thomas Ristenpart, Northeastern University
- Abhi Shelat

## Abstract
We explore the construction of a blind certificate authority (CA). Unlike conventional CAs, which learn the exact identity of those registering a public key, a blind CA can simultaneously validate an identity and provide a certificate binding a public key to it without ever learning the identity. This allows for the bootstrapping of truly anonymous systems where no party ever learns who participates. In this work, we focus on constructing blind CAs that can bind an email address to a public key using secure channel injection (SCI) protocols. These protocols enable one party (the blind CA) to insert a private message into another party's encrypted communications. We construct an efficient SCI protocol for TLS-secured communications and use it to realize anonymous proofs of account ownership for SMTP servers. Combined with a zero-knowledge certificate signing protocol, we build the first blind CA that allows Alice to obtain an X.509 certificate binding her email address, PI:EMAIL, to a public key of her choosing without ever revealing "alice" to the CA. Our system is experimentally shown to work with standard email server implementations and Gmail.

## 1. Introduction
Cryptography in practice relies on certificate authorities (CAs) that validate identities and provide cryptographic assertions binding a public key to that identity. CAs are used in systems like TLS and are essential in privacy-preserving or anonymous credential systems, such as IBM’s Identity Mixer [16] and Cinderella [18]. These systems require users to register with a CA (or identity provider) to obtain credentials attesting to their identity or attributes, which can then be used in an unlinkable, privacy-preserving manner to authenticate with other systems.

However, in all existing systems, registration reveals the user's identity to the CA, making the CA a single point of privacy failure. This is particularly problematic in contexts where using privacy tools is sensitive, such as for journalists, dissidents, or whistleblowers. We define a system that does not disclose the identities of participants as achieving participation privacy and ask whether it is possible to build such systems that still utilize validated identities. A priori, the answer seems to be "no," because validating an identity would seem to fundamentally require knowing it.

In this work, we make progress on this question by designing the first blind CA for email identities. Our blind CA validates ownership of an email address and issues a credential binding that email address to a public key without ever learning the email address. Our system achieves this in a legacy-compatible way, utilizing existing email systems and producing X.509 certificates. By combining our blind CA with Cinderella [18], one can achieve the first anonymous credential system that achieves participation privacy.

The main challenge is the tension between the need to validate an identity while not learning it. We resolve this tension using what we call an anonymous proof of account ownership (PAO). Consider an email provider, such as Gmail, a verifier (the blind CA), and the prover who owns an email account with the provider. To achieve participation privacy, the verifier should be able to validate ownership of the account by the prover without the prover revealing which account and without the email provider learning that the prover is participating.

To do this, we introduce a more general tool called secure channel injection (SCI). An SCI protocol allows the prover and verifier to jointly generate a sequence of encrypted messages sent to a server, with the ability of the verifier to insert a private message at a designated point in the sequence. In our PAO context, the server is run by the email provider, and the injected message will be a random challenge inserted into an email. The prover can later retrieve the challenge from the service using a separate connection and send the challenge back to the verifier.

Our SCI construction targets protocols running over TLS, the most widely used secure channel protocol. TLS consists of a handshake that establishes a shared secret and encrypts application-layer messages (SMTP in our context) using a record layer protocol that uses an authenticated encryption scheme. We design efficient, special-purpose secure two-party computation protocols that allow the prover and verifier to compute a TLS session with the server. For most of the session, the verifier acts as a simple TCP-layer proxy that forwards messages back and forth. The prover negotiates a TLS session key directly with the destination server. At some point in the stream, however, the verifier must inject a message, and here the prover (which has the session key) and the verifier (which has the secret challenge to inject) perform an interactive protocol to compute the record layer encryption of the message. By exploiting the cryptographic structure of the TLS record layer encryption scheme, we securely achieve this using a protocol whose most expensive step is a two-party secure computation protocol [60] on a circuit consisting of a small number of AES computations (plus exclusive-or operations). This approach is demonstrably feasible and leverages recent advances in two-party secure computation of AES.

We implement a prototype and test it with various SMTP servers, showing that it is fast enough for deployment. Running the prover on a laptop connected via a public wireless network to a verifier running on EC2, the median time to complete an SCI-based anonymous PAO is 760 milliseconds. More performance results are given in the body.

In summary, our contributions include:
- Introducing the notion of secure channel injection and showing how to realize it efficiently in the case of TLS.
- Using SCI to build anonymous proof of account ownership protocols for SMTP over TLS.
- Constructing a blind CA that generates certificates binding a public key to an account after verifying ownership of the account, all without the CA learning which account was used.
- Combining our blind CA with Cinderella to achieve the first participation-private anonymous credential system.

## 2. Background and Overview
We show how to build a blind CA service that can verify a user's ownership of an account and sign an X.509 certificate binding the user's public key to the account—without the CA learning the account or public key of the user. Our blind CA is based on an anonymous proof-of-account ownership (PAO) for email. We proceed with an overview of a standard PAO and then with a high-level idea underlying our construction of an anonymous PAO.

### Proofs of Account Ownership
Proofs of email ownership are a primary form of authentication on the web today and form a backstop in case of loss of other credentials (e.g., a forgotten password). A conventional proof of email ownership works as follows: The alleged owner of an email address, say PI:EMAIL, is referred to as the prover. The prover tells a verifier her email address, and in response, the verifier challenges her by sending an email to PI:EMAIL containing a random, unpredictable challenge. The prover must recover this challenge and submit it back to the verifier. If successful, the verifier is convinced that the prover can access the account and presumably owns it. Email is one example of a broader class of account ownership challenge-response protocols. Ownership of a domain name is often proven by having the owner set a field of the DNS record to a challenge value supplied by a verifier. Ownership of websites can be proven by adding a webpage that contains a challenge value, and similar approaches work with Twitter and Facebook accounts [35]. Common to all proofs of account ownership is the fact that the verifier learns the identity of the prover.

### Public-Key Registration
Proofs of account ownership have become increasingly used by CAs to verify ownership of an identity when registering a public key in a public-key infrastructure (PKI). One example is the Let’s Encrypt service [34], which provides free TLS certificates to users that can prove ownership of the domain via a DNS proof of ownership or web page proof of ownership. Keybase.io signs PGP keys based on proofs of ownership of social media accounts [35].

### Anonymous Proofs of Account Ownership
Conventional protocols reveal the identity of the account owner to the verifier. Sometimes, revealing the specific identity is important for security, such as logging users and detecting fraudulent requests. However, in some settings, provers may be unwilling to reveal their identities. In end-to-end encryption, privacy is a common critique of certificate transparency mechanisms like CONIKS [42]. Existing anonymous credential systems rely on a trusted third party (TTP) to perform identity checks and distribute pseudonyms to users. The pseudonym can be used to request a certificate from a CA, who checks the legitimacy of the pseudonym with the TTP [6, 12, 32, 48, 49]. However, these systems are vulnerable if the TTP misbehaves.

We show how to obtain an anonymous proof of account ownership. In our setting, we prove ownership not by showing the ability to read an email from the account but rather by sending an email from the account. A prover with an email account PI:EMAIL wishes to prove to a verifier that she owns an account at the domain without revealing her identity. The prover authenticates to her account at that domain and sends an email from her account to another email account she owns at a different domain (or even to the same email address, PI:EMAIL). However, the verifier sees that the interaction is with the domain and injects a challenge into this email at a designated point. The prover accesses her other email account, extracts the challenge, and sends it back to the verifier, proving ownership of some account in the domain.

### Secure Channel Injection
Secure channel injection (SCI) protocols allow the prover and verifier to jointly generate a sequence of encrypted messages sent to a server, with the ability of the verifier to insert a private message at a designated point in the sequence. Figure 2 illustrates the process. The prover interacts with the service (S) while all the interaction is performed through the proxy of the verifier (V). At a designated point in the interaction, the proxy injects a secret message into the encrypted stream (without knowing the secret key K). This is done using a secure protocol between the prover and the verifier, while the server remains unaware of the injection.

## 3. Conclusion
Our work introduces the concept of a blind CA that can validate ownership of an email address and issue a certificate binding a public key to that address without learning the identity. This is achieved using secure channel injection and zero-knowledge proof techniques. Our system is compatible with existing email infrastructure and produces X.509 certificates. By combining our blind CA with Cinderella, we achieve the first participation-private anonymous credential system. Future work could extend these techniques to other types of identities, such as accounts on popular web services.