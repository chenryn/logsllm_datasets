title:Blind Certificate Authorities
author:Liang Wang and
Gilad Asharov and
Rafael Pass and
Thomas Ristenpart and
Abhi Shelat
(cid:19)(cid:17)(cid:18)(cid:26)(cid:1)(cid:42)(cid:38)(cid:38)(cid:38)(cid:1)(cid:52)(cid:90)(cid:78)(cid:81)(cid:80)(cid:84)(cid:74)(cid:86)(cid:78)(cid:1)(cid:80)(cid:79)(cid:1)(cid:52)(cid:70)(cid:68)(cid:86)(cid:83)(cid:74)(cid:85)(cid:90)(cid:1)(cid:66)(cid:79)(cid:69)(cid:1)(cid:49)(cid:83)(cid:74)(cid:87)(cid:66)(cid:68)(cid:90)
Blind Certiﬁcate Authorities
†
Liang Wang
UW–Madison
∗
Gilad Asharov
∗
†
∗
Rafael Pass
Cornell Tech
∗
Thomas Ristenpart
Northeastern University
‡
‡
abhi shelat
To do so, we ﬁrst introduce secure channel
Abstract—
We explore how to build a blind certiﬁcate authority
(CA). Unlike conventional CAs, which learn the exact
identity of those registering a public key, a blind CA can
simultaneously validate an identity and provide a certiﬁcate
binding a public key to it, without ever learning the
identity. Blind CAs would therefore allow bootstrapping
truly anonymous systems in which no party ever learns
who participates. In this work we focus on constructing
blind CAs that can bind an email address to a public key.
injection
(SCI) protocols. These allow one party (in our setting, the
blind CA) to insert a private message into another party’s
encrypted communications. We construct an efﬁcient SCI
protocol for communications delivered over TLS, and use
it to realize anonymous proofs of account ownership for
SMTP servers. Combined with a zero-knowledge certiﬁcate
signing protocol, we build the ﬁrst blind CA that allows
Alice to obtain a X.509 certiﬁcate binding her email address
PI:EMAIL to a public key of her choosing without
ever revealing “alice” to the CA. We show experimentally
that our system works with standard email server imple-
mentations as well as Gmail.
I. INTRODUCTION
Cryptography in practice relies on certiﬁcate authorities
(CAs) that validate identities and provide a cryptographic
assertion binding a public key to that identity. In addition
to their use in systems like TLS, CAs are required in
privacy-preserving or anonymous credential systems, ﬁrst
introduced by Chaum [16], subsequently studied exten-
sively in the academic literature (c.f., [3,6,10,11,32,48]),
and practically realized with systems like IBM’s Identity
Mixer [12] and Cinderella [18]. These systems have a user
register with a CA (also called an identity provider) to
obtain cryptographic credentials attesting to their identity
or some attribute. The credential can then be used in
an unlinkable, privacy-preserving way to subsequently
authenticate with other systems.
But in all existing systems, registration reveals to the
CA the identity of participants. This makes the CA a sin-
gle point of privacy failure in settings where simply using
a privacy tool is sensitive, such as journalists or dissidents
living within repressive regimes, or whistleblowers at a
large corporation. We call a system that does not disclose
to any party the identities of participants as achieving
participation privacy, and ask in this work whether it is
possible to build participation-private systems that nev-
ertheless utilize validated identities. A priori the answer
would appear to be “no”, because validating an identity
would seem to fundamentally require knowing it.
In this work we make progress on this question by
designing the ﬁrst ever blind CA for email identities.
Our blind CA validates ownership of an email address
and issues a credential binding that email address to
a public key, but never learns the email address being
used. What’s more, our system achieves this in a legacy-
compatible way, utilizing existing email systems and pro-
ducing X.509 certiﬁcates. By combining our blind CA
with Cinderella [18], one can achieve the ﬁrst anonymous
credential system achieving participation privacy.
The main challenge involves the tension between the
need to validate an identity while not learning it. We
resolve this tension using what we call an anonymous
proof of account ownership (PAO). Consider an email
provider, such as Gmail, a veriﬁer (the blind CA), and the
prover that owns an email account with the provider. To
achieve participation privacy, the veriﬁer should be able to
validate ownership of the account by the prover, without
the prover revealing which account and without the email
provider learning that the prover is participating.
To do this, we introduce a more general tool called
secure channel injection (SCI). An SCI protocol allows
the prover and veriﬁer to jointly generate a sequence of
encrypted messages sent to a server, with the ability of the
veriﬁer to insert a private message at a designated point in
the sequence. In our proof of ownership context, the server
is run by the email provider, and the injected message will
be a random challenge inserted into an email. To complete
the proof of ownership, the prover can later retrieve the
challenge from the service using a separate connection,
and send the challenge back to the veriﬁer.
Our SCI construction targets protocols running over
TLS, which is the most widely used secure channel pro-
tocol. Recall that TLS consists of a handshake that es-
tablishes a shared secret, and then encrypts application-
layer messages (SMTP in our context) using a record layer
protocol that uses an authenticated encryption scheme. We
design efﬁcient, special-purpose secure two-party com-
putation protocols that allow the prover and veriﬁer to
efﬁciently compute a TLS session with the server. For
most of the session, the veriﬁer acts as a simple TCP-
layer proxy that forwards messages back and forth. The
prover negotiates a TLS session key directly with the
destination server. At some point in the stream, however,
(cid:165)(cid:1)(cid:19)(cid:17)(cid:18)(cid:26)(cid:13)(cid:1)(cid:45)(cid:74)(cid:66)(cid:79)(cid:72)(cid:1)(cid:56)(cid:66)(cid:79)(cid:72)(cid:15)(cid:1)(cid:54)(cid:79)(cid:69)(cid:70)(cid:83)(cid:1)(cid:77)(cid:74)(cid:68)(cid:70)(cid:79)(cid:84)(cid:70)(cid:1)(cid:85)(cid:80)(cid:1)(cid:42)(cid:38)(cid:38)(cid:38)(cid:15)
(cid:37)(cid:48)(cid:42)(cid:1)(cid:18)(cid:17)(cid:15)(cid:18)(cid:18)(cid:17)(cid:26)(cid:16)(cid:52)(cid:49)(cid:15)(cid:19)(cid:17)(cid:18)(cid:26)(cid:15)(cid:17)(cid:17)(cid:17)(cid:17)(cid:24)
(cid:18)(cid:17)(cid:18)(cid:22)
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:40:08 UTC from IEEE Xplore.  Restrictions apply. 
Our SCI-based anonymous PAO protocol can addition-
ally output a cryptographic commitment to the prover’s
identity (the email account name). The prover can then
construct an X.509 certiﬁcate for a public key of their
choosing, hash it, and prove in zero-knowledge to the
veriﬁer that the identity ﬁeld of the X.509 matches the
email account name in the commitment. We use the
ZKBoo framework for this step [27]. If the proof veriﬁes,
then the veriﬁer obliviously signs the hash. In this way,
the veriﬁer never learns the identity but provides the
certiﬁcate only should the prover have a valid email
account with the agreed-upon service.
We provide formal analysis of the protocols underlying
our blind CA, showing security holds even for malicious
provers or malicious veriﬁers, and for honest-but-curious
email services. Security of the ﬁnal blind CA protocol
relies on some nuances of SMTP implementations, which
we discuss in the body and verify empirically.
the veriﬁer must inject a message, and here the prover
(which has the session key) and the veriﬁer (which has the
secret challenge to inject) perform an interactive protocol
to compute the record layer encryption of the message. By
exploiting the cryptographic structure of the TLS record
layer encryption scheme, we securely achieve this using a
protocol whose most expensive step is a two-party secure
computation protocol [60] on a circuit consisting of a
small number of AES computations (plus exclusive-or
operations). Whereas direct use of secure computation
to perform the entire record layer construction would
be expensive, our approach is demonstrably feasible and
leverages recent advances in two-party secure computa-
tion of AES. Unlike Multi-context TLS [44], our protocol
can modify TLS sessions in a fully legacy-compatible
way, without changing existing network infrastructures
and collaborations with network providers.
We implement a prototype and test it with various
SMTP servers, showing that it is fast enough for deploy-
ment. (We plan to make our implementation public and
open source.) Running the prover on a laptop connected
via a public wireless network to a veriﬁer running on EC2,
the median time to complete an SCI-based anonymous
PAO is 760 milliseconds. More performance results are
given in the body.
In summary, our contributions include the following:
• We introduce the notion of secure channel injection and
show how to realize it efﬁciently in the case of TLS.
Our techniques can be adapted to other secure channels
such as SSH and IPsec.
• We use SCI to build anonymous proof of account
ownership protocols for SMTP over TLS.
• We show how to combine all this to construct a blind
CA that generates certiﬁcates binding a public key to
an account after verifying ownership of the account, all
without having the CA learn which account was used.
By combining our blind CA with Cinderella, we achieve
the ﬁrst participation-private anonymous credential sys-
tem. Our results therefore provide a foundation for privacy
tools in contexts where revealing usage of privacy tools
can be dangerous. Finally, we note that there is nothing
fundamental about our use of email for identities. Future
work could use our techniques to build blind CAs for other
types of identities, e.g., accounts on popular web services.
II. BACKGROUND AND OVERVIEW
We show how to build a blind CA service that can verify
a user’s ownership of an account, and then sign an X.509
certiﬁcate binding the user’s public key to the account—
without the CA learning the account or public key of the
user. Our blind CA is based on an anonymous proof-of-
account ownership (PAO) for email. We proceed with an
overview of a standard PAO, and then with a high-level
idea underlying our construction of an anonymous PAO.
Proofs of account ownership. Proofs of email ownership
are a primary form of authentication on the web today and
form a backstop in case of loss of other credentials (e.g.,
a forgotten password). A conventional proof of email
ownership works as follows. The alleged owner of an
email address, say PI:EMAIL, is who we
will refer to as the prover. The prover tells a veriﬁer her
email address, and in response the veriﬁer challenges her
by sending to PI:EMAIL an email contain-
ing a random, unpredictable challenge. The prover must
recover this challenge and submit it back to the veriﬁer.
If successful, the veriﬁer is convinced that the prover
can, indeed, access the account and presumably owns it.
(Of course it could be anyone with access to the email
account, including rogue insider admins or those who
have compromised the account credentials.) See Figure 1
for an illustration. Email is one example of a broader
class of account ownership challenge-response protocols.
Ownership of a domain name is often proven by having
the owner set a ﬁeld of the DNS record to a challenge
value supplied by a veriﬁer. Ownership of websites can
be proven by adding a webpage that contains a challenge
value, and similar approaches work with Twitter and
Facebook accounts [35]. Common to all proofs of account
ownership is the fact that the veriﬁer learns the identity of
the prover.
Public-key registration. Proofs of account ownership
have become increasingly used by certiﬁcate authorities
(CAs) to verify ownership of an identity when registering
a public key in a public-key infrastructure (PKI). One
example is the Let’s Encrypt service [34], which provides
free TLS certiﬁcates to users that can prove ownership of
the domain via a DNS proof of ownership or web page
proof of ownership. Keybase.io signs PGP keys based
on proofs of ownership of social media accounts [35].
(cid:18)(cid:17)(cid:18)(cid:23)
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:40:08 UTC from IEEE Xplore.  Restrictions apply. 
(a) Proof of account ownership:
(1) The prover wishes to prove the veriﬁer that she is the owner
of PI:EMAIL; (2) The veriﬁer interacts with the service
domain.com, and sends an email to PI:EMAIL with
some unpredictable challenge; (3) The prover accesses her account
at domain.com and extracts the challenge; (4) The prover sends
the challenge to the veriﬁer, proving ownership of
the account
alice@domain.com.
(b) Anonymous proof of account ownership:
(1) The prover wishes to prove the veriﬁer that she is some eligible
user of domain.com without revealing her identity; (2) Secure channel
injection: the prover sends an email from PI:EMAIL to
some other email account she owns; the veriﬁer sees that the interaction
is with domain.com and injects a challenge into this email at some
designated point; (3) The prover accesses her other email account and
extracts the challenge; (4) The prover sends the challenge to the veriﬁer,
proving ownership of some account in domain.com.
Fig. 1: A regular proof of account ownership versus our anonymous proof of account ownership. P is the prover, S is the email server of
domain.com, and V is the veriﬁer. The black circles represent challenges.
Traditional CAs also need to do PAOs, e.g., proof owner-
ship of the administrative email of the domain, to validate
one’s ownership of a domain, before issuing a certiﬁcate
binding a public key to the domain. In these contexts,
the user sends her identity and public key to the CA,
the latter invokes a proof of ownership protocol, and if
the proof veriﬁes then the CA provides the user with an
appropriate certiﬁcate. Importantly, the CA in all existing
systems learns the identity of the user.
Anonymous proofs of account ownership. The con-
ventional protocols discussed so far reveal to the veriﬁer
the identity of the account owner. Sometimes revealing
the speciﬁc identity is important for security, for example
if one needs to log users and detect fraudulent requests.
But in some settings the provers may be unwilling to
reveal their identities. In the end-to-end encryption set-
ting, privacy is an often mentioned critique of certiﬁcate
transparency mechanisms like CONIKS [42]. Existing
anonymous credential systems might seem to solve this
problem, but in fact current systems rely on a trusted
third party (TTP) to perform identity checks (via con-
ventional PAOs) and distribute pseudonyms to users. The
pseudonym can be used to request a certiﬁcate from a
CA, who checks the legitimacy of the pseudonym with
the TTP [6, 12, 32, 48, 49]. However, these systems are
vulnerable if the TTP misbehaves.
We show how to obtain an anonymous proof of account
ownership. In our setting, we prove ownership not by
showing the ability to read an email from the account,
but rather by sending an email from the account. An
illustration appears in Figure 1. In more detail, a prover
with an email account PI:EMAIL wishes
to prove to some veriﬁer that she owns an account at
the domain without revealing her identity. The prover
would authenticate to her account at that domain, and
Fig. 2: Secure channel injection: The prover (P) interacts with the
service (S) while all the interaction is performed through the proxy of
the veriﬁer (V). At some designated point in the interaction, the proxy
injects a secret message into the encrypted stream (without knowing the
secret key K). This is done using a secure protocol between the prover
and the veriﬁer, while the server is unaware of this injection.
will send an email from her account to some other email
account she owns at some other domain (or even to the
same email address, PI:EMAIL). However,