    z'SinCipher.sub_trans..r
    SinCipher.sbox_trans)
    __encrypt_oneD
    SinCipher.__encrypt_onec
    z%SinCipher.encrypt..r
    _SinCipher__encrypt_one)
    {"iv": "8e9313ce03257990eb5c019f97afe2aa4ceb27ac327f4493f300bffe3fb94dc8", "cipher": "c732f791dde0a9e7819da08462e9e767b43df88b8e450d2d63e076fd0f32fe6a51e7fbcc220f4c7b30"}
    ......
3.根据版本号与pyc的结构，定位到pyc的起始位置为0x19020：
    1:9020h 55 0D 0D 0A 00 00 00 00 0C F2 67 61 5E 13 00 00
    1:9030h E3 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
    1:9040h 00 04 00 00 00 40 00 00 00 73 76 00 00 00 64 00
    1:9050h 64 01 6C 00 5A 00 64 00 64 01 6C 01 5A 01 64 00
    1:9060h 64 01 6C 02 5A 02 64 00 64 01 6C 03 5A 03 64 00
    1:9070h 64 02 6C 04 6D 05 5A 05 01 00 64 03 65 03 6A 06
    1:9080h 76 00 73 3E 4A 00 64 04 83 01 82 01 47 00 64 05
    1:9090h 64 06 84 00 64 06 65 07 83 03 5A 08 65 09 64 07
4.提取出pyc并反编译：
    $ dd of=tmp1.pyc if=memdump skip=1 bs=102432
    9+1 records in
    9+1 records out
    946144 bytes (946 kB, 924 KiB) copied, 0.001197 s, 790 MB/s
    $ uncompyle6.exe tmp1.pyc > tmp.py
5.查看代码发现它只有加密部分，且存在一个假的加密密钥：
    def main():
        secret_key = b'O_O.... -_-...'  # 这是错误的密钥
        iv = weak_rand_str(32)
        sin = SinCipher(secret_key, iv)
        plain_text = input('')
        plain_bytes = plain_text.encode('utf8')
        cipher_bytes = sin.encrypt(plain_bytes)
        print(json.dumps({'iv':iv.hex(),  'cipher':cipher_bytes.hex()}))
    if __name__ == '__main__':
        main()
现在已知加密算法/IV和密文，需要找出加密的密钥再写出解密算法。
6.经过分析加密算法，加密脚本只有S盒，需要先算出逆S盒：
    def r_sbox_gen(sbox: list):
        r_sbox = list(range(0, 256))
        for i in range(0, 256):
            raw = (sbox[i] & 0xf0) >> 4
            rol = sbox[i] & 0xf
            r_sbox[(raw * 16) + rol] = i
        return r_sbox
另外它会通过输入的密钥生成轮密钥，轮密钥间存在相互关系：
    def gen_round_key(cls, mk: tuple):
        rk0 = [(cls.FK[i] ^ mk[i]) & 0xffffffff for i in range(0, 4)]
        rk = rk0 * cls.ROUND_COUNT
        for i in range(1, cls.ROUND_COUNT):
            for j in range(0, 4):
                if j == 0:
                    rk[i * 4 + j] = cls.sbox_trans(cls.ROUND_KEY[i - 1] ^ rk[i * 4 + j - 4]) ^ rk[i * 4 + j - 1]
                else:
                    rk[i * 4 + j] = rk[i * 4 + j - 4] ^ rk[i * 4 + j - 1]
        return rk
根据轮密钥规律，每一个密钥是它的前一位与前4位异或而得，每轮的第一位还和轮数相关，因此可通过此规律在内存中搜寻密钥，且只需要知道连续的5位就能恢复出原始密钥，算法如下：
    def crack_rk(data):
        def find_key_first(x: list):
            # 先定位到一个符合规则的位置
            for i in range(len(x) - 1, 3, -1):
                if x[i] == x[i - 4] ^ x[i - 1]:
                    x = x[:i + 1]
                    return x
        def find_round(x: list):
            """获取一轮的数据和当前轮数"""
            for i in range(len(x) - 1, 3, -1):
                if x[i] == x[i - 4] ^ x[i - 1]:
                    continue
                for j in range(SinCipher.ROUND_COUNT - 1):
                    if x[i - 4] == SinCipher.rsbox_trans(x[i - 1] ^ x[i]) ^ SinCipher.ROUND_KEY[j]:
                        # 找到了它，辣么
                        round = j
                        x = x[i - 4:i]
                        return round, x
        def recovery_key(round_key: list[int], round):
            """从一个完整的轮密钥恢复出原始密钥"""
            assert len(round_key) == 4
            round += 1  # 第0轮开始
            rk = round * 4 * [0] + round_key
            for i in range(round - 1, 0, -1):
                for j in range(3, -1, -1):
                    rk[i * 4 + j] = (rk[(i + 1) * 4 + j] ^ rk[(i + 1) * 4 + j - 1]) & 0xffffffff
                    if j == 0:
                        rk[i * 4 + j] = (SinCipher.rsbox_trans(rk[i * 4 + j]) ^ SinCipher.ROUND_KEY[i - 1]) & 0xffffffff
            rk0 = tuple(map(lambda x, y: (x ^ y) & 0xffffffff, rk[4:8], SinCipher.FK))
            return SinCipher.sin_i2b(rk0)
        x = b2i(data)
        x = find_key_first(x)
        x = find_round(x)
        return recovery_key(x[1], x[0])
    #> e08f08b75ee3ccb560f25920a1af79fc
7.恢复出密钥后，可通过加密算法写出解密算法，解密数据。
    def decrypt(data):
        secret_key = crack_rk(data)
        cipher = '''{"iv": "8e9313ce03257990eb5c019f97afe2aa4ceb27ac327f4493f300bffe3fb94dc8", "cipher": "c732f791dde0a9e7819da08462e9e767b43df88b8e450d2d63e076fd0f32fe6a51e7fbcc220f4c7b30"}'''
        cipher = json.loads(cipher)
        iv = bytes.fromhex(cipher['iv'])
        cipher = bytes.fromhex(cipher['cipher'])
        sin = SinCipher(secret_key, iv)
        plain = sin.decrypt(cipher)
        print(plain.decode('utf'))
    #> e08f08b75ee3ccb560f25920a1af79fc
    #> SangFor{Rexz-zluMoHtlhyC3t7E8jB7psZWIKCp}
### GeGe
这一题实质上就是一道求解SVP的题目。
**前置知识：**
**空间（Span）**
给定一组线性无关的基向量v1, v2, ..., vn，那么这些基向量的所有线性组合。
所形成的集合，叫做这组基向量所张成的空间。
例如，在二维平面中，选两个单位正交向量作为基向量。
由这两组基向量的所有可能的线性组合。
张成的空间为整个二维平面。二维平面上的任何一点，都可以由这两组基底的一个线性组合来表示。
**格（Lattice）**
格的定义与空间类似，给定一组线性无关的基向量v1, v2, ..., vn，那么这些基向量的所有 **整系数** 线性组合。
所形成的集合，叫做这组基向量所张成的格。（系数不是任何实数，而是任何整数）不同的基底，可能会张成不同的格。对原基底进行 **整系数**
线性转换得到的新的基底，张成的格不变。
格相关的问题中，有两个知名的难题：
SVP（最短向量问题，Shortest Vector
Problem）：给定格和基向量，找到格中的一个长度最短的非零向量。CVP（最近向量问题，Closest Vector
Problem）：给定格和基向量，以及一个不在格上的目标向量，找到格中一个距离目标向量最近的格向量。在广义上的这两大难题已经被证明是NP难问题。
本题是求解SVP（最短向量问题，Shortest Vector Problem）的题目。
格基规约算法中的LLL算法，可以求解2维的SVP问题。
**解题思路：**
已知2个关系式和p、h、c；求m、f、g。目前无法确定随机数r的值，想办法化简。
由于未知量较多，先假设f、g已知。对上面一式带入二式。
两边同乘f。
得到：
r 为1024 bit，g 为768 bit，m 为flag字符串转成数字，一个字符8bit，一般来说flag不会太长，所以基本上是小于1000 bit，f
为1024 bit，p 为3072 bit。
右边式子的值小于p，所以模p，得到的是：
则令：
即：
通过变换以及参数之间的大小关系，在同余式里面得出了一个等式。
这样可以将随机数r约掉。
此时，r被化简，只需要求出f、g，就可以的到明文m的值：
注：在模 g下运算，g是一个768 bit的强素数，这就保证了，f是个1024 bit的数，在模 g下，f' = f - k*g的逆元必定存在。
现在只要求f、g，就能解出m，求f、g的方法，此式子，看做格来求解SVP问题。
两边同乘f。
可以构造一个由下面这个矩阵M中的两个行向量(1,h), (0,p)所张成的格：
两边同乘f。
下面我们来证明向量(f, g)是在这个格上的。
**证明**
将同余式，
化为等式，
恒等变换，
可以发现，
向量 (f,g) 可以由基向量M的某种 **整系数** 线性组合 (f, -u) 来表示，因此向量 (f,g) 就在这个格上。
已知h, p, f, g的大小。
h：2000多bit p：3072bit f：1024 bit g：768 bit
相对于两个基底向量 (1, h), (0, p) 来说，向量 (f, g) 的长度要小得多得多，根据Gaussian
heurstic可知，在这个格中最短向量的长度大概在sqrt(2^3072)约等于2^1536左右。因此，很大概率上，这个(f,
g)就是这个格的最短向量。本题是求解SVP（最短向量问题，Shortest Vector Problem）的题目。
格基规约算法中的LLL算法，可以求解2维的SVP问题。
SageMath有内置的LLL算法实现。
    # Construct lattice.
    v1 = vector(ZZ, [1, h])
    v2 = vector(ZZ, [0, p])
    m = matrix([v1,v2]);
    # Solve SVP.
    shortest_vector = m.LLL()[0]
    f, g = shortest_vector
    print(f, g)
    if f ，有在线的sagemath的编辑器。
    # sage
    h = 741685980036657124703570824117837943284881194590239567891710666488343092021421903134091659952188649247812611838027447639769126034113747591994366775687375938967689804725196805491414508727437312992768010481834419757670471940075261194879453423923219441257614756265217894613370817896974099404872094147543899352059390091684223795142546563465495330437517764151319634429847222377879702032311285611223439501739927480752413359628416456028279899789972187563618018323679710545652662164125111147585075432716751781364422911569092775368885926180663208641709638464929946478449144257415280995569405660352909393579251948867427394616986700595831562669657998566133390819818439212188072311169414636981074849512957738865991057231262600908765213165983659796926041306763839123708343607947260925756758958195312529064568036435600692876965244213968886099767921881431898610126403483239033503773049306021547301942115027730890839384097247580833293474121
    p = 5050233608529261815459421720709753276268013465317000771847761427957603528040869563265512088502404346554651894767140649951393710149478346487842226815680708858366844907626693398878139547241241604618724512692518021411749264259840624777936075900186833546340656774885080077167415236481738944038259649234453620143653070795178807131460601258060138179420716641430995833287189245805143750618302652642415486774848066609117273672921413983390999591473162031857282360905260202304823054997752113434845072557695790439790834994452905929352930982374841221663164102442465389946495692126891880858411108590904768261764284777490002833011814702755850977198518393079695381425590965457831372828368997585616447655967985166143972176378983702291578885987130611662291398925420497222946016835570309006428390337561970913212519826593343069311323267590159714748533145359585126694351887284247992873298838977471763682734366220545390283355331333821253454043331
    c = 4963446802809571857260968033018406539276364616675148117021060237971516477644729757887366370184520931673134679432221828418088740269678401592795884258839004421043480925685487118640904029869799288796776841100802058925924158488108687288473325967043012138220004040832342591268257566027836494855405293369721831070578120739130911781413843466700339507137012851728602473355307593717499171158125669083422816758550318994201088990498569083885253075290244364705716071465195000806835161297308685979961079993768940640000007962668547794453962322970945764813405945636433263033585002312448411399111242467826146156637847360854845950660733971967028085351610861477485679546778216767725324875436507647728423954456510223005524703874413166915026280934452826254607852008868036423390048222853332874148121355877236114661021786904667122523713764404195998302086834272099572649032757357798879435992821026120121023839152206091356383515016661233619651957370
    # Construct lattice.
    v1 = vector(ZZ, [1, h])
    v2 = vector(ZZ, [0, p])
    m = matrix([v1,v2]);
    # Solve SVP.
    shortest_vector = m.LLL()[0]
    f, g = shortest_vector
    if f < 0:
        f = -f
    if g < 0:
        g = -g
    print(hex(f), hex(g))
    # Decrypt.
    a = f * c % p % g
    m = a * inverse_mod(f, g) * inverse_mod(f, g) % g
    print(hex(m))
运行，可得flag的十六进制值。
转换成明文得flag。
    SangFor{pfa2s1f65ads4fwev1s2d3v1cxxavqes}
* * *