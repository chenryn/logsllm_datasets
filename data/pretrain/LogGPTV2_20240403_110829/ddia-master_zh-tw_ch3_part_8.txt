列式储存背后的想法很简单：不要将所有来自一行的值储存在一起，而是将来自每一列的所有值储存在一起。如果每个列式储存在一个单独的档案中，查询只需要读取和解析查询中使用的那些列，这可以节省大量的工作。这个原理如 [图 3-10](../img/fig3-10.png) 所示。
![](../img/fig3-10.png)
**图 3-10 按列储存关系型资料，而不是行**
> 列式储存在关系资料模型中是最容易理解的，但它同样适用于非关系资料。例如，Parquet【57】是一种列式储存格式，支援基于 Google 的 Dremel 的文件资料模型【54】。
列式储存布局依赖于每个列档案包含相同顺序的行。因此，如果你需要重新组装完整的行，你可以从每个单独的列档案中获取第 23 项，并将它们放在一起形成表的第 23 行。
### 列压缩
除了仅从硬碟载入查询所需的列以外，我们还可以透过压缩资料来进一步降低对硬碟吞吐量的需求。幸运的是，列式储存通常很适合压缩。
看看 [图 3-10](../img/fig3-10.png) 中每一列的值序列：它们通常看起来是相当重复的，这是压缩的好兆头。根据列中的资料，可以使用不同的压缩技术。在资料仓库中特别有效的一种技术是点阵图编码，如 [图 3-11](../img/fig3-11.png) 所示。
![](../img/fig3-11.png)
**图 3-11 压缩的点阵图索引储存布局**
通常情况下，一列中不同值的数量与行数相比要小得多（例如，零售商可能有数十亿的销售交易，但只有 100,000 个不同的产品）。现在我们可以拿一个有 n 个不同值的列，并把它转换成 n 个独立的点阵图：每个不同值对应一个位图，每行对应一个位元位。如果该行具有该值，则该位为 1，否则为 0。
如果 n 非常小（例如，国家 / 地区列可能有大约 200 个不同的值），则这些点阵图可以将每行储存成一个位元位。但是，如果 n 更大，大部分点阵图中将会有很多的零（我们说它们是稀疏的）。在这种情况下，点阵图可以另外再进行游程编码（run-length encoding，一种无损资料压缩技术），如 [图 3-11](fig3-11.png) 底部所示。这可以使列的编码非常紧凑。
这些点阵图索引非常适合资料仓库中常见的各种查询。例如：
```sql
WHERE product_sk IN（30，68，69）
```
载入 `product_sk = 30`、`product_sk = 68` 和 `product_sk = 69` 这三个点阵图，并计算三个点阵图的按位或（OR），这可以非常有效地完成。
```sql
WHERE product_sk = 31 AND store_sk = 3
```
载入 `product_sk = 31` 和 `store_sk = 3` 的点阵图，并计算按位与（AND）。这是因为列按照相同的顺序包含行，因此一列的点阵图中的第 k 位和另一列的点阵图中的第 k 位对应相同的行。
对于不同种类的资料，也有各种不同的压缩方案，但我们不会详细讨论它们，请参阅【58】的概述。
> #### 列式储存和列族
>
> Cassandra 和 HBase 有一个列族（column families）的概念，他们从 Bigtable 继承【9】。然而，把它们称为列式（column-oriented）是非常具有误导性的：在每个列族中，它们将一行中的所有列与行键一起储存，并且不使用列压缩。因此，Bigtable 模型仍然主要是面向行的。
>
#### 记忆体频宽和向量化处理
对于需要扫描数百万行的资料仓库查询来说，一个巨大的瓶颈是从硬盘获取资料到记忆体的频宽。但是，这不是唯一的瓶颈。分析型资料库的开发人员还需要有效地利用记忆体到 CPU 快取的频宽，避免 CPU 指令处理流水线中的分支预测错误和闲置等待，以及在现代 CPU 上使用单指令多资料（SIMD）指令来加速运算【59,60】。
除了减少需要从硬碟载入的资料量以外，列式储存布局也可以有效利用 CPU 周期。例如，查询引擎可以将一整块压缩好的列资料放进 CPU 的 L1 快取中，然后在紧密的回圈（即没有函式呼叫）中遍历。相比于每条记录的处理都需要大量函式呼叫和条件判断的程式码，CPU 执行这样一个回圈要快得多。列压缩允许列中的更多行被同时放进容量有限的 L1 快取。前面描述的按位 “与” 和 “或” 运算子可以被设计为直接在这样的压缩列资料块上操作。这种技术被称为向量化处理（vectorized processing）【58,49】。
### 列式储存中的排序顺序
在列式储存中，储存行的顺序并不关键。按插入顺序储存它们是最简单的，因为插入一个新行只需要追加到每个列档案。但是，我们也可以选择按某种顺序来排列资料，就像我们之前对 SSTables 所做的那样，并将其用作索引机制。
注意，对每列分别执行排序是没有意义的，因为那样就没法知道不同列中的哪些项属于同一行。我们只能在明确一列中的第 k 项与另一列中的第 k 项属于同一行的情况下，才能重建出完整的行。
相反，资料的排序需要对一整行统一操作，即使它们的储存方式是按列的。资料库管理员可以根据他们对常用查询的了解，来选择表格中用来排序的列。例如，如果查询通常以日期范围为目标，例如“上个月”，则可以将 `date_key` 作为第一个排序键。这样查询最佳化器就可以只扫描近1个月范围的行了，这比扫描所有行要快得多。
对于第一排序列中具有相同值的行，可以用第二排序列来进一步排序。例如，如果 `date_key` 是 [图 3-10](../img/fig3-10.png) 中的第一个排序关键字，那么 `product_sk` 可能是第二个排序关键字，以便同一天的同一产品的所有销售资料都被储存在相邻位置。这将有助于需要在特定日期范围内按产品对销售进行分组或过滤的查询。
按顺序排序的另一个好处是它可以帮助压缩列。如果主要排序列没有太多个不同的值，那么在排序之后，将会得到一个相同的值连续重复多次的序列。一个简单的游程编码（就像我们用于 [图 3-11](../img/fig3-11.png) 中的点阵图一样）可以将该列压缩到几 KB —— 即使表中有数十亿行。
第一个排序键的压缩效果最强。第二和第三个排序键会更混乱，因此不会有这么长的连续的重复值。排序优先顺序更低的列以几乎随机的顺序出现，所以可能不会被压缩。但对前几列做排序在整体上仍然是有好处的。
#### 几个不同的排序顺序