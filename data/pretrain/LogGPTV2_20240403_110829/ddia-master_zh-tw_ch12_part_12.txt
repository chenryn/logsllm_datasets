然而另一个需要了解的事实是，许多真实世界的应用实际上可以摆脱这种形式，接受弱得多的唯一性：
* 如果两个人同时注册了相同的使用者名称或预订了相同的座位，你可以给其中一个人发讯息道歉，并要求他们换一个不同的使用者名称或座位。这种纠正错误的变化被称为 **补偿性事务（compensating transaction）**【59,60】。
* 如果客户订购的物品多于仓库中的物品，你可以下单补仓，并为延误向客户道歉，向他们提供折扣。实际上，这么说吧，如果叉车在仓库中轧过了你的货物，剩下的货物比你想象的要少，那么你也是得这么做【61】。因此，既然道歉工作流无论如何已经成为你商业过程中的一部分了，那么对库存物品数目新增线性一致的约束可能就没必要了。
* 与之类似，许多航空公司都会超卖机票，打著一些旅客可能会错过航班的算盘；许多旅馆也会超卖客房，抱著部分客人可能会取消预订的期望。在这些情况下，出于商业原因而故意违反了 “一人一座” 的约束；当需求超过供给的情况出现时，就会进入补偿流程（退款、升级舱位 / 房型、提供隔壁酒店的免费的房间）。即使没有超卖，为了应对由恶劣天气或员工罢工导致的航班取消，你还是需要道歉与补偿流程 —— 从这些问题中恢复仅仅是商业活动的正常组成部分。
* 如果有人从账户超额取款，银行可以向他们收取透支费用，并要求他们偿还欠款。透过限制每天的提款总额，银行的风险是有限的。
在许多商业场景中，临时违背约束并稍后透过道歉来修复，实际上是可以接受的。道歉的成本各不相同，但通常很低（以金钱或名声来算）：你无法撤回已传送的电子邮件，但可以传送一封后续电子邮件进行更正。如果你不小心向信用卡收取了两次费用，则可以将其中一项收费退款，而代价仅仅是手续费，也许还有客户的投诉。尽管一旦 ATM 吐了钱，你无法直接取回，但原则上如果账户透支而客户拒不支付，你可以派催收员收回欠款。
道歉的成本是否能接受是一个商业决策。如果可以接受的话，在写入资料之前检查所有约束的传统模型反而会带来不必要的限制，而线性一致性的约束也不是必须的。乐观写入，事后检查可能是一种合理的选择。你仍然可以在做一些挽回成本高昂的事情前确保有相关的验证，但这并不意味著写入资料之前必须先进行验证。
这些应用 **确实** 需要完整性：你不会希望丢失预订资讯，或者由于借方贷方不匹配导致资金消失。但是它们在执行约束时 **并不需要** 及时性：如果你销售的货物多于仓库中的库存，可以在事后道歉后并弥补问题。这种做法与我们在 “[处理写入冲突](ch5.md#处理写入冲突)” 中讨论的冲突解决方法类似。
#### 无协调资料系统
我们现在已经做了两个有趣的观察：
1. 资料流系统可以维持衍生资料的完整性保证，而无需原子提交、线性一致性或者同步的跨分割槽协调。
2. 虽然严格的唯一性约束要求及时性和协调，但许多应用实际上可以接受宽松的约束：只要整个过程保持完整性，这些约束可能会被临时违反并在稍后被修复。
总之这些观察意味著，资料流系统可以为许多应用提供无需协调的资料管理服务，且仍能给出很强的完整性保证。这种 **无协调（coordination-avoiding）** 的资料系统有著很大的吸引力：比起需要执行同步协调的系统，它们能达到更好的效能与更强的容错能力【56】。
例如，这种系统可以使用多领导者配置运维，跨越多个数据中心，在区域间非同步复制。任何一个数据中心都可以持续独立执行，因为不需要同步的跨区域协调。这样的系统的及时性保证会很弱 —— 如果不引入协调它是不可能是线性一致的 —— 但它仍然可以提供有力的完整性保证。
在这种情况下，可序列化事务作为维护衍生状态的一部分仍然是有用的，但它们只能在小范围内执行，在那里它们工作得很好【8】。异构分散式事务（如 XA 事务，请参阅 “[实践中的分散式事务](ch9.md#实践中的分散式事务)”）不是必需的。同步协调仍然可以在需要的地方引入（例如在无法恢复的操作之前强制执行严格的约束），但是如果只是应用的一小部分地方需要它，没必要让所有操作都付出协调的代价。【43】。
另一种审视协调与约束的角度是：它们减少了由于不一致而必须做出的道歉数量，但也可能会降低系统的效能和可用性，从而可能增加由于宕机中断而需要做出的道歉数量。你不可能将道歉数量减少到零，但可以根据自己的需求寻找最佳平衡点 —— 既不存在太多不一致性，又不存在太多可用性问题。
### 信任但验证
我们所有关于正确性，完整性和容错的讨论都基于一些假设，假设某些事情可能会出错，但其他事情不会。我们将这些假设称为我们的 **系统模型**（system model，请参阅 “[将系统模型对映到现实世界](ch8.md#将系统模型对映到现实世界)”）：例如，我们应该假设程序可能会崩溃，机器可能突然断电，网路可能会任意延迟或丢弃讯息。但是我们也可能假设写入磁碟的资料在执行 `fsync` 后不会丢失，记忆体中的资料没有损坏，而 CPU 的乘法指令总是能返回正确的结果。
这些假设是相当合理的，因为大多数时候它们都是成立的，如果我们不得不经常担心计算机出错，那么基本上寸步难行。在传统上，系统模型采用二元方法处理故障：我们假设有些事情可能会发生，而其他事情 **永远** 不会发生。实际上，这更像是一个机率问题：有些事情更有可能，其他事情不太可能。问题在于违反我们假设的情况是否经常发生，以至于我们可能在实践中遇到它们。
我们已经看到，资料可能会在尚未落盘时损坏（请参阅 “[复制与永续性](ch7.md#复制与永续性)”），而网路上的资料损坏有时可能规避了 TCP 校验和（请参阅 “[弱谎言形式](ch8.md#弱谎言形式)” ）。也许我们应当更关注这些事情？
我过去所从事的一个应用收集了来自客户端的崩溃报告，我们收到的一些报告，只有在这些装置记忆体中出现了随机位翻转才解释的通。这看起来不太可能，但是如果有足够多的装置执行你的软体，那么即使再不可能发生的事也确实会发生。除了由于硬体故障或辐射导致的随机储存器损坏之外，一些病态的储存器访问模式甚至可以在没有故障的储存器中翻转位【62】 —— 一种可用于破坏作业系统安全机制的效应【63】（这种技术被称为 **Rowhammer**）。一旦你仔细观察，硬体并不是看上去那样完美的抽象。
要澄清的是，随机位翻转在现代硬体上仍是非常罕见的【64】。我只想指出，它们并没有超越可能性的范畴，所以值得一些关注。
#### 维护完整性，尽管软体有Bug
除了这些硬体问题之外，总是存在软体 Bug 的风险，这些错误不会被较低层次的网路、记忆体或档案系统校验和所捕获。即使广泛使用的资料库软体也有 Bug：即使像 MySQL 与 PostgreSQL 这样稳健、口碑良好、多年来被许多人充分测试过的软体，就我个人所见也有 Bug，比如 MySQL 未能正确维护唯一约束【65】，以及 PostgreSQL 的可序列化隔离等级存在特定的写入偏差异常【66】。对于不那么成熟的软体来说，情况可能要糟糕得多。
尽管在仔细设计，测试，以及审查上做出很多努力，但 Bug 仍然会在不知不觉中产生。尽管它们很少，而且最终会被发现并被修复，但总会有那么一段时间，这些 Bug 可能会损坏资料。
而对于应用程式码，我们不得不假设会有更多的错误，因为绝大多数应用的程式码经受的评审与测试远远无法与资料库的程式码相比。许多应用甚至没有正确使用资料库提供的用于维持完整性的功能，例如外来键或唯一性约束【36】。
ACID 意义下的一致性（请参阅 “[一致性](ch7.md#一致性)”）基于这样一种想法：资料库以一致的状态启动，而事务将其从一个一致状态转换至另一个一致的状态。因此，我们期望资料库始终处于一致状态。然而，只有当你假设事务没有 Bug 时，这种想法才有意义。如果应用以某种错误的方式使用资料库，例如，不安全地使用弱隔离等级，资料库的完整性就无法得到保证。
#### 不要盲目信任承诺
由于硬体和软体并不总是符合我们的理想，所以资料损坏似乎早晚不可避免。因此，我们至少应该有办法查明资料是否已经损坏，以便我们能够修复它，并尝试追查错误的来源。检查资料完整性称为 **审计（auditing）**。
如 “[不可变事件的优点](ch11.md#不可变事件的优点)” 一节中所述，审计不仅仅适用于财务应用程式。不过，可审计性在财务中是非常非常重要的，因为每个人都知道错误总会发生，我们也都认为能够检测和解决问题是合理的需求。