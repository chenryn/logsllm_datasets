上面描述的HSTS头是被设计来确保所有的网站连接都是加密的。然而，它没有指出使用的关键点。
网站的信任是基于CA模型的。你的浏览器和操作系统绑定一些受信任的证书颁发机构的公钥，这些机构通常是专门的公司或者国家地区。当一个CA向你的域名颁发证书后，意味着信任这个CA的任何人都将自动信任使用这个证书加密的SSL流量。这些CA负责验证你拥有的域（可以是发送邮件、请求你托管文件或调查你的公司）。
两个CA给两个不同的人颁发同一个域名的证书，浏览器将信任这两个CA。这就导致了一个问题，尤其是因为CAs[可能被攻击](https://technet.microsoft.com/library/security/2524375)。这允许攻击者使用MiTM攻击他们想攻击的域名，即使那个域名使用了SSL和HSTS，也是一样。
HPKP头试着缓解这个问题。这个头让你绑定一个证书。当一个浏览器第一次看见这个头，它将保存这个证书。当每个请求达到max-age，除非从服务器发送的证书链中至少有一个指纹记录，否则浏览器将失败。
和上述的HSTS很像，HPKP头也有隐私影响。这些在它的[RFC](https://tools.ietf.org/html/rfc7469#section-5)中有描述。
**是否该使用它？**
可能不需要。
HPKP是一个非常非常锋利的尖刀。考虑到这个：如果你绑定了错误的证书，或者你丢失了密钥，或者某些事出错了，你将阻止你的用户访问你的网站。你能做的只是等待绑定过期。
[该文](https://blog.qualys.com/ssllabs/2016/09/06/is-http-public-key-pinning-dead)举了个关于它的例子，并且包含了一种有趣的攻击方式，使用HPKP勒索他们的受害者。
一个可选项是使用Public-Key-Pins-Report-Only头，这将在出错时报告出来，但是不会锁住用户。这至少让你知道用户被假证书攻击了。
**怎么做？**
两个选项是：
includeSubDomains——HPKP适用于子域名
report-uri——不可靠的行为将被报告
你不得不为你绑定的密钥生成一个base64加密的指纹，并且你不得不使用一个备份的密钥。怎么做，请参考这个[帮助文档](https://developer.mozilla.org/en-US/docs/Web/HTTP/Public_Key_Pinning#Extracting_the_Base64_encoded_public_key_information)。
**了解更多**
[RFC 7469](https://tools.ietf.org/html/rfc7469)
[HTTP Public Key Pinning(HPKP) – MDN](https://developer.mozilla.org/en-US/docs/Web/HTTP/Public_Key_Pinning)
**0x06 X-Frame-Options**
    X-Frame-Options: DENY
    X-Frame-Options: SAMEORIGIN
    X-Frame-Options: ALLOW-FROM https://example.com/
**为什么？**
在我们开始给漏洞命名前，我们先给黑客技术命名。“Clickjacking”是这些名字中的一个。
想法如下：你创建一个看不见的iframe，将它放在焦点中并引导用户输入。作为一个攻击者，你能欺骗人们玩一个基于浏览器的游戏，然而他们点击的是隐藏的显示twitter的iframe，迫使他们非自愿转推。
它听起来很蠢，但是它是一个有效的攻击。
**是否应该使用它？**
是的。如果你的应用是一个漂亮的雪花。你想别人破环它吗？
**怎么做？**
X-Frame-Options有3种模式：
DENY——没有人能够在iframe中放入页面
SAMEORIGIN——该页面只能由同一来源的某个iframe显示。
ALLOW-FROM——指定一个特定的可放入iframe的URL
要记住的一件事是你能按你想要的来增加iframes的深度，并且在这种情况下，SAMEORIGIN和ALLOW-FROM不被指定。也就是说如果你有一个3层的iframe，并且最里层的iframe有SAMEORIGIN，我们关心的是包裹它的iframe的来源还是最顶层的iframe？
**了解更多**
[RFC 7034](https://tools.ietf.org/html/rfc7034)
[X-Frame-Options – MDN](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Frame-Options)
**0x07 X-Content-Type-Options**
    X-Content-Type-Options: nosniff;
**为什么？**
这个头解决了被称为“MIME嗅探”的问题，它是一个浏览器的“特性”。
理论上，每次你的服务器响应一个请求，它应该是设置了一个Content-Type头以便告诉浏览器它是在获取HTML、gif或者flash等。不幸的是，网络总是会被打破，从来没有真正遵循的东西；许多人不会设置正确的Content-Type头。
结果会导致浏览器判断他们是否真的有用并且试图通过检查内容本身且忽略指定的类型来推断内容类型。如果它看起来像是gif，则展示一个gif，即使内容类型是text/html。同样，我们看似得到了一些HTML，即使服务器说他是个gif，我们依然应该展示它。
当你运行一个图片分享站点，并且用户能上传包含javascript的看起来像HTML的图片，你将遭受到存储型XSS攻击。
X-Content-Type-Options头的存在是告诉浏览器设置被告诉的类型。
**是否该使用它？**
是的，只是确保正确设置内容类型。
**怎么做？**
**了解更多**  
[X-Content-Type-Options – MDN](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Content-Type-Options)
##  
**0x08 Referrer-Policy**
     Referrer-Policy: "no-referrer"
        Referrer-Policy: "no-referrer-when-downgrade" 
        Referrer-Policy: "origin" 
        Referrer-Policy: "origin-when-cross-origin"
        Referrer-Policy: "same-origin" 
        Referrer-Policy: "strict-origin" 
        Referrer-Policy: "strict-origin-when-cross-origin" 
        Referrer-Policy: "unsafe-url"
**为什么？**
Referer头对于分析非常有用，但是对于隐私是件坏事。有时网站会苏醒并且认为一直发送它不是个好主意。
Referrer-Policy头在浏览器设置Referer头时可以指定。
**是否应该使用它？**
由你自己决定，但是它可能是个好东西。如果你不关心你用户的隐私，可以考虑它作为分析的一种好的方法。
设置Referrer-Policy：“no-referrer”
**怎么做？**
**了解更多**
[Referrer Policy – MDN](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Referrer-Policy)
**0x09 Cookie Options**
    Set-Cookie: =; Expires=; Secure; HttpOnly; SameSite=strict
**为什么？**
这不是个安全的头，但是有3个不同的选项你应该注意：
Cookies标记为Secure将只能通过HTTPS提供服务。这阻止了一些人在MiTM攻击中读取cookies，它可以强制浏览器访问一个指定的网页。
HttpOnly是一个误称，并且和HTTPS无关。Cookies标记为HttpOnly将阻止在javascript中访问。因此如果有XSS缺陷，攻击者不能立即偷到cookies。
SameSite帮助防御CSRF攻击。这种攻击是用户可能在访问不同的网站，无意中欺骗他们对你的网站发出请求，例如，用于GET请求的图片，或者使用javascript提交POST请求，通常使用CSRF令牌来防御这种攻击。Cookie被标记为SamSite将不会发送到不同的站点。
它有两种模式，lax和strict。Lax模式允许cookie作为GET请求的顶层内容被发送（例如你点击一个链接）。Strict不发送任何第三方的cookies。
**是否应该使用它？**
绝对应该设置Secure和HttpOnly。不幸的是，SameSite cookies只在Chrome和Opera中提供，因此现在可以忽略他们。
**怎么做？**
**了解更多**
[Cookies – MDN](https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies#Secure_and_HttpOnly_cookies)