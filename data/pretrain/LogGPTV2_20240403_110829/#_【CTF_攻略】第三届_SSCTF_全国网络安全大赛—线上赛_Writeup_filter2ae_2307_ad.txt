通过GitHack把文件下载下来后继续分析：
    root@kali:~/Desktop/GitHack/dist/60.191.205.87# git log
    commit 6a0bbb4f6ce6d101c0cf5abac4b04ff004b1a918
    Author: zhang tie 
    Date:   Wed Apr 26 06:10:14 2017 -0400
        this is flag
    commit 8894bb4d45643d52b5eb8175710999fcd398ebd4
    Author: zhang tie 
    Date:   Wed Apr 26 06:08:12 2017 -0400
        666666666
    commit 473e9cce7391e913ffcf10b96ba6e4c0b950fe8e
    Author: zhang tie 
    Date:   Wed Apr 26 06:05:28 2017 -0400
        test pass
    commit 9ab1451776fb32e82c2524fc4f37fa3f33ceae2f
    Author: zhang tie 
    Date:   Wed Apr 26 05:46:06 2017 -0400
        password?
    commit eac8d383f192730a605bb5d3115aa4bbba8a99ea
    Author: zhang tie 
    Date:   Wed Apr 26 05:32:31 2017 -0400
        pass??
    commit cd7bee8ad1b5807b7136fd8fb0c9ae853204c1fc
    Author: zhang tie 
    Date:   Wed Apr 26 05:29:33 2017 -0400
        pass????
在 8894bb4d45643d52b5eb8175710999fcd398ebd4 下看到了
    root@kali:~/Desktop/GitHack/dist/60.191.205.87# git show 8894bb4d45643d52b5eb8175710999fcd398ebd4
    warning: refname '8894bb4d45643d52b5eb8175710999fcd398ebd4' is ambiguous.
Git 通常不会创建一个以40位十六进制字符命名的引用，因为当你提供40位
十六进制字符时将被忽略。不过这些引用也可能被错误地创建。例如：
      git checkout -b $br $(git rev-parse ...)
当 "$br" 空白时一个40位十六进制的引用将被创建。请检查这些引用，
可能需要删除它们。用 "git config advice.objectNameWarning false"
命令关闭本消息通知。
    commit 8894bb4d45643d52b5eb8175710999fcd398ebd4
    Author: zhang tie 
    Date:   Wed Apr 26 06:08:12 2017 -0400
        666666666
    diff --git a/ssctf/phpcms/templates/flag.txt b/ssctf/phpcms/templates/flag.txt
    new file mode 100644
    index 0000000..7746a53
    --- /dev/null
    +++ b/ssctf/phpcms/templates/flag.txt
    @@ -0,0 +1 @@
    +SSCTF{xsL3HOvFlV+H40s0mhszc5t1x38EU0ZIFJHZ/h2sC3U=}
    SSCTF{xsL3HOvFlV+H40s0mhszc5t1x38EU0ZIFJHZ/h2sC3U=}
但是 这是被加密了的字符串
继续往下看，在
    root@kali:~/Desktop/GitHack/dist/60.191.205.87# git show 9ab1451776fb32e82c2524fc4f37fa3f33ceae2f
    commit 9ab1451776fb32e82c2524fc4f37fa3f33ceae2f
    Author: zhang tie 
    Date:   Wed Apr 26 05:46:06 2017 -0400
        password?
    diff --git a/ssctf/pass.php b/ssctf/pass.php
    index 23fdea9..f0acac5 100644
    --- a/ssctf/pass.php
    +++ b/ssctf/pass.php
    @@ -1 +1,30 @@
    -this is pass?
    +
找到了加密方法 通过分析，我们知道这是 RC4加密，那么我只需要对密文重新一次加密便能得到明文
所以修改下php，重新加密后，我们得到flag f6daf9bf00e45f52f23d844f20952503
**Misc150 互相伤害！！！**
解压出来是个流量包，
从流量包中可以导出一堆图片 一堆图片 不对 是一堆表情包
通过这张图片的二维码 扫到信息一
U2FsdGVkX1+VpmdLwwhbyNU80MDlK+8t61sewce2qCVztitDMKpQ4fUl5nsAZOI7
bE9uL8lW/KLfbs33aC1XXw==
从图中的 CTF 以及 AES 等信息推测，这是一个AES加密后的密文，密钥极有可能是 CTF
通过在线解除一串字符串:668b13e0b0fc0944daf4c223b9831e49。但这并不是flag
通过对所以图片 binwalk解析，
    binwalk *.jpg -e
在第11张图片中看到一个压缩包，尝试用上述解出来的字符串解压
得到一张二维码中间还有一个二维码的图片，反色扫描得到flag
**Misc200 我们的秘密是绿色的**
这是一个图片隐写 需要运用到 OurSecret这个隐写工具
通过题目信息，key是图中绿色的文字 0405111218192526 得到一个 名字为 try的压缩包
压缩包密码提示： 你知道coffee的生日是多少么~~~
通过字典爆破得到密码是： 19950822
之后进入下一层 通过明文攻击得到
Advanced Archive Password Recovery 统计信息:
加密的 ZIP/RAR/ACE/ARJ 文件: C:UserswingsDesktopflag.zip
总计口令: n/a
总计时间: 4m 11s 358ms
平均速度(口令/秒): n/a
这个文件的口令 : Y29mZmVl
十六进制口令: 59 32 39 6d 5a 6d 56 6c
得到密文Y29mZmVl
进入下一层伪加密，改加密位后
得到 qddpqwnpcplen%prqwn_{_zz*d@gq} 分别解栅栏 凯撒后得到 flag{ssctf_@seclover%coffee_*}
**Misc300 你知道我在等你么**
对 你知道我在等你吗.mp3 binwalk 处理。得到三个文件，一个提示，一个压缩包，一个MP3
对 mp3文件 strings *.mp3 后 得到 falg_config_@tl_ 这是压缩包密码，从压缩包中解压出一张 咖啡(coffee)图片。
在图片中发现 coffee字样，以及IHDR
猜测后面是一张png图片，从coffee开始把数据dump下来，并保存为png图片，修改png头。得到张二维码，扫描二维码是一个下载链接，
下载下来是txt 文件，但是在内容中看到了PK字样，改为 zip后缀。
然后又是一个伪加密….
得到 a2V5aXMlN0JzZWMxb3ZlciUyNV82dWdzY2FuX0Bjb2ZmZWUlN0Q=
解base64得到 'keyis%7Bsec1over%25_6ugscan_@coffee%7D'
flag是 keyis{sec1over%6ugscan@coffee}
**Web渗透**
**Web100 捡吗？**
题目考的是ssrf，一开始扫描很浪费时间，而且导致服务器几乎崩溃，后来给了hint，然后利用大小写把ftp换成FTP绕过，拿到flag。
    http://120.132.21.19/news.php?url=10.23.173.190/news.php?url=FTP://172.17.0.2/flag.txt
    ssctf{85c43ae2851ba3142364b65d3f1e360f}
**Web200 弹幕**
先分析题目，利用websocket在网页中显示弹幕，发现一个特殊的welcome弹幕是一个xss平台payload，然后得到xss平台地址http://117.34.71.7/xssHentai
admin:admin登录，cookie中提示uid为1拿到flag，而admin用户uid不是1。然后发现xss平台接收xss时有xss漏洞。然后http://117.34.71.7/xssHentai/request/1/?body=YOUR
XSS PAYLOAD，然后收到cookie即flag。
**Web300 白吗?全是套路**
看上去有各种信息，但是很多信息都不真实，网站压缩包也没爆破出密码。最后通过web1点ssrf利用file协议读取到源码。
submit.php
    error;
        exit("aaaa");
    }
    if(!$con->select_db("ctf1")){
        echo $con->error;
    }
    if(!$con->query("SET NAMES utf8")){
        echo $con->error;
    }
    $xss=$_POST["sub"];
    $str = addslashes($xss);
    /**********銮峰彇IP************/
    class Action  
    {  
        function get_outer()  
        {  
            $url = 'http://www.ip138.com/ip2city.asp';  
            $info = file_get_contents($url);  
            preg_match('|(.*?)|i', $info, $m);  
            return $m[1];  
        }  
        function get_inter()  
        {  
            $onlineip = '';  
            if (getenv('HTTP_CLIENT_IP') && strcasecmp(getenv('HTTP_CLIENT_IP'), 'unknown')) {  
                $onlineip = getenv('HTTP_CLIENT_IP');  
            } elseif (getenv('HTTP_X_FORWARDED_FOR') && strcasecmp(getenv('HTTP_X_FORWARDED_FOR'), 'unknown')) {  
                $onlineip = getenv('HTTP_X_FORWARDED_FOR');  
            } elseif (getenv('REMOTE_ADDR') && strcasecmp(getenv('REMOTE_ADDR'), 'unknown')) {  
                $onlineip = getenv('REMOTE_ADDR');  
            } elseif (isset($_SERVER['REMOTE_ADDR']) && $_SERVER['REMOTE_ADDR'] && strcasecmp($_SERVER['REMOTE_ADDR'], 'unknown')) {  
                $onlineip = $_SERVER['REMOTE_ADDR'];  
            }  
            return $onlineip;  
        }  
    }  
    $p = new Action();
    $intip = $p->get_inter();
    $outip2= $intip;
    @mkdir("/tmp/ids",0777,true);
    $sql="insert into ctf1(xss,ip,time,wai_ip) values('$str','$intip',NOW(),'$outip2')";
    if($str=$con->query($sql)){
        echo "";
        $insertid = mysqli_insert_id($con);
        file_put_contents("/tmp/ids/".$insertid,"a");
    }
    else {
        echo "";
    }
    ?>
发现直接post提交参数sub为xss payload即可。然后得到referer打开，查看源码发现script标签引用了/admin/js.php
然后直接读取js.php即可拿到flag
view-source:http://120.132.21.19/news.php?url=10.23.173.190/news.php?url=127.0.0.1/admin/js.php
**Web500 WebHook**
题目设计问题导致出现很多非预期，这些就不提了，给一个正确的思路。
首先题目给了github项目，里面有服务器地址。然后审计python源码，有一个内置的KEY上线时被修改，然后大概试了一下，是ssctf。有了KEY就能添加一个github或者coding上的项目，然后每次调用push接口，会从项目得到源码，并把build.json中的文件夹或文件压缩放到outfile目录。然后用户用repo名字和添加repo时设置的密码登录即可下载到这个压缩文件。
这个时候就能读取任意文件或文件夹了。然后下载flag项目，发现里面并没有flag。很久之后在/home/www-data/.ssh/目录下找到私钥，然后读取repos.json拿到flag项目地址。自己利用ssh私钥git
clone一下或者在下载到的flag目录git pull一下，就能得到flag.txt
    ssh -T PI:EMAIL -i id_rsa
    git clone PI:EMAIL:ljgame/flag.git
    cat flag.txt
    SSCTF{02d6d06ec9e35d11d1f421a400edbb06}
Web500 CloverSec Logos
在显示图片处找到注入，参数由双引号包裹，经过简单的字符串替换。直接布尔盲注即可，information_schema库好像是由于权限问题跑不出来数据，然后手动猜测了一下（后来放出了hint），表名user，字段名username,password。跑出来密码20位，然后去掉前三后一，cmd5解密是admin^g。成功登陆，然后题目提示vim。访问index.php.swp看到源码，需要使得file_get_contents($_GET[secret])===‘1234’
然后让secret=php://input，post数据为1234即可。
然后读取include.php.swp
这里有一个过滤，利用+就不会正则匹配到数字。把cookie中token参数设置为
    O:+4:”Read":1:{s:4:"file";s:63:"php://filter/read=convert.base64-encode/resource=ssctf_flag.php";}
即可读取flag文件
**  
**
**传送门**
* * *
[**第三届 SSCTF 全国网络安全大赛—线上赛圆满结束！**](http://bobao.360.cn/ctf/activity/421.html)