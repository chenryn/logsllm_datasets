Inside  Flash:  Flash  Exploit  
Detec4on  Uncovered 
Ga1ois	
  &	
  Bo	
  Qu 
About  us 
•  Security	
  Researchers	
  in	
  PANW	
•  Work	
•  IPS	
•  APT	
  Detec=on	
•  A>er	
  work	
•  Vulnerability	
  discovery	
•  Exploit	
  technique	
  researching	
Agenda 
•  Iden=fy	
  (Possible)	
  Exploit	
•  Stop	
  Exploit	
•  Detect	
  Exploit	
Part	
  1	
  :	
  Iden=fy	
  Possible	
  Exploit	
Find	
  vector	
  in	
  loop	
  using	
  sta=c	
  detec=on	
Find  opcode  paools	
•  Swfdump.py	
  in	
  mecheye-­‐fusion	
•  Swfdump.jar/swfdump.exe	
  in	
  ﬂex	
  –	
  we	
  use	
  it	
•  3	
  types	
  of	
  loop	
•  For	
•  While	
•  Do/while	
Simplest  situa4on 
MXMLC 
Swfdump 
SWF 
Do…while 
for 
AS3 
Algorithm 
def	
  FindVecInLoop:	
For	
  i	
  in	
  range(0,len(line)):	
  If	
  ﬁnd	
  jump	
  opcode	
  i	
  =	
  line_of_jump_opcode	
  get	
  Jump_label	
  for	
  j	
  in	
  range(line_of_jump_opcode+1,	
  len(line))	
  If	
  ﬁnd	
  jump_label	
  get	
  cur_line_cnt	
  for	
  k	
  in	
  range(cur_line_cnt+1,	
  len(line))	
  if	
  ﬁnd	
  if:	
  get	
  the	
  if_label	
  if	
  line_of_if_label	
  ==	
  line_of_jump_opcode+1	
  print	
  ﬁnd	
  loop	
  get	
  loop_body	
  ﬁnd	
  vector	
  in	
  loop_body	
  check	
  the	
  3rd	
  argument	
  of	
  construct,	
  if	
  vector	
  bingo!	
Find  opcode  paer	
  Free)	
  bugs	
•  OBA	
•  UAF	
4096 
4096 
4096 
1	
  page NO_Access 
Heap	
  block 
1	
  page 
OBA 
NO_Access 
CRASH	
  ! 
4096 
4096 
4096 
free 
NO_Access 
use 
CRASH	
  ! 
Custom  Heap  in  Flash  MMgc 
GCHeap 
GC 
FixedMalloc 
m_allocs[
] 
Used	
  buﬀer 
Ptr	
  to	
  next	
  free	
  block 
Free	
  buﬀer 
Same	
  size	
  in	
  one	
  bucket 
Diﬀerent	
  sizes	
Custom  Heap  in  Flash  MMgc 
GCHeap 
GC	
Toplevel:	
ArrayObject	
ByteArrayObject	
VectorObject	
…	
NaTve:	
BitmapDataObject	
SoundObject	
… 
FixedMalloc	
All	
  of	
  the	
  internal	
  buﬀer	
ByteArrayBuﬀer	
  –	
  UAF	
  Bugs	
VectorBuﬀer	
  –	
  Used	
  to	
  Arbitrary	
  Read/Write	
  in	
  the	
  exploit	
BitmapDataBuﬀer	
  –	
  OBA	
  Bugs 
Vulnerable	
  buﬀer	
  and	
  exploited	
  buﬀer	
  are	
  all	
  allocated	
  here.	
All	
  interes=ng	
  things	
  happened	
  here.	
From  AS3  To  Memory 
Take	
  ByteArray	
  As	
  An	
  Example	
var	
  ba:ByteArray	
  =	
  new	
  ByteArray();	
ba.length	
  =	
  0x80; 
/*staTc*/	
  avmplus::ScriptObject*	
  FASTCALL	
avmplus::ByteArrayClass::createInstanceProc(avmplus::ClassClosure*	
  cls)	
{	
  return	
  new	
  (cls-­‐>gc(),	
  MMgc::kExact,	
  cls-­‐>getExtraSize())	
avmplus::ByteArrayObject(cls-­‐>ivtable(),	
  cls-­‐>prototypePtr());	
} 
staTc	
  void	
  *operator	
  new(size_t	
  size,	
  GC	
  *gc,	
GCExactFlag,	
  size_t	
  extra)	
{	
  return	
  gc-­‐>AllocExtraRCObjectExact(size,	
extra);	
} 
  ByteArrayObject::ByteArrayObject(VTable*	
  ivtable,	
  ScriptObject*	
delegate)	
  :	
  ScriptObject(ivtable,	
  delegate)	
  ,	
  m_byteArray(toplevel())	
  {	
  c.set(&m_byteArray,	
  sizeof(ByteArray));	
  ByteArrayClass*	
  cls	
  =	
  toplevel()-­‐>byteArrayClass();	
  m_byteArray.SetObjectEncoding((ObjectEncoding)cls-­‐
>get_defaultObjectEncoding());	
  toplevel()-­‐>byteArrayCreated(this);	
ByteArrayObject	
  are	
  managed	
  by	
  GC 
From  AS3  To  Memory 
Take	
  ByteArray	
  As	
  An	
  Example	
var	
  ba:ByteArray	
  =	
  new	
  ByteArray();	
ba.length	
  =	
  0x80; 
ByteArrayObject::set_length(unsigned	
  int	
  value) 
ByteArray::SetLengthFromAS3(unsigned	
  int	
  newLength) 
ByteArray::SetLengthCommon(unsigned	
  int	
  newLength,	
  bool	
  calledFromLengthSeker) 
ByteArray::UnprotectedSetLengthCommon(unsigned	
  int	
  newLength,	
  bool	
  calledFromLengthSeker)	
ByteArray::Grower::SetLengthCommon(unsigned	
  int	
  newLength,	
  bool	
  calledFromLengthSeker) 
ByteArray::Grower::EnsureWritableCapacity() 
ByteArray::Grower::ReallocBackingStore 
From  AS3  To  Memory 
Take	
  ByteArray	
  As	
  An	
  Example	
void	
  FASTCALL	
  ByteArray::Grower::ReallocBackingStore(uint32_t	
  newCapacity)	
{	
  ...	
  m_oldArray	
  =	
  m_owner-­‐>m_buﬀer-­‐>array;	
  m_oldLength	
  =	
  m_owner-­‐>m_buﬀer-­‐>length;	
  m_oldCapacity	
  =	
  m_owner-­‐>m_buﬀer-­‐>capacity;	
  uint8_t*	
  newArray	
  =	
  mmfx_new_array_opt(uint8_t,	
  newCapacity,	
  MMgc::kCanFail);	
  …	
  m_owner-­‐>TellGcNewBuﬀerMemory(newArray,	
  newCapacity);	
  if	
  (m_oldArray){	
  VMPI_memcpy(newArray,	
  m_oldArray,	
  min(newCapacity,	
  m_oldLength));	
  if	
  (newCapacity	
  >	
  m_oldLength)	
  VMPI_memset(newArray+m_oldLength,	
  0,	
  newCapacity-­‐m_oldLength);	
  }else{	
  VMPI_memset(newArray,	
  0,	
  newCapacity);	
  }	
  m_owner-­‐>m_buﬀer-­‐>array	
  =	
  newArray;	
  m_owner-­‐>m_buﬀer-­‐>capacity	
  =	
  newCapacity;	
  …	
} 
Mmfx_	
  is	
  a	
  series	
  Macro	
  in	
  FixedMalloc 
ByteArrayDataBuﬀer	
  is	
  managed	
  by	
  FixedMalloc 
From  AS3  To  Memory 
Take	
  ByteArray	
  As	
  An	
  Example	
var	
  ba:ByteArray	
  =	
  new	
ByteArray();	
ba.length	
  =	
  0x80; 
ByteArrayObject	
  [managed	
  by	
  GC]	
02A944A8	
  cc	
  4b	
  18	
  01	
  01	
  df	
  07	
  80	
  d8	
  bd	
  f2	
  04	
  e8	
  52	
  9f	
  05	
02A944B8	
  c0	
  44	
  a9	
  02	
  40	
  00	
  00	
  00	
  20	
  4a	
  18	
  01	
  34	
  4a	
  18	
  01	
02A944C8	
  28	
  4a	
  18	
  01	
  3c	
  4a	
  18	
  01	
  18	
  6c	
  a3	
  02	
  10	
  00	
  5b	
  00	
02A944D8	
  88	
  c3	
  9f	
  05	
  00	
  00	
  00	
  00	
  00	
  00	
  00	
  00	
  00	
  da	
  14	
  01	
02A944E8	
  a0	
  8b	
  5a	
  00	
  01	
  00	
  00	
  00	
  00	
  00	
  00	
  00	
  2c	
  4a	
  18	
  01	
02A944F8	
  03	
  00	
  00	
  00	
  00	
  00	
  00	
  00	
ByteArrayBuﬀer	
  [managed	
  by	
  FixedMalloc]	
059FD010	
  41	
  41	
  41	
  41	
  41	
  41	
  41	
  41	
  41	
  41	
  41	
  41	
  41	
  41	
  41	
  41	
059FD020	
  41	
  41	
  41	
  41	
  41	
  41	
  41	
  41	
  41	
  41	
  41	
  41	
  41	
  41	
  41	
  41	
059FD030	
  41	
  41	
  41	
  41	
  41	
  41	
  41	
  41	
  41	
  41	
  41	
  41	
  41	
  41	
  41	
  41	
059FD040	
  41	
  41	
  41	
  41	
  41	
  41	
  41	
  41	
  41	
  41	
  41	
  41	
  41	
  41	
  41	
  41	
059FD050	
  41	
  41	
  41	
  41	
  41	
  41	
  41	
  41	
  41	
  41	
  41	
  41	
  41	