to guide the system to load the initialization function in
the malicious module. In the latest issue 68 of phrack [4],
styxˆ proposes a similar approach to infecting modules in
kernel versions 2.6.x and 3.0.x. It redirects init module to load
function evil instead of original init function. In order to enable
malicious modules to invoke the original init function, it also
updates the symbol binding of init from local to global. The
effects of these two approaches are equivalent and we choose
to use the former method to inject DR rootkit into an E1000
NIC driver as our target.
The DR rootkit leverages a debug register-based hooking
engine, which does not require modiﬁcation to the system
call table, to perform traditional rootkit behavior, like hiding
processes, sockets, and ﬁles. To be more speciﬁc, it determines
the name of a ﬁle it wants to hide. (In the version we obtain
the name is AAA.) Then it hides the presence of this ﬁle
in the ﬁle system by modifying the ﬁle listing result in the
directory. When executing this ﬁle, the rootkit escalates AAA’s
privilege to root, hides all the sockets created, hides all the
child processes forked, and prevents other processes from
opening ﬁles owned by AAA.
The trojaned driver contains both the functionality of a
benign E1000 NIC driver and a malicious kernel rootkit. We
pass it to DRIP to cripple its malicious behavior and retain
the benign NIC driver behavior. We select and synthesize
test cases from LTP (Linux Test Project) [15], Linux utility
programs, and Iperf to cover the benign functionalities of
E1000 NIC driver and the reliability of the overall system.
We have validated that the puriﬁed driver behaves the same
as a benign E1000 NIC driver with the malicious operations
from the DR rootkit eliminated.
Case Study II: E1000 NIC driver with kernel function
redirection under Linux: From case study I, we learn that we
can implant malicious code inside the initialization function
to install system call hooks. In fact, when the driver code
invokes the kernel function, we can intercept and redirect any
function invocation to a malicious function ﬁrst. The malicious
function can act as a proxy to invoke the original function and
return the result to the original invocation. This kernel function
redirection technique is proposed in the libkernsh of ERESI
[8].
We prepare an interposition kernel module, which contains
malicious functions from the KBeast rootkit and link it with the
E1000 NIC driver to generate a trojaned driver. The relocation
table of this new driver contains all the addresses of code/data
that need to be ﬁxed up during loading. We scan this table to
ﬁnd the function invocation we want to hijack and modify
it
to detour to the malicious function in the interposition
module. The payload, KBeast, is a new kernel rootkit based
on other well-known rootkits and supports the latest Linux
kernel versions. It contains traditional rootkit functionalities,
e.g., process hiding, ﬁles hiding, keystroke logging, local root
escalation, etc. Its basic idea is to patch the system call table
of Linux and detour system calls to its fake functions that
are crafted by the attacker. Because system calls are hijacked,
KBeast can easily manipulate the intermediate results and
return fake results to the user. We select similar test cases
as in Case Study I to build our test suite to ensure the
reliability of the system and core benign functionalities of the
E1000 NIC driver. After puriﬁcation, we validate that KBeast’s
cloaking effects on the system have been eliminated and we
still preserve the E1000 driver’s original functionalities.
Case Study III: Kbdevents under Linux: Kprobes [23] is
a lightweight debugging mechanism in the Linux kernel that
allows developers to intercept kernel routines at runtime to
collect debugging information. Kbdevents [24] is a Linux
kernel module based on Kprobes to intercept keyboard events.
It can be used as a debugging tool to verify the correctness of
the keyboard driver. On every key pressed, Kbdevents has ad-
ditional functionality to launch user scripts from kernel space,
e.g., keylogger to dump keystrokes into a ﬁle, printscr to take
screenshots and typewriter to imitate typewriter sounds. These
supplementary capabilities are not necessary for debugging
purposes. So we can perform puriﬁcation on Kbdevents to
minimize it to contain only the debugging functionality. We
build a special test suite to simulate keystrokes out of VM,
i.e., generate keyboard interrupt from QEMU, and capture
them in the guest VM to verify the correctness of Kbde-
vents’ debugging functionality. After puriﬁcation, we ﬁnd all
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 07:46:27 UTC from IEEE Xplore.  Restrictions apply. 
kernel API invocations related to launching user scripts from
the kernel (e.g., call usermodehelper {setup,exec}) have been
removed from the driver. The puriﬁed driver can still intercept
keystrokes to debug the Linux keyboard driver.
Case Study IV: Infected Kbdclass driver by DaMouse under
Windows: DaMouse [6] is a PE driver infection technique
under Windows. It implants existing malicious code into a
windows device driver in the system. It utilizes a virus coding
technique called Entry-Point Obscuring (EPO) to patch API
invocation inside the device driver. When this patched API is
invoked, it installs a permanent System Service Dispatch Table
(SSDT) hook to redirect the system call to the hook function
inside the driver. The hook function contains malicious code
to ﬁlter the results and can eventually complete the procedure
by invoking the original system call.
In this case study, we use DaMouse to infect kbdclass.sys,
the keyboard class driver in Windows. DaMouse patches the
Kbdclass driver and install the SSDT hook at NtOpenProcess.
Then system calls to NtOpenProcess are redirected to the
hook function called NewNtOpenProcess. The ﬁlter code in
the hook function determines whether the target process is
iexplorer.exe, which belongs to the Internet Explorer. If so, the
NtOpenProcess request will be denied. The symptom notice-
able to the user is that he/she cannot open a new web page in
the Internet Explorer. For other processes, the malicious code
extracts the NtOpenProcess’ arguments, e.g., pid and name, of
calling process and dumps the result through DbgPrint. We
build the test suite for Kbdclass through sending keystrokes
from QEMU into VM, which is similar to Case Study III,
and verify them in the test program within the VM. After
puriﬁcation, we can keep the keyboard driver’s functionality,
Internet Explorer can open new tabs successfully and there is
no process information leakage any more.
Case Study V: Beep driver infected with klog as payload
under Windows: In previous case studies, we have applied
DRIP to purify drivers infected by existing binary infection
tools. In this case study, we try to prove the generality of
DRIP by purifying trojaned drivers generated by a binary trans-
formation tool newly developed in our own research efforts.
This technique enables transplanting binary functional module
extracted from one binary into another binary. We extract the
malicious functions, i.e., keyboard attaching and keystrokes
dumping, from klog, which is a well-known Windows key-
board sniffer. Then we utilize our own binary transformation
technique to implant the extracted functions into the beep
driver of Windows. In order to check if the beep driver works
properly, we add some functionality-checking logic in the
emulated pc speaker in QEMU to verify the beep events.
After puriﬁcation, we load the puriﬁed beep driver into the
production environment and it works as expected and keyboard
can no longer dump sniffed keystrokes to a ﬁle any more.
B. Performance Evaluation
The time it takes for DRIP to purify a speciﬁc driver is
highly dependent on the driver’s code complexity, coverage
of test suite, and hardware conﬁguration. We present
the
complete performance statistics of puriﬁcation process for each
trojaned driver in Table II. It shows the ratio of “Removed
Function Invocations” to “Recorded Function Invocations”, the
Name
E1000+KBeast
E1000+DR
E1000+Adore-ng
E1000+Sebek
E1000+Redir
Kbdevents
Null+SSDT
Kbdclass+SSDT
E1000325+SSDT
E1000325+Klog
Beep+Klog
Ratio1
57/69
13/25
7/23
13/34
37/53
8/12
5/7
13/21
20/24
22/28
24/35
Time
42min 13s
21min 23s
20min 46s
19min 19s
35min 38s
8min 25s
4min 4s
15min 31s
22min 15s
24min 35s
31min 1s
NTC2
37
40
39
35
34
13
12
32
19
19
44
TABLE II: Performance evaluation results with a spectrum of
trojaned drivers
1 Ratio here represents the ratio of “Removed
Function Invocations” to “Recorded Function
Invocations”.
2 NTC stands for “Number of Testing Cycles”
Fig. 5: Comparison of Normalized CPU Performance between
Trojaned Drivers and Puriﬁed Drivers
puriﬁcation time, and the number of testing cycles. Our results
indicate that DRIP is suitable for ofﬂine driver puriﬁcation.
We next measure the system performance overhead with
the puriﬁed driver and compare it with system performance
with the trojaned driver. We use SPECINT 2000 under Win-
dows and UnixBench under Linux to measure the CPU perfor-
mance. We normalize the performance results and present them
in Figure 5. The left bars indicate the normalized performance
scores (the higher the better) after loading the original trojaned
driver. The right bars are normalized performance scores after
loading the puriﬁed driver. In the experiments with trojaned
E1000+KBeast/E1000+Redir, the system crashed when exe-
cuting the test case ﬁle copy in UnixBench. The reason is
that KBeast rootkit cannot survive the workload of test case
ﬁle copy in the UnixBench and both trojaned drivers contain
the KBeast’s code. After puriﬁcation, both drivers support the
benchmark successfully because the KBeast functionality has
been eliminated. For the other experiments, the puriﬁed drivers
improve benchmark performance by 1% to 45% compared
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 07:46:27 UTC from IEEE Xplore.  Restrictions apply. 
 0 0.2 0.4 0.6 0.8 1E1000+KBeastE1000+DRE1000+adore-ngE1000+SebekE1000+RedirKbdeventsNull+SSDTKbdclass+SSDTE1000325+SSDTE1000325+KlogBeep+KlogNormalized ScoreComparison of Normalized CPU Performance between Trojaned Drivers and Purified DriverscrashedOriginalPurifiedcrashedsuite, but it does not mean all these removed invocations are
useless. For example, we have found some memory deallo-
cation invocations have been removed. This may not impact
the execution of the test suite over a short period, but it will
cause memory leaks and affect the performance of the system
in the long term. We can add some test cases to prevent these
invocations from being removed. For example, we can measure
the memory usage of the driver and report failure if it exceeds
a threshold. Another simple solution is to add these well-
known functions with speciﬁc functionalities into a white list
of functions to keep and skip them when proﬁling the driver.
Self-contained Malicious Code: Some malicious code can
jeopardize the kernel without invoking any kernel APIs. For
example, some kernel malware can directly modify the kernel
memory to achieve their malicious effects. They can evade
DRIP’s puriﬁcation as we monitor at the granularity of API
invocations. But
the functionalities of such self-contained
malicious code are limited and it is hard for them to adapt
to new kernel versions. We will improve DRIP to monitor at
the level of memory operations during the proﬁling phase to
address this problem in the future.
Limitation of the Testing Environment: Our Testing Envi-
ronment is based on QEMU to test the drivers. We can support
kernel drivers that extend the core kernel functionalities. For
the device drivers that control real hardware devices, we can
only support those whose devices are emulated by QEMU.
In the DDT research effort [14],
the authors propose the
symbolic device, which presents itself as a virtual device to
facilitate symbolic execution of driver code. This technique
can complement DRIP to address the problem that some
devices are not emulated by QEMU. We consider integration
of symbolic device our future work.
VI. RELATED WORK
Online Device Driver Isolation: Nooks [9] involves a
shadow driver mechanism to conceal driver failures from
applications by monitoring the state of real drivers during
normal operation. It inserts itself when failure occurs, thus
improving the reliability of the overall system. SafeDrive [25]
improves kernel extension reliability by adding type-based
checking to driver code and enforcing runtime memory safety.
In order to leverage user level programming tools and reduce
kernel
level faults introduced by drivers, Microdriver [26]
partitions an existing driver into a kernel level driver handling
performance critical tasks and a user level driver processing
low-performance issues. The Nexus [27] operating system
moves the device driver to user space and it leverages device-
speciﬁc reference monitors to validate that all the interactions
between drivers and devices conform to safety speciﬁcations.
To protect untrusted device drivers from compromising a
system, SUD [10] leverages recent hardware support to conﬁne
operations of devices and allows unmodiﬁed Linux device