attack. 
to  setuid()  (i.e., addr_setuid). 
Operation 2 depicts the manipulation of the GOT entry 
corresponding 
  When 
Sendmail  is  started,  addr_setuid  is  loaded  to  the  memory. 
When setuid() is called, the value of  addr_setuid is used as 
the  function  pointer  to  setuid().  Following  the  predicate 
depicted  by  pFSM3,  the  system  should  check  whether  the 
value  of  addr_setuid  is  unchanged  since  it  was  loaded  to 
the memory. If this is not the case (i.e., the addr_setuid has 
been tampered), the program should not call to the location 
indicated  by  the  corrupted  addr_setuid.  However,  the 
implementation  of  Sendmail  does  not 
corresponding 
perform  the  check  on  the  addr_setuid  (IMPL_ACPT=-♦-
in  pFSM3),  and  accepts  any  value  of  addr_setuid.  As  a 
result,  the  program  again  makes  the  hidden  (dotted) 
transition  and  the  control  jumps  to  the  malicious  code 
(Mcode) when setuid() is called. 
Operation 1:
Write debug level i to 
tTvect[x]
-♦get text strings 
str_x and str_i
Reject State
s t r _ x ) > 2 3 1 ♦ -
b y
?
(IMPL_REJ)
Elementary
Activity 1
i n t e g e r
(
r e p r e s e n t e d
( S P E C _ R E J )
pFSM1
(SPE
(integerrepresented
bystr_x)≤
CPT)
C_A
231♦
-
P
(IM
T)
P
C
L_A
-♦-
-♦convert str_i and str_x
to integer i and x
SPEC Check State
Accept State
.GOT entry of function setuid (i.e., 
addr_setuid ) points to Mcode
Operation 2:
Manipulate the 
GOT entry  of 
function setuid
(i.e., addr_setuid)
-♦ Load addr_setuid
to the memory during 
program initialization
Starting 
sendmail
program
Elementary
Activity 3
a d d r _ s e t u i d
c h a n g e d ♦ -
( S P E C _ R E J )
(SPEC_ACPT)
addr_setuidunchanged♦
pFSM3
-
Elementary
Activity 2
o r
x  1 0 0 ♦ -
( S P E C _ R E J )
pFSM2
CPT)
P
(IM
T)
P
C
L_A
(SPEC_A
0≤
x≤
100♦
-
x > 100 ♦-
(IMPL_REJ)
x ≤ 100 ♦-
-♦ tTvect[x]=i
?
(IMPL_REJ)
-♦-
)
T
P
C
A
_
L
P
M
I
(
♦ Execute code referred 
by addr_setuid
Execute MCode
Figure 3: Sendmail Debugging Function Signed Integer Overflow Vulnerability
Proceedings of the 2003 International Conference on Dependable Systems and Networks (DSN’03) 
0-7695-1959-8/03 $17.00 (c) 2003 IEEE
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 07:06:47 UTC from IEEE Xplore.  Restrictions apply. 
The FSM model introduces a notation of propagation 
gate  (the  triangle  between  FSMs)  to  depict  the  causality 
of  the  exploitation  of  the  vulnerabilities  in  the  two 
in  Figure  3,  exploiting 
operations.  For  example, 
operation  1 
the 
precondition  of  exploiting  operation  2  (execute  Mcode),
which  is  denoted  by  the  upper  propagation  gate.  The 
lower propagation gate (denoted as Execute MCode) can 
be 
in  other 
operations. 
the  precondition  for 
the  exploitation 
(overwrite 
the  addr_setuid) 
is 
5.  Modeling Various Vulnerabilities Using an FSM  
This section provides examples of applying the FSM 
approach to analyze security vulnerabilities. In each case, 
the  predicates  related  to  the  elementary  activities  are 
determined  by  examining  the  vulnerability  data  and  the 
corresponding  source  code  of 
in 
question.  
5.1  Example  1:  NULL  HTTPD  Heap  Overflow 
the  applications 
Vulnerability  
Null HTTPD is a multithreaded web server for Linux 
and Windows platforms. This software was chosen as an 
example because in the process of constructing the FSM 
model for the known vulnerability of NULL HTTPD, we 
discovered a new, as yet unknown vulnerability (Bugtraq
ID  6255).  Discovery  of 
the  new  heap  overflow 
vulnerability  demonstrates  an  additional  potential  of  the 
FSM-based approach. 
Null  HTTPD  0.5  heap  overflow  is  modeled  as  a 
series  of  four  pFSMs  shown  in  Figure  4a.  pFSM1  and 
pFSM2  depict  the  buffer  manipulation  in  the  function 
ReadPOSTData  (the  function  source  code  is  shown  in 
Figure  4b),  which  allocates  a  buffer  (PostData,  source 
code  Line  1)  and  copies  a  user  specified  string  from  a 
socket (source code Line 4), which is marked as input in 
Figure  4a.  One  of  the  input  parameters  (contentLen)
provides the length of input, which, by the specification6,
should be a non-negative integer. However, Null HTTPD
allocates (by calling calloc in source code line 1) a buffer 
for  PostData  with  size  1024+contentLen  without 
checking  whether  contentLen  is  non-negative.  A  buffer 
overflow  occurs  when  the  attacker  provides  a  negative 
contentLen (e.g., contentLen = -800) to make PostData a 
buffer  with  only  224  bytes.  This  results  in  buffer 
overflow  (denoted  by  pFSM1)  because  Null  HTTPD
always  copies  at  least  1024  bytes  arriving  from  the 
socket to PostData (source code Line 4). 
A New Vulnerability. Version 0.5.1 of Null HTTPD
fixed  the  above  overflow  vulnerability  by  imposing  the 
appropriate  check  to  block  a  negative  contentLen value 
before calling the function ReadPOSTData (this check is 
not shown in the source code of Figure 4b). Note that the 
6 Although a well-defined specification does not exist, this 
particular specification can easily be deduced from the 
application. 
socket  programming  style  requires  the  users  to  specify 
the  contentLen  and  input  separately,  because  the  socket 
has  no  way  of  determining  the  length  of  the  input.  The 
programmer must ensure that the length of input does not 
exceed the supplied contentLen.
We  now  describe  how  constructing  the  FSM  model 
for  the  known  vulnerability  leads  to  discovery  of  a  new 
vulnerability  for  the  same  operation.  pFSM1  depicts  the 
predicate  to  check  contentLen  against  the  specification. 
Similarly,  pFSM2  –  the  predicate  to  check  the  actual 
length  of  the  supplied  input  –  should  reject  input  if  its 
length is larger than allocated buffer size, i.e., it takes the 
transition  marked  “?”.  Source  code  Line  11  controls  the 
termination  condition  of  recv  (source  code  Line  4). 
However, due to a logic error (|| should be && in source 
code  Line  11),  recv  never  terminates  before  the  entire 
input  string  is  read  from  the  socket.  Thus,  the  outgoing 
transition  (marked  with  a  “?”)  from  state  X  does  not 
exist, and instead the hidden transition to the accept state 
 is taken. A malicious user can supply right contentLen
but an arbitrary length string input to overflow the buffer 
PostData.  Thus,  constructing  the  FSM  allowed  us  to 
uncover this new vulnerability.  
As  indicated  earlier,  each  elementary  activity  offers 
an  independent  opportunity  for  checking.  If  the  checks 
corresponding  to  the  predicates  depicted  by  pFSM1  and 
pFSM2 (in Figure 4a) are not in place, the impact of this 
vulnerability  is  further  analyzed  using  pFSM3,  which 
describes the operation  manipulating the  heap layout (as 
shown  in  the  left  of  Figure  4a).  The  buffer  PostData  is 
allocated on the heap, followed by a free memory chunk  
(chunk B). Free chunks are organized as a double-linked-
list  by  GNU-libc.  The  beginning  few  bytes  of  each  free 
chunk are used as the forward link (fd) and the backward 
link (bk) of the double-linked list. In this case, since free 
chunks  A,  B  and  C  are  in  the  list,  B->fd=A,  B->bk=C.
The predicate defined in pFSM3 provides a check so that 
B->fd and B->bk are not overwritten to an arbitrary value 
(i.e., pFSM3 does not transit to the reject state), due to the 
overflow of the buffer PostData described in the pFSM1
and  pFSM2.  However,  when  the  PostData  is  freed,  the 
actual  implementation  does  not  check  the  pointer  B->fd 
and B->bk, causing the transition from the reject state to 
the  accept  state  (the  hidden  or  dotted  transition  in 
pFSM3),  which  allows  the  attacker  to  write  an  arbitrary 
value  to  an  arbitrary  memory  location.  Specifically,  in 
this  example,  the  attacker  exploits  this  vulnerability  and 
overwrites the GOT entry of the function free() so that it 
points  to  the  location  of  malicious  code  MCode 7 .
7 Note that the assignment B->fd->bk=B->bk is executed when 
PostData  is  freed.  We  denote  the  GOT  entry  of  free()  as 
addr_free. The attacker sets B->fd=&addr_free – (offset of the 
field bk) and B->bk=Mcode, in order to make the GOT entry of 
free() pointing to Mcode.
Proceedings of the 2003 International Conference on Dependable Systems and Networks (DSN’03) 
0-7695-1959-8/03 $17.00 (c) 2003 IEEE
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 07:06:47 UTC from IEEE Xplore.  Restrictions apply. 
Operation 1:
Read postdata from socket to 
an allocated buffer PostData
−♦get (contentLen, input)
contentLen is an integer,
input is an text string to be 
read from a socket
c o n t e n t L e n =0♦−
-♦Calloc PostData[1024+contentLen]
length(input) fd=&addr_free-(offset of field bk)
B->bk=Mcode
Free chunk A
Used chunk PostData
Free chunk B
fd=A
bk=C
Free chunk C
Note: addr_free is the .GOT 
entry of function free
-♦ B->fd=A
B->bk=C
Calloc is called
B->fd=&addr_free-(offset of field bk)
B->bk=Mcode ♦-
Allocate and free the buffer PostData
B->fd and B->bk
unchanged ♦-
pFSM3
−♦−
-♦ When buf is freed, 