detects that the hardware supports, it uses the hardware AES
instructions for its cryptographic operations, otherwise it falls
back to a software implementation. In our experiments, we
observe that the OpenSSL library executing inside the enclave
fails to detect that our hardware has AES-NI support. Thus, it
uses a slower AES routine which adds latency by consuming
more CPU cycles. We suspect that the SDK has not rolled out
support for executing cpuid instruction inside the enclave.
This change was also proposed by previous work [21].
We point out that the Linux SDK itself does not use hard-
ware AES-NI instructions for encryption-decryption. Instead it
uses software implementation of AES routine, as was pointed
out by recent public disclosures [34]. In our case studies,
this further ampliﬁes the slow-down of each encrypt / decrypt
operation inside microns by 20% of the total execution.
Comparison to Graphene-SGX. Our design does not sig-
niﬁcantly degrade the performance as compared to Graphene-
SGX. We compare the performance of two systems for execut-
ing OpenSSL. Speciﬁcally, we test varied sizes and frequencies
of data written out of the micron-enclave, since it is the main
factor for PANOPLY overheads. To this end, we conﬁgure
a SSL client-server setup and measure the CPU execution
time for 6 conﬁgurations of number of requests and size of
payloads: 512 / 2014 bytes of data for each of the 10 / 100
/ 1000 client connections. Figure 9 depicts the performance
of Graphene-SGX and PANOPLY. For these conﬁgurations,
PANOPLY has 5-10% higher overheads than Graphene-SGX.
Since comparison of a single user-application may not be a
conclusive evidence for the overall performance of PANOPLY,
we present a fair comparison of these two systems. Speciﬁ-
cally, we port the LMBench benchmark to PANOPLY, which
is supported 3 by Graphene-SGX as well. Figures 8 and 10
present the latency and bandwidth performance of PANOPLY
and Graphene-SGX. Our ﬁrst observation is that the perfor-
mance overheads of both the systems are signiﬁcant over the
absolute baseline of a native application executing without any
enclave infrastructure. This re-iterates our earlier ﬁndings that
the slow-down due to enclave life-cycle operations (create and
destroy) are common to any system that uses SGX. Secondly,
the memory latencies exhibited by PANOPLY and Graphene-
SGX are comparable. As shown in Figure 8, the PANOPLY
latency is almost-always lower than Graphene-SGX, whereas
both the systems exhibit similar overheads over an absolute
baseline. Finally, we measure the bandwidth for various types
of operations including network, memory, ﬁle IO for the two
systems. PANOPLY performs comparable to Graphene-SGX for
memory and network operations (Figure 10). For ﬁle-backed
mmap operations, the overhead for PANOPLY is observably
3The Graphene-SGX system is not stable when executing the full LMBench
benchmark suite, and crashes non-deterministically with segmentation faults.
The results presented here are assimilated over 24 attempted runs to gather a
full set of evaluation.
13
94933.2	82480.69	48490.84	66042.22	42293.46	12818.84	0	10000	20000	30000	40000	50000	60000	70000	80000	90000	100000	200	Bytes					1KB				6KB		Throughput	in	Requests/second	Size	of	served	sta8c	web-page	Baseline	H2O	Panoply	H2O	 0 5 10 15 20 25 30 35 0 10 20 30 40 50 60 70Latency in miliseconds(ms)Load size in MBBaselineGraphene-SGXPanoply0.1	0.9	8.84	0.1	0.9	9.64	0.109	1	10.13	0.109	1.02	10.18	0	2	4	6	8	10	12	(512,10)	(512,100)	(512,1000)	(1024,10)	(1024,100)	(1024,1000)	Time	(second)	(Bytes,	Connec2ons)	Graphene-SGX	Panoply	0	20	40	60	80	100	120	pipe	tcp	socket	af_unix	sock	stream	read	read	open2close	Mmap	read	Mmap	read	open2close	libc	bcopy	unaligned	libc	bcopy	aligned	unrolled	bcopy	unaligned	unrolled	par>al	bcopy	unaligned	Memory	read	Memory	par>al	read		Memory	write	Memory	par>al	write		Memory	par>al	read/write	Memory	bzero	Bandwidth	Graphene-SGX	Panoply	larger than Graphene-SGX. Since PANOPLY performs these
operations via libc interface, the number of enclave entry and
exits per operation is larger. On the other hand, Graphene-SGX
uses a narrower interface and hence for ﬁle IO, it incurs a lower
number of enclave transitions. This is one of the factors which
causes the bandwidth variation for this subset of IO operations.
VI. RELATED WORK
PANOPLY is a new design point in SGX enclave design
space that achieves low TCB while maintaining expressiveness
for enclave-bound code. PANOPLY’s inter-micron ﬂow integrity
guarantees a higher level security property, unlike previous
systems which target low-level conﬁdentiality primitives [47],
[48]. We discuss how PANOPLY differs from existing systems
in terms of TCB, design goals, scope and end-to-end guaran-
tees.
TCB. PANOPLY design is driven by the delegate-rather-than-
emulate philosophy, which is the key for lowering the TCB.
Speciﬁcally, we do not perform namespace management inside
the enclave, which is common approach for library OS designs.
The goal of library OSes is to achieve a narrow ABI [21], [41],
[52], so as to maintain compatibility and portability. Hence,
these systems implement bulk of the system logic inside the
library OS to map the system call APIs to their narrow ABI
interface. In PANOPLY, we are not limited by these design
choices. We expose a larger POSIX API to microns, and
delegate all the system logic to underlying operating system.
This is a reasonable choice because the OS can perpetrate the
same set of attacks even with a narrow interface. Thus, our
design choice allows us to keep system libraries such as libc
outside of TCB, while achieving the same level of security.
Security of Single Enclave. PANOPLY is the ﬁrst system to
demonstrate control and data-ﬂow attacks on enclave-enclave
interactions. It prevents such attacks by ensuring inter-micron
ﬂow integrity. Recent works have pointed out that enclaves
are susceptible to side channel attacks via page faults [55] and
cache [28]. Currently, PANOPLY does not guarantee defenses
against such side-channels. However, applications can employ
off-the-shelf defenses proposed recently [29], [38], [43], [44].
Weichbrodt et al. [53] recently showed that if the enclave
logic has use-after-free or TOCTOU bugs, then the OS can
exacerbate the effect of these bugs to perpetrate control-ﬂow
attacks inside the enclave code. PANOPLY assumes that the
enclave is free of any logic or memory bugs. Strackx et al.
highlight that the adversary can shut down enclaves and abuse
the execution by doing a hardware state-replay attack [49],
[50]. PANOPLY can use their proposed solution to ensure
hardware state contiguity in the future.
Partitioning Applications for SGX. PANOPLY enables ex-
pressive enclave-bound code with a low TCB. Thus, it can
execute maximum application logic inside one or more mi-
crons while ensuring that the PANOPLY application maintains
the security guarantee. However, PANOPLY leaves the choice
of partition design to the security architect [22], [24], [35].
Jain et al. [32] propose the use of enclaves to protect Tor
DA server keys inside enclaves to protect against well-known
attacks [14], [15]. Kim et al. [36] propose designs to use SGX
for networking applications such as SDN-based inter-domain
routing, Tor directory servers and ORs. Atamli-Reineh et
al. [20] propose four partitioning schemes ranging from coarse-
grained partitioning (single enclave for whole application) to
ultra-ﬁne partitioning (one enclave per application secret) for
executing OpenSSL library in enclaves.
SGX Containers & Sandboxes using Enclaves. Scone [19]
is a concurrent system which uses Intel SGX enclaves to
isolate docker containers running in a public cloud setting.
We summarise the key design differences between Scone and
PANOPLY. Firstly, the interface exposed by PANOPLY is at
POSIX level, whereas Scone exposes a system call interface
to the enclaves. As an artifact of this design choice, PANOPLY
does not execute any libc library inside the enclave. On the
other hand, Scone executes the libc library (speciﬁcally musl
libc) inside the enclave. Secondly, PANOPLY does a syn-
chronous exit for executing code outside the enclave, whereas
Scone does an asynchronous exit. These two variations lead to
a different design in terms of TCB, performance and system
challenges. Thirdly, the on-demand threading model proposed
by PANOPLY spawns new microns in separate enclaves to scale
the number of threads. This way, each thread in the application
is associated with a unique thread in the enclave. Scone uses
a M:N threading model. Hence, when the application scales
it
is forced to multiplex on a limited number
of existing threads in a single enclave. Lastly, PANOPLY
is designed for multi-process applications, which comprise
of multiple micron containers and user processes. Hence its
design comprises of in-built support for fork, exec, clone and
a secure communication interface between multiple microns
and processes. Scone only supports applications with a single-
container process running inside a single-enclave, which is a
subset of PANOPLY.
threads,
it
Ryoan [31] is a concurrent work for executing distributed
SGX native client (NaCl) sandboxes. PANOPLY’s execution
model of multi-micron applications varies from Ryoan, since in
PANOPLY, all microns that belong to the same application trust
each other. Ryoan introduces a request-oriented data model
where each enclave is in-charge of processing the input only
once. Ryoan ensures that each service sandbox conﬁnes the
user-data to itself, while allowing mutually distrustful parties
to compute over sensitive data. In Ryoan, the NaCl executes
the system calls and all the buffer and ﬁle IO operations are
backed by in-enclave memory.
VII. CONCLUSION
PANOPLY bridges the gap between expressiveness of
the SGX-native abstractions and requirements of feature-rich
Linux applications. PANOPLY offers a new design point, prior-
itizing TCB over performance, without sacriﬁcing compatibil-
ity. It achieves 2 orders of magnitude lower TCB than previous
systems.
ACKNOWLEDGMENTS
We thank Mona Vij and Simon Johnson from Intel for
their feedback. Thanks to Chia-Che Tsai and Donald Porter
for releasing code and discussions on Graphene-SGX. This
research was partially supported by a grant from the National
Research Foundation, Prime Ministers Ofﬁce, Singapore under
its National Cybersecurity R&D Program (TSUNAMi project,
No. NRF2014NCR-NCR001-21) and administered by the Na-
tional Cybersecurity R&D Directorate.
14
REFERENCES
[1]
[2]
[3]
[4]
[5]
[6]
[7]
[8]
[9]
[10]
[11]
[12]
[13]
[14]
[15]
[16]
[17]
[18]
Tabular
Protocol,”
https://
Data
Stream
- HTTP/2 Benchmarking
Tool,”
https://nghttp2.org/
“Chutney - The Chutney tool for testing and automating Tor network
setup,” https://gitweb.torproject.org/chutney.git.
“FreeTDS: Making the leap to SQL Server,” http://www.freetds.org/.
“Graphene-SGX Library OS - A Library OS for Linux Multi-process
Applications, with Intel SGX support,” https://github.com/oscarlab/
graphene, (Accessed on 12/06/2016, Commit 9958214).
“h2load
documentation/h2load-howto.html.
“H2O Neverbleed: Privilege Separation Engine for OpenSSL / Li-
breSSL,” https://github.com/h2o/neverbleed.
“Intel SGX for Linux,” https://github.com/01org/linux-sgx.
“Intel SGX Linux Driver,” https://github.com/01org/linux-sgx-driver.
“Intel Software Guard Extensions SDK - Documentation — Intel
Software,” https://software.intel.com/en-us/sgx-sdk/documentation.
“[MS-TDS]:
msdn.microsoft.com/en-us/library/dd304523.aspx.
“Tor Network Is Under Attack through Directory Authority Servers
Seizures,” http://thehackernews.com/2014/12/tor-network-hacked.html.
“Tor Project: Anonymity Online,” https://www.torproject.org/.
“CVE-2009-3555 TLS Session Renegotiation Vulnerability,” https://
cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-3555, 2009.
“RFC 5746 - Transport Layer Security (TLS) Renegotiation Indication
Extension,” https://tools.ietf.org/html/rfc5746, February 2010.
“Tor Project Infrastructure Updates in Response to Security Breach,”
http://archives.seul.org/or/talk/Jan-2010/msg00161.html, 01 2010.
“Possible Upcoming Attempts to Disable the Tor Network — The
Tor Blog,” https://blog.torproject.org/blog/possible-upcoming-attempts-
disable-tor-network, 12 2014.
“Software Guard Extensions Programming Reference Rev. 2.”
software.intel.com/sites/default/ﬁles/329298-002.pdf, Oct 2014.
“Intel
https://software.intel.com/sites/default/ﬁles/managed/ae/48/Software-
Guard-Extensions-Enclave-Writers-Guide.pdf, 2015.
I. Anati, S. Gueron, S. P. Johnson, and V. R. Scarlata, “Innovative
Technology for CPU Based Attestation and Sealing,” in HASP 2013.
Software Guard Extensions Enclave Writer’s Guide,”
[19] S. Arnautov, B. Trach, F. Gregor, T. Knauth, A. Martin, C. Priebe,
J. Lind, D. Muthukumaran, D. O’Keeffe, M. L. Stillwell, D. Goltzsche,
D. Eyers, R. Kapitza, P. Pietzuch, and C. Fetzer, “SCONE: Secure Linux
Containers with Intel SGX,” in OSDI 2016.
[20] A. Atamli-Reineh and A. Martin, ch. Securing Application with Soft-
ware Partitioning: A Case Study Using SGX.
[21] A. Baumann, M. Peinado, and G. Hunt, “Shielding Applications from
an Untrusted Cloud with Haven,” in OSDI 2014.
[22] A. Bittau, P. Marchenko, M. Handley, and B. Karp, “Wedge: Splitting
Applications into Reduced-privilege Compartments,” in NSDI 2008.
[23] E. Brickell, J. Camenisch, and L. Chen, “Direct Anonymous Attesta-
tion,” in CCS 2004.
[24] D. Brumley and D. X. Song, “Privtrans: Automatically Partitioning
Programs for Privilege Separation,” in USENIX Security 2004.
[25] M. Castro and B. Liskov, “Practical Byzantine Fault Tolerance,” in
OSDI 1999.
[26] S. Checkoway and H. Shacham, “Iago Attacks: Why the System Call
API is a Bad Untrusted RPC Interface,” in ASPLOS 2013.
[27] A. Clement, E. Wong, L. Alvisi, M. Dahlin, and M. Marchetti, “Making
Byzantine Fault Tolerant Systems Tolerate Byzantine Faults,” in NSDI
2009.
[28] V. Costan and S. Devadas, “Intel SGX Explained,” Cryptology ePrint
Archive, Report 2016/086, 2016, http://eprint.iacr.org/2016/086.
[29] V. Costan, I. Lebedev, and S. Devadas, “Sanctum: Minimal Hardware
Extensions for Strong Software Isolation,” in USENIX Security 2016.
[30] T. T. A. Dinh, P. Saxena, E.-C. Chang, B. C. Ooi, and C. Zhang, “M2R:
Enabling Stronger Privacy in MapReduce Computation,” in USENIX
Security ’15.
[31] T. Hunt, Z. Zhu, Y. Xu, S. Peter, and E. Witchel, “Ryoan: A Distributed
Sandbox for Untrusted Computation on Secret Data,” in OSDI 2016.
15
[32] P. Jain, S. Desai, S. Kim, M.-W. Shih, J. Lee, C. Choi, Y. Shin,
T. Kim, B. Kang, and D. Han, “OpenSGX: An Open Platform for SGX
Research,” in NDSS 2016.
[33] S. Johnson, V. Scarlata, C. Rozas, E. Brickell, and F. Mckeen, “Intel
Software Guard Extensions: EPID Provisioning and Attestation Ser-
vices,” ser. Intel Corporation.
[34] L. M. JP Aumasson, “SGX Secure Enclaves in Practice: Security and
Crypto Review — Kudelski Security,” Black Hat USA, 2016.
[35] D. Kilpatrick, “Privman: A Library for Partitioning Applications,” in
USENIX ATC 2003.
[36] S. Kim, Y. Shin, J. Ha, T. Kim, and D. Han, “A First Step Towards
Leveraging Commodity Trusted Execution Environments for Network
Applications,” in HotNets 2015.
[37] G. Klein, K. Elphinstone, G. Heiser, J. Andronick, D. Cock, P. Derrin,
D. Elkaduwe, K. Engelhardt, R. Kolanski, M. Norrish, T. Sewell,
H. Tuch, and S. Winwood, “seL4: Formal Veriﬁcation of an OS Kernel,”
in SOSP 2009.
[38] S. Lee, M. Shih, P. Gera, T. Kim, H. Kim, and M. Peinado, “Inferring
ﬁne-grained control ﬂow inside SGX enclaves with branch shadowing,”
2016. [Online]. Available: http://arxiv.org/abs/1611.06952
[39] F. McKeen, I. Alexandrovich, I. Anati, D. Caspi, S. Johnson, R. Leslie-
Hurd, and C. Rozas, “Intel Software Guard Extensions Support for
Dynamic Memory Management Inside an Enclave,” in HASP 2016.
[40] F. McKeen, I. Alexandrovich, A. Berenzon, C. V. Rozas, H. Shaﬁ,
V. Shanbhogue, and U. R. Savagaonkar, “Innovative Instructions and
Software Model for Isolated Execution,” in HASP 2013.
[41] D. E. Porter, S. Boyd-Wickizer, J. Howell, R. Olinsky, and G. C. Hunt,
“Rethinking the Library OS from the Top Down,” in ASPLOS 2011.
[42] F. Schuster, M. Costa, C. Fournet, C. Gkantsidis, M. Peinado,
G. Mainar-Ruiz, and M. Russinovich, “VC3: Trustworthy Data Analyt-
ics in the Cloud,” in IEEE Symposium on Security and Privacy 2015.
[43] M.-W. Shih, S. Lee, T. Kim, and M. Peinado., “T-SGX: Eradicating
Controlled-Channel Attacks Against Enclave Programs,” in NDSS 2017.
[44] S. Shinde, Z. L. Chua, V. Narayanan, and P. Saxena, “Preventing page
faults from telling your secrets,” in AsiaCCS 2016.
[45] Shweta Shinde and Dat Le Tien and Shruti Tople and Prateek Saxena,
“Panoply: Low-TCB Linux Applications With SGX Enclaves,” National
University of Singapore, Tech. Rep., Dec 2016.
[46] Shweta Shinde and Shruti Tople and Deepak Kathayat and Prateek Sax-
ena, “PodArch: Protecting Legacy Applications with a Purely Hardware
TCB,” National University of Singapore, Tech. Rep., Feb 2015.
[47] R. Sinha, M. Costa, A. Lal, N. P. Lopes, S. Rajamani, S. A. Seshia,
and K. Vaswani, “A Design and Veriﬁcation Methodology for Secure
Isolated Regions,” in PLDI 2016.
[48] R. Sinha, S. Rajamani, S. Seshia, and K. Vaswani, “Moat: Verifying
Conﬁdentiality of Enclave Programs,” in CCS 2015.
[49] R. Strackx, B. Jacobs, and F. Piessens, “ICE: A Passive, High-speed,
State-continuity Scheme,” in ACSAC 2014.
[50] R. Strackx and F. Piessens, “Ariadne: A Minimal Approach to State
Continuity,” in USENIX Security 2016.
[51] F. Tramer, F. Zhang, H. Lin, J.-P. Hubaux, A. Juels, and E. Shi,
“Sealed-Glass Proofs: Using Transparent Enclaves to Prove and Sell
Knowledge,” Cryptology ePrint Archive, Report 2016/635, 2016.
[52] C.-C. Tsai, K. S. Arora, N. Bandi, B. Jain, W. Jannen, J. John, H. A.
Kalodner, V. Kulkarni, D. Oliveira, and D. E. Porter, “Cooperation and
Security Isolation of Library OSes for Multi-Process Applications,” in
EuroSys 2014.
[53] N. Weichbrodt, A. Kurmus, P. Pietzuch, and R. Kapitza, “AsyncShock:
Exploiting Synchronisation Bugs in Intel SGX Enclaves,” in ESORICS
2016.
[54] D. Wheeler, “SLOCcount,” http://www.dwheeler.com/sloccount/.
[55] Y. Xu, W. Cui, and M. Peinado, “Controlled-Channel Attacks: De-
terministic Side Channels for Untrusted Operating Systems,” in IEEE
Symposium on Security and Privacy 2015.
[56] F. Zhang, E. Cecchetti, K. Croman, A. Juels, and E. Shi, “Town Crier:
An Authenticated Data Feed for Smart Contracts,” Cryptology ePrint
Archive, Report 2016/168, 2016, http://eprint.iacr.org/2016/168.