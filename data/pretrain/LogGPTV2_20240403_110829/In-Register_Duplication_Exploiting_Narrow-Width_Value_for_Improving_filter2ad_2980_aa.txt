title:In-Register Duplication: Exploiting Narrow-Width Value for Improving
Register File Reliability
author:Jie S. Hu and
Shuai Wang and
Sotirios G. Ziavras
In-Register Duplication: Exploiting Narrow-Width Value for Improving Register
File Reliability
Jie Hu, Shuai Wang, and Sotirios G. Ziavras
Department of Electrical and Computer Engineering
New Jersey Institute of Technology
{jie.hu,sw63,ziavras}@njit.edu
Newark, NJ 07102
Abstract
Protecting the register value and its data buses is cru-
cial to reliable computing in high-performance micropro-
cessors due to the increasing susceptibility of CMOS cir-
cuitry to soft errors induced by high-energy particle strikes.
Since the register ﬁle is in the critical path of the proces-
sor pipeline, any reliable design that increases either the
pressure on the register ﬁle or the register ﬁle access la-
tency is not desirable.
In this paper, we propose to ex-
ploit narrow-width register values, which present the ma-
jority of the generated values, for duplicating a copy of the
value within the same data item, called in-register duplica-
tion (IRD), eliminating the requirement of additional copy
registers. The datapath pipeline is augmented to efﬁciently
incorporate parity encoding and parity checking such that
error recovery is seamlessly supported in IRD and the par-
ity checking is overlapped with the execution stage to avoid
increasing the critical path. Our experimental evaluation
using the SPEC CINT2000 benchmark suite shows that IRD
provides superior read-with-duplicate (RWD) and error de-
tection/recovery rates under heavy error injection as com-
pared to previous reliability schemes.
1. Introduction
Along with the dramatic performance improvement
driven by advancing technologies, future microprocessors
are becoming even more vulnerable to soft errors induced
by energetic particle strikes such as alpha particles (emit-
ted by decaying radioactive impurities in packaging and in-
terconnect materials) and high-energy neutrons induced by
cosmic rays [35][33]. This increasing vulnerability is pri-
marily due to the continuously reducing logic depth, lower-
ing supply voltage, decreasing nodal capacitance, and in-
creasing clock frequency and on-chip integration density
at new technologies [28]. Thus, designing new generation
microprocessors against soft errors has arisen as a major
requirement along with performance and power considera-
tions.
Traditionally, triple-modular redundancy (TMR) [15] is
used to achieve highly reliable fault-tolerant computing at
high hardware cost. Recently, proposals targeting soft er-
ror problems in microprocessors have suggested utilizing
the inherent resource redundancy in simultaneous multi-
threading (SMT) microprocessors and chip-multiprocessors
(CMPs) to enhance the datapath reliability with concurrent
error detection [26, 31, 25, 32, 7, 19]. Some other research
has proposed that designers exploit the redundant resources
in high-performance superscalar out-of-order cores to en-
able a reliable processor through instruction-level redundant
execution [18, 24, 22, 30, 9, 8].
Since 1) register ﬁle read is within the datapath loose
loops [3], 2) error-ﬂipped intermediate computation results
in the register ﬁle are very likely to propagate to later com-
putations or to memory hierarchies, and 3) the large regis-
ter ﬁle is a major die-area consumer increasing its expo-
sure to high-energy particle strikes [23], designing high-
performance error-resilient register ﬁles is of critical im-
portance. Most dual-instruction execution (DIE) proces-
sors include register ﬁle within the sphere of replication
(SoR) [25]. This is mainly due to the unbearable access
latency and power overhead of ECC-protected register ﬁles
[17, 12]. Notice that including the register ﬁle within the
SoR effectively halves the size of the register ﬁle. Assum-
ing a parity-protected register ﬁle, recent work [17] pro-
posed to use idle/free registers to accommodate duplicate
values and the copy registers can be preempted for regular
register renaming to avoid any performance loss. Further,
it proposed to use predicted dead registers to improve the
duplication rate at a small performance overhead, based on
the assumption that the register value is ﬁrst written back to
the memory before the register is reused. However, the error
coverage of these schemes is signiﬁcantly limited compared
to the full-duplication scheme.
The presence of narrow-width data (whose value can be
represented by fewer bits than the full data width of the pro-
cessor) in general-purpose applications is well understood
and has been utilized for power and performance optimiza-
tions [4][13][14][6]. In this paper, we propose to exploit the
produced narrow-width register values for designing high-
performance error-resilient register ﬁles, and protecting the
result writeback bus and the bypass network. In the pro-
posed new processor microarchitecture, each integer func-
tional unit is augmented with a simple fast leading-0/1 de-
tector for narrow-width check. Detected narrow-width re-
sults that can be represented by no more than 32 bits au-
tomatically duplicate themselves by muxing the lower 32
bits into the higher 32 bits before being latched by the
pipeline registers. We call this scheme In-Register Duplica-
tion (IRD). In-register duplication stores two copies of the
narrow-width value in the same register and transmits two
copies of the value using the bandwidth for a single data
value over the writeback bus and forwarding bus. Thus,
IRD eliminates the need for additional copy registers that
maintain redundant copies of the register value for error de-
tection and recovery. It also protects the data transfer paths
from/to the register ﬁle and the functional units for narrow-
width values. To our best knowledge, this work presents the
ﬁrst effort to exploit narrow-width values for reliable regis-
ter ﬁle design against soft errors.
Experimental evaluation using the SPEC CINT2000
benchmark suite shows that without sacriﬁcing any perfor-
mance IRD achieves a write-with-duplicate (WWD) rate
of 94% at the output of functional units and a read-with-
duplicate (RWD) rate of 95% at the inputs of functional
units. We evaluated two schemes for error detection in
IRD, based on duplicate value comparison and parity check-
ing. Under error injection with accelerated error rates at
10−5/10−4 per selected bit per cycle, both schemes virtu-
ally detect all errors in narrow-width values being read in.
In addition, parity checking also identiﬁes all errors in reg-
ular values. To avoid signaling unnecessary errors in the
duplicate copy, IRD only checks the parity bit of the lower
32-bit half for error detection and utilizes the duplicate in
the upper half for error recovery. Our experimental results
show that IRD detects 99.7% of the erroneous reads for the
narrow-width values and successfully recovers 99.7% and
99.2% at error rate 10−5 and 10−4, respectively, of the de-
tected errors using the uncorrupted duplicate, which makes
our in-register duplication a very cost-effective design for
highly reliable register ﬁles.
The rest of the paper is organized as follows. We dis-
cuss related work in Section 2, and review some basics of
register renaming and the correlation between register ﬁle
size and performance in Section 3. A detailed analysis of
narrow-width values is given in Section 4. We elaborate
on our in-register duplication design in Section 5 and intro-
duce the error injection model in Section 6. In Section 7,
we study the error behavior of the register ﬁle system under
error injection and evaluate IRD for reliable design. Section
8 concludes this work.
2. Related Work
Fault-tolerant designs based on modular redundancy
have been widely used to build highly reliable systems. For
example, cycle-by-cycle lockstepping of dual-processors
and comparison of their outputs are employed for error de-
tection in Compaq Himalaya [1] and IBM z900 [29] with
G5 processors. Other designs use asymmetric redundancy
to include a watch-dog processor [21] or a low-performance
checker processor in DIVA [2] to verify the correctness of
the execution on the main processor.
Targeting the increasing processor vulnerability to soft
temporal redundancy based
errors at new technologies,
reliable schemes exploiting simultaneous multithreading
(SMT) architectures have been extensively studied for both
single processors and chip-multiprocessors, such as AR-
SMT [26], SRT [25][19], SRTR [32], and Slipstream
[31]. Lately, many research efforts have been spent on
exploiting the redundant resources in superscalar proces-
sors for instruction-level redundant execution against tran-
sient faults. In [18], each instruction is executed twice and
the results from duplicate execution are compared to verify
the absence of transient errors in functional units. How-
ever, each instruction only occupies a single re-order buffer
(ROB) entry. On the other hand, the dual-instruction exe-
cution scheme (DIE) in [24] physically duplicates each de-
coded instruction to provide a Sphere of Replication includ-
ing the instruction issue queue/ROB, functional units, phys-
ical register ﬁles, and the interconnect among them. Due
to the substantially increased pressure on the hardware re-
sources, dual-instruction execution in general suffers from
signiﬁcant performance loss. Follow-up work such as DIE-
IRB [22], SHREC [30], and PER-IRTR [8], try to allevi-
ate the resource contention in DIE processors to recover the
performance loss.
In [11], the protection schemes were particularly tuned
to protect frequently accessed cache lines which are more
error-prone, in order to reduce the area overhead. Our fo-
cus in this work is to design reliable register ﬁles. Previous
work [17] has exploited utilizing free registers or predicted
dead registers to maintain a replica of the value in the reg-
ister ﬁle to increase its error resilience. Recent work [16]
studied the trade-offs between performance and reliability
of the register ﬁle when over-clocking is applied to increase
the operation frequency. Different from their work, our in-
register duplication scheme is based on the detection and
capture of narrow-width register values such that redundant
copies are generated within a single 64-bit data item to im-
prove the reliability of the register ﬁle system, eliminating
the need for copy registers and related hardware enhance-
ments.
3. Basics of Register Renaming in Superscalar
Microprocessors
3.1. Register Files and Register Renaming
dynamically
Superscalar microprocessors
exploit
instruction-level parallelism (ILP) to issue multiple in-
structions per cycle for improved performance. Register
renaming is one of the fundamental techniques employed
in superscalar microprocessors to increase the ILP by elim-
inating the two false data dependences, write-after-read
(WAR) and write-after-write (WAW). We implemented
MIPS R10000 [34] style register renaming, where the ar-
chitectural and physical register ﬁles are combined. Figure
1 gives the superscalar microprocessor model simulated in
this paper.
In the register renaming stage, the logical register ids of
the source operands in a decoded instruction are used to
access the register alias table (RAT), a.k.a. register map-
ping table. The table entry indexed by the logical register
id contains the physical register id that the source register
BPred
ICache
Active List
Decoder
RAT
Issue Queue
Register
File
DCache
Fetch
Decode
Reg. Rename
Inst. Scheduling
RF Read
Exec/Bypass
Dcache Acc.
WB
Commit
Figure 1. Datapath and the pipeline stages of the simulated superscalar microprocessor.
was renamed to. For the destination register, a free physical
register is allocated from the register free list and the RAT
is updated as follows: the old physical register id is read
out from the RAT and stored in the active list entry allo-
cated to the instruction, and then the new physical register
id is written to the same RAT entry indexed by the logi-
cal destination register id. The destination register is said
to have been remapped to the new physical register and the
old physical register is said to have been unmapped. In case
the register free list is empty, the renaming stage is stalled
till some physical register is freed. Notice that a physical
register cannot be freed until an instruction that previously
unmapped this physical register is committed. Furthermore,
a physical register is susceptible to soft errors only after a
value is written into the register and before it is freed.
3.2 Register File Performance Sensitivity
The register ﬁle size limits the effective size of the in-
struction window thus presenting a major constraint on the
ILP exploitation in superscalar microprocessors. Figure 2
(a) shows the performance comparison of an 8-wide super-
scalar microprocessor (the detailed conﬁguration is given
in Table 1) when the integer register ﬁle size varies from
40 to 512 entries. Signiﬁcant performance improvement is
achieved when the size increases from 40 to 48, 64, and 80.
However, further increasing the size beyond 80 registers,
the performance improvement is diminished. Notice that
for this study we have assumed a uniform access latency for
the integer register ﬁle at different sizes. A reliable design
based on full register duplication will either require large
size register ﬁles or signiﬁcantly limit the success rate of
duplication. In the following study, we focus on a medium
size, 128-entry integer register ﬁle, which simulates the reg-
ister pressure in wide-issue datapaths while avoiding the
unnecessary performance overhead of the full-duplication
scheme.
4. Narrow-Width Register Values
In high-performance 64-bit microprocessors, many gen-
erated register values during the execution of general-
purpose applications do not require the full width of 64 bits.
Values that can be represented by less than 64 bits are called
narrow-width values in this paper. The presence of narrow-
width values has been well studied and exploited for perfor-
mance and power optimizations [4][14][13][6]. Different
from the previous work, we exploit narrow-width register
values for improving the register ﬁle reliability against soft
errors.
We present a similar study on the data-width distribution
of integer register values for SPEC CINT2000 benchmarks
(Alpha binaries) as in [4][13]. In the following discussion,
we use the terms register value and data value interchange-
ably with integer register value. The detailed cumulative
data-width distribution is given in Figure 2 (b). The data-
width (W ) of a given register value is determined as fol-
lows: W = 64 − (LS − 1), where LS is the number of
leading 0’s or leading 1’s. A data value V at width W can
be represented by W bits instead of 64 bits in the follow-
ing way: V = bW−1bW−2...b0, where bW−1 is the sign bit,
bW−1 ⊕ bW−2 = 1, and W ≤ 64. Figure 2 (b) shows that
on the average 54% of the generated register values have a
data-width no more than 32 bits, and the difference between
32 bits and 33 bits is negligible. However, there is a signif-
icant 40% jump from 33 bits to 34 bits. This is because
the memory address in the Alpha ISA uses 33 bits (plus
1 sign bit = 34 bits) and memory operations account for
a large portion of the executed instructions. Please notice
that 1) the operations generating these memory addresses
are different from the address calculation in a load/store in-
struction, and 2) compiler options or large-size programs
may change the data width of memory addresses. Overall,
around 94% of the integer values can be represented by no
more than 34 bits, an average for SPEC CINT2000 bench-
marks.
We also observed that small values present a signiﬁ-
cant percentage. For example, 46% of the generated values
can be represented by no more than 16 bits. This percent-
age increases to 51% for data-width ≤ 21 bits. Exploit-
ing these small values enables duplicating multiple repli-
cas of the original data value within the same register, thus
achieving N-modular redundancy (N ≥ 3) for the value.
However, such a scheme complicates the design in order
to capture multiple levels of narrow-width values and pro-
vide different error detection and recovery mechanisms. In
this work, we exploit the large percentage of narrow-width
values, especially with data-width ≤ 34 bits, for design-
ing high-performance error-resilient register ﬁles using in-
register duplication.
5. Exploiting Narrow-Width Register Values
In this section, we present our reliable register ﬁle de-
sign that exploits the generated narrow-width register val-