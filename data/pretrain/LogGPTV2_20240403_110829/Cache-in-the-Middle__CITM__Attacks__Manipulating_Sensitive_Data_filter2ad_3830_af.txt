International Conference on Detection of Intrusions and Malware, and Vulnerability
Assessment. Springer, 3–24.
Session 3E: Fuzzing/Trusted Execution Environments CCS '20, November 9–13, 2020, Virtual Event, USA1013[52] Andrew Sloss, Dominic Symes, and Chris Wright. 2004. ARM System Developer’s
Guide: Designing and Optimizing System Software. Morgan Kaufmann Publishers
Inc., San Francisco, CA, USA.
[53] Raoul Strackx and Frank Piessens. 2016. Ariadne: A Minimal Approach to State
Continuity. In Proceeding of usenix security symposium.
[54] He Sun, Kun Sun, Yuewu Wang, and Jiwu Jing. 2015. TrustOTP: Transforming
Smartphones into Secure One-Time Password. In Proceeding of ACM computer
and communications security (CCS).
[55] He Sun, Kun Sun, Yuewu Wang, Jiwu Jing, and Haining Wang. 2015. TrustICE:
Hardware-Assisted Isolated Computing Environments on Mobile Devices. In Pro-
ceeding of IEEE/IFIP International Conference on Dependable Systems and Networks
(DSN).
[56] Min Hong Yun and Lin Zhong. 2019. Ginseng: Keeping Secrets in Registers When
You Distrust the Operating System.. In NDSS.
[57] Fengzhe Zhang, Jin Chen, Haibo Chen, and Binyu Zang. 2011. Cloudvisor:
retrofitting protection of virtual machines in multi-tenant cloud with nested
virtualization. In Proceedings of the Twenty-Third ACM Symposium on Operating
Systems Principles. 203–216.
[58] Ning Zhang, He Sun, Kun Sun, Wenjing Lou, and Y Thomas Hou. 2016. CacheKit:
Evading memory introspection using cache incoherence. In 2016 IEEE European
Symposium on Security and Privacy (EuroS&P). IEEE, 337–352.
[59] Ning Zhang, Kun Sun, Wenjing Lou, and Y Thomas Hou. 2016. Case: Cache-
assisted secure execution on arm processors. In 2016 IEEE Symposium on Security
and Privacy (SP). IEEE, 72–90.
[60] Ning Zhang, Kun Sun, Deborah Shands, Wenjing Lou, and Y Thomas Hou. 2016.
TruSpy: Cache Side-Channel Information Leakage from the Secure World on
ARM Devices. IACR Cryptology ePrint Archive 2016 (2016), 980.
[61] Shijun Zhao, Qianying Zhang, Yu Qin, Wei Feng, and Dengguo Feng. 2019.
SecTEE: A Software-based Approach to Secure Enclave Architecture Using TEE.
In Proceedings of the 2019 ACM SIGSAC Conference on Computer and Communica-
tions Security. 1723–1740.
A SHAREABILITY ATTRIBUTE ON ARM
PROCESSORS
We conduct a series of experiments to better understand the impacts
of the shareability attribute on the non-secure L1 data caches [5].
We conduct the experiments on the i.MX6Quad sabre development
board, which equips with a quad-core ARM Cortex-A9 processor
running at 1.2GHz and 1GB DDR3 SDRAM. Since the board has
only one cluster, the inner shareability domain is equal to the outer
shareability domain. In other words, the inner shareable has the
same effect as the outer shareable. Since the shareability attribute is
utilized to enforce value coherence when the same data is accessed
by multiple cores, we make all four cores access the same physical
memory (hereinafter referred to as test memory). We make all cores
run in the normal world, so that the L1 cache accessed by them
will all be non-secure. To eliminate the potential impacts on L1
cache introduced through L2 cache and memory, we disable the
L2 cache and set the test memory as secure memory. We opt to
set the test memory as secure rather than utilizing the memory
isolation scheme in SANCTUARY, since that scheme is only sim-
ulated through the ARM Fast Models virtualization tools and is
not achievable on the actual development boards. To prevent the
raising of external abort due to accessing secure memory from the
normal world, we set the test memory as write-back, write-allocate
and all other memory as non-cacheable. As such, the writing of test
memory will be buffered and locked in the L1 cache, and will not be
synchronized to memory. The test memory and the corresponding
L1 data cache are all initialized to zero.
We first investigate the impacts of data coherency when enabling
the shareability attribute. Specifically, we set the test memory as
shareable for all the four cores. Then, we store (i.e., write) 0xffff
to core_0’s L1 data cache mapping to test memory, and load (i.e.,
read) L1 data cache of each core addressed through test memory.
Table 1: L1 Cache When Enabling Shareable Attribute
Shareability
Attribute
of the Cores
Core_0 (Shareable)
Core_1 (Shareable)
Core_2 (Shareable)
Core_3 (Shareable)
Value on the Core’s L1 Data Cache
After Writing
After Writing
0xffff to Core_0
0xdddd to Core_1
0xffff
0xffff
0xffff
0xffff
0xdddd
0xdddd
0xdddd
0xdddd
Table 2: L1 Cache When Disabling Shareable Attribute
Shareability
Attribute
of the Cores
Core_0 (Non-shareable)
Core_1 (Shareable)
Core_2 (Shareable)
Core_3 (Shareable)
Value on the Core’s L1 Data Cache
After Writing
After Writing
0xffff to Core_0
0xdddd to Core_1
0xffff
0x0
0x0
0x0
0xffff
0xdddd
0xdddd
0xdddd
As illustrated in Table 1, value 0xffff on core_0’s L1 data cache is
synchronized to the other three cores. Thereafter, we store 0xdddd
to core_1’s L1 data cache, and find all cores’ L1 data caches are
synchronized again. It shows that the data on one core’s L1 data
cache could be leaked out to and manipulated by another core,
when the two cores run in the normal world and the corresponding
memory is set as shareable for both cores. Table 2 illustrates the
results obtained by disabling the shareability attribute. Particularly,
we modify the test memory’s cache attribute as non-shareable (i.e.,
inner&outer non-shareable) for core_0 and repeat the experiment.
It shows that data on the core’s L1 data cache could not be leaked
out to or manipulated by another core, when the corresponding
memory is set as non-shareable for that core.
To set different cache attributes for multiple cores when access-
ing the same physical memory region (i.e., the test memory), we
construct four page table entries, which map to the same physical
memory region and define different cache attributes for this phys-
ical memory region. After assigning one entry to each core, the
four cores can access the same memory region with different cache
attributes.
B EVALUATION OF THE DEFENSE SYSTEM
We evaluate the overhead introduced by our defense system based
on the prototype implemented on the i.MX6Quad SABRE develop-
ment board, which is equipped with a quad-core ARM Cortex-A9
processor running at 1.2GHz with 1GB DDR3 SDRAM. To minimize
the noise in the experiments, we run each test with 1,000 iterations
and report the average.
We first explore the overhead on security-sensitive applications
due to the enforced cache attributes. Particularly, we run an AES
encryption application in one IEE, and evaluate its execution time
when the memory is configured with different cache attributes. In
Table 3, the default configuration for most memory region is shown
in the second column, where S, WB, WA, With L1&L2 means setting
the cache attributes as shareable 2, inner write-back write-allocate,
outer write-back write-allocate. The attributes enforced by our de-
fense system are shown in the fourth column, where non-S, WT,
2Since the i.MX6Quad board has only one cluster, shareable is equal to inner shareable
or outer shareable.
Session 3E: Fuzzing/Trusted Execution Environments CCS '20, November 9–13, 2020, Virtual Event, USA1014Table 3: AES Encryption Time (in Milliseconds)
Table 5: Loading Time Results on Rich OS (in Seconds)
3.9
7.5
15.4
*
Without L2
With L1&L2
non-S, WT, non-WA,
non-S, WT, non-WA,
S, WB, WA,
With L1&L2
Payload
(Bytes)
1024
2048
4096
"S,WB,WA,With L1&L2": shareable, inner write-back write-allocate, outer write-
back write-allocate;
"non-S,WT,non-WA,With L1&L2": non-shareable, inner write-through non write-
allocate, outer write-through non write-allocate;
"non-S,WT,non-WA,Without L2": non-shareable, inner write-through non write-
allocate, outer non-cacheable.
6.8
13.4
28.7
4.5
8.8
18.1
Table 4: Benchmark Results on Rich OS
Test Item
RAM
CPU Integer
CPU Float-point
2D Graphics
3D Graphics
Database I/O
SD Card Write
SD Card Read
Total
Protection
Disabled
486
698
567
282
861
310
38
186
3428
Protection
Enabled
475
692
564
281
852
255
36
182
3337
Overhead
2.26%
0.86%
0.53%
0.35%
1.05%
17.74%
5.26%
2.15%
2.65%
non-WA, Without L2 represents non-shareable, inner write-through
non write-allocate, outer non-cacheable. The cache attributes illus-
trated in the third column are similar to the ones in our defense
system, but with L2 cache enabled. The experimental results show
that our defense system introduces around 90% overhead compar-
ing to the default setting, and it is mainly caused by disabling L2
cache. We also observe that for the IEE systems that disable the L2
cache for protection (e.g., SANCTUARY), our defense system only
introduces negligible additional overhead.
Test Item
Kernel
Android Home
Calculator
Calendar
Music
Settings
Protection
Disabled
22.26
87.42
3.01
3.14
1.26
3.77
Protection
Enabled
23.71
89.81
3.22
3.34
1.37
3.95
Overhead
6.51%
2.73%
6.98%
6.37%
8.73%
4.77%
Then, we evaluate the overhead on the rich OS introduced by
the additional cross-domain context switches enforced on each
page table updating operation. We first study the overall overhead
through a comprehensive benchmark suite, i.e., AnTuTu 2.9.4 [3].
It measures the performance in integer computation, float point
operation, 2D and 3D graphic rendering etc. The results are illus-
trated in Table 4, which shows 2.65% overall overhead is introduced
on the execution of rich OS. The primary reason for the 17.74%
overhead on the Database I/O operations is the need of building
a mass of page table mappings when copying data from the disk to
the memory.
We also evaluate the overhead on the operations that involves
frequent page table updating, i.e., the system booting and applica-
tion loading. As illustrated in Table 5, the test item Kernel records
the loading time from the hardware booting to the starting of the
init process. Android Home refers to the initialization time of the
Android Launcher process. We also test the loading time of four
Android applications, including Calculator, Calendar, Music and
Settings. Overall, the loading overhead for both kernel and appli-
cations is less than 10% in all evaluation scenarios.
Session 3E: Fuzzing/Trusted Execution Environments CCS '20, November 9–13, 2020, Virtual Event, USA1015