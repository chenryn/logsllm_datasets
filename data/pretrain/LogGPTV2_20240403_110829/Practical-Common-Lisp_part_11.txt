（AND （EQUAL（GETF CD:TITLE)“Give US a Break")
(EQUAL
:ARTIST"Limpopo"
www.TopSage.com
:RATING10:RIPPEDT))
---
## Page 51
法所存在的差异。
4.2
语言变得更为强大。接下来的几章将告诉你为什么会这样。
的新一代程序员也许会最终实现它。
放弃，它只不过是被无限期地推迟了。（相比S-表达式）更加偏爱类FORTRAN或类Algol表示法
Lisp?中对此加以解释。
类Algol的语法，他称之为M-表达式。尽管如此，他却从未实现这一点。他在自己的文章History of
贵的历史经验来说明保持开放的思想是值得的：John McCarthy首次发明Lisp时，曾想过实现一种
两个团体之间会有如此对立的见解呢？
Superfluous Parentheses）的简称；而Lisp的追随者则认为，Lisp的语法是它的最大优势。为什么
种语法描述成“奇怪的”和“讨厌的”，他们说Lisp就是“大量不合理的多余括号”（Lots of Iritating
用了括号和前缀表示法。说来也怪，大量的追随者都喜欢这样的语法。Lisp的反对者们总是将这
4.1括号里都可以有什么
先回答下面这个问题·…
换句话说，过去45年以来，实际使用Lisp的人们已经喜欢上了这种语法，并且发现它能使该
这个精确定义M-表达式以及将其编译或至少转译成S-表达式的工程,既没有完成也没有明确
本章不可能完整地描述Lisp的语法，因为我还没有彻底地解释Lisp的宏，但我可以从一些宝
① http://www-formal.standford.edu/jmc/history/lisp/node3.html.
在介绍Lisp的语法和语义之前，值得花一点时间来看看它们的定义及其与许多其他语言的语
Lisp的语法和源自Algol的语言在语法上有很多不同。两者特征最明显的区别在于前者大量使
打开黑箱
语法和语义
www.TopSage.com
---
## Page 52
S-表达式语法以及求值器所理解的Lisp表达式语法。
我将在后续章节详加论述。目前我将集中在Common Lisp所定义的两个层面上：读取器所理解的
大致相同。尽管如此，真正的优势在于可通过处理现有数据来生成代码。这就是Lisp宏的本意，
非文本形式来生成代码。完全从手工生成代码的好处很有限——构造列表和构造字符串的工作量
个后果则在于，由于语言的语义是用对象树而非字符串定义而成的，因此很容易使用语言本身而
一种可暴露的数据格式来表达源代码之外的数据，用READ来读取它再用PRINT来打印它。?另一
于Lisp形式来说是没有意义的。
和（"foo”12)都是S-表达式，但只有前者才是一个Lisp形式，因为一个以字符串开始的列表对
式都是合法的Lisp形式，更不用说所有字符序列都是合法的S-表达式了。举个例子，（foo1 2)
用来表达任意树形表达式，这跟由非Lisp语言的语法解析器所生成的抽象语法树非常相似。
的Lisp对象。由于S-表达式语法可适用于由任意对象及其他列表所组成的列表，因此S-表达式可
子称为读取器，后一个称为求值器。?
了两个黑箱，一个将文本转化成Lisp对象，而另一个则用这些对象来实现语言的语义。前一个箱
来说都是这样。与--个从文本到程序行为一步到位的单一黑箱有所不同的是，Common Lisp定义
者有用。
理器是一种黑箱，所以处理器所使用的包括语元和抽象语法树在内的数据结构，只对语言的实现
个求值器，求值器要么直接解释它，要么将其编译成某种其他语言（比如机器码)。由于语言处
该语言的语法在程序中构建一个表达式的树形表示。这棵树被称为抽象语法树，它随即被送进一
一个阶段提供内容：一个词法分析器将字符流分拆成语元并将其送进一个解析器，解析器再根据
预想行为，要么产生一个编译版本的程序并在运行时执行这些行为。
作业：一系列表示程序文本的字符被送进黑箱，然后它（取决于是解释器还是编译器）要么执行
① 和任何语言的实现者一样，Lisp实现者们有许多方式可以实现一个求值器，从一个解释那些直接送进求值器的对
这样的黑箱划分方法带来了一系列后果。其中之一是可将S-表达式（正如第3章那样）用作
求值器随后定义了一种构建在S-表达式之上的Lisp形式（form）的语法。并非所有的S-表达
每个黑箱都定义了一个语法层面。读取器定义了字符串如何被转换为我们称之为S-表达式
而在CommonLisp中，分工则有点不同，无论从实现者的角度还是从语言定义方式的角度上
③并非所有的Lisp对象都可以被写成一种可以被读回来的形式，但任何你可以用READ读取的东西都可以被PRINT
② 术语“S-表达式”有时代表文本表示，而有时则代表从文本表示中读取到的对象。通常从上下文中可以清楚地判
当然，在黑箱的内部，语言的处理器通常划分成子系统，各自负责一部分将程序文本转换成
在大多数编程语言里，语言的处理器（无论是解释器还是编译器）的操作方式都类似于黑箱
断它的含义，或者怎样理解都无所谓。
打印成可读的形式。
甚至在运行期求值代码的时候也是这样。
虚拟机字节码这样的中间形式，然后解释执行字节码。近年来，多数Common Lisp实现都使用某种形式的编译，
象的“纯”解释器，到一个将对象转化成机器码并执行的编译器。在这两者之间，还有些实现将输人编译成类似
www.TopSage.com
4.2
打开黑箱
35
---
## Page 53
含义。下面是一些字符串的示例：
反斜杠本身。所有其他的字符无需转义即可被包含在一个字符串里，无论它们在字符串之外有何
转义接下来的任意字符，使其被包含在字符串里。两个在字符串中必须被转义的字符是双引号和
我将在第10章详细讨论不同类型数字的特征。
面，1.0、1.0d0和1则可能会代表不同的对象，因为不同精度的浮点数和整数都是不同类型的对象
123的对象并没有什么不同。与此相似，1.0和1.0e0也只是同一个数字的不同写法而已。但另一方
数和比值）在内部都被表示成“简化”形式。换句话说，表示－2/8或246/2的对象跟表示－1/4或
其自己的表示法，第10章将予以介绍。
或-)，还可能会有一个十进制点（.）或者斜杠（/)，或是以一个指数标记结尾。例如：
字。之后我将说明由这些元素所组成的S-表达式是如何作为Lisp形式求值的。
原子的规则了。在本节里我将描述几种常用原子类型的规则，这些原子包括：数字、字符串和名
结尾，本质上将被当作空白来处理。
也就是原子或嵌套的列表)。注释从技术角度来讲不是S-表达式，它们以分号开始，直到一行的
的由空格所分隔的元素。原子是所有其他内容。?列表元素本身也可以是S-表达式（换句话说，
4.3
从这些示例可见，你可以用多种方式来表示同一个数字。但无论怎样书写，所有的有理数（整
这就差不多了。列表在句法上十分简单，你需要知道的句法规则只有那些用来形成不同类型
36
①空列表即（），也可写成NIL，既是原子也是列表。
正如在前面章节所看到的那样，字符串是由双引号所包围着的。在字符串中，一个反斜杠会
 数字的表示方法很简单。任何数位的序列将被读取为一个数字，它们可能有一个前缀标识（十
S-表达式的基本元素是列表（list）和原子（atom)。列表由括号所包围，并可包含任何数量
Lisp中所使用的名字，诸如FoRMAT、hello-world和*db*均由称为符号的对象所表示。读
这些不同的形式代表着不同类型的数字：整数、比值和浮点数。Lisp也支持复数，但它们有
"fol"o#
"follo"
"fo\o"
“foo"
246/2
-2/8
-1/4
1.0e-4
1.0d0
1.0e0
6
S-表达式
第 4章 
；含有f、〇、
含有f、、\和o的字符串
同一个字符串
含有f、和o的字符串
整数一百二十三的另一种写法
负四分之一的另一种写法
双精度的浮点数一
同
默认精度的浮点数一
整数一百二十三
价于万分之一的浮点数
语法和语义
一个浮点数的另一种写法
值七分
十二
之
“和○的字符串
www.TopSage.com
---
## Page 54
示任意的树状对象。下面是一些简单的例子。
前的关键是要理解怎样用数字、字符串和由符号借助括号所组成的列表来构建S-表达式，从而表
向量、单个字符和数组的标识，我将在第10章和第11章里谈及相关的数据类型时再讲解它们。目
、1、2、以及&。
底层的函数名前加%甚至%%。语言标准所定义的名字只使用字母表字符（A-Z）外加*、十、一、
有所不同，诸如可以使用像hello-world这类带有连字符的名字。另一个重要约定是全局变量
号。这样，无论在任何地方，同样的名字出现在任何S-表达式里，都会用同一个对象去表示它。
已有符号。如果无法找到，则将创建一个新符号并添加到表里。否则就将返回已在表中的那个符
并将其全部转化成大写形式以后，读取器在一个称为包（package）的表里查询带有相同名字的
风格是将代码全部写成小写形式，然后让读取器将名字转化成大写。?
为什么在REPL中定义一个函数时，它的名字会被打印成大写形式的原因。近年来，标准的编码
一个符号FOO。但\f\o\o和”fo|将都被读成foo，这是和符号FOo不同的另一个对象。这就是
名字中未转义的字符都转化成它们等价的大写形式。这样，读取器将把foo、Foo和FOo都读成同
大小写，另一个是它如何确保相同的名字总被读取成相同的符号。当读取名字时，读取器将所有
用竖线包起来。
它们也可以成为名字的一部分，只需将它们用反斜杠进行转义，或是将含有需要转义的字符名字
和单引号、反引号、逗号、冒号、分号、反斜杠以及竖线。而就算是这些字符，如果你愿意的话
名字。有十个字符被用于其他句法目的而不能出现在名字里，它们是：开括号和闭括号、双引号
名字不被解释成一个数字。类似地，名字可以包含句点，但读取器无法读取一个只由句点组成的
不过空白字符不可以，因为列表的元素是用空格来分隔的。数位也可以出现在名字里，只要整个
取器对于一个给定名的用途毫不知情一
为了确保同一个文本名字总是被读取成相同的符号，读取器保留这个符号——在已读取名字
这种读取器将名字转化成符号对象的方式有两个重要特征，一个是它如何处理名字中的字母
③我将在第21章里讨论符号和包之间关系的更多细节。
② 事实上，读取器的大小写转化行为是可以定制的，但是要想理解何时以及怎样改变它，则需要在相关的名字、符
① 事实上，正如你后面将要看到的，名字从本质上是一种独立的概念。根据不同的上下文，你可以使用相同的名字
只用列表、数字、字符串和符号就可以描述很大一部分的Lisp程序了。其他规则描述了字面
因为在Lisp中名字可以包含比源自Algol的语言更多的字符，故而命名约定在Lisp中也相应地
号和其他程序元素中，相对我已经涉及的内容做更加深人的讨论。
来同时引用一个变量或者函数，更不用说其他几种可能性了。
(xyz)
("foo" “bar"）
?
23)
三个符号所组成的列表
两个字符串所组成的列
三个数字所组成的列表
空列表
符号X
www.TopSage.com
一无论其究竟用作变量名、函数名还是其他什么东西。读
表
4.3
S-表达式
37
---
## Page 55
时，它会自动定义一个以此命名的常值变量并以该符号作为其值。
以这种方式定义的常量是和NIL，即所谓的真值和假值。我将在4.8节里讨论它们作为布尔值的
world"实际上就是自求值对象的例子了。
达式被传递给假想函数时，它会简单地直接返回自身。第2章在REPL里键入的10和"hello，
得到这个值的。你也需要注意，某些特定的“变量”其实是编程领域的早期产物“常值变量”
形式被求值时会被视为一个变量名，并且会被求值为该变量的当前值。?第6章将讨论变量是如何
我们从不同类型的Lisp形式如何被这个假想的函数求值的角度来描述CommonLisp的语义。
求值器被给定一个表达式，然后生成在其运行时可以计算出相应值的代码。但是这种简化可以让
称之为这个形式的值。当然，当求值器是一个编译器时，情况会更加简化一些——在那种情况下，
以将求值器想象成一个函数，它接受一个句法良好定义的Lisp形式作为参数并返回一个值，我们
号为首元素的列表那样。
面的句法规则相当简单。任何原子（非列表或空列表）都是一个合法的Lisp形式，正如任何以符
的，CommonLisp的求值规则定义了第二层的语法来检测哪种S-表达式可看作Lisp形式°。这一层
者只有它们中的一些可以——并不是每个读取器可读的S-表达式都有必要作为Lisp形式来求值
4.4作为Lisp形式的S-表达式
(constantvariable）。例如，符号PI命名了一个常值变量，其值是最接近数学常量π的浮点数。
含有两个符号和一个字符串：
角色。
作为最简单的Lisp形式，原子可以被分成两个类别：符号和所有其他内容。符号在作为Lisp
当然，Lisp形式的有趣之处不在于其语法，而在于它们被求值的方式。为了便于讨论，你可
把符号变成自求值对象也是可能的——它们所命名的变量可以被赋值成符号本身的值。两个
38
②另一种很少用到的Lisp形式的类型是那种第一个元素是lambda表达式的列表。我将在第5章里讨论这类形式。
①当然如同其他语言那样，其他层面的纠错也存在于Lisp中。例如，从读取（foo12）得到的S-表达式在句法上是
另一类自求值符号是关键字符号一
所有其他的原子，包括你已经见过的数字和字符串，都是自求值对象。这意味着当这样的表
在读取器把大量文本转化为S-表达式以后，这些S-表达式随后可以作为Lisp形式被求值。或
③存在另一种可能性一
(defunhello-world()
良好定义的，但是只有当foo是一个函数或宏的名字时，它才可以被求值。
（x1"foo"）
（formatt"hello，
第4章语法和语义
；由一个符号、一个数字和一个字符串所组成的列表
一可以定义出符号宏（symbolmacro），它可被稍有不同地求值。我们无需理会它们。
world"))
www.TopSage.com