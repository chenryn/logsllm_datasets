WAEP 
WPFV 
Missing variable 
initialization 
Missing variable 
assignment 
using a value 
Wrong arithmetic 
function 
call 
expression 
used in parameter of 
Wrong variable 
used in parameter 
offunction 
call 
most frequently 
observed 
a small set offault emulation 
in the field 
operators; 
of a code change representing 
the class of fault 
identifying 
where that change can be 
Our work is built on top of 
made in a program. 
fault classes 
software 
(Table 1) through 
they consist 
and a code pattern 
realistically 
these efforts to evaluate 
of injected 
faults. 
and improve the representativeness 
The first research 
problem arising 
from the above 
that pre-release 
in complex software differently 
of field 
to triggers 
[11,18] observed 
Field data studies 
is whether emulated 
faults are triggered 
conditions 
is similar 
activation 
whose trigger 
by 
or not, since we aim 
are distributed 
defects, 
observations 
representative 
to inject faults 
faults. 
defects (i.e., those found during system and function 
testing) 
than post-release 
more prone to be hidden where testing 
This fact is relevant 
since fault injection 
commonly adopted during the late phases of the system's 
namely after or at the same time of function 
lifecycle, 
and system testing, 
purposes 
(section 
faults 
are representative 
of faults 
analyzing 
encountered 
if they can be triggered by 
testing 
if injected 
by 
since post-release 
for dependability 
we investigate 
2). Therefore, 
in this context, 
to our problem, 
activities. 
evaluation 
defects 
are 
is less effective. 
is 
In 
of 
process 
testing 
testing 
function 
results, 
and to obtain 
to the testing 
contributor 
procedures. 
into the analysis, 
it is the most significant 
is influenced 
(e.g., which 
analysis 
to ensure the realism 
In order to perform a rigorous 
it is necessary 
In fact, test effectiveness 
should be tested more thoroughly). 
we adopted 
these factors 
of a complex system. 
is not the only mean to address 
meaningful 
testing 
by many factors 
related 
functionalities 
order to include 
the real suite for function 
Although 
software faults, 
detect faults in complex systems [5]. We systematically 
analyze injected 
individual 
compasses 
only in a small subset of test cases, then the activation 
condition 
of events specific 
In this case, the fault can be considered 
activation 
it. We discriminate 
by counting 
fault; 
non-elusive 
arbitrary, 
that this choice does not significantly 
faults 
each 
the number of test cases that detected 
if more than 50% of test cases detect the fault, 
it is a 
test cases from the test suite; 
a different 
is subtle and testing 
between elusive 
could have missed 
and non-elusive 
the system under 
each test case en­
and we will demonstrate 
If the fault is activated 
the 50% threshold 
is a combination 
it is the fairest 
affect results. 
by executing 
to that subset. 
set of inputs. 
condition 
may appear 
Although 
elusive, 
faults, 
choice, 
fault. 
since its 
to 
The second research 
problem is how to remove 
from a faultload, 
faults 
To this aim, we need to discriminate 
to improve its represen­
between 
faults a priori, 
without requiring 
of a test suite to evaluate 
the elusiveness 
and non-elusive 
non-elusive 
tativeness. 
elusive 
the availability 
of faults. 
features 
elusive 
techniques 
We consider 
complexity 
in which the fault is injected, 
between complexity 
to characterize 
software 
A way to achieve 
to each fault, 
and software 
related 
this goal is to collect 
and to use statistical 
a set of 
analysis 
faults. 
of the component 
(representative) 
metrics 
due to the relationship 
faults 
[4]. 
The approach 
adopted in this paper to answer to these 
two problems 
can be summarized 
as follows: 
3 Problem statement and research method­
ology 
The problem of adequate 
fault emulation 
(described 
in 
faults, 
1) is related 
is a condition 
that 
to the two aspects 
that characterize 
fault is deemed representative 
user inputs, 
environment 
it can encompass 
system state, and the external 
namely the fault type and the fault trig­
to the kind of change in the 
section 
software 
ger [6]. The fault type relates 
code to fix the fault. The fault trigger 
allows the fault to surface; 
the internal 
such as the OS. An injected 
when its fault type and fault trigger 
fault types and triggers 
field. Although 
representativeness 
with respect 
of a way to assure the representativeness 
In G-SWFIT, fault types are well emulated, 
operators 
in the field (Table 1), as demonstrated 
study on 668 faults over 12 real-world  applications 
Instead, 
the available 
about them. Therefore, 
to the 
occurring 
in the 
focused on 
to fault types, there is a lack 
more than 50% of fault types found 
by a large field data 
field data did not include any information 
past work on fault injection 
[10]. 
, since 
are not considered 
of the fault trigger. 
G-SWFIT applies 
most frequently 
fault operators 
fault triggers 
since its fault 
in G-SWFIT
are similar 
encompass 
978-1-4244-7501-8/10/$26.00 
©201O IEEE 
439 
DSN 2010: Natella et al. 
2010 IEEE/IFIP International 
Conference 
on Dependable 
Systems & Networks (DSN) 
1. We generate 
a large set of faulty versions 
of the target 
system. 
Each version 
contains 
one fault; 
2. We select a set of test cases from the original 
test suite 
3. Each faulty version 
is executed 
several 
times, one for 
of the system; 
each test case; 
4. Data about system failures 
are collected 
for each exper­
iment; moreover, 
information 
about the statement 
to gain additional 
insights, 
we collect 
of test cases; 
coverage 
distribution 
their amount (first research 
to find non-elusive 
5. We analyze the failure 
faults and evaluate 
problem); 
6. We analyze 
software complexity 
metrics 
related 
location 
identifying 
problem). 
of each fault, in order to define criteria 
non-elusive 
faults 
a priori (second research 
to the 
for 
software faults 
in its source code. It 
program to inject 
a source code file to identify 
suitable 
locations 
It then generates 
of the source file, each containing 
target 
first analyzes 
where fault types in Table I can be applied. 
a set of faulty versions 
a single fault (Figure I). The tool identified 
fault locations; 
those locations 
mentioning 
faults 
we injected 
a sample of 40,402 faults in 
tested by at least one test case. It is worth 
of more than 40 thousand 
campaign. 
that the injection 
a quite extensive 
fault injection 
represents 
384,650 
r'-1 '"'" ',",re 00"  '"'"  """ '"'"  
h...J t...,/ L- _an_a_IYS_
C/C++ 
source file 
iS----'  L.....V L-ln_ie_cto_r--1 L.....V l-:J 
Faulty source 
file versions 
4 Evaluation 
of fault representativeness 
Figure 2 shows the experimental 
setup. Several 
faulty 
Figure 1. Software 
fault injection 
tool. 
In this section, 
we first provide details 
about the case 
setup, and then we discuss 
the 
study and the experimental 
results 
we obtained. 
4.1 Case study and experimental 
setup 
MySQL is one of most used among all DBMSes, 
for about 30% of installations 
accounting 
'. The popularity 
of MySQL is also due to the 
organizations
based on it 
applications 
overall 
adoption 
over the web. The wide use of MySQL 
for running 
in business-critical 
contexts 
benchmark 
of a dependability 
of Off-The-Shelf 
services 
among IT 
[21]. 
makes it a representative 
target 
The MySQL DBMS is also representative 
of complex 
an individual 
to execute every faulty version 
namely Test 
compiled. 
was developed 
I 00 experiments 
were exe­
are preliminarily 
of the DBMS (each containing 
A program, 
versions 
fault) 
Controller, 
for each test case; in total,  2,020, 
cuted. For each experiment, 
collected, 
to an SQL query, and the timeout 
only interested 
fault (i.e., to cause a failure), 
the type of failure 
among 4 workstations 
2.4GHz CPU, 4 Gb RAM, and a SATA 3 Gb/s NCQ disk. 
i.e., the crash of the DBMS, an incorrect 
of the test. Since we are 
mode. The experiments 
whether the test case is able to detect a given 
of the test case were 
the results 
equipped 
with an Intel Core2Duo 
we did not take into account 
answer 
were distributed 
SQL queries 
, 
1. MySQL is  ' 
with a : 
replaced 
faulty version : 
, 
I 
collection 
I 
I 
I 
Test result 
: .Rs!,lts 
I 
_  --.. -- ....I 
the 
we targeted 
and functional 
used for regression 
and most fundamental 
to 
the MySQL core, since it is 
part of the DBMS. The 
it is made up of more than 700K Lines 
among 2K files. Moreover, 
along with the source code, which 
testing. 
Test 
software systems; 
of Code (LoC) distributed 
DD 
test suite is provided 
is actually 
cases are grouped based on the set of functionalities 
• I 
test. In particular, 
I 
I 
the largest 
I 
core is in charge of managing threads 
SQL query parsing, 
optimization, 
suite provides 
carefully 
between the time required 
and the need of a sample large enough to be representative. 
Test cases were randomly sampled, 
similar 
and execution. 
We 
473 test cases for core functionalities. 
50 test cases; this number is a trade-off 
2. A test case '--_
is executed 
for the experimental 
and connections, 
and those cases too 
Test case 
analysis, 
selected 
The test 
he!!!!!! 
between them were discarded. 
tool2 automated 
A fault injection 
the fault injection 
process 
of this study. The tool analyzes 
and modifies the 
.http://www.mysql.com/why-mysql/marketshare/ 
2Available 
at http://www.mobilab.unina.it/SFI.htm 
Figure 2. Experimental 
setup. 
4.2 Result discussion 
During the experimental 
of 2 million 
of experiments 
campaign, 
were observed. 
282,739 failures 
Since some test 
out 
978-1-4244-7501-8/101$26.00 
©2010 IEEE 
440 
DSN 2010: Natella et al. 
2010 IEEE/IFIP International 
Conference 
on Dependable 
Systems & Networks (DSN) 
(they detect less than 1 % of 
cases proved not to be effective 
the injected faults) 
them from the test suite. 
were kept, accounting 
Failure 
rences for each fault and test case are shown in Figure 3. 
and would skew the results, 
After this operation, 
we removed 
40 test cases 
occur­
for 281,027 failures. 
E 
_ Falledruna 
_  Correct runs 
c::::::::J 
Fault not covered 
(1 ) 
(2) 
100 
90 
 80 
'II  70 
c 
 ::I 80 " ., .. ., 
"0 50 
., '" ! 40 
c ., " 30 
i 
20 
10 
0 
5 
10 
15 
.. 'II 
rl 20 
t:i  25 
30 
35 
40 0  0.5 
.. ..:  -:::-
.... ---
-
. 
. .. _--
-
-
-- --...  It ...... 
_ 
1.5  2 
2.5  3 
Fault 
3.5 
0.5 
1.5  2 
2.5  3 
3.5 
Fault 
Key:  G) Elusive faults, 
activated 
in a low number 
• 
xl0 
of executions (21.83%) 
  Elusive faults, 
covered in a low number 
of cases (63.60%) 
Q)  Non-elusive 
faults (14.57%) 
in which a failure 
Figure 3. Experiments 
occurred. Points represent 
in which a given fault was activated 
given test case, causing  a 
Faults are 
observed. 
ordered by number of failures 
failure. 
by a 
experiments 
of failures 
Figure 4. Percentages 
executions 
by the percentage 
executions, 
and correct 
for each fault. Faults are ordered 
and correct 
respectively. 
of failures 
under specific activation 
conditions, 
only when the faulty 
is executed 
since they cause a failure 
real faults, 
location 
which can be missed during testing. 
activation 
by input and state variables. 
unfeasibility 
of exhaustive 
can be related 
condition 
testing 
For instance, 
the 
to specific values took 
to the 
This problem is related 
in complex systems [ I]. 
Faults detected 
Faults covered, not detected 
c=J  Faults not covered 
In the figure, points represent 
an experiment 
in which 
white areas represent  experiments 
in which the 
by a given test case, causing 
a given fault was activated 
a failure; 
test case was not able to detect the fault. 
are detected 
these faults 
are easily detected 
The histogram 
by most of test cases (right 
should be considered 
in Figure 4 provides 
by tests. 
Part of the faults 
side of the figure); 
as non-elusive, 
since they 
faults 
axis). 
of failures 
executions 
bar represents 
a perspective 
from the 
For ease of reading 
and non-elusive 