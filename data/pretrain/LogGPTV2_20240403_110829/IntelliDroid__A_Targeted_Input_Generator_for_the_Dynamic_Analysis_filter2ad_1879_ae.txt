2 5 6
5
1 2
2
4
4
1
1
1
1
1
1
5
5
4
5
5
3
2
3
3
2
3
4
2
4
4
2
2
2
5
1
3
2
1
2
1
2
4
4
4
4
2
Life
6
6
5
5
5
5
5
1
1
5
5
5
6 → 1
5
5
5
UI
5
6
1
1
5
3
1
* Malicious behavior triggered
* Missed behavior
to the event handler that
about the targeted APIs found and triggered in each malware
family. The speciﬁc targeted API (and their corresponding
numbers) are described above and the table is organized with
respect
triggers the API. In the
case of the Jifake malware, IntelliDroid extracted a path to
a reﬂected method call and when dynamically executing this
path, the reﬂected call triggered a malicious behavior that
leaked sensitive information via SMS. Since the malicious
behavior was triggered, a dynamic analysis tool would detect it
in theory, even though IntelliDroid only generated inputs that
triggered the path to the reﬂected call.
IntelliDroid was successful in triggering the targeted API
in 70 out of the 75 instances. We found that IntelliDroid’s
ability to extract event-chains, perform device-framework input
injection, and solve constraints at run-time were signiﬁcant in
achieving targeted execution, which we discuss below.
Event Chains: The event-chains generated by IntelliDroid
were instrumental in 6 cases of malicious behavior and ensured
that all constraints imposed by the application were satisﬁed.
For example, in the Endofday and Zsone malware, the ma-
licious behavior was activated only when the injected event
occurs on a certain date or only after the application has been
running for certain amount of time. In these cases, simply
injecting a single event would not have satisﬁed the multi-
event constraints that these applications impose. The event-
chain for these paths includes a separate event to change the
device’s system time, which is triggered prior to the injection
of the input that ﬁnally triggers the targeted API. In a different
case, the GPSSMSSpy malware watches for a control SMS
message that contains a certain string (“how are you?”). Once
received, it saves the originating address of the message and
begins listening for location updates. For each location update,
it sends the location information to the saved SMS address,
thereby leaking sensitive data to a third-party. IntelliDroid’s
event-chain generation component successfully recognizes this
data-ﬂow dependency through the third-party address saved
on the heap and accessed in the location event handler, thus
ensuring that the SMS is injected prior to the location event.
Device-Framework Injection:
Injection at
the application boundary. For example,
the device-
framework interface was necessary in 9 cases of malicious
activity. For these cases, the malware would not have behaved
realistically if IntelliDroid had not
implemented consistent
framework behavior by injecting inputs into the framework
rather than at
the
GamblerSMS malware receives new SMS notiﬁcations by
registering a custom ContentObserver object to listen for
SMS database changes. Merely injecting new SMS events at
the framework-application boundary would not have triggered
the malicious behavior, since the injected event would not have
been entered into the framework’s SMS database. The Coin-
Pirate and HippoSMS malware also use a similar technique
to receive new SMS notiﬁcations while avoiding traditional
telephony APIs, which are commonly detected. For these
applications (and any others that use ContentObserver for
other databases), it is essential that the events are injected at
the device-framework interface so that they are entered into the
appropriate database. In addition, 5 cases were found where
SMS entries are deleted from the database when the application
detects that a new SMS message was received. Often, these
deletions require a query into the database to obtain a handle
(e.g. URI) on the message. If the SMS event was not entered
into in the database, the query would have failed and the
deletion would not have been executed. If this occurred while
screening the applications for malware, it would have caused
the screening tool to miss potential malicious activity.
Run-time Constraint Data: Run-time data was required
for the extracted constraints of 22 malicious call paths. This
data included controlled variables such as the device time
or location, and monitored variables derived from third-party
server replies to network requests. For instance, the Coin-
Pirate, Crusewin, and Pjapps malware contained malicious
call paths relying on values obtained from a third-party server.
For the malicious activity to occur, the network reply values
are compared against those from the injected event and thus,
the extracted constraints depend on the run-time variables.
In other cases, values are obtained from the application’s
SharedPreferences ﬁle or from the device state. Be-
cause IntelliDroid employs a hybrid system and performs the
constraint solving in the dynamic component, the statically
extracted constraints could be augmented with the run-time
data prior to generating the input values. Without the run-time
variables, the constraints would not have been as precise and
the malicious call path would not have executed fully.
Of the ﬁve malicious behaviors that IntelliDroid could
not trigger, three of them occur for AnserverBot, which has
path constraints that contain hash functions. The solving of
11
constraints containing hash functions is beyond the capabilities
of the Z3 constraint solver that IntelliDroid uses. Similarly,
Backﬂash contained constraints that require Base64 decoding
and string/array manipulation, which IntelliDroid currently
does not fully handle. The remaining case occurred in Gold-
Dream and was the result of data ﬂow through ﬁles. While
IntelliDroid currently does not support ﬂow through ﬁles,
it would be possible to extend it to recognize ﬁle system
dependencies in the same manner as heap dependencies.
C. Performance
We measured two quantitative performance aspects of
IntelliDroid. The ﬁrst is the reduction in analysis time Intelli-
Droid imparts by saving a dynamic analysis tool from having
to exercise irrelevant portions of the application. For this, we
measure the percentage of the application that IntelliDroid
actually dynamically executes to allow TaintDroid to detect
all privacy leaks. The second is the time IntelliDroid takes
to generate and inject inputs, which has two distinct phases:
(1) static extraction and analysis of path constraints; and (2)
dynamic generation of inputs based on run-time state and
constraint solving. We do not include the time to actually
run the dynamic analysis as this is more of a function of the
dynamic tool than of IntelliDroid.
Our previously described experiments with Intelli-
TaintDroid give a glimpse of the reduction in analysis time
that IntelliDroid can provide. While Monkey injected over
60K inputs, it was only able to trigger 7 of the 26 malicious
behaviors that IntelliDroid could trigger with an average of 72
inputs. However, Monkey is a fairly simplistic tool and it was
not possible to integrate more complex tools with TaintDroid.
Thus, we measure the average percentage of application code
that Intelli-TaintDroid must exercise and compare against the
amount of code that an input generator based on random
fuzzing or concolic testing might need to execute to achieve
the same detection results. By measuring the total number of
call graph nodes and edges in each application and comparing
with the number that IntelliDroid actually executes, we ﬁnd
that IntelliDroid need only execute less than 5% of the code
on average in the applications we tested. On the other hand,
both random fuzzing and concolic testing, which inject inputs
without being aware of the goals of the dynamic analysis,
might have to statistically execute 50% or more of the ap-
plication before it has a better than 50% probability of trigger
all the relevant behavior in an application. This conservatively
suggests that IntelliDroid might cut execution time by as much
as 90% against state-of-the-art input generation methods, and
this estimate does not take into account that the number of
paths (and thus inputs) is actually exponentially related to the
size of the code. In addition, fuzzing and concolic testing do
not actively determine the correct order in which inputs must
be injected so they may have to try several permutations to
achieve full coverage.
IntelliDroid’s static analysis time and the number of inputs
it must inject is heavily dependent on the number of target
APIs speciﬁed. Thus, to simulate a worst-case scenario with a
very comprehensive dynamic analysis engine, we use an even
larger set of targeted APIs than in our previous experiments
by deriving them from the set of potentially malicious APIs
identiﬁed by the FlowDroid static analysis tool [4]. The fact
(a) Static Analysis
(b) Constraint Solving
Fig. 2.
IntelliDroid Timing Distribution
that FlowDroid uses static analysis is not relevant – we use
this set mainly because it is a large collection of Android
APIs that have been identiﬁed as potentially malicious. We
note that this set of targeted APIs is a superset of both the
targeted APIs used by TaintDroid and the targeted APIs used
by the hypothetical malware detection tool in our experiments,
containing a total of 228 API methods. The extra methods in
the FlowDroid set include more conservative sources and sinks,
such as those where data is sent via an intent or printed in a
log message. These generic API methods are commonly used
by both malicious and benign applications.
We measure the time IntelliDroid takes to ﬁnd invocations
of the targeted APIs and extract
the constraints required
for input generation using a combination of two datasets:
1260 malware samples from the Android Malware Genome
project [49] and 1066 benign applications from the Android
Observatory [8]. The Android Observatory dataset was ob-
tained by ﬁltering for applications that declare the permissions
necessary for the set of targeted APIs used in this experiment.
The static component, running with a time limit of 60 minutes
(enforced for timeliness of results), took an average of 138.4
seconds per application and 88.1% completed analysis within
the time limit, with the distribution shown in Figure 2a. The
bigger set of targeted APIs and the larger applications in the
benign dataset used in this experiment resulted in an average
of 1760 inputs generated for each benign application. Despite
this large number, the extracted paths still comprise less than
5% of the code in each application on average.
The analysis time of IntelliDroid is dominated by WALA’s
call graph extraction and the search for targeted API invo-
cations, which must be performed on the entire application
and accounts for roughly 50% of the static analysis time. We
found that the applications that required longer analysis times
often used advertisement libraries. The extra code included
with these libraries resulted in larger call graphs and thus,
more time was spent searching for targeted APIs.
Unlike the static component, the dynamic generation of
input values must be extremely quick since it is performed for
every injected input, of which there could be several thousand
per application. Because the constraint solver component of
IntelliDroid is completed during run-time,
is especially
important that it runs efﬁciently. We measure the total time
taken by the Z3 solve the constraints for all target paths in
our dataset to be an average of 4.22 milliseconds, with the
distribution show in Figure 2b. As a result, we expect the main
run-time cost to be that of the dynamic analysis tool itself.
it
12
VI. LIMITATIONS
A. Call-Graph Generation
Since IntelliDroid aims to generate inputs to event handlers
that will trigger all targeted APIs, the tool needs an accurate
call graph to be extracted. Missing edges in the call graph may
cause IntelliDroid to incorrectly believe that a targeted API
is not reachable and thus cannot be triggered by any inputs.
This is particularly challenging for Android because there are
many implicit paths that applications can take via intents,
callbacks and other Android-speciﬁc facilities. This challenge
is not limited to IntelliDroid, but is common to all tools that
perform any sort of static analysis on Android applications.
We currently model all Android-speciﬁc call edges that we
are aware of with the exception of exceptions, although we
can report exception handlers that invoke a targeted API as a
case we cannot handle and ﬂag it as suspicious. We did not
encounter any such cases in our experiments.
Another limitation of our prototype, documented in Sec-
tion V, is that IntelliDroid currently only detects inter-event
data dependencies if they occur through heap variables. Thus,
IntelliDroid failed to generate inputs for data ﬂow through a
ﬁle. It would be straightforward to extend dependency tracking
through ﬁles, as well as other Android facilities such as content
providers, in the same manner.
B. Generating Constraints
Most technical limitations are the result of limitations of the
constraint solver used. In some cases, the extracted constraints
contain theories that are undecidable with current solvers, such
as trigonometric functions to compute location changes. In
other cases, the extracted constraints are too complex for the
constraint solver, such as the functions that convert the SMS
PDU bytecode format [1] used by the hardware for the SMS
message format. IntelliDroid mitigates such shortcomings by
extracting the necessary information at run-time and solving
for inputs dynamically, but this currently still requires manual
instrumentation of the Android framework. Fortunately, this in-
strumentation need only be done once for each Android version
(or even several versions, since system service interfaces rarely
change) and once done, the results can be re-used without
modiﬁcation for all applications that are analyzed.
Another inherent limitation of inputs generated through
constraint solving is that they are not necessarily realistic and
thus might not happen in practice. For example, IntelliDroid
can manipulate time and other inputs in such a way that it
injects a sequence of inputs that is not physically possible,
resulting in the detection of malicious behavior that cannot
happen in reality. We see no reason why IntelliDroid cannot
be enhanced to account for the constraints of the physical
world when generating inputs. The main challenge would be
enumerating what all the relevant physical constraints are.
C. Malware Obfuscation
More recent malware may try to obfuscate their behavior
by using reﬂection and encryption. While IntelliDroid has
been implemented with support for constant reﬂection targets
during call graph generation,
in general, IntelliDroid can
only compute inputs that will trigger the reﬂection. It cannot
determine path constraints after the reﬂected call because the
statically extracted call graph is incomplete at that point. A
possible solution that we are currently exploring is to feed
dynamic information back to the static component to resolve
such issues and build a more complete call graph. In particular,
IntelliDroid’s targeted execution can be used to ensure that
these statically unresolved method invocations are executed
during run-time to obtain the dynamically resolved target.
A similar and related limitation is that IntelliDroid is unable