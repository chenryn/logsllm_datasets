probability distributions, and suppose that A∧¬F ⇔ B ∧¬F .
Then
|Pr[A] − Pr[B]| ≤ Pr[F ].
Game 0.
The challenger runs (mpk, msk) ← S(k) and maintains a
list L, initially empty. To answer a query for X O, the chal-
lenger runs ski ← X(msk, pki), where pki is a binary string
(e.g. the current time), and appends pki to L. To answer EO
queries, for any pki chosen by an adversary A, the challenger
returns ski as the decryption key. When pk∗ ∈ L are two
messages (m0, m1) of equal size are chosen, the challenger
chooses b ← {0, 1} and computes (dk, c0) ← Enc(mpk, pk∗)
and c1 ← SEnc(dk, mb). A may go on to ask X O and EO
queries and the challenger answers the queries as before. Fi-
nally, A terminates and output a guess b′. A wins the game
if b = b′. Since this game is essentially exactly the same as
Deﬁnition 5, we have
Advss
A,UCP(k) = Pr[E0] − 1/2.
(1)
Game 1.
We modify the challenge as follows. Instead of using dk
generated by Enc(mpk, pk), SEnc takes a random key dk′ to
encrypt m. We claim that
|Pr[E1] − Pr[E0]| ≤ Advind-id-cpa
A,IDKEM (k)
(2)
To show this, one can construct an adversary B against the
underlying ID-KEM by counting the probability diﬀerence of
the two games. Though this is quite standard an argument,
we remark that an adversary A in Game 1 doesn’t exploit
full power of adaptive chosen identity attack, since each pk is
74S(k):
(mpk, msk) ← Kg(k);
return (mpk, msk)
G(mpk, pk, m):
(dk, c0) ← Enc(mpk, pk);
c1 ← SEnc(dk, m);
c ← (c0||c1);
return c;
C(sk, c0):
p ← Dec(sk, c0);
return p;
X(msk):
pk ← {0, 1}∗;
sk ← Ext(msk, pk);
return (pk, sk);
R(msk, pk, c):
(c0||c1) ← c;
sk ← Ext(msk, pk);
dk ← Dec(sk, c0);
m ← SDec(dk, c1);
return m;
H(p, c1):
m ← SDec(p, c1);
return m;
Figure 2: A Generic Construction of UCPs
generated by the challenger. However, this already suﬃces
to prove the statement of (2). Finally, we claim that
Pr[E1] ≤ Advss
A,AE(k) + 1/2.
(3)
To see this, observe that dk is chosen independently from
c0, any adversary wins Game 1 can be converted into an ad-
versary against the underlying AE. Namely, the challenger
simulates all the oracles and produces c0 as Game 1.
It
then gives to A together with its own challenge c1, (its own
challenge ciphertext). Finally, it outputs whatever A out-
puts. It is veriﬁed that the simulator wins at least with the
advantage of A.
Summarize Eqs. (1), (2) and (3), we get the statement of
Lemma 1, where the time bound can be veriﬁed from the
above descriptions. We remark that the security reductions
are tight in Lemma 1.
Lemma 2. The generic construction depicted in Figure 2
provides information-theoretic privacy of puzzles.
Proof. This can be easily seen, since only c1 contains
information of the message m and is perfectly hidden from
an adversary merely listening to the channel between the
server and Client B.
Finally, we argue that the useful puzzle satisﬁes the rest of
the requirements in Section 3.2, if all the players only listen
to their own channel.
• Computational intensity: the server only needs to de-
crypt the symmetric key authenticated encryption to
recover the message. But the client has to do the de-
cryption of the ID-KEM, which is always more expen-
sive.
• Reliability: the symmetric key authenticated encryp-
tion will output “⊥” on any invalid p submitted by a
client.
• Non-dependability: if the checking algorithm fails, the
server can solve the puzzle itself using algorithm R or
give it to another client.
• Usefulness: a ciphertext from a client A can be con-
verted to a puzzle for another client B and vice versa.
In order to get the log-in request processed, an client
should help the server.
Theorem 1 follows Lemma 1, 2 and all the above discus-
sions.
5. PRACTICAL INSTANTIATIONS
We show two eﬃcient instantiations of our generic con-
struction. The ﬁrst is based on the Boneh-Boyen identity-
based KEM [4] and the second is based on the Boneh-Gentry-
Hamburg identity-based KEM [6].
5.1 An Efﬁcient UCP without Random Ora-
cles
We ﬁrst present in Figure 3 an eﬃcient UCP based on the
Boneh-Boyen IBE scheme [4]. Especially, compared with
the generic construction given in Figure 2 is optimized, in
the sense that the server can skip the step of extracting the
auxiliary secret key, but use the the master secret key to
decrypt a ciphertext.
Let G1, G2 be two multiplicative cyclic groups of prime
order q and g be a generator of G1, with a bilinear map e :
G1 × G1 → G2. Let H : {0, 1}∗ → Z ∗
p be a collision resistant
hash function. Let AE = (SEnc, SDec) be a secure symmetric
key authenticated encryption scheme. Let F : G2 → K,
where K is the key space for AE, be a key derivation function
as described in [23]. We prove the security of the scheme in
Theorem 2.
Theorem 2. The scheme in Figure 3 is a secure useful
client puzzle scheme.
We prove the scheme provides both semantic security and
information-theoretic privacy, and discuss it fulﬁlls all the
other requirements, as deﬁned in Section 3.2.
Lemma 3. The above client useful puzzle scheme provides
((q+1)ǫ1+ǫ2, t1+t2+O(qk))-semantic security of ciphertexts
against the selective auxiliary public key attack, provided that
(ǫ1, t1)-decisional bilinear Diﬃe-Hellman (DBDH) assump-
tion holds in (G1, G2) and the symmetric key authenticated
encryption is (ǫ2, t2)-authenticated encryption, and the ad-
versary queries EO oracle at most q + 1 times.
Proof. Consider an ID-based KEM scheme where the
ID space is deﬁned as {pki : i = 1, ..., q + 1}.
It is well
known that any (ǫ, q, t)-IND-sID-CPA secure ID-KEM is also
75S(k)
g ← G;
x1, x2, x ← Z ∗
p ;
h1 ← gx
1 ;
h2 ← gx
2 ;
y ← gx;
z ← e(g, y);
mpk ← (g, h1, h2, z);
msk ← (x1, x2, y);
return (mpk, msk);
X(msk)
msk = (x1, x2, y);
pk ← {0, 1}∗;
r ← Z ∗
p ;
H(pk)
d0 = y(h
1
d1 = gr;
sk ← (d0, d1);
return (pk, sk)
h2)r;
G(mpk, pk, m)
R(msk, pk, c)
s ← Z ∗
p ;
dk ← F (zs);
c0,0 ← gs;
c0,1 ← (hH(pk)
c0 ← (c0,1, c0,1);
c1 ← SEnc(dk, m);
c ← (c0, c1);
return c;
1
h2)s;
msk = (x1, x2, y);
c = (c0, c1);
c0 = (c0,0, c0,1);
if cx1H(pk)+x2
dk ← F (e(c0,0, y));
m ← SDec(dk, c1);
return m;
0,0
= c0,1
C(sk, c0)
sk = (d0, d1);
c0 = (c0,0, c0,1);
p ← F (e(c0,0, d0)e(c0,1, d1));
return p;
H(p, c1)
m = SDec(p, c1);
return m;
Figure 3: A Secure UCP Scheme without Random Oracles
an ((q+1)ǫ, q, t)-IND-sID-CPA secure ID-KEM (per [4]). Also
recall that the Boneh-Boyen IBE scheme is (ǫ1, q, t1+O(qk))-
IND-sID-CPA secure assuming (ǫ1, t1)-DBDH holds in (G1, G2)
(Theorem 4.1 of [4]). Lemma 3 then follows Theorem 1 and
the above facts.
The correctness and information-theoretic puzzle privacy
can be seen easily. We further argue that the useful puzzle
satisﬁes the requirements if all the players only listen to their
own channel.
• Computational intensity: the server only needs to de-
crypt the symmetric key authenticated encryption to
recover the message. The client has to two pairing
operation, which is much more expensive.
• Reliability: the symmetric key authenticated encryp-
tion will output “⊥” on any invalid p submitted by a
client.
• Non-dependability: if the checking algorithm fails, the
server can solve the puzzle itself using algorithm R or
give it to another client.
• Usefulness: a ciphertext from a client A can be con-
verted to a puzzle for another client B and vice versa.
In order to get the log-in request processed, an client
should help the server.
Theorem 2 then follows Lemma 3 and all the above dis-
cussions.
We ﬁnally remark that this construction gives security of
only selective auxiliary public key attacks, namely, the at-
tacker has to decide in advance which for which auxiliary
public key he will launch a DoS attack before the setup
phase. Though this is weaker notion than the adaptive cho-
sen auxiliary public key attack, we believe it is still use-
ful in many cases. On the other hand, the security can be
upgraded to be secure against adaptive chosen public key
attacks, by either assuming random oracles, or require poly-
nomially bounded ID (auxiliary public key) space. Alter-
natively, it can be achieve by instantiating the scheme with
Waters IBE [25, 15], which results in adaptive chosen aux-
iliary public key security, however, less eﬃcient and loose
security reductions to the DBDH assumption.
5.2 A Useful Client Puzzle without Pairings
We next present in Figure 4 another UCP based on the
Boneh-Gentry-Hamburg IBE scheme [6]. Denote H is a
collision resistant hash function. FK : {0, 1}∗ × [1, ℓ] →
{0, 1, 2, 3} is a pseudo-random function as deﬁned in [12]
(reviewed in Appendix A.2). Here Q is a deterministic al-
gorithm deﬁned in [6], namely, taking (N, R, S) (N ∈ Z+,
R, S ∈ ZN ) as input, ﬁnding two functions f, g, such that:
(i) f (r)g(r) is a quadratic residue for all square roots r of R
and s of S, if R and S are quadratic residues; (ii) f (r)f (−r)S
is a quadratic residue for all square roots r of R, if R is a
quadratic residue. An example of f and g is f (r) = xr + 1
and g(s) = 2ys + 2, where (x, y) is the solution to the equa-
tion Rx2 + Sy2 = 1 mod N .
Theorem 3 guarantees the security of the UCP scheme.
Due to the space, the proof of the theorem will be postponed
to Appendix B.
Theorem 3. The scheme in Figure 4 is a secure useful