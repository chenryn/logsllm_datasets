e · D − z1 · G + W = e · t · P + e · y · G − σ · G − e · y · G + σ · G
= e · t · P
42
and so
(G,P, e · C, e · D − z1 · G + W ) = (G,P, (e · t) · G, (e · t) · P)
is a Diﬃe-Hellman tuple with witness e · t mod q. Thus, the veriﬁer accepts.
2, π, π(cid:48)) such that e (cid:54)= e(cid:48) mod q
Special soundness: We show that given (X, Y, W, e, e(cid:48), z1, z2, z(cid:48)
and both (X, Y, W, e, z1, z2, π) and (X, Y, W, e(cid:48), z(cid:48)
2, π(cid:48)) are accepting transcripts (where π, π(cid:48) are
the Diﬃe-Hellman proofs), it is possible to compute (x, r) where (A, B) = EGexpEncP (x; r). By
the assumption that both transcripts are accepting we have that both
1, z(cid:48)
1, z(cid:48)
z1 · A + z2 · G = X + e · E and z1 · B + z2 · P = Y + e · F,
and
1 · A + z(cid:48)
z(cid:48)
2 · G = X + e(cid:48) · E and z(cid:48)
1 · B + z(cid:48)
2 · P = Y + e(cid:48) · F,
Subtracting the equations from each other, we have
1) · A + (z2 − z(cid:48)
(z1 − z(cid:48)
2) · G = (e − e(cid:48)) · E
and
Thus,
and
(z1 − z(cid:48)
1) · B + (z2 − z(cid:48)
2) · P = (e − e(cid:48)) · F.
E = (z1 − z(cid:48)
1) · (e − e(cid:48))−1 · A + (z2 − z(cid:48)
2) · (e − e(cid:48))−1 · G
F = (z1 − z(cid:48)
1) · (e − e(cid:48))−1 · B + (z2 − z(cid:48)
2) · (e − e(cid:48))−1 · P.
1) · (e − e(cid:48))−1 mod q and r = (z2 − z(cid:48)
Observe that since e (cid:54)= e(cid:48) mod q, the value (e− e(cid:48))−1 mod q exists and can be eﬃciently computed.
Setting y = (z1 − z(cid:48)
2) · (e − e(cid:48))−1 mod q, the above shows that
E = y · A + r · G and F = y · B + r · P as required.
It remains to validate that the value y obtained is indeed the same y as encrypted in (E, D).
The special soundness of the Diﬃe-Hellman tuple proof (for the two accepting transcripts with e, e(cid:48)
that contain two diﬀerent proofs π, π(cid:48)) provides us with a knowledge extractor to obtain w, w(cid:48) ∈ Zq
such that
e · C = w · G and e · D − z1 · G + W = w · P.
and
This implies that
e(cid:48) · C = w(cid:48) · G and e(cid:48) · D − z(cid:48)
1 · G + W = w(cid:48) · P.
C = (w − w(cid:48)) · (e − e(cid:48))−1 · G
and
D = (w − w(cid:48)) · (e − e(cid:48))−1 · P + (z1 − z(cid:48)
From above, we have already determined that y = (z1 − z(cid:48)
t = (w − w(cid:48)) · (e − e(cid:48))−1 mod q, we conclude that C = t · G and D = t · P + y · G, as required.
1) · (e − e(cid:48))−1 · G.
1) · (e − e(cid:48))−1 mod q and thus setting
43
Honest-veriﬁer zero knowledge: Given e, the simulator chooses random z1, z2 ← Zq and
computes
X = z1 · A + z2 · G − e · E and Y = z1 · B + z2 · P − e · F,
and generates a simulated proof π for the Diﬃe-Hellman tuple.
If indeed there exist (y, r) such that E = y · A + r · G and F = y · B + r · P, then
X = z1 · A + z2 · G − e · y · A − e · r · G = (z1 − e · y) · A + (z2 − e · r) · G
and
Y = z1 · B + z2 · P − e · y · B − e · r · P = (z1 − e · y) · B + (z2 − e · r) · P.
Setting σ = z1 − e · y and ρ = z2 − e · r, we have that the distribution is identical (using the same
argument as in Section A.2 for REG). (The simulation of the Diﬃe-Hellman tuple is perfect, by
the fact that a Sigma protocol is used for that as well.)
Complexity. The cost of the proof is seven exponentiations for the prover (5 for the operations
described in Protocol A.3 and 2 more for the Diﬃe-Hellman proof) and ten for the veriﬁer (6 for
the operations described in Protocol A.3 and 4 more for the Diﬃe-Hellman proof) . When applying
the Fiat-Shamir transform, the communication cost is 6 elements of Zq (3 for Protocol A.3 and 3
more for the Diﬃe-Hellman proof).
B Full Proof of Security – Fmult
We prove that Protocols 4.3–4.7 securely compute Fmult. We prove the theorem in the (Fzk,Fcom-zk,
FcheckDH)-hybrid model. As described in Section 3.3, Fzk and Fcom-zk can be eﬃciently instantiated
non-interactively in the random oracle model. These functionalities also have eﬃcient interactive
instantiations without relying on a random oracle, but they both increase the round complexity, and
the commitment also increases the computational complexity. We show how to securely compute
Functionality FcheckDH in Section 7.
Theorem B.1 Assume that the Decisional Diﬃe-Hellman problem is hard in the group (G, G, q),
and that πpriv
mult is a private multiplication protocol for malicious adversaries as deﬁned in Sec-
tion 2.3. Then, Protocols 4.3 to 4.7 securely compute the Fmult functionality with abort in the
(Fzk,Fcom-zk,FcheckDH)-hybrid model, in the presence in the presence of a malicious adversary cor-
rupting any t < n parties, with point-to-point channels.
Proof: The intuition behind the security is given in Section 4.3, and so we proceed directly to
describe the simulator. Let A be an adversary and let I ⊆ [n] be the set of corrupted parties. If all
parties are corrupted, then the simulation is trivial. We therefore consider I ⊂ [n] (with |I| < n)
and we denote the set of honest parties by J = [n] \ I. Throughout the proof, we denote corrupted
parties by Pi (i.e., i ∈ I), honest parties by Pj (i.e., j ∈ J), and a running index over [n] by (cid:96). We
remark that in the simulation, the simulation of each round begins by simulating the messages that
the corrupted parties receives from the honest in this round, and only then receiving this round
messages from the adversary. This is due to the fact that the adversary is rushing and so may
receive the messages that the honest parties send in round i before sending its own round messages
in round i (this is in contrast to the protocol presentation, where the receipt of round i messages
44
by honest parties is processed at the beginning of round i + 1, since this is the way that honest
parties work). Unless stated otherwise, all operations on scalar values are modulo q.
We construct a simulator S who invokes A internally and simulates an execution of the real
protocol, while interacting with Fmult in the ideal model. We describe the simulator steps separately
for each subprotocol of Fmult.
Initialization: Upon receiving (init, G, G, q), simulator S invokes A upon input (init, G, G, q) and
works as follows:
1. S chooses a random group element P ∈ G.
2. S simulates F RDL
3. S receives the messages (ComProve, init, i,Pi, di) that A sends to F RDL
com-zk sending (ProofReceipt, init, j) to Pi, for every i ∈ I and j ∈ J.
4. S chooses random group elements {Pj}j∈J under the constraint that(cid:80)
S sets Pj∗ = P −(cid:80)
i∈I Pi.
(Speciﬁcally, S speciﬁes some j∗ ∈ J and then chooses random Pj for all j ∈ J \ {j∗}. Finally,
com-zk for every i ∈ I.
j∈J Pj = P −(cid:80)
(cid:96)(cid:54)=j∗ P(cid:96).)
com-zk sending (DecomProof, init, j,Pj, 1) to Pi, for every i ∈ I and j ∈ J.
5. S simulates F RDL
6. S receives the messages (DecomProof, init, i) that A sends to F RDL
7. If for some i ∈ I it holds that a DecomProof message was received and Pi (cid:54)= di · G in the
associated ComProve message of Step 3 above, then S sends abort to Fmult, outputs whatever A
outputs and halts. Else, S proceeds to the next step.
com-zk for every i ∈ I.
(cid:96)=1.
8. S stores all of the values {di}i∈I , as well as P and all {P(cid:96)}n
Input: Upon receiving (input, sid, ˜ai) for all i ∈ I, simulator S invokes A upon the same input
and works as follows:
1. S chooses random group elements {Uj, Vj}j∈J .
2. S simulates F REG
3. S receives the messages (proof, sid, i, (P, Ui, Vi), (ai, si)) that A sends to F REG
for every i ∈ I.
4. If for some i ∈ I it holds that Ui (cid:54)= si · G or Vi (cid:54)= si · P + ai · G, then S sends abort to Fmult,
sending (proof, sid, j, (P, Uj, Vj), 1) to Pi, for every i ∈ I and j ∈ J.
outputs whatever A outputs and halts. Else, S proceeds to the next step.
zk
zk
5. S computes U =(cid:80)n
(cid:96)=1 U(cid:96) and V =(cid:80)n
(cid:96)=1 V(cid:96), and stores (sid, (U, V ),{Ui, Vi, ai, si}i∈I ,{Uj, Vj}j∈J ).
Element-out: Upon receiving (element-out, sid), if some sid has been stored, then simulator S
sends (element-out, sid) to Fmult from every Pi with i ∈ I. Upon receiving back (element-out, sid, A)
and points (A1, . . . , An), S invokes A upon the same input and works as follows:
1. Let (Uj, Vj) be the pair of points stored by S associated with sid for each honest party Pj (if
none exists, then S does nothing).
45
2. S simulates Pj sending Aj to Pi, and F RDH
sending (proof, sid, j, (G,P, Uj, Vj − Aj), 1) to Pi,
zk
for every i ∈ I and j ∈ J.
3. S receives the messages (proof, sid, i, (G,P, Ui, Vi − Ai), si) and Ai, that A sends to F RDH
and
to Pj, for every i ∈ I and j ∈ J. If for some i ∈ I it holds that Ui (cid:54)= si · G or Vi (cid:54)= si · P + ai · G,
then S sends abort to Fmult, outputs whatever A outputs and halts.
zk
Aﬃne: This operation involves local operations by the parties only. Thus, S carries out the local
transformations on the values that it has stored as well, in the same way as the honest parties.
Multiply: Upon receiving (mult, sid1, sid2), if these have been stored, then simulator S sends
(mult, sid1, sid2) to Fmult from every Pi with i ∈ I. Upon receiving back (mult-out, sid1, sid2, c), S
sets sid = sid1(cid:107)sid2, invokes A and works as follows:
1. Let (sid1, (U, V ),{Ui, Vi, ai, si}i∈I ,{Uj, Vj}j∈J ) and (sid2, (X, Y ),{Xi, Yi, bi, ti}i∈I ,{Xj, Yj}j∈J )
be as stored.
2. S chooses random values aj, bj under the constraint that ((cid:80)n
(cid:96)=1 a(cid:96)) · ((cid:80)n
(cid:96)=1 b(cid:96)) = c, and plays
mult using inputs {aj, bj}j∈J . (The idea here is that if A uses
the honest parties in protocol πpriv
the “correct” inputs then this will be indistinguishable. Otherwise, the parties will abort before
revealing anything anyway. Note that the corrupted parties’ values {ai, bi}i∈I were extracted by
S in the simulation of the input phase, and possibly modiﬁed in a known way using aﬃne. Thus,
there values are known to S.)
3. S chooses random group elements Ej, Fj ∈ G for every j ∈ J.
4. S simulates F Rprod
sending (proof, sid, j, (P, X, Y, Uj, Vj, Ej, Fj), 1) to Pi, for every i ∈ I and
zk
j ∈ J.
5. S receives the messages (proof, sid, i, (P, X, Y, Ui, Vi, Ei, Fi), (ai, si, s(cid:48)
i)) that A sends to F Rprod
for every i ∈ I. If for some i ∈ I it holds that the proof is incorrect (checked via the witness),
then S sends abort to Fmult, outputs whatever A outputs and halts. Else, S proceeds to the
next step.
zk
6. S chooses random Aj, Bj ∈ G and simulates F REG
sending (proof, sid, j, (P, Aj, Bj)) to Pi, for
zk
every j ∈ J and i ∈ I.
7. S receives (proof, sid, i, (P, Ai, Bi), (ci, ˆsi)) that A sends to F REG
for every i ∈ I. If for some
i; ˆsi), then S sends abort to Fmult, outputs whatever A
zk
i ∈ I it holds that (Ai, Bi) (cid:54)= EGexpEnc(c(cid:48)
outputs and halts.
8. S computes A = E −(cid:80)n
(cid:96)=1 A(cid:96) and B = F −(cid:80)n
(cid:96)=1 B(cid:96).
9. S receives messages (check, i, A, B, di) that A sends to FcheckDH for every i ∈ I.
(a) If di · G (cid:54)= Pi for any i ∈ I, then S simulates FcheckDH sending reject to all parties, sends
abort to Fmult, outputs whatever A outputs and halts.
46
(b) S veriﬁes that(cid:80)n
(cid:96)=1 c(cid:96) = c, where {ci}i∈I are the values that S receives from A in the proof
messages that it sends to F REG
in Step 7, and {cj}j∈J is the output that the honest parties
simulated by S receive from the πpriv