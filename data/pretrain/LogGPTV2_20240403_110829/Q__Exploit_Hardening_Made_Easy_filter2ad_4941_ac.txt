of available registers.
4.3.1 Q’s Language: QooL
Users write the target program in Q’s high level language,
QooL, which is displayed in Table 3. QooL enables
the user to easily interact with the exploited program’s
environment. For instance, the attacker can do this by
calling a function (e.g., system), overwriting values in
memory, or copying and running a binary payload (when
W⊕X is not present or has been disabled by ﬁrst calling
mprotect or a similar function). QooL is not Turing-
complete; we discuss this further in Section 8.
4.3.2 Arrangements
One of the essential tasks of a compiler is to perform
instruction selection, since there are many combinations
of instructions that can implement a given computation.
The gadget architecture is no exception, as there are many
ways of combining gadget types to produce a particular
 ::=
LoadMem  
| BinOp   
| Const  
 ::=
StoreMem   
| Assign  
| CallExternal  
| Syscall
Table 3: Grammar for our high level language, QooL.
computation. We specify each combination of gadgets
using a gadget arrangement.
A gadget arrangement is a tree in which the vertices
represent gadget types5, and an edge labeled type from a
to b means that the output of gadget a is used for the type
input in gadget b. An example arrangement is shown in
Figure 3.
One simple algorithm for performing instruction selec-
tion (or selecting a gadget arrangement, in our case) is
the maximal munch algorithm [1]. Maximal munch as-
sumes that any instruction selected as the best will always
be available for use. This assumption makes sense in a
traditional compiler, since on a normal architecture there
are few restrictions on when instructions can be used.
A gadget arrangement algorithm cannot make such
assumptions. Any particular gadget type chosen by max-
imal munch might not be available at that point in the
program because Q did not ﬁnd any or the registers in the
gadgets are not compatible with other gadgets needed.
Instead of using maximal munch, Q employs every
munch. Rather than selecting only one arrangement of
5Vertices also include parameters that are relevant to the computation,
such as binary operator type and number of bytes for memory operations.
7
from apt-get. More straightforward options were not
available.
; Load eax: -1
pop %ebp; ret; xchg %eax, %ebp; ret
; Load ebx: address-0x5e5b3cc4
pop %ebx; pop %ebp; ret
; Write -1
or %al, 0x5e5b3cc4(%ebx); pop %edi;
pop %ebp; ret
; Load eax: value + 1
pop %ebp; ret; xchg %eax, %ebp; ret
; Load ebp: address-0xf3774ff
pop %ebp; ret
; Add value + 1
add %al,0xf3774ff(%ebp);
movl $0x85, %dh; ret
4.4 Gadget Assignment
Q must determine if a gadget arrangement can be satisﬁed
using the gadgets it discovered in the source program.
This process is called gadget assignment. The goal is
to assign gadgets found during discovery to the vertices
of arrangements, and see if the assignment is compati-
ble. After a successful gadget assignment, the output is
a mapping from gadget arrangement vertices to concrete
gadgets. It is straightforward to print a ROP payload with
this mapping.
Gadget assignments need a schedule, since the gadgets
must execute in some order. Selecting a valid schedule
is not always easy because there are data dependencies
between different gadgets. For instance, if the gadget at
T2 clobbers (overwrites) the Value register in Figure 3, the
gadget at T3 will not receive the correct input. To resolve
such dependencies between gadgets, a gadget assignment
and corresponding schedule must satisfy these properties:
Matching Registers Whenever the result of gadget a is
used as input type to gadget b, then the two registers
should match, i.e., OutReg(a) = InReg(b, type).
No Register Clobbering If the output of gadget a is
used by gadget b, then a’s output register should not
be clobbered by any gadget scheduled between a and
b. For example, for the schedule shown in Figure 3,
the LOADCONSTG operation during T2 should not
clobber the result of the previous LOADCONSTG
that happened during T1.
We say that a gadget assignment and schedule are com-
patible when the above properties hold, and that a gadget
arrangement that has a compatible assignment and sched-
ule is satisﬁable.
Although deciding whether a given gadget schedule
and assignment are compatible is straightforward (i.e.,
8
Figure 3: A gadget arrangement for storing a constant
value to a constant address. A possible schedule for the
arrangement is denoted by the time slots Ti’s.
gadget types as maximal munch would, every munch
lazily builds a tree representing all possible ways that
gadget types can be arranged to perform a computation.
This is done by recursively applying munch rules to the
program being compiled.
4.3.3 Munch Rules
Each QooL language construct has at least one munch
rule that can implement the construct in terms of the
implementations of its subexpressions. For instance, the
obvious munch rule for the StoreMem statement is to
use a STOREMEMG gadget, which we show below in
ML-style pseudo code.
| StoreMem ( e1 , e2 ,
1 munch = f u n c t i o n
2
3
4
5
6
7
t ) −>
l e t
e 1 l = munch e1 i n
l e t
e 2 l = munch e2 i n
(∗ For each e1g , e2g i n C a r t e s i a n
p r o d u c t o f e 1 l and e 2 l do : ∗ )
( StoreMemG ( a d d r =e1g ,
a d d o u t p u t
v a l u e =e2g ,
t y p = t ) ) ;
Our initial implementation only contained these obvious
rules. We quickly found that it could not ﬁnd payloads
for most binaries.
We found that, in practice, many binaries do not contain
gadgets for directly storing to memory (STOREMEMG
in Table 2). We provide evidence of this in Section 7.1.
However, if Q can learn or set the value in memory to 0
or -1, it can use an ARITHMETICSTOREG gadget with
mathematical identities to write an arbitrary value. As
one example, Q can write zero to memory by bitwise
and’ing the memory location with zero, and then adding
the desired number. The example below shows the com-
plicated return oriented program Q discovered for writing
a single byte to memory with bitwise or, using gadgets
AddressValueLoadRegLoadRegStoreMem, u32T1T2T3just ensure the above properties are satisﬁed), creating a
practical algorithm to search for satisﬁable arrangements
is more complicated. The most straightforward approach
is to iterate over all possible arrangements, schedules, and
assignments, but this is simply too inefﬁcient.
Instead, our key observation is that if a gadget arrange-
ment GA is unsatisﬁable, then any GA’ that contains GA
as a subtree is unsatisﬁable as well. Our algorithm at-
tempts to satisfy iteratively larger subtrees until it fails, or
has satisﬁed the entire arrangement. If the algorithm fails
on a subtree, it aborts the entire arrangement. Since most
arrangements are unsatisﬁable, this saves considerable
time. (If most arrangements are satisﬁable, the search will
not take very long anyway.)
Our assignment algorithms are found in Algorithms
2 and 3. Algorithm 2 is a naive search over a schedule
for all possible gadget assignments. Algorithm 3 is a
caching wrapper that caches results and calls Algorithm 2
on iteratively larger subtrees. It stops as soon as it ﬁnds a
subtree which cannot be satisﬁed. Q calls Algorithm 3 on
each possible gadget arrangement until one is satisﬁable
or there are none left.
The algorithms make use of several data structures:
• C: V → {0, 1, ?} is a cache that maps a gadget
arrangement vertex to one of true, false, or unknown.
• S: V → N represents the current schedule as a one-
to-one mapping between each vertex and its position
in the schedule.
• G: V → G is the current assignment of each vertex
to its assigned gadget.
Q can also search for assignments that meet other con-
straints. For instance, Q can search for assignments that
would result in a payload smaller than a user-speciﬁed
size. This is useful because ROP payloads are typically
larger than conventional payloads, and vulnerabilities usu-
ally limit the number of payload bytes that can be written.
5 Creating Exploits that Bypass ASLR and
W⊕X
In the previous section, we described how to generate
return oriented payloads. If an attacker can redirect exe-
cution to the payload in the memory space of the vulnera-
ble program by creating an exploit, then the computation
speciﬁed by the payload will occur. In this section, we
explain how Q can automatically create such an exploit
when given an input exploit that does not bypass ASLR
and W⊕X.
We call this the exploit hardening problem. Speciﬁ-
cally, in the exploit hardening problem we are given a
Algorithm 2 Find a satisfying schedule and gadget as-
signment for GA
Input: S, G, nodeN um
V ← S−1(nodeN um) {Obtain vertex in GA for nodeN um}
if V = ⊥ then {Base case to end recursion}
return true
5: end if
gadgets ← GADGETSOFTYPE(GADGETTYPE(V))
for all g ∈ gadgets do
if ISCOMPATIBLE(G, nodeN um, g) then {Ensure g is com-
patible with all gadgets before time slot nodeNum}
if Algorithm 2(S, G[V ← g], nodeN um + 1) then {Try
to schedule later schedule slots}
10:
return true
end if
end if
end for
return false {No gadgets matched}
Algorithm 3 Iteratively try to satisfy larger subtrees of a
GA, caching results over all arrangements.
Input: GA, C
for all GA(cid:48) ∈ SUBTREES(GA) do {In order from shortest to
tallest}
if C(GA(cid:48)) = ? then
5:
C(GA(cid:48)) ← exists S ∈ SCHEDULES(GA(cid:48)) such that
Algorithm 2(S, EMPTY, 0) = true
end if
if C(GA(cid:48)) = f alse then {Stop early if a subtree cannot be
satisﬁed}
return false
end if
end for
10: return C(GA) {Return the ﬁnal value from the cache}
program P and an input exploit that triggers a vulnera-
bility. The input exploit can be an exploit that does not
bypass defenses, or can even be a proof of concept crash-
ing input. The goal is to output an exploit for P that
bypasses W⊕X and ASLR.
Intuitively, the input exploit should provide useful in-
formation about a vulnerability in P. Q uses this infor-
mation to consider other inputs that follow the execution
path of the input exploit (i.e., the sequence of conditional
branches and jumps taken by an execution of the input)
on P, and attempts to ﬁnd a new input that uses a return-
oriented payload instead (Section 4).
Q does not always succeed (e.g., sometimes it returns
with no exploit), but we show that it works for real Linux
and Windows vulnerabilities in Section 7. The fact that
our system works with even a few real exploits means that
an attacker can sometimes download an exploit and au-
tomatically harden it to one that works even when W⊕X
and ASLR are enabled.
9
5.1 Background: Generating Formulas
from a Concrete Run
There can be a very large number of inputs along the
vulnerable path. Rather than trying to reason about each
input individually, we build a logical constraint formula
representing all inputs that follow the vulnerable path.
Such constraint formulas have been used in many research
areas, including automatic test case generation, automatic
signature creation, and others [5, 7, 23, 40].
Generating constraint formulas from an input involves
two steps. First, we record at the binary level the concrete
execution of the vulnerable program running on the input
exploit; we call such a recording an execution trace. Our
recording tool incorporates dynamic taint analysis [11, 33,
40] to keep track of which instructions deal with tainted
(or input-derived) data. Our tool uses this information
to 1) record only the instructions that access or modify
tainted data, for performance reasons; and 2) halt the
recording once control-hijacking takes place (i.e., when
the instruction pointer becomes tainted).
After recording the concrete execution, Q symbolically
executes [7, 40] the target program, following the same
path as in the recording. Symbolic execution is similar
to normal execution, except each input byte is replaced
with a symbol (e.g., si for input byte i). Any computation
involving a symbolic input is replaced with a symbolic
expression. Computations not involving a symbolic input
are computed as normal (i.e., using the processor). Any
constraints on the inputs to ensure that execution would
be guided down the same path as the execution trace are
stored in the constraint formula Π.
Before performing any analysis, we use the Binary
Analysis Platform [3] to raise binary code into an inter-
mediate language that is better suited to program analysis.
This frees our analysis from needing to understand the
semantics of each assembly instruction.
5.2 Exploit Constraint Generation
The constraint formula Π describes all inputs that follow
the vulnerable path. In this paper, we are only interested
in inputs that hijack control to our desired computation.
We build two constraints, α (control ﬂow) and Σ (com-
putation), that exclude any inputs that do not work as
exploits. α maps to true only if a program’s control ﬂow
has been diverted, and Σ maps to true only if the payload
for some desired computation is in the exploit.
5.2.1 Assuring Control Flow Hijacking
α takes the form jumpExp = targetExp, where
jumpExp is the symbolic expression representing the
target of the jump that tainted the instruction pointer, and
targetExp depends on the type of exploit.
The value of jumpExp can be obtained from the ex-
ecution trace. Since the trace halts when the program
jumps to a user-derived address, jumpExp is simply the
symbolic expression for the target of this jump. Consider
the following program.
x := 2∗ g e t i n p u t ( )
goto x
1
2
Our trace system would halt the above program at Line
2, because the program jumps to a user-derived address.