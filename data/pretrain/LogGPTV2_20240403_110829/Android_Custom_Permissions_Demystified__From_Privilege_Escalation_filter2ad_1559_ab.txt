conﬁrmation. Note that any permission can be assigned to a
permission group regardless of protection level [15].
From an internal view, to an app, the processes of grant and
revocation of a permission are essentially changing the corre-
sponding granting status parameter, mGranted (boolean vari-
able), maintained by PermissionController (runtime per-
missions) and PermissionManagerService (install-time per-
missions). mGranted is set as True to grant a permission and
False to revoke a permission. Besides, the granting status of
permissions are also recorded by runtime-permissions.xml2
(runtime permissions) and packages.xml3 (install-time per-
missions) for persistent storage.
B. Custom Permissions
In essence, system permissions (also called platform per-
missions) are the permissions deﬁned by system apps located
in system folders (/system/), such as framework-res.apk
(package name: android), to protect speciﬁc system resources.
For instance, an app must have CALL_PHONE permission to
make a phone call. For third-party apps, they can deﬁne their
2Location: /data/system/users/0/runtime-permissions.xml
3Location: /data/system/packages.xml
own permissions as well, called custom permissions, to share
their resources and capabilities with other apps.
1 
2 
6 
7 
Listing 1: Deﬁne and request a custom permission.
As shown in Listing 1, a custom permission com.test.cp is
deﬁned in an app’s manifest ﬁle using the permission element.
The app must specify the permission name and protection level
(default to normal if not speciﬁed). If the name is the same
as a system permission or an existing custom permission, this
custom permission deﬁnition will be ignored by the system.
App developers can also assign a permission group to the
custom permission optionally. The group can be a custom
group deﬁned by third-party apps or a system group (such
as the PHONE group in the above example). In order to use
the custom permission, the app needs to request it through the
uses-permission element in its manifest ﬁle [7].
Design Philosophy. In most usage scenarios, Android does
not intend to distinguish system and custom permissions. The
general permission management policies apply to both types
of permissions, including protection levels, runtime permission
control, and group management. This design uniﬁes and
simpliﬁes the control of permissions.
The fundamental difference is that, system permissions are
deﬁned by the system (system apps), and custom permissions
are deﬁned by third-party apps. Actually, if the system needs
to judge whether a permission is a system one, it will check
whether its source package is a system app [12]. Also, system
apps are pre-installed and cannot be modiﬁed or removed
by users. Accordingly, their deﬁned permissions are stable,
including names, protection levels, grouping, and protected
system components. Therefore, system permissions are treated
as constant features of Android OS. On the other hand, users
can install, uninstall, and update arbitrary third-party apps,
making the usage of custom permissions more ﬂexible. That
is, it brings the possibilities of adding, removing, and updating
permission deﬁnitions, though these permission-related oper-
ations are not only designed for custom permissions.
Since system permissions are used to protect essential
platform resources, Android indeed designs some mechanisms
to ensure custom permissions will not affect the scope of
system permissions. For instance, system permissions cannot
be occupied by third-party apps, say changing the permission
owner. This guarantee is achieved through three conditions:
(1) Android does not allow an app to deﬁne a permission with
the same name as an existing permission. (2) The permission
owner is recorded as the app that deﬁnes this permission ﬁrst.
(3) System apps are installed before any third-party apps and
72
TABLE I: Protection levels of custom permissions.
Protection Level
Percentage
normal
dangerous
signature†
instant‡
Amount
26,330
1,986
53,724
32.09%
2.42%
65.48%
0.01%
12
†: Include mixed levels: signature|privileged and signatureOrSystem.
‡: Only for instant apps [9].
TABLE II: Permission groups of custom permissions.
Group Type
System Group
Custom Group
Amount
4,526
885
83.64%
16.36%
Percentage
ﬁrst deﬁne a set of permissions to protect speciﬁc platform
resources. It can be seen that Android does not distinguish the
permission type in this course, reﬂecting the design philosophy
of custom permissions, to a certain extent.
C. Usage Status
To understand the status quo of using custom permissions,
we conducted a large-scale measurement based on 208,987
APK ﬁles crawled from third-party app markets and randomly
selected from the AndroZoo dataset [22], mainly ranging
from 2017-2019. Speciﬁcally, we focus on the following two
research questions.
1) How many apps use custom permissions?
2) What are the purposes of using custom permissions?
To answer these questions, we developed a script to scan
the manifest ﬁles of apps. Through parsing custom permission
related attributes, we obtained the ﬁrst-hand statistics data for
further processing.
To Question-1, our results show that 52,601 apps (around
25.2%) declare a total of 82,052 custom permissions. We
could ﬁnd the use of custom permissions is not unusual.
On the aspect of protection levels, more than 65% of these
permissions are signature, as listed in Table I. The reason
for such a high percentage may be that a series of apps
are developed by the same company (signed by the same
certiﬁcate) and need to share some resources only restricted to
themselves. On the other hand, normal permissions account
for 32.09%, and dangerous permissions account for only
2.42%.
Besides, 5,411 custom permissions (around 6.6% of the
total) are assigned to permission groups, see Table II. Among
them, system permission groups are used more frequently than
custom permission groups (4,526 vs. 885). Using a system
group can simplify the permission UI shown to the user, which
is recommended by Google [7].
To Question-2, we crawled the custom permission names
and their permission descriptions for analysis. Combined with
a number of manual case studies, here we summarize the
purposes of using custom permissions.
• Use services provided by third-parties. For example, up
to 16,259 apps in our dataset declare the JPUSH_MESSAGE
Fig. 1: An alternative attack ﬂow achieving privilege escalation.
permission to obtain the message push service offered by
the JPush platform [10].
• Restrict the accessing to apps’ shared data. For example,
com.qidian.QDReaderMM deﬁnes the READ_DB4 permis-
sion to control the accessing to its database of e-books.
• Control the communication between apps. For example,
only the apps with the BROADCAST_RECEIVER5 permis-
sion can send a broadcast to the broadcast receiver of
com.tencent.portfolio which deﬁnes this permission.
III. MOTIVATION AND THREAT MODEL
In this section, we discuss the motivation case of our work
and give the threat model.
A. Motivation Case
The security of Android custom permissions was not thor-
oughly studied in previous research. The reason may be that
the corresponding security threats were regarded as limited,
irrelevant to sensitive system resources and user data. As the
only literature focusing on custom permissions, the study of
Tuncay et al. [41] found that custom permissions were insuf-
ﬁciently isolated, and there is no enforcing name convention
for custom permissions in Android. They also presented two
privilege escalation attacks to access unauthorized resources.
As shown in upper Figure 1, one attack case is that the
adversary creates an app app-test that deﬁnes and requests
a normal custom permission cp, and the user installs this
app. Then, the deﬁnition of cp is changed to dangerous,
and the user installs this updated app-test again. Finally,
app-test obtains dangerous cp without user consent, that
is, privilege escalation. This attack can be further extended to
obtain dangerous system permissions.
Our Findings. According to the Android Security Bulletins
and the corresponding source code change logs [5], the above
attack has been ﬁxed on Android 10. Google’s ﬁx prevents the
permission protection level changing operation – from normal
or signature to dangerous.
However, we ﬁnd that, though this attack indeed has been
blocked by Google, another app execution path still can
achieve the same consequence, which bypasses the ﬁx. As
illustrated in lower Figure 1, the adversary creates two apps,
4Full name: com.qidian.QDReader.permission.READ_DB
5Full name: com.tencent.portfolio.permission.BROADCAST_RECEIVER
app-d and app-r. app-d deﬁnes a normal custom permission
cp, and app-r requests cp. Also,
there are two updated
versions of app-d, say app-d-1 and app-d-2. To be speciﬁc,
app-d-1 removes the deﬁnition of cp, and app-d-2 re-deﬁnes
cp with changing the protection level to dangerous. The user
executes the following sequence: install app-d, install app-r,
install app-d-1, and install app-d-2. Finally, app-r obtains
cp and achieves the privilege escalation.
Our further investigation shows this newly discovered attack
derives from a design shortcoming lying in the Android
permission framework, that is, DS#1 – dangling custom per-
mission (see Section VI-A).
Insight. This preliminary exploration motivates us to think
about how to check the security of the complicated custom
permission mechanism effectively. The previously reported
two attack cases [41] may be only the tip of the iceberg, and
an automatic analysis tool is needed. Besides, our ultimate
target should be identifying design shortcomings lying in the
permission framework, not just discovering successful attack
cases.
B. Automatic Analysis
On the high level, there exist two ways to conduct automatic
analysis for custom permissions: static analysis (e.g., analyzing
the source code of Android OS to ﬁnd design ﬂaws) and
dynamic analysis (e.g., executing multitudinous test cases to
trigger unexpected behaviors). In the end, we decided to adopt
the strategy of dynamic analysis for two main reasons: (1)
The internal implementation of the permission mechanism is
quite complicated. (2) Static analysis usually requires prior
knowledge to construct targeted models for matching.
Also, inspired by the motivation case, the analysis process
could be abstracted as ﬁnding speciﬁc app execution sequences
that can trigger privilege escalation issues. The internal opera-
tions of the permission mechanism could be treated as a black-
box accordingly. Following this high-level idea, we designed
an automatic fuzzing tool – CUPERFUZZER.
C. Threat Model
In our study, we consider a general local exploit scenario.
That is, the adversary can distribute malicious apps to app
markets. The user may download and install some malicious
apps on her Android phone. Note that this user understands the
security risks of sensitive permissions and is cautious about
73
-- define dangerous cp-- request cpInstall updated app-test-- define dangerous cp-- request cpInstall updated app-test-- define normal cp-- request cpInstall app-test-- define normal cp-- request cpInstall app-test-- app-r obtains cp without user consentPrivilege Escalation-- app-r obtains cp without user consentPrivilege Escalation-- define normal cpInstall app-d-- define normal cpInstall app-d-- remove definition of cpInstall updated app-d-- remove definition of cpInstall updated app-d-- define dangerous cpInstall updated app-d-- define dangerous cpInstall updated app-d-- app-test obtains cp without user consentPrivilege Escalation-- app-test obtains cp without user consentPrivilege Escalation-- request cpInstall app-r-- request cpInstall app-rTuncay et al. [NDSS 2018]:Blocked in Android 10An alternative attack flow:Available in Android 10Fig. 2: Overview of CUPERFUZZER.
granting permissions to apps. To conduct malicious actions,
malicious apps try to exploit the ﬂaws of custom permissions
to access unauthorized platform resources, such as obtaining
dangerous system permissions without user consent.
IV. DESIGN OF CUPERFUZZER
In this section, we introduce the detailed design of our
automatic analysis tool – CUPERFUZZER. It treats the internal
operations of the Android permission framework as a black-
box and tries to trigger privilege escalation issues by executing
massive test cases. As discussed in Section III-B, each test
case is essentially an execution sequence composed of various
test apps and permission-related operations. Besides, we also
consider how to check the execution results and identify
critical paths to facilitate locating the causes efﬁciently.
As illustrated in Figure 2, on a high level, CUPERFUZZER
contains ﬁve main steps, as following.
• Seed Generation. As the ﬁrst step, CUPERFUZZER needs
to generate a test app as the seed to activate the subse-
quent fuzzing process.
• Test Case Construction. Next, CUPERFUZZER dynami-
cally constructs plenty of complete cases for testing.
• Test Case Execution. Then, CUPERFUZZER executes test
cases in a controlled environment in parallel.
• Effective Case Checking. After executing a test case,
CUPERFUZZER checks whether a privilege escalation
issue has been triggered.
• Critical Path Extraction. Finally, among all discovered
effective cases, CUPERFUZZER automatically ﬁlters du-
plicated cases and identiﬁes the critical paths.
A. Seed Generation
As mentioned in our threat model (see Section III-C), we
want to discover local privilege escalation cases. Therefore, a
successful attack will be achieved by malicious apps installed
on the phone, and our fuzzing test will start with installing a
test app, say the seed app.
Seed Variables. This seed app deﬁnes and requests a custom
permission. Also, it requests all dangerous and signature
74
system permissions6. Three attributes of this custom permis-
sion deﬁnition are variable, including:
• Permission name: based on a pre-deﬁned list but cannot
be the same as a system permission.
• Protection level: normal, dangerous, or signature.
• Group: a certain system group or not set.
Note that we prepare a pre-deﬁned permission name list in-
stead of random generation because some unusual names may
trigger unexpected behaviors, such as containing special char-
acters and starting with the general system permission preﬁx
android.permission. Therefore, they need to be constructed
ingeniously. Besides, based on our workﬂow, the number of
seed apps is usually small, not enough for randomness.
Seed Generation Modes. The key components of the seed app
can be split into two apps, say one app deﬁning the custom
permission and the other app requesting permissions. Also,
they are signed by different certiﬁcates. Therefore, we have
two seed generation modes, say single-app mode and dual-
app mode. Different modes will further affect the subsequent
step of test case construction.
Seed Generation. As a result, when generating a new seed,
CUPERFUZZER needs to determine the seed generation mode
and custom permission deﬁnition. In practice, to avoid the
time cost of real-time app construction, CUPERFUZZER could
construct plenty of test apps and store them in a dataset
in advance. When running tests, CUPERFUZZER randomly
selects an app from the prepared dataset as the seed and
quickly activates the fuzzing process.
B. Test Case Construction
Next, CUPERFUZZER constructs a complete test case. As
illustrated in Figure 3, it is an execution sequence consisting of
multiple test apps and operations that may affect the granting
of requested permissions.
Operation Selection. After reviewing the Android technical
documents and source code [12], we conﬁrm four operations