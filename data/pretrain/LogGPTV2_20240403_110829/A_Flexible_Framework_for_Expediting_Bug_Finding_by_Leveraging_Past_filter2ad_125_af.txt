AFlexibleFrameworkforExpeditingBugFindingbyLeveragingPast(Mis-)BehaviortoDiscoverNewBugsACSAC2020,December7–11,2020,Austin,USATable6:Portfoliomodeconsistency(over18runs)ProgramsBugIDAFLOmniFuzzMOptOmniFuzzFairfuzzOmniFuzzlibarchive118○18✓11○217○17○2○32○0○18○40✓0✓1○50✓0○2○libjpeg617○18✓15○717○18✓2○85○2○0○95○2○0○105○2○0○114○2○0○1217✓18○4○1315✓17○4○1411○15○4○libplist1518✓18○18○1618✓18○18○libpng173○0✓0✓libxml2181○0○10○190○0✓0✓200○0○11○214○0○13○pcre223○1○0✓230✓2✓0✓tiff2417✓2○18○2518✓2○18○2617○2○18○2717✓2○18○2817✓2○18○yaml296○8○18✓Thenumberoftimesabugisfoundbyanapproachispresentedwithrespecttothebasefuzzerandshownas✓todenotesameasthebasefuzzer,○morethanthebasefuzzer,and○fewerthanthebasefuzzer.Table7:ListofnewbugsdiscoveredbyourapproachProgramsVersionsCVEs/BugsBugdetailslibjpeg-turbo(cjpeg)2.0.4CVE-2020-13790Heap-basedbuffer-over-readinget_rgb_row()libarchive(bsdtar)3.4.0,3.4.1devCVE-2019-19221Out-of-boundsreadinarchive_wstring_append_from_mbs()3.4.1devBug1298Out-of-boundswriteinarchive_string_append_from_wcs()pcre(pcre2test)10.34-RC1,10.33Bug-2479HeapoverflowinGETCHARINC()Bug-2480HeapoverflowinGETCHARLEN()Bug-2481HeapoverflowinGETCHARLENTEST()Bug-2482HeapoverflowinGETCHARINCTEST()Bug-2483Out-of-boundsreadininternal_dfa_match()Bug-2484Stack-overflowininternal_dfa_match()torecoverinstructionsthatleadtoacrash.Subsequently,Cuietal.[11]suggestedarefinementwhereintheaccuracyoftherecovereddataflowisimproved.Noneoftheseapproachesweredesignedtobeusedforon-linededuplication.Weincorporatedseveralideas(e.g.,backwarddataflow[12]andrecord&replay[8])fromtheseworksinthede-signofourdeduplicationstrategyforguidingthefuzzingprocess.Fuzzing:Theartandscienceoffuzzinghaswitnessedexplosivegrowth[3,4,6,27,41–43,53,60],driveninpartbytheboomingsoftwaresecuritymarket.Manyapproaches[4,43]trytoexplorelow-frequencypathsinordertoreachbugshiddeninsidelessex-ploredpaths.Vuzzer[43],forexample,usescontrolanddata-flowfeaturestoprioritizedeepandlessfrequentlyexploredcodepaths.Itperformstaintanalysistoinferthedatatypesatcertainoff-setsintheinput,andthenusesthatknowledgetomutateinputs.CollAFL[16]prioritizesinputselectionbasedonmoreuntouchedbranches(toincreasethecoverage)aswellasmorememoryac-cessoperations(tofindmemorycorruptions).Similarly,Angora[7]seekstoincreasebranchcoveragebysolvingpathconstraintsusingcontext-sensitivebranchcountandbyte-leveltainttracking.Todistinguishtheexecutionsofthesamebranchindifferentcontexts,AngoraappendscontexttothebranchIDstoexplorepathsmorepervasively.Bytrackingwhichinputbytesflowintoeachpathconstraint,theapproachmutatesonlythesebytesinsteadoftheentireinput.Lietal.[25]appliedastaticapproachonknownvulnerableprogramstoextractbasicblockinformation,comprisingthenumberofcallinstruction,operandtypesandstringtypes.Insomesense,theseattributescanbeviewedascharacterizingprogrambehavior,albeitnotatthearchitecturallevel.Basedontheseattributes,adeeplearningmodelisbuiltwhereinscoresareassignedtobasicblockstraversedbytheprogram.Bycalculatingscoresforbasicblocks,Lietal.[25]infersthefitnessofaninputformutationduringfuzzing.Weinfersimilarcontrolflowanddataflowbehaviorinformationusingperformancecountereventsbutwithlowoverhead.Concurrenttoourwork,Österlundetal.[39]proposedasanitizer-basedapproachtodirectfuzzingtowardstriggeringsanitizercheckstofindbugsfaster.Atahigh-level,theyalsoprioritizepathsbysteeringtheprogramtowardslocationsthataremorelikelytohavebugs.Unlikeours,theirapproachisbasedonsanitizerchecks,whichmaymisscertainbugtypese.g.,logicalerrors.Moreover,weimplementafeedbackmechanismtoactivelyguidefuzzingandswitchbetweenmultiplestrategiesatruntime.Ahandfulofworks[44,53,57]haveexaminedwhatschedulingalgorithmsproducethebestresultsforseedselection.Rebertetal.[44]formalizethenotionofexpostfactooptimalityseedselection,andprovideevidence-driventechniquesforidentifyingthequalityofaseedselectionstrategycomparedtoanoptimalsolution.Unlikeourwork,theseproposalsfocusonwaystomeasuretheoptimalcaseforbugsfoundwithaparticularsubsetofseedsortofinda“good”setofseedsthatcanbereusedfromoneapplicationtoan-other.Overall,theseworksshowthatthechoiceofseedschedulingalgorithmcansignificantlyimpactthesuccessoffuzzingcampaigns.Thestrategiesweapplytoacceptorrejectinputstobequeuedformutationarecomplementarytotheschedulingalgorithms.Hardwareassistance:Lastly,thereisagrowingbodyofre-searchonhardware-assistedfuzzing[10,15,47,50].Theseap-proachesusetheprocessortracefeaturetogatherinformationforgaugingprogramcoverage.Althoughtheseapproacheslever-ageprocessortracefacilitiestoefficientlycollectanexecutiontrace,theunderlyingcoverage-guidingprincipleissimilartothatofAFL.8ConclusionWedemonstrateinefficienciesincontemporarycoverage-guidedfuzzers,dueprincipallytotheirequalprioritizationofallprogrampaths.Toaddresstheinefficiencies,weproposeaframeworkcalledOmniFuzzthatincorporateson-the-flycrashdeduplicationasafeedbackmechanismtocoaxthefuzzertochangecoursewhennouniquecrashesareobtainedforsometime.AuniqueaspectofOmniFuzzisitsuseofperformancecounterdatatoderivein-formationthatcanbeusedasacoveragemetrictoguideinputselection.Armedwiththesecapabilities,weshowhowonecanA Flexible Framework for Expediting Bug Finding by Leveraging Past (Mis-)Behavior to Discover New Bugs
ACSAC 2020, December 7–11, 2020, Austin, USA
[32] David Molnar and Lars Opstad. 2010. Effective fuzzing strategies. In CERT
Performance Monitoring.
[33] Martin Monperrus. 2018. Automatic Software Repair: A Bibliography. In ACM
vulnerability discovery workshop.
Computing Surveys. 17:1–17:24.
[34] Tipp Moseley, Neil Vachharajani, and William Jalby. 2011. Hardware Performance
Monitoring for the Rest of Us: A Position and Survey. In International Conference
on Network and Parallel Computing. 293–312.
[35] Mozilla. 2018. Mozilla Record & Replay. https://rr-project.org/.
[36] Dongliang Mu, Yunlan Du, Jianhao Xu, Jun Xu, Xinyu Xing, Bing Mao, and Peng
Liu. 2019. POMP++: Facilitating Postmortem Program Diagnosis with Value-set
Analysis. IEEE Transactions on Software Engineering.
[37] Syed Shariyar Murtaza, Wael Khreich, Abdelwahab Hamou-Lhadj, and Ayse Basar
Bener. 2016. Mining Trends and Patterns of Software Vulnerabilities. Journal of
Systems and Software 117, 218–228.
[38] Andrzej Nowak, Ahmad Yasin, Avi Mendelson, and Willy Zwaenepoel. 2015.
Establishing a Base of Trust with Performance Counters for Enterprise Workloads.
In USENIX Annual Technical Conference. 541–548.
[39] Sebastian Österlund, Kaveh Razavi, Herbert Bos, and Cristiano Giuffrida. 2020.
ParmeSan: Sanitizer-guided Greybox Fuzzing. In USENIX Security Symposium.
[40] Andy Ozment and Stuart E Schechter. 2006. Milk or Wine: Does Software Security
Improve with Age?. In USENIX Security Symposium. 93–104.
[41] Theofilos Petsios, Jason Zhao, Angelos D Keromytis, and Suman Jana. 2017.
SlowFuzz: Automated Domain-Independent Detection of Algorithmic Complexity
Vulnerabilities. In ACM Conference on Computer and Communications Security.
2155–2168.
[42] Mohit Rajpal, William Blum, and Rishabh Singh. 2017. Not all bytes are equal:
Neural byte sieve for fuzzing. In arXiv preprint arXiv:1711.04596.
[43] Sanjay Rawat, Vivek Jain, Ashish Kumar, Lucian Cojocar, Cristiano Giuffrida,
and Herbert Bos. 2017. VUzzer: Application-aware Evolutionary Fuzzing. In
Symposium on Network and Distributed System Security, Vol. 17. 1–14.
[44] Alexandre Rebert, Sang Kil Cha, Thanassis Avgerinos, Jonathan Foote, David
Warren, Gustavo Grieco, and David Brumley. 2014. Optimizing Seed Selection
for Fuzzing. In USENIX Security Symposium. 861–875.
[45] FuzzBench: 2020-04-21 Report. 2020. URL: https://www.fuzzbench.com/reports
/sample/index.html.
[46] Thomas Röhl, Jan Eitzinger, Georg Hager, and Gerhard Wellein. 2016. Validation
of Hardware Events for Successful Performance Pattern Identification in High
Performance Computing. In Tools for High Performance Computing. 17–28.
[47] Sergej Schumilo, Cornelius Aschermann, Robert Gawlik, Sebastian Schinzel, and
Thorsten Holz. 2017. KAFL: Hardware-assisted Feedback Fuzzing for OS Kernels.
In USENIX Security Symposium. 167–182.
[48] K Serebryany. 2015. LibFuzzer a Library for Coverage-guided Fuzz Testing. In
LLVM project.
[49] Konstantin Serebryany, Derek Bruening, Alexander Potapenko, and Dmitry
Vyukov. 2012. AddressSanitizer: A Fast Address Sanity Checker. In USENIX
Annual Technical Conference. 309–318.
[50] Robert Swiecki. 2016. Honggfuzz: A General-purpose, easy-to-use fuzzer with
interesting analysis options. https://github.com/google/honggfuzz.
[51] Lin Tan, Chen Liu, Zhenmin Li, Xuanhui Wang, Yuanyuan Zhou, and Chengxiang
Zhai. 2014. Bug characteristics in open source software. Empirical software
engineering 19, 6 (2014), 1665–1705.
[52] Sebastian Vogl and Claudia Eckert. 2012. Using Hardware Performance Events
for Instruction-Level Monitoring on the x86 Architecture. In European Workshop
on System Security.
[53] Junjie Wang, Bihuan Chen, Lei Wei, and Yang Liu. 2017. Skyfire: Data-driven
Seed Generation for Fuzzing. In IEEE Symposium on Security & Privacy. 579–594.
[54] Jinghan Wang, Yue Duan, Wei Song, Heng Yin, and Chengyu Song. 2019. Be
Sensitive and Collaborative: Analyzing Impact of Coverage Metrics in Grey-
box Fuzzing. In International Symposium on Research in Attacks, Intrusions and
Defenses. 1–15.
[55] Yaqing Wang and Quanming Yao. 2019.
arXiv:1904.05046 http://arxiv.org/abs/1904.05046
Few-shot Learning: A Survey.
[56] Vince Weaver and Jack Dongarra. 2010. Can hardware performance counters pro-
duce expected, deterministic results?. In Workshop on Functionality of Hardware
[57] Maverick Woo, Sang Kil Cha, Samantha Gottlieb, and David Brumley. 2013.
Scheduling Black-box Mutational Fuzzing. In ACM Conference on Computer and
Communications Security. 511–522.
[58] Jun Xu, Dongliang Mu, Ping Chen, Xinyu Xing, Pei Wang, and Peng Liu. 2016.
CREDAL: Towards Locating a Memory Corruption Vulnerability with Your Core
Dump. In ACM Conference on Computer and Communications Security. 529–540.
[59] Jun Xu, Dongliang Mu, Xinyu Xing, Peng Liu, Ping Chen, and Bing Mao. 2017.
Postmortem Program Analysis with Hardware-Enhanced Post-Crash Artifacts.
In USENIX Security Symposium. 17–32.
[60] Wei You, Peiyuan Zong, Kai Chen, XiaoFeng Wang, Xiaojing Liao, Pan Bian, and
Bin Liang. 2017. SemFuzz: Semantics-Based Automatic Generation of Proof-of-
Concept Exploits. In ACM Conference on Computer and Communications Security.
2139–2154.
American Fuzzy Lop (AFL).
URL:
[61] Michal Zalewski.
2017.
http://lcamtuf.coredump.cx/afl.
A APPENDIX
A.1 Hardware Events and Classes
We conservatively selected all those hardware performance counter
events that could explain the high-level behavior of a program, but
excluded those events that monitor low-level micro-architectural
information or that are difficult to relate to high-level program be-
havior. For example, we excluded the events relating to the pipelin-
ing behavior of the CPU. In the end, we were left with a set of 96
events, which we further grouped into 65 classes, shown in Table 8.
The criteria we used to group events were (a) events that are similar
but only differ due to the change in the size of hardware compo-
nents are considered as a single class, and (b) events that count hits
instead of cycles are split into different classes.
A.2 Time-to-crash Analysis
Tables 9, 10 and 11 present a detailed analysis on speedup for each
unique crash found on a per run basis on AFL, MOpt, and Fairfuzz
respectively, as discussed in §5.2. The column ‘E’ represents the
exact ratio of time to finding a crash by the base fuzzer vs our
approach, while the column ‘W’ scales the relative speedup in
terms of time window, where the granularity of the window is 15
minutes, i.e., if a fuzzer finds a crash in seconds vs 15 minute, W =
1. A larger ratio means that our approach finds the bug faster than
the base. To test for statistical significance we apply the pairwise
two-tailed Mann-Whitney U approach, represented by p-value (p).
The results show that, for most of the programs, the time-to-crash
data obtained using our approach are statistically different from
the base fuzzer.
A.3 Paths Exploration
Table 12 shows that, on average, we explore less paths than the base
fuzzer, but we still obtain as good, or better, outcomes. Thus, our
approach can be considered more directed in the search for bugs.
ACSAC 2020, December 7–11, 2020, Austin, USA
Sanjeev Das, Kedrian James, Jan Werner, Manos Antonakakis, Michalis Polychronakis, and Fabian Monrose
Table 8: Hardware events and their classes
#
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
Classes
cache-references
cache-misses
dTLB-loads
dtlb_load_misses
dtlb_load_misses_stlb_hit
dtlb_load_miss_causes_a_walk
dtlb_load_misses_walk_completed
dtlb_load_misses_walk_active_cycles
dtlb_load_misses_walk_pending_cycles
dTLB-stores
dtlb_store_misses
dtlb_store_misses_stlb_hit
dtlb_store_misses_miss_causes_a_walk
dtlb_store_misses_walk_completed
dtlb_store_misses_walk_active_cycles
dtlb_store_misses_walk_pending_cycles
iTLB-loads
iTLB-load-misses
itlb_misses_stlb_hit
Events
cache-references
cache-misses
dTLB-loads
dTLB-load-misses
dtlb_load_misses.stlb_hit
dtlb_load_misses.miss_causes_a_walk
dtlb_load_misses.walk_completed_1g
dtlb_load_misses.walk_completed_2m_4m
dtlb_load_misses.walk_completed_4k
dtlb_load_misses.walk_active
dtlb_load_misses.walk_pending
dTLB-stores
dTLB-store-misses
dtlb_store_misses.stlb_hit
dtlb_store_misses.miss_causes_a_walk
dtlb_store_misses.walk_completed_1g
dtlb_store_misses.walk_completed_2m_4m
dtlb_store_misses.walk_completed_4k
dtlb_store_misses.walk_completed
dtlb_store_misses.walk_active
dtlb_store_misses.walk_pending
iTLB-loads
iTLB-load-misses
itlb_misses.stlb_hit
itlb_misses_causes_a_walk
itlb_misses.miss_causes_a_walk
itlb_misses_walk_completed
itlb_misses_walk_active_cycles
itlb_misses_walk_pending_cycles
itlb_misses.walk_completed_1g
itlb_misses.walk_completed_2m_4m
itlb_misses.walk_completed_4k
itlb_misses.walk_completed
itlb_misses.walk_active
itlb_misses.walk_pending
47
48
49
50
51
52
53
54
55
56
Classes
#
34 mem_load_retired_fb_hit
35 mem-stores
36 mem_inst_retired_all_stores
37 mem_inst_retired_split_stores
38 mem_inst_retired_stlb_miss_stores
39 mem_load_retired_l1_miss
Events
mem_load_retired.fb_hit
mem-stores
mem_inst_retired.all_stores
mem_inst_retired.split_stores