preprocessor mode ( NoPP). In NoPP mode, any patch that affects
statements controlled by preprocessor variables will not be consid-
ered as an sp. We show in Appendix I that in NoPP mode, the detec-
tion rate of SPIDER does not vary much (a decrease of 1.15%, see
(Default - NoPP) in Table IV). Furthermore, we also allow the user
to specify the values of preprocessor variables, which can be used to
get the correct source file instead of the conservative NoPP mode.
the limitations above to be fundamental
implications of our requirements R1 and R2. Nonetheless, we
believe that our system provides a reasonable approach to identify
safe patches. Moreover, if these assumptions are considered too
strong, it is always possible to fall back to the more conservative
Security Patch (SeP) mode (see Section VI for details). Finally, it is
also possible to use our system to rank patches and prioritize those
identified as safe for manually vetting (and testing).
We consider
VI. SECURITY PATCH MODE
As explained in Section I, there could exist security patches
without a corresponding CVE entry. To verify this, we have a
configuration of SPIDER called Security Patch (SeP) mode that
identifies security patches with no false positives, i.e., all the patches
identified by this configuration are indeed security patches. SeP
is based on the intuition that most of the security patches add
additional input validation checks. Therefore, in SeP mode, we
restrict ourselves to safe patches that affect only control-flow
statements. Furthermore, when the commit message is available,
we use the technique proposed by Zhou et al. [79] to filter out
non-security related fixes. However, there can be false negatives,
that is, potential security patches not detected as such.
Note that while SeP mode is more limited in the patches that it
considers safe, it does not rely on any of the assumptions discussed
1570
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 09:21:07 UTC from IEEE Xplore.  Restrictions apply. 
in Section V. We believe that SeP mode of SPIDER is the first step
towards a practical solution of automatically identifying security
patches that could be easily integrated into any source-control
system. We plan to integrate SeP mode of SPIDER into GitHub
security alerts [8], which helps both the developers and maintainers
to handle security patches. Note that our running example (shown
in Listing 1), although being a security patch, is not detected by the
SeP mode because it also affects non-control flow instructions.
VII. EVALUATION
We evaluate the effectiveness of SPIDER in three different ways.
First, we run it on a large dataset of 341,767 changes (i.e., commits)
spanning over 32 repositories, collected from the year 2016 for
a total of 32 months, in order to understand if it actually detects
sps, according to our definition (see Section VII-A). Second, we
run SPIDER on a set of security patches (i.e., CVE patching commits)
to evaluate the usefulness of this tool in speeding the propagation of
these critical fixes. Third, in Section VII-D, we show a way to use
the SeP mode of SPIDER as a vulnerability finding tool by identi-
fying non-CVE security patches that are missing in various active
forks of the analyzed projects. Finally, we show in Section VII-E,
that there are several non-CVE security patches in the Linux kernel
and many of these are still unpatched, at the time of writing, on
some of its Android-related forks: this provides real examples where
SPIDER can be useful in fixing potential n-day vulnerabilities.
The analysis that SPIDER performs, described in Section IV, is an
intra-procedural static analysis that does not consider the interaction
between different modified functions. For this reason, to isolate the
effect of these interactions that represent a possible confounding
factor, we evaluate SPIDER only on patches that affect a single C
source file (i.e., .c format only). All the patches studied in our
evaluation are real changes extracted from repositories of widely
used open-source projects (see Section VII-A for more details).
Performance: On average SPIDER took 3.4 seconds to analyze a
patch on a machine equipped with a two-core 2.40 GHz CPU, and
8GB RAM, demonstrating its speed and scalability.
Active forks: We noticed that most of the forks of repositories
are inactive or dead, i.e., there are no new commits made to the
repository since they are forked. Considering such inactive forks
could exaggerate our results, and, therefore, we considered only
active forks. We consider a fork to be active if it has at least ten new
commits in the last six months, and using this filter, we were able
to eliminate a number of forks. For instance, in the case of Linux
kernel (ID 1), we consider only 269 active forks out of 23,854 forks.
A. Large-scale evaluation
We ran SPIDER on a large set of patches: we selected 32
open-source projects widely used by desktop, mobile, and embedded
operating systems, and we collected from each of them all the
single-C-file commits for the past 32 months from the time of
writing (considering merges as single commits). All the details of
the projects are shown in Table II.
Checking for patch applicability: We use the following syntactic
approach to identify whether a patch of a project is applicable to (or
missing from) a fork or other projects. Given a patch, we extract the
affected fileâ€™s source code before the patch (i.e., original file) and
compare it to the latest version of the corresponding file in the fork.
If the file is present in the fork and all the functions affected by the
patch do not differ between the original file of the patch and the corre-
sponding latest file in the fork, then it means that the patch can be ap-
plied to the fork. To perform the comparison, we use the git diff tool,
and check that there are no modifications in the targeted functions.
It is interesting to note that, across all repositories, the percentage
of sps mostly stays around 20%-25%, without much variation.
There are certain projects where the percentage of detected sps
is low, such as IDs 15 and 16. This low detection rate is mainly
because of the inherently complex code and patches. We refer all the
interested readers to Appendix C, where we explain this in detail.
Listing 6 shows a patch identified as an sp, where the patch
modifies error basic blocks, which are ignored. Also, the patch
moves certain function calls Py_INCREF and Py_DECREF.
However, as the arguments to these calls (i.e., dll and ftuple)
are not modified by the patch, the symbolic expressions of the
arguments are proved to be equivalent by Z3, resulting in the patch
being considered an sp. We show a few other sps in Appendix E.
Looking at these results, we argue that SPIDER would be helpful
for project maintainers and could be directly used to port the fixes
or to prioritize the changes that must be ported.
C. Evaluation on CVEs
We wanted to determine how many security patches are indeed
sps, as claimed in Section I. To this end, we collected all the patching
commits linked as reference fixes for kernels CVEs from the An-
droid security bulletins [1], and, similar to the large-scale evaluation,
we studied only the CVEs that patch a single C file. We also collected
all the CVEs for the remaining repositories over the same amount
of time. This resulted in the analysis of 809 CVE patches.
Table III shows the results obtained after running SPIDER
on these patches, which show that 55.37% of the CVE-patching
commits are non-disruptive, while on generic patches (i.e., Table II)
the percentage was 19.72%. This finding shows that SPIDER could
be useful not only to speed-up the process of selecting and applying
a significant number of changes (as shown in Section VII-A) but
also to apply more than half of the security patches in a faster way.
Listing 5 shows an example of CVE patching commit from
Android security bulletin identified as a sp by SPIDER. Listing 5
is also one of the CVEs that we mentioned in Section I, which was
patched in Android more than a year after the appearance of the
corresponding entry in the database.
Looking at Table III, it is interesting to see that SPIDER
performed relatively well with more than 50% success rate in all
but OpenSSL and VLC CVEs. This is because the security fixes
in these software packages are complex. More details can be found
in Appendix D.
B. Effectiveness of patch analysis
D. Security patches missing a CVE number
Table II also shows the number of sps identified by
SPIDER in the dataset. Over the total 341,767 commits studied,
SPIDER identified 67,408 (19.72%) safe patches (Column 6).
Furthermore, 58.72% of these patches are missing in at least one
of the active forks (MIAFs).
We used SPIDER in SeP mode on all the commits to identify
security patches. We then checked if these patches have an
associated CVE number. Listing 6 and 4 show examples of security
patches missing CVE entries, which are detected by the SeP mode
of SPIDER.
1571
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 09:21:07 UTC from IEEE Xplore.  Restrictions apply. 
s
e
h
c
t
a
p
y
t
i
r
u
c
e
s
E
V
C
-
n
o
N
)
%
(
s
F
A
I
M
l
a
t
o
T
)
%
(
s
F
A
I
M
)
%
(
l
a
t
o
T
)
s
t
i
m
m
o
c
r
e
v
o
%
(
s
p
s
s
k
r
o
f
e
v
i
t
c
A
s
t
i
m
m
o
C
g
a
t
/
h
c
n
a
r
b
t
i
g
d
e
i
d
u
t
S
t
c
e
j
o
r
P
)
.
%
0
0
(
0
)
.
%
7
7
6
4
(
7
9
2
)
.
%
5
9
5
3
(
1
1
2
)
.
%
8
8
1
9
(
2
6
3
)
.
%
0
0
(
0
)
.
%
0
0
0
1
(
4
9
)
.
%
0
0
(
0
)
.
%
0
0
0
1
(
9
9
)
.
%
7
0
6
8
(
3
7
1
A
N
/
)
.
%
0
0
(
0
)
.
%
0
5
7
(
3
)
.
%
3
4
1
7
(
0
3
)
%
9
0
9
(
1
.
)
.
%
7
6
6
1
(
2
)
.
%
6
8
2
4
(
3
A
N
/
)
.
%
0
0
(
0
)
.
%
0
0
4
(
2
)
.
%
5
3
2
8
(
8
2
)
.
%
1
8
8
(
7
3
)
.
%
4
6
3
6
(
7
)
.
%
0
0
8
(
4
)
.
%
0
0
(
0
)
.
%
0
0
(
0
)
.
%
7
6
6
8
(
3
1
)
.
%
0
0
0
1
(
1
A
N
/
)
.
%
0
0
(
0
A
N
/
)
.
%
2
1
4
9
(
6
1
5
3
6
7
8
5
4
9
3
8
9
4
4
9
9
9
1
0
2
0
5
4
2
4
1
1
2
1
7
2
0
5
4
3
2
4
1
1
5
1
4
5
1
1
0
9
2
0
7
1
)
.
%
4
7
6
4
(
7
2
4