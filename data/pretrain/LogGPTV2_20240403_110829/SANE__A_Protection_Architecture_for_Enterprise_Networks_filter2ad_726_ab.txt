municate with server by prepending the returned capability to
each packet.
.
users and hosts, advertising services that are available,
and deciding who can connect to these services. It al-
lows hosts to communicate by handing out capabilities
(encrypted source routes). As we will see in Section 3.5,
because the network depends on it, the DC will typically
be physically replicated (described in Section 3.5).
The DC performs three main functions:
1. Authentication Service: This service authenticates
principals (e.g., users, hosts) and switches. It main-
tains a symmetric key with each for secure commu-
nication.2
2. Network Service Directory (NSD): The NSD re-
places DNS. When a principal wants access to a
service, it ﬁrst looks up the service in the NSD (ser-
vices are published by servers using a unique name).
The NSD checks for permissions—it maintains an
access control list (ACL) for each service—and then
returns a capability. The ACL is declared in terms
of system principals (users, groups), mimicking the
controls in a ﬁle system.
3. Protection Layer Controller: This component
controls all connectivity in a SANE network by gen-
erating (and revoking) capabilities. A capability is a
switch-level source route from the client to a server,
Figure 2: Packets forwarded from client A to server B across
multiple switches using a source-routed capability. Each layer
contains the next-hop information, encrypted to the associated
switch’s symmetric key. The capability is passed to A by the
DC (not shown) and can be re-used to send packets to B until it
expires.
Ethernet
SANE header
IP header
data
Figure 3: SANE operates at the same layer as VLAN. All
packets on the network must carry a SANE header at the isola-
tion layer, which strictly deﬁnes the path that packet is allowed
to take.
as shown in Figure 2. Capabilities are encrypted
in layers (i.e., onion routes [23]) both to prove that
they originated from the DC and to hide topol-
ogy. Capabilities are included in a SANE header
in all data packets. The SANE header goes between
the Ethernet and IP headers, similar to the location
VLANs occupy (Figure 3).
The controller keeps a complete view of the network
topology so that it can compute routes. The topol-
ogy is constructed on the basis of link-state updates
generated by authenticated switches. Capabilities
are created using the symmetric keys (to switches
and hosts) established by the authentication service.
The controller will adapt the network when things
go wrong (maliciously or otherwise). For exam-
ple, if a switch ﬂoods the DC with control trafﬁc
(e.g. link-state updates), it will simply eliminate the
switch from the network by instructing its imme-
diate neighbor switches to drop all trafﬁc from that
switch. It will issue new capabilities so that ongoing
communications can start using the new topology.
All packet forwarding is done by switches, which can
be thought of as simpliﬁed Ethernet switches. Switches
forward packets along the encrypted source route carried
in each packet. They also send link-state updates to the
DC so that it knows the network topology.
Note that, in a SANE network, IP continues to pro-
vide wide-area connectivity as well as a common fram-
140
Security ’06: 15th USENIX Security Symposium
USENIX Association
4
ing format to support the use of unmodiﬁed end hosts.
Yet within a SANE enterprise, IP addresses are not used
for identiﬁcation, location, nor routing.
3.2 Network Service Directory
The NSD maintains a hierarchy of directories and ser-
vices; each directory and service has an access control
list specifying which users or groups can view, access,
and publish services, as well as who can modify the
ACLs. This design is similar to that deployed in dis-
tributed ﬁle systems such as AFS [25].
As an example usage scenario, suppose martin
wants to share his MP3’s with his friends aditya,
mike, and tal in the high performance network-
ing group.
He sets up a streaming audio server
on his machine bongo, which has a directory
stanford.hpn.martin.friends with ACLs
already set to allow his friends to list and acquire ser-
vices. He publishes his service by adding the command
sane --publish stanford.martin.ambient:31337
to his audio server’s startup script, and, correspondingly,
adds the command
sane --remove stanford.martin.ambient
to its shutdown script. When his streaming au-
dio server comes on line,
it publishes itself in the
NSD as ambient. When tal accesses this ser-
vice, he simply directs his MP3 player to the name
stanford.martin.ambient The NSD resolves
the name (similar to DNS), has the DC issue a capability,
and returns this capability, which tal’s host then uses to
access the audio server on bongo.
There is nothing unusual about SANE’s approach to
access control. One could envision replacing or combin-
ing SANE’s simple access control system with a more
sophisticated trust-management system [15], in order to
allow for delegation, for example. For most purposes,
however, we believe that our current model provides a
simple yet expressive method of controlling access to
services.
3.3 Protection Layer
All packets in a SANE network contain a SANE header
located between the Ethernet and IP headers. In Figure 4,
we show the packet types supported in SANE, as well as
their intended use (further elaborated below).
Communicating with the DC. SANE establishes de-
fault connectivity to the DC by building a minimum
HELLO
Payload
DC
Request Capability
Authenticator
Payload
FORWARD
Cap-ID
Cap-Exp
Capability
Payload
REVOKE
Cap-ID
Cap-Exp
Signature
DC
Figure 4: Packet types in a SANE network: HELLO packets
are used for immediate neighbor discovery and thus are never
forwarded. DC packets are used by end hosts and switches to
communicate with the DC; they are forwarded by switches to
the DC along a default route. FORWARD packets are used for
most host-to-host data transmissions; they include an encrypted
source route (capability) which tells switches where to forward
the packet. Finally, REVOKE packets revoke a capability before
its normal expiration; they are forwarded back along a capabil-
ity’s forward route.
spanning tree (MST), with the DC as the root of the tree.
This is done using a standard distance vector approach
nearly identical to that used in Ethernet switches [1], with
each switch sending HELLO messages to its neighbor, in-
dicating its distance from the root. The MST algorithm
has the property that no switch learns the network topol-
ogy nor is the topology reproducible from packet traces.
The spanning tree is only used to establish default
routes for forwarding packets to the DC. We also need
a mechanism for the DC to communicate back with
switches so as to establish symmetric keys, required both
for authentication and for generating and decoding capa-
bilities. Note that the DC can initially only communicate
with its immediate neighbors, since it does not know the
full topology.
The DC ﬁrst establishes shared keys with its direct
neighbors, and it receives link-state updates from them.
It then iteratively contacts switches at increasing dis-
tances (hop-counts), until it has established shared keys
with all switches to obtain a map of the full topology.3
To contact a switch multiple hops away, the DC must
ﬁrst generate a capability given the topology informa-
tion collected thus far. Once established, keys provide
conﬁdentiality, integrity, and replay defense for all sub-
sequent trafﬁc with the DC via an authenticator header,
much like IPsec’s ESP header.
All capability requests and link state updates—packets
of type DC—are sent along the MST. As packets traverse
the MST, the switches construct a request capability4 by
generating an encrypted onion at each hop containing the
previous and next hop, encrypted under the switch’s own
key. The DC uses the request capabilities to commu-
nicate back to each sender. Because these capabilities
encode the path, the DC can use them to determine the
location of misbehaving senders.
Point-to-Point Communication. Hosts communicate
USENIX Association
Security ’06: 15th USENIX Security Symposium
141
5
using capabilities provided by the DC. This trafﬁc is sent
using FORWARD packets which carry the capability. On
receipt of a packet, switches ﬁrst check that the capabil-
ity is valid, that it has not expired and that it has not been
revoked (discussed later).
Before discussing how capabilities are constructed,
we must differentiate between long-lived names and
ephemeral connection identiﬁers. Names are known to
the service directory for published services and their ac-
cess control lists.
Identiﬁers enable end hosts to de-
multiplex packets as belonging to either particular con-
nections with other end hosts or to capability requests
with the DC, much like transport-level port numbers in
TCP or UDP. (They are denoted as client-ID and
server-ID below.) So, much like in traditional net-
works `a la DNS names and IP addresses, users use SANE
names to identify end-points, while the network soft-
ware and hardware uses connection identiﬁers to identify
unique services.
The DC constructs capabilities using three pieces of
information: the client’s name and location (given in the
capability request), the service’s location (stored in the
service directory), and the path between these two end-
points (as calculated from the network topology and any
service policies).
Each layer in the capability is calculated recursively,
working backward from the receiver, using the shared
key established between the DC and the corresponding
switches.
1. Initialize:
CAPABILITY ← EKserver−name
server-ID, last-hop)
(client-name,
client-ID,
2. Recurse: For each node on the path, starting from
(switch-name, next-hop, prev-
(client-name, client-ID, ﬁrst-
the last node, do:
CAPABILITY ← EKswitch−name
hop, CAPABILITY)
3. Finalize:
CAPABILITY ← EKclient−name
hop, CAPABILITY),
IV
Where, Ek(m) denotes the encryption of message m
under the symmetric key k. Encryption is implemented
using a block cipher (such as AES) and a message au-
thentication code (MAC) to provide both conﬁdentiality
and integrity.
All capabilities have a globally unique ID Cap-ID
for revocation, as well as an expiration time, on the or-
der of a few minutes, after which a client must request a
new capability. This requires that clocks are only loosely
synchronized to within a few seconds. Expiration times
may vary by service, user, host, etc.
The MAC computation for each layer includes the
Cap-ID as well as the expiration time, so they cannot be
tampered with by the sender or en-route. The initializa-
tion vector (IV) provided in the outer layer of capabilities
is the encryption randomization value used for all layers.
It prevents an eavesdropper from linking capabilities be-
tween the same two end-points.5
Revoking Access. The DC can revoke a capability to im-
mediately stop a misbehaving sender for misusing a ca-
pability. A victim ﬁrst sends a revocation request, which
consists of the ﬁnal layer of the offending capability, to
the DC. The DC veriﬁes that the requester is on the ca-
pability’s path, and it returns a signed packet of type
REVOKE.
The requester then pushes the revocation request to the
upstream switch from which the misbehaving capabil-
ity was forwarded. The packet travels hop-by-hop on
the reverse path of the offending capability. On-path
switches verify the DC’s digital signature, add the re-
voked Cap-ID to a local revocation list, and compare
it with the Cap-ID of each incoming packet. If a match
is found, the switch drops the incoming packet and for-
wards the revocation to the previous hop. Because such
revocation packets are not on the data path, we believe
that the overhead of signature veriﬁcation is acceptable.
A revocation is only useful during the lifetime of its
corresponding capability and therefore carries the same
expiration time. Once a revocation expires, it is purged
from the switch. We discuss protection against revoca-
tion state exhaustion in section 4.1.
3.4 Interoperability
Discussion thus far has assumed a clean-slate redesign
of all components in the network. In this section, we de-
scribe how a SANE network can be used by unmodiﬁed
end-hosts with the addition of two components: transla-
tion proxies for mapping IP events to SANE events and
gateways to provide wide-area connectivity.
Translation Proxies. These proxies are used as the ﬁrst
hop for all unmodiﬁed end hosts. Their primary func-
tion is to translate between IP naming events and SANE
events. For example, they map DNS name queries to DC
service lookups and DC lookup replies to DNS replies.
When the DC returns a capability, the proxy will cache
it and add it to the appropriate outgoing packets from
the host. Conversely, the proxy will remove capabilities
from packets sent to the host.
In addition to DNS, there are a number of service
discovery protocols used in today’s enterprise networks,
such as SLP [44], DNS SD [4], and uPNP [6]. In order to
be fully backwards-compatible, SANE translation prox-
142
Security ’06: 15th USENIX Security Symposium
USENIX Association
6
ies must be able to map all service lookups and requests
to DC service queries and handle the responses.
Gateways. Gateways provide similar functionality to
perimeter NATs. They are positioned on the perime-
ter of a SANE network and provide connectivity to the
wide area. For outgoing packets, they cache the capa-
bility and generate a mapping from the IP packet header
(e.g., IP/port 4-tuple) to the associated capability. All in-
coming packets are checked against this mapping and, if
one exists, the appropriate capability is appended and the
packet is forwarded.
Broadcast. Unfortunately, some discovery protocols,