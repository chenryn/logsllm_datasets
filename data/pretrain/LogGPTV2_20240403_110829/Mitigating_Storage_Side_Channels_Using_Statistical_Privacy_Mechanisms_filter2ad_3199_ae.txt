(a) ǫ = 0.005
Top 1
Top 3
Top 5
Top 10
50 100 150 200 250 300 350 400 450 500
Queries
(c) ǫ = 0.02
y
c
a
r
u
c
c
A
e
g
a
r
e
v
A
1.0
0.8
0.6
0.4
0.2
0.0
y
c
a
r
u
c
c
A
e
g
a
r
e
v
A
1.0
0.8
0.6
0.4
0.2
0.0
Top 1
Top 3
Top 5
Top 10
50 100 150 200 250 300 350 400 450 500
Queries
(b) ǫ = 0.01
Top 1
Top 3
Top 5
Top 10
50 100 150 200 250 300 350 400 450 500
Queries
(d) ǫ = 0.04
y
c
a
r
u
c
c
A
e
g
a
r
e
v
A
1.0
0.8
0.6
0.4
0.2
0.0
y
c
a
r
u
c
c
A
e
g
a
r
e
v
A
1.0
0.8
0.6
0.4
0.2
0.0
Top 1
Top 3
Top 5
Top 10
50 100 150 200 250 300 350 400 450 500
Queries
(a) ǫ = 1
Top 1
Top 3
Top 5
Top 10
50 100 150 200 250 300 350 400 450 500
Queries
(c) ǫ = 4
y
c
a
r
u
c
c
A
e
g
a
r
e
v
A
1.0
0.8
0.6
0.4
0.2
0.0
y
c
a
r
u
c
c
A
e
g
a
r
e
v
A
1.0
0.8
0.6
0.4
0.2
0.0
Top 1
Top 3
Top 5
Top 10
50 100 150 200 250 300 350 400 450 500
Queries
(b) ǫ = 2
Top 1
Top 3
Top 5
Top 10
50 100 150 200 250 300 350 400 450 500
Queries
(d) ǫ = 5
Figure 5: Average rank accuracy based on RES ﬁeld
Figure 6: Average rank accuracy based on %CPU ﬁeld
computations continually during each test. The number of
memory pages allocated by each process to store its array of
ﬂoats was scaled linearly across the ten processes: the ﬁrst
process allocated an 80MB array, the next process allocated
a 95MB array, and so on up to the tenth process, which
allocated a 215MB array. Similarly, the processes were con-
ﬁgured with linearly scaled nice values ranging from −19
(highest priority) through −1 (lowest).
Let R(k) and R′(k) be the set of top k processes displayed
by the two top programs. The top-k accuracy is deﬁned as
k |R(k) ∩ R′(k)|. Fig. 5 shows the average rank accuracy for
1
various values of k when processes were ranked by the RES
ﬁeld. The RES ﬁeld is read from /proc//statm, calcu-
lated as ﬁlePages + anonPages, and represents the physical
memory usage of the process. Fig. 6 shows the average rank
accuracy when processes were ranked by the %CPU ﬁeld, cal-
culated as (utime[i]−utime[i − 1])/(uptime[i]−uptime[i − 1]).
Several observations from Fig. 5 and Fig. 6 are worth not-
ing. First, top retains much of its ability to rank processes
by these measures; e.g., even for the lowest values of ǫ tested
(Fig. 5(a) and Fig. 6(a)), the top-5 ranks remained roughly
80% correct on average through the tests. Second, whereas
the top-10 rank is generally more accurate than the top-1
rank in Fig. 5, the reverse is true in Fig. 6. This occurs be-
cause while the memory usage of the ten test processes was
scaled linearly, our linear scaling of nice values caused the
actual %CPU to drop oﬀ super-linearly. So, for example, the
average diﬀerence in %CPU values for the processes with nice
values −19 and −18 was much larger than the average %CPU
diﬀerence between processes with nice values −3 and −1.
7. DISCUSSION
Security limitations. Since we do not noise every ker-
nel data-structure ﬁeld that is used to serve procfs queries,
there remains the possibility that such ﬁelds might reveal in-
formation about the true values of noised ﬁelds. This could
occur either because the unprotected ﬁelds are related to
those noised ﬁelds by invariants that our techniques did not
ﬁnd (see Sec. 5.2) or because those relationships are only
statistical (but not invariant).
It will therefore be neces-
sary to extend the scope of our protections to other ﬁelds
as new procfs storage side-channel attacks are discovered
or, in the limit, that all kernel data-structures used to gen-
erate procfs contents be protected. As additional ﬁelds are
brought under the protections of dpprocfs, the invariants
that are reestablished on those values will need to be ex-
panded appropriately.
Similarly, the value of ǫ used to protect a ﬁeld might need
to be updated as new attacks involving that ﬁeld are dis-
covered. As shown in Sec. 6.1, the value of ǫ may need to
diﬀer from one ﬁeld to another. The magnitude of ǫ needed
for a ﬁeld will be correlated with the variation of that ﬁeld
and the number of queries over which protection needs to be
provided, since as the number of queries grow, presumably
so might d∗ (between the actual ﬁeld values and another
from which it should remain indistinguishable).
Utility limitations. As the number of procfs queries
grows, the amount of noise added to the kernel data-structure
ﬁelds used to generate the procfs outputs grows (see Sec. 4.3
and Sec. 5.1). As such, the utility of procfs outputs gener-
ated from those ﬁelds will decay. To slow this decay, it may
be necessary to rate-limit the queries that involve each ﬁeld
or to limit the number of such queries from any one user. Or,
as suggested in Sec. 5.1, a separate privfs_struct could be
maintained per querying user, though that obviously weak-
ens the mechanism against colluding users.
It may eventually be necessary to “reset” the d∗-private
mechanism associated with a ﬁeld, particularly for a ﬁeld
associated with a long-running process. A natural way to
do so would be to restart the process itself, since restarting
a process also refreshes its associated kernel data structures.
(This is also beneﬁcial for performance and reliability [15].)
Extensions to other storage side channels. We be-
lieve our proposed method can be extended to other storage
side channels such as those associated with mobile sensors
(e.g., [10, 30, 43, 11, 6, 33, 39]). However, it is unclear how
1591adding noise, e.g., to smartphone gyroscopes, will aﬀect the
usability of the apps that rely on their readings.
Alternative solutions to procfs side channels. An al-
ternative to adding noise in procfs outputs is to isolate mu-
tually distrusting processes into diﬀerent namespaces so that
they cannot read each others’ private procfs ﬁles. For ex-
ample, Linux containers7 isolate multiple applications from
each other using PID namespaces in the kernel. While useful
in hosting services such as modern PaaS clouds, Linux con-
tainers are less suitable in personal computing environments
(e.g., Android devices and desktop computers) since shar-
ing between diﬀerent software applications are necessary in
these single-user settings. Without a shared procfs, appli-
cations that needs accesses to these system statistics—e.g.,
most traﬃc- and system-monitoring apps on Google Play,
as well as the sysstat utilities8—will no longer work.
8. CONCLUSION
In this paper we have reported on the design, implemen-
tation, and evaluation of dpprocfs, a modiﬁcation to the
procfs pseudo ﬁle system that suppresses storage side chan-
nels. The innovations that are central to our design include:
(i) framing the side-channel problem as one of achieving d-
privacy for continual data release, and deﬁning an appropri-
ate distance d∗ for instantiating d-privacy for this scenario;
(ii) generalizing a diﬀerentially private mechanism for the
continuous release of binary values to the d∗-privacy goal
we set forth; (iii) recognition of the systems diﬃculties that
can arise when adding noise to procfs outputs, and an in-
variant reestablishment framework to address those diﬃcul-
ties; and (iv) a working implementation of dpprocfs, cou-
pled with an evaluation that shows it can simultaneously
defend against known storage side-channel attacks while re-
taining the utility of procfs for monitoring and diagnosis.
Our solution provides a conﬁgurable framework to suppress
new storage side channels as they are discovered, through
adding protection to additional kernel data-structure ﬁelds
or updating the ǫ values associated with each ﬁeld and ap-
plication. We further believe that the mechanisms we have
developed within our solution might be applicable to other
storage side channels, and we plan to explore this direction
in future work.
Acknowledgments
This work was supported in part by grant 1330599 from
the National Science Foundation. We are grateful to the
anonymous reviewers for their helpful comments.
9. REFERENCES
[1] I. Abraham, Y. Bartal, and O. Neimany. Advances in
metric embedding theory. In 38th ACM Symposium on
Theory of Computing, May 2006.
[2] G. ´Acs and C. Castelluccia. I have a DREAM!
(diﬀerentially private smart metering). In 13th
International Conference on Information Hiding, 2011.
[3] G. Acs, C. Castelluccia, and W. Lecat. Protecting
against physical resource monitoring. In 10th ACM
Workshop on Privacy in the Electronic Society, 2011.
7https://linuxcontainers.org/
8http://sebastien.godard.pagesperso-orange.fr/
[4] N. R. Adam and J. C. Worthmann. Security-control
methods for statistical databases: A comparative
study. ACM Computing Surveys, 21(4), Dec. 1989.
[5] M. E. Andr´es, N. E. Bordenabe, K. Chatzikokolakis,
and C. Palamidessi. Geo-indistinguishability:
Diﬀerential privacy for location-based systems. In
ACM Conference on Computer and Communications
Security, 2013.
[6] A. J. Aviv, B. Sapp, M. Blaze, and J. M. Smith.
Practicality of accelerometer side channels on
smartphones. In 28th Annual Computer Security
Applications Conference, 2012.
[7] M. Backes and S. Meiser. Diﬀerentially private smart