credentials, and selectively disclosing attributes when signing,
as well as signature-based revocation. Fpdaa+ can be seen as
Fpdaa extended with attributes and signature based revocations,
in the same way that F l
Realistic TPM Interfaces. Contrary to the approach of
in our deﬁnition Fpdaa+ the TPM is agnostic of
F l
daa+,
attributes, predicates or the SRL. That is, when signing it
neither explicitly sees or approves the attributes or SRL. This
reﬂects that the actual TPM interfaces do not provide any such
outputs or approvals either, and in fact, there is no practical
reason to do so and would only make the TPM interfaces more
complicated. Thus, we opted for adapting the functionality
accordingly.
daa.
Similarly, the previous UC-based deﬁnitions [9], [10], [24]
let the TPM approve both the message and basename for which
the hosts requests as signature. In this deﬁnition, the TPM is
only responsible for approving the message being signed, but
does no longer receive (and approve) the basename. Again,
this is done to better capture the actual TPM interfaces that
provide such checks only for the message.
The resulting unforgeability and non-frameability guaran-
tees are as follows. No adversary can sign a message m w.r.t.
basename bsn, attribute predicate p, and signature revocation
list SRL, if the host did not sign exactly that. If the TPM
is honest but the host is corrupt, the unforgeability is a bit
weaker, as the TPM only checks the message. Therefore,
if the TPM signed message m, the adversary is allowed to
918
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:27:02 UTC from IEEE Xplore.  Restrictions apply. 
1) Issuer Setup. On input (SETUP, sid ) from issuer I.
• Verify that sid = (I, sid
(cid:3)).
to A and wait
• Output
(SETUP, sid )
(ALG, sid , sig, ver, link, identify, ukgen) from A.
• Check that ver, link, and identify are deterministic.
• Store
and
(SETUPDONE, sid ) to I.
(sid , sig, ver, link, identify, ukgen)
for
input
output
Join
2) Join Request. On input (JOIN, sid , jsid ,Mi) from host
Hj.
• Output (JOINSTART, sid , jsid ,Mi,Hj) to A and wait for
input (JOINSTART, sid , jsid ) from A.
• Create a join session record (cid:5)jsid ,Mi,Hj,⊥, status(cid:6) with
status ← delivered.
• Abort if I is honest and a record (cid:5)Mi,∗,∗(cid:6) ∈ Members
already exists.
• Output (JOINPROCEED, sid , jsid ,Mi) to I.
3) I Join Proceed. On input (JOINPROCEED, sid , jsid , attrs)
from I, with attrs ∈ A1 × . . . × AL.
• Output (JOINCOMPLETE, sid , jsid ) to A and wait for input
(JOINCOMPLETE, sid , jsid , τ ) from A.
session record (cid:5)jsid ,Mi,Hj, status(cid:6) with
• Update
status = delivered to complete.
• If Hj is honest, set τ ← ⊥.
• Else, verify that the provided tracing trapdoor τ is eligible by
the
checking CheckTtdCorrupt(τ ) = 1.
• Insert
(JOINED, sid , jsid , attrs) to Hj.
(cid:5)Mi,Hj, τ, attrs(cid:6)
into Members and
output
Mi is corrupt.
5) Sign Proceed. On input (SIGNPROCEED, sid , ssid ) from
Mi.
• Look up record (cid:5)ssid ,Mi,Hj, m, bsn, p, SRL, σ, status(cid:6) with
status = request and update it to status ← complete.
• If I is honest, check that (cid:5)Mi,Hj,∗, attrs(cid:6) with p(attrs) = 1
exists in Members.
i,H(cid:3)
(cid:3)
(cid:3)
• For every (σ
j)
, m
i,H(cid:3)
j, τi(cid:6) ∈
j, τi,∗(cid:6) ∈ Members and (cid:5)M(cid:3)
from (cid:5)M(cid:3)
DomainKeys where identify(σ
(cid:3).
– Check that there are no two distinct τ values matching σ
– Check that no pair (τi,Mi,Hj) was found.
• Store (cid:5)σ, m, bsn,Mi,Hj, p, SRL(cid:6) in Signed and output
(SIGNATURE, sid , ssid , σ) to Hj.
(cid:3)) ∈ SRL, ﬁnd all (τi,M(cid:3)
i,H(cid:3)
,∗, τi) = 1.
(cid:3)
, m
, bsn
, bsn
(cid:3)
(cid:3)
Signed exists.
– There is a τ
Verify & Link
6) Verify. On input (VERIFY, sid , m, bsn, σ, p, RL, SRL) from
some party V.
tuples (τi,Mi,Hj) from (cid:5)Mi,Hj, τi,∗(cid:6) ∈
• Retrieve all
Members and (cid:5)Mi,Hj,∗,∗, τi(cid:6) ∈ DomainKeys where
identify(σ, m, bsn, τi) = 1. Set f ← 0 if at least one of the
following conditions hold:
– More than one τi was found.
– I is honest and no pair (τi,Mi,Hj) was found for which an
entry (cid:5)Mi,Hj,∗, attrs(cid:6) ∈ Members exists with p(attrs) =
1.
is honest but no entry (cid:5)∗, m, bsn,Mi,Hj,∗,∗(cid:6) ∈
– Mi
– Hj is honest but no entry (cid:5)∗, m, bsn,Mi,Hj, p, SRL(cid:6) ∈
Signed exists.
(cid:3) ∈ RL where identify(σ, m, bsn, τ
(cid:3)) = 1 and no
pair (τi,Mi,Hj) for an honest Hj was found.
(cid:3))
, bsn
(cid:3)
– For
, m
• If f (cid:4)= 0, set f ← ver(σ, m, bsn, p, SRL).
(cid:5)σ, m, bsn, RL, f(cid:6)
• Add
(VERIFIED, sid , f ) to V.
, bsn)
7) Link. On input (LINK, sid , σ, m, p, SRL, σ
from a party V.
• Output ⊥ to V if at least one signature (σ, m, bsn, p, SRL) or
(cid:3)
(cid:3)) is not valid (veriﬁed via the VERIFY
(σ
interface with RL = ∅).
• For each τi in Members and DomainKeys compute bi ←
i ← identify(σ
(cid:3)
identify(σ, m, bsn, τi) and b
, bsn, τi) and
do the following:
– Set f ← 0 if bi (cid:4)= b
(cid:3)
i for some i.
– Set f ← 1 if bi = b
(cid:3)
i = 1 for some i.
• If f is not deﬁned yet, set f ← link(σ, m, σ
• Output (LINK, sid , f ) to V.
to VerResults and
some matching τi
identify(σ
, τi) = 1.
and (σ
, bsn).
output
(cid:3)
(cid:3)
, m
(cid:3)
(cid:3)
, m
(cid:3)
(cid:3)
, m
(cid:3)
(cid:3)
, m
(cid:3)
(cid:3)
, m
, p
, SRL
, bsn, p
, SRL
SRL,
(cid:3)
, bsn
(cid:3)
(cid:3)
∈
(cid:3)
Sign
4) Sign Request. On input (SIGN, sid , ssid ,Mi, m, bsn, p,
SRL) from Hj with p ∈ P.
• If Hj
is honest and no entry (cid:5)Mi,Hj,∗, attrs(cid:6) with
p(attrs) = 1 exists in Members, abort.
• If Hj is corrupt, set σ ← ⊥. If Hj is honest, generate the
signature for a fresh or established key:
∈
– Retrieve
DomainKeys. If no such entry exists, set (gsk , τ ) ←
ukgen(), check CheckTtdHonest(τ ) = 1, and store
(cid:5)Mi,Hj, bsn, gsk , τ(cid:6) in DomainKeys.
– Compute signature σ ← sig(gsk , m, bsn, p, SRL), check
from (cid:5)Mi,Hj, bsn, gsk , τ(cid:6)
(gsk , τ )
– Check identify(σ, m, bsn, τ ) = 1 and that
,H(cid:3)) (cid:4)= (Mi,Hj) with tracing trapdoor τ
ver(σ, m, bsn, p, SRL) = 1.
there is no
(M(cid:3)
(cid:3) registered in
(cid:3)) = 1.
Members or DomainKeys with identify(σ, m, bsn, τ
• Create a sign session record (cid:5)ssid ,Mi,Hj, m, bsn, p, SRL, σ,
status(cid:6) with status ← request.
• Output (SIGNPROCEED, sid , ssid , m) to Mi when it
is
honest, and (SIGNPROCEED, sid , ssid , m, bsn, SRL, σ) when
Fig. 5. Our ideal DAA functionality with strong privacy Fpdaa+
919
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:27:02 UTC from IEEE Xplore.  Restrictions apply. 
corrupt TPM F l
standard
isolated
daa, F l
-
-
daa+
Fpdaa+ (this work)
-
+
Fpdaa
+
++
Fig. 6. Comparison of privacy guarantees for an honest host in the presence of
a corrupt TPM (either corrupt in the standard UC or isolated model of [24]).
the TPM explicitly approved it). A TPM performing such a
“blocking attack” to alter the signature distribution can clearly
be noticed by the host though, and thus, this attack has rather
limited impact in practice.
The main reason why exposing the signature value to the
TPM reduces the privacy guarantees stems from the way UC
models corruption: In the standard UC corruption model, the
adversary is allowed to see all inputs to the party he corrupts.
That is, he will see the signatures given for approval to the
TPM and can later re-identify the platform from the signature.
However, as Camenisch et al. [24] argue, in case of the TPM
this standard UC corruption model gives the adversary much
more power than in reality. In the real world, the TPM is
embedded inside a host who controls all communication with
the outside world,
the adversary cannot communicate
directly with the TPM but only via the (honest) host. To model
such subversion more accurately, [24] introduces isolated
corruptions, where the adversary can specify the code that
the isolated, yet subverted TPM will run, but cannot directly
interact with the isolated TPM.
i.e.,
Applying this concept of isolated corruptions to our notion
of strong privacy then yields signiﬁcantly stronger privacy
guarantees than with the standard corruption model: In signing
the adversary no longer sees the signature which is only given
to the isolated corrupt TPM. That is, when considering isolated
TPM corruptions, the only difference to the optimal privacy
notion of [24] is the aforementioned “blocking attack” which
allows a corrupt TPM to inﬂuence the signature distribution,
but with the risk of being caught by the host. Thus, w.r.t.
isolated corruption, our notion of strong privacy is almost
equivalent to optimal privacy, yet allows for signiﬁcantly more
efﬁcient instantiation. An overview of the different privacy
guarantees of this and the previous works is given in Fig. 6.
create signatures on m w.r.t. any p and SRL that hold for the
platform (i.e., the platform has the attributes to fulﬁll p and
is not revoked by SRL). The TPM does not explicitly approve
bsn, but we force the (possibly corrupt) host to choose one
bsn when signing, and signatures can only be valid if the
message-basename combination was signed. Because the TPM
does not explicitly approve the basename, our unforgeability
with an honest TPM and corrupt host is slightly weaker than
previous UC-based deﬁnitions [9], [10], [24] where the TPM
must explicitly approve the basename.
is honest but
When the host
the TPM is corrupt, our
deﬁnition also assures unforgeability and non-frameability like
Fpdaa, which provides stronger guarantees than [9] and [10],
where both properties are not ensured when the TPM is
corrupt.
Strong Privacy (vs. Optimal Privacy). Previous DAA
schemes and deﬁnitions condition their privacy property on the
honesty of the entire platform, i.e., as soon as either the TPM
or host is corrupt, no privacy is guaranteed anymore. Whereas
the honesty of the host is indeed necessary (a corrupt host can
always break privacy by outputting identifying information),
relying on the honesty of the TPM as well is an unnecessarily
strong assumption. In fact, it even contradicts the original goal
of DAA, namely to provide anonymous attestations without
having to trust the hardware. This mismatch was recently
discussed by Camenisch et al. [24] who propose the notion
of DAA with optimal privacy which must hold even in the
presence of corrupted or subverted TPMs. In contrast
to
daa and F l
F l
daa+ where the adversary provides the signature
whenever the host or TPM are corrupt, the functionality with
optimal privacy Fpdaa outputs anonymous signatures as long
as the host is honest. As the signatures are given directly to
the host, the adversary learns nothing about them, even if the
TPM is corrupt.
Unfortunately, the authors also show that optimal privacy
cannot be achieved using constructions where the TPM and
host together create a Fiat-Shamir proof of knowledge, which
rules out the most efﬁcient DAA schemes. The DAA protocol
with optimal privacy proposed in [24] comes with a signiﬁcant
re-design, shifting most of the computations from the TPM
to the host and would also require new operations to be
implemented on the TPM.
The goal of this work is to obtain the best privacy properties
with as minimal changes to the existing TPM and DAA
speciﬁcations as possible. We therefore relax their notion of
optimal privacy, and show how this can be achieved with
modest modiﬁcations to the current DAA speciﬁcations and
using our proposed TPM interfaces. Roughly, our new privacy
notion – which we term strong privacy – allows the TPM to see
the anonymous signature that is generated by the functionality
and consequently also condition its behavior on the signature
value. Thus, while the actual signature shown to the TPM
is still guaranteed to be anonymous, the TPM can inﬂuence
the ﬁnal distribution of the signatures by blocking certain
signature values (a signature is only output to the host when
920
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:27:02 UTC from IEEE Xplore.  Restrictions apply.