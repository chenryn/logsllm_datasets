with strictly local information. For example, in a broadcast
tree, a fault can potentially lead to reordering of messages,
which violates the required total order. However, a processor
that receives two messages out-of-order cannot detect that
reordering has occurred without obtaining information from
other nodes (e.g., comparing the order of message reception
with other nodes).
7  Evaluation
We evaluate an SMP that performs both signature analy-
sis checks just developed and invokes SafetyNet BER if
either check fails. Since we cannot build a modern SMP, we
evaluate our design with simulation. We present our simula-
tion methodology [2], benchmarks, and results.
7.1  Simulation Methodology
We simulate a 16-node (P=16, N=32) target system with
the Simics full-system, multiprocessor, functional simulator
[12], and we extend Simics with a memory hierarchy simula-
tor to compute execution times. Each node in our modern
SMP consists of a processor, two levels of cache, cache con-
troller, some portion of the shared memory, memory control-
ler, and a network interface.
Simics. Simics is a system-level architectural simulator
developed by Virtutech AB. We use Simics/sun4u, which
simulates Sun Microsystems’s SPARC V9 platform architec-
ture (e.g., used for Sun E6000s) in sufﬁcient detail to boot
unmodiﬁed Solaris 8. Simics is a functional simulator only,
and it assumes that each instruction takes one cycle to exe-
cute (although I/O may take longer), but it provides an inter-
face to support detailed memory hierarchy simulation.
Processor Model. We use Simics to model a processor core
that, given a perfect memory system, would execute four bil-
lion instructions per second and generate blocking requests
to the cache hierarchy and beyond. We use this simple pro-
cessor model to enable tractable simulation times for full-
system simulation of commercial workloads. While an out-
of-order processor model might affect the absolute values of
the results, it would not qualitatively change them (e.g.,
whether an error is detected).
Memory Model. We have implemented a memory hierarchy
simulator that supports the MOSI broadcast snooping cache
coherence protocol. The simulator captures all state transi-
tions (including transient states) of our coherence protocol in
the cache and memory controllers. We model the intercon-
nection network and the contention within it, including the
small additional contention due to SafetyNet messages. In
Table 2, we present the design parameters of our target mem-
ory system. With a checkpoint interval, Tc, of 300 broadcast
coherence requests and four outstanding checkpoints,
SafetyNet can tolerate fault detection latencies that are
greater than the latency for global communication.
SafetyNet. Our memory system simulator models the details
of the SafetyNet support for checkpoint/recovery. For evalu-
ating overhead for checkpointing register state, we model a
conservative latency of 100 cycles. We conservatively charge
eight cycles for logging store overwrites (8 bytes/cycle for
64 byte cache blocks), but these are only about 0.1% of
instructions.
We integrate the global reduction of the local signatures
with the existing mechanism for validating checkpoints in
SafetyNet. For each checkpoint that a cache or memory con-
troller agrees to validate, it computes both signatures based
on the Tc coherence requests (i.e., address messages) it pro-
cessed in that checkpoint interval and sends these signatures
to the system service processor (i.e., a central controller
often found in servers, such as the Sun E10000 [6]). The ser-
vice processor performs the checks CCL and CML.7 If the
checks detect no errors (i.e., CCL=CML=false), it completes
the validation by notifying every node. Otherwise, it triggers
a system recovery.
7.2  Workloads
Commercial applications are an important workload for
high availability systems. As such, we evaluate our system
with four commercial applications and one scientiﬁc applica-
tion, described brieﬂy in Table 3 and in more detail by
Alameldeen et al. [2]. Using a methodology described by
Alameldeen et al. [2] to address the variability in runtimes
for commercial workloads, we simulate each design point
multiple times with small, pseudo-random perturbations of
memory latencies to cause alternative scheduling paths and
provide statistically meaningful results. Error bars in our
performance results represent one standard deviation in each
direction from the mean.
7.3  Results
In this section, we present the results of our experiments
with the two end-to-end invariant checkers used in parallel.
We injected errors into the system (at an absurdly high rate)
and observed their impact on the system. The only quantita-
tive results concern the performance impact of invariant
7.
In the original SafetyNet paper, a coherence controller sent a “blank”
message to the service processor to indicate that it had validated a check-
point. Here, we add two signatures as a payload to that message.
Proceedings of the 2003 International Conference on Dependable Systems and Networks (DSN’03) 
0-7695-1959-8/03 $17.00 (c) 2003 IEEE
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 07:12:52 UTC from IEEE Xplore.  Restrictions apply. 
TABLE 3. Workloads
OLTP: Our OLTP workload is based on the TPC-C v3.0 benchmark using IBM’s DB2 v7.2 EEE database management system. We use
a 1 GB 10-warehouse database stored on ﬁve raw disks and an additional dedicated database log disk. There are 8 simulated users per
processor. We warm up for 10,000 transactions, and we run for 500 transactions.
Java Server: SPECjbb2000 is a server-side java benchmark that models a 3-tier system with driver threads. We used Sun’s HotSpot
1.4.0 Server JVM. Our experiments use 24 threads and 24 warehouses (~500 MB of data). We warm up for 100,000 transactions, and we
run for 50,000 transactions.
Static Web Server: We use Apache 1.3.19 (www.apache.org) for SPARC/Solaris 8, conﬁgured to use pthread locks and minimal log-
ging as the web server. We use SURGE to generate web requests. We use a repository of 2,000 ﬁles (totalling ~50 MB). There are 10
simulated users per processor. We warm up for ~80,000 requests, and we run for 5000 requests.
Dynamic Web Server: Slashcode is based on a dynamic web message posting system used by slashdot.com. We use Slashcode 2.0,
Apache 1.3.20, and Apache’s mod_perl 1.25 module for the web server. MySQL 3.23.39 is the database engine. The database is a snap-
shot of slashcode.com, and it contains ~3,000 messages. A multithreaded driver simulates browsing and posting behavior for 3 users
per processor. We warm up for 240 transactions, and we run for 50 transactions.
Scientiﬁc Application: We use barnes-hut from the SPLASH-2 suite [17], with the 16K body input set. We measure from the start of
the parallel phase to avoid measuring thread forking.
e
c
n
a
m
r
o
f
r
e
p
d
e
z
i
l
a
m
r
o
n
1.0
0.5
0.0
error-free
1 error per second
10 errors per second
100 errors per second
jbb
apache
slashcode
oltp
barnes
FIGURE 5. Performance as a function of error rate
checking. As would be expected from results shown in Sorin
et al. [16], the performance degradation caused by SafetyNet
overhead is low. Remarkably, as shown in Figure 5, the per-
formance impact even in the presence of ten errors (i.e., ten
system recoveries) per second is low for all benchmarks.
Coherence-level Checking. We injected errors into the sys-
tem, including dropped messages and incorrectly processed
messages, and the signature analysis indeed detected all of
these errors. This signature analysis scheme can detect errors
that are difﬁcult or impossible to detect with localized error
detection schemes. If a Shared node processed an incoming
RequestForExclusive from another node but did not invali-
date its copy of the block, then the system can violate both
cache coherence and memory consistency.
Message-Level Checking. To test the ability of this checker
to detect errors in this error model, we periodically dropped
and reordered messages. The signature analysis scheme suc-
cessfully detected the errors and triggered SafetyNet recov-
eries of the system. This signature analysis scheme also can
detect some errors that are difﬁcult to detect with localized
error detection schemes. Most notably, it is difﬁcult to detect
in a broadcast snooping system if the interconnect errone-
ously reorders two broadcast requests that it delivers to a
given node.
8  Related Work
Prior research has explored dynamic veriﬁcation at differ-
ent levels. At the intra-processor level, DIVA [3] adds a sim-
ple, provably correct checker core that dynamically veriﬁes
the aggressively designed core. DIVA can detect device
errors in either core and design errors in the aggressive core,
but it limits itself to the processor. The Thinking Machines
CM-5 [11] dynamically computed a variant of Kirchoff’s
Current Law (i.e., inﬂow of messages equals outﬂow of mes-
sages) to determine when all messages had been delivered.
Cantin et al. propose a scheme for dynamically verify snoop-
ing cache coherence protocols [5]. This scheme uses a vali-
dation bus, and a node that changes coherence state
broadcasts its new state on this bus so that other nodes can
Proceedings of the 2003 International Conference on Dependable Systems and Networks (DSN’03) 
0-7695-1959-8/03 $17.00 (c) 2003 IEEE
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 07:12:52 UTC from IEEE Xplore.  Restrictions apply. 
check that their states are compatible. This scheme, however,
requires manual construction of the checker protocol and
signiﬁcant extra bandwidth for validation, and it does not
provide a way to integrate it with a recovery mechanism.
Cain and Lipasti propose an algorithm based on vector
clocks for dynamically verifying sequential consistency, but
they leave for future work the issues of implementation and
integration of the algorithm with a checkpoint/recovery
mechanism [4].
9  Conclusions
In this paper, we have argued for dynamic veriﬁcation of
end-to-end, system-wide invariants in shared memory multi-
processors. We have developed two signature analysis
schemes for detecting violations of system-wide invariants,
and we have used full-system simulation to demonstrate that
they detect the targeted errors while not degrading system
performance. The viability of dynamic veriﬁcation of end-
to-end invariants, in conjunction with backward error recov-
ery, enables improved system availability.
While this work applies the end-to-end argument
to
encompass SMP coherence protocols and interconnects,
future work can seek end-to-end approaches that encompass
complete SMP hardware (e.g., by integrating processor
dynamic veriﬁcation [3]) or even software. Future work will
also address the issue of fault diagnosis.
Acknowledgments
We thank Alvy Lebeck, Milo Martin, the Duke Systems
Group, and the Wisconsin Multifacet Group for helpful dis-
cussions of this research. We thank Trey Cain and Jason
Cantin for feedback on the ﬁnal draft.
This work is supported in part by the National Science
Foundation, with grants EIA-9971256, CCR-0105721, and
EIA-0205286, an Intel Fellowship (Sorin), a Warren Faculty
Scholarship (Sorin), two Wisconsin Romnes Fellowships
(Hill and Wood), Universitat Politècnica de Catalunya and
Secretaría de Estado de Educación y Universidades de
España (Hill sabbatical), and donations from IBM, Intel,
Microsoft, and Sun.
References
[1] Miron Abramovici, Melvin A. Breuer,
and Arthur D.
Friedman. Digital Systems Testing and Testable Design. IEEE
Press, 1990.
[2] Alaa R. Alameldeen, Milo M.K. Martin, Carl J. Mauer,
Kevin E. Moore, Min Xu, Daniel J. Sorin, Mark D. Hill, and
David A. Wood. Simulating a $2M Commercial Server on a
$2K PC. IEEE Computer, 36(2), February 2003.
[3] Todd M. Austin. DIVA: A Reliable Substrate for Deep
Submicron Microarchitecture Design. In Proceedings of the
32nd Annual
IEEE/ACM International Symposium on
Microarchitecture, pages 196–207, November 1999.
[4] Harold W. Cain and Mikko H. Lipasti. Verifying Sequential
Consistency Using Vector Clocks. In Revue in conjunction
with Symposium on Parallel Algorithms and Architectures,
August 2002.
J. F. Cantin, M. H. Lipasti, and J. E. Smith. Dynamic
Verification of Cache Coherence Protocols. In Workshop on
Memory Performance Issues, June 2001. In conjunction with
ISCA.
[5]
[6] Alan Charlesworth. Starfire: Extending the SMP Envelope.
IEEE Micro, 18(1):39–49, Jan/Feb 1998.
[7] David E. Culler
J.P. Singh. Parallel Computer
Architecture: A Hardware/Software Approach. Morgan
Kaufmann Publishers, Inc., 1999.
and
[8] E.N. Elnozahy, D.B. Johnson, and Y.M. Wang. A Survey of
Rollback-Recovery Protocols in Message-Passing Systems.
Technical Report CMU-CS-96-181, Department of Computer
Science, Carnegie Mellon University, September 1996.
[9] E.N. Elnozahy and W. Zwaenepoel. Manetho: Transparent
Rollback-Recovery with Low Overhead, Limited Rollback,
and Fast Output Commit. IEEE Transactions on Computers,
41(5):526–531, May 1992.
[10] S. W. Golumb. Shift Register Sequences. Aegean Park Press,
revised edition, 1982.
[11] Charles E. Leiserson et al. The Network Architecture of the
Connection Machine CM-5. In Proceedings of the Fourth
ACM Symposium on Parallel Algorithms and Architectures,
pages 272–285, June 1992.
[12] Peter S. Magnusson et al. Simics: A Full System Simulation
Platform. IEEE Computer, 35(2):50–58, February 2002.
[13] J. H. Saltzer, D. P. Reed, and D. D. Clark. End-to-End
in Systems Design. ACM Transactions on
Arguments
Computer Systems, 2(4):277–288, November 1984.
[14] Ashok Singhal et al. Gigaplane: A High Performance Bus for
Interconnects
In Proceedings of 4th Hot
Large SMPs.
Symposium, pages 41–52, August 1996.
[15] Daniel J. Sorin. Using Lightweight Checkpoint/Recovery to
Improve the Availability and Designability of Shared Memory
Multiprocessors. PhD thesis, University of Wisconsin, August
2002.
[16] Daniel J. Sorin, Milo M.K. Martin, Mark D. Hill, and David A.
Wood. SafetyNet:
Improving the Availability of Shared
Memory Multiprocessors with Global Checkpoint/Recovery.
In Proceedings of the 29th Annual International Symposium on
Computer Architecture, pages 123–134, May 2002.
[17] Steven Cameron Woo, Moriyoshi Ohara, Evan Torrie,
Jaswinder Pal Singh, and Anoop Gupta. The SPLASH-2
Programs:
Methodological
Considerations.
the 22nd Annual
International Symposium on Computer Architecture, pages
24–37, June 1995.
In Proceedings of
Characterization
and
Proceedings of the 2003 International Conference on Dependable Systems and Networks (DSN’03) 
0-7695-1959-8/03 $17.00 (c) 2003 IEEE
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 07:12:52 UTC from IEEE Xplore.  Restrictions apply.