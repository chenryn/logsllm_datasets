title:Making Secure TCP Connections Resistant to Server Failures
author:Hailin Wu and
Andrew Burt and
Ramki Thurimella
Making Secure TCP Connections Resistant to Server Failures 
Hailin Wu,   Andrew Burt,   Ramki Thurimella 
Department of Computer Science 
University of Denver 
Denver, CO 80208, USA 
{hwu, aburt, ramki}@cs.du.edu 
Abstract
failover  mechanism  described 
Methods  are  presented  to  increase  resiliency  to  server 
failures  by  migrating  long  running,  secure  TCP-based 
connections  to  backup  servers,  thus  mitigating  damage 
from  servers  disabled  by  attacks  or  accidental  failures. 
The 
is  completely 
transparent  to  the  client.  Using  these  techniques,  simple, 
practical  systems  can  be  built  that  can  be  retrofitted  into 
the  existing  infrastructure,  i.e.  without  requiring  changes 
either to the TCP/IP protocol, or to the client system. The 
end  result  is  a  drop-in  method  of  adding  significant 
robustness  to  secure  network  connections  such  as  those 
using the secure shell  protocol (SSH). As there is a large 
installed  universe  of  TCP-based  user  agent  software,  it 
will be some time before widespread adoption takes place 
of  other  approaches  designed  to  withstand  these  kind  of 
service failures; our methods provide an immediate way to 
enhance  reliability,  and  thus resistance  to  attack,  without 
having to wait for clients to upgrade software at their end. 
The practical viability of our approach is demonstrated by 
providing  details  of  a  system  we  have  built  that  satisfies 
these requirements. 
1.  Introduction 
TCP is neither secure nor can withstand server failures 
due  to  malevolent  intrusion,  system  crashes,  or  network 
card  failures.  Nonetheless,  today’s  information  assurance 
requirements  demand  building  software,  networks  and 
servers  that  are  resistant  to  attacks  and  failures.    While 
individual  connections  can  be  made  secure 
from 
eavesdropping  or  alteration  by  such  protocols  as  the 
Secure Shell protocol (SSH), the server that provides these 
services  continues  to  be  a  single  point  of  failure.    This  is 
an  artifact  of  TCP’s  original  design,  which  assumed 
connections  should  be  aborted  if  either  endpoint  is  lost.  
That  TCP  also  lacks  any  means  of  migrating  connections 
implies 
to  relocate 
connections to a backup server.  Thus any secure software 
built on top of TCP inherits the vulnerability of the single 
server as a point of failure.Combining TCP with a mix of 
public key and symmetric key encryption such as SSH or 
inherent  way 
that 
there 
is  no 
SSL  addresses  the  protocol’s  general  security  deficiency. 
In  this  paper  we  extend  these  methods  to  increase  the 
resiliency  of  secure  connections  to  tackle  server  failures. 
Specifically,  we  show  practical  ways  to  migrate  active 
SSH connections to backup servers that do not require any 
alterations  to  client-side  software,  including  their  client 
application software, operating systems, or network stacks, 
thus making this solution immediately deployable.  These 
techniques  are  general  and  can  be  employed  for  other 
forms  of  secure  connections,  such  as  SSL,  which  is  our 
next research goal. 
Recently,  the  authors  [4]  presented  techniques  to 
migrate open TCP connections in a client-transparent way 
using  a  system  called  Jeebs  (Jeebs,  from  the  film  Men  in 
Black,  being  the  alien  masquerading  as  a  human  who, 
when his head is blown off, grows a new head). Using this 
system,  it  is  possible  to  make  a  range  of  TCP-based 
network  services  such  as  HTTP,  SMTP,  FTP,  and  Telnet 
fault tolerant. Jeebs has been demonstrated to recover TCP 
sessions 
from  all  combinations  of  Linux/Windows 
clients/servers. 
The  results  in  this  paper  are  a  natural  extension  of  the 
recent results on TCP migration [4] to secure connections, 
with which the ordinary Jeebs implementation is unable to 
cope  because  of  the  very  nature  of  their  security.  Our 
implementation  for  secure  connections,  SecureJeebs, 
consists of making simple, modular and secure extensions 
to  the  SSH  software  and  placing  a  "black  box"  on  the 
server's  subnet  to  monitor  all  TCP  connections  for  the 
specified  server  hosts  and  services,  detect  loss  of  service, 
and  recover  the  TCP  connections  before  the  clients'  TCP 
stacks are aware of any difficulty.  
While  great  strides  have  been  made  in  providing 
redundancy of network components such as load balancing 
switches  and  routers,  and  in  proprietary  applications  such 
as  used  in  database  servers,  a  missing  component  in  end-
to-end  fault  tolerance  has  been  the  inability  to  migrate 
open  TCP  connections  across  server  failures.    Although 
neither  these  products  nor  SecureJeebs  provide  reliability 
if  the  whole  cluster  providing  the  service  were  to  be 
involved in catastrophe such as an earthquake or fire, or if 
network  components  that  are  on  the  path  of  service  were 
to fail, SecureJeebs eliminates servers as a single point of 
Proceedings of the 19th Annual Computer Security Applications Conference (ACSAC 2003) 
1063-9527/03 $17.00 © 2003 IEEE
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 07:51:08 UTC from IEEE Xplore.  Restrictions apply. 
failures. SecureJeebs  is  further  distinguished from  load 
balancing and other techniques in that it transparently and
securely  migrates  secure  connections  that  are  in  progress.
This feature  permits SecureJeebs to  be  used not  only  to
enhance reliability  of unreliable  servers, but  also  to  take
production  servers  offline for scheduled  maintenance
without disrupting the existing connections.
Following  an  overview  in  Section  2  and  discussion  of
related  work in  Section  3,  we  describe  the  necessary
background  in  section  4  and  present our  techniques  and
the  architecture  of  Jeebs  in  Section  5.  We present  a 
performance analysis in Section 6 and concluding remarks
in Section 7.
2.  Overview
2.1.  Migration
Recovering TCP sessions that are about to abort due to
loss of the server requires two components:  (1) A monitor,
to record pertinent information about existing connections
and  detect  their  imminent  demise;  and  (2) a  recovery
system that can perform emergency reconnection to a new
server  that  will  take  over  the  connection.
Each  is 
described briefly below.
Port 22 
IP 1
SSH Server 
in 
the 
literature 
the  monitor observes 
unacknowledged data,  and any  prior data  that  may  be 
required for  recovery purposes  (such as  initial  requests).
Further, 
the  health  of  each 
connection  to detect  imminent  failure.  Health  monitoring
and  server  crash  detection  use  standard  techniques  as
described elsewhere 
[3,  6,  12].
SecureJeebs  is  installed on  the  server’s  subnet  to  monitor
and recover connections,  thus  is  currently  limited  to
recovering what appear to be local server crashes. Packets
are  logged  at  the  TCP  level by  a  sniffer,  thus potentially
suffering from missed  packets,  though mitigating  this
deficiency  has  been  addressed  in [4].   Recovery of  TCP
state  is  handled via  a  passive  recovery daemon  on  a
monitoring  server,  and  application state  is migrated using
simple, per-protocol  recovery modules  described  briefly
here and fully  in  [4].    Connections  are  recovered  to  a 
backup  server  (which  may  co-exist  with  the  recovery
server or be a separate system on the subnet) as shown in
the figures below.
When an IP number is deemed in need of migration, all 
connections  to  that  server  are restored by  the  recovery
system.  The recovery system takes over the IP number of
the  designated  server  and  initiates  recovery of  each
connection.  Connection state is restored using simple per-
service recovery  procedures.    There  are  three  styles  of 
Crashed
IP 1
SSH Server 
Client 1 
Client 2 
Client 3 
Secure Jeebs
Client 1 
Secure Jeebs
IP 2
Monitor
IP 3 
Recovery Server
DB
Client 2 
Client 3 
IP 2
Monitor
Port 22 
IP 1  Recovery Server
DB
Replay
Client
Before Server Crash
After Server Crash
Figure  1.  Illustration  of  Secure  Jeebs.  Monitor  detects  server  crash  and  starts  recovery
server and replay client. After CPR ends, all the original sessions are recovered.
The monitor operates by logging traffic from the server 
host it is watching.  The granularity of recovery is at the IP
number level. The monitor can be further selected to only
watch  certain  ports, but  since  the  entire  IP  number  is
migrated  to  a  new  server, all  ports on  that  IP number
should be monitored in practice (However, since virtual IP
numbers  are used  in  practice,  specific  services  can be
isolated so that they are the only services using a given IP
number. Thus individual services can be migrated if they
are  the  only  services  using  that virtual  IP  number).
Logging 
information,
the  TCP 
includes 
state 
recovery:   Standalone, where  a  new piece  of  software  is
written  specifically  to handle  connections  in  progress
(with new connection requests being serviced by a copy of
the original daemon for that service); Integrated, where the
existing service  daemon  on  the  recovery  system  is 
modified to understand how to adopt stranded connections
(in addition to handling new requests); and Proxy, where a
small, programmable daemon interposes itself between the
client  and  a  backup  copy  of the  original  service  daemon,
such  that  it  can  replay  the  necessary  parts of  the  original 
connection  to bring  the  new  server  up  to the point  the
original  server  failed,  then  acts  in  a  pass-through  mode
Proceedings of the 19th Annual Computer Security Applications Conference (ACSAC 2003) 
1063-9527/03 $17.00 © 2003 IEEE
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 07:51:08 UTC from IEEE Xplore.  Restrictions apply. 
while the new server finishes the connection. Session keys 
and  other  sensitive  data  needed  to  ensure  the  integrity  of 
secure  connections  are  likewise  migrated  in  a  secure 
manner as described in detail in section 5. 
involved 
The  difficulties 
in  migrating  a  secure 
connection  such  as  SSH  primarily  arise  from  exporting 
and 
importing  various  session  keys  securely  and 
efficiently,  and  making  the  state  of  the  cipher  consistent.  
In  addition,  such  protocols  are  specifically  designed  to 
prevent  various  attacks  such  as  man-in-the-middle  or 
replay  attacks.    We  have  overcome  these  obstacles  and 
devised  several  efficient,  secure  and  reliable  migration 
mechanisms  which  are  successfully  implemented  in  our 
testbed.  Figure 1 illustrates one such approach: Controlled 
Partial Replay (CPR). 
2.2.  Preserving Security 
It 
is  always  a 
legitimate  concern  whether  a 
modification to a secure protocol such as SSH weakens the 
original security. We argue that the methods proposed here 
are sound from this perspective. 
First  of  all,  as  explained  in  detail  in  section  5,  the 
changes  we  make  are  all  client-transparent  protocol-level 
changes  that  are  consistent  with  the  regular  operation  of 
SSH. The main changes are to the key exchange phase on 
the  server  side:  we  export  several  entities  so  that  if  there 
were  to  be  a  failure,  the  recovery  server  can  recreate  the 
original  session.  The  exported  entities  include  client’s 
payload  of  SSH_MSG_KEXINIT  message,  prime  p,  and 
generator for subgroup g, server’s exchange value f and its 
host  key.    The  export  operation  is  independent  of  the 
regular behavior of SSH server, in other words, it does not 
interfere  with  the  normal  packet  exchange  between  client 
and  server  at  all,  thus  it  does  not  open  new  holes  within 
the transport layer or connection protocols. 
Secondly,  all  the  entities  for  export,  including  those 
mentioned  above,  the  last  block  of  cipher  text  (details  in 
5.3.1),  and  message  sequence  number  (details  in  5.3.2), 
are encrypted using the recovery server’s public host key. 
In  addition,  a  message  digest  is  appended  for  integrity 
check, and we further provide non-repudiation by signing 
the message digest using the original server’s private key. 
With  these  measures,  only  the  recovery  server  can 
successfully  decrypt  these  quantities  with  the  assurance 
that  they  are  from  the  original  server  and  not  tampered 
with during the export/import process. 
Thirdly,  access  control  is  in  place  to  make  sure  that 