## Page 318
292
第7章：Perl
288页已经提到，正则文字被解析成“表示正则含义的双引1号字符审”。如果用单引号
作分隔符，就无法使用这些功能。使用m…·时就不会进行变量插值，实时修改文本
的结构（比如\Q\E）不会生效，\N()也无法使用。也许在使用包含多个@的正则
表达式时m.·很有价值，因为这样可以不需要转义。
如果进行match操作，而分隔符是斜线或者问号，可以省略m，也就是：
$text=~m/*"/;
$text=~/……/;
是等价的。但我更喜欢明确写上m。
正则文字的解析方式
HowRegex LiteralsAreParsed
大多数情况下，如果用户“只会用到”上文讲解的正则文字特性，就不需要理解Perl将它
们转换为真正的正则表达式的具体细节。就这一点来说，Perl直观性非常方便，但是许多时
候，了解细节并无坏处。下面列出了各种处理的顺序：
1.找到结束分隔符，读入修饰符（例如/i之类）。下面的处理就能判断是否采用了/x之类
的模式。
2.变量插值。
3.如果使用了正则表达式重载，正则文字的每个部分都会交给重载子程序来处理。各部分
由插值变量分隔；插入的值是无法重载的。
如果正则表达式没有进行重载，处理\N（）。
4.应用大小写转换结构（例如\QE）。
5.把结果提交给正则引擎。
以上是程序员眼中的处理，但是Perl内部的处理其实是很复杂的。单单是第二步，就必须
识别正则表达式的元字符，比如不应把'thisSthat$：下画线的那部分识别为变量。
正则修饰符
RegexModifiers
Perl的正则运算符容许在正则文字的结束分隔符之后添加正则修饰符（例如m//i、s/
/1和qr/…/i中的i)。所有运算符都支持的核心修饰符一共有5种，详见表7-3。
头四种在第3章已经介绍过，它们能够作为模式修饰符（?135）或者范围模式修饰符
（135），在正则表达式之中使用。如果正则表达式内部出现了修饰符，match运算符也用
制
---
## Page 319
正则表达式相关的Perl教义
293
表7-3：所有正则运算符可用到的核心修饰符
/i
110
进行忽略大小写的匹配
/x
o111
宽松排列和注释模式
/s
111
点号通配模式
/m
112
增强的行锚点模式
/o
348
仅编译一次
到了修饰符，则正则表达式内部的修饰符的优先级更高（从另一方面来说就是，一旦修饰
符应用到正则表达式内部的某些元素，这些元素就不再受其他修饰符的影响）。
第五个核心修饰符/o，与效率有很大的关系。此问题从第348页开始讨论。
如果需要使用多个修饰符，只需要把它们并排列在结束分隔符之后即可，排列的顺序是无
关紧要的（注3）。请注意，斜线本身不是修饰符，你可以使用m//1、mlli，
或是m{}i，甚至是m>i。不过在讲解修饰符时，通行的做法是加上-个
斜线，例如“修饰符/i”。
正则表达式相关的Perl教义
Regex-Related Perlisms
学习正则表达式，还需要掌握许多一一般的Perl概念。下面几节的内容包括：
应用场合（context）Perl的重要概念之一就是，许多函数和运算符在不同应用场合有
不同的意义。例如，Perl的while循环希望接收一个纯量值（scalarvalue）作为判断
条件，但对于print语句希望接收组值（alistofvalue）。因为Perl容许表达式对其应
用场合进行“响应”（respond），同样的表达式在不同的应用场合可能得到截然不同的
结果。
动态作用域（dynamicscope）大多数编程语言都支持本地变量和全局变量，但是Perl
还提供了另一种复杂功能，称为动态作用域。动态作用域会临时“保护”全局变量，
保存一份副本，稍后自动恢复。这个复杂的概念对我们来说很重要，因为它影响到S1
和其他的匹配相关变量。
注3：因为修饰符可以以任意形式出现、程序员通常会花很多精力调整修饰符，让它们看上去最
顺眼。learn/by/osmosis是没问题的（假设函数名是learn)，其中的修饰符是osmosis。
修饰符可以重复出现，但这没有意义（稍后讨论的替换运算符的/e是个例外）。
---
## Page 320
294
第7章：Perl
表达式应用场合
Expression Context
contexr对Perl来说是很重要的概念，尤其对match运算符来说更是如此。一个表达式可能
出现在三种context中：序列（list）、纯量值（scalar）或者空（void），它们表示表达式期望
接收的参数类型。所以，listcontexr说明表达式期望获得一个序列。scalarcontexr说明表达
式期望获得单个值。以上两者极为常见，而且对使用正则表达式非常有价值。voidcontexi
说明不期望获得任何值。
看下面两个赋值：
Ss=expression one;
a =expression two;
因为Ss是scalar变量（它用来保存单个的值，而不是序列），期望简单的纯量值，所以第-一
个表达式的应用场合为scalarcontext。同样，因为@a是一个数组，期望获得一个list，第二
个表达式的应用场合为listcontext。即使这两个表达式完全等价，也可能返回完全不同的结
果，产生不同的影响。具体情况依表达式而定。
举例来说，localtime函数如果用在listcontext中，会返回一组值，表示当前年、月、日、
时。但如果用在scalarcontext中，则返回文本类型的当前时间，比如‘MonJan2022：05：15
2003'。
另一个例子是之类的IO运算符，在scalarcontext中，它返回文件的下一行，但
是在listcontext中，返回所有（剩下的）行。
就像1ocaltime和I/O运算符一样，许多Perl的结构会根据应用场合的不同返回不同的值，
正则运算符同样如此。拿match运算符m/./来说，有时候它会简单地返回true/false值，
有时候返回一组匹配结果。所有的细节都会在本章讲解。
强转正则表达式
不是所有的正则表达式天生都能区分场合的，所以，如果某个应用场合中正则表达式无法
提供期望的返回类型，就要按照Perl的规定处理。为了把方桩插入圆孔，Perl会“强转
(contort）”这个值。如果在listcontext中返回的是scalar值，Perl会生成只包含单个元素
的list。这样@a=42就等于ea=（42）。
---
## Page 321
正则表达式相关的Perl教义
295
另一方面，把list转换为scalar却没有统一的规定。如果程序是这样：
Svar =（$this, &is,0xA,'list');
逗号运算符返回最后的元素‘list’给Svar。如果给定的是一个数组，例如$var=@array，
则返回数组的长度。
其他语言用不同的术语描述这种处理，例如修正（cast）、提示（promote）、强制转换（coerce）
或转换（convert)，但是我认为这些词都已经具有了自己的意义（有点令人讨厌），不适合
描述Perl的做法，所以我使用“强转（contort）”。
动态作用域及正则匹配效应
DynamicScopeandRegexMatch Effects
Perl的变量分为两类（全局变量和私有变量)，动态作用域是正确理解它们的重点，研究正
则表达式时也需要关注此概念，因为它关系到匹配完成之后信息如何使用。下一节介绍了
这些概念及其与正则表达式的关系。
全局和私有变量
总的来说，Perl提供了两种变量：全局的和私有的。私有变量使用my（·)来声明，全局变
量不需要声明，在使用时会自动出现。全局变量通常在程序的任何地方都是可见的，而私
有变量，按照语言的规定只有在它们所属的代码块之内才是可见的。也就是说，只有私有
变量声明所在的代码块之内的Perl代码，能够访问私有变量。
全局变量的使用则很普通，只是有的特殊变量不太好理解，例如S1、S_、@ARGB之类。普
通用户的变量是全局的，除非它们以my来声明，否则即使它们“看上去”是私有的，也是
全局变量。按照Perl的规定，PackageAcme：:Widget中的全局变量sDebug，虽然有完整
的限定名sAcme：：Widget：：Debug，仍然是一个全局变量。如果出现了useatrict;，则
所有（不包括特殊的）全局变量必须使用完整的限定名，或者通过our来声明（our声明-
个名称（name)，而不是一个新变量，请参考Perl的文档）。
使用动态作用域的值
动态作用域（dynamicscoping）是个值得一提的概念，很少有编程语言提供这种功能。下文
会讲解它与正则表达式的关系，简单地说，动态作用域可以让Perl保存全局变量的一个副
---
## Page 322
296
第7章：Perl
本，在某个代码块中修改此副本，退出之后自动恢复原来的值。保存副本的操作就称为生
成动态作用域（creatinganewdynamicscope），或者本地化（localizing）。
使用动态作用域的原因之一是为了临时改变某些保存在全局变量中的某些全局状态。举例
来说，packageAcme：：Widget提供了一个调试标志位（flag），我们可以修改全局变量
SAcme：：Widget：：Debug来启用或者停用调试功能。下面的代码可以临时改变此标志位：
local（$Acme::Widget::Debug）=1；#确保启用
#此时Acme：：Widget：：Debug已启用、可以调试
#SAcme：：Widget：：Debug现在恢复到原来的值
loca1函数的命名很成问题，但它生成了一个新的动态作用域。调用1oca1并没有创造新
的变量，1ocal是行为，而不是声明。在全局变量之前，1oca1做了三步处理：
1.在内部保存变量值的副本；
2.把新值赋予到变量（无论是undef还是传给1ocal的值）：
3.1oca1代码块执行结束之后，把变量恢复到之前的值。
也就是说，“local”指的是对变量的修改的持续时间。对本地化的变量来说，持续时间就是
代码块执行的时间。如果代码块中调用了子程序，本地化的值仍然保留（毕竟，变量仍然
是一个全局变量）。它与非本地化的全局变量的唯一区别是，在代码块执行完成之后，之前
的值会被恢复。
loca1对全局变量的自动保存和恢复比想象的要复杂。请参考表7-4右侧，详细了解背后的
处理。
为方便起见，我们也可以给本地变量赋一个值1ocal（$SomeVar），这等于把undef赋值给
SSomeVar。如果不使用括号，表示强制使用scalarcontext。
value”的警告。优秀的Perl程序员都会使用Perl的-w选项来解决这个问题，但是库的作者
---
## Page 323
正则表达式相关的Perl教义
297
表7-4：local的含义
普通Normal程序
等价程序
local($SomeVar); # save copy
my $TempCopy = $SomeVar;
$SomeVar = undef;
$SomeVar = 'My Value';
$SomeVar ='My Value';
$SomeVar= $TempCopy;
）#自动恢复到之前的值
显然没有。你对这些警告非常恼火，但是如果不能修改程序库，有什么其他简便办法来代
替-w吗？这时候可以使用对s~w的调用的1ocal，即时关闭警报（~w可以表示为两个字符，
脱字符和“w，也就是ctrl+W）。
1ocalS^W=0：#确保关闭警报
UnrulyFunction(-.-) ;
#退出代码块，把S^W恢复到原来的值
无论全局变量s^W是什么值，调用1oca1保存都会为其保存一份内部副本。然后s^w被用户
置为0。上面提到的糟糕程序在执行时，Perl检查s^W，发现其值为0，就不会发出警报。
在函数返回时，新值0仍然有效。
这样看来，不用1oca1的话似乎也没有问题。不过，在子程序返回，代码块退出时，$^w
会恢复到之前的值。这种改变是本地的、即时的，只在代码块内部生效。按照表7-4右侧的
做法，用户可以手工生成和返回副本，达到同样的效果，但是1oca1更为方便。
考虑在其他情况下会发生什么，比如用my替代1ocal（注4)。my会新建一个变量，其初
始值是undef。只有在声明的代码块中才可见（也就是说，在my和它所在的代码块结束之
间）。它不会改变、修改，或以其他方式引用和影响其他变量，包括可能存在的同样名字的
全局变量。新建的变量在程序的其他部分都不可见，包括在那个槽糕的程序内。这样新的
$^W的确被置为0，但永远不会再使用或者引用，所以它完全是白费工夫（执行糟糕的程序
时，Perl根据与其无关的全局变量s^w决定是否报警）。
注4：Perl不容许对这个特殊的变量名使用mY，所以这种比较只有理论意义。
---
## Page 324
298
第7章：Perl
更好的比喻：充分的透明度
量之上）。用户（还包括能看到的任何人，例如子程序和信号处理程序）会看到这些新的值。
在代码块结束之前，1oca1的修改会取代之前的值。退出之后，这种透明特性会自动消除，
也就是取消1oca1进行的所有修改。
相比“保存一个内部副本”，这个比喻更接近现实。使用1oca1并不会生成一个副本，而是
在访问变量时，使用新设置的值（即屏蔽原来的值）。退出代码块之后会抛弃新设置的值。
调用1oca1时，新值是手动设置的，但我们要讲解这些细节的原因在于：正则表达式的伴
随效应变量（side-effectvariables）会自动使用动态作用域。
正则表达式的伴随效应和动态作用域
正则表达式与动态作用域有什么关系呢？关系很大。作为伴随效应，许多变量一例如S&
（引用匹配的文本）和S1（引引用第一组括号内表达式匹配的文本）一会在匹配成功时自
动设置。在下一节会详细讨论这些问题。在其所处的代码块中，这些变量都会自动使用动
态作用域。
这种设计的好处在于，每次调用子程序都要启动新的代码块，也就是为这些变量提供了新
的动态作用域范围。因为在代码块之前的值会在代码块执行完之后恢复（也就是子程序返
回时），子程序不能改变调用方能看到的值。
来看个例子：
if ( m/ (.…·) /)
DoSomeOtherStuff() ;
print*the matched text was S1.\n";
）
因为S1的值在进入代码块时进行了动态作用域处理，这段代码不关心也不必关心，函数
DoSomeOtherStuff是否改变了s1的值。此函数对s1的任何改动都只在函数定义的代码块
内部，或者函数的子代码块中生效。所以，DoSomeOtherStuff不会影响print接收的s1
的值。
---
## Page 325
正则表达式相关的Perl教义
299
自动使用动态作用域很有用，虽然有时候不那么明显：
if （Sresult =~ m/ERROR=（.*)/）{
warn*Hey.tell SConfig(perladmin} about $1!\n*;
标准库模块Config定义了一个关联数组（associativearray）$Config，其成员sConfig-