ditionally, every message from the extension includes a
hash of the token for authentication.
When the user visits a web page, the login protocol is
roughly as follows.
1. E → S: page url, token hash
2. E ← S: [(description1, username1, password1), ...,
(descriptionn, usernamen, passwordn)]
The browser extension requests the app for password
entries that match a given URL. If matches are found, the
app returns their information to the extension, including
a description, username, and password. The messages
are JSON objects where the values are encrypted while
the keys are plaintext. Each value is encrypted as a sepa-
rate message. For example:
{ "items": [{ "title":
"",
"username": "",
"password": "" }]}
F-Secure Key requires the user to create passwords in
the app, and thus conﬁdential data mainly ﬂows from the
app to the extension. Apart from the aforementioned
messages, the extension sends a periodic health mes-
sage to the app to indicate that it is still running and a
logout message to lock the vault, after which the user
has to enter the master password to unlock the app again.
Both messages have no content except for the authoriza-
tion token hash.
Attacks. As we can see, the extension does not authen-
ticate the app before sending messages. Thus, a MitMa
1516    27th USENIX Security Symposium
USENIX Association
attacker can impersonate the app to the extension by run-
ning an HTTP server on port 24166. Thanks to the health
messages, the attacker is able to capture the authorization
token hash and use it later to impersonate the extension.
With the ability to impersonate both sides, the MitMa
attacker can perform replay attacks as follows.
In the
ﬁrst stage, it impersonates the app to collect as many
encrypted URLs from the extension as possible. In the
second stage, the attacker closes the malicious server, re-
leasing port 24166, and waits until the user restarts the
app. The attacker then connects to the app as a client
and sends the encrypted URLs. In response, the attacker
obtains a list of encrypted password entries. Note that
the attacker cannot decrypt the passwords. However, be-
cause the values are encrypted as individual messages
and the integrity of the end-to-end connection is not
checked, the attacker can modify the messages and pair
the encrypted password ﬁelds with the wrong encrypted
URLs. In the third stage, the attacker again impersonates
the app to the extension, listening on port 24166. It can
do this, for example, if the user logs out and later logs
back in. The attacker then responds to requests from the
browser extension by replaying the responses that it re-
ceived earlier, but with the mismatched passwords. Since
the passwords have been matched with the wrong URLs,
they get sent to the wrong websites. As described, this is
just a nuisance attack but shows that data leaks are possi-
ble. More seriously, the attacker could collude with one
of the websites, identify its encrypted URL at the MitMa
process by correlating the timing of the encrypted mes-
sage with the user’s login on the colluding site, and then
leak the user’s passwords to that site one by one.
4.2 Managers with native messaging
Native messaging [25] is intended to provide a more se-
cure alternative to network sockets or named pipes for
communicating between a browser extension and native
code. In Windows, native messaging uses named pipes
with random names for its internal implementation, and
in Linux and macOS, it uses anonymous pipes. This
makes the communication channel immune to MitMa at-
tacks. The native password manager app registers an
executable, called native messaging host (NMH), with
the web browser. The conﬁguration ﬁle of the NMH can
specify which browser extensions have access to it. The
web browser starts the NMH in a child process and lets
the browser extension communicate with it.
Native messaging can be used to implement a pass-
word manager that is only accessed through the web
browser and the browser extension.
It is, however,
not a complete solution for communication between
the browser extension and the stand-alone password-
manager app of Figure 2. This is because the NMH needs
Figure 3: Communication in native messaging
to be a child process of the web browser and thus is a dif-
ferent process from the stand-alone app. In the follow-
ing, we analyze how password managers nevertheless try
to make use of native messaging.
4.2.1 Password Boss
Password Boss [6] on Windows uses both native mes-
saging and named pipes, as shown in Figure 3. When
the native app is started, it creates a named pipe with a
ﬁxed name and maximum 50 instances. The access con-
trol list on the named pipe allows all authenticated users
to read and write to its instances. The native messaging
host connects to the named pipe as a pipe client and for-
wards messages between the browser extension and the
native app. Messages are sent in plaintext and no attempt
is made to authenticate them.
Attacks. Any authenticated user on the system can per-
form the MitMa attack as follows. First, the attacker con-
nects as a client to the native app’s named pipe instance.
The attacker then creates another instance of the named
pipe, which is possible thanks to the unnecessarily high
maximum number of instances. When the native mes-
saging host tries to communicate with the native app, it
will connect to the attacker’s instance because it is the
only one available. The attacker can thus sit between
the two pipe instances forwarding messages and reading
their content, including passwords.
The above attack does not work if the attacker only has
guest access to the victim’s system because the named
pipe’s security attributes allow only authenticated users
to create and access instances. To overcome this lim-
itation, the guest-user attacker needs to hijack the pipe
name as described in Section 3. That is, the attacker has
to create the ﬁrst instance of the named pipe, so that it
can set the DACL to allow access by everyone. After
that, the guest user can mount the MitMa attack.
4.2.2 Sticky Password
Sticky Password [8] also makes use of both native mes-
saging and WebSocket, but in a conﬁguration that is
slightly different from Figure 3. When the browser ex-
tension starts up, it uses native messaging to obtain an
AccessKey from the NMH, which gets it from the stand-
alone Sticky Password app with the CFMessagePort IPC
method. After this, the browser extension communicates
directly with the app’s WebSocket server on port 10011.
USENIX Association
27th USENIX Security Symposium    1517
A simpliﬁed version of the protocol between the Sticky
Password browser extension and app is shown below.
1. E → S: “authenticate”, ClientID, AccessKey
2. E → S: “GetCompleteWebAccounts”
3. E ← S: [(id1,username1), ..., (idn,usernamen)]
4. E → S: “GetLoginPassword”, idi
5. E ← S: password
Thus, the browser extension ﬁrst authenticates to the
server with the AccessKey.
It then uses further com-
mands to retrieve the list of available data and, ﬁnally,
the desired data item. Different commands exist for dif-
ferent types of user data.
Attacks. The ﬁrst attack that a MitMa attacker can do
with Sticky Password is to impersonate the WebSocket
server. The reason is that the extension does not au-
thenticate the app. That is, the attacker can hijack the
localhost port 10011 before Sticky Password starts and
pretend to be the app. By impersonating the server, the
attacker may be able to capture data that the extension
sends to the app, including new passwords that the user
is attempting to save to the password vault.
Another important piece of data that the attacker can
obtain with the above attack is the AccessKey. Once the
attacker has learned this, it can impersonate the exten-
sion to the authentic Sticky Password app. That is, af-
ter capturing the AccessKey, the MitMa attacker closes
the server socket at port 10011 and waits for the user to
restart the Sticky Password app. It can then connect to
the app and use the AccessKey to retrieve all of the vic-
tim’s passwords. The attacker has to resort to this two-
stage attack because, when the attacker’s binary binds to
port 10011, the Sticky Password app fails to do so. Nev-
ertheless, a patient attacker is able to alternate between
the connections.
5 Case study 2: Hardware tokens
Our second case study is communication with physical
authentication devices. Communication with the physi-
cal tokens also takes place within one computer, and we
ﬁnd that it is vulnerable to MitMa attacks by malicious
processes that are running in the background.
5.1 U2F security key
FIDO U2F [23] is an open authentication standard that
enables strong two-factor authentication to online ser-
vices with public-key cryptography and a USB hardware
device called security key. It is supported by major on-
line service providers, by UK government services [28],
and by the Google Chrome and Firefox (beta) browsers.
We analyze the security of U2F in Windows computers.
Figure 4: The basic authentication ﬂow of a website with
U2F security key [57]
The user must ﬁrst register the U2F device to the on-
line service. The device generates a service-speciﬁc key
pair and stores it together with a key handle (i.e. identi-
ﬁer) and the origin URL of the service.
Figure 4 illustrates the two-factor authentication pro-
cess to a website. The browser receives a challenge to-
gether with a key handle from the web server. It forms
the so-called client-data object and sends the object
to the U2F device for signing. At this point, the user
needs to activate the device by touching a button on the
device. The browser then delivers the signed object back
to the web server for veriﬁcation.
The button press is meant to prevent unauthorized use
of the hardware device. In practice, the browser process
keeps sending signing requests to the USB device until
it receives a signature back. When the button is pressed,
the device responds to the ﬁrst received signing request.
The origin URL is included in the signed message to pre-
vent replay attacks between websites.
Attacks. The two-factor authentication is supposed to
prevent login even when the user’s password has been
compromised (e.g. because of attacks described in Sec-
tion 4). Thus, we only consider how the attacker can
subvert the U2F hardware-device authentication. To do
this, the MitMa attacker creates a malicious (browser)
process that runs on the user’s computer and tries to log
into one of the user’s online services. The attacker’s pro-
cess then sends client-data objects to the U2F device at
a high rate. When the user decides to log in to any ser-
vice using U2F authentication and touches the button on
the device, there is a high probability that the attacker’s
request will be signed. The user may notice that the ﬁrst
button press had no effect, but such minor glitches are
normal in computers and typically ignored.
In experiments with FIDO U2F Security Key, our ma-
licious Python client in the background was 100% suc-
1518    27th USENIX Security Symposium
USENIX Association
(a) Normal operation
(b) MitMa attack
Figure 5: MitMa attack on DigiSign smart card reader through SCS interface
cessful in snatching the ﬁrst button press and spooﬁng
the second authentication factor to services such as Face-
book and GitHub. The high success rate is due to the le-
gitimate user’s browser being slower to issue the signing
requests to the device than our frequently-polling mali-
cious script.
There are two root causes to this attack. First, the de-
vice does not have a secure path for informing the user
about which request will be signed. Second, Windows
allows even non-interactive processes to access the USB
device in the background. This attack is not possible in
Linux or macOS because they would prevent the mali-
cious background process form accessing the USB de-
vice.
Another approach to strengthening the security of crit-
ical login sessions is the TLS Channel ID [13,21]. It does
this by using a public key in addition to session cookies.
However, such approaches only help protect the already
established session, and they do not have any effect on
the security of the initial two-factor authentication which
we are able to compromise.
5.2 Fujitsu DigiSign
DigiSign is a smart-card reader application developed by
Fujitsu for the Finnish government. Its main user base is
healthcare professionals, but all citizens can acquire an
electronic identity card for strong authentication to gov-
ernment services.
The DigiSign application implements the so-called
Signature Creation Service (SCS) interface [34] speciﬁed
by the Finnish Population Register Centre. We analyze
the currently implemented protocol version 1.01.
The idea of the SCS interface is to allow a browser to
send signing requests to the card-reader application with-
out requiring any browser extensions. The basic process
is illustrated in Figure 5(a). The card-reader app with
the SCS interface has an HTTP server running on port
53951 and HTTPS server on port 53952 (during installa-
tion, the card reader app creates a self-signed certiﬁcate
for the local HTTPS server and adds it to the trusted cer-
tiﬁcates). A webpage may send signature requests to the
card reader by making a Cross-Origin Resource Sharing
(CORS) requests on one of these ports on the loopback
address. The data to be signed may be a document, a
hash, or a token that is used for authentication. Once
card reader app receives a signature request over SCS,
it displays a UI dialog requesting the user to insert the
smart card to the reader and to type in the PIN. If these
are correct, the smart card signs the messages and the
result is returned to the browser.
Attacks. The MitMa attack against the SCS protocol,
illustrated in in Figure 5(b), is similar to those against
password managers. The attacker’s process hijacks the
primary (HTTPS) port used by the SCS protocol. While
the attacker cannot spoof the HTTPS server, an attempt
to connect to it informs the malicious process that the
user is about to sign something. The malicious process
blocks this connection without closing it and sends a ma-
licious signing request to the card reader app, which is
listening on the secondary (HTTP) port. When the user
enters the PIN, the card signs the attacker’s data.
SCS speciﬁcation version 1.1 [43] will ﬁx some of the
problems. Most notably, it mandates the use of TLS on
the local IPC channel and speciﬁes only one port for the
card reader app. Because of this, it would appear that an
attacker cannot hijack a port and simultaneously send a
signing request to the card reader app. Nevertheless, the
newer speciﬁcation does not solve the root cause of the
problem, which is that the client in the SCS protocol is
not authenticated. A malicious process could opportunis-
tically send signing requests to the card reader app and
hope that the timing is right, or a confused user might en-
ter the PIN by mistake. Moreover, the attacker could use
out-of-band hints, such as insertion of the smart card or
shoulder surﬁng, to time the malicious signature request
approximately at the correct time window.
USENIX Association
27th USENIX Security Symposium    1519
Browserhttps://domain.comDigiSignSelect certiﬁcateand enter PINmsg, cert, PINsignkeycert(msg)CardVerify PINHTTPS POST localhost:53952msgsign(msg)Browserhttps://domain.comDigiSignmsg', cert, PINsignkeycert(msg')CardVerify PINHTTPS POST localhost:53952; msgMaliciousbinaryHTTP POST localhost:53951; msg'Select certiﬁcateand enter PINsign(msg')6 Case study 3: Software back-ends with
HTTP API
A common application software architecture separates
the application into a front-end component, which only
handles user interaction, and a back-end server with
an HTTP API, which often follows the REST design
paradigm. We discuss three such applications that use
network sockets and HTTP for inter-process communi-
cations. We show that a MitMa attacker can circumvent
the commonly accepted security solutions that are sup-
posed to prevent client impersonation in such applica-
tions.
6.1 Blizzard
Blizzard [2], a computer game publisher, provides the
Battle.net desktop app for installing and updating games.
The app comes with a background service called Bliz-
zard update agent, which receives commands from the
app and does the actual software installation. The up-
date agent runs an HTTP server on localhost port 1120.
The client ﬁrst retrieves an authorization token from
http://localhost:1120/agent and then connects to
other endpoints.
The security of the update agent has received recent