center of the square at the origin, point (0,0). You can then generate pairs of
values, or coordinates, that lie within the range (–r, –r) to (+r, +r). You can
determine whether any set of coordinates (x, y) lie within the circle by
applying Pythagoras’ theorem to determine the distance d of these
coordinates from the origin. You can calculate d as the square root of ((x * x)
+  (y * y)). If d is less than or equal to r, the radius of the circle, the
coordinates (x, y) specify a point within the circle, as shown in the following
diagram:
Download from finelybook PI:EMAIL
869
You can simplify matters further by generating coordinates that lie only in
the upper-right quadrant of the graph so that you only have to generate pairs
of random numbers between 0 and r. This is the approach you will take in the
exercises.
Note The exercises in this chapter are intended to be run on a computer
with a multicore processor. If you have only a single-core CPU, you
will not observe the same effects. Also, you should not start any
additional programs or services between exercises, because these might
affect the results you see.
Calculate pi by using a single thread
1. Start Visual Studio 2017 if it is not already running.
2. Open the CalculatePI solution, which is located in the \Microsoft
Download from finelybook PI:EMAIL
870
Press\VCSBS\Chapter 24\ CalculatePI folder in your Documents folder.
3. In Solution Explorer, in the CalculatePI project, double-click Program.cs
to display the file in the Code and Text Editor window.
This is a console application. The skeleton structure of the application
has already been created for you.
4. Scroll to the bottom of the file and examine the Main method. It looks
like this:
Click here to view code image
static void Main(string[] args)
{
    double pi = SerialPI();
    Console.WriteLine($"Geometric approximation of PI calculated
serially: ");
    Console.WriteLine();
    // pi = ParallelPI();
    // Console.WriteLine($"Geometric approximation of PI
calculated in parallel: ");
}
This code calls the SerialPI method, which calculates pi by using the
geometric algorithm described before this exercise. The value is returned
as a double and displayed. The code that is currently commented out
calls the ParallelPI method, which performs the same calculation but by
using concurrent tasks. The result displayed should be the same as that
returned by the SerialPI method.
5. Examine the SerialPI method.
Click here to view code image
static double SerialPI()
{
    List pointsList = new List();
    Random random = new Random(SEED);
    int numPointsInCircle = 0;
    Stopwatch timer = new Stopwatch();
    timer.Start();
    try
    {
        // TO DO: Implement the geometric approximation of PI
        return 0;
    }
    finally
Download from finelybook PI:EMAIL
871
    {
        long milliseconds = timer.ElapsedMilliseconds;
        Console.WriteLine($"SerialPI complete: Duration:  ms",);
        Console.WriteLine(
            $"Points in pointsList: {pointsList.Count}. Points
within circle: ");
{numPointsInCircle}");
    }
}
This method generates a large set of coordinates and calculates the
distances of each set of coordinates from the origin. The size of the set is
specified by the constant NUMPOINTS at the top of the Program class.
The bigger this value is, the greater the set of coordinates and the more
accurate the value of pi calculated by this method. If your computer has
sufficient memory, you can increase the value of NUMPOINTS.
Similarly, if you find that the application throws
OutOfMemoryException exceptions when you run it, you can reduce this
value.
You store the distance of each point from the origin in the pointsList
List collection. The data for the coordinates is generated by
using the random variable. This is a Random object, seeded with a
constant to generate the same set of random numbers each time you run
the program. (This helps you determine that it is running correctly.) You
can change the SEED constant at the top of the Program class if you
want to seed the random number generator with a different value.
You use the numPointsInCircle variable to count the number of points in
the pointsList collection that lie within the bounds of the circle. The
radius of the circle is specified by the RADIUS constant at the top of the
Program class.
To help you compare performance between this method and the
ParallelPI method, the code creates a Stopwatch variable called timer
and starts it running. The finally block determines how long the
calculation took and displays the result. For reasons that will be
described later, the finally block also displays the number of items in the
pointsList collection and the number of points that it found that lie
within the circle.
You will add the code that actually performs the calculation to the try
Download from finelybook PI:EMAIL
872
block in the next few steps.
6. In the try block, delete the comment and remove the return statement.
(This statement was provided only to ensure that the code compiles.)
Add to the try block the for block and statements shown in bold in the
following code:
Click here to view code image
try
{
    for (int points = 0; points 
    {
        int xCoord = random.Next(RADIUS);
        int yCoord = random.Next(RADIUS);
        double distanceFromOrigin = Math.Sqrt(xCoord * xCoord +
yCoord * yCoord);
        pointsList.Add(distanceFromOrigin);
        doAdditionalProcessing();
    });
}
This construct is the parallel analog of the code in the for loop in the
SerialPI method. The body of the original for loop is wrapped in a
lambda expression. Remember that each iteration of the loop is
performed by using a task, and tasks can run in parallel. The degree of
parallelism depends on the number of processor cores and other
resources available on your computer.
4. Add the following code shown in bold to the try block, after the
Parallel.For statement. This code is the same as the corresponding
statements in the SerialPI method.
Click here to view code image
try
{
    Parallel.For (...
Download from finelybook PI:EMAIL
876
    {
        ...
    });
    foreach (double datum in pointsList)
    {
        if (datum  object. However, this type is not thread-safe. The code in the
Parallel.For statement calls the Add method to append a value to the
collection, but remember that this code is being executed by tasks running as
concurrent threads. Consequently, given the number of items being added to
the collection, it is highly probable that some of the calls to Add will interfere
with one another and cause some corruption. A solution is to use one of the
collections from the System.Collections.Concurrent namespace because these
collections are thread safe. The generic ConcurrentBag class in this
namespace is probably the most suitable collection to use for this example.
Use a thread-safe collection
1. In Solution Explorer, double-click Program.cs to display the file in the
Code and Text Editor window if it is not already open.
2. Add the following using directive to the list at the top of the file:
using System.Collections.Concurrent;
3. Locate the ParallelPI method. At the start of this method, replace the
statement that instantiates the List collection with code that
creates a ConcurrentBag collection instead, as shown in bold
in the following code example:
Click here to view code image
Download from finelybook PI:EMAIL
878
static double ParallelPI()
{
  ConcurrentBag pointsList = new ConcurrentBag
();
  Random random = ...;
  ...
}
Notice that you cannot specify a default capacity for this class, so the
constructor does not take a parameter.
You do not need to change any other code in this method; you add an
item to a ConcurrentBag collection by using the Add method,
which is the same mechanism that you use to add an item to a List
collection.
4. On the Debug menu, click Start Without Debugging.
The program runs and displays its approximation of PI by using the
SerialPI and ParallelPI methods. The following image shows the
typical output.
This time, the pointsList collection in the ParallelPI method contains the
correct number of points, but the number of points within the circle,
9989364, appears to be very high; it should be the same as that reported
by the SerialPI method.
You should also note that the time taken by the ParallelPI method has
increased compared with the previous exercise. This is because the
methods in the ConcurrentBag class have to lock and unlock data to
guarantee thread safety, and this process adds to the overhead of calling
these methods. Keep this point in mind when you’re considering
whether it is appropriate to parallelize an operation.
Download from finelybook PI:EMAIL
879
5. Close the console window, and return to Visual Studio.
You currently have the correct number of points in the pointsList
collection, but the value recorded for each of these points is now
questionable. The code in the Parallel.For construct calls the Next method of
a Random object, but like the methods in the generic List class, this
method is not thread-safe. Sadly, there is no concurrent version of the
Random class, so you must resort to using an alternative technique to
serialize calls to the Next method. Because each invocation is relatively brief,
it makes sense to use a simple lock to guard calls to this method.
Use a lock to serialize method calls
1. In Solution Explorer, double-click Program.cs to display the file in the
Code and Text Editor window if it is not already open.
2. Locate the ParallelPI method. Modify the code in the lambda
expression in the Parallel.For statement to protect the calls to
random.Next by using a lock statement. Specify the pointsList collection
as the subject of the lock, as shown here in bold:
Click here to view code image
static double ParallelPI()
{
    ...
    Parallel.For(0, NUMPOINTS, (x) =>
    {
        int xCoord;
        int yCoord;
        lock(pointsList)
        {
            xCoord = random.Next(RADIUS);
            yCoord = random.Next(RADIUS);
        }
        double distanceFromOrigin = Math.Sqrt(xCoord * xCoord +
yCoord * yCoord);
        pointsList.Add(distanceFromOrigin);
        doAdditionalProcessing();
    });
    ...
}
Notice that the xCoord and yCoord variables are declared outside the
Download from finelybook PI:EMAIL
880
lock statement. You do this because the lock statement defines its own
scope, and any variables defined within the block specifying the scope
of the lock statement disappear when the construct exits.
3. On the Debug menu, click Start Without Debugging.
This time, the values of pi calculated by the SerialPI and ParallelPI
methods are the same. The only difference is that the ParallelPI method
runs more much more quickly.
4. Close the console window, and return to Visual Studio.
Summary
In this chapter, you saw how to define asynchronous methods by using the
async modifier and the await operator. Asynchronous methods are based on
tasks, and the await operator specifies the points at which a task can be used
to perform asynchronous processing.
You also learned a little about PLINQ and how you can use the AsParallel
extension method to parallelize some LINQ queries. However, PLINQ is a
big subject in its own right, and this chapter has only shown you how to get
started. For more information, see the topic “Parallel LINQ (PLINQ)” in the
documentation provided with Visual Studio.
This chapter also showed you how to synchronize data access in
concurrent tasks by using the synchronization primitives provided for use
with tasks. You saw how to use the concurrent collection classes to maintain
collections of data in a thread-safe manner.
If you want to continue to the next chapter, keep Visual Studio 2017
Download from finelybook PI:EMAIL
881
running and turn to  Chapter 25, “Implementing the user interface for a
Universal Windows Platform app.”
If you want to exit Visual Studio 2017 now, on the File menu, click
Exit. If you see a Save dialog box, click Yes and save the project.
Quick reference
To
Do this
Implement an
asynchronous
method
Define the method with the async modifier and change the
type of the method to return a Task (or a void). In the body
of the method, use the await operator to specify points at
which asynchronous processing can be performed. For
example:
Click here to view code image
private async Task calculateValueAsync(...)
{
    // Invoke calculateValue using a Task
    Task generateResultTask =
        Task.Run(() => calculateValue(...));
    await generateResultTask;
    return generateResultTask.Result;
}
Parallelize a
LINQ query
Specify the AsParallel extension method with the data
source in the query. For example:
Click here to view code image
var over100 = from n in numbers.AsParallel()
              where ...
              select n;
Enable