IntL = {ilicl
Ictg : IntL → IntC
Icls : S ∪ O → IntLIntC
{p}1, . . . , ilicl
{p}f
}
Table 1: Elements of the model
the called application. Additionally, after an application is
called it runs at the access classes it is assigned to. Note
that in the original model [10], the calling of an application
is seen as not security relevant. In our extended model, we
are deeply concerned with this issue, as the BioSig example
demonstrates.
We have already deﬁned the allowed communication chan-
nels within the model according to the access rules. It turns
out, if two applications X and Y are assigned to two dif-
ferent access categories, they are completely separated on
the card. But it is often the intention to allow a secure
communication between those applications.
There are three main techniques in achieving this. Firstly,
objects are multiple assigned to both access categories of X
and Y . So, both applications have access to the object.
Next, subjects, e.g. the applications, are multiple assigned
to the access categories and all objects belong to one spe-
cial access category. Thirdly, one can deﬁne trusted channel
programs that have two diﬀerent pairs of access classes in
diﬀerent access categories [15].
These channel programs can also be used within a single
access category for downgrading or upgrading of data to a
lower or higher access class. This is also known as sanitiza-
tion. But special care has to be taken in introducing such
channel programs, as they intentionally violate the overall
security policy. On the other hand, they are a powerful
tool for establishing special communication channels. Espe-
cially virus checker applications or ﬁrewall applications take
advantage of it. The channel programs have to follow the
following transfer rule:
transfer (si, sj) ⇐⇒ slsck
ilick
w (si) ≤ slscl
w (si) ≥ ilicl
r (sj) ∧
r (sj)
(4)
The channel program is assigned to two pairs of access
classes for reading and writing as well as for secrecy and
integrity, respectively. The pair used for reading will have
the clearance of subject si, while the one used for writing
will have the clearance of subject sj . This allows the channel
to read the content of a ﬁle from si and write it into a ﬁle
that can be read by sj. Note that the access categories for
subject si and si may diﬀer, which leads to the problem of
a lack of ordering between the access classes.4
We refer to this rule as
SF4: Channel program (combined read and write clearance)
(Eq. 4).
4The BLP and Biba models require a partial ordering of the
access classes, which is two access classes of the same access
category are in order but there is no ordering of two access
classes of diﬀerent access categories.
low integrity. The elements of both models are summarized
in Table 1. The set {p} denotes the read, write and execute
access class.
The combined read, write and execute permission can be
expressed as follows:
read (si, oj ) ⇐⇒ slsck
ilicl
(si) ≥ slsck
r (si) ≤ ilicl
r
r (oj)
(oj) ∧
r
(1)
r
r
Intuitively, Equation 1 states that an arbitrary subject si,
e.g. an application, with read secrecy access right slsck
in
secrecy access category sck and with read integrity access
right ilicl
in integrity access category icl, receives permis-
sion to read an arbitrary object oj if and only if a) the read
secrecy access right is greater than or equal to the read se-
crecy access right of the object and b) the read integrity
access right is less than or equal to the read integrity access
right of the object. The Equations 2 and 3 give the write
permission of an arbitrary subject si to an arbitrary object
oj and the execute permission of an arbitrary subject si to
an arbitrary subject sj.
w (si) ≤ slsck
write(si, oj) ⇐⇒ slsck
w (si) ≥ ilicl
ilicl
w (oj ) ∧
w (oj)
x (si) ≥ slsck
exec(si, sj ) ⇐⇒ slsck
ilicl
x (si) ≤ ilicl
x (sj ) ∧
x (sj)
(2)
(3)
In order to deﬁne a secure system, all three rules must
be active at the same time. If we look at the system as a
state machine, it must be secure in the initial state and in
all reachable states. The state transitions are deﬁned by all
possible system operations. In our model we distinguish the
read and write operation from the execute operation. These
rules deﬁne security enforcing functions SF that we name as
follows:
SF1: No read up for secrecy and no read down for integrity
(see Eq. 1);
SF2: No write down for secrecy and no write up for integrity
(see Eq. 2);
SF3: No execution upwards for secrecy and no execution
downwards for integrity (see Eq. 3).
4.2 Communication channels
Communication is realized via storage channels, which
means that the return values are stored in a temporary ﬁle.
Hence, the called application needs to have write permission
to the temporary ﬁle and the calling application needs to
have read permission to the ﬁle. This is in fact true, because
otherwise the calling application could not have executed
229
Access category A
access class
secrecy
integrity
4
3
2
1
1
2
3
4
Applications
Ap 1
Ap 2
Ap 3
Ap 4
Ap 5
Access category B
Applications
access class
secrecy integrity
Ap 6
Ap 7
channel
program
Ap 8
3
2
1
1
2
3
write clearance
read/execute clearance
transfer clearance
Figure 2: Communication channels between applications
A summary of the allowed communication channels be-
tween applications assigned to diﬀerent access categories and
access classes is given in Figure 2. In the ﬁgure, the ideal-
ized applications Ap2 and Ap3 are assigned to secrecy access
class 3A and integrity access class 2A in access category A,
whereas Ap6 and Ap7 are assigned to secrecy access class 3B
and integrity access class 1B in access category B. We as-
sume access class 4A of category A is greater than 3A and
so forth. According to the access rules Ap3 is cleared to read
objects of applications Ap2, Ap4 and Ap5 as well as to exe-
cute the applications. It has also write permission of objects
of applications Ap1 and Ap2. In addition a trusted channel
program allows the transfer of information to application
Ap6. Therefore the ordering between the access classes of
category A and B must be deﬁned, which is 3A = 3B and
2A > 1B in the example.
4.3 Integrating external applications and de-
vices
Bearing in mind the security objectives mentioned in Sec-
tion 3, we have yet to mention how the applications (the
subjects) are assigned to security classes within the card.
There is always one point in time where every application
must be loaded on the card and hence will be assigned to
the deﬁned access classes. It is very crucial for the whole
system that this initial process is performed reliably. Imag-
ine a malicious application that is somehow loaded onto the
card and assigned to the highest secrecy and integrity ac-
cess class for all categories. This application would then be
allowed to read all data and to distribute (malicious) data
to all other applications.
To prevent the card from loading such applications, we
again follow the approach given in [15]. Every card holds a
trusted key that is used to verify electronic signatures. In
an oﬀ card process every application, together with assign-
ment information, is electronically signed by the issuer of
the speciﬁc card. Thus, a card only accepts applications
that provide a valid electronic signature and hence assigns
the stated access classes to the application. All other appli-
cations are denied. We summerize security function SF5:
SF5: Authentication of loaded applications and assignment
information.
In our model, subjects are related to applications inside
as well as outside the card. Because the operating system
of the card has full control of both all applications running
on the card as well as data stored on the card, this is not
the case for external applications. This makes additional
protection of the communication channel between external
and internal applications necessary. Furthermore, the ex-
ternal applications must be authenticated by the card each
time they wish to communicate with an internal application.
Furthermore, an external device is treated in the same way
as an external application, since from the card’s point of
view there is no diﬀerence between them.
In contrast to the aforementioned procedure of loading
an internal application onto the card, the card must ﬁrstly
authenticate the application by verifying the electronic sig-
nature, then assign it to the deﬁned access classes and ﬁnally
establish a session key in order to guaranty conﬁdentiality
and integrity of the transferred data. A mutual authenti-
cation may also be performed if requested by the external
application. We summerize security function SF6:
SF6: Authentication of external applications, external de-
vices and assignment information as well as conﬁden-
tiality and integrity of the transfered data.
After this initial procedure, the external application can
be treated as an internal application from the point of view
of the card. The handling of the assignment information
also cannot be adapted from the previous procedure because
external applications are not loaded onto the card and are
therefore not electronically signed. The external application
presents a certiﬁcate instead, e.g.
in card veriﬁable format
or in X.509 format, that holds the public key together with
the assignment information. The application should hold
the corresponding private key. Thus, the card can verify
the certiﬁcate by using the appropriate trusted public key
stored on the card. Here, security depends on the chosen
authentication and key establishment protocol. Well under-
stood and standardized cryptographic protocols are given in
ISO/IEC 9798.
SF1
SF2
SF3
SF4
SF5
√
SF6
√
√
√
√
√
√
√
√
√
√
√
√
√
√
SO1
SO2
SO3
SO4
SO5
SO6
Table 2: Security functions representing the security
objectives
230
{p}
In addition we assign all higher evaluation levels to the
highbiosig
access class [EAL5h], [EAL6h], [EAL7h]. In this way,
diﬀerent evaluation schemes can be integrated in the over-
all application, i.e. ITSEC evaluation level, as well. Note
that we can apply these assignments in our BioSig exam-
ple, because we want to allow even higher evaluated external
signature applications to use the QeSig application. This is
due to legal requirements and cannot be simply adapted to
other scenarios. Our aim is to prevent high evaluated ex-
ternal signature applications as ExtSig from using the not
evaluated AeSig application. A graphical representation of
the assignments is given in Figure 4.
We are not concerned with secrecy categories here because
there is no data that must be kept conﬁdential except secret
keys; keys, however, are not transfered anyway. We assume
that those kinds of data belong to the application itself and
are therefore not accessible by other applications. In fact,
it is crucial for the external signature application that the
document or the hash value of the document to be signed
is neither altered nor manipulated while sending it to the
signature creation application.
In order to get an external signature application ExtSig
authenticated by the card, ExtSig presents its certiﬁcate
that holds the public key as well as the evaluation infor-
mation as mentioned in the previous section.
It is highly
unrealistic that such application is equipped with a certiﬁ-
cate issued by the smart card issuer, which would hold the
assignment information. It rather presents a certiﬁcate is-
sued by the evaluation body. Hence, the card should hold
at least two trusted public keys in order to verify the valid-
ity of the certiﬁcates (issued by the smart card issuer or by
the evaluation body). Once the smart card has successfully
authenticated the external signature application ExtSig, it
then assigns the application to the deﬁned access classes
[EAL4h] = {ExtSig}. From the BioSig point of view, there
is no diﬀerence between two diﬀerently evaluated applica-
tions as long as they provide a valid certiﬁcate stating the
suﬃcient evaluation level. Hence, the application ExtSig is
allowed to execute QeSig but not AeSig.
According to the transport security of data between the
card and external applications, it is in our case suﬃcient to
guarantee integrity of the transferred data. In accordance
with the general communication channels between applica-
tions given in Figure 2, we oﬀer a selection of some possible
communication channels and the classiﬁcations in Figure 4.
More communication channels are possible, e.g. QeSig could
also execute an [EAL5h] instantiated external signature ap-
plication. Because QeSig is not designed to do so, we skip
those channels. As mentioned, we are not concerned with
conﬁdentiality here, hence we assign all applications to a
default secrecy access class dflt.
We have already worked out the ﬁrst step in the execu-
tion chain, e.g. ExtSig calls QeSig. The signature creation
application QeSig has to authenticate the user in order to
activate and create the electronic signature. To maintain
the same security level, it is only allowed to execute authen-
tication applications of the same (or higher) integrity level.
Again, in this scenario, we are not concerned with secrecy,
because the answer of an authentication application, which
may be yes or no, is not conﬁdential, but must be full of
integrity. That is why QeSig is additionally assigned to the
access class highauth
{p} and may execute PIN or Bio1.
Next, we need to integrate the external devices that are
External
Applications
Ap x
Ap y
. . .
Ap n
Load new
Application
External
Devices
IFD
CD 1
CD 2
. . .
. . .
Ap n
Ap 1 Ap 2 Ap 3
Smartcard
                      

                      

                      

                      