201
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 09:56:57 UTC from IEEE Xplore.  Restrictions apply. 
  Figure 10. Register File AVF using cache size of 14 for different number of Read Count bit (R.C.)    Figure 11. Register File AVF using cache size of 16 for different number of Read Count bit (R.C.)  Figure 12. Register File AVF using cache size of 18 for different number of Read Count bit (R.C.)  Figure 13. Register File AVF using cache size of 20 for different number of Read Count bit (R.C.) 0    5    10    15    20    AVF (%) Figure 14. Non-protected Register File AVF  Read from a Register- in each read operation, both the register cache and the main register file are accessed. As shown in Figure 9, a multiplexer is used to select the data. If the value is in the register cache, the hit signal is set and the multiplexer selects the data from the cache. Otherwise, the read data from the main register file is connected to the multiplexer output. It should be noted that SETs occurring in the output lines of the multiplexer may be captured by the next pipeline stage of the processor resulting in a soft error. However, the proposed technique does not address these errors, but if we employ the introduced robust latch in the pipeline stages, theses errors can be simply masked. When a miss occurs and the data is read from the main register file, the parity checking is done to check if an error exists in the read value. In the case of detecting an erroneous value, a rollback recovery mechanism can be used. After a value is read from a cache entry, the corresponding read counter is incremented. When the read counter reaches the maximum value, it is not incremented anymore until it is selected as a victim entry. 5. Experimental Results and Comparisons As mentioned in Section 3.1, the AVF of the register file is considered as a metric for reliability estimation of the RRC technique. The two important parameters in the RRC technique affecting the register file AVF are the size of the register cache and the number of bits assigned for the read counter. In Figures 10, 11, 12, and 13, the register file AVF of the RRC technique with cache size of 20, 18, 16, 14 entries and the number of read count bits of 0, 1, 2, and 3 bits are reported. In Figure 14, the AVF of the non-protected register file is also shown. As it can be seen from these five figures, as the cache size increases for a fixed number of read counts, the register file AVF decreases. For example, for three bits of read count (R.C.=3), as the cache size changes from 14 (See Figure 10) to 20 entries (See Figure 13), the AVF decreases from about 3% to about 1%. This trend is still true, but with a higher amount, for a specific cache size with different sizes of the read count bits. For example, for the cache size of 14 (See Figure 10), as the number of read count bits increases, the AVF decreases from about 7% to 3%.  This means that to gain more AVF improvement, not only the cache size is an important parameter, but also the number of read count bits considerably affects the improvement. The other important thing inferred from the above figures is that, using register caching even with zero read count bits, results in considerable improvement in register file AVF. For example for 012345678AVF (%)R.C.=0R.C.=1R.C.=2R.C.=301234567AVF (%)R.C.=0R.C.=1R.C.=2R.C.=30123456AVF (%)R.C.=0R.C.=1R.C.=2R.C.=30123456R.C.=0R.C.=1R.C.=2R.C.=3978-1-4244-4421-2/09/$25.00 c(cid:13)2009 IEEE
202
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 09:56:57 UTC from IEEE Xplore.  Restrictions apply. 
 the cache size of 20 and the read count size of zero bit, the register file AVF is 4% for the average case while it is about 15% in the Non-protected register file (See Figure 14). However, the AVF of the register file becomes less than 1% if we use three bits read count.  An MBU or SBU error may occur in the main register file or the register cache. When an MBU or SBU occurs, three situations exist: 1) the erroneous register value is in the main register file and is still in its ACE time. In this case, the MBU results in an SDC error while the SBU results in a DUE error as a parity bit is used for the main register file; 2) the erroneous register value is in the register file and it is in its UN-ACE time. In this case, the both MBU and SBU will not cause any failure; and 3) the erroneous register value is in the register cache. In this case, the error will be masked whether it is an MBU or SBU error, as it is built by robust memory elements. Based on these three cases, in the RRC technique, two kinds of error may exist: 1) SDC errors for MBUs; 2) DUE errors for SBUs. In fact, The SDC AVF for SBUs is zero in the RRC technique due to the use of a parity bit for all registers in the main register file.  Therefore, the AVF results shown in Figure 10, 11, 12, and 13 are SDC AVF for MBUs and DUE AVF for SBUs. According to the simulation results, using the RRC technique with proper cache size and read count bits can results in significant reduction for MBU SDC and SBU DUE errors. This is because, the probability that a register value is in the main register file and is still in its ACE time significantly low. In other words, the situations 1 and 2 rarely happen.  To extract the power consumption of the RRC technique, we use the Synopsis power compiler tool for 180nm technology. As the register cache consists of circuit level protected memory elements, the robust register cache is simulated by HSPICE tool and its power consumption for read and write operations are measured for 180nm technology size using CMOS predictive transistor model [4]. The total power consumption of the RRC is then calculated by multiplying total number of both read and write operations by the amount of power consumed by a single read and a single write operation. Finally the total power consumed by the processor is measured. The power overheads reported in this section are the amount of power overheads imposed to the processor not to the register file. In Figure 15, the amount of power overheads of the RRC technique for cache sizes of 14, 16, 18, and 20 and three bits for the read count are depicted. Based on Figure 15, the average processor power overhead increases from about 10% to about 15%, as the cache size increases from 14 to 20. This means that a 5% power overhead is imposed to the processor for reducing the average AVF of the register file from about 3% to 1%. It should be noted that, the main causes of the power overhead are: 1) SEU/SET-tolerant FFs used in the design of the register cache; 2) the read counter used for each entry of the register cache; and 3) word matching needed for the fully associative register cache. Figure 15. The RRC Power overhead for different cache sizes To decrease the amount of power overhead, we have utilized the well known clock gating technique introduced in Section 4.2. As mentioned in Section 4, in the RRC technique, the new value is never written to the main register file. In fact, a write to the main register file occurs only when a victim value is transferred to the buffer. A value in the cache becomes victim if its cache entry is selected for storing the new computed value. It should be noted that, if the new value is written to a register already cached with an old value, the new value is overwritten to that entry and the old value is not considered as a victim value. For example, if R0 value is already stored in the cache and the processor executes a new write operation to R0, the new value is just written to the entry storing the old R0 value i.e. a victim case does not happen. Figure 16 shows the percentage of victim values for different cache sizes in different benchmarks. In other words, it shows the probability that a write operation results in a victim value. Figure 16 shows that, if the cache size is 20 (C.S. =20), only about 15% of all register write operations result in a victim value. In other words in about 85% of register write operations, the new value is written to the register that is already stored in the cache. Based on this observation, using clock gating to gate the clock of the main register file when there is no need to write a value, prevents unnecessary transitions in register file inputs resulting in considerable power reduction.  Figure 16. The average percentage of victim values as a function of Cache Size (C.S.) 8910111213141516Power Overhead(%)C.S.=20C.S.=18C.S.=16C.S.=1401020304050607080Victim Values PercentageBenchmarksC.S.=20C.S.=18C.S.=16C.S.=14978-1-4244-4421-2/09/$25.00 c(cid:13)2009 IEEE
203
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 09:56:57 UTC from IEEE Xplore.  Restrictions apply. 
 The results of power overhead of the RRC technique when using clock gating are shown in Figure 17. It can be inferred from this figure that the power overhead considerably decreases by applying the clock gating technique. For example, in the cache size of 20, the power overhead is reduced from about 15% to about 9%  using clock gating, i.e. 6% power overhead reduction. The interesting point that can be inferred from Figures 15, 16, and 17 is that the amount of reduction in power consumption decreases as the cache size decreases.   Figure 17. The RRC power overhead for different cache sizes using clock gating This means that due to the use of clock gating technique, the amount of power saving in the cache size of 20 is more than that in the cache size of say, 18. This is because; when the cache size decreases, the frequency of writing to the main register file increases (See Figure 16) resulting in lower chance of clock gating and higher dissipated power by the register file.  To show the power efficiency of the RRC technique, its power overhead is compared to other well known SEU-tolerant techniques including SEC-DED, duplication with parity and TMR techniques. In SEC-DED technique, the entire register file is protected by SEC-DED codes. In duplication with parity technique, the entire register file is duplicated and a one-bit parity is used for each register. When a value is written to a register, its parity is computed and stored in the corresponding bit. In read operation, the parity is recomputed and compared with the previously computed one. If a mismatch occurs, the duplicated version is used; otherwise the original register is utilized. In the TMR technique, the entire register file is triplicated and a voter is utilized to compare the redundant register values. Figure 18 shows processor power overheads for the mentioned techniques as well as the RRC technique with cache size of 20. As shown in this Figure, RRC with the cache size of 20 has considerably lower power overhead as compared to other mentioned techniques. The delay of the critical path increase is used as a metric for measuring performance overheads of the RRC technique. The slowest stage of the processor pipeline is considered as the critical path. To extract the delay of the critical path of the processor equipped with the RRC technique, the Synopsis design compiler tool is used. The performance overheads are extracted for the RRC technique with cache sizes of 20, 18 and 16 as well as the other SEU-tolerant techniques including SEC-DED, duplication with parity and the TMR techniques.  Figure 19 shows that the RRC technique has the lowest performance overheads compared to other soft error-tolerant techniques. It is noticeable that, the RRC technique with a cache size of 20 has negligible performance overhead of about 1%. In Figure 20, the area overhead of the RRC technique as well as the other mentioned techniques are shown. It should be noted that the area overhead is the overhead imposed to the processor not to the register file. Based on Figure 20, the RRC technique also has lower processor area overhead as compared to the other techniques.   Figure 18. The power overhead comparison results  Figure 19. The performance overhead comparison results  Figure 20. The area overhead comparison results 6. Conclusions In this paper, a technique called Robust Register Caching (RRC) that effectively utilizes circuit level and architecture level techniques to protect the register file against MBUs and SETs is proposed. In the RRC technique, the most vulnerable registers are cached in a small highly robust memory built by 4567891011Power Overhead (%)C.S.=20C.S.=18C.S.=16C.S.=140102030405060Processor Power Overhead (%)BenchmarksRRC-CS=20SEC-DEDDuplication +ParityTMR00.511.522.533.54performance overhead(%)02468101214161820Processor Area Overhead (%)978-1-4244-4421-2/09/$25.00 c(cid:13)2009 IEEE
204
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 09:56:57 UTC from IEEE Xplore.  Restrictions apply. 
 circuit level protected memory elements. The number of read operations from a register is used as a criterion for the cache replacement policy such that the victim cache entry is one which has the maximum read count. In addition, to minimize the power overhead of the RRC, the clock gating technique for the register file is efficiently exploited. The experimental results of RRC implemented on the LEON processor showed that it can significantly reduce the AVF of the register file while having low overheads in terms of power, area and performance.  References [1] J. Maiz, S. Hareland, K. Zhang, and P. Armstrong, “Characterization of Multibit Soft Error Events in Advanced SRAMs”, Proc. of IEEE Int’l Electronic Device Meeting, pp. 519-522, Dec. 2003. [2] F. X. Ruckerbauer and G. Georgakos, "Soft Error Rates in 65nm SRAMs--Analysis of new Phenomena," Proceedings of the 13th IEEE International On-Line Testing Symposium, pp. 203-204, 2007. [3] P. Shivakumar, M. Kistler, S. W. Keckler, D. Burger, and L. Alvisi, "Modeling the effect of technology trends on the soft error rate of combinational logic," Proceedings of International Conference on Dependable Systems and Networks, 2002. pp. 389-398, 2002. [4] A.J. Drake, A. KleinOsowski, A.K. Martin, "A Self- Correcting Soft Error Tolerant Flop-Flop", 12th NASA Symposium on VLSI Design, Coeur d’Alene, Idaho, USA, Oct. 4-5, 2005. [5] A. Ejlali, B.M. Al-Hashimi, M.T. Schmitz, P. Rosinger, S.G. Miremadi, “Combined Time and Information Redundancy for SEU-tolerance in Energy-Efficient Real-Time Systems,” IEEE Trans. on Very Large Scale Integration Systems,  Vol. 14, No. 4, pp. 323-335, April 2006. [6] P. Montesinos, W. Liu, J. Torrellas, “Using Register ACE time Predictions to Protect Register Files Against Soft Errors,” IEEE Transactions on Dependable and Secure Computing (IEEE TDSC), To Appear, 2008. [7] P. Montesinos, W. Liu, J. Torrellas, “Using Register ACE time Predictions to Protect Register Files Against Soft Errors,” Proc. of 37th International Conference on Dependable Systems and Networks (DSN), June 2007. [8] J. Gaisler, “Evaluation of a 32-bit Microprocessor with Built-In Concurrent Error-Detection,” in International Symposium on Fault-Tolerant Computing, 1997. [9] T. Slegel, I. Averill, R.M., M. Check, B. Giamei, B. Krumm, C. Krygowski, W. Li, J. Liptay, J. MacDougall, T. McPherson, J. Navarro, E. Schwarz, K. Shum, and C. Webb, “IBM’s S/390 G5 Microprocessor Design,” IEEE Micro, vol. 19, 1999. [10] J. Kim, N. Hardavellas, K. Mai, B. Falsafi, J. C. Hoe, “Multi-bit Error Tolerant Caches Using Two-Dimensional Error Coding”, Proceedings of the 40th Annual ACM/IEEE International Symposium on Microarchitecture (MICRO-40). [11] M. Fazeli, A. Patooghy, S. G. Miremadi, A. Ejlali, “Feedback Redundancy: A Power-Aware SEU-Tolerant Latch Design in DSM Technologies,” Proc. of the IEEE/IFIP Int’l. Conference on Dependable Systems and Networks, Edinburg, UK, June 2007, pp. 276-285. [12] M. Omana, D. Rossi, C. Metra, “Latch Susceptibility to Transient Faults and New Hardening Approach,” IEEE Trans. on Computers, Vol. 56, No. 9, pp. 1255-1268, September 2007. [13] P. Hazucha, T. Karnik, S. Walstra, B. Bloechel, J. Tschanz, J. Maiz, K. Soumyanath, G. Dermer, S. Narendra, V.De, S. Borkar, “Measurements and analysis of SER tolerant latch in a 90-nm dual-Vt CMOS process”, IEEE Custom Integrated Circuits Conference, Page(s):617 – 620, 2003. [14] N. Seifert, P. Slankard, M. Kirsch, B. Narasimham, V. Zia, C. Brookreson, A. Vo, S. Mitra, B. Gill1, J. Maiz, “Radiation-Induced Soft Error Rates of Advanced CMOS Bulk Devices”, Proceedings of the IEEE International Physics Symposium, pp. 217-225, 2006. [15] A. Dutta, N. A. Touba, "A Low Cost Code-Based Methodology for Tolerating Multiple Bit Upsets in Memories," IEEE Workshop on System Effects of Logic Soft Errors, Apr. 2007. [16] J. Patel, "Characterization of Soft Errors Caused by Single Event Upsets in CMOS Processes," IEEE Transactions on Dependable and Secure Computing, vol. 1, no. 2, pp. 128-143, 2004. [17] S.S. Mukherjee, C. Weaver, J. Emer, S. K. Reinhardt, T. Austin, "A Systematic Methodology to Compute the Architectural Vulnerability Factors of a High-Performance Microprocessor," Proc. of 36th Int'l Symposium on  Microarchitecture (MICRO-36), IEEE CS Press, 2003. [18]   M. Fazeli, S. G. Miremadi, A. Ejlali, A. Patooghy, "A Low Energy SEU/SET-Tolerant Latch for Deep Sub Micron Technologies", To appear in the Journal of IET Computers & Digital Techniques. [19] S. Mitra, M. Zhang, N. Seifert, T.M. Mak, S. K. Kee, “Soft Error Resilient System Design through Error Correction,” Proc. of IFIP Int’l. Conference on Very Large Scale Integration, October 2006, PP. 332-337. [20] W. Wang, H. Gong, “Edge Triggered Pulse Latch Design With Delayed Latching Edge for Radiation Hardened Application,” IEEE Trans. on Nuclear Science, Vol. 51, No. 6, pp. 3626-3630, December 2004.  [21] J. M. Benedetto, P. H. Eaton, D. G. Mavis, M. Gadlage, T. Turflinger, “Variation of Digital SET Pulse Widths and the Implications for Single Event Hardening of  Advanced CMOS Processes”, IEEE Trans. on Nuclear Science, Vol. 52, No. 6, pp. 2114-2119, December 2005. [22] Gaisler Resarch. Leon2 Processor User's Manual, Version 1.0.30, XST Edition. July 2005. [23] R. Yung, N.C. Wilhelm, “Caching processor general registers”, Proceedings of International Conference on Computer Design (ICCD,95), PP. 307-312, Oct. 1995. [24] J. A. Butts, G. S. Sohi, “Use-based register caching with decoupled indexing,” Proceedings of the 31st Annual International Symposium on Computer Architecture (ISCA’04), PP. 302-313, June 2004. [25] Matthew R. Guthaus, Jeffrey S. Ringenberg, Dan Ernst, Todd M. Austin, Trevor Mudge, Richard B. Brown, “MiBench: A free, commercially representative embedded benchmark suite”, IEEE 4th Annual Workshop on Workload Characterization, Austin, TX, December 2001. [26] J. Blome, S. Gupta, S. Feng, S. Mahlke, and D. Bradley, "Cost efficient soft error protection for embedded microprocessors," Proc. of the Int’l conference on Compilers, architecture, and synthesis for embedded systems, 2006, pp. 421-431.