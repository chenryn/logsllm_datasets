attacker can only execute its DoS attack during a short period, e.g.,
for few seconds.
As described in Section 2, PLCs executes control logic program in
a program scan cycle. Due to real-time nature of PLC runtime, the
number of CPU cycles it uses in every program scan cycle is limited
and predictable. Therefore, with the help of a learning mode, it is
possible to establish a pattern of normal CPU cycle usage in a PLC
program scan. The learning mode captures worse CPU cycle usage
of the PLC scan cycle. We can then compare the number of CPU
cycles consumed by the PLC runtime during program scan with
the values extracted in the learning mode. In the case of significant
contradiction (more than 10 percent) between the worst CPU cycle
usage in a PLC program scan cycle at the learning mode and at
runtime, ECFI raises an alert. To calculate the number of CPU scan
cycles consumed in a PLC program scan we use the Performance
Monitoring Unit (PMU) of the ARM architecture. Note that ECFI
does not utilize PMU to detect control-flow violations, but to detect
possible malicious overwrite in the ring buffer.
Adaptive Scheduling in RTOS. Adaptive scheduling is a concept
in RTOS in which the OS scheduler guarantees a certain amount
of resources (e.g., CPU cycles) to an application when a resource
constraint occurs. Adaptive scheduling is nothing new in RTOS
domain [15]. Since adaptive scheduling can guarantee a certain
amount of CPU cycles by setting a threshold (e.g., 20%) for the
checker application, we can reduce (but not eliminate) the chance
of ring buffer overwrite and increase the number of checking oper-
ation at the time of high CPU load in a PLC. We will discuss using
adaptive scheduling to eliminate the possibility of deceiving ECFI
by overwriting the ring buffer in Section 5.4.
4 ECFI IMPLEMENTATION DETAILS
Based on the design described in the previous section, we now
present several technical details of our implementation
4.1 Target Platform
As a basis for our prototype implementation, we choose a WAGO
PFC200 750-8202 PLC. It is a modular PLC with a 600MHz single-
core 64bit ARM Cortex A8 CPU and 256 megabytes of RAM and a
WAGO 750-1506 8-Channel Digital I/O module attached to it. WAGO
PLC runs on Pengutronix Real-Time Linux with a PREEMPT RT
Kernel 3.18.13.
For the PLC runtime, we could not use the Codesys runtime
(standard WAGO PLC runtime) since the vendor informed us that
they could only provide the source code to the OEMs (Original
Equipment Manufacturers). Therefore, we choose OpenPLC [35]
runtime. OpenPLC is the first fully functional standardized open
source PLC runtime with real-time responses.
OpenPLC has several components including a graphical Inte-
grated Development Environment (IDE) called PLCOpen. PLCOpen
is used for writing Structured Text (ST) control logic on a PC and
transferring the resultant binary logic generated by MatIEC com-
piler [47] to the PLC. Additionally, OpenPLC runs a NodeJS web
interface for SCADA servers to retrieve and visualize data from
the PLC runtime. Finally, OpenPLC includes a PLC runtime en-
gine executing uploaded control logic within the PLC. Similarly to
the Codesys runtime, OpenPLC converts the ST language control
logic to a binary file on a programming (engineering) station before
uploading it to a PLC.
Concerning real-time settings, in our experiments, we set the
OpenPLC priority to 99 (highest possible value) while the ECFI
checker priority was running on a non-real-time default process
priority.
4.2 CFG Generation and HotsiteID
4.2.1 CFG Generation. ECFI uses the compiler to generate ac-
curate CFG of the PLC runtime and the control logic. The result
gives us a complete CFG which can cover the entire control-flow
of the PLC runtime and control logic.
4.2.2 ECFI CFG Metadata Injection. To cope with ASLR, during
the CFG generation, ECFI also analyzes the instrumented OpenPLC
runtime and extracts BB offsets and function addresses and the
distance between each BB via the symbols table of the application
binary. The extracted information is added to the CFG. We use this
information later to calculate all valid function relative addresses
for CFG checking. The updated graph is reprocessed, and an iden-
tification number named as HotsiteID added to it. The HotsiteID
is a unique ID of instrumented basic blocks. Each BB has a unique
HotsiteID which will be used by the Code-Parser Injector (CPI)
module of ECFI to determine instrumentation location. Also, the
HotsiteID is being used by our checker application to immediately
identify the location of the application execution flow in the CFG.
4.3 Instrumenting OpenPLC
In our approach, we perform instrumentation of the PLC runtime at
compile time. This task does not require the high-level code of the
application (e.g., C code); instead, we use the assembly code of the
OpenPLC. It is worth mentioning that since ECFI does not require
high-level source code of the application, it makes it feasible to
use ECFI as a binary-based CFI solution in the future. In ECFI, we
instrument every indirect function call and function return address
in the OpenPLC assembly code (see also Figure 4).
Instrumentation Instructions. Instrumentation instructions are a
set of light ARM assembly instructions which pass the control flow
information to our ring buffer. We developed the following three
types of instrumentation instructions:
• The setup code is an assembly code injected immediately
after the function prologue in main(). This code makes the
ring buffer shadow stack (created by the checker) accessible
in the application memory. Once the ring buffer becomes
accessible, the setup code passes the main() address to the
ring buffer. Using the main() address combined with the
metadata of our CFG, ECFI can calculate all other functions
addresses. The calculation of all other function addresses is
an essential task when the PLC OS has an implementation
for ASLR.
• Function epilogue instrumentation instruction (backward
edge monitor): the function epilogue instrumentation in-
struction passes values of the Frame Pointer(FP) or $LR reg-
isters (depending on the function epilogue generated by the
compiler) and the HotSiteID to the ring buffer shadow stack.
ECFI: Asynchronous Control Flow Integrity for Programmable Logic Controllers
ACSAC 2017, December 4–8, 2017, San Juan, PR, USA
Finally, the CPI module searches for the beginning of the main
function and inserts the setup code right after the function prologue.
4.4 Ring Buffer and CFG Check
The ring buffer consists of three parts: The read offset, the write
offset, and the actual data buffer. The read offset contains informa-
tion about the location that the checker has to read the data from
the ring buffer. The read offset is being maintained by the checker
application which also holds a copy of the last read buffer in its
internal memory. The write buffer is being maintained by the in-
strumentation instruction. The performance counter offset contains
the number of CPU cycles in every PLC program scan cycle and is
managed by the instrumentation instruction inside the OpenPLC
runtime. The buffer size is 1024 bytes. This lets the instrumentation
instruction write 128 times to the buffer before the checker needs
to run and read it. There is no enforcement for the checker to run
even after 128 times (due to real-time requirements). It is worth
mentioning that we set the ring buffer size to 1024 bytes based on
several experiments on OpenPLC and available resources in the
Wago PLC. One can change the size of the ring buffer based on the
resources available within the PLC. This value is small enough for
the checker to quickly read the buffer and large enough to let the
real-time application to run without concern for overwriting the
ring buffer data.
Initialization of the Ring Buffer. Once the CFG checker executes,
it creates the ring buffer shadow stack. After that, the checker loads
the CFG that contains destination targets and control flow data.
Note that the CFG gets loaded at the beginning of the execution of
the checker and is loaded into checker memory. Subsequently, the
checker replaces the source addresses with previously generated
HotsiteID numbers inside its internal memory. In the next step,
the checker application reads the main function address from the
shadow stack and calculates all functions base addresses via pre-
viously calculated offsets from the application binary (using CFG
metadata). The function base addresses are utilized by the checker
to calculate all valid return addresses, and indirect function calls
destination address from determined HotsiteID. This initial process
makes our CFG verification faster.
CFG Checks. At this stage, the checker is ready to read any data
forwarded to the ring buffer and to verify it with the target ad-
dresses listed in the checker. Every time the OS runs the checker,
the checker will read all written values in the ring buffer and verify
the destination or return addresses.
The entire process of write and read operations is illustrated in
Figure 5. In the first step, the instrumentation instruction will write
the control-flow data (the HotSiteID and destination or return ad-
dress) to the shadow stack, but the operating system does not have
resources yet to initiate the checker application (see Figure 5.A).
While the checker waits for the resource, the PLC runtime con-
tinues its tasks (executing control logic) and the instrumentation
instruction will write the control-flow data to the ring buffer and
update the write offset (Figure 5.B). Once the resources become
available, the checker application runs and reads every data in the
Figure 4: ARM Application instrumentation by CPI module.
• Indirect function call instrumentation instruction (forward
edge monitor): the indirect function call instrumentation
instruction passes the call target destination to the ring buffer
alongside the HotsiteID. The HotSiteID is added by the CPI
module to the assembly code of the PLC runtime at the next
stage.
Code Parser-Injector. The Code Parser-Injector (CPI) component
parses the ARM assembly code of the application to select the loca-
tions to inject instrumentation code. The CPI will also take care of
relocation data by inserting a new label for program variables into
the assembly code. In particular, within the application assembly
code, the CPI locates the function epilogues for backward-edge
monitoring, and indirect function calls for forward-edge monitor-
ing. Besides, the CPI searches for any instructions that modify the
PC. Figure 4 illustrate the locations where the CPI module inserts
instrumentation instructions.
• On the ARM architecture, we identify indirect function calls
by spotting a BLX instruction. Once the CPI identifies an indi-
rect branch, it first reads the register used by the instruction
for the indirect function call. This register can be different in
program assembly code (it can be either r3, r2, etc). There-
fore, the CPI module updates the instrumentation instruction
according to the register used for the indirect function call.
The CPI also inserts the HotsiteID that corresponds to the
BB using the information in the CFG.
• Those instructions that modify PC directly are instrumented
with the same code that is used for indirect function calls.
• For returns, the CPI looks for various type of instructions
that are being used in ARM assembly. In particular, ECFI
looks for LDMFA, BX LR, or POP R11, PC instructions. Once
ECFI finds the desired instructions, it updates the instru-
mentation instruction with the register that holds the return
address. The return address register can be different in dif-
ferent functions. For example, for passing the return address
to the ring buffer, we replace the LR with a R11 or vice versa,
depending on the assembly code generated by the compiler
for function epilogue.
Instruction 10Instruction 11...BLX .......Instruction 20BX LRPOP {R11, PC}LDMFD SP!, {FP, PC}LDR/ADR PC RegX2Instruction 10Instruction 11Instrumentation CodePass HotsiteID and Destination Address  (RegX value)BLX ....Instruction 30Instrumentation CodePass HotsiteID and Return Address valueBX LRPOP {R11, PC}LDR/ADR PC, RegX2Instrumentation CodePass HotsiteID and RegX2 valueOriginal ARM ApplicationInstrumented ARM ApplicationPush R0 (If function returns something)Pop R0 (If function returns something)Copy LR/FP value to R0Load HotsiteID to R1Update Write offset Store R0, R1 in Write offset + Beginning of BufferCopy RegX /RegX1 to R0Load HotsiteID to R1Update Write offsetStore R0, R1 into Write Offset + Beginning of BufferPush R0, R1Pop R0, R1MagnifierMagnifierInstrumentation In ARM ArchitectureACSAC 2017, December 4–8, 2017, San Juan, PR, USA
Ali Abbasi, Thorsten Holz, Emmanuele Zambon, and Sandro Etalle
ring buffer, up to the location where the write offset points (Fig-
ure 5.C). At this stage, the checker verifies the control-flow data
with the CFG or waits until the resources become available again.
Since ECFI does not block overwrites to the ring buffer and
does not forcefully run the checker once the ring buffer becomes
full, this creates an attack surface. To detect malicious overwrites
to the ring buffer (e.g., during a DoS attack), ECFI uses the ARM
PMU capabilities. We pre-calculate the range of CPU cycle in every
program scan cycle of the PLC runtime. Each time the checker runs,
it reads all the written values of the CPU cycles of the PLC and
divides it by the number of PLC program scan cycles carried out
by the PLC. To determine how many scan cycles was performed by
the PLC runtime while checker process was waiting for resources
we use the system time. Everytime ECFI checker checks the CFG,
it stores the system time in its internal buffer. In the next round
of check, the checker first gets the current time and then read the
previously stored time from its internal buffer. The checker then
divides the elapsed time to the duration of program scan cycle
in the PLC which is a fixed value (e.g., the program scan cycle is
happening every five milliseconds). The checker at this point knows
how many PLC program scan cycle was executed during since the
last check. The checker then reads the PMU values for CPU cycles
consumed since the previous check and divide it by the number of
CPU cycles executed in the PLC (since the last check). The checker
then compares this value with our acceptable CPU cycle count per
program scan cycle. If it is more than our acceptable range, ECFI
raises an alert for ring buffer overwrite.
Calculating the accurate range of CPU cycle is achievable in
the PLC environment where the PLC OS is a Real-Time system
compared to other operating systems. To calculate acceptable PLC
program scan cycle, we store the CPU cycles of one thousand it-
erations of our logic. It is important to note that we do not use
the PMU counters to detect control-flow attacks against the PLC
runtime. Instead, we use it to detect malicious overwrites to the
ring buffer shadow stack. Additionally, it is worth mentioning that
we do not set up any interrupt handlers for the CPU cycle event.
5 EVALUATION
Unlike general-purpose computers and other embedded systems
CFI, we do not represent our evaluation based on average per-
formance overhead. Instead, we use worst observed overhead in
multiple runs for our evaluation. The general average performance
overhead does not necessarily mean the satisfaction of system time-
liness. For example, SPEC is an industry standard benchmarking
tool which is extensively employed in the majority of CFI systems
to evaluate their performance overhead. However, SPEC provides
average performance penalty and no worst-case performance of
the application. Additionally, in the case of SPEC, we cannot even