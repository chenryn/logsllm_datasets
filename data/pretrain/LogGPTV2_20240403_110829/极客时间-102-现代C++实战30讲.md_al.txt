# 07 \| 迭代器和好用的新for循环你好，我是吴咏炜。 我们已经讲过了容器。在使用容器的过程中，你也应该对迭代器（iterator）或多或少有了些了解。今天，我们就来系统地讲一下迭代器。 什么是迭代器？迭代器是一个很通用的概念，并不是一个特定的类型。它实际上是一组对类型的要求（\[1\）。它的最基本要求就是从一个端点出发，下一步、下一步地到达另一个端点。按照一般的中文习惯，也许"遍历"是比"迭代"更好的用词。我们可以遍历一个字符串的字符，遍历一个文件的内容，遍历目录里的所有文件，等等。这些都可以用迭代器来表达。 我在用 output_container.h 输出容器内容的时候，实际上就对容器的 `begin` 和 `end`成员函数返回的对象类型提出了要求。假设前者返回的类型是I，后者返回的类型是S，这些要求是： 1.  I 对象支持         `*`    操作，解引用取得容器内的某个对象。        2.  I 对象支持         `++`，指向下一个对象。        3.  I 对象可以和 I 或 S    对象进行相等比较，判断是否遍历到了特定位置（在 S    的情况下是是否结束了遍历）。        注意在 C++17 之前，`begin` 和 `end` 返回的类型 I 和 S 必须是相同的。从 C++17 开始，I 和 S可以是不同的类型。这带来了更大的灵活性和更多的优化可能性。 上面的类型 I，多多少少就是一个满足输入迭代器（inputiterator）的类型了。不过，output_container.h 只使用了前置`++`，但输入迭代器要求前置和后置 `++`都得到支持。 输入迭代器不要求对同一迭代器可以多次使用 `*`运算符，也不要求可以保存迭代器来重新遍历对象，换句话说，只要求可以单次访问。如果取消这些限制、允许多次访问的话，那迭代器同时满足了前向迭代器（forwarditerator）。 一个前向迭代器的类型，如果同时支持`--`（前置及后置），回到前一个对象，那它就是个双向迭代器（bidirectionaliterator）。也就是说，可以正向遍历，也可以反向遍历。 一个双向迭代器，如果额外支持在整数类型上的`+`、`-`、`+=`、`-=`，跳跃式地移动迭代器；支持`[]`，数组式的下标访问；支持迭代器的大小比较（之前只要求相等比较）；那它就是个随机访问迭代器（random-accessiterator）。 一个随机访问迭代器 `i` 和一个整数 `n`，在 `*i` 可解引用且 `i + n` 是合法迭代器的前提下，如果额外还满足`*(addressdof(*i) + n)` 等价于`*(i + n)`，即保证迭代器指向的对象在内存里是连续存放的，那它（在C++20 里）就是个连续迭代器（contiguousiterator）。 以上这些迭代器只考虑了读取。如果一个类型像输入迭代器，但 `*i`只能作为左值来写而不能读，那它就是个输出迭代器（outputiterator）。 而比输入迭代器和输出迭代器更底层的概念，就是迭代器了。基本要求是： 1.  对象可以被拷贝构造、拷贝赋值和析构。        2.  对象支持         `*` 运算符。        3.  对象支持前置         `++` 运算符。        迭代器类型的关系可从下图中全部看到： ![](Images/00eba1c57fe8bdf64e0bbdc4dcc6e412.png)savepage-src="https://static001.geekbang.org/resource/image/dd/5a/dd25c3f074fe0b792dddecfd15f74e5a.png"}迭代器通常是对象。但需要注意的是，指针可以满足上面所有的迭代器要求，因而也是迭代器。这应该并不让人惊讶，因为本来迭代器就是根据指针的特性，对其进行抽象的结果。事实上，`vector`的迭代器，在很多实现里就直接是使用指针的。 常用迭代器最常用的迭代器就是容器的 `iterator`类型了。以我们学过的顺序容器为例，它们都定义了嵌套的 `iterator` 类型和 `const_iterator`类型。一般而言，`iterator`可写入， `const_iterator`类型不可写入，但这些迭代器都被定义为输入迭代器或其派生类型：1.  `vector::iterator` 和         `array::iterator`    可以满足到连续迭代器。        2.  `deque::iterator`    可以满足到随机访问迭代器（记得它的内存只有部分连续）。        3.  `list::iterator`    可以满足到双向迭代器（链表不能快速跳转）。        4.  `forward_list::iterator`    可以满足到前向迭代器（单向链表不能反向遍历）。        很常见的一个输出迭代器是 `back_inserter` 返回的类型`back_inserter_iterator`了；用它我们可以很方便地在容器的尾部进行插入操作。另外一个常见的输出迭代器是`ostream_iterator`，方便我们把容器内容"拷贝"到一个输出流。示例如下：    #include   // std::copy    #include    // std::back_inserter    #include      // std::vector    using namespace std;    vector v1{1, 2, 3, 4, 5};    vector v2;    copy(v1.begin(), v1.end(),         back_inserter(v2));    v2>  > `{ 1, 2, 3, 4, 5 }`>    #include   // std::cout    copy(v2.begin(), v2.end(),         ostream_iterator(cout, " "));>  > `1 2 3 4 5`>使用输入行迭代器下面我们来看一下一个我写的输入迭代器。它的功能本身很简单，就是把一个输入流（`istream`）的内容一行行读进来。配上 C++11 引入的基于范围的for循环的语法，我们可以把遍历输入流的代码以一种自然、非过程式的方式写出来，如下所示：    for (const string& line :         istream_line_reader(is)) {      //  示例循环体中仅进行简单输出      cout () const noexcept        {          return &line_;        }        iterator& operator++()        {          getline(*stream_, line_);          if (!*stream_) {            stream_ = nullptr;          }          return *this;        }        iterator operator++(int)        {          iterator temp(*this);          ++*this;          return temp;        }      private:        istream* stream_;        string line_;      };      …    };我们定义了默认构造函数，将 `stream_`清空；相应的，在带参数的构造函数里，我们根据传入的输入流来设置`stream_`。我们也定义了 `*` 和 `->`运算符来取得迭代器指向的文本行的引用和指针，并用 `++`来读取输入流的内容（后置 `++` 则以惯常方式使用前置 `++`和拷贝构造来实现）。唯一"特别"点的地方，是我们在构造函数里调用了`++`，确保在构造后调用 `*`运算符时可以读取内容，符合日常先使用 `*`、再使用 `++`的习惯。一旦文件读取到尾部（或出错），则 `stream_`被清空，回到默认构造的情况。对于迭代器之间的比较，我们则主要考虑文件有没有读到尾部的情况，简单定义为：        bool operator==(const iterator& rhs)          const noexcept        {          return stream_ == rhs.stream_;        }        bool operator!=(const iterator& rhs)          const noexcept        {          return !operator==(rhs);        }有了这个 `iterator`的定义后，`istream_line_reader`的定义就简单得很了：    class istream_line_reader {    public:      class iterator {…};      istream_line_reader() noexcept        : stream_(nullptr) {}      explicit istream_line_reader(        istream& is) noexcept        : stream_(&is) {}      iterator begin()      {        return iterator(*stream_);      }      iterator end() const noexcept      {        return iterator();      }    private:      istream* stream_;    };也就是说，构造函数只是简单地把输入流的指针赋给 `stream_`成员变量。 `begin`成员函数则负责构造一个真正有意义的迭代器；`end`成员函数则只是返回一个默认构造的迭代器而已。以上就是一个完整的基于输入流的行迭代器了。这个行输入模板的设计动机和性能测试结果可参见参考资料\[3\ 和 \[4\；完整的工程可用代码，请参见参考资料\[5\。该项目中还提供了利用 C 文件接口的 file_line_reader和基于内存映射文件的mmap_line_reader。内容小结今天我们介绍了所有的迭代器类型，并介绍了基于范围的 for循环。随后，我们介绍了一个实际的输入迭代器工具，并用它来简化从输入流中读入文本行这一常见操作。最后，我们展示了这个输入迭代器的定义。课后思考请思考一下：1.       目前这个输入行迭代器的行为，在什么情况下可能导致意料之外的后果？        2.       请尝试一下改进这个输入行迭代器，看看能不能消除这种意外。如果可以，该怎么做？如果不可以，为什么？        欢迎留言和我交流你的看法。参考资料\[1\] cppreference.com, "Iterator library".https://en.cppreference.com/w/cpp/iteratorslate-object="mark"} \[1a\] cppreference.com, "迭代器库".https://zh.cppreference.com/w/cpp/iteratorslate-object="mark"} \[2\] Jonathan Boccara, "std::iterator is deprecated: why, what itwas, and what to use instead". slate-object="mark"}https://www.fluentcpp.com/2018/05/08/std-iterator-deprecated/slate-object="mark"} \[3\] 吴咏炜, "Python slate-object="mark"}`yield`[ and C++ coroutines".https://yongweiwu.wordpress.com/2016/08/16/python-yield-and-cplusplus-coroutines/slate-object="mark"} \[4\] 吴咏炜, "Performance of my line readers".https://yongweiwu.wordpress.com/2016/11/12/performance-of-my-line-readers/slate-object="mark"} \[5\] 吴咏炜, nvwa. slate-object="mark"}https://github.com/adah1972/nvwa/slate-object="mark"} 