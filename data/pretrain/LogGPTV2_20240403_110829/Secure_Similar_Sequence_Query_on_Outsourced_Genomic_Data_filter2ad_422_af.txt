computes the exact edit distance between ul, j and Si,l . D1
constructs a distance set L1, in which the element L1[l, j, i] =
ED(ul, j , Si,l )(1 ≤ l ≤ t, 1 ≤ j ≤ v1, 1 ≤ i ≤ m).
After that, DO1 partitions all elements in D1,T1, and L1 using the
genomic sequence secret sharing method shown in Section 5.1.1,
and then uploads them to the servers.
DO2, · · · , DOw do the same as DO1. Note that we assume all the
sequences are of the same length, and the numbers of partitions
for all sequences are t. After all data owners outsource their data,
A and B aggregate these for maintaining a genomic database D
jointly as follows:
where m =
ω
D = ((cid:4)D1(cid:5) , · · · , (cid:4)Dw (cid:5)) = ((cid:4)S1(cid:5) , · · · , (cid:4)Sm (cid:5)),
T = ((cid:4)T1(cid:5) , · · · , (cid:4)Tw (cid:5)), L = ((cid:4)L1(cid:5) , · · · , (cid:4)Lw (cid:5)).
mi . In addition, A and B also hold
i =1
5.2 SSQ-II (with the Approximate Edit
Distance)
The above SEED protocol is an iterative process, which is hard to
boost the performance. In SSQ-II, we leverage the approximate edit
distance computation [3] (described in section 2.1) to improve the
performance of SSQ-I. For brevity, we just present the changed
parts.
In this stage, all computations of data owners are a one-time cost,
that is, the elements in D,T , L could be reused for multiple query
processes.
5.2.2
Stage 2: Query request issuing. The query user breaks the
query sequence Q into t blocks to get Q = (Q1, · · · , Qt ) by Break-
ToBlocks algorithm, then partitions Q to obtain (cid:4)Q(cid:5) = ((cid:4)Q1(cid:5) , · · · ,
(cid:4)Qt (cid:5)). After that, the user sends (cid:4)Q(cid:5) to servers.
5.2.1
Stage 1: Genomic data outsourcing. We assume there are
ω data owners DO1, · · · , DOw . For DO1, given a set of genomic
sequences D1 = (S1, · · · , Sm1
), he/she proceeds as follows:
(1) Use BreakToBlocks3 algorithm to break each sequence into t
blocks. For the set D1, DO1 sets the sequence Si = (Si,1, · · · ,
Si,t ) = BreakToBlocks(Si ) for all i = 1, · · · , m1.
3It is a partition algorithm for genomic data over plaintext, we refer the reader to [3]
for details.
5.2.3
Stage 3: Secure Query Executing. Recall that χl, j indicates
whether or not ul, j == Ql . When two servers receive the request
from the user, we compute the shares of the indicator bits
by
SAGSC protocol. For Si ∈ D1, according to Equation 3, A and B
can easily compute approximate edit distance (cid:4)di (cid:5) between Q and
t1
v1
Si (1 ≤ i ≤ m1) as follows:
χl, j
(cid:3)
(cid:4)
(cid:4)
(cid:3)
(cid:3)
(cid:4)
(cid:4)di (cid:5) ≈
χl, j
·
ED(ul, j , Si,l )
,
l =1
j=1
This  is  an  author-produced,  peer-reviewed  version  of  this  article.  The  final,  definitive  version  of  this  document  can  be  found  online  at  ASIACCS  '18:
Proceedings of the 2018 on Asia Conference on Computer and Communications Security, published by Association for Computing Machinery. Copyright
restrictions may apply. doi: 10.1145/3196494.3196535
(cid:3)
(cid:4)
ED(ul, j , Si,l )
where
is pre-computed by the data owner and sent
to the servers for store. For Si ∈ {D2, · · · , Dw }, A and B do the
same. After that, A and B hold (cid:4)di (cid:5) (1 ≤ i ≤ m), the remaining
steps are the same as that in SSQ-I. We describe this secure query
in Algorithm 8.
5.2.4
Stage 4: Result Recovering. This stage is the same as that
in SSQ-I.
6 THEORETICAL ANALYSIS
In this section, we first analyze the security of the sub-protocols
and our two SSQ protocols, and then present their computational
complexity.
6.1 Security Analysis
The security of secure query protocols in SSQ-I and SSQ-II is assured
by the following theorems:
Theorem 6.1. If SSF, SEED protocols, and ADD-CMP are secure
under the semi-honest adversaries model, then secure query protocol
in SSQ-I is secure under the semi-honest adversaries model.
Theorem 6.2. If SSF, SAGSC protocols and ADD-CMP are secure
under the semi-honest adversaries model, then secure query protocol
in SSQ-II is secure under the semi-honest adversaries model.
In order to prove the above theorems, we first give security
proofs of our sub-protocols including SSF, SBC, SMS, SEED and
SAGSC protocols, and then employ composition theory [15]. The
detailed proofs and discussions can be found in Appendix B.
6.2 Performance Analysis
We analyze the computational complexity of our protocols and
show the analysis results in the Table 2. The detailed analysis can
be found in Appendix C.
Table 2: Computational Complexity of Existing Solutions
and Ours (σ is the statistical security parameter in [26])
Solutions
SSF/[26]
SBC/[26]
SMS/[26]
SEED
SAGSC
SSQ-I
SSQ-II
Enc
2n/4n
8/16
2n/3n
22n1n2
−
Dec
2n/n
8/4
2n/n
22n1n2
−
Mul
n/2n
4/8
n/3n
11n1n2
−
non-XOR gates
−
3(cid:2)/3(cid:2) + 3σ + 1
3(cid:2)(n − 1)/
(3(cid:2) + 3σ + 1)(n − 1)
12(cid:2)n1n2
2(cid:2) − 1
O(mn2) O(mn2) O(mn2)
O(n)
O(n)
O(n)
O(m(cid:2)(n2 + k ))
O(m(cid:2)(tv + k ))
7 EXPERIMENTAL EVALUATION
In this section, we evaluate the performance of our protocols. As
there is no full implementation for secure SSQ on outsourced ge-
nomic data so far, we conduct two sets of experiments: in the first,
we compare our sub-protocols with the state-of-the-art protocols,
and in the second we implement our two SSQ schemes based on
our sub-protocols and report the performance of SSQ-I and SSQ-II.
(a) SSF
(b) SBC
(c) SMS
(cid:3)(cid:50)(cid:73)(cid:73)(cid:79)(cid:76)(cid:81)(cid:72)
(cid:3)(cid:50)(cid:81)(cid:79)(cid:76)(cid:81)(cid:72)
(cid:3)(cid:62)(cid:21)(cid:25)(cid:64)
(cid:3)(cid:62)(cid:28)(cid:64)
(cid:21)(cid:19)(cid:19)(cid:19)
(cid:20)(cid:24)(cid:19)(cid:19)
(cid:20)(cid:19)(cid:19)(cid:19)
(cid:24)(cid:19)(cid:19)
(cid:86)
(cid:71)
(cid:81)
(cid:82)
(cid:70)
(cid:72)
(cid:86)
(cid:29)
(cid:72)
(cid:80)
(cid:55)
(cid:76)
(cid:19)
(cid:20)(cid:19)
(cid:24)(cid:19)
(cid:47)(cid:72)(cid:81)(cid:74)(cid:87)(cid:75)(cid:3)(cid:82)(cid:73)(cid:3)(cid:87)(cid:75)(cid:72)(cid:3)(cid:86)(cid:72)(cid:84)(cid:88)(cid:72)(cid:81)(cid:70)(cid:72)(cid:86)(cid:3)(cid:11)(cid:81)(cid:12)
(cid:21)(cid:19)
(cid:22)(cid:19)
(cid:23)(cid:19)
(d) SEED
(e) SAGSC
Figure 3: The performance of the protocols.
We implemented our protocols in Java, specifically, Paillier cryp-
tosystem with distributed decryption was achieved by BigInteger
Class and Yao’s garbled circuits are constructed by FastGC [18],
which applies the free-XOR technique [24] and oblivious-transfer
extension [20] for optimizations. Our experiments are conducted
on two Amazon EC2 t2.large machines (as server A and B) running
Ubuntu 16.04, with 8GB of RAM each, and a laptop (as the data
owner and user) running Linux 16.04, with 1.70-GHz Intel i5-3317U
CPU and 4 GB of memory. The communication bandwidth between
the two machines for LAN setting is set to 1 GB/s and the average
network latency is 0.037 ms. In our experiment, we used Homo
Sapiens Mitochondrion Complete Genome dataset [30] that consists
of 1,046 genomic sequences and the length of each one is 16568.
We report the results for both the offline and online time. The
offline phase includes all computation and communication that
are independent of the input (e.g. The generation of multiplication
triplets, the construction of garbled circuits and offline part in SSF
protocol), while online phase consists of all input-dependent steps.
7.1 Our Protocols vs. Previous Protocols
We compare our protocols with the ones in a previous work [26]
over the real-world dataset. Recall that this work, which focuses on
the secure similarity computation upon trajectory data, achieves
the same functions as part of our protocols with a similar security
level. For a fair comparison, we implement SSF protocol without
data packing technology [6]. We also set public-key security pa-
rameter (i.e., the length of N ) φ = 2048, and the symmetric security
parameter κ = 128 for garbled circuits.
We first compare SSF protocol with the previous protocol in [26]
for varying length of the sequences (i.e., n from 200 to 1000). As
shown in Figure 3(a), the time cost in our protocol and previous pro-
tocol [26] increases linearly with the length of sequences n, which
is consistent with our complexity analysis. There is a little gap
between the offline time in SSF protocol and the time in previous
protocol, but the online time in our protocol has remarkable ad-
vantages, as it does not involve any time-consuming cryptographic
operation.
Figure 3(b) presents the time cost in SBC protocol and the previ-
ous protocol [26] as the bit length of data ((cid:2)) increases. The time cost
This  is  an  author-produced,  peer-reviewed  version  of  this  article.  The  final,  definitive  version  of  this  document  can  be  found  online  at  ASIACCS  '18:
Proceedings of the 2018 on Asia Conference on Computer and Communications Security, published by Association for Computing Machinery. Copyright
restrictions may apply. doi: 10.1145/3196494.3196535
in previous protocol and ours grows linearly with (cid:2), but only small
increases for both. That is, the performance impact of (cid:2) is limited.
The reason is that (cid:2) only affects the number of the non-XOR gates
while the single-gate average computing time is very short. We can
also see that the online time cost is quite little. This is because that
SBC protocol mainly calls SSF protocol and ADD-CMP circuit, in
which the online cost is a small portion of the overall cost. We test
the impact of (cid:2) because it has the effect on the security of SSF proto-
col. To guarantee the security, our goal is to make the masked value
ui + ri (in line 4 of Algorithm 1) distribute in the interval [0, N )
(cid:2))/N decreases,
uniformly, and the smaller (cid:2) would make (N − K · 2
i.e., make the values distribute more uniformly. In general, given
a fixed N , the smaller (cid:2) is, the stronger the security is. Because of
this, we set a smaller (cid:2) = 10 in all other tests.
Figure 3(c) shows the time cost in SMS protocol and the previous
protocol [26] increases at a linear speed as the number of data (n)
increases. For the same reasons explained above, SMS protocol can
also be divided into two phases and the online time is much less
than that in the previous work.
We compare our SEED protocol with the advanced protocol in
[9]. This work presents a homomorphic computation of exact edit
distance based on somewhat homomorphic encryption scheme. In
addition, we also implement another secure exact edit distance
computing protocol using the protocols in [26] as a comparison.
Figure 3(d) shows the time cost for these protocols. When the
length of the sequences n (n1 = n2 = n) increases, the cost of all
protocols grows as O(n2), since exact edit distance computing is
a two-dimension iteration algorithm. Even so, the performance of
SEED protocol still has advantages over the other two. Specially,
SEED has about 50% performance improvement compared with the
protocol in [9]. For example, when n = 50, the online time is 740
seconds in SEED protocol and 1885 seconds in [9].
For SAGSC protocol, Figure 3(e) shows that the online time is
far less than the offline time, since the major operation in SAGSC is
the computation of EQ-ADD circuit and a single circuit runtime is
much less than the circuit construction time. We also observe the
impact of the sequence length (n) to SAGSC protocol is limited. It is
because that the increase of n only increases the number of modular
addition operations, which has a very small impact on the online
time compared with time cost of EQ-ADD circuit computation.
7.2 The Performance of SSQ-I and SSQ-II
In our two schemes, the query executing stage includes the edit
distance computation and top-k results retrieve. We use the SEED
protocol to compute the exact edit distance in SSQ-I. In SSQ-II, an
approximate edit distance computation method is employed for
efficiency. We customize genomic sequences of different length
(n from 10 to 50) based on the real-world data as test dataset and
set block number t from 2 to 10 in SSQ-II, then report single edit
distance computation time for two schemes in Table 3. We only
show the online time in this subsection. Clearly, if the length of
genomic sequences is large, SEED used by SSQ-I generates a large
amount of computing overhead (e.g., it takes 740.3s when n = 50).
Next, we evaluate the performance of SSQ-II in the online phase.
We assume there are 500 genomic sequences with length as 500,
which are outsourced by two data owners and the data size of each
Table 3: The edit distance computation time in SSQ-I and
SSQ-II
n
SSQ-I
SSQ-II
10
29.6s
1.2s