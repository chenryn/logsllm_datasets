### 数据节

**Openresty中文编程网 用户指南 第20页**
**运行测试 PDF最后生成日期：2016年11月8日**

从上面的示例中可以看出，一个测试块可以包含多个测试。测试的数量取决于数据节中的输出检查部分。当我们为测试文件提供“测试计划”时，“测试计划”即为我们期望当前测试文件运行的确切测试数量。如果实际运行的测试数量与计划不符，即使所有测试都成功通过，测试结果也会被视为异常。因此，“测试计划”对预期运行的测试总数施加了严格的约束。然而，在我们的 t/foo.t 文件中，我们有意避免提供任何测试计划，通过在加载 Test::Nginx::Socket 模块的 use 语句中传递 'no_plan' 参数来实现。我们将在后续章节中重新讨论“测试计划”的特性，并解释如何提供一个测试计划。

### 运行多个文件

运行多个测试文件非常直接；只需在 `prove` 命令行中指定文件名即可，例如：

```bash
prove -v t/foo.t t/bar.t t/baz.t
```

如果你希望运行 t/ 目录下的所有测试文件，可以使用通配符：

```bash
prove -v t/*.t
```

如果 t/ 目录下有子目录，可以通过添加 `-r` 选项让 `prove` 递归地遍历整个目录树以查找测试文件：

```bash
prove -r t/
```

该命令也是运行项目整个测试套件的标准方法。

### 运行单个测试块

Test::Nginx 提供了一种简便的方法来运行给定文件中的单个测试块。只需在要单独运行的测试块中添加特殊的 `ONLY` 数据节，`prove` 将在运行该测试文件时跳过其他所有测试块。例如：

```test-base
=== TEST 1: hello, world
这是一个关于 ngx_http_echo_module 提供的 echo 指令的简单演示。
— config
location = /t {
    echo "hello, world!";
}
— request
GET /t
— response_body
hello, world!
— ONLY
```

现在，`prove` 不会运行同一测试文件中的其他测试（如果有的话）。

这在调试特定测试块时非常有用。你可以一次只关注一个测试用例，而不必担心其他不相关的测试用例干扰。

使用 Vim 编辑器时，我们可以快速在当前查看的测试块中插入一行 `--- ONLY`，然后在 Vim 的命令模式下输入 `:!prove %` 来运行测试，而无需离开编辑器窗口。这是因为 Vim 会自动将 `%` 占位符扩展为当前正在编辑的文件路径。这种工作流程非常高效，因为你不需要切换编辑器界面，也不需要输入测试块标题（或其他标识符）和测试文件的路径。你可以在不同文件的测试块之间快速切换。测试驱动开发通常要求频繁的交互和迭代，而 Test::Nginx 特别优化了这一过程。

有时你可能会忘记在调试后删除某些测试文件中的 `--- ONLY` 行，导致这些文件中的其他测试被跳过。为了避免这种情况，Test::Nginx 总会对使用了 `ONLY` 特殊数据节的测试文件发出警告，例如：

```console
$ prove t/foo.t
t/foo.t .. # I found ONLY: maybe you’re debugging?
t/foo.t .. ok
All tests successful.
Files=1, Tests=2, 0 wallclock secs (0.01 usr 0.00 sys + 0.09 cusr 0.03 csys = 0.13 CPU)
Result: PASS
```

这样更容易识别出遗留的 `--- ONLY` 行。

类似于 `ONLY`，Test::Nginx 还提供了 `LAST` 数据节，使包含该数据节的测试块成为测试文件中最后一个运行的测试块。

**注意**：特殊的数据节 `ONLY` 和 `LAST` 实际上是继承自 Test::Base 模块的功能。

### 跳过测试

我们可以使用特殊的 `SKIP` 数据节无条件地跳过包含该数据节的测试块。这对于编写尚未完成的功能或已知但尚未修复的 bug 的测试用例非常有用。例如：

```test-base
=== TEST 1: test for the future
— config
location /t {
    some_fancy_directive;
}
— request
GET /t
— response_body
blah blah blah
— SKIP
```

也可以在序言部分跳过整个测试文件。只需将 `use` 语句替换为以下形式：

```perl
use Test::Nginx::Socket skip_all => "some reasons";
```

然后运行测试文件会有如下输出：

```
.... t/foo.t .. skipped: some reasons ....
```

**注意**：有条件地跳过整个测试文件也是可能的，但这需要一些 Perl 编程技巧。感兴趣的读者可以尝试在 `use` 语句前使用 `BEGIN {}` 来动态计算 `skip_all` 选项的值。

### 测试运行顺序

#### 测试文件运行顺序

测试文件通常按文件名的字母顺序运行。有些人更喜欢通过在测试文件名前加上数字序列（如 001-、002- 等）来显式控制测试文件的运行顺序。

例如，ngx_http_lua 模块的测试套件就遵循这种做法，其测试文件命名如下：

```
.... t/000-sanity.t
t/001-set.t
t/002-content.t
t/003-errors.t
...
t/139-ssl-cert-by.t
....
```

尽管 `prove` 工具支持通过 `-jN` 选项并行运行多个测试文件，但 Test::Nginx 并不支持这种模式，因为所有测试用例共享相同的测试服务器目录 `t/servroot/` 和监听端口。并行运行需要为每个执行线程提供严格隔离的运行环境。不过，仍然可以手动将测试文件分成不同的组，并在不同的（虚拟）机器或隔离环境（如 Linux 容器）中运行每个组。

#### 测试块运行顺序

默认情况下，Test::Nginx 框架会随机打乱每个文件中的测试块并以随机顺序运行它们。这种行为鼓励编写自包含且独立的测试用例，并通过积极改变测试用例的相对运行顺序增加了发现 bug 的机会。对于来自传统测试平台的新用户来说，这确实可能会令人困惑。

我们可以通过在测试文件序言中调用由 Test::Nginx::Socket 模块导入的 Perl 函数 `no_shuffle()` 来禁用这种测试块打乱行为。例如：

```perl
use Test::Nginx::Socket 'no_plan';
no_shuffle();
run_tests();
```

有了 `no_shuffle()` 的调用，测试块将严格按照其在测试文件中的出现顺序运行。

**Openresty中文编程网 用户指南 第25页**
**测试前的准备 PDF最后生成日期：2016年11月8日**

### 测试前的准备

正如我们在上一章中看到的，`Test::Nginx` 提供了一个简单规范的格式来表达测试用例。每个测试用例都用一个测试块来表示，一个测试块由一个标题、一个可选的描述和几个数据节组成，用于指定输入和期望的输出。在本节中，我们将详细探讨如何针对不同的测试需求准备这样的测试案例。

设计测试用例在很多方面是一门艺术。有时设计测试用例所需的时间和精力可能超过实现要测试功能所需的时间和精力。这取决于个人经验。`Test::Nginx` 努力使编写测试用例尽可能简单，但仍无法自动化整个测试用例设计过程。只有你自己才确切知道要测试什么以及如何进行测试。本节将重点介绍 `Test::Nginx` 提供的基本原语，基于此你可以设计出巧妙且有效的测试用例。

#### 准备 NGINX 配置

在一个测试块中，我们可以使用不同的数据节来指定自定义代码片段，这些片段将被插入到由 `Test::Nginx` 生成的最终 `nginx.conf` 配置文件的不同位置中。

最常见的数据节是 `config`，它用于在默认测试服务器的 `server {}` 配置块中插入自定义代码片段。我们还可以使用 `http_config` 数据节在 `nginx.conf` 的 `http {}` 配置块中插入自定义内容。`main_config` 数据节可以在 NGINX 配置的最顶层范围中插入自定义内容。下面是一个示例：

```test-base
=== TEST 1:
— main_config
env MY_ENVIRONMENT;
— http_config
init_worker_by_lua_block { print("init") }
```