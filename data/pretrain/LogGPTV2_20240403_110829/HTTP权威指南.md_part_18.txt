用假想的bill-my-credit-card选项，
Cache-control: max-age=3600
且本次事务结束之后应关闭持久连接。 Connection: meter, close, bill-my-credit-card
Meter: max-uses=3, max-refuses=6, dont-report
代理
客户端 服务器
图4-9 Connection首部允许发送端指定与连接有关的选项
HTTP应用程序收到一条带有Connection首部的报文时，接收端会解析发送端
请求的所有选项，并将其应用。然后会在将此报文转发给下一跳地址之前，删除
Connection首部以及Connection中列出的所有首部。而且，可能还会有少量没
有作为Connection首部值列出，但一定不能被代理转发的逐跳首部。其中包括
Prxoy-Authenticate、Proxy-Connection、Transfer-Encoding 和 Upgrade。
更多有关Connection首部的内容请参见附录C。
4.3.2 串行事务处理时延
如果只对连接进行简单的管理，TCP的性能时延可能会叠加起来。比如，假设有一
92 ｜ 第4章
个包含了3个嵌入图片的Web页面。浏览器需要发起4个HTTP事务来显示此页面：
1个用于顶层的HTML页面，3个用于嵌入的图片。如果每个事务都需要（串行地建
立）一条新的连接，那么连接时延和慢启动时延就会叠加起来（参见图4-10）。9
事务1 事务2 事务3 事务4
求-1 响 求-2 响 求-3 响 求-4 响
服务器
应 应 应 应
请 请 请 请
-1 -2 -3 -4
1
连接-1 连接-2 连接-3 连接-4 时间
客户端
图4-10 4个事务（串行） 87
除了串行加载引入的实际时延之外，加载一幅图片时，页面上其他地方都没有动静
也会让人觉得速度很慢。用户更希望能够同时加载多幅图片。10
串行加载的另一个缺点是，有些浏览器在对象加载完毕之前无法获知对象的尺寸，
而且它们可能需要尺寸信息来决定将对象放在屏幕的什么位置上，所以在加载了足
够多的对象之前，无法在屏幕上显示任何内容。在这种情况下，可能浏览器串行装
载对象的进度很正常，但用户面对的却是一个空白的屏幕，对装载的进度一无所知。11
还有几种现存和新兴的方法可以提高HTTP的连接性能。后面几节讨论了四种此类
技术。
• 并行连接
通过多条TCP连接发起并发的HTTP请求。
• 持久连接
重用TCP连接，以消除连接及关闭时延。
• 管道化连接
通过共享的TCP连接发起并发的HTTP请求。
注9： 根据举此例的目的，假设所有对象的长度基本上都一样，并且是从同一台服务器发出的，而且DNS
条目被缓存了，排除了DNS的查找时间。
注10： 即使同时加载多幅图片比一次加载一幅图片要慢，人们也会有同样的感觉！用户通常会认为多幅图
片同时加载要快一些。
注11： HTML的设计者可以在图片等嵌入式对象的HTML标签中显式地添加宽高属性，以消除这种“布局
时延”。显式地提供了嵌入图片的宽度和高度，浏览器就可以在从服务器收到对象之前确定图形的布
局了。
连接管理 ｜ 93
• 复用的连接
交替传送请求和响应报文（实验阶段）。
4.4 并行连接
如前所述，浏览器可以先完整地请求原始的HTML页面，然后请求第一个嵌入对
象，然后请求第二个嵌入对象等，以这种简单的方式对每个嵌入式对象进行串行处
理。但这样实在是太慢了！
如图4-11所示，HTTP允许客户端打开多条连接，并行地执行多个HTTP事务。在
这个例子中，并行加载了四幅嵌入式图片，每个事务都有自己的TCP连接。12
因特网
服务器1
服务器2
客户端
图4-11 页面上的每个组件都包含一个独立的HTTP事务
4.4.1 并行连接可能会提高页面的加载速度
包含嵌入对象的组合页面如果能（通过并行连接）克服单条连接的空载时间和带宽
88 限制，加载速度也会有所提高。时延可以重叠起来，而且如果单条连接没有充分利
用客户端的因特网带宽，可以将未用带宽分配来装载其他对象。
图 4-12 显示了并行连接的时间线，比图 4-10 要快得多。首先装载的是封闭的
HTML页面，然后并行处理其余的3个事务，每个事务都有自己的连接。13图片的
装载是并行的，连接的时延也是重叠的。
注12： 嵌入的组件不一定都在同一台Web服务器上，可以同多台服务器建立并行的连接。
注13： 由于软件开销的存在，每个连接请求之间总是会有一些小的时延，但连接请求和传输时间基本上都
是重叠起来的。
94 ｜ 第4章
事务2，3，4
事务1 （并行连接）
响
服务器 请求- 1 响 应 请求-2 请求-3 求应 -- 42 响 应 -3响 应
- -4
1
请
1
连接-1 连接-2 时间
客户端 连接-3
连接-4
（通常每个连接之间
都会有一小段软件时延）
图4-12 4个事务（并行）
4.4.2 并行连接不一定更快
即使并行连接的速度可能会更快，但并不一定总是更快。客户端的网络带宽不足
（比如，浏览器是通过一个28.8kbps的Modem连接到因特网上去的）时，大部分 89
的时间可能都是用来传送数据的。在这种情况下，一个连接到速度较快服务器上的
HTTP事务就会很容易地耗尽所有可用的Modem带宽。如果并行加载多个对象，每
个对象都会去竞争这有限的带宽，每个对象都会以较慢的速度按比例加载，这样带
来的性能提升就很小，甚至没什么提升。14
而且，打开大量连接会消耗很多内存资源，从而引发自身的性能问题。复杂的Web
页面可能会有数十或数百个内嵌对象。客户端可能可以打开数百个连接，但Web服
务器通常要同时处理很多其他用户的请求，所以很少有Web服务器希望出现这样的
情况。一百个用户同时发出申请，每个用户打开100个连接，服务器就要负责处理
10 000个连接。这会造成服务器性能的严重下降。对高负荷的代理来说也同样如此。
实际上，浏览器确实使用了并行连接，但它们会将并行连接的总数限制为一个较小
的值（通常是4个）。服务器可以随意关闭来自特定客户端的超量连接。
4.4.3 并行连接可能让人“感觉”更快一些
好了，这样看来并行连接并不总是能使页面加载得更快一些。但如前所述，即使实
际上它们并没有加快页面的传输速度，并行连接通常也会让用户觉得页面加载得更
注14： 实际上，多条连接会产生一些额外的开销，使用并行连接装载整个页面所需的时间很可能比串行下
载的时间更长。
连接管理 ｜ 95
快了，因为多个组件对象同时出现在屏幕上时，用户能够看到加载的进展。15如果
整个屏幕上有很多动作在进行，即使实际上秒表显示整个页面的下载时间更长，人
们也会认为Web页面加载得更快一些。
4.5 持久连接
Web客户端经常会打开到同一个站点的连接。比如，一个Web页面上的大部分内
嵌图片通常都来自同一个Web站点，而且相当一部分指向其他对象的超链通常都指
向同一个站点。因此，初始化了对某服务器HTTP请求的应用程序很可能会在不久
的将来对那台服务器发起更多的请求（比如，获取在线图片）。这种性质被称为站点
局部性（site locality）。
因此，HTTP/1.1（以及HTTP/1.0的各种增强版本） 允许HTTP设备在事务处理结束
之后将TCP连接保持在打开状态，以便为未来的HTTP请求重用现存的连接。在事
90 务处理结束之后仍然保持在打开状态的TCP连接被称为持久连接。非持久连接会在
每个事务结束之后关闭。持久连接会在不同事务之间保持打开状态，直到客户端或
服务器决定将其关闭为止。
重用已对目标服务器打开的空闲持久连接，就可以避开缓慢的连接建立阶段。而且，
已经打开的连接还可以避免慢启动的拥塞适应阶段，以便更快速地进行数据的传输。
4.5.1 持久以及并行连接
我们看到，并行连接可以提高复合页面的传输速度。但并行连接也有一些缺点。
• 每个事务都会打开/关闭一条新的连接，会耗费时间和带宽。
• 由于TCP慢启动特性的存在，每条新连接的性能都会有所降低。
• 可打开的并行连接数量实际上是有限的。
持久连接有一些比并行连接更好的地方。持久连接降低了时延和连接建立的开销，
将连接保持在已调谐状态，而且减少了打开连接的潜在数量。但是，管理持久连接
时要特别小心，不然就会累积出大量的空闲连接，耗费本地以及远程客户端和服务
器上的资源。
持久连接与并行连接配合使用可能是最高效的方式。现在，很多Web应用程序都会
打开少量的并行连接，其中的每一个都是持久连接。持久连接有两种类型：比较老
注15： 渐进式图片会先显示低分辨率的近似图形，然后再逐渐增加图片的分辨率，而随着渐进式图片应用
的逐步增加，这种效果就更加明显了。
96 ｜ 第4章
的HTTP/1.0+“keep-alive”连接，以及现代的HTTP/1.1“persistent”连接。在接
下来的几节中我们将对这两种类型进行介绍。
4.5.2 HTTP/1.0+ keep-alive连接
大约从1996年开始，很多HTTP/1.0浏览器和服务器都进行了扩展，以支持一种被
称为keep-alive连接的早期实验型持久连接。这些早期的持久连接受到了一些互操
作性设计方面问题的困扰，这些问题在后期的HTTP/1.1版本中都得到了修正，但
很多客户端和服务器仍然在使用这些早期的keep-alive连接。
图 4-13 显示了 keep-alive 连接的一些性能优点，图中将在串行连接上实现 4 个
HTTP事务的时间线与在一条持久连接上实现同样事务所需的时间线进行了比较。
由于去除了进行连接和关闭连接的开销，所以时间线有所缩减。16
91
（a）串行连接
事务1 事务2 事务3 事务4
1 响 2 响 3 响 4 响
服务器 求 求 求 求
应 应 应 应
请 请 请 请
1 2 3 4
连接1 连接2 连接3 连接4 时间
客户端
（b）持久连接
事务1 事务2 事务3 事务4
1 响 2 响 3 响 4 响
服务器 求 求 求 求
应 应 应 应
请 请 请 请
1 2 3 4
时间
客户端
图4-13 4个事务（串行与持久连接）
注16： 由于去除了慢启动阶段，请求和响应时间可能也有缩减。这种性能收益在图中没有显示出来。
连接管理 ｜ 97
4.5.3 Keep-Alive操作
keep-alive已经不再使用了，而且在当前的HTTP/1.1规范中也没有对它的说明了。
但浏览器和服务器对keep-alive握手的使用仍然相当广泛，因此，HTTP的实现者应
该做好与之进行交互操作的准备。现在我们来快速浏览一下keep-alive的操作。对
keep-alive握手更详细的解释请参见较早的HTTP/1.1规范版本（比如RFC 2068）。
实现HTTP/1.0 keep-alive连接的客户端可以通过包含Connection: Keep-Alive
首部请求将一条连接保持在打开状态。
如果服务器愿意为下一条请求将连接保持在打开状态，就在响应中包含相同的首部
（参见图4-14）。如果响应中没有Connection: Keep-Alive首部，客户端就认为
服务器不支持keep-alive，会在发回响应报文之后关闭连接。
GET /index.html HTTP/1.0
Host: www.joes-hardware.com
Connection: Keep-Alive
因特网
客户端 服务器
HTTP/1.0 200 OK
Content-type: text/html
Content-length: 3104
Connection: Keep-Alive
...
图4-14 HTTP/1.0 keep-alive事务首部的握手过程
4.5.4 Keep-Alive选项
注意，keep-Alive首部只是请求将连接保持在活跃状态。发出keep-alive请求之
92 后，客户端和服务器并不一定会同意进行keep-alive会话。它们可以在任意时刻关
闭空闲的keep-alive连接，并可随意限制keep-alive连接所处理事务的数量。
可以用Keep-Alive通用首部中指定的、由逗号分隔的选项来调节keep-alive的
行为。
• 参数timeout是在Keep-Alive响应首部发送的。它估计了服务器希望将连接
保持在活跃状态的时间。这并不是一个承诺值。
• 参数max是在Keep-Alive响应首部发送的。它估计了服务器还希望为多少个
事务保持此连接的活跃状态。这并不是一个承诺值。
98 ｜ 第4章
• Keep-Alive首部还可支持任意未经处理的属性，这些属性主要用于诊断和调试。