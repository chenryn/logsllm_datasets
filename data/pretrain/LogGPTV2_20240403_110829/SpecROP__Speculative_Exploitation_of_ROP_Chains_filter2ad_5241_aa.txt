title:SpecROP: Speculative Exploitation of ROP Chains
author:Atri Bhattacharyya and
Andr&apos;es S&apos;anchez and
Esmaeil Mohammadian Koruyeh and
Nael B. Abu-Ghazaleh and
Chengyu Song and
Mathias Payer
SpecROP: Speculative Exploitation of ROP Chains
Atri Bhattacharyya
EPFL
Andrés Sánchez
EPFL
Esmaeil M. Koruyeh
UC Riverside
Nael Abu-Ghazaleh
UC Riverside
Chengyu Song
UC Riverside
Mathias Payer
EPFL
Abstract
Speculative execution attacks, such as Spectre, reuse code
from the victim’s binary to access and leak secret information
during speculative execution. Every variant of the attack re-
quires very particular code sequences, necessitating elaborate
gadget-search campaigns. Often, victim programs contain
few, or even zero, usable gadgets. Consequently, speculative
attacks are sometimes demonstrated by injecting usable code
sequences into the victim. So far, attacks search for mono-
lithic gadgets, a single sequence of code which performs all
the attack steps.
We introduce SpecROP, a novel speculative execution at-
tack technique, inspired by classic code reuse attacks like
Return-Oriented Programming to tackle the rarity of code
gadgets. The SpecROP attacker uses multiple, small gadgets
chained by poisoning multiple control-ﬂow instructions to
perform the same computation as a monolithic gadget. A key
difference to classic code reuse attacks is that control-ﬂow
transfers between gadgets use speculative targets compared
to targets in memory or registers.
We categorize SpecROP gadgets into generic classes and
demonstrate the abundance of such gadgets in victim libraries.
Further, we explore the practicality of inﬂuencing multiple
control-ﬂow instructions on modern processors, and demon-
strate an attack which uses gadget chaining to increase the
leakage potential of a Spectre variant, SMoTherSpectre.
1 Introduction
Spectre [1] demonstrated the power of speculative execu-
tion attacks by leaking information across various protection
boundaries: sandboxes, processes, userspace/kernel, and vir-
tual machines. These attacks reuse code gadgets (short instruc-
tion sequences with useful functionality) already present in
the victim’s code base to access and leak secrets such as cryp-
tographic keys or arbitrary memory. As a form of code-reuse
attacks, they require gadgets composed of speciﬁc instruction
sequences to exist in victim binaries. Often, the length of these
sequences, their complexity, or the rarity of their constituent
instructions implies that the occurrence of usable gadgets is
sparse. A case in point is the gadget required by Spectre. The
attack requires a gadget where the attacker controls two regis-
ters, and contains two loads, of which the second load must
access an address which depends on the value loaded by the
ﬁrst. In fact, the attack on the Linux kernel, which is a massive
and diverse code base, relied on its eBPF (extended Berkeley
Packet Filter) subsystem to essentially inject the gadget into
the kernel.
To address the lack of powerful, monolithic gadgets, we
propose the use of speculative gadget sequences. We present
SpecROP, an attack based around the idea of using the effects
of multiple, small gadgets to effectively perform computa-
tion equivalent to much larger, monolithic gadgets. The attack
methodology leverages the relative abundance of the smaller
gadgets as compared to larger gadgets to provide the required
leakage gadgets. SpecROP is similar to existing code-reuse
attacks (such as Return-Oriented Programming [2, 3] and
Jump-Oriented Programming [4]). In comparison to these
code reuse techniques, SpecROP leverages branch poisoning,
a common starting step in speculative execution attacks, to
effectively stitch the execution of these smaller gadgets. We
search for small code sequences which perform common mod-
iﬁcations on state (e.g., add, shift registers) and end in a return
or indirect jump. During speculation, the CPU consults the
branch predictor to decide the jump target, allowing us to redi-
rect execution to the next gadget. We use automated binary
analysis to discover the constituent gadgets of a SpecROP
chain, using our tool, SpecFication.
This paper makes the following contributions:
• A study of the contexts in which branch targets may
be maliciously inﬂuenced on modern processors (with
hardware and microcode updates against Spectre-like
attacks);
• Analysis of gadget chaining practicality, using indirect
jump instructions as well as returns;
• A proof-of-concept attack, where we extend the capabil-
ities of an existing speculative execution attack;
USENIX Association
23rd International Symposium on Research in Attacks, Intrusions and Defenses    1
• A practical attack on a real target, libcrypto from
OpenSSL, leaking multiple bits of the plaintext during
encryption;
• A binary analysis tool, SpecFication, for discovering
gadgets in real-world libraries, and a characterization
of the existence of some classes of generic gadgets in
commonly-used libraries.
SEA depend on side-channels to leak any secrets accessed
during speculative execution, since any architectural chan-
nels are erased when the processor detects misspeculation,
and rolls back architecturally visible state. Here, we fo-
cus on two side-channels: a cache residency based chan-
nel (Flush+Reload), and a port contention based channel
(SMoTher).
2 Background
SpecROP extends the power and impact of speculative execu-
tion attacks [1,5, 6] by enabling the combined use of multiple
gadgets, similar in spirit as Return-Oriented Programming
which enabled complex code-reuse attacks. Here, we provide
the necessary background for SpecROP.
2.1 Speculative Execution Attacks
Modern processor design has led to a class of attacks known
as Speculative Execution Attacks (SEA). These attacks target
mechanisms designed to allow a processor to ameliorate the
impact of long latency instructions on performance. Speciﬁ-
cally, processors fetch and execute instructions out-of-order
and speculate when lacking all the information needed to
make decisions. Instructions executed by the processor fol-
lowing a misprediction are incorrect. While processors revert
the architecturally visible effects of incorrect actions, microar-
chitectural side-effects remain. This allows SEA attacks to
leak information encoded into cache residency [1, 5], or port
utilization [6] during the period of incorrect execution. The
period starting from the point the processor mispredicts until
it realizes its mistake is the speculation window.
The microarchitectural structure, and its behavior which
encodes information deﬁnes a side-channel. Variants of SEA
differ in their choice of side-channel and the reason for mis-
speculation. Spectre-v1 [1] exploits misspeculation following
a bounds-check prior to an array access. Spectre-v2 exploits
misprediction of the target of an indirect call or jump. Both of
these variant use a Flush+Reload channel [7]. SMoTherSpec-
tre [6] and NetSpectre [8] use alternate side-channels based in
port contention (ports are microarchitectural structures used
for scheduling instructions within the processor pipeline) and
the power-up status of AVX units instead.
2.2 Microarchitectural Side-channels
Microarchitectural side-channels are data channels on a pro-
cessor which leverage state stored in microarchitectural struc-
tures, such as the cache or branch predictors, to transfer in-
formation. As opposed to a covert-channel, the transmitter in
a side-channel is not privy to the communication: the trans-
mitter is inadvertently leaking information and is referred to
as the victim. The receiver reads the information from the
channel, and is referred to as the attacker.
Flush+Reload channel A Flush+Reload channel [7] en-
codes information in the cache residency of a cache block
at a speciﬁc address (A). This channel requires the attacker
and victim to temporally share a core and its cache. Initially,
the attacker primes the channel by ﬂushing the cache block,
evicting it from all layers of caches: the block is now un-
cached. In the second step, the victim executes. During its
execution, the victim encodes a secret bit into the channel by
conditionally loading from the address A. If the secret is 0, it
loads A (thereby caching the block); if the secret is 1, it does
not. Finally, the attacker reads the channel by reloading the
address A, and timing how long it takes. If the secret was 0,
and the victim had already cached the block, the attacker’s
load is fast, else it is slow. This channel encodes a single bit.
A variant of this channel uses 256 unique address (A0
through A255) which map to different cache blocks. The vic-
tim encodes a secret byte (b) by only loading Ab. In the reload
phase, the attacker reloads all addresses and times each load.
The load Ab completes faster than the others, thereby leaking
a byte.
SMoTher channel A SMoTher channel [6] encodes infor-
mation in the port utilization of the victim’s instructions. This
side-channel requires the attacker and victim to share a Si-
multaneously Multi-Threaded (SMT) core, thereby sharing
the ports on the core.
The victim encodes a secret bit by executing a SMoTher
gadget, a secret-dependent conditional branch leading to (tar-
get and fallthrough) code sequences which utilize different
ports. Concurrently, the attacker executes a speciﬁc sequence
of instructions designed to cause port contention with the
target sequence, and times its execution. In the case that the
victim is executing the fallthrough sequence, there is no port
contention and the attacker completes its own sequence faster.
In the other case, when the victim executes the target se-
quence, port contention causes the attacker’s execution to be
slower. The attacker, therefore, uses its timing to infer which
sequence the victim was executing. Since the victim’s secret
bit determines which way the conditional branch goes, the
attacker is able to leak the secret bit. This channel encodes a
single bit.
2.3 Return/Jump Oriented Programming
Return-Oriented Programming (ROP) is a code-reuse tech-
nique based on chaining multiple instruction sequences al-
2    23rd International Symposium on Research in Attacks, Intrusions and Defenses
USENIX Association
a r r a y 2 [ a r r a y 1 [ x ] * 4096]
/ / C :
1
2 mov ( rax , rdi , 8 ) , rax
3
4 mov ( rdx , rax , 8 ) , rax
s h l 0xc , rax
(a) Spectre gadget where rax points to array1, rdx points to
array2, and rdi is x
( rdx , rax , 1 ) , edx
/ / Gadget 1 : Load s e c r e t
1
2 mov
c a l l * ( rbx + 0 x40 )
3
/ / Gadget 2 : S h i f t
4
s h l
5
6 mov
7
8
9
10 mov
0x20 , rdx
eax , eax
rdx , rax
or
r e t
/ / Gadget 3 : Leak s e c r e t
s e c r e t
/ / E x t r a n e o u s
/ / E x t r a n e o u s
( rbx , rdx , 8 ) , r s i
(b) Equivalent SpecROP chain where rdx points to array1, rbx
points to array2, and rax is x. Lines 6 and 7 contain code irrelevant
to the gadget chain.
Listing 1: A SpecROP chain from libc which can be used in
place of the Spectre gadget
predicted target of the jump. Thereafter, the processor exe-
cutes instructions along the ﬁrst gadget in the chain: a process-
ing gadget. Subsequently, the attacker manipulates a control-
ﬂow instruction at the end of the ﬁrst gadget to direct execu-
tion to the second gadget, and so on through a gadget chain,
similar to a ROP attack. The chain of processing gadgets is
responsible for performing attacker-controlled computation,
and is key to the increased capabilities of a SpecROP attacker
(which we discuss later). The ﬁnal gadget(s) in the chain, a
leakage gadget, is used to leak secrets. The key difference
to ROP attacks is that SpecROP gadgets are executed and
chained speculatively, i.e., the target of the indirect control
ﬂow transfer is not read from a memory location but indirectly
inﬂuenced and “primed” by the attacker.
SpecROP bypasses the reliance of existing SEA on two
conditions which are hard to satisfy, by chaining and leverag-
ing the execution of multiple gadgets. First, in classic SEA
the victim’s secret needs to be directly accessible, either in
a register or in memory referenced to by a register. Using a
gadget chain overcomes this requirement, enabling attacks
which require multiple operations to access the secret. For
example, functions in the generic interface for the OpenSSL
library (called EVP) have a pointer to a context structure as
the ﬁrst argument. The context includes a pointer to cipher-
speciﬁc data (Figure 2b). For AES ciphers, this data is the
encryption key. Accessing the key from the context pointer
requires pointer arithmetic and two dereferences (see the “re-
Figure 1: Phases of a Speculative ROP attack.
ready present in victim code into a gadget capable of per-
forming complex computations. ROP gadgets end in a re-
turn instruction, chained through the attacker-compromised
return addresses on the stack. This mechanism is used to
chain the smaller sequences into complex exploits. In 2007,
Shacham [2] demonstrated how gadgets from instruction se-
quences in libc could be used to achieve Turing-complete
computation. Jump-Oriented Programming (JOP) [4] is a re-
lated technique where indirect jumps are hijacked through
memory corruption to similarly compose smaller gadgets into
complete attacks.
Similar to previously known buffer-overﬂow attacks, ROP
requires the ability to corrupt the stack (or to pivot the stack
to an alternate location). While buffer-overﬂow attacks were
commonly used to inject and execute shell code onto the stack,
they were effectively eliminated by one mitigation technique:
hardware exclusion of writable and executable permissions on
pages. ROP attacks bypass this mitigation by design, reusing
instructions already existing within the victim’s binary and
which must necessarily have executable permissions.
Code-reuse attacks depend on the existence of gadgets
which perform computation useful to the attacker. The statis-
tical probability of a gadget existing in a binary is dictated by
two parameters: the length of the sequence and the probabil-
ity of occurrence of each instruction in the gadget within the
binary. On an architecture with variable-length instructions,
such as x86_64, short instructions such as ret (encoded as
one byte) may be even found inside the machine code for
longer instructions (such as mov rax, rbx). In general, com-
monly existing ROP gadgets are small sequences of common,
sometimes unintended, instructions.
3 Speculative ROP
Speculative Return-Oriented Programming (SpecROP), is an
exploit technique that leverages gadget chaining to enhance
the capabilities of an SEA attacker. Figure 1 shows the steps of
a SpecROP attack. The attack starts at a mispredicted control-
ﬂow instruction, an indirect jump/call or return. The attacker
poisons the branch predictor on the processor to control the
USENIX Association
23rd International Symposium on Research in Attacks, Intrusions and Defenses    3
Indirect jumpFirst gadgetSecond gadget...Start ofspeculationProcessinggadgetsLeakageLeakage ofsecret(a) Control ﬂow during an SEA attack, and for a SpecROP attack.
Below the dotted lines, we show the relevant register state.
(b) OpenSSL’s Memory layout: The EVP_CIPHER_CTX struc-
ture contains a pointer to the AES key at an offset of 0x78.
Figure 2: A SpecROP chain starting with a pointer to the OpenSSL cipher context structure, and capable of leaking the AES key.
quired gadget” in Figure 2a). Such a monolithic gadget which
starts with a pointer to the context, and accesses and leaks
the key requires a long sequence of instructions. We were un-
able to ﬁnd such a gadget within multiple libraries. Existing
SEA, therefore, are incapable of exploiting calls to the EVP
functions to leak the key. In contrast, we found a chain using
three gadgets from libcrypto (“SpecROP gadget chain” in
Figure 2a) which allows attackers to access and leak the AES
key. The full gadgets are listed in Appendix B. This chain
requires the attacker to poison an extra indirect jump and an
extra return instruction.
Second, classic SEA require a single gadget to both access
the secret, and leak it into the microarchitectural channel. The
gadget used to leak information in Spectre attacks requires
two dependent memory loads with a left-shift of at-least 6
bits (to encode each value in a different, 64-byte cache line)
in between (Listing 1a). So far, no natural gadget of this
kind has been disclosed publicly, even for large, real-world
binaries such as the Linux kernel. In fact, we applied our tool,
SpecFication, to search for monolithic, Spectre-like gadgets
in commonly-used libraries (listed in Section 5.2), the Linux
kernel and its modules, and in QEMU without any results.
In contrast, we found an equivalent SpecROP chain in libc
(Listing 1b). The chain has three gadgets , two of which are
dependent loads, with one shift gadget in between. Generally,
each gadget in a SpecROP chain is shorter than a monolithic
gadget, and there is a higher probability of ﬁnding them in
the victim’s code.
SpecROP offers several beneﬁts compared to traditional
ROP and JOP attacks. Unlike ROP attacks, SpecROP does
not require any corruption of the victim’s memory to chain
gadgets. While there is an abundance of memory corruption
attacks, they require the attacker to interact directly with the
victim. In contrast, SpecROP attacks can be performed with
only microarchitectural interactions between the attacker and
their victim. Further, mitigations for memory safety which
protect the stack state do not affect the SpecROP attacker. Un-
like JOP attacks, SpecROP does not require a dispatcher gad-
get whose repeated indirect calls enable chaining of gadgets.
Finally, ROP/JOP attacks require that none of the chained
gadgets have unwanted side-effects such as exceptions. By
executing speculatively, SpecROP bypasses these restrictions.
For example, it allows the transient execution of code that
dereferences a null pointer as long as the loading of the secret
or the leakage gadget do not depend on it.
Limitations SpecROP chains are limited in their length, in
terms of the number of instructions and the number of cycles
they take to execute. Processors have microarchitectural lim-
its on the number of instructions they can fetch and execute
speculatively: the re-order buffer can hold around 200 instruc-
tions on modern processors. The entire gadget chain must
also complete its execution before the mispredicted branch is
resolved. Following a last-level cache miss, the speculation
window is up to a few hundred cycles [1].
Unlike JOP, SpecROP gadgets using indirect jumps cannot
be repeated. The technique used to poison jumps (Branch
Target Injection) implies a unique predicted target for each
address, precluding the reuse of these gadgets in more than
one place in the same chain.
3.1 Gadgets
Gadgets are the building blocks of a SpecROP attack, and an
attacker will require the presence of a variety of gadgets to
launch complicated attacks. We devise a system of catego-
rization of gadgets in Section 3.1.1 and show metrics of the
availability of each category in Section 4.
Gadgets in a typical SpecROP chain perform one of three
important functions: (i) manipulate processor state to access
secrets, and (ii) move said secrets into registers (iii) where a
ﬁnal gadget leaks them. At each step, one or more gadgets may
be used. Figure 2 shows example gadgets from libcrypto
which access and leak the key. The ﬁrst gadget is an arithmetic
4    23rd International Symposium on Research in Attacks, Intrusions and Defenses
USENIX Association
call		*0x20(rax)mov		0x78(rdi),rdimov		(rdi),	raxtest	0x1,raxjmp		...crc32	popcntlea		0x20(rdi),rdimov		0x58(rdi),raxtestb	0x1,(rax)jmp		...SpecROP gadget chainRequired gadgetProcessingLeakagerdi	=	&ctxrdi	=	&ctx	+	0x20rax	=	cipher_data				=	&AES_key EVP_CIPHER_CTXctxrdiAES	keycipher_data0x78gadget, where the lea instruction effectively adds an offset to
a pointer. The second gadget is a data movement gadget, and