policy, the conﬁgurable origin policy, as follows.
A principal (both server and client parts included) can
conﬁgure any of its resources to an arbitrary but unique
origin.
This means that a principal can change its contents’ origin
to an arbitrary value. The program at the server side of the
principal can conﬁgure its originID. For example, the server
may send its content to clients together with an originID. The
program at the client side can also conﬁgure its origin. For
example, a client-side JavaScript program may change the
originID of a document tree.
On server side, unlike the SOP model, in which the content-
to-origin mapping is ﬁxed for all contents from the same
 tuple, in the COP model, we allow
the principal to conﬁgure its own origin. An SOP origin can
be split into several COP origins. As illustrated in Section
II-B, mashups and different web sessions are all examples.
Similarly, multiple SOP origins can be combined together in
conﬁgurable origins. For example, Google Docs and Gmail
may want to share code or data dynamically, and thus they
are better put in a single principal. Also, as illustrated in Sec-
tion II-B, www.cnn.com and ads.cnn.com can be combined
into cnn.com origin. Figure 2 clearly shows the differences
between SOP and COP content-to-principal mapping.
On client side, the principal is also given more freedom.
In the classical SOP model, the switching of origins is not
allowed at the client side. document.domain reduces this re-
striction only a little, which may not be enough for some
applications, and that too at the cost of possible malicious
access to the principal. For example, a.com and b.com cannot
share the same principal, even when using document.domain.
Because in the COP model, the origin ID of a principal is not
tied to its location, the origin of a principal may be arbitrarily
decided at the client side.
C. Operations on a COP Principal
We deﬁne the following operations on a COP principal.
Creating a Principal. A principal can be created by a server
or a client by giving a new originID, as shown in Figure 3.
Figure 3(a) illustrates the client requesting a URL together
with an empty originID to a.com and the server sending
the corresponding content with a new originID. In order to
have multiple separate sessions from the same server, say
for signing into multiple Gmail accounts, the server sends
different originIDs to the client for different sessions. Given
the different originIDs, the client browser renders the corre-
sponding contents using different principals.
Clients can also create a principal as shown in Figure
3(b). A principal can assign a resource belonging to itself a
new originID value to place this resource in a new principal.
The child principal will inherit the PSL of its parent. Mashup
isolation problem can also be solved using such client-side
operations. Web integrators at client side can create different
principals for content from different (distrusting) third par-
ties by giving different originIDs based on the information
provided by the server.
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 07:53:23 UTC from IEEE Xplore.  Restrictions apply. 
Joining an Existing Principal. Resources from one principal
may wish to collaborate with, or join, resources from another
principal. The joining process is discussed below.
that is used for sharing and will then give the new originID
to the other web site so that the other web site can join that
newly created principal.
As shown in Figure 4(a), a web site a.com may request
to use a resource hosted on a different web site b.com under
a.com’s principal — a.com can ask b.com to allow the re-
source to join a.com’s principal. Client browser supplies web
site a.com’s originID and PSL when requesting that resource
from b.com. If b.com agrees that this resource is allowed
to join a.com, b.com will send the resource to a.com and
attach a.com’s originID to it (case one in Figure 4(a)), and
then client browser adds b.com plus the path speciﬁed by
the server to the PSL of the current principal. If b.com does
not want to participate in the principal actively, it will send
the resource back with default originID (case two in Figure
4(a)), and then client browser will not change the PSL of the
current principal. If b.com refuses to let this resource join
a.com, it will fail to respond with the resource (case three in
Figure 4(a)).
This join operation can be used for document.domain
problem. For example, when the client has a www.cnn.com
principal and sends a request to ads.cnn.com with the prin-
cipal’s originID and PSL, ads.cnn.com will agree to join the
existing principal with the same originID. On the other hand,
a bank web site will generally not join an existing principal
of another web site.
Second, as shown in Figure 4(b), a web site a.com may
request to use a resource hosted on a different web site b.com
under a.com’s principal without telling b.com its originID.
Client browser supplies a secret originID when requesting
that resource from b.com. If b.com agrees to provide that
resource, it will send the resource with a default originID.
Otherwise, b.com can reject that request the same as case
three in Figure 4(a). In this case, no matter b.com agrees or
not, it will not be participating in that principal but just pro-
vide external resource. In other words, b.com cannot control
the principal.
This pseudo-join operation can be used for supplying
cacheable contents or those from content distribution net-
works. For example, a.com may request a cascading style
sheet (CSS) by this operation since a.com does not want to
reveal its originID to b.com and meantime b.com does not
care which web site is using this style sheet.
Third, as shown in Figure 4(c), a resource or a principal
from a.com may join another existing principal from b.com.
The resource or principal from a.com acquires the originID
of the other principal from b.com it wishes to join via an
auxiliary communication channel (postMessage channel). By
changing to this originID, the resource or the principal from
a.com joins the other principal represented by this originID.
And the PSL of the merged principal will also be the merging
of those two principals’ PSLs.
This case may be useful for collaboration among web
sites. For example, Facebook Connect can be implemented
with the join operation. A Facebook principal at the client
browser may want to share information with another web site,
say Yelp. The Facebook principal will create a new principal
Communication inside a Principal. For client and server
communication, accompanied by current originID, the com-
munication with a server in PSL will be considered as a
communication inside the current principal. The communi-
cation with a server not in PSL will always considered as
a join operation (therefore attached with originID and PSL).
Details can be found in Section IV-D1.
Pure client-side communication inside a principal is un-
restricted. Any resource can freely access any other resource.
For instance, one JavaScript object can call the methods of
another object.
Communication between Principals. Communication across
principals can be achieved with explicitly deﬁned and regu-
lated channels. Namely, we can use the postMessage channel
and its communication protocols [22].
Destroying a Principal. Principals may destroy themselves
or be destroyed by a user. For example, a user may close all
the tabs and windows belonging to a principal and in this
way destroy it.
IV.
IMPLEMENTATION
Conﬁgurable Origin Framework (COF) requires both client-
side and server-side modiﬁcation. The server-side modiﬁca-
tion requires the server to send each resource together with
the corresponding originID to the client. The client side needs
to recognize the originID and put this resource into the cor-
responding principal.
Server-Side Modiﬁcation. In our implementation, we mod-
ify the web application at server side so that resources in one
web session will be allocated into one principal at client. This
means the content-to-principal mapping is switched from SOP
origin per principal to web session per principal. The concept
of a session already exists in the present web, and denotes
an information exchange process between the server and the
client [33]. For example, when a user logs into his account on
a web service, the web site sends a cookie to the user as an
identity for further communication. Later on, any communi-
cation with that cookie is inside this session. The web server
will check the identity cookie and reject requests without
that cookie. In our paper, we adopt the existing concept of
session. We will put resources of the same session2 from the
server into the same principal. Our server-side modiﬁcation
is discussed in Section VI-A. The rest of this section mainly
deals with client browser modiﬁcation.
Our client-side prototype implementation is based on We-
bKit [34], a popular open-source web browser framework. We
demonstrate COF with the Qt browser that comes with We-
bKit. This browser uses WebKit’s WebCore and JavaScript-
Core. We insert 327 lines into WebKit to implement COF.
The source code can be downloaded from conﬁgurable origin
policy google code project [35].
2Notice that originIDs do not substitute session cookies, which still
perform the same functionality as before.
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 07:53:23 UTC from IEEE Xplore.  Restrictions apply. 
bool SecurityOrigin::canAccess(const
SecurityOrigin* other)const {
HTTP Request
HTTP Response
HTML
...
if (m_protocol == other->m_protocol) {
if (!m_domainWasSetInDOM
if (m_host==other->m_host&&m_port == other->m_port)
&& !other->m_domainWasSetInDOM){
return true;
} else if (m_domainWasSetInDOM
if (m_domain == other->m_domain)
&& other->m_domainWasSetInDOM){
return true;
}
}
return false;
}
HTTP/1.1 200 OK
originID: *****
PSLPath:/part1
(a) OriginID and PSL with HTTP
GET /c.htm HTTP/1.1 
originID: ******
PSL: http://a.com/
(b) OriginID with HTML
Fig. 6. Association of originID and PSL with Different Resources.
freely access each other. Since only small modiﬁcations are
required for COP on WebKit, we believe it will be relatively
easy to adopt COP for other browsers as well.
(a) Access Control in SOP
C. Association of OriginIDs with Resources
bool SecurityOrigin::canAccess(const
if (m_originID!="" || other->originID()!="") {
return m_originID == other->originID();
SecurityOrigin* other) const {
}
else {
SOP Access Control
}
}
(b) Access Control in COP
Fig. 5. Access Control Implementation in SOP and COP.
In the rest of this section, we present originID and publi-
cID generation, and WebKit COP enforcement respectively in
Section IV-A and IV-B. Then, we discuss the association of
originID with different resources in Section IV-C and IV-D.
Finally, Section IV-E presents compatibility issues.
A. OriginID and PublicID Generation
The representation of originID is similar to that of a
session cookie: a long and random string. We generate a 128-
bit random number by CSPRNGs (cryptographically secure
pseudorandom number generator) [36] and encode it as the
value of an originID.
For a principal X, a publicID is an identiﬁer which can
be used by other principals to refer to principal X. Once a
principal is created, a unique publicID is assigned to the prin-
cipal automatically by the browser. The browser maintains a
table of publicIDs and its corresponding information, such as
the domain name and the description from the principal itself.
Other principals can use a new API getpublicID(domain
name), which returns a list of publicIDs belonging to the
domain, to query this table for the information,.
B. Enforcing COP
A principal is associated with a container for resources.
We classify resources into two categories, resources from
servers and dynamically-generated resources. Each resource
belongs to one principal, implying that each resource may be
associated with an originID.
1) Origins for Resources from Servers: Resources ob-
tained from servers, such as HTML, images, and some of
plugin data, are mostly transmitted via HTTP protocol3. As
shown in Figure 6(a), we add a header, named originID, in
the HTTP protocol to indicate the originID of the resource.
When the browser sees this ﬁeld, it will add this resource to
the principal with this originID.
In addition, HTML can be used for originID association.
For example, the content inside an iframe tag may belong
to another principal but this cannot be represented via HTTP
headers alone. As shown in Figure 6(b), for some HTML tags
that will cause an HTTP request or can create a document
object4, we can have an originID different from the one of
the main document. Since HTTP headers, HTML tags, and
HTML attributes are designed to be extensible, our new mod-
iﬁcations are completely compatible with existing browsers;
they simply get discarded in existing browsers.
Some content, such as some plugin data, is not trans-
mitted by HTTP protocol. Such content belongs to the prin-
cipal which requested it. For example, a Flash program in
a Flash plugin creates a TCP connection. Later, contents
transmitted in this TCP connection will have the same ori-
gin as this Flash program. The Flash program belongs to
dynamically-generated resources, which will be discussed in
Section IV-C2. In case the plugin program cannot be trusted,
the whole plugin may be isolated in a different principal by
assigning a different originID. We leave it as our future work
to apply COP to plugin data.
Access control methods or other isolation mechanisms are
required to protect the boundary of a principal. In COF, to
put contents from the same COP origin into one principal we
need to replace SOP-based access control mechanisms with
those based on COP.
2) Origins for Dynamically-Generated Resources: Dynam-
ically generated resources refer to DOM, dynamic JavaScript
objects, computed CSS, etc. These resources are derived from
resources from servers. For example, DOM is generated from
HTML parsing and JavaScript execution. There are two types
SecurityOrigin is deﬁned as a class in the WebKit
implementation for controlling access over all domains. It
adopts SOP and Figure 5(a) shows its core function. In COF,
we modify it to employ originIDs for access control. The key
part of new design is shown in Figure 5(b). Resources labeled
with the same originID belong to the same principal and can
3HTTPS can be dealt with similarly because overall the conﬁdentiali-
ty/integrity of the transfer channel problem is orthogonal to the problem of
deﬁning security principals, and can still use host names.
4Assigning a new originID is useful for only a few HTML tags, the ones
that send another HTTP request or contains another DOM, such as img
and iframe. For other HTML tags, because browser’s access control is not
ﬁne-grained upon each DOM node, we cannot isolate them.
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 07:53:23 UTC from IEEE Xplore.  Restrictions apply. 
Fig. 7. Origins For Generated Resources.
TABLE II.
DEFAULT BEHAVIORS FOR HTTP REQUESTS
(COMPATIBLE WITH SOP).
HTTP Requests
Default Attached OriginID