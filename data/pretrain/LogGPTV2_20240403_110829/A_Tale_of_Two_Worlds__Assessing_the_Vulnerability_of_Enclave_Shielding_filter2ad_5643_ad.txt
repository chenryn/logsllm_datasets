Pointer sanitization is a relatively well-known requirement for
enclave applications, and even bears some similarity with tradi-
tional user-to-kernel system call validation concerns [6]. However,
the kernel system call interface remains largely invisible, fairly
stable, and is only modified by a select group of expert developers.
SDK-based enclave development frameworks on the other hand
expose ecalls and ocalls much more directly to the application
developer by means of a secure function call abstraction.
Intel SGX-SDK. In line with trusted runtime shielding require-
ments, pointer sanitization should preferably not be left to the
application developer’s end responsibility. As part of the official
SGX-SDK, Intel [19] therefore developed a convenient tool called
edger8r, which transparently generates trusted proxy bridge code
to take care of validating pointer arguments and copying input and
output buffers to/from the enclave. The tool automatically gener-
ates C code based on ecall/ocall function prototypes and explicit
programmer annotations that specify pointer directions and sizes
in a custom, domain-specific Enclave Definition Language (EDL).
Figure 3 gives an overview of the high-level operation of the
trusted edger8r bridge code. After entering the enclave, the trusted
runtime establishes a trusted ABI (cf. Section 4), locates the ecall
function to be called, and finally 1○ hands over control to the
corresponding edger8r-generated bridge code. At this point, all
input buffer pointers are validated to fall completely outside the
enclave, before being copied 2○ from untrusted shared memory to
a sufficiently-sized shadow buffer allocated on the enclave heap. Fi-
nally, the edger8r bridge transfers control 3○ to the code written by
the application developer, which can now safely operate 4○ on the
cloned buffer in enclave memory. A symmetrical path is followed
when returning or performing ocalls to the untrusted code outside
the enclave.
Microsoft Open Enclave SDK. Microsoft [29] adopted the san-
itization strategy from the Intel SGX-SDK by means of their own
oeedger8r fork. Interestingly, OE uses a “deep copy” marshalling
scheme to generalize to TEEs where the enclave cannot directly
access host memory and every interaction needs to be mediated in
a security kernel with access to an explicit shared memory region
(cf. Fig. 1). With deep copy marshalling, instead of passing the en-
clave pointers to the input buffer, the contents of the buffer are first
EnclaveEENTERTrusted runtimeEdger8r bridgeApplication Input buffer(shared memory)Cloned buffer(trusted memory)EDLC1243goto done ;
...
done :
sizeof (* p_host_args )))
oe_result_t __result = OE_FAILURE ;
if (! p_host_args || ! oe_is_outside_enclave ( p_host_args ,
1 OE_ECALL void ecall_hello ( hello_args_t * p_host_args ) {
2
3
4
5
6
7
8 ⭑
9 }
Listing 2: Proxy function generated by oeedger8r (simplified)
with illegal write to arbitrary in-enclave pointer on failure.
if ( p_host_args ) p_host_args -> _result = __result ;
copied into the marshalling structure and then cloned into enclave
memory. The pointers in the argument structure are then modified
such that they point to the corresponding (cloned) memory buffer.
Nevertheless, we discovered several flaws in the way OE handles
pointer validation (tracked via CVE-2019-0876). A first subtle issue
was found by reviewing the oeedger8r-generated code skeleton
itself. Listing 2 shows a simplified snippet of the trusted bridge
code generated for an elementary hello() entry point. The code
attempts to properly verify that the untrusted p_host_args structure
lies outside the enclave, and indeed rejects the ecall when detecting
a pointer poisoning attempt. However, in the done branch at line 8,
an error code is still written into the p_host_args structure, even
if it was found earlier to illegally point inside the enclave. At the
time of our review, this could only be exploited when calling the
enclave through a legacy ecall dispatcher that had unfortunately
not been removed from OE’s trusted code base (cf. Appendix A.1).
Secondly, we found that enclaves built with OE feature a small
number of “built-in” ecall entry points for infrastructural function-
ality directly serviced in the trusted runtime without forwarding
to the shielded application. Notably, OE developers decided not to
route these entry points through oeedger8r-generated bridges, but
instead opted to manually scrutinize arguments for these special
ecalls. We audited all eight built-in entry points, and confirmed
that most of them were carefully written to prevent pointer sanitiza-
tion issues, as well as more subtle attack vectors like TOCTOU and
speculative execution side-channels. However, we found a critical
issue in the built-in _handle_get_sgx_report() ecall involved in
crucial attestation functionality (see Appendix A.2 for full code).
This function copies the untrusted report input buffer into enclave
memory, but never validates whether the argument pointer passed
by the untrusted runtime actually lies outside the enclave. This
evidently leads to corruption of trusted memory, e.g., when writing
the return value in the fall-through branch similar to the oeedger8r-
generated code discussed above.
Both of the above vulnerabilities allow to write a fixed fail-
ure code (0x03000000 and 0x01000000) to an arbitrary in-enclave
memory location. We developed a PoC based on an existing file-
encryptor OE example application, and successfully exploited the
above vulnerabilities to forcefully overwrite the first round keys of
the AES cipher. This could be extended by overwriting all but the
final round keys with known values to perform full key extraction.
Google Asylo. Because Google’s Asylo [13] framework is built
on top the existing Intel SGX-SDK, it also inherits Intel’s edger8r-
based input sanitization scheme. Particularly, the Asylo trusted
runtime features a small number of predefined ecall entry points,
specified in EDL, that implement the necessary functionality to
present a higher-level, RPC-like message passing abstraction to the
application programmer. Considering that Asylo’s runtime extends
the trusted computing base on top of Intel’s existing SGX-SDK, we
were interested to assess whether the extra abstraction level may
also bring additional attack surface. This may for instance be the
case when making use of the unsafe [user_check] EDL attribute [19]
that explicitly weakens edger8r guarantees and puts the burden of
pointer validation on the programmer (e.g., to allow for application-
specific optimizations in performance-critical scenarios). Manually
scrutinizing the EDL specifications of Asylo’s trusted runtime, we
found 14 instances of the problematic [user_check] attribute. We
reviewed these instances and alarmingly found that several of them
lacked proper pointer validation, leaving critical vulnerabilities in
the compiled enclave (e.g., a write-zero primitive). Notably, the
developers took care to validate second-level input buffers in the
untrusted argument structure, but failed to validate the argument
pointer itself (cf. Appendix A.3 for a relevant sample).
Graphene-SGX. While Graphene-SGX’s [43] untrusted world
interaction and pointer validation concerns are largely limited to
ocalls (cf. Sections 5.3 and 5.5), our inspection of the narrow ecall
interface revealed a rather subtle type of implicit pointer passing
that was overlooked. Namely, Graphene’s trusted runtime never
validates the argv and envp pointers, which are passed from the
untrusted runtime all the way into the main function of the shielded
application binary. As a result, adversaries can for instance leak
arbitrary in-enclave memory when the trusted application outputs
argv values (e.g., in case of an unknown command line argument).
We experimentally confirmed this attack by means of an elemen-
tary echo program, which unknowingly prints in-enclave secrets
after overriding argv[1] in the untrusted runtime. With respect to
mitigations, note that properly sanitizing string arguments can be
non-trivial in itself, as explored in Section 5.2.
We also found that the special enclave_ecall_thread_start()
trusted runtime function unconditionally redirects control flow,
without performing any validation on the provided untrusted func-
tion pointer. We successfully exploited this to jump to arbitrary
in-enclave locations, hence allowing code reuse attacks [41].
SGX-LKL. Our analysis of the open-source SGX-LKL ecall in-
terface revealed the exact same vulnerability. That is, the trusted __s
gx_init_enclave() libOS function passes the untrusted argv pointer
directly to the shielded application without any prior sanitization.
We experimentally confirmed that this vulnerability can be abused
for information leakage, similar to the above exploit.
Further, the in-enclave signal handler ecall entry point does not
check that the siginfo struct pointer provided by the untrusted
runtime lies outside the enclave. This vulnerability can be abused in
certain scenarios to leak in-enclave memory contents. For instance,
we describe a full exploit for the SIGILL signal in Appendix A.4.
Sancus. To demonstrate that untrusted pointer dereference vul-
nerabilities are not limited to advanced virtual memory-based archi-
tectures, we also reviewed the trusted runtime and infrastructural
enclaves of the low-end open-source Sancus [32] TEE for embedded
TI MSP430 devices. As with the above runtimes, we focused our
security audit on the enclave boundary code only.
A first critical vulnerability was found in a recent extension [31]
to the Sancus compiler infrastructure, which implements a high-
level authenticated message passing abstraction to develop dis-
tributed event-driven enclave programs. Much like Intel’s edger8r,
the Sancus compiler fully automatically generates ecall bridge code
to transparently marshal, decrypt, and authenticate input buffers,
which can be subsequently processed by the shielded application.
We found that the compiler-generated bridge code does not sani-
tize untrusted pointer arguments (cf. Appendix A.5). This may be
exploited to forcefully decrypt enclave secrets.
A second input pointer validation vulnerability was found in
an infrastructural trusted loader enclave [14] that decrypts third-
party application enclaves to preserve code confidentiality. We
noticed that the trusted loader enclave code lacks any input pointer
validation checks, allowing us to build an arbitrary write primitive
in enclave memory. We successfully exploited this vulnerability in
a PoC that launches a ROP-style [41] control flow hijacking attack
by corrupting the loader enclave call stack.
5.2 Validating string arguments
In case the enclave interface is written in a low-level language like
C, string arguments do not carry an explicit length and may not
even have been properly null-terminated. Thus, shielding runtimes
need to first determine the expected length and always include a
null terminator when copying the string inside the enclave.
Attack vector #5 (strings): Runtimes should avoid computing untrusted
string sizes, and always include a null byte at the expected end. ▷ At least
one related instance repeated across two production SDKs.
TEE design. We show below how computing on unchecked
string pointers may leak enclave secrets through side-channels,
even if the ecall is eventually rejected. While side-channels are
generally a known issue across TEE technologies [8, 21, 34, 46] and
may even be observed by non-privileged adversaries, for example
by measuring overall execution time [30] or attacker-induced cache
evictions [26, 39], we show that TEE-specific design decisions can
still largely affect the overall exploitability of subtle side-channel
vulnerabilities. Particularly, we develop a highly practical attack
that abuses several privileged adversary capabilities that have previ-
ously been proven notorious in the Intel SGX design, e.g., untrusted
page tables [47, 54], interrupts [24, 45, 46], and storing interrupted
CPU register contents in SSA memory frames [5, 44].
Intel SGX-SDK. We discovered that edger8r-generated code
may be tricked into operating on unchecked in-enclave pointers
when computing the size of a variable-length input buffer. While
such illegal ecall attempts will always be properly rejected, we
found that adversaries can exploit the unintended size computa-
tion as a deterministic oracle that reveals side-channel information
about arbitrary in-enclave memory locations. This vulnerability is
tracked via CVE-2018-3626 (Intel SA-00117), leading to enclave TCB
recovery and changes in the EDL specification [18]. Prior to our dis-
closure, EDL allowed programmers to specify a custom [sizefunc]
attribute that takes as an argument an unchecked pointer to an
application-specific structure, and returns its size. Likewise, there
is a dedicated [string] EDL attribute to specify null-terminated
CHECK_REF_POINTER ( pms , sizeof ( ms_my_ecall_t ));
ms_my_ecall_t * ms = SGX_CAST ( ms_my_ecall_t *, pms );
char * _tmp_s = ms -> ms_s ;
1 static sgx_status_t SGX_CDECL sgx_my_ecall ( void * pms )
2 {
3
4
5
6
7 ⭑ size_t _len_s = _tmp_s ? strlen ( _tmp_s ) + 1 : 0;
8
9
10
11
12
CHECK_UNIQUE_POINTER ( _tmp_s , _len_s );
__builtin_ia32_lfence () ; // fence after pointer checks
...
char * _in_s = NULL ;
Listing 3: Proxy function generated by edger8r for the EDL
specification: public void my_ecall([in,string] char *s).
string arguments. Essentially, this special case comes down to
[sizefunc=strlen].
Consider the code skeleton generated by edger8r in Listing 3
for an ecall that expects a single string pointer argument. In or-
der to verify that the complete string is outside the enclave, the
trusted edge routine first computes the size of the argument buffer
(through either strlen() or a dedicated sizefunc in general), and
only thereafter checks whether the entire buffer falls outside of the
enclave. It is intended that the edge code first determines the length
in untrusted memory, but we made the crucial observation that the
strlen() invocation at line 7 operates on an arbitrary unchecked
pointer, potentially pointing into enclave memory. Any pointer
poisoning attempts will subsequently be rejected at line 10, but
the unintended computation may have already leaked information
through various side-channels [24, 45]. In general, leakage occurs
whenever there is secret-dependent control or data flow in the
specified sizefunc. This is most obviously the case for the common
[string] EDL attribute, since the amount of loop operations per-
formed by strlen() reveals the number of non-zero bytes following
the specified in-enclave pointer.
Our attack builds on top of the open-source SGX-Step [45] en-
clave interrupt framework to turn the subtle strlen() side-channel
leakage into a fully deterministic oracle that reveals the exact po-
sition of all 0x00 bytes in enclave private memory (thereby for
instance fully breaking the confidentiality of booleans or providing
valuable information for cryptanalysis). Particularly, we use SGX-
Step to reliably step the strlen() execution, one instruction at a
time, leveraging the “accessed” bit in the page table entry of the
targeted in-enclave memory location as a noise-free oracle that is
deterministically set by the processor for every strlen() loop itera-
tion [47]. We confirmed that our single-stepping oracle continues to
work reliably even when the victim enclave was compiled to a sin-
gle, extremely compact rep movsb instruction (x86 string operations
can indeed be interrupted in between every loop iteration [17]).
We developed a practical end-to-end AES-NI key extraction PoC
in an application enclave built with a vulnerable version of edger8r.
Our victim enclave provides a single, multi-threaded ecall entry
point that encrypts the first 16 bytes of a given string using side-
channel resistant AES-NI instructions with a secret in-enclave key.
Since AES-NI operates exclusively on CPU registers (e.g., xmm0) and
due to the limited nature of the strlen() side-channel, we cannot
perform key extraction by directly targeting the AES state or key
in memory. Instead, our attack uses repeated encryption ecalls,
assuming varying (but not necessarily known) plaintext and known
Algorithm 1 strlen() oracle AES key recovery where S(⋅) denotes the
AES SBox and SR(p) the position of byte p after AES ShiftRows.
(P , C , L) ← random plaintext, associated ciphertext, strlen oracle
K[SR(L)] ← C[SR(L)] ⊕ S(0)
while not full key K recovered do
if L < 16 then
end if
end while
Figure 4: Overview of the key extraction attack exploiting
strlen() side-channel leakage in Intel SGX-SDK.
ciphertext. We further abuse that the Intel SGX architecture enables
a privileged adversary to precisely interrupt a victim enclave at
a chosen instruction-level granularity [45], thereby forcing the
processor to write the register state to a fixed SSA location in
enclave memory (this includes the xmm registers that are part of
the XSAVE region of the SSA frame). Figure 4 depicts the high-level
phases of the attack flow, using two threads A and B:
(a) Invoke the encryption ecall from thread A 1○ and interrupt
the enclave 2○ before the final round of the AES (i.e., before the
aesenclast instruction). To keep the PoC simple, we achieve this
requirement by inserting an access to a dummy page at the ap-
propriate point, and catching accesses to this page in a signal
handler on the untrusted side. Note that in a real-world attack,
the single-stepping feature of SGX-Step could be used to execute
the victim enclave exactly up to this point, without relying on a
more coarse-grained page fault for interruption.
(b) While the ecall in thread A is interrupted, prepare the timer
used by SGX-Step 3○ and launch a second thread B 4○ to probe
the position of the first zero byte (if any) in the intermediate AES
state. Concretely, this involves a second ecall to the same entry
point, but this time supplying an illegal in-enclave target address
pointing to the fixed memory location containing the xmm0 register
in the SSA frame of the interrupted thread A. Each time when a
timer interrupt arrives 5○, we monitor and clear 6○ the “accessed”
bit of the targeted SSA page table entry.
(c) After the strlen() probing has finished, the obtained leakage
is stored alongside the corresponding ciphertext, and thread A is
resumed by restoring read/write access to the dummy page.
(d) Repeat from step (a) with a different plaintext until the full key