and once a week thereafter. Default Red Hat 9.0 Linux
installations do not use NTP by default, though they do
present the user with the option of entering an NTP server.
Default Debian 3.0, FreeBSD 5.2.1, and OpenBSD 3.5 sys-
tems, at least under the conﬁgurations that we selected (e.g.,
“typical user”), do not even present the user with the op-
tion of installing ntpd. For such a non-professionally-
administered machine, if an adversary can learn the values
of the machine’s system clock at multiple points in time,
the adversary will be able to infer information about the de-
vice’s system clock skew, s[Csys].
THE TCP TIMESTAMPS OPTION CLOCK. RFC 1323 [13]
speciﬁes the TCP timestamps option to the TCP protocol.
A TCP ﬂow will use the TCP timestamps option if the net-
work stacks on both ends of the ﬂow implement the option
and if the initiator of the ﬂow includes the option in the
initial SYN packet. All modern operating systems that we
tested implement the TCP timestamps option. Of the sys-
tems we tested, Microsoft Windows 2000 and XP are the
only ones that do not include the TCP timestamps option in
the initial SYN packet (Microsoft Windows Pocket PC 2002
does include the option when initiating TCP ﬂows). In Sec-
tion 3 we introduce a trick for making Windows 2000- and
XP-initiated ﬂows use the TCP timestamps option.
For physical device ﬁngerprinting, the most important
property of the TCP timestamps option is that if a ﬂow uses
the option, then a portion of the header of each TCP packet
in that ﬂow will contain a 32-bit timestamp generated by
the creator of that packet. The RFC does not dictate what
values the timestamps should take, but does say that the
timestamps should be taken from a “virtual clock” that is “at
least approximately proportional to real time [13];” the RFC
1323 PAWS algorithm does stipulate (Section 4.2.2) that the
resolution of this virtual clock be between 1 ms and 1 sec-
ond. We refer to this “virtual clock” as the device’s TCP
timestamps option clock, or its TSopt clock Ctcp. There is no
requirement that a device’s TSopt clock and its system clock
be correlated. Moreover, for popular operating systems like
Windows XP, Linux, and FreeBSD, a device’s TSopt clock
may be unaffected by adjustments to the device’s system
clock via NTP. To sample some popular operating systems,
standard Red Hat 9.0 and Debian 3.0 Linux distributions2
and FreeBSD 5.2.1 machines have TSopt clocks with 10 ms
resolution, OS X Panther and OpenBSD 3.5 machines have
TSopt clocks with 500 ms resolution, and Microsoft Win-
dows 2000, XP, and Pocket PC 2002 systems have TSopt
clocks with 100 ms resolution. Most systems reset their
TSopt clock to zero upon reboot; on these systems i[Ctcp]
is the time at which the system booted. If an adversary can
learn the values of a device’s TSopt clock at multiple points
in time, then the adversary may be able to infer information
about the device’s TSopt clock skew, s[Ctcp].
2We do not generalize this to all Linux distributions since Knoppix 3.6,
with the 2.6.7 experimental kernel, has 1 ms resolution.
3 Exploiting the TCP Timestamps Option
In this section we consider (1) how an adversary might
obtain samples of a device’s TSopt clock at multiple points
in time and (2) how an adversary could use those samples
to ﬁngerprint a physical device. We assume for now that
there is a one-to-one correspondence between physical de-
vices and IP addresses, and defer to Section 8 a discussion
of how to deal with multiple active hosts behind a NAT; in
this section we do consider NATs with a single active device
behind them.
THE MEASURER. The measurer can be any entity capable
of observing TCP packets from the ﬁngerprintee, assum-
ing that those packets have the TCP timestamps option en-
abled. The measurer could therefore be the ﬁngerprintee’s
ISP, or any tap in the middle of the network over which
packets from the device travel; e.g., we apply our techniques
to a trace taken on a major Tier 1 ISP’s backbone OC-48
links. The measurer could also be any system with which
the ﬁngerprintee frequently communicates; prime examples
of such systems include a search engine like Google, a news
website, and a click-through ads service that displays con-
tent on a large number of websites. If the measurer is ac-
tive, then the measurer could also be the one to initiate a
TCP ﬂow with the ﬁngerprintee, assuming that the device
is reachable and has an open port. If the measurer is semi-
passive or active, then it could make the ﬂows that it ob-
serves last abnormally long, thereby giving the measurer
samples of the ﬁngerprintee’s clock over extended periods
of time.
A TRICK FOR MEASURING WINDOWS 2000 AND XP MA-
CHINES. We seek the ability to measure TSopt clock skews
of Windows 2000 and XP machines even if those machines
are behind NATs and ﬁrewalls. But, because of the nature of
NATs and ﬁrewalls, in these cases we will typically be lim-
ited to analyzing ﬂows initiated by the Windows machines.
Unfortunately, because Windows 2000 and XP machines do
not include the TCP timestamps option in their initial SYN
packets, the TCP timestamps RFC [13] mandates that none
of the subsequent packets in Windows-initiated ﬂows can
include the TCP timestamps option. Thus, assuming that all
parties correctly implement the TCP RFCs, a passive adver-
sary will not be able to exploit the TCP timestamps option
with Windows 2000/XP-initiated ﬂows.
If the adversary is semi-passive, we observe the follow-
ing trick. Assume for simplicity that the adversary is the de-
vice to whom the Windows machine is connecting. After re-
ceiving the initial SYN packet from the Windows machine,
the adversary will reply with a SYN/ACK, but the adversary
will break the RFC 1323 speciﬁcation and include the TCP
timestamps option in its reply. After receiving such a reply,
our Windows 2000 and XP machines ignored the fact that
they did not include the TCP timestamps option in their ini-
tial SYN packets, and included the TCP timestamps option
in all of their subsequent packets. As an extension, we note
that the adversary does not have to be the device to whom
the Windows machine is connecting. Rather, the adversary
simply needs to be able to mount a “device-in-the-middle”
attack and modify packets such that the Windows machine
receives one with the TCP timestamps option turned on. If
the adversary is the device’s ISP, then the ISP could rewrite
the Windows machine’s initial SYN packets so that they in-
clude the TCP timestamps option. The SYN/ACKs from
the legitimate recipients will therefore have the TCP times-
tamps option enabled and, from that point forward, the Win-
dows machine will include the TCP timestamps option in all
subsequent packets in the ﬂows.
We applied this technique to Windows XP machines on
a residential cable system with a LinkSys Wireless Access
Point and a NAT, as well as to Windows XP SP2 machines
using the default XP SP2 ﬁrewall, and to Windows XP SP1
machines with the Windows ZoneAlarm ﬁrewall. (While
current ﬁrewalls do not detect this trick, it is quite possible
that future ﬁrewalls might.)
ESTIMATING THE TSOPT CLOCK SKEW. Let us now as-
sume that an adversary has obtained a trace T of TCP pack-
ets from the ﬁngerprintee, and let us assume for simplicity
that all |T | packets in the trace have the TCP timestamps
option enabled. Toward estimating a device’s TSopt clock
skew s[Ctcp] we adopt the following additional notation. Let
ti be the time in seconds at which the measurer observed the
i-th packet in T and let Ti be the Ctcp timestamp contained
within the i-th packet. Deﬁne
xi = ti − t1
vi = Ti − T1
wi = vi/Hz
yi = wi − xi
OT = { (xi, yi) : i ∈ {1, . . . ,|T |} } .
The unit for wi is seconds; yi is the observed offset of the i-
th packet; OT is the the offset-set corresponding to the trace
T . We discuss below how to compute Hz if it is not known
to the measurer in advance. As an example, Figure 1 shows
the offset-sets for two devices in a two-hour trace of trafﬁc
from an Internet backbone OC-48 link on 2004-04-28 (we
omit IP addresses for privacy reasons). Shifting the clocks
by t1 and T1 for xi and vi is not necessary for our analysis
but makes plots like in Figure 1 cleaner.
If we could assume that the measurer’s clock is accurate
and that the t values represent true time, and if we could as-
sume that there is no delay between when the ﬁngerprintee
generates the i-th packet and when the measurer records
the i-th packet, then yi = oﬀ(xi + t1). Under these as-
sumptions, and if we make the additional assumption that
400
200
0
-200
-400
)
s
m
(
t
e
s
f
f
o
d
e
v
r
e
s
b
o
Source 1: 10Hz TSopt clock, 37526 packets, ttl=113
Source 2: 100Hz TSopt clock, 20974 packets, ttl=55
linear programming-based upper bound
-600
0
900
1800
2700
3600
4500
5400
6300
7200
time since start of measurement (seconds)
Figure 1. TSopt clock offset-sets for two
sources in BBN. Trace recorded on an OC-
48 link of a U.S. Tier 1 ISP, 2004-04-28 19:30–
21:30PDT. The source with the wide band has
a 10 Hz TSopt clock, the source with the nar-
row band has a 100 Hz TSopt clock. A source
with no clock skew would have a horizontal
band.
R is differentiable, then the ﬁrst derivative of y, which is
the slope of the points in OT , is the skew s of Ctcp. Since
we cannot generally make these assumptions, we are left to
approximate s from the data.
Let us consider plots like those in Figure 1 more closely.
We ﬁrst observe that the large band corresponds to a device
where the TSopt clock has low resolution (r = 100 ms) and
that the narrow band corresponds to a device with a higher
resolution (r = 10 ms). The width of these bands, and in
particular the wide band, means that if the duration of our
trace is short, we cannot always approximate the slope of
the points in OT by computing the slope between any two
points in the set. Moreover, as Paxson and others have noted
in similar contexts [22, 20], variable network delay renders
simple linear regression insufﬁcient. Consequently, to ap-
proximate the the skew s from OT , we borrow a linear pro-
gramming solution from Moon, Skelly, and Towsley [20],
which has as its core Graham’s convex hull algorithm on
sorted data [12].
The linear programming solution outputs the equation of
a line αx + β that upper-bounds the set of points OT . We
use an upper bound because network and host delays are all
positive. The slope of the line, α, is our estimate of the clock
skew of Ctcp. In detail, the linear programming constraints
for this line are that, for all i ∈ {1, . . . ,|T |},
α · xi + β ≥ yi ,
which means that the solution must upper-bound all the
points in OT . The linear programming solution then mini-
mizes the average vertical distance of all the points in OT
from the line; i.e., the linear programming solution is one
that minimizes the objective function
(cid:2)
α · xi + β − yi
(cid:3)
.
1
|T | ·
|T |(cid:1)
i=1
Although one can solve the above using standard linear pro-
gramming techniques, as Moon, Skelly, and Towsley [20]
note, there exist techniques to solve linear programming
problems in two variables in linear time [10, 16]. We use
a linear time algorithm in all our computations.
It remains to discuss how to infer Hz if the measurer does
not know it in advance. One solution involves computing
the slope of the points
I = { (xi, vi) : i ∈ {1, . . . ,|T | }
and rounding to the nearest integer. One can compute the
slope of this set by adapting the above linear programming
problem to this set.
AN EQUIVALENT VIEW. If A is the slope of the points in
the above set I, derived using the linear programming al-
gorithm, then one could also approximate the skew of Ctcp
as A/Hz − 1. This approach is simply a different way of
arriving at the same solution since we can prove that, when
using the linear programming method for slope estimation,
both approaches produce the same skew estimate. We use
the offset-set approach since these sets naturally yield ﬁg-
ures where the skews are clearly visible; e.g., Figure 1.
4 Exploiting ICMP Timestamp Requests
THE MEASURER. To exploit a device’s system time clock
skew, the measurer could be any website with which the ﬁn-
gerprintee communicates, or any other device on the Inter-
net provided that the measurer is capable of issuing ICMP
Timestamp Requests (ICMP message type 13) to the ﬁn-
gerprintee. The measurer must also be capable of record-
ing the ﬁngerprintee’s subsequent ICMP Timestamp Reply
messages (ICMP message type 14). In order for this tech-
nique to be mountable, the primary limitation is that the de-
vice must not be behind a NAT or ﬁrewall that ﬁlters ICMP.
ESTIMATING THE SYSTEM CLOCK SKEW. Let us now as-
sume that an adversary has obtained a trace T of ICMP
Timestamp Reply messages from the ﬁngerprintee. The
ICMP Timestamp Reply messages will contain two 32-bit
values generated by the ﬁngerprintee. The ﬁrst value is
the time at which the corresponding ICMP Timestamp Re-
quest packet was received, and the second value is the time
at which the ICMP Timestamp Reply was generated; here
time is according to the ﬁngerprintee’s system clock, Csys,
and is reported in milliseconds since midnight UTC. Win-
dows machines report the timestamp in little endian for-
mat, whereas all the other machines that we tested report
the timestamp in big endian notation. The remaining nota-
tion and the method for skew estimation is now identical to
what we presented in Section 3, with two minor exceptions.
First, the adversary does not have to compute Hz since RFC
792 [23] requires that Hz be 1000 (or, if not, that a spe-
cial bit be set to indicate non-compliance). Second, since
the time reported in the ICMP Timestamp Reply is in mil-
liseconds since midnight UTC, we expect the timestamps
reported in the ICMP Timestamp Reply messages to reset
approximately once a day; we adjust the v values accord-
ingly. (The only thing special that our attack exploits about
ICMP is the fact that ICMP has a message type that will
reveal a device’s system time; our techniques would work
equally well with any other protocol that leaks information
about a device’s system or other clock.)
BRIEF COMPARISON WITH TCP TIMESTAMPS. For much
of the rest of this paper, we focus on our TCP timestamps-
based approach for physical device ﬁngerprinting rather
than our ICMP-based approach. This is not because we
consider the ICMP-based approach to be inferior. Rather,
we focus on the TCP timestamps-based approach because
most systems have TSopt clocks that operate at a lower
frequency than the 1000 Hz clocks included in the ICMP
timestamp reply messages. This means that it should re-
quire less data for an active adversary to mount our ICMP
ﬁngerprinting technique than to mount our TCP timestamps
technique. Our positive results for the TCP timestamps-
based ﬁngerprinting techniques imply that the ICMP-based
ﬁngerprinting technique will be effective and will have low
data requirements. Focusing on our TCP timestamps based
approach also allows us to experiment with machines be-
hind NATs and ﬁrewalls. We also remark that for popular
operating systems, if a system does not externally synchro-
nize its system time, then the system’s TSopt and system
clocks will be highly correlated (Section 7), which means
that the distribution of system clock skews for machines not
using NTP will be similar to the distribution of TSopt clocks
skews.
5 Distribution and stability of TSopt clock
skew measurements
We now address two fundamental properties that must
hold in order for remote clock skew estimation to be an
effective physical device ﬁngerprinting technique. First,
we show that there is variability in different devices’ clock
skews, meaning that it is reasonable to expect different de-
vices on the Internet to have measurably different clock
skews. Second, we give evidence to suggest that clock
skews, as measured by our techniques, are relatively con-
stant over time. These two facts provide the basis for our
min pkts min duration
per hour
per hour
(md, mins)
(mp)
0
0
0
500
500
500
2000
2000
2000
10
30
50
10
30
50