最终解出来是`Sakura_Love_Strawberry`，用这个来解压刚刚的压缩包即可获取到flag
## Reverse
###  tree
Win32 PE 逆向
放入IDA分析，main函数如下所示：
    int __cdecl main(int argc, const char **argv, const char **envp)
    {
      char v4; // [esp+1Dh] [ebp-33h]
      bool v5; // [esp+48h] [ebp-8h]
      int v6; // [esp+4Ch] [ebp-4h]
      __main();
      init();
      puts(aInputYourFlag);
      scanf("%43s", &v4);
      v6 = chkflag(&v4);
      v5 = parse(root);
      if ( v6 || v5 != 1 )
        puts("No no no~~");
      else
        puts("Congratulations!");
      return 0;
    }
在init中初始化了全局变量root，经调试，在内存中如图所示
深颜色的就是初始化过的root，可以明显的看出来这是一组地址
然后程序让输入43位flag，进入chkflag里面第一次检查flag格式
    signed int __cdecl chkflag(char *a1)
    {
      size_t v2; // ebx
      char v3[4]; // [esp+1Dh] [ebp-3Bh]
      size_t i; // [esp+48h] [ebp-10h]
      int v5; // [esp+4Ch] [ebp-Ch]
      strcpy(v3, "flag{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}");
      v5 = -1;
      for ( i = 0; ; ++i )
      {
        v2 = i;
        if ( v2 >= strlen(v3) )
          break;
        if ( v3[i] == 'x' )
        {
          ++v5;
          switch ( a1[i] )
          {
            case '0':
              glockflag[4 * v5] = '0';
              glockflag[4 * v5 + 1] = '0';
              glockflag[4 * v5 + 2] = '0';
              glockflag[4 * v5 + 3] = '0';
              break;
            case '1':
              glockflag[4 * v5] = '0';
              glockflag[4 * v5 + 1] = '0';
              glockflag[4 * v5 + 2] = 48;
              glockflag[4 * v5 + 3] = '1';
              break;
            case '2':
              glockflag[4 * v5] = 48;
              glockflag[4 * v5 + 1] = 48;
              glockflag[4 * v5 + 2] = 49;
              glockflag[4 * v5 + 3] = 48;
              break;
            case '3':
              glockflag[4 * v5] = 48;
              glockflag[4 * v5 + 1] = 48;
              glockflag[4 * v5 + 2] = 49;
              glockflag[4 * v5 + 3] = 49;
              break;
            case '4':
              glockflag[4 * v5] = 48;
              glockflag[4 * v5 + 1] = 49;
              glockflag[4 * v5 + 2] = 48;
              glockflag[4 * v5 + 3] = 48;
              break;
            case '5':
              glockflag[4 * v5] = 48;
              glockflag[4 * v5 + 1] = 49;
              glockflag[4 * v5 + 2] = 48;
              glockflag[4 * v5 + 3] = 49;
              break;
            case '6':
              glockflag[4 * v5] = 48;
              glockflag[4 * v5 + 1] = 49;
              glockflag[4 * v5 + 2] = 49;
              glockflag[4 * v5 + 3] = 48;
              break;
            case '7':
              glockflag[4 * v5] = 48;
              glockflag[4 * v5 + 1] = 49;
              glockflag[4 * v5 + 2] = 49;
              glockflag[4 * v5 + 3] = 49;
              break;
            case '8':
              glockflag[4 * v5] = 49;
              glockflag[4 * v5 + 1] = 48;
              glockflag[4 * v5 + 2] = 48;
              glockflag[4 * v5 + 3] = 48;
              break;
            case '9':
              glockflag[4 * v5] = '1';
              glockflag[4 * v5 + 1] = '0';
              glockflag[4 * v5 + 2] = 48;
              glockflag[4 * v5 + 3] = 49;
              break;
            case 'a':
              glockflag[4 * v5] = '1';
              glockflag[4 * v5 + 1] = '0';
              glockflag[4 * v5 + 2] = '1';
              glockflag[4 * v5 + 3] = '0';
              break;
            case 'b':
              glockflag[4 * v5] = 49;
              glockflag[4 * v5 + 1] = 48;
              glockflag[4 * v5 + 2] = 49;
              glockflag[4 * v5 + 3] = 49;
              break;
            case 'c':
              glockflag[4 * v5] = 49;
              glockflag[4 * v5 + 1] = 49;
              glockflag[4 * v5 + 2] = 48;
              glockflag[4 * v5 + 3] = 48;
              break;
            case 'd':
              glockflag[4 * v5] = 49;
              glockflag[4 * v5 + 1] = 49;
              glockflag[4 * v5 + 2] = 48;
              glockflag[4 * v5 + 3] = 49;
              break;
            case 'e':
              glockflag[4 * v5] = 49;
              glockflag[4 * v5 + 1] = 49;
              glockflag[4 * v5 + 2] = 49;
              glockflag[4 * v5 + 3] = 48;
              break;
            case 'f':
              glockflag[4 * v5] = 49;
              glockflag[4 * v5 + 1] = 49;
              glockflag[4 * v5 + 2] = 49;
              glockflag[4 * v5 + 3] = 49;
              break;
            default:
              return -1;
          }
        }
        else if ( a1[i] != v3[i] )
        {
          return -1;
        }
      }
      return 0;
    }
格式限制为flag{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}，其中x代表字符，范围在0~f内,不同的字符定义了不同的规则，glockflag是规则所存的地址，每四个数为一组，根据我们输入的flag然后初始化glockflag全局变量
然后进入到parse函数进行第二次检查，参数为root，root此时已经初始化完毕
    bool __cdecl parse(int a1)
    {
      char v2[60]; // [esp+18h] [ebp-50h]
      int v3; // [esp+54h] [ebp-14h]
      int v4; // [esp+58h] [ebp-10h]
      int v5; // [esp+5Ch] [ebp-Ch]
      v5 = 0;
      v4 = 0;
      v3 = a1;
      do
      {
        if ( glockflag[v5] == '0' )
        {
          v3 = *(v3 + 0xC);
        }
        else if ( glockflag[v5] == '1' )
        {
          v3 = *(v3 + 0x10);
        }
        ++v5;
        if ( *v3 > 0x60 && *v3  当然还可以用二叉树的方法来解这道题
## Crypto
###  RUA
题目附件如下所示：文件名就是rsa
    密文
    8024667293310019199660855174436055144348010556139300886990767145319919733369837206849070207955417356957254331839203914525519504562595117422955140319552013305532068903324132309109484106720045613714716627620318471048195232209672212970269569790677144450501305289670783572919282909796765124242287108717189750662740283813981242918671472893126494796140877412502365037187659905034193901633516360208987731322599974612602945866477752340080783296268396044532883548423045471565356810753599618810964317690395898263698123505876052304469769153374038403491084285836952034950978098249299597775306141671935146933958644456499200221696
    n
    18856599160001833299560082802925753595735945621023660831294740454109973698430284916320395522883536507135735383517926050963512440162483065097256884040938259092582892259657340825971260278387406398529168309426241530551396056450450728728601248269612166083300938497235910244979946020059799495231539400114422748104072550004260736766137354572252872437140063474603268146956570787143010441293268321641092743010805639953103578977668248726500636191043930770036787317928372179939360510179438436665591755940224156131460271763912868322774604558314812111335691108887319827579162188169744014973478052491398688611046800951698773893393
    密文
    17388575106047489057419896548519877785989670179021521580945768965101106268068805843720622749203590810185213416901978773748832854888898576822477243682874784689127705334243899967896321836688567602323551986980634884700045627950473546069670440078998428940082620044462222475031805594211784370238038168894827559017562364252406425134530719911057780692073760058203345936344269833206906999625580911856011564697811258009937314511410514416706482571471852503756675411177080916350899445106002226392895645443215522671155311715637759618276305217468892076287376401516124640727839779731609203202530346427613422430202271506248285086956
    n
    21996468204721630460566169654781925102402634427772676287751800587544894952838038401189546149401344752771866376882226876072201426041697882026653772987648569053238451992877808811034545463363146057879646485465730317977739706776287970278094261290398668538232727000322458605289913900919015380904209692398479885177984131014170652915222062267448446642158394150657058846328033404309210836219241651882903083719822769947131283541299760283547938795574020478852839044803553093825730447126796668238131579735916546235889726257184058908852902241422169929720898025622336508382492878690496154797198800699611812166851455110635853297883
    密文
    5170826942130658374627267470548549396328896108666717036999395626588154882531377393671593939192779292151584678688653835775920356845071292462816417186595460417761844407911946323815187102170021222644920874070699813549492713967666736815947822200867353461264579419205756500926218294604616696969184793377381622818381733352202456524002876336304465082656612634304327627259494264840838687207529676882041997761204004549052900816658341867989593333356630311753611684503882509990853456022056473296726728969894815574884063807804354952314391764618179147583447848871220103094864884798102542377747761263052887894135796051521881179607
    n
    22182114562385985868993176463839749402849876738564142471647983947408274900941377521795379832791801082248237432130658027011388009638587979450937703029168222842849801985646044116463703409531938580410511097238939431284352109949200312466658018635489121157805030775386698514705824737070792739967925773549468095396944503293347398507980924747059180705269064441084577177316227162712249300900490014519213102070911105044792363935553422311683947941027846793608299170467483012199132849683112640658915359398437290872795783350944147546342693285520002760411554647284259473777888584007026980376463757296179071968120796742375210877789
所以很明显是rsa广播攻击,一把梭即可
exp:
    # coding:utf8
    from struct import pack, unpack
    import zlib
    import gmpy
    def my_parse_number(number):
        string = "%x" % number
        #if len(string) != 64:
        #    return ""
        erg = []
        while string != '':
            erg = erg + [chr(int(string[:2], 16))]
            string = string[2:]
        return ''.join(erg)
    def extended_gcd(a, b):
        x,y = 0, 1
        lastx, lasty = 1, 0
        while b:
            a, (q, b) = b, divmod(a,b)
            x, lastx = lastx-q*x, x
            y, lasty = lasty-q*y, y
        return (lastx, lasty, a)
    def chinese_remainder_theorem(items):
      N = 1
      for a, n in items:
        N *= n
      result = 0
      for a, n in items:
        m = N/n
        r, s, d = extended_gcd(n, m)
        if d != 1:
          N=N/n
          continue
          #raise "Input not pairwise co-prime"
        result += a*s*m
      return result % N, N
    '''
    c1 = m**e mod n1
    c2 = m**e mod n2
    c3 = m**e mod n3
    ... ...
    '''
    sessions=[{"c":8024667293310019199660855174436055144348010556139300886990767145319919733369837206849070207955417356957254331839203914525519504562595117422955140319552013305532068903324132309109484106720045613714716627620318471048195232209672212970269569790677144450501305289670783572919282909796765124242287108717189750662740283813981242918671472893126494796140877412502365037187659905034193901633516360208987731322599974612602945866477752340080783296268396044532883548423045471565356810753599618810964317690395898263698123505876052304469769153374038403491084285836952034950978098249299597775306141671935146933958644456499200221696,"e":17,"n":18856599160001833299560082802925753595735945621023660831294740454109973698430284916320395522883536507135735383517926050963512440162483065097256884040938259092582892259657340825971260278387406398529168309426241530551396056450450728728601248269612166083300938497235910244979946020059799495231539400114422748104072550004260736766137354572252872437140063474603268146956570787143010441293268321641092743010805639953103578977668248726500636191043930770036787317928372179939360510179438436665591755940224156131460271763912868322774604558314812111335691108887319827579162188169744014973478052491398688611046800951698773893393},{"c":
    17388575106047489057419896548519877785989670179021521580945768965101106268068805843720622749203590810185213416901978773748832854888898576822477243682874784689127705334243899967896321836688567602323551986980634884700045627950473546069670440078998428940082620044462222475031805594211784370238038168894827559017562364252406425134530719911057780692073760058203345936344269833206906999625580911856011564697811258009937314511410514416706482571471852503756675411177080916350899445106002226392895645443215522671155311715637759618276305217468892076287376401516124640727839779731609203202530346427613422430202271506248285086956,"e":17,"n":21996468204721630460566169654781925102402634427772676287751800587544894952838038401189546149401344752771866376882226876072201426041697882026653772987648569053238451992877808811034545463363146057879646485465730317977739706776287970278094261290398668538232727000322458605289913900919015380904209692398479885177984131014170652915222062267448446642158394150657058846328033404309210836219241651882903083719822769947131283541299760283547938795574020478852839044803553093825730447126796668238131579735916546235889726257184058908852902241422169929720898025622336508382492878690496154797198800699611812166851455110635853297883},{"c":5170826942130658374627267470548549396328896108666717036999395626588154882531377393671593939192779292151584678688653835775920356845071292462816417186595460417761844407911946323815187102170021222644920874070699813549492713967666736815947822200867353461264579419205756500926218294604616696969184793377381622818381733352202456524002876336304465082656612634304327627259494264840838687207529676882041997761204004549052900816658341867989593333356630311753611684503882509990853456022056473296726728969894815574884063807804354952314391764618179147583447848871220103094864884798102542377747761263052887894135796051521881179607,"e":17,"n":22182114562385985868993176463839749402849876738564142471647983947408274900941377521795379832791801082248237432130658027011388009638587979450937703029168222842849801985646044116463703409531938580410511097238939431284352109949200312466658018635489121157805030775386698514705824737070792739967925773549468095396944503293347398507980924747059180705269064441084577177316227162712249300900490014519213102070911105044792363935553422311683947941027846793608299170467483012199132849683112640658915359398437290872795783350944147546342693285520002760411554647284259473777888584007026980376463757296179071968120796742375210877789}]
    data = []
    for session in sessions:
        e=session['e']
        n=session['n']
        msg=session['c']
        data += [(msg, n)]
    print "Please wait, performing CRT"
    x, n = chinese_remainder_theorem(data)
    e=session['e']
    realnum = gmpy.mpz(x).root(e)[0].digits()
    print my_parse_number(int(realnum))
## 总结
这次比赛收获还是挺大的，继续冲冲冲！！！