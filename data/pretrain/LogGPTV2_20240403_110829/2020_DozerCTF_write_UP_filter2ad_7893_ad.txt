    int add(int num1,int num2)
    {
        return num2?add(xors(num1,num2),ands(num1,num2)0){
            if(ands(multiplier,0x1)>0){
                product=add(product,multiplicand);
            }
            multiplicand=multiplicand>1;
        }
        if(xors(a,b)=0){
           if((x>>i)>=y){
               ans = add(ans,(i
    unsigned int FUN_00400c94(unsigned int param_1,unsigned int param_2)
    {
    unsigned int uVar1;
    unsigned int uVar2;
    unsigned int uVar3;
    uVar3 = ~(param_1 & param_2) & (param_1 | param_2);
    uVar3 = uVar3 | uVar3 >> 1;
    uVar3 = uVar3 | uVar3 >> 2;
    uVar3 = uVar3 | uVar3 >> 4;
    uVar3 = uVar3 | uVar3 >> 8;
    uVar3 = uVar3 | uVar3 >> 0x10;
    uVar2 = ~(uVar3 & uVar3 >> 1) & (uVar3 | uVar3 >> 1) & param_1;
    uVar2 = uVar2 | uVar2 >> 1;
    uVar3 = uVar3 & 1 | (uVar3 & 1) > 2;
    uVar2 = uVar2 | uVar2 >> 4;
    uVar3 = uVar3 | uVar3 > 8;
    uVar2 = uVar2 | uVar2 >> 0x10;
    uVar3 = uVar3 | uVar3 
###  notfeal
基本上*ctf 2019原题（sixstar的师傅别来捶我）使用sixstar的脚本直接打好像没太大问题。
## Pwn
###  虚假的pwn题
**题目描述**
这题目好虚假啊  
118.31.11.216:30009
**出题思路**
虚假的pwn手出了一道虚假的pwn题，本题是CTF-One-For-All上面提供的源码，进行了修改，是一道BROP，对于输入的内容进行了异或6的操作，又因为这里采用了strcpy的操作，导致0截断，所以在作题过程中需要考虑到这两点，之后就意想不到的只有一队做出来，最后在自己复盘反思的时候发现，glibc版本还得盲猜，这个其实就有点微妙了，所以出题比较失败（给参加比赛的pwn爷跪下）
**解题思路**
可以直接转向fmyy大师傅的博客了，[https://fmyy.pro/2020/06/15/Competition/DozerCTF/基本只能这么做。](https://fmyy.pro/2020/06/15/Competition/DozerCTF/%E5%9F%BA%E6%9C%AC%E5%8F%AA%E8%83%BD%E8%BF%99%E4%B9%88%E5%81%9A%E3%80%82)
###  酸菜鱼
**题目描述**
我是酸菜鱼，又酸又菜又多余  
nc 118.31.11.216 30078
**解题思路**
_starCTF_ 原题魔改，直接用他那个脚本打就没啥大问题
###  ret2 temp
ret2dl模板题，直接打！