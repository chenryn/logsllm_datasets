Table）的简称，它是NTFS文件系统的核心。MFT由一个个MFT项（也称为文件记录）组成。每个MFT项的前部为0x10字节的头结构，用来描述本MFT项的相关信息。后面节存放着属性。每个文件和目录的信息都包含在MFT中，每个文件和目录至少有一个MFT项。除了引导扇区外，访问其他任何一个文件前都需要先访问MFT，在MFT中找到该文件的MFT项，根据MFT项中记录的信息找到文件内容并对其进行访问。
MFT结构分为两种：元文件与普通文件。
元文件对于用户是不能直接访问的，MFT将开头的16个文件记录块保留用于这些元数据文件，除此之外的文件记录块才用于普通的用户文件和目录。
**16个元文件**
    #defineMFT_IDX_MFT0
    #defineMFT_IDX_MFT_MIRR1
    #defineMFT_IDX_LOG_FILE2
    #defineMFT_IDX_VOLUME3
    #defineMFT_IDX_ATTR_DEF4
    #defineMFT_IDX_ROOT5
    #defineMFT_IDX_BITMAP6
    #defineMFT_IDX_BOOT7
    #defineMFT_IDX_BAD_CLUSTER8
    #defineMFT_IDX_SECURE9
    #defineMFT_IDX_UPCASE10
    #defineMFT_IDX_EXTEND11
    #defineMFT_IDX_RESERVED1212
    #defineMFT_IDX_RESERVED1313
    #defineMFT_IDX_RESERVED1414
    #defineMFT_IDX_RESERVED1515
    #defineMFT_IDX_USER16
这16个原文件本身也是MFT结构的模式，可以理解为记录了MFT信息的MFT结构。
**怎么解析这16个原文件的MFT结构呢？**
换句话说，通过MBR定位到DBR,通过DBR定位到MFT，此时的MFT就对应着索引为MFT_IDX_MFT的MFT，向后偏移文件记录大小的地方，就存放着索引为MFT_IDX_MFT_MIRR的MFT。再向后偏移文件记录大小的地方，就存放着索引为MFT_IDX_LOG_FILE的MFT
**解析这16个原文件的MFT结构有什么用？**
如对于MFT_IDX_VOLUME
这个MFT结构，解析这个MFT结构中的ATTR_TYPE_VOLUME_INFORMATION（对应着0x70）就可以得到NTFS卷的版本信息,解析这个MFT结构中的ATTR_TYPE_VOLUME_NAME属性（对应着0x60）就可以得到NTFS卷名信息。
再如，对于MFT_IDX_MFT
这个MFT结构，解析这个MFT结构中的ATTR_TYPE_DATA（对应0x80）的属性RealSize，就表示整个卷所有的文件记录的大小信息。利用这个大小信息是以字节表示的，用这个大小信息除以每个文件记录所占用的字节就得到了卷占有的文件记录数量。计算出来的文件记录数量是将元文件也计算在内的。
依次遍历每个文件记录数量，读取这个文件记录的内容就是MFT结构，解析这个MFT的对应属性就可以解析出文件名、文件属性、文件内容等。
**普通MFT**
遍历文件时，从第16个文件记录开始向后遍历，才会得到普通的用户文件和目录信息及内容。
**数据结构**
MFT的直观结构如下，
// 文件记录体
// 属性1
// 属性2
// …………
每个MFT的结构如下：
    // 文件记录头  
    typedef struct _FILE_RECORD_HEADER  
    {  
     /*+0x00*/  uint32 Type;            // 固定值'FILE'  
     /*+0x04*/  uint16 UsaOffset;       // 更新序列号偏移, 与操作系统有关  
     /*+0x06*/  uint16 UsaCount;        // 固定列表大小Size in words of Update Sequence Number & Array (S)  
     /*+0x08*/  uint64 Lsn;             // 日志文件序列号(LSN)  
    } FILE_RECORD_HEADER, *PFILE_RECORD_HEADER;  
    // 文件记录体  
    typedef struct _FILE_RECORD{  
     /*+0x00*/  FILE_RECORD_HEADER Ntfs;  // MFT表头  
     /*+0x10*/  uint16  SequenceNumber;   // 序列号(用于记录文件被反复使用的次数)  
     /*+0x12*/  uint16  LinkCount;        // 硬连接数  
     /*+0x14*/  uint16  AttributeOffset;  // 第一个属性偏移  
     /*+0x16*/  uint16  Flags;            // falgs, 00表示删除文件,01表示正常文件,02表示删除目录,03表示正常目录  
     /*+0x18*/  uint32  BytesInUse;       // 文件记录实时大小(字节) 当前MFT表项长度,到FFFFFF的长度+4  
     /*+0x1C*/  uint32  BytesAllocated;   // 文件记录分配大小(字节)  
     /*+0x20*/  uint64  BaseFileRecord;   // = 0 基础文件记录 File reference to the base FILE record  
     /*+0x28*/  uint16  NextAttributeNumber; // 下一个自由ID号  
     /*+0x2A*/  uint16  Pading;           // 边界  
     /*+0x2C*/  uint32  MFTRecordNumber;  // windows xp中使用,本MFT记录号  
     /*+0x30*/  uint32  MFTUseFlags;      // MFT的使用标记  
    }FILE_RECORD, *pFILE_RECORD;
根据FILE头部数据找到下面的一个个属性,接下来分析的就是一个个属性了，属性由属性头跟属性体组成,属性头的结构定义如下：
    // 属性头  
    typedef struct  
    {  
     /*+0x00*/  ATTRIBUTE_TYPE AttributeType;    // 属性类型  
     /*+0x04*/  uint16 RecordLength;             // 总长度(Header+body长度)  
     /**0x06*/  uint16 unknow0;  
     /*+0x08*/  uchar Nonresident;               // 非常驻标志  
     /*+0x09*/  uchar NameLength;                // 操作属性名长度  
                                              // 0X0001为压缩标记  
                                            // 0X4000为加密标记  
                                            // 0X8000为系数文件标志  
     /*+0x0A*/  uint16 NameOffset;           // 属性名偏移(从属性起始位置的偏移)  
                                                  // NameLength 如果不为零,则用这个值去寻址数据偏移  
     /*+0x0C*/  uint16 Flags;                    // ATTRIBUTE_xxx flags.  
     /*+0x0E*/  uint16 AttributeNumber;          // The file-record-unique attribute instance number for this attribute.  
    } ATTRIBUTE, *PATTRIBUTE;  
    // 属性头   
    typedef struct _RESIDENT_ATTRIBUTE  
    {  
     /*+0x00*/  ATTRIBUTE Attribute;   // 属性  
     /*+0x10*/  uint32 ValueLength;    // Data部分长度  
     /*+0x14*/  uint16 ValueOffset;    // Data内容起始偏移  
     /*+0x16*/  uchar Flags;           // 索引标志  
     /*+0x17*/  uchar Padding0;        // 填充  
    } RESIDENT_ATTRIBUTE, *PRESIDENT_ATTRIBUTE;
Petya中涉及到MFT的属性
    // 属性类型定义 
    AttributeFileName = 0x30,  
    AttributeData = 0x80, 
    这两个属性的定义如下：
    // 文件属性ATTRIBUTE.AttributeType == 0x30  
    typedef struct  
    {  
     /*+0x00*/  uint64 DirectoryFile:48;    // 父目录记录号(前个字节)  
     /*+0x06*/  uint64 ReferenceNumber:16;  // +序列号(与目录相关)  
     /*+0x08*/  uint64 CreationTime;        // 文件创建时间  
     /*+0x10*/  uint64 ChangeTime;          // 文件修改时间          
     /*+0x18*/  uint64 LastWriteTime;       // MFT更新的时间  
     /*+0x20*/  uint64 LastAccessTime;      // 最后一次访问时间  
     /*+0x28*/  uint64 AllocatedSize;       // 文件分配大小  
     /*+0x30*/  uint64 DataSize;            // 文件实际大小  
     /*+0x38*/  uint32 FileAttributes;      // 标志,如目录压缩隐藏等  
     /*+0x3C*/  uint32 AlignmentOrReserved; // 用于EAS和重解析  
     /*+0x40*/  uchar NameLength;      // 以字符计的文件名长度,没字节占用字节数由下一字节命名空间确定  
                // 文件名命名空间, 0 POSIX大小写敏感,1 win32空间,2 DOS空间, 3 win32&DOS空间  
     /*+0x41*/  uchar NameType;          