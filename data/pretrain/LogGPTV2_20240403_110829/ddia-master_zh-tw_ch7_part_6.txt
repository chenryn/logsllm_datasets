#### 原子写
许多资料库提供了原子更新操作，从而消除了在应用程式程式码中执行读取 - 修改 - 写入序列的需要。如果你的程式码可以用这些操作来表达，那这通常是最好的解决方案。例如，下面的指令在大多数关系资料库中是并发安全的：
```sql
UPDATE counters SET value = value + 1 WHERE key = 'foo';
```
类似地，像 MongoDB 这样的文件资料库提供了对 JSON 文件的一部分进行本地修改的原子操作，Redis 提供了修改资料结构（如优先顺序伫列）的原子操作。并不是所有的写操作都可以用原子操作的方式来表达，例如 wiki 页面的更新涉及到任意文字编辑 [^viii]，但是在可以使用原子操作的情况下，它们通常是最好的选择。
[^viii]: 将文字文件的编辑表示为原子的变化流是可能的，尽管相当复杂。请参阅 “[自动冲突解决](ch5.md#自动冲突解决)”。
原子操作通常透过在读取物件时，获取其上的排它锁来实现。以便更新完成之前没有其他事务可以读取它。这种技术有时被称为 **游标稳定性（cursor stability）**【36,37】。另一个选择是简单地强制所有的原子操作在单一执行绪上执行。
不幸的是，ORM 框架很容易意外地执行不安全的读取 - 修改 - 写入序列，而不是使用资料库提供的原子操作【38】。如果你知道自己在做什么那当然不是问题，但它经常产生那种很难测出来的微妙 Bug。
#### 显式锁定
如果资料库的内建原子操作没有提供必要的功能，防止丢失更新的另一个选择是让应用程式显式地锁定将要更新的物件。然后应用程式可以执行读取 - 修改 - 写入序列，如果任何其他事务尝试同时读取同一个物件，则强制等待，直到第一个 **读取 - 修改 - 写入序列** 完成。
例如，考虑一个多人游戏，其中几个玩家可以同时移动相同的棋子。在这种情况下，一个原子操作可能是不够的，因为应用程式还需要确保玩家的移动符合游戏规则，这可能涉及到一些不能合理地用资料库查询实现的逻辑。但你可以使用锁来防止两名玩家同时移动相同的棋子，如例 7-1 所示。
**例 7-1 显式锁定行以防止丢失更新**
```plsql
BEGIN TRANSACTION;
SELECT * FROM figures
  WHERE name = 'robot' AND game_id = 222
FOR UPDATE;
-- 检查玩家的操作是否有效，然后更新先前 SELECT 返回棋子的位置。
UPDATE figures SET position = 'c4' WHERE id = 1234;
COMMIT;
```
- `FOR UPDATE` 子句告诉资料库应该对该查询返回的所有行加锁。
这是有效的，但要做对，你需要仔细考虑应用逻辑。忘记在程式码某处加锁很容易引入竞争条件。
#### 自动检测丢失的更新
原子操作和锁是透过强制 **读取 - 修改 - 写入序列** 按顺序发生，来防止丢失更新的方法。另一种方法是允许它们并行执行，如果事务管理器检测到丢失更新，则中止事务并强制它们重试其 **读取 - 修改 - 写入序列**。
这种方法的一个优点是，资料库可以结合快照隔离高效地执行此检查。事实上，PostgreSQL 的可重复读，Oracle 的可序列化和 SQL Server 的快照隔离级别，都会自动检测到丢失更新，并中止惹麻烦的事务。但是，MySQL/InnoDB 的可重复读并不会检测 **丢失更新**【23】。一些作者【28,30】认为，资料库必须能防止丢失更新才称得上是提供了 **快照隔离**，所以在这个定义下，MySQL 下不提供快照隔离。
丢失更新检测是一个很好的功能，因为它不需要应用程式码使用任何特殊的资料库功能，你可能会忘记使用锁或原子操作，从而引入错误；但丢失更新的检测是自动发生的，因此不太容易出错。
#### 比较并设定（CAS）
在不提供事务的资料库中，有时会发现一种原子操作：**比较并设定**（CAS, 即 Compare And Set，先前在 “[单物件写入](#单物件写入)” 中提到）。此操作的目的是为了避免丢失更新：只有当前值从上次读取时一直未改变，才允许更新发生。如果当前值与先前读取的值不匹配，则更新不起作用，且必须重试读取 - 修改 - 写入序列。
例如，为了防止两个使用者同时更新同一个 wiki 页面，可以尝试类似这样的方式，只有当用户开始编辑后页面内容未发生改变时，才会更新成功：
```sql
-- 根据资料库的实现情况，这可能安全也可能不安全
UPDATE wiki_pages SET content = '新内容'
  WHERE id = 1234 AND content = '旧内容';
```
如果内容已经更改并且不再与 “旧内容” 相匹配，则此更新将不起作用，因此你需要检查更新是否生效，必要时重试。但是，如果资料库允许 `WHERE` 子句从旧快照中读取，则此语句可能无法防止丢失更新，因为即使发生了另一个并发写入，`WHERE` 条件也可能为真。在依赖资料库的 CAS 操作前要检查其是否安全。
#### 冲突解决和复制
在复制资料库中（请参阅 [第五章](ch5.md)），防止丢失的更新需要考虑另一个维度：由于在多个节点上存在资料副本，并且在不同节点上的资料可能被并发地修改，因此需要采取一些额外的步骤来防止丢失更新。
锁和 CAS 操作假定只有一个最新的资料副本。但是多主或无主复制的资料库通常允许多个写入并发执行，并非同步复制到副本上，因此无法保证只有一个最新资料的副本。所以基于锁或 CAS 操作的技术不适用于这种情况（我们将在 “[线性一致性](ch9.md#线性一致性)” 中更详细地讨论这个问题）。
相反，如 “[检测并发写入](ch5.md#检测并发写入)” 一节所述，这种复制资料库中的一种常见方法是允许并发写入建立多个冲突版本的值（也称为兄弟），并使用应用程式码或特殊资料结构在事实发生之后解决和合并这些版本。
原子操作可以在复制的上下文中很好地工作，尤其当它们具有可交换性时（即，可以在不同的副本上以不同的顺序应用它们，且仍然可以得到相同的结果）。例如，递增计数器或向集合新增元素是可交换的操作。这是 Riak 2.0 资料型别背后的思想，它可以防止复制副本丢失更新。当不同的客户端同时更新一个值时，Riak 自动将更新合并在一起，以免丢失更新【39】。
另一方面，最后写入胜利（LWW）的冲突解决方法很容易丢失更新，如 “[最后写入胜利（丢弃并发写入）](ch5.md#最后写入胜利（丢弃并发写入）)” 中所述。不幸的是，LWW 是许多复制资料库中的预设方案。
### 写入偏差与幻读
前面的章节中，我们看到了 **脏写** 和 **丢失更新**，当不同的事务并发地尝试写入相同的物件时，会出现这两种竞争条件。为了避免资料损坏，这些竞争条件需要被阻止 —— 既可以由资料库自动执行，也可以透过锁和原子写操作这类手动安全措施来防止。