commit block ğµ by epoch ğ‘’.
(i)
17
Session 12D: Decentralized Cryptographic Protocols CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea3518Leader validity: all the honest nodes have a block in Q(ğ¿ğ‘’).
(ii)
(iii) Output consistency: all the honest nodes output the same
randomness ğ‘…ğ‘’, output Oğ‘’, and
leader for epoch ğ‘’ + 1.
(iv) Leader consistency: all the honest nodes choose the same
Proof. We prove the theorem by induction on epochs.
Base case for epoch ğ‘’ = 1 to ğ‘’ = ğ‘¡ + 1. (ii) should hold for the first
ğ‘¡ + 1 leaders because we fill Q(ğ‘ğ‘–) with ğ‘š = 1 values for all nodes
ğ‘ğ‘– âˆˆ P during the setup phase. Additionally, from Definition 4.1,
no leaders repeat in the first ğ‘¡ + 1 epochs, thereby proving (ii) for
the base case. (iii) and (iv) hold since the first ğ‘¡ + 1 outputs only
use the seed values, and pre-agreed upon shares from Q from the
setup phase. At epoch ğ‘’ = ğ‘¡ + 1, from the proof for (iv) for the
base cases, we know that all nodes agree on the leaders for epochs
1 â‰¤ ğ‘’â€² â‰¤ ğ‘¡ + 1. Therefore, if some honest node commits block ğµ1
from epoch ğ‘’ = 1, then all honest nodes will commit ğµ1 by epoch
ğ‘’ = ğ‘¡ + 1, because at least one leader in some epoch 1 â‰¤ ğ‘’â€² â‰¤ ğ‘¡ + 1
must be honest, and from Fact B.6 all honest nodes commit the
block proposed in ğ‘’â€² and therefore directly or indirectly commit ğµ1.
Therefore, by epoch ğ‘’ = ğ‘¡ + 1 all honest nodes commit ğµ1, thereby
proving (i) for the base cases.
Induction hypothesis. The statements hold until epoch ğ‘’ âˆ’ 1.
Induction step. Proof for (i). From the induction hypothesis for
(iv), we have that all the leaders until epoch ğ‘’ are consistent and
at epoch ğ‘’ âˆ’ 1, and from the induction hypothesis for (i) all honest
nodes would have committed all the blocks for epoch ğ‘’â€² < ğ‘’ âˆ’ 1 âˆ’ ğ‘¡
by consistent leaders up to epoch ğ‘’ âˆ’ 1. Now, at epoch ğ‘’ all honest
nodes need to decide on the block ğµ proposed in epoch ğ‘’ âˆ’ ğ‘¡ âˆ’ 1. In
epochs ğ‘’ âˆ’ ğ‘¡ âˆ’ 1 â‰¤ ğ‘’â€² < ğ‘’, there is one epoch ğ‘’â€² whose leader ğ¿ğ‘’â€² is
honest, from Fact B.6, all honest nodes commit ğµ in epoch ğ‘’â€², thus
proving the hypothesis for (i).
Proof for (ii). By the induction hypothesis for (iv), the leader of
epoch ğ‘’ and all previous epochs is agreed upon. Let ğ¿ğ‘’ be the leader
for epoch ğ‘’. Then ğ¿ğ‘’ must have committed a block in some epoch
< ğ‘’ âˆ’ ğ‘¡, or during the setup. If ğ¿ğ‘’ was never the leader, then the
hypothesis (ii) is trivially satisfied. Let ğ‘’â€² < ğ‘’ âˆ’ ğ‘¡ be the latest epoch
in which ğ¿ğ‘’ was the leader last. If ğ¿ğ‘’ proposed a block in some
epoch ğ‘’â€² < ğ‘’ âˆ’ ğ‘“ , then from the proof for (i) for epoch ğ‘’, all nodes
agree on the same block for epoch ğ‘’â€². If no block proposed in epoch
ğ‘’â€² is added to the chain by epoch ğ‘’â€² + ğ‘¡ < ğ‘’ , then from our leader
selection rule (in Definition 4.1), no honest node will derive ğ¿ğ‘’ as
the leader as ğ¿ğ‘’ âˆˆ Pğ‘Ÿ . Therefore, (ii) also holds for epoch ğ‘’.
Proof for (iii). The randomness ğ‘…ğ‘’ depends on choosing a commit-
ted value to be reconstructed. The output Oğ‘’ depends on ğ‘…ğ‘’ and
{Oğ‘’âˆ’1, . . . , Oğ‘’âˆ’ğ‘¡}. By the induction hypothesis for (iii), all honest
nodes agree on Oğ‘’âˆ’1, . . . , Oğ‘’âˆ’ğ‘“ . Moreover, by the induction hypoth-
esis for (iv), they also choose the same leader ğ¿ğ‘’ for epoch ğ‘’. Thus,
if we can prove that all honest nodes agree upon the value from ğ¿ğ‘’
that is reconstructed in epoch ğ‘’, then agreement on Oğ‘’ is trivial.
From the proof of (i) and (ii), we know that there is a block ğ‘â„ that is
enqueued in the queue Q(ğ¿ğ‘’) for ğ¿ğ‘’, which all honest nodes agree
on, and therefore obtain the same ğ‘…ğ‘’ for epoch ğ‘’. Thus, (iii) holds
true for epoch ğ‘’.
Proof for (iv). The leader derivation depends on the candidate set
Lğ‘’, outputs of the last ğ‘¡ iterations {Oğ‘’âˆ’1, . . . , Oğ‘’âˆ’ğ‘¡}, and the recon-
structed randomness ğ‘…ğ‘’ in epoch ğ‘’. By the induction hypothesis
for (iv), and proof of (iii), the output of the last ğ‘“ iterations and
that of epoch ğ‘’ is agreed upon. From the proof of (i), (ii), and the
induction hypothesis for (iv), all honest nodes have the same Lğ¿ğ‘ğ‘ ğ‘¡
and Pğ‘Ÿ . From (iii), all honest nodes derive the same leader for epoch
ğ‘’ + 1.
â–¡
Theorem B.10 (Secure PVSS). Assuming a secure PVSS scheme
PVSS, the GRandPiper protocol is a secure publicly verifiable secret
sharing protocol with the dealer as the leader of an epoch, and the
rest of the nodes as the verifiers.
(2) Guessing the secret. The probability of an adversary winning
(1) Breaking the underlying PVSS scheme PVSS. Since PVSS
Proof Sketch. We already know that our SMR is secure against
a ğ‘¡-bounded adversary assuming a secure digital signature scheme,
ğ‘-SDH and a random oracle ğ». Given a secure suite of algorithms
in PVSS, on a high level we do not reveal any new information.
To formally prove it, consider the view ğ‘‰ğ‘– of any honest node ğ‘ğ‘–.
:= (PVSS.(cid:174)ğ¸, PVSS.pkğ‘–, PVSS.ğœ‹). In the underlying
It observes ğ‘‰ğ‘–
PVSS scheme PVSS, the view of a node is also ğ‘‰ğ‘–. An adversary A
that can successfully violate the secrecy property from GRandPiper
can do so by:
satisfies Definition 2.5, this can occur with negl(ğœ…) probability.
this way is negl(ğœ…).
Correctness. Let ğ¿ğ‘’ be an honest leader for epoch ğ‘’. Then its pro-
posed block that shares ğ‘…ğ‘’ is always committed (from Fact B.6).
Thus when the secret is reconstructed in the beacon protocol (Fig-
ure 4) all the honest nodes will output ğ‘…ğ‘’ with a high probability
of 1 âˆ’ negl(ğœ…) (from the underlying PVSS algorithm).
Commitment. If ğ¿ğ‘’ is Byzantine, then either all the honest nodes
commit to one of the blocks ğµâ„ proposed, or âŠ¥ by epoch ğ‘’ + ğ‘¡ + 1.
Therefore, the commitment property is satisfied by our protocol.
From the underlying scheme PVSS, there is a negligible probability
negl(ğœ…) for two correct nodes ğ‘ğ‘– and ğ‘ ğ‘— to output different ğ‘ âˆ—
ğ‘– â‰ 
ğ‘ âˆ—
ğ‘— â‰  âŠ¥.
(Public) Verifiability. This property holds true with high probability
from the underlying PVSS scheme PVSS as the views are identical.
The probability is over the choice of randomness for the verifier. â–¡
Concrete instantiations. Consider instantiating GRandPiper us-
ing SCRAPE [17]. We can show a reduction from an adversary
breaking the IND1-secrecy [31] property in GRandPiper into an
adversary that can break the secrecy property from SCRAPE (which
in turn shows a reduction to DDH or DBS assumptions [17, Sec.3,
Sec.4]). In the simulation, since the adversary is static, pick ran-
dom public keys for the ğ‘› âˆ’ ğ‘¡ honest nodes, and use A to run an
instance of GRandPiper using the input secrets. When A wins, we
can directly break the IND1-Secrecy property.
Remark. There are no known adaptively secure PVSS protocols.
It is not the case that there are attacks on existing PVSS schemes
when assuming an adaptive adversary, it is just that the existing
proof techniques fail to show security against adaptive adversaries.
Lemma B.11 (Rushing Adversary Advantage). For any epoch ğ‘’ â‰¥ 1,
a rushing adversary can reconstruct output Oğ‘’ at most 2Î” time before
the honest nodes.
Proof. An honest node sends its secret shares in epoch ğ‘’ when
its epoch-timerğ‘’âˆ’1 expires. Let node ğ‘ğ‘– be the earliest honest node
18
Session 12D: Decentralized Cryptographic Protocols CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea3519whose epoch-timerğ‘’âˆ’1 expires and node ğ‘ğ‘– sends its secret share at
time ğœ. A rushing adversary may instantaneously receive the share
and reconstruct the output ğ‘‚ğ‘’ at time ğœ.
Due to the Î” delay among the honest nodes entering epoch ğ‘’,
the other honest nodes may send their secret shares only at time
ğœ + Î” which arrives at all the honest nodes by time ğœ + 2Î”. In the
worst case, the honest nodes can reconstruct only at time ğœ + 2Î”.
Thus, a rushing adversary can reconstruct output Oğ‘’ at most 2Î”
time before honest nodes.
â–¡
Lemma B.12 (Guaranteed Beacon Output). For any epoch ğ‘’ â‰¥ 1,
all the honest nodes output a new beacon output Oğ‘’.
Proof. By Theorem B.9 part (iv), all the honest nodes have
consistent leaders. Let node ğ‘ğ‘– be the leader of epoch ğ‘’. The honest
nodes output a new beacon output in each epoch ğ‘’ if Q(ğ‘ğ‘–) â‰  âŠ¥.
Suppose for the sake of contradiction Q(ğ‘ğ‘–) = âŠ¥ in epoch ğ‘’. Observe
that nodes update Q(ğ‘ğ‘–) with secret proposed in epoch ğ‘’â€² (with
ğ‘’â€² < ğ‘’ âˆ’ ğ‘¡) when ğ‘ğ‘– was an epoch leader in epoch ğ‘’â€² by epoch ğ‘’
and node ğ‘ğ‘– did not propose any secrets in epoch ğ‘’â€². However, if
ğ‘ğ‘– did not propose in epoch ğ‘’â€², ğ‘ğ‘– would have been removed from
the candidate leader set for epoch ğ‘’ and would not be epoch leader
for epoch ğ‘’ and honest nodes would not use Q(ğ‘ğ‘–) in epoch ğ‘’. A
contradiction. Thus, all the honest nodes send shares for secret
shared in Q(ğ‘ğ‘–) and all the honest nodes will receive ğ‘¡ + 1 valid
shares to reconstruct a common randomness ğ‘…ğ‘’ and output Oğ‘’. â–¡
Lemma B.13 (Bias-Resistance). For any epoch ğ‘’ â‰¥ 1, the probability
that a ğ‘¡ bounded adversary A can fix any ğ‘ bits of the GRandPiper
beacon output Oğ‘’ is negl(ğ‘) + negl(ğœ…).
Proof Sketch. The output in any epoch ğ‘’ is Oğ‘’ which is the
hash ğ»(ğ‘…ğ‘’, Oğ‘’âˆ’1, . . . , Oğ‘’âˆ’ğ‘¡). Assume that some static adversary
A wants to bias ğ‘ bits of Oğ‘’. Now there is at least one honest
leader in epoch ğ‘’â€² where ğ‘’ âˆ’ ğ‘¡ â‰¤ ğ‘’â€² â‰¤ ğ‘’. WLOG, assume that the
leader at epoch ğ‘’â€² = ğ‘’ âˆ’ ğ‘¡ is honest. Then the output of epoch ğ‘’â€² is
known only in epoch ğ‘’â€² within 2Î” time of entering the epoch ğ‘’â€²
(from Lemma B.12). Therefore, a rushing adversary A can know
the Oğ‘’â€² at max 2Î” before an honest node enters epoch ğ‘’â€² (from
Lemma B.11). But the adversary has to choose all ğ‘…ğ‘’â€²â€² before epoch
ğ‘’â€², where ğ‘’ âˆ’ ğ‘¡ < ğ‘’â€²â€² â‰¤ ğ‘’, so that it can bias Oğ‘’. But all blocks
containing ğ‘…ğ‘’â€²â€² are committed before the epoch ğ‘’â€², since ğ‘…ğ‘’â€²â€² comes
from the blocks previously proposed by the leaders before epoch
ğ‘’â€² at the start (or during the setup). Thus all blocks containing
ğ‘…ğ‘’â€²â€² are proposed before observing ğ‘…ğ‘’â€², which is guaranteed to be
secret for a honest node against A (from the secrecy property of
Theorem B.10) except with negligible probability negl(ğœ…). Thus,
an adversary A can do no better than negl(ğ‘) + negl(ğœ…) to fix ğ‘
bits.
â–¡
Lemma B.14 (GRandPiper unpredictability). Assuming a secure
PVSS scheme PVSS and SMR protocol, the GRandPiper random beacon
protocol is an ğ‘‚(min(ğœ…, ğ‘¡))-absolute unpredictable random beacon
protocol against a static adversary.
Proof Sketch. Since the leaders are chosen using the beacon
outputs, the probability that the adversaryâ€™s nodes are chosen in
an epoch ğ‘’ is ğ‘¡/ğ‘› < 1/2. The probability that ğ‘ consecutive leaders
(cid:1)/(ğ‘› âˆ’ ğ‘¡)ğ‘ < 2âˆ’ğ‘ for 3 < ğ‘ < ğ‘¡ and is
are Byzantine is therefore(cid:0)ğ‘¡
ğ‘
exponentially decreasing in ğ‘. The expected value of ğ‘ is âŒˆlog 2âŒ‰ = 2.
If ğ‘ = ğ‘¡ + 1, the probability is already negl(ğœ…) (from the probability
of breaking secrecy of secrets shared by honest nodes). Thus, for
a given security parameter ğœ…, a static adversary cannot predict
the output with better than negl(ğœ…) probability in min(ğœ…, ğ‘¡) + 1
epochs.
â–¡
Theorem B.15 (GRandPiper secure random beacon). GRand-
Piper protocol is a ğ‘‚(min(ğœ…, ğ‘¡))-secure random beacon protocol as-
suming a static adversary.
Proof. The proof follows from Lemma B.13 for bias-resistance,
Lemma B.12 for guaranteed output delivery, and Lemma B.14 for
unpredictability.
â–¡
B.3 BRandPiper Security Analysis
Theorem B.16 (Security of iVSS). The verifiable secret sharing
scheme proposed in Figure 6 is a secure verifiable secret sharing scheme
assuming a bulletin board.
Proof Sketch. Consider any secure VSS scheme VSS. The view
ğ‘‰ğ‘– of an honest node is ğ‘‰ğ‘– := (VSS.C, VSS.sğ‘–, VSS.ğœ‹ğ‘–) to every node
ğ‘ğ‘– in both VSS and the iVSS protocol. Any ğ‘¡-bounded adversary
with access to ğ‘¡ views in both the protocols, has an equal probability
of extracting the secret. The case where the adversary forges the
digital signatures to obtain ğ‘¡+1 acks, which happens with negligible
probability, is an extra case to consider for the commitment and
correctness properties.
Formally, assume a secure VSS scheme satisfying Definition 2.4.
Secrecy: If the dealer ğ¿ is honest, then no honest node will blame
and the maximum number of blames is at most ğ‘¡. Thus, only up to
ğ‘¡ blames will be opened privately by the leader. Therefore, the view
ğ‘‰ğ‘‡ of an adversary corrupting ğ‘‡ âŠ‚ [ğ‘›] nodes with |ğ‘‡ | â‰¤ ğ‘¡ has the
same view in both the protocols.
Correctness: If the dealer ğ¿ is honest, then all honest nodes have
their shares for the secret ğ‘ , and similar to eVSS, will output the
same secret ğ‘  except with negl(ğœ…) probability, where the probability
is over forging digital signatures.
Commitment: If an ack certificate is formed, irrespective of the
leader being honest or Byzantine, at least one honest node has not
observed â‰¥ ğ‘¡ + 1 blames, and has received valid shares for every