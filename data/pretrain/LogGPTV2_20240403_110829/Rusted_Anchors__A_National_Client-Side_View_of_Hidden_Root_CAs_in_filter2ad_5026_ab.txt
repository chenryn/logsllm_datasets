as their behaviors are not publicly visible. While hidden root cer-
tificates should be rejected during certificate chain verification
(because they do not present in public root stores), it is possible for
them to be imported into local root stores (e.g., manually or by local
software) [58]. If abused, secure connections can be intercepted and
monitored with forged certificates [21].
The use cases of hidden root CAs make them fundamentally dif-
ferent from trusted ones, thus best security practices of certificate
issuance may not apply globally. For example, hidden root CAs of
malware are built to intercept secure connections, thus their adop-
tion of weak keys and insecure algorithms should not be considered
a problem. By contrast, self-built root CAs of enterprise networks
and anti-virus software should comply with the security require-
ments, in order to prevent themselves from being compromised. To
address this issue, in our methodology (Section 3) we group hidden
root CAs and certificates into different categories and discuss them
separately.
2.3 Related work
As HTTPS protocol is increasingly adopted in the web, efforts from
the community have been devoted to studying security issues of the
certificate ecosystem. Previous works focused on the measurement
and analysis of HTTPS interception are most relevant to our study.
To summarize the security threats posed by HTTPS interception,
[21] and [67] studied dozens of client-end applications (e.g., an-
tivirus software and proxies) that insert self-build root certificates
and perform TLS interception. They evaluated the whole process
of certificate generation and validation by code analysis, and un-
covered several implementation flaws. Besides, Durumeric et al.
further analyzed HTTPS interception from a web-server view and
Session 5B: PKI and Access Control CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea1375Figure 3: Methodological overview of certificate data collection and analysis
3.1 Certificate Data Collection
The goal of this study is to identify hidden root certificates in use
and to evaluate the real-world impact of those trusted by web clients
(i.e., installed into local root stores). To this end, we collaborate
with 360 Secure Browser [46], a popular PC browser built over
Chromium [13] with over 100 million monthly active users in China
mainland [45]. Since 2018, the company has been maintaining its
own root certificate store [47] that is shipped into the browsers. To
help evaluate CAs in the wild and decide whether they should be
included, 360 Secure Browser collects certificate data from volunteer
users who opt-in this program. Data collected from Feb 1, 2020
to Jun 30, 2020 (5 months) is provided to us for research purposes.
Certificate data collection procedure. When a volunteer user
visits a website over HTTPS with 360 Secure Browser, the browser
first fetches and verifies the web server’s certificate chain. Same as
Chromium1, 360 Secure Browser calls underlying operating system
APIs (e.g., CryptoAPI on Windows [51]) for certificate verification.
The APIs return a double-word STATUS_CODE carrying all verifica-
tion errors that occur. Each bit of the code indicates one type of
verification error and we list the mappings in Table 9 of Appen-
dix A. If any bit is set in STATUS_CODE (i.e., an error occurs), the
certificate chain is considered invalid and the browser terminates
the connection, showing an error message to its user.
Particularly, an asserted AUTHORITY_INVALID bit indicates that
the root certificate is not trusted by the client’s local root store. In
addition, the browser examines whether the root certificate includes
any of three large public root programs (Microsoft, Mozilla and
Apple), and encodes the result in an additional PUBLIC_TRUSTED
flag. This extra check is done backstage by matching the public
keys of root certificates, and the result is not shown to web users.
For ethical considerations (Section 3.4 discusses more), a certifi-
cate chain is collected only when PUBLIC_TRUSTED is unset, or if
any bit is set in STATUS_CODE. That is, the browser only collects cer-
tificate chains that link to hidden root CAs, or are considered invalid
by the client’s operating system. Valid certificate chains signed by
root CAs in the three public programs are not recorded and are
only counted for statistical purposes. Figure 4 shows the format
of a collected certificate chain, including (anonymized) client ID,
time of collection, hashes and PEM encoding of each certificate and
verification status codes.
Filtering hidden root certificates. Following, we need to filter
root certificates from certificate chains for further analysis. Due
1Historically, Chrome and Chromium use the local root store of underlying operating
systems, but are transitioning to their own root program [14]. 360 Secure Browser
does not use the Chrome Root Store.
Figure 4: Example chain with three certificates. The root
certificate is not trusted by the client’s local root store
(AUTHORITY_INVALID is set) or the public root programs
(PUBLIC_TRUSTED is unset). The chain is considered invalid
by the web client (STATUS_CODE has bit asserted).
following criteria:
to web server misconfiguration and network errors [5], the PEM-
encoded certificate chain (field CERTS_PEM in Figure 4) can be dis-
ordered or incomplete. As a result, simply taking the last certificate
in the chain as root can be error-prone. Fortunately, the X.509 RFC
standard [19] has special requirements for root certificates and we
check all certificates against them.
We identify the root certificate of a chain, if it satisfies all of the
a cA value set to TRUE.
● The certificate includes a basicConstraints extension with
● The certificate includes a keyUsage extension with an as-
● The distinguished names of subject and issuer are non-
● If included in the certificate, the subjectKey Identifier
serted keyCertSign bit (the first two criteria indicate that
the certificate is held by a CA).
empty and identical.
and authorityKeyIdentifier are identical (the last two
criteria are set because root certificates are self-signed).
To further filter hidden root certificates, we leverage the PUBLIC_
TRUSTED flag drawn from the browser’s additional check. If a root
certificate is identified in a chain with the above criteria, plus the
PUBLIC_TRUSTED flag of this record is unset, we label it as a hidden
root certificate. If no root certificate can be found in a chain, we
consider the record incomplete and remove it from our dataset.
Finally, the AUTHORITY_INVALID flag from certificate verification
APIs tells whether the hidden root certificate is rejected by the
client, or has been installed into the local root store.
3.2 Grouping Hidden Root Certificates
Our next research questions are “who owns the hidden root certifi-
cates” and “how are they currently operating”. Recall that hidden root
certificates can be held by various parties, such as local software
and enterprise networks. One organization can also create multiple
Session 5B: PKI and Access Control CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea1376root certificates with different public keys but identical or similar
subject names (e.g., “Globalsign Root R1”, R3 and R6), which often
share the same properties (e.g., length of validity period). We aim to
identify certificate groups held by the same or similar organizations,
and then classify their usage.
Inferring certificate ownership. We acknowledge that, due to a
lack of ground-truth, identifying the ownership of root certificates
is difficult even for those in public root programs. To our best knowl-
edge, Mozilla’s Common CA Database (CCADB) [52] provides the
most comprehensive and audited ownership information of root
certificates. A recent work [48] supplements the CCADB dataset
and now labels ownership for 6,846 root certificates [49]. However,
as hidden root CAs are invisible to public programs, none of our
collected certificates are found in the public datasets.
Without auxiliary information from external data feeds, we fol-
low the practices in previous studies [39, 44, 56] that leverage sub-
ject distinguished names to infer certificate ownership. That is, cer-
tificates with an identical set of commonName (CN), organization
(O) and organizationUnit (OU) in its subject belong to the same
organization.
Identifying subject templates. CAs holding multiple root certifi-
cates often generate them with subject templates, which should
be clustered as one certificate group. For example, the subject
commonName in root certificates of Whistle (a web debugging tool)
follows a template of CN=whistle.[0-9]*. A previous research [23]
manually identifies 46 subject templates in regular expressions, and
we check our dataset against their list. Unfortunately, only 3 tem-
plates hit our data (2 templates match only one certificate).
To comprehensively and automatically discover subject tem-
plates from certificates, we are inspired by Server Log Parsing tasks
that identify templates from inconsistently formatted logs. Consid-
ering subject names as logs, we select the Drain algorithm [37] for
this task. Designed over a 5-layer Directed Acyclic Graph (DAG),
Drain takes raw log messages as input and outputs structured mes-
sage templates, and produces 92% to 99% parsing accuracy on 11
log datasets [36]. For each certificate in our dataset, we concatenate
all fields in its subject distinguished name (e.g., commonName and
organization) into a log string as the input of Drain. For com-
patibility reasons, special characters that are not common in log
messages (e.g., commas and at signs) are replaced with white spaces.
In total, Drain outputs 13 subject templates from 1.1 million hidden
root certificates (including one discovered by [23]), and no false
positives are found during manual verification (see Section 3.3 for
evaluation).
Unsupervised Grouping. After identifying subject templates, hid-
den root certificates that match one of the following criteria are
grouped:
● Certificates have identical, non-empty values of commonName
● Subject distinguished names of certificates match the same
(CN), organization (O) and organizationUnit (OU) in
their subject distinguished names.
template.
3.3 Evaluation and Limitations
Evaluating hidden root certificates. During data collection, we
use the PUBLIC_TRUSTED flag provided by 360 Secure Browser to
identify hidden root certificates, and here we use the Certificate
Transparency (CT) database to verify if they are truly beyond public
root stores. To monitor the certificate issuance procedure, since
June 2016 all CAs in public root stores are required to submit all
certificates that they sign to CT for future queries [12]. As a result,
hidden root certificates should not appear in CT databases.
For evaluation, we query all (1.19 million) hidden root certificates
in the CT database provided by our industrial partner’s CT monitor
and find only 6 hits. After manual inspection, we confirm that these
certificates are falsely included in the CT database because several
CT nodes use expanded root stores [43]. In the end, we are confident
that the PUBLIC_TRUSTED flag of 360 Secure Browser is effective,
and that the hidden root certificates we identify are not included
by public root programs.
Evaluating grouping algorithm. To group hidden root certifi-
cates, we use the Drain algorithm to identify templates from sub-
ject distinguished names. To our best knowledge, there have not
been other methods designed specifically for this task and we select
Drain because it is a state-of-the-art tool and shows good accuracy.
Due to a lack of template ground truth in our dataset, we choose to
manually evaluate the algorithm on a sample of root certificates.
In detail, we inspect a random sample of 10,000 hidden root certifi-
cates in our dataset, and manually generate 11 subject templates.
Drain identifies all 11 templates, and the other 2 templates from the
larger dataset are missed because the number of their associated
certificates is low in our random samples. As a result, though not
specifically designed for this task, we believe that Drain outputs
correct subject templates with high confidence.
Limitations. First, to identify root certificates from certificate
chains, we set filtering rules that are driven from the standard
requirements of X.509 format (see Section 3.1). We understand that
some hidden root CAs (e.g., of local software) may not follow the
RFC standard requirements and will thus be overlooked. However,
we believe this filtering process also helps us to remove false posi-
tives. And we prefer to provide lower-bound numbers rather than
inflating them. Besides, if a client is infected by malware, it may
also cause the data collection results to be polluted. Although our
results theoretically only reflect a lower bound of the hidden root
CA ecosystem, as shown in Section 4, we are still able to identify
more than 1.19 million hidden root certificates that are witnessed
by real clients. Therefore, we believe our dataset is sufficient to shed
light on a nationwide ecosystem. Second, due to a lack of audited
ownership data, we borrow the approach from previous works and
infer certificate ownership from its subject distinguished names.
We acknowledge that the subject names may not point to the real
organizations behind, for example, self-built CAs of malware may
fill deceptive names in the subject fields. While this approach in-
evitably has limitations, for unidentifiable certificates, we attempt
to search in several auxiliary data feeds including threat intelli-
gence and sandbox logs, as a best-effort approach. Third, instead of
sensitive PII (Personal Identifiable Information) such as the user’s
IP address or device ID, 360 Secure Browser utilizes the timestamp
when the user joined the data collection program as its client ID
(see client_id in Figure 4), to better protect user privacy. Although
this client ID is less accurate than PII, e.g., one timestamp could
be associated with more than one real user and reinstalling the
Session 5B: PKI and Access Control CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea1377certificate chains that link to a hidden root, and they account for
0.54% of all web visits. Using the criteria in Section 3, we identify
over 1.19 million distinct hidden root certificates (distinguished by
certificate hash values) that meet the X.509 standard requirements.
To evaluate their security impact, we then split the hidden root
certificates by whether they have been trusted by web clients. Gen-
erally, hidden root certificates are invisible to public root programs,
thus they should be rejected during verification. However, surpris-
ingly, we find that only 21 thousand (1.8%) hidden root certificates are
rejected by all web clients that witness them. It suggests that, though
not included in public root programs, hidden root certificates have
actually been widely installed into local root stores. In the follow-
ing analysis, we neglect the 21 thousand root certificates that are
rejected by all clients, as their security impact is insignificant.
Certificate group overview. We run the grouping algorithm on
all 1.17 million hidden root certificates that are imported by clients,
and it produces 5,005 certificate groups. Root certificates in one
group are considered to be held by the same organization.
In terms of the size of certificate groups, as expected, the distribu-
tion has a long tail: 4,362 groups (87.2%) only include one certificate,
and the remaining 12.8% groups account for 99.6% of all certificates.
Figure 5 corresponds to each certificate group with their numbers of
associated HTTPS connections and web clients that witness them.
Dozens of certificate groups (at the top right corner of Figure 5)
cause profound impact. For example, the largest group contains
254,412 root certificates that belong to Certum Trusted NetWork
CA 2 (impersonating Certum CA [11]; the authentic CA has a lower-
case ‘w’ in “Network”). Another group contains only 2 certificates
that belong to Verislgn trust Network (impersonating Verisign
CA [66] by replacing the ‘i’ in “Verisign” with ‘l’) but is witnessed
by over 1 million web clients. In Section 4.3 we further discuss the
impersonation behaviors of hidden root CAs.
browser will change the ID, we believe this cost of inaccuracy is
acceptable to mitigate privacy risks.
3.4 Ethical Considerations
One major ethical concern of this work centers on certificate data
collection from users of 360 Secure Browser. To understand the
ecosystem of hidden root CAs, we need certificate chains together
with their verification statuses at the client-end. This goal cannot be
fulfilled through active scanning (e.g., Censys [25]) or passive traffic
analysis (e.g., ICSI Notary [7]). The dataset is only collected from
volunteer users that join the program in “opt-in” mode. Consent is
provided to users of 360 Secure Browser that states the collected
data (e.g., certificate chains and verification statuses), purposes and
benefits (e.g., help evaluate the 360 Root Certificate Program [47]),
and needs explicit agreement. The data collection process is under
the supervision of legal departments of the company (providing
similar functions as an IRB).
Another concern is the collected certificate data may harm user
privacy, as the history of web visits is obtained (e.g., through
hostname in certificate records), and several signed hosts them-
selves may also be sensitive. We tried our best to mitigate potential