In order
to provide a precise security model
for se-
cure group instant messaging, we deﬁne a group in-
stant messaging protocol as the tuple of algorithms Π =
((snd, rcv), (SndM, Add, Leave, Rmv, DelivM, ModG, Ack)).
The ﬁrst two algorithms (snd, rcv) provide the application
access to the network (network interface). Thereby snd out-
puts ciphertexts and rcv takes and processes ciphertexts. The
latter seven algorithms process actions of the user or deliver
remote actions of other users to the user’s graphical interface
(user interface). Each protocol speciﬁes these algorithms and
the interfaces among them. To denote that one algorithm algA
has an interface to another algorithm algB we write algBalgA.
Every algorithm has modifying access to the session state
of the calling party U for the communication in group gr.
• snd → (cid:126)c: Sends a vector of ciphertexts to the central
server.
• rcvsnd,DelivM,ModG,Ack(c): Receives ciphertext c from the
central server and processes it by invoking one of the
delivery algorithms and possibly the snd algorithm.
Authorized licensed use limited to: Tsinghua University. Downloaded on February 25,2022 at 12:15:37 UTC from IEEE Xplore.  Restrictions apply. 
1678
Deﬁnition 2 (Group State). Let st be a state and gr be a
group, then the group state st gr consists of:
• The group gr.
• The long-term public keys PK of all users in gr.
• The long-term secret keys SK of all users in gr.
• The session state ssU ,gr of gr of each user U ∈ gr.
A partial group state st gr .ps consists only of gr.
For our formal notions of deniability judges have to decide
whether a transcript is real or not. In order to allow them
to choose interactions without having to provide them with
full oracle-access, we introduce the notion of an instruction:
An instruction is a tuple that tells the challenger to perform
some action in the name of some user with some arguments
and is marked with a type that indicates the circumstances
under which the challenger shall execute the instruction. An
instruction list is simply an ordered list of instructions.
Deﬁnition 3 (Instruction List). An instruction i is a tuple that
contains:
• A party P,
• a user action act ∈ {SndM, Add, Leave, Rmv, rcv} (with
the respective arguments),
• a timepoint time and
• a type ∈ {exp, ch, ar, hid}.
An instruction list il is an ordered list of instructions. For
an instruction list il and X ∈ {ch, ar} we use il X to refer
that contains all tuples whose type is
to the sublist of il
in {exp, hid, X}. We call these two sublists the executable
sublists.
Intuitively the executable sublists represent the possible ex-
ecutions that the judge will have to distinguish as illustrated in
Figure 1. The type-names exp, ch, ar and hid are shorthands
for “exposed”, “challenge”, “alternate reality” and “hidden”.
message m to group gr.
Actions of user U are processed by the following algorithms,
which then invoke the snd algorithm for distributing the
actions’ results to the members Vi ∈ Ggr of group gr:
• SndM(gr, m) → id: Processes the sending of content
• Add(gr,V) → id: Processes adding of user V to gr.
• Leave(gr) Processes leaving of user U from gr.
• Rmv(gr,V) Processes removal of user V from gr.
Every algorithm that processes the calling user’s actions
outputs a unique reference string id. Actions initiated by other
users are ﬁrst received as ciphertexts by the rcv algorithm
and then passed to the following algorithms, which deliver
the result to user U:
• DelivM → (id, gr,V, m): Stores m with reference string
id from sender V in group gr for displaying it to user U.
• ModG → (id, gr(cid:48)): Updates the description of group gr
with IDgr = IDgr(cid:48) to gr(cid:48) after the remote modiﬁcation
with reference string id.
• Ack → id: Acknowledges that action with id was deliv-
ered and processed by all its designated receivers.
B. Our extensions
We note that all members of a group can perform SndM
and Leave, but only administrators can execute Add and Rmv.
We refer to [18] for security-deﬁnitions besides deniability.
For deniability we extend the model in the following way. We
denote the long-term secrets of a user U as skU (or just sk,
if unambiguous), any publicly identifying information tied to
skU as pkU. We call the tuple (pkU , skU ) U’s key pair and
denote her session state in a group gr as ssU ,gr.
We introduce the notion of the state of a protocol. Intuitively
a state st is a full snapshot of an execution of a protocol; as
such it contains the sets of the existing users U and groups G,
as well as all long-term key pairs and session states. We also
introduce a partial state that does not contain the key pairs
and session-states.
Deﬁnition 1 (State). A state st of our protocol consists of:
• The set U of all users U.
• The set G of all groups gr as deﬁned previously.
• The long-term public keys PK of all users in U.
• The long-term secret keys SK of all users in U.
• The session states ssU ,gr of all groups gr ∈ G and all
users U ∈ gr.
The tuple (U, G) forms the partial state st.ps of a state st.
Two states st 0, st 1 are equivalent(st 0 ≡ st 1) if and only if
their partial states are identical (st 0.ps = st 1.ps).
From here on we use the following convention: If we deﬁne
that a value x consists of multiple values a, b, c, . . . , then x.a
refers to the a-value of x. (E.g., st.U refers to the set U that
is part of a particular state st.)
Given a state st, we also introduce the notion of a group-
state st gr , which contains all information regarding a particu-
lar group gr. Intuitively it contains all session states and long-
term key pairs of any party in that group, as well as the group
description. We also deﬁne the notion of a partial group-state,
which only contains the group-description however.
Fig. 1. Alternative transcripts based on the type of an instruction. The judge
receives either an entirely real transcript (bold red arrows) or a partially
simulated one (bold purple arrows).
In order to prevent trivial attacks we furthermore introduce
the following notion of consistency for instruction lists:
Deﬁnition 4 (Consistency). An instruction list il is consistent
with a starting state st if executing either of il ch and il ar with
st as starting state
• is compliant with the protocol and
• all intermediate states that directly precede an exp ac-
tion are equivalent between the executable sublists with
regards to the target-group of that action.
Authorized licensed use limited to: Tsinghua University. Downloaded on February 25,2022 at 12:15:37 UTC from IEEE Xplore.  Restrictions apply. 
1679
executionofilchexecutionofilarsimulatedlaterbyShidexpch/arhidWe deﬁne the predicate is consistent, which receives an
instruction list il and a starting state st, to return 1 if and
only if il and st are consistent.
Executing an instruction inst will (usually) cause messages
to be sent over the network. The list of all these messages,
each together with their sender and receiver(s), as well as the
resulting session state form an instruction transcript. Note in
this context that a single user action, such as sndM may cause
multiple executions of snd and rcv among different parties.
With this we deﬁne the transcript of an execution of an
executable sublist of an instruction list as the concatenation
of the instruction transcripts of all its actions. We include the
session-states in the transcript to model corruption. While this
may seem excessively powerful, we note that we mostly deal
with unbounded judges in this work, who would usually be
able to extract most of this information from the sent messages
anyways; furthermore we will present more speciﬁc rationales
where appropriate.
Deﬁnition 5
instruc-
tion transcript of
executing an instruction inst =:
(P, (act, args), time, type) in a state st. Then instts contains:
is performed as part of
• For each snd-operation that
(Transcript). Let
instts be
the
executing inst:
– The party P that performed snd.
– The output (cid:126)c of snd.
• For each rcv-operation that
is performed as part of
executing inst:
– The party P that performed rcv.
– The ciphertext c that rcv receives.
• the group-state st gr that results from executing inst.
The transcript ts of an execution of an executable sublist il X
of an instruction list il is the concatenation of the instruction
transcripts of all instructions in il X.
For the actual execution we deﬁne the algorithm exec that
takes an executable sublist il X of an instruction list il and a
starting state st and then executes the sequence of instructions
given by il X, returning the resulting transcript and state.
Deﬁnition 6 (exec). The algorithm exec takes a starting state
st, and an executable sublist il X of an instruction list il and
executes all actions listed in il with state as starting state. It
returns the complete transcript of the execution as well as the
updated state of all involved parties. In the event that il orders
an action that is not compliant with the protocol, an abort is
raised.
We also deﬁne a version that only considers partial states,
and does not return a transcript but only the resulting partial
state:
Deﬁnition 7 (partial exec). The algorithm partial exec takes
a partial starting state ps and an executable sublist il X of
an instruction list il. It returns the partial state ps(cid:48) that would
result from executing il X with any starting state whose partial
state is ps. In the event that il X orders an action that is not
compliant with the protocol, an abort is raised.
Intuitively deniability means that every transcript could
have been generated by everybody. We model this using a
simulation-based deﬁnition, introducing a simulator S that has
the goal to produce a simulated transcript that is indistinguish-
able from the real transcript of a group communication.
In order for S to be able to do its work, it needs to know
what it has to simulate, so it has to receive some information
about the instruction list il and the state st. Giving it the entire
instruction list appears quite unrealistic to us however, which
is why we introduce the notion of the simulation instruction
simil,s that contains only the information that S needs: Which
instructions it has to simulate as well as the members of the
group in which that instruction occurs:
Deﬁnition 8 (Simulation Instruction). Let il be an instruction
list and st be a state so that is consistent (il , st) = 1. Then
the simulation instruction sim il,s for il and st is an ordered
list that contains:
• All entries il [i] of il ch for which il [i].type = ch and
• if there is no ch-entry for the group gr in which il [i] is
performed in il ch that directly precedes il [i] in gr: simil,s
also contains the partial group state of gr before instruc-
tion il [i]. (That is partial exec (il ch[0 . . . , i − 1], st)gr ).
Where il [i] refers to the i’th entry of il.
We note that our deﬁnitions also introduce notation: While
deriving an executable sublist il ch from an instruction list
il would for example strictly speaking require an explicit
algorithm, we will for the remainder of the work just assume
that if there is an instruction list il, then deriving il ch is
possible and use it without introducing it as a variable ﬁrst. The
same holds for other notation that we used in this section, such
as st gr for group-states or simulation instructions simil,state.
III. SECURITY GOALS
There are many aspects to the security of group chats and
our model “inherits” most of the more common aspects from
the original model [18]. Here we only outline authenticity (as
it is directly relevant for our work) and introduce deniability.
For all other notions we refer to [18].
A. Authenticity
The most basic deﬁnition of authenticity is message authen-
tication [18]:
If a message m is delivered to V ∈ Ggr by DelivM →
(id, gr,U, m), then it was indeed sent by user U by calling
SndM(gr, m).
B. Deniability
Deniability is commonly modelled as the property that
everybody (that is able to record the transcript of a transaction)
is able to forge transcripts that are indistinguishable from
transcripts of real protocol runs. This is formally deﬁned in
the simulation framework, asking that for every judge J (the
adversary in this case) there exists a simulator S such that
J cannot distinguish transcripts generated by S from real
transcripts. Of course the devil is in the details and one can
Authorized licensed use limited to: Tsinghua University. Downloaded on February 25,2022 at 12:15:37 UTC from IEEE Xplore.  Restrictions apply. 
1680
consider arbitrary dimensions for such a notion. We consider
the following dimensions:
• adversarial model: Whether the judge is unbounded or
not and whether she has a quantum computer.
• message-deniability
• online judges vs. ofﬂine judges: Whether the judge
receives the transcript as it is generated or at some (to be
deﬁned) later point in time.
vs.
participation-deniability:
Whether only the messages of a communication or even
the occurrence of the communication can be plausibly
denied.
• universal vs non-universal deniability: Whether every-
one is capable to simulate a transcript or just participants.
• corruption: The degree to which the judge learns the
secrets of the involved parties. In the case of full corrup-
tion the judge choses all long-term secrets of all parties
(for an unbounded judge this will rarely be an advantage
however) as well as the session-states that succeed exp
and ch actions.
We decided to aim for unbounded ofﬂine judges, targeting
universal participation deniability under full corruption. In
brief, we always settled for the stronger property except for
the ofﬂine judges. For a more detailed discussion of these
dimensions we refer to the full version.
C. Naive Deniability
We can deﬁne a ﬁrst notion of ofﬂine-deniability that
attempts to match the common intuition of what deniability
is that we call naive ofﬂine deniability. In this case we allow
the judge J to choose the instructions covered in the challenge
protocol execution, with the exception of actions of type exp
and hid. This models a case where a judge is given a transcript
of a conversation and has to decide if this transcript is real
or was prepared by a third party. In our model the judge
is allowed to choose the key-pairs and the contents of the
interaction in order to model the worst case. An equivalent but
harder to work with deﬁnition would quantify over all possible
key-pairs and transcripts. We point out that in this work we
treat all adversaries in one game as using shared states.
Deﬁnition 9 (Naive Ofﬂine Deniability). A protocol Π offers
naive ofﬂine deniability or N-OfD if there is an efﬁcient
simulator S ∈ PPT so that no judge J has a chance of
winning ExpN-OfDS,J , deﬁned in Experiment 1 with a probability
greater than 1
2:
∃S ∈ PPT : ∀J : Pr[ExpN-OfD
We model aborts as the experiment returning 0. Because of
this we require a success-probability strictly greater than 1/2
for an attacker to be considered successful.
We call this notion “naive” because J does not receive
access to any real transcript, even ones that are completely
independent of the interaction in question. In particular this
means that she won’t even learn about public parameters of
the server. Consider a protocol in which the server will sample
a random bitstring once and attach it to any packet it sends
from then on and where all honest parties simply ignore this
bitstring. The naive deniability notion now allows S to sample
Π,S,J(cid:0)1λ(cid:1) = 1] ≤ 1
2
Π,S,J . Naive ofﬂine deniability for
Experiment 1: ExpN-OfD
chats.
1 b ←$ {0, 1}
2 P, il , PK , SK := J ()
3 st := (P,∅, PK , SK ,∅)
4 abort if(¬is consistent(il , st))
5 abort if(∃inst ∈ il : inst.type ∈ {hid, exp})
6 if b = 0:
7
8 else:
9
10 b(cid:48) := J (ts)
11 return b = b(cid:48)
, ts := exec (il ch, st)
ts := S(PK , sim il,st )
this bitstring from the same distribution and use that sampled
value in his simulation. Since J has no way to learn what
bitstring is used in this model, S is able to get away with this
technique. In the real world it would however be exceedingly
unlikely, that J could not learn that bitstring by setting up an