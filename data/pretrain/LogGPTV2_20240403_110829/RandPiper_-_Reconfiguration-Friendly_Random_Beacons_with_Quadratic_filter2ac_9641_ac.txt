uration while keeping low communication overhead is challenging.
Session 12D: Decentralized Cryptographic Protocols CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea3504Prior protocols [1] incur ğ‘‚(ğœ…ğ‘›3) communication without thresh-
old signatures, and moreover, the execution cannot be split across
rounds to reduce per round complexity. We introduce a new clock
synchronization primitive that synchronizes new nodes when a
majority of honest nodes are already synchronized while main-
taining quadratic communication per round. The protocol utilizes
homomorphic addition property of VSS secret shares that yields
constant-sized secrets when the secret is opened. The homomor-
phic secret can be broadcast among all nodes to synchronize all the
nodes with only ğ‘‚(ğœ…ğ‘›2) communication.
Implementation and Evaluation. We implement our protocol
and demonstrate the practicality of our random beacon. We show
that our BRandPiper protocol is as good as the state of the art
practically deployed system: Drand in terms of beacons per minute.
Concretely, we show that choosing a Î” value for BRandPiper such
that it always succeeds, we are always better than Drand if we
assume a similar low Î” value for Drand. Giving a benefit of doubt
to Drand, by choosing slightly relaxed value of 99.9ğ‘¡â„ percentile
value of Î”, we show that our protocol is still as practical as Drand.
Summary of contributions. To summarize, we make the follow-
ing contributions in this work:
(1) In Section 3, we present a communication efficient BFT SMR
protocol with quadratic communication per consensus decision.
(2) We then present two random beacon protocols. Section 4.1
presents GRandPiper, a simple beacon protocol using PVSS with
ğ‘‚(ğœ…ğ‘›2) communication. We then present BRandPiper, a protocol
with better unpredictability in Section 4.2.
(3) In Section 5, we evaluate our BRandPiper protocol.
(4) We present mechanisms for synchronizing a new node in
Appendix C and reconfiguration in Appendix D.
Related Work. We present detailed related works in Appendix A.
Limitations. Our protocol depends on the synchrony assumption,
i.e., messages sent between any two honest nodes in the system are
always delivered within a public value Î”.
2 MODEL AND DEFINITIONS
We consider a system P := {ğ‘1, . . . , ğ‘ğ‘›} consisting of ğ‘› nodes out
of which at most ğ‘¡ = âŒŠğ‘› âˆ’ 1/2âŒ‹ nodes can be Byzantine which we
term as a ğ‘¡-bounded adversary. The Byzantine nodes may behave
arbitrarily. When we assume an adaptive adversary A, the nodes
can be corrupted to behave arbitrarily at any time during execution.
When we assume a static adversary A, the nodes to be corrupted
must be chosen by the adversary before the start of the protocol
execution. We also use the term ğ‘¡-bounded adversary. A node that
is not faulty throughout the execution is considered to be honest
and executes the protocol as specified.
We assume the network between nodes consists of point-to-point
secure (authenticated and confidential) synchronous communica-
tion channels. Messages between nodes may take at most Î” time
before they arrive, where Î” is a known maximum network delay.
To provide safety under adversarial conditions, we assume that the
adversary is capable of delaying the message for an arbitrary time
upper bounded by Î”. In addition, we assume all honest nodes have
clocks moving at the same speed. They also start executing the pro-
tocol within Î” time from each other. This can be easily achieved by
4
using the clock synchronization protocol [1] once at the beginning
of the protocol.
We make use of digital signatures and a public-key infrastructure
(PKI) to prevent spoofing and replays and to validate messages.
Message ğ‘¥ sent by a node ğ‘ is digitally signed by ğ‘â€™s private key
and is denoted by âŸ¨ğ‘¥âŸ©ğ‘. In addition, we use ğ»(ğ‘¥) to denote the
invocation of the random oracle ğ» on input ğ‘¥.
2.1 Definitions
We consider a state machine replication protocol defined as follows:
Definition 2.1 (Byzantine Fault-tolerant State Machine Replica-
tion [45]). A Byzantine fault-tolerant state machine replication proto-
col commits client requests as a linearizable log to provide a consistent
view of the log akin to a single non-faulty server, providing the follow-
ing two guarantees: (i) Safety. Honest nodes do not commit different
values at the same log position. (ii) Liveness. Each client request is
eventually committed by all honest nodes.
We define ğ‘‘-absolute unpredictability as follows:
Definition 2.2 (ğ‘‘-absolute unpredictability). Consider an epoch
based protocol. Let the fastest honest node be at epoch ğ‘’. The protocol
is said to be unpredictable with absolute bound ğ‘‘ for ğ‘‘ â‰¥ 1, if the
probability of an adversary A predicting the honest output for any
epoch ğ‘’â€² â‰¥ ğ‘’ + ğ‘‘ is negl(ğœ…).
We define the security requirements for a random beacon proto-
col RB as follows:
Definition 2.3 (Secure random beacon protocol). An epoch based
protocol RB is said to be a ğ‘‘-secure random beacon protocol if it
satisfies the following conditions:
(1) Bias-resistance. Let O be the output of the beacon for some
epoch ğ‘’. No adversary A can bias the output of the beacon, i.e., fix
some ğ‘ bits of O for any epoch ğ‘’ > 1 with probability better than
negl(ğ‘) + negl(ğœ…).
(2) Unpredictability. The protocol is ğ‘‘-absolute unpredictable.
(3) Guaranteed Output Delivery. For every epoch ğ‘’ â‰¥ 1, the
protocol outputs a value.
2.2 Primitives
In this section, we present several primitives used in our protocols.
Linear erasure and error correcting codes. We use standard
(ğ‘¡ + 1, ğ‘›) Reed-Solomon (RS) codes [41]. This code encodes ğ‘¡ + 1
data symbols into code words of ğ‘› symbols and can decode the ğ‘¡ + 1
elements of code words to recover the original data.
â€¢ ENC. Given inputs ğ‘š1, . . . , ğ‘šğ‘¡+1, an encoding function ENC
computes (ğ‘ 1, . . . , ğ‘ ğ‘›) = ENC(ğ‘š1, . . . , ğ‘šğ‘¡+1), where (ğ‘ 1, . . . , ğ‘ ğ‘›) are
code words of length ğ‘›. A combination of any ğ‘¡+1 elements of ğ‘› code
words uniquely determines the input message and the remaining
of the code word.
â€¢ DEC. DEC computes (ğ‘š1, . . . , ğ‘šğ‘¡+1) = DEC(ğ‘ 1, ..., ğ‘ ğ‘›), and is
capable of tolerating up to ğ‘ errors and ğ‘‘ erasures in code words
(ğ‘ 1, . . . , ğ‘ ğ‘›), if and only if ğ‘¡ â‰¥ 2ğ‘ + ğ‘‘.
Cryptographic accumulators. A cryptographic accumulator sc-
heme constructs an accumulation value for a set of values and
produces a witness for each value in the set. Given the accumulation
value and a witness, any node can verify if a value is indeed in the
Session 12D: Decentralized Cryptographic Protocols CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea3505set. Formally, given a parameter ğ‘˜, and a set ğ· of ğ‘› values ğ‘‘1, . . . , ğ‘‘ğ‘›,
an accumulator has the following components:
â€¢ Gen(1ğ‘˜, ğ‘›): This algorithm takes a parameter ğ‘˜ represented in
unary form 1ğ‘˜ and an accumulation threshold ğ‘› (an upper bound on
the number of values that can be accumulated securely), returns an
accumulator key ğ‘ğ‘˜. The accumulator key ğ‘ğ‘˜ is part of the ğ‘-SDH
setup and therefore is public to all nodes.
â€¢ Eval(ğ‘ğ‘˜, D): This algorithm takes an accumulator key ğ‘ğ‘˜ and
a set D of values to be accumulated, returns an accumulation value
ğ‘§ for the value set D.
â€¢ CreateWit(ğ‘ğ‘˜, ğ‘§, ğ‘‘ğ‘–, D): This algorithm takes an accumulator
key ğ‘ğ‘˜, an accumulation value ğ‘§ for D and a value ğ‘‘ğ‘–, returns âŠ¥ if
ğ‘‘ğ‘– âˆˆ D, and a witness ğ‘¤ğ‘– if ğ‘‘ğ‘– âˆˆ D.
â€¢ Verify(ğ‘ğ‘˜, ğ‘§, ğ‘¤ğ‘–, ğ‘‘ğ‘–): This algorithm takes an accumulator key
ğ‘ğ‘˜, an accumulation value ğ‘§ for D, a witness ğ‘¤ğ‘– and a value ğ‘‘ğ‘–,
returns true if ğ‘¤ğ‘– is the witness for ğ‘‘ğ‘– âˆˆ D, and false otherwise.
In this paper, we use collision free bilinear accumulators from [37]
as cryptographic accumulators.
Verifiable Secret Sharing and Commitments. We assume the
existence of a secure Verifiable secret sharing scheme VSS with
commitments, satisfying the security properties in Definition 2.4.
We use the interfaces to a secure VSS scheme VSS as described in
Table 2 (Appendix B).
Definition 2.4 (VSS Security [6]). A VSS protocol consists of two
phases: sharing and reconstruction. We call an ğ‘›âˆ’node VSS protocol,
with ğ‘¡âˆ’bounded adversary A and security parameter ğœ…, an (ğ‘›âˆ’ğ‘¡)-VSS
protocol if it satisfies the following conditions:
1. Secrecy. If the dealer ğ¿ is honest, then the probability of A learning
any information about the dealerâ€™s secret ğ‘  in the sharing phase is
negl(ğœ…).
2. Correctness. If ğ¿ is honest, then the honest nodes output the secret
ğ‘  at the end of the reconstruction phase with a high probability of
1 âˆ’ negl(ğœ…).
3. Commitment. If ğ¿ is Byzantine, then at the end of the sharing
phase there exists a value ğ‘ â˜… in the input space including âŠ¥, such that
at the end of the reconstruction phase all honest nodes output ğ‘ â˜… with
high probability 1 âˆ’ negl(ğœ…).
In our work, we implicitly assume that the VSS scheme used is
(ğ‘›/2 + 1)-secure.
Publicly Verifiable Secret Sharing â€” PVSS. PVSS schemes con-
sist of communication such as broadcasts, posts on the bulletin
board, as well as computational components such as share genera-
tion, encryption, etc. We separate the two components and present
interfaces to computational algorithms that we will use in our pro-
tocols. We use the interfaces to a secure PVSS scheme PVSS as
described in Table 3 (Appendix B).
We assume the existence of a secure PVSS algorithm PVSS as
defined in Definition 2.5.
Definition 2.5 (PVSS security [6, 17]). Let ğ¿ âˆˆ P be the dealer with
secret ğ‘  and ğœ… be the security parameter. A PVSS scheme PVSS is a
secure VSS scheme (see Definition 2.4) and must provide the following
guarantees:
4. Public Verifiability. If the check in share verification algorithm
(PVSS.ShVrfy, see Table 3) returns 1, i.e., succeeds, then with high
probability 1âˆ’negl(ğœ…), the encryptions are valid shares of some secret.
Normalizing the length of cryptographic building blocks. Let
ğœ† denote the security parameter, ğœ…â„ = ğœ…â„(ğœ†) denote the hash size,
ğœ…ğ‘ = ğœ…ğ‘(ğœ†) denote the size of the accumulation value and witness
of the accumulator and ğœ…ğ‘£ = ğœ…ğ‘£(ğœ†) denote the size of secret share
along with the associated proofs (both for PVSS and VSS). Further,
let ğœ… = max(ğœ…â„, ğœ…ğ‘, ğœ…ğ‘£); we assume ğœ… = Î˜(ğœ…â„) = Î˜(ğœ…ğ‘£) = Î˜(ğœ…ğ‘) =
Î˜(ğœ†). Throughout the paper, we will use the same parameter ğœ… to
denote the hash size, signature size, accumulator size and secret
share size for convenience.
3 BFT SMR PROTOCOL
In this section, we present a simple BFT SMR protocol as a ba-
sic building block for the random beacon protocols discussed in
following sections. Our SMR protocol achieves ğ‘‚(ğœ…ğ‘›2) bits com-
munication complexity with a universal structured reference string
(SRS) setup under the ğ‘-SDH assumption, or ğ‘‚(ğœ…ğ‘›2 log ğ‘›) bits com-
munication complexity without the ğ‘-SDH setup assumption. In
particular, we do not use threshold signatures, and thus avoid any
distributed key generation during the setup or proactive secret
sharing during reconfiguration. We note that prior synchronous
BFT SMR protocols [3, 19, 46] with honest majority incur ğ‘‚(ğœ…ğ‘›3)
communication per consensus decision without threshold signa-
tures.
Epochs. Our protocol progresses through a series of numbered
epochs with each epoch coordinated by a distinct leader. Epochs
are numbered by integers starting with one. Each epoch lasts for
11Î” time. The leaders for each epoch are rotated irrespective of the
progress made in each epoch. For simplicity, we use round-robin
leader election in this section and the leader of epoch ğ‘’, represented
as ğ¿ğ‘’, is determined by ğ‘’ mod ğ‘›. Later in the beacon protocols, we
introduce different leader election rules.
Blocks and block format. An epoch leaderâ€™s proposal is repre-
sented as a block. Each block references its predecessor except for
the genesis block which has no predecessor. We call a blockâ€™s po-
sition in the chain as its height. A block ğµâ„ at height â„ has the
format, ğµâ„ := (ğ‘â„, ğ»(ğµâ„âˆ’1)) where ğ‘â„ denotes the proposed pay-
load at height â„, ğµâ„âˆ’1 is the block at height â„ âˆ’ 1 and ğ»(ğµâ„âˆ’1) is
the hash digest of ğµâ„âˆ’1. The predecessor for the genesis block is âŠ¥.
A block ğµâ„ is said to be valid if (1) its predecessor block is valid, or
if â„ = 1, predecessor is âŠ¥, and (2) the payload in the block meets
the application-level validity conditions. A block ğµâ„ extends a block
ğµğ‘™ (â„ â‰¥ ğ‘™) if ğµğ‘™ is an ancestor of ğµâ„. Note that a blockâ€™s height â„
and its epoch ğ‘’ need not necessarily be the same.
Certified blocks, and locked blocks. A block certificate on a
block ğµâ„ consists of ğ‘¡ + 1 distinct signatures in an epoch ğ‘’ and is
represented by Cğ‘’(ğµâ„). Block certificates are ranked by epochs, i.e.,
blocks certified in a higher epoch has a higher rank. During the
protocol execution, each node keeps track of all certified blocks and
keeps updating the highest ranked certified block to its knowledge.
Nodes will lock on highest ranked certified blocks and do not vote
for blocks that do not extend the locked blocks to ensure safety of
a commit.
Equivocation. Two or more messages of the same type but with