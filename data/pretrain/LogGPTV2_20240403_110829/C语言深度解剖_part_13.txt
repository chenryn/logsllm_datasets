A)，什么是指针？
B)，什么是数组？
C)，数组和指针之间有什么样的关系？
4.1 挃针
4.1.1 挃针的内存布局
先看下面的例子：
int *p;
大家都知道这里定义了一个指针p。但是p 到底是什么东西呢？还记得第一章里说过，
“任何一种数据类型我们都可以把它当一个模子‛吗？p，毫无疑问，是某个模子咔出来的。
我们也讨论过，任何模子都必须有其特定的大小，这样才能用来“咔咔咔”。那咔出p 的
这个模子到底是什么样子呢？它占多大的空间呢？现在用sizeof 测试一下（32 位系统）：
sizeof（p）的值为4。嗯，这说明咔出p 的这个模子大小为4 个byte。显然，这个模子不
是“int”，虽然它大小也为4。既然不是“int”那就一定是“int *”了。好，那现在我
们可以这么理解这个定义：
一个“int *”类型的模子在内存上咔出了4 个字节的空间，然后把这个4 个字节大小
的空间命名为p，同时限定这4 个字节的空间里面只能存储某个内存地址，即使你存入别的
任何数据，都将被当作地址处理，而且这个内存地址开始的连续4 个字节上只能存储某个
int类型的数据。这是一段咬文嚼字的说明，我们还是用图来解析一下：
- 67 -
如上图所示，我们把p 称为指针变量，p 里存储的内存地址处的内存称为p 所指向的
内存。指针变量p 里存储的任何数据都将被当作地址来处理。
我们可以简单的这么理解：一个基本的数据类型（包括结构体等自定义类型）加上“*”
号就构成了一个指针类型的模子。这个模子的大小是一定的，与“*”号前面的数据类型无
关。“*”号前面的数据类型只是说明指针所指向的内存里存储的数据类型。所以，在32 位
系统下，不管什么样的指针类型，其大小都为4byte。可以测试一下sizeof（void *）。
4.1.2 “*”不防盗门的钥匙
这里这个“*”号怎么理解呢？举个例子：当你回到家门口时，你想进屋第一件事就是
拿出钥匙来开锁。那你想想防盗门的锁芯是不是很像这个“*”号？你要进屋必须要用钥匙，
那你去读写一块内存是不是也要一把钥匙呢？这个“*”号是不是我们最好的钥匙？使用指
针的时候，没有它，你是不可能读写某块内存的。
4.1.3 int *p = NULL 和*p = NULL 有什么区别？
很多初学者都无法分清这两者之间的区别。我们先看下面的代码：
int *p = NULL;
这时候我们可以通过编译器查看p 的值为0x00000000。这句代码的意思是：定义一个
指针变量p，其指向的内存里面保存的是int 类型的数据；在定义变量p 的同时把p 的值设
置为0x00000000，而不是把*p 的值设置为0x00000000。这个过程叫做初始化，是在编译
的时候进行的。明白了什么是初始化之后，再看下面的代码：
int *p;
*p = NULL;
同样，我们可以在编译器上调试这两行代码。第一行代码，定义了一个指针变量p，其
指向的内存里面保存的是int 类型的数据；但是这时候变量p 本身的值是多少不得而知，
也就是说现在变量p 保存的有可能是一个非法的地址。第二行代码，给*p 赋值为NULL，即
- 68 -
给p指向的内存赋值为NULL；但是由于p 指向的内存可能是非法的，所以调试的时候编译器
可能会报告一个内存访问错误。这样的话，我们可以把上面的代码改写一下，使p 指向一块
合法的内存：
int i = 10;
int *p = &i;
*p = NULL;
在编译器上调试一下，我们发现p 指向的内存由原来的10 变为0 了；而p 本身的值，
即内存地址并没有改变。
经过上面的分析，相信你已经明白它们之间的区别了。不过这里还有一个问题需要注意，
也就是这个NULL。初学者往往在这里犯错误。
注意NULL 就是NULL，它被宏定义为 0 ：
#define NULL 0
很多系统下除了有NULL外，还有NUL（Visual C++ 6.0 上提示说不认识NUL）。NUL 是
ASCII码表的第一个字符，表示的是空字符，其ASCII 码值为0。其值虽然都为0，但表示
的意思完全不一样。同样，NULL 和0 表示的意思也完全不一样。一定不要混淆。
另外还有初学者在使用NULL 的时候误写成null 或Null 等。这些都是不正确的，C 语
言对大小写十分敏感啊。当然，也确实有系统也定义了null，其意思也与NULL 没有区别，
但是你千万不用使用null，这会影响你代码的移植性。
4.1.4 如何将数值存储到挃定的内存地址
假设现在需要往内存0x12ff7c 地址上存入一个整型数0x100。我们怎么才能做到呢？
我们知道可以通过一个指针向其指向的内存地址写入数据，那么这里的内存地址0x12ff7c
其本质不就是一个指针嘛。所以我们可以用下面的方法：
int *p = (int *)0x12ff7c;
*p = 0x100;
需要注意的是将地址0x12ff7c 赋值给指针变量p 的时候必须强制转换。至于这里为什
么选择内存地址0x12ff7c，而不选择别的地址，比如0xff00 等。这仅仅是为了方便在
Visual C++ 6.0 上测试而已。如果你选择0xff00，也许在执行*p = 0x100;这条语句的
时候，编译器会报告一个内存访问的错误，因为地址0xff00 处的内存你可能并没有权力去
访问。既然这样，我们怎么知道一个内存地址是可以合法的被访问呢？也就是说你怎么知道
地址0x12ff7c处的内存是可以被访问的呢？其实这很简单，我们可以先定义一个变量i，比
如：
int i = 0;
变量i 所处的内存肯定是可以被访问的。然后在编译器的watch 窗口上观察&i 的值不
就知道其内存地址了么？这里我得到的地址是0x12ff7c，仅此而已（不同的编译器可能每
次给变量i 分配的内存地址不一样，而刚好Visual C++ 6.0 每次都一样）。你完全可以
给任意一个可以被合法访问的地址赋值。得到这个地址后再把“int i = 0;”这句代码删
除。一切“罪证”销毁得一干二净，简直是做得天衣无缝。
除了这样就没有别的办法了吗？未必。我们甚至可以直接这么写代码：
*(int *)0x12ff7c = 0x100;
这行代码其实和上面的两行代码没有本质的区别。先将地址0x12ff7c 强制转换，告诉
编译器这个地址上将存储一个int 类型的数据；然后通过钥匙“*”向这块内存写入一个数
据。
- 69 -
上面讨论了这么多，其实表达形式并不重要，重要的是这种思维方式。也就是说我们完
全有办法给指定的某个内存地址写入数据的。
4.1.5 编译器的 bug？
另外一个有意思的现象，在Visual C++ 6.0 调试如下代码的时候却又发现一个古怪
的问题：
int *p = (int *)0x12ff7c;
*p = NULL;
p = NULL;
在执行完第二条代码之后，发现p 的值变为0x00000000 了。按照我么上一节的解释，
应该p的值不变，只是p 指向的内存被赋值为0。难道我们讲错了吗？别急，再试试如下代
码：
int i = 10;
int *p = (int *)0x12ff7c;
*p = NULL;
p = NULL;
通过调试，发现这样子的话，p 的值没有变，而p 指向的内存的值变为0 了。这与我
们前面讲解的完全一致。当然这里的i 的地址刚好是0x12ff7c，但这并不能改变“*p =
NULL;”这行代码的功能。为了再次测试这个问题，我又调试了如下代码：
int i = 10;
int j = 100;
int *p = (int *)0x12ff78;
*p = NULL;
p = NULL;
这里0x12ff78 刚好就是变量j 的地址。这样的话一切正常，但是如果把“int j =
100;”这行代码删除的话，又出现上述的问题了。测试到这里我还是不甘心，编译器怎么
能犯这种低级错误呢？于是又接着进行了如下测试：
unsigned int i = 10;
//unsigned int j = 100;
unsigned int *p = (unsigned int *)0x12ff78;
*p = NULL;
p = NULL;
得到的结果与上面完全一样。当然，我还是没有死心，又进行了如下测试：
char ch = 10;
char *p = (char *)0x12ff7c;
*p = NULL;
p = NULL;
这样子的话，完全正常。但当我删除掉第一行代码后再测试，这里的p 的值并未变成
0x00000000，而是变成了0x0012ff00，同时*p 的值变成了0。这又是怎么回事呢？初学
者是否认为这是编译器“良心发现”，把*p 的值改写为0 了。
如果你真这么认为，那就大错特错了。这里的*p 还是地址0x12ff7c 上的内容吗？显
然不是，而是地址0x0012ff00 上的内容。至于0x12ff7c 为什么变成0x0012ff00，则是
因为编译器认为这是把NULL 赋值给char 类型的内存，所以只是把指针变量p 的低地址上
- 70 -
的一个字节赋值为0。至于为什么是低地址，请参看前面讲解过大小端模式相关内容。
测试到这里，已经基本可以肯定这是Visual C++ 6.0 的一个bug。所以平时一定不要
迷信某个编译器，要相信自己的判断。当然，后面还会提到一个我认为的Visual C++ 6.0
的一个bug。还有，这个小小的例子，你是否可以在多个编译器上测试测试呢？
4.1.6 如何达到手中无剑、胸中也无剑的地步
噢，上面的讨论一不小心就这么多了。这里我为什么要把这个小小的问题放到这里长篇
大论呢？我是想告诉读者：研究问题一定要肯钻研。千万不要小看某一个简单的事情，简单
的事情可能富含着很多秘密。经过这样一番深究，相信你也有不少收获。
平时学习工作也是如此，不要小瞧任何一件简单的事情，把简单的事情做好也是一种伟
大。劳模许振超开了几十年的吊车，技术精到指哪打哪的地步。达到这种程度是需要花苦功
夫的，几十年如一日天天重复这件看似很简单的事情，这不是一般人能做到的。同样的，在
《天龙八部》中，萧峰血战聚贤庄的时候，一套平平凡凡的太祖长拳打得虎虎生威，在场的
英雄无不佩服至极，这也是其苦练的结果。我们学习工作同样如此，要肯下苦功夫钻研，不
要怕钻得深，只怕钻得不深。其实这也就是为什么同一个班的学生，水平会相差非常大的最
关键之处。学得好的，往往是那些舍得钻研的学生。我平时上课教学生的绝不仅仅是知识点，
更多的时候我在教他们学习和解决问题的方法。有时候这个过程远比结论要重要的多。后面
的内容，你也应该能看出来，我非常注重过程的分析，只有你真正明白了这些思考问题、解
决问题的方法和过程，你才能真正立于不败之地。所有的问题对你来说都是一个样，没有本
质的区别。解决任何问题的办法都一致，那就是把没见过的、不会的问题想法设法转换成你
见过的、你会的问题；至于怎么去转换那就要靠你的苦学苦练了。也就是说你要达到手中无
剑，胸中也无剑的地步。
当然这些只是我个人的领悟，写在这里希望能与君共勉。
4.2 数组
4.2.1 数组的内存布局
先看下面的例子：
int a[5];
所有人都明白这里定义了一个数组，其包含了5 个int 型的数据。我们可以用
a[0],a[1]等来访问数组里面的每一个元素，那么这些元素的名字就是a[0],a[1]…吗？看
下面的示意图：
- 71 -
如上图所示，当我们定义一个数组a 时，编译器根据指定的元素个数和元素的类型分配
确定大小（元素类型大小*元素个数）的一块内存，并把这块内存的名字命名为a。名字a 一
旦与这块内存匹配就不能被改变。a[0],a[1]等为a 的元素，但并非元素的名字。数组的每
一个元素都是没有名字的。那现在再来回答第一章讲解sizeof 关键字时的几个问题：
sizeof(a)的值为sizeof(int)*5，32 位系统下为20。
sizeof(a[0])的值为sizeof(int)，32 位系统下为4。
sizeof(a[5])的值在32 位系统下为4。并没有出错，为什么呢？我们讲过sizeof 是
关键字，而不是函数。函数求值是在运行的时候，而关键字sizeof 求值是在编译的时候。
虽然并不存在a[5]这个元素，但是这里也并没有去真正访问a[5],而是仅仅根据数组元素的
类型来确定其值。所以这里使用a[5]并不会出错。
sizeof(&a[0])的值在32 位系下为4，这很好理解。取元素a[0]的首地址。
sizeof(&a)的值在32 位系统下也为4，这也很好理解。取数组a 的首地址。但是在
Visual
C++6.0 上，这个值为20，我认为是错误的。
4.2.2 省政府和市政的区别----&a[0]和&a 的区别
这里&a[0]和&a 到底有什么区别呢？a[0]是一个元素，a 是整个数组，虽然&a[0]和
&a的值一样，但其意义不一样。前者是数组首元素的首地址，而后者是数组的首地址。举
个例子：湖南的省政府在长沙，而长沙的市政府也在长沙。两个政府都在长沙，但其代表的
意义完全不同。这里也是同一个意思。
4.2.3 数组名 a 作为左值和右值的区别
简单而言，出现在赋值符“=”右边的就是右值，出现在赋值符“=”左边的就是左值。
比如,x=y。
左值：在这个上下文环境中，编译器认为x 的含义是x 所代表的地址。这个地址只有
编译器知道，在编译的时候确定，编译器在一个特定的区域保存这个地址，我们完全不必考
虑这个地址保存在哪里。
- 72 -
右值：在这个上下文环境中，编译器认为y 的含义是y 所代表的地址里面的内容。这
个内容是什么，只有到运行时才知道。
C 语言引入一个术语-----“可修改的左值”。意思就是，出现在赋值符左边的符号所
代表的地址上的内容一定是可以被修改的。换句话说，就是我们只能给非只读变量赋值。既
然已经明白左值和右值的区别，下面就讨论一下数组作为左值和右值的情况：
当a 作为右值的时候代表的是什么意思呢？很多书认为是数组的首地址，其实这是非常
错误的。a 作为右值时其意义与&a[0]是一样，代表的是数组首元素的首地址，而不是数组
的首地址。这是两码事。但是注意，这仅仅是代表，并没有一个地方（这只是简单的这么认
为，其具体实现细节不作过多讨论）来存储这个地址，也就是说编译器并没有为数组a分配