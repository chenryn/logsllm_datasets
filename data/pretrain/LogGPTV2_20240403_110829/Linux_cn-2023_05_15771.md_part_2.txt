但是这是荒谬的！变量 `b` 的值在第 7 行被访问了。但是仔细看；警告是关于第 8 行的。这很令人困惑；让我们暂时跳过这个警告，继续看错误。
这个错误信息说 `used binding b is possibly-uninitialized`。和之前的例子一样，Rust 编译器指出错误是由于尝试在第 7 行读取变量 `b` 的值而引起的。读取变量 `b` 的值是错误的原因是它的值没有初始化。在 Rust 编程语言中，这是非法的。因此编译时错误出现。
> 
> ?️ 这个错误可以很容易地通过交换第 7 和第 8 行的代码来解决。试一下，看看错误是否消失了。
> 
> 
> 
### 示例程序：交换数字
现在你已经熟悉了常见的变量相关问题，让我们来看一个交换两个变量值的程序。
```
fn main() {
    let mut a = 7186932;
    let mut b = 1276561;
    println!("a: {a}, b: {b}");
    // 交换变量值
    let temp = a;
    a = b;
    b = temp;
    println!("a: {}, b: {}", a, b);
}
```
我在这里声明了两个变量 `a` 和 `b`。这两个变量都是可变的，因为我希望在后面改变它们的值。我赋予了一些随机值。最初，我打印了这些变量的值。
然后，在第 8 行，我创建了一个名为 `temp` 的不可变变量，并将存储在 `a` 中的值赋给它。之所以这个变量是不可变的，是因为 `temp` 的值不会改变。
要交换值，我将变量 `b` 的值赋给变量 `a`，在下一行，我将 `temp` 的值（它包含 `a` 的值）赋给变量 `b`。现在值已经交换了，我打印了变量 `a` 和 `b` 的值。
在编译并执行上面的代码后，我得到了以下输出：
```
a: 7186932, b: 1276561
a: 1276561, b: 7186932
```
正如你所见，值已经交换了。完美。
### 使用未使用的变量
当你声明了一些变量，打算在后面使用它们，但是还没有使用它们，然后编译你的 Rust 代码来检查一些东西时，Rust 编译器会警告你。
原因是显而易见的。不会被使用的变量占用了不必要的初始化时间（CPU 周期）和内存空间。如果不会被使用，为什么要在程序写上它呢？尽管编译器确实会优化这一点。但是它仍然是一个问题，因为它会以多余的代码的形式影响可读性。
但是，有的时候，你可能会面对这样的情况：创建一个变量与否不在你的控制之下。比如说，当一个函数返回多个值，而你只需要其中的一些值时。在这种情况下，你不能要求库维护者根据你的需要调整他们的函数。
所以，在这种情况下，你可以写一个以下划线开头的变量，Rust 编译器将不再显示这样的警告。如果你真的不需要使用存储在该未使用变量中的值，你可以简单地将其命名为 `_`（下划线），Rust 编译器也会忽略它！
接下来的程序不仅不会生成任何输出，而且也不会生成任何警告和/或错误消息：
```
fn main() {
    let _unnecessary_var = 0; // 没有警告
    let _ = 0.0; // 完全忽略
}
```
### 算术运算
数学就是数学，Rust 并没有在这方面创新。你可以使用在其他编程语言（如 C、C++ 和/或 Java）中使用过的所有算术运算符。
包含可以在 Rust 编程语言中使用的所有运算符和它们的含义的完整列表可以在 [这里](https://doc.rust-lang.org/book/appendix-02-operators.html?ref=itsfoss.com#operators) 找到。
#### 示例程序：一个生锈的温度计
（LCTT 译注：这里的温度计“生锈”了是因为它是使用 Rust（生锈）编写的，原作者在这里玩了一个双关。）
接下来是一个典型的程序，它将华氏度转换为摄氏度，反之亦然。
```
fn main() {
    let boiling_water_f: f64 = 212.0;
    let frozen_water_c: f64 = 0.0;
    let boiling_water_c = (boiling_water_f - 32.0) * (5.0 / 9.0);
    let frozen_water_f = (frozen_water_c * (9.0 / 5.0)) + 32.0;
    println!(
        "Water starts boiling at {}°C (or {}°F).",
        boiling_water_c, boiling_water_f
    );
    println!(
        "Water starts freezing at {}°C (or {}°F).",
        frozen_water_c, frozen_water_f
    );
}
```
没什么大不了的……华氏温度转换为摄氏温度，反之亦然。
正如你在这里看到的，由于 Rust 不允许自动类型转换，我不得不在整数 32、9 和 5 后放一个小数点。除此之外，这与你在 C、C++ 和/或 Java 中所做的类似。
作为练习，尝试编写一个程序，找出给定数中有多少位数字。
### 常量
如果你有一些编程知识，你可能知道这意味着什么。常量是一种特殊类型的变量，它的值**永远不会改变**。*它保持不变*。
在 Rust 编程语言中，使用以下语法声明常量：
```
const CONSTANT_NAME: data_type = value;
```
如你所见，声明常量的语法与我们在 Rust 中看到的变量声明非常相似。但是有两个不同之处：
* 常量的名字需要像 `SCREAMING_SNAKE_CASE` 这样。所有的大写字母和单词之间用下划线分隔。
* 常量的数据类型**必须**被显性定义。
#### 变量与常量的对比
你可能在想，既然变量默认是不可变的，为什么语言还要包含常量呢？
接下来这个表格应该可以帮助你消除疑虑。（如果你好奇并且想更好地理解这些区别，你可以看看[我的博客](https://blog.thefossguy.com/posts/immutable-vars-vs-constants-rs.md?ref=itsfoss.com)，它详细地展示了这些区别。）
![一个展示 Rust 编程语言中变量和常量之间区别的表格](/data/attachment/album/202305/01/145031yte8qc9cm85ytsut.png)
#### 使用常量的示例程序：计算圆的面积
这是一个很直接的关于 Rust 中常量的简单程序。它计算圆的面积和周长。
```
fn main() {
    const PI: f64 = 3.14;
    let radius: f64 = 50.0;
    let circle_area = PI * (radius * radius);
    let circle_perimeter = 2.0 * PI * radius;
    println!("有一个周长为 {radius} 厘米的圆");
    println!("它的面积是 {} 平方厘米", circle_area);
    println!(
        "以及它的周长是 {} 厘米",
        circle_perimeter
    );
}
```
如果运行代码，将产生以下输出：
```
有一个周长为 50 厘米的圆
它的面积是 7850 平方厘米
以及它的周长是 314 厘米
```
### Rust 中的变量遮蔽
如果你是一个 C++ 程序员，你可能已经知道我在说什么了。当程序员**声明**一个与已经声明的变量同名的新变量时，这就是变量遮蔽。
与 C++ 不同，Rust 允许你在同一作用域中执行变量遮蔽！
> 
> ? 当程序员遮蔽一个已经存在的变量时，新变量会被分配一个新的内存地址，但是使用与现有变量相同的名称引用。
> 
> 
> 
来看看它在 Rust 中是如何工作的。
```
fn main() {
    let a = 108;
    println!("a 的地址: {:p}, a 的值 {a}", &a);
    let a = 56;
    println!("a 的地址: {:p}, a 的值: {a} // 遮蔽后", &a);
    let mut b = 82;
    println!("\nb 的地址: {:p}, b 的值: {b}", &b);
    let mut b = 120;
    println!("b的地址: {:p}, b的值: {b} // 遮蔽后", &b);
    let mut c = 18;
    println!("\nc 的地址: {:p}, c的值: {c}", &c);
    c = 29;
    println!("c 的地址: {:p}, c的值: {c} // 遮蔽后", &c);
}
```
`println` 语句中花括号内的 `:p` 与 C 中的 `%p` 类似。它指定值的格式为内存地址（指针）。
我在这里使用了 3 个变量。变量 `a` 是不可变的，并且在第 4 行被遮蔽。变量 `b` 是可变的，并且在第 9 行也被遮蔽。变量 `c` 是可变的，但是在第 14 行，只有它的值被改变了。它没有被遮蔽。
现在，让我们看看输出。
```
a 的地址: 0x7ffe954bf614, a 的值 108
a 的地址: 0x7ffe954bf674, a 的值: 56 // 遮蔽后
b 的地址: 0x7ffe954bf6d4, b 的值: 82
b 的地址: 0x7ffe954bf734, b 的值: 120 // 遮蔽后
c 的地址: 0x7ffe954bf734, c 的值: 18
c 的地址: 0x7ffe954bf734, c 的值: 29 // 遮蔽后
```
来看看输出，你会发现不仅所有三个变量的值都改变了，而且被遮蔽的变量的地址也不同（检查十六进制的最后几个字符）。
变量 `a` 和 `b` 的内存地址改变了。这意味着变量的可变性或不可变性并不是遮蔽变量的限制。
### 总结
本文介绍了 Rust 编程语言中的变量和常量。还介绍了算术运算。
做个总结：
* Rust 中的变量默认是不可变的，但是可以引入可变性。
* 程序员需要显式地指定变量的可变性。
* 常量总是不可变的，无论如何都需要类型注释。
* 变量遮蔽是指使用与现有变量相同的名称声明一个 *新* 变量。
很好！我相信和 Rust 一起的进展不错。在下一章中，我将讨论 Rust 中的数据类型。敬请关注。
与此同时，如果你有任何问题，请告诉我。
*（题图：MJ/7c5366b8-f926-487e-9153-0a877145ca5）*
---
via: 
作者：[Pratham Patel](https://itsfoss.com/author/pratham/) 选题：[lkxed](https://github.com/lkxed/) 译者：[Cubik](https://github.com/Cubik65536) 校对：[wxy](https://github.com/wxy)
本文由 [LCTT](https://github.com/LCTT/TranslateProject) 原创编译，[Linux中国](https://linux.cn/) 荣誉推出