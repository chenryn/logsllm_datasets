**代码分析**
所使用的代码版本为jscript.dll version
5.8.9600.19178，逆向jscript!JsArrayFunctionHeapSort如下：
    69fcd60f 8b7d10 mov edi,dword ptr [ebp+10h] ;输入对象中的参数个数
    69fcd612 81ffaaaaaa0a cmp edi,0AAAAAAAh
    69fcd618 0f87e2820000 ja jscript!JsArrayFunctionHeapSort+0x36d (69fd5900)
    69fcd61e 8bc7 mov eax,edi
    69fcd620 c1e002 shl eax,2
    69fcd623 50 push eax
    69fcd624 ff15fc40026a call dword ptr [jscript!_imp__malloc (6a0240fc)]
    69fcd62a 59 pop ecx
    69fcd62b 8bc8 mov ecx,eax
    69fcd62d 894dd4 mov dword ptr [ebp-2Ch],ecx
    69fcd630 894da8 mov dword ptr [ebp-58h],ecx
    69fcd633 85c9 test ecx,ecx
    69fcd635 0f84c5820000 je jscript!JsArrayFunctionHeapSort+0x36d (69fd5900)
    69fcd63b 6bdf18 imul ebx,edi,18h ;基于输入对象种的参数个数计算出buffer/array的size
    69fcd63e 53 push ebx
    69fcd63f ff15fc40026a call dword ptr [jscript!_imp__malloc (6a0240fc)];buffer/array内存分配
    6789d67a 8b550c mov edx,dword ptr [ebp+0Ch]
    6789d67d 8bc2 mov eax,edx ;eax中存放的是arguments对象中的elements，edi中存放输入对象中的参数个数
    6789d67f d1e8 shr eax,1
    6789d681 3bf8 cmp edi,eax ;在此处，如果arguments对象中的参数个数为2或者3，将进入发生访问冲突的循环
    6789d683 0f826b820000 jb jscript!JsArrayFunctionHeapSort+0x35a (678a58f4)
    69fcd692 8d5308 lea edx,[ebx+8] ;缓冲区中的指针增加，并在此处输入循环
    69fcd695 8b75d8 mov esi,dword ptr [ebp-28h]
    69fcd698 8b06 mov eax,dword ptr [esi]
    69fcd69a 8bfc mov edi,esp
    69fcd69c 52 push edx
    69fcd69d 51 push ecx
    69fcd69e 8b706c mov esi,dword ptr [eax+6Ch]
    69fcd6a1 8bce mov ecx,esi
    69fcd6a3 ff153843026a call dword ptr [jscript!__guard_check_icall_fptr (6a024338)]
    69fcd6a9 8b4dd8 mov ecx,dword ptr [ebp-28h]
    69fcd6ac ffd6 call esi ;调用jscript!NameTbl::GetVal，该函数调用了jscript!NameTbl::GetValCore
    69fcd6d6 41 inc ecx ;increment counter
    69fcd6d7 8b550c mov edx,dword ptr [ebp+0Ch]
    69fcd68b 894ddc mov dword ptr [ebp-24h],ecx ss:0023:04eaa7f0=00000000
    69fcd68e 3bca cmp ecx,edx ;循环
    69fcd690 736a jae jscript!JsArrayFunctionHeapSort+0x113 (69fcd6fc)
jscript!NameTbl::GetValCore函数:
    678ba099 8b4d0c mov ecx,dword ptr [ebp+0Ch]
    678ba09c 8b02 mov eax,dword ptr [edx]
    ;缓冲区发生溢出或者进行越界写
    678ba09e 8901 mov dword ptr [ecx],eax ds:0023:0be09008=????????
**POC代码**
    此漏洞已经有公开的exp，故此处直接给出poc的具体代码。
      Trend Micro Security Research PoC
###  攻击场景分析
根据上面的分析，如果攻击者企图进行攻击，需要受害者打开一个特制的文档，而这种实现一般是通过钓鱼或者发送恶意邮件，诱骗受害者主动打开攻击者构造的恶意文档，实现攻击。如今的钓鱼网站一般都是只要打开链接就自动访问并下载、打开攻击者构造的文档，也就是说，只要访问了攻击者的恶意链接，就会中招。  
虽然现在大家的网络安全意识普遍比之前有了显著的提高，但对于一些高级的社会工程攻击仍然不具备良好的辨别能力，因此认定该漏洞仍然具有较高的影响力，需要引起重视。  
而且在一些政企部门，使用的操作系统相对较为老旧，版本更新停滞，软件的安全更新得不到足够的重视，在现如今APT攻击手段成熟的情况下，很容易遭受恶意组织的攻击。
###  流量分析
此处简单模拟了一下访问恶意网站然后下载恶意文档的流程，进行抓包分析：
从数据包中可以明显看出，受害者下载下来攻击者构造的恶意文档后，文档中的js代码进行了执行，从而触发漏洞，导致浏览器崩溃。
###  检测思路
了解攻击的目的是为了更好的防御，下面就根据上面的分析过程简单说一下防御思路：
为了检测此漏洞，检测设备必须监控传输的HTML页面的各种元素，并且能够解析JavaScript代码。但是我们容易发现，根据上面的分析记过，由于此漏洞的特殊性，无法可靠地检测基于此漏洞的所有攻击，也就是入侵检测中常说的通防。那这种情况下，我们只能是根据已经发现的EXP和POC进行特征提取，然后进行定向防御。
通过之前的分析我们知道，针对此漏洞的恶意HTML文件可能包含具有以下功能的脚本代码：
  1. 定义了一个函数x，该函数利用apply()或call()方法调用sort()方法，并提供“compare”函数作为sort()方法的输入，例如， 
         x = function () {
         Array.prototype.sort.apply(this, [function(a, b) {return b - a;}]);
         }
  2. 将函数x的原型设置为另一个函数y中的arguments对象，并使用“new”关键字调用函数x。例如： 
         y = function () {
         x.prototype = arguments;
         new x();
     }
  3. 函数y由2或3个参数调用。例如： 
         y("trend", 4, 2);
上述条件均为攻击流量中需要包含的，如果在数据包中同时检测到上述所有条件，则应该怀疑该流量为攻击流量，甚至攻击正在进行。
但需要注意，由于易受攻击的代码中相互依赖关系的复杂性，可能会存在触发此漏洞的其他向量。同样，由于脚本语言的性质，攻击者也可能使用各种脚本技术来混淆代码的真正意图，而且当下的混淆技术极容易实现。此外必须以区分大小写的方式对JavaScript脚本代码中的对象和方法名称进行字符串匹配。上述思路只是可能可行的一种检测思路，虽然不能通防，但总比不防的好一点。
## 总结
针对该漏洞的分析基本到此为止，也是为分析CVE-2019-1367做一个简单的预热。需要引起重视的是，目前针对浏览器的攻击层出不穷，而且影响力越来越大，伴随着社会工程的成熟，利用浏览器漏洞进行更大范围攻击的攻击技术将快速发展。为了安全着想，还是希望广大用户可以及时更新安全补丁，宁可麻烦一点，总比受到损失的好。
## 参考链接
[1] Function.prototype,   
[2] Invoking a function,
[3] apply(),   
[4] sort(),   
[5] arguments object, 