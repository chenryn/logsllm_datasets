states are the same), and the two sequences σ(I, s0) and
σ(T, ECT , sT
0 ) are ﬁnite, and the following conditions
hold on the two sequences:
• (Condition 1): Let the two execution sequences be
given as follows:
1
k
eT
eT
σ(T, ECT , sT
(cid:4)= mem(sT
2−→ ··· eT
k−→ sT
e2−→ ··· er−→ sr
1−→ sT
0 ) = sT
0
e1−→ s1
σ(I, s0) = s0
0 )) be the set of addresses
Let aﬀected(σ(T, ECT , sT
a such that mem(sT
0 )[a]
k )[a], i.e.,
aﬀected(σ(T, ECT , sT
0 )) is the set of memory ad-
dresses whose value changes after executing the tem-
plate T from the initial state. We require that
k )[a] = mem(sr)[a] holds for all a ∈
mem(sT
aﬀected(σ(T, ECT , sT
0 )), i.e. values at addresses
that belong to the set aﬀected(σ(T, ECT , sT
0 )) are
the same after executing the template T and the in-
struction sequence I.
0 ,··· , eT
• (Condition 2): Ignoring null events, the event se-
quence (cid:5)eT
k (cid:6) is a subsequence of the event
sequence (cid:5)e0,··· , er(cid:6). In order for the two system
events e1 and e2 to match, their arguments and return
values should be identical.
Proceedings of the 2005 IEEE Symposium on Security and Privacy (S&P’05) 
1081-6011/05 $ 20.00 IEEE
• (Condition 3): If
0 )),
pc(sT
k ) ∈ aﬀected(σ(T, ECT , sT
then pc(sr) ∈ aﬀected(σ(T, ECT , sT
0 )).
In other
words, if the program counter at the end of executing
the template T points to the affected memory area,
then the program counter after executing I should
also point into the affected memory area.
Consider the example shown in Figure 1. Assume
that we use the execution context shown in Figure 1(c)
for the template shown in Figure 1(a). Suppose we ex-
ecute the template and instruction sequence shown in
Figure 1 from states with the same memory contents.
The state of the memory is same in both executions,
so condition 1 is true. Condition 2 is trivially satisﬁed.
Since the jumps have the same target, condition 3 is triv-
ially true.
Deﬁnition 2 A program P satisﬁes a template T (de-
noted as P |= T ) iff P contains an instruction sequence
I such that I contains a behavior speciﬁed by T . Given
a program P and a template T , we call the problem of
determining whether P |= T as the template matching
problem or TMP.
Deﬁning a variant family. Deﬁnition 2 can be used
to deﬁne a variant family. The intuition is that most vari-
ants of a malware contain a common set of malicious
behavior, such as a decryption loop and a loop to search
for email addresses. Let T be a set of templates (this set
contains speciﬁcation of malicious behavior common to
a certain malware family). The set T deﬁnes a variant
family as follows:
{P | for all T ∈ T , P |= T}
In other words, the variant family deﬁned by T contains
all programs that satisfy all templates in the set T.
Theorem 1 TMP is undecidable.
Proof: We will reduce the halting problem to TMP. Let
M be a Turing machine, and PM be a program that uses
instructions in our IR that simulates M (since our IR
is Turing complete, this can be accomplished). With-
out loss of generality, assume that PM does not touch
a special address sp addr while simulating the Turing
machine M. Before starting to simulate M, PM sets
mem[sp addr] to 0. After simulating M, if PM halts,
it sets mem[sp addr] to 1. Consider the template T
shown below:
mem[sp addr] = 0
mem[sp addr] = 1
It is easy to see that PM |= T iff M halts. (cid:1)
2.2. A weaker semantics
In some scenarios the semantics described in deﬁni-
tion 1 is too strict. For example, if a template uses cer-
0 )), we have mem(sT
tain memory locations to store temporaries, then these
memory locations should not be checked for equality
in comparing executions of an instruction sequence and
a template. Let σ(T, ECT , sT
0 ) be the sequence gen-
erated when a template T is executed from a state sT
0
using the execution context ECT . Deﬁne a set of core
memory locations core(σ(T, ECT , sT
0 )) which is a sub-
set of aﬀected(σ(T, ECT , sT
0 )). Condition 1 in deﬁni-
tion 1 can be changed as follows to give a weaker se-
mantics:
• (Modiﬁed condition 1): We require that for all
a ∈ core(σ(T, ECT , sT
k )[a] =
mem(sr)[a], i.e., values in the addresses that belong
to the set core(σ(T, ECT , sT
0 )) are the same after ex-
ecuting the template T and the instruction sequence
I. In other words, only the memory locations in the
set core(σ(T, ECT , sT
0 )) are checked for equality in
the two executions.
There are several ways to deﬁne core memory lo-
cations. We describe one possible deﬁnition of core
memory locations. Assume that each instruction in
the template T is labeled as temp or persistent. Intu-
itively if an instruction is labeled with temp, it performs
temporary computation. Let σ(T, ECT , sT
0 ) be the se-
quence generated when a template T executed from a
state sT
0 using the execution context ECT . Recall that
aﬀected(σ(T, ECT , sT
0 )) is the set of addresses a such
(cid:4)= mem(sT
that mem(sT
k is the
last state in the sequence σ(T, ECT , sT
0 ). Then the core
memory locations core(σ(T, ECT , sT
0 )) can be deﬁned
as any address in aﬀected(σ(T, ECT , sT
0 )) that is a tar-
get of a load or store instruction with label persistent.
k )[a], where sT
0 )[a]
3. Semantics-aware matching algorithm
We present an algorithm for checking whether a pro-
gram P satisﬁes a template T ; this algorithm is sound,
but not complete, with respect to the semantics pre-
sented in Section 2.1, yet it can handle several classes
of obfuscations (see Section 3.4). We have also im-
plemented our algorithm as a malware-detection tool.
The tool takes as input a template and a binary program
for the Microsoft Windows on Intel IA-32 (x86) plat-
form, and determines whether a fragment of the sus-
picious program contains a behavior speciﬁed by the
template. The tool’s output describes the matched frag-
ment of the program together with information relating
template variables to program registers and memory lo-
cations, and a list of “irrelevant” instruction sequences
that are part of the matched program fragment.
3.1. Architecture
The tool is built on top of the IDA Pro disassem-
bler [13]. Figure 2 illustrates the ﬂow through the tool,
Proceedings of the 2005 IEEE Symposium on Security and Privacy (S&P’05) 
1081-6011/05 $ 20.00 IEEE
Program
IDAPro
IR conversion
Template
Program IR
Yes/No
Malware detector
Predeﬁned patterns of
irrelevant instructions.
Randomized x86
interpreter.
Theorem prover.
Decision procedure with
bit-vector arithmetic.
Decision procedures
Nop library
Random execution
Simplify
UCLID
t
s
o
c
d
n
a
i
i
n
o
s
c
e
r
p
i
g
n
s
a
e
r
c
n
I
Figure 2. The architecture of the malicious
code detector. Gray boxes represent ex-
isting infrastructure.
starting with the input binary program on the left and
ending with an output indicating whether the program
satisﬁes the template.
We ﬁrst disassemble the binary program, construct
control ﬂow graphs, one per program function (as iden-
tiﬁed by IDA Pro), and produce an intermediate rep-
resentation (IR). The IR is generated using a library
of x86 instruction transformers, in such a way that the
IR is architecture-independent. The IR can still con-
tain library and system calls that are, by deﬁnition,
platform-speciﬁc – we remove this last dependency by
using summary functions expressed in IR form (see Ap-
pendix B for a description of the IR).
The rest of the toolkit takes advantage of the plat-
form- and architecture-independent IR. We have ini-
tially focused our research on the Microsoft Windows
on Intel IA-32 platform, with no loss of generality. By
providing appropriate front-ends that translate the pro-
gram into the IR format, one can use our malware-
detector tool to process programs for different plat-
forms.
3.2. Algorithm description
Our malware detection algorithm AMD works by
ﬁnding, for each template node, a matching node in
the program. Individual nodes from the template and
the program match if there exists an assignment to vari-
ables from the template node expression that uniﬁes it
with the program node expression. Once two matching
nodes are found, we check whether the def-use relation-
ships true between template nodes also hold true in the
corresponding program (two nodes are related by a def-
use relationship if one node’s deﬁnition of a variable
reaches the other node’s use of the same variable). If all
the nodes in the template have matching counterparts
under these conditions, the algorithm has found a pro-
gram fragment that satisﬁes the template and produces
a proof of this relationship.
Formally, given a malicious code template T and a
program P , we deﬁne the malware detection algorithm
AMD as a predicate on pairs of programs and templates,
AMD : Programs × Templates → {yes,⊥}, such that
AMD(P, T ) returns “yes” when program P satisﬁes
template T under the conditions below. We denote by ⊥
(i.e. “don’t know”) the return value from the algorithm
when it cannot determine that the program satisﬁes the
template.
Consider the example in Figure 3, where a simpler
version of the template T from Figure 1(a) uses expres-
sion X≥const addr3 instead of the symbolic constant
condition(X) and Xˆ5 (where symbol ‘ˆ’ represents the
bit-vector xor operator) instead of f(X). Similarly, the
program P in Figure 3 is a simpler version of the mal-
ware instance from Figure 1(b). For P to satisfy T in
algorithm AMD, i.e., AMD(P, T ) = yes, the following
two conditions have to hold:
• Matching of template nodes to program nodes.
First, each node n in the template has to unify with a
node m in P . In other words, there is an onto partial
function f from the nodes of P to nodes in T , such
that f(m) in T and m in P are uniﬁable. We will de-
note by B(X, n, m), where n = f(m), the binding
of variable X referred to in the template instruction
at node n to an expression referred to in the program
instruction at node m. In Figure 3, the gray arrows
connect uniﬁed template nodes and program nodes:
for instance, program node 7 uniﬁes with template
node 4.
• Preservation of def-use paths. For each node n in
T , deﬁne def (n) as the set of variables deﬁned in
n. Similarly, use(n) is the set of variables used in
node n. In Figure 3, template node 3 uses variable A,
use(3) = {A}, while template node 6 both deﬁnes
and uses variable B, def (6) = use(6) = {B}. De-
ﬁne synthetic nodes npre as predecessor to the tem-
plate entry node and npost as successor to all template
exit nodes, such that def (npre) = use(npost) = VT .
A def-use path is a sequence of nodes (cid:5)n1, ..., nk(cid:6)
such that the following conditions are true:
– For 1 ≤ i < k, there is an edge from ni to ni+1
in T , i.e., (cid:5)n1,··· , nk(cid:6) is a valid path through the
template T .
Proceedings of the 2005 IEEE Symposium on Security and Privacy (S&P’05) 
1081-6011/05 $ 20.00 IEEE
– The instruction I(n1) (at node n1) deﬁnes a vari-
able that I(nk) uses, that is, def (n1) ∩ use(nk) (cid:4)=
∅.
– None of the instructions at the intermediate nodes
redeﬁne the value of the variables in def (n1), i.e.,
def (n1) ∩ def (ni) = ∅ for 1 < i < k.
(cid:1)
, m
Two nodes n1 and n2 are def-use related (denoted by
duse(n1, n2)) iff there exists a path from n1 to n2
that is a def-use path. In Figure 3, template nodes
1 and 3 are def-use related, with the corresponding
def-use path (cid:5)1, 2, 3(cid:6).
(cid:1) in T that are def-use
Consider two nodes n and n
(cid:1) in T be matched to
related. Let nodes n and n
(cid:1) in program P , i.e. f(m) = n
nodes m and m
(cid:1). Suppose X is a variable that is
(cid:1)) = n
and f(m
(cid:1), and B(X, n, m) = r
deﬁned in n and used in n
(cid:1)) = r
(cid:1), i.e., X is bound to expres-
and B(X, n
(cid:1) in program node
sion r program in node m and r
(cid:1).
In this case, we need to make sure that the
m
value of expression r after executing the instruction
(cid:1) before
I(m) is same as the value of expression r
(cid:1)), for every program
executing the instruction I(m
path corresponding (under the matching function f)
(cid:1).
to a template path from n to n
In Figure 3, pro-
gram nodes 1 and 5 match template nodes 1 and
3, with respective bindings B(A, 1, 1) = eax and
B(A, 3, 5) = (ecx − 1). The condition we need to
enforce is that the value of eax after program instruc-
tion I(1) is same as the value of (ecx −1) before pro-
gram instruction I(5). In our algorithm, these value
invariants are checked using a decision procedure.
Algorithm AMD implements a conservative approxima-
tion of the formal semantics of malware detection from
Section 2.1, as the following result demonstrates.
Theorem 2 AMD is sound with respect to the TMP se-
mantics, i.e. AMD(P, T ) = yes implies that P |= T .
(cid:1)
The proof is given in Appendix A. Our algorithm is thus
sound with respect to the TMP semantics, but it is not
complete. We can show there exists a program P , and a
template T , such that P |= T , but AMD(P, T ) returns
⊥. Consider the following example (in C-like syntax)
where the template captures the behavior of initializing
an array of 10 elements to 0.
Template T
Program P
for ( i =0; i <10; i ++)
a [ i ] = 0 ;
for ( i =0; i <10; i +=2)
for ( i =1; i <10; i +=2)
a [ i ] = 0 ;
a [ i ] = 0 ;
Both the program and the template initialize one array
of 10 elements: the sets of affected memory locations
are the same in the ﬁnal states of the template and the
program, thus P |= T . Our algorithm AMD will not
A
1
2
3