r e g e x c h e c k
common_name = self._get_common_name(cert)
alt_names = self._get_subject_alt_names(cert)
# r e p l a c e ∗ w i t h a l p h a n u m e r i c and d a s h
# r e p l a c e . w i t h l i t e r a l
valid_patterns = [re.compile(pattern.replace(r".", r"
.
\.").replace(r"*", r"[0-9A-Za-z]+"))
for pattern
in (set(common_name) | set(alt_names))
]
return any(
pattern.search(hostname)
for pattern in valid_patterns
)
This bug has been ﬁxed in Libcloud version 0.11.1 after we no-
tiﬁed the developers.
10.3 Amazon Elastic Load Balancing API Tools
This library overrides JDK’s default X509TrustManager to dis-
able hostname veriﬁcation. Even if X509TrustManager had not been
overriden, this library employs Codehaus XFire which does not
perform hostname veriﬁcation (see Section 8.1).
10.4 Shopping carts
osCommerce, ZenCart, Ubercart, and PrestaShop are open-
source shopping carts implemented in PHP. They use cURL for
SSL connections to payment gateways. If cURL is not available,
they typically fall back on (insecure) fsockopen.
All carts are bundled with plugin modules for speciﬁc payment
processors. Almost without exception, these modules turn off cer-
tiﬁcate validation. In ZenCart, vulnerable modules include Link-
Point, Authorize.Net, and PayPal Payments Pro, as well as PayPal
IPN functionality (see Section 7.3). The insecure LinkPoint mod-
ule contains an amusing comment at the beginning of the ﬁle: “###
YOU REALLY DO NOT NEED TO EDIT THIS FILE! ###”
Vulnerable modules include eBay, PayPal, and Canada Post in
PrestaShop, PayPal, Authorize.Net, and CyberSource in Ubercart,
Sage Pay Direct, Authorize.Net, MoneyBookers, and PayPal Ex-
press, Pro, Pro PayFlow, and Pro PayFlow EC in osCommerce.
SSL connections to payment gateways from merchants using any
of these carts are insecure against a man-in-the-middle attack.
The only exceptions are Google modules for PrestaShop and os-
Commerce. The Google Checkout module for osCommerce comes
from code.google.com and is not bundled with osCommerce.
It sets CURLOPT_SSL_VERIFYPEER to true and leaves CURLOPT_SSL_
VERIFYHOST to its correct default value, 2. By contrast, the ofﬁcial,
PayPal-provided PayFlow module disables certiﬁcate validation.
10.5 AdMob
Google’s AdMob provides sample code to mobile site owners
that they can use on their servers to associate instances of their
mobile apps with their developer accounts (see Section 5). This
code uses cURL to establish an SSL connection to AdMob’s server,
but turns off certiﬁcate validation. A man-in-the-middle attacker
can thus gain access to all of the developers’ Google services.
10.6 Android apps
15http://iphonedevelopment.blogspot.com/2010/
05/nsstream-tcp-and-ssl.html
16http://libcloud.apache.org/
Groupon Redemptions, an Android app for merchants, disables
certiﬁcate validation twice: by allowing any hostname via the “al-
low all” hostname veriﬁer and by binding to an empty trust man-
47ager. Similarly, Breezy, an app for secure document printing, dis-
ables hostname veriﬁcation and overrides the default trust manager.
ACRA, an Android library for posting application crash reports
to a Google Doc, overrides the default trust manager. Any app
using this library is insecure against a man-in-the-middle attack.
10.7 AIM
AIM client version 1.0.1.2 on Windows uses Microsoft’s Cryp-
toAPI. Runtime analysis shows that it calls CryptoAPI’s certiﬁ-
cate validation function CertVerifyCertificateChainPolicy. To
disable certiﬁcate validation, it passes a CERT_CHAIN_POLICY_PARA
variable with CERT_CHAIN_POLICY_ALLOW_UNKNOWN_CA_FLAG set, in-
structing CryptoAPI to accept certiﬁcates signed by untrusted au-
thorities. AIM does not perform any hostname veriﬁcation, either.
10.8 FilesAnywhere
FilesAnywhere is an application for managing cloud storage. It
uses CryptoAPI for SSL connections and accepts both self-signed
and third-party certiﬁcates.
FilesAnywhere has an interesting peculiarity. If presented with
a Google certiﬁcate when it attempts to connect to a non-Google
server, it shows a warning message “The WebDav server has a new
address. Please specify http://google.com in the proﬁle.” If pre-
sented with any other third-party certiﬁcate, it silently accepts it
and sends user’s data to a wrong, potentially malicious server.
11. OUR RECOMMENDATIONS
Whenever application developers must deal with SSL, the con-
ventional advice is to use standard SSL libraries. This advice is
correct, but insufﬁcient. As this paper shows, even developers of
high-security software often use standard SSL libraries incorrectly.
The following recommendations are informed by our analyses of
broken SSL certiﬁcate validation in diverse applications.
11.1 For application developers
DO use fuzzing (black-box, if necessary) and adversarial test-
ing to see how the application behaves when presented with abnor-
mal SSL certiﬁcates. Even when the vulnerabilities are subtle, the
symptoms usually are not. In many of our case studies, it is obvious
that the software in question has never been tested with any certiﬁ-
cates other than those of the intended server. When presented with
a certiﬁcate issued to AllYourSSLAreBelongTo.us instead
of the expected Amazon or PayPal or Chase certiﬁcate, these pro-
grams eagerly establish SSL connections and spill out their secrets.
These vulnerabilities should have manifested during testing.
DON’T modify application code and disable certiﬁcate valida-
tion for testing with self-signed and/or untrusted certiﬁcates. We
found in our case studies that developers forget to reverse these
modiﬁcations even for the production version of the software. In-
stead, create a temporary keystore with the untrusted CA’s public
key in it. While testing your code with self-signed or untrusted
certiﬁcates, use that keystore as your trusted keystore.
DON’T depend on the library’s defaults to set up the SSL con-
nection securely. Default settings can and do change between dif-
ferent libraries or even different versions of the same library—for
example, cURL prior to version 7.10 did not validate certiﬁcates
by default, but version 7.10 and later do. Always explicitly set the
options necessary for secure connection establishment.
11.2 For SSL library developers
DO make SSL libraries more explicit about the semantics of their
APIs. In many cases, it is obvious that application developers do
not understand the meaning of various options and parameters. For
example, the PHP libraries for Amazon Flexible Payments Services
and PayPal Payments Standard attempt to enable hostname veriﬁ-
cation in cURL, but instead accidentally override the correct default
value and end up disabling it (Sections 7.1 and 7.2). This shows
that even safe defaults may be insufﬁcient. Lynx attempts to check
for self-signed certiﬁcates, but misinterprets the meaning of return
values of GnuTLS’s certiﬁcate validation function and the check is
never executed (Section 7.4). Formalizing the precise semantics of
SSL library API and rigorously verifying the “contracts” between
the application and the library is an interesting topic for future re-
search and may call for programming language support.
DON’T delegate the responsibility for managing SSL connec-
tions to the applications. Existing SSL libraries expose many op-
tions to higher-level software. This is fraught with peril. Appli-
cation developers may not realize that they must explicitly choose
certain options in order to enable certiﬁcate validation. Therefore,
libraries should use safe defaults as much as possible. Furthermore,
they should not silently skip important functionality such as host-
name veriﬁcation as JSSE does when the algorithm ﬁeld is NULL
or an empty string (see Section 4.1). Instead, they should raise a
runtime exception or inform the application in some other way.
DO design a clean and consistent error reporting interface. Li-
braries such as OpenSSL and GnuTLS report some errors via re-
turn values of functions, while other errors from the same function
are reported through a ﬂag passed as an argument. Inconsistent in-
terfaces confuse developers who then mistakenly omit some error
checks in their applications.
These recommendations provide short-term ﬁxes. A principled
solution to the problem must involve a complete redesign of the
SSL libraries’ API. Instead of asking application developers to man-
age incomprehensible options such as CURLOPT_SSL_VERIFYPEER or
SSL_get_verify_result, they should present high-level abstrac-
tions that explicitly express security properties of network connec-
tions in terms that are close to application semantics: for exam-
ple, a “conﬁdential and authenticated tunnel.” The library should
also be explicit about the security consequences of any application-
controlled option: for example, instead of “verify hostname?”, it
could ask “Anyone can impersonate the server. Ok or not?”
12. RELATED WORK
Independently of this work, Kevin McArthur announced multi-
ple vulnerabilities caused by improper SSL certiﬁcate validation in
PHP software. 17 Affected programs include, among others, os-
Commerce, Ubercart, PrestaShop, and three PayPal SDKs.
Moxie Marlinspike demonstrated several vulnerabilities in cer-
tiﬁcate validation code in browsers and SSL libraries, including the
lack of basic constraint checking (e.g., checking the CA bit) [11]
and incorrect parsing of NULL characters in the “CommonName”
ﬁeld [12]. By contrast, we focus on non-browser software that uses
(mostly) correct SSL libraries incorrectly.
Kaminsky et al. [10] showed that parsing differences between
CA software and browser certiﬁcate validation code can result in a
CA issuing a certiﬁcate that can be used for a man-in-the-middle
attack. By contrast, we investigate certiﬁcate validation bugs in
non-browser clients, not in CA software.
Stevens et al. showed how an attacker can leverage MD5 hash
collisions to get a CA to issue a specially crafted certiﬁcate that is
valid for an ordinary host but whose hash collides with that of a
certiﬁcate for a new, rogue intermediate CA [18]. By contrast, our
attacks do not involve certiﬁcate forgery.
17http://www.unrest.ca/peerjacking
48Several certiﬁcate authorities such as Comodo [5] and DigiNo-
tar [6] were recently compromised and used by attackers to issue
fake certiﬁcates for popular websites. By contrast, our attacks do
not involve CA compromise.
To mitigate the risks of rogue certiﬁcates, Evans et al. proposed
certiﬁcate pinning, i.e., pre-established bindings in the browser be-
tween well-known websites and their certiﬁcates [8]. Certiﬁcate
pinning is not supported by any of the software we analyzed.
Several large-scale studies analyzed HTTPS deployment [7, 22]
and found many errors in SSL certiﬁcates. One of the most com-
mon errors is a mismatch between the server’s fully qualiﬁed do-
main name and certiﬁcate’s identiﬁers. This misconﬁguration alone
does not enable a man-in-the-middle attack.
Chen et al. showed how a malicious proxy can exploit browser
bugs for man-in-the-middle attacks on HTTPS [3]. By contrast, our
attacks do not depend on browser bugs.
Side-channel attacks can extract information from encrypted traf-
ﬁc even when SSL is correctly deployed [4, 19]. By contrast, we
found vulnerabilities that enable a man-in-the-middle attacker to
decrypt SSL trafﬁc, obviating the need for side-channel analysis.
Other side-channel attacks include a timing attack that extracts the
private key from OpenSSL implementations [2].
13. CONCLUSION
The main lesson of this paper is that using SSL in non-browser
software is a surprisingly challenging task. We demonstrated that
even applications that rely on standard SSL libraries such as JSSE,
OpenSSL, GnuTLS, etc. often perform SSL certiﬁcate validation
incorrectly or not at all. These vulnerabilities are pervasive in crit-
ical software, such as Amazon FPS and PayPal libraries for trans-
mitting customers’ payment details from merchants to payment
gateways; integrated shopping carts; Amazon EC2, Rackspace, and
other clients for remote administration of cloud storage and virtual
cloud infrastructure; Chase mobile banking on Android; and many
other popular programs. Their SSL connections are completely in-
secure against a man-in-the-middle attack.
We also presented our recommendations for safer use of SSL in
non-browser software. Future research directions include (1) de-
velopment of better black-box testing and code analysis tools for
discovering errors in SSL connection establishment logic, (2) de-
sign of formal veriﬁcation techniques and programming language
support for automatically checking whether applications use SSL
libraries correctly and not misinterpret the meaning of critical op-
tions and parameters, and (3) design of better APIs for SSL and
other secure networking protocols.
Acknowledgments. This research was partially supported by the
NSF grants CNS-0331640, CNS-0746888, and CNS-0905602, two
Google research awards, Samsung, and the MURI program under
AFOSR Grant No. FA9550-08-1-0352. Boneh also thanks iSEC
partners for helpful conversations about this work.
We acknowledge Amazon, Apache, Chase, GitHub, Lynx, Pay-
Pal, and Rackspace developers for recognizing and promising to
repair the vulnerabilities after they were brought to their attention.
We thank Colm O hEigeartaigh for explaining the intended behav-
ior of certiﬁcate validation in Apache CXF.
References
[1] https should check CN of x509 cert. https://issues.
apache.org/jira/browse/HTTPCLIENT-613.
[2] D. Brumley and D. Boneh. Remote timing attacks are
practical. In USENIX Security, 2003.
[3] S. Chen, Z. Mao, Y.-M. Wang, and M. Zhang.
Pretty-Bad-Proxy: An overlooked adversary in browsers’
HTTPS deployments. In S&P, 2009.
[4] S. Chen, R. Wang, X. Wang, and K. Zhang. Side-channel
leaks in Web applications: A reality today, a challenge
tomorrow. In S&P, 2010.
[5] Comodo report of incident.
http://www.comodo.com/Comodo-Fraud-
Incident-2011-03-23.html, 2011.
[6] Diginotar issues dodgy SSL certiﬁcates for Google services
after break-in.
http://www.theinquirer.net/inquirer/
news/2105321/diginotar-issues-dodgy-ssl-
certificates-google-services-break, 2011.
[7] P. Eckersley and J. Burns. An observatory for the SSLiverse.
In DEFCON, 2010.
[8] C. Evans and C. Palmer. Certiﬁcate pinning extension for
HSTS. http://www.ietf.org/mail-archive/
web/websec/current/pdfnSTRd9kYcY.pdf, 2011.
[9] Fiddler - Web debugging proxy.
http://fiddler2.com/fiddler2/.
[10] D. Kaminsky, M. Patterson, and L. Sassaman. PKI layer
cake: new collision attacks against the global X.509
infrastructure. In FC, 2010.
[11] Moxie Marlinspike. IE SSL vulnerability. http:
//www.thoughtcrime.org/ie-ssl-chain.txt,
2002.
[12] Moxie Marlinspike. Null preﬁx attacks against SSL/TLS
certiﬁcates.
http://www.thoughtcrime.org/papers/null-
prefix-attacks.pdf, 2009.
[13] Internet X.509 public key infrastructure certiﬁcate policy and
certiﬁcation practices framework.
http://www.ietf.org/rfc/rfc2527.txt, 1999.
[14] HTTP over TLS.
http://www.ietf.org/rfc/rfc2818.txt, 2000.
[15] Internet X.509 public key infrastructure certiﬁcate and
certiﬁcate revocation list (CRL) proﬁle.
http://tools.ietf.org/html/rfc5280, 2008.
[16] The Secure Sockets Layer (SSL) protocol version 3.0.
http://tools.ietf.org/html/rfc6101, 2011.
[17] Representation and veriﬁcation of domain-based application
service identity within Internet public key infrastructure
using X.509 (PKIX) certiﬁcates in the context of Transport
Layer Security (TLS).
http://tools.ietf.org/html/rfc6125, 2011.
[18] M. Stevens, A. Sotirov, J. Appelbaum, A. Lenstra,
D. Molnar, D. Osvik, and B. Weger. Short chosen-preﬁx
collisions for MD5 and the creation of a rogue CA
certiﬁcate. In CRYPTO, 2009.
[19] Q. Sun, D. Simon, Y.-M. Wang, W. Russell,
V. Padmanabhan, and L. Qiu. Statistical identiﬁcation of
encrypted Web browsing trafﬁc. In S&P, 2002.
[20] CVE-2009-4831. http://cve.mitre.org/cgi-
bin/cvename.cgi?name=CVE-2009-4831, 2009.
[21] J. Viega and M. Messier. Secure Programming Cookbook for
C and C++. O’Reilly Media, 2007.
[22] N. Vratonjic, J. Freudiger, V. Bindschaedler, and J.-P.
Hubaux. The inconvenient truth about Web certiﬁcates. In
WEIS, 2011.
[23] R. Wang, S. Chen, X. Wang, and S. Qadeer. How to shop for
free online – Security analysis of cashier-as-a-service based
Web stores. In S&P, 2011.
49