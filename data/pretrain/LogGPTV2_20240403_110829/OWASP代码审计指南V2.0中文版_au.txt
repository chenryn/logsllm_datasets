天，为用户 2 的密码创建彩虹表需要 10 天，等等。如果有 100，000 个用户，现在是 100，
000 x 10 天= 1，000，000 天或 2738 年，为所有用户创建彩虹表。 
可以看出，盐不需要保密，因为每个用户都使用独特的盐这一事实减缓了攻击者的速度。 
表:盐的使用和相关指纹 
哈希“password”字符的方
法 
结果 
不加盐 
B109F3BBBC244EB82441917ED06D618B9008DD09B3 
BEFD1B5E07394C706A8BB980B1D7785E5976EC049B 
46DF5F1326AF5A2EA6D103FD07C95385FFAB0CACBC86 
Salt = ‘WindowCleaner’ 
E6F9DCB1D07E5412135120C0257BAA1A27659D41DC7 
7FE2DE4C345E23CB973415F8DFDFFF6AA7F0AE0BDD 
61560FB028EFEDF2B5422B40E5EE040A0223D16F06F 
Salt 
= 
‘ a0w8hsdfas8ls587uas8
7’ 
5AA762E7C83CFF223B5A00ADA939FBD186C4A2CD01 
1B0A7FE7AF86B8CA5420C7A47B52AFD2FA6B9BB172 
22ACF32B3E13F8C436447C36364A5E2BE998416A103A 
Salt 
= 
‘8ash87123klnf9d8dq3w
’ 
8058D43195B1CF2794D012A86AC809BFE73254A82C8C 
E6C10256D1C46B9F45700D040A6AC6290746058A63E5 
0AAF8C87ABCD5C3AA00CDBDB31C10BA6D12A1A7 
生成盐值的一种方法是使用伪随机数生成器，如下例 12.4 所示。 
示例： 
private int minSaltSize = 8; 
195 
private int maxSaltSize = 24; 
private int saltSize; 
private byte[] GetSalt(string input) { 
byte[] data; 
byte[] saltBytes; 
RNGCryptoServiceProvider rng = new RNGCryptoServiceProvider(); 
saltBytes = new byte[saltSize]; 
rng.GetNonZeroBytes(saltBytes); 
data = Encoding.UTF8.GetBytes(input); 
byte[] dataWithSaltBytes = new byte[data.Length + saltBytes.Length]; 
for (int i = 0; i  
C# Code: 
1: preferredHash = HashAlgorithm.Create((string)ConfigurationManager.AppSettings[“HashMethod”]); 
2: 
3: hash = computeHash(preferredHash, testString); 
4: 
5: private string computeHash(HashAlgorithm myHash, string input) { 
6: byte[] data; 
7: data = myHash.ComputeHash(Encoding.UTF8.GetBytes(input)); 
8: sb = new StringBuilder(); 
9: for (int i = 0; i < data.Length; i++) { 
10: sb.Append(data[i].ToString(“x2”)); 
11: } 
12: return sb.ToString(); 
13: } 
第 1 行让我们从配置文件中获取将要使用的哈希算法。如果我们使用机器配置文件，
197 
我们的实现将是服务器范围的，而不是应用程序特定的。 
第 3 行允许我们使用配置值，并根据我们选择的散列函数进行设置。计算机散列可能
是 SHA-256 或 SHA-512。 
3.6.5.3 参考 
⚫ 
http://valerieaurora.org/hash.html (Lifetimes of cryptographic hash functions) 
⚫ 
http://docs.oracle.com/javase/6/docs/api/java/security/SecureRandom.html 
⚫ 
http://msdn.microsoft.com/en-us/library/system.security.cryptography.rngcry
ptoserviceprovider.aspx 
⚫ 
http://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf 
⚫ 
弗格森和施奈尔(2003)实用密码学(见第 6 章；第 6.2 节实散列函数) 
3.6.6 减小攻击面 
应用程序的攻击面是对进入/退出点、用户的角色/权限以及应用程序中保存的数据的敏
感性的描述。例如，登录、HTML 表单、文件上传屏幕等入口点都会给应用程序带来一定
程度的风险。请注意，代码结构也是攻击面的一部分，因为代码审计身份验证或加密等，由
应用程序上的关键功能执行。 
198 
3.6.6.1 描述 
软件环境的攻击面是对攻击者试图操纵应用程序的入口点的描述，它通常采用系统图的
形式，指出所有的入口点(接口)。 
迈克尔·霍华德(在微软)和其他研究人员开发了一种方法，用于测量应用程序的攻击面，
并跟踪攻击面随时间的变化，称为相对攻击面商(RSQ)。 
假设应用程序攻击面已经为人所知，可能是通过以前的威胁建模练习或架构风险分析得
到。这样，入口点和出口点是已知的，应用程序中数据的敏感性是可以理解的，并且系统的
各种用户及其权利已经被映射到相关的功能和数据。 
从代码审计的角度来看，目标是确保被审计的变更不会不必要地增加攻击面。比如以前
只用 HTTPS 的地方是不是突然用 HTTP 改代码了？编码者是否决定编写他们自己的散列函
数，而不是使用预先存在的(并且经过很好的练习/测试的)加密函数中央存储库？在某些开
发环境中，如果捕获了攻击面的细节，可以在设计阶段审计攻击面的变化，但是在代码审计
时，实际的实现会反映在代码中，并且可以识别这种攻击面暴露的情况。 
您还可以通过扫描应用程序来构建攻击面的 sitemap。对于网络应用程序，您可以使用
OWASP Zed 攻击代理项目(ZAP)、Arachni、Skipfish、w3af 等工具或许多商业动态测试
和漏洞扫描工具或服务之一来抓取您的应用程序，并映射可通过网络访问的应用程序部分。
一旦你有了攻击面的 sitemap，确定高风险区域，然后了解你有什么补偿控制可以实施。 
请注意，代码和数据的备份(在线和离线介质上)是系统攻击面的一个重要部分，但经常
被忽略。通过编写安全软件和强化基础架构来保护您的数据和知识产权，如果您不保护您的
199 
备份，将一切都交给坏人，这将是徒劳的。 
3.6.6.2 审计什么 
从攻击面的角度查看代码模块时，需要注意的一些常见问题包括: 
⚫ 
代码变更是否改变了攻击面？通过将更改应用到应用程序的当前攻击面，它会打开
新端口还是接受新输入？如果是这样的话，可以在不增加攻击面的情况下进行改变
吗？如果存在更好的实现，那么应该建议这样做，但是如果没有办法在不增加攻击
面的情况下实现代码，请确保企业知道增加的风险。 
⚫ 
该功能是否不必要地使用超文本传输协议而不是 HTTPS？ 
⚫ 
该功能是否可供未经身份验证的用户使用？如果调用函数不需要身份验证，那么攻
击者使用该接口的风险就会增加。该函数是否调用了一个后端任务，该任务可用于
拒绝向其他合法用户提供服务？ 
◼ 
例如。如果该函数写入文件，或发送短信，或导致 CPU 密集型计算，攻击者
能否编写一个脚本来每秒调用该函数多次，并阻止合法用户访问该任务？ 
⚫ 
搜索是否受到控制？搜索是一项有风险的操作，因为它通常会查询数据库中的某些
条件并返回结果，如果攻击者能够将 SQL 注入到查询中，那么他们可能会访问比
预期更多的数据。 
⚫ 
重要数据是否与琐碎数据分开存储(数据库、文件存储等)。该更改是否允许未经身
份验证的用户在与用户名/密码表位于同一分区的数据库表中搜索公开可用的存储
位置？该存储位置数据是否应该放入不同的数据库或不同的分区，以降低数据库信
息的风险？ 
200 
⚫ 
如果文件上传被允许，它们是否被认证？有限速吗？每个用户的每次上传或聚合都
有最大文件大小吗？应用程序是否将文件上传限制为特定类型的文件(通过审计
MIME 数据或文件后缀)。应用程序将运行病毒审计吗？ 
⚫ 
如果您的管理用户拥有高权限，他们的操作是否以这样的方式记录/跟踪: 
◼ 
不能擦除/修改日志， 
◼ 
不能拒绝他们的操作？ 
◼ 
是否有任何警报或监控来发现他们是否访问了不应访问的敏感数据？这可能
适用于所有类型的用户，而不仅仅是管理员。 
⚫ 
变更是否与现有对策或安全代码兼容，或者是否需要开发新的代码/对策？ 
⚫ 
该变更是否试图引入一些非集中式安全代码模块，而不是重用或扩展现有的安全模
块？ 
⚫ 
该变更是否增加了不必要的用户级别或权限，从而使攻击面复杂化。 
⚫ 
如果变更存储的是 PII 或机密数据，所有新信息都是绝对必要的吗？如果数据从未
被使用过，那么通过存储数百万人的社会安全号码来增加应用程序的风险几乎没有
价值。 
⚫ 
应用程序配置是否会导致攻击面因配置设置的不同而有很大差异，当攻击面扩展时，
该配置是否易于使用并提醒管理员？ 
⚫ 
是否可以以不同的方式进行更改，以减少攻击面，即不是使帮助项目可搜索并将帮
助项目文本存储在主用户名/密码存储旁边的数据库表中，而是在 HTML 页面上提
供静态帮助文本，通过“帮助”界面降低风险。 
201 
⚫ 
客户机上存储的信息是否应该存储在服务器上？ 
3.6.6.3 参考 
⚫ 
https://www.owasp.org/index.php/Attack_Surface_Analysis_Cheat_Sheet 
⚫ 
https://www.owasp.org/index.php/OWASP_Zed_Attack_Proxy_Project 
⚫ 
http://www.cs.cmu.edu/~wing/publications/Howard-Wing03.pdf 
3.7 A7 缺失功能级别访问控制 
大多数网络应用程序在用户使用功能之前，验证该用户是否有功能级访问权限。但是，
当访问每个功能时，应用程序需要在服务器上执行相同的访问控制审计。如果请求未经验证，
攻击者将能够伪造请求，以便在没有适当授权的情况下访问功能。 
3.7.1 授权 
授权和认证一样重要。应授权访问应用程序功能和所有数据。对于数据访问授权，应用
程序逻辑应该审计数据是否属于经过身份验证的用户，或者用户是否应该能够访问该数据。 
安全审计的设置是应用程序设计中一个重要的审计领域。不正确的设置会使应用的安全
控制变得无用，因此审计应用程序设计并确定此类审计的正确性非常重要。许多网络应用程
序设计都是基于模型-视图-控制器(MVC)的概念，它有一个中央控制器，可以监听所有传入
的请求，并将控制委托给适当的表单/业务流程逻辑。最终，用户会看到一个视图。在这种
分层设计中，当有许多实体参与处理一个请求时，开发人员可能会错误地将安全控件放置在
不正确的位置，例如，一些应用程序开发人员认为“视图”是进行授权审计的正确位置。 
202 
授权问题覆盖了 web 应用程序中的许多层；从用户在应用层获得应用程序特定功能的
功能授权，到持久层的数据库访问授权和最低特权问题。 
在大多数应用程序中，请求参数或网址是决定处理逻辑的唯一因素。在这种情况下，请
求中用于这种标识的元素可能会受到操纵攻击，以获得对应用程序中受限资源或页面的访问。 
实现授权有两种主要的设计方法:基于角色的访问控制(RBAC)和访问控制列表(ACL)。
RBAC 是指为用户分配特定角色，然后为角色分配权限。它是对实际系统授权的更符合逻辑