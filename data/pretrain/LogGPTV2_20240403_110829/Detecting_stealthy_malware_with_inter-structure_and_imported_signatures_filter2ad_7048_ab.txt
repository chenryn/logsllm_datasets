found that there exist 35 kernel hooks in the kernel-side
execution path of ls that can be potentially hijacked for ma-
nipulation. Similarly, there are 85 kernel hooks for ps and 51
kernel hooks for netstat, which can be respectively hooked
for hiding processes and network activities. It is tedious to
detect potential malicious attacks by monitoring so many
hook points.
File-signature based detection is a classical method in the
area of virus detection, which has repeatedly been proposed
to identify particular classes of security threats. Some rootk-
it detectors [2][5] employ this method to scan system (cid:12)les for
a sequence of bytes that comprise a (cid:12)ngerprint which is u-
nique to a particular rootkit. This method is simple and
e(cid:11)ective. But due to its dependence on the prior knowl-
edge of the known malware, it lacks of the ability to defend
against unknown or mutative malwares.
Another area of related work is using virtual machine
monitor (VMM) to provide a high resistance to attacks from
inside the system. The advantage of VMM-based detection
is that it has the higher privilege over kernel-targeted mal-
wares, which the traditional host-based anti-malware sys-
tems limit in. Since Gar(cid:12)nkel et al.
[13] introduced the
VMM-based intrusion detection system and VM introspec-
tion technique, it is widely adopted by researchers to detect
and analyze intrusions. In some works [19][22], VMM is used
to guarantee the integrity of executed kernel code. This pre-
vention technique monitors the execution of kernel code in
the hypervisor level, and only allows the authorized code to
be run in the kernel’s address space. Besides, some research-
es introduce the cross-view based detection into hypervisor
level. VMwatcher [14] captures a process when the control-
register CR3 changes, that means it could only discover the
process at the moment it enters running state, and could
not gain the information of all the existing processes at a
time. Lycosid [15] uses statistical inference techniques to
obtain the trusted view. Due to the limitation of statistical
method, the low-level view Lycosid gets is just more reliable
but not accurate.
VMM technique is also used to protect some essential ker-
nel data. Rhee et al. [18] implemented a system to monitor
kernel memory access using VMM-based policies in QEMU
[4], adopting memory access control in the hypervisor lev-
el to protect the essential kernel data. Wang et al.
[26]
relocated some important kernel hooks to a dedicated page-
aligned memory space and then regulate accesses to them
with a monitor in XEN hypervisor. In this paper, we also
employ VMM technique to protect the integrity of imported
signatures.
3. METHODOLOGY
The process of the signature-based scanning method is
219
KernelMemoryPool SignatureMemory Block Size FrameObjectshown in Figure 1.
In the (cid:12)rst place, a scanner fetches a
block of memory from kernel memory pool according to a
size frame of target object data structure. Then, the scanner
will check whether the content of the memory block matches
a signature. If so, the memory block will be regarded as a
desired object data structure, and the information about the
corresponding object can be extracted from it.
To reach the goal, scanning signatures must meet the fol-
lowing two requirements:
1) They must have enough discriminating power to dis-
tinguish object data structures without high false pos-
itives.
2) It is impossible for adversaries to evade them without
breaking the functions of target objects and operating
system.
An e(cid:11)ective signature must meet both of the above two
requirements. The (cid:12)elds that only meet one of them cannot
act as an e(cid:11)ective signature. For example, there are many
pointer (cid:12)elds in Linux kernel data structures; they point
to some operation handles or other data structures. These
(cid:12)elds are commonly closely related to the functions of their
host objects. Attempting to modify them will break the nor-
mal operations of the host objects or crash the whole sys-
tem. However, the values of these pointers are variable with
regards to di(cid:11)erent object states or kernel versions. The
only invariant can be deduced from them is that the values
of these pointers are kernel-space addresses. Based on the
property, a scanner cannot obtain desired data structures
without high false positives. On the contrary, the type, size,
and state (cid:12)elds of kernel data structures are often compar-
atively static. For example, the state (cid:12)eld of the Linux pro-
cess descriptor (task struct) describes the current condition
of a process, and it may possesses one of (cid:12)ve possible (cid:13)ags
(TASK INTERRUPTIBLE, TASK UNINTERRUPTIBLE,
TASK RUNNING, TASK STOPPED and TASK ZOMBIE )
to indicate the process’s state. As another example, the
size of struct (cid:12)eld of Linux module structure holds the size
of the data structure. The invariants deduced from these
(cid:12)elds can e(cid:11)ectively identify speci(cid:12)c kernel data structures.
But, adversaries can modify the values of these (cid:12)elds to e-
vade scanning without a(cid:11)ecting the normal operations of
system.
In the rest of this section, we take Linux kernel 2.6 as ex-
ample to describe two new kinds of signatures and give four
invariants to detect stealthy malware. Because some real-
world rootkits employ version-dependent attack techniques,
they cannot work in the newest version kernel. Without
loss of generality, we choose kernel 2.6.9 (Redhat AS4) as
the target platform.
3.1 Inter-structure Signatures
Not every kernel data structure has ideal (cid:12)elds meeting
the above two requirements at the same time. To some
kernel data structures, we cannot deduce e(cid:11)ective signatures
from them directly. To this end, we try discover some cross-
reference relationships to generate robust signatures.
3.1.1 Sockets
Sockets are a common target for attackers to hide to con-
ceal malicious communications. In Linux, the socket data
structure is used to describe network socket objects. As
Figure 2: Linux socket and socket alloc structure.
shown in Figure 2 (a), the socket data structure of Linux
kernel 2.6.9 is very simple. It consists of nine (cid:12)elds. Among
them, state, (cid:13)ags, type, and passcred (cid:12)elds meet the (cid:12)rst
requirement but do not meet the second one. We can do
a simple experiment to demonstrate this. An experimental
LKM is designed to clear these (cid:12)elds of a connected SSH
socket data structure. After clearing them, we can still ac-
cess a remote server correctly via the SSH connection. On
the contrary, ops, fasync list, (cid:12)le, sk, and wait (cid:12)elds meet
the second requirement but not the (cid:12)rst.
According to the above analysis, we can see that no appro-
priate (cid:12)elds can act as signatures in the socket data struc-
ture. In other words, it is impossible to generate an e(cid:11)ective
signature from a single data structure (intra-structure) for
scanning socket objects. We need to extend the scope of
choice to (cid:12)nd an e(cid:11)ective signature.
In Linux kernel, there are many pointer (cid:12)elds in kernel
data structures, which point to some operation handles or
other data structures. When a pointer (cid:12)eld of a data struc-
ture points to a related data structure; a pointer (cid:12)eld of
the related data structure may also point to the source data
structure directly or indirectly. These (cid:12)elds construct a kind
of cross-reference relationship of related data structures. If
the cross-reference relationship re(cid:13)ects an invariant about
target objects that satis(cid:12)es both of the two requirements, it
can be used as an e(cid:11)ective signature. Compared with the
signatures from (cid:12)elds in a single data structure, this kind of
signature involves multiple related data structures. We call
it as inter-structure signature.
As shown in Figure 2 (b), in Linux kernel 2.6.9, a socket
data structure exists as a (cid:12)eld of socket alloc data struc-
ture. The socket alloc data structure is an item of a cache
that stores pairs of socket and its virtual (cid:12)le system inode
(vfs inode).
With regard to the socket data structure, its ops, (cid:12)le, sk,
fasync list, and wait (cid:12)elds are used to point to some relat-
ed data structures. Among them, the (cid:12)le (cid:12)eld points to a
(cid:12)le descriptor ((cid:12)le). The (cid:12)le descriptor is an interface for
applications to manipulate sockets. In a (cid:12)le data structure,
a pointer (cid:12)eld f dentry points to a dentry data structure.
Subsequently, a (cid:12)eld d inode of the dentry data structure
220
struct socket{        socket_state            state;         unsigned long           flags;         struct proto_ops        *ops;         struct fasync_struct    *fasync_list;         struct file             *file;         struct sock             *sk;         wait_queue_head_t       wait;         short                   type;         unsigned char           passcred; };(a)struct socket_alloc {struct socket socket; struct inode vfs_inode; };(b)Figure 6:
for
thread info data structures.
Invariant
the task struct
and
Figure 7: Invariant for the socket alloc data struc-
ture based on the relationship between processes
and sockets.
However, there are only a few (cid:12)elds can be used to iden-
tify it, such as state and pids. Unfortunately, these (cid:12)elds
do not meet the second requirement, i.e., they can be modi-
(cid:12)ed arbitrarily without breaking the operations of the target
process. We design an experimental LKM to modify these
(cid:12)eld of a task struct data structure to invalid values. After
modifying them, the target process still run correctly.
Similar to socket objects, the process objects can be ex-
plored using an inter-structure signature. As shown in Fig-
ure 5, there is a thread info data structure stored in the ker-
nel space stack of the process in Linux kernel 2.6.9; the task
(cid:12)eld of the data structure is a pointer to the process’s actual
task struct data structure. At the same time, the thread info
pointer (cid:12)eld of a task struct data structure points to its
thread info data structure conversely. The cross-reference
relationship is closely related to the operations of processes;
breaking it will lead to system crash. On the other hand, us-
ing the relationship can e(cid:11)ectively identify task struct data
structures. Thus, we can infer an invariant shown in Figure
6 for scanning process objects.
During scanning, scanner can fetch all possible process k-
ernel stack memory block and check whether its end part
matches the invariant about thread info. If it does, the cor-
responding taks struct data structure can be obtained from
its task pointer.
After getting all task struct data structures, there is an-
other way to deduce all socket data structures.
In Linux
kernel, a socket usually belongs to a process as an open (cid:12)le.
The (cid:12)les (cid:12)eld of task struct is a pointer to a struct (cid:12)les da-
ta structure used to store open (cid:12)les information. We can
reference an open (cid:12)le via a (cid:12)le descriptor array (fd array)
in struct (cid:12)les. Based on Invariant 1, we can get another
invariant about socket objects.
A scanner can collect all open (cid:12)le descriptors from ob-
tained task struct list and check one by one using Invariant
3. If a socket alloc data structure can be deduced from a (cid:12)le
descriptor, the scanner will (cid:12)nd a possible socket object.
Figure 3: A relationship of multiple socket related
data structures.
Figure 4: Invariant for the socket alloc data struc-
ture.
should point to the vfs inode (cid:12)eld of a socket alloc data
structure that consists of the source socket data structure
and its virtual (cid:12)le system inode. The relationship of above
data structures is shown in Figure 3. An invariant shown in
Figure 4 can be inferred as a signature from the relationship.
Using the above invariant, we can enumerate all socket
objects in a target Linux system. At the (cid:12)rst step, a scan-
ner will search kernel cache memory to get all socket alloc
data structures based on the invariant. Then, a socket data
structure can be easily collected as a (cid:12)eld of the socket alloc
data structure.
Although we take the socket data structure as an example
to introduce inter-structure signatures, we are sure that the
concept can be applied to other data structures.
3.1.2 Processes
In Linux kernel, the task struct data structure represents
a process of system. The task struct data structure is a
relatively complex data structure and contains many (cid:12)elds.
Figure 5: A relationship between the task struct and
thread info data structures.
221
socket_allocsocket vfs_inode dentry file file f_dentry d_inode Invariant 1: for a socket_alloc data structure sa:(sa.socket)->file->f_dentry->d_inode points to sa.vfs_inodetask_struct thread_info thread_info taskProcess kernel stackthread_info data structures. Invariant 2: for a task_struct data structure t:(t.thread_info)->task points to tOr for a thread_info data structure th:(th.task)->thread_info points to thInvariant 3: for each socket_alloc data structure sa, there exist a task_struct data structure t and a file data structure f,such that: (cid:120)f(cid:143) (t.files)->fd_array, and (cid:120)(f.f_dentry)->d_inode points to sa.vfs_inode, and (cid:120)(sa.socket)->file points to fAccording to the above experiment results, it is con(cid:12)rmed
that no (cid:12)elds of the module data structure can be used as
either an e(cid:11)ective signature or a part of an inter-structure
signature. To detect hidden LKMs in Linux, we need intro-
duce some extra information into memory regions attached
to module structures as an e(cid:11)ective signature. We call this
kind of extra information as imported tag.
Adding some distinctive data in the module data structure
is a natural and direct way to import signatures. However,
this way is not robust enough to counter evasion attacks.
Essentially, the imported tags are the same with those orig-
inal (cid:12)elds from the viewpoint of attackers. Adversaries can
trivially evade this kind of signatures by modifying the im-
ported tags to some malformed values. Especially, a kernel
mode rootkit, as a part of OS kernel, has enough power to do
this. A possible improvement of this way is relating the im-
ported tags with some elementary functions of LKMs, e.g.,
calling the code provided by LKM. As results, adversaries
tampering with the imported tags will break the elementary
functions of LKMs or lead to system crash. But it is very
troublesome to change the operation logic of the operating
system kernel. Besides, the change to kernel is platform-
dependent.
A more feasible choice is to protect the imported tags
from being modi(cid:12)ed. Unfortunately, this kind of protection
requires byte-level granularity while modern hardware plat-
forms can only provide page-level protection. The tags in a
data structure will be co-located together with original (cid:12)elds
that may be written during the lifecycle of target objects.
Because they may be located in the same page, it is improp-
er and unadvisable to protect imported tags and writable
original (cid:12)elds with the same access control permission (read
only).
To bridge the protection granularity gap, we can place
the imported tags to a dedicated page-aligned memory area
and co-locate them together with some data of the same
nature. Consequently, the imported tags can be protected
from being tampered based on hardware protection mech-
anism. Some identi(cid:12)cation information can be introduced
in the tags to identify and refer target objects, and can be
used as an e(cid:11)ective signature. We call these identi(cid:12)cation
information as imported signature.
In Linux kernel, the code and data of an LKM will be load-
ed into some kernel space memory. They can be referenced
using the module core (cid:12)eld of the module data structure.
The text section of LKM is an optional place to store the
imported tags. It is a natural way to protect imported tags
and the code of LKM from being written. But it will incur a
code relocation problem due to the e(cid:11)ect to the layout of the
code. To avoid the troublesome code relocating, we add a
new page prior to the text section to place the imported tags
when loading an LKM. This page will be set to read-only
to avoid malicious tampering. We call the page as signature
page. As shown in Figure 8, a distinctive tag for scanning
(DTS) and a pointer to reference corresponding module data
structure (RP) are stored in the page. Besides, some static
(cid:12)elds of the module data structure (SF) are also stored to
check the integrity of the data structure. Accordingly, we
can infer an invariant shown in Figure 9 for scanning module
objects.
Scanner can traverse the kernel page memory to get the
information via checking whether there is a DTS in current
memory page. A page containing DTS will be regarded as a
Figure 8: An imported signature for the module data
structure.
Figure 9: Invariant for the module data structure.
3.2 Imported Signatures
For some objects, all (cid:12)elds of their data structures are
hardly relevant to their functions or operations of the whole
system. The related operations still are normal even after
all (cid:12)elds are modi(cid:12)ed arbitrarily.