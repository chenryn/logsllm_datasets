计算得到了256个数，但是由于其中有的数是重复的，所以可以缩小Z的取值范围。拿到了Z之后，就可以推导出对应的Y，由于O是已知的，所以可以推出密钥或者缩小密钥的范围。
那么`2Z`和`3Z`怎么计算？
这里的2,3与Z的关系是有限域中的乘法，所以计算求Z的时候，并不是简单的除一下就行了，而是域中的计算。需要涉及到生成多项式`0x11B`求逆元的计算。(推荐一本书，密码编码学与网络安全—原理与实践-第六版，写的很好。)
## 实践操作
我没有像[参考文章](https://bbs.pediy.com/thread-254042.htm)一样用`frida`和`idapython`去做，这样不太灵活。我使用了`unicorn`
引擎，一般来说，白盒AES算法都会被封装在一个或者连续的几个函数中，这样对于`Unicorn` 是十分方便的。
我的目标没有选择上文中的`wbDES`，它太老了，而且DES的使用越来越少，我也没有使用参看文献中的基于`OLLVM`的实现，因为`OLLVM`混淆之后的AES也不是严格意义上的白盒，我选用了CHES
2016 CTF上的一道题。
首先对程序使用`GDB`进行分析，发现程序的`main`函数主要是获取输入和输出，加密过程`chow_aes3_encrypt_wb`函数中，在`chow_aes3_encrypt_wb`下断点。
**_(注：我没有使用github中提供的Shared object文件，而是使用源码，在makefile中添加了-no-pie参数，重新编译了一个executable文件)_**
之后在函数的执行结束的位置下断点。
发现程序使用`RSI`和`RDI`进行传参，`RSI`保存的指针是输出缓冲区，`RDI`保存的指针是函数输出数据的位置。
之后开始栈空间的构建，具体构建的方法和调试请参考上一篇文章。
有错误注入攻击，一定需要能量分析攻击，在针对芯片的攻击中，SPA和DPA可以提供攻击位置信息，针对白盒的攻击也差不多，白盒的实现是针对查找表实现的，所以我们首先需要打印出来所有内存读的位置，这也是为了后续的攻击做准备。在hook中添加筛选条件：
    if access == UC_MEM_READ and size == 1 and address
[2]
ps：如果你对小米安全中心有任何建议，可通过QQ：3022560938联系我们