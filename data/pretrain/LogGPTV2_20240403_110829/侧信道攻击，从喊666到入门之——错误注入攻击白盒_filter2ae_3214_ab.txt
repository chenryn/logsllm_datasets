### 优化后的文本

在计算过程中，我们得到了256个数。由于其中存在重复值，因此可以缩小变量Z的取值范围。一旦确定了Z的值，就可以推导出对应的Y值。已知O的情况下，可以进一步推导出密钥或缩小密钥的可能范围。

对于`2Z`和`3Z`的计算，在有限域中的乘法操作并不等同于普通的算术乘法。具体来说，这里的2和3与Z之间的运算需要在有限域中进行，而不仅仅是简单的除法。这种计算通常涉及到生成多项式`0x11B`的逆元求解过程。关于这一主题，我推荐《密码编码学与网络安全—原理与实践》第六版作为参考书籍，该书对此有详细且清晰的解释。

## 实践操作

在实际操作中，我没有采用[参考文章](https://bbs.pediy.com/thread-254042.htm)中提到的`Frida`和`IdaPython`工具，因为它们在某些情况下不够灵活。相反，我选择了使用`Unicorn`引擎来进行实验。通常，白盒AES算法会被封装在一个或几个连续的函数内，这对利用`Unicorn`来说非常方便。

我的研究对象并不是上述文献中的`wbDES`（它过于陈旧，并且DES算法的应用正逐渐减少），也不是基于`OLLVM`混淆后的AES实现（这并不能被视为真正意义上的白盒）。我选择了一个来自CHES 2016 CTF比赛的问题作为案例分析。

首先，我使用`GDB`对程序进行了初步分析，发现主要加密逻辑位于`chow_aes3_encrypt_wb`函数中。在这个函数入口处设置断点后继续调试。值得注意的是，我没有直接使用GitHub提供的共享库文件，而是根据源代码并添加了`-no-pie`参数重新编译了一个可执行文件。

接着，在函数执行完毕的位置也设置了断点。通过观察得知，程序通过`RSI`寄存器传递输出缓冲区指针，而`RDI`则用于指向输入数据的位置。接下来是构建栈空间的过程，有关这部分的具体步骤及调试技巧，请参阅先前的文章。

当考虑针对此类系统的错误注入攻击时，往往还需要结合侧信道攻击技术，如SPA（简单功耗分析）和DPA（差分功耗分析），以获取更准确的攻击点信息。对于白盒实现而言，其核心在于查找表的设计，因此我们需要记录下所有内存读取操作发生的地址。为此，在hook函数中增加了如下筛选条件：
```python
if access == UC_MEM_READ and size == 1:
    # 执行相应处理
```

最后，如果您对小米安全中心有任何建议或意见，欢迎通过QQ: 3022560938联系我们。