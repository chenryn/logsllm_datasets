Peterson, and Aviel D. Rubin.
Self-protecting
electronic medical records using Attribute-Based
Encryption. Cryptology ePrint Archive, Report
2010/565, 2010. Available from http://eprint.
iacr.org/.
[4] Giuseppe Ateniese, Kevin Fu, Matthew Green, and
Susan Hohenberger. Improved proxy re-encryption
schemes with applications to secure distributed
storage. In NDSS, pages 29–43, 2005.
[5] Amos Beimel. Secure Schemes for Secret Sharing
and Key Distribution. PhD thesis, Israel Institute of
Technology, Technion, Haifa, Israel, 1996.
[6] John Bethencourt.
Ciphertext-policy attribute-
based encryption library. Available from http:
//acsc.cs.utexas.edu/cpabe, May 2010.
[7] John Bethencourt, Amit Sahai, and Brent Waters.
Ciphertext-policy attribute-based encryption.
In
IEEE Symposium on Security and Privacy, pages
321–334, 2007.
[8] Matt Blaze, Gerrit Bleumer, and Martin Strauss.
Divertible protocols and atomic proxy cryptogra-
phy. In EUROCRYPT, pages 127–144, 1998.
[9] Dan Boneh and Xavier Boyen. Efﬁcient selective-
id secure identity-based encryption without random
oracles. In EUROCRYPT, pages 223–238, 2004.
[10] Dan Boneh, Giovanni Di Crescenzo, Rafail Ostro-
vsky, and Giuseppe Persiano. Public key encryp-
tion with keyword search. In EUROCRYPT, pages
506–522, 2004.
[11] Dan Boneh, Amit Sahai, and Brent Waters. Func-
In
tional encryption: Deﬁnitions and challenges.
TCC, pages 253–273, 2011.
[12] Dan Boneh and Brent Waters. Conjunctive, subset,
and range queries on encrypted data. In TCC, pages
535–554, 2007.
[13] Ran Canetti, Hugo Krawczyk, and Jesper Buus
In
Nielsen. Relaxing chosen-ciphertext security.
CRYPTO, pages 565–582, 2003.
[14] Melissa Chase. Multi-authority attribute based en-
cryption. In TCC, pages 515–534, 2007.
[15] Melissa Chase and Sherman S. M. Chow.
Im-
proving privacy and security in multi-authority
In ACM Conference
attribute-based encryption.
on Computer and Communications Security, pages
121–130, 2009.
[16] Benoˆıt Chevallier-Mames, Jean-S´ebastien Coron,
Noel McCullagh, David Naccache, and Michael
Scott. Secure delegation of elliptic-curve pairing.
In CARDIS, pages 24–35, 2010.
[17] Kai-Min Chung, Yael Kalai, and Salil P. Vadhan.
Improved delegation of computation using fully ho-
In CRYPTO, pages 483–
momorphic encryption.
501, 2010.
[18] Eiichiro Fujisaki and Tatsuaki Okamoto. Secure
integration of asymmetric and symmetric encryp-
tion schemes. In CRYPTO ’99, volume 1666, pages
537–554, 1999.
[19] Taher El Gamal. A public key cryptosystem and a
signature scheme based on discrete logarithms. In
CRYPTO, pages 10–18, 1984.
[20] Rosario Gennaro, Craig Gentry, and Bryan Parno.
Non-interactive veriﬁable computing: Outsourcing
In CRYPTO,
computation to untrusted workers.
pages 465–482, 2010.
[21] Craig Gentry. Fully homomorphic encryption using
ideal lattices. In STOC, pages 169–178, 2009.
[22] Craig Gentry and Shai Halevi. Implementing Gen-
In
try’s fully-homomorphic encryption scheme.
EUROCRYPT, pages 129–148, 2011.
[23] Vipul Goyal, Abishek Jain, Omkant Pandey, and
Amit Sahai. Bounded ciphertext policy attribute-
based encryption. In ICALP, pages 579–591, 2008.
[24] Vipul Goyal, Omkant Pandey, Amit Sahai, and
Brent Waters. Attribute-based encryption for ﬁne-
grained access control of encrypted data. In ACM
Conference on Computer and Communications Se-
curity, pages 89–98, 2006.
[25] Matthew Green, Ayo Akinyele, and Michael
Rushanan.
libfenc: The Functional Encryption
Library. Available from http://code.google.
com/p/libfenc.
[26] Matthew Green, Susan Hohenberger, and Brent
Waters. Outsourcing the decryption of ABE cipher-
texts, 2011. The full version of this paper is avail-
able from the Cryptology ePrint Archive.
[27] Jonathan Katz, Amit Sahai, and Brent Waters.
Predicate encryption supporting disjunctions, poly-
In EURO-
nomial equations, and inner products.
CRYPT, pages 146–162, 2008.
[28] Allison Lewko, Tatsuaki Okamoto, Amit Sahai,
Katsuyuki Takashima, and Brent Waters. Fully
secure functional encryption: Attribute-based en-
cryption and (hierarchical) inner product encryp-
tion. In EUROCRYPT, pages 62–91, 2010.
[29] Allison Lewko, Yannis Rouselakis, and Brent Wa-
ters. Achieving leakage resilience through dual sys-
tem encryption. In TCC, pages 70–88, 2011.
[30] Ben Lynn. The Stanford Pairing Based Crypto
Available from http://crypto.
Library.
stanford.edu/pbc.
[31] Jonathan M. McCune, Yanlin Li, Ning Qu, Zong-
wei Zhou, Anupam Datta, Virgil D. Gligor, and
Adrian Perrig. TrustVisor: Efﬁcient TCB Reduc-
tion and Attestation. In IEEE Symposium on Secu-
rity and Privacy, pages 143–158, May 2010.
[32] Jonathan M. McCune, Bryan Parno, Adrian Perrig,
Michael K. Reiter, and Arvind Seshadri. Minimal
In IEEE
tcb code execution (extended abstract).
Symposium on Security and Privacy, pages 267–
272, 2007.
[33] Elinor Mills. Chrome OS security: ’Sandboxing’
and auto updates. eWeek., 2009.
[34] Subhas C. Misra and Virendra C. Bhavsar. Rela-
tionships between selected software measures and
latent bug-density: guidelines for improving qual-
ity. In ICCSA’03, pages 724–732, 2003.
[35] Tatsuaki Okamoto and Katsuyuki Takashima. Fully
secure functional encryption with general relations
from the decisional linear assumption. In CRYPTO,
pages 191–208, 2010.
[36] Rafail Ostrovsky, Amit Sahai, and Brent Waters.
Attribute-based encryption with non-monotonic ac-
In ACM Conference on Com-
cess structures.
puter and Communications Security, pages 195–
203, 2007.
[37] Matthew Pirretti, Patrick Traynor, Patrick Mc-
Daniel, and Brent Waters. Secure attribute-based
In ACM Conference on Computer and
systems.
Communications Security, pages 99–112, 2006.
[38] Amit Sahai and Brent Waters.
Fuzzy identity-
In EUROCRYPT, pages 457–
based encryption.
473, 2005.
[39] Elaine Shi, John Bethencourt, Hubert T.-H. Chan,
Dawn Xiaodong Song, and Adrian Perrig. Multi-
dimensional range query over encrypted data.
In
IEEE Symposium on Security and Privacy, pages
350–364, 2007.
[40] The OpenSSL Project v1.0. OpenSSL: The open
source toolkit for SSL/TLS. www.openssl.org,
April 2010.
[41] Brent Waters. Dual system encryption: Realizing
fully secure IBE and HIBE under simple assump-
tions. In CRYPTO, pages 619–636, 2009.
[42] Brent Waters. Ciphertext-policy attribute-based en-
cryption: An expressive, efﬁcient, and provably se-
cure realization. In PKC, pages 53–70, 2011.
A Proof of Theorem 3.2
Proof. Suppose there exists a polynomial-time adversary
A that can attack our scheme in the selective RCCA-
security model for outsourcing with advantage ε. We
build a simulator B that can attack the Waters scheme
of [42, Appendix C] in the selective CPA-security model
with advantage ε minus a negligible amount. In [42] the
Waters scheme is proven secure under the decisional q-
parallel BDHE assumption.
Init. The simulator B runs A . A chooses the chal-
lenge access structure (M∗,ρ∗), which B passes on to
the Waters challenger as the structure on which it wishes
to be challenged.
Setup.
The simulator B obtains the Waters public
parameters PK = g,e(g,g)α ,ga and a description of the
hash function F. It sends these to A as the public pa-
rameters.
Phase 1.
The simulator B initializes empty tables
T,T1,T2, an empty set D and an integer j = 0. It answers
the adversary’s queries as follows:
• Random Oracle Hash H1(R, M ): If there is an en-
try (R, M ,s) in T1, return s. Otherwise, choose a
random s ∈ Zp, record (R, M ,s) in T1 and return s.
• Random Oracle Hash H2(R): If there is an entry
(R,r) in T2, return r. Otherwise, choose a random
r ∈ {0,1}k, record (R,r) in T2 and return r.
• Create((S)): B sets j := j + 1. It now proceeds one
of two ways.
– Otherwise,
– If S satisﬁes (M∗,ρ∗), then it chooses a “fake”
transformation key as follows: choose a ran-
dom d ∈ Zp and run KeyGen((d,PK),S) to
obtain SK(cid:48). Set TK = SK(cid:48) and set SK =
(d,TK). Note that the pair (d,TK) is not well-
formed, but that TK is properly distributed if d
was replaced by the unknown value z = α/d.
it calls the Waters key genera-
tion oracle on S to obtain the key SK(cid:48) =
(PK,K(cid:48),L(cid:48),{K(cid:48)
x}x∈S).
in the
non-outsourcing CP-ABE game, the Create
and Corrupt functionalities are combined in
one oracle.) The algorithm chooses a ran-
dom value z ∈ Zp and sets the transfor-
mation key TK as (PK, K = K(cid:48)1/z,L =
}x∈S) and the private
L(cid:48)1/z,
key as (z,TK).
{Kx}x∈S = {K(cid:48)1/z
(Recall
that
x
Finally, store ( j,S,SK,TK) in table T and return TK
to A .
• Corrupt(i): A cannot ask to corrupt any key cor-
responding to the challenge structure (M∗,ρ∗). If
there exists an ith entry in table T , then B obtains
the entry (i,S,SK,TK) and sets D := D ∪ {S}.
It
then returns SK to A , or ⊥ if no such entry exists.
• Decrypt(i,CT): Without loss of generality, we as-
sume that all ciphertexts input to this oracle are al-
ready partially decrypted. Recall that both B and
A have access to the TK values for all keys created,
so either can execute the transformation operation.
Let CT = (C0,C1,C2) be associated with structure
(M,ρ). Obtain the record (i,S,SK,TK) from table
T . If it is not there or S (cid:54)∈ (M,ρ), return ⊥ to A .
If key i does not satisfy the challenge structure
(M∗,ρ∗), proceed as follows:
1. Parse SK = (z,TK). Compute R = C0/Cz
2.
2. Obtain the records (R, Mi,si) from table T1. If
none exist, return ⊥ to A .
3. If in this set, there exists indices y (cid:54)= x such
that (R, My,sy) and (R, Mx,sx) are in table T1,
My (cid:54)= Mx and sy = sx, then B aborts the sim-
ulation.
T2. If it does not exist, B outputs ⊥.
4. Otherwise, obtain the record (R,r) from table
5. For each i, test if C0 = R·e(g,g)αsi, C1 = Mi⊕
r and C2 = e(g,g)αsi/z.
6. If there is an i that passes the above test, output
the message Mi; otherwise, output ⊥. (Note:
at most one value of si, and thereby one index
i, can satisfy the third check of the above test.)
If key i does satisfy the challenge structure
(M∗,ρ∗), proceed as follows:
1. Parse SK = (d,TK). Compute β = C1/d
2. For each record (Ri, Mi,si) in table T1, test if
3. If zero matches are found, B outputs ⊥ to A .
4. If more than one matches are found, B aborts
β = e(g,g)si.
2
.
the simulation.
Obtain the record (R,r) from table T2.
does not exist, B outputs ⊥.
5. Otherwise, let (R, M ,s) be the sole match.
If it
6. Test if C0 = R·e(g,g)αs, C1 = M ⊕r and C2 =
7. If all tests pass, output M ; else, output ⊥.
e(g,g)ds.
Challenge. Eventually, A submits a message pair
(M ∗
0 , M ∗
1. B chooses random “messages” (R0, R1) ∈ G2
1 ) ∈ {0,1}2×k. B acts as follows:
T and
passes them on to the Waters challenger to obtain a
ciphertext CT = (C,C(cid:48),{Ci}i∈[1,(cid:96)]) under (M∗,ρ∗).
2. B chooses a random value C(cid:48)(cid:48) ∈ {0,1}k.
3. B sends to A the challenge ciphertext CT∗ =
(C,C(cid:48),C(cid:48)(cid:48),{Ci}i∈[1,(cid:96)]).
Phase 2. The simulator B continues to answer queries
as in Phase 1, except that if the response to a Decrypt
query would be either M ∗
1 , then B responds with
the message test instead.
0 or M ∗
Guess. Eventually, A must either output a bit or abort,
either way B ignores it. Next, B searches through tables
T1 and T2 to see if the values R0 or R1 appear as the
ﬁrst element of any entry (i.e., that A issued a query of
the form H1(Ri,·) or H2(Ri).) If neither or both values
appear, B outputs a random bit as its guess. If only value
Rb appears, then B outputs b as its guess.
This ends the description of the simulation. Due to space
limitations, our analysis of this simulation appears in the
full version of this work [26].
(cid:3)