title:Native Client: A Sandbox for Portable, Untrusted x86 Native Code
author:Bennet Yee and
David Sehr and
Gregory Dardyk and
J. Bradley Chen and
Robert Muth and
Tavis Ormandy and
Shiki Okasaka and
Neha Narula and
Nicholas Fullagar
2009 30th IEEE Symposium on Security and Privacy
Native Client: A Sandbox for Portable, Untrusted x86 Native Code
Bennet Yee, David Sehr, Gregory Dardyk, J. Bradley Chen, Robert Muth,
Tavis Ormandy, Shiki Okasaka, Neha Narula, and Nicholas Fullagar
Google Inc.
Abstract
This paper describes the design, implementation and eval-
uation of Native Client, a sandbox for untrusted x86 native
code. Native Client aims to give browser-based applications
the computational performance of native applications with-
out compromising safety. Native Client uses software fault
isolation and a secure runtime to direct system interaction
and side effects through interfaces managed by Native
Client. Native Client provides operating system portability
for binary code while supporting performance-oriented fea-
tures generally absent from web application programming
environments, such as thread support, instruction set ex-
tensions such as SSE, and use of compiler intrinsics and
hand-coded assembler. We combine these properties in an
open architecture that encourages community review and
3rd-party tools.
1. Introduction
As an application platform,
the modern web browser
brings together a remarkable combination of resources,
including seamless access to Internet
resources, high-
productivity programming languages such as JavaScript, and
the richness of the Document Object Model (DOM) [64]
for graphics presentation and user interaction. While these
strengths put the browser in the forefront as a target for
new application development, it remains handicapped in a
critical dimension: computational performance. Thanks to
Moore’s Law and the zeal with which it is observed by
the hardware community, many interesting applications get
adequate performance in a browser despite this handicap.
But there remains a set of computations that are generally
infeasible for browser-based applications due to performance
constraints, for example: simulation of Newtonian physics,
computational ﬂuid-dynamics, and high-resolution scene
rendering. The current environment also tends to preclude
use of the large bodies of high-quality code developed in
languages other than JavaScript.
Modern web browsers provide extension mechanisms
such as ActiveX [15] and NPAPI [48] to allow native
code to be loaded and run as part of a web application.
Such architectures allow plugins to circumvent the secu-
rity mechanisms otherwise applied to web content, while
giving them access to full native performance, perhaps
as a secondary consideration. Given this organization, and
the absence of effective technical measures to constrain
these plugins, browser applications that wish to use native-
code must rely on non-technical measures for security; for
example, manual establishment of trust relationships through
pop-up dialog boxes, or manual installation of a console
application. Historically, these non-technical measures have
been inadequate to prevent execution of malicious native
code, leading to inconvenience and economic harm [10],
[54]. As a consequence we believe there is a prejudice
against native code extensions for browser-based applica-
tions among experts and distrust among the larger population
of computer users.
While acknowledging the insecurity of the current systems
for incorporating native-code into web applications, we also
observe that there is no fundamental reason why native
code should be unsafe. In Native Client, we separate the
problem of safe native execution from that of extending trust,
allowing each to be managed independently. Conceptually,
Native Client is organized in two parts: a constrained ex-
ecution environment for native code to prevent unintended
side effects, and a runtime for hosting these native code
extensions through which allowable side effects may occur
safely.
The main contributions of this work are:
• an infrastructure for OS and browser-portable sand-
boxed x86 binary modules,
• support for advanced performance capabilities such as
threads, SSE instructions [32], compiler intrinsics and
hand-coded assembler,
• an open system designed for easy retargeting of new
compilers and languages, and
• reﬁnements to CISC software fault
isolation, using
x86 segments for improved simplicity and reduced
overhead.
We combine these features in an infrastructure that supports
safe side effects and local communication. Overall, Native
Client provides sandboxed execution of native code and
portability across operating systems, delivering native code
performance for the browser.
The remainder of the paper is organized as follows. Sec-
tion 1.1 describes our threat model. Section 2 develops some
essential concepts for the NaCl1 system architecture and
1. We use ”NaCl” as an adjective reference to the Native Client system.
1081-6011/09 $25.00 © 2009 IEEE
DOI 10.1109/SP.2009.25
79
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 03:17:16 UTC from IEEE Xplore.  Restrictions apply. 
Figure 1: Hypothetical NaCl-based application for editing and
sharing photos. Untrusted modules have a grey background.
programming model. Section 3 gives additional implemen-
tation details, organized around major system components.
Section 4 provides a quantitative evaluation of the system us-
ing more realistic applications and application components.
In Section 5 we discuss some implications of this work.
Section 6 discusses relevant prior and contemporary systems.
Section 7 concludes.
1.1. Threat Model
Native Client should be able to handle untrusted modules
from any web site with comparable safety to accepted
systems such as JavaScript. When presented to the system,
an untrusted module may contain arbitrary code and data. A
consequence of this is that the NaCl runtime must be able
to conﬁrm that the module conforms to our validity rules
(detailed below). Modules that don’t conform to these rules
are rejected by the system.
Once a conforming NaCl module is accepted for ex-
ecution,
the NaCl runtime must constrain its activity to
prevent unintended side effects, such as might be achieved
via unmoderated access to the native operating system’s
system call
interface. The NaCl module may arbitrarily
combine the entire variety of behaviors permitted by the
NaCl execution environment in attempting to compromise
the system. It may execute any reachable instruction block
in the validated text segment. It may exercise the NaCl
application binary interface to access runtime services in
any way: passing invalid arguments, etc. It may also send
arbitrary data via our intermodule communication interface,
with the communicating peer responsible for validating
input. The NaCl module may allocate memory and spawn
threads up to resource limits. It may attempt to exploit race
conditions in subverting the system.
We argue below that our architecture and code validity
rules constrain NaCl modules within our sandbox.
2. System Architecture
A NaCl application is composed of a collection of trusted
and untrusted components. Figure 1 shows the structure of a
80
Figure 2: The hypothetical photo application of Figure 1 with a
trusted storage service.
hypothetical NaCl-based application for managing and shar-
ing photos. It consists of two components: A user interface,
implemented in JavaScript and executing in the web browser,
and an image processing library (imglib.nexe), implemented
as a NaCl module. In this hypothetical scenario, the user
interface and image processing library are part of the ap-
plication and therefore untrusted. The browser component
is constrained by the browser execution environment and
the image library is constrained by the NaCl container.
Both components are portable across operating systems and
browsers, with native code portability enabled by Native
Client. Prior to running the photo application, the user has
installed Native Client as a browser plugin. Note that the
NaCl browser plugin itself is OS and browser speciﬁc. Also
note it is trusted, that is, it has full access to the OS system
call interface and the user trusts it to not be abusive.
When the user navigates to the web site that hosts the
photo application, the browser loads and executes the appli-
cation JavaScript components. The JavaScript in turn invokes
the NaCl browser plugin to load the image processing library
into a NaCl container. Observe that the native code module
is loaded silently—no pop-up window asks for permission.
Native Client is responsible for constraining the behavior of
the untrusted module.
Each component runs in its own private address space.
Inter-component communication is based on Native Client’s
reliable datagram service, the IMC (Inter-Module Commu-
nications). For communications between the browser and a
NaCl module, Native Client provides two options: a Simple
RPC facility (SRPC), and the Netscape Plugin Application
Programming Interface (NPAPI), both implemented on top
of the IMC. The IMC also provides shared memory seg-
ments and shared synchronization objects, intended to avoid
messaging overhead for high-volume or high-frequency
communications.
The NaCl module also has access to a “service runtime”
interface, providing for memory management operations,
thread creation, and other system services. This interface
is analogous to the system call interface of a conventional
operating system.
In this paper we use “NaCl module” to refer to untrusted
native code. Note however that applications can use multiple
NaCl modules, and that both trusted and untrusted compo-
nents may use the IMC. For example, the user of the photo
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 03:17:16 UTC from IEEE Xplore.  Restrictions apply. 
application might optionally be able to use a (hypothetical)
trusted NaCl service for local storage of images, illustrated
in Figure 2. Because it has access to local disk, the storage
service must be installed as a native browser plugin;
it
can’t be implemented as a NaCl module. Suppose the photo
application has been designed to optionally use the stable
storage service; the user interface would check for the stable
storage plugin during initialization. If it detected the storage
service plugin, the user interface would establish an IMC
communications channel to it, and pass a descriptor for the
channel to the image library, enabling the image library and
the storage service to communicate directly via IMC-based
services (SRPC, shared memory, etc.). In this case the NaCl
module will typically be statically linked against a library
that provides a procedural interface for accessing the storage
service, hiding details of the IMC-level communications
such as whether it uses SRPC or whether it uses shared
memory. Note that the storage service must assume that the
image library is untrusted. The service is responsible for
insuring that it only services requests consistent with the
implied contract with the user. For example, it might enforce
a limit on total disk used by the photo application and
might further restrict operations to only reference a particular
directory.
Native Client is ideal for application components requir-
ing pure computation. It is not appropriate for modules
requiring process creation, direct ﬁle system access, or
unrestricted access to the network. Trusted facilities such
as storage should generally be implemented outside of
Native Client, encouraging simplicity and robustness of the
individual components and enforcing stricter isolation and
scrutiny of all components. This design choice echoes micro-
kernel operating system design [2], [12], [25].
With this example in mind we will now describe the
design of key NaCl system components in more detail.
2.1. The Inner Sandbox
Native Client is built around an x86-speciﬁc intra-process
“inner sandbox.” We believe that the inner sandbox is robust;
regardless, to provide defense in depth [13], [16] we have
also developed a second “outer sandbox” that mediates
system calls at the process boundary. The outer sandbox
is substantially similar to prior structures (systrace [50] and
Janus [24]) and we will not discuss it in detail in this paper.
The inner sandbox uses static analysis to detect security
defects in untrusted x86 code. Previously, such analysis
has been challenging for arbitrary x86 code due to such
practices as self-modifying code and overlapping instruc-
tions. In Native Client we disallow such practices through a
set of alignment and structural rules that, when observed,
insure that the native code module can be disassembled
reliably, such that all reachable instructions are identiﬁed
during disassembly. With reliable disassembly as a tool, our
validator can then insure that the executable includes only
the subset of legal instructions, disallowing unsafe machine
instructions.
The inner sandbox further uses x86 segmented memory
to constrain both data and instruction memory references.
Leveraging existing hardware to implement
these range
checks greatly simpliﬁes the runtime checks required to con-
strain memory references, in turn reducing the performance
impact of safety mechanisms.
This inner sandbox is used to create a security subdomain
within a native operating system process. With this organiza-
tion we can place a trusted service runtime subsystem within
the same process as the untrusted application module, with
a secure trampoline/springboard mechanism to allow safe
transfer of control from trusted to untrusted code and vice-
versa. Although in some cases a process boundary could
effectively contain memory and system-call side effects, we
believe the inner sandbox can provide better security. We
generally assume that the operating system is not defect
free, such that the process barrier might have defects, and
further that the operating system might deliberately map
resources such as shared libraries into the address space of
all processes, as occurs in Microsoft Windows. In effect our
inner sandbox not only isolates the system from the native
module, but also helps to isolate the native module from the
operating system.
2.2. Runtime Facilities
The sandboxes prevent unwanted side effects, but some
side effects are often necessary to make a native mod-
ule useful. For interprocess communications, Native Client
provides a reliable datagram abstraction, the “Inter-Module
Communications” service or IMC. The IMC allows trusted
and untrusted modules to send/receive datagrams consisting
of untyped byte arrays along with optional “NaCl Resource
Descriptors” to facilitate sharing of ﬁles, shared mem-
ory objects, communication channels, etc., across process
boundaries. The IMC can be used by trusted or untrusted
modules, and is the basis for two higher-level abstractions.
The ﬁrst of these, the Simple Remote Procedure Call (SRPC)
facility, provides convenient syntax for deﬁning and using
subroutines across NaCl module boundaries, including calls
to NaCl code from JavaScript in the browser. The second,
NPAPI, provides a familiar interface to interact with browser
state, including opening URLs and accessing the DOM, that
conforms to existing constraints for content safety. Either of
these mechanisms can be used for general interaction with
conventional browser content, including content modiﬁca-
tions, handling mouse and keyboard activity, and fetching
additional site content; substantially all the resources com-
monly available to JavaScript.
As indicated above, the service runtime is responsible
for providing the container through which NaCl modules
81
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 03:17:16 UTC from IEEE Xplore.  Restrictions apply. 
interact with each other and the browser. The service runtime
provides a set of system services commonly associated
with an application programming environment. It provides
sysbrk() and mmap() system calls, primitives to support
malloc()/free() interface or other memory allocation abstrac-
tions. It provides a subset of the POSIX threads interface,
with some NaCl extensions, for thread creation and destruc-
tion, condition variables, mutexes, semaphores, and thread-
local storage. Our thread support is sufﬁciently complete
to allow a port of Intel’s Thread Building Blocks [51]
to Native Client. The service runtime also provides the
common POSIX ﬁle I/O interface, used for operations on
communications channels as well as web-based read-only
content. As the name space of the local ﬁle system is
not accessible to these interfaces, local side effects are not
possible.
To prevent unintended network access, network system
calls such as connect() and accept() are simply omitted.
NaCl modules can access the network via JavaScript in
the browser. This access is subject to the same constraints
that apply to other JavaScript access, with no net effect on
network security.
The NaCl development environment is largely based on
Linux open source systems and will be familiar to most
Linux and Unix developers. We have found that porting
existing Linux libraries is generally straightforward, with
large libraries often requiring no source changes.
2.3. Attack Surface
Overall, we recognize the following as the system com-
ponents that a would-be attacker might attempt to exploit:
• inner sandbox: binary validation
• outer sandbox: OS system-call interception
• service runtime binary module loader
• service runtime trampoline interfaces
• IMC communications interface
• NPAPI interface
In addition to the inner and outer sandbox, the system design
also incorporates CPU and NaCl module black-lists. These