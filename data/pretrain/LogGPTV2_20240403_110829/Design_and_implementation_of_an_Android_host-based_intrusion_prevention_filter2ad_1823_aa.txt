# Design and Implementation of an Android Host-based Intrusion Prevention System

**Authors:**
- Mingshen Sun
- Min Zheng
- John C.S. Lui
- Xuxian Jiang

**Affiliations:**
- The Chinese University of Hong Kong
- Qihoo 360 & NC State University

**Contact:**
- {mssun, mzheng, cslui}@cse.cuhk.edu.hk
- PI:EMAIL
- Xuxian Jiang: [Contact Information]

## Abstract
Android dominates the mobile market, and there has been a significant rise in mobile malware targeting Android devices. In 2013, Android malware accounted for 97% of all mobile threats. To protect smartphones and prevent privacy leaks, companies have implemented various host-based intrusion prevention systems (HIPS) on their Android devices. This paper first analyzes the implementations, strengths, and weaknesses of three popular HIPS architectures. We demonstrate a severe loophole and weakness in an existing popular HIPS product that hackers can exploit. We then present the design and implementation of a secure and extensible HIPS platform called "Patronus." Patronus not only provides intrusion prevention without modifying the Android system but also dynamically detects existing malware based on runtime information. We propose a two-phase dynamic detection algorithm for identifying running malware. Our experiments show that Patronus can efficiently prevent intrusive behaviors and accurately detect malware with very low performance overhead and power consumption.

## 1. Introduction
We now live in a mobile digital era where smartphones are becoming indispensable as personal communication and computing devices. Unfortunately, they are also becoming prime targets for hackers. Android, an open-source operating system for mobile devices, had a market share of around 80% of all smartphone shipments in the second quarter of 2013. Due to its large market share, it is the primary target for hackers. A recent report indicated that 97% of these threats targeted Android devices. Additionally, McAfee reported that 17,000 new Android malware were found in the second quarter of 2013, indicating an explosive growth in malware threats.

The primary security protection in Android is the permission mechanism. When a user installs a mobile application, the system alerts them about the required permissions. However, this mechanism does not provide adequate security. As shown in several studies, there are numerous instances of Android permission abuses. The open-source nature of Android and its working mechanism make it easy to write malware variants that can bypass antivirus software. Recent research has shown that some existing antivirus software cannot effectively detect malware variants generated by simple transformations. Most antivirus engines use static analysis and malware signatures for detection. To address the limitations of static analysis, several systems aim to detect runtime behaviors using dynamic analysis. However, these systems are mainly for post-mortem analysis, and the malware under investigation may have already infected many devices. Therefore, the security community advocates the use of a host-based intrusion prevention system (HIPS), which monitors suspicious activities, blocks, and reports malicious behaviors in real-time.

In general, there are three approaches to implementing HIPS in Android: (1) system patching, (2) application repackaging, and (3) API hooking. Each approach has its own limitations and potential vulnerabilities. In Section 3, we detail the implementation issues and weaknesses of these three popular HIPS implementations.

Given the limitations of static and dynamic analysis, as well as the weaknesses of existing HIPS products, we propose an enhanced HIPS called Patronus. Patronus not only performs secure policy enforcement but also dynamically detects existing malware using runtime information. Patronus does not require any modifications to the Android firmware or mobile apps, ensuring ease of deployment. It performs runtime policy enforcement at the system level to inspect malicious behaviors and provides host-based runtime detection to halt malicious behavior execution. Our contributions include:

- A systematic analysis of three popular HIPS frameworks, exposing various security vulnerabilities and demonstrating how to exploit a popular HIPS product to bypass malware detection.
- The design and implementation of a secure architecture, Patronus, which prevents mobile malware intrusions and detects malware at runtime, addressing the security issues in current HIPS products.
- The design and implementation of a two-phase detection algorithm based on runtime intrusion information to detect and prevent malware in real-time, while traditional signature-based static methods can only achieve this offline.

The rest of the paper is organized as follows: Section 2 introduces the necessary background on Android. Section 3 presents the strengths and weaknesses of three popular HIPS implementations. Section 4 proposes our Patronus system, describing the method to prevent intrusions and a two-phase algorithm for dynamic malware detection. Section 5 presents our experimental results, illustrating the effectiveness and performance of Patronus. Section 6 discusses related work, and Section 7 concludes the paper.

## 2. Background
This section introduces the architecture of the Android system, its Binder inter-process communication mechanism, the Dalvik Virtual Machine, and the Native Development Kit. This background is essential to understand how one can create a HIPS for Android devices.

### 2.1 Android Architecture
Android is an open-source operating system for mobile devices developed by Google. The system consists of five functional layers: (1) kernel, (2) libraries, (3) runtime support, (4) application framework, and (5) applications. Figure 1 presents the Android architecture. Android uses Linux as the core kernel with various drivers for hardware communication. The libraries layer contains native libraries such as libc or OpenGL to support higher application layers. The runtime layer consists of the Dalvik Virtual Machine (DVM) with various runtime libraries. DVM is a special Java virtual machine to execute Android apps. The application framework layer contains basic services for activity management, SMS management, etc. Finally, all Android apps run on top of these layers.

Android apps are mostly written in Java using the Android SDK, and DVM is responsible for interpreting and executing these apps. Each app runs within its own DVM. The Android system assigns a unique ID to each DVM to achieve process (or app) isolation. This sandboxing mechanism provides basic security protection between apps. Android also provides a special inter-process communication mechanism called the Binder. Each app must go through the Binder (which is in the kernel layer) to communicate with other apps or services.

Besides using DVM sandbox, permission is another security mechanism provided by Android. An app can use corresponding APIs only if it has explicitly declared its permissions in its AndroidManifest.xml file. Moreover, when installing an app, the system displays a dialog window to alert users about the declared permissions. However, most users usually accept these permission alerts without paying much attention. Once the installation is complete, the system will not warn users in later invocations. Many Android malware take advantage of this, often obtaining enhanced permissions (e.g., sending premium SMS messages to subscribe to chargeable services in the background).

### 2.2 Binder Mechanism
Binder is a specialized inter-process communication (IPC) mechanism in Android. Since apps run in their own DVM sandboxes, they need to communicate through the Binder to utilize others' services. Figure 2 shows the basic flow of the Binder mechanism. For example, if an app wants to send an SMS message, it should first contact the Service Manager, which contains information about all registered services. The Service Manager provides a handler to communicate with the ISms Service, responsible for sending SMS messages. Once the app has the handler, it can ask the ISms Service to send SMS messages, and the ISms Service will process the request and send the message through the SMS Driver. Note that all communications must go through the Binder by sending transactions with the required information (i.e., the parcel). Transactions are communication procedures between two processes. In Android, the Binder transaction is used to send service requests (represented by a transaction code) to the corresponding processes. There are two stages to complete a transaction. First, the Binder delivers a data parcel to the destination process containing the receiver information (i.e., transaction descriptor). Secondly, after completing the request, the receiving process saves the result in a reply parcel. In the above example of sending an SMS message, there are two transactions completed in three steps. The first transaction requests the ISms Service handler, and the second transaction requests sending an SMS message. In the second transaction, the data parcel contains the ISms Service descriptor (com.android.internal.telephony.ISms) and information (e.g., destination address and text content) for sending an SMS message. In the third step, the ISms Service sends the request and saves the result in a reply parcel.

This procedure is similar to the client-server communication model. Apps are on the client side, executing within their own sandboxes, while various services are on the server side, managed by the Service Manager. The System Services are a group of services related to the Android system (e.g., Account Manager Service, Battery Service, and Network Management Service). An app can export its service to the public by registering with the Service Manager. This special Binder mechanism not only provides a flexible inter-process communication framework but also isolates apps and services to protect the system.

### 2.3 DVM & Native Development Kit
The Dalvik Virtual Machine (DVM) is a special component in the Android system. Apps are written in Java and compiled into bytecode files (i.e., class files) with the Android SDK. These bytecodes are converted to Dalvik executable files (i.e., dex files) before installation. To instantiate an app, the DVM interprets and runs the app in a different virtual machine. To integrate with other C/C++ native libraries, Android provides the Native Development Kit (NDK) for developers to implement parts of the app using native code such as C/C++. The Java Native Interface (JNI) provides a bridge between Java code and C/C++ code, allowing developers to invoke native code easily. Therefore, the DVM can use native libraries (e.g., OpenGL, libbinder, libc) to support its execution.

## 3. HIPS
In this section, we discuss three popular frameworks for implementing host-based intrusion prevention systems (HIPS): (1) system patching, (2) application repackaging, and (3) API hooking. We present their implementations, strengths, and weaknesses. We also demonstrate how to bypass a popular HIPS product.

### 3.1 System Patching
Before Android 4.3, there was no HIPS integrated into the Android OS, and users experienced various forms of permission abuses as malware exploited system loopholes to escalate permissions. Because Android is an open-source project, researchers and companies have developed patches for the Android system. Some third-party system images have integrated these patches to manage permission usage for each app. Some mobile phone vendors (e.g., Huawei) also provide patched images for their phones, and users can install these modified images on their devices. In Android 4.3, Google introduced system patching. For example, there is a hidden function called App Ops, which is a form of HIPS. Using App Ops, one can disable certain permissions of an app. However, App Ops was removed in Android 4.4.

To install these HIPS in Android, users need to update to Android 4.3 or install the patched system image from their vendors. However, as shown in the latest report, only 10% of Android phones are powered by Android 4.3 or 4.4. Furthermore, if users want to install any patched image, they must find the appropriate third-party system images that match their phone models. For this reason, many users opt not to install these patches, leaving a large percentage of smartphones vulnerable. Moreover, because one has to use App Ops to disable permissions before launching the apps, systems like App Ops cannot prevent intrusions at runtime. Hence, even with system patches, many Android phones remain vulnerable to malware attacks.

### 3.2 Application Repackaging
An Android application package file (or apk file) is a zip file containing the Dalvik executable file (classes.dex) and other resource files (e.g., images or audio). An app must declare its permission usage in the AndroidManifest.xml file within the apk package to use the corresponding APIs. To prevent an app from using sensitive APIs, one can delete certain permission declarations in the AndroidManifest.xml and repackage it as a new apk file. App Shield is an app that manages app permissions using this technique.

Since the Dalvik executable file is converted from Java bytecode, it is easy to reverse-engineer into readable code. Several tools provide assembling and disassembling functions on dex files. Therefore, one can disassemble the dex file into readable code, modify the program logic, and then assemble and repackage it into a new apk file. By using this repackaging method, HIPS can be implemented by inserting stubs around sensitive Android APIs to perform policy enforcement without modifying the Android system. For example, if an app needs to get the current location using the GPS function, it must use the requestLocationUpdates API. One can add code to check the GPS permission before invoking this API. Aura-sium and RetroSkeleton are two projects that use this form of application repackaging to inspect sensitive APIs and reinforce the Android permission policy.

Although application repackaging does not require modifying the Android system, it has some major drawbacks. The first major drawback is incomplete security coverage. Since a function can be implemented by different approaches (i.e., calling different APIs), it is possible to miss policy enforcement unless all possible APIs are known. For example, using Java Reflection, one can invoke APIs and bypass the stubs. Secondly, disassembling techniques can only work on dex files. If application developers use native code (e.g., binary libraries), repackaging becomes ineffective.