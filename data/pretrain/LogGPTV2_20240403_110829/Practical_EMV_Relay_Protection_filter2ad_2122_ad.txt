For over the limit transactions on Apple Pay Express Transit,
only clearing the CVM bit in the TTQ (without the CTQ ﬂips)
results in the transaction failing on the reader side, i.e., this
attack does not work against Apple Pay.
The attack presented by Basin et. al. [2] is a different
approach to achieving over the CVM limit transactions without
requiring Cardholder Veriﬁcation, on plastic cards. It involves
clearing the online PIN veriﬁcation required bit and setting the
CDCVM performed bit in the CTQ – i.e. tricking the EMV
reader into believing the card has performed CDCVM. Our
Apple Pay Express Transit CVM limit escalation also targets
the CTQ. However, the online PIN veriﬁcation bit is not set
in our case. We target the CDCVM bit in CTQ in two places:
it ﬁrst appears in the response to the GPO message (under
tag 9F6C), and in a record template, as part of the CARD
(tag 9F69). The CDCVM bit needs to be set in both of these
EMV tags, otherwise the transaction is not successful.
As a side-note, we conﬁrm the Galloway attack still
works against Google Pay (Pixel 5), two years after being
publicised [7]. We found that the Basin et. al. attack did
Authorized licensed use limited to: Tsinghua University. Downloaded on August 07,2022 at 12:59:17 UTC from IEEE Xplore.  Restrictions apply. 
1744
not work against Google Pay: the combination of over the
limit transaction amount and set CVM bit in TTQ results
in the phone terminating the transaction after it receives
the GPO message, with the code 6986 (Command not
allowed), and therefore the CTQ is never sent. We conclude
that Google detects and rejects any Visa transaction that
requests authentication in the TTQ unless the phone has been
unlocked. Unfortunately Apple Pay does not have this defence.
G. Formal Veriﬁcation
To analyse these protocols we use the Tamarin prover [18].
This is a veriﬁcation tool that supports symbolic/Dolev-Yao
analysis [29], [30]. Tamarin models are transition systems over
a multi-sorted term algebra, operating on the semantics of
multiset rewriting logic [31]. Security properties can expressed
as lemmas about the labels on the rewrite rules. Tamarin can
then automatically either prove that a security proprieties holds
or provide a counter example, i.e., ﬁnd an attack.
1) Verifying Visa in Apple & Samsung Pay: We use formal
veriﬁcation
to show that our attack is exhibited on the
EMV speciﬁcation of Visa used inside an Apple Pay app but
not inside the Samsung Pay app. We show, formally, that
the countermeasures proposed to Apple and Visa stop the
attack. Finally, we show that our attack cannot be completely
counteracted by any/all of the countermeasures, i.e., that it is
still possible to relay to terminals that share the same MCC.
to account for a
modular treatment of the countermeasures we discussed, e.g.,
Apple and Samsung Pay differing only in the answers to
GPO commands based on value inside this message, etc. The
Tamarin ﬁle can be found in Mobile Visa.spthy in [9].
We endeavoured to create this model
Tamarin Model for Mobile Visa: We used as starting
point the Tamarin models for contactless Visa “plastic cards”
by Basin et. al. [2]. Unlike Basin et. al., we have one single
model which contains: (a) both EMV transaction-authorisation
modes (“DDA” – with SDAD, used in mobile transport mode,
and “EMV” – no SDAD, used in non-transport mobile);
(b) transaction-values above and below the limit (“high” vs
“low”). Most of our Tamarin rules for card, terminal and bank
are similar to the one in Basin et. al., but other extensions/-
modiﬁcations are necessary as we explain in the following.
it
it
sends
Terminals. A “Create_Terminal” rule generically
creates our
terminals as follows. A terminal can be a
“transport” vs “non-transport” terminal, and if
is the
former
the “magic bytes” we observed TfL
to send. Terminals can send “zero”, “low” and “high”
values. Terminals have an MCC value, which in the
model is as broad as “transport”/“non-transport” MCCs. To
encode the Apple Pay business model, our protocol rules
indeed allow transport
terminals to send any value (see
Terminal_Sends_GPO_AnyValue_AnyMode_Visa
rule). In this rule, we impose however a realistic restriction
that non-transport terminals cannot accept zero values (i.e., see
_restrict(NonTransportNonZero(mode,value)).
Cards/Mobile Apps. We create rules for cards/apps as
generically and modularly as possible, with the same
transition-rule applying to both behaviours wherever possible.
Before the app actually responds to the GPO, we have a
ComputeCVR rule ﬁring that
implements the mobile-app
logic of judging if CDCVM is needed based on the “magic
bytes” being received or not (i.e., perceived app operation
mode) and value (high/low) sent in the GPO command.
We have two GPO-responding rules separated by the
Handset(’samsung’) vs Handset(’apple’) and
otherwise the facts produced by this ComputeCVR rule; these
two GPO-responding rules are the only way we differentiate
between Samsung and Apple Pay w.r.t. EMV-card behaviour;
i.e.,
in the case of Samsung, we impose a restriction
_restrict(ZeroOnly_in_nonAuthen_Transport
(CDCVM_noCDCVM, perceivedAppMode, value))
to allow only zero payments when in the ComputeCVR rule
it judged it is in transport mode.
Unlike the Basin et. al. model, in the GPO-responding rule,
the cards create a more detailed IAD. Concretely, e.g., in the
Basin et. al. model, the IAD for Visa EMV mode was IAD =
; ours is IAD=, and this additionally denotes that the CVR
(denoting if CDCVM was performed is included in the IAD),
and “format” speciﬁed if the card believes it is operated in
transport or non-transport mode. This is entirely in line with
Visa IAD formats for mobiles. Also, in our model, we add
that the MCC of the terminal is ﬁnally sent to the issuing
bank along with the whole transaction on a secure channel.
The Bank. We implement three transaction-processing rules,
accounting for the different possible behaviours: (case1) as in
the models by Basin et. al., in this case the bank does not
check the CVR and format values inside the IAD, (case2) the
bank does check the CVR and format values inside the IAD,
but does not cross-check these against the MCC; (case3) the
bank checks all of the IAD, MCC and transaction data.
Veriﬁcation. In the model, we add numerous sanity-check
lemmas to show that all and only faithful behaviours w.r.t.
to Apple/Samsung,
transport/non-transport, and values are
present. We then prove/disprove the following lemmas: respec-
tively meaning:
1) the Apple-Pay attack is found:
a) via
falsifying
the
“all-traces”
payment-security
the bank-checks above,
lemma1.a,
where the bank does not check the IAD;
for “case1” of
b) via proving an “exist-trace” lemma1.b
2) Samsung Pay does not
from the mode-
abusing payment attack (via proving an “all-traces”
payment-security lemma2, quantifying over traces of
Handset(’samsung’))
suffer
3) either of our two countermeasures stops the Apple attack:
i.e., the bank checking the CVR (lemma3), and the bank
checking the MCC against the IAD-format (lemma4).
4) it is still possible to relay a transaction from a transport
terminal to another transport terminal, if they share the
same MCC (lemma5)
Note. Checking the format of
the IAD (i.e., case2
Authorized licensed use limited to: Tsinghua University. Downloaded on August 07,2022 at 12:59:17 UTC from IEEE Xplore.  Restrictions apply. 
1745
is
is enough to stop the “CTQ-change”, “Tap &
above)
PIN” attack in [2]. This
shown indirectly by our
lemma3 above. We also show this for the original model
Visa EMV High.spthy from [2]. I.e., the authentication for
the bank (i.e., lemma auth_to_bank_minimal) holds
if the IAD format is checked. In the GPO-processing rule,
the TTQ info received by the card now dictates the IAD
format, and in the rules relating to the bank processing the
CVM (for the case of online/not-online PIN) we added IAD
format checking (see lines 425, 749 of the amended ﬁle
Visa EMV High BasinEtAl.spthy in [9]).
2) Verifying Mastercard in Apple & Samsung Pay: We use
Tamarin to verify that no similar attack is possible against ex-
press transit mode for Mastercard on Apple Pay. The Tamarin
ﬁle can be found in Mobile Mastercard.spthy in [9].
We detail slightly less in this case, building on the previous
section. Like for Visa, we base our model of Mastercard on
the work of Basin et. al. [2], to this model we add a) the
more detailed IAD that encodes if the device used the user
authentication (CDCVM) or not, b) that devices may indicate
in the AIP that the device supports CDCVM but that a device
might not use it, c) we add the Merchant Category Code
(MCC). Our experiments and conversations with Mastercard’s
security team indicate that (unlike Visa) all of these values are
actually checked. We also make some simpliﬁcations to the
model in [2]: i.e., we only model Mastercard with a SDAD,
as we have not seen any support for transactions without this
across any of our devices or readers. Unlike for the Visa model,
we only consider two payment amounts, a low and a high
value. For Apple Pay Express Transit, we add that devices
may function without the device authentication if the “magic-
bytes” action is present in the trace and if the MCC code
indicates that the terminal is a transport reader.
Using Tamarin we are able to prove that: for uncompro-
mised Mastercard Apple Pay devices, if the bank accepts
a high transaction amount then the device must have used
CDCVM user authentication and we can further show that
this is based on Mastercard checking the IAD, indicating that
this is an important part of Mastercard’s protocol.
To show that the Visa Apple Pay attack is not possible
against Mastercard, we show that the bank will only accept
a non-CDCVM transaction from a terminal with a transport
MCC code. This means that relay attacks using transit express
mode are limited to only relaying to other transit terminals.
V. VISA’S LEVEL 1-RELAY PROTECTION
As stated in their attacker model, Visa’s solution relies on
the inability of the attacker to change the UID of a card or mo-
bile phone, which they refer to as L1SessionParameter,
and the difﬁculty of relaying the Level 1 messages due to
their timing constraints. However, setting a desired UID on
some mobile devices is possible [32], if the device is rooted.
This has been introduced in Android 4.4, as host-based card
emulation, and allows an app to emulate a card (or NFC
tag) and talk directly to a NFC reader [33]. While this is a
departure from Visa’s attacker model, rooting a phone is not
a complicated task in 2021, with plenty of resources available
and tools which take care of the more “technical” steps of
the process. We have tested a rooted Nexus 5 phone, which
has the Broadcom BCM20793M NFC controller, running its
stock ﬁrmware (Android 4.4) and running CyanogenMod 14.1
(Android 7.1.1). On both versions we were able to successfully
set any UID we wanted by editing the NFC conﬁguration ﬁle.
By building on the work of [26], we modiﬁed their Android
relay apps to add an extra step before any EMV messages
were exchanged. We ran the CardEmulator app on the
Nexus 5 phone and used a Nokia 6 phone to run the
TerminalEmulator app. A server forwards data between
the apps (no change to the original from [26]).
On the TerminalEmulator app we added extra func-
tionality which allows us to retrieve the UID of the card
the phone is in contact with. This is done through retriev-
ing the ID of the Tag object that was discovered by the
ACTION_TECH_DISCOVERED intent, and sending it to the
server, which will then forward it to the CardEmulator app.
In the CardEmulator app we receive the UID and set it
as the phone’s UID by:
• Remounting the system partition with read and write
permissions;
• Replacing the NFA_DM_START_UP_CFG parameter in
the /etc/libnfc-brcm-20791b05.conf conﬁgu-
ration ﬁle such that it includes the UID:
– we add 6 to the ﬁrst byte of the conﬁg parameter, which
holds the length of NFA_DM_START_UP_CFG, as we
will be adding 6 more bytes;
– at the end of NFA_DM_START_UP_CFG, we add the
NCI parameter LA_NFCID1 (0x33), which means the
UID is declared in this conﬁguration parameter, the
length of the UID (0x04), and the UID itself;
• Restarting the NFC service.
The complete set of steps for setting the UID on the phone
takes approximately 181ms. After this, the EMV level relay
can proceed as normal. We conﬁrmed with a Proxmark that
the UID of the Nexus phone was equal to the UID of the
relayed card. Fig. 12 in Appendix B presents the overview
of the communication between all the devices involved. Our
modiﬁed apps are available in [9].
With this attack we can break Visa’s relay protection
protocol. When the L1SessionParameter is sent signed
as part of the EMV protocol, the EMV reader will decrypt
it, and it will match the UID of the phone. We can achieve
this both because we can set a phone’s UID as desired and
because, although there is an overall timeout for the transaction
(the EMV speciﬁcation says 500 ms [34]) there is no round-
trip timing measurement within Visa’s protocol, which means
the card may wait in the PROTOCOL state (before the EMV
protocol starts), for the SELECT 2PAY.SYS.DDF01 message
from the EMV reader, as the transaction timing is enforced
by the EMV reader with which we start interacting after the
UID change has happened.
Authorized licensed use limited to: Tsinghua University. Downloaded on August 07,2022 at 12:59:17 UTC from IEEE Xplore.  Restrictions apply. 
1746
VI. LEVEL 1 AND LEVEL 3 TIMING IN EMV
We experimented with the reliability of timing at Level 1
and Level 3, and therefore the feasibility of relaying at
these two levels. We experimented with several commercial
EMV cards (Visa and Mastercard), as well as aprototype,
test prototype PayPass-RRP card, bought from a vendor
called ICC Solutions. We found no commercial/bank-issued
PayPass-RRP cards.
We show that timing exchanges at Level 1 are much faster
than at Level 3, and show much less variation, and the Level 3
variation in timing is considerable for all EMV cards that we
tested, and more so, for a proprietary card that implements a
test version of PayPass-RRP, we can relay at Level 3 with
a standard relay program. Overall, the variation at Level 3
across all cards, has led us to propose a new Level 1 protocol
for relay protection in EMV, in Section VII, which improves
on both Visa’s and Mastercard’s current solutions for relay
counteraction.
A. Level 1 and Level 3 Timings for EMV Cards
We measured the Level 1 and Level 3 message round trip
times (RTTs) for: (1) a Mastercard-RRP test card; (2) a
“normal” commercial Mastercard; (3) a commercial Visa card.
All the raw data, processing scripts and other programs we
used are available in [9].
Hardware/Software Setup: We used an Advanced Card
Systems ACR122u reader. A program acts as an EMV reader,
prepares the correct sequence of challenges (ISO 14443 mes-
sages, or Level 2 Command Application Protocol Data Units
(C-APDUs)) for a transaction with the card and, via the
ACR122u reader, sends this to the card; the sequences were
different for each card (PayPass-RRP, Mastercard, Visa), as
each executes a different protocol. To obtain RTTs and other
timings related to these exchanges, we placed a Proxmark in-
between the reader and card, to sniff the transaction, and thus
we obtained the full traces of the exchanges. This is discussed
further in Appendix C.
Experimental Design: To capture the variations that occur
when someone makes a contactless payment, we varied the
yaw angle at which the card was placed in the ﬁeld and the
distance between the card and the reader. The distance was
maintained by resting the card on a spacer. We tested at angles
of 0°, 45°, 90°, 135°
and 180°, and at distances of 5mm,
11.4mm, 21mm, 24mm, 27.4mm and 30.6mm. These are all
realistic positions a card may be held in to make a payment.
We took 20 measurements for each physical conﬁguration,
making a total of 600 tests. We note that, apart from the
initial Level 1 messages, what we are actually measuring is
the time from when the reader sends the C-APDU (at Level 2)
until it receives the Response Application Protocol Data Unit
(R-APDU) (also at Level 2) back from the card.
Generally,
the reader
sends a message/C-APDU and
waits for a response/R-APDU from the card. We used the
hf 14a sniff command of the Proxmark client, which
sniffs the ISO 14443-A trafﬁc and produces traces as per
Fig. 5. Thus, we can calculate the reply time of a card
|
|
End | Src | Data (! denotes parity error)
Start |
------+-------+-----+------------------------------------+----+-----------
1056 | Rdr |26
0
2260
4628 | Tag |04 00