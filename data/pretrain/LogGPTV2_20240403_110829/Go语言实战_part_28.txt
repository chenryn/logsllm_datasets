38 var wg sync.WaitGroup
39 wg.Add(100 * len(names))
40
41 for i := 0; i < 100; i++ {
42 // 迭代names切片
43 for _, name := range names {
44 // 创建一个namePrinter并提供
45 // 指定的名字
46 np := namePrinter{
47 name: name,
48 }
49
50 go func() {
51 // 将任务提交执行。当Run返回时
52 // 我们就知道任务已经处理完成
53 p.Run(&np)
54 wg.Done()
55 }()
56 }
57 }
58
59 wg.Wait()
60
61 // 让工作池停止工作，等待所有现有的
62 // 工作完成
63 p.Shutdown()
64 }
代码清单 7-34 展示了使用 work 包来完成名字显示工作的测试程序。这段代码一开始在第
14行声明了名为names的包级的变量，这个变量被声明为一个字符串切片。这个切片使用5个
名字进行了初始化。然后声明了名为namePrinter的类型，如代码清单7-35所示。
代码清单7-35 work/main/main.go：第22行到第31行
22 // namePrinter使用特定方式打印名字
23 type namePrinter struct {
24 name string
25 }
26
27 // Task实现Worker接口
28 func (m *namePrinter) Task() {
29 log.Println(m.name)
30 time.Sleep(time.Second)
31 }
在代码清单7-35的第23行，声明了namePrinter类型，接着是这个类型对Worker接口
的实现。这个类型的工作任务是在显示器上显示名字。这个类型只包含一个字段，即name，它
包含要显示的名字。Worker接口的实现Task函数用log.Println函数来显示名字，之后等
待1 秒再退出。等待这1秒只是为了让测试程序运行的速度慢一些，以便看到并发的效果。
有了 Worker 接口的实现，我们就可以看一下 main 函数内部的代码了，如代码清单 7-36
所示。
代码清单7-36 work/main/main.go：第33行到第64行
33 // main是所有Go程序的入口
34 func main() {
35 // 使用两个goroutine来创建工作池
36 p := work.New(2)
37
38 var wg sync.WaitGroup
39 wg.Add(100 * len(names))
40
41 for i := 0; i < 100; i++ {
42 // 迭代names切片
43 for _, name := range names {
44 // 创建一个namePrinter并提供
45 // 指定的名字
46 np := namePrinter{
47 name: name,
48 }
49
50 go func() {
51 // 将任务提交执行。当Run返回时
52 // 我们就知道任务已经处理完成
53 p.Run(&np)
54 wg.Done()
55 }()
56 }
57 }
58
59 wg.Wait()
60
61 // 让工作池停止工作，等待所有现有的
62 // 工作完成
63 p.Shutdown()
64 }
在代码清单7-36第36行，调用work包里的New函数创建一个工作池。这个调用传入的参
数是2，表示这个工作池只会包含两个执行任务的goroutine。在第38行和第39行，声明了一个
WaitGroup，并初始化为要执行任务的goroutine数。在这个例子里，names切片里的每个名字
都会创建100个goroutine来提交任务。这样就会有一堆goroutine互相竞争，将任务提交到池里。
在第41行到第43行，内部和外部的for循环用来声明并创建所有的goroutine。每次内部
循环都会创建一个namePrinter类型的值，并提供一个用来打印的名字。之后，在第50行，
声明了一个匿名函数，并创建一个goroutine执行这个函数。这个goroutine会调用工作池的Run
方法，将namePrinter的值提交到池里。一旦工作池里的goroutine接收到这个值，Run方法
就会返回。这也会导致goroutine将WaitGroup的计数递减，并终止goroutine。
一旦所有的goroutine都创建完成，main函数就会调用WaitGroup的Wait方法。这个调
用会等待所有创建的goroutine提交它们的工作。一旦Wait返回，就会调用工作池的Shutdown
方法来关闭工作池。Shutdown方法直到所有的工作都做完才会返回。在这个例子里，最多只会
等待两个工作的完成。
7.4 小结
可以使用通道来控制程序的生命周期。
带default分支的select语句可以用来尝试向通道发送或者接收数据，而不会阻塞。
有缓冲的通道可以用来管理一组可复用的资源。
语言运行时会处理好通道的协作和同步。
使用无缓冲的通道来创建完成工作的goroutine池。
任何时间都可以用无缓冲的通道来让两个goroutine交换数据，在通道操作完成时一定保
证对方接收到了数据。
8
第 8 章 标准库
第8章 标准库
本章主要内容
 输出数据以及记录日志
 对JSON进行编码和解码
 处理输入/输出，并以流的方式处理数据
 让标准库里多个包协同工作
什么是 Go 标准库？为什么这个库这么重要？Go 标准库是一组核心包，用来扩展和增强语
言的能力。这些包为语言增加了大量不同的类型。开发人员可以直接使用这些类型，而不用再写
自己的包或者去下载其他人发布的第三方包。由于这些包和语言绑在一起发布，它们会得到以下
特殊的保证：
每次语言更新，哪怕是小更新，都会带有标准库；
这些标准库会严格遵守向后兼容的承诺；
标准库是Go语言开发、构建、发布过程的一部分；
标准库由Go的构建者们维护和评审；
每次Go语言发布新版本时，标准库都会被测试，并评估性能。
这些保证让标准库变得很特殊，开发人员应该尽量利用这些标准库。使用标准库里的包可以
使管理代码变得更容易，并且保证代码的稳定。不用担心程序无法兼容不同的Go语言版本，也
不用管理第三方依赖。
如果标准库包含的包不够好用，那么这些好处实际上没什么用。Go 语言社区的开发者会比
其他语言的开发者更依赖这些标准库里的包的原因是，标准库本身是经过良好设计的，并且比其
他语言的标准库提供了更多的功能。社区里的Go开发者会依赖这些标准库里的包做更多其他语
言中开发者无法做的事情，例如，网络、HTTP、图像处理、加密等。
本章中我们会大致了解标准库的一部分包。之后，我们会更详细地探讨3个非常有用的包：
log、json和io。这些包也展示了Go语言提供的重要且有用的机制。
8.1 文档与源代码
标准库里包含众多的包，不可能在一章内把这些包都讲一遍。目前，标准库里总共有超过
100个包，这些包被分到38个类别里，如代码清单8-1所示。
代码清单8-1 标准库里的顶级目录和包
archive bufio bytes compress container crypto database
debug encoding errors expvar flag fmt go
hash html image index io log math
mime net os path reflect regexp runtime
sort strconv strings sync syscall testing text
time unicode unsafe
代码清单8-1里列出的许多分类本身就是一个包。如果想了解所有包以及更详细的描述，Go
语言团队在网站上维护了一个文档，参见http://golang.org/pkg/。
golang 网站的 pkg 页面提供了每个包的 godoc 文档。图 8-1 展示了 golang 网站上 io
包的文档。
图8-1 golang.org/pkg/io/#Writer
如果想以交互的方式浏览文档，Sourcegraph索引了所有标准库的代码，以及大部分包含Go
代码的公开库。图8-2是Sourcegraph网站的一个例子，展示的是io包的文档。
图8-2 sourcegraph.com/code.google.com/p/go/.GoPackage/io/.def/Writer
不管用什么方式安装Go，标准库的源代码都会安装在$GOROOT/src/pkg文件夹中。拥有标
准库的源代码对Go工具正常工作非常重要。类似godoc、gocode甚至go build这些工具，
都需要读取标准库的源代码才能完成其工作。如果源代码没有安装在以上文件夹中，或者无法通
过$GOROOT变量访问，在试图编译程序时会产生错误。
作为Go发布包的一部分，标准库的源代码是经过预编译的。这些预编译后的文件，称作归
档文件（archive file），可以 在$GOROOT/pkg文件夹中找到已经安装的各目标平台和操作系统的
归档文件。在图8-3里，可以看到扩展名是.a的文件，这些就是归档文件。
图8-3 pkg文件夹中的归档文件的文件夹的视图
这些文件是特殊的 Go 静态库文件，由 Go 的构建工具创建，并在编译和链接最终程序时被
使用。归档文件可以让构建的速度更快。但是在构建的过程中，没办法指定这些文件，所以没办
法与别人共享这些文件。Go 工具链知道什么时候可以使用已有的.a 文件，什么时候需要从机器
上的源代码重新构建。
有了这些背景知识，让我们看一下标准库里的几个包，看看如何用这些包来构建自己的程序。
8.2 记录日志
即便没有表现出来，你的程序依旧可能有bug。这在软件开发里是很自然的事情。日志是一
种找到这些bug，更好地了解程序工作状态的方法。日志是开发人员的眼睛和耳朵，可以用来跟
踪、调试和分析代码。基于此，标准库提供了 log 包，可以对日志做一些最基本的配置。根据
特殊需要，开发人员还可以自己定制日志记录器。
在 UNIX 里，日志有很长的历史。这些积累下来的经验都体现在 log 包的设计里。传统的
CLI（命令行界面）程序直接将输出写到名为stdout的设备上。所有的操作系统上都有这种设
备，这种设备的默认目的地是标准文本输出。默认设置下，终端会显示这些写到stdout设备上
的文本。这种单个目的地的输出用起来很方便，不过你总会碰到需要同时输出程序信息和输出执
行细节的情况。这些执行细节被称作日志。当想要记录日志时，你希望能写到不同的目的地，这
样就不会将程序的输出和日志混在一起了。
为了解决这个问题，UNIX架构上增加了一个叫作stderr的设备。这个设备被创建为日志
的默认目的地。这样开发人员就能将程序的输出和日志分离开来。如果想在程序运行时同时看到
程序输出和日志，可以将终端配置为同时显示写到 stdout 和 stderr 的信息。不过，如果用
户的程序只记录日志，没有程序输出，更常用的方式是将一般的日志信息写到stdout，将错误
或者警告信息写到stderr。
8.2.1 log 包
让我们从 log 包提供的最基本的功能开始，之后再学习如何创建定制的日志记录器。记录
日志的目的是跟踪程序什么时候在什么位置做了什么。这就需要通过某些配置在每个日志项上要
写的一些信息，如代码清单8-2所示。
代码清单8-2 跟踪日志的样例
TRACE: 2009/11/10 23:00:00.000000 /tmpfs/gosandbox-/prog.go:14: message
在代码清单8-2中，可以看到一个由log包产生的日志项。这个日志项包含前缀、日期时间
戳、该日志具体是由哪个源文件记录的、源文件记录日志所在行，最后是日志消息。让我们看一
下如何配置log包来输出这样的日志项，如代码清单8-3所示。
代码清单8-3 listing03.go
01 // 这个示例程序展示如何使用最基本的log包
02 package main
03
04 import (
05 "log"
06 )
07
08 func init() {
09 log.SetPrefix("TRACE: ")
10 log.SetFlags(log.Ldate | log.Lmicroseconds | log.Llongfile)
11 }
12
13 func main() {
14 // Println写到标准日志记录器
15 log.Println("message")
16
17 // Fatalln在调用Println()之后会接着调用os.Exit(1)
18 log.Fatalln("fatal message")
19
20 // Panicln在调用Println()之后会接着调用panic()
21 log.Panicln("panic message")
22 }
如果执行代码清单8-3中的程序，输出的结果会和代码清单8-2所示的输出类似。让我们分
析一下代码清单8-4中的代码，看看它是如何工作的。
代码清单8-4 listing03.go：第08行到第11行
08 func init() {
09 log.SetPrefix("TRACE: ")
10 log.SetFlags(log.Ldate | log.Lmicroseconds | log.Llongfile)
11 }
在第08行到第11行，定义的函数名为init()。这个函数会在运行main()之前作为程序
初始化的一部分执行。通常程序会在这个init()函数里配置日志参数，这样程序一开始就能使
用log包进行正确的输出。在这段程序的第9行，设置了一个字符串，作为每个日志项的前缀。
这个字符串应该是能让用户从一般的程序输出中分辨出日志的字符串。传统上这个字符串的字
符会全部大写。
有几个和 log 包相关联的标志，这些标志用来控制可以写到每个日志项的其他信息。代码
清单8-5展示了目前包含的所有标志。
代码清单8-5 golang.org/src/log/log.go
const (
// 将下面的位使用或运算符连接在一起，可以控制要输出的信息。没有
// 办法控制这些信息出现的顺序（下面会给出顺序）或者打印的格式
// （格式在注释里描述）。这些项后面会有一个冒号：
// 2009/01/23 01:23:23.123123 /a/b/c/d.go:23: message
// 日期: 2009/01/23
Ldate = 1 << iota
// 时间: 01:23:23
Ltime
// 毫秒级时间: 01:23:23.123123。该设置会覆盖Ltime标志
Lmicroseconds
// 完整路径的文件名和行号: /a/b/c/d.go:23
Llongfile
// 最终的文件名元素和行号: d.go:23
// 覆盖 Llongfile
Lshortfile
// 标准日志记录器的初始值