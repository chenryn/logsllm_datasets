title:Pitfalls in HTTP Traffic Measurements and Analysis
author:Fabian Schneider and
Bernhard Ager and
Gregor Maier and
Anja Feldmann and
Steve Uhlig
Pitfalls in HTTP Trafﬁc Measurements and Analysis
Fabian Schneider1,2,(cid:2), Bernhard Ager2, Gregor Maier2,3,
Anja Feldmann2, and Steve Uhlig4
1 NEC Laboratories Europe, Heidelberg, Germany
2 TU Berlin / Telekom Innovation Laboratories, Berlin, Germany
3 International Computer Science Institute, Berkeley, CA, USA
4 Queen Mary, University of London, London, UK
Abstract. Being responsible for more than half of the total trafﬁc volume in the
Internet, HTTP is a popular subject for trafﬁc analysis. From our experiences
with HTTP trafﬁc analysis we identiﬁed a number of pitfalls which can render a
carefully executed study ﬂawed. Often these pitfalls can be avoided easily. Based
on passive trafﬁc measurements of 20.000 European residential broadband cus-
tomers, we quantify the potential error of three issues: Non-consideration of per-
sistent or pipelined HTTP requests, mismatches between the Content-Type header
ﬁeld and the actual content, and mismatches between the Content-Length header
and the actual transmitted volume. We ﬁnd that 60 % (30 %) of all HTTP re-
quests (bytes) are persistent (i. e., not the ﬁrst in a TCP connection) and 4 % are
pipelined. Moreover, we observe a Content-Type mismatch for 35 % of the total
HTTP volume. In terms of Content-Length accuracy our data shows a factor of at
least 3.2 more bytes reported in the HTTP header than actually transferred.
1 Introduction
HTTP has become the preferred protocol for many Internet services. Internet users ex-
change most of their content via HTTP. They download videos from YouTube, share
photos and status updates via Facebook and Twitter, send and read emails with Gmail
or Yahoo, or get the latest news and shop online. Thus analyzing HTTP trafﬁc has been
the focus of many recent studies [1–6, 9, 10]. Often these studies are based on passive
packet-level trafﬁc measurements. These measurements often imply huge amounts of
data to be analyzed, sometimes requiring simpliﬁcations to scale the analysis. Some of
these simpliﬁcations will lead to potential biases in the results or even render a study
ﬂawed, as we show in this paper.
In prior analysis of large HTTP traces [1, 6, 9, 10], we encountered such inconsis-
tencies and identiﬁed and solved the problem. In this paper we quantify the potential
errors of those issues. We study the prevalence of pipelined and persistent HTTP con-
nections, and the accuracy of the Content-Length and Content-Type HTTP header ﬁelds.
Our results are drawn from anonymized HTTP trafﬁc from roughly 20,000 European
residential DSL customers (Section 2). Our contributions are the following:
– Persistence and pipelining: By not considering pipelined and persistent HTTP
connections, e. g., by only considering the ﬁrst request in a HTTP connection, the
(cid:2) Work done at UPMC Sorbonne Universit´es, LIP6, Paris, France.
N. Taft and F. Ricciato (Eds.): PAM 2012, LNCS 7192, pp. 242–251, 2012.
c(cid:2) Springer-Verlag Berlin Heidelberg 2012
Pitfalls in HTTP Trafﬁc Measurements and Analysis
243
Table 1. Overview of anonymized HTTP data sets
Name
Start date Duration HTTP volume
≈ 2.5 TB
≈ 2.5 TB
≈ 5.9 TB
SEP08 18 Sep 2008 24 h
APR09 01 Apr 2009 24 h
AUG09 21 Aug 2009 48 h
Name
Start date Duration HTTP volume
≈ 3.3 TB
≈ 3.2 TB
≈ 42 TB
≈ 38 TB
04 Mar 2010 24 h
MAR10
24 h
23 Jun 2010
JUN10
HTTP14d 09 Sep 2009 14 d
HTTP12d 07 May 2010 12 d
number of HTTP requests is highly underestimated. Indeed, each connection con-
tains more than 2 requests on average. We ﬁnd (Section 3) that 60 % of all HTTP
requests are persistent, i.e., they are not the ﬁrst in a TCP connection. These persis-
tent requests are responsible for 30 % of the HTTP volume, and will be missed if
not taken into account in the analysis. Contrary to our expectations, we ﬁnd that the
most inﬂuential aspect on the use of persistent or pipelined requests is the contacted
web service, not the user’s browser.
– HTTP content type: HTTP servers can specify the mime-type of the transferred
object in the Content-Type header. However, there is no guarantee that this infor-
mation is correct. Indeed, we ﬁnd (Section 4) that for 35 % of the HTTP volume,
the Content-Type header is different from what is found by libmagic.
– HTTP content size: The Content-Length ﬁeld in HTTP headers can state incorrect
values for canceled transfers or erroneous Web servers. In our dataset we record
at least 3.2 times more bytes reported in Content-Length headers than is actually
transferred (Section 5).
2 Data and Methodology
In this section we present our data sets before describing our methodology. We conclude
this section by introducing the user population with respect to Browser and OS usage.
Anonymized HTTP Data. Our study is based on multiple sets of anonymized packet-
level observations of residential DSL connections collected at a large European ISP over
the course of more than 2 years. Data anonymization and analysis is performed imme-
diately on the secured measurement infrastructure. We use Bro [8] with a customized
HTTP analysis script. The monitor operates at the broadband access router connecting
customers to the ISP’s backbone and observes the trafﬁc of more than 20,000 DSL
lines. The monitor uses Endace monitoring cards. While we typically do not experi-
ence any packet loss, there are several multi-second periods with no packets (less than
5 minutes overall per trace) due to OS/ﬁle-system interactions. We summarize the char-
acteristics, including start time, duration and size, of the traces in Table 1. HTTP14d
and HTTP12d do not include request headers. Please refer to Maier et al. [6] for de-
tailed characteristics of this user population (e.g. DSL session lenght, application usage
or network performance).
Persistence and Pipelining. We investigate the prevalence of persistence and pipelining
in HTTP connections. We deﬁne the ﬁrst request/response of a connection as initial,
244
F. Schneider et al.
and mark all follow-up requests/replies as persistent. Hence, persistent connections are
connections with more than one request.1 This allows us to derive the following metrics:
(i) The fraction of connections that are persistent, (ii) the fraction of requests that are
persistent, and (iii) the fraction of bytes transported in persistent request/response pairs.
Next, if a request is issued before the response of an earlier request in the same con-
nection is ﬁnished, we mark this request as pipelined. Moreover, if pipelined requests
are sent in the same IP packet2, we mark them as such. Similarly to the persistent re-
quests, we derive the same fractions as metrics for the pipelined/same packet marking
method. Because HTTP14d and HTTP12d do not include request timestamps, we cannot
use those to determine pipelined/same packet requests.
Note that we never mark the ﬁrst request of a connection as persistent nor do we
mark the ﬁrst request of a pipeline (or same-packet) as such. The reasoning behind
this is that we want to focus on the differences to a one request per connection model
(HTTP/1.0). Also note that each request marked as pipelined will always be marked
as persistent as well, and thereby the set of pipelined requests is a subset of persistent
requests. Similarly, the set of same-packet requests is a subset of pipelined requests.
We also investigate whether different operating systems or browsers inﬂuence our
results. Therefore, we annotate our data sets accordingly and perform our analysis for
each subset. We extract browser type and operating system information from HTTP
user-agent strings using an open source parser 3.
Content Type. Another potential error can be made by relying on the Content-Type
header to identify the mime type of transferred ﬁles. To assess this error, we extract the
Content-Type header and analyze the initial portion of the HTTP body with libmagic.
We then compare the type reported by HTTP headers and libmagic and analyze cases
in which they disagree.
Content Length and Download Volume. HTTP servers can set a Content-Length
header in the response indicating the size of the body. For persistent HTTP connec-
tions, the existence of either a Content-Length or a Content-Encoding header is manda-
tory. When measuring the volume downloaded via HTTP, one can choose to (i) mea-
sure the bytes transported on the wire, or (ii) use the Content-Length header of the
HTTP response. The second option may introduce errors, caused by user interaction
(e. g., interrupted downloads), software errors, or the lack of Content-Length headers.
While canceling a download leads to larger values reported than actually downloaded,
the lack of Content-Length headers will typically cause to ignore the request and there-
fore underestimate the volume. We deﬁne the estimation error as the ratio of the size
announced by the Content-Length header and the actually downloaded volume. If an
HTTP response does not include a Content-Length header, we deﬁne the ratio as 1.
1 Bro terminates connections at control packets (SYN, FIN/RST) or an inactivity timeout.
2 Packet capture is often conﬁgured with a snap-length so that the ﬁrst lines of the HTTP header
are captured. Often, such traces would include persistent requests but not second (pipelined)
ones in the same packet.
3 http://user-agent-string.info/download/UASparser
Pitfalls in HTTP Trafﬁc Measurements and Analysis
245
]
%
[
S
O
r
e
p
e
m
u
o
V
l
100
80
60
40
20
0
Win Other
Win XP
Win Vista
Windows 7
Mobile OS
Mac OS
Linux
]
%
[
r
e
s
w
o
r
B
r
e
p
e
m
u
o
V
l
100
80
60
40
20
0
Safari
Opera
MSIE 8
MSIE 7
MSIE ≤6
Firefox 3
Firefox ≤2
Chrome
SEP08 APR09 AUG09 MAR10
JUN10
SEP08 APR09 AUG09 MAR10 JUN10
Fig. 1. Operating system popularity
Fig. 2. Browser popularity
Browser and OS Popularity. In order to better understand the data sets and the mon-
itored user population we present the popularity and distribution of operating systems
and browser families. In Figure 1 we plot the trafﬁc volume per operating system and
in Figure 2 the trafﬁc volume per browsers family. We only include popular, regu-
lar browsers (Internet Explorer, Firefox, Safari, Opera), and exclude other user-agents
(e. g., software updates, media players).
In terms, of operating system popularity we see that Windows clearly dominates,
with more than 80 % trafﬁc volume. With time users are switching from older Windows
versions to newer ones. Mac OS consistently accounts for 8 % while Linux increases its
contribution from 2 % to 13 % in 2010.
When we look into browser popularity, we see that the majority of bytes are re-
quested by Firefox users. Microsoft’s Internet Explorer (MSIE) is the close second.
As for OSes we see the adaption of new browser versions by users (e.g., Firefox 2 →
Firefox 3), which signiﬁcantly changes the contribution by browser version. In the over-
all share of browser families, Firefox gains 13 % and Google’s Chrome rises to 2.5 %.
While Opera and Safari remain at 3 % and 4 %, Internet Explorer declines.
3 Persistent and Pipelined Requests
3.1 Persistent Requests
We ﬁrst determine the amount of persistent requests. In Figure 3 we plot the comple-
mentary cumulative distribution function (CCDF) of the number of requests per con-
nection for JUN10, HTTP12d, and HTTP14d. We observe that 30 % of the connections
(y-axis at 3· 10
−1 in log-scale) have two or more requests. One connection in one thou-
sand has more than 100 requests. We even observe connections with several tens of
thousands of requests. The CCDFs for the other traces look similar. On average, each
connection has 2.2 to 2.4 requests. This is consistent with Callahan et al. [2].
It also indicates a potentially high error for analyses that only consider the ﬁrst re-
quest in a connection. The TimeMachine [7] suggests that “the most interesting in-
formation is in the beginning of a connection” and showed signiﬁcant recording and
analysis savings when only considering the ﬁrst few bytes (the “cutoff”) of a connec-
tion. If this cutoff is too low, successive persistent requests will be skipped from the
analysis.
In Figures 4 and 5 we present the results of our three metrics—connections with
(Conns) marked request, number (Reqs), and volume (Bytes) of marked requests—
for the persistent, pipelined, and same packet requests for all 24h traces. Recall that
246
F. Schneider et al.
1
10-1
10-2
10-3
10-4
10-5
10-6
10-7
10-8
30%
HTTP12d
HTTP14d
JUN10
j
x
=
>
)
s
t
c
e
b
o
#
(
P
=
y
:
F
D
C
C
1
10
100
1000
10000
100000
x = Objects per connection
Fig. 3. CCDF of requests per connection for
HTTP12d, HTTP14d, and JUN10
Metric
Reqs
Conns
Bytes
Method
Persistent
Pipelined
c
i
f
f
a
r
t
P
T
T
H
l
l
a
f
o
n
o
i
t
c
a
r
F
]
%
[
s
e
t
y
B
/
s
q
e
R
/
s
n
n
o
C
n
i
0
0
1
0
8
0
6
0
4
0
2
0