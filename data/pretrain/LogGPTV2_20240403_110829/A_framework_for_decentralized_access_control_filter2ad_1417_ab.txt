D. Implementation
We implemented the policy structure and the access requests
signing and veriﬁcation in Go. The current version of the
code supports policy creation and updates, rule creation and
updates. The code also has functionality to sign and verify
single signature and multi-signature requests. We developed
a parser to evaluate expressions that use the logical opera-
tors AND/OR/NOT. Finally, the implementation also supports
signing with path selection by the requester. The code is
available on Github [6]. Note that we did not perform the
integration of the access control system with the skipchain
architecture in this project.
IV. EVALUATION
We performed two types of tests after implementing the
system, using the Go testing and benchmarking modules. First,
we completed unit tests to ensure that all the implemented
functionality was correct and worked as expected. Then, we
conducted benchmark tests to evaluate the performance of the
system. We describe the benchmark tests in more detail in this
section.
We undertook benchmarking only for access request veriﬁca-
tion. This is because, out of all the operations, the veriﬁcation
takes the longest time to complete. Other functions, such as
creation or updates to policies, are less time consuming. We
considered three cases for benchmarking: veriﬁcation of single
signature requests, veriﬁcation of multi-signature requests and
signing of single signature request with path selection. Note
that, in the last case, we looked at the signing function rather
than the veriﬁcation function since the path selection happens
during signing.
For our experimental setup, we created functions that could
take in inputs such as number of subjects, expression param-
eters, depth of a policy etc., and create a policy environment
that we then used for benchmarking.
A. Single signature Request Veriﬁcation
We benchmark the request veriﬁcation time for single signa-
ture requests. The request veriﬁcation time can be considered
to be the sum of the signature veriﬁcation time and the time
taken to ﬁnd the path from the target policy to the requester.
We vary the depth of the requester. The depth refers to the
distance between the target policy in the request and the parent
policy of the requester. The depth expresses the levels of
checks that a veriﬁer has to undertake to ﬁnd the path. Our
reasoning behind varying the depth is to investigate whether
the checking for access proof has a signiﬁcant impact on the
request veriﬁcation time.
Figure 7 shows the variation in request veriﬁcation time with
depth of the requester. Note that since we use a log scale, the
lowest value is set to a value close to zero (0.01). Interestingly,
we see that most of the request veriﬁcation time goes into
signature veriﬁcation. The signature veriﬁcation takes ≈ 385
us and accounts for 92.04 − 99.94% of the total time. We
observe that even at a depth of 200, a relatively high scenario
for a real-life access control system, path ﬁnding takes only
about 35 us.
Figure 7: Benchmarking result for single signature request
veriﬁcation.
B. Multi-signature Request Veriﬁcation
Since signature veriﬁcation is the major factor contributing
to request veriﬁcation time, it will have an impact on multi-
signature requests. We measure the veriﬁcation rate for multi-
signature requests. The veriﬁcation rate is the number of
requests veriﬁed per second. We create requests with varying
number of signatures. Figure 8 shows the veriﬁcation rate
for requests with different number of signatures. We show
the results for a requester depth of 2 and 10.
We notice that there is a signiﬁcant reduction in number of
requests that can be veriﬁed when the number of signatures
increases. This is expected since the signature veriﬁcation step
has to be performed for each signature. We also notice that
the depth of the requester does not play a notable role in the
veriﬁcation rate.
Figure 8: Benchmarking result for multi-signature request
veriﬁcation. Veriﬁcation rate vs Number of signatures in
request.
C. Signing with Path Selection
In our ﬁnal benchmark test, we consider the case of a multi-
path requester that signs with path selection. Since the path
selection process has to ﬁnd all possible paths and return
them to the requester, we are interested in determining the
time taken for this process. We create a requester that has
multiple paths from the target policy and performs a path
check during signing. We vary the number of paths and look
at its impact on the signing rate - the number of requests
signed per second.
Figure
9 shows the results for a requester at depths 2
and 10. The depth value is the same at all paths in this
experiment.
We observe that the signing rate reduces rapidly with the
increase in number of paths, from ≈ 320000 at 2 paths to
≈ 530 at 500 paths (depth = 2). This is probably because
all possible paths now have to be discovered and stored. The
depth also has an impact on the signing rate, most likely due
to the searching and storage overheads.
We do not display the veriﬁcation time here since it
is
dominated by the signature veriﬁcation and looks similar to
5
Figure 9: Benchmarking result in signing with path selection.
Signing rate vs Number of paths of the requester.
the single signature veriﬁcation case (one signature is veriﬁed
and one path is searched).
V. RELATED WORK
Kokoris-Kogias et al. [4] describe a system where a set of
trusted servers act as an authority (termed cothority) and
manage blockchains that can store identity information for
users (such as SSH keys). These blockchains, called Identity-
Blockchains, have forward and backward links. While back-
ward links are used for ordering between blocks, Forward
links provide a method for easy veriﬁcation of changes to the
user’s identiﬁcation data. CISC (CISC Identity Skipchains)
[7] is an implementation of the concept described in [4].
Chaniac [5] allows for transparent software updates and in-
troduces the concept of skipchains, a combination of skiplists
and blockchains. The skiplists enable efﬁcient traversal. We
use the concepts in these works in designing how our policies
can evolve with time.
Maesa et al.
[8] outline a blockchain based access control
system that uses the Bitcoin blockchain and XACML policies.
In this system, policies are stored on the blockchain in a
shorter XACML format and access rights are transferred by
means of transactions. Enforcement of policies is done using
the process deﬁned by the XACML standard. FairAccess
[9] is an access control framework that aims to provide
a blockchain based access control system for IoT (Internet
of Things) devices. It uses authorization tokens, a scripting
language and the Bitcoin blockchain. Zyskind et al.
[10]
discuss the possibility of using a blockchain as an access
control manager while using off-blockhain storage systems for
data. This is further expanded in Enigma [11], a decentralized
computation platform. Enigma provides functionality for users
to store and run computations on data with privacy guarantees.
It uses a blockchain for identity management, access control
and logging.
VI. CONCLUSION
In this project, we designed, implemented and performed basic
testing of a policy based access control model. We introduced
6
functionality for policy creation and updates, access request
creation, signing and veriﬁcation. Our system allows for easy
management of policies, organization of users into groups and
both access control and identity management. The code and
API are available on Github [6].
Future Work
We highlight a few avenues for possible exploration and
improvement:
• Alternatives to the ‘one skipchain per policy’ architec-
ture: Currently, we consider the one skipchain per policy
design. This might not be the most appropriate, especially
when the number of policies is large since maintaining
skipchains for so many policy objects can prove to be
cumbersome. Hence, we should also explore alternate
designs - perhaps using a skipchain for groups of related
policies rather than individual policies. We could also
investigate using collections to group policies.
REFERENCES
• THR
consider
operator:
Currently, we
is especially useful
only
AND/OR/NOT operators in Expressions. A consideration
for a third operator would be THR. THR is a threshold
[thrval, S1, S2, S3, ]}.
operator of the form {T H R :
is a threshold value - a positive integer.
thr val
The operation means that a threshold of signatures
>= thr val needs to be obtained for the expression
for voting
to be valid. This
on policy updates, where
admin
subjects have to agree on a change to the policy.
A more
created by
introducing the concept of weights.
is possible
that some subjects votes carry a higher weightage.
Keeping weights
is
{T H R : [thrval, S1, weight1, S2, weight2, S3, weight3]},
where weight1 is weight of subject S1 and so on. Votes
for a change would be the sum of the weights of the
subjects that agreed to the change.
complex expression can be
It
threshold of
in mind,
expression
the
a
• Extensions of attributes: Currently, the policy model is
kept very simple. The reasoning behind this is to have
a general model that can then be tailored based on the
application. However, it might be interesting to explore
the possibility of adding more features to this general
model. For example, perhaps an Environment variable in
a Rule to have a richer set of conditions than can be
provided by Expressions.
• Sub-policies and linking to other policies: In this version
of the architecture, policies are relatively simple and
consist of a list of rules. We can explore a more ad-
vanced architecture where policies can have sub-policies
which then consist of rules. In addition to this, it would
be interesting to have the ability to link policies/sub-
policies from other policies/sub-policies. Currently, we
link policies through the Subject ﬁeld in a Rule, but it
would be feasible to have a policy that contains a list of
other policies rather than rules.
• Versioning and Consistency: The current implementa-
tion of the policies has not been integrated with the
skipchain architecture. This is planned for the On-Chain
Secrets project. While integration would solve the issue
of versioning, we still have to consider the problem of
consistency – all the parties in the system would have
to work on the same version of a particular policy.
Exploring how consistency can be achieved with different
policy versions and access requests/veriﬁcation is an
interesting option.
[1] Pierangela Samarati and Sabrina Capitani de Vimercati.
Access control: Policies, models, and mechanisms.
In
International School on Foundations of Security Analysis
and Design, pages 137–196. Springer, 2000.
[2] Vincent C Hu, D Richard Kuhn, and David F Ferraiolo.
Attribute-based access control. Computer, 48(2):85–88,
2015.
[3] Sabrina De Capitani di Vimercati, Pierangela Sama-
Policies, models, and lan-
rati, and Sushil Jajodia.
guages for access control.
In International Workshop
on Databases in Networked Information Systems, pages
225–237. Springer, 2005.
[4] Lefteris Kokoris-Kogias, Linus Gasser, Ismail Khofﬁ,
Philipp Jovanovic, Nicolas Gailly, and Bryan Ford. Man-
aging identities using blockchains and cosi. In 9th Work-
shop on Hot Topics in Privacy Enhancing Technologies
(HotPETs 2016), 2016.
[5] Kirill Nikitin, Eleftherios Kokoris-Kogias, Philipp Jo-
vanovic, Nicolas Gailly, Linus Gasser, Ismail Khofﬁ,
Justin Cappos, and Bryan Ford.
Chainiac: Proac-
tive software-update transparency via collectively signed
skipchains and veriﬁed builds. In 26th USENIX Security
Symposium (USENIX Security 17), pages 1271–1287,
2017.
[6] Sandra
control.
https://github.com/sandrasiby/cothority template, 2017.
Skipchain.
Decentralized
[7] DEDIS.
Identity
access
CISC
Siby.
https://github.com/dedis/cothority/tree/master/cisc,
2017.
[8] Damiano Di Francesco Maesa, Paolo Mori, and Laura
Ricci. Blockchain based access control.
In IFIP In-
ternational Conference on Distributed Applications and
Interoperable Systems, pages 206–220. Springer, 2017.
[9] Aafaf Ouaddah, Anas Abou Elkalam, and Abdellah
Ait Ouahman.
Fairaccess: a new blockchain-based
access control framework for the internet of things. Se-
curity and Communication Networks, 9(18):5943–5964,
2016.
[10] Guy Zyskind, Oz Nathan, et al. Decentralizing privacy:
Using blockchain to protect personal data. In Security
and Privacy Workshops (SPW), 2015 IEEE, pages 180–
184. IEEE, 2015.
[11] Guy Zyskind, Oz Nathan, and Alex Pentland. Enigma:
Decentralized computation platform with guaranteed pri-
vacy. arXiv preprint arXiv:1506.03471, 2015.