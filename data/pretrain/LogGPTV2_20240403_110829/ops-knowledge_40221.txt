User: I have a subprocess which is constantly producing data, but most of the data I'm not interested in.  However occasionally, at random times, I need to grab a sample of the output - the thing is I need to read it at well defined boundaries.  For example, let's assume the process produces a constant 100 bytes per second and useful information comes in chunks of 100 bytes.  After it has been running for 4 seconds, I ask to see 100 bytes of output, then I would be interested in bytes 400-499 inclusive.  But if I ask at 4.1 seconds, I don't want to intercept and get bytes 410-509, I need to wait and see bytes 500-599.  Otherwise, the process should be happily streaming its output to /dev/null and I don't want to ever block the output stream.  My friend fred might also ask for 100 bytes at, say, 4.6 seconds, so I also need to tee off that stuff and make the data available to multiple consumers for reading.  
Is there an existing design pattern for this kind of thing?  How can I implement it with python subprocess, and ensure that communication with the subprocess is non-blocking?
Assistant: Well I am new to python, but it seems proc.communicate or proc.stdout.readline/readlines waits till the process has completed.
As per my knowledge, you can implement a rotational logging and redirect output to a file, then using subprocess you can fire tailf -n XX logfile, in a loop until the program ends, and print the output whenever there is a request from the user end.