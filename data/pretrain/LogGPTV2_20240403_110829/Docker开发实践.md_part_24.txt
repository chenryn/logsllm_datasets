3
 UTS（UNIX Time-sharing System）命名空间。该命名空间主要用来管理主机名和域名。
每个UTS命名空间都可以定义不同的主机名和域名。通过配置独立的UTS命名空间，就可
4
以虚拟出一个有独立主机名和网络空间的环境。
默认情况下，Docker容器的主机名就是容器id。 5
 用户命名空间。它主要用来隔离系统的用户和用户组。我们可以在用户命名空间中建立
6
自己的用户和组，但这些用户在空间外面却不可见。这样我们就可以在容器中自由地添
加用户和组，却不影响宿主机和其他容器上的用户和组。
7
13.2 cgroups
9
cgroups是control groups的缩写，是Linux内核提供的一种可以记录、限制、隔离进程组（process
group）所使用的物理资源（如CPU、内存、I/O等）的机制。它最初由Google工程师提出，后来 8
被整合进Linux内核。cgroups也是容器为实现虚拟化所使用的资源管理手段。可以说，没有
cgroups，就没有容器。
10
cgroups最初的目标是为资源管理提供一个统一的框架，既整合现有的cpuset等子系统，也为
未来开发新的子系统提供接口。现在的cgroups适用于多种应用场景，从单个进程的资源控制，到 10
实现操作系统层次的虚拟化（OS Level Virtualization）。cgroups提供了以下功能。
 限制进程组可以使用的资源数量（Resource limiting）。比如，memory子系统可以为进程 11
组设定一个memory使用上限，一旦进程组使用的内存达到限额再申请内存，就会出现
13
OOM（Out Of Memory）。
 进程组的优先级控制（Prioritization）。比如，可以使用cpu子系统为某个进程组分配特定
CPU占有率。 14
 记录（Accounting）进程组使用的资源数量。比如，可以使用cpuacct子系统记录某个进
程组使用的CPU时间。 15
 进程组隔离（Isolation）。比如，使用命名空间子系统，可以使不同的进程组使用不同的
16
命名空间，以达到隔离的目的，不同的进程组有各自的进程、网络、文件系统挂载空间。
 进程组控制（Control）。比如，使用freezer子系统可以将进程组挂起和恢复。
17
控制组是 Linux 容器机制的另外一个关键组件，负责实现资源的审计和限制。它提供了很多
有用的特性，确保各个容器可以公平地分享主机的内存、CPU、磁盘I/O等资源。当然，更重要
18
的是，控制组确保了当容器内的资源使用产生压力时，不会连累主机系统。
152 第13章 安全
尽管控制组不负责隔离容器之间相互访问、处理数据和进程，它在防止拒绝服务（DDOS）
攻击方面是必不可少的。尤其是在多用户的平台（比如公有或私有的 PaaS）上，控制组十分重
要。例如，当某些应用程序表现异常时，可以保证一致地正常运行和性能。
控制组机制始于2006年，内核从2.6.24版本开始被引入。
13.3 Linux 能力机制
Linux操作系统赋给普通用户尽可能低的权限，而把所有系统权限给予root用户。root用户可
以执行一切特权操作。
事实上，那些需要root权限的程序往往只需要一种或几种特权操作，多数的特权操作都用不
到。比如passwd程序只需要写passwd的权限，一个Web服务器只需要绑定到1024以下端口的权
限。很显然，其他的特权对程序来说是不必要的，赋予程序root权限给系统带来了额外的威胁。
如果这些程序有漏洞的话，那么理论上别人就可能利用漏洞取得系统的控制权，然后做他想做
的任何事情。而如果把程序不必要的大多数特权去掉，那么即使存在漏洞，对我们造成的威胁
也会小很多。
Linux的能力机制就是为了这个目的设计的。使用能力机制可以消除需要某些操作特权的程
序对root用户的依赖，从而减小安全风险。系统管理员为了系统的安全，还可以去除root用户的
某些能力，这样即使是root用户，也无法执行这些操作，而这个过程又是不可逆的。也就是说，
如果一种能力被删除，除非重新启动系统，否则，即使root用户，也无法重新添加被删除的能力。
1. 能力的概念
Linux内核中使用的能力（capability）就是一个进程能够执行的某种操作。因为传统Linux系
统中的root权限过于强大，能力机制把Linux的root权限细分成不同的能力，通过单独控制对每种
能力的开关来达到安全的目的。这样的话，如果一个程序需要绑定低于1024的端口，那我们就赋
予它这方面的能力，而不开放其他的各种能力。这样的话，如果程序的漏洞被利用，黑客也只能
得到绑定低于1024的端口的能力，而不可能得到系统的控制权。
2. 能力边界集
能力机制还引入了能力边界集的概念。能力边界集是系统中所有进程允许拥有的能力的集
合。如果在能力边界集中不存在某种能力，那么系统中所有进程都没有这种能力，即使以root权
限运行也没有相应的能力。
删除系统中多余的能力对提高系统的安全性很有好处。假设你有一台重要的服务器，比较担
心可加载内核模块的安全性，而你又不想完全禁止使用可加载内核模块，或者一些设备的驱动就
是一些可加载内核模块。在这种情况下，最好使系统在启动时加载所有的模块，然后禁止加载/
卸载任何内核模块。把CAP_SYS_MODULE从能力边界集中删除，系统将不再允许加载/卸载任何的内
核模块。
13.3 Linux能力机制 153
3. 局限 1
虽然利用能力机制可以有效地保护系统安全，但是由于文件系统的制约（当前Linux文件结
构没有存放能力机制的能力），Linux的能力机制还不是很完善。我们除了可以使用能力边界集从 2
总体上放弃一些能力之外，还做不到只赋予某个程序某些方面的能力。
3
4
5
6
7
9
8
10
10
11
13
14
15
16
17
18
154 第14章 Docker API
第 14 章
Docker API
在本章之前，我们对Docker的操作都是通过“docker+命令”这种方式，它是由Docker这个
二进制文件加上命令来进行的。例如，列出本地所有镜像，可以使用docker images命令；获取
当前正在运行的容器，可以使用docker ps命令等。本章要介绍另一种方法：Docker API，即Docker
编程接口。本章内容主要包含：
 API概述，说明通过API操作Docker的优点以及API的分类等；
 如何绑定Docker后台监听接口；
 远程API，包括容器和镜像相关API；
 平台API，先从机制原理上说明镜像的上传和下载流程，然后一步步说明操作步骤；
 API实战，通过docker-py库进行API实战编程。
14.1 API 概述
任何一个开放平台都会向开发者开放API，以供开发者更加自由地使用平台所提供的功能，
定制出特定功能的应用。在应用中使用Docker API，应用就可以直接和Docker后台、库以及Docker
Hub平台通信。事实上，Docker二进制本身也采用API与服务端通信。相对于使用“docker+命令”
的方式对后台服务进行访问和使用，使用API方式具有以下几个优点。
 无需安装Docker客户端。采用“docker+命令”的方式，就意味着必须装有Docker客户端，
而通过API方式则不需要。
 效率更高。除了在终端中直接使用“docker+命令”这种方式外，我们也可以在自己的应
用中通过类似system(docker命令)的方式来达到同样的效果，然而和API编程相比，这种
方式显得更为低效，因为它会新创建一个进程来执行system函数内部的操作。
 更为自由。“docker+命令”的形式返回的内容是经过Docker客户端处理的数据，并不是后
台返回的原始数据，所以对有深度定制需求的应用而言，这制约了其自由定制的可能。
所以，要想更加高效和自由地使用Docker功能，就不得不了解Docker API编程。
从功能上分，Docker API包含三部分内容。
14.2 绑定Docker后台监听接口 155
 Registry API（库API）：提供Docker库相关接口，用于保存镜像。 1
 Hub API（平台API）：和Docker Hub公共平台相关的接口。
 Remote API（远程API）：Docker客户端和后台服务端交互的接口。 2
在本章中，我们主要介绍远程API。因为相比库API和平台API，它更为核心和基础，拥有的
操作也比其他两类多。此外，我们也会介绍与Docker Hub相关的API，因为它涉及镜像的上传和 3
下载。本章中API提供的接口其实和前面章节涉及的Docker操作是一一对应的，所以在说明API
用例时，读者肯定会有一种似曾相识的感觉，所以我们尽量以一种简单规范的形式来说明API， 4
以一种“方法、用例请求、用例返回、参数、状态码、curl操作”模板的方法来展示API。当然，
为了满足读者技痒需求，我们将会在14.5节中说明如何通过docker-py库来进行实战编程。 5
在介绍API的具体内容之前，我们需要说明一下API的工作原理。图14-1所示的是API中客户
端和服务端的通信架构。图中包含两台机器——远端主机和Docker服务主机。Docker服务主机是 6
一台装有Docker服务的计算机，它本身包含了Docker客户端和Docker后台。Docker后台提供
Docker服务，外界通过套接字的方式对其进行访问。默认配置下，Docker后台只监听来自本地的 7
通信请求，这主要是出于安全考虑。例如，图中的本地客户端就可以直接和后台套接字进行API
通信。如果需要支持跨主机的API请求，我们需要在Docker后台启动时通过-H参数对指定或者全 9
部网络接口进行绑定。
8
10
10
11
13
14
15
图14-1 API中客户端和服务端的通信架构
16
14.2 绑定 Docker 后台监听接口
17
在这一节中，我们来详细说明参数-H的用法。前面提到，Docker是由Docker后台和客户端组
成的，而在默认配置下，Docker后台只接受来自本机的root用户的请求。事实上，Docker后台默
18
认监听的是unix//var/run/docker.sock套接字文件，该文件位于/var/run/目录下，读者可以通过ls命
156 第14章 Docker API
令来查看。那么，如果我想改变Docker后台的监听端口，甚至让其他主机也能够访问该后台服务，
我该怎么做呢？
通过-H参数，可以让Docker后台监听指定的IP和端口。-H接受如下格式的IP和端口绑定：
tcp://[host][:port]
或
unix://path
在开始绑定之前，我们需要先把已经运行的Docker后台停止。如果是Ubuntu系列的系统，可
以通过如下命令停止Docker后台：
$sudo service docker stop
如果是Red Hat系列，则为：
#systemctl stop docker.service
接下来，我们可以将本地所有网络接口的2376端口和Docker后端绑定。采用如下命令来启动
Docker后台：
$ sudo docker -H 0.0.0.0:2376 -d &
Docker后台启动后，它将监听本地所有网络接口的2376端口，客户端可以通过-H参数来访问
绑定后的端口，具体操作如下：
$ sudo docker -H tcp://127.0.0.1:2376 pull Ubuntu
此处的-H代表连接到指定IP和端口，而不是绑定。由此看出，-H参数在后台和客户端有着不
一样的含义。
此外，Docker后台同时接受多个端口的绑定，例如：
$ sudo docker -H tcp://127.0.0.1:2376 -H unix:///var/run/docker.sock -d &
$ sudo docker search ubuntu
$ sudo docker -H tcp://127.0.0.1:2376 pull ubuntu
上面的代码通过两次使用-H参数启动Docker后台，这样后台不仅监听127.0.0.1:2376的请求，
还监听/var/run/docker.sock上的请求。
除了使用命令行启动Docker后台外，一种更为持久化和自动化的方法是修改Docker服务的启
动脚本，这免去了我们每次宕机之后手动关闭服务再启动的麻烦。这里我们仅说明Ubuntu系列和
Red Hat系列如何操作。
1. Ubuntu和Debian系统
在Ubuntu或者Debian系统中，其配置为/etc/default/docker文件，打开该文件，其内容为：
14.2 绑定Docker后台监听接口 157
# Docker Upstart and SysVinit configuration file
1
# Customize location of Docker binary (especially for development testing).
#DOCKER="/usr/local/bin/docker"
# Use DOCKER_OPTS to modify the daemon startup options.
2
#DOCKER_OPTS="--dns 8.8.8.8 --dns 8.8.4.4"
# If you need Docker to use an HTTP proxy, it can also be specified here.
#export http_proxy="http://127.0.0.1:3128/"
3
# This is also a handy place to tweak where Docker's temporary files go.
#export TMPDIR="/mnt/bigdrive/docker-tmp"
4
将DOCKER_OPTS行改成：
DOCKER_OPTS="-H 0.0.0.0:2376 -H unix:///var/run/docker.sock"
5
保存后退出，然后重启服务使其生效。具体操作为：
$service docker stop 6
$service docker start
或者直接使用如下命令： 7
$service docker restart
9
2. Red Hat、Fedora和CentOS系统
Red Hat、Fedora和CentOS等系统，其配置为/usr/lib/system/system/docker.service文件，打开
8
该文件，其内容为：
[Unit] 10
Description=Docker Application Container Engine
Documentation=http://docs.docker.com
After=network.target docker.socket 10
Requires=docker.socket
[Service]
Type=notify 11
EnvironmentFile=-/etc/sysconfig/docker
EnvironmentFile=-/etc/sysconfig/docker-storage
ExecStart=/usr/bin/docker -d $OPTIONS $DOCKER_STORAGE_OPTIONS 13
LimitNOFILE=1048576
LimitNPROC=1048576
MountFlags=private 14
[Install]
WantedBy=multi-user.target
15
将下面这行代码：
ExecStart=/usr/bin/docker -d $OPTIONS $DOCKER_STORAGE_OPTIONS 16
改为：
17
ExecStart=/usr/bin/docker -d $OPTIONS $DOCKER_STORAGE_OPTIONS
-d --selinux-enabled -H tcp://0.0.0.0:2376 -H unix:///var/run/docker.sock
18
保存后退出，然后重启服务使其生效：
158 第14章 Docker API
#systemctl restart docker.service
接下来，我们就可以学习Docker API了。
14.3 远程 API
在这一节中，我们主要介绍远程API，它主要包含对容器和镜像的操作。和“docker+命令”
这种形式不一样，这里我们会一一说明常见的操作。为了便于演示，这里使用curl命令。它是一
款利用URL语法在命令行下工作的开源文件传输工具，广泛应用于Unix、多种Linux发型版本中。
当然，Windows系统下也有该工具的移植版本。
在第1章中，我们知道通过docker info命令可以查询当前Docker的系统信息。下面我们使用
API方法来获得同样的信息，其操作如下：
$ curl -X GET http://localhost:2376/info
{"Containers":4,"Debug":0,"Driver":"aufs","DriverStatus":[["Root Dir","/var/lib/docker/aufs"],
["Dirs","61"]],"ExecutionDriver":"native-0.2","IPv4Forwarding":1,"Images":53,"IndexServerAddress":
"https://index.docker.io/v1/","InitPath":"/usr/bin/docker","InitSha1":"","KernelVersion":"3.13.0-44-
generic","MemoryLimit":1,"NEventsListener":0,"NFd":10,"NGoroutines":10,"OperatingSystem":"Ubuntu
14.04.1 LTS","SwapLimit":0}
我们使用curl工具来请求http://locahost:2376/info，该路径用于获取Docker系统信息，-X参数
后面接想要执行的HTTP操作，这里是GET。可以看到，返回的信息与docker info命令一样。