title:Strongly secure certificateless key exchange without pairing
author:Guomin Yang and
Chik How Tan
Strongly Secure Certiﬁcateless Key Agreement
Georg Lippold, Colin Boyd, Juan Gonz´alez Nieto
July 28, 2010
Abstract
We introduce a formal model for certiﬁcateless authenticated key exchange (CL-AKE) protocols.
Contrary to what might be expected, we show that the natural combination of an ID-based AKE
protocol with a public key based AKE protocol cannot provide strong security. We provide the ﬁrst
one-round CL-AKE scheme proven secure in the random oracle model. We introduce two variants of
the Diﬃe-Hellman trapdoor introduced by [CKS08]. The proposed key agreement scheme is secure
as long as each party has at least one uncompromised secret. Thus, our scheme is secure even if the
key generation centre learns the ephemeral secrets of both parties.
1 Introduction
Certificateless encryption introduced by Al-Riyami and Paterson [ARP03] is a variant of identity
based encryption that limits the key escrow capabilities of the key generation centre, which is inherent
in identity based encryption [BF03]. Dent [Den08] published a survey of more than twenty certiﬁcateless
encryption schemes that focuses on the diﬀerent security models and the eﬃciency of the respective
schemes. In certiﬁcateless cryptography schemes, there are three secrets per party:
• The key issued by the key generation centre (Dent [Den08] calls it “partial private key”). We
assume in the following that this key is ID-based, although it does not necessarily have to be
ID-based.
• The user generated private key xID (Dent calls it “secret value”).
• The ephemeral value chosen randomly for each session.
Key agreement schemes provide an eﬃcient means for two parties to communicate over an adver-
sarial controlled channel. An overview of almost twenty identity based key agreement protocols has been
compiled by Chen, Cheng and Smart [CCS07]; they also provide security proofs for two of the surveyed
protocols. Many ID-based schemes guarantee full privacy for both parties as long as the key generation
centre (KGC) does not learn any of the ephemeral secrets used in computing the session key. But as
Krawczyk [Kra05] points out, the leakage of ephemeral keys should not be neglected as they are usually
precomputed and not stored in secure memory. In the context of identity based key agreement protocols,
this means that as soon as the ephemeral key of either party leaks, a malicious KGC is able to compute
the session key.
An overview of current certificateless key agreement schemes has been compiled by
Swanson [Swa08]. Certiﬁcateless key agreement schemes attempt to provide full privacy even if the
ephemeral secrets of the parties leak to the key generation centre or if the key generation centre actively
interferes with the messages that are exchanged (e.g. does a man-in-the-middle attack). The ﬁrst
certiﬁcateless key agreement scheme was published by Al-Riyami and Paterson [ARP03] as a side note to
their certiﬁcateless encryption scheme. However, they provided neither a security model for certiﬁcateless
key agreement schemes nor a proof of security for the scheme. Other certiﬁcateless key agreement schemes
were published by Mandt and Tan [MT06] and improved by Xia et al. [XWSX08], Wang, Cao and Wang
[WCW06], and Shao Zu-hua [Zh05], but the respective authors gave only heuristic arguments as to
why their schemes would be secure. Swanson [Swa08] analysed these certiﬁcateless schemes and showed
generic attacks that break the notions of security claimed by the respective authors. Swanson also posed
three open questions in the last chapter of her thesis that we will answer in this paper.
1
By combining an ID-based scheme with a public key based scheme, certiﬁcateless encryp-
tion [YL04a], [LQ06], certiﬁcateless signatures [YL04b], and certiﬁcateless key encapsulation mechanisms
[BFMLS08] can be readily constructed from existing protocols. Contrary to what would be expected,
we show that a certiﬁcateless key agreement protocol cannot be securely constructed by a natural com-
bination of an ID-based key agreement protocol with a public key based key agreement protocol.
The security model is an extension of Swanson’s [Swa08] modiﬁed version of the extended Canetti
and Krawczyk model presented in [LLM07] for certiﬁcateless key agreement. In this paper, we strengthen
the model further (thus giving more power to the adversary) and provide the ﬁrst formal proof for a
strongly secure certiﬁcateless key agreement scheme in the random oracle model. Moreover, the protocol
we propose is a one round protocol that withstands all of Swanson’s attacks, although the messages
exchanged in our protocol are exactly the same messages as in Mandt and Tan’s protocol [MT06]. To
withstand the attacks we use a modiﬁed version of the technique presented by Xia et al. [XWSX08].
We prove that our certiﬁcateless key agreement protocol is secure even if the key generation centre
actively tries to break the scheme: it may either reveal ephemeral secrets or reveal secret values / replace
public keys but not both. In fact, we show that as long as each party still has at least one uncompromised
secret, our scheme is still secure in the random oracle model assuming that the computational Diﬃe-
Hellman assumption and the computational bilinear Diﬃe-Hellman assumption hold. Our proofs are in
the strongest security model available for certiﬁcateless schemes, i.e.
it corresponds to Dent’s [Den08]
Strong Type I and Strong Type II security where the adversary is allowed to replace certiﬁcateless public
keys and the challenger still has to answer all oracle queries.
The main contributions of this paper are:
• Strongest formal model for secure authenticated certiﬁcateless key exchange protocols today. We
provide the equivalent of a strong decryption oracle [Den08] for reveal queries.
• An analysis of why certiﬁcateless key establishment schemes (CL-AKE) cannot be readily composed
by combining an ID-based authenticated key establishment (ID-AKE) scheme with a public key
authenticated key establishment (PK-AKE) scheme in our security model.
• First one-round protocol for certiﬁcateless key agreement with a security proof in the random
oracle model that fulﬁlls all notions of security of our model and withstands recent attacks on
certiﬁcateless key agreement protocols.
The organization of the paper is as follows: we introduce the security model in Section 2 and
relate it to existing notions of security for key agreement schemes and certiﬁcateless encryption. We also
show why a generic composition of ID-AKE with PK-AKE does not have suﬃcient security guarantees
in our model. A description of the scheme is given in Section 3 on page 6. Section 5 on page 10 discusses
the security proof of the new protocol. We conclude our paper by answering some open questions in
Section 6 on page 18.
2 Security model for certiﬁcateless key agreement schemes
The following security properties are commonly required of key establishment protocols in general.
Resistance to basic impersonation attacks. An adversary who does not know the private key of
party A should not be able to impersonate A.
Resistance to Unknown Key-Share (UKS) attacks. An adversary M interferes with two honest
parties A and B such that both parties accept the session and compute the same key. However,
while A thinks that the key is shared with B, B is convinced that the key is shared with M.
Known key security. Each run of a key agreement protocol between two parties A and B should
produce a unique session key. A protocol should not become insecure if the adversary has learned
some of the session keys [LMQ+03].
Weak Perfect Forward Secrecy (wPFS). A key-exchange protocol provides weak PFS (wPFS)
if an attacker M cannot distinguish from random a key of any session for which the session and
2
its matching session are clean1 even if M has learned the private keys of both peers to the ses-
sion [Kra05, Deﬁnition 22].
Resistance to Key-Compromise Impersonation (KCI) attacks. We say that a KE-attacker M
that has learned the private key of party ˆA succeeds in a Key-compromise impersonation (KCI)
attack against ˆA if M is able to distinguish from random the session key of a complete session at
ˆA for which the session peer is uncorrupted and the session and its matching session (if it exists)
are clean [Kra05, Deﬁnition 20].
Resistance to disclosure of ephemeral secrets. The protocol should be resistant to the disclo-
sure of ephemeral secrets. The disclosure of an ephemeral secret should not compromise the security
of sessions where the ephemeral secret was not used.
ID-based protocols usually require the following property in addition to these properties:
KGC forward secrecy The key generation centre (KGC) should be unable to compute the session
key knowing all publicly available information.
For certiﬁcateless protocols, we will additionally require the following property. Mandt & Tan [MT06]
call this property “Resistance to known session-speciﬁc temporary information”, but they provide only
an informal deﬁnition. It is not possible to provide this property in an ID-based key agreement scheme
since a KGC who knows the ephemeral secrets has all inputs to the session key.
Resistance to leakage of ephemeral secrets to the KGC. If a malicious KGC learns the ephemeral
secrets of any session, the KGC should not be able to compute the session key.
2.1 Formal deﬁnition of the security model
We present a strengthened version of Swanson’s [Swa08] model, which in turn is based on LaMacchia,
Lauter & Mityagin’s [LLM07] extended Canetti-Krawczyk (eCK) model. We discuss the changes to the
respective models in Section 2.2 on page 5.
Let U = {U1, . . . Un} be a set of parties. The protocol may be run between any two of these parties.
For each party there exists an identity based public key that can be derived from its identiﬁer. There is
a key generation centre that issues identity based private keys to the parties through a secure channel.
Additionally, the parties generate their own secret values and certiﬁcateless public keys.
The adversary is in control of the network over which protocol messages are exchanged. Πt
i,j represents
the tth protocol session which runs at party i with intended partner party j. Additionally, the adversary
is allowed to replace certiﬁcateless public keys that are used to compute the session key. The adversary
does not have to disclose the private key matching the replaced certiﬁcateless public key to the respective
party.
A session Πt
i,j enters an accepted state when it computes a session key SK t
i,j. Note that a session
may terminate without ever entering into an accepted state. The information of whether a session has
terminated with acceptance or without acceptance is assumed to be public. The session Πt
i,j is assigned
a partner ID pid = (IDi, IDj). The session ID sid of Πt
i,j at party i is the transcript of the messages
exchanged with party j during the session. Two sessions Πt
j,i are considered matching if they
have the same pid (and sid).
The game runs in two phases. During the ﬁrst phase of the game, the adversary M is allowed to
i,j and Πu
issue the following queries in any order:
Send(Πt
i,j, x): If the session Πt
i,j does not exist, it will be created as initiator at party i if x = λ, or
as a responder at party j otherwise. If the participating parties have not been initiated before,
the respective private and public keys are created. Upon receiving the message x, the protocol is
executed. After party i has sent and received the last set of messages speciﬁed by the protocol, it
outputs a decision indicating accepting or rejecting the session. In the case of one-round protocols,
party i behaves as follows:
x = λ: Party i generates an ephemeral value and responds with an outgoing message only.
1Roughly speaking clean is the same as fresh in Deﬁnition 1 on the following page.
3
x (cid:54)= λ: If party i is a responder, it generates an ephemeral value for the session and responds with
an outgoing message m and a decision indicating acceptance or rejection of the session. If
party i as an initiator, it responds with a decision indicating accepting or rejecting the session.
In this work, we require i (cid:54)= j, i.e. a party will not run a session with itself.
Reveal master key The adversary is given access to the master secret key.
Session key reveal(Πt
session key.
i,j): If the session has not accepted, it returns ⊥, otherwise it reveals the accepted
Reveal ID-based secret(i): Party i responds with its ID-based private key, e.g. sH1(IDi).
Reveal secret value(i): Party i responds with its secret value xi that corresponds to its certiﬁcateless
public key. If i has been asked the replace public key query before, it responds with ⊥.
Replace public key(i, pk): Party i’s certiﬁcateless public key is replaced with pk chosen by the adver-
sary. Party i will use the new public key for all communication and computation.
Reveal ephemeral key(Πt
i,j): Party i responds with the ephemeral secret used in session Πt
i,j
We can group the key reveal queries into three types: the reveal master key and reveal ID-based secret
queries try to undermine the security of the ID-based part of the scheme, the reveal secret value and
replace public key queries try to undermine the security of the public key based part of the scheme, and
the reveal ephemeral key query tries to undermine the security of one particular session.
We deﬁne the state fully corrupt as a session that was asked all three types of reveal queries: the
reveal master key or reveal ID-based secret, the reveal secret value or the replace public key, and the reveal
ephemeral key query.
Once the adversary M decides that the ﬁrst phase is over, it starts the second phase by choosing a
i,j) query, where the fresh session and test query are deﬁned as
i,j and issuing a Test(Πt
fresh session Πt
follows:
i,j is fresh if (1) Πt
Deﬁnition 1 (Fresh session). A session Πt
i,j is unopened (not
being issued the session key reveal query); (3) the session state at neither party participating in this
j,i which has a matching conversation to Πt
session is fully corrupted; (4) there is no opened session Πu
i,j.
i,j must be fresh. A bit b ∈ {0, 1} is randomly chosen. If b = 0, the
adversary is given the session key, otherwise it randomly samples a session key from the distribution
of valid session keys and returns it to the adversary.
i,j) The input session Πt
i,j has accepted; (2) Πt
Test(Πt
After the test(Πt
i,j) query has been issued, the adversary can continue querying except that the test
session Πt
i,j should remain fresh. We emphasize here that partial corruption is allowed as this is a beneﬁt
of our security model. Additionally, replace public key queries may be issued to any party after the test
session has been completed.
At the end of the game, the adversary outputs a guess ˆb for b. If ˆb = b, we say that the adversary
wins. The adversary’s advantage in winning the game is deﬁned as
(cid:12)(cid:12)(cid:12)(cid:12)Pr[M wins] − 1
2
(cid:12)(cid:12)(cid:12)(cid:12)
AdvM(k) =
Deﬁnition 2 (Strong Type I secure key agreement scheme). A certiﬁcateless key agreement scheme
is Strong Type I secure if every probabilistic, polynomial-time adversary M has negligible advantage in
winning the game described in Section 2.1 on the preceding page subject to the following constraints:
• M may corrupt at most two out of three types of secrets per party involved in the test session,
• M is allowed to replace public keys of any party; however, this counts as the corruption of one
secret,
• M may not reveal the secret value of any identity for which it has replaced the certiﬁcateless public
key,
4
• M is allowed to ask session key reveal queries even for session keys computed by identities where
M replaced the identity’s public key.
• M is allowed to replace public keys of any party after the test query has been issued.
Deﬁnition 3 (Strong Type II secure key agreement scheme). A certiﬁcateless key agreement scheme
is Strong Type II secure if every probabilistic, polynomial-time adversary M has negligible advantage in
winning the game described in Section 2.1 on page 3 subject to the following constraints:
• M is given the master secret key s at the start of the game,
• M may corrupt at most one additional type of secret per party participating in the test query,
• M is allowed to replace public keys of any party; however, this counts as the corruption of one
secret,
• M may not reveal the secret value of any identity for which it has replaced the certiﬁcateless public
key,
• M is allowed to ask session key reveal queries even for session keys computed by identities where
he replaced the identity’s public key.
• M is allowed to replace public keys of any party after the test query has been issued.
2.2 Relation to existing notions of security
Swanson’s [Swa08] replace public key query is weaker in assuming that the party whose key was replaced
continues to make its computations with its original (unreplaced) public key (and its matching private
key). Although it seems that Swanson’s model is more “natural” than our model, strong certiﬁcateless
encryption has been the goal of many papers, a discussion of the beneﬁts and drawbacks can be found
in [DLP08]. As it gives more power to the adversary, we think that schemes that are strongly secure are
preferable to those in a weaker security model.
When checking for a matching conversation, Swanson omits the certiﬁcateless public keys from the
conversation transcript. This weakens the adversary compared to our model, as the adversary would not
be allowed to replace public keys and try to replay the conversation with the replaced keys of the test