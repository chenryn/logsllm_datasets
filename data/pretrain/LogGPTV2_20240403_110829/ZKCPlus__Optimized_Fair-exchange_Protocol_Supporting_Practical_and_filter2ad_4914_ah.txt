lz = 
âŸ¨lz, rzâŸ© = 
iâˆˆ[m]
zi Â· li,
iâˆˆ[m]
rz = 
âŸ¨li, riâŸ© + 
+ 
iâˆˆ[m]
kâˆˆ[1â€“m,mâ€“1]\0
According to the Schwartz-Zippel lemma, apart from negligible
error 2m
|Fp|, the equation
âŸ¨lz, rzâŸ© = t
(50)
iâˆˆ[m]âŸ¨li, riâŸ© = t. So a sum of inner products reduces
kâˆˆ[1â€“m,mâ€“1]\0
tk Â· zk
to a single inner product; then the protocol in Figure 8 applies.
B.3 When some vectors are public
A slightly different case is that of some of the vectors, e.g. {ri} are
holds only if
public.
{Li âˆˆ G}iâˆˆ[m],
t âˆˆ Fp, {ri âˆˆ Fn
{li âˆˆ Fn
p}iâˆˆ[m],
{ğœ„i âˆˆ Fp}iâˆˆ[m]

âˆ§
p}iâˆˆ[m];
iâˆˆ[m]
Check(pp, Li, li, ğœ„i) = 1
iâˆˆ[m]âŸ¨li, riâŸ© = t
(51)
 .
Omitting the operations related to commitments R and Ri in
Figure 8, Figure 9, it is not difficult to construct an argument for
relation (51).
B.4 Recursive reduction
The reduction in Section B.2 involves computing and committing
the cross terms tk for k âˆˆ [1 â€“ m, m â€“ 1]\0, which corresponds to
O(m2n) multiplications in Fp and 2m scalar multiplications in G.
The cost becomes substantial when m is large. In this section we
Session 11B: Zero Knowledge II CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea3017describe a recursive protocol, which accomplishes the same task
of reducing a sum of inner products into one single inner product,
but with way less computational cost.
Public input: commitments {Li, Ri}iâˆˆ[m], T
Pâ€™s private input: {li, ri âˆˆ Fn
While m > 1 : m â† m/2
P : t+ = 
tâ€“ = 
p}iâˆˆ[m], t âˆˆ Fp, blinders {ğœ„i, ğœŒi}iâˆˆ[m], ğœ âˆˆ Fp
âŸ¨li, ri+mâŸ©,
iâˆˆm
iâˆˆm
(T +, ğœ+) â† Commit(pp, t+),
âŸ¨li+m, riâŸ©,
(T â€“, ğœâ€“) â† Commit(pp, tâ€“).
P â†’ V : T +, T â€“.
V â†’ P : u.
P : for i âˆˆ [m]
li â† u Â· li + uâ€“1 Â· li+m,
t â† t + u2 Â· t+ + uâ€“1 Â· tâ€“,
ğœ„i â† u Â· ğœ„i + uâ€“1 Â· ğœ„i+m,
ğœ â† ğœ + u2 Â· ğœ+ + uâ€“1 Â· ğœâ€“.
ri â† uâ€“1 Â· ri + u Â· ri+m,
ğœŒi â† u Â· ğœŒi + uâ€“1 Â· ğœŒi+m,
Li â† u Â· Li + uâ€“1 Â· Li+m,
T â† T + u2 Â· T + + uâ€“2 Â· T â€“.
Ri â† uâ€“1 Â· Ri + u Â· Ri+m,
P & V : for i âˆˆ [m]
Public input: commitments L1, R1, T
Pâ€™s private input: l1, r1 âˆˆ Fn
p, t âˆˆ Fp, blinders ğœ„1, ğœŒ1, ğœ âˆˆ Fp
Figure 10: Recursive argument for sum of inner products
The protocol takes log m rounds, where in each round on Vâ€™s
challenger u, P halves the number of vectors from m into mâ€² = m/2
by
that
iâˆˆ[mâ€²]
lâ€²
i = u Â· li + uâ€“1 Â· li+mâ€²,
âŸ¨li, riâŸ© + u2 Â· 
râ€²
i = uâ€“1 Â· ri + uk Â· ri+mâ€²,
âŸ¨li, ri+dâ€²âŸ© + uâ€“2 Â· 
âŸ¨lâ€²
i, râ€²
iâˆˆ[mâ€²]
iâˆˆ[mâ€²]
âŸ¨li, riâŸ© + u2 Â· t+ + uâ€“2 Â· tâ€“.
iâŸ© = 
= 
iâˆˆ[m]
iâˆˆ[m]
Summarizing all log m rounds, we have
(52)
âŸ¨li+dâ€², riâŸ©
(53)
(54)
where zi is the i-th element vector of z with a binary counting
structure
m
i=1
m
i=1
l =
zi Â· li,
r =
zâ€“1
i
Â· ri,
z =
(cid:169)(cid:173)(cid:173)(cid:173)(cid:173)(cid:173)(cid:173)(cid:171)
âŸ¨li, riâŸ© + 
u1 . . . ulog m
uâ€“1
1 . . . ulog m
...
uâ€“1
1 . . . uâ€“1
log m
(cid:170)(cid:174)(cid:174)(cid:174)(cid:174)(cid:174)(cid:174)(cid:172) ,
k + 
k Â· t+
u2
kâˆˆ[log m]
kâˆˆ[log m]
and their inner product
âŸ¨l, râŸ© = 
iâˆˆ[m]
According to the Schwartz-Zippel lemma, except for negligible
error 4Â·log m
|Fp|
, the equation
âŸ¨l, râŸ© = t + 
holds only if t =
kâˆˆ[log m]
iâˆˆ[m]âŸ¨li, riâŸ©.
k + 
kâˆˆ[log m]
k Â· t+
u2
uâ€“2 Â· tâ€“
k
(57)
This recursive reduction involves computing and committing
k for k âˆˆ [log m], costing O(mn) multiplications in Fp and
t+
k and tâ€“
2 log m scalar multiplications in G, a significant boost as compared
to that of Section B.2.
C Composition properties of CP-NIZK arguments
C.1 Conjunction of relations with shared inputs
With a computationally binding commitment scheme Com and
CP-NIZK arguments Î Com
which respectively attest-
ing relations R0(s0, u, aux0) = 1 and R1(s1, u, aux1) = 1, with the
common input u committed as c, one can build a CP-NIZK argu-
ment Î Comâˆ§
for conjunction Râˆ§ s.t. Râˆ§(s0, s1, u, aux0, aux1) = 1 iff
R0(s0, u, aux0) = 1 âˆ§ R1(s1, u, aux1) = 1:
â€¢ KeyGen(1ğœ†) â†’ ğœ: outputs ğœ = (ğœ0, ğœ1), where
and Î Com
0
1
ğœ0 â† Î Com
ğœ1 â† Î Com
0
1
.KeyGen(1ğœ†),
.KeyGen(1ğœ†);
â€¢ Prove(ğœ, s0, s1, c, u, aux0, aux1) â†’ ğœ‹: outputs ğœ‹ = (ğœ‹0, ğœ‹1) where
ğœ‹0 â† Î Com
ğœ‹1 â† Î Com
0
1
.Prove(ğœ, (s0, c), (u, aux0)),
.Prove(ğœ, (s1, c), (u, aux1));
â€¢ Verify(ğœ, s0, s1, c, ğœ‹) â†’ b: outputs b = b0 âˆ§ b1 where
0
b0 â† Î Com
b1 â† Î Com
1
The completeness of Î Comâˆ§
0
.Verify(ğœ, (s0, c), ğœ‹0),
.Verify(ğœ, (s1, c), ğœ‹1);
follows directly from the completenesse
. For knowledge soundness, if the proof ğœ‹ verifies,
, which invokes the
and outputs witnesses
of Î Com
one can construct an extractor Ext for Î Comâˆ§
extractor Ext0 and Ext1 for Î Com
(u0, aux0) and (u1, aux1) s.t. except for negligible error,
and Î Com
and Î Com
Com.Check(pp, c, u0, r0) = 1 âˆ§ R0(s0, u0, aux0) = 1
âˆ§ Com.Check(pp, c, u1, r1) = 1 âˆ§ R1(s1, u1, aux1) = 1.
1
0
1
Moreover, except for negligible possibility the identity u0 = u1
should hold, otherwise it breaks the binding property of Com. As
for zero-knowledge, one can simulate the proof ğœ‹ by combining the
simulated proofs ğœ‹0 and ğœ‹1 from the respective simulators for Î Com
and Î Com
C.2 Disjunction of relations with shared inputs
For relation R(s, u) define Ë†R(s, u, t) s.t.
0
1
.
(cid:40)
(55)
Ë†R(s, u, t) = 1 iff
R(s, u) = 1 âˆ§ t = 0,
R(s, u) = 0 âˆ§ t â‰  0.
(58)
uâ€“2 Â· tâ€“
k .
(56)
With this definition, the disjunction of relations is converted into
conjunctions. Specifically, for R0(s0, u) and R1(s1, u) with shared
inputs u, relation Râˆ¨ is defined as Râˆ¨(s0, s1, u) = 1 iff R0(s0, u) =
1 âˆ¨ R1(s1, u) = 1, which is equivalent to
Ë†R0(s0, u, t0) = 1 âˆ§ Ë†R1(s1, u, t1) = 1 âˆ§ t0 Â· t1 = 0.
(59)
Session 11B: Zero Knowledge II CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea3018C.3 Sequential composition of functions
Define relations Rg and Rh associated with functions g and h as
Rg(z, x, w) = 1 iff âˆƒ (x, w) s.t. g(x, w) = z,
Rh(s, z, y) = 1 iff âˆƒ (z, y) s.t. h(z, y) = s.
(60)
ture
Let f be the composition of g and h s.t. f (x, y, w) = h(g(x, w), y).
Then the relation associated with f , namelyâˆƒ (x, y, w) s.t f (x, y, w) =
s, can be reduced to conjunction of Rg and Rh
Rg(z, x, w) = 1 âˆ§ Rh(s, z, y) = 1.
(61)
D Proof for Theorem 3.1
Theorem 3.1 states that the argument in Figure 2 has perfect com-
pleteness, computational witness-extended emulation and PHVZK
under the discrete logarithm relation assumption.
Perfect completeness is straightforward.
To prove computational witness-extended emulation, we con-
struct an efficient extractor Ext, which runs P with n different y,
m different w, 2 different uk for k âˆˆ [0, log m] and 3 different e, in
total n Ã— m Ã— 2 Ã— log 2m Ã— 3 valid proof transcripts. For simplicity,
we denote K = [1 â€“ 2m, 2m â€“ 1]\0.
Choose 2 transcripts for e âˆˆ {e(1), e(2)} and fixed w, y, {uk}. From
the transmitted lâ€², Ext can extract ld, ğœ„d s.t. Ld = âŸ¨ld, GâŸ© + ğœ„d Â· H. If
for any other set of challenges Ext extracts different ld, ğœ„d then it
yields a non-trivial discrete logarithm relation among (H, G) w.r.t.
commitment Ld. With ld fixed, Ext can extract l, ğœ„ from transmitted
lâ€², ğœ„â€² by l = lâ€²â€“eÂ·ld, ğœ„ = ğœ„â€²â€“eÂ·ğœ„d. In case of Check(pp, Lâ€², lâ€², ğœ„â€²) = 1, it
must hold that âŸ¨l, GâŸ©+ğœ„Â·H = Lâ€²â€“eÂ·Ld = L, otherwise it yields a non-
trivial discrete relation among (H, G) with respect to L. Similarly,
Ext can extract r, ğœŒ from transmitted râ€², ğœŒâ€² s.t. âŸ¨r, GâŸ© + ğœŒ Â· H = Râ€² â€“
eÂ· Rd = R. For inner product, in case of Check(pp, T â€², âŸ¨lâ€², râ€²âŸ©, ğœâ€²) = 1,
by 3 transcripts with different e âˆˆ {e(1), e(2), e(3)}, Ext can extract ğœ
from transmitted ğœ s.t.
.
k
k=0
(62)
k Â· T +
u2
âŸ¨l, râŸ© Â· U + ğœ Â· H =
k Â· T â€“
k + uâ€“2
Choose 2 transcripts with different u0 âˆˆ {u(1)
0 , u(2)
0 } but same
uk for k âˆˆ [1, log m]. Correspondingly there are l âˆˆ {l(1), l(2)}, r âˆˆ
{r(1), r(2)}, and ğœ âˆˆ {ğœ(1), ğœ(2)}. Ext is able to compute from l âˆˆ {l(1), l(2)}
two vectors l1, l2 s.t. l = u0 Â· l1 + uâ€“1
Â· l2. Similarly, Ext recovers
0
r1, r2 s.t. r = u0 Â· r1 + uâ€“1
Â· r2. Moreover, their inner products must
0
satisfy the equation
âŸ¨l, râŸ© =
0 Â· âŸ¨l1, r2âŸ© + âŸ¨l2, r1âŸ©.
âŸ¨li, riâŸ© + u2
2
(63)
Run the process recursively, in the k-th round picking two different
uk, after log m more rounds, Ext will be able to construct {li}iâˆˆ[2m]
and {ri}iâˆˆ[2m] s.t.
log m
(cid:16)
(cid:17)
âŸ¨l, râŸ© =
âŸ¨li, riâŸ© +
âŸ¨li, ri+2kâŸ© + uâ€“2
k Â· 2k
i=1
âŸ¨li+2k, riâŸ©(cid:170)(cid:174)(cid:172) .
(64)
2m
i=1
Equations (62) and (64) imply that
i=1
log m
k=0
k Â· 2k
(cid:169)(cid:173)(cid:171)u2
2m
i=1
i=1
âŸ¨li, riâŸ© = 0.
To prove PSHVZK, we construct an efficient simulator Sim that
(65)
produces a distribution of transcripts
k , T â€“
tr = ({Vj}jâˆˆ[m], w, y, {T +