Current implementation of cputicks on ARM is very low precision which hurts
block profile and tracer.
http://gperftools.googlecode.com/svn/trunk/src/base/cycleclock.h  
contains lots of goodness, and in particular cputicks implementation for arm:
    #elif defined(ARMV3)
    #if defined(ARMV6)  // V6 is the earliest arch that has a standard cyclecount
        uint32 pmccntr;
        uint32 pmuseren;
        uint32 pmcntenset;
        // Read the user mode perf monitor counter access permissions.
        asm volatile ("mrc p15, 0, %0, c9, c14, 0" : "=r" (pmuseren));
        if (pmuseren & 1) {  // Allows reading perfmon counters for user mode code.
          asm volatile ("mrc p15, 0, %0, c9, c12, 1" : "=r" (pmcntenset));
          if (pmcntenset & 0x80000000ul) {  // Is it counting?
            asm volatile ("mrc p15, 0, %0, c9, c13, 0" : "=r" (pmccntr));
            // The counter is set up to count every 64th cycle
            return static_cast(pmccntr) * 64;  // Should optimize to << 6
          }
        }
    #endif
Should consider switching to it.
There is also an impl for power processors.