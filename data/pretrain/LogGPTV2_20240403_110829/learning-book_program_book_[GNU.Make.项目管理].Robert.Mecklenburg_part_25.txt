---
## Page 169
C与C++
159
者C源文件位于子目录中（比如lib/codec/codec.c），基本的编译规则.o：名.c将可以
正常运作。当源文件位于独立的目录时，我们可以通过vpath功能，指示make到何处
搜索源文件。但是当目标文件位于独立的目录中时，make根本无法判断目标文件位于
）
让make知道输出文件位于何处的唯一方法，就是以具体规则来链接源文件和目标文件：
$(BINARY_DIR)/1ib/codec/codec.o:1ib/codec/codec.c
而且必须为每个目标文件都这么做。
更糟的是，这个“工作目标/必要条件”对（pair）无法使用隐含规则.o：8.C。这
意味着，我们还必须提供命令脚本，这使得我们必须重复描述内置数据库中已有的内容，
也可能必须多次重复描述此脚本。这个问题同样也会出现在我们曾经用过的自动依存关
系产生规则中。如果必须为每个目标文件加人两项具体规则，makefile的维护工作将很
难以手动进行。然而，如果能通过函数来自动产生这些规则，将可让代码的重复性以及
维护的困难度降至最低：
#$(call one-compile-rule,binary-file,source-files)
define one-compile-rule
$1:s(call generated-source,$2)
S(COMPILE.C)$$@ $S$@
---
## Page 171
C与C++
161
lex规则现在被实现成一般的具体规则，不过yacc规则却被实现成一个模式规则。为
什么？因为yacc规则将会被用来建立两个工作目标：一个C源文件与一个头文件。如
果我们将yacc规则实现成一般的具体规则，make将会运行两次脚本：一次用来创建
C源文件，一次用来创建头文件。但是make会假设一个模式具有多个工作目标，所以如
果我们将yacc规则实现成模式规则，make只需运行一次就能同时更新两个工作目标。
如果可能，我将会使用较简单的方法从二进制文件树来进行编译的工作，而不会使用这
一节所展示的makefile。如你所见，当我们试着从源文件树来进行编译的工作，事情将
会立即复杂化（而且似乎会越来越恶化）。
只读的源文件树
一旦源文件树和二进制文件树分开之后，如果编译结果只会产生存放在源文件树中的二
进制文件，我们通常可以自由地将“引用源文件树”设置成只读。
在较简单的“从二进制文件树进行编译”的办法中，其所产生的文件将会被自动写人二
文件指定路径并非额外的工作，除非我们必须强迫自己记住这件事。
将“引用源文件树”设置成只读的其他障碍通常是自已强加的。前人所遗留下来的编译
系统通常包含了在源文件树中创建文件的动作，这是因为原来的作者并未考虑到使用只
读的源文件树有哪些优点。这些障碍包含了在源文件树中所产生的文件、记录文件以及
临时文件。要将这些文件移往输出文件树有时可能会很麻烦，但如果从单一源文件树来
建立多个二进制文件树是必要的，可行的替代方案就是维护多个相同的源文件树并且让
它们保持同步的状态。
产生依存关系
问题未解决。因此，这一节将会为已经提到的简单解决方案，提供若干替代方案（注1）。
特别是，稍早所提到的简单办法以及GNUmake在线手册中所提到的办法将会遇到以
下问题：
注1：这一节的内容有许多是GNUautomake工具的作者TomTromey（PI:EMAIL）
创造的，以及取材自PaulSmith（GNUmake的维护者）的网站hrtp://make.paulandlesley.org
上所提供的数据。
---
## Page 172
162
第八章
没有效率。当make发现某个依存文件不存在或尚未更新时，它就会更新.d文件并
且重新启动自己。如果在makefile的读取期间make会进行许多工作并分析依存图，
则重新读取makefile完全没有效率可言。
第一次建立工作目标，以及每当你加入新的源文件的时候，make都会产生警告信
息。以上的状况都会让依存文件关联到尚不存在的新源文件上，所以当make试图
读取依存文件的时候，会在产生依存文件之前先产生警告信息。这并不是无可挽回
的错误，不过相当烦人。
如果你移除了一个源文件，make将会在随后的编译过程中发生无可挽回的错误并
且停止运行。在此状况下会存在一个依存文件，它的必要条件包含了已移除的文
件。因为make无法找到已移除的文件，而且不知道如何编译它，所以make将会
输出如下的信息：
make:***No rule to make target foo.h,needed by foo.d.Stop.
此外，make也无法重建依存文件，因为已经发生如上的错误了。要解决此问题，
只能靠手动移除该依存文件，但因为通常很难找到这些文件，所以用户一般会删除
所有的依存文件以及进行清理的编译工作。当有文件被更名时，也会发生此错误。
请注意，将.c文件移除或更名所导致的问题并不如将头文件移除或更名所导致的问
题显著。这是因为.c文件将会自动从依存文件列表中移除，而且不会在编译过程中
发生错误。
Tromey的办法
让我们逐一探讨这些问题。
如何避免重新启动make？
经过深思熟虑之后，我们发现没有必要重新启动make（即重新读取makefile）。如果我
们说有一个依存文件需要更新，这表示它的必要条件中至少有一个已被变更，也就是说
我们必须更新工作自标。我们还发现这次执行make的时候也不需这么做，因为依存信
息并不会改变make的行为。但是我们需要更新依存文件，这样在make下次执行的时
候将会拥有完整的依存信息。
因为在这次执行make的时候，我们还不需要依存文件，所以我们可以在更新工作目标
的同时产生依存文件。我们可以将编译规则改写成同时更新依存文件来完成此事。
#$(call make-depend,source-file,object-file,depend-file)
define make-depend
$(SED）'s,\（SS(notdir $2）\)*:，SS（dir$2）$3:，>$3.tmp
---
## Page 173
C与C++
163
S（MV）$3.tmp $3
endef
8.0:8.c
s(cal1 make-depend,$$3.tmp
S(SED)-e‘s/#.*//
-e's/[:]*://
1
.//s$ss\\/s，-
-e/^ssss/d
-e's/$s$s/:/·$3.tmp>>$3.tmp
$（MV)$3.tmp $3
endef
我们将会对依存文件执行新的sed命令，以便产生额外的规则。这段sed程序代码将会
进行以下五种转换：
1.删除注释
2.
删除工作目标文件以及随后的空格
3.
删除结尾的空格
4.
删除空行
5.
为每行的结尾加上一个冒号
（GNUsed可以在单一命令行中对文件进行读取和追加的动作，这使得我们不必使用第
二个临时文件。此功能或许无法使用在其他系统上。）新的sed命令将会读取如下的输
人：
#any comments
target.o target.d:prereq1prereq2 prereq3\
prereq4
并且将它转换成：
prereqlprereq2 prereq3:
prereq4:
所以，make-depend会把这个新的输出附加到原来的依存文件中。这样就不会发生“No
ruletomaketarget”的错误了。
makedepend程序
到目前为止，大多数编译器所提供的-M选项已足够我们使用了，但如果此选项不存在
呢？还有比-M更好的选项可用吗？
---
## Page 175
C与C++
165
近来，大部分的C编译器皆已对“从源文件来产生make依存关系”提供若干支持，但
是不久之前的情况并非如此。XWindowSystem项目进行初期，他们实现了一个名为
makedepend的工具，此工具可用来从一组C或C++源文件推断出依存关系。你可以通
过Internet免费取得此工具。makedepend有点难用，因为它会把输出添加到makefile
中，但这并不是我们想要的结果。makedepena的输出会假设目标文件与源文件位于同
一个目录下，这意味着我们的sed表达式必须做如下的改变：
#$(callmake-depend,source-file,object-file,depend-file)
define make-depend
$（MAKEDEPEND）-f-S（CFLAGS）$（CPPFLAGS)$（TARGET_ARCH)$11\
$（SED）s，^.*/\（[/]*\.o\）*:，$（dir$2）\1$3：,>$3.tmp
$（SED)-e*s/#.*//
1