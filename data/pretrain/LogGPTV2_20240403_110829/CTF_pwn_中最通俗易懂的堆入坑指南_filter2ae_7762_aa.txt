# CTF pwn 中最通俗易懂的堆入坑指南
##### 译文声明
本文是翻译文章
译文仅供参考，具体内容表达以及含义原文为准。
## 前言
前段时间入门了 pwn
，慢慢掌握了一些栈上的一些攻击技巧，但是发现在比赛中堆的利用才是王道…无奈只能在堆上再花些功夫。但是发现入门堆不是一件容易的事，毕竟涉及到了内存管理的知识，比较复杂。所以笔者看了大量文章和接受了大牛的指点，决定对堆中的一些基本概念进行总结，还恳请师傅们斧正~
这里不会讲太多的原理性（函数源码的实现等等）的东西，尽量以最简单的形式再结合一下小例子来揭开堆和内存管理的神秘面纱。
## 什么是堆？
首先先明确一下堆的概念，堆不同于栈，堆是动态分配的（由操作系统内核或者堆管理器），只有在程序中需要时才会分配。在 CTF 的 pwn
程序中，栈是程序加载进内存后就会出现，而堆是由 malloc、alloc、realloc 函数分配内存后才会出现。
  * windows 和 linux 下的堆分配、管理方式都不同， **这里主要讲到的是 CTF 中常出现的 linux 下的堆分配知识**
先看看堆在虚拟内存中的位置
  * **堆的生长方向是从低地址向高地址生长的，而栈是从高地址向低地址生长的。**
实际上堆可以申请到的内存空间比栈要大很多，在 linux 的 4G 的虚拟内存空间里最高可以达到 2.9 G 的空间
> 对堆操作的 **是由堆管理器（ptmalloc2）来实现的，而不是操作系统内核**
> 。因为程序每次申请或者释放堆时都需要进行系统调用，系统调用的开销巨大，当频繁进行堆操作时，就会严重影响程序的性能
下面的分析都是以 **glibc 库下的 ptmalloc2 堆管理器** 来讲解的。
## 堆的基本结构
先简单的画一个图吧：
1.pre size 字段。 **只有在前面一个堆块是空闲的时候才有指** ，用来指示前一个堆块的大小。前面一个堆块在使用时，他的值始终为 0  
2.size 字段。是用来指示当前堆块的大小的（头部加上 user data 的大小）。但是这个字段的最后三位相当于三个 flag ，有另外的作用。
这三位的作用分别是：
    1.NON_MAIN_ARENA     这个堆块是否位于主线程
    2.IS_MAPPED          记录当前 chunk 是否是由 mmap 分配的
    3.PREV_INUSE         记录前一个 chunk 块是否被分配
这里重点讲解最后一位： **用来记录前一个 chunk 块是否被分配，被分配的话这个字段的值为 1** ，所以经常会在已分配的堆块中的 size
字段中发现值比原来大 1 个字节。
  * 所以前一个堆块的释放与否都和这两个字段（pre_size、size）的值有关，这是因为便于内存的释放操作（free）  
4.user data 顾名思义就是用来存放用户数据的。
使用 malloc 函数分配到的内存的返回值指针是 **指向 user data （用户数据区）** ，在后面的例子中也会讲到这个问题。
**例如在 64 位程序中：**
    malloc(8)
申请到的堆块总大小为 16 + 8 + 8 + 1 = 0x21
1.第一个 16 字节是 **系统最小分配的内存** ，也就是说你如果想要申请的内存小于系统最小分配的内存的话，就会按照最小的内存来分配。
  * 在 64 位系统中这个值是 16 个字节，在 32 位系统中是 8 个字节
  * 例如，如果代码中是 malloc(0) 的话， **堆管理器也会分配最小内存空间给你**
2.第二个 8 字节是 pre size 字段的大小（32 位的为 4 字节）  
3.第三个 8 字节为 size 字段的大小（32 位的为 4 字节）  
4.最后一个 1 字节是 **PREV_INUSE 的值，只有 0 或 1两个值**
说了这么多的理论肯定会有点头大，不过没关系。在后面会有实例讲解，动手调试的时候对照着每一个字段分析就会好点。
## 指针与地址
指针这一块知识在 c 语言里学的不太好的，可以在学习堆的过程中慢慢巩固一下知识。
  * 熟练掌握指针的使用在堆的题目分析中还是很有帮助的。下面简单说一下堆分配中的指针会用到了地方。
首先要明确用户在调用 malloc 函数时返回的值为 **一个指针，指向分配到堆空间（用户数据区）** ，这个在最前面的那个图片也已经标出来了。
有时候题目是以更复杂的情况，用指针来表示某个数据结构的，例如下面的这个图中的例子：
first chunk（second chunk）表示第一和第二个结构， **每个结构中都有一个 point_heap
指针来指向存储用户数据的堆块（chunk）。**
**左边的这个本身就是一个堆块，用来存放一些全局信息** 。比如 max_size 存储了能够存储的最大结构数量；exist_num
表示已经存储的结构的数量。
###  IDA 中常见的指针表示形式
在 IDA 伪代码中的指针形式形如下面的情况：
    *(qword_6020A8 + 8)
**表示取到 qword_6020A8 这个地址加 8 偏移的那个地址存储的值**
汇编代码等同于：
    .text:0000000000400F85                 mov     rax, cs:qword_6020A8
    .text:0000000000400F8C                 mov     rax, [rax+8]
简单转化一下，也就是：
    *(addr) = [addr]
###  链表
在 pwn 的堆题目中，经常会有像一些”笔记管理系统”之类的题目，例如下面这里例子
代码提供了最基本的增删查改的功能。这个”笔记”的数据结构 **通常就是使用链表连接起来的** ，记录了当前 note 的大小、属性、内容等等。
**例如，下面这个例子就是以指针为基础来存储这个 note 结构的** 。这里的 i 代表 note 的索引，若这里的 i = 0 时：
_(qword_6020A8 + 16) 就 _*代表从 qword_6020A8 这个地址出再往后偏移 16 个字节，取到这个地址存储的值，接着把 1
赋值给这个地方（也就是把 1 存入这个地址）__
同样的 *(qword_6020A8 + 24) 就代表偏移 24 个字节处的值为 len
依次类推就可以在 **不连续的内存空间中** ，把整个 note 的数据结构存储下来了。
## 申请堆块的本质
> 堆管理器 ptmalloc2 主要是通过 malloc/free 函数来分配和释放内存块。
ptmalloc2 的作用通俗的讲就是 **相当于一个”中间商”** ，在程序想要申请向系统申请堆空间时，这里的 ptmalloc2
就会申请一块很大的空间，并根据算法从这些内存中把空间真正的分配给程序。
简单点说就是下面这个图中的情况：
这里的举一个最简单的例子：
    #include 
    #include 
    int main(){
            char *p;
            p = malloc(10);
            return 0;
    }
在 gdb 中进行调试，在 call malloc 处下一个断点， **在这里使用 vmmap 命令，查看内存分布** 。可以看到此时并没有发现堆段
单步 n ，vmmap 命令再次查看内存，发现出现了堆段
但是这里我们明明只是申请了 10 字节的大小，但是为什么这里的为什么给了这么大的堆段呢？
    0x00602000     ~    0x00623000
计算一下，刚好是 132 kB
    (0x00623000-0x00602000)/1024 = 132 kB
> 原来这132KB的堆空间叫做arena，此时因为是主线程分配的，所以这个区域叫做 main arena
也就是说这 132 KB 是”厂家”（内核）批发给”中间商”（ptmalloc2）的货物，
**以便下次程序在向系统申请小内存的时候，直接去”中间商”去取就行了** ，他就会在这 132KB
中按照要申请”货物”的多少进行分配下去。若”中间商”缺货了话，ptmalloc2 就继续去找”厂家”（系统内核）去取货
###  查看已分配的堆内存分布