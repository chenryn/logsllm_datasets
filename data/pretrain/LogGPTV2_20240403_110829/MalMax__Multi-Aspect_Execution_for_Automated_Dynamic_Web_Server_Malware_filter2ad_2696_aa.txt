title:MalMax: Multi-Aspect Execution for Automated Dynamic Web Server Malware
Analysis
author:Abbas Naderi-Afooshteh and
Yonghwi Kwon and
Anh Nguyen-Tuong and
Ali Razmjoo-Qalaei and
Mohammad-Reza Zamiri-Gourabi and
Jack W. Davidson
MalMax: Multi-Aspect Execution for Automated
Dynamic Web Server Malware Analysis
Abbas Naderi-Afooshteh1, Yonghwi Kwon1, Anh Nguyen-Tuong1, Ali Razmjoo-Qalaei2,
Mohammad-Reza Zamiri-Gourabi2, and Jack W. Davidson1
1University of Virginia
2ZDResearch
{abiusx,yongkwon,nguyen,jwd}@virginia.edu
{razmjoo,zamiri}@zdresearch.com
ABSTRACT
This paper presents MalMax, a novel system to detect server-
side malware that routinely employ sophisticated polymorphic eva-
sive runtime code generation techniques. When MalMax encoun-
ters an execution point that presents multiple possible execution
paths (e.g., via predicates and/or dynamic code), it explores these
paths through counterfactual execution of code sandboxed within
an isolated execution environment. Furthermore, a unique feature
of MalMax is its cooperative isolated execution model in which
unresolved artifacts (e.g., variables, functions, and classes) within
one execution context can be concretized using values from other
execution contexts. Such cooperation dramatically amplifies the
reach of counterfactual execution. As an example, for Wordpress,
cooperation results in 63% additional code coverage.
The combination of counterfactual execution and cooperative
isolated execution enables MalMax to accurately and effectively
identify malicious behavior. Using a large (1 terabyte) real-world
dataset of PHP web applications collected from a commercial web
hosting company, we performed an extensive evaluation of Mal-
Max. We evaluated the effectiveness of MalMax by comparing its
ability to detect malware against VirusTotal, a malware detector
that aggregates many diverse scanners. Our evaluation results show
that MalMax is highly effective in exposing malicious behavior in
complicated polymorphic malware. MalMax was also able to iden-
tify 1,485 malware samples that are not detected by any existing
state-of-the-art tool, even after 7 months in the wild.
CCS CONCEPTS
• Security and privacy → Malware and its mitigation; Web
application security; Systems security.
KEYWORDS
PHP, Security, Malware, Multi-Aspect Execution, Counterfactual
Execution
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for profit or commercial advantage and that copies bear this notice and the full citation
on the first page. Copyrights for components of this work owned by others than ACM
must be honored. Abstracting with credit is permitted. To copy otherwise, or republish,
to post on servers or to redistribute to lists, requires prior specific permission and/or a
fee. Request permissions from permissions@acm.org.
CCS ’19, November 11–15, 2019, London, United Kingdom
© 2019 Association for Computing Machinery.
ACM ISBN 978-1-4503-6747-9/19/11...$15.00
https://doi.org/10.1145/3319535.3363199
ACM Reference Format:
Abbas Naderi-Afooshteh, Yonghwi Kwon, Anh Nguyen-Tuong, Ali Razmjoo-
Qalaei, Mohammad-Reza Zamiri-Gourabi, and Jack W. Davidson. 2019. Mal-
Max: Multi-Aspect Execution for Automated Dynamic Web Server Malware
Analysis. In 2019 ACM SIGSAC Conference on Computer and Communications
Security (CCS’19), November 11–15, 2019, London, United Kingdom. ACM,
New York, NY, USA, 18 pages. https://doi.org/10.1145/3319535.3363199
1 INTRODUCTION
Web-based malware (both server-side and client-side) continue
to be one of the top security threats to users of the Internet. Server-
side malware, unlike client-side malware, can have much more
catastrophic consequences. For example, they can persist and com-
promise clients from all over the world for a long period of time.
Moreover, server-side malware can be leveraged to construct mali-
cious infrastructures (e.g., botnets).
Unfortunately, despite the importance of detecting and prevent-
ing server-side malware, existing techniques have difficulty han-
dling sophisticated server-side malware. Numerous reports describe
the prevalence of server-side malware:
• Sucuri, a firm specializing in managed security and system
protection, analyzed 34,371 infected websites and reported
that 71% contained PHP-based, hidden backdoors [66].
• Incapsula discovered that out of 500 infected websites de-
tected on their network, the majority of them contained PHP
malware [28].
• Verizon’s 2017 Data Breach Report reported that a sizable
number of web server compromises are a means to an end,
allowing attackers to set up for other targets [27].
This prevalence is, in part, because server-side malware typically
employs various advanced anti-analysis and anti-debugging tech-
niques such as obfuscation and metamorphism. Additionally, these
techniques are implemented using dynamic language features such
as dynamic code generation (e.g., eval), creating several challeng-
ing analysis problems including constructing a sound or complete
control flow graph (CFG), type inference, error handling, and alias
inference [25, 33]. Consequently, analysis of dynamic applications
is an area of active research [2, 3, 12, 19, 65, 76].
Several prior research efforts have focused on web-based mal-
ware [9, 11, 29, 40, 65], attempting to detect malware by analyzing
network traffic generated by malware (e.g., HTTP responses). How-
ever, evasive malware avoid detection by omitting signals of mali-
cious behavior. For example, they only trigger malicious behaviors
randomly or for a subset of clients. There has also been a surge of
machine learning (ML) approaches for extracting signatures and
classifiers to detect malware. However, the highly dynamic and
metamorphic (e.g., use of encryption, obfuscation and restructur-
ing techniques) nature of web server malware makes it difficult to
obtain large-scale datasets to train sufficiently accurate models [12].
In this paper, we present MalMax, a novel system for the ac-
curate detection of highly sophisticated PHP-based server-side
malware. We choose PHP malware as it is the most prevalent form
of web server malware and more than 79% of all web servers use
PHP [71]. MalMax enables accurate analysis of dynamic code such
as those commonly used by web applications. MalMax systemati-
cally exposes multiple aspects of a target program, including hidden
malicious behaviors, using a combination of counterfactual execu-
tion and cooperative isolated execution. Counterfactual execution
is a technique that forces execution into branches even if branch
conditions are not satisfied (Section 3.1) and cooperative isolated ex-
ecution shares global scope artifacts (e.g., global variables) between
isolated execution paths to facilitate code discovery (Section 3.2).
MalMax outperforms state-of-the-art malware detection tech-
• Development of MalMax, an analysis infrastructure that
uses a combination of counterfactual execution and cooper-
ative sandboxing to deeply explore dynamic behavior.
• A practical tool, PhpMalScan, for detecting server-side mal-
• An open-source malware benchmark suite designed to eval-
uate false positive and negative rates that includes 53 diverse
real-world PHP malware samples as well as 10 synthetic
benign and malicious samples.
• An evaluation using both the benchmark suite and 1 TB of
real-world website deployments that shows MalMax outper-
forming VirusTotal (VT) in terms of both false positives and
false negatives. MalMax identifies 1,485 malware samples
that go undetected by VT even after 7 months in the wild.
Scope. The following list contrasts different aspects of our work
with other research in the area to draw a clear scope.
niques. The main contributions of this research are as follows:
ware that leverages MalMax’s exploration capabilities.
1) Web Server-side Malware vs. Client-side Malware: This research
focuses on identifying malicious behaviors of web server malware.
Unlike client-side malware where no source code is available on
victim machines, source code of web server malware is typically
available for analysis. Hence, our technique analyzes source code.
2) Scripting vs. Binary: This research focuses on dynamic script-
ing languages such as PHP. Scripting code is typically much more
dynamic compared to binaries and commonly modifies itself to
generate new code on demand at runtime.
3) Detecting on Server-side vs. Detecting on Client-side: MalMax
intends to detect malware on the server while having access to the
server-side. This goal is in contrast with the majority of previous
work which attempts to find malware from its client-side output
(i.e., HTML and JavaScript). As many malware do not disclose their
malicious behavior in the client observable output unless specific
criteria are met, such detection is not as effective.
4) General Analysis Infrastructure: MalMax aims to provide
a general malware analysis infrastructure that can disclose mali-
cious behaviors of dynamic and evasive web server malware au-
tomatically. In this paper, we also present a fully automated proof
of concept malware detection tool, PhpMalScan, to demonstrate
MalMax’s effectiveness in practice. However, limitations of Php-
MalScan do not necessarily indicate MalMax is limited.
2 BACKGROUND: WEB SERVER MALWARE
PHP malware is the most prevalent web server malware and it is
typically used to infect a web server. As most server-side scripting
languages are executed on demand when a client accesses certain
web pages, PHP malware on a web server cannot run on its own
or at a predetermined time and condition. It requires intervention,
either via a victim user browsing the infected website to trigger
execution, or via the malware controller (called attacker henceforth)
manually triggering the malware.
We observe that, unlike client-side malware, web server malware
sometimes leverage an attacker provided value in order to hide
its malicious logic. For instance, malware may check the attacker
provided input and not exhibit any malicious behavior unless the
input satisfies certain criteria. As PHP is a highly dynamic language,
it is challenging to analyze and detect such evasive malware without
knowing the triggering criteria (e.g., malware requiring a hard-
coded password to reveal itself). Moreover, web server malware,
particularly PHP malware, is usually injected into benign PHP
program files. As it is difficult to distinguish injected malicious code
from the benign application, analysis techniques that target these
malware must be able to handle complex benign programs. The
focus of this research is discovering and detecting such malware.
Web server malware is either dropped by an attacker manually
or injected into the website by an automated attacker (i.e., a script)
post exploitation. Web applications may have vulnerabilities that,
when exploited, enable an attacker to gain access to the server and
establish a foothold by uploading the malware. The malware can be
a standalone file in an area that does not raise suspicion (such as the
temporary folder, cache folder, uploads folder or library folder), or it
can be incorporated into one of the key files of the web application
available on the server. The latter makes it harder to detect the
malware as the web application must be initiated and executed, and
the execution must reach the malware code thereby activating it.
Malware Categorization. We divide web-server malware into a
few categories based on their behaviors and ultimate purpose.
1) Webshell: Webshell is the most common type of web-server
malware. It provides ssh-like access to the web server via a web
interface. A webshell can be as simple as piping to bash, or may
include user interfaces which list files and system configurations.
2) Backdoor/Backconnect: Backdoors and backconnects enable
an attacker to execute an arbitrary system or PHP functionality on
the victim machine via HTTP or a network socket.
3) Flooder: Flooders send bursts of network packets to specified
machines when directed by the attacker. They are used to carry out
Denial of Service (DoS) or Distributed DoS attacks.
4) Spammer: Spammers infect servers trusted by other email
servers (e.g., new servers using fresh IPs) to send spoof/spam emails.
5) Bruteforcer: They use brute force approaches (e.g., trying
different passwords) to gain access to services on the Internet or
the local network. Once a credential is successfully guessed, the
attacker would use that foothold to carry out further attacks.
6) Bypasser: Bypassers attempt to bypass local or remote security
precautions. Examples would be bypassing chroot via symlinks,
bypassing PHP/Apache security modules, firewalls, and IDSs.
7) Defacer/Uploader: Defacers and uploaders are used to upload
attacker content to the web server. Attackers use them to leave an
obvious trace to claim credit for the hack.
3 DESIGN
As shown in prior research, purely static analysis of dynamic
code, particularly that of an obfuscated malware, is particularly
challenging [12, 25]. To analyze dynamic web server malware, we
propose a novel dynamic analysis approach called Multi-Aspect
Execution (MaX) that can reveal masked malicious behaviors of
highly evasive web server malware (Section 3.1). Intuitively, it at-
tempts to explore multiple aspects of malware by exercising multi-
ple execution paths in cooperative isolated execution environments
(Section 3.2). Each execution is isolated so that it does not affect
analyses of other executions, while the global scope artifacts (e.g.,
database connections stored in global variables) are shared between
isolated executions to facilitate the analysis.
3.1 Multi-Aspect Execution (MaX)
MalMax systematically explores multiple aspects of a target
program in order to expose potential malicious execution paths.
Specifically, MalMax employs counterfactual execution, a multi-
path exploration approach coupled with cooperative state isolation
that shares important artifacts among isolated executions to facili-
tate discovery of more code for malicious behavior discovery.
Counterfactual Execution. MalMax enables discovering parts
of code that would not be accessible in a vanilla dynamic analy-
sis [60] via a concept called counterfactual execution which forces
execution into branches even if the branch conditions are not satis-
fied, past exit nodes, and into pieces of code that are not normally
executed. Such counterfactual execution relies on state isolation to
track changes made to the execution state when exploring counter-
factual paths, and supports fine-grained control over state changes
(e.g., reversing and backporting). This feature enables our approach
to unwrap, decode, and expose the original code of obfuscated and
encoded files while maintaining a valid state throughout execution,
minimizing false positives and negatives.
Counterfactual execution handles dynamic constructs such as
eval(), include(), and dynamic function calls, each of which
might lead to discovery of new code snippets and generation of
new paths along the program execution. It analyzes dynamically
generated code recursively until it is not able to discover any new
unique code (i.e., a fixed point is reached).
Figure 1: Evasive Malware Example.
We use an example malware program to show how counterfac-
tual execution systematically explores multiple execution paths. In
Fig. 1-(a), line 1 checks if an input is provided to the script. When
no input is available, line 2 exits the script with a message (die()
is the exit expression in PHP). Line 3 checks to make sure that the
provided input is the expected password. If not, it simply copies
the malware on line 10 and terminates. If the correct password is
provided, there is a loop to prevent recognition of the maliciousness
of the script. After 200 iterations, and only when the loop counter is
a multiple of 11, the script performs its malicious activity (e.g., send
spam email). A naive dynamic analysis will be unable to expose the
malicious behavior as it will be unable to drive execution past lines
2 and 3, resulting in missing the entire malicious logic.
Counterfactual execution handles this issue by creating a new
isolated execution on a predicate or on terminal events (i.e., exit
expressions). Fig. 1-(b) shows traces (i.e., executed source code
line numbers) from a naive dynamic analysis and the proposed
counterfactual execution. Dynamic analysis only covers 2 lines due
to the missing input at line 1.
Counterfactual execution creates a new isolated state on line
2 (a terminal event) and continues past the termination. On line
3, it enters the branch even if the condition is not satisfied, while
creating another (nested) state isolation. Then, the loop on line 4 is
executed. Within the loop there is also a predicate on line 5 where
we create a new isolated state on line 5, exploring the malicious
execution path on line 6. While we successfully force the execution
paths including the malicious function, we observe that at least one
real-world sample does not properly expose malicious behavior.
We analyzed this case manually and found that it is because the
malicious code is dependent on variables evaluated on other paths
(e.g., Line 8 in our case). For instance, we observe that it increments
a variable within do_benign() and the variable is used to decode
malicious code in do_malicious(). Hence, the execution fails if
we do not execute the other path in the for-loop on line 4. To detect
such cases where there are dependencies between the new isolated
executions and other executions, we track data dependencies across
executions. Specifically, if a variable used in an isolated execution is
referenced by other executions later, we consider there are depen-
dencies between the executions. For the cases with dependencies,
a straightforward approach to handle them is to actually execute
the loop without any intervention.
Key Points: Counterfactual execution forces execution into
branches even if the branch conditions are not satisfied, past
exit nodes, and into pieces of code that are not normally executed,
enabling discovery of dynamically generated code recursively
until we comprehensively cover them. To this end, MalMax effec-
tively exposes hidden malicious code in sophisticated malware.
Control Flow Trimming. PHP malware often include intention-
ally long-running loops to delay execution of malicious behaviors.
As many dynamic analysis based malware detectors terminate their
analyses after certain timeouts (e.g., 30 seconds), those malware
may not be detected. A naive approach to handle such malware is
to limit the number of loop iterations. However, if the execution of
PHP malware is dependent on the number of loop iterations and
a particular path within the loop, the execution may not exhibit
malicious behaviors when we limit the number of loop iterations.