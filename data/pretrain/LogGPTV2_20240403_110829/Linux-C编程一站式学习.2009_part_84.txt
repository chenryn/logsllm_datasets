序号是1001，
的SYN位置1，32位序号是8000，该段不携带有效载荷（数据字节数为0），ACK位置1，32位确认
要信息在箭头上标出，
另一端也需要时间，
闭连接。两条竖线表示通讯的两端，
在这个例子中,
下图是一次TCP通讯的时序图。
3．客户端发出段3，对服务器的连接请求进行应答，
2
1．客户端发出段1,
请求，同时也给客户端发出一个连接请求，同时声明最大尺寸为1024。
序号1000及其以前所有的段，
服务器发出段2，
况，客户端声明自己的最大段尺寸，建议服务器端发来的段不要超过这个长度。
据
序
connectio
connectiog
图 36.13.TCP连接建立断开
establish
每发一个数据字节，
close
但是由于发了SYN位，
也可以发现丢包的情况，
十
，带有一
 首先客户端主动发起连接、
封装成帧后超过了
....
.....4
10
3
client
一个mss选项值为1024。
所以图中的箭头都是斜的。双方发送的段按时间顺序编号为1-10，各段中的主
，也带有SYN位,
，SYN位表示连接请求。序号是1000，
例如段2的箭头上标着SYN,8000(0),ACK 1001，，
SYN, 8000(0), ACK 1001, 
SYN, 1000(0), 
FIN,8011(0)ACK1022
FIN, 1021(0), ACK 8011
8001( 10),ACK 1021
 这个序号要加1,
100 1(20), ACK 8001
 因此下次再发送应该用序号1001。mss表示最大段尺寸,
ACK 8012
ACK 1022
ACK 8011
ACK 8001
请你下次发送序号为1001的段",
了链路层的最大帧长度,
另外，
从上到下表示时间的先后顺序，
同时置ACK位表示确认，
 规定SYN位和FIN位也要占一个序号，
 发送请求,
 这样在接收端可以根据序号排出数据包的正确顺
seryer
6
2
，确认序号是8001。
 然后服务器端响应请求,
就必须在IP层分片，
，这个序号在网络通讯中用作临时的地
，确认序号是1001，
注意，
也就是应答了客户端的连接
，数据从一端传到网络的
为了避免这种情
，这次虽然没发数
 然后客户端主动关
表示"我接收到
 表示该段中
如果
692
---
## Page 693
务器了，
并在一个段中，
建立连接的过程是三方握手，
关闭连接的过程：
向的数据传输，
如果通讯过程只能采用一问一答的方式，收和发两个方向不能同时传输，在同一时间只允许一个方
典型的情景是客户端主动请求服务器被动应答，
这个例子只描述了最简单的一问一答的情景，
回的ACK段，经过等待超时后TCP协议自动将发送缓冲区中的数据包重发。
实发到了对方,
在TCP层的发送缓冲区中，
在数据传输过程中，ACK和确认序号是非常重要的，
数据传输的过程：
端的telnet程序收到RST段后报告错误Connection refused：
口，我们却用telnet客户端去连接它，服务器收到客户端发来的SYN段就会应答一个RST段，客户
一套序号就够了，不需要通讯双方各自维护一套序号，想一想为什么。
使用这个端口，
在TCP通讯中，
尺
的请求和应答在一
在这个过程中，
4．客户端发出段10，应答服务器的关闭连接请求。
1．客户端发出段7，FIN位表示关闭连接的请求。
全双工（ful-duplex）的服务，双方都可以主动甚至同时给对方发送数据。
3．客户端发出段6,
2
1．客户端发出段4，包含从序号1001开始的20个字节数据。
寸等。
2i
．服务器发出段9，其中也包含FIN位，向客户端发送关闭连接请求。
。服务器发出段8，应答客户端的关闭连接请求。
。服务器发出段5，确认序号为1021，
号8011开始的数据。
据，这称为piggyback。
序号1021开始的数据，服务器在应答的同时也向客户端发送从序号8001开始的10个字节数
，但是服务器还可以发送数据给客户端，直到服务器也关闭连接为止，稍后会看到这样的例
celnet: Unable to connect to remote host: Connection refused
Trying
S
因为有连接半关闭的情况，这种情况下客户端关闭连接之后就不能再发送数据给服
，则称为"半双工（half-duplex）“
，就会应答一个包含RST位的段给另一方。
 可以从发送缓冲区中释放掉了
，如果一方收到另一方发来的段，
，客户端和服务器分别给对方发了连接请求，也应答了对方的连接请求，其中服务器
192.
一个段中发出，
，对服务器发来的序号为8001-8010的数据表示确认收到，请求发送序
 发出数据包给对方之后，
而关闭连接通常需要4个段,
，因此一共有三个段用于建立连接，称为"三方握手（three-way-
，对序号为1001-1020的数据表示确认收到，
，实际的TCP数据传输过程可以收发很多数据段,
，读出其中的目的端口号，
但也不是必须如此,
，假设某种面向连接的协议是半双工的，则只需要
，应用程序交给TCP协议发送的数据会暂存
只有收到对方应答的ACK段才知道该数据包确
。例如，服务器并没有任何进程使用8080端
 服务器的应答和关闭连接请求通常不合
事实上TCP协议为应用层提供
，发现本机并没有任何进程
，同时请求发送
693
虽然
---
## Page 694
较慢，而接收缓冲区的大小是固定的，
介绍UDP时我们描述了这样的问题：如果发送端发送的速度较快，
7.3.流量控制 请点评
Window）"机制解决这一问题。看下图的通讯过程。
3.
到6K数据的同时声明窗口大小为2K。
接收端的应用程序提走2K数据，
停止发送数据。
发送端发出段4-9，每个段带1K的数据，
是1024，初始序号是8000，窗口大小是6K。发送端应答，
冲区还有4K字节空闲，你发的数据不要超过4K"。接收端应答连接请求，声明最大段尺寸
发送端发起连接，
fastsender
图36.14.滑动窗口
18
3
8
L
FIN. 7169(1024), ACK 8001, WIn 4096
5121( 1024), ACK 8001, win 4096
4097( 1024), ACK 800 1, win 4096
3073(1024), ACK 8001, win 4096
2049( 1024), ACK 8001, win 4096
1025(1024), ACK 8001, win 4096
1(1024),ACK 8001, win 4096
SYN, 8000(0), ACK 1, win 6144, 
SYN, 0(0), win 4096, 
6145( 1024), ACK 800 1, win 4096
ACK 8002, win 4096
FIN, 8001(0), ACK8194, win 6144
ACK 8194. win 6144
ACK 8194, win 4096
ACK 8194, win 2048
ACK 6145, win 4096
ACK 6145, win 2048
ACK 8001, win 4096
声明最大段尺寸是1460，
接收缓冲区又有了2K空闲，接收端发出段10，在应答已收
slow receiver
，就会丢失数据。
，发送端根据窗口大小知道接收端的缓冲区满了，因此
15
L
10
2
mim
mmim
 初始序号是0,
...............
。TCP协议通过"滑动窗口（Sliding
...............
三方握手结束。
窗口大小是4K,
，接收端接收到数据后处理的速度
，表示"我的接收缓
---
## Page 695
6.UDP段格式
一次提取任意字节的数据，
而UDP是面向消息的协议，
包来发送，
所看到的数据是-
从这个例子还可以看出，
是向右滑动的，因此称为滑动窗口。
因此套在虚线框中的空心小方块表示窗口大小，从图中可以看出，随着应用程序提走数据，虚线框
上图在接收端用小方块表示1K数据，
上一页
9．接收端的应用程序在提走全部数据后，决定关闭连接，发出段17包含FIN位，发送端应答，连
7．接收端的应用程序提走2K数据，接收端重新声明窗口大小为4K。
6．接收端应答接收到的2K数据（6145-8192）
5．发送端发出段12-13，每个段带2K数据，段13同时还包含FIN位。
4．接收端的应用程序又提走2K数据，接收缓冲区有4K空闲，接收端发出段11，重新声明窗口大
8
 当然也有可能一次提走3K或6K数据，
．接收端的应用程序提走剩下的2K数据，接收缓冲区全空，接收端重新声明窗口大小为6K。
接完全关闭。
是8194，连接处于半关闭状态，接收端同时声明窗口大小为2K。
小为4K。
但是-
一个数据包有多少字节对应用程序是不可见的，
一个整体，或说是一
 发送端是一K一K地发送数据，
，这一点和TCP是很不同的。
，每个UDP段都是一条消息，
一个流（stream）
，实心的小方块表示已接收到的数据，
全国嵌入式人才培训基地
或者一次只提走几个字节的数据，
起始页
上一级
 再加上FIN位占一个序号8193，因此应答序号
，应用程序必须以消息为单位提取数据，不能
，在底层通讯中这些数据可能被拆成很多数据
，而接收端的应用程序可以两K两K地提走数
因此TCP协议是面向流的协议。
，虚线框表示接收缓冲区,
也就是说，
第37章 socket编程
应用程序
下一页
---
## Page 696
Domain Socket的函数接口。
本节的主要内容是socket API，
socket这个词可以表示很多概念：
5.练习：实现简单的Web服务器
3.基于UDP协议的网络程序
2.基于TCP协议的网络程序
1.预备知识
第 37章 socket编程请点评
目
7.TCP协议
上二
·TCP/IP协议最早在BSD UNIX上实现，为TCP/IP协议设计的应用层编程接口称为socket
·在TCP协议中，
·在TCP/IP协议中，“IP地址+TCP或UDP端口号"唯一标识网络通讯中的一个进程，“IP地址+端
一页
API。
的socket pair就唯一标识一个连接。socket本身有“插座"的意思，因此用来描述网络连接的一
口号"就称为socket。
5.2.执行CGI程序
5.1.基本HTTP协议
2.6.使用select
2.4.使用fork并发处理多个client的请求
2.2.错误处理与读写控制
2.1.最简单的TCP网络程序
对一关系。
2.3.把client改为交互式输
1.2.socket地址的数据类型及相关函数
1.1.网络字节序
，建立连接的两个进程各自有一个socket来标识，
主要介绍TCP协议的函数接口，最后简要介绍UDP协议和UNIX
部分IIl. Linux系统编程
第37章socket编程
全国嵌入式人才培训基地
起始页
上一级
那么这两个socket组成
1.预备知识
696
下三
---
## Page 697
全国嵌入式人才培训基地
---
## Page 698
的UNIX Domain Socket。然而，各种网络协议的地址格式并不相同，如下图所示：
socket API是一层抽象的网络编程接口，
1.2.socket地址的数据类型及相关函数请点评
函数不做转换，将参数原封不动地返回。
主机是小端字节序，
如htonl表示将32位的长整数从主机字节序转换为网络字节序，
这些函数名很好记，h表示host，n表示network，l表示32位长整数，s表示16位短整数。例
用以下库函数做网络字节序和主机字节序的转换。
为使网络程序具有可移植性,
换。同理，32位的IP地址也要考虑网络字节序和主机字节序的问题。
接到16位的源端口号也要做字节序的转换。如果主机是大端字节序的，发送和接收都不需要做转
送主机把1000填到发送缓冲区之前需要做字节序的转换。同样地，
也就是先发0x03，再发0xe8，
TCP/IP协议规定，网络数据流应采用大端字节序，
络数据流的地址应这样规定：先发出的数据是低地址，后发出的数据是高地址。
把从网络上接到的字节依次保存在接收缓冲区中，
数据流的地址呢？发送主机通常将发送缓冲区中的数据按内存地址从低到高的顺序发出，
相对于文件中的偏移地址也有大端小端之分。网络数据流同样有大端小端之分,
我们已经知道，
1.1.网络字节序 请点评
1.预备知识 请点评
存0xe8。但是，
地址0-1是16位的源端口号，如果这个端口号是1000（0x3e8）
上一页
图 37.1.sockaddr数据结构
uint32
uint32-t htonl(uint32-t hostlong);
uint16 
#include 
，如果发送主机是小端字节序的，
，内存中的多字节数据相对于内存地址有大端和小端之分，
t
 ntohs(uint16t
 ntohl
这些函数将参数做相应的大小端转换然后返回，如果主机是大端字节序，这些
l(uint32)
，使同样的C代码在大端和小端计算机上编译后都能正常运行，可以调
，这16位在发送主机的缓冲区中也应该是低地址存0x03，高地址
T
hos
全国嵌入式人才培训基地
，适用于各种底层网络协议,
第37章 socket编程
sho
1.预备知识
ort）;
这16位被解释成0xe803，而不是1000。因此,
，即低地址高字节。例如上一节的UDP段格式,
，也是按内存地址从低到高的顺序保存，
，例如将IP地址转换后准备发送。如果
，接收主机如果是小端字节序的
则地址0是0x03，地址1是0xe8
，如IPv4、IPv6,
，磁盘文件中的多字节数据
，那么如何定义网络
，以及后面要讲
，因此，网
 接收主机
发
贝
---
## Page 699
in_addr转字符串的函数:
字符串转in_addr的函数:
和in_addr表示之间转换。
的IP地址。但是我们通常用点分十进制的字符串表示IP地址，
本节只介绍基于IPv4的socket网络编程，
用struct sockaddr*类型表示，在传递参数之前要强制类型转换一下，例如：
针，但是sock API的实现早于ANSI C标准化，那时还没有void*类型,
如bind、accept、connect等函数，这些函数的参数应该设计成void*类型以便接受各种类型的指
都有长度字段，
种socket地址结构体的开头都是相同的，
控制字段。UNIX Domain Socket的地址格式定义在sys/un.h中,
口号和32位IP地址,
IPv4和IPv6的地址格式定义在netinet/in.h中，
止2
地址，
类型分别定义为常数AF_INET、
int inet_aton(const char 
bind(listen_fd, 
struct.
16位地址类型
int inet_pton(int family,
.5
sockaddr
struct
--..-..-..-..--
地址数据
_addr_
14字节
initialize.
 sockaddr_in servaddr;
如Linux就没有），
七
，IPv6地址用sockaddr_in6结构体表示，
inet
........
16位地址类型：
sockaddr_in
32位IP地址
16位端口号
 servaddr
AF_INET
struct
_addr(const 
(struct sockaddr *)&servaddr, sizeof(servaddr));
......-
AF_INET6、AF_UNIX。这样,
￥
*strptr,,
 sockaddr_un
 const 
char
16位地址类型：
，sockaddr_in中的成员struct in_addr sin_addr表示32位
，前16位表示整个结构体的长度（并不是所有UNIX的实现
AF_UNIX
struct
路径名
108字节
...........
*strptr)
 char *strptr, void *addrptr);
，IPv4地址用sockaddr_in结构体表示，
.struct in_addr
.-..............-.
就可以根据地址类型字段确定结构体中白
，包括16位端口号、128位IP地址和一些
以下函数可以在字符串表示
用sockaddr_un结构体表示。
: *addrptr);