Many of the limitations are cryptographic and could
be overcome by applying more advanced protocols. For
example, lookup and ﬁnd are currently restricted to ex-
ternally signed tables. Lookup tables based on accumu-
lators [13] or vector commitments [27] would be more
ﬂexible and may reduce cost. At a lower level, table
processing leads to many similar cryptographic opera-
tions in a data-parallel style. Batch proof and veriﬁcation
techniques and homomorphic signature schemes could
speed them up [10]. Well known, zero-knowledge proofs
for disjunctions, would allow ZQL branching statements.
The shared translation could bundle multiple secrets per
commitment. Alternatively one could also employ com-
pletely different low-level proof engines, e.g., [53]. We
note that choosing automatically the best encoding and
technique, as well as compiling them in a compositional
manner are challenging open problems. For some pre-
liminary work in this direction see [41].
On the language design side, we illustrated in §7 how
functions can be approximated though lookups. ZQL
could automate and optimize the process by compiling
data sources that calculate and sign function-tables ap-
propriately. Finally, by design, our source language
shields programmers from cryptography, and this may
hinder power-users that wish to customize our compila-
tion scheme, or experiment with its variants. Similarly,
some users may wish to rely on external, unveriﬁed pro-
cedures, and use ZQL only to validate their results. Ad-
vanced APIs exposing the internals of the ZQL compiler
without breaking its invariants would help them.
Acknowledgments The authors would like to thank
Ian Goldberg for early discussions of languages for zero-
knowledge proofs and the advantages of compilation ver-
sus interpretation, and Nikhil Swamy for his comments.
References
[1] J. A. Akinyele, M. D. Green, and A. D. Rubin. Charm: A frame-
work for rapidly prototyping cryptosystems. Cryptology ePrint
Archive, Report 2011/617, 2011.
[2] J. B. Almeida, M. Barbosa, E. Bangerter, G. Barthe, S. Krenn,
and S. Z. B´eguelin. Full proof cryptography: veriﬁable compi-
lation of efﬁcient zero-knowledge protocols.
In ACM Confer-
ence on Computer and Communications Security, pages 488–
500, 2012.
[3] M. H. Au, W. Susilo, and Y. Mu. Constant-size dynamic k-TAA.
In R. D. Prisco and M. Yung, editors, SCN 2006, volume 4116 of
LNCS, pages 111–125, Maiori, Italy, 2006. Springer.
[4] M. Backes, M. Maffei, and K. Pecina. Automated synthesis of
privacy-preserving distributed applications. 19th Annual Network
& Distributed System Security Symposium (NDSS12), 2012.
[5] J. Balasch, A. Rial, C. Troncoso, B. Preneel, I. Verbauwhede, and
C. Geuens. PrETP: Privacy-preserving electronic toll pricing. In
USENIX Security Symposium, pages 63–78, 2010.
[6] E. Bangerter, J. Camenisch, and U. M. Maurer. Efﬁcient proofs
of knowledge of discrete logarithms and representations in groups
with hidden order. In Public Key Cryptography, pages 154–171,
2005.
[7] E. Bangerter, T. Briner, W. Henecka, S. Krenn, A.-R. Sadeghi,
and T. Schneider. Automatic generation of sigma-protocols. In
EuroPKI, pages 67–82, 2009.
[8] E. Bangerter, S. Krenn, A.-R. Sadeghi, T. Schneider, and J.-
K. Tsay. On the design and implementation of efﬁcient zero-
knowledge proofs of knowledge. ECRYPT workshop on Soft-
ware Performance Enhancements for Encryption and Decryption
and Cryptographic Compilers (SPEED-CC ’09), 2009.
[9] E. Bangerter, S. Krenn, A.-R. Sadeghi, and T. Schneider. Yaczk:
Yet another compiler for zero-knowledge. In USENIX Security
Symposium, 2010.
[10] S. Bayer and J. Groth. Efﬁcient zero-knowledge argument for
correctness of a shufﬂe. In EUROCRYPT, pages 263–280, 2012.
[11] M. Bellare and O. Goldreich. On deﬁning proofs of knowledge.
In CRYPTO, pages 390–420, 1992.
[12] M. Bellare and P. Rogaway. Random oracles are practical: A
paradigm for designing efﬁcient protocols. In ACM Conference
on Computer and Communications Security, pages 62–73, 1993.
[13] J. C. Benaloh and M. de Mare. One-way accumulators: A de-
centralized alternative to digital sinatures (extended abstract). In
176  22nd USENIX Security Symposium 
USENIX Association
14
EUROCRYPT, pages 274–285, 1993.
[14] J. Bengtson, K. Bhargavan, C. Fournet, A. D. Gordon, and
S. Maffeis. Reﬁnement types for secure implementations.
In
21st IEEE Computer Security Foundations Symposium (CSF’08),
pages 17–32, 2008.
[15] T. S. Benjamin. Zero-knowledge protocols to prove distances.
Personal communication, 2008.
[16] K. Bhargavan, C. Fournet, and A. D. Gordon. F7: reﬁnement
types for F#, 2008. Microsoft Research Technical Report.
[17] D. Boneh, X. Boyen, and H. Shacham. Short group signatures.
In CRYPTO, pages 41–55, 2004.
[18] S. Brands. Rapid demonstration of linear relations connected by
boolean operators. In EUROCRYPT, pages 318–333, 1997.
[19] T. Briner. Compiler for zero-knowledge proof-of-knowledge pro-
tocols. Master thesis, ETH Zurich & IBM Research Lab Zurich,
2004.
[20] J. Camenisch and A. Lysyanskaya. A signature scheme with efﬁ-
cient protocols. In SCN, pages 268–289, 2002.
[21] J. Camenisch and A. Lysyanskaya. Signature schemes and anony-
mous credentials from bilinear maps. In CRYPTO, pages 56–72,
2004.
[22] J. Camenisch and M. Stadler. Efﬁcient group signature schemes
for large groups. In B. Kaliski, editor, Advances in Cryptology —
CRYPTO ’97, volume 1296 of LNCS, pages 410–424. Springer
Verlag, 1997.
[23] J. Camenisch and E. Van Herreweghen. Design and implementa-
tion of the idemix anonymous credential system. Technical Re-
port Research Report RZ 3419, IBM, May 2002.
[24] J. Camenisch, A. Kiayias, and M. Yung. On the portability of
In EUROCRYPT, pages 425–442,
generalized schnorr proofs.
2009.
[25] J. Camenisch, M. Kohlweiss, and C. Soriente. Solving revocation
with efﬁcient update of anonymous credentials. In SCN, pages
454–471, 2010.
[26] J. L. Camenisch. Group Signature Schemes and Payment Sys-
tems Based on the Discrete Logarithm Problem. PhD thesis, ETH
Z¨urich, 1998. Diss. ETH No. 12520, Hartung Gorre Verlag, Kon-
stanz.
[27] D. Catalano and D. Fiore. Vector commitments and their appli-
cations. Cryptology ePrint Archive, Report 2011/495, 2011.
[28] D. Chaum and T. P. Pedersen. Wallet databases with observers.
In CRYPTO, pages 89–105, 1992.
[29] E. F. Codd. A relational model of data for large shared data banks.
Commun. ACM, 13(6):377–387, 1970.
[30] R. Cramer. Modular Design of Secure yet Practical Crypto-
graphic Protocols. PhD thesis, University of Amsterdam, 1997.
[31] R. Cramer and I. Damg˚ard. Zero-knowledge proofs for ﬁnite ﬁeld
In CRYPTO,
arithmetic; or: Can zero-knowledge be for free?
pages 424–441, 1998.
[32] R. Cramer, I. Damg˚ard, and B. Schoenmakers. Proofs of partial
knowledge and simpliﬁed design of witness hiding protocols. In
CRYPTO, pages 174–187, 1994.
[33] I. Damg˚ard. On Σ-protocols, 2002. Available at http://www.
daimi.au.dk/~ivan/Sigma.ps.
[34] I. Damg˚ard and E. Fujisaki. An integer commitment scheme
IACR Cryptology ePrint
based on groups with hidden order.
Archive, 2001:64, 2001.
[35] G. Danezis and B. Livshits. Towards ensuring client-side compu-
tational integrity. In CCSW, pages 125–130, 2011.
[36] G. Danezis, M. Kohlweiss, and A. Rial. Differentially private
In Information Hiding, pages 148–162,
billing with rebates.
2011.
[37] C. Dwork. Differential privacy: A survey of results. Theory and
Applications of Models of Computation, pages 1–19, 2008.
[38] U. Feige and A. Shamir. Witness indistinguishable and witness
hiding protocols. In STOC, pages 416–426, 1990.
[39] U. Feige, A. Fiat, and A. Shamir. Zero knowledge proofs of iden-
tity. In STOC, pages 210–217, 1987.
[40] A. Fiat and A. Shamir. How to prove yourself: Practical solutions
to identiﬁcation and signature problems. In CRYPTO, pages 186–
194, 1986.
[41] M. Fredrikson and B. Livshits. Z0: An optimizing distributing
zero-knowledge compiler. 2013. MSR Technical report.
[42] T. Freeman and F. Pfenning. Reﬁnement types for ML.
In
Programming Language Design and Implementation (PLDI’91),
pages 268–277. ACM, 1991.
[43] E. Fujisaki and T. Okamoto. Statistical zero knowledge protocols
to prove modular polynomial relations. In CRYPTO, pages 16–
30, 1997.
[44] F. D. Garcia, E. R. Verheul, and B. Jacobs. Cell-based roadpric-
ing. In EuroPKI, pages 106–122, 2011.
[45] I. Goldberg. Natural zero-knowledge embedding in c++. Personal
communication, October 2011.
[46] O. Goldreich, S. Micali, and A. Wigderson. How to prove all
np-statements in zero-knowledge, and a methodology of crypto-
graphic protocol design. In CRYPTO, pages 171–185, 1986.
[47] S. Goldwasser, S. Micali, and C. Rackoff. The knowledge com-
plexity of interactive proof systems. SIAM J. Comput., 18(1):
186–208, 1989.
[48] M. Jawurek, M. Johns, and F. Kerschbaum. Plug-in privacy for
smart metering billing. In PETS, pages 192–210, 2011.
[49] D. Malkhi, N. Nisan, B. Pinkas, and Y. Sella. Fairplay - a secure
two-party computation system. In USENIX Security, pages 287–
302, 2004.
[50] U. M. Maurer. Unifying zero-knowledge proofs of knowledge.
In B. Preneel, editor, AFRICACRYPT, volume 5580, pages 272–
286. Springer, 2009.
[51] S. Meiklejohn, C. C. Erway, A. K¨upc¸ ¨u, T. Hinkle, and A. Lysyan-
skaya. ZKPDL: A language-based system for efﬁcient zero-
knowledge proofs and electronic cash. In USENIX Security Sym-
posium, pages 193–206, 2010.
[52] T. Okamoto. Provably secure and practical identiﬁcation schemes
and corresponding signature schemes. In CRYPTO, volume 740,
pages 31–53. Springer, 1992.
[53] B. Parno, C. Gentry, J. Howell, and M. Raykova. Pinocchio:
Nearly practical veriﬁable computation. In IEEE Symposium on
Security and Privacy, 2013.
[54] T. P. Pedersen. Non-interactive and information-theoretic secure
veriﬁable secret sharing. In CRYPTO ’92, volume 576 of LNCS,
pages 129–140, 1992.
[55] A. Rial and G. Danezis. Privacy-preserving smart metering. In
WPES, pages 49–60, 2011.
[56] T. Ristenpart, G. Maganis, A. Krishnamurthy, and T. Kohno.
Privacy-preserving location tracking of lost or stolen devices:
Cryptographic techniques and replacing trusted third parties with
dhts. In 17th USENIX Security Symposium, pages 275–290, 2008.
[57] C.-P. Schnorr. Efﬁcient signature generation by smart cards. J.
Cryptology, 4(3):161–174, 1991.
[58] N. Swamy, J. Chen, C. Fournet, P.-Y. Strub, K. Bhargavan, and
J. Yang. Secure distributed programming with value-dependent
types. In ICFP, pages 266–278, 2011.
[59] M. Tompa and H. Woll. Random self-reducibility and zero
In
knowledge interactive proofs of possession of information.
FOCS, pages 472–482, 1987.
[60] C. Troncoso, G. Danezis, E. Kosta, and B. Preneel. PriPAYD:
privacy friendly pay-as-you-drive insurance. In P. Ning and T. Yu,
editors, WPES, pages 99–107. ACM, 2007.
[61] C. Troncoso, G. Danezis, E. Kosta, J. Balasch, and B. Preneel.
IEEE
Pripayd: Privacy-friendly pay-as-you-drive insurance.
Trans. Dependable Sec. Comput., 8(5):742–755, 2011.
[62] H. Wee. Zero knowledge in the random oracle model, revisited.
In ASIACRYPT, pages 417–434, 2009.
USENIX Association  
22nd USENIX Security Symposium  177
15
First stage:
[[x : τ,ρ]]1 = x : τ, [[ρ]]1 when x public (including all group elements)
[[x : τ,ρ]]1 = x : τ,tx : x witness, [[ρ]]1 when x private int or num
[[Γ (cid:31) e]]1 = H,a,e
[[Γ (cid:31) e]]1 = let C = e in extend H C, (a,C),C
i=1 ai ∗txi
i=1 ai ∗ xi]]1 = H,a,a0 + ∑n
i=1 ai ∗ xi,∑n
[[Γ (cid:31) a0 + ∑n
when the xi are private and the ai public:
(Γ(ai) =pub num) i=0..n, (Γ(xi) =num) i=1..n
when e public expression, that is, whose variables are all public in Γ.
when Γ (cid:31) e : eltG and e is not public
[[Γ (cid:31) e]]1 = let a,ρ = e in (let txi = random() in )xi
H, (a, [[ρ]]1), [[ρ]]1
when Γ (cid:31) e : ρ non-linear private expression (including assoc, random, opening...)
and xi ranges over the private variables bound in ρ
[[Γ (cid:31) assert eC =G ex]]1 = extend H et ,a,ε
[[Γ (cid:31)↓ x]]1 = let a = a,x in extend (extend H gx) gtx ,a,x
[[Γ (cid:31) let ρ = e in e0]]1 = let H,a, [[ρ]]1 = [[Γ (cid:31) e]]1 in [[Γ,ρ (cid:31) e0]]1
when eC public and ex algebraic on private exponents
Second stage:
[[δ ,ρ]]2 = let a, [[ρ]]1 = a in [[δ ]]2, [let rx = tx − c∗ x in ]x [[ρ]]v
where x ranges over the private variables bound in ρ
[[δ ,δ(cid:27) table]]2 = let a,A = a in [[δ ]]2,map (δ(cid:27) → [[δ(cid:27)]]2) A
[[ε]]2 = ε
[[θ → e]]PROVER = [[θ ]]D →let H = H0 in let a = () in
// hash and prove commitments for all private inputs (omitted)
let H : hash,a : δ ,r = [[θ (cid:31) e]]1 in
let c = ﬁnalize H in
[[θ ,r]]pub, [[δ ]]2,c
Figure 6: Prover Translation (see full paper for map and fold)
[[x : τ,ρ]]v = x : τ, [[ρ]]v when x public (including all group elements)
[[x : τ,ρ]]v = rx : (c,x) response, [[ρ]]v when x private
[[Γ (cid:31) e]]v = H,a,e
[[Γ (cid:31) e]]v = let C,a = a in extend H C,a,C
[[Γ (cid:31) a0 + ∑n
i=1 ai ∗ xi]]v = H,a,−c∗ a0 + ∑n
i=1 ai ∗ rxi
when the xi are private and the ai public:
(Γ(ai) =pub num) i=0..n, (Γ(xi) =num) i=1..n
when e public expression, that is, whose variables are all public in Γ.
when Γ (cid:31) e : eltG and e is not public
[[Γ (cid:31) e]]v = let a, [[ρ]]v = a in H,a, [[ρ]]v
when Γ (cid:31) e : ρ non-linear private-exponent expression (including assoc, random, opening...)
and ρ binds private exponents and public elements
[[Γ (cid:31) assert eC =G ex]]v = extend H ((eC)c ∗G [[ex]]v),a,ε
[[Γ (cid:31)↓ x]]v = let x,a = a in
extend (extend H gx) gc∗x+rx ,a,x
when ex algebraic on private exponents
[[Γ (cid:31) let ρ = e in e0]]v = let H,a, [[ρ]]v = Γ (cid:31) [[e]]1 in [[Γ,ρ (cid:31) e0]]v
[[θ → e]]VERIFIER = [[θ ,r]]pub(cid:27) ,a,c →
// check plain signatures, hash commitments into H,
// and check commitment proofs for all private inputs (omitted)
let H = H0 in
let H,a,r = [[Γ (cid:31) e]]v in
check c = ﬁnalize H;
r
Figure 7: Veriﬁer Translation (see full paper for map and fold)
16
178  22nd USENIX Security Symposium 
USENIX Association