动态分配的内存用完之后可以用free释放掉，传给free的参数正是先前malloc返回的内存块首地
系统的对齐要求，
程序可以转换成其它类型的指针再访问这块内存。malloc函数保证它返回的指针所指向的地址满
由于malloc函数不知道用户拿到这块内存要存放什么类型的数据，
malloc的参数size表示要分配的字节数，
个函数的用法和工作原理。
放，
配内存，
要求。
块全局的内存空间，
用VLA仍然不够灵活，
过C99引入VLA特性，
n是由参数传进来的，
成任何类型的指针都能用。
，更准确地说是归还给ma1loc，这样下次调用ma1loc时这块内存可以再次被分配。本节学习这两
例 24.1. malloc和free
void free(void *ptr);
#include 
 它的底层通过brk系统调用向操作系统申请内存。动态分配的内存用完之后可以用free释
void foo(char *str, int n)
值：m成
int main(void)
typedef struct {
#include
} unit_t;
 例如在32位平台上返回的指针一定对齐到4字节边界，以保证用户程序把它转换
(u 'as 'nq)douxas
char buf[?];
，在各函数中都可以访问呢？由于全局数组无法定义成VLA，所以仍然不能满
，事先不知道是多少，那么buf该定义多大呢？在第1节“数组的基本概念"讲
VLA是在栈上动态分配的，
p->msg 
unit_t *p = malloc(sizeof(unit_t));
char *msg;
->number = 3;
，如果分配失败（可能是由于系统内存耗尽）则返回NULL
%d\nmsg:
函数返回时就要释放，如果我们希望动态分配
这样可确保buf是以·o结尾的。但即使
', p->number,
所以返回通用指针void*，
p-
用
户
---
## Page 427
[K&R]的8.7节给出了malloc和free的简单实现,
两次free(p);，则后一次调用会产生运行时错误。
做任何事情，
关于malloc和free还有一些特殊情况。malloc（0)这种调用也是合法的，也会返回一个非NuLL的指
并不影响程序的正确运行，
foo函数返回时要释放局部变量p的内存空间，
况下即使不用free释放内存也可以，
关于这个程序要注意以下几点:
代码会有点困难，我再做一些简化，！
程
释放了。
存
漏
次
序）
进程占用的所有内存都会归还给操作系统。但如果一个程序长年累月运行（例如网络服务器程
上面的例子只有一个简单的顺序控制流程，
，而且把整个系统都拖得很慢。
(Memory Leak)
，否则每次循环都分配内存，分配完了又不释放，
·虽然内存耗尽是很不常见的错误，
这个指针也可以传给free释放，
·
内存了。
看根本就没法改变p的值,
free(p);之后,
否成功。
学习的大部分系统函数都有成功的返回值和失败的返回值，每次调用系统函数都应该判断是
换。
*类型，
。内存泄漏的Bug很难找到，
void foo(void)
，但是free-
，编译器会做隐式类型转换，我们讲过void*类型和任何指针类型之间可以相互隐式转
>msg);
..
char *p = malloc(10);
p所指的内存空间是归还了，
另外，
一个野指针是不合法的，
return 0;
free(p->msg);
，大量的内存泄漏会使系统内存紧缺，
malloc返回的指针一定要保存好，
，p现在指向的内存空间已经不属于用户，
，图示如下
因为它不会像访问越界一样导致程序运行错误，
 因为程序退出时整个进程地址空间都会释放,
，但写程序要规范，
 分配内存，
，它所指向的内存地址就丢失了，
，基于环形链表。目前读者还没有学习链表，看那段
目的是让读者理解malloc和free的工作原
，但是p的值并没有变,
，就会慢慢耗尽系统内存，
赋值，
，也会造成内存泄漏。例如：
，malloc之后应该判断是否成功。以后要
打印，
，导致频繁换页，
，只有把它传给free才能释放这块内
 释放内存,
，换句话说，p成了野指针，
因为从free的函数接口来
 分配一次就要释放-
，这10个字节也就没法
 这种错误称为内存泄
，等号左边是unit_t,
，不仅影响当前进
，退出程序。这种情
包括堆空间，
少量内存泄漏
不
该
---
## Page 428
_libc的实现比这要复杂得多，
图24.5.简单的mal1oc和free实现
但基本工作原理也是如此。读者只要理解了基本工作原理，就很
大
---
## Page 429
03
pl=malloc(8);
free(pl);
2=malloc（
malloc（16)
[p3]
---
## Page 430
败？内存耗尽之后会怎么样？会不会死机？
1、小练习：编写一个小程序让它耗尽系统内存。观察一下，分配了多少内存后才会出现分配失
习题请点评
第 24 章函数接口
所有空闲块的头节点串在一起，组成一个环形链表，
向内核申请。每个内存块开头都有一个头节点,
用户的内存块，
图中白色背景的框表示malloc管理的空闲内存块,
7．在合并后的这个空闲块末尾截出24个字节，新的头节点占8个字节，另外16个字节返回给用
5．调用malloc分配16个字节，
4．调用free释放pi所指向的内存块，内存块（包括头节点在内）归还给了malloc，
一共有多长，以8字节为单位（也就是以头节点的长度为单位）。
6.
3．又调用malloc分配16个字节，又在空闲块的末尾截出24个字节，步骤和上一步类似。
2i
页
不会还给内核。
意，Break只能拾高而不能降低，从内核申请到的内存以后都归malloc管了，即使调用free也
空闲块越割越小，无法满足大的分配请求。
新申请的空闲块和前一个空闲块连续，
户。
为了画图方便，我们假设每次调用sbrk申请32个字节，建立一个新的空闲块。
到哪去都不-
在malloc管理着两块不连续的内存，
节，另外8个字节返回给用户使用，注意返回的指针p1指向头节点后面的内存块。
一开始堆空间由一个空闲块组成，长度为7x8=56字节，除头节点之外的长度为48字节。
据。另外注意，
段错误，
用户的内存，
，也可能不属于当前进程,
但在访问p1时这段内存可能已经被malloc再次分配出去了,
一定，全乱套了。
此时如果通过p2向右写越界，有可能覆盖右边的头节点，
，现在虽然有两个空闲块，
 要在这个空闲块的末尾截出16个字节，
全国嵌入式人才培训基地
，Break之上的地址不属于当前进程,
用环形链表串起来。
因此可以合并成一个。在能合并时要尽量合并，以免
起始页
上一级
里面有-
，深色背景的框不归malloc管，
一个空闲块的指针字段找到下-
长度字段记录着头节点和后面的内存块加起来
一个指针字段和-
，各有8个字节可分配，但是这两块不连
注意这时p1成了野指针,
又重新合并成一个空闲块。注
，其中新的头节点占了8个字
一个长度字段，指针字段把
2.传入参数与传出参数
 可能会读到意外改写
需要通过brk系统调用
所以访问pi时不会比
，可能是已经分配给
一个空闲块了，找
从而破 
现
指向不属
每次调
下一页
---
## Page 431
函数填充指针所指的内存空间，
2.传入参数与传出参数 请点评
入参数，dest参数是传出参数。
如果函数接口有指针参数，
上一页
表24.2.传出参数示例：void func(unit_t *p);
表 24.1.传入参数示例：void func(const unit_t *p);
3．读取p所指的内存空间
2．调用函数
1．分配p所指的内存空间
4.
3．调用函数
2．在p所指的内存空间中保存数据
1．分配p所指的内存空间 
空间不会被改变
由于有const限定符，
调用者
调用者
，既可以把指针所指向的数据传给函数使用（称为传入参数）：
。有些函数的指针参数同时担当了这两种角色，
 传回给调用者使用 (称为传出参数)
调用者
，调用者可以确信p所指的内存
2．在p所指的内存空间中保存数据
1．规定指针参数的类型unit_t＊
2.传入参数与传出参数
全国嵌入式人才培训基地
第 24 章函数接口
实现者
实现者
2．读取p所指的内存空间
1．规定指针参数的类
型unit_t ＊ 
例如strcpy的src参数是传
实现者
也可以由
下一
---
## Page 432
以下是一个传出参数的完整例子：
由于传出参数和Value-result参数的函数接口完全相同，
例24.2.传出参数
4.读取p所指的内存空间
3．调用函数
2．在p所指的内存空间保存数据
1．分配p所指的内存空间
#include
#include 
(dx 44Tun)4Tun 4as pToA
#include
int main(void)
#include 
#endif
extern void set_unit(unit_t *);
} unit_t;
typedef struct ·
*
*
*
 main.c
 populator.h_
populator.c
return 0;
unit_t u;
if (p == NULL)
"populator.h"
numbe
"populator.h"
'number:
*
*
1*
%d\nmsg: %s\n", u.number, u.msg);
"Hello World!");
 ignore NULL parameter
3．改写p所指的内存空间
2．读取p所指的内存空间
1．规定指针参数的类型unit_t 
，应该在文档中说明是哪种参数。
*/
---
## Page 433
楚
传出参数是NULL表示调用者不需要传出值，例如time(2)的参数。这些特殊规定应该在文档中写清
很多系统函数对于指针参数是NULL的情况有特殊规定：如果传入参数是NULL表示取缺省值，
1.本章的预备知识
一页
全国嵌入式人才培训基地
起始页
级
例如free的参数；如果
3.两层指针的参数
例
433
下一页
---
## Page 434
3.两层指针的参数 请点评
如pthread_join(3)的void **参数。下面看一个简单的例子。
的内存空间应该解释成一个指针变量。
两层指针也是指针,
上一页
出参数，
想一想，
例 24.3.两层指针做传出参数
#include
#include
static const char *msg[] = {"Sunday", "Monday",
#include
，为什么？如果是传入参数应该怎么表示？
，这里的参数指针是const char **,
int main(void)
#endif
extern void get_a_day(const char **);
/* main.c
"Tuesday"
#define REDIRECT_PTR H
#ifndef
，同样可以表示传入参数、
return 0;
static int i = 0;
 REDIRECT
"redirect_ptr.h"
￥
'Wednesday'
s\ts\n"
*secondday
_PTR
，用两层指针做传出参数的系统函数也很常见，比
全国嵌入式人才培训基地
H
第 24 章函数接口
3.两层指针的参数
‘"Kepnzes.'.KepT.‘.Kepsnu.,
、传出参数或者Value-result参数,
，有const限定符，却不是传入参数而是传
只不过该参数所指
下一
---
## Page 435
的函数就要实现一
向该内存的指针,
两层指针作为传出参数还有一种特别的用法，
例 24.4.通过两层指针参数分配内存
表 24.4.通过参数分配内存示例：void alloc_unit(unit_t**pp); void
4．调用free_unit释放内存
3
1．分配pp所指的指针变量的空间
．调用alloc_unit分配内存
使用alloc_unit分配的内存
读取pp所指的指针变量，
(dx 44Tun)aTun aarJ PTOA
void alloc_unit(unit_t **pp)
#include
#endif
extern
typedef struct
#define PARA_ALLOCATOR_H
 unit_t;
/*
 para_allocator.c 
 para_allocator.h_
一个释放内存的函数，所以getaddrinfo(3)有一个对应的freeaddrinfo(3)函数。
strcpy(p->msg,
‘bsumsg);
调用者的责任是请求分配和请求释放内存，
 然后传出的指针指向这块内存空间，这种情况下调用者应该在使用内存之后
或者指向已分配的动态内存（比如指向某个链表的节点）；第二种情况是
= NULL;
number: