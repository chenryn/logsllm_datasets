e
d
o
N
o
t
1.05
1.00
0.95
0.90
0.85
d
e
z
i
l
a
m
r
o
n
,
s
j
.
e
d
o
N
r
e
f
a
S
f
o
d
e
e
p
S
)
r
e
t
t
e
b
s
i
r
e
h
g
h
(
i
s
j
.
e
d
o
N
o
t
1.05
1.00
0.95
0.90
0.85
(a) buffer benchmark suite: 304 tests, 50 runs each
(b) http benchmark suite: 182 tests, 10 runs each
Figure 3—Speed of SaferNode.js normalized to Node.js on a subset of the Node.js benchmarking suite [69] (§5.3). Each dot represents one
benchmark from the suite; results are sorted slowest to fastest. SaferNode.js’s speed ranges from ≈89% to ≈105% of Node.js’s.
Finally, echo_safeAPI uses the safe API:
1 void echo_safeAPI(const FunctionCallbackInfo&
(cid:2)→
args) {
2
3
4
5
6
7
return safeV8::With(args->GetIsolate(), args[0])
.onVal([&](Local ret) {
args.GetReturnValue().Set(ret);
})
.onFail([&](Local exception) {
// handle error
});
8
9 }
slowly
executes
echo_safeAPI
12% more
We benchmark these functions by calling each one in a 107-
iteration loop and measuring execution time. We call all three
functions with an argument of the correct type; still, note that
echo_nocheck would crash if given a non-numeric argument.
than
echo_nocheck, close to SaferNode.js’s worst-case over-
head on the benchmarks in the previous section. On the other
hand, since both echo_safeAPI and echo_check check the
type of their argument, they show no signiﬁcant performance
difference (less than 1%). As a result, we conclude that most of
the overhead in the SaferNode.js benchmarks comes from the
safe API’s extra checking.
Macro-benchmark. Finally, to measure the performance of
our safe API in a real-world setting, we measured the per-
formance of the popular express.js web framework [95] by
comparing the performance of Node.js and SaferNode.js using
express.js’s speed benchmark [31]. This benchmark uses the
wrk web server stress testing tool, running 8 concurrent threads
and 50 open connections to measure the throughput of the web
server. Node.js and SaferNode.js performance was within 1%,
each serving about 15,000 requests/second.
ing similar code, so we built a prototype tool that assists
the programmer by ﬂagging binding functions and automat-
ically rewriting common unsafe patterns. Speciﬁcally, the
tool identiﬁes top-level binding functions that are exposed to
JavaScript (i.e., Node.js functions that accept one argument of
type const v8::FunctionCallbackInfo&).
For these functions, the tool rewrites (1) hard-crashing CHECK
calls, (2) casts using As with no preceding IsType
check, and (3) calls to Get, Set, and ToString. Our tool is
conservative in that it only rewrites code that is easy to reason
about. For example, it does not rewrite functions that include
gotos. The tool comprises about 7,500 lines of Java.
Despite being a prototype, this tool was useful in porting
Node.js to our API. In Node.js 7.0.0, we manually counted 378
functions with the required type signature; our tool ﬂagged 371
of them. Of these, 201 did not need to be rewritten. Another
35 used gotos or similar patterns that the tool cannot handle.
The tool rewrote the remaining 135 functions, but required
manual intervention in two cases, about 30 lines of code total.
As a sanity check, we ran CITGM (the regression suite from
above) and the full Node.js benchmarks on the rewritten code.
We found that it was fully functional and paid a performance
overhead roughly commensurate with the results in Figure 3.
From the above, we surmise that porting to our API is rea-
sonable, even in complicated code bases. We regard further
automation of this porting effort as future work.
6 Related Work
We discuss our contributions with respect to related work on se-
curing binding code in multi-language systems. Speciﬁcally, we
consider the literature on ﬁnding bugs in binding code, avoiding
bugs by construction, and tolerating bugs using isolation.
Porting burden
Porting Node.js’s buffer module to our safe API required
adding about 1000 lines of code to node_buffer.cc, originally
a 1300-line ﬁle. For http, we added about 150 lines of code to
node_http_parser.cc, which was originally about 800 lines.
While porting, we realized that we were repeatedly rewrit-
6.1 Finding Binding Bugs
The ﬁrst line of work looks at ﬁnding errors that arise at
the boundaries of multi-language systems, either via dynamic
checking, property-independent translation to a common IR, or
property-speciﬁc static checking.
Dynamic checking. Jinn [55] generates dynamic bug check-
574
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:27:26 UTC from IEEE Xplore.  Restrictions apply. 
ers for arbitrary languages from state machine descriptions of
foreign function interface (FFI) rules. In doing so, Jinn ﬁnds
bugs in both the Java Native Interface (JNI) and Python/C code.
While running similar checkers in production is probably pro-
hibitively expensive, this kind of system would complement
existing browser debug-runtime checks.
Translation to common IR. Several groups have looked into
translating multi-language programs into a common interme-
diate language, and then applying off-the-shelf analysis tools
to their translation [9, 54, 58, 100]. For large code bases like
Chrome, this approach is as feasible as the analysis approach
is scalable; consequently, an alternative approach is to develop
custom checks for particular classes of bugs.
Crash-safety bugs. Kondoh, Tan, and Li present different static
analysis techniques for ﬁnding bugs caused by mishandled ex-
ceptions in Java JNI code [52, 56, 99]. Safer binding-layer
APIs would address some of the issues these works tackle. For
example, both our API the recent V8 API addresses similar
memory management and exception-catching concerns by con-
struction [30, 37]. Still, their approach can address a concern
that neither our API nor existing JavaScript engine APIs handle:
ﬁnding bugs in binding code where exceptions are raised by
native code.
Type-safety bugs. Tan and Croft ﬁnd type safety bugs that re-
sult when developers expose C pointers to Java as integers [99].
Their work also illustrates that static checkers can ﬁnd type
safety bugs in practice, as we suggest in §3. Exposed pointer
errors, however, are unlikely in JavaScript binding code, since
JavaScript engines provide hidden ﬁelds for C code to save
raw pointers across contexts. Still, since these errors would
be catastrophic, it may be worthwhile to implement Tan and
Croft’s technique for browser binding code. More broadly, Furr
and Foster [34, 35] present a multi-language type inference
systems for the OCaml and Java FFIs. Since JavaScript is dy-
namically typed, using type-inference approaches like these is
difﬁcult, but a similar analysis could help ensure that binding
layer dynamic type checks are correct. Moreover, they would be
applicable to runtime systems like Node.js where type checks
are not generated but implemented manually.
Memory-safety bugs. Li and Tan present a static analysis
tool that detects reference counting bugs in Python/C inter-
face code [57]. Their results also show that static checkers can
help secure cross-language code. A tool like this one would
assist binding code in which the C++ side performs reference
counting (e.g., Blink before Oilpan).
6.2 Avoiding Binding Bugs by Construction
Another line of work looks at avoiding binding bugs by construc-
tion, either with formal models of inter-language interaction to
verify safety, or with new languages that restrict interactions to
ensure safety.
Formal models. Several projects develop formal models for
JavaScript, multi-language systems, and FFIs [53, 59, 61, 98,
104]. These works not only help developers understand multi-
language interaction but also allow developers to formally rea-
son about tools for multi-language systems (tools like static
checkers or new APIs). We envision developing a similar for-
malization for JavaScript, perhaps based on [59, 80], or by ex-
tending and combining the formal models for C and JavaScript
developed in the K-framework [29, 77].
Language design. Janet [7] and Jeannie [44] are language de-
signs that allow users to combine Java and C code in a single ﬁle,
therefore building multi-language systems more safely. Safe-
JNI [101] provides a safe Java/C interface by using CCured [65]
to retroﬁt C code to a subset that abides by Java’s memory and
type safety. While these language designs are well-suited for
isolated browser features, it is unclear how these approaches
would apply to existing large JavaScript runtime system. By
refactoring existing FFI code to use domain-speciﬁc languages
such as our safe API, our approach provides a way to gradually
increase security across different components. Speciﬁcally, it
strongly encourages the programmer to put in suitable checks
and handle all possible errors, one module at a time, thereby
providing greater safety while remaining in the original host
language (e.g., C++).
Safe linking. A recent line of work by Ahmed et al. [3, 78] aims
to address the problem of (safely) composing multi-language
programs by separately compiling the components into a grad-
ually typed [88, 89] target language and then linking the results.
The gradually typed target language would have support for
more, less, or completely untyped sub-components, and would
automatically insert run-time checks to ensure that typing invari-
ants are preserved as values move across the different parts [65].
In the context of binding code, this approach has the beneﬁt of
shifting the burden of placing suitable checks from programmer
to the compiler and could provide formal safety guarantees.
On the other hand, gradual typing implementations still have
non-trivial run-time overheads [97] and it remains to be seen
whether the above approach can be made practical for complex
systems like Node.js and Chrome.
6.3 Tolerating Binding Bugs
One last approach, orthogonal to ﬁnding and preventing binding
bugs, is to design systems to tolerate such bugs by isolating
components at the language or browser level.
Language-level isolation. Running different languages’ run-
times in isolated environments addresses many security bugs in
FFI code. Klinkoff et al. [49] present an isolation approach for
the .NET framework. They run native, unmanaged code in a sep-
arate sandboxed process mediated according to the high-level
.NET security policy. Robusta [87] takes a similar approach for
Java, but, to improve performance, uses software fault isolation
(SFI) [108].
Browser-level
isolation. Redesigning the browser to run
iframes in separate processes would address many of the vul-
nerabilities that lead to same-origin policy bypasses. Unfor-
tunately, as illustrated by Chrome’s ongoing efforts [22] and
several research browsers (e.g., Gazelle [107], IBOS [102], and
Quark [47]) this is not an easy task. Redesigns often break com-
patibility and have huge performance costs. Moreover, applying
such techniques beyond the browser to runtime systems such as
Node.js and PDFium is not easily achievable—in these systems
575
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:27:26 UTC from IEEE Xplore.  Restrictions apply. 
we do not have the security policies that allow browsers to more
easily decide where to draw isolation boundaries.
Acknowledgements
We thank the anonymous reviewers and our shepherd, Nikhil
Swamy, for many insightful comments and for pointing out
a bug in an early version of this paper. Úlfar Erlingsson and
Bryan Parno for their accomodations. Thomas Sepez for help-
ing us understand the PDFium attacker model and conﬁrming
and ﬁxing some of our bugs. Bryan Eglish, Colin Ihrig, Devon
Rifkin, Sam Roberts, Rod Vagg, and Brian White for useful dis-
cussions of Node.js’s attacker model and for incorporating our
feedback on how to improve the runtime’s safety and security.
Colin Ihrig and Timothy Gu for promptly ﬁxing many of our
Node.js bugs. Adrienne Porter Felt, Joel Weinberger, Lei Zhang,
Nasko Oskov, and Devlin Cronin for helping to explain the se-
curity model for Chrome extensions. Hovav Shacham, David
Kohlbrenner, and Joe Politz for fruitful discussions. Sergio Ben-
itez and Andres Nötzli for help, comments, and formatting
magic. Mary Jane Swenson for making everything easier. This
work was supported by NSF Grant CNS-1514435 and an NSF
Fellowship.
References
[1] F. Aboukhadijeh. Buffer(number) is unsafe. https:
//github.com/nodejs/node/issues/4660.
[2] B. Adida, A. Barth, and C. Jackson. Rootkits for
JavaScript environments. In WOOT, Aug. 2009.
[3] A. Ahmed. Veriﬁed compilers for a multi-language
world. In Summit on Advances in Programming Lan-
guages, SNAPL 2015, May 2015.
[4] A. Barth, A. P. Felt, P. Saxena, and A. Boodman. Protect-
ing browsers from extension vulnerabilities. In NDSS,
Feb. 2010.
[5] F. Brown, S. Narayan, R. S. Wahby, D. Engler, R. Jhala,
Finding and preventing bugs in
https://
and D. Stefan.
JavaScript bindings: Extended version.
bindings.programming.systems.
[6] F. Brown, A. Nötzli, and D. Engler. How to build static
checking systems using orders of magnitude less code.
In ASPLOS, Apr. 2016.
[7] M. Bubak, D. Kurzyniec, and P. Luszczek. Creating
Java to native code interfaces with Janet extension. In
Worldwide SGI Usersâ ˘A ´Z Conference, Oct. 2000.
[8] E. Budianto, R. Chow, J. Ding, and M. McCool.
Language-based hypervisors. In CANS, Nov. 2016.
[9] C. Cadar, D. Dunbar, and D. R. Engler. KLEE: Unas-
sisted and automatic generation of high-coverage tests
for complex systems programs. In OSDI, Dec. 2008.
[10] caja. Caja. https://developers.google.com/caja/.
[11] P. Carbonnelle. PopularitY of Programming Language.
http://pypl.github.io/PYPL.html.
[12] chakraCore. Microsoft chakracore. https://github.
com/Microsoft/ChakraCore.
[13] checkerChromeVersion. Chromium version 56.0.2915.0.