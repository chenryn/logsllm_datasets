# TCTF 2021 0bf - 利用Unicorn模拟被混淆的代码
|
##### 译文声明
本文是翻译文章
译文仅供参考，具体内容表达以及含义原文为准。
## 简介
这次的TCTF 2021 Final有队友们的鼎力相助，拿了Rising
Star的冠军，十分刺激。其中收获比较大的是`0bf`这道题目，这是一个10轮的加密算法，代码有大量混淆，加密逻辑没法直观地看出来。赛后官方的writeup是去混淆再解，但在比赛时没有足够的时间来研究混淆的规律，只能硬着头皮分析。这道题目也是我第一次用Unicorn来模拟函数逻辑，收获还是很大。
## 程序逻辑
由于代码经过了混淆，函数严重膨胀，首先要修改IDA的配置文件，将函数大小的上限调高，IDA反编译插件的配置文件在`IDA安装目录\cfg\hexrays.cfg`，打开找到`MAX_FUNCSIZE`，改成一个大数，再重新分析程序的加密函数`sub_11C9`，等上十几分钟，反编译完成后把代码复制到一个文件中，重新格式化成每个赋值语句一行的形式，方便查看。我上传了一份[反编译后的代码](https://pastebin.com/pjH7iacC)，有需要可以下载。
这时从VSCode的代码缩略图中就可以看出，该加密函数有明显的重复部分，例如函数入口的两行：
      v2 = 12 * (*a1 & 0x4138B65C) + 8 * ~(*a1 & 0xBEC749A3) + (*a1 & 0xBEC749A3) + 1 - 6 * (*a1 ^ 0xBEC749A3) + 8 * ~*a1 + *a1 + 1 - 2 * (*a1 | 0xBEC749A3) - 4 * ~(*a1 | 0xBEC749A3) - 4 * ~(*a1 | 0x4138B65C) + 5 * (*a1 & 0xBEC749A3) + 1688020449;
      v3 = 2636545543LL * v1;
和第二轮开始的部分：
      v106 = 12 * (v103 & 0x70E38EE0) + 8 * ~(v103 & 0x8F1C711F) + (v103 & 0x8F1C711F) + 1 - 6 * (v103 ^ 0x8F1C711F) + 8 * ~v103 + v103 + 1 - 2 * (v103 | 0x8F1C711F) - 4 * ~(v103 | 0x8F1C711F) - 4 * ~(v103 | 0x70E38EE0) + 5 * (v103 & 0x8F1C711F) + 1583631427;
      v107 = 4225108746u * v105;
以及第三轮开始的部分：
      v209 = 12 * (v206 & 0xEEE7AAAE) + 8 * ~(v206 & 0x11185551) + (v206 & 0x11185551) + 1 - 6 * (v206 ^ 0x11185551) + 8 * ~v206 + v206 + 1 - 2 * (v206 | 0x11185551) - 4 * ~(v206 | 0x11185551) - 4 * ~(v206 | 0xEEE7AAAE) + 5 * (v206 & 0x11185551) + 1862844314;
      v210 = 3734538576u * v208;
仔细寻找类似的代码，可以将整个加密函数分成10轮，每轮之间传递两个32位的值。第一轮的输入是`a1`开始的8字节，第二轮输入是第一轮计算产生的`v103`和`v105`两个值，依次类推，第10轮完成后计算结果作为加密后的8字节。
第一轮代码大致结构如下：
      v1 = (unsigned int)a1[1];
      v2 = 12 * (*a1 & 0x4138B65C) + 8 * ~(*a1 & 0xBEC749A3) + ...;
      v3 = 2636545543LL * v1;
      if (2636545543LL * v1) {
        ...
        v10 = 6 * ~((HIDWORD(v9) - 1) | ~(_DWORD)v9 | 0x9D267E07) + 2 * (v9 & ((HIDWORD(v9) - 1) | 0x9D267E07)) - ...;
      } else {
        ...
        v10 = 4 * (~((v1 - 1) | 0x9D267E05) - 3 * ~((v1 - 1) | 0x62D981FA)) - ...;
      }
      v12 = 300216365LL * (21 * (v10 & ~v2 & 0xEE1B0FD2) + 10 * ~(v10 | ~v2 | 0xEE1B0FD2) + ...;
      if (v12) {
        v1222 = -4 * (-(__int64)HIDWORD(v12) ^ (unsigned int)v12);
        v1182 = 6 * (v12 | (HIDWORD(v12) - 1)) + 5 * (~(unsigned __int64)(unsigned int)v12 & (v12 | (HIDWORD(v12) - 1)) ^ -(__int64)HIDWORD(v12));
        ...
      } else {
        v20 = 2 * ~((21 * (v10 & ~v2 & 0xEE1B0FD2) + 10 * ~(v10 | ~v2 | 0xEE1B0FD2) + ....;
        v21 = v20 - (-(21 * (v10 & ~v2 & 0xEE1B0FD2) + 10 * ~(v10 | ~v2 | 0xEE1B0FD2) + ...;
        ...
      }
      ...
      v103 = 4 * (v2 & v93 & v101) - 21 * (v2 & v93 & ~(_DWORD)v101) + ...;
      v105 = 26 * (v10 & v101 & ~v97) + ((unsigned int)v101 & v10 | v97 ^ v101) + ...;
从上面的代码可以将一轮的加密过程总结如下：
1、将本轮输入`*a1`，`a1[1]`经过短暂的处理，变为两个新的32位数`v2 = s(*a1)`和`v10 =
t(a[1])`，再用这两个数计算第三个值`v12 = r(v2, v10)`。
2、此后的计算仅依赖于第三个值`v12`（注意计算出`v12`后，下面的代码对`v2`和`v10`的使用形式与`v12`完全相同，均为`21 * (v10
& ~v2 & 0xEE1B0FD2) + ...`，实际上这个表达式还是`v12`）。
3、将第二步的计算结果记为`f(v12)`，则两个输出32位值`v103`和`v105`分别为`g(v2, f(v12))`和`h(v10,
f(v12))`。
`r`，`s`，`t`，`f`，`g`，`h`的具体操作未知。
## 分析
在没法去除混淆的情况下，只能将各段代码分别看作不同的黑盒，通过改变黑盒的输入，观察黑盒的输出，来猜测黑盒中的逻辑。
IDA的反汇编代码中用到的`_DWORD`，`LOWORD`，`__CFADD__`等宏定义可以从`IDA安装目录\plugins\defs.h`中找到，以分析`v2
= s(*a1)`中的`s`函数为例，将IDA反汇编重新改为C代码：
    #include 
    #include 
    #include 
    #include 
    #include "defs.h"
    void f(unsigned int* a1) {
      unsigned int v2 = 12 * (*a1 & 0x4138B65C) + 8 * ~(*a1 & 0xBEC749A3) +
                        (*a1 & 0xBEC749A3) + 1 - 6 * (*a1 ^ 0xBEC749A3) + 8 * ~*a1 +
                        *a1 + 1 - 2 * (*a1 | 0xBEC749A3) - 4 * ~(*a1 | 0xBEC749A3) -                        4 * ~(*a1 | 0x4138B65C) + 5 * (*a1 & 0xBEC749A3) +
                        1688020449;
      printf("%x %x\n", *a1, v2);
    }
    int main() {
      srand((unsigned)time(NULL));
      unsigned int a, x;
      for (a = 0; a >32))&0xFFFFFFFF`。剩余`f`过于复杂，没法直接观察出结果。单轮加密可以总结如下：
    输入：32位值a，b
    输出：32位值x，y
    v1=(a*C1-((a*C1)>>32))&0xFFFFFFFF
    v2=b+C2
    v3=v1^v2
    x=v1^f(v3)
    y=v2^f(v3)
## 解法
不去混淆的情况下，程序中唯一无法求逆的是`f`函数，但观察得知`f`函数的可以通过异或来消去。给定加密结果`x`，`y`，若取`v1'=x^y,
v2'=0`，则`v3'=x^y`，`x'=v1'^f(v3')=x^y^f(x^y)`，`y'=v2'^f(v3')=f(x^y)`，可以发现新的加密中的`y'`即原先的加密时`f`函数的输出，再将`y'`分别与`x`，`y`异或，可以求出原先加密时的`v1`和`v2`。
再取`a'=0, b'=1`，则`v1'=C1,