# ByteCTF
##### 译文声明
本文是翻译文章
译文仅供参考，具体内容表达以及含义原文为准。
## Reverse
###  moderncpp
经过奇怪的一种转化后将输入转化为01串，应该是一种树形结构。  
类似于哈夫曼树的感觉，没有细看。  
然后就是一个简单的tea。  
dump出各个字符对应的bit位，算出tea结果，拿去匹配算出flag。
    cmps="00001100111100000110100111011000010010100011001011111011011000101000111010100100110011000000110011000000001000100110001111100101101101101111110100000111010111101110011011111110110001101000110111111101100011010101000110101101111001000110100011111010000101000111100000000000000000000000000000000000000000000000000000000000"
    map01={}
    map01["a"]="100101"
    map01["b"]="00001"
    map01["c"]="01110"
    map01["d"]="11011"
    map01["e"]="0011010"
    map01["f"]="010010"
    map01["g"]="111011"
    map01["h"]="01000"
    map01["i"]="10110"
    map01["j"]="00110111"
    map01["k"]="1111010"
    map01["l"]="110010"
    map01["m"]="00011"
    map01["n"]="10000"
    map01["o"]="10100011101"
    map01["p"]="0110011"
    map01["q"]="011000"
    map01["r"]="111110"
    map01["s"]="01011"
    map01["t"]="11000"
    map01["u"]="11110110"
    map01["v"]="000001"
    map01["w"]="111000"
    map01["x"]="00101"
    map01["y"]="10011"
    map01["z"]="101000110"
    map01["0"]="1110010"
    map01["1"]="100100"
    map01["2"]="111111"
    map01["3"]="01101"
    map01["4"]="11010"
    map01["5"]="11110111"
    map01["6"]="001100"
    map01["7"]="111010"
    map01["8"]="00111"
    map01["9"]="10101"
    map01["!"]="00110110"
    map01["@"]="1110011"
    map01["#"]="101001"
    map01["%"]="00010"
    map01["^"]="01111"
    map01["&"]="10100011100"
    map01["*"]="0110010"
    map01["("]="010011"
    map01[")"]="111100"
    map01["_"]="01010"
    map01["+"]="10111"
    map01["-"]="10100010"
    map01["="]="000000"
    map01["["]="110011"
    map01["]"]="00100"
    map01["{"]="10001"
    map01["}"]="1010001111"
    map01[";"]="1010000"
    path=[]
    def output():
        strs=""
        for i in path:
            strs+=i
        print(strs)
    def dfs(ptr):
        if ptr>len(cmps):
            return
        output()
        for k,v in map01.items():
            if cmps[ptr:ptr+len(v)]==v:
                path.append(k)
                dfs(ptr+len(v))
                path.remove(k)
    dfs(0)
## Misc
###  BabyShark
给出了一个流量包，流量包我们可以看到里面第一个TCP流中有利用adbshell进行下载得一个程序。我们将其提取下来反编译。
    package com.bytectf.misc1;
    import javax.crypto.Cipher;
    import javax.crypto.spec.IvParameterSpec;
    import javax.crypto.spec.SecretKeySpec;
    public class AesUtil {
        private static final String CipherMode = "AES/CFB/NoPadding";
        private static String byte2hex(byte[] b) {
            StringBuilder sb = new StringBuilder(b.length * 2);
            int v3;
            for(v3 = 0; v3 = 2) {
                String v6 = inputString.toLowerCase();
                int l = v6.length() / 2;
                byte[] result = new byte[l];
                int i;
                for(i = 0; i > 8 & 0xFFL)))), ((byte)(((int)(value >> 16 & 0xFFL)))), ((byte)(((int)(value >> 24 & 0xFFL)))), ((byte)(((int)(value >> 0x20 & 0xFFL)))), ((byte)(((int)(value >> 40 & 0xFFL)))), ((byte)(((int)(value >> 0x30 & 0xFFL)))), ((byte)(((int)(value >> 56 & 0xFFL))))};
        }
        private static byte[] paddingBytes(byte[] data) {
            byte[] padding = new byte[0x20];
            int i;
            for(i = 0; i = 2) {
                String v6 = inputString.toLowerCase();
                int l = v6.length() / 2;
                byte[] result = new byte[l];
                int i;
                for(i = 0; i > 8 & 0xFFL)))), ((byte)(((int)(value >> 16 & 0xFFL)))), ((byte)(((int)(value >> 24 & 0xFFL)))), ((byte)(((int)(value >> 0x20 & 0xFFL)))), ((byte)(((int)(value >> 40 & 0xFFL)))), ((byte)(((int)(value >> 0x30 & 0xFFL)))), ((byte)(((int)(value >> 56 & 0xFFL))))};
        }
        private static byte[] paddingBytes(byte[] data) {
            byte[] padding = new byte[0x20];
            int i;
            for(i = 0; i < 0x20; ++i) {
                padding[i] = i < data.length ? data[i] : 0;
            }
            return padding;
        }
    }
###  Lost Excel
分离excel文件，拿到点阵图，发现LSB隐写。根据提示blocksize=8将其分为8*8pixel的格子  
发现有许多循环出现的部分，直接读。
根据格子中黑点出现的位置将其转换为二进制
    from PIL import Image
    ans=''
    def check(temp):
        global ans
        for y in range(2):
            for x in range(2):
                if temp.getpixel((x*4,y*4))==(0,0,0):
                    ans=ans+str(y)+str(x)
    for i in range(4,5700):
        img=Image.open('{}.png'.format(i))
        check(img)
    print(ans)
得到01串，读一下 得到flag
###  frequently
题目比较简单  
dns tunnel中 i,o两种代表 01 获得前一半部分flag。  