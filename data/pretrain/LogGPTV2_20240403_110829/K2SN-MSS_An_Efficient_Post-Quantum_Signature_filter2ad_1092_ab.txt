(cid:16) t
(cid:17) ⩾ m.
• n ∈ N: Security parameter where N denotes the set of natural
numbers.
• m ∈ N: Length of the messages in bits.
• ˆm, ˆn ∈ N: Parameters of SWIFFT hash function family.
• p: Prime integer.
• t: The number of component key-pairs for the OTS we em-
ploy. We assume t = 2ℓ for some positive integer ℓ and
log2
• h: Merkle tree height. The K2SN-MSS is designed to sign 2h
messages.
• ∥: concatenation of two binary strings.
• ⊕: bit-wise XOR of two binary strings.
• ⊕p: component-wise modulo p addition of two vectors of
same length.
• ⊙p: component-wise modulo p multiplication of two vectors
of same length.
• Fn =
is pseudo-random
function family and will be used in KSN-OTS and K2SN-MSS.
• Fn =(cid:8)fk : {0, 1}n → {0, 1}n | k ∈ {0, 1}n(cid:9) is pseudo-random
fk : {0, 1}2n → {0, 1}2n | k ∈ {0, 1}n
function family and will be used in W-OTS+ and XMSS.
• cm: A function that, on an input of m-bit, generates a row of
the 1-CFF function family table.
(cid:41)
(cid:40)
Definition 2.5. Multi-function, Multi-target Second-Preimage
Resistance (MM-SPR) [21]. We define the success probability of
an adversary B against multi-function multi-target second-preimage
resistant of a hash function family Hn which is parameterized by
the number of targets as:
Succmm-spr
(B) = Pr[Ki
$←− {0, 1}2n,
$←− {0, 1}n′
, xi
H,q′
0 < i ⩽ q
′;
′
$←− B((K1, x1), . . . , (Kq′, xq′ )) :
(j, x
)
′ (cid:44) xj ∧ HKj (xj ) = HKj (x
′
)].
x
Definition 2.6. InSecMM-SPR
(H , q, q′): This is defined as the
maximum success probability for any attacker B against the multi-
function multi-target second-preimage resistant of Hn with q′
targets after q queries as
InSecMM-SPR
(Hn, q, q
′
) = max
B
Succmm-spr
Hn,q′
(B)
For more details we refer the reader to [21].
(cid:26)
(cid:27)
.
2.1 Hash Function
Definition 2.1. Hash Function Family [21]. Let n ∈ N be the
security parameter. Let n′ = n + nϵ ∈ poly(n) and k ∈ poly(n).
Then we define a hash function family Hn as:
(cid:40)
HK : {0, 1}2n (cid:55)→ {0, 1}n′(cid:41)
Hn =
K ∈R {0,1}k .
2.2 XMSS and W-OTS+
XMSS [9] is a hash-based signature scheme that extends the one
time signature W-OTS+ to a multi-message signature scheme using
Merkle tree construction. The construction was proposed in [9]
and the security was reduced to the second-preimage resistance of
the hash function that was used in the Merkle tree and the security
of the W-OTS+. XMSSMT [20] extends XMSS to multiple layer
xxx, yyy, zzz
Sabyasachi Karati and Reihaneh Safavi-Naini
tree where each layer root node is signed using W-OTS+. It allows
for a virtually unlimited number of signatures, while it preserves its
desirable properties [20] of XMSS. This provides signature and key
generation computation time and signature size trade-off which
allow the users to choose parameters to match their requirements.
XMSS is a special case of XMSSMT . In [21], XMSS is proposed that
provides security against multi-function-multi-target preimage (or
second preimage) attacks. The new security requirement for the
signature schemes is given in Appendix 2.1 and is used in our
security analysis. There are several implementations for XMSS [3,
15]. We compare our implementation with the implementation
in [15] because this takes the multi-function-multi-attack notion of
security into consideration. Also, this is the only implementation
which takes advantage of SIMD parallelization and reports the
fastest result. On the other hand, choice of the parameters for
SWIFFT hash function leads to 512-bit classical (256-bit quantum)
security of K2SN-MSS in multi-function-multi-target model and it
should be noted that there is no existing software of XMSSMT at
the same security level.
2.3 W-OTS+
XMSS signature scheme uses W-OTS+ [9] as the OTS scheme. The
public key and signature of W-OTS+ is computed through random
walks in a function family Fn = { fk : {0, 1}n (cid:55)→ {0, 1}n | k ∈
{0, 1}n}. For a k, x ∈ {0, 1}n and e ∈ N, the random walk is defined
as:
0
k (x) = k,
f
For an m-bit message, and Winternitz parameter w, define following
parameters
k (x) = fk’ (x), where k’ = f i−1
f i
(cid:37)
(cid:38)
(cid:36) log2 (l1 (w − 1))
(cid:39)
m
k
(x).
, l2 =
+ 1.
log2 (w )
log2 (w )
l = l1 + l2, l1 =
(x), f w−1
(1)
The secret key of W-OTS+ is SK = {x0, x1, . . . , xl−1} where each
xi is a binary string of length n (that is generated by using a pseudo-
random function on a random seed), and the corresponding public
key is PK = {x, f w−1
xl−1 (x)}, where x is a
randomly generated element from {0, 1}n.
To sign a message mes, first the message is written in base w as,
i =0 (w − 1 − bi )
in base w is calculated, C = {bl1 , bl1+1, . . . , bl−1}, and appended to
the message to obtain b = {b0, b1, . . . , bl−1}.
mes = {b0, b1, . . . , bl1−1}. Next a checksum C =(cid:80)l1−1
The signature of b is σmes = {σ0, σ1, . . . , σl−1} = { f
b1
x1 (x),
xl−1 (x)}, resulting in an l×n-bit signature. Verification is done
bl−1
(x), . . . , f w−1
b0
x0 (x), f
x0
x1
. . . , f
by checking
PK ?
= { f
w−1−b0
σ0
(x), f
w−1−b1
σ1
(x), . . . , f
w−1−bl−1
σl−1
(x)}.
2.4 XMSS: A Secure Merkle Tree MSS
Construction [21]
In this section we describe XMSS briefly which is an instantiation
of SPR-MSS with W-OTS+ and also takes the multi-function-multi-
target security model of hash functions into consideration. Let W-
OTS+ be a secure one-time signature scheme with 2ℓ component
secret keys (and the corresponding component public keys). To
design an MSS for 2h messages, 2h instances of the W-OTS+ will
be used as follows. Let the secret key SK i and public key PK i of
the i-th instance of the W-OTS+ be,
SK i = {xi0 , xi1 , . . . , xi2ℓ−1}; xij ∈ {0, 1}n, and
PK i = {xi , yi0 , yi1 , . . . , yi2ℓ−1}; xi , yij ∈ {0, 1}n .
To sign the i-th message, the i-th instance of the W-OTS+ is used.
The construction uses a Merkle tree of height h + ℓ, and attaches a
random binary string of length 2n for each node of the tree, denoted
by vi, j where (i, j) denotes the j-th node from left at height i as
0 ⩽ i ⩽ h + ℓ and 0 ⩽ j ⩽ 2i − 1. In our construction, we consider
that leaf nodes are at height h + ℓ and the root node is at the height
0. Similarly each node computation uses a different hash key ki, j
and random pad vi, j. The construction of the Merkle tree consists
of two types of trees: (i) Li trees and (ii) MSS tree.
(1) Construction of Li trees: Li is a Merkle tree of height ℓ
whose leaves are the component public keys of the i-th in-
stance of W-OTS+, that is {xi , yi0 , yi1 , . . . , yi2ℓ−1}. Let yil, j
be a node of the tree where it is the j-th (0 ⩽ j ⩽ 2l −1) node
from the left at height l (0 ⩽ l ⩽ ℓ) of the Li. Now we assign
for 0 ⩽ l < ℓ are
yiℓ, j
computed as
for 0 ⩽ j < 2ℓ. The nodes yil, j
= yij
yil, j
= Hkil, j
((yil +1,2j ∥yil +1,2j +1 ) ⊕ vil, j ),
(2)
where Hk ∈ Hn, ∥ and ⊕ denote the concatenation and bit-
wise XOR of two binary strings, respectively. Let the root of
the Merkle tree Li be yh,i and then yh,i = yi0,0.
(2) Construction of MSS tree: MSS has height h and the leaf
nodes are the root nodes of the Li trees, that is {yh,0, yh,1, . . . ,
yh,2h−1}. The intermediate nodes and the root node of the
MSS are constructed in the similar way shown in equa-
tion (2). Let the root of the MSS tree be y0,0.
The pictorial view of the Merkle tree is given in the Figure 1 and
Figure 2.
All the random pads and all the hash keys can be generated
using a seed and pseudo-random number generator (PRG). From
the seed and the PRG, we can compute the random pad and the
hash key for a particular node using the index of the node in the
tree. Let the seed for hash key be hkseed and the seed of ran-
dom pads be rpseed. Also all the secret keys can be generated
using the PRG using another seed sk. The multi-message signa-
ture scheme has secret and public keys given by, SK = {sk} and
PK = {y0,0, hkseed, rpseed}, respectively. A signature consists of,
(i) the index of the message, i, (ii) the signature of the i-th W-OTS+
on the message, (iii) the public key PK i of the i-th W-OTS+, and
(iv) a list of nodes of MSS called authentication path which au-
thenticates the root of the L tree that corresponds to PK i, against
the root of the MSS tree, y0,0. As the public key of W-OTS+
can be computed using the random walks in the function family
Fn from the W-OTS+ signature, the XMSS signature does not in-
clude the aforementioned third component PK i of i-th instance of
W-OTS+. K2SN-MSS uses this structure of Merkle, and employ a
pseudo-random generator together with a random seed to generate
the secret key components. Hash keys and random pads are also
generated in a similar way.
K2SN-MSS: An Efficient Post-Quantum Signature (Full Version)
xxx, yyy, zzz
y0,0
y1,0
y1,1
yh−2,0
yh−1,0
yh−1,1
· · ·
yh−1, T2 −1
yh,0
L0
yh,1
L1
yh,2
L2
· · ·
yh,3
L3
yh,T−2
LT−2
yh,T−1
LT−1
Figure 1: Merkle Tree
yi, j
ki, j
Hki, j (y′
i, j ⊕ vi, j )
vi, j
y′
i, j
= (yi +1,2j∥yi +1,2j+1)
yi +1,2j
yi +1,2j+1
Figure 2: Intermediate node computation
2.5 SWIFFT: An Efficient Lattice-Based
Hash-Function
The SWIFFT family of hash functions [28] is defined by three
parameters: (i) ˆn: a power of 2, (ii) ˆm: a small integer, and (iii) p: a
prime (the construction works for non-prime also).
Let R be a ring as defined in the equation (3):
ˆn + 1).
R = Zp[X]/(X
(3)
A SWIFFT function of a given SWIFFT family is defined by ˆm
elements, a0, a1, . . . , a ˆm−1 ∈ R called multipliers. The input of a
SWIFFT function is a binary string of length ˆm ˆn: the input is divided
into ˆm ˆn-bit string, and each string is represented as an element of
R with binary coefficients. Let z = (z0, z1, . . . , z ˆm−1) be a SWIFFT
input, where zi is a ring element with binary coefficients. Then
hash of z is computed as,
SWIFFT(z) =
(ai · zi ) ,
(4)
ˆm−1(cid:88)
i =0
Notice that we do not apply iNTT on the output of equation 5
to get back the same result as of equation 4. As FFT is linear and
bijective, there is no need to apply iNTT on the output of equation 5
as suggested in [28].
Security. SWIFFT is an efficient instantiation of the generalized
compact knapsack [32] proposed in [28]. It has been proved [32] that
the generalized compact knapsack is asymptotically one-way, and
this implies that the SWIFFT family also enjoys the same property.
It has been also proved [27, 35], that SWIFFT is asymptotically
where the multiplications and the additions are in the ring R. For
computational efficiency, the ring multiplications are performed
using NTT and so SWIFFT is written as equation (5):
SWIFFT(z) =
.
(5)
(cid:16)NTT(ai ) ⊙p NTT(zi )
(cid:17)
ˆm−1(cid:88)
i =0
collision resistant. In [28], it is proved that the security of a SWIFFT
function reduces to the security of the subset-sum problem.
gSWIFFT. We use a generalized version of SWIFFT func-