Data button. Alternatively, you may decide that the fields belong to a useful plugin that hasn’t yet been
installed on the new Jenkins instance. In this case, install the plugin and all should be well. Finally, you
can always choose to leave the redundant data and live with the error message, at least until you are sure
that you won’t need to migrate the job back to the old server some day.
However, Jenkins doesn’t always detect all of the errors or inconsistencies—it still pays to keep one
eye on the system logs when you migrate your build jobs. For example, the following is a real example
from a Jenkins log file showing what can happen during the migration process:
Mar 16, 2010 2:05:06 PM hudson.util.CopyOnWriteList$ConverterImpl unmarshal
WARNING: Failed to resolve class
com.thoughtworks.xstream.mapper.CannotResolveClassException: hudson.plugins.ciga
me.GamePublisher : hudson.plugins.cigame.GamePublisher
at com.thoughtworks.xstream.mapper.DefaultMapper.realClass(DefaultMapper
.java:68)
at com.thoughtworks.xstream.mapper.MapperWrapper.realClass(MapperWrapper
.java:38)
at com.thoughtworks.xstream.mapper.DynamicProxyMapper.realClass(DynamicP
roxyMapper.java:71)
at com.thoughtworks.xstream.mapper.MapperWrapper.realClass(MapperWrapper
.java:38)
The error is essentially telling us that it can’t find a class called
hudson.plugins.cigame.GamePublisher. In fact, the target installation is missing the CI Game
plugin. And in this case (as sometimes happens), no warning messages where appearing on the Manage
Jenkins page, so Jenkins was unable to correct the configuration files itself.
358
The simplest solution in this case would be to install the CI Game plugin on the target server. But what
if we don’t want to install this plugin? We could leave the configuration files alone, but this might mask
more significant errors later on—it would be better to tidy them up.
In that case, we need to inspect and update the project configuration files by hand. On this Unix box, I
just used grep to find all the configuration files containing a reference to “cigame”:
$ cd $JENKINS_HOME/jobs
$ grep cigame */config.xml
project-a/config.xml: 
project-b/config.xml: 
project-c/config.xml: 
In these config.xml files, I found the reference to the CI Game plugin in the  sect1
(which is where the configuration for the reporting plugins generally goes):
...
...
To fix the issue, all I have to do is to remove the offending line:
...
...
The exact location of the plugin configuration data will vary depending on the plugin, but in general the
config.xml files are quite readable, and updating them by hand isn’t too hard.
So, all in all, migrating build jobs between Jenkins instances isn’t all that hard—you just need to know
a couple of tricks for the corner cases, and if you know where to look Jenkins provides some nice tools
to make the process smoother.
13.7. Conclusion
In this chapter, we looked at a number of considerations that you should be aware of if your job is to
maintain your Jenkins server, including how to monitor disk and server usage, how to back up your build
jobs and Jenkins configuration files, and also how to migrate build jobs and upgrade build data safely.
359
Appendix A. Automating Your Unit
and Integration Tests
A.1. Automating Your Tests with Maven
Maven is a popular open source build tool of the Java world, that makes use of practices such as
declarative dependencies, standard directories and build life cycles, and convention over configuration
to encourage clean, maintainable, high level build scripts. Test automation is strongly supported in
Maven. Maven projects use a standard directory structure: it will automatically look for unit tests in a
directory called (by default) src/test/java. There is little else to configure: just add a dependency
to the test framework (or frameworks) your tests are using, and Maven will automatically look for and
execute the JUnit, TestNG, or even Plain Old Java Objects (POJO) tests contained in this directory
structure.
In Maven, you run your unit tests by invoking the test life cycle phase, as shown here:
$ mvn test
[INFO] Scanning for projects...
[INFO] ------------------------------------------------------------------------
[INFO] Building Tweeter domain model
[INFO] task-segment: [test]
[INFO] ------------------------------------------------------------------------
...
-------------------------------------------------------
T E S T S
-------------------------------------------------------
Running com.wakaleo.training.tweeter.domain.TagTest
Tests run: 13, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.093 sec
Running com.wakaleo.training.tweeter.domain.TweeterTest
Tests run: 3, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.021 sec
Running com.wakaleo.training.tweeter.domain.TweeterUserTest
Tests run: 4, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.055 sec
Running com.wakaleo.training.tweeter.domain.TweetFeeRangeTest
Tests run: 10, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.051 sec
Running com.wakaleo.training.tweeter.domain.HamcrestTest
Tests run: 8, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.023 sec
Results :
Tests run: 38, Failures: 0, Errors: 0, Skipped: 0
In addition to executing your tests, and failing the build if any of the tests fail, Maven will produce a
set of test reports (again, by default) in the target/surefire-reports directory, in both XML and
text formats. For our CI purposes, it is the XML files that interest us, as Jenkins is able to understand
and analyze these files for its CI reporting:
$ ls target/surefire-reports/*.xml
target/surefire-reports/TEST-com.wakaleo.training.tweeter.domain.HamcrestTest.xml
target/surefire-reports/TEST-com.wakaleo.training.tweeter.domain.TagTest.xml
target/surefire-reports/TEST-com.wakaleo.training.tweeter.domain.TweetFeeRangeTest.xm
target/surefire-reports/TEST-com.wakaleo.training.tweeter.domain.TweeterTest.xml
target/surefire-reports/TEST-com.wakaleo.training.tweeter.domain.TweeterUserTest.xml
Maven defines two distinct testing phases: unit tests and integration tests. Unit tests should be fast and
lightweight, providing a large amount of test feedback in as little time as possible. Integration tests are
slower and more cumbersome, and often require the application to be built and deployed to a server
(even an embedded one) to carry out more complete tests. Both these sorts of tests are important, and for
a well-designed Continuous Integration environment, it is important to be able to distinguish between
them. The build should ensure that all of the unit tests are run initially—if a unit test fails, developers
should be notified very quickly. Only if all of the unit tests pass is it worthwhile undertaking the slower
and more heavyweight integration tests.
In Maven, integration tests are executed during the integration-test life cycle phase, which you
can invoke by running mvn integration-test or (more simply) mvn verify. During this phase,
it is easy to configure Maven to start up your web application on an embedded Jetty web server, or to
package and deploy your application to a test server, for example. Your integration tests can then be
executed against the running application. The tricky part however is telling Maven how to distinguish
between your unit tests and your integration tests, so that they will only be executed when a running
version of the application is available.
There are several ways to do this, but at the time of writing there is no official standard approach
used across all Maven projects. One simple strategy is to use naming conventions: all integration tests
might end in “IntegrationTest”, or be placed in a particular package. The following class uses one such
convention:
public class AccountIntegrationTest {
@Test
public void cashWithdrawalShouldDeductSumFromBalance() throws Exception {
Account account = new Account();
account.makeDeposit(100);
account.makeCashWithdraw(60);
assertThat(account.getBalance(), is(40));
}
}
In Maven, tests are configured via the maven-surefire-plugin plugin. To ensure that Maven only
runs these tests during the integration-test phase, you can configure this plugin as shown here:
...
maven-surefire-plugin
362
true¶
•
unit-tests
test
test
false
**/*IntegrationTest.java
‚
integration-tests
integration-test
test
false
**/*IntegrationTest.java
...
¶ Skip all tests by default—this deactivates the default Maven test configuration.
• During the unit test phase, run the tests but exclude the integration tests.
‚ During the integration test phase, run the tests but only include the integration tests.
This will ensure that the integration tests are skipped during the unit test phase, and only executed during
the integration test phase.
If you don’t want to put unwanted constraints on the names of your test classes, you can use package
names instead. In the project illustrated in Figure A.1, “A project containing freely-named test classes”,
all of the functional tests have been placed in a package called webtests. There is no constraint on the
names of the tests, but we are using Page Objects to model our application user interface, so we also
make sure that no classes in the pages package (underneath the webtests package) are treated as tests.
363
Figure A.1. A project containing freely-named test classes
In Maven, we could do this with the following configuration:
maven-surefire-plugin
true
unit-tests
test
test
false
**/webtests/*.java
integration-tests
integration-test
test
false
364
**/webtests/*.java
**/pages/*.java
TestNG currently has more flexible support for test groups than JUnit. If you are using TestNG, you
can identify your integration tests using TestNG Groups. In TestNG, test classes or test methods can be
tagged using the groups attribute of the @Test annotation, as shown here:
@Test(groups = { "integration-test" })
public void cashWithdrawalShouldDeductSumFromBalance() throws Exception {
Account account = new Account();
account.makeDeposit(100);
account.makeCashWithdraw(60);
assertThat(account.getBalance(), is(40));
}
Using Maven, you could ensure that these tests were only run during the integration test phase using
the following configuration:
...
maven-surefire-plugin
true
unit-tests
test
test
false
integration-tests¶
integration-tests
integration-test
test