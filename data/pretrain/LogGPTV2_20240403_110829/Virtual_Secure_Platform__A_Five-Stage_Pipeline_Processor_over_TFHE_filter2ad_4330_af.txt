accelerator library,” in Cryptography and Information
Security in the Balkans (E. Pasalic and L. R. Knudsen,
eds.), (Cham), pp. 169–186, Springer International Pub-
lishing, 2016.
[37] “Users page in ofﬁcial LLVM website.” http://llvm.
org/Users.html. Accessed 06/19/2020.
[38] “ACM Software System Award 2012 (LLVM).”
https://awards.acm.org/award_winners/
lattner_5074762. Accessed 06/19/2020.
[39] N. Matsumoto, R. Banno, and K. Matsuoka, “Speciﬁ-
cation for CAHPv3,” 2020. https://github.com/
virtualsecureplatform/cahpv3-spec.
[40] J. Bachrach, H. Vo, B. Richards, Y. Lee, A. Waterman,
R. Avižienis, J. Wawrzynek, and K. Asanovi´c, “Chisel:
Constructing hardware in a scala embedded language,”
in DAC Design Automation Conference 2012, pp. 1212–
1221, 2012.
[41] “Community page in ofﬁcial chisel website.” https:
//www.chisel-lang.org/community.html.
[42] D. A. Patterson and J. L. Hennessy, Computer Organi-
zation and Design, Fourth Edition, Fourth Edition: The
Hardware/Software Interface (The Morgan Kaufmann
Series in Computer Architecture and Design). San Fran-
cisco, CA, USA: Morgan Kaufmann Publishers Inc.,
4th ed., 2008.
[43] “Rocket
https://github.com/
chipsalliance/rocket-chip. Accessed 06/19/2020.
(risc-v).”
core
[44] P. M. Sailer, P. M. Sailer, and D. R. Kaeli, The DLX
Instruction Set Architecture Handbook. San Francisco,
CA, USA: Morgan Kaufmann Publishers Inc., 1st ed.,
1996.
4022    30th USENIX Security Symposium
USENIX Association
development
[45] X. Inc., “Microblaze processor reference guideem-
https:
bedded
//www.xilinx.com/support/documentation/sw_
manuals/xilinx11/mb_ref_guide.pdf. Accessed
06/19/2020.
kitedk
11.4.”
Schneider, and
[46] E. M. Songhori, S. U. Hussain, A. Sadeghi,
https:
T.
//github.com/esonghori/TinyGarble/tree/
d40454dd365a943c364c3e7de05039fe94728c7a/
circuit_synthesis/mips. Accessed 06/19/2020.
Koushanfar.
F.
[47] C.
Wolf,
“PicoRV32.”
https://github.
com/cliffordwolf/picorv32/tree/
f9b1beb4cfd6b382157b54bc8f38c61d5ae7d785.
Accessed 06/19/2020.
[48] R. Banno, K. Matsuoka, and N. Matsumoto, “Bench-
mark scripts for VSP,” 2020. https://github.com/
virtualsecureplatform/kvsp-benchmark.
[49] P. Paillier, “Public-key cryptosystems based on compos-
ite degree residuosity classes,” in Advances in Cryptol-
ogy — EUROCRYPT ’99 (J. Stern, ed.), (Berlin, Heidel-
berg), pp. 223–238, Springer Berlin Heidelberg, 1999.
[50] N. G. Tsoutsos and M. Maniatakos, “Heroic: Homomor-
phically encrypted one instruction computer,” in 2014
Design, Automation Test in Europe Conference Exhibi-
tion (DATE), pp. 1–6, 2014.
[51] O. Mazonka, “Higher subleq.” http://mazonka.com/
subleq/hsq.html, March 2011. Accessed 06/19/2020.
[52] P. T. Breuer, J. P. Bowen, E. Palomar, and Z. Liu, “A
practical encrypted microprocessor,” in Proceedings of
the 13th International Joint Conference on E-Business
and Telecommunications, ICETE 2016, (Setubal, PRT),
p. 239–250, SCITEPRESS - Science and Technology
Publications, Lda, 2016.
A Related Work
Although FURISC is the most similar existing study to our
proposed method, we will discuss other studies here. There are
some previous works which uses Paillier Cryptosystem [49]
to evaluate encrypted binaries. HEROIC [50] is the ﬁrst one.
Paillier cryptosystem is one kind of Partial Homomorphic En-
cryption (PHE). Paillier Cryptosystem only permits addition
of integers. Therefore, HEROIC uses some tables to provide
enough functionality to implement a processor as Arithmetic
circuit. HEROIC implements an OISC processor which only
supports SUBtract and branch if Less-than or EQual to zero
(SUBLEQ) instruction. Unlike to FURSIC, there is a C like
language compiler for SUBLEQ, HIGHER SUBLEQ, though
its last update is in March 2011 [51]. The use of the tables
Figure 14: Protocol ﬂow of PF-SFE
leads the ciphertexts becomes deterministic. This means the
public key cannot be public. Therefore HEROIC theoretically
cannot achieve two-party PF-SFE. In addition, the method
of using the table has not been proven to be secure. The au-
thors of HEROIC also proposed Cryptoleq in 2016 [24]. It
also uses Paillier Cryptosystem with some tables and OISC.
They also proposed assembly-like Domain Speciﬁc Language
(DSL) in it. Cryptoleq depends on the random number gen-
eration of the server. This is not suitable characteristic for
SMPC since it needs the veriﬁcation of the random number
generator. Cryptoleq also depends on heuristic code-based
obfuscation. There is a Open RISC implementation based on
idea of HEROIC [52], but this is suffered from too much mem-
ory consumption because of big tables. The authors estimated
it to be between hundreds of gigabytes to terabytes.
B Abstract Protocol Flow in two-party PF-
SFE
In this section, we explain how the protocol ﬂow of VSP can
be theoretically modiﬁed to do two-party PF-SFE.
Public/Private Data: In this protocol, the function to be
evaluated is provided by Bob and the input data is provided
by Alice. The most important fact for understanding how
VSP works in this protocol is that TFHE supports “trivial”
ciphertexts. “Trivial” here means the generation of them does
not need any secret key nor random number generation. For
example, trivial TLWE of 1 is (0,µ). In such a way, Bob can
provide ROM and RAM data without the input of Alice.
ROM data and RAM data except for the input of Alice are
private of Bob and the input is private of Alice.
B.1 Abstract protocol workﬂow
The visual image is shown in Figure 14. This shows only
difference from two-party SCO case.
3. Compilation: Bob compiles the source code of the de-
sired function into the executable for the processor.
USENIX Association
30th USENIX Security Symposium    4023
AliceBob3. CompilationRAM4. EncryptionSource CodeInputROMExecutableTable 7: Runtime performance evaluation in 1 KiB ROM and RAM setting
Machine
# of V100
Pipelining? CMUX Memory?
# of cycles
AWS p3.8xlarge
AWS p3.8xlarge
AWS p3.8xlarge
AWS p3.8xlarge
AWS c5.metal
AWS c5.metal
4
4
4
4
0
0
No
No
Yes
Yes
No
Yes
No
Yes
No
Yes
Yes
Yes
937
937
1217
1217
937
1217
Runtime [s]
3306.0± 12.9
1733.4± 1.1
3804.0± 18.6
1217.0± 2.4
3230.0± 40.6
3940.0± 68.4
sec./cycle
3.528± 0.014
1.850± 0.001
3.126± 0.015
1.000± 0.002
3.443± 0.043
3.238± 0.056
# of tries
2
3
3
5
3
3
Table 8: Resource requirements of CAHP-Ruby.
Gate
AND
ANDNOT
MUX
NAND
NOR
NOT
OR
ORNOT
XNOR
XOR
IF
193
59
54
300
4
3
77
39
3
4
ID+WB
270
110
683
336
77
4
56
142
9
5
Ex Mem Total
651
301
223
44
256
996
1025
356
90
31
15
11
95
215
195
40
51
40
21
36
92
0
116
10
0
1
8
8
0
0
Table 9: The number of CMUXs in CMUX Memory
Component
# of CMUXs
RAM Read Unit
RAM Write Unit
ROM
Total
4,080
32,768
8
36,856
4. Encryption: Alice encrypts the input and sends it to Bob.
Bob encrypts the executable using trivial ciphertexts and
combines it with the encrypted input to generate the
encrypted ROM and RAM.
B.2 Security Analysis in Two-party PF-SFE
Bob tries to reveal plaintexts of Bootstrapping Key, RAM,
registers and each ciphertext of each wire, etc. ROM (the
function to be evaluated) is not a target since it is provided
by Bob. However, like two-party SCO case, this can be re-
duced to the hardness of decryption of ciphertexts of TFHE.
Alice tries to reveal ROM, RAM, registers and ciphertexts
of each wire, etc. Though they will not be provided to Alice,
Alice knows the result of the function, so if Bob uses always
the same function and input, Alice can try to get the results
for all possible inputs. Therefore, the protection of private
information of Bob from Alice needs another method like
indistinguishable obfuscation. This is beyond the scope of our
proposed method.
We note that PF-SFE protocol does have the FHE malleabil-
ity problem, since the program is provided by Bob. However,
PF-SFE is still vulnerable to the termination problem men-
tioned in Section 4.1.
C Additional Evaluations
Runtime Performance Evaluation
Table 7 shows additional results in 1 KiB ROM and RAM
setting.
Gate count evaluation
Table 8 shows the gate requirements of each stage of CAHP-
Ruby. Note that these values are calculated by synthesising
the components separately. Due to global optimizations in the
synthesis software, the numbers do not add up to the size of
the entire processor circuit (the column “Total”).
Also, Table 9 shows the number of CMUXs in CMUX
Memory components.
Memory consumption evaluation
On p3.8xlarge, running our implementation consumes about
3.7 GB of main memory and about 0.6 GB per GPU. The
most of memory consumption seems to be caused by holding
Bootstrapping Key.
4024    30th USENIX Security Symposium
USENIX Association