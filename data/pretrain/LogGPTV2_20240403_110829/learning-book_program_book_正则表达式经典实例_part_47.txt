正则流派：PCRE、Perl
\A(？>（?>\\n？1[\n-\f\x85\u2028\u2029])？[^\n-\r\x85\u2028\u2029]*)(0,5}\z
正则选项：无
正则流派：.NET、Java、Ruby
\A（？:（？:\r\n？1[\n-\f\x85\u2028\u2029]）？[\n-\r\x85\u2028\u2029]*){0,5}\z
正则选项：无
正则流派：Python
（？：（？:\r\n？|[\n-\f\x85\u2028\u2029]）？[^\n-\r\x85\u2028\u2029]*）(0,5}$
正则选项：无
正则流派：JavaScript
所有这些正则式可以处理在表4-1中列出的行分隔符，表中同时列出了它们的Unicode
位置和名称。
表4-1行分隔符
Unicode序列
等价正则式
名
称
使用场合
U+000DU+000A
回车和换行(CRLF)
Windows和MS-DOS文本文件
U+000A
换行(LF)
Unix、Linux和OSX文本文件
U+000B
(lv>
垂直制表符(VT)
（不常见）
U+000C
f
换页 (FF)
（不常见）
U+000D
回车(CR)
MacOS文本文件
U+0085
x85>
下一行(NEL)
IBM主机文本文件
U+2028
（u2028或
行分隔符
（x{2028})
（不常见）
U+2929
\u2029或
lx{2029}>
段分隔符
（不常见）
240
第4章
www.TopSage.com
---
## Page 257
参见
实例4.9。
4.11肯定响应的检查
问题描述
你想要检查一个配置选项或者命令行响应是否返回了一个肯定取值。你希望在可接受
的响应中提供一些灵活性，可以接受true、t、yes、y、okay、ok和1，以及所有相应的
大小写组合形式。
解决方案
使用一个正则表达式来把所有可接受的形式组合起来，只进行一个简单测试就可以完
成这个检查。
正则表达式
^ (?:11t (?:rue) ?1y(?:es) ?|ok (?:ay) ?) $
正则选项：不区分大小写
正则流派：.NET、Java、JavaScript、PCRE、Perl、Python、Ruby
JavaScript
var yes = /^ (?:lIt (?:rue) ?ly(?:es) ?|ok(?:ay) ?) $/i;
if (yes.test(subject)){
alert("Yes");
}else{
alert("No");
}
其他编程语言
3.5中的讲解。
讨论
下面的分解中给出了上述正则表达式的每个组成部分。容易读懂的记号组合被显示在
了同一行中：
A
#判断字符串的开始位置
(?：
分组但是不捕获...
合法性验证和格式化
241
www.TopSage.com
---
## Page 258
1
匹配一个字面的“1"
#或者...
t(?:rue) ?
？#匹配“t"，后面可能会跟着“rue”
善或者...
y(?:es)?
#匹配“y"，后面可能会跟着"es"
#或者...
ok(?:ay) ?
#匹配“ok”，后面可能会跟着"ay”
#非捕获分组的结束
$
#判断字符串的结束位置
正则选项：不区分大小写、宽松排列
正则流派：.NET、Java、PCRE、Perl、Python、Ruby
不同的形式。例如，（^（?:[1ty]trueyesok(?:ay)?)S>也是一种完全正确的解答。简单地在
所有7个取值中进行选择也没有问题，比如采用(?:1lttruelylyeslokjokay)S)，然而就性
能来说，减少使用管道操作符小实现的多选结构的大小，而改用字符类或者可选后缀
（使用量词?>）的效率会比较高。在这个例子中，性能的差别可能不会超过几个微秒，
但是在脑子里对正则式性能问题有个概念是比较好的。有时候，在不同实现方式之间
的区别可能会让你大吃一惊。
所有这些例子都把可能的匹配取值放到了一个非捕获分组中，以便限制多选操作符的
作用范围。如果我们略掉了分组结构，而使用了类似^truelyesS>的形式，那幺正则引
单电，，星n，长电，星率受泰
后是字符串的结束。
参见
实例5.2和实例5.3。
4.12社会安全号码的合法性验证
问题描述
你想要检查用户输人的文本是不是一个合法的社会安全号码（SocialSecuritynumber）。
解决方案
如果你只是需要保证一个字符串遵守了基本的社会安全号码格式，从而可以排除明
显不合法的号码，那么下面的正则表达式提供了一个简单的解决方案。如果你需要
更加严格的解答，可以通过社会安全管理局（SocialSecurityAdministration）来检查
到底该号码是否真的属于一个人，那么请参考在本实例的“参见”小节中给出的
链接。
242第4章
www.TopSage.com
---
## Page 259
正则表达式
(?!000|666)(?:[0-6][0-9]{2}17(?:[0-6][0-9]17[0-2]))=
(?!00)[0-9]{2}-(?!0000)[0-9](4}$
正则选项：无
正则流派：.NET、Java、JavaScript、PCRE、Perl、Python、Ruby
Python
if re.match(r"(?!0001666)(?:[0-6][0-9]{2}17(?:[0-6][0-9]17[0-21))-
(?!00)[0-9]{2}-(?!0000)[0-9]{4}$",sys.argv[1]) :
print "SSN is valid"
else:
print "sSN is invalid"
其他编程语言
如果读者希望知道在其他编程语言中如何实现这个正则表达式，那么请参考实例3.5中
的讲解。
讨论
美国的社会安全号码包含9个数字，它采用的形式是AAA-GG-SSSS。
前三个数字是根据地理区域分配的，被称作是区号（areanumber）。区号不能是000
或666，在本书写作之时，合法的社会安全号码中包含的区号都不大于772。
第4位和第5位数字被称作是组号（groupnumber），范围可以是01～99。
最后四位是序号（serialnumber），范围可以是0001～9999。
这个实例遵守了上面列出的规则。下面我们再对这个正则表达式进行一下分解：
#判断字符串的开始位置
(？!0001666)
#检查这里不能匹配“000”或“666”
(? :
分组但是不捕获...
[0-6]
#
匹配“0”到“6”之间的一个数字
[0-9](2}
匹配一个数字刚好两次
井
或者...
7
匹配一个字面的“7"
(?：
分组但是不捕获...
[9-0]
#
匹配“0”到“6”之间的一个数字
[0-9]
匹配一个数字
1
或者...
匹配一个字面的“7"
[0-2]
匹配“0”到“2”之间的一个数字
非捕获分组的结束
#非捕获分组的结束。
匹配一个字面的“-"
(00i)
#检查这里不能匹配“00"
合法性验证和格式化
243
www.TopSage.com
---
## Page 260
[0-9](2}
#匹配一个数字刚好两次
匹配一个字面的“_"
(00001)
#检查这里不能匹配“0000“
[0-9]{4}
#匹配一个数字刚好四次
$
#判断字符串的结束位置
正则选项：宽松排列
正则流派：.NET、Java、PCRE、Perl、Python、Ruby
除了用来判断字符串开始和结束位置的记号和之外，这个正则式可以被分解为
由连字符分隔的3组数字。第一组是最为复杂的。第二组和第三组会分别简单匹配2
个或4个数字，但是使用一个前置的否定型顺序环视来排除匹配全0的可能性。
第一组中的数学要复杂很多，而且比其他两组更难理解，因为它匹配了一个数值范围。
首先，它使用否定型顺序环视（?!000666)）来排除特殊的取值“000”和“666”。接下
来需要做的任务是去掉任何大于772的数字。
因为正则表达式处理的文本，而不是数字，所以我们就必须要逐个学符来分解数值范
围。首先，我们知道可以匹配0～6开头的任意三个数字，因为前面的否定型顺序环视
已经排除了不合法的数字000和666。这第一个部分很容易使用两个字符类和一个量词
来实现：。因为我们还要为以7开头的数字提供一个多选结构，所以我
们刚刚构造的模式被放到了-一个分组，这个正则式会匹配数字7后面跟着两种不同的第二
个和第三个数字的选择。
最后，把它加到第一组数字的外层分组中，你就得到了最后的结果：(?：[0-6][0-9]
{2}7(?：[0-6][0-9]7[0-2]))>。这样你就成功创建了可以匹配000～772之间的-一个三位数
的正则表达式。