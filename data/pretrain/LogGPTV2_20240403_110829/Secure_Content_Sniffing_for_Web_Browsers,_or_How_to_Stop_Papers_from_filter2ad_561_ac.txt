Web site. In a typical attack, the attacker uploads malicious
content to the honest Web site and then directs the user’s
browser to render that content. We base our threat model on
the standard Web attacker threat model [33]. Even though the
Web attacker has more abilities than are strictly necessary
to carry out a content-snifﬁng XSS attack, we use this threat
model to ensure our defenses are robust.
• Attacker abilities. The attacker owns and operates
a Web site with an untrusted domain name, canon-
ically https://attacker.com/. These abilities can all be
purchased on the open market for a nominal cost.
• User behavior. The user visits https://attacker.com/, but
does not treat attacker.com as if it were a trusted site.
For example, the user does not enter any passwords
at attacker.com. When the user visits attacker.com, the
attacker is “introduced” to the user’s browser, letting
the attacker redirect the user to arbitrary URLs. This
assumption captures a central principle of Web security:
browsers ought to protect users from malicious sites.
• Honest Web site behavior. The honest Web site lets
the attacker upload content and then makes that content
available at some URL. For example, a social network-
ing site might let its users (who are potential attackers)
upload images or videos. We assume that the honest
site restricts what content the attacker can upload.
The most challenging part of constructing a useful threat
model is characterizing how honest Web sites restrict up-
loads. For example, some honest sites (e.g., ﬁle storage
services) might let users upload arbitrary content, whereas
other sites might restrict the type of uploaded content (e.g.,
photograph sharing services) and perform different amounts
of validation before serving the content to other users. Based
on our case studies, we believe that many sites either restrict
the Content-Types they serve or ﬁlter content when
uploaded (or both):
• Restrict Content-Type. Some Web sites restrict the
Content-Type header they use when serving con-
tent uploaded by users. For example, a social net-
working Web site might enforce that
its servers
attach a Content-Type header beginning with
image/ to photographs, or a conference manage-
ment Web application might serve papers only with a
Content-Type header of application/pdf or
application/postscript.
• Filter uploads. When users upload content, some sites
use a function like PHP’s finfo_file to check
the initial bytes of the ﬁle to verify that the content
conforms to the appropriate MIME type. For example, a
photo sharing site might verify that uploaded ﬁles actu-
ally appear to be images and a conference management
Web site might check that uploaded documents actually
appear to be in PDF or PostScript format. Although
not all MIME types can be recognized by their initial
bytes, we assume sites only accept types commonly
used on the Web. For these types, the initial bytes are
dispositive.
We also assume that the honest site uses standard XSS
defenses [34] to sanitize untrusted portions of HTML docu-
ments. However, we assume the honest site does not apply
these sanitizers to non-HTML content because using an
HTML sanitizer, such as PHP’s htmlentities, on an
image makes little sense because converting  matches both the
GIF signature and the HTML signature. Firefox 3 and
Google Chrome use a strict HTML signature that requires
the ﬁrst non-whitespace characters to be a known HTML tag.
According to our experiments on the Google search database
(see Section 3.4), tolerating leading white space matches
9% more documents than requiring the initial characters of
the content-snifﬁng buffer to be a known HTML tag. We
recommend this HTML signature because the signature is
preﬁx-disjoint from the other signatures.
3.4. Compatibility Evaluation
To evaluate the compatibility of our principles for secure
content snifﬁng, we implement a content-snifﬁng algorithm
that follows both of our design principles and collaborate
with Google to ship the algorithm in Google Chrome. We
use the following process to design the algorithm:
1) We evaluate the compatibility of our design principles
over Google’s search database, which contains billions
of Web documents.
2) Google’s quality assurance team manually tests our
implementation for compatibility with the 500 most
popular Web sites.
3) We deploy the algorithm to millions of users and
improve the algorithm using aggregate metrics.
Search database. To avoid privilege escalation, our content-
snifﬁng algorithm does not
sniff HTML from most
Content-Type values. To evaluate whether this behavior
is compatible with the Web, we run a map-reduce query [36]
over Google’s search database. One limitation of this ap-
proach is that each page in the database contributes equally
to the statistics, but users visit some pages (such as the CNN
home page) much more often than other pages. The other
two steps in our evaluation attempt to correct for this bias.
From this data, we make the following observations:
• <!DOCTYPE html is the most
frequently occur-
ring initial HTML tag in documents that
lack a
Content-Type header. (We assign these documents
a relative frequency of 1.)
• <html is the next most frequently occurring initial
HTML tag in documents missing a Content-Type
header. This occurs with relative frequency 0.612. For
clarity, we limit the remainder of our statistics to this
tag, but the results are similar if we consider all valid
HTML tags.
• <html occurs as the initial bytes of documents with
a Content-Type of text/plain with relative fre-
quency 0.556, which is approximately the same relative
frequency as for documents with a Content-Type of
unknown/unknown.
• <html occurs as the initial bytes of documents with
a bogus Content-Type (i.e., missing a slash) with
relative frequency 0.059.
• When the Content-Type is valid, HTML tags occur
with relative frequency less than 0.001.
From these observations, we conclude that, with the possible
exception of text/plain, a content-snifﬁng algorithm
can avoid privilege escalation by limiting when it sniffs
HTML and remain compatible with a large percentage of the
Web. From these observations, we do not draw a conclusion
about text/plain because the data indicates that not
snifﬁng HTML from text/plain is roughly as com-
patible as not snifﬁng HTML from unknown/unknown,
367
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 03:16:06 UTC from IEEE Xplore.  Restrictions apply. 
Signature
DATA[0:2] == 0xffd8ff
strncmp(DATA,"GIF89a",6) == 0
(DATA[0:3] == 0x89504e47) &&
(DATA[4:7] == 0x0d0a1a0a)
strncasecmp(PTR,"<SCRIPT",7) == 0
strncasecmp(PTR,"<HTML",5) == 0
strncmp(PTR,"<?xml",5) == 0
Mime Type
image/jpeg
image/gif
image/png
Percentage
58.50%
13.43%
5.50%
text/html
text/html
application/xml
16.11%
1.25%
1.10%
Table 3. The most popular signatures according to statistics collected from opt-in Google Chrome users. PTR is a
pointer to the ﬁrst non-whitespace byte of DATA.
yet none of the other major browsers sniff HTML from
unknown/unknown. In our implementation, we choose
to sniff HTML from unknown/unknown but not from
text/plain because unknown/unknown is not a valid
MIME type.
Top 500 sites. We implement a content-snifﬁng algorithm
for Google Chrome according to both of our design princi-
ples. To evaluate compatibility, the Google Chrome quality
assurance team manually analyzed the 500 most popular
Web sites both with and without our content-snifﬁng algo-
rithm. With the algorithm disabled, the team found a number
of incompatibilities with major Web sites including Digg and
United Airlines. With the content-snifﬁng algorithm enabled,
the team found one incompatibility due to the algorithm
not snifﬁng application/x-shockwave-flash from
text/plain. However, every major browser is incompat-
ible with this page, suggesting that this incompatibility is
likely be resolved by the Web site operator.
Metrics. To improve the security of our algorithm, we
instrument Google Chrome to collect metrics about
the
effectiveness of each signature from users who opt in to
sharing their anonymous statistics. Based on this data, we
ﬁnd that six signatures (see Table 3) are responsible for 96%
of the time the content snifﬁng algorithm changes the MIME
type of an HTTP response. Based on this data, we remove
over half of the signatures used by the initial algorithm. This
change has a negligible impact on compatibility because
these signatures trigger less than 0.004% of the time the
content snifﬁng algorithm is invoked. Removing these signa-
tures reduces the attack surface presented by the algorithm.
Google has deployed our modiﬁed algorithm to all users of
Google Chrome.
3.5. Adoption
In addition to being deployed in Google Chrome, our
design principles have been standardized by the HTML 5
working group and adopted in part by Internet Explorer 8.
Standardization. The HTML 5 working group has adopted
both of our content-snifﬁng principles in the draft HTML 5
speciﬁcation [5]. The current draft advocates using preﬁx-
disjoint signatures and classiﬁes MIME types as either
safe or scriptable. Content served with a safe MIME type
carries no origin, but content served with a scriptable
MIME type conveys the (perhaps limited) authority of its
origin. The speciﬁcation lets browsers sniff safe types from
HTTP responses with valid Content-Types (such as
text/plain) but forbids browsers from snifﬁng scriptable
types from these responses, avoiding privilege escalation.
Internet Explorer 8. The content-snifﬁng algorithm in
Internet Explorer 8 differs from the algorithm in Internet
Explorer 7. The new algorithm does not sniff HTML from
HTTP responses with a Content-Type header that begins
with the bytes image/ [11], partially avoiding privilege
escalation. This change signiﬁcantly reduces the content-
snifﬁng XSS attack surface, but it does not mitigate attacks
against sites, such as HotCRP, that accept non-image uploads
from untrusted users.
4. Related Work
In this section, we relate the current approaches used by
sites that allow user uploads. These approaches provide an
incomplete defense against content-snifﬁng XSS attacks. We
also describe historical instances of content-snifﬁng XSS and
related attacks.
Transform content. Web sites can defend themselves
against content-snifﬁng XSS attacks by transforming user
uploads. For example, Flickr converts user-uploaded PNG
images to JPEG format. This saves on storage costs and
makes it more difﬁcult to construct chameleon documents
because HTML content inside the PNG is often destroyed
by the transformation. Unfortunately, this approach does not
guarantee security because an attacker might be able to craft
a chameleon that survives the transformation. Also, sites
might have difﬁculty transforming non-media content, like
text documents.
Host content off-domain. Some sites host user-supplied
content on an untrusted domain. For example, Wikipedia
hosts English-language articles at en.wikipedia.org but hosts
368
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 03:16:06 UTC from IEEE Xplore.  Restrictions apply. 
uploaded images at upload.wikimedia.org. Content-snifﬁng
XSS attacks compromise the http://upload.wikimedia.org
origin but not the http://en.wikipedia.org origin, which con-
tains the user’s session cookie. This approach has a couple
of disadvantages. First, hosting uploads off-domain compli-
cates the installation of redistributable Web applications like
phpBB, Bugzilla, or mediawiki. Also, hosting uploads
off-domain limits interaction with these uploads. For exam-
ple, sites can display off-domain images but cannot convert
them to data URLs or use them in SVG ﬁlters. Although
hosting user-uploaded content off-domain is not a complete
defense, the approach provides defense-in-depth and reduces
the site’s attack surface.
Disable content snifﬁng. Users can disable content snifﬁng
using advanced browser options, at the cost of compatibility.
Sites can disable content snifﬁng for an individual HTTP re-
sponse by adding a Content-Disposition header with
the value attachment [37], but this causes the browser to
download the ﬁle instead of rendering its contents. Another
approach, used by Gmail, to disable content snifﬁng is to
pad text/plain attachments with 256 leading whitespace
characters to exhaust Internet Explorer’s snifﬁng buffer.
Internet Explorer 8 lets sites disable content snifﬁng for an
individual HTTP response (without triggering the download
handler) by including an X-Content-Type-Options
header with the value nosniff [38]. This feature lets
sites opt out of content snifﬁng but requires sites to modify
their behavior. We believe this header is complementary to
securing the content-snifﬁng algorithm itself, which protects
sites that do not upgrade.
Content-snifﬁng XSS attacks. Previous references to
content-snifﬁng XSS attacks focus on the construction