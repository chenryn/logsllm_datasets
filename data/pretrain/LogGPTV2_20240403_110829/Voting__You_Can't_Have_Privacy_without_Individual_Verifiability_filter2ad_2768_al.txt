Expverif−careful
A
Note that, in these reduction, for each id in U1, B makes at most as many calls to Op,c
. In addition, for each id in
vote
Thus, the exact same proof proves that the result also holds if both the games Exppriv−careful and Expverif−careful are modified to prevent
□
U2, B makes at most one call to Op,c
vote
revote, by allowing only one call to Op,c
vote
as A makes to Ov,c
vote
for each id.
/Ov,c
vote
.
27
Oi
c(id, cred, v0, v1)
b ← Vote(id, cred, pk, vβ)
L ← L∥extract(b)
return b
Expind, βA (λ)
(pk, sk) ← Setup(1λ)
U, CU ← []
state ← AOreg,Ocorr
L ← []
β′ ← AOi
2
return β′
c ,Oi
1
d
(state, pk)
(pk)
A2 is only allowed one call to Oi
d
d(bL)
Oi
dL ← []
for b ∈ bL do
dL ← dL∥⊥
return dL
if extract(b) (cid:60) L then
dL ← dL∥(opencred(b, sk, U), open(b, sk, U))
else
Figure 15: IND − CCA-like property on the ballot creation function
Appendix C CASE STUDY
C.1 Assumptions
To prove that the protocols we study satisfy the different privacy properties, we will in some cases assume that no adversary wins ExpNM
(presented on Figure 7) with non-negligible probability. We will also in some cases use the assumption that the ballot creation function has a
property similar to the IND − CCA property i.e. that
(cid:12)(cid:12)(cid:12)P(cid:104)
A (λ) = 1(cid:105) − P(cid:104)
Expind,0
A (λ) = 1(cid:105)(cid:12)(cid:12)(cid:12) is negligible
Expind,1
∀A.
where Expind is defined on Figure 15. This definition assumes a function open(b, sk, U) that returns the vote contained in the ballot b, i.e. for
all election keys (pk, sk) and list of users and credentials U,
∀id, cred, v. open(Vote(id, cred, pk, v), sk, U) = v.
It also assumes a function extract(b), that represents the ciphertext part in b. Typically, if b has the form (id, c) where id is the identity of
the voter and c the ciphertext containing the vote, we have openid(b) = id and extract(b) = c. This corresponds to the case of Helios and
Belenios in our case study. For the other protocols we study, extract(b) = b.
C.2 Proofs
C.2.1 Civitas is private for Exppriv.
d
1
c, Oi
(pk) first simulates AOreg, Ocorr
(state1, pk) maintains lists V0, V1, BB, initially empty, which will be used to simulate the lists with the same name in Exppriv.
(pk), i.e. B registers and corrupts the same identities as A, while keeping lists U1, CU1 of
1. B1 then corrupts each user A1 has registered,
Theorem C.1. Assuming no adversary wins Expind nor ExpNM with non-negligible probability, Civitas is private for Exppriv.
Proof. Let A = A1, A2, A3 be an adversary that wins Exppriv. We consider an adversary B = B1, B2 that plays Expind:
• BOreg, Ocorr
1
the identities it declares and corrupts by calling Oreg and Ocorr. A returns some state′
i.e., B1 calls Ocorr(id) for each id A1 has declared, and stores each id’s credential in a list CU2.
• BOi
2
B2 will also use lists hL, cL, initially empty.
B2 first simulates AOp
vote, Ocast
1, pk):
2
vote(id, v0, v1), provided id ∈ U1\CU1, B checks whether id is already present in V0, V1. Provided it is not, B
– for each call to Op
then retrieves id’s credential credid from CU2, and calls Oi
c(id, credid, v0, v1). B obtains a ballot b. B then appends b to BB and hL,
(id, v0) to V0, (id, v1) to V1. Finally B returns b to the simulated A.
– for each call to Ocast(id, b), provided id ∈ CU1 and Valid(id, b, BB, pk), B appends b to BB, and to cL.
We write cL\hL (resp. cL ∩ hL) the sublist of cL (in the same order) of ballots that do not occur (resp. do occur) in hL.
• B2 then computes ρ(V0), ρ(V1), and check they are equal.
• B2 calls Oi
d(cL\hL), and obtains a list L of pairs of credentials and votes. B2 then computes the list L′ of the first vote for each
accepts to
credential in L. Note that, by construction, no ballot in cL\hL has been generated by a call to Oi
open all ballots in cL\hL.
• B2 computes r = ρ(V0) ∗ ρ(L′), calls A3 on r, and obtains a bit β′. B2 returns β′.
c, which means that Oi
(state′
d
28
Note that the lists BB, V0, V1 in B are equal to the lists of the same name in Exppriv, βA . Then, by construction, A2 is always accurately
simulated by B2, i.e. it is called on the same inputs, shown the same board, and provided with the same oracles as what would happen in
Exppriv, βA .
We also construct an adversary C, that plays the game ExpNM.
• C1 simulates A1, similarly to B1. However, unlike B1, it stops there, and does not corrupt all identities.
• C2 first draws at random a bit β′′, Similarly to B2, C2 then simulates A2 and uses lists BB, cL, hL, V:
– for each call to Op
(id, vβ′′) to V. Finally C returns b to the simulated A.
– for each call to Ocast(id, b), provided id ∈ CU1 and Valid(id, b, BB, pk), C appends b to BB and cL.
• Once C2 has finished simulating A2, it draws at random an element of cL and returns it.
vote(id, v0, v1), provided id ∈ U1\CU1, C calls Oc(id, vβ′′). C obtains a ballot b and appends b to BB and hL, and
Note that the lists BB, cL, hL are the same for C in ExpNM at the point C2 returns, and for B in Expind at the point B2 returns. Similarly V in
C is the same as Vβ′′ in B. Let us also notice that hL in C is equal to the list L in the game ExpNM.
We will now prove that if A breaks privacy, then B wins Expind provided C does not win ExpNM.
The adversary C is polynomial, i.e. there exists a polynomial q(λ) bounding its number of operations. q(λ) necessarily also bounds the
length of the list cL that C uses.
For any β, assume cL\hL contains a ballot b such that there exists a honest (∗, cred) ∈ U\CU such that opencred(b, sk, U) = cred (note
that U,CU in ExpNMC are equal to U1, CU1 in B). Thus, provided C correctly guesses β′′ = β, and chooses this b from cL, the condition
b (cid:60) L ∧ ∃(∗, cred) ∈ U\CU. opencred(b, sk, U) = cred in ExpNMC holds. Indeed, since b (cid:60) hL, b (cid:60) L. Thus ExpNMC = 1.
ExpNMC = 1(cid:105), which is smaller than 2q(λ) P(cid:104)
ExpNMC = 1(cid:105) since |cL| ≤ q(λ).
Therefore, such a ballot b exists with probability at most 2|cL| P(cid:104)
ExpNMC = 1(cid:105).
holds except with probability at most 2q(λ) P(cid:104)
For any β, Expind, βB
Assume cL\hL does not contain any ballot associated with a honest credential (i.e. a credential in U1\CU1), which, as we have established,
(λ) = 1 if and only if B2 returns 1 in this game.
ρ(V0) = ρ(V1); and it is provided with the actually tally of the board BB (which A2 interacted with).
Let us then show that A3 is accurately simulated by B2, i.e. it is simulated by B2 only when it is called in Exppriv, βA , that is, when
Indeed, by construction of B2, BB = hL ⊎ cL is an interleaving of the ballots from hL and cL.
By assumption, cL\hL contains no ballot from honest credentials, while by construction hL (and thus cL ∩ hL) only contains ballots from
honest credentials. Hence, the list BBd of ballots in BB associated with dishonest credentials is cL\hL (in that order). The list BBh of ballots in
BB associated with honest credentials is an interleaving of the ballots from the lists hL and cL ∩ hL. However, by construction, hL contains
at most one ballot for each credential. Thus, BBh also contains at most one distinct ballot (of which there can be several copies) for each
credential. The list of distinct ballots in BBh (not necessarily in the same order) is thus hL.
The revote policy specified for Civitas is to count only the first ballot corresponding to each credential. Since BB can be separated into the
lists BBh and BBd (whose ballots do not share any credential, by definition), and since the ballots of each of these two lists occur in the same
order in BB, we have
Tally(BB, sk, U1) = Tally(BBh, sk, U1) ∗ Tally(BBd , sk, U1) = Tally(hL, sk, U1) ∗ Tally(cL\hL, sk, U1).
hL contains ballots for either the votes in V0 or those in V1, depending on β. Since at that point ρ(V0) = ρ(V1), we have ρ(V0) =
returns the list L of the credentials and votes of each ballot in cL\hL. Since L′ is the list of the
Tally(hL, sk, U1). In addition, the oracle Oi
first vote for each credential in L, we thus have Tally(cL\hL, sk, U1) = ρ(L′). Therefore, ρ(V0) ∗ ρ(L′), which is the result computed by B2, is
d
indeed Tally(BB, sk, U1), which concludes the proof that A3 is accurately simulated by B2.
Hence, unless cL\hL contains a ballot associated with a honest credential, Expind, βB
Thus
returns 1, i.e. if and only if Exppriv, βA (λ) = 1.
(λ) = 1(cid:105) − P(cid:104)
Exppriv, βA (λ) (cid:44) 1(cid:105)(cid:12)(cid:12)(cid:12) ≤ 2q(λ) P(cid:104)
ExpNMC = 1(cid:105)
(cid:12)(cid:12)(cid:12)P(cid:104)
We thus have:
Expind, βB
(λ) = 1 if and only if the accurately simulated A3
.
(6)
29
(cid:12)(cid:12)(cid:12)P(cid:104)
A (λ) = 1(cid:105) − P(cid:104)
Exppriv,0
Exppriv,1
Therefore, if A breaks privacy, i.e. if(cid:12)(cid:12)(cid:12)P(cid:104)
ExpNM.
(cid:12)(cid:12)(cid:12)(cid:16)P(cid:104)
A (λ) = 1(cid:105)(cid:12)(cid:12)(cid:12) =
(cid:16)P(cid:104)
≤ (cid:12)(cid:12)(cid:12)P(cid:104)
(cid:12)(cid:12)(cid:12)P(cid:104)
≤ (cid:12)(cid:12)(cid:12)P(cid:104)
A (λ) = 1(cid:105) − P(cid:104)
Exppriv,0
Expind,1
Exppriv,0
Expind,1
Expind,0
A (λ) = 1(cid:105) − P(cid:104)
B (λ) = 1(cid:105) − P(cid:104)
A (λ) = 1(cid:105) − P(cid:104)
B (λ) = 1(cid:105) − P(cid:104)
B (λ) = 1(cid:105) − P(cid:104)
(cid:16)P(cid:104)
B (λ) = 1(cid:105)(cid:17)
A (λ) = 1(cid:105)(cid:17)(cid:12)(cid:12)(cid:12)
B (λ) = 1(cid:105)(cid:12)(cid:12)(cid:12) +
(cid:12)(cid:12)(cid:12)P(cid:104)
A (λ) = 1(cid:105)(cid:12)(cid:12)(cid:12)
B (λ) = 1(cid:105)(cid:12)(cid:12)(cid:12) + 4q(λ) P(cid:104)
B (λ) = 1(cid:105)(cid:17)
B (λ) = 1(cid:105)(cid:12)(cid:12)(cid:12)
A (λ) = 1(cid:105)(cid:12)(cid:12)(cid:12) is not negligible, then B breaks Expind, or C breaks
B (λ) = 1(cid:105) − P(cid:104)
B (λ) = 1(cid:105) − P(cid:104)
ExpNMC = 1(cid:105)
Expind,0
Exppriv,1
Expind,0
Exppriv,1
Expind,1
Exppriv,0
Exppriv,1
Expind,1
Expind,0
Expind,1
Expind,0
+
+
+
□
d
2
1
vote
c, Oi
(state′
1, pk). For each call to Op,c
(pk) first simulates AOreg, Ocorr
C.2.2 Civitas is private for Exppriv−careful.
Theorem C.2. Assuming no adversary wins Expind nor ExpNM with non-negligible probability, Civitas is private for Exppriv−careful.
Proof. Let A = A1, A2, A3, A4 be an adversary that wins Exppriv−careful. We consider an adversary B = B1, B2, B3 that plays Expind:
• BOreg, Ocorr
(pk), i.e. B registers and corrupts the same identities as A, while keeping lists U1, CU1 of
1
the identities it declares and corrupts by calling Oreg and Ocorr. A returns some state′
1. B1 then corrupts each user A1 has registered,
i.e., B1 calls Ocorr(id) for each id A1 has declared, and stores each id’s credential in a list CU2.
• BOi
2
Exppriv−careful. B2 will also use lists hL, H, and a list Lid for each id ∈ U1, all of them initially empty.
B2 first simulates AOp,c
vote(id, v0, v1), provided id ∈ U1\CU1, B checks whether id is already present
c(id, credid, v0, v1). B obtains a ballot b. B
in V0, V1. Provided it is not, B then retrieves id’s credential credid from CU2, and calls Oi
then appends (id, v0) to V0, (id, v1) to V1, b to hL, and b to Lid. Finally B returns b to A.
A2 eventually returns a board BB. We write BB\hL (resp. BB ∩ hL) the sublist of BB (in the same order) of ballots that do not occur
(resp. do occur) in hL.
d(BB\hL), and obtains a list L of pairs of credentials and votes. B2 then computes the list L′ of the first vote for each
accepts to
(state1, pk) maintains lists V0, V1, BB, initially empty, which will be used to simulate the lists with the same name in
credential in L. Note that, by construction, no ballot in BB\hL has been generated by a call to Oi
open all ballots in BB\hL.
• B2 then simulates AOhappyBB
(id), provided id ∈ U1\CU1, following the specification of the voter verification
for Civitas, B checks whether the first ballot b in Lid is in BB (note that by definition of the oracles, Lid actually only contains a single
element). If so, B appends id to H. In any case, B then resumes the execution of A3.
• B2 then computes ρ(V0), ρ(V1), and checks that they are equal, and that every id occurring in V0, V1 is also an element of H. If so, B2
computes r = ρ(V0) ∗ ρ(L′). Otherwise, B2 lets r = ⊥.
• B2 then calls A4 on r, and obtains a bit β′. B2 returns β′.
Note that the lists BB, V0, V1, H in B are equal to the lists of the same name in Exppriv−careful, β
. Then, by construction, A2 is always
accurately simulated by B2, i.e. it is called on the same inputs, and provided with the same oracles as what would happen in Exppriv, βA . Given
the specification of VerifVoter for Civitas, A3 is also accurately simulated by B2.
. For each call to OhappyBB
c, which means that Oi
• B2 calls Oi
A
3
d
We also construct an adversary C, who plays the game ExpNM.