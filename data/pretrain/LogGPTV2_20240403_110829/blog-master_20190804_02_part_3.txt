 17728 | customer1   | 2618115206 | c_id       | {1}     | SELECT c_discount, c_last, c_credit, w_t..    
 17728 | customer1   | 2965820579 | c_last     | {6}     | SELECT c_id FROM customer1 ....    
 17728 | customer1   | 3738483437 | c_id       | {1}     | UPDATE customer1 ....    
 17752 | orders2     | 2217779140 | o_id       | {1}     | SELECT o_c_id ....    
 17752 | orders2     | 2709941400 | o_id       | {1}     | UPDATE orders2 ....    
 17762 | new_orders2 | 3012757930 | no_o_id    | {1}     | DELETE FROM new_orders2 ....    
 17771 | order_line2 |  192474146 | ol_o_id    | {1}     | SELECT COUNT(DISTINCT (s_i_id)) ....    
 17771 | order_line2 |  313117619 | ol_o_id    | {1}     | UPDATE order_line2 ....    
 17771 | order_line2 | 2921207531 | ol_o_id    | {1}     | SELECT SUM(ol_amount) sm ....    
 17782 | stock2      |  192474146 | s_quantity | {3}     | SELECT COUNT(DISTINCT (s_i_id)) ....    
(18 rows)    
```    
An example query with predicates can be obtained using the function : ```pg_qualstats_example_query()``` provided by pg_qualstats.    
```    
percona=# select pg_qualstats_example_query(297872607);    
                          pg_qualstats_example_query                               
-------------------------------------------------------------------------------    
 UPDATE customer2                                                             +    
                         SET c_balance=-1576.000000, c_ytd_payment=1576.000000+    
                       WHERE c_w_id = 2                                       +    
                         AND c_d_id=9                                         +    
                         AND c_id=900    
(1 row)    
```    
Run EXPLAIN on the example query to store it in the table: public.idx_recommendations.    
Use hypopg to create a hypothetical index on the attributes mentioned as columns without an index on them.    
Run EXPLAIN on the query again and use ```hypopg_reset()``` to drop the hypothetical index created.     
When I have validated if any of the queries generated by ```sysbench-tpcc``` need some tuning using indexing, it was not a surprise that none of those need any further indexing. Hence, for the purpose of a demo, I have created a table and ran a few queries as following.    
```    
percona=# CREATE TABLE foo.bar (id int, dept int, id2 int, id3 int, id4 int, id5 int,id6 int,id7 int,details text, zipcode int);    
CREATE TABLE    
percona=# INSERT INTO foo.bar SELECT (random() * 1000000)::int, (random() * 1000000)::int, (random() * 1000000)::int,    
(random() * 1000000)::int,(random() * 1000000)::int,(random() * 1000000)::int,(random() * 1000000)::int,(random() * 1000000)::int,    
md5(g::text), floor(random()* (20000-9999 + 1) + 9999)     
FROM generate_series(1,1*1e6) g;    
INSERT 0 1000000    
percona=# CREATE INDEX idx_btree_bar ON foo.bar (id, dept, id2,id3,id4,id5,id6,zipcode);    
CREATE INDEX    
percona=# select * from foo.bar where id2 = 1 and id4 = 3;    
 id | dept | id2 | id3 | id4 | id5 | id6 | id7 | details | zipcode     
----+------+-----+-----+-----+-----+-----+-----+---------+---------    
(0 rows)    
percona=# select * from foo.bar where id3 = 3;    
   id   |  dept  |  id2   | id3 |  id4   | id5  |  id6   |  id7   |             details              | zipcode     
--------+--------+--------+-----+--------+------+--------+--------+----------------------------------+---------    
 876920 | 723557 | 670210 |   3 | 321924 | 9512 | 183549 | 756279 | 3e780bae1aacbebc10b1e06ca49d226e |   16364    
(1 row)    
```    
Now, let us check if we can find the indexes that could improve the SQL COST of execution in reality. As I have mentioned earlier, none of the queries run by ```sysbench-tpcc``` needed any further improvement through indexing, so we see the improvement only for the 2 select statements I ran above.    
```    
percona=# select find_usable_indexes();    
 find_usable_indexes     
---------------------    
(1 row)    
percona=# select queryid, current_plan->0->'Plan'->>'Total Cost' as "cost_without_index",     
hypo_plan->0->'Plan'->>'Total Cost' as "cost_with_index",     
round((((current_plan->0->'Plan'->>'Total Cost')::numeric-(hypo_plan->0->'Plan'->>'Total Cost')::numeric)*100/(current_plan->0->'Plan'->>'Total Cost')::numeric),2) as percent_improvd     
FROM idx_recommendations order by 4 desc;    
  queryid   | cost_without_index | cost_with_index | percent_improvd     
------------+--------------------+-----------------+-----------------    
  612880084 | 27346.00           | 8.07            |           99.97    
 1669974955 | 24846.00           | 12.08           |           99.95    
 1539164311 | 9.35               | 9.35            |            0.00    
 1976730265 | 15.37              | 15.37           |            0.00    
 2041891134 | 8.32               | 8.32            |            0.00    
 2750481779 | 8.31               | 8.31            |            0.00    
  850567043 | 8.32               | 8.32            |            0.00    
  946492786 | 8.32               | 8.32            |            0.00    
 2618115206 | 9.35               | 9.35            |            0.00    
  297872607 | 8.31               | 8.31            |            0.00    
 1170842645 | 8.31               | 8.31            |            0.00    
 1210386388 | 8.31               | 8.31            |            0.00    
 1101690903 | 39.52              | 39.52           |            0.00    
 4203200359 | 39.51              | 39.51           |            0.00    
  192474146 | 2289.00            | 2289.00         |            0.00    
  192474146 | 2289.00            | 2289.00         |            0.00    
 3738483437 | 8.31               | 8.31            |            0.00    
 1509701064 | 15.39              | 15.39           |            0.00    
(18 rows)    
percona=# select b.query, a.recmnded_index,round((((a.current_plan->0->'Plan'->>'Total Cost')::numeric-(hypo_plan->0->'Plan'->>'Total Cost')::numeric)*100/(a.current_plan->0->'Plan'->>'Total Cost')::numeric),2) as percent_improvd FROM idx_recommendations a JOIN pg_stat_statements b ON a.queryid = b.queryid WHERE round((((current_plan->0->'Plan'->>'Total Cost')::numeric-(hypo_plan->0->'Plan'->>'Total Cost')::numeric)*100/(current_plan->0->'Plan'->>'Total Cost')::numeric),2) > 0 order by 3 desc ;    
                       query                       |                 recmnded_index                 | percent_improvd     
---------------------------------------------------+------------------------------------------------+-----------------    
 select * from foo.bar where id2 = $1 and id4 = $2 | CREATE INDEX ON foo.bar USING btree (id2, id4) |           99.96    
 select * from foo.bar where id3 = $1              | CREATE INDEX ON foo.bar USING btree (id3)      |           99.93    
(2 rows)    
```    
As this function is storing the results into a table: ```public.idx_recommendations``` , we can query that and see the hypothetical index that has improved the total cost of that query.    
```    
percona=# select * from idx_recommendations WHERE queryid IN (612880084,1669974955);    
-[ RECORD 1 ]--+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------    
queryid        | 1669974955    
query          |     
current_plan   | [{"Plan": {"Alias": "bar", "Filter": "(id3 = 3)", "Node Type": "Seq Scan", "Plan Rows": 2, "Plan Width": 69, "Total Cost": 24846.00, "Startup Cost": 0.00, "Relation Name": "bar", "Parallel Aware": false}}]    
recmnded_index | CREATE INDEX ON foo.bar USING btree (id3)    
hypo_plan      | [{"Plan": {"Alias": "bar", "Node Type": "Index Scan", "Plan Rows": 2, "Index Cond": "(id3 = 3)", "Index Name": "btree_foo_bar_id3", "Plan Width": 69, "Total Cost": 12.08, "Startup Cost": 0.05, "Relation Name": "bar", "Parallel Aware": false, "Scan Direction": "Forward"}}]    
-[ RECORD 2 ]--+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------    
queryid        | 612880084    
query          |     
current_plan   | [{"Plan": {"Alias": "bar", "Filter": "((id2 = 1) AND (id4 = 3))", "Node Type": "Seq Scan", "Plan Rows": 1, "Plan Width": 69, "Total Cost": 27346.00, "Startup Cost": 0.00, "Relation Name": "bar", "Parallel Aware": false}}]    
recmnded_index | CREATE INDEX ON foo.bar USING btree (id2, id4)    
hypo_plan      | [{"Plan": {"Alias": "bar", "Node Type": "Index Scan", "Plan Rows": 1, "Index Cond": "((id2 = 1) AND (id4 = 3))", "Index Name": "btree_foo_bar_id2_id4", "Plan Width": 69, "Total Cost": 8.07, "Startup Cost": 0.05, "Relation Name": "bar", "Parallel Aware": false, "Scan Direction": "Forward"}}]    
```    
### Conclusion    
With this experiment, we see that we can use hypopg and ```pg_qualstats```  to automate index recommendations. The automation logic is currently limited to B-Tree Indexes only. Though it has a very negligible impact on performance through some minimalistic resource consumption, it can be considered by developers while coding an application logic. Developers could easily enable sampling for each query and see what indexes can be used to improve which query, and then implement the changes in Production. The function logic I have created above is just an experiment in automatic index recommendations and you may re-use the same upon additional testing. Special thanks again to POWA Team who have contributed to the very useful extension ```pg_qualstats``` in PostgreSQL.     
## 参考    
[《PostgreSQL SQL自动优化案例 - 极简，自动推荐索引》](../201801/20180111_02.md)      
[《PostgreSQL 虚拟|虚假 索引(hypothetical index) - HypoPG》](../201710/20171030_03.md)      
[《powa4 PostreSQL Workload Analyzer - PostgreSQL监控工具、带WEB展示》](../201905/20190520_01.md)      
[《PostgreSQL 商用版本EPAS(阿里云ppas(Oracle 兼容版)) 索引推荐功能使用》](../201801/20180113_02.md)         
[《PostgreSQL index include - 类聚簇表与应用(append only, IoT时空轨迹, 离散多行扫描与返回)》](../201905/20190503_03.md)     
[《PostgreSQL 空间st_contains，st_within空间包含搜索优化 - 降IO和降CPU(bound box) (多边形GiST优化)》](../201710/20171004_01.md)      
[《HTAP数据库 PostgreSQL 场景与性能测试之 47 - (OLTP) 空间应用 - 高并发空间位置更新、多属性KNN搜索并测（含空间索引）末端配送、新零售类项目》](../201711/20171107_48.md)    
[《PostgreSQL Oracle 兼容性之 - performance insight - AWS performance insight 理念与实现解读 - 珍藏级》](../201901/20190125_02.md)     
https://www.percona.com/blog/2019/07/22/automatic-index-recommendations-in-postgresql-using-pg_qualstats-and-hypopg/    
#### [PostgreSQL 许愿链接](https://github.com/digoal/blog/issues/76 "269ac3d1c492e938c0191101c7238216")
您的愿望将传达给PG kernel hacker、数据库厂商等, 帮助提高数据库产品质量和功能, 说不定下一个PG版本就有您提出的功能点. 针对非常好的提议，奖励限量版PG文化衫、纪念品、贴纸、PG热门书籍等，奖品丰富，快来许愿。[开不开森](https://github.com/digoal/blog/issues/76 "269ac3d1c492e938c0191101c7238216").  
#### [9.9元购买3个月阿里云RDS PostgreSQL实例](https://www.aliyun.com/database/postgresqlactivity "57258f76c37864c6e6d23383d05714ea")
#### [PostgreSQL 解决方案集合](https://yq.aliyun.com/topic/118 "40cff096e9ed7122c512b35d8561d9c8")
#### [德哥 / digoal's github - 公益是一辈子的事.](https://github.com/digoal/blog/blob/master/README.md "22709685feb7cab07d30f30387f0a9ae")
![digoal's wechat](../pic/digoal_weixin.jpg "f7ad92eeba24523fd47a6e1a0e691b59")
#### [PolarDB 学习图谱: 训练营、培训认证、在线互动实验、解决方案、生态合作、写心得拿奖品](https://www.aliyun.com/database/openpolardb/activity "8642f60e04ed0c814bf9cb9677976bd4")
#### [购买PolarDB云服务折扣活动进行中, 55元起](https://www.aliyun.com/activity/new/polardb-yunparter?userCode=bsb3t4al "e0495c413bedacabb75ff1e880be465a")
#### [About 德哥](https://github.com/digoal/blog/blob/master/me/readme.md "a37735981e7704886ffd590565582dd0")