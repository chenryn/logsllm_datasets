83.7命令的执行
S3.7.1简单命令的扩展
执行简单命令时，shell会从左到右地进行下列扩展，赋值和重定向：
被分析器当作（在命令名称之前的）变量赋值和重定向的单词，将被保存下来以备后续处理。
②不是变量赋值和重定向的单词会被（参见53.5Shell扩展]，pI4）.如果扩展以后还有单词，则其中的第
一个会被当作命令的名称，剩余的当作该命令的参数。
③进行前面所说的重定向（参见53.6[重定向]，p21)。
每个变量赋值语句中“"后面的文本在赋给变量之前会进行大括号扩展、参数扩展、命令替换、算术扩
展和引用去除。
如果结果没有产生命令名称，则变量赋值会影响到当前的shell环境：否则，变量被加到命令的执行环境中，
而不会影响当前的shell环境。如果某个赋值语句试图给只读变量赋值，就会发生错误，命令就会退出并返
回一个非零的状态。
如果结果没有产生命令名称，也会进行重定向，但是不会影响到当前的shell环境。如果重定向发生错
误，命令就会退出并返回一个非零的状态。
如果扩展以后产生了命令名称，则按如前所说的步骤执行：否则，命令结束。如果某个扩展含有命令替
换，则命令的退出状态是替换中所执行的最后一个命令的退出状态。如果没有命令替换，则结束命令并返回
状态零。
S3.7.2命令的搜索和执行
命令拆分成单词以后，结果就得到一个简单命令及其可选的参数列表。这时，执行下面的操作，
如果命令名中不含斜杠，shell 试图找到它。如果有一个同名的 shell函数，则如3.3[Shell 函数]，p12
所说的执行该函数。
2如果这个名称不是函数，shell会在内部命令列表中搜索它。如果找到，则执行该内部命令。
③如果这个名称既不是函数名，也不是内部命令，并且不含有斜杠，Bash会授索SPATH中每个目录里
面同名的可执行文件。Bash使用一个散列表来保存可执行文件的绝对路径（参见4.1[波恩Shell的内
部命令hash]，p31)，以避免重复搜索SPATH路径。只有当命令不在散列表中时才去搜索SPATH中的
所有目录。如果搜索失败，shell就会去找一个叫command_not_foundhandle的shell函数定义。如
果这个函数存在，就调用这个函数，并把原来的命令及其参数当作参数传递给它：这个函数的就成为
shell的退出状态。如果这个函数也没有定义，shell会打印一条错误信息并返回状态127.
4如果搜索成功，或者命令名中含有一个或多个斜杠，shell就会在独立的执行环境中执行这个命令。参
数0设为指定的命令名，如果有剩余的参数，将传作为参数递给命令。
5如果因为文件格式和可执行文件不同导致执行失败，并且该文件不是一个目录名称，它就会被当成一
个shell脚本并按照3.8[Shell脚本]：p26中所说的方法执行。
如果命令不是异步执行的，shell会等待它的结束并收集其返回状态。
BASH中文文档
目录
p24
---
## Page 36
3.7命令的执行
第三章SHELL的基本功能
+ee ee e e e ee e e e ee ee e ee ee e ee ee e ee e e e ee ee e ee ee e ee e e e e e
S3.7.3命令执行的环境
Shell的执行环境包括下列内容：
Shell启动时，打开它所继承的文件：这些文件可以用内部命令exec来重定向
当前工作目录：它是由cd，pushd或popd设置的，或者shell启动时就继承的
创建文件所用的掩码：它是由umask设置，或者继承自shell的父进程
当前的陷阱，由trap设置
Shell参数：它是通过变量赋值或者get设置的，或者从shell的父进程环境中继承来的
Shell函数：它是在执行期间定义的，或者从shell的父进程环境中继承来的
启动时（默认的或通过命令行参数）或通过Bet打开的选项
用shopt（参见S4.3.2[内部命令shopt]，p45）打开的选项
用alias（参见§6.6[别名]，p62）定义的shell别名
各个进程号，包括后台作业（参见53.2.3命令队列]，p7），以及$S和$PPID的值
要执行一个不是内部命令或者shell函数的简单命令时，它会在包含下列内容的单独环境中执行。除非特别
说明，下面的值都从shell 中继承。
Shell打开的文件，包括命令重定向时所作的修改和增加
当前工作目录
创建文件所用的掩码
标志为可以导出的shell变量和函数，以及命令从环境（参见53.7.4[环境]，p25）中导入的变量。
Shell捕获的陷阱被重置为从shell父进程中继承来的值：shell忽略的陷阱也会被忽略
在这种单独的环境里启动的命令不会影响shell的执行环境。
命令替换，组合在括号中的命令，以及异步命令都在子shell环境中：子shell 复制了shell环境，不同
的是shell捕获的陷阱被重置为从shell父进程中继承来的值。属于管道中一部分的内部命令也在子shell环
境中执行。对子shell环境的改变不会影响到shell的执行环境。
用来执行命令替换的子shell会继承父shell的“=e"选项。如果不是在POSIX模式下，Bash会在这些
子shell中去掉“=e”选项。
如果启用了作业控制，并且命令后面有个"”，则命令的默认标准输入是空文件"/dev/nul1"：否则，
命令将会继承shell的重定向后的文件描述符，
$3.7.4环境
在一个程序启动时，它会得到一个字符串数组，这就叫做环境。这个数组有一列成对的名称和值，
即“名称=值”
Bash提供了几种操纵环境的方法。启动时，shell会检查自已的环境，每找到一个名称就创建一个变
量，并自动标志这个变量，使得它可以导入到子进程中。执行的命令都继承这个环境。export命令和
“declare-x”可以在环境中增加和删除变量或函数。在环境中，如果一个参数的值被修改，这个新的值取
代旧的值就会成为环境的一部分。执行的命令所继承的环境包括shell的初始环境，这些值可能在shell中
被修改了，其中不包括用unet或“export-n”删除了的，但包含export 和“declare=x”命令所增加
的部分。
简单变量或函数的环境都可以通过加上参数赋值的前缀来暂时修改（参展s5[Shell变量]，p48）。这些赋
值语句只影响该命令所能访间到的环境。
如果打开了“-k"选项（参见586[内部命令set]，p42），则所有赋值的变量都被加入到命令的环境中，而
不仅仅是命令名前面的那些变量。
当Bash启动外部命令时，$_就会被设置为这个命令的绝对路径，并传递到变量的环境中。
Geeeeee eee ee eee ee eeeeeeeeeeeeeeeeee ee e e e ee e e e ee ee@
p25
目录
BASH 中文文栏
---
## Page 37
第三章SHELL的基本功能
3.8 SHELL 脚本
+ee e ee ee e ee e e e e e ee e e e ee e ee ee e e e ee e e e ee e e e ee ee e ee e @
S3.7.5退出状态
命令执行以后，它的退出状态就是系统调用uaitpid或与其等价的函数所返回的值。返回状态总是介
于0和255之间，具体将在下面解释：125以上的值使用比较特殊。Shell的内部命令和复合命令的退出状
态也是位于这个范围。在某些情况下，shell将使用特殊的状态来表示具体的错误状态。
为了便于shell处理，对成功执行的命令，它的退出状态是零：而非零的退出状态表示失败了。使用这
种看起来不直观的方法是因为，这样就可以很好的区分成功和多种不同的失败状态。如果命令接收到一个值
为N的关键信号而退出，Bash就会把128+N作为它的退出状态。
如果命令没有找到，用来执行它的子进程就会返回状态127。如果命令跃然找到但却不是可执行的，就
返回状态126。
如果命令因为扩展或重定向时发生错误而失败，则它的返回状态比零大。
Bash的条件命令（参见53.2.4.2[条件结构]，p9）以及部分命令队列（参见≤3.2.3[命令队列]，p7）使用了
退出状态。
Bash的所有内部命令都会在成功时返回状态零，失败时返回非零，所以它们可以用于条件命令和命令
队列中。如果使用不正确，所有的内部命令都会返回状态2.
S3.7.6信号
如果Bash是交互运行的，并且没有任何陷阱，它就会忽略SIGTERM（所以“ki11o"不会杀死一个交互
式的shell），但会捕获并处理SIGINT（所以内部命令wait是可以中断的）。当Bash接收到SIGINT 时，会
退出任何正在进行的循环。在任何情况下，Bash都会忽略SIGQUIT。如果启用了作业控制（参见57[作业控
制]，p69)，Bash 会忽略 SIGTTIN、SIGTTOU、SIGTSTP.
Bash启动的非内部命令会使用shell从其父进程继承的信号处理程序。如果没有启用作业控制，异步执
行的命令除了有这些信号处理程序，还会忽略SIGINT和SIGQUIT。因为命令替换而运行的命令会忽略键盘
产生的作业控制信号SIGTTIN，SIGTTOU和SIGTSTP.
默认情况下，shell 接收到SIGHUP 后会退出。在退出之间，交互运行的 shell会向所有的作业，不管是
正在运行还是已经停止，重新发送SIGHUP。对已经停止的作业，shell还会发送SIGCONT以确保它能够接收
到SIGHUP。为了阻止shell向某个特定的作业发送SIGHUP信号，可以用内部命令diBown（参见57.2[作业
控制内部命令]，p70）将它从作业表中剩除，或者用disoun-h让它下接收SIGHUP.
如果使用ehopt（参见与87[内部命令shopt]，p46）打开了shell的huponexit选项，当一个交互运行的
登录shell退出时，会向所有的作业发送SIGHUP。
如果Bash在等待命令结束时接收到了一个信号，并且已经给这个信号设置了陷阱，则该陷阱直到命令
结束时才会执行。如果Bash通过内部命令uait在等待一个异步命令时接收到了一个信号，并且已经给这
个信号设置了陷阱，则内部命令wat在执行完该陷阱后将立即返回一个大于128的状态。
S3.8Shell脚本
Shell脚本是包含shell命令的文本文件。如果Bash启动时把这个文件用作为第一个不是选项的参数，
并且没有使用“=e”或“-a"选项（参见g6.1Bash的启动]，p55），Bash会从该文件中读取命令并执行，然后退
会继续搜索SPATH中的目录。
Bash运行shell脚本时，会把特殊参数0设为该脚本的名称，而不是shell的名称。如果还有其它参
数，就把其余的参数当作位置参数：如果没有其它参数，就不设置位置参数。
可以用chown命令打开shell脚本的执行位使得它成为可执行文件。如果Bash在$PATH中搜索命令时
找到了这个文件，就会产生一个子shell来执行它。换句话说，如果文件名是一个可执行的shell脚本，则
执行
文件名参数
就相当于执行
bash文件名参数
BASH中文文档
目录
p26
---
## Page 38
3.8 SHELL脚本
第三章SHELL的基本功能
这个子shell会重新初始化，效果就等同于启动了一个新的shell来执行该脚本：所不同的是，父进程存储
的各命令的路径（参见54.1[波恩Shell的内部命令hash]，pSI）将会在子进程中沿用。
大多数Unix版本在执行命令时都包含这样的机制：如果脚本的第一行由“#！"这两个字符开头，则这一
行其余的内容就指定该脚本的解释器。因此，可以指定Bash、awk、Perl、或者其它解释器，并在脚本的这
行后面用这些语言来写。
在脚本文件的第一行，解释器名称后面可以包含一个单一的选项，以作为该解释器的参数：后面是脚本
的名称，再后面是其余参数。在不能处理这些参数的操作系统里面，Bash会处理它们.注意，有些比较老
的Unix版本规定，解释器名称和其参数总长度不得超过32个字符。
Bash脚本的开头通常是#!/bin/bash（假定Bash 安装在"/bin”下面），因为这样能保证该脚本用Bash
来解释，即使它在其它shell下执行。
p27
目录
BASH中文文
---
## Page 39
第四章SHELL内部命令
第四章Shell内部命令
内部命令是由shell自身提供的。如果某个内部命令的名称是一个简单命令（参见s3.2.1[简单命令]
部程序实现的功能，内部命令是非常必要的。
本章简要介绍了Bash从波恩shell继承的内部命令，以及Bash扩展过的独特内部命令。还有几个内
部命令在其它章节中介绍：Bash对作业控制功能（参见多7.2[作业控制内部命令]，p70）提供的界面，目录
栈（参见56.8[目录栈]，p63），history命令（参见s9.2[Bash历史内部命令]，p90），以及可编程补全功能（参
见58.7[可编程补全的内部命令]，p87）.很多内部命令在POSIX或者Bash中都得到了扩展。
下面介绍的内部命令，除非特别说明，如果说它接受“-"开头的选项，则“-"就表示选项的结束。例如，
内部命令：、true、false和test不接受选项。
S4.1波恩Shell的内部命令
下面的内部命令是从波恩shell继承来的：它们是根据POSIX规范现实的。
■A.：(逗号)
：[参数]
除了扩展参数和执行重定向外不做任何操作。返回状态是零。
■B..（点号）
，文件名[参数]
在当前的shell环境中，从文件名中读取并执行命令。如果文件名不包括斜杠，则使用PATH变量去搜索文
件。如果Bash不是在POSIX模式下运行，则在$PATH中找不支后就会在当前目录中搜索。如果提供了参
数，它们就成为执行文件名时的位置参数：否则，位置参数不会被改变。返回状态是最后一个被执行命令的
退出状态：如果没有命令被执行，则返回零。如果文件名没有找到，或者不能读取，返回状态就是非零值。
该命令和eource是等价的。
C.break
break [m]
从for，uhile，until或Belect循环中退出。如果给定n，则退出外围的第n层循环。n必须大于或等于
1.返回状态是零，除非n不是大于或等于1.
BASH 中文文档
p28
---
## Page 40
4.1波恩SHELL的内部命令
第四章SHELL内部命令
D.cd
cd[-L|-P][目录]
把当前工作目录改为目录：如果目录没有指定，则使用shell变量SHOME的值。如果shell变量CDPATH存
在，则用它作为搜索路径。如果目录以斜杠开头就不再使用CDPATH。“=P"选项助记词：Pbysical，物理路径的意思
是不跟踪符号链接：而默认情况下，或使用了“-L”助记词：zyLini，符号链按会跟踪符号链接。如果目录是“-"，
就相当于$OLDPWD。如果使用CDPATH中一个非空的目录，或者“-”上第一个参数，并且改变目录成功，则
在标准输出中打印新的工作目录的绝对路径。如果改变目录成功，返回状态就是零：否则就是非零。
亲代码清单3：改进cd实现目录导航
1 #!/bin/bash
3#改进 Basb 中的cd命令。
4 #另请参见 dire，popd 和 pushd 命令。
5 #作者Jerry Fleming，2009年8月
7 cd()
8
[[ s(+[6=0]）（[-+]）.-=T$ ]]JT
10
then
CDR=$(expr $CDR ${BASH.REMATCH[1]}${BASH_REMATCH[2] :=1})
12
[[ sCDR-1t1]]&CDR=1
13
][{]]
14
I-S(($CDR-1))
15
builtin cd s{cDP[$I]}
[[$（▪[6-0]）[+][+]--T$]]x
17
then
CDR=${BASH_REMATCH[1] :=1}
19
[[$CDR-1t 1 ]]&CDR=1
{]d$[{[]#}$$]]
21
=$（（$CDR-1）)
22
builtin cd s{cDP[$I]}
23
elif [[ $1 = =i ]]
24
then
25
unset CDP
26
CDP [0] =$PWD