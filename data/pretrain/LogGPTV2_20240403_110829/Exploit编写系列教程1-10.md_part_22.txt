SOCKADDR_IN sin;
sin.sin_family = PF_INET;
sin.sin_port = htons(LocalPort);
sin.sin_addr.s_addr = INADDR_ANY;
//bind the socket
rVal = bind(serverSocket, (LPSOCKADDR)&sin, sizeof(sin));
if(rVal == SOCKET_ERROR)
{
sError("Failed bind()");
WSACleanup();
return SS_ERROR;
}
//get socket to listen
rVal = listen(serverSocket, 10);
if(rVal == SOCKET_ERROR)
{
sError("Failed listen()");
WSACleanup();
return SS_ERROR;
}
//wait for a client to connect
SOCKET clientSocket;
clientSocket = accept(serverSocket, NULL, NULL);
if(clientSocket == INVALID_SOCKET)
{
sError("Failed accept()");
WSACleanup();
return SS_ERROR;
}
int bytesRecv = SOCKET_ERROR;
while( bytesRecv == SOCKET_ERROR )
{
//receive the data that is being sent by the client max limit to 5000 bytes.
bytesRecv = recv( clientSocket, Message, 5000, 0 );
if ( bytesRecv == 0 || bytesRecv == WSAECONNRESET )
{
printf( "\nConnection Closed.\n");
break;
}
}
//Pass the data received to the function pr
pr(Message);
//close client socket
closesocket(clientSocket);
//close server socket
closesocket(serverSocket);
WSACleanup();
return SS_OK;
}
编辑漏洞程序的属性。
转到C / C + +代码生成，并设置“Buffer Security Check”为NO。
编译代码（调试模式）
在调试器中打开漏洞程序server.exe，并观察函数pr():
(8c0.9c8): Break instruction exception - code 80000003 (first chance)
eax=7ffde000 ebx=00000001 ecx=00000002 edx=00000003 esi=00000004 edi=00000005
eip=7c90120e esp=0039ffcc ebp=0039fff4 iopl=0 nv up ei pl zr na pe nc
cs=001b ss=0023 ds=0023 es=0023 fs=0038 gs=0000 efl=00000246
ntdll!DbgBreakPoint:
7c90120e cc int 3
0:001> uf pr
*** WARNING: Unable to verify checksum for C:\Documents and Settings\peter\My
Documents\Visual Studio 2008\Projects\vulnerable server\Debug\vulnerable server.exe
vulnerable_server!pr [c:\documents and settings\peter\my documents\visual studio
2008\projects\vulnerable server\vulnerable server\vulnerable server.cpp @ 17]:
17 00411430 55 push ebp
17 00411431 8bec mov ebp,esp
17 00411433 81ecbc020000 sub esp,2BCh
17 00411439 53 push ebx
17 0041143a 56 push esi
17 0041143b 57 push edi
17 0041143c 8dbd44fdffff lea edi,[ebp-2BCh]
17 00411442 b9af000000 mov ecx,0AFh
17 00411447 b8cccccccc mov eax,0CCCCCCCCh
17 0041144c f3ab rep stos dword ptr es:[edi]
18 0041144e a03c574100 mov al,byte ptr [vulnerable_server!`string' (0041573c)]
18 00411453 888508feffff mov byte ptr [ebp-1F8h],al
18 00411459 68f3010000 push 1F3h
18 0041145e 6a00 push 0
18 00411460 8d8509feffff lea eax,[ebp-1F7h]
18 00411466 50 push eax
18 00411467 e81bfcffff call vulnerable_server!ILT+130(_memset) (00411087)
18 0041146c 83c40c add esp,0Ch
19 0041146f 8b4508 mov eax,dword ptr [ebp+8]
19 00411472 50 push eax
19 00411473 8d8d08feffff lea ecx,[ebp-1F8h]
19 00411479 51 push ecx
19 0041147a e83ffcffff call vulnerable_server!ILT+185(_strcpy) (004110be)
19 0041147f 83c408 add esp,8
20 00411482 52 push edx
20 00411483 8bcd mov ecx,ebp
20 00411485 50 push eax
20 00411486 8d15a8144100 lea edx,[vulnerable_server!pr+0x78 (004114a8)]
20 0041148c e80ffcffff call vulnerable_server!ILT+155(_RTC_CheckStackVars
(004110a0)
20 00411491 58 pop eax
20 00411492 5a pop edx
20 00411493 5f pop edi
20 00411494 5e pop esi
20 00411495 5b pop ebx
20 00411496 81c4bc020000 add esp,2BCh
20 0041149c 3bec cmp ebp,esp
20 0041149e e8cffcffff call vulnerable_server!ILT+365(__RTC_CheckEsp) (00411172)
20 004114a3 8be5 mov esp,ebp
20 004114a5 5d pop ebp
20 004114a6 c3 ret
如你所见，这个函数的开头并没有关于cookie的任何东西。
现在打开/GS选项重新编译，并再次观察这个函数:
(738.828): Break instruction exception - code 80000003 (first chance)
eax=00251eb4 ebx=7ffdc000 ecx=00000002 edx=00000004 esi=00251f48 edi=00251eb4
eip=7c90120e esp=0012fb20 ebp=0012fc94 iopl=0 nv up ei pl nz na po nc
cs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000202
ntdll!DbgBreakPoint:
7c90120e cc int 3
0:000> uf pr
*** WARNING: Unable to verify checksum for vulnerable server.exe
vulnerable_server!pr [c:\documents and settings\peter\my documents\visual studio
2008\projects\vulnerable server\vulnerable server\vulnerable server.cpp @ 17]:
17 00411430 55 push ebp
17 00411431 8bec mov ebp,esp
17 00411433 81ecc0020000 sub esp,2C0h
17 00411439 53 push ebx
17 0041143a 56 push esi
17 0041143b 57 push edi
17 0041143c 8dbd40fdffff lea edi,[ebp-2C0h]
17 00411442 b9b0000000 mov ecx,0B0h
17 00411447 b8cccccccc mov eax,0CCCCCCCCh
17 0041144c f3ab rep stos dword ptr es:[edi]
17 0041144e a100704100 mov eax,dword ptr [vulnerable_server!__security_cookie
(00417000)]
17 00411453 33c5 xor eax,ebp
17 00411455 8945fc mov dword ptr [ebp-4],eax
18 00411458 a03c574100 mov al,byte ptr [vulnerable_server!`string' (0041573c)]
18 0041145d 888504feffff mov byte ptr [ebp-1FCh],al
18 00411463 68f3010000 push 1F3h
18 00411468 6a00 push 0
18 0041146a 8d8505feffff lea eax,[ebp-1FBh]
18 00411470 50 push eax
18 00411471 e811fcffff call vulnerable_server!ILT+130(_memset) (00411087)
18 00411476 83c40c add esp,0Ch
19 00411479 8b4508 mov eax,dword ptr [ebp+8]
19 0041147c 50 push eax
19 0041147d 8d8d04feffff lea ecx,[ebp-1FCh]
19 00411483 51 push ecx
19 00411484 e835fcffff call vulnerable_server!ILT+185(_strcpy) (004110be)
19 00411489 83c408 add esp,8
20 0041148c 52 push edx
20 0041148d 8bcd mov ecx,ebp
20 0041148f 50 push eax
20 00411490 8d15bc144100 lea edx,[vulnerable_server!pr+0x8c (004114bc)]
20 00411496 e805fcffff call vulnerable_server!ILT+155(_RTC_CheckStackVars
(004110a0)
20 0041149b 58 pop eax
20 0041149c 5a pop edx
20 0041149d 5f pop edi
20 0041149e 5e pop esi
20 0041149f 5b pop ebx
20 004114a0 8b4dfc mov ecx,dword ptr [ebp-4]
20 004114a3 33cd xor ecx,ebp
20 004114a5 e879fbffff call vulnerable_server!ILT+30(__security_check_cookie
(00411023)
20 004114aa 81c4c0020000 add esp,2C0h
20 004114b0 3bec cmp ebp,esp
20 004114b2 e8bbfcffff call vulnerable_server!ILT+365(__RTC_CheckEsp) (00411172)
20 004114b7 8be5 mov esp,ebp
20 004114b9 5d pop ebp
20 004114ba c3 ret
在这个函数的开头，做了下边这些操作：
- sub esp,2c0h : 预留704字节空间
- mov eax,dword ptr[vulnerable_server!__security_cookie (00417000)] :提取cookie副本
- xor eax,ebp : cookie和ebp进行异或。
-然后把cookie保存到堆栈中返回地址的下方。
-在函数的结尾，下边的指令被执行：
- mov ecx,dword ptr [ebp-4] : 获取cookie的副本。
- xor ecx,ebp : 再次执行异或操作
- call vulnerable_server!ITL+30(__security_check_cookie (00411023) : 跳入例程进行 cookie 验
证。
简而言之：在函数的开头一个安全的cookie被添加到堆栈中，当函数返回时会对这个cookie进行验证。
当你发送超过500字节的数据到200端口尝试溢出缓冲区的时候，这个应用程序挂掉了（在调试器中，程
序执行到一个断点 - 用VS2008 C++编译的程序在运行时未初始化变量默认都被置成0xcc）
(a38.444): Break instruction exception - code 80000003 (first chance)
eax=00000001 ebx=0041149b ecx=bb522d78 edx=0012cb9b esi=102ce7b0 edi=00000002
eip=7c90120e esp=0012cbbc ebp=0012da08 iopl=0 nv up ei pl nz na po nc
cs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000202
ntdll!DbgBreakPoint:
7c90120e cc int 3
0:000> d esp
0012cbbc 06 24 41 00 00 00 00 00-01 5c 41 00 2c da 12 00 .$A......\A.,...
0012cbcc 2c da 12 00 00 00 00 00-dc cb 12 00 b0 e7 2c 10 ,.............,.
0012cbdc 53 00 74 00 61 00 63 00-6b 00 20 00 61 00 72 00 S.t.a.c.k. .a.r.
0012cbec 6f 00 75 00 6e 00 64 00-20 00 74 00 68 00 65 00 o.u.n.d. .t.h.e.
0012cbfc 20 00 76 00 61 00 72 00-69 00 61 00 62 00 6c 00 .v.a.r.i.a.b.l.
0012cc0c 65 00 20 00 27 00 62 00-75 00 66 00 27 00 20 00 e. .'.b.u.f.'. .
0012cc1c 77 00 61 00 73 00 20 00-63 00 6f 00 72 00 72 00 w.a.s. .c.o.r.r.
0012cc2c 75 00 70 00 74 00 65 00-64 00 2e 00 00 00 00 00 u.p.t.e.d.......