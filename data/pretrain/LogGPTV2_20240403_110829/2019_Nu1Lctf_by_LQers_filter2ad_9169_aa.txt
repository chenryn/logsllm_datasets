# 2019 Nu1Lctf by LQers
##### 译文声明
本文是翻译文章
译文仅供参考，具体内容表达以及含义原文为准。
## 比赛地址
https://nu1lctf.com/login
## 比赛时间
2019/09/06 12:00 UTC-2019/09/08 12:00 UTC 48h
## 签到-Checkin
N1CTF{WelcometoN1CTF2019havefunwow}
## REVERSE
###  lost in the deep(part 1 )
golang逆向，而且是Windows下的，去了符号表，不过自己之前研究过这种东西，根据段信息能恢复基本所有符号表，使用ida的golangHelper插件即可。
恢复出来之后，除了常规的runtime函数，在main包中的函数如下：
  * main_init
  * mainmyserver
  * main_dec
  * main_check
  * main_client
  * mainrunserver
  * main_main
以及部分密码算法函数：
  * cryptorc4NewCipher
  * cryptorc4__ptrCipher_XORKeyStream
  * encodingbase64NewEncoding
  * encodingbase64__ptrEncoding_DecodeString
下面简要分析程序流程
  1. 分析程序流程，从main包中的mainmain开始，一开始会调用mainrunserver。在main函数最后，会调用mainclient。这里应该是创建了子线程，和父线程通信。
  2. 子线程进入mainrunserver函数中，在该函数中，调用net_ptrListenConfigListen，开始配置TCP通信。然后两次调用ioioutil_ReadFile函数，读取服务器上的flag1和flag2。最后向父进程发出信号，返回到父线程。
  3. 父线程运行在main_client中，设置通信地址是TCP:0.0.0.0:30754
  4. 之后如果我们向本地服务器进行了通信，runtime设置好了通信处理函数是mainmyserver。除了常规的操作以外，在04DA191处调用main_check，同时注意返回值有3个，分别是0、1和2。
  5. 进入maincheck函数，其中调用了maindec函数。
  6. 在maindec函数中，使用memcpy复制密钥，即”This is not the key”到地址，然后调用rc4函数进行1024轮加密操作。最后调用encodingbase64_ptrEncoding_DecodeString进行解密，所以我们的输入必须满足base64编码之后的结果，同时该table是rc4解出来的结果。
  7. 在本地服务器创建完成之后，我们可以向该地址进行通信，使用nc就行。
cat.exe test.txt | nc64.exe -v 127.0.0.1 30754
  8. 同时main_check的返回值，使用交叉引用可以看到5个地址，如下图所示。
Address Text | instruction | value  
---|---|---  
main_check+168 | mov [rsp+68h+ret] | 0  
maincheck:loc4D9CEE | mov [rsp+68h+ret] | 0  
maincheck:loc4D9D4E | mov [rsp+68h+ret] | 0  
maincheck:loc4D9D64 | mov [rsp+68h+ret] | 1  
maincheck:loc4D9D7A | mov [rsp+68h+ret] | 2  
  9. 也就是这部分才是核心操作，经过调试可以判断，当返回值是0时，失败，如果返回值是1，可以获取flag1，如果返回值是2，可以获取flag2。这部分的check逻辑从0x04D9C24正式开始。
**core check**
在maincheck里面，也就是0x4d9c24之后，大循环的次数是输入的长度，首先判断是否大于0x80，然后调用stringsIndexRune，这个函数是查表，注意输入参数，分别是查表长度100，和字符串，0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!
和一些可见标点符号。 然后在循环中，判断当前的index是否比前一个循环的index大，这就说明index是严格递增的。
同时判断每一轮的输入是否存在于该表中，说明输入都是可见字符，同时也需要结合前面的base64编码。下面给出前面这段的脚本，需要结合后文使用。
    import string
    import base64
    import struct
    import hashlib
    import binascii
    STANDARD_ALPHABET = '''ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='''
    CUSTOM_ALPHABET   = '''AiHheGuklOxE5wz+WS9JLZRY7FXnyV0jCQP/Kf3d4BqTr8MmUta6NbpIov2cDgs1='''
    ENCODE_TRANS = string.maketrans(STANDARD_ALPHABET, CUSTOM_ALPHABET)
    DECODE_TRANS = string.maketrans(CUSTOM_ALPHABET, STANDARD_ALPHABET)
    def encode(inputa):
        return base64.b64encode(inputa).translate(ENCODE_TRANS)
    def decode(inputa):
        return base64.b64decode(inputa.translate(DECODE_TRANS))
    table ='''30 31 32 33 34 35 36 37 38 39 \
    61 62 63 64 65 66 67 68 69 6A\
    6B 6C 6D 6E 6F 70 71 72 73 74\
    75 76 77 78 79 7A 41 42 43 44\
    45 46 47 48 49 4A 4B 4C 4D 4E\
    4F 50 51 52 53 54 55 56 57 58\
    59 5A 21 22 23 24 25 26 27 28\
    29 2A 2B 2C 2D 2E 2F 3A 3B 3C\
    3D 3E 3F 40 5B 5C 5D 5E 5F 60\
    7B 7C 7D 7E 20 09 0A 0D 0B 0C'''.replace(' ','').decode('hex')
    # index
    right_index = [0, 1, 3, 5, 10, 11, 16, 25, 26, 28, 31, 32, 35, 52, 56, 59, 76, 91, 97]
    plain = ''.join(map(lambda x: table[x], right_index))
    print encode(plain)
之后载入一张结构体数组，长度也是100，每一个index都是一个结构体，如下所示。
    struc_1         struc ; (sizeof=0x20, mappedto_55)
    00000000                                         ; XREF: main_check+90/o
    00000000                                         ; main_check+99/o ...
    00000000 rsi         dq ?
    00000008 rdi         dq ?
    00000010 flag        dq ?
    00000018 ptr        dq ?                    ; offset
    00000020 struc_1         ends
这个结构体有自身的地址，2个权重，1个标志位和1个指向其他结构体地址的指针。
这部分的内容就不详细讲了。大致的算法如下，主要是判断标志位是否是0，如果是0就停下寻找，如果是1就加入到一个大集合中，然后下次寻找下一个。同时累计2个权重的值。
    def f1(i,itum2,rsi1,rdi1):
        r8 = 0
        r9 = 0
        rcx = table[i]
        k = itum2[rcx][3]
        if itum2[k][2] != 0:
           r8 = itum2[rcx][0]
           r9 = itum2[rcx][1]
           rsi1 += r8
           rdi1 += r9
           itum2[rcx][2] = 1
        else:
           return False
        return (rsi1,rdi1)
所以main_check函数返回的值是取决于这两个累计和的。从004D9D2A开始判断，如果 rdi=560
满足flag1的条件。如果rdi=1050，满足flag2的条件，下面就开始写算法，寻找这个条件的值。
对于第一问的条件，其实有很多能满足，所以我们可以手工寻找的方式，很快就能找到。
    table = [6274272, 6276416, 6277344, 6274656, 6275584, 6276768, 6276256, 6275424, 6274784, 6277152, 6275008, 6275232, 6276576, 6275968, 6276608, 6275200, 6277120, 6276352, 6276192, 6277312, 6275456, 6274816, 6275744, 6275040, 6276448, 6276960, 6275360, 6275264, 6276032, 6274336, 6276832, 6274592, 6274912, 6277408, 6276320, 6274304, 6276480, 6276864, 6275488, 6274848, 6277216, 6275648, 6276000, 6276640, 6275072, 6275712, 6275680, 6276992, 6275296, 6276096, 6276160, 6274624, 6276896, 6276128, 6276800, 6274944, 6274432, 6276224, 6274368, 6276736, 6275520, 6275616, 6274880, 6277248, 6277184, 6276672, 6275776, 6276064, 6277024, 6275328, 6274688, 6277056, 6274976, 6275904, 6274560, 6274464, 6275104, 6274400, 6276384, 6276544, 6277280, 6275808, 6275392, 6276512, 6275552, 6277088, 6275936, 6277376, 6276704, 6274720, 6274496, 6275136, 6276928, 6275840, 6274752, 6274528, 6277440, 6275168, 6276288, 6275872]
    itum = {6275072: [84, 17, 0, 6275040], 6275328: [12, 7, 0, 6275296], 6277152: [43, 17, 0, 6274656], 6277408: [19, 29, 0, 6277120], 6275584: [2, 18, 0, 6274272], 6275840: [11, 135, 0, 6275808], 6274592: [71, 2, 0, 6277120], 6276096: [36, 11, 0, 6276032], 6274272: [82, 6, 1, 0], 6276352: [30, 34, 0, 6275424], 6274912: [49, 8, 0, 6277120], 6276608: [75, 50, 0, 6275584], 6276864: [65, 22, 0, 6276192], 6275136: [59, 15, 0, 6275104], 6274400: [84, 28, 0, 6274368], 6277120: [6, 2, 0, 6276768], 6275296: [74, 40, 0, 6275264], 6277376: [64, 24, 0, 6274560], 6275552: [99, 5, 0, 6274688], 6275808: [49, 37, 0, 6275776], 6274656: [15, 10, 0, 6274272], 6276064: [29, 22, 0, 6275712], 6276320: [15, 29, 0, 6277120], 6274496: [66, 25, 0, 6274464], 6276576: [47, 34, 0, 6274656], 6274752: [70, 33, 0, 6274720], 6276832: [98, 44, 0, 6275200], 6275200: [54, 41, 0, 6276768], 6275520: [40, 36, 0, 6275488], 6277088: [45, 44, 0, 6277056], 6277344: [53, 40, 0, 6274272], 6275776: [8, 43, 0, 6275072], 6274720: [86, 12, 0, 6274464], 6276032: [54, 8, 0, 6275232], 6276288: [398, 68, 0, 6275840], 6276928: [19, 42, 0, 6274400], 6276544: [99, 37, 0, 6275520], 6276800: [54, 28, 0, 6274912], 6275264: [82, 32, 0, 6275232], 6274848: [14, 27, 0, 6274816], 6277056: [9, 34, 0, 6276128], 6275232: [46, 8, 0, 6274656], 6277312: [79, 11, 0, 6275424], 6275488: [13, 20, 0, 6275456], 6275744: [25, 1, 0, 6274784], 6274784: [1, 36, 0, 6274656], 6276000: [71, 13, 0, 6275744], 6276256: [54, 22, 0, 6276416], 6276512: [93, 46, 0, 6275328], 6274688: [73, 41, 0, 6274624], 6276768: [51, 22, 0, 6276416], 6274304: [61, 50, 0, 6277120], 6274944: [59, 28, 0, 6274912], 6277024: [20, 21, 0, 6276992], 6277280: [97, 8, 0, 6277248], 6275456: [44, 23, 0, 6275424], 6275712: [26, 4, 0, 6275360], 6274336: [71, 48, 0, 6275232], 6275968: [99, 17, 0, 6275584], 6276224: [4, 26, 0, 6274304], 6276480: [100, 5, 0, 6276352], 6276736: [35, 3, 0, 6274304], 6275392: [22, 10, 0, 6275328], 6275040: [82, 48, 0, 6274784], 6276992: [19, 17, 0, 6275264], 6275168: [82, 1, 0, 6275136], 6277248: [85, 34, 0, 6277216], 6275424: [14, 16, 0, 6276416], 6275680: [11, 34, 0, 6275264], 6276960: [16, 3, 0, 6275008], 6275936: [86, 3, 0, 6275904], 6276192: [56, 33, 0, 6275424], 6274368: [16, 25, 0, 6274304], 6276448: [4, 2, 0, 6275008], 6274624: [45, 50, 0, 6274592], 6276704: [91, 11, 0, 6274464], 6274432: [99, 6, 0, 6274304], 6275904: [86, 39, 0, 6274944], 6277216: [72, 28, 0, 6274816], 6275648: [46, 45, 0, 6274816], 6274464: [24, 27, 0, 6274432], 6276160: [79, 32, 0, 6274592], 6276416: [46, 31, 0, 6274272], 6276672: [31, 43, 0, 6276640], 6275008: [86, 6, 0, 6274656], 6274976: [100, 36, 0, 6274944], 6275104: [19, 16, 0, 6274432], 6277184: [18, 4, 0, 6275648], 6275360: [92, 15, 0, 6275008], 6277440: [37, 14, 0, 6275136], 6275616: [35, 19, 0, 6275488], 6275872: [480, 55, 0, 6275840], 6274528: [58, 34, 0, 6274496], 6276128: [7, 17, 0, 6274912], 6276384: [10, 20, 0, 6274368], 6274880: [19, 13, 0, 6274848], 6274560: [24, 41, 0, 6274432], 6276640: [59, 39, 0, 6275744], 6274816: [26, 43, 0, 6274784], 6276896: [81, 21, 0, 6274912]}
    def f1(i,itum2,rsi1,rdi1):
        r8 = 0
        r9 = 0
        rcx = table[i]
        k = itum2[rcx][3]
        if itum2[k][2] != 0:
           r8 = itum2[rcx][0]
           r9 = itum2[rcx][1]
           rsi1 += r8
           rdi1 += r9
           itum2[rcx][2] = 1
        else:
           return False
        return (rsi1,rdi1)
    '''
    f1(1,itum)
    print 'rsi = %s'% rsi
    print 'rdi = %s'% rdi
    '''
    rsi = 82
    rdi = 6
    t = f1(1,itum,rsi,rdi)
    rsi = 128
    rdi = 37
    t = f1(2,itum,rsi,rdi)
    rsi = 181
    rdi = 77
    t = f1(3,itum,rsi,rdi)
    rsi = 196
    rdi = 87
    t = f1(4,itum,rsi,rdi)
    rsi = 198
    rdi = 105
    t = f1(5,itum,rsi,rdi)
    rsi = 249
    rdi = 127
    t = f1(6,itum,rsi,rdi)
    rsi = 303
    rdi = 149
    t = f1(7,itum,rsi,rdi)
    rsi = 317