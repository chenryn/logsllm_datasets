Es2
Es2
Es2
(cid:2)
(cid:2)
Es3
Es2
Es2
Es2
Es3
Es3
Es2
Es2
Es2
Es2
variables. The higher bits can be ﬁll up with 0 if they are not
useful in the ﬁnal symbolic values. Angr also solved the case
with one-level symbolic array, because it can model memory
with a map from indexes to expressions. This feature enables
it to store and load values based on the index. However, Angr
cannot handle more complex cases, such as two-level symbolic
array, and using symbolic jump address within arrays. This
implies that symbolic array still cannot be fully supported.
When Angr thinks a bomb can be triggered but generates
insufﬁcient symbolic values for triggering the bomb, we label
the result as P (partial success). This is because Angr adopts
system call simulation, and may simply think a system call
can return any value that satisﬁes a constraint, which is not
true actually. When there are unsupported system calls, it has
higher chances to incur errors. For example, Angr cannot
handle the fork case due to unsupported system calls when
dynamic libraries are loaded. There are similar issues when
unloading dynamic libraries into SimuVEX. In this mode,
Angr doesn’t need to explore the details of external functions
but may think any values can be returned by external functions.
Such an approach facilitates Angr to explore more paths, but
it also has drawbacks in generating wrong symbolic values. To
verify our idea, we design a negative bomb which is guarded
under a constant false predict using square operations (e.g.,
x2 == −1). Theoretically, the bomb should not be triggered;
however, Angr aggressively assigns return values to the pow
function, and thinks the bomb path can be triggered.
For Triton and BAP, they both employ no sophisticated
techniques to handle the proposed challenges and suffer many
failures related to Es2 and Es3. Besides, there are several
Es1, because the binaries contain instructions that cannot
be lifted. Speciﬁcally, Triton does not support the ﬂoating-
point instructions, such as cvtsi2sd and ucomisd. When
symbolic variables are propagated in such instructions, the
error occurs and propagates. As a result, the constraint models
may either contain no symbolic variables or have wrong
expressions.
For scalability challenges, no tool can solve any of the cases
correctly. Our expected result for scalability problem is E,
which means the concolic executor exits abnormally due to
resource constraint. However, only half of our results are E,
while the other half of them are Es#. This is because some
errors happen during symbolic reasoning.
Finally, even for the same case, the failures of different tools
may be incurred with different error types. For example, Angr
thinks the bomb path in the symbolic jump case is reachable
but calculates a wrong result. It is likely that the error is
incurred during data propagation. In comparison, BAP and
Triton even do not have mechanisms to handle such jump,
and the failure should be caused by a constraint extraction
issue.
D. Lessons Learnt
1) Limitations of Concolic Execution: Our experimental
result shows that even the state-of-the-art concolic execution
tools are far less than perfect. There are several non-trivial
accuracy challenges which cannot be easily addressed. As a
result, real-world concolic execution tools are not as reliable
as their theoretical models. Also, even small-size programs
187
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 10:00:37 UTC from IEEE Xplore.  Restrictions apply. 
may incur scalability issues. Understanding the limitations of
concolic execution tools and knowing the characteristics of the
target codes beforehand would be helpful for users to employ
the technique appropriately.
2) Application Issue: We use two major application sce-
narios to illustrate the impacts of the challenges. The ﬁrst
scenario is bug detection [1]. Bugs may happen at any
place in any control ﬂow. Thus achieving high control
ﬂow coverage is essential for detecting bugs. However, our
discussed challenges are prevalent in real-world programs [15],
and thus pose concolic execution fails in achieving an ideal
coverage. Integrating other testing approaches, such as random
testing or fuzz testing, are helpful for bug detection. Besides,
some concolic execution tools leverage simulation techniques
to improve the coverage, but such tools may incur many false
positives.
Another scenario is deobfuscation. Obfuscation generally
increases code complexity by introducing opaque predicates
(e.g., constant) and bogus codes, while deobfuscation removes
the obscurity and redundancy. Theoretically, concolic execu-
tion is effective for deobfuscating such programs via dead code
(i.e., bogus codes) elimination. However, when composing
opaque predicates leveraging the challenges we investigated
in this paper, it would incur troubles for deobfuscation.
VI. CONCLUSION
To summarize,
this paper serves as a ﬁrst attempt
to
investigate the challenges of concolic execution on small-size
binary programs. We have systematically proposed four types
of errors which may occur in different symbolic reasoning
stages, and seven challenges that can incur such errors in real-
world concolic execution tasks. We have also proposed two
challenges that may incur scalability issues when performing
concolic execution on small-size programs. To show that the
proposed challenges are non-trivial, we have conducted real-
world experiments, which includes a set of 22 binary programs
and three most popular concolic execution tools. To facilitate
further study in this area, we release our dataset as open
source. This paper would serve as an essential reference for
concolic execution researchers to improve the technique, and
for the users to properly use it.
ACKNOWLEDGMENTS
This work was supported by the Key Project of National
Natural Science Foundation of China (Project No. 61332010),
the National Basic Research Program of China (973 Project
No. 2014CB347701), and the Research Grants Council of the
Hong Kong Special Administrative Region, China (No. CUHK
14234416 of the General Research Fund). Yangfan Zhou is the
corresponding author.
REFERENCES
[1] T. Avgerinos, S. K. Cha, B. L. T. Hao, and D. Brumley, “Aeg:
Automatic exploit generation,” in Proc. of the 2011 ACM the Network
and Distributed System Security Symposium, 2011.
[2] S. K. Cha, T. Avgerinos, A. Rebert, and D. Brumley, “Unleashing
mayhem on binary code,” in Proc. of the 2012 IEEE Symposium on
Security and Privacy, 2012.
188
[3] J. Ming, D. Xu, L. Wang, and D. Wu, “Loop: Logic-oriented opaque
predicate detection in obfuscated binary code,” in Proc. of the 22nd
ACM SIGSAC Conference on Computer and Communications Security,
2015.
[4] B. Yadegari and S. Debray, “Symbolic execution of obfuscated code,”
the 22nd ACM SIGSAC Conference on Computer and
in Proc. of
Communications Security, 2015.
[5] Y. Shoshitaishvili and et al., “Sok: (state of) the art of war: Offensive
techniques in binary analysis,” in Proc. of the IEEE Symposium on
Security and Privacy, 2016.
[6] F. Saudel and J. Salwan, “Triton: a dynamic symbolic execution
technologies de
framework,” in Symposium sur
linformation et des communications, SSTIC, France, Rennes, 2015.
la s´ecurit´e des
[7] “Crackme puzzles solved with Angr,” https://github.com/angr/angr-
doc/blob/master/docs/examples.md/.
[8] DAPRA,
“Cyber
Grand
Challenge,”
http://www.cybergrandchallenge.com/.
[9] L. Ciortea, C. Zamﬁr, S. Bucur, V. Chipounov, and G. Candea, “Cloud9:
a software testing service,” ACM SIGOPS Operating Systems Review,
vol. 43, no. 4, pp. 5–10, 2010.
[10] T. Xie, N. Tillmann, J. de Halleux, and W. Schulte, “Fitness-guided
path exploration in dynamic symbolic execution,” in Proc. of
the
39th IEEE/IFIP International Conference on Dependable Systems &
Networks, 2009.
[11] D. Brumley, I. Jager, T. Avgerinos, and E. J. Schwartz, “Bap: A binary
analysis platform,” in Proc. of the International Conference on Computer
Aided Veriﬁcation. Springer, 2011.
[12] C. Cadar, D. Dunbar, and D. R. Engler, “Klee: Unassisted and automatic
generation of high-coverage tests for complex systems programs,” in
Proc. of the 8th USENIX Symposium on Operating Systems Design and
Implementation, 2008.
[13] E. J. Schwartz, T. Avgerinos, and D. Brumley, “All you ever wanted to
know about dynamic taint analysis and forward symbolic execution (but
might have been afraid to ask),” in Proc. of the 2010 IEEE Symposium
on Security and Privacy, 2010.
[14] X. Qu and B. Robinson, “A case study of concolic testing tools and their
limitations,” in Proc. of the IEEE International Symposium on Empirical
Software Engineering and Measurement, 2011.
[15] L. Cseppento and Z. Micskei, “Evaluating symbolic execution-based test
tools,” in Proc. of the IEEE 8th International Conference on Software
Testing, Veriﬁcation and Validation, 2015.
[16] R. Kannavara, C. J. Havlicek, B. Chen, M. R. Tuttle, K. Cong,
S. Ray, and F. Xie, “Challenges and opportunities with concolic testing,”
in Aerospace and Electronics Conference (NAECON), 2015 National.
IEEE, 2015, pp. 374–378.
[17] C. A. R. Hoare, “An axiomatic basis for computer programming,”
Communications of the ACM, 1969.
[18] C.-K. Luk, R. Cohn, R. Muth, H. Patil, A. Klauser, G. Lowney,
S. Wallace, V. J. Reddi, and K. Hazelwood, “Pin: building customized
program analysis tools with dynamic instrumentation,” in ACM Sigplan
Notices, vol. 40, no. 6, 2005, pp. 190–200.
[19] F. Bellard, “Qemu, a fast and portable dynamic translator,” in Proc. of
the USENIX Annual Technical Conference, 2005.
[20] C. Barrett, A. Stump, and C. Tinelli, “The SMT-LIB Standard: Version
2.0,” in Proc. of the 8th International Workshop on Satisﬁability Modulo
Theories, 2010.
[21] N. Sorensson and N. Een, “Minisat v1.13-a sat solver with conﬂict-
clause minimization,” 2005.
[22] L. De Moura and N. Bjørner, “Z3: An efﬁcient smt solver,” in Proc.
the International Conference on Tools and Algorithms for the
of
Construction and Analysis of Systems. Springer, 2008.
[23] “PySymEmu,” https://github.com/feliam/pysymemu/.
[24] V. Ganesh and D. L. Dill, “A decision procedure for bit-vectors and
arrays,” in Proc. of the International Conference on Computer Aided
Veriﬁcation. Springer, 2007.
[25] N. Nethercote, “Dynamic binary analysis and instrumentation,” Ph.D.
dissertation, PhD thesis, University of Cambridge, 2004.
[26] K. Ma, K. Y. Phang, J. S. Foster, and M. Hicks, “Directed symbolic
execution,” in Proc. of the International Static Analysis Symposium.
Springer, 2011.
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 10:00:37 UTC from IEEE Xplore.  Restrictions apply.