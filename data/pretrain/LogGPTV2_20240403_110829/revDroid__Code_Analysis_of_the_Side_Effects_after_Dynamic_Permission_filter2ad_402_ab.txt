nation, point-to analysis, def/use chain analysis and data
ﬂow dominator analysis. FlowDroid is a context-sensitive,
ﬂow-sensitive, object sensitive and lifecycle-ware static anal-
ysis for Android applications based on Soot. Compared with
Soot, FlowDroid provides functionalities speciﬁc to Android
applications, including resource ﬁle parsing, UI mapping,
callback calculation and entry point generation based on
We deﬁne that a permission-relevant API call is not cor-
rectly handled if all methods in one of the call stacks of
the API call are not wrapped by an exception handler or
a proactive permission check block which calls permission
check methods such as checkPermission and checkUidPer-
mission. If the permission-relevant API call is not correctly
handled, we deﬁne this usage as a mis-usage of the API.
In the analysis framework, revDroid ﬁrstly leverages apk-
tool [6] to unpack the input APK ﬁle, and decode resource
ﬁles including the manifest ﬁle and the UI XML ﬁles, to
nearly original form [6]. After revDroid obtains the man-
ifest ﬁle, it calculates the set of API calls which the ap-
plication may invoke based on the permissions requested
by the application and the result of PScout [8] which is a
mapping between a permission and a set of API calls if the
749permission is required on execution of the API1. Note that
in Android 6.0, permissions which are classiﬁed as PROTEC-
TION_NORMAL, including widely used permissions such as the
INTERNET permission and the ACCCESS_NETWORK_STATE per-
mission will be automatically granted by system at install-
time and cannot be revoked by users. Thus, we will ignore
APIs which are only protected by permissions classiﬁed as
PROTECTION_NORMAL in Android 6.0.
Secondly, revDroid leverages FlowDroid to generate a dummy
main class and a dummy main method as the analysis entry
point. The dummy main class and dummy main method is
generated by combining the lifecycle methods of the applica-
tion component classes, such as the void onCreate(Bundle)
method of the android.app.Activity class. Moreover, the
callback methods for system-event, handling UI interaction
and others, including callback methods declared in the XML
resource ﬁles, such as the callback methods of the callback
classes and interfaces shown in Table 1, are also included in
the dummy main method by parsing the decoded resource
ﬁles [7].
Table 1: Examples of callback class or interface [7]
Class or Interface Name
android.bluetooth.BluetoothProfile$ServiceListener
android.content.DialogInterface$OnClickListener
android.database.sqlite.SQLiteTransactionListener
android.hardware.Camera$ShutterCallback
android.location.LocationListener
android.view.View$OnClickListener
android.widget.PopupMenu$OnMenuItemClickListener
Next, revDroid passes the generated dummy main class
and dummy main method to Soot. Soot generates the whole
call graph of the application, and starting from the dummy
main method, examines bodies of every reachable method,
looks for the method invocations which belong to the set
of API calls calculated in the ﬁrst step, and ﬁnally checks
whether these API calls are wrapped in an exception han-
dler which handles SecurityException or a proactive per-
mission check block which calls permission check methods
such as checkPermission and checkSelfPermission. If not,
revDroid searches their callers, recursively. In one iteration
of the recursive process, revDroid searches the caller of the
method which current invocation locates at, checks all the
invocations of the callee, and moves to next iteration by
treating every caller as callee if the invocation is not cor-
rectly handled. The search terminates when the analyzer
cannot ﬁnd any caller of the current callee or a method call
cycle is found.
3.1 Mis-usage Detection Algorithm
The mis-usage detection algorithm shown in Algorithm 1
checks whether the API call is a mis-usage. The algorithm
takes an API call as input, then leverages Soot to obtain all
call stacks of this API call. For every call stack we check
whether there exists an invocation in this call stack which
is wrapped by an exception handler, or dealt with proactive
permission check (described in detail in Section 3.2.2).
If
any one of the call stacks of the API call is neither wrapped
by an exception handler nor dealt with proactive permission
1PScout is a tool which extracts the permission speciﬁcation
from the Android operating system source code using static
analysis and generates a mapping [8]
check, the API call is judged as a mis-usage. Note that, if the
exception which is handled is a more general one than the
SecurityException, i.e., super classes of SecurityExcep-
tion, we also consider that the developer correctly handles
the invocation of the permission-relevant API.
Our algorithm checks all the reachable statements for the
API call recursively, so the complexity of the algorithm de-
pends on the number of statements and size of the call
stacks.
If there are N statements in the application and
the average size of the call stacks is M, the complexity of
the algorithm is O(N*M ).
Algorithm 1 Mis-usage Detection
Require: APICall : a permission-relevant API usage to be
checked
Ensure: checkResult
: whether the usage of APICall is correct
————————————————————–
1: checkResult ← true
2: for all callStack generate by Soot do
3:
4:
5:
checkTempResult ← false
for all statement ∈ callStack do
if statement is wrapped by exception handler or
dealt with proactive permission check then
checkTempResult = true
end if
end for
if checkTempResult == false then
checkResult = false
6:
7:
8:
9:
10:
11:
end if
12: end for
3.2 Technical Issues in the Framework
3.2.1 Recursion
revDroid checks whether the potential SecurityExcep-
tion is handled along a call stack in depth-ﬁrst order. To
prevent recursion from resulting in an inﬁnite loop, we keep
track of the history of invocations which have been checked
along a call stack. If the invocation which should be checked
next is already present in the history, we stop the check and
judge the root invocation of the call stack as a mis-usage.
3.2.2 Proactive Permission Checks
Many applications, especially third-party libraries, will
proactively check if the application is granted with the corre-
sponding permissions by calling methods such as checkPer-
mission, checkUidPermission and checkSelfPermission
before invoking APIs which require permissions. revDroid
takes this kind of handling into consideration by checking
whether the API call depends on the return value of the
permission check methods by leveraging the SimpleDomina-
torsFinder class of Soot which ﬁnds dominators of a given
ﬂow graph using the simple LT algorithm [15].
If that is
the case, revDroid will judge these API calls as correctly
handled.
3.2.3 Dead Code
Dead code is the code which exists in the application but
will never be executed. Not considering the eﬀect of the
dead code will lead to false positives, so revDroid leverages
750Soot to eliminate dead code ﬁrst and only analyzes methods
which are reachable [12].
4. EXPERIMENTS
4.1 Collections of Android Applications
The experiments are based on two datasets. The ﬁrst
dataset consists of 540 regular Android applications. We
denote this as regular applications. This dataset is obtained
by downloading the top 540 applications on the top free
chart of the US Google Play Store in late September 2015,
four months after Android 6.0 was released to developers
in May 28th, 2015 [24]. The second dataset consists of 200
malware samples from the M0Droid project by Damshenas
et al., which was last updated in December 2014 [18]. The
experiments are conducted on a virtual machine with 4-core
CPU and 12GB RAM running CentOS 6.5 and OpenJDK
7.
4.2 Results
We run revDroid with the two datasets mentioned in Sec-
tion 4.1 and obtain a preliminary report. For each appli-
cation, the preliminary report shows the permissions which
the application requests and potential SecurityExceptions
which the application handles and does not handle. Further,
we analyze the preliminary report and obtain more impor-
tant and interesting insights.
Table 2 lists the top 10 most used APIs in the two datasets.
We can see that the top 10 most used APIs in the two
datasets almost overlap, so applications’ usages of the ap-
plications in the two datasets are similar.
4.2.1 Results by Application
Figure 1 shows the overall distribution of regular applica-
tions’ handling of potential side eﬀects. Of the 540 applica-
tions in the regular application dataset, revDroid analyzes
420 applications successfully. Among them, 172 applications
do not call APIs which require permissions except permis-
sions classiﬁed as PROTECTION_NORMAL in Android 6.0. For
the rest 248 regular applications, 70% of them fail to han-
dle one or more cases where the exception is supposed to be
thrown. Only 30% of them handle all cases. This low rate
of correct exception handling indicates that application de-
velopers worrisomely fail to handle potential side eﬀects of
permission revocations. Figure 2 shows the distribution of
regular applications’ handling of potential side eﬀects cate-
gorized by the rate of handled potential side eﬀects. We can
see that 48% of applications handle less than 60% of their
potential side eﬀects.
By contrast, Figure 3 and Figure 4 show the overall dis-
tribution of malwares’ handling of potential side eﬀects. Of
the 200 applications in the malware dataset, revDroid an-
alyzes 155 malwares successfully. 23 malwares do not re-
quest permissions except permissions classiﬁed as PROTEC-
TION_NORMAL in Android 6.0. We can conclude from the
comparison between Figure 2 and Figure 4 that malwares
put more attention to the side eﬀects of permission revoca-
tion because 73% malwares handle all potential side eﬀects.
A possible reason for this diﬀerence between the results for
regular applications and malwares is that the developers of
malwares tend to take end users’ revocation of permissions
into consideration and handle potential side eﬀects of per-
mission revocation so that their malwares can survive on
more devices, including those which allow users to revoke
permissions, to keep the core malicious logic running. As we
discover in Section 4.2.6, when trying retrieving the unique
identiﬁer string of the device, some malwares will return
string “invalid” instead if the READ_PHONE_STATE permission
is revoked to prevent itself from crashing.
Figure 1: Distribution of regular applications’ handling of
potential side eﬀects. 70% of regular applications do not
handle all occurrences of potential side eﬀects, while only
30% of applications handle all.
Figure 2: Distribution of regular applications’ handling of
potential side eﬀects categorized by correct usage rate. 48%
of regular applications handle less than 60% of their poten-
tial side eﬀects.
4.2.2 Results by API
We group the results by the API calls which are invoked
by the applications. Figure 5 shows the overall distribution
of regular applications’ handling of potential side eﬀects by
API calls. 46% of API calls which require permissions are
not correctly handled by regular applications, while the rest
54% API calls are correctly handled. Table 3 lists the top 10
most mis-used APIs by regular application developers. We
can conclude from Table 3 that the API calls which require
the ACCESS_COARSE_LOCATION and ACCESS_FINE_LOCATION
permissions are widely used by application developers but
not handled well, which is also supported by the result shown
in Table 5.
Since Android 6.0 allows users to revoke permissions af-
ter installing applications, we wonder if removing permis-
sions will still crash applications. To answer this question,
we developed a test application that invokes APIs that re-
quest permissions including those listed in Table 3, without
Regular applications handling all potential side effects, 75(30%)Regular applications not handling all potential side effects, 173(70%)56352830247501020304050607080[0, 20%)[20%, 40%)[40%, 60%)[60%, 80%)[80%, 100%)100%Application CountCorrect Usage Rate751Table 2: Top 10 most used APIs of applications in the two datasets
Rank Regular Application
1
2
3
4
5
6
7
8
9
10
android.telephony.TelephonyManager:
java.lang.String getDeviceId()
android.location.LocationManager: an-
droid.location.Location getLastKnownLoca-
tion(java.lang.String)
android.location.LocationManager: boolean is-
ProviderEnabled(java.lang.String)
android.accounts.AccountManager: an-
droid.accounts.Account[] getAccountsBy-
Type(java.lang.String)
android.location.LocationManager: void request-
LocationUpdates(java.lang.String,long,float,
android.location.LocationListener)
android.location.LocationManager: an-
droid.location.LocationProvider get-
Provider(java.lang.String)
android.telephony.TelephonyManager: void lis-
ten(android.telephony.PhoneStateListener,int)
android.hardware.Camera: an-
droid.hardware.Camera open()
android.telephony.TelephonyManager:
java.lang.String getSubscriberId()
android.accounts.AccountManager:
java.lang.String getUser-
Data(android.accounts.Account,java.lang.String)
Malware
android.telephony.TelephonyManager:
java.lang.String getDeviceId()
android.location.LocationManager: an-
droid.location.Location getLastKnownLoca-
tion(java.lang.String)
android.location.LocationManager:
java.lang.String getBest-
Provider(android.location.Criteria,boolean)
android.telephony.TelephonyManager:
java.lang.String getLine1Number()
android.location.LocationManager: void request-
LocationUpdates(java.lang.String,long,float,
android.location.LocationListener)
android.accounts.AccountManager: an-
droid.accounts.Account[] getAccounts()
android.telephony.SmsManager: void send-
TextMessage(java.lang.String,java.lang.String,
java.lang.String, android.app.PendingIntent,
android.app.PendingIntent)
android.telephony.TelephonyManager:
java.lang.String getSubscriberId()
android.location.LocationManager: boolean is-
ProviderEnabled(java.lang.String)
android.location.LocationManager: void request-
LocationUpdates(java.lang.String,long,float, an-
droid.location.LocationListener,android.os.Looper)
Table 3: Top 10 most mis-used APIs of regular applications
Permission
ACCESS_COARSE_LOCATION
ACCESS_FINE_LOCATION
GET_ACCOUNTS
API
android.location.LocationManager: android.location.Location get-
LastKnownLocation (java.lang.String)
android.accounts.AccountManager: android.accounts.Account[]
getAccountsByType(java.lang.String)
android.telephony.TelephonyManager: java.lang.String getDevi-
ceId()
android.location.LocationManager: boolean isProviderEn-
abled(java.lang.String)
android.location.LocationManager: void requestLocationUp-
dates(java.lang.String,long,float,android.location.LocationListener)
android.telephony.TelephonyManager: void lis-
ten(android.telephony.PhoneStateListener,int)
android.location.LocationManager: android.location.LocationProvider
getProvider(java.lang.String)
android.accounts.AccountManager: java.lang.String getUser-
Data(android.accounts.Account,java.lang.String)
android.accounts.AccountManager: android.accounts.Account[]
getAccounts()
android.location.LocationManager: java.util.List get-
Providers(boolean)
READ_PHONE_STATE
ACCESS_COARSE_LOCATION
ACCESS_FINE_LOCATION
ACCESS_COARSE_LOCATION
ACCESS_FINE_LOCATION
ACCESS_COARSE_LOCATION