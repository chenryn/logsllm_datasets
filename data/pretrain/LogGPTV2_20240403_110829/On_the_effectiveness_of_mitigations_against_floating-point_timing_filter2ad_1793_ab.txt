### Multiplication Timing for Double Precision Floats on Intel i5-4460

| Dividend | 1e-320 | 6.59 | 6.57 | 6.55 | 6.55 | 6.51 | 6.55 | 6.58 | 6.59 | 6.59 | 6.56 | 6.59 | 6.55 | 6.57 | 6.57 | 6.57 | 6.53 | 6.57 | 130.90 | 6.59 | 6.55 | 6.56 | 6.56 | 6.56 | 6.55 | 6.56 | 6.60 | 130.92 | 6.58 | 6.57 | 6.58 | 6.58 | 6.59 | 6.57 | 6.54 | 6.56 | 130.94 |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 0.0 | 257 | 1e-320 | 6.59 | 6.57 | 6.55 | 6.55 | 6.51 | 6.55 | 6.58 | 6.59 | 6.59 | 6.56 | 6.59 | 6.55 | 6.57 | 6.57 | 6.57 | 6.53 | 6.57 | 130.90 | 6.59 | 6.55 | 6.56 | 6.56 | 6.56 | 6.55 | 6.56 | 6.60 | 130.92 | 6.58 | 6.57 | 6.58 | 6.58 | 6.59 | 6.57 | 6.54 | 6.56 | 130.94 |
| 1.0 | 6.58 | 6.55 | 6.58 | 6.57 | 6.59 | 6.58 | 6.57 | 6.59 | 6.58 | 6.59 | 6.56 | 6.59 | 6.55 | 6.57 | 6.57 | 6.57 | 6.53 | 6.57 | 130.90 | 6.59 | 6.55 | 6.56 | 6.56 | 6.56 | 6.55 | 6.56 | 6.60 | 130.92 | 6.58 | 6.57 | 6.58 | 6.58 | 6.59 | 6.57 | 6.54 | 6.56 | 130.94 |
| 1e10 | 6.58 | 6.55 | 6.58 | 6.57 | 6.59 | 6.58 | 6.57 | 6.59 | 6.58 | 6.59 | 6.56 | 6.59 | 6.55 | 6.57 | 6.57 | 6.57 | 6.53 | 6.57 | 130.90 | 6.59 | 6.55 | 6.56 | 6.56 | 6.56 | 6.55 | 6.56 | 6.60 | 130.92 | 6.58 | 6.57 | 6.58 | 6.58 | 6.59 | 6.57 | 6.54 | 6.56 | 130.94 |
| 1e+200 | 6.58 | 6.55 | 6.58 | 6.57 | 6.59 | 6.58 | 6.57 | 6.59 | 6.58 | 6.59 | 6.56 | 6.59 | 6.55 | 6.57 | 6.57 | 6.57 | 6.53 | 6.57 | 130.90 | 6.59 | 6.55 | 6.56 | 6.56 | 6.56 | 6.55 | 6.56 | 6.60 | 130.92 | 6.58 | 6.57 | 6.58 | 6.58 | 6.59 | 6.57 | 6.54 | 6.56 | 130.94 |
| 1e-300 | 6.58 | 6.55 | 6.58 | 6.57 | 6.59 | 6.58 | 6.57 | 6.59 | 6.58 | 6.59 | 6.56 | 6.59 | 6.55 | 6.57 | 6.57 | 6.57 | 6.53 | 6.57 | 130.90 | 6.59 | 6.55 | 6.56 | 6.56 | 6.56 | 6.55 | 6.56 | 6.60 | 130.92 | 6.58 | 6.57 | 6.58 | 6.58 | 6.59 | 6.57 | 6.54 | 6.56 | 130.94 |
| 1e-42 | 6.58 | 6.55 | 6.58 | 6.57 | 6.59 | 6.58 | 6.57 | 6.59 | 6.58 | 6.59 | 6.56 | 6.59 | 6.55 | 6.57 | 6.57 | 6.57 | 6.53 | 6.57 | 130.90 | 6.59 | 6.55 | 6.56 | 6.56 | 6.56 | 6.55 | 6.56 | 6.60 | 130.92 | 6.58 | 6.57 | 6.58 | 6.58 | 6.59 | 6.57 | 6.54 | 6.56 | 130.94 |
| 256 | 6.58 | 6.55 | 6.58 | 6.57 | 6.59 | 6.58 | 6.57 | 6.59 | 6.58 | 6.59 | 6.56 | 6.59 | 6.55 | 6.57 | 6.57 | 6.57 | 6.53 | 6.57 | 130.90 | 6.59 | 6.55 | 6.56 | 6.56 | 6.56 | 6.55 | 6.56 | 6.60 | 130.92 | 6.58 | 6.57 | 6.58 | 6.58 | 6.59 | 6.57 | 6.54 | 6.56 | 130.94 |
| 257 | 6.58 | 6.55 | 6.58 | 6.57 | 6.59 | 6.58 | 6.57 | 6.59 | 6.58 | 6.59 | 6.56 | 6.59 | 6.55 | 6.57 | 6.57 | 6.57 | 6.53 | 6.57 | 130.90 | 6.59 | 6.55 | 6.56 | 6.56 | 6.56 | 6.55 | 6.56 | 6.60 | 130.92 | 6.58 | 6.57 | 6.58 | 6.58 | 6.59 | 6.57 | 6.54 | 6.56 | 130.94 |
| 1e-320 | 6.58 | 6.55 | 6.58 | 6.57 | 6.59 | 6.58 | 6.57 | 6.59 | 6.58 | 6.59 | 6.56 | 6.59 | 6.55 | 6.57 | 6.57 | 6.57 | 6.53 | 6.57 | 130.90 | 6.59 | 6.55 | 6.56 | 6.56 | 6.56 | 6.55 | 6.56 | 6.60 | 130.92 | 6.58 | 6.57 | 6.58 | 6.58 | 6.59 | 6.57 | 6.54 | 6.56 | 130.94 |

**Figure 6: Multiplication timing for double precision floats on Intel i5-4460.**
- **Cells highlighted in blue** indicate computations that averaged 1 cycle higher than the mode across all computations for that operation.
- **Cells in orange** indicate the same for 1 cycle less than the mode.
- **Bold face** indicates a computation that had a standard deviation of > 1 cycle (none of the tests on the Intel i5-4460 had standard deviations above 1 cycle).
- All other crosstables in this paper follow this format unless otherwise noted.

### Methodology
We run each computation (operation and argument pair) in a tight loop for 40,000,000 iterations, take the total number of CPU cycles during the execution, remove loop overheads, and find the average cycles per computation. This process is repeated for each operation and argument pair and stored. Finally, we run the entire testing apparatus 10 times and store all the results. Thus, we execute each computation 400,000,000 times split into 10 distinct samples. This apparatus measures the steady-state execution time of each computation.

The entirety of our data across multiple generations of Intel and AMD CPUs, as well as tools and instructions for generating this data, are available at [https://csweb.ucsd.edu/~dkohlbre/floats](https://csweb.ucsd.edu/~dkohlbre/floats).

It is important to note that Andrysco et al. [2] focused on the performance difference between subnormal and normal operands, while we observe that there are additional classes of values worth examining. The specific differences on powers-of-two are more difficult to detect with a naive analysis as they cause a slight speedup when compared to the massive slowdown of subnormals.

### Fixed Point Defenses in Firefox
In version 28, Firefox switched to a new set of SVG filter implementations that caused the attack presented by Andrysco et al. [2] to stop functioning. Many of these implementations no longer used floating point math, instead using their own fixed point arithmetic.

As the `feConvolveMatrix` implementation now consists entirely of integer operations, we cannot use floating point timing side channels to exploit it. We instead examined a number of the other SVG filter implementations and found that several had not yet been ported to the new fixed point implementation, such as the lighting filters.

### Division Timing for Double Precision Floats on Intel i5-4460

| Dividend | 0.0 | 1.0 | 1e10 | 1e+200 | 1e-300 | 1e-42 | 256 | 257 | 1e-320 |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 0.0 | 6.56 | 6.58 | 6.58 | 6.60 | 6.59 | 6.60 | 6.57 | 6.55 | 6.56 |
| 1.0 | 6.59 | 6.58 | 6.55 | 6.56 | 6.58 | 6.57 | 6.53 | 6.55 | 6.58 |
| 1e10 | 150.73 | 6.58 | 12.19 | 12.25 | 12.25 | 175.22 | 12.23 | 12.24 | 12.24 |
| 1e+200 | 165.79 | 6.55 | 12.17 | 12.20 | 12.20 | 12.24 | 12.22 | 12.20 | 12.22 |
| 1e-300 | 6.59 | 12.22 | 12.23 | 12.22 | 12.17 | 12.21 | 12.20 | 12.24 | 165.78 |
| 1e-42 | 6.58 | 12.24 | 12.25 | 12.22 | 12.22 | 12.24 | 12.20 | 12.23 | 165.76 |
| 256 | 6.57 | 6.57 | 6.57 | 6.58 | 6.52 | 6.58 | 6.53 | 6.56 | 150.66 |
| 257 | 6.57 | 12.24 | 12.22 | 12.24 | 12.23 | 12.21 | 12.22 | 12.21 | 165.80 |
| 1e-320 | 6.59 | 165.76 | 165.81 | 165.79 | 165.83 | 165.79 | 165.79 | 165.80 | 165.78 |

**Figure 7: Division timing for double precision floats on Intel i5-4460.**

### IEEE-754 Special Value Encoding
- **Exponent**: All Zeros, Zero, Infinity, All Ones, Not-a-Number
- **Significand**: Zero, Non-zero

**Figure 8: IEEE-754 Special Value Encoding (Reproduced with permission from [2])**

### Observed Sources of Timing Differences
- **Single Precision**: Add/Sub, Mul, Div, Sqrt
- **Double Precision**: Add/Sub, Mul, Div, Sqrt
- **Default**: FTZ & DAZ -ffast-math
- **S**: Subnormals are slower
- **Z**: All zero exponent or significand values are faster
- **M**: Mixture of several effects

**Figure 9: Observed sources of timing differences under different settings on an Intel i5-4460.**
- **–**: No variation
- **S**: Subnormals are slower
- **Z**: All zero exponent or significand values are faster
- **M**: Mixture of several effects

### Fixed Point Implementation in Firefox
The fixed point implementation used in Firefox SVG filters is a simple 32-bit format with no Not-a-Number, Infinity, or other special case handling. Since they make use of the standard add/subtract/multiply operations for 32-bit integers, we know of no timing side channels based on operands for this implementation. Integer division is known to be timing variable based on the upper 32-bits of 64-bit operands, but none of the filters can generate intermediate values requiring the upper 32-bits. Thus, none of the filters we examined using fixed point had any instruction data timing based side channels. Handling the full range of floating point functionality in a fixed point and constant time way is expensive and complex, as seen in [2].

A side effect of a simple implementation is that it cannot handle more complex operations that could induce NaNs or infinities and must process them.

### Lighting Filter Attack
Our Firefox SVG timing attack makes use of the `feSpecularLighting` lighting model with an `fePointLight`. In this configuration, it is not ported to fixed point and performs a scaling operation over the input alpha channel. The `surfaceScale` property in `feSpecularLighting` controls this scaling operation and can be set to an arbitrary floating point value when creating the filter. With this tool, we perform the following attack similar to the one in section 2.2. We need only to modify step 4 as seen below to enable the use of the new lighting filter attack.

1. Steps 1-3 are the same as section 2.2.
2. Apply an `feColorMatrix` to the pixel multiplier that sets the alpha channel based entirely on the input color values. This sets the alpha channel to 1 for a black pixel input, and 0 for a white pixel input.
3. Apply the `feSpecularLighting` filter with a `fePointLight` as the timing vulnerable filter.
4. Steps 5 and 6 are the same as section 2.2.

In this case, we differentiate between n^2 multiplications of subnormal × 0 (black) vs subnormal × 1 (white), where n is the width/height of the copied pixel. Since our measurements show a difference of 7 cycles vs 130 cycles for each multiplication (see Figure 4), we can easily detect this difference once we scale n enough that the faster white pixel case takes longer than 16ms (circa n = 200) in our tests. We need to cross this 16ms threshold as frames take a minimum of 16ms to render (60fps) on our test systems.

In our tests on an Intel i5-4460 with Firefox 49+, we were able to consistently obtain > 99% accuracy (on black and white images) at an average of 17ms per pixel. This is approximately as fast as an attack using this method can operate, since Firefox animates at a capped 60fps on all our test systems.

We notified Mozilla of this attack, and they are working on a comprehensive solution. Firefox has patched the `surfaceScale`-based attack on the `feSpecularLighting` filter in Firefox 52 and assigned the attack CVE-2017-5407.

### Safari
At the time of writing this paper, Safari has not implemented any defensive mechanisms that hamper the SVG timing attack presented in [2]. Thus, with a rework of the attack framework, we are able to modify the attack presented in Andrysco et al. against the `feConvolveMatrix` filter for Firefox 25 to work against current Safari.

Webkit (Safari) uses its own SVG filter implementations not used in other browsers. None of the SVG filters had GPU support at the time of this paper, but some CSS transforms could be GPU accelerated.

The Webkit `feConvolveMatrix` filter is implemented in the obvious way; multiply each kernel-sized pixel region against the kernel element-by-element, sum, and divide the result by the divisor. We can therefore cause operations with 0×subnormal or normal×subnormal depending on the target pixel. Since as we have seen, these can be 21× faster than a subnormal times a normal, we can easily detect the difference between executing over a black pixel or a white pixel.

We have disclosed the attack to Apple, and discussed options for entirely disabling cross-origin SVG filtering. Apple is working to address the issue.

We have removed details on the needed technical modifications to the attack for Safari as a patch is not yet available for all users. A full description of the modifications required for the Safari variant will be released upon a patch being available.

### DAZ/FTZ FPU Flag Defenses in Chrome
Google Chrome implements CSS and SVG filter support through the Skia graphics library. As of July 2016, when executing Skia filters on the CPU, Chrome enables an FPU control flag-based countermeasure to timing attacks. Specifically, Chrome enables the Flush-to-Zero (FTZ) and Denormals-are-Zero (DAZ) flags.

These flags are two of the many FPU control flags that can be set. Flags determine options such as when to set a floating point exception, what rounding options to use, and how to handle subnormals. The FTZ flag indicates to the FPU that whenever it would produce a subnormal as the result of a calculation, it instead produces a zero. The DAZ flag indicates to the FPU that any subnormal operand should be treated as if it were zero in the computation. Generally, these flags are enabled together as a performance optimization to avoid any use or generation of subnormal values. However, these flags break strict IEEE-754 compatibility, and so some compilers do not enable them without specific optimization flags. In the case of Chrome, FTZ and DAZ are enabled and disabled manually in the Skia rendering path.

### Attacking Chrome
We present a cross-origin pixel stealing attack for Google Chrome using the `feConvolveMatrix` filter. As in our previous attacks, we observe the timing differences between white and black pixels rendered with a specific convolution matrix. This attack works without any changes on all major platforms for Chrome that support GPU acceleration. We have tested it on Windows 10 (Intel i7-6700k), Ubuntu Linux 16.10 (Intel i5-4460), OSX 10.11.6 (Intel i7-3667U Macbook Air), and a Chromebook Pixel LS ChromeOS 55.0.2883.105 (i7-5500U) on versions of Chrome from 54-56. The attack is very similar to the one detailed in section 2.2 and figure 3.

Unlike Firefox, we cannot trivially supply subnormal values like "1e-41", as the Skia SVG float parsing code treats them as 0s. The float parsing in Skia attempts to avoid introducing subnormal values by disallowing exponents ≤ −37. Thus, we use the value 0.0000001e−35 or simply the fully written out form, which is correctly parsed into a subnormal value. Since the FTZ and DAZ flags are set only on entering the Skia rendering code, the parsing is not subject to these flags, and we can always successfully generate subnormals at parse time.

The largest obstacle we bypass is the use of the FTZ and DAZ control flags. These flags reduce the precision and representable space of floats but prevent any performance impact caused by subnormals for these filters in our experiments. As shown in section 3, even with these flags enabled, the div and sqrt operations still have timing variation. Unfortunately, none of the current SVG filter implementations we examined have tight division loops, making it possible to exploit the timing differences.

### Conclusion
We have demonstrated various timing attacks on different web browsers and provided insights into the defenses and vulnerabilities. The detailed methodology and results provide a comprehensive understanding of the floating-point and fixed-point arithmetic timing side channels. Future work should focus on further hardening browser implementations and exploring new defense mechanisms.