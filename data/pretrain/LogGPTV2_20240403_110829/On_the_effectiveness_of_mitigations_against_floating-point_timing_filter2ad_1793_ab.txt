257
1e-320
6.59
6.57
6.55
6.55
6.51
6.55
6.58
6.59
6.59
6.56
6.59
6.55
6.57
6.57
6.57
6.53
6.57
130.90
6.59
6.55
6.56
6.56
6.56
6.55
6.56
6.60
130.92
6.58
6.57
6.58
6.58
6.59
6.57
6.54
6.56
130.94
Cycle count
6.58
6.57
6.56
6.59
6.57
6.55
6.56
6.58
6.59
6.57
6.56
6.56
6.53
6.57
6.58
6.56
6.56
6.58
6.58
6.56
6.56
6.55
6.55
6.58
6.58
6.57
130.95
6.59
6.56
6.57
6.58
6.58
6.58
6.57
6.59
130.91
6.57
130.89
130.95
130.92
6.54
6.55
130.94
130.90
6.56
Figure 6: Multiplication timing for double precision ﬂoats on Intel i5-4460
and operation as the computation. Cells highlighted in
blue indicate computations that averaged 1 cycle higher
than the mode across all computations for that operation.
Cells in orange indicate the same for 1 cycle less than
the mode. Bold face indicates a computation that had a
standard deviation of > 1 cycle (none of the tests on the
Intel i5-4460 had standard deviations above 1 cycle). All
other crosstables in this paper follow this format unless
otherwise noted.
We run each computation (operation and argument
pair) in a tight loop for 40,000,000 iterations, take the to-
tal number of CPU cycles during the execution, remove
loop overheads, and ﬁnd the average cycles per compu-
tation. This process is repeated for each operation and
argument pair and stored. Finally, we run the entire test-
ing apparatus 10 times and store all the results. Thus, we
execute each computation 400,000,000 times split into
10 distinct samples. This apparatus measures the steady-
state execution time of each computation.
The entirety of our data across multiple generations of
Intel and AMD CPUs, as well as tools and instructions
for generating this data, are available at https://cs
eweb.ucsd.edu/~dkohlbre/floats.
It is important to note that the Andrysco et al. [2] fo-
cused on the performance difference between subnormal
and normal operands, while we observe that there are ad-
ditional classes of values worth examining. The speciﬁc
differences on powers-of-two are more difﬁcult to detect
with a naive analysis as they cause a slight speedup when
compared to the massive slowdown of subnormals.
4 Fixed point defenses in Firefox
In version 28 Firefox switched to a new set of SVG ﬁl-
ter implementations that caused the attack presented by
Andrysco et al. [2] to stop functioning. Many of these
implementations no longer used ﬂoating point math, in-
stead using their own ﬁxed point arithmetic.
As the feConvolveMatrix implementation now
consists entirely of integer operations, we cannot use
ﬂoating point timing side channels to exploit it. We in-
stead examined a number of the other SVG ﬁlter imple-
mentations and found that several had not yet been ported
to the new ﬁxed point implementation, such as the light-
ing ﬁlters.
72    26th USENIX Security Symposium
USENIX Association
Dividend
0.0
1.0
1e10
1e+200
Divisor
1e-300
1e-42
256
257
1e-320
0.0
1.0
1e10
1e+200
1e-300
1e-42
256
257
1e-320
6.56
6.58
6.58
6.60
6.59
6.60
6.57
6.55
6.56
6.59
6.58
6.55
6.60
6.57
6.53
6.55
6.58
150.73
6.58
12.19
12.25
12.25
175.22
12.23
12.24
12.24
165.79
6.55
12.17
12.20
12.20
12.24
12.22
12.20
12.22
6.59
Cycle count
6.57
12.22
12.23
12.22
12.17
12.21
12.20
12.24
165.78
6.58
12.24
12.25
12.22
12.22
12.24
12.20
12.23
165.76
6.57
6.57
6.57
6.58
6.52
6.58
6.53
6.56
150.66
6.57
12.24
12.22
12.24
12.23
12.21
12.22
12.21
165.80
6.59
165.76
165.81
165.79
165.83
165.79
165.79
165.80
165.78
Figure 7: Division timing for double precision ﬂoats on Intel i5-4460
Exponent
Value
All Zeros
Zero
Inﬁnity
All Ones
Not-a-Number All Ones
Subnormal
All Zeros
Signiﬁcand
Zero
Zero
Non-zero
Non-zero
Figure 8:
duced with permission from [2])
IEEE-754 Special Value Encoding (Repro-
Operation
Single Precision
Add/Sub
Mul
Div
Sqrt
Double Precision
Add/Sub
Mul
Div
Sqrt
Default
FTZ & DAZ -ffast-math
–
S
S
M
–
S
M
M
–
–
–
Z
–
–
Z
Z
–
–
–
–
–
–
Z
Z
Figure 9: Observed sources of timing differences under
different settings on an Intel i5-4460. – : no variation, S
: Subnormals are slower, Z : all zero exponent or signiﬁ-
cand values are faster, M : mixture of several effects
4.1 Fixed point implementation
The ﬁxed point implementation used in Firefox SVG ﬁl-
ters is a simple 32-bit format with no Not-a-Number, In-
ﬁnity, or other special case handling. Since they make
use of the standard add/subtract/multiply operations for
32-bit integers, we know of no timing side channels
based on operands for this implementation. Integer di-
vision is known to be timing variable based on the up-
per 32-bits of 64-bit operands, but none of the ﬁlters
can generate intermediate values requiring the upper 32-
bits. Thus, none of the ﬁlters we examined using ﬁxed
point had any instruction data timing based side chan-
nels. Handling the full range of ﬂoating point function-
ality in a ﬁxed point and constant time way is expensive
and complex, as seen in [2].
A side effect of a simple implementation is that it can-
not handle more complex operations that could induce
NaNs or inﬁnities and must process them.
4.2 Lighting ﬁlter attack
Our Firefox SVG timing attack makes use of the
feSpecularLighting lighting model with an
fePointLight.
in this
conﬁguration is not ported to ﬁxed point,
and
performs a scaling operation over
the input al-
pha channel.
The surfaceScale property in
feSpecularLighting controls this scaling opera-
tion and can be set to an arbitrary ﬂoating point value
when creating the ﬁlter. With this tool, we perform the
following attack similar to the one in section 2.2. We
need only to modify step 4 as seen below to enable the
use of the new lighting ﬁlter attack.
This particular ﬁlter
1. Steps 1-3 are the same as section 2.2.
4.1. Apply an feColorMatrix to the pixel mul-
tiplier  that sets the alpha channel based en-
tirely on the input color values. This sets the alpha
channel to 1 for a black pixel input, and 0 for a white
pixel input.
variable
4.2. Apply
sub-
feSpecularLighting ﬁlter with a
normal
attached
fePointLight as the timing vulnerable ﬁl-
ter.
surfaceScale
timing
and
an
the
5. Steps 5 and 6 are the same as section 2.2.
USENIX Association
26th USENIX Security Symposium    73
In this case, we differentiate between n2 multiplica-
tions of subnormal × 0 (black) vs subnormal × 1 (white)
where n is the width/height of the copied pixel .
Since our measurements show a difference of 7 cycles vs
130 cycles for each multiplication (see Figure 4), we can
easily detect this difference once we scale n enough that
the faster white pixel case takes longer than 16ms (circa
n = 200) in our tests. We need to cross this 16ms thresh-
old as frames take a minimum of 16ms to render (60fps)
on our test systems.
In our tests on an Intel i5-4460 with Firefox 49+ we
were able to consistently obtain > 99% accuracy (on
black and white images) at an average of 17ms per pixel.
This is approximately as fast as an attack using this
method can operate, since Firefox animates at a capped
60fps on all our test systems.
We notiﬁed Mozilla of this attack and they are
working on a comprehensive solution.
Firefox has
patched the surfaceScale based attack on the
feSpecularLighting ﬁlter in Firefox 52 and as-
signed the attack CVE-2017-5407.
5 Safari
At the time of writing this paper, Safari has not im-
plemented any defensive mechanisms that hamper the
SVG timing attack presented in [2]. Thus, with a re-
work of the attack framework, we are able to mod-
ify the attack presented in Andrysco et al against the
feConvolveMatrix ﬁlter for Firefox 25 to work
against current Safari.
Webkit (Safari) uses its own SVG ﬁlter implementa-
tions not used in other browsers. None of the SVG ﬁlters
had GPU support at the time of this paper, but some CSS
transforms could be GPU accelerated.
The Webkit feConvolveMatrix ﬁlter
is im-
plemented in the obvious way; multiply each ker-
nel sized pixel region against the kernel element-by-
element, sum, and divide the result by the divisor. We
can therefore cause operations with 0×subnormal or
normal×subnormal depending on the target pixel. Since
as we have seen these can a 0×subnormal can be 21×
faster than a subnormal times a normal, we can easily de-
tect the difference between executing over a black pixel
or a white pixel.
We have disclosed the attack to Apple, and discussed
options for entirely disabling cross-origin SVG ﬁltering.
Apple is working to address the issue.
We have removed details on the needed technical mod-
iﬁcations to the attack for Safari as a patch is not yet
available for all users. A full description of the modiﬁca-
tions required for the Safari variant will be released upon
a patch being available.
6 DAZ/FTZ FPU ﬂag defenses in Chrome
Google Chrome implements CSS and SVG ﬁlter support
through the Skia 1 graphics library. As of July of 2016,
when executing Skia ﬁlters on the CPU, Chrome enables
an FPU control ﬂag based countermeasure to timing at-
tacks. Speciﬁcally, Chrome enables the Flush-to-Zero
(FTZ) and Denormals-are-Zero (DAZ) ﬂags.
These ﬂags are two of the many FPU control ﬂags that
can be set. Flags determine options such as when to set
a ﬂoating point exception, what rounding options to use,
and how to handle subnormals. The FTZ ﬂag indicates
to the FPU that whenever it would produce a subnormal
as the result of a calculation, it instead produces a zero.
The DAZ ﬂag indicates to the FPU that any subnormal
operand should be treated as if it were zero in the com-
putation. Generally these ﬂags are enabled together as a
performance optimization to avoid any use or generation
of subnormal values. However, these ﬂags break strict
IEEE-754 compatibility and so some compilers do not
enable them without speciﬁc optimization ﬂags. In the
case of Chrome, FTZ and DAZ are enabled and disabled
manually in the Skia rendering path.
6.1 Attacking Chrome
We present a cross-origin pixel stealing attack for Google
Chrome using the feConvolveMatrix ﬁlter. As in
our previous attacks, we observe the timing differences
between white and black pixels rendered with a spe-
ciﬁc convolution matrix. This attack works without any
changes on all major platforms for Chrome that support
GPU acceleration. We have tested it on Windows 10 (In-
tel i7-6700k), Ubuntu Linux 16.10 (Intel i5-4460), OSX
10.11.6 (Intel i7-3667U Macbook Air), and a Chrome-
book Pixel LS ChromeOS 55.0.2883.105 (i7-5500U) on
versions of Chrome from 54-56. The attack is very simi-
lar to the one detailed in section 2.2 and ﬁgure 3.
Unlike Firefox, we cannot trivially supply subnormal
value like “1e-41”, as the Skia SVG ﬂoat parsing code
treats them as 0s. The ﬂoat parsing in Skia attempts to
avoid introducing subnormal values by disallowing ex-
ponents ≤ −37. Thus we use the value 0.0000001e− 35
or simply the fully written out form, which is correctly
parsed into a subnormal value. Since the FTZ and DAZ
ﬂags are set only on entering the Skia rendering code, the
parsing is not subject to these ﬂags and we can always
successfully generate subnormals at parse time.
The largest obstacle we bypass is the use of the FTZ
and DAZ control ﬂags. These ﬂags reduce the precision
and representable space of ﬂoats, but prevent any perfor-
mance impact caused by subnormals for these ﬁlters in
our experiments. As shown in section 3 even with these
ﬂags enabled the div and sqrt operations still have
timing variation. Unfortunately none of the current SVG
ﬁlter implementations we examined have tight division
74    26th USENIX Security Symposium
USENIX Association
Figure 10: HTML and style design for the pixel multiplying structure used in our attacks on Safari and Chrome
Dividend
0.0
1.0
1e10
1e+200
Divisor
1e-300
1e-42
256
257
1e-320
0.0
1.0
1e10
1e+200
1e-300
1e-42
256
257
1e-320
6.58
6.55
6.58
6.57
6.59
6.58
6.57