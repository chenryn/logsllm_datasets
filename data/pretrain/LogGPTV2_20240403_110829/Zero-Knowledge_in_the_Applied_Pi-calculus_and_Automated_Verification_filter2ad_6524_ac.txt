process speciﬁcation is ﬁnite:
i,j((cid:11)M , (cid:12)N ) is equivalent to
i,j((cid:11)M , (cid:12)N , F {(cid:11)M /(cid:12)α}{(cid:12)N/(cid:12)β}). This can be captured us-
i,j((cid:12)x,(cid:12)y) = PZK
i,j((cid:12)x,(cid:12)y, F {(cid:12)x/(cid:12)α}{(cid:12)y/(cid:12)β})
FZK the function symbols PZK
ZK
F
F
F
F
For verifying a zero-knowledge proof, it thus sufﬁces to
F
i,j is true or
check whether the last argument of the PZK
not:
i,j ((cid:12)x,(cid:12)y, true)) = true
F
F
i,j(PZK
Ver
The rule for extracting the public component is deﬁned
in the expected manner. Extracting the formula from a
F
zero-knowledge proof PZK
quires an additional thought: for preserving the secrecy of
private components, the function Formula yields the for-
i,j ((cid:11)M , (cid:12)N, F {(cid:11)M /(cid:12)α}{(cid:12)N/(cid:12)β}) re-
mula F (without the substitution {(cid:11)M /(cid:12)α}{(cid:12)N/(cid:12)β}) in order
to prevent the adversary from deriving the formula instanti-
ated with private terms.
i,j ((cid:12)x,(cid:12)y, z)) = yp
i,j((cid:12)x,(cid:12)y, z)) = F
F
F
Publicp(PZK
Formula(PZK
p ∈ [1, j]
F
i,j and
F
i,j constructors corresponds to the (ﬁnite) number of for-
We obtain a ﬁnite set of rules since the number of ZK
Ver
F
mulas occurring in the process speciﬁcation. The PZK
i,j
functions are private; hence they cannot be used by the
207
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 03:09:38 UTC from IEEE Xplore.  Restrictions apply. 
Table 5 Finite equational theory for zero-knowledge with respect to an (F , h, l)-valid process.
ΣF ,h,l
FZK
= Σbase ∪
i,j, PZKF
i,j, VerF
i,j, FakeZKk, Publicp,
Formula, FakeCollect, FakePublic, FakeVer, αg, βp
| (i, j, F ) ∈ F, g ∈ [1, h], k ∈ [0, l], p ∈ [1, l]
⎧⎨
⎩ ZKF
⎫⎬
⎭
i,j of arity i + j + 1, ZKF
PZKF
Publicp, and Formula of arity 1, αg and βp of arity 0. PZKF
i,j is private.
i,j of arity i + j, FakeZKk of arity k + 2, FakeVer of arity 4, FakePublic and FakeCollect of arity 2, VerF
i,j,
EF ,h,l
FZK is the smallest equational theory satisfying the equations of Ebase and the following equations, for every (i, j, F ) ∈ F:
((cid:12)x,(cid:12)y)
(PZKF
i,j
ZKF
i,j
VerF
i,j
Publicp(PZKF
i,j
Formula(PZKF
i,j
((cid:12)x,(cid:12)y, true))
((cid:12)x,(cid:12)y, z))
((cid:12)x,(cid:12)y, z))
Publicp(FakeZKk(x,(cid:12)y, z)) = yp
Formula(FakeZKk(x,(cid:12)y, z)) = z
= PZKF
i,j
= true
= yp
= F
((cid:12)x,(cid:12)y, F {(cid:12)x/(cid:12)α}{(cid:12)y/(cid:12)β})
p ∈ [1, j]
p ∈ [1, k], k ∈ [0, l]
k ∈ [0, l]
i,j((cid:11)M , (cid:12)N , true),
regardless of the value of F {(cid:11)M /(cid:12)α}{(cid:12)N/(cid:12)β}. The possibility
adversary to derive terms of the form PZK
which would be successfully veriﬁed by trusted participants
F
to construct such terms would break the soundness property
of zero-knowledge proofs.
It now remains to encode the zero-knowledge proofs
generated by the environment. These proofs possibly con-
tain formulas or have arities different from the ones spec-
iﬁed in the process. We include in ΣF ,h,l
FZK a ﬁnite set of
symbols FakeZKk of arity k + 2, where k ∈ [0, l]. The
term FakeZKk(M, (cid:12)N , F ) never occurs in process speciﬁca-
role only in the proof of soundness, (cid:12)N denotes the ﬁrst k el-
tions and represents zero-knowledge statements forged by
the adversary; here M constitutes a distinguished term that
uniquely refers to the zero-knowledge proof and that plays a
ements of the public component, and F is the formula. The
equational rules for extracting the public components and
the formula from FakeZKk terms are speciﬁed as follows:
Publicp(FakeZKk(x,(cid:12)y, z)) = yk
Formula(FakeZKk(x,(cid:12)y, z)) = z
for any p ∈ [1, k] and k ∈ [0, l]. We additionally include
in ΣF ,h,l
FZK functions FakeCollect, FakePublic, and FakeVer.
These functions are only used in the proofs and do not occur
in any equations.
4.2 Compilation into Finite Form
We now deﬁne the static compilation of terms and pro-
cesses.
Deﬁnition 4 (Static Compilation) The (F , h, l)-static
compilation is the partial function σ : TΣZK
re-
cursively deﬁned as follows:
→ TΣF ,h,l
FZK
ZKi,j((cid:11)M , (cid:12)N , F )σ = ZKF
((cid:11)M σ, (cid:12)N σ)
Veri,j(F, M )σ
Publicp(M )σ
Formula(M )σ
f(M1, . . . , Mi)σ
xσ
nσ
∀(i, j, F ) ∈ F
∀(i, j, F ) ∈ F
∀p ∈ [1, l]
(M σ)
i,j
= VerF
i,j
= Publicp(M σ)
= Formula(M σ)
= f(M1σ, . . . , Miσ) ∀f ∈ Σbase
= x
= n
∀x
∀n
The (F , h, l)- static compilation constitutes a total func-
tion when restricted to (F , h, l)-valid terms. The ﬁrst equa-
tions deal with the compilation of zero-knowledge proofs
and operators acting on them. The static compilation acts
component-wise on the remaining terms and behaves as the
identity function on names and variables. The compilation
of a process P , written P σ, is deﬁned by the compilation of
the terms occurring therein.
The following theorem ﬁnally states that observational
equivalence is preserved under static compilation and hence
asserts the soundness of the encoding from the inﬁnite spec-
iﬁcation into the ﬁnite speciﬁcation. Due to space con-
straints, we refer the interested reader to the long version
[7] for the proof of this theorem.
Theorem 1 (Preservation of Observational Equivalence)
Let P and Q be (F , h, l)-valid processes and σ be
Qσ, then
the (F , h, l)-static compilation.
P ≈EZK
If P σ ≈
EF ,h,l
Q.
FZK
In the long version [7], we additionally prove that a compre-
hensive class of trace-based properties that includes secrecy
and authenticity carries over to the original process speciﬁ-
cations.
208
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 03:09:38 UTC from IEEE Xplore.  Restrictions apply. 
5 Case Study: Direct Anonymous Attestation
To exemplify the applicability of our theory to real-world
protocols, we analyze the security properties of the Direct
Anonymous Attestation (DAA) scheme [12]. DAA consti-
tutes a cryptographic protocol that enables the remote au-
thentication of a hardware module called the Trusted Plat-
form Module (TPM), while preserving the privacy of the
user owning the module. Such TPMs are now widely in-
cluded in end-user notebooks.
The goal of the DAA protocol is to enable the TPM to
sign arbitrary messages and to send them to an entity called
the veriﬁer in such a way that the veriﬁer will only learn that
a valid TPM signed that message, but without revealing the
TPM’s identity. The DAA protocol relies heavily on zero-
knowledge proofs to achieve anonymity.
The DAA protocol is composed of two subprotocols: the
join protocol and the DAA-sign protocol. The join protocol
allows a TPM to obtain a certiﬁcate from an entity called
the issuer. The protocol ensures that even the issuer cannot
link the TPM to its subsequently produced signatures. The
DAA-sign protocol enables a TPM to sign a message. This
signed message is then veriﬁed by the veriﬁer. The DAA
protocol includes also a rogue-tagging procedure preventing
corrupted TPMs from getting certiﬁcates and authenticating
messages. Due to space constraints, we omit the speciﬁca-
tion and the analysis of the rogue-tagging procedure. We
refer the interested reader to the long version [7].
Every TPM has a unique id as well as a key-pair called
endorsement key (EK). The issuer is assumed to know the
public component of each EK. We assume further a publicly
known string bsn I called the basename of the issuer, as well
as a publicly known unique string bsn V for each veriﬁer
V . Every TPM has a secret seed daaseed id that allows for
deriving secret values fcnt := h(daaseed id , cnt) where H
is some hash function. We will call fcnt the f-value for
counter cnt. Each such f-value represents a virtual identity
with respect to which the TPM can execute the join and the
DAA-sign protocol.
5.1 Join protocol
In the join protocol, the TPM can receive a certiﬁcate
for one of its f-values f from the issuer. Such a certiﬁ-
cate is basically just a signature on f of the TPM. However,
since we do not want the issuer to learn f , we have to use
blind signatures, i.e., the request from the TPM to the is-
suer contains bl(f, v), for some random v, instead of just
f . Furthermore, the TPM is required to also send the hash
value NI := exp(ζI , f ) along with its request where ζI is
a value derived from the issuer’s basename bsn I. This mes-
sage is used in the rogue-tagging procedure mentioned be-
fore. The function exp constitutes an exponentation in the
original speciﬁcation of DAA; we model it as a hash func-
tion with two arguments. Since we do not want the TPM
to use different f-values in the computation of NI and of
bl(f, v), we have to attach a ZK proof that the same f-value
has been used in both cases. After checking the proof, the
issuer signs the blinded f-value bl(f, v) and returns this sig-
nature x := blsign(bl(f, v), skI ). Then cert := unbl(x, v)
is a valid blind signature on f . This certiﬁcate cert will be
used for the DAA-sign protocol. Since we want to guaran-
tee that only valid TPMs can receive certiﬁcates, the TPM
authenticates all its communication by a challenge-response
nonce handshake: the issuer outputs a nonce encrypted by
the TPM’s public endorsement key, and the TPM proves its
identity by hashing the nonce together with the blinded f-
value bl(f, v). The join protocol has the following overall
shape:
TPM
Issuer
id , ZK(f,v;bl(f,v),NI ,ζI ;Fjoin)
encasym(nonce,pkid )
h(bl(f,v),nonce)
blsign(bl(f,v),skI )
:= (β1 = bl(α1, α2) ∧ β2 = exp(β3, α1))
with Fjoin
and with id being the id of the TPM.
In our calculus,
we can model the behavior of the TPM in the join protocol
as reported in Table 6. Here we use let x = M in P as
syntactic sugar for P {M/x}. The occurence of an event M
is modeled as c(cid:3)M (cid:4) where c is a distinguished channel used
only for events. Given the explanations above, most steps
in this process should be self-explanatory, however, a few
points merit further explanation: The secret seed daaseedid
is modelled by the private constructor seed taking as input
id. In the computation of ζI := h(pair(n1, bsnI )), n1 is a
free name. In the original DAA protocol [12], the integer
1 is used here. For communication with the issuer, we use
the channel pub. The public keys pkid and pk I are modeled
as pk(ek(id )) and pk(issuerK) where ek and issuerK are
private constructors. That is, by ek(id ) we model a secret
function mapping a TPM’s identity to the endorsement key
pair. We then use the operators sk and pk to access the secret
and the public key. The function issuerK is nullary since, for
the sake of simplicity, we model a single issuer. The private
channel och will later be modeled as a secret channel to pass
the received certiﬁcate to the DAA-sign process.
5.2 DAA-sign protocol
After successfully executing the join protocol, the TPM
has a valid certiﬁcate cert for its f-value f signed by the
issuer. Since we only want valid TPMs to be able to DAA-
sign a message m, the TPM will have to convince a veri-
ﬁer V that it possesses a valid certiﬁcate cert. Of course,
209
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 03:09:38 UTC from IEEE Xplore.  Restrictions apply. 
/
/
o
o
/
/
o
o
Table 6 TPM/Host and issuer in the join protocol
Table 7 TPM/Host and veriﬁer in the DAA-sign protocol
tpmjoin := let f = h(pair(seed(id ), cnt )) in
νv.
let U = bl(f, v) in
let ζI = h(pair(n1, bsn I )) in
let NI = exp(ζI , f ) in
let zkp = ZK(f, v; U, NI , ζI ; Fjoin) in
pub(cid:8)pair(id, zkp)(cid:9).
pub(encn).
let nonce = decsym(encn, sk(ek(id))) in
pub(cid:8)h((U, nonce))(cid:9)
pub(x).
let cert = unbl(x, v) in
if blindver(cert , f, pk(issuerK)) = true then
event JOINED(id, cnt , cert ).
och(cid:8)cert (cid:9)
issuer := ! pub(msg).
let id = ﬁrst(msg) in
let zkp = snd(msg) in
if Ver2,3(Fjoin; zkp) = true then
let U = Public1(zkp) in
νnonce.
pub(cid:8)encasym(nonce, pk(ek(id)))(cid:9).
pub(hashn).