**介绍：** ****
针对大整数的分解有很多种算法，性能上各有优异，有Fermat方法，Pollard
rho方法，试除法，以及椭圆曲线法，连分数法，二次筛选法，数域分析法等等。其中一些方法应用在RSA的攻击上也有奇效。
在p，q的取值差异过大，或者p，q的取值过于相近的时候，Format方法与Pollard rho方法都可以很快将n分解成功。
此类分解方法有一个开源项目yafu将其自动化实现了，不论n的大小，只要p和q存在相差过大或者过近时，都可以通过yafu很快地分解成功。
**识别：** ****
在直接分解n无望，不能利用公约数分解n之后，都应该使用yafu去试一下。
**例题：**
[https://www.jarvisoj.com](https://www.jarvisoj.com) (Medium RSA)
此题首先从pem中提取N和e，然后上yafu，直接分解成功。
**0x03 低加密指数攻击**
****
在RSA中e也称为加密指数。由于e是可以随意选取的，选取小一点的e可以缩短加密时间，但是选取不当的话，就会造成安全问题。
**e=3时的小明文攻击**
**介绍：**
当e=3时，如果明文过小，导致明文的三次方仍然小于n，那么通过直接对密文三次开方，即可得到明文。
即：
$ cequiv m^e$ $mod$ $n$
如果e=3，且$ m^e
**Coppersmith定理攻击**
Coppersmith定理指出在一个e阶的mod n多项式f(x)中，如果有一个根小于$ n^frac{1}{e} $，就可以运用一个O(log
n)的算法求出这些根。
这个定理可以应用于RSA算法。如果e = 3并且在明文当中只有三分之二的比特是已知的，这种算法可以求出明文中所有的比特。
并未找到真题。
**0x04 低解密指数攻击**
**介绍：**
与低加密指数相同，低解密指数可以加快解密的过程，但是者也带来了安全问题。Wiener表示如果满足：
$ d
这里注意一个细节问题，如果在运行脚本的时候报错，请在脚本前加上：
****
    import   sys
    sys.setrecursionlimit(10000000)
****
**0x05 共模攻击**
**介绍：**
如果在RSA的使用中使用了相同的模n对相同的明文m进行了加密，那么就可以在不分解n的情况下还原出明文m的值。
即：
$ c_1equiv m^{e_1}$ $mod$ $n$
$ c_2equiv m^{e_2}$ $mod$ $n$
此时不需要分解n，不需要求解私钥，如果两个加密指数互素，就可以通过共模攻击在两个密文和公钥被嗅探到的情况下还原出明文m的值。
过程如下，首先两个加密指数互质，则：
$ (e_1,e_2)=1 $
即存在$ s_2 $，$ s_2 $使得：
$ s_1e_1+s_2e_2=1 $
又因为：
$ c_1equiv m^{e_1}$ $mod$ $n$
$ c_2equiv m^{e_2}$ $mod$ $n$
通过代入化简可以得出：
$c_1^{s_1}c_2^{s_2}equiv m$ $mod$ $n$
明文解出。
**识别：**
非常简单，若干次加密，每次n都一样，明文根据题意也一样即可。
**例题：**
 (very hard RSA)
如果已知：n1，n2，c1，c2，e1，e2，并且其中n1=n2的话：
    s = egcd(e1, e2)
     s1 = s[1]
     s2 = s[2]
       print s
     n=n1
       if s1<0:
         s1 = - s1
         c1 = modinv(c1, n)
       elif s2<0:
         s2 = - s2
         c2 = modinv(c2, n)
     m=(pow(c1,s1,n)*pow(c2,s2,n)) % n
**0x06 总结 **
****
这里总结方法也不是全部的方法，但是希望能够对大家RSA方面解题过程中能提供一些帮助。这里推荐汪神的OJ系统，里面题目多多，关于RSA也有不少，可以在此练习：[https://www.jarvisoj.com](https://www.jarvisoj.com/)
顺便再打个广告，我们战队最近正在从战队角度编篡一本CTF方面相关的书籍，干货多多，敬请期待！
本文如有什么问题或建议，请联系我，一定虚心接受：[PI:EMAIL](mailto:PI:EMAIL)。