Starting the Avalanche: 
Application DoS In Microservice Architectures
Scott Behrens
Jeremy Heffner
Jeremy Heffner
● Senior Security Software 
Engineer
● Developing and securing 
things for 20+ years
Introductions
Scott Behrens
● Netflix senior application 
security engineer
● Breaking and building for 
8+ years
● Contributor to a variety 
of open source projects 
(github.com/sbehrens)
DoS focused on application 
layer logic
Photo of a battering ram by Flickr user Patrick Denker; License: https://creativecommons.org/licenses/by/2.0/
http://www.interestingfacts.org/fact/first-example-of-biological-warfare
How Novel is Application DoS?
https://www.akamai.com/us/en/multimedia/documents/state-of-the-internet/q1-2017-state-of-the-internet-security-report.pdf 
Microservice Primer: High Level View 
Architecture
Client Libraries and API Gateway
Circuit Breakers / Failover
Cache 
Microservice Primer: Architecture
Scale
Service independence
Fault isolation
Eliminates stack debt
Distributed system complexity
Deployment complexity
Cascading service failures if 
things aren’t set up right
GOOD
BAD
Simplified Microservice API Architecture 
INTERNET
ZUUL
PROXY
ZUUL 
PROXY
PROXIES
CORE API
WEBSITE 
Middle Tier Service
Middle Tier Service
Middle Tier Service
Middle Tier Service
Backend Tier Service
Backend Tier Service
Backend Tier Service
Backend Tier Service
Backend Tier Service
Backend Tier Service
Backend Tier Service
Backend Tier Service
EDGE
Middle
Backend
Microservice Primer: API Gateways and Client Libraries
Interface for middle tier 
services
Services provide client 
libraries to API Gateway
Diagrams provided by microservices.io
Microservice Primer: Circuit Breaker
Helps with handling service failures
How do you know what timeout to 
choose? 
How long should the breaker be triggered?
Diagrams provided by microservices.io
Microservice Primer: Cache
Speeds up response time
Reduces load on services 
fronted by cache
Reduces the number of servers 
needed to handle requests 
https://github.com/netflix/evcache 
Old school Application DoS
CPU
Mem
Cache
Disk
Network
New School Application DoS
CPU
Mem
Cache
Disk
Network
Queueing
Client Library Timeouts
Healthchecks
Connection Pool
Hardware Operations (HSMs)
New School Application DoS
CPU
Mem
Cache
Disk
Network
Queueing
Client Library Timeouts
Healthchecks
Connection Pool
Hardware Operations (HSMs)
Difference Between Old School and New School App DoS
Old School Application DoS
Often 1 to 1
New School Application DoS
Often 1 to Many
Simple Web Application Architecture
Old School Application DoS Attack
> perl create_many_profiles.pl
POST /create_profile HTTP/1.1
…
profile_name=$counter + “hacker”
300 requests per second
HTTP Timeouts
HTTP Timeouts
https://www.teachprivacy.com/the-funniest-hacker-stock-photos/
https://openclipart.org/image/2400px/svg_to_png/241842/sad_panda.png 
http://www.funnyordie.com/lists/f64f7beefd/brent-rambo-approves-of-these-gifs 
ZUUL
PROXY
ZUUL 
PROXY
PROXIES
CORE API
WEBSITE 
Middle Tier Service
Middle Tier Service
Middle Tier Service
Middle Tier Service
Backend Tier Service 
Backend Tier Service 
Backend Tier Service 
Backend Tier Service 
 Backend Tier Service 
 Backend Tier Service 
Backend Tier Service 
Backend Tier Service 
EDGE
Middle
Backend
New School Microservice API DoS 
> python grizzly.py
POST /recommendations HTTP/1.1
…
{“recommendations”: {“range”: 
[0,10000]}}
ZUUL
PROXY
ZUUL 
PROXY
PROXIES
CORE API
WEBSITE 
Middle Tier Service
Middle Tier Service
Middle Tier Service
Middle Tier Service
Backend Tier Service 
Backend Tier Service 
Backend Tier Service 
Backend Tier Service 
 Backend Tier Service 
 Backend Tier Service 
Backend Tier Service 
Backend Tier Service 
EDGE
Middle
Backend
New School Microservice API DoS 
> python grizzly.py
POST /recommendations HTTP/1.1
…
{“recommendations”: {“range”: 
[0,10000]}}
Fallback or
Site Error
Core API making many 
client requests
Middle tier services 
making many calls to 
backend services
Backend service 
queues filling up with 
expensive requests
Client Timeouts, circuit 
breakers triggered, 
fallback experience 
triggered
Workflow for Identifying Application DoS - Part 1
Identify the most latent service calls
Investigate if latent calls allow for manipulation
Tune payload to fly under WAF/Rate Limiting 
Test hypothesis
Scale your test using Cloudy Kraken (orchestrator) and Repulsive Grizzly (attack 
framework)
Workflow for Identifying Application DoS - Part 1
Identify the most latent service calls
Investigate if latent calls allow for manipulation
Tune payload to fly under WAF/Rate Limiting 
Test hypothesis
Scale your test using Cloudy Kraken (orchestrator) and Repulsive Grizzly (attack 
framework)
Identifying Latent Service Calls
Identifying Latent Service Calls
Microservice Application DoS: Attack Patterns
Range
Object Out per Object in
Request Size
All of the Above
Application DoS Technique: Range
Application DoS Technique: Object Out Per Object In
Application DoS Technique: Request Size
Application DoS Technique: All of the Above
 AWS Geographical Region
VPC => VLAN
ASG => Automatically starts identical nodes
AZ/Subnet => Localized nodes / Subnet
Launch Config => Initial configuration
Region
VPC
AZ/Subnet
AZ/Subnet
Auto-Scaling Group
Node
Node
Node
Node
Node
Node
Node
Node
Node
Node
Node
Node
Cloudy Kraken Deployment phase
VPC
Security Group
Auto Scaling Group
VPC
Security Group
Auto Scaling Group
Region A
Region B
Cloudy Kraken Workers
Each worker node is a single EC2 instance
Each worker runs many threads
EC2 gives you access to Enhanced Networking Driver
Minimal overhead with launch config and ASG
Cloudy Kraken Execution phase
On startup, each worker node runs a cloud-init script
Enables ssh access for monitoring and debugging
Downloads and runs main config script
Downloads ZIP file with attack script
Spins up attack worker
Waits for coordinated time to start
Cloudy Kraken Kill-Switch
Script to set the kill switch, and bring it all down
Cloudy Kraken Tear-Down
Terminates all the instances
Removes ASGs and Launch Configs
Removes VPC, Security group, and Instance Profiles
We scaled up, time to run the test!
Tested against prod
Multi-region and 
multi-agent
Conducted two 5 
minute attacks
Monitored for success
Results of Test
80% Error Rate
$1.71
5 minute outage for a single AWS region
So What Failed?
Expensive API calls could be invoked with non-member cookies
Expensive traffic resulted in many RPCs per request
WAF/Rate Limiter was unable to monitor middle tier RPCs
Missing fallback experience when cache missed
Demo
●
Test app 
●
Launching and scaling attack with Cloudy Kraken
Microservice 
Application DoS: 
Mitigations
Understand which 
microservices impact 
customer experience
Microservice 
Application DoS: 
Mitigations
Rate limiter (WAF) 
should monitor 
middle tier signals or 
cost of request*
Microservice 
Application DoS: 
Mitigations
Middle tier services 
should provide 
context on abnormal 
behavior
Microservice 
Application DoS: 
Mitigations
Rate limiter (WAF) 
should monitor 
volume of cache 
misses*
Microservice 
Application DoS: 
Mitigations
Prioritize 
authenticated traffic 
over unauthenticated
Microservice 
Application DoS: 
Mitigations
Configure reasonable 
client library timeouts
Microservice 
Application DoS: 
Mitigations
Trigger fallback 
experiences when 
cache or lookups fail
Thanks!
https://github.com/netflix-skunkworks/repulsive-grizzly
https://github.com/netflix-skunkworks/cloudy-kraken   
@helloarbit