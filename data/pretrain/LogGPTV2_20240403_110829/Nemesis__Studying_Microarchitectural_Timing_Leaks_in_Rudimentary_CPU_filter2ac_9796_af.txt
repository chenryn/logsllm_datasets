and 2 list the number of cycles for respectively single and double
operand instructions. Note that a number of MSP430 assembly op-
erations (including nop, incd, rla, ret, and tst) are emulated by
means of the listed machine instructions.
Table 1: MSP430 single operand instruction cycles.
No. of Cycles
PUSH CALL Example
Addressing RRA, RRC,
Mode
SWPB, SXT
1
Rn
3
@Rn
3
@Rn+
#N
–
4
x(Rn)
4
EDE
&EDE
4
3
4
5
4
5
5
5
4
4
5
5
5
5
5
SWPB R5
RRC @R9
SWPB @R10+
CALL #0F000H
CALL 2(R7)
PUSH EDE
SXT &EDE
Table 2: MSP430 double operand instruction cycles.
Addressing Mode No. of
Src
Rn
Dst
Rm
PC
x(Rm)
EDE
&EDE
Rm
PC
x(Rm)
EDE
&EDE
@Rn
#N
@Rn+ Rm
PC
x(Rm)
EDE
&EDE
Rm
PC
x(Rm)
EDE
&EDE
Rm
PC
x(Rm)
EDE
&EDE
Rm
PC
x(Rm)
EDE
&EDE
x(Rn)
EDE
&EDE Rm
PC
x(Rm)
EDE
&EDE
MOV R5,R8
BR R9
ADD R5,4(R6)
XOR R8,EDE
MOV R5,&EDE
AND @R4,R5
BR @R8
XOR @R5,8(R6)
MOV @R5,EDE
XOR @R5,&EDE
ADD @R5+,R6
BR @R9+
XOR @R5+,8(R6)
MOV @R9+,EDE
MOV @R9+,&EDE
Cycles Example
1
2
4
4
4
2
2
5
5
5
2
3
5
5
5
2
3
5
5
5
3
3
6
6
6
3
3
6
6
6
3
3
6
6
6
MOV #20, R9
BR #2AEH
MOV #0300H,0(SP)
ADD #33,EDE
ADD #33,&EDE
MOV 2(R5),R7
BR 2(R6)
ADD 2(R4),6(R9)
MOV 4(R7),EDE
MOV 2(R4),&EDE
AND EDE,R6
BR EDE,R6
MOV EDE,0(SP)
CMP EDE,EDE
MOV EDE,&EDE
MOV &EDE,R8
BR &EDE
MOV &EDE,0(SP)
MOV &EDE,EDE
MOV &EDE,&EDE
B SECURE KEYPAD IMPLEMENTATION
The enclaved keypad program below was derived from a recently
published open-source8 automotive Sancus application scenario [72],
which we had to minimally modify in order to run without function
callbacks in a stand-alone enclave.
The start-to-end timing of the poll_keypad function only re-
veals the number of times the if statement was executed, i.e., the
number of keys that were down (cf. return value). By carefully
interrupting the function each loop iteration, an untrusted ISR can
learn the value of the secret PIN code.
8 https://github.com/sancus-pma/vulcan/blob/master/demo/ecu-tcs/sm_tcs_kypd.c
i n i t
= 0 x0 ;
SM_DATA ( s e c u r e )
SM_DATA ( s e c u r e ) p i n _ i d x
= 0 x0 ;
SM_DATA ( s e c u r e ) k e y _ s t a t e = 0 x0 ;
SM_DATA ( s e c u r e ) p i n [ PIN_LEN ] ;
i n t
i n t
u i n t 1 6 _ t
c h a r
c o n s t c h a r SM_DATA ( s e c u r e ) keymap [ NB_KEYS ] =
{
' 1 ' ,
' 3 ' ,
' 4 ' ,
' 6 ' ,
' 7 ' ,
' 9 ' ,
' 0 ' ,
' E ' ,
' 2 ' ,
' A ' ,
' 5 ' ,
' B ' ,
' 8 ' ,
'C ' ,
' F ' ,
'D '
} ;
i n t SM_ENTRY ( s e c u r e ) p o l l _ k e y p a d ( v o i d )
{
i n t
i s _ p r e s s e d , was_pressed , mask = 0 x1 ;
/ ∗ S e c u r e l y
i f
( ! i n i t )
i n i t i a l i z e SM on f i r s t
c a l l .
∗ /
r e t u r n d o _ i n i t ( ) ;
∗ /
/ ∗ F e t c h key s t a t e
u i n t 1 6 _ t n e w _ k e y _ s t a t e = r e a d _ k e y _ s t a t e ( ) ;
from MMIO d r i v e r SM .
i n p r i v a t e PIN a r r a y .
( i n t key = 0 ; key < NB_KEYS ; key ++)
/ ∗ S t o r e down k e y s
f o r
{
∗ /
= ( n e w _ k e y _ s t a t e & mask ) ;
i s _ p r e s s e d
w a s _ p r e s s e d = ( k e y _ s t a t e & mask ) ;
i f
( i s _ p r e s s e d
INTERRUPT SHOULD ARRIVE HERE ∗ /
/ ∗
&& ! w a s _ p r e s s e d && ( p i n _ i d x < PIN_LEN ) )
{
p i n [ p i n _ i d x ++] = keymap [ key ] ;
. . OR HERE . When c o n f i g u r i n g t h e
t h e key c o m p a r i s o n i n t h e n e x t
t i m e r
l o o p
i n t o a c c o u n t
}
/ ∗
f o r
i t e r a t i o n ,
key p r e s s e s
t o d e t e c t key r e l e a s e s .
mask = mask << 1 ;
ISR s h o u l d t a k e
∗ /
from p r e v i o u s
r u n s
t o be a b l e
jz
call
mov
clr
mov
1: mov
cmp
jge
mov
and
tst
jz
mov
and
tst
jnz
mov .b
mov
inc
mov
mov .b
2: rla
incd
cmp
jnz
mov
mov
sub
jmp
3: call
4: pop
pop
pop
pop
ret
3f
# read_key_state
#1 , r12
r13
& key_state , r14
& pin_idx , r11
#4 , r11
2f
r12 , r10
r15 , r10
r10
2f
r14 , r10
r12 , r10
r10
2f
518( r13 ), r10
r11 , r9
r9
r9 , & pin_idx
r10 , 550( r11 )
r12
r13
#32 , r13
1b
r15 , & key_state
#4 , r15
& pin_idx , r15