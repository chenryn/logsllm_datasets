â€¢ Set G = âŸ¨ğºâŸ©
â€¢ Output pp := (G, ğº, ğ¹, ğ›¾, ğ›¾ğ‘, Ëœğ‘)
KeyGen(G, ğº, ğ¹, ğ›¾, ğ›¾ğ‘):
â€¢ Sample ğ‘˜ â† Z Ëœğ‘
â€¢ Compute ğ» = ğºğ‘˜
â€¢ Return ğ‘ğ‘˜ = ğ» and ğ‘ ğ‘˜ = ğ‘˜
Encrypt(ğ‘ğ‘˜, ğ‘š âˆˆ Zğ‘):
â€¢ Sample ğ‘Ÿ â† Z Ëœğ‘
â€¢ Compute ğ¶1 = ğºğ‘Ÿ and ğ¶2 = ğœ“ğ‘(ğ»ğ‘Ÿ) Â· ğ¹ğ‘š
â€¢ Return ğ¶ = (ğ¶1, ğ¶2)
Decrypt(ğ‘ ğ‘˜, (ğ¶1, ğ¶2)):
â€¢ Return SolveDL(ğ¶2 Â· ğœ“ğ‘(ğ¶ğ‘˜
1)âˆ’1)
Figure 5: Modified fast variant of CL
2 = (ğ‘ â˜…)ğ‘˜â€² Â· ğ¹ğ‘šğ‘ .
ğ‘ with ğ‘Ÿâ€² â† Z Ëœğ‘. The challenge ciphertext is made
1 = ğœ‘ğ‘(ğ‘ â˜…) and ğ¶â˜…
Hyb0: This is the original IND-CPA game.
Hyb1: The public key is computed as follows: first sample ğ‘˜â€² â† Z Ëœğ‘
and set ğ» = ğœ‘ğ‘(ğ›¾)ğ‘˜â€².
Hyb2: Let ğ‘ â˜… = ğ›¾ğ‘Ÿâ€²
up as follows: ğ¶â˜…
Hyb3: We change the definition of ğ‘ â˜…: ğ‘ â˜… = ğ›¾ğ‘Ÿâ€² with ğ‘Ÿâ€² â† Zğ‘ Ëœğ‘.
We now argue the indistinguishability of the hybrids.
Hyb0 â‰¡ Hyb1: In Hyb1, ğ» = ğœ‘ğ‘(ğ›¾)ğ‘˜â€²
= ğœ‘ğ‘(ğ›¾)ğ‘˜ğ‘ = ğºğ‘˜ for some
ğ‘˜ âˆˆ Zğ‘  since gcd(ğ‘ , ğ‘) = 1. Furthermore, ğ‘˜ and ğ‘˜â€² follow the same
distribution in Zğ‘ . Therefore, the public key has the right form.
Note that the simulator does not know the â€œcorrectâ€ secret key ğ‘˜.
Hyb1 â‰¡ Hyb2:
= ğœ‘ğ‘(ğ›¾)ğ‘ğ‘Ÿ = ğºğ‘Ÿ for a ğ‘Ÿ that
In Hyb2, ğ¶â˜…
satisfies ğ‘Ÿâ€² = ğ‘ğ‘Ÿ mod ğ‘ . Again, it exists since gcd(ğ‘, ğ‘ ) = 1. On the
other hand, ğ¶â˜…
ğ‘ ) = ğœ‘ğ‘(ğ›¾)ğ‘Ÿâ€²
Â· ğ¹ğ‘šğ‘ .
1 = ğœ‘ğ‘(ğ›¾ğ‘Ÿâ€²
2 = ğ›¾ğ‘Ÿâ€²ğ‘˜â€²
= ğ›¾ğ‘˜â€²ğ‘Ÿâ€²
But ğœ“ğ‘(ğ»ğ‘Ÿ) = ğœ“ğ‘(ğœ‘ğ‘(ğ›¾)ğ‘˜â€²)ğ‘Ÿ = ğœ“ğ‘(ğœ‘ğ‘(ğ›¾))ğ‘˜â€²ğ‘Ÿ .
Since ğœ“ğ‘(ğœ‘ğ‘(ğ‘)) = ğ‘ğ‘ for all ğ‘ âˆˆ ğ¶ğ‘™(Î”ğ¾), this is equal to ğ›¾ğ‘˜â€²ğ‘Ÿğ‘ =
ğ›¾ğ‘˜â€²ğ‘Ÿğ‘
. This means that ğ¶â˜… = (ğºğ‘Ÿ ,ğœ“ğ‘(ğ»ğ‘Ÿ) Â· ğ¹ğ‘šğ‘ is a genuine
ğ‘
ciphertext of ğ‘šğ‘ for the public key ğ».
Hyb2 â‰ˆğ‘ Hyb3: The indistinguishability follows from reduction
against the HSMğ¶ğ¿ assumption.
We now prove that ğ¶â˜… perfectly hides ğ‘ in Hyb3. From the challenge
1 = ğœ‘ğ‘(ğ›¾)ğ‘Ÿâ€² where ğ‘Ÿâ€² â† Zğ‘ Ëœğ‘. As ğœ‘ğ‘(ğ›¾) is of
ciphertext one gets ğ¶â˜…
ğ‘
ğ‘
order ğ‘ , from an information theoretical point of view, the only
information known from the adversary on ğ‘Ÿâ€² is modulo ğ‘ . But ğ‘Ÿâ€² is
closed to uniform modulo ğ‘ğ‘ , and gcd(ğ‘, ğ‘ ) = 1, so ğ‘Ÿâ€² modulo ğ‘ is
still uniformly distributed for the adversary.
Â·ğ¹ğ‘šğ‘+ğ‘Ÿâ€²ğ‘˜â€².
As ğ‘Ÿâ€²ğ‘˜â€² remains uniform modulo ğ‘ it acts as a one-time pad on ğ‘šğ‘
(note that ğ‘˜â€² â‰  0 with overwhelming probability) , which means
that the challenge ciphertext does not reveal any information on
ğ‘šğ‘.
2 = (ğ›¾ğ‘Ÿâ€²)ğ‘˜â€²Â·ğ¹ğ‘šğ‘ = (ğ›¾ğ‘Â·ğ¹)ğ‘Ÿâ€²ğ‘˜â€²Â·ğ¹ğ‘šğ‘ = ğ›¾ğ‘Ÿâ€²ğ‘˜â€²
Eventually, ğ¶â˜…
ğ‘
â–¡
D SECURITY ANALYSIS OF CCA TIMED
COMMITMENT
In this section we present the formal proof for the security of our
CCA Timed commitment construction Figure 3.
âŒŠlog Ëœğ‘âŒ‹ +1). Compute ğ‘Ÿ :=ğ›¼
Proof of Theorem 5.6. The proof for CCA security proceeds
by defining a series of hybrid distributions and then arguing about
the indistinguishability of the neighbouring experiments.
Hyb0: This is identical to the original CCA experiment, except that
we fix the bit ğ‘ = 0.
Hyb1: In this hybrid we compute the NIZK proof for the challenge
commitment using the simulator (Sim0, Sim1).
Hyb2: In this hybrid we compute, for all ğ‘– âˆˆ [ğ›¼] (where ğ›¼ :=
âŒŠlog Ëœğ‘âŒ‹ + 1), (ğ‘ğ‘–,0, ğ‘ğ‘–,1) and ( Ëœğ‘ğ‘–,0, Ëœğ‘ğ‘–,1) as encryptions of 0 in the chal-
lenge commitment. I.e., we fix ğ‘Ÿğ‘– = 0, regardless on the value of
ğ‘Ÿ.
Ëœğ‘˜ for some uniformly at
Hyb3: In this hybrid we sample Ëœğ¾ as a Ëœğº
random integer Ëœğ‘˜ from Z Ëœğ‘.
Hyb4: Here we change the way we simulate the oracle O. On input
a valid commitment ğ‘, instead of using Solve(ğ‘) to solve the puzzle,
use Ëœğ‘˜ to decrypt ( Ëœğ‘ğ‘–,0, Ëœğ‘ğ‘–,1) to obtain ğ‘Ÿğ‘–, for ğ‘– âˆˆ [ğ›¼] (where ğ›¼ :=
ğ‘–=1 2ğ‘– Â·ğ‘Ÿğ‘–. Now recover ğ‘š from (ğ‘1, ğ‘2)
by computing SolveDL(ğ‘2 Â· ğœ“ğ‘(ğ»ğ‘Ÿ)âˆ’1).
Hyb5: We switch ğ‘ in the challenge ciphertext from PGen(pp, ğ‘š0)
to PGen(pp, ğ‘š1).
Hyb6 . . . Hyb9: We revert the changes made in hybrids Hyb4 . . .
Hyb1.
Observe that Hyb9 is identical to the CCA experiment, except with
the bit ğ‘ fixed to ğ‘ = 1. To conclude the proof, we now argue on
the indistinguishability of the hybrid executions.
Hyb0 â‰ˆğ‘ Hyb1: This follows from the zero-knowledge property of
the NIZK proofs.
Hyb1 â‰ˆğ‘ Hyb2: The indistinguishability follows from a standard
hybrid argument (over each ğ‘– âˆˆ [2 Â· ğ›¼], where ğ›¼ := âŒŠlog Ëœğ‘âŒ‹ + 1)
and a reduction against the DDH assumption (cf. Theorem B.1
and Theorem B.2).
Hyb2 â‰¡ Hyb3: The two hybrids define two identical distributions,
so the change here is only syntactical.
Hyb3 â‰ˆğ‘ Hyb4: The only difference between the two hybrids is in
the simulation of the oracle O, therefore the two hybrids differ
only in the case that the output of O differs on some input query
of the adversary. Observe that this can happen only if the value ğ‘Ÿ
Session 10C: Foundations CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea2679extracted in Hyb4 is not the randomness used in generating (ğ‘1, ğ‘2),
i.e., ğºğ‘Ÿ â‰  ğ‘1.
By the simulation-soundness of the NIZK, for ğ›¼ := âŒŠlog Ëœğ‘âŒ‹ + 1,
(cid:33)
(cid:32)
=
ğ‘–=1
ğº, ğ¾,
ğº, ğ¾,
ğ‘2ğ‘–
ğ‘–,0,
ğ›¼
we have that
ğ‘–=1
ğºğ‘ ğ‘– Â·2âˆ’ğœŒğ‘– Â·2ğ‘–
ğ›¼
(cid:32)
ğ›¼
(cid:16)ğº, ğ¾, ğºğ›¼
(cid:16)ğº, ğ¾, ğºğ‘ â€²
, ğ¾ğ‘ â€² Â· ğºğ›¼
with ğ‘ â€² =ğ›¼
ğºğ›¼
ğ‘–=1 ğ‘ ğ‘–2âˆ’ğœŒğ‘– Â·2ğ‘–
ğ‘–=1
=
=
ğ¾ğ‘ ğ‘– Â·2âˆ’ğœŒğ‘– Â·2ğ‘– Â· ğºğ‘Ÿğ‘– Â·2ğ‘– Â· ğ‘âˆ’1
1
,
ğ‘–,1 Â· ğ‘âˆ’1
ğ‘2ğ‘–
ğ›¼
1
ğ‘–=1 ğ‘ ğ‘–2âˆ’ğœŒğ‘– Â·2ğ‘– Â· ğºğ›¼
, ğ¾ğ›¼
(cid:17) âˆˆ L2
ğ‘–=1 ğ‘Ÿğ‘– Â·2ğ‘– Â· ğ‘âˆ’1
1
ğ‘–=1
ğ‘–=1 ğ‘Ÿğ‘– Â·2ğ‘– Â· ğ‘âˆ’1
1
(cid:33)
(cid:17)
ğ‘–=1 ğ‘ ğ‘–2âˆ’ğœŒğ‘– Â· 2ğ‘–, which in particular means
ğ‘–=1 ğ‘Ÿğ‘– Â·2ğ‘–
= ğ‘1
and therefore (ğ‘Ÿ1, . . . , ğ‘Ÿğ›¼) is the bit decomposition of the discrete
logarithm of ğ‘1 in base ğº. Furthermore, we have that ( Ëœğ‘ğ‘–,0, Ëœğ‘ğ‘–,1)
encrypts the same bit as (ğ‘ğ‘–,0, ğ‘ğ‘–,1), for all ğ‘– âˆˆ [ğ›¼]. It follows that de-
crypting (ğ‘ğ‘–,0, ğ‘ğ‘–,1) yields a valid bit decomposition of ğ‘Ÿ, the discrete
logarithm of ğ‘1 in base ğº, except with negligible probability.
Hyb4 â‰ˆğ‘ Hyb5: The indistinguishability follows from a reduction
to the hiding property of the time-lock puzzle. The only non-trivial
aspect of the reduction is the running time needed to answer the
queries of the adversary to the oracle O. Note however that the
running time of the simulated oracle is independent of T, so the
running time of the reduction is only a polynomial (in ğœ†) factor
slower than that of the adversary.
Indistinguishability of the hybrids Hyb5 . . . Hyb9 follows along the
same lines. This concludes the proof for CCA security.
The proof for verifiability follows from the soundness of the
NIZK proof system. Notice that the winning condition of the verifi-
ability property requires TVfy(crs, ğ‘, ğœ‹) = 1 and ğ‘ âˆ‰ TCom(crs, ğ‘š).
The latter condition means that the commitments is not well-formed
according to TCom. Therefore, it must be the case that Vfy(crs, stmt,
ğœ‹) = 1 and one of the following holds:
(ğº, ğ¾) âˆ‰ L1
(cid:32)
ğ›¼
ğ‘–=1
ğ›¼
ğ‘–=1
ğº, ğ¾,
ğ‘2ğ‘–
ğ‘–,0,
ğ‘–,1 Â· ğ‘âˆ’1
ğ‘2ğ‘–
1
âˆ‰ L2
(cid:33)
(ğº, ğ¾, Ëœğº, Ëœğ¾, {ğ‘ğ‘–,0, ğ‘ğ‘–,1, Ëœğ‘ğ‘–,0, Ëœğ‘ğ‘–,1}ğ‘–âˆˆ[ğ›¼]) âˆ‰ L3
where ğ›¼ := âŒŠlog Ëœğ‘âŒ‹+1. The above event immediately contradicts the
soundness of at least one of the NIZK proof systems that we use for
the languages. We can therefore conclude that the probability with
which the above event occurs is at most negligible in the security
parameter. This concludes the proof for verifiability.
â–¡
E EFFICIENT NIZK PROTOCOLS
Let ğ›¼ := âŒŠlog Ëœğ‘âŒ‹ + 1. We consider the statement
stmt = (ğ‘1, ğ‘2, ğº, ğ¾, Ëœğº, Ëœğ¾, {ğ‘ğ‘–,0, ğ‘ğ‘–,1, Ëœğ‘ğ‘–,0, Ëœğ‘ğ‘–,1}ğ‘–âˆˆ[ğ›¼])
as defined in Section 5. For simplicity we split the statement that
we want to prove in the following languages:
or
or
â€¢ Language L1 contains all statements stmt1 := (ğº, ğ¾) such that
ğ¾ is generated by ğº, defined as
(cid:110)(ğº, ğ¾)(cid:12)(cid:12)(cid:12) âˆƒ ğ‘˜, ğœŒ s.t. ğ¾ = ğºğ‘˜Â·2âˆ’ğœŒ(cid:111) .
L1 :=
â€¢ Language L2 contains statements