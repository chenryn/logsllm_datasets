我们唯一的需求是指示函数可以处理字符串，并且希望该指示函数永远不会被漏洞利用程序调用。因此我们选择[
**JSON.stringify**](http://help.adobe.com/en_US/FlashPlatform/reference/actionscript/3/JSON.html#stringify\(\))函数作为指示函数。
在Flash库中查找指示函数的偏移量相对而言比较简单。我们分配一个字符串对象，使用WinDBG在内存中搜索这个对象，设置在访问字符串时触发断点，然后引导JSON.stringify函数处理字符串，如下所示：
编译ActionScript工程后，我们将创建的SWF文件嵌入到一个本地html文件中，使用IE浏览器打开这个文件。我们将WindDBG附加到IE进程上，在ExternalInterface.call(“alert(123)”)这一行设置断点。
当alert弹出时，Flash会暂停运行。此时，我们使用[
**Mona.py**](https://www.corelan.be/index.php/2011/07/14/mona-py-the-manual/)查找已分配的字符串对象，使用“ba”指令，设置WinDBG在读取这个具体的位置时触发断点：
在我们恢复Flash的运行后，断点自然会被触发：
现在我们需要验证当前操作的确与JSON.stringify()有关。在IDA中查看这个地址，我们发现情况的确如此：
如果一切按照计划执行，在函数返回时，eax中应该保存一个指向字符串化对象的指针。
大功告成，我们可以将以上步骤结合在一起，在WinDBG控制台中，创建断点，打印发往json.stringify()函数的所有所有字符串，如下所示：
    bp (Flash32_17_0_0_188 + 006a201a)  “.echo ——-; da poi(eax)”
**3.3.2 使用指示函数hook原始的SWF文件**
在处理各种对象和数据类型时，单单打印字符串是远远不够的。然而，我们可以将自己的类添加到flash文件中，这样我们就能够执行更加复杂的逻辑处理，处理各种数据类型。我们使用的类名为“exploit_common”，使用的主函数是debugPrint()。这个类能接受任何对象作为参数，并根据对象的具体类型进行处理，因此能够简化整个hook流程。然而，我们不能简单地将ActionScript代码以文本形式添加到漏洞利用程序中，因此，我们利用Adobe提供的[
**Flex SDK**](http://www.adobe.com/devnet/flex/flex-sdk-download.html)，使用如下命令编译库文件：
其中“as”是ActionScript库的实际路径。接下来，我们使用RABCDasm反汇编这个新创建的SWF文件。
之后我们拷贝库的.asasm文件，放在一边留待后用。
**四、案例演示**
现在我们以实际的漏洞利用程序为例，介绍这种方法的具体应用。
Sundown是目前最活跃的漏洞利用工具之一。我们可以从[ **Malware-traffic-analysis**](http://www.malware-traffic-analysis.net/2017/01/06/2017-01-06-Sundown-EK-sends-Terdot.A-Zloader.pcap.zip)上下载Sundown最新的Flash漏洞利用工具。
首先我们需要导出恶意SWF文件的DoABC标签，对类进行反汇编处理。
需要注意的是，abcexport命令导出的DoABC标签中包含附加的索引值，我们需要反汇编第一个索引（索引值从0开始）。
每个标签反汇编之后都会生成一些.class.asasm以及.script.asasm文件，以及一个main.asasm文件。
我们需要编辑main.asasm，包含我们的自定义库。
当然我们也需要将我们之前生成的.asasm文件添加进去：
现在我们已经可以在漏洞利用工具内部调用我们自己的函数。分析经过混淆处理的flash漏洞利用工具不是特别容易，对于Sundown来说，它的某些类名似乎是随机生成的。
**4.1 导出shellcode**
这个SWF文件的主类名为“unfaithfulness”。
我们在主类的初始化函数内部，找到一个非常长的混淆字符串。我们对这个字符串的功能比较感兴趣。
上图中高亮的那一行代码在ABC指令中的形式如下：
图1. 生成的字节码
在字节码中，当变量从AVM栈中弹出时，会使用setlocal_n指令完成变量的本地分配。因此，hook点应该挂在_loc6_的分配完成之后，如下所示：
现在我们可以保存.asasm文件了，汇编处理.asasm文件，生成.abc文件，将漏洞利用工具中的DoABC标签替换为我们hook过的标签。
Abcreplace.exe工具接受以下三个参数：
1、需要修改的.SWF文件；
2、需要替换的标签的索引值
3、我们修改过的标签
将hook后的SWF文件嵌入到一个HTML文件中，使用调试器开始调试。
设置断点、运行漏洞利用工具后，我们可以看到断点已被触发：
我们可以看到_loc6_的打印信息，它看起来像是一个shellcode，这段shellcode以XOR循环开始：
能够导出解码后的shellcode看起来的确很酷，但这种方法的最大的功能是能够了解堆的布局结构。现在让我们来看看如何做到这一点。
**4.2 查看堆结构**
以下是漏洞利用工具调用的第一个函数：
Spray_obj()中创建了两个Vector：
Vector
obj20中包含大小为20字节的数组，长度为0x200000。这些数组都包含明显特征，数组开头为一个有序增加的整数，整数基址为0xFACE0000，如下所示：
Vector obj4000保存0x4000个“everyday”类的实例：
“everyday”类的结构如下所示：
可以看出来，这个对象头部包含某些特征，应该会被漏洞利用工具大量填充到堆中（即所谓的堆喷射技术）。
所有的堆操作和设置准备完毕后，我们现在可以触发漏洞了。我们执行一次数组溢出读取操作，读取数组范围之外的78字节数据。由于obj20只有0x200000字节长，因此我们需要读取0x200078长度的数据。堆喷射成功后，泄露的对象（紧挨着obj20的最后一个成员所在的地址）的类型应该为“everyday”。代码如下图所示：
这个位置就是我们希望hook的关键位置，与一些信息描述字符串以及_local7的值有关：
我们可以借此获取有关堆结构的一些关键信息。与之前操作类似，我们需要保存、汇编以及替换我们修改过的标签。
在WindDBG中设置必要的断点，断点触发情况如下所示：
在0x78偏移处，我们找到了第一个“everyday”成员：
从前文分析，我们已知obj20字节数组的长度为0x200000，因此我们应该可以在0x090a0000处找到它，如下所示：
我们只是通过这个示例说明这种方法的强大功能。从此时开始，我们可以设置更多的断点，访问泄露的对象，搜索漏洞利用工具在内存中的模式和特征，了解所分配空间的特点等等。
**五、结论**
Flash漏洞利用无所不在，从漏洞利用工具以及目标攻击活动等各方面都能看到它的身影。这些漏洞利用程序使用高强度的混淆机制，试图逃避基于静态特征的检查，提高安全研究人员的分析难度。我们有可能使用[
**跟踪（trace）**](http://help.adobe.com/en_US/FlashPlatform/reference/actionscript/3/package.html#trace\(\))功能、使用[
**Flash Debug
Player**](https://www.adobe.com/support/flashplayer/debug_downloads.html)运行漏洞利用工具，避免在原生层进行调试。然而，虽然原生层的调试比较具有挑战性，但在处理具有底层虚拟机（例如Flash）的应用时，这种调试方式依然非常强大，具有多个优点。我们可以使用某些不常用的指示函数作为断点、提供有价值信息，在漏洞利用的执行流程中的关键点中断执行流程，打印有价值的数据，对恶意SWF文件进行调试。对比传统的debug
player调试方法，我们可以通过这种方法获得维度更广的信息。