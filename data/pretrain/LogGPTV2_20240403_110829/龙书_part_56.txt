F →digit
图5-4一个基于适用于自顶向
←
*
←
产生式
下语法分析的文法的 SDD
F.val = 4
F.val = digit.lerval
T'.syn = T'.inh 
T'.syn = T}-syn
T}.inh = T'.inh x F.val
T.val = T'.syn
T'.inh = F.val
语义规则
197
---
## Page 214
的边表示计算第二个属性实例时需要第一个属性实例的值。图中的边表示语义规则所蕴涵的约
5.2.1依赖图
且在实践中遇到的大部分翻译方案可以按照这两类 SDD 中的至少一类的要求写出来。
SDD。使用这两类 SDD 描述的翻译方案可以和我们已经研究过的语法分析方法很好地结合在一起。并
性实例的求值顺序。注释语法分析树显示了各个属性的值，而依赖图可以帮助我们确定如何计
5.2SDD 的求值顺序
束。更详细地说：
算这些值。
5.1.35.1节的练习
将值15 沿着树向上传递到 T结点，使得 T.ual
定
式是 T'→e。相应的语义规则 T". syn= T". inh
T.inh= 15。在层次较低的 T 结点上的产生
这个规则和产生式2 相关联。
由语义规则 T.inh = T".inh × F. val 定义的,
区分树中的两个 T'结点。)继承属性 T.inh 是
（我们保留了注释语法分析树中的下标1，以
因此，运算符＊的左运算分量3从根结点的左子结点传递到右子结点。
因为--个结点N可能有多个标号为X的子结点，我们再次假设使用下标来区分同一个符号在这个产生式的不同
在本节中，除了依赖图，我们还定义了两类重要的 SDD：“S属性"SDD 和更加通用的“L属性"
义了T.syn=15。各个 T'结点上的属性 syn
依赖图描述了某个语法分析树中的属性实例之间的信息流。从一个属性实例到另一个实例
依赖图（dependency graph)是一个有用的工具，它可以确定一棵给定的语法分析树中各个属
已知 T".inh =3 且 F.ual = 5，我们得到
，对应于 T"的结点的产生式是T一→*FT!
在根结点的第二个子结点上，继承属性T. inh根据和产生式1 关联的语义规则T. inh=F ual 定义。
198
●对于每个语法分析树的结点，比如一个标号为文法符号X的结点，和X关联的每个属性
练习 5.1.3：使用你在练习5.1.2 中得到的 SDD，重复练习5.1.1。
练习 5.1.2：扩展图5-4 中的 SDD，使它可以像图 5-1 所示的那样处理表达式。
3）(9+8*(7+6)+5)*4n 
2)1*2*3*(4+5)n
1)(3+4)*(5+6)n 
练习5.1.1：对于图5-1中的 SDD，给出下列表达式对应的注释语法分析树：
位置上的多次使用。
都在依赖图中有--个结点。
式体中的符号 X 的实例所对应的 N的子结点上的属性c到 N上的属性 b 的边。
的边。更准确地讲，在每个标号为A且应用了产生式p的结点N上，创建一条从该产生
A.b时可能还用到了X.c之外的其他属性）。那么，相应的依赖图中有一条从X.c到 A.b
图
=15。
digit.lerval = 3
图5-53＊5 的注释语法分析树
T.vat = 15 
digit.lerval = 5
F.val'= 5
inh = 3
第5章
口
---
## Page 215
图的拓扑排序(topological sort）。
N;的依赖图的边，那么i<j。这样的排序将一个有向图变成了一个线性排序，这个排序称为这个
此，所有的可行求值顺序就是满足下列条件的结点顺序 N、M2、、N：如果有一条从结点N;到
中有一条从结点 M到结点 N的边，那么要先对 M 对应的属性求值，再对 N 对应的属性求值。
5.2.2属性求值的顺序
T. val = T'.syn 而得到的。
所关联的语义规则得到的。
5-4 中的产生式3 所关联的规则 T.sym= T. inh 得到的。从结点 7 到结点 8 的边是根据产生式 2
digit.lexval，但依赖图中的边表示的是依赖关系，而不是等于关系。
的边是根据通过 SDD 中 digit. lexoal 定义 F. ual 的语义规则得到的。实际上，F. ual 等于
联的属性 val。从结点1到结点3 的边，以及从结点2 到结点 4
的属性 lexval。结点 3 和 4 表示和其标号为 F 的两个结点相关
树中的各个属性。
江
结
图的结点用数字1～9表示，对应于图5-5中的注释语法分析
例55
线，而依赖图的边显示为实线。
析树，该树的依赖图中有一部分如图5-6所示。作为惯例，我们将把语法分析树的边显示为且
例5. 4
依赖图刻画了对一棵语法分析树中不同结点上的属性求值时可能采取的顺序。如果依赖图
了结点6上的属性inh 的值。
表 F.val 的边，因为这两个值相乘后得
表 T.inh 的边和从结点 4 到结点 5
inh。我们看到了从结点5到结点6 的
pal 得到的，这个规则根据根的左子结
点3到结点5的边是根据规则 T.inh =
次出现相关联的继承属性T'.inh。
语法制导的翻译
结点 7 和8 表示了和 T"的各次出现相关联的综合属性 syn。从结点6 到结点7 的边是根据图
上的 F.val 定义了右子结点上！
最后，结点9 表示属性 T. ual。从结点8 到结点9 的边是根据产生式1 所关联的语义规则
结点5和6 表示和非终结符号 T'的
结点 1 和2 表示和其标号为 digit 的两个叶子结点相关联
在每个标号为E，且其子结点对应于这个产生式体的结点 N上，N上的综合属性 val 使用两
·假设和产生式p关联的一-个语义规则通过X.α的值定义了继承属性 B.c的值。那么，在
个X。请注意，M可以是N的父结点或者兄弟结点。
个 B 的结点 N，创建一条从结点 M上的属性α 到 N上的属性c的边。这里的 M 对应于这
相应的依赖图中有一条从 X.α到 B.c的边。对于每个标号为 B、对应于产生式 p 中的这
一个完整的依赖图的例子如图 5-7 所示。这个依赖
考虑下面的产生式和规则：
产生式
的
从
digit 1 lezval
图5-7对应于图5-5 中的注释语法分析树的依赖图
E.ual = E1.val + T.ual
3
语义规则
digit 2 lerval
图5-6E.val由E val 和
T. val 综合得到
十
uis9
val
199
100
因
图
口
图
口
虚
分
2
---
## Page 216
确地讲，每个属性必须要么是
5. 2.4 L属性的定义 
存放在分析栈中。这个过程不会显式地创建语法分析树的结点。
语法分析树的根上（见2.3.4节中的“前序遍历和后序遍历”部分）：
各个属性值。对语法分析树进行后序遍历并对属性求值常常会非常简单，当遍历最后一次离开
F pal)都是综合属性。
例5.7
底向上的语法分析过程一起高效地实现。
5. 2.3 S 属性的定义 
排序。还有其他的拓扑排序，比如1、3、5、2、4、6、7、8、9。
请注意，这个图的每条边都是从编号较低的结点指向编号较高的结点，因此这个排序一定是拓扑
?
例5.6
明--下为什么会存在拓扑排序。因为没有环，所以我们一定能够找到一个没有边进入的结点。
1）和产生式头 A 关联的继承属性。
S 属性的定义可以在自底向上语法分析的过程中实现，因为一个自底向上的语法分析过程对
，如果一个 SDD 是S 属性的，我们可以按照语法分析树结点的任何自底向上顺序来计算它的
前面提到过，给定一个 SDD，很难判定是否存在一棵其依赖图包含环的语法分析树。在实践
如果这个图中存在任意一个环，那么就不存在拓扑排序。也就是说，没有办法在这棵语法分
200
对 N关联的各个属性求值：
postorder(N)
·如果一个 SDD 的每个属性都是综合属性，它就是S 属性的。
第一种 SDD 类型的定义如下：
一个综合属性，要么是
for(从左边开始,对 N 的每个子结点 C)postorder( C);；
图5-7中的依赖图没有环。它的拓扑排序之一-是这些结点的编码的顺序：1、2、、9。
图5-1 中的 SDD 是一-个 S 属性定义的例子。其中的每个属性( L val、E nal、T pal 和 
第5章
口
---
## Page 217
个打印语句在结果被计算到E.val 中之后才会被执行。
相关的哑综合属性的定义。这个经过修改的 SDD 在任何拓扑顺序下都能产生相同的值，因为这
像 print(E. val)这样的语义规则的目的就是执行它们的副作用。它们将会被看作与相应产生式头
不使用规则 L. val= E. val,这个规则将结果保存到综合属性 L. oal 中。我们考虑：
成器可能把--个标识符的类型加人到符号表中。对于SDD，我们在属性文法和翻译方案之间找
5.2.5具有受控副作用的语义规则
按
到
结
体中位于 B 的右边。虽然在L属性的 SDD 中可以使用语法分析树中的兄弟结点的属性，但这些
个规则是合法的，这个 SDD 也不可能是L属性的，因为属性C.c用来定义 B.i，并且C在产生式
(也就是产生式体中的一个符号)的属性定义了综合属性A.s。
第
例5.9
此这个 SDD 是L 属性的。
“来自于上边或左边”的语法树结点，因此满足这一类 SDD 的要求。其余的属性是综合属性，因
T.inh及 F.ual，其中 F 在这个产生式体中出现在 T'的左边。
部，因此满足L属性的要求。第二个规则定义 T'inh 时使用了和产生式头相关联的继承属性
其中的第一个规则定义继承属性T.inh 时只使用了 F.val，且F 在相应产生式体中出现在 7"的左
便起见，我们在这里再重复下这些规则：
到了一个平衡点。属性文法没有副作用，并支持任何与依赖图一致的求值顺序。翻译方案要求
例5.8
依赖图中不存在环。
安从左到右的顺序求值，并允许语义动作包含任何程序片段。翻译方案将在5.4节中讨论。
点必须位于被定义属性的符号的左边。
第一-个规则 A.s=B.b在 S 属性 SDD 或L 属性 SDD 中都是一个合法的规则。它通过一个子结点
第二个规则定义了一个继承属性 B.i，因此整个 SDD 不可能是S属性的。不仅如此，虽然这
语法制导的翻译
作为附带副作用的一个例子，让我们修改例5.1的桌上计算器，使它打印出计算结果。我们
在实践中，翻译过程会出现一些副作用：一个桌上计算器可能打印出一个结果；一个代码生
。支持那些不会对属性求值产生约束的附带副作用。换句话说，如果按照依赖图的任何拓
我们将按照下面的方法之一来控制 SDD 中的副作用：
3）和这个X;的实例本身相关的继承属性或综合属性，但是在由这个X；的全部属性组成的
2）位于X;左边的文法符号实例X、Xz、、X;-;相关的继承属性或者综合属性。
些约束可以被看作隐含加人到依赖图中的边。
对允许的求值顺序添加约束，使得以任何允许的顺序求值都会产生相同的翻译结果。这
“正确”要视具体应用而定。
扑顺序进行属性求值时都可以产生“正确的”翻译结果，我们就允许副作用存在。这里的