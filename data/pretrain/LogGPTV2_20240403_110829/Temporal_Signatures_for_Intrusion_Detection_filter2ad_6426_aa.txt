title:Temporal Signatures for Intrusion Detection
author:Anita Jones and
Song Li
Temporal Signatures for Intrusion Detection
Anita Jones
PI:EMAIL
University of Virginia
Song Li
PI:EMAIL
University of Massachusetts
Abstract
We  introduce  a  new  method  for  detecting  intrusions
based on the temporal behavior of applications. It builds
on  an  existing  method  of  application  intrusion  detection
developed  at  the  University  of  New  Mexico  that  uses  a
system  call  sequence  as  a  signature.    Intrusions  are
detected by comparing the signature of the intrusion and
that of the normal application. But when the system call
sequences  generated  by  the  intrusion  and  the  normal
application  are  sufficiently  similar,  this  method  cannot
work.  By  extending  system  call  signature  to  incorporate
temporal information related to the application, we form
a  richer  signature.  Analysis  shows  that  the  temporal
behavior  for  many  applications  is  relatively  stable.  We
exclude  high  variance  data  when  creating  a  normal
database to characterize an application with  a  temporal
signature.  It can then be the basis for future comparisons
in  an  intrusion  detection  system.  This  paper  discusses
experiments  that  test  the  effectiveness  of  the  temporal
signature on different applications, alternative intrusions,
and  in  various  environments.  The  results  show  that  by
choosing 
and
experimentally  adjusting  the  parameters,  intrusions  are
readily  detected.  Finally,  we  give  some  comparisons
between  the  temporal  signature  method  and  the  system
call method.
appropriate 
methods 
analysis 
Keywords:    security,  application  intrusion  detection,
temporal signature
1. Introduction
Modern  computer  systems  are  vulnerable  to  numerous
intrusions. Both the long standing UNIX buffer overflow
flaw and the recently successful denial of services attacks
illustrate  that  applications  and  operating  systems  harbor
many  security  flaws.  The  use  of  Intrusion  Detection
Systems  (IDS)  to  assure  security  is  based  on  the
assumption  that  a  system  will  not  be  secure,  but  that
violations  of  security  policy  (intrusions)  can  be  detected
by  analyzing  system  behavior  [1].  Anomaly  detection
techniques  assume 
intrusive  activities  are
necessarily anomalous. This  means  that  given  a  "normal
activity profile" for a system, intrusion attempts produce
that  all 
behavior  that  varies  from  the  established  profile  by
statistically significant amounts [2, 3].
An anomaly detection method created at the University
of New Mexico defines sequences of system calls created
by  a  particular  application  to  be  its  signature  [1,  4].
Anomalous  behavior  of 
that  application,  hopefully,
produces  system  call  sequences  that  are  different  from
those of the normally executing application.  Of course, if
all system call sequences produced by an intrusion are a
subset  of  those  of  the  application  executing  normally,
then the intrusion cannot be detected.
The University of New Mexico method depends on the
creation of a database for each application that consists of
call  sequences 
that
application. To detect intrusions, sequences in this normal
database  are  compared  with  the  system  call  sequences
generated by monitored runs of the application.
that  reflect  normal  activity  of 
Hamming distance, which is a measure of the distance
or difference between two system call sequences, is used
as  the  criteria  for  determining  abnormal  from  normal
signatures.
2. Temporal signature introduced
Our  work  builds  on  the  University  of  New  Mexico
method;  we  use  sequences  of  system  calls,  but  also
incorporate  timing  properties  to  create  signatures  that
more richly and uniquely related to the application.  We
have  experimented  with  four  different  time  measure
definitions.   In this paper, we discuss the measure that we
consider  the  most  straightforward  and  most  effective.
That measure is the time duration between sequence calls.
Time  measurements  are  on  a  per  process  basis  and  are
made so that  only  the  time  duration  (between  calls)  that
the  process  is  actually  executing  is  measured.    Context
swap and process sleep time are elided.   For convenience,
we will denote this time measurement as r.
The  elapsed  time  between  two  system  calls  can  vary
because  the  path  through  the  application  code  can  vary.
So,  we  take  a  number  of  measurements  for  each  unique
sequence.    We  compute  time  distributions  for  each  time
interval between two calls in a unique sequence. Then we
build the normal database containing signatures that are –
in  effect  –  summaries  of  multiple  measurements.
1
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 07:06:42 UTC from IEEE Xplore.  Restrictions apply. 
Figure  1.  The  frequency  distribution  of  the  time  intervals  associated  with  a
particular pair of adjacent system calls.
3. Building the raw database
In  this  section  we  describe  how  a  raw  database  is
constructed,  and  in  the  next  section  we  describe  how  to
refine it to be a normal database that can be considered a
signature 
  Our
discussion  will  focus  on  the  construction  of  a  single
element in the database.
representative  of 
the  application. 
We monitor application execution multiple times either
in  a  production  environment,  or  when  synthetically
stimulating the application, with a variety of inputs.  That
execution generates a sequence of system calls.  Given a
sequence  length  k,  we  can  pass  a  window  across  the
recorded sequence and detect all unique sub-sequences of
length  k.    We  will  develop  a  database  element  for  each
such k-length sequence.
 In  the  following  explanation,  we  use  an  illustrative
system call sequence of length 6:
         open, fstat, seteuid, socket, setsockopt, bind.
During the time that the database measurements are taken,
there  are  typically  many  cases  in  which  this  unique
sequence  of  calls  is  detected.      We  collect  the  multiple
cases  of  time  measurements  related  to  the  unique  call
sequence into groups called sequence clusters. Each case
is a sequence of time interval measurements.
Table 1 illustrates one sequence cluster. The first row
representing the system call sequence is called the title of
the cluster. All other rows represent one time interval
sequence or case. Table 1 has a total of twelve cases, i.e.
the sequence in the title was measured 12 times.
The  raw  temporal  signature  database  is  defined  as  a
collection  of  sequence  clusters,  or  clusters.  There  is  a
different  database  of 
temporal  signatures  for  each
application.
Table 1. Illustration of one sequence cluster
composed of one title and 12 cases.
System
interval  calls
sequence
Case 1
Case 2
Case 3
Case 4
Case 5
Case 6
Case 7
Case 8
Case 9
Case 10
Case 11
Case 12
open fstat seteuid socket setsockopt bind
108
84
84
84
116
85
87
87
114
83
120
   98
24
22
23
23
23
22
24
22
25
23
23
23
25
23
24
24
24
23
23
23
24
50
23      23
43
37
37
38
41
40
41
42
43
41
40
  41
21
21
23
21
22
23
23
23
22
24
22
      22
27
27
27
27
28
28
29
29
28
27
27
 27
The  database  of  an  application  might  be  large  or
relatively small. Usually, the signature of an application is
generated  by  one  or  more  executions  of  the  application.
Sometimes,  several  sequence  clusters  for  an  application
are created at different times.  Two  clusters  for  the  same
application  can  be  merged  to  create  a  new  cluster.  The
new  cluster  is  the  union  of  all  the  clusters  that  share  a
common  title.  Two  clusters  can  be  merged  only  if  their
sequence lengths are identical.
Next we consider the time elapsed between two system
adjacent  calls  in  a  cluster.    Figure  1  illustrates  that  the
2
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 07:06:42 UTC from IEEE Xplore.  Restrictions apply. 
Figure 2. The frequency distribution of the time intervals with two peaks.
time intervals corresponding to the interval between fstat
and  getpid  in  a  particular  cluster,  i.e.  one  column  of  a
sequence  cluster.      In  Figure  1,  the  x  axis  indicates  the
time  interval  duration,  measured  in  µs,  between  the  two
successive system calls. The y axis is the number of the
occurrences  of  each  value  of  a  particular  time  interval
value. So, for about 400 times, the interval measured was
61(µs).    Figure  1  depicts  2832  time  interval  measures.
Note  that  the  time  intervals  between  the  pair  of  calls
deviate from one another very little.  We found this to be
typical.
Because  some  time  intervals  exhibit  large  deviations
and  are  not  well  distributed,  the  raw  cluster  summaries
should not be used directly. High variance data should be
removed.  The  next  step  is  to  reduce  the  raw  sequence
cluster data illustrated by Table 1 to a summary form  We
refer to the process as qualifying the database.
However, in some situations we observed distributions
with  multiple  peaks.      Figure  2  shows  two  clear  peaks,
and both of them are similar to normal distributions. We
observed  multiple  peaks  (usually  two)  in  only  3-10%  of
the cases.
The  reason  for  such  two-peak  distribution  of  time
intervals  is  likely  because  two  different  execution  paths
through the application code that exhibits the same system
call sequence.
3. Qualification of cluster summaries and
derivation of the normal database
First,  we  calculate  an  initial  summary  of  the  time
interval sequences.   We define a cluster summary to be
the  combination  of  the  title  of  the  sequence  cluster,  the
mean vector of all the cases, and  the  standard  deviation
vector of all the cases.
   In  Table  2,  the  initial  cluster  summary  appears  at  the
bottom  of  the  table.  The  row  labeled  m  is  the  vector  of
mean values. The row labeled s is the vector of standard
deviations.
In Table 2, most standard deviations are small because
most case values are quite close to their associated mean
values.  However,  note  that  four  time  intervals  diverge
greatly  from  their  corresponding  mean.    Three  are
associated with system call open: 116, 114, 120 (cases 5,
9, 11, respectively), and also the value 50 for case 11 and
system  call  seteuid.  Analysis  shows  that  most  such  high
variance data are due to I/O related system calls, as is the
case here with open. Basically this occurs for I/O devices
whose  actions  rely  on  (slow)  mechanical  components.
However, not all I/O related system calls would result in
high variance time intervals.
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 07:06:42 UTC from IEEE Xplore.  Restrictions apply. 
3
Table 2. Time intervals in a cluster, m is the mean of
time intervals in each column, s is the standard
deviation of these time intervals
seteuid socket setsockopt
System
interval calls
sequence
open
Case 1
Case 2
Case 3
Case 4
Case 5
Case 6
Case 7
Case 8
Case 9
Case 10
Case 11
Case 12
m (mean)
s
108
84
84
84
116
85
87
87
114
83
120
98
95.8
14.6
fstat
24
23
23
24
25
23
25
24
24
23
24
23
23.8
0.75
bind
27
27
27
27
28
28
29
29
28
27
27
27
27.6
22
23
23
22
23
23
23
24
23
23
50
23
25.2
7.84
43
37
37
38
41