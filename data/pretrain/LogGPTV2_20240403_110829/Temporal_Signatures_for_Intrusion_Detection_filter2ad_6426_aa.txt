# Temporal Signatures for Intrusion Detection

## Authors
- Anita Jones
  - University of Virginia
  - Email: [EMAIL]
- Song Li
  - University of Massachusetts
  - Email: [EMAIL]

## Abstract
We present a novel method for detecting intrusions by leveraging the temporal behavior of applications. This approach builds on an existing intrusion detection technique developed at the University of New Mexico, which uses system call sequences as signatures. The current method identifies intrusions by comparing the signature of the intrusion with that of the normal application. However, when the system call sequences generated by the intrusion and the normal application are highly similar, this method becomes ineffective. By extending the system call signature to include temporal information, we create a more robust and unique signature. Our analysis shows that the temporal behavior of many applications is relatively stable. We exclude high-variance data when constructing a normal database to characterize an application with a temporal signature, which can then serve as a basis for future comparisons in an intrusion detection system. This paper discusses experiments that test the effectiveness of the temporal signature method across different applications, alternative intrusions, and various environments. The results demonstrate that, with appropriate parameter selection and experimental adjustments, intrusions can be readily detected. Finally, we provide a comparison between the temporal signature method and the traditional system call method.

**Keywords:** security, application intrusion detection, temporal signature

## 1. Introduction
Modern computer systems are vulnerable to numerous intrusions. Both long-standing issues like the UNIX buffer overflow flaw and recent successful denial-of-service attacks highlight the many security vulnerabilities in applications and operating systems. Intrusion Detection Systems (IDS) are used to ensure security based on the assumption that while a system may not be entirely secure, violations of security policies (intrusions) can be detected by analyzing system behavior [1]. Anomaly detection techniques assume that intrusive activities are necessarily anomalous. This means that given a "normal activity profile" for a system, intrusion attempts produce behavior that significantly deviates from the established profile [2, 3].

An anomaly detection method developed at the University of New Mexico defines the sequences of system calls created by a particular application as its signature [1, 4]. Anomalous behavior of the application, ideally, produces system call sequences that differ from those of the normally executing application. If all system call sequences produced by an intrusion are a subset of those of the application executing normally, the intrusion cannot be detected.

The University of New Mexico method relies on creating a database for each application that consists of system call sequences reflecting normal activity. To detect intrusions, sequences in this normal database are compared with the system call sequences generated during monitored runs of the application. The Hamming distance, a measure of the difference between two system call sequences, is used as the criterion for distinguishing abnormal from normal signatures.

## 2. Temporal Signature Method
Our work extends the University of New Mexico method by incorporating timing properties into the system call sequences to create richer and more unique signatures. We have experimented with four different time measurement definitions. In this paper, we discuss the most straightforward and effective measure: the time duration between sequence calls. Time measurements are made on a per-process basis, capturing only the actual execution time of the process, excluding context swap and process sleep times. For convenience, we denote this time measurement as \( r \).

The elapsed time between two system calls can vary due to different paths through the application code. Therefore, we take multiple measurements for each unique sequence and compute time distributions for each time interval between two calls in a unique sequence. We then build a normal database containing signatures that summarize these multiple measurements.

### Figure 1
**Frequency distribution of the time intervals associated with a particular pair of adjacent system calls.**

## 3. Building the Raw Database
In this section, we describe the construction of a raw database, and in the next section, we explain how to refine it into a normal database that can be considered representative of the application.

We monitor the application's execution multiple times, either in a production environment or under synthetic stimulation, using a variety of inputs. This generates a sequence of system calls. Given a sequence length \( k \), we can pass a window across the recorded sequence and detect all unique sub-sequences of length \( k \). We develop a database element for each such \( k \)-length sequence.

For illustration, consider a system call sequence of length 6:
```
open, fstat, seteuid, socket, setsockopt, bind
```
During the database measurement period, this unique sequence of calls is typically detected multiple times. We collect the multiple cases of time measurements related to the unique call sequence into groups called sequence clusters. Each case is a sequence of time interval measurements.

### Table 1
**Illustration of one sequence cluster composed of one title and 12 cases.**

| System Calls | Case 1 | Case 2 | Case 3 | Case 4 | Case 5 | Case 6 | Case 7 | Case 8 | Case 9 | Case 10 | Case 11 | Case 12 |
|--------------|--------|--------|--------|--------|--------|--------|--------|--------|--------|---------|---------|---------|
| open         | 108    | 84     | 84     | 84     | 116    | 85     | 87     | 87     | 114    | 83      | 120     | 98      |
| fstat        | 24     | 22     | 23     | 23     | 23     | 22     | 24     | 22     | 25     | 23      | 23      | 23      |
| seteuid      | 25     | 23     | 24     | 24     | 24     | 23     | 23     | 23     | 24     | 22      | 22      | 22      |
| socket       | 50     | 23     | 23     | 43     | 37     | 37     | 38     | 41     | 40     | 41      | 42      | 43      |
| setsockopt   | 21     | 21     | 23     | 21     | 22     | 23     | 23     | 23     | 22     | 24      | 22      | 22      |
| bind         | 27     | 27     | 27     | 27     | 28     | 28     | 29     | 29     | 28     | 27      | 27      | 27      |

The raw temporal signature database is defined as a collection of sequence clusters. There is a different database of temporal signatures for each application.

### Figure 2
**Frequency distribution of the time intervals with two peaks.**

## 4. Qualification of Cluster Summaries and Derivation of the Normal Database
First, we calculate an initial summary of the time interval sequences. A cluster summary is defined as the combination of the title of the sequence cluster, the mean vector of all the cases, and the standard deviation vector of all the cases.

### Table 2
**Time intervals in a cluster, m is the mean of time intervals in each column, s is the standard deviation of these time intervals.**

| System Calls | Case 1 | Case 2 | Case 3 | Case 4 | Case 5 | Case 6 | Case 7 | Case 8 | Case 9 | Case 10 | Case 11 | Case 12 | m (mean) | s (std dev) |
|--------------|--------|--------|--------|--------|--------|--------|--------|--------|--------|---------|---------|---------|----------|------------|
| open         | 108    | 84     | 84     | 84     | 116    | 85     | 87     | 87     | 114    | 83      | 120     | 98      | 95.8     | 14.6      |
| fstat        | 24     | 23     | 23     | 24     | 25     | 23     | 25     | 24     | 24     | 23      | 24      | 23      | 23.8     | 0.75      |
| seteuid      | 27     | 27     | 27     | 27     | 28     | 28     | 29     | 29     | 28     | 27      | 27      | 27      | 27.6     | 22        |
| socket       | 23     | 23     | 22     | 23     | 23     | 23     | 24     | 23     | 23     | 50      | 23      | 25.2    | 7.84     |
| setsockopt   | 43     | 37     | 37     | 38     | 41     | 40     | 41     | 42     | 43     | 41      | 40      | 41      |          |            |
| bind         | 21     | 21     | 23     | 21     | 22     | 23     | 23     | 23     | 22     | 24      | 22      | 22      |          |            |

In Table 2, most standard deviations are small because most case values are close to their associated mean values. However, note that four time intervals diverge significantly from their corresponding mean. Analysis shows that most high-variance data are due to I/O-related system calls, as seen here with `open`. This occurs for I/O devices whose actions rely on slow mechanical components. Not all I/O-related system calls result in high-variance time intervals.

By excluding high-variance data, we refine the raw sequence cluster data into a summary form, which we refer to as qualifying the database. This refined database serves as the normal database for future comparisons in the intrusion detection system.