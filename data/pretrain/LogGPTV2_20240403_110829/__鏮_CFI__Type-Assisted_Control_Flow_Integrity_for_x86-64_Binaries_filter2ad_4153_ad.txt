nal COOP attack as presented in
the original paper. We observed
that due to the forward-edge pol-
icy this attack was no longer pos-
sible. For testing if backward-
edge attacks are possible after
applying τ CFI, we used several
open source ROP attacks that
are explicitly violating the control
ﬂow of a C++ program through
backward-edge violations. Next,
we instrumented the binaries of
these programs. Each attack that was using one of the protected function returns
was successfully stopped.
All Backward
edge violating
attacks
Jump to address /∈ in the max − min address range.
a
Jump to address (cid:5)= then a legitimate address.
b
Jump to address label (cid:5)= the calltarget return label.
c
(cid:2) (FP) Target function not AT
(cid:2) (FP) Void target where non-void
(cid:2) (FP) Void target where non-void
(cid:2) (BP) (1)
was expected
b
a
or (2)
Control Jujutsu [8]
Apache
Nginx
was expected
c
or (3)
In summary, many forward-edge and backward-edge attacks can be success-
fully mitigated by τ CFI as long as these attacks are not aware of the policy
in place and thus cannot selectively use gadgets that have their start address
in the allowed set for the legitimate forward-edge and backward-edge transfers,
respectively.
440
P. Muntean et al.
5.7 Runtime Overhead
Figure 4 presents
the runtime over-
head obtained by
applying τ CFI’s
forward-edge pol-
icy (register type;
parameter count)
and
backward-
edge policy on
all C/C++ pro-
grams contained
in SPEC CPU2006.
Out of the eval-
uated programs:
xala- ncbmk, namd,
omnetpp, dealII,
astar, soplex, and
povray are C++ programs, while the rest are pure C programs. After the pro-
grams were instrumented, we measured the runtime overhead. The geomean of
the instrumented programs is around 2.89% runtime overhead. One reason for
the performance drop is cache misses introduced by jumping between the old and
the new executable section of the binary generated by duplicating and patching.
This is necessary, because when outside of the compiler, it is diﬃcult to relo-
cate indirect control ﬂow. Therefore, every time an indirect control ﬂow occurs,
jumps into the old executable section and from there back to the new executable
section occur. Moreover, this is also dependent on the actual structure of the tar-
get as the overhead depends on the frequency of indirect control ﬂow operations.
Another reason for the slightly higher (yet acceptable) performance overhead is
our runtime policy, which is more complex than that of other state-of-the-art
tools.
Fig. 4. Runtime overhead.
6 Discussion
Limitations. First, τ CFI is limited by the capabilities of the DynInst instru-
mentation environment, where non-returning functions like exit are not detected
reliably in some cases. As a result, we cannot test the Pure-FTP server, as it
heavily relies on these functions. The problem is that those non-returning func-
tions usually appear as a second branch within a function that occurs after
the normal control ﬂow, causing basic blocks from the following function to be
attributed to the current function. This results in a malformed control ﬂow graph
and erroneous attribution of callsites and problematic misclassiﬁcations for both
calltargets and callsites.
Second, parameter passing through ﬂoating point registers is currently not
supported by τ CFI, similar to other state-of-the-art tools. Tail calls are also
τ CFI: Type-Assisted Control Flow Integrity for x86-64 Binaries
441
not supported for now as they lose the one-to-one matching between callers
and callees. Further, τ CFI does not support self-modifying code as code pages
become writable at run-time. We plan to address this limitation in future work.
Third, τ CFI is not intended to be more precise than source code based tools
such as IFCC/VTV [19]. However, τ CFI is highly useful in situations when the
source code is typically not available (e.g., oﬀ-the-shelf binaries), where programs
rely on third-party libraries, and where the recompilation of all shared libraries
is not possible.
Finally, while a major step forward, τ CFI cannot thwart all possible attacks,
as even solutions with access to source code are unable to protect against all pos-
sible attacks [27]. In contrast, τ CFI, our binary-based tool can stop all COOP
attacks published to date and signiﬁcantly raises the bar for an adversary when
compared to other state-of-the-art tools. Moreover, τ CFI provides a strong mit-
igation for other types of code-reuse attacks as well as for attacks that violate
the caller-callee function calling convention.
Attacker Policy Discovery Trade-oﬀs. In general, with usage of CFI tech-
niques, it is relatively unchallenging for an attacker to ﬁgure out where an indi-
rect program control ﬂow may transfer during runtime. This is because the
indirect transfer targets (backward and forward) are labeled with IDs that have
to satisfy certain conditions, e.g., a bitwise XOR operation between the bits of
the start and target address of indirect control ﬂow transfer should return a one
or zero in case the transfer is legal or illegal, respectively.
Thus, we note that in general it is not diﬃcult for a resourceful attacker to
ﬁgure out which callees match to which calltargets or vice versa when these are
labeled with IDs for example. τ CFI is not exempted from this. In general, if
the attacker knows where an indirect transfer is allowed to jump to, he may use
this wiggle space to craft his attack with the available (reachable) gadgets. The
main assumption on which CFI and τ CFI are built upon is that the wiggle room
is suﬃciently reduced for an attacker such that the likelihood for a successful
attack is greatly diminished.
7 Related Work
Mitigation of Forward-Edge Based Attacks with Binary-Based Tools.
τ CFI is closely related to TypeArmor w.r.t. the forward edge analysis. TypeAr-
mor [25] (≈3% runtime overhead in geomean) enforces a CFI-policy based on the
parameter count policy. Compared to τ CFI, TypeArmor does not use function
parameter types and assumes a backward-edge protection is in place. VCI [23]
and Marx [24] are both based on approximated program (quasi) class hierar-
chies; they (1) do not recover the root class of the hierarchy, and (2) the edges
between the classes are not oriented; thus both tools enforce for each callsite
the same virtual table entry (i.e., index based) contained in one recovered class
hierarchy represented by father-child relationships between the recovered vta-
bles. Finally, both tools use up to six heuristics and simplifying assumptions in
order to make the problem of program class hierarchy reconstruction tractable.
442
P. Muntean et al.
Compared to these tools, τ CFI tries not to reconstruct a high-level metadata
data structure (class hierarchy), but rather performs analysis on the usage of
provided and consumed parameters at the callsites and calltargets.
Mitigation of Backward-Edge Based Attacks with Binary Based Tools.
According to a comprehensive survey by Burow et al. [11], tools that provide
backward-edge protection oﬀer low, medium, and high levels of protection w.r.t.
backward edges. Further, this survey provides runtime overhead comparisons,
classiﬁes the backward-edge protection techniques into binary-based, source code
based, and other types (e.g., with HW support, etc.). Due to page restriction,
we review only binary tools.
implementation of Abadi et al.
[41],
kBouncer [42], CCFIR [20], bin-CFI [43], O-CFI [44], PathArmor [45], Lock-
Down [46] mostly suﬀer from imprecision (high number of reused labels), have
low runtime eﬃciency, and most of them protect either forward edges or back-
ward edges assuming a perfect shadow stack implementation is in place. In con-
trast, τ CFI makes no assumptions on the presence of a backward-edge protec-
tion. Further, τ CFI provides a technique for protecting forward edges and does
not rely on a shadow stack approach for protecting backward edges.
The original CFI
[9], MoCFI
8 Conclusion
In this paper, we have presented τ CFI, a new control ﬂow integrity (CFI) tech-
nique, which can be used to protect program control ﬂow graph (CFG) forward
edges and backward edges in executables during runtime. For the protected
stripped (i.e., no RTTI information) x86-64 binaries, we do not need to make
any assumptions on the presence of an auxiliary technique for protecting back-
ward edges (i.e., shadow stacks, etc.) as τ CFI protects these transfers, too. We
have evaluated τ CFI with real world open source programs and have shown that
τ CFI is practical and eﬀective when protecting program binaries. Further, our
evaluation reveals that τ CFI can considerably reduce the forward-edge legal call-
target set, provide high backward-edge precision, while maintaining low runtime
overhead.
Acknowledgement. We thank the anonymous reviewers for their feedback, which
helped to considerably improve the quality of this paper. Jens Grossklags’ research is sup-
ported by the German Institute for Trust and Safety on the Internet (DIVSI). Gang Tan
is supported by US NSF grants CCF-1723571 and CNS-1624126, the Defense Advanced
Research Projects Agency (DARPA) under agreement number N6600117C4052, and
Oﬃce of Naval Research (ONR) under agreement number N00014-17-1-2539. Zhiqiang
Lin is partially supported by US NSF grant CNS-1812553 and CNS-1834215, AFOSR
award FA9550-14-1-0119, and ONR award N00014-17-1-2995.
References
1. LLVM: Clang CFI (2017). https://goo.gl/W7aMF9
τ CFI: Type-Assisted Control Flow Integrity for x86-64 Binaries
443
2. LLVM: Clang’s SafeStack. https://clang.llvm.org/docs/SafeStack.html
3. Schuster, F., Tendyck, T., Liebchen, C., Davi, L., Sadeghi, A.R., Holz, T.: Coun-
terfeit object-oriented programming. In: S&P (2015)
4. Crane, S., et al.: It’s a TRaP: table randomization and protection against function-
reuse attacks. In: CCS (2015)
5. Lettner, J., et al.: Subversive-C: abusing and protecting dynamic message dispatch.
In: USENIX ATC (2016)
6. BlueLotus Team: BCTF challenge: Bypass VTable read-only checks (2015).
https://goo.gl/4RYDS2
7. Lan, B., Li, Y., Sun, H., Su, C., Liu, Y., Zeng, Q.: Loop-oriented programming:
a new code reuse attack to bypass modern defenses. In: IEEE Trustcom/Big-
DataSE/ISPA (2015)
8. Evans, I., et al.: Control Jujutsu: on the weaknesses of ﬁne-grained control ﬂow
integrity. In: CCS (2015)
9. Abadi, M., Budiu, M., Erlingsson, ´U., Ligatti, J.: Control ﬂow integrity. In: CCS
(2005)
10. Abadi, M., Budiu, M., Erlingsson, ´U., Ligatti, J.: Control ﬂow integrity principles,
implementations, and applications. In: TISSEC (2009)
11. Burow, N.: Control-ﬂow integrity: precision, security, and performance. CSUR 50,
16:1–16:33 (2017)
12. Tan, G., Jaeger, T.: CFG construction soundness in control-ﬂow integrity. In: PLAS
(2017)
13. Ramalingam, G.: The undecidability of aliasing. TOPLAS 16, 1467–1471 (1994)
14. Jang, D., Tatlock, T., Lerner, S.: SAFEDISPATCH: securing C++ virtual calls
from memory corruption attacks. In: NDSS (2014)
15. Niu, B., Tan, G.: Modular control-ﬂow integrity. In: PLDI (2014)
16. Niu, B., Tan, G.: RockJIT: securing just-in-time compilation using modular
control-ﬂow inegrity. In: CCS (2014)
17. Haller, I., Goktas, E., Athanasopoulos, E., Portokalidis, G., Bos, H.: ShrinkWrap:
VTable protection without loose ends. In: ACSAC (2015)
18. Bounov, D., G¨okhan K., R., Lerner, S.: Protecting C++ dynamic dispatch through
VTable interleaving. In: NDSS (2016)
19. Tice, C., et al.: Enforcing forward-edge control-ﬂow integrity in GCC and LLVM.
In: USENIX Security (2014)
20. Zhang, C., et al. : Practical control ﬂow integrity and randomization for binary
executables. In: S&P (2013)
21. Prakash, A., Hu, X., Yin, H.: Strict protection for virtual function calls in COTS
C++ binaries. In: NDSS (2015)
22. Zhang, C., Song, C., Zhijie, K.C., Chen, Z., Song, D.: VTint: protecting virtual
function tables’ integrity. In: NDSS (2015)
23. Elsabagh, M., Fleck, D., Stavrou, A.: Strict virtual call integrity checking for C
++ binaries. In: ASIACCS (2017)
24. Pawlowski, A., et al.: MARX: uncovering class hierarchies in C++ programs. In:
NDSS (2017)
25. Veen, V.V.D., et al.: A tough call: mitigating advanced code-reuse attacks at the
binary level. In: S&P (2016)
26. Kuznetsov, V., Szekeres, L., Payer, M., Candea, G., Sekar, R., Song, D.: Code-
pointer integrity. In: OSDI (2014)
27. Carlini, N., Barresi, A., Payer, M., Wagner, D., Gross, T.: Control-ﬂow bending:
on the eﬀectiveness of control-ﬂow integrity. In: USENIX Security (2015)
444
P. Muntean et al.
28. Goktas, E., et al.: Bypassing Clang’s SafeStack for fun and proﬁt. In: Blackhat
Europe (2016). https://goo.gl/zKMHzs
29. Dang, T., Maniatis, P., Wagner, D.: The performance cost of shadow stacks and
stack canaries. In: ASIACCS (2015)
30. Bernat, A.R., Miller, B.P.: Anywhere, any-time binary instrumentation. In: PASTE
(2011)
31. Andriesse, D., Chen, X., Veen, V.V.D., Slowinska, A., Bos, H.: An in-depth analysis
of disassembly on full-scale x86/x64 binaries. In: USENIX Security (2016)
32. Mycroft, A.: Lecture Notes (2007). https://goo.gl/F7tUZj
33. Lin, Z., Zhang, X., Xu, D.: Automatic reverse engineering of data structures from
binary execution. In: NDSS (2010)
34. Brumley, D., Jager, I., Avgerinos, T., Schwartz, E.J.: BAP: a binary analysis plat-
form. In: Gopalakrishnan, G., Qadeer, S. (eds.) CAV 2011. LNCS, vol. 6806, pp.
463–469. Springer, Heidelberg (2011). https://doi.org/10.1007/978-3-642-22110-
1 37
35. Fokin, A., Derevenets, Y., Chernov, A., Troshina, K.: SmartDec: approaching C++
decompilation. In: WCRE (2011)
36. Balakrishnan, G., Reps, T.: DIVINE: discovering variables IN executables. In:
Cook, B., Podelski, A. (eds.) VMCAI 2007. LNCS, vol. 4349, pp. 1–28. Springer,
Heidelberg (2007). https://doi.org/10.1007/978-3-540-69738-1 1
37. Caballero, J., Lin, Z.: Type inference on executables. CSUR 48, 35 (2016)
38. Lee, B., Song, C., Kim, T., Lee, W.: Type casting veriﬁcation: stopping an emerging
attack vector. In: USENIX Security (2015)
39. Andriesse, D., Slowinska, A., Bos, H.: Compiler-agnostic function detection in bina-
ries. In: Euro S&P (2017)
40. Bruening, D.: DynamoRIO. http://dynamorio.org/home.html
41. Davi, L., et al.: MoCFI: a framework to mitigate control-ﬂow attacks on smart-
phones. In: NDSS (2012)
42. Pappas, V., Polychronakis, M., Keromytis, A.D.: Transparent ROP exploit miti-
gation using indirect branch tracing. In: USENIX Security (2013)
43. Zhang, M., Sekar, R.: Control ﬂow integrity for COTS binaries. In: USENIX Secu-
rity (2013)
44. Mohan, V., Larsen, P., Brunthaler, S., Hamlen, K.W., Franz, M.: Opaque control-
ﬂow integrity. In: NDSS (2015)
45. Veen, V.V.D., et al.: Practical context-sensiticve CFI. In: CCS (2015)
46. Payer, M., Barresi, A., Gross, T.R.: Fine-grained control-ﬂow integrity through
binary hardening. In: Almgren, M., Gulisano, V., Maggi, F. (eds.) DIMVA 2015.
LNCS, vol. 9148, pp. 144–164. Springer, Cham (2015). https://doi.org/10.1007/
978-3-319-20550-2 8