# 《VScape - Assessing and Escaping Virtual Call Protections》 论文笔记
|
##### 译文声明
本文是翻译文章
译文仅供参考，具体内容表达以及含义原文为准。
## 一、简介
这篇论文介绍了一种面向伪对象编程（COOP）的 **加强攻击手法** ，称为 **COOPlus** 。对于那些不破坏 C++ ABI
的虚拟调用保护来说，有相当一部分的 虚拟调用保护手段易受 COOPlus 的攻击。
**符合以下三个条件的虚拟函数调用容易受到 COOPlus 的攻击：**
  * **不破坏虚函数调用的 ABI**
  * **不保证 C++ 对象 vtable 指针的完整性（即可以被修改）**
  * **允许在虚拟函数调用点上调用不同的函数**
COOPlus 本质上是 **代码重用** 攻击，它在目标虚拟函数调用点上调用 **符合类型但不符合上下文** 的虚拟函数。该调用可通过 C++ 语义感知的
**控制流完整性 CFI** 检测，但由于调用上下文不同，因此可能会造成进一步的利用。
除了 COOPlus 以外，该论文还提出了一种解决方案 **VScape** ，用来评估针对虚拟调用攻击保护的有效性。
论文 + 幻灯片 – [USENIX security
21](https://www.usenix.org/conference/usenixsecurity21/presentation/chen-kaixiang)
## 二、虚拟调用保护
在进一步学习 COOPlus 之前，我们需要了解一下现有的虚拟调用保护手法。
由于大部分 vtable 劫持攻击都涉及到 **纂改 vptr** ，因此一种简单的方式是 **确保 vptr 完整性** ，例如 **通用数据流完整性技术
DFI** 。但通常精度不高，且运行时开销较大，不太实用。
另一种方式是 **破坏掉了 C++ 的 ABI** ，例如有些保护方法将 vptr 放入单独的
元数据表中，并利用硬件功能（例如英特尔内存保护扩展插件）来确保元数据表的完整性，防止 vptr 被纂改。由于 ABI
被破坏，因此此类的保护方式会导致较为严重的兼容问题，实用性也不大。
第三种保护方式是， **检查每个虚拟调用目标的有效性** 。这个保护方式在之前阅读的论文 《SHARD: Fine-Grained Kernel
Specialization with Context-Aware Hardening》中也用到过，通过检查 vptr
指向位置的有效性，来确认调用的虚函数是否是正确的。
对于 CFI
技术来说，其解决方案均以安全性和实用性为目标。其中对于粗粒度（即不考虑C++语义或类型信息）的CFI方式来说，无法防止虚拟函数调用攻击；而细粒度 CFI
解决方案将会考虑更多的信息来提供更强的防御。
## 三、 COOP 攻击
在说明 COOPlus 攻击之前，我们必须先说明一下 COOP 攻击，以了解 COOPlus 攻击所提出的改进点。这篇论文中对 COOP
攻击描述的不多，因此我找了一下提出 COOP 的论文，大概的看了一下。
COOP，即面向伪对象的编程。这个攻击方式在 2015 年被首次提出，直至现在其论文引用量多达三百余次。
COOP 攻击受限于篇幅，将在另一篇文章中记录。
## 四、COOPlus 攻击
COOPlus 攻击的目的是为了 **绕过 C++语法感知的 CFI 解决方案** ，因此其他漏洞缓解措施（例如
ASLR、DEP等等）以及其他漏洞利用手法等暂时不做考虑。
与 COOP 攻击不同，COOPlus 调用的是 **类型兼容的虚拟函数** 来绕过更强的防御。
COOPlus 攻击的条件是：
  * **不保证 vptr 完整性**
  * **不破坏 C++ ABI**
  * **存在一个低危漏洞，例如一字节越界写 off-by-one**
该攻击的原理如下图所示：
> 一图胜过千言万语。
通俗的说，主要攻击过程概括如下：
假设有三个类，分别是 **基类 Base 类** ， **Base 派生类 S1** ， **另一个 Base 派生类 S2** 。其中 S1、S2
是否也是派生关系并不重要。只要 **确保 S1 类和 S2 类都是从基类 Base 类中派生出来** 的即可。
  * 寻找一个 **派生类 S1 调用 Base 基类虚函数** 的函数调用进行劫持
  * 利用给定的漏洞（例如一字节越界写）来修改 **派生类 S1** 的 vptr 为 **另一个 Base 类的派生类 S2 （简称 counterfeit 类） 的 vptr** 。  
> 即 **S1 类和 S2 类都是从基类 Base 类中派生出** 。
>
> 而对于虚函数调用来说，由于 vcall 肯定是 **通过基类指针** 进行调用，而 **S1 和 S2 都是基类的派生类** ，因此在 C++
> 语义敏感层面将通过检查。因为 **从基类 ptr 调用派生类虚函数是非常正常的事情** ，除非保护手法非常的细粒度，否则就无法检测出这类利用方式。
>
> 个人猜测正是因为这点使得 COOPlus 可以绕过相当一部分的 **C++ 语义敏感** 的保护手法。
  * 接下来，由于 victim 类的 vptr 被修改为 counterfeit 类（伪造类），因此 victim 类的所有虚函数调用最终都将调用到 counterfeit 类的虚函数。如上图所示，当被篡改 vptr 后的 victim 类对象调用虚函数 `func1` 时，它将不再调用 `S1::func1`，而是调用 `S2::func2`。由于 S2 和 S1 的类布局不同，因此可能会存在一些 S1 所没有的字段（例如图中的 `memberM`）。而 S1 调用了 S2 的 func1，因此将超过 S1 类对象的内存界限进行内存访问，最终造成内存越界操作。
当 victim 类对象的函数操作可以造成内存越界后（内存越界到的对象称为 **中继对象 Relay object**
），我们便可以利用这种内存越界来精心修改 Relay object 上的字段，例如 length 等等，来进一步 **放大漏洞危害**
（最初的漏洞是一字节越界写）。
对于不同的 counterfeit 函数，大致将其分为以下几类可利用的 vfgadget：
  * Out-of-bound Read 
    * Ld-Ex-PC：可以从目标内存中读取可控数据并 **加载进 PC**
    * Ld-AW-Const：可以将 **常量值** 写入目标内存
    * Ld-AW-nonCtrl：可以将 **非恒定且不可控的值** 写入目标内存
    * Ld-AW-Ctrl：可以将 **可控值** 写入目标内存
> 鉴于这四种 gadget 都分类至 OOB read，因此推测这里的 **目标内存** 应该指的是 victim Object
> 上的成员变量，或者特定其他堆空间等等。
  * Out-of-bound Write 
    * St-Ptr：可以将 **指针值** 写入中继对象。若中继对象可被操作，则可以用来绕过 ASLR 等防御手段
    * St-nonPtr：将 **非指针值** 写入中继对象。例如将一个超大值写入至中继对象的 length 字段，造成更大范围的 OOB-RW。
COOPlus 攻击无需用到较为高危的漏洞，只需用到简单的低危漏洞即可放大漏洞影响，实用性较好。由于 victim 基类和 counterfeit
派生类通常都在同一个模块中定义，因此其 vtable 的分布也较为相近。漏洞对 vptr 一字节的改动也有可能产生另一个兼容 vptr，并成功利用
COOPlus。
但即便如此，若原始漏洞的效果较低，那么其 COOPlus 可用利用原语的条目数量也会降低。例如一字节越界写只能修改 vptr 正负偏移 255