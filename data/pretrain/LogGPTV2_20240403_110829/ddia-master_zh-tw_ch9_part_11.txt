为了理解它的工作原理，我们必须更详细地分解这个过程：
1. 当应用想要启动一个分散式事务时，它向协调者请求一个事务 ID。此事务 ID 是全域性唯一的。
2. 应用在每个参与者上启动单节点事务，并在单节点事务上捎带上这个全域性事务 ID。所有的读写都是在这些单节点事务中各自完成的。如果在这个阶段出现任何问题（例如，节点崩溃或请求超时），则协调者或任何参与者都可以中止。
3. 当应用准备提交时，协调者向所有参与者传送一个 **准备** 请求，并打上全域性事务 ID 的标记。如果任意一个请求失败或超时，则协调者向所有参与者传送针对该事务 ID 的中止请求。
4. 参与者收到准备请求时，需要确保在任意情况下都的确可以提交事务。这包括将所有事务资料写入磁碟（出现崩溃、电源故障或硬碟空间不足都不能是稍后拒绝提交的理由）以及检查是否存在任何冲突或违反约束。透过向协调者回答 “是”，节点承诺，只要请求，这个事务一定可以不出差错地提交。换句话说，参与者放弃了中止事务的权利，但没有实际提交。
5. 当协调者收到所有准备请求的答复时，会就提交或中止事务作出明确的决定（只有在所有参与者投赞成票的情况下才会提交）。协调者必须把这个决定写到磁碟上的事务日志中，如果它随后就崩溃，恢复后也能知道自己所做的决定。这被称为 **提交点（commit point）**。
6. 一旦协调者的决定落盘，提交或中止请求会发送给所有参与者。如果这个请求失败或超时，协调者必须永远保持重试，直到成功为止。没有回头路：如果已经做出决定，不管需要多少次重试它都必须被执行。如果参与者在此期间崩溃，事务将在其恢复后提交 —— 由于参与者投了赞成，因此恢复后它不能拒绝提交。
因此，该协议包含两个关键的 “不归路” 点：当参与者投票 “是” 时，它承诺它稍后肯定能够提交（尽管协调者可能仍然选择放弃）；以及一旦协调者做出决定，这一决定是不可撤销的。这些承诺保证了 2PC 的原子性（单节点原子提交将这两个事件合为了一体：将提交记录写入事务日志）。
回到婚姻的比喻，在说 “我愿意” 之前，你和你的新娘 / 新郎有中止这个事务的自由，只要回复 “没门！” 就行（或者有类似效果的话）。然而在说了 “我愿意” 之后，你就不能撤回那个声明了。如果你说 “我愿意” 后晕倒了，没有听到司仪说 “你们现在是夫妻了”，那也并不会改变事务已经提交的现实。当你稍后恢复意识时，可以透过查询司仪的全域性事务 ID 状态来确定你是否已经成婚，或者你可以等待司仪重试下一次提交请求（因为重试将在你无意识期间一直持续）。
#### 协调者失效
我们已经讨论了在 2PC 期间，如果参与者之一或网路发生故障时会发生什么情况：如果任何一个 **准备** 请求失败或者超时，协调者就会中止事务。如果任何提交或中止请求失败，协调者将无条件重试。但是如果协调者崩溃，会发生什么情况就不太清楚了。
如果协调者在传送 **准备** 请求之前失败，参与者可以安全地中止事务。但是，一旦参与者收到了准备请求并投了 “是”，就不能再单方面放弃 —— 必须等待协调者回答事务是否已经提交或中止。如果此时协调者崩溃或网路出现故障，参与者什么也做不了只能等待。参与者的这种事务状态称为 **存疑（in doubt）** 的或 **不确定（uncertain）** 的。
情况如 [图 9-10](../img/fig9-10.png) 所示。在这个特定的例子中，协调者实际上决定提交，资料库 2 收到提交请求。但是，协调者在将提交请求传送到资料库 1 之前发生崩溃，因此资料库 1 不知道是否提交或中止。即使 **超时** 在这里也没有帮助：如果资料库 1 在超时后单方面中止，它将最终与执行提交的资料库 2 不一致。同样，单方面提交也是不安全的，因为另一个参与者可能已经中止了。
![](../img/fig9-10.png)
**图 9-10 参与者投赞成票后，协调者崩溃。资料库 1 不知道是否提交或中止**
没有协调者的讯息，参与者无法知道是提交还是放弃。原则上参与者可以相互沟通，找出每个参与者是如何投票的，并达成一致，但这不是 2PC 协议的一部分。
可以完成 2PC 的唯一方法是等待协调者恢复。这就是为什么协调者必须在向参与者传送提交或中止请求之前，将其提交或中止决定写入磁碟上的事务日志：协调者恢复后，透过读取其事务日志来确定所有存疑事务的状态。任何在协调者日志中没有提交记录的事务都会中止。因此，2PC 的 **提交点** 归结为协调者上的常规单节点原子提交。
#### 三阶段提交
两阶段提交被称为 **阻塞（blocking）**- 原子提交协议，因为存在 2PC 可能卡住并等待协调者恢复的情况。理论上，可以使一个原子提交协议变为 **非阻塞（nonblocking）** 的，以便在节点失败时不会卡住。但是让这个协议能在实践中工作并没有那么简单。
作为 2PC 的替代方案，已经提出了一种称为 **三阶段提交（3PC）** 的演算法【13,80】。然而，3PC 假定网路延迟有界，节点响应时间有限；在大多数具有无限网路延迟和程序暂停的实际系统中（见 [第八章](ch8.md)），它并不能保证原子性。
通常，非阻塞原子提交需要一个 **完美的故障检测器（perfect failure detector）**【67,71】—— 即一个可靠的机制来判断一个节点是否已经崩溃。在具有无限延迟的网路中，超时并不是一种可靠的故障检测机制，因为即使没有节点崩溃，请求也可能由于网路问题而超时。出于这个原因，2PC 仍然被使用，尽管大家都清楚可能存在协调者故障的问题。
### 实践中的分散式事务
分散式事务的名声毁誉参半，尤其是那些透过两阶段提交实现的。一方面，它被视作提供了一个难以实现的重要的安全性保证；另一方面，它们因为导致运维问题，造成效能下降，做出超过能力范围的承诺而饱受批评【81,82,83,84】。许多云服务由于其导致的运维问题，而选择不实现分散式事务【85,86】。
分散式事务的某些实现会带来严重的效能损失 —— 例如据报告称，MySQL 中的分散式事务比单节点事务慢 10 倍以上【87】，所以当人们建议不要使用它们时就不足为奇了。两阶段提交所固有的效能成本，大部分是由于崩溃恢复所需的额外强制刷盘（`fsync`）【88】以及额外的网路往返。
但我们不应该直接忽视分散式事务，而应当更加仔细地审视这些事务，因为从中可以汲取重要的经验教训。首先，我们应该精确地说明 “**分散式事务**” 的含义。两种截然不同的分散式事务型别经常被混淆：
* 资料库内部的分散式事务
  一些分散式资料库（即在其标准配置中使用复制和分割槽的资料库）支援资料库节点之间的内部事务。例如，VoltDB 和 MySQL Cluster 的 NDB 储存引擎就有这样的内部事务支援。在这种情况下，所有参与事务的节点都执行相同的资料库软体。
* 异构分散式事务
  在 **异构（heterogeneous）** 事务中，参与者是由两种或两种以上的不同技术组成的：例如来自不同供应商的两个资料库，甚至是非资料库系统（如讯息代理）。跨系统的分散式事务必须确保原子提交，尽管系统可能完全不同。
资料库内部事务不必与任何其他系统相容，因此它们可以使用任何协议，并能针对特定技术进行特定的最佳化。因此资料库内部的分散式事务通常工作地很好。另一方面，跨异构技术的事务则更有挑战性。
#### 恰好一次的讯息处理
异构的分散式事务处理能够以强大的方式整合不同的系统。例如：讯息伫列中的一条讯息可以被确认为已处理，当且仅当用于处理讯息的资料库事务成功提交。这是透过在同一个事务中原子提交 **讯息确认** 和 **资料库写入** 两个操作来实现的。借由分散式事务的支援，即使讯息代理和资料库是在不同机器上执行的两种不相关的技术，这种操作也是可能的。
如果讯息传递或资料库事务任意一者失败，两者都会中止，因此讯息代理可能会在稍后安全地重传讯息。因此，透过原子提交 **讯息处理及其副作用**，即使在成功之前需要几次重试，也可以确保讯息被 **有效地（effectively）** 恰好处理一次。中止会抛弃部分完成事务所导致的任何副作用。