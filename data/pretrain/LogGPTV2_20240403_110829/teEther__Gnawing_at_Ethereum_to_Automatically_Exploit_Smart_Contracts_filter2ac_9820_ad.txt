62.78%, do not even expose a single critical path.
In
other words, these contracts either do not contain any
CALL, CALLCODE, DELEGATECALL, or SELFDESTRUCT in-
structions, or do so only with non-attacker controllable
arguments. Further 8,049 (20.77%) contracts did have a
critical path, but we were not able to exploit it. While
some of these can be false negatives due to TEETHER’s
limitations, like the restricting the transaction sequences
to maximum three, or limitations of the underlying con-
straint solver, we believe the majority of these cases are
actually true negatives, as our deﬁnition of critical paths
is broad. We will discuss this issue in detail in Section 6.
Table 1 shows a breakdown of analysis results per
vulnerability type. While many contracts were found
vulnerable to CALL- or SELFDESTRUCT-based exploits,
only a small number of CALLCODE- and DELEGATECALL-
based exploits were found. However, also the number of
contracts having a critical CALLCODE or DELEGATECALL
path is signiﬁcantly lower compared with CALL or
SELFDESTRUCT. Interestingly, some contracts exposed
multiple vulnerabilities so that TEETHER generated a to-
tal of 855 exploits targeting 815 different contracts.
The 855 exploits can be grouped into two classes:
As the target contract can send further transactions to
other, third-party contracts during execution, the out-
come of an exploit might be dependent upon the results
returned by these transactions. We will call such ex-
ploits dependent. In contrast, in an independent exploit,
the execution of the target contract does not depend on
further transactions to non-attacker-controlled addresses.
134 (24.50%) of the 547 CALL-based exploits and 57
(19.13%) of the 298 SELFDESTRUCT-based exploits are
dependent, leaving 413 respectively 241 independent ex-
ploits. As TEETHER can only create path constraints for
a single contract, we will only consider independent ex-
ploits in the following.
As said before, many contract addresses share the
same contract code. Therefore, while the 664 indepen-
dent exploits only target 630 different contracts, in total,
1,731 contract accounts are affected.
5.2 Validation
To verify that the exploits generated by TEETHER do
in fact work as intended, for ethical and jurisdictional
reasons we refrain from testing them on the actual
blockchain. While there are no technical limitations to
buying Ether and performing the attacks on the main net-
work of Ethereum, we chose to evaluate the generated
exploits on private test networks only. We thus modeled
an attack on the actual blockchain as close as possible.
Since every contract account has its own storage that
can inﬂuence the execution, we validate every exploit
against every affected account individually, leading to a
total of 1,769 (exploit,account) combinations. To this
end, we create a fresh test Ethereum network (i.e., a sepa-
rate blockchain) containing three accounts: The contract
under test, a regular account to model the attacker, and a
third contract whose code will be used in CALLCODE and
DELEGATECALL exploits. The attacker’s account and the
contract account are given an initial balance of 100 and
10 Ether, respectively. Additionally, we also ensure that
the contract’s storage content in our test network agrees
with the one from our snapshot of the actual Ethereum
blockchain. The network is then run using the unmodi-
ﬁed ofﬁcial Ethereum Go client [5], whose scripting in-
terface will also be used to submit the exploit transac-
tions.
To reduce computation time by allowing tests on sev-
eral non-unique contracts at once, we computed the ex-
ploit assuming that the contract’s storage was set to zero.
The ﬁrst step in evaluation is thus to repeat TEETHER’s
constraint and exploit generation stages by supplying the
contract’s actual storage content. Unfortunately, creat-
ing an updated exploit fails for 84 (5.71%) of the CALL-
based and 28 (9.69%) of the SELFDESTRUCT-based ex-
ploits, which means that the generated exploit was a
false positive. Note that while the analysis performed by
TEETHER is sound in general, this assumption is the only
thing breaking soundness in our evaluation. We further
discuss this issue in Section 6
If generation of the updated exploit succeeded, we
submit its transaction to our test network. To prevent
transaction reordering, we wait until the miner processed
each transaction before submitting the next. After the
USENIX Association
27th USENIX Security Symposium    1327
successful exploit
failed exploit
failed update
Sum
CALL
1,301
85
84
1,470
CALLCODE
1
1
0
2
DELEGATECALL
7
1
0
8
SELFDESTRUCT
255
6
28
289
Total
1,564
93
112
1,769
(88.41%)
(5.26%)
(6.33%)
(100.00%)
Table 2: Validation results
last transaction has been processed, we check the ﬁnal
balance of the attacker’s account. As the attacker’s goal
is to extract Ether from the target account we call the ex-
ploit successful if the ﬁnal balance is greater than the 100
Ether that we preallocated to it. In order to minimize in-
terference due to processing fees we set the gas price in
our test network to 0, i.e., no processing fee is deducted.
The results for all tested 1,769 exploits are given in Ta-
ble 2. Overall, a large fraction (88.41%) of the generated
exploits works as expected: Once all exploit transactions
have been processed, the attacker has successfully stolen
Ether and increased their own balance.
Overall, 205 exploits (11.59%) failed for mainly two
reasons. As mentioned earlier, 112 (6.33%) of all ex-
ploits failed in the update stage due to the mismatch in
storage between the initial exploit generation and the ex-
ploit re-computation on the actual storage contents. To
better understand why the exploit did not succeed in
the remaining 93 cases, we further analyzed the con-
straints they induce. About half of these can be attributed
to differences between our test network and the actual
blockchain. For example, some of these exploits result
in constraints based on the current block number or the
balance of another account. As we base our test network
on a custom genesis block, the current block number will
be low when executing the contract, whereas the actual
Ethereum blockchain has been constantly growing since
2015 and currently contains over 5,000,000 blocks. Sim-
ilarly, as our test network only contains three accounts,
retrieving another account’s balance will always return 0,
as these accounts do not exist in our network.
5.3 Case Studies
In an effort to shed some light onto the cause of these vul-
nerabilities, we manually reviewed all vulnerable con-
tracts for which users had uploaded Solidity source code
to etherscan.io. However, as this was the case for only
44 (3%) contracts, these ﬁndings do not provide a com-
prehensive list of contract vulnerabilities, but rather serve
as a case-study. Finally, to protect contracts that are still
“live”, we only provide a description of the vulnerabili-
ties we found, but do not publish addresses of vulnerable
contracts.
Vulnerabilities we found in these contracts can be clas-
siﬁed into four categories:
1. Erroneous visibility: Per default, Solidity functions
are publicly accessible, unless marked with the key-
word internal. This can lead to unintended expo-
sure of contract functionalities. For example, one of
the 44 contracts implements a betting functionality
with a dedicated function to handle a draw. How-
ever, this function is not marked as internal and
can be called directly to transfer funds to arbitrary
addresses.
2. Erroneous constructor: In Solidity, a function with
the same name as the contract itself serves as the
contract’s constructor. In contrast to regular func-
tions, the constructor does not become part of the
contract’s compiled code and is only executed once
during contract creation. However, as Solidity does
not provide a special keyword to mark the con-
structor, functions that were meant to be construc-
tors can become regular functions due to ignoring
case-sensitivity, spelling mistakes, or oversight dur-
ing refactoring operations such as renaming. The
analyzed contracts contain examples of both, sim-
ple mistakes (e.g. Figure 8) and cases where the
contract was presumably renamed without renam-
ing the constructor (e.g. contract MyContract v1
with constructor MyContract).
3. Semantic confusion: Another class of vulnerable
contracts stem from different misunderstandings of
Ethereum’s execution model. For example, these
contracts seemingly confuse the contract’s total bal-
ance (this.balance) with the value held by the
current transaction (msg.value). Other cases ne-
glect the fact that a contract’s storage is publicly
readable and thus should not be used to store se-
crets.
4. Logic ﬂaws: The ﬁnal class of vulnerabilities we
observed is caused by logic ﬂaws. For example,
the excerpt given in Figure 9 is a ﬂawed imple-
mentation of the classical onlyOwner modiﬁer, but
has an inverted condition. Contrary to the intended
behaviour, this allows all marked functions to be
called by anyone but the owner.
Interestingly, the ﬁrst three of these categories can be
almost exclusively attributed to Solidity. While vulnera-
1328    27th USENIX Security Symposium
USENIX Association
address public owner;
function owned() {
}
modifier onlyOwner {
owner = msg.sender;
1 contract Owned {
2
3
4
5
6
7
8
9
10
11
}
// ...
}
;
if (msg.sender != owner) throw;
Figure 8: Erroneous constructor
onlyOwner() {
require(msg.sender != owner);
1 modifier
2
3
4
}
;
Figure 9: Flawed onlyOwner modiﬁer
bilities due to logic ﬂaws are also common in other do-
mains, others could be prevented through modiﬁcations
of Solidity. For example, making functions internal
by default would eliminate the ﬁrst category. Likewise,
the second category could be eliminated by introducing
a dedicated keyword for constructors.
6 Discussion
While the evaluation results are promising and our tool
has identiﬁed several hundreds of vulnerable contracts,
there are cases in which our current implementation fails
to create working exploits.
In this section we discuss
some of the underlying assumptions and limitations, both
of TEETHER and of the evaluation we performed.
6.1 Critical Path Deﬁnition
One potential limitation of TEETHER is the broad deﬁni-
tion of a critical path, speciﬁcally of potentially attacker-
controlled instructions. Our deﬁnition states that a crit-
ical path is a path that contains a slice of a critical in-
struction which contains at least one potentially attacker-
controlled instruction (cf. Deﬁnition 1). The inclusion of
SLOAD and MLOAD into the potentially attacker-controlled
instructions makes this criterion apply to many paths,
even though the corresponding storage or memory lo-
cations may never be writable by an attacker. This, in
turn, may cause irrelevant paths to be considered in the
path generation. While this does not pose a conceptual
problem, it can cause a signiﬁcant increase in compu-
tation time and thus lead to a larger number of time-
outs. This problem could be alleviated by performing
additional checks to match SLOAD and MLOAD to previ-
ous writes to create a more precise deﬁnition of critical
paths, thereby limiting the number of paths considered.
Inter-Contract Exploits
6.2
Furthermore, our current implementation of TEETHER
focuses on intra-contract exploits.
In fact, however, a
contract may call other contracts, and by supporting this
inter-contract communication one could ﬁnd additional
exploits. For example, the bug in Parity’s multi-signature
wallet [6] that allowed an attacker to take over multiple
wallets, splits core functionality between two contracts.
Whereas one contract acts as the actual Wallet, the other
is the support library. Only by combining these two con-
tracts TEETHER could ﬁnd an exploit of this documented
vulnerability. In fact, with all relevant code in a single
contract, our tool can indeed ﬁnd the vulnerability and
create a working exploit (see Appendix A).
6.3 Evaluation
As described in Section 5, our evaluation initializes the
contract’s storage to an empty state when we start search-
ing for exploits. This allows us to combine the analysis
of contracts that share the same code, reducing the num-
ber of tool runs from 784,344 to only 38,757 and has re-
duced the overall runtime by roughly factor 20. However,
this comes at the cost of imprecise results. As we already
have observed in 112 cases, an exploit that would work
against a contract with empty storage might not work
against the same contract with ﬁlled storage. Conversely,
our current evaluation might also miss exploits that only
work if the storage contains certain entries. However,
this is not a fundamental limitation of TEETHER and can
be solved by retrieving the actual storage state from the
real Ethereum blockchain, and reapplying it to our local
testbed. While it would require to treat all collapsed non-
unique contracts separately, as each address has its own
storage state, the results obtained would be sound.
7 Related Work
In this section we discuss related work in the areas of
smart contract analysis and automatic exploitation, and
how they relate to the work presented here.
7.1 Smart Contract Analysis
Analysis of smart contracts has been an area of active
research for the past few years. In a similar vein to the
work present herein, Luu et al. [20] presented OYENTE,
USENIX Association
27th USENIX Security Symposium    1329
a tool to detect certain vulnerabilities like transaction-
ordering dependence or reentrancy. However, their work
is substantially different from ours in two ways: Firstly,
OYENTE only considers a very speciﬁc set of vulnera-
bilities, many of which can also only be exploited by a
malicious miner or a by colluding with a miner collud-
ing. In contrast, we give a general vulnerability deﬁni-
tion that can be exploited by a much weaker attacker—in
fact, anyone with an Ethereum account. Secondly, the
goal of OYENTE is only to detect a vulnerability. This
means that the report generated by OYENTE have to be
painstakingly veriﬁed on a case-by-case basis. Our tool,
on the other hand, is designed to automatically provide
an exploit once a vulnerability is found. Validation is
then often as easy as executing the exploit transactions
and checking the ﬁnal balance.
Atzei et al. [7] provide a survey on attacks against
Ethereum smart contracts, giving a taxonomy and dis-
cussing attacks and ﬂaws that have been observed in the
wild. While not all attacks they consider provide a mone-
tary beneﬁt to the attacker, some of the attacks presented
therein are a special case of the vulnerabilities consid-
ered by TEETHER. For example, the multiplayer games
attack described in their paper can also be identiﬁed and
be exploited by our tool—fully automated.
In an effort to support further vulnerability analyses,
Matt Suiche has proposed a decompiler [24]. Also, Zhou
et al. [26] developed Erays, a tool for reverse engineering
smart contracts able to produce high-level pseudocode
from compiled EVM code. Yet in contrast to our work,
both of these rely on manual contract inspection (al-
though at a higher code abstraction).
Aside from security vulnerabilities, Delmolino et
al. [19] describe several pitfalls that can lead to logic
ﬂaws in smart contracts. In a similar vein, several works
consider the problem of designing good contracts, e.g.
Mavridou et al. [21] or Chen et al. [12].
Fr¨owis and B¨ohme [14] performed an analysis on