title:Dynamic Service Chaining with Dysco
author:Pamela Zave and
Ronaldo Alves Ferreira and
Xuan Kelvin Zou and
Masaharu Morimoto and
Jennifer Rexford
Dynamic Service Chaining with Dysco
Pamela Zave
AT&T Labs–Research
PI:EMAIL
Ronaldo A. Ferreira
UFMS
PI:EMAIL
Xuan Kelvin Zou
Google
PI:EMAIL
Masaharu Morimoto
NEC Corporation of America
PI:EMAIL
Jennifer Rexford
Princeton University
PI:EMAIL
ABSTRACT
Middleboxes are crucial for improving network security and per-
formance, but only if the right traffic goes through the right mid-
dleboxes at the right time. Existing traffic-steering techniques rely
on a central controller to install fine-grained forwarding rules in
network elements—at the expense of a large number of rules, a cen-
tral point of failure, challenges in ensuring all packets of a session
traverse the same middleboxes, and difficulties with middleboxes
that modify the “five tuple.” We argue that a session-level protocol is
a fundamentally better approach to traffic steering, while naturally
supporting host mobility and multihoming in an integrated fashion.
In addition, a session-level protocol can enable new capabilities like
dynamic service chaining, where the sequence of middleboxes can
change during the life of a session, e.g., to remove a load-balancer
that is no longer needed, replace a middlebox undergoing main-
tenance, or add a packet scrubber when traffic looks suspicious.
Our Dysco protocol steers the packets of a TCP session through
a service chain, and can dynamically reconfigure the chain for
an ongoing session. Dysco requires no changes to end-host and
middlebox applications, host TCP stacks, or IP routing. Dysco’s
distributed reconfiguration protocol handles the removal of proxies
that terminate TCP connections, middleboxes that change the size
of a byte stream, and concurrent requests to reconfigure different
parts of a chain. Through formal verification using Spin and ex-
periments with our Linux-based prototype, we show that Dysco is
provably correct, highly scalable, and able to reconfigure service
chains across a range of middleboxes.
CCS CONCEPTS
• Networks → Network protocols; Middle boxes / network
appliances; Session protocols; Network components;
KEYWORDS
Session Protocol; NFV; Verification; Spin.
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for profit or commercial advantage and that copies bear this notice and the full citation
on the first page. Copyrights for components of this work owned by others than ACM
must be honored. Abstracting with credit is permitted. To copy otherwise, or republish,
to post on servers or to redistribute to lists, requires prior specific permission and/or a
fee. Request permissions from permissions@acm.org.
SIGCOMM ’17, August 21–25, 2017, Los Angeles, CA, USA
© 2017 Association for Computing Machinery.
ACM ISBN 978-1-4503-4653-5/17/08...$15.00
https://doi.org/10.1145/3098822.3098827
ACM Reference format:
Pamela Zave, Ronaldo A. Ferreira, Xuan Kelvin Zou, Masaharu Morimoto,
and Jennifer Rexford. 2017. Dynamic Service Chaining with Dysco. In Pro-
ceedings of SIGCOMM ’17, Los Angeles, CA, USA, August 21–25, 2017, 14 pages.
https://doi.org/10.1145/3098822.3098827
1 INTRODUCTION
In the early days of the Internet, end-hosts were stationary devices,
each with a single network interface, communicating directly with
other such devices. Now most end-hosts are mobile, many are
multihomed, and traffic traverses chains of middleboxes such as
firewalls, network address translators, and load balancers. In this
paper, we argue that the “new normal” of middleboxes warrants a
re-examination of approaches, as has happened with mobility [49].
Most existing research proposals for middlebox insertion or
“service chaining” use a logically centralized controller to install
fine-grained forwarding rules in network elements, to steer traffic
through the right sequence of middleboxes [1, 9, 10, 18, 19, 36, 37,
50]. The many weaknesses of these solutions are a direct result of
their reliance on forwarding rules for traffic steering:
• They rely on real-time response from the central controller to
handle frequent events, including link failures, traffic fluctua-
tions, and the addition of new middlebox instances.
• They need network state that grows with the number of policies,
the difficulty of classifying traffic, the length of service chains,
and the number of instances per middlebox type.
• Updates to rules due to changes in policy, topology, or load may
change the paths of ongoing sessions, yet all packets of a session
must traverse the same middleboxes (“session affinity”).
• Fine-grained routing is inherently intra-domain. It is difficult
to outsource middleboxes to the cloud [40] or other third-party
providers [45], since the controller cannot control the entire path.
• Some middleboxes modify the “five-tuple” of packets in unpre-
dictable ways, so that forwarding rules matching packets going
into the middlebox might not match them on the way out.
• Some middleboxes classify packets to choose which middlebox
should come next. These middleboxes should be able to select
the service chain for their outgoing packets, which forwarding
by network elements does not allow them to do.
• Adding middleboxes to a secure session (e.g., TLS) is challeng-
ing without cooperation with the end-hosts to exchange the
information needed to decrypt and reencrypt the data [25].
• A multihomed host spreads traffic over multiple administrative
domains (e.g., enterprise WiFi and commercial cellular network),
yet some middleboxes need to see all the data in a TCP session
(e.g., for parental controls [38]). In the administrative domain
SIGCOMM ’17, August 21–25, 2017, Los Angeles, CA, USA
P. Zave et al.
where the paths converge, this requires coordination between
seemingly independent paths.
Some of these problems can be ameliorated. Research has shown
how to reduce forwarding state [10, 18, 37], maintain session affin-
ity [10, 18], identify packets whose headers have been changed
by a middlebox [9, 10, 37], install forwarding rules for modified
packets [10], and allow classification by middleboxes [9]. Yet all
these mechanisms add complexity, reduce rather than eliminate
some problems, and leave other problems untouched.
The principal contribution of this paper is a detailed exploration
of an opposing viewpoint, that session protocols might be a better
mechanism for service chaining. By session protocol we mean any
end-to-end protocol, one that establishes and controls communi-
cation between end-hosts. There are two major advantages to this
approach, which appear in direct contrast to the disadvantages of
routing/forwarding above:
• Many of the requirements for service chaining—session affinity,
handling modified five-tuples, selective control by middleboxes,
and convergence—apply to specific individual sessions. The need
for inter-domain control arises primarily because sessions often
cross domain boundaries. A session protocol operates on individ-
ual sessions rather than on aggregates of them, and can operate
end-to-end as well as separately in each domain.
• In the spirit of the end-to-end argument, all of the key functions
of a session protocol are performed by hosts—whether end-hosts
or middlebox hosts. Compared to the session state that is already
in these hosts, service chaining requires little additional state.
This provides inherent scalability, relieves the pressure on con-
troller capacity, and eliminates the need for network state to do
service chaining.
In response to the difficulties with fine-grained forwarding, emerg-
ing industry solutions are already replacing fine-grained forwarding
with encapsulation, so that forwarding through the service chain
is by destination addresses alone [6, 16, 26]. This is a step in the
right direction, but these solutions are intra-domain and some are
proprietary. In contrast, we are interested in service chaining that
can work across domains and can be added straightforwardly to
existing deployments. Session protocols already provide effective
and efficient support for mobility [3, 4, 24, 29, 30, 34, 41] and multi-
homing [17, 31], and we complete the exploration of this “design
pattern” by focusing on middleboxes.
Given the obvious flexibility of signaling in a session protocol,
it might be predicted that use of a session protocol for service
chaining would provide entirely new opportunities for optimization
and network management. This is indeed the case. We introduce a
session protocol that does dynamic reconfiguration, which means
changing the middleboxes in a service chain mid-session. Dynamic
reconfiguration could be useful in many situations (see also [20]):
• After directing a request to a backend server, a load balancer
could remove itself from the path of the request. The load bal-
ancer is no longer a possible point of failure, and there is no need
for custom optimizations, like direct server return for response
traffic to bypass the load balancer [33].
• A Web proxy cache, ad-inserting proxy, or intrusion detection
system could remove itself after its work for a session is done.
be redirected through compression middleboxes [13].
redirected through a packet scrubber for further analysis.
• When suspicious traffic is identified, ongoing sessions could be
• When the network is congested, ongoing video sessions could
• A middlebox that is overloaded or undergoing maintenance,
could be replaced with another of the same type (e.g., see [11, 39]).
• When an end-host moves to a new location, a middlebox could
be added temporarily to buffer and redirect traffic from the old
location. In addition, the old middleboxes in the service chain
could be replaced with new ones closer to the new location.
Note that removing a middlebox removes the host machine from
the path entirely, rather than having the kernel simply bypass
the application. This improves performance and relability, while
conserving middlebox resources for sessions that actually need
them.
In this paper we describe the Dysco session protocol for service
chaining with dynamic reconfiguration. Dysco is an extension to
TCP (already a session protocol by our definition) requiring no
alterations to end-host applications, middlebox applications, host
TCP stacks, or IP routing. Because service chains need not span
the entire TCP session, Dysco can be deployed incrementally and
across untrusted domains, with conventional security techniques.
We have focused on TCP because of its dominance. Although
the Dysco approach will not work for connectionless protocols
such as UDP, Dysco does not interfere with forwarding in any
way. Therefore existing forwarding solutions can continue to steer
all traffic through essential middleboxes such as firewalls, while
co-existing with Dysco for more-demanding TCP service chaining.
In addition to the design, implementation, and measurement of
a Dysco prototype, this paper makes the following contributions:
Highly distributed control: Service chaining and dynamic re-
configuration of the service chain can be performed completely
under the control of middlebox hosts. Autonomous operation is
valuable not only because it avoids controller bottlenecks, but also
because sometimes only the middlebox itself knows which mid-
dlebox should be next in the chain for a session, or when its job
within a session has been completed. During dynamic reconfigura-
tion, Dysco manages possible contention between different Dysco
agents (representing different middleboxes) attempting to reconfig-
ure overlapping segments of the same session at the same time.
Generalized dynamic reconfiguration: For maximum gener-
ality, dynamic reconfiguration of a service chain works even if a
middlebox being deleted has modified the TCP session, most notably
by acting as a session-terminating proxy. It also works if the mid-
dlebox has changed the size of a byte stream (e.g., by transcoding
or adding/removing content). There is no inherent need for packet
buffering except in the case of server migration, when server state
must be frozen before it can be transferred. Such packet buffering,
when needed, can be performed exclusively by hosts.
Protocol verification: Although the code for dynamic recon-
figuration is compact, it was difficult to design, and covers many
subtle cases. It would be wrong to assume it is correct without some
clear evidence. We have this evidence because we designed the pro-
tocol using the modeling language of the model-checker Spin [15],
and used Spin to verify it at every stage of design. By presenting
an automated proof of correctness, we show how to increase the
Dynamic Service Chaining with Dysco
SIGCOMM ’17, August 21–25, 2017, Los Angeles, CA, USA
Figure 1: A TCP session with its Dysco subsessions.
power of session protocols without sacrificing our confidence in
them.
Transparent support for middleboxes: Our prototype includes
a Linux kernel module that intercepts packets in the network device,
so it works with unmodified applications and a wide range of mid-
dleboxes. The kernel module supports Linux namespaces, which
makes it suitable for virtualized environments (e.g., Docker [7]) and
experimentation with Mininet [23]. Experiments show that session
setup is fast, steady-state throughput is high, and disruption during
reconfiguration is small.
2 DYSCO ARCHITECTURE
In Dysco, agents running on the hosts establish, reconfigure, and
tear down service chains, relying only on high-level policies and
basic IP routing. In this section, we introduce the Dysco architecture
and give an overview of the protocol; in §3, we expand on how
Dysco can reconfigure an existing service chain.
2.1 Basic service chaining
The basic Dysco concept is that a service chain for a TCP session
is a chain of middleboxes and subsessions, each connecting an end-
host and a middlebox or two middleboxes. A service chain is set up
when the TCP session is set up. The service chain sometimes has
the same endpoints as the TCP session, as shown in Figure 1. Each
subsession is identified by a five-tuple, just as the TCP session is.
The unmodified end-host applications and middleboxes see packets
with the original header of the TCP session; as such, Dysco works
with existing application-layer protocols. As usual, congestion con-
trol and retransmission are performed end-to-end (see Figure 2). At
the same time, Dysco agents rewrite packet headers for transmis-
sion so that packets traveling between hosts have the subsession
five-tuple in their headers. In this way, normal forwarding steers
packets through the service chain, and there is no encapsulation to
increase packet size.
Establishment of the service chain: Establishment of the ser-
vice chain in Figure 1 begins when the Dysco agent at host A
intercepts the outbound SYN packet. If the SYN packet matches a
policy predicate, the agent will get an address list for the service
chain such as [B, C]. The agent then allocates local TCP ports for the
subsession with the next middlebox. The agent rewrites the packet
header with its own address as the source IP address, the address
of the next specified middlebox as the destination IP address, and
the new allocated TCP ports as source and destination TCP ports.
The agent also adds to the payload of the SYN packet the original
five-tuple of the session header and the address list [B, C, D]. It
Figure 2: Data flow inside hosts with Dysco agents.
creates a dictionary entry to map the original session to the new
subsession, and another entry to map the subsession to the session
on the reverse path. It then transmits the modified SYN packet.
When the Dysco agent at host B receives the SYN packet from
the network, it checks to see if the payload carries an address list. If
it does, the agent removes the address list from the payload (storing
it), and rewrites the packet header with the session information
also stored in the payload. The agent also creates dictionary entries
to map the subsession to the session and vice-versa, and delivers
the packet to the middlebox application. When the SYN packet