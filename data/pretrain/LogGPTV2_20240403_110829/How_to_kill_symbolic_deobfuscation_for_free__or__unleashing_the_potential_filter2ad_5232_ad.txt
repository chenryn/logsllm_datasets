making Tigress a tool of choice for the systematic evaluation of
deobfuscation methods [5, 8, 37].
Protections. We mainly consider tractable path-oriented protec-
tions and select both a new SVP scheme (For) and an existing
non-SVP scheme (Split), inserted in a robust-by-design way. We
vary the number of forking points per path (parameter k).
We also consider standard protections: Virtualization (up to 3
levels), arithmetic encoding and flattening [48]. Previous work [5]
has shown that nested virtualization is the sole standard protection
useful against DSE. Our results confirm that, so we report only
results about virtualization (other results partly in Appendix).
8.2 Datasets
We select small and medium programs for experiments as they repre-
sent the worst case for program protection. If path-oriented protections
2 Download at https://bit.ly/2wYSEDG
ACSAC ’19, December 9–13, 2019, San Juan, PR, USA
Mathilde Ollivier, Sébastien Bardin, Richard Bonichon, and Jean-Yves Marion
can slow down DSE analysis substantially on smaller programs, then
those protections can only give better results for larger programs.
Dataset #1. This synthetic dataset from Banescu et al 3 [5] offers a
valuable diversity of functions and has already been used to assess
resilience against DSE. It has 48 C programs (between 11 and 24 lines
of code) including control-flow statements, integer arithmetic and
system calls to printf . We exclude 2 programs because reaching full
coverage took considerably longer than for the other 46 programs
and blurred the overall results. Also, some programs have only a
1-byte input space, making them too easy to brute force (Goal 2).
We turn them into equivalent 8-byte input programs with same
number of paths – additional input are not used by the program, but
latter protections will rely on them. The maximum time to obtain
full coverage on the 46 programs with KLEE is 33s, mean time is
2.34s (Appendix B).
Dataset #2. The second dataset comprises 7 larger realistic pro-
grams, representative of real-life protection scenarios: 4 hash func-
tions (City, Fast, Spooky, md5), 2 cryptographic encoding functions
(AES, DES) and a snippet from the GRUB bootloader. Unobfuscated
programs have between 101 and 934 LOCs: KLEE needs at most
33.31s to explore all paths, mean time is 8s (Appendix B).
8.3 Impact on Dynamic Symbolic Execution
Protocol. To assess the impact of protections against DSE, we
consider the induced slowdown (time) of symbolic execution on an
obfuscated program w.r.t. its original version. Fore more readable
results, we only report whether DSE achieves its goal or times out.
For Path Exploration (Goal 1), we use programs from Datasets
#1 and #2, add the protections and launch KLEE untils it reports
full coverage or times out – 3h for Dataset #1, or a 5,400× average
slowdown, 24h for Dataset #2, or a 10,000x average slowdown.
For Secret finding (Goal 2), we modify the programs from both
datasets into “secret finding” oriented code (e.g.,win / lose) and set
up KLEE to stop execution as soon as the secret is found. We take
the whole Dataset #2, but restrict Dataset #1 to the 15 programs
with 16-byte input space. We set smaller timeouts (1h for Dataset
#1, 3h and 8h for Dataset #2) as the time to find the secret with
KLEE on the original programs is substantially lower (0.3s average).
Table 3: Impact of obfuscations on DSE
Transformation
(#TO/#Samples)
Dataset #1
Dataset #2
Goal 1
3h TO
0/46
1/46
5/46
1/46
4/46
18/46
2/46
30/46
46/46
Goal 2
1h TO
0/15
0/15
2/15
0/15
0/15
2/15
0/15
8/15
15/15
Goal 1
24h TO
0/7
0/7
1/7
0/7
1/7
3/7
0/7
3/7
7/7
Virt
Virt ×2
Virt ×3
SPLIT (k = 10)
SPLIT (k = 13)
SPLIT (k = 17)
FOR (k = 1)
FOR (k = 3)
FOR (k = 5)
Results & Observations. Table 3 shows the number of timeouts
during symbolic execution for each obfuscation and goal. For ex-
ample, KLEE is always able to cover all paths on Dataset #1 against
Goal 2
3h TO
0/7
0/7
0/7
0/7
1/7
2/7
0/7
2/7
7/7
Goal 2
8h TO
0/7
0/7
0/7
0/7
0/7
1/7
0/7
1/7
7/7
3https://github.com/tum-i22/obfuscation-benchmarks
simple Virtualization (0/46 TO) – the protection is useless here,
while it fails on ≈ 40% of the programs with Split (k = 17), and
never succeeds with For (k = 5).
As expected, higher levels of protections (more virtualization
layers or more forking points) result in better protection. Yet, results
of Sec. 8.4 will show that while increasing forking points is cheap,
increasing levels of virtualization is quickly prohibitive.
Virtualization is rather weak for both goals – only 3 levels of
virtualization manage some protection. For performs very well for
both goals: with k = 3 and Dataset #1, For induces a timeout for
more than half the programs for both goals, which is significantly
better than Virt×3. With k = 5, all programs timeout. In between,
Split is efficient for Goal 1 (even though it requires much higher
k than For) but not for Goal 2 – see for example Dataset #1 and
k = 17: 39% timeouts (18/46) for Goal 1, only 13% (2/15) for Goal 2.
Other (unreported) results. All standard protections from Ti-
gress we used turns out to be ineffective against DSE – for example
Flattening and EncodeArithmetic on Dataset#1 slows path explo-
ration by a maximum factor of 10, which is far from critical. Search
heuristics obviously do not make any difference in the case of Path
Exploration (Goal 1). Still, DFS tends to perform slightly better than
BFS and NURS against Split in the case of Secret Finding (Goal 2).
No other difference is visible. Experiments with three binary-level
DSE engines supported by different SMT solvers (Binsec [26] with
Boolector[14], Triton [38] and Angr [43] with Z3[27]) are in line
with those reported here.
Regarding Write, most state-of-the-art tools (KLEE, Binsec, Tri-
ton) do not support self-modification. Angr has a specific option,
however after testing we found out it did not consider the Write
pattern as symbolic thus missing the majority of paths (Goal 1) and
failing to recover the secret (Goal 2).
Conclusion. As already stated in the literature, standard protec-
tions such as nested virtualization are mostly inefficient against DSE
attacks. Path-oriented protections are shown here to offer a stronger
protection. Yet, care must be taken. Non-SVP path protections such
as Split do improve over nested virtualization (Split with k = 13
is roughly equivalent to Virt ×3, with k = 17 it is clearly superior),
but they provide only a weak-to-mild protection in the cases of
Secret Finding (Goal 2) or large time outs. On the other hand, SVP
protections (represented here by For) are able to discard all DSE
attacks on our benchmarks for both Path Exploration and Secret
Finding with only k = 5, demonstrating a protection power against
DSE far above those of standard and non-SVP path protections.
To conclude, path-oriented protections are indeed a tool of choice
against DSE attacks (RQ1), much stronger than standard ones
(RQ4). In addition, SVP allows to predict the strength difference of
these protections (RQ4), against Coverage or Secret Finding.
8.4 Impact on Runtime Performance
Protocol. We evaluate the cost of path-oriented protections by
measuring the runtime overhead (RO) and the (binary-level) code
size increase (CI) of an obfuscated program w.r.t. its original version.
We consider also Write and two variants of For– its recursive
encoding REC (Sec. 7.1) and the more robust P2 encoding (Sec. 8.5),
as well as the untractable word-level For scheme (Sec. 5), coined
WORD.
How to Kill Symbolic Deobfuscation for Free
(or: Unleashing the Potential of Path-Oriented Protections)
Table 4: Impact of obfuscations on runtime performance
Table 5: Robustness of path-oriented protections
ACSAC ’19, December 9–13, 2019, San Juan, PR, USA
Transformation
Dataset #1
Dataset #2
RO
RO
CI
×1.5
×2.5
×4
×1.0
×1.0
×1.5
×1.0
×1.0
×1.0
×1.5
×1.0
×1.0
×1.0
×1.0
×2.1
×1.5
×15
×1.6 · 103
×1.2
×1.2
×1.5
×1.0
×1.1
×1.3
×1.5
×1.3
×3.0
×2.6 · 103
×1.0
×1.0
×1.7
×5.1
×362
×1.0
×1.0
×1.1
×1.0
×1.0
×1.1
×1.2
×1.1
×2.7
×2.1 · 103
×1.0
×1.0
Virt
Virt ×2
Virt ×3
SPLIT (k = 10)
SPLIT (k = 13)
SPLIT (k = 50)
FOR (k = 1)
FOR (k = 3)
FOR (k = 5)
FOR (k = 50)
FOR (k = 5) P2
FOR (k = 5) REC
FOR (k = 1) WORD
WRITE (k = 5)
WRITE (k = 50)
CI
×1.4
×2.1
×3.0
×1.0
×1.0
×1.0
×1.0
×1.0
×1.0
×1.1
×1.0
×1.0
×1.0
×1.0
×1.2
Results & Observations. Results are shown in Table 4 as average
values over all programs in the datasets. As expected, nested virtu-
alization introduces a significant and prohibitive runtime overhead
(three layers: ×1.6· 103 for Dataset #1 and ×362 for Dataset #2), and
each new layer comes at a high price (from 1 to 2: between ×3 and
×10; from 2 to 3: between ×70 and ×100). Moreover, the code size is
also increased, but in a more manageable way (still, at least ×3 for
three layers). On the other hand, Split, For and Write introduce
only very low runtime overhead (at most ×1.3 on Dataset #1 and
×1.1 on Dataset #2). No significant code size increase is reported
even for k = 50 for larger programs, however we predictably see
some code size increase for small programs of dataset #1. Regarding
variants of For, P2 does not show any overhead w.r.t. For, while
the recursive encoding REC comes at a higher price. Finally, as
predicted by our framework, WORD is intractable.
Conclusion. As expected, tractable path-oriented protections in-
deed yield only a very slight overhead, both in terms of time or code
size (RQ2), and improving the level of protection (k) is rather cheap,
while nested virtualization comes at a high price (RQ4). Coupled
with results of Sec. 8.3, it turns out that path-oriented protections
offer a much better anti-DSE protection than nested virtualization
at a runtime cost several orders of magnitude lower. Also, the code
size increase due to path-oriented protections seems compatible
with strict memory requirements (e.g., embedded systems) where
it is not the case for nested virtualization.
8.5 Robustness to taint and slice attacks
Protocol. We consider the clang & GCC compilers (many simpli-
fications including slicing), the industrial-strength Frama-C static
code analyzer (both its Taint and Slice plugins together with precise
interprocedural range analysis) as well as Triton (featuring taint-
ing) and KLEE. We focus on the 8 programs from dataset #1 with
16-byte input space and all programs from dataset #2. We remove
programs with 1-byte input space from dataset #1 because we added
fake inputs that would obviously not resist analysis. This issue is