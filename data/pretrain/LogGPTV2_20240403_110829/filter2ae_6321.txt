# PE-AFL漏洞挖掘技术原理分析

##### 译文声明
本文是翻译文章，译文仅供参考。具体内容表达及含义以原文为准。

在2019年，我撰写了许多关于fuzzer原理及其实践的文章。经过一段时间的沉寂后，最近又开始将重心转向了模糊测试（fuzzing）。在研究PE-AFL的过程中，我记录了一些笔记，并在此分享给大家，希望可以有所交流。

PE-AFL是一种通过静态插桩实现针对Windows闭源程序的覆盖率引导型模糊测试工具，由Lucas Leong在BlueHat IL 2019上发布。

### 使用方法
使用方法相对直观易懂。例如，若要对`msjet40.dll`进行模糊测试，首先在IDA中打开该文件，运行`ida_dumper.py`生成`msjet40.dll.dump.txt`文件。接着执行`python pe-afl.py -m msjet40.dll msjet40.dll.dump.txt`命令，得到插桩后的`msjet40.instrumented.dll`文件。用此文件替换原有的`msjet40.dll`，然后就可以利用修改后的AFL.exe进行模糊测试了。

目前发布的版本支持IDA 7.2，但不支持64位程序的模糊测试。此外，由于插桩操作针对的是由Visual Studio编译的二进制文件，因此对于其他编译器生成的目标文件可能无法正常工作。

### ida_dumper.py解析
`ida_dumper.py`用于从目标DLL或EXE文件中提取关键信息。它会生成一个包含以下数据的`.dump.txt`文件：
- **rip_inst列表**：暂时未被使用。
- **idata列表**：可执行的idata段。
- **bb列表**：基本块（basic block）识别方法为记录条件跳转指令的下一条指令地址和跳转目标地址，最终去除重复项并排序。
- **relative字典**：键为条件跳转指令地址，值为跳转目标地址、操作码、操作数长度以及总长度。
- **stk_frame字典**：查找特定代码模式如`mov edi,edi`、`push ebp`等，并记录相关地址与偏移量。
- **code_loc字典**：标记混合代码区域中的代码位置。

### pe-afl.py解析
`pe-afl.py`主要负责调用`instrument.py`中的`inject_code`函数向每个基本块注入代码。具体实现包括初始化阶段的操作如移除DOS头、数字签名等，以及创建新的.cov段和.tex2段来存储额外的数据。

### instrument.py详解
在`instrument.py`中，核心任务是在文本段内插入监控代码，并处理由此引起的地址偏移问题。这涉及到扩展短跳转指令为长跳转指令，更新重定位表等步骤。

#### 关键函数
- **get_text_diff** 和 **get_data_diff**：计算插桩前后代码或数据在文件中位置的变化。
- **get_relative_diff**：根据跳转指令及其目标地址的位置，返回两者之间的偏移量。

这些函数帮助确保即使在进行了大量代码插入之后，程序仍能正确执行。

### 应用场景
除了用于模糊测试外，我认为这项技术也可能适用于恶意软件分析领域。面对复杂的混淆手段时，我们可能需要调整乱序代码或删除冗余指令等，而这里提供的代码或许能够提供一些有用的参考。

总之，虽然我尚未深入研究其实际效果如何，但我相信对于那些已经接触过类似工具的人来说，相互交流经验将是非常有价值的。