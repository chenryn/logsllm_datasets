对于漏洞利用，以指向shellcode的指针来填充缓冲区就足够了。 SfnINOUTNCCALCSIZE的返回地址将被覆盖
并被劫持执行
漏洞将生成由攻击者控制的lParam结构的异步复制
44
框架
CVE-2018-8589带来更大的发现，因为它是更大的开发框架的一部分
• 杀毒软件逃逸
• 可靠地选择最合适的漏洞利用方式
• 利用DKOM控制安装rootkit
框架目的
45
框架 - 杀毒软件逃逸
漏洞利用程序会检查emet.dll是否存在，如果它不存在，则使用trampolines执行所有功能
•
在系统库的文本部分中搜索模式
•
使用小工具构建虚假堆栈并执行函数
/* build fake stack */
push    ebp
mov
ebp, esp
push    offset gadget_ret
push    ebp
mov
ebp, esp
push    offset gadget_ret
push    ebp
mov
ebp, esp
…
/* push args*/
…
/* push return address*/
push    offset trampilne_prolog
/* jump to function */
jmp
eax
46
框架 - 可靠性
可以多次触发漏洞利用
为了可靠的利用，需要适当的互斥
否则，执行多个漏洞提权实例将导致BSOD
使用CreateMutex()函数可能会引起怀疑
47
框架 - 可靠性
内存块的存在意味着漏洞正在运行
创建Mutex
48
框架 - 可靠性
这个框架可以带有多个漏洞利用程序（嵌入或从远程资源接收）
漏洞利用程序执行Windows操作系统版本检查以查找目标版本是否支持此漏洞程序
这个框架可尝试不同漏洞利用方法，直到找到合适的
每个漏洞利用都提供了可执行内核shellcode的接口
嵌入式漏洞利用的最大值
我们已经观察到了4种不同的漏洞
49
框架 - 军械库
CVE-2018-8589
CVE-2015-2360
CVE-2018-8611
CVE-2019-0797
?
?
?
目前我们找到了4个，但最多可能有10个？
50
案例 3
CVE-2018-8611
tm.sys驱动程序中的竞争条件
代码是为了支持下一个OS版本 :
•
Windows 10 build 15063
•
Windows 10 build 14393
•
Windows 10 build 10586
•
Windows 10 build 10240
•
Windows 8.1
•
Windows 8
•
Windows 7
新的漏洞利用瞄准了以下OS版本:
•
Windows 10 build 17133
•
Windows 10 build 16299
允许在Chrome和Edge中的沙箱逃逸，因为系统调用过滤缓解技
术不适用于ntoskrnl.exe系统调用。
51
CVE-2018-8611
tm.sys驱动程序实现内核事务管理器（KTM）
它用于处理错误：
•
将更改作为事务执行
•
如果出现问题，则回滚更改到文件系统或注册表
如果您正在设计新的数据存储系统，它还可用于协调更改
52
CVE-2018-8611
Resource manager objects
Transaction objects
Enlistment objects
KTM Objects 
Transaction manager objects
Transaction ：事务 - 数据操作的集合
Resource manager ：资源管理器 - 管理可由事务处理操作更新的数据资源的组件
Transaction manager ：事务管理器 - 它处理事务客户端和资源管理器的通信
它还跟踪每个事务的状态（没有数据）
Enlistment ：登记 - 资源管理器和事务之间的关联
53
CVE-2018-8611
为了最大化的利用漏洞，漏洞利用程序首先创建一个命名管道并打开它进行读写
然后它会创一组新的对象 transaction manager objects, resource manager objects, transaction objects
Transaction 1
Transaction 2
54
CVE-2018-8611
Transaction 1
Transaction 2
55
CVE-2018-8611
漏洞利用程序会创建多个线程，并将它们绑定到单个CPU核心
Thread 1 在循环中调用NtQueryInformationResourceManager
Thread 2 尝试执行一次NtRecoverResourceManager
56
CVE-2018-8611
漏洞利用发生在第三个线程内
该线程执行NtQueryInformationThread以使用RecoverResourceManager来获取最后一个线程系统调用
成功执行NtRecoverResourceManager意味着已发生竞争条件
在此阶段，在先前创建的命名管道上执行WriteFile将导致内存损坏
57
CVE-2018-8611
CVE-2018-8611是函数TmRecoverResourceManagerExt中的竞争条件
在功能启动时检查ResourceManager是否在线
检查登记是否已完成
但是，在处理所有登记之前，可能会发生ResourceManager的破坏
…
58
CVE-2018-8611
Microsoft通过以下更改修复了漏洞：
•
检查登记状态是否已删除
•
检查ResourceManager是否处于联机状态且被添加
59
CVE-2018-8611
我们控制了登记对象，那么如何利用它？
这里并没有太多的代码路径
如果通过检查，我们能够AND任意值。
似乎很难利用。
60
CVE-2018-8611
我们控制了登记对象，那么如何利用它？
这里并没有太多的代码路径
我们可以创建我们自己的对象（PVOID）(v10 + 64)
61
CVE-2018-8611
62
CVE-2018-8611
Dispatcher objects:
nt!_KEVENT
nt!_KMUTANT
nt!_KSEMAPHORE
nt!_KTHREAD
nt!_KTIMER
…
dt nt!_KTHREAD
+0x000 Header           : _DISPATCHER_HEADER
…
dt nt!_DISPATCHER_HEADER
+0x000 Lock             : Int4B
+0x000 LockNV
: Int4B
+0x000 Type             : UChar
+0x001 Signalling
: UChar
…
63
CVE-2018-8611
dt nt!_KOBJECTS
EventNotificationObject = 0n0
EventSynchronizationObject = 0n1
MutantObject = 0n2
ProcessObject = 0n3
QueueObject = 0n4
SemaphoreObject = 0n5
ThreadObject = 0n6
GateObject = 0n7
TimerNotificationObject = 0n8
TimerSynchronizationObject = 0n9
Spare2Object = 0n10
Spare3Object = 0n11
Spare4Object = 0n12
Spare5Object = 0n13
Spare6Object = 0n14
Spare7Object = 0n15
Spare8Object = 0n16
ProfileCallbackObject = 0n17
ApcObject = 0n18
DpcObject = 0n19
DeviceQueueObject = 0n20
PriQueueObject = 0n21
InterruptObject = 0n22
ProfileObject = 0n23
Timer2NotificationObject = 0n24
Timer2SynchronizationObject = 0n25
ThreadedDpcObject = 0n26
MaximumKernelObject = 0n27
64
CVE-2018-8611
提供伪造的 EventNotificationObject
65
CVE-2018-8611
在当前线程处于等待状态时，我们可以从用户态修改调度程序对象
基于_KWAIT_BLOCK的地址，我们可以计算_KTHREAD的地址
0: kd> dt nt!_KTHREAD
+0x000 Header           : _DISPATCHER_HEADER
+0x018 SListFaultAddress : Ptr64 Void
+0x020 QuantumTarget
: Uint8B
+0x028 InitialStack
: Ptr64 Void
+0x030 StackLimit
: Ptr64 Void
+0x038 StackBase
: Ptr64 Void
+0x040 ThreadLock
: Uint8B
...
+0x140 WaitBlock
: [4] _KWAIT_BLOCK
+0x140 WaitBlockFill4   : [20] UChar
+0x154 ContextSwitches : Uint4B
...
_KTHREAD = _KWAIT_BLOCK - 0x140
66
CVE-2018-8611
修改调度程序对象，构建SemaphoreObject
0: kd> dt nt!_KMUTANT
+0x000 Header           : _DISPATCHER_HEADER
+0x018 MutantListEntry : _LIST_ENTRY
+0x028 OwnerThread
: Ptr64 _KTHREAD
+0x030 Abandoned        : UChar
+0x031 ApcDisable
: UChar
mutex->Header.Type = SemaphoreObject;
mutex->Header.SignalState = 1;
mutex->OwnerThread = Leaked_KTHREAD;
mutex->ApcDisable = 0;
mutex->MutantListEntry = Fake_LIST;
mutex->Header.WaitListHead.Flink = 
0: kd> dt nt!_KWAIT_BLOCK
+0x000 WaitListEntry
: _LIST_ENTRY
+0x010 WaitType
: UChar
+0x011 BlockState
: UChar
+0x012 WaitKey
: Uint2B
+0x014 SpareLong
: Int4B
+0x018 Thread           : Ptr64 _KTHREAD
+0x018 NotificationQueue : Ptr64 _KQUEUE
+0x020 Object           : Ptr64 Void
+0x028 SparePtr
: Ptr64 Void
67
CVE-2018-8611
waitBlock.WaitType = 3;
waitBlock.Thread = Leaked_KTHREAD + 0x1EB;
0: kd> dt nt!_KWAIT_BLOCK
+0x000 WaitListEntry
: _LIST_ENTRY
+0x010 WaitType
: UChar
+0x011 BlockState
: UChar
+0x012 WaitKey
: Uint2B
+0x014 SpareLong
: Int4B
+0x018 Thread           : Ptr64 _KTHREAD
+0x018 NotificationQueue : Ptr64 _KQUEUE
+0x020 Object           : Ptr64 Void
+0x028 SparePtr
: Ptr64 Void
Call to GetThreadContext(…) will make 
KeWaitForSingleObject continue execution
使用WaitType = 1 向WaitList添加一个线程
68
CVE-2018-8611
伪造的 Semaphore 对象将传递给 KeReleaseMutex，它是 KeReleaseMutant 的包装器
Check for current thread will be bypassed because we were able to leak it
69
CVE-2018-8611
由于精心设计的 WaitBlock 的 WaitType 值为 3， WaitBlock 将被传递给 KiTryUnwaitThread
70
CVE-2018-8611
KiTryUnwaitThread 是一个很大的函数，但最有趣的事情在函数末尾
这被设置为 Leaked_KTHREAD + 0x1EB
我们可以将 Leaked_KTHREAD + 0x1EB + 0x40设置为0！
71
CVE-2018-8611
KTHREAD + 0x22B
0: kd> dt nt!_KTHREAD
...
+0x228 UserAffinity
: _GROUP_AFFINITY
+0x228 UserAffinityFill : [10] UChar
+0x232 PreviousMode
: Char
+0x233 BasePriority
: Char
+0x234 PriorityDecrement : Char
72
CVE-2018-8611
一个字节就彻底统治它们
73
CVE-2018-8611
由于能够使用NtReadVirtualMemory，进一步提升权限和安装rootkit是非常简单的
可能的缓解措施：
•
核心调度程序对象的强化
•
对PreviousMode进行密码验证
滥用调度程序对象似乎是一种有价值的开发技术
•
非常感谢Microsoft快速的处理我们的研究发现。
•
零日似乎有很长的寿命。 被精心设计的漏洞能够绕过缓解措施。
•
攻击者知道，如果漏洞可以被发现，安全厂商就一定会发现漏洞。 因此他们也在谋求改变以实现更好的杀毒
软件逃逸。
•
我们发现的两个漏洞是针对Windows 10的最新版本，但是大多数零日都是针对旧版本的。 这意味着缓解措
施正在发挥作用。
•
竞争条件漏洞正在逐渐增加。 我们发现的五个漏洞中有三个是竞争条件漏洞。 非常好的模糊分析器
（Bochspwn的重现？）或静态分析？ 我们将看到更多像这样的漏洞。
•
Win32k锁定和系统调用过滤是有效的，但攻击者切换到利用ntoskrnl中的错误。
•
我们使用调度程序对象和PreviousMode揭示了一种新技术。
74
结论
Momigari: 最新的Windows操作系统内核在野漏洞概述
Twitter: @antonivanovm
Anton Ivanov
Kaspersky Lab
Twitter: @oct0xor 
Boris Larin
Kaspersky Lab
答疑 ?