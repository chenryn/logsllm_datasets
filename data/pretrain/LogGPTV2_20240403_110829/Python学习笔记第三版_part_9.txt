操作
字典不是序列类型，不⽀持序号访问，以主键为条件读取、新增或删除内容。
>>> x = dict(a = 1)
>>> x["a"] # 读取。
1
>>> x["b"] = 2 # 修改或新增。
>>> x
{'a': 1, 'b': 2}
!79
学习笔记 . 第三版
>>> del x["a"] # 删除。
>>> x
{'b': 2}
当访问不存在主键时，会引发异常。可先以 in、not in 语句判断，或⽤ get ⽅法返回预设
的默认值参数。
>>> x = dict(a = 1)
>>> x["b"]
KeyError: 'b'
>>> "b" in x
False
>>> x.get("b", 100) # 主键 b 存在，返回默认值 100。
100
>>> x.get("a", 100) # 主键 a 存在，返回字典内容。
1
⽅法 get 的默认值仅返回，不影响字典内容。但某些时候，我们还需向字典插⼊默认值。
⽐如⽤字典存储多个计数器，那么在第⼀次取值时延迟初始化是很有必要的。在字典内有
零值内容代表了该计数器被使⽤过，没有则⽆法记录该⾏为。
>>> x = {}
>>> x.setdefault("a", 0) # 如果有 a，那么返回。否则新增 a = 0 键值。
0
>>> x
{'a': 0}
>>> x["a"] = 100
>>> x.setdefault("a", 0)
100
字典不⽀持加法、乘法、⼤⼩等运算，但可⽐较内容是否相同。
!80
学习笔记 . 第三版
>>> {"b":2, "a":1} == {"a":1, "b":2}
True
视图
与早期版本某些⽅法复制并返回内容列表不同，Python 3 默认以视图（view object）⽅式
关联字典内容。如此，即避免了复制开销，还能同步观察字典变化。
>>> x = dict(a = 1, b = 2)
>>> ks = x.keys() # 主键视图。
>>> "b" in ks # 判断主键是否存在。
True
>>> for k in ks: print(k, x[k]) # 利利⽤用视图迭代字典。
a 1
b 2
>>> x["b"] = 200 # 修改字典内容。
>>> x["c"] = 3
>>> for k in ks: print(k, x[k]) # 视图能同步变化。
a 1
b 200
c 3
字典没有类似元组那样的只读版本，⽆论直接传递引⽤还是复制品，都存在弊端。直接引
⽤导致接收⽅存在修改内容的风险，⽽复制品又仅是⼀次性快照，⽆法获知字典本⾝变化。
视图则不同，它能同步读取字典内容，却⽆法修改。且可选择不同粒度的内容传递，如此
可将接收⽅限定为指定模式下的观察员。
def test(d): # 传递键值视图（items），只能读取，⽆无法修改。
for k, v in d:
print(k, v)
>>> x = dict(a = 1)
>>> d = x.items()
!81
学习笔记 . 第三版
>>> test(d)
a 1
另⼀⽅⾯，视图⽀持集合运算，弥补了字典功能上的不⾜。
>>> a = dict(a = 1, b = 2)
>>> b = dict(c = 3, b = 2)
>>> ka = a.keys()
>>> kb = b.keys()
>>> ka & kb # 交集：在 a、b 中同时存在。
{'b'}
>>> ka | kb # 并集：在 a 或 b 中存在。
{'a', 'b', 'c'}
>>> ka - kb # 差集：仅在 a 中存在。
{'a'}
>>> ka ^ kb # 对称差集：仅在 a 或仅在 b 中出现，相当于 “并集 - 交集”。
{'a', 'c'}
利⽤视图集合运算，可简化⼀些操作。例如 update 只更新，不新增。
>>> a = dict(a = 1, b = 2)
>>> b = dict(b = 20, c = 3)
>>> ks = a.keys() & b.keys() # 并集，也就是 a 中必须存在的主键。
>>> a.update({k: b[k] for k in ks}) # 利利⽤用并集提取待更更新内容。
>>> a
{'a': 1, 'b': 20}
扩展
在标准库中，有⼏个字典的扩展类型可供使⽤。
!82
学习笔记 . 第三版
默认字典（defaultdict）类似 setdefault 包装。当主键不存在时，调⽤构造参数提供的⼯⼚
函数返回默认值。
将字典直接作为对外接⼜时，⽆法保证⽤户是否会调⽤ setdefault 或 get ⽅法。那么，默认字典
的内置初始化⾏为就好于对⽤户做额外要求。
>>> d = collections.defaultdict(lambda: 100)
>>> d["a"]
100
>>> d["b"] += 1
>>> d
{'a': 100, 'b': 101}
与 dict 内部实现⽆关，有序字典（OrderedDict）明确记录主键⾸次插⼊次序。
任何时候都要避免依赖内部实现，或者说遵循 “显式优于隐式” 规则。
>>> d = collections.OrderedDict()
>>> d["z"] = 1
>>> d["a"] = 2
>>> d["x"] = 3
>>> for k, v in d.items(): print(k, v)
z 1
a 2
x 3
与前⾯所说不同，计数器（Counter）对于不存在的主键返回零，但不会新增。
可通过继承并重载 __missing__ ⽅法新增键值。
>>> d = collections.Counter()
>>> d["a"]
0
>>> d["b"] += 1
!83
学习笔记 . 第三版
>>> d
Counter({'b': 1})
链式字典（ChainMap）以单⼀接⼜访问多个字典内容，其⾃⾝并不存储数据。读操作按
参数顺序依次查找各字典，但修改操作（新增、更新、删除）仅针对第⼀字典。
可利⽤链式字典设计多层次上下⽂（context）结构。
⼀个合理的上下⽂类型，需具备两个基本特征。⾸先是继承，所有设置可被调⽤链后续函数读取。
其次是修改仅针对当前和后续逻辑，不应向⽆关的⽗级传递。如此，链式字典查找次序本⾝就是
继承体现。⽽修改操作被限制在当前第⼀字典，⾃然也不会影响⽗级字典的同名主键设置。当调
⽤链回溯时，利⽤ parents 属性抛弃 child 字典，也就等于丢弃了被修改的⽆关数据。当然，还
可进⼀步封装 cancel、timeout 操作，通过 __getattribute__ 拦截访问并引发异常。
>>> a = dict(a = 1, b = 2)
>>> b = dict(b = 20, c = 30)
>>> x = collections.ChainMap(a, b)
>>> x["b"], x["c"] # 按顺序命中。
2 30
>>> for k, v in x.items(): print(k, v) # 遍历所有字典。
b 2
c 30
a 1
>>> x["b"] = 999 # 更更新，命中第⼀一字典。
>>> x["z"] = 888 # 新增，命中第⼀一字典。
>>> x
{'a': 1, 'b': 999, 'z': 888}, {'b': 20, 'c': 30}
2.7 集合
集合⽤于存储⾮重复对象。所谓⾮重复，除不是同⼀对象外，还包括值不能相等。
!84
学习笔记 . 第三版
判重公式
(a is b) or (hash(a) == hash(b) and a == b)
-------- -------------------------------
如果不是同⼀对象，那么先判断哈希值，然后⽐较内容。受限于哈希算法，不同内容可能返回相
同哈希值（哈希碰撞），那么就有必要继续⽐较内容是否相同。
为什么先⽐较哈希值，⽽不直接⽐较内容？⾸先，相⽐⼤多数内容（例如字符串），整数类型哈
希值⽐较运算，性能⾼得多。其次，哈希值不同，内容肯定不同，没有继续⽐较内容的必要。
>>> a = 1234
>>> b = 1234
>>> a is b # a、b 内容相同，但⾮非同⼀一对象。
False
>>> s = {a} # 创建集合，初始化元素 a。
>>> b in s # 使⽤用内容相同的 b 进⾏行行判重。
True
按操作⽅式，集合分可变（set）和不可变（frozenset）两个版本，其内部实现完全相同。
⽤数组哈希表存储对象引⽤，这也就要求元素必须为可哈希类型。
set small table
entry table
k key, hash
k key, hash
!85
学习笔记 . 第三版
查找元素对象时，先通过算法定位数组索引，继⽽⽐较哈希值和内容。
集合对象⾃带⼀个长度为 8 的⼩数组（small table），这对多数简单集合运算有益，避免额外内
存分配。只有超出容量限制时，才分配更⼤数组内存（entry table）。集合使⽤频率不及列表和
字典，内部没采⽤缓存复⽤策略。其实现⽅式决定了⽆序存储，标准库也没有提供有序实现。
创建
和字典⼀样使⽤⼤括号语法，但初始化数据⾮键值对。
>>> type({}) # 没有初始化值，表示创建⼀一个空字典。
dict
>>> type({"a":1}) # 字典: 键值对
dict
>>> type({1}) # 集合
set
可调⽤类型构造⽅法创建，或推导式。
>>> set((1, "a", 1.0))
{1, 'a'}
>>> frozenset(range(3))
frozenset({0, 1, 2})
>>> {x + 1 for x in range(6) if x % 2 == 0}
{1, 3, 5}
直接在不同版本间⾃由转换。
>>> s = {1}
>>> f = frozenset(s)
>>> set(f)
{1}
!86
学习笔记 . 第三版
操作
⽀持⼤⼩、相等运算符。
>>> {1, 2} > {2, 1}
False
>>> {1, 2} == {2, 1}
True
⼦集判断不能使⽤ in、not in 语句，它仅⽤来检查是否包含某个特定元素。
>>> {1, 2} >> {1, 2, 3} >= {1, 2} # 超集: issuperset
True
>>> {1, 2} in {1, 2, 3} # 判断是否包含 {1, 2} 单⼀一元素。
False
集合作为⼀个初等数学概念，其重点⾃然是并差集运算。合理使⽤这些操作，可简化算法
筛选逻辑，使其具备更好的可读性。
交集：同时属于 A、B 两个集合。
并集：A、B 所有元素。
差集：仅属于 A，不属于 B。
对称差集：仅属于 A，加上仅属于 B，相当于 “并集 - 交集”。
>>> {1, 2, 3} & {2, 3, 4} # 交集: intersection
{2, 3}
>>> {1, 2, 3} | {2, 3, 4} # 并集: union
{1, 2, 3, 4}
>>> {1, 2, 3} - {2, 3, 4} # 差集: difference
{1}
!87
学习笔记 . 第三版
>>> {1, 2, 3} ^ {2, 3, 4} # 对称差集: symmetric_difference
{1, 4}
集合运算还可与 update 联合使⽤。
>>> x = {1, 2}
>>> x |= {2, 3} # update
>>> x
{1, 2, 3}
>>> x = {1, 2}
>>> x &= {2, 3} # intersection_update
>>> x
{2}
删除操作 remove 可能引发异常，可改⽤ discard。
>>> x = {2, 1}
>>> x.remove(2)
>>> x.remove(2)
KeyError: 2
>>> x.discard(2)
自定义类型
⾃定义类型虽是可哈希类型，但默认实现并不⾜以完成集合去重操作。
class User:
def __init__(self, uid, name):
self.uid = uid
self.name = name
>>> issubclass(User, collections.Hashable)
True
!88
学习笔记 . 第三版
>>> u1 = User(1, "user1")
>>> u2 = User(1, "user1")
>>> s = set()
>>> s.add(u1)
>>> s.add(u2)
>>> s
{, }
根本原因是默认实现的 __hash__ ⽅法返回随机值，⽽ __eq__ 仅⽐较⾃⾝。为符合逻辑需
要，须重载这两个⽅法。
class User:
def __init__(self, uid, name):