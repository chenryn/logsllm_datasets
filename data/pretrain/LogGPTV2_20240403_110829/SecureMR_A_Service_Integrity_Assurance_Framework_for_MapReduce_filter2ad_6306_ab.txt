t
t
i
n
g
g
,
,
V
V
o
o
N
l
e
T
a
C
s
M
k
o
S
S
r
G
G
E
e
e
a
d
d
m
i
x
p
m
c
c
p
e
u
u
r
r
i
C
C
o
o
e
c
t
e
e
r
t
u
e
t
r
m
o
p
p
r
u
u
r
s
R
o
o
S
S
k
V
m
e
e
E
e
e
d
r
u
x
i
c
c
p
p
f
u
u
u
u
e
c
i
r
r
t
e
e
e
e
c
i
r
u
r
n
o
t
g
g
T
P
a
C
C
P
2
d
d
n
a
a
r
e
p
a
r
e
m
5
a
.
s
s
C
t
o
r
e
e
M
e
r
i
f
y
.
V
1
0
R
R
R
A
R
R
…
………
d
d
u
u
u
u
a
e
e
P
d
d
e
e
h
r
r
e
e
c
c
s
e
e
e
c
c
B12
1
B
B
n
F
……
…
S
D
M
M
M
a
a
p
a
……
……
a
p
p
p
s
A
A
B
e
e
r
M
M
M
P
h
(a) SecureMR Architecture Design.
(b) SecureMR Communication Design.
Fig. 2. SecureMR Design Overview.
Veriﬁer running in a reducer collaborates with Secure Manager
to verify a mapper’s intermediate result. For simplicity, we
quote all components using names without Secure in the
following sections, for example Manager, Scheduler, Task
Executor and so on.
Communication Design. Figure 2(b) shows how the entities
in SecureMR communicate with each other to provide security
protection for MapReduce. Communications among them are
further organized into two protocols: Commitment protocol
and Veriﬁcation protocol. In Figure 2(b), communications from
1 to 5 form the commitment protocol while communications
from 6 to 10 form the veriﬁcation protocol.
In the commitment protocol, to avoid checking the interme-
diate results directly (which is expensive), mappers only send
commitments (which will be described in detail later) to the
master, which can be used to detect inconsistency efﬁciently.
However, this introduces another vulnerability. Mappers may
send the master the right commitments but the wrong results
to reducers. For this reason, we further ask reducers to check
the consistency between the commitment and the result in the
veriﬁcation protocol. Note that this does not add much extra
effort to the reducer as it has to retrieve the intermediate result
for data processing anyway.
In the following two sections, we will discuss the details
of communications between the ﬁve security components of
SecureMR, which happen in the commitment and veriﬁcation
protocols.
B. Commitment Protocol
Map
Loc sig
KpubM
Map
P1 (cid:258) Pr sigM
Fig. 3. The Commitment Protocol.
76
As mentioned in Section III-B, the master is a trusted entity.
However, since the intermediate result is usually tremendous, it
is impractical to require the master to check all intermediate re-
sults generated by different map tasks in different jobs, which
will overload the master and lead to low system performance.
Thus, instead of examining intermediate results directly, the
master requires mappers to generate commitments for their
intermediate results, and then check commitments [13].
1) Protocol design: Since we assume that the DFS provides
data integrity protection, we do not discuss the communi-
cations between mappers and the DFS. Figure 3 shows the
communications between a mapper and the master in the
commitment protocol. The speciﬁc steps are described as
follows.
Assign. The Scheduler in the master sends the Assign
message to the Task Executor in a mapper to assign a map task
to the mapper. Regarding task duplication, the Scheduler may
assign the same map task to different mappers. For example,
in Figure 2(b), MA and MB are assigned the same map
task. The Assign message includes a monotonically increasing
identity IDM ap of a map task and an input data block location
DataLoc, which is signed by the master and encrypted using
KpubM , the public key of the mapper. After the Task Executor
receives the task assignment message,
the Task Executor
decrypts and veriﬁes the signature of the message. Then, the
Task Executor reads an input block according to DataLoc from
the DFS. In Figure 2(b), since MA and MB receive the same
task, they both read the same data block B2 from the DFS.
Commit. After the mapper processes the input block, the
Committer of the mapper makes a commitment to the master
by generating a hash value for each partition of its intermediate
result and signing those hash values. We use {...}sigM to
denote a signed message of a mapper. When the Manager
of the master receives the commitment, the Manager veriﬁes
the signature using the mapper’s public key KpubM . If the
Manager has received more than one commitments for the
same map task from different mappers, the Manager will
compare new commitment with an old one to see if they are
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 13:04:27 UTC from IEEE Xplore.  Restrictions apply. 
consistent with each other.
Note that in this paper, we focus on expose suspicious
activities. How to exactly pinpoint malicious ones is the next
step and some existing techniques may be applied [24].
2) Protocol analysis: In this protocol, since the task assign-
ment message is signed by the master and encrypted using
the mapper’s public key, the integrity and conﬁdentiality of
the Assign message is well protected. It also ensures that the
mapper is the only entity that can decrypt the Assign message
and the master is the only entity that can create it. In this
case, malicious mappers cannot know task assignments of
other good mappers or arbitrarily assign fake tasks to a mapper
to launch DoS attacks. Furthermore, to prevent replay attacks
which send old task assignments, a monotonically increasing
identity IDM ap is associated with each map task, which is
automatically generated using timestamp or sequence number
by the Scheduler. The Task Executor in the mapper records
the IDM ap for the last map task that it processed. In this
way, the Task Executor can determine if a task assignment is
an old one by comparing the IDM ap with the latest recorded
IDM ap. Regarding the Commit message, the integrity of the
commitment is assured since the Commit message is signed
using the mapper’s private key. Moreover, IDM ap is needed
so that the master knows which map task this commitment is
for.
Reduce
sig
KpubR
M
pubM
Map
Pi
Reduce
M sig KpubR
M
Seq
Map
Reduce sigR
Map
Data sigM
Map
Data sigM
M
pubM
Map
Pi
Reduce
M sig
M
pubR
Map
Reduce sig
Fig. 4. The Veriﬁcation Protocol.
C. Veriﬁcation Protocol
In the veriﬁcation protocol, reducers further help the master
to verify if intermediate results generated by mappers are
consistent with commitments submitted to the master. The
veriﬁcation protocol is built on existing MapReduce com-
munication mechanisms. There are no additional messages
introduced to MapReduce.
1) Protocol design: Figure 4 shows how the master, a
mapper, and a reducer communicate with each other in the
veriﬁcation protocol. We illustrate each step as follows.
Assign. The master signs the Assign message and encrypts
it using KpubR, the public key of a reducer. In the message,
IDReduce is a monotonically increasing identity of a reduce
task, and P i indicates the partition of intermediate results
that the reducer will process. When the Task Executor in the
77
reducer receives the task assignment, the Task Executor ﬁrst
veriﬁes the integrity and authenticity of the task assignment.
Then, the Veriﬁer of the reducer will wait for notiﬁcations
from the Manager.
Notify. When the Manager receives the completion event
with a commitment from the Committer of a mapper, the
Master sends a notiﬁcation to the Veriﬁer of each reducer,
which includes the mapper’s address ADM ,
the mapper’s
public key KpubM , IDM ap, the ticket T icketM for the mapper
signed by the master and the hash value HP i for the P i
partition committed by the Committer. The ticket T icketM is
used for data request authentication in the Request message.
Request. After the Veriﬁer in a reducer gets notiﬁed, the
Veriﬁer sends a data request to the Committer of the mapper,
which includes the ticket T icketM as evidence of an authentic
data request authorized by the master, the reducer’s public key
KpubR, a sequence number ReqSeq and P i which indicates
which partition is requested.
Response. After the Committer veriﬁes the authenticity
of the request by verifying the ticket from the master and
the reducer’s signature, the mapper sends a response to the
Veriﬁer, which includes IDM ap, P i,
the data Data and
HData, the hash value of Data. To verify the integrity of
the response, the Veriﬁer ﬁrst veriﬁes the signature in the
Response message, then regenerates a hash value H ′
Data for
the data, and compares HData with H ′
Data to make sure that
the data is not tampered during the Response communication.
Finally, the Veriﬁer compares H ′
Data with HP i committed to
the master to check if any inconsistency occurs.
Report. When the Veriﬁer detects an inconsistency, the
Veriﬁer sends two signatures as evidence to the Manager
to report the inconsistency. After the Manager receives and
veriﬁes the two signatures, the Manager can compare HData
with HP i to conﬁrm the reported inconsistency.
2) Protocol analysis: Similar to the commitment protocol,
the reduce task assignment mechanism prevents both DoS and
replay attacks against reducers. However, in the veriﬁcation
protocol, a mapper faces DoS attacks when others request
data from it. To countermeasure this kind of DoS attacks,
the mapper needs to authenticate data requests from reducers.
The data request authentication is achieved by requiring that
a reducer shows a ticket from the master. If the mapper sees a
ticket at the ﬁrst time, the mapper can make sure that the
request must come from an authorized reducer who holds
the ticket issued by the master. However, if the ﬁrst attempt
of data request fails somehow, attackers may get the ticket
by eavesdropping the communications between the mapper
and the reducer. In this case, since the mapper will record
the latest request sequence number ReqSeq associated with a
ticket, the mapper will check if this data request is an old
one by comparing the two ReqSeq numbers when the mapper
receives another data request with the same ticket. In this way,
replay attacks can be defeated.
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 13:04:27 UTC from IEEE Xplore.  Restrictions apply. 
Commit
Verify
Master
Master
M
Mapper
R d