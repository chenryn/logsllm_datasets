$ write tinothy tty3
Hello Tin1
消息的接收方会看到如下信息。
Message from christinelserver01 on tty2 at 14:11 ...
Hello Tin!
EOF
26
接收方可以看到消息是由哪个用户在哪个终端上发送的。也可以给消息加上一个时间截。注
意，消息的末尾出现了EOF，表示文件结束，这可以让接收方知道消息已经全部显示出来了。
跨门接收到消息之后，接收方经常需要按回车键来重新获得命令行提示符。
---
## Page 583
568第26章一些小有意思的脚本
现在，你可以发送消息了！接下来要使用这些命令创建脚本。
26.1.2创建脚本
使用脚本发送消息有助于解决一些潜在的问题。首先，如果系统中有很多用户，要找出你想
发送消息的那个用户可是个苦差事！你还得确定这个用户是否启用了消息功能。另外，脚本还能
够提高效率，可以让你一步就把消息快速发送给特定的用户。
1.检查用户是否登录
第一个问题就是得让脚本知道要给谁发送消息。这一点很容易实现，只需要在执行脚本是加
上一个参数就行了。对于确定特定用户是否登录的问题，可以利用who命令，脚本代码如下。
 Deternine if user is logged om1
Logged_on=$ (who 1grep -i -n 1 $1 1gavk *(print $1)*)
在上面的代码中，who命令的结果被管接人grep命令（参见第4章）。grep命令使用选项-i
来忽略大小写，用户名使用大小写字母都可以。grep命令中还包含了选项-m1，这是为了防止
用户多次登人系统。grep命令要么什么都不输出（如果用户还没有登录），要么生成用户首次登
录的信息。输出的信息被传给gawk命令（参见第19章）。gawk命令只返回第一个字段，要么为空，
要么是用户名。该命令最终的输出结果被保存在变量lcgged_on中。
窍门在有些Linux发行版中（例如oUbuntu），可能并没有双认安装gawk。可以输入apt-get
installgawk进行安装。还可以在第9章中找到更多有关软件包安装的信息。
变量logged_on中可能什么都没有（如果用户没有登录），也可能包含用户名，可以对变量
内容进行测试，并根据测试结果进行相应的处理，
1f [ -z $1ogged_on ]
thef
echo *$1 la not logged on.*
echo *Exiting script..*
#
ex1 t
利用ir语句和test命令来测试变量1ogged_on是否为空。如果变量为空，通过echo命令提
醒脚本用户指定的用户尚未登录系统，然后使用exit命令退出脚本。如果指定用户已经登入系
统，则变量logged_on中包含了该用户的用户名，脚本继续执行。
在下面的例子中，用户Charlie被作为参数传给shell脚本。这个用户尚未登人系统。
S -/mu.sh Charlie
Exiting script..
Char1le is not logged on.
---
## Page 584
26.1发送消息
569
代码工作良好！现在你不用埋头在who命令的输出中翻看某个用户是否登录系统，用这个脚
本就可以帮你搞定。
2.检查用户是否接受消息
下一个重要事项是确定登录用户是否接受消息。这部分脚本的工作方法和确定用户是否登录
的那部分脚本非常像。
 Determine if user a1lows messsging1
(($ qutad) , xne6 1 TS [ α- - dax 1 - oua) $=paxo[[e
if [ $alloved ! *+* ]
Ehen
echo *$1 does not alloving messaging-*
exit
ecbo
*Exiting script..,*
注意，这次我们不仅使用了who命令，还加上了-T选项。如果允许接收消息的话，这会在用
户名后显示+，否则会显示一个-。who命令的结果会被管接人grep和gawk，只提取出消息接收
人，并将其存储在变量allowed中。最后使用ir语句测试消息接收人是否被设置了+。如果没有
设置+，则提示脚本用户并退出脚本。如果消息接收人能够接收消息，脚本继续向下执行。
要检验这部分脚本，需要一个已登录且不接受消息的用户参与测试。用户Samantha目前关闭
接收消息功能
S ./mu,sh Sanantha
Samant.ha does not allowing messaging.
Exiting script...
测试结果和预期的一样。有了这部分脚本，就再也不需要手动检查消息功能是否启用了。
3.检查是否包含要发送的消息
待发送的消息会被作为脚本参数。因此，还要检查mu.sh脚本是否将消息作为了参数。要测
试这个消息参数，和之前一样，需要在脚本代码中加人if语句。
 Determine if a message was included:
then
if [ -z $2 ]
echo *lo message parameter included.*
echo *Exiting script,..*
26
exit.
fi
我们使用一个已登录且启用了消息功能的用户来测试这部分脚本，不过在测试中并没有加人
要发送的消息。
---
## Page 585
570
第26章一些小有意思的脚本
$. /mu sh Plmothy
No message paraneter Lncluded.
Exiting acript...
这正是我们需要的！现在脚本已经完成了这些前期检查工作，可以开始执行它的主要任务了：
发送消息。
4.发送简单的消息
在发送消息前，必须识别并将用户当前终端保存在变量中。who、grep和gawk再次出马。
 Send message to user:
utermLnal=$ (who 1 gzrep - -m 1 $1 1 gawk * (pr1nt $2)*)
要发送消息，需要使用echo和write。
echo $2 1 write Slogged_on Suternina1
#
因为write是一个交互式命令，所以它必须从管道中接收消息，这样脚本才能正常工作。echo
命令用来将保存在s2中的消息发送到sTDOUT，然后再通过管道传给write命令。1ogged_on变
量保存了用户名，uterminal变量保存了用户当前的终端。
现在来测试一下，通过脚本向指定用户发送一条简单的消息。
S./mu.sh Pimothy test
用户Timothy在自己的终端上接收到了以下消息。
Hessage Eron chrlatine9server01 on tty2 at 10:23 ..-
t.e8/L
BOP
搞定！现在可以通过脚本向系统中的其他用户发送一个单词的消息了。
5.发送长消息
你通常可不会愿意只向其他用户发送一个单词的消息。让我们来试试用当前的脚本发送更多
内容的消息。
 ./mu.sh Pinothy Boee la coming. Look busy.
用户Timothy在自己的终端上接收到了以下消息。
Message fron chrlatine9sexver01 on tty2 at 10:24 ...
B08R
BOP
看来不行。只有消息中第一个单词Boss被成功发送了。这是因为脚本使用了参数（参见第14
章）。bash shell使用空格来区分不同的参数。因为消息中有空格，所以消息中的每个单词都被视
为一个不同的参数。必须修改脚本来解决这个问题。
---
## Page 586
26.1发送消息
571
对此，shift命令（参见第14章）和while循环（参见第13章）可助其一臂之力。
 Determine if there is more to the message1
shift
vhile [ -n *$1* ]
do
T$ . ,aesu"aoqps=aesau"o
shift
done
shift命令允许你在不知道参数总数的情况下处理各种脚本参数。该命令会将下一个参数移
动到s1。一开始必须在while循环前使用一次shift，因为消息是从s2参数开始的，而非$1。
进人while循环后，它接着获取消息中的每个单词，并将单词添加到变量whole_message
中，然后使用shift命令移动到下一个参数。处理完最后一个参数后，while循环退出，完整的
消息就被保存在了变量whole_message中。
还要对脚本进行另一处修改。脚本需要将变量whole_message发送给write，而不是仅仅
发送参数s2。
 Send message to user1
uterminal=$ (vho 1 grep i -n 1 $1 1 gawk *(print $2)*)
echo Swbole_message 1 vrite $logged_on Suterminal
现在再试试发送一条警告消息，告诉Timothy，老板正走向他。
Usage: grep (OPTIoN] ... PATrERN [FILE] ...
./mu.sh Tinothy Boss is coning
Try 'grep --belp' for more information.
还是不行。这是因为在脚本中使用shift命令时，参数s1中的内容被删除了。因此当脚本试
图在grep命令中使用si时，就产生了错误。要解决这个间题，需要使用一个变量muser来保存
参数s1的内容。
 Save the vsernane parameter
muser=$1
26
现在变量muser中保存了用户名。grep和echo命令中涉及使用参数s1的地方都可以使用
muser来替换。
 Determine if user is logged on1
(T$ uTd) , xAo6 1xanas T u- T- dax6 1oqa)$uopaEo[
 + + - J
ecbo *Smaser is not logged on. *
---
## Page 587
572
第26章
一些小有意思的脚本
[.-.]
 Deternine lf uaer allova nessaging:
(,[2s autad) , xnef 1 eemms T w- 1- dex6 1 - oqx) s=pono[e
[ · - · ]
echo *Saueer Goeg not allouing nessaging.*
[ . - .]
 Send nessage to user:
[, {2s uTxd] 。 xne6 1xeems [ u- T- dox6 1 og) s=[euuxon
[ · - · ]
可以再发送一次长消息来测试一下修改后的脚本。另外我们还在消息中加人了几个惊叹号。
S -/mu.sh Timothy The boss ia coning! Look busy!
用户Timothy在自己的终端上接收到下面的消息。
Message fron chrlatinegsexver01 on tty2 at 10:30 ...
The boss La coning: Look busy1
BOF
没问题啦！现在可以使用这个脚本快速向系统中的其他用户发送消息。最终的脚本代码如下。
1/bin/baah
mu.sh - Send a Message to a particular user
#＃#＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃
 Save the username paraneter
muser=$1
 Determine lf ueer La logged on:
#
(. (ts aut.xd) , xme6 1 xesnes [ e- t- dox6 1 oux) s=uope6foT
1f 1 -z $logged_on ]
then
echo *Snuser la not logged on.*
echo *Exiting acript...*
ex1t
f 1
#
 Determine if user allove messaging:
a11owed=S (vho -T 1 gxep -1 =m 1 Smusez 1 gawk *(pr1nt $2)′)
[ ,+, = ponoes 1 T
Chen
echo *Snuser Goea not allouing messaging.*
echo *Exiting acript...*
ex1 t:
 1
---
## Page 588
26.2获取格言
573
f [ -z 2 ]
then
- 'popntout teqeuexed efessee oN。 ouo8
Bcho
*Exiting acript...*
f1
exit
# Deternine lf there is more to the nessage:
shift
[-S。 u-1Tm
do
ahifc
done
:xesn. o1 efesreu pueg
uterminal=$Ivho 1 grep -1
echo Suhole_nessage l wzite $logged_on Sutezminal
ex1t
既然你已经读到了本书的最后一章，自然也就应该准备好了应对脚本编写中出现的挑战。下
面是对于这个消息发送脚本的一些改进意见，可以试着加人这些功能。
口选择使用选项（参见第14章），不把用户名和消息作为参数传递。
口如果用户登人多个终端，允许将消息发往这些终端（提示：使用多个write命令）。
口如果消息的接收方目前只登人了GUI环境，提示脚本用户并退出脚本（write命令只能向
虚拟控制台终端写入信息）。
口允许将保存在文件中的长消息发送给终端（提示：使用管道将cat命令的输出传人write
命令，不要使用echo命令）。
要想巩固学到的脚本编写知识，不仅要通读脚本，还得修改脚本。加人一些自己的点子。找
点小乐子吧！这有助于你的学习。
26.2获取格言
26
励志格言常见于商业环境中。你的办公室墙上可能现在就有那么几句。这个有趣的小脚本可
以帮助你每天获得一句格言以供使用。
本节将介绍如何创建这样的脚本。其中包括一个功能丰富但至今尚未讲过的工具，另外还会
用了一些我们已经熟悉的工具，例如sed和gawk。
---
## Page 589
574
第26章一些小有意思的脚本
26.2.1功能分析
有一些不错的网站可以获得每日格言。打开你惯用的搜索引擎，可以找到很多这类网站。找
到之后，你需要使用工具来下载这些格言。对于这种用途的脚本，正是wget工具发挥用途之处。
1.学习wget
wget是一款非常灵活的工具，它能够将Web页面下载到本地Linux系统中。你可以从这些页
面中收集每日格言。
说明wget命令功能极其丰富。本章中仅使用了很小一部分功能。可以查看wget的手册页获得
更多的相关信息：
要通过wget下载Web页面，只需要使用wget命令和网站的地址就行了。
$wget ww.quotationspage.com/gotd.html
-20150923 09:14 :28-  http1/ /w- quotationspage com/qotd.htm1
Resolving www.quotationspage,con.. . 67.228,101.64
Connecting to wv,quotationspage,con167.228,101, 641 :80.。 connected
HTTP request sent, avaiting response... 200 0K
Length: unspecified [text/html]
Saving to: *gotd.htnl*
[
] 13, 806 --, -K/s  in 0.1s
[908]paea -upob。 -(8/8 8) 8160 c60-5T07
网站的信息被存储在与Web页面同名的文件中。在这个例子中，文件名就是qotd.html。你大
概已经猜到了，这个文件中都是HTML代码。
$ cat gotd.htnl
chead>
Quotes of the Day - The Quotations Page
[...]
这里只列出了部分HTML代码。脚本可以使用sed和gawk工具提取出需要的格言。不过在使
用脚本之前，你需要对wget工具的输入和输出施加一点控制。
可以使用一个变量来保存页面地址（URL）。然后把这个变量作为参数传递给wget就行了。
记住，别忘了在变量名前加上$。
$ url=w.quotationspage com/gotd.htnl
wget $url
---
## Page 590