title:VRASED: A Verified Hardware/Software Co-Design for Remote Attestation
author:Ivan De Oliveira Nunes and
Karim Eldefrawy and
Norrathep Rattanavipanon and
Michael Steiner and
Gene Tsudik
VRASED: A Verified Hardware/Software Co-Design 
for Remote Attestation
Ivan De Oliveira Nunes, University of California, Irvine; Karim Eldefrawy, SRI International; 
Norrathep Rattanavipanon, University of California, Irvine; Michael Steiner, Intel; 
Gene Tsudik, University of California, Irvine
https://www.usenix.org/conference/usenixsecurity19/presentation/de-oliveira-nunes
This paper is included in the Proceedings of the 28th USENIX Security Symposium.August 14–16, 2019 • Santa Clara, CA, USA978-1-939133-06-9Open access to the Proceedings of the 28th USENIX Security Symposium is sponsored by USENIX.VRASED: A Veriﬁed Hardware/Software Co-Design for Remote Attestation
Ivan De Oliveira Nunes
University of California, Irvine
Karim Eldefrawy
SRI International
Norrathep Rattanavipanon
University of California, Irvine
PI:EMAIL
PI:EMAIL
PI:EMAIL
Michael Steiner
Intel
Gene Tsudik
University of California, Irvine
PI:EMAIL
PI:EMAIL
Abstract
Remote Attestation (RA) is a distinct security service that al-
lows a trusted veriﬁer (V rf) to measure the software state of
an untrusted remote prover (P rv). If correctly implemented,
RA allows V rf to remotely detect if P rv is in an illegal or com-
promised state. Although several RA approaches have been
explored (including hardware-based, software-based, and hy-
brid) and many concrete methods have been proposed, compar-
atively little attention has been devoted to formal veriﬁcation.
In particular, thus far, no RA designs and no implementations
have been formally veriﬁed with respect to claimed security
properties.
In this work, we take the ﬁrst step towards formal veriﬁca-
tion of RA by designing and verifying an architecture called
VRASED: Veriﬁable Remote Attestation for Simple Embedded
Devices. VRASED instantiates a hybrid (HW/SW) RA co-
design aimed at low-end embedded systems, e.g., simple IoT
devices. VRASED provides a level of security comparable to
HW-based approaches, while relying on SW to minimize ad-
ditional HW costs. Since security properties must be jointly
guaranteed by HW and SW, veriﬁcation is a challenging task,
which has never been attempted before in the context of RA. We
believe that VRASED is the ﬁrst formally veriﬁed RA scheme.
To the best of our knowledge, it is also the ﬁrst formal veriﬁ-
cation of a HW/SW co-design implementation of any security
service. To demonstrate VRASED’s practicality and low over-
head, we instantiate and evaluate it on a commodity platform
(TI MSP430). VRASED was deployed using the Basys3 Artix-7
FPGA and its implementation is publicly available.
1 Introduction
The number and variety of special-purpose computing devices
is increasing dramatically. This includes all kinds of embedded
devices, cyber-physical systems (CPS) and Internet-of-Things
(IoT) gadgets, that are utilized in various “smart” settings, such
as homes, ofﬁces, factories, automotive systems and public
venues. As society becomes increasingly accustomed to being
surrounded by, and dependent on, such devices, their security
becomes extremely important. For actuation-capable devices,
malware can impact both security and safety, e.g., as demon-
strated by Stuxnet [49]. Whereas, for sensing devices, malware
can undermine privacy by obtaining ambient information. Fur-
thermore, clever malware can turn vulnerable IoT devices into
zombies that can become sources for DDoS attacks. For exam-
ple, in 2016, a multitude of compromised “smart” cameras and
DVRs formed the Mirai Botnet [2] which was used to mount a
massive-scale DDoS attack (the largest in history).
Unfortunately, security is typically not a key priority for low-
end device manufacturers, due to cost, size or power constraints.
It is thus unrealistic to expect such devices to have the means to
prevent current and future malware attacks. The next best thing
is detection of malware presence. This typically requires some
form of Remote Attestation (RA) – a distinct security service
for detecting malware on CPS, embedded and IoT devices. RA
is especially applicable to low-end embedded devices that are
incapable of defending themselves against malware infection.
This is in contrast to more powerful devices (both embedded
and general-purpose) that can avail themselves of sophisticated
anti-malware protection. RA involves veriﬁcation of current
internal state (i.e., RAM and/or ﬂash) of an untrusted remote
hardware platform (prover or P rv) by a trusted entity (veriﬁer
or V rf). If V rf detects malware presence, P rv’s software can
be re-set or rolled back and out-of-band measures can be taken
to prevent similar infections. In general, RA can help V rf es-
tablish a static or dynamic root of trust in P rv and can also be
used to construct other security services, such as software up-
dates [43] and secure deletion [40]. Hybrid RA (implemented
as a HW/SW co-design) is a particularly promising approach
for low-end embedded devices. It aims to provide the same
security guarantees as (more expensive) hardware-based ap-
proaches, while minimizing modiﬁcations to the underlying
hardware.
Even though numerous RA techniques with different as-
sumptions, security guarantees, and designs, have been pro-
posed [9, 10, 14–16, 20, 21, 25, 30, 35, 38, 38–40, 43], a major
missing aspect of RA is the high-assurance and rigor derivable
from utilizing computer-aided formal veriﬁcation to guarantee
security of the design and implementation of RA techniques.
Because all aforementioned architectures and their implemen-
tations are not systematically designed from abstract models,
their soundness and security can not be formally argued. In
fact, our RA veriﬁcation efforts revealed that a previous hybrid
RA design – SMART [21] – assumed that disabling interrupts
is an atomic operation and hence opened the door to compro-
mise of P rv’s secret key in the window between the time of
USENIX Association
28th USENIX Security Symposium    1429
the invocation of disable interrupts functionality and the time
when interrupts are actually disabled. Another low/medium-
end architecture – Trustlite [30] – does not achieve our formal
deﬁnition of RA soundness. As a consequence, this architecture
is vulnerable to self-relocating malware (See [13] for details).
Formal speciﬁcation of RA properties and their veriﬁcation
signiﬁcantly increases our conﬁdence that such subtle issues
are not overlooked.
In this paper we take a “veriﬁable-by-design” approach
and develop, from scratch, an architecture for Veriﬁable
Remote Attestation for Simple Embedded Devices (VRASED).
VRASED is the ﬁrst formally speciﬁed and veriﬁed RA archi-
tecture accompanied by a formally veriﬁed implementation.
Veriﬁcation is carried out for all trusted components, including
hardware, software, and the composition of both, all the way
up to end-to-end notions for RA soundness and security. The
resulting veriﬁed implementation – along with its computer
proofs – is publicly available [1]. Formally reasoning about,
and verifying, VRASED involves overcoming major challenges
that have not been attempted in the context of RA and, to the
best of our knowledge, not attempted for any security service
implemented as a HW/SW co-design. These challenges in-
clude:
1 – Formal deﬁnitions of: (i) end-to-end notions for RA
soundness and security; (ii) a realistic machine model for
low-end embedded systems; and (iii) VRASED’s guaran-
tees. These deﬁnitions must be made in single formal system
that is powerful enough to provide a common ground for rea-
soning about their interplay. In particular, our end goal is to
prove that the deﬁnitions for RA soundness and security are
implied by VRASED’s guarantees when applied to our machine
model. Our formal system of choice is Linear Temporal Logic
(LTL). A background on LTL and our reasons for choosing it
are discussed in Section 2.
2 – Automatic end-to-end veriﬁcation of complex systems such
as VRASED is challenging from the computability perspective,
as the space of possible states is extremely large. To cope with
this challenge, we take a “divide-to-conquer” approach. We
start by dividing the end-to-end goal of RA soundness and
security into smaller sub-properties that are also deﬁned in
LTL. Each HW sub-module, responsible for enforcing a given
sub-property, is speciﬁed as a Finite State Machine (FSM),
and veriﬁed using a Model Checker. VRASED’s SW relies on
an F* veriﬁed implementation (see Section 4.3) which is also
speciﬁed in LTL. This modular approach allows us to efﬁciently
prove sub-properties enforced by individual building blocks in
VRASED.
3 – All proven sub-properties must be composed together in
order to reason about RA security and soundness of VRASED
as one whole system. To this end, we use a theorem prover
to show (by using LTL equivalences) that the sub-properties
that were proved for each of VRASED’s sub-modules, when
composed, imply the end-to-end deﬁnitions of RA soundness
and security. This modular approach enables efﬁcient system-
wide formal veriﬁcation.
1.1 The Scope of Low-End Devices
This work focuses on low-end devices based on low-power
single core microcontrollers with a few KBytes of program
and data memory. A representative of this class of devices is
the Texas Instrument’s MSP430 microcontroller (MCU) fam-
ily [26]. It has a 16-bit word size, resulting in ≈ 64 KBytes of
addressable memory. SRAM is used as data memory and its
size ranges between 4 and 16KBytes (depending on the spe-
ciﬁc MSP430 model), while the rest of the address space can
be used for program memory, e.g., ROM and Flash. MSP430 is
a Von Neumann architecture processor with common data and
code address spaces. It can perform multiple memory accesses
within a single instruction; its instruction execution time varies
from 1 to 6 clock cycles, and instruction length varies from 16
to 48 bits. MSP430 was designed for low-power and low-cost.
It is widely used in many application domains, e.g., automotive
industry, utility meters, as well as consumer devices and com-
puter peripherals. Our choice is also motivated by availability
of a well-maintained open-source MSP430 hardware design
from Open Cores [22]. Nevertheless, our machine model is ap-
plicable to other low-end MCUs in the same class as MSP430
(e.g., Atmel AVR ATMega).
1.2 Organization
Section 2 provides relevant background on RA and formal ver-
iﬁcation. Section 3 contains the details of the VRASED archi-
tecture and an overview of the veriﬁcation approach. Section 4
contains the formal deﬁnitions of end-to-end RA soundness and
security and the formalization of the necessary sub-properties
along with the implementation of veriﬁed components to re-
alize such sub-properties. Due to space limitation, the proofs
for end-to-end soundness and security derived from the sub-
properties are discussed in Appendix A. Section 5 discusses
alternative designs to guarantee the same required properties
and their trade-offs with the standard design. Section 6 presents
experimental results demonstrating the minimal overhead of
the formally veriﬁed and synthesized components. Section 7
discusses related work. Section 8 concludes with a summary
of our results. End-to-end proofs of soundness and security,
optional parts of the design, VRASED’s API, and discussion
on VRASED’s prototype can be found in Appendices A to C.
2 Background
This section overviews RA and provides some background on
computer-aided veriﬁcation.
1430    28th USENIX Security Symposium
USENIX Association
2.1 RA for Low-end Devices
As mentioned earlier, RA is a security service that facilitates
detection of malware presence on a remote device. Speciﬁ-
cally, it allows a trusted veriﬁer (V rf) to remotely measure the
software state of an untrusted remote device (P rv). As shown
in Figure 1, RA is typically obtained via a simple challenge-
response protocol:
1. V rf sends an attestation request containing a challenge
(C hal) to P rv. This request might also contain a token
derived from a secret that allows P rv to authenticate V rf.
2. P rv receives the attestation request and computes an au-
thenticated integrity check over its memory and C hal. The
memory region might be either pre-deﬁned, or explicitly
speciﬁed in the request. In the latter case, authentication
of V rf in step (1) is paramount to the overall security/pri-
vacy of P rv, as the request can specify arbitrary memory
regions.
3. P rv returns the result to V rf.
4. V rf receives the result from P rv, and checks whether it
corresponds to a valid memory state.
Veriﬁer
Prover
(1) Request
( 3 ) R e p o r t
(2) Authenticated
Integrity Check
(4) Verify
Report
Figure 1: Remote attestation (RA) protocol
Platform Modules (TPMs) [47]; or ii) modiﬁcations to the
CPU semantics or instruction sets to support the execution
of trusted software, e.g., SGX [27] or TrustZone [3]. Such
hardware features are too expensive (in terms of physical area,
energy consumption, and actual cost) for low-end devices.
While neither hardware- nor software-based approaches are
well-suited for settings where low-end devices communicate
over the Internet (which is often the case in the IoT), hybrid
RA (based on HW/SW co-design) is a more promising ap-
proach. Hybrid RA aims at providing the same security guar-
antees as hardware-based techniques with minimal hardware
support. SMART [21] is the ﬁrst hybrid RA architecture target-
ing low-end MCUs. In SMART, attestation’s integrity check is
implemented in software. SMART’s small hardware footprint
guarantees that the attestation code runs safely and that the
attestation key is not leaked. HYDRA [20] is a hybrid RA
scheme that relies on a secure boot hardware feature and on
a secure micro-kernel. Trustlite [30] modiﬁes Memory Pro-
tection Unit (MPU) and CPU exception engine hardware to
implement RA. Tytan [9] is built on top of Trustlite, extending
its capabilities for applications with real-time requirements.
Despite much progress, a major missing aspect in RA re-
search is high-assurance and rigor obtained by using formal
methods to guarantee security of a concrete RA design and
its implementation We believe that veriﬁability and formal
security guarantees are particularly important for hybrid RA
designs aimed at low-end embedded and IoT devices, as their
proliferation keeps growing. This serves as the main motiva-
tion for our efforts to develop the ﬁrst formally veriﬁed RA
architecture.
The authenticated integrity check can be realized as a Mes-
sage Authentication Code (MAC) over P rv’s memory. How-
ever, computing a MAC requires P rv to have a unique secret
key (denoted by K ) shared with V rf. This K must reside in
secure storage, where it is not accessible to any software run-
ning on P rv, except for attestation code. Since most RA threat
models assume a fully compromised software state on P rv,
secure storage implies some level of hardware support.
Prior RA approaches can be divided into three groups:
software-based, hardware-based, and hybrid. Software-based
(or timing-based) RA is the only viable approach for legacy
devices with no hardware security features. Without hardware
support, it is (currently) impossible to guarantee that K is not
accessible by malware. Therefore, security of software-based
approaches [35, 44] is attained by setting threshold communi-
cation delays between V rf and P rv. Thus, software-based RA
is unsuitable for multi-hop and jitter-prone communication, or
settings where a compromised P rv is aided (during attestation)
by a more powerful accomplice device. It also requires strong
constraints and assumptions on the hardware platform and at-