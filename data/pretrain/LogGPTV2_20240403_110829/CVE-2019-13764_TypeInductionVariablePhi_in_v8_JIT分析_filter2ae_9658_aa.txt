# CVE-2019-13764 TypeInductionVariablePhi in v8 JIT分析
##### 译文声明
本文是翻译文章
译文仅供参考，具体内容表达以及含义原文为准。
## 一、前言
  * CVE-2019-13764 是 v8 中的一个位于 JIT TyperPhase `TypeInductionVariablePhi` 函数的漏洞。我们可以通过这个例子简单学习一下 TyperPhase 中对 InductionVariablePhi 的处理方式，以及越界读取构造方式。
  * 复现用的 v8 版本为 `7.8.279.23`（chromium 78.0.3904.108） 。
## 二、环境搭建
  * 切换 v8 版本，然后编译： 
        git checkout 7.8.279.23
    gclient sync
    tools/dev/v8gen.py x64.debug
    ninja -C out.gn/x64.debug
  * 启动 turbolizer。如果原先版本的 turbolizer 无法使用，则可以使用在线版本的 [turbolizer](https://v8.github.io/tools/head/turbolizer/index.html)
        cd tools/turbolizer
    npm i
    npm run-script build
    python -m SimpleHTTPServer 8000&
    google-chrome http://127.0.0.1:8000
## 三、漏洞细节
  * 在循环变量分析中，当initial_type 与 increment_type 相结合，则可以通过两个不同符号的无穷大相加产生NaN结果（即 **-inf + inf == NaN** ）。这将 **进入 turboFan 认为是 unreachable code 的代码区域** ，触发 SIGTRAP 崩溃。
  * 以下是漏洞函数的源码： 
        Type Typer::Visitor::TypeInductionVariablePhi(Node* node) {
      int arity = NodeProperties::GetControlInput(node)->op()->ControlInputCount();
      DCHECK_EQ(IrOpcode::kLoop, NodeProperties::GetControlInput(node)->opcode());
      DCHECK_EQ(2, NodeProperties::GetControlInput(node)->InputCount());
      Type initial_type = Operand(node, 0);
      Type increment_type = Operand(node, 2);
      // We only handle integer induction variables (otherwise ranges
      // do not apply and we cannot do anything).
      // 检测 intial_type && increment_type 是否都是 integer 类型
      if (!initial_type.Is(typer_->cache_->kInteger) ||
          !increment_type.Is(typer_->cache_->kInteger)) {
        // Fallback to normal phi typing, but ensure monotonicity.
        // (Unfortunately, without baking in the previous type, monotonicity might
        // be violated because we might not yet have retyped the incrementing
        // operation even though the increment's type might been already reflected
        // in the induction variable phi.)
        // 如果不满足条件，则回退至保守的 phi typer。
        Type type = NodeProperties::IsTyped(node) ? NodeProperties::GetType(node)
                                                  : Type::None();
        for (int i = 0; i induction_variables().find(node->id());
      DCHECK(res != induction_vars_->induction_variables().end());
      InductionVariable* induction_var = res->second;
      InductionVariable::ArithmeticType arithmetic_type = induction_var->Type();
      double min = -V8_INFINITY;
      double max = V8_INFINITY;
      /* 获取实际的 min 和 max。
         其中
         1. 对于循环是增量的情况（即increment_min >= 0）：
          - min = initial_type.Min();
          - max = std::min(max, bound_max + increment_max);
            max = std::max(max, initial_type.Max());   
         2. 对于循环是减量的情况（即increment_max zone());
    }
上述源码只是简单的判断了一下 initial_type 和 increment_type 的类型是否全为 Integer，如果不满足条件则使用保守的
typer；但这其中并没有判断出现 NaN 的情况，因此针对于某些 testcase 会产生问题。
  * 当 initial value 为 **infinity** ， increment value 为 **-infinity** ，即类似于以下这种形式的循环： 
        for(let a = Infinity, a >= 1; a += (-Infinity)) {}
则在处理归纳变量 i 的phi结点时，由于 inital_type 和 increment_type 都是 integer
类型的，因此将不会回退至保守typer计算 type，而是继续向下执行。那么将会以下述过程执行至 return 语句，返回一个 `-inf ~
inf`的范围给当前的 InductionVariablePhi 结点：
> 具体的细节均以注释的形式写入代码中。
        Type Typer::Visitor::TypeInductionVariablePhi(Node* node) {
      // ...
      // [1]. 初始时设置 min 值和 max 值为两个极端
      double min = -V8_INFINITY;
      double max = V8_INFINITY;
      double increment_min;
      double increment_max;
      if (arithmetic_type == InductionVariable::ArithmeticType::kAddition) {
        // [2]. 由于 JS 代码中的归纳变量执行的是加法操作，即 `i += (-Infinity)`，因此控制流进入此处
        increment_min = increment_type.Min();
        increment_max = increment_type.Max();
        // 此时increment_min == increment_max = -inf
      } else {
        DCHECK_EQ(InductionVariable::ArithmeticType::kSubtraction, arithmetic_type);
        increment_min = -increment_type.Max();
        increment_max = -increment_type.Min();
      }
      if (increment_min >= 0) {
        // ...
      } else if (increment_max lower_bounds()) {
          // [4]. 对于判断语句中的每个比较操作，即获取 bound类型和值
          Type bound_type = TypeOrNone(bound.bound);
          // If the type is not an integer, just skip the bound.
          if (!bound_type.Is(typer_->cache_->kInteger)) continue;
          // If the type is not inhabited, then we can take the initial value.
          if (bound_type.IsNone()) {
            min = initial_type.Min();
            break;
          }
          // 对于上述例子，此时的 bound_min == bound_max = 1
          double bound_min = bound_type.Min();
          if (bound.kind == InductionVariable::kStrict) {
            bound_min += 1;
          }
          // 设置min值，由于 max 函数的两个参数都与 -inf 相关，因此设置 min 为 -inf
          min = std::max(min, bound_min + increment_min);
        }
        // The lower bound must be at most the initial value's lower bound.
        // [5]. 由于 -inf cache_->kInteger;
      }
      // ...
      // [6]. 返回 Range(-inf, inf)，即返回了一个错误的范围
      return Type::Range(min, max, typer_->zone());
    }
在 min 值的赋值处（即[4]、[5]），原先的代码预期 **min 值范围为**
        initial_type.Min  -inf(bound_min+increment_min) => -inf(与initial value比较后的结果)
这样使得最终的 min 值为 -inf。
  * 错误的 Phi 结点的 Range 将导致错误的类型传播。这样会使得控制流非常容易地进入 deopt 环节。该漏洞触发的 int3 断点就是位于编译生成的 JIT 代码中 deopt 环节内部。由于 turboFan 中传播了错误的类型，使得 deopt 无法识别出该调用的 deopt 函数，因此控制流将陷入死循环，频繁触发本不该执行到的 int3 断点。以下是 turboFan 第一次编译生成的汇编代码： 
        0x118a80d82e20     0  488d1df9ffffff       REX.W leaq rbx,[rip+0xfffffff9]
    0x118a80d82e27     7  483bd9               REX.W cmpq rbx,rcx
    0x118a80d82e2a     a  7418                 jz 0x118a80d82e44  
    0x118a80d82e2c     c  48ba0000000036000000 REX.W movq rdx,0x3600000000
    0x118a80d82e36    16  49ba803d5202157f0000 REX.W movq r10,0x7f1502523d80  (Abort)    ;; off heap target
    0x118a80d82e40    20  41ffd2               call r10
    0x118a80d82e43    23  cc                   int3l
    0x118a80d82e44    24  488b59e0             REX.W movq rbx,[rcx-0x20]
    0x118a80d82e48    28  f6430f01             testb [rbx+0xf],0x1
    0x118a80d82e4c    2c  740d                 jz 0x118a80d82e5b  
    0x118a80d82e4e    2e  49bac0914602157f0000 REX.W movq r10,0x7f15024691c0  (CompileLazyDeoptimizedCode)    ;; off heap target
    0x118a80d82e58    38  41ffe2               jmp r10
    0x118a80d82e5b    3b  55                   push rbp
    0x118a80d82e5c    3c  4889e5               REX.W movq rbp,rsp
    0x118a80d82e5f    3f  56                   push rsi
    0x118a80d82e60    40  57                   push rdi
    0x118a80d82e61    41  48ba0000000022000000 REX.W movq rdx,0x2200000000
    0x118a80d82e6b    4b  4c8b15c6ffffff       REX.W movq r10,[rip+0xffffffc6]