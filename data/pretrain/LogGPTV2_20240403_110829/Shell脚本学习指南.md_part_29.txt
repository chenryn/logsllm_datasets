字符、任何接下来的参数以及任何留在格式字符申中的字符，都被忽略
\f
换页（formfeed）
\n
换行
\r
回车 (Carriage return)
水平制表符
www.TopSage.com
---
## Page 175
输入/输出、文件与命令执行
表7-1：printf的转义序列（续）
com
序列
说明
\ v
垂直制表符
11
一个字面上的反斜杠字符
\ddd
表示1到3位数八进制值的字符。仅在格式字符串中有效
\0ddd
表示1到3位的八进制值字符
注：只在%b格式指示将控制下的参数字将事中有效。
printf对转义序列的处理可能会让人觉得混滑。默认情况下，转义序列只在格式字符
串中会被特别对待，也就是说，出现在参数字符串里的转义序列不会被解释：
S printf “a string, no processing: \n *A\nB*
a string, no processing: 
当你使用8b格式指示符时，printf会解释参数字符串里的转义序列：
Sprintf a string,vith processing:\n*"A\nB"
a string. with processing: <A
无论是在格式字符串内还是在使用8b所打印的参数字符串里，大部分的转义序列都是
被相同对待（如表7-1所示）。无论如何，\c与\0ddd只有搭配b使用才有效，而\ddd
只有在格式字符串里才会被解释。
现在应大致可以作结论，格式指示符为printf提供了强大的功能和灵活性。格式规格
字母请见表7-2。
表7-2：printf格式指示符
项目
说明
相对应的参数被视为含有要被处理的转义序列之字符串。见表7-1
$c
ASCII字符，显示相对应参数的第一个字符
ed,8i
十进制整数
$e
浮点格式（[-]d.precisione[+-]da）
E
浮点格式（[-]d.precisionE[+-]dd）
f
浮点格式（{-]ddd.precision）
5g
$e或f转换，看哪一个较短，则删除结尾的零
$G
$E或f转换，看哪一个较短，则删除结尾的零
$0
不带正负号的八进制值
www.TopSage.com
---
## Page 176
164
第7章
表7-2：printf格式指示符（续）
项目
说明
字符串
u
不带正负号的十进制值
8x
不带正负号的十六进制值。使用a至f表示10至15
$X
不带正负号的十六进制值。使用A至F表示10至15
字面意义的
根据POSIX标准：浮点格式多e、$、8f、8g与8G是“不需要被支持”这是因为awk
支持浮点算数运算，且有它自已的printE语句，这样，Shell程序中需要将浮点数值进
行格式化的打印时，可使用小型awk程序实现。然而，内建于bash、ksh93和zsh中
的printf命令都支持浮点格式。
prirtE命令可用来指定输出字段的宽度以及进行对齐操作，为实现此目的，接在后
面的格式表达式可采用三个可选用的修饰符（modifier）以及前置的格式指示符（format
specifier):
flaga width.preciaion format-specifier
输出字段的width为数字值。指定字段宽度时，字段的内容默认为向右对齐，如果你希
望文字向左靠，必须指定-标志。这样：“号-20s'会在一个有20个字符宽度的字段里，
输出一个向左对齐的字符串，如果字符串少于20个字符，则字段将以空白填满。下面的
例子里，1是输出，以表示字段的实际宽度。第一个例子为向右对齐文字：
S printf *1%10el\n* bello
hel1o1
下一个例子则为向左对齐文字：
S printf "1%-10sl\n* bello
Ihe110
Drecision修饰符是可选用的。对十进制或浮点数值而言，它可以控制数字出现于结果
中的位数。对字符申值而言，它控制将要打印的字符串的最大字符数。具体的含义会因
格式指示符而有不同，见表7-3。
表7-3：精度的意义
转换
$d，$i， $o， $u， $x, 8x
要打印的最小位数。当值的位数少于此数字时，会在前面补
零。默认精度（precisioh）为1
www.TopSage.com
---
## Page 177
输入/输出、文件与命令执行
165
表7-3：精度的意义（续）
转换
s精度含义5
$e, $E
要打印的最小位数，当值的位数少于此数字时，会在小数点
后面补零，默认精度为6，精度为0则表示不显示小数点
$f
小数点右边的位数
g。G
有效位数（significant digit）的最大数目
要打印字符的最大数目
下面是几个精度的例子：
$ printf %.5d\n°15
S printf "%.10s\n* *a very long string*
00015
S printf "%.2f\n* 123.4567
a very lon
123.46
C函数库的printf（）函数允许通过参数列表里的额外数值动态地指定宽度及精度。
POSIX标准不支持此功能，相反地，它会建议你在格式字符串里使用Shell变量值（注2）。
举例如下：
$vidtb=5prec=6myvar=42.123456
$ printt "/%$(width).$(prec)G1\n*$nyvar
POSIX
$ printf "/*,*G1\n* 5 6Snyvar
142.12351
|42.12351
最后要介绍的是：在字段宽度与精度前放置一个或多个标志的用法。我们已介绍过使用
-标志可以让字符申向左对齐，完整的标志列表如表7-4所示。
表7-4：print的标志
字符
意义
x-2.1:A; / 
将字段里已格式化的值向左对齐。
14,2 
空白（space)
在正值前置一个空格，在负值前置一个负号。
+
总是在数值之前放置一个正号成负号，即便是正值也是，
下列形式选择其一：$o有一个前置的0：$x与x分别有前置的0x与OX
e、E与$f总是在结果中有一个小数点：g与$G为没有结尾的零。
以零填补输出，而非空白。这仅发生在字段宽度大于转换后的情况下。在C
语言里，该标志应用到所有输出格式，即使是非数字的值也一样，对于
Drintf命令而言，它仅应用到数值格式。
运 2 ;
某些printf版茶，例如ksh93与Dash下的版本，确实支持动态的宽度与精度指定。
www.TopSage.com
---
## Page 178
166
再举例说明：
com
$printf*1%-10s11%10s1\n*hello wor1d
字符申向左、向右对齐
S printf *1% d1 1% d1\n" 15 -15
Ihello
11
world1
空白标志
S printf *+d %+d\n” 15 -15
1 151 1-151
标志
S printf *kx %x\n" 15 15
+15 -15
标志
Sprintf *o5d\n” 15
f 0xf
0标志
00015
对于转换指示符8b、8c与$s而言，相对应的参数都视为字符串。否则，它们会被解释
为C语言的数字常数（开头的0为八进制，以及开头的0x与0X为十六进制）。更进一
步来说，如果参数的第一个字符为单引号或双引号，则相对应的数值是字符串的第二个
字符的ASCII值：
S printf "e ie td\n" a "'a"
a 18 97
当参数多于格式指示符时，格式指示符会根据需要再利用。这种做法在参数列表长度未
知时是很方便的，例如来自通配符表达式。如果留在格式（format）字符串里剩下的指
示符比参数多时，如果是数值转换，则遗漏的值会被看成是零，如果是字符串转换，则
被视为空字符串（虽然可以这么用，但比较好的方式应该是确认你提供的参数数目，与
格式字符串所预期的数目是一样的）。如果printf无法进行格式的转换，它便会返回
一个非零的退出状态。
7.5波浪号展开与通配符
Shell有两种与文件名相关的展开。第一个是波浪号展开（tildeexpansion），另一个则
有很多种叫法，有人称之为通配符展开式（wildcardexpansion），有人则称之为全局展
开（globbing）或是路径展开（pathnameexpansion）。
7.5.1
波浪号展开
如果命令行字符串的第一个字符为波浪号（~），或者变量指定（例如PATH或CDPATH
变量）的值里任何未被引号括起来的冒号之后的第一个字符为波浪号（-）时，Shell便
会执行波浪号展开。
www.TopSage.com
---
## Page 179
输入/输出、文件与命令执行
167
波浪号展开的目的，是要将用户根目录的符号型表示方式，改为实际的目录路径，可以
采用直接或间接的方式指定执行此程序的用户，如未明白指定，则为当前的用户：
S v1 =/-profile
与viSHOME/ ,proE11e 相同]
sv1-tolatoy/.profile
编辑用户tolstoy的·profile文件
以第一个例子来看，Shell将-换成SHOME，也就是当前用户的根目录。第二个例子，则
是Shell在系统的密码数据库里，寻找用户tolstoy，再将~tolstoy置换为tolstoy
的根目录，
注意：波浪号展开最先是出现于Berkeley CShell—csh中。主要是交互式功能。事实证明它
的确很受欢迎，而且之后还被KornShell、bash及绝大多数现代Bourme形式的Shell采纳
成为自已的功能。因此POSIX标准里也说明了它的应用方式。
不过（总是有“不过”），有许多商用UNIX的Bourne Shell不支持它，因此，如果你对Shell
聊本的可移植性有所要求，请不要在你的脚本里使用波浪号展开，
使用波浪展开有两个好处，第一，它是一种简洁的概念表示方式，让查阅Shell脚本的
人更清楚脚本在做的事。第二，它可以避免在程序里把路径名称直接编码。先看这个脚
本片段：
printf *Enter usernane: *
显示提示信息
vi /home/Suser/ -prof11e
read user
编辑该用户的-proEile文件
读取指名的用户
前面的程序假设所有用户的根目录都在/home之下，如果这有任何变动（例如，用户子
目录根据部门存放在部门目录的子目录下），那么这个脚本就得重写，但如果使用波浪
号展开，就能避免重写的情况：
printf *Enter username: *
显示提示信息
vi ~Suser/.profile
read user
读取指名的用户
输辑该用户的-profile文件
+*.
这么一来，无论用户根目录在哪里，程序都可以正常运作。
许多Shell如ksh88、ksh93、bash与zsh，都提供额外的波浪号展开，详见14.3.7节。
7.5.2使用通配符
寻找文件名里的特殊字符，也是Shell提供的服务之一。当它找到这类字符时，会将它
www.TopSage.com
---
## Page 180
168
第7章
们视为要匹配的模式，也就是，一组文件的规格，它们的文件名称都匹配于某个给定的
模式。Shell会将命令行上的模式，置换为符合模式的一组排序过的文件名（注3）。
如果接触过MS-DOS下的简单命令行环境，你可能会觉得*，这样的通配符很熟悉，它
指的是当前目录下的所有文件名。UNIXShell的通配符也类似，只不过功能更强大。基
本的通配符见表7-5所示。
表7-5：基本的通配符
通配符
匹配
7
任何的单一字符。