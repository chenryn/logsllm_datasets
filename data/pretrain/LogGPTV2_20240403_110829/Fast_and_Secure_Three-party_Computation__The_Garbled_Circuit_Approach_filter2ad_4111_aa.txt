title:Fast and Secure Three-party Computation: The Garbled Circuit Approach
author:Payman Mohassel and
Mike Rosulek and
Ye Zhang
Fast and Secure Three-party Computation:
The Garbled Circuit Approach
Payman Mohassel
Yahoo Labs
Sunnyvale, California
pmohassel@yahoo-
inc.com
∗
Mike Rosulek
Oregon State University
Corvallis, Oregon
rosulekm@eecs.
oregonstate.edu
Ye Zhang
Google
Mountain View, CA
PI:EMAIL
†
ABSTRACT
Many deployments of secure multi-party computation (MPC)
in practice have used information-theoretic three-party pro-
tocols that tolerate a single, semi-honest corrupt party, since
these protocols enjoy very high eﬃciency.
We propose a new approach for secure three-party compu-
tation (3PC) that improves security while maintaining prac-
tical eﬃciency that is competitive with traditional information-
theoretic protocols. Our protocol is based on garbled circuits
and provides security against a single, malicious corrupt
party. Unlike information-theoretic 3PC protocols, ours uses
a constant number of rounds. Our protocol only uses inex-
pensive symmetric-key cryptography: hash functions, block
ciphers, pseudorandom generators (in particular, no obliv-
ious transfers) and has performance that is comparable to
that of Yao’s (semi-honest) 2PC protocol.
We demonstrate the practicality of our protocol with an
implementation based on the JustGarble framework of Bel-
lare et al. (S&P 2013). The implementation incorporates
various optimizations including the most recent techniques
for eﬃcient circuit garbling. We perform experiments on
several benchmarking circuits, in diﬀerent setups. Our ex-
periments conﬁrm that, despite providing a more demanding
security guarantee, our protocol has performance compara-
ble to existing information-theoretic 3PC.
1.
INTRODUCTION
Secure multi-party computation (MPC) allows a set of
parties to compute a function of their joint inputs without
revealing any information beyond the output of the func-
tion they compute. MPC has found numerous applications
not only enabling various privacy-preserving tasks on sen-
sitive data, but also removing a single point of attack by
∗Supported by NSF award CCF-1149647.
†Most of the work done while an Intern at Yahoo Labs! and
a PhD student at Penn State.
Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proﬁt or commercial advantage and that copies
bear this notice and the full citation on the ﬁrst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciﬁc
permission and/or a fee.
CCS’15 October 12 - 16, 2015, Denver, CO, USA
Copyright is held by the owner/author(s). Publication rights licensed to
ACM. ACM 978-1-4503-3832-5/15/10/$15.00
DOI: http://dx.doi.org/10.1145/2810103.2813705 .
allowing for distribution of secrets and trust while main-
taining the original functionality. Since the seminal work of
[Yao86, GMW87] showing its feasibility in the two-party and
multi-party settings, MPC has been the subject of extensive
research, focusing on bettering security and eﬃciency.
The case of three-party computation (3PC) where the ad-
versary corrupts at most one party (honest majority) is an
important special case that has received particular atten-
tion. It has been the subject of active research, implementa-
tion and optimization in frameworks such as VIFF [Gei07],
Sharemind [BLW08], ShareMonad [LDDAM12, LADM14]
and MEVAL [CMF+14]. These protocols have been used in
a wide range of applications such as statistical data analy-
sis [BTW12], and email ﬁltering [LADM14]. They have also
been deployed in practice for online beet auctions [BCD+09]
and for ﬁnancial data analysis [BTW12]. A main reason for
popularity of 3PC with-one-corruption is the simplicity and
eﬃciency of the resulting protocols.
In particular, proto-
cols designed in this setting can be signiﬁcantly more eﬃ-
cient than their two-party counterparts (or dishonest major-
ity protocols in general) since they are commonly based on
secret-sharing schemes and hence only require arithmetic op-
erations that are considered faster than cryptographic ones.
However, the secret-sharing-based solutions have several
drawbacks.
In particular, the round complexity of these
protocols is proportional to the circuit-depth of the com-
putation being performed, which can be high in practice.
Also, to the best of our knowledge, With the exception of
[IKHC14], existing implementations are only secure against
semi-honest adversaries. Traditionally, one may be willing
to settle for semi-honest security given that security against
active cheating (malicious adversaries) has a reputation of
requiring signiﬁcant overhead. Our work shows that this im-
pression need not be true, and that malicious security can in
fact be obtained with little to no overhead over semi-honest
security in the 3-party setting.
1.1 Our Contributions
We design a new protocol for 3PC with one corruption
based on Garbled Circuits (GC) [Yao82, LP09, BHR12b].
Our protocol is constant-round and secure against a mali-
cious adversary that corrupts one party. Unlike the standard
approach of applying cut-and-choose techniques for compil-
ing GC-based protocols into malicious 2PC, we show that
in the setting of 3PC with one corruption one can avoid the
cut-and-choose paradigm and achieve malicious security at
a cost similar to semi-honest two-party constructions. We
591also avoid the use of public-key operations such as Oblivious
Transfer.
We prove our protocol secure in the Universal Compos-
ability (UC) model, but avoid the use of expensive UC-
secure primitives due to the honest-majority setting. The
only cryptographic tools we require are a secure garbling
scheme and a non-interactive (standalone-secure) commit-
ment scheme, both of which can be instantiated using sym-
metric key primitives.
Our protocol does not achieve fairness, and we leave it
open to design a protocol with similar level of eﬃciency that
also achieves fairness (a feasible goal in the honest majority
setting).
We implement our protocol by enhancing the implemen-
tation of JustGarble [BHKR13] in various ways and incor-
porating the state-of-the-art “half-gates” garbling scheme of
[ZRE15]. We further reduce communication (which our ex-
periments show to be the bottleneck), by a factor of two
using a hashing technique described in Section 3.4. We
run experiments evaluating benchmarking circuits such as
AES/MD5/SHA1/SHA256, and with diﬀerent communica-
tion techniques turned on/oﬀ. Our experimental results con-
ﬁrm that our construction is competitive with prior work
in the same setting while achieving the stronger malicious
security. They also conﬁrm that communication remains
the major bottleneck in GC-based constructions even in the
three-party setting. We also explore a motivating applica-
tion we call distributed credential encryption service, that
naturally lends itself to an oﬄine pre-processing stage. Our
experiments show that the online phase can be very fast.
1.2 Related Work
The most relevant line of work to ours are MPC construc-
tions with an honest majority. Starting with seminal work
of [BOGW88, CCD88] a large body of work has studied
round and communication complexity of such protocols. A
main building block for achieving security against a mali-
cious adversarie in these constructions is veriﬁable secret
sharing (VSS) [BOGW88, RBO89]. While these construc-
tions are quite eﬃcient and avoid cryptographic operations,
their practical eﬃciency and the constant factors are not
fully examined. The one implementation of 3PC with mali-
cious security we know of is [IKHC14]. Their work proposes
an approach for compiling a semi-honest 3PC into a mali-
cious one with a small overhead (we discuss the overhead
in more detail in the experiment section). The other exist-
ing implementations we know of are based on customized
3PC frameworks provided in [BLW08, LDDAM12, ZSB13,
CMF+14] which only provide security against semi-honest
adversaries. We provide a more detailed comparison with
this line of work in the experiment section. Another cus-
tomized 3PC based on garbled circuits, using the cut-and-
choose paradigm and distributed garbling, was introduced
in [CKMZ14]. Their protocol considers the stronger two-
corruption setting and is naturally more expensive.
The more general multiparty and constant-round variant
of Yao’s garbled circuit was also studied in both the semi-
honest setting [BMR90], and the malicious setting [DI05,
IKP10]. An implementation exists [BDNP08] for the semi-
honest case. These protocols are conceptually based on gar-
bled circuits but require a particular instantiation of garbled
circuits that expands the wire-labels through secret-sharing.
We leave it as interesting open work to investigate whether
recent optimizations to standard garbled circuits can be sim-
ilarly applied to these protocols, and to compare the practi-
cal eﬃciency of malicious-secure variants.
In concurrent and independent work, Ishai et al. [IKKPC15]
describe eﬃcient, constant-round secure computation proto-
cols for 3 and 4 parties, tolerating 1 malicious corruption.
Both their protocol and ours use as a starting point the pro-
tocol of Feige et al. [FKN94] in the private simultaneous mes-
sages (PSM) setting, which is in turn based on Yao’s garbled
circuit construction. The two protocols ([IKKPC15] and
ours) use incomparable techniques to strengthen the PSM
protocol against one malicious participant, and achieve a dif-
ferent mix of properties. In the 3-party setting, [IKKPC15]
achieve a 2-round protocol whose cost is essentially that of 3
garbled circuits, whereas our protocol requires 3 rounds (in
its random oracle instantiation) and has cost of 1 garbled
circuit. In the 4-party setting, [IKKPC15] achieve guaran-
teed output delivery as well.
Fast implementation of malicious 2PC and MPC in the
dishonest majority setting include cut-and-choose solutions
based on garbled circuits [LPS08, KS12, FN13, AMPR14],
OT-based solutions [NNOB12, LOS14], and implementa-
tions in the pre-processing models [DKL+12, DKL+13]. These
protocols resists a larger fraction of coalition of corrupted
parties than ours, but are signiﬁcantly less eﬃcient.
1.3 Organization
The building blocks used in our protocols such as a gar-
bling scheme, commitment schemes and coin-tossing are all
deﬁned and described in Section 2. Our main construction
and its security proof are described in Section 3. Our imple-
mentation, experimental results, and comparison with other
implementations can be found in Section 4. We discuss the
distributed encryption service application in Section 5.
2. PRELIMINARIES
2.1 Secure MPC: UC Framework
We deﬁne security of multi-party computation using the
framework of Universal Composition (UC) [Can01]. We give
a very brief overview here, and refer the reader to [Can01]
for all of the details.
An execution in the UC framework involves a collection
of (non-uniform) interactive Turing machines. In this work
we consider an adversary that can statically (i.e., at the be-
ginning of the interaction) corrupt at most one party. We
consider security against active adversaries, meaning that a
corrupt party is under complete control of the adversary and
may deviate arbitrarily from the prescribed protocol. The
parties exchange messages according to a protocol. Protocol
inputs of uncorrupted parties are chosen by an environment
machine. Uncorrupted parties also report their protocol out-
puts to the environment. At the end of the interaction, the
environment outputs a single bit. The adversary can also
interact arbitrarily with the environment — without loss of
generality the adversary is a dummy adversary which simply
forwards all received protocol messages to the environment
and acts in the protocol as instructed by the environment.
Security is deﬁned by comparing a real and ideal interac-
tion. Let real[Z,A, π, k] denote the ﬁnal (single-bit) out-
put of the environment Z when interacting with adversary
A and honest parties who execute protocol π on security
592parameter k. This interaction is referred to as the real in-
teraction involving protocol π.
In the ideal interaction, parties run a “dummy protocol”
in which they simply forward the inputs they receive to an
uncorruptable functionality machine and forward the func-
tionality’s response to the environment. Hence, the trusted
functionality performs the entire computation on behalf of
the parties. Let ideal[Z,S,F, k] denote the output of the
environment Z when interacting with adversary S and hon-
est parties who run the dummy protocol in presence of func-
tionality F on security parameter k.
We say that a protocol π securely realizes a functional-
ity F if for every adversary A attacking the real interaction
(without loss of generality, we can take A to be the dummy
adversary), there exists an adversary S (called a simulator)
attacking the ideal interaction, such that for all environ-
ments Z, the following quantity is negligible (in k):
(cid:12)(cid:12)(cid:12) Pr(cid:2)real[Z,A, π, k] = 1(cid:3) − Pr(cid:2)ideal[Z,S,F, k] = 1(cid:3)(cid:12)(cid:12)(cid:12).
Intuitively, the simulator must achieve the same eﬀect (on
the environment) in the ideal interaction that the adversary
achieves in the real interaction. Note that the environment’s
view includes (without loss of generality) all of the messages
that honest parties sent to the adversary as well as the out-
puts of the honest parties. Thus the deﬁnition captures both
the information that an adversary can learn about honest
parties’ inputs as well as the eﬀect that an adversary can
have on the honest parties’ outputs.
In a secure protocol
these capabilities cannot exceed what is possible in the ideal
interaction.
Target functionality.
The code of the functionality F implicitly deﬁnes all of the
properties that comprise the security required of a protocol
π. In Figure 1 we deﬁne the ideal functionality Ff for secure
3-party computation of a function f .
Input collection. On message (input, xi) from a
party Pi (i ∈ {1, 2, 3}), do the following:
if a pre-
vious (input,·) message was received from Pi, then
ignore. Otherwise record xi
internally and send
(inputfrom, Pi) to the adversary.
Computation. After all 3 parties have given input,
compute y = f (x1, x2, x3).
If any party is corrupt,
then send (output, y) to the adversary; otherwise
send (output, y) to all parties.
Unfair output. On message deliver from the ad-
versary, if an identical message was received before,
then ignore. Otherwise send (output, y) to all honest
parties.
Figure 1: Ideal functionality Ff for secure 3-party
computation of a function f .
In particular, Ff provides “security with abort” (i.e., un-
fair output) in which the adversary is allowed to learn its
output from the functionality before deciding whether the
uncorrupted parties should also receive their output.
Contrasting active and semi-honest security.
When one party (say, P1) is actively corrupt, it may send
unexpected messages to an honest party (say, P3). This may
have the eﬀect that P3’s view leaks extra information about
the other honest party P2. We note that this situation is in-
deed possible in our protocol (for example, P1 can send to P3
the seed used to generate the garbled circuit, which allows
everyone’s inputs to be computable from P3’s view). How-
ever, we emphasize that this is not a violation of security in
the 1-out-of-3 corruption case.
A protocol with malicious security must let the honest par-
ties handle “unexpected” messages appropriately. The secu-
rity deﬁnition only considers what eﬀect such “unexpected”
messages have on the ﬁnal output of an honest party, but not
the eﬀect they have on the view of an honest party. More
precisely, if P3 is honest, then only his ﬁnal protocol output
is given to the environment, while his entire view is not. A
participant who hands its entire view over to the environ-
ment must be at least semi-honest corrupt, but in our case
only one party (P1 in our example) is assumed to be corrupt
at all. We leave as an open problem to achieve security in
the presence of one active and one semi-honest party (simul-
taneously), with comparable eﬃciency to our protocol.
We also emphasize that our primary point of comparison
is against existing 3PC protocols that tolerate 1 semi-honest
corruption. In these protocols, a single, actively corrupt par-