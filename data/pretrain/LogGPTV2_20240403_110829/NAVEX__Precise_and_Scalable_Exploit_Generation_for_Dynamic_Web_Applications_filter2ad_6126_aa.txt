title:NAVEX: Precise and Scalable Exploit Generation for Dynamic Web Applications
author:Abeer Alhuzali and
Rigel Gjomemo and
Birhanu Eshete and
V. N. Venkatakrishnan
NAVEX: Precise and Scalable Exploit Generation 
for Dynamic Web Applications
Abeer Alhuzali, Rigel Gjomemo, Birhanu Eshete,  
and V.N. Venkatakrishnan, University of Illinois at Chicago
https://www.usenix.org/conference/usenixsecurity18/presentation/alhuzali
This paper is included in the Proceedings of the 
27th USENIX Security Symposium.
August 15–17, 2018 • Baltimore, MD, USA
ISBN 978-1-939133-04-5
Open access to the Proceedings of the 27th USENIX Security Symposium is sponsored by USENIX.NAVEX: Precise and Scalable Exploit Generation for Dynamic Web
Applications
Abeer Alhuzali, Rigel Gjomemo, Birhanu Eshete, and V.N. Venkatakrishnan
University of Illinois at Chicago
{aalhuz2, rgjome1, eshete5, venkat}@uic.edu
Abstract
Modern multi-tier web applications are composed of sev-
eral dynamic features, which make their vulnerability
analysis challenging from a purely static analysis per-
spective. We describe an approach that overcomes the
challenges posed by the dynamic nature of web applica-
tions. Our approach combines dynamic analysis that is
guided by static analysis techniques in order to automat-
ically identify vulnerabilities and build working exploits.
Our approach is implemented and evaluated in NAVEX, a
tool that can scale the process of automatic vulnerability
analysis and exploit generation to large applications and
to multiple classes of vulnerabilities. In our experiments,
we were able to use NAVEX over a codebase of 3.2 mil-
lion lines of PHP code, and construct 204 exploits in the
code that was analyzed.
1
Modern web applications are typically designed as multi-
tier applications (i.e., client, server, and database). They
include many dynamic features, which generate content
”on the ﬂy” based on user interaction and other inputs.
Such dynamism helps the usability as well as the respon-
siveness of the application to the user. These features,
however, increase the complexity of web applications
and raise the difﬁculty bar of analyzing their security.
Introduction
Currently, several approaches exist for analyzing the
security of modern web applications such as [9, 15, 18,
29]. These approaches use a series of analysis techniques
to identify vulnerabilities such as SQL Injection (SQLI)
and Cross-Site Scripting (XSS). However, a drawback
of these approaches is that they generate false alarms,
therefore require manual efforts to check whether each
one of the reported vulnerabilities is indeed exploitable.
Other approaches take a further step and try to include
methods for automatically verifying that vulnerabilities
are true by generating concrete exploits [7, 25, 27, 32].
However, these approaches use largely static analysis
methods. While static analysis methods can provide
good coverage of an application, they often sacriﬁce pre-
cision due to technical challenges related to handling
complex program artifacts, which is one of the main rea-
sons for generating false positives. In particular, static
analysis is challenging in the context of the dynamic fea-
tures of web applications, where content (e.g., forms,
links, JavaScript code) is often generated on the ﬂy, and
the code is executed at different tiers, whose effects are
difﬁcult to model statically.
In this paper, our main contribution is a precise ap-
proach for vulnerability analysis of multi-tier web appli-
cations with dynamic features. Rather than following a
strictly static analysis strategy, our approach combines
dynamic analysis of web applications with static analy-
sis to automatically identify vulnerabilities and generate
concrete exploits as proof of those vulnerabilities. The
combination of dynamic and static analysis provides sev-
eral beneﬁts. First, the dynamic execution component
greatly reduces the complexity faced by the static anal-
ysis by revealing run-time artifacts, which do not need
to be modeled statically. On the other hand, the static
analysis component guides its dynamic counterpart in
maximizing the coverage of the application by analyzing
application paths and providing inputs to exercise those
paths. Second, our approach scales to very large applica-
tions (e.g., 965K LOC), surpassing signiﬁcantly the state
of the art. The main reason for the increased scalability is
the ability of the dynamic execution component to reduce
the complexity faced by the static analysis component.
An additional goal of our approach is that of enabling
automatic exploit generation for different classes of vul-
nerabilities with minimal analysis setup overhead. To
achieve this goal, our approach was designed with sev-
eral analysis templates and an attack dictionary that is
used to instantiate each template. There exist other static
approaches that try to achieve such generality for identi-
fying vulnerabilities [9, 15]. However, our approach ex-
tends [9] by (a) applying precise dynamic analysis tech-
niques and (b) automatically generating exploits for the
USENIX Association
27th USENIX Security Symposium    377
identiﬁed vulnerabilities.
Our approach is implemented in a tool called NAVEX.
NAVEX’s operations are divided into two steps. In the
ﬁrst step, we create a model of the behavior of individual
modules of a web application using symbolic execution.
To address the scalability challenge, we prioritize only
those modules that contain potentially vulnerable sinks
where an attacker ‘may’ be successful in injecting mali-
cious values or in exploiting other types of vulnerabili-
ties, and analyze them further in the successive search.
In the second step, we construct the actual exploits.
This requires modeling the whole application and dis-
covering a sequence of HTTP requests that take an appli-
cation to execute a vulnerable sink. To address the scala-
bility challenge in this phase, we perform dynamic anal-
ysis of a deployed application and use a web crawler and
a concolic executioner on the server-side to uncover pos-
sible HTTP navigation paths that may lead the attacker
to the vulnerable sink. To maximize the coverage of the
code during dynamic analysis, the crawler and concolic
executioner are aided by a constraint solver, which gen-
erates the (exploit) sequence of HTTP inputs.
Our contributions in NAVEX include an exploit gen-
eration framework that can easily scale to large appli-
cations and many classes of vulnerabilities and a novel
method that combines dynamic execution and static
analysis to address scalability issues affecting previous
works, mainly due to the dynamic features of web appli-
cations.
We evaluate NAVEX on 26 applications having a total
of 3.2M SLOC and 22.7K PHP ﬁles. NAVEX was able to
analyze the applications and generated 204 exploits, in
little under 6.5 hours. Of these exploits, 195 are related
to SQLI and XSS, while 9 are related to logic vulnera-
bilities, such as Execution After Redirect (EAR) vulner-
abilities. We note that NAVEX is the ﬁrst reported work
in the literature to construct exploits for EAR vulnerabil-
ities.
This paper is organized as follows. Section 2 discusses
a running example to highlight challenges and provides
an overview of NAVEX, Architectural and algorithmic
details of NAVEX are discussed in Section 3. Section
4 contains details about the implementation, Section 5
describes the evaluation of NAVEX, and Section 6 dis-
cusses the related work. Finally, Section 7 contains the
conclusions.
2 Challenges and Approach Overview
In this section, we use a running example to highlight
the challenges addressed in this paper. We then present
an overview of NAVEX.
2.1 Running Example
Listings 1-3 present a simple book borrowing web ap-
plication, which will be used throughout this paper to
illustrate our approach. Books can be selected through
the web form in selectBooks.php module (lines 23-38
in Listing 1). SelectBooks.php validates some of the
user input using JavaScript (lines 31-36). The user in-
put is further validated and sanitized by server-side code
(lines 4-12). Next, the module queries the database to
check the book availability (line 17). Based on the query
results, $ SESSION[’ISBN’] is initialized and an HTTP
link to hold.php is printed on the browser.
1  Hold the
Book";
}
21
22 ?>//client-side code starts
23 "
onsubmit="validate()">
 //drop-down list
Intro to
CS
Intro to
Math..
24
25
26
27
28
29
30 
31 
32 function validate() { //validates form upon submission
var edition = document.getElementsByName("edition");
33
if(edition.value 
return false; // do not submit the form
return true; //submit the form
Listing 1: selectBooks.php, ﬁnd books to borrow.
Hold.php (Listing 2) performs additional checks and,
if they are satisﬁed, an HTTP link guides the user
to the next step (line 7). When the link is clicked
the superglobal $ GET[’step’] is set and the module
checkout.php is therefore included by hold.php and
executed. Checkout.php completes the borrowing pro-
cess by providing a link (line 19) to the user for conﬁr-
mation. The link sets two superglobals ($ GET[’step’]
and $ GET[’msg’]), which will be checked by the mod-
ule (line 6). Finally, a conﬁrmation function (line 13) is
378    27th USENIX Security Symposium
USENIX Association
called to notify the user that the book was successfully
reserved.
1 
Checkout";
if (isset($_GET[’step’]) && $_GET[’step’] == "checkout")
include_once( "checkout.php");
}
8
9
10
11 ?>
Listing 2: hold.php, hold books for pickup.
header( "Location: index.php" );
exit();
1 sql_fetchrow($result);
$msg = $_GET[’msg’];
confirm($name, $msg);
8
9
10
11
12 }
13 function confirm($name, $msg){
14
15
16
17 ?> //client-side code starts
18 
19 DONE
20 
if (isset($name) && isset($msg) )
echo $name. " you are ".$msg; // XSS vulnerability
}
Listing 3: checkout.php, checkout functionality.
The example contains sensitive sinks that are vul-
nerable to injection and logic attacks. For example,
the query in listing 1 (line 17) is vulnerable to SQLI
through the variable $publisher, which is not prop-
erly sanitized before reaching the sink. In particular, the
str replace function (line 13) does a poor job of san-
itizing $publisher, since an SQLI attack not involving
double quotes may still be used. Additionally, the echo
call in Listing 3 is vulnerable to XSS as the user input
$msg is not sanitized. Finally, the sink at Listing 1 line 3
is vulnerable to an Execution After Redirect (EAR) logic
attack because the execution after the header call (redi-
rects the execution to another PHP module) does not halt
since there is no call to an execution termination function
afterward. Consequently, the following statements will
be executed regardless of the check at line 2. The prob-
lem is further exacerbated by the fact that those state-
ments contain a vulnerable SQL query. An attacker may
thus be able to run a SQLI exploit without needing to log
in ﬁrst.
2.2 Challenges
As illustrated by the example, typical web applications
have client-side logic that consists of forms, links, and
JavaScript code, which may be dynamically generated
by the server-side code, as well as a complex server-
side logic that frequently interacts with the client-side
and with the database backend. Therefore, building an
exploit generation framework that uncovers a wide range
of different types of exploits for dynamic web applica-
tions is non-trivial. Speciﬁcally, we identify the follow-
ing challenges:
Sink reachability.
In web applications, some tasks/-
functionalities require a series of steps, and there are de-
pendencies that exist between these tasks. These steps
are usually accomplished using different modules where
the state of the application, maintained through the use
of global constructs (e.g., $ GET[] in PHP), is updated
to reﬂect the completion/failure of a step.
If a sensi-
tive sink is located deep in these interrelated modules,
the challenge is to automatically generate an exploit that
navigates through the complex dependencies among ap-
plication modules while satisfying constraints required at
each junction in the navigation. For instance, a success-
ful exploit for the vulnerable echo in Listing 3, must con-
sider navigation and constraint satisfaction through the
modules selectBooks.php, hold.php, index.php
(not shown in the example), and checkout.php.
More broadly, we must take into account several fac-
tors. First, data ﬂow paths from sources to sensitive
sinks must be identiﬁed. Next, possible data sanitiza-
tions along those paths must be analyzed. However, san-