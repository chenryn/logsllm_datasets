Binary 自动分析的那些事
YSc
2016/07/22
2
●
当你拿到一个 binary ...
3
●
当你拿到一个 binary ...
–
file binary
–
ltrace
–
gdb
–
IDA
–
...
4
●
当你拿到一个 binary ...
–
file binary
–
ltrace
–
gdb
–
IDA
–
...
5
●
当你拿到一个 binary ...
–
file binary
–
ltrace
–
gdb
–
IDA
–
...
6
●
一条一条看，一条一条算
●
用工具（ z3 ）来算
●
整支程式自动跑自动算
7
这个议程在干麻
●
binary 自动分析的原理
●
如何用 angr 写解 CTF reverse 的脚本
●
先来谈谈要怎么自动分析，
–
符号执行（ symbolic execution ）
–
用 angr 来自动分析 binary
●
以及遇到的问题，要怎么解决？
–
符号执行的优化
–
经验谈更多 angr 用法
8
先讲个分类
●
静态分析  – IDA
●
动态分析 - GDB
9
先讲个分类
●
静态分析  – IDA
–
优点
● 程式覆盖
● 找到很多条程式执行路径
–
缺点
● 该从那开始分析？
● 怎么互动？ 
●
动态分析 - GDB
10
先讲个分类
●
静态分析  – IDA 
●
动态分析  – GDB
–
优点
● 可以观察到记忆体、暂存器
的值
● 精确的结果
–
缺点
● 程式覆盖有限
● 该怎么模拟环境？
11
先讲个分类
●
静态分析  – IDA 
●
动态分析  – GDB
–
优点
● 可以观察到记忆体、暂存器
的值
● 精确的结果
–
缺点
● 程式覆盖有限
● 该怎么模拟环境？
●
如何自动动态分析？自动找 bug ？
12
Automated Discovery
●
Fuzzing
–
随机放一堆 input 想办法让程式坏掉
●
Symbolic Execution
–
用符号变数来当作 input 而非实际的数值
13
Symbolic Execution
14
Symbolic Execution
15
Symbolic Execution
●
Dynamic analysis
●
Set symbolic values and constraints
●
Concretize to obtain a possible value
Constraints
X >= 5
X = 5)
if (x = 5)
if (x = 5
State AB
X = ???
X = 5)
if (x = 5
19
Symbolic Execution
x = get_intput();
if (x >= 5)
if (x = 5
X = 5
X >= 50
State AA
X = ???
X >= 5
20
Symbolic Execution
x = get_intput();
if (x >= 5)
if (x = 5
X = 5)
if (x >> print b.loader.find_symbol_got_entry('__libc_start_main')
>>> print b.loader.main_bin.imports
{'__gmon_start__': ,
 '__libc_start_main': ,
 '__stack_chk_fail': ,
 'fgets': ,
 'getenv': ,
 'printf': ,
 'ptrace': ,
 'puts': }
Angr - archinfo
29
Angr
●
将指令转换成中间语言 (IR) 、分析 IR 并且模拟
–
i.e., 不只知道他是什么，还知道他做了什么
●
state, symbolic memory, SimProcedure ...
CLE, archinfo
PyVEX, SimuVEX
Claripy
Angr
analysis
surveyors
Angr - IR
0x8000: dec eax
t0 = GET:I32(8)
t1 = Sub(t0, 1)
PUT(8) = t1
PUT(68) = 0x8001
31
Angr
●
设符号变数以及 solver 、收集限制式
●
是一个前端界面，而后端可以是各种 solver 像是 z3
CLE, archinfo
PyVEX, SimuVEX
Claripy
Angr
analysis
surveyors
32
Z3 Solver
●
微软的某项研究
●
有 python API
●
ebx = 0x1234, eax = (ebx / ecx) ^ ecx, eax = 2, ecx=?
from z3 import *
x = Int('x')
y = Int('y')
s = Solver()
s.add(x > 2, y < 10, x + y == 7)
print s.check()
# sat
m = s.model()
print m