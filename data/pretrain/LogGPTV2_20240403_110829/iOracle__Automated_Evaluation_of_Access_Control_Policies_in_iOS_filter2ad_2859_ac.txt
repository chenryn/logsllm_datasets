The prefix filter uses Apple defined variables to act as the pre-
fix of a file path. For example, the filter prefix(${HOME}/foo.txt)
requires the subject file to be the foo.txt file in the process user’s
home directory. Therefore, the rule to model this filter must refer-
ence process ownership facts and facts that determine the home
Figure 3: Privilege Levels and Kernel Attack Surface8
directories of iOS users. If the subject runs with the authority of
user mobile, the filter would match the mobile/foo.txt7 filepath.
The require-entitlement filter specifies an entitlement key-val-
ue pair and is only satisfied if the sandboxed process has the enti-
tlement key-value pair embedded in its signature. We model this
requirement by searching for entitlement facts that satisfy the filter.
If such facts do not exist, the process lacks the required entitlement.
The extension filter specifies the sandbox extension class that
must be possessed by the process in order to satisfy the filter. How-
ever, unlike the require-entitlement filter, the extension filter rep-
resents more flexibility due to the extension’s value. While the
sandbox profile can specify the extension class, the extension value
is not specified in the profile. In addition to the class, sandbox exten-
sions also have a type and a value. If the extension type is file, then
the value will be a subpath that filepaths may match. For example,
an extension value of /tmp allows access to /tmp and files inside
/tmp. We evaluate extension filters by referencing sandbox exten-
sion facts generated by dynamic analysis. The following Prolog
code is used to satisfy file type extension filters:
%The filter to satisfy is for a sandbox extension.
satisfyFilters(extension(ExtClass),_,Ext,_,file(ObjectPath)):-
%Does subject have required file type sandbox extension class?
member(extension(class(ExtClass),type("f"),value(ExtValue)),Ext),
%Does object file path match extension value?
satisfyFilters(subpath(ExtValue),_,_,_,file(ObjectPath)).
Object Context Sandbox Filters: There are sandbox filters based
on the context of the access control object. Objects include files,
network ports, and mach-services; however, for the purposes of this
paper, we only consider files. The literal filter matches an exact
file path. The subpath filter matches all file paths within a given
subpath (e.g., all files in /var/mobile/). The regex filter matches file
paths that match a given regular expression. Each of these filters
may contain variables to represent a prefix to the filepath (e.g.,
${HOME} would be replaced by the subject’s home directory when
resolving the filter. These filters are evaluated by comparing filter
values to facts about files found in the file system or the file paths
accessed during dynamic analysis.
unixAllows: For the Unix policy to allow creating a file, the parent
directory must be writable. Unix permission semantics are not
proprietary, but they are non-trivial to model. In general, the Unix
permission mechanism will allow an operation to proceed if any
of the following conditions hold: 1) the process user is root; 2) the
7/private/var/mobile/foo.txt
8Figure inspired by presentation on Pangu 9.
http://blog.pangu.io/wp-content/uploads/2016/08/us-16-Pangu9-Internals.pdf
Keyboard Sandbox, mobileContainer Sandbox, mobileSystem Sandbox, mobileNo Sandbox, mobileNo Sandbox, rootKernel Attack SurfaceLevel of Privilegeprocess user is the owner of the file and the owner has permission
to perform the operation; 3) the process user is a member of the
group that owns the file and the group owner has permission to
perform the operation; and 4) the Unix permissions allow users
other than the user owner or group owner to perform the operation.
We also model exceptions such as parent directories that are not
executable or user owners being denied access while others are
granted access (e.g., 077 Unix permissions). Our rules modeling Unix
policy decisions reference file metadata facts to get file context such
as file ownership and permission bits. These rules reference facts
on process ownership and group membership for process context.
5 CASE STUDY: iOS JAILBREAKS
A primary use case of iOracle is the discovery of policy flaws that
enable jailbreaks. In this section, we investigate four recent jail-
breaks in order to characterize the different types of policy flaws
that have enabled them. We broadly separate our discussion into
name resolution based flaws and capability based flaws. We then
conclude the section by demonstrating iOracle’s ability to direct a
security analyst to executables likely to be exploited.
5.1 Understanding iOS Jailbreaks
A jailbreak is a collection of exploits that place Apple-mandated
iOS security features (i.e., code signing, sandboxing, and Unix per-
missions) under the jailbreaker’s control. This ability to disable
security features can be abused by malware to gain persistence and
elevated privileges. For example, the Pegasus9 malware combined
a trio of exploits called Trident to jailbreak the victim’s iOS device
via a malicious web page. Jailbreaks represent a significant threat
to iOS users as well as a powerful tool for attackers.
Early jailbreaks such as L1meRain performed exploits during the
device’s boot sequence [16]. However, as of the iPhone 4S, Apple
improved hardware security and boot-time jailbreaks became less
feasible. Modern jailbreaks attack the system after it has booted,
and their components can be divided into userland exploits and
kernel exploits. Jailbreaks typically use a series of userland exploits
to reach a vulnerable kernel interface in order to deploy a kernel
exploit. Figure 3 illustrates various levels of privilege on iOS. As
the attacker gains privileges, the kernel attack surface increases.
Jailbreaks exploit a combination of policy flaws and code vulner-
abilities. For example, a code vulnerability may provide the attacker
with elevated control of a system process, but policy flaws must
still be exploited to bypass access control mechanisms. We refer to
these code vulnerabilities and policy flaws as “jailbreak gadgets”
since they can be assembled into a chain where one gadget pro-
vides the privileges or control required to exploit the next gadget.
We categorize 4 jailbreaks into 2 families and study their jailbreak
gadgets as inspiration for iOracle queries. iOracle is designed to
detect policy flaws, but it does not identify code vulnerabilities.
However, we still discuss code vulnerabilities to provide a better
understanding of the attacks.
The following survey of known jailbreaks and their gadgets is
based on Levin’s book chapters [16], conference presentations,10
blog posts,11 and our own investigations.
Due to space constraints and scope limitations, some jailbreak
gadgets have been simplified or excluded. Figures illustrating the
privilege escalation attacks discussed in the remainder of this sec-
tion are available in the Appendix A.2 (Figure 4 and Figure 5).
5.1.1 Name Resolution Based Jailbreaks iOS 7-8. The jailbreaks
in this family share the same start and goal states and primarily
use name resolution attacks to elevate their privileges. We define
the start state as a limited interface with the Apple File Conduit
Daemon (afcd), which is accessed via a computer connected to the
iOS device. This interface with afcd is a suitable starting point be-
cause it allows the creation of symlinks in Media/, a directory which
several potential confused deputies must traverse. Within userland,
we define the goal state as write access to the root partition, which
is normally mounted as read-only.
There are three layers of security between the start and goal
state that prevent the attacker from directly remounting the root
partition: 1) the limited interface with afcd only allows read and
write access to files in Media/; 2) a dedicated sandbox profile restricts
which system calls afcd can make; and 3) Unix permissions only
allow afcd to access files available to Unix user mobile.
evasi0n 7 (iOS 7): The user interface defined by afcd prevents
the jailbreaker from creating symlinks that redirect to files outside
of Media/. This symlink restriction is enforced when a symlink
is created, but no enforcement occurs when a symlink is moved.
However, when a relative symbolic link is moved, it may resolve to
a new filepath. Therefore, jailbreakers can create and then move
symlinks with ../ sequences in them to bypass this restriction.
With the interface restrictions bypassed, afcd can write through
the links to files outside of Media/, but it is still sandboxed. When
afcd is launched, it calls a sandbox initialization function to sand-
box itself. Therefore, if the export symbol for this library call is
overwritten and redirected to a different function, the sandbox will
never be applied. This technique is called export symbol redirection,
and it does not violate code signing since export symbols are not
covered by the code signature. The afcd sandbox allows it to deploy
symlinks in tmp/ and perform a name resolution attack against
installd which must traverse directories in tmp/. installd is used
as a confused deputy to modify afcd’s libraries to deploy the export
symbol redirection attack and disable afcd’s sandbox.
At this point afcd is unsandboxed, but running as the Unix user
mobile. However, a root authorized executable called CrashHouse-
keeping performs a hard coded “chown to mobile” operation on
Logs/AppleSupport. Since Logs/ is writable by mobile, afcd can re-
place AppleSupport with a link to the device file for the root partition.
This name resolution attack causes CrashHousekeeping to change
the owner of the root partition to mobile, achieving the goal state.
TaiG (iOS 8): In iOS 8, afcd can still create symbolic links in Media/.
Instead of relying on confused deputies available during normal
activity, the TaiG jailbreak exploits an obsolete, but vulnerable
executable called BackupAgent. Although BackupAgent2 has been in
use since at least iOS 4, its predecessor BackupAgent can still be
9https://info.lookout.com/rs/051-ESQ-475/images/lookout-pegasus-technical-
analysis.pdf
10https://cansecwest.com/slides/2015/CanSecWest2015_Final.pdf
11http://proteaswang.blogspot.com/2017/
found on the iOS file system. The TaiG authors reverse engineered
the protocol to communicate with BackupAgent and interfaced with
it via USB connection prompting it to perform a recovery operation.
The recovery requires BackupAgent to move files from the Media/
directory into a backup staging directory.
TaiG performs a name resolution attack by using a chain of two
different symbolic links: 1) Link1 is moved by BackupAgent into the
backup staging directory; 2) Link2 is moved by BackupAgent into the
backup staging directory passing through Link1 as the destination
of the move operation is resolved. When BackupAgent moves the
second link, it resolves the first symbolic link, effectively placing
the second link anywhere that BackupAgent can write.
Even if the root partition is read-only, the directories inside it
can be used as mount points and overwritten with attacker con-
tent by using a mounting agent as a confused deputy. Therefore,
TaiG uses BackupAgent to overwrite MobileStorageMounter’s work-
ing directory with a symlink to a directory in Media/. This name
resolution attack changes MobileStorageMounter’s working direc-
tory from a high integrity directory to a low integrity directory.
TaiG deploys malicious disk images into the new working directory
and proceeds to exploit MobileStorageMounter such that a fake disk
image is mounted over /Developer. Malicious configuration files in
the fake disk image allow more disk images to be mounted over
the root partition to achieve the goal state.
Name Resolution Insights: Before the attacker can perform a
name resolution attack, they must find an intersection of an ac-
cessible directory and a confused deputy working in the directory.
Therefore, it is useful to know which high integrity processes work
in a given directory and to know which low integrity processes can
access a given directory. In some cases, a name resolution attack can
be triaged to specific file paths (e.g., chown or chmod operations on
hard coded filepaths), so it useful to observe these operations dy-
namically or predict them statically with our backtracer. Separation
of duties limits the usefulness of each confused deputy (e.g., the
BackupAgent is unlikely to mount a partition, but MobileStorage-
Mounter can). This separation of duties allows us to use iOracle to
identify interesting executables based on rarely used, security sensi-
tive function calls. Finally, legacy code (e.g., BackupAgent) represents
a security risk as it expands the options available to attackers and
may contain vulnerabilities. Therefore, iOracle models all executa-
bles on the firmware, even those considered to be legacy code.
5.1.2 Capability Based Jailbreaks iOS 8-9. We categorize Pangu
8 and 9 as capability based jailbreaks. Instead of name resolution
attacks, these jailbreaks exploit exceptions in access control policies
for processes with specific capabilities. We define the start state as
access to the debugserver which is mounted as part of the iOS DDI
and accessible via USB connection. The container sandbox profile
is too restrictive to deploy the Pangu 8 and 9 kernel exploits, but
other profiles are less restrictive. Therefore, we define the goal state
as full control of a process that is not sandboxed with the container
profile.
Pangu 8 (iOS 8): One method of gaining control of an executable
is to have it import an attacker defined library. debugserver does
this by manipulating environment variables before launching an
executable. While debugserver in iOS 8 is sandboxed, our reversal of
its sandbox profile shows that it can execute any file outside of the
Containers/12 directory, which holds third party apps. However,
code signing requirements prevent jailbreakers from arbitrarily
injecting third party libraries into system executables.
Unfortunately for Apple, neagent (Network Extension Agent) ex-
ists outside of Containers/, has an entitlement called skip-library-
-validation, and runs with the vpn-plugins sandbox profile. In
order to support third party VPN applications, neagent uses the
skip-library-validation entitlement to bypass code signing re-
quirements when loading libraries. Therefore, debugserver is able
to modify environment variables and load the jailbreaker library
into neagent. This library provides the attacker with full control of
neagent, and the less restrictive vpn-plugins sandbox profile allows
the kernel exploit to be deployed. Thus, the goal state is achieved.
Pangu 9 (iOS 9): Apple modified the debugserver sandbox in iOS
8.2 and later such that it can only execute processes with get-task-
-allow entitlement (in Mach systems the task port can be used
for debugging). The Pangu team stated that they could not find
an executable on iOS 9 with the get-task-allow entitlement,13 but
iOracle finds that neagent on the DDI for iOS 9.0 does have the
entitlement. Regardless, the jailbreakers decided to search older
versions of iOS for executables with the entitlement and found
vpnagent (neagent’s predecessor) on the DDI for iOS 6.1. vpnagent
also uses the vpn-plugins sandbox profile, making it an ideal target
to deploy the kernel exploit.
However, vpnagent is not installed on iOS 9 and its signature is
not valid for iOS 9. It is not sufficient to install vpnagent as a third
party application because debugserver would not be able to execute
it, and the container profile would be applied to it. Therefore, the
jailbreak installs vpnagent as a system application by exploiting an
input validation vulnerability in a file moving service provided by
assetsd. Next, the jailbreak uses a disk mounting exploit to cause
MobileStorageMounter to import signatures from old disk images
into the list of acceptable signatures.
At this point, the iOS 6.1 vpnagent has been installed on iOS 9, and
its signature is now recognized by the system as valid. vpnagent does
not possess the skip-library-validation entitlement, but debug-
server can load third party libraries when debugging with the
get-task-allow entitlement. Therefore, the goal state is achieved
when debugserver executes vpnagent in debug mode and loads the
jailbreak library.
Capability Insights: The DDI, which is mounted on an iOS de-
vice via Xcode, contains several resources useful to jailbreakers and
should not be ignored. This insight is the reason iOracle uses the
DDI as a source of input for static extraction. Capability based poli-
cies should also consider older executables that have been signed
by Apple. Therefore, we created additional to scripts automatically
run iOracle queries on multiple versions of iOS. Combinations
of skip-library-validation or get-task-allow entitlements and
non-container sandbox profiles are dangerous. However, the facts
extracted by iOracle make finding these combinations trivial.
Other Modern Jailbreaks: evasi0n 6 (iOS 6), Pangu 7 (iOS 7) and
Yalu (iOS 10) are modern jailbreaks that we have not discussed in
detail. At a high level, the exploits used in evasi0n 6 are very similar
to those used in evasi0n 7 and TaiG. In iOS 7, the container profile for
12/private/var/mobile/Containers
13https://www.youtube.com/watch?v=vCLf7tdjabY
Table 2: Triage of Likely Attack Vectors and Confused Deputies Based on Known Jailbreak Gadgets
Target
Detected
Executables
on System
Executables
Detected
iOS
Version
Jailbreak
evasi0n 7
evasi0n 7
evasi0n 7
Query
chown/chmod name resolution attack confused deputy
low integrity can create files in tmp/
high integrity works in tmp/
low integrity can create files in Media/
high integrity works in Media/
triage executables with _mount symbol
capabilities for full control with non-container sandbox
capabilities for full control with non-container sandbox
capabilities for full control with non-container sandbox
∗ Pangu 9 installs an executable with required capabilities from iOS 6.1, bypassing expired signature with an exploit.
† iOracle additionally detected an executable with required capabilities on iOS 9.0 that may obviate the need to use an expired signature.
Target Executable
CrashHousekeeping
TaiG
TaiG
TaiG
Pangu 8
Pangu 9
Pangu 9
7.0
7.0
7.0
8.0
8.0
8.0
8.0
6.1∗
9.0†
Yes
Yes
Yes