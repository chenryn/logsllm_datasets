而如果只有 CVE 编号，CVE 的 References 一般会给出 issue 的短链，虽然通常该 issue 限制访问，但是仍可以通过 Gerrit
了解相关 issue 的具体修复代码，安全研究者可以根据这些修复代码对该问题进行分析，进而推测出漏洞复现代码。
难怪 Twitter 上某位研究员会说：“如果 0-Day 有 Chromium Bug Tracker 的编号，那它就不算 0-Day 了”。
##### **4.1.2 风险评估**
通常，在 Chromium 官方披露漏洞或外部已出现在野利用的案例后，应进行风险评估，主要聚两个问题：
  * 公司内哪些产品受漏洞影响？
  * 外部披露的 exp 是否能真实利用形成危害？
在获悉一个漏洞的存在后，安全人员需要评估漏洞对公司的影响如何。通常一个可利用的漏洞在披露后会马上有安全人员写出 exploit，而公开的 exploit
将导致利用门槛的大幅降低。
因此，常常需要监控公开信息渠道的 exploit 信息，例如：监控 Github、Twitter 等平台的消息。但是早在 exploit 披露前，就可以通过
Chromium Monorail 系统中的 issues、代码 CL 或者更新日志提前了解风险。
一个漏洞的影响评估流程可以按下面几步走：
**step 1**
确定存在漏洞组件为哪个部分。
**step 2**
采集使用了该组件的产品（包括：使用了嵌入式浏览器的客户端、单纯使用 v8 引擎等组件的软件、使用了 chrome headless 的服务端程序）；
有些产品仅使用 chrome 的一部分组件可能不受影响。例如：v8 就会影响所有用 Chromium 内核的产品，但 iOS 客户端如果用
JavaScriptCore，则不受影响。
**step 3**
确认使用存在漏洞组件的产品使用的版本是否受影响，如果产品本身对 chromium 进行定制化开发的情况下，难以根据版本确定，可以通过
PoC（部分场景下，可借助 Chromium 项目中的单元测试用例）进行黑盒测试或者白盒审计受影响代码是否存在，是否存在漏洞的触发路径。
**step 4**
原则上内存破坏类的漏洞在没有 exploit 公开的情况下也需要尽快修复，存在公开 exploit 的情况下，需要立即修复；有时候 exploit 使用到的
exploit 技术可能仅适用于某些版本的 chromium，但是并不代表这些版本之外的 chromium 完全没有利用的可能。
例如使用 WebAssembly 创建 RWX pages 来写入 shellcode 的技术在客户端使用的 chromium 版本不支持，但依旧存在通过
ROP 等技术来到达 RCE 的可能性。
##### **4.1.3 风险检测**
###### **4.1.3.1 黑盒测试**
V8 等组件会编写单元测试 js 文件，可以基于此修改形成页面，来通过黑盒的方式判断组件是否受对应漏洞影响。对于漏洞测试来说，这个资源也是极好的
TestCase。
以 CVE-2021-21224 为例，编写黑盒测试用例过程如下：
**step 1**
通过 Issue 编号定位到对应的 Chromium Gerrit 工单
**step 2**
定位到官方提供的、针对该漏洞的单元测试文件
**step 3 基于单元测试文件修改生成黑盒测试用例**
如果仔细观察，会发现上述单元测试代码中包含 % 开头的函数。它们是 v8 引擎内置的 runtime 函数，用于触发 v8 引擎的某些功能特性，需要在 v8
的 debug 版本 d8 命令行工具启动时，追加 --allow-natives-syntax 参数才会生效。
因此，直接将上述单元测试 js 来测试是无法准确测出是否存在漏洞的。但可以通过编写 js 代码，实现相同的效果，例如：
值得一提的是，前述漏洞的单元测试用例并不会造成浏览器 tab 崩溃，而只是输出的数值与预期不符。因此，可以看到上述单元测试用例中引入了
assertTrue、assertEquals 等断言方法，用于判断单元测试数值是否与预期相等。
如果不等，则认为存在漏洞。在进行改造时，也要一并用自己的 JavaScript 代码替换。最终，前述官方提供的测试用例可改造如下：
**step 4**
最终效果如下
###### **4.1.3.2 静态代码扫描**
如上面所述，由于 Chrome 漏洞即便在没有正式发布安全公告前，就已经有 Issue ID，且能通过 Gerrit
平台找到涉及的代码变动。因此，开发人员可以抢先在公司内部代码仓库进行全局静态代码扫描并修复问题。
**1\. 收集包含 chromium 组件的仓库**
不同的项目可能会引入 Chromium 整体或部分相关的组件，通常可结合文件名、或特定的代码片段，在公司的代码仓库中收集包含相关指纹的仓库。
**2\. 精确判断某个 Issue 对应的代码是否已修复**
以要精准扫描全局代码仓库中是否存在涉及 v8 组件的 CVE-2021-21224 的漏洞代码为例。可基于 semgrep
类方案，对公司代码仓库进行全局检查，编写静态代码扫描步骤如下：
1) 根据 Issue 号找到对应的漏洞修复代码变动
2) 确定涉及文件 representation-change.cc，存在漏洞的代码特征为
![
](https://images.seebug.org/content/images/2021/07/1e6bbd7b-a9f7-4c14-a1b8-0783cc6db35d.png-w331s)
可编写 semgrep 规则如下
![
](https://images.seebug.org/content/images/2021/07/d87d6294-3257-4868-a98e-36d8fee9ef1a.png-w331s)
调用命令扫描
![
](https://images.seebug.org/content/images/2021/07/3f967b2b-dd01-4eb7-a41c-17a86f568615.png-w331s)
最终效果如下
![
](https://images.seebug.org/content/images/2021/07/db36f47e-ae38-470e-891b-28fe01771195.png-w331s)
###### 4.1.3.3 主机Agent采集
针对部署在服务器端、且使用了Chromium的程序，除了上述方法之外，可以考虑借助HIDS、EDR或RASP等系统采集进程特征，排查存在风险的实例。
同时满足下面两个条件的 cmdline，其进程我们就可以认为是存在风险的：
  * 程序名包含 Chrome 或 Chromium
  * 且 Cmdline 中包含 --no-sandbox 参数或 --disable-setuid-sandbox
**1) 关于误报**
这里大家可能会产生疑问，这里为什么单独检测 Sandbox 的开启与关闭就判断风险呢？
若Chromium组件已经使用最新发布的commit编译而成，包含了所有的漏洞补丁，也一样不会受到1Day和NDay漏洞的影响。
其实，这里主要考虑到Chrome在对漏洞修复是十分频繁的，持续的升级存在一定的维护成本，且不排除攻击者拥有Chromium
0Day的可能。相较之下，逃逸Sandbox以控制浏览器所在的主机，是比较困难的；所以要求线上业务，尽可能开启 Chromium Sandbox特性。
**2) 关于漏报**
另外，以上方案若 Chrome 可执行文件被修改了文件名，则容易产生漏报。另一种可选的方案是：提取出多个 Chrome
的特有选项进行过滤。例如，headless 浏览器启动时一般不会导航至特定 url，此时命令行会存在 about:blank，再用 Chrome
特定的区别于其他浏览器的选项进行排除。
更复杂的方案可以提取出 Chrome 执行文件的文件特征，或者建立 Chrome 执行文件的 hashsum 数据库来判断进程的执行文件是否是 Chrome
浏览器，进而再筛选启动时用了不安全配置的进程。
其实，我们在大规模观察相关的进程数据和运营之后，发现利用 --no-sandbox 单个因素进行进程数据分析并获取未开启 Sandbox 的
Chromium 进程，这样简单粗暴的做法并不会产生太多误报；有些进程看似非 Chromium 浏览器，但其实也集成了 Chromium 并使用 no-sandbox 参数。
#### **4.2 风险修复**
##### **4.2.1 通用修复方案**
无论是客户端还是服务端，为了解决 Chrome 漏洞的远程命令执行风险，启用 Chrome Sandbox，去除启动 Chrome 组件时的 --no-sandbox 参数都是必须推进的安全实践。
如果客户端程序直接使用了 Chrome 的最新版本，且未进行过于复杂的二次开发和迁移，没有历史包袱的话，在客户端里开启 Chrome
Sandbox，其实就是使用 Chrome 组件的默认安全设计，障碍是比较小的。
此处根据不同场景和需求，存在三种不同的修复方案：
**方案 1. 启用 Sandbox**
1.启动 Chrome 时切勿使用 --no-sandbox 参数，错误的例子如：
`./bin/chrome --remote-debugging-address=0.0.0.0 --remote-debugging-port=9222