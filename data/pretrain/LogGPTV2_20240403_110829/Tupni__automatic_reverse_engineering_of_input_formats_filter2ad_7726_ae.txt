with this new signature generation system. The new system auto-
matically generated the same vulnerability signature as in [14].
None of the existing reverse engineering tools [6,12,26,42] lends
itself to the ShieldGen application because they fail to reliably iden-
tify record sequences in a sufﬁciently broad class of input formats.
In the case of WMF, without identifying record sequences, the sys-
tem will not be able to eliminate iterative elements, and the gen-
erated vulnerability signature will be particular to the attack in-
stance and may have thousands of conditions if the attack instance
is crafted with thousands of draw records. On the other hand, Tupni
can identify not only ﬁelds but also record sequences and important
constraints. Therefore, it can potentially be used to generate high-
quality vulnerability signatures.
6. RELATED WORK
Network protocols and ﬁle formats have been subject to painstak-
ing manual reverse engineering [18, 36]. Recently, there has been
rising interest in automatic protocol reverse engineering.
The Protocol Informatics Project [35] and Discoverer [12] an-
alyzed network traces to infer protocol formats. Fisher et al. [17]
have presented a system that automatically infers the structure of an
ad hoc data source and that produces a format speciﬁcation in the
PADS data description language. Speciﬁcally, the system infers
several structural relationships based on the histogram of the fre-
quencies of all tokens in the input. These systems are useful when
a parsing program is unavailable. However, leveraging a parsing
program can signiﬁcantly improve the quality of the reverse engi-
neered format.
Polyglot [6] uses dynamic data ﬂow analysis to reverse engi-
neer network message formats. With the rich information revealed
by how a program consumes an input, Polyglot can identify ba-
sic ﬁelds and certain dependencies (e.g., length ﬁelds). Compared
to Tupni, the main limitation of Polyglot is that it infers a mes-
sage format as a “ﬂat” sequence of ﬁelds, and cannot infer record
sequences that are common in network protocol and ﬁle formats.
Furthermore, Polyglot does not generalize a network message for-
mat over multiple message samples.
AutoFormat [26] reverse engineers network message formats by
using context-aware monitored execution. To identify ﬁelds, it
groups contiguous inputs accessed consecutively in a function as a
ﬁeld. This heuristic works well for ASCII strings but is likely to fail
for complex data structures. For example, different binary ﬁelds
will be clustered into a single ﬁeld if an application makes two
subsequent accesses to adjacent input ﬁelds in a function. To iden-
tify record sequences, it identiﬁes input positions that have been
read by the same functions and declares each of them to be the start
of a record. The input data between two subsequent record start
markers is considered to belong to the ﬁrst record. This heuristic
may produce arbitrary false positives when confronted with com-
plex input formats. For example, if an application accesses the ﬁrst
and the last byte of the input in the same functions, AutoFormat
will conclude that the entire input is a record sequence. It also does
not recognize nested record sequences such as those in WMF, JPG
and PNG. AutoFormat does not attempt to identify record types or
aggregate the analysis over multiple input samples.
In [42], Wondracek et al. propose a system for automatic net-
work protocol analysis. When identifying basic ﬁelds, the system
breaks an input chunk that cannot be attributed to any semantics
(e.g., delimiters, lengths) into individual bytes and thus may fail
to identify binary ﬁelds with more than one byte. For record se-
quences, the system can only identify those in which all records are
structurally identical. Therefore, it cannot identify complex record
sequences such as those in HTTP, WMF, JPG, PNG and TIF. It
also does not identify record types. Unlike Polyglot and AutoFor-
mat, the system in [42] can generalize a network message format
over multiple messages. However, its sequence alignment algo-
rithm may introduce more inaccuracies than Tupni because it does
not have type information for individual byte ﬁelds and assumes
any byte ﬁeld can be matched with any other byte ﬁeld. In contrast,
Tupni infers ﬁeld types based on the set of instructions that operate
on each ﬁeld and aligns ﬁelds based on their types.
Compared to previous efforts [6,26,42] that reverse engineer net-
work message formats by observing how a program processes net-
work messages, Tupni makes signiﬁcant advances in the follow-
ing ways: (1) It can identify arbitrary record sequences, includ-
ing nested ones, by analyzing loops in a program; (2) It can infer
ﬁeld or record types by comparing the set of instructions that pro-
cess each ﬁeld or record; (3) It can derive constraints of various,
not pre-deﬁned dependencies across ﬁelds or messages by tracking
symbolic predicates from dynamic data ﬂow analysis; (4) It can
improve its format speciﬁcations by aggregating its analysis over
multiple inputs.
In parallel to our work, Lin and Zhang [27] developed two dy-
namic analysis techniques to derive syntactic structures of inputs
with top-down or bottom-up grammars. The dynamic analysis on
inputs with top-down grammars makes the assumption that pro-
gram control dependence follows the parsing structure. However,
real-world programs may not follow this assumption (e.g., a pro-
gram may scan an input multiple times). Unlike Tupni, this system
does not attempt to aggregate the analysis over multiple inputs or
infer input constraints.
Besides using dynamic analysis, Lim et al. [25] have proposed
FFE/X86, a binary static analysis tool that infers ﬁle formats based
on the program’s output routines. The system can generate gram-
mars with alternation and repetition, but requires manual annota-
tions to the executable.
Previous work has also studied reverse engineering for speciﬁc
applications such as replay. RolePlayer [13] and ScriptGen [23,
24] leverage byte-wise sequence alignment techniques to achieve
application-level replay. Replayer [29] uses binary analysis to re-
play an application dialog. Kannan et al. semi-automatically dis-
cover session structures [22]. Christodorescu et al. perform bi-
nary static analysis to infer all possible strings at a given program
point [8].
Dynamic data ﬂow analysis has been used in many security ap-
plications, including exploit detection, patch generation, worm con-
tainment, and fuzz testing [10, 11, 14, 15, 19, 30, 31].
7. LIMITATIONS AND FUTURE WORK
In this section, we discuss the limitations of Tupni and describe
future research directions for solving these limitations.
A fundamental limitation faced by Tupni is that the coverage of
its reverse engineered format is dependent on the diversity of the
input samples. We can mitigate this limitation from two perspec-
tives. First, ShieldGen [14] and SAGE [19] have shown that one
can construct new inputs to probe a program, which leads to bet-
ter code coverage. Second, it is also possible to combine dynamic
analysis with static analysis. However, it remains a research prob-
lem to integrate them effectively for reverse engineering a complete
input format.
Another fundamental limitation in Tupni is that the constraints
identiﬁed by Tupni may be speciﬁc to the input samples, which is a
general limitation of dynamic analysis. This limitation can be mit-
igated by techniques presented in ShieldGen [14] and Bouncer [9].
Currently, Tupni does not work well for certain classes of input
formats. The ﬁrst class are formats whose ﬁeld boundaries do not
coincide with byte boundaries. This includes many encrypted and
compressed ﬁle formats. The reason is that the Tupni prototype
tracks taint at the byte level. We believe that this problem could be
resolved by a more sophisticated implementation.
Another class of inputs that causes problems for Tupni are for-
mats that cannot be described as regular expressions. For example,
attempts to generate a C language speciﬁcation by having Tupni
analyze execution traces of a compiler would most likely produce
poor results.
In addition, the quality of Tupni’s output depends on the qual-
ity of the parsing application. Applications that neglect to compute
checksums, ignore ﬁelds or deviate in other ways from the pub-
lished speciﬁcation reveal no information about those aspects of
the format speciﬁcation. This was the main cause of errors in our
experiments. Any system that attempts to use a parsing application
to obtain a format speciﬁcation faces this problem. A possible way
to mitigate this problem is to run multiple parsing applications on
the input samples.
8. CONCLUSIONS
We have presented Tupni, a tool to reverse engineer input for-
mats. Based on the observation that an application usually pro-
cesses iterative data records in a loop, Tupni can automatically
identify (nested) record sequences, and record types in input for-
mats. Tupni also can ﬁnd different types of constraints on the val-
ues of ﬁelds. Furthermore, Tupni can generalize input formats over
multiple inputs. We have demonstrated that Tupni can effectively
reverse engineer 10 common, real-world ﬁle and network message
formats. Given the rich set of information available in the input
formats reverse engineered by Tupni, it can potentially be used for
security applications such as zero-day vulnerability signature gen-
eration.
9. ACKNOWLEDGMENTS
We would like to thank Xuxian Jiang for his valuable comments
on an early draft of this paper. We are grateful to Andrew Edwards,
Stuart de Jong and Jinlin Yang for helping us understand iDNA. We
also want to thank the anonymous reviewers for their constructive
comments.
10. REFERENCES
[1] International Telecommunication Union Recommendation
T.81: JPEG Speciﬁcation. http:
//www.w3.org/Graphics/JPEG/itu-t81.pdf.
[2] TIFF Revision 6.0. http://partners.adobe.com/
public/developer/en/tiff/TIFF6.pdf.
[3] A. Aho, M. Lam, R. Sethi, and J. Ullman. Compilers:
Principles, Techniques, and Tools. Addison-Wesley, 2007.
[4] S. Bhansali, W.-K. Chen, S. de Jong, A. Edwords, R. Murray,
M. Drinic, D. Mihocka, and J. Chau. Framework for
instruction-level tracing and analysis of program executions.
In Proceedings of the Second International Conference on
Virtual Execution Environments, Ottawa, Canada, June 2006.
[5] N. Borisov, D. J. Brumley, H. J. Wang, J. Dunagan, P. Joshi,
and C. Guo. A Generic Application-Level Protocol Analyzer
and its Language. In Proceedings of the 14th Annual
Network & Distributed System Security Symposium (NDSS),
March 2007.
[6] J. Caballero, H. Yin, Z. Liang, and D. Song. Polyglot:
Automatic Extraction of Protocol Message Format using
Dynamic Binary Analysis. In Proceedings of the 14th ACM
Conference on Computer and Communications Security,
Alexandria, VA, October 2007.
[7] B. Chandra and M. Halldórsson. Greedy local improvement
and weighted setpacking. Journal of Algorithms,
39(2):223–240, 2001.
[8] M. Christodorescu, N. Kidd, and W.-H. Goh. String analysis
for x86 binaries. 6th ACM SIGPLAN-SIGSOFT Workshop on
Program Analysis for Software Tools and Engineering
(PASTE 2005), 31(1):88–95, 2006.
[9] M. Costa, M. Castro, L. Zhou, L. Zhang, and M. Peinado.
Bouncer: Securing Software by Blocking Bad Input. In
Proceedings of the 21st ACM Symposium on Operating
Systems Principles (SOSP), pages 117–130, 2007.
[10] M. Costa, J. Crowcroft, M. Castro, and A. Rowstron.
Vigilante: End-to-End Containment of Internet Worms. In
Proceedings of the Symposium on Systems and Operating
Systems Principles (SOSP 2005), 2005.
[11] J. R. Crandall and F. T. Chong. Minos: Control Data Attack
Prevention Orthogonal to Memory Model. In Proceedigns of
the 37th Annual IEEE/ACM International Symposium on
Microarchitecture (Micro-37), Portland, OR, December
2004.
[12] W. Cui, J. Kannan, and H. J. Wang. Discoverer: Automatic
[27] Z. Lin and X. Zhang. Deriving input syntactic structure from
Protocol Reverse Engineering from Network Traces. In
Proceedings of the 16th USENIX Security Symposium,
Boston, MA, August 2007.
execution. In Proceedings of the 16th ACM SIGSOFT
International Symposiumon the Foundations of Software
Engineering, November 2008.
[13] W. Cui, V. Paxson, N. C. Weaver, and R. H. Katz.
[28] P. Mockapetris. RFC 1035: Domain Names -
Protocol-Independent Adatpive Replay of Application
Dialog. In Proceedings of the 13th Symposium on Network
and Distributed System Security (NDSS 2006), February
2006.
[14] W. Cui, H. J. Wang, M. Peinado, and M. Locasto. ShieldGen:
Automated Data Patch Generation for Unknown
Vulnerabilities with Informed Probing. In Proceedings of the
2007 IEEE Symposium on Security and Privacy, May 2007.
[15] M. D. Ernst, J. H. Perkins, P. J. Guo, S. McCamant,
C. Pacheco, M. S. Tschantz, and C. Xiao. The Daikon
System for Dynamic Detection of Likely Invariants. 2007.
[16] R. Fielding, J. Gettys, J. Mogul, H. Frystyk, L. Masinter,
P. Leach, and T. Berners-Lee. RFC 2616: Hypertext Transfer
Protocol – HTTP/1.1. http://www.w3.org/
Protocols/rfc2616/rfc2616.html.
Implementation and Speciﬁcation.
http://www.faqs.org/rfcs/rfc1035.html.
[29] J. Newsome, D. Brumley, J. Franklin, and D. Song.
Replayer: Automatic Protocol Replay by Binary Analysis. In
Proceedings of the 13th ACM Conference on Computer and
Communications Security (CCS), pages 311–321, 2006.
[30] J. Newsome, D. Brumley, and D. Song. Vulnerability-speciﬁc
execution ﬁltering for exploit prevention on commodity
software. In Proceeding of the Network and Distributed
System Security Symposium (NDSS), 2006.
[31] J. Newsome and D. Song. Dynamic Taint Analysis for
Automatic Detection, Analysis, and Signature Generation of
Exploits on Commodity Software. In Proceedings of the
12th Symposium on Network and Distributed System
Security (NDSS), February 2005.
[17] K. Fisher, D. Walker, K. Q. Zhu, and P. White. From dirt to
[32] R. Pang, V. Paxson, R. Somer, and L. Peterson. binpac: A
shovels: Fully automatic tool generation from ad hoc data. In
Proceedings of the 35th Annual Symposium on Principles of
Programming Languages, January 2008.
[18] Gaim Instant Messaging Client.
http://gaim.sourceforge.net.
[19] P. Godefroid, M. Levin, and D. Molnar. Automated
Whitebox Fuzz Testing. In Proceedings of the 15th Annual
Network and Distributed System Security Symposium
(NDSS), February 2008.
[20] T. O. Group. Dce 1.1: Remote procedure call.
http://www.opengroup.org/onlinepubs/
9629399/toc.htm.
[21] E. Hazan, S. Safra, and O. Schwartz. On the complexity of
approximating k-set packing. Computational Complexity,
15(1):20–39, 2006.
[22] J. Kannan, J. Jung, V. Paxson, and C. E. Koksal.
Semi-Automated Discovery of Application Session
Structure. In Proceedings of the 2006 Internet Measurement
Conference (IMC), Rio de Janeiro, Brazil, October 2006.
[23] C. Leita, M. Dacier, and F. Massicotte. Automatic Handling
of Protocol Dependencies and Reaction to 0-Day Attacks
with ScriptGen based Honeypots. In Proceedings of the 9th
International Symposium on Recent Advances in Intrusion
Detection, Hamburg, Germany, September 2006.
[24] C. Leita, K. Mermoud, and M. Dacier. ScriptGen: An
Automated Script Generation Tool for Honeyd. In
Proceedings of the 21st Annual Computer Security
Applications Conference (ACSAC 2005), December 2005.
[25] J. Lim, T. Reps, and B. Liblit. Extracting ﬁle formats from
executables. In S. E. Sim and M. Di Penta, editors,
Proceedings of the 13th Working Conference on Reverse
Engineering, Benevento, Italy, Oct. 23–27 2006.
[26] Z. Lin, X. Jiang, D. Xu, and X. Zhang. Automatic Protocol
Format Reverse Engineering through Context-Aware
Monitored Execution. In Proceedings of NDSS’2008, 2008.
yacc for Writing Application Protocol Parsers. In
Proceedings of the 2006 Internet Measurement Conference,
October 2006.
[33] V. Paxson. Bro: A system for detecting network intruders in
real time. Computer Networks, 31(23):2435–2463, 1999.
[34] J. Postel and J. Reynolds. Rfc 959: File transfer protocol
(ftp). http://www.faqs.org/rfcs/rfc959.html.
[35] The Protocol Informatics Project.
http://www.baselineresearch.net/PI/.
[36] How Samba Was Written. http://samba.org/ftp/
tridge/misc/french_cafe.txt.
[37] K. Sollins. Rfc 1350: The tftp protocol (revision 2).
http://www.faqs.org/rfcs/rfc1350.html.
[38] G. E. Suh, J. W. Lee, D. Zhang, and S. Devadas. Secure
Program Execution via Dynamic Information Flow Tracking.
In Proceedings of the 11th International Conference on
Architectural Support for Programming Languages and
Operating Systems (ASPLOS-XI), October 2004.
[39] T. Swan. Inside Windows File Formats. Sams Publishing,
1993.
[40] T. Boutell, et. al. RFC 2083: PNG (Portable Network
Graphics) Speciﬁcation.
http://www.faqs.org/rfcs/rfc2083.html.
[41] H. J. Wang, C. Guo, D. R. Simon, and A. Zugenmaier.
Shield: Vulnerability-Driven Network Filters for Preventing
Known Vulnerability Exploits. In Proceedings of the ACM
SIGCOMM, August 2004.
[42] G. Wondracek, C. Kruegel, E. Kirda, and P. Milani.
Automatic Network Protocol Analysis. In Proceedings of the
15th Annual Network and Distributed System Security
Symposium (NDSS), February 2008.