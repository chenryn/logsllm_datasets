title:Service Traceroute: Tracing Paths of Application Flows
author:Ivan Morandi and
Francesco Bronzino and
Renata Teixeira and
Srikanth Sundaresan
Service Traceroute: Tracing Paths
of Application Flows
Ivan Morandi1, Francesco Bronzino1(B), Renata Teixeira1,
and Srikanth Sundaresan2
{ivan.morandi,francesco.bronzino,renata.teixeira}@inria.fr
1 Inria, Paris, France
2 Princeton University, Princeton, USA
PI:EMAIL
Abstract. Traceroute is often used to help diagnose when users experi-
ence issues with Internet applications or services. Unfortunately, probes
issued by classic traceroute tools diﬀer from application traﬃc and hence
can be treated diﬀerently by routers that perform load balancing and
middleboxes within the network. This paper proposes a new traceroute
tool, called Service traceroute. Service traceroute leverages the idea from
paratrace, which passively listens to application traﬃc to then issue
traceroute probes that pretend to be part of the application ﬂow. We
extend this idea to work for modern Internet services with support for
identifying the ﬂows to probe automatically, for tracing of multiple con-
current ﬂows, and for UDP ﬂows. We implement command-line and
library versions of Service traceroute, which we release as open source.
This paper also presents an evaluation of Service traceroute when tracing
paths traversed by Web downloads from the top-1000 Alexa websites and
by video sessions from Twitch and Youtube. Our evaluation shows that
Service traceroute has no negative eﬀect on application ﬂows. Our com-
parison with Paris traceroute shows that a typical traceroute tool that
launches a new ﬂow to the same destination discovers diﬀerent paths than
when embedding probes in the application ﬂow in a signiﬁcant fraction of
experiments (from 40% to 50% of our experiments in PlanetLab Europe).
1 Introduction
Internet services and applications rely on highly distributed infrastructures to
deliver content. When applications stop working or when their performance
degrades, service providers and more sophisticated users often resort to tracer-
oute to narrow down the likely location of the problem. Traceroute issues probes
with increasing TTL to force routers along the path towards a destination to
issue an ICMP TTL exceeded message back to the source, which iteratively
reveals the IP addresses of routers in the path [4].
Traceroute, however, may fail to reveal the exact path that a given appli-
cation ﬂow traverses. For example, Luckie et al. [8] have shown that depending
on the traceroute probing method (ICMP, UDP, and TCP) the set of reached
c(cid:2) Springer Nature Switzerland AG 2019
D. Choﬀnes and M. Barcellos (Eds.): PAM 2019, LNCS 11419, pp. 116–128, 2019.
https://doi.org/10.1007/978-3-030-15986-3_8
Service Traceroute: Tracing Paths of Application Flows
117
destinations and discovered links diﬀer. The authors explain these diﬀerences by
the presence of middleboxes in the path such as load balancers and ﬁrewalls that
make forwarding decisions based on ﬂow characteristics. These results imply that
diagnosing issues on application ﬂows must ensure that traceroute probes have
the same characteristics as the application’s packets.
This paper develops a traceroute tool, called Service traceroute, to allow dis-
covering the paths of individual application ﬂows. Service traceroute passively
listens to application traﬃc to then issue probes that pretend to be part of the
application ﬂow. Some traceroute tools (for instance, paratrace [6], TCP side-
car [13], and 0trace [5]) already enable probes to piggyback on TCP connections.
These tools observe an active TCP connection to then insert traceroute probes
that resemble retransmitted packets. TCP sidecar was developed for topology
mapping, whereas paratrace and 0trace for tracing past a ﬁrewall. As such, they
lack the support for tracing paths of modern application sessions, which fetch
content over multiple ﬂows that change dynamically over time. First, these tools
provide no means to identify the set of application ﬂows to trace. They require
as input the destination IP address and the destination port to detect the target
application ﬂow. Second, they trace one target application ﬂow at a time. Finally,
these tools lack the support for tracing application ﬂows using UDP as transport
protocol, which are increasing thanks to the adoption of QUIC protocol [7].
Our work makes the following contributions. First, we develop and implement
Service traceroute (Sect. 2), which we release as open source software. Service
traceroute is capable of identifying application ﬂows to probe and of tracing the
paths of multiple concurrent ﬂows of both TCP and UDP ﬂows. For example,
a user may simply specify trace ‘Youtube’ and Service traceroute will identify
Youtube ﬂows and then trace all of their paths. Service traceroute is conﬁgurable
to cover a large variety of Internet services.
Our second contribution is to conduct the ﬁrst thorough evaluation of the
eﬀect of embedding tracetoute probes within application ﬂows. One issue with
this approach is that we may hurt application performance. Our evaluation shows
that in the vast majority of cases, Service traceroute has no side-eﬀect on the
target application (Sect. 4). Finally, we compare Service traceroute with 0Trace,
which also embeds probes within a target application ﬂow, and with Paris Tracer-
oute, which launches a new ﬂow for probing (Sect. 5). Our comparison with Paris
traceroute shows that when we launch a new ﬂow with traceroute probes we
observe a diﬀerent path in around 40% to 50% of paths depending on the appli-
cation. This diﬀerence reduces considerably for the majority of applications when
we run Paris traceroute with the same ﬂow ID as the target application ﬂow,
which shows that diﬀerences are mostly due to middleboxes that make forward-
ing decisions per ﬂow. These results highlight the need for Service traceroute,
which automatically identiﬁes the ﬂow IDs of the target application to create
probes.
118
I. Morandi et al.
2 Tool Design and Implementation
Service traceroute follows the same high-level logic as paratrace or 0trace. Given
a target application ﬂow, which we deﬁne as the application ﬂow whose path
we aim to trace, Service traceroute proceeds with two main phases. The ﬁrst
phase is the passive observation of a target application ﬂow to deﬁne the content
of the probes. Then, the second phase involves active injection of TTL-limited
probes within the application ﬂow. The main diﬀerence is that Service traceroute
identiﬁes the ﬂows to trace automatically and supports tracing paths traversed
by multiple application ﬂows concurrently. The user can either directly specify
the set of target application ﬂows or simply describe a high-level service (e.g.,
Youtube). Service traceroute will then trace paths traversed by all the ﬂows
related to the target service. This section ﬁrst describes the two phases focus-
ing on the new aspects of Service traceroute to allow per service tracing and
then presents our implementation. Library and command-line versions of Ser-
vice traceroute, together with the scripts to perform data analysis are available
as open source projects [1].
2.1 Observation of Target Application Flow
Service traceroute passively observes traﬃc traversing a network interface to
search for packets with the ﬂow-id of the target application ﬂows.1 Service tracer-
oute takes a set of target application ﬂows as input, in contrast with previous
tools which can only trace the path traversed by one single application ﬂow.
Users can either explicitly specify one or more target application ﬂows or they
can simply specify a service. Service traceroute uses a database of signatures of
known services to inspect DNS packets in real-time and identify ﬂows that match
the target service. We release the DB as open source, so users can contribute to
add or update the signatures in the database [1]. We deﬁne as signature the set
of domains and IP addresses corresponding to a speciﬁc service. For instance,
‘google.com’ or the corresponding IP addresses can be used in the signature to
detect Google services. Our current database has signatures for popular video
streaming services such as Netﬂix, Youtube, and Twitch. We identify web ﬂows
simply from the domain or the host name given as input. For additional ﬂexibil-
ity, it is possible to add domains and IP addresses via command line parameters
or through the library API.
2.2 Path Tracing
Only once it identiﬁes a packet belonging to the target application ﬂow, Service
traceroute will start the tracing phase. This phase works as classic traceroute
implementations sending probes with increasing TTL, but Service traceroute
creates a probe that takes the form of an empty TCP acknowledgement that
1 We use the traditional 5-tuple deﬁnition of a ﬂow (protocol, source and destination
IP, as well as source and destination port).
Service Traceroute: Tracing Paths of Application Flows
119
copies the 5-tuple of the ﬂow as well as its sequence number and acknowledge-
ment number (similar to paratrace and 0trace). We rely on the ﬂow-id plus the
IPID ﬁeld to match issued probes with the corresponding ICMP responses. We
note that this is suﬃcient to correctly identify probes even when tracing mul-
tiple concurrent target application ﬂows. The maximum number of concurrent
target application ﬂows varies based on the used conﬁguration as the IPID ﬁeld
is dynamically sliced based on the number of probes that have to be generated.
For example, with traceroute standard parameters, i.e. maximum distance of
32 and 3 packets per hop, Service traceroute can trace paths of more than 600
target application ﬂows in parallel.
Service traceroute stops tracing when the target application ﬂow closes to
avoid any issues with middleboxes (which may interpret probes after the end of
the connection as an attack) and also to reduce any network and server overhead.
In contrast to prior tools that only support TCP, we add support for UDP. In
this case, we create probes with empty UDP payload, but with the same 5-tuple
ﬂow-id as the target application ﬂow. Given UDP has no explicit signal of the
end of the ﬂow (like the FIN in TCP), we stop tracing if the ﬂow produces no
further packets (either received or sent) after a conﬁgurable time interval.
2.3 Implementation
We implement Service traceroute in Go and release command-line and library
versions. The command-line version is useful for ad-hoc diagnosis, whereas the
library allows easy integration within monitoring systems. The library version
of Service traceroute outputs a json data structure that contains the discovered
interfaces with the observed round-trip-time values. For the command line ver-
sion, Service traceroute shows the results of each trace in the traceroute format,
i.e., the list of hops with the corresponding round-trip times.
Service traceroute is conﬁgurable to adapt to diﬀerent applications. It
includes three types of probing algorithms that capture the tradeoﬀ between
tracing speed and network overhead. PacketByPacket sends only one probe at
a time. HopByHop sends a conﬁgurable number of probes with the same TTL
at a time (3 by default). Concurrent sends all probes to all hops at once. Given
that Service traceroute requires the target application ﬂow to be active dur-
ing tracing, some applications with short ﬂows (e.g., Web) require the higher
overhead of Concurrent to complete all the probes within the ﬂow duration. Ser-
vice traceroute also allows conﬁguring the number of probes for each TTL, the
inter-probe time, and inter-iteration time (i.e., the time between packets with
diﬀerent TTL) to further control the tradeoﬀ between tracing speed and over-
head. Finally, Service traceroute allows to specify three types of stop conditions:
the maximum distance from the source, the maximum number of non-replying
hops, like Paris Traceroute, or explicit stop points in the form of IP addresses.
The stop condition is particularly important for Service traceroute because the
destination host will never respond with an ICMP error message as probes are
part of the target application ﬂow.
120
I. Morandi et al.
Following extensive calibration tests (reported in Sect. 3), we set Service
traceroute to use as default the Concurrent mode, together with a maximum
distance of 32 and 3 probes per hop.
3 Evaluation Method
We design our evaluation around two questions. First, does Service traceroute
aﬀect the target application ﬂows? Service traceroute injects new packets within
the application ﬂow. Although the majority of these packets will be discarded
before they reach the servers, a few probe packets will reach the end-host and
can potentially aﬀect the target application ﬂows. Second, do paths discovered