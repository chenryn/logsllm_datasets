# OCR Output
## Page 1
越感兴趣，一些问题开始频繁地出现在我的脑海中，比如：
Redis命令就能够实现了，整个模块的可读性得到了极大的提高。
快，更重要的是，之前需要使用一段甚至一大段SQL查询才能实现的功能，现在只需要调用一两个
合数据类型，并用它重新实现了整个用户关系模块：重写之后的关系模块不仅代码量更少，速度更
关注功能。
集合执行交集、并集、差集等集合计算操作，其中的交集计算操作可以直接用于实现我想要的共同
发现了Redis。在我看来，Redis正是我想要找的那种数据库—它内置了集合数据类型，并支持对
导致交集操作的实现变得异常复杂。
对两个数据表执行合并（join）操作之外，还需要对合并的结果执行去重复（distinct）操作，最终
当头一棒：我所使用的关系数据库并不直接支持交集计算操作，要计算两个集合的交集，除了需要
个概念是如此的常见，所以我很自然地认为共同关注这个功能可以很容易地实现，但现实却给了我
都关注了peter和tom”这样的信息。
注”功能，用于计算出两个用户关注了哪些相同的用户。
自此之后，我开始在越来越多的项目里面使用Redis，与此同时，我对Redis的内部实现也越来
是否存在直接支持集合操作的数据库呢？带着这个疑问，我在搜索引擎上面进行查找，并最终
从集合计算的角度来看，共同关注功能本质上就是计算两个用户关注集合的交集，因为交集这
口Redis的一部分命令只能对特定数据类型执行（比如APPEND只能对字符串执行，HSET
得益于Redis本身的简单性，以及Redis手册的详尽和完善，我很快学会了怎样使用Redis的集
举个例子，假设huangz关注了peter、tom、jack三个用户，而john关注了peter、tom、bob、
口Redis的五种数据类型分别是由什么数据结构实现的？
时间回到2011年4月，当时我正在编写一个用户关系模块，这个模块需要实现一个“共同关
Redis的字符串数据类型既可以存储字符串（比如"helloworld"），又可以存储整数和
样存储这些值的？
浮点数（比如10086和3.14），甚至是二进制位（使用SETBIT等命令），Redis在内部是怎
前
---
## Page 2
N
模型），而且还介绍了大部分Redis单机特性（比如事务、持久化、Lua脚本、排序、二进制位操
的《Redis 设计与实现》。本书不仅介绍了Redis的内部机制（比如数据库实现、类型系统、事件
关于二进制位操作（bitop）、排序、复制、Sentinel和集群等主题的新章节，最终完成了这本新版
现在的Redis 3.0源代码），重写了《Redis设计与实现》第一版已有的所有章节，并向书中添加了
版《Redis设计与实现》的写作也马不停蹄地开始了。
情，我找不到任何拒绝这一邀请的理由，就这样，在《Redis设计与实现》第一版发布几天之后，新
是否有兴趣正式地出版《Redis设计与实现》，能够正式地出版自己写的书一直是我梦寐以求的事
的地方：
作《Redis设计与实现》，并最终于2013年3月8日在互联网发布了本书的第一版。
集成书的话，那一定会非常有趣，并且我自己也会从中学到很多知识。于是我在2012年年未开始创
他Redis用户分享我的发现。在积累了七八篇Redis源代码注释文章之后，我想如果能将这些博文汇
这一点之后，我决定自己动手注释Redis的源代码，从中寻找问题的答案，并通过写博客的方式与其
版已经是2.6了）。
于简单（只是一些概述性的文章），要么关注的就是旧版本（比如2.0、2.2或者2.4，而当时的最新
内部实现进行了介绍，但这些文章要么不齐全（只介绍了Redis中的少数几个特性），要么就写得过
关注的是怎样使用Redis，而不是介绍Redis的内部实现。另外，网上虽然有一些博客文章对Redis的
获：Redis还是一个非常年轻的软件，对它的最好介绍就是官方网站上面的文档，但是这些文档主要
尽管《Redis设计与实现》第一版顺利发布了，但在我的心目中，这个第一版还是有很多不完善
综合来看，详细而且完整地介绍Redis内部实现的资料，无论是外文还是中文都不存在。意识到
从2013年3月到2014年1月这11个月间，我重新注释了Redis在unstable分支的源代码（也即是
就在我考虑应该何时编写新版来修复这些缺陷的时候，机械工业出版社的吴怡编辑来信询问我
口
为了找到这些问题的答案，我再次在搜索引擎上面进行查找，可惜的是这次搜索并没有多少收
比如说，因为第一版是我边注释Redis源代码边写的，如果有足够时间让我先完整地注释-
完成了。
又比如说，第一版只介绍了Redis的内部机制和单机特性，但并没有介绍Redis多机特性，
遍Redis的源代码，然后再进行写作的话，那么书本在内容方面应该会更为全面。
过什么步骤？
Redis使用什么模型或者模式来处理客户端的命令请求？一条命令请求从发送到返回需要经
除了数据库之外，Redis还拥有发布与订阅、脚本、事务等特性，这些特性又是如何实现的？
现自动删除的？
Redis的数据库是怎样存储各种不同数据类型的键值对的？数据库里面的过期键又是怎样实
而我认为只有将关于多机特性的介绍也包含进来，这本《Redis设计与实现》才算是真正的
型系统？
EXPIRE），不同的命令在执行时是如何进行类型检查的？Redis在内部是否实现了一个类
只能对哈希表执行），而另一部分命令却可以对所有数据类型执行（比如DEL、TYPE和
---
## Page 3
的意见，争取在将来写出更好的《Redis设计与实现》，以此来回报大家对本书的支持。
就这本新版《Redis设计与实现》发表提问、意见、建议、批评、勘误，等等，我会努力地采纳大家
议，因此我将继续在www.RedisBook.com设置disqus论坛（可以不注册直接发贴），欢迎读者随时
现》能够帮助读者更好地了解Redis，并成为更优秀的Redis使用者。
更高效地使用Redis，避开那些可能会引起性能问题的陷阱。我衷心希望这本新版《Redis设计与实
于满足好奇心：通过了解Redis的内部实现，理解每一个特性和命令背后的运作机制，可以帮助我们
作），以及所有Redis多机特性（如复制、Sentinel和集群）。
虽然作者创作本书的初衷只是为了满足自己的好奇心，但了解Redis内部实现的好处并不仅仅在
本书的第一版获得了很多热心读者的反馈，这本新版的很多改进也来源于读者们的意见和建
2014年3月于清远
黄健宏（huangz）
---
## Page 4
成这本新版《Redis设计与实现》。
现了。
我的悉心指导。
到正式出版的整个阶段，也感谢他们抽出宝贵的时间为本书审稿。
致
我要感谢所有阅读了《Redis 设计与实现》第一版的读者，他们的意见和建议帮助我更好地完
我要感谢吴怡编辑鼓励我创作并出版这本新版《Redis 设计与实现》，以及她在写作过程中对
最后，我要感谢我的家人和朋友，他们的关怀和鼓励使得本书得以顺利完成。
我要感谢Redis 之父Salvatore Sanfilippo，如果不是他创造了Redis 的话，这本书也不会出
我要感谢TimYang在百忙之中抽空为本书审稿，并耐心地给出了详细的意见。
我要感谢hoterran 和iammutex 这两位良师益友，他们对我的帮助和支持贯穿整本书从概念萌芽
谢
---
## Page 5
实现”四个部分组成。
1.2
以本书的大部分内容对于Redis 3.0之后的几个版本来说，应该也是有用的。
基本相同，所以本书的内容对于使用 Redis 2.6 至 Redis 3.0 的读者来说应该都是有用的。
要与 Redis 的多机功能有关，而 Redis 3.0 的单机功能则与 Redis 2.6、Redis 2.8 的单机功能
1.1Redis版本说明
解该功能的实现原理。
阅读该功能对应的实现代码，这有助于读者更快地读懂实现代码，也有助于读者更深人地了
提供了一份带有详细注释的 Redis 源代码，读者可以先阅读本书对某一功能的介绍，然后再
那么阅读本书就足够了。
现原理进行描述，如果读者只是对 Redis 的实现原理感兴趣，但并不想研究 Redis 的源代码，
可以帮助读者更好地、也更高效地使用 Redis。
些功能的核心数据结构以及关键的算法思想。
另外，因为 Redis 通常都是渐进地增加新功能，并且很少会大幅地修改已有的功能，所
另一方面，如果读者打算深人了解Redis 实现原理的底层细节，本书在 RedisBook.com
为了让本书的内容保持简单并且容易读懂，本书会尽量以高层次的角度来对Redis 的实
本书由“数据结构与对象”、“单机数据库的实现”、“多机数据库的实现”、“独立功能的
通过阅读本书，读者可以快速、有效地了解Redis 的内部构造以及运作机制，这些知识
本书是基于 Redis 2.9——也即是 Redis 3.0 的开发版来编写的，因为 Redis 3.0 的更新主
本书对 Redis 的大多数单机功能以及所有多机功能的实现原理进行了介绍，力图展示这
章节编排
第1章
信
---
## Page 6
2+第1章引
过程。
处理命令请求的步骤，解释了 serverCron 函数所做的工作，并讲解了Redis 服务器的初始化
Redis 服务器创建和销毁客户端状态的条件等等。
客户端状态包含的各个属性，说明了客户端的输人缓冲区和输出缓冲区的实现方法，以及
文件来还原数据库的方法，以及BGSAVE命令和BGREWRITEAOF命令的实现原理等等。
化方式的实现原理，说明了服务器根据数据库来生成持久化文件的方法，服务器根据持久化
方法，服务器保存键值对过期时间的方法，以及服务器自动删除过期键值对的方法等等。
第二部分“单机数据库的实现”
底层数据结构，并说明这些数据结构是如何深刻地影响对象的功能和性能的。
值对：
第一部分“数据结构与对象”
第14章“服务器”对单机Redis服务器的运作机制进行了介绍，详细地说明了服务器
第10章“RDB持久化”和第11章“AOF持久化”分别介绍了Redis两种不同的持久
第13章“客户端”对Redis 服务器维护和管理客户端状态的方法进行了介绍，列举了
口而时间事件则主要用于执行redis.c/serverCron 函数，这个函数通过执行常规的维护
文件事件主要用于应答（accept）客户端的连接请求，接收客户端发送的命令请求，
第12章“事件”对 Redis 的文件事件和时间事件进行了介绍：
第9章“数据库”对Redis 数据库的实现原理进行了介绍，说明了服务器保存键值对的
本书的第二部分对Redis实现单机数据库的方法进行了介绍。
本书的第一部分将对以上提到的五种不同类型的对象进行介绍，剖析这些对象所使用的
redis> RPUSH numbers 1 3 5 7 9
而执行以下命令将在数据库中创建一个键为字符串对象，值为列表对象的键值对：
redis> SEr msg "hello world"
比如说，执行以下命令将在数据库中创建一个键为字符申对象，值也为字符串对象的键
口数据库键总是一个字符串对象（string object）；
Redis 数据库里面的每个键值对（key-value pair）都是由对象（object）组成的，其中:
(integer) 5
负责触发的。
和管理操作来保持 Redis 服务器的正常运作，一些重要的定时操作也是由这个函数
以及向客户端返回命令回复；
其中一种。
object）、集合对象（set object）、有序集合对象（sorted set object）这五种对象中的
---
## Page 7
命令请求时，向监视器发送命令信息的方法。
现原理。
并说明了 SLOWLOGGET、SLOWLOGLEN、SLOWLOG RESET等慢查询日志操作命令的实
GETBIT、SETBIT、BITCOUNT、BITOP这儿个二进制位数组操作命令的实现原理。
行的先后顺序。
GET等等）的实现原理进行了介绍，并说明了当SORT命令带有多个选项时，不同选项执
器构建Lua 环境的过程，以及主从服务器之间复制Lua 脚本的方法进行了介绍。
绍，解释了 Redis 服务器是如何执行和管理用户传人的Lua 脚本的；这一章还对 Redis 服务
Redis 的事务是如何实现的，并说明了Redis 的事务对ACID 性质的支持程度。
了介绍，解释了Redis 的发布与订阅功能是如何实现的。
第四部分“独立功能的实现”
行通信的方法等等。
法，节点处理命令请求的方法，转发（redirection）错误的实现方法，以及各个节点之间进
移的方法等等。
务器的方法，Sentinel判断服务器是否下线的方法，以及 Sentinel 对下线服务器进行故障转
主从服务器之间执行了什么操作，进行了什么数据交互，诸如此类。
进行了介绍。
第三部分“多机数据库的实现”
第 24章“监视器”介绍了将客户端变为监视器（monitor）的方法，以及服务器在处理
第23章“慢查询日志”对Redis 创建和保存慢查询日志（slow log）的方法进行了介绍，
第19章“事务”对MULTI、EXEC、WATCH等命令的实现原理进行了介绍，解释了
第16章“Sentinel”对 Redis Sentinel 的实现原理进行了介绍，说明了 Sentinel监视服
第15章“复制”对Redis 的主从复制功能（master-slave replication）的实现原理进行
本书的第三部分对 Redis 的 Sentinel、复制（replication）、集群（cluster）三个多机功能
第22章“二进制位数组”对Redis 保存二进制位数组的方法进行了介绍，并说明了
第21章“排序”对SORT命令以及SORT命令所有可用选项（比如DESC、ALPHA
第 20章“Lua脚本”对EVAL、EVALSHA、SCRIPT LOAD 等命令的实现原理进行了介
第17章“集群”对Redis 集群的实现原理进行了介绍，说明了节点（node）的构建方
第18章“发布与订阅”对PUBLISH、SUBSCRIBE、PUBSUB 等命令的实现原理进行
本书的第四部分对Redis 中各个相对独立的功能模块进行了介绍。
第1章
引
·3
---
## Page 8
redis.h文件中的 redisDb 结构，诸如此类。
比如 redis.c/main 表示 redis.c 文件中的 main 函数，而 redis.h/redisDb 则表示
名字引用规则
1.4
分的情况下阅读。
涉及多机功能的内容，所以第四部分的大部分章节都可以在只阅读了本书第一部分和第二部
在本书的第四部分中，除了第20章的其中一节涉及多机功能的内容之外，其他章节都没有
么后面的章节就不会再重复介绍这个概念，所以读者最好按顺序阅读这三部分的各个章节。
的章节会假设读者已经读过了排在前面的章节。如果一个概念在前面的章节已经介绍过，那
接阅读第四部分。
接着阅读本书的第三部分。如果读者只使用 Redis 的单机功能，那么可以跳过第三部分，直
所有 Redis 使用者都必然会用到的。
还是多机模式的Redis，都应该阅读本书的第一部分和第二部分，这两个部分包含的知识是
1.3 
在第一次引用 Redis 源代码文件file 中的名字 name 时，本书使用 file/name 格式,
本书的第四部分包含的各章是完全独立的，读者可以按自己的兴趣来挑选要读的章节。
本书的前三个部分都是以自底向上（bottom-up）的方式来写的，也就是说，排在后面
如果读者要使用 Redis 的多机功能，那么在阅读本书的第一部分和第二部分之后，应该
因为 Redis 的单机功能是多机功能的子集，所以无论读者使用的是单机模式的 Redis.
第1章引
图 1-1 对上面描述的阅读方法进行了总结。
推荐的阅读方法
行文规则
海
数据库的实现”的所有章节
按顺序阅读第三部分“多机
按顺序阅读第一部分“数据结构与对象”的所有章节
是
图 1-1推荐阅读方法
多机功能吗？
否
---
## Page 9
问题、意见以及建议。
源代码可供下载，读者也可以通过这个网站查看和反馈本书的勘误，或者发表与本书有关的
1.5
在执行操作的客户端状态（redis.h/redisClient 结构的实例)。
server 表示服务器状态（redis.h/redisServer 结构的实例)，"而 client 则表示正
代码规则
算法规则
结构的expires 属性，诸如此类。
redisDb.id 表示 redisDb 结构的 id 属性，而 redisDb.expires 则表示 redisDb
结构引用规则
redisDb 格式，而之后再次引用 redisDb 结构时，只使用名字 redisDb。
举个例子，当第一次引用 redis.h 文件的 redisDb 结构的时候，会使用 redis.h/
/printf 则表示 stdio.h头文件的 printf 函数，诸如此类。
格式，比如/write 表示 unistd.h 头文件的 write 函数，而
本书使用 struct.property格式来引用 struct 结构的property属性，比如
本书配套网站redisbook.com记录了本书的最新消息，并且提供了附带详细注释的 Redis
除非有额外说明，否则本书列出的算法复杂度一律为最坏情形下的算法复杂度。
在第一次引用某个名字之后，本书就会去掉名字前缀的文件名，直接使用名字本身。
本书展示的 Python 伪代码中通常会包含 server 和client 两个全局变量，其中
口而当需要使用代码来描述比较长或者比较复杂的程序时，本书通常会使用 Python 语
口在描述数据结构以及比较简短的代码时，本书通常会直接粘贴 Redis 的源代码，也
本书使用C语言和Python语言来展示代码：
另外，在第一次引用标准库头文件 file 中的名字 name 时，本书使用/name
配套网站
即C语言代码。
言来表示伪代码。
第1章
引
、
言
+5
---
## Page 11
第6章
第5章
第4章
第3章
7章
压缩列表
整数集合
对象
跳跃表
字典
链表
简单动态字符串
数据结构与对象
第一部分
---
## Page 12
层都是由 SDS 实现的。
就会使用 SDS 来表示字符串值，比如在 Redis 的数据库里面，包含字符串值的键值对在底
值进行修改的地方，比如打印日志：
类型，并将 SDS 用作 Redis 的默认字符串表示。
字符串），而是自己构建了一种名为简单动态字符串（simple dynamic string，SDS）的抽象
在 Redis 里面，C字符串只会作为字符串字面量（string literal）用在一些无须对字符串
举个例子，如果客户端执行命令：
Redis 没有直接使用C 语言传统的字符串表示（以空字符结尾的字符数组，以下简称C
除了用来保存数据库中的字符串值之外，SDS 还被用作缓冲区（buffer）：AOF 模块中
口键值对的值是一个列表对象，列表对象包含了三个字符串对象，这三个字符串对象
口键值对的键是—个字符串对象，对象的底层实现是一个保存了字符串“fruits"的 SDS。
那么Redis 将在数据库中创建一个新的键值对，其中：
"Aziauou weueueau uotdde, sitnay Hsndy <sipax
又比如，如果客户端执行命令：
口键值对的值也是一个字符串对象，对象的底层实现是一个保存着字符串"hello
口键值对的键是一个字符串对象，对象的底层实现是一个保存着字符串“msg”的 SDS。
那么 Redis 将在数据库中创建一个新的键值对，其中：
当Redis 需要的不仅仅是一个字符串字面量，而是一个可以被修改的字符串值时，Redis
redisLog(REDIS_WARNING, "Redis is now ready to exit, bye bye...");
(integer) 3
world" 的 sDS。
符串“banana"，第三个SDs 保存着字符串“cherry"。
简单动态字符串