### Analysis Systems and Malware Detection

Analysis systems often focus on information flow analysis and leak detection [28, 61, 83]. Some systems use system calls to model and detect malicious behaviors [17, 25, 78, 66]. Since malware can detect when it is running in an instrumented environment, such as an Android emulator [60, 46, 69], researchers have proposed building sandboxes on real devices [15, 12] to address this issue. Dynamic analysis can typically overcome obfuscation techniques used by malware, but it can only detect malicious behavior if it is executed during the analysis. To mitigate this, tools have been developed to systematically exercise the functionality of an app to trigger its malicious behaviors [11, 74].

### Hybrid Analysis

Hybrid analysis can be categorized into two types. The first type combines static and dynamic characteristics to detect malicious behaviors [87, 76, 73]. The second type uses static analysis to guide dynamic analysis [84, 80, 11, 74].

### Attack Modeling and Detection

Previous research on attack modeling and detection has primarily focused on filtering remote exploits, such as those launched by worms [23, 48, 58, 64, 51, 71, 24, 22]. RootExplorer also leverages program analysis techniques like symbolic execution to extract attack signatures. However, there are key differences:

1. **Fragmentation of the Android Ecosystem**: Due to the fragmentation of the Android ecosystem, we do not always have access to the targeted device. Therefore, we must derive both the attack signature and the corresponding environment requirements without the target system. In contrast, previous systems typically analyze the targeted software directly.
   
2. **Local Privilege Escalation Attacks**: For remote attacks, the malicious payload often contains shellcode. In local privilege escalation attacks, shellcode is rarely used; instead, techniques like ret2usr, ret2dir, or direct kernel object modification (DKOM) are more common.

3. **Polymorphic Payloads**: Finding a balance between false negatives and false positives is challenging for network filters due to polymorphic or metamorphic payloads. Android root exploits are less likely to be morphed, and most Android malware authors lack the capability to generate polymorphic exploits. Therefore, we derive system-call-based signatures purely from known exploits.

### Other Related Work

#### Android Emulator Evasion

Recent studies have shown how easily malware authors can evade Android emulators. Petsas et al. [60] applied three different detection heuristics and successfully detected most Android dynamic analysis tools. Vidas et al. [69] identified four techniques based on differences in behavior, performance, hardware, and software components, demonstrating how they can detect existing malware scanner tools. Morpheus [46] can create up to 10,000 different detection heuristics for Android emulators. As a countermeasure, researchers [56] have started using real phones instead of emulators for malware analysis. Our solution is designed to work on both real Android devices and emulators, making this issue orthogonal to our work.

#### Syscall-based Behavior Modeling

RootExplorer uses system-call-based behaviors to model and detect root exploit attempts. This approach has been widely used to model and detect malicious behaviors [49, 14]. Our model is derived from the behavior graph proposed in [49], with adjustments to fit our specific scenario.

### Threat Model and Problem Scope

The goal of RootExplorer is to detect Android apps that carry root exploits. Detecting other malicious behaviors is out of scope and has been covered by many previous papers (ยง2). We do not attempt to understand what the malware will do after acquiring root privileges; this is deferred to future work.

We envision our system operating in the cloud, similar to Google Bouncer [39], and scanning apps by dynamically executing samples on real Android devices and/or emulators. We restrict the source of analyzed apps to either the official Google Play Store or third-party marketplaces. We do not consider malware involved in targeted attacks such as APTs.

We assume that malware carrying root exploits can be obfuscated to prevent static analysis and may include common anti-debugging/anti-virtualization techniques to detect the analysis environment. They may also download root exploits dynamically from a C&C server only when the desired Android device is detected. For triggering root exploits, we focus on understanding and providing the environment expectations. However, we do not handle malware that depends on specific user inputs (e.g., passing a game level) to trigger the root exploit. Generating such inputs is orthogonal to this work and has been covered by other projects [11, 74].

Finally, we focus on detecting root exploits against known vulnerabilities; detecting unknown or zero-day exploits is out of scope. No malware that has propagated through app marketplaces has been found to contain zero-day exploits, making this a reasonable limitation.

### RootExplorer Overview

Figure 1 depicts the operations of RootExplorer, which consists of two key phases: (1) an offline training phase (static analysis) that extracts useful information about root exploits from one-click root apps, and (2) a detection phase (dynamic analysis) that analyzes apps in specially tailored environments to detect root exploits.

During training, we gather information about as many different root exploits as possible. Since root exploits target specific devices, it is not possible to trigger all their behaviors without proper environments. We thus resort to static analysis. For each exploit, we collect:
1. The sequence and dependencies of system calls that can lead to a compromise of the device, i.e., the behavior signature [14, 49].
2. Preconditions for deterministically triggering the exploit.

The first step of our offline analysis is to identify a feasible execution path that leads to the success of the analyzed root exploit. We use guided symbolic execution to solve this problem. Specifically, we symbolize all external "inputs" to each root exploit (binary) and aim to find the shortest feasible path from the entry to the marked successful end point. Our prototype symbolic execution engine, based on IDA Pro, can handle all instructions and libc functions encountered in the training set of exploit binaries.

From the feasible execution path, we extract the sequence of system calls and their dependencies. This information is used to construct the behavior signature. During symbolic execution, we collect constraints over the information that needs to be returned from the system through system calls (i.e., preconditions). We consult an SMT solver to provide a concrete instance of satisfying preconditions. Both the behavior signature and preconditions feed directly into the dynamic analysis phase to prepare the right environment and satisfy necessary preconditions, thereby triggering and detecting various root exploits.

For this purpose, we use root exploits from one-click root apps. The benefits of this approach are:
1. High-quality exploits, as they are part of commercial products.
2. A rich variety of exploits (60 families in our evaluation).
3. Exploits packaged in the same one-click root app are likely to be obfuscated similarly, allowing us to de-obfuscate all at once and conduct static analysis.

### Learning the Expected Behavior Signature

The behavior signature of an exploit is extracted by analyzing de-obfuscated exploit binaries. While there are many models for constructing malware signatures, we favor system call-based behavior signatures because root exploits interact with the operating system through system calls in unique ways to exploit vulnerabilities. We build our behavior signature based on prior work [14, 49], allowing our dynamic analysis to track the progress of an exploit and confirm it when all steps have been performed.

### Learning Preconditions

There are two types of preconditions that need to be satisfied regarding a root exploit: environment-related and exploit preparation-related. Environment preconditions dictate whether the underlying Android device model and kernel version match what the exploit expects. After training, our dynamic analysis environment can provide the expected Android device information to trigger an exploit. One-click root apps already provide this information to a large degree. By reverse engineering their protocol, we have built a mapping from a list of more than 20K Android device types to their corresponding exploits.

For exploit preparation-related preconditions, we give the symbolic constraints collected along the feasible path and ask the SMT solver to construct a concrete satisfying instance. For example, if an exploit expects to open a vulnerable device file, the "input" to the exploit program is the return value of the `open()` syscall, which needs to be non-negative. Once we learn such preconditions, our dynamic analysis environment can provide the same expected "input."

### Behavior Graph Analysis

Since Android malware, especially those containing root exploits, heavily obfuscates their payloads, dynamic analysis is the preferred method for detection. However, dynamic analysis of root exploits is difficult because they target specific Android devices. Without the right environment, such exploits are likely to terminate prematurely, preventing detection.

To overcome this, we leverage de-obfuscated binaries from a one-click root app to extract the behavior signatures of root exploits. A behavior signature is constructed by abstracting low-level operations into a high-level behavioral representation [49, 14]. We check for malware samples that exhibit similar behaviors at runtime to detect the presence of specific exploits. For root exploits, we capture behaviors by modeling system call events, borrowing the system call modeling technique from ANUBIS [49] with slight adjustments.

The behavior graphs are directed acyclic graphs where nodes represent objects and system calls, and edges encode dependencies between objects and system calls, and across system calls. Compared to simply looking at a sequence of system calls, a behavior graph constrains the order of only dependent operations through explicit edges.

While the high-level behavior graph is similar to that proposed in [49], the main differences are:
1. We statically extract the behavior graph instead of extracting it from a dynamic trace.
2. We target Android, so the system calls are mostly inherited from Linux and differ from Windows.

### Generating Training Behavior Graphs

We automatically generate the behavior graph by analyzing de-obfuscated ARM root exploit binaries [81]. System call invocations and their hard-coded arguments are generally easy to identify, allowing us to know what OS objects are created and how they are operated on. The main challenge is to extract dependencies across system calls.

**Extracting Data Dependencies**: To extract dependencies, we look for cases where the arguments for one system call are derived from a previous system call. Previous work [49] used taint analysis, but we take a slightly different approach. When we use symbolic execution to find a feasible success path, we symbolize all the outputs of system calls. Symbolic values are propagated along the execution path, and we determine if a path is feasible by consulting the solver. If we consider a symbolic value as tainted, symbolic execution constructs the data dependencies between system calls.