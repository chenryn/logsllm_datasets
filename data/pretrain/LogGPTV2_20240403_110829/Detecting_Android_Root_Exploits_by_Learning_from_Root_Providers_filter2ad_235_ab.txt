analysis systems also focus on information ﬂow analysis
and leak detection [28, 61, 83]. Others use system calls
to model and detect malicious behaviors [17, 25, 78, 66].
Because malware can detect that it is being run in an
instrumented environment such as an Android emula-
tor [60, 46, 69], researchers have also proposed building
sandboxes on real devices [15, 12] for this purpose. Dy-
namic analysis can usually overcome obfuscation tech-
niques employed by malware, but a malicious behavior
can only be detected if it is executed during the analysis.
To overcome this, tools have been developed to system-
atically exercise the functionality of an app in the hope
of triggering its malicious behaviors [11, 74].
Hybrid Analysis: Hybrid analysis can be divided into
two categories. The ﬁrst category combines static and
dynamic characteristics to detect malicious behaviors
[87, 76, 73]. The other category utilizes static analysis
to guide dynamic analysis [84, 80, 11, 74].
USENIX Association
26th USENIX Security Symposium    1131
2.3 Attack Modeling and Detection
Previous papers on attack modeling and detection mainly
focus on ﬁltering remote exploits like those launched by
worms [23, 48, 58, 64, 51, 71, 24, 22]. Similar to those
systems, RootExplorer also leverages program analysis
techniques like symbolic execution to extract the attack
signature. However, there are a few differences. First,
due to fragmentation of the Android ecosystem, we do
not always have the targeted device, i.e., we need to de-
rive both the attack signature and the corresponding en-
vironment requirements without the corresponding target
system. Note that in aforementioned systems, in con-
trast, analysis is usually performed over the targeted soft-
ware. Second, for remote attacks, the malicious payload
usually contains shellcode; however, in local privilege
escalation attacks, shellcode is rarely used – ret2usr,
ret2dir, or direct kernel object modiﬁcation (DKOM)
are more common. Finally, due to polymorphic or meta-
morphic payloads, ﬁnding a good balance between false
negatives and false positives is very challenging for net-
work ﬁlters. Android root exploits are more difﬁcult to
morph (as shellcode is not part of the payload); more
importantly, even though it is possible to generate poly-
morphic exploits, as previously discussed, most Android
malware authors are not capable of doing so. For these
reason, we decide to pursue our current approach, i.e.,
derive system-call-based signatures purely from known
exploits.
2.4 Other Related Work
Android Emulator Evasion: Recent works have shown
how easy it is for malware authors to evade the Android
emulator. Petsas et al. [60] apply three different detec-
tion heuristics and manage to detect most Android dy-
namic analysis tools. Vidas et al. [69] derive four dif-
ferent techniques based on differences in behavior, per-
formance, hardware and software components and show
how they can easily detect existing malware scanner
tools that are based in emulators. Morpheus [46] is a
system that can create up to 10,000 different detection
heuristics for Android emulators. As a countermeasure,
researchers [56] have begun to use real phones instead of
emulators to analyze malware. We design our solution to
be operable on both real Android devices and emulators,
thereby making this issue orthogonal to our work.
Syscall-based Behavior Modeling: RootExplorer uses
system-call-based behaviors to model and detect root
exploit attempts. Syscall-based behavior modeling has
been widely used to model and detect malicious behav-
iors [49, 14]. Our model is derived from the behavior
graph proposed in [49], with adjustments to ﬁt our sce-
nario.
Figure 1: System overview
3 Threat Model and Problem Scope
The goal of RootExplorer is to detect Android apps that
carry root exploits. Detecting other malicious behaviors
is out-of-scope of this work and has been covered by
many previous papers (§2). We also do not attempt to
understand what the malware will do after acquiring the
root privilege; we defer such an analysis to future work.
We envision our system to operate in the cloud (sim-
ilar to Google Bouncer [39]), and that it will scan apps
by dynamically executing the samples on real Android
devices and/or emulators. For this reason, we restrict the
source of the analyzed apps to be either from the ofﬁ-
cial Google Play Store or from third-party marketplaces.
We do not consider malware involved in targeted attacks
such as APTs.
We assume that malware carrying root exploits
can be obfuscated to prevent static analysis, and
may be equipped with common anti-debugging/anti-
virtualization techniques to detect the analysis environ-
ment. They may also download root exploits dynami-
cally from a C&C server only when the desired Android
device is detected. For triggering root exploits, we focus
on understanding and providing the environment expec-
tations. However, we do not handle malware that de-
pends on speciﬁc user inputs (e.g., passing a game level)
to trigger the root exploit. We believe generating such
inputs is orthogonal to this work and has been covered
by other projects [11, 74].
Finally, we focus on detecting root exploits against
known vulnerabilities; detecting unknown or zero-day
exploits is out of scope of this work. We believe this
is a reasonable limitation as no malware that has propa-
gated through app marketplace has been found to contain
zero-day exploits.
4 RootExplorer Overview
Figure 1 depicts the operations of RootExplorer. There
are two key phases: (1) an ofﬂine training phase (static
analysis) that extracts useful information about root ex-
ploits from one-click root apps and, (2) a detection phase
(dynamic analysis) that dynamically analyzes apps in
specially tailored environments to detect root exploits.
During training, we gather information about as many
1132    26th USENIX Security Symposium
USENIX Association
Offline trainingwith one-click root appsEnvironment preparation and dynamic analysisExpected behavior signatureDetection resultsPreconditions /environment constraintsdifferent root exploits as possible. Since root exploits
target speciﬁc devices, it is not possible to trigger all of
their behaviors without proper environments. We thus
resort to static analysis. For each exploit, we collect
(1) sequence and dependencies of system calls that can
lead to a compromise of the device, i.e., behavior signa-
ture [14, 49], and (2) preconditions for deterministically
triggering the exploit.
The ﬁrst step of our ofﬂine analysis is to identify a
feasible execution path that leads to the success of the
analyzed root exploit. We use guided symbolic execution
to solve this problem.
In particular, we symbolize all
external “inputs” to each root exploit (binary) and aim to
ﬁnd a shortest feasible path from the entry to the marked
successful end point. We build our prototype symbolic
execution engine based on IDA pro, which is capable of
handling all the instructions and libc functions that were
encountered in the training set of exploit binaries.
From the feasible execution path, we extract the se-
quence of system calls and the dependencies across sys-
tem calls from the output of symbolic execution as well.
This information is then used to construct the behav-
ior signature. Since we already collect constraints over
what information needs to be returned from the system
through system calls (i.e., preconditions) during sym-
bolic execution, we just consult an SMT solver to provide
a concrete instance of satisfying preconditions. Both
pieces of information (behavior signature and precon-
ditions) feed directly to the dynamic analysis phase to-
wards preparing the right environment and satisfying
necessary preconditions, to trigger and thereby detect
various root exploits.
For this purpose, besides utilizing root exploits from
one-click root apps, we could in theory utilize the many
exploits with PoC code available on the Internet, but they
all come in different “sizes and shapes”. Some contain
source code but often hard code values in certain vari-
ables; this renders the exploit suitable only for a speciﬁc
tested Android device. Some have binaries only, which
are obfuscated to prevent direct reuse. Therefore, We
choose to work with a popular one-click root app for the
purposes of training. The beneﬁts are multi-fold: (1) the
quality of exploits is likely very good, as they are offered
in commercial products (e.g., they don’t contain unnec-
essary steps, and are unlikely to crash the system); (2)
there is a rich variety of exploits available (60 families of
exploits in our evaluation); (3) the exploits packaged in
the same one-click root app are likely to be obfuscated
in similar ways, making it possible to de-obfuscate all
exploits at once and conduct static analysis on them.
Learning the expected behavior signature: The be-
havior signature of an exploit is extracted by analyzing
the de-obfuscated exploit binaries. While there are many
possible models to construct malware signatures in gen-
eral, we favor system call based behavior signatures; this
is because root exploits interact with the operating sys-
tem through system calls in unique ways to exploit vul-
nerabilities. To this end, we build our behavior signature
largely based on prior work on extracting a malware be-
havior signature from system calls [14, 49]. This allows
our dynamic analysis to keep track of the progress of an
exploit and conﬁrm it when all of its steps have been per-
formed. More details are provided in §5.
Learning preconditions: As discussed earlier in §2,
there are two types of preconditions that have to be sat-
isﬁed with regards to a root exploit in general: environ-
ment related and exploit preparation related. Environ-
ment preconditions dictate whether the underlying An-
droid device model and kernel version match what are
expected by the exploit. After training, our dynamic
analysis environment can provide the expected Android
device information to trigger an exploit. Normally it is
difﬁcult to determine which exploits work against which
Android devices (because one needs to ideally test an ex-
ploit against real devices). Fortunately, one-click root
apps already provide this information to a large degree.
Speciﬁcally, the one-click root app we studied down-
loads a different set of exploit binaries depending on
the device information that is reported to its backend
server. By reverse engineering their protocol, we have
effectively built a mapping from a list of more than 20K
Android device types (available from [1]) to their cor-
responding exploits. The assumption is that a one-click
root app has a reasonably good idea of which exploits
can target which device.
For exploit preparation related preconditions, we give
the symbolic constraints collected along the feasible path
and ask the SMT solver to construct a concrete satisfying
instance such that when replayed during dynamic anal-
ysis, can deterministically trigger the analyzed root ex-
ploit. For instance, if an exploit expects to open a vul-
nerable device ﬁle successfully, the “input” to the exploit
program is the return value of the open() syscall, which
needs to take a non-negative value according to the sym-
bolic execution. Once we learn such preconditions, our
dynamic analysis environment can provide the same ex-
pected “input”. We will present the detailed design of the
symbolic execution framework in §6.
5 Behavior Graph Analysis
Since Android malware (especially those that contain
root exploits) typically obfuscate their payloads heav-
ily [86], dynamic analysis is the obvious choice over
static analysis, for the purposes of detection. However,
as discussed earlier, dynamic analysis wrt root exploits is
difﬁcult as such exploits target speciﬁc Android devices.
Without the right environment, such exploits are likely to
USENIX Association
26th USENIX Security Symposium    1133
terminate prematurely, thereby preempting detection.
To overcome this hurdle, we leverage de-obfuscated
binaries from a one-click root app from our prior
study [81] to extract the behavior signatures of root ex-
ploits. A behavior signature is constructed by abstracting
the low-level operations into a high-level behavioral rep-
resentation [49, 14]. One can check for malware samples
that exhibit similar behaviors at runtime and thereby de-
tect the presence of the particular exploits. In the case of
root exploits, since they interact with the kernel (or de-
vice drivers) in unique ways to exploit an OS vulnerabil-
ity, we choose to capture behaviors by modeling system
call events. Instead of reinventing the wheel, we borrow
the system call modeling technique from ANUBIS [49]
with slight adjustments. Speciﬁcally, we follow the deﬁ-
nition of “behavior graphs” [49] that are used to describe
OS objects, system calls that operate on these objects
and, relationships across system call events (e.g., the re-
sult of one system call is used as a parameter on another
system call).
The behavior graphs are directed acyclic graphs where
the nodes represent objects and system calls, and the
edges encode (1) the dependencies between objects and
system calls, and (2) the dependencies across system
calls. Compared to the traditional model of simply
looking at a sequence of system calls [44], a behavior
graph constrains the order of only dependent operations
through an explicit edge (and never constrains indepen-
dent operations).
While the high-level behavior graph is similar to that
proposed in [49], we highlight the main differences here:
(1) We statically extract the behavior graph instead of ex-
tracting it from a dynamic trace (as is done in ANUBIS).
This leads to different requirements as elaborated later.
(2) Since we target Android, the system calls are mostly
inherited from Linux and are different from Windows.
5.1 Generating Training Behavior Graphs
We now describe how we automatically generate the be-
havior graph statically, by analyzing de-obfuscated ARM
root exploit binaries [81]. The system call invocations,
and their hard-coded arguments are generally easy to
identify. This allows us to know what OS objects are
created (e.g., a ﬁle name), and how they are operated
on (e.g., Read-only or Read/Write). The main challenge
that we face is to extract the dependencies across system
calls.
Extracting data dependencies: To extract dependen-
cies across system calls, we look for cases where the ar-
guments for one system call is derived from a previous
system call. Previous work [49] utilized taint analysis
to derive such dependencies.
In our system, since we
perform static analysis over de-obfuscated binaries, we
take a slight different approach. Speciﬁcally, when we
use symbolic execution to ﬁnd a feasible success path,
we symbolize all the outputs of system calls. During the
analysis, symbolic values are propagated along the ex-
ecution path. To determine whether a path is feasible,
whenever we meet a conditional branch that depends on
symbolic value, we consult the solver to see if the corre-
sponding path constraints are solvable. If we consider a
symbolic value as tainted, then symbolic execution itself,
already constructs the data dependencies between system
calls, i.e., if the input argument(s) of a system call is a
symbolic value, then it must have a data dependency over
one or more previous system calls. More importantly, the