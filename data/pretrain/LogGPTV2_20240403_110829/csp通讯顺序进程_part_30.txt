temp::filesys
209
---
## Page 233
须是立进程字母表的子集。这个题目留待进一步研究。
享。看来需要重新定义附庸进程，不必规定附进程的字母表必
标记的情况下，就无法实现附庸进程及其主进程之间的资源共
（2）在用后提交作业的过程中，用户文件应该始终保留不被删除。
（1）用户作业也有权存取文件系统和多重虚拟输入和输出设备
变动。这些改进包括
要影响三个模块，CR(X1），INSPOOL(X3)和JOB。
但并不是所有的变动都是轻而易举的：如改变界符卡的值，就
接受的。这种问题称为无穷抢占（见2.5.5节）。
永远不能获取资源，或者至少不能预测要等待多久，这也是不能
而上述情形叉一再发生。那末，就会有些进程一再被推迟，甚至
个新加入的进程也许会被幸运地选上。设想这个资源十分热门，
正好有一个进程加人了等待的进程集，而选择又是非确定的，这
的选择，对资源而言，如何选择是无关紧要的。但若在释放前，
着，则应如何选择获取的用户；以上各例中，采用的是非确定性
已有着热切的用片等待获取它。若在释放时，已有多个用卢等候
（4）建立已输入但未执行的作业的登录表，选择-种决定正在
用。为此，需增加资源，或合理使用资源，或提高使用资源的收
（3）
210
，还可对系统做很多有意义的改进，但会使系统结构有较大的
解决问题的一种办法是，保证所有资源不会过于频繁地被使
在做这些改进工作时，遇到的问题之一是，在不能使用多重
一-种迅速从故障中恢复的备查点方法也需引入。
并发的作业批数
在大量用户中共享有限的资源时，释放一个资源以前，往往
问题。
等待的作业的运行次序的方法。下一-节中将进一步讨论这一
6.6调
度
---
## Page 234
服务。
法，形式地表述如下。我们在表逃中假设至多可同时为R位顾客
这同汽车站上排队的乘客所遵守的规定一样。
进程。这种方法叫作先到先服务（FCFS）或先进先出（FIFO)。
为区分要求分配资源的进程，将please和thankyou的每个出现缀
进程从please至thankyou所花的时间，就是它等待资源的时间。
取看作是单一·的原子事件，而分为两个事件
度，需要知道哪些进程刚进又等待状态。为此，不应把资源的获
直无法确知，自已究竟需等待一分钟抑或是一天。
是可预测的：人们宁愿被告知在一小时内能得到服务，也不愿一
免地要被延缓。重要的是，如何保证这种延缓无很大波动，而且
但这不一定总是成功的。在高峰期，平均而言，用片进程不可避
频繁。这时，可以试用不同时间不同收费标准来平缓用片要求。
的是，有些资源平均而言使用频率不高，但在高峰时期也会极其
费标准。但这种办法只适用于任何时候都频繁使用的资源。可惜
X1
取到票证但尚未服务的、序号又最小的顾客。这叫作面包房算
号的票证。一进面包房，就取一张票。服务员一有空，就呼叫已
种算法以达到同样的效果。装置··部机器，分发印有严格递增序
以不同的自然数指标。进程获取它的指标的办法同于远程附康进
在面包房中，顾客不可能也不愿意排成一队，这就需要另一
（6.4节X3）。如
调度资源的简单和有效的方法是，将资源分配给等得最久的
thankyotu
在等待的用户中分配资源的任务叫作调度。为成功地进行调
举例
please
面包房算法
要求分配资源
实际分配资源
211
---
## Page 235
客得到了资源。表述为
客：一且出现这种现象，紧接的事件必须是thankyou，即有个顾
当全都相等时，如在夜间，最后一个顾客也已离开时，计数变元
数，而R+－则是等待的服务员数。所有计数变元的初值为零，
客而增加，‘则是随新被服务的顾客而增大；P一是等待的顾客
显然，任意时刘≤≤p。而且，随时会因新进入面包房的顾
文都置为筹。
212
算法的主要任务是确保不会同时有自出的资源和等待的顾
我们需要三个计数变元
★
已释放他们的资源的顾客
已说please的颐客
BAKERY = Bo,0;
已说thankyou的顾客
olse(p.please→Bp+1,t;?
else if R+r-t>0Ap-t>0
口
---
## Page 236
我有很大影响。我期待着这个课题的基础方面以及其广泛的实际
戚谢这个领域中的其它研究工作者，他门的开创性的研究工作对
的一些别的途径，而且解释一下没有朵纳的理由。同时，也借此
多个目标方面的更大的成功。本章中讨论我和其他人会经探求过
同的方法，或者是某些部分的重大的改进，都会导致上述一-个或
（3）这个理论可以协助程序设计员，完成对复杂的计算机系统的
慢的人类通信，那简直是莫大的浪费。便宜的专用处理器（通道）
常珍贵的；让处理器等待和慢速的外部设备通信，甚至和速度更
算机体系结构和操作系统的发展所提出来的。那时，处理器是非
应用方面的更深入的研究成果。
（2）这个理论可以在各种计算装置上实现，具有各种传统的或新
（1）这个理论可以刘画各种有趣的计算机应用领域，从自动售货
数学理论，它们是
我不能宣称所有的目标都完美地达到了。有可能一种完至不
单个计算机中并发式程序设计开始于60年代，是由当时的计
描述、设计、实施、验证和验牧。
机、过程控制、离散事件模拟，直到资源共享的操作系统。
我研究通信进程的主要目标是找到满足下列特性的最简单的
信的微型机网络。
颖的体系结构的，从分时计算机、多重处理机，直到相互通
第七章
7.2
7.1引[
共享存储
讨
论
213
---
## Page 237
将控制转到标号L处，但同时允许控制继续顺序往下传递。这
某处的标号，命合
7.2.1
存储区的并发进程，有可能使用户作业更充分利用硬件的并行性。
（2）
(1）使用的存储量和作业数成比例增加。
序几平不必修改。
则只要稍稍地修改一下，就能用于多处理器了，而对用卢作业程
若干个独立的中央处理器；若原来的操作系统具有良好的结构，
各自的主存。为增加作业的吞吐量，又设法使同一计算机中附有
的片段，一个片段只由一个程序使用，而且确保程序间不会干扰
互独立的。
且，不同的程序是由不同的用户提交的不同作业，彼此间应是相
存相连，各个处理器对主存的存取操作应该是穿插进行的。而
个程序。
生中断，使得操作系统能够考虑，中央处理器下一步应该执行哪
序在使用输入输出处理器。在一个输入输出操作终止时，就会产
时刻总有一个程序在使用中央处理器，与此同时尽管有若干个程
完整的程序，就可以使昂贵的中央处理器总是在忙碌工作；任意
任务。使用分时操作系统，在计算机的主存中同时贮存若干个
就用来独立地执行输入输出，从而使中央处理器有可能执行其它
这样，在设计硬、软件时，就设法将主存分成若干个不相交
214
上远的描绘说明，中央处理器和所有通道都应和计算机的主
第一个这类建议是基于转移命合（9oto)。合L表示程序中
不改变程序的存储区域，但将单个程序分解为多个使用同一
闻也要随作业数而增加。
除非取得最高的优先级，否则用后等待其作业运行结果的时
几个不同的作业共享单一计算机的缺点是
多流化
fork L
---
## Page 238
止。终止后，由单个处理器继续执行后随的命合。这种结构化的
能导致P和Q词时启动，而且同时前进，直到两者都结束后才终
P,Q是这样的程序块，复合命合
叉后，两个处理器执行的程序块完全不同，不会彼此转移，合
7.2.2 cobegin ... coend
并发性，而不适用于小范围的并发性。
可能都不合算。这种方法适用于在作业的最外层引发（全局的）
区，解除了多流化的主要困难和危险，但在时间和空间两个方面
以判断谁是它的双亲，谁是它的子孙。给进程分配不相交的存储
程一起自分叉命合往下执行。系统提供一种机制，使每个进程可
份，而且将这份拷贝分给一个新的进程。原先的进程和这个新进
不提及标号。它的效果是将分配给程序的整个存储区重新拷贝一
设计语言呢！
设计以前就提出来的：在那时，FORTRAN还被看作是高级程序
序外，以不用为好。可解的是，这种技术是在使用结构化程序
两个进程中的一个进程继续往下执行。
达这个命合的进程，必须等待另·个进程也到达该处。然后，这
只有当两个进程同时要求执行这个命合时，它才能被执行。先到
方法。非常简单的建议是用命合
序技术叫作多流化技术。
控制轨迹，贯穿一系列命合。每条控制轨迹还可分叉，故这种程
样，就有两个处理器同时执行同一程序：每个处理器管理各自的
分叉命合的--种变种现在还在UNIXTM操作系统中使用。它
总的来说，多流化是极其复杂和容易出错的，除了最小的程
有了将程序一分为二的方法，随之也需要将两个进程合并的
为解决多流化中的问题，E.W.Dijkstra提议：必须确保分
cobegin P; Q coend
join
215
---
## Page 239
些变元的名字，如
更新这种变元的临界区的前面应写上 with子句，子句中引用这
享的资源，例如
个共享进程的临界区中更新数值的一组变元，应被申明为一种共
后来，我也会建议在高级程序设计语含中将共形式表示。在若于
明可用由互斥信号量保护的临界区（6.3节）来达到这一目标。
的，即用共享主存的办法实现并发进程间的通信。Dijkstra会说
一个方法：但早期解决这个问题的技术是由计算机的硬件联想到
互作用，这个限制严重地减低了并发性的潜在价值。
7.2.3条件临界区
用一般的括号，而不使用更麻烦的cobegin…·coend。
号；为避免与顺序组合相混淆，我用算子Ⅱ将进程分开；而且使
因此，本书的并行构造基于 Dijketra 的建议。与其不同的只是记
而并行组合的正确性的证明方法，比之顺序情形甚至更为简单。
序任意）的效果完至一样。即
通信发生，则P和Q的拜发执行的效果，和它们的顺序执行（次
制）时，更容易清楚。这时，称这些进程是不相交的：如果又无
特别当各块使用不同变元（这可用高级语言的编译程序检查或强
得到
命合可用非结构化的fork和ioin命合实施，使用标号L和’，
begin P; Qend = begin Q; P end = cobegin P; Q coend
216
f1+ u=:1opu 4l!m
本书中引入的（模拟的）输人和输出通道是解决上逃问题的
限定并发进程间不能共享变元，使得进程间无法通信或者交
这种结构化的记法的一大优点是，容易搞清使用它的后果；
fork L; P; go toJ; L:Q, J: join
 shared position:record x, y:real end
shared n:integer;
---
## Page 240
包含临界区的读取进程则为
包含临界区的更新进程则为
作为资源的一-部分，并由它统计在更新前读取消息的进程的个
若多个推迟的进程都能前进，它们间的选择则是任意的。
变为真，则被推迟的进程进人其临界区；否则该进程重新挂起。
区，并更新共享变元。每做一次更新后，重新检验条件。若条件
假，就推退临界区的进人，从而共它进程允许进入它们的临界
在临界区的入口，先检验条件。若条件为具，就执行临界区；若
程尚未全部读取更新值前，不应再更新变元。
值。故在更新变元前，其它进程就不应读取。反之，在其它进
形式。如，某一进程更新变元的目的是要其它进程读取这个新
的临界区中。
检查，是否对共享变元的存取和更新只出现在由相关信号量保护
围绕每个临界区能补以必要的P和V操作。而且在编译时刻可以
数，
这种记法的好处是，绢译程序能自动地引人必要的信号量，而且
若有多个进程更新并读取-个消息，则需申明一个整数变元
shared message:record count:integer; content: .- end;
如
共享存储的进程间的合作方式是多样的，可能要求其它同步
with message when count>0 do
message,count: = 0,
解决这个问题，可用条件临界区。其形式为
with position do begin x: = x+ deltax; y: = y + deltay end
with sharedvar whon condition do critical region
with message when count = 0 do
end 
begin content: = ."".
count:=number of readers
…
---
## Page 241
另一个调用完成为止。过程体就象是出相同的信号量保护的临界
个管程中只有--个过程体处于活动状态：若两个进程同时调用一
过程调用的办法来启用它。管程的一个重要特征是，每个时刻每
的结构和类型；当共享这个数据的进程需要使用某操作时，就用
作（包括初始化及终止化），应该收集在一起，并申明数据本身
60的过程概念的推广。基本想法是，关于数据的全部有意义的操
7.2.4管程
只需重新测试那些可能改变值的条件。
在其等待过程中它们的值不会改变。这样，每退出－·个临界区，
个过程（或者调用两个不同过程），其中的－个调用必须推退到
的条件才会改变。条件中的其它变元都是等待进程所私有的，故
享变元的限制，保证了只有在共享变元改变值的时候，等待进程
区，必须重新测试等待进入临界区的至部进程的条件。对存取共
号量相比，条件临界区的开销是非常大的；每次退出一个临界
218
管程的提出来白 SIMULA67的class，它本身叉是ALGOL