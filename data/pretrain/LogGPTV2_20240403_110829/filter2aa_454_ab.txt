0001 
0000
Valid Size
0000 
ff5d
Vuln Size
0001 
ff5d
NT Buffer Size
Bug #1 - Integer Cast Error
ULONG FEALIST.cbList;
SmbPutUshort(&FeaList->cbList, PTR_DIFF_SHORT(fea, FeaList));
Win7
0x1ff5d (OS/2) > 0x10fe8 (NT)
HIDWORD
LODWORD
Attacker
0001 
0000
Valid Size
0000 
ff5d
Vuln Size
0001 
ff5d
NT Buffer Size
0001 
0fe8
Assembly Analysis
x86/x64
  ARM
Itanium
  DEC ALPHA
packet Trans2_Open2_Parameters
{
   USHORT              Flags;
   USHORT              AccessMode;
   USHORT              Reserved1;
   SMB_FILE_ATTRIBUTES FileAttributes;
   UTIME               CreationTime;
   USHORT              OpenMode;
   ULONG               AllocationSize;
   USHORT              Reserved[5];
   SMB_STRING          FileName;
};
packet Trans2_Open2_Data
{        
   SMB_FEA_LIST ExtendedAttributeList;
};
Bug #2 - Oversized Trans/Trans2 Requests
●
Need to send > WORD data
○
Bug trigger 0x10000 > 0xffff
●
Trans2_Open2 is WORD
○
NT Trans allows DWORD!
●
Can trick transaction dispatch tables
○
They all become generic _TRANSACTION
○
Primary transaction type doesn't matter
■
Final Secondary transaction
Bug #3 - Session Setup Allocation Error
●
NT Security vs. Extended Security
○
13 words vs. 12 words
●
Certain flag values can confuse it
○
Reads SMB_DATA_BLOCK size at wrong offset
○
Can reserve large memory
■
Same pool tag as FEA: LSbf
●
Free on demand
○
Close client socket
●
Not really a "vuln" itself
○
Still in master branch
EternalBlue NonPagedPool Ingredients
●
FEALIST overflow
○
Exploit
●
Session Setup bug
○
Allocation
○
Hole
●
SrvNet.sys network buffers
○
Primary Grooms
○
Secondary Grooms
○
FAKE SMB2
■
IDS bypass?
EternalBlue Grooming
●
Step 0. Pre-Exploitation Memory Layout
○
SrvNet has lookaside memory, random stuff is in the pool
Free pool memory
Random pool memory
SrvNet look-aside buffers
SrvNet "groom" buffer
Session setup "allocation" buffer
Session setup "hole" buffer
Exploit OS/2 to NT FEA overflow
EternalBlue Grooming
●
Step 1. Send all of FEALIST except last Trans2 secondary
○
The NT FEA Buffer will not be reserved yet
Free pool memory
Random pool memory
SrvNet look-aside buffers
SrvNet "groom" buffer
Session setup "allocation" buffer
Session setup "hole" buffer
Exploit OS/2 to NT FEA overflow
EternalBlue Grooming
●
Step 2. Send initial N grooms
○
Use up all of SrvNet look-aside, forcing new pool allocations
Free pool memory
Random pool memory
SrvNet look-aside buffers
SrvNet "groom" buffer
Session setup "allocation" buffer
Session setup "hole" buffer
Exploit OS/2 to NT FEA overflow
EternalBlue Grooming
●
Step 2. Send initial N grooms
○
Use up all of SrvNet look-aside, forcing new pool allocations
Free pool memory
Random pool memory
SrvNet look-aside buffers
SrvNet "groom" buffer
Session setup "allocation" buffer
Session setup "hole" buffer
Exploit OS/2 to NT FEA overflow
EternalBlue Grooming
●
Step 2. Send initial N grooms
○
Use up all of SrvNet look-aside, forcing new pool allocations
Free pool memory
Random pool memory
SrvNet look-aside buffers
SrvNet "groom" buffer
Session setup "allocation" buffer
Session setup "hole" buffer
Exploit OS/2 to NT FEA overflow
EternalBlue Grooming
●
Step 2. Send initial N grooms
○
Use up all of SrvNet look-aside, forcing new pool allocations
Free pool memory
Random pool memory
SrvNet look-aside buffers
SrvNet "groom" buffer
Session setup "allocation" buffer
Session setup "hole" buffer
Exploit OS/2 to NT FEA overflow
EternalBlue Grooming
●
Step 2. Send initial N grooms
○
Use up all of SrvNet look-aside, forcing new pool allocations
Free pool memory
Random pool memory
SrvNet look-aside buffers
SrvNet "groom" buffer
Session setup "allocation" buffer
Session setup "hole" buffer
Exploit OS/2 to NT FEA overflow
EternalBlue Grooming
●
Step 2. Send initial N grooms
○
Use up all of SrvNet look-aside, forcing new pool allocations
Free pool memory
Random pool memory
SrvNet look-aside buffers
SrvNet "groom" buffer
Session setup "allocation" buffer
Session setup "hole" buffer
Exploit OS/2 to NT FEA overflow
EternalBlue Grooming
●
Step 3. Send allocation connection
○
Session Setup bug SMALLER than NT FEA Buffer Size
Free pool memory
Random pool memory
SrvNet look-aside buffers
SrvNet "groom" buffer
Session setup "allocation" buffer
Session setup "hole" buffer
Exploit OS/2 to NT FEA overflow
EternalBlue Grooming
●
Step 4. Send hole buffer connection
○
Session Setup bug SAME SIZE as NT FEA Buffer Size
Free pool memory
Random pool memory
SrvNet look-aside buffers
SrvNet "groom" buffer
Session setup "allocation" buffer
Session setup "hole" buffer
Exploit OS/2 to NT FEA overflow
EternalBlue Grooming
●
Step 5. Close allocation connection
○
Memory slot can now hold smaller miscellaneous allocations
Free pool memory
Random pool memory
SrvNet look-aside buffers
SrvNet "groom" buffer
Session setup "allocation" buffer
Session setup "hole" buffer
Exploit OS/2 to NT FEA overflow
EternalBlue Grooming
●
Step 5. Close allocation connection
○
Memory slot can now hold smaller miscellaneous allocations
Free pool memory
Random pool memory
SrvNet look-aside buffers
SrvNet "groom" buffer
Session setup "allocation" buffer
Session setup "hole" buffer
Exploit OS/2 to NT FEA overflow
EternalBlue Grooming
●
Step 6. Send final groom packets
○
Hopefully a groom is after the Hole buffer
Free pool memory
Random pool memory
SrvNet look-aside buffers
SrvNet "groom" buffer
Session setup "allocation" buffer
Session setup "hole" buffer
Exploit OS/2 to NT FEA overflow
EternalBlue Grooming
●
Step 6. Send final groom packets
○
Hopefully a groom is after the Hole buffer
Free pool memory
Random pool memory
SrvNet look-aside buffers
SrvNet "groom" buffer
Session setup "allocation" buffer
Session setup "hole" buffer
Exploit OS/2 to NT FEA overflow
EternalBlue Grooming
●
Step 6. Send final groom packets
○
Hopefully a groom is after the Hole buffer
Free pool memory
Random pool memory
SrvNet look-aside buffers
SrvNet "groom" buffer
Session setup "allocation" buffer
Session setup "hole" buffer
Exploit OS/2 to NT FEA overflow
EternalBlue Grooming
●
Step 6. Send final groom packets
○
Hopefully a groom is after the Hole buffer
Free pool memory
Random pool memory
SrvNet look-aside buffers
SrvNet "groom" buffer
Session setup "allocation" buffer
Session setup "hole" buffer
Exploit OS/2 to NT FEA overflow
EternalBlue Grooming
●
Step 6. Close Hole connection
○
Memory the same size as NT FEA Buffer is now available
Free pool memory
Random pool memory
SrvNet look-aside buffers
SrvNet "groom" buffer
Session setup "allocation" buffer
Session setup "hole" buffer
Exploit OS/2 to NT FEA overflow
EternalBlue Grooming
●
Step 7. Send final FEALIST exploit fragment
○
Erroneously calculated to fit in the free Hole buffer, overflows into groom
Free pool memory
Random pool memory
SrvNet look-aside buffers
SrvNet "groom" buffer
Session setup "allocation" buffer
Session setup "hole" buffer
Exploit OS/2 to NT FEA overflow
struct _SRVNET_BUFFER
{
// ...
   SRVNET_WSK_STRUCT*
WskContext;
// ...
MDL  
MDL1; // MapSysVa = &Buffer
MDL  
MDL2;
CHAR
Buffer[];
};
struct _SRVNET_BUFFER
{
// ...
   SRVNET_WSK_STRUCT*
WskContext;
// ...
MDL  
MDL1; // MapSysVa = &HAL
MDL  
MDL2;
CHAR
Buffer[];
};
struct _SRVNET_BUFFER
{
// ...
   SRVNET_WSK_STRUCT*
WskContext;
// ...
MDL  
MDL1; // MapSysVa = &HAL
MDL  
MDL2;
CHAR
Buffer[];
};
struct _SRVNET_BUFFER
{
// ...
   SRVNET_WSK_STRUCT*
WskContext;
// ...
MDL  
MDL1; // MapSysVa = &HAL
MDL  
MDL2;
CHAR
Buffer[];
};
struct _SRVNET_WSK_STRUCT
{
// ...
PVOID
FunctionTable[];
// ...
};
struct _SRVNET_WSK_STRUCT
{
// ...
PVOID
FunctionTable[];
// ...
};
struct _SRVNET_WSK_STRUCT
{
// ...
PVOID
FunctionTable[];
// ...
};
EternalBlue payload
EternalBlue payload
1.
Hook syscall handler
○
DISPATCH_LEVEL IRQL
■
Many routines are off limits
EternalBlue payload
1.
Hook syscall handler
○
DISPATCH_LEVEL IRQL
■
Many routines are off limits
2.
On next syscall…
○
Transition from user mode
○
Run DOUBLEPULSAR backdoor
■
SrvTransaction2DispatchTable
EternalBlue payload
1.
Hook syscall handler
○
DISPATCH_LEVEL IRQL
■
Many routines are off limits
2.
On next syscall…
○
Transition from user mode
○
Run DOUBLEPULSAR backdoor
■
SrvTransaction2DispatchTable
3.
Restore syscall handler
EternalBlue Patch
SrvOs2FeaListSizeToNt():
SmbPutUshort(&FeaList->cbList, PTR_DIFF_SHORT(fea, FeaList));
EternalBlue Patch
SrvOs2FeaListSizeToNt():
SmbPutUlong (&FeaList->cbList, PTR_DIFF_LONG(fea, FeaList));
EternalChampion
Race Condition
●
TRANSACTION.Executing
○
BOOLEAN locking mechanism
○
Checked during Secondary transactions
■
NOT SET if Primary has all data!
Race Condition
●
TRANSACTION.Executing
○
BOOLEAN locking mechanism
○
Checked during Secondary transactions
■
NOT SET if Primary has all data!
●
Modify executing TRANSACTION!
○
Info leak on single-core
○
Stack overwrite on multi-core
Race Condition
●
TRANSACTION.Executing
○
BOOLEAN locking mechanism
○
Checked during Secondary transactions
■
NOT SET if Primary has all data!
●
Modify executing TRANSACTION!
○
Info leak on single-core
○
Stack overwrite on multi-core
●
CHAMPION
○
CHAMPIONS WIN RACES!
Leak a TRANSACTION
●
Need a SMB which echos back Data
○
MS-RAP
■
WNetAccountSync
■
NetServerEnum2
○
NT_RENAME
■
Requires valid FID
●
Primary Trans
○
Data > CONNECTION.MaxBufferSize
■
Requires restart (multiple response SMB)
■
Always winrar a Race!
●
Secondary Trans sends more data
○
Increases DataCount
○
Use Displacement=0
SrvSmbQueryPathInformation(WorkContext)
{
UNICODE_STRING objectName;
if (subCommand == SMB_INFO_QUERY_EA_SIZE)
{
SrvQueueWorkToBlockingThread(WorkContext);
return SmbTransStatusInProgress;
}
if (subCommand == SMB_INFO_IS_NAME_VALID)
{
transaction->InData = &objectName;
}
// ...
}
SrvSmbQueryPathInformation(WorkContext)
{
UNICODE_STRING objectName;
if (subCommand == SMB_INFO_QUERY_EA_SIZE)
{
SrvQueueWorkToBlockingThread(WorkContext);
return SmbTransStatusInProgress;
}
if (subCommand == SMB_INFO_IS_NAME_VALID)
{
transaction->InData = &objectName;
}
// ...
}
STEP 1
SrvSmbQueryPathInformation(WorkContext)
{
UNICODE_STRING objectName;
if (subCommand == SMB_INFO_QUERY_EA_SIZE)
{
SrvQueueWorkToBlockingThread(WorkContext);
return SmbTransStatusInProgress;
}
if (subCommand == SMB_INFO_IS_NAME_VALID)
{
transaction->InData = &objectName;
}
// ...
}
STEP 2
STEP 1
Overwrite RIP/EIP to Shellcode
●
After SMB_INFO_IS_NAME_VALID, send another secondary trans
○
Displacement = stack offset
●
Overwrite RET WorkerThread to Stage 0 Shellcode
DataDisplacement = offset
RWX Shellcode Location
●
No DEP (x86)
○
Write at LEAKED TRANSACTION->InData
●
DEP (x64)
○
Write at LEAKED TRANSACTION->CONNECTION.ClientOSName
■
I.E. same Session Setup bug used in EBlue
EternalChampion RCE Trigger
●
8 SMB per TCP packet
Trans2 
SMB_INFO_QUERY_EA_SIZE
Restart
Trans2 Secondary
SMB_INFO_IS_NAME_VALID
InData = &stack
Trans2 Secondary
DataDisplacement
Overwrite RET
EternalChampion RCE Trigger
●
8 SMB per TCP packet
●
8 packets per attempt
Trans2 
SMB_INFO_QUERY_EA_SIZE
Restart
Trans2 Secondary
SMB_INFO_IS_NAME_VALID
InData = &stack
Trans2 Secondary
DataDisplacement
Overwrite RET
EternalChampion RCE Trigger
●
8 SMB per TCP packet
●
8 packets per attempt
●
42 attempts
Trans2 
SMB_INFO_QUERY_EA_SIZE
Restart
Trans2 Secondary
SMB_INFO_IS_NAME_VALID
InData = &stack
Trans2 Secondary
DataDisplacement
Overwrite RET
EternalChampion Shellcode
1.
Loop CONNECTION.TransactionList
○
Find special identifier at start of Data buffer
■
AKA: egghunter
EternalChampion Shellcode
1.
Loop CONNECTION.TransactionList
○
Find special identifier at start of Data buffer
■
AKA: egghunter
2.
Copy primary payload from egg (DOUBLEPULSAR)
○
Access to pool functions
■
Can allocate large RWX space
○
Execute main stage
EternalChampion Shellcode
1.
Loop CONNECTION.TransactionList
○
Find special identifier at start of Data buffer
■
AKA: egghunter
2.
Copy primary payload from egg (DOUBLEPULSAR)
○
Access to pool functions
■
Can allocate large RWX space
○
Execute main stage
3.
++SrvBlockingWorkQueues->AvailableThreads
EternalChampion Shellcode
1.
Loop CONNECTION.TransactionList
○
Find special identifier at start of Data buffer
■
AKA: egghunter
2.
Copy primary payload from egg (DOUBLEPULSAR)
○
Access to pool functions
■
Can allocate large RWX space
○
Execute main stage
3.
++SrvBlockingWorkQueues->AvailableThreads
4.
KPCR->Prcb.CurrentThread->StartAddress
○
Use global kernel data structures
○
Resume execution
■
JMP to srv!WorkerThread() loop
EternalChampion Patch
SrvSmbTransaction/SrvSmbNtTransaction():