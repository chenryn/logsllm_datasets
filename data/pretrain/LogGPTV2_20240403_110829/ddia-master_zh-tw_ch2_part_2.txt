    }
  ],
  "contact_info": {
    "blog": "http://thegatesnotes.com",
    "twitter": "http://twitter.com/BillGates"
  }
}
```
有一些开发人员认为 JSON 模型减少了应用程式程式码和储存层之间的阻抗不匹配。不过，正如我们将在 [第四章](ch4.md) 中看到的那样，JSON 作为资料编码格式也存在问题。无模式对 JSON 模型来说往往被认为是一个优势；我们将在 “[文件模型中的模式灵活性](#文件模型中的模式灵活性)” 中讨论这个问题。
JSON 表示比 [图 2-1](../img/fig2-1.png) 中的多表模式具有更好的 **区域性（locality）**。如果在前面的关系型示例中获取简介，那需要执行多个查询（透过 `user_id` 查询每个表），或者在 User 表与其下属表之间混乱地执行多路连线。而在 JSON 表示中，所有相关资讯都在同一个地方，一个查询就足够了。
从使用者简介档案到使用者职位，教育历史和联络资讯，这种一对多关系隐含了资料中的一个树状结构，而 JSON 表示使得这个树状结构变得明确（见 [图 2-2](../img/fig2-2.png)）。
![](../img/fig2-2.png)
**图 2-2 一对多关系构建了一个树结构**
### 多对一和多对多的关系
在上一节的 [例 2-1]() 中，`region_id` 和 `industry_id` 是以 ID，而不是纯字串 “Greater Seattle Area” 和 “Philanthropy” 的形式给出的。为什么？
如果使用者介面用一个自由文字栏位来输入区域和行业，那么将他们储存为纯文字字串是合理的。另一方式是给出地理区域和行业的标准化的列表，并让使用者从下拉列表或自动填充器中进行选择，其优势如下：
* 各个简介之间样式和拼写统一
* 避免歧义（例如，如果有几个同名的城市）
* 易于更新 —— 名称只储存在一个地方，如果需要更改（例如，由于政治事件而改变城市名称），很容易进行全面更新。
* 本地化支援 —— 当网站翻译成其他语言时，标准化的列表可以被本地化，使得地区和行业可以使用使用者的语言来显示
* 更好的搜寻 —— 例如，搜寻华盛顿州的慈善家就会匹配这份简介，因为地区列表可以编码记录西雅图在华盛顿这一事实（从 “Greater Seattle Area” 这个字串中看不出来）
储存 ID 还是文字字串，这是个 **副本（duplication）** 问题。当使用 ID 时，对人类有意义的资讯（比如单词：Philanthropy）只储存在一处，所有引用它的地方使用 ID（ID 只在资料库中有意义）。当直接储存文字时，对人类有意义的资讯会复制在每处使用记录中。
使用 ID 的好处是，ID 对人类没有任何意义，因而永远不需要改变：ID 可以保持不变，即使它标识的资讯发生变化。任何对人类有意义的东西都可能需要在将来某个时候改变 —— 如果这些资讯被复制，所有的冗余副本都需要更新。这会导致写入开销，也存在不一致的风险（一些副本被更新了，还有些副本没有被更新）。去除此类重复是资料库 **规范化（normalization）** 的关键思想。[^ii]
[^ii]: 关于关系模型的文献区分了几种不同的规范形式，但这些区别几乎没有实际意义。一个经验法则是，如果重复储存了可以储存在一个地方的值，则模式就不是 **规范化（normalized）** 的。
> 资料库管理员和开发人员喜欢争论规范化和非规范化，让我们暂时保留判断吧。在本书的 [第三部分](part-iii.md)，我们将回到这个话题，探讨系统的方法用以处理快取，非规范化和衍生资料。
不幸的是，对这些资料进行规范化需要多对一的关系（许多人生活在一个特定的地区，许多人在一个特定的行业工作），这与文件模型不太吻合。在关系资料库中，透过 ID 来引用其他表中的行是正常的，因为连线很容易。在文件资料库中，一对多树结构没有必要用连线，对连线的支援通常很弱 [^iii]。
[^iii]: 在撰写本文时，RethinkDB 支援连线，MongoDB 不支援连线，而 CouchDB 只支援预先宣告的检视。
如果资料库本身不支援连线，则必须在应用程式程式码中透过对资料库进行多个查询来模拟连线。（在这种情况中，地区和行业的列表可能很小，改动很少，应用程式可以简单地将其储存在记忆体中。不过，执行连线的工作从资料库被转移到应用程式程式码上。）
此外，即便应用程式的最初版本适合无连线的文件模型，随著功能新增到应用程式中，资料会变得更加互联。例如，考虑一下对简历例子进行的一些修改：
* 组织和学校作为实体
  在前面的描述中，`organization`（使用者工作的公司）和 `school_name`（他们学习的地方）只是字串。也许他们应该是对实体的引用呢？然后，每个组织、学校或大学都可以拥有自己的网页（标识、新闻提要等）。每个简历可以连结到它所提到的组织和学校，并且包括他们的图示和其他资讯（请参阅 [图 2-3](../img/fig2-3.png)，来自 LinkedIn 的一个例子）。
* 推荐
  假设你想新增一个新的功能：一个使用者可以为另一个使用者写一个推荐。在使用者的简历上显示推荐，并附上推荐使用者的姓名和照片。如果推荐人更新他们的照片，那他们写的任何推荐都需要显示新的照片。因此，推荐应该拥有作者个人简介的引用。
![](../img/fig2-3.png)
**图 2-3 公司名不仅是字串，还是一个指向公司实体的连结（LinkedIn 截图）**
[图 2-4](../img/fig2-4.png) 阐明了这些新功能需要如何使用多对多关系。每个虚线矩形内的资料可以分组成一个文件，但是对单位，学校和其他使用者的引用需要表示成引用，并且在查询时需要连线。
![](../img/fig2-4.png)
**图 2-4 使用多对多关系扩充套件简历**
### 文件资料库是否在重蹈覆辙？
在多对多的关系和连线已常规用在关系资料库时，文件资料库和 NoSQL 重启了辩论：如何以最佳方式在资料库中表示多对多关系。那场辩论可比 NoSQL 古老得多，事实上，最早可以追溯到计算机化资料库系统。
20 世纪 70 年代最受欢迎的业务资料处理资料库是 IBM 的资讯管理系统（IMS），最初是为了阿波罗太空计划的库存管理而开发的，并于 1968 年有了首次商业释出【13】。目前它仍在使用和维护，执行在 IBM 大型机的 OS/390 上【14】。
IMS 的设计中使用了一个相当简单的资料模型，称为 **层次模型（hierarchical model）**，它与文件资料库使用的 JSON 模型有一些惊人的相似之处【2】。它将所有资料表示为巢状在记录中的记录树，这很像 [图 2-2](../img/fig2-2.png) 的 JSON 结构。
同文档资料库一样，IMS 能良好处理一对多的关系，但是很难应对多对多的关系，并且不支援连线。开发人员必须决定是否复制（非规范化）资料或手动解决从一个记录到另一个记录的引用。这些二十世纪六七十年代的问题与现在开发人员遇到的文件资料库问题非常相似【15】。
那时人们提出了各种不同的解决方案来解决层次模型的局限性。其中最突出的两个是 **关系模型**（relational model，它变成了 SQL，并统治了世界）和 **网状模型**（network model，最初很受关注，但最终变得冷门）。这两个阵营之间的 “大辩论” 在 70 年代持续了很久时间【2】。
那两个模式解决的问题与当前的问题相关，因此值得简要回顾一下那场辩论。
#### 网状模型
网状模型由一个称为资料系统语言会议（CODASYL）的委员会进行了标准化，并被数个不同的资料库厂商实现；它也被称为 CODASYL 模型【16】。
CODASYL 模型是层次模型的推广。在层次模型的树结构中，每条记录只有一个父节点；在网路模式中，每条记录可能有多个父节点。例如，“Greater Seattle Area” 地区可能是一条记录，每个居住在该地区的使用者都可以与之相关联。这允许对多对一和多对多的关系进行建模。
网状模型中记录之间的连结不是外来键，而更像程式语言中的指标（同时仍然储存在磁碟上）。访问记录的唯一方法是跟随从根记录起沿这些链路所形成的路径。这被称为 **访问路径（access path）**。
最简单的情况下，访问路径类似遍历连结串列：从列表头开始，每次检视一条记录，直到找到所需的记录。但在多对多关系的情况中，数条不同的路径可以到达相同的记录，网状模型的程式设计师必须跟踪这些不同的访问路径。
CODASYL 中的查询是透过利用遍历记录列和跟随访问路径表在资料库中移动游标来执行的。如果记录有多个父结点（即多个来自其他记录的传入指标），则应用程式程式码必须跟踪所有的各种关系。甚至 CODASYL 委员会成员也承认，这就像在 n 维资料空间中进行导航【17】。
尽管手动选择访问路径能够最有效地利用 20 世纪 70 年代非常有限的硬体功能（如磁带驱动器，其搜寻速度非常慢），但这使得查询和更新资料库的程式码变得复杂不灵活。无论是分层还是网状模型，如果你没有所需资料的路径，就会陷入困境。你可以改变访问路径，但是必须浏览大量手写资料库查询程式码，并重写来处理新的访问路径。更改应用程式的资料模型是很难的。
#### 关系模型
相比之下，关系模型做的就是将所有的资料放在光天化日之下：一个 **关系（表）** 只是一个 **元组（行）** 的集合，仅此而已。如果你想读取资料，它没有迷宫似的巢状结构，也没有复杂的访问路径。你可以选中符合任意条件的行，读取表中的任何或所有行。你可以透过指定某些列作为匹配关键字来读取特定行。你可以在任何表中插入一个新的行，而不必担心与其他表的外来键关系 [^iv]。
[^iv]: 外来键约束允许对修改进行限制，但对于关系模型这并不是必选项。即使有约束，外来键连线在查询时执行，而在 CODASYL 中，连线在插入时高效完成。
在关系资料库中，查询最佳化器自动决定查询的哪些部分以哪个顺序执行，以及使用哪些索引。这些选择实际上是 “访问路径”，但最大的区别在于它们是由查询最佳化器自动生成的，而不是由程式设计师生成，所以我们很少需要考虑它们。
如果想按新的方式查询资料，你可以宣告一个新的索引，查询会自动使用最合适的那些索引。无需更改查询来利用新的索引（请参阅 “[资料查询语言](#资料查询语言)”）。关系模型因此使新增应用程式新功能变得更加容易。
关系资料库的查询最佳化器是复杂的，已耗费了多年的研究和开发精力【18】。关系模型的一个关键洞察是：只需构建一次查询最佳化器，随后使用该资料库的所有应用程式都可以从中受益。如果你没有查询最佳化器的话，那么为特定查询手动编写访问路径比编写通用最佳化器更容易 —— 不过从长期看通用解决方案更好。
#### 与文件资料库相比
在一个方面，文件资料库还原为层次模型：在其父记录中储存巢状记录（[图 2-1](../img/fig2-1.png) 中的一对多关系，如 `positions`，`education` 和 `contact_info`），而不是在单独的表中。